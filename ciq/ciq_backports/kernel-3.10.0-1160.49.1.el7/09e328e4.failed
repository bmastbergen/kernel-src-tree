RDMA/ucma: Fix the locking of ctx->file

jira LE-1907
cve CVE-2020-36385
Rebuild_History Non-Buildable kernel-3.10.0-1160.49.1.el7
commit-author Jason Gunthorpe <jgg@nvidia.com>
commit 09e328e47a695b0d346598f5d6593ee598e64885
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.49.1.el7/09e328e4.failed

ctx->file is changed under the file->mut lock by ucma_migrate_id(), which
is impossible to lock correctly. Instead change ctx->file under the
handler_lock and ctx_table lock and revise all places touching ctx->file
to use this locking when reading ctx->file.

Link: https://lore.kernel.org/r/20200818120526.702120-9-leon@kernel.org
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 09e328e47a695b0d346598f5d6593ee598e64885)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/ucma.c
diff --cc drivers/infiniband/core/ucma.c
index 55e2907d69af,f7ec71225e87..000000000000
--- a/drivers/infiniband/core/ucma.c
+++ b/drivers/infiniband/core/ucma.c
@@@ -552,6 -547,8 +552,11 @@@ static void ucma_cleanup_mc_events(stru
  {
  	struct ucma_event *uevent, *tmp;
  
++<<<<<<< HEAD
++=======
+ 	rdma_lock_handler(mc->ctx->cm_id);
+ 	mutex_lock(&mc->ctx->file->mut);
++>>>>>>> 09e328e47a69 (RDMA/ucma: Fix the locking of ctx->file)
  	list_for_each_entry_safe(uevent, tmp, &mc->ctx->file->event_list, list) {
  		if (uevent->mc != mc)
  			continue;
@@@ -559,6 -556,8 +564,11 @@@
  		list_del(&uevent->list);
  		kfree(uevent);
  	}
++<<<<<<< HEAD
++=======
+ 	mutex_unlock(&mc->ctx->file->mut);
+ 	rdma_unlock_handler(mc->ctx->cm_id);
++>>>>>>> 09e328e47a69 (RDMA/ucma: Fix the locking of ctx->file)
  }
  
  /*
@@@ -1545,17 -1598,17 +1555,17 @@@ static ssize_t ucma_leave_multicast(str
  	if (copy_from_user(&cmd, inbuf, sizeof(cmd)))
  		return -EFAULT;
  
 -	xa_lock(&multicast_table);
 -	mc = xa_load(&multicast_table, cmd.id);
 +	mutex_lock(&mut);
 +	mc = idr_find(&multicast_idr, cmd.id);
  	if (!mc)
  		mc = ERR_PTR(-ENOENT);
- 	else if (mc->ctx->file != file)
+ 	else if (READ_ONCE(mc->ctx->file) != file)
  		mc = ERR_PTR(-EINVAL);
 -	else if (!refcount_inc_not_zero(&mc->ctx->ref))
 +	else if (!atomic_inc_not_zero(&mc->ctx->ref))
  		mc = ERR_PTR(-ENXIO);
  	else
 -		__xa_erase(&multicast_table, mc->id);
 -	xa_unlock(&multicast_table);
 +		idr_remove(&multicast_idr, mc->id);
 +	mutex_unlock(&mut);
  
  	if (IS_ERR(mc)) {
  		ret = PTR_ERR(mc);
* Unmerged path drivers/infiniband/core/ucma.c
