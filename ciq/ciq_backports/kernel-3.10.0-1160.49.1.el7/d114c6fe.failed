RDMA/cma: Add missing locking to rdma_accept()

jira LE-1907
cve CVE-2020-36385
Rebuild_History Non-Buildable kernel-3.10.0-1160.49.1.el7
commit-author Jason Gunthorpe <jgg@nvidia.com>
commit d114c6feedfe0600c19b9f9479a4026354d1f7fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.49.1.el7/d114c6fe.failed

In almost all cases rdma_accept() is called under the handler_mutex by
ULPs from their handler callbacks. The one exception was ucma which did
not get the handler_mutex.

To improve the understand-ability of the locking scheme obtain the mutex
for ucma as well.

This improves how ucma works by allowing it to directly use handler_mutex
for some of its internal locking against the handler callbacks intead of
the global file->mut lock.

There does not seem to be a serious bug here, other than a DISCONNECT event
can be delivered concurrently with accept succeeding.

Link: https://lore.kernel.org/r/20200818120526.702120-7-leon@kernel.org
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit d114c6feedfe0600c19b9f9479a4026354d1f7fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cma.c
#	drivers/infiniband/core/ucma.c
#	include/rdma/rdma_cm.h
diff --cc drivers/infiniband/core/cma.c
index d9c39b6f4781,78641858abe2..000000000000
--- a/drivers/infiniband/core/cma.c
+++ b/drivers/infiniband/core/cma.c
@@@ -3997,6 -4202,37 +3998,40 @@@ reject
  }
  EXPORT_SYMBOL(__rdma_accept);
  
++<<<<<<< HEAD
++=======
+ int __rdma_accept_ece(struct rdma_cm_id *id, struct rdma_conn_param *conn_param,
+ 		      const char *caller, struct rdma_ucm_ece *ece)
+ {
+ 	struct rdma_id_private *id_priv =
+ 		container_of(id, struct rdma_id_private, id);
+ 
+ 	id_priv->ece.vendor_id = ece->vendor_id;
+ 	id_priv->ece.attr_mod = ece->attr_mod;
+ 
+ 	return __rdma_accept(id, conn_param, caller);
+ }
+ EXPORT_SYMBOL(__rdma_accept_ece);
+ 
+ void rdma_lock_handler(struct rdma_cm_id *id)
+ {
+ 	struct rdma_id_private *id_priv =
+ 		container_of(id, struct rdma_id_private, id);
+ 
+ 	mutex_lock(&id_priv->handler_mutex);
+ }
+ EXPORT_SYMBOL(rdma_lock_handler);
+ 
+ void rdma_unlock_handler(struct rdma_cm_id *id)
+ {
+ 	struct rdma_id_private *id_priv =
+ 		container_of(id, struct rdma_id_private, id);
+ 
+ 	mutex_unlock(&id_priv->handler_mutex);
+ }
+ EXPORT_SYMBOL(rdma_unlock_handler);
+ 
++>>>>>>> d114c6feedfe (RDMA/cma: Add missing locking to rdma_accept())
  int rdma_notify(struct rdma_cm_id *id, enum ib_event_type event)
  {
  	struct rdma_id_private *id_priv;
diff --cc drivers/infiniband/core/ucma.c
index 55e2907d69af,add1ece38739..000000000000
--- a/drivers/infiniband/core/ucma.c
+++ b/drivers/infiniband/core/ucma.c
@@@ -1139,18 -1155,27 +1139,32 @@@ static ssize_t ucma_accept(struct ucma_
  	if (IS_ERR(ctx))
  		return PTR_ERR(ctx);
  
 -	if (offsetofend(typeof(cmd), ece) <= in_size) {
 -		ece.vendor_id = cmd.ece.vendor_id;
 -		ece.attr_mod = cmd.ece.attr_mod;
 -	}
 -
  	if (cmd.conn_param.valid) {
  		ucma_copy_conn_param(ctx->cm_id, &conn_param, &cmd.conn_param);
- 		mutex_lock(&file->mut);
  		mutex_lock(&ctx->mutex);
++<<<<<<< HEAD
 +		ret = __rdma_accept(ctx->cm_id, &conn_param, NULL);
 +		mutex_unlock(&ctx->mutex);
 +		if (!ret)
++=======
+ 		rdma_lock_handler(ctx->cm_id);
+ 		ret = __rdma_accept_ece(ctx->cm_id, &conn_param, NULL, &ece);
+ 		if (!ret) {
+ 			/* The uid must be set atomically with the handler */
++>>>>>>> d114c6feedfe (RDMA/cma: Add missing locking to rdma_accept())
  			ctx->uid = cmd.uid;
- 		mutex_unlock(&file->mut);
+ 		}
+ 		rdma_unlock_handler(ctx->cm_id);
+ 		mutex_unlock(&ctx->mutex);
  	} else {
  		mutex_lock(&ctx->mutex);
++<<<<<<< HEAD
 +		ret = __rdma_accept(ctx->cm_id, NULL, NULL);
++=======
+ 		rdma_lock_handler(ctx->cm_id);
+ 		ret = __rdma_accept_ece(ctx->cm_id, NULL, NULL, &ece);
+ 		rdma_unlock_handler(ctx->cm_id);
++>>>>>>> d114c6feedfe (RDMA/cma: Add missing locking to rdma_accept())
  		mutex_unlock(&ctx->mutex);
  	}
  	ucma_put_ctx(ctx);
diff --cc include/rdma/rdma_cm.h
index 60987a5903b7,c1334c9a7aa8..000000000000
--- a/include/rdma/rdma_cm.h
+++ b/include/rdma/rdma_cm.h
@@@ -276,6 -253,11 +276,14 @@@ int rdma_listen(struct rdma_cm_id *id, 
  int __rdma_accept(struct rdma_cm_id *id, struct rdma_conn_param *conn_param,
  		  const char *caller);
  
++<<<<<<< HEAD
++=======
+ void rdma_lock_handler(struct rdma_cm_id *id);
+ void rdma_unlock_handler(struct rdma_cm_id *id);
+ int __rdma_accept_ece(struct rdma_cm_id *id, struct rdma_conn_param *conn_param,
+ 		      const char *caller, struct rdma_ucm_ece *ece);
+ 
++>>>>>>> d114c6feedfe (RDMA/cma: Add missing locking to rdma_accept())
  /**
   * rdma_accept - Called to accept a connection request or response.
   * @id: Connection identifier associated with the request.
* Unmerged path drivers/infiniband/core/cma.c
* Unmerged path drivers/infiniband/core/ucma.c
* Unmerged path include/rdma/rdma_cm.h
