nvme-pci: Don't disable on timeout in reset state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.49.1.el7
commit-author Keith Busch <keith.busch@intel.com>
commit 39a9dd81f864aa20be896bb34b4bbc2501a2453d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.49.1.el7/39a9dd81.failed

The reset state doesn't dispatch commands that it needs to wait for
anymore. If a timeout occurs in this state, the reset work is already
disabling the controller, so just reset the request's timer.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Keith Busch <keith.busch@intel.com>
(cherry picked from commit 39a9dd81f864aa20be896bb34b4bbc2501a2453d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/pci.c
diff --cc drivers/nvme/host/pci.c
index 7e300a01dee5,c72755311ffa..000000000000
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@@ -1022,14 -1296,16 +1022,19 @@@ static enum blk_eh_timer_return nvme_ti
  	switch (dev->ctrl.state) {
  	case NVME_CTRL_DELETING:
  		shutdown = true;
 -		/* fall through */
  	case NVME_CTRL_CONNECTING:
- 	case NVME_CTRL_RESETTING:
  		dev_warn_ratelimited(dev->ctrl.device,
  			 "I/O %d QID %d timeout, disable controller\n",
  			 req->tag, nvmeq->qid);
  		nvme_dev_disable(dev, shutdown);
  		nvme_req(req)->flags |= NVME_REQ_CANCELLED;
++<<<<<<< HEAD
 +		return BLK_EH_NOT_HANDLED;
++=======
+ 		return BLK_EH_DONE;
+ 	case NVME_CTRL_RESETTING:
+ 		return BLK_EH_RESET_TIMER;
++>>>>>>> 39a9dd81f864 (nvme-pci: Don't disable on timeout in reset state)
  	default:
  		break;
  	}
* Unmerged path drivers/nvme/host/pci.c
