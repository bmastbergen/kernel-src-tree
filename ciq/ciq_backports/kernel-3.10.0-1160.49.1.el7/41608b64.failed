PCI: hv: Fix sleep while in non-sleep context when removing child devices from the bus

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.49.1.el7
commit-author Long Li <longli@microsoft.com>
commit 41608b64b10b80fe00dd253cd8326ec8ad85930f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.49.1.el7/41608b64.failed

In hv_pci_bus_exit, the code is holding a spinlock while calling
pci_destroy_slot(), which takes a mutex.

This is not safe for spinlock. Fix this by moving the children to be
deleted to a list on the stack, and removing them after spinlock is
released.

Fixes: 94d22763207a ("PCI: hv: Fix a race condition when removing the device")

	Cc: "K. Y. Srinivasan" <kys@microsoft.com>
	Cc: Haiyang Zhang <haiyangz@microsoft.com>
	Cc: Stephen Hemminger <sthemmin@microsoft.com>
	Cc: Wei Liu <wei.liu@kernel.org>
	Cc: Dexuan Cui <decui@microsoft.com>
	Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
	Cc: Rob Herring <robh@kernel.org>
	Cc: "Krzysztof Wilczy≈Ñski" <kw@linux.com>
	Cc: Bjorn Helgaas <bhelgaas@google.com>
	Cc: Michael Kelley <mikelley@microsoft.com>
	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
Link: https://lore.kernel.org/linux-hyperv/20210823152130.GA21501@kili/
	Signed-off-by: Long Li <longli@microsoft.com>
	Reviewed-by: Wei Liu <wei.liu@kernel.org>
Link: https://lore.kernel.org/r/1630365207-20616-1-git-send-email-longli@linuxonhyperv.com
	Signed-off-by: Wei Liu <wei.liu@kernel.org>
(cherry picked from commit 41608b64b10b80fe00dd253cd8326ec8ad85930f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pci-hyperv.c
diff --cc drivers/pci/pci-hyperv.c
index 15ab10058bb9,fc1a29acadbb..000000000000
--- a/drivers/pci/pci-hyperv.c
+++ b/drivers/pci/pci-hyperv.c
@@@ -2844,17 -3226,35 +2844,40 @@@ static void hv_pci_bus_exit(struct hv_d
  	 * access the per-channel ringbuffer any longer.
  	 */
  	if (hdev->channel->rescind)
 -		return 0;
 +		return;
  
++<<<<<<< HEAD:drivers/pci/pci-hyperv.c
 +	/* Delete any children which might still exist. */
 +	dr = kzalloc(sizeof(*dr), GFP_KERNEL);
 +	if (dr && hv_pci_start_relations_work(hbus, dr))
 +		kfree(dr);
++=======
+ 	if (!keep_devs) {
+ 		struct list_head removed;
+ 
+ 		/* Move all present children to the list on stack */
+ 		INIT_LIST_HEAD(&removed);
+ 		spin_lock_irqsave(&hbus->device_list_lock, flags);
+ 		list_for_each_entry_safe(hpdev, tmp, &hbus->children, list_entry)
+ 			list_move_tail(&hpdev->list_entry, &removed);
+ 		spin_unlock_irqrestore(&hbus->device_list_lock, flags);
+ 
+ 		/* Remove all children in the list */
+ 		list_for_each_entry_safe(hpdev, tmp, &removed, list_entry) {
+ 			list_del(&hpdev->list_entry);
+ 			if (hpdev->pci_slot)
+ 				pci_destroy_slot(hpdev->pci_slot);
+ 			/* For the two refs got in new_pcichild_device() */
+ 			put_pcichild(hpdev);
+ 			put_pcichild(hpdev);
+ 		}
+ 	}
++>>>>>>> 41608b64b10b (PCI: hv: Fix sleep while in non-sleep context when removing child devices from the bus):drivers/pci/controller/pci-hyperv.c
  
  	ret = hv_send_resources_released(hdev);
 -	if (ret) {
 +	if (ret)
  		dev_err(&hdev->device,
  			"Couldn't send resources released packet(s)\n");
 -		return ret;
 -	}
  
  	memset(&pkt.teardown_packet, 0, sizeof(pkt.teardown_packet));
  	init_completion(&comp_pkt.host_event);
* Unmerged path drivers/pci/pci-hyperv.c
