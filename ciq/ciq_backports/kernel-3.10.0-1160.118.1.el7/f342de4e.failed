netfilter: nf_tables: reject QUEUE/DROP verdict parameters

jira LE-1907
cve CVE-2024-1086
Rebuild_History Non-Buildable kernel-3.10.0-1160.118.1.el7
commit-author Florian Westphal <fw@strlen.de>
commit f342de4e2f33e0e39165d8639387aa6c19dff660
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.118.1.el7/f342de4e.failed

This reverts commit e0abdadcc6e1.

core.c:nf_hook_slow assumes that the upper 16 bits of NF_DROP
verdicts contain a valid errno, i.e. -EPERM, -EHOSTUNREACH or similar,
or 0.

Due to the reverted commit, its possible to provide a positive
value, e.g. NF_ACCEPT (1), which results in use-after-free.

Its not clear to me why this commit was made.

NF_QUEUE is not used by nftables; "queue" rules in nftables
will result in use of "nft_queue" expression.

If we later need to allow specifiying errno values from userspace
(do not know why), this has to call NF_DROP_GETERR and check that
"err <= 0" holds true.

Fixes: e0abdadcc6e1 ("netfilter: nf_tables: accept QUEUE/DROP verdict parameters")
	Cc: stable@vger.kernel.org
	Reported-by: Notselwyn <notselwyn@pwning.tech>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit f342de4e2f33e0e39165d8639387aa6c19dff660)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index 82b8f8388670,c537104411e7..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -4571,34 -10989,49 +4571,43 @@@ static int nft_verdict_init(const struc
  	data->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));
  
  	switch (data->verdict.code) {
++<<<<<<< HEAD
 +	default:
 +		switch (data->verdict.code & NF_VERDICT_MASK) {
 +		case NF_ACCEPT:
 +		case NF_DROP:
 +		case NF_QUEUE:
 +			break;
 +		default:
 +			return -EINVAL;
 +		}
 +		/* fall through */
++=======
+ 	case NF_ACCEPT:
+ 	case NF_DROP:
+ 	case NF_QUEUE:
+ 		break;
++>>>>>>> f342de4e2f33 (netfilter: nf_tables: reject QUEUE/DROP verdict parameters)
  	case NFT_CONTINUE:
  	case NFT_BREAK:
  	case NFT_RETURN:
  		break;
  	case NFT_JUMP:
  	case NFT_GOTO:
 -		if (tb[NFTA_VERDICT_CHAIN]) {
 -			chain = nft_chain_lookup(ctx->net, ctx->table,
 -						 tb[NFTA_VERDICT_CHAIN],
 -						 genmask);
 -		} else if (tb[NFTA_VERDICT_CHAIN_ID]) {
 -			chain = nft_chain_lookup_byid(ctx->net, ctx->table,
 -						      tb[NFTA_VERDICT_CHAIN_ID],
 -						      genmask);
 -			if (IS_ERR(chain))
 -				return PTR_ERR(chain);
 -		} else {
 +		if (!tb[NFTA_VERDICT_CHAIN])
  			return -EINVAL;
 -		}
 -
 +		chain = nf_tables_chain_lookup(ctx->table,
 +					       tb[NFTA_VERDICT_CHAIN]);
  		if (IS_ERR(chain))
  			return PTR_ERR(chain);
 -		if (nft_is_base_chain(chain))
 +		if (chain->flags & NFT_BASE_CHAIN)
  			return -EOPNOTSUPP;
 -		if (nft_chain_is_bound(chain))
 -			return -EINVAL;
 -		if (desc->flags & NFT_DATA_DESC_SETELEM &&
 -		    chain->flags & NFT_CHAIN_BINDING)
 -			return -EINVAL;
 -		if (!nft_use_inc(&chain->use))
 -			return -EMFILE;
  
 +		chain->use++;
  		data->verdict.chain = chain;
  		break;
+ 	default:
+ 		return -EINVAL;
  	}
  
  	desc->len = sizeof(data->verdict);
* Unmerged path net/netfilter/nf_tables_api.c
