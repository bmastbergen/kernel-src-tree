ceph: switch to use cap_delay_lock for the unlink delay list

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-427.18.1.el9_4
commit-author Xiubo Li <xiubli@redhat.com>
commit 17f8dc2db52185460f212052f3a692c1fdc167ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.18.1.el9_4/17f8dc2d.failed

The same list item will be used in both cap_delay_list and
cap_unlink_delay_list, so it's buggy to use two different locks
to protect them.

	Cc: stable@vger.kernel.org
Fixes: dbc347ef7f0c ("ceph: add ceph_cap_unlink_work to fire check_caps() immediately")
Link: https://lists.ceph.io/hyperkitty/list/ceph-users@ceph.io/thread/AODC76VXRAMXKLFDCTK4TKFDDPWUSCN5
	Reported-by: Marc Ruhmann <ruhmann@luis.uni-hannover.de>
	Signed-off-by: Xiubo Li <xiubli@redhat.com>
	Reviewed-by: Ilya Dryomov <idryomov@gmail.com>
	Tested-by: Marc Ruhmann <ruhmann@luis.uni-hannover.de>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 17f8dc2db52185460f212052f3a692c1fdc167ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/mds_client.c
diff --cc fs/ceph/mds_client.c
index cd0677d27683,360b686c3c67..000000000000
--- a/fs/ceph/mds_client.c
+++ b/fs/ceph/mds_client.c
@@@ -2293,9 -2501,10 +2293,14 @@@ static void ceph_cap_unlink_work(struc
  {
  	struct ceph_mds_client *mdsc =
  		container_of(work, struct ceph_mds_client, cap_unlink_work);
 -	struct ceph_client *cl = mdsc->fsc->client;
  
++<<<<<<< HEAD
 +	dout("begin\n");
 +	spin_lock(&mdsc->cap_unlink_delay_lock);
++=======
+ 	doutc(cl, "begin\n");
+ 	spin_lock(&mdsc->cap_delay_lock);
++>>>>>>> 17f8dc2db521 (ceph: switch to use cap_delay_lock for the unlink delay list)
  	while (!list_empty(&mdsc->cap_unlink_delay_list)) {
  		struct ceph_inode_info *ci;
  		struct inode *inode;
@@@ -2307,16 -2516,16 +2312,26 @@@
  
  		inode = igrab(&ci->netfs.inode);
  		if (inode) {
++<<<<<<< HEAD
 +			spin_unlock(&mdsc->cap_unlink_delay_lock);
 +			dout("on %p %llx.%llx\n", inode,
++=======
+ 			spin_unlock(&mdsc->cap_delay_lock);
+ 			doutc(cl, "on %p %llx.%llx\n", inode,
++>>>>>>> 17f8dc2db521 (ceph: switch to use cap_delay_lock for the unlink delay list)
  			      ceph_vinop(inode));
 -			ceph_check_caps(ci, CHECK_CAPS_FLUSH);
 +			ceph_check_caps(ci, CHECK_CAPS_FLUSH, NULL);
  			iput(inode);
- 			spin_lock(&mdsc->cap_unlink_delay_lock);
+ 			spin_lock(&mdsc->cap_delay_lock);
  		}
  	}
++<<<<<<< HEAD
 +	spin_unlock(&mdsc->cap_unlink_delay_lock);
 +	dout("done\n");
++=======
+ 	spin_unlock(&mdsc->cap_delay_lock);
+ 	doutc(cl, "done\n");
++>>>>>>> 17f8dc2db521 (ceph: switch to use cap_delay_lock for the unlink delay list)
  }
  
  /*
diff --git a/fs/ceph/caps.c b/fs/ceph/caps.c
index 54545c7f565a..c337c1643906 100644
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@ -4530,13 +4530,13 @@ int ceph_drop_caps_for_unlink(struct inode *inode)
 
 			dout("%p %llx.%llx\n", inode,
 			      ceph_vinop(inode));
-			spin_lock(&mdsc->cap_unlink_delay_lock);
+			spin_lock(&mdsc->cap_delay_lock);
 			ci->i_ceph_flags |= CEPH_I_FLUSH;
 			if (!list_empty(&ci->i_cap_delay_list))
 				list_del_init(&ci->i_cap_delay_list);
 			list_add_tail(&ci->i_cap_delay_list,
 				      &mdsc->cap_unlink_delay_list);
-			spin_unlock(&mdsc->cap_unlink_delay_lock);
+			spin_unlock(&mdsc->cap_delay_lock);
 
 			/*
 			 * Fire the work immediately, because the MDS maybe
* Unmerged path fs/ceph/mds_client.c
diff --git a/fs/ceph/mds_client.h b/fs/ceph/mds_client.h
index b95446ac7620..512b84432de6 100644
--- a/fs/ceph/mds_client.h
+++ b/fs/ceph/mds_client.h
@@ -428,9 +428,8 @@ struct ceph_mds_client {
 	struct delayed_work    delayed_work;  /* delayed work */
 	unsigned long    last_renew_caps;  /* last time we renewed our caps */
 	struct list_head cap_delay_list;   /* caps with delayed release */
-	spinlock_t       cap_delay_lock;   /* protects cap_delay_list */
 	struct list_head cap_unlink_delay_list;  /* caps with delayed release for unlink */
-	spinlock_t       cap_unlink_delay_lock;  /* protects cap_unlink_delay_list */
+	spinlock_t       cap_delay_lock;   /* protects cap_delay_list and cap_unlink_delay_list */
 	struct list_head snap_flush_list;  /* cap_snaps ready to flush */
 	spinlock_t       snap_flush_lock;
 
