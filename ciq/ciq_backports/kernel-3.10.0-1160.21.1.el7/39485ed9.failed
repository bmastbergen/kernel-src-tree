KVM: x86: reinstate vendor-agnostic check on SPEC_CTRL cpuid bits

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.21.1.el7
Rebuild_CHGLOG: - [x86] kvm: reinstate vendor-agnostic check on SPEC_CTRL cpuid bits (Vitaly Kuznetsov) [1890669]
Rebuild_FUZZ: 96.00%
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 39485ed95d6b83b62fa75c06c2c4d33992e0d971
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.21.1.el7/39485ed9.failed

Until commit e7c587da1252 ("x86/speculation: Use synthetic bits for
IBRS/IBPB/STIBP"), KVM was testing both Intel and AMD CPUID bits before
allowing the guest to write MSR_IA32_SPEC_CTRL and MSR_IA32_PRED_CMD.
Testing only Intel bits on VMX processors, or only AMD bits on SVM
processors, fails if the guests are created with the "opposite" vendor
as the host.

While at it, also tweak the host CPU check to use the vendor-agnostic
feature bit X86_FEATURE_IBPB, since we only care about the availability
of the MSR on the host here and not about specific CPUID bits.

Fixes: e7c587da1252 ("x86/speculation: Use synthetic bits for IBRS/IBPB/STIBP")
	Cc: stable@vger.kernel.org
	Reported-by: Denis V. Lunev <den@openvz.org>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 39485ed95d6b83b62fa75c06c2c4d33992e0d971)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.h
#	arch/x86/kvm/svm/svm.c
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/cpuid.h
index c4996e57d10c,dc921d76e42e..000000000000
--- a/arch/x86/kvm/cpuid.h
+++ b/arch/x86/kvm/cpuid.h
@@@ -119,7 -226,116 +119,120 @@@ static inline bool guest_cpuid_is_amd(s
  	struct kvm_cpuid_entry2 *best;
  
  	best = kvm_find_cpuid_entry(vcpu, 0, 0);
++<<<<<<< HEAD
 +	return best && best->ebx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx;
++=======
+ 	return best &&
+ 	       (is_guest_vendor_amd(best->ebx, best->ecx, best->edx) ||
+ 		is_guest_vendor_hygon(best->ebx, best->ecx, best->edx));
+ }
+ 
+ static inline int guest_cpuid_family(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvm_cpuid_entry2 *best;
+ 
+ 	best = kvm_find_cpuid_entry(vcpu, 0x1, 0);
+ 	if (!best)
+ 		return -1;
+ 
+ 	return x86_family(best->eax);
+ }
+ 
+ static inline int guest_cpuid_model(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvm_cpuid_entry2 *best;
+ 
+ 	best = kvm_find_cpuid_entry(vcpu, 0x1, 0);
+ 	if (!best)
+ 		return -1;
+ 
+ 	return x86_model(best->eax);
+ }
+ 
+ static inline int guest_cpuid_stepping(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvm_cpuid_entry2 *best;
+ 
+ 	best = kvm_find_cpuid_entry(vcpu, 0x1, 0);
+ 	if (!best)
+ 		return -1;
+ 
+ 	return x86_stepping(best->eax);
+ }
+ 
+ static inline bool guest_has_spec_ctrl_msr(struct kvm_vcpu *vcpu)
+ {
+ 	return (guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL) ||
+ 		guest_cpuid_has(vcpu, X86_FEATURE_AMD_STIBP) ||
+ 		guest_cpuid_has(vcpu, X86_FEATURE_AMD_IBRS) ||
+ 		guest_cpuid_has(vcpu, X86_FEATURE_AMD_SSBD));
+ }
+ 
+ static inline bool guest_has_pred_cmd_msr(struct kvm_vcpu *vcpu)
+ {
+ 	return (guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL) ||
+ 		guest_cpuid_has(vcpu, X86_FEATURE_AMD_IBPB));
+ }
+ 
+ static inline bool supports_cpuid_fault(struct kvm_vcpu *vcpu)
+ {
+ 	return vcpu->arch.msr_platform_info & MSR_PLATFORM_INFO_CPUID_FAULT;
+ }
+ 
+ static inline bool cpuid_fault_enabled(struct kvm_vcpu *vcpu)
+ {
+ 	return vcpu->arch.msr_misc_features_enables &
+ 		  MSR_MISC_FEATURES_ENABLES_CPUID_FAULT;
+ }
+ 
+ static __always_inline void kvm_cpu_cap_clear(unsigned int x86_feature)
+ {
+ 	unsigned int x86_leaf = x86_feature / 32;
+ 
+ 	reverse_cpuid_check(x86_leaf);
+ 	kvm_cpu_caps[x86_leaf] &= ~__feature_bit(x86_feature);
+ }
+ 
+ static __always_inline void kvm_cpu_cap_set(unsigned int x86_feature)
+ {
+ 	unsigned int x86_leaf = x86_feature / 32;
+ 
+ 	reverse_cpuid_check(x86_leaf);
+ 	kvm_cpu_caps[x86_leaf] |= __feature_bit(x86_feature);
+ }
+ 
+ static __always_inline u32 kvm_cpu_cap_get(unsigned int x86_feature)
+ {
+ 	unsigned int x86_leaf = x86_feature / 32;
+ 
+ 	reverse_cpuid_check(x86_leaf);
+ 	return kvm_cpu_caps[x86_leaf] & __feature_bit(x86_feature);
+ }
+ 
+ static __always_inline bool kvm_cpu_cap_has(unsigned int x86_feature)
+ {
+ 	return !!kvm_cpu_cap_get(x86_feature);
+ }
+ 
+ static __always_inline void kvm_cpu_cap_check_and_set(unsigned int x86_feature)
+ {
+ 	if (boot_cpu_has(x86_feature))
+ 		kvm_cpu_cap_set(x86_feature);
+ }
+ 
+ static inline bool page_address_valid(struct kvm_vcpu *vcpu, gpa_t gpa)
+ {
+ 	return PAGE_ALIGNED(gpa) && !(gpa >> cpuid_maxphyaddr(vcpu));
+ }
+ 
+ static __always_inline bool guest_pv_has(struct kvm_vcpu *vcpu,
+ 					 unsigned int kvm_feature)
+ {
+ 	if (!vcpu->arch.pv_cpuid.enforce)
+ 		return true;
+ 
+ 	return vcpu->arch.pv_cpuid.features & (1u << kvm_feature);
++>>>>>>> 39485ed95d6b (KVM: x86: reinstate vendor-agnostic check on SPEC_CTRL cpuid bits)
  }
  
  #endif
* Unmerged path arch/x86/kvm/svm/svm.c
* Unmerged path arch/x86/kvm/vmx/vmx.c
* Unmerged path arch/x86/kvm/cpuid.h
* Unmerged path arch/x86/kvm/svm/svm.c
* Unmerged path arch/x86/kvm/vmx/vmx.c
