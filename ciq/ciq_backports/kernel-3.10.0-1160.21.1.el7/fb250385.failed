net-sysfs: take the rtnl lock when accessing xps_cpus_map and num_tc

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.21.1.el7
commit-author Antoine Tenart <atenart@kernel.org>
commit fb25038586d0064123e393cadf1fadd70a9df97a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.21.1.el7/fb250385.failed

Accesses to dev->xps_cpus_map (when using dev->num_tc) should be
protected by the rtnl lock, like we do for netif_set_xps_queue. I didn't
see an actual bug being triggered, but let's be safe here and take the
rtnl lock while accessing the map in sysfs.

Fixes: 184c449f91fe ("net: Add support for XPS with QoS via traffic classes")
	Signed-off-by: Antoine Tenart <atenart@kernel.org>
	Reviewed-by: Alexander Duyck <alexanderduyck@fb.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit fb25038586d0064123e393cadf1fadd70a9df97a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/net-sysfs.c
diff --cc net/core/net-sysfs.c
index b707b2ea036b,65886bfbf822..000000000000
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@@ -1172,29 -1314,48 +1172,47 @@@ static struct attribute_group dql_grou
  #endif /* CONFIG_BQL */
  
  #ifdef CONFIG_XPS
 -static ssize_t xps_cpus_show(struct netdev_queue *queue,
 -			     char *buf)
 +static ssize_t show_xps_map(struct netdev_queue *queue,
 +			    struct netdev_queue_attribute *attribute, char *buf)
  {
+ 	int cpu, len, ret, num_tc = 1, tc = 0;
  	struct net_device *dev = queue->dev;
- 	int cpu, len, num_tc = 1, tc = 0;
  	struct xps_dev_maps *dev_maps;
  	cpumask_var_t mask;
  	unsigned long index;
  
 -	if (!netif_is_multiqueue(dev))
 -		return -ENOENT;
 -
  	index = get_netdev_queue_index(queue);
  
+ 	if (!rtnl_trylock())
+ 		return restart_syscall();
+ 
  	if (dev->num_tc) {
 -		/* Do not allow XPS on subordinate device directly */
  		num_tc = dev->num_tc;
++<<<<<<< HEAD
++=======
+ 		if (num_tc < 0) {
+ 			ret = -EINVAL;
+ 			goto err_rtnl_unlock;
+ 		}
+ 
+ 		/* If queue belongs to subordinate dev use its map */
+ 		dev = netdev_get_tx_queue(dev, index)->sb_dev ? : dev;
+ 
++>>>>>>> fb25038586d0 (net-sysfs: take the rtnl lock when accessing xps_cpus_map and num_tc)
  		tc = netdev_txq_to_tc(dev, index);
- 		if (tc < 0)
- 			return -EINVAL;
+ 		if (tc < 0) {
+ 			ret = -EINVAL;
+ 			goto err_rtnl_unlock;
+ 		}
  	}
  
- 	if (!zalloc_cpumask_var(&mask, GFP_KERNEL))
- 		return -ENOMEM;
+ 	if (!zalloc_cpumask_var(&mask, GFP_KERNEL)) {
+ 		ret = -ENOMEM;
+ 		goto err_rtnl_unlock;
+ 	}
  
  	rcu_read_lock();
 -	dev_maps = rcu_dereference(dev->xps_cpus_map);
 +	dev_maps = rcu_dereference(dev->xps_maps);
  	if (dev_maps) {
  		for_each_possible_cpu(cpu) {
  			int i, tci = cpu * num_tc + tc;
@@@ -1217,11 -1380,14 +1237,15 @@@
  	len = snprintf(buf, PAGE_SIZE, "%*pb\n", cpumask_pr_args(mask));
  	free_cpumask_var(mask);
  	return len < PAGE_SIZE ? len : -EINVAL;
+ 
+ err_rtnl_unlock:
+ 	rtnl_unlock();
+ 	return ret;
  }
  
 -static ssize_t xps_cpus_store(struct netdev_queue *queue,
 -			      const char *buf, size_t len)
 +static ssize_t store_xps_map(struct netdev_queue *queue,
 +		      struct netdev_queue_attribute *attribute,
 +		      const char *buf, size_t len)
  {
  	struct net_device *dev = queue->dev;
  	unsigned long index;
* Unmerged path net/core/net-sysfs.c
