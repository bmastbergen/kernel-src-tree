geneve: add transport ports in route lookup for geneve

jira LE-1907
cve CVE-2020-25645
Rebuild_History Non-Buildable kernel-3.10.0-1160.21.1.el7
commit-author Mark Gray <mark.d.gray@redhat.com>
commit 34beb21594519ce64a55a498c2fe7d567bc1ca20
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.21.1.el7/34beb215.failed

This patch adds transport ports information for route lookup so that
IPsec can select Geneve tunnel traffic to do encryption. This is
needed for OVS/OVN IPsec with encrypted Geneve tunnels.

This can be tested by configuring a host-host VPN using an IKE
daemon and specifying port numbers. For example, for an
Openswan-type configuration, the following parameters should be
configured on both hosts and IPsec set up as-per normal:

$ cat /etc/ipsec.conf

conn in
...
left=$IP1
right=$IP2
...
leftprotoport=udp/6081
rightprotoport=udp
...
conn out
...
left=$IP1
right=$IP2
...
leftprotoport=udp
rightprotoport=udp/6081
...

The tunnel can then be setup using "ip" on both hosts (but
changing the relevant IP addresses):

$ ip link add tun type geneve id 1000 remote $IP2
$ ip addr add 192.168.0.1/24 dev tun
$ ip link set tun up

This can then be tested by pinging from $IP1:

$ ping 192.168.0.2

Without this patch the traffic is unencrypted on the wire.

Fixes: 2d07dc79fe04 ("geneve: add initial netdev driver for GENEVE tunnels")
	Signed-off-by: Qiuyu Xiao <qiuyu.xiao.qyx@gmail.com>
	Signed-off-by: Mark Gray <mark.d.gray@redhat.com>
	Reviewed-by: Greg Rose <gvrose8192@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 34beb21594519ce64a55a498c2fe7d567bc1ca20)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
diff --cc drivers/net/geneve.c
index 682a01ad1ddf,974a244f45ba..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -772,8 -775,10 +772,9 @@@ free_dst
  
  static struct rtable *geneve_get_v4_rt(struct sk_buff *skb,
  				       struct net_device *dev,
 -				       struct geneve_sock *gs4,
  				       struct flowi4 *fl4,
- 				       const struct ip_tunnel_info *info)
+ 				       const struct ip_tunnel_info *info,
+ 				       __be16 dport, __be16 sport)
  {
  	bool use_cache = ip_tunnel_dst_cache_usable(skb, info);
  	struct geneve_dev *geneve = netdev_priv(dev);
@@@ -789,9 -794,11 +790,11 @@@
  	fl4->flowi4_proto = IPPROTO_UDP;
  	fl4->daddr = info->key.u.ipv4.dst;
  	fl4->saddr = info->key.u.ipv4.src;
+ 	fl4->fl4_dport = dport;
+ 	fl4->fl4_sport = sport;
  
  	tos = info->key.tos;
 -	if ((tos == 1) && !geneve->cfg.collect_md) {
 +	if ((tos == 1) && !geneve->collect_md) {
  		tos = ip_tunnel_get_dsfield(ip_hdr(skb), skb);
  		use_cache = false;
  	}
@@@ -821,8 -828,10 +824,9 @@@
  #if IS_ENABLED(CONFIG_IPV6)
  static struct dst_entry *geneve_get_v6_dst(struct sk_buff *skb,
  					   struct net_device *dev,
 -					   struct geneve_sock *gs6,
  					   struct flowi6 *fl6,
- 					   const struct ip_tunnel_info *info)
+ 					   const struct ip_tunnel_info *info,
+ 					   __be16 dport, __be16 sport)
  {
  	bool use_cache = ip_tunnel_dst_cache_usable(skb, info);
  	struct geneve_dev *geneve = netdev_priv(dev);
@@@ -840,8 -847,11 +844,11 @@@
  	fl6->flowi6_proto = IPPROTO_UDP;
  	fl6->daddr = info->key.u.ipv6.dst;
  	fl6->saddr = info->key.u.ipv6.src;
+ 	fl6->fl6_dport = dport;
+ 	fl6->fl6_sport = sport;
+ 
  	prio = info->key.tos;
 -	if ((prio == 1) && !geneve->cfg.collect_md) {
 +	if ((prio == 1) && !geneve->collect_md) {
  		prio = ip_tunnel_get_dsfield(ip_hdr(skb), skb);
  		use_cache = false;
  	}
@@@ -882,26 -892,70 +889,36 @@@ static int geneve_xmit_skb(struct sk_bu
  	struct rtable *rt;
  	struct flowi4 fl4;
  	__u8 tos, ttl;
 -	__be16 df = 0;
  	__be16 sport;
 +	__be16 df;
  	int err;
  
++<<<<<<< HEAD
 +	rt = geneve_get_v4_rt(skb, dev, &fl4, info);
++=======
+ 	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
+ 	rt = geneve_get_v4_rt(skb, dev, gs4, &fl4, info,
+ 			      geneve->cfg.info.key.tp_dst, sport);
++>>>>>>> 34beb2159451 (geneve: add transport ports in route lookup for geneve)
  	if (IS_ERR(rt))
  		return PTR_ERR(rt);
  
 -	err = skb_tunnel_check_pmtu(skb, &rt->dst,
 -				    GENEVE_IPV4_HLEN + info->options_len,
 -				    netif_is_any_bridge_port(dev));
 -	if (err < 0) {
 -		dst_release(&rt->dst);
 -		return err;
 -	} else if (err) {
 -		struct ip_tunnel_info *info;
 -
 -		info = skb_tunnel_info(skb);
 -		if (info) {
 -			info->key.u.ipv4.dst = fl4.saddr;
 -			info->key.u.ipv4.src = fl4.daddr;
 -		}
 -
 -		if (!pskb_may_pull(skb, ETH_HLEN)) {
 -			dst_release(&rt->dst);
 -			return -EINVAL;
 -		}
 -
 -		skb->protocol = eth_type_trans(skb, geneve->dev);
 -		netif_rx(skb);
 -		dst_release(&rt->dst);
 -		return -EMSGSIZE;
 -	}
 +	skb_tunnel_check_pmtu(skb, &rt->dst,
 +			      GENEVE_IPV4_HLEN + info->options_len);
  
++<<<<<<< HEAD
 +	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
 +	if (geneve->collect_md) {
++=======
+ 	if (geneve->cfg.collect_md) {
++>>>>>>> 34beb2159451 (geneve: add transport ports in route lookup for geneve)
  		tos = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);
  		ttl = key->ttl;
 -
 -		df = key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;
  	} else {
  		tos = ip_tunnel_ecn_encap(fl4.flowi4_tos, ip_hdr(skb), skb);
 -		if (geneve->cfg.ttl_inherit)
 -			ttl = ip_tunnel_get_ttl(ip_hdr(skb), skb);
 -		else
 -			ttl = key->ttl;
 -		ttl = ttl ? : ip4_dst_hoplimit(&rt->dst);
 -
 -		if (geneve->cfg.df == GENEVE_DF_SET) {
 -			df = htons(IP_DF);
 -		} else if (geneve->cfg.df == GENEVE_DF_INHERIT) {
 -			struct ethhdr *eth = eth_hdr(skb);
 -
 -			if (ntohs(eth->h_proto) == ETH_P_IPV6) {
 -				df = htons(IP_DF);
 -			} else if (ntohs(eth->h_proto) == ETH_P_IP) {
 -				struct iphdr *iph = ip_hdr(skb);
 -
 -				if (iph->frag_off & htons(IP_DF))
 -					df = htons(IP_DF);
 -			}
 -		}
 +		ttl = key->ttl ? : ip4_dst_hoplimit(&rt->dst);
  	}
 +	df = key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;
  
  	err = geneve_build_skb(&rt->dst, skb, info, xnet, sizeof(struct iphdr));
  	if (unlikely(err))
@@@ -928,14 -982,38 +945,24 @@@ static int geneve6_xmit_skb(struct sk_b
  	__be16 sport;
  	int err;
  
++<<<<<<< HEAD
 +	dst = geneve_get_v6_dst(skb, dev, &fl6, info);
++=======
+ 	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
+ 	dst = geneve_get_v6_dst(skb, dev, gs6, &fl6, info,
+ 				geneve->cfg.info.key.tp_dst, sport);
++>>>>>>> 34beb2159451 (geneve: add transport ports in route lookup for geneve)
  	if (IS_ERR(dst))
  		return PTR_ERR(dst);
  
 -	err = skb_tunnel_check_pmtu(skb, dst,
 -				    GENEVE_IPV6_HLEN + info->options_len,
 -				    netif_is_any_bridge_port(dev));
 -	if (err < 0) {
 -		dst_release(dst);
 -		return err;
 -	} else if (err) {
 -		struct ip_tunnel_info *info = skb_tunnel_info(skb);
 -
 -		if (info) {
 -			info->key.u.ipv6.dst = fl6.saddr;
 -			info->key.u.ipv6.src = fl6.daddr;
 -		}
 -
 -		if (!pskb_may_pull(skb, ETH_HLEN)) {
 -			dst_release(dst);
 -			return -EINVAL;
 -		}
 -
 -		skb->protocol = eth_type_trans(skb, geneve->dev);
 -		netif_rx(skb);
 -		dst_release(dst);
 -		return -EMSGSIZE;
 -	}
 +	skb_tunnel_check_pmtu(skb, dst, GENEVE_IPV6_HLEN + info->options_len);
  
++<<<<<<< HEAD
 +	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
 +	if (geneve->collect_md) {
++=======
+ 	if (geneve->cfg.collect_md) {
++>>>>>>> 34beb2159451 (geneve: add transport ports in route lookup for geneve)
  		prio = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);
  		ttl = key->ttl;
  	} else {
@@@ -1016,7 -1100,12 +1044,16 @@@ static int geneve_fill_metadata_dst(str
  		struct rtable *rt;
  		struct flowi4 fl4;
  
++<<<<<<< HEAD
 +		rt = geneve_get_v4_rt(skb, dev, &fl4, info);
++=======
+ 		struct geneve_sock *gs4 = rcu_dereference(geneve->sock4);
+ 		sport = udp_flow_src_port(geneve->net, skb,
+ 					  1, USHRT_MAX, true);
+ 
+ 		rt = geneve_get_v4_rt(skb, dev, gs4, &fl4, info,
+ 				      geneve->cfg.info.key.tp_dst, sport);
++>>>>>>> 34beb2159451 (geneve: add transport ports in route lookup for geneve)
  		if (IS_ERR(rt))
  			return PTR_ERR(rt);
  
@@@ -1027,7 -1116,12 +1064,16 @@@
  		struct dst_entry *dst;
  		struct flowi6 fl6;
  
++<<<<<<< HEAD
 +		dst = geneve_get_v6_dst(skb, dev, &fl6, info);
++=======
+ 		struct geneve_sock *gs6 = rcu_dereference(geneve->sock6);
+ 		sport = udp_flow_src_port(geneve->net, skb,
+ 					  1, USHRT_MAX, true);
+ 
+ 		dst = geneve_get_v6_dst(skb, dev, gs6, &fl6, info,
+ 					geneve->cfg.info.key.tp_dst, sport);
++>>>>>>> 34beb2159451 (geneve: add transport ports in route lookup for geneve)
  		if (IS_ERR(dst))
  			return PTR_ERR(dst);
  
@@@ -1038,9 -1132,8 +1084,14 @@@
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	info->key.tp_src = udp_flow_src_port(geneve->net, skb,
 +					     1, USHRT_MAX, true);
 +	info->key.tp_dst = geneve->info.key.tp_dst;
++=======
+ 	info->key.tp_src = sport;
+ 	info->key.tp_dst = geneve->cfg.info.key.tp_dst;
++>>>>>>> 34beb2159451 (geneve: add transport ports in route lookup for geneve)
  	return 0;
  }
  
* Unmerged path drivers/net/geneve.c
