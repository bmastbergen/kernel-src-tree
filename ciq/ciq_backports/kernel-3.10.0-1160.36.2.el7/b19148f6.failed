s390/pci: improve irq number check for msix

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.36.2.el7
commit-author Sebastian Ott <sebott@linux.vnet.ibm.com>
commit b19148f6e2d90738ecf0c2eeeb9bdbae25c59e9b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.36.2.el7/b19148f6.failed

s390s arch_setup_msi_irqs function ensures that we don't return with
more irqs than the PCI architecture allows and that a single PCI
function doesn't consume more irqs than the kernel is configured for.

At least the last check doesn't help much and should take the sum of
all irqs into account. Since that's already done by irq_alloc_desc
we can remove this check.

As for the first check we should use the value provided by the
firmware which can be less than what the PCI architecture allows.

	Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit b19148f6e2d90738ecf0c2eeeb9bdbae25c59e9b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/pci.h
#	arch/s390/pci/pci.c
diff --cc arch/s390/include/asm/pci.h
index 1da0480a6412,ef803c202d42..000000000000
--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@@ -59,29 -42,20 +59,32 @@@ struct zpci_fmb 
  	u64 st_ops;
  	u64 stb_ops;
  	u64 rpcit_ops;
 -	u64 dma_rbytes;
 -	u64 dma_wbytes;
 -	/* software counters */
 -	atomic64_t allocated_pages;
 -	atomic64_t mapped_pages;
 -	atomic64_t unmapped_pages;
 -} __packed __aligned(16);
 +	/* format specific counters */
 +	union {
 +		struct zpci_fmb_fmt0 fmt0;
 +		struct zpci_fmb_fmt1 fmt1;
 +		struct zpci_fmb_fmt2 fmt2;
 +	};
 +} __packed __aligned(128);
 +
++<<<<<<< HEAD
 +struct msi_map {
 +	unsigned long irq;
 +	struct msi_desc *msi;
 +	struct hlist_node msi_chain;
 +};
 +
 +#define ZPCI_MSI_VEC_BITS	10
 +#define ZPCI_MSI_VEC_MAX	(1 << ZPCI_MSI_VEC_BITS)
 +#define ZPCI_MSI_VEC_MASK	(ZPCI_MSI_VEC_MAX - 1)
  
++=======
++>>>>>>> b19148f6e2d9 (s390/pci: improve irq number check for msix)
  enum zpci_state {
 -	ZPCI_FN_STATE_RESERVED,
 -	ZPCI_FN_STATE_STANDBY,
 -	ZPCI_FN_STATE_CONFIGURED,
 -	ZPCI_FN_STATE_ONLINE,
 -	NR_ZPCI_FN_STATES,
 +	ZPCI_FN_STATE_STANDBY = 0,
 +	ZPCI_FN_STATE_CONFIGURED = 1,
 +	ZPCI_FN_STATE_RESERVED = 2,
 +	ZPCI_FN_STATE_ONLINE = 3,
  };
  
  struct zpci_bar_struct {
@@@ -111,10 -86,9 +114,14 @@@ struct zpci_dev 
  
  	/* IRQ stuff */
  	u64		msi_addr;	/* MSI address */
++<<<<<<< HEAD
 +	struct zdev_irq_map *irq_map;
 +	struct msi_map *msi_map;
++=======
+ 	unsigned int	max_msi;	/* maximum number of MSI's */
++>>>>>>> b19148f6e2d9 (s390/pci: improve irq number check for msix)
  	struct airq_iv *aibv;		/* adapter interrupt bit vector */
 -	unsigned int	aisb;		/* number of the summary bit */
 +	unsigned long	aisb;		/* number of the summary bit */
  
  	/* DMA stuff */
  	unsigned long	*dma_table;
diff --cc arch/s390/pci/pci.c
index e3d424e9f820,47a4568e141d..000000000000
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@@ -503,20 -361,21 +503,24 @@@ static void zpci_free_msi(struct zpci_d
  int arch_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type)
  {
  	struct zpci_dev *zdev = get_zdev(pdev);
 -	unsigned int hwirq, msi_vecs;
 +	unsigned int msi_nr, msi_vecs;
  	unsigned long aisb;
  	struct msi_desc *msi;
 -	struct msi_msg msg;
 -	int rc, irq;
 +	int rc;
  
 +	zdev->aisb = -1UL;
  	if (type == PCI_CAP_ID_MSI && nvec > 1)
  		return 1;
++<<<<<<< HEAD
 +	msi_vecs = min(nvec, ZPCI_MSI_VEC_MAX);
++=======
+ 	msi_vecs = min_t(unsigned int, nvec, zdev->max_msi);
++>>>>>>> b19148f6e2d9 (s390/pci: improve irq number check for msix)
  
  	/* Allocate adapter summary indicator bit */
 -	rc = -EIO;
  	aisb = airq_iv_alloc_bit(zpci_aisb_iv);
  	if (aisb == -1UL)
 -		goto out;
 +		return -EIO;
  	zdev->aisb = aisb;
  
  	/* Create adapter interrupt vector */
* Unmerged path arch/s390/include/asm/pci.h
* Unmerged path arch/s390/pci/pci.c
diff --git a/arch/s390/pci/pci_clp.c b/arch/s390/pci/pci_clp.c
index 70c2286e4d73..b45241e5b51c 100644
--- a/arch/s390/pci/pci_clp.c
+++ b/arch/s390/pci/pci_clp.c
@@ -64,6 +64,7 @@ static void clp_store_query_pci_fngrp(struct zpci_dev *zdev,
 	zdev->tlb_refresh = response->refresh;
 	zdev->dma_mask = response->dasm;
 	zdev->msi_addr = response->msia;
+	zdev->max_msi = response->noi;
 	zdev->fmb_update = response->mui;
 
 	switch (response->version) {
