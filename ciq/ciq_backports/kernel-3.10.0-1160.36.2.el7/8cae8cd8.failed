seq_file: disallow extremely large seq buffer allocations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.36.2.el7
commit-author Eric Sandeen <sandeen@redhat.com>
commit 8cae8cd89f05f6de223d63e6d15e31c8ba9cf53b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.36.2.el7/8cae8cd8.failed

There is no reasonable need for a buffer larger than this, and it avoids
int overflow pitfalls.

Fixes: 058504edd026 ("fs/seq_file: fallback to vmalloc allocation")
	Suggested-by: Al Viro <viro@zeniv.linux.org.uk>
	Reported-by: Qualys Security Advisory <qsa@qualys.com>
	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
	Cc: stable@kernel.org
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8cae8cd89f05f6de223d63e6d15e31c8ba9cf53b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/seq_file.c
diff --cc fs/seq_file.c
index bc7a9ec855aa,4a2cda04d3e2..000000000000
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@@ -26,15 -32,10 +26,22 @@@ static void seq_set_overflow(struct seq
  
  static void *seq_buf_alloc(unsigned long size)
  {
++<<<<<<< HEAD
 +	return kvmalloc(size, GFP_KERNEL);
 +}
 +
 +static void seq_buf_free(const void *buf)
 +{
 +	if (unlikely(is_vmalloc_addr(buf)))
 +		vfree(buf);
 +	else
 +		kfree(buf);
++=======
+ 	if (unlikely(size > MAX_RW_COUNT))
+ 		return NULL;
+ 
+ 	return kvmalloc(size, GFP_KERNEL_ACCOUNT);
++>>>>>>> 8cae8cd89f05 (seq_file: disallow extremely large seq buffer allocations)
  }
  
  /**
* Unmerged path fs/seq_file.c
