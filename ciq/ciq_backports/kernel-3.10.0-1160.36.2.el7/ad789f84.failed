sched/debug: Fix cgroup_path[] serialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.36.2.el7
Rebuild_CHGLOG: - sched/debug: Fix cgroup_path[] serialization (Waiman Long) [1912221]
Rebuild_FUZZ: 96.47%
commit-author Waiman Long <longman@redhat.com>
commit ad789f84c9a145f8a18744c0387cec22ec51651e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.36.2.el7/ad789f84.failed

The handling of sysrq key can be activated by echoing the key to
/proc/sysrq-trigger or via the magic key sequence typed into a terminal
that is connected to the system in some way (serial, USB or other mean).
In the former case, the handling is done in a user context. In the
latter case, it is likely to be in an interrupt context.

Currently in print_cpu() of kernel/sched/debug.c, sched_debug_lock is
taken with interrupt disabled for the whole duration of the calls to
print_*_stats() and print_rq() which could last for the quite some time
if the information dump happens on the serial console.

If the system has many cpus and the sched_debug_lock is somehow busy
(e.g. parallel sysrq-t), the system may hit a hard lockup panic
depending on the actually serial console implementation of the
system.

The purpose of sched_debug_lock is to serialize the use of the global
cgroup_path[] buffer in print_cpu(). The rests of the printk calls don't
need serialization from sched_debug_lock.

Calling printk() with interrupt disabled can still be problematic if
multiple instances are running. Allocating a stack buffer of PATH_MAX
bytes is not feasible because of the limited size of the kernel stack.

The solution implemented in this patch is to allow only one caller at a
time to use the full size group_path[], while other simultaneous callers
will have to use shorter stack buffers with the possibility of path
name truncation. A "..." suffix will be printed if truncation may have
happened.  The cgroup path name is provided for informational purpose
only, so occasional path name truncation should not be a big problem.

Fixes: efe25c2c7b3a ("sched: Reinstate group names in /proc/sched_debug")
	Suggested-by: Peter Zijlstra <peterz@infradead.org>
	Signed-off-by: Waiman Long <longman@redhat.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20210415195426.6677-1-longman@redhat.com
(cherry picked from commit ad789f84c9a145f8a18744c0387cec22ec51651e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/debug.c
diff --cc kernel/sched/debug.c
index bca064647618,9c882f20803e..000000000000
--- a/kernel/sched/debug.c
+++ b/kernel/sched/debug.c
@@@ -1,26 -1,13 +1,24 @@@
  /*
   * kernel/sched/debug.c
   *
 - * Print the CFS rbtree and other debugging details
 + * Print the CFS rbtree
   *
   * Copyright(C) 2007, Red Hat, Inc., Ingo Molnar
 + *
 + * This program is free software; you can redistribute it and/or modify
 + * it under the terms of the GNU General Public License version 2 as
 + * published by the Free Software Foundation.
   */
 +
 +#include <linux/proc_fs.h>
 +#include <linux/sched.h>
 +#include <linux/seq_file.h>
 +#include <linux/kallsyms.h>
 +#include <linux/utsname.h>
 +#include <linux/mempolicy.h>
 +
  #include "sched.h"
  
- static DEFINE_SPINLOCK(sched_debug_lock);
- 
  /*
   * This allows printing both to /proc/sched_debug and
   * to the console
@@@ -106,15 -474,37 +104,42 @@@ static void print_cfs_group_stats(struc
  #endif
  
  #ifdef CONFIG_CGROUP_SCHED
+ static DEFINE_SPINLOCK(sched_debug_lock);
  static char group_path[PATH_MAX];
  
- static char *task_group_path(struct task_group *tg)
+ static void task_group_path(struct task_group *tg, char *path, int plen)
  {
- 	if (autogroup_path(tg, group_path, PATH_MAX))
- 		return group_path;
+ 	if (autogroup_path(tg, path, plen))
+ 		return;
  
++<<<<<<< HEAD
 +	cgroup_path(tg->css.cgroup, group_path, PATH_MAX);
 +	return group_path;
++=======
+ 	cgroup_path(tg->css.cgroup, path, plen);
+ }
+ 
+ /*
+  * Only 1 SEQ_printf_task_group_path() caller can use the full length
+  * group_path[] for cgroup path. Other simultaneous callers will have
+  * to use a shorter stack buffer. A "..." suffix is appended at the end
+  * of the stack buffer so that it will show up in case the output length
+  * matches the given buffer size to indicate possible path name truncation.
+  */
+ #define SEQ_printf_task_group_path(m, tg, fmt...)			\
+ {									\
+ 	if (spin_trylock(&sched_debug_lock)) {				\
+ 		task_group_path(tg, group_path, sizeof(group_path));	\
+ 		SEQ_printf(m, fmt, group_path);				\
+ 		spin_unlock(&sched_debug_lock);				\
+ 	} else {							\
+ 		char buf[128];						\
+ 		char *bufend = buf + sizeof(buf) - 3;			\
+ 		task_group_path(tg, buf, bufend - buf);			\
+ 		strcpy(bufend - 1, "...");				\
+ 		SEQ_printf(m, fmt, buf);				\
+ 	}								\
++>>>>>>> ad789f84c9a1 (sched/debug: Fix cgroup_path[] serialization)
  }
  #endif
  
@@@ -133,15 -523,15 +158,15 @@@ print_task(struct seq_file *m, struct r
  		p->prio);
  
  	SEQ_printf(m, "%9Ld.%06ld %9Ld.%06ld %9Ld.%06ld",
 -		SPLIT_NS(schedstat_val_or_zero(p->se.statistics.wait_sum)),
 +		SPLIT_NS(schedstat_val(p, se.statistics->wait_sum)),
  		SPLIT_NS(p->se.sum_exec_runtime),
 -		SPLIT_NS(schedstat_val_or_zero(p->se.statistics.sum_sleep_runtime)));
 +		SPLIT_NS(schedstat_val(p, se.statistics->sum_sleep_runtime)));
  
  #ifdef CONFIG_NUMA_BALANCING
 -	SEQ_printf(m, " %d %d", task_node(p), task_numa_group_id(p));
 +	SEQ_printf(m, " %d", cpu_to_node(task_cpu(p)));
  #endif
  #ifdef CONFIG_CGROUP_SCHED
- 	SEQ_printf(m, " %s", task_group_path(task_group(p)));
+ 	SEQ_printf_task_group_path(m, task_group(p), " %s")
  #endif
  
  	SEQ_printf(m, "\n");
@@@ -325,16 -739,13 +349,18 @@@ do {									
  		P(ttwu_count);
  		P(ttwu_local);
  	}
 -#undef P
  
++<<<<<<< HEAD
 +#undef P
 +#undef P64
 +#endif
 +	spin_lock_irqsave(&sched_debug_lock, flags);
++=======
++>>>>>>> ad789f84c9a1 (sched/debug: Fix cgroup_path[] serialization)
  	print_cfs_stats(m, cpu);
  	print_rt_stats(m, cpu);
 -	print_dl_stats(m, cpu);
  
  	print_rq(m, rq, cpu);
- 	spin_unlock_irqrestore(&sched_debug_lock, flags);
  	SEQ_printf(m, "\n");
  }
  
* Unmerged path kernel/sched/debug.c
