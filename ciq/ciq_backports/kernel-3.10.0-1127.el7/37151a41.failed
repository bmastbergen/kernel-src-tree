ALSA: pcm: fix lost wakeup event scenarios in snd_pcm_drain

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Yuki Tsunashima <ytsunashima@jp.adit-jv.com>
commit 37151a41df800493cfcbbef4f7208ffe04feb959
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/37151a41.failed

lost wakeup can occur after enabling irq, therefore put task
into interruptible before enabling interrupts,

without this change, task can be put to sleep and snd_pcm_drain
will delay

Fixes: f2b3614cefb6 ("ALSA: PCM - Don't check DMA time-out too shortly")
	Signed-off-by: Yuki Tsunashima <ytsunashima@jp.adit-jv.com>
	Signed-off-by: Suresh Udipi <sudipi@jp.adit-jv.com>
[ported from 4.9]
	Signed-off-by: Adam Miartus <amiartus@de.adit-jv.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 37151a41df800493cfcbbef4f7208ffe04feb959)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/core/pcm_native.c
diff --cc sound/core/pcm_native.c
index e5b262e50308,703857aab00f..000000000000
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@@ -1886,9 -1872,10 +1886,10 @@@ static int snd_pcm_drain(struct snd_pcm
  		if (!to_check)
  			break; /* all drained */
  		init_waitqueue_entry(&wait, current);
+ 		set_current_state(TASK_INTERRUPTIBLE);
  		add_wait_queue(&to_check->sleep, &wait);
  		snd_pcm_stream_unlock_irq(substream);
 +		up_read(&snd_pcm_link_rwsem);
  		if (runtime->no_period_wakeup)
  			tout = MAX_SCHEDULE_TIMEOUT;
  		else {
@@@ -1899,10 -1886,18 +1900,15 @@@
  			}
  			tout = msecs_to_jiffies(tout * 1000);
  		}
++<<<<<<< HEAD
 +		tout = schedule_timeout_interruptible(tout);
 +		down_read(&snd_pcm_link_rwsem);
++=======
+ 		tout = schedule_timeout(tout);
+ 
++>>>>>>> 37151a41df80 (ALSA: pcm: fix lost wakeup event scenarios in snd_pcm_drain)
  		snd_pcm_stream_lock_irq(substream);
 -		group = snd_pcm_stream_group_ref(substream);
 -		snd_pcm_group_for_each_entry(s, substream) {
 -			if (s->runtime == to_check) {
 -				remove_wait_queue(&to_check->sleep, &wait);
 -				break;
 -			}
 -		}
 -		snd_pcm_group_unref(group, substream);
 -
 +		remove_wait_queue(&to_check->sleep, &wait);
  		if (card->shutdown) {
  			result = -ENODEV;
  			break;
* Unmerged path sound/core/pcm_native.c
