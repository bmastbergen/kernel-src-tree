cpuidle-haltpoll: vcpu hotplug support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Joao Martins <joao.m.martins@oracle.com>
commit 97d3eb9da84cae0548359b0aecb8619faad003b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/97d3eb9d.failed

When cpus != maxcpus cpuidle-haltpoll will fail to register all vcpus
past the online ones and thus fail to register the idle driver.
This is because cpuidle_add_sysfs() will return with -ENODEV as a
consequence from get_cpu_device() return no device for a non-existing
CPU.

Instead switch to cpuidle_register_driver() and manually register each
of the present cpus through cpuhp_setup_state() callbacks and future
ones that get onlined or offlined. This mimmics similar logic that
intel_idle does.

Fixes: fa86ee90eb11 ("add cpuidle-haltpoll driver")
	Signed-off-by: Joao Martins <joao.m.martins@oracle.com>
	Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Reviewed-by: Marcelo Tosatti <mtosatti@redhat.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 97d3eb9da84cae0548359b0aecb8619faad003b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/cpuidle_haltpoll.h
#	arch/x86/kernel/kvm.c
#	drivers/cpuidle/cpuidle-haltpoll.c
#	include/linux/cpuidle_haltpoll.h
diff --cc arch/x86/kernel/kvm.c
index 3521cc67bdcc,60bab4a3b36b..000000000000
--- a/arch/x86/kernel/kvm.c
+++ b/arch/x86/kernel/kvm.c
@@@ -897,32 -861,53 +897,71 @@@ void __init kvm_spinlock_init(void
  	if (num_possible_cpus() == 1)
  		return;
  
 +#ifdef CONFIG_QUEUED_SPINLOCKS
  	__pv_init_lock_hash();
 -	pv_ops.lock.queued_spin_lock_slowpath = __pv_queued_spin_lock_slowpath;
 -	pv_ops.lock.queued_spin_unlock =
 -		PV_CALLEE_SAVE(__pv_queued_spin_unlock);
 -	pv_ops.lock.wait = kvm_wait;
 -	pv_ops.lock.kick = kvm_kick_cpu;
 +	pv_lock_ops.queued_spin_lock_slowpath = __pv_queued_spin_lock_slowpath;
 +	pv_lock_ops.queued_spin_unlock = PV_CALLEE_SAVE(__pv_queued_spin_unlock);
 +	pv_lock_ops.wait = kvm_wait;
 +	pv_lock_ops.kick = kvm_kick_cpu;
 +#else /* !CONFIG_QUEUED_SPINLOCKS */
 +	pv_lock_ops.lock_spinning = PV_CALLEE_SAVE(kvm_lock_spinning);
 +	pv_lock_ops.unlock_kick = kvm_unlock_kick;
 +#endif
 +}
  
 -	if (kvm_para_has_feature(KVM_FEATURE_STEAL_TIME)) {
 -		pv_ops.lock.vcpu_is_preempted =
 -			PV_CALLEE_SAVE(__kvm_vcpu_is_preempted);
 -	}
 +static __init int kvm_spinlock_init_jump(void)
 +{
 +	if (!kvm_para_available())
 +		return 0;
 +	if (!kvm_para_has_feature(KVM_FEATURE_PV_UNHALT))
 +		return 0;
 +
 +#ifndef CONFIG_QUEUED_SPINLOCKS
 +	static_key_slow_inc(&paravirt_ticketlocks_enabled);
 +#endif
 +	printk(KERN_INFO "KVM setup paravirtual spinlock\n");
 +
 +	return 0;
  }
 +early_initcall(kvm_spinlock_init_jump);
  
  #endif	/* CONFIG_PARAVIRT_SPINLOCKS */
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_ARCH_CPUIDLE_HALTPOLL
+ 
+ static void kvm_disable_host_haltpoll(void *i)
+ {
+ 	wrmsrl(MSR_KVM_POLL_CONTROL, 0);
+ }
+ 
+ static void kvm_enable_host_haltpoll(void *i)
+ {
+ 	wrmsrl(MSR_KVM_POLL_CONTROL, 1);
+ }
+ 
+ void arch_haltpoll_enable(unsigned int cpu)
+ {
+ 	if (!kvm_para_has_feature(KVM_FEATURE_POLL_CONTROL)) {
+ 		pr_err_once("kvm: host does not support poll control\n");
+ 		pr_err_once("kvm: host upgrade recommended\n");
+ 		return;
+ 	}
+ 
+ 	/* Enable guest halt poll disables host halt poll */
+ 	smp_call_function_single(cpu, kvm_disable_host_haltpoll, NULL, 1);
+ }
+ EXPORT_SYMBOL_GPL(arch_haltpoll_enable);
+ 
+ void arch_haltpoll_disable(unsigned int cpu)
+ {
+ 	if (!kvm_para_has_feature(KVM_FEATURE_POLL_CONTROL))
+ 		return;
+ 
+ 	/* Enable guest halt poll disables host halt poll */
+ 	smp_call_function_single(cpu, kvm_enable_host_haltpoll, NULL, 1);
+ }
+ EXPORT_SYMBOL_GPL(arch_haltpoll_disable);
+ #endif
++>>>>>>> 97d3eb9da84c (cpuidle-haltpoll: vcpu hotplug support)
* Unmerged path arch/x86/include/asm/cpuidle_haltpoll.h
* Unmerged path drivers/cpuidle/cpuidle-haltpoll.c
* Unmerged path include/linux/cpuidle_haltpoll.h
* Unmerged path arch/x86/include/asm/cpuidle_haltpoll.h
* Unmerged path arch/x86/kernel/kvm.c
* Unmerged path drivers/cpuidle/cpuidle-haltpoll.c
* Unmerged path include/linux/cpuidle_haltpoll.h
