xfs: clean up xfs_mount allocation and dynamic initializers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Brian Foster <bfoster@redhat.com>
commit 72c44e35f02a1cb4032e476c398a7234badcf49f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/72c44e35.failed

Most of the generic data structures embedded in xfs_mount are
dynamically initialized immediately after mp is allocated. A few
fields are left out and initialized during the xfs_mountfs()
sequence, after mp has been attached to the superblock.

To clean this up and help prevent premature access of associated
fields, refactor xfs_mount allocation and all dependent init calls
into a new helper. This self-documents that all low level data
structures (i.e., locks, trees, etc.) should be initialized before
xfs_mount is attached to the superblock.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 72c44e35f02a1cb4032e476c398a7234badcf49f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_super.c
diff --cc fs/xfs/xfs_super.c
index 0e53995c4b54,612c1d5348b3..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -1582,18 -1614,13 +1607,25 @@@ xfs_fs_fill_super
  	struct xfs_mount	*mp = NULL;
  	int			flags = 0, error = -ENOMEM;
  
- 	mp = kzalloc(sizeof(struct xfs_mount), GFP_KERNEL);
+ 	/*
+ 	 * allocate mp and do all low-level struct initializations before we
+ 	 * attach it to the super
+ 	 */
+ 	mp = xfs_mount_alloc(sb);
  	if (!mp)
  		goto out;
++<<<<<<< HEAD
 +
 +	spin_lock_init(&mp->m_sb_lock);
 +	mutex_init(&mp->m_growlock);
 +	atomic_set(&mp->m_active_trans, 0);
 +	INIT_DELAYED_WORK(&mp->m_reclaim_work, xfs_reclaim_worker);
 +	INIT_DELAYED_WORK(&mp->m_eofblocks_work, xfs_eofblocks_worker);
 +	mp->m_kobj.kobject.kset = xfs_kset;
 +
 +	mp->m_super = sb;
++=======
++>>>>>>> 72c44e35f02a (xfs: clean up xfs_mount allocation and dynamic initializers)
  	sb->s_fs_info = mp;
  
  	error = xfs_parseargs(mp, (char *)data);
diff --git a/fs/xfs/libxfs/xfs_sb.c b/fs/xfs/libxfs/xfs_sb.c
index e6b1f0895277..a61c3bb9dbdc 100644
--- a/fs/xfs/libxfs/xfs_sb.c
+++ b/fs/xfs/libxfs/xfs_sb.c
@@ -728,7 +728,6 @@ xfs_sb_mount_common(
 	struct xfs_sb	*sbp)
 {
 	mp->m_agfrotor = mp->m_agirotor = 0;
-	spin_lock_init(&mp->m_agirotor_lock);
 	mp->m_maxagi = mp->m_sb.sb_agcount;
 	mp->m_blkbit_log = sbp->sb_blocklog + XFS_NBBYLOG;
 	mp->m_blkbb_log = sbp->sb_blocklog - BBSHIFT;
diff --git a/fs/xfs/xfs_mount.c b/fs/xfs/xfs_mount.c
index b52efabba8ca..cc8a8a575f70 100644
--- a/fs/xfs/xfs_mount.c
+++ b/fs/xfs/xfs_mount.c
@@ -805,8 +805,6 @@ xfs_mountfs(
 	/*
 	 * Allocate and initialize the per-ag data.
 	 */
-	spin_lock_init(&mp->m_perag_lock);
-	INIT_RADIX_TREE(&mp->m_perag_tree, GFP_ATOMIC);
 	error = xfs_initialize_perag(mp, sbp->sb_agcount, &mp->m_maxagi);
 	if (error) {
 		xfs_warn(mp, "Failed per-ag init: %d", error);
* Unmerged path fs/xfs/xfs_super.c
