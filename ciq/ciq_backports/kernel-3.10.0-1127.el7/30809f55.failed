mm/migrate: fix refcount handling when !hugepage_migration_supported()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Punit Agrawal <punit.agrawal@arm.com>
commit 30809f559a0d348c2dfd7ab05e9a451e2384962e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/30809f55.failed

On failing to migrate a page, soft_offline_huge_page() performs the
necessary update to the hugepage ref-count.

But when !hugepage_migration_supported() , unmap_and_move_hugepage()
also decrements the page ref-count for the hugepage.  The combined
behaviour leaves the ref-count in an inconsistent state.

This leads to soft lockups when running the overcommitted hugepage test
from mce-tests suite.

  Soft offlining pfn 0x83ed600 at process virtual address 0x400000000000
  soft offline: 0x83ed600: migration failed 1, type 1fffc00000008008 (uptodate|head)
  INFO: rcu_preempt detected stalls on CPUs/tasks:
   Tasks blocked on level-0 rcu_node (CPUs 0-7): P2715
    (detected by 7, t=5254 jiffies, g=963, c=962, q=321)
    thugetlb_overco R  running task        0  2715   2685 0x00000008
    Call trace:
      dump_backtrace+0x0/0x268
      show_stack+0x24/0x30
      sched_show_task+0x134/0x180
      rcu_print_detail_task_stall_rnp+0x54/0x7c
      rcu_check_callbacks+0xa74/0xb08
      update_process_times+0x34/0x60
      tick_sched_handle.isra.7+0x38/0x70
      tick_sched_timer+0x4c/0x98
      __hrtimer_run_queues+0xc0/0x300
      hrtimer_interrupt+0xac/0x228
      arch_timer_handler_phys+0x3c/0x50
      handle_percpu_devid_irq+0x8c/0x290
      generic_handle_irq+0x34/0x50
      __handle_domain_irq+0x68/0xc0
      gic_handle_irq+0x5c/0xb0

Address this by changing the putback_active_hugepage() in
soft_offline_huge_page() to putback_movable_pages().

This only triggers on systems that enable memory failure handling
(ARCH_SUPPORTS_MEMORY_FAILURE) but not hugepage migration
(!ARCH_ENABLE_HUGEPAGE_MIGRATION).

I imagine this wasn't triggered as there aren't many systems running
this configuration.

[akpm@linux-foundation.org: remove dead comment, per Naoya]
Link: http://lkml.kernel.org/r/20170525135146.32011-1-punit.agrawal@arm.com
	Reported-by: Manoj Iyer <manoj.iyer@canonical.com>
	Tested-by: Manoj Iyer <manoj.iyer@canonical.com>
	Suggested-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Signed-off-by: Punit Agrawal <punit.agrawal@arm.com>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Wanpeng Li <wanpeng.li@hotmail.com>
	Cc: Christoph Lameter <cl@linux.com>
	Cc: Mel Gorman <mgorman@techsingularity.net>
	Cc: <stable@vger.kernel.org>	[3.14+]
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 30809f559a0d348c2dfd7ab05e9a451e2384962e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory-failure.c
diff --cc mm/memory-failure.c
index 2d6d813952ef,342fac9ba89b..000000000000
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@@ -1598,17 -1590,13 +1598,24 @@@ static int soft_offline_huge_page(struc
  		return -EBUSY;
  	}
  
 -	ret = migrate_pages(&pagelist, new_page, NULL, MPOL_MF_MOVE_ALL,
 +	ret = migrate_pages(&pagelist, new_page, MPOL_MF_MOVE_ALL,
  				MIGRATE_SYNC, MR_MEMORY_FAILURE);
  	if (ret) {
++<<<<<<< HEAD
 +		pr_info("soft offline: %#lx: migration failed %d, type %lx\n",
 +			pfn, ret, page->flags);
 +		/*
 +		 * We know that soft_offline_huge_page() tries to migrate
 +		 * only one hugepage pointed to by hpage, so we need not
 +		 * run through the pagelist here.
 +		 */
 +		putback_active_hugepage(hpage);
++=======
+ 		pr_info("soft offline: %#lx: migration failed %d, type %lx (%pGp)\n",
+ 			pfn, ret, page->flags, &page->flags);
+ 		if (!list_empty(&pagelist))
+ 			putback_movable_pages(&pagelist);
++>>>>>>> 30809f559a0d (mm/migrate: fix refcount handling when !hugepage_migration_supported())
  		if (ret > 0)
  			ret = -EIO;
  	} else {
* Unmerged path mm/memory-failure.c
