s390/protvirt: avoid memory sharing for diag 308 set/store

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Vasily Gorbik <gor@linux.ibm.com>
commit a287a49e672d9762bb85de117b477bdf3ef20bd5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/a287a49e.failed

This reverts commit db9492cef45e ("s390/protvirt: add memory sharing for
diag 308 set/store") which due to ultravisor implementation change is
not needed after all.

Fixes: db9492cef45e ("s390/protvirt: add memory sharing for diag 308 set/store")
	Reviewed-by: Janosch Frank <frankja@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit a287a49e672d9762bb85de117b477bdf3ef20bd5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/boot/ipl_parm.c
#	arch/s390/kernel/ipl.c
diff --cc arch/s390/kernel/ipl.c
index 579fadf9e63f,6837affc19e8..000000000000
--- a/arch/s390/kernel/ipl.c
+++ b/arch/s390/kernel/ipl.c
@@@ -28,6 -29,8 +28,11 @@@
  #include <asm/checksum.h>
  #include <asm/debug.h>
  #include <asm/os_info.h>
++<<<<<<< HEAD
++=======
+ #include <asm/sections.h>
+ #include <asm/boot_data.h>
++>>>>>>> a287a49e672d (s390/protvirt: avoid memory sharing for diag 308 set/store)
  #include "entry.h"
  
  #define IPL_PARM_BLOCK_VERSION 0
@@@ -1021,80 -887,28 +1026,100 @@@ static struct kobj_attribute reipl_type
  static struct kset *reipl_kset;
  static struct kset *reipl_fcp_kset;
  
 -static void __reipl_run(void *unused)
 +static void get_ipl_string(char *dst, struct ipl_parameter_block *ipb,
 +			   const enum ipl_method m)
  {
++<<<<<<< HEAD
 +	char loadparm[LOADPARM_LEN + 1] = {};
 +	char vmparm[DIAG308_VMPARM_SIZE + 1] = {};
 +	char nss_name[NSS_NAME_SIZE + 1] = {};
 +	size_t pos = 0;
 +
 +	reipl_get_ascii_loadparm(loadparm, ipb);
 +	reipl_get_ascii_nss_name(nss_name, ipb);
 +	reipl_get_ascii_vmparm(vmparm, sizeof(vmparm), ipb);
 +
 +	switch (m) {
 +	case REIPL_METHOD_CCW_VM:
 +		pos = sprintf(dst, "IPL %X CLEAR", ipb->ipl_info.ccw.devno);
 +		break;
 +	case REIPL_METHOD_NSS:
 +		pos = sprintf(dst, "IPL %s", nss_name);
 +		break;
 +	default:
++=======
+ 	switch (reipl_type) {
+ 	case IPL_TYPE_CCW:
+ 		diag308(DIAG308_SET, reipl_block_ccw);
+ 		diag308(DIAG308_LOAD_CLEAR, NULL);
+ 		break;
+ 	case IPL_TYPE_FCP:
+ 		diag308(DIAG308_SET, reipl_block_fcp);
+ 		diag308(DIAG308_LOAD_CLEAR, NULL);
+ 		break;
+ 	case IPL_TYPE_NSS:
+ 		diag308(DIAG308_SET, reipl_block_nss);
+ 		diag308(DIAG308_LOAD_CLEAR, NULL);
+ 		break;
+ 	case IPL_TYPE_UNKNOWN:
+ 		diag308(DIAG308_LOAD_CLEAR, NULL);
+ 		break;
+ 	case IPL_TYPE_FCP_DUMP:
++>>>>>>> a287a49e672d (s390/protvirt: avoid memory sharing for diag 308 set/store)
 +		break;
 +	}
 +	if (strlen(loadparm) > 0)
 +		pos += sprintf(dst + pos, " LOADPARM '%s'", loadparm);
 +	if (strlen(vmparm) > 0)
 +		sprintf(dst + pos, " PARM %s", vmparm);
 +}
 +
 +static void __reipl_run(void *unused)
 +{
 +	struct ccw_dev_id devid;
 +	static char buf[128];
 +
 +	switch (reipl_method) {
 +	case REIPL_METHOD_CCW_CIO:
 +		devid.ssid  = reipl_block_ccw->ipl_info.ccw.ssid;
 +		devid.devno = reipl_block_ccw->ipl_info.ccw.devno;
 +		reipl_ccw_dev(&devid);
 +		break;
 +	case REIPL_METHOD_CCW_VM:
 +		get_ipl_string(buf, reipl_block_ccw, REIPL_METHOD_CCW_VM);
 +		__cpcmd(buf, NULL, 0, NULL);
 +		break;
 +	case REIPL_METHOD_CCW_DIAG:
 +		diag308(DIAG308_SET, reipl_block_ccw);
 +		diag308(DIAG308_IPL, NULL);
 +		break;
 +	case REIPL_METHOD_FCP_RW_DIAG:
 +		diag308(DIAG308_SET, reipl_block_fcp);
 +		diag308(DIAG308_IPL, NULL);
 +		break;
 +	case REIPL_METHOD_FCP_RO_DIAG:
 +		diag308(DIAG308_IPL, NULL);
 +		break;
 +	case REIPL_METHOD_FCP_RO_VM:
 +		__cpcmd("IPL", NULL, 0, NULL);
 +		break;
 +	case REIPL_METHOD_NSS_DIAG:
 +		diag308(DIAG308_SET, reipl_block_nss);
 +		diag308(DIAG308_IPL, NULL);
 +		break;
 +	case REIPL_METHOD_NSS:
 +		get_ipl_string(buf, reipl_block_nss, REIPL_METHOD_NSS);
 +		__cpcmd(buf, NULL, 0, NULL);
 +		break;
 +	case REIPL_METHOD_DEFAULT:
 +		if (MACHINE_IS_VM)
 +			__cpcmd("IPL", NULL, 0, NULL);
 +		diag308(DIAG308_IPL, NULL);
 +		break;
 +	case REIPL_METHOD_FCP_DUMP:
  		break;
  	}
 -	disabled_wait();
 +	disabled_wait((unsigned long) __builtin_return_address(0));
  }
  
  static void reipl_run(struct shutdown_trigger *trigger)
* Unmerged path arch/s390/boot/ipl_parm.c
* Unmerged path arch/s390/boot/ipl_parm.c
* Unmerged path arch/s390/kernel/ipl.c
