s390/cio: add basic protected virtualization support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Halil Pasic <pasic@linux.ibm.com>
commit 37db8985b2116c89a3cbaf87083a02f83afaba5b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/37db8985.failed

As virtio-ccw devices are channel devices, we need to use the
dma area within the common I/O layer for any communication with
the hypervisor.

Note that we do not need to use that area for control blocks
directly referenced by instructions, e.g. the orb.

It handles neither QDIO in the common code, nor any device type specific
stuff (like channel programs constructed by the DASD driver).

An interesting side effect is that virtio structures are now going to
get allocated in 31 bit addressable storage.

	Signed-off-by: Halil Pasic <pasic@linux.ibm.com>
	Reviewed-by: Sebastian Ott <sebott@linux.ibm.com>
	Reviewed-by: Cornelia Huck <cohuck@redhat.com>
	Reviewed-by: Michael Mueller <mimu@linux.ibm.com>
	Tested-by: Michael Mueller <mimu@linux.ibm.com>
	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
(cherry picked from commit 37db8985b2116c89a3cbaf87083a02f83afaba5b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/cio/device.c
#	drivers/s390/cio/device_fsm.c
#	drivers/s390/cio/device_ops.c
#	drivers/s390/cio/io_sch.h
#	drivers/s390/virtio/virtio_ccw.c
diff --cc drivers/s390/cio/device.c
index 1ab5f6c36d9b,9985b7484a6b..000000000000
--- a/drivers/s390/cio/device.c
+++ b/drivers/s390/cio/device.c
@@@ -22,6 -23,8 +22,11 @@@
  #include <linux/delay.h>
  #include <linux/timer.h>
  #include <linux/kernel_stat.h>
++<<<<<<< HEAD
++=======
+ #include <linux/sched/signal.h>
+ #include <linux/dma-mapping.h>
++>>>>>>> 37db8985b211 (s390/cio: add basic protected virtualization support)
  
  #include <asm/ccwdev.h>
  #include <asm/cio.h>
@@@ -1127,15 -1111,15 +1161,17 @@@ io_subchannel_remove (struct subchanne
  	cdev = sch_get_cdev(sch);
  	if (!cdev)
  		goto out_free;
 -
 -	ccw_device_unregister(cdev);
 -	spin_lock_irq(sch->lock);
 +	io_subchannel_quiesce(sch);
 +	/* Set ccw device to not operational and drop reference. */
 +	spin_lock_irq(cdev->ccwlock);
  	sch_set_cdev(sch, NULL);
  	set_io_private(sch, NULL);
 -	spin_unlock_irq(sch->lock);
 +	cdev->private->state = DEV_STATE_NOT_OPER;
 +	spin_unlock_irq(cdev->ccwlock);
 +	ccw_device_unregister(cdev);
  out_free:
+ 	dma_free_coherent(&sch->dev, sizeof(*io_priv->dma_area),
+ 			  io_priv->dma_area, io_priv->dma_area_dma);
  	kfree(io_priv);
  	sysfs_remove_group(&sch->dev.kobj, &io_subchannel_attr_group);
  	return 0;
@@@ -1622,28 -1625,47 +1658,64 @@@ struct ccw_device *ccw_device_probe_con
  		return ERR_CAST(sch);
  
  	io_priv = kzalloc(sizeof(*io_priv), GFP_KERNEL | GFP_DMA);
++<<<<<<< HEAD
 +	if (!io_priv) {
 +		put_device(&sch->dev);
 +		return ERR_PTR(-ENOMEM);
 +	}
++=======
+ 	if (!io_priv)
+ 		goto err_priv;
+ 	io_priv->dma_area = dma_alloc_coherent(&sch->dev,
+ 				sizeof(*io_priv->dma_area),
+ 				&io_priv->dma_area_dma, GFP_KERNEL);
+ 	if (!io_priv->dma_area)
+ 		goto err_dma_area;
+ 	set_io_private(sch, io_priv);
++>>>>>>> 37db8985b211 (s390/cio: add basic protected virtualization support)
  	cdev = io_subchannel_create_ccwdev(sch);
  	if (IS_ERR(cdev)) {
+ 		dma_free_coherent(&sch->dev, sizeof(*io_priv->dma_area),
+ 				  io_priv->dma_area, io_priv->dma_area_dma);
+ 		set_io_private(sch, NULL);
  		put_device(&sch->dev);
  		kfree(io_priv);
  		return cdev;
  	}
 -	cdev->drv = drv;
 -	ccw_device_set_int_class(cdev);
 +	set_io_private(sch, io_priv);
 +	ret = ccw_device_console_enable(cdev, sch);
 +	if (ret) {
 +		set_io_private(sch, NULL);
 +		put_device(&sch->dev);
 +		put_device(&cdev->dev);
 +		kfree(io_priv);
 +		return ERR_PTR(ret);
 +	}
  	return cdev;
+ 
+ err_dma_area:
+ 	kfree(io_priv);
+ err_priv:
+ 	put_device(&sch->dev);
+ 	return ERR_PTR(-ENOMEM);
+ }
+ 
++<<<<<<< HEAD
++=======
+ void __init ccw_device_destroy_console(struct ccw_device *cdev)
+ {
+ 	struct subchannel *sch = to_subchannel(cdev->dev.parent);
+ 	struct io_subchannel_private *io_priv = to_io_private(sch);
+ 
+ 	set_io_private(sch, NULL);
+ 	put_device(&sch->dev);
+ 	put_device(&cdev->dev);
+ 	dma_free_coherent(&sch->dev, sizeof(*io_priv->dma_area),
+ 			  io_priv->dma_area, io_priv->dma_area_dma);
+ 	kfree(io_priv);
  }
  
++>>>>>>> 37db8985b211 (s390/cio: add basic protected virtualization support)
  /**
   * ccw_device_wait_idle() - busy wait for device to become idle
   * @cdev: ccw device
diff --cc drivers/s390/cio/device_fsm.c
index c7638c543250,8fc267324ebb..000000000000
--- a/drivers/s390/cio/device_fsm.c
+++ b/drivers/s390/cio/device_fsm.c
@@@ -542,10 -520,12 +548,11 @@@ callback
  			cdev->private->flags.fake_irb = 0;
  			if (cdev->handler)
  				cdev->handler(cdev, cdev->private->intparm,
- 					      &cdev->private->irb);
- 			memset(&cdev->private->irb, 0, sizeof(struct irb));
+ 					      &cdev->private->dma_area->irb);
+ 			memset(&cdev->private->dma_area->irb, 0,
+ 			       sizeof(struct irb));
  		}
  		ccw_device_report_path_events(cdev);
 -		ccw_device_handle_broken_paths(cdev);
  		break;
  	case -ETIME:
  	case -EUSERS:
@@@ -731,6 -712,44 +739,47 @@@ static void ccw_device_boxed_verify(str
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Pass interrupt to device driver.
+  */
+ static int ccw_device_call_handler(struct ccw_device *cdev)
+ {
+ 	unsigned int stctl;
+ 	int ending_status;
+ 
+ 	/*
+ 	 * we allow for the device action handler if .
+ 	 *  - we received ending status
+ 	 *  - the action handler requested to see all interrupts
+ 	 *  - we received an intermediate status
+ 	 *  - fast notification was requested (primary status)
+ 	 *  - unsolicited interrupts
+ 	 */
+ 	stctl = scsw_stctl(&cdev->private->dma_area->irb.scsw);
+ 	ending_status = (stctl & SCSW_STCTL_SEC_STATUS) ||
+ 		(stctl == (SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND)) ||
+ 		(stctl == SCSW_STCTL_STATUS_PEND);
+ 	if (!ending_status &&
+ 	    !cdev->private->options.repall &&
+ 	    !(stctl & SCSW_STCTL_INTER_STATUS) &&
+ 	    !(cdev->private->options.fast &&
+ 	      (stctl & SCSW_STCTL_PRIM_STATUS)))
+ 		return 0;
+ 
+ 	if (ending_status)
+ 		ccw_device_set_timeout(cdev, 0);
+ 
+ 	if (cdev->handler)
+ 		cdev->handler(cdev, cdev->private->intparm,
+ 			      &cdev->private->dma_area->irb);
+ 
+ 	memset(&cdev->private->dma_area->irb, 0, sizeof(struct irb));
+ 	return 1;
+ }
+ 
+ /*
++>>>>>>> 37db8985b211 (s390/cio: add basic protected virtualization support)
   * Got an interrupt for a normal io (state online).
   */
  static void
diff --cc drivers/s390/cio/device_ops.c
index f3c417943dad,d722458c5928..000000000000
--- a/drivers/s390/cio/device_ops.c
+++ b/drivers/s390/cio/device_ops.c
@@@ -783,7 -699,23 +783,27 @@@ void ccw_device_get_schid(struct ccw_de
  }
  EXPORT_SYMBOL_GPL(ccw_device_get_schid);
  
++<<<<<<< HEAD
 +MODULE_LICENSE("GPL");
++=======
+ /*
+  * Allocate zeroed dma coherent 31 bit addressable memory using
+  * the subchannels dma pool. Maximal size of allocation supported
+  * is PAGE_SIZE.
+  */
+ void *ccw_device_dma_zalloc(struct ccw_device *cdev, size_t size)
+ {
+ 	return cio_gp_dma_zalloc(cdev->private->dma_pool, &cdev->dev, size);
+ }
+ EXPORT_SYMBOL(ccw_device_dma_zalloc);
+ 
+ void ccw_device_dma_free(struct ccw_device *cdev, void *cpu_addr, size_t size)
+ {
+ 	cio_gp_dma_free(cdev->private->dma_pool, cpu_addr, size);
+ }
+ EXPORT_SYMBOL(ccw_device_dma_free);
+ 
++>>>>>>> 37db8985b211 (s390/cio: add basic protected virtualization support)
  EXPORT_SYMBOL(ccw_device_set_options_mask);
  EXPORT_SYMBOL(ccw_device_set_options);
  EXPORT_SYMBOL(ccw_device_clear_options);
diff --cc drivers/s390/cio/io_sch.h
index b108f4a5c7dd,c03b4a19974e..000000000000
--- a/drivers/s390/cio/io_sch.h
+++ b/drivers/s390/cio/io_sch.h
@@@ -154,10 -168,7 +166,14 @@@ struct ccw_device_private 
  	} __attribute__((packed)) flags;
  	unsigned long intparm;	/* user interruption parameter */
  	struct qdio_irq *qdio_data;
++<<<<<<< HEAD
 +	struct irb irb;		/* device status */
 +	struct senseid senseid;	/* SenseID info */
 +	struct pgid pgid[8];	/* path group IDs per chpid*/
 +	struct ccw1 iccws[2];	/* ccws for SNID/SID/SPGID commands */
++=======
+ 	int async_kill_io_rc;
++>>>>>>> 37db8985b211 (s390/cio: add basic protected virtualization support)
  	struct work_struct todo_work;
  	enum cdev_todo todo;
  	wait_queue_head_t wait_q;
diff --cc drivers/s390/virtio/virtio_ccw.c
index 528f117e589d,f995798bb025..000000000000
--- a/drivers/s390/virtio/virtio_ccw.c
+++ b/drivers/s390/virtio/virtio_ccw.c
@@@ -1220,6 -1254,7 +1220,10 @@@ static int virtio_ccw_online(struct ccw
  		ret = -ENOMEM;
  		goto out_free;
  	}
++<<<<<<< HEAD
++=======
+ 	vcdev->vdev.dev.parent = &cdev->dev;
++>>>>>>> 37db8985b211 (s390/cio: add basic protected virtualization support)
  	vcdev->config_block = kzalloc(sizeof(*vcdev->config_block),
  				   GFP_DMA | GFP_KERNEL);
  	if (!vcdev->config_block) {
diff --git a/arch/s390/include/asm/ccwdev.h b/arch/s390/include/asm/ccwdev.h
index 73b4359ab7a4..a44a0f923e36 100644
--- a/arch/s390/include/asm/ccwdev.h
+++ b/arch/s390/include/asm/ccwdev.h
@@ -223,6 +223,10 @@ extern struct ccw_device *ccw_device_probe_console(void);
 extern void ccw_device_wait_idle(struct ccw_device *);
 extern int ccw_device_force_console(struct ccw_device *);
 
+extern void *ccw_device_dma_zalloc(struct ccw_device *cdev, size_t size);
+extern void ccw_device_dma_free(struct ccw_device *cdev,
+				void *cpu_addr, size_t size);
+
 int ccw_device_siosl(struct ccw_device *);
 
 extern void ccw_device_get_schid(struct ccw_device *, struct subchannel_id *);
diff --git a/drivers/s390/cio/ccwreq.c b/drivers/s390/cio/ccwreq.c
index 5156264d0c74..0f8f9361061b 100644
--- a/drivers/s390/cio/ccwreq.c
+++ b/drivers/s390/cio/ccwreq.c
@@ -62,7 +62,7 @@ static void ccwreq_stop(struct ccw_device *cdev, int rc)
 		return;
 	req->done = 1;
 	ccw_device_set_timeout(cdev, 0);
-	memset(&cdev->private->irb, 0, sizeof(struct irb));
+	memset(&cdev->private->dma_area->irb, 0, sizeof(struct irb));
 	if (rc && rc != -ENODEV && req->drc)
 		rc = req->drc;
 	req->callback(cdev, req->data, rc);
@@ -85,7 +85,7 @@ static void ccwreq_do(struct ccw_device *cdev)
 			continue;
 		}
 		/* Perform start function. */
-		memset(&cdev->private->irb, 0, sizeof(struct irb));
+		memset(&cdev->private->dma_area->irb, 0, sizeof(struct irb));
 		rc = cio_start(sch, cp, (u8) req->mask);
 		if (rc == 0) {
 			/* I/O started successfully. */
@@ -168,7 +168,7 @@ int ccw_request_cancel(struct ccw_device *cdev)
  */
 static enum io_status ccwreq_status(struct ccw_device *cdev, struct irb *lcirb)
 {
-	struct irb *irb = &cdev->private->irb;
+	struct irb *irb = &cdev->private->dma_area->irb;
 	struct cmd_scsw *scsw = &irb->scsw.cmd;
 	enum uc_todo todo;
 
@@ -186,7 +186,8 @@ static enum io_status ccwreq_status(struct ccw_device *cdev, struct irb *lcirb)
 		CIO_TRACE_EVENT(2, "sensedata");
 		CIO_HEX_EVENT(2, &cdev->private->dev_id,
 			      sizeof(struct ccw_dev_id));
-		CIO_HEX_EVENT(2, &cdev->private->irb.ecw, SENSE_MAX_COUNT);
+		CIO_HEX_EVENT(2, &cdev->private->dma_area->irb.ecw,
+			      SENSE_MAX_COUNT);
 		/* Check for command reject. */
 		if (irb->ecw[0] & SNS0_CMD_REJECT)
 			return IO_REJECTED;
* Unmerged path drivers/s390/cio/device.c
* Unmerged path drivers/s390/cio/device_fsm.c
diff --git a/drivers/s390/cio/device_id.c b/drivers/s390/cio/device_id.c
index d4fa30541a33..5118bf18c6bc 100644
--- a/drivers/s390/cio/device_id.c
+++ b/drivers/s390/cio/device_id.c
@@ -98,7 +98,7 @@ static int diag210_to_senseid(struct senseid *senseid, struct diag210 *diag)
 static int diag210_get_dev_info(struct ccw_device *cdev)
 {
 	struct ccw_dev_id *dev_id = &cdev->private->dev_id;
-	struct senseid *senseid = &cdev->private->senseid;
+	struct senseid *senseid = &cdev->private->dma_area->senseid;
 	struct diag210 diag_data;
 	int rc;
 
@@ -133,8 +133,10 @@ err_failed:
 static void snsid_init(struct ccw_device *cdev)
 {
 	cdev->private->flags.esid = 0;
-	memset(&cdev->private->senseid, 0, sizeof(cdev->private->senseid));
-	cdev->private->senseid.cu_type = 0xffff;
+
+	memset(&cdev->private->dma_area->senseid, 0,
+	       sizeof(cdev->private->dma_area->senseid));
+	cdev->private->dma_area->senseid.cu_type = 0xffff;
 }
 
 /*
@@ -142,16 +144,16 @@ static void snsid_init(struct ccw_device *cdev)
  */
 static int snsid_check(struct ccw_device *cdev, void *data)
 {
-	struct cmd_scsw *scsw = &cdev->private->irb.scsw.cmd;
+	struct cmd_scsw *scsw = &cdev->private->dma_area->irb.scsw.cmd;
 	int len = sizeof(struct senseid) - scsw->count;
 
 	/* Check for incomplete SENSE ID data. */
 	if (len < SENSE_ID_MIN_LEN)
 		goto out_restart;
-	if (cdev->private->senseid.cu_type == 0xffff)
+	if (cdev->private->dma_area->senseid.cu_type == 0xffff)
 		goto out_restart;
 	/* Check for incompatible SENSE ID data. */
-	if (cdev->private->senseid.reserved != 0xff)
+	if (cdev->private->dma_area->senseid.reserved != 0xff)
 		return -EOPNOTSUPP;
 	/* Check for extended-identification information. */
 	if (len > SENSE_ID_BASIC_LEN)
@@ -169,7 +171,7 @@ out_restart:
 static void snsid_callback(struct ccw_device *cdev, void *data, int rc)
 {
 	struct ccw_dev_id *id = &cdev->private->dev_id;
-	struct senseid *senseid = &cdev->private->senseid;
+	struct senseid *senseid = &cdev->private->dma_area->senseid;
 	int vm = 0;
 
 	if (rc && MACHINE_IS_VM) {
@@ -199,7 +201,7 @@ void ccw_device_sense_id_start(struct ccw_device *cdev)
 {
 	struct subchannel *sch = to_subchannel(cdev->dev.parent);
 	struct ccw_request *req = &cdev->private->req;
-	struct ccw1 *cp = cdev->private->iccws;
+	struct ccw1 *cp = cdev->private->dma_area->iccws;
 
 	CIO_TRACE_EVENT(4, "snsid");
 	CIO_HEX_EVENT(4, &cdev->private->dev_id, sizeof(cdev->private->dev_id));
@@ -207,7 +209,7 @@ void ccw_device_sense_id_start(struct ccw_device *cdev)
 	snsid_init(cdev);
 	/* Channel program setup. */
 	cp->cmd_code	= CCW_CMD_SENSE_ID;
-	cp->cda		= (u32) (addr_t) &cdev->private->senseid;
+	cp->cda		= (u32) (addr_t) &cdev->private->dma_area->senseid;
 	cp->count	= sizeof(struct senseid);
 	cp->flags	= CCW_FLAG_SLI;
 	/* Request setup. */
* Unmerged path drivers/s390/cio/device_ops.c
diff --git a/drivers/s390/cio/device_pgid.c b/drivers/s390/cio/device_pgid.c
index 148b3fadac00..1fedc0c819b8 100644
--- a/drivers/s390/cio/device_pgid.c
+++ b/drivers/s390/cio/device_pgid.c
@@ -55,7 +55,7 @@ out:
 static void nop_build_cp(struct ccw_device *cdev)
 {
 	struct ccw_request *req = &cdev->private->req;
-	struct ccw1 *cp = cdev->private->iccws;
+	struct ccw1 *cp = cdev->private->dma_area->iccws;
 
 	cp->cmd_code	= CCW_CMD_NOOP;
 	cp->cda		= 0;
@@ -132,9 +132,9 @@ err:
 static void spid_build_cp(struct ccw_device *cdev, u8 fn)
 {
 	struct ccw_request *req = &cdev->private->req;
-	struct ccw1 *cp = cdev->private->iccws;
+	struct ccw1 *cp = cdev->private->dma_area->iccws;
 	int i = pathmask_to_pos(req->lpm);
-	struct pgid *pgid = &cdev->private->pgid[i];
+	struct pgid *pgid = &cdev->private->dma_area->pgid[i];
 
 	pgid->inf.fc	= fn;
 	cp->cmd_code	= CCW_CMD_SET_PGID;
@@ -298,7 +298,7 @@ static int pgid_cmp(struct pgid *p1, struct pgid *p2)
 static void pgid_analyze(struct ccw_device *cdev, struct pgid **p,
 			 int *mismatch, u8 *reserved, u8 *reset)
 {
-	struct pgid *pgid = &cdev->private->pgid[0];
+	struct pgid *pgid = &cdev->private->dma_area->pgid[0];
 	struct pgid *first = NULL;
 	int lpm;
 	int i;
@@ -340,7 +340,7 @@ static u8 pgid_to_donepm(struct ccw_device *cdev)
 		lpm = 0x80 >> i;
 		if ((cdev->private->pgid_valid_mask & lpm) == 0)
 			continue;
-		pgid = &cdev->private->pgid[i];
+		pgid = &cdev->private->dma_area->pgid[i];
 		if (sch->opm & lpm) {
 			if (pgid->inf.ps.state1 != SNID_STATE1_GROUPED)
 				continue;
@@ -366,7 +366,8 @@ static void pgid_fill(struct ccw_device *cdev, struct pgid *pgid)
 	int i;
 
 	for (i = 0; i < 8; i++)
-		memcpy(&cdev->private->pgid[i], pgid, sizeof(struct pgid));
+		memcpy(&cdev->private->dma_area->pgid[i], pgid,
+		       sizeof(struct pgid));
 }
 
 /*
@@ -433,12 +434,12 @@ out:
 static void snid_build_cp(struct ccw_device *cdev)
 {
 	struct ccw_request *req = &cdev->private->req;
-	struct ccw1 *cp = cdev->private->iccws;
+	struct ccw1 *cp = cdev->private->dma_area->iccws;
 	int i = pathmask_to_pos(req->lpm);
 
 	/* Channel program setup. */
 	cp->cmd_code	= CCW_CMD_SENSE_PGID;
-	cp->cda		= (u32) (addr_t) &cdev->private->pgid[i];
+	cp->cda		= (u32) (addr_t) &cdev->private->dma_area->pgid[i];
 	cp->count	= sizeof(struct pgid);
 	cp->flags	= CCW_FLAG_SLI;
 	req->cp		= cp;
@@ -514,7 +515,8 @@ static void verify_start(struct ccw_device *cdev)
 	sch->lpm = sch->schib.pmcw.pam;
 
 	/* Initialize PGID data. */
-	memset(cdev->private->pgid, 0, sizeof(cdev->private->pgid));
+	memset(cdev->private->dma_area->pgid, 0,
+	       sizeof(cdev->private->dma_area->pgid));
 	cdev->private->pgid_valid_mask = 0;
 	cdev->private->pgid_todo_mask = sch->schib.pmcw.pam;
 	cdev->private->path_notoper_mask = 0;
@@ -619,7 +621,7 @@ void ccw_device_disband_start(struct ccw_device *cdev)
 static void stlck_build_cp(struct ccw_device *cdev, void *buf1, void *buf2)
 {
 	struct ccw_request *req = &cdev->private->req;
-	struct ccw1 *cp = cdev->private->iccws;
+	struct ccw1 *cp = cdev->private->dma_area->iccws;
 
 	cp[0].cmd_code = CCW_CMD_STLCK;
 	cp[0].cda = (u32) (addr_t) buf1;
diff --git a/drivers/s390/cio/device_status.c b/drivers/s390/cio/device_status.c
index 15b56a15db15..51527396e766 100644
--- a/drivers/s390/cio/device_status.c
+++ b/drivers/s390/cio/device_status.c
@@ -77,15 +77,15 @@ ccw_device_accumulate_ecw(struct ccw_device *cdev, struct irb *irb)
 	 * are condition that have to be met for the extended control
 	 * bit to have meaning. Sick.
 	 */
-	cdev->private->irb.scsw.cmd.ectl = 0;
+	cdev->private->dma_area->irb.scsw.cmd.ectl = 0;
 	if ((irb->scsw.cmd.stctl & SCSW_STCTL_ALERT_STATUS) &&
 	    !(irb->scsw.cmd.stctl & SCSW_STCTL_INTER_STATUS))
-		cdev->private->irb.scsw.cmd.ectl = irb->scsw.cmd.ectl;
+		cdev->private->dma_area->irb.scsw.cmd.ectl = irb->scsw.cmd.ectl;
 	/* Check if extended control word is valid. */
-	if (!cdev->private->irb.scsw.cmd.ectl)
+	if (!cdev->private->dma_area->irb.scsw.cmd.ectl)
 		return;
 	/* Copy concurrent sense / model dependent information. */
-	memcpy (&cdev->private->irb.ecw, irb->ecw, sizeof (irb->ecw));
+	memcpy(&cdev->private->dma_area->irb.ecw, irb->ecw, sizeof(irb->ecw));
 }
 
 /*
@@ -116,7 +116,7 @@ ccw_device_accumulate_esw(struct ccw_device *cdev, struct irb *irb)
 	if (!ccw_device_accumulate_esw_valid(irb))
 		return;
 
-	cdev_irb = &cdev->private->irb;
+	cdev_irb = &cdev->private->dma_area->irb;
 
 	/* Copy last path used mask. */
 	cdev_irb->esw.esw1.lpum = irb->esw.esw1.lpum;
@@ -208,7 +208,7 @@ ccw_device_accumulate_irb(struct ccw_device *cdev, struct irb *irb)
 		ccw_device_path_notoper(cdev);
 	/* No irb accumulation for transport mode irbs. */
 	if (scsw_is_tm(&irb->scsw)) {
-		memcpy(&cdev->private->irb, irb, sizeof(struct irb));
+		memcpy(&cdev->private->dma_area->irb, irb, sizeof(struct irb));
 		return;
 	}
 	/*
@@ -217,7 +217,7 @@ ccw_device_accumulate_irb(struct ccw_device *cdev, struct irb *irb)
 	if (!scsw_is_solicited(&irb->scsw))
 		return;
 
-	cdev_irb = &cdev->private->irb;
+	cdev_irb = &cdev->private->dma_area->irb;
 
 	/*
 	 * If the clear function had been performed, all formerly pending
@@ -225,7 +225,7 @@ ccw_device_accumulate_irb(struct ccw_device *cdev, struct irb *irb)
 	 * intermediate accumulated status to the device driver.
 	 */
 	if (irb->scsw.cmd.fctl & SCSW_FCTL_CLEAR_FUNC)
-		memset(&cdev->private->irb, 0, sizeof(struct irb));
+		memset(&cdev->private->dma_area->irb, 0, sizeof(struct irb));
 
 	/* Copy bits which are valid only for the start function. */
 	if (irb->scsw.cmd.fctl & SCSW_FCTL_START_FUNC) {
@@ -327,9 +327,9 @@ ccw_device_do_sense(struct ccw_device *cdev, struct irb *irb)
 	/*
 	 * We have ending status but no sense information. Do a basic sense.
 	 */
-	sense_ccw = &to_io_private(sch)->sense_ccw;
+	sense_ccw = &to_io_private(sch)->dma_area->sense_ccw;
 	sense_ccw->cmd_code = CCW_CMD_BASIC_SENSE;
-	sense_ccw->cda = (__u32) __pa(cdev->private->irb.ecw);
+	sense_ccw->cda = (__u32) __pa(cdev->private->dma_area->irb.ecw);
 	sense_ccw->count = SENSE_MAX_COUNT;
 	sense_ccw->flags = CCW_FLAG_SLI;
 
@@ -362,7 +362,7 @@ ccw_device_accumulate_basic_sense(struct ccw_device *cdev, struct irb *irb)
 
 	if (!(irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) &&
 	    (irb->scsw.cmd.dstat & DEV_STAT_CHN_END)) {
-		cdev->private->irb.esw.esw0.erw.cons = 1;
+		cdev->private->dma_area->irb.esw.esw0.erw.cons = 1;
 		cdev->private->flags.dosense = 0;
 	}
 	/* Check if path verification is required. */
@@ -384,7 +384,7 @@ ccw_device_accumulate_and_sense(struct ccw_device *cdev, struct irb *irb)
 	/* Check for basic sense. */
 	if (cdev->private->flags.dosense &&
 	    !(irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK)) {
-		cdev->private->irb.esw.esw0.erw.cons = 1;
+		cdev->private->dma_area->irb.esw.esw0.erw.cons = 1;
 		cdev->private->flags.dosense = 0;
 		return 0;
 	}
* Unmerged path drivers/s390/cio/io_sch.h
* Unmerged path drivers/s390/virtio/virtio_ccw.c
