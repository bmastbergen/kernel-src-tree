net/mlx5e: Disallow tc redirect offload cases we don't support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Paul Blakey <paulb@mellanox.com>
commit f6dc1264f1c01976a84239d1038359604ee42001
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/f6dc1264.failed

After changing the parent_id to be the same for both NICs of same
the hardware device, netdev_port_same_parent_id now returns true for
more cases (all the lower devices in the hierarchy are on the same
hardware device).

If merged eswitch isn't enabled, these cases aren't supported, so disallow
them.

	Signed-off-by: Paul Blakey <paulb@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit f6dc1264f1c01976a84239d1038359604ee42001)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index c47f64762949,e6b199cd68ea..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -2572,8 -2757,63 +2572,68 @@@ static int parse_tc_vlan_action(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
 +				struct mlx5e_tc_flow_parse_attr *parse_attr,
++=======
+ static int add_vlan_push_action(struct mlx5e_priv *priv,
+ 				struct mlx5_esw_flow_attr *attr,
+ 				struct net_device **out_dev,
+ 				u32 *action)
+ {
+ 	struct net_device *vlan_dev = *out_dev;
+ 	struct flow_action_entry vlan_act = {
+ 		.id = FLOW_ACTION_VLAN_PUSH,
+ 		.vlan.vid = vlan_dev_vlan_id(vlan_dev),
+ 		.vlan.proto = vlan_dev_vlan_proto(vlan_dev),
+ 		.vlan.prio = 0,
+ 	};
+ 	int err;
+ 
+ 	err = parse_tc_vlan_action(priv, &vlan_act, attr, action);
+ 	if (err)
+ 		return err;
+ 
+ 	*out_dev = dev_get_by_index_rcu(dev_net(vlan_dev),
+ 					dev_get_iflink(vlan_dev));
+ 	if (is_vlan_dev(*out_dev))
+ 		err = add_vlan_push_action(priv, attr, out_dev, action);
+ 
+ 	return err;
+ }
+ 
+ static int add_vlan_pop_action(struct mlx5e_priv *priv,
+ 			       struct mlx5_esw_flow_attr *attr,
+ 			       u32 *action)
+ {
+ 	int nest_level = vlan_get_encap_level(attr->parse_attr->filter_dev);
+ 	struct flow_action_entry vlan_act = {
+ 		.id = FLOW_ACTION_VLAN_POP,
+ 	};
+ 	int err = 0;
+ 
+ 	while (nest_level--) {
+ 		err = parse_tc_vlan_action(priv, &vlan_act, attr, action);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ bool mlx5e_is_valid_eswitch_fwd_dev(struct mlx5e_priv *priv,
+ 				    struct net_device *out_dev)
+ {
+ 	if (is_merged_eswitch_dev(priv, out_dev))
+ 		return true;
+ 
+ 	return mlx5e_eswitch_rep(out_dev) &&
+ 	       same_hw_devs(priv, netdev_priv(out_dev));
+ }
+ 
+ static int parse_tc_fdb_actions(struct mlx5e_priv *priv,
+ 				struct flow_action *flow_action,
++>>>>>>> f6dc1264f1c0 (net/mlx5e: Disallow tc redirect offload cases we don't support)
  				struct mlx5e_tc_flow *flow,
  				struct netlink_ext_ack *extack)
  {
@@@ -2644,9 -2877,7 +2704,13 @@@
  
  			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
  				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
++<<<<<<< HEAD
 +			if (switchdev_port_same_parent_id(priv->netdev,
 +							  out_dev) ||
 +			    is_merged_eswitch_dev(priv, out_dev)) {
++=======
+ 			if (netdev_port_same_parent_id(priv->netdev, out_dev)) {
++>>>>>>> f6dc1264f1c0 (net/mlx5e: Disallow tc redirect offload cases we don't support)
  				struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
  				struct net_device *uplink_dev = mlx5_eswitch_uplink_get_proto_dev(esw, REP_ETH);
  				struct net_device *uplink_upper = netdev_master_upper_dev_get(uplink_dev);
@@@ -2656,8 -2887,28 +2720,32 @@@
  				    uplink_upper == out_dev)
  					out_dev = uplink_dev;
  
++<<<<<<< HEAD
 +				if (!mlx5e_eswitch_rep(out_dev))
++=======
+ 				if (is_vlan_dev(out_dev)) {
+ 					err = add_vlan_push_action(priv, attr,
+ 								   &out_dev,
+ 								   &action);
+ 					if (err)
+ 						return err;
+ 				}
+ 
+ 				if (is_vlan_dev(parse_attr->filter_dev)) {
+ 					err = add_vlan_pop_action(priv, attr,
+ 								  &action);
+ 					if (err)
+ 						return err;
+ 				}
+ 
+ 				if (!mlx5e_is_valid_eswitch_fwd_dev(priv, out_dev)) {
+ 					NL_SET_ERR_MSG_MOD(extack,
+ 							   "devices are not on same switch HW, can't offload forwarding");
+ 					pr_err("devices %s %s not on same switch HW, can't offload forwarding\n",
+ 					       priv->netdev->name, out_dev->name);
++>>>>>>> f6dc1264f1c0 (net/mlx5e: Disallow tc redirect offload cases we don't support)
  					return -EOPNOTSUPP;
+ 				}
  
  				out_priv = netdev_priv(out_dev);
  				rpriv = out_priv->ppriv;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
index 0b62b9baba02..c46d3e433ef1 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
@@ -5,6 +5,7 @@
 #include <net/gre.h>
 #include "lib/vxlan.h"
 #include "en/tc_tun.h"
+#include "en_tc.h"
 
 static int get_route_and_out_devs(struct mlx5e_priv *priv,
 				  struct net_device *dev,
@@ -33,7 +34,8 @@ static int get_route_and_out_devs(struct mlx5e_priv *priv,
 		*route_dev = dev;
 		if (is_vlan_dev(*route_dev))
 			*out_dev = uplink_dev;
-		else if (mlx5e_eswitch_rep(dev))
+		else if (mlx5e_eswitch_rep(dev) &&
+			 mlx5e_is_valid_eswitch_fwd_dev(priv, dev))
 			*out_dev = *route_dev;
 		else
 			return -EOPNOTSUPP;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index a15c08a35054..590fb7e9dc5c 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -71,6 +71,9 @@ void mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe);
 int mlx5e_tc_num_filters(struct mlx5e_priv *priv);
 
 
+bool mlx5e_is_valid_eswitch_fwd_dev(struct mlx5e_priv *priv,
+				    struct net_device *out_dev);
+
 #else /* CONFIG_MLX5_ESWITCH */
 static inline int  mlx5e_tc_nic_init(struct mlx5e_priv *priv) { return 0; }
 static inline void mlx5e_tc_nic_cleanup(struct mlx5e_priv *priv) {}
