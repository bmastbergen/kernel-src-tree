tcp: be more careful in tcp_fragment()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Eric Dumazet <edumazet@google.com>
commit b617158dc096709d8600c53b6052144d12b89fab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/b617158d.failed

Some applications set tiny SO_SNDBUF values and expect
TCP to just work. Recent patches to address CVE-2019-11478
broke them in case of losses, since retransmits might
be prevented.

We should allow these flows to make progress.

This patch allows the first and last skb in retransmit queue
to be split even if memory limits are hit.

It also adds the some room due to the fact that tcp_sendmsg()
and tcp_sendpage() might overshoot sk_wmem_queued by about one full
TSO skb (64KB size). Note this allowance was already present
in stable backports for kernels < 4.15

Note for < 4.15 backports :
 tcp_rtx_queue_tail() will probably look like :

static inline struct sk_buff *tcp_rtx_queue_tail(const struct sock *sk)
{
	struct sk_buff *skb = tcp_send_head(sk);

	return skb ? tcp_write_queue_prev(sk, skb) : tcp_write_queue_tail(sk);
}

Fixes: f070ef2ac667 ("tcp: tcp_fragment() should apply sane memory limits")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reported-by: Andrew Prout <aprout@ll.mit.edu>
	Tested-by: Andrew Prout <aprout@ll.mit.edu>
	Tested-by: Jonathan Lemon <jonathan.lemon@gmail.com>
	Tested-by: Michal Kubecek <mkubecek@suse.cz>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Acked-by: Yuchung Cheng <ycheng@google.com>
	Acked-by: Christoph Paasch <cpaasch@apple.com>
	Cc: Jonathan Looney <jtl@netflix.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b617158dc096709d8600c53b6052144d12b89fab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_output.c
diff --cc net/ipv4/tcp_output.c
index f0c4ad73bc91,6e4afc48d7bb..000000000000
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@@ -1130,9 -1299,16 +1131,22 @@@ int tcp_fragment(struct sock *sk, enum 
  	if (nsize < 0)
  		nsize = 0;
  
++<<<<<<< HEAD
 +	if (unlikely(((sk->sk_wmem_queued >> 1) > sk->sk_sndbuf &&
 +	    tcp_queue != TCP_FRAG_IN_WRITE_QUEUE) ||
 +	    skb_queue_len(&sk->sk_write_queue) > 2048)) {
++=======
+ 	/* tcp_sendmsg() can overshoot sk_wmem_queued by one full size skb.
+ 	 * We need some allowance to not penalize applications setting small
+ 	 * SO_SNDBUF values.
+ 	 * Also allow first and last skb in retransmit queue to be split.
+ 	 */
+ 	limit = sk->sk_sndbuf + 2 * SKB_TRUESIZE(GSO_MAX_SIZE);
+ 	if (unlikely((sk->sk_wmem_queued >> 1) > limit &&
+ 		     tcp_queue != TCP_FRAG_IN_WRITE_QUEUE &&
+ 		     skb != tcp_rtx_queue_head(sk) &&
+ 		     skb != tcp_rtx_queue_tail(sk))) {
++>>>>>>> b617158dc096 (tcp: be more careful in tcp_fragment())
  		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPWQUEUETOOBIG);
  		return -ENOMEM;
  	}
diff --git a/include/net/tcp.h b/include/net/tcp.h
index 70aafc9c61c1..9d1aa39f1c75 100644
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -1396,6 +1396,11 @@ static inline void tcp_write_queue_purge(struct sock *sk)
 	tcp_clear_all_retrans_hints(tcp_sk(sk));
 }
 
+static inline struct sk_buff *tcp_rtx_queue_tail(const struct sock *sk)
+{
+	return skb_rb_last(&sk->tcp_rtx_queue);
+}
+
 static inline struct sk_buff *tcp_write_queue_head(const struct sock *sk)
 {
 	return skb_peek(&sk->sk_write_queue);
* Unmerged path net/ipv4/tcp_output.c
