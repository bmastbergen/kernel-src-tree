audit: add kernel set-up parameter to override default backlog limit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Richard Guy Briggs <rgb@redhat.com>
commit f910fde7307be80a1a228bba969c492f61f13281
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/f910fde7.failed

The default audit_backlog_limit is 64.  This was a reasonable limit at one time.

systemd causes so much audit queue activity on startup that auditd doesn't
start before the backlog queue has already overflowed by more than a factor of
2.  On a system with audit= not set on the kernel command line, this isn't an
issue since that history isn't kept for auditd when it is available.  On a
system with audit=1 set on the kernel command line, kaudit tries to keep that
history until auditd is able to drain the queue.

This default can be changed by the "-b" option in audit.rules once the system
has booted, but won't help with lost messages on boot.

One way to solve this would be to increase the default backlog queue size to
avoid losing any messages before auditd is able to consume them.  This would
be overkill to the embedded community and insufficient for some servers.

Another way to solve it might be to add a kconfig option to set the default
based on the system type.  An embedded system would get the current (or
smaller) default, while Workstations might get more than now and servers might
get more.

None of these solutions helps if a system's compiled default is too small to
see the lost messages without compiling a new kernel.

This patch adds a kernel set-up parameter (audit already has one to
enable/disable it) "audit_backlog_limit=<n>" that overrides the default to
allow the system administrator to set the backlog limit.

	Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
	Signed-off-by: Eric Paris <eparis@redhat.com>
(cherry picked from commit f910fde7307be80a1a228bba969c492f61f13281)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/kernel-parameters.txt
diff --cc Documentation/kernel-parameters.txt
index 4ee8a23b1fd1,ab86766e28cb..000000000000
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@@ -458,12 -463,13 +458,22 @@@ bytes respectively. Such letter suffixe
  	atkbd.softrepeat= [HW]
  			Use software keyboard repeat
  
++<<<<<<< HEAD
 +	bau=		[X86_UV] Enable the BAU on SGI UV.  The default
 +			behavior is to disable the BAU (i.e. bau=0).
 +			Format: { "0" | "1" }
 +			0 - Disable the BAU.
 +			1 - Enable the BAU.
 +			unset - Disable the BAU.
++=======
+ 	audit=		[KNL] Enable the audit sub-system
+ 			Format: { "0" | "1" } (0 = disabled, 1 = enabled)
+ 			Default: unset
+ 			
+ 	audit_backlog_limit= [KNL] Set the audit queue size limit.
+ 			Format: <int> (must be >=0)
+ 			Default: 64
++>>>>>>> f910fde7307b (audit: add kernel set-up parameter to override default backlog limit)
  
  	baycom_epp=	[HW,AX25]
  			Format: <io>,<mode>
* Unmerged path Documentation/kernel-parameters.txt
diff --git a/kernel/audit.c b/kernel/audit.c
index 190c6372a817..69b7ac0286a1 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -1128,9 +1128,27 @@ static int __init audit_enable(char *str)
 
 	return 1;
 }
-
 __setup("audit=", audit_enable);
 
+/* Process kernel command-line parameter at boot time.
+ * audit_backlog_limit=<n> */
+static int __init audit_backlog_limit_set(char *str)
+{
+	long int audit_backlog_limit_arg;
+	pr_info("audit_backlog_limit: ");
+	if (kstrtol(str, 0, &audit_backlog_limit_arg)) {
+		printk("using default of %d, unable to parse %s\n",
+		       audit_backlog_limit, str);
+		return 1;
+	}
+	if (audit_backlog_limit_arg >= 0)
+		audit_backlog_limit = (int)audit_backlog_limit_arg;
+	printk("%d\n", audit_backlog_limit);
+
+	return 1;
+}
+__setup("audit_backlog_limit=", audit_backlog_limit_set);
+
 static void audit_buffer_free(struct audit_buffer *ab)
 {
 	unsigned long flags;
