gfs2: Clean up freeing struct gfs2_sbd

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 2a27b755ed244527df845f07f4dd83988a90f2e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/2a27b755.failed

Add a free_sbd function for freeing a struct gfs2_sbd.  Use that for
freeing a super-block descriptor, either directly or via kobject_put.
Free sd_lkstats inside the kobject release function: that way,
gfs2_put_super will no longer leak sd_lkstats.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 2a27b755ed244527df845f07f4dd83988a90f2e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/ops_fstype.c
#	fs/gfs2/sys.c
diff --cc fs/gfs2/ops_fstype.c
index c852d6352870,8d614f599065..000000000000
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@@ -67,13 -77,11 +74,19 @@@ static struct gfs2_sbd *init_sbd(struc
  	if (!sdp)
  		return NULL;
  
 +	sb->s_fs_info = sdp;
  	sdp->sd_vfs = sb;
  	sdp->sd_lkstats = alloc_percpu(struct gfs2_pcpu_lkstats);
++<<<<<<< HEAD
 +	if (!sdp->sd_lkstats) {
 +		kfree(sdp);
 +		return NULL;
 +	}
++=======
+ 	if (!sdp->sd_lkstats)
+ 		goto fail;
+ 	sb->s_fs_info = sdp;
++>>>>>>> 2a27b755ed24 (gfs2: Clean up freeing struct gfs2_sbd)
  
  	set_bit(SDF_NOJOURNALID, &sdp->sd_flags);
  	gfs2_tune_init(&sdp->sd_tune);
@@@ -114,11 -132,18 +127,14 @@@
  
  	init_rwsem(&sdp->sd_log_flush_lock);
  	atomic_set(&sdp->sd_log_in_flight, 0);
 -	atomic_set(&sdp->sd_reserving_log, 0);
 -	init_waitqueue_head(&sdp->sd_reserving_log_wait);
  	init_waitqueue_head(&sdp->sd_log_flush_wait);
 -	atomic_set(&sdp->sd_freeze_state, SFS_UNFROZEN);
 -	mutex_init(&sdp->sd_freeze_mutex);
  
  	return sdp;
- }
  
+ fail:
+ 	free_sbd(sdp);
+ 	return NULL;
+ }
  
  /**
   * gfs2_check_sb - Check superblock
@@@ -1407,8 -1376,6 +1421,11 @@@ static void gfs2_kill_sb(struct super_b
  	sdp->sd_root_dir = NULL;
  	sdp->sd_master_dir = NULL;
  	shrink_dcache_sb(sb);
++<<<<<<< HEAD
 +	gfs2_delete_debugfs_file(sdp);
 +	free_percpu(sdp->sd_lkstats);
++=======
++>>>>>>> 2a27b755ed24 (gfs2: Clean up freeing struct gfs2_sbd)
  	kill_block_super(sb);
  }
  
diff --cc fs/gfs2/sys.c
index 0c2a60fa66d7,325612ce1c6b..000000000000
--- a/fs/gfs2/sys.c
+++ b/fs/gfs2/sys.c
@@@ -664,12 -679,8 +664,17 @@@ fail_lock_module
  fail_tune:
  	sysfs_remove_group(&sdp->sd_kobj, &tune_group);
  fail_reg:
++<<<<<<< HEAD
 +	free_percpu(sdp->sd_lkstats);
 +	fs_err(sdp, "error %d adding sysfs files", error);
 +	if (sysfs_frees_sdp)
 +		kobject_put(&sdp->sd_kobj);
 +	else
 +		kfree(sdp);
++=======
+ 	fs_err(sdp, "error %d adding sysfs files\n", error);
+ 	kobject_put(&sdp->sd_kobj);
++>>>>>>> 2a27b755ed24 (gfs2: Clean up freeing struct gfs2_sbd)
  	sb->s_fs_info = NULL;
  	return error;
  }
* Unmerged path fs/gfs2/ops_fstype.c
diff --git a/fs/gfs2/super.h b/fs/gfs2/super.h
index 90e3322ffa10..eebb62e5a48b 100644
--- a/fs/gfs2/super.h
+++ b/fs/gfs2/super.h
@@ -46,6 +46,8 @@ extern void update_statfs(struct gfs2_sbd *sdp, struct buffer_head *m_bh,
 			  struct buffer_head *l_bh);
 extern int gfs2_statfs_sync(struct super_block *sb, int type);
 
+extern void free_sbd(struct gfs2_sbd *sdp);
+
 extern struct file_system_type gfs2_fs_type;
 extern struct file_system_type gfs2meta_fs_type;
 extern const struct export_operations gfs2_export_ops;
* Unmerged path fs/gfs2/sys.c
