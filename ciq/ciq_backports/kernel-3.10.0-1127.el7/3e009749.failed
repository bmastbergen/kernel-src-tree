scsi: sg: fixup infoleak when using SG_GET_REQUEST_TABLE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Hannes Reinecke <hare@suse.de>
commit 3e0097499839e0fe3af380410eababe5a47c4cf9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/3e009749.failed

When calling SG_GET_REQUEST_TABLE ioctl only a half-filled table is
returned; the remaining part will then contain stale kernel memory
information.  This patch zeroes out the entire table to avoid this
issue.

	Signed-off-by: Hannes Reinecke <hare@suse.com>
	Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 3e0097499839e0fe3af380410eababe5a47c4cf9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/sg.c
diff --cc drivers/scsi/sg.c
index 19ec234ee455,0419c2298eab..000000000000
--- a/drivers/scsi/sg.c
+++ b/drivers/scsi/sg.c
@@@ -828,6 -819,48 +828,51 @@@ static int srp_done(Sg_fd *sfp, Sg_requ
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int max_sectors_bytes(struct request_queue *q)
+ {
+ 	unsigned int max_sectors = queue_max_sectors(q);
+ 
+ 	max_sectors = min_t(unsigned int, max_sectors, INT_MAX >> 9);
+ 
+ 	return max_sectors << 9;
+ }
+ 
+ static void
+ sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo)
+ {
+ 	Sg_request *srp;
+ 	int val;
+ 	unsigned int ms;
+ 
+ 	val = 0;
+ 	list_for_each_entry(srp, &sfp->rq_list, entry) {
+ 		if (val > SG_MAX_QUEUE)
+ 			break;
+ 		rinfo[val].req_state = srp->done + 1;
+ 		rinfo[val].problem =
+ 			srp->header.masked_status &
+ 			srp->header.host_status &
+ 			srp->header.driver_status;
+ 		if (srp->done)
+ 			rinfo[val].duration =
+ 				srp->header.duration;
+ 		else {
+ 			ms = jiffies_to_msecs(jiffies);
+ 			rinfo[val].duration =
+ 				(ms > srp->header.duration) ?
+ 				(ms - srp->header.duration) : 0;
+ 		}
+ 		rinfo[val].orphan = srp->orphan;
+ 		rinfo[val].sg_io_owned = srp->sg_io_owned;
+ 		rinfo[val].pack_id = srp->header.pack_id;
+ 		rinfo[val].usr_ptr = srp->header.usr_ptr;
+ 		val++;
+ 	}
+ }
+ 
++>>>>>>> 3e0097499839 (scsi: sg: fixup infoleak when using SG_GET_REQUEST_TABLE)
  static long
  sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)
  {
@@@ -1014,10 -1045,9 +1059,10 @@@
  			return -EFAULT;
  		else {
  			sg_req_info_t *rinfo;
 +			unsigned int ms;
  
- 			rinfo = kmalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE,
- 								GFP_KERNEL);
+ 			rinfo = kzalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE,
+ 					GFP_KERNEL);
  			if (!rinfo)
  				return -ENOMEM;
  			read_lock_irqsave(&sfp->rq_list_lock, iflags);
* Unmerged path drivers/scsi/sg.c
