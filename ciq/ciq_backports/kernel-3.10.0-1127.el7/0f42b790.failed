x86/cpufeature: Add facility to check for min microcode revisions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [x86] cpufeature: Add facility to check for min microcode revisions (Jiri Olsa) [1482406]
Rebuild_FUZZ: 96.83%
commit-author Kan Liang <kan.liang@linux.intel.com>
commit 0f42b790c9ba5ec2f25b7da8b0b6d361082d67b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/0f42b790.failed

For bug workarounds or checks, it is useful to check for specific
microcode revisions.

Add a new generic function to match the CPU with stepping.
Add the other function to check the min microcode revisions for
the matched CPU.

A new table format is introduced to facilitate the quirk to
fill the related information.

This does not change the existing x86_cpu_id because it's an ABI
shared with modules, and also has quite different requirements,
as in no wildcards, but everything has to be matched exactly.

Originally-by: Andi Kleen <ak@linux.intel.com>
	Suggested-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Kan Liang <kan.liang@linux.intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Acked-by: Borislav Petkov <bp@alien8.de>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: eranian@google.com
Link: https://lkml.kernel.org/r/1549319013-4522-1-git-send-email-kan.liang@linux.intel.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 0f42b790c9ba5ec2f25b7da8b0b6d361082d67b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/match.c
diff --cc arch/x86/kernel/cpu/match.c
index 98e780a94c11,6dd78d8235e4..000000000000
--- a/arch/x86/kernel/cpu/match.c
+++ b/arch/x86/kernel/cpu/match.c
@@@ -48,44 -49,33 +48,77 @@@ const struct x86_cpu_id *x86_match_cpu(
  }
  EXPORT_SYMBOL(x86_match_cpu);
  
++<<<<<<< HEAD
 +ssize_t arch_print_cpu_modalias(struct device *dev,
 +				struct device_attribute *attr,
 +				char *bufptr)
 +{
 +	int size = PAGE_SIZE;
 +	int i, n;
 +	char *buf = bufptr;
 +
 +	n = snprintf(buf, size, "x86cpu:vendor:%04X:family:%04X:"
 +		     "model:%04X:feature:",
 +		boot_cpu_data.x86_vendor,
 +		boot_cpu_data.x86,
 +		boot_cpu_data.x86_model);
 +	size -= n;
 +	buf += n;
 +	size -= 1;
 +	for (i = 0; i < NCAPINTS*32; i++) {
 +		if (boot_cpu_has(i)) {
 +			n = snprintf(buf, size, ",%04X", i);
 +			if (n >= size) {
 +				WARN(1, "x86 features overflow page\n");
 +				break;
 +			}
 +			size -= n;
 +			buf += n;
 +		}
 +	}
 +	*buf++ = '\n';
 +	return buf - bufptr;
 +}
 +
 +int arch_cpu_uevent(struct device *dev, struct kobj_uevent_env *env)
 +{
 +	char *buf = kzalloc(PAGE_SIZE, GFP_KERNEL);
 +	if (buf) {
 +		arch_print_cpu_modalias(NULL, NULL, buf);
 +		add_uevent_var(env, "MODALIAS=%s", buf);
 +		kfree(buf);
 +	}
 +	return 0;
 +}
++=======
+ static const struct x86_cpu_desc *
+ x86_match_cpu_with_stepping(const struct x86_cpu_desc *match)
+ {
+ 	struct cpuinfo_x86 *c = &boot_cpu_data;
+ 	const struct x86_cpu_desc *m;
+ 
+ 	for (m = match; m->x86_family | m->x86_model; m++) {
+ 		if (c->x86_vendor != m->x86_vendor)
+ 			continue;
+ 		if (c->x86 != m->x86_family)
+ 			continue;
+ 		if (c->x86_model != m->x86_model)
+ 			continue;
+ 		if (c->x86_stepping != m->x86_stepping)
+ 			continue;
+ 		return m;
+ 	}
+ 	return NULL;
+ }
+ 
+ bool x86_cpu_has_min_microcode_rev(const struct x86_cpu_desc *table)
+ {
+ 	const struct x86_cpu_desc *res = x86_match_cpu_with_stepping(table);
+ 
+ 	if (!res || res->x86_microcode_rev > boot_cpu_data.microcode)
+ 		return false;
+ 
+ 	return true;
+ }
+ EXPORT_SYMBOL_GPL(x86_cpu_has_min_microcode_rev);
++>>>>>>> 0f42b790c9ba (x86/cpufeature: Add facility to check for min microcode revisions)
diff --git a/arch/x86/include/asm/cpu_device_id.h b/arch/x86/include/asm/cpu_device_id.h
index ff501e511d91..0d72cb7c4c6e 100644
--- a/arch/x86/include/asm/cpu_device_id.h
+++ b/arch/x86/include/asm/cpu_device_id.h
@@ -10,4 +10,32 @@
 
 extern const struct x86_cpu_id *x86_match_cpu(const struct x86_cpu_id *match);
 
+/*
+ * Match specific microcode revisions.
+ *
+ * vendor/family/model/stepping must be all set.
+ *
+ * Only checks against the boot CPU.  When mixed-stepping configs are
+ * valid for a CPU model, add a quirk for every valid stepping and
+ * do the fine-tuning in the quirk handler.
+ */
+
+struct x86_cpu_desc {
+	__u8	x86_family;
+	__u8	x86_vendor;
+	__u8	x86_model;
+	__u8	x86_stepping;
+	__u32	x86_microcode_rev;
+};
+
+#define INTEL_CPU_DESC(mod, step, rev) {			\
+	.x86_family = 6,					\
+	.x86_vendor = X86_VENDOR_INTEL,				\
+	.x86_model = mod,					\
+	.x86_stepping = step,					\
+	.x86_microcode_rev = rev,				\
+}
+
+extern bool x86_cpu_has_min_microcode_rev(const struct x86_cpu_desc *table);
+
 #endif
* Unmerged path arch/x86/kernel/cpu/match.c
