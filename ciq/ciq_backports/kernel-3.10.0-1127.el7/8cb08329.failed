fuse: Support fuse filesystems outside of init_user_ns

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 8cb08329b0809453722bc12aa912be34355bcb66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/8cb08329.failed

In order to support mounts from namespaces other than init_user_ns, fuse
must translate uids and gids to/from the userns of the process servicing
requests on /dev/fuse. This patch does that, with a couple of restrictions
on the namespace:

 - The userns for the fuse connection is fixed to the namespace
   from which /dev/fuse is opened.

 - The namespace must be the same as s_user_ns.

These restrictions simplify the implementation by avoiding the need to pass
around userns references and by allowing fuse to rely on the checks in
setattr_prepare for ownership changes.  Either restriction could be relaxed
in the future if needed.

For cuse the userns used is the opener of /dev/cuse.  Semantically the cuse
support does not appear safe for unprivileged users.  Practically the
permissions on /dev/cuse only make it accessible to the global root user.
If something slips through the cracks in a user namespace the only users
who will be able to use the cuse device are those users mapped into the
user namespace.

Translation in the posix acl is updated to use the uuser namespace of the
filesystem.  Avoiding cases which might bypass this translation is handled
in a following change.

This change is stronlgy based on a similar change from Seth Forshee and
Dongsu Park.

	Cc: Seth Forshee <seth.forshee@canonical.com>
	Cc: Dongsu Park <dongsu@kinvolk.io>
	Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 8cb08329b0809453722bc12aa912be34355bcb66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/acl.c
#	fs/fuse/cuse.c
#	fs/fuse/dev.c
#	fs/fuse/fuse_i.h
#	fs/fuse/inode.c
diff --cc fs/fuse/cuse.c
index b6c31303acfb,8f68181256c0..000000000000
--- a/fs/fuse/cuse.c
+++ b/fs/fuse/cuse.c
@@@ -48,6 -47,8 +48,11 @@@
  #include <linux/slab.h>
  #include <linux/stat.h>
  #include <linux/module.h>
++<<<<<<< HEAD
++=======
+ #include <linux/uio.h>
+ #include <linux/user_namespace.h>
++>>>>>>> 8cb08329b080 (fuse: Support fuse filesystems outside of init_user_ns)
  
  #include "fuse_i.h"
  
@@@ -502,8 -499,18 +507,12 @@@ static int cuse_channel_open(struct ino
  	if (!cc)
  		return -ENOMEM;
  
- 	fuse_conn_init(&cc->fc);
+ 	/*
+ 	 * Limit the cuse channel to requests that can
+ 	 * be represented in file->f_cred->user_ns.
+ 	 */
+ 	fuse_conn_init(&cc->fc, file->f_cred->user_ns);
  
 -	fud = fuse_dev_alloc(&cc->fc);
 -	if (!fud) {
 -		kfree(cc);
 -		return -ENOMEM;
 -	}
 -
  	INIT_LIST_HEAD(&cc->list);
  	cc->fc.release = cuse_fc_release;
  
diff --cc fs/fuse/dev.c
index 253369bc378a,686631f12001..000000000000
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@@ -169,9 -156,19 +169,25 @@@ static struct fuse_req *__fuse_get_req(
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	fuse_req_init_context(fc, req);
 +	req->waiting = 1;
 +	req->background = for_background;
++=======
+ 	req->in.h.uid = from_kuid(fc->user_ns, current_fsuid());
+ 	req->in.h.gid = from_kgid(fc->user_ns, current_fsgid());
+ 	req->in.h.pid = pid_nr_ns(task_pid(current), fc->pid_ns);
+ 
+ 	__set_bit(FR_WAITING, &req->flags);
+ 	if (for_background)
+ 		__set_bit(FR_BACKGROUND, &req->flags);
+ 
+ 	if (unlikely(req->in.h.uid == ((uid_t)-1) ||
+ 		     req->in.h.gid == ((gid_t)-1))) {
+ 		fuse_put_request(fc, req);
+ 		return ERR_PTR(-EOVERFLOW);
+ 	}
++>>>>>>> 8cb08329b080 (fuse: Support fuse filesystems outside of init_user_ns)
  	return req;
  
   out:
@@@ -258,9 -257,12 +274,18 @@@ struct fuse_req *fuse_get_req_nofail_no
  	if (!req)
  		req = get_reserved_req(fc, file);
  
++<<<<<<< HEAD
 +	fuse_req_init_context(fc, req);
 +	req->waiting = 1;
 +	req->background = 0;
++=======
+ 	req->in.h.uid = from_kuid_munged(fc->user_ns, current_fsuid());
+ 	req->in.h.gid = from_kgid_munged(fc->user_ns, current_fsgid());
+ 	req->in.h.pid = pid_nr_ns(task_pid(current), fc->pid_ns);
+ 
+ 	__set_bit(FR_WAITING, &req->flags);
+ 	__clear_bit(FR_BACKGROUND, &req->flags);
++>>>>>>> 8cb08329b080 (fuse: Support fuse filesystems outside of init_user_ns)
  	return req;
  }
  
diff --cc fs/fuse/fuse_i.h
index aee57e6d2d86,f630951df8dc..000000000000
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@@ -22,7 -22,11 +22,12 @@@
  #include <linux/rbtree.h>
  #include <linux/poll.h>
  #include <linux/workqueue.h>
 -#include <linux/kref.h>
 -#include <linux/xattr.h>
  #include <linux/pid_namespace.h>
++<<<<<<< HEAD
++=======
+ #include <linux/refcount.h>
+ #include <linux/user_namespace.h>
++>>>>>>> 8cb08329b080 (fuse: Support fuse filesystems outside of init_user_ns)
  
  /** Max number of pages that can be used in a single read request */
  #define FUSE_MAX_PAGES_PER_REQ 32
diff --cc fs/fuse/inode.c
index 110e3fd863fb,1643043d4fe5..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -480,7 -466,19 +480,23 @@@ static const match_table_t tokens = 
  	{OPT_ERR,			NULL}
  };
  
++<<<<<<< HEAD
 +static int parse_fuse_opt(char *opt, struct fuse_mount_data *d, int is_bdev)
++=======
+ static int fuse_match_uint(substring_t *s, unsigned int *res)
+ {
+ 	int err = -ENOMEM;
+ 	char *buf = match_strdup(s);
+ 	if (buf) {
+ 		err = kstrtouint(buf, 10, res);
+ 		kfree(buf);
+ 	}
+ 	return err;
+ }
+ 
+ static int parse_fuse_opt(char *opt, struct fuse_mount_data *d, int is_bdev,
+ 			  struct user_namespace *user_ns)
++>>>>>>> 8cb08329b080 (fuse: Support fuse filesystems outside of init_user_ns)
  {
  	char *p;
  	memset(d, 0, sizeof(struct fuse_mount_data));
@@@ -513,18 -512,18 +529,26 @@@
  			break;
  
  		case OPT_USER_ID:
 -			if (fuse_match_uint(&args[0], &uv))
 +			if (match_int(&args[0], &value))
  				return 0;
++<<<<<<< HEAD
 +			d->user_id = make_kuid(current_user_ns(), value);
++=======
+ 			d->user_id = make_kuid(user_ns, uv);
++>>>>>>> 8cb08329b080 (fuse: Support fuse filesystems outside of init_user_ns)
  			if (!uid_valid(d->user_id))
  				return 0;
  			d->user_id_present = 1;
  			break;
  
  		case OPT_GROUP_ID:
 -			if (fuse_match_uint(&args[0], &uv))
 +			if (match_int(&args[0], &value))
  				return 0;
++<<<<<<< HEAD
 +			d->group_id = make_kgid(current_user_ns(), value);
++=======
+ 			d->group_id = make_kgid(user_ns, uv);
++>>>>>>> 8cb08329b080 (fuse: Support fuse filesystems outside of init_user_ns)
  			if (!gid_valid(d->group_id))
  				return 0;
  			d->group_id_present = 1;
@@@ -567,11 -566,11 +591,17 @@@ static int fuse_show_options(struct seq
  	struct super_block *sb = root->d_sb;
  	struct fuse_conn *fc = get_fuse_conn_super(sb);
  
++<<<<<<< HEAD
 +	seq_printf(m, ",user_id=%u", from_kuid_munged(&init_user_ns, fc->user_id));
 +	seq_printf(m, ",group_id=%u", from_kgid_munged(&init_user_ns, fc->group_id));
 +	if (fc->flags & FUSE_DEFAULT_PERMISSIONS)
++=======
+ 	seq_printf(m, ",user_id=%u", from_kuid_munged(fc->user_ns, fc->user_id));
+ 	seq_printf(m, ",group_id=%u", from_kgid_munged(fc->user_ns, fc->group_id));
+ 	if (fc->default_permissions)
++>>>>>>> 8cb08329b080 (fuse: Support fuse filesystems outside of init_user_ns)
  		seq_puts(m, ",default_permissions");
 -	if (fc->allow_other)
 +	if (fc->flags & FUSE_ALLOW_OTHER)
  		seq_puts(m, ",allow_other");
  	if (fc->max_read != ~0)
  		seq_printf(m, ",max_read=%u", fc->max_read);
@@@ -580,7 -579,26 +610,30 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +void fuse_conn_init(struct fuse_conn *fc)
++=======
+ static void fuse_iqueue_init(struct fuse_iqueue *fiq)
+ {
+ 	memset(fiq, 0, sizeof(struct fuse_iqueue));
+ 	init_waitqueue_head(&fiq->waitq);
+ 	INIT_LIST_HEAD(&fiq->pending);
+ 	INIT_LIST_HEAD(&fiq->interrupts);
+ 	fiq->forget_list_tail = &fiq->forget_list_head;
+ 	fiq->connected = 1;
+ }
+ 
+ static void fuse_pqueue_init(struct fuse_pqueue *fpq)
+ {
+ 	memset(fpq, 0, sizeof(struct fuse_pqueue));
+ 	spin_lock_init(&fpq->lock);
+ 	INIT_LIST_HEAD(&fpq->processing);
+ 	INIT_LIST_HEAD(&fpq->io);
+ 	fpq->connected = 1;
+ }
+ 
+ void fuse_conn_init(struct fuse_conn *fc, struct user_namespace *user_ns)
++>>>>>>> 8cb08329b080 (fuse: Support fuse filesystems outside of init_user_ns)
  {
  	memset(fc, 0, sizeof(*fc));
  	spin_lock_init(&fc->lock);
@@@ -1002,12 -1062,12 +1057,16 @@@ static int fuse_fill_super(struct super
  	int is_bdev = sb->s_bdev != NULL;
  
  	err = -EINVAL;
 -	if (sb->s_flags & SB_MANDLOCK)
 +	if (sb->s_flags & MS_MANDLOCK)
  		goto err;
  
 -	sb->s_flags &= ~(SB_NOSEC | SB_I_VERSION);
 +	sb->s_flags &= ~(MS_NOSEC | MS_I_VERSION);
  
++<<<<<<< HEAD
 +	if (!parse_fuse_opt((char *) data, &d, is_bdev))
++=======
+ 	if (!parse_fuse_opt(data, &d, is_bdev, sb->s_user_ns))
++>>>>>>> 8cb08329b080 (fuse: Support fuse filesystems outside of init_user_ns)
  		goto err;
  
  	if (is_bdev) {
@@@ -1040,9 -1105,13 +1103,9 @@@
  	if (!fc)
  		goto err_fput;
  
- 	fuse_conn_init(fc);
+ 	fuse_conn_init(fc, sb->s_user_ns);
  	fc->release = fuse_free_conn;
  
 -	fud = fuse_dev_alloc(fc);
 -	if (!fud)
 -		goto err_put_conn;
 -
  	fc->dev = sb->s_dev;
  	fc->sb = sb;
  	err = fuse_bdi_init(fc, sb);
* Unmerged path fs/fuse/acl.c
* Unmerged path fs/fuse/acl.c
* Unmerged path fs/fuse/cuse.c
* Unmerged path fs/fuse/dev.c
diff --git a/fs/fuse/dir.c b/fs/fuse/dir.c
index b8baa693ed17..f71a38a48d4e 100644
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@ -909,8 +909,8 @@ static void fuse_fillattr(struct inode *inode, struct fuse_attr *attr,
 	stat->ino = attr->ino;
 	stat->mode = (inode->i_mode & S_IFMT) | (attr->mode & 07777);
 	stat->nlink = attr->nlink;
-	stat->uid = make_kuid(&init_user_ns, attr->uid);
-	stat->gid = make_kgid(&init_user_ns, attr->gid);
+	stat->uid = make_kuid(fc->user_ns, attr->uid);
+	stat->gid = make_kgid(fc->user_ns, attr->gid);
 	stat->rdev = inode->i_rdev;
 	stat->atime.tv_sec = attr->atime;
 	stat->atime.tv_nsec = attr->atimensec;
@@ -1565,17 +1565,17 @@ static bool update_mtime(unsigned ivalid, bool trust_local_mtime)
 	return true;
 }
 
-static void iattr_to_fattr(struct iattr *iattr, struct fuse_setattr_in *arg,
-			   bool trust_local_cmtime)
+static void iattr_to_fattr(struct fuse_conn *fc, struct iattr *iattr,
+			   struct fuse_setattr_in *arg, bool trust_local_cmtime)
 {
 	unsigned ivalid = iattr->ia_valid;
 
 	if (ivalid & ATTR_MODE)
 		arg->valid |= FATTR_MODE,   arg->mode = iattr->ia_mode;
 	if (ivalid & ATTR_UID)
-		arg->valid |= FATTR_UID,    arg->uid = from_kuid(&init_user_ns, iattr->ia_uid);
+		arg->valid |= FATTR_UID,    arg->uid = from_kuid(fc->user_ns, iattr->ia_uid);
 	if (ivalid & ATTR_GID)
-		arg->valid |= FATTR_GID,    arg->gid = from_kgid(&init_user_ns, iattr->ia_gid);
+		arg->valid |= FATTR_GID,    arg->gid = from_kgid(fc->user_ns, iattr->ia_gid);
 	if (ivalid & ATTR_SIZE)
 		arg->valid |= FATTR_SIZE,   arg->size = iattr->ia_size;
 	if (ivalid & ATTR_ATIME) {
@@ -1761,7 +1761,7 @@ int fuse_do_setattr(struct inode *inode, struct iattr *attr,
 
 	memset(&inarg, 0, sizeof(inarg));
 	memset(&outarg, 0, sizeof(outarg));
-	iattr_to_fattr(attr, &inarg, trust_local_cmtime);
+	iattr_to_fattr(fc, attr, &inarg, trust_local_cmtime);
 	if (file) {
 		struct fuse_file *ff = file->private_data;
 		inarg.valid |= FATTR_FH;
* Unmerged path fs/fuse/fuse_i.h
* Unmerged path fs/fuse/inode.c
