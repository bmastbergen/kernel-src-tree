tracing: Pass export pointer as argument to ->write()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Felipe Balbi <felipe.balbi@linux.intel.com>
commit a773d419275bf54854ca6cfda8f2594ed2790faa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/a773d419.failed

By passing an export descriptor to the write function, users don't need to
keep a global static pointer and can rely on container_of() to fetch their
own structure.

Link: http://lkml.kernel.org/r/20170602102025.5140-1-felipe.balbi@linux.intel.com

	Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
	Reviewed-by: Chunyan Zhang <zhang.chunyan@linaro.org>
	Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit a773d419275bf54854ca6cfda8f2594ed2790faa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hwtracing/stm/ftrace.c
#	include/linux/trace.h
#	kernel/trace/trace.c
diff --cc kernel/trace/trace.c
index 1f2fe17a9d70,59518b8126d0..000000000000
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@@ -1644,17 -2382,152 +1644,143 @@@ void trace_buffer_unlock_commit_regs(st
  {
  	__buffer_unlock_commit(buffer, event);
  
 -	/*
 -	 * If regs is not set, then skip the following callers:
 -	 *   trace_buffer_unlock_commit_regs
 -	 *   event_trigger_unlock_commit
 -	 *   trace_event_buffer_commit
 -	 *   trace_event_raw_event_sched_switch
 -	 * Note, we can still get here via blktrace, wakeup tracer
 -	 * and mmiotrace, but that's ok if they lose a function or
 -	 * two. They are that meaningful.
 -	 */
 -	ftrace_trace_stack(tr, buffer, flags, regs ? 0 : 4, pc, regs);
 +	ftrace_trace_stack_regs(buffer, flags, 0, pc, regs);
  	ftrace_trace_userstack(buffer, flags, pc);
  }
 +EXPORT_SYMBOL_GPL(trace_buffer_unlock_commit_regs);
  
 -/*
 - * Similar to trace_buffer_unlock_commit_regs() but do not dump stack.
 - */
 -void
 -trace_buffer_unlock_commit_nostack(struct ring_buffer *buffer,
 -				   struct ring_buffer_event *event)
 +void trace_current_buffer_discard_commit(struct ring_buffer *buffer,
 +					 struct ring_buffer_event *event)
  {
 -	__buffer_unlock_commit(buffer, event);
 +	ring_buffer_discard_commit(buffer, event);
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(trace_current_buffer_discard_commit);
++=======
+ 
+ static void
+ trace_process_export(struct trace_export *export,
+ 	       struct ring_buffer_event *event)
+ {
+ 	struct trace_entry *entry;
+ 	unsigned int size = 0;
+ 
+ 	entry = ring_buffer_event_data(event);
+ 	size = ring_buffer_event_length(event);
+ 	export->write(export, entry, size);
+ }
+ 
+ static DEFINE_MUTEX(ftrace_export_lock);
+ 
+ static struct trace_export __rcu *ftrace_exports_list __read_mostly;
+ 
+ static DEFINE_STATIC_KEY_FALSE(ftrace_exports_enabled);
+ 
+ static inline void ftrace_exports_enable(void)
+ {
+ 	static_branch_enable(&ftrace_exports_enabled);
+ }
+ 
+ static inline void ftrace_exports_disable(void)
+ {
+ 	static_branch_disable(&ftrace_exports_enabled);
+ }
+ 
+ void ftrace_exports(struct ring_buffer_event *event)
+ {
+ 	struct trace_export *export;
+ 
+ 	preempt_disable_notrace();
+ 
+ 	export = rcu_dereference_raw_notrace(ftrace_exports_list);
+ 	while (export) {
+ 		trace_process_export(export, event);
+ 		export = rcu_dereference_raw_notrace(export->next);
+ 	}
+ 
+ 	preempt_enable_notrace();
+ }
+ 
+ static inline void
+ add_trace_export(struct trace_export **list, struct trace_export *export)
+ {
+ 	rcu_assign_pointer(export->next, *list);
+ 	/*
+ 	 * We are entering export into the list but another
+ 	 * CPU might be walking that list. We need to make sure
+ 	 * the export->next pointer is valid before another CPU sees
+ 	 * the export pointer included into the list.
+ 	 */
+ 	rcu_assign_pointer(*list, export);
+ }
+ 
+ static inline int
+ rm_trace_export(struct trace_export **list, struct trace_export *export)
+ {
+ 	struct trace_export **p;
+ 
+ 	for (p = list; *p != NULL; p = &(*p)->next)
+ 		if (*p == export)
+ 			break;
+ 
+ 	if (*p != export)
+ 		return -1;
+ 
+ 	rcu_assign_pointer(*p, (*p)->next);
+ 
+ 	return 0;
+ }
+ 
+ static inline void
+ add_ftrace_export(struct trace_export **list, struct trace_export *export)
+ {
+ 	if (*list == NULL)
+ 		ftrace_exports_enable();
+ 
+ 	add_trace_export(list, export);
+ }
+ 
+ static inline int
+ rm_ftrace_export(struct trace_export **list, struct trace_export *export)
+ {
+ 	int ret;
+ 
+ 	ret = rm_trace_export(list, export);
+ 	if (*list == NULL)
+ 		ftrace_exports_disable();
+ 
+ 	return ret;
+ }
+ 
+ int register_ftrace_export(struct trace_export *export)
+ {
+ 	if (WARN_ON_ONCE(!export->write))
+ 		return -1;
+ 
+ 	mutex_lock(&ftrace_export_lock);
+ 
+ 	add_ftrace_export(&ftrace_exports_list, export);
+ 
+ 	mutex_unlock(&ftrace_export_lock);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(register_ftrace_export);
+ 
+ int unregister_ftrace_export(struct trace_export *export)
+ {
+ 	int ret;
+ 
+ 	mutex_lock(&ftrace_export_lock);
+ 
+ 	ret = rm_ftrace_export(&ftrace_exports_list, export);
+ 
+ 	mutex_unlock(&ftrace_export_lock);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(unregister_ftrace_export);
++>>>>>>> a773d419275b (tracing: Pass export pointer as argument to ->write())
  
  void
  trace_function(struct trace_array *tr,
* Unmerged path drivers/hwtracing/stm/ftrace.c
* Unmerged path include/linux/trace.h
* Unmerged path drivers/hwtracing/stm/ftrace.c
* Unmerged path include/linux/trace.h
* Unmerged path kernel/trace/trace.c
