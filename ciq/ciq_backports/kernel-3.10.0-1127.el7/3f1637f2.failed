dm snapshot: Use fine-grained locking scheme

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Nikos Tsironis <ntsironis@arrikto.com>
commit 3f1637f2103822f9cab4c927d929db57ac4fd933
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/3f1637f2.failed

Substitute the global locking scheme with a fine grained one, employing
the read-write semaphore and the scalable exception tables with
per-bucket locks introduced by the previous two commits.

Summarizing, we now use a read-write semaphore to protect the mostly
read fields of the snapshot structure, e.g., valid, active, etc., and
per-bucket bit spinlocks to protect accesses to the complete and pending
exception tables.

Finally, we use an extra spinlock (pe_allocation_lock) to serialize the
allocation of new exceptions by the exception store. This allocation is
really fast, so the extra spinlock doesn't hurt the performance.

This scheme allows dm-snapshot to scale better, resulting in increased
IOPS and reduced latency.

Following are some benchmark results using the null_blk device:

  modprobe null_blk gb=1024 bs=512 submit_queues=8 hw_queue_depth=4096 \
   queue_mode=2 irqmode=1 completion_nsec=1 nr_devices=1

* Benchmark fio_origin_randwrite_throughput_N, from the device mapper
  test suite [1] (direct IO, random 4K writes to origin device, IO
  engine libaio):

  +--------------+-------------+------------+
  | # of workers | IOPS Before | IOPS After |
  +--------------+-------------+------------+
  |      1       |    57708    |   66421    |
  |      2       |    63415    |   77589    |
  |      4       |    67276    |   98839    |
  |      8       |    60564    |   109258   |
  +--------------+-------------+------------+

* Benchmark fio_origin_randwrite_latency_N, from the device mapper test
  suite [1] (direct IO, random 4K writes to origin device, IO engine
  psync):

  +--------------+-----------------------+----------------------+
  | # of workers | Latency (usec) Before | Latency (usec) After |
  +--------------+-----------------------+----------------------+
  |      1       |         16.25         |        13.27         |
  |      2       |         31.65         |        25.08         |
  |      4       |         55.28         |        41.08         |
  |      8       |         121.47        |        74.44         |
  +--------------+-----------------------+----------------------+

* Benchmark fio_snapshot_randwrite_throughput_N, from the device mapper
  test suite [1] (direct IO, random 4K writes to snapshot device, IO
  engine libaio):

  +--------------+-------------+------------+
  | # of workers | IOPS Before | IOPS After |
  +--------------+-------------+------------+
  |      1       |    72593    |   84938    |
  |      2       |    97379    |   134973   |
  |      4       |    90610    |   143077   |
  |      8       |    90537    |   180085   |
  +--------------+-------------+------------+

* Benchmark fio_snapshot_randwrite_latency_N, from the device mapper
  test suite [1] (direct IO, random 4K writes to snapshot device, IO
  engine psync):

  +--------------+-----------------------+----------------------+
  | # of workers | Latency (usec) Before | Latency (usec) After |
  +--------------+-----------------------+----------------------+
  |      1       |         12.53         |         10.6         |
  |      2       |         19.78         |        14.89         |
  |      4       |         40.37         |        23.47         |
  |      8       |         89.32         |        48.48         |
  +--------------+-----------------------+----------------------+

[1] https://github.com/jthornber/device-mapper-test-suite

Co-developed-by: Ilias Tsitsimpis <iliastsi@arrikto.com>
	Signed-off-by: Nikos Tsironis <ntsironis@arrikto.com>
	Acked-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 3f1637f2103822f9cab4c927d929db57ac4fd933)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-snap.c
diff --cc drivers/md/dm-snap.c
index 4f3251269638,3107f2b1988b..000000000000
--- a/drivers/md/dm-snap.c
+++ b/drivers/md/dm-snap.c
@@@ -1474,29 -1540,37 +1484,44 @@@ static void pending_complete(void *cont
  	struct bio *origin_bios = NULL;
  	struct bio *snapshot_bios = NULL;
  	struct bio *full_bio = NULL;
 -	struct dm_exception_table_lock lock;
  	int error = 0;
  
 -	dm_exception_table_lock_init(s, pe->e.old_chunk, &lock);
 -
  	if (!success) {
  		/* Read/write error - snapshot is unusable */
++<<<<<<< HEAD
 +		mutex_lock(&s->lock);
 +		__invalidate_snapshot(s, -EIO);
++=======
+ 		invalidate_snapshot(s, -EIO);
++>>>>>>> 3f1637f21038 (dm snapshot: Use fine-grained locking scheme)
  		error = 1;
 -
 -		dm_exception_table_lock(&lock);
  		goto out;
  	}
  
  	e = alloc_completed_exception(GFP_NOIO);
  	if (!e) {
++<<<<<<< HEAD
 +		mutex_lock(&s->lock);
 +		__invalidate_snapshot(s, -ENOMEM);
++=======
+ 		invalidate_snapshot(s, -ENOMEM);
++>>>>>>> 3f1637f21038 (dm snapshot: Use fine-grained locking scheme)
  		error = 1;
 -
 -		dm_exception_table_lock(&lock);
  		goto out;
  	}
  	*e = pe->e;
  
++<<<<<<< HEAD
 +	mutex_lock(&s->lock);
++=======
+ 	down_read(&s->lock);
+ 	dm_exception_table_lock(&lock);
++>>>>>>> 3f1637f21038 (dm snapshot: Use fine-grained locking scheme)
  	if (!s->valid) {
+ 		up_read(&s->lock);
  		free_completed_exception(e);
  		error = 1;
+ 
  		goto out;
  	}
  
@@@ -1511,9 -1586,9 +1537,15 @@@
  
  	/* Wait for conflicting reads to drain */
  	if (__chunk_is_tracked(s, pe->e.old_chunk)) {
++<<<<<<< HEAD
 +		mutex_unlock(&s->lock);
 +		__check_for_conflicting_io(s, pe->e.old_chunk);
 +		mutex_lock(&s->lock);
++=======
+ 		dm_exception_table_unlock(&lock);
+ 		__check_for_conflicting_io(s, pe->e.old_chunk);
+ 		dm_exception_table_lock(&lock);
++>>>>>>> 3f1637f21038 (dm snapshot: Use fine-grained locking scheme)
  	}
  
  out:
@@@ -1526,8 -1604,6 +1558,11 @@@
  		full_bio->bi_end_io = pe->full_bio_end_io;
  	increment_pending_exceptions_done_count();
  
++<<<<<<< HEAD
 +	mutex_unlock(&s->lock);
 +
++=======
++>>>>>>> 3f1637f21038 (dm snapshot: Use fine-grained locking scheme)
  	/* Submit any pending write bios */
  	if (error) {
  		if (full_bio)
@@@ -1748,12 -1828,14 +1786,17 @@@ static int snapshot_map(struct dm_targe
  	/* Full snapshots are not usable */
  	/* To get here the table must be live so s->active is always set. */
  	if (!s->valid)
 -		return DM_MAPIO_KILL;
 +		return -EIO;
  
++<<<<<<< HEAD
 +	mutex_lock(&s->lock);
++=======
+ 	down_read(&s->lock);
+ 	dm_exception_table_lock(&lock);
++>>>>>>> 3f1637f21038 (dm snapshot: Use fine-grained locking scheme)
  
 -	if (!s->valid || (unlikely(s->snapshot_overflowed) &&
 -	    bio_data_dir(bio) == WRITE)) {
 -		r = DM_MAPIO_KILL;
 +	if (!s->valid || (unlikely(s->snapshot_overflowed) && bio_rw(bio) == WRITE)) {
 +		r = -EIO;
  		goto out_unlock;
  	}
  
@@@ -1769,19 -1851,13 +1812,26 @@@
  	 * flags so we should only get this if we are
  	 * writeable.
  	 */
 -	if (bio_data_dir(bio) == WRITE) {
 +	if (bio_rw(bio) == WRITE) {
  		pe = __lookup_pending_exception(s, chunk);
  		if (!pe) {
++<<<<<<< HEAD
 +			mutex_unlock(&s->lock);
 +			pe = alloc_pending_exception(s);
 +			mutex_lock(&s->lock);
 +
 +			if (!s->valid || s->snapshot_overflowed) {
 +				free_pending_exception(pe);
 +				r = -EIO;
 +				goto out_unlock;
 +			}
 +
++=======
+ 			dm_exception_table_unlock(&lock);
+ 			pe = alloc_pending_exception(s);
+ 			dm_exception_table_lock(&lock);
+ 
++>>>>>>> 3f1637f21038 (dm snapshot: Use fine-grained locking scheme)
  			e = dm_lookup_exception(&s->complete, chunk);
  			if (e) {
  				free_pending_exception(pe);
@@@ -1791,13 -1867,22 +1841,23 @@@
  
  			pe = __find_pending_exception(s, pe, chunk);
  			if (!pe) {
++<<<<<<< HEAD
++=======
+ 				dm_exception_table_unlock(&lock);
+ 				up_read(&s->lock);
+ 
+ 				down_write(&s->lock);
+ 
++>>>>>>> 3f1637f21038 (dm snapshot: Use fine-grained locking scheme)
  				if (s->store->userspace_supports_overflow) {
- 					s->snapshot_overflowed = 1;
- 					DMERR("Snapshot overflowed: Unable to allocate exception.");
+ 					if (s->valid && !s->snapshot_overflowed) {
+ 						s->snapshot_overflowed = 1;
+ 						DMERR("Snapshot overflowed: Unable to allocate exception.");
+ 					}
  				} else
  					__invalidate_snapshot(s, -ENOMEM);
 -				up_write(&s->lock);
 -
 -				r = DM_MAPIO_KILL;
 -				goto out;
 +				r = -EIO;
 +				goto out_unlock;
  			}
  		}
  
@@@ -1806,9 -1891,13 +1866,16 @@@
  		r = DM_MAPIO_SUBMITTED;
  
  		if (!pe->started &&
 -		    bio->bi_iter.bi_size ==
 -		    (s->store->chunk_size << SECTOR_SHIFT)) {
 +		    bio->bi_size == (s->store->chunk_size << SECTOR_SHIFT)) {
  			pe->started = 1;
++<<<<<<< HEAD
 +			mutex_unlock(&s->lock);
++=======
+ 
+ 			dm_exception_table_unlock(&lock);
+ 			up_read(&s->lock);
+ 
++>>>>>>> 3f1637f21038 (dm snapshot: Use fine-grained locking scheme)
  			start_full_bio(pe, bio);
  			goto out;
  		}
@@@ -1816,9 -1905,12 +1883,16 @@@
  		bio_list_add(&pe->snapshot_bios, bio);
  
  		if (!pe->started) {
- 			/* this is protected by snap->lock */
+ 			/* this is protected by the exception table lock */
  			pe->started = 1;
++<<<<<<< HEAD
 +			mutex_unlock(&s->lock);
++=======
+ 
+ 			dm_exception_table_unlock(&lock);
+ 			up_read(&s->lock);
+ 
++>>>>>>> 3f1637f21038 (dm snapshot: Use fine-grained locking scheme)
  			start_copy(pe);
  			goto out;
  		}
@@@ -1828,7 -1920,8 +1902,12 @@@
  	}
  
  out_unlock:
++<<<<<<< HEAD
 +	mutex_unlock(&s->lock);
++=======
+ 	dm_exception_table_unlock(&lock);
+ 	up_read(&s->lock);
++>>>>>>> 3f1637f21038 (dm snapshot: Use fine-grained locking scheme)
  out:
  	return r;
  }
@@@ -2154,6 -2243,14 +2233,17 @@@ static int __origin_write(struct list_h
  		 * different chunk sizes.
  		 */
  		chunk = sector_to_chunk(snap->store, sector);
++<<<<<<< HEAD
++=======
+ 		dm_exception_table_lock_init(snap, chunk, &lock);
+ 
+ 		down_read(&snap->lock);
+ 		dm_exception_table_lock(&lock);
+ 
+ 		/* Only deal with valid and active snapshots */
+ 		if (!snap->valid || !snap->active)
+ 			goto next_snapshot;
++>>>>>>> 3f1637f21038 (dm snapshot: Use fine-grained locking scheme)
  
  		pe = __lookup_pending_exception(snap, chunk);
  		if (!pe) {
@@@ -2166,14 -2263,9 +2256,15 @@@
  			if (e)
  				goto next_snapshot;
  
++<<<<<<< HEAD
 +			mutex_unlock(&snap->lock);
 +			pe = alloc_pending_exception(snap);
 +			mutex_lock(&snap->lock);
- 
- 			if (!snap->valid) {
- 				free_pending_exception(pe);
- 				goto next_snapshot;
- 			}
++=======
+ 			dm_exception_table_unlock(&lock);
+ 			pe = alloc_pending_exception(snap);
+ 			dm_exception_table_lock(&lock);
++>>>>>>> 3f1637f21038 (dm snapshot: Use fine-grained locking scheme)
  
  			pe2 = __lookup_pending_exception(snap, chunk);
  
@@@ -2186,8 -2278,11 +2277,16 @@@
  
  				pe = __insert_pending_exception(snap, pe, chunk);
  				if (!pe) {
++<<<<<<< HEAD
 +					__invalidate_snapshot(snap, -ENOMEM);
 +					goto next_snapshot;
++=======
+ 					dm_exception_table_unlock(&lock);
+ 					up_read(&snap->lock);
+ 
+ 					invalidate_snapshot(snap, -ENOMEM);
+ 					continue;
++>>>>>>> 3f1637f21038 (dm snapshot: Use fine-grained locking scheme)
  				}
  			} else {
  				free_pending_exception(pe);
@@@ -2218,7 -2313,8 +2317,12 @@@
  		}
  
  next_snapshot:
++<<<<<<< HEAD
 +		mutex_unlock(&snap->lock);
++=======
+ 		dm_exception_table_unlock(&lock);
+ 		up_read(&snap->lock);
++>>>>>>> 3f1637f21038 (dm snapshot: Use fine-grained locking scheme)
  
  		if (pe_to_start_now) {
  			start_copy(pe_to_start_now);
* Unmerged path drivers/md/dm-snap.c
