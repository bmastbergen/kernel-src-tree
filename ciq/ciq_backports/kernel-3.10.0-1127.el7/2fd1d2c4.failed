proc: Fix proc_sys_prune_dcache to hold a sb reference

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 2fd1d2c4ceb2248a727696962cf3370dc9f5a0a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/2fd1d2c4.failed

Andrei Vagin writes:
FYI: This bug has been reproduced on 4.11.7
> BUG: Dentry ffff895a3dd01240{i=4e7c09a,n=lo}  still in use (1) [unmount of proc proc]
> ------------[ cut here ]------------
> WARNING: CPU: 1 PID: 13588 at fs/dcache.c:1445 umount_check+0x6e/0x80
> CPU: 1 PID: 13588 Comm: kworker/1:1 Not tainted 4.11.7-200.fc25.x86_64 #1
> Hardware name: CompuLab sbc-flt1/fitlet, BIOS SBCFLT_0.08.04 06/27/2015
> Workqueue: events proc_cleanup_work
> Call Trace:
>  dump_stack+0x63/0x86
>  __warn+0xcb/0xf0
>  warn_slowpath_null+0x1d/0x20
>  umount_check+0x6e/0x80
>  d_walk+0xc6/0x270
>  ? dentry_free+0x80/0x80
>  do_one_tree+0x26/0x40
>  shrink_dcache_for_umount+0x2d/0x90
>  generic_shutdown_super+0x1f/0xf0
>  kill_anon_super+0x12/0x20
>  proc_kill_sb+0x40/0x50
>  deactivate_locked_super+0x43/0x70
>  deactivate_super+0x5a/0x60
>  cleanup_mnt+0x3f/0x90
>  mntput_no_expire+0x13b/0x190
>  kern_unmount+0x3e/0x50
>  pid_ns_release_proc+0x15/0x20
>  proc_cleanup_work+0x15/0x20
>  process_one_work+0x197/0x450
>  worker_thread+0x4e/0x4a0
>  kthread+0x109/0x140
>  ? process_one_work+0x450/0x450
>  ? kthread_park+0x90/0x90
>  ret_from_fork+0x2c/0x40
> ---[ end trace e1c109611e5d0b41 ]---
> VFS: Busy inodes after unmount of proc. Self-destruct in 5 seconds.  Have a nice day...
> BUG: unable to handle kernel NULL pointer dereference at           (null)
> IP: _raw_spin_lock+0xc/0x30
> PGD 0

Fix this by taking a reference to the super block in proc_sys_prune_dcache.

The superblock reference is the core of the fix however the sysctl_inodes
list is converted to a hlist so that hlist_del_init_rcu may be used.  This
allows proc_sys_prune_dache to remove inodes the sysctl_inodes list, while
not causing problems for proc_sys_evict_inode when if it later choses to
remove the inode from the sysctl_inodes list.  Removing inodes from the
sysctl_inodes list allows proc_sys_prune_dcache to have a progress
guarantee, while still being able to drop all locks.  The fact that
head->unregistering is set in start_unregistering ensures that no more
inodes will be added to the the sysctl_inodes list.

Previously the code did a dance where it delayed calling iput until the
next entry in the list was being considered to ensure the inode remained on
the sysctl_inodes list until the next entry was walked to.  The structure
of the loop in this patch does not need that so is much easier to
understand and maintain.

	Cc: stable@vger.kernel.org
	Reported-by: Andrei Vagin <avagin@gmail.com>
	Tested-by: Andrei Vagin <avagin@openvz.org>
Fixes: ace0c791e6c3 ("proc/sysctl: Don't grab i_lock under sysctl_lock.")
Fixes: d6cffbbe9a7e ("proc/sysctl: prune stale dentries during unregistering")
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit 2fd1d2c4ceb2248a727696962cf3370dc9f5a0a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/internal.h
#	fs/proc/proc_sysctl.c
#	include/linux/sysctl.h
diff --cc fs/proc/internal.h
index 2e3c29a0f0b8,18694598bebf..000000000000
--- a/fs/proc/internal.h
+++ b/fs/proc/internal.h
@@@ -77,7 -67,8 +77,12 @@@ struct proc_inode 
  	struct proc_dir_entry *pde;
  	struct ctl_table_header *sysctl;
  	struct ctl_table *sysctl_entry;
++<<<<<<< HEAD
 +	struct proc_ns ns;
++=======
+ 	struct hlist_node sysctl_inodes;
+ 	const struct proc_ns_operations *ns_ops;
++>>>>>>> 2fd1d2c4ceb2 (proc: Fix proc_sys_prune_dcache to hold a sb reference)
  	struct inode vfs_inode;
  };
  
diff --cc fs/proc/proc_sysctl.c
index df9e927d244d,9bf06e2b1284..000000000000
--- a/fs/proc/proc_sysctl.c
+++ b/fs/proc/proc_sysctl.c
@@@ -190,6 -191,7 +190,10 @@@ static void init_header(struct ctl_tabl
  	head->set = set;
  	head->parent = NULL;
  	head->node = node;
++<<<<<<< HEAD
++=======
+ 	INIT_HLIST_HEAD(&head->inodes);
++>>>>>>> 2fd1d2c4ceb2 (proc: Fix proc_sys_prune_dcache to hold a sb reference)
  	if (node) {
  		struct ctl_table *entry;
  		for (entry = table; entry->procname; entry++, node++)
@@@ -259,6 -261,44 +263,47 @@@ static void unuse_table(struct ctl_tabl
  			complete(p->unregistering);
  }
  
++<<<<<<< HEAD
++=======
+ static void proc_sys_prune_dcache(struct ctl_table_header *head)
+ {
+ 	struct inode *inode;
+ 	struct proc_inode *ei;
+ 	struct hlist_node *node;
+ 	struct super_block *sb;
+ 
+ 	rcu_read_lock();
+ 	for (;;) {
+ 		node = hlist_first_rcu(&head->inodes);
+ 		if (!node)
+ 			break;
+ 		ei = hlist_entry(node, struct proc_inode, sysctl_inodes);
+ 		spin_lock(&sysctl_lock);
+ 		hlist_del_init_rcu(&ei->sysctl_inodes);
+ 		spin_unlock(&sysctl_lock);
+ 
+ 		inode = &ei->vfs_inode;
+ 		sb = inode->i_sb;
+ 		if (!atomic_inc_not_zero(&sb->s_active))
+ 			continue;
+ 		inode = igrab(inode);
+ 		rcu_read_unlock();
+ 		if (unlikely(!inode)) {
+ 			deactivate_super(sb);
+ 			rcu_read_lock();
+ 			continue;
+ 		}
+ 
+ 		d_prune_aliases(inode);
+ 		iput(inode);
+ 		deactivate_super(sb);
+ 
+ 		rcu_read_lock();
+ 	}
+ 	rcu_read_unlock();
+ }
+ 
++>>>>>>> 2fd1d2c4ceb2 (proc: Fix proc_sys_prune_dcache to hold a sb reference)
  /* called under sysctl_lock, will reacquire if has to wait */
  static void start_unregistering(struct ctl_table_header *p)
  {
@@@ -439,12 -467,22 +484,18 @@@ static struct inode *proc_sys_make_inod
  
  	inode->i_ino = get_next_ino();
  
 +	sysctl_head_get(head);
  	ei = PROC_I(inode);
 -
 -	spin_lock(&sysctl_lock);
 -	if (unlikely(head->unregistering)) {
 -		spin_unlock(&sysctl_lock);
 -		iput(inode);
 -		inode = NULL;
 -		goto out;
 -	}
  	ei->sysctl = head;
  	ei->sysctl_entry = table;
++<<<<<<< HEAD
++=======
+ 	hlist_add_head_rcu(&ei->sysctl_inodes, &head->inodes);
+ 	head->count++;
+ 	spin_unlock(&sysctl_lock);
++>>>>>>> 2fd1d2c4ceb2 (proc: Fix proc_sys_prune_dcache to hold a sb reference)
  
 -	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
 +	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
  	inode->i_mode = table->mode;
  	if (!S_ISDIR(table->mode)) {
  		inode->i_mode |= S_IFREG;
@@@ -461,6 -503,15 +512,18 @@@ out
  	return inode;
  }
  
++<<<<<<< HEAD
++=======
+ void proc_sys_evict_inode(struct inode *inode, struct ctl_table_header *head)
+ {
+ 	spin_lock(&sysctl_lock);
+ 	hlist_del_init_rcu(&PROC_I(inode)->sysctl_inodes);
+ 	if (!--head->count)
+ 		kfree_rcu(head, rcu);
+ 	spin_unlock(&sysctl_lock);
+ }
+ 
++>>>>>>> 2fd1d2c4ceb2 (proc: Fix proc_sys_prune_dcache to hold a sb reference)
  static struct ctl_table_header *grab_header(struct inode *inode)
  {
  	struct ctl_table_header *head = PROC_I(inode)->sysctl;
diff --cc include/linux/sysctl.h
index 5bc418a12633,1c04a26bfd2f..000000000000
--- a/include/linux/sysctl.h
+++ b/include/linux/sysctl.h
@@@ -149,6 -143,7 +149,10 @@@ struct ctl_table_heade
  	struct ctl_table_set *set;
  	struct ctl_dir *parent;
  	struct ctl_node *node;
++<<<<<<< HEAD
++=======
+ 	struct hlist_head inodes; /* head for proc_inode->sysctl_inodes */
++>>>>>>> 2fd1d2c4ceb2 (proc: Fix proc_sys_prune_dcache to hold a sb reference)
  };
  
  struct ctl_dir {
* Unmerged path fs/proc/internal.h
* Unmerged path fs/proc/proc_sysctl.c
* Unmerged path include/linux/sysctl.h
