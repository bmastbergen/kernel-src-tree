cifs: add spinlock for the openFileList to cifsInodeInfo

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [fs] revert "[fs] cifs: add spinlock for the openFileList to cifsInodeInfo (Dave Wysochanski) [1757872]
Rebuild_FUZZ: 93.33%
commit-author Ronnie Sahlberg <lsahlber@redhat.com>
commit 487317c99477d00f22370625d53be3239febabbe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/487317c9.failed

We can not depend on the tcon->open_file_lock here since in multiuser mode
we may have the same file/inode open via multiple different tcons.

The current code is race prone and will crash if one user deletes a file
at the same time a different user opens/create the file.

To avoid this we need to have a spinlock attached to the inode and not the tcon.

RHBZ:  1580165

CC: Stable <stable@vger.kernel.org>
	Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
	Reviewed-by: Pavel Shilovsky <pshilov@microsoft.com>
(cherry picked from commit 487317c99477d00f22370625d53be3239febabbe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/file.c
diff --cc fs/cifs/file.c
index 2bf5f443b3da,97090693d182..000000000000
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@@ -334,17 -334,16 +334,25 @@@ cifs_new_fileinfo(struct cifs_fid *fid
  	fid->purge_cache = false;
  	server->ops->set_fid(cfile, fid, oplock);
  
 +	spin_lock(&cifs_list_lock);
  	list_add(&cfile->tlist, &tcon->openFileList);
 -	atomic_inc(&tcon->num_local_opens);
 +	spin_unlock(&cifs_list_lock);
  
  	/* if readable file instance put first in list*/
++<<<<<<< HEAD
 +	spin_lock(&cifs_list_lock);
++=======
+ 	spin_lock(&cinode->open_file_lock);
++>>>>>>> 487317c99477 (cifs: add spinlock for the openFileList to cifsInodeInfo)
  	if (file->f_mode & FMODE_READ)
  		list_add(&cfile->flist, &cinode->openFileList);
  	else
  		list_add_tail(&cfile->flist, &cinode->openFileList);
++<<<<<<< HEAD
 +	spin_unlock(&cifs_list_lock);
++=======
+ 	spin_unlock(&cinode->open_file_lock);
++>>>>>>> 487317c99477 (cifs: add spinlock for the openFileList to cifsInodeInfo)
  	spin_unlock(&tcon->open_file_lock);
  
  	if (fid->purge_cache)
@@@ -398,10 -415,11 +406,15 @@@ void cifsFileInfo_put(struct cifsFileIn
  	cifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);
  
  	/* remove it from the lists */
++<<<<<<< HEAD
 +	spin_lock(&cifs_list_lock);
++=======
+ 	spin_lock(&cifsi->open_file_lock);
++>>>>>>> 487317c99477 (cifs: add spinlock for the openFileList to cifsInodeInfo)
  	list_del(&cifs_file->flist);
+ 	spin_unlock(&cifsi->open_file_lock);
  	list_del(&cifs_file->tlist);
 -	atomic_dec(&tcon->num_local_opens);
 +	spin_unlock(&cifs_list_lock);
  
  	if (list_empty(&cifsi->openFileList)) {
  		cifs_dbg(FYI, "closing last open instance for inode %p\n",
@@@ -1901,24 -1949,35 +1914,36 @@@ refind_writable
  
  	if (inv_file) {
  		rc = cifs_reopen_file(inv_file, false);
 -		if (!rc) {
 -			*ret_file = inv_file;
 -			return 0;
 +		if (!rc)
 +			return inv_file;
 +		else {
 +			spin_lock(&tcon->open_file_lock);
 +			spin_lock(&cifs_list_lock);
 +			list_move_tail(&inv_file->flist,
 +					&cifs_inode->openFileList);
 +			spin_unlock(&cifs_list_lock);
 +			spin_unlock(&tcon->open_file_lock);
 +			cifsFileInfo_put(inv_file);
 +			++refind;
 +			inv_file = NULL;
 +			spin_lock(&tcon->open_file_lock);
 +			goto refind_writable;
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		spin_lock(&cifs_inode->open_file_lock);
+ 		list_move_tail(&inv_file->flist, &cifs_inode->openFileList);
+ 		spin_unlock(&cifs_inode->open_file_lock);
+ 		cifsFileInfo_put(inv_file);
+ 		++refind;
+ 		inv_file = NULL;
+ 		spin_lock(&tcon->open_file_lock);
+ 		goto refind_writable;
++>>>>>>> 487317c99477 (cifs: add spinlock for the openFileList to cifsInodeInfo)
  	}
  
 -	return rc;
 -}
 -
 -struct cifsFileInfo *
 -find_writable_file(struct cifsInodeInfo *cifs_inode, bool fsuid_only)
 -{
 -	struct cifsFileInfo *cfile;
 -	int rc;
 -
 -	rc = cifs_get_writable_file(cifs_inode, fsuid_only, &cfile);
 -	if (rc)
 -		cifs_dbg(FYI, "couldn't find writable handle rc=%d", rc);
 -
 -	return cfile;
 +	return NULL;
  }
  
  static int cifs_partialpagewrite(struct page *page, unsigned from, unsigned to)
diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 7a1a5a971751..cad8cb682fde 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -267,6 +267,7 @@ cifs_alloc_inode(struct super_block *sb)
 	cifs_inode->uniqueid = 0;
 	cifs_inode->createtime = 0;
 	cifs_inode->epoch = 0;
+	spin_lock_init(&cifs_inode->open_file_lock);
 	generate_random_uuid(cifs_inode->lease_key);
 
 	/*
diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 761ca006b0af..a270d3d3d54f 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1193,6 +1193,7 @@ struct cifsInodeInfo {
 	struct rw_semaphore lock_sem;	/* protect the fields above */
 	/* BB add in lists for dirty pages i.e. write caching info for oplock */
 	struct list_head openFileList;
+	spinlock_t	open_file_lock;	/* protects openFileList */
 	__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */
 	unsigned int oplock;		/* oplock/lease level we have */
 	unsigned int epoch;		/* used to track lease state changes */
@@ -1577,10 +1578,14 @@ require use of the stronger protocol */
  *  tcp_ses_lock protects:
  *	list operations on tcp and SMB session lists
  *  tcon->open_file_lock protects the list of open files hanging off the tcon
+ *  inode->open_file_lock protects the openFileList hanging off the inode
  *  cfile->file_info_lock protects counters and fields in cifs file struct
  *  f_owner.lock protects certain per file struct operations
  *  mapping->page_lock protects certain per page operations
  *
+ *  Note that the cifs_tcon.open_file_lock should be taken before
+ *  not after the cifsInodeInfo.open_file_lock
+ *
  *  Semaphores
  *  ----------
  *  sesSem     operations on smb session
* Unmerged path fs/cifs/file.c
