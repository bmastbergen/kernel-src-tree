ipc: drop non-RCU allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Kees Cook <keescook@chromium.org>
commit f8dbe8d290637ac3f68600e30d092393fe9b40a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/f8dbe8d2.failed

The only users of ipc_alloc() were ipc_rcu_alloc() and the on-heap
sem_io fall-back memory.  Better to just open-code these to make things
easier to read.

[manfred@colorfullife.com: Rediff due to inclusion of memset() into ipc_rcu_alloc()]
Link: http://lkml.kernel.org/r/20170525185107.12869-5-manfred@colorfullife.com
	Signed-off-by: Kees Cook <keescook@chromium.org>
	Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
	Cc: Davidlohr Bueso <dave@stgolabs.net>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit f8dbe8d290637ac3f68600e30d092393fe9b40a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	ipc/sem.c
#	ipc/util.c
#	ipc/util.h
diff --cc ipc/sem.c
index b95cbc887889,484ccf83cf85..000000000000
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@@ -1365,9 -1368,10 +1365,16 @@@ static int semctl_main(struct ipc_names
  			}
  			sem_unlock(sma, -1);
  			rcu_read_unlock();
++<<<<<<< HEAD
 +			sem_io = ipc_alloc(sizeof(ushort)*nsems);
 +			if(sem_io == NULL) {
 +				ipc_rcu_putref(sma, ipc_rcu_free);
++=======
+ 			sem_io = kvmalloc_array(nsems, sizeof(ushort),
+ 						GFP_KERNEL);
+ 			if (sem_io == NULL) {
+ 				ipc_rcu_putref(&sma->sem_perm, sem_rcu_free);
++>>>>>>> f8dbe8d29063 (ipc: drop non-RCU allocation)
  				return -ENOMEM;
  			}
  
@@@ -1398,10 -1402,11 +1405,18 @@@
  		}
  		rcu_read_unlock();
  
++<<<<<<< HEAD
 +		if(nsems > SEMMSL_FAST) {
 +			sem_io = ipc_alloc(sizeof(ushort)*nsems);
 +			if(sem_io == NULL) {
 +				ipc_rcu_putref(sma, ipc_rcu_free);
++=======
+ 		if (nsems > SEMMSL_FAST) {
+ 			sem_io = kvmalloc_array(nsems, sizeof(ushort),
+ 						GFP_KERNEL);
+ 			if (sem_io == NULL) {
+ 				ipc_rcu_putref(&sma->sem_perm, sem_rcu_free);
++>>>>>>> f8dbe8d29063 (ipc: drop non-RCU allocation)
  				return -ENOMEM;
  			}
  		}
@@@ -1474,10 -1479,10 +1489,15 @@@ out_unlock
  	sem_unlock(sma, -1);
  out_rcu_wakeup:
  	rcu_read_unlock();
 -	wake_up_q(&wake_q);
 +	wake_up_sem_queue_do(&tasks);
  out_free:
++<<<<<<< HEAD
 +	if(sem_io != fast_sem_io)
 +		ipc_free(sem_io, sizeof(ushort)*nsems);
++=======
+ 	if (sem_io != fast_sem_io)
+ 		kvfree(sem_io);
++>>>>>>> f8dbe8d29063 (ipc: drop non-RCU allocation)
  	return err;
  }
  
diff --cc ipc/util.c
index d3c37adf5b01,dd73feb1569a..000000000000
--- a/ipc/util.c
+++ b/ipc/util.c
@@@ -453,76 -395,45 +453,85 @@@ void ipc_rmid(struct ipc_ids *ids, stru
  }
  
  /**
++<<<<<<< HEAD
 + *	ipc_alloc	-	allocate ipc space
 + *	@size: size desired
 + *
 + *	Allocate memory from the appropriate pools and return a pointer to it.
 + *	NULL is returned if the allocation fails
 + */
 + 
 +void *ipc_alloc(int size)
 +{
 +	return kvmalloc(size, GFP_KERNEL);
 +}
 +
 +/**
 + *	ipc_free        -       free ipc space
 + *	@ptr: pointer returned by ipc_alloc
 + *	@size: size of block
 + *
 + *	Free a block created with ipc_alloc(). The caller must know the size
 + *	used in the allocation call.
 + */
 +
 +void ipc_free(void* ptr, int size)
 +{
 +	if(size > PAGE_SIZE)
 +		vfree(ptr);
 +	else
 +		kfree(ptr);
 +}
 +
 +/**
 + *	ipc_rcu_alloc	-	allocate ipc and rcu space 
 + *	@size: size desired
++=======
+  * ipc_rcu_alloc - allocate ipc space
+  * @size: size desired
++>>>>>>> f8dbe8d29063 (ipc: drop non-RCU allocation)
   *
 - * Allocate memory for an ipc object.
 - * The first member must be struct kern_ipc_perm.
 + *	Allocate memory for the rcu header structure +  the object.
 + *	Returns the pointer to the object or NULL upon failure.
   */
 -struct kern_ipc_perm *ipc_rcu_alloc(int size)
 +void *ipc_rcu_alloc(int size)
  {
  	/*
  	 * We prepend the allocation with the rcu struct
  	 */
++<<<<<<< HEAD
 +	struct ipc_rcu *out = ipc_alloc(sizeof(struct ipc_rcu) + size);
++=======
+ 	struct kern_ipc_perm *out = kvmalloc(size, GFP_KERNEL);
++>>>>>>> f8dbe8d29063 (ipc: drop non-RCU allocation)
  	if (unlikely(!out))
  		return NULL;
 -
 -	memset(out, 0, size);
  	atomic_set(&out->refcount, 1);
 -	return out;
 +	return out + 1;
  }
  
 -int ipc_rcu_getref(struct kern_ipc_perm *ptr)
 +int ipc_rcu_getref(void *ptr)
  {
 -	return atomic_inc_not_zero(&ptr->refcount);
 +	struct ipc_rcu *p = ((struct ipc_rcu *)ptr) - 1;
 +
 +	return atomic_inc_not_zero(&p->refcount);
  }
  
 -void ipc_rcu_putref(struct kern_ipc_perm *ptr,
 -			void (*func)(struct rcu_head *head))
 +void ipc_rcu_putref(void *ptr, void (*func)(struct rcu_head *head))
  {
 -	if (!atomic_dec_and_test(&ptr->refcount))
 +	struct ipc_rcu *p = ((struct ipc_rcu *)ptr) - 1;
 +
 +	if (!atomic_dec_and_test(&p->refcount))
  		return;
  
 -	call_rcu(&ptr->rcu, func);
 +	call_rcu(&p->rcu, func);
  }
  
 -void ipc_rcu_free(struct rcu_head *h)
 +void ipc_rcu_free(struct rcu_head *head)
  {
 -	struct kern_ipc_perm *ptr = container_of(h, struct kern_ipc_perm, rcu);
 +	struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);
  
 -	kvfree(ptr);
 +	kvfree(p);
  }
  
  /**
diff --cc ipc/util.h
index 778c12c8c204,2578fd9be835..000000000000
--- a/ipc/util.h
+++ b/ipc/util.h
@@@ -114,12 -107,6 +114,15 @@@ void ipc_rmid(struct ipc_ids *, struct 
  /* must be called with ipcp locked */
  int ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flg);
  
++<<<<<<< HEAD
 +/* for rare, potentially huge allocations.
 + * both function can sleep
 + */
 +void* ipc_alloc(int size);
 +void ipc_free(void* ptr, int size);
 +
++=======
++>>>>>>> f8dbe8d29063 (ipc: drop non-RCU allocation)
  /*
   * For allocation that need to be freed by RCU.
   * Objects are reference counted, they start with reference count 1.
* Unmerged path ipc/sem.c
* Unmerged path ipc/util.c
* Unmerged path ipc/util.h
