ip6_tunnel: collect_md xmit: Use ip_tunnel_key's provided src address

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Shmulik Ladkani <shmulik@metanetworks.com>
commit 3789cabaab1a939eb56edd76bbde2c2e49f081da
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/3789caba.failed

When using an ip6tnl device in collect_md mode, the xmit methods ignore
the ipv6.src field present in skb_tunnel_info's key, both for route
calculation purposes (flowi6 construction) and for assigning the
packet's final ipv6h->saddr.

This makes it impossible specifying a desired ipv6 local address in the
encapsulating header (for example, when using tc action tunnel_key).

This is also not aligned with behavior of ipip (ipv4) in collect_md
mode, where the key->u.ipv4.src gets used.

Fix, by assigning fl6.saddr with given key->u.ipv6.src.
In case ipv6.src is not specified, ip6_tnl_xmit uses existing saddr
selection code.

Fixes: 8d79266bc48c ("ip6_tunnel: add collect_md mode to IPv6 tunnels")
	Signed-off-by: Shmulik Ladkani <shmulik.ladkani@gmail.com>
	Reviewed-by: Eyal Birger <eyal.birger@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3789cabaab1a939eb56edd76bbde2c2e49f081da)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_tunnel.c
diff --cc net/ipv6/ip6_tunnel.c
index 5663d90448eb,820cebe0c687..000000000000
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@@ -1068,6 -1113,10 +1068,13 @@@ int ip6_tnl_xmit(struct sk_buff *skb, s
  			dst = NULL;
  			goto tx_err_link_failure;
  		}
++<<<<<<< HEAD
++=======
+ 		if (t->parms.collect_md && ipv6_addr_any(&fl6->saddr) &&
+ 		    ipv6_dev_get_saddr(net, ip6_dst_idev(dst)->dev,
+ 				       &fl6->daddr, 0, &fl6->saddr))
+ 			goto tx_err_link_failure;
++>>>>>>> 3789cabaab1a (ip6_tunnel: collect_md xmit: Use ip_tunnel_key's provided src address)
  		ndst = dst;
  	}
  
@@@ -1188,19 -1244,46 +1195,36 @@@ ip4ip6_tnl_xmit(struct sk_buff *skb, st
  	if (tproto != IPPROTO_IPIP && tproto != 0)
  		return -1;
  
 -	if (t->parms.collect_md) {
 -		struct ip_tunnel_info *tun_info;
 -		const struct ip_tunnel_key *key;
 +	if (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))
 +		encap_limit = t->parms.encap_limit;
  
++<<<<<<< HEAD
 +	memcpy(&fl6, &t->fl.u.ip6, sizeof(fl6));
 +	fl6.flowi6_proto = IPPROTO_IPIP;
++=======
+ 		tun_info = skb_tunnel_info(skb);
+ 		if (unlikely(!tun_info || !(tun_info->mode & IP_TUNNEL_INFO_TX) ||
+ 			     ip_tunnel_info_af(tun_info) != AF_INET6))
+ 			return -1;
+ 		key = &tun_info->key;
+ 		memset(&fl6, 0, sizeof(fl6));
+ 		fl6.flowi6_proto = IPPROTO_IPIP;
+ 		fl6.saddr = key->u.ipv6.src;
+ 		fl6.daddr = key->u.ipv6.dst;
+ 		fl6.flowlabel = key->label;
+ 		dsfield =  key->tos;
+ 	} else {
+ 		if (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))
+ 			encap_limit = t->parms.encap_limit;
++>>>>>>> 3789cabaab1a (ip6_tunnel: collect_md xmit: Use ip_tunnel_key's provided src address)
  
 -		memcpy(&fl6, &t->fl.u.ip6, sizeof(fl6));
 -		fl6.flowi6_proto = IPPROTO_IPIP;
 -
 -		if (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)
 -			dsfield = ipv4_get_dsfield(iph);
 -		else
 -			dsfield = ip6_tclass(t->parms.flowinfo);
 -		if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
 -			fl6.flowi6_mark = skb->mark;
 -		else
 -			fl6.flowi6_mark = t->parms.fwmark;
 -	}
 -
 -	fl6.flowi6_uid = sock_net_uid(dev_net(dev), NULL);
 +	dsfield = ipv4_get_dsfield(iph);
  
 -	if (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP6))
 -		return -1;
 -
 -	dsfield = INET_ECN_encapsulate(dsfield, ipv4_get_dsfield(iph));
 -
 -	skb_set_inner_ipproto(skb, IPPROTO_IPIP);
 +	if (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)
 +		fl6.flowlabel |= htonl((__u32)iph->tos << IPV6_TCLASS_SHIFT)
 +					  & IPV6_TCLASS_MASK;
 +	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
 +		fl6.flowi6_mark = skb->mark;
  
  	err = ip6_tnl_xmit(skb, dev, dsfield, &fl6, encap_limit, &mtu,
  			   IPPROTO_IPIP);
@@@ -1237,31 -1316,62 +1261,57 @@@ ip6ip6_tnl_xmit(struct sk_buff *skb, st
  	    ip6_tnl_addr_conflict(t, ipv6h))
  		return -1;
  
 -	if (t->parms.collect_md) {
 -		struct ip_tunnel_info *tun_info;
 -		const struct ip_tunnel_key *key;
 -
 -		tun_info = skb_tunnel_info(skb);
 -		if (unlikely(!tun_info || !(tun_info->mode & IP_TUNNEL_INFO_TX) ||
 -			     ip_tunnel_info_af(tun_info) != AF_INET6))
 +	offset = ip6_tnl_parse_tlv_enc_lim(skb, skb_network_header(skb));
 +	/* ip6_tnl_parse_tlv_enc_lim() might have reallocated skb->head */
 +	ipv6h = ipv6_hdr(skb);
 +	if (offset > 0) {
 +		struct ipv6_tlv_tnl_enc_lim *tel;
 +		tel = (struct ipv6_tlv_tnl_enc_lim *)&skb_network_header(skb)[offset];
 +		if (tel->encap_limit == 0) {
 +			icmpv6_send(skb, ICMPV6_PARAMPROB,
 +				    ICMPV6_HDR_FIELD, offset + 2);
  			return -1;
++<<<<<<< HEAD
++=======
+ 		key = &tun_info->key;
+ 		memset(&fl6, 0, sizeof(fl6));
+ 		fl6.flowi6_proto = IPPROTO_IPV6;
+ 		fl6.saddr = key->u.ipv6.src;
+ 		fl6.daddr = key->u.ipv6.dst;
+ 		fl6.flowlabel = key->label;
+ 		dsfield = key->tos;
+ 	} else {
+ 		offset = ip6_tnl_parse_tlv_enc_lim(skb, skb_network_header(skb));
+ 		/* ip6_tnl_parse_tlv_enc_lim() might have reallocated skb->head */
+ 		ipv6h = ipv6_hdr(skb);
+ 		if (offset > 0) {
+ 			struct ipv6_tlv_tnl_enc_lim *tel;
+ 
+ 			tel = (void *)&skb_network_header(skb)[offset];
+ 			if (tel->encap_limit == 0) {
+ 				icmpv6_send(skb, ICMPV6_PARAMPROB,
+ 					    ICMPV6_HDR_FIELD, offset + 2);
+ 				return -1;
+ 			}
+ 			encap_limit = tel->encap_limit - 1;
+ 		} else if (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT)) {
+ 			encap_limit = t->parms.encap_limit;
++>>>>>>> 3789cabaab1a (ip6_tunnel: collect_md xmit: Use ip_tunnel_key's provided src address)
  		}
 +		encap_limit = tel->encap_limit - 1;
 +	} else if (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))
 +		encap_limit = t->parms.encap_limit;
  
 -		memcpy(&fl6, &t->fl.u.ip6, sizeof(fl6));
 -		fl6.flowi6_proto = IPPROTO_IPV6;
 -
 -		if (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)
 -			dsfield = ipv6_get_dsfield(ipv6h);
 -		else
 -			dsfield = ip6_tclass(t->parms.flowinfo);
 -		if (t->parms.flags & IP6_TNL_F_USE_ORIG_FLOWLABEL)
 -			fl6.flowlabel |= ip6_flowlabel(ipv6h);
 -		if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
 -			fl6.flowi6_mark = skb->mark;
 -		else
 -			fl6.flowi6_mark = t->parms.fwmark;
 -	}
 +	memcpy(&fl6, &t->fl.u.ip6, sizeof(fl6));
 +	fl6.flowi6_proto = IPPROTO_IPV6;
  
 -	fl6.flowi6_uid = sock_net_uid(dev_net(dev), NULL);
 -
 -	if (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP6))
 -		return -1;
 -
 -	dsfield = INET_ECN_encapsulate(dsfield, ipv6_get_dsfield(ipv6h));
 -
 -	skb_set_inner_ipproto(skb, IPPROTO_IPV6);
 +	dsfield = ipv6_get_dsfield(ipv6h);
 +	if (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)
 +		fl6.flowlabel |= (*(__be32 *) ipv6h & IPV6_TCLASS_MASK);
 +	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FLOWLABEL)
 +		fl6.flowlabel |= ip6_flowlabel(ipv6h);
 +	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
 +		fl6.flowi6_mark = skb->mark;
  
  	err = ip6_tnl_xmit(skb, dev, dsfield, &fl6, encap_limit, &mtu,
  			   IPPROTO_IPV6);
* Unmerged path net/ipv6/ip6_tunnel.c
