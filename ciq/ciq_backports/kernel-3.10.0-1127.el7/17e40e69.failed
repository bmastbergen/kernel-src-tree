iwlwifi: pcie: don't switch FW to qnj when ax201 is detected

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Luca Coelho <luciano.coelho@intel.com>
commit 17e40e6979aaf60f356331bac129df20e1fd74a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/17e40e69.failed

We have a too generic condition that switches from Qu configurations
to QnJ configurations.  We need to exclude some configurations so that
they are not erroneously switched.  Add the ax201 configuration to the
list of exclusions.

	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
	Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
(cherry picked from commit 17e40e6979aaf60f356331bac129df20e1fd74a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/intel/iwlwifi/pcie/trans.c
diff --cc drivers/net/wireless/intel/iwlwifi/pcie/trans.c
index 3e4a9c886786,935e35dafce5..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
@@@ -3145,7 -3562,52 +3145,56 @@@ struct iwl_trans *iwl_trans_pcie_alloc(
  
  #if IS_ENABLED(CONFIG_IWLMVM)
  	trans->hw_rf_id = iwl_read32(trans, CSR_HW_RF_ID);
++<<<<<<< HEAD
 +	if (trans->hw_rf_id == CSR_HW_RF_ID_TYPE_HR) {
++=======
+ 
+ 	if (cfg == &iwlax210_2ax_cfg_so_hr_a0) {
+ 		if (trans->hw_rev == CSR_HW_REV_TYPE_TY) {
+ 			trans->cfg = &iwlax210_2ax_cfg_ty_gf_a0;
+ 		} else if (CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 			   CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_JF)) {
+ 			trans->cfg = &iwlax210_2ax_cfg_so_jf_a0;
+ 		} else if (CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 			   CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_GF)) {
+ 			trans->cfg = &iwlax211_2ax_cfg_so_gf_a0;
+ 		} else if (CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 			   CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_GF4)) {
+ 			trans->cfg = &iwlax411_2ax_cfg_so_gf4_a0;
+ 		}
+ 	} else if (cfg == &iwl_ax101_cfg_qu_hr) {
+ 		if ((CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 		     CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_HR) &&
+ 		     trans->hw_rev == CSR_HW_REV_TYPE_QNJ_B0) ||
+ 		    (CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 		     CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_HR1))) {
+ 			trans->cfg = &iwl22000_2ax_cfg_qnj_hr_b0;
+ 		} else if (CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 		    CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_HR)) {
+ 			trans->cfg = &iwl_ax101_cfg_qu_hr;
+ 		} else if (CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 			   CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_JF)) {
+ 			trans->cfg = &iwl22000_2ax_cfg_jf;
+ 		} else if (CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 			   CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_HRCDB)) {
+ 			IWL_ERR(trans, "RF ID HRCDB is not supported\n");
+ 			ret = -EINVAL;
+ 			goto out_no_pci;
+ 		} else {
+ 			IWL_ERR(trans, "Unrecognized RF ID 0x%08x\n",
+ 				CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id));
+ 			ret = -EINVAL;
+ 			goto out_no_pci;
+ 		}
+ 	} else if (CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 		   CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_HR) &&
+ 		   ((trans->cfg != &iwl_ax200_cfg_cc &&
+ 		     trans->cfg != &iwl_ax201_cfg_qu_hr &&
+ 		     trans->cfg != &killer1650x_2ax_cfg &&
+ 		     trans->cfg != &killer1650w_2ax_cfg &&
+ 		     trans->cfg != &iwl_ax201_cfg_quz_hr) ||
+ 		    trans->hw_rev == CSR_HW_REV_TYPE_QNJ_B0)) {
++>>>>>>> 17e40e6979aa (iwlwifi: pcie: don't switch FW to qnj when ax201 is detected)
  		u32 hw_status;
  
  		hw_status = iwl_read_prph(trans, UMAG_GEN_HW_STATUS);
* Unmerged path drivers/net/wireless/intel/iwlwifi/pcie/trans.c
