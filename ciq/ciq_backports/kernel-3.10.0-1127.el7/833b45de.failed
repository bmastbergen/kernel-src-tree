kvm: x86, powerpc: do not allow clearing largepages debugfs entry

jira LE-1907
cve CVE-2018-12207
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 833b45de69a6016c4b0cebe6765d526a31a81580
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/833b45de.failed

The largepages debugfs entry is incremented/decremented as shadow
pages are created or destroyed.  Clearing it will result in an
underflow, which is harmless to KVM but ugly (and could be
misinterpreted by tools that use debugfs information), so make
this particular statistic read-only.

	Cc: kvm-ppc@vger.kernel.org
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 833b45de69a6016c4b0cebe6765d526a31a81580)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s.c
#	arch/x86/kvm/x86.c
#	virt/kvm/kvm_main.c
diff --cc arch/powerpc/kvm/book3s.c
index 5ecb857ffd6e,ec2547cc5ecb..000000000000
--- a/arch/powerpc/kvm/book3s.c
+++ b/arch/powerpc/kvm/book3s.c
@@@ -39,7 -36,8 +39,12 @@@
  #include "book3s.h"
  #include "trace.h"
  
++<<<<<<< HEAD
 +#define VCPU_STAT(x) offsetof(struct kvm_vcpu, stat.x), KVM_STAT_VCPU
++=======
+ #define VM_STAT(x, ...) offsetof(struct kvm, stat.x), KVM_STAT_VM, ## __VA_ARGS__
+ #define VCPU_STAT(x, ...) offsetof(struct kvm_vcpu, stat.x), KVM_STAT_VCPU, ## __VA_ARGS__
++>>>>>>> 833b45de69a6 (kvm: x86, powerpc: do not allow clearing largepages debugfs entry)
  
  /* #define EXIT_DEBUG */
  
@@@ -70,6 -69,8 +75,11 @@@ struct kvm_stats_debugfs_item debugfs_e
  	{ "pthru_all",       VCPU_STAT(pthru_all) },
  	{ "pthru_host",      VCPU_STAT(pthru_host) },
  	{ "pthru_bad_aff",   VCPU_STAT(pthru_bad_aff) },
++<<<<<<< HEAD
++=======
+ 	{ "largepages_2M",    VM_STAT(num_2M_pages, .mode = 0444) },
+ 	{ "largepages_1G",    VM_STAT(num_1G_pages, .mode = 0444) },
++>>>>>>> 833b45de69a6 (kvm: x86, powerpc: do not allow clearing largepages debugfs entry)
  	{ NULL }
  };
  
diff --cc arch/x86/kvm/x86.c
index 69feb8491cac,8072acaaf028..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -189,7 -212,9 +189,13 @@@ struct kvm_stats_debugfs_item debugfs_e
  	{ "mmu_cache_miss", VM_STAT(mmu_cache_miss) },
  	{ "mmu_unsync", VM_STAT(mmu_unsync) },
  	{ "remote_tlb_flush", VM_STAT(remote_tlb_flush) },
++<<<<<<< HEAD
 +	{ "largepages", VM_STAT(lpages) },
++=======
+ 	{ "largepages", VM_STAT(lpages, .mode = 0444) },
+ 	{ "max_mmu_page_hash_collisions",
+ 		VM_STAT(max_mmu_page_hash_collisions) },
++>>>>>>> 833b45de69a6 (kvm: x86, powerpc: do not allow clearing largepages debugfs entry)
  	{ NULL }
  };
  
diff --cc virt/kvm/kvm_main.c
index af3df0f2e28f,fd68fbe0a75d..000000000000
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@@ -567,12 -617,10 +567,18 @@@ static int kvm_create_vm_debugfs(struc
  
  		stat_data->kvm = kvm;
  		stat_data->offset = p->offset;
+ 		stat_data->mode = p->mode ? p->mode : 0644;
  		kvm->debugfs_stat_data[p - debugfs_entries] = stat_data;
++<<<<<<< HEAD
 +		if (!debugfs_create_file(p->name, 0444,
 +					 kvm->debugfs_dentry,
 +					 stat_data,
 +					 stat_fops_per_vm[p->kind]))
 +			return -ENOMEM;
++=======
+ 		debugfs_create_file(p->name, stat_data->mode, kvm->debugfs_dentry,
+ 				    stat_data, stat_fops_per_vm[p->kind]);
++>>>>>>> 833b45de69a6 (kvm: x86, powerpc: do not allow clearing largepages debugfs entry)
  	}
  	return 0;
  }
@@@ -3566,10 -3927,12 +3572,12 @@@ static int kvm_debugfs_open(struct inod
  	 * To avoid the race between open and the removal of the debugfs
  	 * directory we test against the users count.
  	 */
 -	if (!refcount_inc_not_zero(&stat_data->kvm->users_count))
 +	if (!atomic_add_unless(&stat_data->kvm->users_count, 1, 0))
  		return -ENOENT;
  
- 	if (simple_attr_open(inode, file, get, set, fmt)) {
+ 	if (simple_attr_open(inode, file, get,
+ 			     stat_data->mode & S_IWUGO ? set : NULL,
+ 			     fmt)) {
  		kvm_put_kvm(stat_data->kvm);
  		return -ENOMEM;
  	}
@@@ -3754,18 -4180,11 +3762,25 @@@ static int kvm_init_debug(void
  
  	kvm_debugfs_num_entries = 0;
  	for (p = debugfs_entries; p->name; ++p, kvm_debugfs_num_entries++) {
++<<<<<<< HEAD
 +		if (!debugfs_create_file(p->name, 0444, kvm_debugfs_dir,
 +					 (void *)(long)p->offset,
 +					 stat_fops[p->kind]))
 +			goto out_dir;
++=======
+ 		int mode = p->mode ? p->mode : 0644;
+ 		debugfs_create_file(p->name, mode, kvm_debugfs_dir,
+ 				    (void *)(long)p->offset,
+ 				    stat_fops[p->kind]);
++>>>>>>> 833b45de69a6 (kvm: x86, powerpc: do not allow clearing largepages debugfs entry)
  	}
 +
 +	return 0;
 +
 +out_dir:
 +	debugfs_remove_recursive(kvm_debugfs_dir);
 +out:
 +	return r;
  }
  
  static int kvm_suspend(void)
* Unmerged path arch/powerpc/kvm/book3s.c
* Unmerged path arch/x86/kvm/x86.c
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index fbc35bbaa5a0..f88dea5a799e 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -1017,6 +1017,7 @@ enum kvm_stat_kind {
 
 struct kvm_stat_data {
 	int offset;
+	int mode;
 	struct kvm *kvm;
 };
 
@@ -1024,6 +1025,7 @@ struct kvm_stats_debugfs_item {
 	const char *name;
 	int offset;
 	enum kvm_stat_kind kind;
+	int mode;
 };
 extern struct kvm_stats_debugfs_item debugfs_entries[];
 extern struct dentry *kvm_debugfs_dir;
* Unmerged path virt/kvm/kvm_main.c
