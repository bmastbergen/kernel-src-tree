gfs2: Get rid of gfs2_log_header_in

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 0ff5916ad4eb857e03e7586665d1c022ef3277f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/0ff5916a.failed

Get rid of gfs2_log_header_in by integrating it into get_log_header.
Clean up the crc32 computations and use the same functions for encoding
and decoding to make things less confusing.  Eliminate lh_hash from
gfs2_log_header_host which is completely useless.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 0ff5916ad4eb857e03e7586665d1c022ef3277f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/log.c
diff --cc fs/gfs2/log.c
index 15a3a8cfcfad,c27cbcebfe88..000000000000
--- a/fs/gfs2/log.c
+++ b/fs/gfs2/log.c
@@@ -617,6 -651,44 +617,47 @@@ out_of_blocks
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * write_log_header - Write a journal log header buffer at sd_log_flush_head
+  * @sdp: The GFS2 superblock
+  * @seq: sequence number
+  * @tail: tail of the log
+  * @flags: log header flags
+  * @op_flags: flags to pass to the bio
+  *
+  * Returns: the initialized log buffer descriptor
+  */
+ 
+ void gfs2_write_log_header(struct gfs2_sbd *sdp, u64 seq, u32 tail,
+ 			   u32 flags, int op_flags)
+ {
+ 	struct gfs2_log_header *lh;
+ 	u32 hash;
+ 	struct page *page = mempool_alloc(gfs2_page_pool, GFP_NOIO);
+ 
+ 	lh = page_address(page);
+ 	clear_page(lh);
+ 
+ 	lh->lh_header.mh_magic = cpu_to_be32(GFS2_MAGIC);
+ 	lh->lh_header.mh_type = cpu_to_be32(GFS2_METATYPE_LH);
+ 	lh->lh_header.__pad0 = cpu_to_be64(0);
+ 	lh->lh_header.mh_format = cpu_to_be32(GFS2_FORMAT_LH);
+ 	lh->lh_header.mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);
+ 	lh->lh_sequence = cpu_to_be64(seq);
+ 	lh->lh_flags = cpu_to_be32(flags);
+ 	lh->lh_tail = cpu_to_be32(tail);
+ 	lh->lh_blkno = cpu_to_be32(sdp->sd_log_flush_head);
+ 	hash = ~crc32(~0, lh, sizeof(*lh));
+ 	lh->lh_hash = cpu_to_be32(hash);
+ 
+ 	gfs2_log_write_page(sdp, page);
+ 	gfs2_log_flush_bio(sdp, REQ_OP_WRITE, op_flags);
+ 	log_flush_wait(sdp);
+ }
+ 
+ /**
++>>>>>>> 0ff5916ad4eb (gfs2: Get rid of gfs2_log_header_in)
   * log_write_header - Get and initialize a journal header buffer
   * @sdp: The GFS2 superblock
   *
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index a714432d2254..ef7e7c6b0dc5 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -44,7 +44,6 @@ struct gfs2_log_header_host {
 	u32 lh_flags;		/* GFS2_LOG_HEAD_... */
 	u32 lh_tail;		/* Block number of log tail */
 	u32 lh_blkno;
-	u32 lh_hash;
 };
 
 /*
* Unmerged path fs/gfs2/log.c
diff --git a/fs/gfs2/recovery.c b/fs/gfs2/recovery.c
index 489aaf82cabb..807cdebb082e 100644
--- a/fs/gfs2/recovery.c
+++ b/fs/gfs2/recovery.c
@@ -117,22 +117,6 @@ void gfs2_revoke_clean(struct gfs2_jdesc *jd)
 	}
 }
 
-static int gfs2_log_header_in(struct gfs2_log_header_host *lh, const void *buf)
-{
-	const struct gfs2_log_header *str = buf;
-
-	if (str->lh_header.mh_magic != cpu_to_be32(GFS2_MAGIC) ||
-	    str->lh_header.mh_type != cpu_to_be32(GFS2_METATYPE_LH))
-		return 1;
-
-	lh->lh_sequence = be64_to_cpu(str->lh_sequence);
-	lh->lh_flags = be32_to_cpu(str->lh_flags);
-	lh->lh_tail = be32_to_cpu(str->lh_tail);
-	lh->lh_blkno = be32_to_cpu(str->lh_blkno);
-	lh->lh_hash = be32_to_cpu(str->lh_hash);
-	return 0;
-}
-
 /**
  * get_log_header - read the log header for a given segment
  * @jd: the journal
@@ -150,29 +134,33 @@ static int gfs2_log_header_in(struct gfs2_log_header_host *lh, const void *buf)
 static int get_log_header(struct gfs2_jdesc *jd, unsigned int blk,
 			  struct gfs2_log_header_host *head)
 {
+	struct gfs2_log_header *lh;
 	struct buffer_head *bh;
-	struct gfs2_log_header_host uninitialized_var(lh);
-	const u32 nothing = 0;
 	u32 hash;
 	int error;
 
 	error = gfs2_replay_read_block(jd, blk, &bh);
 	if (error)
 		return error;
+	lh = (void *)bh->b_data;
 
-	hash = crc32_le((u32)~0, bh->b_data, sizeof(struct gfs2_log_header) -
-					     sizeof(u32));
-	hash = crc32_le(hash, (unsigned char const *)&nothing, sizeof(nothing));
-	hash ^= (u32)~0;
-	error = gfs2_log_header_in(&lh, bh->b_data);
-	brelse(bh);
+	hash = crc32(~0, lh, sizeof(*lh) - 4);
+	hash = ~crc32_le_shift(hash, 4);  /* assume lh_hash is zero */
 
-	if (error || lh.lh_blkno != blk || lh.lh_hash != hash)
-		return 1;
+	error = lh->lh_header.mh_magic != cpu_to_be32(GFS2_MAGIC) ||
+		lh->lh_header.mh_type != cpu_to_be32(GFS2_METATYPE_LH) ||
+		be32_to_cpu(lh->lh_blkno) != blk ||
+		be32_to_cpu(lh->lh_hash) != hash;
 
-	*head = lh;
+	brelse(bh);
 
-	return 0;
+	if (!error) {
+		head->lh_sequence = be64_to_cpu(lh->lh_sequence);
+		head->lh_flags = be32_to_cpu(lh->lh_flags);
+		head->lh_tail = be32_to_cpu(lh->lh_tail);
+		head->lh_blkno = be32_to_cpu(lh->lh_blkno);
+	}
+	return error;
 }
 
 /**
