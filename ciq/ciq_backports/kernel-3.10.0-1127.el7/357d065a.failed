crypto: vmx - ghash: do nosimd fallback manually

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Daniel Axtens <dja@axtens.net>
commit 357d065a44cdd77ed5ff35155a989f2a763e96ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/357d065a.failed

VMX ghash was using a fallback that did not support interleaving simd
and nosimd operations, leading to failures in the extended test suite.

If I understood correctly, Eric's suggestion was to use the same
data format that the generic code uses, allowing us to call into it
with the same contexts. I wasn't able to get that to work - I think
there's a very different key structure and data layout being used.

So instead steal the arm64 approach and perform the fallback
operations directly if required.

Fixes: cc333cd68dfa ("crypto: vmx - Adding GHASH routines for VMX module")
	Cc: stable@vger.kernel.org # v4.1+
	Reported-by: Eric Biggers <ebiggers@google.com>
	Signed-off-by: Daniel Axtens <dja@axtens.net>
	Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Tested-by: Michael Ellerman <mpe@ellerman.id.au>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 357d065a44cdd77ed5ff35155a989f2a763e96ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/vmx/ghash.c
diff --cc drivers/crypto/vmx/ghash.c
index 6d98ae1dc3c6,14807ac2e3b9..000000000000
--- a/drivers/crypto/vmx/ghash.c
+++ b/drivers/crypto/vmx/ghash.c
@@@ -47,65 -40,15 +41,70 @@@ struct p8_ghash_desc_ctx 
  	u64 shash[2];
  	u8 buffer[GHASH_DIGEST_SIZE];
  	int bytes;
- 	struct shash_desc fallback_desc;
  };
  
++<<<<<<< HEAD
 +static int p8_ghash_init_tfm(struct crypto_tfm *tfm)
 +{
 +	const char *alg = "ghash-generic";
 +	struct crypto_shash *fallback;
 +	struct crypto_shash *shash_tfm = __crypto_shash_cast(tfm);
 +	struct p8_ghash_ctx *ctx = crypto_tfm_ctx(tfm);
 +
 +	fallback = crypto_alloc_shash(alg, 0, CRYPTO_ALG_NEED_FALLBACK);
 +	if (IS_ERR(fallback)) {
 +		printk(KERN_ERR
 +		       "Failed to allocate transformation for '%s': %ld\n",
 +		       alg, PTR_ERR(fallback));
 +		return PTR_ERR(fallback);
 +	}
 +	printk(KERN_INFO "Using '%s' as fallback implementation.\n",
 +	       crypto_tfm_alg_driver_name(crypto_shash_tfm(fallback)));
 +
 +	crypto_shash_set_flags(fallback,
 +			       crypto_shash_get_flags((struct crypto_shash
 +						       *) tfm));
 +
 +	/* Check if the descsize defined in the algorithm is still enough. */
 +	if (shash_tfm->descsize < sizeof(struct p8_ghash_desc_ctx)
 +	    + crypto_shash_descsize(fallback)) {
 +		printk(KERN_ERR
 +		       "Desc size of the fallback implementation (%s) does not match the expected value: %lu vs %u\n",
 +		       alg,
 +		       shash_tfm->descsize - sizeof(struct p8_ghash_desc_ctx),
 +		       crypto_shash_descsize(fallback));
 +		return -EINVAL;
 +	}
 +	ctx->fallback = fallback;
 +
 +	return 0;
 +}
 +
 +static void p8_ghash_exit_tfm(struct crypto_tfm *tfm)
 +{
 +	struct p8_ghash_ctx *ctx = crypto_tfm_ctx(tfm);
 +
 +	if (ctx->fallback) {
 +		crypto_free_shash(ctx->fallback);
 +		ctx->fallback = NULL;
 +	}
 +}
 +
++=======
++>>>>>>> 357d065a44cd (crypto: vmx - ghash: do nosimd fallback manually)
  static int p8_ghash_init(struct shash_desc *desc)
  {
- 	struct p8_ghash_ctx *ctx = crypto_tfm_ctx(crypto_shash_tfm(desc->tfm));
  	struct p8_ghash_desc_ctx *dctx = shash_desc_ctx(desc);
  
  	dctx->bytes = 0;
  	memset(dctx->shash, 0, GHASH_DIGEST_SIZE);
++<<<<<<< HEAD
 +	dctx->fallback_desc.tfm = ctx->fallback;
 +	dctx->fallback_desc.flags = desc->flags;
 +	return crypto_shash_init(&dctx->fallback_desc);
++=======
+ 	return 0;
++>>>>>>> 357d065a44cd (crypto: vmx - ghash: do nosimd fallback manually)
  }
  
  static int p8_ghash_setkey(struct crypto_shash *tfm, const u8 *key,
@@@ -120,9 -63,54 +119,53 @@@
  	pagefault_disable();
  	enable_kernel_vsx();
  	gcm_init_p8(ctx->htable, (const u64 *) key);
 -	disable_kernel_vsx();
  	pagefault_enable();
  	preempt_enable();
- 	return crypto_shash_setkey(ctx->fallback, key, keylen);
+ 
+ 	memcpy(&ctx->key, key, GHASH_BLOCK_SIZE);
+ 
+ 	return 0;
+ }
+ 
+ static inline void __ghash_block(struct p8_ghash_ctx *ctx,
+ 				 struct p8_ghash_desc_ctx *dctx)
+ {
+ 	if (crypto_simd_usable()) {
+ 		preempt_disable();
+ 		pagefault_disable();
+ 		enable_kernel_vsx();
+ 		gcm_ghash_p8(dctx->shash, ctx->htable,
+ 				dctx->buffer, GHASH_DIGEST_SIZE);
+ 		disable_kernel_vsx();
+ 		pagefault_enable();
+ 		preempt_enable();
+ 	} else {
+ 		crypto_xor((u8 *)dctx->shash, dctx->buffer, GHASH_BLOCK_SIZE);
+ 		gf128mul_lle((be128 *)dctx->shash, &ctx->key);
+ 	}
+ }
+ 
+ static inline void __ghash_blocks(struct p8_ghash_ctx *ctx,
+ 				  struct p8_ghash_desc_ctx *dctx,
+ 				  const u8 *src, unsigned int srclen)
+ {
+ 	if (crypto_simd_usable()) {
+ 		preempt_disable();
+ 		pagefault_disable();
+ 		enable_kernel_vsx();
+ 		gcm_ghash_p8(dctx->shash, ctx->htable,
+ 				src, srclen);
+ 		disable_kernel_vsx();
+ 		pagefault_enable();
+ 		preempt_enable();
+ 	} else {
+ 		while (srclen >= GHASH_BLOCK_SIZE) {
+ 			crypto_xor((u8 *)dctx->shash, src, GHASH_BLOCK_SIZE);
+ 			gf128mul_lle((be128 *)dctx->shash, &ctx->key);
+ 			srclen -= GHASH_BLOCK_SIZE;
+ 			src += GHASH_BLOCK_SIZE;
+ 		}
+ 	}
  }
  
  static int p8_ghash_update(struct shash_desc *desc,
@@@ -132,47 -120,33 +175,76 @@@
  	struct p8_ghash_ctx *ctx = crypto_tfm_ctx(crypto_shash_tfm(desc->tfm));
  	struct p8_ghash_desc_ctx *dctx = shash_desc_ctx(desc);
  
++<<<<<<< HEAD
 +	if (IN_INTERRUPT) {
 +		return crypto_shash_update(&dctx->fallback_desc, src,
 +					   srclen);
 +	} else {
 +		if (dctx->bytes) {
 +			if (dctx->bytes + srclen < GHASH_DIGEST_SIZE) {
 +				memcpy(dctx->buffer + dctx->bytes, src,
 +				       srclen);
 +				dctx->bytes += srclen;
 +				return 0;
 +			}
 +			memcpy(dctx->buffer + dctx->bytes, src,
 +			       GHASH_DIGEST_SIZE - dctx->bytes);
 +			preempt_disable();
 +			pagefault_disable();
 +			enable_kernel_vsx();
 +			gcm_ghash_p8(dctx->shash, ctx->htable,
 +				     dctx->buffer, GHASH_DIGEST_SIZE);
 +			pagefault_enable();
 +			preempt_enable();
 +			src += GHASH_DIGEST_SIZE - dctx->bytes;
 +			srclen -= GHASH_DIGEST_SIZE - dctx->bytes;
 +			dctx->bytes = 0;
 +		}
 +		len = srclen & ~(GHASH_DIGEST_SIZE - 1);
 +		if (len) {
 +			preempt_disable();
 +			pagefault_disable();
 +			enable_kernel_vsx();
 +			gcm_ghash_p8(dctx->shash, ctx->htable, src, len);
 +			pagefault_enable();
 +			preempt_enable();
 +			src += len;
 +			srclen -= len;
 +		}
 +		if (srclen) {
 +			memcpy(dctx->buffer, src, srclen);
 +			dctx->bytes = srclen;
 +		}
 +		return 0;
++=======
+ 	if (dctx->bytes) {
+ 		if (dctx->bytes + srclen < GHASH_DIGEST_SIZE) {
+ 			memcpy(dctx->buffer + dctx->bytes, src,
+ 				srclen);
+ 			dctx->bytes += srclen;
+ 			return 0;
+ 		}
+ 		memcpy(dctx->buffer + dctx->bytes, src,
+ 			GHASH_DIGEST_SIZE - dctx->bytes);
+ 
+ 		__ghash_block(ctx, dctx);
+ 
+ 		src += GHASH_DIGEST_SIZE - dctx->bytes;
+ 		srclen -= GHASH_DIGEST_SIZE - dctx->bytes;
+ 		dctx->bytes = 0;
++>>>>>>> 357d065a44cd (crypto: vmx - ghash: do nosimd fallback manually)
+ 	}
+ 	len = srclen & ~(GHASH_DIGEST_SIZE - 1);
+ 	if (len) {
+ 		__ghash_blocks(ctx, dctx, src, len);
+ 		src += len;
+ 		srclen -= len;
  	}
+ 	if (srclen) {
+ 		memcpy(dctx->buffer, src, srclen);
+ 		dctx->bytes = srclen;
+ 	}
+ 	return 0;
  }
  
  static int p8_ghash_final(struct shash_desc *desc, u8 *out)
@@@ -181,24 -155,14 +253,34 @@@
  	struct p8_ghash_ctx *ctx = crypto_tfm_ctx(crypto_shash_tfm(desc->tfm));
  	struct p8_ghash_desc_ctx *dctx = shash_desc_ctx(desc);
  
++<<<<<<< HEAD
 +	if (IN_INTERRUPT) {
 +		return crypto_shash_final(&dctx->fallback_desc, out);
 +	} else {
 +		if (dctx->bytes) {
 +			for (i = dctx->bytes; i < GHASH_DIGEST_SIZE; i++)
 +				dctx->buffer[i] = 0;
 +			preempt_disable();
 +			pagefault_disable();
 +			enable_kernel_vsx();
 +			gcm_ghash_p8(dctx->shash, ctx->htable,
 +				     dctx->buffer, GHASH_DIGEST_SIZE);
 +			pagefault_enable();
 +			preempt_enable();
 +			dctx->bytes = 0;
 +		}
 +		memcpy(out, dctx->shash, GHASH_DIGEST_SIZE);
 +		return 0;
++=======
+ 	if (dctx->bytes) {
+ 		for (i = dctx->bytes; i < GHASH_DIGEST_SIZE; i++)
+ 			dctx->buffer[i] = 0;
+ 		__ghash_block(ctx, dctx);
+ 		dctx->bytes = 0;
++>>>>>>> 357d065a44cd (crypto: vmx - ghash: do nosimd fallback manually)
  	}
+ 	memcpy(out, dctx->shash, GHASH_DIGEST_SIZE);
+ 	return 0;
  }
  
  struct shash_alg p8_ghash_alg = {
@@@ -213,7 -177,6 +295,10 @@@
  		 .cra_name = "ghash",
  		 .cra_driver_name = "p8_ghash",
  		 .cra_priority = 1000,
++<<<<<<< HEAD
 +		 .cra_flags = CRYPTO_ALG_TYPE_SHASH | CRYPTO_ALG_NEED_FALLBACK,
++=======
++>>>>>>> 357d065a44cd (crypto: vmx - ghash: do nosimd fallback manually)
  		 .cra_blocksize = GHASH_BLOCK_SIZE,
  		 .cra_ctxsize = sizeof(struct p8_ghash_ctx),
  		 .cra_module = THIS_MODULE,
* Unmerged path drivers/crypto/vmx/ghash.c
