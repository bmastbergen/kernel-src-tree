KVM: x86: Add a framework for supporting MSR-based features

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Tom Lendacky <thomas.lendacky@amd.com>
commit 801e459a6f3a63af9d447e6249088c76ae16efc4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/801e459a.failed

Provide a new KVM capability that allows bits within MSRs to be recognized
as features.  Two new ioctls are added to the /dev/kvm ioctl routine to
retrieve the list of these MSRs and then retrieve their values. A kvm_x86_ops
callback is used to determine support for the listed MSR-based features.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
[Tweaked documentation. - Radim]
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit 801e459a6f3a63af9d447e6249088c76ae16efc4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/x86.c
#	include/uapi/linux/kvm.h
diff --cc arch/x86/include/asm/kvm_host.h
index 35f22ae3e497,bab0694b35c3..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -1085,6 -1091,12 +1085,15 @@@ struct kvm_x86_ops 
  	int (*pre_enter_smm)(struct kvm_vcpu *vcpu, char *smstate);
  	int (*pre_leave_smm)(struct kvm_vcpu *vcpu, u64 smbase);
  	int (*enable_smi_window)(struct kvm_vcpu *vcpu);
++<<<<<<< HEAD
++=======
+ 
+ 	int (*mem_enc_op)(struct kvm *kvm, void __user *argp);
+ 	int (*mem_enc_reg_region)(struct kvm *kvm, struct kvm_enc_region *argp);
+ 	int (*mem_enc_unreg_region)(struct kvm *kvm, struct kvm_enc_region *argp);
+ 
+ 	int (*get_msr_feature)(struct kvm_msr_entry *entry);
++>>>>>>> 801e459a6f3a (KVM: x86: Add a framework for supporting MSR-based features)
  };
  
  struct kvm_arch_async_pf {
diff --cc arch/x86/kvm/x86.c
index 69feb8491cac,239fc1fd7845..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -2674,10 -2804,8 +2694,15 @@@ int kvm_vm_ioctl_check_extension(struc
  	case KVM_CAP_DISABLE_QUIRKS:
  	case KVM_CAP_SET_BOOT_CPU_ID:
   	case KVM_CAP_SPLIT_IRQCHIP:
++<<<<<<< HEAD
 +#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT
 +	case KVM_CAP_ASSIGN_DEV_IRQ:
 +	case KVM_CAP_PCI_2_3:
 +#endif
++=======
+ 	case KVM_CAP_IMMEDIATE_EXIT:
+ 	case KVM_CAP_GET_MSR_FEATURES:
++>>>>>>> 801e459a6f3a (KVM: x86: Add a framework for supporting MSR-based features)
  		r = 1;
  		break;
  	case KVM_CAP_ADJUST_CLOCK:
diff --cc include/uapi/linux/kvm.h
index afa0c1ad3524,7b26d4b0b052..000000000000
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@@ -730,13 -905,37 +731,20 @@@ struct kvm_ppc_resize_hpt 
  #define KVM_CAP_GUEST_DEBUG_HW_WPS 120
  #define KVM_CAP_SPLIT_IRQCHIP 121
  #define KVM_CAP_IOEVENTFD_ANY_LENGTH 122
 -#define KVM_CAP_HYPERV_SYNIC 123
 -#define KVM_CAP_S390_RI 124
 -#define KVM_CAP_SPAPR_TCE_64 125
 -#define KVM_CAP_ARM_PMU_V3 126
 -#define KVM_CAP_VCPU_ATTRIBUTES 127
  #define KVM_CAP_MAX_VCPU_ID 128
  #define KVM_CAP_X2APIC_API 129
 -#define KVM_CAP_S390_USER_INSTR0 130
 -#define KVM_CAP_MSI_DEVID 131
 -#define KVM_CAP_PPC_HTM 132
  #define KVM_CAP_SPAPR_RESIZE_HPT 133
 -#define KVM_CAP_PPC_MMU_RADIX 134
 -#define KVM_CAP_PPC_MMU_HASH_V3 135
 -#define KVM_CAP_IMMEDIATE_EXIT 136
 -#define KVM_CAP_MIPS_VZ 137
 -#define KVM_CAP_MIPS_TE 138
 -#define KVM_CAP_MIPS_64BIT 139
 -#define KVM_CAP_S390_GS 140
 -#define KVM_CAP_S390_AIS 141
 -#define KVM_CAP_SPAPR_TCE_VFIO 142
 -#define KVM_CAP_X86_GUEST_MWAIT 143
 -#define KVM_CAP_ARM_USER_IRQ 144
 -#define KVM_CAP_S390_CMMA_MIGRATION 145
 -#define KVM_CAP_PPC_FWNMI 146
 -#define KVM_CAP_PPC_SMT_POSSIBLE 147
 +#define KVM_CAP_PPC_GET_CPU_CHAR 151
 +#define KVM_CAP_HYPERV_SYNIC 123
  #define KVM_CAP_HYPERV_SYNIC2 148
  #define KVM_CAP_HYPERV_VP_INDEX 149
++<<<<<<< HEAD
++=======
+ #define KVM_CAP_S390_AIS_MIGRATION 150
+ #define KVM_CAP_PPC_GET_CPU_CHAR 151
+ #define KVM_CAP_S390_BPB 152
+ #define KVM_CAP_GET_MSR_FEATURES 153
++>>>>>>> 801e459a6f3a (KVM: x86: Add a framework for supporting MSR-based features)
  
  #ifdef KVM_CAP_IRQ_ROUTING
  
diff --git a/Documentation/virtual/kvm/api.txt b/Documentation/virtual/kvm/api.txt
index 67f64c409235..c6e14f7b5a53 100644
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@ -122,14 +122,15 @@ KVM_CAP_S390_UCONTROL and use the flag KVM_VM_S390_UCONTROL as
 privileged user (CAP_SYS_ADMIN).
 
 
-4.3 KVM_GET_MSR_INDEX_LIST
+4.3 KVM_GET_MSR_INDEX_LIST, KVM_GET_MSR_FEATURE_INDEX_LIST
 
-Capability: basic
+Capability: basic, KVM_CAP_GET_MSR_FEATURES for KVM_GET_MSR_FEATURE_INDEX_LIST
 Architectures: x86
-Type: system
+Type: system ioctl
 Parameters: struct kvm_msr_list (in/out)
 Returns: 0 on success; -1 on error
 Errors:
+  EFAULT:    the msr index list cannot be read from or written to
   E2BIG:     the msr index list is to be to fit in the array specified by
              the user.
 
@@ -138,16 +139,23 @@ struct kvm_msr_list {
 	__u32 indices[0];
 };
 
-This ioctl returns the guest msrs that are supported.  The list varies
-by kvm version and host processor, but does not change otherwise.  The
-user fills in the size of the indices array in nmsrs, and in return
-kvm adjusts nmsrs to reflect the actual number of msrs and fills in
-the indices array with their numbers.
+The user fills in the size of the indices array in nmsrs, and in return
+kvm adjusts nmsrs to reflect the actual number of msrs and fills in the
+indices array with their numbers.
+
+KVM_GET_MSR_INDEX_LIST returns the guest msrs that are supported.  The list
+varies by kvm version and host processor, but does not change otherwise.
 
 Note: if kvm indicates supports MCE (KVM_CAP_MCE), then the MCE bank MSRs are
 not returned in the MSR list, as different vcpus can have a different number
 of banks, as set via the KVM_X86_SETUP_MCE ioctl.
 
+KVM_GET_MSR_FEATURE_INDEX_LIST returns the list of MSRs that can be passed
+to the KVM_GET_MSRS system ioctl.  This lets userspace probe host capabilities
+and processor features that are exposed via MSRs (e.g., VMX capabilities).
+This list also varies by kvm version and host processor, but does not change
+otherwise.
+
 
 4.4 KVM_CHECK_EXTENSION
 
@@ -460,14 +468,22 @@ Support for this has been removed.  Use KVM_SET_GUEST_DEBUG instead.
 
 4.18 KVM_GET_MSRS
 
-Capability: basic
+Capability: basic (vcpu), KVM_CAP_GET_MSR_FEATURES (system)
 Architectures: x86
-Type: vcpu ioctl
+Type: system ioctl, vcpu ioctl
 Parameters: struct kvm_msrs (in/out)
-Returns: 0 on success, -1 on error
+Returns: number of msrs successfully returned;
+        -1 on error
+
+When used as a system ioctl:
+Reads the values of MSR-based features that are available for the VM.  This
+is similar to KVM_GET_SUPPORTED_CPUID, but it returns MSR indices and values.
+The list of msr-based features can be obtained using KVM_GET_MSR_FEATURE_INDEX_LIST
+in a system ioctl.
 
+When used as a vcpu ioctl:
 Reads model-specific registers from the vcpu.  Supported msr indices can
-be obtained using KVM_GET_MSR_INDEX_LIST.
+be obtained using KVM_GET_MSR_INDEX_LIST in a system ioctl.
 
 struct kvm_msrs {
 	__u32 nmsrs; /* number of msrs in entries */
* Unmerged path arch/x86/include/asm/kvm_host.h
diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c
index 1d79a6e54e94..3338ea21b570 100644
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -3708,6 +3708,11 @@ static int cr8_write_interception(struct vcpu_svm *svm)
 	return 0;
 }
 
+static int svm_get_msr_feature(struct kvm_msr_entry *msr)
+{
+	return 1;
+}
+
 static int svm_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 {
 	struct vcpu_svm *svm = to_svm(vcpu);
@@ -5742,6 +5747,7 @@ static struct kvm_x86_ops svm_x86_ops = {
 	.vcpu_unblocking = svm_vcpu_unblocking,
 
 	.update_bp_intercept = update_bp_intercept,
+	.get_msr_feature = svm_get_msr_feature,
 	.get_msr = svm_get_msr,
 	.set_msr = svm_set_msr,
 	.get_segment_base = svm_get_segment_base,
diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index 0288e33ce3ec..33b5c1679beb 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -3181,6 +3181,11 @@ static inline bool vmx_feature_control_msr_valid(struct kvm_vcpu *vcpu,
 	return !(val & ~valid_bits);
 }
 
+static int vmx_get_msr_feature(struct kvm_msr_entry *msr)
+{
+	return 1;
+}
+
 /*
  * Reads an msr value (of 'msr_index') into 'pdata'.
  * Returns 0 on success, non-0 otherwise.
@@ -12339,6 +12344,7 @@ static struct kvm_x86_ops vmx_x86_ops = {
 	.vcpu_put = vmx_vcpu_put,
 
 	.update_bp_intercept = update_exception_bitmap,
+	.get_msr_feature = vmx_get_msr_feature,
 	.get_msr = vmx_get_msr,
 	.set_msr = vmx_set_msr,
 	.get_segment_base = vmx_get_segment_base,
* Unmerged path arch/x86/kvm/x86.c
* Unmerged path include/uapi/linux/kvm.h
