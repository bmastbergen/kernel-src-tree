perf callchain: Honour the ordering of PERF_CONTEXT_{USER,KERNEL,etc}

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [tools] perf callchain: Honour the ordering of PERF_CONTEXT_{USER, KERNEL, etc} (Michael Petlan) [1758046]
Rebuild_FUZZ: 98.57%
commit-author David S. Miller <davem@davemloft.net>
commit e9024d519d892b38176cafd46f68a7cdddd77412
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/e9024d51.failed

When processing using 'perf report -g caller', which is the default, we
ended up reverting the callchain entries received from the kernel, but
simply reverting throws away the information that tells that from a
point onwards the addresses are for userspace, kernel, guest kernel,
guest user, hypervisor.

The idea is that if we are walking backwards, for each cluster of
non-cpumode entries we have to first scan backwards for the next one and
use that for the cluster.

This seems silly and more expensive than it needs to be but it is enough
for a initial fix.

The code here is really complicated because it is intimately intertwined
with the lbr and branch handling, as well as this callchain order,
further fixes will be needed to properly take into account the cpumode
in those cases.

Another problem with ORDER_CALLER is that the NULL "0" IP that is at the
end of most callchains shows up at the top of the histogram because
every callchain contains it and with ORDER_CALLER it is the first entry.

	Signed-off-by: David S. Miller <davem@davemloft.net>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Souvik Banerjee <souvik1997@gmail.com>
	Cc: Wang Nan <wangnan0@huawei.com>
	Cc: stable@vger.kernel.org # 4.19
Link: https://lkml.kernel.org/n/tip-2wt3ayp6j2y2f2xowixa8y6y@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit e9024d519d892b38176cafd46f68a7cdddd77412)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/machine.c
diff --cc tools/perf/util/machine.c
index 64f4a3a50bdb,8ee8ab39d8ac..000000000000
--- a/tools/perf/util/machine.c
+++ b/tools/perf/util/machine.c
@@@ -2233,12 -2267,14 +2254,23 @@@ static int thread__resolve_callchain_sa
  	}
  
  check_calls:
++<<<<<<< HEAD
 +	if (chain->nr > sysctl_perf_event_max_stack && (int)chain->nr > max_stack) {
 +		pr_warning("corrupted callchain. skipping...\n");
 +		return 0;
 +	}
 +
 +	for (i = first_call; i < chain_nr; i++) {
++=======
+ 	if (callchain_param.order != ORDER_CALLEE) {
+ 		err = find_prev_cpumode(chain, thread, cursor, parent, root_al,
+ 					&cpumode, chain->nr - first_call);
+ 		if (err)
+ 			return (err < 0) ? err : 0;
+ 	}
+ 	for (i = first_call, nr_entries = 0;
+ 	     i < chain_nr && nr_entries < max_stack; i++) {
++>>>>>>> e9024d519d89 (perf callchain: Honour the ordering of PERF_CONTEXT_{USER,KERNEL,etc})
  		u64 ip;
  
  		if (callchain_param.order == ORDER_CALLEE)
@@@ -2251,6 -2287,15 +2283,18 @@@
  			continue;
  #endif
  		ip = chain->ips[j];
++<<<<<<< HEAD
++=======
+ 		if (ip < PERF_CONTEXT_MAX)
+                        ++nr_entries;
+ 		else if (callchain_param.order != ORDER_CALLEE) {
+ 			err = find_prev_cpumode(chain, thread, cursor, parent,
+ 						root_al, &cpumode, j);
+ 			if (err)
+ 				return (err < 0) ? err : 0;
+ 			continue;
+ 		}
++>>>>>>> e9024d519d89 (perf callchain: Honour the ordering of PERF_CONTEXT_{USER,KERNEL,etc})
  
  		err = add_callchain_ip(thread, cursor, parent,
  				       root_al, &cpumode, ip,
* Unmerged path tools/perf/util/machine.c
