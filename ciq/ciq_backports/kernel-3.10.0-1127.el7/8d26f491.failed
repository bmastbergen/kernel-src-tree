scsi: sg: recheck MMAP_IO request length with lock held

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [scsi] sg: recheck MMAP_IO request length with lock held (Ewan Milne) [1710533]
Rebuild_FUZZ: 94.23%
commit-author Todd Poynor <toddpoynor@google.com>
commit 8d26f491116feaa0b16de370b6a7ba40a40fa0b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/8d26f491.failed

Commit 1bc0eb044615 ("scsi: sg: protect accesses to 'reserved' page
array") adds needed concurrency protection for the "reserve" buffer.
Some checks that are initially made outside the lock are replicated once
the lock is taken to ensure the checks and resulting decisions are made
using consistent state.

The check that a request with flag SG_FLAG_MMAP_IO set fits in the
reserve buffer also needs to be performed again under the lock to ensure
the reserve buffer length compared against matches the value in effect
when the request is linked to the reserve buffer.  An -ENOMEM should be
returned in this case, instead of switching over to an indirect buffer
as for non-MMAP_IO requests.

	Signed-off-by: Todd Poynor <toddpoynor@google.com>
	Acked-by: Douglas Gilbert <dgilbert@interlog.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 8d26f491116feaa0b16de370b6a7ba40a40fa0b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/sg.c
diff --cc drivers/scsi/sg.c
index d2c3bdbc08a2,bda438e1fb1d..000000000000
--- a/drivers/scsi/sg.c
+++ b/drivers/scsi/sg.c
@@@ -1754,13 -1759,25 +1754,23 @@@ sg_start_req(Sg_request *srp, unsigned 
  		md = &map_data;
  
  	if (md) {
 -		mutex_lock(&sfp->f_mutex);
 -		if (dxfer_len <= rsv_schp->bufflen &&
 -		    !sfp->res_in_use) {
 -			sfp->res_in_use = 1;
 +		if (!sg_res_in_use(sfp) && dxfer_len <= rsv_schp->bufflen)
  			sg_link_reserve(sfp, srp, dxfer_len);
++<<<<<<< HEAD
 +		else {
++=======
+ 		} else if (hp->flags & SG_FLAG_MMAP_IO) {
+ 			res = -EBUSY; /* sfp->res_in_use == 1 */
+ 			if (dxfer_len > rsv_schp->bufflen)
+ 				res = -ENOMEM;
+ 			mutex_unlock(&sfp->f_mutex);
+ 			return res;
+ 		} else {
++>>>>>>> 8d26f491116f (scsi: sg: recheck MMAP_IO request length with lock held)
  			res = sg_build_indirect(req_schp, sfp, dxfer_len);
 -			if (res) {
 -				mutex_unlock(&sfp->f_mutex);
 +			if (res)
  				return res;
 -			}
  		}
 -		mutex_unlock(&sfp->f_mutex);
  
  		md->pages = req_schp->pages;
  		md->page_order = req_schp->page_order;
* Unmerged path drivers/scsi/sg.c
