x86/bugs: Add ITLB_MULTIHIT bug infrastructure

jira LE-1907
cve CVE-2018-12207
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [x86] Add ITLB_MULTIHIT bug infrastructure (Paolo Bonzini) [1690343] {CVE-2018-12207}
Rebuild_FUZZ: 87.80%
commit-author Vineela Tummalapalli <vineela.tummalapalli@intel.com>
commit db4d30fbb71b47e4ecb11c4efa5d8aad4b03dfae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/db4d30fb.failed

Some processors may incur a machine check error possibly resulting in an
unrecoverable CPU lockup when an instruction fetch encounters a TLB
multi-hit in the instruction TLB. This can occur when the page size is
changed along with either the physical address or cache type. The relevant
erratum can be found here:

   https://bugzilla.kernel.org/show_bug.cgi?id=205195

There are other processors affected for which the erratum does not fully
disclose the impact.

This issue affects both bare-metal x86 page tables and EPT.

It can be mitigated by either eliminating the use of large pages or by
using careful TLB invalidations when changing the page size in the page
tables.

Just like Spectre, Meltdown, L1TF and MDS, a new bit has been allocated in
MSR_IA32_ARCH_CAPABILITIES (PSCHANGE_MC_NO) and will be set on CPUs which
are mitigated against this issue.

	Signed-off-by: Vineela Tummalapalli <vineela.tummalapalli@intel.com>
Co-developed-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
	Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit db4d30fbb71b47e4ecb11c4efa5d8aad4b03dfae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/ABI/testing/sysfs-devices-system-cpu
#	arch/x86/include/asm/cpufeatures.h
#	arch/x86/include/asm/msr-index.h
#	arch/x86/kernel/cpu/bugs.c
#	arch/x86/kernel/cpu/common.c
#	drivers/base/cpu.c
#	include/linux/cpu.h
diff --cc Documentation/ABI/testing/sysfs-devices-system-cpu
index 9853afe5ec40,fc20cde63d1e..000000000000
--- a/Documentation/ABI/testing/sysfs-devices-system-cpu
+++ b/Documentation/ABI/testing/sysfs-devices-system-cpu
@@@ -277,6 -486,8 +277,11 @@@ What:		/sys/devices/system/cpu/vulnerab
  		/sys/devices/system/cpu/vulnerabilities/spec_store_bypass
  		/sys/devices/system/cpu/vulnerabilities/l1tf
  		/sys/devices/system/cpu/vulnerabilities/mds
++<<<<<<< HEAD
++=======
+ 		/sys/devices/system/cpu/vulnerabilities/tsx_async_abort
+ 		/sys/devices/system/cpu/vulnerabilities/itlb_multihit
++>>>>>>> db4d30fbb71b (x86/bugs: Add ITLB_MULTIHIT bug infrastructure)
  Date:		January 2018
  Contact:	Linux kernel mailing list <linux-kernel@vger.kernel.org>
  Description:	Information about CPU vulnerabilities
diff --cc arch/x86/include/asm/cpufeatures.h
index dbaf1dd9cc7a,c4fbe379cc0b..000000000000
--- a/arch/x86/include/asm/cpufeatures.h
+++ b/arch/x86/include/asm/cpufeatures.h
@@@ -358,5 -398,8 +358,11 @@@
  #define X86_BUG_L1TF			X86_BUG(18) /* CPU is affected by L1 Terminal Fault */
  #define X86_BUG_MDS			X86_BUG(19) /* CPU is affected by Microarchitectural data sampling */
  #define X86_BUG_MSBDS_ONLY		X86_BUG(20) /* CPU is only affected by the  MSDBS variant of BUG_MDS */
++<<<<<<< HEAD
++=======
+ #define X86_BUG_SWAPGS			X86_BUG(21) /* CPU is affected by speculation through SWAPGS */
+ #define X86_BUG_TAA			X86_BUG(22) /* CPU is affected by TSX Async Abort(TAA) */
+ #define X86_BUG_ITLB_MULTIHIT		X86_BUG(23) /* CPU may incur MCE during certain page attribute changes */
++>>>>>>> db4d30fbb71b (x86/bugs: Add ITLB_MULTIHIT bug infrastructure)
  
  #endif /* _ASM_X86_CPUFEATURES_H */
diff --cc arch/x86/include/asm/msr-index.h
index 93cf8a6b3d93,6a3124664289..000000000000
--- a/arch/x86/include/asm/msr-index.h
+++ b/arch/x86/include/asm/msr-index.h
@@@ -80,6 -93,18 +80,21 @@@
  						  * Microarchitectural Data
  						  * Sampling (MDS) vulnerabilities.
  						  */
++<<<<<<< HEAD
++=======
+ #define ARCH_CAP_PSCHANGE_MC_NO		BIT(6)	 /*
+ 						  * The processor is not susceptible to a
+ 						  * machine check error due to modifying the
+ 						  * code page size along with either the
+ 						  * physical address or cache type
+ 						  * without TLB invalidation.
+ 						  */
+ #define ARCH_CAP_TSX_CTRL_MSR		BIT(7)	/* MSR for TSX control is available. */
+ #define ARCH_CAP_TAA_NO			BIT(8)	/*
+ 						 * Not susceptible to
+ 						 * TSX Async Abort (TAA) vulnerabilities.
+ 						 */
++>>>>>>> db4d30fbb71b (x86/bugs: Add ITLB_MULTIHIT bug infrastructure)
  
  #define MSR_IA32_FLUSH_CMD		0x0000010b
  #define L1D_FLUSH			BIT(0)	/*
diff --cc arch/x86/kernel/cpu/bugs.c
index 9ec6cfa4f503,5364beda8c61..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -882,9 -1419,14 +882,14 @@@ static ssize_t l1tf_show_state(char *bu
  }
  #endif
  
+ static ssize_t itlb_multihit_show_state(char *buf)
+ {
+ 	return sprintf(buf, "Processor vulnerable\n");
+ }
+ 
  static ssize_t mds_show_state(char *buf)
  {
 -	if (boot_cpu_has(X86_FEATURE_HYPERVISOR)) {
 +	if (x86_hyper) {
  		return sprintf(buf, "%s; SMT Host state unknown\n",
  			       mds_strings[mds_mitigation]);
  	}
@@@ -951,6 -1526,12 +956,15 @@@ static ssize_t cpu_show_common(struct d
  	case X86_BUG_MDS:
  		return mds_show_state(buf);
  
++<<<<<<< HEAD
++=======
+ 	case X86_BUG_TAA:
+ 		return tsx_async_abort_show_state(buf);
+ 
+ 	case X86_BUG_ITLB_MULTIHIT:
+ 		return itlb_multihit_show_state(buf);
+ 
++>>>>>>> db4d30fbb71b (x86/bugs: Add ITLB_MULTIHIT bug infrastructure)
  	default:
  		break;
  	}
@@@ -990,4 -1568,14 +1004,17 @@@ ssize_t cpu_show_mds(struct device *dev
  {
  	return cpu_show_common(dev, attr, buf, X86_BUG_MDS);
  }
++<<<<<<< HEAD
++=======
+ 
+ ssize_t cpu_show_tsx_async_abort(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	return cpu_show_common(dev, attr, buf, X86_BUG_TAA);
+ }
+ 
+ ssize_t cpu_show_itlb_multihit(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	return cpu_show_common(dev, attr, buf, X86_BUG_ITLB_MULTIHIT);
+ }
++>>>>>>> db4d30fbb71b (x86/bugs: Add ITLB_MULTIHIT bug infrastructure)
  #endif
diff --cc arch/x86/kernel/cpu/common.c
index f0257a566938,d29b71ca3ca7..000000000000
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -895,12 -1016,14 +895,23 @@@ static void identify_cpu_without_cpuid(
  #endif
  }
  
++<<<<<<< HEAD
 +#define NO_SPECULATION	BIT(0)
 +#define NO_MELTDOWN	BIT(1)
 +#define NO_SSB		BIT(2)
 +#define NO_L1TF		BIT(3)
 +#define NO_MDS		BIT(4)
 +#define MSBDS_ONLY	BIT(5)
++=======
+ #define NO_SPECULATION		BIT(0)
+ #define NO_MELTDOWN		BIT(1)
+ #define NO_SSB			BIT(2)
+ #define NO_L1TF			BIT(3)
+ #define NO_MDS			BIT(4)
+ #define MSBDS_ONLY		BIT(5)
+ #define NO_SWAPGS		BIT(6)
+ #define NO_ITLB_MULTIHIT	BIT(7)
++>>>>>>> db4d30fbb71b (x86/bugs: Add ITLB_MULTIHIT bug infrastructure)
  
  #define VULNWL(_vendor, _family, _model, _whitelist)	\
  	{ X86_VENDOR_##_vendor, _family, _model, X86_FEATURE_ANY, _whitelist }
@@@ -921,35 -1044,45 +932,71 @@@ static const __initconst struct x86_cpu
  	VULNWL(NSC,	5, X86_MODEL_ANY,	NO_SPECULATION),
  
  	/* Intel Family 6 */
- 	VULNWL_INTEL(ATOM_SALTWELL,		NO_SPECULATION),
- 	VULNWL_INTEL(ATOM_SALTWELL_TABLET,	NO_SPECULATION),
- 	VULNWL_INTEL(ATOM_SALTWELL_MID,		NO_SPECULATION),
- 	VULNWL_INTEL(ATOM_BONNELL,		NO_SPECULATION),
- 	VULNWL_INTEL(ATOM_BONNELL_MID,		NO_SPECULATION),
+ 	VULNWL_INTEL(ATOM_SALTWELL,		NO_SPECULATION | NO_ITLB_MULTIHIT),
+ 	VULNWL_INTEL(ATOM_SALTWELL_TABLET,	NO_SPECULATION | NO_ITLB_MULTIHIT),
+ 	VULNWL_INTEL(ATOM_SALTWELL_MID,		NO_SPECULATION | NO_ITLB_MULTIHIT),
+ 	VULNWL_INTEL(ATOM_BONNELL,		NO_SPECULATION | NO_ITLB_MULTIHIT),
+ 	VULNWL_INTEL(ATOM_BONNELL_MID,		NO_SPECULATION | NO_ITLB_MULTIHIT),
  
++<<<<<<< HEAD
 +	VULNWL_INTEL(ATOM_SILVERMONT,		NO_SSB | NO_L1TF | MSBDS_ONLY),
 +	VULNWL_INTEL(ATOM_SILVERMONT_X,		NO_SSB | NO_L1TF | MSBDS_ONLY),
 +	VULNWL_INTEL(ATOM_SILVERMONT_MID,	NO_SSB | NO_L1TF | MSBDS_ONLY),
 +	VULNWL_INTEL(ATOM_AIRMONT,		NO_SSB | NO_L1TF | MSBDS_ONLY),
 +	VULNWL_INTEL(XEON_PHI_KNL,		NO_SSB | NO_L1TF | MSBDS_ONLY),
 +	VULNWL_INTEL(XEON_PHI_KNM,		NO_SSB | NO_L1TF | MSBDS_ONLY),
 +
 +	VULNWL_INTEL(CORE_YONAH,		NO_SSB),
 +
 +	VULNWL_INTEL(ATOM_AIRMONT_MID,		NO_L1TF | MSBDS_ONLY),
 +
 +	VULNWL_INTEL(ATOM_GOLDMONT,		NO_MDS | NO_L1TF),
 +	VULNWL_INTEL(ATOM_GOLDMONT_X,		NO_MDS | NO_L1TF),
 +	VULNWL_INTEL(ATOM_GOLDMONT_PLUS,	NO_MDS | NO_L1TF),
 +
 +	/* AMD Family 0xf - 0x12 */
 +	VULNWL_AMD(0x0f,	NO_MELTDOWN | NO_SSB | NO_L1TF | NO_MDS),
 +	VULNWL_AMD(0x10,	NO_MELTDOWN | NO_SSB | NO_L1TF | NO_MDS),
 +	VULNWL_AMD(0x11,	NO_MELTDOWN | NO_SSB | NO_L1TF | NO_MDS),
 +	VULNWL_AMD(0x12,	NO_MELTDOWN | NO_SSB | NO_L1TF | NO_MDS),
 +
 +	/* FAMILY_ANY must be last, otherwise 0x0f - 0x12 matches won't work */
 +	VULNWL_AMD(X86_FAMILY_ANY,	NO_MELTDOWN | NO_L1TF | NO_MDS),
++=======
+ 	VULNWL_INTEL(ATOM_SILVERMONT,		NO_SSB | NO_L1TF | MSBDS_ONLY | NO_SWAPGS | NO_ITLB_MULTIHIT),
+ 	VULNWL_INTEL(ATOM_SILVERMONT_D,		NO_SSB | NO_L1TF | MSBDS_ONLY | NO_SWAPGS | NO_ITLB_MULTIHIT),
+ 	VULNWL_INTEL(ATOM_SILVERMONT_MID,	NO_SSB | NO_L1TF | MSBDS_ONLY | NO_SWAPGS | NO_ITLB_MULTIHIT),
+ 	VULNWL_INTEL(ATOM_AIRMONT,		NO_SSB | NO_L1TF | MSBDS_ONLY | NO_SWAPGS | NO_ITLB_MULTIHIT),
+ 	VULNWL_INTEL(XEON_PHI_KNL,		NO_SSB | NO_L1TF | MSBDS_ONLY | NO_SWAPGS | NO_ITLB_MULTIHIT),
+ 	VULNWL_INTEL(XEON_PHI_KNM,		NO_SSB | NO_L1TF | MSBDS_ONLY | NO_SWAPGS | NO_ITLB_MULTIHIT),
+ 
+ 	VULNWL_INTEL(CORE_YONAH,		NO_SSB),
+ 
+ 	VULNWL_INTEL(ATOM_AIRMONT_MID,		NO_L1TF | MSBDS_ONLY | NO_SWAPGS | NO_ITLB_MULTIHIT),
+ 	VULNWL_INTEL(ATOM_AIRMONT_NP,		NO_L1TF | NO_SWAPGS | NO_ITLB_MULTIHIT),
+ 
+ 	VULNWL_INTEL(ATOM_GOLDMONT,		NO_MDS | NO_L1TF | NO_SWAPGS | NO_ITLB_MULTIHIT),
+ 	VULNWL_INTEL(ATOM_GOLDMONT_D,		NO_MDS | NO_L1TF | NO_SWAPGS | NO_ITLB_MULTIHIT),
+ 	VULNWL_INTEL(ATOM_GOLDMONT_PLUS,	NO_MDS | NO_L1TF | NO_SWAPGS | NO_ITLB_MULTIHIT),
+ 
+ 	/*
+ 	 * Technically, swapgs isn't serializing on AMD (despite it previously
+ 	 * being documented as such in the APM).  But according to AMD, %gs is
+ 	 * updated non-speculatively, and the issuing of %gs-relative memory
+ 	 * operands will be blocked until the %gs update completes, which is
+ 	 * good enough for our purposes.
+ 	 */
+ 
+ 	/* AMD Family 0xf - 0x12 */
+ 	VULNWL_AMD(0x0f,	NO_MELTDOWN | NO_SSB | NO_L1TF | NO_MDS | NO_SWAPGS | NO_ITLB_MULTIHIT),
+ 	VULNWL_AMD(0x10,	NO_MELTDOWN | NO_SSB | NO_L1TF | NO_MDS | NO_SWAPGS | NO_ITLB_MULTIHIT),
+ 	VULNWL_AMD(0x11,	NO_MELTDOWN | NO_SSB | NO_L1TF | NO_MDS | NO_SWAPGS | NO_ITLB_MULTIHIT),
+ 	VULNWL_AMD(0x12,	NO_MELTDOWN | NO_SSB | NO_L1TF | NO_MDS | NO_SWAPGS | NO_ITLB_MULTIHIT),
+ 
+ 	/* FAMILY_ANY must be last, otherwise 0x0f - 0x12 matches won't work */
+ 	VULNWL_AMD(X86_FAMILY_ANY,	NO_MELTDOWN | NO_L1TF | NO_MDS | NO_SWAPGS | NO_ITLB_MULTIHIT),
+ 	VULNWL_HYGON(X86_FAMILY_ANY,	NO_MELTDOWN | NO_L1TF | NO_MDS | NO_SWAPGS | NO_ITLB_MULTIHIT),
++>>>>>>> db4d30fbb71b (x86/bugs: Add ITLB_MULTIHIT bug infrastructure)
  	{}
  };
  
@@@ -960,10 -1093,24 +1007,14 @@@ static bool __init cpu_matches(unsigne
  	return m && !!(m->driver_data & which);
  }
  
 -u64 x86_read_arch_cap_msr(void)
 -{
 -	u64 ia32_cap = 0;
 -
 -	if (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES))
 -		rdmsrl(MSR_IA32_ARCH_CAPABILITIES, ia32_cap);
 -
 -	return ia32_cap;
 -}
 -
  static void __init cpu_set_bug_bits(struct cpuinfo_x86 *c)
  {
 -	u64 ia32_cap = x86_read_arch_cap_msr();
 +	u64 ia32_cap = 0;
  
+ 	/* Set ITLB_MULTIHIT bug if cpu is not in the whitelist and not mitigated */
+ 	if (!cpu_matches(NO_ITLB_MULTIHIT) && !(ia32_cap & ARCH_CAP_PSCHANGE_MC_NO))
+ 		setup_force_cpu_bug(X86_BUG_ITLB_MULTIHIT);
+ 
  	if (cpu_matches(NO_SPECULATION))
  		return;
  
diff --cc drivers/base/cpu.c
index 3aa0bee19466,6265871a4af2..000000000000
--- a/drivers/base/cpu.c
+++ b/drivers/base/cpu.c
@@@ -432,12 -554,27 +432,36 @@@ ssize_t __weak cpu_show_mds(struct devi
  	return sprintf(buf, "Not affected\n");
  }
  
++<<<<<<< HEAD
 +static DEVICE_ATTR(meltdown, 0400, cpu_show_meltdown, NULL);
 +static DEVICE_ATTR(spectre_v1, 0400, cpu_show_spectre_v1, NULL);
 +static DEVICE_ATTR(spectre_v2, 0400, cpu_show_spectre_v2, NULL);
 +static DEVICE_ATTR(spec_store_bypass, 0400, cpu_show_spec_store_bypass, NULL);
 +static DEVICE_ATTR(l1tf, 0400, cpu_show_l1tf, NULL);
 +static DEVICE_ATTR(mds, 0400, cpu_show_mds, NULL);
++=======
+ ssize_t __weak cpu_show_tsx_async_abort(struct device *dev,
+ 					struct device_attribute *attr,
+ 					char *buf)
+ {
+ 	return sprintf(buf, "Not affected\n");
+ }
+ 
+ ssize_t __weak cpu_show_itlb_multihit(struct device *dev,
+ 			    struct device_attribute *attr, char *buf)
+ {
+ 	return sprintf(buf, "Not affected\n");
+ }
+ 
+ static DEVICE_ATTR(meltdown, 0444, cpu_show_meltdown, NULL);
+ static DEVICE_ATTR(spectre_v1, 0444, cpu_show_spectre_v1, NULL);
+ static DEVICE_ATTR(spectre_v2, 0444, cpu_show_spectre_v2, NULL);
+ static DEVICE_ATTR(spec_store_bypass, 0444, cpu_show_spec_store_bypass, NULL);
+ static DEVICE_ATTR(l1tf, 0444, cpu_show_l1tf, NULL);
+ static DEVICE_ATTR(mds, 0444, cpu_show_mds, NULL);
+ static DEVICE_ATTR(tsx_async_abort, 0444, cpu_show_tsx_async_abort, NULL);
+ static DEVICE_ATTR(itlb_multihit, 0444, cpu_show_itlb_multihit, NULL);
++>>>>>>> db4d30fbb71b (x86/bugs: Add ITLB_MULTIHIT bug infrastructure)
  
  static struct attribute *cpu_root_vulnerabilities_attrs[] = {
  	&dev_attr_meltdown.attr,
@@@ -446,6 -583,8 +470,11 @@@
  	&dev_attr_spec_store_bypass.attr,
  	&dev_attr_l1tf.attr,
  	&dev_attr_mds.attr,
++<<<<<<< HEAD
++=======
+ 	&dev_attr_tsx_async_abort.attr,
+ 	&dev_attr_itlb_multihit.attr,
++>>>>>>> db4d30fbb71b (x86/bugs: Add ITLB_MULTIHIT bug infrastructure)
  	NULL
  };
  
diff --cc include/linux/cpu.h
index 6fecb3df2476,2a093434e975..000000000000
--- a/include/linux/cpu.h
+++ b/include/linux/cpu.h
@@@ -50,7 -59,16 +50,15 @@@ extern ssize_t cpu_show_l1tf(struct dev
  			     struct device_attribute *attr, char *buf);
  extern ssize_t cpu_show_mds(struct device *dev,
  			    struct device_attribute *attr, char *buf);
++<<<<<<< HEAD
++=======
+ extern ssize_t cpu_show_tsx_async_abort(struct device *dev,
+ 					struct device_attribute *attr,
+ 					char *buf);
+ extern ssize_t cpu_show_itlb_multihit(struct device *dev,
+ 				      struct device_attribute *attr, char *buf);
++>>>>>>> db4d30fbb71b (x86/bugs: Add ITLB_MULTIHIT bug infrastructure)
  
 -extern __printf(4, 5)
 -struct device *cpu_device_create(struct device *parent, void *drvdata,
 -				 const struct attribute_group **groups,
 -				 const char *fmt, ...);
  #ifdef CONFIG_HOTPLUG_CPU
  extern void unregister_cpu(struct cpu *cpu);
  extern ssize_t arch_cpu_probe(const char *, size_t);
* Unmerged path Documentation/ABI/testing/sysfs-devices-system-cpu
* Unmerged path arch/x86/include/asm/cpufeatures.h
* Unmerged path arch/x86/include/asm/msr-index.h
* Unmerged path arch/x86/kernel/cpu/bugs.c
* Unmerged path arch/x86/kernel/cpu/common.c
* Unmerged path drivers/base/cpu.c
* Unmerged path include/linux/cpu.h
