iomap: Fix use-after-free error in page_done callback

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 7a77dad7e3be1280456508841ccdd2a091b1906a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/7a77dad7.failed

In iomap_write_end, we're not holding a page reference anymore when
calling the page_done callback, but the callback needs that reference to
access the page.  To fix that, move the put_page call in
__generic_write_end into the callers of __generic_write_end.  Then, in
iomap_write_end, put the page after calling the page_done callback.

	Reported-by: Jan Kara <jack@suse.cz>
Fixes: 63899c6f8851 ("iomap: add a page_done callback")
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 7a77dad7e3be1280456508841ccdd2a091b1906a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/buffer.c
diff --cc fs/buffer.c
index ccb67909a9cb,0faa41fb4c88..000000000000
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@@ -2087,7 -2104,6 +2087,10 @@@ int __generic_write_end(struct file *fi
  	}
  
  	unlock_page(page);
++<<<<<<< HEAD
 +	page_cache_release(page);
++=======
++>>>>>>> 7a77dad7e3be (iomap: Fix use-after-free error in page_done callback)
  
  	if (old_size < pos)
  		pagecache_isize_extended(inode, old_size, pos);
@@@ -2144,9 -2158,9 +2147,15 @@@ int generic_write_end(struct file *file
  			struct page *page, void *fsdata)
  {
  	copied = block_write_end(file, mapping, pos, len, copied, page, fsdata);
++<<<<<<< HEAD
 +
 +	return __generic_write_end(file, mapping, pos, len, copied, page,
 +				   fsdata);
++=======
+ 	__generic_write_end(mapping->host, pos, copied, page);
+ 	put_page(page);
+ 	return copied;
++>>>>>>> 7a77dad7e3be (iomap: Fix use-after-free error in page_done callback)
  }
  EXPORT_SYMBOL(generic_write_end);
  
* Unmerged path fs/buffer.c
diff --git a/fs/iomap.c b/fs/iomap.c
index b368e069ba43..516486912e46 100644
--- a/fs/iomap.c
+++ b/fs/iomap.c
@@ -195,6 +195,7 @@ iomap_write_end(struct inode *inode, loff_t pos, unsigned len,
 
 	if (iomap->page_done)
 		iomap->page_done(inode, pos, copied, page, iomap);
+	put_page(page);
 
 	if (ret < len)
 		iomap_write_failed(inode, pos, len);
