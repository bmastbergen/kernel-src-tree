scsi: qla2xxx: Add error handling for PLOGI ELS passthrough

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Quinn Tran <qutran@marvell.com>
commit c76ae845ea836d6128982dcbd41ac35c81e2de63
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/c76ae845.failed

Add error handling logic to ELS Passthrough relating to NVME devices.
Current code does not parse error code to take proper recovery action,
instead it re-logins with the same login parameters that encountered the
error. Ex: nport handle collision.

Link: https://lore.kernel.org/r/20190912180918.6436-10-hmadhani@marvell.com
	Signed-off-by: Quinn Tran <qutran@marvell.com>
	Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit c76ae845ea836d6128982dcbd41ac35c81e2de63)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_iocb.c
diff --cc drivers/scsi/qla2xxx/qla_iocb.c
index 347a91c0bc3a,eeb526411536..000000000000
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@@ -2855,14 -2755,99 +2859,105 @@@ qla2x00_els_dcmd2_sp_done(void *ptr, in
  	if (sp->flags & SRB_WAKEUP_ON_COMP)
  		complete(&lio->u.els_plogi.comp);
  	else {
- 		if (res) {
- 			set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
- 		} else {
+ 		switch (fw_status[0]) {
+ 		case CS_DATA_UNDERRUN:
+ 		case CS_COMPLETE:
  			memset(&ea, 0, sizeof(ea));
  			ea.fcport = fcport;
++<<<<<<< HEAD
 +			ea.rc = res;
 +			ea.event = FCME_ELS_PLOGI_DONE;
 +			qla2x00_fcport_event_handler(vha, &ea);
++=======
+ 			ea.data[0] = MBS_COMMAND_COMPLETE;
+ 			ea.sp = sp;
+ 			qla24xx_handle_plogi_done_event(vha, &ea);
+ 			break;
+ 		case CS_IOCB_ERROR:
+ 			switch (fw_status[1]) {
+ 			case LSC_SCODE_PORTID_USED:
+ 				lid = fw_status[2] & 0xffff;
+ 				qlt_find_sess_invalidate_other(vha,
+ 				    wwn_to_u64(fcport->port_name),
+ 				    fcport->d_id, lid, &conflict_fcport);
+ 				if (conflict_fcport) {
+ 					/*
+ 					 * Another fcport shares the same
+ 					 * loop_id & nport id; conflict
+ 					 * fcport needs to finish cleanup
+ 					 * before this fcport can proceed
+ 					 * to login.
+ 					 */
+ 					conflict_fcport->conflict = fcport;
+ 					fcport->login_pause = 1;
+ 					ql_dbg(ql_dbg_disc, vha, 0x20ed,
+ 					    "%s %d %8phC pid %06x inuse with lid %#x post gidpn\n",
+ 					    __func__, __LINE__,
+ 					    fcport->port_name,
+ 					    fcport->d_id.b24, lid);
+ 				} else {
+ 					ql_dbg(ql_dbg_disc, vha, 0x20ed,
+ 					    "%s %d %8phC pid %06x inuse with lid %#x sched del\n",
+ 					    __func__, __LINE__,
+ 					    fcport->port_name,
+ 					    fcport->d_id.b24, lid);
+ 					qla2x00_clear_loop_id(fcport);
+ 					set_bit(lid, vha->hw->loop_id_map);
+ 					fcport->loop_id = lid;
+ 					fcport->keep_nport_handle = 0;
+ 					qlt_schedule_sess_for_deletion(fcport);
+ 				}
+ 				break;
+ 
+ 			case LSC_SCODE_NPORT_USED:
+ 				cid.b.domain = (fw_status[2] >> 16) & 0xff;
+ 				cid.b.area   = (fw_status[2] >>  8) & 0xff;
+ 				cid.b.al_pa  = fw_status[2] & 0xff;
+ 				cid.b.rsvd_1 = 0;
+ 
+ 				ql_dbg(ql_dbg_disc, vha, 0x20ec,
+ 				    "%s %d %8phC lid %#x in use with pid %06x post gnl\n",
+ 				    __func__, __LINE__, fcport->port_name,
+ 				    fcport->loop_id, cid.b24);
+ 				set_bit(fcport->loop_id,
+ 				    vha->hw->loop_id_map);
+ 				fcport->loop_id = FC_NO_LOOP_ID;
+ 				qla24xx_post_gnl_work(vha, fcport);
+ 				break;
+ 
+ 			case LSC_SCODE_NOXCB:
+ 				vha->hw->exch_starvation++;
+ 				if (vha->hw->exch_starvation > 5) {
+ 					ql_log(ql_log_warn, vha, 0xd046,
+ 					    "Exchange starvation. Resetting RISC\n");
+ 					vha->hw->exch_starvation = 0;
+ 					set_bit(ISP_ABORT_NEEDED,
+ 					    &vha->dpc_flags);
+ 					qla2xxx_wake_dpc(vha);
+ 				}
+ 				/* fall through */
+ 			default:
+ 				ql_dbg(ql_dbg_disc, vha, 0x20eb,
+ 				    "%s %8phC cmd error fw_status 0x%x 0x%x 0x%x\n",
+ 				    __func__, sp->fcport->port_name,
+ 				    fw_status[0], fw_status[1], fw_status[2]);
+ 
+ 				fcport->flags &= ~FCF_ASYNC_SENT;
+ 				set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 				break;
+ 			}
+ 			break;
+ 
+ 		default:
+ 			ql_dbg(ql_dbg_disc, vha, 0x20eb,
+ 			    "%s %8phC cmd error 2 fw_status 0x%x 0x%x 0x%x\n",
+ 			    __func__, sp->fcport->port_name,
+ 			    fw_status[0], fw_status[1], fw_status[2]);
+ 
+ 			sp->fcport->flags &= ~FCF_ASYNC_SENT;
+ 			set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 			break;
++>>>>>>> c76ae845ea83 (scsi: qla2xxx: Add error handling for PLOGI ELS passthrough)
  		}
  
  		e = qla2x00_alloc_work(vha, QLA_EVT_UNMAP);
* Unmerged path drivers/scsi/qla2xxx/qla_iocb.c
