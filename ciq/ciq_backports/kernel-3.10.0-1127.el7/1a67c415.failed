CIFS: Fix use after free of file info structures

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Pavel Shilovsky <pshilov@microsoft.com>
commit 1a67c415965752879e2e9fad407bc44fc7f25f23
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/1a67c415.failed

Currently the code assumes that if a file info entry belongs
to lists of open file handles of an inode and a tcon then
it has non-zero reference. The recent changes broke that
assumption when putting the last reference of the file info.
There may be a situation when a file is being deleted but
nothing prevents another thread to reference it again
and start using it. This happens because we do not hold
the inode list lock while checking the number of references
of the file info structure. Fix this by doing the proper
locking when doing the check.

Fixes: 487317c99477d ("cifs: add spinlock for the openFileList to cifsInodeInfo")
Fixes: cb248819d209d ("cifs: use cifsInodeInfo->open_file_lock while iterating to avoid a panic")
	Cc: Stable <stable@vger.kernel.org>
	Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Signed-off-by: Pavel Shilovsky <pshilov@microsoft.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 1a67c415965752879e2e9fad407bc44fc7f25f23)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/file.c
diff --cc fs/cifs/file.c
index 2bf5f443b3da,64827938ecf7..000000000000
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@@ -398,10 -422,9 +399,13 @@@ void cifsFileInfo_put(struct cifsFileIn
  	cifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);
  
  	/* remove it from the lists */
++<<<<<<< HEAD
 +	spin_lock(&cifs_list_lock);
++=======
++>>>>>>> 1a67c4159657 (CIFS: Fix use after free of file info structures)
  	list_del(&cifs_file->flist);
  	list_del(&cifs_file->tlist);
 -	atomic_dec(&tcon->num_local_opens);
 +	spin_unlock(&cifs_list_lock);
  
  	if (list_empty(&cifsi->openFileList)) {
  		cifs_dbg(FYI, "closing last open instance for inode %p\n",
@@@ -416,9 -439,11 +420,10 @@@
  		cifs_set_oplock_level(cifsi, 0);
  	}
  
+ 	spin_unlock(&cifsi->open_file_lock);
  	spin_unlock(&tcon->open_file_lock);
  
 -	oplock_break_cancelled = wait_oplock_handler ?
 -		cancel_work_sync(&cifs_file->oplock_break) : false;
 +	oplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);
  
  	if (!tcon->need_reconnect && !cifs_file->invalidHandle) {
  		struct TCP_Server_Info *server = tcon->ses->server;
* Unmerged path fs/cifs/file.c
