cifs: use cifsInodeInfo->open_file_lock while iterating to avoid a panic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [fs] revert "[fs] cifs: use cifsInodeInfo->open_file_lock while iterating to avoid a panic (Dave Wysochanski) [1757872]
Rebuild_FUZZ: 94.74%
commit-author Dave Wysochanski <dwysocha@redhat.com>
commit cb248819d209d113e45fed459773991518e8e80b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/cb248819.failed

Commit 487317c99477 ("cifs: add spinlock for the openFileList to
cifsInodeInfo") added cifsInodeInfo->open_file_lock spin_lock to protect
the openFileList, but missed a few places where cifs_inode->openFileList
was enumerated.  Change these remaining tcon->open_file_lock to
cifsInodeInfo->open_file_lock to avoid panic in is_size_safe_to_change.

[17313.245641] RIP: 0010:is_size_safe_to_change+0x57/0xb0 [cifs]
[17313.245645] Code: 68 40 48 89 ef e8 19 67 b7 f1 48 8b 43 40 48 8d 4b 40 48 8d 50 f0 48 39 c1 75 0f eb 47 48 8b 42 10 48 8d 50 f0 48 39 c1 74 3a <8b> 80 88 00 00 00 83 c0 01 a8 02 74 e6 48 89 ef c6 07 00 0f 1f 40
[17313.245649] RSP: 0018:ffff94ae1baefa30 EFLAGS: 00010202
[17313.245654] RAX: dead000000000100 RBX: ffff88dc72243300 RCX: ffff88dc72243340
[17313.245657] RDX: dead0000000000f0 RSI: 00000000098f7940 RDI: ffff88dd3102f040
[17313.245659] RBP: ffff88dd3102f040 R08: 0000000000000000 R09: ffff94ae1baefc40
[17313.245661] R10: ffffcdc8bb1c4e80 R11: ffffcdc8b50adb08 R12: 00000000098f7940
[17313.245663] R13: ffff88dc72243300 R14: ffff88dbc8f19600 R15: ffff88dc72243428
[17313.245667] FS:  00007fb145485700(0000) GS:ffff88dd3e000000(0000) knlGS:0000000000000000
[17313.245670] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[17313.245672] CR2: 0000026bb46c6000 CR3: 0000004edb110003 CR4: 00000000007606e0
[17313.245753] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[17313.245756] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[17313.245759] PKRU: 55555554
[17313.245761] Call Trace:
[17313.245803]  cifs_fattr_to_inode+0x16b/0x580 [cifs]
[17313.245838]  cifs_get_inode_info+0x35c/0xa60 [cifs]
[17313.245852]  ? kmem_cache_alloc_trace+0x151/0x1d0
[17313.245885]  cifs_open+0x38f/0x990 [cifs]
[17313.245921]  ? cifs_revalidate_dentry_attr+0x3e/0x350 [cifs]
[17313.245953]  ? cifsFileInfo_get+0x30/0x30 [cifs]
[17313.245960]  ? do_dentry_open+0x132/0x330
[17313.245963]  do_dentry_open+0x132/0x330
[17313.245969]  path_openat+0x573/0x14d0
[17313.245974]  do_filp_open+0x93/0x100
[17313.245979]  ? __check_object_size+0xa3/0x181
[17313.245986]  ? audit_alloc_name+0x7e/0xd0
[17313.245992]  do_sys_open+0x184/0x220
[17313.245999]  do_syscall_64+0x5b/0x1b0

Fixes: 487317c99477 ("cifs: add spinlock for the openFileList to cifsInodeInfo")

CC: Stable <stable@vger.kernel.org>
	Signed-off-by: Dave Wysochanski <dwysocha@redhat.com>
	Reviewed-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit cb248819d209d113e45fed459773991518e8e80b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/file.c
diff --cc fs/cifs/file.c
index 2bf5f443b3da,3758237bf951..000000000000
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@@ -1841,14 -1876,17 +1840,13 @@@ struct cifsFileInfo *find_writable_file
  {
  	struct cifsFileInfo *open_file, *inv_file = NULL;
  	struct cifs_sb_info *cifs_sb;
- 	struct cifs_tcon *tcon;
  	bool any_available = false;
 -	int rc = -EBADF;
 +	int rc;
  	unsigned int refind = 0;
  
 -	*ret_file = NULL;
 -
 -	/*
 -	 * Having a null inode here (because mapping->host was set to zero by
 -	 * the VFS or MM) should not happen but we had reports of on oops (due
 -	 * to it being zero) during stress testcases so we need to check for it
 -	 */
 +	/* Having a null inode here (because mapping->host was set to zero by
 +	the VFS or MM) should not happen but we had reports of on oops (due to
 +	it being zero) during stress testcases so we need to check for it */
  
  	if (cifs_inode == NULL) {
  		cifs_dbg(VFS, "Null inode passed to cifs_writeable_file\n");
@@@ -1863,11 -1900,11 +1860,16 @@@
  	if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))
  		fsuid_only = false;
  
- 	spin_lock(&tcon->open_file_lock);
+ 	spin_lock(&cifs_inode->open_file_lock);
  refind_writable:
  	if (refind > MAX_REOPEN_ATT) {
++<<<<<<< HEAD
 +		spin_unlock(&tcon->open_file_lock);
 +		return NULL;
++=======
+ 		spin_unlock(&cifs_inode->open_file_lock);
+ 		return rc;
++>>>>>>> cb248819d209 (cifs: use cifsInodeInfo->open_file_lock while iterating to avoid a panic)
  	}
  	list_for_each_entry(open_file, &cifs_inode->openFileList, flist) {
  		if (!any_available && open_file->pid != current->tgid)
@@@ -1878,8 -1915,9 +1880,14 @@@
  			if (!open_file->invalidHandle) {
  				/* found a good writable file */
  				cifsFileInfo_get(open_file);
++<<<<<<< HEAD
 +				spin_unlock(&tcon->open_file_lock);
 +				return open_file;
++=======
+ 				spin_unlock(&cifs_inode->open_file_lock);
+ 				*ret_file = open_file;
+ 				return 0;
++>>>>>>> cb248819d209 (cifs: use cifsInodeInfo->open_file_lock while iterating to avoid a panic)
  			} else {
  				if (!inv_file)
  					inv_file = open_file;
@@@ -1901,24 -1939,106 +1909,75 @@@
  
  	if (inv_file) {
  		rc = cifs_reopen_file(inv_file, false);
++<<<<<<< HEAD
 +		if (!rc)
 +			return inv_file;
 +		else {
 +			spin_lock(&tcon->open_file_lock);
 +			spin_lock(&cifs_list_lock);
 +			list_move_tail(&inv_file->flist,
 +					&cifs_inode->openFileList);
 +			spin_unlock(&cifs_list_lock);
++=======
+ 		if (!rc) {
+ 			*ret_file = inv_file;
+ 			return 0;
+ 		}
+ 
+ 		spin_lock(&cifs_inode->open_file_lock);
+ 		list_move_tail(&inv_file->flist, &cifs_inode->openFileList);
+ 		spin_unlock(&cifs_inode->open_file_lock);
+ 		cifsFileInfo_put(inv_file);
+ 		++refind;
+ 		inv_file = NULL;
+ 		spin_lock(&cifs_inode->open_file_lock);
+ 		goto refind_writable;
+ 	}
+ 
+ 	return rc;
+ }
+ 
+ struct cifsFileInfo *
+ find_writable_file(struct cifsInodeInfo *cifs_inode, bool fsuid_only)
+ {
+ 	struct cifsFileInfo *cfile;
+ 	int rc;
+ 
+ 	rc = cifs_get_writable_file(cifs_inode, fsuid_only, &cfile);
+ 	if (rc)
+ 		cifs_dbg(FYI, "couldn't find writable handle rc=%d", rc);
+ 
+ 	return cfile;
+ }
+ 
+ int
+ cifs_get_writable_path(struct cifs_tcon *tcon, const char *name,
+ 		       struct cifsFileInfo **ret_file)
+ {
+ 	struct list_head *tmp;
+ 	struct cifsFileInfo *cfile;
+ 	struct cifsInodeInfo *cinode;
+ 	char *full_path;
+ 
+ 	*ret_file = NULL;
+ 
+ 	spin_lock(&tcon->open_file_lock);
+ 	list_for_each(tmp, &tcon->openFileList) {
+ 		cfile = list_entry(tmp, struct cifsFileInfo,
+ 			     tlist);
+ 		full_path = build_path_from_dentry(cfile->dentry);
+ 		if (full_path == NULL) {
++>>>>>>> cb248819d209 (cifs: use cifsInodeInfo->open_file_lock while iterating to avoid a panic)
  			spin_unlock(&tcon->open_file_lock);
 -			return -ENOMEM;
 -		}
 -		if (strcmp(full_path, name)) {
 -			kfree(full_path);
 -			continue;
 -		}
 -
 -		kfree(full_path);
 -		cinode = CIFS_I(d_inode(cfile->dentry));
 -		spin_unlock(&tcon->open_file_lock);
 -		return cifs_get_writable_file(cinode, 0, ret_file);
 -	}
 -
 -	spin_unlock(&tcon->open_file_lock);
 -	return -ENOENT;
 -}
 -
 -int
 -cifs_get_readable_path(struct cifs_tcon *tcon, const char *name,
 -		       struct cifsFileInfo **ret_file)
 -{
 -	struct list_head *tmp;
 -	struct cifsFileInfo *cfile;
 -	struct cifsInodeInfo *cinode;
 -	char *full_path;
 -
 -	*ret_file = NULL;
 -
 -	spin_lock(&tcon->open_file_lock);
 -	list_for_each(tmp, &tcon->openFileList) {
 -		cfile = list_entry(tmp, struct cifsFileInfo,
 -			     tlist);
 -		full_path = build_path_from_dentry(cfile->dentry);
 -		if (full_path == NULL) {
 -			spin_unlock(&tcon->open_file_lock);
 -			return -ENOMEM;
 -		}
 -		if (strcmp(full_path, name)) {
 -			kfree(full_path);
 -			continue;
 +			cifsFileInfo_put(inv_file);
 +			++refind;
 +			inv_file = NULL;
 +			spin_lock(&tcon->open_file_lock);
 +			goto refind_writable;
  		}
 -
 -		kfree(full_path);
 -		cinode = CIFS_I(d_inode(cfile->dentry));
 -		spin_unlock(&tcon->open_file_lock);
 -		*ret_file = find_readable_file(cinode, 0);
 -		return *ret_file ? 0 : -ENOENT;
  	}
  
 -	spin_unlock(&tcon->open_file_lock);
 -	return -ENOENT;
 +	return NULL;
  }
  
  static int cifs_partialpagewrite(struct page *page, unsigned from, unsigned to)
* Unmerged path fs/cifs/file.c
