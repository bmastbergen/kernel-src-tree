governors: unify last_state_idx

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Marcelo Tosatti <mtosatti@redhat.com>
commit 7d4daeedd575bbc3c40c87fc6708a8b88c50fe7e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/7d4daeed.failed

Since this field is shared by all governors, move it to
cpuidle device structure.

	Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 7d4daeedd575bbc3c40c87fc6708a8b88c50fe7e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpuidle/governors/ladder.c
#	drivers/cpuidle/governors/menu.c
#	drivers/cpuidle/governors/teo.c
diff --cc drivers/cpuidle/governors/ladder.c
index 6e914d072f88,428eeb832fe7..000000000000
--- a/drivers/cpuidle/governors/ladder.c
+++ b/drivers/cpuidle/governors/ladder.c
@@@ -62,14 -61,16 +62,20 @@@ static inline void ladder_do_selection(
   * ladder_select_state - selects the next state to enter
   * @drv: cpuidle driver
   * @dev: the CPU
 - * @dummy: not used
   */
  static int ladder_select_state(struct cpuidle_driver *drv,
 -			       struct cpuidle_device *dev, bool *dummy)
 +				struct cpuidle_device *dev)
  {
 -	struct ladder_device *ldev = this_cpu_ptr(&ladder_devices);
 +	struct ladder_device *ldev = &__get_cpu_var(ladder_devices);
  	struct ladder_device_state *last_state;
++<<<<<<< HEAD
 +	int last_residency, last_idx = ldev->last_state_idx;
 +	int latency_req = pm_qos_request(PM_QOS_CPU_DMA_LATENCY);
++=======
+ 	int last_residency, last_idx = dev->last_state_idx;
+ 	int first_idx = drv->states[0].flags & CPUIDLE_FLAG_POLLING ? 1 : 0;
+ 	int latency_req = cpuidle_governor_latency_req(dev->cpu);
++>>>>>>> 7d4daeedd575 (governors: unify last_state_idx)
  
  	/* Special case when user has set very strict latency requirement */
  	if (unlikely(latency_req == 0)) {
@@@ -142,9 -139,9 +148,13 @@@ static int ladder_enable_device(struct 
  	struct ladder_device_state *lstate;
  	struct cpuidle_state *state;
  
++<<<<<<< HEAD
 +	ldev->last_state_idx = CPUIDLE_DRIVER_STATE_START;
++=======
+ 	dev->last_state_idx = first_idx;
++>>>>>>> 7d4daeedd575 (governors: unify last_state_idx)
  
 -	for (i = first_idx; i < drv->state_count; i++) {
 +	for (i = 0; i < drv->state_count; i++) {
  		state = &drv->states[i];
  		lstate = &ldev->states[i];
  
@@@ -170,9 -167,8 +180,12 @@@
   */
  static void ladder_reflect(struct cpuidle_device *dev, int index)
  {
++<<<<<<< HEAD
 +	struct ladder_device *ldev = &__get_cpu_var(ladder_devices);
++=======
++>>>>>>> 7d4daeedd575 (governors: unify last_state_idx)
  	if (index > 0)
- 		ldev->last_state_idx = index;
+ 		dev->last_state_idx = index;
  }
  
  static struct cpuidle_governor ladder_governor = {
diff --cc drivers/cpuidle/governors/menu.c
index c99fee9880b7,dace4c7f830c..000000000000
--- a/drivers/cpuidle/governors/menu.c
+++ b/drivers/cpuidle/governors/menu.c
@@@ -110,15 -117,13 +110,14 @@@
   */
  
  struct menu_device {
- 	int		last_state_idx;
  	int             needs_update;
 -	int             tick_wakeup;
  
 -	unsigned int	next_timer_us;
 +	unsigned int	expected_us;
 +	u64		predicted_us;
 +	unsigned int	exit_us;
  	unsigned int	bucket;
 -	unsigned int	correction_factor[BUCKETS];
 -	unsigned int	intervals[INTERVALS];
 +	u64		correction_factor[BUCKETS];
 +	u32		intervals[INTERVALS];
  	int		interval_ptr;
  };
  
@@@ -346,10 -452,11 +345,18 @@@ static int menu_select(struct cpuidle_d
   */
  static void menu_reflect(struct cpuidle_device *dev, int index)
  {
++<<<<<<< HEAD
 +	struct menu_device *data = &__get_cpu_var(menu_devices);
 +	data->last_state_idx = index;
 +	if (index >= 0)
 +		data->needs_update = 1;
++=======
+ 	struct menu_device *data = this_cpu_ptr(&menu_devices);
+ 
+ 	dev->last_state_idx = index;
+ 	data->needs_update = 1;
+ 	data->tick_wakeup = tick_nohz_idle_got_tick();
++>>>>>>> 7d4daeedd575 (governors: unify last_state_idx)
  }
  
  /**
@@@ -359,39 -466,69 +366,44 @@@
   */
  static void menu_update(struct cpuidle_driver *drv, struct cpuidle_device *dev)
  {
++<<<<<<< HEAD
 +	struct menu_device *data = &__get_cpu_var(menu_devices);
 +	int last_idx = data->last_state_idx;
 +	unsigned int last_idle_us = cpuidle_get_last_residency(dev);
++=======
+ 	struct menu_device *data = this_cpu_ptr(&menu_devices);
+ 	int last_idx = dev->last_state_idx;
++>>>>>>> 7d4daeedd575 (governors: unify last_state_idx)
  	struct cpuidle_state *target = &drv->states[last_idx];
  	unsigned int measured_us;
 -	unsigned int new_factor;
 +	u64 new_factor;
  
  	/*
 -	 * Try to figure out how much time passed between entry to low
 -	 * power state and occurrence of the wakeup event.
 -	 *
 -	 * If the entered idle state didn't support residency measurements,
 -	 * we use them anyway if they are short, and if long,
 -	 * truncate to the whole expected time.
 -	 *
 -	 * Any measured amount of time will include the exit latency.
 -	 * Since we are interested in when the wakeup begun, not when it
 -	 * was completed, we must subtract the exit latency. However, if
 -	 * the measured amount of time is less than the exit latency,
 -	 * assume the state was never reached and the exit latency is 0.
 +	 * Ugh, this idle state doesn't support residency measurements, so we
 +	 * are basically lost in the dark.  As a compromise, assume we slept
 +	 * for the whole expected time.
  	 */
 +	if (unlikely(target->flags & CPUIDLE_FLAG_TIME_INVALID))
 +		last_idle_us = data->expected_us;
 +
 +
 +	measured_us = last_idle_us;
 +
 +	/*
 +	 * We correct for the exit latency; we are assuming here that the
 +	 * exit latency happens after the event that we're interested in.
 +	 */
 +	if (measured_us > data->exit_us)
 +		measured_us -= data->exit_us;
  
 -	if (data->tick_wakeup && data->next_timer_us > TICK_USEC) {
 -		/*
 -		 * The nohz code said that there wouldn't be any events within
 -		 * the tick boundary (if the tick was stopped), but the idle
 -		 * duration predictor had a differing opinion.  Since the CPU
 -		 * was woken up by a tick (that wasn't stopped after all), the
 -		 * predictor was not quite right, so assume that the CPU could
 -		 * have been idle long (but not forever) to help the idle
 -		 * duration predictor do a better job next time.
 -		 */
 -		measured_us = 9 * MAX_INTERESTING / 10;
 -	} else if ((drv->states[last_idx].flags & CPUIDLE_FLAG_POLLING) &&
 -		   dev->poll_time_limit) {
 -		/*
 -		 * The CPU exited the "polling" state due to a time limit, so
 -		 * the idle duration prediction leading to the selection of that
 -		 * state was inaccurate.  If a better prediction had been made,
 -		 * the CPU might have been woken up from idle by the next timer.
 -		 * Assume that to be the case.
 -		 */
 -		measured_us = data->next_timer_us;
 -	} else {
 -		/* measured value */
 -		measured_us = dev->last_residency;
 -
 -		/* Deduct exit latency */
 -		if (measured_us > 2 * target->exit_latency)
 -			measured_us -= target->exit_latency;
 -		else
 -			measured_us /= 2;
 -	}
  
 -	/* Make sure our coefficients do not exceed unity */
 -	if (measured_us > data->next_timer_us)
 -		measured_us = data->next_timer_us;
 +	/* update our correction ratio */
  
 -	/* Update our correction ratio */
 -	new_factor = data->correction_factor[data->bucket];
 -	new_factor -= new_factor / DECAY;
 +	new_factor = data->correction_factor[data->bucket]
 +			* (DECAY - 1) / DECAY;
  
 -	if (data->next_timer_us > 0 && measured_us < MAX_INTERESTING)
 -		new_factor += RESOLUTION * measured_us / data->next_timer_us;
 +	if (data->expected_us > 0 && measured_us < MAX_INTERESTING)
 +		new_factor += RESOLUTION * measured_us / data->expected_us;
  	else
  		/*
  		 * we were idle so long that we count it as a perfect
* Unmerged path drivers/cpuidle/governors/teo.c
* Unmerged path drivers/cpuidle/governors/ladder.c
* Unmerged path drivers/cpuidle/governors/menu.c
* Unmerged path drivers/cpuidle/governors/teo.c
diff --git a/include/linux/cpuidle.h b/include/linux/cpuidle.h
index 9bd9bae0c305..14b5f14ee8c5 100644
--- a/include/linux/cpuidle.h
+++ b/include/linux/cpuidle.h
@@ -66,6 +66,7 @@ struct cpuidle_device {
 	unsigned int		enabled:1;
 	unsigned int		cpu;
 
+	int			last_state_idx;
 	int			last_residency;
 	int			state_count;
 	struct cpuidle_state_usage	states_usage[CPUIDLE_STATE_MAX];
