s390/ptrace: run seccomp after ptrace

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Kees Cook <keescook@chromium.org>
commit 0208b9445bc031791e589c334a93365cbad008fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/0208b944.failed

Close the hole where ptrace can change a syscall out from under seccomp.

	Signed-off-by: Kees Cook <keescook@chromium.org>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Cc: linux-s390@vger.kernel.org
(cherry picked from commit 0208b9445bc031791e589c334a93365cbad008fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kernel/ptrace.c
diff --cc arch/s390/kernel/ptrace.c
index 8ac3240d6fb5,cea17010448f..000000000000
--- a/arch/s390/kernel/ptrace.c
+++ b/arch/s390/kernel/ptrace.c
@@@ -860,16 -821,6 +860,19 @@@ long compat_arch_ptrace(struct task_str
  
  asmlinkage long do_syscall_trace_enter(struct pt_regs *regs)
  {
++<<<<<<< HEAD
 +	long ret = 0;
 +	unsigned long mask = -1UL;
 +
 +	/* Do the secure computing check first. */
 +	if (secure_computing()) {
 +		/* seccomp failures shouldn't expose any additional code. */
 +		ret = -1;
 +		goto out;
 +	}
 +
++=======
++>>>>>>> 0208b9445bc0 (s390/ptrace: run seccomp after ptrace)
  	/*
  	 * The sysc_tracesys code in entry.S stored the system
  	 * call number to gprs[2].
@@@ -882,21 -833,24 +885,40 @@@
  		 * debugger stored an invalid system call number. Skip
  		 * the system call and the system call restart handling.
  		 */
++<<<<<<< HEAD
 +		clear_thread_flag(TIF_SYSCALL);
 +		ret = -1;
++=======
+ 		clear_pt_regs_flag(regs, PIF_SYSCALL);
+ 		return -1;
+ 	}
+ 
+ 	/* Do the secure computing check after ptrace. */
+ 	if (secure_computing(NULL)) {
+ 		/* seccomp failures shouldn't expose any additional code. */
+ 		return -1;
++>>>>>>> 0208b9445bc0 (s390/ptrace: run seccomp after ptrace)
  	}
  
  	if (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))
  		trace_sys_enter(regs, regs->gprs[2]);
  
++<<<<<<< HEAD
 +	if (is_compat_task())
 +		mask = 0xffffffff;
 +
 +	audit_syscall_entry(regs->gprs[2], regs->orig_gpr2 & mask,
 +			    regs->gprs[3] & mask, regs->gprs[4] & mask,
 +			    regs->gprs[5] & mask);
 +out:
 +	return ret ?: regs->gprs[2];
++=======
+ 	audit_syscall_entry(regs->gprs[2], regs->orig_gpr2,
+ 			    regs->gprs[3], regs->gprs[4],
+ 			    regs->gprs[5]);
+ 
+ 	return regs->gprs[2];
++>>>>>>> 0208b9445bc0 (s390/ptrace: run seccomp after ptrace)
  }
  
  asmlinkage void do_syscall_trace_exit(struct pt_regs *regs)
* Unmerged path arch/s390/kernel/ptrace.c
