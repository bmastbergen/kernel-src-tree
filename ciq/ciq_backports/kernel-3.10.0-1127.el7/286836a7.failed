x86/cpu: Add a helper function x86_read_arch_cap_msr()

jira LE-1907
cve CVE-2019-11135
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
commit 286836a70433fb64131d2590f4bf512097c255e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/286836a7.failed

Add a helper function to read the IA32_ARCH_CAPABILITIES MSR.

	Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Tested-by: Neelima Krishnan <neelima.krishnan@intel.com>
	Reviewed-by: Mark Gross <mgross@linux.intel.com>
	Reviewed-by: Tony Luck <tony.luck@intel.com>
	Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>

(cherry picked from commit 286836a70433fb64131d2590f4bf512097c255e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/cpu.h
diff --cc arch/x86/kernel/cpu/cpu.h
index c7ea4cc38e10,a5cd0eba2746..000000000000
--- a/arch/x86/kernel/cpu/cpu.h
+++ b/arch/x86/kernel/cpu/cpu.h
@@@ -42,7 -45,23 +42,18 @@@ extern const struct cpu_dev *const __x8
  			    *const __x86_cpu_dev_end[];
  
  extern void get_cpu_cap(struct cpuinfo_x86 *c);
 -extern void get_cpu_address_sizes(struct cpuinfo_x86 *c);
  extern void cpu_detect_cache_sizes(struct cpuinfo_x86 *c);
 -extern void init_scattered_cpuid_features(struct cpuinfo_x86 *c);
 -extern void init_intel_cacheinfo(struct cpuinfo_x86 *c);
 -extern void init_amd_cacheinfo(struct cpuinfo_x86 *c);
 -extern void init_hygon_cacheinfo(struct cpuinfo_x86 *c);
 -
 -extern void detect_num_cpu_cores(struct cpuinfo_x86 *c);
  extern int detect_extended_topology_early(struct cpuinfo_x86 *c);
 -extern int detect_extended_topology(struct cpuinfo_x86 *c);
  extern int detect_ht_early(struct cpuinfo_x86 *c);
++<<<<<<< HEAD
++=======
+ extern void detect_ht(struct cpuinfo_x86 *c);
+ 
+ unsigned int aperfmperf_get_khz(int cpu);
+ 
+ extern void x86_spec_ctrl_setup_ap(void);
+ 
+ extern u64 x86_read_arch_cap_msr(void);
+ 
++>>>>>>> 286836a70433 (x86/cpu: Add a helper function x86_read_arch_cap_msr())
  #endif /* ARCH_X86_CPU_H */
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index 0591d15edb0a..8615d06b84a4 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -962,19 +962,26 @@ static bool __init cpu_matches(unsigned long which)
 	return m && !!(m->driver_data & which);
 }
 
-static void __init cpu_set_bug_bits(struct cpuinfo_x86 *c)
+u64 x86_read_arch_cap_msr(void)
 {
 	u64 ia32_cap = 0;
 
+	if (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES))
+		rdmsrl(MSR_IA32_ARCH_CAPABILITIES, ia32_cap);
+
+	return ia32_cap;
+}
+
+static void __init cpu_set_bug_bits(struct cpuinfo_x86 *c)
+{
+	u64 ia32_cap = x86_read_arch_cap_msr();
+
 	if (cpu_matches(NO_SPECULATION))
 		return;
 
 	setup_force_cpu_bug(X86_BUG_SPECTRE_V1);
 	setup_force_cpu_bug(X86_BUG_SPECTRE_V2);
 
-	if (cpu_has(c, X86_FEATURE_ARCH_CAPABILITIES))
-		rdmsrl(MSR_IA32_ARCH_CAPABILITIES, ia32_cap);
-
 	if (!cpu_matches(NO_SSB) && !(ia32_cap & ARCH_CAP_SSB_NO) &&
 	   !cpu_has(c, X86_FEATURE_AMD_SSB_NO))
 		setup_force_cpu_bug(X86_BUG_SPEC_STORE_BYPASS);
* Unmerged path arch/x86/kernel/cpu/cpu.h
