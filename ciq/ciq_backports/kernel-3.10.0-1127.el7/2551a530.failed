xfs: explicitly pass buffer size to xfs_corruption_error

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 2551a53053de52993be8752731f084fad3cfc4d8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/2551a530.failed

Explicitly pass the buffer length to xfs_corruption_error() instead of
assuming XFS_CORRUPTION_DUMP_LEN so that we avoid dumping off the end
of the buffer.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit 2551a53053de52993be8752731f084fad3cfc4d8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_dir2_data.c
#	fs/xfs/libxfs/xfs_dir2_leaf.c
#	fs/xfs/libxfs/xfs_dir2_node.c
#	fs/xfs/xfs_error.c
#	fs/xfs/xfs_error.h
diff --cc fs/xfs/libxfs/xfs_dir2_data.c
index 14eb9e9f3cfd,c672846a0303..000000000000
--- a/fs/xfs/libxfs/xfs_dir2_data.c
+++ b/fs/xfs/libxfs/xfs_dir2_data.c
@@@ -211,17 -229,35 +211,39 @@@ __xfs_dir3_data_check
  				stale++;
  			if (i > 0 && be32_to_cpu(lep[i].hashval) <
  				     be32_to_cpu(lep[i - 1].hashval))
 -				return __this_address;
 +				return false;
  		}
  		if (count != be32_to_cpu(btp->count) - be32_to_cpu(btp->stale))
 -			return __this_address;
 +			return false;
  		if (stale != be32_to_cpu(btp->stale))
 -			return __this_address;
 +			return false;
  	}
 -	return NULL;
 +	return true;
  }
  
++<<<<<<< HEAD
 +static bool
++=======
+ #ifdef DEBUG
+ void
+ xfs_dir3_data_check(
+ 	struct xfs_inode	*dp,
+ 	struct xfs_buf		*bp)
+ {
+ 	xfs_failaddr_t		fa;
+ 
+ 	fa = __xfs_dir3_data_check(dp, bp);
+ 	if (!fa)
+ 		return;
+ 	xfs_corruption_error(__func__, XFS_ERRLEVEL_LOW, dp->i_mount,
+ 			bp->b_addr, BBTOB(bp->b_length), __FILE__, __LINE__,
+ 			fa);
+ 	ASSERT(0);
+ }
+ #endif
+ 
+ static xfs_failaddr_t
++>>>>>>> 2551a53053de (xfs: explicitly pass buffer size to xfs_corruption_error)
  xfs_dir3_data_verify(
  	struct xfs_buf		*bp)
  {
@@@ -1110,6 -1158,24 +1132,6 @@@ xfs_dir2_data_use_free
  	return 0;
  corrupt:
  	xfs_corruption_error(__func__, XFS_ERRLEVEL_LOW, args->dp->i_mount,
- 			hdr, __FILE__, __LINE__, fa);
+ 			hdr, sizeof(*hdr), __FILE__, __LINE__, fa);
  	return -EFSCORRUPTED;
  }
 -
 -/* Find the end of the entry data in a data/block format dir block. */
 -void *
 -xfs_dir3_data_endp(
 -	struct xfs_da_geometry		*geo,
 -	struct xfs_dir2_data_hdr	*hdr)
 -{
 -	switch (hdr->magic) {
 -	case cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):
 -	case cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):
 -		return xfs_dir2_block_leaf_p(xfs_dir2_block_tail_p(geo, hdr));
 -	case cpu_to_be32(XFS_DIR3_DATA_MAGIC):
 -	case cpu_to_be32(XFS_DIR2_DATA_MAGIC):
 -		return (char *)hdr + geo->blksize;
 -	default:
 -		return NULL;
 -	}
 -}
diff --cc fs/xfs/libxfs/xfs_dir2_leaf.c
index 91ad5da54309,77240f4de0e0..000000000000
--- a/fs/xfs/libxfs/xfs_dir2_leaf.c
+++ b/fs/xfs/libxfs/xfs_dir2_leaf.c
@@@ -75,6 -69,22 +75,25 @@@ xfs_dir3_leaf1_check
  
  	return xfs_dir3_leaf_check_int(dp->i_mount, dp, &leafhdr, leaf);
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline void
+ xfs_dir3_leaf_check(
+ 	struct xfs_inode	*dp,
+ 	struct xfs_buf		*bp)
+ {
+ 	xfs_failaddr_t		fa;
+ 
+ 	fa = xfs_dir3_leaf1_check(dp, bp);
+ 	if (!fa)
+ 		return;
+ 	xfs_corruption_error(__func__, XFS_ERRLEVEL_LOW, dp->i_mount,
+ 			bp->b_addr, BBTOB(bp->b_length), __FILE__, __LINE__,
+ 			fa);
+ 	ASSERT(0);
+ }
++>>>>>>> 2551a53053de (xfs: explicitly pass buffer size to xfs_corruption_error)
  #else
  #define	xfs_dir3_leaf_check(dp, bp)
  #endif
diff --cc fs/xfs/libxfs/xfs_dir2_node.c
index 0e9a3f6c334b,a5e7d9bd7552..000000000000
--- a/fs/xfs/libxfs/xfs_dir2_node.c
+++ b/fs/xfs/libxfs/xfs_dir2_node.c
@@@ -78,6 -72,22 +78,25 @@@ xfs_dir3_leafn_check
  
  	return xfs_dir3_leaf_check_int(dp->i_mount, dp, &leafhdr, leaf);
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline void
+ xfs_dir3_leaf_check(
+ 	struct xfs_inode	*dp,
+ 	struct xfs_buf		*bp)
+ {
+ 	xfs_failaddr_t		fa;
+ 
+ 	fa = xfs_dir3_leafn_check(dp, bp);
+ 	if (!fa)
+ 		return;
+ 	xfs_corruption_error(__func__, XFS_ERRLEVEL_LOW, dp->i_mount,
+ 			bp->b_addr, BBTOB(bp->b_length), __FILE__, __LINE__,
+ 			fa);
+ 	ASSERT(0);
+ }
++>>>>>>> 2551a53053de (xfs: explicitly pass buffer size to xfs_corruption_error)
  #else
  #define	xfs_dir3_leaf_check(dp, bp)
  #endif
diff --cc fs/xfs/xfs_error.c
index 388ce630c4b7,fedb2730ea9b..000000000000
--- a/fs/xfs/xfs_error.c
+++ b/fs/xfs/xfs_error.c
@@@ -315,14 -334,15 +315,20 @@@ xfs_corruption_error
  	const char		*tag,
  	int			level,
  	struct xfs_mount	*mp,
- 	void			*p,
+ 	void			*buf,
+ 	size_t			bufsize,
  	const char		*filename,
  	int			linenum,
 -	xfs_failaddr_t		failaddr)
 +	void			*ra)
  {
  	if (level <= xfs_error_level)
++<<<<<<< HEAD
 +		xfs_hex_dump(p, 64);
 +	xfs_error_report(tag, level, mp, filename, linenum, ra);
++=======
+ 		xfs_hex_dump(buf, bufsize);
+ 	xfs_error_report(tag, level, mp, filename, linenum, failaddr);
++>>>>>>> 2551a53053de (xfs: explicitly pass buffer size to xfs_corruption_error)
  	xfs_alert(mp, "Corruption detected. Unmount and run xfs_repair");
  }
  
diff --cc fs/xfs/xfs_error.h
index ea816c1bf8db,f8c3667790de..000000000000
--- a/fs/xfs/xfs_error.h
+++ b/fs/xfs/xfs_error.h
@@@ -21,11 -21,20 +21,25 @@@
  struct xfs_mount;
  
  extern void xfs_error_report(const char *tag, int level, struct xfs_mount *mp,
 -			const char *filename, int linenum,
 -			xfs_failaddr_t failaddr);
 +			const char *filename, int linenum, void *ra);
  extern void xfs_corruption_error(const char *tag, int level,
++<<<<<<< HEAD
 +			struct xfs_mount *mp, void *p, const char *filename,
 +			int linenum, void *ra);
 +extern void xfs_verifier_error(struct xfs_buf *bp);
++=======
+ 			struct xfs_mount *mp, void *buf, size_t bufsize,
+ 			const char *filename, int linenum,
+ 			xfs_failaddr_t failaddr);
+ extern void xfs_buf_verifier_error(struct xfs_buf *bp, int error,
+ 			const char *name, void *buf, size_t bufsz,
+ 			xfs_failaddr_t failaddr);
+ extern void xfs_verifier_error(struct xfs_buf *bp, int error,
+ 			xfs_failaddr_t failaddr);
+ extern void xfs_inode_verifier_error(struct xfs_inode *ip, int error,
+ 			const char *name, void *buf, size_t bufsz,
+ 			xfs_failaddr_t failaddr);
++>>>>>>> 2551a53053de (xfs: explicitly pass buffer size to xfs_corruption_error)
  
  #define	XFS_ERROR_REPORT(e, lvl, mp)	\
  	xfs_error_report(e, lvl, mp, __FILE__, __LINE__, __return_address)
diff --git a/fs/xfs/libxfs/xfs_btree.c b/fs/xfs/libxfs/xfs_btree.c
index 22db6411486c..f1d6537a55ce 100644
--- a/fs/xfs/libxfs/xfs_btree.c
+++ b/fs/xfs/libxfs/xfs_btree.c
@@ -1883,7 +1883,8 @@ xfs_btree_lookup(
 				if (level != 0 || cur->bc_nlevels != 1) {
 					XFS_CORRUPTION_ERROR(__func__,
 							XFS_ERRLEVEL_LOW,
-							cur->bc_mp, block);
+							cur->bc_mp, block,
+							sizeof(*block));
 					return -EFSCORRUPTED;
 				}
 
diff --git a/fs/xfs/libxfs/xfs_da_btree.c b/fs/xfs/libxfs/xfs_da_btree.c
index fb4daffc943a..9e5973c7c3b6 100644
--- a/fs/xfs/libxfs/xfs_da_btree.c
+++ b/fs/xfs/libxfs/xfs_da_btree.c
@@ -282,7 +282,7 @@ xfs_da3_node_read(
 			break;
 		default:
 			XFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW,
-					tp->t_mountp, info);
+					tp->t_mountp, info, sizeof(*info));
 			xfs_trans_brelse(tp, *bpp);
 			*bpp = NULL;
 			return -EFSCORRUPTED;
* Unmerged path fs/xfs/libxfs/xfs_dir2_data.c
* Unmerged path fs/xfs/libxfs/xfs_dir2_leaf.c
* Unmerged path fs/xfs/libxfs/xfs_dir2_node.c
diff --git a/fs/xfs/xfs_attr_list.c b/fs/xfs/xfs_attr_list.c
index 47a90e7eda66..d385a249ea8e 100644
--- a/fs/xfs/xfs_attr_list.c
+++ b/fs/xfs/xfs_attr_list.c
@@ -139,7 +139,8 @@ xfs_attr_shortform_list(xfs_attr_list_context_t *context)
 		    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {
 			XFS_CORRUPTION_ERROR("xfs_attr_shortform_list",
 					     XFS_ERRLEVEL_LOW,
-					     context->dp->i_mount, sfe);
+					     context->dp->i_mount, sfe,
+					     sizeof(*sfe));
 			kmem_free(sbuf);
 			return -EFSCORRUPTED;
 		}
@@ -241,7 +242,7 @@ xfs_attr_node_list_lookup(
 		if (magic != XFS_DA_NODE_MAGIC &&
 		    magic != XFS_DA3_NODE_MAGIC) {
 			XFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,
-					node);
+					node, sizeof(*node));
 			goto out_corruptbuf;
 		}
 
* Unmerged path fs/xfs/xfs_error.c
* Unmerged path fs/xfs/xfs_error.h
diff --git a/fs/xfs/xfs_log_recover.c b/fs/xfs/xfs_log_recover.c
index 9925c8ea78f2..8553f5898c1a 100644
--- a/fs/xfs/xfs_log_recover.c
+++ b/fs/xfs/xfs_log_recover.c
@@ -3091,7 +3091,8 @@ xlog_recover_inode_pass2(
 		if ((ldip->di_format != XFS_DINODE_FMT_EXTENTS) &&
 		    (ldip->di_format != XFS_DINODE_FMT_BTREE)) {
 			XFS_CORRUPTION_ERROR("xlog_recover_inode_pass2(3)",
-					 XFS_ERRLEVEL_LOW, mp, ldip);
+					 XFS_ERRLEVEL_LOW, mp, ldip,
+					 sizeof(*ldip));
 			xfs_alert(mp,
 		"%s: Bad regular inode log record, rec ptr %p, "
 		"ino ptr = %p, ino bp = %p, ino %Ld",
@@ -3104,7 +3105,8 @@ xlog_recover_inode_pass2(
 		    (ldip->di_format != XFS_DINODE_FMT_BTREE) &&
 		    (ldip->di_format != XFS_DINODE_FMT_LOCAL)) {
 			XFS_CORRUPTION_ERROR("xlog_recover_inode_pass2(4)",
-					     XFS_ERRLEVEL_LOW, mp, ldip);
+					     XFS_ERRLEVEL_LOW, mp, ldip,
+					     sizeof(*ldip));
 			xfs_alert(mp,
 		"%s: Bad dir inode log record, rec ptr %p, "
 		"ino ptr = %p, ino bp = %p, ino %Ld",
@@ -3115,7 +3117,8 @@ xlog_recover_inode_pass2(
 	}
 	if (unlikely(ldip->di_nextents + ldip->di_anextents > ldip->di_nblocks)){
 		XFS_CORRUPTION_ERROR("xlog_recover_inode_pass2(5)",
-				     XFS_ERRLEVEL_LOW, mp, ldip);
+				     XFS_ERRLEVEL_LOW, mp, ldip,
+				     sizeof(*ldip));
 		xfs_alert(mp,
 	"%s: Bad inode log record, rec ptr %p, dino ptr %p, "
 	"dino bp %p, ino %Ld, total extents = %d, nblocks = %Ld",
@@ -3127,7 +3130,8 @@ xlog_recover_inode_pass2(
 	}
 	if (unlikely(ldip->di_forkoff > mp->m_sb.sb_inodesize)) {
 		XFS_CORRUPTION_ERROR("xlog_recover_inode_pass2(6)",
-				     XFS_ERRLEVEL_LOW, mp, ldip);
+				     XFS_ERRLEVEL_LOW, mp, ldip,
+				     sizeof(*ldip));
 		xfs_alert(mp,
 	"%s: Bad inode log record, rec ptr %p, dino ptr %p, "
 	"dino bp %p, ino %Ld, forkoff 0x%x", __func__,
@@ -3138,7 +3142,8 @@ xlog_recover_inode_pass2(
 	isize = xfs_log_dinode_size(ldip->di_version);
 	if (unlikely(item->ri_buf[1].i_len > isize)) {
 		XFS_CORRUPTION_ERROR("xlog_recover_inode_pass2(7)",
-				     XFS_ERRLEVEL_LOW, mp, ldip);
+				     XFS_ERRLEVEL_LOW, mp, ldip,
+				     sizeof(*ldip));
 		xfs_alert(mp,
 			"%s: Bad inode log record length %d, rec ptr %p",
 			__func__, item->ri_buf[1].i_len, item);
