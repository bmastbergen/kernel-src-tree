scsi: bnx2fc: Limit the IO size according to the FW capability

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Saurav Kashyap <skashyap@marvell.com>
commit 3c97b569505f0d467a7fd544b05f1e122c08db67
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/3c97b569.failed

 - Reduce the sg_tablesize to 255.

 - Reduce the MAX BDs firmware can handle to 255.

 - Return IO to ML if BD goes more then 255 after split.

 - Correct the size of each BD split to 0xffff.

	Signed-off-by: Saurav Kashyap <skashyap@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 3c97b569505f0d467a7fd544b05f1e122c08db67)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/bnx2fc/bnx2fc_fcoe.c
diff --cc drivers/scsi/bnx2fc/bnx2fc_fcoe.c
index 0654fc8b2b81,7796799bf04a..000000000000
--- a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
@@@ -3019,13 -2967,13 +3019,19 @@@ static struct scsi_host_template bnx2fc
  	.eh_target_reset_handler = bnx2fc_eh_target_reset, /* tgt reset */
  	.eh_host_reset_handler	= fc_eh_host_reset,
  	.slave_alloc		= fc_slave_alloc,
 -	.change_queue_depth	= scsi_change_queue_depth,
 +	.change_queue_depth	= fc_change_queue_depth,
 +	.change_queue_type	= fc_change_queue_type,
  	.this_id		= -1,
  	.cmd_per_lun		= 3,
 +	.use_clustering		= ENABLE_CLUSTERING,
  	.sg_tablesize		= BNX2FC_MAX_BDS_PER_CMD,
++<<<<<<< HEAD
 +	.max_sectors		= 1024,
++=======
+ 	.dma_boundary           = 0x7fff,
+ 	.max_sectors		= 0x3fbf,
+ 	.track_queue_depth	= 1,
++>>>>>>> 3c97b569505f (scsi: bnx2fc: Limit the IO size according to the FW capability)
  	.slave_configure	= bnx2fc_slave_configure,
  	.shost_attrs		= bnx2fc_host_attrs,
  };
diff --git a/drivers/scsi/bnx2fc/bnx2fc.h b/drivers/scsi/bnx2fc/bnx2fc.h
index 5cf4998450f0..3522a16cc6ab 100644
--- a/drivers/scsi/bnx2fc/bnx2fc.h
+++ b/drivers/scsi/bnx2fc/bnx2fc.h
@@ -75,8 +75,9 @@
 #define BNX2X_DOORBELL_PCI_BAR		2
 
 #define BNX2FC_MAX_BD_LEN		0xffff
-#define BNX2FC_BD_SPLIT_SZ		0x8000
-#define BNX2FC_MAX_BDS_PER_CMD		256
+#define BNX2FC_BD_SPLIT_SZ		0xffff
+#define BNX2FC_MAX_BDS_PER_CMD		255
+#define BNX2FC_FW_MAX_BDS_PER_CMD	255
 
 #define BNX2FC_SQ_WQES_MAX	256
 
* Unmerged path drivers/scsi/bnx2fc/bnx2fc_fcoe.c
diff --git a/drivers/scsi/bnx2fc/bnx2fc_io.c b/drivers/scsi/bnx2fc/bnx2fc_io.c
index 59a7423bff6b..9577a2116758 100644
--- a/drivers/scsi/bnx2fc/bnx2fc_io.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_io.c
@@ -1660,6 +1660,7 @@ static int bnx2fc_map_sg(struct bnx2fc_cmd *io_req)
 	u64 addr;
 	int i;
 
+	WARN_ON(scsi_sg_count(sc) > BNX2FC_MAX_BDS_PER_CMD);
 	/*
 	 * Use dma_map_sg directly to ensure we're using the correct
 	 * dev struct off of pcidev.
@@ -1707,6 +1708,16 @@ static int bnx2fc_build_bd_list_from_sg(struct bnx2fc_cmd *io_req)
 	}
 	io_req->bd_tbl->bd_valid = bd_count;
 
+	/*
+	 * Return the command to ML if BD count exceeds the max number
+	 * that can be handled by FW.
+	 */
+	if (bd_count > BNX2FC_FW_MAX_BDS_PER_CMD) {
+		pr_err("bd_count = %d exceeded FW supported max BD(255), task_id = 0x%x\n",
+		       bd_count, io_req->xid);
+		return -ENOMEM;
+	}
+
 	return 0;
 }
 
