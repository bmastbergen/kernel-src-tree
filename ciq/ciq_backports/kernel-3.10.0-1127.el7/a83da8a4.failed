scsi: sd: Optimal I/O size should be a multiple of physical block size

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Martin K. Petersen <martin.petersen@oracle.com>
commit a83da8a4509d3ebfe03bb7fffce022e4d5d4764f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/a83da8a4.failed

It was reported that some devices report an OPTIMAL TRANSFER LENGTH of
0xFFFF blocks. That looks bogus, especially for a device with a
4096-byte physical block size.

Ignore OPTIMAL TRANSFER LENGTH if it is not a multiple of the device's
reported physical block size.

To make the sanity checking conditionals more readable--and to
facilitate printing warnings--relocate the checking to a helper
function. No functional change aside from the printks.

	Cc: <stable@vger.kernel.org>
Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=199759
	Reported-by: Christoph Anton Mitterer <calestyo@scientia.net>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit a83da8a4509d3ebfe03bb7fffce022e4d5d4764f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/sd.c
diff --cc drivers/scsi/sd.c
index f65a22cbf36e,f3e5e6b6404c..000000000000
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@@ -2819,6 -3047,69 +2819,72 @@@ static void sd_read_write_same(struct s
  		sdkp->ws10 = 1;
  }
  
++<<<<<<< HEAD
++=======
+ static void sd_read_security(struct scsi_disk *sdkp, unsigned char *buffer)
+ {
+ 	struct scsi_device *sdev = sdkp->device;
+ 
+ 	if (!sdev->security_supported)
+ 		return;
+ 
+ 	if (scsi_report_opcode(sdev, buffer, SD_BUF_SIZE,
+ 			SECURITY_PROTOCOL_IN) == 1 &&
+ 	    scsi_report_opcode(sdev, buffer, SD_BUF_SIZE,
+ 			SECURITY_PROTOCOL_OUT) == 1)
+ 		sdkp->security = 1;
+ }
+ 
+ /*
+  * Determine the device's preferred I/O size for reads and writes
+  * unless the reported value is unreasonably small, large, not a
+  * multiple of the physical block size, or simply garbage.
+  */
+ static bool sd_validate_opt_xfer_size(struct scsi_disk *sdkp,
+ 				      unsigned int dev_max)
+ {
+ 	struct scsi_device *sdp = sdkp->device;
+ 	unsigned int opt_xfer_bytes =
+ 		logical_to_bytes(sdp, sdkp->opt_xfer_blocks);
+ 
+ 	if (sdkp->opt_xfer_blocks > dev_max) {
+ 		sd_first_printk(KERN_WARNING, sdkp,
+ 				"Optimal transfer size %u logical blocks " \
+ 				"> dev_max (%u logical blocks)\n",
+ 				sdkp->opt_xfer_blocks, dev_max);
+ 		return false;
+ 	}
+ 
+ 	if (sdkp->opt_xfer_blocks > SD_DEF_XFER_BLOCKS) {
+ 		sd_first_printk(KERN_WARNING, sdkp,
+ 				"Optimal transfer size %u logical blocks " \
+ 				"> sd driver limit (%u logical blocks)\n",
+ 				sdkp->opt_xfer_blocks, SD_DEF_XFER_BLOCKS);
+ 		return false;
+ 	}
+ 
+ 	if (opt_xfer_bytes < PAGE_SIZE) {
+ 		sd_first_printk(KERN_WARNING, sdkp,
+ 				"Optimal transfer size %u bytes < " \
+ 				"PAGE_SIZE (%u bytes)\n",
+ 				opt_xfer_bytes, (unsigned int)PAGE_SIZE);
+ 		return false;
+ 	}
+ 
+ 	if (opt_xfer_bytes & (sdkp->physical_block_size - 1)) {
+ 		sd_first_printk(KERN_WARNING, sdkp,
+ 				"Optimal transfer size %u bytes not a " \
+ 				"multiple of physical block size (%u bytes)\n",
+ 				opt_xfer_bytes, sdkp->physical_block_size);
+ 		return false;
+ 	}
+ 
+ 	sd_first_printk(KERN_INFO, sdkp, "Optimal transfer size %u bytes\n",
+ 			opt_xfer_bytes);
+ 	return true;
+ }
+ 
++>>>>>>> a83da8a4509d (scsi: sd: Optimal I/O size should be a multiple of physical block size)
  /**
   *	sd_revalidate_disk - called the first time a new disk is seen,
   *	performs disk spin up, read_capacity, etc.
@@@ -2883,15 -3179,7 +2949,19 @@@ static int sd_revalidate_disk(struct ge
  	dev_max = min_not_zero(dev_max, sdkp->max_xfer_blocks);
  	q->limits.max_dev_sectors = logical_to_sectors(sdp, dev_max);
  
++<<<<<<< HEAD
 +	/*
 +	 * Determine the device's preferred I/O size for reads and writes
 +	 * unless the reported value is unreasonably small, large, or
 +	 * garbage.
 +	 */
 +	if (sdkp->opt_xfer_blocks &&
 +	    sdkp->opt_xfer_blocks <= dev_max &&
 +	    sdkp->opt_xfer_blocks <= SD_DEF_XFER_BLOCKS &&
 +	    logical_to_bytes(sdp, sdkp->opt_xfer_blocks) >= PAGE_CACHE_SIZE) {
++=======
+ 	if (sd_validate_opt_xfer_size(sdkp, dev_max)) {
++>>>>>>> a83da8a4509d (scsi: sd: Optimal I/O size should be a multiple of physical block size)
  		q->limits.io_opt = logical_to_bytes(sdp, sdkp->opt_xfer_blocks);
  		rw_max = logical_to_sectors(sdp, sdkp->opt_xfer_blocks);
  	} else
* Unmerged path drivers/scsi/sd.c
