nvme-rdma: always have a valid trsvcid

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Sagi Grimberg <sagi@grimberg.me>
commit bb59b8e57493465fac8658bba103f7c4cc5d874a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/bb59b8e5.failed

If not passed, we set the default trsvcid. We can rely on having trsvcid
and can simplify the controller matching logic.

	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit bb59b8e57493465fac8658bba103f7c4cc5d874a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/rdma.c
diff --cc drivers/nvme/host/rdma.c
index a2ff5b88b98b,03fff72b96f1..000000000000
--- a/drivers/nvme/host/rdma.c
+++ b/drivers/nvme/host/rdma.c
@@@ -1842,19 -1856,37 +1842,49 @@@ static const struct nvme_ctrl_ops nvme_
  	.stop_ctrl		= nvme_rdma_stop_ctrl,
  };
  
 -static inline bool
 -__nvme_rdma_options_match(struct nvme_rdma_ctrl *ctrl,
 -	struct nvmf_ctrl_options *opts)
 +static int nvme_rdma_parse_ipaddr(struct sockaddr_in *in_addr, char *p)
  {
++<<<<<<< HEAD
 +	u8 *addr = (u8 *)&in_addr->sin_addr.s_addr;
 +	size_t buflen = strlen(p);
 +
 +	/* XXX: handle IPv6 addresses */
 +
 +	if (buflen > INET_ADDRSTRLEN)
 +		return -EINVAL;
 +	if (in4_pton(p, buflen, addr, '\0', NULL) == 0)
 +		return -EINVAL;
 +	in_addr->sin_family = AF_INET;
 +	return 0;
++=======
+ 	if (!nvmf_ctlr_matches_baseopts(&ctrl->ctrl, opts) ||
+ 	    strcmp(opts->traddr, ctrl->ctrl.opts->traddr) ||
+ 	    strcmp(opts->trsvcid, ctrl->ctrl.opts->trsvcid))
+ 		return false;
+ 
+ 	/*
+ 	 * checking the local address is rough. In most cases, one
+ 	 * is not specified and the host port is selected by the stack.
+ 	 *
+ 	 * Assume no match if:
+ 	 *  local address is specified and address is not the same
+ 	 *  local address is not specified but remote is, or vice versa
+ 	 *    (admin using specific host_traddr when it matters).
+ 	 */
+ 	if (opts->mask & NVMF_OPT_HOST_TRADDR &&
+ 	    ctrl->ctrl.opts->mask & NVMF_OPT_HOST_TRADDR) {
+ 		if (strcmp(opts->host_traddr, ctrl->ctrl.opts->host_traddr))
+ 			return false;
+ 	} else if (opts->mask & NVMF_OPT_HOST_TRADDR ||
+ 		   ctrl->ctrl.opts->mask & NVMF_OPT_HOST_TRADDR)
+ 		return false;
+ 	/*
+ 	 * if neither controller had an host port specified, assume it's
+ 	 * a match as everything else matched.
+ 	 */
+ 
+ 	return true;
++>>>>>>> bb59b8e57493 (nvme-rdma: always have a valid trsvcid)
  }
  
  /*
@@@ -1899,9 -1931,21 +1929,27 @@@ static struct nvme_ctrl *nvme_rdma_crea
  	ctrl->ctrl.opts = opts;
  	INIT_LIST_HEAD(&ctrl->list);
  
++<<<<<<< HEAD
 +	ret = nvme_rdma_parse_ipaddr(&ctrl->addr_in, opts->traddr);
 +	if (ret) {
 +		pr_err("malformed IP address passed: %s\n", opts->traddr);
++=======
+ 	if (!(opts->mask & NVMF_OPT_TRSVCID)) {
+ 		opts->trsvcid =
+ 			kstrdup(__stringify(NVME_RDMA_IP_PORT), GFP_KERNEL);
+ 		if (!opts->trsvcid) {
+ 			ret = -ENOMEM;
+ 			goto out_free_ctrl;
+ 		}
+ 		opts->mask |= NVMF_OPT_TRSVCID;
+ 	}
+ 
+ 	ret = inet_pton_with_scope(&init_net, AF_UNSPEC,
+ 			opts->traddr, opts->trsvcid, &ctrl->addr);
+ 	if (ret) {
+ 		pr_err("malformed address passed: %s:%s\n",
+ 			opts->traddr, opts->trsvcid);
++>>>>>>> bb59b8e57493 (nvme-rdma: always have a valid trsvcid)
  		goto out_free_ctrl;
  	}
  
* Unmerged path drivers/nvme/host/rdma.c
