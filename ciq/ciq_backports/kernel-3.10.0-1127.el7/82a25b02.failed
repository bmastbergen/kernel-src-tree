ext4: wait for outstanding dio during truncate in nojournal mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Jan Kara <jack@suse.cz>
commit 82a25b027ca48d7ef197295846b352345853dfa8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/82a25b02.failed

We didn't wait for outstanding direct IO during truncate in nojournal
mode (as we skip orphan handling in that case). This can lead to fs
corruption or stale data exposure if truncate ends up freeing blocks
and these get reallocated before direct IO finishes. Fix the condition
determining whether the wait is necessary.

CC: stable@vger.kernel.org
Fixes: 1c9114f9c0f1 ("ext4: serialize unlocked dio reads with truncate")
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit 82a25b027ca48d7ef197295846b352345853dfa8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/inode.c
diff --cc fs/ext4/inode.c
index 424023796cc3,9bcb7f2b86dd..000000000000
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@@ -5027,22 -5630,17 +5027,33 @@@ int ext4_setattr(struct dentry *dentry
  				goto err_out;
  			}
  		}
- 		if (!shrink)
+ 		if (!shrink) {
  			pagecache_isize_extended(inode, oldsize, inode->i_size);
++<<<<<<< HEAD
 +
 +		/*
 +		 * Blocks are going to be removed from the inode. Wait
 +		 * for dio in flight.  Temporarily disable
 +		 * dioread_nolock to prevent livelock.
 +		 */
 +		if (orphan) {
 +			if (!ext4_should_journal_data(inode)) {
 +				ext4_inode_block_unlocked_dio(inode);
 +				inode_dio_wait(inode);
 +				ext4_inode_resume_unlocked_dio(inode);
 +			} else
 +				ext4_wait_for_tail_page_commit(inode);
++=======
+ 		} else {
+ 			/*
+ 			 * Blocks are going to be removed from the inode. Wait
+ 			 * for dio in flight.
+ 			 */
+ 			inode_dio_wait(inode);
++>>>>>>> 82a25b027ca4 (ext4: wait for outstanding dio during truncate in nojournal mode)
  		}
+ 		if (orphan && ext4_should_journal_data(inode))
+ 			ext4_wait_for_tail_page_commit(inode);
  		down_write(&EXT4_I(inode)->i_mmap_sem);
  
  		rc = ext4_break_layouts(inode);
* Unmerged path fs/ext4/inode.c
