scsi: qla2xxx: Secure flash update support for ISP28XX

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Michael Hernandez <mhernandez@marvell.com>
commit 3f006ac342c033c795aa0ec2d0dde63975e2144b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/3f006ac3.failed

This patch adds support for Secure flash update with ISP28xx.

	Signed-off-by: Michael Hernandez <mhernandez@marvell.com>
	Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 3f006ac342c033c795aa0ec2d0dde63975e2144b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_os.c
#	drivers/scsi/qla2xxx/qla_sup.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 416307fab71e,2ec878afa18d..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -4696,7 -4771,13 +4721,17 @@@ struct sff_8247_a0 
  #define AUTO_DETECT_SFP_SUPPORT(_vha)\
  	(ql2xautodetectsfp && !_vha->vp_idx &&		\
  	(IS_QLA25XX(_vha->hw) || IS_QLA81XX(_vha->hw) ||\
++<<<<<<< HEAD
 +	IS_QLA83XX(_vha->hw) || IS_QLA27XX(_vha->hw)))
++=======
+ 	IS_QLA83XX(_vha->hw) || IS_QLA27XX(_vha->hw) || \
+ 	 IS_QLA28XX(_vha->hw)))
+ 
+ #define FLASH_SEMAPHORE_REGISTER_ADDR   0x00101016
+ 
+ #define USER_CTRL_IRQ(_ha) (ql2xuctrlirq && QLA_TGT_MODE_ENABLED() && \
+ 	(IS_QLA27XX(_ha) || IS_QLA28XX(_ha) || IS_QLA83XX(_ha)))
++>>>>>>> 3f006ac342c0 (scsi: qla2xxx: Secure flash update support for ISP28XX)
  
  #define SAVE_TOPO(_ha) { \
  	if (_ha->current_topology)				\
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 50169fbc204f,f640c8373b05..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -7959,14 -8217,35 +7988,20 @@@ qla81xx_nvram_config(scsi_qla_host_t *v
  	if (IS_P3P_TYPE(ha) || IS_QLA8031(ha))
  		ha->vpd_size = FA_VPD_SIZE_82XX;
  
++<<<<<<< HEAD
++=======
+ 	if (IS_QLA28XX(ha) || IS_QLA27XX(ha))
+ 		qla28xx_get_aux_images(vha, &active_regions);
+ 
++>>>>>>> 3f006ac342c0 (scsi: qla2xxx: Secure flash update support for ISP28XX)
  	/* Get VPD data into cache */
  	ha->vpd = ha->nvram + VPD_OFFSET;
 -
 -	faddr = ha->flt_region_vpd;
 -	if (IS_QLA28XX(ha)) {
 -		if (active_regions.aux.vpd_nvram == QLA27XX_SECONDARY_IMAGE)
 -			faddr = ha->flt_region_vpd_sec;
 -		ql_dbg(ql_dbg_init, vha, 0x0110,
 -		    "Loading %s nvram image.\n",
 -		    active_regions.aux.vpd_nvram == QLA27XX_PRIMARY_IMAGE ?
 -		    "primary" : "secondary");
 -	}
 -	qla24xx_read_flash_data(vha, ha->vpd, faddr, ha->vpd_size >> 2);
 +	ha->isp_ops->read_optrom(vha, ha->vpd, ha->flt_region_vpd << 2,
 +	    ha->vpd_size);
  
  	/* Get NVRAM data into cache and calculate checksum. */
 -	faddr = ha->flt_region_nvram;
 -	if (IS_QLA28XX(ha)) {
 -		if (active_regions.aux.vpd_nvram == QLA27XX_SECONDARY_IMAGE)
 -			faddr = ha->flt_region_nvram_sec;
 -	}
 -	ql_dbg(ql_dbg_init, vha, 0x0110,
 -	    "Loading %s nvram image.\n",
 -	    active_regions.aux.vpd_nvram == QLA27XX_PRIMARY_IMAGE ?
 -	    "primary" : "secondary");
 -	qla24xx_read_flash_data(vha, ha->nvram, faddr, ha->nvram_size >> 2);
 -
 +	ha->isp_ops->read_optrom(vha, ha->nvram, ha->flt_region_nvram << 2,
 +	    ha->nvram_size);
  	dptr = (uint32_t *)nv;
  	for (cnt = 0, chksum = 0; cnt < ha->nvram_size >> 2; cnt++, dptr++)
  		chksum += le32_to_cpu(*dptr);
diff --cc drivers/scsi/qla2xxx/qla_os.c
index ee09796b9847,d2bad3f99ce2..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -41,7 -42,7 +41,11 @@@ static struct kmem_cache *ctx_cachep
  /*
   * error level for logging
   */
++<<<<<<< HEAD
 +int ql_errlev = ql_log_all;
++=======
+ uint ql_errlev = 0x8001;
++>>>>>>> 3f006ac342c0 (scsi: qla2xxx: Secure flash update support for ISP28XX)
  
  static int ql2xenableclass2;
  module_param(ql2xenableclass2, int, S_IRUGO|S_IRUSR);
diff --cc drivers/scsi/qla2xxx/qla_sup.c
index d78d2bdfd652,320c25f3a79a..000000000000
--- a/drivers/scsi/qla2xxx/qla_sup.c
+++ b/drivers/scsi/qla2xxx/qla_sup.c
@@@ -718,12 -709,15 +709,22 @@@ qla2xxx_get_flt_info(scsi_qla_host_t *v
  		/* Store addresses as DWORD offsets. */
  		start = le32_to_cpu(region->start) >> 2;
  		ql_dbg(ql_dbg_init, vha, 0x0049,
++<<<<<<< HEAD
 +		    "FLT[%02x]: start=0x%x "
 +		    "end=0x%x size=0x%x.\n", le32_to_cpu(region->code) & 0xff,
 +		    start, le32_to_cpu(region->end) >> 2,
 +		    le32_to_cpu(region->size));
++=======
+ 		    "FLT[%#x]: start=%#x end=%#x size=%#x.\n",
+ 		    le16_to_cpu(region->code), start,
+ 		    le32_to_cpu(region->end) >> 2,
+ 		    le32_to_cpu(region->size) >> 2);
+ 		if (region->attribute)
+ 			ql_log(ql_dbg_init, vha, 0xffff,
+ 			    "Region %x is secure\n", region->code);
++>>>>>>> 3f006ac342c0 (scsi: qla2xxx: Secure flash update support for ISP28XX)
  
 -		switch (le16_to_cpu(region->code)) {
 +		switch (le32_to_cpu(region->code) & 0xff) {
  		case FLT_REG_FCOE_FW:
  			if (!IS_QLA8031(ha))
  				break;
@@@ -2587,8 -2617,340 +2588,340 @@@ qla24xx_read_optrom_data(struct scsi_ql
  	return buf;
  }
  
+ static int
+ qla28xx_extract_sfub_and_verify(struct scsi_qla_host *vha, uint32_t *buf,
+     uint32_t len, uint32_t buf_size_without_sfub, uint8_t *sfub_buf)
+ {
+ 	uint32_t *p, check_sum = 0;
+ 	int i;
+ 
+ 	p = buf + buf_size_without_sfub;
+ 
+ 	/* Extract SFUB from end of file */
+ 	memcpy(sfub_buf, (uint8_t *)p,
+ 	    sizeof(struct secure_flash_update_block));
+ 
+ 	for (i = 0; i < (sizeof(struct secure_flash_update_block) >> 2); i++)
+ 		check_sum += p[i];
+ 
+ 	check_sum = (~check_sum) + 1;
+ 
+ 	if (check_sum != p[i]) {
+ 		ql_log(ql_log_warn, vha, 0x7097,
+ 		    "SFUB checksum failed, 0x%x, 0x%x\n",
+ 		    check_sum, p[i]);
+ 		return QLA_COMMAND_ERROR;
+ 	}
+ 
+ 	return QLA_SUCCESS;
+ }
+ 
+ static int
+ qla28xx_get_flash_region(struct scsi_qla_host *vha, uint32_t start,
+     struct qla_flt_region *region)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct qla_flt_header *flt;
+ 	struct qla_flt_region *flt_reg;
+ 	uint16_t cnt;
+ 	int rval = QLA_FUNCTION_FAILED;
+ 
+ 	if (!ha->flt)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	flt = (struct qla_flt_header *)ha->flt;
+ 	flt_reg = (struct qla_flt_region *)&flt[1];
+ 	cnt = le16_to_cpu(flt->length) / sizeof(struct qla_flt_region);
+ 
+ 	for (; cnt; cnt--, flt_reg++) {
+ 		if (flt_reg->start == start) {
+ 			memcpy((uint8_t *)region, flt_reg,
+ 			    sizeof(struct qla_flt_region));
+ 			rval = QLA_SUCCESS;
+ 			break;
+ 		}
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ static int
+ qla28xx_write_flash_data(scsi_qla_host_t *vha, uint32_t *dwptr, uint32_t faddr,
+     uint32_t dwords)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	ulong liter;
+ 	ulong dburst = OPTROM_BURST_DWORDS; /* burst size in dwords */
+ 	uint32_t sec_mask, rest_addr, fdata;
+ 	void *optrom = NULL;
+ 	dma_addr_t optrom_dma;
+ 	int rval;
+ 	struct secure_flash_update_block *sfub;
+ 	dma_addr_t sfub_dma;
+ 	uint32_t offset = faddr << 2;
+ 	uint32_t buf_size_without_sfub = 0;
+ 	struct qla_flt_region region;
+ 	bool reset_to_rom = false;
+ 	uint32_t risc_size, risc_attr = 0;
+ 	uint32_t *fw_array = NULL;
+ 
+ 	/* Retrieve region info - must be a start address passed in */
+ 	rval = qla28xx_get_flash_region(vha, offset, &region);
+ 
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Invalid address %x - not a region start address\n",
+ 		    offset);
+ 		goto done;
+ 	}
+ 
+ 	/* Allocate dma buffer for burst write */
+ 	optrom = dma_alloc_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,
+ 	    &optrom_dma, GFP_KERNEL);
+ 	if (!optrom) {
+ 		ql_log(ql_log_warn, vha, 0x7095,
+ 		    "Failed allocate burst (%x bytes)\n", OPTROM_BURST_SIZE);
+ 		rval = QLA_COMMAND_ERROR;
+ 		goto done;
+ 	}
+ 
+ 	/*
+ 	 * If adapter supports secure flash and region is secure
+ 	 * extract secure flash update block (SFUB) and verify
+ 	 */
+ 	if (ha->flags.secure_adapter && region.attribute) {
+ 
+ 		ql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,
+ 		    "Region %x is secure\n", region.code);
+ 
+ 		if (region.code == FLT_REG_FW ||
+ 		    region.code == FLT_REG_FW_SEC_27XX) {
+ 			fw_array = dwptr;
+ 
+ 			/* 1st fw array */
+ 			risc_size = be32_to_cpu(fw_array[3]);
+ 			risc_attr = be32_to_cpu(fw_array[9]);
+ 
+ 			buf_size_without_sfub = risc_size;
+ 			fw_array += risc_size;
+ 
+ 			/* 2nd fw array */
+ 			risc_size = be32_to_cpu(fw_array[3]);
+ 
+ 			buf_size_without_sfub += risc_size;
+ 			fw_array += risc_size;
+ 
+ 			/* 1st dump template */
+ 			risc_size = be32_to_cpu(fw_array[2]);
+ 
+ 			/* skip header and ignore checksum */
+ 			buf_size_without_sfub += risc_size;
+ 			fw_array += risc_size;
+ 
+ 			if (risc_attr & BIT_9) {
+ 				/* 2nd dump template */
+ 				risc_size = be32_to_cpu(fw_array[2]);
+ 
+ 				/* skip header and ignore checksum */
+ 				buf_size_without_sfub += risc_size;
+ 				fw_array += risc_size;
+ 			}
+ 		} else {
+ 			ql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,
+ 			    "Secure region %x not supported\n",
+ 			    region.code);
+ 			rval = QLA_COMMAND_ERROR;
+ 			goto done;
+ 		}
+ 
+ 		sfub = dma_alloc_coherent(&ha->pdev->dev,
+ 			sizeof(struct secure_flash_update_block), &sfub_dma,
+ 			GFP_KERNEL);
+ 		if (!sfub) {
+ 			ql_log(ql_log_warn, vha, 0xffff,
+ 			    "Unable to allocate memory for SFUB\n");
+ 			rval = QLA_COMMAND_ERROR;
+ 			goto done;
+ 		}
+ 
+ 		rval = qla28xx_extract_sfub_and_verify(vha, dwptr, dwords,
+ 			buf_size_without_sfub, (uint8_t *)sfub);
+ 
+ 		if (rval != QLA_SUCCESS)
+ 			goto done;
+ 
+ 		ql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,
+ 		    "SFUB extract and verify successful\n");
+ 	}
+ 
+ 	rest_addr = (ha->fdt_block_size >> 2) - 1;
+ 	sec_mask = ~rest_addr;
+ 
+ 	/* Lock semaphore */
+ 	rval = qla81xx_fac_semaphore_access(vha, FAC_SEMAPHORE_LOCK);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Unable to lock flash semaphore.");
+ 		goto done;
+ 	}
+ 
+ 	ql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,
+ 	    "Unprotect flash...\n");
+ 	rval = qla24xx_unprotect_flash(vha);
+ 	if (rval) {
+ 		qla81xx_fac_semaphore_access(vha, FAC_SEMAPHORE_UNLOCK);
+ 		ql_log(ql_log_warn, vha, 0x7096, "Failed unprotect flash\n");
+ 		goto done;
+ 	}
+ 
+ 	for (liter = 0; liter < dwords; liter++, faddr++) {
+ 		fdata = (faddr & sec_mask) << 2;
+ 
+ 		/* If start of sector */
+ 		if (!(faddr & rest_addr)) {
+ 			ql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,
+ 			    "Erase sector %#x...\n", faddr);
+ 			rval = qla24xx_erase_sector(vha, fdata);
+ 			if (rval) {
+ 				ql_dbg(ql_dbg_user, vha, 0x7007,
+ 				    "Failed erase sector %#x\n", faddr);
+ 				goto write_protect;
+ 			}
+ 		}
+ 	}
+ 
+ 	if (ha->flags.secure_adapter) {
+ 		/*
+ 		 * If adapter supports secure flash but FW doesn't,
+ 		 * disable write protect, release semaphore and reset
+ 		 * chip to execute ROM code in order to update region securely
+ 		 */
+ 		if (!ha->flags.secure_fw) {
+ 			ql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,
+ 			    "Disable Write and Release Semaphore.");
+ 			rval = qla24xx_protect_flash(vha);
+ 			if (rval != QLA_SUCCESS) {
+ 				qla81xx_fac_semaphore_access(vha,
+ 					FAC_SEMAPHORE_UNLOCK);
+ 				ql_log(ql_log_warn, vha, 0xffff,
+ 				    "Unable to protect flash.");
+ 				goto done;
+ 			}
+ 
+ 			ql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,
+ 			    "Reset chip to ROM.");
+ 			set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
+ 			set_bit(ISP_ABORT_TO_ROM, &vha->dpc_flags);
+ 			qla2xxx_wake_dpc(vha);
+ 			rval = qla2x00_wait_for_chip_reset(vha);
+ 			if (rval != QLA_SUCCESS) {
+ 				ql_log(ql_log_warn, vha, 0xffff,
+ 				    "Unable to reset to ROM code.");
+ 				goto done;
+ 			}
+ 			reset_to_rom = true;
+ 			ha->flags.fac_supported = 0;
+ 
+ 			ql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,
+ 			    "Lock Semaphore");
+ 			rval = qla2xxx_write_remote_register(vha,
+ 			    FLASH_SEMAPHORE_REGISTER_ADDR, 0x00020002);
+ 			if (rval != QLA_SUCCESS) {
+ 				ql_log(ql_log_warn, vha, 0xffff,
+ 				    "Unable to lock flash semaphore.");
+ 				goto done;
+ 			}
+ 
+ 			/* Unprotect flash */
+ 			ql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,
+ 			    "Enable Write.");
+ 			rval = qla2x00_write_ram_word(vha, 0x7ffd0101, 0);
+ 			if (rval) {
+ 				ql_log(ql_log_warn, vha, 0x7096,
+ 				    "Failed unprotect flash\n");
+ 				goto done;
+ 			}
+ 		}
+ 
+ 		/* If region is secure, send Secure Flash MB Cmd */
+ 		if (region.attribute && buf_size_without_sfub) {
+ 			ql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,
+ 			    "Sending Secure Flash MB Cmd\n");
+ 			rval = qla28xx_secure_flash_update(vha, 0, region.code,
+ 				buf_size_without_sfub, sfub_dma,
+ 				sizeof(struct secure_flash_update_block));
+ 			if (rval != QLA_SUCCESS) {
+ 				ql_log(ql_log_warn, vha, 0xffff,
+ 				    "Secure Flash MB Cmd failed %x.", rval);
+ 				goto write_protect;
+ 			}
+ 		}
+ 
+ 	}
+ 
+ 	/* re-init flash offset */
+ 	faddr = offset >> 2;
+ 
+ 	for (liter = 0; liter < dwords; liter++, faddr++, dwptr++) {
+ 		fdata = (faddr & sec_mask) << 2;
+ 
+ 		/* If smaller than a burst remaining */
+ 		if (dwords - liter < dburst)
+ 			dburst = dwords - liter;
+ 
+ 		/* Copy to dma buffer */
+ 		memcpy(optrom, dwptr, dburst << 2);
+ 
+ 		/* Burst write */
+ 		ql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,
+ 		    "Write burst (%#lx dwords)...\n", dburst);
+ 		rval = qla2x00_load_ram(vha, optrom_dma,
+ 		    flash_data_addr(ha, faddr), dburst);
+ 		if (rval != QLA_SUCCESS) {
+ 			ql_log(ql_log_warn, vha, 0x7097,
+ 			    "Failed burst write at %x (%p/%#llx)...\n",
+ 			    flash_data_addr(ha, faddr), optrom,
+ 			    (u64)optrom_dma);
+ 			break;
+ 		}
+ 
+ 		liter += dburst - 1;
+ 		faddr += dburst - 1;
+ 		dwptr += dburst - 1;
+ 		continue;
+ 	}
+ 
+ write_protect:
+ 	ql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,
+ 	    "Protect flash...\n");
+ 	rval = qla24xx_protect_flash(vha);
+ 	if (rval) {
+ 		qla81xx_fac_semaphore_access(vha, FAC_SEMAPHORE_UNLOCK);
+ 		ql_log(ql_log_warn, vha, 0x7099,
+ 		    "Failed protect flash\n");
+ 	}
+ 
+ 	if (reset_to_rom == true) {
+ 		/* Schedule DPC to restart the RISC */
+ 		set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
+ 		qla2xxx_wake_dpc(vha);
+ 
+ 		rval = qla2x00_wait_for_hba_online(vha);
+ 		if (rval != QLA_SUCCESS)
+ 			ql_log(ql_log_warn, vha, 0xffff,
+ 			    "Adapter did not come out of reset\n");
+ 	}
+ 
+ done:
+ 	if (optrom)
+ 		dma_free_coherent(&ha->pdev->dev,
+ 		    OPTROM_BURST_SIZE, optrom, optrom_dma);
+ 
+ 	return rval;
+ }
+ 
  int
 -qla24xx_write_optrom_data(struct scsi_qla_host *vha, void *buf,
 +qla24xx_write_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,
      uint32_t offset, uint32_t length)
  {
  	int rval;
@@@ -2599,8 -2961,12 +2932,17 @@@
  	set_bit(MBX_UPDATE_FLASH_ACTIVE, &ha->mbx_cmd_flags);
  
  	/* Go with write. */
++<<<<<<< HEAD
 +	rval = qla24xx_write_flash_data(vha, (uint32_t *)buf, offset >> 2,
 +	    length >> 2);
++=======
+ 	if (IS_QLA28XX(ha))
+ 		rval = qla28xx_write_flash_data(vha, (uint32_t *)buf,
+ 		    offset >> 2, length >> 2);
+ 	else
+ 		rval = qla24xx_write_flash_data(vha, (uint32_t *)buf,
+ 		    offset >> 2, length >> 2);
++>>>>>>> 3f006ac342c0 (scsi: qla2xxx: Secure flash update support for ISP28XX)
  
  	clear_bit(MBX_UPDATE_FLASH_ACTIVE, &ha->mbx_cmd_flags);
  	scsi_unblock_requests(vha->host);
@@@ -3117,20 -3479,15 +3459,28 @@@ qla24xx_get_flash_version(scsi_qla_host
  
  	/* Read firmware image information. */
  	memset(ha->fw_revision, 0, sizeof(ha->fw_revision));
 +	dcode = mbuf;
  	faddr = ha->flt_region_fw;
++<<<<<<< HEAD
 +	if (IS_QLA27XX(ha) &&
 +	    qla27xx_find_valid_image(vha) == QLA27XX_SECONDARY_IMAGE)
 +		faddr = ha->flt_region_fw_sec;
++=======
+ 	if (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {
+ 		qla27xx_get_active_image(vha, &active_regions);
+ 		if (active_regions.global == QLA27XX_SECONDARY_IMAGE)
+ 			faddr = ha->flt_region_fw_sec;
+ 	}
++>>>>>>> 3f006ac342c0 (scsi: qla2xxx: Secure flash update support for ISP28XX)
 +
 +	qla24xx_read_flash_data(vha, dcode, faddr + 4, 4);
 +	for (i = 0; i < 4; i++)
 +		dcode[i] = be32_to_cpu(dcode[i]);
  
 -	qla24xx_read_flash_data(vha, dcode, faddr, 8);
 -	if (qla24xx_risc_firmware_invalid(dcode)) {
 +	if ((dcode[0] == 0xffffffff && dcode[1] == 0xffffffff &&
 +	    dcode[2] == 0xffffffff && dcode[3] == 0xffffffff) ||
 +	    (dcode[0] == 0 && dcode[1] == 0 && dcode[2] == 0 &&
 +	    dcode[3] == 0)) {
  		ql_log(ql_log_warn, vha, 0x005f,
  		    "Unrecognized fw revision at %x.\n",
  		    ha->flt_region_fw * 4);
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
diff --git a/drivers/scsi/qla2xxx/qla_fw.h b/drivers/scsi/qla2xxx/qla_fw.h
index 50c1e6c62e31..7bb8d92dcd94 100644
--- a/drivers/scsi/qla2xxx/qla_fw.h
+++ b/drivers/scsi/qla2xxx/qla_fw.h
@@ -1522,6 +1522,10 @@ struct qla_flt_region {
 	uint32_t end;
 };
 
+#define FLT_REGION_SIZE		16
+#define FLT_MAX_REGIONS		0xFF
+#define FLT_REGIONS_SIZE	(FLT_REGION_SIZE * FLT_MAX_REGIONS)
+
 /* Flash NPIV Configuration Table ********************************************/
 
 struct qla_npiv_header {
@@ -1711,6 +1715,10 @@ struct access_chip_rsp_84xx {
 #define LR_DIST_FW_SHIFT	(LR_DIST_FW_POS - LR_DIST_NV_POS)
 #define LR_DIST_FW_FIELD(x)	((x) << LR_DIST_FW_SHIFT & 0xf000)
 
+/* FAC semaphore defines */
+#define FAC_SEMAPHORE_UNLOCK    0
+#define FAC_SEMAPHORE_LOCK      1
+
 struct nvram_81xx {
 	/* NVRAM header. */
 	uint8_t id[4];
diff --git a/drivers/scsi/qla2xxx/qla_gbl.h b/drivers/scsi/qla2xxx/qla_gbl.h
index 780625376e18..40c6304d9903 100644
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@ -18,14 +18,14 @@ extern int qla2100_pci_config(struct scsi_qla_host *);
 extern int qla2300_pci_config(struct scsi_qla_host *);
 extern int qla24xx_pci_config(scsi_qla_host_t *);
 extern int qla25xx_pci_config(scsi_qla_host_t *);
-extern void qla2x00_reset_chip(struct scsi_qla_host *);
-extern void qla24xx_reset_chip(struct scsi_qla_host *);
+extern int qla2x00_reset_chip(struct scsi_qla_host *);
+extern int qla24xx_reset_chip(struct scsi_qla_host *);
 extern int qla2x00_chip_diag(struct scsi_qla_host *);
 extern int qla24xx_chip_diag(struct scsi_qla_host *);
 extern void qla2x00_config_rings(struct scsi_qla_host *);
 extern void qla24xx_config_rings(struct scsi_qla_host *);
-extern void qla2x00_reset_adapter(struct scsi_qla_host *);
-extern void qla24xx_reset_adapter(struct scsi_qla_host *);
+extern int qla2x00_reset_adapter(struct scsi_qla_host *);
+extern int qla24xx_reset_adapter(struct scsi_qla_host *);
 extern int qla2x00_nvram_config(struct scsi_qla_host *);
 extern int qla24xx_nvram_config(struct scsi_qla_host *);
 extern int qla81xx_nvram_config(struct scsi_qla_host *);
@@ -465,6 +465,8 @@ qla81xx_fac_do_write_enable(scsi_qla_host_t *, int);
 extern int
 qla81xx_fac_erase_sector(scsi_qla_host_t *, uint32_t, uint32_t);
 
+extern int qla81xx_fac_semaphore_access(scsi_qla_host_t *, int);
+
 extern int
 qla2x00_get_xgmac_stats(scsi_qla_host_t *, dma_addr_t, uint16_t, uint16_t *);
 
@@ -510,6 +512,14 @@ extern int qla27xx_get_zio_threshold(scsi_qla_host_t *, uint16_t *);
 extern int qla27xx_set_zio_threshold(scsi_qla_host_t *, uint16_t);
 int qla24xx_res_count_wait(struct scsi_qla_host *, uint16_t *, int);
 
+extern int qla28xx_secure_flash_update(scsi_qla_host_t *, uint16_t, uint16_t,
+    uint32_t, dma_addr_t, uint32_t);
+
+extern int qla2xxx_read_remote_register(scsi_qla_host_t *, uint32_t,
+    uint32_t *);
+extern int qla2xxx_write_remote_register(scsi_qla_host_t *, uint32_t,
+    uint32_t);
+
 /*
  * Global Function Prototypes in qla_isr.c source file.
  */
@@ -719,7 +729,7 @@ extern void qla24xx_wrt_rsp_reg(struct qla_hw_data *, uint16_t, uint16_t);
 /* qlafx00 related functions */
 extern int qlafx00_pci_config(struct scsi_qla_host *);
 extern int qlafx00_initialize_adapter(struct scsi_qla_host *);
-extern void qlafx00_soft_reset(scsi_qla_host_t *);
+extern int qlafx00_soft_reset(scsi_qla_host_t *);
 extern int qlafx00_chip_diag(scsi_qla_host_t *);
 extern void qlafx00_config_rings(struct scsi_qla_host *);
 extern char *qlafx00_pci_info_str(struct scsi_qla_host *, char *);
@@ -762,7 +772,7 @@ extern int qla82xx_pci_region_offset(struct pci_dev *, int);
 extern int qla82xx_iospace_config(struct qla_hw_data *);
 
 /* Initialization related functions */
-extern void qla82xx_reset_chip(struct scsi_qla_host *);
+extern int qla82xx_reset_chip(struct scsi_qla_host *);
 extern void qla82xx_config_rings(struct scsi_qla_host *);
 extern void qla82xx_watchdog(scsi_qla_host_t *);
 extern int qla82xx_start_firmware(scsi_qla_host_t *);
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c
index 3068422cd7a5..ba68b982fc27 100644
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@ -1135,6 +1135,13 @@ qla2x00_get_fw_version(scsi_qla_host_t *vha)
 		ha->fw_shared_ram_end = (mcp->mb[21] << 16) | mcp->mb[20];
 		ha->fw_ddr_ram_start = (mcp->mb[23] << 16) | mcp->mb[22];
 		ha->fw_ddr_ram_end = (mcp->mb[25] << 16) | mcp->mb[24];
+		if (IS_QLA28XX(ha)) {
+			if (mcp->mb[16] & BIT_10) {
+				ql_log(ql_log_info, vha, 0xffff,
+				    "FW support secure flash updates\n");
+				ha->flags.secure_fw = 1;
+			}
+		}
 	}
 
 failed:
@@ -4583,6 +4590,42 @@ qla81xx_fac_erase_sector(scsi_qla_host_t *vha, uint32_t start, uint32_t finish)
 	return rval;
 }
 
+int
+qla81xx_fac_semaphore_access(scsi_qla_host_t *vha, int lock)
+{
+	int rval = QLA_SUCCESS;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+	struct qla_hw_data *ha = vha->hw;
+
+	if (!IS_QLA81XX(ha) && !IS_QLA83XX(ha) &&
+	    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))
+		return rval;
+
+	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e2,
+	    "Entered %s.\n", __func__);
+
+	mcp->mb[0] = MBC_FLASH_ACCESS_CTRL;
+	mcp->mb[1] = (lock ? FAC_OPT_CMD_LOCK_SEMAPHORE :
+	    FAC_OPT_CMD_UNLOCK_SEMAPHORE);
+	mcp->out_mb = MBX_1|MBX_0;
+	mcp->in_mb = MBX_1|MBX_0;
+	mcp->tov = MBX_TOV_SECONDS;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(vha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		ql_dbg(ql_dbg_mbx, vha, 0x10e3,
+		    "Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\n",
+		    rval, mcp->mb[0], mcp->mb[1], mcp->mb[2]);
+	} else {
+		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e4,
+		    "Done %s.\n", __func__);
+	}
+
+	return rval;
+}
+
 int
 qla81xx_restart_mpi_firmware(scsi_qla_host_t *vha)
 {
@@ -6520,3 +6563,101 @@ int qla24xx_res_count_wait(struct scsi_qla_host *vha,
 done:
 	return rval;
 }
+
+int qla28xx_secure_flash_update(scsi_qla_host_t *vha, uint16_t opts,
+    uint16_t region, uint32_t len, dma_addr_t sfub_dma_addr,
+    uint32_t sfub_len)
+{
+	int		rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	mcp->mb[0] = MBC_SECURE_FLASH_UPDATE;
+	mcp->mb[1] = opts;
+	mcp->mb[2] = region;
+	mcp->mb[3] = MSW(len);
+	mcp->mb[4] = LSW(len);
+	mcp->mb[5] = MSW(sfub_dma_addr);
+	mcp->mb[6] = LSW(sfub_dma_addr);
+	mcp->mb[7] = MSW(MSD(sfub_dma_addr));
+	mcp->mb[8] = LSW(MSD(sfub_dma_addr));
+	mcp->mb[9] = sfub_len;
+	mcp->out_mb =
+	    MBX_9|MBX_8|MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_2|MBX_1|MBX_0;
+	mcp->tov = MBX_TOV_SECONDS;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(vha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		ql_dbg(ql_dbg_mbx, vha, 0xffff, "%s(%ld): failed rval 0x%x, %x %x %x",
+			__func__, vha->host_no, rval, mcp->mb[0], mcp->mb[1],
+			mcp->mb[2]);
+	}
+
+	return rval;
+}
+
+int qla2xxx_write_remote_register(scsi_qla_host_t *vha, uint32_t addr,
+    uint32_t data)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e8,
+	    "Entered %s.\n", __func__);
+
+	mcp->mb[0] = MBC_WRITE_REMOTE_REG;
+	mcp->mb[1] = LSW(addr);
+	mcp->mb[2] = MSW(addr);
+	mcp->mb[3] = LSW(data);
+	mcp->mb[4] = MSW(data);
+	mcp->out_mb = MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_1|MBX_0;
+	mcp->tov = MBX_TOV_SECONDS;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(vha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		ql_dbg(ql_dbg_mbx, vha, 0x10e9,
+		    "Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);
+	} else {
+		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ea,
+		    "Done %s.\n", __func__);
+	}
+
+	return rval;
+}
+
+int qla2xxx_read_remote_register(scsi_qla_host_t *vha, uint32_t addr,
+    uint32_t *data)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e8,
+	    "Entered %s.\n", __func__);
+
+	mcp->mb[0] = MBC_READ_REMOTE_REG;
+	mcp->mb[1] = LSW(addr);
+	mcp->mb[2] = MSW(addr);
+	mcp->out_mb = MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->tov = MBX_TOV_SECONDS;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(vha, mcp);
+
+	*data = (uint32_t)((((uint32_t)mcp->mb[4]) << 16) | mcp->mb[3]);
+
+	if (rval != QLA_SUCCESS) {
+		ql_dbg(ql_dbg_mbx, vha, 0x10e9,
+		    "Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);
+	} else {
+		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ea,
+		    "Done %s.\n", __func__);
+	}
+
+	return rval;
+}
diff --git a/drivers/scsi/qla2xxx/qla_mr.c b/drivers/scsi/qla2xxx/qla_mr.c
index 045b00ecc24c..e941107bf692 100644
--- a/drivers/scsi/qla2xxx/qla_mr.c
+++ b/drivers/scsi/qla2xxx/qla_mr.c
@@ -627,17 +627,20 @@ qlafx00_soc_cpu_reset(scsi_qla_host_t *vha)
  *
  * Returns 0 on success.
  */
-void
+int
 qlafx00_soft_reset(scsi_qla_host_t *vha)
 {
 	struct qla_hw_data *ha = vha->hw;
+	int rval = QLA_FUNCTION_FAILED;
 
 	if (unlikely(pci_channel_offline(ha->pdev) &&
 	    ha->flags.pci_channel_io_perm_failure))
-		return;
+		return rval;
 
 	ha->isp_ops->disable_intrs(ha);
 	qlafx00_soc_cpu_reset(vha);
+
+	return QLA_SUCCESS;
 }
 
 /**
diff --git a/drivers/scsi/qla2xxx/qla_nx.c b/drivers/scsi/qla2xxx/qla_nx.c
index 868bfb56d972..d1fd5d62d660 100644
--- a/drivers/scsi/qla2xxx/qla_nx.c
+++ b/drivers/scsi/qla2xxx/qla_nx.c
@@ -1752,11 +1752,13 @@ qla82xx_pci_config(scsi_qla_host_t *vha)
  *
  * Returns 0 on success.
  */
-void
+int
 qla82xx_reset_chip(scsi_qla_host_t *vha)
 {
 	struct qla_hw_data *ha = vha->hw;
 	ha->isp_ops->disable_intrs(ha);
+
+	return QLA_SUCCESS;
 }
 
 void qla82xx_config_rings(struct scsi_qla_host *vha)
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
* Unmerged path drivers/scsi/qla2xxx/qla_sup.c
