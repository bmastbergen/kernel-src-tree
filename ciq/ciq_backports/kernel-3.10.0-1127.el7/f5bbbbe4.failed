blk-mq: sync the update nr_hw_queues with blk_mq_queue_tag_busy_iter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Jianchao Wang <jianchao.w.wang@oracle.com>
commit f5bbbbe4d63577026f908a809f22f5fd5a90ea1f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/f5bbbbe4.failed

For blk-mq, part_in_flight/rw will invoke blk_mq_in_flight/rw to
account the inflight requests. It will access the queue_hw_ctx and
nr_hw_queues w/o any protection. When updating nr_hw_queues and
blk_mq_in_flight/rw occur concurrently, panic comes up.

Before update nr_hw_queues, the q will be frozen. So we could use
q_usage_counter to avoid the race. percpu_ref_is_zero is used here
so that we will not miss any in-flight request. The access to
nr_hw_queues and queue_hw_ctx in blk_mq_queue_tag_busy_iter are
under rcu critical section, __blk_mq_update_nr_hw_queues could use
synchronize_rcu to ensure the zeroed q_usage_counter to be globally
visible.

	Signed-off-by: Jianchao Wang <jianchao.w.wang@oracle.com>
	Reviewed-by: Ming Lei <ming.lei@redhat.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit f5bbbbe4d63577026f908a809f22f5fd5a90ea1f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index fb66815acc5a,81cb84b17b73..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -3068,6 -2976,18 +3068,21 @@@ static void __blk_mq_update_nr_hw_queue
  
  	list_for_each_entry(q, &set->tag_list, tag_set_list)
  		blk_mq_freeze_queue(q);
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Sync with blk_mq_queue_tag_busy_iter.
+ 	 */
+ 	synchronize_rcu();
+ 	/*
+ 	 * Switch IO scheduler to 'none', cleaning up the data associated
+ 	 * with the previous scheduler. We will switch back once we are done
+ 	 * updating the new sw to hw queue mappings.
+ 	 */
+ 	list_for_each_entry(q, &set->tag_list, tag_set_list)
+ 		if (!blk_mq_elv_switch_none(&head, q))
+ 			goto switch_back;
++>>>>>>> f5bbbbe4d635 (blk-mq: sync the update nr_hw_queues with blk_mq_queue_tag_busy_iter)
  
  	set->nr_hw_queues = nr_hw_queues;
  	blk_mq_update_queue_map(set);
diff --git a/block/blk-mq-tag.c b/block/blk-mq-tag.c
index 077457fdfef0..f0552c69b9e7 100644
--- a/block/blk-mq-tag.c
+++ b/block/blk-mq-tag.c
@@ -345,6 +345,18 @@ void blk_mq_queue_tag_busy_iter(struct request_queue *q, busy_iter_fn *fn,
 	struct blk_mq_hw_ctx *hctx;
 	int i;
 
+	/*
+	 * __blk_mq_update_nr_hw_queues will update the nr_hw_queues and
+	 * queue_hw_ctx after freeze the queue. So we could use q_usage_counter
+	 * to avoid race with it. __blk_mq_update_nr_hw_queues will users
+	 * synchronize_rcu to ensure all of the users go out of the critical
+	 * section below and see zeroed q_usage_counter.
+	 */
+	rcu_read_lock();
+	if (percpu_ref_is_zero(&q->q_usage_counter)) {
+		rcu_read_unlock();
+		return;
+	}
 
 	queue_for_each_hw_ctx(q, hctx, i) {
 		struct blk_mq_tags *tags = hctx->tags;
@@ -360,7 +372,7 @@ void blk_mq_queue_tag_busy_iter(struct request_queue *q, busy_iter_fn *fn,
 			bt_for_each(hctx, &tags->breserved_tags, fn, priv, true);
 		bt_for_each(hctx, &tags->bitmap_tags, fn, priv, false);
 	}
-
+	rcu_read_unlock();
 }
 
 static int bt_alloc(struct sbitmap_queue *bt, unsigned int depth,
* Unmerged path block/blk-mq.c
