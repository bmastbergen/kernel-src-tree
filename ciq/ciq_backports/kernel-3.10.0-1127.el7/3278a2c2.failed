ipc: conserve sequence numbers in ipcmni_extend mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [ipc] conserve sequence numbers in ipcmni_extend mode (Waiman Long) [1373519]
Rebuild_FUZZ: 94.95%
commit-author Manfred Spraul <manfred@colorfullife.com>
commit 3278a2c20cb302d27e6f6ee45a3f57361176e426
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/3278a2c2.failed

Rewrite, based on the patch from Waiman Long:

The mixing in of a sequence number into the IPC IDs is probably to avoid
ID reuse in userspace as much as possible.  With ipcmni_extend mode, the
number of usable sequence numbers is greatly reduced leading to higher
chance of ID reuse.

To address this issue, we need to conserve the sequence number space as
much as possible.  Right now, the sequence number is incremented for
every new ID created.  In reality, we only need to increment the
sequence number when new allocated ID is not greater than the last one
allocated.  It is in such case that the new ID may collide with an
existing one.  This is being done irrespective of the ipcmni mode.

In order to avoid any races, the index is first allocated and then the
pointer is replaced.

Changes compared to the initial patch:
 - Handle failures from idr_alloc().
 - Avoid that concurrent operations can see the wrong sequence number.
   (This is achieved by using idr_replace()).
 - IPCMNI_SEQ_SHIFT is not a constant, thus renamed to
   ipcmni_seq_shift().
 - IPCMNI_SEQ_MAX is not a constant, thus renamed to ipcmni_seq_max().

Link: http://lkml.kernel.org/r/20190329204930.21620-2-longman@redhat.com
	Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
	Signed-off-by: Waiman Long <longman@redhat.com>
	Suggested-by: Matthew Wilcox <willy@infradead.org>
	Acked-by: Waiman Long <longman@redhat.com>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: Davidlohr Bueso <dbueso@suse.de>
	Cc: "Eric W . Biederman" <ebiederm@xmission.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
	Cc: Takashi Iwai <tiwai@suse.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 3278a2c20cb302d27e6f6ee45a3f57361176e426)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/ipc_namespace.h
#	ipc/util.c
#	ipc/util.h
diff --cc include/linux/ipc_namespace.h
index 3077f12384f0,c309f43bde45..000000000000
--- a/include/linux/ipc_namespace.h
+++ b/include/linux/ipc_namespace.h
@@@ -21,10 -16,14 +21,16 @@@ struct user_namespace
  struct ipc_ids {
  	int in_use;
  	unsigned short seq;
 +	unsigned short seq_max;
  	struct rw_semaphore rwsem;
  	struct idr ipcs_idr;
++<<<<<<< HEAD
++=======
+ 	int max_idx;
+ 	int last_idx;	/* For wrap around detection */
+ #ifdef CONFIG_CHECKPOINT_RESTORE
++>>>>>>> 3278a2c20cb3 (ipc: conserve sequence numbers in ipcmni_extend mode)
  	int next_id;
 -#endif
 -	struct rhashtable key_ht;
  };
  
  struct ipc_namespace {
diff --cc ipc/util.c
index 1df75a61612b,71f3f3982fc8..000000000000
--- a/ipc/util.c
+++ b/ipc/util.c
@@@ -130,30 -97,32 +130,39 @@@ static int __init ipc_init(void
  }
  device_initcall(ipc_init);
  
 -static const struct rhashtable_params ipc_kht_params = {
 -	.head_offset		= offsetof(struct kern_ipc_perm, khtnode),
 -	.key_offset		= offsetof(struct kern_ipc_perm, key),
 -	.key_len		= FIELD_SIZEOF(struct kern_ipc_perm, key),
 -	.automatic_shrinking	= true,
 -};
 -
  /**
 - * ipc_init_ids	- initialise ipc identifiers
 - * @ids: ipc identifier set
 + *	ipc_init_ids		-	initialise IPC identifiers
 + *	@ids: Identifier set
   *
 - * Set up the sequence range to use for the ipc identifier range (limited
 - * below ipc_mni) then initialise the keys hashtable and ids idr.
 + *	Set up the sequence range to use for the ipc identifier range (limited
 + *	below IPCMNI) then initialise the ids idr.
   */
 + 
  void ipc_init_ids(struct ipc_ids *ids)
  {
 +	init_rwsem(&ids->rwsem);
 +
  	ids->in_use = 0;
  	ids->seq = 0;
++<<<<<<< HEAD
++=======
+ 	init_rwsem(&ids->rwsem);
+ 	rhashtable_init(&ids->key_ht, &ipc_kht_params);
+ 	idr_init(&ids->ipcs_idr);
+ 	ids->max_idx = -1;
+ 	ids->last_idx = -1;
+ #ifdef CONFIG_CHECKPOINT_RESTORE
++>>>>>>> 3278a2c20cb3 (ipc: conserve sequence numbers in ipcmni_extend mode)
  	ids->next_id = -1;
 -#endif
 +	{
 +		int seq_limit = INT_MAX/SEQ_MULTIPLIER;
 +		if (seq_limit > USHRT_MAX)
 +			ids->seq_max = USHRT_MAX;
 +		 else
 +		 	ids->seq_max = seq_limit;
 +	}
 +
 +	idr_init(&ids->ipcs_idr);
  }
  
  #ifdef CONFIG_PROC_FS
@@@ -191,39 -159,99 +200,112 @@@ void __init ipc_init_proc_interface(con
  #endif
  
  /**
 - * ipc_findkey	- find a key in an ipc identifier set
 - * @ids: ipc identifier set
 - * @key: key to find
 - *
 - * Returns the locked pointer to the ipc structure if found or NULL
 - * otherwise. If key is found ipc points to the owning ipc structure
 - *
 - * Called with writer ipc_ids.rwsem held.
 + *	ipc_findkey	-	find a key in an ipc identifier set	
 + *	@ids: Identifier set
 + *	@key: The key to find
 + *	
 + *	Requires ipc_ids.rwsem locked.
 + *	Returns the LOCKED pointer to the ipc structure if found or NULL
 + *	if not.
 + *	If key is found ipc points to the owning ipc structure
   */
 + 
  static struct kern_ipc_perm *ipc_findkey(struct ipc_ids *ids, key_t key)
  {
 -	struct kern_ipc_perm *ipcp;
 +	struct kern_ipc_perm *ipc;
 +	int next_id;
 +	int total;
  
 -	ipcp = rhashtable_lookup_fast(&ids->key_ht, &key,
 -					      ipc_kht_params);
 -	if (!ipcp)
 -		return NULL;
 +	for (total = 0, next_id = 0; total < ids->in_use; next_id++) {
 +		ipc = idr_find(&ids->ipcs_idr, next_id);
  
 -	rcu_read_lock();
 -	ipc_lock_object(ipcp);
 -	return ipcp;
 -}
 +		if (ipc == NULL)
 +			continue;
  
++<<<<<<< HEAD
 +		if (ipc->key != key) {
 +			total++;
 +			continue;
 +		}
 +
 +		rcu_read_lock();
 +		ipc_lock_object(ipc);
 +		return ipc;
 +	}
 +
 +	return NULL;
++=======
+ /*
+  * Insert new IPC object into idr tree, and set sequence number and id
+  * in the correct order.
+  * Especially:
+  * - the sequence number must be set before inserting the object into the idr,
+  *   because the sequence number is accessed without a lock.
+  * - the id can/must be set after inserting the object into the idr.
+  *   All accesses must be done after getting kern_ipc_perm.lock.
+  *
+  * The caller must own kern_ipc_perm.lock.of the new object.
+  * On error, the function returns a (negative) error code.
+  *
+  * To conserve sequence number space, especially with extended ipc_mni,
+  * the sequence number is incremented only when the returned ID is less than
+  * the last one.
+  */
+ static inline int ipc_idr_alloc(struct ipc_ids *ids, struct kern_ipc_perm *new)
+ {
+ 	int idx, next_id = -1;
+ 
+ #ifdef CONFIG_CHECKPOINT_RESTORE
+ 	next_id = ids->next_id;
+ 	ids->next_id = -1;
+ #endif
+ 
+ 	/*
+ 	 * As soon as a new object is inserted into the idr,
+ 	 * ipc_obtain_object_idr() or ipc_obtain_object_check() can find it,
+ 	 * and the lockless preparations for ipc operations can start.
+ 	 * This means especially: permission checks, audit calls, allocation
+ 	 * of undo structures, ...
+ 	 *
+ 	 * Thus the object must be fully initialized, and if something fails,
+ 	 * then the full tear-down sequence must be followed.
+ 	 * (i.e.: set new->deleted, reduce refcount, call_rcu())
+ 	 */
+ 
+ 	if (next_id < 0) { /* !CHECKPOINT_RESTORE or next_id is unset */
+ 
+ 		/* allocate the idx, with a NULL struct kern_ipc_perm */
+ 		idx = idr_alloc(&ids->ipcs_idr, NULL, 0, 0, GFP_NOWAIT);
+ 
+ 		if (idx >= 0) {
+ 			/*
+ 			 * idx got allocated successfully.
+ 			 * Now calculate the sequence number and set the
+ 			 * pointer for real.
+ 			 */
+ 			if (idx <= ids->last_idx) {
+ 				ids->seq++;
+ 				if (ids->seq >= ipcid_seq_max())
+ 					ids->seq = 0;
+ 			}
+ 			ids->last_idx = idx;
+ 
+ 			new->seq = ids->seq;
+ 			/* no need for smp_wmb(), this is done
+ 			 * inside idr_replace, as part of
+ 			 * rcu_assign_pointer
+ 			 */
+ 			idr_replace(&ids->ipcs_idr, new, idx);
+ 		}
+ 	} else {
+ 		new->seq = ipcid_to_seqx(next_id);
+ 		idx = idr_alloc(&ids->ipcs_idr, new, ipcid_to_idx(next_id),
+ 				0, GFP_NOWAIT);
+ 	}
+ 	if (idx >= 0)
+ 		new->id = (new->seq << ipcmni_seq_shift()) + idx;
+ 	return idx;
++>>>>>>> 3278a2c20cb3 (ipc: conserve sequence numbers in ipcmni_extend mode)
  }
  
  /**
diff --cc ipc/util.h
index 778c12c8c204,8c834ed39012..000000000000
--- a/ipc/util.h
+++ b/ipc/util.h
@@@ -12,15 -13,43 +12,35 @@@
  
  #include <linux/unistd.h>
  #include <linux/err.h>
 -#include <linux/ipc_namespace.h>
  
 -/*
 - * The IPC ID contains 2 separate numbers - index and sequence number.
 - * By default,
 - *   bits  0-14: index (32k, 15 bits)
 - *   bits 15-30: sequence number (64k, 16 bits)
 - *
 - * When IPCMNI extension mode is turned on, the composition changes:
 - *   bits  0-23: index (16M, 24 bits)
 - *   bits 24-30: sequence number (128, 7 bits)
 - */
 -#define IPCMNI_SHIFT		15
 -#define IPCMNI_EXTEND_SHIFT	24
 -#define IPCMNI			(1 << IPCMNI_SHIFT)
 -#define IPCMNI_EXTEND		(1 << IPCMNI_EXTEND_SHIFT)
 +#define IPCMNI 32768  /* <= MAX_INT limit for ipc arrays (including sysctl changes) */
 +#define SEQ_MULTIPLIER	(IPCMNI)
  
++<<<<<<< HEAD
 +void sem_init (void);
 +void msg_init (void);
 +void shm_init (void);
++=======
+ #ifdef CONFIG_SYSVIPC_SYSCTL
+ extern int ipc_mni;
+ extern int ipc_mni_shift;
+ 
+ #define ipcmni_seq_shift()	ipc_mni_shift
+ #define IPCMNI_IDX_MASK		((1 << ipc_mni_shift) - 1)
+ 
+ #else /* CONFIG_SYSVIPC_SYSCTL */
+ 
+ #define ipc_mni			IPCMNI
+ #define ipcmni_seq_shift()	IPCMNI_SHIFT
+ #define IPCMNI_IDX_MASK		((1 << IPCMNI_SHIFT) - 1)
+ #endif /* CONFIG_SYSVIPC_SYSCTL */
+ 
+ void sem_init(void);
+ void msg_init(void);
+ void shm_init(void);
++>>>>>>> 3278a2c20cb3 (ipc: conserve sequence numbers in ipcmni_extend mode)
  
  struct ipc_namespace;
 -struct pid_namespace;
  
  #ifdef CONFIG_POSIX_MQUEUE
  extern void mq_clear_sbinfo(struct ipc_namespace *ns);
@@@ -99,8 -122,9 +119,14 @@@ void __init ipc_init_proc_interface(con
  #define IPC_MSG_IDS	1
  #define IPC_SHM_IDS	2
  
++<<<<<<< HEAD
 +#define ipcid_to_idx(id) ((id) % SEQ_MULTIPLIER)
 +#define ipcid_to_seqx(id) ((id) / SEQ_MULTIPLIER)
++=======
+ #define ipcid_to_idx(id)  ((id) & IPCMNI_IDX_MASK)
+ #define ipcid_to_seqx(id) ((id) >> ipcmni_seq_shift())
+ #define ipcid_seq_max()	  (INT_MAX >> ipcmni_seq_shift())
++>>>>>>> 3278a2c20cb3 (ipc: conserve sequence numbers in ipcmni_extend mode)
  
  /* must be called with ids->rwsem acquired for writing */
  int ipc_addid(struct ipc_ids *, struct kern_ipc_perm *, int);
* Unmerged path include/linux/ipc_namespace.h
* Unmerged path ipc/util.c
* Unmerged path ipc/util.h
