scsi: scsi-mq: Always unprepare before requeuing a request

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Bart Van Assche <bart.vanassche@wdc.com>
commit a45a1f3614182267803baadba657b59e2ddc0545
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/a45a1f36.failed

One of the two scsi-mq functions that requeue a request unprepares a
request before requeueing (scsi_io_completion()) but the other function
not (__scsi_queue_insert()). Make sure that a request is unprepared
before requeuing it.

Fixes: commit d285203cf647 ("scsi: add support for a blk-mq based I/O path.")
	Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Hannes Reinecke <hare@suse.com>
	Cc: Damien Le Moal <damien.lemoal@wdc.com>
	Cc: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit a45a1f3614182267803baadba657b59e2ddc0545)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_lib.c
diff --cc drivers/scsi/scsi_lib.c
index b802e0e13ac4,9cf6a80fe297..000000000000
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@@ -38,8 -38,62 +38,61 @@@
  #include "scsi_priv.h"
  #include "scsi_logging.h"
  
 -static struct kmem_cache *scsi_sdb_cache;
 -static struct kmem_cache *scsi_sense_cache;
 -static struct kmem_cache *scsi_sense_isadma_cache;
 -static DEFINE_MUTEX(scsi_sense_cache_mutex);
  
++<<<<<<< HEAD
 +struct kmem_cache *scsi_sdb_cache;
++=======
+ static void scsi_mq_uninit_cmd(struct scsi_cmnd *cmd);
+ 
+ static inline struct kmem_cache *
+ scsi_select_sense_cache(bool unchecked_isa_dma)
+ {
+ 	return unchecked_isa_dma ? scsi_sense_isadma_cache : scsi_sense_cache;
+ }
+ 
+ static void scsi_free_sense_buffer(bool unchecked_isa_dma,
+ 				   unsigned char *sense_buffer)
+ {
+ 	kmem_cache_free(scsi_select_sense_cache(unchecked_isa_dma),
+ 			sense_buffer);
+ }
+ 
+ static unsigned char *scsi_alloc_sense_buffer(bool unchecked_isa_dma,
+ 	gfp_t gfp_mask, int numa_node)
+ {
+ 	return kmem_cache_alloc_node(scsi_select_sense_cache(unchecked_isa_dma),
+ 				     gfp_mask, numa_node);
+ }
+ 
+ int scsi_init_sense_cache(struct Scsi_Host *shost)
+ {
+ 	struct kmem_cache *cache;
+ 	int ret = 0;
+ 
+ 	cache = scsi_select_sense_cache(shost->unchecked_isa_dma);
+ 	if (cache)
+ 		return 0;
+ 
+ 	mutex_lock(&scsi_sense_cache_mutex);
+ 	if (shost->unchecked_isa_dma) {
+ 		scsi_sense_isadma_cache =
+ 			kmem_cache_create("scsi_sense_cache(DMA)",
+ 			SCSI_SENSE_BUFFERSIZE, 0,
+ 			SLAB_HWCACHE_ALIGN | SLAB_CACHE_DMA, NULL);
+ 		if (!scsi_sense_isadma_cache)
+ 			ret = -ENOMEM;
+ 	} else {
+ 		scsi_sense_cache =
+ 			kmem_cache_create("scsi_sense_cache",
+ 			SCSI_SENSE_BUFFERSIZE, 0, SLAB_HWCACHE_ALIGN, NULL);
+ 		if (!scsi_sense_cache)
+ 			ret = -ENOMEM;
+ 	}
+ 
+ 	mutex_unlock(&scsi_sense_cache_mutex);
+ 	return ret;
+ }
++>>>>>>> a45a1f361418 (scsi: scsi-mq: Always unprepare before requeuing a request)
  
  /*
   * When to reinvoke queueing after a resource shortage. It's 3 msecs to
@@@ -983,8 -990,6 +1042,11 @@@ void scsi_io_completion(struct scsi_cmn
  		 * A new command will be prepared and issued.
  		 */
  		if (q->mq_ops) {
++<<<<<<< HEAD
 +			cmd->request->cmd_flags &= ~REQ_DONTPREP;
 +			scsi_mq_uninit_cmd(cmd);
++=======
++>>>>>>> a45a1f361418 (scsi: scsi-mq: Always unprepare before requeuing a request)
  			scsi_mq_requeue_cmd(cmd);
  		} else {
  			scsi_release_buffers(cmd);
* Unmerged path drivers/scsi/scsi_lib.c
