scsi: qla2xxx: Split the __qla2x00_abort_all_cmds() function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Bart Van Assche <bvanassche@acm.org>
commit c4e521b654e15e372a6429e269e7e907b4698224
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/c4e521b6.failed

Nesting in __qla2x00_abort_all_cmds() is way too deep. Reduce the nesting
level by introducing a helper function. This patch does not change any
functionality.

	Reviewed-by: Laurence Oberman <loberman@redhat.com>
	Acked-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Bart Van Assche <bvanassche@acm.org>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit c4e521b654e15e372a6429e269e7e907b4698224)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 9b129f1fdd3e,4a75e0572121..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -1819,50 -1803,7 +1854,54 @@@ __qla2x00_abort_all_cmds(struct qla_qpa
  			req->outstanding_cmds[cnt] = NULL;
  			switch (sp->cmd_type) {
  			case TYPE_SRB:
++<<<<<<< HEAD
 +				if (sp->type == SRB_NVME_CMD ||
 +				    sp->type == SRB_NVME_LS) {
 +					if (!sp_get(sp)) {
 +						/* got sp */
 +						spin_unlock_irqrestore
 +							(qp->qp_lock_ptr,
 +							 flags);
 +						qla_nvme_abort(ha, sp, res);
 +						spin_lock_irqsave
 +							(qp->qp_lock_ptr, flags);
 +					}
 +				} else if (GET_CMD_SP(sp) &&
 +				    !ha->flags.eeh_busy &&
 +				    (!test_bit(ABORT_ISP_ACTIVE,
 +					&vha->dpc_flags)) &&
 +				    !qla2x00_isp_reg_stat(ha) &&
 +				    (sp->type == SRB_SCSI_CMD)) {
 +					/*
 +					 * Don't abort commands in adapter
 +					 * during EEH recovery as it's not
 +					 * accessible/responding.
 +					 *
 +					 * Get a reference to the sp and drop
 +					 * the lock. The reference ensures this
 +					 * sp->done() call and not the call in
 +					 * qla2xxx_eh_abort() ends the SCSI cmd
 +					 * (with result 'res').
 +					 */
 +					if (!sp_get(sp)) {
 +						spin_unlock_irqrestore
 +							(qp->qp_lock_ptr, flags);
 +						status = qla2xxx_eh_abort(
 +							GET_CMD_SP(sp));
 +						spin_lock_irqsave
 +							(qp->qp_lock_ptr, flags);
 +						/*
 +						 * Get rid of extra reference caused
 +						 * by early exit from qla2xxx_eh_abort
 +						 */
 +						if (status == FAST_IO_FAIL)
 +							atomic_dec(&sp->ref_count);
 +					}
 +				}
 +				sp->done(sp, res);
++=======
+ 				qla2x00_abort_srb(qp, sp, res, &flags);
++>>>>>>> c4e521b654e1 (scsi: qla2xxx: Split the __qla2x00_abort_all_cmds() function)
  				break;
  			case TYPE_TGT_CMD:
  				if (!vha->hw->tgt.tgt_ops || !tgt ||
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
