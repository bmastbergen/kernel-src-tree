sched/fair: Reset se-depth when task switched to FAIR

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Michael wang <wangyun@linux.vnet.ibm.com>
commit eb7a59b2c888c2518ba2c9d0020343ca71aa9dee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/eb7a59b2.failed

Sasha reported:

[  522.645288] BUG: unable to handle kernel NULL pointer dereference at ...
[  522.646271] IP: [<ffffffff81186c6f>] check_preempt_wakeup+0x11f/0x210
		...
[  522.650021] Call Trace:
[  522.650021]  <IRQ>
[  522.650021]  [<ffffffff8117361d>] check_preempt_curr+0x3d/0xb0
[  522.650021]  [<ffffffff81175d88>] ttwu_do_wakeup+0x18/0x130
		...

which was caused by the se-depth changed during the time when task is not
FAIR, and we will use the wrong depth value after it switched back to FAIR.

This patch reset the depth at the time when task switched to FAIR, make sure
that we always have the correct value when task is FAIR.

	Cc: Ingo Molnar <mingo@kernel.org>
	Reported-by: Sasha Levin <sasha.levin@oracle.com>
	Tested-by: Sasha Levin <sasha.levin@oracle.com>
	Signed-off-by: Michael Wang <wangyun@linux.vnet.ibm.com>
	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/5305732D.70001@linux.vnet.ibm.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit eb7a59b2c888c2518ba2c9d0020343ca71aa9dee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/fair.c
diff --cc kernel/sched/fair.c
index f3df0d8beb03,280da893cd0f..000000000000
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@@ -7602,7 -7317,15 +7602,19 @@@ static void switched_from_fair(struct r
   */
  static void switched_to_fair(struct rq *rq, struct task_struct *p)
  {
++<<<<<<< HEAD
 +	if (!task_on_rq_queued(p))
++=======
+ 	struct sched_entity *se = &p->se;
+ #ifdef CONFIG_FAIR_GROUP_SCHED
+ 	/*
+ 	 * Since the real-depth could have been changed (only FAIR
+ 	 * class maintain depth value), reset depth properly.
+ 	 */
+ 	se->depth = se->parent ? se->parent->depth + 1 : 0;
+ #endif
+ 	if (!se->on_rq)
++>>>>>>> eb7a59b2c888 (sched/fair: Reset se-depth when task switched to FAIR)
  		return;
  
  	/*
* Unmerged path kernel/sched/fair.c
