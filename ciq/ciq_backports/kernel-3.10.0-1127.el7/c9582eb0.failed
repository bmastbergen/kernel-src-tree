fuse: Fail all requests with invalid uids or gids

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit c9582eb0ff7d2b560be60eafab29183882cdc82b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/c9582eb0.failed

Upon a cursory examinination the uid and gid of a fuse request are
necessary for correct operation.  Failing a fuse request where those
values are not reliable seems a straight forward and reliable means of
ensuring that fuse requests with bad data are not sent or processed.

In most cases the vfs will avoid actions it suspects will cause
an inode write back of an inode with an invalid uid or gid.  But that does
not map precisely to what fuse is doing, so test for this and solve
this at the fuse level as well.

Performing this work in fuse_req_init_context is cheap as the code is
already performing the translation here and only needs to check the
result of the translation to see if things are not representable in
a form the fuse server can handle.

[SzM] Don't zero the context for the nofail case, just keep using the
munging version (makes sense for debugging and doesn't hurt).

	Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit c9582eb0ff7d2b560be60eafab29183882cdc82b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/dev.c
diff --cc fs/fuse/dev.c
index 253369bc378a,4852f8803156..000000000000
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@@ -121,15 -109,14 +121,23 @@@ void __fuse_get_request(struct fuse_re
  /* Must be called with > 1 refcount */
  static void __fuse_put_request(struct fuse_req *req)
  {
 -	refcount_dec(&req->count);
 +	BUG_ON(atomic_read(&req->count) < 2);
 +	atomic_dec(&req->count);
  }
  
++<<<<<<< HEAD
 +static void fuse_req_init_context(struct fuse_conn *fc, struct fuse_req *req)
 +{
 +	req->in.h.uid = from_kuid_munged(&init_user_ns, current_fsuid());
 +	req->in.h.gid = from_kgid_munged(&init_user_ns, current_fsgid());
 +	req->in.h.pid = pid_nr_ns(task_pid(current), fc->pid_ns);
++=======
+ void fuse_set_initialized(struct fuse_conn *fc)
+ {
+ 	/* Make sure stores before this are seen on another CPU */
+ 	smp_wmb();
+ 	fc->initialized = 1;
++>>>>>>> c9582eb0ff7d (fuse: Fail all requests with invalid uids or gids)
  }
  
  static bool fuse_block_alloc(struct fuse_conn *fc, bool for_background)
@@@ -169,9 -156,19 +177,25 @@@ static struct fuse_req *__fuse_get_req(
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	fuse_req_init_context(fc, req);
 +	req->waiting = 1;
 +	req->background = for_background;
++=======
+ 	req->in.h.uid = from_kuid(&init_user_ns, current_fsuid());
+ 	req->in.h.gid = from_kgid(&init_user_ns, current_fsgid());
+ 	req->in.h.pid = pid_nr_ns(task_pid(current), fc->pid_ns);
+ 
+ 	__set_bit(FR_WAITING, &req->flags);
+ 	if (for_background)
+ 		__set_bit(FR_BACKGROUND, &req->flags);
+ 
+ 	if (unlikely(req->in.h.uid == ((uid_t)-1) ||
+ 		     req->in.h.gid == ((gid_t)-1))) {
+ 		fuse_put_request(fc, req);
+ 		return ERR_PTR(-EOVERFLOW);
+ 	}
++>>>>>>> c9582eb0ff7d (fuse: Fail all requests with invalid uids or gids)
  	return req;
  
   out:
@@@ -258,9 -257,12 +282,18 @@@ struct fuse_req *fuse_get_req_nofail_no
  	if (!req)
  		req = get_reserved_req(fc, file);
  
++<<<<<<< HEAD
 +	fuse_req_init_context(fc, req);
 +	req->waiting = 1;
 +	req->background = 0;
++=======
+ 	req->in.h.uid = from_kuid_munged(&init_user_ns, current_fsuid());
+ 	req->in.h.gid = from_kgid_munged(&init_user_ns, current_fsgid());
+ 	req->in.h.pid = pid_nr_ns(task_pid(current), fc->pid_ns);
+ 
+ 	__set_bit(FR_WAITING, &req->flags);
+ 	__clear_bit(FR_BACKGROUND, &req->flags);
++>>>>>>> c9582eb0ff7d (fuse: Fail all requests with invalid uids or gids)
  	return req;
  }
  
* Unmerged path fs/fuse/dev.c
