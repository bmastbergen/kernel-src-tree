sched: Move rq->idle_stamp up to the core

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Daniel Lezcano <daniel.lezcano@linaro.org>
commit 3c4017c13f91069194fce3160944efec50f15a6e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/3c4017c1.failed

idle_balance() modifies the rq->idle_stamp field, making this information
shared across core.c and fair.c.

As we know if the cpu is going to idle or not with the previous patch, let's
encapsulate the rq->idle_stamp information in core.c by moving it up to the
caller.

The idle_balance() function returns true in case a balancing occured and the
cpu won't be idle, false if no balance happened and the cpu is going idle.

	Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
	Cc: alex.shi@linaro.org
	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/1389949444-14821-3-git-send-email-daniel.lezcano@linaro.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 3c4017c13f91069194fce3160944efec50f15a6e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/core.c
#	kernel/sched/fair.c
#	kernel/sched/sched.h
diff --cc kernel/sched/core.c
index 9474c46ea21e,417cf657a606..000000000000
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@@ -3586,8 -2704,15 +3586,20 @@@ need_resched
  
  	pre_schedule(rq, prev);
  
++<<<<<<< HEAD
 +	if (unlikely(!rq->nr_running))
 +		idle_balance(cpu, rq);
++=======
+ 	if (unlikely(!rq->nr_running)) {
+ 		/*
+ 		 * We must set idle_stamp _before_ calling idle_balance(), such
+ 		 * that we measure the duration of idle_balance() as idle time.
+ 		 */
+ 		rq->idle_stamp = rq_clock(rq);
+ 		if (idle_balance(rq))
+ 			rq->idle_stamp = 0;
+ 	}
++>>>>>>> 3c4017c13f91 (sched: Move rq->idle_stamp up to the core)
  
  	put_prev_task(rq, prev);
  	next = pick_next_task(rq);
diff --cc kernel/sched/fair.c
index f3df0d8beb03,04fea7744a9f..000000000000
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@@ -6859,25 -6531,16 +6859,34 @@@ update_next_balance(struct sched_domai
   * idle_balance is called by schedule() if this_cpu is about to become
   * idle. Attempts to pull tasks from other CPUs.
   */
++<<<<<<< HEAD
 +void idle_balance(int this_cpu, struct rq *this_rq)
++=======
+ int idle_balance(struct rq *this_rq)
++>>>>>>> 3c4017c13f91 (sched: Move rq->idle_stamp up to the core)
  {
 +	unsigned long next_balance = jiffies + HZ;
  	struct sched_domain *sd;
  	int pulled_task = 0;
 -	unsigned long next_balance = jiffies + HZ;
  	u64 curr_cost = 0;
 -	int this_cpu = this_rq->cpu;
  
++<<<<<<< HEAD
 +	this_rq->idle_stamp = rq_clock(this_rq);
 +
 +	if (this_rq->avg_idle < sysctl_sched_migration_cost ||
 +	    !this_rq->rd->overload) {
 +		rcu_read_lock();
 +		sd = rcu_dereference_check_sched_domain(this_rq->sd);
 +		if (sd)
 +			update_next_balance(sd, 0, &next_balance);
 +		rcu_read_unlock();
 +
 +		goto out;
 +	}
++=======
+ 	if (this_rq->avg_idle < sysctl_sched_migration_cost)
+ 		return 0;
++>>>>>>> 3c4017c13f91 (sched: Move rq->idle_stamp up to the core)
  
  	/*
  	 * Drop the rq->lock, but keep IRQ/preempt disabled.
@@@ -6912,25 -6575,30 +6921,46 @@@
  			curr_cost += domain_cost;
  		}
  
++<<<<<<< HEAD
 +		update_next_balance(sd, 0, &next_balance);
 +
 +		/*
 +		 * Stop searching for tasks to pull if there are
 +		 * now runnable tasks on this rq.
 +		 */
 +		if (pulled_task || this_rq->nr_running > 0) {
 +			this_rq->idle_stamp = 0;
++=======
+ 		interval = msecs_to_jiffies(sd->balance_interval);
+ 		if (time_after(next_balance, sd->last_balance + interval))
+ 			next_balance = sd->last_balance + interval;
+ 		if (pulled_task)
++>>>>>>> 3c4017c13f91 (sched: Move rq->idle_stamp up to the core)
  			break;
- 		}
  	}
  	rcu_read_unlock();
  
  	raw_spin_lock(&this_rq->lock);
  
++<<<<<<< HEAD
 +out:
 +	/* Move the next balance forward */
 +	if (time_after(this_rq->next_balance, next_balance))
++=======
+ 	/*
+ 	 * While browsing the domains, we released the rq lock.
+ 	 * A task could have be enqueued in the meantime
+ 	 */
+ 	if (this_rq->nr_running && !pulled_task)
+ 		return 1;
+ 
+ 	if (pulled_task || time_after(jiffies, this_rq->next_balance)) {
+ 		/*
+ 		 * We are going idle. next_balance may be set based on
+ 		 * a busy processor. So reset next_balance.
+ 		 */
++>>>>>>> 3c4017c13f91 (sched: Move rq->idle_stamp up to the core)
  		this_rq->next_balance = next_balance;
 -	}
  
  	if (curr_cost > this_rq->max_idle_balance_cost)
  		this_rq->max_idle_balance_cost = curr_cost;
diff --cc kernel/sched/sched.h
index 38c9ae998b34,bb89991ee409..000000000000
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@@ -1313,23 -1157,11 +1313,28 @@@ extern const struct sched_class idle_sc
  
  extern void update_group_power(struct sched_domain *sd, int cpu);
  
++<<<<<<< HEAD
 +extern void trigger_load_balance(struct rq *rq, int cpu);
 +extern void idle_balance(int this_cpu, struct rq *this_rq);
++=======
+ extern void trigger_load_balance(struct rq *rq);
+ extern int idle_balance(struct rq *this_rq);
++>>>>>>> 3c4017c13f91 (sched: Move rq->idle_stamp up to the core)
 +
 +extern void sched_cpu_activate(unsigned int cpu);
 +extern void sched_cpu_deactivate(unsigned int cpu);
  
 +/*
 + * Only depends on SMP, FAIR_GROUP_SCHED may be removed when runnable_avg
 + * becomes useful in lb
 + */
 +#if defined(CONFIG_FAIR_GROUP_SCHED)
  extern void idle_enter_fair(struct rq *this_rq);
  extern void idle_exit_fair(struct rq *this_rq);
 +#else
 +static inline void idle_enter_fair(struct rq *this_rq) {}
 +static inline void idle_exit_fair(struct rq *this_rq) {}
 +#endif
  
  #else	/* CONFIG_SMP */
  
* Unmerged path kernel/sched/core.c
* Unmerged path kernel/sched/fair.c
* Unmerged path kernel/sched/sched.h
