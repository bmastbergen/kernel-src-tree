mac80211: keep BHs disabled while calling drv_tx_wake_queue()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Johannes Berg <johannes.berg@intel.com>
commit d8dec42b5c2d2b273bc30b0e073cfbe832d69902
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/d8dec42b.failed

Drivers typically expect this, as it's the case for almost all cases
where this is called (i.e. from the TX path). Also, the code in mac80211
itself (if the driver calls ieee80211_tx_dequeue()) expects this as it
uses this_cpu_ptr() without additional protection.

This should fix various reports of the problem:
https://bugzilla.kernel.org/show_bug.cgi?id=204127
https://lore.kernel.org/linux-wireless/CAN5HydrWb3o_FE6A1XDnP1E+xS66d5kiEuhHfiGKkLNQokx13Q@mail.gmail.com/
https://lore.kernel.org/lkml/nycvar.YFH.7.76.1909111238470.473@cbobk.fhfr.pm/

	Cc: stable@vger.kernel.org
Reported-and-tested-by: Jiri Kosina <jkosina@suse.cz>
	Reported-by: Aaron Hill <aa1ronham@gmail.com>
	Reported-by: Lukas Redlinger <rel+kernel@agilox.net>
	Reported-by: Oleksii Shevchuk <alxchk@gmail.com>
Fixes: 21a5d4c3a45c ("mac80211: add stop/start logic for software TXQs")
Link: https://lore.kernel.org/r/1569928763-I3e8838c5ecad878e59d4a94eb069a90f6641461a@changeid
	Reviewed-by: Toke Høiland-Jørgensen <toke@redhat.com>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit d8dec42b5c2d2b273bc30b0e073cfbe832d69902)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/util.c
diff --cc net/mac80211/util.c
index ba73e9893408,32a7a53833c0..000000000000
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@@ -240,6 -237,114 +240,117 @@@ __le16 ieee80211_ctstoself_duration(str
  }
  EXPORT_SYMBOL(ieee80211_ctstoself_duration);
  
++<<<<<<< HEAD
++=======
+ static void __ieee80211_wake_txqs(struct ieee80211_sub_if_data *sdata, int ac)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct ieee80211_vif *vif = &sdata->vif;
+ 	struct fq *fq = &local->fq;
+ 	struct ps_data *ps = NULL;
+ 	struct txq_info *txqi;
+ 	struct sta_info *sta;
+ 	int i;
+ 
+ 	local_bh_disable();
+ 	spin_lock(&fq->lock);
+ 
+ 	if (sdata->vif.type == NL80211_IFTYPE_AP)
+ 		ps = &sdata->bss->ps;
+ 
+ 	sdata->vif.txqs_stopped[ac] = false;
+ 
+ 	list_for_each_entry_rcu(sta, &local->sta_list, list) {
+ 		if (sdata != sta->sdata)
+ 			continue;
+ 
+ 		for (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {
+ 			struct ieee80211_txq *txq = sta->sta.txq[i];
+ 
+ 			if (!txq)
+ 				continue;
+ 
+ 			txqi = to_txq_info(txq);
+ 
+ 			if (ac != txq->ac)
+ 				continue;
+ 
+ 			if (!test_and_clear_bit(IEEE80211_TXQ_STOP_NETIF_TX,
+ 						&txqi->flags))
+ 				continue;
+ 
+ 			spin_unlock(&fq->lock);
+ 			drv_wake_tx_queue(local, txqi);
+ 			spin_lock(&fq->lock);
+ 		}
+ 	}
+ 
+ 	if (!vif->txq)
+ 		goto out;
+ 
+ 	txqi = to_txq_info(vif->txq);
+ 
+ 	if (!test_and_clear_bit(IEEE80211_TXQ_STOP_NETIF_TX, &txqi->flags) ||
+ 	    (ps && atomic_read(&ps->num_sta_ps)) || ac != vif->txq->ac)
+ 		goto out;
+ 
+ 	spin_unlock(&fq->lock);
+ 
+ 	drv_wake_tx_queue(local, txqi);
+ 	local_bh_enable();
+ 	return;
+ out:
+ 	spin_unlock(&fq->lock);
+ 	local_bh_enable();
+ }
+ 
+ static void
+ __releases(&local->queue_stop_reason_lock)
+ __acquires(&local->queue_stop_reason_lock)
+ _ieee80211_wake_txqs(struct ieee80211_local *local, unsigned long *flags)
+ {
+ 	struct ieee80211_sub_if_data *sdata;
+ 	int n_acs = IEEE80211_NUM_ACS;
+ 	int i;
+ 
+ 	rcu_read_lock();
+ 
+ 	if (local->hw.queues < IEEE80211_NUM_ACS)
+ 		n_acs = 1;
+ 
+ 	for (i = 0; i < local->hw.queues; i++) {
+ 		if (local->queue_stop_reasons[i])
+ 			continue;
+ 
+ 		spin_unlock_irqrestore(&local->queue_stop_reason_lock, *flags);
+ 		list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+ 			int ac;
+ 
+ 			for (ac = 0; ac < n_acs; ac++) {
+ 				int ac_queue = sdata->vif.hw_queue[ac];
+ 
+ 				if (ac_queue == i ||
+ 				    sdata->vif.cab_queue == i)
+ 					__ieee80211_wake_txqs(sdata, ac);
+ 			}
+ 		}
+ 		spin_lock_irqsave(&local->queue_stop_reason_lock, *flags);
+ 	}
+ 
+ 	rcu_read_unlock();
+ }
+ 
+ void ieee80211_wake_txqs(unsigned long data)
+ {
+ 	struct ieee80211_local *local = (struct ieee80211_local *)data;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+ 	_ieee80211_wake_txqs(local, &flags);
+ 	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+ }
+ 
++>>>>>>> d8dec42b5c2d (mac80211: keep BHs disabled while calling drv_tx_wake_queue())
  void ieee80211_propagate_queue_wake(struct ieee80211_local *local, int queue)
  {
  	struct ieee80211_sub_if_data *sdata;
* Unmerged path net/mac80211/util.c
