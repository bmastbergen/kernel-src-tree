dm delay: fix a crash when invalid device is specified

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Mikulas Patocka <mpatocka@redhat.com>
commit 81bc6d150ace6250503b825d9d0c10f7bbd24095
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/81bc6d15.failed

When the target line contains an invalid device, delay_ctr() will call
delay_dtr() with NULL workqueue.  Attempting to destroy the NULL
workqueue causes a crash.

	Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 81bc6d150ace6250503b825d9d0c10f7bbd24095)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-delay.c
diff --cc drivers/md/dm-delay.c
index d98a56468add,f496213f8b67..000000000000
--- a/drivers/md/dm-delay.c
+++ b/drivers/md/dm-delay.c
@@@ -117,6 -117,51 +117,54 @@@ static void flush_expired_bios(struct w
  	flush_bios(flush_delayed_bios(dc, 0));
  }
  
++<<<<<<< HEAD
++=======
+ static void delay_dtr(struct dm_target *ti)
+ {
+ 	struct delay_c *dc = ti->private;
+ 
+ 	if (dc->kdelayd_wq)
+ 		destroy_workqueue(dc->kdelayd_wq);
+ 
+ 	if (dc->read.dev)
+ 		dm_put_device(ti, dc->read.dev);
+ 	if (dc->write.dev)
+ 		dm_put_device(ti, dc->write.dev);
+ 	if (dc->flush.dev)
+ 		dm_put_device(ti, dc->flush.dev);
+ 
+ 	mutex_destroy(&dc->timer_lock);
+ 
+ 	kfree(dc);
+ }
+ 
+ static int delay_class_ctr(struct dm_target *ti, struct delay_class *c, char **argv)
+ {
+ 	int ret;
+ 	unsigned long long tmpll;
+ 	char dummy;
+ 
+ 	if (sscanf(argv[1], "%llu%c", &tmpll, &dummy) != 1 || tmpll != (sector_t)tmpll) {
+ 		ti->error = "Invalid device sector";
+ 		return -EINVAL;
+ 	}
+ 	c->start = tmpll;
+ 
+ 	if (sscanf(argv[2], "%u%c", &c->delay, &dummy) != 1) {
+ 		ti->error = "Invalid delay";
+ 		return -EINVAL;
+ 	}
+ 
+ 	ret = dm_get_device(ti, argv[0], dm_table_get_mode(ti->table), &c->dev);
+ 	if (ret) {
+ 		ti->error = "Device lookup failed";
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 81bc6d150ace (dm delay: fix a crash when invalid device is specified)
  /*
   * Mapping parameters:
   *    <device> <offset> <delay> [<write_device> <write_offset> <write_delay>]
* Unmerged path drivers/md/dm-delay.c
