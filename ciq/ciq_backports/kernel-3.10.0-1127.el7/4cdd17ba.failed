TTY: serial_core, add ->install

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Jiri Slaby <jslaby@suse.cz>
commit 4cdd17ba1dff20ffc99fdbd2e6f0201fc7fe67df
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/4cdd17ba.failed

We need to compute the uart state only on the first open. This is
usually what is done in the ->install hook. serial_core used to do this
in ->open on every open. So move it to ->install.

As a side effect, it ensures the state is set properly in the window
after tty_init_dev is called, but before uart_open. This fixes a bunch
of races between tty_open and flush_to_ldisc we were dealing with
recently.

One of such bugs was attempted to fix in commit fedb5760648a (serial:
fix race between flush_to_ldisc and tty_open), but it only took care of
a couple of functions (uart_start and uart_unthrottle).  I was able to
reproduce the crash on a SLE system, but in uart_write_room which is
also called from flush_to_ldisc via process_echoes. I was *unable* to
reproduce the bug locally. It is due to having this patch in my queue
since 2012!

 general protection fault: 0000 [#1] SMP KASAN PTI
 CPU: 1 PID: 5 Comm: kworker/u4:0 Tainted: G             L 4.12.14-396-default #1 SLE15-SP1 (unreleased)
 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-0-ga698c89-prebuilt.qemu.org 04/01/2014
 Workqueue: events_unbound flush_to_ldisc
 task: ffff8800427d8040 task.stack: ffff8800427f0000
 RIP: 0010:uart_write_room+0xc4/0x590
 RSP: 0018:ffff8800427f7088 EFLAGS: 00010202
 RAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000000000
 RDX: 000000000000002f RSI: 00000000000000ee RDI: ffff88003888bd90
 RBP: ffffffffb9545850 R08: 0000000000000001 R09: 0000000000000400
 R10: ffff8800427d825c R11: 000000000000006e R12: 1ffff100084fee12
 R13: ffffc900004c5000 R14: ffff88003888bb28 R15: 0000000000000178
 FS:  0000000000000000(0000) GS:ffff880043300000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 0000561da0794148 CR3: 000000000ebf4000 CR4: 00000000000006e0
 Call Trace:
  tty_write_room+0x6d/0xc0
  __process_echoes+0x55/0x870
  n_tty_receive_buf_common+0x105e/0x26d0
  tty_ldisc_receive_buf+0xb7/0x1c0
  tty_port_default_receive_buf+0x107/0x180
  flush_to_ldisc+0x35d/0x5c0
...

0 in rbx means tty->driver_data is NULL in uart_write_room. 0x178 is
tried to be dereferenced (0x178 >> 3 is 0x2f in rdx) at
uart_write_room+0xc4. 0x178 is exactly (struct uart_state *)NULL->refcount
used in uart_port_lock from uart_write_room.

So revert the upstream commit here as my local patch should fix the
whole family.

	Signed-off-by: Jiri Slaby <jslaby@suse.cz>
	Cc: Li RongQing <lirongqing@baidu.com>
	Cc: Wang Li <wangli39@baidu.com>
	Cc: Zhang Yu <zhangyu31@baidu.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: stable <stable@vger.kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 4cdd17ba1dff20ffc99fdbd2e6f0201fc7fe67df)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/serial/serial_core.c
diff --cc drivers/tty/serial/serial_core.c
index 2436b552ef0b,0decb0bf991d..000000000000
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@@ -97,15 -127,15 +97,19 @@@ static void __uart_start(struct tty_str
  static void uart_start(struct tty_struct *tty)
  {
  	struct uart_state *state = tty->driver_data;
 -	struct uart_port *port;
 +	struct uart_port *port = state->uart_port;
  	unsigned long flags;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&port->lock, flags);
++=======
+ 	port = uart_port_lock(state, flags);
++>>>>>>> 4cdd17ba1dff (TTY: serial_core, add ->install)
  	__uart_start(tty);
 -	uart_port_unlock(port, flags);
 +	spin_unlock_irqrestore(&port->lock, flags);
  }
  
 -static void
 +static inline void
  uart_update_mctrl(struct uart_port *port, unsigned int set, unsigned int clear)
  {
  	unsigned long flags;
@@@ -633,35 -724,37 +637,44 @@@ static void uart_throttle(struct tty_st
  static void uart_unthrottle(struct tty_struct *tty)
  {
  	struct uart_state *state = tty->driver_data;
++<<<<<<< HEAD
 +	struct uart_port *port = state->uart_port;
 +	uint32_t mask = 0;
++=======
+ 	upstat_t mask = UPSTAT_SYNC_FIFO;
+ 	struct uart_port *port;
+ 
+ 	port = uart_port_ref(state);
+ 	if (!port)
+ 		return;
++>>>>>>> 4cdd17ba1dff (TTY: serial_core, add ->install)
  
  	if (I_IXOFF(tty))
 -		mask |= UPSTAT_AUTOXOFF;
 -	if (C_CRTSCTS(tty))
 -		mask |= UPSTAT_AUTORTS;
 +		mask |= UPF_SOFT_FLOW;
 +	if (tty->termios.c_cflag & CRTSCTS)
 +		mask |= UPF_HARD_FLOW;
  
 -	if (port->status & mask) {
 +	if (port->flags & mask) {
  		port->ops->unthrottle(port);
 -		mask &= ~port->status;
 +		mask &= ~port->flags;
  	}
  
 -	if (mask & UPSTAT_AUTORTS)
 -		uart_set_mctrl(port, TIOCM_RTS);
 -
 -	if (mask & UPSTAT_AUTOXOFF)
 -		uart_send_xchar(tty, START_CHAR(tty));
 +	if (mask & UPF_SOFT_FLOW) {
 +		if (port->x_char)
 +			port->x_char = 0;
 +		else
 +			uart_send_xchar(tty, START_CHAR(tty));
 +	}
  
 -	uart_port_deref(port);
 +	if (mask & UPF_HARD_FLOW)
 +		uart_set_mctrl(port, TIOCM_RTS);
  }
  
 -static int uart_get_info(struct tty_port *port, struct serial_struct *retinfo)
 +static void do_uart_get_info(struct tty_port *port,
 +			struct serial_struct *retinfo)
  {
  	struct uart_state *state = container_of(port, struct uart_state, port);
 -	struct uart_port *uport;
 -	int ret = -ENODEV;
 +	struct uart_port *uport = state->uart_port;
  
  	memset(retinfo, 0, sizeof(*retinfo));
  
@@@ -1509,17 -1729,28 +1522,27 @@@ static int uart_carrier_raised(struct t
  	return 0;
  }
  
 -static void uart_dtr_rts(struct tty_port *port, int raise)
 +static void uart_dtr_rts(struct tty_port *port, int onoff)
  {
  	struct uart_state *state = container_of(port, struct uart_state, port);
 -	struct uart_port *uport;
 +	struct uart_port *uport = state->uart_port;
  
 -	uport = uart_port_ref(state);
 -	if (!uport)
 -		return;
 -	uart_port_dtr_rts(uport, raise);
 -	uart_port_deref(uport);
 +	if (onoff)
 +		uart_set_mctrl(uport, TIOCM_DTR | TIOCM_RTS);
 +	else
 +		uart_clear_mctrl(uport, TIOCM_DTR | TIOCM_RTS);
  }
  
+ static int uart_install(struct tty_driver *driver, struct tty_struct *tty)
+ {
+ 	struct uart_driver *drv = driver->driver_state;
+ 	struct uart_state *state = drv->state + tty->index;
+ 
+ 	tty->driver_data = state;
+ 
+ 	return tty_standard_install(driver, tty);
+ }
+ 
  /*
   * Calls to uart_open are serialised by the tty_lock in
   *   drivers/tty/tty_io.c:tty_open()
@@@ -1532,41 -1763,26 +1555,64 @@@
   */
  static int uart_open(struct tty_struct *tty, struct file *filp)
  {
++<<<<<<< HEAD
 +	struct uart_driver *drv = (struct uart_driver *)tty->driver->driver_state;
 +	int retval, line = tty->index;
 +	struct uart_state *state = drv->state + line;
 +	struct tty_port *port = &state->port;
 +
 +	pr_debug("uart_open(%d) called\n", line);
 +
 +	/*
 +	 * We take the semaphore here to guarantee that we won't be re-entered
 +	 * while allocating the state structure, or while we request any IRQs
 +	 * that the driver may need.  This also has the nice side-effect that
 +	 * it delays the action of uart_hangup, so we can guarantee that
 +	 * state->port.tty will always contain something reasonable.
 +	 */
 +	if (mutex_lock_interruptible(&port->mutex)) {
 +		retval = -ERESTARTSYS;
 +		goto end;
 +	}
 +
 +	port->count++;
 +	if (!state->uart_port || state->uart_port->flags & UPF_DEAD) {
 +		retval = -ENXIO;
 +		goto err_dec_count;
 +	}
 +
 +	/*
 +	 * Once we set tty->driver_data here, we are guaranteed that
 +	 * uart_close() will decrement the driver module use count.
 +	 * Any failures from here onwards should not touch the count.
 +	 */
 +	tty->driver_data = state;
 +	state->uart_port->state = state;
 +	state->port.low_latency =
 +		(state->uart_port->flags & UPF_LOW_LATENCY) ? 1 : 0;
 +	tty_port_tty_set(port, tty);
++=======
+ 	struct uart_state *state = tty->driver_data;
+ 	int retval;
+ 
+ 	retval = tty_port_open(&state->port, tty, filp);
+ 	if (retval > 0)
+ 		retval = 0;
+ 
+ 	return retval;
+ }
+ 
+ static int uart_port_activate(struct tty_port *port, struct tty_struct *tty)
+ {
+ 	struct uart_state *state = container_of(port, struct uart_state, port);
+ 	struct uart_port *uport;
+ 
+ 	uport = uart_port_check(state);
+ 	if (!uport || uport->flags & UPF_DEAD)
+ 		return -ENXIO;
+ 
+ 	port->low_latency = (uport->flags & UPF_LOW_LATENCY) ? 1 : 0;
++>>>>>>> 4cdd17ba1dff (TTY: serial_core, add ->install)
  
  	/*
  	 * Start up the serial port.
* Unmerged path drivers/tty/serial/serial_core.c
