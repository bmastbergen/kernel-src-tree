VFS: close race between getcwd() and d_move()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author NeilBrown <neilb@suse.com>
commit 61647823aa920e395afcce4b57c32afb51456cab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/61647823.failed

d_move() will call __d_drop() and then __d_rehash()
on the dentry being moved.  This creates a small window
when the dentry appears to be unhashed.  Many tests
of d_unhashed() are made under ->d_lock and so are safe
from racing with this window, but some aren't.
In particular, getcwd() calls d_unlinked() (which calls
d_unhashed()) without d_lock protection, so it can race.

This races has been seen in practice with lustre, which uses d_move() as
part of name lookup.  See:
   https://jira.hpdd.intel.com/browse/LU-9735
It could race with a regular rename(), and result in ENOENT instead
of either the 'before' or 'after' name.

The race can be demonstrated with a simple program which
has two threads, one renaming a directory back and forth
while another calls getcwd() within that directory: it should never
fail, but does.  See:
  https://patchwork.kernel.org/patch/9455345/

We could fix this race by taking d_lock and rechecking when
d_unhashed() reports true.  Alternately when can remove the window,
which is the approach this patch takes.

___d_drop() is introduce which does *not* clear d_hash.pprev
so the dentry still appears to be hashed.  __d_drop() calls
___d_drop(), then clears d_hash.pprev.
__d_move() now uses ___d_drop() and only clears d_hash.pprev
when not rehashing.

	Signed-off-by: NeilBrown <neilb@suse.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 61647823aa920e395afcce4b57c32afb51456cab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dcache.c
diff --cc fs/dcache.c
index 44174d1719f8,cab211e13744..000000000000
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@@ -490,15 -467,37 +490,42 @@@ static void __d_shrink(struct dentry *d
   * d_drop() is used mainly for stuff that wants to invalidate a dentry for some
   * reason (NFS timeouts or autofs deletes).
   *
-  * __d_drop requires dentry->d_lock.
+  * __d_drop requires dentry->d_lock
+  * ___d_drop doesn't mark dentry as "unhashed"
+  *   (dentry->d_hash.pprev will be LIST_POISON2, not NULL).
   */
- void __d_drop(struct dentry *dentry)
+ static void ___d_drop(struct dentry *dentry)
  {
  	if (!d_unhashed(dentry)) {
++<<<<<<< HEAD
 +		__d_shrink(dentry);
 +		dentry_rcuwalk_invalidate(dentry);
++=======
+ 		struct hlist_bl_head *b;
+ 		/*
+ 		 * Hashed dentries are normally on the dentry hashtable,
+ 		 * with the exception of those newly allocated by
+ 		 * d_obtain_root, which are always IS_ROOT:
+ 		 */
+ 		if (unlikely(IS_ROOT(dentry)))
+ 			b = &dentry->d_sb->s_roots;
+ 		else
+ 			b = d_hash(dentry->d_name.hash);
+ 
+ 		hlist_bl_lock(b);
+ 		__hlist_bl_del(&dentry->d_hash);
+ 		hlist_bl_unlock(b);
+ 		/* After this call, in-progress rcu-walk path lookup will fail. */
+ 		write_seqcount_invalidate(&dentry->d_seq);
++>>>>>>> 61647823aa92 (VFS: close race between getcwd() and d_move())
  	}
  }
+ 
+ void __d_drop(struct dentry *dentry)
+ {
+ 	___d_drop(dentry);
+ 	dentry->d_hash.pprev = NULL;
+ }
  EXPORT_SYMBOL(__d_drop);
  
  void d_drop(struct dentry *dentry)
@@@ -2426,9 -2386,10 +2453,14 @@@ again
  }
  EXPORT_SYMBOL(d_delete);
  
 -static void __d_rehash(struct dentry *entry)
 +static void __d_rehash(struct dentry * entry, struct hlist_bl_head *b)
  {
++<<<<<<< HEAD
 +	BUG_ON(!d_unhashed(entry));
++=======
+ 	struct hlist_bl_head *b = d_hash(entry->d_name.hash);
+ 
++>>>>>>> 61647823aa92 (VFS: close race between getcwd() and d_move())
  	hlist_bl_lock(b);
  	hlist_bl_add_head_rcu(&entry->d_hash, b);
  	hlist_bl_unlock(b);
@@@ -2596,34 -2823,27 +2628,52 @@@ static void __d_move(struct dentry *den
  	write_seqcount_begin(&dentry->d_seq);
  	write_seqcount_begin_nested(&target->d_seq, DENTRY_D_LOCK_NESTED);
  
++<<<<<<< HEAD
 +	/* __d_drop does write_seqcount_barrier, but they're OK to nest. */
 +
 +	/*
 +	 * Move the dentry to the target hash queue. Don't bother checking
 +	 * for the same hash queue because of how unlikely it is.
 +	 */
 +	__d_drop(dentry);
 +	__d_rehash(dentry, d_hash(target->d_parent, target->d_name.hash));
 +
 +	/*
 +	 * Unhash the target (d_delete() is not usable here).  If exchanging
 +	 * the two dentries, then rehash onto the other's hash queue.
 +	 */
 +	__d_drop(target);
 +	if (exchange) {
 +		__d_rehash(target,
 +			   d_hash(dentry->d_parent, dentry->d_name.hash));
 +	}
 +
 +	list_del(&dentry->d_u.d_child);
 +	list_del(&target->d_u.d_child);
++=======
+ 	/* unhash both */
+ 	/* ___d_drop does write_seqcount_barrier, but they're OK to nest. */
+ 	___d_drop(dentry);
+ 	___d_drop(target);
++>>>>>>> 61647823aa92 (VFS: close race between getcwd() and d_move())
  
  	/* Switch the names.. */
 -	if (exchange)
 -		swap_names(dentry, target);
 -	else
 -		copy_name(dentry, target);
 +	switch_names(dentry, target);
 +	swap(dentry->d_name.hash, target->d_name.hash);
  
++<<<<<<< HEAD
 +	/* ... and switch the parents */
++=======
+ 	/* rehash in new place(s) */
+ 	__d_rehash(dentry);
+ 	if (exchange)
+ 		__d_rehash(target);
+ 	else
+ 		target->d_hash.pprev = NULL;
+ 
+ 	/* ... and switch them in the tree */
++>>>>>>> 61647823aa92 (VFS: close race between getcwd() and d_move())
  	if (IS_ROOT(dentry)) {
 -		/* splicing a tree */
  		dentry->d_flags |= DCACHE_RCUACCESS;
  		dentry->d_parent = target->d_parent;
  		target->d_parent = target;
* Unmerged path fs/dcache.c
