vfs: Verify acls are valid within superblock's s_user_ns.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 0d4d717f25834134bb6f43284f84c8ccee5bbf2a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/0d4d717f.failed

Update posix_acl_valid to verify that an acl is within a user namespace.

Update the callers of posix_acl_valid to pass in an appropriate
user namespace.  For posix_acl_xattr_set and v9fs_xattr_set_acl pass in
inode->i_sb->s_user_ns to posix_acl_valid.  For md_unpack_acl pass in
&init_user_ns as no inode or superblock is in sight.

	Acked-by: Seth Forshee <seth.forshee@canonical.com>
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit 0d4d717f25834134bb6f43284f84c8ccee5bbf2a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/lustre/lustre/mdc/mdc_request.c
#	fs/posix_acl.c
diff --cc fs/posix_acl.c
index ce7b4e77278d,647c28180675..000000000000
--- a/fs/posix_acl.c
+++ b/fs/posix_acl.c
@@@ -123,12 -225,8 +123,12 @@@ posix_acl_valid(struct user_namespace *
  			case ACL_USER:
  				if (state != ACL_USER)
  					return -EINVAL;
- 				if (!uid_valid(pa->e_uid))
+ 				if (!kuid_has_mapping(user_ns, pa->e_uid))
  					return -EINVAL;
 +				if (uid_valid(prev_uid) &&
 +				    uid_lte(pa->e_uid, prev_uid))
 +					return -EINVAL;
 +				prev_uid = pa->e_uid;
  				needs_mask = 1;
  				break;
  
@@@ -142,12 -240,8 +142,12 @@@
  			case ACL_GROUP:
  				if (state != ACL_GROUP)
  					return -EINVAL;
- 				if (!gid_valid(pa->e_gid))
+ 				if (!kgid_has_mapping(user_ns, pa->e_gid))
  					return -EINVAL;
 +				if (gid_valid(prev_gid) &&
 +				    gid_lte(pa->e_gid, prev_gid))
 +					return -EINVAL;
 +				prev_gid = pa->e_gid;
  				needs_mask = 1;
  				break;
  
@@@ -475,4 -547,372 +475,348 @@@ posix_acl_chmod(struct posix_acl **acl
  	*acl = clone;
  	return err;
  }
 -EXPORT_SYMBOL(__posix_acl_chmod);
 -
 -int
 -posix_acl_chmod(struct inode *inode, umode_t mode)
 -{
 -	struct posix_acl *acl;
 -	int ret = 0;
 -
 -	if (!IS_POSIXACL(inode))
 -		return 0;
 -	if (!inode->i_op->set_acl)
 -		return -EOPNOTSUPP;
 -
 -	acl = get_acl(inode, ACL_TYPE_ACCESS);
 -	if (IS_ERR_OR_NULL(acl)) {
 -		if (acl == ERR_PTR(-EOPNOTSUPP))
 -			return 0;
 -		return PTR_ERR(acl);
 -	}
 -
 -	ret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);
 -	if (ret)
 -		return ret;
 -	ret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);
 -	posix_acl_release(acl);
 -	return ret;
 -}
  EXPORT_SYMBOL(posix_acl_chmod);
++<<<<<<< HEAD
++=======
+ 
+ int
+ posix_acl_create(struct inode *dir, umode_t *mode,
+ 		struct posix_acl **default_acl, struct posix_acl **acl)
+ {
+ 	struct posix_acl *p;
+ 	struct posix_acl *clone;
+ 	int ret;
+ 
+ 	*acl = NULL;
+ 	*default_acl = NULL;
+ 
+ 	if (S_ISLNK(*mode) || !IS_POSIXACL(dir))
+ 		return 0;
+ 
+ 	p = get_acl(dir, ACL_TYPE_DEFAULT);
+ 	if (!p || p == ERR_PTR(-EOPNOTSUPP)) {
+ 		*mode &= ~current_umask();
+ 		return 0;
+ 	}
+ 	if (IS_ERR(p))
+ 		return PTR_ERR(p);
+ 
+ 	clone = posix_acl_clone(p, GFP_NOFS);
+ 	if (!clone)
+ 		goto no_mem;
+ 
+ 	ret = posix_acl_create_masq(clone, mode);
+ 	if (ret < 0)
+ 		goto no_mem_clone;
+ 
+ 	if (ret == 0)
+ 		posix_acl_release(clone);
+ 	else
+ 		*acl = clone;
+ 
+ 	if (!S_ISDIR(*mode))
+ 		posix_acl_release(p);
+ 	else
+ 		*default_acl = p;
+ 
+ 	return 0;
+ 
+ no_mem_clone:
+ 	posix_acl_release(clone);
+ no_mem:
+ 	posix_acl_release(p);
+ 	return -ENOMEM;
+ }
+ EXPORT_SYMBOL_GPL(posix_acl_create);
+ 
+ /*
+  * Fix up the uids and gids in posix acl extended attributes in place.
+  */
+ static void posix_acl_fix_xattr_userns(
+ 	struct user_namespace *to, struct user_namespace *from,
+ 	void *value, size_t size)
+ {
+ 	posix_acl_xattr_header *header = (posix_acl_xattr_header *)value;
+ 	posix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;
+ 	int count;
+ 	kuid_t uid;
+ 	kgid_t gid;
+ 
+ 	if (!value)
+ 		return;
+ 	if (size < sizeof(posix_acl_xattr_header))
+ 		return;
+ 	if (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))
+ 		return;
+ 
+ 	count = posix_acl_xattr_count(size);
+ 	if (count < 0)
+ 		return;
+ 	if (count == 0)
+ 		return;
+ 
+ 	for (end = entry + count; entry != end; entry++) {
+ 		switch(le16_to_cpu(entry->e_tag)) {
+ 		case ACL_USER:
+ 			uid = make_kuid(from, le32_to_cpu(entry->e_id));
+ 			entry->e_id = cpu_to_le32(from_kuid(to, uid));
+ 			break;
+ 		case ACL_GROUP:
+ 			gid = make_kgid(from, le32_to_cpu(entry->e_id));
+ 			entry->e_id = cpu_to_le32(from_kgid(to, gid));
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ void posix_acl_fix_xattr_from_user(void *value, size_t size)
+ {
+ 	struct user_namespace *user_ns = current_user_ns();
+ 	if (user_ns == &init_user_ns)
+ 		return;
+ 	posix_acl_fix_xattr_userns(&init_user_ns, user_ns, value, size);
+ }
+ 
+ void posix_acl_fix_xattr_to_user(void *value, size_t size)
+ {
+ 	struct user_namespace *user_ns = current_user_ns();
+ 	if (user_ns == &init_user_ns)
+ 		return;
+ 	posix_acl_fix_xattr_userns(user_ns, &init_user_ns, value, size);
+ }
+ 
+ /*
+  * Convert from extended attribute to in-memory representation.
+  */
+ struct posix_acl *
+ posix_acl_from_xattr(struct user_namespace *user_ns,
+ 		     const void *value, size_t size)
+ {
+ 	posix_acl_xattr_header *header = (posix_acl_xattr_header *)value;
+ 	posix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;
+ 	int count;
+ 	struct posix_acl *acl;
+ 	struct posix_acl_entry *acl_e;
+ 
+ 	if (!value)
+ 		return NULL;
+ 	if (size < sizeof(posix_acl_xattr_header))
+ 		 return ERR_PTR(-EINVAL);
+ 	if (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 
+ 	count = posix_acl_xattr_count(size);
+ 	if (count < 0)
+ 		return ERR_PTR(-EINVAL);
+ 	if (count == 0)
+ 		return NULL;
+ 	
+ 	acl = posix_acl_alloc(count, GFP_NOFS);
+ 	if (!acl)
+ 		return ERR_PTR(-ENOMEM);
+ 	acl_e = acl->a_entries;
+ 	
+ 	for (end = entry + count; entry != end; acl_e++, entry++) {
+ 		acl_e->e_tag  = le16_to_cpu(entry->e_tag);
+ 		acl_e->e_perm = le16_to_cpu(entry->e_perm);
+ 
+ 		switch(acl_e->e_tag) {
+ 			case ACL_USER_OBJ:
+ 			case ACL_GROUP_OBJ:
+ 			case ACL_MASK:
+ 			case ACL_OTHER:
+ 				break;
+ 
+ 			case ACL_USER:
+ 				acl_e->e_uid =
+ 					make_kuid(user_ns,
+ 						  le32_to_cpu(entry->e_id));
+ 				if (!uid_valid(acl_e->e_uid))
+ 					goto fail;
+ 				break;
+ 			case ACL_GROUP:
+ 				acl_e->e_gid =
+ 					make_kgid(user_ns,
+ 						  le32_to_cpu(entry->e_id));
+ 				if (!gid_valid(acl_e->e_gid))
+ 					goto fail;
+ 				break;
+ 
+ 			default:
+ 				goto fail;
+ 		}
+ 	}
+ 	return acl;
+ 
+ fail:
+ 	posix_acl_release(acl);
+ 	return ERR_PTR(-EINVAL);
+ }
+ EXPORT_SYMBOL (posix_acl_from_xattr);
+ 
+ /*
+  * Convert from in-memory to extended attribute representation.
+  */
+ int
+ posix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,
+ 		   void *buffer, size_t size)
+ {
+ 	posix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;
+ 	posix_acl_xattr_entry *ext_entry;
+ 	int real_size, n;
+ 
+ 	real_size = posix_acl_xattr_size(acl->a_count);
+ 	if (!buffer)
+ 		return real_size;
+ 	if (real_size > size)
+ 		return -ERANGE;
+ 
+ 	ext_entry = ext_acl->a_entries;
+ 	ext_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);
+ 
+ 	for (n=0; n < acl->a_count; n++, ext_entry++) {
+ 		const struct posix_acl_entry *acl_e = &acl->a_entries[n];
+ 		ext_entry->e_tag  = cpu_to_le16(acl_e->e_tag);
+ 		ext_entry->e_perm = cpu_to_le16(acl_e->e_perm);
+ 		switch(acl_e->e_tag) {
+ 		case ACL_USER:
+ 			ext_entry->e_id =
+ 				cpu_to_le32(from_kuid(user_ns, acl_e->e_uid));
+ 			break;
+ 		case ACL_GROUP:
+ 			ext_entry->e_id =
+ 				cpu_to_le32(from_kgid(user_ns, acl_e->e_gid));
+ 			break;
+ 		default:
+ 			ext_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);
+ 			break;
+ 		}
+ 	}
+ 	return real_size;
+ }
+ EXPORT_SYMBOL (posix_acl_to_xattr);
+ 
+ static int
+ posix_acl_xattr_get(const struct xattr_handler *handler,
+ 		    struct dentry *unused, struct inode *inode,
+ 		    const char *name, void *value, size_t size)
+ {
+ 	struct posix_acl *acl;
+ 	int error;
+ 
+ 	if (!IS_POSIXACL(inode))
+ 		return -EOPNOTSUPP;
+ 	if (S_ISLNK(inode->i_mode))
+ 		return -EOPNOTSUPP;
+ 
+ 	acl = get_acl(inode, handler->flags);
+ 	if (IS_ERR(acl))
+ 		return PTR_ERR(acl);
+ 	if (acl == NULL)
+ 		return -ENODATA;
+ 
+ 	error = posix_acl_to_xattr(&init_user_ns, acl, value, size);
+ 	posix_acl_release(acl);
+ 
+ 	return error;
+ }
+ 
+ static int
+ posix_acl_xattr_set(const struct xattr_handler *handler,
+ 		    struct dentry *unused, struct inode *inode,
+ 		    const char *name, const void *value,
+ 		    size_t size, int flags)
+ {
+ 	struct posix_acl *acl = NULL;
+ 	int ret;
+ 
+ 	if (!IS_POSIXACL(inode))
+ 		return -EOPNOTSUPP;
+ 	if (!inode->i_op->set_acl)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (handler->flags == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))
+ 		return value ? -EACCES : 0;
+ 	if (!inode_owner_or_capable(inode))
+ 		return -EPERM;
+ 
+ 	if (value) {
+ 		acl = posix_acl_from_xattr(&init_user_ns, value, size);
+ 		if (IS_ERR(acl))
+ 			return PTR_ERR(acl);
+ 
+ 		if (acl) {
+ 			ret = posix_acl_valid(inode->i_sb->s_user_ns, acl);
+ 			if (ret)
+ 				goto out;
+ 		}
+ 	}
+ 
+ 	ret = inode->i_op->set_acl(inode, acl, handler->flags);
+ out:
+ 	posix_acl_release(acl);
+ 	return ret;
+ }
+ 
+ static bool
+ posix_acl_xattr_list(struct dentry *dentry)
+ {
+ 	return IS_POSIXACL(d_backing_inode(dentry));
+ }
+ 
+ const struct xattr_handler posix_acl_access_xattr_handler = {
+ 	.name = XATTR_NAME_POSIX_ACL_ACCESS,
+ 	.flags = ACL_TYPE_ACCESS,
+ 	.list = posix_acl_xattr_list,
+ 	.get = posix_acl_xattr_get,
+ 	.set = posix_acl_xattr_set,
+ };
+ EXPORT_SYMBOL_GPL(posix_acl_access_xattr_handler);
+ 
+ const struct xattr_handler posix_acl_default_xattr_handler = {
+ 	.name = XATTR_NAME_POSIX_ACL_DEFAULT,
+ 	.flags = ACL_TYPE_DEFAULT,
+ 	.list = posix_acl_xattr_list,
+ 	.get = posix_acl_xattr_get,
+ 	.set = posix_acl_xattr_set,
+ };
+ EXPORT_SYMBOL_GPL(posix_acl_default_xattr_handler);
+ 
+ int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)
+ {
+ 	int error;
+ 
+ 	if (type == ACL_TYPE_ACCESS) {
+ 		error = posix_acl_equiv_mode(acl, &inode->i_mode);
+ 		if (error < 0)
+ 			return 0;
+ 		if (error == 0)
+ 			acl = NULL;
+ 	}
+ 
+ 	inode->i_ctime = CURRENT_TIME;
+ 	set_cached_acl(inode, type, acl);
+ 	return 0;
+ }
+ 
+ int simple_acl_create(struct inode *dir, struct inode *inode)
+ {
+ 	struct posix_acl *default_acl, *acl;
+ 	int error;
+ 
+ 	error = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);
+ 	if (error)
+ 		return error;
+ 
+ 	set_cached_acl(inode, ACL_TYPE_DEFAULT, default_acl);
+ 	set_cached_acl(inode, ACL_TYPE_ACCESS, acl);
+ 
+ 	if (default_acl)
+ 		posix_acl_release(default_acl);
+ 	if (acl)
+ 		posix_acl_release(acl);
+ 	return 0;
+ }
++>>>>>>> 0d4d717f2583 (vfs: Verify acls are valid within superblock's s_user_ns.)
* Unmerged path drivers/staging/lustre/lustre/mdc/mdc_request.c
* Unmerged path drivers/staging/lustre/lustre/mdc/mdc_request.c
diff --git a/fs/9p/acl.c b/fs/9p/acl.c
index 7af425f53bee..38a0410ddea5 100644
--- a/fs/9p/acl.c
+++ b/fs/9p/acl.c
@@ -309,7 +309,7 @@ static int v9fs_xattr_set_acl(struct dentry *dentry, const char *name,
 		if (IS_ERR(acl))
 			return PTR_ERR(acl);
 		else if (acl) {
-			retval = posix_acl_valid(acl);
+			retval = posix_acl_valid(inode->i_sb->s_user_ns, acl);
 			if (retval)
 				goto err_out;
 		}
* Unmerged path fs/posix_acl.c
diff --git a/include/linux/posix_acl.h b/include/linux/posix_acl.h
index f37b94074bc3..7fcea03ed284 100644
--- a/include/linux/posix_acl.h
+++ b/include/linux/posix_acl.h
@@ -84,7 +84,7 @@ posix_acl_release(struct posix_acl *acl)
 
 extern void posix_acl_init(struct posix_acl *, int);
 extern struct posix_acl *posix_acl_alloc(int, gfp_t);
-extern int posix_acl_valid(const struct posix_acl *);
+extern int posix_acl_valid(struct user_namespace *, const struct posix_acl *);
 extern int posix_acl_permission(struct inode *, const struct posix_acl *, int);
 extern struct posix_acl *posix_acl_from_mode(umode_t, gfp_t);
 extern int posix_acl_equiv_mode(const struct posix_acl *, umode_t *);
