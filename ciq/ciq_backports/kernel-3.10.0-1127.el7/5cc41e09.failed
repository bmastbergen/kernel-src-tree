fs/binfmt_misc.c: do not allow offset overflow

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [fs] binfmt_misc.c: do not allow offset overflow (Bill O'Donnell) [1708066]
Rebuild_FUZZ: 96.63%
commit-author Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
commit 5cc41e099504b77014358b58567c5ea6293dd220
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/5cc41e09.failed

WHen registering a new binfmt_misc handler, it is possible to overflow
the offset to get a negative value, which might crash the system, or
possibly leak kernel data.

Here is a crash log when 2500000000 was used as an offset:

  BUG: unable to handle kernel paging request at ffff989cfd6edca0
  IP: load_misc_binary+0x22b/0x470 [binfmt_misc]
  PGD 1ef3e067 P4D 1ef3e067 PUD 0
  Oops: 0000 [#1] SMP NOPTI
  Modules linked in: binfmt_misc kvm_intel ppdev kvm irqbypass joydev input_leds serio_raw mac_hid parport_pc qemu_fw_cfg parpy
  CPU: 0 PID: 2499 Comm: bash Not tainted 4.15.0-22-generic #24-Ubuntu
  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.11.1-1 04/01/2014
  RIP: 0010:load_misc_binary+0x22b/0x470 [binfmt_misc]
  Call Trace:
    search_binary_handler+0x97/0x1d0
    do_execveat_common.isra.34+0x667/0x810
    SyS_execve+0x31/0x40
    do_syscall_64+0x73/0x130
    entry_SYSCALL_64_after_hwframe+0x3d/0xa2

Use kstrtoint instead of simple_strtoul.  It will work as the code
already set the delimiter byte to '\0' and we only do it when the field
is not empty.

Tested with offsets -1, 2500000000, UINT_MAX and INT_MAX.  Also tested
with examples documented at Documentation/admin-guide/binfmt-misc.rst
and other registrations from packages on Ubuntu.

Link: http://lkml.kernel.org/r/20180529135648.14254-1-cascardo@canonical.com
Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
	Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
	Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
	Cc: Alexander Viro <viro@zeniv.linux.org.uk>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 5cc41e099504b77014358b58567c5ea6293dd220)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/binfmt_misc.c
diff --cc fs/binfmt_misc.c
index 1c740e152f38,4de191563261..000000000000
--- a/fs/binfmt_misc.c
+++ b/fs/binfmt_misc.c
@@@ -307,22 -359,46 +307,33 @@@ static Node *create_entry(const char __
  	    !strcmp(e->name, ".") ||
  	    !strcmp(e->name, "..") ||
  	    strchr(e->name, '/'))
 -		goto einval;
 -
 -	pr_debug("register: name: {%s}\n", e->name);
 -
 -	/* Parse the 'type' field. */
 +		goto Einval;
  	switch (*p++) {
 -	case 'E':
 -		pr_debug("register: type: E (extension)\n");
 -		e->flags = 1 << Enabled;
 -		break;
 -	case 'M':
 -		pr_debug("register: type: M (magic)\n");
 -		e->flags = (1 << Enabled) | (1 << Magic);
 -		break;
 -	default:
 -		goto einval;
 +		case 'E': e->flags = 1<<Enabled; break;
 +		case 'M': e->flags = (1<<Enabled) | (1<<Magic); break;
 +		default: goto Einval;
  	}
  	if (*p++ != del)
 -		goto einval;
 -
 +		goto Einval;
  	if (test_bit(Magic, &e->flags)) {
 -		/* Handle the 'M' (magic) format. */
 -		char *s;
 -
 -		/* Parse the 'offset' field. */
 -		s = strchr(p, del);
 +		char *s = strchr(p, del);
  		if (!s)
++<<<<<<< HEAD
 +			goto Einval;
 +		*s++ = '\0';
 +		e->offset = simple_strtoul(p, &p, 10);
++=======
+ 			goto einval;
+ 		*s = '\0';
+ 		if (p != s) {
+ 			int r = kstrtoint(p, 10, &e->offset);
+ 			if (r != 0 || e->offset < 0)
+ 				goto einval;
+ 		}
+ 		p = s;
++>>>>>>> 5cc41e099504 (fs/binfmt_misc.c: do not allow offset overflow)
  		if (*p++)
 -			goto einval;
 -		pr_debug("register: offset: %#x\n", e->offset);
 -
 -		/* Parse the 'magic' field. */
 +			goto Einval;
  		e->magic = p;
  		p = scanarg(p, del);
  		if (!p)
@@@ -340,14 -420,57 +351,46 @@@
  		e->size = string_unescape_inplace(e->magic, UNESCAPE_HEX);
  		if (e->mask &&
  		    string_unescape_inplace(e->mask, UNESCAPE_HEX) != e->size)
++<<<<<<< HEAD
 +			goto Einval;
 +		if (e->size + e->offset > BINPRM_BUF_SIZE)
 +			goto Einval;
++=======
+ 			goto einval;
+ 		if (e->size > BINPRM_BUF_SIZE ||
+ 		    BINPRM_BUF_SIZE - e->size < e->offset)
+ 			goto einval;
+ 		pr_debug("register: magic/mask length: %i\n", e->size);
+ 		if (USE_DEBUG) {
+ 			print_hex_dump_bytes(
+ 				KBUILD_MODNAME ": register: magic[decoded]: ",
+ 				DUMP_PREFIX_NONE, e->magic, e->size);
+ 
+ 			if (e->mask) {
+ 				int i;
+ 				char *masked = kmalloc(e->size, GFP_KERNEL);
+ 
+ 				print_hex_dump_bytes(
+ 					KBUILD_MODNAME ": register:  mask[decoded]: ",
+ 					DUMP_PREFIX_NONE, e->mask, e->size);
+ 
+ 				if (masked) {
+ 					for (i = 0; i < e->size; ++i)
+ 						masked[i] = e->magic[i] & e->mask[i];
+ 					print_hex_dump_bytes(
+ 						KBUILD_MODNAME ": register:  magic[masked]: ",
+ 						DUMP_PREFIX_NONE, masked, e->size);
+ 
+ 					kfree(masked);
+ 				}
+ 			}
+ 		}
++>>>>>>> 5cc41e099504 (fs/binfmt_misc.c: do not allow offset overflow)
  	} else {
 -		/* Handle the 'E' (extension) format. */
 -
 -		/* Skip the 'offset' field. */
  		p = strchr(p, del);
  		if (!p)
 -			goto einval;
 +			goto Einval;
  		*p++ = '\0';
 -
 -		/* Parse the 'magic' field. */
  		e->magic = p;
  		p = strchr(p, del);
  		if (!p)
* Unmerged path fs/binfmt_misc.c
