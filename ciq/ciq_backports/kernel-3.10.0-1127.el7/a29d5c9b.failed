perf tools: Separate accounting of contexts and real addresses in a stack trace

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit a29d5c9b8167dbc21a7ca8c0302e3799f9063b4e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/a29d5c9b.failed

The perf_sample->ip_callchain->nr value includes all the entries in the
ip_callchain->ip[] array, real addresses and PERF_CONTEXT_{KERNEL,USER,etc},
while what the user expects is that what is in the kernel.perf_event_max_stack
sysctl or in the upcoming per event perf_event_attr.sample_max_stack knob be
honoured in terms of IP addresses in the stack trace.

So match the kernel support and validate chain->nr taking into account
both kernel.perf_event_max_stack and kernel.perf_event_max_contexts_per_stack.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Alexei Starovoitov <ast@kernel.org>
	Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: He Kuang <hekuang@huawei.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Masami Hiramatsu <mhiramat@kernel.org>
	Cc: Milian Wolff <milian.wolff@kdab.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
	Cc: Wang Nan <wangnan0@huawei.com>
	Cc: Zefan Li <lizefan@huawei.com>
Link: http://lkml.kernel.org/n/tip-mgx0jpzfdq4uq4abfa40byu0@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit a29d5c9b8167dbc21a7ca8c0302e3799f9063b4e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/machine.c
#	tools/perf/util/util.h
diff --cc tools/perf/util/machine.c
index 64f4a3a50bdb,7ba9fadb68af..000000000000
--- a/tools/perf/util/machine.c
+++ b/tools/perf/util/machine.c
@@@ -2136,9 -1811,9 +2136,13 @@@ static int thread__resolve_callchain_sa
  {
  	struct branch_stack *branch = sample->branch_stack;
  	struct ip_callchain *chain = sample->callchain;
++<<<<<<< HEAD
 +	int chain_nr = 0;
++=======
+ 	int chain_nr = chain->nr;
++>>>>>>> a29d5c9b8167 (perf tools: Separate accounting of contexts and real addresses in a stack trace)
  	u8 cpumode = PERF_RECORD_MISC_USER;
- 	int i, j, err;
+ 	int i, j, err, nr_entries, nr_contexts;
  	int skip_idx = -1;
  	int first_call = 0;
  
@@@ -2252,51 -1904,27 +2252,67 @@@ check_calls
  #endif
  		ip = chain->ips[j];
  
++<<<<<<< HEAD
 +		err = add_callchain_ip(thread, cursor, parent,
 +				       root_al, &cpumode, ip,
 +				       false, NULL, NULL, 0);
++=======
+ 		if (ip >= PERF_CONTEXT_MAX) {
+ 			if (++nr_contexts > sysctl_perf_event_max_contexts_per_stack)
+ 				goto out_corrupted_callchain;
+ 		} else {
+ 			if (++nr_entries > sysctl_perf_event_max_stack)
+ 				goto out_corrupted_callchain;
+ 		}
+ 
+ 		err = add_callchain_ip(thread, cursor, parent, root_al, &cpumode, ip);
++>>>>>>> a29d5c9b8167 (perf tools: Separate accounting of contexts and real addresses in a stack trace)
  
  		if (err)
  			return (err < 0) ? err : 0;
  	}
  
  	return 0;
+ 
+ out_corrupted_callchain:
+ 	pr_warning("corrupted callchain. skipping...\n");
+ 	return 0;
  }
  
 +static int append_inlines(struct callchain_cursor *cursor,
 +			  struct map *map, struct symbol *sym, u64 ip)
 +{
 +	struct inline_node *inline_node;
 +	struct inline_list *ilist;
 +	u64 addr;
 +	int ret = 1;
 +
 +	if (!symbol_conf.inline_name || !map || !sym)
 +		return ret;
 +
 +	addr = map__map_ip(map, ip);
 +	addr = map__rip_2objdump(map, addr);
 +
 +	inline_node = inlines__tree_find(&map->dso->inlined_nodes, addr);
 +	if (!inline_node) {
 +		inline_node = dso__parse_addr_inlines(map->dso, addr, sym);
 +		if (!inline_node)
 +			return ret;
 +		inlines__tree_insert(&map->dso->inlined_nodes, inline_node);
 +	}
 +
 +	list_for_each_entry(ilist, &inline_node->val, list) {
 +		ret = callchain_cursor_append(cursor, ip, map,
 +					      ilist->symbol, false,
 +					      NULL, 0, 0, 0, ilist->srcline);
 +
 +		if (ret != 0)
 +			return ret;
 +	}
 +
 +	return ret;
 +}
 +
  static int unwind_entry(struct unwind_entry *entry, void *arg)
  {
  	struct callchain_cursor *cursor = arg;
diff --cc tools/perf/util/util.h
index 27005fe33819,1e8c3167b9fb..000000000000
--- a/tools/perf/util/util.h
+++ b/tools/perf/util/util.h
@@@ -42,28 -248,88 +42,34 @@@ ssize_t writen(int fd, const void *buf
  size_t hex_width(u64 v);
  int hex2u64(const char *ptr, u64 *val);
  
 -char *ltrim(char *s);
 -char *rtrim(char *s);
 -
 -static inline char *trim(char *s)
 -{
 -	return ltrim(rtrim(s));
 -}
 -
 -void dump_stack(void);
 -void sighandler_dump_stack(int sig);
 -
  extern unsigned int page_size;
++<<<<<<< HEAD
 +int __pure cacheline_size(void);
++=======
+ extern int cacheline_size;
+ extern int sysctl_perf_event_max_stack;
+ extern int sysctl_perf_event_max_contexts_per_stack;
++>>>>>>> a29d5c9b8167 (perf tools: Separate accounting of contexts and real addresses in a stack trace)
  
 -struct parse_tag {
 -	char tag;
 -	int mult;
 -};
 -
 -unsigned long parse_tag_value(const char *str, struct parse_tag *tags);
 -
 -#define SRCLINE_UNKNOWN  ((char *) "??:0")
 -
 -static inline int path__join(char *bf, size_t size,
 -			     const char *path1, const char *path2)
 -{
 -	return scnprintf(bf, size, "%s%s%s", path1, path1[0] ? "/" : "", path2);
 -}
 -
 -static inline int path__join3(char *bf, size_t size,
 -			      const char *path1, const char *path2,
 -			      const char *path3)
 -{
 -	return scnprintf(bf, size, "%s%s%s%s%s",
 -			 path1, path1[0] ? "/" : "",
 -			 path2, path2[0] ? "/" : "", path3);
 -}
 -
 -struct dso;
 -struct symbol;
 -
 -extern bool srcline_full_filename;
 -char *get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 -		  bool show_sym);
 -char *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 -		  bool show_sym, bool unwind_inlines);
 -void free_srcline(char *srcline);
 -
 -int perf_event_paranoid(void);
 -
 -void mem_bswap_64(void *src, int byte_size);
 -void mem_bswap_32(void *src, int byte_size);
 -
 -const char *get_filename_for_perf_kvm(void);
 -bool find_process(const char *name);
 +const char *perf_tip(const char *dirpath);
  
 -#ifdef HAVE_ZLIB_SUPPORT
 -int gzip_decompress_to_file(const char *input, int output_fd);
 +#ifndef HAVE_GET_CURRENT_DIR_NAME
 +char *get_current_dir_name(void);
  #endif
  
 -#ifdef HAVE_LZMA_SUPPORT
 -int lzma_decompress_to_file(const char *input, int output_fd);
 +#ifndef HAVE_SCHED_GETCPU_SUPPORT
 +int sched_getcpu(void);
  #endif
  
 -char *asprintf_expr_inout_ints(const char *var, bool in, size_t nints, int *ints);
 -
 -static inline char *asprintf_expr_in_ints(const char *var, size_t nints, int *ints)
 -{
 -	return asprintf_expr_inout_ints(var, true, nints, ints);
 -}
 +#ifndef HAVE_SETNS_SUPPORT
 +int setns(int fd, int nstype);
 +#endif
  
 -static inline char *asprintf_expr_not_in_ints(const char *var, size_t nints, int *ints)
 -{
 -	return asprintf_expr_inout_ints(var, false, nints, ints);
 -}
 +extern bool perf_singlethreaded;
  
 -int get_stack_size(const char *str, unsigned long *_size);
 +void perf_set_singlethreaded(void);
 +void perf_set_multithreaded(void);
  
 -int fetch_kernel_version(unsigned int *puint,
 -			 char *str, size_t str_sz);
  #define KVER_VERSION(x)		(((x) >> 16) & 0xff)
  #define KVER_PATCHLEVEL(x)	(((x) >> 8) & 0xff)
  #define KVER_SUBLEVEL(x)	((x) & 0xff)
diff --git a/tools/perf/perf.c b/tools/perf/perf.c
index c7aac2a5715e..a0e10ea0b35c 100644
--- a/tools/perf/perf.c
+++ b/tools/perf/perf.c
@@ -436,6 +436,9 @@ int main(int argc, const char **argv)
 	if (sysctl__read_int("kernel/perf_event_max_stack", &value) == 0)
 		sysctl_perf_event_max_stack = value;
 
+	if (sysctl__read_int("kernel/perf_event_max_contexts_per_stack", &value) == 0)
+		sysctl_perf_event_max_contexts_per_stack = value;
+
 	cmd = extract_argv0_path(argv[0]);
 	if (!cmd)
 		cmd = "perf-help";
* Unmerged path tools/perf/util/machine.c
diff --git a/tools/perf/util/util.c b/tools/perf/util/util.c
index 11080cc6e145..70378f2b1197 100644
--- a/tools/perf/util/util.c
+++ b/tools/perf/util/util.c
@@ -58,7 +58,8 @@ int cacheline_size(void)
 	return size;
 }
 
-unsigned int sysctl_perf_event_max_stack = PERF_MAX_STACK_DEPTH;
+int sysctl_perf_event_max_stack = PERF_MAX_STACK_DEPTH;
+int sysctl_perf_event_max_contexts_per_stack = PERF_MAX_CONTEXTS_PER_STACK;
 
 bool test_attr__enabled;
 
* Unmerged path tools/perf/util/util.h
