x86, efi: Never relocate kernel below lowest acceptable address

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Kairui Song <kasong@redhat.com>
commit 220dd7699c46d5940115bd797b01b2ab047c87b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/220dd769.failed

Currently, kernel fails to boot on some HyperV VMs when using EFI.
And it's a potential issue on all x86 platforms.

It's caused by broken kernel relocation on EFI systems, when below three
conditions are met:

1. Kernel image is not loaded to the default address (LOAD_PHYSICAL_ADDR)
   by the loader.
2. There isn't enough room to contain the kernel, starting from the
   default load address (eg. something else occupied part the region).
3. In the memmap provided by EFI firmware, there is a memory region
   starts below LOAD_PHYSICAL_ADDR, and suitable for containing the
   kernel.

EFI stub will perform a kernel relocation when condition 1 is met. But
due to condition 2, EFI stub can't relocate kernel to the preferred
address, so it fallback to ask EFI firmware to alloc lowest usable memory
region, got the low region mentioned in condition 3, and relocated
kernel there.

It's incorrect to relocate the kernel below LOAD_PHYSICAL_ADDR. This
is the lowest acceptable kernel relocation address.

The first thing goes wrong is in arch/x86/boot/compressed/head_64.S.
Kernel decompression will force use LOAD_PHYSICAL_ADDR as the output
address if kernel is located below it. Then the relocation before
decompression, which move kernel to the end of the decompression buffer,
will overwrite other memory region, as there is no enough memory there.

To fix it, just don't let EFI stub relocate the kernel to any address
lower than lowest acceptable address.

[ ardb: introduce efi_low_alloc_above() to reduce the scope of the change ]

	Signed-off-by: Kairui Song <kasong@redhat.com>
	Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Acked-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-efi@vger.kernel.org
Link: https://lkml.kernel.org/r/20191029173755.27149-6-ardb@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 220dd7699c46d5940115bd797b01b2ab047c87b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/eboot.c
#	drivers/firmware/efi/libstub/arm32-stub.c
#	drivers/firmware/efi/libstub/efi-stub-helper.c
#	include/linux/efi.h
diff --cc arch/x86/boot/compressed/eboot.c
index 1d45c6510706,82bc60c8acb2..000000000000
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@@ -9,13 -8,14 +9,17 @@@
  
  #include <linux/efi.h>
  #include <linux/pci.h>
 -
  #include <asm/efi.h>
 -#include <asm/e820/types.h>
  #include <asm/setup.h>
  #include <asm/desc.h>
++<<<<<<< HEAD
 +#include <asm/bootparam_utils.h>
 +
 +#undef memcpy			/* Use memcpy from misc.c */
++=======
+ #include <asm/boot.h>
++>>>>>>> 220dd7699c46 (x86, efi: Never relocate kernel below lowest acceptable address)
  
 -#include "../string.h"
  #include "eboot.h"
  
  static efi_system_table_t *sys_table;
@@@ -1491,15 -810,26 +1495,26 @@@ struct boot_params *efi_main(struct efi
  	 * address, relocate it.
  	 */
  	if (hdr->pref_address != hdr->code32_start) {
++<<<<<<< HEAD
 +		status = relocate_kernel(hdr);
 +
 +		if (status != EFI_SUCCESS)
++=======
+ 		unsigned long bzimage_addr = hdr->code32_start;
+ 		status = efi_relocate_kernel(sys_table, &bzimage_addr,
+ 					     hdr->init_size, hdr->init_size,
+ 					     hdr->pref_address,
+ 					     hdr->kernel_alignment,
+ 					     LOAD_PHYSICAL_ADDR);
+ 		if (status != EFI_SUCCESS) {
+ 			efi_printk(sys_table, "efi_relocate_kernel() failed!\n");
++>>>>>>> 220dd7699c46 (x86, efi: Never relocate kernel below lowest acceptable address)
  			goto fail;
 -		}
 -
 -		hdr->pref_address = hdr->code32_start;
 -		hdr->code32_start = bzimage_addr;
  	}
  
 -	status = exit_boot(boot_params, handle);
 -	if (status != EFI_SUCCESS) {
 -		efi_printk(sys_table, "exit_boot() failed!\n");
 +	status = exit_boot(boot_params, handle, is64);
 +	if (status != EFI_SUCCESS)
  		goto fail;
 -	}
  
  	memset((char *)gdt->address, 0x0, gdt->size);
  	desc = (struct desc_struct *)gdt->address;
diff --cc include/linux/efi.h
index d03ef62a0f4d,d87acf62958e..000000000000
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@@ -1286,8 -1566,86 +1286,72 @@@ static inline int efi_runtime_map_copy(
  
  #endif
  
++<<<<<<< HEAD
 +bool efi_runtime_disabled(void);
++=======
+ /* prototypes shared between arch specific and generic stub code */
+ 
+ void efi_printk(efi_system_table_t *sys_table_arg, char *str);
+ 
+ void efi_free(efi_system_table_t *sys_table_arg, unsigned long size,
+ 	      unsigned long addr);
+ 
+ char *efi_convert_cmdline(efi_system_table_t *sys_table_arg,
+ 			  efi_loaded_image_t *image, int *cmd_line_len);
+ 
+ efi_status_t efi_get_memory_map(efi_system_table_t *sys_table_arg,
+ 				struct efi_boot_memmap *map);
+ 
+ efi_status_t efi_low_alloc_above(efi_system_table_t *sys_table_arg,
+ 				 unsigned long size, unsigned long align,
+ 				 unsigned long *addr, unsigned long min);
+ 
+ static inline
+ efi_status_t efi_low_alloc(efi_system_table_t *sys_table_arg,
+ 			   unsigned long size, unsigned long align,
+ 			   unsigned long *addr)
+ {
+ 	/*
+ 	 * Don't allocate at 0x0. It will confuse code that
+ 	 * checks pointers against NULL. Skip the first 8
+ 	 * bytes so we start at a nice even number.
+ 	 */
+ 	return efi_low_alloc_above(sys_table_arg, size, align, addr, 0x8);
+ }
+ 
+ efi_status_t efi_high_alloc(efi_system_table_t *sys_table_arg,
+ 			    unsigned long size, unsigned long align,
+ 			    unsigned long *addr, unsigned long max);
+ 
+ efi_status_t efi_relocate_kernel(efi_system_table_t *sys_table_arg,
+ 				 unsigned long *image_addr,
+ 				 unsigned long image_size,
+ 				 unsigned long alloc_size,
+ 				 unsigned long preferred_addr,
+ 				 unsigned long alignment,
+ 				 unsigned long min_addr);
+ 
+ efi_status_t handle_cmdline_files(efi_system_table_t *sys_table_arg,
+ 				  efi_loaded_image_t *image,
+ 				  char *cmd_line, char *option_string,
+ 				  unsigned long max_addr,
+ 				  unsigned long *load_addr,
+ 				  unsigned long *load_size);
+ 
+ efi_status_t efi_parse_options(char const *cmdline);
+ 
+ efi_status_t efi_setup_gop(efi_system_table_t *sys_table_arg,
+ 			   struct screen_info *si, efi_guid_t *proto,
+ 			   unsigned long size);
+ 
+ #ifdef CONFIG_EFI
+ extern bool efi_runtime_disabled(void);
+ #else
+ static inline bool efi_runtime_disabled(void) { return true; }
+ #endif
+ 
++>>>>>>> 220dd7699c46 (x86, efi: Never relocate kernel below lowest acceptable address)
  extern void efi_call_virt_check_flags(unsigned long flags, const char *call);
 -extern unsigned long efi_call_virt_save_flags(void);
 -
 -enum efi_secureboot_mode {
 -	efi_secureboot_mode_unset,
 -	efi_secureboot_mode_unknown,
 -	efi_secureboot_mode_disabled,
 -	efi_secureboot_mode_enabled,
 -};
 -enum efi_secureboot_mode efi_get_secureboot(efi_system_table_t *sys_table);
 -
 -#ifdef CONFIG_RESET_ATTACK_MITIGATION
 -void efi_enable_reset_attack_mitigation(efi_system_table_t *sys_table_arg);
 -#else
 -static inline void
 -efi_enable_reset_attack_mitigation(efi_system_table_t *sys_table_arg) { }
 -#endif
 -
 -void efi_retrieve_tpm2_eventlog(efi_system_table_t *sys_table);
  
  /*
   * Arch code can implement the following three template macros, avoiding
* Unmerged path drivers/firmware/efi/libstub/arm32-stub.c
* Unmerged path drivers/firmware/efi/libstub/efi-stub-helper.c
* Unmerged path arch/x86/boot/compressed/eboot.c
* Unmerged path drivers/firmware/efi/libstub/arm32-stub.c
* Unmerged path drivers/firmware/efi/libstub/efi-stub-helper.c
* Unmerged path include/linux/efi.h
