ipc: reorganize initialization of kern_ipc_perm.seq

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [ipc] reorganize initialization of kern_ipc_perm.seq (Waiman Long) [1373519]
Rebuild_FUZZ: 94.85%
commit-author Manfred Spraul <manfred@colorfullife.com>
commit e2652ae6bd7492cdc0436817cbcd09282eb0bb03
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/e2652ae6.failed

ipc_addid() initializes kern_ipc_perm.seq after having called idr_alloc()
(within ipc_idr_alloc()).

Thus a parallel semop() or msgrcv() that uses ipc_obtain_object_check()
may see an uninitialized value.

The patch moves the initialization of kern_ipc_perm.seq before the calls
of idr_alloc().

Notes:
1) This patch has a user space visible side effect:
If /proc/sys/kernel/*_next_id is used (i.e.: checkpoint/restore) and
if semget()/msgget()/shmget() fails in the final step of adding the id
to the rhash tree, then .._next_id is cleared. Before the patch, is
remained unmodified.

There is no change of the behavior after a successful ..get() call: It
always clears .._next_id, there is no impact to non checkpoint/restore
code as that code does not use .._next_id.

2) The patch correctly documents that after a call to ipc_idr_alloc(),
the full tear-down sequence must be used. The callers of ipc_addid()
do not fullfill that, i.e. more bugfixes are required.

The patch is a squash of a patch from Dmitry and my own changes.

Link: http://lkml.kernel.org/r/20180712185241.4017-3-manfred@colorfullife.com
	Reported-by: syzbot+2827ef6b3385deb07eaf@syzkaller.appspotmail.com
	Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: Davidlohr Bueso <dave@stgolabs.net>
	Cc: Michael Kerrisk <mtk.manpages@gmail.com>
	Cc: Davidlohr Bueso <dbueso@suse.de>
	Cc: Herbert Xu <herbert@gondor.apana.org.au>
	Cc: Michal Hocko <mhocko@suse.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit e2652ae6bd7492cdc0436817cbcd09282eb0bb03)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	ipc/util.c
diff --cc ipc/util.c
index 1df75a61612b,e5c9e2b2e4c4..000000000000
--- a/ipc/util.c
+++ b/ipc/util.c
@@@ -226,35 -194,52 +226,84 @@@ static struct kern_ipc_perm *ipc_findke
  	return NULL;
  }
  
++<<<<<<< HEAD
 +/**
 + *	ipc_get_maxid 	-	get the last assigned id
 + *	@ids: IPC identifier set
 + *
 + *	Called with ipc_ids.rwsem held.
 + */
 +
 +int ipc_get_maxid(struct ipc_ids *ids)
 +{
 +	struct kern_ipc_perm *ipc;
 +	int max_id = -1;
 +	int total, id;
 +
 +	if (ids->in_use == 0)
 +		return -1;
 +
 +	if (ids->in_use == IPCMNI)
 +		return IPCMNI - 1;
 +
 +	/* Look for the last assigned id */
 +	total = 0;
 +	for (id = 0; id < IPCMNI && total < ids->in_use; id++) {
 +		ipc = idr_find(&ids->ipcs_idr, id);
 +		if (ipc != NULL) {
 +			max_id = id;
 +			total++;
 +		}
 +	}
 +	return max_id;
++=======
+ /*
+  * Insert new IPC object into idr tree, and set sequence number and id
+  * in the correct order.
+  * Especially:
+  * - the sequence number must be set before inserting the object into the idr,
+  *   because the sequence number is accessed without a lock.
+  * - the id can/must be set after inserting the object into the idr.
+  *   All accesses must be done after getting kern_ipc_perm.lock.
+  *
+  * The caller must own kern_ipc_perm.lock.of the new object.
+  * On error, the function returns a (negative) error code.
+  */
+ static inline int ipc_idr_alloc(struct ipc_ids *ids, struct kern_ipc_perm *new)
+ {
+ 	int idx, next_id = -1;
+ 
+ #ifdef CONFIG_CHECKPOINT_RESTORE
+ 	next_id = ids->next_id;
+ 	ids->next_id = -1;
+ #endif
+ 
+ 	/*
+ 	 * As soon as a new object is inserted into the idr,
+ 	 * ipc_obtain_object_idr() or ipc_obtain_object_check() can find it,
+ 	 * and the lockless preparations for ipc operations can start.
+ 	 * This means especially: permission checks, audit calls, allocation
+ 	 * of undo structures, ...
+ 	 *
+ 	 * Thus the object must be fully initialized, and if something fails,
+ 	 * then the full tear-down sequence must be followed.
+ 	 * (i.e.: set new->deleted, reduce refcount, call_rcu())
+ 	 */
+ 
+ 	if (next_id < 0) { /* !CHECKPOINT_RESTORE or next_id is unset */
+ 		new->seq = ids->seq++;
+ 		if (ids->seq > IPCID_SEQ_MAX)
+ 			ids->seq = 0;
+ 		idx = idr_alloc(&ids->ipcs_idr, new, 0, 0, GFP_NOWAIT);
+ 	} else {
+ 		new->seq = ipcid_to_seqx(next_id);
+ 		idx = idr_alloc(&ids->ipcs_idr, new, ipcid_to_idx(next_id),
+ 				0, GFP_NOWAIT);
+ 	}
+ 	if (idx >= 0)
+ 		new->id = SEQ_MULTIPLIER * new->seq + idx;
+ 	return idx;
++>>>>>>> e2652ae6bd74 (ipc: reorganize initialization of kern_ipc_perm.seq)
  }
  
  /**
@@@ -274,13 -259,12 +323,17 @@@ int ipc_addid(struct ipc_ids* ids, stru
  {
  	kuid_t euid;
  	kgid_t egid;
++<<<<<<< HEAD
 +	int id;
 +	int next_id = ids->next_id;
++=======
+ 	int idx, err;
++>>>>>>> e2652ae6bd74 (ipc: reorganize initialization of kern_ipc_perm.seq)
  
 -	if (limit > IPCMNI)
 -		limit = IPCMNI;
 +	if (size > IPCMNI)
 +		size = IPCMNI;
  
 -	if (!ids->tables_initialized || ids->in_use >= limit)
 +	if (ids->in_use >= size)
  		return -ENOSPC;
  
  	idr_preload(GFP_KERNEL);
@@@ -294,29 -279,27 +347,50 @@@
  	new->cuid = new->uid = euid;
  	new->gid = new->cgid = egid;
  
++<<<<<<< HEAD
 +	id = idr_alloc(&ids->ipcs_idr, new,
 +		       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,
 +		       GFP_NOWAIT);
 +	idr_preload_end();
 +	if (id < 0) {
++=======
+ 	idx = ipc_idr_alloc(ids, new);
+ 	idr_preload_end();
+ 
+ 	if (idx >= 0 && new->key != IPC_PRIVATE) {
+ 		err = rhashtable_insert_fast(&ids->key_ht, &new->khtnode,
+ 					     ipc_kht_params);
+ 		if (err < 0) {
+ 			idr_remove(&ids->ipcs_idr, idx);
+ 			idx = err;
+ 		}
+ 	}
+ 	if (idx < 0) {
++>>>>>>> e2652ae6bd74 (ipc: reorganize initialization of kern_ipc_perm.seq)
  		spin_unlock(&new->lock);
  		rcu_read_unlock();
- 		return id;
+ 		return idx;
  	}
  
  	ids->in_use++;
++<<<<<<< HEAD
 +
 +	if (next_id < 0) {
 +		new->seq = ids->seq++;
 +		if (ids->seq > ids->seq_max)
 +			ids->seq = 0;
 +	} else {
 +		new->seq = ipcid_to_seqx(next_id);
 +		ids->next_id = -1;
 +	}
 +
 +	new->id = ipc_buildid(id, new->seq);
 +	return id;
++=======
+ 	if (idx > ids->max_id)
+ 		ids->max_id = idx;
+ 	return idx;
++>>>>>>> e2652ae6bd74 (ipc: reorganize initialization of kern_ipc_perm.seq)
  }
  
  /**
diff --git a/Documentation/sysctl/kernel.txt b/Documentation/sysctl/kernel.txt
index faaa10d0b546..0327becb6191 100644
--- a/Documentation/sysctl/kernel.txt
+++ b/Documentation/sysctl/kernel.txt
@@ -433,7 +433,8 @@ Notes:
 1) kernel doesn't guarantee, that new object will have desired id. So,
 it's up to userspace, how to handle an object with "wrong" id.
 2) Toggle with non-default value will be set back to -1 by kernel after
-successful IPC object allocation.
+successful IPC object allocation. If an IPC object allocation syscall
+fails, it is undefined if the value remains unmodified or is reset to -1.
 
 ==============================================================
 
* Unmerged path ipc/util.c
