s390/zcrypt: Fix wrong dispatching for control domain CPRBs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [s390] zcrypt: Fix wrong dispatching for control domain CPRBs (Hendrik Brueckner) [1720389]
Rebuild_FUZZ: 95.58%
commit-author Harald Freudenberger <freude@linux.ibm.com>
commit 7379e652797c0b9b5f6caea1576f2dff9ce6a708
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/7379e652.failed

The zcrypt device driver does not handle CPRBs which address
a control domain correctly. This fix introduces a workaround:
The domain field of the request CPRB is checked if there is
a valid domain value in there. If this is true and the value
is a control only domain (a domain which is enabled in the
crypto config ADM mask but disabled in the AQM mask) the
CPRB is forwarded to the default usage domain. If there is
no default domain, the request is rejected with an ENODEV.

This fix is important for maintaining crypto adapters. For
example one LPAR can use a crypto adapter domain ('Control
and Usage') but another LPAR needs to be able to maintain
this adapter domain ('Control'). Scenarios like this did
not work properly and the patch enables this.

	Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
(cherry picked from commit 7379e652797c0b9b5f6caea1576f2dff9ce6a708)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
diff --cc drivers/s390/crypto/ap_bus.c
index a35f296c4afa,b9fc502c58c2..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -1357,6 -1370,170 +1375,173 @@@ static int __match_queue_device_with_qi
  	return is_queue_dev(dev) && to_ap_queue(dev)->qid == (int)(long) data;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Helper function to be used with bus_find_dev
+  * matches any queue device with given queue id
+  */
+ static int __match_queue_device_with_queue_id(struct device *dev, void *data)
+ {
+ 	return is_queue_dev(dev)
+ 		&& AP_QID_QUEUE(to_ap_queue(dev)->qid) == (int)(long) data;
+ }
+ 
+ /*
+  * Helper function for ap_scan_bus().
+  * Does the scan bus job for the given adapter id.
+  */
+ static void _ap_scan_bus_adapter(int id)
+ {
+ 	ap_qid_t qid;
+ 	unsigned int func;
+ 	struct ap_card *ac;
+ 	struct device *dev;
+ 	struct ap_queue *aq;
+ 	int rc, dom, depth, type, comp_type, borked;
+ 
+ 	/* check if there is a card device registered with this id */
+ 	dev = bus_find_device(&ap_bus_type, NULL,
+ 			      (void *)(long) id,
+ 			      __match_card_device_with_id);
+ 	ac = dev ? to_ap_card(dev) : NULL;
+ 	if (!ap_test_config_card_id(id)) {
+ 		if (dev) {
+ 			/* Card device has been removed from configuration */
+ 			bus_for_each_dev(&ap_bus_type, NULL,
+ 					 (void *)(long) id,
+ 					 __ap_queue_devices_with_id_unregister);
+ 			device_unregister(dev);
+ 			put_device(dev);
+ 		}
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * This card id is enabled in the configuration. If we already have
+ 	 * a card device with this id, check if type and functions are still
+ 	 * the very same. Also verify that at least one queue is available.
+ 	 */
+ 	if (ac) {
+ 		/* find the first valid queue */
+ 		for (dom = 0; dom < AP_DOMAINS; dom++) {
+ 			qid = AP_MKQID(id, dom);
+ 			if (ap_query_queue(qid, &depth, &type, &func) == 0)
+ 				break;
+ 		}
+ 		borked = 0;
+ 		if (dom >= AP_DOMAINS) {
+ 			/* no accessible queue on this card */
+ 			borked = 1;
+ 		} else if (ac->raw_hwtype != type) {
+ 			/* card type has changed */
+ 			AP_DBF(DBF_INFO, "card=%02x type changed.\n", id);
+ 			borked = 1;
+ 		} else if (ac->functions != func) {
+ 			/* card functions have changed */
+ 			AP_DBF(DBF_INFO, "card=%02x functions changed.\n", id);
+ 			borked = 1;
+ 		}
+ 		if (borked) {
+ 			/* unregister card device and associated queues */
+ 			bus_for_each_dev(&ap_bus_type, NULL,
+ 					 (void *)(long) id,
+ 					 __ap_queue_devices_with_id_unregister);
+ 			device_unregister(dev);
+ 			put_device(dev);
+ 			/* go back if there is no valid queue on this card */
+ 			if (dom >= AP_DOMAINS)
+ 				return;
+ 			ac = NULL;
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Go through all possible queue ids. Check and maybe create or release
+ 	 * queue devices for this card. If there exists no card device yet,
+ 	 * create a card device also.
+ 	 */
+ 	for (dom = 0; dom < AP_DOMAINS; dom++) {
+ 		qid = AP_MKQID(id, dom);
+ 		dev = bus_find_device(&ap_bus_type, NULL,
+ 				      (void *)(long) qid,
+ 				      __match_queue_device_with_qid);
+ 		aq = dev ? to_ap_queue(dev) : NULL;
+ 		if (!ap_test_config_usage_domain(dom)) {
+ 			if (dev) {
+ 				/* Queue device exists but has been
+ 				 * removed from configuration.
+ 				 */
+ 				device_unregister(dev);
+ 				put_device(dev);
+ 			}
+ 			continue;
+ 		}
+ 		/* try to fetch infos about this queue */
+ 		rc = ap_query_queue(qid, &depth, &type, &func);
+ 		if (dev) {
+ 			if (rc == -ENODEV)
+ 				borked = 1;
+ 			else {
+ 				spin_lock_bh(&aq->lock);
+ 				borked = aq->state == AP_STATE_BORKED;
+ 				spin_unlock_bh(&aq->lock);
+ 			}
+ 			if (borked) {
+ 				/* Remove broken device */
+ 				AP_DBF(DBF_DEBUG,
+ 				       "removing broken queue=%02x.%04x\n",
+ 				       id, dom);
+ 				device_unregister(dev);
+ 			}
+ 			put_device(dev);
+ 			continue;
+ 		}
+ 		if (rc)
+ 			continue;
+ 		/* a new queue device is needed, check out comp type */
+ 		comp_type = ap_get_compatible_type(qid, type, func);
+ 		if (!comp_type)
+ 			continue;
+ 		/* maybe a card device needs to be created first */
+ 		if (!ac) {
+ 			ac = ap_card_create(id, depth, type, comp_type, func);
+ 			if (!ac)
+ 				continue;
+ 			ac->ap_dev.device.bus = &ap_bus_type;
+ 			ac->ap_dev.device.parent = ap_root_device;
+ 			dev_set_name(&ac->ap_dev.device, "card%02x", id);
+ 			/* Register card device with AP bus */
+ 			rc = device_register(&ac->ap_dev.device);
+ 			if (rc) {
+ 				put_device(&ac->ap_dev.device);
+ 				ac = NULL;
+ 				break;
+ 			}
+ 			/* get it and thus adjust reference counter */
+ 			get_device(&ac->ap_dev.device);
+ 		}
+ 		/* now create the new queue device */
+ 		aq = ap_queue_create(qid, comp_type);
+ 		if (!aq)
+ 			continue;
+ 		aq->card = ac;
+ 		aq->ap_dev.device.bus = &ap_bus_type;
+ 		aq->ap_dev.device.parent = &ac->ap_dev.device;
+ 		dev_set_name(&aq->ap_dev.device, "%02x.%04x", id, dom);
+ 		/* Register queue device */
+ 		rc = device_register(&aq->ap_dev.device);
+ 		if (rc) {
+ 			put_device(&aq->ap_dev.device);
+ 			continue;
+ 		}
+ 	} /* end domain loop */
+ 
+ 	if (ac)
+ 		put_device(&ac->ap_dev.device);
+ }
+ 
++>>>>>>> 7379e652797c (s390/zcrypt: Fix wrong dispatching for control domain CPRBs)
  /**
   * ap_scan_bus(): Scan the AP bus for new devices
   * Runs periodically, workqueue timer (ap_config_time)
diff --git a/arch/s390/include/asm/ap.h b/arch/s390/include/asm/ap.h
index 0d99749b5d09..16fe9ef5342f 100644
--- a/arch/s390/include/asm/ap.h
+++ b/arch/s390/include/asm/ap.h
@@ -72,8 +72,8 @@ struct ap_config_info {
 	unsigned char Nd;		/* max # of Domains - 1 */
 	unsigned char _reserved3[10];
 	unsigned int apm[8];		/* AP ID mask */
-	unsigned int aqm[8];		/* AP queue mask */
-	unsigned int adm[8];		/* AP domain mask */
+	unsigned int aqm[8];		/* AP (usage) queue mask */
+	unsigned int adm[8];		/* AP (control) domain mask */
 	unsigned char _reserved4[16];
 } __aligned(8);
 
* Unmerged path drivers/s390/crypto/ap_bus.c
diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 4bff07e2ddbc..1a77360585be 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -268,6 +268,9 @@ void ap_wait(enum ap_wait wait);
 void ap_request_timeout(unsigned long data);
 void ap_bus_force_rescan(void);
 
+int ap_test_config_usage_domain(unsigned int domain);
+int ap_test_config_ctrl_domain(unsigned int domain);
+
 void ap_queue_init_reply(struct ap_queue *aq, struct ap_message *ap_msg);
 struct ap_queue *ap_queue_create(ap_qid_t qid, int device_type);
 void ap_queue_remove(struct ap_queue *aq);
diff --git a/drivers/s390/crypto/zcrypt_api.c b/drivers/s390/crypto/zcrypt_api.c
index b8ad41ae5168..658caf293637 100644
--- a/drivers/s390/crypto/zcrypt_api.c
+++ b/drivers/s390/crypto/zcrypt_api.c
@@ -834,7 +834,7 @@ static long _zcrypt_send_cprb(struct ap_perms *perms,
 	struct ap_message ap_msg;
 	unsigned int weight, pref_weight;
 	unsigned int func_code;
-	unsigned short *domain;
+	unsigned short *domain, tdom;
 	int qid = 0, rc = -ENODEV;
 
 	trace_s390_zcrypt_req(xcRB, TB_ZSECSENDCPRB);
@@ -844,6 +844,17 @@ static long _zcrypt_send_cprb(struct ap_perms *perms,
 	if (rc)
 		goto out;
 
+	/*
+	 * If a valid target domain is set and this domain is NOT a usage
+	 * domain but a control only domain, use the default domain as target.
+	 */
+	tdom = *domain;
+	if (tdom >= 0 && tdom < AP_DOMAINS &&
+	    !ap_test_config_usage_domain(tdom) &&
+	    ap_test_config_ctrl_domain(tdom) &&
+	    ap_domain_index >= 0)
+		tdom = ap_domain_index;
+
 	pref_zc = NULL;
 	pref_zq = NULL;
 	spin_lock(&zcrypt_list_lock);
@@ -866,8 +877,8 @@ static long _zcrypt_send_cprb(struct ap_perms *perms,
 			/* check if device is online and eligible */
 			if (!zq->online ||
 			    !zq->ops->send_cprb ||
-			    ((*domain != (unsigned short) AUTOSELECT) &&
-			     (*domain != AP_QID_QUEUE(zq->queue->qid))))
+			    (tdom != (unsigned short) AUTOSELECT &&
+			     tdom != AP_QID_QUEUE(zq->queue->qid)))
 				continue;
 			/* check if device node has admission for this queue */
 			if (!zcrypt_check_queue(perms,
