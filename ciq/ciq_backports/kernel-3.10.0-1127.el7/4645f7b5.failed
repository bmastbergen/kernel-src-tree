scsi: lpfc: Coordinate adapter error handling with offline handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author James Smart <jsmart2021@gmail.com>
commit 4645f7b56a9fc3fb16605a1bfa10d884fcd5226c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/4645f7b5.failed

The driver periodically checks for adapter error in a background thread. If
the thread detects an error, the adapter will be reset including the
deletion and reallocation of workqueues on the adapter.  Simultaneously,
there may be a user-space request to offline the adapter which may try to
do many of the same steps, in parallel, on a different thread. As memory
was deallocated while unexpected, the parallel offline request hit a bad
pointer.

Add coordination between the two threads.  The error recovery thread has
precedence. So, when an error is detected, a flag is set on the adapter to
indicate the error thread is terminating the adapter. But, before doing
that work, it will look for a flag that is set by the offline flow, and if
set, will wait for it to complete before then processing the error handling
path.  Similarly, in the offline thread, it first checks for whether the
error thread is resetting the adapter, and if so, will then wait for the
error thread to finish. Only after it has finished, will it set its flag
and offline the adapter.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <jsmart2021@gmail.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 4645f7b56a9fc3fb16605a1bfa10d884fcd5226c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_init.c
#	drivers/scsi/lpfc/lpfc_sli.c
diff --cc drivers/scsi/lpfc/lpfc_init.c
index c658ac05b103,05fbb4765d70..000000000000
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@@ -8864,33 -9135,23 +8864,49 @@@ lpfc_sli4_release_queue_map(uint16_t **
  void
  lpfc_sli4_queue_destroy(struct lpfc_hba *phba)
  {
++<<<<<<< HEAD
 +	if (phba->cfg_fof)
 +		lpfc_fof_queue_destroy(phba);
++=======
+ 	/*
+ 	 * Set FREE_INIT before beginning to free the queues.
+ 	 * Wait until the users of queues to acknowledge to
+ 	 * release queues by clearing FREE_WAIT.
+ 	 */
+ 	spin_lock_irq(&phba->hbalock);
+ 	phba->sli.sli_flag |= LPFC_QUEUE_FREE_INIT;
+ 	while (phba->sli.sli_flag & LPFC_QUEUE_FREE_WAIT) {
+ 		spin_unlock_irq(&phba->hbalock);
+ 		msleep(20);
+ 		spin_lock_irq(&phba->hbalock);
+ 	}
+ 	spin_unlock_irq(&phba->hbalock);
++>>>>>>> 4645f7b56a9f (scsi: lpfc: Coordinate adapter error handling with offline handling)
  
  	/* Release HBA eqs */
 -	if (phba->sli4_hba.hdwq)
 -		lpfc_sli4_release_hdwq(phba);
 +	lpfc_sli4_release_queues(&phba->sli4_hba.hba_eq, phba->io_channel_irqs);
 +
 +	/* Release FCP cqs */
 +	lpfc_sli4_release_queues(&phba->sli4_hba.fcp_cq,
 +				 phba->cfg_fcp_io_channel);
 +
 +	/* Release FCP wqs */
 +	lpfc_sli4_release_queues(&phba->sli4_hba.fcp_wq,
 +				 phba->cfg_fcp_io_channel);
 +
 +	/* Release FCP CQ mapping array */
 +	lpfc_sli4_release_queue_map(&phba->sli4_hba.fcp_cq_map);
 +
 +	/* Release NVME cqs */
 +	lpfc_sli4_release_queues(&phba->sli4_hba.nvme_cq,
 +					phba->cfg_nvme_io_channel);
 +
 +	/* Release NVME wqs */
 +	lpfc_sli4_release_queues(&phba->sli4_hba.nvme_wq,
 +					phba->cfg_nvme_io_channel);
 +
 +	/* Release NVME CQ mapping array */
 +	lpfc_sli4_release_queue_map(&phba->sli4_hba.nvme_cq_map);
  
  	if (phba->nvmet_support) {
  		lpfc_sli4_release_queues(&phba->sli4_hba.nvmet_cqset,
diff --cc drivers/scsi/lpfc/lpfc_sli.c
index c7d41e5dfe79,4b084a408e71..000000000000
--- a/drivers/scsi/lpfc/lpfc_sli.c
+++ b/drivers/scsi/lpfc/lpfc_sli.c
@@@ -14516,8 -14432,8 +14519,13 @@@ lpfc_sli4_queue_free(struct lpfc_queue 
  		kfree(queue->rqbp);
  	}
  
++<<<<<<< HEAD
 +	if (!list_empty(&queue->wq_list))
 +		list_del(&queue->wq_list);
++=======
+ 	if (!list_empty(&queue->cpu_list))
+ 		list_del(&queue->cpu_list);
++>>>>>>> 4645f7b56a9f (scsi: lpfc: Coordinate adapter error handling with offline handling)
  
  	kfree(queue);
  	return;
diff --git a/drivers/scsi/lpfc/lpfc_attr.c b/drivers/scsi/lpfc/lpfc_attr.c
index 109fa0bed270..877f9f2bfb15 100644
--- a/drivers/scsi/lpfc/lpfc_attr.c
+++ b/drivers/scsi/lpfc/lpfc_attr.c
@@ -1157,6 +1157,20 @@ lpfc_do_offline(struct lpfc_hba *phba, uint32_t type)
 
 	psli = &phba->sli;
 
+	/*
+	 * If freeing the queues have already started, don't access them.
+	 * Otherwise set FREE_WAIT to indicate that queues are being used
+	 * to hold the freeing process until we finish.
+	 */
+	spin_lock_irq(&phba->hbalock);
+	if (!(psli->sli_flag & LPFC_QUEUE_FREE_INIT)) {
+		psli->sli_flag |= LPFC_QUEUE_FREE_WAIT;
+	} else {
+		spin_unlock_irq(&phba->hbalock);
+		goto skip_wait;
+	}
+	spin_unlock_irq(&phba->hbalock);
+
 	/* Wait a little for things to settle down, but not
 	 * long enough for dev loss timeout to expire.
 	 */
@@ -1178,6 +1192,11 @@ lpfc_do_offline(struct lpfc_hba *phba, uint32_t type)
 		}
 	}
 out:
+	spin_lock_irq(&phba->hbalock);
+	psli->sli_flag &= ~LPFC_QUEUE_FREE_WAIT;
+	spin_unlock_irq(&phba->hbalock);
+
+skip_wait:
 	init_completion(&online_compl);
 	rc = lpfc_workq_post_event(phba, &status, &online_compl, type);
 	if (rc == 0)
* Unmerged path drivers/scsi/lpfc/lpfc_init.c
* Unmerged path drivers/scsi/lpfc/lpfc_sli.c
diff --git a/drivers/scsi/lpfc/lpfc_sli.h b/drivers/scsi/lpfc/lpfc_sli.h
index 0d841a4f82eb..48219e5150e7 100644
--- a/drivers/scsi/lpfc/lpfc_sli.h
+++ b/drivers/scsi/lpfc/lpfc_sli.h
@@ -322,6 +322,10 @@ struct lpfc_sli {
 #define LPFC_SLI_ASYNC_MBX_BLK    0x2000 /* Async mailbox is blocked */
 #define LPFC_SLI_SUPPRESS_RSP     0x4000 /* Suppress RSP feature is supported */
 #define LPFC_SLI_USE_EQDR         0x8000 /* EQ Delay Register is supported */
+#define LPFC_QUEUE_FREE_INIT	  0x10000 /* Queue freeing is in progress */
+#define LPFC_QUEUE_FREE_WAIT	  0x20000 /* Hold Queue free as it is being
+					   * used outside worker thread
+					   */
 
 	struct lpfc_sli_ring *sli3_ring;
 
