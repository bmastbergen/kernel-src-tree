ipvs: Pass ipvs not net to ip_vs_genl_new_daemon

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit d8443c5f2b6524bbad465073330f6dba458f8871
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/d8443c5f.failed

	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
	Acked-by: Julian Anastasov <ja@ssi.bg>
	Signed-off-by: Simon Horman <horms@verge.net.au>
(cherry picked from commit d8443c5f2b6524bbad465073330f6dba458f8871)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipvs/ip_vs_ctl.c
diff --cc net/netfilter/ipvs/ip_vs_ctl.c
index 4aed1d77d557,847ea2fd44db..000000000000
--- a/net/netfilter/ipvs/ip_vs_ctl.c
+++ b/net/netfilter/ipvs/ip_vs_ctl.c
@@@ -3358,17 -3374,69 +3358,76 @@@ nla_put_failure
  	return skb->len;
  }
  
- static int ip_vs_genl_new_daemon(struct net *net, struct nlattr **attrs)
+ static int ip_vs_genl_new_daemon(struct netns_ipvs *ipvs, struct nlattr **attrs)
  {
++<<<<<<< HEAD
++=======
+ 	struct ipvs_sync_daemon_cfg c;
+ 	struct nlattr *a;
+ 	int ret;
+ 
+ 	memset(&c, 0, sizeof(c));
++>>>>>>> d8443c5f2b65 (ipvs: Pass ipvs not net to ip_vs_genl_new_daemon)
  	if (!(attrs[IPVS_DAEMON_ATTR_STATE] &&
  	      attrs[IPVS_DAEMON_ATTR_MCAST_IFN] &&
  	      attrs[IPVS_DAEMON_ATTR_SYNC_ID]))
  		return -EINVAL;
 -	strlcpy(c.mcast_ifn, nla_data(attrs[IPVS_DAEMON_ATTR_MCAST_IFN]),
 -		sizeof(c.mcast_ifn));
 -	c.syncid = nla_get_u32(attrs[IPVS_DAEMON_ATTR_SYNC_ID]);
  
++<<<<<<< HEAD
 +	return start_sync_thread(net,
 +				 nla_get_u32(attrs[IPVS_DAEMON_ATTR_STATE]),
 +				 nla_data(attrs[IPVS_DAEMON_ATTR_MCAST_IFN]),
 +				 nla_get_u32(attrs[IPVS_DAEMON_ATTR_SYNC_ID]));
++=======
+ 	a = attrs[IPVS_DAEMON_ATTR_SYNC_MAXLEN];
+ 	if (a)
+ 		c.sync_maxlen = nla_get_u16(a);
+ 
+ 	a = attrs[IPVS_DAEMON_ATTR_MCAST_GROUP];
+ 	if (a) {
+ 		c.mcast_af = AF_INET;
+ 		c.mcast_group.ip = nla_get_in_addr(a);
+ 		if (!ipv4_is_multicast(c.mcast_group.ip))
+ 			return -EINVAL;
+ 	} else {
+ 		a = attrs[IPVS_DAEMON_ATTR_MCAST_GROUP6];
+ 		if (a) {
+ #ifdef CONFIG_IP_VS_IPV6
+ 			int addr_type;
+ 
+ 			c.mcast_af = AF_INET6;
+ 			c.mcast_group.in6 = nla_get_in6_addr(a);
+ 			addr_type = ipv6_addr_type(&c.mcast_group.in6);
+ 			if (!(addr_type & IPV6_ADDR_MULTICAST))
+ 				return -EINVAL;
+ #else
+ 			return -EAFNOSUPPORT;
+ #endif
+ 		}
+ 	}
+ 
+ 	a = attrs[IPVS_DAEMON_ATTR_MCAST_PORT];
+ 	if (a)
+ 		c.mcast_port = nla_get_u16(a);
+ 
+ 	a = attrs[IPVS_DAEMON_ATTR_MCAST_TTL];
+ 	if (a)
+ 		c.mcast_ttl = nla_get_u8(a);
+ 
+ 	/* The synchronization protocol is incompatible with mixed family
+ 	 * services
+ 	 */
+ 	if (ipvs->mixed_address_family_dests > 0)
+ 		return -EINVAL;
+ 
+ 	rtnl_lock();
+ 	mutex_lock(&ipvs->sync_mutex);
+ 	ret = start_sync_thread(ipvs->net, &c,
+ 				nla_get_u32(attrs[IPVS_DAEMON_ATTR_STATE]));
+ 	mutex_unlock(&ipvs->sync_mutex);
+ 	rtnl_unlock();
+ 	return ret;
++>>>>>>> d8443c5f2b65 (ipvs: Pass ipvs not net to ip_vs_genl_new_daemon)
  }
  
  static int ip_vs_genl_del_daemon(struct net *net, struct nlattr **attrs)
@@@ -3416,18 -3490,16 +3475,18 @@@ static int ip_vs_genl_set_daemon(struc
  		if (!info->attrs[IPVS_CMD_ATTR_DAEMON] ||
  		    nla_parse_nested(daemon_attrs, IPVS_DAEMON_ATTR_MAX,
  				     info->attrs[IPVS_CMD_ATTR_DAEMON],
 -				     ip_vs_daemon_policy))
 +				     ip_vs_daemon_policy)) {
 +			ret = -EINVAL;
  			goto out;
 +		}
  
  		if (cmd == IPVS_CMD_NEW_DAEMON)
- 			ret = ip_vs_genl_new_daemon(net, daemon_attrs);
+ 			ret = ip_vs_genl_new_daemon(ipvs, daemon_attrs);
  		else
  			ret = ip_vs_genl_del_daemon(net, daemon_attrs);
 -	}
 -
  out:
 +		mutex_unlock(&ipvs->sync_mutex);
 +	}
  	return ret;
  }
  
* Unmerged path net/netfilter/ipvs/ip_vs_ctl.c
