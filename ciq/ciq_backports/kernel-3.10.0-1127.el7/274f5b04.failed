dcache_{readdir,dir_lseek}(): don't bother with nested ->d_lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [fs] dcache_{readdir, dir_lseek}(): don't bother with nested ->d_lock (Ondrej Mosnacek) [1510603]
Rebuild_FUZZ: 99.21%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 274f5b041d3c9c0974a7dd1f66b67c33bb5b0f42
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/274f5b04.failed

Make sure that directory is locked shared in dcache_dir_lseek();
for dcache_readdir() it's already tru, and that's enough to make
simple_positive() stable.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 274f5b041d3c9c0974a7dd1f66b67c33bb5b0f42)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/libfs.c
diff --cc fs/libfs.c
index 1f2023801ea9,f56acb1e5fbc..000000000000
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@@ -109,24 -103,23 +109,29 @@@ loff_t dcache_dir_lseek(struct file *fi
  			struct dentry *cursor = file->private_data;
  			loff_t n = file->f_pos - 2;
  
+ 			inode_lock_shared(dentry->d_inode);
  			spin_lock(&dentry->d_lock);
  			/* d_lock not required for cursor */
 -			list_del(&cursor->d_child);
 +			list_del(&cursor->d_u.d_child);
  			p = dentry->d_subdirs.next;
  			while (n && p != &dentry->d_subdirs) {
  				struct dentry *next;
++<<<<<<< HEAD
 +				next = list_entry(p, struct dentry, d_u.d_child);
 +				spin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);
++=======
+ 				next = list_entry(p, struct dentry, d_child);
++>>>>>>> 274f5b041d3c (dcache_{readdir,dir_lseek}(): don't bother with nested ->d_lock)
  				if (simple_positive(next))
  					n--;
- 				spin_unlock(&next->d_lock);
  				p = p->next;
  			}
 -			list_add_tail(&cursor->d_child, p);
 +			list_add_tail(&cursor->d_u.d_child, p);
  			spin_unlock(&dentry->d_lock);
+ 			inode_unlock_shared(dentry->d_inode);
  		}
  	}
 +	mutex_unlock(&dentry->d_inode->i_mutex);
  	return offset;
  }
  EXPORT_SYMBOL(dcache_dir_lseek);
@@@ -143,60 -136,34 +148,77 @@@ static inline unsigned char dt_type(str
   * both impossible due to the lock on directory.
   */
  
 -int dcache_readdir(struct file *file, struct dir_context *ctx)
 +int dcache_readdir(struct file * filp, void * dirent, filldir_t filldir)
  {
 -	struct dentry *dentry = file->f_path.dentry;
 -	struct dentry *cursor = file->private_data;
 -	struct list_head *p, *q = &cursor->d_child;
 +	struct dentry *dentry = filp->f_path.dentry;
 +	struct dentry *cursor = filp->private_data;
 +	struct list_head *p, *q = &cursor->d_u.d_child;
 +	ino_t ino;
 +	int i = filp->f_pos;
  
 -	if (!dir_emit_dots(file, ctx))
 -		return 0;
 -	spin_lock(&dentry->d_lock);
 -	if (ctx->pos == 2)
 -		list_move(q, &dentry->d_subdirs);
 +	switch (i) {
 +		case 0:
 +			ino = dentry->d_inode->i_ino;
 +			if (filldir(dirent, ".", 1, i, ino, DT_DIR) < 0)
 +				break;
 +			filp->f_pos++;
 +			i++;
 +			/* fallthrough */
 +		case 1:
 +			ino = parent_ino(dentry);
 +			if (filldir(dirent, "..", 2, i, ino, DT_DIR) < 0)
 +				break;
 +			filp->f_pos++;
 +			i++;
 +			/* fallthrough */
 +		default:
 +			spin_lock(&dentry->d_lock);
 +			if (filp->f_pos == 2)
 +				list_move(q, &dentry->d_subdirs);
  
++<<<<<<< HEAD
 +			for (p=q->next; p != &dentry->d_subdirs; p=p->next) {
 +				struct dentry *next;
 +				next = list_entry(p, struct dentry, d_u.d_child);
 +				spin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);
 +				if (!simple_positive(next)) {
 +					spin_unlock(&next->d_lock);
 +					continue;
 +				}
 +
 +				spin_unlock(&next->d_lock);
 +				spin_unlock(&dentry->d_lock);
 +				if (filldir(dirent, next->d_name.name, 
 +					    next->d_name.len, filp->f_pos, 
 +					    next->d_inode->i_ino, 
 +					    dt_type(next->d_inode)) < 0)
 +					return 0;
 +				spin_lock(&dentry->d_lock);
 +				spin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);
 +				/* next is still alive */
 +				list_move(q, p);
 +				spin_unlock(&next->d_lock);
 +				p = q;
 +				filp->f_pos++;
 +			}
 +			spin_unlock(&dentry->d_lock);
++=======
+ 	for (p = q->next; p != &dentry->d_subdirs; p = p->next) {
+ 		struct dentry *next = list_entry(p, struct dentry, d_child);
+ 		if (!simple_positive(next))
+ 			continue;
+ 
+ 		spin_unlock(&dentry->d_lock);
+ 		if (!dir_emit(ctx, next->d_name.name, next->d_name.len,
+ 			      d_inode(next)->i_ino, dt_type(d_inode(next))))
+ 			return 0;
+ 		spin_lock(&dentry->d_lock);
+ 		/* next is still alive */
+ 		list_move(q, p);
+ 		p = q;
+ 		ctx->pos++;
++>>>>>>> 274f5b041d3c (dcache_{readdir,dir_lseek}(): don't bother with nested ->d_lock)
  	}
 -	spin_unlock(&dentry->d_lock);
  	return 0;
  }
  EXPORT_SYMBOL(dcache_readdir);
* Unmerged path fs/libfs.c
