scsi: qla2xxx: Do command completion on abort timeout

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Quinn Tran <qutran@marvell.com>
commit 71c80b75ce8f08c0978ce9a9816b81b5c3ce5e12
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/71c80b75.failed

On switch, fabric and mgt command timeout, driver send Abort to tell FW to
return the original command.  If abort is timeout, then return both Abort
and original command for cleanup.

Fixes: 219d27d7147e0 ("scsi: qla2xxx: Fix race conditions in the code for aborting SCSI commands")
	Cc: stable@vger.kernel.org # 5.2
Link: https://lore.kernel.org/r/20191105150657.8092-3-hmadhani@marvell.com
	Reviewed-by: Ewan D. Milne <emilne@redhat.com>
	Signed-off-by: Quinn Tran <qutran@marvell.com>
	Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 71c80b75ce8f08c0978ce9a9816b81b5c3ce5e12)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index bffbdb309273,7fdbe041cc19..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -99,22 -97,50 +99,55 @@@ static void qla24xx_abort_iocb_timeout(
  {
  	srb_t *sp = data;
  	struct srb_iocb *abt = &sp->u.iocb_cmd;
++<<<<<<< HEAD
++=======
+ 	struct qla_qpair *qpair = sp->qpair;
+ 	u32 handle;
+ 	unsigned long flags;
+ 
+ 	if (sp->cmd_sp)
+ 		ql_dbg(ql_dbg_async, sp->vha, 0x507c,
+ 		    "Abort timeout - cmd hdl=%x, cmd type=%x hdl=%x, type=%x\n",
+ 		    sp->cmd_sp->handle, sp->cmd_sp->type,
+ 		    sp->handle, sp->type);
+ 	else
+ 		ql_dbg(ql_dbg_async, sp->vha, 0x507c,
+ 		    "Abort timeout 2 - hdl=%x, type=%x\n",
+ 		    sp->handle, sp->type);
+ 
+ 	spin_lock_irqsave(qpair->qp_lock_ptr, flags);
+ 	for (handle = 1; handle < qpair->req->num_outstanding_cmds; handle++) {
+ 		if (sp->cmd_sp && (qpair->req->outstanding_cmds[handle] ==
+ 		    sp->cmd_sp))
+ 			qpair->req->outstanding_cmds[handle] = NULL;
+ 
+ 		/* removing the abort */
+ 		if (qpair->req->outstanding_cmds[handle] == sp) {
+ 			qpair->req->outstanding_cmds[handle] = NULL;
+ 			break;
+ 		}
+ 	}
+ 	spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
++>>>>>>> 71c80b75ce8f (scsi: qla2xxx: Do command completion on abort timeout)
+ 
+ 	if (sp->cmd_sp)
+ 		sp->cmd_sp->done(sp->cmd_sp, QLA_OS_TIMER_EXPIRED);
  
  	abt->u.abt.comp_status = CS_TIMEOUT;
 -	sp->done(sp, QLA_OS_TIMER_EXPIRED);
 +	sp->done(sp, QLA_FUNCTION_TIMEOUT);
  }
  
 -static void qla24xx_abort_sp_done(srb_t *sp, int res)
 +static void qla24xx_abort_sp_done(void *ptr, int res)
  {
 +	srb_t *sp = ptr;
  	struct srb_iocb *abt = &sp->u.iocb_cmd;
  
 -	del_timer(&sp->u.iocb_cmd.timer);
 -	if (sp->flags & SRB_WAKEUP_ON_COMP)
 -		complete(&abt->u.abt.comp);
 -	else
 -		sp->free(sp);
 +	if (del_timer(&sp->u.iocb_cmd.timer)) {
 +		if (sp->flags & SRB_WAKEUP_ON_COMP)
 +			complete(&abt->u.abt.comp);
 +		else
 +			sp->free(sp);
 +	}
  }
  
  static int qla24xx_async_abort_cmd(srb_t *cmd_sp, bool wait)
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index efa92b3b1c72..0822e0dc83db 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -550,6 +550,7 @@ typedef struct srb {
 	const char *name;
 	int iocbs;
 	struct qla_qpair *qpair;
+	struct srb *cmd_sp;
 	struct list_head elem;
 	u32 gen1;	/* scratch */
 	u32 gen2;	/* scratch */
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
