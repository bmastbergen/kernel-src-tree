scsi: sd: Contribute to randomness when running rotational device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Xuewei Zhang <xueweiz@google.com>
commit 83e32a5910772e1475d3640a429b7686695f04d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/83e32a59.failed

Currently a scsi device won't contribute to kernel randomness when it uses
blk-mq. Since we commonly use scsi on rotational device with blk-mq, it make
sense to keep contributing to kernel randomness in these cases. This is
especially important for virtual machines.

commit b5b6e8c8d3b4 ("scsi: virtio_scsi: fix IO hang caused by automatic irq
vector affinity") made all virtio-scsi device to use blk-mq, which does not
contribute to randomness today. So for a virtual machine only having
virtio-scsi disk (which is common), it will simple stop getting randomness
from its disks in today's implementation.

With this patch, if the above VM has rotational virtio-scsi device, then it
can still benefit from the entropy generated from the disk.

	Reported-by: Xuewei Zhang <xueweiz@google.com>
	Signed-off-by: Xuewei Zhang <xueweiz@google.com>
	Reviewed-by: Ming Lei <ming.lei@redhat.com>
	Reviewed-by: Maciej Å»enczykowski <maze@google.com>
	Reviewed-by: Bart Van Assche <bvanassche@acm.org>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 83e32a5910772e1475d3640a429b7686695f04d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/sd.c
diff --cc drivers/scsi/sd.c
index d93fd6eb56ed,5e4f10d28065..000000000000
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@@ -2748,10 -2957,32 +2748,18 @@@ static void sd_read_block_characteristi
  	rot = get_unaligned_be16(&buffer[4]);
  
  	if (rot == 1) {
++<<<<<<< HEAD
 +		queue_flag_set_unlocked(QUEUE_FLAG_NONROT, sdkp->disk->queue);
 +		queue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, sdkp->disk->queue);
++=======
+ 		blk_queue_flag_set(QUEUE_FLAG_NONROT, q);
+ 		blk_queue_flag_clear(QUEUE_FLAG_ADD_RANDOM, q);
+ 	} else {
+ 		blk_queue_flag_clear(QUEUE_FLAG_NONROT, q);
+ 		blk_queue_flag_set(QUEUE_FLAG_ADD_RANDOM, q);
++>>>>>>> 83e32a591077 (scsi: sd: Contribute to randomness when running rotational device)
  	}
  
 -	if (sdkp->device->type == TYPE_ZBC) {
 -		/* Host-managed */
 -		q->limits.zoned = BLK_ZONED_HM;
 -	} else {
 -		sdkp->zoned = (buffer[8] >> 4) & 3;
 -		if (sdkp->zoned == 1)
 -			/* Host-aware */
 -			q->limits.zoned = BLK_ZONED_HA;
 -		else
 -			/*
 -			 * Treat drive-managed devices as
 -			 * regular block devices.
 -			 */
 -			q->limits.zoned = BLK_ZONED_NONE;
 -	}
 -	if (blk_queue_is_zoned(q) && sdkp->first_scan)
 -		sd_printk(KERN_NOTICE, sdkp, "Host-%s zoned block device\n",
 -		      q->limits.zoned == BLK_ZONED_HM ? "managed" : "aware");
 -
   out:
  	kfree(buffer);
  }
* Unmerged path drivers/scsi/sd.c
