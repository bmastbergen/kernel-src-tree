percpu: update header to contain bitmap allocator explanation.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [mm] percpu: update header to contain bitmap allocator explanation (Vladis Dronov) [1744633]
Rebuild_FUZZ: 99.19%
commit-author Dennis Zhou (Facebook) <dennisszhou@gmail.com>
commit 5e81ee3e6a79cc9fa85af5c3db0f1f269709bbf1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/5e81ee3e.failed

The other patches contain a lot of information, so adding this
information in a separate patch. It adds my copyright and a brief
explanation of how the bitmap allocator works. There is a minor typo as
well in the prior explanation so that is fixed.

	Signed-off-by: Dennis Zhou <dennisszhou@gmail.com>
	Reviewed-by: Josef Bacik <jbacik@fb.com>
	Signed-off-by: Tejun Heo <tj@kernel.org>
(cherry picked from commit 5e81ee3e6a79cc9fa85af5c3db0f1f269709bbf1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/percpu.c
diff --cc mm/percpu.c
index 3c1f6f694380,59d44d61f5f1..000000000000
--- a/mm/percpu.c
+++ b/mm/percpu.c
@@@ -4,46 -4,55 +4,77 @@@
   * Copyright (C) 2009		SUSE Linux Products GmbH
   * Copyright (C) 2009		Tejun Heo <tj@kernel.org>
   *
++<<<<<<< HEAD
 + * This file is released under the GPLv2.
++=======
+  * Copyright (C) 2017		Facebook Inc.
+  * Copyright (C) 2017		Dennis Zhou <dennisszhou@gmail.com>
+  *
+  * This file is released under the GPLv2 license.
++>>>>>>> 5e81ee3e6a79 (percpu: update header to contain bitmap allocator explanation.)
   *
 - * The percpu allocator handles both static and dynamic areas.  Percpu
 - * areas are allocated in chunks which are divided into units.  There is
 - * a 1-to-1 mapping for units to possible cpus.  These units are grouped
 - * based on NUMA properties of the machine.
 + * This is percpu allocator which can handle both static and dynamic
 + * areas.  Percpu areas are allocated in chunks.  Each chunk is
 + * consisted of boot-time determined number of units and the first
 + * chunk is used for static percpu variables in the kernel image
 + * (special boot time alloc/init handling necessary as these areas
 + * need to be brought up before allocation services are running).
 + * Unit grows as necessary and all units grow or shrink in unison.
 + * When a chunk is filled up, another chunk is allocated.
   *
   *  c0                           c1                         c2
   *  -------------------          -------------------        ------------
   * | u0 | u1 | u2 | u3 |        | u0 | u1 | u2 | u3 |      | u0 | u1 | u
   *  -------------------  ......  -------------------  ....  ------------
   *
 - * Allocation is done by offsets into a unit's address space.  Ie., an
 - * area of 512 bytes at 6k in c1 occupies 512 bytes at 6k in c1:u0,
 - * c1:u1, c1:u2, etc.  On NUMA machines, the mapping may be non-linear
 - * and even sparse.  Access is handled by configuring percpu base
 - * registers according to the cpu to unit mappings and offsetting the
 - * base address using pcpu_unit_size.
 - *
 + * Allocation is done in offset-size areas of single unit space.  Ie,
 + * an area of 512 bytes at 6k in c1 occupies 512 bytes at 6k of c1:u0,
 + * c1:u1, c1:u2 and c1:u3.  On UMA, units corresponds directly to
 + * cpus.  On NUMA, the mapping can be non-linear and even sparse.
 + * Percpu access can be done by configuring percpu base registers
 + * according to cpu to unit mapping and pcpu_unit_size.
 + *
++<<<<<<< HEAD
 + * There are usually many small percpu allocations many of them being
 + * as small as 4 bytes.  The allocator organizes chunks into lists
 + * according to free size and tries to allocate from the fullest one.
 + * Each chunk keeps the maximum contiguous area size hint which is
 + * guaranteed to be equal to or larger than the maximum contiguous
 + * area in the chunk.  This helps the allocator not to iterate the
 + * chunk maps unnecessarily.
++=======
+  * There is special consideration for the first chunk which must handle
+  * the static percpu variables in the kernel image as allocation services
+  * are not online yet.  In short, the first chunk is structured like so:
+  *
+  *                  <Static | [Reserved] | Dynamic>
   *
-  * Allocation state in each chunk is kept using an array of integers
-  * on chunk->map.  A positive value in the map represents a free
-  * region and negative allocated.  Allocation inside a chunk is done
-  * by scanning this map sequentially and serving the first matching
-  * entry.  This is mostly copied from the percpu_modalloc() allocator.
-  * Chunks can be determined from the address using the index field
-  * in the page struct. The index field contains a pointer to the chunk.
+  * The static data is copied from the original section managed by the
+  * linker.  The reserved section, if non-zero, primarily manages static
+  * percpu variables from kernel modules.  Finally, the dynamic section
+  * takes care of normal allocations.
++>>>>>>> 5e81ee3e6a79 (percpu: update header to contain bitmap allocator explanation.)
   *
+  * The allocator organizes chunks into lists according to free size and
+  * tries to allocate from the fullest chunk first.  Each chunk is managed
+  * by a bitmap with metadata blocks.  The allocation map is updated on
+  * every allocation and free to reflect the current state while the boundary
+  * map is only updated on allocation.  Each metadata block contains
+  * information to help mitigate the need to iterate over large portions
+  * of the bitmap.  The reverse mapping from page to chunk is stored in
+  * the page's index.  Lastly, units are lazily backed and grow in unison.
+  *
++<<<<<<< HEAD
 + * To use this allocator, arch code should do the followings.
++=======
+  * There is a unique conversion that goes on here between bytes and bits.
+  * Each bit represents a fragment of size PCPU_MIN_ALLOC_SIZE.  The chunk
+  * tracks the number of pages it is responsible for in nr_pages.  Helper
+  * functions are used to convert from between the bytes, bits, and blocks.
+  * All hints are managed in bits unless explicitly stated.
+  *
+  * To use this allocator, arch code should do the following:
++>>>>>>> 5e81ee3e6a79 (percpu: update header to contain bitmap allocator explanation.)
   *
   * - define __addr_to_pcpu_ptr() and __pcpu_ptr_to_addr() to translate
   *   regular address to percpu pointer and back if they need to be
* Unmerged path mm/percpu.c
