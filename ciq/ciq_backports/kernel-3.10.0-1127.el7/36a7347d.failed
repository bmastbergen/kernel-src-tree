iomap: fix page_done callback for short writes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 36a7347de097edf9c4d7203d09fa223c86479674
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/36a7347d.failed

When we truncate a short write to have it retried, pass the truncated
length to the page_done callback instead of the full length.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 36a7347de097edf9c4d7203d09fa223c86479674)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/iomap.c
diff --cc fs/iomap.c
index b368e069ba43,f15c705c5a93..000000000000
--- a/fs/iomap.c
+++ b/fs/iomap.c
@@@ -186,15 -775,32 +186,34 @@@ iomap_write_end(struct inode *inode, lo
  	int ret;
  
  	if (iomap->type == IOMAP_INLINE) {
 -		ret = iomap_write_end_inline(inode, page, iomap, pos, copied);
 -	} else if (iomap->flags & IOMAP_F_BUFFER_HEAD) {
 -		ret = block_write_end(NULL, inode->i_mapping, pos, len, copied,
 -				page, NULL);
 +		ret = iomap_write_end_inline(inode, page, iomap, pos, len,
 +				copied);
  	} else {
 -		ret = __iomap_write_end(inode, pos, len, copied, page, iomap);
 +		ret = generic_write_end(NULL, inode->i_mapping, pos, len,
 +				copied, page, NULL);
  	}
  
++<<<<<<< HEAD
 +	if (iomap->page_done)
 +		iomap->page_done(inode, pos, copied, page, iomap);
++=======
+ 	/*
+ 	 * Update the in-memory inode size after copying the data into the page
+ 	 * cache.  It's up to the file system to write the updated size to disk,
+ 	 * preferably after I/O completion so that no stale data is exposed.
+ 	 */
+ 	if (pos + ret > old_size) {
+ 		i_size_write(inode, pos + ret);
+ 		iomap->flags |= IOMAP_F_SIZE_CHANGED;
+ 	}
+ 	unlock_page(page);
+ 
+ 	if (old_size < pos)
+ 		pagecache_isize_extended(inode, old_size, pos);
+ 	if (page_ops && page_ops->page_done)
+ 		page_ops->page_done(inode, pos, ret, page, iomap);
+ 	put_page(page);
++>>>>>>> 36a7347de097 (iomap: fix page_done callback for short writes)
  
  	if (ret < len)
  		iomap_write_failed(inode, pos, len);
* Unmerged path fs/iomap.c
