ipv6: icmp: Updating pmtu for link local route

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Georg Kohmann <geokohma@cisco.com>
commit 5f379ef51bc967567bbddacdcdecb772d4d7c3b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/5f379ef5.failed

When a ICMPV6_PKT_TOOBIG is received from a link local address the pmtu will
be updated on a route with an arbitrary interface index. Subsequent packets
sent back to the same link local address may therefore end up not
considering the updated pmtu.

Current behavior breaks TAHI v6LC4.1.4 Reduce PMTU On-link. Referring to RFC
1981: Section 3: "Note that Path MTU Discovery must be performed even in
cases where a node "thinks" a destination is attached to the same link as
itself. In a situation such as when a neighboring router acts as proxy [ND]
for some destination, the destination can to appear to be directly
connected but is in fact more than one hop away."

Using the interface index from the incoming ICMPV6_PKT_TOOBIG when updating
the pmtu.

	Signed-off-by: Georg Kohmann <geokohma@cisco.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5f379ef51bc967567bbddacdcdecb772d4d7c3b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/icmp.c
diff --cc net/ipv6/icmp.c
index e629e07c2516,7f6b1f81c200..000000000000
--- a/net/ipv6/icmp.c
+++ b/net/ipv6/icmp.c
@@@ -87,9 -90,16 +87,13 @@@ static void icmpv6_err(struct sk_buff *
  	struct net *net = dev_net(skb->dev);
  
  	if (type == ICMPV6_PKT_TOOBIG)
++<<<<<<< HEAD
 +		ip6_update_pmtu(skb, net, info, 0, 0);
++=======
+ 		ip6_update_pmtu(skb, net, info, skb->dev->ifindex, 0, sock_net_uid(net, NULL));
++>>>>>>> 5f379ef51bc9 (ipv6: icmp: Updating pmtu for link local route)
  	else if (type == NDISC_REDIRECT)
 -		ip6_redirect(skb, net, skb->dev->ifindex, 0,
 -			     sock_net_uid(net, NULL));
 -
 -	if (!(type & ICMPV6_INFOMSG_MASK))
 -		if (icmp6->icmp6_type == ICMPV6_ECHO_REQUEST)
 -			ping_err(skb, offset, ntohl(info));
 +		ip6_redirect(skb, net, skb->dev->ifindex, 0);
  }
  
  static int icmpv6_rcv(struct sk_buff *skb);
* Unmerged path net/ipv6/icmp.c
