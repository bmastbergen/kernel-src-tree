ipvs: Pass ipvs not net to start_sync_thread

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 6ac121d710697cee894d6981b804583b0a66ed38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/6ac121d7.failed

	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
	Acked-by: Julian Anastasov <ja@ssi.bg>
	Signed-off-by: Simon Horman <horms@verge.net.au>
(cherry picked from commit 6ac121d710697cee894d6981b804583b0a66ed38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip_vs.h
#	net/netfilter/ipvs/ip_vs_ctl.c
#	net/netfilter/ipvs/ip_vs_sync.c
diff --cc include/net/ip_vs.h
index 2d7cb932edee,dd7cd3a48fd4..000000000000
--- a/include/net/ip_vs.h
+++ b/include/net/ip_vs.h
@@@ -1416,11 -1440,17 +1416,16 @@@ static inline void ip_vs_dest_put(struc
  	atomic_dec(&dest->refcnt);
  }
  
 -static inline void ip_vs_dest_put_and_free(struct ip_vs_dest *dest)
 -{
 -	if (atomic_dec_return(&dest->refcnt) < 0)
 -		kfree(dest);
 -}
 -
 -/* IPVS sync daemon data and function prototypes
 - * (from ip_vs_sync.c)
 +/*
 + *      IPVS sync daemon data and function prototypes
 + *      (from ip_vs_sync.c)
   */
++<<<<<<< HEAD
 +int start_sync_thread(struct net *net, int state, char *mcast_ifn, __u8 syncid);
++=======
+ int start_sync_thread(struct netns_ipvs *ipvs, struct ipvs_sync_daemon_cfg *cfg,
+ 		      int state);
++>>>>>>> 6ac121d71069 (ipvs: Pass ipvs not net to start_sync_thread)
  int stop_sync_thread(struct net *net, int state);
  void ip_vs_sync_conn(struct net *net, struct ip_vs_conn *cp, int pkts);
  
diff --cc net/netfilter/ipvs/ip_vs_ctl.c
index 4aed1d77d557,b63b4c186040..000000000000
--- a/net/netfilter/ipvs/ip_vs_ctl.c
+++ b/net/netfilter/ipvs/ip_vs_ctl.c
@@@ -2406,13 -2341,23 +2406,30 @@@ do_ip_vs_set_ctl(struct sock *sk, int c
  	    cmd == IP_VS_SO_SET_STOPDAEMON) {
  		struct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;
  
++<<<<<<< HEAD
 +		mutex_lock(&ipvs->sync_mutex);
 +		if (cmd == IP_VS_SO_SET_STARTDAEMON)
 +			ret = start_sync_thread(net, dm->state, dm->mcast_ifn,
 +						dm->syncid);
 +		else
++=======
+ 		if (cmd == IP_VS_SO_SET_STARTDAEMON) {
+ 			struct ipvs_sync_daemon_cfg cfg;
+ 
+ 			memset(&cfg, 0, sizeof(cfg));
+ 			strlcpy(cfg.mcast_ifn, dm->mcast_ifn,
+ 				sizeof(cfg.mcast_ifn));
+ 			cfg.syncid = dm->syncid;
+ 			rtnl_lock();
+ 			mutex_lock(&ipvs->sync_mutex);
+ 			ret = start_sync_thread(ipvs, &cfg, dm->state);
+ 			mutex_unlock(&ipvs->sync_mutex);
+ 			rtnl_unlock();
+ 		} else {
+ 			mutex_lock(&ipvs->sync_mutex);
++>>>>>>> 6ac121d71069 (ipvs: Pass ipvs not net to start_sync_thread)
  			ret = stop_sync_thread(net, dm->state);
 -			mutex_unlock(&ipvs->sync_mutex);
 -		}
 +		mutex_unlock(&ipvs->sync_mutex);
  		goto out_dec;
  	}
  
@@@ -3364,15 -3385,64 +3381,66 @@@ static int ip_vs_genl_new_daemon(struc
  	      attrs[IPVS_DAEMON_ATTR_MCAST_IFN] &&
  	      attrs[IPVS_DAEMON_ATTR_SYNC_ID]))
  		return -EINVAL;
 -	strlcpy(c.mcast_ifn, nla_data(attrs[IPVS_DAEMON_ATTR_MCAST_IFN]),
 -		sizeof(c.mcast_ifn));
 -	c.syncid = nla_get_u32(attrs[IPVS_DAEMON_ATTR_SYNC_ID]);
  
++<<<<<<< HEAD
 +	return start_sync_thread(net,
 +				 nla_get_u32(attrs[IPVS_DAEMON_ATTR_STATE]),
 +				 nla_data(attrs[IPVS_DAEMON_ATTR_MCAST_IFN]),
 +				 nla_get_u32(attrs[IPVS_DAEMON_ATTR_SYNC_ID]));
++=======
+ 	a = attrs[IPVS_DAEMON_ATTR_SYNC_MAXLEN];
+ 	if (a)
+ 		c.sync_maxlen = nla_get_u16(a);
+ 
+ 	a = attrs[IPVS_DAEMON_ATTR_MCAST_GROUP];
+ 	if (a) {
+ 		c.mcast_af = AF_INET;
+ 		c.mcast_group.ip = nla_get_in_addr(a);
+ 		if (!ipv4_is_multicast(c.mcast_group.ip))
+ 			return -EINVAL;
+ 	} else {
+ 		a = attrs[IPVS_DAEMON_ATTR_MCAST_GROUP6];
+ 		if (a) {
+ #ifdef CONFIG_IP_VS_IPV6
+ 			int addr_type;
+ 
+ 			c.mcast_af = AF_INET6;
+ 			c.mcast_group.in6 = nla_get_in6_addr(a);
+ 			addr_type = ipv6_addr_type(&c.mcast_group.in6);
+ 			if (!(addr_type & IPV6_ADDR_MULTICAST))
+ 				return -EINVAL;
+ #else
+ 			return -EAFNOSUPPORT;
+ #endif
+ 		}
+ 	}
+ 
+ 	a = attrs[IPVS_DAEMON_ATTR_MCAST_PORT];
+ 	if (a)
+ 		c.mcast_port = nla_get_u16(a);
+ 
+ 	a = attrs[IPVS_DAEMON_ATTR_MCAST_TTL];
+ 	if (a)
+ 		c.mcast_ttl = nla_get_u8(a);
+ 
+ 	/* The synchronization protocol is incompatible with mixed family
+ 	 * services
+ 	 */
+ 	if (ipvs->mixed_address_family_dests > 0)
+ 		return -EINVAL;
+ 
+ 	rtnl_lock();
+ 	mutex_lock(&ipvs->sync_mutex);
+ 	ret = start_sync_thread(ipvs, &c,
+ 				nla_get_u32(attrs[IPVS_DAEMON_ATTR_STATE]));
+ 	mutex_unlock(&ipvs->sync_mutex);
+ 	rtnl_unlock();
+ 	return ret;
++>>>>>>> 6ac121d71069 (ipvs: Pass ipvs not net to start_sync_thread)
  }
  
 -static int ip_vs_genl_del_daemon(struct netns_ipvs *ipvs, struct nlattr **attrs)
 +static int ip_vs_genl_del_daemon(struct net *net, struct nlattr **attrs)
  {
 -	int ret;
 -
  	if (!attrs[IPVS_DAEMON_ATTR_STATE])
  		return -EINVAL;
  
diff --cc net/netfilter/ipvs/ip_vs_sync.c
index ab0e9562476c,90c455c0b42b..000000000000
--- a/net/netfilter/ipvs/ip_vs_sync.c
+++ b/net/netfilter/ipvs/ip_vs_sync.c
@@@ -1715,16 -1778,18 +1715,25 @@@ static int sync_thread_backup(void *dat
  }
  
  
++<<<<<<< HEAD
 +int start_sync_thread(struct net *net, int state, char *mcast_ifn, __u8 syncid)
++=======
+ int start_sync_thread(struct netns_ipvs *ipvs, struct ipvs_sync_daemon_cfg *c,
+ 		      int state)
++>>>>>>> 6ac121d71069 (ipvs: Pass ipvs not net to start_sync_thread)
  {
  	struct ip_vs_sync_thread_data *tinfo;
  	struct task_struct **array = NULL, *task;
  	struct socket *sock;
++<<<<<<< HEAD
 +	struct netns_ipvs *ipvs = net_ipvs(net);
++=======
+ 	struct net_device *dev;
++>>>>>>> 6ac121d71069 (ipvs: Pass ipvs not net to start_sync_thread)
  	char *name;
  	int (*threadfn)(void *data);
 -	int id, count, hlen;
 +	int id, count;
  	int result = -ENOMEM;
 -	u16 mtu, min_mtu;
  
  	IP_VS_DBG(7, "%s(): pid %d\n", __func__, task_pid_nr(current));
  	IP_VS_DBG(7, "Each ip_vs_sync_conn entry needs %Zd bytes\n",
@@@ -1736,6 -1801,34 +1745,37 @@@
  	} else
  		count = ipvs->threads_mask + 1;
  
++<<<<<<< HEAD
++=======
+ 	if (c->mcast_af == AF_UNSPEC) {
+ 		c->mcast_af = AF_INET;
+ 		c->mcast_group.ip = cpu_to_be32(IP_VS_SYNC_GROUP);
+ 	}
+ 	if (!c->mcast_port)
+ 		c->mcast_port = IP_VS_SYNC_PORT;
+ 	if (!c->mcast_ttl)
+ 		c->mcast_ttl = 1;
+ 
+ 	dev = __dev_get_by_name(ipvs->net, c->mcast_ifn);
+ 	if (!dev) {
+ 		pr_err("Unknown mcast interface: %s\n", c->mcast_ifn);
+ 		return -ENODEV;
+ 	}
+ 	hlen = (AF_INET6 == c->mcast_af) ?
+ 	       sizeof(struct ipv6hdr) + sizeof(struct udphdr) :
+ 	       sizeof(struct iphdr) + sizeof(struct udphdr);
+ 	mtu = (state == IP_VS_STATE_BACKUP) ?
+ 		  clamp(dev->mtu, 1500U, 65535U) : 1500U;
+ 	min_mtu = (state == IP_VS_STATE_BACKUP) ? 1024 : 1;
+ 
+ 	if (c->sync_maxlen)
+ 		c->sync_maxlen = clamp_t(unsigned int,
+ 					 c->sync_maxlen, min_mtu,
+ 					 65535 - hlen);
+ 	else
+ 		c->sync_maxlen = mtu - hlen;
+ 
++>>>>>>> 6ac121d71069 (ipvs: Pass ipvs not net to start_sync_thread)
  	if (state == IP_VS_STATE_MASTER) {
  		if (ipvs->ms)
  			return -EEXIST;
@@@ -1794,10 -1882,10 +1834,10 @@@
  		tinfo = kmalloc(sizeof(*tinfo), GFP_KERNEL);
  		if (!tinfo)
  			goto outsocket;
- 		tinfo->net = net;
+ 		tinfo->net = ipvs->net;
  		tinfo->sock = sock;
  		if (state == IP_VS_STATE_BACKUP) {
 -			tinfo->buf = kmalloc(ipvs->bcfg.sync_maxlen,
 +			tinfo->buf = kmalloc(ipvs->recv_mesg_maxlen,
  					     GFP_KERNEL);
  			if (!tinfo->buf)
  				goto outtinfo;
* Unmerged path include/net/ip_vs.h
* Unmerged path net/netfilter/ipvs/ip_vs_ctl.c
* Unmerged path net/netfilter/ipvs/ip_vs_sync.c
