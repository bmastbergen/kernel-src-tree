kvm: Convert kvm_lock to a mutex

jira LE-1907
cve CVE-2018-12207
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Junaid Shahid <junaids@google.com>
commit 0d9ce162cf46c99628cc5da9510b959c7976735b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/0d9ce162.failed

It doesn't seem as if there is any particular need for kvm_lock to be a
spinlock, so convert the lock to a mutex so that sleepable functions (in
particular cond_resched()) can be called while holding it.

	Signed-off-by: Junaid Shahid <junaids@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 0d9ce162cf46c99628cc5da9510b959c7976735b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kvm/kvm-s390.c
#	arch/x86/kvm/mmu.c
#	arch/x86/kvm/x86.c
#	virt/kvm/kvm_main.c
diff --cc arch/s390/kvm/kvm-s390.c
index 875286d3fac7,0fef9192f6ac..000000000000
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@@ -205,104 -789,1736 +205,114 @@@ static int kvm_vm_ioctl_enable_cap(stru
  	return r;
  }
  
 -static int kvm_s390_get_mem_control(struct kvm *kvm, struct kvm_device_attr *attr)
 +long kvm_arch_vm_ioctl(struct file *filp,
 +		       unsigned int ioctl, unsigned long arg)
  {
 -	int ret;
 +	struct kvm *kvm = filp->private_data;
 +	void __user *argp = (void __user *)arg;
 +	int r;
  
 -	switch (attr->attr) {
 -	case KVM_S390_VM_MEM_LIMIT_SIZE:
 -		ret = 0;
 -		VM_EVENT(kvm, 3, "QUERY: max guest memory: %lu bytes",
 -			 kvm->arch.mem_limit);
 -		if (put_user(kvm->arch.mem_limit, (u64 __user *)attr->addr))
 -			ret = -EFAULT;
 +	switch (ioctl) {
 +	case KVM_S390_INTERRUPT: {
 +		struct kvm_s390_interrupt s390int;
 +
 +		r = -EFAULT;
 +		if (copy_from_user(&s390int, argp, sizeof(s390int)))
 +			break;
 +		r = kvm_s390_inject_vm(kvm, &s390int);
  		break;
 -	default:
 -		ret = -ENXIO;
 +	}
 +	case KVM_ENABLE_CAP: {
 +		struct kvm_enable_cap cap;
 +		r = -EFAULT;
 +		if (copy_from_user(&cap, argp, sizeof(cap)))
 +			break;
 +		r = kvm_vm_ioctl_enable_cap(kvm, &cap);
  		break;
  	}
 -	return ret;
 +	default:
 +		r = -ENOTTY;
 +	}
 +
 +	return r;
  }
  
 -static int kvm_s390_set_mem_control(struct kvm *kvm, struct kvm_device_attr *attr)
 +int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
  {
 -	int ret;
 -	unsigned int idx;
 -	switch (attr->attr) {
 -	case KVM_S390_VM_MEM_ENABLE_CMMA:
 -		ret = -ENXIO;
 -		if (!sclp.has_cmma)
 -			break;
 -
 -		VM_EVENT(kvm, 3, "%s", "ENABLE: CMMA support");
 -		mutex_lock(&kvm->lock);
 -		if (kvm->created_vcpus)
 -			ret = -EBUSY;
 -		else if (kvm->mm->context.allow_gmap_hpage_1m)
 -			ret = -EINVAL;
 -		else {
 -			kvm->arch.use_cmma = 1;
 -			/* Not compatible with cmma. */
 -			kvm->arch.use_pfmfi = 0;
 -			ret = 0;
 -		}
 -		mutex_unlock(&kvm->lock);
 -		break;
 -	case KVM_S390_VM_MEM_CLR_CMMA:
 -		ret = -ENXIO;
 -		if (!sclp.has_cmma)
 -			break;
 -		ret = -EINVAL;
 -		if (!kvm->arch.use_cmma)
 -			break;
 +	int rc;
 +	char debug_name[16];
  
 -		VM_EVENT(kvm, 3, "%s", "RESET: CMMA states");
 -		mutex_lock(&kvm->lock);
 -		idx = srcu_read_lock(&kvm->srcu);
 -		s390_reset_cmma(kvm->arch.gmap->mm);
 -		srcu_read_unlock(&kvm->srcu, idx);
 -		mutex_unlock(&kvm->lock);
 -		ret = 0;
 -		break;
 -	case KVM_S390_VM_MEM_LIMIT_SIZE: {
 -		unsigned long new_limit;
 +	rc = -EINVAL;
 +#ifdef CONFIG_KVM_S390_UCONTROL
 +	if (type & ~KVM_VM_S390_UCONTROL)
 +		goto out_err;
 +	if ((type & KVM_VM_S390_UCONTROL) && (!capable(CAP_SYS_ADMIN)))
 +		goto out_err;
 +#else
 +	if (type)
 +		goto out_err;
 +#endif
  
 -		if (kvm_is_ucontrol(kvm))
 -			return -EINVAL;
 +	rc = s390_enable_sie();
 +	if (rc)
 +		goto out_err;
  
 -		if (get_user(new_limit, (u64 __user *)attr->addr))
 -			return -EFAULT;
 +	rc = -ENOMEM;
  
 -		if (kvm->arch.mem_limit != KVM_S390_NO_MEM_LIMIT &&
 -		    new_limit > kvm->arch.mem_limit)
 -			return -E2BIG;
 -
 -		if (!new_limit)
 -			return -EINVAL;
 -
 -		/* gmap_create takes last usable address */
 -		if (new_limit != KVM_S390_NO_MEM_LIMIT)
 -			new_limit -= 1;
 -
 -		ret = -EBUSY;
 -		mutex_lock(&kvm->lock);
 -		if (!kvm->created_vcpus) {
 -			/* gmap_create will round the limit up */
 -			struct gmap *new = gmap_create(current->mm, new_limit);
 -
 -			if (!new) {
 -				ret = -ENOMEM;
 -			} else {
 -				gmap_remove(kvm->arch.gmap);
 -				new->private = kvm;
 -				kvm->arch.gmap = new;
 -				ret = 0;
 -			}
 -		}
 -		mutex_unlock(&kvm->lock);
 -		VM_EVENT(kvm, 3, "SET: max guest address: %lu", new_limit);
 -		VM_EVENT(kvm, 3, "New guest asce: 0x%pK",
 -			 (void *) kvm->arch.gmap->asce);
 -		break;
 -	}
 -	default:
 -		ret = -ENXIO;
 -		break;
 -	}
 -	return ret;
 -}
 +	kvm->arch.sca = (struct sca_block *) get_zeroed_page(GFP_KERNEL);
 +	ratelimit_state_init(&kvm->arch.sthyi_limit, 5 * HZ, 500);
  
 -static void kvm_s390_vcpu_crypto_setup(struct kvm_vcpu *vcpu);
 +	if (!kvm->arch.sca)
 +		goto out_err;
++<<<<<<< HEAD
++=======
++	mutex_lock(&kvm_lock);
++	sca_offset += 16;
++	if (sca_offset + sizeof(struct bsca_block) > PAGE_SIZE)
++		sca_offset = 0;
++	kvm->arch.sca = (struct bsca_block *)
++			((char *) kvm->arch.sca + sca_offset);
++	mutex_unlock(&kvm_lock);
++>>>>>>> 0d9ce162cf46 (kvm: Convert kvm_lock to a mutex)
  
 -void kvm_s390_vcpu_crypto_reset_all(struct kvm *kvm)
 -{
 -	struct kvm_vcpu *vcpu;
 -	int i;
 +	sprintf(debug_name, "kvm-%u", current->pid);
  
 -	kvm_s390_vcpu_block_all(kvm);
 +	kvm->arch.dbf = debug_register(debug_name, 8, 2, 8 * sizeof(long));
 +	if (!kvm->arch.dbf)
 +		goto out_nodbf;
  
 -	kvm_for_each_vcpu(i, vcpu, kvm) {
 -		kvm_s390_vcpu_crypto_setup(vcpu);
 -		/* recreate the shadow crycb by leaving the VSIE handler */
 -		kvm_s390_sync_request(KVM_REQ_VSIE_RESTART, vcpu);
 -	}
 +	spin_lock_init(&kvm->arch.float_int.lock);
 +	INIT_LIST_HEAD(&kvm->arch.float_int.list);
  
 -	kvm_s390_vcpu_unblock_all(kvm);
 -}
 +	debug_register_view(kvm->arch.dbf, &debug_sprintf_view);
 +	VM_EVENT(kvm, 3, "%s", "vm created");
  
 -static int kvm_s390_vm_set_crypto(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	mutex_lock(&kvm->lock);
 -	switch (attr->attr) {
 -	case KVM_S390_VM_CRYPTO_ENABLE_AES_KW:
 -		if (!test_kvm_facility(kvm, 76)) {
 -			mutex_unlock(&kvm->lock);
 -			return -EINVAL;
 -		}
 -		get_random_bytes(
 -			kvm->arch.crypto.crycb->aes_wrapping_key_mask,
 -			sizeof(kvm->arch.crypto.crycb->aes_wrapping_key_mask));
 -		kvm->arch.crypto.aes_kw = 1;
 -		VM_EVENT(kvm, 3, "%s", "ENABLE: AES keywrapping support");
 -		break;
 -	case KVM_S390_VM_CRYPTO_ENABLE_DEA_KW:
 -		if (!test_kvm_facility(kvm, 76)) {
 -			mutex_unlock(&kvm->lock);
 -			return -EINVAL;
 -		}
 -		get_random_bytes(
 -			kvm->arch.crypto.crycb->dea_wrapping_key_mask,
 -			sizeof(kvm->arch.crypto.crycb->dea_wrapping_key_mask));
 -		kvm->arch.crypto.dea_kw = 1;
 -		VM_EVENT(kvm, 3, "%s", "ENABLE: DEA keywrapping support");
 -		break;
 -	case KVM_S390_VM_CRYPTO_DISABLE_AES_KW:
 -		if (!test_kvm_facility(kvm, 76)) {
 -			mutex_unlock(&kvm->lock);
 -			return -EINVAL;
 -		}
 -		kvm->arch.crypto.aes_kw = 0;
 -		memset(kvm->arch.crypto.crycb->aes_wrapping_key_mask, 0,
 -			sizeof(kvm->arch.crypto.crycb->aes_wrapping_key_mask));
 -		VM_EVENT(kvm, 3, "%s", "DISABLE: AES keywrapping support");
 -		break;
 -	case KVM_S390_VM_CRYPTO_DISABLE_DEA_KW:
 -		if (!test_kvm_facility(kvm, 76)) {
 -			mutex_unlock(&kvm->lock);
 -			return -EINVAL;
 -		}
 -		kvm->arch.crypto.dea_kw = 0;
 -		memset(kvm->arch.crypto.crycb->dea_wrapping_key_mask, 0,
 -			sizeof(kvm->arch.crypto.crycb->dea_wrapping_key_mask));
 -		VM_EVENT(kvm, 3, "%s", "DISABLE: DEA keywrapping support");
 -		break;
 -	case KVM_S390_VM_CRYPTO_ENABLE_APIE:
 -		if (!ap_instructions_available()) {
 -			mutex_unlock(&kvm->lock);
 -			return -EOPNOTSUPP;
 -		}
 -		kvm->arch.crypto.apie = 1;
 -		break;
 -	case KVM_S390_VM_CRYPTO_DISABLE_APIE:
 -		if (!ap_instructions_available()) {
 -			mutex_unlock(&kvm->lock);
 -			return -EOPNOTSUPP;
 -		}
 -		kvm->arch.crypto.apie = 0;
 -		break;
 -	default:
 -		mutex_unlock(&kvm->lock);
 -		return -ENXIO;
 +	if (type & KVM_VM_S390_UCONTROL) {
 +		kvm->arch.gmap = NULL;
 +	} else {
 +		kvm->arch.gmap = gmap_alloc(current->mm);
 +		if (!kvm->arch.gmap)
 +			goto out_nogmap;
 +		kvm->arch.gmap->private = kvm;
  	}
  
 -	kvm_s390_vcpu_crypto_reset_all(kvm);
 -	mutex_unlock(&kvm->lock);
 +	kvm->arch.css_support = 0;
 +
  	return 0;
 +out_nogmap:
 +	debug_unregister(kvm->arch.dbf);
 +out_nodbf:
 +	free_page((unsigned long)(kvm->arch.sca));
 +out_err:
 +	return rc;
  }
  
 -static void kvm_s390_sync_request_broadcast(struct kvm *kvm, int req)
 +bool kvm_arch_has_vcpu_debugfs(void)
  {
 -	int cx;
 -	struct kvm_vcpu *vcpu;
 -
 -	kvm_for_each_vcpu(cx, vcpu, kvm)
 -		kvm_s390_sync_request(req, vcpu);
 +	return false;
  }
  
 -/*
 - * Must be called with kvm->srcu held to avoid races on memslots, and with
 - * kvm->slots_lock to avoid races with ourselves and kvm_s390_vm_stop_migration.
 - */
 -static int kvm_s390_vm_start_migration(struct kvm *kvm)
 -{
 -	struct kvm_memory_slot *ms;
 -	struct kvm_memslots *slots;
 -	unsigned long ram_pages = 0;
 -	int slotnr;
 -
 -	/* migration mode already enabled */
 -	if (kvm->arch.migration_mode)
 -		return 0;
 -	slots = kvm_memslots(kvm);
 -	if (!slots || !slots->used_slots)
 -		return -EINVAL;
 -
 -	if (!kvm->arch.use_cmma) {
 -		kvm->arch.migration_mode = 1;
 -		return 0;
 -	}
 -	/* mark all the pages in active slots as dirty */
 -	for (slotnr = 0; slotnr < slots->used_slots; slotnr++) {
 -		ms = slots->memslots + slotnr;
 -		/*
 -		 * The second half of the bitmap is only used on x86,
 -		 * and would be wasted otherwise, so we put it to good
 -		 * use here to keep track of the state of the storage
 -		 * attributes.
 -		 */
 -		memset(kvm_second_dirty_bitmap(ms), 0xff, kvm_dirty_bitmap_bytes(ms));
 -		ram_pages += ms->npages;
 -	}
 -	atomic64_set(&kvm->arch.cmma_dirty_pages, ram_pages);
 -	kvm->arch.migration_mode = 1;
 -	kvm_s390_sync_request_broadcast(kvm, KVM_REQ_START_MIGRATION);
 -	return 0;
 -}
 -
 -/*
 - * Must be called with kvm->slots_lock to avoid races with ourselves and
 - * kvm_s390_vm_start_migration.
 - */
 -static int kvm_s390_vm_stop_migration(struct kvm *kvm)
 -{
 -	/* migration mode already disabled */
 -	if (!kvm->arch.migration_mode)
 -		return 0;
 -	kvm->arch.migration_mode = 0;
 -	if (kvm->arch.use_cmma)
 -		kvm_s390_sync_request_broadcast(kvm, KVM_REQ_STOP_MIGRATION);
 -	return 0;
 -}
 -
 -static int kvm_s390_vm_set_migration(struct kvm *kvm,
 -				     struct kvm_device_attr *attr)
 -{
 -	int res = -ENXIO;
 -
 -	mutex_lock(&kvm->slots_lock);
 -	switch (attr->attr) {
 -	case KVM_S390_VM_MIGRATION_START:
 -		res = kvm_s390_vm_start_migration(kvm);
 -		break;
 -	case KVM_S390_VM_MIGRATION_STOP:
 -		res = kvm_s390_vm_stop_migration(kvm);
 -		break;
 -	default:
 -		break;
 -	}
 -	mutex_unlock(&kvm->slots_lock);
 -
 -	return res;
 -}
 -
 -static int kvm_s390_vm_get_migration(struct kvm *kvm,
 -				     struct kvm_device_attr *attr)
 -{
 -	u64 mig = kvm->arch.migration_mode;
 -
 -	if (attr->attr != KVM_S390_VM_MIGRATION_STATUS)
 -		return -ENXIO;
 -
 -	if (copy_to_user((void __user *)attr->addr, &mig, sizeof(mig)))
 -		return -EFAULT;
 -	return 0;
 -}
 -
 -static int kvm_s390_set_tod_ext(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	struct kvm_s390_vm_tod_clock gtod;
 -
 -	if (copy_from_user(&gtod, (void __user *)attr->addr, sizeof(gtod)))
 -		return -EFAULT;
 -
 -	if (!test_kvm_facility(kvm, 139) && gtod.epoch_idx)
 -		return -EINVAL;
 -	kvm_s390_set_tod_clock(kvm, &gtod);
 -
 -	VM_EVENT(kvm, 3, "SET: TOD extension: 0x%x, TOD base: 0x%llx",
 -		gtod.epoch_idx, gtod.tod);
 -
 -	return 0;
 -}
 -
 -static int kvm_s390_set_tod_high(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	u8 gtod_high;
 -
 -	if (copy_from_user(&gtod_high, (void __user *)attr->addr,
 -					   sizeof(gtod_high)))
 -		return -EFAULT;
 -
 -	if (gtod_high != 0)
 -		return -EINVAL;
 -	VM_EVENT(kvm, 3, "SET: TOD extension: 0x%x", gtod_high);
 -
 -	return 0;
 -}
 -
 -static int kvm_s390_set_tod_low(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	struct kvm_s390_vm_tod_clock gtod = { 0 };
 -
 -	if (copy_from_user(&gtod.tod, (void __user *)attr->addr,
 -			   sizeof(gtod.tod)))
 -		return -EFAULT;
 -
 -	kvm_s390_set_tod_clock(kvm, &gtod);
 -	VM_EVENT(kvm, 3, "SET: TOD base: 0x%llx", gtod.tod);
 -	return 0;
 -}
 -
 -static int kvm_s390_set_tod(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	int ret;
 -
 -	if (attr->flags)
 -		return -EINVAL;
 -
 -	switch (attr->attr) {
 -	case KVM_S390_VM_TOD_EXT:
 -		ret = kvm_s390_set_tod_ext(kvm, attr);
 -		break;
 -	case KVM_S390_VM_TOD_HIGH:
 -		ret = kvm_s390_set_tod_high(kvm, attr);
 -		break;
 -	case KVM_S390_VM_TOD_LOW:
 -		ret = kvm_s390_set_tod_low(kvm, attr);
 -		break;
 -	default:
 -		ret = -ENXIO;
 -		break;
 -	}
 -	return ret;
 -}
 -
 -static void kvm_s390_get_tod_clock(struct kvm *kvm,
 -				   struct kvm_s390_vm_tod_clock *gtod)
 -{
 -	struct kvm_s390_tod_clock_ext htod;
 -
 -	preempt_disable();
 -
 -	get_tod_clock_ext((char *)&htod);
 -
 -	gtod->tod = htod.tod + kvm->arch.epoch;
 -	gtod->epoch_idx = 0;
 -	if (test_kvm_facility(kvm, 139)) {
 -		gtod->epoch_idx = htod.epoch_idx + kvm->arch.epdx;
 -		if (gtod->tod < htod.tod)
 -			gtod->epoch_idx += 1;
 -	}
 -
 -	preempt_enable();
 -}
 -
 -static int kvm_s390_get_tod_ext(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	struct kvm_s390_vm_tod_clock gtod;
 -
 -	memset(&gtod, 0, sizeof(gtod));
 -	kvm_s390_get_tod_clock(kvm, &gtod);
 -	if (copy_to_user((void __user *)attr->addr, &gtod, sizeof(gtod)))
 -		return -EFAULT;
 -
 -	VM_EVENT(kvm, 3, "QUERY: TOD extension: 0x%x, TOD base: 0x%llx",
 -		gtod.epoch_idx, gtod.tod);
 -	return 0;
 -}
 -
 -static int kvm_s390_get_tod_high(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	u8 gtod_high = 0;
 -
 -	if (copy_to_user((void __user *)attr->addr, &gtod_high,
 -					 sizeof(gtod_high)))
 -		return -EFAULT;
 -	VM_EVENT(kvm, 3, "QUERY: TOD extension: 0x%x", gtod_high);
 -
 -	return 0;
 -}
 -
 -static int kvm_s390_get_tod_low(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	u64 gtod;
 -
 -	gtod = kvm_s390_get_tod_clock_fast(kvm);
 -	if (copy_to_user((void __user *)attr->addr, &gtod, sizeof(gtod)))
 -		return -EFAULT;
 -	VM_EVENT(kvm, 3, "QUERY: TOD base: 0x%llx", gtod);
 -
 -	return 0;
 -}
 -
 -static int kvm_s390_get_tod(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	int ret;
 -
 -	if (attr->flags)
 -		return -EINVAL;
 -
 -	switch (attr->attr) {
 -	case KVM_S390_VM_TOD_EXT:
 -		ret = kvm_s390_get_tod_ext(kvm, attr);
 -		break;
 -	case KVM_S390_VM_TOD_HIGH:
 -		ret = kvm_s390_get_tod_high(kvm, attr);
 -		break;
 -	case KVM_S390_VM_TOD_LOW:
 -		ret = kvm_s390_get_tod_low(kvm, attr);
 -		break;
 -	default:
 -		ret = -ENXIO;
 -		break;
 -	}
 -	return ret;
 -}
 -
 -static int kvm_s390_set_processor(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	struct kvm_s390_vm_cpu_processor *proc;
 -	u16 lowest_ibc, unblocked_ibc;
 -	int ret = 0;
 -
 -	mutex_lock(&kvm->lock);
 -	if (kvm->created_vcpus) {
 -		ret = -EBUSY;
 -		goto out;
 -	}
 -	proc = kzalloc(sizeof(*proc), GFP_KERNEL);
 -	if (!proc) {
 -		ret = -ENOMEM;
 -		goto out;
 -	}
 -	if (!copy_from_user(proc, (void __user *)attr->addr,
 -			    sizeof(*proc))) {
 -		kvm->arch.model.cpuid = proc->cpuid;
 -		lowest_ibc = sclp.ibc >> 16 & 0xfff;
 -		unblocked_ibc = sclp.ibc & 0xfff;
 -		if (lowest_ibc && proc->ibc) {
 -			if (proc->ibc > unblocked_ibc)
 -				kvm->arch.model.ibc = unblocked_ibc;
 -			else if (proc->ibc < lowest_ibc)
 -				kvm->arch.model.ibc = lowest_ibc;
 -			else
 -				kvm->arch.model.ibc = proc->ibc;
 -		}
 -		memcpy(kvm->arch.model.fac_list, proc->fac_list,
 -		       S390_ARCH_FAC_LIST_SIZE_BYTE);
 -		VM_EVENT(kvm, 3, "SET: guest ibc: 0x%4.4x, guest cpuid: 0x%16.16llx",
 -			 kvm->arch.model.ibc,
 -			 kvm->arch.model.cpuid);
 -		VM_EVENT(kvm, 3, "SET: guest faclist: 0x%16.16llx.%16.16llx.%16.16llx",
 -			 kvm->arch.model.fac_list[0],
 -			 kvm->arch.model.fac_list[1],
 -			 kvm->arch.model.fac_list[2]);
 -	} else
 -		ret = -EFAULT;
 -	kfree(proc);
 -out:
 -	mutex_unlock(&kvm->lock);
 -	return ret;
 -}
 -
 -static int kvm_s390_set_processor_feat(struct kvm *kvm,
 -				       struct kvm_device_attr *attr)
 -{
 -	struct kvm_s390_vm_cpu_feat data;
 -
 -	if (copy_from_user(&data, (void __user *)attr->addr, sizeof(data)))
 -		return -EFAULT;
 -	if (!bitmap_subset((unsigned long *) data.feat,
 -			   kvm_s390_available_cpu_feat,
 -			   KVM_S390_VM_CPU_FEAT_NR_BITS))
 -		return -EINVAL;
 -
 -	mutex_lock(&kvm->lock);
 -	if (kvm->created_vcpus) {
 -		mutex_unlock(&kvm->lock);
 -		return -EBUSY;
 -	}
 -	bitmap_copy(kvm->arch.cpu_feat, (unsigned long *) data.feat,
 -		    KVM_S390_VM_CPU_FEAT_NR_BITS);
 -	mutex_unlock(&kvm->lock);
 -	VM_EVENT(kvm, 3, "SET: guest feat: 0x%16.16llx.0x%16.16llx.0x%16.16llx",
 -			 data.feat[0],
 -			 data.feat[1],
 -			 data.feat[2]);
 -	return 0;
 -}
 -
 -static int kvm_s390_set_processor_subfunc(struct kvm *kvm,
 -					  struct kvm_device_attr *attr)
 -{
 -	mutex_lock(&kvm->lock);
 -	if (kvm->created_vcpus) {
 -		mutex_unlock(&kvm->lock);
 -		return -EBUSY;
 -	}
 -
 -	if (copy_from_user(&kvm->arch.model.subfuncs, (void __user *)attr->addr,
 -			   sizeof(struct kvm_s390_vm_cpu_subfunc))) {
 -		mutex_unlock(&kvm->lock);
 -		return -EFAULT;
 -	}
 -	mutex_unlock(&kvm->lock);
 -
 -	VM_EVENT(kvm, 3, "SET: guest PLO    subfunc 0x%16.16lx.%16.16lx.%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.plo)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.plo)[1],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.plo)[2],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.plo)[3]);
 -	VM_EVENT(kvm, 3, "SET: guest PTFF   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.ptff)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.ptff)[1]);
 -	VM_EVENT(kvm, 3, "SET: guest KMAC   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmac)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmac)[1]);
 -	VM_EVENT(kvm, 3, "SET: guest KMC    subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmc)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmc)[1]);
 -	VM_EVENT(kvm, 3, "SET: guest KM     subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.km)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.km)[1]);
 -	VM_EVENT(kvm, 3, "SET: guest KIMD   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kimd)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kimd)[1]);
 -	VM_EVENT(kvm, 3, "SET: guest KLMD   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.klmd)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.klmd)[1]);
 -	VM_EVENT(kvm, 3, "SET: guest PCKMO  subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.pckmo)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.pckmo)[1]);
 -	VM_EVENT(kvm, 3, "SET: guest KMCTR  subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmctr)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmctr)[1]);
 -	VM_EVENT(kvm, 3, "SET: guest KMF    subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmf)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmf)[1]);
 -	VM_EVENT(kvm, 3, "SET: guest KMO    subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmo)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmo)[1]);
 -	VM_EVENT(kvm, 3, "SET: guest PCC    subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.pcc)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.pcc)[1]);
 -	VM_EVENT(kvm, 3, "SET: guest PPNO   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.ppno)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.ppno)[1]);
 -	VM_EVENT(kvm, 3, "SET: guest KMA    subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kma)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kma)[1]);
 -	VM_EVENT(kvm, 3, "SET: guest KDSA   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kdsa)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kdsa)[1]);
 -	VM_EVENT(kvm, 3, "SET: guest SORTL  subfunc 0x%16.16lx.%16.16lx.%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.sortl)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.sortl)[1],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.sortl)[2],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.sortl)[3]);
 -	VM_EVENT(kvm, 3, "SET: guest DFLTCC subfunc 0x%16.16lx.%16.16lx.%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.dfltcc)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.dfltcc)[1],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.dfltcc)[2],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.dfltcc)[3]);
 -
 -	return 0;
 -}
 -
 -static int kvm_s390_set_cpu_model(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	int ret = -ENXIO;
 -
 -	switch (attr->attr) {
 -	case KVM_S390_VM_CPU_PROCESSOR:
 -		ret = kvm_s390_set_processor(kvm, attr);
 -		break;
 -	case KVM_S390_VM_CPU_PROCESSOR_FEAT:
 -		ret = kvm_s390_set_processor_feat(kvm, attr);
 -		break;
 -	case KVM_S390_VM_CPU_PROCESSOR_SUBFUNC:
 -		ret = kvm_s390_set_processor_subfunc(kvm, attr);
 -		break;
 -	}
 -	return ret;
 -}
 -
 -static int kvm_s390_get_processor(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	struct kvm_s390_vm_cpu_processor *proc;
 -	int ret = 0;
 -
 -	proc = kzalloc(sizeof(*proc), GFP_KERNEL);
 -	if (!proc) {
 -		ret = -ENOMEM;
 -		goto out;
 -	}
 -	proc->cpuid = kvm->arch.model.cpuid;
 -	proc->ibc = kvm->arch.model.ibc;
 -	memcpy(&proc->fac_list, kvm->arch.model.fac_list,
 -	       S390_ARCH_FAC_LIST_SIZE_BYTE);
 -	VM_EVENT(kvm, 3, "GET: guest ibc: 0x%4.4x, guest cpuid: 0x%16.16llx",
 -		 kvm->arch.model.ibc,
 -		 kvm->arch.model.cpuid);
 -	VM_EVENT(kvm, 3, "GET: guest faclist: 0x%16.16llx.%16.16llx.%16.16llx",
 -		 kvm->arch.model.fac_list[0],
 -		 kvm->arch.model.fac_list[1],
 -		 kvm->arch.model.fac_list[2]);
 -	if (copy_to_user((void __user *)attr->addr, proc, sizeof(*proc)))
 -		ret = -EFAULT;
 -	kfree(proc);
 -out:
 -	return ret;
 -}
 -
 -static int kvm_s390_get_machine(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	struct kvm_s390_vm_cpu_machine *mach;
 -	int ret = 0;
 -
 -	mach = kzalloc(sizeof(*mach), GFP_KERNEL);
 -	if (!mach) {
 -		ret = -ENOMEM;
 -		goto out;
 -	}
 -	get_cpu_id((struct cpuid *) &mach->cpuid);
 -	mach->ibc = sclp.ibc;
 -	memcpy(&mach->fac_mask, kvm->arch.model.fac_mask,
 -	       S390_ARCH_FAC_LIST_SIZE_BYTE);
 -	memcpy((unsigned long *)&mach->fac_list, S390_lowcore.stfle_fac_list,
 -	       sizeof(S390_lowcore.stfle_fac_list));
 -	VM_EVENT(kvm, 3, "GET: host ibc:  0x%4.4x, host cpuid:  0x%16.16llx",
 -		 kvm->arch.model.ibc,
 -		 kvm->arch.model.cpuid);
 -	VM_EVENT(kvm, 3, "GET: host facmask:  0x%16.16llx.%16.16llx.%16.16llx",
 -		 mach->fac_mask[0],
 -		 mach->fac_mask[1],
 -		 mach->fac_mask[2]);
 -	VM_EVENT(kvm, 3, "GET: host faclist:  0x%16.16llx.%16.16llx.%16.16llx",
 -		 mach->fac_list[0],
 -		 mach->fac_list[1],
 -		 mach->fac_list[2]);
 -	if (copy_to_user((void __user *)attr->addr, mach, sizeof(*mach)))
 -		ret = -EFAULT;
 -	kfree(mach);
 -out:
 -	return ret;
 -}
 -
 -static int kvm_s390_get_processor_feat(struct kvm *kvm,
 -				       struct kvm_device_attr *attr)
 -{
 -	struct kvm_s390_vm_cpu_feat data;
 -
 -	bitmap_copy((unsigned long *) data.feat, kvm->arch.cpu_feat,
 -		    KVM_S390_VM_CPU_FEAT_NR_BITS);
 -	if (copy_to_user((void __user *)attr->addr, &data, sizeof(data)))
 -		return -EFAULT;
 -	VM_EVENT(kvm, 3, "GET: guest feat: 0x%16.16llx.0x%16.16llx.0x%16.16llx",
 -			 data.feat[0],
 -			 data.feat[1],
 -			 data.feat[2]);
 -	return 0;
 -}
 -
 -static int kvm_s390_get_machine_feat(struct kvm *kvm,
 -				     struct kvm_device_attr *attr)
 -{
 -	struct kvm_s390_vm_cpu_feat data;
 -
 -	bitmap_copy((unsigned long *) data.feat,
 -		    kvm_s390_available_cpu_feat,
 -		    KVM_S390_VM_CPU_FEAT_NR_BITS);
 -	if (copy_to_user((void __user *)attr->addr, &data, sizeof(data)))
 -		return -EFAULT;
 -	VM_EVENT(kvm, 3, "GET: host feat:  0x%16.16llx.0x%16.16llx.0x%16.16llx",
 -			 data.feat[0],
 -			 data.feat[1],
 -			 data.feat[2]);
 -	return 0;
 -}
 -
 -static int kvm_s390_get_processor_subfunc(struct kvm *kvm,
 -					  struct kvm_device_attr *attr)
 -{
 -	if (copy_to_user((void __user *)attr->addr, &kvm->arch.model.subfuncs,
 -	    sizeof(struct kvm_s390_vm_cpu_subfunc)))
 -		return -EFAULT;
 -
 -	VM_EVENT(kvm, 3, "GET: guest PLO    subfunc 0x%16.16lx.%16.16lx.%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.plo)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.plo)[1],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.plo)[2],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.plo)[3]);
 -	VM_EVENT(kvm, 3, "GET: guest PTFF   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.ptff)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.ptff)[1]);
 -	VM_EVENT(kvm, 3, "GET: guest KMAC   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmac)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmac)[1]);
 -	VM_EVENT(kvm, 3, "GET: guest KMC    subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmc)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmc)[1]);
 -	VM_EVENT(kvm, 3, "GET: guest KM     subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.km)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.km)[1]);
 -	VM_EVENT(kvm, 3, "GET: guest KIMD   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kimd)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kimd)[1]);
 -	VM_EVENT(kvm, 3, "GET: guest KLMD   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.klmd)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.klmd)[1]);
 -	VM_EVENT(kvm, 3, "GET: guest PCKMO  subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.pckmo)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.pckmo)[1]);
 -	VM_EVENT(kvm, 3, "GET: guest KMCTR  subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmctr)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmctr)[1]);
 -	VM_EVENT(kvm, 3, "GET: guest KMF    subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmf)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmf)[1]);
 -	VM_EVENT(kvm, 3, "GET: guest KMO    subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmo)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kmo)[1]);
 -	VM_EVENT(kvm, 3, "GET: guest PCC    subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.pcc)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.pcc)[1]);
 -	VM_EVENT(kvm, 3, "GET: guest PPNO   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.ppno)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.ppno)[1]);
 -	VM_EVENT(kvm, 3, "GET: guest KMA    subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kma)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kma)[1]);
 -	VM_EVENT(kvm, 3, "GET: guest KDSA   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kdsa)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.kdsa)[1]);
 -	VM_EVENT(kvm, 3, "GET: guest SORTL  subfunc 0x%16.16lx.%16.16lx.%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.sortl)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.sortl)[1],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.sortl)[2],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.sortl)[3]);
 -	VM_EVENT(kvm, 3, "GET: guest DFLTCC subfunc 0x%16.16lx.%16.16lx.%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.dfltcc)[0],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.dfltcc)[1],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.dfltcc)[2],
 -		 ((unsigned long *) &kvm->arch.model.subfuncs.dfltcc)[3]);
 -
 -	return 0;
 -}
 -
 -static int kvm_s390_get_machine_subfunc(struct kvm *kvm,
 -					struct kvm_device_attr *attr)
 -{
 -	if (copy_to_user((void __user *)attr->addr, &kvm_s390_available_subfunc,
 -	    sizeof(struct kvm_s390_vm_cpu_subfunc)))
 -		return -EFAULT;
 -
 -	VM_EVENT(kvm, 3, "GET: host  PLO    subfunc 0x%16.16lx.%16.16lx.%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.plo)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.plo)[1],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.plo)[2],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.plo)[3]);
 -	VM_EVENT(kvm, 3, "GET: host  PTFF   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.ptff)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.ptff)[1]);
 -	VM_EVENT(kvm, 3, "GET: host  KMAC   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.kmac)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.kmac)[1]);
 -	VM_EVENT(kvm, 3, "GET: host  KMC    subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.kmc)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.kmc)[1]);
 -	VM_EVENT(kvm, 3, "GET: host  KM     subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.km)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.km)[1]);
 -	VM_EVENT(kvm, 3, "GET: host  KIMD   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.kimd)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.kimd)[1]);
 -	VM_EVENT(kvm, 3, "GET: host  KLMD   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.klmd)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.klmd)[1]);
 -	VM_EVENT(kvm, 3, "GET: host  PCKMO  subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.pckmo)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.pckmo)[1]);
 -	VM_EVENT(kvm, 3, "GET: host  KMCTR  subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.kmctr)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.kmctr)[1]);
 -	VM_EVENT(kvm, 3, "GET: host  KMF    subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.kmf)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.kmf)[1]);
 -	VM_EVENT(kvm, 3, "GET: host  KMO    subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.kmo)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.kmo)[1]);
 -	VM_EVENT(kvm, 3, "GET: host  PCC    subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.pcc)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.pcc)[1]);
 -	VM_EVENT(kvm, 3, "GET: host  PPNO   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.ppno)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.ppno)[1]);
 -	VM_EVENT(kvm, 3, "GET: host  KMA    subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.kma)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.kma)[1]);
 -	VM_EVENT(kvm, 3, "GET: host  KDSA   subfunc 0x%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.kdsa)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.kdsa)[1]);
 -	VM_EVENT(kvm, 3, "GET: host  SORTL  subfunc 0x%16.16lx.%16.16lx.%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.sortl)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.sortl)[1],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.sortl)[2],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.sortl)[3]);
 -	VM_EVENT(kvm, 3, "GET: host  DFLTCC subfunc 0x%16.16lx.%16.16lx.%16.16lx.%16.16lx",
 -		 ((unsigned long *) &kvm_s390_available_subfunc.dfltcc)[0],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.dfltcc)[1],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.dfltcc)[2],
 -		 ((unsigned long *) &kvm_s390_available_subfunc.dfltcc)[3]);
 -
 -	return 0;
 -}
 -
 -static int kvm_s390_get_cpu_model(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	int ret = -ENXIO;
 -
 -	switch (attr->attr) {
 -	case KVM_S390_VM_CPU_PROCESSOR:
 -		ret = kvm_s390_get_processor(kvm, attr);
 -		break;
 -	case KVM_S390_VM_CPU_MACHINE:
 -		ret = kvm_s390_get_machine(kvm, attr);
 -		break;
 -	case KVM_S390_VM_CPU_PROCESSOR_FEAT:
 -		ret = kvm_s390_get_processor_feat(kvm, attr);
 -		break;
 -	case KVM_S390_VM_CPU_MACHINE_FEAT:
 -		ret = kvm_s390_get_machine_feat(kvm, attr);
 -		break;
 -	case KVM_S390_VM_CPU_PROCESSOR_SUBFUNC:
 -		ret = kvm_s390_get_processor_subfunc(kvm, attr);
 -		break;
 -	case KVM_S390_VM_CPU_MACHINE_SUBFUNC:
 -		ret = kvm_s390_get_machine_subfunc(kvm, attr);
 -		break;
 -	}
 -	return ret;
 -}
 -
 -static int kvm_s390_vm_set_attr(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	int ret;
 -
 -	switch (attr->group) {
 -	case KVM_S390_VM_MEM_CTRL:
 -		ret = kvm_s390_set_mem_control(kvm, attr);
 -		break;
 -	case KVM_S390_VM_TOD:
 -		ret = kvm_s390_set_tod(kvm, attr);
 -		break;
 -	case KVM_S390_VM_CPU_MODEL:
 -		ret = kvm_s390_set_cpu_model(kvm, attr);
 -		break;
 -	case KVM_S390_VM_CRYPTO:
 -		ret = kvm_s390_vm_set_crypto(kvm, attr);
 -		break;
 -	case KVM_S390_VM_MIGRATION:
 -		ret = kvm_s390_vm_set_migration(kvm, attr);
 -		break;
 -	default:
 -		ret = -ENXIO;
 -		break;
 -	}
 -
 -	return ret;
 -}
 -
 -static int kvm_s390_vm_get_attr(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	int ret;
 -
 -	switch (attr->group) {
 -	case KVM_S390_VM_MEM_CTRL:
 -		ret = kvm_s390_get_mem_control(kvm, attr);
 -		break;
 -	case KVM_S390_VM_TOD:
 -		ret = kvm_s390_get_tod(kvm, attr);
 -		break;
 -	case KVM_S390_VM_CPU_MODEL:
 -		ret = kvm_s390_get_cpu_model(kvm, attr);
 -		break;
 -	case KVM_S390_VM_MIGRATION:
 -		ret = kvm_s390_vm_get_migration(kvm, attr);
 -		break;
 -	default:
 -		ret = -ENXIO;
 -		break;
 -	}
 -
 -	return ret;
 -}
 -
 -static int kvm_s390_vm_has_attr(struct kvm *kvm, struct kvm_device_attr *attr)
 -{
 -	int ret;
 -
 -	switch (attr->group) {
 -	case KVM_S390_VM_MEM_CTRL:
 -		switch (attr->attr) {
 -		case KVM_S390_VM_MEM_ENABLE_CMMA:
 -		case KVM_S390_VM_MEM_CLR_CMMA:
 -			ret = sclp.has_cmma ? 0 : -ENXIO;
 -			break;
 -		case KVM_S390_VM_MEM_LIMIT_SIZE:
 -			ret = 0;
 -			break;
 -		default:
 -			ret = -ENXIO;
 -			break;
 -		}
 -		break;
 -	case KVM_S390_VM_TOD:
 -		switch (attr->attr) {
 -		case KVM_S390_VM_TOD_LOW:
 -		case KVM_S390_VM_TOD_HIGH:
 -			ret = 0;
 -			break;
 -		default:
 -			ret = -ENXIO;
 -			break;
 -		}
 -		break;
 -	case KVM_S390_VM_CPU_MODEL:
 -		switch (attr->attr) {
 -		case KVM_S390_VM_CPU_PROCESSOR:
 -		case KVM_S390_VM_CPU_MACHINE:
 -		case KVM_S390_VM_CPU_PROCESSOR_FEAT:
 -		case KVM_S390_VM_CPU_MACHINE_FEAT:
 -		case KVM_S390_VM_CPU_MACHINE_SUBFUNC:
 -		case KVM_S390_VM_CPU_PROCESSOR_SUBFUNC:
 -			ret = 0;
 -			break;
 -		default:
 -			ret = -ENXIO;
 -			break;
 -		}
 -		break;
 -	case KVM_S390_VM_CRYPTO:
 -		switch (attr->attr) {
 -		case KVM_S390_VM_CRYPTO_ENABLE_AES_KW:
 -		case KVM_S390_VM_CRYPTO_ENABLE_DEA_KW:
 -		case KVM_S390_VM_CRYPTO_DISABLE_AES_KW:
 -		case KVM_S390_VM_CRYPTO_DISABLE_DEA_KW:
 -			ret = 0;
 -			break;
 -		case KVM_S390_VM_CRYPTO_ENABLE_APIE:
 -		case KVM_S390_VM_CRYPTO_DISABLE_APIE:
 -			ret = ap_instructions_available() ? 0 : -ENXIO;
 -			break;
 -		default:
 -			ret = -ENXIO;
 -			break;
 -		}
 -		break;
 -	case KVM_S390_VM_MIGRATION:
 -		ret = 0;
 -		break;
 -	default:
 -		ret = -ENXIO;
 -		break;
 -	}
 -
 -	return ret;
 -}
 -
 -static long kvm_s390_get_skeys(struct kvm *kvm, struct kvm_s390_skeys *args)
 -{
 -	uint8_t *keys;
 -	uint64_t hva;
 -	int srcu_idx, i, r = 0;
 -
 -	if (args->flags != 0)
 -		return -EINVAL;
 -
 -	/* Is this guest using storage keys? */
 -	if (!mm_uses_skeys(current->mm))
 -		return KVM_S390_GET_SKEYS_NONE;
 -
 -	/* Enforce sane limit on memory allocation */
 -	if (args->count < 1 || args->count > KVM_S390_SKEYS_MAX)
 -		return -EINVAL;
 -
 -	keys = kvmalloc_array(args->count, sizeof(uint8_t), GFP_KERNEL);
 -	if (!keys)
 -		return -ENOMEM;
 -
 -	down_read(&current->mm->mmap_sem);
 -	srcu_idx = srcu_read_lock(&kvm->srcu);
 -	for (i = 0; i < args->count; i++) {
 -		hva = gfn_to_hva(kvm, args->start_gfn + i);
 -		if (kvm_is_error_hva(hva)) {
 -			r = -EFAULT;
 -			break;
 -		}
 -
 -		r = get_guest_storage_key(current->mm, hva, &keys[i]);
 -		if (r)
 -			break;
 -	}
 -	srcu_read_unlock(&kvm->srcu, srcu_idx);
 -	up_read(&current->mm->mmap_sem);
 -
 -	if (!r) {
 -		r = copy_to_user((uint8_t __user *)args->skeydata_addr, keys,
 -				 sizeof(uint8_t) * args->count);
 -		if (r)
 -			r = -EFAULT;
 -	}
 -
 -	kvfree(keys);
 -	return r;
 -}
 -
 -static long kvm_s390_set_skeys(struct kvm *kvm, struct kvm_s390_skeys *args)
 -{
 -	uint8_t *keys;
 -	uint64_t hva;
 -	int srcu_idx, i, r = 0;
 -	bool unlocked;
 -
 -	if (args->flags != 0)
 -		return -EINVAL;
 -
 -	/* Enforce sane limit on memory allocation */
 -	if (args->count < 1 || args->count > KVM_S390_SKEYS_MAX)
 -		return -EINVAL;
 -
 -	keys = kvmalloc_array(args->count, sizeof(uint8_t), GFP_KERNEL);
 -	if (!keys)
 -		return -ENOMEM;
 -
 -	r = copy_from_user(keys, (uint8_t __user *)args->skeydata_addr,
 -			   sizeof(uint8_t) * args->count);
 -	if (r) {
 -		r = -EFAULT;
 -		goto out;
 -	}
 -
 -	/* Enable storage key handling for the guest */
 -	r = s390_enable_skey();
 -	if (r)
 -		goto out;
 -
 -	i = 0;
 -	down_read(&current->mm->mmap_sem);
 -	srcu_idx = srcu_read_lock(&kvm->srcu);
 -        while (i < args->count) {
 -		unlocked = false;
 -		hva = gfn_to_hva(kvm, args->start_gfn + i);
 -		if (kvm_is_error_hva(hva)) {
 -			r = -EFAULT;
 -			break;
 -		}
 -
 -		/* Lowest order bit is reserved */
 -		if (keys[i] & 0x01) {
 -			r = -EINVAL;
 -			break;
 -		}
 -
 -		r = set_guest_storage_key(current->mm, hva, keys[i], 0);
 -		if (r) {
 -			r = fixup_user_fault(current, current->mm, hva,
 -					     FAULT_FLAG_WRITE, &unlocked);
 -			if (r)
 -				break;
 -		}
 -		if (!r)
 -			i++;
 -	}
 -	srcu_read_unlock(&kvm->srcu, srcu_idx);
 -	up_read(&current->mm->mmap_sem);
 -out:
 -	kvfree(keys);
 -	return r;
 -}
 -
 -/*
 - * Base address and length must be sent at the start of each block, therefore
 - * it's cheaper to send some clean data, as long as it's less than the size of
 - * two longs.
 - */
 -#define KVM_S390_MAX_BIT_DISTANCE (2 * sizeof(void *))
 -/* for consistency */
 -#define KVM_S390_CMMA_SIZE_MAX ((u32)KVM_S390_SKEYS_MAX)
 -
 -/*
 - * Similar to gfn_to_memslot, but returns the index of a memslot also when the
 - * address falls in a hole. In that case the index of one of the memslots
 - * bordering the hole is returned.
 - */
 -static int gfn_to_memslot_approx(struct kvm_memslots *slots, gfn_t gfn)
 -{
 -	int start = 0, end = slots->used_slots;
 -	int slot = atomic_read(&slots->lru_slot);
 -	struct kvm_memory_slot *memslots = slots->memslots;
 -
 -	if (gfn >= memslots[slot].base_gfn &&
 -	    gfn < memslots[slot].base_gfn + memslots[slot].npages)
 -		return slot;
 -
 -	while (start < end) {
 -		slot = start + (end - start) / 2;
 -
 -		if (gfn >= memslots[slot].base_gfn)
 -			end = slot;
 -		else
 -			start = slot + 1;
 -	}
 -
 -	if (gfn >= memslots[start].base_gfn &&
 -	    gfn < memslots[start].base_gfn + memslots[start].npages) {
 -		atomic_set(&slots->lru_slot, start);
 -	}
 -
 -	return start;
 -}
 -
 -static int kvm_s390_peek_cmma(struct kvm *kvm, struct kvm_s390_cmma_log *args,
 -			      u8 *res, unsigned long bufsize)
 -{
 -	unsigned long pgstev, hva, cur_gfn = args->start_gfn;
 -
 -	args->count = 0;
 -	while (args->count < bufsize) {
 -		hva = gfn_to_hva(kvm, cur_gfn);
 -		/*
 -		 * We return an error if the first value was invalid, but we
 -		 * return successfully if at least one value was copied.
 -		 */
 -		if (kvm_is_error_hva(hva))
 -			return args->count ? 0 : -EFAULT;
 -		if (get_pgste(kvm->mm, hva, &pgstev) < 0)
 -			pgstev = 0;
 -		res[args->count++] = (pgstev >> 24) & 0x43;
 -		cur_gfn++;
 -	}
 -
 -	return 0;
 -}
 -
 -static unsigned long kvm_s390_next_dirty_cmma(struct kvm_memslots *slots,
 -					      unsigned long cur_gfn)
 -{
 -	int slotidx = gfn_to_memslot_approx(slots, cur_gfn);
 -	struct kvm_memory_slot *ms = slots->memslots + slotidx;
 -	unsigned long ofs = cur_gfn - ms->base_gfn;
 -
 -	if (ms->base_gfn + ms->npages <= cur_gfn) {
 -		slotidx--;
 -		/* If we are above the highest slot, wrap around */
 -		if (slotidx < 0)
 -			slotidx = slots->used_slots - 1;
 -
 -		ms = slots->memslots + slotidx;
 -		ofs = 0;
 -	}
 -	ofs = find_next_bit(kvm_second_dirty_bitmap(ms), ms->npages, ofs);
 -	while ((slotidx > 0) && (ofs >= ms->npages)) {
 -		slotidx--;
 -		ms = slots->memslots + slotidx;
 -		ofs = find_next_bit(kvm_second_dirty_bitmap(ms), ms->npages, 0);
 -	}
 -	return ms->base_gfn + ofs;
 -}
 -
 -static int kvm_s390_get_cmma(struct kvm *kvm, struct kvm_s390_cmma_log *args,
 -			     u8 *res, unsigned long bufsize)
 -{
 -	unsigned long mem_end, cur_gfn, next_gfn, hva, pgstev;
 -	struct kvm_memslots *slots = kvm_memslots(kvm);
 -	struct kvm_memory_slot *ms;
 -
 -	cur_gfn = kvm_s390_next_dirty_cmma(slots, args->start_gfn);
 -	ms = gfn_to_memslot(kvm, cur_gfn);
 -	args->count = 0;
 -	args->start_gfn = cur_gfn;
 -	if (!ms)
 -		return 0;
 -	next_gfn = kvm_s390_next_dirty_cmma(slots, cur_gfn + 1);
 -	mem_end = slots->memslots[0].base_gfn + slots->memslots[0].npages;
 -
 -	while (args->count < bufsize) {
 -		hva = gfn_to_hva(kvm, cur_gfn);
 -		if (kvm_is_error_hva(hva))
 -			return 0;
 -		/* Decrement only if we actually flipped the bit to 0 */
 -		if (test_and_clear_bit(cur_gfn - ms->base_gfn, kvm_second_dirty_bitmap(ms)))
 -			atomic64_dec(&kvm->arch.cmma_dirty_pages);
 -		if (get_pgste(kvm->mm, hva, &pgstev) < 0)
 -			pgstev = 0;
 -		/* Save the value */
 -		res[args->count++] = (pgstev >> 24) & 0x43;
 -		/* If the next bit is too far away, stop. */
 -		if (next_gfn > cur_gfn + KVM_S390_MAX_BIT_DISTANCE)
 -			return 0;
 -		/* If we reached the previous "next", find the next one */
 -		if (cur_gfn == next_gfn)
 -			next_gfn = kvm_s390_next_dirty_cmma(slots, cur_gfn + 1);
 -		/* Reached the end of memory or of the buffer, stop */
 -		if ((next_gfn >= mem_end) ||
 -		    (next_gfn - args->start_gfn >= bufsize))
 -			return 0;
 -		cur_gfn++;
 -		/* Reached the end of the current memslot, take the next one. */
 -		if (cur_gfn - ms->base_gfn >= ms->npages) {
 -			ms = gfn_to_memslot(kvm, cur_gfn);
 -			if (!ms)
 -				return 0;
 -		}
 -	}
 -	return 0;
 -}
 -
 -/*
 - * This function searches for the next page with dirty CMMA attributes, and
 - * saves the attributes in the buffer up to either the end of the buffer or
 - * until a block of at least KVM_S390_MAX_BIT_DISTANCE clean bits is found;
 - * no trailing clean bytes are saved.
 - * In case no dirty bits were found, or if CMMA was not enabled or used, the
 - * output buffer will indicate 0 as length.
 - */
 -static int kvm_s390_get_cmma_bits(struct kvm *kvm,
 -				  struct kvm_s390_cmma_log *args)
 -{
 -	unsigned long bufsize;
 -	int srcu_idx, peek, ret;
 -	u8 *values;
 -
 -	if (!kvm->arch.use_cmma)
 -		return -ENXIO;
 -	/* Invalid/unsupported flags were specified */
 -	if (args->flags & ~KVM_S390_CMMA_PEEK)
 -		return -EINVAL;
 -	/* Migration mode query, and we are not doing a migration */
 -	peek = !!(args->flags & KVM_S390_CMMA_PEEK);
 -	if (!peek && !kvm->arch.migration_mode)
 -		return -EINVAL;
 -	/* CMMA is disabled or was not used, or the buffer has length zero */
 -	bufsize = min(args->count, KVM_S390_CMMA_SIZE_MAX);
 -	if (!bufsize || !kvm->mm->context.uses_cmm) {
 -		memset(args, 0, sizeof(*args));
 -		return 0;
 -	}
 -	/* We are not peeking, and there are no dirty pages */
 -	if (!peek && !atomic64_read(&kvm->arch.cmma_dirty_pages)) {
 -		memset(args, 0, sizeof(*args));
 -		return 0;
 -	}
 -
 -	values = vmalloc(bufsize);
 -	if (!values)
 -		return -ENOMEM;
 -
 -	down_read(&kvm->mm->mmap_sem);
 -	srcu_idx = srcu_read_lock(&kvm->srcu);
 -	if (peek)
 -		ret = kvm_s390_peek_cmma(kvm, args, values, bufsize);
 -	else
 -		ret = kvm_s390_get_cmma(kvm, args, values, bufsize);
 -	srcu_read_unlock(&kvm->srcu, srcu_idx);
 -	up_read(&kvm->mm->mmap_sem);
 -
 -	if (kvm->arch.migration_mode)
 -		args->remaining = atomic64_read(&kvm->arch.cmma_dirty_pages);
 -	else
 -		args->remaining = 0;
 -
 -	if (copy_to_user((void __user *)args->values, values, args->count))
 -		ret = -EFAULT;
 -
 -	vfree(values);
 -	return ret;
 -}
 -
 -/*
 - * This function sets the CMMA attributes for the given pages. If the input
 - * buffer has zero length, no action is taken, otherwise the attributes are
 - * set and the mm->context.uses_cmm flag is set.
 - */
 -static int kvm_s390_set_cmma_bits(struct kvm *kvm,
 -				  const struct kvm_s390_cmma_log *args)
 -{
 -	unsigned long hva, mask, pgstev, i;
 -	uint8_t *bits;
 -	int srcu_idx, r = 0;
 -
 -	mask = args->mask;
 -
 -	if (!kvm->arch.use_cmma)
 -		return -ENXIO;
 -	/* invalid/unsupported flags */
 -	if (args->flags != 0)
 -		return -EINVAL;
 -	/* Enforce sane limit on memory allocation */
 -	if (args->count > KVM_S390_CMMA_SIZE_MAX)
 -		return -EINVAL;
 -	/* Nothing to do */
 -	if (args->count == 0)
 -		return 0;
 -
 -	bits = vmalloc(array_size(sizeof(*bits), args->count));
 -	if (!bits)
 -		return -ENOMEM;
 -
 -	r = copy_from_user(bits, (void __user *)args->values, args->count);
 -	if (r) {
 -		r = -EFAULT;
 -		goto out;
 -	}
 -
 -	down_read(&kvm->mm->mmap_sem);
 -	srcu_idx = srcu_read_lock(&kvm->srcu);
 -	for (i = 0; i < args->count; i++) {
 -		hva = gfn_to_hva(kvm, args->start_gfn + i);
 -		if (kvm_is_error_hva(hva)) {
 -			r = -EFAULT;
 -			break;
 -		}
 -
 -		pgstev = bits[i];
 -		pgstev = pgstev << 24;
 -		mask &= _PGSTE_GPS_USAGE_MASK | _PGSTE_GPS_NODAT;
 -		set_pgste_bits(kvm->mm, hva, mask, pgstev);
 -	}
 -	srcu_read_unlock(&kvm->srcu, srcu_idx);
 -	up_read(&kvm->mm->mmap_sem);
 -
 -	if (!kvm->mm->context.uses_cmm) {
 -		down_write(&kvm->mm->mmap_sem);
 -		kvm->mm->context.uses_cmm = 1;
 -		up_write(&kvm->mm->mmap_sem);
 -	}
 -out:
 -	vfree(bits);
 -	return r;
 -}
 -
 -long kvm_arch_vm_ioctl(struct file *filp,
 -		       unsigned int ioctl, unsigned long arg)
 -{
 -	struct kvm *kvm = filp->private_data;
 -	void __user *argp = (void __user *)arg;
 -	struct kvm_device_attr attr;
 -	int r;
 -
 -	switch (ioctl) {
 -	case KVM_S390_INTERRUPT: {
 -		struct kvm_s390_interrupt s390int;
 -
 -		r = -EFAULT;
 -		if (copy_from_user(&s390int, argp, sizeof(s390int)))
 -			break;
 -		r = kvm_s390_inject_vm(kvm, &s390int);
 -		break;
 -	}
 -	case KVM_CREATE_IRQCHIP: {
 -		struct kvm_irq_routing_entry routing;
 -
 -		r = -EINVAL;
 -		if (kvm->arch.use_irqchip) {
 -			/* Set up dummy routing. */
 -			memset(&routing, 0, sizeof(routing));
 -			r = kvm_set_irq_routing(kvm, &routing, 0, 0);
 -		}
 -		break;
 -	}
 -	case KVM_SET_DEVICE_ATTR: {
 -		r = -EFAULT;
 -		if (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))
 -			break;
 -		r = kvm_s390_vm_set_attr(kvm, &attr);
 -		break;
 -	}
 -	case KVM_GET_DEVICE_ATTR: {
 -		r = -EFAULT;
 -		if (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))
 -			break;
 -		r = kvm_s390_vm_get_attr(kvm, &attr);
 -		break;
 -	}
 -	case KVM_HAS_DEVICE_ATTR: {
 -		r = -EFAULT;
 -		if (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))
 -			break;
 -		r = kvm_s390_vm_has_attr(kvm, &attr);
 -		break;
 -	}
 -	case KVM_S390_GET_SKEYS: {
 -		struct kvm_s390_skeys args;
 -
 -		r = -EFAULT;
 -		if (copy_from_user(&args, argp,
 -				   sizeof(struct kvm_s390_skeys)))
 -			break;
 -		r = kvm_s390_get_skeys(kvm, &args);
 -		break;
 -	}
 -	case KVM_S390_SET_SKEYS: {
 -		struct kvm_s390_skeys args;
 -
 -		r = -EFAULT;
 -		if (copy_from_user(&args, argp,
 -				   sizeof(struct kvm_s390_skeys)))
 -			break;
 -		r = kvm_s390_set_skeys(kvm, &args);
 -		break;
 -	}
 -	case KVM_S390_GET_CMMA_BITS: {
 -		struct kvm_s390_cmma_log args;
 -
 -		r = -EFAULT;
 -		if (copy_from_user(&args, argp, sizeof(args)))
 -			break;
 -		mutex_lock(&kvm->slots_lock);
 -		r = kvm_s390_get_cmma_bits(kvm, &args);
 -		mutex_unlock(&kvm->slots_lock);
 -		if (!r) {
 -			r = copy_to_user(argp, &args, sizeof(args));
 -			if (r)
 -				r = -EFAULT;
 -		}
 -		break;
 -	}
 -	case KVM_S390_SET_CMMA_BITS: {
 -		struct kvm_s390_cmma_log args;
 -
 -		r = -EFAULT;
 -		if (copy_from_user(&args, argp, sizeof(args)))
 -			break;
 -		mutex_lock(&kvm->slots_lock);
 -		r = kvm_s390_set_cmma_bits(kvm, &args);
 -		mutex_unlock(&kvm->slots_lock);
 -		break;
 -	}
 -	default:
 -		r = -ENOTTY;
 -	}
 -
 -	return r;
 -}
 -
 -static int kvm_s390_apxa_installed(void)
 -{
 -	struct ap_config_info info;
 -
 -	if (ap_instructions_available()) {
 -		if (ap_qci(&info) == 0)
 -			return info.apxa;
 -	}
 -
 -	return 0;
 -}
 -
 -/*
 - * The format of the crypto control block (CRYCB) is specified in the 3 low
 - * order bits of the CRYCB designation (CRYCBD) field as follows:
 - * Format 0: Neither the message security assist extension 3 (MSAX3) nor the
 - *	     AP extended addressing (APXA) facility are installed.
 - * Format 1: The APXA facility is not installed but the MSAX3 facility is.
 - * Format 2: Both the APXA and MSAX3 facilities are installed
 - */
 -static void kvm_s390_set_crycb_format(struct kvm *kvm)
 -{
 -	kvm->arch.crypto.crycbd = (__u32)(unsigned long) kvm->arch.crypto.crycb;
 -
 -	/* Clear the CRYCB format bits - i.e., set format 0 by default */
 -	kvm->arch.crypto.crycbd &= ~(CRYCB_FORMAT_MASK);
 -
 -	/* Check whether MSAX3 is installed */
 -	if (!test_kvm_facility(kvm, 76))
 -		return;
 -
 -	if (kvm_s390_apxa_installed())
 -		kvm->arch.crypto.crycbd |= CRYCB_FORMAT2;
 -	else
 -		kvm->arch.crypto.crycbd |= CRYCB_FORMAT1;
 -}
 -
 -void kvm_arch_crypto_set_masks(struct kvm *kvm, unsigned long *apm,
 -			       unsigned long *aqm, unsigned long *adm)
 -{
 -	struct kvm_s390_crypto_cb *crycb = kvm->arch.crypto.crycb;
 -
 -	mutex_lock(&kvm->lock);
 -	kvm_s390_vcpu_block_all(kvm);
 -
 -	switch (kvm->arch.crypto.crycbd & CRYCB_FORMAT_MASK) {
 -	case CRYCB_FORMAT2: /* APCB1 use 256 bits */
 -		memcpy(crycb->apcb1.apm, apm, 32);
 -		VM_EVENT(kvm, 3, "SET CRYCB: apm %016lx %016lx %016lx %016lx",
 -			 apm[0], apm[1], apm[2], apm[3]);
 -		memcpy(crycb->apcb1.aqm, aqm, 32);
 -		VM_EVENT(kvm, 3, "SET CRYCB: aqm %016lx %016lx %016lx %016lx",
 -			 aqm[0], aqm[1], aqm[2], aqm[3]);
 -		memcpy(crycb->apcb1.adm, adm, 32);
 -		VM_EVENT(kvm, 3, "SET CRYCB: adm %016lx %016lx %016lx %016lx",
 -			 adm[0], adm[1], adm[2], adm[3]);
 -		break;
 -	case CRYCB_FORMAT1:
 -	case CRYCB_FORMAT0: /* Fall through both use APCB0 */
 -		memcpy(crycb->apcb0.apm, apm, 8);
 -		memcpy(crycb->apcb0.aqm, aqm, 2);
 -		memcpy(crycb->apcb0.adm, adm, 2);
 -		VM_EVENT(kvm, 3, "SET CRYCB: apm %016lx aqm %04x adm %04x",
 -			 apm[0], *((unsigned short *)aqm),
 -			 *((unsigned short *)adm));
 -		break;
 -	default:	/* Can not happen */
 -		break;
 -	}
 -
 -	/* recreate the shadow crycb for each vcpu */
 -	kvm_s390_sync_request_broadcast(kvm, KVM_REQ_VSIE_RESTART);
 -	kvm_s390_vcpu_unblock_all(kvm);
 -	mutex_unlock(&kvm->lock);
 -}
 -EXPORT_SYMBOL_GPL(kvm_arch_crypto_set_masks);
 -
 -void kvm_arch_crypto_clear_masks(struct kvm *kvm)
 -{
 -	mutex_lock(&kvm->lock);
 -	kvm_s390_vcpu_block_all(kvm);
 -
 -	memset(&kvm->arch.crypto.crycb->apcb0, 0,
 -	       sizeof(kvm->arch.crypto.crycb->apcb0));
 -	memset(&kvm->arch.crypto.crycb->apcb1, 0,
 -	       sizeof(kvm->arch.crypto.crycb->apcb1));
 -
 -	VM_EVENT(kvm, 3, "%s", "CLR CRYCB:");
 -	/* recreate the shadow crycb for each vcpu */
 -	kvm_s390_sync_request_broadcast(kvm, KVM_REQ_VSIE_RESTART);
 -	kvm_s390_vcpu_unblock_all(kvm);
 -	mutex_unlock(&kvm->lock);
 -}
 -EXPORT_SYMBOL_GPL(kvm_arch_crypto_clear_masks);
 -
 -static u64 kvm_s390_get_initial_cpuid(void)
 -{
 -	struct cpuid cpuid;
 -
 -	get_cpu_id(&cpuid);
 -	cpuid.version = 0xff;
 -	return *((u64 *) &cpuid);
 -}
 -
 -static void kvm_s390_crypto_init(struct kvm *kvm)
 -{
 -	kvm->arch.crypto.crycb = &kvm->arch.sie_page2->crycb;
 -	kvm_s390_set_crycb_format(kvm);
 -
 -	if (!test_kvm_facility(kvm, 76))
 -		return;
 -
 -	/* Enable AES/DEA protected key functions by default */
 -	kvm->arch.crypto.aes_kw = 1;
 -	kvm->arch.crypto.dea_kw = 1;
 -	get_random_bytes(kvm->arch.crypto.crycb->aes_wrapping_key_mask,
 -			 sizeof(kvm->arch.crypto.crycb->aes_wrapping_key_mask));
 -	get_random_bytes(kvm->arch.crypto.crycb->dea_wrapping_key_mask,
 -			 sizeof(kvm->arch.crypto.crycb->dea_wrapping_key_mask));
 -}
 -
 -static void sca_dispose(struct kvm *kvm)
 -{
 -	if (kvm->arch.use_esca)
 -		free_pages_exact(kvm->arch.sca, sizeof(struct esca_block));
 -	else
 -		free_page((unsigned long)(kvm->arch.sca));
 -	kvm->arch.sca = NULL;
 -}
 -
 -int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
 -{
 -	gfp_t alloc_flags = GFP_KERNEL;
 -	int i, rc;
 -	char debug_name[16];
 -	static unsigned long sca_offset;
 -
 -	rc = -EINVAL;
 -#ifdef CONFIG_KVM_S390_UCONTROL
 -	if (type & ~KVM_VM_S390_UCONTROL)
 -		goto out_err;
 -	if ((type & KVM_VM_S390_UCONTROL) && (!capable(CAP_SYS_ADMIN)))
 -		goto out_err;
 -#else
 -	if (type)
 -		goto out_err;
 -#endif
 -
 -	rc = s390_enable_sie();
 -	if (rc)
 -		goto out_err;
 -
 -	rc = -ENOMEM;
 -
 -	if (!sclp.has_64bscao)
 -		alloc_flags |= GFP_DMA;
 -	rwlock_init(&kvm->arch.sca_lock);
 -	/* start with basic SCA */
 -	kvm->arch.sca = (struct bsca_block *) get_zeroed_page(alloc_flags);
 -	if (!kvm->arch.sca)
 -		goto out_err;
 -	mutex_lock(&kvm_lock);
 -	sca_offset += 16;
 -	if (sca_offset + sizeof(struct bsca_block) > PAGE_SIZE)
 -		sca_offset = 0;
 -	kvm->arch.sca = (struct bsca_block *)
 -			((char *) kvm->arch.sca + sca_offset);
 -	mutex_unlock(&kvm_lock);
 -
 -	sprintf(debug_name, "kvm-%u", current->pid);
 -
 -	kvm->arch.dbf = debug_register(debug_name, 32, 1, 7 * sizeof(long));
 -	if (!kvm->arch.dbf)
 -		goto out_err;
 -
 -	BUILD_BUG_ON(sizeof(struct sie_page2) != 4096);
 -	kvm->arch.sie_page2 =
 -	     (struct sie_page2 *) get_zeroed_page(GFP_KERNEL | GFP_DMA);
 -	if (!kvm->arch.sie_page2)
 -		goto out_err;
 -
 -	kvm->arch.sie_page2->kvm = kvm;
 -	kvm->arch.model.fac_list = kvm->arch.sie_page2->fac_list;
 -
 -	for (i = 0; i < kvm_s390_fac_size(); i++) {
 -		kvm->arch.model.fac_mask[i] = S390_lowcore.stfle_fac_list[i] &
 -					      (kvm_s390_fac_base[i] |
 -					       kvm_s390_fac_ext[i]);
 -		kvm->arch.model.fac_list[i] = S390_lowcore.stfle_fac_list[i] &
 -					      kvm_s390_fac_base[i];
 -	}
 -	kvm->arch.model.subfuncs = kvm_s390_available_subfunc;
 -
 -	/* we are always in czam mode - even on pre z14 machines */
 -	set_kvm_facility(kvm->arch.model.fac_mask, 138);
 -	set_kvm_facility(kvm->arch.model.fac_list, 138);
 -	/* we emulate STHYI in kvm */
 -	set_kvm_facility(kvm->arch.model.fac_mask, 74);
 -	set_kvm_facility(kvm->arch.model.fac_list, 74);
 -	if (MACHINE_HAS_TLB_GUEST) {
 -		set_kvm_facility(kvm->arch.model.fac_mask, 147);
 -		set_kvm_facility(kvm->arch.model.fac_list, 147);
 -	}
 -
 -	kvm->arch.model.cpuid = kvm_s390_get_initial_cpuid();
 -	kvm->arch.model.ibc = sclp.ibc & 0x0fff;
 -
 -	kvm_s390_crypto_init(kvm);
 -
 -	mutex_init(&kvm->arch.float_int.ais_lock);
 -	spin_lock_init(&kvm->arch.float_int.lock);
 -	for (i = 0; i < FIRQ_LIST_COUNT; i++)
 -		INIT_LIST_HEAD(&kvm->arch.float_int.lists[i]);
 -	init_waitqueue_head(&kvm->arch.ipte_wq);
 -	mutex_init(&kvm->arch.ipte_mutex);
 -
 -	debug_register_view(kvm->arch.dbf, &debug_sprintf_view);
 -	VM_EVENT(kvm, 3, "vm created with type %lu", type);
 -
 -	if (type & KVM_VM_S390_UCONTROL) {
 -		kvm->arch.gmap = NULL;
 -		kvm->arch.mem_limit = KVM_S390_NO_MEM_LIMIT;
 -	} else {
 -		if (sclp.hamax == U64_MAX)
 -			kvm->arch.mem_limit = TASK_SIZE_MAX;
 -		else
 -			kvm->arch.mem_limit = min_t(unsigned long, TASK_SIZE_MAX,
 -						    sclp.hamax + 1);
 -		kvm->arch.gmap = gmap_create(current->mm, kvm->arch.mem_limit - 1);
 -		if (!kvm->arch.gmap)
 -			goto out_err;
 -		kvm->arch.gmap->private = kvm;
 -		kvm->arch.gmap->pfault_enabled = 0;
 -	}
 -
 -	kvm->arch.use_pfmfi = sclp.has_pfmfi;
 -	kvm->arch.use_skf = sclp.has_skey;
 -	spin_lock_init(&kvm->arch.start_stop_lock);
 -	kvm_s390_vsie_init(kvm);
 -	kvm_s390_gisa_init(kvm);
 -	KVM_EVENT(3, "vm 0x%pK created by pid %u", kvm, current->pid);
 -
 -	return 0;
 -out_err:
 -	free_page((unsigned long)kvm->arch.sie_page2);
 -	debug_unregister(kvm->arch.dbf);
 -	sca_dispose(kvm);
 -	KVM_EVENT(3, "creation of vm failed: %d", rc);
 -	return rc;
 -}
 -
 -bool kvm_arch_has_vcpu_debugfs(void)
 -{
 -	return false;
 -}
 -
 -int kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu)
 +int kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu)
  {
  	return 0;
  }
diff --cc arch/x86/kvm/mmu.c
index 24ebfb6e8f2e,3384c539d150..000000000000
--- a/arch/x86/kvm/mmu.c
+++ b/arch/x86/kvm/mmu.c
@@@ -5751,11 -5954,9 +5751,11 @@@ static int mmu_shrink(struct shrinker *
  {
  	struct kvm *kvm;
  	int nr_to_scan = sc->nr_to_scan;
 -	unsigned long freed = 0;
 +
 +	if (nr_to_scan == 0)
 +		goto out;
  
- 	spin_lock(&kvm_lock);
+ 	mutex_lock(&kvm_lock);
  
  	list_for_each_entry(kvm, &vm_list, vm_list) {
  		int idx;
@@@ -5799,9 -5998,13 +5799,15 @@@ unlock
  		break;
  	}
  
++<<<<<<< HEAD
 +	spin_unlock(&kvm_lock);
++=======
+ 	mutex_unlock(&kvm_lock);
+ 	return freed;
+ }
++>>>>>>> 0d9ce162cf46 (kvm: Convert kvm_lock to a mutex)
  
 -static unsigned long
 -mmu_shrink_count(struct shrinker *shrink, struct shrink_control *sc)
 -{
 +out:
  	return percpu_counter_read_positive(&kvm_total_used_mmu_pages);
  }
  
diff --cc arch/x86/kvm/x86.c
index 69feb8491cac,6200d5a51f13..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -5778,10 -6712,45 +5778,51 @@@ static void tsc_khz_changed(void *data
  	__this_cpu_write(cpu_tsc_khz, khz);
  }
  
++<<<<<<< HEAD
 +static int kvmclock_cpufreq_notifier(struct notifier_block *nb, unsigned long val,
 +				     void *data)
++=======
+ #ifdef CONFIG_X86_64
+ static void kvm_hyperv_tsc_notifier(void)
+ {
+ 	struct kvm *kvm;
+ 	struct kvm_vcpu *vcpu;
+ 	int cpu;
+ 
+ 	mutex_lock(&kvm_lock);
+ 	list_for_each_entry(kvm, &vm_list, vm_list)
+ 		kvm_make_mclock_inprogress_request(kvm);
+ 
+ 	hyperv_stop_tsc_emulation();
+ 
+ 	/* TSC frequency always matches when on Hyper-V */
+ 	for_each_present_cpu(cpu)
+ 		per_cpu(cpu_tsc_khz, cpu) = tsc_khz;
+ 	kvm_max_guest_tsc_khz = tsc_khz;
+ 
+ 	list_for_each_entry(kvm, &vm_list, vm_list) {
+ 		struct kvm_arch *ka = &kvm->arch;
+ 
+ 		spin_lock(&ka->pvclock_gtod_sync_lock);
+ 
+ 		pvclock_update_vm_gtod_copy(kvm);
+ 
+ 		kvm_for_each_vcpu(cpu, vcpu, kvm)
+ 			kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);
+ 
+ 		kvm_for_each_vcpu(cpu, vcpu, kvm)
+ 			kvm_clear_request(KVM_REQ_MCLOCK_INPROGRESS, vcpu);
+ 
+ 		spin_unlock(&ka->pvclock_gtod_sync_lock);
+ 	}
+ 	mutex_unlock(&kvm_lock);
+ }
+ #endif
+ 
+ static void __kvmclock_cpufreq_notifier(struct cpufreq_freqs *freq, int cpu)
++>>>>>>> 0d9ce162cf46 (kvm: Convert kvm_lock to a mutex)
  {
 +	struct cpufreq_freqs *freq = data;
  	struct kvm *kvm;
  	struct kvm_vcpu *vcpu;
  	int i, send_ipi = 0;
@@@ -5825,20 -6794,15 +5866,20 @@@
  	 *
  	 */
  
 -	smp_call_function_single(cpu, tsc_khz_changed, freq, 1);
 +	if (val == CPUFREQ_PRECHANGE && freq->old > freq->new)
 +		return 0;
 +	if (val == CPUFREQ_POSTCHANGE && freq->old < freq->new)
 +		return 0;
 +
 +	smp_call_function_single(freq->cpu, tsc_khz_changed, freq, 1);
  
- 	spin_lock(&kvm_lock);
+ 	mutex_lock(&kvm_lock);
  	list_for_each_entry(kvm, &vm_list, vm_list) {
  		kvm_for_each_vcpu(i, vcpu, kvm) {
 -			if (vcpu->cpu != cpu)
 +			if (vcpu->cpu != freq->cpu)
  				continue;
  			kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);
- 			if (vcpu->cpu != smp_processor_id())
+ 			if (vcpu->cpu != raw_smp_processor_id())
  				send_ipi = 1;
  		}
  	}
diff --cc virt/kvm/kvm_main.c
index af3df0f2e28f,9613987ef4c8..000000000000
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@@ -631,10 -683,12 +631,10 @@@ static struct kvm *kvm_create_vm(unsign
  	if (r)
  		goto out_err;
  
- 	spin_lock(&kvm_lock);
+ 	mutex_lock(&kvm_lock);
  	list_add(&kvm->vm_list, &vm_list);
- 	spin_unlock(&kvm_lock);
+ 	mutex_unlock(&kvm_lock);
  
 -	preempt_notifier_inc();
 -
  	return kvm;
  
  out_err:
@@@ -674,12 -731,17 +674,12 @@@ static void kvm_destroy_vm(struct kvm *
  	kvm_uevent_notify_change(KVM_EVENT_DESTROY_VM, kvm);
  	kvm_destroy_vm_debugfs(kvm);
  	kvm_arch_sync_events(kvm);
- 	spin_lock(&kvm_lock);
+ 	mutex_lock(&kvm_lock);
  	list_del(&kvm->vm_list);
- 	spin_unlock(&kvm_lock);
+ 	mutex_unlock(&kvm_lock);
  	kvm_free_irq_routing(kvm);
 -	for (i = 0; i < KVM_NR_BUSES; i++) {
 -		struct kvm_io_bus *bus = kvm_get_bus(kvm, i);
 -
 -		if (bus)
 -			kvm_io_bus_destroy(bus);
 -		kvm->buses[i] = NULL;
 -	}
 +	for (i = 0; i < KVM_NR_BUSES; i++)
 +		kvm_io_bus_destroy(kvm->buses[i]);
  	kvm_coalesced_mmio_free(kvm);
  #if defined(CONFIG_MMU_NOTIFIER) && defined(KVM_ARCH_WANT_MMU_NOTIFIER)
  	mmu_notifier_unregister(&kvm->mmu_notifier, kvm->mm);
@@@ -3666,7 -4044,26 +3666,30 @@@ static int vm_stat_get(void *_offset, u
  	return 0;
  }
  
++<<<<<<< HEAD
 +DEFINE_SIMPLE_ATTRIBUTE(vm_stat_fops, vm_stat_get, NULL, "%llu\n");
++=======
+ static int vm_stat_clear(void *_offset, u64 val)
+ {
+ 	unsigned offset = (long)_offset;
+ 	struct kvm *kvm;
+ 	struct kvm_stat_data stat_tmp = {.offset = offset};
+ 
+ 	if (val)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&kvm_lock);
+ 	list_for_each_entry(kvm, &vm_list, vm_list) {
+ 		stat_tmp.kvm = kvm;
+ 		vm_stat_clear_per_vm((void *)&stat_tmp, 0);
+ 	}
+ 	mutex_unlock(&kvm_lock);
+ 
+ 	return 0;
+ }
+ 
+ DEFINE_SIMPLE_ATTRIBUTE(vm_stat_fops, vm_stat_get, vm_stat_clear, "%llu\n");
++>>>>>>> 0d9ce162cf46 (kvm: Convert kvm_lock to a mutex)
  
  static int vcpu_stat_get(void *_offset, u64 *val)
  {
@@@ -3686,7 -4083,27 +3709,31 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +DEFINE_SIMPLE_ATTRIBUTE(vcpu_stat_fops, vcpu_stat_get, NULL, "%llu\n");
++=======
+ static int vcpu_stat_clear(void *_offset, u64 val)
+ {
+ 	unsigned offset = (long)_offset;
+ 	struct kvm *kvm;
+ 	struct kvm_stat_data stat_tmp = {.offset = offset};
+ 
+ 	if (val)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&kvm_lock);
+ 	list_for_each_entry(kvm, &vm_list, vm_list) {
+ 		stat_tmp.kvm = kvm;
+ 		vcpu_stat_clear_per_vm((void *)&stat_tmp, 0);
+ 	}
+ 	mutex_unlock(&kvm_lock);
+ 
+ 	return 0;
+ }
+ 
+ DEFINE_SIMPLE_ATTRIBUTE(vcpu_stat_fops, vcpu_stat_get, vcpu_stat_clear,
+ 			"%llu\n");
++>>>>>>> 0d9ce162cf46 (kvm: Convert kvm_lock to a mutex)
  
  static const struct file_operations *stat_fops[] = {
  	[KVM_STAT_VCPU] = &vcpu_stat_fops,
@@@ -3710,9 -4127,9 +3757,9 @@@ static void kvm_uevent_notify_change(un
  	}
  	created = kvm_createvm_count;
  	active = kvm_active_vms;
- 	spin_unlock(&kvm_lock);
+ 	mutex_unlock(&kvm_lock);
  
 -	env = kzalloc(sizeof(*env), GFP_KERNEL_ACCOUNT);
 +	env = kzalloc(sizeof(*env), GFP_KERNEL);
  	if (!env)
  		return;
  
diff --git a/Documentation/virtual/kvm/locking.txt b/Documentation/virtual/kvm/locking.txt
index fd013bf4115b..3342747cfa71 100644
--- a/Documentation/virtual/kvm/locking.txt
+++ b/Documentation/virtual/kvm/locking.txt
@@ -15,8 +15,6 @@ The acquisition orders for mutexes are as follows:
 
 On x86, vcpu->mutex is taken outside kvm->arch.hyperv.hv_lock.
 
-For spinlocks, kvm_lock is taken outside kvm->mmu_lock.
-
 Everything else is a leaf: no other lock is taken inside the critical
 sections.
 
@@ -146,7 +144,7 @@ See the comments in spte_has_volatile_bits() and mmu_spte_update().
 ------------
 
 Name:		kvm_lock
-Type:		spinlock_t
+Type:		mutex
 Arch:		any
 Protects:	- vm_list
 
* Unmerged path arch/s390/kvm/kvm-s390.c
* Unmerged path arch/x86/kvm/mmu.c
* Unmerged path arch/x86/kvm/x86.c
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index fbc35bbaa5a0..d7264fb06622 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -160,7 +160,7 @@ static inline bool is_error_page(struct page *page)
 
 extern struct kmem_cache *kvm_vcpu_cache;
 
-extern spinlock_t kvm_lock;
+extern struct mutex kvm_lock;
 extern struct list_head vm_list;
 
 struct kvm_io_range {
* Unmerged path virt/kvm/kvm_main.c
