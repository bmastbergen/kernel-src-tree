cifs: fix parsing of symbolic link error response

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Ronnie Sahlberg <lsahlber@redhat.com>
commit df070afd9b8c952eacf49db54cae7138eb9deaeb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/df070afd.failed

RHBZ: 1672539

In smb2_query_symlink(), if we are parsing the error buffer but it is not something
we recognize as a symlink we should return -EINVAL and not -ENOENT.
I.e. the entry does exist, it is just not something we recognize.

Additionally, add check to verify that that the errortag and the reparsetag all make sense.

	Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Acked-by: Paulo Alcantara <palcantara@suse.de>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit df070afd9b8c952eacf49db54cae7138eb9deaeb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/smb2ops.c
diff --cc fs/cifs/smb2ops.c
index 56b3db9e354a,e704e04891fb..000000000000
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@@ -1465,17 -2533,87 +1465,30 @@@ smb2_query_symlink(const unsigned int x
  	oparms.fid = &fid;
  	oparms.reconnect = false;
  
 -	rc = SMB2_open_init(tcon, &rqst[0], &oplock, &oparms, utf16_path);
 -	if (rc)
 -		goto querty_exit;
 -	smb2_set_next_command(tcon, &rqst[0]);
 -
 -
 -	/* IOCTL */
 -	memset(&io_iov, 0, sizeof(io_iov));
 -	rqst[1].rq_iov = io_iov;
 -	rqst[1].rq_nvec = SMB2_IOCTL_IOV_SIZE;
 -
 -	rc = SMB2_ioctl_init(tcon, &rqst[1], fid.persistent_fid,
 -			     fid.volatile_fid, FSCTL_GET_REPARSE_POINT,
 -			     true /* is_fctl */, NULL, 0, CIFSMaxBufSize);
 -	if (rc)
 -		goto querty_exit;
 -
 -	smb2_set_next_command(tcon, &rqst[1]);
 -	smb2_set_related(&rqst[1]);
 -
 -
 -	/* Close */
 -	memset(&close_iov, 0, sizeof(close_iov));
 -	rqst[2].rq_iov = close_iov;
 -	rqst[2].rq_nvec = 1;
 -
 -	rc = SMB2_close_init(tcon, &rqst[2], COMPOUND_FID, COMPOUND_FID);
 -	if (rc)
 -		goto querty_exit;
 -
 -	smb2_set_related(&rqst[2]);
 +	rc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, &err_buf);
  
 -	rc = compound_send_recv(xid, tcon->ses, flags, 3, rqst,
 -				resp_buftype, rsp_iov);
 -
 -	create_rsp = rsp_iov[0].iov_base;
 -	if (create_rsp && create_rsp->sync_hdr.Status)
 -		err_iov = rsp_iov[0];
 -	ioctl_rsp = rsp_iov[1].iov_base;
 -
 -	/*
 -	 * Open was successful and we got an ioctl response.
 -	 */
 -	if ((rc == 0) && (is_reparse_point)) {
 -		/* See MS-FSCC 2.3.23 */
 -
 -		reparse_buf = (struct reparse_data_buffer *)
 -			((char *)ioctl_rsp +
 -			 le32_to_cpu(ioctl_rsp->OutputOffset));
 -		plen = le32_to_cpu(ioctl_rsp->OutputCount);
 -
 -		if (plen + le32_to_cpu(ioctl_rsp->OutputOffset) >
 -		    rsp_iov[1].iov_len) {
 -			cifs_dbg(VFS, "srv returned invalid ioctl len: %d\n",
 -				 plen);
 -			rc = -EIO;
 -			goto querty_exit;
 -		}
 -
 -		rc = parse_reparse_point(reparse_buf, plen, target_path,
 -					 cifs_sb);
 -		goto querty_exit;
 -	}
 -
 -	if (!rc || !err_iov.iov_base) {
 -		rc = -ENOENT;
 -		goto querty_exit;
 +	if (!rc || !err_buf) {
 +		kfree(utf16_path);
 +		return -ENOENT;
  	}
  
 -	err_buf = err_iov.iov_base;
  	if (le32_to_cpu(err_buf->ByteCount) < sizeof(struct smb2_symlink_err_rsp) ||
++<<<<<<< HEAD
 +	    get_rfc1002_length(err_buf) + 4 < SMB2_SYMLINK_STRUCT_SIZE) {
 +		kfree(utf16_path);
 +		return -ENOENT;
++=======
+ 	    err_iov.iov_len < SMB2_SYMLINK_STRUCT_SIZE) {
+ 		rc = -EINVAL;
+ 		goto querty_exit;
+ 	}
+ 
+ 	symlink = (struct smb2_symlink_err_rsp *)err_buf->ErrorData;
+ 	if (le32_to_cpu(symlink->SymLinkErrorTag) != SYMLINK_ERROR_TAG ||
+ 	    le32_to_cpu(symlink->ReparseTag) != IO_REPARSE_TAG_SYMLINK) {
+ 		rc = -EINVAL;
+ 		goto querty_exit;
++>>>>>>> df070afd9b8c (cifs: fix parsing of symbolic link error response)
  	}
  
  	/* open must fail on symlink - reset rc */
@@@ -1486,16 -2623,15 +1498,28 @@@
  	print_len = le16_to_cpu(symlink->PrintNameLength);
  	print_offset = le16_to_cpu(symlink->PrintNameOffset);
  
++<<<<<<< HEAD
 +	if (get_rfc1002_length(err_buf) + 4 <
 +			SMB2_SYMLINK_STRUCT_SIZE + sub_offset + sub_len) {
 +		kfree(utf16_path);
 +		return -ENOENT;
 +	}
 +
 +	if (get_rfc1002_length(err_buf) + 4 <
 +			SMB2_SYMLINK_STRUCT_SIZE + print_offset + print_len) {
 +		kfree(utf16_path);
 +		return -ENOENT;
++=======
+ 	if (err_iov.iov_len < SMB2_SYMLINK_STRUCT_SIZE + sub_offset + sub_len) {
+ 		rc = -EINVAL;
+ 		goto querty_exit;
+ 	}
+ 
+ 	if (err_iov.iov_len <
+ 	    SMB2_SYMLINK_STRUCT_SIZE + print_offset + print_len) {
+ 		rc = -EINVAL;
+ 		goto querty_exit;
++>>>>>>> df070afd9b8c (cifs: fix parsing of symbolic link error response)
  	}
  
  	*target_path = cifs_strndup_from_utf16(
* Unmerged path fs/cifs/smb2ops.c
diff --git a/fs/cifs/smb2pdu.h b/fs/cifs/smb2pdu.h
index 1bcdcab907ca..6b9f6b3f85ec 100644
--- a/fs/cifs/smb2pdu.h
+++ b/fs/cifs/smb2pdu.h
@@ -178,6 +178,8 @@ struct smb2_err_rsp {
 	__u8   ErrorData[1];  /* variable length */
 } __packed;
 
+#define SYMLINK_ERROR_TAG 0x4c4d5953
+
 struct smb2_symlink_err_rsp {
 	__le32 SymLinkLength;
 	__le32 SymLinkErrorTag;
