x86/memory_failure: Introduce {set, clear}_mce_nospec()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit 284ce4011ba60d6c487b668eea729b6294930806
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/284ce401.failed

Currently memory_failure() returns zero if the error was handled. On
that result mce_unmap_kpfn() is called to zap the page out of the kernel
linear mapping to prevent speculative fetches of potentially poisoned
memory. However, in the case of dax mapped devmap pages the page may be
in active permanent use by the device driver, so it cannot be unmapped
from the kernel.

Instead of marking the page not present, marking the page UC should
be sufficient for preventing poison from being pre-fetched into the
cache. Convert mce_unmap_pfn() to set_mce_nospec() remapping the page as
UC, to hide it from speculative accesses.

Given that that persistent memory errors can be cleared by the driver,
include a facility to restore the page to cacheable operation,
clear_mce_nospec().

	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: <linux-edac@vger.kernel.org>
	Cc: <x86@kernel.org>
	Acked-by: Tony Luck <tony.luck@intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Acked-by: Ingo Molnar <mingo@redhat.com>
	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
(cherry picked from commit 284ce4011ba60d6c487b668eea729b6294930806)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/set_memory.h
#	arch/x86/kernel/cpu/mcheck/mce-internal.h
#	arch/x86/kernel/cpu/mcheck/mce.c
#	include/linux/set_memory.h
diff --cc arch/x86/kernel/cpu/mcheck/mce-internal.h
index de20902ecf23,ceb67cd5918f..000000000000
--- a/arch/x86/kernel/cpu/mcheck/mce-internal.h
+++ b/arch/x86/kernel/cpu/mcheck/mce-internal.h
@@@ -96,3 -100,74 +96,77 @@@ static inline bool mce_cmp(struct mce *
  		m1->addr != m2->addr ||
  		m1->misc != m2->misc;
  }
++<<<<<<< HEAD
++=======
+ 
+ extern struct device_attribute dev_attr_trigger;
+ 
+ #ifdef CONFIG_X86_MCELOG_LEGACY
+ void mce_work_trigger(void);
+ void mce_register_injector_chain(struct notifier_block *nb);
+ void mce_unregister_injector_chain(struct notifier_block *nb);
+ #else
+ static inline void mce_work_trigger(void)	{ }
+ static inline void mce_register_injector_chain(struct notifier_block *nb)	{ }
+ static inline void mce_unregister_injector_chain(struct notifier_block *nb)	{ }
+ #endif
+ 
+ struct mca_config {
+ 	bool dont_log_ce;
+ 	bool cmci_disabled;
+ 	bool ignore_ce;
+ 
+ 	__u64 lmce_disabled		: 1,
+ 	      disabled			: 1,
+ 	      ser			: 1,
+ 	      recovery			: 1,
+ 	      bios_cmci_threshold	: 1,
+ 	      __reserved		: 59;
+ 
+ 	u8 banks;
+ 	s8 bootlog;
+ 	int tolerant;
+ 	int monarch_timeout;
+ 	int panic_timeout;
+ 	u32 rip_msr;
+ };
+ 
+ extern struct mca_config mca_cfg;
+ 
+ struct mce_vendor_flags {
+ 	/*
+ 	 * Indicates that overflow conditions are not fatal, when set.
+ 	 */
+ 	__u64 overflow_recov	: 1,
+ 
+ 	/*
+ 	 * (AMD) SUCCOR stands for S/W UnCorrectable error COntainment and
+ 	 * Recovery. It indicates support for data poisoning in HW and deferred
+ 	 * error interrupts.
+ 	 */
+ 	      succor		: 1,
+ 
+ 	/*
+ 	 * (AMD) SMCA: This bit indicates support for Scalable MCA which expands
+ 	 * the register space for each MCA bank and also increases number of
+ 	 * banks. Also, to accommodate the new banks and registers, the MCA
+ 	 * register space is moved to a new MSR range.
+ 	 */
+ 	      smca		: 1,
+ 
+ 	      __reserved_0	: 61;
+ };
+ 
+ extern struct mce_vendor_flags mce_flags;
+ 
+ struct mca_msr_regs {
+ 	u32 (*ctl)	(int bank);
+ 	u32 (*status)	(int bank);
+ 	u32 (*addr)	(int bank);
+ 	u32 (*misc)	(int bank);
+ };
+ 
+ extern struct mca_msr_regs msr_ops;
+ 
+ #endif /* __X86_MCE_INTERNAL_H__ */
++>>>>>>> 284ce4011ba6 (x86/memory_failure: Introduce {set, clear}_mce_nospec())
diff --cc arch/x86/kernel/cpu/mcheck/mce.c
index f77fd7cdb99d,42a061ce1f5d..000000000000
--- a/arch/x86/kernel/cpu/mcheck/mce.c
+++ b/arch/x86/kernel/cpu/mcheck/mce.c
@@@ -41,6 -41,8 +41,11 @@@
  #include <linux/debugfs.h>
  #include <linux/irq_work.h>
  #include <linux/export.h>
++<<<<<<< HEAD
++=======
+ #include <linux/jump_label.h>
+ #include <linux/set_memory.h>
++>>>>>>> 284ce4011ba6 (x86/memory_failure: Introduce {set, clear}_mce_nospec())
  
  #include <asm/intel-family.h>
  #include <asm/processor.h>
@@@ -565,7 -597,8 +570,12 @@@ static int srao_decode_notifier(struct 
  
  	if (mce_usable_address(mce) && (mce->severity == MCE_AO_SEVERITY)) {
  		pfn = mce->addr >> PAGE_SHIFT;
++<<<<<<< HEAD
 +		memory_failure(pfn, MCE_VECTOR, 0);
++=======
+ 		if (!memory_failure(pfn, 0))
+ 			set_mce_nospec(pfn);
++>>>>>>> 284ce4011ba6 (x86/memory_failure: Introduce {set, clear}_mce_nospec())
  	}
  
  	return NOTIFY_OK;
@@@ -1082,9 -1064,11 +1092,14 @@@ static int do_memory_failure(struct mc
  	pr_err("Uncorrected hardware memory error in user-access at %llx", m->addr);
  	if (!(m->mcgstatus & MCG_STATUS_RIPV))
  		flags |= MF_MUST_KILL;
 -	ret = memory_failure(m->addr >> PAGE_SHIFT, flags);
 +	ret = memory_failure(m->addr >> PAGE_SHIFT, MCE_VECTOR, flags);
  	if (ret)
  		pr_err("Memory error not recovered");
++<<<<<<< HEAD
++=======
+ 	else
+ 		set_mce_nospec(m->addr >> PAGE_SHIFT);
++>>>>>>> 284ce4011ba6 (x86/memory_failure: Introduce {set, clear}_mce_nospec())
  	return ret;
  }
  
* Unmerged path arch/x86/include/asm/set_memory.h
* Unmerged path include/linux/set_memory.h
* Unmerged path arch/x86/include/asm/set_memory.h
* Unmerged path arch/x86/kernel/cpu/mcheck/mce-internal.h
* Unmerged path arch/x86/kernel/cpu/mcheck/mce.c
* Unmerged path include/linux/set_memory.h
