memcg: do not account memory used for cache creation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Glauber Costa <glommer@gmail.com>
commit 425c598d583883c33c75780225ba8e0794b43bd9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/425c598d.failed

The memory we used to hold the memcg arrays is currently accounted to
the current memcg.  But that creates a problem, because that memory can
only be freed after the last user is gone.  Our only way to know which
is the last user, is to hook up to freeing time, but the fact that we
still have some in flight kmallocs will prevent freeing to happen.  I
believe therefore to be just easier to account this memory as global
overhead.

	Signed-off-by: Glauber Costa <glommer@openvz.org>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Michal Hocko <mhocko@suse.cz>
	Cc: Kamezawa Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 425c598d583883c33c75780225ba8e0794b43bd9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memcontrol.c
diff --cc mm/memcontrol.c
index e66bef57a827,64f726599ff0..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -5179,9 -5231,11 +5179,17 @@@ static int memcg_propagate_kmem(struct 
  	mem_cgroup_get(memcg);
  	static_key_slow_inc(&memcg_kmem_enabled_key);
  
++<<<<<<< HEAD
 +	mutex_lock(&memcg_limit_mutex);
 +	ret = memcg_update_cache_sizes(memcg);
 +	mutex_unlock(&memcg_limit_mutex);
++=======
+ 	mutex_lock(&set_limit_mutex);
+ 	memcg_stop_kmem_account();
+ 	ret = memcg_update_cache_sizes(memcg);
+ 	memcg_resume_kmem_account();
+ 	mutex_unlock(&set_limit_mutex);
++>>>>>>> 425c598d5838 (memcg: do not account memory used for cache creation)
  out:
  	return ret;
  }
* Unmerged path mm/memcontrol.c
