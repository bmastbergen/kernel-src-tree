slab: __GFP_ZERO is incompatible with a constructor

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Matthew Wilcox <mawilcox@microsoft.com>
commit 128227e7fe4087b60f1bd31f762e61237eb23790
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/128227e7.failed

__GFP_ZERO requests that the object be initialised to all-zeroes, while
the purpose of a constructor is to initialise an object to a particular
pattern.  We cannot do both.  Add a warning to catch any users who
mistakenly pass a __GFP_ZERO flag when allocating a slab with a
constructor.

Link: http://lkml.kernel.org/r/20180412191322.GA21205@bombadil.infradead.org
Fixes: d07dbea46405 ("Slab allocators: support __GFP_ZERO in all allocators")
	Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>
	Acked-by: Johannes Weiner <hannes@cmpxchg.org>
	Acked-by: Vlastimil Babka <vbabka@suse.cz>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 128227e7fe4087b60f1bd31f762e61237eb23790)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/slab.c
#	mm/slob.c
diff --cc mm/slab.c
index 0a4735511ea7,c1fe8099b3cd..000000000000
--- a/mm/slab.c
+++ b/mm/slab.c
@@@ -2762,16 -2658,32 +2762,27 @@@ static int cache_grow(struct kmem_cach
  	 * Be lazy and only check for valid flags here,  keeping it out of the
  	 * critical path in kmem_cache_alloc().
  	 */
++<<<<<<< HEAD
 +	BUG_ON(flags & GFP_SLAB_BUG_MASK);
++=======
+ 	if (unlikely(flags & GFP_SLAB_BUG_MASK)) {
+ 		gfp_t invalid_mask = flags & GFP_SLAB_BUG_MASK;
+ 		flags &= ~GFP_SLAB_BUG_MASK;
+ 		pr_warn("Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\n",
+ 				invalid_mask, &invalid_mask, flags, &flags);
+ 		dump_stack();
+ 	}
+ 	WARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));
++>>>>>>> 128227e7fe40 (slab: __GFP_ZERO is incompatible with a constructor)
  	local_flags = flags & (GFP_CONSTRAINT_MASK|GFP_RECLAIM_MASK);
  
 +	/* Take the node list lock to change the colour_next on this node */
  	check_irq_off();
 -	if (gfpflags_allow_blocking(local_flags))
 -		local_irq_enable();
 -
 -	/*
 -	 * Get mem for the objs.  Attempt to allocate a physical page from
 -	 * 'nodeid'.
 -	 */
 -	page = kmem_getpages(cachep, local_flags, nodeid);
 -	if (!page)
 -		goto failed;
 -
 -	page_node = page_to_nid(page);
 -	n = get_node(cachep, page_node);
 +	n = cachep->node[nodeid];
 +	spin_lock(&n->list_lock);
  
  	/* Get colour for the slab, and cal the next value. */
 +	offset = n->colour_next;
  	n->colour_next++;
  	if (n->colour_next >= cachep->colour)
  		n->colour_next = 0;
diff --cc mm/slob.c
index 5bcd216a1f94,307c2c9feb44..000000000000
--- a/mm/slob.c
+++ b/mm/slob.c
@@@ -554,8 -555,10 +554,14 @@@ void *kmem_cache_alloc_node(struct kmem
  					    flags, node);
  	}
  
++<<<<<<< HEAD
 +	if (c->ctor)
++=======
+ 	if (b && c->ctor) {
+ 		WARN_ON_ONCE(flags & __GFP_ZERO);
++>>>>>>> 128227e7fe40 (slab: __GFP_ZERO is incompatible with a constructor)
  		c->ctor(b);
+ 	}
  
  	kmemleak_alloc_recursive(b, c->size, 1, c->flags, flags);
  	return b;
* Unmerged path mm/slab.c
* Unmerged path mm/slob.c
diff --git a/mm/slub.c b/mm/slub.c
index cfd46f5b97ec..fd842de5a891 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -2293,6 +2293,8 @@ static inline void *new_slab_objects(struct kmem_cache *s, gfp_t flags,
 	struct kmem_cache_cpu *c = *pc;
 	struct page *page;
 
+	WARN_ON_ONCE(s->ctor && (flags & __GFP_ZERO));
+
 	freelist = get_partial(s, flags, node, c);
 
 	if (freelist)
