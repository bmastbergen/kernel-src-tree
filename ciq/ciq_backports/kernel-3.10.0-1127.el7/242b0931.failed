cfg80211: validate SSID/MBSSID element ordering assumption

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Johannes Berg <johannes.berg@intel.com>
commit 242b0931c1918c56cd1dc5563fd250a3c39b996d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/242b0931.failed

The code copying the data assumes that the SSID element is
before the MBSSID element, but since the data is untrusted
from the AP, this cannot be guaranteed.

Validate that this is indeed the case and ignore the MBSSID
otherwise, to avoid having to deal with both cases for the
copy of data that should be between them.

	Cc: stable@vger.kernel.org
Fixes: 0b8fb8235be8 ("cfg80211: Parsing of Multiple BSSID information in scanning")
Link: https://lore.kernel.org/r/1569009255-I1673911f5eae02964e21bdc11b2bf58e5e207e59@changeid
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 242b0931c1918c56cd1dc5563fd250a3c39b996d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/wireless/scan.c
diff --cc net/wireless/scan.c
index 9f0901f3e42b,ff1016607f0b..000000000000
--- a/net/wireless/scan.c
+++ b/net/wireless/scan.c
@@@ -1169,15 -1465,335 +1169,127 @@@ cfg80211_inform_bss_data(struct wiphy *
  	/* cfg80211_bss_update gives us a referenced result */
  	return &res->pub;
  }
 -
 -static const struct element
 -*cfg80211_get_profile_continuation(const u8 *ie, size_t ielen,
 -				   const struct element *mbssid_elem,
 -				   const struct element *sub_elem)
 -{
 -	const u8 *mbssid_end = mbssid_elem->data + mbssid_elem->datalen;
 -	const struct element *next_mbssid;
 -	const struct element *next_sub;
 -
 -	next_mbssid = cfg80211_find_elem(WLAN_EID_MULTIPLE_BSSID,
 -					 mbssid_end,
 -					 ielen - (mbssid_end - ie));
 -
 -	/*
 -	 * If is is not the last subelement in current MBSSID IE or there isn't
 -	 * a next MBSSID IE - profile is complete.
 -	*/
 -	if ((sub_elem->data + sub_elem->datalen < mbssid_end - 1) ||
 -	    !next_mbssid)
 -		return NULL;
 -
 -	/* For any length error, just return NULL */
 -
 -	if (next_mbssid->datalen < 4)
 -		return NULL;
 -
 -	next_sub = (void *)&next_mbssid->data[1];
 -
 -	if (next_mbssid->data + next_mbssid->datalen <
 -	    next_sub->data + next_sub->datalen)
 -		return NULL;
 -
 -	if (next_sub->id != 0 || next_sub->datalen < 2)
 -		return NULL;
 -
 -	/*
 -	 * Check if the first element in the next sub element is a start
 -	 * of a new profile
 -	 */
 -	return next_sub->data[0] == WLAN_EID_NON_TX_BSSID_CAP ?
 -	       NULL : next_mbssid;
 -}
 -
 -size_t cfg80211_merge_profile(const u8 *ie, size_t ielen,
 -			      const struct element *mbssid_elem,
 -			      const struct element *sub_elem,
 -			      u8 *merged_ie, size_t max_copy_len)
 -{
 -	size_t copied_len = sub_elem->datalen;
 -	const struct element *next_mbssid;
 -
 -	if (sub_elem->datalen > max_copy_len)
 -		return 0;
 -
 -	memcpy(merged_ie, sub_elem->data, sub_elem->datalen);
 -
 -	while ((next_mbssid = cfg80211_get_profile_continuation(ie, ielen,
 -								mbssid_elem,
 -								sub_elem))) {
 -		const struct element *next_sub = (void *)&next_mbssid->data[1];
 -
 -		if (copied_len + next_sub->datalen > max_copy_len)
 -			break;
 -		memcpy(merged_ie + copied_len, next_sub->data,
 -		       next_sub->datalen);
 -		copied_len += next_sub->datalen;
 -	}
 -
 -	return copied_len;
 -}
 -EXPORT_SYMBOL(cfg80211_merge_profile);
 -
 -static void cfg80211_parse_mbssid_data(struct wiphy *wiphy,
 -				       struct cfg80211_inform_bss *data,
 -				       enum cfg80211_bss_frame_type ftype,
 -				       const u8 *bssid, u64 tsf,
 -				       u16 beacon_interval, const u8 *ie,
 -				       size_t ielen,
 -				       struct cfg80211_non_tx_bss *non_tx_data,
 -				       gfp_t gfp)
 -{
 -	const u8 *mbssid_index_ie;
 -	const struct element *elem, *sub;
 -	size_t new_ie_len;
 -	u8 new_bssid[ETH_ALEN];
 -	u8 *new_ie, *profile;
 -	u64 seen_indices = 0;
 -	u16 capability;
 -	struct cfg80211_bss *bss;
 -
 -	if (!non_tx_data)
 -		return;
 -	if (!cfg80211_find_ie(WLAN_EID_MULTIPLE_BSSID, ie, ielen))
 -		return;
 -	if (!wiphy->support_mbssid)
 -		return;
 -	if (wiphy->support_only_he_mbssid &&
 -	    !cfg80211_find_ext_ie(WLAN_EID_EXT_HE_CAPABILITY, ie, ielen))
 -		return;
 -
 -	new_ie = kmalloc(IEEE80211_MAX_DATA_LEN, gfp);
 -	if (!new_ie)
 -		return;
 -
 -	profile = kmalloc(ielen, gfp);
 -	if (!profile)
 -		goto out;
 -
 -	for_each_element_id(elem, WLAN_EID_MULTIPLE_BSSID, ie, ielen) {
 -		if (elem->datalen < 4)
 -			continue;
 -		for_each_element(sub, elem->data + 1, elem->datalen - 1) {
 -			u8 profile_len;
 -
 -			if (sub->id != 0 || sub->datalen < 4) {
 -				/* not a valid BSS profile */
 -				continue;
 -			}
 -
 -			if (sub->data[0] != WLAN_EID_NON_TX_BSSID_CAP ||
 -			    sub->data[1] != 2) {
 -				/* The first element within the Nontransmitted
 -				 * BSSID Profile is not the Nontransmitted
 -				 * BSSID Capability element.
 -				 */
 -				continue;
 -			}
 -
 -			memset(profile, 0, ielen);
 -			profile_len = cfg80211_merge_profile(ie, ielen,
 -							     elem,
 -							     sub,
 -							     profile,
 -							     ielen);
 -
 -			/* found a Nontransmitted BSSID Profile */
 -			mbssid_index_ie = cfg80211_find_ie
 -				(WLAN_EID_MULTI_BSSID_IDX,
 -				 profile, profile_len);
 -			if (!mbssid_index_ie || mbssid_index_ie[1] < 1 ||
 -			    mbssid_index_ie[2] == 0 ||
 -			    mbssid_index_ie[2] > 46) {
 -				/* No valid Multiple BSSID-Index element */
 -				continue;
 -			}
 -
 -			if (seen_indices & BIT_ULL(mbssid_index_ie[2]))
 -				/* We don't support legacy split of a profile */
 -				net_dbg_ratelimited("Partial info for BSSID index %d\n",
 -						    mbssid_index_ie[2]);
 -
 -			seen_indices |= BIT_ULL(mbssid_index_ie[2]);
 -
 -			non_tx_data->bssid_index = mbssid_index_ie[2];
 -			non_tx_data->max_bssid_indicator = elem->data[0];
 -
 -			cfg80211_gen_new_bssid(bssid,
 -					       non_tx_data->max_bssid_indicator,
 -					       non_tx_data->bssid_index,
 -					       new_bssid);
 -			memset(new_ie, 0, IEEE80211_MAX_DATA_LEN);
 -			new_ie_len = cfg80211_gen_new_ie(ie, ielen,
 -							 profile,
 -							 profile_len, new_ie,
 -							 gfp);
 -			if (!new_ie_len)
 -				continue;
 -
 -			capability = get_unaligned_le16(profile + 2);
 -			bss = cfg80211_inform_single_bss_data(wiphy, data,
 -							      ftype,
 -							      new_bssid, tsf,
 -							      capability,
 -							      beacon_interval,
 -							      new_ie,
 -							      new_ie_len,
 -							      non_tx_data,
 -							      gfp);
 -			if (!bss)
 -				break;
 -			cfg80211_put_bss(wiphy, bss);
 -		}
 -	}
 -
 -out:
 -	kfree(new_ie);
 -	kfree(profile);
 -}
 -
 -struct cfg80211_bss *
 -cfg80211_inform_bss_data(struct wiphy *wiphy,
 -			 struct cfg80211_inform_bss *data,
 -			 enum cfg80211_bss_frame_type ftype,
 -			 const u8 *bssid, u64 tsf, u16 capability,
 -			 u16 beacon_interval, const u8 *ie, size_t ielen,
 -			 gfp_t gfp)
 -{
 -	struct cfg80211_bss *res;
 -	struct cfg80211_non_tx_bss non_tx_data;
 -
 -	res = cfg80211_inform_single_bss_data(wiphy, data, ftype, bssid, tsf,
 -					      capability, beacon_interval, ie,
 -					      ielen, NULL, gfp);
 -	if (!res)
 -		return NULL;
 -	non_tx_data.tx_bss = res;
 -	cfg80211_parse_mbssid_data(wiphy, data, ftype, bssid, tsf,
 -				   beacon_interval, ie, ielen, &non_tx_data,
 -				   gfp);
 -	return res;
 -}
  EXPORT_SYMBOL(cfg80211_inform_bss_data);
  
++<<<<<<< HEAD
++=======
+ static void
+ cfg80211_parse_mbssid_frame_data(struct wiphy *wiphy,
+ 				 struct cfg80211_inform_bss *data,
+ 				 struct ieee80211_mgmt *mgmt, size_t len,
+ 				 struct cfg80211_non_tx_bss *non_tx_data,
+ 				 gfp_t gfp)
+ {
+ 	enum cfg80211_bss_frame_type ftype;
+ 	const u8 *ie = mgmt->u.probe_resp.variable;
+ 	size_t ielen = len - offsetof(struct ieee80211_mgmt,
+ 				      u.probe_resp.variable);
+ 
+ 	ftype = ieee80211_is_beacon(mgmt->frame_control) ?
+ 		CFG80211_BSS_FTYPE_BEACON : CFG80211_BSS_FTYPE_PRESP;
+ 
+ 	cfg80211_parse_mbssid_data(wiphy, data, ftype, mgmt->bssid,
+ 				   le64_to_cpu(mgmt->u.probe_resp.timestamp),
+ 				   le16_to_cpu(mgmt->u.probe_resp.beacon_int),
+ 				   ie, ielen, non_tx_data, gfp);
+ }
+ 
+ static void
+ cfg80211_update_notlisted_nontrans(struct wiphy *wiphy,
+ 				   struct cfg80211_bss *nontrans_bss,
+ 				   struct ieee80211_mgmt *mgmt, size_t len,
+ 				   gfp_t gfp)
+ {
+ 	u8 *ie, *new_ie, *pos;
+ 	const u8 *nontrans_ssid, *trans_ssid, *mbssid;
+ 	size_t ielen = len - offsetof(struct ieee80211_mgmt,
+ 				      u.probe_resp.variable);
+ 	size_t new_ie_len;
+ 	struct cfg80211_bss_ies *new_ies;
+ 	const struct cfg80211_bss_ies *old;
+ 	u8 cpy_len;
+ 
+ 	ie = mgmt->u.probe_resp.variable;
+ 
+ 	new_ie_len = ielen;
+ 	trans_ssid = cfg80211_find_ie(WLAN_EID_SSID, ie, ielen);
+ 	if (!trans_ssid)
+ 		return;
+ 	new_ie_len -= trans_ssid[1];
+ 	mbssid = cfg80211_find_ie(WLAN_EID_MULTIPLE_BSSID, ie, ielen);
+ 	/*
+ 	 * It's not valid to have the MBSSID element before SSID
+ 	 * ignore if that happens - the code below assumes it is
+ 	 * after (while copying things inbetween).
+ 	 */
+ 	if (!mbssid || mbssid < trans_ssid)
+ 		return;
+ 	new_ie_len -= mbssid[1];
+ 	rcu_read_lock();
+ 	nontrans_ssid = ieee80211_bss_get_ie(nontrans_bss, WLAN_EID_SSID);
+ 	if (!nontrans_ssid) {
+ 		rcu_read_unlock();
+ 		return;
+ 	}
+ 	new_ie_len += nontrans_ssid[1];
+ 	rcu_read_unlock();
+ 
+ 	/* generate new ie for nontrans BSS
+ 	 * 1. replace SSID with nontrans BSS' SSID
+ 	 * 2. skip MBSSID IE
+ 	 */
+ 	new_ie = kzalloc(new_ie_len, gfp);
+ 	if (!new_ie)
+ 		return;
+ 	new_ies = kzalloc(sizeof(*new_ies) + new_ie_len, gfp);
+ 	if (!new_ies)
+ 		goto out_free;
+ 
+ 	pos = new_ie;
+ 
+ 	/* copy the nontransmitted SSID */
+ 	cpy_len = nontrans_ssid[1] + 2;
+ 	memcpy(pos, nontrans_ssid, cpy_len);
+ 	pos += cpy_len;
+ 	/* copy the IEs between SSID and MBSSID */
+ 	cpy_len = trans_ssid[1] + 2;
+ 	memcpy(pos, (trans_ssid + cpy_len), (mbssid - (trans_ssid + cpy_len)));
+ 	pos += (mbssid - (trans_ssid + cpy_len));
+ 	/* copy the IEs after MBSSID */
+ 	cpy_len = mbssid[1] + 2;
+ 	memcpy(pos, mbssid + cpy_len, ((ie + ielen) - (mbssid + cpy_len)));
+ 
+ 	/* update ie */
+ 	new_ies->len = new_ie_len;
+ 	new_ies->tsf = le64_to_cpu(mgmt->u.probe_resp.timestamp);
+ 	new_ies->from_beacon = ieee80211_is_beacon(mgmt->frame_control);
+ 	memcpy(new_ies->data, new_ie, new_ie_len);
+ 	if (ieee80211_is_probe_resp(mgmt->frame_control)) {
+ 		old = rcu_access_pointer(nontrans_bss->proberesp_ies);
+ 		rcu_assign_pointer(nontrans_bss->proberesp_ies, new_ies);
+ 		rcu_assign_pointer(nontrans_bss->ies, new_ies);
+ 		if (old)
+ 			kfree_rcu((struct cfg80211_bss_ies *)old, rcu_head);
+ 	} else {
+ 		old = rcu_access_pointer(nontrans_bss->beacon_ies);
+ 		rcu_assign_pointer(nontrans_bss->beacon_ies, new_ies);
+ 		rcu_assign_pointer(nontrans_bss->ies, new_ies);
+ 		if (old)
+ 			kfree_rcu((struct cfg80211_bss_ies *)old, rcu_head);
+ 	}
+ 
+ out_free:
+ 	kfree(new_ie);
+ }
+ 
++>>>>>>> 242b0931c191 (cfg80211: validate SSID/MBSSID element ordering assumption)
  /* cfg80211_inform_bss_width_frame helper */
 -static struct cfg80211_bss *
 -cfg80211_inform_single_bss_frame_data(struct wiphy *wiphy,
 -				      struct cfg80211_inform_bss *data,
 -				      struct ieee80211_mgmt *mgmt, size_t len,
 -				      gfp_t gfp)
 +struct cfg80211_bss *
 +cfg80211_inform_bss_frame_data(struct wiphy *wiphy,
 +			       struct cfg80211_inform_bss *data,
 +			       struct ieee80211_mgmt *mgmt, size_t len,
 +			       gfp_t gfp)
 +
  {
  	struct cfg80211_internal_bss tmp = {}, *res;
  	struct cfg80211_bss_ies *ies;
* Unmerged path net/wireless/scan.c
