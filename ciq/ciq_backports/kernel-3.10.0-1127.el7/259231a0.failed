cpuidle: add poll_limit_ns to cpuidle_device structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Marcelo Tosatti <mtosatti@redhat.com>
commit 259231a045616c4101d023a8f4dcc8379af265a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/259231a0.failed

Add a poll_limit_ns variable to cpuidle_device structure.

Calculate and configure it in the new cpuidle_poll_time
function, in case its zero.

Individual governors are allowed to override this value.

	Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 259231a045616c4101d023a8f4dcc8379af265a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpuidle/poll_state.c
#	include/linux/cpuidle.h
diff --cc include/linux/cpuidle.h
index 9bd9bae0c305,b484dd69ec21..000000000000
--- a/include/linux/cpuidle.h
+++ b/include/linux/cpuidle.h
@@@ -64,10 -80,13 +64,14 @@@ struct cpuidle_state 
  struct cpuidle_device {
  	unsigned int		registered:1;
  	unsigned int		enabled:1;
 -	unsigned int		use_deepest_state:1;
 -	unsigned int		poll_time_limit:1;
  	unsigned int		cpu;
 -	ktime_t			next_hrtimer;
  
  	int			last_residency;
++<<<<<<< HEAD
 +	int			state_count;
++=======
+ 	u64			poll_limit_ns;
++>>>>>>> 259231a04561 (cpuidle: add poll_limit_ns to cpuidle_device structure)
  	struct cpuidle_state_usage	states_usage[CPUIDLE_STATE_MAX];
  	struct cpuidle_state_kobj *kobjs[CPUIDLE_STATE_MAX];
  	struct cpuidle_driver_kobj *kobj_driver;
@@@ -118,7 -124,18 +122,22 @@@ struct cpuidle_driver 
  
  #ifdef CONFIG_CPU_IDLE
  extern void disable_cpuidle(void);
++<<<<<<< HEAD
 +extern int cpuidle_idle_call(void);
++=======
+ extern bool cpuidle_not_available(struct cpuidle_driver *drv,
+ 				  struct cpuidle_device *dev);
+ 
+ extern int cpuidle_select(struct cpuidle_driver *drv,
+ 			  struct cpuidle_device *dev,
+ 			  bool *stop_tick);
+ extern int cpuidle_enter(struct cpuidle_driver *drv,
+ 			 struct cpuidle_device *dev, int index);
+ extern void cpuidle_reflect(struct cpuidle_device *dev, int index);
+ extern u64 cpuidle_poll_time(struct cpuidle_driver *drv,
+ 			     struct cpuidle_device *dev);
+ 
++>>>>>>> 259231a04561 (cpuidle: add poll_limit_ns to cpuidle_device structure)
  extern int cpuidle_register_driver(struct cpuidle_driver *drv);
  extern struct cpuidle_driver *cpuidle_get_driver(void);
  extern struct cpuidle_driver *cpuidle_driver_ref(void);
@@@ -138,9 -155,23 +157,25 @@@ extern void cpuidle_disable_device(stru
  extern int cpuidle_play_dead(void);
  
  extern struct cpuidle_driver *cpuidle_get_cpu_driver(struct cpuidle_device *dev);
 -static inline struct cpuidle_device *cpuidle_get_device(void)
 -{return __this_cpu_read(cpuidle_devices); }
  #else
  static inline void disable_cpuidle(void) { }
++<<<<<<< HEAD
 +static inline int cpuidle_idle_call(void) { return -ENODEV; }
++=======
+ static inline bool cpuidle_not_available(struct cpuidle_driver *drv,
+ 					 struct cpuidle_device *dev)
+ {return true; }
+ static inline int cpuidle_select(struct cpuidle_driver *drv,
+ 				 struct cpuidle_device *dev, bool *stop_tick)
+ {return -ENODEV; }
+ static inline int cpuidle_enter(struct cpuidle_driver *drv,
+ 				struct cpuidle_device *dev, int index)
+ {return -ENODEV; }
+ static inline void cpuidle_reflect(struct cpuidle_device *dev, int index) { }
+ extern u64 cpuidle_poll_time(struct cpuidle_driver *drv,
+ 			     struct cpuidle_device *dev)
+ {return 0; }
++>>>>>>> 259231a04561 (cpuidle: add poll_limit_ns to cpuidle_device structure)
  static inline int cpuidle_register_driver(struct cpuidle_driver *drv)
  {return -ENODEV; }
  static inline struct cpuidle_driver *cpuidle_get_driver(void) {return NULL; }
* Unmerged path drivers/cpuidle/poll_state.c
diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c
index fc903b7bb9d3..f93a5cb0c85b 100644
--- a/drivers/cpuidle/cpuidle.c
+++ b/drivers/cpuidle/cpuidle.c
@@ -172,6 +172,36 @@ int cpuidle_idle_call(void)
 	return 0;
 }
 
+/**
+ * cpuidle_poll_time - return amount of time to poll for,
+ * governors can override dev->poll_limit_ns if necessary
+ *
+ * @drv:   the cpuidle driver tied with the cpu
+ * @dev:   the cpuidle device
+ *
+ */
+u64 cpuidle_poll_time(struct cpuidle_driver *drv,
+		      struct cpuidle_device *dev)
+{
+	int i;
+	u64 limit_ns;
+
+	if (dev->poll_limit_ns)
+		return dev->poll_limit_ns;
+
+	limit_ns = TICK_NSEC;
+	for (i = 1; i < drv->state_count; i++) {
+		if (drv->states[i].disabled || dev->states_usage[i].disable)
+			continue;
+
+		limit_ns = (u64)drv->states[i].target_residency * NSEC_PER_USEC;
+	}
+
+	dev->poll_limit_ns = limit_ns;
+
+	return dev->poll_limit_ns;
+}
+
 /**
  * cpuidle_install_idle_handler - installs the cpuidle idle loop handler
  */
* Unmerged path drivers/cpuidle/poll_state.c
diff --git a/drivers/cpuidle/sysfs.c b/drivers/cpuidle/sysfs.c
index 428754af6236..c84d3ceaa030 100644
--- a/drivers/cpuidle/sysfs.c
+++ b/drivers/cpuidle/sysfs.c
@@ -303,11 +303,13 @@ struct cpuidle_state_kobj {
 	struct cpuidle_state_usage *state_usage;
 	struct completion kobj_unregister;
 	struct kobject kobj;
+	struct cpuidle_device *device;
 };
 
 #define kobj_to_state_obj(k) container_of(k, struct cpuidle_state_kobj, kobj)
 #define kobj_to_state(k) (kobj_to_state_obj(k)->state)
 #define kobj_to_state_usage(k) (kobj_to_state_obj(k)->state_usage)
+#define kobj_to_device(k) (kobj_to_state_obj(k)->device)
 #define attr_to_stateattr(a) container_of(a, struct cpuidle_state_attr, attr)
 static ssize_t cpuidle_state_show(struct kobject * kobj,
 	struct attribute * attr ,char * buf)
@@ -330,10 +332,14 @@ static ssize_t cpuidle_state_store(struct kobject *kobj,
 	struct cpuidle_state *state = kobj_to_state(kobj);
 	struct cpuidle_state_usage *state_usage = kobj_to_state_usage(kobj);
 	struct cpuidle_state_attr *cattr = attr_to_stateattr(attr);
+	struct cpuidle_device *dev = kobj_to_device(kobj);
 
 	if (cattr->store)
 		ret = cattr->store(state, state_usage, buf, size);
 
+	/* reset poll time cache */
+	dev->poll_limit_ns = 0;
+
 	return ret;
 }
 
@@ -380,6 +386,7 @@ static int cpuidle_add_state_sysfs(struct cpuidle_device *device)
 			goto error_state;
 		kobj->state = &drv->states[i];
 		kobj->state_usage = &device->states_usage[i];
+		kobj->device = device;
 		init_completion(&kobj->kobj_unregister);
 
 		ret = kobject_init_and_add(&kobj->kobj, &ktype_state_cpuidle,
* Unmerged path include/linux/cpuidle.h
