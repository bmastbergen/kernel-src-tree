ALSA: line6: Assure canceling delayed work at disconnection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit 0b074ab7fc0d575247b9cc9f93bb7e007ca38840
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/0b074ab7.failed

The current code performs the cancel of a delayed work at the late
stage of disconnection procedure, which may lead to the access to the
already cleared state.

This patch assures to call cancel_delayed_work_sync() at the beginning
of the disconnection procedure for avoiding that race.  The delayed
work object is now assigned in the common line6 object instead of its
derivative, so that we can call cancel_delayed_work_sync().

Along with the change, the startup function is called via the new
callback instead.  This will make it easier to port other LINE6
drivers to use the delayed work for startup in later patches.

	Reported-by: syzbot+5255458d5e0a2b10bbb9@syzkaller.appspotmail.com
Fixes: 7f84ff68be05 ("ALSA: line6: toneport: Fix broken usage of timer for delayed execution")
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 0b074ab7fc0d575247b9cc9f93bb7e007ca38840)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/usb/line6/toneport.c
diff --cc sound/usb/line6/toneport.c
index 5c52d41b8d6a,55865f7e437d..000000000000
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@@ -54,9 -54,6 +54,12 @@@ struct usb_line6_toneport 
  	/* Firmware version (x 100) */
  	u8 firmware_version;
  
++<<<<<<< HEAD
 +	/* Timer for delayed PCM startup */
 +	struct timer_list timer;
 +
++=======
++>>>>>>> 0b074ab7fc0d (ALSA: line6: Assure canceling delayed work at disconnection)
  	/* Device type */
  	enum line6_device_type type;
  
@@@ -241,11 -238,8 +244,16 @@@ static int snd_toneport_source_put(stru
  	return 1;
  }
  
++<<<<<<< HEAD
 +static void toneport_start_pcm(struct timer_list *t)
 +{
 +	struct usb_line6_toneport *toneport = from_timer(toneport, t, timer);
 +	struct usb_line6 *line6 = &toneport->line6;
 +
++=======
+ static void toneport_startup(struct usb_line6 *line6)
+ {
++>>>>>>> 0b074ab7fc0d (ALSA: line6: Assure canceling delayed work at disconnection)
  	line6_pcm_acquire(line6->line6pcm, LINE6_STREAM_MONITOR, true);
  }
  
@@@ -387,7 -387,9 +395,13 @@@ static void toneport_setup(struct usb_l
  	if (toneport_has_led(toneport))
  		toneport_update_led(toneport);
  
++<<<<<<< HEAD
 +	mod_timer(&toneport->timer, jiffies + TONEPORT_PCM_DELAY * HZ);
++=======
+ 	schedule_delayed_work(&toneport->line6.startup_work,
+ 			      msecs_to_jiffies(TONEPORT_PCM_DELAY * 1000));
+ 	return 0;
++>>>>>>> 0b074ab7fc0d (ALSA: line6: Assure canceling delayed work at disconnection)
  }
  
  /*
@@@ -398,8 -400,6 +412,11 @@@ static void line6_toneport_disconnect(s
  	struct usb_line6_toneport *toneport =
  		(struct usb_line6_toneport *)line6;
  
++<<<<<<< HEAD
 +	del_timer_sync(&toneport->timer);
 +
++=======
++>>>>>>> 0b074ab7fc0d (ALSA: line6: Assure canceling delayed work at disconnection)
  	if (toneport_has_led(toneport))
  		toneport_remove_leds(toneport);
  }
@@@ -415,9 -415,9 +432,13 @@@ static int toneport_init(struct usb_lin
  	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
  
  	toneport->type = id->driver_info;
++<<<<<<< HEAD
 +	timer_setup(&toneport->timer, toneport_start_pcm, 0);
++=======
++>>>>>>> 0b074ab7fc0d (ALSA: line6: Assure canceling delayed work at disconnection)
  
  	line6->disconnect = line6_toneport_disconnect;
+ 	line6->startup = toneport_startup;
  
  	/* initialize PCM subsystem: */
  	err = line6_init_pcm(line6, &toneport_pcm_properties);
diff --git a/sound/usb/line6/driver.c b/sound/usb/line6/driver.c
index 4f9613e5fc9e..310aea362897 100644
--- a/sound/usb/line6/driver.c
+++ b/sound/usb/line6/driver.c
@@ -710,6 +710,15 @@ static int line6_init_cap_control(struct usb_line6 *line6)
 	return 0;
 }
 
+static void line6_startup_work(struct work_struct *work)
+{
+	struct usb_line6 *line6 =
+		container_of(work, struct usb_line6, startup_work.work);
+
+	if (line6->startup)
+		line6->startup(line6);
+}
+
 /*
 	Probe USB device.
 */
@@ -745,6 +754,7 @@ int line6_probe(struct usb_interface *interface,
 	line6->properties = properties;
 	line6->usbdev = usbdev;
 	line6->ifcdev = &interface->dev;
+	INIT_DELAYED_WORK(&line6->startup_work, line6_startup_work);
 
 	strcpy(card->id, properties->id);
 	strcpy(card->driver, driver_name);
@@ -815,6 +825,8 @@ void line6_disconnect(struct usb_interface *interface)
 	if (WARN_ON(usbdev != line6->usbdev))
 		return;
 
+	cancel_delayed_work(&line6->startup_work);
+
 	if (line6->urb_listen != NULL)
 		line6_stop_listen(line6);
 
diff --git a/sound/usb/line6/driver.h b/sound/usb/line6/driver.h
index 61425597eb61..650d909c9c4f 100644
--- a/sound/usb/line6/driver.h
+++ b/sound/usb/line6/driver.h
@@ -178,11 +178,15 @@ struct usb_line6 {
 			fifo;
 	} messages;
 
+	/* Work for delayed PCM startup */
+	struct delayed_work startup_work;
+
 	/* If MIDI is supported, buffer_message contains the pre-processed data;
 	 * otherwise the data is only in urb_listen (buffer_incoming).
 	 */
 	void (*process_message)(struct usb_line6 *);
 	void (*disconnect)(struct usb_line6 *line6);
+	void (*startup)(struct usb_line6 *line6);
 };
 
 extern char *line6_alloc_sysex_buffer(struct usb_line6 *line6, int code1,
* Unmerged path sound/usb/line6/toneport.c
