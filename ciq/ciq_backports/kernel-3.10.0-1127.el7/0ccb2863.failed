fold __get_file_write_access() into its only caller

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 0ccb286346c4c0644be17f04a9eb23ad99262882
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/0ccb2863.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 0ccb286346c4c0644be17f04a9eb23ad99262882)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/open.c
diff --cc fs/open.c
index 0bdd69faf284,ebef0c5fa10c..000000000000
--- a/fs/open.c
+++ b/fs/open.c
@@@ -668,35 -632,6 +668,38 @@@ out
  	return error;
  }
  
++<<<<<<< HEAD
 +/*
 + * You have to be very careful that these write
 + * counts get cleaned up in error cases and
 + * upon __fput().  This should probably never
 + * be called outside of __dentry_open().
 + */
 +static inline int __get_file_write_access(struct inode *inode,
 +					  struct vfsmount *mnt)
 +{
 +	int error;
 +	error = get_write_access(inode);
 +	if (error)
 +		return error;
 +	/*
 +	 * Do not take mount writer counts on
 +	 * special files since no writes to
 +	 * the mount itself will occur.
 +	 */
 +	if (!special_file(inode->i_mode)) {
 +		/*
 +		 * Balanced in __fput()
 +		 */
 +		error = __mnt_want_write(mnt);
 +		if (error)
 +			put_write_access(inode);
 +	}
 +	return error;
 +}
 +
++=======
++>>>>>>> 0ccb286346c4 (fold __get_file_write_access() into its only caller)
  int open_check_o_direct(struct file *f)
  {
  	/* NB: we're sure to have correct a_ops only after f_op->open */
@@@ -722,13 -660,16 +725,26 @@@ static int do_dentry_open(struct file *
  		f->f_mode = FMODE_PATH;
  
  	path_get(&f->f_path);
++<<<<<<< HEAD
 +	f->f_inode = inode;
 +	if (f->f_mode & FMODE_WRITE) {
 +		error = __get_file_write_access(inode, f->f_path.mnt);
 +		if (error)
 +			goto cleanup_file;
 +		if (!special_file(inode->i_mode))
 +			file_take_write(f);
++=======
+ 	inode = f->f_inode = f->f_path.dentry->d_inode;
+ 	if (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {
+ 		error = get_write_access(inode);
+ 		if (error)
+ 			goto cleanup_file;
+ 		error = __mnt_want_write(f->f_path.mnt);
+ 		if (error) {
+ 			put_write_access(inode);
+ 			goto cleanup_file;
+ 		}
++>>>>>>> 0ccb286346c4 (fold __get_file_write_access() into its only caller)
  	}
  
  	f->f_mapping = inode->i_mapping;
* Unmerged path fs/open.c
