xfs: verify dinode header first

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 50aa90ef03007beca2c9108993f5b4f2bb4f0a66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/50aa90ef.failed

Move the v3 inode integrity information (crc, owner, metauuid) before we
look at anything else in the inode so that we don't waste time on a torn
write or a totally garbled block.  This makes xfs_dinode_verify more
consistent with the other verifiers.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit 50aa90ef03007beca2c9108993f5b4f2bb4f0a66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_inode_buf.c
diff --cc fs/xfs/libxfs/xfs_inode_buf.c
index 3aebe5129937,a1ba112567b0..000000000000
--- a/fs/xfs/libxfs/xfs_inode_buf.c
+++ b/fs/xfs/libxfs/xfs_inode_buf.c
@@@ -387,119 -388,57 +387,135 @@@ xfs_dinode_verify
  {
  	uint16_t		mode;
  	uint16_t		flags;
 -	uint64_t		flags2;
 +	uint64_t		di_size;
  
  	if (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))
 -		return __this_address;
 +		return false;
  
+ 	/* Verify v3 integrity information first */
+ 	if (dip->di_version >= 3) {
+ 		if (!xfs_sb_version_hascrc(&mp->m_sb))
+ 			return __this_address;
+ 		if (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,
+ 				      XFS_DINODE_CRC_OFF))
+ 			return __this_address;
+ 		if (be64_to_cpu(dip->di_ino) != ino)
+ 			return __this_address;
+ 		if (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_uuid))
+ 			return __this_address;
+ 	}
+ 
  	/* don't allow invalid i_size */
 -	if (be64_to_cpu(dip->di_size) & (1ULL << 63))
 -		return __this_address;
 +	di_size = be64_to_cpu(dip->di_size);
 +	if (di_size & (1ULL << 63))
 +		return false;
  
  	mode = be16_to_cpu(dip->di_mode);
  	if (mode && xfs_mode_to_ftype(mode) == XFS_DIR3_FT_UNKNOWN)
 -		return __this_address;
 +		return false;
  
  	/* No zero-length symlinks/dirs. */
 -	if ((S_ISLNK(mode) || S_ISDIR(mode)) && dip->di_size == 0)
 -		return __this_address;
 -
 -	/* only version 3 or greater inodes are extensively verified here */
 -	if (dip->di_version < 3)
 -		return NULL;
 +	if ((S_ISLNK(mode) || S_ISDIR(mode)) && di_size == 0)
 +		return false;
  
 -	flags = be16_to_cpu(dip->di_flags);
 -	flags2 = be64_to_cpu(dip->di_flags2);
 +	/* Fork checks carried over from xfs_iformat_fork */
 +	if (mode &&
 +	    be32_to_cpu(dip->di_nextents) + be16_to_cpu(dip->di_anextents) >
 +			be64_to_cpu(dip->di_nblocks))
 +		return false;
  
 -	/* don't allow reflink/cowextsize if we don't have reflink */
 -	if ((flags2 & (XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)) &&
 -            !xfs_sb_version_hasreflink(&mp->m_sb))
 -		return __this_address;
++<<<<<<< HEAD
 +	if (mode && XFS_DFORK_BOFF(dip) > mp->m_sb.sb_inodesize)
 +		return false;
  
 -	/* don't let reflink and realtime mix */
 -	if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags & XFS_DIFLAG_REALTIME))
 -		return __this_address;
++=======
++>>>>>>> 50aa90ef0300 (xfs: verify dinode header first)
 +	flags = be16_to_cpu(dip->di_flags);
  
 -	/* don't let reflink and dax mix */
 -	if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags2 & XFS_DIFLAG2_DAX))
 -		return __this_address;
 +	if (mode && (flags & XFS_DIFLAG_REALTIME) && !mp->m_rtdev_targp)
 +		return false;
 +
 +	/* Do we have appropriate data fork formats for the mode? */
 +	switch (mode & S_IFMT) {
 +	case S_IFIFO:
 +	case S_IFCHR:
 +	case S_IFBLK:
 +	case S_IFSOCK:
 +		if (dip->di_format != XFS_DINODE_FMT_DEV)
 +			return false;
 +		break;
 +	case S_IFREG:
 +	case S_IFLNK:
 +	case S_IFDIR:
 +		switch (dip->di_format) {
 +		case XFS_DINODE_FMT_LOCAL:
 +			/*
 +			 * no local regular files yet
 +			 */
 +			if (S_ISREG(mode))
 +				return false;
 +			if (di_size > XFS_DFORK_DSIZE(dip, mp))
 +				return false;
 +			if (dip->di_nextents)
 +				return false;
 +			/* fall through */
 +		case XFS_DINODE_FMT_EXTENTS:
 +		case XFS_DINODE_FMT_BTREE:
 +			break;
 +		default:
 +			return false;
 +		}
 +		break;
 +	case 0:
 +		/* Uninitialized inode ok. */
 +		break;
 +	default:
 +		return false;
 +	}
  
 -	return NULL;
 +	if (XFS_DFORK_Q(dip)) {
 +		switch (dip->di_aformat) {
 +		case XFS_DINODE_FMT_LOCAL:
 +			if (dip->di_anextents)
 +				return false;
 +		/* fall through */
 +		case XFS_DINODE_FMT_EXTENTS:
 +		case XFS_DINODE_FMT_BTREE:
 +			break;
 +		default:
 +			return false;
 +		}
 +	} else {
 +		/*
 +		 * If there is no fork offset, this may be a freshly-made inode
 +		 * in a new disk cluster, in which case di_aformat is zeroed.
 +		 * Otherwise, such an inode must be in EXTENTS format; this goes
 +		 * for freed inodes as well.
 +		 */
 +		switch (dip->di_aformat) {
 +		case 0:
 +		case XFS_DINODE_FMT_EXTENTS:
 +			break;
 +		default:
 +			return false;
 +		}
 +		if (dip->di_anextents)
 +			return false;
 +	}
 +	/* only version 3 or greater inodes are extensively verified here */
 +	if (dip->di_version < 3)
 +		return true;
 +
 +	if (!xfs_sb_version_hascrc(&mp->m_sb))
 +		return false;
 +	if (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,
 +			      XFS_DINODE_CRC_OFF))
 +		return false;
 +	if (be64_to_cpu(dip->di_ino) != ino)
 +		return false;
 +	if (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_uuid))
 +		return false;
 +	return true;
  }
  
  void
* Unmerged path fs/xfs/libxfs/xfs_inode_buf.c
