nvme-loop: kill timeout handler

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Ming Lei <ming.lei@redhat.com>
commit 663d6fee66b555f6a080104751be0b54e0bca78a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/663d6fee.failed

Firstly it doesn't make sense to handle timeout for loop: 1) for admin
queue, the request is always completed in code path of queuing IO. 2)
for normal IO request, the timeout on these IOs have been handled by
underlying queue already.

Secondly nvme-loop's timeout handler is simply broken, and easy to
cause issue: 1) no any sync/protection between timeout and normal
completion, and now it is driver's responsibility to deal with
that; 2) bad reset implementation, blk_mq_update_nr_hw_queues()
is called after all NSs's queue is stopped(quiesced), and easy
to trigger deadlock.

So kill the timeout handler.

	Signed-off-by: Ming Lei <ming.lei@redhat.com>
Reviewd-by: Keith Busch <keith.busch@intel.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 663d6fee66b555f6a080104751be0b54e0bca78a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/loop.c
diff --cc drivers/nvme/target/loop.c
index 2fc4c291a3ef,9e211ad6bdd3..000000000000
--- a/drivers/nvme/target/loop.c
+++ b/drivers/nvme/target/loop.c
@@@ -137,21 -129,7 +137,25 @@@ static void nvme_loop_execute_work(stru
  	nvmet_req_execute(&iod->req);
  }
  
++<<<<<<< HEAD
 +static enum blk_eh_timer_return
 +nvme_loop_timeout(struct request *rq, bool reserved)
 +{
 +	struct nvme_loop_iod *iod = blk_mq_rq_to_pdu(rq);
 +
 +	/* queue error recovery */
 +	nvme_reset_ctrl(&iod->queue->ctrl->ctrl);
 +
 +	/* fail with DNR on admin cmd timeout */
 +	nvme_req(rq)->status = NVME_SC_ABORT_REQ | NVME_SC_DNR;
 +
 +	return BLK_EH_HANDLED;
 +}
 +
 +static int nvme_loop_queue_rq(struct blk_mq_hw_ctx *hctx,
++=======
+ static blk_status_t nvme_loop_queue_rq(struct blk_mq_hw_ctx *hctx,
++>>>>>>> 663d6fee66b5 (nvme-loop: kill timeout handler)
  		const struct blk_mq_queue_data *bd)
  {
  	struct nvme_ns *ns = hctx->queue->queuedata;
@@@ -263,10 -239,9 +267,9 @@@ static struct blk_mq_ops nvme_loop_mq_o
  	.complete	= nvme_loop_complete_rq,
  	.init_request	= nvme_loop_init_request,
  	.init_hctx	= nvme_loop_init_hctx,
- 	.timeout	= nvme_loop_timeout,
  };
  
 -static const struct blk_mq_ops nvme_loop_admin_mq_ops = {
 +static struct blk_mq_ops nvme_loop_admin_mq_ops = {
  	.queue_rq	= nvme_loop_queue_rq,
  	.complete	= nvme_loop_complete_rq,
  	.init_request	= nvme_loop_init_request,
* Unmerged path drivers/nvme/target/loop.c
