perf: Make perf_callchain function static

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 8cf7e0e22414f5acf85ecb7cd0d4482e6c9696ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/8cf7e0e2.failed

And move it to core.c, because there's no caller of this function other
than the one in core.c

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20180107160356.28203-6-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 8cf7e0e22414f5acf85ecb7cd0d4482e6c9696ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/callchain.c
diff --cc kernel/events/callchain.c
index 84203ce07276,772a43fea825..000000000000
--- a/kernel/events/callchain.c
+++ b/kernel/events/callchain.c
@@@ -153,28 -175,15 +153,31 @@@ static struct perf_callchain_entry *get
  static void
  put_callchain_entry(int rctx)
  {
 -	put_recursion_context(this_cpu_ptr(callchain_recursion), rctx);
 +	put_recursion_context(__get_cpu_var(callchain_recursion), rctx);
 +}
 +
 +struct perf_callchain_entry *
++<<<<<<< HEAD
 +perf_callchain(struct perf_event *event, struct pt_regs *regs)
 +{
 +	bool kernel = !event->attr.exclude_callchain_kernel;
 +	bool user   = !event->attr.exclude_callchain_user;
 +	/* Disallow cross-task user callchains. */
 +	bool crosstask = event->ctx->task && event->ctx->task != current;
 +
 +	if (!kernel && !user)
 +		return NULL;
 +
 +	return get_perf_callchain(regs, 0, kernel, user, crosstask, true);
  }
  
  struct perf_callchain_entry *
++=======
++>>>>>>> 8cf7e0e22414 (perf: Make perf_callchain function static)
  get_perf_callchain(struct pt_regs *regs, u32 init_nr, bool kernel, bool user,
 -		   u32 max_stack, bool crosstask, bool add_mark)
 +		   bool crosstask, bool add_mark)
  {
  	struct perf_callchain_entry *entry;
 -	struct perf_callchain_entry_ctx ctx;
  	int rctx;
  
  	entry = get_callchain_entry(&rctx);
* Unmerged path kernel/events/callchain.c
diff --git a/kernel/events/core.c b/kernel/events/core.c
index 559f40f24854..c8c1032a601b 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -6188,6 +6188,22 @@ static u64 perf_virt_to_phys(u64 virt)
 	return phys_addr;
 }
 
+static struct perf_callchain_entry *
+perf_callchain(struct perf_event *event, struct pt_regs *regs)
+{
+	bool kernel = !event->attr.exclude_callchain_kernel;
+	bool user   = !event->attr.exclude_callchain_user;
+	/* Disallow cross-task user callchains. */
+	bool crosstask = event->ctx->task && event->ctx->task != current;
+	const u32 max_stack = event->attr.sample_max_stack;
+
+	if (!kernel && !user)
+		return NULL;
+
+	return get_perf_callchain(regs, 0, kernel, user,
+				  max_stack, crosstask, true);
+}
+
 void perf_prepare_sample(struct perf_event_header *header,
 			 struct perf_sample_data *data,
 			 struct perf_event *event,
diff --git a/kernel/events/internal.h b/kernel/events/internal.h
index 843e97047335..2c96d849d661 100644
--- a/kernel/events/internal.h
+++ b/kernel/events/internal.h
@@ -200,10 +200,6 @@ arch_perf_out_copy_user(void *dst, const void *src, unsigned long n)
 
 DEFINE_OUTPUT_COPY(__output_copy_user, arch_perf_out_copy_user)
 
-/* Callchain handling */
-extern struct perf_callchain_entry *
-perf_callchain(struct perf_event *event, struct pt_regs *regs);
-
 static inline int get_recursion_context(int *recursion)
 {
 	int rctx;
