ipc: standardize code comments

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [ipc] standardize code comments (Waiman Long) [1373519]
Rebuild_FUZZ: 90.91%
commit-author Davidlohr Bueso <davidlohr@hp.com>
commit 8001c85810dd2277d75ae60376e840456afa9b7e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/8001c858.failed

IPC commenting style is all over the place, *specially* in util.c.  This
patch orders things a bit.

	Signed-off-by: Davidlohr Bueso <davidlohr@hp.com>
	Cc: Aswin Chandramouleeswaran <aswin@hp.com>
	Cc: Rik van Riel <riel@redhat.com>
	Acked-by: Manfred Spraul <manfred@colorfullife.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8001c85810dd2277d75ae60376e840456afa9b7e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	ipc/util.c
diff --cc ipc/util.c
index 496c9b0095ff,af976fc6a464..000000000000
--- a/ipc/util.c
+++ b/ipc/util.c
@@@ -227,12 -225,11 +225,16 @@@ static struct kern_ipc_perm *ipc_findke
  }
  
  /**
++<<<<<<< HEAD
 + *	ipc_get_maxid 	-	get the last assigned id
 + *	@ids: IPC identifier set
++=======
+  * ipc_get_maxid - get the last assigned id
+  * @ids: ipc identifier set
++>>>>>>> 8001c85810dd (ipc: standardize code comments)
   *
-  *	Called with ipc_ids.rwsem held.
+  * Called with ipc_ids.rwsem held.
   */
- 
  int ipc_get_maxid(struct ipc_ids *ids)
  {
  	struct kern_ipc_perm *ipc;
@@@ -258,19 -255,19 +260,26 @@@
  }
  
  /**
++<<<<<<< HEAD
 + *	ipc_addid 	-	add an IPC identifier
 + *	@ids: IPC identifier set
 + *	@new: new IPC permission set
 + *	@size: limit for the number of used ids
++=======
+  * ipc_addid - add an ipc identifier
+  * @ids: ipc identifier set
+  * @new: new ipc permission set
+  * @size: limit for the number of used ids
++>>>>>>> 8001c85810dd (ipc: standardize code comments)
   *
-  *	Add an entry 'new' to the IPC ids idr. The permissions object is
-  *	initialised and the first free entry is set up and the id assigned
-  *	is returned. The 'new' entry is returned in a locked state on success.
-  *	On failure the entry is not locked and a negative err-code is returned.
+  * Add an entry 'new' to the ipc ids idr. The permissions object is
+  * initialised and the first free entry is set up and the id assigned
+  * is returned. The 'new' entry is returned in a locked state on success.
+  * On failure the entry is not locked and a negative err-code is returned.
   *
-  *	Called with writer ipc_ids.rwsem held.
+  * Called with writer ipc_ids.rwsem held.
   */
 -int ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int size)
 +int ipc_addid(struct ipc_ids* ids, struct kern_ipc_perm* new, int size)
  {
  	kuid_t euid;
  	kgid_t egid;
@@@ -453,30 -449,33 +461,33 @@@ void ipc_rmid(struct ipc_ids *ids, stru
  }
  
  /**
-  *	ipc_alloc	-	allocate ipc space
-  *	@size: size desired
+  * ipc_alloc -	allocate ipc space
+  * @size: size desired
   *
-  *	Allocate memory from the appropriate pools and return a pointer to it.
-  *	NULL is returned if the allocation fails
+  * Allocate memory from the appropriate pools and return a pointer to it.
+  * NULL is returned if the allocation fails
   */
-  
  void *ipc_alloc(int size)
  {
 -	void *out;
 -	if (size > PAGE_SIZE)
 -		out = vmalloc(size);
 -	else
 -		out = kmalloc(size, GFP_KERNEL);
 -	return out;
 +	return kvmalloc(size, GFP_KERNEL);
  }
  
  /**
-  *	ipc_free        -       free ipc space
-  *	@ptr: pointer returned by ipc_alloc
-  *	@size: size of block
+  * ipc_free - free ipc space
+  * @ptr: pointer returned by ipc_alloc
+  * @size: size of block
   *
-  *	Free a block created with ipc_alloc(). The caller must know the size
-  *	used in the allocation call.
+  * Free a block created with ipc_alloc(). The caller must know the size
+  * used in the allocation call.
   */
++<<<<<<< HEAD
 +
 +void ipc_free(void* ptr, int size)
++=======
+ void ipc_free(void *ptr, int size)
++>>>>>>> 8001c85810dd (ipc: standardize code comments)
  {
 -	if (size > PAGE_SIZE)
 +	if(size > PAGE_SIZE)
  		vfree(ptr);
  	else
  		kfree(ptr);
@@@ -529,17 -528,16 +540,20 @@@ void ipc_rcu_free(struct rcu_head *head
  }
  
  /**
-  *	ipcperms	-	check IPC permissions
-  *	@ns: IPC namespace
-  *	@ipcp: IPC permission set
-  *	@flag: desired permission set.
+  * ipcperms - check ipc permissions
+  * @ns: ipc namespace
+  * @ipcp: ipc permission set
+  * @flag: desired permission set
   *
-  *	Check user, group, other permissions for access
-  *	to ipc resources. return 0 if allowed
+  * Check user, group, other permissions for access
+  * to ipc resources. return 0 if allowed
   *
++<<<<<<< HEAD
 + * 	@flag will most probably be 0 or S_...UGO from <linux/stat.h>
++=======
+  * @flag will most probably be 0 or S_...UGO from <linux/stat.h>
++>>>>>>> 8001c85810dd (ipc: standardize code comments)
   */
-  
  int ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flag)
  {
  	kuid_t euid = current_euid();
@@@ -567,16 -565,14 +581,20 @@@
   */
  
  /**
-  *	kernel_to_ipc64_perm	-	convert kernel ipc permissions to user
-  *	@in: kernel permissions
-  *	@out: new style IPC permissions
+  * kernel_to_ipc64_perm	- convert kernel ipc permissions to user
+  * @in: kernel permissions
+  * @out: new style ipc permissions
   *
-  *	Turn the kernel object @in into a set of permissions descriptions
-  *	for returning to userspace (@out).
+  * Turn the kernel object @in into a set of permissions descriptions
+  * for returning to userspace (@out).
   */
++<<<<<<< HEAD
 + 
 +
 +void kernel_to_ipc64_perm (struct kern_ipc_perm *in, struct ipc64_perm *out)
++=======
+ void kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out)
++>>>>>>> 8001c85810dd (ipc: standardize code comments)
  {
  	out->key	= in->key;
  	out->uid	= from_kuid_munged(current_user_ns(), in->uid);
@@@ -588,15 -584,14 +606,19 @@@
  }
  
  /**
-  *	ipc64_perm_to_ipc_perm	-	convert new ipc permissions to old
-  *	@in: new style IPC permissions
-  *	@out: old style IPC permissions
+  * ipc64_perm_to_ipc_perm - convert new ipc permissions to old
+  * @in: new style ipc permissions
+  * @out: old style ipc permissions
   *
-  *	Turn the new style permissions object @in into a compatibility
-  *	object and store it into the @out pointer.
+  * Turn the new style permissions object @in into a compatibility
+  * object and store it into the @out pointer.
   */
++<<<<<<< HEAD
 + 
 +void ipc64_perm_to_ipc_perm (struct ipc64_perm *in, struct ipc_perm *out)
++=======
+ void ipc64_perm_to_ipc_perm(struct ipc64_perm *in, struct ipc_perm *out)
++>>>>>>> 8001c85810dd (ipc: standardize code comments)
  {
  	out->key	= in->key;
  	SET_UID(out->uid, in->uid);
@@@ -774,15 -769,14 +796,19 @@@ err
  
  
  /**
-  *	ipc_parse_version	-	IPC call version
-  *	@cmd: pointer to command
+  * ipc_parse_version - ipc call version
+  * @cmd: pointer to command
   *
-  *	Return IPC_64 for new style IPC and IPC_OLD for old style IPC. 
-  *	The @cmd value is turned from an encoding command and version into
-  *	just the command code.
+  * Return IPC_64 for new style IPC and IPC_OLD for old style IPC.
+  * The @cmd value is turned from an encoding command and version into
+  * just the command code.
   */
++<<<<<<< HEAD
 + 
 +int ipc_parse_version (int *cmd)
++=======
+ int ipc_parse_version(int *cmd)
++>>>>>>> 8001c85810dd (ipc: standardize code comments)
  {
  	if (*cmd & IPC_64) {
  		*cmd ^= IPC_64;
diff --git a/ipc/sem.c b/ipc/sem.c
index b95cbc887889..e4fc1d614897 100644
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@ -226,7 +226,7 @@ static void unmerge_queues(struct sem_array *sma)
 }
 
 /**
- * merge_queues - Merge single semop queues into global queue
+ * merge_queues - merge single semop queues into global queue
  * @sma: semaphore array
  *
  * This function merges all per-semaphore queues into the global queue.
@@ -477,7 +477,6 @@ static inline void sem_rmid(struct ipc_namespace *ns, struct sem_array *s)
  *
  * Called with sem_ids.rwsem held (as a writer)
  */
-
 static int newary(struct ipc_namespace *ns, struct ipc_params *params)
 {
 	int id;
@@ -684,7 +683,7 @@ static void wake_up_sem_queue_prepare(struct list_head *pt,
 }
 
 /**
- * wake_up_sem_queue_do(pt) - do the actual wake-up
+ * wake_up_sem_queue_do - do the actual wake-up
  * @pt: list of tasks to be woken up
  *
  * Do the actual wake-up.
@@ -750,7 +749,7 @@ static int check_restart(struct sem_array *sma, struct sem_queue *q)
 }
 
 /**
- * wake_const_ops(sma, semnum, pt) - Wake up non-alter tasks
+ * wake_const_ops - wake up non-alter tasks
  * @sma: semaphore array.
  * @semnum: semaphore that was modified.
  * @pt: list head for the tasks that must be woken up.
@@ -800,15 +799,14 @@ static int wake_const_ops(struct sem_array *sma, int semnum,
 }
 
 /**
- * do_smart_wakeup_zero(sma, sops, nsops, pt) - wakeup all wait for zero tasks
+ * do_smart_wakeup_zero - wakeup all wait for zero tasks
  * @sma: semaphore array
  * @sops: operations that were performed
  * @nsops: number of operations
  * @pt: list head of the tasks that must be woken up.
  *
- * do_smart_wakeup_zero() checks all required queue for wait-for-zero
- * operations, based on the actual changes that were performed on the
- * semaphore array.
+ * Checks all required queue for wait-for-zero operations, based
+ * on the actual changes that were performed on the semaphore array.
  * The function returns 1 if at least one operation was completed successfully.
  */
 static int do_smart_wakeup_zero(struct sem_array *sma, struct sembuf *sops,
@@ -852,7 +850,7 @@ static int do_smart_wakeup_zero(struct sem_array *sma, struct sembuf *sops,
 
 
 /**
- * update_queue(sma, semnum): Look for tasks that can be completed.
+ * update_queue - look for tasks that can be completed.
  * @sma: semaphore array.
  * @semnum: semaphore that was modified.
  * @pt: list head for the tasks that must be woken up.
@@ -922,7 +920,7 @@ again:
 }
 
 /**
- * set_semotime(sma, sops) - set sem_otime
+ * set_semotime - set sem_otime
  * @sma: semaphore array
  * @sops: operations that modified the array, may be NULL
  *
@@ -940,7 +938,7 @@ static void set_semotime(struct sem_array *sma, struct sembuf *sops)
 }
 
 /**
- * do_smart_update(sma, sops, nsops, otime, pt) - optimized update_queue
+ * do_smart_update - optimized update_queue
  * @sma: semaphore array
  * @sops: operations that were performed
  * @nsops: number of operations
@@ -1660,7 +1658,7 @@ static struct sem_undo *lookup_undo(struct sem_undo_list *ulp, int semid)
 }
 
 /**
- * find_alloc_undo - Lookup (and if not present create) undo array
+ * find_alloc_undo - lookup (and if not present create) undo array
  * @ns: namespace
  * @semid: semaphore array id
  *
@@ -1750,7 +1748,7 @@ out:
 
 
 /**
- * get_queue_result - Retrieve the result code from sem_queue
+ * get_queue_result - retrieve the result code from sem_queue
  * @q: Pointer to queue structure
  *
  * Retrieve the return code from the pending queue. If IN_WAKEUP is found in
diff --git a/ipc/shm.c b/ipc/shm.c
index 6801069fa93d..a7aa80b22508 100644
--- a/ipc/shm.c
+++ b/ipc/shm.c
@@ -501,7 +501,6 @@ static const struct vm_operations_struct shm_vm_ops = {
  *
  * Called with shm_ids.rwsem held as a writer.
  */
-
 static int newseg(struct ipc_namespace *ns, struct ipc_params *params)
 {
 	key_t key = params->key;
* Unmerged path ipc/util.c
