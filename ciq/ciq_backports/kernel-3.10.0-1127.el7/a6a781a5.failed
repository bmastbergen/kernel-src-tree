xfs: have buffer verifier functions report failing address

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit a6a781a58befcbd467ce843af4eaca3906aa1f08
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/a6a781a5.failed

Modify each function that checks the contents of a metadata buffer to
return the instruction address of the failing test so that we can report
more precise failure errors to the log.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit a6a781a58befcbd467ce843af4eaca3906aa1f08)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_alloc.c
#	fs/xfs/libxfs/xfs_alloc_btree.c
#	fs/xfs/libxfs/xfs_attr_leaf.c
#	fs/xfs/libxfs/xfs_attr_remote.c
#	fs/xfs/libxfs/xfs_bmap_btree.c
#	fs/xfs/libxfs/xfs_btree.c
#	fs/xfs/libxfs/xfs_btree.h
#	fs/xfs/libxfs/xfs_da_btree.c
#	fs/xfs/libxfs/xfs_dir2_block.c
#	fs/xfs/libxfs/xfs_dir2_data.c
#	fs/xfs/libxfs/xfs_dir2_leaf.c
#	fs/xfs/libxfs/xfs_dir2_node.c
#	fs/xfs/libxfs/xfs_ialloc.c
#	fs/xfs/libxfs/xfs_ialloc_btree.c
#	fs/xfs/libxfs/xfs_inode_buf.c
#	fs/xfs/libxfs/xfs_refcount_btree.c
#	fs/xfs/libxfs/xfs_rmap_btree.c
#	fs/xfs/libxfs/xfs_symlink_remote.c
#	fs/xfs/scrub/inode.c
diff --cc fs/xfs/libxfs/xfs_alloc.c
index 71f7539a064c,4d7ef74f5783..000000000000
--- a/fs/xfs/libxfs/xfs_alloc.c
+++ b/fs/xfs/libxfs/xfs_alloc.c
@@@ -543,12 -568,9 +544,18 @@@ xfs_agfl_read_verify
  		return;
  
  	if (!xfs_buf_verify_cksum(bp, XFS_AGFL_CRC_OFF))
++<<<<<<< HEAD
 +		xfs_buf_ioerror(bp, -EFSBADCRC);
 +	else if (!xfs_agfl_verify(bp))
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +
 +	if (bp->b_error)
 +		xfs_verifier_error(bp);
++=======
+ 		xfs_verifier_error(bp, -EFSBADCRC);
+ 	else if (xfs_agfl_verify(bp))
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  }
  
  static void
@@@ -562,9 -584,8 +569,14 @@@ xfs_agfl_write_verify
  	if (!xfs_sb_version_hascrc(&mp->m_sb))
  		return;
  
++<<<<<<< HEAD
 +	if (!xfs_agfl_verify(bp)) {
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +		xfs_verifier_error(bp);
++=======
+ 	if (xfs_agfl_verify(bp)) {
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  		return;
  	}
  
@@@ -2394,39 -2403,31 +2406,54 @@@ xfs_agf_verify
  
  	if (xfs_sb_version_hascrc(&mp->m_sb)) {
  		if (!uuid_equal(&agf->agf_uuid, &mp->m_sb.sb_meta_uuid))
- 			return false;
+ 			return __this_address;
  		if (!xfs_log_check_lsn(mp,
  				be64_to_cpu(XFS_BUF_TO_AGF(bp)->agf_lsn)))
- 			return false;
+ 			return __this_address;
  	}
  
 +	/*
 +	 * RHEL7: The RHEL7 v5 AGFL is one slot smaller than upstream due to the
 +	 * header padding problem. Allow the on-disk AGFL fields to exceed the
 +	 * expected size by one so the verifier doesn't generate corruption
 +	 * errors for valid upstream (or RHEL8) filesystems. The AGF read
 +	 * handler detects this incompatibility and triggers an AGFL reset at
 +	 * block allocation time such that the filesystem remains online. See
 +	 * xfs_agfl_needs_reset() for further details.
 +	 */
 +	xfs_agfl_size = XFS_AGFL_SIZE(mp);
 +	if (xfs_sb_version_hascrc(&mp->m_sb))
 +		xfs_agfl_size++;
 +
  	if (!(agf->agf_magicnum == cpu_to_be32(XFS_AGF_MAGIC) &&
  	      XFS_AGF_GOOD_VERSION(be32_to_cpu(agf->agf_versionnum)) &&
  	      be32_to_cpu(agf->agf_freeblks) <= be32_to_cpu(agf->agf_length) &&
++<<<<<<< HEAD
 +	      be32_to_cpu(agf->agf_flfirst) < xfs_agfl_size &&
 +	      be32_to_cpu(agf->agf_fllast) < xfs_agfl_size &&
 +	      be32_to_cpu(agf->agf_flcount) <= xfs_agfl_size))
 +		return false;
++=======
+ 	      be32_to_cpu(agf->agf_flfirst) < XFS_AGFL_SIZE(mp) &&
+ 	      be32_to_cpu(agf->agf_fllast) < XFS_AGFL_SIZE(mp) &&
+ 	      be32_to_cpu(agf->agf_flcount) <= XFS_AGFL_SIZE(mp)))
+ 		return __this_address;
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  
  	if (be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) < 1 ||
  	    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) < 1 ||
  	    be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) > XFS_BTREE_MAXLEVELS ||
  	    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) > XFS_BTREE_MAXLEVELS)
- 		return false;
+ 		return __this_address;
+ 
++<<<<<<< HEAD
++=======
+ 	if (xfs_sb_version_hasrmapbt(&mp->m_sb) &&
+ 	    (be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) < 1 ||
+ 	     be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) > XFS_BTREE_MAXLEVELS))
+ 		return __this_address;
  
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  	/*
  	 * during growfs operations, the perag is not fully initialised,
  	 * so we can't use it for any useful checking. growfs ensures we can't
@@@ -2438,9 -2439,14 +2465,18 @@@
  
  	if (xfs_sb_version_haslazysbcount(&mp->m_sb) &&
  	    be32_to_cpu(agf->agf_btreeblks) > be32_to_cpu(agf->agf_length))
- 		return false;
+ 		return __this_address;
  
++<<<<<<< HEAD
 +	return true;;
++=======
+ 	if (xfs_sb_version_hasreflink(&mp->m_sb) &&
+ 	    (be32_to_cpu(agf->agf_refcount_level) < 1 ||
+ 	     be32_to_cpu(agf->agf_refcount_level) > XFS_BTREE_MAXLEVELS))
+ 		return __this_address;
+ 
+ 	return NULL;
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  
  }
  
@@@ -2452,13 -2458,10 +2488,18 @@@ xfs_agf_read_verify
  
  	if (xfs_sb_version_hascrc(&mp->m_sb) &&
  	    !xfs_buf_verify_cksum(bp, XFS_AGF_CRC_OFF))
++<<<<<<< HEAD
 +		xfs_buf_ioerror(bp, -EFSBADCRC);
 +	else if (XFS_TEST_ERROR(!xfs_agf_verify(mp, bp), mp,
++=======
+ 		xfs_verifier_error(bp, -EFSBADCRC);
+ 	else if (XFS_TEST_ERROR(xfs_agf_verify(mp, bp), mp,
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  				XFS_ERRTAG_ALLOC_READ_AGF))
 -		xfs_verifier_error(bp, -EFSCORRUPTED);
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +
 +	if (bp->b_error)
 +		xfs_verifier_error(bp);
  }
  
  static void
@@@ -2468,9 -2471,8 +2509,14 @@@ xfs_agf_write_verify
  	struct xfs_mount *mp = bp->b_target->bt_mount;
  	struct xfs_buf_log_item	*bip = bp->b_fspriv;
  
++<<<<<<< HEAD
 +	if (!xfs_agf_verify(mp, bp)) {
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +		xfs_verifier_error(bp);
++=======
+ 	if (xfs_agf_verify(mp, bp)) {
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  		return;
  	}
  
diff --cc fs/xfs/libxfs/xfs_alloc_btree.c
index 63a0babaab52,4383c05df8ca..000000000000
--- a/fs/xfs/libxfs/xfs_alloc_btree.c
+++ b/fs/xfs/libxfs/xfs_alloc_btree.c
@@@ -256,7 -280,34 +256,38 @@@ xfs_allocbt_key_diff
  	return (int64_t)be32_to_cpu(kp->ar_startblock) - rec->ar_startblock;
  }
  
++<<<<<<< HEAD
 +static bool
++=======
+ STATIC int64_t
+ xfs_bnobt_diff_two_keys(
+ 	struct xfs_btree_cur	*cur,
+ 	union xfs_btree_key	*k1,
+ 	union xfs_btree_key	*k2)
+ {
+ 	return (int64_t)be32_to_cpu(k1->alloc.ar_startblock) -
+ 			  be32_to_cpu(k2->alloc.ar_startblock);
+ }
+ 
+ STATIC int64_t
+ xfs_cntbt_diff_two_keys(
+ 	struct xfs_btree_cur	*cur,
+ 	union xfs_btree_key	*k1,
+ 	union xfs_btree_key	*k2)
+ {
+ 	int64_t			diff;
+ 
+ 	diff =  be32_to_cpu(k1->alloc.ar_blockcount) -
+ 		be32_to_cpu(k2->alloc.ar_blockcount);
+ 	if (diff)
+ 		return diff;
+ 
+ 	return  be32_to_cpu(k1->alloc.ar_startblock) -
+ 		be32_to_cpu(k2->alloc.ar_startblock);
+ }
+ 
+ static xfs_failaddr_t
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  xfs_allocbt_verify(
  	struct xfs_buf		*bp)
  {
@@@ -313,24 -367,21 +347,30 @@@ xfs_allocbt_read_verify
  	struct xfs_buf	*bp)
  {
  	if (!xfs_btree_sblock_verify_crc(bp))
++<<<<<<< HEAD
 +		xfs_buf_ioerror(bp, -EFSBADCRC);
 +	else if (!xfs_allocbt_verify(bp))
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
++=======
+ 		xfs_verifier_error(bp, -EFSBADCRC);
+ 	else if (xfs_allocbt_verify(bp))
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  
 -	if (bp->b_error)
 +	if (bp->b_error) {
  		trace_xfs_btree_corrupt(bp, _RET_IP_);
 +		xfs_verifier_error(bp);
 +	}
  }
  
  static void
  xfs_allocbt_write_verify(
  	struct xfs_buf	*bp)
  {
- 	if (!xfs_allocbt_verify(bp)) {
+ 	if (xfs_allocbt_verify(bp)) {
  		trace_xfs_btree_corrupt(bp, _RET_IP_);
 -		xfs_verifier_error(bp, -EFSCORRUPTED);
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +		xfs_verifier_error(bp);
  		return;
  	}
  	xfs_btree_sblock_calc_crc(bp);
diff --cc fs/xfs/libxfs/xfs_attr_leaf.c
index 521209514b31,f6281e100469..000000000000
--- a/fs/xfs/libxfs/xfs_attr_leaf.c
+++ b/fs/xfs/libxfs/xfs_attr_leaf.c
@@@ -296,9 -296,8 +296,14 @@@ xfs_attr3_leaf_write_verify
  	struct xfs_buf_log_item	*bip = bp->b_fspriv;
  	struct xfs_attr3_leaf_hdr *hdr3 = bp->b_addr;
  
++<<<<<<< HEAD
 +	if (!xfs_attr3_leaf_verify(bp)) {
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +		xfs_verifier_error(bp);
++=======
+ 	if (xfs_attr3_leaf_verify(bp)) {
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  		return;
  	}
  
@@@ -325,12 -324,9 +330,18 @@@ xfs_attr3_leaf_read_verify
  
  	if (xfs_sb_version_hascrc(&mp->m_sb) &&
  	     !xfs_buf_verify_cksum(bp, XFS_ATTR3_LEAF_CRC_OFF))
++<<<<<<< HEAD
 +		xfs_buf_ioerror(bp, -EFSBADCRC);
 +	else if (!xfs_attr3_leaf_verify(bp))
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +
 +	if (bp->b_error)
 +		xfs_verifier_error(bp);
++=======
+ 		xfs_verifier_error(bp, -EFSBADCRC);
+ 	else if (xfs_attr3_leaf_verify(bp))
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  }
  
  const struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {
diff --cc fs/xfs/libxfs/xfs_attr_remote.c
index 3e888d7d3199,06858db972ed..000000000000
--- a/fs/xfs/libxfs/xfs_attr_remote.c
+++ b/fs/xfs/libxfs/xfs_attr_remote.c
@@@ -137,12 -137,12 +137,18 @@@ xfs_attr3_rmt_read_verify
  
  	while (len > 0) {
  		if (!xfs_verify_cksum(ptr, blksize, XFS_ATTR3_RMT_CRC_OFF)) {
 -			xfs_verifier_error(bp, -EFSBADCRC);
 -			return;
 +			xfs_buf_ioerror(bp, -EFSBADCRC);
 +			break;
  		}
++<<<<<<< HEAD
 +		if (!xfs_attr3_rmt_verify(mp, ptr, blksize, bno)) {
 +			xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +			break;
++=======
+ 		if (xfs_attr3_rmt_verify(mp, ptr, blksize, bno)) {
+ 			xfs_verifier_error(bp, -EFSCORRUPTED);
+ 			return;
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  		}
  		len -= blksize;
  		ptr += blksize;
@@@ -177,9 -175,8 +183,14 @@@ xfs_attr3_rmt_write_verify
  	while (len > 0) {
  		struct xfs_attr3_rmt_hdr *rmt = (struct xfs_attr3_rmt_hdr *)ptr;
  
++<<<<<<< HEAD
 +		if (!xfs_attr3_rmt_verify(mp, ptr, blksize, bno)) {
 +			xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +			xfs_verifier_error(bp);
++=======
+ 		if (xfs_attr3_rmt_verify(mp, ptr, blksize, bno)) {
+ 			xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  			return;
  		}
  
diff --cc fs/xfs/libxfs/xfs_bmap_btree.c
index 2fb9ffdf0120,0fdae57e7944..000000000000
--- a/fs/xfs/libxfs/xfs_bmap_btree.c
+++ b/fs/xfs/libxfs/xfs_bmap_btree.c
@@@ -400,7 -415,17 +400,21 @@@ xfs_bmbt_key_diff
  				      cur->bc_rec.b.br_startoff;
  }
  
++<<<<<<< HEAD
 +static bool
++=======
+ STATIC int64_t
+ xfs_bmbt_diff_two_keys(
+ 	struct xfs_btree_cur	*cur,
+ 	union xfs_btree_key	*k1,
+ 	union xfs_btree_key	*k2)
+ {
+ 	return (int64_t)be64_to_cpu(k1->bmbt.br_startoff) -
+ 			  be64_to_cpu(k2->bmbt.br_startoff);
+ }
+ 
+ static xfs_failaddr_t
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  xfs_bmbt_verify(
  	struct xfs_buf		*bp)
  {
@@@ -420,8 -440,9 +435,14 @@@
  		 * XXX: need a better way of verifying the owner here. Right now
  		 * just make sure there has been one set.
  		 */
++<<<<<<< HEAD
 +		if (be64_to_cpu(block->bb_u.l.bb_owner) == 0)
 +			return false;
++=======
+ 		fa = xfs_btree_lblock_v5hdr_verify(bp, XFS_RMAP_OWN_UNKNOWN);
+ 		if (fa)
+ 			return fa;
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  		/* fall through */
  	case cpu_to_be32(XFS_BMAP_MAGIC):
  		break;
@@@ -438,21 -459,9 +459,25 @@@
  	 */
  	level = be16_to_cpu(block->bb_level);
  	if (level > max(mp->m_bm_maxlevels[0], mp->m_bm_maxlevels[1]))
++<<<<<<< HEAD
 +		return false;
 +	if (be16_to_cpu(block->bb_numrecs) > mp->m_bmap_dmxr[level != 0])
 +		return false;
++=======
+ 		return __this_address;
 -
 -	return xfs_btree_lblock_verify(bp, mp->m_bmap_dmxr[level != 0]);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
 +
 +	/* sibling pointer verification */
 +	if (!block->bb_u.l.bb_leftsib ||
 +	    (block->bb_u.l.bb_leftsib != cpu_to_be64(NULLFSBLOCK) &&
 +	     !xfs_verify_fsbno(mp, be64_to_cpu(block->bb_u.l.bb_leftsib))))
 +		return false;
 +	if (!block->bb_u.l.bb_rightsib ||
 +	    (block->bb_u.l.bb_rightsib != cpu_to_be64(NULLFSBLOCK) &&
 +	     !xfs_verify_fsbno(mp, be64_to_cpu(block->bb_u.l.bb_rightsib))))
 +		return false;
 +
 +	return true;
  }
  
  static void
@@@ -460,24 -469,21 +485,30 @@@ xfs_bmbt_read_verify
  	struct xfs_buf	*bp)
  {
  	if (!xfs_btree_lblock_verify_crc(bp))
++<<<<<<< HEAD
 +		xfs_buf_ioerror(bp, -EFSBADCRC);
 +	else if (!xfs_bmbt_verify(bp))
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
++=======
+ 		xfs_verifier_error(bp, -EFSBADCRC);
+ 	else if (xfs_bmbt_verify(bp))
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  
 -	if (bp->b_error)
 +	if (bp->b_error) {
  		trace_xfs_btree_corrupt(bp, _RET_IP_);
 +		xfs_verifier_error(bp);
 +	}
  }
  
  static void
  xfs_bmbt_write_verify(
  	struct xfs_buf	*bp)
  {
- 	if (!xfs_bmbt_verify(bp)) {
+ 	if (xfs_bmbt_verify(bp)) {
  		trace_xfs_btree_corrupt(bp, _RET_IP_);
 -		xfs_verifier_error(bp, -EFSCORRUPTED);
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +		xfs_verifier_error(bp);
  		return;
  	}
  	xfs_btree_lblock_calc_crc(bp);
diff --cc fs/xfs/libxfs/xfs_btree.c
index b40f6d005e5f,2b2be1d6c00d..000000000000
--- a/fs/xfs/libxfs/xfs_btree.c
+++ b/fs/xfs/libxfs/xfs_btree.c
@@@ -4240,6 -4529,51 +4240,54 @@@ xfs_btree_change_owner
  			&bbcoi);
  }
  
++<<<<<<< HEAD
++=======
+ /* Verify the v5 fields of a long-format btree block. */
+ xfs_failaddr_t
+ xfs_btree_lblock_v5hdr_verify(
+ 	struct xfs_buf		*bp,
+ 	uint64_t		owner)
+ {
+ 	struct xfs_mount	*mp = bp->b_target->bt_mount;
+ 	struct xfs_btree_block	*block = XFS_BUF_TO_BLOCK(bp);
+ 
+ 	if (!xfs_sb_version_hascrc(&mp->m_sb))
+ 		return __this_address;
+ 	if (!uuid_equal(&block->bb_u.l.bb_uuid, &mp->m_sb.sb_meta_uuid))
+ 		return __this_address;
+ 	if (block->bb_u.l.bb_blkno != cpu_to_be64(bp->b_bn))
+ 		return __this_address;
+ 	if (owner != XFS_RMAP_OWN_UNKNOWN &&
+ 	    be64_to_cpu(block->bb_u.l.bb_owner) != owner)
+ 		return __this_address;
+ 	return NULL;
+ }
+ 
+ /* Verify a long-format btree block. */
+ xfs_failaddr_t
+ xfs_btree_lblock_verify(
+ 	struct xfs_buf		*bp,
+ 	unsigned int		max_recs)
+ {
+ 	struct xfs_mount	*mp = bp->b_target->bt_mount;
+ 	struct xfs_btree_block	*block = XFS_BUF_TO_BLOCK(bp);
+ 
+ 	/* numrecs verification */
+ 	if (be16_to_cpu(block->bb_numrecs) > max_recs)
+ 		return __this_address;
+ 
+ 	/* sibling pointer verification */
+ 	if (block->bb_u.l.bb_leftsib != cpu_to_be64(NULLFSBLOCK) &&
+ 	    !xfs_verify_fsbno(mp, be64_to_cpu(block->bb_u.l.bb_leftsib)))
+ 		return __this_address;
+ 	if (block->bb_u.l.bb_rightsib != cpu_to_be64(NULLFSBLOCK) &&
+ 	    !xfs_verify_fsbno(mp, be64_to_cpu(block->bb_u.l.bb_rightsib)))
+ 		return __this_address;
+ 
+ 	return NULL;
+ }
+ 
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  /**
   * xfs_btree_sblock_v5hdr_verify() -- verify the v5 fields of a short-format
   *				      btree block
@@@ -4283,19 -4617,19 +4331,29 @@@ xfs_btree_sblock_verify
  
  	/* numrecs verification */
  	if (be16_to_cpu(block->bb_numrecs) > max_recs)
- 		return false;
+ 		return __this_address;
  
  	/* sibling pointer verification */
++<<<<<<< HEAD
 +	if (!block->bb_u.s.bb_leftsib ||
 +	    (be32_to_cpu(block->bb_u.s.bb_leftsib) >= mp->m_sb.sb_agblocks &&
 +	     block->bb_u.s.bb_leftsib != cpu_to_be32(NULLAGBLOCK)))
 +		return false;
 +	if (!block->bb_u.s.bb_rightsib ||
 +	    (be32_to_cpu(block->bb_u.s.bb_rightsib) >= mp->m_sb.sb_agblocks &&
 +	     block->bb_u.s.bb_rightsib != cpu_to_be32(NULLAGBLOCK)))
 +		return false;
++=======
+ 	agno = xfs_daddr_to_agno(mp, XFS_BUF_ADDR(bp));
+ 	if (block->bb_u.s.bb_leftsib != cpu_to_be32(NULLAGBLOCK) &&
+ 	    !xfs_verify_agbno(mp, agno, be32_to_cpu(block->bb_u.s.bb_leftsib)))
+ 		return __this_address;
+ 	if (block->bb_u.s.bb_rightsib != cpu_to_be32(NULLAGBLOCK) &&
+ 	    !xfs_verify_agbno(mp, agno, be32_to_cpu(block->bb_u.s.bb_rightsib)))
+ 		return __this_address;
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  
- 	return true;
+ 	return NULL;
  }
  
  /*
diff --cc fs/xfs/libxfs/xfs_btree.h
index d81d6317f8d8,2f13b8676f41..000000000000
--- a/fs/xfs/libxfs/xfs_btree.h
+++ b/fs/xfs/libxfs/xfs_btree.h
@@@ -469,8 -492,14 +469,19 @@@ static inline int xfs_btree_get_level(s
  #define XFS_BTREE_TRACE_ARGR(c, r)
  #define	XFS_BTREE_TRACE_CURSOR(c, t)
  
++<<<<<<< HEAD
 +bool xfs_btree_sblock_v5hdr_verify(struct xfs_buf *bp);
 +bool xfs_btree_sblock_verify(struct xfs_buf *bp, unsigned int max_recs);
++=======
+ xfs_failaddr_t xfs_btree_sblock_v5hdr_verify(struct xfs_buf *bp);
+ xfs_failaddr_t xfs_btree_sblock_verify(struct xfs_buf *bp,
+ 		unsigned int max_recs);
+ xfs_failaddr_t xfs_btree_lblock_v5hdr_verify(struct xfs_buf *bp,
+ 		uint64_t owner);
+ xfs_failaddr_t xfs_btree_lblock_verify(struct xfs_buf *bp,
+ 		unsigned int max_recs);
+ 
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  uint xfs_btree_compute_maxlevels(struct xfs_mount *mp, uint *limits,
  				 unsigned long len);
  xfs_extlen_t xfs_btree_calc_size(struct xfs_mount *mp, uint *limits,
diff --cc fs/xfs/libxfs/xfs_da_btree.c
index 651611530d2f,60a2572ba4e3..000000000000
--- a/fs/xfs/libxfs/xfs_da_btree.c
+++ b/fs/xfs/libxfs/xfs_da_btree.c
@@@ -185,9 -185,8 +185,14 @@@ xfs_da3_node_write_verify
  	struct xfs_buf_log_item	*bip = bp->b_fspriv;
  	struct xfs_da3_node_hdr *hdr3 = bp->b_addr;
  
++<<<<<<< HEAD
 +	if (!xfs_da3_node_verify(bp)) {
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +		xfs_verifier_error(bp);
++=======
+ 	if (xfs_da3_node_verify(bp)) {
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  		return;
  	}
  
@@@ -220,10 -219,8 +225,15 @@@ xfs_da3_node_read_verify
  			}
  			/* fall through */
  		case XFS_DA_NODE_MAGIC:
++<<<<<<< HEAD
 +			if (!xfs_da3_node_verify(bp)) {
 +				xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +				break;
 +			}
++=======
+ 			if (xfs_da3_node_verify(bp))
+ 				xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  			return;
  		case XFS_ATTR_LEAF_MAGIC:
  		case XFS_ATTR3_LEAF_MAGIC:
diff --cc fs/xfs/libxfs/xfs_dir2_block.c
index e4272494b17f,3b728794659c..000000000000
--- a/fs/xfs/libxfs/xfs_dir2_block.c
+++ b/fs/xfs/libxfs/xfs_dir2_block.c
@@@ -89,12 -89,9 +89,18 @@@ xfs_dir3_block_read_verify
  
  	if (xfs_sb_version_hascrc(&mp->m_sb) &&
  	     !xfs_buf_verify_cksum(bp, XFS_DIR3_DATA_CRC_OFF))
++<<<<<<< HEAD
 +		xfs_buf_ioerror(bp, -EFSBADCRC);
 +	else if (!xfs_dir3_block_verify(bp))
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +
 +	if (bp->b_error)
 +		xfs_verifier_error(bp);
++=======
+ 		xfs_verifier_error(bp, -EFSBADCRC);
+ 	else if (xfs_dir3_block_verify(bp))
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  }
  
  static void
@@@ -105,9 -102,8 +111,14 @@@ xfs_dir3_block_write_verify
  	struct xfs_buf_log_item	*bip = bp->b_fspriv;
  	struct xfs_dir3_blk_hdr	*hdr3 = bp->b_addr;
  
++<<<<<<< HEAD
 +	if (!xfs_dir3_block_verify(bp)) {
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +		xfs_verifier_error(bp);
++=======
+ 	if (xfs_dir3_block_verify(bp)) {
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  		return;
  	}
  
diff --cc fs/xfs/libxfs/xfs_dir2_data.c
index af15f7052f3a,3eda2474ad0f..000000000000
--- a/fs/xfs/libxfs/xfs_dir2_data.c
+++ b/fs/xfs/libxfs/xfs_dir2_data.c
@@@ -280,13 -296,10 +297,20 @@@ xfs_dir3_data_read_verify
  	struct xfs_mount	*mp = bp->b_target->bt_mount;
  
  	if (xfs_sb_version_hascrc(&mp->m_sb) &&
++<<<<<<< HEAD
 +	     !xfs_buf_verify_cksum(bp, XFS_DIR3_DATA_CRC_OFF))
 +		 xfs_buf_ioerror(bp, -EFSBADCRC);
 +	else if (!xfs_dir3_data_verify(bp))
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +
 +	if (bp->b_error)
 +		xfs_verifier_error(bp);
++=======
+ 	    !xfs_buf_verify_cksum(bp, XFS_DIR3_DATA_CRC_OFF))
+ 		xfs_verifier_error(bp, -EFSBADCRC);
+ 	else if (xfs_dir3_data_verify(bp))
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  }
  
  static void
@@@ -297,9 -310,8 +321,14 @@@ xfs_dir3_data_write_verify
  	struct xfs_buf_log_item	*bip = bp->b_fspriv;
  	struct xfs_dir3_blk_hdr	*hdr3 = bp->b_addr;
  
++<<<<<<< HEAD
 +	if (!xfs_dir3_data_verify(bp)) {
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +		xfs_verifier_error(bp);
++=======
+ 	if (xfs_dir3_data_verify(bp)) {
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  		return;
  	}
  
diff --cc fs/xfs/libxfs/xfs_dir2_leaf.c
index 27297a689d9c,a8694860566b..000000000000
--- a/fs/xfs/libxfs/xfs_dir2_leaf.c
+++ b/fs/xfs/libxfs/xfs_dir2_leaf.c
@@@ -184,12 -193,9 +193,18 @@@ __read_verify
  
  	if (xfs_sb_version_hascrc(&mp->m_sb) &&
  	     !xfs_buf_verify_cksum(bp, XFS_DIR3_LEAF_CRC_OFF))
++<<<<<<< HEAD
 +		xfs_buf_ioerror(bp, -EFSBADCRC);
 +	else if (!xfs_dir3_leaf_verify(bp, magic))
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +
 +	if (bp->b_error)
 +		xfs_verifier_error(bp);
++=======
+ 		xfs_verifier_error(bp, -EFSBADCRC);
+ 	else if (xfs_dir3_leaf_verify(bp, magic))
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  }
  
  static void
@@@ -201,9 -207,8 +216,14 @@@ __write_verify
  	struct xfs_buf_log_item	*bip = bp->b_fspriv;
  	struct xfs_dir3_leaf_hdr *hdr3 = bp->b_addr;
  
++<<<<<<< HEAD
 +	if (!xfs_dir3_leaf_verify(bp, magic)) {
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +		xfs_verifier_error(bp);
++=======
+ 	if (xfs_dir3_leaf_verify(bp, magic)) {
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  		return;
  	}
  
diff --cc fs/xfs/libxfs/xfs_dir2_node.c
index 682e2bf370c7,051a21f3ad06..000000000000
--- a/fs/xfs/libxfs/xfs_dir2_node.c
+++ b/fs/xfs/libxfs/xfs_dir2_node.c
@@@ -118,12 -127,9 +127,18 @@@ xfs_dir3_free_read_verify
  
  	if (xfs_sb_version_hascrc(&mp->m_sb) &&
  	    !xfs_buf_verify_cksum(bp, XFS_DIR3_FREE_CRC_OFF))
++<<<<<<< HEAD
 +		xfs_buf_ioerror(bp, -EFSBADCRC);
 +	else if (!xfs_dir3_free_verify(bp))
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +
 +	if (bp->b_error)
 +		xfs_verifier_error(bp);
++=======
+ 		xfs_verifier_error(bp, -EFSBADCRC);
+ 	else if (xfs_dir3_free_verify(bp))
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  }
  
  static void
@@@ -134,9 -140,8 +149,14 @@@ xfs_dir3_free_write_verify
  	struct xfs_buf_log_item	*bip = bp->b_fspriv;
  	struct xfs_dir3_blk_hdr	*hdr3 = bp->b_addr;
  
++<<<<<<< HEAD
 +	if (!xfs_dir3_free_verify(bp)) {
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +		xfs_verifier_error(bp);
++=======
+ 	if (xfs_dir3_free_verify(bp)) {
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  		return;
  	}
  
@@@ -208,9 -213,8 +228,14 @@@ __xfs_dir3_free_read
  		return err;
  
  	/* Check things that we can't do in the verifier. */
++<<<<<<< HEAD
 +	if (!xfs_dir3_free_header_check(dp, fbno, *bpp)) {
 +		xfs_buf_ioerror(*bpp, -EFSCORRUPTED);
 +		xfs_verifier_error(*bpp);
++=======
+ 	if (xfs_dir3_free_header_check(dp, fbno, *bpp)) {
+ 		xfs_verifier_error(*bpp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  		xfs_trans_brelse(tp, *bpp);
  		return -EFSCORRUPTED;
  	}
diff --cc fs/xfs/libxfs/xfs_ialloc.c
index 8a6e2ce84589,f53f9bc486e8..000000000000
--- a/fs/xfs/libxfs/xfs_ialloc.c
+++ b/fs/xfs/libxfs/xfs_ialloc.c
@@@ -2540,13 -2544,10 +2540,18 @@@ xfs_agi_read_verify
  
  	if (xfs_sb_version_hascrc(&mp->m_sb) &&
  	    !xfs_buf_verify_cksum(bp, XFS_AGI_CRC_OFF))
++<<<<<<< HEAD
 +		xfs_buf_ioerror(bp, -EFSBADCRC);
 +	else if (XFS_TEST_ERROR(!xfs_agi_verify(bp), mp,
++=======
+ 		xfs_verifier_error(bp, -EFSBADCRC);
+ 	else if (XFS_TEST_ERROR(xfs_agi_verify(bp), mp,
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  				XFS_ERRTAG_IALLOC_READ_AGI))
 -		xfs_verifier_error(bp, -EFSCORRUPTED);
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +
 +	if (bp->b_error)
 +		xfs_verifier_error(bp);
  }
  
  static void
@@@ -2556,9 -2557,8 +2561,14 @@@ xfs_agi_write_verify
  	struct xfs_mount *mp = bp->b_target->bt_mount;
  	struct xfs_buf_log_item	*bip = bp->b_fspriv;
  
++<<<<<<< HEAD
 +	if (!xfs_agi_verify(bp)) {
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +		xfs_verifier_error(bp);
++=======
+ 	if (xfs_agi_verify(bp)) {
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  		return;
  	}
  
diff --cc fs/xfs/libxfs/xfs_ialloc_btree.c
index 65f87127fae3,8fe126bcc5bd..000000000000
--- a/fs/xfs/libxfs/xfs_ialloc_btree.c
+++ b/fs/xfs/libxfs/xfs_ialloc_btree.c
@@@ -199,7 -240,17 +199,21 @@@ xfs_inobt_key_diff
  			  cur->bc_rec.i.ir_startino;
  }
  
++<<<<<<< HEAD
 +static int
++=======
+ STATIC int64_t
+ xfs_inobt_diff_two_keys(
+ 	struct xfs_btree_cur	*cur,
+ 	union xfs_btree_key	*k1,
+ 	union xfs_btree_key	*k2)
+ {
+ 	return (int64_t)be32_to_cpu(k1->inobt.ir_startino) -
+ 			  be32_to_cpu(k2->inobt.ir_startino);
+ }
+ 
+ static xfs_failaddr_t
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  xfs_inobt_verify(
  	struct xfs_buf		*bp)
  {
@@@ -243,24 -296,21 +259,30 @@@ xfs_inobt_read_verify
  	struct xfs_buf	*bp)
  {
  	if (!xfs_btree_sblock_verify_crc(bp))
++<<<<<<< HEAD
 +		xfs_buf_ioerror(bp, -EFSBADCRC);
 +	else if (!xfs_inobt_verify(bp))
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
++=======
+ 		xfs_verifier_error(bp, -EFSBADCRC);
+ 	else if (xfs_inobt_verify(bp))
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  
 -	if (bp->b_error)
 +	if (bp->b_error) {
  		trace_xfs_btree_corrupt(bp, _RET_IP_);
 +		xfs_verifier_error(bp);
 +	}
  }
  
  static void
  xfs_inobt_write_verify(
  	struct xfs_buf	*bp)
  {
- 	if (!xfs_inobt_verify(bp)) {
+ 	if (xfs_inobt_verify(bp)) {
  		trace_xfs_btree_corrupt(bp, _RET_IP_);
 -		xfs_verifier_error(bp, -EFSCORRUPTED);
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +		xfs_verifier_error(bp);
  		return;
  	}
  	xfs_btree_sblock_calc_crc(bp);
diff --cc fs/xfs/libxfs/xfs_inode_buf.c
index 3aebe5129937,607dcca30668..000000000000
--- a/fs/xfs/libxfs/xfs_inode_buf.c
+++ b/fs/xfs/libxfs/xfs_inode_buf.c
@@@ -387,119 -388,54 +387,151 @@@ xfs_dinode_verify
  {
  	uint16_t		mode;
  	uint16_t		flags;
 -	uint64_t		flags2;
 +	uint64_t		di_size;
  
  	if (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))
- 		return false;
+ 		return __this_address;
  
  	/* don't allow invalid i_size */
++<<<<<<< HEAD
 +	di_size = be64_to_cpu(dip->di_size);
 +	if (di_size & (1ULL << 63))
 +		return false;
++=======
+ 	if (be64_to_cpu(dip->di_size) & (1ULL << 63))
+ 		return __this_address;
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  
  	mode = be16_to_cpu(dip->di_mode);
  	if (mode && xfs_mode_to_ftype(mode) == XFS_DIR3_FT_UNKNOWN)
- 		return false;
+ 		return __this_address;
  
  	/* No zero-length symlinks/dirs. */
++<<<<<<< HEAD
 +	if ((S_ISLNK(mode) || S_ISDIR(mode)) && di_size == 0)
 +		return false;
++=======
+ 	if ((S_ISLNK(mode) || S_ISDIR(mode)) && dip->di_size == 0)
+ 		return __this_address;
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
 +
 +	/* Fork checks carried over from xfs_iformat_fork */
 +	if (mode &&
 +	    be32_to_cpu(dip->di_nextents) + be16_to_cpu(dip->di_anextents) >
 +			be64_to_cpu(dip->di_nblocks))
 +		return false;
 +
 +	if (mode && XFS_DFORK_BOFF(dip) > mp->m_sb.sb_inodesize)
 +		return false;
 +
 +	flags = be16_to_cpu(dip->di_flags);
 +
 +	if (mode && (flags & XFS_DIFLAG_REALTIME) && !mp->m_rtdev_targp)
 +		return false;
 +
 +	/* Do we have appropriate data fork formats for the mode? */
 +	switch (mode & S_IFMT) {
 +	case S_IFIFO:
 +	case S_IFCHR:
 +	case S_IFBLK:
 +	case S_IFSOCK:
 +		if (dip->di_format != XFS_DINODE_FMT_DEV)
 +			return false;
 +		break;
 +	case S_IFREG:
 +	case S_IFLNK:
 +	case S_IFDIR:
 +		switch (dip->di_format) {
 +		case XFS_DINODE_FMT_LOCAL:
 +			/*
 +			 * no local regular files yet
 +			 */
 +			if (S_ISREG(mode))
 +				return false;
 +			if (di_size > XFS_DFORK_DSIZE(dip, mp))
 +				return false;
 +			if (dip->di_nextents)
 +				return false;
 +			/* fall through */
 +		case XFS_DINODE_FMT_EXTENTS:
 +		case XFS_DINODE_FMT_BTREE:
 +			break;
 +		default:
 +			return false;
 +		}
 +		break;
 +	case 0:
 +		/* Uninitialized inode ok. */
 +		break;
 +	default:
 +		return false;
 +	}
  
 +	if (XFS_DFORK_Q(dip)) {
 +		switch (dip->di_aformat) {
 +		case XFS_DINODE_FMT_LOCAL:
 +			if (dip->di_anextents)
 +				return false;
 +		/* fall through */
 +		case XFS_DINODE_FMT_EXTENTS:
 +		case XFS_DINODE_FMT_BTREE:
 +			break;
 +		default:
 +			return false;
 +		}
 +	} else {
 +		/*
 +		 * If there is no fork offset, this may be a freshly-made inode
 +		 * in a new disk cluster, in which case di_aformat is zeroed.
 +		 * Otherwise, such an inode must be in EXTENTS format; this goes
 +		 * for freed inodes as well.
 +		 */
 +		switch (dip->di_aformat) {
 +		case 0:
 +		case XFS_DINODE_FMT_EXTENTS:
 +			break;
 +		default:
 +			return false;
 +		}
 +		if (dip->di_anextents)
 +			return false;
 +	}
  	/* only version 3 or greater inodes are extensively verified here */
  	if (dip->di_version < 3)
- 		return true;
+ 		return NULL;
  
  	if (!xfs_sb_version_hascrc(&mp->m_sb))
- 		return false;
+ 		return __this_address;
  	if (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,
  			      XFS_DINODE_CRC_OFF))
- 		return false;
+ 		return __this_address;
  	if (be64_to_cpu(dip->di_ino) != ino)
- 		return false;
+ 		return __this_address;
  	if (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_uuid))
++<<<<<<< HEAD
 +		return false;
 +	return true;
++=======
+ 		return __this_address;
+ 
+ 	flags = be16_to_cpu(dip->di_flags);
+ 	flags2 = be64_to_cpu(dip->di_flags2);
+ 
+ 	/* don't allow reflink/cowextsize if we don't have reflink */
+ 	if ((flags2 & (XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)) &&
+             !xfs_sb_version_hasreflink(&mp->m_sb))
+ 		return __this_address;
+ 
+ 	/* don't let reflink and realtime mix */
+ 	if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags & XFS_DIFLAG_REALTIME))
+ 		return __this_address;
+ 
+ 	/* don't let reflink and dax mix */
+ 	if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags2 & XFS_DIFLAG2_DAX))
+ 		return __this_address;
+ 
+ 	return NULL;
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  }
  
  void
diff --cc fs/xfs/libxfs/xfs_symlink_remote.c
index c484877129a0,64db737c49d5..000000000000
--- a/fs/xfs/libxfs/xfs_symlink_remote.c
+++ b/fs/xfs/libxfs/xfs_symlink_remote.c
@@@ -135,12 -135,9 +135,18 @@@ xfs_symlink_read_verify
  		return;
  
  	if (!xfs_buf_verify_cksum(bp, XFS_SYMLINK_CRC_OFF))
++<<<<<<< HEAD
 +		xfs_buf_ioerror(bp, -EFSBADCRC);
 +	else if (!xfs_symlink_verify(bp))
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +
 +	if (bp->b_error)
 +		xfs_verifier_error(bp);
++=======
+ 		xfs_verifier_error(bp, -EFSBADCRC);
+ 	else if (xfs_symlink_verify(bp))
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  }
  
  static void
@@@ -154,9 -151,8 +160,14 @@@ xfs_symlink_write_verify
  	if (!xfs_sb_version_hascrc(&mp->m_sb))
  		return;
  
++<<<<<<< HEAD
 +	if (!xfs_symlink_verify(bp)) {
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +		xfs_verifier_error(bp);
++=======
+ 	if (xfs_symlink_verify(bp)) {
+ 		xfs_verifier_error(bp, -EFSCORRUPTED);
++>>>>>>> a6a781a58bef (xfs: have buffer verifier functions report failing address)
  		return;
  	}
  
* Unmerged path fs/xfs/libxfs/xfs_refcount_btree.c
* Unmerged path fs/xfs/libxfs/xfs_rmap_btree.c
* Unmerged path fs/xfs/scrub/inode.c
* Unmerged path fs/xfs/libxfs/xfs_alloc.c
* Unmerged path fs/xfs/libxfs/xfs_alloc_btree.c
* Unmerged path fs/xfs/libxfs/xfs_attr_leaf.c
* Unmerged path fs/xfs/libxfs/xfs_attr_remote.c
* Unmerged path fs/xfs/libxfs/xfs_bmap_btree.c
* Unmerged path fs/xfs/libxfs/xfs_btree.c
* Unmerged path fs/xfs/libxfs/xfs_btree.h
* Unmerged path fs/xfs/libxfs/xfs_da_btree.c
* Unmerged path fs/xfs/libxfs/xfs_dir2_block.c
* Unmerged path fs/xfs/libxfs/xfs_dir2_data.c
* Unmerged path fs/xfs/libxfs/xfs_dir2_leaf.c
* Unmerged path fs/xfs/libxfs/xfs_dir2_node.c
diff --git a/fs/xfs/libxfs/xfs_dir2_priv.h b/fs/xfs/libxfs/xfs_dir2_priv.h
index 0bf55bcf18e9..229135358e46 100644
--- a/fs/xfs/libxfs/xfs_dir2_priv.h
+++ b/fs/xfs/libxfs/xfs_dir2_priv.h
@@ -39,18 +39,13 @@ extern int xfs_dir2_leaf_to_block(struct xfs_da_args *args,
 
 /* xfs_dir2_data.c */
 #ifdef DEBUG
-#define	xfs_dir3_data_check(dp, bp) \
-do { \
-	if (!__xfs_dir3_data_check((dp), (bp))) { \
-		XFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, \
-				(bp)->b_target->bt_mount, (bp)->b_addr); \
-	} \
-} while (0)
+extern void xfs_dir3_data_check(struct xfs_inode *dp, struct xfs_buf *bp);
 #else
 #define	xfs_dir3_data_check(dp,bp)
 #endif
 
-extern bool __xfs_dir3_data_check(struct xfs_inode *dp, struct xfs_buf *bp);
+extern xfs_failaddr_t __xfs_dir3_data_check(struct xfs_inode *dp,
+		struct xfs_buf *bp);
 extern int xfs_dir3_data_read(struct xfs_trans *tp, struct xfs_inode *dp,
 		xfs_dablk_t bno, xfs_daddr_t mapped_bno, struct xfs_buf **bpp);
 extern int xfs_dir3_data_readahead(struct xfs_inode *dp, xfs_dablk_t bno,
@@ -95,8 +90,9 @@ xfs_dir3_leaf_find_entry(struct xfs_dir3_icleaf_hdr *leafhdr,
 		int lowstale, int highstale, int *lfloglow, int *lfloghigh);
 extern int xfs_dir2_node_to_leaf(struct xfs_da_state *state);
 
-extern bool xfs_dir3_leaf_check_int(struct xfs_mount *mp, struct xfs_inode *dp,
-		struct xfs_dir3_icleaf_hdr *hdr, struct xfs_dir2_leaf *leaf);
+extern xfs_failaddr_t xfs_dir3_leaf_check_int(struct xfs_mount *mp,
+		struct xfs_inode *dp, struct xfs_dir3_icleaf_hdr *hdr,
+		struct xfs_dir2_leaf *leaf);
 
 /* xfs_dir2_node.c */
 extern int xfs_dir2_leaf_to_node(struct xfs_da_args *args,
* Unmerged path fs/xfs/libxfs/xfs_ialloc.c
* Unmerged path fs/xfs/libxfs/xfs_ialloc_btree.c
* Unmerged path fs/xfs/libxfs/xfs_inode_buf.c
diff --git a/fs/xfs/libxfs/xfs_inode_buf.h b/fs/xfs/libxfs/xfs_inode_buf.h
index 63e2323f2ff7..afe80545e8fa 100644
--- a/fs/xfs/libxfs/xfs_inode_buf.h
+++ b/fs/xfs/libxfs/xfs_inode_buf.h
@@ -81,7 +81,7 @@ void	xfs_inobp_check(struct xfs_mount *, struct xfs_buf *);
 #define	xfs_inobp_check(mp, bp)
 #endif /* DEBUG */
 
-bool	xfs_dinode_verify(struct xfs_mount *mp, xfs_ino_t ino,
-			  struct xfs_dinode *dip);
+xfs_failaddr_t xfs_dinode_verify(struct xfs_mount *mp, xfs_ino_t ino,
+			   struct xfs_dinode *dip);
 
 #endif	/* __XFS_INODE_BUF_H__ */
* Unmerged path fs/xfs/libxfs/xfs_refcount_btree.c
* Unmerged path fs/xfs/libxfs/xfs_rmap_btree.c
* Unmerged path fs/xfs/libxfs/xfs_symlink_remote.c
* Unmerged path fs/xfs/scrub/inode.c
