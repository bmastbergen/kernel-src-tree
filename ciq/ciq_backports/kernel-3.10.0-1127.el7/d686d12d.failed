xfs: don't assert fail with AIL lock held

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit d686d12d23ae1a6a5a52ad2f794f3955985fd54d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/d686d12d.failed

Been hitting AIL ordering assert failures recently, but been unable
to trace them down because the system immediately hangs up onteh
spinlock that was held when this assert fires:

XFS: Assertion failed: XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) <= 0, file: fs/xfs/xfs_trans_ail.c, line: 52

Move the assertions outside of the spinlock so the corpse can
be dissected. Thanks to Brian Foster for supplying a clean
way of doing this.

Signed-Off-By: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit d686d12d23ae1a6a5a52ad2f794f3955985fd54d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_trans_ail.c
diff --cc fs/xfs/xfs_trans_ail.c
index cef89f7127d3,41e280ef1483..000000000000
--- a/fs/xfs/xfs_trans_ail.c
+++ b/fs/xfs/xfs_trans_ail.c
@@@ -35,27 -41,42 +41,53 @@@
   */
  STATIC void
  xfs_ail_check(
- 	struct xfs_ail	*ailp,
- 	xfs_log_item_t	*lip)
+ 	struct xfs_ail		*ailp,
+ 	struct xfs_log_item	*lip)
  {
- 	xfs_log_item_t	*prev_lip;
+ 	struct xfs_log_item	*prev_lip;
+ 	struct xfs_log_item	*next_lip;
+ 	xfs_lsn_t		prev_lsn = NULLCOMMITLSN;
+ 	xfs_lsn_t		next_lsn = NULLCOMMITLSN;
+ 	xfs_lsn_t		lsn;
+ 	bool			in_ail;
+ 
  
 -	if (list_empty(&ailp->ail_head))
 +	if (list_empty(&ailp->xa_ail))
  		return;
  
  	/*
- 	 * Check the next and previous entries are valid.
+ 	 * Sample then check the next and previous entries are valid.
  	 */
++<<<<<<< HEAD
 +	ASSERT((lip->li_flags & XFS_LI_IN_AIL) != 0);
 +	prev_lip = list_entry(lip->li_ail.prev, xfs_log_item_t, li_ail);
 +	if (&prev_lip->li_ail != &ailp->xa_ail)
 +		ASSERT(XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) <= 0);
 +
 +	prev_lip = list_entry(lip->li_ail.next, xfs_log_item_t, li_ail);
 +	if (&prev_lip->li_ail != &ailp->xa_ail)
 +		ASSERT(XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) >= 0);
++=======
+ 	in_ail = test_bit(XFS_LI_IN_AIL, &lip->li_flags);
+ 	prev_lip = list_entry(lip->li_ail.prev, struct xfs_log_item, li_ail);
+ 	if (&prev_lip->li_ail != &ailp->ail_head)
+ 		prev_lsn = prev_lip->li_lsn;
+ 	next_lip = list_entry(lip->li_ail.next, struct xfs_log_item, li_ail);
+ 	if (&next_lip->li_ail != &ailp->ail_head)
+ 		next_lsn = next_lip->li_lsn;
+ 	lsn = lip->li_lsn;
++>>>>>>> d686d12d23ae (xfs: don't assert fail with AIL lock held)
  
+ 	if (in_ail &&
+ 	    (prev_lsn == NULLCOMMITLSN || XFS_LSN_CMP(prev_lsn, lsn) <= 0) &&
+ 	    (next_lsn == NULLCOMMITLSN || XFS_LSN_CMP(next_lsn, lsn) >= 0))
+ 		return;
  
+ 	spin_unlock(&ailp->ail_lock);
+ 	ASSERT(in_ail);
+ 	ASSERT(prev_lsn == NULLCOMMITLSN || XFS_LSN_CMP(prev_lsn, lsn) <= 0);
+ 	ASSERT(next_lsn == NULLCOMMITLSN || XFS_LSN_CMP(next_lsn, lsn) >= 0);
+ 	spin_lock(&ailp->ail_lock);
  }
  #else /* !DEBUG */
  #define	xfs_ail_check(a,l)
* Unmerged path fs/xfs/xfs_trans_ail.c
