x86/topology: Create topology_max_die_per_package()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Len Brown <len.brown@intel.com>
commit 14d96d6c06b5d8116b8d52c9c5530f5528ef1e61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/14d96d6c.failed

topology_max_packages() is available to size resources to cover all
packages in the system.

But now multi-die/package systems are coming up, and some resources are
per-die.

Create topology_max_die_per_package(), for detecting multi-die/package
systems, and sizing any per-die resources.

	Signed-off-by: Len Brown <len.brown@intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Ingo Molnar <mingo@kernel.org>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/e6eaf384571ae52ac7d0ca41510b7fb7d2fda0e4.1557769318.git.len.brown@intel.com

(cherry picked from commit 14d96d6c06b5d8116b8d52c9c5530f5528ef1e61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/processor.h
#	arch/x86/kernel/cpu/topology.c
diff --cc arch/x86/include/asm/processor.h
index 004d7b98c9bf,7c17343946dd..000000000000
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@@ -125,7 -102,10 +125,11 @@@ struct cpuinfo_x86 
  	int			x86_power;
  	unsigned long		loops_per_jiffy;
  	/* cpuid returned max cores value: */
++<<<<<<< HEAD
 +	u16			 x86_max_cores;
++=======
+ 	u16			x86_max_cores;
++>>>>>>> 14d96d6c06b5 (x86/topology: Create topology_max_die_per_package())
  	u16			apicid;
  	u16			initial_apicid;
  	u16			x86_clflush_size;
diff --cc arch/x86/kernel/cpu/topology.c
index 5cadd3be250a,ee48c3fc8a65..000000000000
--- a/arch/x86/kernel/cpu/topology.c
+++ b/arch/x86/kernel/cpu/topology.c
@@@ -21,6 -25,43 +21,46 @@@
  #define BITS_SHIFT_NEXT_LEVEL(eax)	((eax) & 0x1f)
  #define LEVEL_MAX_SIBLINGS(ebx)		((ebx) & 0xffff)
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_SMP
+ unsigned int __max_die_per_package __read_mostly = 1;
+ EXPORT_SYMBOL(__max_die_per_package);
+ 
+ /*
+  * Check if given CPUID extended toplogy "leaf" is implemented
+  */
+ static int check_extended_topology_leaf(int leaf)
+ {
+ 	unsigned int eax, ebx, ecx, edx;
+ 
+ 	cpuid_count(leaf, SMT_LEVEL, &eax, &ebx, &ecx, &edx);
+ 
+ 	if (ebx == 0 || (LEAFB_SUBTYPE(ecx) != SMT_TYPE))
+ 		return -1;
+ 
+ 	return 0;
+ }
+ /*
+  * Return best CPUID Extended Toplogy Leaf supported
+  */
+ static int detect_extended_topology_leaf(struct cpuinfo_x86 *c)
+ {
+ 	if (c->cpuid_level >= 0x1f) {
+ 		if (check_extended_topology_leaf(0x1f) == 0)
+ 			return 0x1f;
+ 	}
+ 
+ 	if (c->cpuid_level >= 0xb) {
+ 		if (check_extended_topology_leaf(0xb) == 0)
+ 			return 0xb;
+ 	}
+ 
+ 	return -1;
+ }
+ #endif
+ 
++>>>>>>> 14d96d6c06b5 (x86/topology: Create topology_max_die_per_package())
  int detect_extended_topology_early(struct cpuinfo_x86 *c)
  {
  #ifdef CONFIG_SMP
@@@ -97,6 -149,7 +137,10 @@@ int detect_extended_topology(struct cpu
  	c->apicid = apic->phys_pkg_id(c->initial_apicid, 0);
  
  	c->x86_max_cores = (core_level_siblings / smp_num_siblings);
++<<<<<<< HEAD
++=======
+ 	__max_die_per_package = (die_level_siblings / core_level_siblings);
++>>>>>>> 14d96d6c06b5 (x86/topology: Create topology_max_die_per_package())
  #endif
  	return 0;
  }
* Unmerged path arch/x86/include/asm/processor.h
diff --git a/arch/x86/include/asm/topology.h b/arch/x86/include/asm/topology.h
index bd6fba2c0523..702e991402b4 100644
--- a/arch/x86/include/asm/topology.h
+++ b/arch/x86/include/asm/topology.h
@@ -132,6 +132,13 @@ extern const struct cpumask *cpu_coregroup_mask(int cpu);
 extern unsigned int __max_logical_packages;
 #define topology_max_packages()			(__max_logical_packages)
 
+extern unsigned int __max_die_per_package;
+
+static inline int topology_max_die_per_package(void)
+{
+	return __max_die_per_package;
+}
+
 extern int __max_smt_threads;
 
 static inline int topology_max_smt_threads(void)
@@ -148,6 +155,9 @@ bool topology_smt_supported(void);
 static inline int
 topology_update_package_map(unsigned int apicid, unsigned int cpu) { return 0; }
 static inline int topology_phys_to_logical_pkg(unsigned int pkg) { return 0; }
+static inline int topology_phys_to_logical_die(unsigned int die,
+		unsigned int cpu) { return 0; }
+static inline int topology_max_die_per_package(void) { return 1; }
 static inline int topology_max_smt_threads(void) { return 1; }
 static inline bool topology_is_primary_thread(unsigned int cpu) { return true; }
 static inline bool topology_smt_supported(void) { return false; }
* Unmerged path arch/x86/kernel/cpu/topology.c
