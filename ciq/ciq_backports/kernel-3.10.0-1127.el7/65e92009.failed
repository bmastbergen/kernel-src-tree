scsi: qla2xxx: Fix device connect issues in P2P configuration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Arun Easi <aeasi@marvell.com>
commit 65e9200938052ce90f24421bb057e1be1d6147c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/65e92009.failed

P2P needs to take the alternate plogi route.

Link: https://lore.kernel.org/r/20191105150657.8092-8-hmadhani@marvell.com
	Reviewed-by: Ewan D. Milne <emilne@redhat.com>
	Signed-off-by: Arun Easi <aeasi@marvell.com>
	Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 65e9200938052ce90f24421bb057e1be1d6147c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_iocb.c
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index 7a7063b47932,5b163ad85c34..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -894,4 -914,8 +894,10 @@@ void qlt_remove_target_resources(struc
  void qlt_set_mode(struct scsi_qla_host *);
  int qla2x00_set_data_rate(scsi_qla_host_t *vha, uint16_t mode);
  
++<<<<<<< HEAD
++=======
+ /* nvme.c */
+ void qla_nvme_unregister_remote_port(struct fc_port *fcport);
+ void qla_handle_els_plogi_done(scsi_qla_host_t *vha, struct event_arg *ea);
++>>>>>>> 65e920093805 (scsi: qla2xxx: Fix device connect issues in P2P configuration)
  #endif /* _QLA_GBL_H */
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 66fd59075b91,6bb4ddd90b6e..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -1683,8 -1717,7 +1683,12 @@@ void qla24xx_handle_relogin_event(scsi_
  	qla24xx_fcport_handle_login(vha, fcport);
  }
  
++<<<<<<< HEAD
 +
 +static void qla_handle_els_plogi_done(scsi_qla_host_t *vha,
++=======
+ void qla_handle_els_plogi_done(scsi_qla_host_t *vha,
++>>>>>>> 65e920093805 (scsi: qla2xxx: Fix device connect issues in P2P configuration)
  				      struct event_arg *ea)
  {
  	ql_dbg(ql_dbg_disc, vha, 0x2118,
@@@ -1693,78 -1726,6 +1697,81 @@@
  	qla24xx_post_prli_work(vha, ea->fcport);
  }
  
++<<<<<<< HEAD
 +void qla2x00_fcport_event_handler(scsi_qla_host_t *vha, struct event_arg *ea)
 +{
 +	fc_port_t *fcport;
 +
 +	switch (ea->event) {
 +	case FCME_RELOGIN:
 +		if (test_bit(UNLOADING, &vha->dpc_flags))
 +			return;
 +
 +		qla24xx_handle_relogin_event(vha, ea);
 +		break;
 +	case FCME_RSCN:
 +		if (test_bit(UNLOADING, &vha->dpc_flags))
 +			return;
 +		{
 +			unsigned long flags;
 +			fcport = qla2x00_find_fcport_by_nportid
 +				(vha, &ea->id, 1);
 +			if (fcport) {
 +				fcport->scan_needed = 1;
 +				fcport->rscn_gen++;
 +			}
 +
 +			spin_lock_irqsave(&vha->work_lock, flags);
 +			if (vha->scan.scan_flags == 0) {
 +				ql_dbg(ql_dbg_disc, vha, 0xffff,
 +				    "%s: schedule\n", __func__);
 +				vha->scan.scan_flags |= SF_QUEUED;
 +				schedule_delayed_work(&vha->scan.scan_work, 5);
 +			}
 +			spin_unlock_irqrestore(&vha->work_lock, flags);
 +		}
 +		break;
 +	case FCME_GNL_DONE:
 +		qla24xx_handle_gnl_done_event(vha, ea);
 +		break;
 +	case FCME_GPSC_DONE:
 +		qla24xx_handle_gpsc_event(vha, ea);
 +		break;
 +	case FCME_PLOGI_DONE:	/* Initiator side sent LLIOCB */
 +		qla24xx_handle_plogi_done_event(vha, ea);
 +		break;
 +	case FCME_PRLI_DONE:
 +		qla24xx_handle_prli_done_event(vha, ea);
 +		break;
 +	case FCME_GPDB_DONE:
 +		qla24xx_handle_gpdb_event(vha, ea);
 +		break;
 +	case FCME_GPNID_DONE:
 +		qla24xx_handle_gpnid_event(vha, ea);
 +		break;
 +	case FCME_GFFID_DONE:
 +		qla24xx_handle_gffid_event(vha, ea);
 +		break;
 +	case FCME_ADISC_DONE:
 +		qla24xx_handle_adisc_event(vha, ea);
 +		break;
 +	case FCME_GNNID_DONE:
 +		qla24xx_handle_gnnid_event(vha, ea);
 +		break;
 +	case FCME_GFPNID_DONE:
 +		qla24xx_handle_gfpnid_event(vha, ea);
 +		break;
 +	case FCME_ELS_PLOGI_DONE:
 +		qla_handle_els_plogi_done(vha, ea);
 +		break;
 +	default:
 +		BUG_ON(1);
 +		break;
 +	}
 +}
 +
++=======
++>>>>>>> 65e920093805 (scsi: qla2xxx: Fix device connect issues in P2P configuration)
  /*
   * RSCN(s) came in for this fcport, but the RSCN(s) was not able
   * to be consumed by the fcport
diff --cc drivers/scsi/qla2xxx/qla_iocb.c
index 347a91c0bc3a,b25f87ff8cde..000000000000
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@@ -2861,8 -2761,95 +2861,100 @@@ qla2x00_els_dcmd2_sp_done(void *ptr, in
  			memset(&ea, 0, sizeof(ea));
  			ea.fcport = fcport;
  			ea.rc = res;
++<<<<<<< HEAD
 +			ea.event = FCME_ELS_PLOGI_DONE;
 +			qla2x00_fcport_event_handler(vha, &ea);
++=======
+ 			qla_handle_els_plogi_done(vha, &ea);
+ 			break;
+ 
+ 		case CS_IOCB_ERROR:
+ 			switch (fw_status[1]) {
+ 			case LSC_SCODE_PORTID_USED:
+ 				lid = fw_status[2] & 0xffff;
+ 				qlt_find_sess_invalidate_other(vha,
+ 				    wwn_to_u64(fcport->port_name),
+ 				    fcport->d_id, lid, &conflict_fcport);
+ 				if (conflict_fcport) {
+ 					/*
+ 					 * Another fcport shares the same
+ 					 * loop_id & nport id; conflict
+ 					 * fcport needs to finish cleanup
+ 					 * before this fcport can proceed
+ 					 * to login.
+ 					 */
+ 					conflict_fcport->conflict = fcport;
+ 					fcport->login_pause = 1;
+ 					ql_dbg(ql_dbg_disc, vha, 0x20ed,
+ 					    "%s %d %8phC pid %06x inuse with lid %#x post gidpn\n",
+ 					    __func__, __LINE__,
+ 					    fcport->port_name,
+ 					    fcport->d_id.b24, lid);
+ 				} else {
+ 					ql_dbg(ql_dbg_disc, vha, 0x20ed,
+ 					    "%s %d %8phC pid %06x inuse with lid %#x sched del\n",
+ 					    __func__, __LINE__,
+ 					    fcport->port_name,
+ 					    fcport->d_id.b24, lid);
+ 					qla2x00_clear_loop_id(fcport);
+ 					set_bit(lid, vha->hw->loop_id_map);
+ 					fcport->loop_id = lid;
+ 					fcport->keep_nport_handle = 0;
+ 					qlt_schedule_sess_for_deletion(fcport);
+ 				}
+ 				break;
+ 
+ 			case LSC_SCODE_NPORT_USED:
+ 				cid.b.domain = (fw_status[2] >> 16) & 0xff;
+ 				cid.b.area   = (fw_status[2] >>  8) & 0xff;
+ 				cid.b.al_pa  = fw_status[2] & 0xff;
+ 				cid.b.rsvd_1 = 0;
+ 
+ 				ql_dbg(ql_dbg_disc, vha, 0x20ec,
+ 				    "%s %d %8phC lid %#x in use with pid %06x post gnl\n",
+ 				    __func__, __LINE__, fcport->port_name,
+ 				    fcport->loop_id, cid.b24);
+ 				set_bit(fcport->loop_id,
+ 				    vha->hw->loop_id_map);
+ 				fcport->loop_id = FC_NO_LOOP_ID;
+ 				qla24xx_post_gnl_work(vha, fcport);
+ 				break;
+ 
+ 			case LSC_SCODE_NOXCB:
+ 				vha->hw->exch_starvation++;
+ 				if (vha->hw->exch_starvation > 5) {
+ 					ql_log(ql_log_warn, vha, 0xd046,
+ 					    "Exchange starvation. Resetting RISC\n");
+ 					vha->hw->exch_starvation = 0;
+ 					set_bit(ISP_ABORT_NEEDED,
+ 					    &vha->dpc_flags);
+ 					qla2xxx_wake_dpc(vha);
+ 				}
+ 				/* fall through */
+ 			default:
+ 				ql_dbg(ql_dbg_disc, vha, 0x20eb,
+ 				    "%s %8phC cmd error fw_status 0x%x 0x%x 0x%x\n",
+ 				    __func__, sp->fcport->port_name,
+ 				    fw_status[0], fw_status[1], fw_status[2]);
+ 
+ 				fcport->flags &= ~FCF_ASYNC_SENT;
+ 				fcport->disc_state = DSC_LOGIN_FAILED;
+ 				set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 				break;
+ 			}
+ 			break;
+ 
+ 		default:
+ 			ql_dbg(ql_dbg_disc, vha, 0x20eb,
+ 			    "%s %8phC cmd error 2 fw_status 0x%x 0x%x 0x%x\n",
+ 			    __func__, sp->fcport->port_name,
+ 			    fw_status[0], fw_status[1], fw_status[2]);
+ 
+ 			sp->fcport->flags &= ~FCF_ASYNC_SENT;
+ 			sp->fcport->disc_state = DSC_LOGIN_FAILED;
+ 			set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 			break;
++>>>>>>> 65e920093805 (scsi: qla2xxx: Fix device connect issues in P2P configuration)
  		}
  
  		e = qla2x00_alloc_work(vha, QLA_EVT_UNMAP);
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
* Unmerged path drivers/scsi/qla2xxx/qla_iocb.c
