net: udp: fix handling of CHECKSUM_COMPLETE packets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [net] udp: fix handling of CHECKSUM_COMPLETE packets (Davide Caratti) [1657877]
Rebuild_FUZZ: 94.85%
commit-author Sean Tranchetti <stranche@codeaurora.org>
commit db4f1be3ca9b0ef7330763d07bf4ace83ad6f913
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/db4f1be3.failed

Current handling of CHECKSUM_COMPLETE packets by the UDP stack is
incorrect for any packet that has an incorrect checksum value.

udp4/6_csum_init() will both make a call to
__skb_checksum_validate_complete() to initialize/validate the csum
field when receiving a CHECKSUM_COMPLETE packet. When this packet
fails validation, skb->csum will be overwritten with the pseudoheader
checksum so the packet can be fully validated by software, but the
skb->ip_summed value will be left as CHECKSUM_COMPLETE so that way
the stack can later warn the user about their hardware spewing bad
checksums. Unfortunately, leaving the SKB in this state can cause
problems later on in the checksum calculation.

Since the the packet is still marked as CHECKSUM_COMPLETE,
udp_csum_pull_header() will SUBTRACT the checksum of the UDP header
from skb->csum instead of adding it, leaving us with a garbage value
in that field. Once we try to copy the packet to userspace in the
udp4/6_recvmsg(), we'll make a call to skb_copy_and_csum_datagram_msg()
to checksum the packet data and add it in the garbage skb->csum value
to perform our final validation check.

Since the value we're validating is not the proper checksum, it's possible
that the folded value could come out to 0, causing us not to drop the
packet. Instead, we believe that the packet was checksummed incorrectly
by hardware since skb->ip_summed is still CHECKSUM_COMPLETE, and we attempt
to warn the user with netdev_rx_csum_fault(skb->dev);

Unfortunately, since this is the UDP path, skb->dev has been overwritten
by skb->dev_scratch and is no longer a valid pointer, so we end up
reading invalid memory.

This patch addresses this problem in two ways:
	1) Do not use the dev pointer when calling netdev_rx_csum_fault()
	   from skb_copy_and_csum_datagram_msg(). Since this gets called
	   from the UDP path where skb->dev has been overwritten, we have
	   no way of knowing if the pointer is still valid. Also for the
	   sake of consistency with the other uses of
	   netdev_rx_csum_fault(), don't attempt to call it if the
	   packet was checksummed by software.

	2) Add better CHECKSUM_COMPLETE handling to udp4/6_csum_init().
	   If we receive a packet that's CHECKSUM_COMPLETE that fails
	   verification (i.e. skb->csum_valid == 0), check who performed
	   the calculation. It's possible that the checksum was done in
	   software by the network stack earlier (such as Netfilter's
	   CONNTRACK module), and if that says the checksum is bad,
	   we can drop the packet immediately instead of waiting until
	   we try and copy it to userspace. Otherwise, we need to
	   mark the SKB as CHECKSUM_NONE, since the skb->csum field
	   no longer contains the full packet checksum after the
	   call to __skb_checksum_validate_complete().

Fixes: e6afc8ace6dd ("udp: remove headers from UDP packets before queueing")
Fixes: c84d949057ca ("udp: copy skb->truesize in the first cache line")
	Cc: Sam Kumar <samanthakumar@google.com>
	Cc: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Sean Tranchetti <stranche@codeaurora.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit db4f1be3ca9b0ef7330763d07bf4ace83ad6f913)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/datagram.c
diff --cc net/core/datagram.c
index 29a309afc82d,57f3a6fcfc1e..000000000000
--- a/net/core/datagram.c
+++ b/net/core/datagram.c
@@@ -818,19 -799,20 +818,31 @@@ int skb_copy_and_csum_datagram_iovec(st
  			goto fault;
  	} else {
  		csum = csum_partial(skb->data, hlen, skb->csum);
 -		if (skb_copy_and_csum_datagram(skb, hlen, &msg->msg_iter,
 +		if (skb_copy_and_csum_datagram(skb, hlen, iov->iov_base,
  					       chunk, &csum))
  			goto fault;
++<<<<<<< HEAD
 +		if (csum_fold(csum))
 +			goto csum_error;
 +		if (unlikely(skb->ip_summed == CHECKSUM_COMPLETE))
 +			netdev_rx_csum_fault(skb->dev);
 +		iov->iov_len -= chunk;
 +		iov->iov_base += chunk;
++=======
+ 
+ 		if (csum_fold(csum)) {
+ 			iov_iter_revert(&msg->msg_iter, chunk);
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (unlikely(skb->ip_summed == CHECKSUM_COMPLETE) &&
+ 		    !skb->csum_complete_sw)
+ 			netdev_rx_csum_fault(NULL);
++>>>>>>> db4f1be3ca9b (net: udp: fix handling of CHECKSUM_COMPLETE packets)
  	}
  	return 0;
 +csum_error:
 +	return -EINVAL;
  fault:
  	return -EFAULT;
  }
* Unmerged path net/core/datagram.c
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index b5f283c34d45..48c062dd9b05 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -1884,8 +1884,24 @@ static inline int udp4_csum_init(struct sk_buff *skb, struct udphdr *uh,
 	/* Note, we are only interested in != 0 or == 0, thus the
 	 * force to int.
 	 */
-	return (__force int)skb_checksum_init_zero_check(skb, proto, uh->check,
-							 inet_compute_pseudo);
+	err = (__force int)skb_checksum_init_zero_check(skb, proto, uh->check,
+							inet_compute_pseudo);
+	if (err)
+		return err;
+
+	if (skb->ip_summed == CHECKSUM_COMPLETE && !skb->csum_valid) {
+		/* If SW calculated the value, we know it's bad */
+		if (skb->csum_complete_sw)
+			return 1;
+
+		/* HW says the value is bad. Let's validate that.
+		 * skb->csum is no longer the full packet checksum,
+		 * so don't treat it as such.
+		 */
+		skb_checksum_complete_unset(skb);
+	}
+
+	return 0;
 }
 
 /*
diff --git a/net/ipv6/ip6_checksum.c b/net/ipv6/ip6_checksum.c
index c6359b7a2d0c..da99167e63d3 100644
--- a/net/ipv6/ip6_checksum.c
+++ b/net/ipv6/ip6_checksum.c
@@ -83,8 +83,24 @@ int udp6_csum_init(struct sk_buff *skb, struct udphdr *uh, int proto)
 	 * Note, we are only interested in != 0 or == 0, thus the
 	 * force to int.
 	 */
-	return (__force int)skb_checksum_init_zero_check(skb, proto, uh->check,
-							 ip6_compute_pseudo);
+	err = (__force int)skb_checksum_init_zero_check(skb, proto, uh->check,
+							ip6_compute_pseudo);
+	if (err)
+		return err;
+
+	if (skb->ip_summed == CHECKSUM_COMPLETE && !skb->csum_valid) {
+		/* If SW calculated the value, we know it's bad */
+		if (skb->csum_complete_sw)
+			return 1;
+
+		/* HW says the value is bad. Let's validate that.
+		 * skb->csum is no longer the full packet checksum,
+		 * so don't treat is as such.
+		 */
+		skb_checksum_complete_unset(skb);
+	}
+
+	return 0;
 }
 EXPORT_SYMBOL(udp6_csum_init);
 
