mm: charge/uncharge kmemcg from generic page allocator paths

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Vladimir Davydov <vdavydov@virtuozzo.com>
commit 4949148ad433f6f11cf837978b2907092ec99f3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/4949148a.failed

Currently, to charge a non-slab allocation to kmemcg one has to use
alloc_kmem_pages helper with __GFP_ACCOUNT flag.  A page allocated with
this helper should finally be freed using free_kmem_pages, otherwise it
won't be uncharged.

This API suits its current users fine, but it turns out to be impossible
to use along with page reference counting, i.e.  when an allocation is
supposed to be freed with put_page, as it is the case with pipe or unix
socket buffers.

To overcome this limitation, this patch moves charging/uncharging to
generic page allocator paths, i.e.  to __alloc_pages_nodemask and
free_pages_prepare, and zaps alloc/free_kmem_pages helpers.  This way,
one can use any of the available page allocation functions to get the
allocated page charged to kmemcg - it's enough to pass __GFP_ACCOUNT,
just like in case of kmalloc and friends.  A charged page will be
automatically uncharged on free.

To make it possible, we need to mark pages charged to kmemcg somehow.
To avoid introducing a new page flag, we make use of page->_mapcount for
marking such pages.  Since pages charged to kmemcg are not supposed to
be mapped to userspace, it should work just fine.  There are other
(ab)users of page->_mapcount - buddy and balloon pages - but we don't
conflict with them.

In case kmemcg is compiled out or not used at runtime, this patch
introduces no overhead to generic page allocator paths.  If kmemcg is
used, it will be plus one gfp flags check on alloc and plus one
page->_mapcount check on free, which shouldn't hurt performance, because
the data accessed are hot.

Link: http://lkml.kernel.org/r/a9736d856f895bcb465d9f257b54efe32eda6f99.1464079538.git.vdavydov@virtuozzo.com
	Signed-off-by: Vladimir Davydov <vdavydov@virtuozzo.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Eric Dumazet <eric.dumazet@gmail.com>
	Cc: Minchan Kim <minchan@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 4949148ad433f6f11cf837978b2907092ec99f3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/gfp.h
#	include/linux/page-flags.h
#	kernel/fork.c
#	mm/page_alloc.c
#	mm/slab_common.c
#	mm/slub.c
#	mm/vmalloc.c
diff --cc include/linux/gfp.h
index b4194f05bfaa,c29e9d347bc6..000000000000
--- a/include/linux/gfp.h
+++ b/include/linux/gfp.h
@@@ -55,118 -53,220 +55,195 @@@ struct vm_area_struct
  #define __GFP_DMA	((__force gfp_t)___GFP_DMA)
  #define __GFP_HIGHMEM	((__force gfp_t)___GFP_HIGHMEM)
  #define __GFP_DMA32	((__force gfp_t)___GFP_DMA32)
 -#define __GFP_MOVABLE	((__force gfp_t)___GFP_MOVABLE)  /* ZONE_MOVABLE allowed */
 +#define __GFP_MOVABLE	((__force gfp_t)___GFP_MOVABLE)  /* Page is movable */
  #define GFP_ZONEMASK	(__GFP_DMA|__GFP_HIGHMEM|__GFP_DMA32|__GFP_MOVABLE)
 -
  /*
++<<<<<<< HEAD
 + * Action modifiers - doesn't change the zoning
++=======
+  * Page mobility and placement hints
+  *
+  * These flags provide hints about how mobile the page is. Pages with similar
+  * mobility are placed within the same pageblocks to minimise problems due
+  * to external fragmentation.
+  *
+  * __GFP_MOVABLE (also a zone modifier) indicates that the page can be
+  *   moved by page migration during memory compaction or can be reclaimed.
+  *
+  * __GFP_RECLAIMABLE is used for slab allocations that specify
+  *   SLAB_RECLAIM_ACCOUNT and whose pages can be freed via shrinkers.
+  *
+  * __GFP_WRITE indicates the caller intends to dirty the page. Where possible,
+  *   these pages will be spread between local zones to avoid all the dirty
+  *   pages being in one zone (fair zone allocation policy).
+  *
+  * __GFP_HARDWALL enforces the cpuset memory allocation policy.
+  *
+  * __GFP_THISNODE forces the allocation to be satisified from the requested
+  *   node with no fallbacks or placement policy enforcements.
+  *
+  * __GFP_ACCOUNT causes the allocation to be accounted to kmemcg.
+  */
+ #define __GFP_RECLAIMABLE ((__force gfp_t)___GFP_RECLAIMABLE)
+ #define __GFP_WRITE	((__force gfp_t)___GFP_WRITE)
+ #define __GFP_HARDWALL   ((__force gfp_t)___GFP_HARDWALL)
+ #define __GFP_THISNODE	((__force gfp_t)___GFP_THISNODE)
+ #define __GFP_ACCOUNT	((__force gfp_t)___GFP_ACCOUNT)
+ 
+ /*
+  * Watermark modifiers -- controls access to emergency reserves
+  *
+  * __GFP_HIGH indicates that the caller is high-priority and that granting
+  *   the request is necessary before the system can make forward progress.
+  *   For example, creating an IO context to clean pages.
+  *
+  * __GFP_ATOMIC indicates that the caller cannot reclaim or sleep and is
+  *   high priority. Users are typically interrupt handlers. This may be
+  *   used in conjunction with __GFP_HIGH
+  *
+  * __GFP_MEMALLOC allows access to all memory. This should only be used when
+  *   the caller guarantees the allocation will allow more memory to be freed
+  *   very shortly e.g. process exiting or swapping. Users either should
+  *   be the MM or co-ordinating closely with the VM (e.g. swap over NFS).
+  *
+  * __GFP_NOMEMALLOC is used to explicitly forbid access to emergency reserves.
+  *   This takes precedence over the __GFP_MEMALLOC flag if both are set.
+  */
+ #define __GFP_ATOMIC	((__force gfp_t)___GFP_ATOMIC)
+ #define __GFP_HIGH	((__force gfp_t)___GFP_HIGH)
+ #define __GFP_MEMALLOC	((__force gfp_t)___GFP_MEMALLOC)
+ #define __GFP_NOMEMALLOC ((__force gfp_t)___GFP_NOMEMALLOC)
+ 
+ /*
+  * Reclaim modifiers
+  *
+  * __GFP_IO can start physical IO.
+  *
+  * __GFP_FS can call down to the low-level FS. Clearing the flag avoids the
+  *   allocator recursing into the filesystem which might already be holding
+  *   locks.
+  *
+  * __GFP_DIRECT_RECLAIM indicates that the caller may enter direct reclaim.
+  *   This flag can be cleared to avoid unnecessary delays when a fallback
+  *   option is available.
+  *
+  * __GFP_KSWAPD_RECLAIM indicates that the caller wants to wake kswapd when
+  *   the low watermark is reached and have it reclaim pages until the high
+  *   watermark is reached. A caller may wish to clear this flag when fallback
+  *   options are available and the reclaim is likely to disrupt the system. The
+  *   canonical example is THP allocation where a fallback is cheap but
+  *   reclaim/compaction may cause indirect stalls.
+  *
+  * __GFP_RECLAIM is shorthand to allow/forbid both direct and kswapd reclaim.
++>>>>>>> 4949148ad433 (mm: charge/uncharge kmemcg from generic page allocator paths)
   *
   * __GFP_REPEAT: Try hard to allocate the memory, but the allocation attempt
 - *   _might_ fail.  This depends upon the particular VM implementation.
 + * _might_ fail.  This depends upon the particular VM implementation.
   *
   * __GFP_NOFAIL: The VM implementation _must_ retry infinitely: the caller
 - *   cannot handle allocation failures. New users should be evaluated carefully
 - *   (and the flag should be used only when there is no reasonable failure
 - *   policy) but it is definitely preferable to use the flag rather than
 - *   opencode endless loop around allocator.
 + * cannot handle allocation failures.  This modifier is deprecated and no new
 + * users should be added.
 + *
 + * __GFP_NORETRY: The VM implementation must not retry indefinitely.
   *
 - * __GFP_NORETRY: The VM implementation must not retry indefinitely and will
 - *   return NULL when direct reclaim and memory compaction have failed to allow
 - *   the allocation to succeed.  The OOM killer is not called with the current
 - *   implementation.
 + * __GFP_MOVABLE: Flag that this page will be movable by the page migration
 + * mechanism or reclaimed
   */
 -#define __GFP_IO	((__force gfp_t)___GFP_IO)
 -#define __GFP_FS	((__force gfp_t)___GFP_FS)
 -#define __GFP_DIRECT_RECLAIM	((__force gfp_t)___GFP_DIRECT_RECLAIM) /* Caller can reclaim */
 -#define __GFP_KSWAPD_RECLAIM	((__force gfp_t)___GFP_KSWAPD_RECLAIM) /* kswapd can wake */
 -#define __GFP_RECLAIM ((__force gfp_t)(___GFP_DIRECT_RECLAIM|___GFP_KSWAPD_RECLAIM))
 -#define __GFP_REPEAT	((__force gfp_t)___GFP_REPEAT)
 -#define __GFP_NOFAIL	((__force gfp_t)___GFP_NOFAIL)
 -#define __GFP_NORETRY	((__force gfp_t)___GFP_NORETRY)
 +#define __GFP_WAIT	((__force gfp_t)___GFP_WAIT)	/* Can wait and reschedule? */
 +#define __GFP_HIGH	((__force gfp_t)___GFP_HIGH)	/* Should access emergency pools? */
 +#define __GFP_IO	((__force gfp_t)___GFP_IO)	/* Can start physical IO? */
 +#define __GFP_FS	((__force gfp_t)___GFP_FS)	/* Can call down to low-level FS? */
 +#define __GFP_COLD	((__force gfp_t)___GFP_COLD)	/* Cache-cold page required */
 +#define __GFP_NOWARN	((__force gfp_t)___GFP_NOWARN)	/* Suppress page allocation failure warning */
 +#define __GFP_REPEAT	((__force gfp_t)___GFP_REPEAT)	/* See above */
 +#define __GFP_NOFAIL	((__force gfp_t)___GFP_NOFAIL)	/* See above */
 +#define __GFP_NORETRY	((__force gfp_t)___GFP_NORETRY) /* See above */
 +#define __GFP_MEMALLOC	((__force gfp_t)___GFP_MEMALLOC)/* Allow access to emergency reserves */
 +#define __GFP_COMP	((__force gfp_t)___GFP_COMP)	/* Add compound page metadata */
 +#define __GFP_ZERO	((__force gfp_t)___GFP_ZERO)	/* Return zeroed page on success */
 +#define __GFP_NOMEMALLOC ((__force gfp_t)___GFP_NOMEMALLOC) /* Don't use emergency reserves.
 +							 * This takes precedence over the
 +							 * __GFP_MEMALLOC flag if both are
 +							 * set
 +							 */
 +#define __GFP_HARDWALL   ((__force gfp_t)___GFP_HARDWALL) /* Enforce hardwall cpuset memory allocs */
 +#define __GFP_THISNODE	((__force gfp_t)___GFP_THISNODE)/* No fallback, no policies */
 +#define __GFP_RECLAIMABLE ((__force gfp_t)___GFP_RECLAIMABLE) /* Page is reclaimable */
 +#define __GFP_NOTRACK	((__force gfp_t)___GFP_NOTRACK)  /* Don't track with kmemcheck */
 +
 +#define __GFP_NO_KSWAPD	((__force gfp_t)___GFP_NO_KSWAPD)
 +#define __GFP_OTHER_NODE ((__force gfp_t)___GFP_OTHER_NODE) /* On behalf of other node */
 +#define __GFP_KMEMCG	((__force gfp_t)___GFP_KMEMCG) /* Allocation comes from a memcg-accounted resource */
 +#define __GFP_WRITE	((__force gfp_t)___GFP_WRITE)	/* Allocator intends to dirty page */
  
  /*
 - * Action modifiers
 - *
 - * __GFP_COLD indicates that the caller does not expect to be used in the near
 - *   future. Where possible, a cache-cold page will be returned.
 - *
 - * __GFP_NOWARN suppresses allocation failure reports.
 - *
 - * __GFP_COMP address compound page metadata.
 - *
 - * __GFP_ZERO returns a zeroed page on success.
 - *
 - * __GFP_NOTRACK avoids tracking with kmemcheck.
 - *
 - * __GFP_NOTRACK_FALSE_POSITIVE is an alias of __GFP_NOTRACK. It's a means of
 - *   distinguishing in the source between false positives and allocations that
 - *   cannot be supported (e.g. page tables).
 - *
 - * __GFP_OTHER_NODE is for allocations that are on a remote node but that
 - *   should not be accounted for as a remote allocation in vmstat. A
 - *   typical user would be khugepaged collapsing a huge page on a remote
 - *   node.
 + * This may seem redundant, but it's a way of annotating false positives vs.
 + * allocations that simply cannot be supported (e.g. page tables).
   */
 -#define __GFP_COLD	((__force gfp_t)___GFP_COLD)
 -#define __GFP_NOWARN	((__force gfp_t)___GFP_NOWARN)
 -#define __GFP_COMP	((__force gfp_t)___GFP_COMP)
 -#define __GFP_ZERO	((__force gfp_t)___GFP_ZERO)
 -#define __GFP_NOTRACK	((__force gfp_t)___GFP_NOTRACK)
  #define __GFP_NOTRACK_FALSE_POSITIVE (__GFP_NOTRACK)
 -#define __GFP_OTHER_NODE ((__force gfp_t)___GFP_OTHER_NODE)
  
 -/* Room for N __GFP_FOO bits */
 -#define __GFP_BITS_SHIFT 26
 +#define __GFP_BITS_SHIFT 25	/* Room for N __GFP_FOO bits */
  #define __GFP_BITS_MASK ((__force gfp_t)((1 << __GFP_BITS_SHIFT) - 1))
  
 +/* This equals 0, but use constants in case they ever change */
 +#define GFP_NOWAIT	(GFP_ATOMIC & ~__GFP_HIGH)
 +/* GFP_ATOMIC means both !wait (__GFP_WAIT not set) and use emergency pool */
 +#define GFP_ATOMIC	(__GFP_HIGH)
 +#define GFP_NOIO	(__GFP_WAIT)
 +#define GFP_NOFS	(__GFP_WAIT | __GFP_IO)
 +#define GFP_KERNEL	(__GFP_WAIT | __GFP_IO | __GFP_FS)
 +#define GFP_TEMPORARY	(__GFP_WAIT | __GFP_IO | __GFP_FS | \
 +			 __GFP_RECLAIMABLE)
 +#define GFP_USER	(__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HARDWALL)
 +#define GFP_HIGHUSER	(__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HARDWALL | \
 +			 __GFP_HIGHMEM)
 +#define GFP_HIGHUSER_MOVABLE	(__GFP_WAIT | __GFP_IO | __GFP_FS | \
 +				 __GFP_HARDWALL | __GFP_HIGHMEM | \
 +				 __GFP_MOVABLE)
 +#define GFP_IOFS	(__GFP_IO | __GFP_FS)
 +#define GFP_TRANSHUGE	(GFP_HIGHUSER_MOVABLE | __GFP_COMP | \
 +			 __GFP_NOMEMALLOC | __GFP_NORETRY | __GFP_NOWARN | \
 +			 __GFP_NO_KSWAPD)
 +
  /*
 - * Useful GFP flag combinations that are commonly used. It is recommended
 - * that subsystems start with one of these combinations and then set/clear
 - * __GFP_FOO flags as necessary.
 - *
 - * GFP_ATOMIC users can not sleep and need the allocation to succeed. A lower
 - *   watermark is applied to allow access to "atomic reserves"
 - *
 - * GFP_KERNEL is typical for kernel-internal allocations. The caller requires
 - *   ZONE_NORMAL or a lower zone for direct access but can direct reclaim.
 - *
 - * GFP_KERNEL_ACCOUNT is the same as GFP_KERNEL, except the allocation is
 - *   accounted to kmemcg.
 - *
 - * GFP_NOWAIT is for kernel allocations that should not stall for direct
 - *   reclaim, start physical IO or use any filesystem callback.
 - *
 - * GFP_NOIO will use direct reclaim to discard clean pages or slab pages
 - *   that do not require the starting of any physical IO.
 - *
 - * GFP_NOFS will use direct reclaim but will not use any filesystem interfaces.
 - *
 - * GFP_USER is for userspace allocations that also need to be directly
 - *   accessibly by the kernel or hardware. It is typically used by hardware
 - *   for buffers that are mapped to userspace (e.g. graphics) that hardware
 - *   still must DMA to. cpuset limits are enforced for these allocations.
 - *
 - * GFP_DMA exists for historical reasons and should be avoided where possible.
 - *   The flags indicates that the caller requires that the lowest zone be
 - *   used (ZONE_DMA or 16M on x86-64). Ideally, this would be removed but
 - *   it would require careful auditing as some users really require it and
 - *   others use the flag to avoid lowmem reserves in ZONE_DMA and treat the
 - *   lowest zone as a type of emergency reserve.
 - *
 - * GFP_DMA32 is similar to GFP_DMA except that the caller requires a 32-bit
 - *   address.
 - *
 - * GFP_HIGHUSER is for userspace allocations that may be mapped to userspace,
 - *   do not need to be directly accessible by the kernel but that cannot
 - *   move once in use. An example may be a hardware allocation that maps
 - *   data directly into userspace but has no addressing limitations.
 - *
 - * GFP_HIGHUSER_MOVABLE is for userspace allocations that the kernel does not
 - *   need direct access to but can use kmap() when access is required. They
 - *   are expected to be movable via page reclaim or page migration. Typically,
 - *   pages on the LRU would also be allocated with GFP_HIGHUSER_MOVABLE.
 - *
 - * GFP_TRANSHUGE is used for THP allocations. They are compound allocations
 - *   that will fail quickly if memory is not available and will not wake
 - *   kswapd on failure.
 + * GFP_THISNODE does not perform any reclaim, you most likely want to
 + * use __GFP_THISNODE to allocate from a given node without fallback!
   */
 -#define GFP_ATOMIC	(__GFP_HIGH|__GFP_ATOMIC|__GFP_KSWAPD_RECLAIM)
 -#define GFP_KERNEL	(__GFP_RECLAIM | __GFP_IO | __GFP_FS)
 -#define GFP_KERNEL_ACCOUNT (GFP_KERNEL | __GFP_ACCOUNT)
 -#define GFP_NOWAIT	(__GFP_KSWAPD_RECLAIM)
 -#define GFP_NOIO	(__GFP_RECLAIM)
 -#define GFP_NOFS	(__GFP_RECLAIM | __GFP_IO)
 -#define GFP_TEMPORARY	(__GFP_RECLAIM | __GFP_IO | __GFP_FS | \
 -			 __GFP_RECLAIMABLE)
 -#define GFP_USER	(__GFP_RECLAIM | __GFP_IO | __GFP_FS | __GFP_HARDWALL)
 +#ifdef CONFIG_NUMA
 +#define GFP_THISNODE	(__GFP_THISNODE | __GFP_NOWARN | __GFP_NORETRY)
 +#else
 +#define GFP_THISNODE	((__force gfp_t)0)
 +#endif
 +
 +/* This mask makes up all the page movable related flags */
 +#define GFP_MOVABLE_MASK (__GFP_RECLAIMABLE|__GFP_MOVABLE)
 +
 +/* Control page allocator reclaim behavior */
 +#define GFP_RECLAIM_MASK (__GFP_WAIT|__GFP_HIGH|__GFP_IO|__GFP_FS|\
 +			__GFP_NOWARN|__GFP_REPEAT|__GFP_NOFAIL|\
 +			__GFP_NORETRY|__GFP_MEMALLOC|__GFP_NOMEMALLOC)
 +
 +/* Control slab gfp mask during early boot */
 +#define GFP_BOOT_MASK (__GFP_BITS_MASK & ~(__GFP_WAIT|__GFP_IO|__GFP_FS))
 +
 +/* Control allocation constraints */
 +#define GFP_CONSTRAINT_MASK (__GFP_HARDWALL|__GFP_THISNODE)
 +
 +/* Do not use these with a slab allocator */
 +#define GFP_SLAB_BUG_MASK (__GFP_DMA32|__GFP_HIGHMEM|~__GFP_BITS_MASK)
 +
 +/* Flag - indicates that the buffer will be suitable for DMA.  Ignored on some
 +   platforms, used as appropriate on others */
 +
  #define GFP_DMA		__GFP_DMA
 +
 +/* 4GB DMA on some platforms */
  #define GFP_DMA32	__GFP_DMA32
 -#define GFP_HIGHUSER	(GFP_USER | __GFP_HIGHMEM)
 -#define GFP_HIGHUSER_MOVABLE	(GFP_HIGHUSER | __GFP_MOVABLE)
 -#define GFP_TRANSHUGE	((GFP_HIGHUSER_MOVABLE | __GFP_COMP | \
 -			 __GFP_NOMEMALLOC | __GFP_NORETRY | __GFP_NOWARN) & \
 -			 ~__GFP_RECLAIM)
  
  /* Convert GFP flags to their corresponding migrate type */
 -#define GFP_MOVABLE_MASK (__GFP_RECLAIMABLE|__GFP_MOVABLE)
 -#define GFP_MOVABLE_SHIFT 3
 -
  static inline int gfpflags_to_migratetype(const gfp_t gfp_flags)
  {
 -	VM_WARN_ON((gfp_flags & GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK);
 -	BUILD_BUG_ON((1UL << GFP_MOVABLE_SHIFT) != ___GFP_MOVABLE);
 -	BUILD_BUG_ON((___GFP_MOVABLE >> GFP_MOVABLE_SHIFT) != MIGRATE_MOVABLE);
 +	WARN_ON((gfp_flags & GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK);
  
  	if (unlikely(page_group_by_mobility_disabled))
  		return MIGRATE_UNMOVABLE;
@@@ -394,14 -504,10 +471,17 @@@ extern void free_hot_cold_page(struct p
  extern void free_hot_cold_page_list(struct list_head *list, bool cold);
  
  struct page_frag_cache;
 -extern void *__alloc_page_frag(struct page_frag_cache *nc,
 -			       unsigned int fragsz, gfp_t gfp_mask);
 -extern void __free_page_frag(void *addr);
 +extern void __page_frag_cache_drain(struct page *page, unsigned int count);
 +extern void *page_frag_alloc(struct page_frag_cache *nc,
 +			     unsigned int fragsz, gfp_t gfp_mask);
 +extern void page_frag_free(void *addr);
  
++<<<<<<< HEAD
 +extern void __free_memcg_kmem_pages(struct page *page, unsigned int order);
 +extern void free_memcg_kmem_pages(unsigned long addr, unsigned int order);
 +
++=======
++>>>>>>> 4949148ad433 (mm: charge/uncharge kmemcg from generic page allocator paths)
  #define __free_page(page) __free_pages((page), 0)
  #define free_page(addr) free_pages((addr), 0)
  
diff --cc include/linux/page-flags.h
index a685f4913207,7c8e82ac2eb7..000000000000
--- a/include/linux/page-flags.h
+++ b/include/linux/page-flags.h
@@@ -577,14 -642,15 +577,26 @@@ PAGE_MAPCOUNT_OPS(Buddy, BUDDY
  PAGE_MAPCOUNT_OPS(Balloon, BALLOON)
  
  /*
++<<<<<<< HEAD
 + * PageOffline() indicates that the page is logically offline although the
 + * containing section is online. (e.g. inflated in a balloon driver or
 + * not onlined when onlining the section).
 + * The content of these pages is effectively stale. Such pages should not
 + * be touched (read/write/dump/save) except by their owner.
 + */
 +#define PAGE_OFFLINE_MAPCOUNT_VALUE		(-512)
 +PAGE_MAPCOUNT_OPS(Offline, OFFLINE)
++=======
+  * If kmemcg is enabled, the buddy allocator will set PageKmemcg() on
+  * pages allocated with __GFP_ACCOUNT. It gets cleared on page free.
+  */
+ #define PAGE_KMEMCG_MAPCOUNT_VALUE		(-512)
+ PAGE_MAPCOUNT_OPS(Kmemcg, KMEMCG)
+ 
+ extern bool is_free_buddy_page(struct page *page);
+ 
+ __PAGEFLAG(Isolated, isolated, PF_ANY);
++>>>>>>> 4949148ad433 (mm: charge/uncharge kmemcg from generic page allocator paths)
  
  /*
   * If network-based swap is enabled, sl*b must keep track of whether pages
diff --cc kernel/fork.c
index 350a3225b39e,de21f25e0d2c..000000000000
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@@ -180,38 -159,46 +180,55 @@@ void __weak arch_release_thread_info(st
   * kmemcache based allocator.
   */
  # if THREAD_SIZE >= PAGE_SIZE
 -static unsigned long *alloc_thread_stack_node(struct task_struct *tsk,
 +static struct thread_info *alloc_thread_info_node(struct task_struct *tsk,
  						  int node)
  {
++<<<<<<< HEAD
 +	struct page *page = alloc_pages_node(node, THREADINFO_GFP_ACCOUNTED,
 +					     THREAD_SIZE_ORDER);
++=======
+ 	struct page *page = alloc_pages_node(node, THREADINFO_GFP,
+ 					     THREAD_SIZE_ORDER);
+ 
+ 	if (page)
+ 		memcg_kmem_update_page_stat(page, MEMCG_KERNEL_STACK,
+ 					    1 << THREAD_SIZE_ORDER);
++>>>>>>> 4949148ad433 (mm: charge/uncharge kmemcg from generic page allocator paths)
  
  	return page ? page_address(page) : NULL;
  }
  
 -static inline void free_thread_stack(unsigned long *stack)
 +static inline void free_thread_info(struct thread_info *ti)
  {
++<<<<<<< HEAD
 +	free_memcg_kmem_pages((unsigned long)ti, THREAD_SIZE_ORDER);
++=======
+ 	struct page *page = virt_to_page(stack);
+ 
+ 	memcg_kmem_update_page_stat(page, MEMCG_KERNEL_STACK,
+ 				    -(1 << THREAD_SIZE_ORDER));
+ 	__free_pages(page, THREAD_SIZE_ORDER);
++>>>>>>> 4949148ad433 (mm: charge/uncharge kmemcg from generic page allocator paths)
  }
  # else
 -static struct kmem_cache *thread_stack_cache;
 +static struct kmem_cache *thread_info_cache;
  
 -static unsigned long *alloc_thread_stack_node(struct task_struct *tsk,
 +static struct thread_info *alloc_thread_info_node(struct task_struct *tsk,
  						  int node)
  {
 -	return kmem_cache_alloc_node(thread_stack_cache, THREADINFO_GFP, node);
 +	return kmem_cache_alloc_node(thread_info_cache, THREADINFO_GFP, node);
  }
  
 -static void free_thread_stack(unsigned long *stack)
 +static void free_thread_info(struct thread_info *ti)
  {
 -	kmem_cache_free(thread_stack_cache, stack);
 +	kmem_cache_free(thread_info_cache, ti);
  }
  
 -void thread_stack_cache_init(void)
 +void thread_info_cache_init(void)
  {
 -	thread_stack_cache = kmem_cache_create("thread_stack", THREAD_SIZE,
 +	thread_info_cache = kmem_cache_create("thread_info", THREAD_SIZE,
  					      THREAD_SIZE, 0, NULL);
 -	BUG_ON(thread_stack_cache == NULL);
 +	BUG_ON(thread_info_cache == NULL);
  }
  # endif
  #endif
diff --cc mm/page_alloc.c
index 10b3d04ee8fe,7023a31edc5c..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -62,8 -61,9 +62,12 @@@
  #include <linux/page_ext.h>
  #include <linux/hugetlb.h>
  #include <linux/sched/rt.h>
 -#include <linux/page_owner.h>
  #include <linux/kthread.h>
++<<<<<<< HEAD
 +#include <linux/nmi.h>
++=======
+ #include <linux/memcontrol.h>
++>>>>>>> 4949148ad433 (mm: charge/uncharge kmemcg from generic page allocator paths)
  
  #include <asm/sections.h>
  #include <asm/tlbflush.h>
@@@ -797,17 -920,153 +801,97 @@@ static inline int free_pages_check(stru
  		bad_reason = "PAGE_FLAGS_CHECK_AT_FREE flag(s) set";
  		bad_flags = PAGE_FLAGS_CHECK_AT_FREE;
  	}
 -#ifdef CONFIG_MEMCG
 -	if (unlikely(page->mem_cgroup))
 -		bad_reason = "page still charged to cgroup";
 -#endif
 -	bad_page(page, bad_reason, bad_flags);
 -}
 -
 -static inline int free_pages_check(struct page *page)
 -{
 -	if (likely(page_expected_state(page, PAGE_FLAGS_CHECK_AT_FREE)))
 -		return 0;
 -
 -	/* Something has gone sideways, find it */
 -	free_pages_check_bad(page);
 -	return 1;
 -}
 -
 -static int free_tail_pages_check(struct page *head_page, struct page *page)
 -{
 -	int ret = 1;
 -
 -	/*
 -	 * We rely page->lru.next never has bit 0 set, unless the page
 -	 * is PageTail(). Let's make sure that's true even for poisoned ->lru.
 -	 */
 -	BUILD_BUG_ON((unsigned long)LIST_POISON1 & 1);
 -
 -	if (!IS_ENABLED(CONFIG_DEBUG_VM)) {
 -		ret = 0;
 -		goto out;
 +	if (unlikely(mem_cgroup_bad_page_check(page)))
 +		bad_reason = "cgroup check failed";
 +	if (unlikely(bad_reason)) {
 +		bad_page(page, bad_reason, bad_flags);
 +		return 1;
  	}
++<<<<<<< HEAD
++=======
+ 	switch (page - head_page) {
+ 	case 1:
+ 		/* the first tail page: ->mapping is compound_mapcount() */
+ 		if (unlikely(compound_mapcount(page))) {
+ 			bad_page(page, "nonzero compound_mapcount", 0);
+ 			goto out;
+ 		}
+ 		break;
+ 	case 2:
+ 		/*
+ 		 * the second tail page: ->mapping is
+ 		 * page_deferred_list().next -- ignore value.
+ 		 */
+ 		break;
+ 	default:
+ 		if (page->mapping != TAIL_MAPPING) {
+ 			bad_page(page, "corrupted mapping in tail page", 0);
+ 			goto out;
+ 		}
+ 		break;
+ 	}
+ 	if (unlikely(!PageTail(page))) {
+ 		bad_page(page, "PageTail not set", 0);
+ 		goto out;
+ 	}
+ 	if (unlikely(compound_head(page) != head_page)) {
+ 		bad_page(page, "compound_head not consistent", 0);
+ 		goto out;
+ 	}
+ 	ret = 0;
+ out:
+ 	page->mapping = NULL;
+ 	clear_compound_head(page);
+ 	return ret;
+ }
+ 
+ static __always_inline bool free_pages_prepare(struct page *page,
+ 					unsigned int order, bool check_free)
+ {
+ 	int bad = 0;
+ 
+ 	VM_BUG_ON_PAGE(PageTail(page), page);
+ 
+ 	trace_mm_page_free(page, order);
+ 	kmemcheck_free_shadow(page, order);
+ 
+ 	/*
+ 	 * Check tail pages before head page information is cleared to
+ 	 * avoid checking PageCompound for order-0 pages.
+ 	 */
+ 	if (unlikely(order)) {
+ 		bool compound = PageCompound(page);
+ 		int i;
+ 
+ 		VM_BUG_ON_PAGE(compound && compound_order(page) != order, page);
+ 
+ 		for (i = 1; i < (1 << order); i++) {
+ 			if (compound)
+ 				bad += free_tail_pages_check(page, page + i);
+ 			if (unlikely(free_pages_check(page + i))) {
+ 				bad++;
+ 				continue;
+ 			}
+ 			(page + i)->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;
+ 		}
+ 	}
+ 	if (PageMappingFlags(page))
+ 		page->mapping = NULL;
+ 	if (memcg_kmem_enabled() && PageKmemcg(page)) {
+ 		memcg_kmem_uncharge(page, order);
+ 		__ClearPageKmemcg(page);
+ 	}
+ 	if (check_free)
+ 		bad += free_pages_check(page);
+ 	if (bad)
+ 		return false;
+ 
++>>>>>>> 4949148ad433 (mm: charge/uncharge kmemcg from generic page allocator paths)
  	page_cpupid_reset_last(page);
 -	page->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;
 -	reset_page_owner(page, order);
 -
 -	if (!PageHighMem(page)) {
 -		debug_check_no_locks_freed(page_address(page),
 -					   PAGE_SIZE << order);
 -		debug_check_no_obj_freed(page_address(page),
 -					   PAGE_SIZE << order);
 -	}
 -	arch_free_page(page, order);
 -	kernel_poison_pages(page, 1 << order, 0);
 -	kernel_map_pages(page, 1 << order, 0);
 -	kasan_free_pages(page, order);
 -
 -	return true;
 -}
 -
 -#ifdef CONFIG_DEBUG_VM
 -static inline bool free_pcp_prepare(struct page *page)
 -{
 -	return free_pages_prepare(page, 0, true);
 -}
 -
 -static inline bool bulkfree_pcp_prepare(struct page *page)
 -{
 -	return false;
 -}
 -#else
 -static bool free_pcp_prepare(struct page *page)
 -{
 -	return free_pages_prepare(page, 0, false);
 -}
 -
 -static bool bulkfree_pcp_prepare(struct page *page)
 -{
 -	return free_pages_check(page);
 +	if (page->flags & PAGE_FLAGS_CHECK_AT_PREP)
 +		page->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;
 +	return 0;
  }
 -#endif /* CONFIG_DEBUG_VM */
  
  /*
   * Frees a number of pages from the PCP lists
@@@ -3471,10 -3840,24 +3555,26 @@@ out
  	 * the mask is being updated. If a page allocation is about to fail,
  	 * check if the cpuset changed during allocation and if so, retry.
  	 */
 -	if (unlikely(!page && read_mems_allowed_retry(cpuset_mems_cookie))) {
 -		alloc_mask = gfp_mask;
 +	if (unlikely(!page && read_mems_allowed_retry(cpuset_mems_cookie)))
  		goto retry_cpuset;
 -	}
  
++<<<<<<< HEAD
 +	memcg_kmem_commit_charge(page, memcg, order);
++=======
+ out:
+ 	if (memcg_kmem_enabled() && (gfp_mask & __GFP_ACCOUNT) && page) {
+ 		if (unlikely(memcg_kmem_charge(page, gfp_mask, order))) {
+ 			__free_pages(page, order);
+ 			page = NULL;
+ 		} else
+ 			__SetPageKmemcg(page);
+ 	}
+ 
+ 	if (kmemcheck_enabled && page)
+ 		kmemcheck_pagealloc_alloc(page, order, gfp_mask);
+ 
+ 	trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);
++>>>>>>> 4949148ad433 (mm: charge/uncharge kmemcg from generic page allocator paths)
  
  	return page;
  }
@@@ -3639,65 -4007,10 +3739,70 @@@ void page_frag_free(void *addr
  	if (unlikely(put_page_testzero(page)))
  		__free_pages_ok(page, compound_order(page));
  }
 -EXPORT_SYMBOL(__free_page_frag);
 +EXPORT_SYMBOL(page_frag_free);
 +
++<<<<<<< HEAD
 +/*
 + * alloc_kmem_pages charges newly allocated pages to the kmem resource counter
 + * of the current memory cgroup.
 + *
 + * It should be used when the caller would like to use kmalloc, but since the
 + * allocation is large, it has to fall back to the page allocator.
 + */
 +struct page *alloc_kmem_pages(gfp_t gfp_mask, unsigned int order)
 +{
 +	struct page *page;
 +	struct mem_cgroup *memcg = NULL;
 +
 +	if (!memcg_kmem_newpage_charge(gfp_mask, &memcg, order))
 +		return NULL;
 +	page = alloc_pages(gfp_mask, order);
 +	memcg_kmem_commit_charge(page, memcg, order);
 +	return page;
 +}
 +
 +struct page *alloc_kmem_pages_node(int nid, gfp_t gfp_mask, unsigned int order)
 +{
 +	struct page *page;
 +	struct mem_cgroup *memcg = NULL;
 +
 +	if (!memcg_kmem_newpage_charge(gfp_mask, &memcg, order))
 +		return NULL;
 +	page = alloc_pages_node(nid, gfp_mask, order);
 +	memcg_kmem_commit_charge(page, memcg, order);
 +	return page;
 +}
 +
 +/*
 + * __free_memcg_kmem_pages and free_memcg_kmem_pages will free
 + * pages allocated with __GFP_KMEMCG.
 + *
 + * Those pages are accounted to a particular memcg, embedded in the
 + * corresponding page_cgroup. To avoid adding a hit in the allocator to search
 + * for that information only to find out that it is NULL for users who have no
 + * interest in that whatsoever, we provide these functions.
 + *
 + * The caller knows better which flags it relies on.
 + */
 +void __free_memcg_kmem_pages(struct page *page, unsigned int order)
 +{
 +	memcg_kmem_uncharge_pages(page, order);
 +	__free_pages(page, order);
 +}
 +
 +void free_memcg_kmem_pages(unsigned long addr, unsigned int order)
 +{
 +	if (addr != 0) {
 +		VM_BUG_ON(!virt_addr_valid((void *)addr));
 +		__free_memcg_kmem_pages(virt_to_page((void *)addr), order);
 +	}
 +}
  
 +static void *make_alloc_exact(unsigned long addr, unsigned order, size_t size)
++=======
+ static void *make_alloc_exact(unsigned long addr, unsigned int order,
+ 		size_t size)
++>>>>>>> 4949148ad433 (mm: charge/uncharge kmemcg from generic page allocator paths)
  {
  	if (addr) {
  		unsigned long alloc_end = addr + (PAGE_SIZE << order);
diff --cc mm/slab_common.c
index 288b69b9b33e,71f0b28a1bec..000000000000
--- a/mm/slab_common.c
+++ b/mm/slab_common.c
@@@ -608,9 -1001,91 +608,87 @@@ void __init create_kmalloc_caches(unsig
  }
  #endif /* !CONFIG_SLOB */
  
++<<<<<<< HEAD
++=======
+ /*
+  * To avoid unnecessary overhead, we pass through large allocation requests
+  * directly to the page allocator. We use __GFP_COMP, because we will need to
+  * know the allocation order to free the pages properly in kfree.
+  */
+ void *kmalloc_order(size_t size, gfp_t flags, unsigned int order)
+ {
+ 	void *ret;
+ 	struct page *page;
+ 
+ 	flags |= __GFP_COMP;
+ 	page = alloc_pages(flags, order);
+ 	ret = page ? page_address(page) : NULL;
+ 	kmemleak_alloc(ret, size, 1, flags);
+ 	kasan_kmalloc_large(ret, size, flags);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(kmalloc_order);
+ 
+ #ifdef CONFIG_TRACING
+ void *kmalloc_order_trace(size_t size, gfp_t flags, unsigned int order)
+ {
+ 	void *ret = kmalloc_order(size, flags, order);
+ 	trace_kmalloc(_RET_IP_, ret, size, PAGE_SIZE << order, flags);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(kmalloc_order_trace);
+ #endif
+ 
+ #ifdef CONFIG_SLAB_FREELIST_RANDOM
+ /* Randomize a generic freelist */
+ static void freelist_randomize(struct rnd_state *state, unsigned int *list,
+ 			size_t count)
+ {
+ 	size_t i;
+ 	unsigned int rand;
+ 
+ 	for (i = 0; i < count; i++)
+ 		list[i] = i;
+ 
+ 	/* Fisher-Yates shuffle */
+ 	for (i = count - 1; i > 0; i--) {
+ 		rand = prandom_u32_state(state);
+ 		rand %= (i + 1);
+ 		swap(list[i], list[rand]);
+ 	}
+ }
+ 
+ /* Create a random sequence per cache */
+ int cache_random_seq_create(struct kmem_cache *cachep, unsigned int count,
+ 				    gfp_t gfp)
+ {
+ 	struct rnd_state state;
+ 
+ 	if (count < 2 || cachep->random_seq)
+ 		return 0;
+ 
+ 	cachep->random_seq = kcalloc(count, sizeof(unsigned int), gfp);
+ 	if (!cachep->random_seq)
+ 		return -ENOMEM;
+ 
+ 	/* Get best entropy at this stage of boot */
+ 	prandom_seed_state(&state, get_random_long());
+ 
+ 	freelist_randomize(&state, cachep->random_seq, count);
+ 	return 0;
+ }
+ 
+ /* Destroy the per-cache random freelist sequence */
+ void cache_random_seq_destroy(struct kmem_cache *cachep)
+ {
+ 	kfree(cachep->random_seq);
+ 	cachep->random_seq = NULL;
+ }
+ #endif /* CONFIG_SLAB_FREELIST_RANDOM */
++>>>>>>> 4949148ad433 (mm: charge/uncharge kmemcg from generic page allocator paths)
  
  #ifdef CONFIG_SLABINFO
 -
 -#ifdef CONFIG_SLAB
 -#define SLABINFO_RIGHTS (S_IWUSR | S_IRUSR)
 -#else
 -#define SLABINFO_RIGHTS S_IRUSR
 -#endif
 -
 -static void print_slabinfo_header(struct seq_file *m)
 +void print_slabinfo_header(struct seq_file *m)
  {
  	/*
  	 * Output format version, so at least we can change it
diff --cc mm/slub.c
index cfd46f5b97ec,f9da8716b8b3..000000000000
--- a/mm/slub.c
+++ b/mm/slub.c
@@@ -2872,12 -2971,25 +2872,30 @@@ int build_detached_freelist(struct kmem
  	if (!object)
  		return 0;
  
++<<<<<<< HEAD
 +	/* Support for memcg, compiler can optimize this out */
 +	df->s = cache_from_obj(s, object);
++=======
+ 	page = virt_to_head_page(object);
+ 	if (!s) {
+ 		/* Handle kalloc'ed objects */
+ 		if (unlikely(!PageSlab(page))) {
+ 			BUG_ON(!PageCompound(page));
+ 			kfree_hook(object);
+ 			__free_pages(page, compound_order(page));
+ 			p[size] = NULL; /* mark object processed */
+ 			return size;
+ 		}
+ 		/* Derive kmem_cache from object */
+ 		df->s = page->slab_cache;
+ 	} else {
+ 		df->s = cache_from_obj(s, object); /* Support for memcg */
+ 	}
++>>>>>>> 4949148ad433 (mm: charge/uncharge kmemcg from generic page allocator paths)
  
  	/* Start new detached freelist */
 -	df->page = page;
  	set_freepointer(df->s, object, NULL);
 +	df->page = virt_to_head_page(object);
  	df->tail = object;
  	df->freelist = object;
  	p[size] = NULL; /* mark object processed */
@@@ -3605,7 -3692,7 +3623,11 @@@ static void *kmalloc_large_node(size_t 
  	struct page *page;
  	void *ptr = NULL;
  
++<<<<<<< HEAD
 +	flags |= __GFP_COMP | __GFP_NOTRACK | __GFP_KMEMCG;
++=======
+ 	flags |= __GFP_COMP | __GFP_NOTRACK;
++>>>>>>> 4949148ad433 (mm: charge/uncharge kmemcg from generic page allocator paths)
  	page = alloc_pages_node(node, flags, get_order(size));
  	if (page)
  		ptr = page_address(page);
@@@ -3750,8 -3773,8 +3772,13 @@@ void kfree(const void *x
  	page = virt_to_head_page(x);
  	if (unlikely(!PageSlab(page))) {
  		BUG_ON(!PageCompound(page));
++<<<<<<< HEAD
 +		kmemleak_free(x);
 +		__free_memcg_kmem_pages(page, compound_order(page));
++=======
+ 		kfree_hook(x);
+ 		__free_pages(page, compound_order(page));
++>>>>>>> 4949148ad433 (mm: charge/uncharge kmemcg from generic page allocator paths)
  		return;
  	}
  	slab_free(page->slab_cache, page, object, NULL, 1, _RET_IP_);
diff --cc mm/vmalloc.c
index 90de46594b5f,91f44e78c516..000000000000
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@@ -1501,13 -1501,10 +1501,17 @@@ static void __vunmap(const void *addr, 
  			struct page *page = area->pages[i];
  
  			BUG_ON(!page);
++<<<<<<< HEAD
 +			__free_page(page);
++=======
+ 			__free_pages(page, 0);
++>>>>>>> 4949148ad433 (mm: charge/uncharge kmemcg from generic page allocator paths)
  		}
  
 -		kvfree(area->pages);
 +		if (area->flags & VM_VPAGES)
 +			vfree(area->pages);
 +		else
 +			kfree(area->pages);
  	}
  
  	kfree(area);
@@@ -1628,12 -1627,11 +1632,19 @@@ static void *__vmalloc_area_node(struc
  
  	for (i = 0; i < area->nr_pages; i++) {
  		struct page *page;
 +		gfp_t tmp_mask = gfp_mask | __GFP_NOWARN;
  
++<<<<<<< HEAD
 +		if (node < 0)
 +			page = alloc_page(tmp_mask);
 +		else
 +			page = alloc_pages_node(node, tmp_mask, order);
++=======
+ 		if (node == NUMA_NO_NODE)
+ 			page = alloc_pages(alloc_mask, order);
+ 		else
+ 			page = alloc_pages_node(node, alloc_mask, order);
++>>>>>>> 4949148ad433 (mm: charge/uncharge kmemcg from generic page allocator paths)
  
  		if (unlikely(!page)) {
  			/* Successfully allocated i pages, free them in __vunmap() */
* Unmerged path include/linux/gfp.h
* Unmerged path include/linux/page-flags.h
* Unmerged path kernel/fork.c
* Unmerged path mm/page_alloc.c
* Unmerged path mm/slab_common.c
* Unmerged path mm/slub.c
* Unmerged path mm/vmalloc.c
