cifs: fix crash in cifs_dfs_do_automount

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Ronnie Sahlberg <lsahlber@redhat.com>
commit ce465bf94b70f03136171a62b607864f00093b19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/ce465bf9.failed

RHBZ: 1649907

Fix a crash that happens while attempting to mount a DFS referral from the same server on the root of a filesystem.

	Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit ce465bf94b70f03136171a62b607864f00093b19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
diff --cc fs/cifs/connect.c
index 9a641bdd75d8,6331c4f93b59..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -3836,111 -4526,107 +3845,155 @@@ cifs_are_all_path_components_accessible
  	return rc;
  }
  
 -/*
 - * Check if path is remote (e.g. a DFS share). Return -EREMOTE if it is,
 - * otherwise 0.
 - */
 -static int is_path_remote(struct cifs_sb_info *cifs_sb, struct smb_vol *vol,
 -			  const unsigned int xid,
 -			  struct TCP_Server_Info *server,
 -			  struct cifs_tcon *tcon)
 +int
 +cifs_mount(struct cifs_sb_info *cifs_sb, struct smb_vol *volume_info)
  {
  	int rc;
++<<<<<<< HEAD
++=======
+ 	char *full_path;
+ 
+ 	if (!server->ops->is_path_accessible)
+ 		return -EOPNOTSUPP;
+ 
+ 	/*
+ 	 * cifs_build_path_to_root works only when we have a valid tcon
+ 	 */
+ 	full_path = cifs_build_path_to_root(vol, cifs_sb, tcon,
+ 					    tcon->Flags & SMB_SHARE_IS_IN_DFS);
+ 	if (full_path == NULL)
+ 		return -ENOMEM;
+ 
+ 	cifs_dbg(FYI, "%s: full_path: %s\n", __func__, full_path);
+ 
+ 	rc = server->ops->is_path_accessible(xid, tcon, cifs_sb,
+ 					     full_path);
+ 	if (rc != 0 && rc != -EREMOTE) {
+ 		kfree(full_path);
+ 		return rc;
+ 	}
+ 
+ 	if (rc != -EREMOTE) {
+ 		rc = cifs_are_all_path_components_accessible(server, xid, tcon,
+ 			cifs_sb, full_path, tcon->Flags & SMB_SHARE_IS_IN_DFS);
+ 		if (rc != 0) {
+ 			cifs_dbg(VFS, "cannot query dirs between root and final path, "
+ 				 "enabling CIFS_MOUNT_USE_PREFIX_PATH\n");
+ 			cifs_sb->mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;
+ 			rc = 0;
+ 		}
+ 	}
+ 
+ 	kfree(full_path);
+ 	return rc;
+ }
+ 
+ #ifdef CONFIG_CIFS_DFS_UPCALL
+ int cifs_mount(struct cifs_sb_info *cifs_sb, struct smb_vol *vol)
+ {
+ 	int rc = 0;
++>>>>>>> ce465bf94b70 (cifs: fix crash in cifs_dfs_do_automount)
  	unsigned int xid;
  	struct cifs_ses *ses;
 -	struct cifs_tcon *root_tcon = NULL;
 -	struct cifs_tcon *tcon = NULL;
 +	struct cifs_tcon *tcon;
  	struct TCP_Server_Info *server;
 -	char *root_path = NULL, *full_path = NULL;
 -	char *old_mountdata, *origin_mountdata = NULL;
 -	int count;
 +	char   *full_path;
 +	struct tcon_link *tlink;
 +#ifdef CONFIG_CIFS_DFS_UPCALL
 +	int referral_walks_count = 0;
 +#endif
  
 -	rc = mount_get_conns(vol, cifs_sb, &xid, &server, &ses, &tcon);
 -	if (!rc && tcon) {
 -		/* If not a standalone DFS root, then check if path is remote */
 -		rc = dfs_cache_find(xid, ses, cifs_sb->local_nls,
 -				    cifs_remap(cifs_sb), vol->UNC + 1, NULL,
 -				    NULL);
 -		if (rc) {
 -			rc = is_path_remote(cifs_sb, vol, xid, server, tcon);
 -			if (!rc)
 -				goto out;
 -			if (rc != -EREMOTE)
 -				goto error;
 -		}
 +	rc = bdi_setup_and_register(&cifs_sb->bdi, "cifs", BDI_CAP_MAP_COPY);
 +	if (rc)
 +		return rc;
 +
 +#ifdef CONFIG_CIFS_DFS_UPCALL
 +try_mount_again:
 +	/* cleanup activities if we're chasing a referral */
 +	if (referral_walks_count) {
 +		if (tcon)
 +			cifs_put_tcon(tcon);
 +		else if (ses)
 +			cifs_put_smb_ses(ses);
 +
 +		cifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_POSIX_PATHS;
 +
 +		free_xid(xid);
  	}
 -	/*
 -	 * If first DFS target server went offline and we failed to connect it,
 -	 * server and ses pointers are NULL at this point, though we still have
 -	 * chance to get a cached DFS referral in expand_dfs_referral() and
 -	 * retry next target available in it.
 -	 *
 -	 * If a NULL ses ptr is passed to dfs_cache_find(), a lookup will be
 -	 * performed against DFS path and *no* requests will be sent to server
 -	 * for any new DFS referrals. Hence it's safe to skip checking whether
 -	 * server or ses ptr is NULL.
 -	 */
 -	if (rc == -EACCES || rc == -EOPNOTSUPP)
 -		goto error;
 -
 -	root_path = build_unc_path_to_root(vol, cifs_sb, false);
 -	if (IS_ERR(root_path)) {
 -		rc = PTR_ERR(root_path);
 -		root_path = NULL;
 -		goto error;
 +#endif
 +	rc = 0;
 +	tcon = NULL;
 +	ses = NULL;
 +	server = NULL;
 +	full_path = NULL;
 +	tlink = NULL;
 +
 +	xid = get_xid();
 +
 +	/* get a reference to a tcp session */
 +	server = cifs_get_tcp_session(volume_info);
 +	if (IS_ERR(server)) {
 +		rc = PTR_ERR(server);
 +		bdi_destroy(&cifs_sb->bdi);
 +		goto out;
  	}
 +	if ((volume_info->max_credits < 20) ||
 +	     (volume_info->max_credits > 60000))
 +		server->max_credits = SMB2_MAX_CREDITS_AVAILABLE;
 +	else
 +		server->max_credits = volume_info->max_credits;
 +	/* get a reference to a SMB session */
 +	ses = cifs_get_smb_ses(server, volume_info);
 +	if (IS_ERR(ses)) {
 +		rc = PTR_ERR(ses);
 +		ses = NULL;
 +		goto mount_fail_check;
 +	}
 +
 +	if ((volume_info->persistent == true) && ((ses->server->capabilities &
 +		SMB2_GLOBAL_CAP_PERSISTENT_HANDLES) == 0)) {
 +		cifs_dbg(VFS, "persistent handles not supported by server\n");
 +		rc = -EOPNOTSUPP;
 +		goto mount_fail_check;
 +	}
 +
 +	/* search for existing tcon to this server share */
 +	tcon = cifs_get_tcon(ses, volume_info);
 +	if (IS_ERR(tcon)) {
 +		rc = PTR_ERR(tcon);
 +		tcon = NULL;
 +		if (rc == -EACCES)
 +			goto mount_fail_check;
  
 -	full_path = build_unc_path_to_root(vol, cifs_sb, true);
 -	if (IS_ERR(full_path)) {
 -		rc = PTR_ERR(full_path);
 -		full_path = NULL;
 -		goto error;
 +		goto remote_path_check;
  	}
 +
 +	/* tell server which Unix caps we support */
 +	if (cap_unix(tcon->ses)) {
 +		/* reset of caps checks mount to see if unix extensions
 +		   disabled for just this mount */
 +		reset_cifs_unix_caps(xid, tcon, cifs_sb, volume_info);
 +		if ((tcon->ses->server->tcpStatus == CifsNeedReconnect) &&
 +		    (le64_to_cpu(tcon->fsUnixInfo.Capability) &
 +		     CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)) {
 +			rc = -EACCES;
 +			goto mount_fail_check;
 +		}
 +	} else
 +		tcon->unix_ext = 0; /* server does not support them */
 +
 +	/* do not care if a following call succeed - informational */
 +	if (!tcon->pipe && server->ops->qfs_tcon)
 +		server->ops->qfs_tcon(xid, tcon);
 +
 +	cifs_sb->wsize = server->ops->negotiate_wsize(tcon, volume_info);
 +	cifs_sb->rsize = server->ops->negotiate_rsize(tcon, volume_info);
 +
 +	/* tune readahead according to rsize */
 +	cifs_sb->bdi.ra_pages = cifs_sb->rsize / PAGE_SIZE;
 +
 +remote_path_check:
 +#ifdef CONFIG_CIFS_DFS_UPCALL
  	/*
  	 * Perform an unconditional check for whether there are DFS
  	 * referrals for this path without prefix, to provide support
* Unmerged path fs/cifs/connect.c
