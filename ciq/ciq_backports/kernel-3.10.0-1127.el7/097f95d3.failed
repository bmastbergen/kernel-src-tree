netfilter: masquerade: don't flush all conntracks if only one address deleted on device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Tan Hu <tan.hu@zte.com.cn>
commit 097f95d319f817e651bd51f8846aced92a55a6a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/097f95d3.failed

We configured iptables as below, which only allowed incoming data on
established connections:

iptables -t mangle -A PREROUTING -m state --state ESTABLISHED -j ACCEPT
iptables -t mangle -P PREROUTING DROP

When deleting a secondary address, current masquerade implements would
flush all conntracks on this device. All the established connections on
primary address also be deleted, then subsequent incoming data on the
connections would be dropped wrongly because it was identified as NEW
connection.

So when an address was delete, it should only flush connections related
with the address.

	Signed-off-by: Tan Hu <tan.hu@zte.com.cn>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 097f95d319f817e651bd51f8846aced92a55a6a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/netfilter/nf_nat_masquerade_ipv6.c
diff --cc net/ipv6/netfilter/nf_nat_masquerade_ipv6.c
index e47dc94f678b,3e4bf2286abe..000000000000
--- a/net/ipv6/netfilter/nf_nat_masquerade_ipv6.c
+++ b/net/ipv6/netfilter/nf_nat_masquerade_ipv6.c
@@@ -78,50 -84,107 +78,135 @@@ static struct notifier_block masq_dev_n
  	.notifier_call	= masq_device_event,
  };
  
++<<<<<<< HEAD
 +static int masq_inet6_event(struct notifier_block *this,
 +			    unsigned long event, void *ptr)
++=======
+ struct masq_dev_work {
+ 	struct work_struct work;
+ 	struct net *net;
+ 	struct in6_addr addr;
+ 	int ifindex;
+ };
+ 
+ static int inet_cmp(struct nf_conn *ct, void *work)
+ {
+ 	struct masq_dev_work *w = (struct masq_dev_work *)work;
+ 	struct nf_conntrack_tuple *tuple;
+ 
+ 	if (!device_cmp(ct, (void *)(long)w->ifindex))
+ 		return 0;
+ 
+ 	tuple = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;
+ 
+ 	return ipv6_addr_equal(&w->addr, &tuple->dst.u3.in6);
+ }
+ 
+ static void iterate_cleanup_work(struct work_struct *work)
+ {
+ 	struct masq_dev_work *w;
+ 
+ 	w = container_of(work, struct masq_dev_work, work);
+ 
+ 	nf_ct_iterate_cleanup_net(w->net, inet_cmp, (void *)w, 0, 0);
+ 
+ 	put_net(w->net);
+ 	kfree(w);
+ 	atomic_dec(&v6_worker_count);
+ 	module_put(THIS_MODULE);
+ }
+ 
+ /* ipv6 inet notifier is an atomic notifier, i.e. we cannot
+  * schedule.
+  *
+  * Unfortunately, nf_ct_iterate_cleanup_net can run for a long
+  * time if there are lots of conntracks and the system
+  * handles high softirq load, so it frequently calls cond_resched
+  * while iterating the conntrack table.
+  *
+  * So we defer nf_ct_iterate_cleanup_net walk to the system workqueue.
+  *
+  * As we can have 'a lot' of inet_events (depending on amount
+  * of ipv6 addresses being deleted), we also need to add an upper
+  * limit to the number of queued work items.
+  */
+ static int masq_inet_event(struct notifier_block *this,
+ 			   unsigned long event, void *ptr)
++>>>>>>> 097f95d319f8 (netfilter: masquerade: don't flush all conntracks if only one address deleted on device)
  {
  	struct inet6_ifaddr *ifa = ptr;
 -	const struct net_device *dev;
 -	struct masq_dev_work *w;
 -	struct net *net;
 +	struct netdev_notifier_info info;
  
++<<<<<<< HEAD
 +	netdev_notifier_info_init(&info, ifa->idev->dev);
 +	return masq_device_event(this, event, &info);
++=======
+ 	if (event != NETDEV_DOWN ||
+ 	    atomic_read(&v6_worker_count) >= MAX_WORK_COUNT)
+ 		return NOTIFY_DONE;
+ 
+ 	dev = ifa->idev->dev;
+ 	net = maybe_get_net(dev_net(dev));
+ 	if (!net)
+ 		return NOTIFY_DONE;
+ 
+ 	if (!try_module_get(THIS_MODULE))
+ 		goto err_module;
+ 
+ 	w = kmalloc(sizeof(*w), GFP_ATOMIC);
+ 	if (w) {
+ 		atomic_inc(&v6_worker_count);
+ 
+ 		INIT_WORK(&w->work, iterate_cleanup_work);
+ 		w->ifindex = dev->ifindex;
+ 		w->net = net;
+ 		w->addr = ifa->addr;
+ 		schedule_work(&w->work);
+ 
+ 		return NOTIFY_DONE;
+ 	}
+ 
+ 	module_put(THIS_MODULE);
+  err_module:
+ 	put_net(net);
+ 	return NOTIFY_DONE;
++>>>>>>> 097f95d319f8 (netfilter: masquerade: don't flush all conntracks if only one address deleted on device)
  }
  
 -static struct notifier_block masq_inet_notifier = {
 -	.notifier_call	= masq_inet_event,
 +static struct notifier_block masq_inet6_notifier = {
 +	.notifier_call	= masq_inet6_event,
  };
  
 -static atomic_t masquerade_notifier_refcount = ATOMIC_INIT(0);
 +static int masq_refcnt;
 +static DEFINE_MUTEX(masq_mutex);
  
 -void nf_nat_masquerade_ipv6_register_notifier(void)
 +int nf_nat_masquerade_ipv6_register_notifier(void)
  {
 +	int ret = 0;
 +
 +	mutex_lock(&masq_mutex);
  	/* check if the notifier is already set */
 -	if (atomic_inc_return(&masquerade_notifier_refcount) > 1)
 -		return;
 +	if (++masq_refcnt > 1)
 +		goto out_unlock;
 +
 +	ret = register_netdevice_notifier_rh(&masq_dev_notifier);
 +	if (ret)
 +		goto err_dec;
  
 -	register_netdevice_notifier(&masq_dev_notifier);
 -	register_inet6addr_notifier(&masq_inet_notifier);
 +	ret = register_inet6addr_notifier(&masq_inet6_notifier);
 +	if (ret)
 +		goto err_unregister;
 +
 +	mutex_unlock(&masq_mutex);
 +	return ret;
 +
 +err_unregister:
 +	unregister_netdevice_notifier(&masq_dev_notifier);
 +err_dec:
 +	masq_refcnt--;
 +out_unlock:
 +	mutex_unlock(&masq_mutex);
 +	return ret;
  }
  EXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv6_register_notifier);
  
diff --git a/net/ipv4/netfilter/nf_nat_masquerade_ipv4.c b/net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
index 0160dff0378e..632f2d6c2aeb 100644
--- a/net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
+++ b/net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
@@ -104,12 +104,26 @@ static int masq_device_event(struct notifier_block *this,
 	return NOTIFY_DONE;
 }
 
+static int inet_cmp(struct nf_conn *ct, void *ptr)
+{
+	struct in_ifaddr *ifa = (struct in_ifaddr *)ptr;
+	struct net_device *dev = ifa->ifa_dev->dev;
+	struct nf_conntrack_tuple *tuple;
+
+	if (!device_cmp(ct, (void *)(long)dev->ifindex))
+		return 0;
+
+	tuple = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;
+
+	return ifa->ifa_address == tuple->dst.u3.ip;
+}
+
 static int masq_inet_event(struct notifier_block *this,
 			   unsigned long event,
 			   void *ptr)
 {
 	struct in_device *idev = ((struct in_ifaddr *)ptr)->ifa_dev;
-	struct netdev_notifier_info info;
+	struct net *net = dev_net(idev->dev);
 
 	/* The masq_dev_notifier will catch the case of the device going
 	 * down.  So if the inetdev is dead and being destroyed we have
@@ -119,8 +133,10 @@ static int masq_inet_event(struct notifier_block *this,
 	if (idev->dead)
 		return NOTIFY_DONE;
 
-	netdev_notifier_info_init(&info, idev->dev);
-	return masq_device_event(this, event, &info);
+	if (event == NETDEV_DOWN)
+		nf_ct_iterate_cleanup_net(net, inet_cmp, ptr, 0, 0);
+
+	return NOTIFY_DONE;
 }
 
 static struct notifier_block masq_dev_notifier = {
* Unmerged path net/ipv6/netfilter/nf_nat_masquerade_ipv6.c
