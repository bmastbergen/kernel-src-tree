nl80211: validate beacon head

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Johannes Berg <johannes.berg@intel.com>
commit f88eb7c0d002a67ef31aeb7850b42ff69abc46dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/f88eb7c0.failed

We currently don't validate the beacon head, i.e. the header,
fixed part and elements that are to go in front of the TIM
element. This means that the variable elements there can be
malformed, e.g. have a length exceeding the buffer size, but
most downstream code from this assumes that this has already
been checked.

Add the necessary checks to the netlink policy.

	Cc: stable@vger.kernel.org
Fixes: ed1b6cc7f80f ("cfg80211/nl80211: add beacon settings")
Link: https://lore.kernel.org/r/1569009255-I7ac7fbe9436e9d8733439eab8acbbd35e55c74ef@changeid
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit f88eb7c0d002a67ef31aeb7850b42ff69abc46dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/wireless/nl80211.c
diff --cc net/wireless/nl80211.c
index 1e078b140bcc,7386421e2ad3..000000000000
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@@ -200,8 -201,128 +200,61 @@@ cfg80211_get_dev_from_info(struct net *
  	return __cfg80211_rdev_from_attrs(netns, info->attrs);
  }
  
++<<<<<<< HEAD
++=======
+ static int validate_beacon_head(const struct nlattr *attr,
+ 				struct netlink_ext_ack *extack)
+ {
+ 	const u8 *data = nla_data(attr);
+ 	unsigned int len = nla_len(attr);
+ 	const struct element *elem;
+ 	const struct ieee80211_mgmt *mgmt = (void *)data;
+ 	unsigned int fixedlen = offsetof(struct ieee80211_mgmt,
+ 					 u.beacon.variable);
+ 
+ 	if (len < fixedlen)
+ 		goto err;
+ 
+ 	if (ieee80211_hdrlen(mgmt->frame_control) !=
+ 	    offsetof(struct ieee80211_mgmt, u.beacon))
+ 		goto err;
+ 
+ 	data += fixedlen;
+ 	len -= fixedlen;
+ 
+ 	for_each_element(elem, data, len) {
+ 		/* nothing */
+ 	}
+ 
+ 	if (for_each_element_completed(elem, data, len))
+ 		return 0;
+ 
+ err:
+ 	NL_SET_ERR_MSG_ATTR(extack, attr, "malformed beacon head");
+ 	return -EINVAL;
+ }
+ 
+ static int validate_ie_attr(const struct nlattr *attr,
+ 			    struct netlink_ext_ack *extack)
+ {
+ 	const u8 *data = nla_data(attr);
+ 	unsigned int len = nla_len(attr);
+ 	const struct element *elem;
+ 
+ 	for_each_element(elem, data, len) {
+ 		/* nothing */
+ 	}
+ 
+ 	if (for_each_element_completed(elem, data, len))
+ 		return 0;
+ 
+ 	NL_SET_ERR_MSG_ATTR(extack, attr, "malformed information elements");
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> f88eb7c0d002 (nl80211: validate beacon head)
  /* policy for the attributes */
 -static const struct nla_policy
 -nl80211_ftm_responder_policy[NL80211_FTM_RESP_ATTR_MAX + 1] = {
 -	[NL80211_FTM_RESP_ATTR_ENABLED] = { .type = NLA_FLAG, },
 -	[NL80211_FTM_RESP_ATTR_LCI] = { .type = NLA_BINARY,
 -					.len = U8_MAX },
 -	[NL80211_FTM_RESP_ATTR_CIVICLOC] = { .type = NLA_BINARY,
 -					     .len = U8_MAX },
 -};
 -
 -static const struct nla_policy
 -nl80211_pmsr_ftm_req_attr_policy[NL80211_PMSR_FTM_REQ_ATTR_MAX + 1] = {
 -	[NL80211_PMSR_FTM_REQ_ATTR_ASAP] = { .type = NLA_FLAG },
 -	[NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE] = { .type = NLA_U32 },
 -	[NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP] =
 -		NLA_POLICY_MAX(NLA_U8, 15),
 -	[NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD] = { .type = NLA_U16 },
 -	[NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION] =
 -		NLA_POLICY_MAX(NLA_U8, 15),
 -	[NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST] =
 -		NLA_POLICY_MAX(NLA_U8, 31),
 -	[NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES] = { .type = NLA_U8 },
 -	[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI] = { .type = NLA_FLAG },
 -	[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC] = { .type = NLA_FLAG },
 -};
 -
 -static const struct nla_policy
 -nl80211_pmsr_req_data_policy[NL80211_PMSR_TYPE_MAX + 1] = {
 -	[NL80211_PMSR_TYPE_FTM] =
 -		NLA_POLICY_NESTED(nl80211_pmsr_ftm_req_attr_policy),
 -};
 -
 -static const struct nla_policy
 -nl80211_pmsr_req_attr_policy[NL80211_PMSR_REQ_ATTR_MAX + 1] = {
 -	[NL80211_PMSR_REQ_ATTR_DATA] =
 -		NLA_POLICY_NESTED(nl80211_pmsr_req_data_policy),
 -	[NL80211_PMSR_REQ_ATTR_GET_AP_TSF] = { .type = NLA_FLAG },
 -};
 -
 -static const struct nla_policy
 -nl80211_psmr_peer_attr_policy[NL80211_PMSR_PEER_ATTR_MAX + 1] = {
 -	[NL80211_PMSR_PEER_ATTR_ADDR] = NLA_POLICY_ETH_ADDR,
 -	/*
 -	 * we could specify this again to be the top-level policy,
 -	 * but that would open us up to recursion problems ...
 -	 */
 -	[NL80211_PMSR_PEER_ATTR_CHAN] = { .type = NLA_NESTED },
 -	[NL80211_PMSR_PEER_ATTR_REQ] =
 -		NLA_POLICY_NESTED(nl80211_pmsr_req_attr_policy),
 -	[NL80211_PMSR_PEER_ATTR_RESP] = { .type = NLA_REJECT },
 -};
 -
 -static const struct nla_policy
 -nl80211_pmsr_attr_policy[NL80211_PMSR_ATTR_MAX + 1] = {
 -	[NL80211_PMSR_ATTR_MAX_PEERS] = { .type = NLA_REJECT },
 -	[NL80211_PMSR_ATTR_REPORT_AP_TSF] = { .type = NLA_REJECT },
 -	[NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR] = { .type = NLA_REJECT },
 -	[NL80211_PMSR_ATTR_TYPE_CAPA] = { .type = NLA_REJECT },
 -	[NL80211_PMSR_ATTR_PEERS] =
 -		NLA_POLICY_NESTED_ARRAY(nl80211_psmr_peer_attr_policy),
 -};
 -
 -static const struct nla_policy
 -he_obss_pd_policy[NL80211_HE_OBSS_PD_ATTR_MAX + 1] = {
 -	[NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET] =
 -		NLA_POLICY_RANGE(NLA_U8, 1, 20),
 -	[NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET] =
 -		NLA_POLICY_RANGE(NLA_U8, 1, 20),
 -};
 -
 -const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {
 -	[0] = { .strict_start_type = NL80211_ATTR_HE_OBSS_PD },
 +static const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {
  	[NL80211_ATTR_WIPHY] = { .type = NLA_U32 },
  	[NL80211_ATTR_WIPHY_NAME] = { .type = NLA_NUL_STRING,
  				      .len = 20-1 },
@@@ -238,11 -370,14 +291,22 @@@
  
  	[NL80211_ATTR_BEACON_INTERVAL] = { .type = NLA_U32 },
  	[NL80211_ATTR_DTIM_PERIOD] = { .type = NLA_U32 },
++<<<<<<< HEAD
 +	[NL80211_ATTR_BEACON_HEAD] = { .type = NLA_BINARY,
 +				       .len = IEEE80211_MAX_DATA_LEN },
 +	[NL80211_ATTR_BEACON_TAIL] = { .type = NLA_BINARY,
 +				       .len = IEEE80211_MAX_DATA_LEN },
 +	[NL80211_ATTR_STA_AID] = { .type = NLA_U16 },
++=======
+ 	[NL80211_ATTR_BEACON_HEAD] =
+ 		NLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_beacon_head,
+ 				       IEEE80211_MAX_DATA_LEN),
+ 	[NL80211_ATTR_BEACON_TAIL] =
+ 		NLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,
+ 				       IEEE80211_MAX_DATA_LEN),
+ 	[NL80211_ATTR_STA_AID] =
+ 		NLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),
++>>>>>>> f88eb7c0d002 (nl80211: validate beacon head)
  	[NL80211_ATTR_STA_FLAGS] = { .type = NLA_NESTED },
  	[NL80211_ATTR_STA_LISTEN_INTERVAL] = { .type = NLA_U16 },
  	[NL80211_ATTR_STA_SUPPORTED_RATES] = { .type = NLA_BINARY,
* Unmerged path net/wireless/nl80211.c
