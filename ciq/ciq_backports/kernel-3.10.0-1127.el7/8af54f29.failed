fs: fold __generic_write_end back into generic_write_end

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 8af54f291e5cfdb215e0b3045cc365954c55855d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/8af54f29.failed

This effectively reverts a6d639da63ae ("fs: factor out a
__generic_write_end helper") as we now open code what is left of that
helper in iomap.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 8af54f291e5cfdb215e0b3045cc365954c55855d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/buffer.c
#	fs/internal.h
diff --cc fs/buffer.c
index ccb67909a9cb,49a871570092..000000000000
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@@ -2066,43 -2086,6 +2066,46 @@@ int block_write_begin(struct address_sp
  }
  EXPORT_SYMBOL(block_write_begin);
  
++<<<<<<< HEAD
 +int __generic_write_end(struct file *file, struct address_space *mapping,
 +			loff_t pos, unsigned len, unsigned copied,
 +			struct page *page, void *fsdata)
 +{
 +	struct inode *inode = mapping->host;
 +	loff_t old_size = inode->i_size;
 +	int i_size_changed = 0;
 +
 +	/*
 +	 * No need to use i_size_read() here, the i_size
 +	 * cannot change under us because we hold i_mutex.
 +	 *
 +	 * But it's important to update i_size while still holding page lock:
 +	 * page writeout could otherwise come in and zero beyond i_size.
 +	 */
 +	if (pos+copied > inode->i_size) {
 +		i_size_write(inode, pos+copied);
 +		i_size_changed = 1;
 +	}
 +
 +	unlock_page(page);
 +	page_cache_release(page);
 +
 +	if (old_size < pos)
 +		pagecache_isize_extended(inode, old_size, pos);
 +	/*
 +	 * Don't mark the inode dirty under page lock. First, it unnecessarily
 +	 * makes the holding time of page lock longer. Second, it forces lock
 +	 * ordering of page lock and transaction start for journaling
 +	 * filesystems.
 +	 */
 +	if (i_size_changed)
 +		mark_inode_dirty(inode);
 +
 +	return copied;
 +}
 +
++=======
++>>>>>>> 8af54f291e5c (fs: fold __generic_write_end back into generic_write_end)
  int block_write_end(struct file *file, struct address_space *mapping,
  			loff_t pos, unsigned len, unsigned copied,
  			struct page *page, void *fsdata)
@@@ -2143,10 -2126,38 +2146,43 @@@ int generic_write_end(struct file *file
  			loff_t pos, unsigned len, unsigned copied,
  			struct page *page, void *fsdata)
  {
+ 	struct inode *inode = mapping->host;
+ 	loff_t old_size = inode->i_size;
+ 	bool i_size_changed = false;
+ 
  	copied = block_write_end(file, mapping, pos, len, copied, page, fsdata);
  
++<<<<<<< HEAD
 +	return __generic_write_end(file, mapping, pos, len, copied, page,
 +				   fsdata);
++=======
+ 	/*
+ 	 * No need to use i_size_read() here, the i_size cannot change under us
+ 	 * because we hold i_rwsem.
+ 	 *
+ 	 * But it's important to update i_size while still holding page lock:
+ 	 * page writeout could otherwise come in and zero beyond i_size.
+ 	 */
+ 	if (pos + copied > inode->i_size) {
+ 		i_size_write(inode, pos + copied);
+ 		i_size_changed = true;
+ 	}
+ 
+ 	unlock_page(page);
+ 	put_page(page);
+ 
+ 	if (old_size < pos)
+ 		pagecache_isize_extended(inode, old_size, pos);
+ 	/*
+ 	 * Don't mark the inode dirty under page lock. First, it unnecessarily
+ 	 * makes the holding time of page lock longer. Second, it forces lock
+ 	 * ordering of page lock and transaction start for journaling
+ 	 * filesystems.
+ 	 */
+ 	if (i_size_changed)
+ 		mark_inode_dirty(inode);
+ 	return copied;
++>>>>>>> 8af54f291e5c (fs: fold __generic_write_end back into generic_write_end)
  }
  EXPORT_SYMBOL(generic_write_end);
  
diff --cc fs/internal.h
index 3310bfe574a4,2f3c3de51fad..000000000000
--- a/fs/internal.h
+++ b/fs/internal.h
@@@ -44,9 -40,6 +44,12 @@@ static inline int __sync_blockdev(struc
  extern void guard_bio_eod(int rw, struct bio *bio);
  extern int __block_write_begin_int(struct page *page, loff_t pos, unsigned len,
  		get_block_t *get_block, struct iomap *iomap);
++<<<<<<< HEAD
 +extern int __generic_write_end(struct file *file, struct address_space *mapping,
 +			       loff_t pos, unsigned len, unsigned copied,
 +			       struct page *page, void *fsdata);
++=======
++>>>>>>> 8af54f291e5c (fs: fold __generic_write_end back into generic_write_end)
  
  /*
   * char_dev.c
* Unmerged path fs/buffer.c
* Unmerged path fs/internal.h
