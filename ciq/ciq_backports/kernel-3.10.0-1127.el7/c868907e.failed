scsi: qla2xxx: Fix incorrect SFUB length used for Secure Flash Update MB Cmd

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Michael Hernandez <mhernandez@marvell.com>
commit c868907e1ac6a08a17f8fa9ce482c0a496896e9e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/c868907e.failed

SFUB length should be in DWORDs when passed to FW.

Fixes: 3f006ac342c03 ("scsi: qla2xxx: Secure flash update support for ISP28XX")
	Cc: stable@vger.kernel.org
Link: https://lore.kernel.org/r/20191203223657.22109-4-hmadhani@marvell.com
	Signed-off-by: Michael Hernandez <mhernandez@marvell.com>
	Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit c868907e1ac6a08a17f8fa9ce482c0a496896e9e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_sup.c
diff --cc drivers/scsi/qla2xxx/qla_sup.c
index d78d2bdfd652,bbe90354f49b..000000000000
--- a/drivers/scsi/qla2xxx/qla_sup.c
+++ b/drivers/scsi/qla2xxx/qla_sup.c
@@@ -2587,8 -2619,357 +2587,360 @@@ qla24xx_read_optrom_data(struct scsi_ql
  	return buf;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ qla28xx_extract_sfub_and_verify(struct scsi_qla_host *vha, uint32_t *buf,
+     uint32_t len, uint32_t buf_size_without_sfub, uint8_t *sfub_buf)
+ {
+ 	uint32_t *p, check_sum = 0;
+ 	int i;
+ 
+ 	p = buf + buf_size_without_sfub;
+ 
+ 	/* Extract SFUB from end of file */
+ 	memcpy(sfub_buf, (uint8_t *)p,
+ 	    sizeof(struct secure_flash_update_block));
+ 
+ 	for (i = 0; i < (sizeof(struct secure_flash_update_block) >> 2); i++)
+ 		check_sum += p[i];
+ 
+ 	check_sum = (~check_sum) + 1;
+ 
+ 	if (check_sum != p[i]) {
+ 		ql_log(ql_log_warn, vha, 0x7097,
+ 		    "SFUB checksum failed, 0x%x, 0x%x\n",
+ 		    check_sum, p[i]);
+ 		return QLA_COMMAND_ERROR;
+ 	}
+ 
+ 	return QLA_SUCCESS;
+ }
+ 
+ static int
+ qla28xx_get_flash_region(struct scsi_qla_host *vha, uint32_t start,
+     struct qla_flt_region *region)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct qla_flt_header *flt;
+ 	struct qla_flt_region *flt_reg;
+ 	uint16_t cnt;
+ 	int rval = QLA_FUNCTION_FAILED;
+ 
+ 	if (!ha->flt)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	flt = (struct qla_flt_header *)ha->flt;
+ 	flt_reg = (struct qla_flt_region *)&flt[1];
+ 	cnt = le16_to_cpu(flt->length) / sizeof(struct qla_flt_region);
+ 
+ 	for (; cnt; cnt--, flt_reg++) {
+ 		if (flt_reg->start == start) {
+ 			memcpy((uint8_t *)region, flt_reg,
+ 			    sizeof(struct qla_flt_region));
+ 			rval = QLA_SUCCESS;
+ 			break;
+ 		}
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ static int
+ qla28xx_write_flash_data(scsi_qla_host_t *vha, uint32_t *dwptr, uint32_t faddr,
+     uint32_t dwords)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	ulong liter;
+ 	ulong dburst = OPTROM_BURST_DWORDS; /* burst size in dwords */
+ 	uint32_t sec_mask, rest_addr, fdata;
+ 	void *optrom = NULL;
+ 	dma_addr_t optrom_dma;
+ 	int rval;
+ 	struct secure_flash_update_block *sfub;
+ 	dma_addr_t sfub_dma;
+ 	uint32_t offset = faddr << 2;
+ 	uint32_t buf_size_without_sfub = 0;
+ 	struct qla_flt_region region;
+ 	bool reset_to_rom = false;
+ 	uint32_t risc_size, risc_attr = 0;
+ 	uint32_t *fw_array = NULL;
+ 
+ 	/* Retrieve region info - must be a start address passed in */
+ 	rval = qla28xx_get_flash_region(vha, offset, &region);
+ 
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Invalid address %x - not a region start address\n",
+ 		    offset);
+ 		goto done;
+ 	}
+ 
+ 	/* Allocate dma buffer for burst write */
+ 	optrom = dma_alloc_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,
+ 	    &optrom_dma, GFP_KERNEL);
+ 	if (!optrom) {
+ 		ql_log(ql_log_warn, vha, 0x7095,
+ 		    "Failed allocate burst (%x bytes)\n", OPTROM_BURST_SIZE);
+ 		rval = QLA_COMMAND_ERROR;
+ 		goto done;
+ 	}
+ 
+ 	/*
+ 	 * If adapter supports secure flash and region is secure
+ 	 * extract secure flash update block (SFUB) and verify
+ 	 */
+ 	if (ha->flags.secure_adapter && region.attribute) {
+ 
+ 		ql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,
+ 		    "Region %x is secure\n", region.code);
+ 
+ 		switch (region.code) {
+ 		case FLT_REG_FW:
+ 		case FLT_REG_FW_SEC_27XX:
+ 		case FLT_REG_MPI_PRI_28XX:
+ 		case FLT_REG_MPI_SEC_28XX:
+ 			fw_array = dwptr;
+ 
+ 			/* 1st fw array */
+ 			risc_size = be32_to_cpu(fw_array[3]);
+ 			risc_attr = be32_to_cpu(fw_array[9]);
+ 
+ 			buf_size_without_sfub = risc_size;
+ 			fw_array += risc_size;
+ 
+ 			/* 2nd fw array */
+ 			risc_size = be32_to_cpu(fw_array[3]);
+ 
+ 			buf_size_without_sfub += risc_size;
+ 			fw_array += risc_size;
+ 
+ 			/* 1st dump template */
+ 			risc_size = be32_to_cpu(fw_array[2]);
+ 
+ 			/* skip header and ignore checksum */
+ 			buf_size_without_sfub += risc_size;
+ 			fw_array += risc_size;
+ 
+ 			if (risc_attr & BIT_9) {
+ 				/* 2nd dump template */
+ 				risc_size = be32_to_cpu(fw_array[2]);
+ 
+ 				/* skip header and ignore checksum */
+ 				buf_size_without_sfub += risc_size;
+ 				fw_array += risc_size;
+ 			}
+ 			break;
+ 
+ 		case FLT_REG_PEP_PRI_28XX:
+ 		case FLT_REG_PEP_SEC_28XX:
+ 			fw_array = dwptr;
+ 
+ 			/* 1st fw array */
+ 			risc_size = be32_to_cpu(fw_array[3]);
+ 			risc_attr = be32_to_cpu(fw_array[9]);
+ 
+ 			buf_size_without_sfub = risc_size;
+ 			fw_array += risc_size;
+ 			break;
+ 
+ 		default:
+ 			ql_log(ql_log_warn + ql_dbg_verbose, vha,
+ 			    0xffff, "Secure region %x not supported\n",
+ 			    region.code);
+ 			rval = QLA_COMMAND_ERROR;
+ 			goto done;
+ 		}
+ 
+ 		sfub = dma_alloc_coherent(&ha->pdev->dev,
+ 			sizeof(struct secure_flash_update_block), &sfub_dma,
+ 			GFP_KERNEL);
+ 		if (!sfub) {
+ 			ql_log(ql_log_warn, vha, 0xffff,
+ 			    "Unable to allocate memory for SFUB\n");
+ 			rval = QLA_COMMAND_ERROR;
+ 			goto done;
+ 		}
+ 
+ 		rval = qla28xx_extract_sfub_and_verify(vha, dwptr, dwords,
+ 			buf_size_without_sfub, (uint8_t *)sfub);
+ 
+ 		if (rval != QLA_SUCCESS)
+ 			goto done;
+ 
+ 		ql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,
+ 		    "SFUB extract and verify successful\n");
+ 	}
+ 
+ 	rest_addr = (ha->fdt_block_size >> 2) - 1;
+ 	sec_mask = ~rest_addr;
+ 
+ 	/* Lock semaphore */
+ 	rval = qla81xx_fac_semaphore_access(vha, FAC_SEMAPHORE_LOCK);
+ 	if (rval != QLA_SUCCESS) {
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Unable to lock flash semaphore.");
+ 		goto done;
+ 	}
+ 
+ 	ql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,
+ 	    "Unprotect flash...\n");
+ 	rval = qla24xx_unprotect_flash(vha);
+ 	if (rval) {
+ 		qla81xx_fac_semaphore_access(vha, FAC_SEMAPHORE_UNLOCK);
+ 		ql_log(ql_log_warn, vha, 0x7096, "Failed unprotect flash\n");
+ 		goto done;
+ 	}
+ 
+ 	for (liter = 0; liter < dwords; liter++, faddr++) {
+ 		fdata = (faddr & sec_mask) << 2;
+ 
+ 		/* If start of sector */
+ 		if (!(faddr & rest_addr)) {
+ 			ql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,
+ 			    "Erase sector %#x...\n", faddr);
+ 			rval = qla24xx_erase_sector(vha, fdata);
+ 			if (rval) {
+ 				ql_dbg(ql_dbg_user, vha, 0x7007,
+ 				    "Failed erase sector %#x\n", faddr);
+ 				goto write_protect;
+ 			}
+ 		}
+ 	}
+ 
+ 	if (ha->flags.secure_adapter) {
+ 		/*
+ 		 * If adapter supports secure flash but FW doesn't,
+ 		 * disable write protect, release semaphore and reset
+ 		 * chip to execute ROM code in order to update region securely
+ 		 */
+ 		if (!ha->flags.secure_fw) {
+ 			ql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,
+ 			    "Disable Write and Release Semaphore.");
+ 			rval = qla24xx_protect_flash(vha);
+ 			if (rval != QLA_SUCCESS) {
+ 				qla81xx_fac_semaphore_access(vha,
+ 					FAC_SEMAPHORE_UNLOCK);
+ 				ql_log(ql_log_warn, vha, 0xffff,
+ 				    "Unable to protect flash.");
+ 				goto done;
+ 			}
+ 
+ 			ql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,
+ 			    "Reset chip to ROM.");
+ 			set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
+ 			set_bit(ISP_ABORT_TO_ROM, &vha->dpc_flags);
+ 			qla2xxx_wake_dpc(vha);
+ 			rval = qla2x00_wait_for_chip_reset(vha);
+ 			if (rval != QLA_SUCCESS) {
+ 				ql_log(ql_log_warn, vha, 0xffff,
+ 				    "Unable to reset to ROM code.");
+ 				goto done;
+ 			}
+ 			reset_to_rom = true;
+ 			ha->flags.fac_supported = 0;
+ 
+ 			ql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,
+ 			    "Lock Semaphore");
+ 			rval = qla2xxx_write_remote_register(vha,
+ 			    FLASH_SEMAPHORE_REGISTER_ADDR, 0x00020002);
+ 			if (rval != QLA_SUCCESS) {
+ 				ql_log(ql_log_warn, vha, 0xffff,
+ 				    "Unable to lock flash semaphore.");
+ 				goto done;
+ 			}
+ 
+ 			/* Unprotect flash */
+ 			ql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,
+ 			    "Enable Write.");
+ 			rval = qla2x00_write_ram_word(vha, 0x7ffd0101, 0);
+ 			if (rval) {
+ 				ql_log(ql_log_warn, vha, 0x7096,
+ 				    "Failed unprotect flash\n");
+ 				goto done;
+ 			}
+ 		}
+ 
+ 		/* If region is secure, send Secure Flash MB Cmd */
+ 		if (region.attribute && buf_size_without_sfub) {
+ 			ql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,
+ 			    "Sending Secure Flash MB Cmd\n");
+ 			rval = qla28xx_secure_flash_update(vha, 0, region.code,
+ 				buf_size_without_sfub, sfub_dma,
+ 				sizeof(struct secure_flash_update_block) >> 2);
+ 			if (rval != QLA_SUCCESS) {
+ 				ql_log(ql_log_warn, vha, 0xffff,
+ 				    "Secure Flash MB Cmd failed %x.", rval);
+ 				goto write_protect;
+ 			}
+ 		}
+ 
+ 	}
+ 
+ 	/* re-init flash offset */
+ 	faddr = offset >> 2;
+ 
+ 	for (liter = 0; liter < dwords; liter++, faddr++, dwptr++) {
+ 		fdata = (faddr & sec_mask) << 2;
+ 
+ 		/* If smaller than a burst remaining */
+ 		if (dwords - liter < dburst)
+ 			dburst = dwords - liter;
+ 
+ 		/* Copy to dma buffer */
+ 		memcpy(optrom, dwptr, dburst << 2);
+ 
+ 		/* Burst write */
+ 		ql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,
+ 		    "Write burst (%#lx dwords)...\n", dburst);
+ 		rval = qla2x00_load_ram(vha, optrom_dma,
+ 		    flash_data_addr(ha, faddr), dburst);
+ 		if (rval != QLA_SUCCESS) {
+ 			ql_log(ql_log_warn, vha, 0x7097,
+ 			    "Failed burst write at %x (%p/%#llx)...\n",
+ 			    flash_data_addr(ha, faddr), optrom,
+ 			    (u64)optrom_dma);
+ 			break;
+ 		}
+ 
+ 		liter += dburst - 1;
+ 		faddr += dburst - 1;
+ 		dwptr += dburst - 1;
+ 		continue;
+ 	}
+ 
+ write_protect:
+ 	ql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,
+ 	    "Protect flash...\n");
+ 	rval = qla24xx_protect_flash(vha);
+ 	if (rval) {
+ 		qla81xx_fac_semaphore_access(vha, FAC_SEMAPHORE_UNLOCK);
+ 		ql_log(ql_log_warn, vha, 0x7099,
+ 		    "Failed protect flash\n");
+ 	}
+ 
+ 	if (reset_to_rom == true) {
+ 		/* Schedule DPC to restart the RISC */
+ 		set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
+ 		qla2xxx_wake_dpc(vha);
+ 
+ 		rval = qla2x00_wait_for_hba_online(vha);
+ 		if (rval != QLA_SUCCESS)
+ 			ql_log(ql_log_warn, vha, 0xffff,
+ 			    "Adapter did not come out of reset\n");
+ 	}
+ 
+ done:
+ 	if (optrom)
+ 		dma_free_coherent(&ha->pdev->dev,
+ 		    OPTROM_BURST_SIZE, optrom, optrom_dma);
+ 
+ 	return rval;
+ }
+ 
++>>>>>>> c868907e1ac6 (scsi: qla2xxx: Fix incorrect SFUB length used for Secure Flash Update MB Cmd)
  int
 -qla24xx_write_optrom_data(struct scsi_qla_host *vha, void *buf,
 +qla24xx_write_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,
      uint32_t offset, uint32_t length)
  {
  	int rval;
* Unmerged path drivers/scsi/qla2xxx/qla_sup.c
