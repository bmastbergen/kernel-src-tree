KVM: X86: Introduce kvm_get_msr_feature()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Wanpeng Li <wanpengli@tencent.com>
commit 66421c1ec340096b291af763ed5721314cdd9c5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/66421c1e.failed

Introduce kvm_get_msr_feature() to handle the msrs which are supported
by different vendors and sharing the same emulation logic.

	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Radim Krčmář <rkrcmar@redhat.com>
	Cc: Liran Alon <liran.alon@oracle.com>
	Cc: Nadav Amit <nadav.amit@gmail.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: Wanpeng Li <wanpengli@tencent.com>
	Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit 66421c1ec340096b291af763ed5721314cdd9c5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index 69feb8491cac,d97620eeb394..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -1039,6 -1049,41 +1039,44 @@@ static u32 emulated_msrs[] = 
  
  static unsigned num_emulated_msrs;
  
++<<<<<<< HEAD
++=======
+ /*
+  * List of msr numbers which are used to expose MSR-based features that
+  * can be used by a hypervisor to validate requested CPU features.
+  */
+ static u32 msr_based_features[] = {
+ 	MSR_F10H_DECFG,
+ };
+ 
+ static unsigned int num_msr_based_features;
+ 
+ static int kvm_get_msr_feature(struct kvm_msr_entry *msr)
+ {
+ 	switch (msr->index) {
+ 	default:
+ 		if (kvm_x86_ops->get_msr_feature(msr))
+ 			return 1;
+ 	}
+ 	return 0;
+ }
+ 
+ static int do_get_msr_feature(struct kvm_vcpu *vcpu, unsigned index, u64 *data)
+ {
+ 	struct kvm_msr_entry msr;
+ 	int r;
+ 
+ 	msr.index = index;
+ 	r = kvm_get_msr_feature(&msr);
+ 	if (r)
+ 		return r;
+ 
+ 	*data = msr.data;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 66421c1ec340 (KVM: X86: Introduce kvm_get_msr_feature())
  bool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)
  {
  	if (efer & efer_reserved_bits)
@@@ -4260,6 -4529,19 +4298,22 @@@ static void kvm_init_msr_list(void
  		j++;
  	}
  	num_emulated_msrs = j;
++<<<<<<< HEAD
++=======
+ 
+ 	for (i = j = 0; i < ARRAY_SIZE(msr_based_features); i++) {
+ 		struct kvm_msr_entry msr;
+ 
+ 		msr.index = msr_based_features[i];
+ 		if (kvm_get_msr_feature(&msr))
+ 			continue;
+ 
+ 		if (j < i)
+ 			msr_based_features[j] = msr_based_features[i];
+ 		j++;
+ 	}
+ 	num_msr_based_features = j;
++>>>>>>> 66421c1ec340 (KVM: X86: Introduce kvm_get_msr_feature())
  }
  
  static int vcpu_mmio_write(struct kvm_vcpu *vcpu, gpa_t addr, int len,
* Unmerged path arch/x86/kvm/x86.c
