gfs2: time journal recovery steps accurately

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Abhi Das <adas@redhat.com>
commit 5e86d9d122d0d6fae00d9dff41c22d6f4d09f566
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/5e86d9d1.failed

This patch spits out the time taken by the various steps in the
journal recover process. Previously, the journal recovery time
didn't account for finding the journal head in the log which takes
up a significant portion of time.

	Signed-off-by: Abhi Das <adas@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 5e86d9d122d0d6fae00d9dff41c22d6f4d09f566)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/recovery.c
diff --cc fs/gfs2/recovery.c
index 489aaf82cabb,d8b622c375ab..000000000000
--- a/fs/gfs2/recovery.c
+++ b/fs/gfs2/recovery.c
@@@ -14,6 -14,8 +14,11 @@@
  #include <linux/buffer_head.h>
  #include <linux/gfs2_ondisk.h>
  #include <linux/crc32.h>
++<<<<<<< HEAD
++=======
+ #include <linux/crc32c.h>
+ #include <linux/ktime.h>
++>>>>>>> 5e86d9d122d0 (gfs2: time journal recovery steps accurately)
  
  #include "gfs2.h"
  #include "incore.h"
@@@ -454,16 -409,16 +459,27 @@@ void gfs2_recover_func(struct work_stru
  	struct gfs2_inode *ip = GFS2_I(jd->jd_inode);
  	struct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);
  	struct gfs2_log_header_host head;
++<<<<<<< HEAD
 +	struct gfs2_holder j_gh, ji_gh, t_gh;
 +	unsigned long t;
++=======
+ 	struct gfs2_holder j_gh, ji_gh, thaw_gh;
+ 	ktime_t t_start, t_jlck, t_jhd, t_tlck, t_rep;
++>>>>>>> 5e86d9d122d0 (gfs2: time journal recovery steps accurately)
  	int ro = 0;
  	unsigned int pass;
 -	int error;
 +	int error = 0;
  	int jlocked = 0;
  
++<<<<<<< HEAD
 +	if (sdp->sd_args.ar_spectator)
 +		goto fail;
 +	if (jd->jd_jid != sdp->sd_lockstruct.ls_jid) {
++=======
+ 	t_start = ktime_get();
+ 	if (sdp->sd_args.ar_spectator ||
+ 	    (jd->jd_jid != sdp->sd_lockstruct.ls_jid)) {
++>>>>>>> 5e86d9d122d0 (gfs2: time journal recovery steps accurately)
  		fs_info(sdp, "jid=%u: Trying to acquire journal lock...\n",
  			jd->jd_jid);
  		jlocked = 1;
@@@ -507,13 -464,11 +525,17 @@@
  		fs_info(sdp, "jid=%u: Acquiring the transaction lock...\n",
  			jd->jd_jid);
  
++<<<<<<< HEAD
 +		t = jiffies;
 +
 +		/* Acquire a shared hold on the transaction lock */
++=======
+ 		/* Acquire a shared hold on the freeze lock */
++>>>>>>> 5e86d9d122d0 (gfs2: time journal recovery steps accurately)
  
 -		error = gfs2_glock_nq_init(sdp->sd_freeze_gl, LM_ST_SHARED,
 -					   LM_FLAG_NOEXP | LM_FLAG_PRIORITY,
 -					   &thaw_gh);
 +		error = gfs2_glock_nq_init(sdp->sd_trans_gl, LM_ST_SHARED,
 +					   LM_FLAG_NOEXP | LM_FLAG_PRIORITY |
 +					   GL_NOCACHE, &t_gh);
  		if (error)
  			goto fail_gunlock_ji;
  
@@@ -539,9 -494,10 +561,10 @@@
  			fs_warn(sdp, "jid=%u: Can't replay: read-only block "
  				"device\n", jd->jd_jid);
  			error = -EROFS;
 -			goto fail_gunlock_thaw;
 +			goto fail_gunlock_tr;
  		}
  
+ 		t_tlck = ktime_get();
  		fs_info(sdp, "jid=%u: Replaying journal...\n", jd->jd_jid);
  
  		for (pass = 0; pass < 2; pass++) {
@@@ -550,17 -506,20 +573,29 @@@
  						   head.lh_blkno, pass);
  			lops_after_scan(jd, error, pass);
  			if (error)
 -				goto fail_gunlock_thaw;
 +				goto fail_gunlock_tr;
  		}
  
 -		clean_journal(jd, &head);
 -
 +		error = clean_journal(jd, &head);
 +		if (error)
 +			goto fail_gunlock_tr;
 +
++<<<<<<< HEAD
 +		gfs2_glock_dq_uninit(&t_gh);
 +		t = DIV_ROUND_UP(jiffies - t, HZ);
 +		fs_info(sdp, "jid=%u: Journal replayed in %lus\n",
 +			jd->jd_jid, t);
++=======
+ 		gfs2_glock_dq_uninit(&thaw_gh);
+ 		t_rep = ktime_get();
+ 		fs_info(sdp, "jid=%u: Journal replayed in %lldms [jlck:%lldms, "
+ 			"jhead:%lldms, tlck:%lldms, replay:%lldms]\n",
+ 			jd->jd_jid, ktime_ms_delta(t_rep, t_start),
+ 			ktime_ms_delta(t_jlck, t_start),
+ 			ktime_ms_delta(t_jhd, t_jlck),
+ 			ktime_ms_delta(t_tlck, t_jhd),
+ 			ktime_ms_delta(t_rep, t_tlck));
++>>>>>>> 5e86d9d122d0 (gfs2: time journal recovery steps accurately)
  	}
  
  	gfs2_recovery_done(sdp, jd->jd_jid, LM_RD_SUCCESS);
* Unmerged path fs/gfs2/recovery.c
