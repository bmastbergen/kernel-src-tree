netfilter: xt_bpf: add overflow checks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Jann Horn <jannh@google.com>
commit 6ab405114b0b229151ef06f4e31c7834dd09d0c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/6ab40511.failed

Check whether inputs from userspace are too long (explicit length field too
big or string not null-terminated) to avoid out-of-bounds reads.

As far as I can tell, this can at worst lead to very limited kernel heap
memory disclosure or oopses.

This bug can be triggered by an unprivileged user even if the xt_bpf module
is not loaded: iptables is available in network namespaces, and the xt_bpf
module can be autoloaded.

Triggering the bug with a classic BPF filter with fake length 0x1000 causes
the following KASAN report:

==================================================================
BUG: KASAN: slab-out-of-bounds in bpf_prog_create+0x84/0xf0
Read of size 32768 at addr ffff8801eff2c494 by task test/4627

CPU: 0 PID: 4627 Comm: test Not tainted 4.15.0-rc1+ #1
[...]
Call Trace:
 dump_stack+0x5c/0x85
 print_address_description+0x6a/0x260
 kasan_report+0x254/0x370
 ? bpf_prog_create+0x84/0xf0
 memcpy+0x1f/0x50
 bpf_prog_create+0x84/0xf0
 bpf_mt_check+0x90/0xd6 [xt_bpf]
[...]
Allocated by task 4627:
 kasan_kmalloc+0xa0/0xd0
 __kmalloc_node+0x47/0x60
 xt_alloc_table_info+0x41/0x70 [x_tables]
[...]
The buggy address belongs to the object at ffff8801eff2c3c0
                which belongs to the cache kmalloc-2048 of size 2048
The buggy address is located 212 bytes inside of
                2048-byte region [ffff8801eff2c3c0, ffff8801eff2cbc0)
[...]
==================================================================

Fixes: e6f30c731718 ("netfilter: x_tables: add xt_bpf match")
	Signed-off-by: Jann Horn <jannh@google.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 6ab405114b0b229151ef06f4e31c7834dd09d0c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/xt_bpf.c
diff --cc net/netfilter/xt_bpf.c
index 12d4da8e6c77,1f7fbd3c7e5a..000000000000
--- a/net/netfilter/xt_bpf.c
+++ b/net/netfilter/xt_bpf.c
@@@ -20,14 -22,18 +20,24 @@@ MODULE_LICENSE("GPL")
  MODULE_ALIAS("ipt_bpf");
  MODULE_ALIAS("ip6t_bpf");
  
 -static int __bpf_mt_check_bytecode(struct sock_filter *insns, __u16 len,
 -				   struct bpf_prog **ret)
 +static int bpf_mt_check(const struct xt_mtchk_param *par)
  {
 -	struct sock_fprog_kern program;
 +	struct xt_bpf_info *info = par->matchinfo;
 +	struct sock_fprog program;
  
++<<<<<<< HEAD
 +	program.len = info->bpf_program_num_elem;
 +	program.filter = (struct sock_filter __user *) info->bpf_program;
 +	if (sk_unattached_filter_create(&info->filter, &program)) {
++=======
+ 	if (len > XT_BPF_MAX_NUM_INSTR)
+ 		return -EINVAL;
+ 
+ 	program.len = len;
+ 	program.filter = insns;
+ 
+ 	if (bpf_prog_create(ret, &program)) {
++>>>>>>> 6ab405114b0b (netfilter: xt_bpf: add overflow checks)
  		pr_info("bpf: check failed: parse error\n");
  		return -EINVAL;
  	}
@@@ -35,6 -41,62 +45,65 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int __bpf_mt_check_fd(int fd, struct bpf_prog **ret)
+ {
+ 	struct bpf_prog *prog;
+ 
+ 	prog = bpf_prog_get_type(fd, BPF_PROG_TYPE_SOCKET_FILTER);
+ 	if (IS_ERR(prog))
+ 		return PTR_ERR(prog);
+ 
+ 	*ret = prog;
+ 	return 0;
+ }
+ 
+ static int __bpf_mt_check_path(const char *path, struct bpf_prog **ret)
+ {
+ 	mm_segment_t oldfs = get_fs();
+ 	int retval, fd;
+ 
+ 	if (strnlen(path, XT_BPF_PATH_MAX) == XT_BPF_PATH_MAX)
+ 		return -EINVAL;
+ 
+ 	set_fs(KERNEL_DS);
+ 	fd = bpf_obj_get_user(path, 0);
+ 	set_fs(oldfs);
+ 	if (fd < 0)
+ 		return fd;
+ 
+ 	retval = __bpf_mt_check_fd(fd, ret);
+ 	sys_close(fd);
+ 	return retval;
+ }
+ 
+ static int bpf_mt_check(const struct xt_mtchk_param *par)
+ {
+ 	struct xt_bpf_info *info = par->matchinfo;
+ 
+ 	return __bpf_mt_check_bytecode(info->bpf_program,
+ 				       info->bpf_program_num_elem,
+ 				       &info->filter);
+ }
+ 
+ static int bpf_mt_check_v1(const struct xt_mtchk_param *par)
+ {
+ 	struct xt_bpf_info_v1 *info = par->matchinfo;
+ 
+ 	if (info->mode == XT_BPF_MODE_BYTECODE)
+ 		return __bpf_mt_check_bytecode(info->bpf_program,
+ 					       info->bpf_program_num_elem,
+ 					       &info->filter);
+ 	else if (info->mode == XT_BPF_MODE_FD_ELF)
+ 		return __bpf_mt_check_fd(info->fd, &info->filter);
+ 	else if (info->mode == XT_BPF_MODE_PATH_PINNED)
+ 		return __bpf_mt_check_path(info->path, &info->filter);
+ 	else
+ 		return -EINVAL;
+ }
+ 
++>>>>>>> 6ab405114b0b (netfilter: xt_bpf: add overflow checks)
  static bool bpf_mt(const struct sk_buff *skb, struct xt_action_param *par)
  {
  	const struct xt_bpf_info *info = par->matchinfo;
* Unmerged path net/netfilter/xt_bpf.c
