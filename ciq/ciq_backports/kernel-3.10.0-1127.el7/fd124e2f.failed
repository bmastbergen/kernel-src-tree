ipvs: Pass ipvs not net to make_receive_sock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit fd124e2f8bb2ff94a1547a8f1d9741e7ffef1bbb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/fd124e2f.failed

	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
	Acked-by: Julian Anastasov <ja@ssi.bg>
	Signed-off-by: Simon Horman <horms@verge.net.au>
(cherry picked from commit fd124e2f8bb2ff94a1547a8f1d9741e7ffef1bbb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipvs/ip_vs_sync.c
diff --cc net/netfilter/ipvs/ip_vs_sync.c
index ab0e9562476c,304eade977d2..000000000000
--- a/net/netfilter/ipvs/ip_vs_sync.c
+++ b/net/netfilter/ipvs/ip_vs_sync.c
@@@ -1483,20 -1549,16 +1483,24 @@@ error
  /*
   *      Set up receiving multicast socket over UDP
   */
- static struct socket *make_receive_sock(struct net *net, int id)
+ static struct socket *make_receive_sock(struct netns_ipvs *ipvs, int id)
  {
- 	struct netns_ipvs *ipvs = net_ipvs(net);
  	/* multicast addr */
 -	union ipvs_sockaddr mcast_addr;
 +	struct sockaddr_in mcast_addr = {
 +		.sin_family		= AF_INET,
 +		.sin_port		= cpu_to_be16(IP_VS_SYNC_PORT + id),
 +		.sin_addr.s_addr	= cpu_to_be32(IP_VS_SYNC_GROUP),
 +	};
  	struct socket *sock;
 -	int result, salen;
 +	int result;
  
  	/* First create a socket */
++<<<<<<< HEAD
 +	result = sock_create_kern(PF_INET, SOCK_DGRAM, IPPROTO_UDP, &sock);
++=======
+ 	result = sock_create_kern(ipvs->net, ipvs->bcfg.mcast_af, SOCK_DGRAM,
+ 				  IPPROTO_UDP, &sock);
++>>>>>>> fd124e2f8bb2 (ipvs: Pass ipvs not net to make_receive_sock)
  	if (result < 0) {
  		pr_err("Error during creation of socket; terminating\n");
  		return ERR_PTR(result);
@@@ -1784,9 -1870,9 +1788,13 @@@ int start_sync_thread(struct net *net, 
  	tinfo = NULL;
  	for (id = 0; id < count; id++) {
  		if (state == IP_VS_STATE_MASTER)
 -			sock = make_send_sock(ipvs, id);
 +			sock = make_send_sock(net, id);
  		else
++<<<<<<< HEAD
 +			sock = make_receive_sock(net, id);
++=======
+ 			sock = make_receive_sock(ipvs, id);
++>>>>>>> fd124e2f8bb2 (ipvs: Pass ipvs not net to make_receive_sock)
  		if (IS_ERR(sock)) {
  			result = PTR_ERR(sock);
  			goto outtinfo;
* Unmerged path net/netfilter/ipvs/ip_vs_sync.c
