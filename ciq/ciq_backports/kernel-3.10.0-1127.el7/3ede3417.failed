x86/efi: Replace efi_pgd with efi_mm.pgd

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Sai Praneeth <sai.praneeth.prakhya@intel.com>
commit 3ede3417f8d59fff5c07339b310b343468c81b07
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/3ede3417.failed

Since the previous patch added support for efi_mm, let's handle efi_pgd
through efi_mm and remove global variable efi_pgd.

	Tested-by: Bhupesh Sharma <bhsharma@redhat.com>
	Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
	Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Lee, Chun-Yi <jlee@suse.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Michael S. Tsirkin <mst@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Ravi Shankar <ravi.v.shankar@intel.com>
	Cc: Ricardo Neri <ricardo.neri@intel.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: linux-efi@vger.kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 3ede3417f8d59fff5c07339b310b343468c81b07)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/debug_pagetables.c
#	arch/x86/platform/efi/efi_64.c
diff --cc arch/x86/platform/efi/efi_64.c
index 66a949fa7d66,29b267b8cb63..000000000000
--- a/arch/x86/platform/efi/efi_64.c
+++ b/arch/x86/platform/efi/efi_64.c
@@@ -153,7 -191,7 +153,11 @@@ void __init efi_call_phys_epilog(pgd_t 
  	early_code_mapping_set_exec(0);
  }
  
++<<<<<<< HEAD
 +static pgd_t *efi_pgd;
++=======
+ EXPORT_SYMBOL_GPL(efi_mm);
++>>>>>>> 3ede3417f8d5 (x86/efi: Replace efi_pgd with efi_mm.pgd)
  
  /*
   * We need our own copy of the higher levels of the page tables
@@@ -163,7 -201,11 +167,12 @@@
   */
  int __init efi_alloc_page_tables(void)
  {
++<<<<<<< HEAD
 +	pgd_t *pgd;
++=======
+ 	pgd_t *pgd, *efi_pgd;
+ 	p4d_t *p4d;
++>>>>>>> 3ede3417f8d5 (x86/efi: Replace efi_pgd with efi_mm.pgd)
  	pud_t *pud;
  	gfp_t gfp_mask;
  
@@@ -183,7 -232,9 +192,13 @@@
  		return -ENOMEM;
  	}
  
++<<<<<<< HEAD
 +	pgd_populate(NULL, pgd, pud);
++=======
+ 	efi_mm.pgd = efi_pgd;
+ 	mm_init_cpumask(&efi_mm);
+ 	init_new_context(NULL, &efi_mm);
++>>>>>>> 3ede3417f8d5 (x86/efi: Replace efi_pgd with efi_mm.pgd)
  
  	return 0;
  }
@@@ -195,7 -246,9 +210,8 @@@ void efi_sync_low_kernel_mappings(void
  {
  	unsigned num_entries;
  	pgd_t *pgd_k, *pgd_efi;
 -	p4d_t *p4d_k, *p4d_efi;
  	pud_t *pud_k, *pud_efi;
+ 	pgd_t *efi_pgd = efi_mm.pgd;
  
  	if (efi_enabled(EFI_OLD_MEMMAP))
  		return;
@@@ -244,9 -311,38 +260,13 @@@
  int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)
  {
  	unsigned long pfn, text, pf;
 -	struct page *page;
  	unsigned npages;
++<<<<<<< HEAD
 +	struct page *page;
 +	pgd_t *pgd;
++=======
+ 	pgd_t *pgd = efi_mm.pgd;
++>>>>>>> 3ede3417f8d5 (x86/efi: Replace efi_pgd with efi_mm.pgd)
  
  	if (efi_enabled(EFI_OLD_MEMMAP))
  		return 0;
@@@ -407,10 -523,107 +426,114 @@@ void __init parse_efi_setup(u64 phys_ad
  	efi_setup = phys_addr + sizeof(struct setup_data);
  }
  
++<<<<<<< HEAD
 +void __init efi_dump_pagetable(void)
 +{
 +#ifdef CONFIG_EFI_PGT_DUMP
 +	ptdump_walk_pgd_level(NULL, efi_pgd);
++=======
+ static int __init efi_update_mappings(efi_memory_desc_t *md, unsigned long pf)
+ {
+ 	unsigned long pfn;
+ 	pgd_t *pgd = efi_mm.pgd;
+ 	int err1, err2;
+ 
+ 	/* Update the 1:1 mapping */
+ 	pfn = md->phys_addr >> PAGE_SHIFT;
+ 	err1 = kernel_map_pages_in_pgd(pgd, pfn, md->phys_addr, md->num_pages, pf);
+ 	if (err1) {
+ 		pr_err("Error while updating 1:1 mapping PA 0x%llx -> VA 0x%llx!\n",
+ 			   md->phys_addr, md->virt_addr);
+ 	}
+ 
+ 	err2 = kernel_map_pages_in_pgd(pgd, pfn, md->virt_addr, md->num_pages, pf);
+ 	if (err2) {
+ 		pr_err("Error while updating VA mapping PA 0x%llx -> VA 0x%llx!\n",
+ 			   md->phys_addr, md->virt_addr);
+ 	}
+ 
+ 	return err1 || err2;
+ }
+ 
+ static int __init efi_update_mem_attr(struct mm_struct *mm, efi_memory_desc_t *md)
+ {
+ 	unsigned long pf = 0;
+ 
+ 	if (md->attribute & EFI_MEMORY_XP)
+ 		pf |= _PAGE_NX;
+ 
+ 	if (!(md->attribute & EFI_MEMORY_RO))
+ 		pf |= _PAGE_RW;
+ 
+ 	if (sev_active())
+ 		pf |= _PAGE_ENC;
+ 
+ 	return efi_update_mappings(md, pf);
+ }
+ 
+ void __init efi_runtime_update_mappings(void)
+ {
+ 	efi_memory_desc_t *md;
+ 
+ 	if (efi_enabled(EFI_OLD_MEMMAP)) {
+ 		if (__supported_pte_mask & _PAGE_NX)
+ 			runtime_code_page_mkexec();
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * Use the EFI Memory Attribute Table for mapping permissions if it
+ 	 * exists, since it is intended to supersede EFI_PROPERTIES_TABLE.
+ 	 */
+ 	if (efi_enabled(EFI_MEM_ATTR)) {
+ 		efi_memattr_apply_permissions(NULL, efi_update_mem_attr);
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * EFI_MEMORY_ATTRIBUTES_TABLE is intended to replace
+ 	 * EFI_PROPERTIES_TABLE. So, use EFI_PROPERTIES_TABLE to update
+ 	 * permissions only if EFI_MEMORY_ATTRIBUTES_TABLE is not
+ 	 * published by the firmware. Even if we find a buggy implementation of
+ 	 * EFI_MEMORY_ATTRIBUTES_TABLE, don't fall back to
+ 	 * EFI_PROPERTIES_TABLE, because of the same reason.
+ 	 */
+ 
+ 	if (!efi_enabled(EFI_NX_PE_DATA))
+ 		return;
+ 
+ 	for_each_efi_memory_desc(md) {
+ 		unsigned long pf = 0;
+ 
+ 		if (!(md->attribute & EFI_MEMORY_RUNTIME))
+ 			continue;
+ 
+ 		if (!(md->attribute & EFI_MEMORY_WB))
+ 			pf |= _PAGE_PCD;
+ 
+ 		if ((md->attribute & EFI_MEMORY_XP) ||
+ 			(md->type == EFI_RUNTIME_SERVICES_DATA))
+ 			pf |= _PAGE_NX;
+ 
+ 		if (!(md->attribute & EFI_MEMORY_RO) &&
+ 			(md->type != EFI_RUNTIME_SERVICES_CODE))
+ 			pf |= _PAGE_RW;
+ 
+ 		if (sev_active())
+ 			pf |= _PAGE_ENC;
+ 
+ 		efi_update_mappings(md, pf);
+ 	}
+ }
+ 
+ void __init efi_dump_pagetable(void)
+ {
+ #ifdef CONFIG_EFI_PGT_DUMP
+ 	if (efi_enabled(EFI_OLD_MEMMAP))
+ 		ptdump_walk_pgd_level(NULL, swapper_pg_dir);
+ 	else
+ 		ptdump_walk_pgd_level(NULL, efi_mm.pgd);
++>>>>>>> 3ede3417f8d5 (x86/efi: Replace efi_pgd with efi_mm.pgd)
  #endif
  }
  
* Unmerged path arch/x86/mm/debug_pagetables.c
* Unmerged path arch/x86/mm/debug_pagetables.c
* Unmerged path arch/x86/platform/efi/efi_64.c
