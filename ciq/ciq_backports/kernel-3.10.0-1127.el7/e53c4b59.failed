xfs: ensure post-EOF zeroing happens after zeroing part of a file

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit e53c4b598372001a13901b77649dc1b4afec3e85
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/e53c4b59.failed

If a user asks us to zero_range part of a file, the end of the range is
EOF, and not aligned to a page boundary, invoke writeback of the EOF
page to ensure that the post-EOF part of the page is zeroed.  This
ensures that we don't expose stale memory contents via mmap, if in a
clumsy manner.

Found by running generic/127 when it runs zero_range and mapread at EOF
one after the other.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Allison Henderson <allison.henderson@oracle.com>
(cherry picked from commit e53c4b598372001a13901b77649dc1b4afec3e85)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_bmap_util.c
diff --cc fs/xfs/xfs_bmap_util.c
index fb4da4b82f8d,83b1e8c6c18f..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -1152,18 -1179,30 +1152,37 @@@ xfs_free_file_space
  
  	/*
  	 * Now that we've unmap all full blocks we'll have to zero out any
 -	 * partial block at the beginning and/or end.  iomap_zero_range is smart
 -	 * enough to skip any holes, including those we just created, but we
 -	 * must take care not to zero beyond EOF and enlarge i_size.
 +	 * partial block at the beginning and/or end.  xfs_zero_range is
 +	 * smart enough to skip any holes, including those we just created,
 +	 * but we must take care not to zero beyond EOF and enlarge i_size.
  	 */
 +
  	if (offset >= XFS_ISIZE(ip))
  		return 0;
 +
  	if (offset + len > XFS_ISIZE(ip))
  		len = XFS_ISIZE(ip) - offset;
++<<<<<<< HEAD
 +
 +	return xfs_zero_range(ip, offset, len, NULL);
++=======
+ 	error = iomap_zero_range(VFS_I(ip), offset, len, NULL, &xfs_iomap_ops);
+ 	if (error)
+ 		return error;
+ 
+ 	/*
+ 	 * If we zeroed right up to EOF and EOF straddles a page boundary we
+ 	 * must make sure that the post-EOF area is also zeroed because the
+ 	 * page could be mmap'd and iomap_zero_range doesn't do that for us.
+ 	 * Writeback of the eof page will do this, albeit clumsily.
+ 	 */
+ 	if (offset + len >= XFS_ISIZE(ip) && ((offset + len) & PAGE_MASK)) {
+ 		error = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,
+ 				(offset + len) & ~PAGE_MASK, LLONG_MAX);
+ 	}
+ 
+ 	return error;
++>>>>>>> e53c4b598372 (xfs: ensure post-EOF zeroing happens after zeroing part of a file)
  }
  
  /*
* Unmerged path fs/xfs/xfs_bmap_util.c
