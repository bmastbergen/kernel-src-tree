kvm: Add helper function for creating VM worker threads

jira LE-1907
cve CVE-2018-12207
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Junaid Shahid <junaids@google.com>
commit c57c80467f90e5504c8df9ad3555d2c78800bf94
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/c57c8046.failed

Add a function to create a kernel thread associated with a given VM. In
particular, it ensures that the worker thread inherits the priority and
cgroups of the calling thread.

	Signed-off-by: Junaid Shahid <junaids@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit c57c80467f90e5504c8df9ad3555d2c78800bf94)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/kvm_host.h
#	virt/kvm/kvm_main.c
diff --cc include/linux/kvm_host.h
index fbc35bbaa5a0,52ed5f66e8f9..000000000000
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@@ -1226,4 -1334,58 +1226,61 @@@ int kvm_arch_update_irqfd_routing(struc
  				  uint32_t guest_irq, bool set);
  #endif /* CONFIG_HAVE_KVM_IRQ_BYPASS */
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_HAVE_KVM_INVALID_WAKEUPS
+ /* If we wakeup during the poll time, was it a sucessful poll? */
+ static inline bool vcpu_valid_wakeup(struct kvm_vcpu *vcpu)
+ {
+ 	return vcpu->valid_wakeup;
+ }
+ 
+ #else
+ static inline bool vcpu_valid_wakeup(struct kvm_vcpu *vcpu)
+ {
+ 	return true;
+ }
+ #endif /* CONFIG_HAVE_KVM_INVALID_WAKEUPS */
+ 
+ #ifdef CONFIG_HAVE_KVM_NO_POLL
+ /* Callback that tells if we must not poll */
+ bool kvm_arch_no_poll(struct kvm_vcpu *vcpu);
+ #else
+ static inline bool kvm_arch_no_poll(struct kvm_vcpu *vcpu)
+ {
+ 	return false;
+ }
+ #endif /* CONFIG_HAVE_KVM_NO_POLL */
+ 
+ #ifdef CONFIG_HAVE_KVM_VCPU_ASYNC_IOCTL
+ long kvm_arch_vcpu_async_ioctl(struct file *filp,
+ 			       unsigned int ioctl, unsigned long arg);
+ #else
+ static inline long kvm_arch_vcpu_async_ioctl(struct file *filp,
+ 					     unsigned int ioctl,
+ 					     unsigned long arg)
+ {
+ 	return -ENOIOCTLCMD;
+ }
+ #endif /* CONFIG_HAVE_KVM_VCPU_ASYNC_IOCTL */
+ 
+ int kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,
+ 		unsigned long start, unsigned long end, bool blockable);
+ 
+ #ifdef CONFIG_HAVE_KVM_VCPU_RUN_PID_CHANGE
+ int kvm_arch_vcpu_run_pid_change(struct kvm_vcpu *vcpu);
+ #else
+ static inline int kvm_arch_vcpu_run_pid_change(struct kvm_vcpu *vcpu)
+ {
+ 	return 0;
+ }
+ #endif /* CONFIG_HAVE_KVM_VCPU_RUN_PID_CHANGE */
+ 
+ typedef int (*kvm_vm_thread_fn_t)(struct kvm *kvm, uintptr_t data);
+ 
+ int kvm_vm_create_worker_thread(struct kvm *kvm, kvm_vm_thread_fn_t thread_fn,
+ 				uintptr_t data, const char *name,
+ 				struct task_struct **thread_ptr);
+ 
++>>>>>>> c57c80467f90 (kvm: Add helper function for creating VM worker threads)
  #endif
diff --cc virt/kvm/kvm_main.c
index af3df0f2e28f,8aed32b604d9..000000000000
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@@ -49,11 -48,13 +49,17 @@@
  #include <linux/slab.h>
  #include <linux/sort.h>
  #include <linux/bsearch.h>
++<<<<<<< HEAD
++=======
+ #include <linux/io.h>
+ #include <linux/lockdep.h>
+ #include <linux/kthread.h>
++>>>>>>> c57c80467f90 (kvm: Add helper function for creating VM worker threads)
  
  #include <asm/processor.h>
 +#include <asm/io.h>
  #include <asm/ioctl.h>
 -#include <linux/uaccess.h>
 +#include <asm/uaccess.h>
  #include <asm/pgtable.h>
  
  #include "coalesced_mmio.h"
* Unmerged path include/linux/kvm_host.h
* Unmerged path virt/kvm/kvm_main.c
