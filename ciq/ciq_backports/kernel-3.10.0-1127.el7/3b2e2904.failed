net: bridge: fix per-port af_packet sockets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [net] bridge: fix per-port af_packet sockets (Hangbin Liu) [1749658]
Rebuild_FUZZ: 93.83%
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit 3b2e2904deb314cc77a2192f506f2fd44e3d10d0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/3b2e2904.failed

When the commit below was introduced it changed two visible things:
 - the skb was no longer passed through the protocol handlers with the
   original device
 - the skb was passed up the stack with skb->dev = bridge

The first change broke af_packet sockets on bridge ports. For example we
use them for hostapd which listens for ETH_P_PAE packets on the ports.
We discussed two possible fixes:
 - create a clone and pass it through NF_HOOK(), act on the original skb
   based on the result
 - somehow signal to the caller from the okfn() that it was called,
   meaning the skb is ok to be passed, which this patch is trying to
   implement via returning 1 from the bridge link-local okfn()

Note that we rely on the fact that NF_QUEUE/STOLEN would return 0 and
drop/error would return < 0 thus the okfn() is called only when the
return was 1, so we signal to the caller that it was called by preserving
the return value from nf_hook().

Fixes: 8626c56c8279 ("bridge: fix potential use-after-free when hook returns QUEUE or STOLEN verdict")
	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3b2e2904deb314cc77a2192f506f2fd44e3d10d0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_input.c
diff --cc net/bridge/br_input.c
index 5d32cede38c6,ba303ee99b9b..000000000000
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@@ -233,15 -195,12 +233,12 @@@ static void __br_handle_local_finish(st
  }
  
  /* note: already called with rcu_read_lock */
 -static int br_handle_local_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
 +static int br_handle_local_finish(struct sock *sk, struct sk_buff *skb)
  {
- 	struct net_bridge_port *p = br_port_get_rcu(skb->dev);
- 
  	__br_handle_local_finish(skb);
  
- 	BR_INPUT_SKB_CB(skb)->brdev = p->br->dev;
- 	br_pass_frame_up(skb);
- 	return 0;
+ 	/* return 1 to signal the okfn() was called so it's ok to use the skb */
+ 	return 1;
  }
  
  /*
@@@ -317,10 -277,18 +314,25 @@@ rx_handler_result_t br_handle_frame(str
  				goto forward;
  		}
  
++<<<<<<< HEAD
 +		/* Deliver packet to local host only */
 +		NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, NULL, skb,
 +			skb->dev, NULL, br_handle_local_finish);
 +		return RX_HANDLER_CONSUMED; /* consumed by filter */
++=======
+ 		/* The else clause should be hit when nf_hook():
+ 		 *   - returns < 0 (drop/error)
+ 		 *   - returns = 0 (stolen/nf_queue)
+ 		 * Thus return 1 from the okfn() to signal the skb is ok to pass
+ 		 */
+ 		if (NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,
+ 			    dev_net(skb->dev), NULL, skb, skb->dev, NULL,
+ 			    br_handle_local_finish) == 1) {
+ 			return RX_HANDLER_PASS;
+ 		} else {
+ 			return RX_HANDLER_CONSUMED;
+ 		}
++>>>>>>> 3b2e2904deb3 (net: bridge: fix per-port af_packet sockets)
  	}
  
  forward:
* Unmerged path net/bridge/br_input.c
