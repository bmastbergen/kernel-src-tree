mm: introduce kmemleak_update_trace()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [mm] mm: kmemleak: introduce kmemleak_update_trace() (Rafael Aquini) [1618438]
Rebuild_FUZZ: 88.10%
commit-author Catalin Marinas <catalin.marinas@arm.com>
commit ffe2c748e283c5dc1b9b9ac116299dbfc11a609b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/ffe2c748.failed

The memory allocation stack trace is not always useful for debugging a
memory leak (e.g.  radix_tree_preload).  This function, when called,
updates the stack trace for an already allocated object.

	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ffe2c748e283c5dc1b9b9ac116299dbfc11a609b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/kmemleak.h
diff --cc include/linux/kmemleak.h
index c3bcbb6a913b,057e95971014..000000000000
--- a/include/linux/kmemleak.h
+++ b/include/linux/kmemleak.h
@@@ -31,8 -30,7 +31,12 @@@ extern void kmemleak_alloc_percpu(cons
  extern void kmemleak_free(const void *ptr) __ref;
  extern void kmemleak_free_part(const void *ptr, size_t size) __ref;
  extern void kmemleak_free_percpu(const void __percpu *ptr) __ref;
++<<<<<<< HEAD
 +extern void kmemleak_padding(const void *ptr, unsigned long offset,
 +			     size_t size) __ref;
++=======
+ extern void kmemleak_update_trace(const void *ptr) __ref;
++>>>>>>> ffe2c748e283 (mm: introduce kmemleak_update_trace())
  extern void kmemleak_not_leak(const void *ptr) __ref;
  extern void kmemleak_ignore(const void *ptr) __ref;
  extern void kmemleak_scan_area(const void *ptr, size_t size, gfp_t gfp) __ref;
diff --git a/Documentation/kmemleak.txt b/Documentation/kmemleak.txt
index b6e39739a36d..d5e005b08519 100644
--- a/Documentation/kmemleak.txt
+++ b/Documentation/kmemleak.txt
@@ -131,6 +131,7 @@ kmemleak_alloc_percpu	 - notify of a percpu memory block allocation
 kmemleak_free		 - notify of a memory block freeing
 kmemleak_free_part	 - notify of a partial memory block freeing
 kmemleak_free_percpu	 - notify of a percpu memory block freeing
+kmemleak_update_trace	 - update object allocation stack trace
 kmemleak_not_leak	 - mark an object as not a leak
 kmemleak_ignore		 - do not scan or report an object as leak
 kmemleak_scan_area	 - add scan areas inside a memory block
* Unmerged path include/linux/kmemleak.h
diff --git a/mm/kmemleak.c b/mm/kmemleak.c
index 8c78f1372f6b..0dc89a593958 100644
--- a/mm/kmemleak.c
+++ b/mm/kmemleak.c
@@ -987,6 +987,40 @@ void __ref kmemleak_free_percpu(const void __percpu *ptr)
 }
 EXPORT_SYMBOL_GPL(kmemleak_free_percpu);
 
+/**
+ * kmemleak_update_trace - update object allocation stack trace
+ * @ptr:	pointer to beginning of the object
+ *
+ * Override the object allocation stack trace for cases where the actual
+ * allocation place is not always useful.
+ */
+void __ref kmemleak_update_trace(const void *ptr)
+{
+	struct kmemleak_object *object;
+	unsigned long flags;
+
+	pr_debug("%s(0x%p)\n", __func__, ptr);
+
+	if (!kmemleak_enabled || IS_ERR_OR_NULL(ptr))
+		return;
+
+	object = find_and_get_object((unsigned long)ptr, 1);
+	if (!object) {
+#ifdef DEBUG
+		kmemleak_warn("Updating stack trace for unknown object at %p\n",
+			      ptr);
+#endif
+		return;
+	}
+
+	spin_lock_irqsave(&object->lock, flags);
+	object->trace_len = __save_stack_trace(object->trace);
+	spin_unlock_irqrestore(&object->lock, flags);
+
+	put_object(object);
+}
+EXPORT_SYMBOL(kmemleak_update_trace);
+
 /**
  * kmemleak_not_leak - mark an allocated object as false positive
  * @ptr:	pointer to beginning of the object
