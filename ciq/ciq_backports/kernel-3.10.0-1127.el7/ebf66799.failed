sysvipc: properly name ipc_addid() limit parameter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Davidlohr Bueso <dave@stgolabs.net>
commit ebf66799acfb5f52ada4ff96ecc9579867941ea9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/ebf66799.failed

This is better understood as a limit, instead of size; exactly like the
function comment indicates.  Rename it.

Link: http://lkml.kernel.org/r/20170831172049.14576-4-dave@stgolabs.net
	Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
	Cc: Manfred Spraul <manfred@colorfullife.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ebf66799acfb5f52ada4ff96ecc9579867941ea9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	ipc/util.c
diff --cc ipc/util.c
index 1df75a61612b,e09bf76610ef..000000000000
--- a/ipc/util.c
+++ b/ipc/util.c
@@@ -257,30 -218,69 +257,45 @@@ int ipc_get_maxid(struct ipc_ids *ids
  	return max_id;
  }
  
 -#ifdef CONFIG_CHECKPOINT_RESTORE
 -/*
 - * Specify desired id for next allocated IPC object.
 - */
 -#define ipc_idr_alloc(ids, new)						\
 -	idr_alloc(&(ids)->ipcs_idr, (new),				\
 -		  (ids)->next_id < 0 ? 0 : ipcid_to_idx((ids)->next_id),\
 -		  0, GFP_NOWAIT)
 -
 -static inline int ipc_buildid(int id, struct ipc_ids *ids,
 -			      struct kern_ipc_perm *new)
 -{
 -	if (ids->next_id < 0) { /* default, behave as !CHECKPOINT_RESTORE */
 -		new->seq = ids->seq++;
 -		if (ids->seq > IPCID_SEQ_MAX)
 -			ids->seq = 0;
 -	} else {
 -		new->seq = ipcid_to_seqx(ids->next_id);
 -		ids->next_id = -1;
 -	}
 -
 -	return SEQ_MULTIPLIER * new->seq + id;
 -}
 -
 -#else
 -#define ipc_idr_alloc(ids, new)					\
 -	idr_alloc(&(ids)->ipcs_idr, (new), 0, 0, GFP_NOWAIT)
 -
 -static inline int ipc_buildid(int id, struct ipc_ids *ids,
 -			      struct kern_ipc_perm *new)
 -{
 -	new->seq = ids->seq++;
 -	if (ids->seq > IPCID_SEQ_MAX)
 -		ids->seq = 0;
 -
 -	return SEQ_MULTIPLIER * new->seq + id;
 -}
 -
 -#endif /* CONFIG_CHECKPOINT_RESTORE */
 -
  /**
++<<<<<<< HEAD
 + *	ipc_addid 	-	add an IPC identifier
 + *	@ids: IPC identifier set
 + *	@new: new IPC permission set
 + *	@size: limit for the number of used ids
++=======
+  * ipc_addid - add an ipc identifier
+  * @ids: ipc identifier set
+  * @new: new ipc permission set
+  * @limit: limit for the number of used ids
++>>>>>>> ebf66799acfb (sysvipc: properly name ipc_addid() limit parameter)
   *
 - * Add an entry 'new' to the ipc ids idr. The permissions object is
 - * initialised and the first free entry is set up and the id assigned
 - * is returned. The 'new' entry is returned in a locked state on success.
 - * On failure the entry is not locked and a negative err-code is returned.
 + *	Add an entry 'new' to the IPC ids idr. The permissions object is
 + *	initialised and the first free entry is set up and the id assigned
 + *	is returned. The 'new' entry is returned in a locked state on success.
 + *	On failure the entry is not locked and a negative err-code is returned.
   *
 - * Called with writer ipc_ids.rwsem held.
 + *	Called with writer ipc_ids.rwsem held.
   */
++<<<<<<< HEAD
 +int ipc_addid(struct ipc_ids* ids, struct kern_ipc_perm* new, int size)
++=======
+ int ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int limit)
++>>>>>>> ebf66799acfb (sysvipc: properly name ipc_addid() limit parameter)
  {
  	kuid_t euid;
  	kgid_t egid;
 -	int id, err;
 +	int id;
 +	int next_id = ids->next_id;
  
- 	if (size > IPCMNI)
- 		size = IPCMNI;
+ 	if (limit > IPCMNI)
+ 		limit = IPCMNI;
  
++<<<<<<< HEAD
 +	if (ids->in_use >= size)
++=======
+ 	if (!ids->tables_initialized || ids->in_use >= limit)
++>>>>>>> ebf66799acfb (sysvipc: properly name ipc_addid() limit parameter)
  		return -ENOSPC;
  
  	idr_preload(GFP_KERNEL);
* Unmerged path ipc/util.c
