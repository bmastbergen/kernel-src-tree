scsi: lpfc: Fix nvmet target abort cmd matching

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author James Smart <jsmart2021@gmail.com>
commit 32b938656462dd2c4aa1e91e0b48cd114c2d00f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/32b93865.failed

After receiving an unsolicited ABTS (meaning rxid is 0xFFFF), the driver
used the oxid from the initiator to match against a local xri which may
have been allocated for the io. The xri would be the rxid - it's an invalid
check resulting in the command not being matched or erroneously matched.

Change the lookup to use the oxid and the SID to match against received
IO's original values.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <jsmart2021@gmail.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 32b938656462dd2c4aa1e91e0b48cd114c2d00f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_nvmet.c
diff --cc drivers/scsi/lpfc/lpfc_nvmet.c
index 6a1265b7c114,c9011579aa0f..000000000000
--- a/drivers/scsi/lpfc/lpfc_nvmet.c
+++ b/drivers/scsi/lpfc/lpfc_nvmet.c
@@@ -1543,8 -1561,9 +1544,9 @@@ lpfc_sli4_nvmet_xri_aborted(struct lpfc
  			lpfc_worker_wake_up(phba);
  		return;
  	}
 -	spin_unlock(&phba->sli4_hba.abts_nvmet_buf_list_lock);
 +	spin_unlock(&phba->sli4_hba.abts_nvme_buf_list_lock);
  	spin_unlock_irqrestore(&phba->hbalock, iflag);
+ #endif
  }
  
  int
@@@ -1560,16 -1579,19 +1563,23 @@@ lpfc_nvmet_rcv_unsol_abort(struct lpfc_
  	unsigned long iflag = 0;
  
  	xri = be16_to_cpu(fc_hdr->fh_ox_id);
+ 	sid = sli4_sid_from_fc_hdr(fc_hdr);
  
  	spin_lock_irqsave(&phba->hbalock, iflag);
 -	spin_lock(&phba->sli4_hba.abts_nvmet_buf_list_lock);
 +	spin_lock(&phba->sli4_hba.abts_nvme_buf_list_lock);
  	list_for_each_entry_safe(ctxp, next_ctxp,
  				 &phba->sli4_hba.lpfc_abts_nvmet_ctx_list,
  				 list) {
- 		if (ctxp->ctxbuf->sglq->sli4_xritag != xri)
+ 		if (ctxp->oxid != xri || ctxp->sid != sid)
  			continue;
  
++<<<<<<< HEAD
 +		spin_unlock(&phba->sli4_hba.abts_nvme_buf_list_lock);
++=======
+ 		xri = ctxp->ctxbuf->sglq->sli4_xritag;
+ 
+ 		spin_unlock(&phba->sli4_hba.abts_nvmet_buf_list_lock);
++>>>>>>> 32b938656462 (scsi: lpfc: Fix nvmet target abort cmd matching)
  		spin_unlock_irqrestore(&phba->hbalock, iflag);
  
  		spin_lock_irqsave(&ctxp->ctxlock, iflag);
@@@ -1594,10 -1616,10 +1604,10 @@@
  	spin_unlock_irqrestore(&phba->hbalock, iflag);
  
  	lpfc_nvmeio_data(phba, "NVMET ABTS RCV: xri x%x CPU %02x rjt %d\n",
 -			 xri, raw_smp_processor_id(), 1);
 +			 xri, smp_processor_id(), 1);
  
  	lpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,
- 			"6320 NVMET Rcv ABTS:rjt xri x%x\n", xri);
+ 			"6320 NVMET Rcv ABTS:rjt xid x%x\n", xri);
  
  	/* Respond with BA_RJT accordingly */
  	lpfc_sli4_seq_abort_rsp(vport, fc_hdr, 0);
* Unmerged path drivers/scsi/lpfc/lpfc_nvmet.c
