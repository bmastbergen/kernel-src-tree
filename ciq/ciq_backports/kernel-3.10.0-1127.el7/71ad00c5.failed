netfilter: nf_tables: fix module unload race

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Florian Westphal <fw@strlen.de>
commit 71ad00c50d77e507138c792a9646b53c16f22e11
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/71ad00c5.failed

We must first remove the nfnetlink protocol handler when nf_tables module
is unloaded -- we don't want userspace to submit new change requests once
we've started to tear down nft state.

Furthermore, nfnetlink must not call any subsystem function after
call_batch returned -EAGAIN.

EAGAIN means the subsys mutex was dropped, so its unlikely but possible that
nf_tables subsystem was removed due to 'rmmod nf_tables' on another cpu.

Therefore, we must abort batch completely and not move on to next part of
the batch.

Last, we can't invoke ->abort unless we've checked that the subsystem is
still registered.

Change netns exit path of nf_tables to make sure any incompleted
transaction gets removed on exit.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 71ad00c50d77e507138c792a9646b53c16f22e11)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
#	net/netfilter/nfnetlink.c
diff --cc net/netfilter/nf_tables_api.c
index 0cf39357e9a5,ae312b31db28..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -4098,9 -6439,8 +4098,13 @@@ static void nf_tables_abort_release(str
  	kfree(trans);
  }
  
++<<<<<<< HEAD
 +static int nf_tables_abort(struct sk_buff *skb)
++=======
+ static int __nf_tables_abort(struct net *net)
++>>>>>>> 71ad00c50d77 (netfilter: nf_tables: fix module unload race)
  {
 +	struct net *net = sock_net(skb->sk);
  	struct nft_trans *trans, *next;
  	struct nft_trans_elem *te;
  
@@@ -4190,6 -6550,21 +4194,24 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void nf_tables_cleanup(struct net *net)
+ {
+ 	nft_validate_state_update(net, NFT_VALIDATE_SKIP);
+ }
+ 
+ static int nf_tables_abort(struct net *net, struct sk_buff *skb)
+ {
+ 	return __nf_tables_abort(net);
+ }
+ 
+ static bool nf_tables_valid_genid(struct net *net, u32 genid)
+ {
+ 	return net->nft.base_seq == genid;
+ }
+ 
++>>>>>>> 71ad00c50d77 (netfilter: nf_tables: fix module unload race)
  static const struct nfnetlink_subsystem nf_tables_subsys = {
  	.name		= "nf_tables",
  	.subsys_id	= NFNL_SUBSYS_NFTABLES,
@@@ -4732,8 -7142,27 +4754,29 @@@ static void __nft_release_afinfo(struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int __net_init nf_tables_init_net(struct net *net)
+ {
+ 	INIT_LIST_HEAD(&net->nft.tables);
+ 	INIT_LIST_HEAD(&net->nft.commit_list);
+ 	net->nft.base_seq = 1;
+ 	net->nft.validate_state = NFT_VALIDATE_SKIP;
+ 
+ 	return 0;
+ }
+ 
+ static void __net_exit nf_tables_exit_net(struct net *net)
+ {
+ 	if (!list_empty(&net->nft.commit_list))
+ 		__nf_tables_abort(net);
+ 	__nft_release_tables(net);
+ 	WARN_ON_ONCE(!list_empty(&net->nft.tables));
+ }
+ 
++>>>>>>> 71ad00c50d77 (netfilter: nf_tables: fix module unload race)
  static struct pernet_operations nf_tables_net_ops = {
  	.init	= nf_tables_init_net,
 -	.exit	= nf_tables_exit_net,
  };
  
  static int __init nf_tables_module_init(void)
@@@ -4767,8 -7199,9 +4810,12 @@@ err1
  
  static void __exit nf_tables_module_exit(void)
  {
- 	unregister_pernet_subsys(&nf_tables_net_ops);
  	nfnetlink_subsys_unregister(&nf_tables_subsys);
++<<<<<<< HEAD
++=======
+ 	unregister_netdevice_notifier(&nf_tables_flowtable_notifier);
+ 	unregister_pernet_subsys(&nf_tables_net_ops);
++>>>>>>> 71ad00c50d77 (netfilter: nf_tables: fix module unload race)
  	rcu_barrier();
  	nf_tables_core_module_exit();
  	kfree(info);
diff --cc net/netfilter/nfnetlink.c
index d1e972913291,e1b6be29848d..000000000000
--- a/net/netfilter/nfnetlink.c
+++ b/net/netfilter/nfnetlink.c
@@@ -418,7 -464,11 +418,15 @@@ ack
  	}
  done:
  	if (status & NFNL_BATCH_REPLAY) {
++<<<<<<< HEAD
 +		ss->abort(oskb);
++=======
+ 		const struct nfnetlink_subsystem *ss2;
+ 
+ 		ss2 = nfnl_dereference_protected(subsys_id);
+ 		if (ss2 == ss)
+ 			ss->abort(net, oskb);
++>>>>>>> 71ad00c50d77 (netfilter: nf_tables: fix module unload race)
  		nfnl_err_reset(&err_list);
  		nfnl_unlock(subsys_id);
  		kfree_skb(skb);
* Unmerged path net/netfilter/nf_tables_api.c
* Unmerged path net/netfilter/nfnetlink.c
