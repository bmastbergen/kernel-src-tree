/proc/meminfo: add percpu populated pages count

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Dennis Zhou (Facebook) <dennisszhou@gmail.com>
commit 7e8a6304d5419cbf056a59de92939e5eef039c57
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/7e8a6304.failed

Currently, percpu memory only exposes allocation and utilization
information via debugfs.  This more or less is only really useful for
understanding the fragmentation and allocation information at a per-chunk
level with a few global counters.  This is also gated behind a config.
BPF and cgroup, for example, have seen an increase in use causing
increased use of percpu memory.  Let's make it easier for someone to
identify how much memory is being used.

This patch adds the "Percpu" stat to meminfo to more easily look up how
much percpu memory is in use.  This number includes the cost for all
allocated backing pages and not just insight at the per a unit, per chunk
level.  Metadata is excluded.  I think excluding metadata is fair because
the backing memory scales with the numbere of cpus and can quickly
outweigh the metadata.  It also makes this calculation light.

Link: http://lkml.kernel.org/r/20180807184723.74919-1-dennisszhou@gmail.com
	Signed-off-by: Dennis Zhou <dennisszhou@gmail.com>
	Acked-by: Tejun Heo <tj@kernel.org>
	Acked-by: Roman Gushchin <guro@fb.com>
	Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
	Acked-by: David Rientjes <rientjes@google.com>
	Acked-by: Vlastimil Babka <vbabka@suse.cz>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Christoph Lameter <cl@linux.com>
	Cc: Alexey Dobriyan <adobriyan@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 7e8a6304d5419cbf056a59de92939e5eef039c57)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/meminfo.c
#	include/linux/percpu.h
#	mm/percpu.c
diff --cc fs/proc/meminfo.c
index 78f07b795734,edda898714eb..000000000000
--- a/fs/proc/meminfo.c
+++ b/fs/proc/meminfo.c
@@@ -50,132 -54,95 +51,150 @@@ static int meminfo_proc_show(struct seq
  
  	available = si_mem_available();
  
 -	show_val_kb(m, "MemTotal:       ", i.totalram);
 -	show_val_kb(m, "MemFree:        ", i.freeram);
 -	show_val_kb(m, "MemAvailable:   ", available);
 -	show_val_kb(m, "Buffers:        ", i.bufferram);
 -	show_val_kb(m, "Cached:         ", cached);
 -	show_val_kb(m, "SwapCached:     ", total_swapcache_pages());
 -	show_val_kb(m, "Active:         ", pages[LRU_ACTIVE_ANON] +
 -					   pages[LRU_ACTIVE_FILE]);
 -	show_val_kb(m, "Inactive:       ", pages[LRU_INACTIVE_ANON] +
 -					   pages[LRU_INACTIVE_FILE]);
 -	show_val_kb(m, "Active(anon):   ", pages[LRU_ACTIVE_ANON]);
 -	show_val_kb(m, "Inactive(anon): ", pages[LRU_INACTIVE_ANON]);
 -	show_val_kb(m, "Active(file):   ", pages[LRU_ACTIVE_FILE]);
 -	show_val_kb(m, "Inactive(file): ", pages[LRU_INACTIVE_FILE]);
 -	show_val_kb(m, "Unevictable:    ", pages[LRU_UNEVICTABLE]);
 -	show_val_kb(m, "Mlocked:        ", global_zone_page_state(NR_MLOCK));
 -
 +	/*
 +	 * Tagged format, for easy grepping and expansion.
 +	 */
 +	seq_printf(m,
 +		"MemTotal:       %8lu kB\n"
 +		"MemFree:        %8lu kB\n"
 +		"MemAvailable:   %8lu kB\n"
 +		"Buffers:        %8lu kB\n"
 +		"Cached:         %8lu kB\n"
 +		"SwapCached:     %8lu kB\n"
 +		"Active:         %8lu kB\n"
 +		"Inactive:       %8lu kB\n"
 +		"Active(anon):   %8lu kB\n"
 +		"Inactive(anon): %8lu kB\n"
 +		"Active(file):   %8lu kB\n"
 +		"Inactive(file): %8lu kB\n"
 +		"Unevictable:    %8lu kB\n"
 +		"Mlocked:        %8lu kB\n"
  #ifdef CONFIG_HIGHMEM
 -	show_val_kb(m, "HighTotal:      ", i.totalhigh);
 -	show_val_kb(m, "HighFree:       ", i.freehigh);
 -	show_val_kb(m, "LowTotal:       ", i.totalram - i.totalhigh);
 -	show_val_kb(m, "LowFree:        ", i.freeram - i.freehigh);
 +		"HighTotal:      %8lu kB\n"
 +		"HighFree:       %8lu kB\n"
 +		"LowTotal:       %8lu kB\n"
 +		"LowFree:        %8lu kB\n"
  #endif
 -
  #ifndef CONFIG_MMU
 -	show_val_kb(m, "MmapCopy:       ",
 -		    (unsigned long)atomic_long_read(&mmap_pages_allocated));
 +		"MmapCopy:       %8lu kB\n"
  #endif
 -
 -	show_val_kb(m, "SwapTotal:      ", i.totalswap);
 -	show_val_kb(m, "SwapFree:       ", i.freeswap);
 -	show_val_kb(m, "Dirty:          ",
 -		    global_node_page_state(NR_FILE_DIRTY));
 -	show_val_kb(m, "Writeback:      ",
 -		    global_node_page_state(NR_WRITEBACK));
 -	show_val_kb(m, "AnonPages:      ",
 -		    global_node_page_state(NR_ANON_MAPPED));
 -	show_val_kb(m, "Mapped:         ",
 -		    global_node_page_state(NR_FILE_MAPPED));
 -	show_val_kb(m, "Shmem:          ", i.sharedram);
 -	show_val_kb(m, "Slab:           ",
 -		    global_node_page_state(NR_SLAB_RECLAIMABLE) +
 -		    global_node_page_state(NR_SLAB_UNRECLAIMABLE));
 -
 -	show_val_kb(m, "SReclaimable:   ",
 -		    global_node_page_state(NR_SLAB_RECLAIMABLE));
 -	show_val_kb(m, "SUnreclaim:     ",
 -		    global_node_page_state(NR_SLAB_UNRECLAIMABLE));
 -	seq_printf(m, "KernelStack:    %8lu kB\n",
 -		   global_zone_page_state(NR_KERNEL_STACK_KB));
 -	show_val_kb(m, "PageTables:     ",
 -		    global_zone_page_state(NR_PAGETABLE));
 +		"SwapTotal:      %8lu kB\n"
 +		"SwapFree:       %8lu kB\n"
 +		"Dirty:          %8lu kB\n"
 +		"Writeback:      %8lu kB\n"
 +		"AnonPages:      %8lu kB\n"
 +		"Mapped:         %8lu kB\n"
 +		"Shmem:          %8lu kB\n"
 +		"Slab:           %8lu kB\n"
 +		"SReclaimable:   %8lu kB\n"
 +		"SUnreclaim:     %8lu kB\n"
 +		"KernelStack:    %8lu kB\n"
 +		"PageTables:     %8lu kB\n"
  #ifdef CONFIG_QUICKLIST
 -	show_val_kb(m, "Quicklists:     ", quicklist_total_size());
 +		"Quicklists:     %8lu kB\n"
  #endif
++<<<<<<< HEAD
 +		"NFS_Unstable:   %8lu kB\n"
 +		"Bounce:         %8lu kB\n"
 +		"WritebackTmp:   %8lu kB\n"
 +		"CommitLimit:    %8lu kB\n"
 +		"Committed_AS:   %8lu kB\n"
 +		"VmallocTotal:   %8lu kB\n"
 +		"VmallocUsed:    %8lu kB\n"
 +		"VmallocChunk:   %8lu kB\n"
++=======
+ 
+ 	show_val_kb(m, "NFS_Unstable:   ",
+ 		    global_node_page_state(NR_UNSTABLE_NFS));
+ 	show_val_kb(m, "Bounce:         ",
+ 		    global_zone_page_state(NR_BOUNCE));
+ 	show_val_kb(m, "WritebackTmp:   ",
+ 		    global_node_page_state(NR_WRITEBACK_TEMP));
+ 	show_val_kb(m, "CommitLimit:    ", vm_commit_limit());
+ 	show_val_kb(m, "Committed_AS:   ", committed);
+ 	seq_printf(m, "VmallocTotal:   %8lu kB\n",
+ 		   (unsigned long)VMALLOC_TOTAL >> 10);
+ 	show_val_kb(m, "VmallocUsed:    ", 0ul);
+ 	show_val_kb(m, "VmallocChunk:   ", 0ul);
+ 	show_val_kb(m, "Percpu:         ", pcpu_nr_pages());
+ 
++>>>>>>> 7e8a6304d541 (/proc/meminfo: add percpu populated pages count)
  #ifdef CONFIG_MEMORY_FAILURE
 -	seq_printf(m, "HardwareCorrupted: %5lu kB\n",
 -		   atomic_long_read(&num_poisoned_pages) << (PAGE_SHIFT - 10));
 +		"HardwareCorrupted: %5lu kB\n"
  #endif
 -
  #ifdef CONFIG_TRANSPARENT_HUGEPAGE
 -	show_val_kb(m, "AnonHugePages:  ",
 -		    global_node_page_state(NR_ANON_THPS) * HPAGE_PMD_NR);
 -	show_val_kb(m, "ShmemHugePages: ",
 -		    global_node_page_state(NR_SHMEM_THPS) * HPAGE_PMD_NR);
 -	show_val_kb(m, "ShmemPmdMapped: ",
 -		    global_node_page_state(NR_SHMEM_PMDMAPPED) * HPAGE_PMD_NR);
 +		"AnonHugePages:  %8lu kB\n"
  #endif
 -
  #ifdef CONFIG_CMA
 -	show_val_kb(m, "CmaTotal:       ", totalcma_pages);
 -	show_val_kb(m, "CmaFree:        ",
 -		    global_zone_page_state(NR_FREE_CMA_PAGES));
 +		"CmaTotal:       %8lu kB\n"
 +		"CmaFree:        %8lu kB\n"
 +#endif
 +		,
 +		K(i.totalram),
 +		K(i.freeram),
 +		K(available),
 +		K(i.bufferram),
 +		K(cached),
 +		K(total_swapcache_pages()),
 +		K(pages[LRU_ACTIVE_ANON]   + pages[LRU_ACTIVE_FILE]),
 +		K(pages[LRU_INACTIVE_ANON] + pages[LRU_INACTIVE_FILE]),
 +		K(pages[LRU_ACTIVE_ANON]),
 +		K(pages[LRU_INACTIVE_ANON]),
 +		K(pages[LRU_ACTIVE_FILE]),
 +		K(pages[LRU_INACTIVE_FILE]),
 +		K(pages[LRU_UNEVICTABLE]),
 +		K(global_page_state(NR_MLOCK)),
 +#ifdef CONFIG_HIGHMEM
 +		K(i.totalhigh),
 +		K(i.freehigh),
 +		K(i.totalram-i.totalhigh),
 +		K(i.freeram-i.freehigh),
 +#endif
 +#ifndef CONFIG_MMU
 +		K((unsigned long) atomic_long_read(&mmap_pages_allocated)),
  #endif
 +		K(i.totalswap),
 +		K(i.freeswap),
 +		K(global_page_state(NR_FILE_DIRTY)),
 +		K(global_page_state(NR_WRITEBACK)),
 +#ifdef CONFIG_TRANSPARENT_HUGEPAGE
 +		K(global_page_state(NR_ANON_PAGES)
 +		  + global_page_state(NR_ANON_TRANSPARENT_HUGEPAGES) *
 +		  HPAGE_PMD_NR),
 +#else
 +		K(global_page_state(NR_ANON_PAGES)),
 +#endif
 +		K(global_page_state(NR_FILE_MAPPED)),
 +		K(global_page_state(NR_SHMEM)),
 +		K(global_page_state(NR_SLAB_RECLAIMABLE) +
 +				global_page_state(NR_SLAB_UNRECLAIMABLE)),
 +		K(global_page_state(NR_SLAB_RECLAIMABLE)),
 +		K(global_page_state(NR_SLAB_UNRECLAIMABLE)),
 +		global_page_state(NR_KERNEL_STACK) * THREAD_SIZE / 1024,
 +		K(global_page_state(NR_PAGETABLE)),
 +#ifdef CONFIG_QUICKLIST
 +		K(quicklist_total_size()),
 +#endif
 +		K(global_page_state(NR_UNSTABLE_NFS)),
 +		K(global_page_state(NR_BOUNCE)),
 +		K(global_page_state(NR_WRITEBACK_TEMP)),
 +		K(vm_commit_limit()),
 +		K(committed),
 +		(unsigned long)VMALLOC_TOTAL >> 10,
 +		vmi.used >> 10,
 +		vmi.largest_chunk >> 10
 +#ifdef CONFIG_MEMORY_FAILURE
 +		, atomic_long_read(&num_poisoned_pages) << (PAGE_SHIFT - 10)
 +#endif
 +#ifdef CONFIG_TRANSPARENT_HUGEPAGE
 +		, K(global_page_state(NR_ANON_TRANSPARENT_HUGEPAGES) *
 +		   HPAGE_PMD_NR)
 +#endif
 +#ifdef CONFIG_CMA
 +		, K(totalcma_pages)
 +		, K(global_page_state(NR_FREE_CMA_PAGES))
 +#endif
 +		);
  
  	hugetlb_report_meminfo(m);
  
diff --cc include/linux/percpu.h
index 004298923ccf,70b7123f38c7..000000000000
--- a/include/linux/percpu.h
+++ b/include/linux/percpu.h
@@@ -171,597 -149,6 +171,601 @@@ extern phys_addr_t per_cpu_ptr_to_phys(
  	(typeof(type) __percpu *)__alloc_percpu(sizeof(type),		\
  						__alignof__(type))
  
++<<<<<<< HEAD
 +/*
 + * Branching function to split up a function into a set of functions that
 + * are called for different scalar sizes of the objects handled.
 + */
 +
 +extern void __bad_size_call_parameter(void);
 +
 +#define __pcpu_size_call_return(stem, variable)				\
 +({	typeof(variable) pscr_ret__;					\
 +	__verify_pcpu_ptr(&(variable));					\
 +	switch(sizeof(variable)) {					\
 +	case 1: pscr_ret__ = stem##1(variable);break;			\
 +	case 2: pscr_ret__ = stem##2(variable);break;			\
 +	case 4: pscr_ret__ = stem##4(variable);break;			\
 +	case 8: pscr_ret__ = stem##8(variable);break;			\
 +	default:							\
 +		__bad_size_call_parameter();break;			\
 +	}								\
 +	pscr_ret__;							\
 +})
 +
 +#define __pcpu_size_call_return2(stem, variable, ...)			\
 +({									\
 +	typeof(variable) pscr2_ret__;					\
 +	__verify_pcpu_ptr(&(variable));					\
 +	switch(sizeof(variable)) {					\
 +	case 1: pscr2_ret__ = stem##1(variable, __VA_ARGS__); break;	\
 +	case 2: pscr2_ret__ = stem##2(variable, __VA_ARGS__); break;	\
 +	case 4: pscr2_ret__ = stem##4(variable, __VA_ARGS__); break;	\
 +	case 8: pscr2_ret__ = stem##8(variable, __VA_ARGS__); break;	\
 +	default:							\
 +		__bad_size_call_parameter(); break;			\
 +	}								\
 +	pscr2_ret__;							\
 +})
 +
 +/*
 + * Special handling for cmpxchg_double.  cmpxchg_double is passed two
 + * percpu variables.  The first has to be aligned to a double word
 + * boundary and the second has to follow directly thereafter.
 + * We enforce this on all architectures even if they don't support
 + * a double cmpxchg instruction, since it's a cheap requirement, and it
 + * avoids breaking the requirement for architectures with the instruction.
 + */
 +#define __pcpu_double_call_return_bool(stem, pcp1, pcp2, ...)		\
 +({									\
 +	bool pdcrb_ret__;						\
 +	__verify_pcpu_ptr(&pcp1);					\
 +	BUILD_BUG_ON(sizeof(pcp1) != sizeof(pcp2));			\
 +	VM_BUG_ON((unsigned long)(&pcp1) % (2 * sizeof(pcp1)));		\
 +	VM_BUG_ON((unsigned long)(&pcp2) !=				\
 +		  (unsigned long)(&pcp1) + sizeof(pcp1));		\
 +	switch(sizeof(pcp1)) {						\
 +	case 1: pdcrb_ret__ = stem##1(pcp1, pcp2, __VA_ARGS__); break;	\
 +	case 2: pdcrb_ret__ = stem##2(pcp1, pcp2, __VA_ARGS__); break;	\
 +	case 4: pdcrb_ret__ = stem##4(pcp1, pcp2, __VA_ARGS__); break;	\
 +	case 8: pdcrb_ret__ = stem##8(pcp1, pcp2, __VA_ARGS__); break;	\
 +	default:							\
 +		__bad_size_call_parameter(); break;			\
 +	}								\
 +	pdcrb_ret__;							\
 +})
 +
 +#define __pcpu_size_call(stem, variable, ...)				\
 +do {									\
 +	__verify_pcpu_ptr(&(variable));					\
 +	switch(sizeof(variable)) {					\
 +		case 1: stem##1(variable, __VA_ARGS__);break;		\
 +		case 2: stem##2(variable, __VA_ARGS__);break;		\
 +		case 4: stem##4(variable, __VA_ARGS__);break;		\
 +		case 8: stem##8(variable, __VA_ARGS__);break;		\
 +		default: 						\
 +			__bad_size_call_parameter();break;		\
 +	}								\
 +} while (0)
 +
 +/*
 + * Optimized manipulation for memory allocated through the per cpu
 + * allocator or for addresses of per cpu variables.
 + *
 + * These operation guarantee exclusivity of access for other operations
 + * on the *same* processor. The assumption is that per cpu data is only
 + * accessed by a single processor instance (the current one).
 + *
 + * The first group is used for accesses that must be done in a
 + * preemption safe way since we know that the context is not preempt
 + * safe. Interrupts may occur. If the interrupt modifies the variable
 + * too then RMW actions will not be reliable.
 + *
 + * The arch code can provide optimized functions in two ways:
 + *
 + * 1. Override the function completely. F.e. define this_cpu_add().
 + *    The arch must then ensure that the various scalar format passed
 + *    are handled correctly.
 + *
 + * 2. Provide functions for certain scalar sizes. F.e. provide
 + *    this_cpu_add_2() to provide per cpu atomic operations for 2 byte
 + *    sized RMW actions. If arch code does not provide operations for
 + *    a scalar size then the fallback in the generic code will be
 + *    used.
 + */
 +
 +#define _this_cpu_generic_read(pcp)					\
 +({	typeof(pcp) ret__;						\
 +	preempt_disable();						\
 +	ret__ = *this_cpu_ptr(&(pcp));					\
 +	preempt_enable();						\
 +	ret__;								\
 +})
 +
 +#ifndef this_cpu_read
 +# ifndef this_cpu_read_1
 +#  define this_cpu_read_1(pcp)	_this_cpu_generic_read(pcp)
 +# endif
 +# ifndef this_cpu_read_2
 +#  define this_cpu_read_2(pcp)	_this_cpu_generic_read(pcp)
 +# endif
 +# ifndef this_cpu_read_4
 +#  define this_cpu_read_4(pcp)	_this_cpu_generic_read(pcp)
 +# endif
 +# ifndef this_cpu_read_8
 +#  define this_cpu_read_8(pcp)	_this_cpu_generic_read(pcp)
 +# endif
 +# define this_cpu_read(pcp)	__pcpu_size_call_return(this_cpu_read_, (pcp))
 +#endif
 +
 +#define _this_cpu_generic_to_op(pcp, val, op)				\
 +do {									\
 +	unsigned long flags;						\
 +	raw_local_irq_save(flags);					\
 +	*__this_cpu_ptr(&(pcp)) op val;					\
 +	raw_local_irq_restore(flags);					\
 +} while (0)
 +
 +#ifndef this_cpu_write
 +# ifndef this_cpu_write_1
 +#  define this_cpu_write_1(pcp, val)	_this_cpu_generic_to_op((pcp), (val), =)
 +# endif
 +# ifndef this_cpu_write_2
 +#  define this_cpu_write_2(pcp, val)	_this_cpu_generic_to_op((pcp), (val), =)
 +# endif
 +# ifndef this_cpu_write_4
 +#  define this_cpu_write_4(pcp, val)	_this_cpu_generic_to_op((pcp), (val), =)
 +# endif
 +# ifndef this_cpu_write_8
 +#  define this_cpu_write_8(pcp, val)	_this_cpu_generic_to_op((pcp), (val), =)
 +# endif
 +# define this_cpu_write(pcp, val)	__pcpu_size_call(this_cpu_write_, (pcp), (val))
 +#endif
 +
 +#ifndef this_cpu_add
 +# ifndef this_cpu_add_1
 +#  define this_cpu_add_1(pcp, val)	_this_cpu_generic_to_op((pcp), (val), +=)
 +# endif
 +# ifndef this_cpu_add_2
 +#  define this_cpu_add_2(pcp, val)	_this_cpu_generic_to_op((pcp), (val), +=)
 +# endif
 +# ifndef this_cpu_add_4
 +#  define this_cpu_add_4(pcp, val)	_this_cpu_generic_to_op((pcp), (val), +=)
 +# endif
 +# ifndef this_cpu_add_8
 +#  define this_cpu_add_8(pcp, val)	_this_cpu_generic_to_op((pcp), (val), +=)
 +# endif
 +# define this_cpu_add(pcp, val)		__pcpu_size_call(this_cpu_add_, (pcp), (val))
 +#endif
 +
 +#ifndef this_cpu_sub
 +# define this_cpu_sub(pcp, val)		this_cpu_add((pcp), -(val))
 +#endif
 +
 +#ifndef this_cpu_inc
 +# define this_cpu_inc(pcp)		this_cpu_add((pcp), 1)
 +#endif
 +
 +#ifndef this_cpu_dec
 +# define this_cpu_dec(pcp)		this_cpu_sub((pcp), 1)
 +#endif
 +
 +#ifndef this_cpu_and
 +# ifndef this_cpu_and_1
 +#  define this_cpu_and_1(pcp, val)	_this_cpu_generic_to_op((pcp), (val), &=)
 +# endif
 +# ifndef this_cpu_and_2
 +#  define this_cpu_and_2(pcp, val)	_this_cpu_generic_to_op((pcp), (val), &=)
 +# endif
 +# ifndef this_cpu_and_4
 +#  define this_cpu_and_4(pcp, val)	_this_cpu_generic_to_op((pcp), (val), &=)
 +# endif
 +# ifndef this_cpu_and_8
 +#  define this_cpu_and_8(pcp, val)	_this_cpu_generic_to_op((pcp), (val), &=)
 +# endif
 +# define this_cpu_and(pcp, val)		__pcpu_size_call(this_cpu_and_, (pcp), (val))
 +#endif
 +
 +#ifndef this_cpu_or
 +# ifndef this_cpu_or_1
 +#  define this_cpu_or_1(pcp, val)	_this_cpu_generic_to_op((pcp), (val), |=)
 +# endif
 +# ifndef this_cpu_or_2
 +#  define this_cpu_or_2(pcp, val)	_this_cpu_generic_to_op((pcp), (val), |=)
 +# endif
 +# ifndef this_cpu_or_4
 +#  define this_cpu_or_4(pcp, val)	_this_cpu_generic_to_op((pcp), (val), |=)
 +# endif
 +# ifndef this_cpu_or_8
 +#  define this_cpu_or_8(pcp, val)	_this_cpu_generic_to_op((pcp), (val), |=)
 +# endif
 +# define this_cpu_or(pcp, val)		__pcpu_size_call(this_cpu_or_, (pcp), (val))
 +#endif
 +
 +#ifndef this_cpu_xor
 +# ifndef this_cpu_xor_1
 +#  define this_cpu_xor_1(pcp, val)	_this_cpu_generic_to_op((pcp), (val), ^=)
 +# endif
 +# ifndef this_cpu_xor_2
 +#  define this_cpu_xor_2(pcp, val)	_this_cpu_generic_to_op((pcp), (val), ^=)
 +# endif
 +# ifndef this_cpu_xor_4
 +#  define this_cpu_xor_4(pcp, val)	_this_cpu_generic_to_op((pcp), (val), ^=)
 +# endif
 +# ifndef this_cpu_xor_8
 +#  define this_cpu_xor_8(pcp, val)	_this_cpu_generic_to_op((pcp), (val), ^=)
 +# endif
 +# define this_cpu_xor(pcp, val)		__pcpu_size_call(this_cpu_or_, (pcp), (val))
 +#endif
 +
 +#define _this_cpu_generic_add_return(pcp, val)				\
 +({									\
 +	typeof(pcp) ret__;						\
 +	unsigned long flags;						\
 +	raw_local_irq_save(flags);					\
 +	__this_cpu_add(pcp, val);					\
 +	ret__ = __this_cpu_read(pcp);					\
 +	raw_local_irq_restore(flags);					\
 +	ret__;								\
 +})
 +
 +#ifndef this_cpu_add_return
 +# ifndef this_cpu_add_return_1
 +#  define this_cpu_add_return_1(pcp, val)	_this_cpu_generic_add_return(pcp, val)
 +# endif
 +# ifndef this_cpu_add_return_2
 +#  define this_cpu_add_return_2(pcp, val)	_this_cpu_generic_add_return(pcp, val)
 +# endif
 +# ifndef this_cpu_add_return_4
 +#  define this_cpu_add_return_4(pcp, val)	_this_cpu_generic_add_return(pcp, val)
 +# endif
 +# ifndef this_cpu_add_return_8
 +#  define this_cpu_add_return_8(pcp, val)	_this_cpu_generic_add_return(pcp, val)
 +# endif
 +# define this_cpu_add_return(pcp, val)	__pcpu_size_call_return2(this_cpu_add_return_, pcp, val)
 +#endif
 +
 +#define this_cpu_sub_return(pcp, val)	this_cpu_add_return(pcp, -(val))
 +#define this_cpu_inc_return(pcp)	this_cpu_add_return(pcp, 1)
 +#define this_cpu_dec_return(pcp)	this_cpu_add_return(pcp, -1)
 +
 +#define _this_cpu_generic_xchg(pcp, nval)				\
 +({	typeof(pcp) ret__;						\
 +	unsigned long flags;						\
 +	raw_local_irq_save(flags);					\
 +	ret__ = __this_cpu_read(pcp);					\
 +	__this_cpu_write(pcp, nval);					\
 +	raw_local_irq_restore(flags);					\
 +	ret__;								\
 +})
 +
 +#ifndef this_cpu_xchg
 +# ifndef this_cpu_xchg_1
 +#  define this_cpu_xchg_1(pcp, nval)	_this_cpu_generic_xchg(pcp, nval)
 +# endif
 +# ifndef this_cpu_xchg_2
 +#  define this_cpu_xchg_2(pcp, nval)	_this_cpu_generic_xchg(pcp, nval)
 +# endif
 +# ifndef this_cpu_xchg_4
 +#  define this_cpu_xchg_4(pcp, nval)	_this_cpu_generic_xchg(pcp, nval)
 +# endif
 +# ifndef this_cpu_xchg_8
 +#  define this_cpu_xchg_8(pcp, nval)	_this_cpu_generic_xchg(pcp, nval)
 +# endif
 +# define this_cpu_xchg(pcp, nval)	\
 +	__pcpu_size_call_return2(this_cpu_xchg_, (pcp), nval)
 +#endif
 +
 +#define _this_cpu_generic_cmpxchg(pcp, oval, nval)			\
 +({									\
 +	typeof(pcp) ret__;						\
 +	unsigned long flags;						\
 +	raw_local_irq_save(flags);					\
 +	ret__ = __this_cpu_read(pcp);					\
 +	if (ret__ == (oval))						\
 +		__this_cpu_write(pcp, nval);				\
 +	raw_local_irq_restore(flags);					\
 +	ret__;								\
 +})
 +
 +#ifndef this_cpu_cmpxchg
 +# ifndef this_cpu_cmpxchg_1
 +#  define this_cpu_cmpxchg_1(pcp, oval, nval)	_this_cpu_generic_cmpxchg(pcp, oval, nval)
 +# endif
 +# ifndef this_cpu_cmpxchg_2
 +#  define this_cpu_cmpxchg_2(pcp, oval, nval)	_this_cpu_generic_cmpxchg(pcp, oval, nval)
 +# endif
 +# ifndef this_cpu_cmpxchg_4
 +#  define this_cpu_cmpxchg_4(pcp, oval, nval)	_this_cpu_generic_cmpxchg(pcp, oval, nval)
 +# endif
 +# ifndef this_cpu_cmpxchg_8
 +#  define this_cpu_cmpxchg_8(pcp, oval, nval)	_this_cpu_generic_cmpxchg(pcp, oval, nval)
 +# endif
 +# define this_cpu_cmpxchg(pcp, oval, nval)	\
 +	__pcpu_size_call_return2(this_cpu_cmpxchg_, pcp, oval, nval)
 +#endif
 +
 +/*
 + * cmpxchg_double replaces two adjacent scalars at once.  The first
 + * two parameters are per cpu variables which have to be of the same
 + * size.  A truth value is returned to indicate success or failure
 + * (since a double register result is difficult to handle).  There is
 + * very limited hardware support for these operations, so only certain
 + * sizes may work.
 + */
 +#define _this_cpu_generic_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2)	\
 +({									\
 +	int ret__;							\
 +	unsigned long flags;						\
 +	raw_local_irq_save(flags);					\
 +	ret__ = __this_cpu_generic_cmpxchg_double(pcp1, pcp2,		\
 +			oval1, oval2, nval1, nval2);			\
 +	raw_local_irq_restore(flags);					\
 +	ret__;								\
 +})
 +
 +#ifndef this_cpu_cmpxchg_double
 +# ifndef this_cpu_cmpxchg_double_1
 +#  define this_cpu_cmpxchg_double_1(pcp1, pcp2, oval1, oval2, nval1, nval2)	\
 +	_this_cpu_generic_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2)
 +# endif
 +# ifndef this_cpu_cmpxchg_double_2
 +#  define this_cpu_cmpxchg_double_2(pcp1, pcp2, oval1, oval2, nval1, nval2)	\
 +	_this_cpu_generic_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2)
 +# endif
 +# ifndef this_cpu_cmpxchg_double_4
 +#  define this_cpu_cmpxchg_double_4(pcp1, pcp2, oval1, oval2, nval1, nval2)	\
 +	_this_cpu_generic_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2)
 +# endif
 +# ifndef this_cpu_cmpxchg_double_8
 +#  define this_cpu_cmpxchg_double_8(pcp1, pcp2, oval1, oval2, nval1, nval2)	\
 +	_this_cpu_generic_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2)
 +# endif
 +# define this_cpu_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2)	\
 +	__pcpu_double_call_return_bool(this_cpu_cmpxchg_double_, (pcp1), (pcp2), (oval1), (oval2), (nval1), (nval2))
 +#endif
 +
 +/*
 + * Generic percpu operations for context that are safe from preemption/interrupts.
 + * Either we do not care about races or the caller has the
 + * responsibility of handling preemption/interrupt issues. Arch code can still
 + * override these instructions since the arch per cpu code may be more
 + * efficient and may actually get race freeness for free (that is the
 + * case for x86 for example).
 + *
 + * If there is no other protection through preempt disable and/or
 + * disabling interupts then one of these RMW operations can show unexpected
 + * behavior because the execution thread was rescheduled on another processor
 + * or an interrupt occurred and the same percpu variable was modified from
 + * the interrupt context.
 + */
 +#ifndef __this_cpu_read
 +# ifndef __this_cpu_read_1
 +#  define __this_cpu_read_1(pcp)	(*__this_cpu_ptr(&(pcp)))
 +# endif
 +# ifndef __this_cpu_read_2
 +#  define __this_cpu_read_2(pcp)	(*__this_cpu_ptr(&(pcp)))
 +# endif
 +# ifndef __this_cpu_read_4
 +#  define __this_cpu_read_4(pcp)	(*__this_cpu_ptr(&(pcp)))
 +# endif
 +# ifndef __this_cpu_read_8
 +#  define __this_cpu_read_8(pcp)	(*__this_cpu_ptr(&(pcp)))
 +# endif
 +# define __this_cpu_read(pcp)	__pcpu_size_call_return(__this_cpu_read_, (pcp))
 +#endif
 +
 +#define __this_cpu_generic_to_op(pcp, val, op)				\
 +do {									\
 +	*__this_cpu_ptr(&(pcp)) op val;					\
 +} while (0)
 +
 +#ifndef __this_cpu_write
 +# ifndef __this_cpu_write_1
 +#  define __this_cpu_write_1(pcp, val)	__this_cpu_generic_to_op((pcp), (val), =)
 +# endif
 +# ifndef __this_cpu_write_2
 +#  define __this_cpu_write_2(pcp, val)	__this_cpu_generic_to_op((pcp), (val), =)
 +# endif
 +# ifndef __this_cpu_write_4
 +#  define __this_cpu_write_4(pcp, val)	__this_cpu_generic_to_op((pcp), (val), =)
 +# endif
 +# ifndef __this_cpu_write_8
 +#  define __this_cpu_write_8(pcp, val)	__this_cpu_generic_to_op((pcp), (val), =)
 +# endif
 +# define __this_cpu_write(pcp, val)	__pcpu_size_call(__this_cpu_write_, (pcp), (val))
 +#endif
 +
 +#ifndef __this_cpu_add
 +# ifndef __this_cpu_add_1
 +#  define __this_cpu_add_1(pcp, val)	__this_cpu_generic_to_op((pcp), (val), +=)
 +# endif
 +# ifndef __this_cpu_add_2
 +#  define __this_cpu_add_2(pcp, val)	__this_cpu_generic_to_op((pcp), (val), +=)
 +# endif
 +# ifndef __this_cpu_add_4
 +#  define __this_cpu_add_4(pcp, val)	__this_cpu_generic_to_op((pcp), (val), +=)
 +# endif
 +# ifndef __this_cpu_add_8
 +#  define __this_cpu_add_8(pcp, val)	__this_cpu_generic_to_op((pcp), (val), +=)
 +# endif
 +# define __this_cpu_add(pcp, val)	__pcpu_size_call(__this_cpu_add_, (pcp), (val))
 +#endif
 +
 +#ifndef __this_cpu_sub
 +# define __this_cpu_sub(pcp, val)	__this_cpu_add((pcp), -(val))
 +#endif
 +
 +#ifndef __this_cpu_inc
 +# define __this_cpu_inc(pcp)		__this_cpu_add((pcp), 1)
 +#endif
 +
 +#ifndef __this_cpu_dec
 +# define __this_cpu_dec(pcp)		__this_cpu_sub((pcp), 1)
 +#endif
 +
 +#ifndef __this_cpu_and
 +# ifndef __this_cpu_and_1
 +#  define __this_cpu_and_1(pcp, val)	__this_cpu_generic_to_op((pcp), (val), &=)
 +# endif
 +# ifndef __this_cpu_and_2
 +#  define __this_cpu_and_2(pcp, val)	__this_cpu_generic_to_op((pcp), (val), &=)
 +# endif
 +# ifndef __this_cpu_and_4
 +#  define __this_cpu_and_4(pcp, val)	__this_cpu_generic_to_op((pcp), (val), &=)
 +# endif
 +# ifndef __this_cpu_and_8
 +#  define __this_cpu_and_8(pcp, val)	__this_cpu_generic_to_op((pcp), (val), &=)
 +# endif
 +# define __this_cpu_and(pcp, val)	__pcpu_size_call(__this_cpu_and_, (pcp), (val))
 +#endif
 +
 +#ifndef __this_cpu_or
 +# ifndef __this_cpu_or_1
 +#  define __this_cpu_or_1(pcp, val)	__this_cpu_generic_to_op((pcp), (val), |=)
 +# endif
 +# ifndef __this_cpu_or_2
 +#  define __this_cpu_or_2(pcp, val)	__this_cpu_generic_to_op((pcp), (val), |=)
 +# endif
 +# ifndef __this_cpu_or_4
 +#  define __this_cpu_or_4(pcp, val)	__this_cpu_generic_to_op((pcp), (val), |=)
 +# endif
 +# ifndef __this_cpu_or_8
 +#  define __this_cpu_or_8(pcp, val)	__this_cpu_generic_to_op((pcp), (val), |=)
 +# endif
 +# define __this_cpu_or(pcp, val)	__pcpu_size_call(__this_cpu_or_, (pcp), (val))
 +#endif
 +
 +#ifndef __this_cpu_xor
 +# ifndef __this_cpu_xor_1
 +#  define __this_cpu_xor_1(pcp, val)	__this_cpu_generic_to_op((pcp), (val), ^=)
 +# endif
 +# ifndef __this_cpu_xor_2
 +#  define __this_cpu_xor_2(pcp, val)	__this_cpu_generic_to_op((pcp), (val), ^=)
 +# endif
 +# ifndef __this_cpu_xor_4
 +#  define __this_cpu_xor_4(pcp, val)	__this_cpu_generic_to_op((pcp), (val), ^=)
 +# endif
 +# ifndef __this_cpu_xor_8
 +#  define __this_cpu_xor_8(pcp, val)	__this_cpu_generic_to_op((pcp), (val), ^=)
 +# endif
 +# define __this_cpu_xor(pcp, val)	__pcpu_size_call(__this_cpu_xor_, (pcp), (val))
 +#endif
 +
 +#define __this_cpu_generic_add_return(pcp, val)				\
 +({									\
 +	__this_cpu_add(pcp, val);					\
 +	__this_cpu_read(pcp);						\
 +})
 +
 +#ifndef __this_cpu_add_return
 +# ifndef __this_cpu_add_return_1
 +#  define __this_cpu_add_return_1(pcp, val)	__this_cpu_generic_add_return(pcp, val)
 +# endif
 +# ifndef __this_cpu_add_return_2
 +#  define __this_cpu_add_return_2(pcp, val)	__this_cpu_generic_add_return(pcp, val)
 +# endif
 +# ifndef __this_cpu_add_return_4
 +#  define __this_cpu_add_return_4(pcp, val)	__this_cpu_generic_add_return(pcp, val)
 +# endif
 +# ifndef __this_cpu_add_return_8
 +#  define __this_cpu_add_return_8(pcp, val)	__this_cpu_generic_add_return(pcp, val)
 +# endif
 +# define __this_cpu_add_return(pcp, val)	\
 +	__pcpu_size_call_return2(__this_cpu_add_return_, pcp, val)
 +#endif
 +
 +#define __this_cpu_sub_return(pcp, val)	__this_cpu_add_return(pcp, -(val))
 +#define __this_cpu_inc_return(pcp)	__this_cpu_add_return(pcp, 1)
 +#define __this_cpu_dec_return(pcp)	__this_cpu_add_return(pcp, -1)
 +
 +#define __this_cpu_generic_xchg(pcp, nval)				\
 +({	typeof(pcp) ret__;						\
 +	ret__ = __this_cpu_read(pcp);					\
 +	__this_cpu_write(pcp, nval);					\
 +	ret__;								\
 +})
 +
 +#ifndef __this_cpu_xchg
 +# ifndef __this_cpu_xchg_1
 +#  define __this_cpu_xchg_1(pcp, nval)	__this_cpu_generic_xchg(pcp, nval)
 +# endif
 +# ifndef __this_cpu_xchg_2
 +#  define __this_cpu_xchg_2(pcp, nval)	__this_cpu_generic_xchg(pcp, nval)
 +# endif
 +# ifndef __this_cpu_xchg_4
 +#  define __this_cpu_xchg_4(pcp, nval)	__this_cpu_generic_xchg(pcp, nval)
 +# endif
 +# ifndef __this_cpu_xchg_8
 +#  define __this_cpu_xchg_8(pcp, nval)	__this_cpu_generic_xchg(pcp, nval)
 +# endif
 +# define __this_cpu_xchg(pcp, nval)	\
 +	__pcpu_size_call_return2(__this_cpu_xchg_, (pcp), nval)
 +#endif
 +
 +#define __this_cpu_generic_cmpxchg(pcp, oval, nval)			\
 +({									\
 +	typeof(pcp) ret__;						\
 +	ret__ = __this_cpu_read(pcp);					\
 +	if (ret__ == (oval))						\
 +		__this_cpu_write(pcp, nval);				\
 +	ret__;								\
 +})
 +
 +#ifndef __this_cpu_cmpxchg
 +# ifndef __this_cpu_cmpxchg_1
 +#  define __this_cpu_cmpxchg_1(pcp, oval, nval)	__this_cpu_generic_cmpxchg(pcp, oval, nval)
 +# endif
 +# ifndef __this_cpu_cmpxchg_2
 +#  define __this_cpu_cmpxchg_2(pcp, oval, nval)	__this_cpu_generic_cmpxchg(pcp, oval, nval)
 +# endif
 +# ifndef __this_cpu_cmpxchg_4
 +#  define __this_cpu_cmpxchg_4(pcp, oval, nval)	__this_cpu_generic_cmpxchg(pcp, oval, nval)
 +# endif
 +# ifndef __this_cpu_cmpxchg_8
 +#  define __this_cpu_cmpxchg_8(pcp, oval, nval)	__this_cpu_generic_cmpxchg(pcp, oval, nval)
 +# endif
 +# define __this_cpu_cmpxchg(pcp, oval, nval)	\
 +	__pcpu_size_call_return2(__this_cpu_cmpxchg_, pcp, oval, nval)
 +#endif
 +
 +#define __this_cpu_generic_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2)	\
 +({									\
 +	int __ret = 0;							\
 +	if (__this_cpu_read(pcp1) == (oval1) &&				\
 +			 __this_cpu_read(pcp2)  == (oval2)) {		\
 +		__this_cpu_write(pcp1, (nval1));			\
 +		__this_cpu_write(pcp2, (nval2));			\
 +		__ret = 1;						\
 +	}								\
 +	(__ret);							\
 +})
 +
 +#ifndef __this_cpu_cmpxchg_double
 +# ifndef __this_cpu_cmpxchg_double_1
 +#  define __this_cpu_cmpxchg_double_1(pcp1, pcp2, oval1, oval2, nval1, nval2)	\
 +	__this_cpu_generic_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2)
 +# endif
 +# ifndef __this_cpu_cmpxchg_double_2
 +#  define __this_cpu_cmpxchg_double_2(pcp1, pcp2, oval1, oval2, nval1, nval2)	\
 +	__this_cpu_generic_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2)
 +# endif
 +# ifndef __this_cpu_cmpxchg_double_4
 +#  define __this_cpu_cmpxchg_double_4(pcp1, pcp2, oval1, oval2, nval1, nval2)	\
 +	__this_cpu_generic_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2)
 +# endif
 +# ifndef __this_cpu_cmpxchg_double_8
 +#  define __this_cpu_cmpxchg_double_8(pcp1, pcp2, oval1, oval2, nval1, nval2)	\
 +	__this_cpu_generic_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2)
 +# endif
 +# define __this_cpu_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2)	\
 +	__pcpu_double_call_return_bool(__this_cpu_cmpxchg_double_, (pcp1), (pcp2), (oval1), (oval2), (nval1), (nval2))
 +#endif
 +
 +/* To avoid include hell, as printk can not declare this, we declare it here */
 +DECLARE_PER_CPU(printk_func_t, printk_func);
++=======
+ extern unsigned long pcpu_nr_pages(void);
++>>>>>>> 7e8a6304d541 (/proc/meminfo: add percpu populated pages count)
  
  #endif /* __LINUX_PERCPU_H */
diff --cc mm/percpu.c
index abecedcf6b94,a749d4d96e3e..000000000000
--- a/mm/percpu.c
+++ b/mm/percpu.c
@@@ -172,8 -167,16 +172,16 @@@ static LIST_HEAD(pcpu_map_extend_chunks
   * The number of empty populated pages, protected by pcpu_lock.  The
   * reserved chunk doesn't contribute to the count.
   */
 -int pcpu_nr_empty_pop_pages;
 +static int pcpu_nr_empty_pop_pages;
  
+ /*
+  * The number of populated pages in use by the allocator, protected by
+  * pcpu_lock.  This number is kept per a unit per chunk (i.e. when a page gets
+  * allocated/deallocated, it is allocated/deallocated in all units of a chunk
+  * and increments/decrements this count by 1).
+  */
+ static unsigned long pcpu_nr_populated;
+ 
  /*
   * Balance work is used to populate or destroy chunks asynchronously.  We
   * try to keep the number of populated free pages between
@@@ -776,7 -1240,12 +784,16 @@@ static void pcpu_chunk_populated(struc
  
  	bitmap_set(chunk->populated, page_start, nr);
  	chunk->nr_populated += nr;
++<<<<<<< HEAD
 +	pcpu_nr_empty_pop_pages += nr;
++=======
+ 	pcpu_nr_populated += nr;
+ 
+ 	if (!for_alloc) {
+ 		chunk->nr_empty_pop_pages += nr;
+ 		pcpu_nr_empty_pop_pages += nr;
+ 	}
++>>>>>>> 7e8a6304d541 (/proc/meminfo: add percpu populated pages count)
  }
  
  /**
@@@ -798,7 -1267,9 +815,8 @@@ static void pcpu_chunk_depopulated(stru
  
  	bitmap_clear(chunk->populated, page_start, nr);
  	chunk->nr_populated -= nr;
 -	chunk->nr_empty_pop_pages -= nr;
  	pcpu_nr_empty_pop_pages -= nr;
+ 	pcpu_nr_populated -= nr;
  }
  
  /*
@@@ -1729,11 -2182,16 +1747,20 @@@ int __init pcpu_setup_first_chunk(cons
  	}
  
  	/* link the first chunk in */
 -	pcpu_first_chunk = chunk;
 -	pcpu_nr_empty_pop_pages = pcpu_first_chunk->nr_empty_pop_pages;
 +	pcpu_first_chunk = dchunk ?: schunk;
 +	pcpu_nr_empty_pop_pages +=
 +		pcpu_count_occupied_pages(pcpu_first_chunk, 1);
  	pcpu_chunk_relocate(pcpu_first_chunk, -1);
  
++<<<<<<< HEAD
++=======
+ 	/* include all regions of the first chunk */
+ 	pcpu_nr_populated += PFN_DOWN(size_sum);
+ 
+ 	pcpu_stats_chunk_alloc();
+ 	trace_percpu_create_chunk(base_addr);
+ 
++>>>>>>> 7e8a6304d541 (/proc/meminfo: add percpu populated pages count)
  	/* we're done */
  	pcpu_base_addr = base_addr;
  	return 0;
@@@ -2290,33 -2759,19 +2317,49 @@@ void __init setup_per_cpu_areas(void
  #endif	/* CONFIG_SMP */
  
  /*
++<<<<<<< HEAD
 + * First and reserved chunks are initialized with temporary allocation
 + * map in initdata so that they can be used before slab is online.
 + * This function is called after slab is brought up and replaces those
 + * with properly allocated maps.
 + */
 +void __init percpu_init_late(void)
 +{
 +	struct pcpu_chunk *target_chunks[] =
 +		{ pcpu_first_chunk, pcpu_reserved_chunk, NULL };
 +	struct pcpu_chunk *chunk;
 +	unsigned long flags;
 +	int i;
 +
 +	for (i = 0; (chunk = target_chunks[i]); i++) {
 +		int *map;
 +		const size_t size = PERCPU_DYNAMIC_EARLY_SLOTS * sizeof(map[0]);
 +
 +		BUILD_BUG_ON(size > PAGE_SIZE);
 +
 +		map = pcpu_mem_zalloc(size);
 +		BUG_ON(!map);
 +
 +		spin_lock_irqsave(&pcpu_lock, flags);
 +		memcpy(map, chunk->map, size);
 +		chunk->map = map;
 +		spin_unlock_irqrestore(&pcpu_lock, flags);
 +	}
++=======
+  * pcpu_nr_pages - calculate total number of populated backing pages
+  *
+  * This reflects the number of pages populated to back chunks.  Metadata is
+  * excluded in the number exposed in meminfo as the number of backing pages
+  * scales with the number of cpus and can quickly outweigh the memory used for
+  * metadata.  It also keeps this calculation nice and simple.
+  *
+  * RETURNS:
+  * Total number of populated backing pages in use by the allocator.
+  */
+ unsigned long pcpu_nr_pages(void)
+ {
+ 	return pcpu_nr_populated * pcpu_nr_units;
++>>>>>>> 7e8a6304d541 (/proc/meminfo: add percpu populated pages count)
  }
  
  /*
diff --git a/Documentation/filesystems/proc.txt b/Documentation/filesystems/proc.txt
index b17ca04e507b..aff300e1912a 100644
--- a/Documentation/filesystems/proc.txt
+++ b/Documentation/filesystems/proc.txt
@@ -845,6 +845,7 @@ Committed_AS:   100056 kB
 VmallocTotal:   112216 kB
 VmallocUsed:       428 kB
 VmallocChunk:   111088 kB
+Percpu:          62080 kB
 HardwareCorrupted:   0 kB
 AnonHugePages:   49152 kB
 
@@ -932,6 +933,8 @@ Committed_AS: The amount of memory presently allocated on the system.
 VmallocTotal: total size of vmalloc memory area
  VmallocUsed: amount of vmalloc area which is used
 VmallocChunk: largest contiguous block of vmalloc area which is free
+      Percpu: Memory allocated to the percpu allocator used to back percpu
+              allocations. This stat excludes the cost of metadata.
 
 ..............................................................................
 
* Unmerged path fs/proc/meminfo.c
* Unmerged path include/linux/percpu.h
* Unmerged path mm/percpu.c
