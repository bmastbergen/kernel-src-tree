iavf: allow permanent MAC address to change

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Mitch Williams <mitch.a.williams@intel.com>
commit 155f0ac2c96bc5dbfa26c14b397915443980e01d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/155f0ac2.failed

Allow the VF to override the "permanent" MAC address set by the host.
This allows bonding to work in the case where the administrator has set
the VF MAC.

Note that the VF must still be set to Trusted on the host if this change
is to be accepted by the PF driver.

	Signed-off-by: Mitch Williams <mitch.a.williams@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 155f0ac2c96bc5dbfa26c14b397915443980e01d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/iavf/iavf_main.c
diff --cc drivers/net/ethernet/intel/iavf/iavf_main.c
index e9f2c4fb4082,07f5541a0f01..000000000000
--- a/drivers/net/ethernet/intel/iavf/iavf_main.c
+++ b/drivers/net/ethernet/intel/iavf/iavf_main.c
@@@ -1532,16 -1511,379 +1529,375 @@@ err
  }
  
  /**
 - * iavf_process_aq_command - process aq_required flags
 - * and sends aq command
 - * @adapter: pointer to iavf adapter structure
 - *
 - * Returns 0 on success
 - * Returns error code if no command was sent
 - * or error code if the command failed.
 + * iavf_watchdog_timer - Periodic call-back timer
 + * @data: pointer to adapter disguised as unsigned long
   **/
 -static int iavf_process_aq_command(struct iavf_adapter *adapter)
 +static void iavf_watchdog_timer(struct timer_list *t)
  {
 -	if (adapter->aq_required & IAVF_FLAG_AQ_GET_CONFIG)
 -		return iavf_send_vf_config_msg(adapter);
 -	if (adapter->aq_required & IAVF_FLAG_AQ_DISABLE_QUEUES) {
 -		iavf_disable_queues(adapter);
 -		return 0;
 -	}
 +	struct iavf_adapter *adapter = from_timer(adapter, t,
 +						    watchdog_timer);
  
++<<<<<<< HEAD
 +	schedule_work(&adapter->watchdog_task);
 +	/* timer will be rescheduled in watchdog task */
++=======
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_MAP_VECTORS) {
+ 		iavf_map_queues(adapter);
+ 		return 0;
+ 	}
+ 
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_ADD_MAC_FILTER) {
+ 		iavf_add_ether_addrs(adapter);
+ 		return 0;
+ 	}
+ 
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_ADD_VLAN_FILTER) {
+ 		iavf_add_vlans(adapter);
+ 		return 0;
+ 	}
+ 
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_DEL_MAC_FILTER) {
+ 		iavf_del_ether_addrs(adapter);
+ 		return 0;
+ 	}
+ 
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_DEL_VLAN_FILTER) {
+ 		iavf_del_vlans(adapter);
+ 		return 0;
+ 	}
+ 
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_ENABLE_VLAN_STRIPPING) {
+ 		iavf_enable_vlan_stripping(adapter);
+ 		return 0;
+ 	}
+ 
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_DISABLE_VLAN_STRIPPING) {
+ 		iavf_disable_vlan_stripping(adapter);
+ 		return 0;
+ 	}
+ 
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_CONFIGURE_QUEUES) {
+ 		iavf_configure_queues(adapter);
+ 		return 0;
+ 	}
+ 
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_ENABLE_QUEUES) {
+ 		iavf_enable_queues(adapter);
+ 		return 0;
+ 	}
+ 
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_CONFIGURE_RSS) {
+ 		/* This message goes straight to the firmware, not the
+ 		 * PF, so we don't have to set current_op as we will
+ 		 * not get a response through the ARQ.
+ 		 */
+ 		adapter->aq_required &= ~IAVF_FLAG_AQ_CONFIGURE_RSS;
+ 		return 0;
+ 	}
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_GET_HENA) {
+ 		iavf_get_hena(adapter);
+ 		return 0;
+ 	}
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_SET_HENA) {
+ 		iavf_set_hena(adapter);
+ 		return 0;
+ 	}
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_SET_RSS_KEY) {
+ 		iavf_set_rss_key(adapter);
+ 		return 0;
+ 	}
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_SET_RSS_LUT) {
+ 		iavf_set_rss_lut(adapter);
+ 		return 0;
+ 	}
+ 
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_REQUEST_PROMISC) {
+ 		iavf_set_promiscuous(adapter, FLAG_VF_UNICAST_PROMISC |
+ 				       FLAG_VF_MULTICAST_PROMISC);
+ 		return 0;
+ 	}
+ 
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_REQUEST_ALLMULTI) {
+ 		iavf_set_promiscuous(adapter, FLAG_VF_MULTICAST_PROMISC);
+ 		return 0;
+ 	}
+ 
+ 	if ((adapter->aq_required & IAVF_FLAG_AQ_RELEASE_PROMISC) &&
+ 	    (adapter->aq_required & IAVF_FLAG_AQ_RELEASE_ALLMULTI)) {
+ 		iavf_set_promiscuous(adapter, 0);
+ 		return 0;
+ 	}
+ 
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_ENABLE_CHANNELS) {
+ 		iavf_enable_channels(adapter);
+ 		return 0;
+ 	}
+ 
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_DISABLE_CHANNELS) {
+ 		iavf_disable_channels(adapter);
+ 		return 0;
+ 	}
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_ADD_CLOUD_FILTER) {
+ 		iavf_add_cloud_filter(adapter);
+ 		return 0;
+ 	}
+ 
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_DEL_CLOUD_FILTER) {
+ 		iavf_del_cloud_filter(adapter);
+ 		return 0;
+ 	}
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_DEL_CLOUD_FILTER) {
+ 		iavf_del_cloud_filter(adapter);
+ 		return 0;
+ 	}
+ 	if (adapter->aq_required & IAVF_FLAG_AQ_ADD_CLOUD_FILTER) {
+ 		iavf_add_cloud_filter(adapter);
+ 		return 0;
+ 	}
+ 	return -EAGAIN;
+ }
+ 
+ /**
+  * iavf_startup - first step of driver startup
+  * @adapter: board private structure
+  *
+  * Function process __IAVF_STARTUP driver state.
+  * When success the state is changed to __IAVF_INIT_VERSION_CHECK
+  * when fails it returns -EAGAIN
+  **/
+ static int iavf_startup(struct iavf_adapter *adapter)
+ {
+ 	struct pci_dev *pdev = adapter->pdev;
+ 	struct iavf_hw *hw = &adapter->hw;
+ 	int err;
+ 
+ 	WARN_ON(adapter->state != __IAVF_STARTUP);
+ 
+ 	/* driver loaded, probe complete */
+ 	adapter->flags &= ~IAVF_FLAG_PF_COMMS_FAILED;
+ 	adapter->flags &= ~IAVF_FLAG_RESET_PENDING;
+ 	err = iavf_set_mac_type(hw);
+ 	if (err) {
+ 		dev_err(&pdev->dev, "Failed to set MAC type (%d)\n", err);
+ 		goto err;
+ 	}
+ 
+ 	err = iavf_check_reset_complete(hw);
+ 	if (err) {
+ 		dev_info(&pdev->dev, "Device is still in reset (%d), retrying\n",
+ 			 err);
+ 		goto err;
+ 	}
+ 	hw->aq.num_arq_entries = IAVF_AQ_LEN;
+ 	hw->aq.num_asq_entries = IAVF_AQ_LEN;
+ 	hw->aq.arq_buf_size = IAVF_MAX_AQ_BUF_SIZE;
+ 	hw->aq.asq_buf_size = IAVF_MAX_AQ_BUF_SIZE;
+ 
+ 	err = iavf_init_adminq(hw);
+ 	if (err) {
+ 		dev_err(&pdev->dev, "Failed to init Admin Queue (%d)\n", err);
+ 		goto err;
+ 	}
+ 	err = iavf_send_api_ver(adapter);
+ 	if (err) {
+ 		dev_err(&pdev->dev, "Unable to send to PF (%d)\n", err);
+ 		iavf_shutdown_adminq(hw);
+ 		goto err;
+ 	}
+ 	adapter->state = __IAVF_INIT_VERSION_CHECK;
+ err:
+ 	return err;
+ }
+ 
+ /**
+  * iavf_init_version_check - second step of driver startup
+  * @adapter: board private structure
+  *
+  * Function process __IAVF_INIT_VERSION_CHECK driver state.
+  * When success the state is changed to __IAVF_INIT_GET_RESOURCES
+  * when fails it returns -EAGAIN
+  **/
+ static int iavf_init_version_check(struct iavf_adapter *adapter)
+ {
+ 	struct pci_dev *pdev = adapter->pdev;
+ 	struct iavf_hw *hw = &adapter->hw;
+ 	int err = -EAGAIN;
+ 
+ 	WARN_ON(adapter->state != __IAVF_INIT_VERSION_CHECK);
+ 
+ 	if (!iavf_asq_done(hw)) {
+ 		dev_err(&pdev->dev, "Admin queue command never completed\n");
+ 		iavf_shutdown_adminq(hw);
+ 		adapter->state = __IAVF_STARTUP;
+ 		goto err;
+ 	}
+ 
+ 	/* aq msg sent, awaiting reply */
+ 	err = iavf_verify_api_ver(adapter);
+ 	if (err) {
+ 		if (err == IAVF_ERR_ADMIN_QUEUE_NO_WORK)
+ 			err = iavf_send_api_ver(adapter);
+ 		else
+ 			dev_err(&pdev->dev, "Unsupported PF API version %d.%d, expected %d.%d\n",
+ 				adapter->pf_version.major,
+ 				adapter->pf_version.minor,
+ 				VIRTCHNL_VERSION_MAJOR,
+ 				VIRTCHNL_VERSION_MINOR);
+ 		goto err;
+ 	}
+ 	err = iavf_send_vf_config_msg(adapter);
+ 	if (err) {
+ 		dev_err(&pdev->dev, "Unable to send config request (%d)\n",
+ 			err);
+ 		goto err;
+ 	}
+ 	adapter->state = __IAVF_INIT_GET_RESOURCES;
+ 
+ err:
+ 	return err;
+ }
+ 
+ /**
+  * iavf_init_get_resources - third step of driver startup
+  * @adapter: board private structure
+  *
+  * Function process __IAVF_INIT_GET_RESOURCES driver state and
+  * finishes driver initialization procedure.
+  * When success the state is changed to __IAVF_DOWN
+  * when fails it returns -EAGAIN
+  **/
+ static int iavf_init_get_resources(struct iavf_adapter *adapter)
+ {
+ 	struct net_device *netdev = adapter->netdev;
+ 	struct pci_dev *pdev = adapter->pdev;
+ 	struct iavf_hw *hw = &adapter->hw;
+ 	int err = 0, bufsz;
+ 
+ 	WARN_ON(adapter->state != __IAVF_INIT_GET_RESOURCES);
+ 	/* aq msg sent, awaiting reply */
+ 	if (!adapter->vf_res) {
+ 		bufsz = sizeof(struct virtchnl_vf_resource) +
+ 			(IAVF_MAX_VF_VSI *
+ 			sizeof(struct virtchnl_vsi_resource));
+ 		adapter->vf_res = kzalloc(bufsz, GFP_KERNEL);
+ 		if (!adapter->vf_res)
+ 			goto err;
+ 	}
+ 	err = iavf_get_vf_config(adapter);
+ 	if (err == IAVF_ERR_ADMIN_QUEUE_NO_WORK) {
+ 		err = iavf_send_vf_config_msg(adapter);
+ 		goto err;
+ 	} else if (err == IAVF_ERR_PARAM) {
+ 		/* We only get ERR_PARAM if the device is in a very bad
+ 		 * state or if we've been disabled for previous bad
+ 		 * behavior. Either way, we're done now.
+ 		 */
+ 		iavf_shutdown_adminq(hw);
+ 		dev_err(&pdev->dev, "Unable to get VF config due to PF error condition, not retrying\n");
+ 		return 0;
+ 	}
+ 	if (err) {
+ 		dev_err(&pdev->dev, "Unable to get VF config (%d)\n", err);
+ 		goto err_alloc;
+ 	}
+ 
+ 	if (iavf_process_config(adapter))
+ 		goto err_alloc;
+ 	adapter->current_op = VIRTCHNL_OP_UNKNOWN;
+ 
+ 	adapter->flags |= IAVF_FLAG_RX_CSUM_ENABLED;
+ 
+ 	netdev->netdev_ops = &iavf_netdev_ops;
+ 	iavf_set_ethtool_ops(netdev);
+ 	netdev->watchdog_timeo = 5 * HZ;
+ 
+ 	/* MTU range: 68 - 9710 */
+ 	netdev->min_mtu = ETH_MIN_MTU;
+ 	netdev->max_mtu = IAVF_MAX_RXBUFFER - IAVF_PACKET_HDR_PAD;
+ 
+ 	if (!is_valid_ether_addr(adapter->hw.mac.addr)) {
+ 		dev_info(&pdev->dev, "Invalid MAC address %pM, using random\n",
+ 			 adapter->hw.mac.addr);
+ 		eth_hw_addr_random(netdev);
+ 		ether_addr_copy(adapter->hw.mac.addr, netdev->dev_addr);
+ 	} else {
+ 		ether_addr_copy(netdev->dev_addr, adapter->hw.mac.addr);
+ 		ether_addr_copy(netdev->perm_addr, adapter->hw.mac.addr);
+ 	}
+ 
+ 	adapter->tx_desc_count = IAVF_DEFAULT_TXD;
+ 	adapter->rx_desc_count = IAVF_DEFAULT_RXD;
+ 	err = iavf_init_interrupt_scheme(adapter);
+ 	if (err)
+ 		goto err_sw_init;
+ 	iavf_map_rings_to_vectors(adapter);
+ 	if (adapter->vf_res->vf_cap_flags &
+ 		VIRTCHNL_VF_OFFLOAD_WB_ON_ITR)
+ 		adapter->flags |= IAVF_FLAG_WB_ON_ITR_CAPABLE;
+ 
+ 	err = iavf_request_misc_irq(adapter);
+ 	if (err)
+ 		goto err_sw_init;
+ 
+ 	netif_carrier_off(netdev);
+ 	adapter->link_up = false;
+ 
+ 	/* set the semaphore to prevent any callbacks after device registration
+ 	 * up to time when state of driver will be set to __IAVF_DOWN
+ 	 */
+ 	rtnl_lock();
+ 	if (!adapter->netdev_registered) {
+ 		err = register_netdevice(netdev);
+ 		if (err) {
+ 			rtnl_unlock();
+ 			goto err_register;
+ 		}
+ 	}
+ 
+ 	adapter->netdev_registered = true;
+ 
+ 	netif_tx_stop_all_queues(netdev);
+ 	if (CLIENT_ALLOWED(adapter)) {
+ 		err = iavf_lan_add_device(adapter);
+ 		if (err) {
+ 			rtnl_unlock();
+ 			dev_info(&pdev->dev, "Failed to add VF to client API service list: %d\n",
+ 				 err);
+ 		}
+ 	}
+ 	dev_info(&pdev->dev, "MAC address: %pM\n", adapter->hw.mac.addr);
+ 	if (netdev->features & NETIF_F_GRO)
+ 		dev_info(&pdev->dev, "GRO is enabled\n");
+ 
+ 	adapter->state = __IAVF_DOWN;
+ 	set_bit(__IAVF_VSI_DOWN, adapter->vsi.state);
+ 	rtnl_unlock();
+ 
+ 	iavf_misc_irq_enable(adapter);
+ 	wake_up(&adapter->down_waitqueue);
+ 
+ 	adapter->rss_key = kzalloc(adapter->rss_key_size, GFP_KERNEL);
+ 	adapter->rss_lut = kzalloc(adapter->rss_lut_size, GFP_KERNEL);
+ 	if (!adapter->rss_key || !adapter->rss_lut)
+ 		goto err_mem;
+ 	if (RSS_AQ(adapter))
+ 		adapter->aq_required |= IAVF_FLAG_AQ_CONFIGURE_RSS;
+ 	else
+ 		iavf_init_rss(adapter);
+ 
+ 	return err;
+ err_mem:
+ 	iavf_free_rss(adapter);
+ err_register:
+ 	iavf_free_misc_irq(adapter);
+ err_sw_init:
+ 	iavf_reset_interrupt_capability(adapter);
+ err_alloc:
+ 	kfree(adapter->vf_res);
+ 	adapter->vf_res = NULL;
+ err:
+ 	return err;
++>>>>>>> 155f0ac2c96b (iavf: allow permanent MAC address to change)
  }
  
  /**
diff --git a/drivers/net/ethernet/intel/iavf/iavf.h b/drivers/net/ethernet/intel/iavf/iavf.h
index 272d76b733aa..8603522daa19 100644
--- a/drivers/net/ethernet/intel/iavf/iavf.h
+++ b/drivers/net/ethernet/intel/iavf/iavf.h
@@ -253,7 +253,6 @@ struct iavf_adapter {
 #define IAVF_FLAG_RESET_PENDING		BIT(4)
 #define IAVF_FLAG_RESET_NEEDED		BIT(5)
 #define IAVF_FLAG_WB_ON_ITR_CAPABLE		BIT(6)
-#define IAVF_FLAG_ADDR_SET_BY_PF		BIT(8)
 #define IAVF_FLAG_SERVICE_CLIENT_REQUESTED	BIT(9)
 #define IAVF_FLAG_CLIENT_NEEDS_OPEN		BIT(10)
 #define IAVF_FLAG_CLIENT_NEEDS_CLOSE		BIT(11)
* Unmerged path drivers/net/ethernet/intel/iavf/iavf_main.c
