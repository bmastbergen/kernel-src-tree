sched/fair: Remove idle_balance() declaration in sched.h

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit 6e83125c6b151afa139c8852c099d6d92954fe3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/6e83125c.failed

Remove idle_balance() from the public life; also reduce some #ifdef
clutter by folding the pick_next_task_fair() idle path into
idle_balance().

	Cc: mingo@kernel.org
	Reported-by: Daniel Lezcano <daniel.lezcano@linaro.org>
	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20140211151148.GP27965@twins.programming.kicks-ass.net
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 6e83125c6b151afa139c8852c099d6d92954fe3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/fair.c
#	kernel/sched/sched.h
diff --cc kernel/sched/fair.c
index c5d4b4242380,40c758bbdd57..000000000000
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@@ -2659,7 -2571,10 +2659,14 @@@ void idle_exit_fair(struct rq *this_rq
  	update_rq_runnable_avg(this_rq, 0);
  }
  
++<<<<<<< HEAD
 +#else
++=======
+ static int idle_balance(struct rq *this_rq);
+ 
+ #else /* CONFIG_SMP */
+ 
++>>>>>>> 6e83125c6b15 (sched/fair: Remove idle_balance() declaration in sched.h)
  static inline void update_entity_load_avg(struct sched_entity *se,
  					  int update_cfs_rq) {}
  static inline void update_rq_runnable_avg(struct rq *rq, int runnable) {}
@@@ -2671,7 -2586,13 +2678,17 @@@ static inline void dequeue_entity_load_
  					   int sleep) {}
  static inline void update_cfs_rq_blocked_load(struct cfs_rq *cfs_rq,
  					      int force_update) {}
++<<<<<<< HEAD
 +#endif
++=======
+ 
+ static inline int idle_balance(struct rq *rq)
+ {
+ 	return 0;
+ }
+ 
+ #endif /* CONFIG_SMP */
++>>>>>>> 6e83125c6b15 (sched/fair: Remove idle_balance() declaration in sched.h)
  
  static void enqueue_sleeper(struct cfs_rq *cfs_rq, struct sched_entity *se)
  {
@@@ -4906,9 -4685,10 +4923,13 @@@ static struct task_struct *pick_next_ta
  	struct sched_entity *se;
  	struct task_struct *p;
  
++<<<<<<< HEAD
++=======
+ again:
++>>>>>>> 6e83125c6b15 (sched/fair: Remove idle_balance() declaration in sched.h)
  #ifdef CONFIG_FAIR_GROUP_SCHED
  	if (!cfs_rq->nr_running)
 -		goto idle;
 +		return NULL;
  
  	if (!prev || prev->sched_class != &fair_sched_class)
  		goto simple;
@@@ -4998,6 -4781,12 +5019,15 @@@ simple
  		hrtick_start_fair(rq, p);
  
  	return p;
++<<<<<<< HEAD
++=======
+ 
+ idle:
+ 	if (idle_balance(rq)) /* drops rq->lock */
+ 		goto again;
+ 
+ 	return NULL;
++>>>>>>> 6e83125c6b15 (sched/fair: Remove idle_balance() declaration in sched.h)
  }
  
  /*
@@@ -6957,25 -6632,23 +6987,41 @@@ update_next_balance(struct sched_domai
   * idle_balance is called by schedule() if this_cpu is about to become
   * idle. Attempts to pull tasks from other CPUs.
   */
++<<<<<<< HEAD
 +void idle_balance(int this_cpu, struct rq *this_rq)
++=======
+ static int idle_balance(struct rq *this_rq)
++>>>>>>> 6e83125c6b15 (sched/fair: Remove idle_balance() declaration in sched.h)
  {
 +	unsigned long next_balance = jiffies + HZ;
  	struct sched_domain *sd;
  	int pulled_task = 0;
 -	unsigned long next_balance = jiffies + HZ;
  	u64 curr_cost = 0;
 -	int this_cpu = this_rq->cpu;
  
++<<<<<<< HEAD
 +	this_rq->idle_stamp = rq_clock(this_rq);
 +
 +	if (this_rq->avg_idle < sysctl_sched_migration_cost ||
 +	    !this_rq->rd->overload) {
 +		rcu_read_lock();
 +		sd = rcu_dereference_check_sched_domain(this_rq->sd);
 +		if (sd)
 +			update_next_balance(sd, 0, &next_balance);
 +		rcu_read_unlock();
 +
 +		goto out;
 +	}
++=======
+ 	idle_enter_fair(this_rq);
+ 	/*
+ 	 * We must set idle_stamp _before_ calling idle_balance(), such that we
+ 	 * measure the duration of idle_balance() as idle time.
+ 	 */
+ 	this_rq->idle_stamp = rq_clock(this_rq);
+ 
+ 	if (this_rq->avg_idle < sysctl_sched_migration_cost)
+ 		goto out;
++>>>>>>> 6e83125c6b15 (sched/fair: Remove idle_balance() declaration in sched.h)
  
  	/*
  	 * Drop the rq->lock, but keep IRQ/preempt disabled.
@@@ -7025,13 -6693,31 +7071,39 @@@
  
  	raw_spin_lock(&this_rq->lock);
  
++<<<<<<< HEAD
 +out:
 +	/* Move the next balance forward */
 +	if (time_after(this_rq->next_balance, next_balance))
++=======
+ 	/*
+ 	 * While browsing the domains, we released the rq lock.
+ 	 * A task could have be enqueued in the meantime
+ 	 */
+ 	if (this_rq->nr_running && !pulled_task) {
+ 		pulled_task = 1;
+ 		goto out;
+ 	}
+ 
+ 	if (pulled_task || time_after(jiffies, this_rq->next_balance)) {
+ 		/*
+ 		 * We are going idle. next_balance may be set based on
+ 		 * a busy processor. So reset next_balance.
+ 		 */
++>>>>>>> 6e83125c6b15 (sched/fair: Remove idle_balance() declaration in sched.h)
  		this_rq->next_balance = next_balance;
 -	}
  
  	if (curr_cost > this_rq->max_idle_balance_cost)
  		this_rq->max_idle_balance_cost = curr_cost;
++<<<<<<< HEAD
++=======
+ 
+ out:
+ 	if (pulled_task)
+ 		this_rq->idle_stamp = 0;
+ 
+ 	return pulled_task;
++>>>>>>> 6e83125c6b15 (sched/fair: Remove idle_balance() declaration in sched.h)
  }
  
  /*
diff --cc kernel/sched/sched.h
index 38c9ae998b34,92018f9821e8..000000000000
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@@ -1313,30 -1162,11 +1313,28 @@@ extern const struct sched_class idle_sc
  
  extern void update_group_power(struct sched_domain *sd, int cpu);
  
++<<<<<<< HEAD
 +extern void trigger_load_balance(struct rq *rq, int cpu);
 +extern void idle_balance(int this_cpu, struct rq *this_rq);
++=======
+ extern void trigger_load_balance(struct rq *rq);
++>>>>>>> 6e83125c6b15 (sched/fair: Remove idle_balance() declaration in sched.h)
  
 +extern void sched_cpu_activate(unsigned int cpu);
 +extern void sched_cpu_deactivate(unsigned int cpu);
 +
 +/*
 + * Only depends on SMP, FAIR_GROUP_SCHED may be removed when runnable_avg
 + * becomes useful in lb
 + */
 +#if defined(CONFIG_FAIR_GROUP_SCHED)
  extern void idle_enter_fair(struct rq *this_rq);
  extern void idle_exit_fair(struct rq *this_rq);
 +#else
 +static inline void idle_enter_fair(struct rq *this_rq) {}
 +static inline void idle_exit_fair(struct rq *this_rq) {}
 +#endif
  
- #else	/* CONFIG_SMP */
- 
- static inline void idle_balance(int cpu, struct rq *rq)
- {
- }
- 
  #endif
  
  extern void sysrq_sched_debug_show(void);
* Unmerged path kernel/sched/fair.c
* Unmerged path kernel/sched/sched.h
