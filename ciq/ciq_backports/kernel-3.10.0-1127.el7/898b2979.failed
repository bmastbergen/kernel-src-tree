ip6_gre: Refactor ip6gre xmit codes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author William Tu <u9012063@gmail.com>
commit 898b29798e36019966839187fd58dacec16d7db6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/898b2979.failed

This patch refactors the ip6gre_xmit_{ipv4, ipv6}.
It is a prep work to add the ip6erspan tunnel.

	Signed-off-by: William Tu <u9012063@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 898b29798e36019966839187fd58dacec16d7db6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_gre.c
diff --cc net/ipv6/ip6_gre.c
index d333143106be,907d2e8405e2..000000000000
--- a/net/ipv6/ip6_gre.c
+++ b/net/ipv6/ip6_gre.c
@@@ -545,18 -607,7 +616,22 @@@ static inline int ip6gre_xmit_ipv4(stru
  
  	memset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));
  
++<<<<<<< HEAD
 +	if (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))
 +		encap_limit = t->parms.encap_limit;
 +
 +	memcpy(&fl6, &t->fl.u.ip6, sizeof(fl6));
 +
 +	dsfield = ipv4_get_dsfield(iph);
 +
 +	if (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)
 +		fl6.flowlabel |= htonl((__u32)iph->tos << IPV6_TCLASS_SHIFT)
 +					  & IPV6_TCLASS_MASK;
 +	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
 +		fl6.flowi6_mark = skb->mark;
++=======
+ 	prepare_ip6gre_xmit_ipv4(skb, dev, &fl6, &dsfield, &encap_limit);
++>>>>>>> 898b29798e36 (ip6_gre: Refactor ip6gre xmit codes)
  
  	err = gre_handle_offloads(skb, !!(t->parms.o_flags & TUNNEL_CSUM));
  	if (err)
@@@ -589,31 -639,8 +663,36 @@@ static inline int ip6gre_xmit_ipv6(stru
  	if (ipv6_addr_equal(&t->parms.raddr, &ipv6h->saddr))
  		return -1;
  
++<<<<<<< HEAD
 +	offset = ip6_tnl_parse_tlv_enc_lim(skb, skb_network_header(skb));
 +	/* ip6_tnl_parse_tlv_enc_lim() might have reallocated skb->head */
 +	ipv6h = ipv6_hdr(skb);
 +
 +	if (offset > 0) {
 +		struct ipv6_tlv_tnl_enc_lim *tel;
 +		tel = (struct ipv6_tlv_tnl_enc_lim *)&skb_network_header(skb)[offset];
 +		if (tel->encap_limit == 0) {
 +			icmpv6_send(skb, ICMPV6_PARAMPROB,
 +				    ICMPV6_HDR_FIELD, offset + 2);
 +			return -1;
 +		}
 +		encap_limit = tel->encap_limit - 1;
 +	} else if (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))
 +		encap_limit = t->parms.encap_limit;
 +
 +	memcpy(&fl6, &t->fl.u.ip6, sizeof(fl6));
 +
 +	dsfield = ipv6_get_dsfield(ipv6h);
 +	if (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)
 +		fl6.flowlabel |= (*(__be32 *) ipv6h & IPV6_TCLASS_MASK);
 +	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FLOWLABEL)
 +		fl6.flowlabel |= ip6_flowlabel(ipv6h);
 +	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
 +		fl6.flowi6_mark = skb->mark;
++=======
+ 	if (prepare_ip6gre_xmit_ipv6(skb, dev, &fl6, &dsfield, &encap_limit))
+ 		return -1;
++>>>>>>> 898b29798e36 (ip6_gre: Refactor ip6gre xmit codes)
  
  	if (gre_handle_offloads(skb, !!(t->parms.o_flags & TUNNEL_CSUM)))
  		return -1;
* Unmerged path net/ipv6/ip6_gre.c
