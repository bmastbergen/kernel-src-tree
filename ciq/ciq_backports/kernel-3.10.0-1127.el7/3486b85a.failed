mm/huge_memory: replace VM_NO_THP VM_BUG_ON with actual VMA check

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Konstantin Khlebnikov <koct9i@gmail.com>
commit 3486b85a29c1741db99d0c522211c82d2b7a56d0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/3486b85a.failed

Khugepaged detects own VMAs by checking vm_file and vm_ops but this way
it cannot distinguish private /dev/zero mappings from other special
mappings like /dev/hpet which has no vm_ops and popultes PTEs in mmap.

This fixes false-positive VM_BUG_ON and prevents installing THP where
they are not expected.

Link: http://lkml.kernel.org/r/CACT4Y+ZmuZMV5CjSFOeXviwQdABAgT7T+StKfTqan9YDtgEi5g@mail.gmail.com
Fixes: 78f11a255749 ("mm: thp: fix /dev/zero MAP_PRIVATE and vm_flags cleanups")
	Signed-off-by: Konstantin Khlebnikov <koct9i@gmail.com>
	Reported-by: Dmitry Vyukov <dvyukov@google.com>
	Acked-by: Vlastimil Babka <vbabka@suse.cz>
	Acked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: stable <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 3486b85a29c1741db99d0c522211c82d2b7a56d0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/huge_memory.c
diff --cc mm/huge_memory.c
index 5c622aeff5fe,df67b53ae3c5..000000000000
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@@ -2563,10 -1960,9 +2563,13 @@@ int khugepaged_enter_vma_merge(struct v
  		 * page fault if needed.
  		 */
  		return 0;
- 	if (vma->vm_ops)
+ 	if (vma->vm_ops || (vm_flags & VM_NO_THP))
  		/* khugepaged not yet working on file or special mappings */
  		return 0;
++<<<<<<< HEAD
 +	VM_BUG_ON(vma->vm_flags & VM_NO_THP);
++=======
++>>>>>>> 3486b85a29c1 (mm/huge_memory: replace VM_NO_THP VM_BUG_ON with actual VMA check)
  	hstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;
  	hend = vma->vm_end & HPAGE_PMD_MASK;
  	if (hstart < hend)
@@@ -2866,8 -2351,7 +2869,12 @@@ static bool hugepage_vma_check(struct v
  		return false;
  	if (is_vma_temporary_stack(vma))
  		return false;
++<<<<<<< HEAD
 +	VM_BUG_ON(vma->vm_flags & VM_NO_THP);
 +	return true;
++=======
+ 	return !(vma->vm_flags & VM_NO_THP);
++>>>>>>> 3486b85a29c1 (mm/huge_memory: replace VM_NO_THP VM_BUG_ON with actual VMA check)
  }
  
  static void collapse_huge_page(struct mm_struct *mm,
* Unmerged path mm/huge_memory.c
