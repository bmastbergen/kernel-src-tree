mm: fix anon_vma_clone() error treatment

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Daniel Forrest <dan.forrest@ssec.wisc.edu>
commit c4ea95d7cd08d9ffd7fa75e6c5e0332d596dd11e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/c4ea95d7.failed

Andrew Morton noticed that the error return from anon_vma_clone() was
being dropped and replaced with -ENOMEM (which is not itself a bug
because the only error return value from anon_vma_clone() is -ENOMEM).

I did an audit of callers of anon_vma_clone() and discovered an actual
bug where the error return was being lost.  In __split_vma(), between
Linux 3.11 and 3.12 the code was changed so the err variable is used
before the call to anon_vma_clone() and the default initial value of
-ENOMEM is overwritten.  So a failure of anon_vma_clone() will return
success since err at this point is now zero.

Below is a patch which fixes this bug and also propagates the error
return value from anon_vma_clone() in all cases.

Fixes: ef0855d334e1 ("mm: mempolicy: turn vma_set_policy() into vma_dup_policy()")
	Signed-off-by: Daniel Forrest <dan.forrest@ssec.wisc.edu>
	Reviewed-by: Michal Hocko <mhocko@suse.cz>
	Cc: Konstantin Khlebnikov <koct9i@gmail.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Tim Hartrick <tim@edgecast.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Michel Lespinasse <walken@google.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: <stable@vger.kernel.org>	[3.12+]
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit c4ea95d7cd08d9ffd7fa75e6c5e0332d596dd11e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/mmap.c
diff --cc mm/mmap.c
index d07a55987643,ae919891a087..000000000000
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@@ -871,13 -776,15 +871,22 @@@ int __vma_adjust(struct vm_area_struct 
  		 * shrinking vma had, to cover any anon pages imported.
  		 */
  		if (exporter && exporter->anon_vma && !importer->anon_vma) {
++<<<<<<< HEAD
 +			importer->anon_vma = exporter->anon_vma;
 +			if (anon_vma_clone(importer, exporter))
 +				return -ENOMEM;
++=======
+ 			int error;
+ 
+ 			error = anon_vma_clone(importer, exporter);
+ 			if (error)
+ 				return error;
+ 			importer->anon_vma = exporter->anon_vma;
++>>>>>>> c4ea95d7cd08 (mm: fix anon_vma_clone() error treatment)
  		}
  	}
 -
 +again:
 +	vma_adjust_trans_huge(orig_vma, start, end, adjust_next);
  	if (file) {
  		mapping = file->f_mapping;
  		if (!(vma->vm_flags & VM_NONLINEAR)) {
@@@ -2713,14 -2468,12 +2722,15 @@@ int __split_vma(struct mm_struct *mm, s
  		new->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);
  	}
  
 -	err = vma_dup_policy(vma, new);
 -	if (err)
 +	pol = mpol_dup(vma_policy(vma));
 +	if (IS_ERR(pol)) {
 +		err = PTR_ERR(pol);
  		goto out_free_vma;
 +	}
 +	vma_set_policy(new, pol);
  
- 	if (anon_vma_clone(new, vma))
+ 	err = anon_vma_clone(new, vma);
+ 	if (err)
  		goto out_free_mpol;
  
  	if (new->vm_file)
* Unmerged path mm/mmap.c
diff --git a/mm/rmap.c b/mm/rmap.c
index ea642ad32384..1f85878c54bc 100644
--- a/mm/rmap.c
+++ b/mm/rmap.c
@@ -316,6 +316,7 @@ int anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)
 {
 	struct anon_vma_chain *avc;
 	struct anon_vma *anon_vma;
+	int error;
 
 	/* Don't bother if the parent process has no anon_vma here. */
 	if (!pvma->anon_vma)
@@ -328,8 +329,9 @@ int anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)
 	 * First, attach the new VMA to the parent VMA's anon_vmas,
 	 * so rmap can find non-COWed pages in child processes.
 	 */
-	if (anon_vma_clone(vma, pvma))
-		return -ENOMEM;
+	error = anon_vma_clone(vma, pvma);
+	if (error)
+		return error;
 
 	/* An existing anon_vma has been reused, all done then. */
 	if (vma->anon_vma)
