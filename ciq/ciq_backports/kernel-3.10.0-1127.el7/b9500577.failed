iwlwifi: pcie: handle switching killer Qu B0 NICs to C0

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Luca Coelho <luciano.coelho@intel.com>
commit b9500577d361522a3d9f14da8cf41dc1d824904e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/b9500577.failed

We need to use a different firmware for C0 versions of killer Qu NICs.
Add structures for them and handle them in the if block that detects
C0 revisions.

Additionally, instead of having an inclusive check for QnJ devices,
make the selection exclusive, so that switching to QnJ is the
exception, not the default.  This prevents us from having to add all
the non-QnJ cards to an exclusion list.  To do so, only go into the
QnJ block if the device has an RF ID type HR and HW revision QnJ.

	Cc: stable@vger.kernel.org # 5.2
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
Link: https://lore.kernel.org/r/20190821171732.2266-1-luca@coelho.fi
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit b9500577d361522a3d9f14da8cf41dc1d824904e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/intel/iwlwifi/cfg/22000.c
#	drivers/net/wireless/intel/iwlwifi/iwl-config.h
#	drivers/net/wireless/intel/iwlwifi/pcie/drv.c
#	drivers/net/wireless/intel/iwlwifi/pcie/trans.c
diff --cc drivers/net/wireless/intel/iwlwifi/iwl-config.h
index 5e02f999d25e,6c04f8223aff..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/iwl-config.h
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-config.h
@@@ -484,13 -561,47 +484,58 @@@ extern const struct iwl_cfg iwl9560_2ac
  extern const struct iwl_cfg iwl9560_2ac_160_cfg_shared_clk;
  extern const struct iwl_cfg iwl9560_killer_2ac_cfg_shared_clk;
  extern const struct iwl_cfg iwl9560_killer_s_2ac_cfg_shared_clk;
++<<<<<<< HEAD
 +extern const struct iwl_cfg iwla000_2ac_cfg_hr;
 +extern const struct iwl_cfg iwla000_2ac_cfg_hr_cdb;
 +extern const struct iwl_cfg iwla000_2ac_cfg_jf;
 +extern const struct iwl_cfg iwla000_2ax_cfg_hr;
 +extern const struct iwl_cfg iwla000_2ax_cfg_qnj_hr_f0;
 +extern const struct iwl_cfg iwla000_2ax_cfg_qnj_jf_b0;
 +extern const struct iwl_cfg iwla000_2ax_cfg_qnj_hr_a0;
 +#endif /* CONFIG_IWLMVM */
++=======
+ extern const struct iwl_cfg iwl22000_2ac_cfg_hr;
+ extern const struct iwl_cfg iwl22000_2ac_cfg_hr_cdb;
+ extern const struct iwl_cfg iwl22000_2ac_cfg_jf;
+ extern const struct iwl_cfg iwl_ax101_cfg_qu_hr;
+ extern const struct iwl_cfg iwl_ax101_cfg_qu_c0_hr_b0;
+ extern const struct iwl_cfg iwl_ax101_cfg_quz_hr;
+ extern const struct iwl_cfg iwl22000_2ax_cfg_hr;
+ extern const struct iwl_cfg iwl_ax200_cfg_cc;
+ extern const struct iwl_cfg iwl_ax201_cfg_qu_hr;
+ extern const struct iwl_cfg iwl_ax201_cfg_qu_hr;
+ extern const struct iwl_cfg iwl_ax201_cfg_qu_c0_hr_b0;
+ extern const struct iwl_cfg iwl_ax201_cfg_quz_hr;
+ extern const struct iwl_cfg iwl_ax1650i_cfg_quz_hr;
+ extern const struct iwl_cfg iwl_ax1650s_cfg_quz_hr;
+ extern const struct iwl_cfg killer1650s_2ax_cfg_qu_b0_hr_b0;
+ extern const struct iwl_cfg killer1650i_2ax_cfg_qu_b0_hr_b0;
+ extern const struct iwl_cfg killer1650s_2ax_cfg_qu_c0_hr_b0;
+ extern const struct iwl_cfg killer1650i_2ax_cfg_qu_c0_hr_b0;
+ extern const struct iwl_cfg killer1650x_2ax_cfg;
+ extern const struct iwl_cfg killer1650w_2ax_cfg;
+ extern const struct iwl_cfg iwl9461_2ac_cfg_qu_b0_jf_b0;
+ extern const struct iwl_cfg iwl9462_2ac_cfg_qu_b0_jf_b0;
+ extern const struct iwl_cfg iwl9560_2ac_cfg_qu_b0_jf_b0;
+ extern const struct iwl_cfg iwl9560_2ac_160_cfg_qu_b0_jf_b0;
+ extern const struct iwl_cfg iwl9461_2ac_cfg_qu_c0_jf_b0;
+ extern const struct iwl_cfg iwl9462_2ac_cfg_qu_c0_jf_b0;
+ extern const struct iwl_cfg iwl9560_2ac_cfg_qu_c0_jf_b0;
+ extern const struct iwl_cfg iwl9560_2ac_160_cfg_qu_c0_jf_b0;
+ extern const struct iwl_cfg killer1550i_2ac_cfg_qu_b0_jf_b0;
+ extern const struct iwl_cfg killer1550s_2ac_cfg_qu_b0_jf_b0;
+ extern const struct iwl_cfg iwl22000_2ax_cfg_jf;
+ extern const struct iwl_cfg iwl22000_2ax_cfg_qnj_hr_a0_f0;
+ extern const struct iwl_cfg iwl22000_2ax_cfg_qnj_hr_b0_f0;
+ extern const struct iwl_cfg iwl22000_2ax_cfg_qnj_hr_b0;
+ extern const struct iwl_cfg iwl9560_2ac_cfg_qnj_jf_b0;
+ extern const struct iwl_cfg iwl22000_2ax_cfg_qnj_hr_a0;
+ extern const struct iwl_cfg iwlax210_2ax_cfg_so_jf_a0;
+ extern const struct iwl_cfg iwlax210_2ax_cfg_so_hr_a0;
+ extern const struct iwl_cfg iwlax211_2ax_cfg_so_gf_a0;
+ extern const struct iwl_cfg iwlax210_2ax_cfg_ty_gf_a0;
+ extern const struct iwl_cfg iwlax411_2ax_cfg_so_gf4_a0;
+ #endif /* CPTCFG_IWLMVM || CPTCFG_IWLFMAC */
++>>>>>>> b9500577d361 (iwlwifi: pcie: handle switching killer Qu B0 NICs to C0)
  
  #endif /* __IWL_CONFIG_H__ */
diff --cc drivers/net/wireless/intel/iwlwifi/pcie/drv.c
index 42672ddf7977,d9ed53b7c768..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/pcie/drv.c
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/drv.c
@@@ -1046,6 -1042,48 +1046,51 @@@ static int iwl_pci_probe(struct pci_de
  		}
  		iwl_trans->cfg = cfg;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * This is a hack to switch from Qu B0 to Qu C0.  We need to
+ 	 * do this for all cfgs that use Qu B0.  All this code is in
+ 	 * urgent need for a refactor, but for now this is the easiest
+ 	 * thing to do to support Qu C-step.
+ 	 */
+ 	if (iwl_trans->hw_rev == CSR_HW_REV_TYPE_QU_C0) {
+ 		if (iwl_trans->cfg == &iwl_ax101_cfg_qu_hr)
+ 			iwl_trans->cfg = &iwl_ax101_cfg_qu_c0_hr_b0;
+ 		else if (iwl_trans->cfg == &iwl_ax201_cfg_qu_hr)
+ 			iwl_trans->cfg = &iwl_ax201_cfg_qu_c0_hr_b0;
+ 		else if (iwl_trans->cfg == &iwl9461_2ac_cfg_qu_b0_jf_b0)
+ 			iwl_trans->cfg = &iwl9461_2ac_cfg_qu_c0_jf_b0;
+ 		else if (iwl_trans->cfg == &iwl9462_2ac_cfg_qu_b0_jf_b0)
+ 			iwl_trans->cfg = &iwl9462_2ac_cfg_qu_c0_jf_b0;
+ 		else if (iwl_trans->cfg == &iwl9560_2ac_cfg_qu_b0_jf_b0)
+ 			iwl_trans->cfg = &iwl9560_2ac_cfg_qu_c0_jf_b0;
+ 		else if (iwl_trans->cfg == &iwl9560_2ac_160_cfg_qu_b0_jf_b0)
+ 			iwl_trans->cfg = &iwl9560_2ac_160_cfg_qu_c0_jf_b0;
+ 		else if (iwl_trans->cfg == &killer1650s_2ax_cfg_qu_b0_hr_b0)
+ 			iwl_trans->cfg = &killer1650s_2ax_cfg_qu_c0_hr_b0;
+ 		else if (iwl_trans->cfg == &killer1650i_2ax_cfg_qu_b0_hr_b0)
+ 			iwl_trans->cfg = &killer1650i_2ax_cfg_qu_c0_hr_b0;
+ 	}
+ 
+ 	/* same thing for QuZ... */
+ 	if (iwl_trans->hw_rev == CSR_HW_REV_TYPE_QUZ) {
+ 		if (cfg == &iwl_ax101_cfg_qu_hr)
+ 			cfg = &iwl_ax101_cfg_quz_hr;
+ 		else if (cfg == &iwl_ax201_cfg_qu_hr)
+ 			cfg = &iwl_ax201_cfg_quz_hr;
+ 		else if (cfg == &iwl9461_2ac_cfg_qu_b0_jf_b0)
+ 			cfg = &iwl9461_2ac_cfg_quz_a0_jf_b0_soc;
+ 		else if (cfg == &iwl9462_2ac_cfg_qu_b0_jf_b0)
+ 			cfg = &iwl9462_2ac_cfg_quz_a0_jf_b0_soc;
+ 		else if (cfg == &iwl9560_2ac_cfg_qu_b0_jf_b0)
+ 			cfg = &iwl9560_2ac_cfg_quz_a0_jf_b0_soc;
+ 		else if (cfg == &iwl9560_2ac_160_cfg_qu_b0_jf_b0)
+ 			cfg = &iwl9560_2ac_160_cfg_quz_a0_jf_b0_soc;
+ 	}
+ 
++>>>>>>> b9500577d361 (iwlwifi: pcie: handle switching killer Qu B0 NICs to C0)
  #endif
  
  	pci_set_drvdata(pdev, iwl_trans);
diff --cc drivers/net/wireless/intel/iwlwifi/pcie/trans.c
index 3e4a9c886786,db62c8314603..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/trans.c
@@@ -3145,7 -3562,47 +3145,51 @@@ struct iwl_trans *iwl_trans_pcie_alloc(
  
  #if IS_ENABLED(CONFIG_IWLMVM)
  	trans->hw_rf_id = iwl_read32(trans, CSR_HW_RF_ID);
++<<<<<<< HEAD
 +	if (trans->hw_rf_id == CSR_HW_RF_ID_TYPE_HR) {
++=======
+ 
+ 	if (cfg == &iwlax210_2ax_cfg_so_hr_a0) {
+ 		if (trans->hw_rev == CSR_HW_REV_TYPE_TY) {
+ 			trans->cfg = &iwlax210_2ax_cfg_ty_gf_a0;
+ 		} else if (CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 			   CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_JF)) {
+ 			trans->cfg = &iwlax210_2ax_cfg_so_jf_a0;
+ 		} else if (CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 			   CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_GF)) {
+ 			trans->cfg = &iwlax211_2ax_cfg_so_gf_a0;
+ 		} else if (CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 			   CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_GF4)) {
+ 			trans->cfg = &iwlax411_2ax_cfg_so_gf4_a0;
+ 		}
+ 	} else if (cfg == &iwl_ax101_cfg_qu_hr) {
+ 		if ((CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 		     CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_HR) &&
+ 		     trans->hw_rev == CSR_HW_REV_TYPE_QNJ_B0) ||
+ 		    (CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 		     CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_HR1))) {
+ 			trans->cfg = &iwl22000_2ax_cfg_qnj_hr_b0;
+ 		} else if (CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 		    CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_HR)) {
+ 			trans->cfg = &iwl_ax101_cfg_qu_hr;
+ 		} else if (CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 			   CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_JF)) {
+ 			trans->cfg = &iwl22000_2ax_cfg_jf;
+ 		} else if (CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 			   CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_HRCDB)) {
+ 			IWL_ERR(trans, "RF ID HRCDB is not supported\n");
+ 			ret = -EINVAL;
+ 			goto out_no_pci;
+ 		} else {
+ 			IWL_ERR(trans, "Unrecognized RF ID 0x%08x\n",
+ 				CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id));
+ 			ret = -EINVAL;
+ 			goto out_no_pci;
+ 		}
+ 	} else if (CSR_HW_RF_ID_TYPE_CHIP_ID(trans->hw_rf_id) ==
+ 		   CSR_HW_RF_ID_TYPE_CHIP_ID(CSR_HW_RF_ID_TYPE_HR) &&
+ 		   trans->hw_rev == CSR_HW_REV_TYPE_QNJ_B0) {
++>>>>>>> b9500577d361 (iwlwifi: pcie: handle switching killer Qu B0 NICs to C0)
  		u32 hw_status;
  
  		hw_status = iwl_read_prph(trans, UMAG_GEN_HW_STATUS);
* Unmerged path drivers/net/wireless/intel/iwlwifi/cfg/22000.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/cfg/22000.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/iwl-config.h
* Unmerged path drivers/net/wireless/intel/iwlwifi/pcie/drv.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/pcie/trans.c
