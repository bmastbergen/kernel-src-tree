tree wide: use kvfree() than conditional kfree()/vfree()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
commit 1d5cfdb076288df5eb95545a547a39905e95c930
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/1d5cfdb0.failed

There are many locations that do

  if (memory_was_allocated_by_vmalloc)
    vfree(ptr);
  else
    kfree(ptr);

but kvfree() can handle both kmalloc()ed memory and vmalloc()ed memory
using is_vmalloc_addr().  Unless callers have special reasons, we can
replace this branch with kvfree().  Please check and reply if you found
problems.

	Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Acked-by: Jan Kara <jack@suse.com>
	Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
	Reviewed-by: Andreas Dilger <andreas.dilger@intel.com>
	Acked-by: "Rafael J. Wysocki" <rjw@rjwysocki.net>
	Acked-by: David Rientjes <rientjes@google.com>
	Cc: "Luck, Tony" <tony.luck@intel.com>
	Cc: Oleg Drokin <oleg.drokin@intel.com>
	Cc: Boris Petkov <bp@suse.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 1d5cfdb076288df5eb95545a547a39905e95c930)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/apei/erst.c
#	drivers/block/drbd/drbd_bitmap.c
#	drivers/staging/lustre/include/linux/libcfs/libcfs_private.h
#	ipc/sem.c
#	ipc/util.c
#	ipc/util.h
diff --cc drivers/acpi/apei/erst.c
index bb1f30482074,6e6bc1059301..000000000000
--- a/drivers/acpi/apei/erst.c
+++ b/drivers/acpi/apei/erst.c
@@@ -35,9 -31,9 +35,14 @@@
  #include <linux/nmi.h>
  #include <linux/hardirq.h>
  #include <linux/pstore.h>
++<<<<<<< HEAD
++=======
+ #include <linux/vmalloc.h>
+ #include <linux/mm.h> /* kvfree() */
++>>>>>>> 1d5cfdb07628 (tree wide: use kvfree() than conditional kfree()/vfree())
  #include <acpi/apei.h>
 +#include <linux/vmalloc.h>
 +#include <linux/mm.h>
  
  #include "apei-internal.h"
  
diff --cc drivers/block/drbd/drbd_bitmap.c
index 64fbb8385cdc,92d6fc020a65..000000000000
--- a/drivers/block/drbd/drbd_bitmap.c
+++ b/drivers/block/drbd/drbd_bitmap.c
@@@ -463,14 -455,14 +454,21 @@@ sector_t drbd_bm_capacity(struct drbd_c
  
  /* called on driver unload. TODO: call when a device is destroyed.
   */
 -void drbd_bm_cleanup(struct drbd_device *device)
 +void drbd_bm_cleanup(struct drbd_conf *mdev)
  {
 -	if (!expect(device->bitmap))
 +	if (!expect(mdev->bitmap))
  		return;
++<<<<<<< HEAD
 +	bm_free_pages(mdev->bitmap->bm_pages, mdev->bitmap->bm_number_of_pages);
 +	bm_vk_free(mdev->bitmap->bm_pages, (BM_P_VMALLOCED & mdev->bitmap->bm_flags));
 +	kfree(mdev->bitmap);
 +	mdev->bitmap = NULL;
++=======
+ 	bm_free_pages(device->bitmap->bm_pages, device->bitmap->bm_number_of_pages);
+ 	bm_vk_free(device->bitmap->bm_pages);
+ 	kfree(device->bitmap);
+ 	device->bitmap = NULL;
++>>>>>>> 1d5cfdb07628 (tree wide: use kvfree() than conditional kfree()/vfree())
  }
  
  /*
@@@ -739,13 -732,13 +734,13 @@@ int drbd_bm_resize(struct drbd_conf *md
  
  	spin_unlock_irq(&b->bm_lock);
  	if (opages != npages)
- 		bm_vk_free(opages, opages_vmalloced);
+ 		bm_vk_free(opages);
  	if (!growing)
  		b->bm_set = bm_count_bits(b);
 -	drbd_info(device, "resync bitmap: bits=%lu words=%lu pages=%lu\n", bits, words, want);
 +	dev_info(DEV, "resync bitmap: bits=%lu words=%lu pages=%lu\n", bits, words, want);
  
   out:
 -	drbd_bm_unlock(device);
 +	drbd_bm_unlock(mdev);
  	return err;
  }
  
diff --cc ipc/sem.c
index b95cbc887889,cddd5b5fde51..000000000000
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@@ -1476,8 -1492,8 +1476,13 @@@ out_rcu_wakeup
  	rcu_read_unlock();
  	wake_up_sem_queue_do(&tasks);
  out_free:
++<<<<<<< HEAD
 +	if(sem_io != fast_sem_io)
 +		ipc_free(sem_io, sizeof(ushort)*nsems);
++=======
+ 	if (sem_io != fast_sem_io)
+ 		ipc_free(sem_io);
++>>>>>>> 1d5cfdb07628 (tree wide: use kvfree() than conditional kfree()/vfree())
  	return err;
  }
  
diff --cc ipc/util.c
index d3c37adf5b01,798cad18dd87..000000000000
--- a/ipc/util.c
+++ b/ipc/util.c
@@@ -466,20 -412,14 +466,31 @@@ void *ipc_alloc(int size
  }
  
  /**
++<<<<<<< HEAD
 + *	ipc_free        -       free ipc space
 + *	@ptr: pointer returned by ipc_alloc
 + *	@size: size of block
 + *
 + *	Free a block created with ipc_alloc(). The caller must know the size
 + *	used in the allocation call.
 + */
 +
 +void ipc_free(void* ptr, int size)
 +{
 +	if(size > PAGE_SIZE)
 +		vfree(ptr);
 +	else
 +		kfree(ptr);
++=======
+  * ipc_free - free ipc space
+  * @ptr: pointer returned by ipc_alloc
+  *
+  * Free a block created with ipc_alloc().
+  */
+ void ipc_free(void *ptr)
+ {
+ 	kvfree(ptr);
++>>>>>>> 1d5cfdb07628 (tree wide: use kvfree() than conditional kfree()/vfree())
  }
  
  /**
diff --cc ipc/util.h
index 778c12c8c204,51f7ca58ac67..000000000000
--- a/ipc/util.h
+++ b/ipc/util.h
@@@ -117,8 -117,8 +117,13 @@@ int ipcperms(struct ipc_namespace *ns, 
  /* for rare, potentially huge allocations.
   * both function can sleep
   */
++<<<<<<< HEAD
 +void* ipc_alloc(int size);
 +void ipc_free(void* ptr, int size);
++=======
+ void *ipc_alloc(int size);
+ void ipc_free(void *ptr);
++>>>>>>> 1d5cfdb07628 (tree wide: use kvfree() than conditional kfree()/vfree())
  
  /*
   * For allocation that need to be freed by RCU.
* Unmerged path drivers/staging/lustre/include/linux/libcfs/libcfs_private.h
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index 1fb40dc37ec2..88e3c08b8616 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -1131,10 +1131,7 @@ error:
 	while (i--)
 		if (pages[i])
 			__free_pages(pages[i], 0);
-	if (array_size <= PAGE_SIZE)
-		kfree(pages);
-	else
-		vfree(pages);
+	kvfree(pages);
 	return NULL;
 }
 
@@ -1142,7 +1139,6 @@ static int __iommu_free_buffer(struct device *dev, struct page **pages,
 			       size_t size, struct dma_attrs *attrs)
 {
 	int count = size >> PAGE_SHIFT;
-	int array_size = count * sizeof(struct page *);
 	int i;
 
 	if (dma_get_attr(DMA_ATTR_FORCE_CONTIGUOUS, attrs)) {
@@ -1153,10 +1149,7 @@ static int __iommu_free_buffer(struct device *dev, struct page **pages,
 				__free_pages(pages[i], 0);
 	}
 
-	if (array_size <= PAGE_SIZE)
-		kfree(pages);
-	else
-		vfree(pages);
+	kvfree(pages);
 	return 0;
 }
 
* Unmerged path drivers/acpi/apei/erst.c
* Unmerged path drivers/block/drbd/drbd_bitmap.c
diff --git a/drivers/block/drbd/drbd_int.h b/drivers/block/drbd/drbd_int.h
index f943aacfdad8..75a51296621c 100644
--- a/drivers/block/drbd/drbd_int.h
+++ b/drivers/block/drbd/drbd_int.h
@@ -700,9 +700,6 @@ struct drbd_bitmap; /* opaque for drbd_conf */
 /* definition of bits in bm_flags to be used in drbd_bm_lock
  * and drbd_bitmap_io and friends. */
 enum bm_flag {
-	/* do we need to kfree, or vfree bm_pages? */
-	BM_P_VMALLOCED = 0x10000, /* internal use only, will be masked out */
-
 	/* currently locked for bulk operation */
 	BM_LOCKED_MASK = 0xf,
 
diff --git a/drivers/char/mspec.c b/drivers/char/mspec.c
index e1f60f968fdd..d4f857d42dd3 100644
--- a/drivers/char/mspec.c
+++ b/drivers/char/mspec.c
@@ -93,14 +93,11 @@ struct vma_data {
 	spinlock_t lock;	/* Serialize access to this structure. */
 	int count;		/* Number of pages allocated. */
 	enum mspec_page_type type; /* Type of pages allocated. */
-	int flags;		/* See VMD_xxx below. */
 	unsigned long vm_start;	/* Original (unsplit) base. */
 	unsigned long vm_end;	/* Original (unsplit) end. */
 	unsigned long maddr[0];	/* Array of MSPEC addresses. */
 };
 
-#define VMD_VMALLOCED 0x1	/* vmalloc'd rather than kmalloc'd */
-
 /* used on shub2 to clear FOP cache in the HUB */
 static unsigned long scratch_page[MAX_NUMNODES];
 #define SH2_AMO_CACHE_ENTRIES	4
@@ -185,10 +182,7 @@ mspec_close(struct vm_area_struct *vma)
 			       "failed to zero page %ld\n", my_page);
 	}
 
-	if (vdata->flags & VMD_VMALLOCED)
-		vfree(vdata);
-	else
-		kfree(vdata);
+	kvfree(vdata);
 }
 
 /*
@@ -256,7 +250,7 @@ mspec_mmap(struct file *file, struct vm_area_struct *vma,
 					enum mspec_page_type type)
 {
 	struct vma_data *vdata;
-	int pages, vdata_size, flags = 0;
+	int pages, vdata_size;
 
 	if (vma->vm_pgoff != 0)
 		return -EINVAL;
@@ -271,16 +265,13 @@ mspec_mmap(struct file *file, struct vm_area_struct *vma,
 	vdata_size = sizeof(struct vma_data) + pages * sizeof(long);
 	if (vdata_size <= PAGE_SIZE)
 		vdata = kzalloc(vdata_size, GFP_KERNEL);
-	else {
+	else
 		vdata = vzalloc(vdata_size);
-		flags = VMD_VMALLOCED;
-	}
 	if (!vdata)
 		return -ENOMEM;
 
 	vdata->vm_start = vma->vm_start;
 	vdata->vm_end = vma->vm_end;
-	vdata->flags = flags;
 	vdata->type = type;
 	spin_lock_init(&vdata->lock);
 	atomic_set(&vdata->refcnt, 1);
* Unmerged path drivers/staging/lustre/include/linux/libcfs/libcfs_private.h
diff --git a/fs/coda/coda_linux.h b/fs/coda/coda_linux.h
index cc0ea9fe5ecf..0ea4656c8312 100644
--- a/fs/coda/coda_linux.h
+++ b/fs/coda/coda_linux.h
@@ -67,8 +67,7 @@ void coda_sysctl_clean(void);
 } while (0)
 
 
-#define CODA_FREE(ptr,size) \
-    do { if (size < PAGE_SIZE) kfree((ptr)); else vfree((ptr)); } while (0)
+#define CODA_FREE(ptr, size) kvfree((ptr))
 
 /* inode to cnode access functions */
 
diff --git a/fs/jffs2/build.c b/fs/jffs2/build.c
index a3750f902adc..0ae91ad6df2d 100644
--- a/fs/jffs2/build.c
+++ b/fs/jffs2/build.c
@@ -17,6 +17,7 @@
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/mtd/mtd.h>
+#include <linux/mm.h> /* kvfree() */
 #include "nodelist.h"
 
 static void jffs2_build_remove_unlinked_inode(struct jffs2_sb_info *,
@@ -383,12 +384,7 @@ int jffs2_do_mount_fs(struct jffs2_sb_info *c)
 	return 0;
 
  out_free:
-#ifndef __ECOS
-	if (jffs2_blocks_use_vmalloc(c))
-		vfree(c->blocks);
-	else
-#endif
-		kfree(c->blocks);
+	kvfree(c->blocks);
 
 	return ret;
 }
diff --git a/fs/jffs2/fs.c b/fs/jffs2/fs.c
index 00ed6c64a579..a20a7ad92971 100644
--- a/fs/jffs2/fs.c
+++ b/fs/jffs2/fs.c
@@ -590,10 +590,7 @@ int jffs2_do_fill_super(struct super_block *sb, void *data, int silent)
 out_root:
 	jffs2_free_ino_caches(c);
 	jffs2_free_raw_node_refs(c);
-	if (jffs2_blocks_use_vmalloc(c))
-		vfree(c->blocks);
-	else
-		kfree(c->blocks);
+	kvfree(c->blocks);
  out_inohash:
 	jffs2_clear_xattr_subsystem(c);
 	kfree(c->inocache_list);
diff --git a/fs/jffs2/super.c b/fs/jffs2/super.c
index 0defb1cc2a35..b38eb8ac30fb 100644
--- a/fs/jffs2/super.c
+++ b/fs/jffs2/super.c
@@ -330,10 +330,7 @@ static void jffs2_put_super (struct super_block *sb)
 
 	jffs2_free_ino_caches(c);
 	jffs2_free_raw_node_refs(c);
-	if (jffs2_blocks_use_vmalloc(c))
-		vfree(c->blocks);
-	else
-		kfree(c->blocks);
+	kvfree(c->blocks);
 	jffs2_flash_cleanup(c);
 	kfree(c->inocache_list);
 	jffs2_clear_xattr_subsystem(c);
diff --git a/fs/udf/super.c b/fs/udf/super.c
index 9a45395df54b..b0af5a3cb041 100644
--- a/fs/udf/super.c
+++ b/fs/udf/super.c
@@ -264,17 +264,12 @@ static void udf_sb_free_bitmap(struct udf_bitmap *bitmap)
 {
 	int i;
 	int nr_groups = bitmap->s_nr_groups;
-	int size = sizeof(struct udf_bitmap) + (sizeof(struct buffer_head *) *
-						nr_groups);
 
 	for (i = 0; i < nr_groups; i++)
 		if (bitmap->s_block_bitmap[i])
 			brelse(bitmap->s_block_bitmap[i]);
 
-	if (size <= PAGE_SIZE)
-		kfree(bitmap);
-	else
-		vfree(bitmap);
+	kvfree(bitmap);
 }
 
 static void udf_free_partition(struct udf_part_map *map)
* Unmerged path ipc/sem.c
* Unmerged path ipc/util.c
* Unmerged path ipc/util.h
diff --git a/mm/percpu.c b/mm/percpu.c
index 5db02d6ae3e2..21eab17b12ac 100644
--- a/mm/percpu.c
+++ b/mm/percpu.c
@@ -308,16 +308,12 @@ static void *pcpu_mem_zalloc(size_t size)
 /**
  * pcpu_mem_free - free memory
  * @ptr: memory to free
- * @size: size of the area
  *
  * Free @ptr.  @ptr should have been allocated using pcpu_mem_zalloc().
  */
-static void pcpu_mem_free(void *ptr, size_t size)
+static void pcpu_mem_free(void *ptr)
 {
-	if (size <= PAGE_SIZE)
-		kfree(ptr);
-	else
-		vfree(ptr);
+	kvfree(ptr);
 }
 
 /**
@@ -474,8 +470,8 @@ out_unlock:
 	 * pcpu_mem_free() might end up calling vfree() which uses
 	 * IRQ-unsafe lock and thus can't be called under pcpu_lock.
 	 */
-	pcpu_mem_free(old, old_size);
-	pcpu_mem_free(new, new_size);
+	pcpu_mem_free(old);
+	pcpu_mem_free(new);
 
 	return 0;
 }
@@ -729,7 +725,7 @@ static struct pcpu_chunk *pcpu_alloc_chunk(void)
 	chunk->map = pcpu_mem_zalloc(PCPU_DFL_MAP_ALLOC *
 						sizeof(chunk->map[0]));
 	if (!chunk->map) {
-		pcpu_mem_free(chunk, pcpu_chunk_struct_size);
+		pcpu_mem_free(chunk);
 		return NULL;
 	}
 
@@ -750,8 +746,8 @@ static void pcpu_free_chunk(struct pcpu_chunk *chunk)
 {
 	if (!chunk)
 		return;
-	pcpu_mem_free(chunk->map, chunk->map_alloc * sizeof(chunk->map[0]));
-	pcpu_mem_free(chunk, pcpu_chunk_struct_size);
+	pcpu_mem_free(chunk->map);
+	pcpu_mem_free(chunk);
 }
 
 /**
diff --git a/net/ipv4/fib_trie.c b/net/ipv4/fib_trie.c
index 3edb3ec358f5..a5525034174c 100644
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@ -320,10 +320,8 @@ static void __node_free_rcu(struct rcu_head *head)
 
 	if (!n->tn_bits)
 		kmem_cache_free(trie_leaf_kmem, n);
-	else if (n->tn_bits <= TNODE_KMALLOC_MAX)
-		kfree(n);
 	else
-		vfree(n);
+		kvfree(n);
 }
 
 #define node_free(n) call_rcu(&tn_info(n)->rcu, __node_free_rcu)
