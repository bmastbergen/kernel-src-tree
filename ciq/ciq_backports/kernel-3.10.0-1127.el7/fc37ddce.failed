scsi: qedf: Check both the FCF and fabric ID before servicing clear virtual link

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Chad Dupuis <cdupuis@marvell.com>
commit fc37ddce937bb245cc3490fbaa98e64f31bb6751
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/fc37ddce.failed

 - Check proper values before servicing CVL.

	Signed-off-by: Chad Dupuis <cdupuis@marvell.com>
	Signed-off-by: Saurav Kashyap <skashyap@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit fc37ddce937bb245cc3490fbaa98e64f31bb6751)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qedf/qedf_fip.c
diff --cc drivers/scsi/qedf/qedf_fip.c
index a0afe1aee853,766da74fa546..000000000000
--- a/drivers/scsi/qedf/qedf_fip.c
+++ b/drivers/scsi/qedf/qedf_fip.c
@@@ -177,8 -185,19 +185,19 @@@ void qedf_fip_recv(struct qedf_ctx *qed
  		print_hex_dump(KERN_WARNING, "fip ", DUMP_PREFIX_OFFSET, 16, 1,
  		    skb->data, skb->len, false);
  
+ 	if (!ether_addr_equal(eth_hdr->h_dest, qedf->mac) &&
+ 	    !ether_addr_equal(eth_hdr->h_dest, fcoe_all_enode) &&
+ 		!ether_addr_equal(eth_hdr->h_dest, qedf->data_src_addr)) {
+ 		QEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_LL2,
+ 			  "Dropping FIP type 0x%x pkt due to destination MAC mismatch dest_mac=%pM ctlr.dest_addr=%pM data_src_addr=%pM.\n",
+ 			  op, eth_hdr->h_dest, qedf->mac,
+ 			  qedf->data_src_addr);
+ 		kfree_skb(skb);
+ 		return;
+ 	}
+ 
  	/* Handle FIP VLAN resp in the driver */
 -	if (op == FIP_OP_VLAN && sub == FIP_SC_VL_NOTE) {
 +	if (op == FIP_OP_VLAN && sub == FIP_SC_VL_REP) {
  		qedf_fcoe_process_vlan_resp(qedf, skb);
  		kfree_skb(skb);
  	} else if (op == FIP_OP_CTRL && sub == FIP_SC_CLR_VLINK) {
@@@ -205,11 -224,11 +224,16 @@@
  			switch (desc->fip_dtype) {
  			case FIP_DT_MAC:
  				mp = (struct fip_mac_desc *)desc;
++<<<<<<< HEAD
 +				QEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_LL2,
 +				    "fd_mac=%pM.\n", __func__, mp->fd_mac);
++=======
+ 				QEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_DISC,
+ 					  "Switch fd_mac=%pM.\n", mp->fd_mac);
++>>>>>>> fc37ddce937b (scsi: qedf: Check both the FCF and fabric ID before servicing clear virtual link)
  				if (ether_addr_equal(mp->fd_mac,
  				    qedf->ctlr.sel_fcf->fcf_mac))
- 					do_reset = true;
+ 					fcf_valid = true;
  				break;
  			case FIP_DT_NAME:
  				wp = (struct fip_wwn_desc *)desc;
@@@ -233,13 -263,11 +268,21 @@@
  			rlen -= dlen;
  		}
  
++<<<<<<< HEAD
 +		QEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_LL2,
 +		    "do_reset=%d.\n", do_reset);
 +		if (do_reset) {
 +			fcoe_ctlr_link_down(&qedf->ctlr);
 +			qedf_wait_for_upload(qedf);
 +			fcoe_ctlr_link_up(&qedf->ctlr);
 +		}
++=======
+ 		QEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_DISC,
+ 			  "fcf_valid=%d fabric_id_valid=%d fc_wwpn_valid=%d.\n",
+ 			  fcf_valid, fabric_id_valid, fc_wwpn_valid);
+ 		if (fcf_valid && fabric_id_valid && fc_wwpn_valid)
+ 			qedf_ctx_soft_reset(qedf->lport);
++>>>>>>> fc37ddce937b (scsi: qedf: Check both the FCF and fabric ID before servicing clear virtual link)
  		kfree_skb(skb);
  	} else {
  		/* Everything else is handled by libfcoe */
* Unmerged path drivers/scsi/qedf/qedf_fip.c
