s390/airq: use DMA memory for adapter interrupts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Halil Pasic <pasic@linux.ibm.com>
commit b50623e5db802e41736f3305cb54c03bc7f0e30a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/b50623e5.failed

Protected virtualization guests have to use shared pages for airq
notifier bit vectors, because the hypervisor needs to write these bits.

Let us make sure we allocate DMA memory for the notifier bit vectors by
replacing the kmem_cache with a dma_cache and kalloc() with
cio_dma_zalloc().

	Signed-off-by: Halil Pasic <pasic@linux.ibm.com>
	Reviewed-by: Sebastian Ott <sebott@linux.ibm.com>
	Reviewed-by: Michael Mueller <mimu@linux.ibm.com>
	Tested-by: Michael Mueller <mimu@linux.ibm.com>
	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
(cherry picked from commit b50623e5db802e41736f3305cb54c03bc7f0e30a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/cio/airq.c
#	drivers/s390/cio/cio.h
#	drivers/s390/cio/css.c
diff --cc drivers/s390/cio/airq.c
index 4be08f4af00d,427b2e24a8ce..000000000000
--- a/drivers/s390/cio/airq.c
+++ b/drivers/s390/cio/airq.c
@@@ -26,6 -29,8 +28,11 @@@
  static DEFINE_SPINLOCK(airq_lists_lock);
  static struct hlist_head airq_lists[MAX_ISC+1];
  
++<<<<<<< HEAD
++=======
+ static struct dma_pool *airq_iv_cache;
+ 
++>>>>>>> b50623e5db80 (s390/airq: use DMA memory for adapter interrupts)
  /**
   * register_adapter_interrupt() - register adapter interrupt handler
   * @airq: pointer to adapter interrupt descriptor
@@@ -90,10 -99,29 +97,15 @@@ void do_adapter_IO(u8 isc
  	rcu_read_lock();
  	hlist_for_each_entry_rcu(airq, head, list)
  		if ((*airq->lsi_ptr & airq->lsi_mask) != 0)
 -			airq->handler(airq, !tpi_info->directed_irq);
 +			airq->handler(airq);
  	rcu_read_unlock();
 -
 -	return IRQ_HANDLED;
 -}
 -
 -static struct irqaction airq_interrupt = {
 -	.name	 = "AIO",
 -	.handler = do_airq_interrupt,
 -};
 -
 -void __init init_airq_interrupts(void)
 -{
 -	irq_set_chip_and_handler(THIN_INTERRUPT,
 -				 &dummy_irq_chip, handle_percpu_irq);
 -	setup_irq(THIN_INTERRUPT, &airq_interrupt);
  }
  
+ static inline unsigned long iv_size(unsigned long bits)
+ {
+ 	return BITS_TO_LONGS(bits) * sizeof(unsigned long);
+ }
+ 
  /**
   * airq_iv_create - create an interrupt vector
   * @bits: number of bits in the interrupt vector
@@@ -110,10 -138,23 +122,30 @@@ struct airq_iv *airq_iv_create(unsigne
  	if (!iv)
  		goto out;
  	iv->bits = bits;
++<<<<<<< HEAD
 +	size = BITS_TO_LONGS(bits) * sizeof(unsigned long);
 +	iv->vector = kzalloc(size, GFP_KERNEL);
 +	if (!iv->vector)
 +		goto out_free;
++=======
+ 	iv->flags = flags;
+ 	size = iv_size(bits);
+ 
+ 	if (flags & AIRQ_IV_CACHELINE) {
+ 		if ((cache_line_size() * BITS_PER_BYTE) < bits
+ 				|| !airq_iv_cache)
+ 			goto out_free;
+ 
+ 		iv->vector = dma_pool_zalloc(airq_iv_cache, GFP_KERNEL,
+ 					     &iv->vector_dma);
+ 		if (!iv->vector)
+ 			goto out_free;
+ 	} else {
+ 		iv->vector = cio_dma_zalloc(size);
+ 		if (!iv->vector)
+ 			goto out_free;
+ 	}
++>>>>>>> b50623e5db80 (s390/airq: use DMA memory for adapter interrupts)
  	if (flags & AIRQ_IV_ALLOC) {
  		iv->avail = kmalloc(size, GFP_KERNEL);
  		if (!iv->avail)
@@@ -146,7 -187,10 +178,14 @@@ out_free
  	kfree(iv->ptr);
  	kfree(iv->bitlock);
  	kfree(iv->avail);
++<<<<<<< HEAD
 +	kfree(iv->vector);
++=======
+ 	if (iv->flags & AIRQ_IV_CACHELINE && iv->vector)
+ 		dma_pool_free(airq_iv_cache, iv->vector, iv->vector_dma);
+ 	else
+ 		cio_dma_free(iv->vector, size);
++>>>>>>> b50623e5db80 (s390/airq: use DMA memory for adapter interrupts)
  	kfree(iv);
  out:
  	return NULL;
@@@ -162,7 -206,10 +201,14 @@@ void airq_iv_release(struct airq_iv *iv
  	kfree(iv->data);
  	kfree(iv->ptr);
  	kfree(iv->bitlock);
++<<<<<<< HEAD
 +	kfree(iv->vector);
++=======
+ 	if (iv->flags & AIRQ_IV_CACHELINE)
+ 		dma_pool_free(airq_iv_cache, iv->vector, iv->vector_dma);
+ 	else
+ 		cio_dma_free(iv->vector, iv_size(iv->bits));
++>>>>>>> b50623e5db80 (s390/airq: use DMA memory for adapter interrupts)
  	kfree(iv->avail);
  	kfree(iv);
  }
@@@ -256,3 -303,13 +302,16 @@@ unsigned long airq_iv_scan(struct airq_
  	return bit;
  }
  EXPORT_SYMBOL(airq_iv_scan);
++<<<<<<< HEAD
++=======
+ 
+ int __init airq_init(void)
+ {
+ 	airq_iv_cache = dma_pool_create("airq_iv_cache", cio_get_dma_css_dev(),
+ 					cache_line_size(),
+ 					cache_line_size(), PAGE_SIZE);
+ 	if (!airq_iv_cache)
+ 		return -ENOMEM;
+ 	return 0;
+ }
++>>>>>>> b50623e5db80 (s390/airq: use DMA memory for adapter interrupts)
diff --cc drivers/s390/cio/cio.h
index d62f5e7f3cf1,4d6c7d16416e..000000000000
--- a/drivers/s390/cio/cio.h
+++ b/drivers/s390/cio/cio.h
@@@ -121,8 -135,7 +121,12 @@@ extern int cio_commit_config(struct sub
  int cio_tm_start_key(struct subchannel *sch, struct tcw *tcw, u8 lpm, u8 key);
  int cio_tm_intrg(struct subchannel *sch);
  
++<<<<<<< HEAD
 +void do_adapter_IO(u8 isc);
 +void do_IRQ(struct pt_regs *);
++=======
+ extern int __init airq_init(void);
++>>>>>>> b50623e5db80 (s390/airq: use DMA memory for adapter interrupts)
  
  /* Use with care. */
  #ifdef CONFIG_CCW_CONSOLE
diff --cc drivers/s390/cio/css.c
index 6c907bb420c3,7159933d9d3e..000000000000
--- a/drivers/s390/cio/css.c
+++ b/drivers/s390/cio/css.c
@@@ -955,10 -1179,12 +955,19 @@@ static int __init css_bus_init(void
  	if (ret)
  		goto out_unregister;
  	ret = register_pm_notifier(&css_power_notifier);
++<<<<<<< HEAD
 +	if (ret) {
 +		unregister_reboot_notifier(&css_reboot_notifier);
 +		goto out_unregister;
 +	}
++=======
+ 	if (ret)
+ 		goto out_unregister_rn;
+ 	ret = cio_dma_pool_init();
+ 	if (ret)
+ 		goto out_unregister_pmn;
+ 	airq_init();
++>>>>>>> b50623e5db80 (s390/airq: use DMA memory for adapter interrupts)
  	css_init_done = 1;
  
  	/* Enable default isc for I/O subchannels. */
diff --git a/arch/s390/include/asm/airq.h b/arch/s390/include/asm/airq.h
index bd93ff6661b8..d024ef6bde00 100644
--- a/arch/s390/include/asm/airq.h
+++ b/arch/s390/include/asm/airq.h
@@ -10,6 +10,7 @@
 #define _ASM_S390_AIRQ_H
 
 #include <linux/bit_spinlock.h>
+#include <linux/dma-mapping.h>
 
 struct airq_struct {
 	struct hlist_node list;		/* Handler queueing. */
@@ -28,6 +29,7 @@ void unregister_adapter_interrupt(struct airq_struct *airq);
 /* Adapter interrupt bit vector */
 struct airq_iv {
 	unsigned long *vector;	/* Adapter interrupt bit vector */
+	dma_addr_t vector_dma; /* Adapter interrupt bit vector dma */
 	unsigned long *avail;	/* Allocation bit mask for the bit vector */
 	unsigned long *bitlock;	/* Lock bit mask for the bit vector */
 	unsigned long *ptr;	/* Pointer associated with each bit */
* Unmerged path drivers/s390/cio/airq.c
* Unmerged path drivers/s390/cio/cio.h
* Unmerged path drivers/s390/cio/css.c
