ipvs: Pass ipvs not net to make_send_sock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 68c76b6aa0e02b727e931cd9ce7d969e94a8e845
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/68c76b6a.failed

	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
	Acked-by: Julian Anastasov <ja@ssi.bg>
	Signed-off-by: Simon Horman <horms@verge.net.au>
(cherry picked from commit 68c76b6aa0e02b727e931cd9ce7d969e94a8e845)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipvs/ip_vs_sync.c
diff --cc net/netfilter/ipvs/ip_vs_sync.c
index ab0e9562476c,dc987762ca2c..000000000000
--- a/net/netfilter/ipvs/ip_vs_sync.c
+++ b/net/netfilter/ipvs/ip_vs_sync.c
@@@ -1423,20 -1473,36 +1423,25 @@@ static int bind_mcastif_addr(struct soc
  /*
   *      Set up sending multicast socket over UDP
   */
- static struct socket *make_send_sock(struct net *net, int id)
+ static struct socket *make_send_sock(struct netns_ipvs *ipvs, int id)
  {
- 	struct netns_ipvs *ipvs = net_ipvs(net);
  	/* multicast addr */
 -	union ipvs_sockaddr mcast_addr;
 +	struct sockaddr_in mcast_addr = {
 +		.sin_family		= AF_INET,
 +		.sin_port		= cpu_to_be16(IP_VS_SYNC_PORT + id),
 +		.sin_addr.s_addr	= cpu_to_be32(IP_VS_SYNC_GROUP),
 +	};
  	struct socket *sock;
 -	int result, salen;
 +	int result;
  
++<<<<<<< HEAD
 +	/* First create a socket move it to right name space later */
 +	result = sock_create_kern(PF_INET, SOCK_DGRAM, IPPROTO_UDP, &sock);
++=======
+ 	/* First create a socket */
+ 	result = sock_create_kern(ipvs->net, ipvs->mcfg.mcast_af, SOCK_DGRAM,
+ 				  IPPROTO_UDP, &sock);
++>>>>>>> 68c76b6aa0e0 (ipvs: Pass ipvs not net to make_send_sock)
  	if (result < 0) {
  		pr_err("Error during creation of socket; terminating\n");
  		return ERR_PTR(result);
@@@ -1784,9 -1871,9 +1789,13 @@@ int start_sync_thread(struct net *net, 
  	tinfo = NULL;
  	for (id = 0; id < count; id++) {
  		if (state == IP_VS_STATE_MASTER)
++<<<<<<< HEAD
 +			sock = make_send_sock(net, id);
++=======
+ 			sock = make_send_sock(ipvs, id);
++>>>>>>> 68c76b6aa0e0 (ipvs: Pass ipvs not net to make_send_sock)
  		else
 -			sock = make_receive_sock(ipvs->net, id);
 +			sock = make_receive_sock(net, id);
  		if (IS_ERR(sock)) {
  			result = PTR_ERR(sock);
  			goto outtinfo;
* Unmerged path net/netfilter/ipvs/ip_vs_sync.c
