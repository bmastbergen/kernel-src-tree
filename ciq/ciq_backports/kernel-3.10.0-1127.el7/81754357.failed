fs: Update i_[ug]id_(read|write) to translate relative to s_user_ns

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Seth Forshee <seth.forshee@canonical.com>
commit 81754357770ebd900801231e7bc8d151ddc00498
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/81754357.failed

For filesystems mounted from a user namespace on-disk ids should
be translated relative to s_users_ns rather than init_user_ns.

When an id in the filesystem doesn't exist in s_user_ns the
associated id in the inode will be set to INVALID_[UG]ID, which
turns these into de facto "nobody" ids. This actually maps pretty
well into the way most code already works, and those places where
it didn't were fixed in previous patches. Moving forward vfs code
needs to be careful to handle instances where ids in inodes may
be invalid.

	Signed-off-by: Seth Forshee <seth.forshee@canonical.com>
	Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
(cherry picked from commit 81754357770ebd900801231e7bc8d151ddc00498)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/fs.h
diff --cc include/linux/fs.h
index f4c0e7616f02,8aa9b72e0bc5..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -1580,29 -1431,35 +1555,56 @@@ struct super_block_wrapper 
  	 */
  	int s_stack_depth;
  
 -	/* s_inode_list_lock protects s_inodes */
 -	spinlock_t		s_inode_list_lock ____cacheline_aligned_in_smp;
 -	struct list_head	s_inodes;	/* all inodes */
 +	/* -- Wrapper version 1 -- */
  };
  
++<<<<<<< HEAD
 +static inline struct super_block_wrapper *get_sb_wrapper(struct super_block *sb,
 +							 unsigned version)
 +{
 +	/* Make sure we get a link failure if this function is used against an
 +	 * older kernel that doesn't have the superblock wrapper.
 +	 */
 +	if (super_block_wrapper_version < version)
 +		return NULL;
 +	return container_of(sb, struct super_block_wrapper, sb);
 +}
 +
 +static inline int *get_s_stack_depth(struct super_block *sb)
 +{
 +	struct super_block_wrapper *wrapper = get_sb_wrapper(sb, 0);
 +	return wrapper ? &wrapper->s_stack_depth : NULL;
 +}
 +
 +/* superblock cache pruning functions */
 +extern void prune_icache_sb(struct super_block *sb, int nr_to_scan);
 +extern void prune_dcache_sb(struct super_block *sb, int nr_to_scan);
++=======
+ /* Helper functions so that in most cases filesystems will
+  * not need to deal directly with kuid_t and kgid_t and can
+  * instead deal with the raw numeric values that are stored
+  * in the filesystem.
+  */
+ static inline uid_t i_uid_read(const struct inode *inode)
+ {
+ 	return from_kuid(inode->i_sb->s_user_ns, inode->i_uid);
+ }
+ 
+ static inline gid_t i_gid_read(const struct inode *inode)
+ {
+ 	return from_kgid(inode->i_sb->s_user_ns, inode->i_gid);
+ }
+ 
+ static inline void i_uid_write(struct inode *inode, uid_t uid)
+ {
+ 	inode->i_uid = make_kuid(inode->i_sb->s_user_ns, uid);
+ }
+ 
+ static inline void i_gid_write(struct inode *inode, gid_t gid)
+ {
+ 	inode->i_gid = make_kgid(inode->i_sb->s_user_ns, gid);
+ }
++>>>>>>> 81754357770e (fs: Update i_[ug]id_(read|write) to translate relative to s_user_ns)
  
  extern struct timespec current_fs_time(struct super_block *sb);
  
* Unmerged path include/linux/fs.h
