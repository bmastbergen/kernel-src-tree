kernel/sysctl.c: fix proc_do_large_bitmap for large input buffers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Eric Sandeen <sandeen@redhat.com>
commit 3116ad38f51c98c81175151bd7358858a92a6031
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/3116ad38.failed

Today, proc_do_large_bitmap() truncates a large write input buffer to
PAGE_SIZE - 1, which may result in misparsed numbers at the (truncated)
end of the buffer.  Further, it fails to notify the caller that the
buffer was truncated, so it doesn't get called iteratively to finish the
entire input buffer.

Tell the caller if there's more work to do by adding the skipped amount
back to left/*lenp before returning.

To fix the misparsing, reset the position if we have completely consumed
a truncated buffer (or if just one char is left, which may be a "-" in a
range), and ask the caller to come back for more.

Link: http://lkml.kernel.org/r/20190320222831.8243-7-mcgrof@kernel.org
	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
	Signed-off-by: Luis Chamberlain <mcgrof@kernel.org>
	Acked-by: Kees Cook <keescook@chromium.org>
	Cc: Eric Sandeen <sandeen@sandeen.net>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 3116ad38f51c98c81175151bd7358858a92a6031)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sysctl.c
diff --cc kernel/sysctl.c
index 3823bf7453b0,943c89178e3d..000000000000
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@@ -3014,35 -3171,44 +3014,60 @@@ int proc_do_large_bitmap(struct ctl_tab
  	}
  
  	if (write) {
++<<<<<<< HEAD
 +		unsigned long page = 0;
 +		char *kbuf;
++=======
+ 		char *kbuf, *p;
+ 		size_t skipped = 0;
++>>>>>>> 3116ad38f51c (kernel/sysctl.c: fix proc_do_large_bitmap for large input buffers)
  
- 		if (left > PAGE_SIZE - 1)
+ 		if (left > PAGE_SIZE - 1) {
  			left = PAGE_SIZE - 1;
+ 			/* How much of the buffer we'll skip this pass */
+ 			skipped = *lenp - left;
+ 		}
  
 -		p = kbuf = memdup_user_nul(buffer, left);
 -		if (IS_ERR(kbuf))
 -			return PTR_ERR(kbuf);
 +		page = __get_free_page(GFP_TEMPORARY);
 +		kbuf = (char *) page;
 +		if (!kbuf)
 +			return -ENOMEM;
 +		if (copy_from_user(kbuf, buffer, left)) {
 +			free_page(page);
 +			return -EFAULT;
 +                }
 +		kbuf[left] = 0;
  
 -		tmp_bitmap = bitmap_zalloc(bitmap_len, GFP_KERNEL);
 +		tmp_bitmap = kzalloc(BITS_TO_LONGS(bitmap_len) * sizeof(unsigned long),
 +				     GFP_KERNEL);
  		if (!tmp_bitmap) {
 -			kfree(kbuf);
 +			free_page(page);
  			return -ENOMEM;
  		}
 -		proc_skip_char(&p, &left, '\n');
 +		proc_skip_char(&kbuf, &left, '\n');
  		while (!err && left) {
  			unsigned long val_a, val_b;
  			bool neg;
+ 			size_t saved_left;
  
++<<<<<<< HEAD
 +			err = proc_get_long(&kbuf, &left, &val_a, &neg, tr_a,
++=======
+ 			/* In case we stop parsing mid-number, we can reset */
+ 			saved_left = left;
+ 			err = proc_get_long(&p, &left, &val_a, &neg, tr_a,
++>>>>>>> 3116ad38f51c (kernel/sysctl.c: fix proc_do_large_bitmap for large input buffers)
  					     sizeof(tr_a), &c);
+ 			/*
+ 			 * If we consumed the entirety of a truncated buffer or
+ 			 * only one char is left (may be a "-"), then stop here,
+ 			 * reset, & come back for more.
+ 			 */
+ 			if ((left <= 1) && skipped) {
+ 				left = saved_left;
+ 				break;
+ 			}
+ 
  			if (err)
  				break;
  			if (val_a >= bitmap_len || neg) {
@@@ -3057,9 -3223,18 +3082,18 @@@
  			}
  
  			if (c == '-') {
 -				err = proc_get_long(&p, &left, &val_b,
 +				err = proc_get_long(&kbuf, &left, &val_b,
  						     &neg, tr_b, sizeof(tr_b),
  						     &c);
+ 				/*
+ 				 * If we consumed all of a truncated buffer or
+ 				 * then stop here, reset, & come back for more.
+ 				 */
+ 				if (!left && skipped) {
+ 					left = saved_left;
+ 					break;
+ 				}
+ 
  				if (err)
  					break;
  				if (val_b >= bitmap_len || neg ||
@@@ -3075,9 -3250,10 +3109,14 @@@
  
  			bitmap_set(tmp_bitmap, val_a, val_b - val_a + 1);
  			first = 0;
 -			proc_skip_char(&p, &left, '\n');
 +			proc_skip_char(&kbuf, &left, '\n');
  		}
++<<<<<<< HEAD
 +		free_page(page);
++=======
+ 		kfree(kbuf);
+ 		left += skipped;
++>>>>>>> 3116ad38f51c (kernel/sysctl.c: fix proc_do_large_bitmap for large input buffers)
  	} else {
  		unsigned long bit_a, bit_b = 0;
  
* Unmerged path kernel/sysctl.c
