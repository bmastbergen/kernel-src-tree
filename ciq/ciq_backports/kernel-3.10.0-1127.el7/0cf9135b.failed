KVM: x86: Emulate MSR_IA32_ARCH_CAPABILITIES on AMD hosts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 0cf9135b773bf32fba9dd8e6699c1b331ee4b749
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/0cf9135b.failed

The CPUID flag ARCH_CAPABILITIES is unconditioinally exposed to host
userspace for all x86 hosts, i.e. KVM advertises ARCH_CAPABILITIES
regardless of hardware support under the pretense that KVM fully
emulates MSR_IA32_ARCH_CAPABILITIES.  Unfortunately, only VMX hosts
handle accesses to MSR_IA32_ARCH_CAPABILITIES (despite KVM_GET_MSRS
also reporting MSR_IA32_ARCH_CAPABILITIES for all hosts).

Move the MSR_IA32_ARCH_CAPABILITIES handling to common x86 code so
that it's emulated on AMD hosts.

Fixes: 1eaafe91a0df4 ("kvm: x86: IA32_ARCH_CAPABILITIES is always supported")
	Cc: stable@vger.kernel.org
	Reported-by: Xiaoyao Li <xiaoyao.li@linux.intel.com>
	Cc: Jim Mattson <jmattson@google.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 0cf9135b773bf32fba9dd8e6699c1b331ee4b749)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/vmx/vmx.c
#	arch/x86/kvm/vmx/vmx.h
#	arch/x86/kvm/x86.c
diff --cc arch/x86/include/asm/kvm_host.h
index 35f22ae3e497,264814f26ce0..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -523,7 -564,11 +523,13 @@@ struct kvm_vcpu_arch 
  	int mp_state;
  	u64 ia32_misc_enable_msr;
  	u64 smbase;
 -	u64 smi_count;
  	bool tpr_access_reporting;
++<<<<<<< HEAD
++=======
+ 	u64 ia32_xss;
+ 	u64 microcode_version;
+ 	u64 arch_capabilities;
++>>>>>>> 0cf9135b773b (KVM: x86: Emulate MSR_IA32_ARCH_CAPABILITIES on AMD hosts)
  
  	/*
  	 * Paging state of the vcpu
diff --cc arch/x86/kvm/x86.c
index 69feb8491cac,9fc378531ca7..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -2142,6 -2439,15 +2142,18 @@@ int kvm_set_msr_common(struct kvm_vcpu 
  	case MSR_F15H_EX_CFG:
  		break;
  
++<<<<<<< HEAD
++=======
+ 	case MSR_IA32_UCODE_REV:
+ 		if (msr_info->host_initiated)
+ 			vcpu->arch.microcode_version = data;
+ 		break;
+ 	case MSR_IA32_ARCH_CAPABILITIES:
+ 		if (!msr_info->host_initiated)
+ 			return 1;
+ 		vcpu->arch.arch_capabilities = data;
+ 		break;
++>>>>>>> 0cf9135b773b (KVM: x86: Emulate MSR_IA32_ARCH_CAPABILITIES on AMD hosts)
  	case MSR_EFER:
  		return set_efer(vcpu, data);
  	case MSR_K7_HWCR:
@@@ -2421,8 -2750,14 +2433,14 @@@ int kvm_get_msr_common(struct kvm_vcpu 
  		msr_info->data = 0;
  		break;
  	case MSR_IA32_UCODE_REV:
 -		msr_info->data = vcpu->arch.microcode_version;
 +		msr_info->data = 0x100000000ULL;
  		break;
+ 	case MSR_IA32_ARCH_CAPABILITIES:
+ 		if (!msr_info->host_initiated &&
+ 		    !guest_cpuid_has(vcpu, X86_FEATURE_ARCH_CAPABILITIES))
+ 			return 1;
+ 		msr_info->data = vcpu->arch.arch_capabilities;
+ 		break;
  	case MSR_IA32_TSC:
  		msr_info->data = kvm_scale_tsc(vcpu, rdtsc()) + vcpu->arch.tsc_offset;
  		break;
@@@ -7706,12 -8744,10 +7724,17 @@@ struct kvm_vcpu *kvm_arch_vcpu_create(s
  
  int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	int r;
 +
++=======
+ 	vcpu->arch.arch_capabilities = kvm_get_arch_capabilities();
+ 	vcpu->arch.msr_platform_info = MSR_PLATFORM_INFO_CPUID_FAULT;
++>>>>>>> 0cf9135b773b (KVM: x86: Emulate MSR_IA32_ARCH_CAPABILITIES on AMD hosts)
  	kvm_vcpu_mtrr_init(vcpu);
 -	vcpu_load(vcpu);
 +	r = vcpu_load(vcpu);
 +	if (r)
 +		return r;
  	kvm_vcpu_reset(vcpu, false);
  	kvm_init_mmu(vcpu, false);
  	vcpu_put(vcpu);
* Unmerged path arch/x86/kvm/vmx/vmx.c
* Unmerged path arch/x86/kvm/vmx/vmx.h
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/vmx/vmx.c
* Unmerged path arch/x86/kvm/vmx/vmx.h
* Unmerged path arch/x86/kvm/x86.c
