dm: Use kzalloc for all structs with embedded biosets/mempools

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Kent Overstreet <kent.overstreet@gmail.com>
commit d377535405686f735b90a8ad4ba269484cd7c96e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/d3775354.failed

mempool_init()/bioset_init() require that the mempools/biosets be zeroed
first; they probably should not _require_ this, but not allocating those
structs with kzalloc is a fairly nonsensical thing to do (calling
mempool_exit()/bioset_exit() on an uninitialized mempool/bioset is legal
and safe, but only works if said memory was zeroed.)

	Acked-by: Mike Snitzer <snitzer@redhat.com>
	Signed-off-by: Kent Overstreet <kent.overstreet@gmail.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit d377535405686f735b90a8ad4ba269484cd7c96e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-bio-prison-v1.c
#	drivers/md/dm-bio-prison-v2.c
diff --cc drivers/md/dm-bio-prison-v1.c
index c7564a342766,e794e3662fdd..000000000000
--- a/drivers/md/dm-bio-prison-v1.c
+++ b/drivers/md/dm-bio-prison-v1.c
@@@ -33,7 -33,8 +33,12 @@@ static struct kmem_cache *_cell_cache
   */
  struct dm_bio_prison *dm_bio_prison_create(void)
  {
++<<<<<<< HEAD
 +	struct dm_bio_prison *prison = kmalloc(sizeof(*prison), GFP_KERNEL);
++=======
+ 	struct dm_bio_prison *prison = kzalloc(sizeof(*prison), GFP_KERNEL);
+ 	int ret;
++>>>>>>> d37753540568 (dm: Use kzalloc for all structs with embedded biosets/mempools)
  
  	if (!prison)
  		return NULL;
diff --cc drivers/md/dm-bio-prison-v2.c
index 8ce3a1a588cf,f866bc97b032..000000000000
--- a/drivers/md/dm-bio-prison-v2.c
+++ b/drivers/md/dm-bio-prison-v2.c
@@@ -35,7 -35,8 +35,12 @@@ static struct kmem_cache *_cell_cache
   */
  struct dm_bio_prison_v2 *dm_bio_prison_create_v2(struct workqueue_struct *wq)
  {
++<<<<<<< HEAD
 +	struct dm_bio_prison_v2 *prison = kmalloc(sizeof(*prison), GFP_KERNEL);
++=======
+ 	struct dm_bio_prison_v2 *prison = kzalloc(sizeof(*prison), GFP_KERNEL);
+ 	int ret;
++>>>>>>> d37753540568 (dm: Use kzalloc for all structs with embedded biosets/mempools)
  
  	if (!prison)
  		return NULL;
* Unmerged path drivers/md/dm-bio-prison-v1.c
* Unmerged path drivers/md/dm-bio-prison-v2.c
diff --git a/drivers/md/dm-io.c b/drivers/md/dm-io.c
index 1797c3acb749..be20283c18e2 100644
--- a/drivers/md/dm-io.c
+++ b/drivers/md/dm-io.c
@@ -50,7 +50,7 @@ struct dm_io_client *dm_io_client_create(void)
 	struct dm_io_client *client;
 	unsigned min_ios = dm_get_reserved_bio_based_ios();
 
-	client = kmalloc(sizeof(*client), GFP_KERNEL);
+	client = kzalloc(sizeof(*client), GFP_KERNEL);
 	if (!client)
 		return ERR_PTR(-ENOMEM);
 
diff --git a/drivers/md/dm-kcopyd.c b/drivers/md/dm-kcopyd.c
index 2cc83b1e6032..2f3f4732cf89 100644
--- a/drivers/md/dm-kcopyd.c
+++ b/drivers/md/dm-kcopyd.c
@@ -820,7 +820,7 @@ struct dm_kcopyd_client *dm_kcopyd_client_create(struct dm_kcopyd_throttle *thro
 	int r = -ENOMEM;
 	struct dm_kcopyd_client *kc;
 
-	kc = kmalloc(sizeof(*kc), GFP_KERNEL);
+	kc = kzalloc(sizeof(*kc), GFP_KERNEL);
 	if (!kc)
 		return ERR_PTR(-ENOMEM);
 
diff --git a/drivers/md/dm-region-hash.c b/drivers/md/dm-region-hash.c
index a1f57656fea5..fd4db744d527 100644
--- a/drivers/md/dm-region-hash.c
+++ b/drivers/md/dm-region-hash.c
@@ -178,7 +178,7 @@ struct dm_region_hash *dm_region_hash_create(
 		;
 	nr_buckets >>= 1;
 
-	rh = kmalloc(sizeof(*rh), GFP_KERNEL);
+	rh = kzalloc(sizeof(*rh), GFP_KERNEL);
 	if (!rh) {
 		DMERR("unable to allocate region hash memory");
 		return ERR_PTR(-ENOMEM);
diff --git a/drivers/md/dm-snap.c b/drivers/md/dm-snap.c
index 4f3251269638..a1b8450b0e7e 100644
--- a/drivers/md/dm-snap.c
+++ b/drivers/md/dm-snap.c
@@ -1136,7 +1136,7 @@ static int snapshot_ctr(struct dm_target *ti, unsigned int argc, char **argv)
 		origin_mode = FMODE_WRITE;
 	}
 
-	s = kmalloc(sizeof(*s), GFP_KERNEL);
+	s = kzalloc(sizeof(*s), GFP_KERNEL);
 	if (!s) {
 		ti->error = "Cannot allocate private snapshot structure";
 		r = -ENOMEM;
diff --git a/drivers/md/dm-thin.c b/drivers/md/dm-thin.c
index 90704334ea25..582f1016fc95 100644
--- a/drivers/md/dm-thin.c
+++ b/drivers/md/dm-thin.c
@@ -3055,7 +3055,7 @@ static struct pool *pool_create(struct mapped_device *pool_md,
 		return (struct pool *)pmd;
 	}
 
-	pool = kmalloc(sizeof(*pool), GFP_KERNEL);
+	pool = kzalloc(sizeof(*pool), GFP_KERNEL);
 	if (!pool) {
 		*error = "Error allocating memory for pool";
 		err_p = ERR_PTR(-ENOMEM);
