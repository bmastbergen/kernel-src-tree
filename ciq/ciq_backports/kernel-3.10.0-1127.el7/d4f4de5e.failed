Fix the locking in dcache_readdir() and friends

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit d4f4de5e5ef8efde85febb6876cd3c8ab1631999
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/d4f4de5e.failed

There are two problems in dcache_readdir() - one is that lockless traversal
of the list needs non-trivial cooperation of d_alloc() (at least a switch
to list_add_rcu(), and probably more than just that) and another is that
it assumes that no removal will happen without the directory locked exclusive.
Said assumption had always been there, never had been stated explicitly and
is violated by several places in the kernel (devpts and selinuxfs).

        * replacement of next_positive() with different calling conventions:
it returns struct list_head * instead of struct dentry *; the latter is
passed in and out by reference, grabbing the result and dropping the original
value.
        * scan is under ->d_lock.  If we run out of timeslice, cursor is moved
after the last position we'd reached and we reschedule; then the scan continues
from that place.  To avoid livelocks between multiple lseek() (with cursors
getting moved past each other, never reaching the real entries) we always
skip the cursors, need_resched() or not.
        * returned list_head * is either ->d_child of dentry we'd found or
->d_subdirs of parent (if we got to the end of the list).
        * dcache_readdir() and dcache_dir_lseek() switched to new helper.
dcache_readdir() always holds a reference to dentry passed to dir_emit() now.
Cursor is moved to just before the entry where dir_emit() has failed or into
the very end of the list, if we'd run out.
        * move_cursor() eliminated - it had sucky calling conventions and
after fixing that it became simply list_move() (in lseek and scan_positives)
or list_move_tail() (in readdir).

        All operations with the list are under ->d_lock now, and we do not
depend upon having all file removals done with parent locked exclusive
anymore.

	Cc: stable@vger.kernel.org
	Reported-by: "zhengbin (A)" <zhengbin13@huawei.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit d4f4de5e5ef8efde85febb6876cd3c8ab1631999)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/libfs.c
diff --cc fs/libfs.c
index 1f2023801ea9,8e023b08a240..000000000000
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@@ -88,6 -88,50 +88,53 @@@ int dcache_dir_close(struct inode *inod
  }
  EXPORT_SYMBOL(dcache_dir_close);
  
++<<<<<<< HEAD
++=======
+ /* parent is locked at least shared */
+ /*
+  * Returns an element of siblings' list.
+  * We are looking for <count>th positive after <p>; if
+  * found, dentry is grabbed and passed to caller via *<res>.
+  * If no such element exists, the anchor of list is returned
+  * and *<res> is set to NULL.
+  */
+ static struct list_head *scan_positives(struct dentry *cursor,
+ 					struct list_head *p,
+ 					loff_t count,
+ 					struct dentry **res)
+ {
+ 	struct dentry *dentry = cursor->d_parent, *found = NULL;
+ 
+ 	spin_lock(&dentry->d_lock);
+ 	while ((p = p->next) != &dentry->d_subdirs) {
+ 		struct dentry *d = list_entry(p, struct dentry, d_child);
+ 		// we must at least skip cursors, to avoid livelocks
+ 		if (d->d_flags & DCACHE_DENTRY_CURSOR)
+ 			continue;
+ 		if (simple_positive(d) && !--count) {
+ 			spin_lock_nested(&d->d_lock, DENTRY_D_LOCK_NESTED);
+ 			if (simple_positive(d))
+ 				found = dget_dlock(d);
+ 			spin_unlock(&d->d_lock);
+ 			if (likely(found))
+ 				break;
+ 			count = 1;
+ 		}
+ 		if (need_resched()) {
+ 			list_move(&cursor->d_child, p);
+ 			p = &cursor->d_child;
+ 			spin_unlock(&dentry->d_lock);
+ 			cond_resched();
+ 			spin_lock(&dentry->d_lock);
+ 		}
+ 	}
+ 	spin_unlock(&dentry->d_lock);
+ 	dput(*res);
+ 	*res = found;
+ 	return p;
+ }
+ 
++>>>>>>> d4f4de5e5ef8 (Fix the locking in dcache_readdir() and friends)
  loff_t dcache_dir_lseek(struct file *file, loff_t offset, int whence)
  {
  	struct dentry *dentry = file->f_path.dentry;
@@@ -103,30 -147,29 +150,53 @@@
  			return -EINVAL;
  	}
  	if (offset != file->f_pos) {
++<<<<<<< HEAD
 +		file->f_pos = offset;
 +		if (file->f_pos >= 2) {
 +			struct list_head *p;
 +			struct dentry *cursor = file->private_data;
 +			loff_t n = file->f_pos - 2;
 +
 +			spin_lock(&dentry->d_lock);
 +			/* d_lock not required for cursor */
 +			list_del(&cursor->d_u.d_child);
 +			p = dentry->d_subdirs.next;
 +			while (n && p != &dentry->d_subdirs) {
 +				struct dentry *next;
 +				next = list_entry(p, struct dentry, d_u.d_child);
 +				spin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);
 +				if (simple_positive(next))
 +					n--;
 +				spin_unlock(&next->d_lock);
 +				p = p->next;
 +			}
 +			list_add_tail(&cursor->d_u.d_child, p);
++=======
+ 		struct dentry *cursor = file->private_data;
+ 		struct dentry *to = NULL;
+ 		struct list_head *p;
+ 
+ 		file->f_pos = offset;
+ 		inode_lock_shared(dentry->d_inode);
+ 
+ 		if (file->f_pos > 2) {
+ 			p = scan_positives(cursor, &dentry->d_subdirs,
+ 					   file->f_pos - 2, &to);
+ 			spin_lock(&dentry->d_lock);
+ 			list_move(&cursor->d_child, p);
+ 			spin_unlock(&dentry->d_lock);
+ 		} else {
+ 			spin_lock(&dentry->d_lock);
+ 			list_del_init(&cursor->d_child);
++>>>>>>> d4f4de5e5ef8 (Fix the locking in dcache_readdir() and friends)
  			spin_unlock(&dentry->d_lock);
  		}
+ 
+ 		dput(to);
+ 
+ 		inode_unlock_shared(dentry->d_inode);
  	}
 +	mutex_unlock(&dentry->d_inode->i_mutex);
  	return offset;
  }
  EXPORT_SYMBOL(dcache_dir_lseek);
@@@ -143,60 -186,33 +213,87 @@@ static inline unsigned char dt_type(str
   * both impossible due to the lock on directory.
   */
  
 -int dcache_readdir(struct file *file, struct dir_context *ctx)
 +int dcache_readdir(struct file * filp, void * dirent, filldir_t filldir)
  {
++<<<<<<< HEAD
 +	struct dentry *dentry = filp->f_path.dentry;
 +	struct dentry *cursor = filp->private_data;
 +	struct list_head *p, *q = &cursor->d_u.d_child;
 +	ino_t ino;
 +	int i = filp->f_pos;
++=======
+ 	struct dentry *dentry = file->f_path.dentry;
+ 	struct dentry *cursor = file->private_data;
+ 	struct list_head *anchor = &dentry->d_subdirs;
+ 	struct dentry *next = NULL;
+ 	struct list_head *p;
++>>>>>>> d4f4de5e5ef8 (Fix the locking in dcache_readdir() and friends)
  
 -	if (!dir_emit_dots(file, ctx))
 -		return 0;
 -
 +	switch (i) {
 +		case 0:
 +			ino = dentry->d_inode->i_ino;
 +			if (filldir(dirent, ".", 1, i, ino, DT_DIR) < 0)
 +				break;
 +			filp->f_pos++;
 +			i++;
 +			/* fallthrough */
 +		case 1:
 +			ino = parent_ino(dentry);
 +			if (filldir(dirent, "..", 2, i, ino, DT_DIR) < 0)
 +				break;
 +			filp->f_pos++;
 +			i++;
 +			/* fallthrough */
 +		default:
 +			spin_lock(&dentry->d_lock);
 +			if (filp->f_pos == 2)
 +				list_move(q, &dentry->d_subdirs);
 +
++<<<<<<< HEAD
 +			for (p=q->next; p != &dentry->d_subdirs; p=p->next) {
 +				struct dentry *next;
 +				next = list_entry(p, struct dentry, d_u.d_child);
 +				spin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);
 +				if (!simple_positive(next)) {
 +					spin_unlock(&next->d_lock);
 +					continue;
 +				}
 +
 +				spin_unlock(&next->d_lock);
 +				spin_unlock(&dentry->d_lock);
 +				if (filldir(dirent, next->d_name.name, 
 +					    next->d_name.len, filp->f_pos, 
 +					    next->d_inode->i_ino, 
 +					    dt_type(next->d_inode)) < 0)
 +					return 0;
 +				spin_lock(&dentry->d_lock);
 +				spin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);
 +				/* next is still alive */
 +				list_move(q, p);
 +				spin_unlock(&next->d_lock);
 +				p = q;
 +				filp->f_pos++;
 +			}
 +			spin_unlock(&dentry->d_lock);
 +	}
++=======
+ 	if (ctx->pos == 2)
+ 		p = anchor;
+ 	else
+ 		p = &cursor->d_child;
+ 
+ 	while ((p = scan_positives(cursor, p, 1, &next)) != anchor) {
+ 		if (!dir_emit(ctx, next->d_name.name, next->d_name.len,
+ 			      d_inode(next)->i_ino, dt_type(d_inode(next))))
+ 			break;
+ 		ctx->pos++;
+ 	}
+ 	spin_lock(&dentry->d_lock);
+ 	list_move_tail(&cursor->d_child, p);
+ 	spin_unlock(&dentry->d_lock);
+ 	dput(next);
+ 
++>>>>>>> d4f4de5e5ef8 (Fix the locking in dcache_readdir() and friends)
  	return 0;
  }
  EXPORT_SYMBOL(dcache_readdir);
* Unmerged path fs/libfs.c
