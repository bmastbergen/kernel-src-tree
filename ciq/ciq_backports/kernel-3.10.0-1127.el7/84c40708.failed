cpuidle: Set polling in poll_idle

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Andy Lutomirski <luto@amacapital.net>
commit 84c407084137d4e491b07ea5ff8665d19106a5ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/84c40708.failed

poll_idle is the archetypal polling idle loop; tell the core idle
code about it.

This avoids pointless IPIs when all of the other cpuidle states are
disabled.

	Signed-off-by: Andy Lutomirski <luto@amacapital.net>
	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
	Cc: nicolas.pitre@linaro.org
	Cc: umgwanakikbuti@gmail.com
	Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
	Cc: linux-kernel@vger.kernel.org
	Cc: linux-pm@vger.kernel.org
Link: http://lkml.kernel.org/r/c65ce49615d338bae8fb79df5daffab19353c900.1401902905.git.luto@amacapital.net
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 84c407084137d4e491b07ea5ff8665d19106a5ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpuidle/driver.c
diff --cc drivers/cpuidle/driver.c
index 3ac499d5a207,9634f20e3926..000000000000
--- a/drivers/cpuidle/driver.c
+++ b/drivers/cpuidle/driver.c
@@@ -169,20 -168,58 +169,65 @@@ static int __cpuidle_driver_init(struc
  	/*
  	 * Look for the timer stop flag in the different states, so that we know
  	 * if the broadcast timer has to be set up.  The loop is in the reverse
 -	 * order, because usually one of the deeper states have this flag set.
 +	 * order, because usually on of the the deeper states has this flag set.
  	 */
  	for (i = drv->state_count - 1; i >= 0 ; i--) {
 -		if (drv->states[i].flags & CPUIDLE_FLAG_TIMER_STOP) {
 -			drv->bctimer = 1;
 -			break;
 -		}
 +
 +		if (!(drv->states[i].flags & CPUIDLE_FLAG_TIMER_STOP))
 +			continue;
 +
 +		drv->bctimer = 1;
 +		break;
  	}
 +
 +	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARCH_HAS_CPU_RELAX
+ static int poll_idle(struct cpuidle_device *dev,
+ 		struct cpuidle_driver *drv, int index)
+ {
+ 	ktime_t	t1, t2;
+ 	s64 diff;
+ 
+ 	t1 = ktime_get();
+ 	local_irq_enable();
+ 	if (!current_set_polling_and_test()) {
+ 		while (!need_resched())
+ 			cpu_relax();
+ 	}
+ 	current_clr_polling();
+ 
+ 	t2 = ktime_get();
+ 	diff = ktime_to_us(ktime_sub(t2, t1));
+ 	if (diff > INT_MAX)
+ 		diff = INT_MAX;
+ 
+ 	dev->last_residency = (int) diff;
+ 
+ 	return index;
+ }
+ 
+ static void poll_idle_init(struct cpuidle_driver *drv)
+ {
+ 	struct cpuidle_state *state = &drv->states[0];
+ 
+ 	snprintf(state->name, CPUIDLE_NAME_LEN, "POLL");
+ 	snprintf(state->desc, CPUIDLE_DESC_LEN, "CPUIDLE CORE POLL IDLE");
+ 	state->exit_latency = 0;
+ 	state->target_residency = 0;
+ 	state->power_usage = -1;
+ 	state->flags = CPUIDLE_FLAG_TIME_VALID;
+ 	state->enter = poll_idle;
+ 	state->disabled = false;
+ }
+ #else
+ static void poll_idle_init(struct cpuidle_driver *drv) {}
+ #endif /* !CONFIG_ARCH_HAS_CPU_RELAX */
+ 
++>>>>>>> 84c407084137 (cpuidle: Set polling in poll_idle)
  /**
   * __cpuidle_register_driver: register the driver
   * @drv: a valid pointer to a struct cpuidle_driver
* Unmerged path drivers/cpuidle/driver.c
