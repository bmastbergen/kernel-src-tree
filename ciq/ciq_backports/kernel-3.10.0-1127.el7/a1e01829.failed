sched: Remove double_rq_lock() from __migrate_task()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Kirill Tkhai <ktkhai@parallels.com>
commit a1e01829796aa7a993e28ffd7fee5c8d525be175
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/a1e01829.failed

Avoid double_rq_lock() and use TASK_ON_RQ_MIGRATING for
__migrate_task(). The advantage is (obviously) not holding two
rq->lock's at the same time and thereby increasing parallelism.

The important point to note is that because we acquire dst->lock
immediately after releasing src->lock the potential wait time of
task_rq_lock() callers on TASK_ON_RQ_MIGRATING is not longer
than it would have been in the double rq lock scenario.

	Signed-off-by: Kirill Tkhai <ktkhai@parallels.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Paul Turner <pjt@google.com>
	Cc: Oleg Nesterov <oleg@redhat.com>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Mike Galbraith <umgwanakikbuti@gmail.com>
	Cc: Kirill Tkhai <tkhai@yandex.ru>
	Cc: Tim Chen <tim.c.chen@linux.intel.com>
	Cc: Nicolas Pitre <nicolas.pitre@linaro.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
Link: http://lkml.kernel.org/r/1408528070.23412.89.camel@tkhai
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit a1e01829796aa7a993e28ffd7fee5c8d525be175)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/core.c
diff --cc kernel/sched/core.c
index 13966acd35e8,a773c919d88d..000000000000
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@@ -6079,10 -4702,17 +6079,24 @@@ static int __migrate_task(struct task_s
  	 * placed properly.
  	 */
  	if (task_on_rq_queued(p)) {
++<<<<<<< HEAD
 +		dequeue_task(rq_src, p, DEQUEUE_SAVE);
 +		set_task_cpu(p, dest_cpu);
 +		enqueue_task(rq_dest, p, ENQUEUE_RESTORE);
 +		check_preempt_curr(rq_dest, p, 0);
++=======
+ 		dequeue_task(rq, p, 0);
+ 		p->on_rq = TASK_ON_RQ_MIGRATING;
+ 		set_task_cpu(p, dest_cpu);
+ 		raw_spin_unlock(&rq->lock);
+ 
+ 		rq = cpu_rq(dest_cpu);
+ 		raw_spin_lock(&rq->lock);
+ 		BUG_ON(task_rq(p) != rq);
+ 		p->on_rq = TASK_ON_RQ_QUEUED;
+ 		enqueue_task(rq, p, 0);
+ 		check_preempt_curr(rq, p, 0);
++>>>>>>> a1e01829796a (sched: Remove double_rq_lock() from __migrate_task())
  	}
  done:
  	ret = 1;
* Unmerged path kernel/sched/core.c
