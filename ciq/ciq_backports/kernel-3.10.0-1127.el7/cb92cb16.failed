scsi: qla2xxx: Fix flash read for Qlogic ISPs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Quinn Tran <qutran@marvell.com>
commit cb92cb1657c438efe7c88c9759f40c0a9d46c353
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/cb92cb16.failed

Use adapter specific callback to read flash instead of ISP adapter
specific.

	Signed-off-by: Quinn Tran <qutran@marvell.com>
	Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
	Reviewed-by: Ewan D. Milne <emilne@redhat.com>
Link: https://lore.kernel.org/r/20190830222402.23688-3-hmadhani@marvell.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit cb92cb1657c438efe7c88c9759f40c0a9d46c353)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_sup.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 95ac54b7b8fc,d9e8b808bb59..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -8026,14 -8214,35 +8026,41 @@@ qla81xx_nvram_config(scsi_qla_host_t *v
  	if (IS_P3P_TYPE(ha) || IS_QLA8031(ha))
  		ha->vpd_size = FA_VPD_SIZE_82XX;
  
 -	if (IS_QLA28XX(ha) || IS_QLA27XX(ha))
 -		qla28xx_get_aux_images(vha, &active_regions);
 -
  	/* Get VPD data into cache */
  	ha->vpd = ha->nvram + VPD_OFFSET;
++<<<<<<< HEAD
 +	ha->isp_ops->read_optrom(vha, ha->vpd, ha->flt_region_vpd << 2,
 +	    ha->vpd_size);
 +
 +	/* Get NVRAM data into cache and calculate checksum. */
 +	ha->isp_ops->read_optrom(vha, ha->nvram, ha->flt_region_nvram << 2,
 +	    ha->nvram_size);
++=======
+ 
+ 	faddr = ha->flt_region_vpd;
+ 	if (IS_QLA28XX(ha)) {
+ 		if (active_regions.aux.vpd_nvram == QLA27XX_SECONDARY_IMAGE)
+ 			faddr = ha->flt_region_vpd_sec;
+ 		ql_dbg(ql_dbg_init, vha, 0x0110,
+ 		    "Loading %s nvram image.\n",
+ 		    active_regions.aux.vpd_nvram == QLA27XX_PRIMARY_IMAGE ?
+ 		    "primary" : "secondary");
+ 	}
+ 	ha->isp_ops->read_optrom(vha, ha->vpd, faddr << 2, ha->vpd_size);
+ 
+ 	/* Get NVRAM data into cache and calculate checksum. */
+ 	faddr = ha->flt_region_nvram;
+ 	if (IS_QLA28XX(ha)) {
+ 		if (active_regions.aux.vpd_nvram == QLA27XX_SECONDARY_IMAGE)
+ 			faddr = ha->flt_region_nvram_sec;
+ 	}
+ 	ql_dbg(ql_dbg_init, vha, 0x0110,
+ 	    "Loading %s nvram image.\n",
+ 	    active_regions.aux.vpd_nvram == QLA27XX_PRIMARY_IMAGE ?
+ 	    "primary" : "secondary");
+ 	ha->isp_ops->read_optrom(vha, ha->nvram, faddr << 2, ha->nvram_size);
+ 
++>>>>>>> cb92cb1657c4 (scsi: qla2xxx: Fix flash read for Qlogic ISPs)
  	dptr = (uint32_t *)nv;
  	for (cnt = 0, chksum = 0; cnt < ha->nvram_size >> 2; cnt++, dptr++)
  		chksum += le32_to_cpu(*dptr);
diff --cc drivers/scsi/qla2xxx/qla_sup.c
index d78d2bdfd652,f2d5115b2d8d..000000000000
--- a/drivers/scsi/qla2xxx/qla_sup.c
+++ b/drivers/scsi/qla2xxx/qla_sup.c
@@@ -686,12 -681,11 +686,20 @@@ qla2xxx_get_flt_info(scsi_qla_host_t *v
  	    fcp_prio_cfg0[def] : fcp_prio_cfg1[def];
  
  	ha->flt_region_flt = flt_addr;
++<<<<<<< HEAD
 +	wptr = (uint16_t *)req->ring;
 +	flt = (struct qla_flt_header *)req->ring;
 +	region = (struct qla_flt_region *)&flt[1];
 +	ha->isp_ops->read_optrom(vha, (uint8_t *)req->ring,
 +	    flt_addr << 2, OPTROM_BURST_SIZE);
 +	if (*wptr == cpu_to_le16(0xffff))
++=======
+ 	wptr = (uint16_t *)ha->flt;
+ 	ha->isp_ops->read_optrom(vha, (void *)flt, flt_addr << 2,
+ 	    (sizeof(struct qla_flt_header) + FLT_REGIONS_SIZE));
+ 
+ 	if (le16_to_cpu(*wptr) == 0xffff)
++>>>>>>> cb92cb1657c4 (scsi: qla2xxx: Fix flash read for Qlogic ISPs)
  		goto no_flash_data;
  	if (flt->version != cpu_to_le16(1)) {
  		ql_log(ql_log_warn, vha, 0x0047,
@@@ -912,22 -946,19 +920,33 @@@ qla2xxx_get_fdt_info(scsi_qla_host_t *v
  #define FLASH_BLK_SIZE_32K	0x8000
  #define FLASH_BLK_SIZE_64K	0x10000
  	const char *loc, *locations[] = { "MID", "FDT" };
 -	struct qla_hw_data *ha = vha->hw;
 -	struct req_que *req = ha->req_q_map[0];
  	uint16_t cnt, chksum;
++<<<<<<< HEAD
 +	uint16_t *wptr;
 +	struct qla_fdt_layout *fdt;
++=======
+ 	uint16_t *wptr = (void *)req->ring;
+ 	struct qla_fdt_layout *fdt = (struct qla_fdt_layout *)req->ring;
++>>>>>>> cb92cb1657c4 (scsi: qla2xxx: Fix flash read for Qlogic ISPs)
  	uint8_t	man_id, flash_id;
  	uint16_t mid = 0, fid = 0;
 +	struct qla_hw_data *ha = vha->hw;
 +	struct req_que *req = ha->req_q_map[0];
  
++<<<<<<< HEAD
 +	wptr = (uint16_t *)req->ring;
 +	fdt = (struct qla_fdt_layout *)req->ring;
 +	ha->isp_ops->read_optrom(vha, (uint8_t *)req->ring,
 +	    ha->flt_region_fdt << 2, OPTROM_BURST_SIZE);
 +	if (*wptr == cpu_to_le16(0xffff))
++=======
+ 	ha->isp_ops->read_optrom(vha, fdt, ha->flt_region_fdt << 2,
+ 	    OPTROM_BURST_DWORDS);
+ 	if (le16_to_cpu(*wptr) == 0xffff)
++>>>>>>> cb92cb1657c4 (scsi: qla2xxx: Fix flash read for Qlogic ISPs)
  		goto no_flash_data;
 -	if (memcmp(fdt->sig, "QLID", 4))
 +	if (fdt->sig[0] != 'Q' || fdt->sig[1] != 'L' || fdt->sig[2] != 'I' ||
 +	    fdt->sig[3] != 'D')
  		goto no_flash_data;
  
  	for (cnt = 0, chksum = 0; cnt < sizeof(*fdt) >> 1; cnt++, wptr++)
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_nx.c b/drivers/scsi/qla2xxx/qla_nx.c
index 868bfb56d972..2faad3f87b7c 100644
--- a/drivers/scsi/qla2xxx/qla_nx.c
+++ b/drivers/scsi/qla2xxx/qla_nx.c
@@ -2272,6 +2272,7 @@ qla82xx_disable_intrs(struct qla_hw_data *ha)
 {
 	scsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);
 	qla82xx_mbx_intr_disable(vha);
+
 	spin_lock_irq(&ha->hardware_lock);
 	if (IS_QLA8044(ha))
 		qla8044_wr_reg(ha, LEG_INTR_MASK_OFFSET, 1);
* Unmerged path drivers/scsi/qla2xxx/qla_sup.c
