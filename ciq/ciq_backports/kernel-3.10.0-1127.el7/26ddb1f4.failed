fs: Turn __generic_write_end into a void function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 26ddb1f4fd884258eeb8a8d7f2d40b163f00fedd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/26ddb1f4.failed

The VFS-internal __generic_write_end helper always returns the value of
its @copied argument.  This can be confusing, and it isn't very useful
anyway, so turn __generic_write_end into a function returning void
instead.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 26ddb1f4fd884258eeb8a8d7f2d40b163f00fedd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/buffer.c
#	fs/internal.h
#	fs/iomap.c
diff --cc fs/buffer.c
index ccb67909a9cb,e0d4c6a5e2d2..000000000000
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@@ -2066,17 -2085,15 +2066,22 @@@ int block_write_begin(struct address_sp
  }
  EXPORT_SYMBOL(block_write_begin);
  
++<<<<<<< HEAD
 +int __generic_write_end(struct file *file, struct address_space *mapping,
 +			loff_t pos, unsigned len, unsigned copied,
 +			struct page *page, void *fsdata)
++=======
+ void __generic_write_end(struct inode *inode, loff_t pos, unsigned copied,
+ 		struct page *page)
++>>>>>>> 26ddb1f4fd88 (fs: Turn __generic_write_end into a void function)
  {
 +	struct inode *inode = mapping->host;
  	loff_t old_size = inode->i_size;
 -	bool i_size_changed = false;
 +	int i_size_changed = 0;
  
  	/*
 -	 * No need to use i_size_read() here, the i_size cannot change under us
 -	 * because we hold i_rwsem.
 +	 * No need to use i_size_read() here, the i_size
 +	 * cannot change under us because we hold i_mutex.
  	 *
  	 * But it's important to update i_size while still holding page lock:
  	 * page writeout could otherwise come in and zero beyond i_size.
@@@ -2099,8 -2116,6 +2104,11 @@@
  	 */
  	if (i_size_changed)
  		mark_inode_dirty(inode);
++<<<<<<< HEAD
 +
 +	return copied;
++=======
++>>>>>>> 26ddb1f4fd88 (fs: Turn __generic_write_end into a void function)
  }
  
  int block_write_end(struct file *file, struct address_space *mapping,
@@@ -2144,9 -2159,8 +2152,14 @@@ int generic_write_end(struct file *file
  			struct page *page, void *fsdata)
  {
  	copied = block_write_end(file, mapping, pos, len, copied, page, fsdata);
++<<<<<<< HEAD
 +
 +	return __generic_write_end(file, mapping, pos, len, copied, page,
 +				   fsdata);
++=======
+ 	__generic_write_end(mapping->host, pos, copied, page);
+ 	return copied;
++>>>>>>> 26ddb1f4fd88 (fs: Turn __generic_write_end into a void function)
  }
  EXPORT_SYMBOL(generic_write_end);
  
diff --cc fs/internal.h
index 3310bfe574a4,530587fdf5d8..000000000000
--- a/fs/internal.h
+++ b/fs/internal.h
@@@ -44,9 -44,8 +44,14 @@@ static inline int __sync_blockdev(struc
  extern void guard_bio_eod(int rw, struct bio *bio);
  extern int __block_write_begin_int(struct page *page, loff_t pos, unsigned len,
  		get_block_t *get_block, struct iomap *iomap);
++<<<<<<< HEAD
 +extern int __generic_write_end(struct file *file, struct address_space *mapping,
 +			       loff_t pos, unsigned len, unsigned copied,
 +			       struct page *page, void *fsdata);
++=======
+ void __generic_write_end(struct inode *inode, loff_t pos, unsigned copied,
+ 		struct page *page);
++>>>>>>> 26ddb1f4fd88 (fs: Turn __generic_write_end into a void function)
  
  /*
   * char_dev.c
diff --cc fs/iomap.c
index b368e069ba43,4380d2c412f4..000000000000
--- a/fs/iomap.c
+++ b/fs/iomap.c
@@@ -186,13 -761,15 +186,17 @@@ iomap_write_end(struct inode *inode, lo
  	int ret;
  
  	if (iomap->type == IOMAP_INLINE) {
 -		ret = iomap_write_end_inline(inode, page, iomap, pos, copied);
 -	} else if (iomap->flags & IOMAP_F_BUFFER_HEAD) {
 -		ret = block_write_end(NULL, inode->i_mapping, pos, len, copied,
 -				page, NULL);
 +		ret = iomap_write_end_inline(inode, page, iomap, pos, len,
 +				copied);
  	} else {
 -		ret = __iomap_write_end(inode, pos, len, copied, page, iomap);
 +		ret = generic_write_end(NULL, inode->i_mapping, pos, len,
 +				copied, page, NULL);
  	}
  
++<<<<<<< HEAD
++=======
+ 	__generic_write_end(inode, pos, ret, page);
++>>>>>>> 26ddb1f4fd88 (fs: Turn __generic_write_end into a void function)
  	if (iomap->page_done)
  		iomap->page_done(inode, pos, copied, page, iomap);
  
* Unmerged path fs/buffer.c
* Unmerged path fs/internal.h
* Unmerged path fs/iomap.c
