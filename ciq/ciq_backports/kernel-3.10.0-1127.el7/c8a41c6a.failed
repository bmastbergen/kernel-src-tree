mac80211: Don't memset RXCB prior to PAE intercept

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Denis Kenzior <denkenz@gmail.com>
commit c8a41c6afa27b8c3f61622dfd882b912da9d6721
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/c8a41c6a.failed

In ieee80211_deliver_skb_to_local_stack intercepts EAPoL frames if
mac80211 is configured to do so and forwards the contents over nl80211.
During this process some additional data is also forwarded, including
whether the frame was received encrypted or not.  Unfortunately just
prior to the call to ieee80211_deliver_skb_to_local_stack, skb->cb is
cleared, resulting in incorrect data being exposed over nl80211.

Fixes: 018f6fbf540d ("mac80211: Send control port frames over nl80211")
	Cc: stable@vger.kernel.org
	Signed-off-by: Denis Kenzior <denkenz@gmail.com>
Link: https://lore.kernel.org/r/20190827224120.14545-2-denkenz@gmail.com
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit c8a41c6afa27b8c3f61622dfd882b912da9d6721)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/rx.c
diff --cc net/mac80211/rx.c
index 708be6c719d8,7c4aeac006fb..000000000000
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@@ -2250,6 -2437,31 +2250,34 @@@ static bool ieee80211_frame_allowed(str
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ static void ieee80211_deliver_skb_to_local_stack(struct sk_buff *skb,
+ 						 struct ieee80211_rx_data *rx)
+ {
+ 	struct ieee80211_sub_if_data *sdata = rx->sdata;
+ 	struct net_device *dev = sdata->dev;
+ 
+ 	if (unlikely((skb->protocol == sdata->control_port_protocol ||
+ 		      skb->protocol == cpu_to_be16(ETH_P_PREAUTH)) &&
+ 		     sdata->control_port_over_nl80211)) {
+ 		struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+ 		bool noencrypt = status->flag & RX_FLAG_DECRYPTED;
+ 
+ 		cfg80211_rx_control_port(dev, skb, noencrypt);
+ 		dev_kfree_skb(skb);
+ 	} else {
+ 		memset(skb->cb, 0, sizeof(skb->cb));
+ 
+ 		/* deliver to local stack */
+ 		if (rx->napi)
+ 			napi_gro_receive(rx->napi, skb);
+ 		else
+ 			netif_receive_skb(skb);
+ 	}
+ }
+ 
++>>>>>>> c8a41c6afa27 (mac80211: Don't memset RXCB prior to PAE intercept)
  /*
   * requires that rx->skb is a frame with ethernet header
   */
@@@ -2334,13 -2547,8 +2362,17 @@@ ieee80211_deliver_skb(struct ieee80211_
  #endif
  
  	if (skb) {
 +		/* deliver to local stack */
  		skb->protocol = eth_type_trans(skb, dev);
++<<<<<<< HEAD
 +		memset(skb->cb, 0, sizeof(skb->cb));
 +		if (rx->napi)
 +			napi_gro_receive(rx->napi, skb);
 +		else
 +			netif_receive_skb(skb);
++=======
+ 		ieee80211_deliver_skb_to_local_stack(skb, rx);
++>>>>>>> c8a41c6afa27 (mac80211: Don't memset RXCB prior to PAE intercept)
  	}
  
  	if (xmit_skb) {
* Unmerged path net/mac80211/rx.c
