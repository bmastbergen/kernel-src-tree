s390/qeth: clean up page frag creation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Julian Wiedmann <jwi@linux.vnet.ibm.com>
commit b6f72f9698ab8bd79cd0b72a8d9f25dacd786563
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/b6f72f96.failed

Replace the open-coded skb_add_rx_frag(), and use a fall-through
to remove some duplicated code.

	Signed-off-by: Julian Wiedmann <jwi@linux.vnet.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b6f72f9698ab8bd79cd0b72a8d9f25dacd786563)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core_main.c
diff --cc drivers/s390/net/qeth_core_main.c
index b1a62a620d2b,1cf4e066955f..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -5104,11 -5170,13 +5104,19 @@@ out
  }
  EXPORT_SYMBOL_GPL(qeth_core_hardsetup_card);
  
++<<<<<<< HEAD
 +static inline int qeth_create_skb_frag(struct qeth_qdio_buffer *qethbuffer,
 +		struct qdio_buffer_element *element,
 +		struct sk_buff **pskb, int offset, int *pfrag, int data_len)
++=======
+ static int qeth_create_skb_frag(struct qeth_qdio_buffer *qethbuffer,
+ 				struct qdio_buffer_element *element,
+ 				struct sk_buff **pskb, int offset, int data_len)
++>>>>>>> b6f72f9698ab (s390/qeth: clean up page frag creation)
  {
  	struct page *page = virt_to_page(element->addr);
+ 	unsigned int next_frag;
+ 
  	if (*pskb == NULL) {
  		if (qethbuffer->rx_skb) {
  			/* only if qeth_card.options.cq == QETH_CQ_ENABLED */
@@@ -5122,30 -5190,20 +5130,36 @@@
  
  		skb_reserve(*pskb, ETH_HLEN);
  		if (data_len <= QETH_RX_PULL_LEN) {
++<<<<<<< HEAD
 +			memcpy(skb_put(*pskb, data_len), element->addr + offset,
 +				data_len);
 +		} else {
 +			get_page(page);
 +			memcpy(skb_put(*pskb, QETH_RX_PULL_LEN),
 +			       element->addr + offset, QETH_RX_PULL_LEN);
 +			skb_fill_page_desc(*pskb, *pfrag, page,
 +				offset + QETH_RX_PULL_LEN,
 +				data_len - QETH_RX_PULL_LEN);
 +			(*pskb)->data_len += data_len - QETH_RX_PULL_LEN;
 +			(*pskb)->len      += data_len - QETH_RX_PULL_LEN;
 +			(*pskb)->truesize += data_len - QETH_RX_PULL_LEN;
 +			(*pfrag)++;
++=======
+ 			skb_put_data(*pskb, element->addr + offset, data_len);
+ 			return 0;
+ 		} else {
+ 			skb_put_data(*pskb, element->addr + offset,
+ 				     QETH_RX_PULL_LEN);
+ 			data_len -= QETH_RX_PULL_LEN;
+ 			offset += QETH_RX_PULL_LEN;
+ 			/* fall through to add page frag for remaining data */
++>>>>>>> b6f72f9698ab (s390/qeth: clean up page frag creation)
  		}
- 	} else {
- 		get_page(page);
- 		skb_fill_page_desc(*pskb, *pfrag, page, offset, data_len);
- 		(*pskb)->data_len += data_len;
- 		(*pskb)->len      += data_len;
- 		(*pskb)->truesize += data_len;
- 		(*pfrag)++;
  	}
  
- 
+ 	next_frag = skb_shinfo(*pskb)->nr_frags;
+ 	get_page(page);
+ 	skb_add_rx_frag(*pskb, next_frag, page, offset, data_len, data_len);
  	return 0;
  }
  
@@@ -5215,11 -5277,10 +5228,11 @@@ struct sk_buff *qeth_core_get_next_skb(
  		if (data_len) {
  			if (use_rx_sg) {
  				if (qeth_create_skb_frag(qethbuffer, element,
- 				    &skb, offset, &frag, data_len))
+ 				    &skb, offset, data_len))
  					goto no_mem;
  			} else {
 -				skb_put_data(skb, data_ptr, data_len);
 +				memcpy(skb_put(skb, data_len), data_ptr,
 +					data_len);
  			}
  		}
  		skb_len -= data_len;
* Unmerged path drivers/s390/net/qeth_core_main.c
