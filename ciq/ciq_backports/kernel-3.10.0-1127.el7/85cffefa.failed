scsi: qla2xxx: Fix a race condition between aborting and completing a SCSI command

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Bart Van Assche <bvanassche@acm.org>
commit 85cffefa09e448906a6f0bc20f422d75a18675bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/85cffefa.failed

Instead of allocating a struct srb dynamically from inside .queuecommand(),
set qla2xxx_driver_template.cmd_size such that struct scsi_cmnd and struct
srb are contiguous. Do not call QLA_QPAIR_MARK_BUSY() /
QLA_QPAIR_MARK_NOT_BUSY() for SRBs associated with SCSI commands. That is
safe because scsi_remove_host() is called before queue pairs are deleted
and scsi_remove_host() waits for all outstanding SCSI commands to finish.

	Cc: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Bart Van Assche <bvanassche@acm.org>
	Tested-by: Himanshu Madhani <hmadhani@marvell.com>
	Reviewed-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 85cffefa09e448906a6f0bc20f422d75a18675bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_os.c
index d8902b90b121,5ca7f7913258..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -778,13 -707,16 +778,18 @@@ qla2x00_sp_compl(void *ptr, int res
  
  	sp->free(sp);
  	cmd->result = res;
 -	CMD_SP(cmd) = NULL;
  	cmd->scsi_done(cmd);
++<<<<<<< HEAD
++=======
+ 	if (comp)
+ 		complete(comp);
++>>>>>>> 85cffefa09e4 (scsi: qla2xxx: Fix a race condition between aborting and completing a SCSI command)
  }
  
 -void qla2xxx_qpair_sp_free_dma(srb_t *sp)
 +void
 +qla2xxx_qpair_sp_free_dma(void *ptr)
  {
 +	srb_t *sp = (srb_t *)ptr;
  	struct scsi_cmnd *cmd = GET_CMD_SP(sp);
  	struct qla_hw_data *ha = sp->fcport->vha->hw;
  	void *ctx = GET_CMD_CTX_SP(sp);
@@@ -862,32 -777,42 +867,37 @@@
  		sp->flags &= ~SRB_DIF_BUNDL_DMA_VALID;
  	}
  
 -	if (sp->flags & SRB_FCP_CMND_DMA_VALID) {
 -		struct ct6_dsd *ctx1 = ctx;
 -
 -		dma_pool_free(ha->fcp_cmnd_dma_pool, ctx1->fcp_cmnd,
 -		    ctx1->fcp_cmnd_dma);
 -		list_splice(&ctx1->dsd_list, &ha->gbl_dsd_list);
 -		ha->gbl_dsd_inuse -= ctx1->dsd_use_cnt;
 -		ha->gbl_dsd_avail += ctx1->dsd_use_cnt;
 -		mempool_free(ctx1, ha->ctx_mempool);
 -		sp->flags &= ~SRB_FCP_CMND_DMA_VALID;
 -	}
 -
 -	if (sp->flags & SRB_CRC_CTX_DMA_VALID) {
 -		struct crc_context *ctx0 = ctx;
 -
 -		dma_pool_free(ha->dl_dma_pool, ctx, ctx0->crc_ctx_dma);
 -		sp->flags &= ~SRB_CRC_CTX_DMA_VALID;
 -	}
 +end:
 +	CMD_SP(cmd) = NULL;
 +	qla2xxx_rel_qpair_sp(sp->qpair, sp);
  }
  
 -void qla2xxx_qpair_sp_compl(srb_t *sp, int res)
 +void
 +qla2xxx_qpair_sp_compl(void *ptr, int res)
  {
 +	srb_t *sp = ptr;
  	struct scsi_cmnd *cmd = GET_CMD_SP(sp);
 -	struct completion *comp = sp->comp;
  
 -	if (WARN_ON_ONCE(atomic_read(&sp->ref_count) == 0))
 -		return;
 +	cmd->result = res;
  
 -	atomic_dec(&sp->ref_count);
 +	if (atomic_read(&sp->ref_count) == 0) {
 +		ql_dbg(ql_dbg_io, sp->fcport->vha, 0x3079,
 +		    "SP reference-count to ZERO -- sp=%p cmd=%p.\n",
 +		    sp, GET_CMD_SP(sp));
 +		if (ql2xextended_error_logging & ql_dbg_io)
 +			WARN_ON(atomic_read(&sp->ref_count) == 0);
 +		return;
 +	}
 +	if (!atomic_dec_and_test(&sp->ref_count))
 +		return;
  
  	sp->free(sp);
 -	cmd->result = res;
 -	CMD_SP(cmd) = NULL;
  	cmd->scsi_done(cmd);
++<<<<<<< HEAD
++=======
+ 	if (comp)
+ 		complete(comp);
++>>>>>>> 85cffefa09e4 (scsi: qla2xxx: Fix a race condition between aborting and completing a SCSI command)
  }
  
  static int
@@@ -1328,13 -1242,13 +1330,18 @@@ static in
  qla2xxx_eh_abort(struct scsi_cmnd *cmd)
  {
  	scsi_qla_host_t *vha = shost_priv(cmd->device->host);
 -	DECLARE_COMPLETION_ONSTACK(comp);
  	srb_t *sp;
  	int ret;
++<<<<<<< HEAD
 +	unsigned int id, lun;
 +	unsigned long flags;
 +	int rval, wait = 0;
++=======
+ 	unsigned int id;
+ 	uint64_t lun;
+ 	int rval;
++>>>>>>> 85cffefa09e4 (scsi: qla2xxx: Fix a race condition between aborting and completing a SCSI command)
  	struct qla_hw_data *ha = vha->hw;
- 	struct qla_qpair *qpair;
  
  	if (qla2x00_isp_reg_stat(ha)) {
  		ql_log(ql_log_info, vha, 0x8042,
@@@ -1345,33 -1259,15 +1352,33 @@@
  	ret = fc_block_scsi_eh(cmd);
  	if (ret != 0)
  		return ret;
 +	ret = SUCCESS;
  
- 	sp = (srb_t *) CMD_SP(cmd);
- 	if (!sp)
- 		return SUCCESS;
- 
- 	qpair = sp->qpair;
- 	if (!qpair)
- 		return SUCCESS;
+ 	sp = scsi_cmd_priv(cmd);
  
  	if (sp->fcport && sp->fcport->deleted)
  		return SUCCESS;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(qpair->qp_lock_ptr, flags);
 +	if (!CMD_SP(cmd)) {
 +		/* there's a chance an interrupt could clear
 +		   the ptr as part of done & free */
 +		spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
 +		return SUCCESS;
 +	}
 +
 +	if (sp_get(sp)){
 +		/* ref_count is already 0 */
 +		spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
 +		return SUCCESS;
 +	}
 +	spin_unlock_irqrestore(qpair->qp_lock_ptr, flags);
++=======
+ 	/* Return if the command has already finished. */
+ 	if (sp_get(sp))
+ 		return SUCCESS;
++>>>>>>> 85cffefa09e4 (scsi: qla2xxx: Fix a race condition between aborting and completing a SCSI command)
  
  	id = cmd->device->id;
  	lun = cmd->device->lun;
@@@ -7226,12 -7034,104 +7233,60 @@@ qla2xxx_pci_resume(struct pci_dev *pdev
  		ql_log(ql_log_fatal, base_vha, 0x9002,
  		    "The device failed to resume I/O from slot/link_reset.\n");
  	}
 -}
 -
 -static void
 -qla_pci_reset_prepare(struct pci_dev *pdev)
 -{
 -	scsi_qla_host_t *base_vha = pci_get_drvdata(pdev);
 -	struct qla_hw_data *ha = base_vha->hw;
 -	struct qla_qpair *qpair;
 -
 -	ql_log(ql_log_warn, base_vha, 0xffff,
 -	    "%s.\n", __func__);
  
 -	/*
 -	 * PCI FLR/function reset is about to reset the
 -	 * slot. Stop the chip to stop all DMA access.
 -	 * It is assumed that pci_reset_done will be called
 -	 * after FLR to resume Chip operation.
 -	 */
 -	ha->flags.eeh_busy = 1;
 -	mutex_lock(&ha->mq_lock);
 -	list_for_each_entry(qpair, &base_vha->qp_list, qp_list_elem)
 -		qpair->online = 0;
 -	mutex_unlock(&ha->mq_lock);
 +	pci_cleanup_aer_uncorrect_error_status(pdev);
  
 -	set_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags);
 -	qla2x00_abort_isp_cleanup(base_vha);
 -	qla2x00_abort_all_cmds(base_vha, DID_RESET << 16);
 -}
 -
 -static void
 -qla_pci_reset_done(struct pci_dev *pdev)
 -{
 -	scsi_qla_host_t *base_vha = pci_get_drvdata(pdev);
 -	struct qla_hw_data *ha = base_vha->hw;
 -	struct qla_qpair *qpair;
 -
 -	ql_log(ql_log_warn, base_vha, 0xffff,
 -	    "%s.\n", __func__);
 -
 -	/*
 -	 * FLR just completed by PCI layer. Resume adapter
 -	 */
  	ha->flags.eeh_busy = 0;
 -	mutex_lock(&ha->mq_lock);
 -	list_for_each_entry(qpair, &base_vha->qp_list, qp_list_elem)
 -		qpair->online = 1;
 -	mutex_unlock(&ha->mq_lock);
 -
 -	base_vha->flags.online = 1;
 -	ha->isp_ops->abort_isp(base_vha);
 -	clear_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags);
  }
  
++<<<<<<< HEAD
++=======
+ static int qla2xxx_map_queues(struct Scsi_Host *shost)
+ {
+ 	int rc;
+ 	scsi_qla_host_t *vha = (scsi_qla_host_t *)shost->hostdata;
+ 	struct blk_mq_queue_map *qmap = &shost->tag_set.map[HCTX_TYPE_DEFAULT];
+ 
+ 	if (USER_CTRL_IRQ(vha->hw) || !vha->hw->mqiobase)
+ 		rc = blk_mq_map_queues(qmap);
+ 	else
+ 		rc = blk_mq_pci_map_queues(qmap, vha->hw->pdev, vha->irq_offset);
+ 	return rc;
+ }
+ 
+ struct scsi_host_template qla2xxx_driver_template = {
+ 	.module			= THIS_MODULE,
+ 	.name			= QLA2XXX_DRIVER_NAME,
+ 	.queuecommand		= qla2xxx_queuecommand,
+ 
+ 	.eh_timed_out		= fc_eh_timed_out,
+ 	.eh_abort_handler	= qla2xxx_eh_abort,
+ 	.eh_device_reset_handler = qla2xxx_eh_device_reset,
+ 	.eh_target_reset_handler = qla2xxx_eh_target_reset,
+ 	.eh_bus_reset_handler	= qla2xxx_eh_bus_reset,
+ 	.eh_host_reset_handler	= qla2xxx_eh_host_reset,
+ 
+ 	.slave_configure	= qla2xxx_slave_configure,
+ 
+ 	.slave_alloc		= qla2xxx_slave_alloc,
+ 	.slave_destroy		= qla2xxx_slave_destroy,
+ 	.scan_finished		= qla2xxx_scan_finished,
+ 	.scan_start		= qla2xxx_scan_start,
+ 	.change_queue_depth	= scsi_change_queue_depth,
+ 	.map_queues             = qla2xxx_map_queues,
+ 	.this_id		= -1,
+ 	.cmd_per_lun		= 3,
+ 	.sg_tablesize		= SG_ALL,
+ 
+ 	.max_sectors		= 0xFFFF,
+ 	.shost_attrs		= qla2x00_host_attrs,
+ 
+ 	.supported_mode		= MODE_INITIATOR,
+ 	.track_queue_depth	= 1,
+ 	.cmd_size		= sizeof(srb_t),
+ };
+ 
++>>>>>>> 85cffefa09e4 (scsi: qla2xxx: Fix a race condition between aborting and completing a SCSI command)
  static const struct pci_error_handlers qla2xxx_err_handler = {
  	.error_detected = qla2xxx_pci_error_detected,
  	.mmio_enabled = qla2xxx_pci_mmio_enabled,
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index a2b4b8c56292..de5200da36bb 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -566,7 +566,6 @@ typedef struct srb {
 } srb_t;
 
 #define GET_CMD_SP(sp) (sp->u.scmd.cmd)
-#define SET_CMD_SP(sp, cmd) (sp->u.scmd.cmd = cmd)
 #define GET_CMD_CTX_SP(sp) (sp->u.scmd.ctx)
 
 #define GET_CMD_SENSE_LEN(sp) \
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
