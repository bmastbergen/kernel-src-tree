ipvs: add sync_maxlen parameter for the sync daemon

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Julian Anastasov <ja@ssi.bg>
commit e4ff67513096e6e196ca58043fce04d0f87babbe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/e4ff6751.failed

Allow setups with large MTU to send large sync packets by
adding sync_maxlen parameter. The default value is now based
on MTU but no more than 1500 for compatibility reasons.

To avoid problems if MTU changes allow fragmentation by
sending packets with DF=0. Problem reported by Dan Carpenter.

	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Julian Anastasov <ja@ssi.bg>
	Signed-off-by: Simon Horman <horms@verge.net.au>
(cherry picked from commit e4ff67513096e6e196ca58043fce04d0f87babbe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipvs/ip_vs_ctl.c
#	net/netfilter/ipvs/ip_vs_sync.c
diff --cc net/netfilter/ipvs/ip_vs_ctl.c
index 4aed1d77d557,96f7bbfd5e1d..000000000000
--- a/net/netfilter/ipvs/ip_vs_ctl.c
+++ b/net/netfilter/ipvs/ip_vs_ctl.c
@@@ -2406,13 -2335,23 +2406,30 @@@ do_ip_vs_set_ctl(struct sock *sk, int c
  	    cmd == IP_VS_SO_SET_STOPDAEMON) {
  		struct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;
  
++<<<<<<< HEAD
 +		mutex_lock(&ipvs->sync_mutex);
 +		if (cmd == IP_VS_SO_SET_STARTDAEMON)
 +			ret = start_sync_thread(net, dm->state, dm->mcast_ifn,
 +						dm->syncid);
 +		else
++=======
+ 		if (cmd == IP_VS_SO_SET_STARTDAEMON) {
+ 			struct ipvs_sync_daemon_cfg cfg;
+ 
+ 			memset(&cfg, 0, sizeof(cfg));
+ 			strlcpy(cfg.mcast_ifn, dm->mcast_ifn,
+ 				sizeof(cfg.mcast_ifn));
+ 			cfg.syncid = dm->syncid;
+ 			rtnl_lock();
+ 			mutex_lock(&ipvs->sync_mutex);
+ 			ret = start_sync_thread(net, &cfg, dm->state);
+ 			mutex_unlock(&ipvs->sync_mutex);
+ 			rtnl_unlock();
+ 		} else {
+ 			mutex_lock(&ipvs->sync_mutex);
++>>>>>>> e4ff67513096 (ipvs: add sync_maxlen parameter for the sync daemon)
  			ret = stop_sync_thread(net, dm->state);
 -			mutex_unlock(&ipvs->sync_mutex);
 -		}
 +		mutex_unlock(&ipvs->sync_mutex);
  		goto out_dec;
  	}
  
@@@ -3360,15 -3352,37 +3377,47 @@@ nla_put_failure
  
  static int ip_vs_genl_new_daemon(struct net *net, struct nlattr **attrs)
  {
++<<<<<<< HEAD
++=======
+ 	struct netns_ipvs *ipvs = net_ipvs(net);
+ 	struct ipvs_sync_daemon_cfg c;
+ 	struct nlattr *a;
+ 	int ret;
+ 
+ 	memset(&c, 0, sizeof(c));
++>>>>>>> e4ff67513096 (ipvs: add sync_maxlen parameter for the sync daemon)
  	if (!(attrs[IPVS_DAEMON_ATTR_STATE] &&
  	      attrs[IPVS_DAEMON_ATTR_MCAST_IFN] &&
  	      attrs[IPVS_DAEMON_ATTR_SYNC_ID]))
  		return -EINVAL;
+ 	strlcpy(c.mcast_ifn, nla_data(attrs[IPVS_DAEMON_ATTR_MCAST_IFN]),
+ 		sizeof(c.mcast_ifn));
+ 	c.syncid = nla_get_u32(attrs[IPVS_DAEMON_ATTR_SYNC_ID]);
+ 
+ 	a = attrs[IPVS_DAEMON_ATTR_SYNC_MAXLEN];
+ 	if (a)
+ 		c.sync_maxlen = nla_get_u16(a);
  
++<<<<<<< HEAD
 +	return start_sync_thread(net,
 +				 nla_get_u32(attrs[IPVS_DAEMON_ATTR_STATE]),
 +				 nla_data(attrs[IPVS_DAEMON_ATTR_MCAST_IFN]),
 +				 nla_get_u32(attrs[IPVS_DAEMON_ATTR_SYNC_ID]));
++=======
+ 	/* The synchronization protocol is incompatible with mixed family
+ 	 * services
+ 	 */
+ 	if (ipvs->mixed_address_family_dests > 0)
+ 		return -EINVAL;
+ 
+ 	rtnl_lock();
+ 	mutex_lock(&ipvs->sync_mutex);
+ 	ret = start_sync_thread(net, &c,
+ 				nla_get_u32(attrs[IPVS_DAEMON_ATTR_STATE]));
+ 	mutex_unlock(&ipvs->sync_mutex);
+ 	rtnl_unlock();
+ 	return ret;
++>>>>>>> e4ff67513096 (ipvs: add sync_maxlen parameter for the sync daemon)
  }
  
  static int ip_vs_genl_del_daemon(struct net *net, struct nlattr **attrs)
diff --cc net/netfilter/ipvs/ip_vs_sync.c
index ab0e9562476c,e68a43421479..000000000000
--- a/net/netfilter/ipvs/ip_vs_sync.c
+++ b/net/netfilter/ipvs/ip_vs_sync.c
@@@ -1441,13 -1433,7 +1413,17 @@@ static struct socket *make_send_sock(st
  		pr_err("Error during creation of socket; terminating\n");
  		return ERR_PTR(result);
  	}
++<<<<<<< HEAD
 +	/*
 +	 * Kernel sockets that are a part of a namespace, should not
 +	 * hold a reference to a namespace in order to allow to stop it.
 +	 * After sk_change_net should be released using sk_release_kernel.
 +	 */
 +	sk_change_net(sock->sk, net);
 +	result = set_mcast_if(sock->sk, ipvs->master_mcast_ifn);
++=======
+ 	result = set_mcast_if(sock->sk, ipvs->mcfg.mcast_ifn);
++>>>>>>> e4ff67513096 (ipvs: add sync_maxlen parameter for the sync daemon)
  	if (result < 0) {
  		pr_err("Error setting outbound mcast interface\n");
  		goto error;
diff --git a/include/net/ip_vs.h b/include/net/ip_vs.h
index 2d7cb932edee..3487f8ef4c7e 100644
--- a/include/net/ip_vs.h
+++ b/include/net/ip_vs.h
@@ -876,6 +876,13 @@ struct ipvs_master_sync_state {
 /* How much time to keep dests in trash */
 #define IP_VS_DEST_TRASH_PERIOD		(120 * HZ)
 
+struct ipvs_sync_daemon_cfg {
+	int			syncid;
+	u16			sync_maxlen;
+	/* multicast interface name */
+	char			mcast_ifn[IP_VS_IFNAME_MAXLEN];
+};
+
 /* IPVS in network namespace */
 struct netns_ipvs {
 	int			gen;		/* Generation */
@@ -991,15 +998,10 @@ struct netns_ipvs {
 	spinlock_t		sync_buff_lock;
 	struct task_struct	**backup_threads;
 	int			threads_mask;
-	int			send_mesg_maxlen;
-	int			recv_mesg_maxlen;
 	volatile int		sync_state;
-	volatile int		master_syncid;
-	volatile int		backup_syncid;
 	struct mutex		sync_mutex;
-	/* multicast interface name */
-	char			master_mcast_ifn[IP_VS_IFNAME_MAXLEN];
-	char			backup_mcast_ifn[IP_VS_IFNAME_MAXLEN];
+	struct ipvs_sync_daemon_cfg	mcfg;	/* Master Configuration */
+	struct ipvs_sync_daemon_cfg	bcfg;	/* Backup Configuration */
 	/* net name space ptr */
 	struct net		*net;            /* Needed by timer routines */
 };
@@ -1420,7 +1422,8 @@ static inline void ip_vs_dest_put(struct ip_vs_dest *dest)
  *      IPVS sync daemon data and function prototypes
  *      (from ip_vs_sync.c)
  */
-int start_sync_thread(struct net *net, int state, char *mcast_ifn, __u8 syncid);
+int start_sync_thread(struct net *net, struct ipvs_sync_daemon_cfg *cfg,
+		      int state);
 int stop_sync_thread(struct net *net, int state);
 void ip_vs_sync_conn(struct net *net, struct ip_vs_conn *cp, int pkts);
 
diff --git a/include/uapi/linux/ip_vs.h b/include/uapi/linux/ip_vs.h
index 29458223d044..af478b56f2f9 100644
--- a/include/uapi/linux/ip_vs.h
+++ b/include/uapi/linux/ip_vs.h
@@ -399,6 +399,7 @@ enum {
 	IPVS_DAEMON_ATTR_STATE,		/* sync daemon state (master/backup) */
 	IPVS_DAEMON_ATTR_MCAST_IFN,	/* multicast interface name */
 	IPVS_DAEMON_ATTR_SYNC_ID,	/* SyncID we belong to */
+	IPVS_DAEMON_ATTR_SYNC_MAXLEN,	/* UDP Payload Size */
 	__IPVS_DAEMON_ATTR_MAX,
 };
 
* Unmerged path net/netfilter/ipvs/ip_vs_ctl.c
* Unmerged path net/netfilter/ipvs/ip_vs_sync.c
