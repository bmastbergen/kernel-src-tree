scsi: lpfc: resolve lockdep warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author James Smart <jsmart2021@gmail.com>
commit e2a8be5696e706a2fce6edd11e5c74ce14cffec0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/e2a8be56.failed

There were a number of erroneous comments and incorrect older lockdep
checks that were causing a number of warnings.

Resolve the following:

 - Inconsistent lock state warnings in lpfc_nvme_info_show().

 - Fixed comments and code on sequences where ring lock is now held instead
   of hbalock.

 - Reworked calling sequences around lpfc_sli_iocbq_lookup(). Rather than
   locking prior to the routine and have routine guess on what lock, take
   the lock within the routine. The lockdep check becomes unnecessary.

 - Fixed comments and removed erroneous hbalock checks.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <jsmart2021@gmail.com>
CC: Bart Van Assche <bvanassche@acm.org>
	Tested-by: Bart Van Assche <bvanassche@acm.org>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit e2a8be5696e706a2fce6edd11e5c74ce14cffec0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_sli.c
diff --cc drivers/scsi/lpfc/lpfc_sli.c
index 2f006f914f24,d1512e4f9791..000000000000
--- a/drivers/scsi/lpfc/lpfc_sli.c
+++ b/drivers/scsi/lpfc/lpfc_sli.c
@@@ -1126,12 -1113,20 +1127,23 @@@ __lpfc_sli_get_els_sglq(struct lpfc_hb
  	struct list_head *lpfc_els_sgl_list = &phba->sli4_hba.lpfc_els_sgl_list;
  	struct lpfc_sglq *sglq = NULL;
  	struct lpfc_sglq *start_sglq = NULL;
 -	struct lpfc_io_buf *lpfc_cmd;
 +	struct lpfc_scsi_buf *lpfc_cmd;
  	struct lpfc_nodelist *ndlp;
+ 	struct lpfc_sli_ring *pring = NULL;
  	int found = 0;
  
++<<<<<<< HEAD
++=======
+ 	if (piocbq->iocb_flag & LPFC_IO_NVME_LS)
+ 		pring =  phba->sli4_hba.nvmels_wq->pring;
+ 	else
+ 		pring = lpfc_phba_elsring(phba);
+ 
+ 	lockdep_assert_held(&pring->ring_lock);
+ 
++>>>>>>> e2a8be5696e7 (scsi: lpfc: resolve lockdep warnings)
  	if (piocbq->iocb_flag &  LPFC_IO_FCP) {
 -		lpfc_cmd = (struct lpfc_io_buf *) piocbq->context1;
 +		lpfc_cmd = (struct lpfc_scsi_buf *) piocbq->context1;
  		ndlp = lpfc_cmd->rdata->pnode;
  	} else  if ((piocbq->iocb.ulpCommand == CMD_GEN_REQUEST64_CR) &&
  			!(piocbq->iocb_flag & LPFC_IO_LIBDFC)) {
@@@ -1576,6 -1577,10 +1589,13 @@@ static in
  lpfc_sli_ringtxcmpl_put(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,
  			struct lpfc_iocbq *piocb)
  {
++<<<<<<< HEAD
++=======
+ 	if (phba->sli_rev == LPFC_SLI_REV4)
+ 		lockdep_assert_held(&pring->ring_lock);
+ 	else
+ 		lockdep_assert_held(&phba->hbalock);
++>>>>>>> e2a8be5696e7 (scsi: lpfc: resolve lockdep warnings)
  
  	BUG_ON(!piocb);
  
@@@ -2971,7 -2989,15 +2991,18 @@@ lpfc_sli_iocbq_lookup(struct lpfc_hba *
  {
  	struct lpfc_iocbq *cmd_iocb = NULL;
  	uint16_t iotag;
++<<<<<<< HEAD
++=======
+ 	spinlock_t *temp_lock = NULL;
+ 	unsigned long iflag = 0;
++>>>>>>> e2a8be5696e7 (scsi: lpfc: resolve lockdep warnings)
+ 
+ 	if (phba->sli_rev == LPFC_SLI_REV4)
+ 		temp_lock = &pring->ring_lock;
+ 	else
+ 		temp_lock = &phba->hbalock;
  
+ 	spin_lock_irqsave(temp_lock, iflag);
  	iotag = prspiocb->iocb.ulpIoTag;
  
  	if (iotag != 0 && iotag <= phba->sli.last_iotag) {
@@@ -2980,6 -3006,8 +3011,11 @@@
  			/* remove from txcmpl queue list */
  			list_del_init(&cmd_iocb->list);
  			cmd_iocb->iocb_flag &= ~LPFC_IO_ON_TXCMPLQ;
++<<<<<<< HEAD
++=======
+ 			pring->txcmplq_cnt--;
+ 			spin_unlock_irqrestore(temp_lock, iflag);
++>>>>>>> e2a8be5696e7 (scsi: lpfc: resolve lockdep warnings)
  			return cmd_iocb;
  		}
  	}
@@@ -3009,13 -3038,23 +3046,29 @@@ lpfc_sli_iocbq_lookup_by_tag(struct lpf
  			     struct lpfc_sli_ring *pring, uint16_t iotag)
  {
  	struct lpfc_iocbq *cmd_iocb = NULL;
+ 	spinlock_t *temp_lock = NULL;
+ 	unsigned long iflag = 0;
+ 
++<<<<<<< HEAD
++=======
+ 	if (phba->sli_rev == LPFC_SLI_REV4)
+ 		temp_lock = &pring->ring_lock;
+ 	else
+ 		temp_lock = &phba->hbalock;
  
+ 	spin_lock_irqsave(temp_lock, iflag);
++>>>>>>> e2a8be5696e7 (scsi: lpfc: resolve lockdep warnings)
  	if (iotag != 0 && iotag <= phba->sli.last_iotag) {
  		cmd_iocb = phba->sli.iocbq_lookup[iotag];
  		if (cmd_iocb->iocb_flag & LPFC_IO_ON_TXCMPLQ) {
  			/* remove from txcmpl queue list */
  			list_del_init(&cmd_iocb->list);
  			cmd_iocb->iocb_flag &= ~LPFC_IO_ON_TXCMPLQ;
++<<<<<<< HEAD
++=======
+ 			pring->txcmplq_cnt--;
+ 			spin_unlock_irqrestore(temp_lock, iflag);
++>>>>>>> e2a8be5696e7 (scsi: lpfc: resolve lockdep warnings)
  			return cmd_iocb;
  		}
  	}
diff --git a/drivers/scsi/lpfc/lpfc_attr.c b/drivers/scsi/lpfc/lpfc_attr.c
index caf8545951b3..e99b8785bdbb 100644
--- a/drivers/scsi/lpfc/lpfc_attr.c
+++ b/drivers/scsi/lpfc/lpfc_attr.c
@@ -179,6 +179,7 @@ lpfc_nvme_info_show(struct device *dev, struct device_attribute *attr,
 	int i;
 	int len = 0;
 	char tmp[LPFC_MAX_NVME_INFO_TMP_LEN] = {0};
+	unsigned long iflags = 0;
 
 	if (!(phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME)) {
 		len = scnprintf(buf, PAGE_SIZE, "NVME Disabled\n");
@@ -378,11 +379,11 @@ lpfc_nvme_info_show(struct device *dev, struct device_attribute *attr,
 
 	list_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {
 		nrport = NULL;
-		spin_lock(&vport->phba->hbalock);
+		spin_lock_irqsave(&vport->phba->hbalock, iflags);
 		rport = lpfc_ndlp_get_nrport(ndlp);
 		if (rport)
 			nrport = rport->remoteport;
-		spin_unlock(&vport->phba->hbalock);
+		spin_unlock_irqrestore(&vport->phba->hbalock, iflags);
 		if (!nrport)
 			continue;
 
* Unmerged path drivers/scsi/lpfc/lpfc_sli.c
