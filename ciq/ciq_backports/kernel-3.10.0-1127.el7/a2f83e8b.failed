dm snapshot: introduce account_start_copy() and account_end_copy()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Mikulas Patocka <mpatocka@redhat.com>
commit a2f83e8b0c82c9500421a26c49eb198b25fcdea3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/a2f83e8b.failed

This simple refactoring moves code for modifying the semaphore cow_count
into separate functions to prepare for changes that will extend these
methods to provide for a more sophisticated mechanism for COW
throttling.

	Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
	Reviewed-by: Nikos Tsironis <ntsironis@arrikto.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit a2f83e8b0c82c9500421a26c49eb198b25fcdea3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-snap.c
diff --cc drivers/md/dm-snap.c
index 4f3251269638,da3bd1794ee0..000000000000
--- a/drivers/md/dm-snap.c
+++ b/drivers/md/dm-snap.c
@@@ -1720,12 -1864,42 +1730,51 @@@ __find_pending_exception(struct dm_snap
  static void remap_exception(struct dm_snapshot *s, struct dm_exception *e,
  			    struct bio *bio, chunk_t chunk)
  {
++<<<<<<< HEAD
 +	bio->bi_bdev = s->cow->bdev;
 +	bio->bi_sector = chunk_to_sector(s->store,
 +					 dm_chunk_number(e->new_chunk) +
 +					 (chunk - e->old_chunk)) +
 +					 (bio->bi_sector &
 +					  s->store->chunk_mask);
++=======
+ 	bio_set_dev(bio, s->cow->bdev);
+ 	bio->bi_iter.bi_sector =
+ 		chunk_to_sector(s->store, dm_chunk_number(e->new_chunk) +
+ 				(chunk - e->old_chunk)) +
+ 		(bio->bi_iter.bi_sector & s->store->chunk_mask);
+ }
+ 
+ static void zero_callback(int read_err, unsigned long write_err, void *context)
+ {
+ 	struct bio *bio = context;
+ 	struct dm_snapshot *s = bio->bi_private;
+ 
+ 	account_end_copy(s);
+ 	bio->bi_status = write_err ? BLK_STS_IOERR : 0;
+ 	bio_endio(bio);
+ }
+ 
+ static void zero_exception(struct dm_snapshot *s, struct dm_exception *e,
+ 			   struct bio *bio, chunk_t chunk)
+ {
+ 	struct dm_io_region dest;
+ 
+ 	dest.bdev = s->cow->bdev;
+ 	dest.sector = bio->bi_iter.bi_sector;
+ 	dest.count = s->store->chunk_size;
+ 
+ 	account_start_copy(s);
+ 	WARN_ON_ONCE(bio->bi_private);
+ 	bio->bi_private = s;
+ 	dm_kcopyd_zero(s->kcopyd_client, 1, &dest, 0, zero_callback, bio);
+ }
+ 
+ static bool io_overlaps_chunk(struct dm_snapshot *s, struct bio *bio)
+ {
+ 	return bio->bi_iter.bi_size ==
+ 		(s->store->chunk_size << SECTOR_SHIFT);
++>>>>>>> a2f83e8b0c82 (dm snapshot: introduce account_start_copy() and account_end_copy())
  }
  
  static int snapshot_map(struct dm_target *ti, struct bio *bio)
* Unmerged path drivers/md/dm-snap.c
