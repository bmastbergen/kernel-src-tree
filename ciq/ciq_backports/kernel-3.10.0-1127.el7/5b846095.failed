gfs2: changes to gfs2_log_XXX_bio

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Abhi Das <adas@redhat.com>
commit 5b84609532d6e48a769a735d214e2cd705ed395e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/5b846095.failed

Change gfs2_log_XXX_bio family of functions so they can be used
with different bios, not just sdp->sd_log_bio.

This patch also contains some clean up suggested by Andreas.

	Signed-off-by: Abhi Das <adas@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 5b84609532d6e48a769a735d214e2cd705ed395e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/log.c
#	fs/gfs2/lops.c
#	fs/gfs2/lops.h
diff --cc fs/gfs2/log.c
index 15a3a8cfcfad,e7c6e9fc62b5..000000000000
--- a/fs/gfs2/log.c
+++ b/fs/gfs2/log.c
@@@ -617,8 -667,81 +617,83 @@@ out_of_blocks
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * write_log_header - Write a journal log header buffer at sd_log_flush_head
+  * @sdp: The GFS2 superblock
+  * @jd: journal descriptor of the journal to which we are writing
+  * @seq: sequence number
+  * @tail: tail of the log
+  * @flags: log header flags GFS2_LOG_HEAD_*
+  * @op_flags: flags to pass to the bio
+  *
+  * Returns: the initialized log buffer descriptor
+  */
+ 
+ void gfs2_write_log_header(struct gfs2_sbd *sdp, struct gfs2_jdesc *jd,
+ 			   u64 seq, u32 tail, u32 flags, int op_flags)
+ {
+ 	struct gfs2_log_header *lh;
+ 	u32 hash, crc;
+ 	struct page *page = mempool_alloc(gfs2_page_pool, GFP_NOIO);
+ 	struct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;
+ 	struct timespec64 tv;
+ 	struct super_block *sb = sdp->sd_vfs;
+ 	u64 addr;
+ 
+ 	lh = page_address(page);
+ 	clear_page(lh);
+ 
+ 	lh->lh_header.mh_magic = cpu_to_be32(GFS2_MAGIC);
+ 	lh->lh_header.mh_type = cpu_to_be32(GFS2_METATYPE_LH);
+ 	lh->lh_header.__pad0 = cpu_to_be64(0);
+ 	lh->lh_header.mh_format = cpu_to_be32(GFS2_FORMAT_LH);
+ 	lh->lh_header.mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);
+ 	lh->lh_sequence = cpu_to_be64(seq);
+ 	lh->lh_flags = cpu_to_be32(flags);
+ 	lh->lh_tail = cpu_to_be32(tail);
+ 	lh->lh_blkno = cpu_to_be32(sdp->sd_log_flush_head);
+ 	hash = ~crc32(~0, lh, LH_V1_SIZE);
+ 	lh->lh_hash = cpu_to_be32(hash);
+ 
+ 	ktime_get_coarse_real_ts64(&tv);
+ 	lh->lh_nsec = cpu_to_be32(tv.tv_nsec);
+ 	lh->lh_sec = cpu_to_be64(tv.tv_sec);
+ 	addr = gfs2_log_bmap(sdp);
+ 	lh->lh_addr = cpu_to_be64(addr);
+ 	lh->lh_jinode = cpu_to_be64(GFS2_I(jd->jd_inode)->i_no_addr);
+ 
+ 	/* We may only write local statfs, quota, etc., when writing to our
+ 	   own journal. The values are left 0 when recovering a journal
+ 	   different from our own. */
+ 	if (!(flags & GFS2_LOG_HEAD_RECOVERY)) {
+ 		lh->lh_statfs_addr =
+ 			cpu_to_be64(GFS2_I(sdp->sd_sc_inode)->i_no_addr);
+ 		lh->lh_quota_addr =
+ 			cpu_to_be64(GFS2_I(sdp->sd_qc_inode)->i_no_addr);
+ 
+ 		spin_lock(&sdp->sd_statfs_spin);
+ 		lh->lh_local_total = cpu_to_be64(l_sc->sc_total);
+ 		lh->lh_local_free = cpu_to_be64(l_sc->sc_free);
+ 		lh->lh_local_dinodes = cpu_to_be64(l_sc->sc_dinodes);
+ 		spin_unlock(&sdp->sd_statfs_spin);
+ 	}
+ 
+ 	BUILD_BUG_ON(offsetof(struct gfs2_log_header, lh_crc) != LH_V1_SIZE);
+ 
+ 	crc = crc32c(~0, (void *)lh + LH_V1_SIZE + 4,
+ 		     sb->s_blocksize - LH_V1_SIZE - 4);
+ 	lh->lh_crc = cpu_to_be32(crc);
+ 
+ 	gfs2_log_write(sdp, page, sb->s_blocksize, 0, addr);
+ 	gfs2_log_submit_bio(&sdp->sd_log_bio, REQ_OP_WRITE, op_flags);
+ 	log_flush_wait(sdp);
+ }
+ 
+ /**
++>>>>>>> 5b84609532d6 (gfs2: changes to gfs2_log_XXX_bio)
   * log_write_header - Get and initialize a journal header buffer
   * @sdp: The GFS2 superblock
 - * @flags: The log header flags, including log header origin
   *
   * Returns: the initialized log buffer descriptor
   */
@@@ -692,14 -807,11 +767,18 @@@ void gfs2_log_flush(struct gfs2_sbd *sd
  	gfs2_assert_withdraw(sdp,
  			sdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);
  
 +	sdp->sd_log_flush_head = sdp->sd_log_head;
 +	sdp->sd_log_flush_wrapped = 0;
 +	if (tr)
 +		tr->tr_first = sdp->sd_log_flush_head;
 +
  	gfs2_ordered_write(sdp);
  	lops_before_commit(sdp, tr);
++<<<<<<< HEAD
 +	gfs2_log_flush_bio(sdp, WRITE);
++=======
+ 	gfs2_log_submit_bio(&sdp->sd_log_bio, REQ_OP_WRITE, 0);
++>>>>>>> 5b84609532d6 (gfs2: changes to gfs2_log_XXX_bio)
  
  	if (sdp->sd_log_head != sdp->sd_log_flush_head) {
  		log_flush_wait(sdp);
diff --cc fs/gfs2/lops.c
index d34d08639ce8,2295042bc625..000000000000
--- a/fs/gfs2/lops.c
+++ b/fs/gfs2/lops.c
@@@ -229,57 -228,48 +229,81 @@@ static void gfs2_end_log_write(struct b
  }
  
  /**
++<<<<<<< HEAD
 + * gfs2_log_flush_bio - Submit any pending log bio
 + * @sdp: The superblock
 + * @rw: The rw flags
++=======
+  * gfs2_log_submit_bio - Submit any pending log bio
+  * @biop: Address of the bio pointer
+  * @op: REQ_OP
+  * @op_flags: req_flag_bits
++>>>>>>> 5b84609532d6 (gfs2: changes to gfs2_log_XXX_bio)
   *
   * Submit any pending part-built or full bio to the block device. If
   * there is no pending bio, then this is a no-op.
   */
  
++<<<<<<< HEAD
 +void gfs2_log_flush_bio(struct gfs2_sbd *sdp, int rw)
++=======
+ void gfs2_log_submit_bio(struct bio **biop, int op, int op_flags)
++>>>>>>> 5b84609532d6 (gfs2: changes to gfs2_log_XXX_bio)
  {
- 	if (sdp->sd_log_bio) {
+ 	struct bio *bio = *biop;
+ 	if (bio) {
+ 		struct gfs2_sbd *sdp = bio->bi_private;
  		atomic_inc(&sdp->sd_log_in_flight);
++<<<<<<< HEAD
 +		submit_bio(rw, sdp->sd_log_bio);
 +		sdp->sd_log_bio = NULL;
++=======
+ 		bio_set_op_attrs(bio, op, op_flags);
+ 		submit_bio(bio);
+ 		*biop = NULL;
++>>>>>>> 5b84609532d6 (gfs2: changes to gfs2_log_XXX_bio)
  	}
  }
  
  /**
-  * gfs2_log_alloc_bio - Allocate a new bio for log writing
-  * @sdp: The superblock
-  * @blkno: The next device block number we want to write to
+  * gfs2_log_alloc_bio - Allocate a bio
+  * @sdp: The super block
+  * @blkno: The device block number we want to write to
+  * @end_io: The bi_end_io callback
   *
-  * This should never be called when there is a cached bio in the
-  * super block. When it returns, there will be a cached bio in the
-  * super block which will have as many bio_vecs as the device is
-  * happy to handle.
+  * Allocate a new bio, initialize it with the given parameters and return it.
   *
-  * Returns: Newly allocated bio
+  * Returns: The newly allocated bio
   */
  
- static struct bio *gfs2_log_alloc_bio(struct gfs2_sbd *sdp, u64 blkno)
+ static struct bio *gfs2_log_alloc_bio(struct gfs2_sbd *sdp, u64 blkno,
+ 				      bio_end_io_t *end_io)
  {
  	struct super_block *sb = sdp->sd_vfs;
++<<<<<<< HEAD
 +	unsigned nrvecs = bio_get_nr_vecs(sb->s_bdev);
 +	struct bio *bio;
 +
 +	BUG_ON(sdp->sd_log_bio);
 +
 +	while (1) {
 +		bio = bio_alloc(GFP_NOIO, nrvecs);
 +		if (likely(bio))
 +			break;
 +		nrvecs = max(nrvecs/2, 1U);
 +	}
 +
 +	bio->bi_sector = blkno * (sb->s_blocksize >> 9);
 +	bio->bi_bdev = sb->s_bdev;
 +	bio->bi_end_io = gfs2_end_log_write;
- 	bio->bi_private = sdp;
++=======
+ 	struct bio *bio = bio_alloc(GFP_NOIO, BIO_MAX_PAGES);
  
- 	sdp->sd_log_bio = bio;
+ 	bio->bi_iter.bi_sector = blkno * (sb->s_blocksize >> 9);
+ 	bio_set_dev(bio, sb->s_bdev);
+ 	bio->bi_end_io = end_io;
++>>>>>>> 5b84609532d6 (gfs2: changes to gfs2_log_XXX_bio)
+ 	bio->bi_private = sdp;
  
  	return bio;
  }
@@@ -297,23 -291,26 +325,31 @@@
   * Returns: The bio to use for log writes
   */
  
- static struct bio *gfs2_log_get_bio(struct gfs2_sbd *sdp, u64 blkno)
+ static struct bio *gfs2_log_get_bio(struct gfs2_sbd *sdp, u64 blkno,
+ 				    struct bio **biop, int op,
+ 				    bio_end_io_t *end_io, bool flush)
  {
- 	struct bio *bio = sdp->sd_log_bio;
- 	u64 nblk;
+ 	struct bio *bio = *biop;
  
  	if (bio) {
+ 		u64 nblk;
+ 
  		nblk = bio_end_sector(bio);
  		nblk >>= sdp->sd_fsb2bb_shift;
- 		if (blkno == nblk)
+ 		if (blkno == nblk && !flush)
  			return bio;
++<<<<<<< HEAD
 +		gfs2_log_flush_bio(sdp, WRITE);
++=======
+ 		gfs2_log_submit_bio(biop, op, 0);
++>>>>>>> 5b84609532d6 (gfs2: changes to gfs2_log_XXX_bio)
  	}
  
- 	return gfs2_log_alloc_bio(sdp, blkno);
+ 	*biop = gfs2_log_alloc_bio(sdp, blkno, end_io);
+ 	return *biop;
  }
  
 +
  /**
   * gfs2_log_write - write to log
   * @sdp: the filesystem
@@@ -333,11 -330,12 +369,17 @@@ static void gfs2_log_write(struct gfs2_
  	struct bio *bio;
  	int ret;
  
- 	bio = gfs2_log_get_bio(sdp, blkno);
+ 	bio = gfs2_log_get_bio(sdp, blkno, &sdp->sd_log_bio, REQ_OP_WRITE,
+ 			       gfs2_end_log_write, false);
  	ret = bio_add_page(bio, page, size, offset);
  	if (ret == 0) {
++<<<<<<< HEAD
 +		gfs2_log_flush_bio(sdp, WRITE);
 +		bio = gfs2_log_alloc_bio(sdp, blkno);
++=======
+ 		bio = gfs2_log_get_bio(sdp, blkno, &sdp->sd_log_bio,
+ 				       REQ_OP_WRITE, gfs2_end_log_write, true);
++>>>>>>> 5b84609532d6 (gfs2: changes to gfs2_log_XXX_bio)
  		ret = bio_add_page(bio, page, size, offset);
  		WARN_ON(ret == 0);
  	}
diff --cc fs/gfs2/lops.h
index 06793e3001a7,711c4d89c063..000000000000
--- a/fs/gfs2/lops.h
+++ b/fs/gfs2/lops.h
@@@ -27,8 -26,11 +27,12 @@@ extern const struct gfs2_log_operation
  extern const struct gfs2_log_operations gfs2_databuf_lops;
  
  extern const struct gfs2_log_operations *gfs2_log_ops[];
 -extern u64 gfs2_log_bmap(struct gfs2_sbd *sdp);
 -extern void gfs2_log_write(struct gfs2_sbd *sdp, struct page *page,
 -			   unsigned size, unsigned offset, u64 blkno);
  extern void gfs2_log_write_page(struct gfs2_sbd *sdp, struct page *page);
++<<<<<<< HEAD
 +extern void gfs2_log_flush_bio(struct gfs2_sbd *sdp, int rw);
++=======
+ extern void gfs2_log_submit_bio(struct bio **biop, int op, int op_flags);
++>>>>>>> 5b84609532d6 (gfs2: changes to gfs2_log_XXX_bio)
  extern void gfs2_pin(struct gfs2_sbd *sdp, struct buffer_head *bh);
  
  static inline unsigned int buf_limit(struct gfs2_sbd *sdp)
* Unmerged path fs/gfs2/log.c
* Unmerged path fs/gfs2/lops.c
* Unmerged path fs/gfs2/lops.h
