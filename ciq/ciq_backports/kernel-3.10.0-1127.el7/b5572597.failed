xfs: create a new buf_ops pointer to verify structure metadata

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit b55725974c9d3a5afcdf83daff6fba7d3f91ffca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/b5572597.failed

Expose all metadata structure buffer verifier functions via buf_ops.
These will be used by the online scrub mechanism to look for problems
with buffers that are already sitting around in memory.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit b55725974c9d3a5afcdf83daff6fba7d3f91ffca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_alloc.c
#	fs/xfs/libxfs/xfs_attr_remote.c
#	fs/xfs/libxfs/xfs_refcount_btree.c
#	fs/xfs/libxfs/xfs_rmap_btree.c
diff --cc fs/xfs/libxfs/xfs_alloc.c
index 71f7539a064c,50ba989481cc..000000000000
--- a/fs/xfs/libxfs/xfs_alloc.c
+++ b/fs/xfs/libxfs/xfs_alloc.c
@@@ -504,10 -528,19 +504,19 @@@ xfs_agfl_verify
  	struct xfs_agfl	*agfl = XFS_BUF_TO_AGFL(bp);
  	int		i;
  
+ 	/*
+ 	 * There is no verification of non-crc AGFLs because mkfs does not
+ 	 * initialise the AGFL to zero or NULL. Hence the only valid part of the
+ 	 * AGFL is what the AGF says is active. We can't get to the AGF, so we
+ 	 * can't verify just those entries are valid.
+ 	 */
+ 	if (!xfs_sb_version_hascrc(&mp->m_sb))
+ 		return NULL;
+ 
  	if (!uuid_equal(&agfl->agfl_uuid, &mp->m_sb.sb_meta_uuid))
 -		return __this_address;
 +		return false;
  	if (be32_to_cpu(agfl->agfl_magicnum) != XFS_AGFL_MAGIC)
 -		return __this_address;
 +		return false;
  	/*
  	 * during growfs operations, the perag is not fully initialised,
  	 * so we can't use it for any useful checking. growfs ensures we can't
@@@ -2384,13 -2410,12 +2394,20 @@@ xfs_alloc_put_freelist
  	return 0;
  }
  
 -static xfs_failaddr_t
 +static bool
  xfs_agf_verify(
++<<<<<<< HEAD
 +	struct xfs_mount *mp,
 +	struct xfs_buf	*bp)
 + {
 +	struct xfs_agf	*agf = XFS_BUF_TO_AGF(bp);
 +	unsigned int	xfs_agfl_size;
++=======
+ 	struct xfs_buf		*bp)
+ {
+ 	struct xfs_mount	*mp = bp->b_target->bt_mount;
+ 	struct xfs_agf		*agf = XFS_BUF_TO_AGF(bp);
++>>>>>>> b55725974c9d (xfs: create a new buf_ops pointer to verify structure metadata)
  
  	if (xfs_sb_version_hascrc(&mp->m_sb)) {
  		if (!uuid_equal(&agf->agf_uuid, &mp->m_sb.sb_meta_uuid))
@@@ -2452,13 -2474,13 +2469,22 @@@ xfs_agf_read_verify
  
  	if (xfs_sb_version_hascrc(&mp->m_sb) &&
  	    !xfs_buf_verify_cksum(bp, XFS_AGF_CRC_OFF))
++<<<<<<< HEAD
 +		xfs_buf_ioerror(bp, -EFSBADCRC);
 +	else if (XFS_TEST_ERROR(!xfs_agf_verify(mp, bp), mp,
 +				XFS_ERRTAG_ALLOC_READ_AGF))
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +
 +	if (bp->b_error)
 +		xfs_verifier_error(bp);
++=======
+ 		xfs_verifier_error(bp, -EFSBADCRC, __this_address);
+ 	else {
+ 		fa = xfs_agf_verify(bp);
+ 		if (XFS_TEST_ERROR(fa, mp, XFS_ERRTAG_ALLOC_READ_AGF))
+ 			xfs_verifier_error(bp, -EFSCORRUPTED, fa);
+ 	}
++>>>>>>> b55725974c9d (xfs: create a new buf_ops pointer to verify structure metadata)
  }
  
  static void
@@@ -2467,10 -2489,11 +2493,16 @@@ xfs_agf_write_verify
  {
  	struct xfs_mount *mp = bp->b_target->bt_mount;
  	struct xfs_buf_log_item	*bip = bp->b_fspriv;
 -	xfs_failaddr_t		fa;
  
++<<<<<<< HEAD
 +	if (!xfs_agf_verify(mp, bp)) {
 +		xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +		xfs_verifier_error(bp);
++=======
+ 	fa = xfs_agf_verify(bp);
+ 	if (fa) {
+ 		xfs_verifier_error(bp, -EFSCORRUPTED, fa);
++>>>>>>> b55725974c9d (xfs: create a new buf_ops pointer to verify structure metadata)
  		return;
  	}
  
diff --cc fs/xfs/libxfs/xfs_attr_remote.c
index 3e888d7d3199,21be186067a2..000000000000
--- a/fs/xfs/libxfs/xfs_attr_remote.c
+++ b/fs/xfs/libxfs/xfs_attr_remote.c
@@@ -98,27 -98,29 +98,29 @@@ xfs_attr3_rmt_verify
  	struct xfs_attr3_rmt_hdr *rmt = ptr;
  
  	if (!xfs_sb_version_hascrc(&mp->m_sb))
 -		return __this_address;
 +		return false;
  	if (rmt->rm_magic != cpu_to_be32(XFS_ATTR3_RMT_MAGIC))
 -		return __this_address;
 +		return false;
  	if (!uuid_equal(&rmt->rm_uuid, &mp->m_sb.sb_meta_uuid))
 -		return __this_address;
 +		return false;
  	if (be64_to_cpu(rmt->rm_blkno) != bno)
 -		return __this_address;
 +		return false;
  	if (be32_to_cpu(rmt->rm_bytes) > fsbsize - sizeof(*rmt))
 -		return __this_address;
 +		return false;
  	if (be32_to_cpu(rmt->rm_offset) +
  				be32_to_cpu(rmt->rm_bytes) > XFS_XATTR_SIZE_MAX)
 -		return __this_address;
 +		return false;
  	if (rmt->rm_owner == 0)
 -		return __this_address;
 +		return false;
  
 -	return NULL;
 +	return true;
  }
  
- static void
- xfs_attr3_rmt_read_verify(
- 	struct xfs_buf	*bp)
+ static int
+ __xfs_attr3_rmt_read_verify(
+ 	struct xfs_buf	*bp,
+ 	bool		check_crc,
+ 	xfs_failaddr_t	*failaddr)
  {
  	struct xfs_mount *mp = bp->b_target->bt_mount;
  	char		*ptr;
@@@ -136,23 -138,48 +138,65 @@@
  	ASSERT(len >= blksize);
  
  	while (len > 0) {
++<<<<<<< HEAD
 +		if (!xfs_verify_cksum(ptr, blksize, XFS_ATTR3_RMT_CRC_OFF)) {
 +			xfs_buf_ioerror(bp, -EFSBADCRC);
 +			break;
 +		}
 +		if (!xfs_attr3_rmt_verify(mp, ptr, blksize, bno)) {
 +			xfs_buf_ioerror(bp, -EFSCORRUPTED);
 +			break;
++=======
+ 		if (check_crc &&
+ 		    !xfs_verify_cksum(ptr, blksize, XFS_ATTR3_RMT_CRC_OFF)) {
+ 			*failaddr = __this_address;
+ 			return -EFSBADCRC;
++>>>>>>> b55725974c9d (xfs: create a new buf_ops pointer to verify structure metadata)
  		}
+ 		*failaddr = xfs_attr3_rmt_verify(mp, ptr, blksize, bno);
+ 		if (*failaddr)
+ 			return -EFSCORRUPTED;
  		len -= blksize;
  		ptr += blksize;
  		bno += BTOBB(blksize);
  	}
  
++<<<<<<< HEAD
 +	if (bp->b_error)
 +		xfs_verifier_error(bp);
 +	else
 +		ASSERT(len == 0);
++=======
+ 	if (len != 0) {
+ 		*failaddr = __this_address;
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void
+ xfs_attr3_rmt_read_verify(
+ 	struct xfs_buf	*bp)
+ {
+ 	xfs_failaddr_t	fa;
+ 	int		error;
+ 
+ 	error = __xfs_attr3_rmt_read_verify(bp, true, &fa);
+ 	if (error)
+ 		xfs_verifier_error(bp, error, fa);
+ }
+ 
+ static xfs_failaddr_t
+ xfs_attr3_rmt_verify_struct(
+ 	struct xfs_buf	*bp)
+ {
+ 	xfs_failaddr_t	fa;
+ 	int		error;
+ 
+ 	error = __xfs_attr3_rmt_read_verify(bp, false, &fa);
+ 	return error ? fa : NULL;
++>>>>>>> b55725974c9d (xfs: create a new buf_ops pointer to verify structure metadata)
  }
  
  static void
* Unmerged path fs/xfs/libxfs/xfs_refcount_btree.c
* Unmerged path fs/xfs/libxfs/xfs_rmap_btree.c
* Unmerged path fs/xfs/libxfs/xfs_alloc.c
diff --git a/fs/xfs/libxfs/xfs_alloc_btree.c b/fs/xfs/libxfs/xfs_alloc_btree.c
index 63a0babaab52..988e533e6b21 100644
--- a/fs/xfs/libxfs/xfs_alloc_btree.c
+++ b/fs/xfs/libxfs/xfs_alloc_btree.c
@@ -341,6 +341,7 @@ const struct xfs_buf_ops xfs_allocbt_buf_ops = {
 	.name = "xfs_allocbt",
 	.verify_read = xfs_allocbt_read_verify,
 	.verify_write = xfs_allocbt_write_verify,
+	.verify_struct = xfs_allocbt_verify,
 };
 
 
diff --git a/fs/xfs/libxfs/xfs_attr_leaf.c b/fs/xfs/libxfs/xfs_attr_leaf.c
index b48a17e093f8..c6ecf1413378 100644
--- a/fs/xfs/libxfs/xfs_attr_leaf.c
+++ b/fs/xfs/libxfs/xfs_attr_leaf.c
@@ -337,6 +337,7 @@ const struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {
 	.name = "xfs_attr3_leaf",
 	.verify_read = xfs_attr3_leaf_read_verify,
 	.verify_write = xfs_attr3_leaf_write_verify,
+	.verify_struct = xfs_attr3_leaf_verify,
 };
 
 int
* Unmerged path fs/xfs/libxfs/xfs_attr_remote.c
diff --git a/fs/xfs/libxfs/xfs_bmap_btree.c b/fs/xfs/libxfs/xfs_bmap_btree.c
index 2fb9ffdf0120..dbba54a3c233 100644
--- a/fs/xfs/libxfs/xfs_bmap_btree.c
+++ b/fs/xfs/libxfs/xfs_bmap_btree.c
@@ -487,6 +487,7 @@ const struct xfs_buf_ops xfs_bmbt_buf_ops = {
 	.name = "xfs_bmbt",
 	.verify_read = xfs_bmbt_read_verify,
 	.verify_write = xfs_bmbt_write_verify,
+	.verify_struct = xfs_bmbt_verify,
 };
 
 
diff --git a/fs/xfs/libxfs/xfs_da_btree.c b/fs/xfs/libxfs/xfs_da_btree.c
index 651611530d2f..5dfc3e98d71b 100644
--- a/fs/xfs/libxfs/xfs_da_btree.c
+++ b/fs/xfs/libxfs/xfs_da_btree.c
@@ -244,10 +244,35 @@ xfs_da3_node_read_verify(
 	xfs_verifier_error(bp);
 }
 
+/* Verify the structure of a da3 block. */
+static xfs_failaddr_t
+xfs_da3_node_verify_struct(
+	struct xfs_buf		*bp)
+{
+	struct xfs_da_blkinfo	*info = bp->b_addr;
+
+	switch (be16_to_cpu(info->magic)) {
+	case XFS_DA3_NODE_MAGIC:
+	case XFS_DA_NODE_MAGIC:
+		return xfs_da3_node_verify(bp);
+	case XFS_ATTR_LEAF_MAGIC:
+	case XFS_ATTR3_LEAF_MAGIC:
+		bp->b_ops = &xfs_attr3_leaf_buf_ops;
+		return bp->b_ops->verify_struct(bp);
+	case XFS_DIR2_LEAFN_MAGIC:
+	case XFS_DIR3_LEAFN_MAGIC:
+		bp->b_ops = &xfs_dir3_leafn_buf_ops;
+		return bp->b_ops->verify_struct(bp);
+	default:
+		return __this_address;
+	}
+}
+
 const struct xfs_buf_ops xfs_da3_node_buf_ops = {
 	.name = "xfs_da3_node",
 	.verify_read = xfs_da3_node_read_verify,
 	.verify_write = xfs_da3_node_write_verify,
+	.verify_struct = xfs_da3_node_verify_struct,
 };
 
 int
diff --git a/fs/xfs/libxfs/xfs_dir2_block.c b/fs/xfs/libxfs/xfs_dir2_block.c
index e4272494b17f..ef39579fad44 100644
--- a/fs/xfs/libxfs/xfs_dir2_block.c
+++ b/fs/xfs/libxfs/xfs_dir2_block.c
@@ -124,6 +124,7 @@ const struct xfs_buf_ops xfs_dir3_block_buf_ops = {
 	.name = "xfs_dir3_block",
 	.verify_read = xfs_dir3_block_read_verify,
 	.verify_write = xfs_dir3_block_write_verify,
+	.verify_struct = xfs_dir3_block_verify,
 };
 
 int
diff --git a/fs/xfs/libxfs/xfs_dir2_data.c b/fs/xfs/libxfs/xfs_dir2_data.c
index af15f7052f3a..1e99ccc01ee8 100644
--- a/fs/xfs/libxfs/xfs_dir2_data.c
+++ b/fs/xfs/libxfs/xfs_dir2_data.c
@@ -316,6 +316,7 @@ const struct xfs_buf_ops xfs_dir3_data_buf_ops = {
 	.name = "xfs_dir3_data",
 	.verify_read = xfs_dir3_data_read_verify,
 	.verify_write = xfs_dir3_data_write_verify,
+	.verify_struct = xfs_dir3_data_verify,
 };
 
 static const struct xfs_buf_ops xfs_dir3_data_reada_buf_ops = {
diff --git a/fs/xfs/libxfs/xfs_dir2_leaf.c b/fs/xfs/libxfs/xfs_dir2_leaf.c
index 27297a689d9c..17a42c0cb806 100644
--- a/fs/xfs/libxfs/xfs_dir2_leaf.c
+++ b/fs/xfs/libxfs/xfs_dir2_leaf.c
@@ -216,6 +216,13 @@ __write_verify(
 	xfs_buf_update_cksum(bp, XFS_DIR3_LEAF_CRC_OFF);
 }
 
+static xfs_failaddr_t
+xfs_dir3_leaf1_verify(
+	struct xfs_buf	*bp)
+{
+	return xfs_dir3_leaf_verify(bp, XFS_DIR2_LEAF1_MAGIC);
+}
+
 static void
 xfs_dir3_leaf1_read_verify(
 	struct xfs_buf	*bp)
@@ -230,6 +237,13 @@ xfs_dir3_leaf1_write_verify(
 	__write_verify(bp, XFS_DIR2_LEAF1_MAGIC);
 }
 
+static xfs_failaddr_t
+xfs_dir3_leafn_verify(
+	struct xfs_buf	*bp)
+{
+	return xfs_dir3_leaf_verify(bp, XFS_DIR2_LEAFN_MAGIC);
+}
+
 static void
 xfs_dir3_leafn_read_verify(
 	struct xfs_buf	*bp)
@@ -248,12 +262,14 @@ const struct xfs_buf_ops xfs_dir3_leaf1_buf_ops = {
 	.name = "xfs_dir3_leaf1",
 	.verify_read = xfs_dir3_leaf1_read_verify,
 	.verify_write = xfs_dir3_leaf1_write_verify,
+	.verify_struct = xfs_dir3_leaf1_verify,
 };
 
 const struct xfs_buf_ops xfs_dir3_leafn_buf_ops = {
 	.name = "xfs_dir3_leafn",
 	.verify_read = xfs_dir3_leafn_read_verify,
 	.verify_write = xfs_dir3_leafn_write_verify,
+	.verify_struct = xfs_dir3_leafn_verify,
 };
 
 int
diff --git a/fs/xfs/libxfs/xfs_dir2_node.c b/fs/xfs/libxfs/xfs_dir2_node.c
index 682e2bf370c7..8c2a17535a6e 100644
--- a/fs/xfs/libxfs/xfs_dir2_node.c
+++ b/fs/xfs/libxfs/xfs_dir2_node.c
@@ -153,6 +153,7 @@ const struct xfs_buf_ops xfs_dir3_free_buf_ops = {
 	.name = "xfs_dir3_free",
 	.verify_read = xfs_dir3_free_read_verify,
 	.verify_write = xfs_dir3_free_write_verify,
+	.verify_struct = xfs_dir3_free_verify,
 };
 
 /* Everything ok in the free block header? */
diff --git a/fs/xfs/libxfs/xfs_dquot_buf.c b/fs/xfs/libxfs/xfs_dquot_buf.c
index 747085b4ef44..ed72cc857b13 100644
--- a/fs/xfs/libxfs/xfs_dquot_buf.c
+++ b/fs/xfs/libxfs/xfs_dquot_buf.c
@@ -242,6 +242,17 @@ xfs_dquot_buf_verify(
 	return true;
 }
 
+static xfs_failaddr_t
+xfs_dquot_buf_verify_struct(
+	struct xfs_buf	*bp)
+{
+	struct xfs_mount	*mp = bp->b_target->bt_mount;
+
+	if (!xfs_dquot_buf_verify(mp, bp, 0))
+		return __this_address;
+	return NULL;
+}
+
 static void
 xfs_dquot_buf_read_verify(
 	struct xfs_buf	*bp)
@@ -298,6 +309,7 @@ const struct xfs_buf_ops xfs_dquot_buf_ops = {
 	.name = "xfs_dquot",
 	.verify_read = xfs_dquot_buf_read_verify,
 	.verify_write = xfs_dquot_buf_write_verify,
+	.verify_struct = xfs_dquot_buf_verify_struct,
 };
 
 const struct xfs_buf_ops xfs_dquot_buf_ra_ops = {
diff --git a/fs/xfs/libxfs/xfs_ialloc.c b/fs/xfs/libxfs/xfs_ialloc.c
index 8a6e2ce84589..c2c535cbe978 100644
--- a/fs/xfs/libxfs/xfs_ialloc.c
+++ b/fs/xfs/libxfs/xfs_ialloc.c
@@ -2574,6 +2574,7 @@ const struct xfs_buf_ops xfs_agi_buf_ops = {
 	.name = "xfs_agi",
 	.verify_read = xfs_agi_read_verify,
 	.verify_write = xfs_agi_write_verify,
+	.verify_struct = xfs_agi_verify,
 };
 
 /*
diff --git a/fs/xfs/libxfs/xfs_ialloc_btree.c b/fs/xfs/libxfs/xfs_ialloc_btree.c
index 65f87127fae3..376d0e3a9a98 100644
--- a/fs/xfs/libxfs/xfs_ialloc_btree.c
+++ b/fs/xfs/libxfs/xfs_ialloc_btree.c
@@ -271,6 +271,7 @@ const struct xfs_buf_ops xfs_inobt_buf_ops = {
 	.name = "xfs_inobt",
 	.verify_read = xfs_inobt_read_verify,
 	.verify_write = xfs_inobt_write_verify,
+	.verify_struct = xfs_inobt_verify,
 };
 
 STATIC int
* Unmerged path fs/xfs/libxfs/xfs_refcount_btree.c
* Unmerged path fs/xfs/libxfs/xfs_rmap_btree.c
diff --git a/fs/xfs/libxfs/xfs_symlink_remote.c b/fs/xfs/libxfs/xfs_symlink_remote.c
index 62fd8d043c61..98dd7eecf941 100644
--- a/fs/xfs/libxfs/xfs_symlink_remote.c
+++ b/fs/xfs/libxfs/xfs_symlink_remote.c
@@ -171,6 +171,7 @@ const struct xfs_buf_ops xfs_symlink_buf_ops = {
 	.name = "xfs_symlink",
 	.verify_read = xfs_symlink_read_verify,
 	.verify_write = xfs_symlink_write_verify,
+	.verify_struct = xfs_symlink_verify,
 };
 
 void
diff --git a/fs/xfs/xfs_buf.h b/fs/xfs/xfs_buf.h
index a05324f0f97a..1d4456e13f55 100644
--- a/fs/xfs/xfs_buf.h
+++ b/fs/xfs/xfs_buf.h
@@ -141,6 +141,7 @@ struct xfs_buf_ops {
 	char *name;
 	void (*verify_read)(struct xfs_buf *);
 	void (*verify_write)(struct xfs_buf *);
+	xfs_failaddr_t (*verify_struct)(struct xfs_buf *bp);
 };
 
 typedef struct xfs_buf {
