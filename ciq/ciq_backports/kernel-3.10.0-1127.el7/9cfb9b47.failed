xfs: provide a centralized method for verifying inline fork data

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 9cfb9b47479e237d217dbcfafe034cbf98f45909
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/9cfb9b47.failed

Replace the current haphazard dir2 shortform verifier callsites with a
centralized verifier function that can be called either with the default
verifier functions or with a custom set.  This helps us strengthen
integrity checking while providing us with flexibility for repair tools.

xfs_repair wants this to be able to supply its own verifier functions
when trying to fix possibly corrupt metadata.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit 9cfb9b47479e237d217dbcfafe034cbf98f45909)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_inode_fork.c
#	fs/xfs/libxfs/xfs_inode_fork.h
#	fs/xfs/xfs_inode.h
diff --cc fs/xfs/libxfs/xfs_inode_fork.c
index 0986aa588340,c1c1a86e7f47..000000000000
--- a/fs/xfs/libxfs/xfs_inode_fork.c
+++ b/fs/xfs/libxfs/xfs_inode_fork.c
@@@ -94,16 -96,12 +96,22 @@@ xfs_iformat_fork
  	default:
  		return -EFSCORRUPTED;
  	}
 -	if (error)
 +	if (error) {
  		return error;
 +	}
  
++<<<<<<< HEAD
 +	/* Check inline dir contents. */
 +	if (S_ISDIR(inode->i_mode) && dip->di_format == XFS_DINODE_FMT_LOCAL) {
 +		if (xfs_dir2_sf_verify(ip)) {
 +			xfs_idestroy_fork(ip, XFS_DATA_FORK);
 +			return -EFSCORRUPTED;
 +		}
++=======
+ 	if (xfs_is_reflink_inode(ip)) {
+ 		ASSERT(ip->i_cowfp == NULL);
+ 		xfs_ifork_init_cow(ip);
++>>>>>>> 9cfb9b47479e (xfs: provide a centralized method for verifying inline fork data)
  	}
  
  	if (!XFS_DFORK_Q(dip))
@@@ -117,17 -115,6 +125,20 @@@
  		atp = (xfs_attr_shortform_t *)XFS_DFORK_APTR(dip);
  		size = be16_to_cpu(atp->hdr.totsize);
  
++<<<<<<< HEAD
 +		if (unlikely(size < sizeof(struct xfs_attr_sf_hdr))) {
 +			xfs_warn(ip->i_mount,
 +				"corrupt inode %Lu (bad attr fork size %Ld).",
 +				(unsigned long long) ip->i_ino,
 +				(long long) size);
 +			XFS_CORRUPTION_ERROR("xfs_iformat(8)",
 +					     XFS_ERRLEVEL_LOW,
 +					     ip->i_mount, dip);
 +			return -EFSCORRUPTED;
 +		}
 +
++=======
++>>>>>>> 9cfb9b47479e (xfs: provide a centralized method for verifying inline fork data)
  		error = xfs_iformat_local(ip, dip, XFS_ATTR_FORK, size);
  		break;
  	case XFS_DINODE_FMT_EXTENTS:
@@@ -697,3 -705,62 +708,65 @@@ xfs_iext_state_to_fork
  		return ip->i_afp;
  	return &ip->i_df;
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Initialize an inode's copy-on-write fork.
+  */
+ void
+ xfs_ifork_init_cow(
+ 	struct xfs_inode	*ip)
+ {
+ 	if (ip->i_cowfp)
+ 		return;
+ 
+ 	ip->i_cowfp = kmem_zone_zalloc(xfs_ifork_zone,
+ 				       KM_SLEEP | KM_NOFS);
+ 	ip->i_cowfp->if_flags = XFS_IFEXTENTS;
+ 	ip->i_cformat = XFS_DINODE_FMT_EXTENTS;
+ 	ip->i_cnextents = 0;
+ }
+ 
+ /* Default fork content verifiers. */
+ struct xfs_ifork_ops xfs_default_ifork_ops = {
+ 	.verify_attr	= xfs_attr_shortform_verify,
+ 	.verify_dir	= xfs_dir2_sf_verify,
+ 	.verify_symlink	= xfs_symlink_shortform_verify,
+ };
+ 
+ /* Verify the inline contents of the data fork of an inode. */
+ xfs_failaddr_t
+ xfs_ifork_verify_data(
+ 	struct xfs_inode	*ip,
+ 	struct xfs_ifork_ops	*ops)
+ {
+ 	/* Non-local data fork, we're done. */
+ 	if (ip->i_d.di_format != XFS_DINODE_FMT_LOCAL)
+ 		return NULL;
+ 
+ 	/* Check the inline data fork if there is one. */
+ 	switch (VFS_I(ip)->i_mode & S_IFMT) {
+ 	case S_IFDIR:
+ 		return ops->verify_dir(ip);
+ 	case S_IFLNK:
+ 		return ops->verify_symlink(ip);
+ 	default:
+ 		return NULL;
+ 	}
+ }
+ 
+ /* Verify the inline contents of the attr fork of an inode. */
+ xfs_failaddr_t
+ xfs_ifork_verify_attr(
+ 	struct xfs_inode	*ip,
+ 	struct xfs_ifork_ops	*ops)
+ {
+ 	/* There has to be an attr fork allocated if aformat is local. */
+ 	if (ip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)
+ 		return NULL;
+ 	if (!XFS_IFORK_PTR(ip, XFS_ATTR_FORK))
+ 		return __this_address;
+ 	return ops->verify_attr(ip);
+ }
++>>>>>>> 9cfb9b47479e (xfs: provide a centralized method for verifying inline fork data)
diff --cc fs/xfs/libxfs/xfs_inode_fork.h
index 36b245a260a3,dd8aba0dd119..000000000000
--- a/fs/xfs/libxfs/xfs_inode_fork.h
+++ b/fs/xfs/libxfs/xfs_inode_fork.h
@@@ -172,4 -184,20 +172,23 @@@ static inline bool xfs_iext_peek_prev_e
  
  extern struct kmem_zone	*xfs_ifork_zone;
  
++<<<<<<< HEAD
++=======
+ extern void xfs_ifork_init_cow(struct xfs_inode *ip);
+ 
+ typedef xfs_failaddr_t (*xfs_ifork_verifier_t)(struct xfs_inode *);
+ 
+ struct xfs_ifork_ops {
+ 	xfs_ifork_verifier_t	verify_symlink;
+ 	xfs_ifork_verifier_t	verify_dir;
+ 	xfs_ifork_verifier_t	verify_attr;
+ };
+ extern struct xfs_ifork_ops	xfs_default_ifork_ops;
+ 
+ xfs_failaddr_t xfs_ifork_verify_data(struct xfs_inode *ip,
+ 		struct xfs_ifork_ops *ops);
+ xfs_failaddr_t xfs_ifork_verify_attr(struct xfs_inode *ip,
+ 		struct xfs_ifork_ops *ops);
+ 
++>>>>>>> 9cfb9b47479e (xfs: provide a centralized method for verifying inline fork data)
  #endif	/* __XFS_INODE_FORK_H__ */
diff --cc fs/xfs/xfs_inode.h
index da0768e5cbc6,386b0bb3c92a..000000000000
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@@ -493,4 -488,9 +493,12 @@@ do { 
  
  extern struct kmem_zone	*xfs_inode_zone;
  
++<<<<<<< HEAD
++=======
+ /* The default CoW extent size hint. */
+ #define XFS_DEFAULT_COWEXTSZ_HINT 32
+ 
+ bool xfs_inode_verify_forks(struct xfs_inode *ip);
+ 
++>>>>>>> 9cfb9b47479e (xfs: provide a centralized method for verifying inline fork data)
  #endif	/* __XFS_INODE_H__ */
* Unmerged path fs/xfs/libxfs/xfs_inode_fork.c
* Unmerged path fs/xfs/libxfs/xfs_inode_fork.h
diff --git a/fs/xfs/xfs_icache.c b/fs/xfs/xfs_icache.c
index 560d2a2caa0e..00331013e698 100644
--- a/fs/xfs/xfs_icache.c
+++ b/fs/xfs/xfs_icache.c
@@ -511,6 +511,11 @@ xfs_iget_cache_miss(
 	if (error)
 		goto out_destroy;
 
+	if (!xfs_inode_verify_forks(ip)) {
+		error = -EFSCORRUPTED;
+		goto out_destroy;
+	}
+
 	trace_xfs_iget_miss(ip);
 
 
diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c
index 93793b47f0a0..6abf1cd378b2 100644
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@ -3419,6 +3419,34 @@ abort_out:
 	return error;
 }
 
+/*
+ * If there are inline format data / attr forks attached to this inode,
+ * make sure they're not corrupt.
+ */
+bool
+xfs_inode_verify_forks(
+	struct xfs_inode	*ip)
+{
+	xfs_failaddr_t		fa;
+
+	fa = xfs_ifork_verify_data(ip, &xfs_default_ifork_ops);
+	if (fa) {
+		xfs_alert(ip->i_mount,
+				"%s: bad inode %llu inline data fork at %pF",
+				__func__, ip->i_ino, fa);
+		return false;
+	}
+
+	fa = xfs_ifork_verify_attr(ip, &xfs_default_ifork_ops);
+	if (fa) {
+		xfs_alert(ip->i_mount,
+				"%s: bad inode %llu inline attr fork at %pF",
+				__func__, ip->i_ino, fa);
+		return false;
+	}
+	return true;
+}
+
 STATIC int
 xfs_iflush_int(
 	struct xfs_inode	*ip,
@@ -3497,10 +3525,8 @@ xfs_iflush_int(
 	if (ip->i_d.di_version < 3)
 		ip->i_d.di_flushiter++;
 
-	/* Check the inline directory data. */
-	if (S_ISDIR(VFS_I(ip)->i_mode) &&
-	    ip->i_d.di_format == XFS_DINODE_FMT_LOCAL &&
-	    xfs_dir2_sf_verify(ip))
+	/* Check the inline fork data before we write out. */
+	if (!xfs_inode_verify_forks(ip))
 		goto corrupt_out;
 
 	/*
* Unmerged path fs/xfs/xfs_inode.h
diff --git a/fs/xfs/xfs_log_recover.c b/fs/xfs/xfs_log_recover.c
index 7f2f9a4aa85e..b4792b1f0a6e 100644
--- a/fs/xfs/xfs_log_recover.c
+++ b/fs/xfs/xfs_log_recover.c
@@ -2940,6 +2940,10 @@ xfs_recover_inode_owner_change(
 	if (error)
 		goto out_free_ip;
 
+	if (!xfs_inode_verify_forks(ip)) {
+		error = -EFSCORRUPTED;
+		goto out_free_ip;
+	}
 
 	if (in_f->ilf_fields & XFS_ILOG_DOWNER) {
 		ASSERT(in_f->ilf_fields & XFS_ILOG_DBROOT);
