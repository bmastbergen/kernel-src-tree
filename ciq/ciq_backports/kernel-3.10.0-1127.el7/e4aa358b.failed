sched/fair: Push down check for high priority class task into idle_balance()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Kirill Tkhai <ktkhai@parallels.com>
commit e4aa358b6c23f98b2715594f6b1e9a4996a55f04
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/e4aa358b.failed

We close idle_exit_fair() bracket in case of we've pulled something or we've received
task of high priority class.

	Signed-off-by: Kirill Tkhai <ktkhai@parallels.com>
	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
	Cc: Vincent Guittot <vincent.guittot@linaro.org>
Link: http://lkml.kernel.org/r/1394098315.19290.10.camel@tkhai
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit e4aa358b6c23f98b2715594f6b1e9a4996a55f04)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/fair.c
#	kernel/sched/idle_task.c
diff --cc kernel/sched/fair.c
index c5d4b4242380,b956e70fc503..000000000000
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@@ -4998,6 -4785,21 +4998,24 @@@ simple
  		hrtick_start_fair(rq, p);
  
  	return p;
++<<<<<<< HEAD
++=======
+ 
+ idle:
+ 	new_tasks = idle_balance(rq);
+ 	/*
+ 	 * Because idle_balance() releases (and re-acquires) rq->lock, it is
+ 	 * possible for any higher priority task to appear. In that case we
+ 	 * must re-start the pick_next_entity() loop.
+ 	 */
+ 	if (new_tasks < 0)
+ 		return RETRY_TASK;
+ 
+ 	if (new_tasks > 0)
+ 		goto again;
+ 
+ 	return NULL;
++>>>>>>> e4aa358b6c23 (sched/fair: Push down check for high priority class task into idle_balance())
  }
  
  /*
@@@ -7032,6 -6724,19 +7050,21 @@@ out
  
  	if (curr_cost > this_rq->max_idle_balance_cost)
  		this_rq->max_idle_balance_cost = curr_cost;
++<<<<<<< HEAD
++=======
+ 
+ out:
+ 	/* Is there a task of a high priority class? */
+ 	if (this_rq->nr_running != this_rq->cfs.h_nr_running)
+ 		pulled_task = -1;
+ 
+ 	if (pulled_task) {
+ 		idle_exit_fair(this_rq);
+ 		this_rq->idle_stamp = 0;
+ 	}
+ 
+ 	return pulled_task;
++>>>>>>> e4aa358b6c23 (sched/fair: Push down check for high priority class task into idle_balance())
  }
  
  /*
diff --cc kernel/sched/idle_task.c
index 1a162e4ffb03,879f2b75266a..000000000000
--- a/kernel/sched/idle_task.c
+++ b/kernel/sched/idle_task.c
@@@ -25,15 -20,15 +25,18 @@@ static void pre_schedule_idle(struct r
   */
  static void check_preempt_curr_idle(struct rq *rq, struct task_struct *p, int flags)
  {
 -	resched_task(rq->idle);
 +	resched_curr(rq);
  }
  
 -static struct task_struct *
 -pick_next_task_idle(struct rq *rq, struct task_struct *prev)
 +static struct task_struct *pick_next_task_idle(struct rq *rq)
  {
 -	put_prev_task(rq, prev);
 -
  	schedstat_inc(rq, sched_goidle);
++<<<<<<< HEAD
 +#ifdef CONFIG_SMP
 +	idle_enter_fair(rq);
 +#endif
++=======
++>>>>>>> e4aa358b6c23 (sched/fair: Push down check for high priority class task into idle_balance())
  	return rq->idle;
  }
  
* Unmerged path kernel/sched/fair.c
* Unmerged path kernel/sched/idle_task.c
