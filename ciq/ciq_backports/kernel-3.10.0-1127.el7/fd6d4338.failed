net/sched: act_police: fix memory leak in case of invalid control action

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
Rebuild_CHGLOG: - [net] sched: act_police: fix memory leak in case of invalid control action (Davide Caratti) [1729033]
Rebuild_FUZZ: 97.14%
commit-author Davide Caratti <dcaratti@redhat.com>
commit fd6d433865a2ad1f7e018ef80408cb3dc3be1ab3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/fd6d4338.failed

when users set an invalid control action, kmemleak complains as follows:

 # echo clear >/sys/kernel/debug/kmemleak
 # ./tdc.py -e b48b
 Test b48b: Add police action with exceed goto chain control action
 All test results:

 1..1
 ok 1 - b48b # Add police action with exceed goto chain control action
 about to flush the tap output if tests need to be skipped
 done flushing skipped test tap output
 # echo scan >/sys/kernel/debug/kmemleak
 # cat /sys/kernel/debug/kmemleak
 unreferenced object 0xffffa0fafbc3dde0 (size 96):
  comm "tc", pid 2358, jiffies 4294922738 (age 17.022s)
  hex dump (first 32 bytes):
    2a 00 00 20 00 00 00 00 00 00 7d 00 00 00 00 00  *.. ......}.....
    f8 07 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  backtrace:
    [<00000000648803d2>] tcf_action_init_1+0x384/0x4c0
    [<00000000cb69382e>] tcf_action_init+0x12b/0x1a0
    [<00000000847ef0d4>] tcf_action_add+0x73/0x170
    [<0000000093656e14>] tc_ctl_action+0x122/0x160
    [<0000000023c98e32>] rtnetlink_rcv_msg+0x263/0x2d0
    [<000000003493ae9c>] netlink_rcv_skb+0x4d/0x130
    [<00000000de63f8ba>] netlink_unicast+0x209/0x2d0
    [<00000000c3da0ebe>] netlink_sendmsg+0x2c1/0x3c0
    [<000000007a9e0753>] sock_sendmsg+0x33/0x40
    [<00000000457c6d2e>] ___sys_sendmsg+0x2a0/0x2f0
    [<00000000c5c6a086>] __sys_sendmsg+0x5e/0xa0
    [<00000000446eafce>] do_syscall_64+0x5b/0x180
    [<000000004aa871f2>] entry_SYSCALL_64_after_hwframe+0x44/0xa9
    [<00000000450c38ef>] 0xffffffffffffffff

change tcf_police_init() to avoid leaking 'new' in case TCA_POLICE_RESULT
contains TC_ACT_GOTO_CHAIN extended action.

Fixes: c08f5ed5d625 ("net/sched: act_police: disallow 'goto chain' on fallback control action")
	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Davide Caratti <dcaratti@redhat.com>
	Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fd6d433865a2ad1f7e018ef80408cb3dc3be1ab3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_police.c
diff --cc net/sched/act_police.c
index d79498312c1b,ec8ec55e0fe8..000000000000
--- a/net/sched/act_police.c
+++ b/net/sched/act_police.c
@@@ -72,18 -80,19 +72,17 @@@ static const struct nla_policy police_p
  	[TCA_POLICE_RESULT]	= { .type = NLA_U32 },
  };
  
 -static int tcf_police_init(struct net *net, struct nlattr *nla,
 +static int tcf_act_police_init(struct net *net, struct nlattr *nla,
  			       struct nlattr *est, struct tc_action **a,
 -			       int ovr, int bind, bool rtnl_held,
 -			       struct netlink_ext_ack *extack)
 +			       int ovr, int bind)
  {
- 	int ret = 0, err;
+ 	int ret = 0, tcfp_result = TC_ACT_OK, err, size;
  	struct nlattr *tb[TCA_POLICE_MAX + 1];
  	struct tc_police *parm;
  	struct tcf_police *police;
  	struct qdisc_rate_table *R_tab = NULL, *P_tab = NULL;
  	struct tc_action_net *tn = net_generic(net, police_net_id);
 -	struct tcf_police_params *new;
  	bool exists = false;
- 	int size;
  
  	if (nla == NULL)
  		return -EINVAL;
@@@ -143,50 -159,71 +142,88 @@@
  		goto failure;
  	}
  
++<<<<<<< HEAD
 +	spin_lock_bh(&police->tcf_lock);
 +	/* No failure allowed after this point */
 +	police->tcfp_mtu = parm->mtu;
 +	if (police->tcfp_mtu == 0) {
 +		police->tcfp_mtu = ~0;
++=======
+ 	if (tb[TCA_POLICE_RESULT]) {
+ 		tcfp_result = nla_get_u32(tb[TCA_POLICE_RESULT]);
+ 		if (TC_ACT_EXT_CMP(tcfp_result, TC_ACT_GOTO_CHAIN)) {
+ 			NL_SET_ERR_MSG(extack,
+ 				       "goto chain not allowed on fallback");
+ 			err = -EINVAL;
+ 			goto failure;
+ 		}
+ 	}
+ 
+ 	new = kzalloc(sizeof(*new), GFP_KERNEL);
+ 	if (unlikely(!new)) {
+ 		err = -ENOMEM;
+ 		goto failure;
+ 	}
+ 
+ 	/* No failure allowed after this point */
+ 	new->tcfp_result = tcfp_result;
+ 	new->tcfp_mtu = parm->mtu;
+ 	if (!new->tcfp_mtu) {
+ 		new->tcfp_mtu = ~0;
++>>>>>>> fd6d433865a2 (net/sched: act_police: fix memory leak in case of invalid control action)
  		if (R_tab)
 -			new->tcfp_mtu = 255 << R_tab->rate.cell_log;
 +			police->tcfp_mtu = 255 << R_tab->rate.cell_log;
  	}
  	if (R_tab) {
 -		new->rate_present = true;
 -		psched_ratecfg_precompute(&new->rate, &R_tab->rate, 0);
 +		police->rate_present = true;
 +		psched_ratecfg_precompute(&police->rate, &R_tab->rate, 0);
  		qdisc_put_rtab(R_tab);
  	} else {
 -		new->rate_present = false;
 +		police->rate_present = false;
  	}
  	if (P_tab) {
 -		new->peak_present = true;
 -		psched_ratecfg_precompute(&new->peak, &P_tab->rate, 0);
 +		police->peak_present = true;
 +		psched_ratecfg_precompute(&police->peak, &P_tab->rate, 0);
  		qdisc_put_rtab(P_tab);
  	} else {
 -		new->peak_present = false;
 +		police->peak_present = false;
  	}
  
 -	new->tcfp_burst = PSCHED_TICKS2NS(parm->burst);
 -	if (new->peak_present)
 -		new->tcfp_mtu_ptoks = (s64)psched_l2t_ns(&new->peak,
 -							 new->tcfp_mtu);
 +	if (tb[TCA_POLICE_RESULT])
 +		police->tcfp_result = nla_get_u32(tb[TCA_POLICE_RESULT]);
 +	police->tcfp_burst = PSCHED_TICKS2NS(parm->burst);
 +	police->tcfp_toks = police->tcfp_burst;
 +	if (police->peak_present) {
 +		police->tcfp_mtu_ptoks = (s64) psched_l2t_ns(&police->peak,
 +							     police->tcfp_mtu);
 +		police->tcfp_ptoks = police->tcfp_mtu_ptoks;
 +	}
 +	police->tcf_action = parm->action;
  
  	if (tb[TCA_POLICE_AVRATE])
 -		new->tcfp_ewma_rate = nla_get_u32(tb[TCA_POLICE_AVRATE]);
 +		police->tcfp_ewma_rate = nla_get_u32(tb[TCA_POLICE_AVRATE]);
  
++<<<<<<< HEAD
++=======
+ 	spin_lock_bh(&police->tcf_lock);
+ 	spin_lock_bh(&police->tcfp_lock);
+ 	police->tcfp_t_c = ktime_get_ns();
+ 	police->tcfp_toks = new->tcfp_burst;
+ 	if (new->peak_present)
+ 		police->tcfp_ptoks = new->tcfp_mtu_ptoks;
+ 	spin_unlock_bh(&police->tcfp_lock);
+ 	police->tcf_action = parm->action;
+ 	rcu_swap_protected(police->params,
+ 			   new,
+ 			   lockdep_is_held(&police->tcf_lock));
++>>>>>>> fd6d433865a2 (net/sched: act_police: fix memory leak in case of invalid control action)
  	spin_unlock_bh(&police->tcf_lock);
 +	if (ret != ACT_P_CREATED)
 +		return ret;
  
 -	if (new)
 -		kfree_rcu(new, rcu);
 +	police->tcfp_t_c = ktime_get_ns();
 +	tcf_idr_insert(tn, *a);
  
 -	if (ret == ACT_P_CREATED)
 -		tcf_idr_insert(tn, *a);
  	return ret;
  
  failure:
* Unmerged path net/sched/act_police.c
