mm, memory_failure: Collect mapping size in collect_procs()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit ae1139ece126b8eb6d0770094fbac43ea928d9d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/ae1139ec.failed

In preparation for supporting memory_failure() for dax mappings, teach
collect_procs() to also determine the mapping size. Unlike typical
mappings the dax mapping size is determined by walking page-table
entries rather than using the compound-page accounting for THP pages.

	Acked-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
(cherry picked from commit ae1139ece126b8eb6d0770094fbac43ea928d9d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory-failure.c
diff --cc mm/memory-failure.c
index 2d6d813952ef,8a81680d00dd..000000000000
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@@ -191,26 -208,18 +221,40 @@@ struct to_kill 
   * ``action optional'' if they are not immediately affected by the error
   * ``action required'' if error happened in current execution context
   */
++<<<<<<< HEAD
 +static int kill_proc(struct task_struct *t, unsigned long addr, int trapno,
 +			unsigned long pfn, struct page *page, int flags)
 +{
 +	struct siginfo si;
++=======
+ static int kill_proc(struct to_kill *tk, unsigned long pfn, int flags)
+ {
+ 	struct task_struct *t = tk->tsk;
+ 	short addr_lsb = tk->size_shift;
++>>>>>>> ae1139ece126 (mm, memory_failure: Collect mapping size in collect_procs())
  	int ret;
  
 -	pr_err("Memory failure: %#lx: Killing %s:%d due to hardware memory corruption\n",
 +	printk(KERN_ERR
 +		"MCE %#lx: Killing %s:%d due to hardware memory corruption\n",
  		pfn, t->comm, t->pid);
++<<<<<<< HEAD
 +	si.si_signo = SIGBUS;
 +	si.si_errno = 0;
 +	si.si_addr = (void *)addr;
 +#ifdef __ARCH_SI_TRAPNO
 +	si.si_trapno = trapno;
 +#endif
 +	si.si_addr_lsb = compound_order(compound_head(page)) + PAGE_SHIFT;
 +
 +	if ((flags & MF_ACTION_REQUIRED) && t->mm == current->mm) {
 +		si.si_code = BUS_MCEERR_AR;
 +		ret = force_sig_info(SIGBUS, &si, current);
++=======
+ 
+ 	if ((flags & MF_ACTION_REQUIRED) && t->mm == current->mm) {
+ 		ret = force_sig_mceerr(BUS_MCEERR_AR, (void __user *)tk->addr,
+ 				       addr_lsb, current);
++>>>>>>> ae1139ece126 (mm, memory_failure: Collect mapping size in collect_procs())
  	} else {
  		/*
  		 * Don't use force here, it's convenient if the signal
@@@ -218,12 -227,12 +262,17 @@@
  		 * This could cause a loop when the user sets SIGBUS
  		 * to SIG_IGN, but hopefully no one will do that?
  		 */
++<<<<<<< HEAD
 +		si.si_code = BUS_MCEERR_AO;
 +		ret = send_sig_info(SIGBUS, &si, t);  /* synchronous? */
++=======
+ 		ret = send_sig_mceerr(BUS_MCEERR_AO, (void __user *)tk->addr,
+ 				      addr_lsb, t);  /* synchronous? */
++>>>>>>> ae1139ece126 (mm, memory_failure: Collect mapping size in collect_procs())
  	}
  	if (ret < 0)
 -		pr_info("Memory failure: Error sending signal to %s:%d: %d\n",
 -			t->comm, t->pid, ret);
 +		printk(KERN_INFO "MCE: Error sending signal to %s:%d: %d\n",
 +		       t->comm, t->pid, ret);
  	return ret;
  }
  
@@@ -348,9 -318,8 +369,14 @@@ static void add_to_kill(struct task_str
   * Also when FAIL is set do a force kill because something went
   * wrong earlier.
   */
++<<<<<<< HEAD
 +static void kill_procs(struct list_head *to_kill, int forcekill, int trapno,
 +			  int fail, struct page *page, unsigned long pfn,
 +			  int flags)
++=======
+ static void kill_procs(struct list_head *to_kill, int forcekill, bool fail,
+ 		unsigned long pfn, int flags)
++>>>>>>> ae1139ece126 (mm, memory_failure: Collect mapping size in collect_procs())
  {
  	struct to_kill *tk, *next;
  
@@@ -374,11 -342,9 +400,17 @@@
  			 * check for that, but we need to tell the
  			 * process anyways.
  			 */
++<<<<<<< HEAD
 +			else if (kill_proc(tk->tsk, tk->addr, trapno,
 +					      pfn, page, flags) < 0)
 +				printk(KERN_ERR
 +		"MCE %#lx: Cannot send advisory machine check signal to %s:%d\n",
 +					pfn, tk->tsk->comm, tk->tsk->pid);
++=======
+ 			else if (kill_proc(tk, pfn, flags) < 0)
+ 				pr_err("Memory failure: %#lx: Cannot send advisory machine check signal to %s:%d\n",
+ 				       pfn, tk->tsk->comm, tk->tsk->pid);
++>>>>>>> ae1139ece126 (mm, memory_failure: Collect mapping size in collect_procs())
  		}
  		put_task_struct(tk->tsk);
  		kfree(tk);
@@@ -1016,26 -1011,104 +1048,30 @@@ static int hwpoison_user_mappings(struc
  	 * any accesses to the poisoned memory.
  	 */
  	forcekill = PageDirty(hpage) || (flags & MF_MUST_KILL);
++<<<<<<< HEAD
 +	kill_procs(&tokill, forcekill, trapno,
 +		      ret != SWAP_SUCCESS, p, pfn, flags);
++=======
+ 	kill_procs(&tokill, forcekill, !unmap_success, pfn, flags);
++>>>>>>> ae1139ece126 (mm, memory_failure: Collect mapping size in collect_procs())
  
 -	return unmap_success;
 +	return ret;
  }
  
 -static int identify_page_state(unsigned long pfn, struct page *p,
 -				unsigned long page_flags)
 +static void set_page_hwpoison_huge_page(struct page *hpage)
  {
 -	struct page_state *ps;
 -
 -	/*
 -	 * The first check uses the current page flags which may not have any
 -	 * relevant information. The second check with the saved page flags is
 -	 * carried out only if the first check can't determine the page status.
 -	 */
 -	for (ps = error_states;; ps++)
 -		if ((p->flags & ps->mask) == ps->res)
 -			break;
 -
 -	page_flags |= (p->flags & (1UL << PG_dirty));
 -
 -	if (!ps->mask)
 -		for (ps = error_states;; ps++)
 -			if ((page_flags & ps->mask) == ps->res)
 -				break;
 -	return page_action(ps, p, pfn);
 +	int i;
 +	int nr_pages = 1 << compound_order(hpage);
 +	for (i = 0; i < nr_pages; i++)
 +		SetPageHWPoison(hpage + i);
  }
  
 -static int memory_failure_hugetlb(unsigned long pfn, int flags)
 +static void clear_page_hwpoison_huge_page(struct page *hpage)
  {
 -	struct page *p = pfn_to_page(pfn);
 -	struct page *head = compound_head(p);
 -	int res;
 -	unsigned long page_flags;
 -
 -	if (TestSetPageHWPoison(head)) {
 -		pr_err("Memory failure: %#lx: already hardware poisoned\n",
 -		       pfn);
 -		return 0;
 -	}
 -
 -	num_poisoned_pages_inc();
 -
 -	if (!(flags & MF_COUNT_INCREASED) && !get_hwpoison_page(p)) {
 -		/*
 -		 * Check "filter hit" and "race with other subpage."
 -		 */
 -		lock_page(head);
 -		if (PageHWPoison(head)) {
 -			if ((hwpoison_filter(p) && TestClearPageHWPoison(p))
 -			    || (p != head && TestSetPageHWPoison(head))) {
 -				num_poisoned_pages_dec();
 -				unlock_page(head);
 -				return 0;
 -			}
 -		}
 -		unlock_page(head);
 -		dissolve_free_huge_page(p);
 -		action_result(pfn, MF_MSG_FREE_HUGE, MF_DELAYED);
 -		return 0;
 -	}
 -
 -	lock_page(head);
 -	page_flags = head->flags;
 -
 -	if (!PageHWPoison(head)) {
 -		pr_err("Memory failure: %#lx: just unpoisoned\n", pfn);
 -		num_poisoned_pages_dec();
 -		unlock_page(head);
 -		put_hwpoison_page(head);
 -		return 0;
 -	}
 -
 -	/*
 -	 * TODO: hwpoison for pud-sized hugetlb doesn't work right now, so
 -	 * simply disable it. In order to make it work properly, we need
 -	 * make sure that:
 -	 *  - conversion of a pud that maps an error hugetlb into hwpoison
 -	 *    entry properly works, and
 -	 *  - other mm code walking over page table is aware of pud-aligned
 -	 *    hwpoison entries.
 -	 */
 -	if (huge_page_size(page_hstate(head)) > PMD_SIZE) {
 -		action_result(pfn, MF_MSG_NON_PMD_HUGE, MF_IGNORED);
 -		res = -EBUSY;
 -		goto out;
 -	}
 -
 -	if (!hwpoison_user_mappings(p, pfn, flags, &head)) {
 -		action_result(pfn, MF_MSG_UNMAP_FAILED, MF_IGNORED);
 -		res = -EBUSY;
 -		goto out;
 -	}
 -
 -	res = identify_page_state(pfn, p, page_flags);
 -out:
 -	unlock_page(head);
 -	return res;
 +	int i;
 +	int nr_pages = 1 << compound_order(hpage);
 +	for (i = 0; i < nr_pages; i++)
 +		ClearPageHWPoison(hpage + i);
  }
  
  /**
* Unmerged path mm/memory-failure.c
