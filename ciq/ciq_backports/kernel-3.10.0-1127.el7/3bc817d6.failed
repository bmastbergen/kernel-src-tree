ip6_gre: reload ipv6h in prepare_ip6gre_xmit_ipv6

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Haishuang Yan <yanhaishuang@cmss.chinamobile.com>
commit 3bc817d665ac6d9de89f59df522ad86f5b5dfc03
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/3bc817d6.failed

Since ip6_tnl_parse_tlv_enc_lim() can call pskb_may_pull()
which may change skb->data, so we need to re-load ipv6h at
the right place.

Fixes: 898b29798e36 ("ip6_gre: Refactor ip6gre xmit codes")
	Cc: William Tu <u9012063@gmail.com>
	Signed-off-by: Haishuang Yan <yanhaishuang@cmss.chinamobile.com>
	Acked-by: William Tu <u9012063@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3bc817d665ac6d9de89f59df522ad86f5b5dfc03)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_gre.c
diff --cc net/ipv6/ip6_gre.c
index d333143106be,dd2d0b963260..000000000000
--- a/net/ipv6/ip6_gre.c
+++ b/net/ipv6/ip6_gre.c
@@@ -502,6 -629,79 +502,82 @@@ static int gre_handle_offloads(struct s
  					csum ? SKB_GSO_GRE_CSUM : SKB_GSO_GRE);
  }
  
++<<<<<<< HEAD
++=======
+ static void prepare_ip6gre_xmit_ipv4(struct sk_buff *skb,
+ 				     struct net_device *dev,
+ 				     struct flowi6 *fl6, __u8 *dsfield,
+ 				     int *encap_limit)
+ {
+ 	const struct iphdr *iph = ip_hdr(skb);
+ 	struct ip6_tnl *t = netdev_priv(dev);
+ 
+ 	if (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))
+ 		*encap_limit = t->parms.encap_limit;
+ 
+ 	memcpy(fl6, &t->fl.u.ip6, sizeof(*fl6));
+ 
+ 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)
+ 		*dsfield = ipv4_get_dsfield(iph);
+ 	else
+ 		*dsfield = ip6_tclass(t->parms.flowinfo);
+ 
+ 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
+ 		fl6->flowi6_mark = skb->mark;
+ 	else
+ 		fl6->flowi6_mark = t->parms.fwmark;
+ 
+ 	fl6->flowi6_uid = sock_net_uid(dev_net(dev), NULL);
+ }
+ 
+ static int prepare_ip6gre_xmit_ipv6(struct sk_buff *skb,
+ 				    struct net_device *dev,
+ 				    struct flowi6 *fl6, __u8 *dsfield,
+ 				    int *encap_limit)
+ {
+ 	struct ipv6hdr *ipv6h;
+ 	struct ip6_tnl *t = netdev_priv(dev);
+ 	__u16 offset;
+ 
+ 	offset = ip6_tnl_parse_tlv_enc_lim(skb, skb_network_header(skb));
+ 	/* ip6_tnl_parse_tlv_enc_lim() might have reallocated skb->head */
+ 	ipv6h = ipv6_hdr(skb);
+ 
+ 	if (offset > 0) {
+ 		struct ipv6_tlv_tnl_enc_lim *tel;
+ 
+ 		tel = (struct ipv6_tlv_tnl_enc_lim *)&skb_network_header(skb)[offset];
+ 		if (tel->encap_limit == 0) {
+ 			icmpv6_send(skb, ICMPV6_PARAMPROB,
+ 				    ICMPV6_HDR_FIELD, offset + 2);
+ 			return -1;
+ 		}
+ 		*encap_limit = tel->encap_limit - 1;
+ 	} else if (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT)) {
+ 		*encap_limit = t->parms.encap_limit;
+ 	}
+ 
+ 	memcpy(fl6, &t->fl.u.ip6, sizeof(*fl6));
+ 
+ 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)
+ 		*dsfield = ipv6_get_dsfield(ipv6h);
+ 	else
+ 		*dsfield = ip6_tclass(t->parms.flowinfo);
+ 
+ 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FLOWLABEL)
+ 		fl6->flowlabel |= ip6_flowlabel(ipv6h);
+ 
+ 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
+ 		fl6->flowi6_mark = skb->mark;
+ 	else
+ 		fl6->flowi6_mark = t->parms.fwmark;
+ 
+ 	fl6->flowi6_uid = sock_net_uid(dev_net(dev), NULL);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 3bc817d665ac (ip6_gre: reload ipv6h in prepare_ip6gre_xmit_ipv6)
  static netdev_tx_t __gre6_xmit(struct sk_buff *skb,
  			       struct net_device *dev, __u8 dsfield,
  			       struct flowi6 *fl6, int encap_limit,
* Unmerged path net/ipv6/ip6_gre.c
