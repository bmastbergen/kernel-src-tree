scsi: qla2xxx: Inline the qla2x00_fcport_event_handler() function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Bart Van Assche <bvanassche@acm.org>
commit 897def2004213636ffe2e9ee6a75660c5b53b03d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/897def20.failed

Instead of calling qla2x00_fcport_event_handler() and letting the switch
statement inside that function decide which other function to call, call
the latter function directly. Remove the event member from the event_arg
structure because it is no longer needed. Remove the
qla_handle_els_plogi_done() function because it is never called.

	Cc: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Bart Van Assche <bvanassche@acm.org>
	Tested-by: Himanshu Madhani <hmadhani@marvell.com>
	Reviewed-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 897def2004213636ffe2e9ee6a75660c5b53b03d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index bffbdb309273,c9cb6856f82e..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -1684,88 -1697,6 +1701,91 @@@ void qla24xx_handle_relogin_event(scsi_
  	qla24xx_fcport_handle_login(vha, fcport);
  }
  
++<<<<<<< HEAD
 +
 +static void qla_handle_els_plogi_done(scsi_qla_host_t *vha,
 +				      struct event_arg *ea)
 +{
 +	ql_dbg(ql_dbg_disc, vha, 0x2118,
 +	    "%s %d %8phC post PRLI\n",
 +	    __func__, __LINE__, ea->fcport->port_name);
 +	qla24xx_post_prli_work(vha, ea->fcport);
 +}
 +
 +void qla2x00_fcport_event_handler(scsi_qla_host_t *vha, struct event_arg *ea)
 +{
 +	fc_port_t *fcport;
 +
 +	switch (ea->event) {
 +	case FCME_RELOGIN:
 +		if (test_bit(UNLOADING, &vha->dpc_flags))
 +			return;
 +
 +		qla24xx_handle_relogin_event(vha, ea);
 +		break;
 +	case FCME_RSCN:
 +		if (test_bit(UNLOADING, &vha->dpc_flags))
 +			return;
 +		{
 +			unsigned long flags;
 +			fcport = qla2x00_find_fcport_by_nportid
 +				(vha, &ea->id, 1);
 +			if (fcport) {
 +				fcport->scan_needed = 1;
 +				fcport->rscn_gen++;
 +			}
 +
 +			spin_lock_irqsave(&vha->work_lock, flags);
 +			if (vha->scan.scan_flags == 0) {
 +				ql_dbg(ql_dbg_disc, vha, 0xffff,
 +				    "%s: schedule\n", __func__);
 +				vha->scan.scan_flags |= SF_QUEUED;
 +				schedule_delayed_work(&vha->scan.scan_work, 5);
 +			}
 +			spin_unlock_irqrestore(&vha->work_lock, flags);
 +		}
 +		break;
 +	case FCME_GNL_DONE:
 +		qla24xx_handle_gnl_done_event(vha, ea);
 +		break;
 +	case FCME_GPSC_DONE:
 +		qla24xx_handle_gpsc_event(vha, ea);
 +		break;
 +	case FCME_PLOGI_DONE:	/* Initiator side sent LLIOCB */
 +		qla24xx_handle_plogi_done_event(vha, ea);
 +		break;
 +	case FCME_PRLI_DONE:
 +		qla24xx_handle_prli_done_event(vha, ea);
 +		break;
 +	case FCME_GPDB_DONE:
 +		qla24xx_handle_gpdb_event(vha, ea);
 +		break;
 +	case FCME_GPNID_DONE:
 +		qla24xx_handle_gpnid_event(vha, ea);
 +		break;
 +	case FCME_GFFID_DONE:
 +		qla24xx_handle_gffid_event(vha, ea);
 +		break;
 +	case FCME_ADISC_DONE:
 +		qla24xx_handle_adisc_event(vha, ea);
 +		break;
 +	case FCME_GNNID_DONE:
 +		qla24xx_handle_gnnid_event(vha, ea);
 +		break;
 +	case FCME_GFPNID_DONE:
 +		qla24xx_handle_gfpnid_event(vha, ea);
 +		break;
 +	case FCME_ELS_PLOGI_DONE:
 +		qla_handle_els_plogi_done(vha, ea);
 +		break;
 +	default:
 +		BUG_ON(1);
 +		break;
 +	}
 +}
 +
++=======
++>>>>>>> 897def200421 (scsi: qla2xxx: Inline the qla2x00_fcport_event_handler() function)
  /*
   * RSCN(s) came in for this fcport, but the RSCN(s) was not able
   * to be consumed by the fcport
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index efa92b3b1c72..5b1ea53f1543 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -2323,22 +2323,6 @@ enum login_state {	/* FW control Target side */
 	DSC_LS_LOGO_PEND,
 };
 
-enum fcport_mgt_event {
-	FCME_RELOGIN = 1,
-	FCME_RSCN,
-	FCME_PLOGI_DONE,	/* Initiator side sent LLIOCB */
-	FCME_PRLI_DONE,
-	FCME_GNL_DONE,
-	FCME_GPSC_DONE,
-	FCME_GPDB_DONE,
-	FCME_GPNID_DONE,
-	FCME_GFFID_DONE,
-	FCME_ADISC_DONE,
-	FCME_GNNID_DONE,
-	FCME_GFPNID_DONE,
-	FCME_ELS_PLOGI_DONE,
-};
-
 enum rscn_addr_format {
 	RSCN_PORT_ADDR,
 	RSCN_AREA_ADDR,
@@ -2457,7 +2441,6 @@ typedef struct fc_port {
 #define QLA_FCPORT_FOUND	2
 
 struct event_arg {
-	enum fcport_mgt_event	event;
 	fc_port_t		*fcport;
 	srb_t			*sp;
 	port_id_t		id;
diff --git a/drivers/scsi/qla2xxx/qla_gbl.h b/drivers/scsi/qla2xxx/qla_gbl.h
index 7a7063b47932..428a1976fcfa 100644
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@ -97,7 +97,11 @@ extern uint8_t qla27xx_find_valid_image(struct scsi_qla_host *);
 extern struct qla_qpair *qla2xxx_create_qpair(struct scsi_qla_host *,
 	int, int, bool);
 extern int qla2xxx_delete_qpair(struct scsi_qla_host *, struct qla_qpair *);
-void qla2x00_fcport_event_handler(scsi_qla_host_t *, struct event_arg *);
+void qla2x00_handle_rscn(scsi_qla_host_t *vha, struct event_arg *ea);
+void qla24xx_handle_plogi_done_event(struct scsi_qla_host *vha,
+				     struct event_arg *ea);
+void qla24xx_handle_relogin_event(scsi_qla_host_t *vha,
+				  struct event_arg *ea);
 int qla24xx_async_gpdb(struct scsi_qla_host *, fc_port_t *, u8);
 int qla24xx_async_prli(struct scsi_qla_host *, fc_port_t *);
 int qla24xx_async_notify_ack(scsi_qla_host_t *, fc_port_t *,
diff --git a/drivers/scsi/qla2xxx/qla_gs.c b/drivers/scsi/qla2xxx/qla_gs.c
index 42f41ac67abd..923bf227c683 100644
--- a/drivers/scsi/qla2xxx/qla_gs.c
+++ b/drivers/scsi/qla2xxx/qla_gs.c
@@ -3081,11 +3081,10 @@ static void qla24xx_async_gpsc_sp_done(void *s, int res)
 		    be16_to_cpu(ct_rsp->rsp.gpsc.speed));
 	}
 	memset(&ea, 0, sizeof(ea));
-	ea.event = FCME_GPSC_DONE;
 	ea.rc = res;
 	ea.fcport = fcport;
 	ea.sp = sp;
-	qla2x00_fcport_event_handler(vha, &ea);
+	qla24xx_handle_gpsc_event(vha, &ea);
 
 done:
 	sp->free(sp);
@@ -3336,7 +3335,6 @@ static void qla2x00_async_gpnid_sp_done(void *s, int res)
 	ea.id.b.area = ct_req->req.port_id.port_id[1];
 	ea.id.b.al_pa = ct_req->req.port_id.port_id[2];
 	ea.rc = res;
-	ea.event = FCME_GPNID_DONE;
 
 	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
 	list_del(&sp->elem);
@@ -3355,7 +3353,7 @@ static void qla2x00_async_gpnid_sp_done(void *s, int res)
 		return;
 	}
 
-	qla2x00_fcport_event_handler(vha, &ea);
+	qla24xx_handle_gpnid_event(vha, &ea);
 
 	e = qla2x00_alloc_work(vha, QLA_EVT_UNMAP);
 	if (!e) {
@@ -3537,9 +3535,8 @@ void qla24xx_async_gffid_sp_done(void *s, int res)
 	ea.sp = sp;
 	ea.fcport = sp->fcport;
 	ea.rc = res;
-	ea.event = FCME_GFFID_DONE;
 
-	qla2x00_fcport_event_handler(vha, &ea);
+	qla24xx_handle_gffid_event(vha, &ea);
 	sp->free(sp);
 }
 
@@ -4303,13 +4300,12 @@ static void qla2x00_async_gnnid_sp_done(void *s, int res)
 	ea.fcport = fcport;
 	ea.sp = sp;
 	ea.rc = res;
-	ea.event = FCME_GNNID_DONE;
 
 	ql_dbg(ql_dbg_disc, vha, 0x204f,
 	    "Async done-%s res %x, WWPN %8phC %8phC\n",
 	    sp->name, res, fcport->port_name, fcport->node_name);
 
-	qla2x00_fcport_event_handler(vha, &ea);
+	qla24xx_handle_gnnid_event(vha, &ea);
 
 	sp->free(sp);
 }
@@ -4437,13 +4433,12 @@ static void qla2x00_async_gfpnid_sp_done(void *s, int res)
 	ea.fcport = fcport;
 	ea.sp = sp;
 	ea.rc = res;
-	ea.event = FCME_GFPNID_DONE;
 
 	ql_dbg(ql_dbg_disc, vha, 0x204f,
 	    "Async done-%s res %x, WWPN %8phC %8phC\n",
 	    sp->name, res, fcport->port_name, fcport->fabric_port_name);
 
-	qla2x00_fcport_event_handler(vha, &ea);
+	qla24xx_handle_gfpnid_event(vha, &ea);
 
 	sp->free(sp);
 }
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_iocb.c b/drivers/scsi/qla2xxx/qla_iocb.c
index 347a91c0bc3a..d81c63cf4e5c 100644
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@ -2861,8 +2861,7 @@ qla2x00_els_dcmd2_sp_done(void *ptr, int res)
 			memset(&ea, 0, sizeof(ea));
 			ea.fcport = fcport;
 			ea.rc = res;
-			ea.event = FCME_ELS_PLOGI_DONE;
-			qla2x00_fcport_event_handler(vha, &ea);
+			qla24xx_handle_plogi_done_event(vha, &ea);
 		}
 
 		e = qla2x00_alloc_work(vha, QLA_EVT_UNMAP);
diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c
index 8cadfea78fdb..8262842540b0 100644
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@ -1114,10 +1114,9 @@ global_port_update:
 			struct event_arg ea;
 
 			memset(&ea, 0, sizeof(ea));
-			ea.event = FCME_RSCN;
 			ea.id.b24 = rscn_entry;
 			ea.id.b.rsvd_1 = rscn_entry >> 24;
-			qla2x00_fcport_event_handler(vha, &ea);
+			qla2x00_handle_rscn(vha, &ea);
 			qla2x00_post_aen_work(vha, FCH_EVT_RSCN, rscn_entry);
 		}
 		break;
diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
index 2d8d1482665a..75bb65e74335 100644
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -5466,9 +5466,8 @@ void qla2x00_relogin(struct scsi_qla_host *vha)
 			} else {
 				if (vha->hw->current_topology != ISP_CFG_NL) {
 					memset(&ea, 0, sizeof(ea));
-					ea.event = FCME_RELOGIN;
 					ea.fcport = fcport;
-					qla2x00_fcport_event_handler(vha, &ea);
+					qla24xx_handle_relogin_event(vha, &ea);
 				} else if (vha->hw->current_topology ==
 				    ISP_CFG_NL) {
 					fcport->login_retry--;
