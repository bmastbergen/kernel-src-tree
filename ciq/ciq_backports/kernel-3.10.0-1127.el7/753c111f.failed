netfilter: nft_compat: use-after-free when deleting targets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 753c111f655e38bbd52fc01321266633f022ebe2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/753c111f.failed

Fetch pointer to module before target object is released.

Fixes: 29e3880109e3 ("netfilter: nf_tables: fix use-after-free when deleting compat expressions")
Fixes: 0ca743a55991 ("netfilter: nf_tables: add compatibility layer for x_tables")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 753c111f655e38bbd52fc01321266633f022ebe2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_compat.c
diff --cc net/netfilter/nft_compat.c
index 424d1b9a8293,0a4bad55a8aa..000000000000
--- a/net/netfilter/nft_compat.c
+++ b/net/netfilter/nft_compat.c
@@@ -260,7 -325,26 +261,30 @@@ nft_target_destroy(const struct nft_ct
  	if (par.target->destroy != NULL)
  		par.target->destroy(&par);
  
++<<<<<<< HEAD
 +	module_put(target->me);
++=======
+ 	if (nft_xt_put(container_of(expr->ops, struct nft_xt, ops)))
+ 		module_put(me);
+ }
+ 
+ static int nft_extension_dump_info(struct sk_buff *skb, int attr,
+ 				   const void *info,
+ 				   unsigned int size, unsigned int user_size)
+ {
+ 	unsigned int info_size, aligned_size = XT_ALIGN(size);
+ 	struct nlattr *nla;
+ 
+ 	nla = nla_reserve(skb, attr, aligned_size);
+ 	if (!nla)
+ 		return -1;
+ 
+ 	info_size = user_size ? : size;
+ 	memcpy(nla_data(nla), info, info_size);
+ 	memset(nla_data(nla) + info_size, 0, aligned_size - info_size);
+ 
+ 	return 0;
++>>>>>>> 753c111f655e (netfilter: nft_compat: use-after-free when deleting targets)
  }
  
  static int nft_target_dump(struct sk_buff *skb, const struct nft_expr *expr)
* Unmerged path net/netfilter/nft_compat.c
