net/mlx5e: Do not rewrite fields with the same match

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Eli Britstein <elibr@mellanox.com>
commit 27c11b6b844cd9473330ff29ddb55a535d2dd14a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/27c11b6b.failed

If we have a match for the same value of a rewrite field, there is no
point for the rewrite. In order to save rewrite actions, and avoid
entirely rewrite actions (if all rewrites are the same), ignore such
rewrite fields.

	Signed-off-by: Eli Britstein <elibr@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 27c11b6b844cd9473330ff29ddb55a535d2dd14a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index c47f64762949,ff9756c3dee5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -1939,9 -1980,9 +1973,10 @@@ static struct mlx5_fields fields[] = 
   * max from the SW pedit action. On success, attr->num_mod_hdr_actions
   * says how many HW actions were actually parsed.
   */
 -static int offload_pedit_fields(struct pedit_headers_action *hdrs,
 +static int offload_pedit_fields(struct pedit_headers *masks,
 +				struct pedit_headers *vals,
  				struct mlx5e_tc_flow_parse_attr *parse_attr,
+ 				u32 *action_flags,
  				struct netlink_ext_ack *extack)
  {
  	struct pedit_headers *set_masks, *add_masks, *set_vals, *add_vals;
@@@ -2083,52 -2152,62 +2139,76 @@@ static int alloc_mod_hdr_actions(struc
  static const struct pedit_headers zero_masks = {};
  
  static int parse_tc_pedit_action(struct mlx5e_priv *priv,
 -				 const struct flow_action_entry *act, int namespace,
 +				 const struct tc_action *a, int namespace,
  				 struct mlx5e_tc_flow_parse_attr *parse_attr,
 -				 struct pedit_headers_action *hdrs,
  				 struct netlink_ext_ack *extack)
  {
 -	u8 cmd = (act->id == FLOW_ACTION_MANGLE) ? 0 : 1;
 -	int err = -EOPNOTSUPP;
 +	struct pedit_headers masks[__PEDIT_CMD_MAX], vals[__PEDIT_CMD_MAX], *cmd_masks;
 +	int nkeys, i, err = -EOPNOTSUPP;
  	u32 mask, val, offset;
 -	u8 htype;
 +	u8 cmd, htype;
  
 -	htype = act->mangle.htype;
 -	err = -EOPNOTSUPP; /* can't be all optimistic */
 +	nkeys = tcf_pedit_nkeys(a);
  
 -	if (htype == FLOW_ACT_MANGLE_UNSPEC) {
 -		NL_SET_ERR_MSG_MOD(extack, "legacy pedit isn't offloaded");
 -		goto out_err;
 -	}
 +	memset(masks, 0, sizeof(struct pedit_headers) * __PEDIT_CMD_MAX);
 +	memset(vals,  0, sizeof(struct pedit_headers) * __PEDIT_CMD_MAX);
  
 -	if (!mlx5e_flow_namespace_max_modify_action(priv->mdev, namespace)) {
 -		NL_SET_ERR_MSG_MOD(extack,
 -				   "The pedit offload action is not supported");
 -		goto out_err;
 -	}
 +	for (i = 0; i < nkeys; i++) {
 +		htype = tcf_pedit_htype(a, i);
 +		cmd = tcf_pedit_cmd(a, i);
 +		err = -EOPNOTSUPP; /* can't be all optimistic */
  
 -	mask = act->mangle.mask;
 -	val = act->mangle.val;
 -	offset = act->mangle.offset;
 +		if (htype == TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK) {
 +			NL_SET_ERR_MSG_MOD(extack,
 +					   "legacy pedit isn't offloaded");
 +			goto out_err;
 +		}
  
 -	err = set_pedit_val(htype, ~mask, val, offset, &hdrs[cmd]);
 -	if (err)
 -		goto out_err;
 +		if (cmd != TCA_PEDIT_KEY_EX_CMD_SET && cmd != TCA_PEDIT_KEY_EX_CMD_ADD) {
 +			NL_SET_ERR_MSG_MOD(extack, "pedit cmd isn't offloaded");
 +			goto out_err;
 +		}
  
 -	hdrs[cmd].pedits++;
 +		mask = tcf_pedit_mask(a, i);
 +		val = tcf_pedit_val(a, i);
 +		offset = tcf_pedit_offset(a, i);
  
++<<<<<<< HEAD
 +		err = set_pedit_val(htype, ~mask, val, offset, &masks[cmd], &vals[cmd]);
++=======
+ 	return 0;
+ out_err:
+ 	return err;
+ }
+ 
+ static int alloc_tc_pedit_action(struct mlx5e_priv *priv, int namespace,
+ 				 struct mlx5e_tc_flow_parse_attr *parse_attr,
+ 				 struct pedit_headers_action *hdrs,
+ 				 u32 *action_flags,
+ 				 struct netlink_ext_ack *extack)
+ {
+ 	struct pedit_headers *cmd_masks;
+ 	int err;
+ 	u8 cmd;
+ 
+ 	if (!parse_attr->mod_hdr_actions) {
+ 		err = alloc_mod_hdr_actions(priv, hdrs, namespace, parse_attr);
++>>>>>>> 27c11b6b844c (net/mlx5e: Do not rewrite fields with the same match)
 +		if (err)
 +			goto out_err;
 +	}
 +
++<<<<<<< HEAD
 +	if (!parse_attr->mod_hdr_actions) {
 +		err = alloc_mod_hdr_actions(priv, a, namespace, parse_attr);
  		if (err)
  			goto out_err;
  	}
  
 +	err = offload_pedit_fields(masks, vals, parse_attr, extack);
++=======
+ 	err = offload_pedit_fields(hdrs, parse_attr, action_flags, extack);
++>>>>>>> 27c11b6b844c (net/mlx5e: Do not rewrite fields with the same match)
  	if (err < 0)
  		goto out_dealloc_parsed_actions;
  
@@@ -2350,10 -2471,25 +2430,24 @@@ static int parse_tc_nic_actions(struct 
  
  			attr->flow_tag = mark;
  			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
 -			}
 -			break;
 -		default:
 -			NL_SET_ERR_MSG_MOD(extack, "The offload action is not supported");
 -			return -EOPNOTSUPP;
 +			continue;
  		}
 -	}
  
++<<<<<<< HEAD
 +		return -EINVAL;
++=======
+ 	if (hdrs[TCA_PEDIT_KEY_EX_CMD_SET].pedits ||
+ 	    hdrs[TCA_PEDIT_KEY_EX_CMD_ADD].pedits) {
+ 		err = alloc_tc_pedit_action(priv, MLX5_FLOW_NAMESPACE_KERNEL,
+ 					    parse_attr, hdrs, &action, extack);
+ 		if (err)
+ 			return err;
+ 		/* in case all pedit actions are skipped, remove the MOD_HDR
+ 		 * flag.
+ 		 */
+ 		if (parse_attr->num_mod_hdr_actions == 0)
+ 			action &= ~MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
++>>>>>>> 27c11b6b844c (net/mlx5e: Do not rewrite fields with the same match)
  	}
  
  	attr->action = action;
@@@ -2732,11 -2884,30 +2826,30 @@@ static int parse_tc_fdb_actions(struct 
  			}
  			action |= MLX5_FLOW_CONTEXT_ACTION_COUNT;
  			attr->dest_chain = dest_chain;
 -			break;
 -			}
 -		default:
 -			NL_SET_ERR_MSG_MOD(extack, "The offload action is not supported");
 -			return -EOPNOTSUPP;
 +
++<<<<<<< HEAD
 +			continue;
  		}
 -	}
  
 +		return -EINVAL;
++=======
+ 	if (hdrs[TCA_PEDIT_KEY_EX_CMD_SET].pedits ||
+ 	    hdrs[TCA_PEDIT_KEY_EX_CMD_ADD].pedits) {
+ 		err = alloc_tc_pedit_action(priv, MLX5_FLOW_NAMESPACE_KERNEL,
+ 					    parse_attr, hdrs, &action, extack);
+ 		if (err)
+ 			return err;
+ 		/* in case all pedit actions are skipped, remove the MOD_HDR
+ 		 * flag. we might have set split_count either by pedit or
+ 		 * pop/push. if there is no pop/push either, reset it too.
+ 		 */
+ 		if (parse_attr->num_mod_hdr_actions == 0) {
+ 			action &= ~MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
+ 			if (!((action & MLX5_FLOW_CONTEXT_ACTION_VLAN_POP) ||
+ 			      (action & MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH)))
+ 				attr->split_count = 0;
+ 		}
++>>>>>>> 27c11b6b844c (net/mlx5e: Do not rewrite fields with the same match)
  	}
  
  	attr->action = action;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
