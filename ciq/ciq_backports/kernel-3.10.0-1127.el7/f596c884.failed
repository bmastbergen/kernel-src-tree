nfit: Fix nfit_intel_shutdown_status() command submission

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit f596c8844fe1d0022007ae6c7a377361fb653eff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/f596c884.failed

The implementation is broken in all the ways the unit test did not touch:

1/ The local definition of in_buf and in_obj violated C99 initializer
   expectations for zeroing. By only initializing 2 out of the three
   struct members the compiler was free to zero-initialize the remaining
   entry even though the aliased location in the union was initialized.

2/ The implementation made assumptions about the state of the 'smart'
   payload after command execution that are satisfied by
   acpi_nfit_ctl(), but not acpi_evaluate_dsm().

3/ populate_shutdown_status() is skipped on Intel NVDIMMs due to the early
   return for skipping the common _LS{I,R,W} enabling.

4/ The input length should be zero.

This breakage was missed due to the unit test implementation only
testing the case where nfit_intel_shutdown_status() returns a valid
payload.

Much of this complexity would be saved if acpi_nfit_ctl() could be used, but
that currently requires a 'struct nvdimm *' argument and one is not created
until later in the init process. The health result is needed before the device
is created because the payload gates whether the nmemX/nfit/dirty_shutdown
property is visible in sysfs.

	Cc: <stable@vger.kernel.org>
Fixes: 0ead11181fe0 ("acpi, nfit: Collect shutdown status")
	Reported-by: Dexuan Cui <decui@microsoft.com>
	Reviewed-by: Dexuan Cui <decui@microsoft.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit f596c8844fe1d0022007ae6c7a377361fb653eff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/nfit/core.c
diff --cc drivers/acpi/nfit/core.c
index deea8d0ce0e0,95db6a2d0d6b..000000000000
--- a/drivers/acpi/nfit/core.c
+++ b/drivers/acpi/nfit/core.c
@@@ -1781,9 -1759,16 +1781,21 @@@ __weak void nfit_intel_shutdown_status(
  	if ((nfit_mem->dsm_mask & (1 << func)) == 0)
  		return;
  
++<<<<<<< HEAD
 +	out_obj = acpi_evaluate_dsm(handle, guid->b, revid, func, &in_obj);
 +	if (!out_obj)
++=======
+ 	out_obj = acpi_evaluate_dsm(handle, guid, revid, func, &in_obj);
+ 	if (!out_obj || out_obj->type != ACPI_TYPE_BUFFER
+ 			|| out_obj->buffer.length < sizeof(smart)) {
+ 		dev_dbg(dev->parent, "%s: failed to retrieve initial health\n",
+ 				dev_name(dev));
+ 		ACPI_FREE(out_obj);
++>>>>>>> f596c8844fe1 (nfit: Fix nfit_intel_shutdown_status() command submission)
  		return;
+ 	}
+ 	memcpy(&smart, out_obj->buffer.pointer, sizeof(smart));
+ 	ACPI_FREE(out_obj);
  
  	if (smart.flags & ND_INTEL_SMART_SHUTDOWN_VALID) {
  		if (smart.shutdown_state)
* Unmerged path drivers/acpi/nfit/core.c
