fib_rules: Added NLM_F_EXCL support to fib_nl_newrule

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Mateusz Bajorski <mateusz.bajorski@nokia.com>
commit 153380ec4b9b6802bba61ebd34da432a54994e9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/153380ec.failed

When adding rule with NLM_F_EXCL flag then check if the same rule exist.
If yes then exit with -EEXIST.

This is already implemented in iproute2:
        if (cmd == RTM_NEWRULE) {
                req.n.nlmsg_flags |= NLM_F_CREATE|NLM_F_EXCL;
                req.r.rtm_type = RTN_UNICAST;
        }

Tested ipv4 and ipv6 with net-next linux on qemu x86

expected behavior after patch:
localhost ~ # ip rule
0:    from all lookup local
32766:    from all lookup main
32767:    from all lookup default
localhost ~ # ip rule add from 10.46.177.97 lookup 104 pref 1005
localhost ~ # ip rule add from 10.46.177.97 lookup 104 pref 1005
RTNETLINK answers: File exists
localhost ~ # ip rule
0:    from all lookup local
1005:    from 10.46.177.97 lookup 104
32766:    from all lookup main
32767:    from all lookup default

There was already topic regarding this but I don't see any changes
merged and problem still occurs.
https://lkml.kernel.org/r/1135778809.5944.7.camel+%28%29+localhost+%21+localdomain

	Signed-off-by: Mateusz Bajorski <mateusz.bajorski@nokia.com>
	Acked-by: David Ahern <dsa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 153380ec4b9b6802bba61ebd34da432a54994e9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/fib_rules.c
diff --cc net/core/fib_rules.c
index 7541aebf6512,be4629c344a6..000000000000
--- a/net/core/fib_rules.c
+++ b/net/core/fib_rules.c
@@@ -341,7 -269,50 +341,54 @@@ errout
  	return err;
  }
  
++<<<<<<< HEAD
 +static int fib_nl_newrule(struct sk_buff *skb, struct nlmsghdr* nlh)
++=======
+ static int rule_exists(struct fib_rules_ops *ops, struct fib_rule_hdr *frh,
+ 		       struct nlattr **tb, struct fib_rule *rule)
+ {
+ 	struct fib_rule *r;
+ 
+ 	list_for_each_entry(r, &ops->rules_list, list) {
+ 		if (r->action != rule->action)
+ 			continue;
+ 
+ 		if (r->table != rule->table)
+ 			continue;
+ 
+ 		if (r->pref != rule->pref)
+ 			continue;
+ 
+ 		if (memcmp(r->iifname, rule->iifname, IFNAMSIZ))
+ 			continue;
+ 
+ 		if (memcmp(r->oifname, rule->oifname, IFNAMSIZ))
+ 			continue;
+ 
+ 		if (r->mark != rule->mark)
+ 			continue;
+ 
+ 		if (r->mark_mask != rule->mark_mask)
+ 			continue;
+ 
+ 		if (r->tun_id != rule->tun_id)
+ 			continue;
+ 
+ 		if (r->fr_net != rule->fr_net)
+ 			continue;
+ 
+ 		if (r->l3mdev != rule->l3mdev)
+ 			continue;
+ 
+ 		if (!ops->compare(r, frh, tb))
+ 			continue;
+ 		return 1;
+ 	}
+ 	return 0;
+ }
+ 
+ int fib_nl_newrule(struct sk_buff *skb, struct nlmsghdr *nlh)
++>>>>>>> 153380ec4b9b (fib_rules: Added NLM_F_EXCL support to fib_nl_newrule)
  {
  	struct net *net = sock_net(skb->sk);
  	struct fib_rule_hdr *frh = nlmsg_data(nlh);
@@@ -442,6 -426,15 +489,18 @@@
  	} else if (rule->action == FR_ACT_GOTO)
  		goto errout_free;
  
++<<<<<<< HEAD
++=======
+ 	if (rule->l3mdev && rule->table)
+ 		goto errout_free;
+ 
+ 	if ((nlh->nlmsg_flags & NLM_F_EXCL) &&
+ 	    rule_exists(ops, frh, tb, rule)) {
+ 		err = -EEXIST;
+ 		goto errout_free;
+ 	}
+ 
++>>>>>>> 153380ec4b9b (fib_rules: Added NLM_F_EXCL support to fib_nl_newrule)
  	err = ops->configure(rule, skb, frh, tb);
  	if (err < 0)
  		goto errout_free;
* Unmerged path net/core/fib_rules.c
