libfs.c: new helper - next_positive()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 4f42c1b5b9c27b6228e6b9c57eee4beb3118b6b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/4f42c1b5.failed

Return nth positive child after given or NULL if there's
less than n left.  dcache_readdir() and dcache_dir_lseek()
switched to it.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 4f42c1b5b9c27b6228e6b9c57eee4beb3118b6b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/libfs.c
diff --cc fs/libfs.c
index 1f2023801ea9,b05b74ae3f16..000000000000
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@@ -105,28 -132,16 +138,35 @@@ loff_t dcache_dir_lseek(struct file *fi
  	if (offset != file->f_pos) {
  		file->f_pos = offset;
  		if (file->f_pos >= 2) {
- 			struct list_head *p;
  			struct dentry *cursor = file->private_data;
+ 			struct dentry *to;
  			loff_t n = file->f_pos - 2;
  
++<<<<<<< HEAD
 +			spin_lock(&dentry->d_lock);
 +			/* d_lock not required for cursor */
 +			list_del(&cursor->d_u.d_child);
 +			p = dentry->d_subdirs.next;
 +			while (n && p != &dentry->d_subdirs) {
 +				struct dentry *next;
 +				next = list_entry(p, struct dentry, d_u.d_child);
 +				spin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);
 +				if (simple_positive(next))
 +					n--;
 +				spin_unlock(&next->d_lock);
 +				p = p->next;
 +			}
 +			list_add_tail(&cursor->d_u.d_child, p);
 +			spin_unlock(&dentry->d_lock);
++=======
+ 			inode_lock_shared(dentry->d_inode);
+ 			to = next_positive(dentry, &dentry->d_subdirs, n);
+ 			move_cursor(cursor, to ? &to->d_child : NULL);
+ 			inode_unlock_shared(dentry->d_inode);
++>>>>>>> 4f42c1b5b9c2 (libfs.c: new helper - next_positive())
  		}
  	}
 +	mutex_unlock(&dentry->d_inode->i_mutex);
  	return offset;
  }
  EXPORT_SYMBOL(dcache_dir_lseek);
@@@ -143,60 -158,29 +183,84 @@@ static inline unsigned char dt_type(str
   * both impossible due to the lock on directory.
   */
  
 -int dcache_readdir(struct file *file, struct dir_context *ctx)
 +int dcache_readdir(struct file * filp, void * dirent, filldir_t filldir)
  {
++<<<<<<< HEAD
 +	struct dentry *dentry = filp->f_path.dentry;
 +	struct dentry *cursor = filp->private_data;
 +	struct list_head *p, *q = &cursor->d_u.d_child;
 +	ino_t ino;
 +	int i = filp->f_pos;
 +
 +	switch (i) {
 +		case 0:
 +			ino = dentry->d_inode->i_ino;
 +			if (filldir(dirent, ".", 1, i, ino, DT_DIR) < 0)
 +				break;
 +			filp->f_pos++;
 +			i++;
 +			/* fallthrough */
 +		case 1:
 +			ino = parent_ino(dentry);
 +			if (filldir(dirent, "..", 2, i, ino, DT_DIR) < 0)
 +				break;
 +			filp->f_pos++;
 +			i++;
 +			/* fallthrough */
 +		default:
 +			spin_lock(&dentry->d_lock);
 +			if (filp->f_pos == 2)
 +				list_move(q, &dentry->d_subdirs);
 +
 +			for (p=q->next; p != &dentry->d_subdirs; p=p->next) {
 +				struct dentry *next;
 +				next = list_entry(p, struct dentry, d_u.d_child);
 +				spin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);
 +				if (!simple_positive(next)) {
 +					spin_unlock(&next->d_lock);
 +					continue;
 +				}
 +
 +				spin_unlock(&next->d_lock);
 +				spin_unlock(&dentry->d_lock);
 +				if (filldir(dirent, next->d_name.name, 
 +					    next->d_name.len, filp->f_pos, 
 +					    next->d_inode->i_ino, 
 +					    dt_type(next->d_inode)) < 0)
 +					return 0;
 +				spin_lock(&dentry->d_lock);
 +				spin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);
 +				/* next is still alive */
 +				list_move(q, p);
 +				spin_unlock(&next->d_lock);
 +				p = q;
 +				filp->f_pos++;
 +			}
 +			spin_unlock(&dentry->d_lock);
 +	}
++=======
+ 	struct dentry *dentry = file->f_path.dentry;
+ 	struct dentry *cursor = file->private_data;
+ 	struct list_head *p = &cursor->d_child;
+ 	struct dentry *next;
+ 	bool moved = false;
+ 
+ 	if (!dir_emit_dots(file, ctx))
+ 		return 0;
+ 
+ 	if (ctx->pos == 2)
+ 		p = &dentry->d_subdirs;
+ 	while ((next = next_positive(dentry, p, 1)) != NULL) {
+ 		if (!dir_emit(ctx, next->d_name.name, next->d_name.len,
+ 			      d_inode(next)->i_ino, dt_type(d_inode(next))))
+ 			break;
+ 		moved = true;
+ 		p = &next->d_child;
+ 		ctx->pos++;
+ 	}
+ 	if (moved)
+ 		move_cursor(cursor, p);
++>>>>>>> 4f42c1b5b9c2 (libfs.c: new helper - next_positive())
  	return 0;
  }
  EXPORT_SYMBOL(dcache_readdir);
* Unmerged path fs/libfs.c
