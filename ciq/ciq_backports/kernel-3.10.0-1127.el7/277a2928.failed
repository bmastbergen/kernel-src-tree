netfilter: nft_dynset: continue to next expr if _OP_ADD succeeded

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Liping Zhang <zlpnobody@gmail.com>
commit 277a292835c196894ef895d5e1fd6170bb916f55
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/277a2928.failed

Currently, after adding the following nft rules:
  # nft add set x target1 { type ipv4_addr \; flags timeout \;}
  # nft add rule x y set add ip daddr timeout 1d @target1 counter

the counters will always be zero despite of the elements are added
to the dynamic set "target1" or not, as we will break the nft expr
traversal unconditionally:
  # nft list ruleset
  ...
  set target1 {
      ...
      elements = { 8.8.8.8 expires 23h59m53s}
  }
  chain output {
      ...
      set add ip daddr timeout 1d @target1 counter packets 0 bytes 0
                                                           ^       ^
      ...
  }

Since we add the elements to the set successfully, we should continue
to the next expression.

Additionally, if elements are added to "flow table" successfully, we
will _always_ continue to the next expr, even if the operation is
_OP_ADD. So it's better to keep them to be consistent.

Fixes: 22fe54d5fefc ("netfilter: nf_tables: add support for dynamic set updates")
	Reported-by: Robert White <rwhite@pobox.com>
	Signed-off-by: Liping Zhang <zlpnobody@gmail.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 277a292835c196894ef895d5e1fd6170bb916f55)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_dynset.c
diff --cc net/netfilter/nft_dynset.c
index c6804f3511c8,fafbeea3ed04..000000000000
--- a/net/netfilter/nft_dynset.c
+++ b/net/netfilter/nft_dynset.c
@@@ -82,10 -86,14 +81,16 @@@ static void nft_dynset_eval(const struc
  
  		if (sexpr != NULL)
  			sexpr->ops->eval(sexpr, regs, pkt);
 -
 -		if (priv->invert)
 -			regs->verdict.code = NFT_BREAK;
  		return;
  	}
++<<<<<<< HEAD
 +out:
 +	regs->verdict.code = NFT_BREAK;
++=======
+ 
+ 	if (!priv->invert)
+ 		regs->verdict.code = NFT_BREAK;
++>>>>>>> 277a292835c1 (netfilter: nft_dynset: continue to next expr if _OP_ADD succeeded)
  }
  
  static const struct nla_policy nft_dynset_policy[NFTA_DYNSET_MAX + 1] = {
* Unmerged path net/netfilter/nft_dynset.c
