sched: Check for stop task appearance when balancing happens

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Kirill Tkhai <tkhai@yandex.ru>
commit a1d9a3231eac4117cadaf4b6bba5b2902c15a33e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/a1d9a323.failed

We need to do it like we do for the other higher priority classes..

	Signed-off-by: Kirill Tkhai <tkhai@yandex.ru>
	Cc: Michael wang <wangyun@linux.vnet.ibm.com>
	Cc: Sasha Levin <sasha.levin@oracle.com>
	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/336561397137116@web27h.yandex.ru
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit a1d9a3231eac4117cadaf4b6bba5b2902c15a33e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/deadline.c
#	kernel/sched/fair.c
#	kernel/sched/rt.c
diff --cc kernel/sched/deadline.c
index 75f9634980d1,b08095786cb8..000000000000
--- a/kernel/sched/deadline.c
+++ b/kernel/sched/deadline.c
@@@ -1589,6 -1021,24 +1589,27 @@@ struct task_struct *pick_next_task_dl(s
  
  	dl_rq = &rq->dl;
  
++<<<<<<< HEAD
++=======
+ 	if (need_pull_dl_task(rq, prev)) {
+ 		pull_dl_task(rq);
+ 		/*
+ 		 * pull_rt_task() can drop (and re-acquire) rq->lock; this
+ 		 * means a stop task can slip in, in which case we need to
+ 		 * re-start task selection.
+ 		 */
+ 		if (rq->stop && rq->stop->on_rq)
+ 			return RETRY_TASK;
+ 	}
+ 
+ 	/*
+ 	 * When prev is DL, we may throttle it in put_prev_task().
+ 	 * So, we update time before we check for dl_nr_running.
+ 	 */
+ 	if (prev->sched_class == &dl_sched_class)
+ 		update_curr_dl(rq);
+ 
++>>>>>>> a1d9a3231eac (sched: Check for stop task appearance when balancing happens)
  	if (unlikely(!dl_rq->dl_nr_running))
  		return NULL;
  
diff --cc kernel/sched/fair.c
index c5d4b4242380,7570dd969c28..000000000000
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@@ -7032,6 -6723,22 +7032,24 @@@ out
  
  	if (curr_cost > this_rq->max_idle_balance_cost)
  		this_rq->max_idle_balance_cost = curr_cost;
++<<<<<<< HEAD
++=======
+ 
+ out:
+ 	/* Is there a task of a high priority class? */
+ 	if (this_rq->nr_running != this_rq->cfs.h_nr_running &&
+ 	    ((this_rq->stop && this_rq->stop->on_rq) ||
+ 	     this_rq->dl.dl_nr_running ||
+ 	     (this_rq->rt.rt_nr_running && !rt_rq_throttled(&this_rq->rt))))
+ 		pulled_task = -1;
+ 
+ 	if (pulled_task) {
+ 		idle_exit_fair(this_rq);
+ 		this_rq->idle_stamp = 0;
+ 	}
+ 
+ 	return pulled_task;
++>>>>>>> a1d9a3231eac (sched: Check for stop task appearance when balancing happens)
  }
  
  /*
diff --cc kernel/sched/rt.c
index 6b68ceb9a68d,bd2267ad404f..000000000000
--- a/kernel/sched/rt.c
+++ b/kernel/sched/rt.c
@@@ -1370,9 -1352,40 +1370,43 @@@ static struct task_struct *_pick_next_t
  	return p;
  }
  
 -static struct task_struct *
 -pick_next_task_rt(struct rq *rq, struct task_struct *prev)
 +static struct task_struct *pick_next_task_rt(struct rq *rq)
  {
++<<<<<<< HEAD
 +	struct task_struct *p = _pick_next_task_rt(rq);
++=======
+ 	struct task_struct *p;
+ 	struct rt_rq *rt_rq = &rq->rt;
+ 
+ 	if (need_pull_rt_task(rq, prev)) {
+ 		pull_rt_task(rq);
+ 		/*
+ 		 * pull_rt_task() can drop (and re-acquire) rq->lock; this
+ 		 * means a dl or stop task can slip in, in which case we need
+ 		 * to re-start task selection.
+ 		 */
+ 		if (unlikely((rq->stop && rq->stop->on_rq) ||
+ 			     rq->dl.dl_nr_running))
+ 			return RETRY_TASK;
+ 	}
+ 
+ 	/*
+ 	 * We may dequeue prev's rt_rq in put_prev_task().
+ 	 * So, we update time before rt_nr_running check.
+ 	 */
+ 	if (prev->sched_class == &rt_sched_class)
+ 		update_curr_rt(rq);
+ 
+ 	if (!rt_rq->rt_nr_running)
+ 		return NULL;
+ 
+ 	if (rt_rq_throttled(rt_rq))
+ 		return NULL;
+ 
+ 	put_prev_task(rq, prev);
+ 
+ 	p = _pick_next_task_rt(rq);
++>>>>>>> a1d9a3231eac (sched: Check for stop task appearance when balancing happens)
  
  	/* The running task is never eligible for pushing */
  	if (p)
* Unmerged path kernel/sched/deadline.c
* Unmerged path kernel/sched/fair.c
* Unmerged path kernel/sched/rt.c
