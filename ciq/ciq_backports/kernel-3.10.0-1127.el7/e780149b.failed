mm: fix set pageblock migratetype in deferred struct page init

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Xishi Qiu <qiuxishi@huawei.com>
commit e780149bcd4be171421535db0514fa9ff556cb87
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/e780149b.failed

On x86_64 MAX_ORDER_NR_PAGES is usually 4M, and a pageblock is usually
2M, so we only set one pageblock's migratetype in deferred_free_range()
if pfn is aligned to MAX_ORDER_NR_PAGES.  That means it causes
uninitialized migratetype blocks, you can see from "cat
/proc/pagetypeinfo", almost half blocks are Unmovable.

Also we missed freeing the last block in deferred_init_memmap(), it
causes memory leak.

Fixes: ac5d2539b238 ("mm: meminit: reduce number of times pageblocks are set during struct page init")
Link: http://lkml.kernel.org/r/57A3260F.4050709@huawei.com
	Signed-off-by: Xishi Qiu <qiuxishi@huawei.com>
	Cc: Taku Izumi <izumi.taku@jp.fujitsu.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Mel Gorman <mgorman@techsingularity.net>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: "Kirill A . Shutemov" <kirill.shutemov@linux.intel.com>
	Cc: Kamezawa Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit e780149bcd4be171421535db0514fa9ff556cb87)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/page_alloc.c
diff --cc mm/page_alloc.c
index fd58fca076c2,0c34633720c0..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -1086,15 -1393,18 +1086,27 @@@ static void __init deferred_free_range(
  		return;
  
  	/* Free a large naturally-aligned chunk if possible */
- 	if (nr_pages == MAX_ORDER_NR_PAGES &&
- 	    (pfn & (MAX_ORDER_NR_PAGES-1)) == 0) {
+ 	if (nr_pages == pageblock_nr_pages &&
+ 	    (pfn & (pageblock_nr_pages - 1)) == 0) {
  		set_pageblock_migratetype(page, MIGRATE_MOVABLE);
++<<<<<<< HEAD
 +		__free_pages_boot_core(page, pfn, MAX_ORDER-1);
 +		return;
 +	}
 +
 +	for (i = 0; i < nr_pages; i++, page++, pfn++)
 +		__free_pages_boot_core(page, pfn, 0);
++=======
+ 		__free_pages_boot_core(page, pageblock_order);
+ 		return;
+ 	}
+ 
+ 	for (i = 0; i < nr_pages; i++, page++, pfn++) {
+ 		if ((pfn & (pageblock_nr_pages - 1)) == 0)
+ 			set_pageblock_migratetype(page, MIGRATE_MOVABLE);
+ 		__free_pages_boot_core(page, 0);
+ 	}
++>>>>>>> e780149bcd4b (mm: fix set pageblock migratetype in deferred struct page init)
  }
  
  /* Completion tracking for deferred_init_memmap() threads */
* Unmerged path mm/page_alloc.c
