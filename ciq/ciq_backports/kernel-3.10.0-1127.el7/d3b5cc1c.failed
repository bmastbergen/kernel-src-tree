RDMA/mlx5: Initialize roce port info before multiport master init

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Mark Bloch <markb@mellanox.com>
commit d3b5cc1cd996ce84d362b3c15f940346603741b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/d3b5cc1c.failed

When working in mutliport RoCE mode it is possible to attach a slave
before the master. In that case the slave is waiting for a master to be
attached.  When the master is attached it goes over the list of waiting
slaves, finds a slave that is compatible and tries to bind it to itself.

The call stack is:
mlx5_ib_init_multiport_master() -> mlx5_ib_bind_slave_port()

In the bind function we will create a netdev notifier, but this is done
before we initialize the RoCE structure (this is done at a later stage by
the master in the ROCE stage).

Once events are delivered to that notifier we will use
mlx5_ib_get_native_port_mdev() to get the actual port and as the native
port is zero we will access an invalid index in the port structure.

Move the RoCE structure initialization to an earlier stage.

Fixes: 32f69e4be269 ("{net, IB}/mlx5: Manage port association for multiport RoCE")
	Signed-off-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit d3b5cc1cd996ce84d362b3c15f940346603741b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
diff --cc drivers/infiniband/hw/mlx5/main.c
index 94a0cdc2f350,795db12e7fa4..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -5748,14 -5901,12 +5748,21 @@@ int mlx5_ib_stage_init_init(struct mlx5
  	int err;
  	int i;
  
 +	dev->port = kcalloc(dev->num_ports, sizeof(*dev->port),
 +			    GFP_KERNEL);
 +	if (!dev->port)
 +		return -ENOMEM;
 +
  	for (i = 0; i < dev->num_ports; i++) {
  		spin_lock_init(&dev->port[i].mp.mpi_lock);
++<<<<<<< HEAD
 +		rwlock_init(&dev->roce[i].netdev_lock);
++=======
+ 		rwlock_init(&dev->port[i].roce.netdev_lock);
+ 		dev->port[i].roce.dev = dev;
+ 		dev->port[i].roce.native_port_num = i + 1;
+ 		dev->port[i].roce.last_port_state = IB_PORT_DOWN;
++>>>>>>> d3b5cc1cd996 (RDMA/mlx5: Initialize roce port info before multiport master init)
  	}
  
  	err = mlx5_ib_init_multiport_master(dev);
@@@ -6014,20 -6184,15 +6021,23 @@@ int mlx5_ib_stage_rep_non_default_cb(st
  static int mlx5_ib_stage_common_roce_init(struct mlx5_ib_dev *dev)
  {
  	u8 port_num;
++<<<<<<< HEAD
 +	int i;
 +
 +	for (i = 0; i < dev->num_ports; i++) {
 +		dev->roce[i].dev = dev;
 +		dev->roce[i].native_port_num = i + 1;
 +		dev->roce[i].last_port_state = IB_PORT_DOWN;
 +	}
++=======
++>>>>>>> d3b5cc1cd996 (RDMA/mlx5: Initialize roce port info before multiport master init)
 +
 +	dev->ib_dev.get_netdev	= mlx5_ib_get_netdev;
 +	dev->ib_dev.create_wq	 = mlx5_ib_create_wq;
 +	dev->ib_dev.modify_wq	 = mlx5_ib_modify_wq;
 +	dev->ib_dev.destroy_wq	 = mlx5_ib_destroy_wq;
 +	dev->ib_dev.create_rwq_ind_table = mlx5_ib_create_rwq_ind_table;
 +	dev->ib_dev.destroy_rwq_ind_table = mlx5_ib_destroy_rwq_ind_table;
  
  	dev->ib_dev.uverbs_ex_cmd_mask |=
  			(1ull << IB_USER_VERBS_EX_CMD_CREATE_WQ) |
* Unmerged path drivers/infiniband/hw/mlx5/main.c
