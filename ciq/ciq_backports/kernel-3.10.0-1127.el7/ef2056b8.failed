ALSA: pcm: Cleanup snd_pcm_stream_lock() & co

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit ef2056b8f3945c78cc5a3a3ba7592e18a757ffd9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/ef2056b8.failed

After the previous code refactoring, the PCM stream locking code
became nothing but the PCM group lock with self_group object.  Use the
existing helper function for simplifying the code.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit ef2056b8f3945c78cc5a3a3ba7592e18a757ffd9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/core/pcm_native.c
diff --cc sound/core/pcm_native.c
index 72d271be617b,024e32acbc25..000000000000
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@@ -104,58 -92,23 +104,75 @@@ void snd_pcm_group_init(struct snd_pcm_
  	spin_lock_init(&group->lock);
  	mutex_init(&group->mutex);
  	INIT_LIST_HEAD(&group->substreams);
 -	refcount_set(&group->refs, 0);
  }
  
++<<<<<<< HEAD
 +#define PCM_LOCK_DEFAULT	0
 +#define PCM_LOCK_IRQ	1
 +#define PCM_LOCK_IRQSAVE	2
 +
 +static unsigned long __snd_pcm_stream_lock_mode(struct snd_pcm_substream *substream,
 +						unsigned int mode)
 +{
 +	unsigned long flags = 0;
 +	if (substream->pcm->nonatomic) {
 +		down_read_nested(&snd_pcm_link_rwsem, SINGLE_DEPTH_NESTING);
 +		mutex_lock(&substream->self_group.mutex);
 +	} else {
 +		switch (mode) {
 +		case PCM_LOCK_DEFAULT:
 +			read_lock(&snd_pcm_link_rwlock);
 +			break;
 +		case PCM_LOCK_IRQ:
 +			read_lock_irq(&snd_pcm_link_rwlock);
 +			break;
 +		case PCM_LOCK_IRQSAVE:
 +			read_lock_irqsave(&snd_pcm_link_rwlock, flags);
 +			break;
 +		}
 +		spin_lock(&substream->self_group.lock);
 +	}
 +	return flags;
 +}
 +
 +static void __snd_pcm_stream_unlock_mode(struct snd_pcm_substream *substream,
 +					 unsigned int mode, unsigned long flags)
 +{
 +	if (substream->pcm->nonatomic) {
 +		mutex_unlock(&substream->self_group.mutex);
 +		up_read(&snd_pcm_link_rwsem);
 +	} else {
 +		spin_unlock(&substream->self_group.lock);
 +
 +		switch (mode) {
 +		case PCM_LOCK_DEFAULT:
 +			read_unlock(&snd_pcm_link_rwlock);
 +			break;
 +		case PCM_LOCK_IRQ:
 +			read_unlock_irq(&snd_pcm_link_rwlock);
 +			break;
 +		case PCM_LOCK_IRQSAVE:
 +			read_unlock_irqrestore(&snd_pcm_link_rwlock, flags);
 +			break;
 +		}
 +	}
 +}
++=======
+ /* define group lock helpers */
+ #define DEFINE_PCM_GROUP_LOCK(action, mutex_action) \
+ static void snd_pcm_group_ ## action(struct snd_pcm_group *group, bool nonatomic) \
+ { \
+ 	if (nonatomic) \
+ 		mutex_ ## mutex_action(&group->mutex); \
+ 	else \
+ 		spin_ ## action(&group->lock); \
+ }
+ 
+ DEFINE_PCM_GROUP_LOCK(lock, lock);
+ DEFINE_PCM_GROUP_LOCK(unlock, unlock);
+ DEFINE_PCM_GROUP_LOCK(lock_irq, lock);
+ DEFINE_PCM_GROUP_LOCK(unlock_irq, unlock);
++>>>>>>> ef2056b8f394 (ALSA: pcm: Cleanup snd_pcm_stream_lock() & co)
  
  /**
   * snd_pcm_stream_lock - Lock the PCM stream
* Unmerged path sound/core/pcm_native.c
