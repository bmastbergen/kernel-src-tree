perf callchain: Stop validating callchains by the max_stack sysctl

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit bf8bddbf1971d40549f33bc6f70623cf53bbfa2f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/bf8bddbf.failed

As thread__resolve_callchain_sample can be used for handling perf.data
files, that could've been recorded with a large max_stack sysctl setting
than what the system used for analysis has set.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Alexei Starovoitov <ast@kernel.org>
	Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: He Kuang <hekuang@huawei.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Masami Hiramatsu <mhiramat@kernel.org>
	Cc: Milian Wolff <milian.wolff@kdab.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
	Cc: Wang Nan <wangnan0@huawei.com>
	Cc: Zefan Li <lizefan@huawei.com>
Link: http://lkml.kernel.org/n/tip-2995bt2g5yq2m05vga4kip6m@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit bf8bddbf1971d40549f33bc6f70623cf53bbfa2f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/machine.c
diff --cc tools/perf/util/machine.c
index 64f4a3a50bdb,205d27017361..000000000000
--- a/tools/perf/util/machine.c
+++ b/tools/perf/util/machine.c
@@@ -2070,16 -1771,7 +2070,11 @@@ static int resolve_lbr_callchain_sample
  		 */
  		int mix_chain_nr = i + 1 + lbr_nr + 1;
  
- 		if (mix_chain_nr > (int)sysctl_perf_event_max_stack + PERF_MAX_BRANCH_DEPTH) {
- 			pr_warning("corrupted callchain. skipping...\n");
- 			return 0;
- 		}
- 
  		for (j = 0; j < mix_chain_nr; j++) {
 +			int err;
 +			branch = false;
 +			flags = NULL;
 +
  			if (callchain_param.order == ORDER_CALLEE) {
  				if (j < i + 1)
  					ip = chain->ips[j];
@@@ -2136,9 -1808,9 +2131,13 @@@ static int thread__resolve_callchain_sa
  {
  	struct branch_stack *branch = sample->branch_stack;
  	struct ip_callchain *chain = sample->callchain;
 -	int chain_nr = chain->nr;
 +	int chain_nr = 0;
  	u8 cpumode = PERF_RECORD_MISC_USER;
++<<<<<<< HEAD
 +	int i, j, err;
++=======
+ 	int i, j, err, nr_entries;
++>>>>>>> bf8bddbf1971 (perf callchain: Stop validating callchains by the max_stack sysctl)
  	int skip_idx = -1;
  	int first_call = 0;
  
@@@ -2156,8 -1825,7 +2155,12 @@@
  	 * Based on DWARF debug information, some architectures skip
  	 * a callchain entry saved by the kernel.
  	 */
++<<<<<<< HEAD
 +	if (chain->nr < sysctl_perf_event_max_stack)
 +		skip_idx = arch_skip_callchain_idx(thread, chain);
++=======
+ 	skip_idx = arch_skip_callchain_idx(thread, chain);
++>>>>>>> bf8bddbf1971 (perf callchain: Stop validating callchains by the max_stack sysctl)
  
  	/*
  	 * Add branches to call stack for easier browsing. This gives
@@@ -2233,12 -1885,8 +2236,17 @@@
  	}
  
  check_calls:
++<<<<<<< HEAD
 +	if (chain->nr > sysctl_perf_event_max_stack && (int)chain->nr > max_stack) {
 +		pr_warning("corrupted callchain. skipping...\n");
 +		return 0;
 +	}
 +
 +	for (i = first_call; i < chain_nr; i++) {
++=======
+ 	for (i = first_call, nr_entries = 0;
+ 	     i < chain_nr && nr_entries < max_stack; i++) {
++>>>>>>> bf8bddbf1971 (perf callchain: Stop validating callchains by the max_stack sysctl)
  		u64 ip;
  
  		if (callchain_param.order == ORDER_CALLEE)
@@@ -2252,49 -1900,16 +2260,59 @@@
  #endif
  		ip = chain->ips[j];
  
++<<<<<<< HEAD
 +		err = add_callchain_ip(thread, cursor, parent,
 +				       root_al, &cpumode, ip,
 +				       false, NULL, NULL, 0);
++=======
+ 		if (ip < PERF_CONTEXT_MAX)
+                        ++nr_entries;
+ 
+ 		err = add_callchain_ip(thread, cursor, parent, root_al, &cpumode, ip);
++>>>>>>> bf8bddbf1971 (perf callchain: Stop validating callchains by the max_stack sysctl)
  
  		if (err)
  			return (err < 0) ? err : 0;
  	}
  
  	return 0;
++<<<<<<< HEAD
 +}
 +
 +static int append_inlines(struct callchain_cursor *cursor,
 +			  struct map *map, struct symbol *sym, u64 ip)
 +{
 +	struct inline_node *inline_node;
 +	struct inline_list *ilist;
 +	u64 addr;
 +	int ret = 1;
 +
 +	if (!symbol_conf.inline_name || !map || !sym)
 +		return ret;
 +
 +	addr = map__map_ip(map, ip);
 +	addr = map__rip_2objdump(map, addr);
 +
 +	inline_node = inlines__tree_find(&map->dso->inlined_nodes, addr);
 +	if (!inline_node) {
 +		inline_node = dso__parse_addr_inlines(map->dso, addr, sym);
 +		if (!inline_node)
 +			return ret;
 +		inlines__tree_insert(&map->dso->inlined_nodes, inline_node);
 +	}
 +
 +	list_for_each_entry(ilist, &inline_node->val, list) {
 +		ret = callchain_cursor_append(cursor, ip, map,
 +					      ilist->symbol, false,
 +					      NULL, 0, 0, 0, ilist->srcline);
 +
 +		if (ret != 0)
 +			return ret;
 +	}
 +
 +	return ret;
++=======
++>>>>>>> bf8bddbf1971 (perf callchain: Stop validating callchains by the max_stack sysctl)
  }
  
  static int unwind_entry(struct unwind_entry *entry, void *arg)
* Unmerged path tools/perf/util/machine.c
