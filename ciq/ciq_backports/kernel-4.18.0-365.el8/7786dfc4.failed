skmsg: Use rcu work for destroying psock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Cong Wang <cong.wang@bytedance.com>
commit 7786dfc41a74e0567557b5c4a28fc8482f5f5691
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/7786dfc4.failed

The RCU callback sk_psock_destroy() only queues work psock->gc,
so we can just switch to rcu work to simplify the code.

	Signed-off-by: Cong Wang <cong.wang@bytedance.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
Link: https://lore.kernel.org/bpf/20210331023237.41094-6-xiyou.wangcong@gmail.com
(cherry picked from commit 7786dfc41a74e0567557b5c4a28fc8482f5f5691)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/skmsg.c
diff --cc net/core/skmsg.c
index c39c0a361217,d43d43905d2c..000000000000
--- a/net/core/skmsg.c
+++ b/net/core/skmsg.c
@@@ -646,17 -652,30 +646,35 @@@ static void sk_psock_link_destroy(struc
  	}
  }
  
++<<<<<<< HEAD
 +static void sk_psock_destroy_deferred(struct work_struct *gc)
++=======
+ void sk_psock_stop(struct sk_psock *psock, bool wait)
  {
- 	struct sk_psock *psock = container_of(gc, struct sk_psock, gc);
+ 	spin_lock_bh(&psock->ingress_lock);
+ 	sk_psock_clear_state(psock, SK_PSOCK_TX_ENABLED);
+ 	sk_psock_cork_free(psock);
+ 	__sk_psock_zap_ingress(psock);
+ 	spin_unlock_bh(&psock->ingress_lock);
+ 
+ 	if (wait)
+ 		cancel_work_sync(&psock->work);
+ }
+ 
+ static void sk_psock_done_strp(struct sk_psock *psock);
  
+ static void sk_psock_destroy(struct work_struct *work)
++>>>>>>> 7786dfc41a74 (skmsg: Use rcu work for destroying psock)
+ {
+ 	struct sk_psock *psock = container_of(to_rcu_work(work),
+ 					      struct sk_psock, rwork);
  	/* No sk_callback_lock since already detached. */
  
 -	sk_psock_done_strp(psock);
 +	/* Parser has been stopped */
 +	if (psock->progs.skb_parser)
 +		strp_done(&psock->parser.strp);
  
  	cancel_work_sync(&psock->work);
 -	mutex_destroy(&psock->work_mutex);
  
  	psock_progs_drop(&psock->progs);
  
@@@ -670,30 -688,21 +688,23 @@@
  	kfree(psock);
  }
  
- static void sk_psock_destroy(struct rcu_head *rcu)
- {
- 	struct sk_psock *psock = container_of(rcu, struct sk_psock, rcu);
- 
- 	INIT_WORK(&psock->gc, sk_psock_destroy_deferred);
- 	schedule_work(&psock->gc);
- }
- 
  void sk_psock_drop(struct sock *sk, struct sk_psock *psock)
  {
 -	sk_psock_stop(psock, false);
 +	sk_psock_cork_free(psock);
 +	sk_psock_zap_ingress(psock);
  
  	write_lock_bh(&sk->sk_callback_lock);
  	sk_psock_restore_proto(sk, psock);
  	rcu_assign_sk_user_data(sk, NULL);
 -	if (psock->progs.stream_parser)
 +	if (psock->progs.skb_parser)
  		sk_psock_stop_strp(sk, psock);
 -	else if (psock->progs.stream_verdict)
 +	else if (psock->progs.skb_verdict)
  		sk_psock_stop_verdict(sk, psock);
  	write_unlock_bh(&sk->sk_callback_lock);
 +	sk_psock_clear_state(psock, SK_PSOCK_TX_ENABLED);
  
- 	call_rcu(&psock->rcu, sk_psock_destroy);
+ 	INIT_RCU_WORK(&psock->rwork, sk_psock_destroy);
+ 	queue_rcu_work(system_wq, &psock->rwork);
  }
  EXPORT_SYMBOL_GPL(sk_psock_drop);
  
diff --git a/include/linux/skmsg.h b/include/linux/skmsg.h
index a85cacd89635..9f1c18c3d39f 100644
--- a/include/linux/skmsg.h
+++ b/include/linux/skmsg.h
@@ -103,10 +103,7 @@ struct sk_psock {
 	struct proto			*sk_proto;
 	struct sk_psock_work_state	work_state;
 	struct work_struct		work;
-	union {
-		struct rcu_head		rcu;
-		struct work_struct	gc;
-	};
+	struct rcu_work			rwork;
 };
 
 int sk_msg_alloc(struct sock *sk, struct sk_msg *msg, int len,
* Unmerged path net/core/skmsg.c
