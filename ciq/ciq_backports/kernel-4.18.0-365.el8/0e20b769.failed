drm/i915/display/psr: Handle SU Y granularity

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author José Roberto de Souza <jose.souza@intel.com>
commit 0e20b769c4b3347b68c7c388ce5b758dcc7d141a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/0e20b769.failed

We were only handling X and width granularity, what was causing issues
when sink had a granularity different than 4.

While at it, renaming su_x_granularity to su_w_granularity to better
match reality.

	Cc: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
	Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
	Reviewed-by: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210616203158.118111-1-jose.souza@intel.com
(cherry picked from commit 0e20b769c4b3347b68c7c388ce5b758dcc7d141a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_display_types.h
#	drivers/gpu/drm/i915/display/intel_psr.c
diff --cc drivers/gpu/drm/i915/display/intel_display_types.h
index cc8308e725ba,7ea73420bcf9..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@@ -1420,6 -1471,46 +1421,49 @@@ struct intel_pps 
  	struct edp_power_seq pps_delays;
  };
  
++<<<<<<< HEAD
++=======
+ struct intel_psr {
+ 	/* Mutex for PSR state of the transcoder */
+ 	struct mutex lock;
+ 
+ #define I915_PSR_DEBUG_MODE_MASK	0x0f
+ #define I915_PSR_DEBUG_DEFAULT		0x00
+ #define I915_PSR_DEBUG_DISABLE		0x01
+ #define I915_PSR_DEBUG_ENABLE		0x02
+ #define I915_PSR_DEBUG_FORCE_PSR1	0x03
+ #define I915_PSR_DEBUG_ENABLE_SEL_FETCH	0x4
+ #define I915_PSR_DEBUG_IRQ		0x10
+ 
+ 	u32 debug;
+ 	bool sink_support;
+ 	bool source_support;
+ 	bool enabled;
+ 	bool paused;
+ 	enum pipe pipe;
+ 	enum transcoder transcoder;
+ 	bool active;
+ 	struct work_struct work;
+ 	unsigned int busy_frontbuffer_bits;
+ 	bool sink_psr2_support;
+ 	bool link_standby;
+ 	bool colorimetry_support;
+ 	bool psr2_enabled;
+ 	bool psr2_sel_fetch_enabled;
+ 	u8 sink_sync_latency;
+ 	ktime_t last_entry_attempt;
+ 	ktime_t last_exit;
+ 	bool sink_not_reliable;
+ 	bool irq_aux_error;
+ 	u16 su_w_granularity;
+ 	u16 su_y_granularity;
+ 	u32 dc3co_exitline;
+ 	u32 dc3co_exit_delay;
+ 	struct delayed_work dc3co_work;
+ 	struct drm_dp_vsc_sdp vsc;
+ };
+ 
++>>>>>>> 0e20b769c4b3 (drm/i915/display/psr: Handle SU Y granularity)
  struct intel_dp {
  	i915_reg_t output_reg;
  	u32 DP;
diff --cc drivers/gpu/drm/i915/display/intel_psr.c
index 2c6c4a4f9477,fde30f937504..000000000000
--- a/drivers/gpu/drm/i915/display/intel_psr.c
+++ b/drivers/gpu/drm/i915/display/intel_psr.c
@@@ -341,15 -351,14 +353,19 @@@ void intel_psr_init_dpcd(struct intel_d
  		 * Y-coordinate requirement panels we would need to enable
  		 * GTC first.
  		 */
 -		intel_dp->psr.sink_psr2_support = y_req && alpm;
 +		dev_priv->psr.sink_psr2_support = y_req && alpm;
  		drm_dbg_kms(&dev_priv->drm, "PSR2 %ssupported\n",
 -			    intel_dp->psr.sink_psr2_support ? "" : "not ");
 +			    dev_priv->psr.sink_psr2_support ? "" : "not ");
  
 -		if (intel_dp->psr.sink_psr2_support) {
 -			intel_dp->psr.colorimetry_support =
 +		if (dev_priv->psr.sink_psr2_support) {
 +			dev_priv->psr.colorimetry_support =
  				intel_dp_get_colorimetry_status(intel_dp);
++<<<<<<< HEAD
 +			dev_priv->psr.su_x_granularity =
 +				intel_dp_get_su_x_granulartiy(intel_dp);
++=======
+ 			intel_dp_get_su_granularity(intel_dp);
++>>>>>>> 0e20b769c4b3 (drm/i915/display/psr: Handle SU Y granularity)
  		}
  	}
  }
@@@ -781,19 -869,6 +831,22 @@@ static bool intel_psr2_config_valid(str
  		return false;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * HW sends SU blocks of size four scan lines, which means the starting
 +	 * X coordinate and Y granularity requirements will always be met. We
 +	 * only need to validate the SU block width is a multiple of
 +	 * x granularity.
 +	 */
 +	if (crtc_hdisplay % dev_priv->psr.su_x_granularity) {
 +		drm_dbg_kms(&dev_priv->drm,
 +			    "PSR2 not enabled, hdisplay(%d) not multiple of %d\n",
 +			    crtc_hdisplay, dev_priv->psr.su_x_granularity);
 +		return false;
 +	}
 +
++=======
++>>>>>>> 0e20b769c4b3 (drm/i915/display/psr: Handle SU Y granularity)
  	if (HAS_PSR2_SEL_FETCH(dev_priv)) {
  		if (!intel_psr2_sel_fetch_config_valid(intel_dp, crtc_state) &&
  		    !HAS_PSR_HW_TRACKING(dev_priv)) {
@@@ -803,6 -878,18 +856,21 @@@
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Wa_2209313811 */
+ 	if (!crtc_state->enable_psr2_sel_fetch &&
+ 	    IS_TGL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B1)) {
+ 		drm_dbg_kms(&dev_priv->drm, "PSR2 HW tracking is not supported this Display stepping\n");
+ 		return false;
+ 	}
+ 
+ 	if (!psr2_granularity_check(intel_dp, crtc_state)) {
+ 		drm_dbg_kms(&dev_priv->drm, "PSR2 not enabled, SU granularity not compatible\n");
+ 		return false;
+ 	}
+ 
++>>>>>>> 0e20b769c4b3 (drm/i915/display/psr: Handle SU Y granularity)
  	if (!crtc_state->enable_psr2_sel_fetch &&
  	    (crtc_hdisplay > psr_max_h || crtc_vdisplay > psr_max_v)) {
  		drm_dbg_kms(&dev_priv->drm,
* Unmerged path drivers/gpu/drm/i915/display/intel_display_types.h
* Unmerged path drivers/gpu/drm/i915/display/intel_psr.c
