sock_map: Make sock_map_prog_update() static

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Cong Wang <cong.wang@bytedance.com>
commit 4675e234b9e15159894b90ead9340e1dc202b670
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/4675e234.failed

It is only used within sock_map.c so can become static.

	Suggested-by: Jakub Sitnicki <jakub@cloudflare.com>
	Signed-off-by: Cong Wang <cong.wang@bytedance.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Jakub Sitnicki <jakub@cloudflare.com>
Link: https://lore.kernel.org/bpf/20210223184934.6054-7-xiyou.wangcong@gmail.com
(cherry picked from commit 4675e234b9e15159894b90ead9340e1dc202b670)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
diff --cc include/linux/bpf.h
index 3737afe9262e,e1e4d2f60527..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -1876,22 -1778,24 +1876,34 @@@ static inline void bpf_map_offload_map_
  }
  #endif /* CONFIG_NET && CONFIG_BPF_SYSCALL */
  
++<<<<<<< HEAD
 +#if defined(CONFIG_BPF_STREAM_PARSER)
 +int sock_map_prog_update(struct bpf_map *map, struct bpf_prog *prog,
 +			 struct bpf_prog *old, u32 which);
++=======
+ #if defined(CONFIG_INET) && defined(CONFIG_BPF_SYSCALL)
++>>>>>>> 4675e234b9e1 (sock_map: Make sock_map_prog_update() static)
  int sock_map_get_from_fd(const union bpf_attr *attr, struct bpf_prog *prog);
  int sock_map_prog_detach(const union bpf_attr *attr, enum bpf_prog_type ptype);
  int sock_map_update_elem_sys(struct bpf_map *map, void *key, void *value, u64 flags);
  void sock_map_unhash(struct sock *sk);
  void sock_map_close(struct sock *sk, long timeout);
 -
 -void bpf_sk_reuseport_detach(struct sock *sk);
 -int bpf_fd_reuseport_array_lookup_elem(struct bpf_map *map, void *key,
 -				       void *value);
 -int bpf_fd_reuseport_array_update_elem(struct bpf_map *map, void *key,
 -				       void *value, u64 map_flags);
  #else
++<<<<<<< HEAD
 +static inline int sock_map_prog_update(struct bpf_map *map,
 +				       struct bpf_prog *prog,
 +				       struct bpf_prog *old, u32 which)
 +{
 +	return -EOPNOTSUPP;
 +}
 +
++=======
+ static inline void bpf_sk_reuseport_detach(struct sock *sk)
+ {
+ }
+ 
+ #ifdef CONFIG_BPF_SYSCALL
++>>>>>>> 4675e234b9e1 (sock_map: Make sock_map_prog_update() static)
  static inline int sock_map_get_from_fd(const union bpf_attr *attr,
  				       struct bpf_prog *prog)
  {
* Unmerged path include/linux/bpf.h
diff --git a/net/core/sock_map.c b/net/core/sock_map.c
index f2963865e78e..97f694568e74 100644
--- a/net/core/sock_map.c
+++ b/net/core/sock_map.c
@@ -26,6 +26,9 @@ struct bpf_stab {
 #define SOCK_CREATE_FLAG_MASK				\
 	(BPF_F_NUMA_NODE | BPF_F_RDONLY | BPF_F_WRONLY)
 
+static int sock_map_prog_update(struct bpf_map *map, struct bpf_prog *prog,
+				struct bpf_prog *old, u32 which);
+
 static struct bpf_map *sock_map_alloc(union bpf_attr *attr)
 {
 	struct bpf_stab *stab;
@@ -1452,8 +1455,8 @@ static struct sk_psock_progs *sock_map_progs(struct bpf_map *map)
 	return NULL;
 }
 
-int sock_map_prog_update(struct bpf_map *map, struct bpf_prog *prog,
-			 struct bpf_prog *old, u32 which)
+static int sock_map_prog_update(struct bpf_map *map, struct bpf_prog *prog,
+				struct bpf_prog *old, u32 which)
 {
 	struct sk_psock_progs *progs = sock_map_progs(map);
 	struct bpf_prog **pprog;
