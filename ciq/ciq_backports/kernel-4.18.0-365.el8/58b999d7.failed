kasan: adopt KUNIT tests to SW_TAGS mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Andrey Konovalov <andreyknvl@google.com>
commit 58b999d7a22c59313e1e84832607c7a61640f4e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/58b999d7.failed

Now that we have KASAN-KUNIT tests integration, it's easy to see that
some KASAN tests are not adopted to the SW_TAGS mode and are failing.

Adjust the allocation size for kasan_memchr() and kasan_memcmp() by
roung it up to OOB_TAG_OFF so the bad access ends up in a separate
memory granule.

Add a new kmalloc_uaf_16() tests that relies on UAF, and a new
kasan_bitops_tags() test that is tailored to tag-based mode, as it's
hard to adopt the existing kmalloc_oob_16() and kasan_bitops_generic()
(renamed from kasan_bitops()) without losing the precision.

Add new kmalloc_uaf_16() and kasan_bitops_uaf() tests that rely on UAFs,
as it's hard to adopt the existing kmalloc_oob_16() and
kasan_bitops_oob() (rename from kasan_bitops()) without losing the
precision.

Disable kasan_global_oob() and kasan_alloca_oob_left/right() as SW_TAGS
mode doesn't instrument globals nor dynamic allocas.

	Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Tested-by: David Gow <davidgow@google.com>
Link: https://lkml.kernel.org/r/76eee17b6531ca8b3ca92b240cb2fd23204aaff7.1603129942.git.andreyknvl@google.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 58b999d7a22c59313e1e84832607c7a61640f4e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/test_kasan.c
diff --cc lib/test_kasan.c
index 5679dda37d78,662f862702fc..000000000000
--- a/lib/test_kasan.c
+++ b/lib/test_kasan.c
@@@ -211,21 -216,41 +211,51 @@@ static noinline void __init kmalloc_oob
  		u64 words[2];
  	} *ptr1, *ptr2;
  
++<<<<<<< HEAD
 +	pr_info("kmalloc out-of-bounds for 16-bytes access\n");
++=======
+ 	/* This test is specifically crafted for the generic mode. */
+ 	if (!IS_ENABLED(CONFIG_KASAN_GENERIC)) {
+ 		kunit_info(test, "CONFIG_KASAN_GENERIC required\n");
+ 		return;
+ 	}
+ 
++>>>>>>> 58b999d7a22c (kasan: adopt KUNIT tests to SW_TAGS mode)
  	ptr1 = kmalloc(sizeof(*ptr1) - 3, GFP_KERNEL);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr1);
 -
  	ptr2 = kmalloc(sizeof(*ptr2), GFP_KERNEL);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr2);
 -
 -	KUNIT_EXPECT_KASAN_FAIL(test, *ptr1 = *ptr2);
 +	if (!ptr1 || !ptr2) {
 +		pr_err("Allocation failed\n");
 +		kfree(ptr1);
 +		kfree(ptr2);
 +		return;
 +	}
 +	*ptr1 = *ptr2;
  	kfree(ptr1);
  	kfree(ptr2);
  }
  
++<<<<<<< HEAD
 +static noinline void __init kmalloc_oob_memset_2(void)
++=======
+ static void kmalloc_uaf_16(struct kunit *test)
+ {
+ 	struct {
+ 		u64 words[2];
+ 	} *ptr1, *ptr2;
+ 
+ 	ptr1 = kmalloc(sizeof(*ptr1), GFP_KERNEL);
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr1);
+ 
+ 	ptr2 = kmalloc(sizeof(*ptr2), GFP_KERNEL);
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr2);
+ 	kfree(ptr2);
+ 
+ 	KUNIT_EXPECT_KASAN_FAIL(test, *ptr1 = *ptr2);
+ 	kfree(ptr1);
+ }
+ 
+ static void kmalloc_oob_memset_2(struct kunit *test)
++>>>>>>> 58b999d7a22c (kasan: adopt KUNIT tests to SW_TAGS mode)
  {
  	char *ptr;
  	size_t size = 8;
@@@ -485,21 -452,16 +515,31 @@@ static noinline void __init kasan_globa
  	volatile int i = 3;
  	char *p = &global_array[ARRAY_SIZE(global_array) + i];
  
++<<<<<<< HEAD
 +	pr_info("out-of-bounds global variable\n");
 +	*(volatile char *)p;
++=======
+ 	/* Only generic mode instruments globals. */
+ 	if (!IS_ENABLED(CONFIG_KASAN_GENERIC)) {
+ 		kunit_info(test, "CONFIG_KASAN_GENERIC required");
+ 		return;
+ 	}
+ 
+ 	KUNIT_EXPECT_KASAN_FAIL(test, *(volatile char *)p);
++>>>>>>> 58b999d7a22c (kasan: adopt KUNIT tests to SW_TAGS mode)
 +}
 +
 +static noinline void __init kasan_stack_oob(void)
 +{
 +	char stack_array[10];
 +	volatile int i = OOB_TAG_OFF;
 +	char *p = &stack_array[ARRAY_SIZE(stack_array) + i];
 +
 +	pr_info("out-of-bounds on stack\n");
 +	*(volatile char *)p;
  }
  
 -static void ksize_unpoisons_memory(struct kunit *test)
 +static noinline void __init ksize_unpoisons_memory(void)
  {
  	char *ptr;
  	size_t size = 123, real_size;
@@@ -569,21 -496,41 +609,51 @@@ static noinline void __init kasan_alloc
  	char alloca_array[i];
  	char *p = alloca_array - 1;
  
++<<<<<<< HEAD
 +	pr_info("out-of-bounds to left on alloca\n");
 +	*(volatile char *)p;
++=======
+ 	/* Only generic mode instruments dynamic allocas. */
+ 	if (!IS_ENABLED(CONFIG_KASAN_GENERIC)) {
+ 		kunit_info(test, "CONFIG_KASAN_GENERIC required");
+ 		return;
+ 	}
+ 
+ 	if (!IS_ENABLED(CONFIG_KASAN_STACK)) {
+ 		kunit_info(test, "CONFIG_KASAN_STACK is not enabled");
+ 		return;
+ 	}
+ 
+ 	KUNIT_EXPECT_KASAN_FAIL(test, *(volatile char *)p);
++>>>>>>> 58b999d7a22c (kasan: adopt KUNIT tests to SW_TAGS mode)
  }
  
 -static void kasan_alloca_oob_right(struct kunit *test)
 +static noinline void __init kasan_alloca_oob_right(void)
  {
  	volatile int i = 10;
  	char alloca_array[i];
  	char *p = alloca_array + i;
  
++<<<<<<< HEAD
 +	pr_info("out-of-bounds to right on alloca\n");
 +	*(volatile char *)p;
++=======
+ 	/* Only generic mode instruments dynamic allocas. */
+ 	if (!IS_ENABLED(CONFIG_KASAN_GENERIC)) {
+ 		kunit_info(test, "CONFIG_KASAN_GENERIC required");
+ 		return;
+ 	}
+ 
+ 	if (!IS_ENABLED(CONFIG_KASAN_STACK)) {
+ 		kunit_info(test, "CONFIG_KASAN_STACK is not enabled");
+ 		return;
+ 	}
+ 
+ 	KUNIT_EXPECT_KASAN_FAIL(test, *(volatile char *)p);
++>>>>>>> 58b999d7a22c (kasan: adopt KUNIT tests to SW_TAGS mode)
  }
  
 -static void kmem_cache_double_free(struct kunit *test)
 +static noinline void __init kmem_cache_double_free(void)
  {
  	char *p;
  	size_t size = 200;
@@@ -644,12 -585,22 +714,25 @@@ static noinline void __init kasan_memch
  	char *ptr;
  	size_t size = 24;
  
++<<<<<<< HEAD
 +	pr_info("out-of-bounds in memchr\n");
++=======
+ 	/* See https://bugzilla.kernel.org/show_bug.cgi?id=206337 */
+ 	if (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT)) {
+ 		kunit_info(test,
+ 			"str* functions are not instrumented with CONFIG_AMD_MEM_ENCRYPT");
+ 		return;
+ 	}
+ 
+ 	if (OOB_TAG_OFF)
+ 		size = round_up(size, OOB_TAG_OFF);
+ 
++>>>>>>> 58b999d7a22c (kasan: adopt KUNIT tests to SW_TAGS mode)
  	ptr = kmalloc(size, GFP_KERNEL | __GFP_ZERO);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr);
 -
 -	KUNIT_EXPECT_KASAN_FAIL(test,
 -		kasan_ptr_result = memchr(ptr, '1', size + 1));
 +	if (!ptr)
 +		return;
  
 +	kasan_ptr_result = memchr(ptr, '1', size + 1);
  	kfree(ptr);
  }
  
@@@ -659,13 -610,22 +742,26 @@@ static noinline void __init kasan_memcm
  	size_t size = 24;
  	int arr[9];
  
++<<<<<<< HEAD
 +	pr_info("out-of-bounds in memcmp\n");
++=======
+ 	/* See https://bugzilla.kernel.org/show_bug.cgi?id=206337 */
+ 	if (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT)) {
+ 		kunit_info(test,
+ 			"str* functions are not instrumented with CONFIG_AMD_MEM_ENCRYPT");
+ 		return;
+ 	}
+ 
+ 	if (OOB_TAG_OFF)
+ 		size = round_up(size, OOB_TAG_OFF);
+ 
++>>>>>>> 58b999d7a22c (kasan: adopt KUNIT tests to SW_TAGS mode)
  	ptr = kmalloc(size, GFP_KERNEL | __GFP_ZERO);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr);
 -	memset(arr, 0, sizeof(arr));
 +	if (!ptr)
 +		return;
  
 -	KUNIT_EXPECT_KASAN_FAIL(test,
 -		kasan_int_result = memcmp(ptr, arr, size+1));
 +	memset(arr, 0, sizeof(arr));
 +	kasan_int_result = memcmp(ptr, arr, size + 1);
  	kfree(ptr);
  }
  
@@@ -688,95 -653,98 +784,171 @@@ static noinline void __init kasan_strin
  	 * will likely point to zeroed byte.
  	 */
  	ptr += 16;
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_ptr_result = strchr(ptr, '1'));
 +	kasan_ptr_result = strchr(ptr, '1');
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_ptr_result = strrchr(ptr, '1'));
 +	pr_info("use-after-free in strrchr\n");
 +	kasan_ptr_result = strrchr(ptr, '1');
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result = strcmp(ptr, "2"));
 +	pr_info("use-after-free in strcmp\n");
 +	kasan_int_result = strcmp(ptr, "2");
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result = strncmp(ptr, "2", 1));
 +	pr_info("use-after-free in strncmp\n");
 +	kasan_int_result = strncmp(ptr, "2", 1);
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result = strlen(ptr));
 +	pr_info("use-after-free in strlen\n");
 +	kasan_int_result = strlen(ptr);
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result = strnlen(ptr, 1));
 +	pr_info("use-after-free in strnlen\n");
 +	kasan_int_result = strnlen(ptr, 1);
  }
  
++<<<<<<< HEAD
 +static noinline void __init kasan_bitops(void)
++=======
+ static void kasan_bitops_modify(struct kunit *test, int nr, void *addr)
++>>>>>>> 58b999d7a22c (kasan: adopt KUNIT tests to SW_TAGS mode)
+ {
+ 	KUNIT_EXPECT_KASAN_FAIL(test, set_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, __set_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, clear_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, __clear_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, clear_bit_unlock(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, __clear_bit_unlock(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, change_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, __change_bit(nr, addr));
+ }
+ 
+ static void kasan_bitops_test_and_modify(struct kunit *test, int nr, void *addr)
+ {
+ 	KUNIT_EXPECT_KASAN_FAIL(test, test_and_set_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, __test_and_set_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, test_and_set_bit_lock(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, test_and_clear_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, __test_and_clear_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, test_and_change_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, __test_and_change_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result = test_bit(nr, addr));
+ 
+ #if defined(clear_bit_unlock_is_negative_byte)
+ 	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result =
+ 				clear_bit_unlock_is_negative_byte(nr, addr));
+ #endif
+ }
+ 
+ static void kasan_bitops_generic(struct kunit *test)
  {
+ 	long *bits;
+ 
+ 	/* This test is specifically crafted for the generic mode. */
+ 	if (!IS_ENABLED(CONFIG_KASAN_GENERIC)) {
+ 		kunit_info(test, "CONFIG_KASAN_GENERIC required\n");
+ 		return;
+ 	}
+ 
  	/*
  	 * Allocate 1 more byte, which causes kzalloc to round up to 16-bytes;
  	 * this way we do not actually corrupt other memory.
  	 */
++<<<<<<< HEAD
 +	long *bits = kzalloc(sizeof(*bits) + 1, GFP_KERNEL);
 +	if (!bits)
 +		return;
++=======
+ 	bits = kzalloc(sizeof(*bits) + 1, GFP_KERNEL);
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, bits);
++>>>>>>> 58b999d7a22c (kasan: adopt KUNIT tests to SW_TAGS mode)
  
  	/*
  	 * Below calls try to access bit within allocated memory; however, the
  	 * below accesses are still out-of-bounds, since bitops are defined to
  	 * operate on the whole long the bit is in.
  	 */
++<<<<<<< HEAD
 +	pr_info("out-of-bounds in set_bit\n");
 +	set_bit(BITS_PER_LONG, bits);
 +
 +	pr_info("out-of-bounds in __set_bit\n");
 +	__set_bit(BITS_PER_LONG, bits);
 +
 +	pr_info("out-of-bounds in clear_bit\n");
 +	clear_bit(BITS_PER_LONG, bits);
 +
 +	pr_info("out-of-bounds in __clear_bit\n");
 +	__clear_bit(BITS_PER_LONG, bits);
 +
 +	pr_info("out-of-bounds in clear_bit_unlock\n");
 +	clear_bit_unlock(BITS_PER_LONG, bits);
 +
 +	pr_info("out-of-bounds in __clear_bit_unlock\n");
 +	__clear_bit_unlock(BITS_PER_LONG, bits);
 +
 +	pr_info("out-of-bounds in change_bit\n");
 +	change_bit(BITS_PER_LONG, bits);
 +
 +	pr_info("out-of-bounds in __change_bit\n");
 +	__change_bit(BITS_PER_LONG, bits);
++=======
+ 	kasan_bitops_modify(test, BITS_PER_LONG, bits);
++>>>>>>> 58b999d7a22c (kasan: adopt KUNIT tests to SW_TAGS mode)
  
  	/*
  	 * Below calls try to access bit beyond allocated memory.
  	 */
++<<<<<<< HEAD
 +	pr_info("out-of-bounds in test_and_set_bit\n");
 +	test_and_set_bit(BITS_PER_LONG + BITS_PER_BYTE, bits);
 +
 +	pr_info("out-of-bounds in __test_and_set_bit\n");
 +	__test_and_set_bit(BITS_PER_LONG + BITS_PER_BYTE, bits);
 +
 +	pr_info("out-of-bounds in test_and_set_bit_lock\n");
 +	test_and_set_bit_lock(BITS_PER_LONG + BITS_PER_BYTE, bits);
 +
 +	pr_info("out-of-bounds in test_and_clear_bit\n");
 +	test_and_clear_bit(BITS_PER_LONG + BITS_PER_BYTE, bits);
 +
 +	pr_info("out-of-bounds in __test_and_clear_bit\n");
 +	__test_and_clear_bit(BITS_PER_LONG + BITS_PER_BYTE, bits);
 +
 +	pr_info("out-of-bounds in test_and_change_bit\n");
 +	test_and_change_bit(BITS_PER_LONG + BITS_PER_BYTE, bits);
 +
 +	pr_info("out-of-bounds in __test_and_change_bit\n");
 +	__test_and_change_bit(BITS_PER_LONG + BITS_PER_BYTE, bits);
 +
 +	pr_info("out-of-bounds in test_bit\n");
 +	kasan_int_result = test_bit(BITS_PER_LONG + BITS_PER_BYTE, bits);
 +
 +#if defined(clear_bit_unlock_is_negative_byte)
 +	pr_info("out-of-bounds in clear_bit_unlock_is_negative_byte\n");
 +	kasan_int_result = clear_bit_unlock_is_negative_byte(BITS_PER_LONG +
 +		BITS_PER_BYTE, bits);
 +#endif
++=======
+ 	kasan_bitops_test_and_modify(test, BITS_PER_LONG + BITS_PER_BYTE, bits);
+ 
+ 	kfree(bits);
+ }
+ 
+ static void kasan_bitops_tags(struct kunit *test)
+ {
+ 	long *bits;
+ 
+ 	/* This test is specifically crafted for the tag-based mode. */
+ 	if (IS_ENABLED(CONFIG_KASAN_GENERIC)) {
+ 		kunit_info(test, "CONFIG_KASAN_SW_TAGS required\n");
+ 		return;
+ 	}
+ 
+ 	/* Allocation size will be rounded to up granule size, which is 16. */
+ 	bits = kzalloc(sizeof(*bits), GFP_KERNEL);
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, bits);
+ 
+ 	/* Do the accesses past the 16 allocated bytes. */
+ 	kasan_bitops_modify(test, BITS_PER_LONG, &bits[1]);
+ 	kasan_bitops_test_and_modify(test, BITS_PER_LONG + BITS_PER_BYTE, &bits[1]);
+ 
++>>>>>>> 58b999d7a22c (kasan: adopt KUNIT tests to SW_TAGS mode)
  	kfree(bits);
  }
  
@@@ -808,100 -774,61 +980,144 @@@ static noinline void __init vmalloc_oob
  	 * The MMU will catch that and crash us.
  	 */
  	area = vmalloc(3000);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, area);
 +	if (!area) {
 +		pr_err("Allocation failed\n");
 +		return;
 +	}
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, ((volatile char *)area)[3100]);
 +	((volatile char *)area)[3100];
  	vfree(area);
  }
 +#else
 +static void __init vmalloc_oob(void) {}
 +#endif
  
++<<<<<<< HEAD
 +static struct kasan_rcu_info {
 +	int i;
 +	struct rcu_head rcu;
 +} *global_rcu_ptr;
++=======
+ static struct kunit_case kasan_kunit_test_cases[] = {
+ 	KUNIT_CASE(kmalloc_oob_right),
+ 	KUNIT_CASE(kmalloc_oob_left),
+ 	KUNIT_CASE(kmalloc_node_oob_right),
+ 	KUNIT_CASE(kmalloc_pagealloc_oob_right),
+ 	KUNIT_CASE(kmalloc_pagealloc_uaf),
+ 	KUNIT_CASE(kmalloc_pagealloc_invalid_free),
+ 	KUNIT_CASE(kmalloc_large_oob_right),
+ 	KUNIT_CASE(kmalloc_oob_krealloc_more),
+ 	KUNIT_CASE(kmalloc_oob_krealloc_less),
+ 	KUNIT_CASE(kmalloc_oob_16),
+ 	KUNIT_CASE(kmalloc_uaf_16),
+ 	KUNIT_CASE(kmalloc_oob_in_memset),
+ 	KUNIT_CASE(kmalloc_oob_memset_2),
+ 	KUNIT_CASE(kmalloc_oob_memset_4),
+ 	KUNIT_CASE(kmalloc_oob_memset_8),
+ 	KUNIT_CASE(kmalloc_oob_memset_16),
+ 	KUNIT_CASE(kmalloc_memmove_invalid_size),
+ 	KUNIT_CASE(kmalloc_uaf),
+ 	KUNIT_CASE(kmalloc_uaf_memset),
+ 	KUNIT_CASE(kmalloc_uaf2),
+ 	KUNIT_CASE(kfree_via_page),
+ 	KUNIT_CASE(kfree_via_phys),
+ 	KUNIT_CASE(kmem_cache_oob),
+ 	KUNIT_CASE(memcg_accounted_kmem_cache),
+ 	KUNIT_CASE(kasan_global_oob),
+ 	KUNIT_CASE(kasan_stack_oob),
+ 	KUNIT_CASE(kasan_alloca_oob_left),
+ 	KUNIT_CASE(kasan_alloca_oob_right),
+ 	KUNIT_CASE(ksize_unpoisons_memory),
+ 	KUNIT_CASE(kmem_cache_double_free),
+ 	KUNIT_CASE(kmem_cache_invalid_free),
+ 	KUNIT_CASE(kasan_memchr),
+ 	KUNIT_CASE(kasan_memcmp),
+ 	KUNIT_CASE(kasan_strings),
+ 	KUNIT_CASE(kasan_bitops_generic),
+ 	KUNIT_CASE(kasan_bitops_tags),
+ 	KUNIT_CASE(kmalloc_double_kzfree),
+ 	KUNIT_CASE(vmalloc_oob),
+ 	{}
+ };
++>>>>>>> 58b999d7a22c (kasan: adopt KUNIT tests to SW_TAGS mode)
  
 -static struct kunit_suite kasan_kunit_test_suite = {
 -	.name = "kasan",
 -	.init = kasan_test_init,
 -	.test_cases = kasan_kunit_test_cases,
 -	.exit = kasan_test_exit,
 -};
 +static noinline void __init kasan_rcu_reclaim(struct rcu_head *rp)
 +{
 +	struct kasan_rcu_info *fp = container_of(rp,
 +						struct kasan_rcu_info, rcu);
  
 -kunit_test_suite(kasan_kunit_test_suite);
 +	kfree(fp);
 +	fp->i = 1;
 +}
 +
 +static noinline void __init kasan_rcu_uaf(void)
 +{
 +	struct kasan_rcu_info *ptr;
 +
 +	pr_info("use-after-free in kasan_rcu_reclaim\n");
 +	ptr = kmalloc(sizeof(struct kasan_rcu_info), GFP_KERNEL);
 +	if (!ptr) {
 +		pr_err("Allocation failed\n");
 +		return;
 +	}
 +
 +	global_rcu_ptr = rcu_dereference_protected(ptr, NULL);
 +	call_rcu(&global_rcu_ptr->rcu, kasan_rcu_reclaim);
 +}
 +
 +static int __init kmalloc_tests_init(void)
 +{
 +	/*
 +	 * Temporarily enable multi-shot mode. Otherwise, we'd only get a
 +	 * report for the first case.
 +	 */
 +	bool multishot = kasan_save_enable_multi_shot();
 +
 +	kmalloc_oob_right();
 +	kmalloc_oob_left();
 +	kmalloc_node_oob_right();
 +#ifdef CONFIG_SLUB
 +	kmalloc_pagealloc_oob_right();
 +	kmalloc_pagealloc_uaf();
 +	kmalloc_pagealloc_invalid_free();
 +#endif
 +	kmalloc_large_oob_right();
 +	kmalloc_oob_krealloc_more();
 +	kmalloc_oob_krealloc_less();
 +	kmalloc_oob_16();
 +	kmalloc_oob_in_memset();
 +	kmalloc_oob_memset_2();
 +	kmalloc_oob_memset_4();
 +	kmalloc_oob_memset_8();
 +	kmalloc_oob_memset_16();
 +	kmalloc_memmove_invalid_size();
 +	kmalloc_uaf();
 +	kmalloc_uaf_memset();
 +	kmalloc_uaf2();
 +	kfree_via_page();
 +	kfree_via_phys();
 +	kmem_cache_oob();
 +	memcg_accounted_kmem_cache();
 +	kasan_stack_oob();
 +	kasan_global_oob();
 +	kasan_alloca_oob_left();
 +	kasan_alloca_oob_right();
 +	ksize_unpoisons_memory();
 +	copy_user_test();
 +	kmem_cache_double_free();
 +	kmem_cache_invalid_free();
 +	kasan_memchr();
 +	kasan_memcmp();
 +	kasan_strings();
 +	kasan_bitops();
 +	kmalloc_double_kzfree();
 +	vmalloc_oob();
 +	kasan_rcu_uaf();
 +
 +	kasan_restore_multi_shot(multishot);
 +
 +	return -EAGAIN;
 +}
  
 +module_init(kmalloc_tests_init);
  MODULE_LICENSE("GPL");
* Unmerged path lib/test_kasan.c
