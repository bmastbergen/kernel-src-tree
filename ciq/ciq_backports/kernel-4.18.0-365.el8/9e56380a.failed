media: uvcvideo: Rename debug functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Joe Perches <joe@perches.com>
commit 9e56380ae62543fc2043715050b80d494b2b1553
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/9e56380a.failed

trace isn't a good name as it's not a trace mechanism, it is a
typical debug mechanism.

Rename uvc_trace/uvc_trace_cont macros to uvc_dbg/uvc_dbg_cont.
Rename uvc_trace_param to uvc_dbg_param
Rename UVC_TRACE_<FOO> defines to UVC_DBG_<FOO>
Use ## concatenation in uvc_dbg macros to avoid overly long and
repetitive UVC_DBG uses

	Signed-off-by: Joe Perches <joe@perches.com>
	Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
(cherry picked from commit 9e56380ae62543fc2043715050b80d494b2b1553)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/usb/uvc/uvc_ctrl.c
#	drivers/media/usb/uvc/uvc_driver.c
#	drivers/media/usb/uvc/uvc_isight.c
#	drivers/media/usb/uvc/uvc_queue.c
#	drivers/media/usb/uvc/uvc_status.c
#	drivers/media/usb/uvc/uvc_v4l2.c
#	drivers/media/usb/uvc/uvc_video.c
#	drivers/media/usb/uvc/uvcvideo.h
diff --cc drivers/media/usb/uvc/uvc_ctrl.c
index 58ad63751baa,b3dde98499f4..000000000000
--- a/drivers/media/usb/uvc/uvc_ctrl.c
+++ b/drivers/media/usb/uvc/uvc_ctrl.c
@@@ -906,8 -906,8 +906,13 @@@ static struct uvc_control *uvc_find_con
  	}
  
  	if (ctrl == NULL && !next)
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_CONTROL, "Control 0x%08x not found.\n",
 +				v4l2_id);
++=======
+ 		uvc_dbg(chain->dev, CONTROL, "Control 0x%08x not found\n",
+ 			v4l2_id);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	return ctrl;
  }
@@@ -1800,9 -1800,9 +1805,15 @@@ static int uvc_ctrl_fill_xu_info(struc
  	ret = uvc_query_ctrl(dev, UVC_GET_LEN, ctrl->entity->id, dev->intfnum,
  			     info->selector, data, 2);
  	if (ret < 0) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_CONTROL,
 +			  "GET_LEN failed on control %pUl/%u (%d).\n",
 +			   info->entity, info->selector, ret);
++=======
+ 		uvc_dbg(dev, CONTROL,
+ 			"GET_LEN failed on control %pUl/%u (%d)\n",
+ 			info->entity, info->selector, ret);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		goto done;
  	}
  
@@@ -1813,20 -1813,20 +1824,35 @@@
  
  	ret = uvc_ctrl_get_flags(dev, ctrl, info);
  	if (ret < 0) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_CONTROL,
 +			  "Failed to get flags for control %pUl/%u (%d).\n",
 +			  info->entity, info->selector, ret);
++=======
+ 		uvc_dbg(dev, CONTROL,
+ 			"Failed to get flags for control %pUl/%u (%d)\n",
+ 			info->entity, info->selector, ret);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		goto done;
  	}
  
  	uvc_ctrl_fixup_xu_info(dev, ctrl, info);
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_CONTROL, "XU control %pUl/%u queried: len %u, "
 +		  "flags { get %u set %u auto %u }.\n",
 +		  info->entity, info->selector, info->size,
 +		  (info->flags & UVC_CTRL_FLAG_GET_CUR) ? 1 : 0,
 +		  (info->flags & UVC_CTRL_FLAG_SET_CUR) ? 1 : 0,
 +		  (info->flags & UVC_CTRL_FLAG_AUTO_UPDATE) ? 1 : 0);
++=======
+ 	uvc_dbg(dev, CONTROL,
+ 		"XU control %pUl/%u queried: len %u, flags { get %u set %u auto %u }\n",
+ 		info->entity, info->selector, info->size,
+ 		(info->flags & UVC_CTRL_FLAG_GET_CUR) ? 1 : 0,
+ 		(info->flags & UVC_CTRL_FLAG_SET_CUR) ? 1 : 0,
+ 		(info->flags & UVC_CTRL_FLAG_AUTO_UPDATE) ? 1 : 0);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  done:
  	kfree(data);
@@@ -1851,9 -1851,10 +1877,16 @@@ static int uvc_ctrl_init_xu_ctrl(struc
  
  	ret = uvc_ctrl_add_info(dev, ctrl, &info);
  	if (ret < 0)
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_CONTROL, "Failed to initialize control "
 +			  "%pUl/%u on device %s entity %u\n", info.entity,
 +			  info.selector, dev->udev->devpath, ctrl->entity->id);
++=======
+ 		uvc_dbg(dev, CONTROL,
+ 			"Failed to initialize control %pUl/%u on device %s entity %u\n",
+ 			info.entity, info.selector, dev->udev->devpath,
+ 			ctrl->entity->id);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	return ret;
  }
@@@ -1881,7 -1882,7 +1914,11 @@@ int uvc_xu_ctrl_query(struct uvc_video_
  	}
  
  	if (!found) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_CONTROL, "Extension unit %u not found.\n",
++=======
+ 		uvc_dbg(chain->dev, CONTROL, "Extension unit %u not found\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			xqry->unit);
  		return -ENOENT;
  	}
@@@ -1897,7 -1898,7 +1934,11 @@@
  	}
  
  	if (!found) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_CONTROL, "Control %pUl/%u not found.\n",
++=======
+ 		uvc_dbg(chain->dev, CONTROL, "Control %pUl/%u not found\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			entity->guid, xqry->selector);
  		return -ENOENT;
  	}
@@@ -2046,9 -2047,9 +2087,15 @@@ static int uvc_ctrl_add_info(struct uvc
  
  	ctrl->initialized = 1;
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_CONTROL, "Added control %pUl/%u to device %s "
 +		"entity %u\n", ctrl->info.entity, ctrl->info.selector,
 +		dev->udev->devpath, ctrl->entity->id);
++=======
+ 	uvc_dbg(dev, CONTROL, "Added control %pUl/%u to device %s entity %u\n",
+ 		ctrl->info.entity, ctrl->info.selector, dev->udev->devpath,
+ 		ctrl->entity->id);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	return 0;
  }
@@@ -2085,8 -2086,7 +2132,12 @@@ static int __uvc_ctrl_add_mapping(struc
  		map->set = uvc_set_le_value;
  
  	list_add_tail(&map->list, &ctrl->info.mappings);
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_CONTROL,
 +		"Adding mapping '%s' to control %pUl/%u.\n",
++=======
+ 	uvc_dbg(dev, CONTROL, "Adding mapping '%s' to control %pUl/%u\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		map->name, ctrl->info.entity, ctrl->info.selector);
  
  	return 0;
@@@ -2103,9 -2103,9 +2154,15 @@@ int uvc_ctrl_add_mapping(struct uvc_vid
  	int ret;
  
  	if (mapping->id & ~V4L2_CTRL_ID_MASK) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_CONTROL, "Can't add mapping '%s', control "
 +			"id 0x%08x is invalid.\n", mapping->name,
 +			mapping->id);
++=======
+ 		uvc_dbg(dev, CONTROL,
+ 			"Can't add mapping '%s', control id 0x%08x is invalid\n",
+ 			mapping->name, mapping->id);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		return -EINVAL;
  	}
  
@@@ -2150,8 -2150,8 +2207,13 @@@
  
  	list_for_each_entry(map, &ctrl->info.mappings, list) {
  		if (mapping->id == map->id) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_CONTROL, "Can't add mapping '%s', "
 +				"control id 0x%08x already exists.\n",
++=======
+ 			uvc_dbg(dev, CONTROL,
+ 				"Can't add mapping '%s', control id 0x%08x already exists\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  				mapping->name, mapping->id);
  			ret = -EEXIST;
  			goto done;
@@@ -2161,9 -2161,9 +2223,15 @@@
  	/* Prevent excess memory consumption */
  	if (atomic_inc_return(&dev->nmappings) > UVC_MAX_CONTROL_MAPPINGS) {
  		atomic_dec(&dev->nmappings);
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_CONTROL, "Can't add mapping '%s', maximum "
 +			"mappings count (%u) exceeded.\n", mapping->name,
 +			UVC_MAX_CONTROL_MAPPINGS);
++=======
+ 		uvc_dbg(dev, CONTROL,
+ 			"Can't add mapping '%s', maximum mappings count (%u) exceeded\n",
+ 			mapping->name, UVC_MAX_CONTROL_MAPPINGS);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		ret = -ENOMEM;
  		goto done;
  	}
@@@ -2232,8 -2232,9 +2300,14 @@@ static void uvc_ctrl_prune_entity(struc
  		    !uvc_test_bit(controls, blacklist[i].index))
  			continue;
  
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_CONTROL, "%u/%u control is black listed, "
 +			"removing it.\n", entity->id, blacklist[i].index);
++=======
+ 		uvc_dbg(dev, CONTROL,
+ 			"%u/%u control is black listed, removing it\n",
+ 			entity->id, blacklist[i].index);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  		uvc_clear_bit(controls, blacklist[i].index);
  	}
diff --cc drivers/media/usb/uvc/uvc_driver.c
index 1e641fa437fc,1abc122a0977..000000000000
--- a/drivers/media/usb/uvc/uvc_driver.c
+++ b/drivers/media/usb/uvc/uvc_driver.c
@@@ -520,10 -520,10 +520,17 @@@ static int uvc_parse_format(struct uvc_
  	case UVC_VS_FORMAT_FRAME_BASED:
  		n = buffer[2] == UVC_VS_FORMAT_UNCOMPRESSED ? 27 : 28;
  		if (buflen < n) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 +			       "interface %d FORMAT error\n",
 +			       dev->udev->devnum,
 +			       alts->desc.bInterfaceNumber);
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videostreaming interface %d FORMAT error\n",
+ 				dev->udev->devnum,
+ 				alts->desc.bInterfaceNumber);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			return -EINVAL;
  		}
  
@@@ -568,10 -584,10 +575,17 @@@
  
  	case UVC_VS_FORMAT_MJPEG:
  		if (buflen < 11) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 +			       "interface %d FORMAT error\n",
 +			       dev->udev->devnum,
 +			       alts->desc.bInterfaceNumber);
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videostreaming interface %d FORMAT error\n",
+ 				dev->udev->devnum,
+ 				alts->desc.bInterfaceNumber);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			return -EINVAL;
  		}
  
@@@ -584,10 -600,10 +598,17 @@@
  
  	case UVC_VS_FORMAT_DV:
  		if (buflen < 9) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 +			       "interface %d FORMAT error\n",
 +			       dev->udev->devnum,
 +			       alts->desc.bInterfaceNumber);
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videostreaming interface %d FORMAT error\n",
+ 				dev->udev->devnum,
+ 				alts->desc.bInterfaceNumber);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			return -EINVAL;
  		}
  
@@@ -602,10 -618,10 +623,17 @@@
  			strscpy(format->name, "HD-DV", sizeof(format->name));
  			break;
  		default:
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 +			       "interface %d: unknown DV format %u\n",
 +			       dev->udev->devnum,
 +			       alts->desc.bInterfaceNumber, buffer[8]);
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videostreaming interface %d: unknown DV format %u\n",
+ 				dev->udev->devnum,
+ 				alts->desc.bInterfaceNumber, buffer[8]);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			return -EINVAL;
  		}
  
@@@ -631,14 -647,14 +659,25 @@@
  	case UVC_VS_FORMAT_STREAM_BASED:
  		/* Not supported yet. */
  	default:
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 +		       "interface %d unsupported format %u\n",
 +		       dev->udev->devnum, alts->desc.bInterfaceNumber,
 +		       buffer[2]);
 +		return -EINVAL;
 +	}
 +
 +	uvc_trace(UVC_TRACE_DESCR, "Found format %s.\n", format->name);
++=======
+ 		uvc_dbg(dev, DESCR,
+ 			"device %d videostreaming interface %d unsupported format %u\n",
+ 			dev->udev->devnum, alts->desc.bInterfaceNumber,
+ 			buffer[2]);
+ 		return -EINVAL;
+ 	}
+ 
+ 	uvc_dbg(dev, DESCR, "Found format %s\n", format->name);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	buflen -= buffer[0];
  	buffer += buffer[0];
@@@ -657,9 -673,10 +696,16 @@@
  		n = n ? n : 3;
  
  		if (buflen < 26 + 4*n) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 +			       "interface %d FRAME error\n", dev->udev->devnum,
 +			       alts->desc.bInterfaceNumber);
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videostreaming interface %d FRAME error\n",
+ 				dev->udev->devnum,
+ 				alts->desc.bInterfaceNumber);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			return -EINVAL;
  		}
  
@@@ -721,10 -738,10 +767,17 @@@
  				frame->dwDefaultFrameInterval;
  		}
  
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_DESCR, "- %ux%u (%u.%u fps)\n",
 +			frame->wWidth, frame->wHeight,
 +			10000000/frame->dwDefaultFrameInterval,
 +			(100000000/frame->dwDefaultFrameInterval)%10);
++=======
+ 		uvc_dbg(dev, DESCR, "- %ux%u (%u.%u fps)\n",
+ 			frame->wWidth, frame->wHeight,
+ 			10000000 / frame->dwDefaultFrameInterval,
+ 			(100000000 / frame->dwDefaultFrameInterval) % 10);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  		format->nframes++;
  		buflen -= buffer[0];
@@@ -740,10 -757,10 +793,17 @@@
  	if (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE &&
  	    buffer[2] == UVC_VS_COLORFORMAT) {
  		if (buflen < 6) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 +			       "interface %d COLORFORMAT error\n",
 +			       dev->udev->devnum,
 +			       alts->desc.bInterfaceNumber);
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videostreaming interface %d COLORFORMAT error\n",
+ 				dev->udev->devnum,
+ 				alts->desc.bInterfaceNumber);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			return -EINVAL;
  		}
  
@@@ -775,15 -792,17 +835,27 @@@ static int uvc_parse_streaming(struct u
  
  	if (intf->cur_altsetting->desc.bInterfaceSubClass
  		!= UVC_SC_VIDEOSTREAMING) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_DESCR, "device %d interface %d isn't a "
 +			"video streaming interface\n", dev->udev->devnum,
++=======
+ 		uvc_dbg(dev, DESCR,
+ 			"device %d interface %d isn't a video streaming interface\n",
+ 			dev->udev->devnum,
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			intf->altsetting[0].desc.bInterfaceNumber);
  		return -EINVAL;
  	}
  
  	if (usb_driver_claim_interface(&uvc_driver.driver, intf, dev)) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_DESCR, "device %d interface %d is already "
 +			"claimed\n", dev->udev->devnum,
++=======
+ 		uvc_dbg(dev, DESCR,
+ 			"device %d interface %d is already claimed\n",
+ 			dev->udev->devnum,
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			intf->altsetting[0].desc.bInterfaceNumber);
  		return -EINVAL;
  	}
@@@ -806,8 -825,9 +878,14 @@@
  
  			if (ep->extralen > 2 &&
  			    ep->extra[1] == USB_DT_CS_INTERFACE) {
++<<<<<<< HEAD
 +				uvc_trace(UVC_TRACE_DESCR, "trying extra data "
 +					"from endpoint %u.\n", i);
++=======
+ 				uvc_dbg(dev, DESCR,
+ 					"trying extra data from endpoint %u\n",
+ 					i);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  				buffer = alts->endpoint[i].extra;
  				buflen = alts->endpoint[i].extralen;
  				break;
@@@ -822,8 -842,8 +900,13 @@@
  	}
  
  	if (buflen <= 2) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_DESCR, "no class-specific streaming "
 +			"interface descriptors found.\n");
++=======
+ 		uvc_dbg(dev, DESCR,
+ 			"no class-specific streaming interface descriptors found\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		goto error;
  	}
  
@@@ -840,9 -860,9 +923,15 @@@
  		break;
  
  	default:
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming interface "
 +			"%d HEADER descriptor not found.\n", dev->udev->devnum,
 +			alts->desc.bInterfaceNumber);
++=======
+ 		uvc_dbg(dev, DESCR,
+ 			"device %d videostreaming interface %d HEADER descriptor not found\n",
+ 			dev->udev->devnum, alts->desc.bInterfaceNumber);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		goto error;
  	}
  
@@@ -850,8 -870,8 +939,13 @@@
  	n = buflen >= size ? buffer[size-1] : 0;
  
  	if (buflen < size + p*n) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 +			"interface %d HEADER descriptor is invalid.\n",
++=======
+ 		uvc_dbg(dev, DESCR,
+ 			"device %d videostreaming interface %d HEADER descriptor is invalid\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			dev->udev->devnum, alts->desc.bInterfaceNumber);
  		goto error;
  	}
@@@ -902,8 -922,8 +996,13 @@@
  
  		case UVC_VS_FORMAT_MPEG2TS:
  		case UVC_VS_FORMAT_STREAM_BASED:
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 +				"interface %d FORMAT %u is not supported.\n",
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videostreaming interface %d FORMAT %u is not supported\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  				dev->udev->devnum,
  				alts->desc.bInterfaceNumber, _buffer[2]);
  			break;
@@@ -927,8 -947,8 +1026,13 @@@
  	}
  
  	if (nformats == 0) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming interface "
 +			"%d has no supported formats defined.\n",
++=======
+ 		uvc_dbg(dev, DESCR,
+ 			"device %d videostreaming interface %d has no supported formats defined\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			dev->udev->devnum, alts->desc.bInterfaceNumber);
  		goto error;
  	}
@@@ -976,8 -996,8 +1080,13 @@@
  	}
  
  	if (buflen)
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming interface "
 +			"%d has %u bytes of trailing descriptor garbage.\n",
++=======
+ 		uvc_dbg(dev, DESCR,
+ 			"device %d videostreaming interface %d has %u bytes of trailing descriptor garbage\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			dev->udev->devnum, alts->desc.bInterfaceNumber, buflen);
  
  	/* Parse the alternate settings to find the maximum bandwidth. */
@@@ -1111,8 -1131,8 +1220,13 @@@ static int uvc_parse_vendor_control(str
  		n = buflen >= 25 + p ? buffer[22+p] : 0;
  
  		if (buflen < 25 + p + 2*n) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "
 +				"interface %d EXTENSION_UNIT error\n",
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videocontrol interface %d EXTENSION_UNIT error\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  				udev->devnum, alts->desc.bInterfaceNumber);
  			break;
  		}
@@@ -1160,9 -1180,9 +1274,15 @@@ static int uvc_parse_standard_control(s
  		n = buflen >= 12 ? buffer[11] : 0;
  
  		if (buflen < 12 + n) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "
 +				"interface %d HEADER error\n", udev->devnum,
 +				alts->desc.bInterfaceNumber);
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videocontrol interface %d HEADER error\n",
+ 				udev->devnum, alts->desc.bInterfaceNumber);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			return -EINVAL;
  		}
  
@@@ -1173,8 -1193,8 +1293,13 @@@
  		for (i = 0; i < n; ++i) {
  			intf = usb_ifnum_to_if(udev, buffer[12+i]);
  			if (intf == NULL) {
++<<<<<<< HEAD
 +				uvc_trace(UVC_TRACE_DESCR, "device %d "
 +					"interface %d doesn't exists\n",
++=======
+ 				uvc_dbg(dev, DESCR,
+ 					"device %d interface %d doesn't exists\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  					udev->devnum, i);
  				continue;
  			}
@@@ -1185,8 -1205,8 +1310,13 @@@
  
  	case UVC_VC_INPUT_TERMINAL:
  		if (buflen < 8) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "
 +				"interface %d INPUT_TERMINAL error\n",
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videocontrol interface %d INPUT_TERMINAL error\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  				udev->devnum, alts->desc.bInterfaceNumber);
  			return -EINVAL;
  		}
@@@ -1204,10 -1224,9 +1334,16 @@@
  		 */
  		type = get_unaligned_le16(&buffer[4]);
  		if ((type & 0x7f00) == 0 || (type & 0x8000) != 0) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "
 +				"interface %d INPUT_TERMINAL %d has invalid "
 +				"type 0x%04x, skipping\n", udev->devnum,
 +				alts->desc.bInterfaceNumber,
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videocontrol interface %d INPUT_TERMINAL %d has invalid type 0x%04x, skipping\n",
+ 				udev->devnum, alts->desc.bInterfaceNumber,
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  				buffer[3], type);
  			return 0;
  		}
@@@ -1227,8 -1246,8 +1363,13 @@@
  		}
  
  		if (buflen < len + n + p) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "
 +				"interface %d INPUT_TERMINAL error\n",
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videocontrol interface %d INPUT_TERMINAL error\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  				udev->devnum, alts->desc.bInterfaceNumber);
  			return -EINVAL;
  		}
@@@ -1274,8 -1293,8 +1415,13 @@@
  
  	case UVC_VC_OUTPUT_TERMINAL:
  		if (buflen < 9) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "
 +				"interface %d OUTPUT_TERMINAL error\n",
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videocontrol interface %d OUTPUT_TERMINAL error\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  				udev->devnum, alts->desc.bInterfaceNumber);
  			return -EINVAL;
  		}
@@@ -1285,10 -1304,10 +1431,17 @@@
  		 */
  		type = get_unaligned_le16(&buffer[4]);
  		if ((type & 0xff00) == 0) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "
 +				"interface %d OUTPUT_TERMINAL %d has invalid "
 +				"type 0x%04x, skipping\n", udev->devnum,
 +				alts->desc.bInterfaceNumber, buffer[3], type);
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videocontrol interface %d OUTPUT_TERMINAL %d has invalid type 0x%04x, skipping\n",
+ 				udev->devnum, alts->desc.bInterfaceNumber,
+ 				buffer[3], type);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			return 0;
  		}
  
@@@ -1312,8 -1331,8 +1465,13 @@@
  		p = buflen >= 5 ? buffer[4] : 0;
  
  		if (buflen < 5 || buflen < 6 + p) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "
 +				"interface %d SELECTOR_UNIT error\n",
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videocontrol interface %d SELECTOR_UNIT error\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  				udev->devnum, alts->desc.bInterfaceNumber);
  			return -EINVAL;
  		}
@@@ -1338,8 -1357,8 +1496,13 @@@
  		p = dev->uvc_version >= 0x0110 ? 10 : 9;
  
  		if (buflen < p + n) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "
 +				"interface %d PROCESSING_UNIT error\n",
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videocontrol interface %d PROCESSING_UNIT error\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  				udev->devnum, alts->desc.bInterfaceNumber);
  			return -EINVAL;
  		}
@@@ -1371,8 -1390,8 +1534,13 @@@
  		n = buflen >= 24 + p ? buffer[22+p] : 0;
  
  		if (buflen < 24 + p + n) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "
 +				"interface %d EXTENSION_UNIT error\n",
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"device %d videocontrol interface %d EXTENSION_UNIT error\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  				udev->devnum, alts->desc.bInterfaceNumber);
  			return -EINVAL;
  		}
@@@ -1398,8 -1417,9 +1566,14 @@@
  		break;
  
  	default:
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_DESCR, "Found an unknown CS_INTERFACE "
 +			"descriptor (%u)\n", buffer[2]);
++=======
+ 		uvc_dbg(dev, DESCR,
+ 			"Found an unknown CS_INTERFACE descriptor (%u)\n",
+ 			buffer[2]);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		break;
  	}
  
@@@ -1444,8 -1464,9 +1618,14 @@@ next_descriptor
  		if (usb_endpoint_is_int_in(desc) &&
  		    le16_to_cpu(desc->wMaxPacketSize) >= 8 &&
  		    desc->bInterval != 0) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "Found a Status endpoint "
 +				"(addr %02x).\n", desc->bEndpointAddress);
++=======
+ 			uvc_dbg(dev, DESCR,
+ 				"Found a Status endpoint (addr %02x)\n",
+ 				desc->bEndpointAddress);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			dev->int_ep = ep;
  		}
  	}
@@@ -1590,24 -1611,23 +1770,41 @@@ static int uvc_scan_chain_entity(struc
  {
  	switch (UVC_ENTITY_TYPE(entity)) {
  	case UVC_VC_EXTENSION_UNIT:
++<<<<<<< HEAD
 +		if (uvc_trace_param & UVC_TRACE_PROBE)
 +			printk(KERN_CONT " <- XU %d", entity->id);
 +
 +		if (entity->bNrInPins != 1) {
 +			uvc_trace(UVC_TRACE_DESCR, "Extension unit %d has more "
 +				"than 1 input pin.\n", entity->id);
++=======
+ 		uvc_dbg_cont(PROBE, " <- XU %d", entity->id);
+ 
+ 		if (entity->bNrInPins != 1) {
+ 			uvc_dbg(chain->dev, DESCR,
+ 				"Extension unit %d has more than 1 input pin\n",
+ 				entity->id);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			return -1;
  		}
  
  		break;
  
  	case UVC_VC_PROCESSING_UNIT:
++<<<<<<< HEAD
 +		if (uvc_trace_param & UVC_TRACE_PROBE)
 +			printk(KERN_CONT " <- PU %d", entity->id);
 +
 +		if (chain->processing != NULL) {
 +			uvc_trace(UVC_TRACE_DESCR, "Found multiple "
 +				"Processing Units in chain.\n");
++=======
+ 		uvc_dbg_cont(PROBE, " <- PU %d", entity->id);
+ 
+ 		if (chain->processing != NULL) {
+ 			uvc_dbg(chain->dev, DESCR,
+ 				"Found multiple Processing Units in chain\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			return -1;
  		}
  
@@@ -1615,16 -1635,15 +1812,25 @@@
  		break;
  
  	case UVC_VC_SELECTOR_UNIT:
++<<<<<<< HEAD
 +		if (uvc_trace_param & UVC_TRACE_PROBE)
 +			printk(KERN_CONT " <- SU %d", entity->id);
++=======
+ 		uvc_dbg_cont(PROBE, " <- SU %d", entity->id);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  		/* Single-input selector units are ignored. */
  		if (entity->bNrInPins == 1)
  			break;
  
  		if (chain->selector != NULL) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "Found multiple Selector "
 +				"Units in chain.\n");
++=======
+ 			uvc_dbg(chain->dev, DESCR,
+ 				"Found multiple Selector Units in chain\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			return -1;
  		}
  
@@@ -1634,33 -1653,29 +1840,54 @@@
  	case UVC_ITT_VENDOR_SPECIFIC:
  	case UVC_ITT_CAMERA:
  	case UVC_ITT_MEDIA_TRANSPORT_INPUT:
++<<<<<<< HEAD
 +		if (uvc_trace_param & UVC_TRACE_PROBE)
 +			printk(KERN_CONT " <- IT %d\n", entity->id);
++=======
+ 		uvc_dbg_cont(PROBE, " <- IT %d\n", entity->id);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  		break;
  
  	case UVC_OTT_VENDOR_SPECIFIC:
  	case UVC_OTT_DISPLAY:
  	case UVC_OTT_MEDIA_TRANSPORT_OUTPUT:
++<<<<<<< HEAD
 +		if (uvc_trace_param & UVC_TRACE_PROBE)
 +			printk(KERN_CONT " OT %d", entity->id);
++=======
+ 		uvc_dbg_cont(PROBE, " OT %d", entity->id);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  		break;
  
  	case UVC_TT_STREAMING:
++<<<<<<< HEAD
 +		if (UVC_ENTITY_IS_ITERM(entity)) {
 +			if (uvc_trace_param & UVC_TRACE_PROBE)
 +				printk(KERN_CONT " <- IT %d\n", entity->id);
 +		} else {
 +			if (uvc_trace_param & UVC_TRACE_PROBE)
 +				printk(KERN_CONT " OT %d", entity->id);
 +		}
++=======
+ 		if (UVC_ENTITY_IS_ITERM(entity))
+ 			uvc_dbg_cont(PROBE, " <- IT %d\n", entity->id);
+ 		else
+ 			uvc_dbg_cont(PROBE, " OT %d", entity->id);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  		break;
  
  	default:
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_DESCR, "Unsupported entity type "
 +			"0x%04x found in chain.\n", UVC_ENTITY_TYPE(entity));
++=======
+ 		uvc_dbg(chain->dev, DESCR,
+ 			"Unsupported entity type 0x%04x found in chain\n",
+ 			UVC_ENTITY_TYPE(entity));
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		return -1;
  	}
  
@@@ -1686,28 -1701,27 +1913,48 @@@ static int uvc_scan_chain_forward(struc
  		if (forward == prev)
  			continue;
  		if (forward->chain.next || forward->chain.prev) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "Found reference to "
 +				"entity %d already in chain.\n", forward->id);
++=======
+ 			uvc_dbg(chain->dev, DESCR,
+ 				"Found reference to entity %d already in chain\n",
+ 				forward->id);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			return -EINVAL;
  		}
  
  		switch (UVC_ENTITY_TYPE(forward)) {
  		case UVC_VC_EXTENSION_UNIT:
  			if (forward->bNrInPins != 1) {
++<<<<<<< HEAD
 +				uvc_trace(UVC_TRACE_DESCR, "Extension unit %d "
 +					  "has more than 1 input pin.\n",
 +					  entity->id);
++=======
+ 				uvc_dbg(chain->dev, DESCR,
+ 					"Extension unit %d has more than 1 input pin\n",
+ 					entity->id);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  				return -EINVAL;
  			}
  
  			list_add_tail(&forward->chain, &chain->entities);
++<<<<<<< HEAD
 +			if (uvc_trace_param & UVC_TRACE_PROBE) {
 +				if (!found)
 +					printk(KERN_CONT " (->");
 +
 +				printk(KERN_CONT " XU %d", forward->id);
 +				found = 1;
 +			}
++=======
+ 			if (!found)
+ 				uvc_dbg_cont(PROBE, " (->");
+ 
+ 			uvc_dbg_cont(PROBE, " XU %d", forward->id);
+ 			found = 1;
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			break;
  
  		case UVC_OTT_VENDOR_SPECIFIC:
@@@ -1715,24 -1729,23 +1962,42 @@@
  		case UVC_OTT_MEDIA_TRANSPORT_OUTPUT:
  		case UVC_TT_STREAMING:
  			if (UVC_ENTITY_IS_ITERM(forward)) {
++<<<<<<< HEAD
 +				uvc_trace(UVC_TRACE_DESCR, "Unsupported input "
 +					"terminal %u.\n", forward->id);
++=======
+ 				uvc_dbg(chain->dev, DESCR,
+ 					"Unsupported input terminal %u\n",
+ 					forward->id);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  				return -EINVAL;
  			}
  
  			list_add_tail(&forward->chain, &chain->entities);
++<<<<<<< HEAD
 +			if (uvc_trace_param & UVC_TRACE_PROBE) {
 +				if (!found)
 +					printk(KERN_CONT " (->");
 +
 +				printk(KERN_CONT " OT %d", forward->id);
 +				found = 1;
 +			}
++=======
+ 			if (!found)
+ 				uvc_dbg_cont(PROBE, " (->");
+ 
+ 			uvc_dbg_cont(PROBE, " OT %d", forward->id);
+ 			found = 1;
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			break;
  		}
  	}
  	if (found)
++<<<<<<< HEAD
 +		printk(KERN_CONT ")");
++=======
+ 		uvc_dbg_cont(PROBE, ")");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	return 0;
  }
@@@ -1757,36 -1770,33 +2022,59 @@@ static int uvc_scan_chain_backward(stru
  			break;
  		}
  
++<<<<<<< HEAD
 +		if (uvc_trace_param & UVC_TRACE_PROBE)
 +			printk(KERN_CONT " <- IT");
++=======
+ 		uvc_dbg_cont(PROBE, " <- IT");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  		chain->selector = entity;
  		for (i = 0; i < entity->bNrInPins; ++i) {
  			id = entity->baSourceID[i];
  			term = uvc_entity_by_id(chain->dev, id);
  			if (term == NULL || !UVC_ENTITY_IS_ITERM(term)) {
++<<<<<<< HEAD
 +				uvc_trace(UVC_TRACE_DESCR, "Selector unit %d "
 +					"input %d isn't connected to an "
 +					"input terminal\n", entity->id, i);
++=======
+ 				uvc_dbg(chain->dev, DESCR,
+ 					"Selector unit %d input %d isn't connected to an input terminal\n",
+ 					entity->id, i);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  				return -1;
  			}
  
  			if (term->chain.next || term->chain.prev) {
++<<<<<<< HEAD
 +				uvc_trace(UVC_TRACE_DESCR, "Found reference to "
 +					"entity %d already in chain.\n",
++=======
+ 				uvc_dbg(chain->dev, DESCR,
+ 					"Found reference to entity %d already in chain\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  					term->id);
  				return -EINVAL;
  			}
  
++<<<<<<< HEAD
 +			if (uvc_trace_param & UVC_TRACE_PROBE)
 +				printk(KERN_CONT " %d", term->id);
++=======
+ 			uvc_dbg_cont(PROBE, " %d", term->id);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  			list_add_tail(&term->chain, &chain->entities);
  			uvc_scan_chain_forward(chain, term, entity);
  		}
  
++<<<<<<< HEAD
 +		if (uvc_trace_param & UVC_TRACE_PROBE)
 +			printk(KERN_CONT "\n");
++=======
+ 		uvc_dbg_cont(PROBE, "\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  		id = 0;
  		break;
@@@ -1809,8 -1819,8 +2097,13 @@@
  
  	entity = uvc_entity_by_id(chain->dev, id);
  	if (entity == NULL) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_DESCR, "Found reference to "
 +			"unknown entity %d.\n", id);
++=======
+ 		uvc_dbg(chain->dev, DESCR,
+ 			"Found reference to unknown entity %d\n", id);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		return -EINVAL;
  	}
  
@@@ -1823,7 -1833,7 +2116,11 @@@ static int uvc_scan_chain(struct uvc_vi
  {
  	struct uvc_entity *entity, *prev;
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_PROBE, "Scanning UVC chain:");
++=======
+ 	uvc_dbg(chain->dev, PROBE, "Scanning UVC chain:");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	entity = term;
  	prev = NULL;
@@@ -1831,8 -1841,9 +2128,14 @@@
  	while (entity != NULL) {
  		/* Entity must not be part of an existing chain */
  		if (entity->chain.next || entity->chain.prev) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_DESCR, "Found reference to "
 +				"entity %d already in chain.\n", entity->id);
++=======
+ 			uvc_dbg(chain->dev, DESCR,
+ 				"Found reference to entity %d already in chain\n",
+ 				entity->id);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			return -EINVAL;
  		}
  
@@@ -1986,9 -1997,8 +2289,14 @@@ static int uvc_scan_fallback(struct uvc
  
  	list_add_tail(&chain->list, &dev->chains);
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_PROBE,
 +		  "Found a video chain by fallback heuristic (%s).\n",
 +		  uvc_print_chain(chain));
++=======
+ 	uvc_dbg(dev, PROBE, "Found a video chain by fallback heuristic (%s)\n",
+ 		uvc_print_chain(chain));
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	return 0;
  
@@@ -2030,8 -2040,8 +2338,13 @@@ static int uvc_scan_device(struct uvc_d
  			continue;
  		}
  
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_PROBE, "Found a valid video chain (%s).\n",
 +			  uvc_print_chain(chain));
++=======
+ 		uvc_dbg(dev, PROBE, "Found a valid video chain (%s)\n",
+ 			uvc_print_chain(chain));
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  		list_add_tail(&chain->list, &dev->chains);
  	}
@@@ -2336,6 -2340,13 +2649,16 @@@ static int uvc_probe(struct usb_interfa
  	dev->quirks = uvc_quirks_param == -1
  		    ? dev->info->quirks : uvc_quirks_param;
  
++<<<<<<< HEAD
++=======
+ 	if (id->idVendor && id->idProduct)
+ 		uvc_dbg(dev, PROBE, "Probing known UVC device %s (%04x:%04x)\n",
+ 			udev->devpath, id->idVendor, id->idProduct);
+ 	else
+ 		uvc_dbg(dev, PROBE, "Probing generic UVC device %s\n",
+ 			udev->devpath);
+ 
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  	if (udev->product != NULL)
  		strscpy(dev->name, udev->product, sizeof(dev->name));
  	else
@@@ -2378,14 -2389,13 +2701,22 @@@
  
  	/* Parse the Video Class control descriptor. */
  	if (uvc_parse_control(dev) < 0) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_PROBE, "Unable to parse UVC "
 +			"descriptors.\n");
++=======
+ 		uvc_dbg(dev, PROBE, "Unable to parse UVC descriptors\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		goto error;
  	}
  
  	/* Parse the associated GPIOs. */
  	if (uvc_gpio_parse(dev) < 0) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_PROBE, "Unable to parse UVC GPIOs\n");
++=======
+ 		uvc_dbg(dev, PROBE, "Unable to parse UVC GPIOs\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		goto error;
  	}
  
@@@ -2446,7 -2457,7 +2777,11 @@@
  		goto error;
  	}
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_PROBE, "UVC device initialized.\n");
++=======
+ 	uvc_dbg(dev, PROBE, "UVC device initialized\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  	usb_enable_autosuspend(udev);
  	return 0;
  
@@@ -2478,7 -2489,7 +2813,11 @@@ static int uvc_suspend(struct usb_inter
  	struct uvc_device *dev = usb_get_intfdata(intf);
  	struct uvc_streaming *stream;
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_SUSPEND, "Suspending interface %u\n",
++=======
+ 	uvc_dbg(dev, SUSPEND, "Suspending interface %u\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		intf->cur_altsetting->desc.bInterfaceNumber);
  
  	/* Controls are cached on the fly so they don't need to be saved. */
@@@ -2496,8 -2507,8 +2835,13 @@@
  			return uvc_video_suspend(stream);
  	}
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_SUSPEND, "Suspend: video streaming USB interface "
 +			"mismatch.\n");
++=======
+ 	uvc_dbg(dev, SUSPEND,
+ 		"Suspend: video streaming USB interface mismatch\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  	return -EINVAL;
  }
  
@@@ -2507,7 -2518,7 +2851,11 @@@ static int __uvc_resume(struct usb_inte
  	struct uvc_streaming *stream;
  	int ret = 0;
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_SUSPEND, "Resuming interface %u\n",
++=======
+ 	uvc_dbg(dev, SUSPEND, "Resuming interface %u\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		intf->cur_altsetting->desc.bInterfaceNumber);
  
  	if (intf->cur_altsetting->desc.bInterfaceSubClass ==
@@@ -2536,8 -2547,8 +2884,13 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_SUSPEND, "Resume: video streaming USB interface "
 +			"mismatch.\n");
++=======
+ 	uvc_dbg(dev, SUSPEND,
+ 		"Resume: video streaming USB interface mismatch\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  	return -EINVAL;
  }
  
diff --cc drivers/media/usb/uvc/uvc_isight.c
index 135fd7fe6852,2578d6ee4829..000000000000
--- a/drivers/media/usb/uvc/uvc_isight.c
+++ b/drivers/media/usb/uvc/uvc_isight.c
@@@ -49,15 -50,15 +49,24 @@@ static int isight_decode(struct uvc_vid
  
  	if ((len >= 14 && memcmp(&data[2], hdr, 12) == 0) ||
  	    (len >= 15 && memcmp(&data[3], hdr, 12) == 0)) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_FRAME, "iSight header found\n");
++=======
+ 		uvc_dbg(stream->dev, FRAME, "iSight header found\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		is_header = 1;
  	}
  
  	/* Synchronize to the input stream by waiting for a header packet. */
  	if (buf->state != UVC_BUF_STATE_ACTIVE) {
  		if (!is_header) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_FRAME, "Dropping packet (out of "
 +				  "sync).\n");
++=======
+ 			uvc_dbg(stream->dev, FRAME,
+ 				"Dropping packet (out of sync)\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			return 0;
  		}
  
@@@ -85,8 -86,8 +94,13 @@@
  		buf->bytesused += nbytes;
  
  		if (len > maxlen || buf->bytesused == buf->length) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_FRAME, "Frame complete "
 +				  "(overflow).\n");
++=======
+ 			uvc_dbg(stream->dev, FRAME,
+ 				"Frame complete (overflow)\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			buf->state = UVC_BUF_STATE_DONE;
  		}
  	}
@@@ -103,9 -104,9 +117,15 @@@ void uvc_video_decode_isight(struct uvc
  
  	for (i = 0; i < urb->number_of_packets; ++i) {
  		if (urb->iso_frame_desc[i].status < 0) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_FRAME, "USB isochronous frame "
 +				  "lost (%d).\n",
 +				  urb->iso_frame_desc[i].status);
++=======
+ 			uvc_dbg(stream->dev, FRAME,
+ 				"USB isochronous frame lost (%d)\n",
+ 				urb->iso_frame_desc[i].status);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		}
  
  		/* Decode the payload packet.
diff --cc drivers/media/usb/uvc/uvc_queue.c
index 94dc6807eec6,21a907d32bb7..000000000000
--- a/drivers/media/usb/uvc/uvc_queue.c
+++ b/drivers/media/usb/uvc/uvc_queue.c
@@@ -109,7 -103,8 +109,12 @@@ static int uvc_buffer_prepare(struct vb
  
  	if (vb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT &&
  	    vb2_get_plane_payload(vb, 0) > vb2_plane_size(vb, 0)) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_CAPTURE, "[E] Bytes used out of bounds.\n");
++=======
+ 		uvc_dbg(uvc_queue_to_stream(queue)->dev, CAPTURE,
+ 			"[E] Bytes used out of bounds\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		return -EINVAL;
  	}
  
diff --cc drivers/media/usb/uvc/uvc_status.c
index 3e26d82a906d,753c8226db70..000000000000
--- a/drivers/media/usb/uvc/uvc_status.c
+++ b/drivers/media/usb/uvc/uvc_status.c
@@@ -93,22 -93,21 +93,37 @@@ static void uvc_event_streaming(struct 
  				struct uvc_streaming_status *status, int len)
  {
  	if (len < 3) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_STATUS, "Invalid streaming status event "
 +				"received.\n");
++=======
+ 		uvc_dbg(dev, STATUS,
+ 			"Invalid streaming status event received\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		return;
  	}
  
  	if (status->bEvent == 0) {
  		if (len < 4)
  			return;
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_STATUS, "Button (intf %u) %s len %d\n",
 +			  status->bOriginator,
 +			  status->bValue[0] ? "pressed" : "released", len);
 +		uvc_input_report_key(dev, KEY_CAMERA, status->bValue[0]);
 +	} else {
 +		uvc_trace(UVC_TRACE_STATUS,
 +			  "Stream %u error event %02x len %d.\n",
 +			  status->bOriginator, status->bEvent, len);
++=======
+ 		uvc_dbg(dev, STATUS, "Button (intf %u) %s len %d\n",
+ 			status->bOriginator,
+ 			status->bValue[0] ? "pressed" : "released", len);
+ 		uvc_input_report_key(dev, KEY_CAMERA, status->bValue[0]);
+ 	} else {
+ 		uvc_dbg(dev, STATUS, "Stream %u error event %02x len %d\n",
+ 			status->bOriginator, status->bEvent, len);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  	}
  }
  
@@@ -163,14 -162,13 +178,24 @@@ static bool uvc_event_control(struct ur
  
  	if (len < 6 || status->bEvent != 0 ||
  	    status->bAttribute >= ARRAY_SIZE(attrs)) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_STATUS, "Invalid control status event "
 +				"received.\n");
 +		return false;
 +	}
 +
 +	uvc_trace(UVC_TRACE_STATUS, "Control %u/%u %s change len %d.\n",
 +		  status->bOriginator, status->bSelector,
 +		  attrs[status->bAttribute], len);
++=======
+ 		uvc_dbg(dev, STATUS, "Invalid control status event received\n");
+ 		return false;
+ 	}
+ 
+ 	uvc_dbg(dev, STATUS, "Control %u/%u %s change len %d\n",
+ 		status->bOriginator, status->bSelector,
+ 		attrs[status->bAttribute], len);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	/* Find the control. */
  	ctrl = uvc_event_find_ctrl(dev, status, &chain);
@@@ -236,8 -235,8 +261,13 @@@ static void uvc_status_complete(struct 
  		}
  
  		default:
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_STATUS, "Unknown status event "
 +				"type %u.\n", dev->status[0]);
++=======
+ 			uvc_dbg(dev, STATUS, "Unknown status event type %u\n",
+ 				dev->status[0]);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			break;
  		}
  	}
diff --cc drivers/media/usb/uvc/uvc_v4l2.c
index 986d9056a79c,252136cc885c..000000000000
--- a/drivers/media/usb/uvc/uvc_v4l2.c
+++ b/drivers/media/usb/uvc/uvc_v4l2.c
@@@ -75,8 -75,8 +75,13 @@@ static int uvc_ioctl_ctrl_map(struct uv
  		break;
  
  	default:
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_CONTROL, "Unsupported V4L2 control type "
 +			  "%u.\n", xmap->v4l2_type);
++=======
+ 		uvc_dbg(chain->dev, CONTROL,
+ 			"Unsupported V4L2 control type %u\n", xmap->v4l2_type);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		ret = -ENOTTY;
  		goto free_map;
  	}
@@@ -164,10 -164,10 +169,17 @@@ static int uvc_v4l2_try_format(struct u
  		return -EINVAL;
  
  	fcc = (u8 *)&fmt->fmt.pix.pixelformat;
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_FORMAT, "Trying format 0x%08x (%c%c%c%c): %ux%u.\n",
 +			fmt->fmt.pix.pixelformat,
 +			fcc[0], fcc[1], fcc[2], fcc[3],
 +			fmt->fmt.pix.width, fmt->fmt.pix.height);
++=======
+ 	uvc_dbg(stream->dev, FORMAT, "Trying format 0x%08x (%c%c%c%c): %ux%u\n",
+ 		fmt->fmt.pix.pixelformat,
+ 		fcc[0], fcc[1], fcc[2], fcc[3],
+ 		fmt->fmt.pix.width, fmt->fmt.pix.height);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	/* Check if the hardware supports the requested format, use the default
  	 * format otherwise.
@@@ -207,16 -207,17 +219,28 @@@
  	}
  
  	if (frame == NULL) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_FORMAT, "Unsupported size %ux%u.\n",
 +				fmt->fmt.pix.width, fmt->fmt.pix.height);
++=======
+ 		uvc_dbg(stream->dev, FORMAT, "Unsupported size %ux%u\n",
+ 			fmt->fmt.pix.width, fmt->fmt.pix.height);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		return -EINVAL;
  	}
  
  	/* Use the default frame interval. */
  	interval = frame->dwDefaultFrameInterval;
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_FORMAT, "Using default frame interval %u.%u us "
 +		"(%u.%u fps).\n", interval/10, interval%10, 10000000/interval,
 +		(100000000/interval)%10);
++=======
+ 	uvc_dbg(stream->dev, FORMAT,
+ 		"Using default frame interval %u.%u us (%u.%u fps)\n",
+ 		interval / 10, interval % 10, 10000000 / interval,
+ 		(100000000 / interval) % 10);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	/* Set the format index, frame index and frame interval. */
  	memset(probe, 0, sizeof(*probe));
@@@ -260,9 -261,9 +284,15 @@@
  	}
  
  	if (i == stream->nformats)
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_FORMAT,
 +			  "Unknown bFormatIndex %u, using default\n",
 +			  probe->bFormatIndex);
++=======
+ 		uvc_dbg(stream->dev, FORMAT,
+ 			"Unknown bFormatIndex %u, using default\n",
+ 			probe->bFormatIndex);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	for (i = 0; i < format->nframes; ++i) {
  		if (probe->bFrameIndex == format->frame[i].bFrameIndex) {
@@@ -272,9 -273,9 +302,15 @@@
  	}
  
  	if (i == format->nframes)
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_FORMAT,
 +			  "Unknown bFrameIndex %u, using default\n",
 +			  probe->bFrameIndex);
++=======
+ 		uvc_dbg(stream->dev, FORMAT,
+ 			"Unknown bFrameIndex %u, using default\n",
+ 			probe->bFrameIndex);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	fmt->fmt.pix.width = frame->wWidth;
  	fmt->fmt.pix.height = frame->wHeight;
@@@ -416,7 -417,7 +452,11 @@@ static int uvc_v4l2_set_streamparm(stru
  
  	interval = uvc_fraction_to_interval(timeperframe.numerator,
  		timeperframe.denominator);
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_FORMAT, "Setting frame interval to %u/%u (%u).\n",
++=======
+ 	uvc_dbg(stream->dev, FORMAT, "Setting frame interval to %u/%u (%u)\n",
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		timeperframe.numerator, timeperframe.denominator, interval);
  
  	mutex_lock(&stream->mutex);
@@@ -545,8 -546,8 +585,12 @@@ static int uvc_v4l2_open(struct file *f
  	struct uvc_fh *handle;
  	int ret = 0;
  
 +	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_open\n");
  	stream = video_drvdata(file);
++<<<<<<< HEAD
++=======
+ 	uvc_dbg(stream->dev, CALLS, "%s\n", __func__);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	ret = usb_autopm_get_interface(stream->dev->intf);
  	if (ret < 0)
@@@ -588,7 -589,7 +632,11 @@@ static int uvc_v4l2_release(struct fil
  	struct uvc_fh *handle = file->private_data;
  	struct uvc_streaming *stream = handle->stream;
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_release\n");
++=======
+ 	uvc_dbg(stream->dev, CALLS, "%s\n", __func__);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	/* Only free resources if this is a privileged handle. */
  	if (uvc_has_privileges(handle))
@@@ -1460,7 -1462,10 +1508,14 @@@ static long uvc_v4l2_compat_ioctl32(str
  static ssize_t uvc_v4l2_read(struct file *file, char __user *data,
  		    size_t count, loff_t *ppos)
  {
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_read: not implemented.\n");
++=======
+ 	struct uvc_fh *handle = file->private_data;
+ 	struct uvc_streaming *stream = handle->stream;
+ 
+ 	uvc_dbg(stream->dev, CALLS, "%s: not implemented\n", __func__);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  	return -EINVAL;
  }
  
@@@ -1469,7 -1474,7 +1524,11 @@@ static int uvc_v4l2_mmap(struct file *f
  	struct uvc_fh *handle = file->private_data;
  	struct uvc_streaming *stream = handle->stream;
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_mmap\n");
++=======
+ 	uvc_dbg(stream->dev, CALLS, "%s\n", __func__);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	return uvc_queue_mmap(&stream->queue, vma);
  }
@@@ -1479,7 -1484,7 +1538,11 @@@ static __poll_t uvc_v4l2_poll(struct fi
  	struct uvc_fh *handle = file->private_data;
  	struct uvc_streaming *stream = handle->stream;
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_poll\n");
++=======
+ 	uvc_dbg(stream->dev, CALLS, "%s\n", __func__);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	return uvc_queue_poll(&stream->queue, file, wait);
  }
@@@ -1492,7 -1497,7 +1555,11 @@@ static unsigned long uvc_v4l2_get_unmap
  	struct uvc_fh *handle = file->private_data;
  	struct uvc_streaming *stream = handle->stream;
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_get_unmapped_area\n");
++=======
+ 	uvc_dbg(stream->dev, CALLS, "%s\n", __func__);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	return uvc_queue_get_unmapped_area(&stream->queue, pgoff);
  }
diff --cc drivers/media/usb/uvc/uvc_video.c
index a3150da66df5,f2f565281e63..000000000000
--- a/drivers/media/usb/uvc/uvc_video.c
+++ b/drivers/media/usb/uvc/uvc_video.c
@@@ -95,7 -95,7 +95,11 @@@ int uvc_query_ctrl(struct uvc_device *d
  	if (ret != 1)
  		return ret < 0 ? ret : -EPIPE;
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_CONTROL, "Control error %u\n", error);
++=======
+ 	uvc_dbg(dev, CONTROL, "Control error %u\n", error);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	switch (error) {
  	case 0:
@@@ -705,12 -705,12 +709,21 @@@ void uvc_video_clock_update(struct uvc_
  
  	sof = y;
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_CLOCK, "%s: PTS %u y %llu.%06llu SOF %u.%06llu "
 +		  "(x1 %u x2 %u y1 %u y2 %u SOF offset %u)\n",
 +		  stream->dev->name, buf->pts,
 +		  y >> 16, div_u64((y & 0xffff) * 1000000, 65536),
 +		  sof >> 16, div_u64(((u64)sof & 0xffff) * 1000000LLU, 65536),
 +		  x1, x2, y1, y2, clock->sof_offset);
++=======
+ 	uvc_dbg(stream->dev, CLOCK,
+ 		"%s: PTS %u y %llu.%06llu SOF %u.%06llu (x1 %u x2 %u y1 %u y2 %u SOF offset %u)\n",
+ 		stream->dev->name, buf->pts,
+ 		y >> 16, div_u64((y & 0xffff) * 1000000, 65536),
+ 		sof >> 16, div_u64(((u64)sof & 0xffff) * 1000000LLU, 65536),
+ 		x1, x2, y1, y2, clock->sof_offset);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	/* Second step, SOF to host clock conversion. */
  	x1 = (uvc_video_clock_host_sof(first) + 2048) << 16;
@@@ -740,13 -740,13 +753,23 @@@
  
  	timestamp = ktime_to_ns(first->host_time) + y - y1;
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_CLOCK, "%s: SOF %u.%06llu y %llu ts %llu "
 +		  "buf ts %llu (x1 %u/%u/%u x2 %u/%u/%u y1 %u y2 %u)\n",
 +		  stream->dev->name,
 +		  sof >> 16, div_u64(((u64)sof & 0xffff) * 1000000LLU, 65536),
 +		  y, timestamp, vbuf->vb2_buf.timestamp,
 +		  x1, first->host_sof, first->dev_sof,
 +		  x2, last->host_sof, last->dev_sof, y1, y2);
++=======
+ 	uvc_dbg(stream->dev, CLOCK,
+ 		"%s: SOF %u.%06llu y %llu ts %llu buf ts %llu (x1 %u/%u/%u x2 %u/%u/%u y1 %u y2 %u)\n",
+ 		stream->dev->name,
+ 		sof >> 16, div_u64(((u64)sof & 0xffff) * 1000000LLU, 65536),
+ 		y, timestamp, vbuf->vb2_buf.timestamp,
+ 		x1, first->host_sof, first->dev_sof,
+ 		x2, last->host_sof, last->dev_sof, y1, y2);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	/* Update the V4L2 buffer. */
  	vbuf->vb2_buf.timestamp = timestamp;
@@@ -875,16 -875,15 +898,28 @@@ static void uvc_video_stats_update(stru
  {
  	struct uvc_stats_frame *frame = &stream->stats.frame;
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_STATS, "frame %u stats: %u/%u/%u packets, "
 +		  "%u/%u/%u pts (%searly %sinitial), %u/%u scr, "
 +		  "last pts/stc/sof %u/%u/%u\n",
 +		  stream->sequence, frame->first_data,
 +		  frame->nb_packets - frame->nb_empty, frame->nb_packets,
 +		  frame->nb_pts_diffs, frame->last_pts_diff, frame->nb_pts,
 +		  frame->has_early_pts ? "" : "!",
 +		  frame->has_initial_pts ? "" : "!",
 +		  frame->nb_scr_diffs, frame->nb_scr,
 +		  frame->pts, frame->scr_stc, frame->scr_sof);
++=======
+ 	uvc_dbg(stream->dev, STATS,
+ 		"frame %u stats: %u/%u/%u packets, %u/%u/%u pts (%searly %sinitial), %u/%u scr, last pts/stc/sof %u/%u/%u\n",
+ 		stream->sequence, frame->first_data,
+ 		frame->nb_packets - frame->nb_empty, frame->nb_packets,
+ 		frame->nb_pts_diffs, frame->last_pts_diff, frame->nb_pts,
+ 		frame->has_early_pts ? "" : "!",
+ 		frame->has_initial_pts ? "" : "!",
+ 		frame->nb_scr_diffs, frame->nb_scr,
+ 		frame->pts, frame->scr_stc, frame->scr_sof);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  	stream->stats.stream.nb_frames++;
  	stream->stats.stream.nb_packets += stream->stats.frame.nb_packets;
@@@ -1039,8 -1038,8 +1074,13 @@@ static int uvc_video_decode_start(struc
  
  	/* Mark the buffer as bad if the error bit is set. */
  	if (data[1] & UVC_STREAM_ERR) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_FRAME, "Marking buffer as bad (error bit "
 +			  "set).\n");
++=======
+ 		uvc_dbg(stream->dev, FRAME,
+ 			"Marking buffer as bad (error bit set)\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		buf->error = 1;
  	}
  
@@@ -1054,8 -1053,8 +1094,13 @@@
  	 */
  	if (buf->state != UVC_BUF_STATE_ACTIVE) {
  		if (fid == stream->last_fid) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_FRAME, "Dropping payload (out of "
 +				"sync).\n");
++=======
+ 			uvc_dbg(stream->dev, FRAME,
+ 				"Dropping payload (out of sync)\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			if ((stream->dev->quirks & UVC_QUIRK_STREAM_NO_FID) &&
  			    (data[1] & UVC_STREAM_EOF))
  				stream->last_fid ^= UVC_STREAM_FID;
@@@ -1086,8 -1085,8 +1131,13 @@@
  	 * previous payload had the EOF bit set.
  	 */
  	if (fid != stream->last_fid && buf->bytesused != 0) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_FRAME, "Frame complete (FID bit "
 +				"toggled).\n");
++=======
+ 		uvc_dbg(stream->dev, FRAME,
+ 			"Frame complete (FID bit toggled)\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		buf->state = UVC_BUF_STATE_READY;
  		return -EAGAIN;
  	}
@@@ -1148,7 -1147,8 +1198,12 @@@ static void uvc_video_decode_data(struc
  
  	/* Complete the current frame if the buffer size was exceeded. */
  	if (len > maxlen) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_FRAME, "Frame complete (overflow).\n");
++=======
+ 		uvc_dbg(uvc_urb->stream->dev, FRAME,
+ 			"Frame complete (overflow)\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		buf->error = 1;
  		buf->state = UVC_BUF_STATE_READY;
  	}
@@@ -1161,9 -1161,9 +1216,15 @@@ static void uvc_video_decode_end(struc
  {
  	/* Mark the buffer as done if the EOF marker is set. */
  	if (data[1] & UVC_STREAM_EOF && buf->bytesused != 0) {
++<<<<<<< HEAD
 +		uvc_trace(UVC_TRACE_FRAME, "Frame complete (EOF found).\n");
 +		if (data[0] == len)
 +			uvc_trace(UVC_TRACE_FRAME, "EOF in empty payload.\n");
++=======
+ 		uvc_dbg(stream->dev, FRAME, "Frame complete (EOF found)\n");
+ 		if (data[0] == len)
+ 			uvc_dbg(stream->dev, FRAME, "EOF in empty payload\n");
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		buf->state = UVC_BUF_STATE_READY;
  		if (stream->dev->quirks & UVC_QUIRK_STREAM_NO_FID)
  			stream->last_fid ^= UVC_STREAM_FID;
@@@ -1279,13 -1279,13 +1340,23 @@@ static void uvc_video_decode_meta(struc
  	memcpy(&meta->length, mem, length);
  	meta_buf->bytesused += length + sizeof(meta->ns) + sizeof(meta->sof);
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_FRAME,
 +		  "%s(): t-sys %lluns, SOF %u, len %u, flags 0x%x, PTS %u, STC %u frame SOF %u\n",
 +		  __func__, ktime_to_ns(time), meta->sof, meta->length,
 +		  meta->flags,
 +		  has_pts ? *(u32 *)meta->buf : 0,
 +		  has_scr ? *(u32 *)scr : 0,
 +		  has_scr ? *(u32 *)(scr + 4) & 0x7ff : 0);
++=======
+ 	uvc_dbg(stream->dev, FRAME,
+ 		"%s(): t-sys %lluns, SOF %u, len %u, flags 0x%x, PTS %u, STC %u frame SOF %u\n",
+ 		__func__, ktime_to_ns(time), meta->sof, meta->length,
+ 		meta->flags,
+ 		has_pts ? *(u32 *)meta->buf : 0,
+ 		has_scr ? *(u32 *)scr : 0,
+ 		has_scr ? *(u32 *)(scr + 4) & 0x7ff : 0);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  }
  
  /* ------------------------------------------------------------------------
@@@ -1339,8 -1339,9 +1410,14 @@@ static void uvc_video_decode_isoc(struc
  
  	for (i = 0; i < urb->number_of_packets; ++i) {
  		if (urb->iso_frame_desc[i].status < 0) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_FRAME, "USB isochronous frame "
 +				"lost (%d).\n", urb->iso_frame_desc[i].status);
++=======
+ 			uvc_dbg(stream->dev, FRAME,
+ 				"USB isochronous frame lost (%d)\n",
+ 				urb->iso_frame_desc[i].status);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			/* Mark the buffer as faulty. */
  			if (buf != NULL)
  				buf->error = 1;
@@@ -1628,15 -1629,16 +1705,27 @@@ static int uvc_alloc_urb_buffers(struc
  		}
  
  		if (i == UVC_URBS) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_VIDEO, "Allocated %u URB buffers "
 +				"of %ux%u bytes each.\n", UVC_URBS, npackets,
 +				psize);
++=======
+ 			uvc_dbg(stream->dev, VIDEO,
+ 				"Allocated %u URB buffers of %ux%u bytes each\n",
+ 				UVC_URBS, npackets, psize);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  			return npackets;
  		}
  	}
  
++<<<<<<< HEAD
 +	uvc_trace(UVC_TRACE_VIDEO, "Failed to allocate URB buffers (%u bytes "
 +		"per packet).\n", psize);
++=======
+ 	uvc_dbg(stream->dev, VIDEO,
+ 		"Failed to allocate URB buffers (%u bytes per packet)\n",
+ 		psize);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  	return 0;
  }
  
@@@ -1835,12 -1837,13 +1924,22 @@@ static int uvc_video_start_transfer(str
  		bandwidth = stream->ctrl.dwMaxPayloadTransferSize;
  
  		if (bandwidth == 0) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_VIDEO, "Device requested null "
 +				"bandwidth, defaulting to lowest.\n");
 +			bandwidth = 1;
 +		} else {
 +			uvc_trace(UVC_TRACE_VIDEO, "Device requested %u "
 +				"B/frame bandwidth.\n", bandwidth);
++=======
+ 			uvc_dbg(stream->dev, VIDEO,
+ 				"Device requested null bandwidth, defaulting to lowest\n");
+ 			bandwidth = 1;
+ 		} else {
+ 			uvc_dbg(stream->dev, VIDEO,
+ 				"Device requested %u B/frame bandwidth\n",
+ 				bandwidth);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  		}
  
  		for (i = 0; i < intf->num_altsetting; ++i) {
@@@ -1863,13 -1866,14 +1962,24 @@@
  		}
  
  		if (best_ep == NULL) {
++<<<<<<< HEAD
 +			uvc_trace(UVC_TRACE_VIDEO, "No fast enough alt setting "
 +				"for requested bandwidth.\n");
 +			return -EIO;
 +		}
 +
 +		uvc_trace(UVC_TRACE_VIDEO, "Selecting alternate setting %u "
 +			"(%u B/frame bandwidth).\n", altsetting, best_psize);
++=======
+ 			uvc_dbg(stream->dev, VIDEO,
+ 				"No fast enough alt setting for requested bandwidth\n");
+ 			return -EIO;
+ 		}
+ 
+ 		uvc_dbg(stream->dev, VIDEO,
+ 			"Selecting alternate setting %u (%u B/frame bandwidth)\n",
+ 			altsetting, best_psize);
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
  		ret = usb_set_interface(stream->dev->udev, intfnum, altsetting);
  		if (ret < 0)
diff --cc drivers/media/usb/uvc/uvcvideo.h
index 7fe135950aca,97df5ecd66c9..000000000000
--- a/drivers/media/usb/uvc/uvcvideo.h
+++ b/drivers/media/usb/uvc/uvcvideo.h
@@@ -751,20 -752,24 +751,35 @@@ extern unsigned int uvc_dbg_param
  extern unsigned int uvc_timeout_param;
  extern unsigned int uvc_hw_timestamps_param;
  
++<<<<<<< HEAD
 +#define uvc_trace(flag, msg...) \
 +	do { \
 +		if (uvc_trace_param & flag) \
 +			printk(KERN_DEBUG "uvcvideo: " msg); \
 +	} while (0)
 +
 +#define uvc_warn_once(dev, warn, msg...) \
 +	do { \
 +		if (!test_and_set_bit(warn, &dev->warnings)) \
 +			printk(KERN_INFO "uvcvideo: " msg); \
 +	} while (0)
++=======
+ #define uvc_dbg(_dev, flag, fmt, ...)					\
+ do {									\
+ 	if (uvc_dbg_param & UVC_DBG_##flag)				\
+ 		dev_printk(KERN_DEBUG, &(_dev)->udev->dev, fmt,		\
+ 			   ##__VA_ARGS__);				\
+ } while (0)
+ 
+ #define uvc_dbg_cont(flag, fmt, ...)					\
+ do {									\
+ 	if (uvc_dbg_param & UVC_DBG_##flag)				\
+ 		pr_cont(fmt, ##__VA_ARGS__);				\
+ } while (0)
++>>>>>>> 9e56380ae625 (media: uvcvideo: Rename debug functions)
  
 -#define uvc_warn_once(_dev, warn, fmt, ...)				\
 -do {									\
 -	if (!test_and_set_bit(warn, &(_dev)->warnings))			\
 -		dev_info(&(_dev)->udev->dev, fmt, ##__VA_ARGS__);	\
 -} while (0)
 +#define uvc_printk(level, msg...) \
 +	printk(level "uvcvideo: " msg)
  
  /* --------------------------------------------------------------------------
   * Internal functions.
* Unmerged path drivers/media/usb/uvc/uvc_ctrl.c
* Unmerged path drivers/media/usb/uvc/uvc_driver.c
* Unmerged path drivers/media/usb/uvc/uvc_isight.c
* Unmerged path drivers/media/usb/uvc/uvc_queue.c
* Unmerged path drivers/media/usb/uvc/uvc_status.c
* Unmerged path drivers/media/usb/uvc/uvc_v4l2.c
* Unmerged path drivers/media/usb/uvc/uvc_video.c
* Unmerged path drivers/media/usb/uvc/uvcvideo.h
