of: net: pass the dst buffer to of_get_mac_address()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Michael Walle <michael@walle.cc>
commit 83216e3988cd196183542937c9bd58b279f946af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/83216e39.failed

of_get_mac_address() returns a "const void*" pointer to a MAC address.
Lately, support to fetch the MAC address by an NVMEM provider was added.
But this will only work with platform devices. It will not work with
PCI devices (e.g. of an integrated root complex) and esp. not with DSA
ports.

There is an of_* variant of the nvmem binding which works without
devices. The returned data of a nvmem_cell_read() has to be freed after
use. On the other hand the return of_get_mac_address() points to some
static data without a lifetime. The trick for now, was to allocate a
device resource managed buffer which is then returned. This will only
work if we have an actual device.

Change it, so that the caller of of_get_mac_address() has to supply a
buffer where the MAC address is written to. Unfortunately, this will
touch all drivers which use the of_get_mac_address().

Usually the code looks like:

  const char *addr;
  addr = of_get_mac_address(np);
  if (!IS_ERR(addr))
    ether_addr_copy(ndev->dev_addr, addr);

This can then be simply rewritten as:

  of_get_mac_address(np, ndev->dev_addr);

Sometimes is_valid_ether_addr() is used to test the MAC address.
of_get_mac_address() already makes sure, it just returns a valid MAC
address. Thus we can just test its return code. But we have to be
careful if there are still other sources for the MAC address before the
of_get_mac_address(). In this case we have to keep the
is_valid_ether_addr() call.

The following coccinelle patch was used to convert common cases to the
new style. Afterwards, I've manually gone over the drivers and fixed the
return code variable: either used a new one or if one was already
available use that. Mansour Moufid, thanks for that coccinelle patch!

<spml>
@a@
identifier x;
expression y, z;
@@
- x = of_get_mac_address(y);
+ x = of_get_mac_address(y, z);
  <...
- ether_addr_copy(z, x);
  ...>

@@
identifier a.x;
@@
- if (<+... x ...+>) {}

@@
identifier a.x;
@@
  if (<+... x ...+>) {
      ...
  }
- else {}

@@
identifier a.x;
expression e;
@@
- if (<+... x ...+>@e)
-     {}
- else
+ if (!(e))
      {...}

@@
expression x, y, z;
@@
- x = of_get_mac_address(y, z);
+ of_get_mac_address(y, z);
  ... when != x
</spml>

All drivers, except drivers/net/ethernet/aeroflex/greth.c, were
compile-time tested.

	Suggested-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: Michael Walle <michael@walle.cc>
	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 83216e3988cd196183542937c9bd58b279f946af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/mach-mvebu/kirkwood.c
#	arch/powerpc/sysdev/tsi108_dev.c
#	drivers/net/ethernet/aeroflex/greth.c
#	drivers/net/ethernet/allwinner/sun4i-emac.c
#	drivers/net/ethernet/altera/altera_tse_main.c
#	drivers/net/ethernet/arc/emac_main.c
#	drivers/net/ethernet/atheros/ag71xx.c
#	drivers/net/ethernet/broadcom/bcm4908_enet.c
#	drivers/net/ethernet/broadcom/bcmsysport.c
#	drivers/net/ethernet/broadcom/bgmac-bcma.c
#	drivers/net/ethernet/broadcom/bgmac-platform.c
#	drivers/net/ethernet/cadence/macb_main.c
#	drivers/net/ethernet/cavium/octeon/octeon_mgmt.c
#	drivers/net/ethernet/cavium/thunder/thunder_bgx.c
#	drivers/net/ethernet/davicom/dm9000.c
#	drivers/net/ethernet/ethoc.c
#	drivers/net/ethernet/ezchip/nps_enet.c
#	drivers/net/ethernet/freescale/fec_main.c
#	drivers/net/ethernet/freescale/fec_mpc52xx.c
#	drivers/net/ethernet/freescale/fman/mac.c
#	drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
#	drivers/net/ethernet/freescale/gianfar.c
#	drivers/net/ethernet/freescale/ucc_geth.c
#	drivers/net/ethernet/hisilicon/hisi_femac.c
#	drivers/net/ethernet/hisilicon/hix5hd2_gmac.c
#	drivers/net/ethernet/lantiq_xrx200.c
#	drivers/net/ethernet/marvell/mv643xx_eth.c
#	drivers/net/ethernet/marvell/mvneta.c
#	drivers/net/ethernet/marvell/prestera/prestera_main.c
#	drivers/net/ethernet/marvell/pxa168_eth.c
#	drivers/net/ethernet/marvell/sky2.c
#	drivers/net/ethernet/mediatek/mtk_eth_soc.c
#	drivers/net/ethernet/micrel/ks8851.c
#	drivers/net/ethernet/microchip/lan743x_main.c
#	drivers/net/ethernet/nxp/lpc_eth.c
#	drivers/net/ethernet/qualcomm/qca_spi.c
#	drivers/net/ethernet/qualcomm/qca_uart.c
#	drivers/net/ethernet/renesas/ravb_main.c
#	drivers/net/ethernet/renesas/sh_eth.c
#	drivers/net/ethernet/samsung/sxgbe/sxgbe_platform.c
#	drivers/net/ethernet/socionext/sni_ave.c
#	drivers/net/ethernet/stmicro/stmmac/dwmac-imx.c
#	drivers/net/ethernet/stmicro/stmmac/dwmac-intel-plat.c
#	drivers/net/ethernet/stmicro/stmmac/dwmac-mediatek.c
#	drivers/net/ethernet/stmicro/stmmac/dwmac-qcom-ethqos.c
#	drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
#	drivers/net/ethernet/stmicro/stmmac/dwmac-visconti.c
#	drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
#	drivers/net/ethernet/ti/am65-cpsw-nuss.c
#	drivers/net/ethernet/ti/cpsw.c
#	drivers/net/ethernet/ti/cpsw_new.c
#	drivers/net/ethernet/ti/davinci_emac.c
#	drivers/net/ethernet/ti/netcp_core.c
#	drivers/net/ethernet/wiznet/w5100-spi.c
#	drivers/net/ethernet/xilinx/ll_temac_main.c
#	drivers/net/ethernet/xilinx/xilinx_axienet_main.c
#	drivers/net/ethernet/xilinx/xilinx_emaclite.c
#	drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
#	drivers/of/of_net.c
#	drivers/staging/octeon/ethernet.c
#	drivers/staging/wfx/main.c
#	include/linux/of_net.h
#	include/net/dsa.h
#	net/dsa/dsa2.c
#	net/dsa/slave.c
#	net/ethernet/eth.c
diff --cc arch/arm/mach-mvebu/kirkwood.c
index 0aa88105d46e,06b1706595f4..000000000000
--- a/arch/arm/mach-mvebu/kirkwood.c
+++ b/arch/arm/mach-mvebu/kirkwood.c
@@@ -92,7 -93,8 +93,12 @@@ static void __init kirkwood_dt_eth_fixu
  			continue;
  
  		/* skip disabled nodes or nodes with valid MAC address*/
++<<<<<<< HEAD
 +		if (!of_device_is_available(pnp) || of_get_mac_address(np))
++=======
+ 		if (!of_device_is_available(pnp) ||
+ 		    !of_get_mac_address(np, tmpmac))
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  			goto eth_fixup_skip;
  
  		clk = of_clk_get(pnp, 0);
diff --cc arch/powerpc/sysdev/tsi108_dev.c
index 1fd0717ade02,4c4a6efd5e5f..000000000000
--- a/arch/powerpc/sysdev/tsi108_dev.c
+++ b/arch/powerpc/sysdev/tsi108_dev.c
@@@ -104,9 -100,7 +103,13 @@@ static int __init tsi108_eth_of_init(vo
  			goto err;
  		}
  
++<<<<<<< HEAD
 +		mac_addr = of_get_mac_address(np);
 +		if (mac_addr)
 +			memcpy(tsi_eth_data.mac_addr, mac_addr, 6);
++=======
+ 		of_get_mac_address(np, tsi_eth_data.mac_addr);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  		ph = of_get_property(np, "mdio-handle", NULL);
  		mdio = of_find_node_by_phandle(*ph);
diff --cc drivers/net/ethernet/aeroflex/greth.c
index f0bc2c555543,d77fafbc1530..000000000000
--- a/drivers/net/ethernet/aeroflex/greth.c
+++ b/drivers/net/ethernet/aeroflex/greth.c
@@@ -1455,10 -1449,10 +1455,15 @@@ static int greth_of_probe(struct platfo
  			break;
  	}
  	if (i == 6) {
- 		const u8 *addr;
+ 		u8 addr[ETH_ALEN];
  
++<<<<<<< HEAD
 +		addr = of_get_mac_address(ofdev->dev.of_node);
 +		if (addr) {
++=======
+ 		err = of_get_mac_address(ofdev->dev.of_node, addr);
+ 		if (!err) {
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  			for (i = 0; i < 6; i++)
  				macaddr[i] = (unsigned int) addr[i];
  		} else {
diff --cc drivers/net/ethernet/allwinner/sun4i-emac.c
index 7b54c4472fb3,f99ae317c188..000000000000
--- a/drivers/net/ethernet/allwinner/sun4i-emac.c
+++ b/drivers/net/ethernet/allwinner/sun4i-emac.c
@@@ -869,12 -852,9 +868,18 @@@ static int emac_probe(struct platform_d
  	}
  
  	/* Read MAC-address from DT */
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(np);
 +	if (mac_addr)
 +		memcpy(ndev->dev_addr, mac_addr, ETH_ALEN);
 +
 +	/* Check if the MAC address is valid, if not get a random one */
 +	if (!is_valid_ether_addr(ndev->dev_addr)) {
++=======
+ 	ret = of_get_mac_address(np, ndev->dev_addr);
+ 	if (ret) {
+ 		/* if the MAC address is invalid get a random one */
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		eth_hw_addr_random(ndev);
  		dev_warn(&pdev->dev, "using random MAC address %pM\n",
  			 ndev->dev_addr);
diff --cc drivers/net/ethernet/altera/altera_tse_main.c
index 02921d877c08,1c00d719e5d7..000000000000
--- a/drivers/net/ethernet/altera/altera_tse_main.c
+++ b/drivers/net/ethernet/altera/altera_tse_main.c
@@@ -1534,10 -1524,8 +1533,15 @@@ static int altera_tse_probe(struct plat
  	priv->rx_dma_buf_sz = ALTERA_RXDMABUFFER_SIZE;
  
  	/* get default MAC address from device tree */
++<<<<<<< HEAD
 +	macaddr = of_get_mac_address(pdev->dev.of_node);
 +	if (macaddr)
 +		ether_addr_copy(ndev->dev_addr, macaddr);
 +	else
++=======
+ 	ret = of_get_mac_address(pdev->dev.of_node, ndev->dev_addr);
+ 	if (ret)
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		eth_hw_addr_random(ndev);
  
  	/* get phy addr and create mdio */
diff --cc drivers/net/ethernet/arc/emac_main.c
index 4406325fdd9f,67b8113a2b53..000000000000
--- a/drivers/net/ethernet/arc/emac_main.c
+++ b/drivers/net/ethernet/arc/emac_main.c
@@@ -958,11 -941,8 +957,16 @@@ int arc_emac_probe(struct net_device *n
  	}
  
  	/* Get MAC address from device tree */
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(dev->of_node);
 +
 +	if (mac_addr)
 +		memcpy(ndev->dev_addr, mac_addr, ETH_ALEN);
 +	else
++=======
+ 	err = of_get_mac_address(dev->of_node, ndev->dev_addr);
+ 	if (err)
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		eth_hw_addr_random(ndev);
  
  	arc_emac_set_address_internal(ndev);
diff --cc drivers/net/ethernet/broadcom/bcmsysport.c
index d92a344bc8ce,d9f0f0df8f7b..000000000000
--- a/drivers/net/ethernet/broadcom/bcmsysport.c
+++ b/drivers/net/ethernet/broadcom/bcmsysport.c
@@@ -2256,8 -2457,6 +2256,11 @@@ static int bcm_sysport_probe(struct pla
  	struct bcm_sysport_priv *priv;
  	struct device_node *dn;
  	struct net_device *dev;
++<<<<<<< HEAD
 +	const void *macaddr;
 +	struct resource *r;
++=======
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  	u32 txq, rxq;
  	int ret;
  
@@@ -2338,12 -2551,10 +2341,15 @@@
  	}
  
  	/* Initialize netdevice members */
++<<<<<<< HEAD
 +	macaddr = of_get_mac_address(dn);
 +	if (!macaddr || !is_valid_ether_addr(macaddr)) {
++=======
+ 	ret = of_get_mac_address(dn, dev->dev_addr);
+ 	if (ret) {
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		dev_warn(&pdev->dev, "using random Ethernet MAC\n");
  		eth_hw_addr_random(dev);
- 	} else {
- 		ether_addr_copy(dev->dev_addr, macaddr);
  	}
  
  	SET_NETDEV_DEV(dev, &pdev->dev);
diff --cc drivers/net/ethernet/broadcom/bgmac-bcma.c
index 6fe074c1588b,85fa0ab7201c..000000000000
--- a/drivers/net/ethernet/broadcom/bgmac-bcma.c
+++ b/drivers/net/ethernet/broadcom/bgmac-bcma.c
@@@ -128,11 -128,10 +128,14 @@@ static int bgmac_probe(struct bcma_devi
  
  	bcma_set_drvdata(core, bgmac);
  
- 	if (bgmac->dev->of_node)
- 		mac = of_get_mac_address(bgmac->dev->of_node);
+ 	err = of_get_mac_address(bgmac->dev->of_node, bgmac->net_dev->dev_addr);
  
  	/* If no MAC address assigned via device tree, check SPROM */
++<<<<<<< HEAD
 +	if (!mac) {
++=======
+ 	if (err) {
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		switch (core->core_unit) {
  		case 0:
  			mac = sprom->et0mac;
diff --cc drivers/net/ethernet/broadcom/bgmac-platform.c
index 894eda5b13cf,9834b77cf4b6..000000000000
--- a/drivers/net/ethernet/broadcom/bgmac-platform.c
+++ b/drivers/net/ethernet/broadcom/bgmac-platform.c
@@@ -192,25 -192,17 +192,32 @@@ static int bgmac_probe(struct platform_
  	bgmac->dev = &pdev->dev;
  	bgmac->dma_dev = &pdev->dev;
  
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(np);
 +	if (mac_addr)
 +		ether_addr_copy(bgmac->net_dev->dev_addr, mac_addr);
 +	else
 +		dev_warn(&pdev->dev, "MAC address not present in device tree\n");
++=======
+ 	ret = of_get_mac_address(np, bgmac->net_dev->dev_addr);
+ 	if (ret)
+ 		dev_warn(&pdev->dev,
+ 			 "MAC address not present in device tree\n");
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  	bgmac->irq = platform_get_irq(pdev, 0);
 -	if (bgmac->irq < 0)
 +	if (bgmac->irq < 0) {
 +		dev_err(&pdev->dev, "Unable to obtain IRQ\n");
  		return bgmac->irq;
 +	}
 +
 +	regs = platform_get_resource_byname(pdev, IORESOURCE_MEM, "amac_base");
 +	if (!regs) {
 +		dev_err(&pdev->dev, "Unable to obtain base resource\n");
 +		return -EINVAL;
 +	}
  
 -	bgmac->plat.base =
 -		devm_platform_ioremap_resource_byname(pdev, "amac_base");
 +	bgmac->plat.base = devm_ioremap_resource(&pdev->dev, regs);
  	if (IS_ERR(bgmac->plat.base))
  		return PTR_ERR(bgmac->plat.base);
  
diff --cc drivers/net/ethernet/cadence/macb_main.c
index eaaa8bf3961f,d6bde1748a22..000000000000
--- a/drivers/net/ethernet/cadence/macb_main.c
+++ b/drivers/net/ethernet/cadence/macb_main.c
@@@ -3970,28 -4759,22 +3969,40 @@@ static int macb_probe(struct platform_d
  						macb_dma_desc_get_size(bp);
  	}
  
++<<<<<<< HEAD
 +	mac = of_get_mac_address(np);
 +	if (mac) {
 +		ether_addr_copy(bp->dev->dev_addr, mac);
 +	} else {
 +		err = of_get_nvmem_mac_address(np, bp->dev->dev_addr);
 +		if (err) {
 +			if (err == -EPROBE_DEFER)
 +				goto err_out_free_netdev;
 +			macb_get_hwaddr(bp);
 +		}
 +	}
++=======
+ 	bp->rx_intr_mask = MACB_RX_INT_FLAGS;
+ 	if (bp->caps & MACB_CAPS_NEEDS_RSTONUBR)
+ 		bp->rx_intr_mask |= MACB_BIT(RXUBR);
+ 
+ 	err = of_get_mac_address(np, bp->dev->dev_addr);
+ 	if (err == -EPROBE_DEFER)
+ 		goto err_out_free_netdev;
+ 	else if (err)
+ 		macb_get_hwaddr(bp);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
 -	err = of_get_phy_mode(np, &interface);
 -	if (err)
 -		/* not found in DT, MII by default */
 -		bp->phy_interface = PHY_INTERFACE_MODE_MII;
 -	else
 -		bp->phy_interface = interface;
 +	err = of_get_phy_mode(np);
 +	if (err < 0) {
 +		pdata = dev_get_platdata(&pdev->dev);
 +		if (pdata && pdata->is_rmii)
 +			bp->phy_interface = PHY_INTERFACE_MODE_RMII;
 +		else
 +			bp->phy_interface = PHY_INTERFACE_MODE_MII;
 +	} else {
 +		bp->phy_interface = err;
 +	}
  
  	/* IP specific init */
  	err = init(pdev);
diff --cc drivers/net/ethernet/cavium/octeon/octeon_mgmt.c
index a8e5b6b02696,48ff6fb0eed9..000000000000
--- a/drivers/net/ethernet/cavium/octeon/octeon_mgmt.c
+++ b/drivers/net/ethernet/cavium/octeon/octeon_mgmt.c
@@@ -1498,13 -1499,10 +1497,18 @@@ static int octeon_mgmt_probe(struct pla
  	netdev->ethtool_ops = &octeon_mgmt_ethtool_ops;
  
  	netdev->min_mtu = 64 - OCTEON_MGMT_RX_HEADROOM;
 -	netdev->max_mtu = 16383 - OCTEON_MGMT_RX_HEADROOM - VLAN_HLEN;
 +	netdev->max_mtu = 16383 - OCTEON_MGMT_RX_HEADROOM;
 +
++<<<<<<< HEAD
 +	mac = of_get_mac_address(pdev->dev.of_node);
  
 +	if (mac)
 +		memcpy(netdev->dev_addr, mac, ETH_ALEN);
 +	else
++=======
+ 	result = of_get_mac_address(pdev->dev.of_node, netdev->dev_addr);
+ 	if (result)
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		eth_hw_addr_random(netdev);
  
  	p->phy_np = of_parse_phandle(pdev->dev.of_node, "phy-handle", 0);
diff --cc drivers/net/ethernet/cavium/thunder/thunder_bgx.c
index e337da6ba2a4,0c783aadf393..000000000000
--- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
+++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
@@@ -1483,9 -1482,7 +1482,13 @@@ static int bgx_init_of_phy(struct bgx *
  		if (!node)
  			break;
  
++<<<<<<< HEAD
 +		mac = of_get_mac_address(node);
 +		if (mac)
 +			ether_addr_copy(bgx->lmac[lmac].mac, mac);
++=======
+ 		of_get_mac_address(node, bgx->lmac[lmac].mac);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  		SET_NETDEV_DEV(&bgx->lmac[lmac].netdev, &bgx->pdev->dev);
  		bgx->lmac[lmac].lmacid = lmac;
diff --cc drivers/net/ethernet/davicom/dm9000.c
index 1ea29122e1f2,2374c51bf2b2..000000000000
--- a/drivers/net/ethernet/davicom/dm9000.c
+++ b/drivers/net/ethernet/davicom/dm9000.c
@@@ -1410,9 -1399,9 +1410,15 @@@ static struct dm9000_plat_data *dm9000_
  	if (of_find_property(np, "davicom,no-eeprom", NULL))
  		pdata->flags |= DM9000_PLATF_NO_EEPROM;
  
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(np);
 +	if (mac_addr)
 +		memcpy(pdata->dev_addr, mac_addr, sizeof(pdata->dev_addr));
++=======
+ 	ret = of_get_mac_address(np, pdata->dev_addr);
+ 	if (ret == -EPROBE_DEFER)
+ 		return ERR_PTR(ret);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  	return pdata;
  }
diff --cc drivers/net/ethernet/ethoc.c
index c0c7a35d0af6,e1b43b07755b..000000000000
--- a/drivers/net/ethernet/ethoc.c
+++ b/drivers/net/ethernet/ethoc.c
@@@ -1152,11 -1151,7 +1152,15 @@@ static int ethoc_probe(struct platform_
  		ether_addr_copy(netdev->dev_addr, pdata->hwaddr);
  		priv->phy_id = pdata->phy_id;
  	} else {
++<<<<<<< HEAD
 +		const void *mac;
 +
 +		mac = of_get_mac_address(pdev->dev.of_node);
 +		if (mac)
 +			ether_addr_copy(netdev->dev_addr, mac);
++=======
+ 		of_get_mac_address(pdev->dev.of_node, netdev->dev_addr);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		priv->phy_id = -1;
  	}
  
diff --cc drivers/net/ethernet/ezchip/nps_enet.c
index 659f1ad37e96,e3954d8835e7..000000000000
--- a/drivers/net/ethernet/ezchip/nps_enet.c
+++ b/drivers/net/ethernet/ezchip/nps_enet.c
@@@ -586,8 -575,6 +586,11 @@@ static s32 nps_enet_probe(struct platfo
  	struct net_device *ndev;
  	struct nps_enet_priv *priv;
  	s32 err = 0;
++<<<<<<< HEAD
 +	const char *mac_addr;
 +	struct resource *res_regs;
++=======
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  	if (!dev->of_node)
  		return -ENODEV;
@@@ -615,10 -601,8 +618,15 @@@
  	dev_dbg(dev, "Registers base address is 0x%p\n", priv->regs_base);
  
  	/* set kernel MAC address to dev */
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(dev->of_node);
 +	if (mac_addr)
 +		ether_addr_copy(ndev->dev_addr, mac_addr);
 +	else
++=======
+ 	err = of_get_mac_address(dev->of_node, ndev->dev_addr);
+ 	if (err)
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		eth_hw_addr_random(ndev);
  
  	/* Get IRQ number */
diff --cc drivers/net/ethernet/freescale/fec_main.c
index 5206013c106d,aecc111fbe73..000000000000
--- a/drivers/net/ethernet/freescale/fec_main.c
+++ b/drivers/net/ethernet/freescale/fec_main.c
@@@ -1634,8 -1664,8 +1634,9 @@@ static int fec_enet_rx_napi(struct napi
  static void fec_get_mac(struct net_device *ndev)
  {
  	struct fec_enet_private *fep = netdev_priv(ndev);
 +	struct fec_platform_data *pdata = dev_get_platdata(&fep->pdev->dev);
  	unsigned char *iap, tmpaddr[ETH_ALEN];
+ 	int ret;
  
  	/*
  	 * try to get mac address in following order:
@@@ -1651,9 -1681,9 +1652,15 @@@
  	if (!is_valid_ether_addr(iap)) {
  		struct device_node *np = fep->pdev->dev.of_node;
  		if (np) {
++<<<<<<< HEAD
 +			const char *mac = of_get_mac_address(np);
 +			if (mac)
 +				iap = (unsigned char *) mac;
++=======
+ 			ret = of_get_mac_address(np, tmpaddr);
+ 			if (!ret)
+ 				iap = tmpaddr;
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		}
  	}
  
diff --cc drivers/net/ethernet/freescale/fec_mpc52xx.c
index dc20614b8f44,02c47658a215..000000000000
--- a/drivers/net/ethernet/freescale/fec_mpc52xx.c
+++ b/drivers/net/ethernet/freescale/fec_mpc52xx.c
@@@ -900,10 -890,8 +899,15 @@@ static int mpc52xx_fec_probe(struct pla
  	 *
  	 * First try to read MAC address from DT
  	 */
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(np);
 +	if (mac_addr) {
 +		memcpy(ndev->dev_addr, mac_addr, ETH_ALEN);
 +	} else {
++=======
+ 	rv = of_get_mac_address(np, ndev->dev_addr);
+ 	if (rv) {
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		struct mpc52xx_fec __iomem *fec = priv->fec;
  
  		/*
diff --cc drivers/net/ethernet/freescale/fman/mac.c
index d4e575032b3e,46ecb42f2ef8..000000000000
--- a/drivers/net/ethernet/freescale/fman/mac.c
+++ b/drivers/net/ethernet/freescale/fman/mac.c
@@@ -602,10 -605,9 +602,9 @@@ static int mac_probe(struct platform_de
  	struct platform_device	*of_dev;
  	struct resource		 res;
  	struct mac_priv_s	*priv;
- 	const u8		*mac_addr;
  	u32			 val;
  	u8			fman_id;
 -	phy_interface_t          phy_if;
 +	int			phy_if;
  
  	dev = &_of_dev->dev;
  	mac_node = dev->of_node;
@@@ -720,13 -722,9 +719,19 @@@
  	priv->cell_index = (u8)val;
  
  	/* Get the MAC address */
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(mac_node);
 +	if (!mac_addr) {
 +		dev_err(dev, "of_get_mac_address(%pOF) failed\n", mac_node);
 +		err = -EINVAL;
 +		goto _return_of_get_parent;
 +	}
 +	memcpy(mac_dev->addr, mac_addr, sizeof(mac_dev->addr));
++=======
+ 	err = of_get_mac_address(mac_node, mac_dev->addr);
+ 	if (err)
+ 		dev_warn(dev, "of_get_mac_address(%pOF) failed\n", mac_node);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  	/* Get the port handles */
  	nph = of_count_phandle_with_args(mac_node, "fsl,fman-ports", NULL);
@@@ -852,9 -850,8 +857,14 @@@
  	if (err < 0)
  		dev_err(dev, "fman_set_mac_active_pause() = %d\n", err);
  
++<<<<<<< HEAD
 +	dev_info(dev, "FMan MAC address: %02hx:%02hx:%02hx:%02hx:%02hx:%02hx\n",
 +		 mac_dev->addr[0], mac_dev->addr[1], mac_dev->addr[2],
 +		 mac_dev->addr[3], mac_dev->addr[4], mac_dev->addr[5]);
++=======
+ 	if (!is_zero_ether_addr(mac_dev->addr))
+ 		dev_info(dev, "FMan MAC address: %pM\n", mac_dev->addr);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  	priv->eth_dev = dpaa_eth_add_device(fman_id, mac_dev);
  	if (IS_ERR(priv->eth_dev)) {
diff --cc drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
index 8379ab1dc6e3,6ee325ad35c5..000000000000
--- a/drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
+++ b/drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
@@@ -1012,9 -1005,7 +1011,13 @@@ static int fs_enet_probe(struct platfor
  	spin_lock_init(&fep->lock);
  	spin_lock_init(&fep->tx_lock);
  
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(ofdev->dev.of_node);
 +	if (mac_addr)
 +		memcpy(ndev->dev_addr, mac_addr, ETH_ALEN);
++=======
+ 	of_get_mac_address(ofdev->dev.of_node, ndev->dev_addr);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  	ret = fep->ops->allocate_bd(ndev);
  	if (ret)
diff --cc drivers/net/ethernet/freescale/gianfar.c
index de9438022f2e,339f9567ef9d..000000000000
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@@ -728,30 -593,73 +728,33 @@@ static int gfar_of_group_count(struct d
  	return num;
  }
  
 -/* Reads the controller's registers to determine what interface
 - * connects it to the PHY.
 - */
 -static phy_interface_t gfar_get_interface(struct net_device *dev)
 +static int gfar_of_init(struct platform_device *ofdev, struct net_device **pdev)
  {
 -	struct gfar_private *priv = netdev_priv(dev);
 -	struct gfar __iomem *regs = priv->gfargrp[0].regs;
 -	u32 ecntrl;
 -
 -	ecntrl = gfar_read(&regs->ecntrl);
 +	const char *model;
++<<<<<<< HEAD
 +	const char *ctype;
 +	const void *mac_addr;
++=======
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
 +	int err = 0, i;
 +	struct net_device *dev = NULL;
 +	struct gfar_private *priv = NULL;
 +	struct device_node *np = ofdev->dev.of_node;
 +	struct device_node *child = NULL;
 +	u32 stash_len = 0;
 +	u32 stash_idx = 0;
 +	unsigned int num_tx_qs, num_rx_qs;
 +	unsigned short mode, poll_mode;
  
 -	if (ecntrl & ECNTRL_SGMII_MODE)
 -		return PHY_INTERFACE_MODE_SGMII;
 +	if (!np)
 +		return -ENODEV;
  
 -	if (ecntrl & ECNTRL_TBI_MODE) {
 -		if (ecntrl & ECNTRL_REDUCED_MODE)
 -			return PHY_INTERFACE_MODE_RTBI;
 -		else
 -			return PHY_INTERFACE_MODE_TBI;
 -	}
 -
 -	if (ecntrl & ECNTRL_REDUCED_MODE) {
 -		if (ecntrl & ECNTRL_REDUCED_MII_MODE) {
 -			return PHY_INTERFACE_MODE_RMII;
 -		}
 -		else {
 -			phy_interface_t interface = priv->interface;
 -
 -			/* This isn't autodetected right now, so it must
 -			 * be set by the device tree or platform code.
 -			 */
 -			if (interface == PHY_INTERFACE_MODE_RGMII_ID)
 -				return PHY_INTERFACE_MODE_RGMII_ID;
 -
 -			return PHY_INTERFACE_MODE_RGMII;
 -		}
 -	}
 -
 -	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_GIGABIT)
 -		return PHY_INTERFACE_MODE_GMII;
 -
 -	return PHY_INTERFACE_MODE_MII;
 -}
 -
 -static int gfar_of_init(struct platform_device *ofdev, struct net_device **pdev)
 -{
 -	const char *model;
 -	int err = 0, i;
 -	phy_interface_t interface;
 -	struct net_device *dev = NULL;
 -	struct gfar_private *priv = NULL;
 -	struct device_node *np = ofdev->dev.of_node;
 -	struct device_node *child = NULL;
 -	u32 stash_len = 0;
 -	u32 stash_idx = 0;
 -	unsigned int num_tx_qs, num_rx_qs;
 -	unsigned short mode, poll_mode;
 -
 -	if (!np)
 -		return -ENODEV;
 -
 -	if (of_device_is_compatible(np, "fsl,etsec2")) {
 -		mode = MQ_MG_MODE;
 -		poll_mode = GFAR_SQ_POLLING;
 -	} else {
 -		mode = SQ_SG_MODE;
 -		poll_mode = GFAR_SQ_POLLING;
 +	if (of_device_is_compatible(np, "fsl,etsec2")) {
 +		mode = MQ_MG_MODE;
 +		poll_mode = GFAR_SQ_POLLING;
 +	} else {
 +		mode = SQ_SG_MODE;
 +		poll_mode = GFAR_SQ_POLLING;
  	}
  
  	if (mode == SQ_SG_MODE) {
@@@ -871,10 -781,11 +874,18 @@@
  	if (stash_len || stash_idx)
  		priv->device_flags |= FSL_GIANFAR_DEV_HAS_BUF_STASHING;
  
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(np);
 +
 +	if (mac_addr)
 +		memcpy(dev->dev_addr, mac_addr, ETH_ALEN);
++=======
+ 	err = of_get_mac_address(np, dev->dev_addr);
+ 	if (err) {
+ 		eth_hw_addr_random(dev);
+ 		dev_info(&ofdev->dev, "Using random MAC address: %pM\n", dev->dev_addr);
+ 	}
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  	if (model && !strcasecmp(model, "TSEC"))
  		priv->device_flags |= FSL_GIANFAR_DEV_HAS_GIGABIT |
diff --cc drivers/net/ethernet/freescale/ucc_geth.c
index 2e8e7a2fde71,e0936510fa34..000000000000
--- a/drivers/net/ethernet/freescale/ucc_geth.c
+++ b/drivers/net/ethernet/freescale/ucc_geth.c
@@@ -3687,8 -3562,6 +3687,11 @@@ static int ucc_geth_probe(struct platfo
  	struct resource res;
  	int err, ucc_num, max_speed = 0;
  	const unsigned int *prop;
++<<<<<<< HEAD
 +	const char *sprop;
 +	const void *mac_addr;
++=======
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  	phy_interface_t phy_interface;
  	static const int enet_to_speed[] = {
  		SPEED_10, SPEED_10, SPEED_10,
@@@ -3897,9 -3732,7 +3900,13 @@@
  		goto err_free_netdev;
  	}
  
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(np);
 +	if (mac_addr)
 +		memcpy(dev->dev_addr, mac_addr, ETH_ALEN);
++=======
+ 	of_get_mac_address(np, dev->dev_addr);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  	ugeth->ug_info = ug_info;
  	ugeth->dev = device;
diff --cc drivers/net/ethernet/hisilicon/hisi_femac.c
index 2c2808830e95,3c4db4a6b431..000000000000
--- a/drivers/net/ethernet/hisilicon/hisi_femac.c
+++ b/drivers/net/ethernet/hisilicon/hisi_femac.c
@@@ -869,10 -841,8 +868,15 @@@ static int hisi_femac_drv_probe(struct 
  			   (unsigned long)phy->phy_id,
  			   phy_modes(phy->interface));
  
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(node);
 +	if (mac_addr)
 +		ether_addr_copy(ndev->dev_addr, mac_addr);
 +	if (!is_valid_ether_addr(ndev->dev_addr)) {
++=======
+ 	ret = of_get_mac_address(node, ndev->dev_addr);
+ 	if (ret) {
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		eth_hw_addr_random(ndev);
  		dev_warn(dev, "using random MAC address %pM\n",
  			 ndev->dev_addr);
diff --cc drivers/net/ethernet/hisilicon/hix5hd2_gmac.c
index 1d55968d4e6b,c1aae0fca5e9..000000000000
--- a/drivers/net/ethernet/hisilicon/hix5hd2_gmac.c
+++ b/drivers/net/ethernet/hisilicon/hix5hd2_gmac.c
@@@ -1102,9 -1097,7 +1102,8 @@@ static int hix5hd2_dev_probe(struct pla
  	const struct of_device_id *of_id = NULL;
  	struct net_device *ndev;
  	struct hix5hd2_priv *priv;
 +	struct resource *res;
  	struct mii_bus *bus;
- 	const char *mac_addr;
  	int ret;
  
  	ndev = alloc_etherdev(sizeof(struct hix5hd2_priv));
@@@ -1229,10 -1219,8 +1228,15 @@@
  		goto out_phy_node;
  	}
  
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(node);
 +	if (mac_addr)
 +		ether_addr_copy(ndev->dev_addr, mac_addr);
 +	if (!is_valid_ether_addr(ndev->dev_addr)) {
++=======
+ 	ret = of_get_mac_address(node, ndev->dev_addr);
+ 	if (ret) {
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		eth_hw_addr_random(ndev);
  		netdev_warn(ndev, "using random MAC address %pM\n",
  			    ndev->dev_addr);
diff --cc drivers/net/ethernet/marvell/mv643xx_eth.c
index 8772a715952f,d207bfcaf31d..000000000000
--- a/drivers/net/ethernet/marvell/mv643xx_eth.c
+++ b/drivers/net/ethernet/marvell/mv643xx_eth.c
@@@ -2752,9 -2732,7 +2751,13 @@@ static int mv643xx_eth_shared_of_add_po
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(pnp);
 +	if (mac_addr)
 +		memcpy(ppd.mac_addr, mac_addr, ETH_ALEN);
++=======
+ 	of_get_mac_address(pnp, ppd.mac_addr);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  	mv643xx_eth_property(pnp, "tx-queue-size", ppd.tx_queue_size);
  	mv643xx_eth_property(pnp, "tx-sram-addr", ppd.tx_sram_addr);
diff --cc drivers/net/ethernet/marvell/mvneta.c
index 304c49ad6c9b,7d5cd9bc6c99..000000000000
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@@ -4331,11 -5140,11 +4331,15 @@@ static int mvneta_probe(struct platform
  	struct mvneta_port *pp;
  	struct net_device *dev;
  	struct phylink *phylink;
++<<<<<<< HEAD
 +	const char *dt_mac_addr;
++=======
+ 	struct phy *comphy;
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  	char hw_mac_addr[ETH_ALEN];
 -	phy_interface_t phy_mode;
  	const char *mac_from;
  	int tx_csum_limit;
 +	int phy_mode;
  	int err;
  	int cpu;
  
@@@ -4423,10 -5236,9 +4427,16 @@@
  		goto err_free_ports;
  	}
  
++<<<<<<< HEAD
 +	dt_mac_addr = of_get_mac_address(dn);
 +	if (dt_mac_addr) {
 +		mac_from = "device tree";
 +		memcpy(dev->dev_addr, dt_mac_addr, ETH_ALEN);
++=======
+ 	err = of_get_mac_address(dn, dev->dev_addr);
+ 	if (!err) {
+ 		mac_from = "device tree";
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  	} else {
  		mvneta_get_mac_addr(pp, hw_mac_addr);
  		if (is_valid_ether_addr(hw_mac_addr)) {
diff --cc drivers/net/ethernet/marvell/pxa168_eth.c
index 8acd668c1a43,e967867828d8..000000000000
--- a/drivers/net/ethernet/marvell/pxa168_eth.c
+++ b/drivers/net/ethernet/marvell/pxa168_eth.c
@@@ -1455,12 -1434,8 +1454,17 @@@ static int pxa168_eth_probe(struct plat
  
  	INIT_WORK(&pep->tx_timeout_task, pxa168_eth_tx_timeout_task);
  
++<<<<<<< HEAD
 +	if (pdev->dev.of_node)
 +		mac_addr = of_get_mac_address(pdev->dev.of_node);
 +
 +	if (mac_addr && is_valid_ether_addr(mac_addr)) {
 +		ether_addr_copy(dev->dev_addr, mac_addr);
 +	} else {
++=======
+ 	err = of_get_mac_address(pdev->dev.of_node, dev->dev_addr);
+ 	if (err) {
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		/* try reading the mac address, if set by the bootloader */
  		pxa168_eth_get_mac_address(dev, dev->dev_addr);
  		if (!is_valid_ether_addr(dev->dev_addr)) {
diff --cc drivers/net/ethernet/marvell/sky2.c
index 0e01b4486d17,222c32367b2c..000000000000
--- a/drivers/net/ethernet/marvell/sky2.c
+++ b/drivers/net/ethernet/marvell/sky2.c
@@@ -4820,10 -4798,8 +4820,15 @@@ static struct net_device *sky2_init_net
  	 * 1) from device tree data
  	 * 2) from internal registers set by bootloader
  	 */
++<<<<<<< HEAD
 +	iap = of_get_mac_address(hw->pdev->dev.of_node);
 +	if (iap)
 +		memcpy(dev->dev_addr, iap, ETH_ALEN);
 +	else
++=======
+ 	ret = of_get_mac_address(hw->pdev->dev.of_node, dev->dev_addr);
+ 	if (ret)
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		memcpy_fromio(dev->dev_addr, hw->regs + B2_MAC_1 + port * 8,
  			      ETH_ALEN);
  
diff --cc drivers/net/ethernet/mediatek/mtk_eth_soc.c
index e558deb9449b,6b00c12c6c43..000000000000
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@@ -2030,14 -2484,11 +2030,20 @@@ static int __init mtk_init(struct net_d
  {
  	struct mtk_mac *mac = netdev_priv(dev);
  	struct mtk_eth *eth = mac->hw;
- 	const char *mac_addr;
+ 	int ret;
  
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(mac->of_node);
 +	if (mac_addr)
 +		ether_addr_copy(dev->dev_addr, mac_addr);
 +
 +	/* If the mac address is invalid, use random mac address  */
 +	if (!is_valid_ether_addr(dev->dev_addr)) {
++=======
+ 	ret = of_get_mac_address(mac->of_node, dev->dev_addr);
+ 	if (ret) {
+ 		/* If the mac address is invalid, use random mac address */
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		eth_hw_addr_random(dev);
  		dev_err(eth->dev, "generated random MAC address %pM\n",
  			dev->dev_addr);
diff --cc drivers/net/ethernet/micrel/ks8851.c
index bd6e9014bc74,13eef6e9bd2d..000000000000
--- a/drivers/net/ethernet/micrel/ks8851.c
+++ b/drivers/net/ethernet/micrel/ks8851.c
@@@ -413,14 -190,13 +413,19 @@@ static void ks8851_read_mac_addr(struc
   * we try that. If no valid mac address is found we use eth_random_addr()
   * to create a new one.
   */
 -static void ks8851_init_mac(struct ks8851_net *ks, struct device_node *np)
 +static void ks8851_init_mac(struct ks8851_net *ks)
  {
  	struct net_device *dev = ks->netdev;
- 	const u8 *mac_addr;
+ 	int ret;
  
++<<<<<<< HEAD:drivers/net/ethernet/micrel/ks8851.c
 +	mac_addr = of_get_mac_address(ks->spidev->dev.of_node);
 +	if (mac_addr) {
 +		memcpy(dev->dev_addr, mac_addr, ETH_ALEN);
++=======
+ 	ret = of_get_mac_address(np, dev->dev_addr);
+ 	if (!ret) {
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address()):drivers/net/ethernet/micrel/ks8851_common.c
  		ks8851_write_mac_addr(dev);
  		return;
  	}
diff --cc drivers/net/ethernet/microchip/lan743x_main.c
index ccc1e25df20b,dae10328c6cf..000000000000
--- a/drivers/net/ethernet/microchip/lan743x_main.c
+++ b/drivers/net/ethernet/microchip/lan743x_main.c
@@@ -2669,6 -2787,8 +2669,11 @@@ static int lan743x_pcidev_probe(struct 
  			      NETIF_MSG_IFDOWN | NETIF_MSG_TX_QUEUED;
  	netdev->max_mtu = LAN743X_MAX_FRAME_SIZE;
  
++<<<<<<< HEAD
++=======
+ 	of_get_mac_address(pdev->dev.of_node, adapter->mac_address);
+ 
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  	ret = lan743x_pci_init(adapter, pdev);
  	if (ret)
  		goto return_error;
diff --cc drivers/net/ethernet/nxp/lpc_eth.c
index f378a450e51b,64c6842bd452..000000000000
--- a/drivers/net/ethernet/nxp/lpc_eth.c
+++ b/drivers/net/ethernet/nxp/lpc_eth.c
@@@ -1382,9 -1350,7 +1382,13 @@@ static int lpc_eth_drv_probe(struct pla
  	__lpc_get_mac(pldat, ndev->dev_addr);
  
  	if (!is_valid_ether_addr(ndev->dev_addr)) {
++<<<<<<< HEAD
 +		const char *macaddr = of_get_mac_address(pdev->dev.of_node);
 +		if (macaddr)
 +			memcpy(ndev->dev_addr, macaddr, ETH_ALEN);
++=======
+ 		of_get_mac_address(np, ndev->dev_addr);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  	}
  	if (!is_valid_ether_addr(ndev->dev_addr))
  		eth_hw_addr_random(ndev);
diff --cc drivers/net/ethernet/qualcomm/qca_spi.c
index 0d2c213bf52e,ab9b02574a15..000000000000
--- a/drivers/net/ethernet/qualcomm/qca_spi.c
+++ b/drivers/net/ethernet/qualcomm/qca_spi.c
@@@ -930,12 -962,8 +930,17 @@@ qca_spi_probe(struct spi_device *spi
  
  	spi_set_drvdata(spi, qcaspi_devs);
  
++<<<<<<< HEAD
 +	mac = of_get_mac_address(spi->dev.of_node);
 +
 +	if (mac)
 +		ether_addr_copy(qca->net_dev->dev_addr, mac);
 +
 +	if (!is_valid_ether_addr(qca->net_dev->dev_addr)) {
++=======
+ 	ret = of_get_mac_address(spi->dev.of_node, qca->net_dev->dev_addr);
+ 	if (ret) {
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		eth_hw_addr_random(qca->net_dev);
  		dev_info(&spi->dev, "Using random MAC address: %pM\n",
  			 qca->net_dev->dev_addr);
diff --cc drivers/net/ethernet/qualcomm/qca_uart.c
index 9d60b90939e6,bcdeca7b3366..000000000000
--- a/drivers/net/ethernet/qualcomm/qca_uart.c
+++ b/drivers/net/ethernet/qualcomm/qca_uart.c
@@@ -349,12 -347,8 +348,17 @@@ static int qca_uart_probe(struct serdev
  
  	of_property_read_u32(serdev->dev.of_node, "current-speed", &speed);
  
++<<<<<<< HEAD
 +	mac = of_get_mac_address(serdev->dev.of_node);
 +
 +	if (mac)
 +		ether_addr_copy(qca->net_dev->dev_addr, mac);
 +
 +	if (!is_valid_ether_addr(qca->net_dev->dev_addr)) {
++=======
+ 	ret = of_get_mac_address(serdev->dev.of_node, qca->net_dev->dev_addr);
+ 	if (ret) {
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		eth_hw_addr_random(qca->net_dev);
  		dev_info(&serdev->dev, "Using random MAC address: %pM\n",
  			 qca->net_dev->dev_addr);
diff --cc drivers/net/ethernet/renesas/ravb_main.c
index 2763ef5c80b3,8c84c40ab9a0..000000000000
--- a/drivers/net/ethernet/renesas/ravb_main.c
+++ b/drivers/net/ethernet/renesas/ravb_main.c
@@@ -119,11 -109,13 +119,19 @@@ static void ravb_set_buffer_align(struc
   * Ethernet AVB device doesn't have ROM for MAC address.
   * This function gets the MAC address that was used by a bootloader.
   */
- static void ravb_read_mac_address(struct net_device *ndev, const u8 *mac)
+ static void ravb_read_mac_address(struct device_node *np,
+ 				  struct net_device *ndev)
  {
++<<<<<<< HEAD
 +	if (mac) {
 +		ether_addr_copy(ndev->dev_addr, mac);
 +	} else {
++=======
+ 	int ret;
+ 
+ 	ret = of_get_mac_address(np, ndev->dev_addr);
+ 	if (ret) {
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		u32 mahr = ravb_read(ndev, MAHR);
  		u32 malr = ravb_read(ndev, MALR);
  
diff --cc drivers/net/ethernet/renesas/sh_eth.c
index d3bb8450ca29,c5b154868c1f..000000000000
--- a/drivers/net/ethernet/renesas/sh_eth.c
+++ b/drivers/net/ethernet/renesas/sh_eth.c
@@@ -3098,17 -3169,19 +3098,26 @@@ static struct sh_eth_plat_data *sh_eth_
  {
  	struct device_node *np = dev->of_node;
  	struct sh_eth_plat_data *pdata;
++<<<<<<< HEAD
 +	const char *mac_addr;
++=======
+ 	phy_interface_t interface;
+ 	int ret;
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
  	if (!pdata)
  		return NULL;
  
 -	ret = of_get_phy_mode(np, &interface);
 -	if (ret)
 -		return NULL;
 -	pdata->phy_interface = interface;
 +	pdata->phy_interface = of_get_phy_mode(np);
  
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(np);
 +	if (mac_addr)
 +		memcpy(pdata->mac_addr, mac_addr, ETH_ALEN);
++=======
+ 	of_get_mac_address(np, pdata->mac_addr);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  	pdata->no_ether_link =
  		of_property_read_bool(np, "renesas,no-ether-link");
diff --cc drivers/net/ethernet/samsung/sxgbe/sxgbe_platform.c
index fbd00cb0cb7d,4639ed9438a3..000000000000
--- a/drivers/net/ethernet/samsung/sxgbe/sxgbe_platform.c
+++ b/drivers/net/ethernet/samsung/sxgbe/sxgbe_platform.c
@@@ -37,8 -34,9 +36,14 @@@ static int sxgbe_probe_config_dt(struc
  	if (!np)
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	*mac = of_get_mac_address(np);
 +	plat->interface = of_get_phy_mode(np);
++=======
+ 	err = of_get_phy_mode(np, &plat->interface);
+ 	if (err && err != -ENODEV)
+ 		return err;
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  	plat->bus_id = of_alias_get_id(np, "ethernet");
  	if (plat->bus_id < 0)
@@@ -124,8 -118,7 +127,12 @@@ static int sxgbe_platform_probe(struct 
  	}
  
  	/* Get MAC address if available (DT) */
++<<<<<<< HEAD
 +	if (mac)
 +		ether_addr_copy(priv->dev->dev_addr, mac);
++=======
+ 	of_get_mac_address(node, priv->dev->dev_addr);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  	/* Get the TX/RX IRQ numbers */
  	for (i = 0, chan = 1; i < SXGBE_TX_QUEUES; i++) {
diff --cc drivers/net/ethernet/socionext/sni_ave.c
index 633d0138af15,fcbb4bb31408..000000000000
--- a/drivers/net/ethernet/socionext/sni_ave.c
+++ b/drivers/net/ethernet/socionext/sni_ave.c
@@@ -1546,8 -1559,6 +1546,11 @@@ static int ave_probe(struct platform_de
  	struct ave_private *priv;
  	struct net_device *ndev;
  	struct device_node *np;
++<<<<<<< HEAD
 +	struct resource	*res;
 +	const void *mac_addr;
++=======
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  	void __iomem *base;
  	const char *name;
  	int i, irq, ret;
@@@ -1591,12 -1599,9 +1594,18 @@@
  
  	ndev->max_mtu = AVE_MAX_ETHFRAME - (ETH_HLEN + ETH_FCS_LEN);
  
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(np);
 +	if (mac_addr)
 +		ether_addr_copy(ndev->dev_addr, mac_addr);
 +
 +	/* if the mac address is invalid, use random mac address */
 +	if (!is_valid_ether_addr(ndev->dev_addr)) {
++=======
+ 	ret = of_get_mac_address(np, ndev->dev_addr);
+ 	if (ret) {
+ 		/* if the mac address is invalid, use random mac address */
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		eth_hw_addr_random(ndev);
  		dev_warn(dev, "Using random MAC address: %pM\n",
  			 ndev->dev_addr);
diff --cc drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
index a91adf929fa3,4422baeed3d8..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
@@@ -1177,7 -1217,13 +1177,17 @@@ static int sun8i_dwmac_probe(struct pla
  		return ret;
  	}
  
++<<<<<<< HEAD
 +	plat_dat->interface = of_get_phy_mode(dev->of_node);
++=======
+ 	ret = of_get_phy_mode(dev->of_node, &interface);
+ 	if (ret)
+ 		return -EINVAL;
+ 
+ 	plat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
+ 	if (IS_ERR(plat_dat))
+ 		return PTR_ERR(plat_dat);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  	/* platform data specifying hardware features and callbacks.
  	 * hardware features were copied from Allwinner drivers.
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 131ec0b508ae,328aeb2cd276..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@@ -5564,7 -6016,7 +5564,11 @@@ int stmmac_dvr_probe(struct device *dev
  	for (i = 0; i < MTL_MAX_TX_QUEUES; i++)
  		priv->tx_irq[i] = res->tx_irq[i];
  
++<<<<<<< HEAD
 +	if (res->mac)
++=======
+ 	if (!is_zero_ether_addr(res->mac))
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		memcpy(priv->dev->dev_addr, res->mac, ETH_ALEN);
  
  	dev_set_drvdata(device, priv->dev);
diff --cc drivers/net/ethernet/ti/cpsw.c
index 49ae576ed25d,c0cd7de88316..000000000000
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@@ -2841,10 -1367,8 +2840,15 @@@ static int cpsw_probe_dt(struct cpsw_pl
  		}
  
  no_phy_slave:
++<<<<<<< HEAD
 +		mac_addr = of_get_mac_address(slave_node);
 +		if (mac_addr) {
 +			memcpy(slave_data->mac_addr, mac_addr, ETH_ALEN);
 +		} else {
++=======
+ 		ret = of_get_mac_address(slave_node, slave_data->mac_addr);
+ 		if (ret) {
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  			ret = ti_cm_get_macid(&pdev->dev, i,
  					      slave_data->mac_addr);
  			if (ret)
diff --cc drivers/net/ethernet/ti/davinci_emac.c
index e231c64fe973,14e7da7d302f..000000000000
--- a/drivers/net/ethernet/ti/davinci_emac.c
+++ b/drivers/net/ethernet/ti/davinci_emac.c
@@@ -1720,11 -1698,8 +1719,16 @@@ davinci_emac_of_get_pdata(struct platfo
  	np = pdev->dev.of_node;
  	pdata->version = EMAC_VERSION_2;
  
++<<<<<<< HEAD
 +	if (!is_valid_ether_addr(pdata->mac_addr)) {
 +		mac_addr = of_get_mac_address(np);
 +		if (mac_addr)
 +			ether_addr_copy(pdata->mac_addr, mac_addr);
 +	}
++=======
+ 	if (!is_valid_ether_addr(pdata->mac_addr))
+ 		of_get_mac_address(np, pdata->mac_addr);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  	of_property_read_u32(np, "ti,davinci-ctrl-reg-offset",
  			     &pdata->ctrl_reg_offset);
diff --cc drivers/net/ethernet/ti/netcp_core.c
index 10d9b08ed584,9030e619e543..000000000000
--- a/drivers/net/ethernet/ti/netcp_core.c
+++ b/drivers/net/ethernet/ti/netcp_core.c
@@@ -2050,11 -2035,9 +2049,17 @@@ static int netcp_create_interface(struc
  		devm_iounmap(dev, efuse);
  		devm_release_mem_region(dev, res.start, size);
  	} else {
++<<<<<<< HEAD
 +		mac_addr = of_get_mac_address(node_interface);
 +		if (mac_addr)
 +			ether_addr_copy(ndev->dev_addr, mac_addr);
 +		else
 +			random_ether_addr(ndev->dev_addr);
++=======
+ 		ret = of_get_mac_address(node_interface, ndev->dev_addr);
+ 		if (ret)
+ 			eth_random_addr(ndev->dev_addr);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  	}
  
  	ret = of_property_read_string(node_interface, "rx-channel",
diff --cc drivers/net/ethernet/wiznet/w5100-spi.c
index 93a2d3c07303,2b84848dc26a..000000000000
--- a/drivers/net/ethernet/wiznet/w5100-spi.c
+++ b/drivers/net/ethernet/wiznet/w5100-spi.c
@@@ -410,14 -410,38 +410,24 @@@ static const struct w5100_ops w5500_op
  	.init = w5500_spi_init,
  };
  
 -static const struct of_device_id w5100_of_match[] = {
 -	{ .compatible = "wiznet,w5100", .data = (const void*)W5100, },
 -	{ .compatible = "wiznet,w5200", .data = (const void*)W5200, },
 -	{ .compatible = "wiznet,w5500", .data = (const void*)W5500, },
 -	{ },
 -};
 -MODULE_DEVICE_TABLE(of, w5100_of_match);
 -
  static int w5100_spi_probe(struct spi_device *spi)
  {
 -	const struct of_device_id *of_id;
 +	const struct spi_device_id *id = spi_get_device_id(spi);
  	const struct w5100_ops *ops;
++<<<<<<< HEAD
++=======
+ 	kernel_ulong_t driver_data;
+ 	const void *mac = NULL;
+ 	u8 tmpmac[ETH_ALEN];
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  	int priv_size;
- 	const void *mac = of_get_mac_address(spi->dev.of_node);
+ 	int ret;
+ 
+ 	ret = of_get_mac_address(spi->dev.of_node, tmpmac);
+ 	if (!ret)
+ 		mac = tmpmac;
  
 -	if (spi->dev.of_node) {
 -		of_id = of_match_device(w5100_of_match, &spi->dev);
 -		if (!of_id)
 -			return -ENODEV;
 -		driver_data = (kernel_ulong_t)of_id->data;
 -	} else {
 -		driver_data = spi_get_device_id(spi)->driver_data;
 -	}
 -
 -	switch (driver_data) {
 +	switch (id->driver_data) {
  	case W5100:
  		ops = &w5100_spi_ops;
  		priv_size = 0;
diff --cc drivers/net/ethernet/xilinx/ll_temac_main.c
index 60abc9250f56,a1f5f07f4ca9..000000000000
--- a/drivers/net/ethernet/xilinx/ll_temac_main.c
+++ b/drivers/net/ethernet/xilinx/ll_temac_main.c
@@@ -974,15 -1339,21 +974,15 @@@ static const struct ethtool_ops temac_e
  	.get_ts_info = ethtool_op_get_ts_info,
  	.get_link_ksettings = phy_ethtool_get_link_ksettings,
  	.set_link_ksettings = phy_ethtool_set_link_ksettings,
 -	.get_ringparam	= ll_temac_ethtools_get_ringparam,
 -	.set_ringparam	= ll_temac_ethtools_set_ringparam,
 -	.get_coalesce	= ll_temac_ethtools_get_coalesce,
 -	.set_coalesce	= ll_temac_ethtools_set_coalesce,
  };
  
 -static int temac_probe(struct platform_device *pdev)
 +static int temac_of_probe(struct platform_device *op)
  {
 -	struct ll_temac_platform_data *pdata = dev_get_platdata(&pdev->dev);
 -	struct device_node *temac_np = dev_of_node(&pdev->dev), *dma_np;
 +	struct device_node *np;
  	struct temac_local *lp;
  	struct net_device *ndev;
- 	const void *addr;
+ 	u8 addr[ETH_ALEN];
  	__be32 *p;
 -	bool little_endian;
  	int rc = 0;
  
  	/* Init network device structure */
@@@ -1028,68 -1432,139 +1028,82 @@@
  
  	/* Setup checksum offload, but default to off if not specified */
  	lp->temac_features = 0;
 -	if (temac_np) {
 -		p = (__be32 *)of_get_property(temac_np, "xlnx,txcsum", NULL);
 -		if (p && be32_to_cpu(*p))
 -			lp->temac_features |= TEMAC_FEATURE_TX_CSUM;
 -		p = (__be32 *)of_get_property(temac_np, "xlnx,rxcsum", NULL);
 -		if (p && be32_to_cpu(*p))
 -			lp->temac_features |= TEMAC_FEATURE_RX_CSUM;
 -	} else if (pdata) {
 -		if (pdata->txcsum)
 -			lp->temac_features |= TEMAC_FEATURE_TX_CSUM;
 -		if (pdata->rxcsum)
 -			lp->temac_features |= TEMAC_FEATURE_RX_CSUM;
 -	}
 -	if (lp->temac_features & TEMAC_FEATURE_TX_CSUM)
 +	p = (__be32 *)of_get_property(op->dev.of_node, "xlnx,txcsum", NULL);
 +	if (p && be32_to_cpu(*p)) {
 +		lp->temac_features |= TEMAC_FEATURE_TX_CSUM;
  		/* Can checksum TCP/UDP over IPv4. */
  		ndev->features |= NETIF_F_IP_CSUM;
 +	}
 +	p = (__be32 *)of_get_property(op->dev.of_node, "xlnx,rxcsum", NULL);
 +	if (p && be32_to_cpu(*p))
 +		lp->temac_features |= TEMAC_FEATURE_RX_CSUM;
 +
 +	/* Find the DMA node, map the DMA registers, and decode the DMA IRQs */
 +	np = of_parse_phandle(op->dev.of_node, "llink-connected", 0);
 +	if (!np) {
 +		dev_err(&op->dev, "could not find DMA node\n");
 +		rc = -ENODEV;
 +		goto err_iounmap;
 +	}
  
 -	/* Defaults for IRQ delay/coalescing setup.  These are
 -	 * configuration values, so does not belong in device-tree.
 -	 */
 -	lp->coalesce_delay_tx = 0x10;
 -	lp->coalesce_count_tx = 0x22;
 -	lp->coalesce_delay_rx = 0xff;
 -	lp->coalesce_count_rx = 0x07;
 -
 -	/* Setup LocalLink DMA */
 -	if (temac_np) {
 -		/* Find the DMA node, map the DMA registers, and
 -		 * decode the DMA IRQs.
 -		 */
 -		dma_np = of_parse_phandle(temac_np, "llink-connected", 0);
 -		if (!dma_np) {
 -			dev_err(&pdev->dev, "could not find DMA node\n");
 -			return -ENODEV;
 -		}
 -
 -		/* Setup the DMA register accesses, could be DCR or
 -		 * memory mapped.
 -		 */
 -		if (temac_dcr_setup(lp, pdev, dma_np)) {
 -			/* no DCR in the device tree, try non-DCR */
 -			lp->sdma_regs = devm_of_iomap(&pdev->dev, dma_np, 0,
 -						      NULL);
 -			if (IS_ERR(lp->sdma_regs)) {
 -				dev_err(&pdev->dev,
 -					"unable to map DMA registers\n");
 -				of_node_put(dma_np);
 -				return PTR_ERR(lp->sdma_regs);
 -			}
 -			if (of_get_property(dma_np, "little-endian", NULL)) {
 -				lp->dma_in = temac_dma_in32_le;
 -				lp->dma_out = temac_dma_out32_le;
 -			} else {
 -				lp->dma_in = temac_dma_in32_be;
 -				lp->dma_out = temac_dma_out32_be;
 -			}
 -			dev_dbg(&pdev->dev, "MEM base: %p\n", lp->sdma_regs);
 -		}
 -
 -		/* Get DMA RX and TX interrupts */
 -		lp->rx_irq = irq_of_parse_and_map(dma_np, 0);
 -		lp->tx_irq = irq_of_parse_and_map(dma_np, 1);
 +	/* Setup the DMA register accesses, could be DCR or memory mapped */
 +	if (temac_dcr_setup(lp, op, np)) {
  
 -		/* Finished with the DMA node; drop the reference */
 -		of_node_put(dma_np);
 -	} else if (pdata) {
 -		/* 2nd memory resource specifies DMA registers */
 -		lp->sdma_regs = devm_platform_ioremap_resource(pdev, 1);
 -		if (IS_ERR(lp->sdma_regs)) {
 -			dev_err(&pdev->dev,
 -				"could not map DMA registers\n");
 -			return PTR_ERR(lp->sdma_regs);
 -		}
 -		if (pdata->dma_little_endian) {
 -			lp->dma_in = temac_dma_in32_le;
 -			lp->dma_out = temac_dma_out32_le;
 +		/* no DCR in the device tree, try non-DCR */
 +		lp->sdma_regs = of_iomap(np, 0);
 +		if (lp->sdma_regs) {
 +			lp->dma_in = temac_dma_in32;
 +			lp->dma_out = temac_dma_out32;
 +			dev_dbg(&op->dev, "MEM base: %p\n", lp->sdma_regs);
  		} else {
 -			lp->dma_in = temac_dma_in32_be;
 -			lp->dma_out = temac_dma_out32_be;
 +			dev_err(&op->dev, "unable to map DMA registers\n");
 +			of_node_put(np);
 +			goto err_iounmap;
  		}
 +	}
  
 -		/* Get DMA RX and TX interrupts */
 -		lp->rx_irq = platform_get_irq(pdev, 0);
 -		lp->tx_irq = platform_get_irq(pdev, 1);
 +	lp->rx_irq = irq_of_parse_and_map(np, 0);
 +	lp->tx_irq = irq_of_parse_and_map(np, 1);
  
 -		/* IRQ delay/coalescing setup */
 -		if (pdata->tx_irq_timeout || pdata->tx_irq_count) {
 -			lp->coalesce_delay_tx = pdata->tx_irq_timeout;
 -			lp->coalesce_count_tx = pdata->tx_irq_count;
 -		}
 -		if (pdata->rx_irq_timeout || pdata->rx_irq_count) {
 -			lp->coalesce_delay_rx = pdata->rx_irq_timeout;
 -			lp->coalesce_count_rx = pdata->rx_irq_count;
 -		}
 -	}
 +	of_node_put(np); /* Finished with the DMA node; drop the reference */
  
 -	/* Error handle returned DMA RX and TX interrupts */
 -	if (lp->rx_irq < 0) {
 -		if (lp->rx_irq != -EPROBE_DEFER)
 -			dev_err(&pdev->dev, "could not get DMA RX irq\n");
 -		return lp->rx_irq;
 -	}
 -	if (lp->tx_irq < 0) {
 -		if (lp->tx_irq != -EPROBE_DEFER)
 -			dev_err(&pdev->dev, "could not get DMA TX irq\n");
 -		return lp->tx_irq;
 +	if (!lp->rx_irq || !lp->tx_irq) {
 +		dev_err(&op->dev, "could not determine irqs\n");
 +		rc = -ENOMEM;
 +		goto err_iounmap_2;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (temac_np) {
+ 		/* Retrieve the MAC address */
+ 		rc = of_get_mac_address(temac_np, addr);
+ 		if (rc) {
+ 			dev_err(&pdev->dev, "could not find MAC address\n");
+ 			return -ENODEV;
+ 		}
+ 		temac_init_mac_address(ndev, addr);
+ 	} else if (pdata) {
+ 		temac_init_mac_address(ndev, pdata->mac_addr);
+ 	}
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
 +
 +	/* Retrieve the MAC address */
 +	addr = of_get_mac_address(op->dev.of_node);
 +	if (!addr) {
 +		dev_err(&op->dev, "could not find MAC address\n");
 +		rc = -ENODEV;
 +		goto err_iounmap_2;
 +	}
 +	temac_init_mac_address(ndev, addr);
  
 -	rc = temac_mdio_setup(lp, pdev);
 +	rc = temac_mdio_setup(lp, op->dev.of_node);
  	if (rc)
 -		dev_warn(&pdev->dev, "error registering MDIO bus\n");
 +		dev_warn(&op->dev, "error registering MDIO bus\n");
  
 -	if (temac_np) {
 -		lp->phy_node = of_parse_phandle(temac_np, "phy-handle", 0);
 -		if (lp->phy_node)
 -			dev_dbg(lp->dev, "using PHY node %pOF\n", temac_np);
 -	} else if (pdata) {
 -		snprintf(lp->phy_name, sizeof(lp->phy_name),
 -			 PHY_ID_FMT, lp->mii_bus->id, pdata->phy_addr);
 -		lp->phy_interface = pdata->phy_interface;
 -	}
 +	lp->phy_node = of_parse_phandle(op->dev.of_node, "phy-handle", 0);
 +	if (lp->phy_node)
 +		dev_dbg(lp->dev, "using PHY node %pOF (%p)\n", np, np);
  
  	/* Add the device attributes */
  	rc = sysfs_create_group(&lp->dev->kobj, &temac_attr_group);
diff --cc drivers/net/ethernet/xilinx/xilinx_axienet_main.c
index 25d339e4404a,b508c9453f40..000000000000
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
@@@ -1460,8 -1835,9 +1460,14 @@@ static int axienet_probe(struct platfor
  	struct device_node *np;
  	struct axienet_local *lp;
  	struct net_device *ndev;
++<<<<<<< HEAD
 +	const void *mac_addr;
 +	struct resource *ethres, dmares;
++=======
+ 	struct resource *ethres;
+ 	u8 mac_addr[ETH_ALEN];
+ 	int addr_width = 32;
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  	u32 value;
  
  	ndev = alloc_etherdev(sizeof(*lp));
@@@ -1598,16 -2024,52 +1604,25 @@@
  	if ((lp->rx_irq <= 0) || (lp->tx_irq <= 0)) {
  		dev_err(&pdev->dev, "could not determine irqs\n");
  		ret = -ENOMEM;
 -		goto cleanup_clk;
 -	}
 -
 -	/* Autodetect the need for 64-bit DMA pointers.
 -	 * When the IP is configured for a bus width bigger than 32 bits,
 -	 * writing the MSB registers is mandatory, even if they are all 0.
 -	 * We can detect this case by writing all 1's to one such register
 -	 * and see if that sticks: when the IP is configured for 32 bits
 -	 * only, those registers are RES0.
 -	 * Those MSB registers were introduced in IP v7.1, which we check first.
 -	 */
 -	if ((axienet_ior(lp, XAE_ID_OFFSET) >> 24) >= 0x9) {
 -		void __iomem *desc = lp->dma_regs + XAXIDMA_TX_CDESC_OFFSET + 4;
 -
 -		iowrite32(0x0, desc);
 -		if (ioread32(desc) == 0) {	/* sanity check */
 -			iowrite32(0xffffffff, desc);
 -			if (ioread32(desc) > 0) {
 -				lp->features |= XAE_FEATURE_DMA_64BIT;
 -				addr_width = 64;
 -				dev_info(&pdev->dev,
 -					 "autodetected 64-bit DMA range\n");
 -			}
 -			iowrite32(0x0, desc);
 -		}
 -	}
 -
 -	ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(addr_width));
 -	if (ret) {
 -		dev_err(&pdev->dev, "No suitable DMA available\n");
 -		goto cleanup_clk;
 +		goto free_netdev;
  	}
  
 -	/* Check for Ethernet core IRQ (optional) */
 -	if (lp->eth_irq <= 0)
 -		dev_info(&pdev->dev, "Ethernet core IRQ not defined\n");
 -
  	/* Retrieve the MAC address */
++<<<<<<< HEAD
 +	mac_addr = of_get_mac_address(pdev->dev.of_node);
 +	if (!mac_addr) {
 +		dev_err(&pdev->dev, "could not find MAC address\n");
 +		goto free_netdev;
++=======
+ 	ret = of_get_mac_address(pdev->dev.of_node, mac_addr);
+ 	if (!ret) {
+ 		axienet_set_mac_address(ndev, mac_addr);
+ 	} else {
+ 		dev_warn(&pdev->dev, "could not find MAC address property: %d\n",
+ 			 ret);
+ 		axienet_set_mac_address(ndev, NULL);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  	}
- 	axienet_set_mac_address(ndev, mac_addr);
  
  	lp->coalesce_count_rx = XAXIDMA_DFT_RX_THRESHOLD;
  	lp->coalesce_count_tx = XAXIDMA_DFT_TX_THRESHOLD;
diff --cc drivers/net/ethernet/xilinx/xilinx_emaclite.c
index b1700225a984,d9d58a7dabee..000000000000
--- a/drivers/net/ethernet/xilinx/xilinx_emaclite.c
+++ b/drivers/net/ethernet/xilinx/xilinx_emaclite.c
@@@ -1124,12 -1156,9 +1123,16 @@@ static int xemaclite_of_probe(struct pl
  	lp->next_rx_buf_to_use = 0x0;
  	lp->tx_ping_pong = get_bool(ofdev, "xlnx,tx-ping-pong");
  	lp->rx_ping_pong = get_bool(ofdev, "xlnx,rx-ping-pong");
- 	mac_address = of_get_mac_address(ofdev->dev.of_node);
  
++<<<<<<< HEAD
 +	if (mac_address) {
 +		/* Set the MAC address. */
 +		memcpy(ndev->dev_addr, mac_address, ETH_ALEN);
 +	} else {
++=======
+ 	rc = of_get_mac_address(ofdev->dev.of_node, ndev->dev_addr);
+ 	if (rc) {
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		dev_warn(dev, "No MAC address found, using random\n");
  		eth_hw_addr_random(ndev);
  	}
diff --cc drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
index 0b33de9896b3,e95c101c2711..000000000000
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
@@@ -1000,11 -989,7 +1000,15 @@@ static void rt2x00lib_rate(struct ieee8
  
  void rt2x00lib_set_mac_address(struct rt2x00_dev *rt2x00dev, u8 *eeprom_mac_addr)
  {
++<<<<<<< HEAD
 +	const char *mac_addr;
 +
 +	mac_addr = of_get_mac_address(rt2x00dev->dev->of_node);
 +	if (mac_addr)
 +		ether_addr_copy(eeprom_mac_addr, mac_addr);
++=======
+ 	of_get_mac_address(rt2x00dev->dev->of_node, eeprom_mac_addr);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
  	if (!is_valid_ether_addr(eeprom_mac_addr)) {
  		eth_random_addr(eeprom_mac_addr);
diff --cc drivers/of/of_net.c
index 53189d4022a6,cb77b774bf76..000000000000
--- a/drivers/of/of_net.c
+++ b/drivers/of/of_net.c
@@@ -43,12 -49,32 +43,36 @@@ static int of_get_mac_addr(struct devic
  {
  	struct property *pp = of_find_property(np, name, NULL);
  
- 	if (pp && pp->length == ETH_ALEN && is_valid_ether_addr(pp->value))
- 		return pp->value;
- 	return NULL;
+ 	if (pp && pp->length == ETH_ALEN && is_valid_ether_addr(pp->value)) {
+ 		memcpy(addr, pp->value, ETH_ALEN);
+ 		return 0;
+ 	}
+ 	return -ENODEV;
+ }
+ 
++<<<<<<< HEAD
++/**
++=======
+ static int of_get_mac_addr_nvmem(struct device_node *np, u8 *addr)
+ {
+ 	struct platform_device *pdev = of_find_device_by_node(np);
+ 	int ret;
+ 
+ 	if (!pdev)
+ 		return -ENODEV;
+ 
+ 	ret = nvmem_get_mac_address(&pdev->dev, addr);
+ 	put_device(&pdev->dev);
+ 
+ 	return ret;
  }
  
  /**
+  * of_get_mac_address()
+  * @np:		Caller's Device Node
+  * @addr:	Pointer to a six-byte array for the result
+  *
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
   * Search the device tree for the best MAC address to use.  'mac-address' is
   * checked first, because that is supposed to contain to "most recent" MAC
   * address. If that isn't set, then 'local-mac-address' is checked next,
@@@ -65,58 -93,28 +89,74 @@@
   * addresses.  Some older U-Boots only initialized 'local-mac-address'.  In
   * this case, the real MAC is in 'local-mac-address', and 'mac-address' exists
   * but is all zeros.
++<<<<<<< HEAD
++=======
+  *
+  * Return: 0 on success and errno in case of error.
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  */
- const void *of_get_mac_address(struct device_node *np)
+ int of_get_mac_address(struct device_node *np, u8 *addr)
  {
- 	const void *addr;
+ 	int ret;
  
- 	addr = of_get_mac_addr(np, "mac-address");
- 	if (addr)
- 		return addr;
+ 	if (!np)
+ 		return -ENODEV;
  
- 	addr = of_get_mac_addr(np, "local-mac-address");
- 	if (addr)
- 		return addr;
+ 	ret = of_get_mac_addr(np, "mac-address", addr);
+ 	if (!ret)
+ 		return 0;
  
++<<<<<<< HEAD
 +	return of_get_mac_addr(np, "address");
++=======
+ 	ret = of_get_mac_addr(np, "local-mac-address", addr);
+ 	if (!ret)
+ 		return 0;
+ 
+ 	ret = of_get_mac_addr(np, "address", addr);
+ 	if (!ret)
+ 		return 0;
+ 
+ 	return of_get_mac_addr_nvmem(np, addr);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  }
  EXPORT_SYMBOL(of_get_mac_address);
 +
 +/**
 + * Obtain the MAC address from an nvmem provider named 'mac-address' through
 + * device tree.
 + * On success, copies the new address into memory pointed to by addr and
 + * returns 0. Returns a negative error code otherwise.
 + * @np:		Device tree node containing the nvmem-cells phandle
 + * @addr:	Pointer to receive the MAC address using ether_addr_copy()
 + */
 +int of_get_nvmem_mac_address(struct device_node *np, void *addr)
 +{
 +	struct nvmem_cell *cell;
 +	const void *mac;
 +	size_t len;
 +	int ret;
 +
 +	cell = of_nvmem_cell_get(np, "mac-address");
 +	if (IS_ERR(cell))
 +		return PTR_ERR(cell);
 +
 +	mac = nvmem_cell_read(cell, &len);
 +
 +	nvmem_cell_put(cell);
 +
 +	if (IS_ERR(mac))
 +		return PTR_ERR(mac);
 +
 +	if (len < ETH_ALEN || !is_valid_ether_addr(mac)) {
 +		ret = -EINVAL;
 +	} else {
 +		ether_addr_copy(addr, mac);
 +		ret = 0;
 +	}
 +
 +	kfree(mac);
 +
 +	return ret;
 +}
 +EXPORT_SYMBOL(of_get_nvmem_mac_address);
diff --cc drivers/staging/octeon/ethernet.c
index 400ca9133fd5,da7c2cd8ebb8..000000000000
--- a/drivers/staging/octeon/ethernet.c
+++ b/drivers/staging/octeon/ethernet.c
@@@ -417,14 -407,10 +417,19 @@@ static int cvm_oct_common_set_mac_addre
  int cvm_oct_common_init(struct net_device *dev)
  {
  	struct octeon_ethernet *priv = netdev_priv(dev);
- 	const u8 *mac = NULL;
+ 	int ret;
  
++<<<<<<< HEAD
 +	if (priv->of_node)
 +		mac = of_get_mac_address(priv->of_node);
 +
 +	if (mac)
 +		ether_addr_copy(dev->dev_addr, mac);
 +	else
++=======
+ 	ret = of_get_mac_address(priv->of_node, dev->dev_addr);
+ 	if (ret)
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		eth_hw_addr_random(dev);
  
  	/*
diff --cc include/linux/of_net.h
index 90d81ee9e6a0,daef3b0d9270..000000000000
--- a/include/linux/of_net.h
+++ b/include/linux/of_net.h
@@@ -11,23 -12,18 +11,31 @@@
  #include <linux/of.h>
  
  struct net_device;
++<<<<<<< HEAD
 +extern int of_get_phy_mode(struct device_node *np);
 +extern const void *of_get_mac_address(struct device_node *np);
 +extern int of_get_nvmem_mac_address(struct device_node *np, void *addr);
++=======
+ extern int of_get_phy_mode(struct device_node *np, phy_interface_t *interface);
+ extern int of_get_mac_address(struct device_node *np, u8 *mac);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  extern struct net_device *of_find_net_device_by_node(struct device_node *np);
  #else
 -static inline int of_get_phy_mode(struct device_node *np,
 -				  phy_interface_t *interface)
 +static inline int of_get_phy_mode(struct device_node *np)
  {
  	return -ENODEV;
  }
  
- static inline const void *of_get_mac_address(struct device_node *np)
+ static inline int of_get_mac_address(struct device_node *np, u8 *mac)
  {
++<<<<<<< HEAD
 +	return NULL;
 +}
 +
 +static inline int of_get_nvmem_mac_address(struct device_node *np, void *addr)
 +{
++=======
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  	return -ENODEV;
  }
  
diff --cc include/net/dsa.h
index 043c895b2f6f,1259b0f40684..000000000000
--- a/include/net/dsa.h
+++ b/include/net/dsa.h
@@@ -196,9 -259,11 +196,14 @@@ struct dsa_port 
  	struct dsa_switch	*ds;
  	unsigned int		index;
  	const char		*name;
++<<<<<<< HEAD
 +	const struct dsa_port	*cpu_dp;
++=======
+ 	struct dsa_port		*cpu_dp;
+ 	u8			mac[ETH_ALEN];
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  	struct device_node	*dn;
  	unsigned int		ageing_time;
 -	bool			vlan_filtering;
  	u8			stp_state;
  	struct net_device	*bridge_dev;
  	struct devlink_port	devlink_port;
diff --cc net/dsa/dsa2.c
index 3472b9dc341c,d7c22e3a1fbf..000000000000
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@@ -258,25 -355,49 +258,35 @@@ static void dsa_tree_teardown_default_c
  
  static int dsa_port_setup(struct dsa_port *dp)
  {
 -	struct devlink_port *dlp = &dp->devlink_port;
 -	bool dsa_port_link_registered = false;
 -	bool dsa_port_enabled = false;
 -	int err = 0;
 +	enum devlink_port_flavour flavour;
 +	struct dsa_switch *ds = dp->ds;
 +	int err;
  
 -	if (dp->setup)
 +	if (dp->type == DSA_PORT_TYPE_UNUSED)
  		return 0;
  
 +	memset(&dp->devlink_port, 0, sizeof(dp->devlink_port));
 +
  	switch (dp->type) {
 -	case DSA_PORT_TYPE_UNUSED:
 -		dsa_port_disable(dp);
 -		break;
  	case DSA_PORT_TYPE_CPU:
 -		err = dsa_port_link_register_of(dp);
 -		if (err)
 -			break;
 -		dsa_port_link_registered = true;
 -
 -		err = dsa_port_enable(dp, NULL);
 -		if (err)
 -			break;
 -		dsa_port_enabled = true;
 -
 +		flavour = DEVLINK_PORT_FLAVOUR_CPU;
  		break;
  	case DSA_PORT_TYPE_DSA:
 -		err = dsa_port_link_register_of(dp);
 -		if (err)
 -			break;
 -		dsa_port_link_registered = true;
 -
 -		err = dsa_port_enable(dp, NULL);
 -		if (err)
 -			break;
 -		dsa_port_enabled = true;
 -
 +		flavour = DEVLINK_PORT_FLAVOUR_DSA;
  		break;
++<<<<<<< HEAD
 +	case DSA_PORT_TYPE_USER: /* fall-through */
 +	default:
 +		flavour = DEVLINK_PORT_FLAVOUR_PHYSICAL;
++=======
+ 	case DSA_PORT_TYPE_USER:
+ 		of_get_mac_address(dp->dn, dp->mac);
+ 		err = dsa_slave_create(dp);
+ 		if (err)
+ 			break;
+ 
+ 		devlink_port_type_eth_set(dlp, dp->slave);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  		break;
  	}
  
diff --cc net/dsa/slave.c
index 24cc4de02bd3,9300cb66e500..000000000000
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@@ -1336,14 -1891,19 +1336,21 @@@ int dsa_slave_create(struct dsa_port *p
  		return -ENOMEM;
  
  	slave_dev->features = master->vlan_features | NETIF_F_HW_TC;
 -	if (ds->ops->port_vlan_add && ds->ops->port_vlan_del)
 -		slave_dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
  	slave_dev->hw_features |= NETIF_F_HW_TC;
 -	slave_dev->features |= NETIF_F_LLTX;
  	slave_dev->ethtool_ops = &dsa_slave_ethtool_ops;
++<<<<<<< HEAD
 +	eth_hw_addr_inherit(slave_dev, master);
++=======
+ 	if (!is_zero_ether_addr(port->mac))
+ 		ether_addr_copy(slave_dev->dev_addr, port->mac);
+ 	else
+ 		eth_hw_addr_inherit(slave_dev, master);
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  	slave_dev->priv_flags |= IFF_NO_QUEUE;
  	slave_dev->netdev_ops = &dsa_slave_netdev_ops;
 -	if (ds->ops->port_max_mtu)
 -		slave_dev->max_mtu = ds->ops->port_max_mtu(ds, port->index);
 +	slave_dev->switchdev_ops = &dsa_slave_switchdev_ops;
 +	slave_dev->min_mtu = 0;
 +	slave_dev->max_mtu = ETH_MAX_MTU;
  	SET_NETDEV_DEVTYPE(slave_dev, &dsa_type);
  
  	netdev_for_each_tx_queue(slave_dev, dsa_slave_set_lockdep_class_one,
diff --cc net/ethernet/eth.c
index e7ecb2faf936,9cce612e8976..000000000000
--- a/net/ethernet/eth.c
+++ b/net/ethernet/eth.c
@@@ -542,20 -511,14 +542,30 @@@ unsigned char * __weak arch_get_platfor
  
  int eth_platform_get_mac_address(struct device *dev, u8 *mac_addr)
  {
++<<<<<<< HEAD
 +	const unsigned char *addr;
 +	struct device_node *dp;
 +
 +	if (dev_is_pci(dev))
 +		dp = pci_device_to_OF_node(to_pci_dev(dev));
 +	else
 +		dp = dev->of_node;
 +
 +	addr = NULL;
 +	if (dp)
 +		addr = of_get_mac_address(dp);
 +	if (!addr)
 +		addr = arch_get_platform_mac_address();
++=======
+ 	unsigned char *addr;
+ 	int ret;
+ 
+ 	ret = of_get_mac_address(dev->of_node, mac_addr);
+ 	if (!ret)
+ 		return 0;
++>>>>>>> 83216e3988cd (of: net: pass the dst buffer to of_get_mac_address())
  
+ 	addr = arch_get_platform_mac_address();
  	if (!addr)
  		return -ENODEV;
  
* Unmerged path drivers/net/ethernet/atheros/ag71xx.c
* Unmerged path drivers/net/ethernet/broadcom/bcm4908_enet.c
* Unmerged path drivers/net/ethernet/lantiq_xrx200.c
* Unmerged path drivers/net/ethernet/marvell/prestera/prestera_main.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac-imx.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac-intel-plat.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac-mediatek.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac-qcom-ethqos.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac-visconti.c
* Unmerged path drivers/net/ethernet/ti/am65-cpsw-nuss.c
* Unmerged path drivers/net/ethernet/ti/cpsw_new.c
* Unmerged path drivers/staging/wfx/main.c
* Unmerged path arch/arm/mach-mvebu/kirkwood.c
* Unmerged path arch/powerpc/sysdev/tsi108_dev.c
* Unmerged path drivers/net/ethernet/aeroflex/greth.c
* Unmerged path drivers/net/ethernet/allwinner/sun4i-emac.c
* Unmerged path drivers/net/ethernet/altera/altera_tse_main.c
* Unmerged path drivers/net/ethernet/arc/emac_main.c
* Unmerged path drivers/net/ethernet/atheros/ag71xx.c
* Unmerged path drivers/net/ethernet/broadcom/bcm4908_enet.c
* Unmerged path drivers/net/ethernet/broadcom/bcmsysport.c
* Unmerged path drivers/net/ethernet/broadcom/bgmac-bcma.c
* Unmerged path drivers/net/ethernet/broadcom/bgmac-platform.c
* Unmerged path drivers/net/ethernet/cadence/macb_main.c
* Unmerged path drivers/net/ethernet/cavium/octeon/octeon_mgmt.c
* Unmerged path drivers/net/ethernet/cavium/thunder/thunder_bgx.c
* Unmerged path drivers/net/ethernet/davicom/dm9000.c
* Unmerged path drivers/net/ethernet/ethoc.c
* Unmerged path drivers/net/ethernet/ezchip/nps_enet.c
* Unmerged path drivers/net/ethernet/freescale/fec_main.c
* Unmerged path drivers/net/ethernet/freescale/fec_mpc52xx.c
* Unmerged path drivers/net/ethernet/freescale/fman/mac.c
* Unmerged path drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
* Unmerged path drivers/net/ethernet/freescale/gianfar.c
* Unmerged path drivers/net/ethernet/freescale/ucc_geth.c
* Unmerged path drivers/net/ethernet/hisilicon/hisi_femac.c
* Unmerged path drivers/net/ethernet/hisilicon/hix5hd2_gmac.c
* Unmerged path drivers/net/ethernet/lantiq_xrx200.c
* Unmerged path drivers/net/ethernet/marvell/mv643xx_eth.c
* Unmerged path drivers/net/ethernet/marvell/mvneta.c
* Unmerged path drivers/net/ethernet/marvell/prestera/prestera_main.c
* Unmerged path drivers/net/ethernet/marvell/pxa168_eth.c
* Unmerged path drivers/net/ethernet/marvell/sky2.c
* Unmerged path drivers/net/ethernet/mediatek/mtk_eth_soc.c
* Unmerged path drivers/net/ethernet/micrel/ks8851.c
* Unmerged path drivers/net/ethernet/microchip/lan743x_main.c
* Unmerged path drivers/net/ethernet/nxp/lpc_eth.c
* Unmerged path drivers/net/ethernet/qualcomm/qca_spi.c
* Unmerged path drivers/net/ethernet/qualcomm/qca_uart.c
* Unmerged path drivers/net/ethernet/renesas/ravb_main.c
* Unmerged path drivers/net/ethernet/renesas/sh_eth.c
* Unmerged path drivers/net/ethernet/samsung/sxgbe/sxgbe_platform.c
* Unmerged path drivers/net/ethernet/socionext/sni_ave.c
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-anarion.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-anarion.c
index 85ce80c600c7..27cf120ecd95 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-anarion.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-anarion.c
@@ -112,7 +112,7 @@ static int anarion_dwmac_probe(struct platform_device *pdev)
 	if (IS_ERR(gmac))
 		return PTR_ERR(gmac);
 
-	plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+	plat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
 	if (IS_ERR(plat_dat))
 		return PTR_ERR(plat_dat);
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-dwc-qos-eth.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-dwc-qos-eth.c
index 451a11a0da72..a8cbac7a9e43 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-dwc-qos-eth.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-dwc-qos-eth.c
@@ -450,7 +450,7 @@ static int dwc_eth_dwmac_probe(struct platform_device *pdev)
 	if (IS_ERR(stmmac_res.addr))
 		return PTR_ERR(stmmac_res.addr);
 
-	plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+	plat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
 	if (IS_ERR(plat_dat))
 		return PTR_ERR(plat_dat);
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-generic.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-generic.c
index 3304095c934c..649d2feb5755 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-generic.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-generic.c
@@ -27,7 +27,7 @@ static int dwmac_generic_probe(struct platform_device *pdev)
 		return ret;
 
 	if (pdev->dev.of_node) {
-		plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+		plat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
 		if (IS_ERR(plat_dat)) {
 			dev_err(&pdev->dev, "dt configuration failed\n");
 			return PTR_ERR(plat_dat);
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac-imx.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac-intel-plat.c
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-ipq806x.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-ipq806x.c
index 2c6d7c69c8f7..c3847c1d8f7f 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-ipq806x.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-ipq806x.c
@@ -254,7 +254,7 @@ static int ipq806x_gmac_probe(struct platform_device *pdev)
 	if (val)
 		return val;
 
-	plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+	plat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
 	if (IS_ERR(plat_dat))
 		return PTR_ERR(plat_dat);
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-lpc18xx.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-lpc18xx.c
index 3d3f43d91b98..9d77c647badd 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-lpc18xx.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-lpc18xx.c
@@ -37,7 +37,7 @@ static int lpc18xx_dwmac_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+	plat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
 	if (IS_ERR(plat_dat))
 		return PTR_ERR(plat_dat);
 
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac-mediatek.c
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c
index 7fdd1760a74c..898bc803a135 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-meson.c
@@ -59,7 +59,7 @@ static int meson6_dwmac_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+	plat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
 	if (IS_ERR(plat_dat))
 		return PTR_ERR(plat_dat);
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-meson8b.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-meson8b.c
index c5979569fd60..f4db18e93302 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-meson8b.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-meson8b.c
@@ -322,7 +322,7 @@ static int meson8b_dwmac_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+	plat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
 	if (IS_ERR(plat_dat))
 		return PTR_ERR(plat_dat);
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-oxnas.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-oxnas.c
index 3dc7d279f805..704de6e52d6f 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-oxnas.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-oxnas.c
@@ -124,7 +124,7 @@ static int oxnas_dwmac_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+	plat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
 	if (IS_ERR(plat_dat))
 		return PTR_ERR(plat_dat);
 
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac-qcom-ethqos.c
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
index f08625a02cea..328ebcd4b664 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
@@ -1337,7 +1337,7 @@ static int rk_gmac_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+	plat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
 	if (IS_ERR(plat_dat))
 		return PTR_ERR(plat_dat);
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-socfpga.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-socfpga.c
index 5b3b06a0a3bf..8b5d572082e8 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-socfpga.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-socfpga.c
@@ -315,7 +315,7 @@ static int socfpga_dwmac_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+	plat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
 	if (IS_ERR(plat_dat))
 		return PTR_ERR(plat_dat);
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-sti.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-sti.c
index 86e0e053804c..2733d947faca 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-sti.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-sti.c
@@ -324,7 +324,7 @@ static int sti_dwmac_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+	plat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
 	if (IS_ERR(plat_dat))
 		return PTR_ERR(plat_dat);
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c
index 7e2e79dedebf..289e6d18a3c6 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c
@@ -275,7 +275,7 @@ static int stm32_dwmac_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+	plat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
 	if (IS_ERR(plat_dat))
 		return PTR_ERR(plat_dat);
 
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-sunxi.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-sunxi.c
index 225d339965a2..87d5e0a6d0f2 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-sunxi.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-sunxi.c
@@ -115,7 +115,7 @@ static int sun7i_gmac_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+	plat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
 	if (IS_ERR(plat_dat))
 		return PTR_ERR(plat_dat);
 
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac-visconti.c
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
index d98da20cb86c..1076f471f3b7 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -36,7 +36,7 @@
 
 struct stmmac_resources {
 	void __iomem *addr;
-	const char *mac;
+	u8 mac[ETH_ALEN];
 	int wol_irq;
 	int lpi_irq;
 	int irq;
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
index eae595c5bc2f..21fb20dc05c4 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
@@ -403,7 +403,7 @@ static int stmmac_of_get_mac_mode(struct device_node *np)
  * set some private fields that will be used by the main at runtime.
  */
 struct plat_stmmacenet_data *
-stmmac_probe_config_dt(struct platform_device *pdev, const char **mac)
+stmmac_probe_config_dt(struct platform_device *pdev, u8 *mac)
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct plat_stmmacenet_data *plat;
@@ -414,12 +414,12 @@ stmmac_probe_config_dt(struct platform_device *pdev, const char **mac)
 	if (!plat)
 		return ERR_PTR(-ENOMEM);
 
-	*mac = of_get_mac_address(np);
-	if (IS_ERR(*mac)) {
-		if (PTR_ERR(*mac) == -EPROBE_DEFER)
-			return ERR_CAST(*mac);
+	rc = of_get_mac_address(np, mac);
+	if (rc) {
+		if (rc == -EPROBE_DEFER)
+			return ERR_PTR(rc);
 
-		*mac = NULL;
+		eth_zero_addr(mac);
 	}
 
 	plat->phy_interface = device_get_phy_mode(&pdev->dev);
@@ -633,7 +633,7 @@ void stmmac_remove_config_dt(struct platform_device *pdev,
 }
 #else
 struct plat_stmmacenet_data *
-stmmac_probe_config_dt(struct platform_device *pdev, const char **mac)
+stmmac_probe_config_dt(struct platform_device *pdev, u8 *mac)
 {
 	return ERR_PTR(-EINVAL);
 }
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.h b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.h
index b72eb0de57b7..26df5c53045c 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.h
@@ -22,7 +22,7 @@
 #include "stmmac.h"
 
 struct plat_stmmacenet_data *
-stmmac_probe_config_dt(struct platform_device *pdev, const char **mac);
+stmmac_probe_config_dt(struct platform_device *pdev, u8 *mac);
 void stmmac_remove_config_dt(struct platform_device *pdev,
 			     struct plat_stmmacenet_data *plat);
 
* Unmerged path drivers/net/ethernet/ti/am65-cpsw-nuss.c
* Unmerged path drivers/net/ethernet/ti/cpsw.c
* Unmerged path drivers/net/ethernet/ti/cpsw_new.c
* Unmerged path drivers/net/ethernet/ti/davinci_emac.c
* Unmerged path drivers/net/ethernet/ti/netcp_core.c
* Unmerged path drivers/net/ethernet/wiznet/w5100-spi.c
* Unmerged path drivers/net/ethernet/xilinx/ll_temac_main.c
* Unmerged path drivers/net/ethernet/xilinx/xilinx_axienet_main.c
* Unmerged path drivers/net/ethernet/xilinx/xilinx_emaclite.c
diff --git a/drivers/net/wireless/ath/ath9k/init.c b/drivers/net/wireless/ath/ath9k/init.c
index a2cc8029977a..c0ba24556002 100644
--- a/drivers/net/wireless/ath/ath9k/init.c
+++ b/drivers/net/wireless/ath/ath9k/init.c
@@ -617,7 +617,6 @@ static int ath9k_of_init(struct ath_softc *sc)
 	struct ath_hw *ah = sc->sc_ah;
 	struct ath_common *common = ath9k_hw_common(ah);
 	enum ath_bus_type bus_type = common->bus_ops->ath_bus_type;
-	const char *mac;
 	char eeprom_name[100];
 	int ret;
 
@@ -640,9 +639,7 @@ static int ath9k_of_init(struct ath_softc *sc)
 		ah->ah_flags |= AH_NO_EEP_SWAP;
 	}
 
-	mac = of_get_mac_address(np);
-	if (!IS_ERR(mac))
-		ether_addr_copy(common->macaddr, mac);
+	of_get_mac_address(np, common->macaddr);
 
 	return 0;
 }
diff --git a/drivers/net/wireless/mediatek/mt76/eeprom.c b/drivers/net/wireless/mediatek/mt76/eeprom.c
index aed9bcb2db7b..3b47e85e95e7 100644
--- a/drivers/net/wireless/mediatek/mt76/eeprom.c
+++ b/drivers/net/wireless/mediatek/mt76/eeprom.c
@@ -90,16 +90,9 @@ void
 mt76_eeprom_override(struct mt76_phy *phy)
 {
 	struct mt76_dev *dev = phy->dev;
-
-#ifdef CONFIG_OF
 	struct device_node *np = dev->dev->of_node;
-	const u8 *mac = NULL;
 
-	if (np)
-		mac = of_get_mac_address(np);
-	if (!IS_ERR_OR_NULL(mac))
-		ether_addr_copy(phy->macaddr, mac);
-#endif
+	of_get_mac_address(np, phy->macaddr);
 
 	if (!is_valid_ether_addr(phy->macaddr)) {
 		eth_random_addr(phy->macaddr);
* Unmerged path drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
* Unmerged path drivers/of/of_net.c
* Unmerged path drivers/staging/octeon/ethernet.c
* Unmerged path drivers/staging/wfx/main.c
* Unmerged path include/linux/of_net.h
* Unmerged path include/net/dsa.h
* Unmerged path net/dsa/dsa2.c
* Unmerged path net/dsa/slave.c
* Unmerged path net/ethernet/eth.c
