kasan: hide invalid free check implementation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Andrey Konovalov <andreyknvl@google.com>
commit 2cdbed63490d0d2bcbae60abcc5639caa5aba49b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/2cdbed63.failed

This is a preparatory commit for the upcoming addition of a new hardware
tag-based (MTE-based) KASAN mode.

For software KASAN modes the check is based on the value in the shadow
memory.  Hardware tag-based KASAN won't be using shadow, so hide the
implementation of the check in check_invalid_free().

Also simplify the code for software tag-based mode.

No functional changes for software modes.

Link: https://lkml.kernel.org/r/d01534a4b977f97d87515dc590e6348e1406de81.1606161801.git.andreyknvl@google.com
	Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
	Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Reviewed-by: Marco Elver <elver@google.com>
	Reviewed-by: Alexander Potapenko <glider@google.com>
	Tested-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Branislav Rankov <Branislav.Rankov@arm.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Evgenii Stepanov <eugenis@google.com>
	Cc: Kevin Brodsky <kevin.brodsky@arm.com>
	Cc: Vasily Gorbik <gor@linux.ibm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 2cdbed63490d0d2bcbae60abcc5639caa5aba49b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/kasan/common.c
diff --cc mm/kasan/common.c
index 5c1cf01c4cee,663ffa71cd20..000000000000
--- a/mm/kasan/common.c
+++ b/mm/kasan/common.c
@@@ -388,21 -277,6 +388,24 @@@ void * __must_check kasan_init_slab_obj
  	return (void *)object;
  }
  
++<<<<<<< HEAD
 +static inline bool shadow_invalid(u8 tag, s8 shadow_byte)
 +{
 +	if (IS_ENABLED(CONFIG_KASAN_GENERIC))
 +		return shadow_byte < 0 ||
 +			shadow_byte >= KASAN_SHADOW_SCALE_SIZE;
 +
 +	/* else CONFIG_KASAN_SW_TAGS: */
 +	if ((u8)shadow_byte == KASAN_TAG_INVALID)
 +		return true;
 +	if ((tag != KASAN_TAG_KERNEL) && (tag != (u8)shadow_byte))
 +		return true;
 +
 +	return false;
 +}
 +
++=======
++>>>>>>> 2cdbed63490d (kasan: hide invalid free check implementation)
  static bool __kasan_slab_free(struct kmem_cache *cache, void *object,
  			      unsigned long ip, bool quarantine)
  {
* Unmerged path mm/kasan/common.c
diff --git a/mm/kasan/generic.c b/mm/kasan/generic.c
index d341859a1b95..7dd800e16752 100644
--- a/mm/kasan/generic.c
+++ b/mm/kasan/generic.c
@@ -187,6 +187,13 @@ bool check_memory_region(unsigned long addr, size_t size, bool write,
 	return check_memory_region_inline(addr, size, write, ret_ip);
 }
 
+bool check_invalid_free(void *addr)
+{
+	s8 shadow_byte = READ_ONCE(*(s8 *)kasan_mem_to_shadow(addr));
+
+	return shadow_byte < 0 || shadow_byte >= KASAN_GRANULE_SIZE;
+}
+
 void kasan_cache_shrink(struct kmem_cache *cache)
 {
 	quarantine_remove_cache(cache);
diff --git a/mm/kasan/kasan.h b/mm/kasan/kasan.h
index ac499456740f..b2989f529058 100644
--- a/mm/kasan/kasan.h
+++ b/mm/kasan/kasan.h
@@ -163,6 +163,8 @@ void kasan_poison_shadow(const void *address, size_t size, u8 value);
 bool check_memory_region(unsigned long addr, size_t size, bool write,
 				unsigned long ret_ip);
 
+bool check_invalid_free(void *addr);
+
 void *find_first_bad_addr(void *addr, size_t size);
 const char *get_bug_type(struct kasan_access_info *info);
 
diff --git a/mm/kasan/tags.c b/mm/kasan/tags.c
index 5c8b08a25715..19b2c75cef55 100644
--- a/mm/kasan/tags.c
+++ b/mm/kasan/tags.c
@@ -121,6 +121,15 @@ bool check_memory_region(unsigned long addr, size_t size, bool write,
 	return true;
 }
 
+bool check_invalid_free(void *addr)
+{
+	u8 tag = get_tag(addr);
+	u8 shadow_byte = READ_ONCE(*(u8 *)kasan_mem_to_shadow(reset_tag(addr)));
+
+	return (shadow_byte == KASAN_TAG_INVALID) ||
+		(tag != KASAN_TAG_KERNEL && tag != shadow_byte);
+}
+
 #define DEFINE_HWASAN_LOAD_STORE(size)					\
 	void __hwasan_load##size##_noabort(unsigned long addr)		\
 	{								\
