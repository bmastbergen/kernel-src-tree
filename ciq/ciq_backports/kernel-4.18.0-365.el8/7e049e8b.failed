x86/fpu/signal: Convert to fpstate

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 7e049e8b74591038c831e765585ae9038b7880a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/7e049e8b.failed

Convert signal related code to the new register storage mechanism in
preparation for dynamically sized buffers.

No functional change.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20211013145322.607370221@linutronix.de
(cherry picked from commit 7e049e8b74591038c831e765585ae9038b7880a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/fpu/signal.c
diff --cc arch/x86/kernel/fpu/signal.c
index f74c29985497,c54c2a3dda44..000000000000
--- a/arch/x86/kernel/fpu/signal.c
+++ b/arch/x86/kernel/fpu/signal.c
@@@ -67,10 -69,10 +67,10 @@@ setfx
  /*
   * Signal frame handlers.
   */
 -static inline bool save_fsave_header(struct task_struct *tsk, void __user *buf)
 +static inline int save_fsave_header(struct task_struct *tsk, void __user *buf)
  {
  	if (use_fxsr()) {
- 		struct xregs_state *xsave = &tsk->thread.fpu.state.xsave;
+ 		struct xregs_state *xsave = &tsk->thread.fpu.fpstate->regs.xsave;
  		struct user_i387_ia32_struct env;
  		struct _fpstate_32 __user *fp = buf;
  
@@@ -315,9 -317,11 +315,10 @@@ static int __fpu_restore_sig(void __use
  	struct task_struct *tsk = current;
  	struct fpu *fpu = &tsk->thread.fpu;
  	struct user_i387_ia32_struct env;
+ 	union fpregs_state *fpregs;
  	u64 user_xfeatures = 0;
  	bool fx_only = false;
 -	bool success;
 -
 +	int ret;
  
  	if (use_xsave()) {
  		struct _fpx_sw_bytes fx_sw_user;
@@@ -344,10 -347,10 +345,11 @@@
  	 * to be ignored for histerical raisins. The legacy state is folded
  	 * in once the larger state has been copied.
  	 */
 -	if (__copy_from_user(&env, buf, sizeof(env)))
 -		return false;
 +	ret = __copy_from_user(&env, buf, sizeof(env));
 +	if (ret)
 +		return ret;
  
+ 	fpregs = &fpu->fpstate->regs;
  	/*
  	 * By setting TIF_NEED_FPU_LOAD it is ensured that our xstate is
  	 * not modified on context switch and that the xstate is considered
@@@ -373,21 -376,20 +375,35 @@@
  	fpregs_unlock();
  
  	if (use_xsave() && !fx_only) {
++<<<<<<< HEAD
 +		ret = copy_sigframe_from_user_to_xstate(&fpu->state.xsave, buf_fx);
 +		if (ret)
 +			return ret;
 +	} else {
 +		if (__copy_from_user(&fpu->state.fxsave, buf_fx,
 +				     sizeof(fpu->state.fxsave)))
 +			return -EFAULT;
 +
 +		if (IS_ENABLED(CONFIG_X86_64)) {
 +			/* Reject invalid MXCSR values. */
 +			if (fpu->state.fxsave.mxcsr & ~mxcsr_feature_mask)
 +				return -EINVAL;
++=======
+ 		if (copy_sigframe_from_user_to_xstate(&fpregs->xsave, buf_fx))
+ 			return false;
+ 	} else {
+ 		if (__copy_from_user(&fpregs->fxsave, buf_fx,
+ 				     sizeof(fpregs->fxsave)))
+ 			return false;
+ 
+ 		if (IS_ENABLED(CONFIG_X86_64)) {
+ 			/* Reject invalid MXCSR values. */
+ 			if (fpregs->fxsave.mxcsr & ~mxcsr_feature_mask)
+ 				return false;
++>>>>>>> 7e049e8b7459 (x86/fpu/signal: Convert to fpstate)
  		} else {
  			/* Mask invalid bits out for historical reasons (broken hardware). */
- 			fpu->state.fxsave.mxcsr &= mxcsr_feature_mask;
+ 			fpregs->fxsave.mxcsr &= mxcsr_feature_mask;
  		}
  
  		/* Enforce XFEATURE_MASK_FPSSE when XSAVE is enabled */
@@@ -411,13 -413,13 +427,20 @@@
  		 */
  		u64 mask = user_xfeatures | xfeatures_mask_supervisor();
  
++<<<<<<< HEAD
 +		fpu->state.xsave.header.xfeatures &= mask;
 +		ret = os_xrstor_safe(&fpu->state.xsave, xfeatures_mask_all);
 +	} else {
 +		ret = fxrstor_safe(&fpu->state.fxsave);
++=======
+ 		fpregs->xsave.header.xfeatures &= mask;
+ 		success = !os_xrstor_safe(&fpregs->xsave, xfeatures_mask_all);
+ 	} else {
+ 		success = !fxrstor_safe(&fpregs->fxsave);
++>>>>>>> 7e049e8b7459 (x86/fpu/signal: Convert to fpstate)
  	}
  
 -	if (likely(success))
 +	if (likely(!ret))
  		fpregs_mark_activate();
  
  	fpregs_unlock();
* Unmerged path arch/x86/kernel/fpu/signal.c
