dma-mapping: move large parts of <linux/dma-direct.h> to kernel/dma

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 19c65c3d30bb5a97170e425979d2e44ab2096c7d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/19c65c3d.failed

Most of the dma_direct symbols should only be used by direct.c and
mapping.c, so move them to kernel/dma.  In fact more of dma-direct.h
should eventually move, but that will require more coordination with
other subsystems.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 19c65c3d30bb5a97170e425979d2e44ab2096c7d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/dma-direct.h
#	kernel/dma/direct.c
#	kernel/dma/mapping.c
diff --cc include/linux/dma-direct.h
index 28fdd6ebdd10,a2d6640c42c0..000000000000
--- a/include/linux/dma-direct.h
+++ b/include/linux/dma-direct.h
@@@ -79,111 -120,8 +79,103 @@@ struct page *dma_direct_alloc_pages(str
  void dma_direct_free_pages(struct device *dev, size_t size,
  		struct page *page, dma_addr_t dma_addr,
  		enum dma_data_direction dir);
- int dma_direct_get_sgtable(struct device *dev, struct sg_table *sgt,
- 		void *cpu_addr, dma_addr_t dma_addr, size_t size,
- 		unsigned long attrs);
- bool dma_direct_can_mmap(struct device *dev);
- int dma_direct_mmap(struct device *dev, struct vm_area_struct *vma,
- 		void *cpu_addr, dma_addr_t dma_addr, size_t size,
- 		unsigned long attrs);
  int dma_direct_supported(struct device *dev, u64 mask);
- bool dma_direct_need_sync(struct device *dev, dma_addr_t dma_addr);
- int dma_direct_map_sg(struct device *dev, struct scatterlist *sgl, int nents,
- 		enum dma_data_direction dir, unsigned long attrs);
  dma_addr_t dma_direct_map_resource(struct device *dev, phys_addr_t paddr,
  		size_t size, enum dma_data_direction dir, unsigned long attrs);
- size_t dma_direct_max_mapping_size(struct device *dev);
  
++<<<<<<< HEAD
 +#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \
 +    defined(CONFIG_SWIOTLB)
 +void dma_direct_sync_sg_for_device(struct device *dev, struct scatterlist *sgl,
 +		int nents, enum dma_data_direction dir);
 +#else
 +static inline void dma_direct_sync_sg_for_device(struct device *dev,
 +		struct scatterlist *sgl, int nents, enum dma_data_direction dir)
 +{
 +}
 +#endif
 +
 +#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \
 +    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL) || \
 +    defined(CONFIG_SWIOTLB)
 +void dma_direct_unmap_sg(struct device *dev, struct scatterlist *sgl,
 +		int nents, enum dma_data_direction dir, unsigned long attrs);
 +void dma_direct_sync_sg_for_cpu(struct device *dev,
 +		struct scatterlist *sgl, int nents, enum dma_data_direction dir);
 +#else
 +static inline void dma_direct_unmap_sg(struct device *dev,
 +		struct scatterlist *sgl, int nents, enum dma_data_direction dir,
 +		unsigned long attrs)
 +{
 +}
 +static inline void dma_direct_sync_sg_for_cpu(struct device *dev,
 +		struct scatterlist *sgl, int nents, enum dma_data_direction dir)
 +{
 +}
 +#endif
 +
 +static inline void dma_direct_sync_single_for_device(struct device *dev,
 +		dma_addr_t addr, size_t size, enum dma_data_direction dir)
 +{
 +	phys_addr_t paddr = dma_to_phys(dev, addr);
 +
 +	if (unlikely(is_swiotlb_buffer(paddr)))
 +		swiotlb_tbl_sync_single(dev, paddr, size, dir, SYNC_FOR_DEVICE);
 +
 +	if (!dev_is_dma_coherent(dev))
 +		arch_sync_dma_for_device(paddr, size, dir);
 +}
 +
 +static inline void dma_direct_sync_single_for_cpu(struct device *dev,
 +		dma_addr_t addr, size_t size, enum dma_data_direction dir)
 +{
 +	phys_addr_t paddr = dma_to_phys(dev, addr);
 +
 +	if (!dev_is_dma_coherent(dev)) {
 +		arch_sync_dma_for_cpu(paddr, size, dir);
 +		arch_sync_dma_for_cpu_all();
 +	}
 +
 +	if (unlikely(is_swiotlb_buffer(paddr)))
 +		swiotlb_tbl_sync_single(dev, paddr, size, dir, SYNC_FOR_CPU);
 +}
 +
 +static inline dma_addr_t dma_direct_map_page(struct device *dev,
 +		struct page *page, unsigned long offset, size_t size,
 +		enum dma_data_direction dir, unsigned long attrs)
 +{
 +	phys_addr_t phys = page_to_phys(page) + offset;
 +	dma_addr_t dma_addr = phys_to_dma(dev, phys);
 +
 +	if (unlikely(swiotlb_force == SWIOTLB_FORCE))
 +		return swiotlb_map(dev, phys, size, dir, attrs);
 +
 +	if (unlikely(!dma_capable(dev, dma_addr, size, true))) {
 +		if (swiotlb_force != SWIOTLB_NO_FORCE)
 +			return swiotlb_map(dev, phys, size, dir, attrs);
 +
 +		dev_WARN_ONCE(dev, 1,
 +			     "DMA addr %pad+%zu overflow (mask %llx, bus limit %llx).\n",
 +			     &dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);
 +		return DMA_MAPPING_ERROR;
 +	}
 +
 +	if (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))
 +		arch_sync_dma_for_device(phys, size, dir);
 +	return dma_addr;
 +}
 +
 +static inline void dma_direct_unmap_page(struct device *dev, dma_addr_t addr,
 +		size_t size, enum dma_data_direction dir, unsigned long attrs)
 +{
 +	phys_addr_t phys = dma_to_phys(dev, addr);
 +
 +	if (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))
 +		dma_direct_sync_single_for_cpu(dev, addr, size, dir);
 +
 +	if (unlikely(is_swiotlb_buffer(phys)))
 +		swiotlb_tbl_unmap_single(dev, phys, size, size, dir, attrs);
 +}
++=======
++>>>>>>> 19c65c3d30bb (dma-mapping: move large parts of <linux/dma-direct.h> to kernel/dma)
  #endif /* _LINUX_DMA_DIRECT_H */
diff --cc kernel/dma/direct.c
index 7d488b64b9de,bf9f77623022..000000000000
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@@ -7,12 -7,13 +7,21 @@@
  #include <linux/memblock.h> /* for max_pfn */
  #include <linux/export.h>
  #include <linux/mm.h>
++<<<<<<< HEAD
 +#include <linux/dma-direct.h>
++=======
+ #include <linux/dma-map-ops.h>
++>>>>>>> 19c65c3d30bb (dma-mapping: move large parts of <linux/dma-direct.h> to kernel/dma)
  #include <linux/scatterlist.h>
 +#include <linux/dma-contiguous.h>
  #include <linux/pfn.h>
  #include <linux/vmalloc.h>
  #include <linux/set_memory.h>
++<<<<<<< HEAD
++=======
+ #include <linux/slab.h>
+ #include "direct.h"
++>>>>>>> 19c65c3d30bb (dma-mapping: move large parts of <linux/dma-direct.h> to kernel/dma)
  
  /*
   * Most architectures use ZONE_DMA for the first 16 Megabytes, but some use it
diff --cc kernel/dma/mapping.c
index b152e4e4a653,51bb8fa8eb89..000000000000
--- a/kernel/dma/mapping.c
+++ b/kernel/dma/mapping.c
@@@ -7,24 -7,14 +7,33 @@@
   */
  #include <linux/memblock.h> /* for max_pfn */
  #include <linux/acpi.h>
++<<<<<<< HEAD
 +#include <linux/dma-direct.h>
 +#include <linux/dma-mapping.h>
++=======
+ #include <linux/dma-map-ops.h>
++>>>>>>> 19c65c3d30bb (dma-mapping: move large parts of <linux/dma-direct.h> to kernel/dma)
  #include <linux/export.h>
  #include <linux/gfp.h>
  #include <linux/of_device.h>
  #include <linux/slab.h>
  #include <linux/vmalloc.h>
++<<<<<<< HEAD
 +
 +/*
 + * Avoid KABI breakage due to struct device opacity change when relocating
 + * dma_set_mask/dma_set_coherent_mask/dma_get_required_mask definitions
 + * from arch/powerpc/kernel/dma.c to here
 + */
 +#ifdef CONFIG_PPC64
 +#include RH_KABI_FAKE_INCLUDE(<linux/cred.h>)
 +#include RH_KABI_FAKE_INCLUDE(<linux/seq_file.h>)
 +#include RH_KABI_FAKE_INCLUDE(<asm/iommu.h>)
 +#endif
++=======
+ #include "debug.h"
+ #include "direct.h"
++>>>>>>> 19c65c3d30bb (dma-mapping: move large parts of <linux/dma-direct.h> to kernel/dma)
  
  /*
   * Managed DMA API
* Unmerged path include/linux/dma-direct.h
* Unmerged path kernel/dma/direct.c
diff --git a/kernel/dma/direct.h b/kernel/dma/direct.h
new file mode 100644
index 000000000000..b98615578737
--- /dev/null
+++ b/kernel/dma/direct.h
@@ -0,0 +1,119 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2018 Christoph Hellwig.
+ *
+ * DMA operations that map physical memory directly without using an IOMMU.
+ */
+#ifndef _KERNEL_DMA_DIRECT_H
+#define _KERNEL_DMA_DIRECT_H
+
+#include <linux/dma-direct.h>
+
+int dma_direct_get_sgtable(struct device *dev, struct sg_table *sgt,
+		void *cpu_addr, dma_addr_t dma_addr, size_t size,
+		unsigned long attrs);
+bool dma_direct_can_mmap(struct device *dev);
+int dma_direct_mmap(struct device *dev, struct vm_area_struct *vma,
+		void *cpu_addr, dma_addr_t dma_addr, size_t size,
+		unsigned long attrs);
+bool dma_direct_need_sync(struct device *dev, dma_addr_t dma_addr);
+int dma_direct_map_sg(struct device *dev, struct scatterlist *sgl, int nents,
+		enum dma_data_direction dir, unsigned long attrs);
+size_t dma_direct_max_mapping_size(struct device *dev);
+
+#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \
+    defined(CONFIG_SWIOTLB)
+void dma_direct_sync_sg_for_device(struct device *dev, struct scatterlist *sgl,
+		int nents, enum dma_data_direction dir);
+#else
+static inline void dma_direct_sync_sg_for_device(struct device *dev,
+		struct scatterlist *sgl, int nents, enum dma_data_direction dir)
+{
+}
+#endif
+
+#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \
+    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL) || \
+    defined(CONFIG_SWIOTLB)
+void dma_direct_unmap_sg(struct device *dev, struct scatterlist *sgl,
+		int nents, enum dma_data_direction dir, unsigned long attrs);
+void dma_direct_sync_sg_for_cpu(struct device *dev,
+		struct scatterlist *sgl, int nents, enum dma_data_direction dir);
+#else
+static inline void dma_direct_unmap_sg(struct device *dev,
+		struct scatterlist *sgl, int nents, enum dma_data_direction dir,
+		unsigned long attrs)
+{
+}
+static inline void dma_direct_sync_sg_for_cpu(struct device *dev,
+		struct scatterlist *sgl, int nents, enum dma_data_direction dir)
+{
+}
+#endif
+
+static inline void dma_direct_sync_single_for_device(struct device *dev,
+		dma_addr_t addr, size_t size, enum dma_data_direction dir)
+{
+	phys_addr_t paddr = dma_to_phys(dev, addr);
+
+	if (unlikely(is_swiotlb_buffer(paddr)))
+		swiotlb_tbl_sync_single(dev, paddr, size, dir, SYNC_FOR_DEVICE);
+
+	if (!dev_is_dma_coherent(dev))
+		arch_sync_dma_for_device(paddr, size, dir);
+}
+
+static inline void dma_direct_sync_single_for_cpu(struct device *dev,
+		dma_addr_t addr, size_t size, enum dma_data_direction dir)
+{
+	phys_addr_t paddr = dma_to_phys(dev, addr);
+
+	if (!dev_is_dma_coherent(dev)) {
+		arch_sync_dma_for_cpu(paddr, size, dir);
+		arch_sync_dma_for_cpu_all();
+	}
+
+	if (unlikely(is_swiotlb_buffer(paddr)))
+		swiotlb_tbl_sync_single(dev, paddr, size, dir, SYNC_FOR_CPU);
+
+	if (dir == DMA_FROM_DEVICE)
+		arch_dma_mark_clean(paddr, size);
+}
+
+static inline dma_addr_t dma_direct_map_page(struct device *dev,
+		struct page *page, unsigned long offset, size_t size,
+		enum dma_data_direction dir, unsigned long attrs)
+{
+	phys_addr_t phys = page_to_phys(page) + offset;
+	dma_addr_t dma_addr = phys_to_dma(dev, phys);
+
+	if (unlikely(swiotlb_force == SWIOTLB_FORCE))
+		return swiotlb_map(dev, phys, size, dir, attrs);
+
+	if (unlikely(!dma_capable(dev, dma_addr, size, true))) {
+		if (swiotlb_force != SWIOTLB_NO_FORCE)
+			return swiotlb_map(dev, phys, size, dir, attrs);
+
+		dev_WARN_ONCE(dev, 1,
+			     "DMA addr %pad+%zu overflow (mask %llx, bus limit %llx).\n",
+			     &dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);
+		return DMA_MAPPING_ERROR;
+	}
+
+	if (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))
+		arch_sync_dma_for_device(phys, size, dir);
+	return dma_addr;
+}
+
+static inline void dma_direct_unmap_page(struct device *dev, dma_addr_t addr,
+		size_t size, enum dma_data_direction dir, unsigned long attrs)
+{
+	phys_addr_t phys = dma_to_phys(dev, addr);
+
+	if (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))
+		dma_direct_sync_single_for_cpu(dev, addr, size, dir);
+
+	if (unlikely(is_swiotlb_buffer(phys)))
+		swiotlb_tbl_unmap_single(dev, phys, size, size, dir, attrs);
+}
+#endif /* _KERNEL_DMA_DIRECT_H */
* Unmerged path kernel/dma/mapping.c
