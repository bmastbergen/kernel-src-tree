USB: serial: stop reporting legacy UART types

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Johan Hovold <johan@kernel.org>
commit f64d74a59c476df7d5abbddc23011f0d8475c7cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/f64d74a5.failed

The TIOCGSERIAL ioctl can be used to set and retrieve the UART type for
legacy UARTs, but some USB serial drivers have been reporting back
random types in order to "make user-space happy".

Some applications have historically expected TIOCGSERIAL to be
implemented, but judging from the Debian sources, the port type not
being PORT_UNKNOWN is only used to check for the existence of legacy
serial ports (ttySn).

Drivers like ftdi_sio have been using PORT_UNKNOWN for twenty years (and
option for 10 years) without anyone complaining so let's stop reporting
back anything else.

In the unlikely event that this do cause problems, this should be fixed
tree-wide anyway (e.g. for all USB serial drivers and also CDC-ACM).

	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Signed-off-by: Johan Hovold <johan@kernel.org>
(cherry picked from commit f64d74a59c476df7d5abbddc23011f0d8475c7cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/serial/ark3116.c
#	drivers/usb/serial/f81232.c
#	drivers/usb/serial/f81534.c
#	drivers/usb/serial/io_edgeport.c
#	drivers/usb/serial/io_ti.c
#	drivers/usb/serial/mos7720.c
#	drivers/usb/serial/mos7840.c
#	drivers/usb/serial/opticon.c
#	drivers/usb/serial/pl2303.c
#	drivers/usb/serial/ti_usb_3410_5052.c
#	drivers/usb/serial/whiteheat.c
diff --cc drivers/usb/serial/ark3116.c
index 3beda74379db,5dd710e9fe7d..000000000000
--- a/drivers/usb/serial/ark3116.c
+++ b/drivers/usb/serial/ark3116.c
@@@ -387,19 -385,6 +387,22 @@@ err_free
  	return result;
  }
  
++<<<<<<< HEAD
 +static int ark3116_get_serial_info(struct tty_struct *tty,
 +			struct serial_struct *ss)
 +{
 +	struct usb_serial_port *port = tty->driver_data;
 +
 +	ss->type = PORT_16654;
 +	ss->line = port->minor;
 +	ss->close_delay = 50;
 +	ss->closing_wait = 3000;
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> f64d74a59c47 (USB: serial: stop reporting legacy UART types)
  static int ark3116_tiocmget(struct tty_struct *tty)
  {
  	struct usb_serial_port *port = tty->driver_data;
diff --cc drivers/usb/serial/f81232.c
index 6a8f39147d8e,b4b847dce4bc..000000000000
--- a/drivers/usb/serial/f81232.c
+++ b/drivers/usb/serial/f81232.c
@@@ -826,11 -825,7 +826,14 @@@ static int f81232_get_serial_info(struc
  	struct usb_serial_port *port = tty->driver_data;
  	struct f81232_private *priv = usb_get_serial_port_data(port);
  
++<<<<<<< HEAD
 +	ss->type = PORT_16550A;
 +	ss->line = port->minor;
 +	ss->port = port->port_number;
++=======
++>>>>>>> f64d74a59c47 (USB: serial: stop reporting legacy UART types)
  	ss->baud_base = priv->baud_base;
 +	return 0;
  }
  
  static void  f81232_interrupt_work(struct work_struct *work)
diff --cc drivers/usb/serial/f81534.c
index e7f2f7139cf7,c0bca52ef92a..000000000000
--- a/drivers/usb/serial/f81534.c
+++ b/drivers/usb/serial/f81534.c
@@@ -1150,33 -1147,7 +1150,37 @@@ static int f81534_get_serial_info(struc
  
  	port_priv = usb_get_serial_port_data(port);
  
++<<<<<<< HEAD
 +	memset(&tmp, 0, sizeof(tmp));
 +
 +	tmp.type = PORT_16550A;
 +	tmp.port = port->port_number;
 +	tmp.line = port->minor;
 +	tmp.baud_base = port_priv->baud_base;
 +
 +	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
 +		return -EFAULT;
 +
 +	return 0;
 +}
 +
 +static int f81534_ioctl(struct tty_struct *tty, unsigned int cmd,
 +			unsigned long arg)
 +{
 +	struct usb_serial_port *port = tty->driver_data;
 +	struct serial_struct __user *buf = (struct serial_struct __user *)arg;
 +
 +	switch (cmd) {
 +	case TIOCGSERIAL:
 +		return f81534_get_serial_info(port, buf);
 +	default:
 +		break;
 +	}
 +
 +	return -ENOIOCTLCMD;
++=======
+ 	ss->baud_base = port_priv->baud_base;
++>>>>>>> f64d74a59c47 (USB: serial: stop reporting legacy UART types)
  }
  
  static void f81534_process_per_serial_block(struct usb_serial_port *port,
diff --cc drivers/usb/serial/io_edgeport.c
index b542cce803cd,e6fe3882bf69..000000000000
--- a/drivers/usb/serial/io_edgeport.c
+++ b/drivers/usb/serial/io_edgeport.c
@@@ -1637,20 -1594,6 +1637,23 @@@ static int edge_tiocmget(struct tty_str
  	return result;
  }
  
++<<<<<<< HEAD
 +static int get_serial_info(struct tty_struct *tty,
 +				struct serial_struct *ss)
 +{
 +	struct usb_serial_port *port = tty->driver_data;
 +
 +	ss->type		= PORT_16550A;
 +	ss->line		= port->minor;
 +	ss->close_delay		= 50;
 +	ss->closing_wait	= 3000;
 +
 +	return 0;
 +}
 +
 +
++=======
++>>>>>>> f64d74a59c47 (USB: serial: stop reporting legacy UART types)
  /*****************************************************************************
   * SerialIoctl
   *	this function handles any ioctl calls to the driver
diff --cc drivers/usb/serial/io_ti.c
index 16b24261e7cc,f548cdbf0a51..000000000000
--- a/drivers/usb/serial/io_ti.c
+++ b/drivers/usb/serial/io_ti.c
@@@ -2433,24 -2433,6 +2433,27 @@@ static int edge_tiocmget(struct tty_str
  	return result;
  }
  
++<<<<<<< HEAD
 +static int get_serial_info(struct tty_struct *tty,
 +				struct serial_struct *ss)
 +{
 +	struct usb_serial_port *port = tty->driver_data;
 +	unsigned cwait;
 +
 +	cwait = port->port.closing_wait;
 +	if (cwait != ASYNC_CLOSING_WAIT_NONE)
 +		cwait = jiffies_to_msecs(cwait) / 10;
 +
 +	ss->type		= PORT_16550A;
 +	ss->line		= port->minor;
 +	ss->close_delay		= 50;
 +	ss->closing_wait	= cwait;
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> f64d74a59c47 (USB: serial: stop reporting legacy UART types)
  static void edge_break(struct tty_struct *tty, int break_state)
  {
  	struct usb_serial_port *port = tty->driver_data;
diff --cc drivers/usb/serial/mos7720.c
index 7f73217807b1,d3f1bdb26fd4..000000000000
--- a/drivers/usb/serial/mos7720.c
+++ b/drivers/usb/serial/mos7720.c
@@@ -1792,19 -1634,6 +1792,22 @@@ static int mos7720_tiocmset(struct tty_
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int get_serial_info(struct tty_struct *tty,
 +			   struct serial_struct *ss)
 +{
 +	struct usb_serial_port *port = tty->driver_data;
 +
 +	ss->type		= PORT_16550A;
 +	ss->line		= port->minor;
 +	ss->close_delay		= 50;
 +	ss->closing_wait	= 3000;
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> f64d74a59c47 (USB: serial: stop reporting legacy UART types)
  static int mos7720_ioctl(struct tty_struct *tty,
  			 unsigned int cmd, unsigned long arg)
  {
diff --cc drivers/usb/serial/mos7840.c
index a9d627bc2e56,28e4093794e0..000000000000
--- a/drivers/usb/serial/mos7840.c
+++ b/drivers/usb/serial/mos7840.c
@@@ -1384,24 -1384,6 +1384,27 @@@ static int mos7840_get_lsr_info(struct 
  }
  
  /*****************************************************************************
++<<<<<<< HEAD
 + * mos7840_get_serial_info
 + *      function to get information about serial port
 + *****************************************************************************/
 +
 +static int mos7840_get_serial_info(struct tty_struct *tty,
 +				   struct serial_struct *ss)
 +{
 +	struct usb_serial_port *port = tty->driver_data;
 +
 +	ss->type = PORT_16550A;
 +	ss->line = port->minor;
 +	ss->close_delay = 50;
 +	ss->closing_wait = 3000;
 +
 +	return 0;
 +}
 +
 +/*****************************************************************************
++=======
++>>>>>>> f64d74a59c47 (USB: serial: stop reporting legacy UART types)
   * SerialIoctl
   *	this function handles any ioctl calls to the driver
   *****************************************************************************/
diff --cc drivers/usb/serial/opticon.c
index 70ce06148071,40c713fae0c3..000000000000
--- a/drivers/usb/serial/opticon.c
+++ b/drivers/usb/serial/opticon.c
@@@ -352,20 -352,6 +352,23 @@@ static int opticon_tiocmset(struct tty_
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int get_serial_info(struct tty_struct *tty,
 +			   struct serial_struct *ss)
 +{
 +	struct usb_serial_port *port = tty->driver_data;
 +
 +	/* fake emulate a 16550 uart to make userspace code happy */
 +	ss->type		= PORT_16550A;
 +	ss->line		= port->minor;
 +	ss->close_delay		= 50;
 +	ss->closing_wait	= 3000;
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> f64d74a59c47 (USB: serial: stop reporting legacy UART types)
  static int opticon_port_probe(struct usb_serial_port *port)
  {
  	struct opticon_private *priv;
diff --cc drivers/usb/serial/pl2303.c
index aec563888ecf,fd773d252691..000000000000
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@@ -1050,19 -1048,6 +1050,22 @@@ static int pl2303_carrier_raised(struc
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int pl2303_get_serial(struct tty_struct *tty,
 +			struct serial_struct *ss)
 +{
 +	struct usb_serial_port *port = tty->driver_data;
 +
 +	ss->type = PORT_16654;
 +	ss->line = port->minor;
 +	ss->close_delay = 50;
 +	ss->closing_wait = 3000;
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> f64d74a59c47 (USB: serial: stop reporting legacy UART types)
  static void pl2303_set_break(struct usb_serial_port *port, bool enable)
  {
  	struct usb_serial *serial = port->serial;
diff --cc drivers/usb/serial/ti_usb_3410_5052.c
index 67100e1004b8,c312d0cce5fb..000000000000
--- a/drivers/usb/serial/ti_usb_3410_5052.c
+++ b/drivers/usb/serial/ti_usb_3410_5052.c
@@@ -1400,41 -1392,8 +1400,44 @@@ static int ti_get_serial_info(struct tt
  {
  	struct usb_serial_port *port = tty->driver_data;
  	struct ti_port *tport = usb_get_serial_port_data(port);
 +	unsigned cwait;
  
 +	cwait = port->port.closing_wait;
 +	if (cwait != ASYNC_CLOSING_WAIT_NONE)
 +		cwait = jiffies_to_msecs(cwait) / 10;
 +
++<<<<<<< HEAD
 +	ss->type = PORT_16550A;
 +	ss->line = port->minor;
++=======
++>>>>>>> f64d74a59c47 (USB: serial: stop reporting legacy UART types)
  	ss->baud_base = tport->tp_tdev->td_is_3410 ? 921600 : 460800;
 +	ss->close_delay = 50;
 +	ss->closing_wait = cwait;
 +
 +	return 0;
 +}
 +
 +
 +static int ti_set_serial_info(struct tty_struct *tty,
 +	struct serial_struct *ss)
 +{
 +	struct usb_serial_port *port = tty->driver_data;
 +	struct tty_port *tport = &port->port;
 +	unsigned cwait;
 +
 +	cwait = ss->closing_wait;
 +	if (cwait != ASYNC_CLOSING_WAIT_NONE)
 +		cwait = msecs_to_jiffies(10 * ss->closing_wait);
 +
 +	if (!capable(CAP_SYS_ADMIN)) {
 +		if (cwait != tport->closing_wait)
 +			return -EPERM;
 +	}
 +
 +	tport->closing_wait = cwait;
 +
 +	return 0;
  }
  
  
diff --cc drivers/usb/serial/whiteheat.c
index 4f85291d525d,5116ed9db3eb..000000000000
--- a/drivers/usb/serial/whiteheat.c
+++ b/drivers/usb/serial/whiteheat.c
@@@ -441,18 -439,9 +441,21 @@@ static int whiteheat_tiocmset(struct tt
  }
  
  
 -static void whiteheat_get_serial(struct tty_struct *tty, struct serial_struct *ss)
 +static int whiteheat_get_serial(struct tty_struct *tty,
 +				struct serial_struct *ss)
  {
++<<<<<<< HEAD
 +	struct usb_serial_port *port = tty->driver_data;
 +
 +	ss->type = PORT_16654;
 +	ss->line = port->minor;
++=======
++>>>>>>> f64d74a59c47 (USB: serial: stop reporting legacy UART types)
  	ss->baud_base = 460800;
 +	ss->close_delay = 50;
 +	ss->closing_wait = 3000;
 +
 +	return 0;
  }
  
  
* Unmerged path drivers/usb/serial/ark3116.c
* Unmerged path drivers/usb/serial/f81232.c
* Unmerged path drivers/usb/serial/f81534.c
* Unmerged path drivers/usb/serial/io_edgeport.c
* Unmerged path drivers/usb/serial/io_ti.c
* Unmerged path drivers/usb/serial/mos7720.c
* Unmerged path drivers/usb/serial/mos7840.c
* Unmerged path drivers/usb/serial/opticon.c
* Unmerged path drivers/usb/serial/pl2303.c
* Unmerged path drivers/usb/serial/ti_usb_3410_5052.c
* Unmerged path drivers/usb/serial/whiteheat.c
