swiotlb: Support aligned swiotlb buffers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author David Stevens <stevensd@chromium.org>
commit e81e99bacc9f9347bda7808a949c1ce9fcc2bbf4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/e81e99ba.failed

Add an argument to swiotlb_tbl_map_single that specifies the desired
alignment of the allocated buffer. This is used by dma-iommu to ensure
the buffer is aligned to the iova granule size when using swiotlb with
untrusted sub-granule mappings. This addresses an issue where adjacent
slots could be exposed to the untrusted device if IO_TLB_SIZE < iova
granule < PAGE_SIZE.

	Signed-off-by: David Stevens <stevensd@chromium.org>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
Link: https://lore.kernel.org/r/20210929023300.335969-7-stevensd@google.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit e81e99bacc9f9347bda7808a949c1ce9fcc2bbf4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/dma-iommu.c
#	kernel/dma/swiotlb.c
diff --cc drivers/iommu/dma-iommu.c
index 5899c384b30a,289c49ead01a..000000000000
--- a/drivers/iommu/dma-iommu.c
+++ b/drivers/iommu/dma-iommu.c
@@@ -870,9 -802,48 +870,47 @@@ static dma_addr_t iommu_dma_map_page(st
  {
  	phys_addr_t phys = page_to_phys(page) + offset;
  	bool coherent = dev_is_dma_coherent(dev);
 -	int prot = dma_info_to_prot(dir, coherent, attrs);
 -	struct iommu_domain *domain = iommu_get_dma_domain(dev);
 -	struct iommu_dma_cookie *cookie = domain->iova_cookie;
 -	struct iova_domain *iovad = &cookie->iovad;
 -	size_t aligned_size = size;
 -	dma_addr_t iova, dma_mask = dma_get_mask(dev);
  
++<<<<<<< HEAD
 +	return __iommu_dma_map_swiotlb(dev, phys, size, dma_get_mask(dev),
 +			coherent, dir, attrs);
++=======
+ 	/*
+ 	 * If both the physical buffer start address and size are
+ 	 * page aligned, we don't need to use a bounce page.
+ 	 */
+ 	if (dev_use_swiotlb(dev) && iova_offset(iovad, phys | size)) {
+ 		void *padding_start;
+ 		size_t padding_size;
+ 
+ 		aligned_size = iova_align(iovad, size);
+ 		phys = swiotlb_tbl_map_single(dev, phys, size, aligned_size,
+ 					      iova_mask(iovad), dir, attrs);
+ 
+ 		if (phys == DMA_MAPPING_ERROR)
+ 			return DMA_MAPPING_ERROR;
+ 
+ 		/* Cleanup the padding area. */
+ 		padding_start = phys_to_virt(phys);
+ 		padding_size = aligned_size;
+ 
+ 		if (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&
+ 		    (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL)) {
+ 			padding_start += size;
+ 			padding_size -= size;
+ 		}
+ 
+ 		memset(padding_start, 0, padding_size);
+ 	}
+ 
+ 	if (!coherent && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))
+ 		arch_sync_dma_for_device(phys, size, dir);
+ 
+ 	iova = __iommu_dma_map(dev, phys, aligned_size, prot, dma_mask);
+ 	if (iova == DMA_MAPPING_ERROR && is_swiotlb_buffer(dev, phys))
+ 		swiotlb_tbl_unmap_single(dev, phys, size, dir, attrs);
+ 	return iova;
++>>>>>>> e81e99bacc9f (swiotlb: Support aligned swiotlb buffers)
  }
  
  static void iommu_dma_unmap_page(struct device *dev, dma_addr_t dma_handle,
diff --cc kernel/dma/swiotlb.c
index be0e4e04c6fd,019672b3da1d..000000000000
--- a/kernel/dma/swiotlb.c
+++ b/kernel/dma/swiotlb.c
@@@ -535,12 -458,13 +535,17 @@@ static unsigned int wrap_index(unsigne
   * Find a suitable number of IO TLB entries size that will fit this request and
   * allocate a buffer from that IO TLB pool.
   */
++<<<<<<< HEAD
 +static int find_slots(struct device *dev, phys_addr_t orig_addr,
 +		size_t alloc_size)
++=======
+ static int swiotlb_find_slots(struct device *dev, phys_addr_t orig_addr,
+ 			      size_t alloc_size, unsigned int alloc_align_mask)
++>>>>>>> e81e99bacc9f (swiotlb: Support aligned swiotlb buffers)
  {
 -	struct io_tlb_mem *mem = dev->dma_io_tlb_mem;
  	unsigned long boundary_mask = dma_get_seg_boundary(dev);
  	dma_addr_t tbl_dma_addr =
 -		phys_to_dma_unencrypted(dev, mem->start) & boundary_mask;
 +		phys_to_dma_unencrypted(dev, io_tlb_start) & boundary_mask;
  	unsigned long max_slots = get_max_slots(boundary_mask);
  	unsigned int iotlb_align_mask =
  		dma_get_min_align_mask(dev) & ~(IO_TLB_SIZE - 1);
@@@ -558,16 -483,18 +563,17 @@@
  	stride = (iotlb_align_mask >> IO_TLB_SHIFT) + 1;
  	if (alloc_size >= PAGE_SIZE)
  		stride = max(stride, stride << (PAGE_SHIFT - IO_TLB_SHIFT));
+ 	stride = max(stride, (alloc_align_mask >> IO_TLB_SHIFT) + 1);
  
 -	spin_lock_irqsave(&mem->lock, flags);
 -	if (unlikely(nslots > mem->nslabs - mem->used))
 +	spin_lock_irqsave(&io_tlb_lock, flags);
 +	if (unlikely(nslots > io_tlb_nslabs - io_tlb_used))
  		goto not_found;
  
 -	index = wrap = wrap_index(mem, ALIGN(mem->index, stride));
 +	index = wrap = wrap_index(ALIGN(io_tlb_index, stride));
  	do {
 -		if (orig_addr &&
 -		    (slot_addr(tbl_dma_addr, index) & iotlb_align_mask) !=
 -			    (orig_addr & iotlb_align_mask)) {
 -			index = wrap_index(mem, index + 1);
 +		if ((slot_addr(tbl_dma_addr, index) & iotlb_align_mask) !=
 +		    (orig_addr & iotlb_align_mask)) {
 +			index = wrap_index(index + 1);
  			continue;
  		}
  
@@@ -612,8 -542,10 +618,9 @@@ found
  
  phys_addr_t swiotlb_tbl_map_single(struct device *dev, phys_addr_t orig_addr,
  		size_t mapping_size, size_t alloc_size,
- 		enum dma_data_direction dir, unsigned long attrs)
+ 		unsigned int alloc_align_mask, enum dma_data_direction dir,
+ 		unsigned long attrs)
  {
 -	struct io_tlb_mem *mem = dev->dma_io_tlb_mem;
  	unsigned int offset = swiotlb_align_offset(dev, orig_addr);
  	unsigned int i;
  	int index;
@@@ -631,7 -563,8 +638,12 @@@
  		return (phys_addr_t)DMA_MAPPING_ERROR;
  	}
  
++<<<<<<< HEAD
 +	index = find_slots(dev, orig_addr, alloc_size + offset);
++=======
+ 	index = swiotlb_find_slots(dev, orig_addr,
+ 				   alloc_size + offset, alloc_align_mask);
++>>>>>>> e81e99bacc9f (swiotlb: Support aligned swiotlb buffers)
  	if (index == -1) {
  		if (!(attrs & DMA_ATTR_NO_WARN))
  			dev_warn_ratelimited(dev,
@@@ -796,24 -704,153 +808,110 @@@ size_t swiotlb_max_mapping_size(struct 
  	return ((size_t)IO_TLB_SIZE) * IO_TLB_SEGSIZE;
  }
  
 -bool is_swiotlb_active(struct device *dev)
 +bool is_swiotlb_active(void)
  {
++<<<<<<< HEAD
++=======
+ 	struct io_tlb_mem *mem = dev->dma_io_tlb_mem;
+ 
+ 	return mem && mem->nslabs;
+ }
+ EXPORT_SYMBOL_GPL(is_swiotlb_active);
+ 
+ #ifdef CONFIG_DEBUG_FS
+ static struct dentry *debugfs_dir;
+ 
+ static void swiotlb_create_debugfs_files(struct io_tlb_mem *mem)
+ {
+ 	debugfs_create_ulong("io_tlb_nslabs", 0400, mem->debugfs, &mem->nslabs);
+ 	debugfs_create_ulong("io_tlb_used", 0400, mem->debugfs, &mem->used);
+ }
+ 
+ static int __init swiotlb_create_default_debugfs(void)
+ {
+ 	struct io_tlb_mem *mem = &io_tlb_default_mem;
+ 
+ 	debugfs_dir = debugfs_create_dir("swiotlb", NULL);
+ 	if (mem->nslabs) {
+ 		mem->debugfs = debugfs_dir;
+ 		swiotlb_create_debugfs_files(mem);
+ 	}
+ 	return 0;
+ }
+ 
+ late_initcall(swiotlb_create_default_debugfs);
+ 
+ #endif
+ 
+ #ifdef CONFIG_DMA_RESTRICTED_POOL
+ 
+ #ifdef CONFIG_DEBUG_FS
+ static void rmem_swiotlb_debugfs_init(struct reserved_mem *rmem)
+ {
+ 	struct io_tlb_mem *mem = rmem->priv;
+ 
+ 	mem->debugfs = debugfs_create_dir(rmem->name, debugfs_dir);
+ 	swiotlb_create_debugfs_files(mem);
+ }
+ #else
+ static void rmem_swiotlb_debugfs_init(struct reserved_mem *rmem)
+ {
+ }
+ #endif
+ 
+ struct page *swiotlb_alloc(struct device *dev, size_t size)
+ {
+ 	struct io_tlb_mem *mem = dev->dma_io_tlb_mem;
+ 	phys_addr_t tlb_addr;
+ 	int index;
+ 
+ 	if (!mem)
+ 		return NULL;
+ 
+ 	index = swiotlb_find_slots(dev, 0, size, 0);
+ 	if (index == -1)
+ 		return NULL;
+ 
+ 	tlb_addr = slot_addr(mem->start, index);
+ 
+ 	return pfn_to_page(PFN_DOWN(tlb_addr));
+ }
+ 
+ bool swiotlb_free(struct device *dev, struct page *page, size_t size)
+ {
+ 	phys_addr_t tlb_addr = page_to_phys(page);
+ 
+ 	if (!is_swiotlb_buffer(dev, tlb_addr))
+ 		return false;
+ 
+ 	swiotlb_release_slots(dev, tlb_addr);
+ 
+ 	return true;
+ }
+ 
+ static int rmem_swiotlb_device_init(struct reserved_mem *rmem,
+ 				    struct device *dev)
+ {
+ 	struct io_tlb_mem *mem = rmem->priv;
+ 	unsigned long nslabs = rmem->size >> IO_TLB_SHIFT;
+ 
++>>>>>>> e81e99bacc9f (swiotlb: Support aligned swiotlb buffers)
  	/*
 -	 * Since multiple devices can share the same pool, the private data,
 -	 * io_tlb_mem struct, will be initialized by the first device attached
 -	 * to it.
 +	 * When SWIOTLB is initialized, even if io_tlb_start points to physical
 +	 * address zero, io_tlb_end surely doesn't.
  	 */
 -	if (!mem) {
 -		mem = kzalloc(sizeof(*mem), GFP_KERNEL);
 -		if (!mem)
 -			return -ENOMEM;
 -
 -		mem->slots = kzalloc(array_size(sizeof(*mem->slots), nslabs),
 -				     GFP_KERNEL);
 -		if (!mem->slots) {
 -			kfree(mem);
 -			return -ENOMEM;
 -		}
 -
 -		set_memory_decrypted((unsigned long)phys_to_virt(rmem->base),
 -				     rmem->size >> PAGE_SHIFT);
 -		swiotlb_init_io_tlb_mem(mem, rmem->base, nslabs, false);
 -		mem->force_bounce = true;
 -		mem->for_alloc = true;
 -
 -		rmem->priv = mem;
 -
 -		rmem_swiotlb_debugfs_init(rmem);
 -	}
 -
 -	dev->dma_io_tlb_mem = mem;
 -
 -	return 0;
 -}
 -
 -static void rmem_swiotlb_device_release(struct reserved_mem *rmem,
 -					struct device *dev)
 -{
 -	dev->dma_io_tlb_mem = &io_tlb_default_mem;
 +	return io_tlb_end != 0;
  }
  
 -static const struct reserved_mem_ops rmem_swiotlb_ops = {
 -	.device_init = rmem_swiotlb_device_init,
 -	.device_release = rmem_swiotlb_device_release,
 -};
 +#ifdef CONFIG_DEBUG_FS
  
 -static int __init rmem_swiotlb_setup(struct reserved_mem *rmem)
 +static int __init swiotlb_create_debugfs(void)
  {
 -	unsigned long node = rmem->fdt_node;
 +	struct dentry *root;
  
 -	if (of_get_flat_dt_prop(node, "reusable", NULL) ||
 -	    of_get_flat_dt_prop(node, "linux,cma-default", NULL) ||
 -	    of_get_flat_dt_prop(node, "linux,dma-default", NULL) ||
 -	    of_get_flat_dt_prop(node, "no-map", NULL))
 -		return -EINVAL;
 -
 -	if (PageHighMem(pfn_to_page(PHYS_PFN(rmem->base)))) {
 -		pr_err("Restricted DMA pool must be accessible within the linear mapping.");
 -		return -EINVAL;
 -	}
 -
 -	rmem->ops = &rmem_swiotlb_ops;
 -	pr_info("Reserved memory: created restricted DMA pool at %pa, size %ld MiB\n",
 -		&rmem->base, (unsigned long)rmem->size / SZ_1M);
 +	root = debugfs_create_dir("swiotlb", NULL);
 +	debugfs_create_ulong("io_tlb_nslabs", 0400, root, &io_tlb_nslabs);
 +	debugfs_create_ulong("io_tlb_used", 0400, root, &io_tlb_used);
  	return 0;
  }
  
* Unmerged path drivers/iommu/dma-iommu.c
diff --git a/drivers/xen/swiotlb-xen.c b/drivers/xen/swiotlb-xen.c
index 8ccd85660984..1c3975aa8bc8 100644
--- a/drivers/xen/swiotlb-xen.c
+++ b/drivers/xen/swiotlb-xen.c
@@ -377,7 +377,7 @@ static dma_addr_t xen_swiotlb_map_page(struct device *dev, struct page *page,
 	 */
 	trace_swiotlb_bounced(dev, dev_addr, size, swiotlb_force);
 
-	map = swiotlb_tbl_map_single(dev, phys, size, size, dir, attrs);
+	map = swiotlb_tbl_map_single(dev, phys, size, size, 0, dir, attrs);
 	if (map == (phys_addr_t)DMA_MAPPING_ERROR)
 		return DMA_MAPPING_ERROR;
 
diff --git a/include/linux/swiotlb.h b/include/linux/swiotlb.h
index 5857a937c637..0b35dda2aecc 100644
--- a/include/linux/swiotlb.h
+++ b/include/linux/swiotlb.h
@@ -52,7 +52,8 @@ enum dma_sync_target {
 
 phys_addr_t swiotlb_tbl_map_single(struct device *hwdev, phys_addr_t phys,
 		size_t mapping_size, size_t alloc_size,
-		enum dma_data_direction dir, unsigned long attrs);
+		unsigned int alloc_aligned_mask, enum dma_data_direction dir,
+		unsigned long attrs);
 
 extern void swiotlb_tbl_unmap_single(struct device *hwdev,
 				     phys_addr_t tlb_addr,
* Unmerged path kernel/dma/swiotlb.c
