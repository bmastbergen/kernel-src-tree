ACPI: scan: initialize local variable to avoid garbage being returned

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Colin Ian King <colin.king@canonical.com>
commit 23db673d7e5194c8fbbb8c307e23960767305c09
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/23db673d.failed

In the unlikely event that there are no callback calls made in
acpi_walk_dep_device_list(), local variable ret will be returned as
an uninitialized value.

Clean up static analysis warnings by ensuring ret is initialized.

Addresses-Coverity: ("Uninitialized scalar variable")
Fixes: a9e10e587304 ("ACPI: scan: Extend acpi_walk_dep_device_list()")
	Signed-off-by: Colin Ian King <colin.king@canonical.com>
	Reviewed-by: Daniel Scally <djrscally@gmail.com>
[ rjw: Subject and changelog edits ]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 23db673d7e5194c8fbbb8c307e23960767305c09)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
diff --cc drivers/acpi/scan.c
index 7c82197723ba,f64119a17382..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -2118,10 -2101,56 +2118,14 @@@ static void acpi_bus_attach(struct acpi
  		device->handler->hotplug.notify_online(device);
  }
  
 -static int acpi_dev_get_first_consumer_dev_cb(struct acpi_dep_data *dep, void *data)
 -{
 -	struct acpi_device *adev;
 -
 -	adev = acpi_bus_get_acpi_device(dep->consumer);
 -	if (!adev)
 -		/* If we don't find an adev then we want to continue parsing */
 -		return 0;
 -
 -	*(struct acpi_device **)data = adev;
 -
 -	return 1;
 -}
 -
 -static int acpi_scan_clear_dep(struct acpi_dep_data *dep, void *data)
 -{
 -	struct acpi_device *adev;
 -
 -	acpi_bus_get_device(dep->consumer, &adev);
 -
 -	if (adev) {
 -		adev->dep_unmet--;
 -		if (!adev->dep_unmet)
 -			acpi_bus_attach(adev, true);
 -	}
 -
 -	list_del(&dep->node);
 -	kfree(dep);
 -
 -	return 0;
 -}
 -
 -/**
 - * acpi_walk_dep_device_list - Apply a callback to every entry in acpi_dep_list
 - * @handle:	The ACPI handle of the supplier device
 - * @callback:	Pointer to the callback function to apply
 - * @data:	Pointer to some data to pass to the callback
 - *
 - * The return value of the callback determines this function's behaviour. If 0
 - * is returned we continue to iterate over acpi_dep_list. If a positive value
 - * is returned then the loop is broken but this function returns 0. If a
 - * negative value is returned by the callback then the loop is broken and that
 - * value is returned as the final error.
 - */
 -int acpi_walk_dep_device_list(acpi_handle handle,
 -			      int (*callback)(struct acpi_dep_data *, void *),
 -			      void *data)
 +void acpi_walk_dep_device_list(acpi_handle handle)
  {
  	struct acpi_dep_data *dep, *tmp;
++<<<<<<< HEAD
 +	struct acpi_device *adev;
++=======
+ 	int ret = 0;
++>>>>>>> 23db673d7e51 (ACPI: scan: initialize local variable to avoid garbage being returned)
  
  	mutex_lock(&acpi_dep_list_lock);
  	list_for_each_entry_safe(dep, tmp, &acpi_dep_list, node) {
* Unmerged path drivers/acpi/scan.c
