fanotify: Use interruptible wait when waiting for permission events

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Jan Kara <jack@suse.cz>
commit fabf7f29b3e2ce5ed9741bf06f3583cd7e82ed1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/fabf7f29.failed

When waiting for response to fanotify permission events, we currently
use uninterruptible waits. That makes code simple however it can cause
lots of processes to end up in uninterruptible sleep with hard reboot
being the only alternative in case fanotify listener process stops
responding (e.g. due to a bug in its implementation). Uninterruptible
sleep also makes system hibernation fail if the listener gets frozen
before the process generating fanotify permission event.

Fix these problems by using interruptible sleep for waiting for response
to fanotify event. This is slightly tricky though - we have to
detect when the event got already reported to userspace as in that
case we must not free the event. Instead we push the responsibility for
freeing the event to the process that will write response to the
event.

	Reported-by: Orion Poplawski <orion@nwra.com>
	Reported-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit fabf7f29b3e2ce5ed9741bf06f3583cd7e82ed1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/fanotify/fanotify.c
#	fs/notify/fanotify/fanotify.h
#	fs/notify/fanotify/fanotify_user.c
diff --cc fs/notify/fanotify/fanotify.c
index 2a603513f12e,ff7b8a1cdfe1..000000000000
--- a/fs/notify/fanotify/fanotify.c
+++ b/fs/notify/fanotify/fanotify.c
@@@ -57,15 -77,44 +57,48 @@@ static int fanotify_merge(struct list_h
  	return 0;
  }
  
+ /*
+  * Wait for response to permission event. The function also takes care of
+  * freeing the permission event (or offloads that in case the wait is canceled
+  * by a signal). The function returns 0 in case access got allowed by userspace,
+  * -EPERM in case userspace disallowed the access, and -ERESTARTSYS in case
+  * the wait got interrupted by a signal.
+  */
  static int fanotify_get_response(struct fsnotify_group *group,
 -				 struct fanotify_perm_event *event,
 +				 struct fanotify_perm_event_info *event,
  				 struct fsnotify_iter_info *iter_info)
  {
  	int ret;
  
  	pr_debug("%s: group=%p event=%p\n", __func__, group, event);
  
++<<<<<<< HEAD
 +	wait_event(group->fanotify_data.access_waitq, event->response);
++=======
+ 	ret = wait_event_interruptible(group->fanotify_data.access_waitq,
+ 				       event->state == FAN_EVENT_ANSWERED);
+ 	/* Signal pending? */
+ 	if (ret < 0) {
+ 		spin_lock(&group->notification_lock);
+ 		/* Event reported to userspace and no answer yet? */
+ 		if (event->state == FAN_EVENT_REPORTED) {
+ 			/* Event will get freed once userspace answers to it */
+ 			event->state = FAN_EVENT_CANCELED;
+ 			spin_unlock(&group->notification_lock);
+ 			return ret;
+ 		}
+ 		/* Event not yet reported? Just remove it. */
+ 		if (event->state == FAN_EVENT_INIT)
+ 			fsnotify_remove_queued_event(group, &event->fae.fse);
+ 		/*
+ 		 * Event may be also answered in case signal delivery raced
+ 		 * with wakeup. In that case we have nothing to do besides
+ 		 * freeing the event and reporting error.
+ 		 */
+ 		spin_unlock(&group->notification_lock);
+ 		goto out;
+ 	}
++>>>>>>> fabf7f29b3e2 (fanotify: Use interruptible wait when waiting for permission events)
  
  	/* userspace responded, convert to something usable */
  	switch (event->response & ~FAN_AUDIT) {
@@@ -81,11 -130,11 +114,17 @@@
  	if (event->response & FAN_AUDIT)
  		audit_fanotify(event->response & ~FAN_AUDIT);
  
 +	event->response = 0;
 +
  	pr_debug("%s: group=%p event=%p about to return ret=%d\n", __func__,
  		 group, event, ret);
++<<<<<<< HEAD
 +	
++=======
+ out:
+ 	fsnotify_destroy_event(group, &event->fae.fse);
+ 
++>>>>>>> fabf7f29b3e2 (fanotify: Use interruptible wait when waiting for permission events)
  	return ret;
  }
  
diff --cc fs/notify/fanotify/fanotify.h
index ea05b8a401e7,68b30504284c..000000000000
--- a/fs/notify/fanotify/fanotify.h
+++ b/fs/notify/fanotify/fanotify.h
@@@ -7,6 -8,51 +7,54 @@@ extern struct kmem_cache *fanotify_mark
  extern struct kmem_cache *fanotify_event_cachep;
  extern struct kmem_cache *fanotify_perm_event_cachep;
  
++<<<<<<< HEAD
++=======
+ /* Possible states of the permission event */
+ enum {
+ 	FAN_EVENT_INIT,
+ 	FAN_EVENT_REPORTED,
+ 	FAN_EVENT_ANSWERED,
+ 	FAN_EVENT_CANCELED,
+ };
+ 
+ /*
+  * 3 dwords are sufficient for most local fs (64bit ino, 32bit generation).
+  * For 32bit arch, fid increases the size of fanotify_event by 12 bytes and
+  * fh_* fields increase the size of fanotify_event by another 4 bytes.
+  * For 64bit arch, fid increases the size of fanotify_fid by 8 bytes and
+  * fh_* fields are packed in a hole after mask.
+  */
+ #if BITS_PER_LONG == 32
+ #define FANOTIFY_INLINE_FH_LEN	(3 << 2)
+ #else
+ #define FANOTIFY_INLINE_FH_LEN	(4 << 2)
+ #endif
+ 
+ struct fanotify_fid {
+ 	__kernel_fsid_t fsid;
+ 	union {
+ 		unsigned char fh[FANOTIFY_INLINE_FH_LEN];
+ 		unsigned char *ext_fh;
+ 	};
+ };
+ 
+ static inline void *fanotify_fid_fh(struct fanotify_fid *fid,
+ 				    unsigned int fh_len)
+ {
+ 	return fh_len <= FANOTIFY_INLINE_FH_LEN ? fid->fh : fid->ext_fh;
+ }
+ 
+ static inline bool fanotify_fid_equal(struct fanotify_fid *fid1,
+ 				      struct fanotify_fid *fid2,
+ 				      unsigned int fh_len)
+ {
+ 	return fid1->fsid.val[0] == fid2->fsid.val[0] &&
+ 		fid1->fsid.val[1] == fid2->fsid.val[1] &&
+ 		!memcmp(fanotify_fid_fh(fid1, fh_len),
+ 			fanotify_fid_fh(fid2, fh_len), fh_len);
+ }
+ 
++>>>>>>> fabf7f29b3e2 (fanotify: Use interruptible wait when waiting for permission events)
  /*
   * Structure for normal fanotify events. It gets allocated in
   * fanotify_handle_event() and freed when the information is retrieved by
diff --cc fs/notify/fanotify/fanotify_user.c
index 48689619c0fd,56992b32c6bb..000000000000
--- a/fs/notify/fanotify/fanotify_user.c
+++ b/fs/notify/fanotify/fanotify_user.c
@@@ -114,56 -138,26 +114,70 @@@ static int create_fd(struct fsnotify_gr
  	return client_fd;
  }
  
 -/*
 - * Finish processing of permission event by setting it to ANSWERED state and
 - * drop group->notification_lock.
 - */
 -static void finish_permission_event(struct fsnotify_group *group,
 -				    struct fanotify_perm_event *event,
 -				    unsigned int response)
 -				    __releases(&group->notification_lock)
 +static int fill_event_metadata(struct fsnotify_group *group,
 +			       struct fanotify_event_metadata *metadata,
 +			       struct fsnotify_event *fsn_event,
 +			       struct file **file)
 +{
++<<<<<<< HEAD
 +	int ret = 0;
 +	struct fanotify_event_info *event;
 +
 +	pr_debug("%s: group=%p metadata=%p event=%p\n", __func__,
 +		 group, metadata, fsn_event);
 +
 +	*file = NULL;
 +	event = container_of(fsn_event, struct fanotify_event_info, fse);
 +	metadata->event_len = FAN_EVENT_METADATA_LEN;
 +	metadata->metadata_len = FAN_EVENT_METADATA_LEN;
 +	metadata->vers = FANOTIFY_METADATA_VERSION;
 +	metadata->reserved = 0;
 +	metadata->mask = fsn_event->mask & FANOTIFY_OUTGOING_EVENTS;
 +	metadata->pid = pid_vnr(event->pid);
 +	if (unlikely(fsn_event->mask & FAN_Q_OVERFLOW))
 +		metadata->fd = FAN_NOFD;
 +	else {
 +		metadata->fd = create_fd(group, event, file);
 +		if (metadata->fd < 0)
 +			ret = metadata->fd;
 +	}
 +
 +	return ret;
 +}
 +
 +static struct fanotify_perm_event_info *dequeue_event(
 +				struct fsnotify_group *group, int fd)
  {
 +	struct fanotify_perm_event_info *event, *return_e = NULL;
 +
 +	spin_lock(&group->notification_lock);
 +	list_for_each_entry(event, &group->fanotify_data.access_list,
 +			    fae.fse.list) {
 +		if (event->fd != fd)
 +			continue;
 +
 +		list_del_init(&event->fae.fse.list);
 +		return_e = event;
 +		break;
 +	}
 +	spin_unlock(&group->notification_lock);
 +
 +	pr_debug("%s: found return_re=%p\n", __func__, return_e);
 +
 +	return return_e;
++=======
+ 	bool destroy = false;
+ 
+ 	assert_spin_locked(&group->notification_lock);
+ 	event->response = response;
+ 	if (event->state == FAN_EVENT_CANCELED)
+ 		destroy = true;
+ 	else
+ 		event->state = FAN_EVENT_ANSWERED;
+ 	spin_unlock(&group->notification_lock);
+ 	if (destroy)
+ 		fsnotify_destroy_event(group, &event->fae.fse);
++>>>>>>> fabf7f29b3e2 (fanotify: Use interruptible wait when waiting for permission events)
  }
  
  static int process_access_response(struct fsnotify_group *group,
* Unmerged path fs/notify/fanotify/fanotify.c
* Unmerged path fs/notify/fanotify/fanotify.h
* Unmerged path fs/notify/fanotify/fanotify_user.c
