x86/fpu: Convert restore_fpregs_from_fpstate() to struct fpstate

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 18b3fa1ad15fa8d777ac32f117553cce1a968460
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/18b3fa1a.failed

Convert restore_fpregs_from_fpstate() and related code to the new
register storage mechanism in preparation for dynamically sized buffers.

No functional change.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20211013145322.347395546@linutronix.de
(cherry picked from commit 18b3fa1ad15fa8d777ac32f117553cce1a968460)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/fpu/signal.h
#	arch/x86/kernel/fpu/core.c
diff --cc arch/x86/include/asm/fpu/signal.h
index 04868a76239a,22b0273a8bf1..000000000000
--- a/arch/x86/include/asm/fpu/signal.h
+++ b/arch/x86/include/asm/fpu/signal.h
@@@ -31,4 -36,12 +31,15 @@@ fpu__alloc_mathframe(unsigned long sp, 
  
  unsigned long fpu__get_fpstate_size(void);
  
++<<<<<<< HEAD
++=======
+ extern bool copy_fpstate_to_sigframe(void __user *buf, void __user *fp, int size);
+ extern void fpu__clear_user_states(struct fpu *fpu);
+ extern bool fpu__restore_sig(void __user *buf, int ia32_frame);
+ 
+ extern void restore_fpregs_from_fpstate(struct fpstate *fpstate, u64 mask);
+ 
+ extern bool copy_fpstate_to_sigframe(void __user *buf, void __user *fp, int size);
+ 
++>>>>>>> 18b3fa1ad15f (x86/fpu: Convert restore_fpregs_from_fpstate() to struct fpstate)
  #endif /* _ASM_X86_FPU_SIGNAL_H */
diff --cc arch/x86/kernel/fpu/core.c
index 3f16056105e8,03926bf00971..000000000000
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@@ -147,6 -155,11 +147,14 @@@ void restore_fpregs_from_fpstate(struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ void fpu_reset_from_exception_fixup(void)
+ {
+ 	restore_fpregs_from_fpstate(&init_fpstate, xfeatures_mask_fpstate());
+ }
+ 
++>>>>>>> 18b3fa1ad15f (x86/fpu: Convert restore_fpregs_from_fpstate() to struct fpstate)
  #if IS_ENABLED(CONFIG_KVM)
  void fpu_swap_kvm_fpu(struct fpu *save, struct fpu *rstor, u64 restore_mask)
  {
* Unmerged path arch/x86/include/asm/fpu/signal.h
diff --git a/arch/x86/kernel/fpu/context.h b/arch/x86/kernel/fpu/context.h
index e652282842c8..f8f510519688 100644
--- a/arch/x86/kernel/fpu/context.h
+++ b/arch/x86/kernel/fpu/context.h
@@ -74,7 +74,7 @@ static inline void fpregs_restore_userregs(void)
 		 */
 		mask = xfeatures_mask_restore_user() |
 			xfeatures_mask_supervisor();
-		restore_fpregs_from_fpstate(&fpu->state, mask);
+		restore_fpregs_from_fpstate(fpu->fpstate, mask);
 
 		fpregs_activate(fpu);
 		fpu->last_cpu = cpu;
* Unmerged path arch/x86/kernel/fpu/core.c
