kasan: clean up comments in tests

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Andrey Konovalov <andreyknvl@google.com>
commit 0fd379253691e7bb7c0285a7b87525e1ff6e2fd2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/0fd37925.failed

Clarify and update comments in KASAN tests.

Link: https://linux-review.googlesource.com/id/I6c816c51fa1e0eb7aa3dead6bda1f339d2af46c8
Link: https://lkml.kernel.org/r/ba6db104d53ae0e3796f80ef395f6873c1c1282f.1610733117.git.andreyknvl@google.com
	Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
	Reviewed-by: Marco Elver <elver@google.com>
	Reviewed-by: Alexander Potapenko <glider@google.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Branislav Rankov <Branislav.Rankov@arm.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Evgenii Stepanov <eugenis@google.com>
	Cc: Kevin Brodsky <kevin.brodsky@arm.com>
	Cc: Peter Collingbourne <pcc@google.com>
	Cc: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0fd379253691e7bb7c0285a7b87525e1ff6e2fd2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/test_kasan.c
#	lib/test_kasan_module.c
diff --cc lib/test_kasan.c
index 5679dda37d78,6f46e27c2af7..000000000000
--- a/lib/test_kasan.c
+++ b/lib/test_kasan.c
@@@ -27,24 -21,59 +27,69 @@@
  
  #include <asm/page.h>
  
 -#include <kunit/test.h>
 -
  #include "../mm/kasan/kasan.h"
  
 -#define OOB_TAG_OFF (IS_ENABLED(CONFIG_KASAN_GENERIC) ? 0 : KASAN_GRANULE_SIZE)
 +#define OOB_TAG_OFF (IS_ENABLED(CONFIG_KASAN_GENERIC) ? 0 : KASAN_SHADOW_SCALE_SIZE)
  
  /*
-  * We assign some test results to these globals to make sure the tests
-  * are not eliminated as dead code.
+  * Some tests use these global variables to store return values from function
+  * calls that could otherwise be eliminated by the compiler as dead code.
   */
++<<<<<<< HEAD
 +
++=======
+ void *kasan_ptr_result;
++>>>>>>> 0fd379253691 (kasan: clean up comments in tests)
  int kasan_int_result;
 +void *kasan_ptr_result;
  
++<<<<<<< HEAD
 +/*
 + * Note: test functions are marked noinline so that their names appear in
 + * reports.
 + */
++=======
+ static struct kunit_resource resource;
+ static struct kunit_kasan_expectation fail_data;
+ static bool multishot;
+ 
+ /*
+  * Temporarily enable multi-shot mode. Otherwise, KASAN would only report the
+  * first detected bug and panic the kernel if panic_on_warn is enabled.
+  */
+ static int kasan_test_init(struct kunit *test)
+ {
+ 	multishot = kasan_save_enable_multi_shot();
+ 	return 0;
+ }
+ 
+ static void kasan_test_exit(struct kunit *test)
+ {
+ 	kasan_restore_multi_shot(multishot);
+ }
+ 
+ /**
+  * KUNIT_EXPECT_KASAN_FAIL() - check that the executed expression produces a
+  * KASAN report; causes a test failure otherwise. This relies on a KUnit
+  * resource named "kasan_data". Do not use this name for KUnit resources
+  * outside of KASAN tests.
+  */
+ #define KUNIT_EXPECT_KASAN_FAIL(test, expression) do { \
+ 	fail_data.report_expected = true; \
+ 	fail_data.report_found = false; \
+ 	kunit_add_named_resource(test, \
+ 				NULL, \
+ 				NULL, \
+ 				&resource, \
+ 				"kasan_data", &fail_data); \
+ 	expression; \
+ 	KUNIT_EXPECT_EQ(test, \
+ 			fail_data.report_expected, \
+ 			fail_data.report_found); \
+ } while (0)
++>>>>>>> 0fd379253691 (kasan: clean up comments in tests)
  
 -static void kmalloc_oob_right(struct kunit *test)
 +static noinline void __init kmalloc_oob_right(void)
  {
  	char *ptr;
  	size_t size = 123;
@@@ -99,18 -114,19 +144,28 @@@ static noinline void __init kmalloc_pag
  	char *ptr;
  	size_t size = KMALLOC_MAX_CACHE_SIZE + 10;
  
++<<<<<<< HEAD
 +	/* Allocate a chunk that does not fit into a SLUB cache to trigger
++=======
+ 	if (!IS_ENABLED(CONFIG_SLUB)) {
+ 		kunit_info(test, "CONFIG_SLUB is not enabled.");
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * Allocate a chunk that does not fit into a SLUB cache to trigger
++>>>>>>> 0fd379253691 (kasan: clean up comments in tests)
  	 * the page allocator fallback.
  	 */
 +	pr_info("kmalloc pagealloc allocation: out-of-bounds to right\n");
  	ptr = kmalloc(size, GFP_KERNEL);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr);
 +	if (!ptr) {
 +		pr_err("Allocation failed\n");
 +		return;
 +	}
 +
 +	ptr[size + OOB_TAG_OFF] = 0;
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, ptr[size + OOB_TAG_OFF] = 0);
  	kfree(ptr);
  }
  
@@@ -150,17 -167,15 +205,19 @@@ static noinline void __init kmalloc_lar
  {
  	char *ptr;
  	size_t size = KMALLOC_MAX_CACHE_SIZE - 256;
- 	/* Allocate a chunk that is large enough, but still fits into a slab
+ 
+ 	/*
+ 	 * Allocate a chunk that is large enough, but still fits into a slab
  	 * and does not trigger the page allocator fallback in SLUB.
  	 */
 +	pr_info("kmalloc large allocation: out-of-bounds to right\n");
  	ptr = kmalloc(size, GFP_KERNEL);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr);
 +	if (!ptr) {
 +		pr_err("Allocation failed\n");
 +		return;
 +	}
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, ptr[size] = 0);
 +	ptr[size] = 0;
  	kfree(ptr);
  }
  
@@@ -485,11 -453,34 +542,33 @@@ static noinline void __init kasan_globa
  	volatile int i = 3;
  	char *p = &global_array[ARRAY_SIZE(global_array) + i];
  
 -	/* Only generic mode instruments globals. */
 -	if (!IS_ENABLED(CONFIG_KASAN_GENERIC)) {
 -		kunit_info(test, "CONFIG_KASAN_GENERIC required");
 -		return;
 -	}
 -
 -	KUNIT_EXPECT_KASAN_FAIL(test, *(volatile char *)p);
 +	pr_info("out-of-bounds global variable\n");
 +	*(volatile char *)p;
  }
  
++<<<<<<< HEAD
 +static noinline void __init kasan_stack_oob(void)
++=======
+ static void ksize_unpoisons_memory(struct kunit *test)
+ {
+ 	char *ptr;
+ 	size_t size = 123, real_size;
+ 
+ 	ptr = kmalloc(size, GFP_KERNEL);
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr);
+ 	real_size = ksize(ptr);
+ 
+ 	/* This access shouldn't trigger a KASAN report. */
+ 	ptr[size] = 'x';
+ 
+ 	/* This one must. */
+ 	KUNIT_EXPECT_KASAN_FAIL(test, ptr[real_size] = 'y');
+ 
+ 	kfree(ptr);
+ }
+ 
+ static void kasan_stack_oob(struct kunit *test)
++>>>>>>> 0fd379253691 (kasan: clean up comments in tests)
  {
  	char stack_array[10];
  	volatile int i = OOB_TAG_OFF;
@@@ -627,8 -572,8 +706,13 @@@ static noinline void __init kmem_cache_
  		return;
  	}
  
++<<<<<<< HEAD
 +	/* Trigger invalid free, the object doesn't get freed */
 +	kmem_cache_free(cache, p + 1);
++=======
+ 	/* Trigger invalid free, the object doesn't get freed. */
+ 	KUNIT_EXPECT_KASAN_FAIL(test, kmem_cache_free(cache, p + 1));
++>>>>>>> 0fd379253691 (kasan: clean up comments in tests)
  
  	/*
  	 * Properly free the object to prevent the "Objects remaining in
@@@ -644,12 -589,25 +728,28 @@@ static noinline void __init kasan_memch
  	char *ptr;
  	size_t size = 24;
  
++<<<<<<< HEAD
 +	pr_info("out-of-bounds in memchr\n");
++=======
+ 	/*
+ 	 * str* functions are not instrumented with CONFIG_AMD_MEM_ENCRYPT.
+ 	 * See https://bugzilla.kernel.org/show_bug.cgi?id=206337 for details.
+ 	 */
+ 	if (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT)) {
+ 		kunit_info(test,
+ 			"str* functions are not instrumented with CONFIG_AMD_MEM_ENCRYPT");
+ 		return;
+ 	}
+ 
+ 	if (OOB_TAG_OFF)
+ 		size = round_up(size, OOB_TAG_OFF);
+ 
++>>>>>>> 0fd379253691 (kasan: clean up comments in tests)
  	ptr = kmalloc(size, GFP_KERNEL | __GFP_ZERO);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr);
 -
 -	KUNIT_EXPECT_KASAN_FAIL(test,
 -		kasan_ptr_result = memchr(ptr, '1', size + 1));
 +	if (!ptr)
 +		return;
  
 +	kasan_ptr_result = memchr(ptr, '1', size + 1);
  	kfree(ptr);
  }
  
@@@ -659,13 -617,25 +759,29 @@@ static noinline void __init kasan_memcm
  	size_t size = 24;
  	int arr[9];
  
++<<<<<<< HEAD
 +	pr_info("out-of-bounds in memcmp\n");
++=======
+ 	/*
+ 	 * str* functions are not instrumented with CONFIG_AMD_MEM_ENCRYPT.
+ 	 * See https://bugzilla.kernel.org/show_bug.cgi?id=206337 for details.
+ 	 */
+ 	if (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT)) {
+ 		kunit_info(test,
+ 			"str* functions are not instrumented with CONFIG_AMD_MEM_ENCRYPT");
+ 		return;
+ 	}
+ 
+ 	if (OOB_TAG_OFF)
+ 		size = round_up(size, OOB_TAG_OFF);
+ 
++>>>>>>> 0fd379253691 (kasan: clean up comments in tests)
  	ptr = kmalloc(size, GFP_KERNEL | __GFP_ZERO);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr);
 -	memset(arr, 0, sizeof(arr));
 +	if (!ptr)
 +		return;
  
 -	KUNIT_EXPECT_KASAN_FAIL(test,
 -		kasan_int_result = memcmp(ptr, arr, size+1));
 +	memset(arr, 0, sizeof(arr));
 +	kasan_int_result = memcmp(ptr, arr, size + 1);
  	kfree(ptr);
  }
  
@@@ -674,10 -644,18 +790,23 @@@ static noinline void __init kasan_strin
  	char *ptr;
  	size_t size = 24;
  
++<<<<<<< HEAD
 +	pr_info("use-after-free in strchr\n");
++=======
+ 	/*
+ 	 * str* functions are not instrumented with CONFIG_AMD_MEM_ENCRYPT.
+ 	 * See https://bugzilla.kernel.org/show_bug.cgi?id=206337 for details.
+ 	 */
+ 	if (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT)) {
+ 		kunit_info(test,
+ 			"str* functions are not instrumented with CONFIG_AMD_MEM_ENCRYPT");
+ 		return;
+ 	}
+ 
++>>>>>>> 0fd379253691 (kasan: clean up comments in tests)
  	ptr = kmalloc(size, GFP_KERNEL | __GFP_ZERO);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr);
 +	if (!ptr)
 +		return;
  
  	kfree(ptr);
  
@@@ -688,33 -666,64 +817,33 @@@
  	 * will likely point to zeroed byte.
  	 */
  	ptr += 16;
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_ptr_result = strchr(ptr, '1'));
 +	kasan_ptr_result = strchr(ptr, '1');
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_ptr_result = strrchr(ptr, '1'));
 +	pr_info("use-after-free in strrchr\n");
 +	kasan_ptr_result = strrchr(ptr, '1');
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result = strcmp(ptr, "2"));
 +	pr_info("use-after-free in strcmp\n");
 +	kasan_int_result = strcmp(ptr, "2");
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result = strncmp(ptr, "2", 1));
 +	pr_info("use-after-free in strncmp\n");
 +	kasan_int_result = strncmp(ptr, "2", 1);
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result = strlen(ptr));
 +	pr_info("use-after-free in strlen\n");
 +	kasan_int_result = strlen(ptr);
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result = strnlen(ptr, 1));
 +	pr_info("use-after-free in strnlen\n");
 +	kasan_int_result = strnlen(ptr, 1);
  }
  
 -static void kasan_bitops_modify(struct kunit *test, int nr, void *addr)
 +static noinline void __init kasan_bitops(void)
  {
 -	KUNIT_EXPECT_KASAN_FAIL(test, set_bit(nr, addr));
 -	KUNIT_EXPECT_KASAN_FAIL(test, __set_bit(nr, addr));
 -	KUNIT_EXPECT_KASAN_FAIL(test, clear_bit(nr, addr));
 -	KUNIT_EXPECT_KASAN_FAIL(test, __clear_bit(nr, addr));
 -	KUNIT_EXPECT_KASAN_FAIL(test, clear_bit_unlock(nr, addr));
 -	KUNIT_EXPECT_KASAN_FAIL(test, __clear_bit_unlock(nr, addr));
 -	KUNIT_EXPECT_KASAN_FAIL(test, change_bit(nr, addr));
 -	KUNIT_EXPECT_KASAN_FAIL(test, __change_bit(nr, addr));
 -}
 -
 -static void kasan_bitops_test_and_modify(struct kunit *test, int nr, void *addr)
 -{
 -	KUNIT_EXPECT_KASAN_FAIL(test, test_and_set_bit(nr, addr));
 -	KUNIT_EXPECT_KASAN_FAIL(test, __test_and_set_bit(nr, addr));
 -	KUNIT_EXPECT_KASAN_FAIL(test, test_and_set_bit_lock(nr, addr));
 -	KUNIT_EXPECT_KASAN_FAIL(test, test_and_clear_bit(nr, addr));
 -	KUNIT_EXPECT_KASAN_FAIL(test, __test_and_clear_bit(nr, addr));
 -	KUNIT_EXPECT_KASAN_FAIL(test, test_and_change_bit(nr, addr));
 -	KUNIT_EXPECT_KASAN_FAIL(test, __test_and_change_bit(nr, addr));
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result = test_bit(nr, addr));
 -
 -#if defined(clear_bit_unlock_is_negative_byte)
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result =
 -				clear_bit_unlock_is_negative_byte(nr, addr));
 -#endif
 -}
 -
 -static void kasan_bitops_generic(struct kunit *test)
 -{
 -	long *bits;
 -
 -	/* This test is specifically crafted for the generic mode. */
 -	if (!IS_ENABLED(CONFIG_KASAN_GENERIC)) {
 -		kunit_info(test, "CONFIG_KASAN_GENERIC required\n");
 -		return;
 -	}
 -
  	/*
- 	 * Allocate 1 more byte, which causes kzalloc to round up to 16-bytes;
+ 	 * Allocate 1 more byte, which causes kzalloc to round up to 16 bytes;
  	 * this way we do not actually corrupt other memory.
  	 */
 -	bits = kzalloc(sizeof(*bits) + 1, GFP_KERNEL);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, bits);
 +	long *bits = kzalloc(sizeof(*bits) + 1, GFP_KERNEL);
 +	if (!bits)
 +		return;
  
  	/*
  	 * Below calls try to access bit within allocated memory; however, the
* Unmerged path lib/test_kasan_module.c
* Unmerged path lib/test_kasan.c
* Unmerged path lib/test_kasan_module.c
