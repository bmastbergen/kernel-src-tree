powerpc/pseries/iommu: Fix window size for direct mapping with pmem

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Leonardo Bras <leobras.c@gmail.com>
commit a9d2f9bb225fd2a764aef57738ab6c7f38d782ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/a9d2f9bb.failed

As of today, if the DDW is big enough to fit (1 << MAX_PHYSMEM_BITS)
it's possible to use direct DMA mapping even with pmem region.

But, if that happens, the window size (len) is set to (MAX_PHYSMEM_BITS
- page_shift) instead of MAX_PHYSMEM_BITS, causing a pagesize times
smaller DDW to be created, being insufficient for correct usage.

Fix this so the correct window size is used in this case.

Fixes: bf6e2d562bbc4 ("powerpc/dma: Fallback to dma_ops when persistent memory present")
	Signed-off-by: Leonardo Bras <leobras.c@gmail.com>
	Reviewed-by: Alexey Kardashevskiy <aik@ozlabs.ru>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20210420045404.438735-1-leobras.c@gmail.com

(cherry picked from commit a9d2f9bb225fd2a764aef57738ab6c7f38d782ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/pseries/iommu.c
diff --cc arch/powerpc/platforms/pseries/iommu.c
index b10015a82ec4,5b3050ff0c55..000000000000
--- a/arch/powerpc/platforms/pseries/iommu.c
+++ b/arch/powerpc/platforms/pseries/iommu.c
@@@ -1228,14 -1242,29 +1228,38 @@@ static u64 enable_ddw(struct pci_dev *d
  	}
  	/* verify the window * number of ptes will map the partition */
  	/* check largest block * page size > max memory hotplug addr */
++<<<<<<< HEAD
 +	max_addr = ddw_memory_hotplug_max();
 +	if (query.largest_available_block < (max_addr >> page_shift)) {
 +		dev_dbg(&dev->dev, "can't map partition max 0x%llx with %llu "
 +			  "%llu-sized pages\n", max_addr,  query.largest_available_block,
 +			  1ULL << page_shift);
++=======
+ 	/*
+ 	 * The "ibm,pmemory" can appear anywhere in the address space.
+ 	 * Assuming it is still backed by page structs, try MAX_PHYSMEM_BITS
+ 	 * for the upper limit and fallback to max RAM otherwise but this
+ 	 * disables device::dma_ops_bypass.
+ 	 */
+ 	len = max_ram_len;
+ 	if (pmem_present) {
+ 		if (query.largest_available_block >=
+ 		    (1ULL << (MAX_PHYSMEM_BITS - page_shift)))
+ 			len = MAX_PHYSMEM_BITS;
+ 		else
+ 			dev_info(&dev->dev, "Skipping ibm,pmemory");
+ 	}
+ 
+ 	if (query.largest_available_block < (1ULL << (len - page_shift))) {
+ 		dev_dbg(&dev->dev,
+ 			"can't map partition max 0x%llx with %llu %llu-sized pages\n",
+ 			1ULL << len,
+ 			query.largest_available_block,
+ 			1ULL << page_shift);
++>>>>>>> a9d2f9bb225f (powerpc/pseries/iommu: Fix window size for direct mapping with pmem)
  		goto out_failed;
  	}
 +	len = order_base_2(max_addr);
  	win64 = kzalloc(sizeof(struct property), GFP_KERNEL);
  	if (!win64) {
  		dev_info(&dev->dev,
* Unmerged path arch/powerpc/platforms/pseries/iommu.c
