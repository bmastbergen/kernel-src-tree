xen/swiotlb: check if the swiotlb has already been initialized

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Stefano Stabellini <stefano.stabellini@xilinx.com>
commit 97729b653de52ba98e08732dd8855586e37a3a31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/97729b65.failed

xen_swiotlb_init calls swiotlb_late_init_with_tbl, which fails with
-ENOMEM if the swiotlb has already been initialized.

Add an explicit check io_tlb_default_mem != NULL at the beginning of
xen_swiotlb_init. If the swiotlb is already initialized print a warning
and return -EEXIST.

On x86, the error propagates.

On ARM, we don't actually need a special swiotlb buffer (yet), any
buffer would do. So ignore the error and continue.

CC: boris.ostrovsky@oracle.com
CC: jgross@suse.com
	Signed-off-by: Stefano Stabellini <stefano.stabellini@xilinx.com>
	Reviewed-by: Boris Ostrovsky <boris.ostrvsky@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
Link: https://lore.kernel.org/r/20210512201823.1963-3-sstabellini@kernel.org
	Signed-off-by: Juergen Gross <jgross@suse.com>
(cherry picked from commit 97729b653de52ba98e08732dd8855586e37a3a31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/xen/mm.c
#	drivers/xen/swiotlb-xen.c
diff --cc arch/arm/xen/mm.c
index cb44aa290e73,a7e54a087b80..000000000000
--- a/arch/arm/xen/mm.c
+++ b/arch/arm/xen/mm.c
@@@ -179,18 -134,19 +179,30 @@@ void xen_destroy_contiguous_region(phys
  {
  	return;
  }
 +EXPORT_SYMBOL_GPL(xen_destroy_contiguous_region);
 +
 +const struct dma_map_ops *xen_dma_ops;
 +EXPORT_SYMBOL(xen_dma_ops);
  
 -static int __init xen_mm_init(void)
 +int __init xen_mm_init(void)
  {
  	struct gnttab_cache_flush cflush;
++<<<<<<< HEAD
 +	if (!xen_initial_domain())
 +		return 0;
 +	xen_swiotlb_init(1, false);
 +	xen_dma_ops = &xen_swiotlb_dma_ops;
++=======
+ 	int rc;
+ 
+ 	if (!xen_swiotlb_detect())
+ 		return 0;
+ 
+ 	rc = xen_swiotlb_init();
+ 	/* we can work with the default swiotlb */
+ 	if (rc < 0 && rc != -EEXIST)
+ 		return rc;
++>>>>>>> 97729b653de5 (xen/swiotlb: check if the swiotlb has already been initialized)
  
  	cflush.op = 0;
  	cflush.a.dev_bus_addr = 0;
diff --cc drivers/xen/swiotlb-xen.c
index 8ccd85660984,24d11861ac7d..000000000000
--- a/drivers/xen/swiotlb-xen.c
+++ b/drivers/xen/swiotlb-xen.c
@@@ -165,20 -155,22 +165,28 @@@ static const char *xen_swiotlb_error(en
  
  #define DEFAULT_NSLABS		ALIGN(SZ_64M >> IO_TLB_SHIFT, IO_TLB_SEGSIZE)
  
 -int __ref xen_swiotlb_init(void)
 +int __ref xen_swiotlb_init(int verbose, bool early)
  {
 -	enum xen_swiotlb_err m_ret = XEN_SWIOTLB_UNKNOWN;
 -	unsigned long bytes = swiotlb_size_or_default();
 -	unsigned long nslabs = bytes >> IO_TLB_SHIFT;
 -	unsigned int order, repeat = 3;
 +	unsigned long bytes, order;
  	int rc = -ENOMEM;
 +	enum xen_swiotlb_err m_ret = XEN_SWIOTLB_UNKNOWN;
 +	unsigned int repeat = 3;
  	char *start;
 +	unsigned long nslabs;
  
++<<<<<<< HEAD
 +	nslabs = swiotlb_nr_tbl();
++=======
+ 	if (io_tlb_default_mem != NULL) {
+ 		pr_warn("swiotlb buffer already initialized\n");
+ 		return -EEXIST;
+ 	}
+ 
++>>>>>>> 97729b653de5 (xen/swiotlb: check if the swiotlb has already been initialized)
  retry:
 -	m_ret = XEN_SWIOTLB_ENOMEM;
 +	if (!nslabs)
 +		nslabs = DEFAULT_NSLABS;
 +	bytes = nslabs << IO_TLB_SHIFT;
  	order = get_order(bytes);
  
  	/*
* Unmerged path arch/arm/xen/mm.c
* Unmerged path drivers/xen/swiotlb-xen.c
