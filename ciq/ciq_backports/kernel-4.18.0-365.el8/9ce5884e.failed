drm/i915/display: Only keep PSR enabled if there is active planes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author José Roberto de Souza <jose.souza@intel.com>
commit 9ce5884e5139037445d0efcf37aeba21008011ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/9ce5884e.failed

PSR always had a requirement to only be enabled if there is active
planes but not following that never caused any issues.
But that changes in Alderlake-P, leaving PSR enabled without
active planes causes transcoder/port underruns.

Similar behavior was fixed during the pipe disable sequence by
commit 84030adb9e27 ("drm/i915/display: Disable audio, DRRS and PSR before planes").

intel_dp_compute_psr_vsc_sdp() had to move from
intel_psr_enable_locked() to intel_psr_compute_config() because we
need to be able to disable/enable PSR from atomic states without
connector and encoder state.

	Reviewed-by: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
	Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
	Cc: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
	Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210922215242.66683-3-jose.souza@intel.com
(cherry picked from commit 9ce5884e5139037445d0efcf37aeba21008011ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_display.c
#	drivers/gpu/drm/i915/display/intel_display_types.h
#	drivers/gpu/drm/i915/display/intel_dp.c
#	drivers/gpu/drm/i915/display/intel_psr.c
#	drivers/gpu/drm/i915/display/intel_psr.h
diff --cc drivers/gpu/drm/i915/display/intel_display.c
index be4f122dd751,f27c294beb92..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@@ -11301,6 -8097,13 +11301,16 @@@ intel_pipe_config_compare(const struct 
  		bp_gamma = intel_color_get_gamma_bit_precision(pipe_config);
  		if (bp_gamma)
  			PIPE_CONF_CHECK_COLOR_LUT(gamma_mode, hw.gamma_lut, bp_gamma);
++<<<<<<< HEAD
++=======
+ 
+ 		if (current_config->active_planes) {
+ 			PIPE_CONF_CHECK_BOOL(has_psr);
+ 			PIPE_CONF_CHECK_BOOL(has_psr2);
+ 			PIPE_CONF_CHECK_BOOL(enable_psr2_sel_fetch);
+ 			PIPE_CONF_CHECK_I(dc3co_exitline);
+ 		}
++>>>>>>> 9ce5884e5139 (drm/i915/display: Only keep PSR enabled if there is active planes)
  	}
  
  	PIPE_CONF_CHECK_BOOL(double_wide);
@@@ -11354,7 -8160,12 +11364,16 @@@
  		PIPE_CONF_CHECK_I(min_voltage_level);
  	}
  
++<<<<<<< HEAD
 +	PIPE_CONF_CHECK_X(infoframes.enable);
++=======
+ 	if (current_config->has_psr || pipe_config->has_psr)
+ 		PIPE_CONF_CHECK_X_WITH_MASK(infoframes.enable,
+ 					    ~intel_hdmi_infoframe_enable(DP_SDP_VSC));
+ 	else
+ 		PIPE_CONF_CHECK_X(infoframes.enable);
+ 
++>>>>>>> 9ce5884e5139 (drm/i915/display: Only keep PSR enabled if there is active planes)
  	PIPE_CONF_CHECK_X(infoframes.gcp);
  	PIPE_CONF_CHECK_INFOFRAME(avi);
  	PIPE_CONF_CHECK_INFOFRAME(spd);
diff --cc drivers/gpu/drm/i915/display/intel_display_types.h
index 421b07aecc99,9413ebae15f5..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@@ -1005,7 -1058,10 +1006,12 @@@ struct intel_crtc_state 
  	bool has_psr;
  	bool has_psr2;
  	bool enable_psr2_sel_fetch;
 -	bool req_psr2_sdp_prior_scanline;
  	u32 dc3co_exitline;
++<<<<<<< HEAD
++=======
+ 	u16 su_y_granularity;
+ 	struct drm_dp_vsc_sdp psr_vsc;
++>>>>>>> 9ce5884e5139 (drm/i915/display: Only keep PSR enabled if there is active planes)
  
  	/*
  	 * Frequence the dpll for the port should run at. Differs from the
@@@ -1424,6 -1487,46 +1430,49 @@@ struct intel_pps 
  	struct edp_power_seq pps_delays;
  };
  
++<<<<<<< HEAD
++=======
+ struct intel_psr {
+ 	/* Mutex for PSR state of the transcoder */
+ 	struct mutex lock;
+ 
+ #define I915_PSR_DEBUG_MODE_MASK	0x0f
+ #define I915_PSR_DEBUG_DEFAULT		0x00
+ #define I915_PSR_DEBUG_DISABLE		0x01
+ #define I915_PSR_DEBUG_ENABLE		0x02
+ #define I915_PSR_DEBUG_FORCE_PSR1	0x03
+ #define I915_PSR_DEBUG_ENABLE_SEL_FETCH	0x4
+ #define I915_PSR_DEBUG_IRQ		0x10
+ 
+ 	u32 debug;
+ 	bool sink_support;
+ 	bool source_support;
+ 	bool enabled;
+ 	bool paused;
+ 	enum pipe pipe;
+ 	enum transcoder transcoder;
+ 	bool active;
+ 	struct work_struct work;
+ 	unsigned int busy_frontbuffer_bits;
+ 	bool sink_psr2_support;
+ 	bool link_standby;
+ 	bool colorimetry_support;
+ 	bool psr2_enabled;
+ 	bool psr2_sel_fetch_enabled;
+ 	bool req_psr2_sdp_prior_scanline;
+ 	u8 sink_sync_latency;
+ 	ktime_t last_entry_attempt;
+ 	ktime_t last_exit;
+ 	bool sink_not_reliable;
+ 	bool irq_aux_error;
+ 	u16 su_w_granularity;
+ 	u16 su_y_granularity;
+ 	u32 dc3co_exitline;
+ 	u32 dc3co_exit_delay;
+ 	struct delayed_work dc3co_work;
+ };
+ 
++>>>>>>> 9ce5884e5139 (drm/i915/display: Only keep PSR enabled if there is active planes)
  struct intel_dp {
  	i915_reg_t output_reg;
  	u32 DP;
diff --cc drivers/gpu/drm/i915/display/intel_dp.c
index aefe3cd87e91,378008873e03..000000000000
--- a/drivers/gpu/drm/i915/display/intel_dp.c
+++ b/drivers/gpu/drm/i915/display/intel_dp.c
@@@ -1629,12 -1672,10 +1629,17 @@@ void intel_dp_compute_psr_vsc_sdp(struc
  				  const struct drm_connector_state *conn_state,
  				  struct drm_dp_vsc_sdp *vsc)
  {
 +	struct drm_i915_private *dev_priv = dp_to_i915(intel_dp);
 +
  	vsc->sdp_type = DP_SDP_VSC;
  
++<<<<<<< HEAD
 +	if (dev_priv->psr.psr2_enabled) {
 +		if (dev_priv->psr.colorimetry_support &&
++=======
+ 	if (crtc_state->has_psr2) {
+ 		if (intel_dp->psr.colorimetry_support &&
++>>>>>>> 9ce5884e5139 (drm/i915/display: Only keep PSR enabled if there is active planes)
  		    intel_dp_needs_vsc_sdp(crtc_state, conn_state)) {
  			/* [PSR2, +Colorimetry] */
  			intel_dp_compute_vsc_colorimetry(crtc_state, conn_state,
@@@ -1793,13 -1820,17 +1798,19 @@@ intel_dp_compute_config(struct intel_en
  			       &pipe_config->dp_m_n,
  			       constant_n, pipe_config->fec_enable);
  
 -	/* FIXME: abstract this better */
 -	if (pipe_config->splitter.enable)
 -		pipe_config->dp_m_n.gmch_m *= pipe_config->splitter.link_count;
 -
  	if (!HAS_DDI(dev_priv))
 -		g4x_dp_set_clock(encoder, pipe_config);
 +		intel_dp_set_clock(encoder, pipe_config);
  
  	intel_vrr_compute_config(pipe_config, conn_state);
++<<<<<<< HEAD
 +	intel_psr_compute_config(intel_dp, pipe_config);
 +	intel_dp_drrs_compute_config(intel_dp, pipe_config, output_bpp,
 +				     constant_n);
++=======
+ 	intel_psr_compute_config(intel_dp, pipe_config, conn_state);
+ 	intel_drrs_compute_config(intel_dp, pipe_config, output_bpp,
+ 				  constant_n);
++>>>>>>> 9ce5884e5139 (drm/i915/display: Only keep PSR enabled if there is active planes)
  	intel_dp_compute_vsc_sdp(intel_dp, pipe_config, conn_state);
  	intel_dp_compute_hdr_metadata_infoframe_sdp(intel_dp, pipe_config, conn_state);
  
diff --cc drivers/gpu/drm/i915/display/intel_psr.c
index 2c6c4a4f9477,19a96d3c4acf..000000000000
--- a/drivers/gpu/drm/i915/display/intel_psr.c
+++ b/drivers/gpu/drm/i915/display/intel_psr.c
@@@ -817,9 -950,9 +817,10 @@@ static bool intel_psr2_config_valid(str
  }
  
  void intel_psr_compute_config(struct intel_dp *intel_dp,
- 			      struct intel_crtc_state *crtc_state)
+ 			      struct intel_crtc_state *crtc_state,
+ 			      struct drm_connector_state *conn_state)
  {
 +	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
  	struct drm_i915_private *dev_priv = dp_to_i915(intel_dp);
  	const struct drm_display_mode *adjusted_mode =
  		&crtc_state->hw.adjusted_mode;
@@@ -885,9 -1003,57 +886,12 @@@
  
  	crtc_state->has_psr = true;
  	crtc_state->has_psr2 = intel_psr2_config_valid(intel_dp, crtc_state);
+ 
  	crtc_state->infoframes.enable |= intel_hdmi_infoframe_enable(DP_SDP_VSC);
+ 	intel_dp_compute_psr_vsc_sdp(intel_dp, crtc_state, conn_state,
+ 				     &crtc_state->psr_vsc);
  }
  
 -void intel_psr_get_config(struct intel_encoder *encoder,
 -			  struct intel_crtc_state *pipe_config)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 -	struct intel_digital_port *dig_port = enc_to_dig_port(encoder);
 -	struct intel_dp *intel_dp;
 -	u32 val;
 -
 -	if (!dig_port)
 -		return;
 -
 -	intel_dp = &dig_port->dp;
 -	if (!CAN_PSR(intel_dp))
 -		return;
 -
 -	mutex_lock(&intel_dp->psr.lock);
 -	if (!intel_dp->psr.enabled)
 -		goto unlock;
 -
 -	/*
 -	 * Not possible to read EDP_PSR/PSR2_CTL registers as it is
 -	 * enabled/disabled because of frontbuffer tracking and others.
 -	 */
 -	pipe_config->has_psr = true;
 -	pipe_config->has_psr2 = intel_dp->psr.psr2_enabled;
 -	pipe_config->infoframes.enable |= intel_hdmi_infoframe_enable(DP_SDP_VSC);
 -
 -	if (!intel_dp->psr.psr2_enabled)
 -		goto unlock;
 -
 -	if (HAS_PSR2_SEL_FETCH(dev_priv)) {
 -		val = intel_de_read(dev_priv, PSR2_MAN_TRK_CTL(intel_dp->psr.transcoder));
 -		if (val & PSR2_MAN_TRK_CTL_ENABLE)
 -			pipe_config->enable_psr2_sel_fetch = true;
 -	}
 -
 -	if (DISPLAY_VER(dev_priv) >= 12) {
 -		val = intel_de_read(dev_priv, EXITLINE(intel_dp->psr.transcoder));
 -		val &= EXITLINE_MASK;
 -		pipe_config->dc3co_exitline = val;
 -	}
 -unlock:
 -	mutex_unlock(&intel_dp->psr.lock);
 -}
 -
  static void intel_psr_activate(struct intel_dp *intel_dp)
  {
  	struct drm_i915_private *dev_priv = dp_to_i915(intel_dp);
@@@ -1015,62 -1173,65 +1019,102 @@@ static void intel_psr_enable_locked(str
  		val &= EDP_PSR_ERROR(0);
  	} else {
  		val = intel_de_read(dev_priv, EDP_PSR_IIR);
 -		val &= EDP_PSR_ERROR(intel_dp->psr.transcoder);
 +		val &= EDP_PSR_ERROR(dev_priv->psr.transcoder);
  	}
  	if (val) {
 -		intel_dp->psr.sink_not_reliable = true;
 +		dev_priv->psr.sink_not_reliable = true;
  		drm_dbg_kms(&dev_priv->drm,
  			    "PSR interruption error set, not enabling PSR\n");
 -		return false;
 +		return;
  	}
  
++<<<<<<< HEAD
 +	drm_dbg_kms(&dev_priv->drm, "Enabling PSR%s\n",
 +		    dev_priv->psr.psr2_enabled ? "2" : "1");
 +	intel_dp_compute_psr_vsc_sdp(intel_dp, crtc_state, conn_state,
 +				     &dev_priv->psr.vsc);
 +	intel_write_dp_vsc_sdp(encoder, crtc_state, &dev_priv->psr.vsc);
++=======
+ 	return true;
+ }
+ 
+ static void intel_psr_enable_locked(struct intel_dp *intel_dp,
+ 				    const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
+ 	struct drm_i915_private *dev_priv = dp_to_i915(intel_dp);
+ 	enum phy phy = intel_port_to_phy(dev_priv, dig_port->base.port);
+ 	struct intel_encoder *encoder = &dig_port->base;
+ 	u32 val;
+ 
+ 	drm_WARN_ON(&dev_priv->drm, intel_dp->psr.enabled);
+ 
+ 	intel_dp->psr.psr2_enabled = crtc_state->has_psr2;
+ 	intel_dp->psr.busy_frontbuffer_bits = 0;
+ 	intel_dp->psr.pipe = to_intel_crtc(crtc_state->uapi.crtc)->pipe;
+ 	intel_dp->psr.transcoder = crtc_state->cpu_transcoder;
+ 	/* DC5/DC6 requires at least 6 idle frames */
+ 	val = usecs_to_jiffies(intel_get_frame_time_us(crtc_state) * 6);
+ 	intel_dp->psr.dc3co_exit_delay = val;
+ 	intel_dp->psr.dc3co_exitline = crtc_state->dc3co_exitline;
+ 	intel_dp->psr.psr2_sel_fetch_enabled = crtc_state->enable_psr2_sel_fetch;
+ 	intel_dp->psr.req_psr2_sdp_prior_scanline =
+ 		crtc_state->req_psr2_sdp_prior_scanline;
+ 
+ 	if (!psr_interrupt_error_check(intel_dp))
+ 		return;
+ 
+ 	drm_dbg_kms(&dev_priv->drm, "Enabling PSR%s\n",
+ 		    intel_dp->psr.psr2_enabled ? "2" : "1");
+ 	intel_write_dp_vsc_sdp(encoder, crtc_state, &crtc_state->psr_vsc);
+ 	intel_snps_phy_update_psr_power_state(dev_priv, phy, true);
++>>>>>>> 9ce5884e5139 (drm/i915/display: Only keep PSR enabled if there is active planes)
  	intel_psr_enable_sink(intel_dp);
 -	intel_psr_enable_source(intel_dp);
 -	intel_dp->psr.enabled = true;
 -	intel_dp->psr.paused = false;
 +	intel_psr_enable_source(intel_dp, crtc_state);
 +	dev_priv->psr.enabled = true;
  
  	intel_psr_activate(intel_dp);
  }
  
 -static void intel_psr_exit(struct intel_dp *intel_dp)
++<<<<<<< HEAD
 +/**
 + * intel_psr_enable - Enable PSR
 + * @intel_dp: Intel DP
 + * @crtc_state: new CRTC state
 + * @conn_state: new CONNECTOR state
 + *
 + * This function can only be called after the pipe is fully trained and enabled.
 + */
 +void intel_psr_enable(struct intel_dp *intel_dp,
 +		      const struct intel_crtc_state *crtc_state,
 +		      const struct drm_connector_state *conn_state)
  {
  	struct drm_i915_private *dev_priv = dp_to_i915(intel_dp);
 +
 +	if (!CAN_PSR(dev_priv) || dev_priv->psr.dp != intel_dp)
 +		return;
 +
 +	if (!crtc_state->has_psr)
 +		return;
 +
 +	drm_WARN_ON(&dev_priv->drm, dev_priv->drrs.dp);
 +
 +	mutex_lock(&dev_priv->psr.lock);
 +	intel_psr_enable_locked(dev_priv, crtc_state, conn_state);
 +	mutex_unlock(&dev_priv->psr.lock);
 +}
 +
 +static void intel_psr_exit(struct drm_i915_private *dev_priv)
++=======
++static void intel_psr_exit(struct intel_dp *intel_dp)
++>>>>>>> 9ce5884e5139 (drm/i915/display: Only keep PSR enabled if there is active planes)
 +{
  	u32 val;
  
 -	if (!intel_dp->psr.active) {
 -		if (transcoder_has_psr2(dev_priv, intel_dp->psr.transcoder)) {
 +	if (!dev_priv->psr.active) {
 +		if (transcoder_has_psr2(dev_priv, dev_priv->psr.transcoder)) {
  			val = intel_de_read(dev_priv,
 -					    EDP_PSR2_CTL(intel_dp->psr.transcoder));
 +					    EDP_PSR2_CTL(dev_priv->psr.transcoder));
  			drm_WARN_ON(&dev_priv->drm, val & EDP_PSR2_ENABLE);
  		}
  
@@@ -1448,57 -1708,92 +1492,124 @@@ skip_sel_fetch_set_loop
  	return 0;
  }
  
- /**
-  * intel_psr_update - Update PSR state
-  * @intel_dp: Intel DP
-  * @crtc_state: new CRTC state
-  * @conn_state: new CONNECTOR state
-  *
-  * This functions will update PSR states, disabling, enabling or switching PSR
-  * version when executing fastsets. For full modeset, intel_psr_disable() and
-  * intel_psr_enable() should be called instead.
-  */
- void intel_psr_update(struct intel_dp *intel_dp,
- 		      const struct intel_crtc_state *crtc_state,
- 		      const struct drm_connector_state *conn_state)
+ static void _intel_psr_pre_plane_update(const struct intel_atomic_state *state,
+ 					const struct intel_crtc_state *crtc_state)
  {
++<<<<<<< HEAD
 +	struct drm_i915_private *dev_priv = dp_to_i915(intel_dp);
 +	struct i915_psr *psr = &dev_priv->psr;
 +	bool enable, psr2_enable;
 +
 +	if (!CAN_PSR(dev_priv) || READ_ONCE(psr->dp) != intel_dp)
 +		return;
 +
 +	mutex_lock(&dev_priv->psr.lock);
++=======
+ 	struct intel_encoder *encoder;
+ 
+ 	for_each_intel_encoder_mask_with_psr(state->base.dev, encoder,
+ 					     crtc_state->uapi.encoder_mask) {
+ 		struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
+ 		struct intel_psr *psr = &intel_dp->psr;
+ 		bool needs_to_disable = false;
  
- 	enable = crtc_state->has_psr;
- 	psr2_enable = crtc_state->has_psr2;
+ 		mutex_lock(&psr->lock);
  
+ 		/*
+ 		 * Reasons to disable:
+ 		 * - PSR disabled in new state
+ 		 * - All planes will go inactive
+ 		 * - Changing between PSR versions
+ 		 */
+ 		needs_to_disable |= !crtc_state->has_psr;
+ 		needs_to_disable |= !crtc_state->active_planes;
+ 		needs_to_disable |= crtc_state->has_psr2 != psr->psr2_enabled;
+ 
+ 		if (psr->enabled && needs_to_disable)
+ 			intel_psr_disable_locked(intel_dp);
+ 
+ 		mutex_unlock(&psr->lock);
+ 	}
+ }
+ 
+ void intel_psr_pre_plane_update(const struct intel_atomic_state *state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+ 	struct intel_crtc_state *crtc_state;
+ 	struct intel_crtc *crtc;
+ 	int i;
+ 
+ 	if (!HAS_PSR(dev_priv))
+ 		return;
+ 
+ 	for_each_new_intel_crtc_in_state(state, crtc, crtc_state, i)
+ 		_intel_psr_pre_plane_update(state, crtc_state);
+ }
++>>>>>>> 9ce5884e5139 (drm/i915/display: Only keep PSR enabled if there is active planes)
+ 
+ static void _intel_psr_post_plane_update(const struct intel_atomic_state *state,
+ 					 const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+ 	struct intel_encoder *encoder;
+ 
+ 	if (!crtc_state->has_psr)
+ 		return;
+ 
+ 	for_each_intel_encoder_mask_with_psr(state->base.dev, encoder,
+ 					     crtc_state->uapi.encoder_mask) {
+ 		struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
+ 		struct intel_psr *psr = &intel_dp->psr;
+ 
+ 		mutex_lock(&psr->lock);
+ 
+ 		drm_WARN_ON(&dev_priv->drm, psr->enabled && !crtc_state->active_planes);
+ 
+ 		/* Only enable if there is active planes */
+ 		if (!psr->enabled && crtc_state->active_planes)
+ 			intel_psr_enable_locked(intel_dp, crtc_state);
+ 
++<<<<<<< HEAD
 +	if (enable == psr->enabled && psr2_enable == psr->psr2_enabled) {
++=======
++>>>>>>> 9ce5884e5139 (drm/i915/display: Only keep PSR enabled if there is active planes)
  		/* Force a PSR exit when enabling CRC to avoid CRC timeouts */
  		if (crtc_state->crc_enabled && psr->enabled)
 -			psr_force_hw_tracking_exit(intel_dp);
 +			psr_force_hw_tracking_exit(dev_priv);
 +		else if (INTEL_GEN(dev_priv) < 9 && psr->enabled) {
 +			/*
 +			 * Activate PSR again after a force exit when enabling
 +			 * CRC in older gens
 +			 */
 +			if (!dev_priv->psr.active &&
 +			    !dev_priv->psr.busy_frontbuffer_bits)
 +				schedule_work(&dev_priv->psr.work);
 +		}
  
- 		goto unlock;
+ 		mutex_unlock(&psr->lock);
  	}
+ }
  
- 	if (psr->enabled)
- 		intel_psr_disable_locked(intel_dp);
+ void intel_psr_post_plane_update(const struct intel_atomic_state *state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+ 	struct intel_crtc_state *crtc_state;
+ 	struct intel_crtc *crtc;
+ 	int i;
  
++<<<<<<< HEAD
 +	if (enable)
 +		intel_psr_enable_locked(dev_priv, crtc_state, conn_state);
 +
 +unlock:
 +	mutex_unlock(&dev_priv->psr.lock);
++=======
+ 	if (!HAS_PSR(dev_priv))
+ 		return;
+ 
+ 	for_each_new_intel_crtc_in_state(state, crtc, crtc_state, i)
+ 		_intel_psr_post_plane_update(state, crtc_state);
++>>>>>>> 9ce5884e5139 (drm/i915/display: Only keep PSR enabled if there is active planes)
  }
  
  /**
diff --cc drivers/gpu/drm/i915/display/intel_psr.h
index 0a517978e8af,facffbacd357..000000000000
--- a/drivers/gpu/drm/i915/display/intel_psr.h
+++ b/drivers/gpu/drm/i915/display/intel_psr.h
@@@ -17,31 -17,29 +17,42 @@@ struct intel_crtc
  struct intel_atomic_state;
  struct intel_plane_state;
  struct intel_plane;
 -struct intel_encoder;
  
 +#define CAN_PSR(dev_priv) (HAS_PSR(dev_priv) && dev_priv->psr.sink_support)
  void intel_psr_init_dpcd(struct intel_dp *intel_dp);
- void intel_psr_enable(struct intel_dp *intel_dp,
- 		      const struct intel_crtc_state *crtc_state,
- 		      const struct drm_connector_state *conn_state);
+ void intel_psr_pre_plane_update(const struct intel_atomic_state *state);
+ void intel_psr_post_plane_update(const struct intel_atomic_state *state);
  void intel_psr_disable(struct intel_dp *intel_dp,
  		       const struct intel_crtc_state *old_crtc_state);
++<<<<<<< HEAD
 +void intel_psr_update(struct intel_dp *intel_dp,
 +		      const struct intel_crtc_state *crtc_state,
 +		      const struct drm_connector_state *conn_state);
 +int intel_psr_debug_set(struct drm_i915_private *dev_priv, u64 value);
++=======
+ int intel_psr_debug_set(struct intel_dp *intel_dp, u64 value);
++>>>>>>> 9ce5884e5139 (drm/i915/display: Only keep PSR enabled if there is active planes)
  void intel_psr_invalidate(struct drm_i915_private *dev_priv,
  			  unsigned frontbuffer_bits,
  			  enum fb_op_origin origin);
  void intel_psr_flush(struct drm_i915_private *dev_priv,
  		     unsigned frontbuffer_bits,
  		     enum fb_op_origin origin);
 -void intel_psr_init(struct intel_dp *intel_dp);
 +void intel_psr_init(struct drm_i915_private *dev_priv);
  void intel_psr_compute_config(struct intel_dp *intel_dp,
++<<<<<<< HEAD
 +			      struct intel_crtc_state *crtc_state);
 +void intel_psr_irq_handler(struct drm_i915_private *dev_priv, u32 psr_iir);
++=======
+ 			      struct intel_crtc_state *crtc_state,
+ 			      struct drm_connector_state *conn_state);
+ void intel_psr_get_config(struct intel_encoder *encoder,
+ 			  struct intel_crtc_state *pipe_config);
+ void intel_psr_irq_handler(struct intel_dp *intel_dp, u32 psr_iir);
++>>>>>>> 9ce5884e5139 (drm/i915/display: Only keep PSR enabled if there is active planes)
  void intel_psr_short_pulse(struct intel_dp *intel_dp);
 -void intel_psr_wait_for_idle(const struct intel_crtc_state *new_crtc_state);
 +int intel_psr_wait_for_idle(const struct intel_crtc_state *new_crtc_state,
 +			    u32 *out_value);
  bool intel_psr_enabled(struct intel_dp *intel_dp);
  int intel_psr2_sel_fetch_update(struct intel_atomic_state *state,
  				struct intel_crtc *crtc);
diff --git a/drivers/gpu/drm/i915/display/intel_ddi.c b/drivers/gpu/drm/i915/display/intel_ddi.c
index 017f4ea5d46f..114eed8a76e9 100644
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@ -4343,7 +4343,6 @@ static void intel_enable_ddi_dp(struct intel_atomic_state *state,
 		intel_dp_stop_link_train(intel_dp, crtc_state);
 
 	intel_edp_backlight_on(crtc_state, conn_state);
-	intel_psr_enable(intel_dp, crtc_state, conn_state);
 
 	if (!dig_port->lspcon.active || dig_port->dp.has_hdmi_sink)
 		intel_dp_set_infoframes(encoder, true, crtc_state, conn_state);
@@ -4546,7 +4545,6 @@ static void intel_ddi_update_pipe_dp(struct intel_atomic_state *state,
 
 	intel_ddi_set_dp_msa(crtc_state, conn_state);
 
-	intel_psr_update(intel_dp, crtc_state, conn_state);
 	intel_dp_set_infoframes(encoder, true, crtc_state, conn_state);
 	intel_edp_drrs_update(intel_dp, crtc_state);
 
* Unmerged path drivers/gpu/drm/i915/display/intel_display.c
* Unmerged path drivers/gpu/drm/i915/display/intel_display_types.h
* Unmerged path drivers/gpu/drm/i915/display/intel_dp.c
diff --git a/drivers/gpu/drm/i915/display/intel_dp.h b/drivers/gpu/drm/i915/display/intel_dp.h
index d80839139bfb..601c5c269327 100644
--- a/drivers/gpu/drm/i915/display/intel_dp.h
+++ b/drivers/gpu/drm/i915/display/intel_dp.h
@@ -108,7 +108,7 @@ void intel_dp_compute_psr_vsc_sdp(struct intel_dp *intel_dp,
 				  struct drm_dp_vsc_sdp *vsc);
 void intel_write_dp_vsc_sdp(struct intel_encoder *encoder,
 			    const struct intel_crtc_state *crtc_state,
-			    struct drm_dp_vsc_sdp *vsc);
+			    const struct drm_dp_vsc_sdp *vsc);
 void intel_dp_set_infoframes(struct intel_encoder *encoder, bool enable,
 			     const struct intel_crtc_state *crtc_state,
 			     const struct drm_connector_state *conn_state);
* Unmerged path drivers/gpu/drm/i915/display/intel_psr.c
* Unmerged path drivers/gpu/drm/i915/display/intel_psr.h
