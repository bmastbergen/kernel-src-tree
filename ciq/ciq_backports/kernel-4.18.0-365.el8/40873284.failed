fanotify: Track permission event state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Jan Kara <jack@suse.cz>
commit 40873284d7106fc0f0f4d2deae74b38fb18342cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/40873284.failed

Track whether permission event got already reported to userspace and
whether userspace already answered to the permission event. Protect
stores to this field together with updates to ->response field by
group->notification_lock. This will allow aborting wait for reply to
permission event from userspace.

	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 40873284d7106fc0f0f4d2deae74b38fb18342cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/fanotify/fanotify.h
#	fs/notify/fanotify/fanotify_user.c
diff --cc fs/notify/fanotify/fanotify.h
index ea05b8a401e7,480f281996d4..000000000000
--- a/fs/notify/fanotify/fanotify.h
+++ b/fs/notify/fanotify/fanotify.h
@@@ -7,6 -8,50 +7,13 @@@ extern struct kmem_cache *fanotify_mark
  extern struct kmem_cache *fanotify_event_cachep;
  extern struct kmem_cache *fanotify_perm_event_cachep;
  
+ /* Possible states of the permission event */
+ enum {
+ 	FAN_EVENT_INIT,
+ 	FAN_EVENT_REPORTED,
+ 	FAN_EVENT_ANSWERED
+ };
+ 
 -/*
 - * 3 dwords are sufficient for most local fs (64bit ino, 32bit generation).
 - * For 32bit arch, fid increases the size of fanotify_event by 12 bytes and
 - * fh_* fields increase the size of fanotify_event by another 4 bytes.
 - * For 64bit arch, fid increases the size of fanotify_fid by 8 bytes and
 - * fh_* fields are packed in a hole after mask.
 - */
 -#if BITS_PER_LONG == 32
 -#define FANOTIFY_INLINE_FH_LEN	(3 << 2)
 -#else
 -#define FANOTIFY_INLINE_FH_LEN	(4 << 2)
 -#endif
 -
 -struct fanotify_fid {
 -	__kernel_fsid_t fsid;
 -	union {
 -		unsigned char fh[FANOTIFY_INLINE_FH_LEN];
 -		unsigned char *ext_fh;
 -	};
 -};
 -
 -static inline void *fanotify_fid_fh(struct fanotify_fid *fid,
 -				    unsigned int fh_len)
 -{
 -	return fh_len <= FANOTIFY_INLINE_FH_LEN ? fid->fh : fid->ext_fh;
 -}
 -
 -static inline bool fanotify_fid_equal(struct fanotify_fid *fid1,
 -				      struct fanotify_fid *fid2,
 -				      unsigned int fh_len)
 -{
 -	return fid1->fsid.val[0] == fid2->fsid.val[0] &&
 -		fid1->fsid.val[1] == fid2->fsid.val[1] &&
 -		!memcmp(fanotify_fid_fh(fid1, fh_len),
 -			fanotify_fid_fh(fid2, fh_len), fh_len);
 -}
 -
  /*
   * Structure for normal fanotify events. It gets allocated in
   * fanotify_handle_event() and freed when the information is retrieved by
@@@ -29,9 -114,10 +36,16 @@@ struct fanotify_event_info 
   * group->notification_list to group->fanotify_data.access_list to wait for
   * user response.
   */
++<<<<<<< HEAD
 +struct fanotify_perm_event_info {
 +	struct fanotify_event_info fae;
 +	int response;	/* userspace answer to question */
++=======
+ struct fanotify_perm_event {
+ 	struct fanotify_event fae;
+ 	unsigned short response;	/* userspace answer to the event */
+ 	unsigned short state;		/* state of the event */
++>>>>>>> 40873284d710 (fanotify: Track permission event state)
  	int fd;		/* fd we passed to userspace for this event */
  };
  
diff --cc fs/notify/fanotify/fanotify_user.c
index 48689619c0fd,3c272f61d341..000000000000
--- a/fs/notify/fanotify/fanotify_user.c
+++ b/fs/notify/fanotify/fanotify_user.c
@@@ -50,9 -52,20 +50,14 @@@ struct kmem_cache *fanotify_perm_event_
  /*
   * Get an fsnotify notification event if one exists and is small
   * enough to fit in "count". Return an error pointer if the count
++<<<<<<< HEAD
 + * is not large enough.
 + *
 + * Called with the group->notification_lock held.
++=======
+  * is not large enough. When permission event is dequeued, its state is
+  * updated accordingly.
++>>>>>>> 40873284d710 (fanotify: Track permission event state)
   */
  static struct fsnotify_event *get_one_event(struct fsnotify_group *group,
  					    size_t count)
@@@ -61,15 -75,25 +66,28 @@@
  
  	pr_debug("%s: group=%p count=%zd\n", __func__, group, count);
  
 -	spin_lock(&group->notification_lock);
  	if (fsnotify_notify_queue_is_empty(group))
 -		goto out;
 +		return NULL;
  
 -	if (FAN_GROUP_FLAG(group, FAN_REPORT_FID)) {
 -		event_size += fanotify_event_info_len(
 -			FANOTIFY_E(fsnotify_peek_first_event(group)));
 -	}
 +	if (FAN_EVENT_METADATA_LEN > count)
 +		return ERR_PTR(-EINVAL);
  
++<<<<<<< HEAD
 +	/* held the notification_lock the whole time, so this is the
 +	 * same event we peeked above */
 +	return fsnotify_remove_first_event(group);
++=======
+ 	if (event_size > count) {
+ 		fsn_event = ERR_PTR(-EINVAL);
+ 		goto out;
+ 	}
+ 	fsn_event = fsnotify_remove_first_event(group);
+ 	if (fanotify_is_perm_event(FANOTIFY_E(fsn_event)->mask))
+ 		FANOTIFY_PE(fsn_event)->state = FAN_EVENT_REPORTED;
+ out:
+ 	spin_unlock(&group->notification_lock);
+ 	return fsn_event;
++>>>>>>> 40873284d710 (fanotify: Track permission event state)
  }
  
  static int create_fd(struct fsnotify_group *group,
@@@ -114,56 -138,19 +132,72 @@@
  	return client_fd;
  }
  
++<<<<<<< HEAD
 +static int fill_event_metadata(struct fsnotify_group *group,
 +			       struct fanotify_event_metadata *metadata,
 +			       struct fsnotify_event *fsn_event,
 +			       struct file **file)
 +{
 +	int ret = 0;
 +	struct fanotify_event_info *event;
 +
 +	pr_debug("%s: group=%p metadata=%p event=%p\n", __func__,
 +		 group, metadata, fsn_event);
 +
 +	*file = NULL;
 +	event = container_of(fsn_event, struct fanotify_event_info, fse);
 +	metadata->event_len = FAN_EVENT_METADATA_LEN;
 +	metadata->metadata_len = FAN_EVENT_METADATA_LEN;
 +	metadata->vers = FANOTIFY_METADATA_VERSION;
 +	metadata->reserved = 0;
 +	metadata->mask = fsn_event->mask & FANOTIFY_OUTGOING_EVENTS;
 +	metadata->pid = pid_vnr(event->pid);
 +	if (unlikely(fsn_event->mask & FAN_Q_OVERFLOW))
 +		metadata->fd = FAN_NOFD;
 +	else {
 +		metadata->fd = create_fd(group, event, file);
 +		if (metadata->fd < 0)
 +			ret = metadata->fd;
 +	}
 +
 +	return ret;
 +}
 +
 +static struct fanotify_perm_event_info *dequeue_event(
 +				struct fsnotify_group *group, int fd)
 +{
 +	struct fanotify_perm_event_info *event, *return_e = NULL;
 +
 +	spin_lock(&group->notification_lock);
 +	list_for_each_entry(event, &group->fanotify_data.access_list,
 +			    fae.fse.list) {
 +		if (event->fd != fd)
 +			continue;
 +
 +		list_del_init(&event->fae.fse.list);
 +		return_e = event;
 +		break;
 +	}
 +	spin_unlock(&group->notification_lock);
 +
 +	pr_debug("%s: found return_re=%p\n", __func__, return_e);
 +
 +	return return_e;
++=======
+ /*
+  * Finish processing of permission event by setting it to ANSWERED state and
+  * drop group->notification_lock.
+  */
+ static void finish_permission_event(struct fsnotify_group *group,
+ 				    struct fanotify_perm_event *event,
+ 				    unsigned int response)
+ 				    __releases(&group->notification_lock)
+ {
+ 	assert_spin_locked(&group->notification_lock);
+ 	event->response = response;
+ 	event->state = FAN_EVENT_ANSWERED;
+ 	spin_unlock(&group->notification_lock);
++>>>>>>> 40873284d710 (fanotify: Track permission event state)
  }
  
  static int process_access_response(struct fsnotify_group *group,
@@@ -194,12 -181,60 +228,63 @@@
  	if ((response & FAN_AUDIT) && !FAN_GROUP_FLAG(group, FAN_ENABLE_AUDIT))
  		return -EINVAL;
  
 -	spin_lock(&group->notification_lock);
 -	list_for_each_entry(event, &group->fanotify_data.access_list,
 -			    fae.fse.list) {
 -		if (event->fd != fd)
 -			continue;
 +	event = dequeue_event(group, fd);
 +	if (!event)
 +		return -ENOENT;
  
++<<<<<<< HEAD
 +	event->response = response;
 +	wake_up(&group->fanotify_data.access_waitq);
++=======
+ 		list_del_init(&event->fae.fse.list);
+ 		finish_permission_event(group, event, response);
+ 		wake_up(&group->fanotify_data.access_waitq);
+ 		return 0;
+ 	}
+ 	spin_unlock(&group->notification_lock);
+ 
+ 	return -ENOENT;
+ }
+ 
+ static int copy_fid_to_user(struct fanotify_event *event, char __user *buf)
+ {
+ 	struct fanotify_event_info_fid info = { };
+ 	struct file_handle handle = { };
+ 	size_t fh_len = event->fh_len;
+ 	size_t len = fanotify_event_info_len(event);
+ 
+ 	if (!len)
+ 		return 0;
+ 
+ 	if (WARN_ON_ONCE(len < sizeof(info) + sizeof(handle) + fh_len))
+ 		return -EFAULT;
+ 
+ 	/* Copy event info fid header followed by vaiable sized file handle */
+ 	info.hdr.info_type = FAN_EVENT_INFO_TYPE_FID;
+ 	info.hdr.len = len;
+ 	info.fsid = event->fid.fsid;
+ 	if (copy_to_user(buf, &info, sizeof(info)))
+ 		return -EFAULT;
+ 
+ 	buf += sizeof(info);
+ 	len -= sizeof(info);
+ 	handle.handle_type = event->fh_type;
+ 	handle.handle_bytes = fh_len;
+ 	if (copy_to_user(buf, &handle, sizeof(handle)))
+ 		return -EFAULT;
+ 
+ 	buf += sizeof(handle);
+ 	len -= sizeof(handle);
+ 	if (copy_to_user(buf, fanotify_event_fh(event), fh_len))
+ 		return -EFAULT;
+ 
+ 	/* Pad with 0's */
+ 	buf += fh_len;
+ 	len -= fh_len;
+ 	WARN_ON_ONCE(len < 0 || len >= FANOTIFY_EVENT_ALIGN);
+ 	if (len > 0 && clear_user(buf, len))
+ 		return -EFAULT;
++>>>>>>> 40873284d710 (fanotify: Track permission event state)
  
  	return 0;
  }
@@@ -385,13 -438,12 +472,14 @@@ static int fanotify_release(struct inod
  	 * and simulate reply from userspace.
  	 */
  	spin_lock(&group->notification_lock);
 -	while (!list_empty(&group->fanotify_data.access_list)) {
 -		event = list_first_entry(&group->fanotify_data.access_list,
 -				struct fanotify_perm_event, fae.fse.list);
 +	list_for_each_entry_safe(event, next, &group->fanotify_data.access_list,
 +				 fae.fse.list) {
 +		pr_debug("%s: found group=%p event=%p\n", __func__, group,
 +			 event);
 +
  		list_del_init(&event->fae.fse.list);
- 		event->response = FAN_ALLOW;
+ 		finish_permission_event(group, event, FAN_ALLOW);
+ 		spin_lock(&group->notification_lock);
  	}
  
  	/*
@@@ -401,13 -453,14 +489,14 @@@
  	 */
  	while (!fsnotify_notify_queue_is_empty(group)) {
  		fsn_event = fsnotify_remove_first_event(group);
 -		if (!(FANOTIFY_E(fsn_event)->mask & FANOTIFY_PERM_EVENTS)) {
 +		if (!(fsn_event->mask & FANOTIFY_PERM_EVENTS)) {
  			spin_unlock(&group->notification_lock);
  			fsnotify_destroy_event(group, fsn_event);
- 			spin_lock(&group->notification_lock);
  		} else {
- 			FANOTIFY_PE(fsn_event)->response = FAN_ALLOW;
+ 			finish_permission_event(group, FANOTIFY_PE(fsn_event),
+ 						FAN_ALLOW);
  		}
+ 		spin_lock(&group->notification_lock);
  	}
  	spin_unlock(&group->notification_lock);
  
diff --git a/fs/notify/fanotify/fanotify.c b/fs/notify/fanotify/fanotify.c
index 2a603513f12e..a26f82dc1ce8 100644
--- a/fs/notify/fanotify/fanotify.c
+++ b/fs/notify/fanotify/fanotify.c
@@ -65,7 +65,8 @@ static int fanotify_get_response(struct fsnotify_group *group,
 
 	pr_debug("%s: group=%p event=%p\n", __func__, group, event);
 
-	wait_event(group->fanotify_data.access_waitq, event->response);
+	wait_event(group->fanotify_data.access_waitq,
+		   event->state == FAN_EVENT_ANSWERED);
 
 	/* userspace responded, convert to something usable */
 	switch (event->response & ~FAN_AUDIT) {
@@ -81,8 +82,6 @@ static int fanotify_get_response(struct fsnotify_group *group,
 	if (event->response & FAN_AUDIT)
 		audit_fanotify(event->response & ~FAN_AUDIT);
 
-	event->response = 0;
-
 	pr_debug("%s: group=%p event=%p about to return ret=%d\n", __func__,
 		 group, event, ret);
 	
@@ -174,6 +173,7 @@ struct fanotify_event_info *fanotify_alloc_event(struct fsnotify_group *group,
 			goto out;
 		event = &pevent->fae;
 		pevent->response = 0;
+		pevent->state = FAN_EVENT_INIT;
 		goto init;
 	}
 	event = kmem_cache_alloc(fanotify_event_cachep, gfp);
* Unmerged path fs/notify/fanotify/fanotify.h
* Unmerged path fs/notify/fanotify/fanotify_user.c
