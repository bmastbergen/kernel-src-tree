powerpc/uaccess: get rid of small constant size cases in raw_copy_{to,from}_user()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Christophe Leroy <christophe.leroy@csgroup.eu>
commit 6b385d1d7c0a346758e35b128815afa25d4709ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/6b385d1d.failed

Copied from commit 4b842e4e25b1 ("x86: get rid of small
constant size cases in raw_copy_{to,from}_user()")

Very few call sites where that would be triggered remain, and none
of those is anywhere near hot enough to bother.

	Signed-off-by: Christophe Leroy <christophe.leroy@csgroup.eu>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/99d4ccb58a20d8408d0e19874393655ad5b40822.1612879284.git.christophe.leroy@csgroup.eu
(cherry picked from commit 6b385d1d7c0a346758e35b128815afa25d4709ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/uaccess.h
diff --cc arch/powerpc/include/asm/uaccess.h
index 5a6739bbf2b1,88f5b0fe9a12..000000000000
--- a/arch/powerpc/include/asm/uaccess.h
+++ b/arch/powerpc/include/asm/uaccess.h
@@@ -406,66 -398,26 +406,80 @@@ static inline unsigned long raw_copy_fr
  		const void __user *from, unsigned long n)
  {
  	unsigned long ret;
++<<<<<<< HEAD
 +	if (__builtin_constant_p(n) && (n <= 8)) {
 +		ret = 1;
 +
 +		switch (n) {
 +		case 1:
 +			barrier_nospec();
 +			__get_user_size(*(u8 *)to, from, 1, ret);
 +			break;
 +		case 2:
 +			barrier_nospec();
 +			__get_user_size(*(u16 *)to, from, 2, ret);
 +			break;
 +		case 4:
 +			barrier_nospec();
 +			__get_user_size(*(u32 *)to, from, 4, ret);
 +			break;
 +		case 8:
 +			barrier_nospec();
 +			__get_user_size(*(u64 *)to, from, 8, ret);
 +			break;
 +		}
 +		if (ret == 0)
 +			return 0;
 +	}
++=======
++>>>>>>> 6b385d1d7c0a (powerpc/uaccess: get rid of small constant size cases in raw_copy_{to,from}_user())
  
 +	barrier_nospec();
  	allow_read_from_user(from, n);
  	ret = __copy_tofrom_user((__force void __user *)to, from, n);
  	prevent_read_from_user(from, n);
  	return ret;
  }
  
 -static inline unsigned long
 -raw_copy_to_user_allowed(void __user *to, const void *from, unsigned long n)
 +static inline unsigned long raw_copy_to_user(void __user *to,
 +		const void *from, unsigned long n)
  {
++<<<<<<< HEAD
 +	unsigned long ret;
 +
 +	if (__builtin_constant_p(n) && (n <= 8)) {
 +		ret = 1;
 +
 +		switch (n) {
 +		case 1:
 +			__put_user_size_allowed(*(u8 *)from, (u8 __user *)to, 1, ret);
 +			break;
 +		case 2:
 +			__put_user_size_allowed(*(u16 *)from, (u16 __user *)to, 2, ret);
 +			break;
 +		case 4:
 +			__put_user_size_allowed(*(u32 *)from, (u32 __user *)to, 4, ret);
 +			break;
 +		case 8:
 +			__put_user_size_allowed(*(u64 *)from, (u64 __user *)to, 8, ret);
 +			break;
 +		}
 +		if (ret == 0)
 +			return 0;
 +	}
 +
++=======
+ 	return __copy_tofrom_user(to, (__force const void __user *)from, n);
+ }
+ 
+ static inline unsigned long
+ raw_copy_to_user(void __user *to, const void *from, unsigned long n)
+ {
+ 	unsigned long ret;
+ 
++>>>>>>> 6b385d1d7c0a (powerpc/uaccess: get rid of small constant size cases in raw_copy_{to,from}_user())
  	allow_write_to_user(to, n);
 -	ret = raw_copy_to_user_allowed(to, from, n);
 +	ret = __copy_tofrom_user(to, (__force const void __user *)from, n);
  	prevent_write_to_user(to, n);
  	return ret;
  }
* Unmerged path arch/powerpc/include/asm/uaccess.h
