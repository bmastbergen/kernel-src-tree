bnxt_en: Improve the status_reliable flag in bp->fw_health.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Michael Chan <michael.chan@broadcom.com>
commit 43a440c4007b28c473afba966e8410459db4975f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/43a440c4.failed

In order to read the firmware health status, we first need to determine
the register location and then the register may need to be mapped.
There are 2 code paths to do this.  The first one is done early as a
best effort attempt by the function bnxt_try_map_fw_health_reg().  The
second one is done later in the function bnxt_map_fw_health_regs()
after establishing communications with the firmware.  We currently
only set fw_health->status_reliable if we can successfully set up the
health register in the first code path.

Improve the scheme by setting the fw_health->status_reliable flag if
either (or both) code paths can successfully set up the health
register.  This flag is relied upon during run-time when we need to
check the health status.  So this will make it work better.

During ifdown, if the health register is mapped, we need to invalidate
the health register mapping because a potential fw reset will reset
the mapping.  Similarly, we need to do the same after firmware reset
during recovery.  We'll remap it during ifup.

	Reviewed-by: Edwin Peer <edwin.peer@broadcom.com>
	Reviewed-by: Vasundhara Volam <vasundhara-v.volam@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 43a440c4007b28c473afba966e8410459db4975f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 26cd8c410fc6,16cf18eb7b3d..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -11783,20 -11743,29 +11803,26 @@@ static void bnxt_fw_reset_task(struct w
  		bnxt_queue_fw_reset_work(bp, bp->fw_reset_min_dsecs * HZ / 10);
  		return;
  	case BNXT_FW_RESET_STATE_ENABLE_DEV:
++<<<<<<< HEAD
 +		if (test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state) &&
 +		    !bp->fw_reset_min_dsecs) {
 +			u16 val;
++=======
+ 		bnxt_inv_fw_health_reg(bp);
+ 		if (test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state)) {
+ 			u32 val;
 -
 -			if (!bp->fw_reset_min_dsecs) {
 -				u16 val;
 -
 -				pci_read_config_word(bp->pdev, PCI_SUBSYSTEM_ID,
 -						     &val);
 -				if (val == 0xffff) {
 -					if (bnxt_fw_reset_timeout(bp)) {
 -						netdev_err(bp->dev, "Firmware reset aborted, PCI config space invalid\n");
 -						goto fw_reset_abort;
 -					}
 -					bnxt_queue_fw_reset_work(bp, HZ / 1000);
 -					return;
++>>>>>>> 43a440c4007b (bnxt_en: Improve the status_reliable flag in bp->fw_health.)
 +
 +			pci_read_config_word(bp->pdev, PCI_SUBSYSTEM_ID, &val);
 +			if (val == 0xffff) {
 +				if (bnxt_fw_reset_timeout(bp)) {
 +					netdev_err(bp->dev, "Firmware reset aborted, PCI config space invalid\n");
 +					rc = -ETIMEDOUT;
 +					goto fw_reset_abort;
  				}
 +				bnxt_queue_fw_reset_work(bp, HZ / 1000);
 +				return;
  			}
 -			val = bnxt_fw_health_readl(bp,
 -						   BNXT_FW_RESET_INPROG_REG);
 -			if (val)
 -				netdev_warn(bp->dev, "FW reset inprog %x after min wait time.\n",
 -					    val);
  		}
  		clear_bit(BNXT_STATE_FW_FATAL_COND, &bp->state);
  		if (pci_enable_device(bp->pdev)) {
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
