x86/fpu: Convert fpstate_init() to struct fpstate

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit f83ac56acdad0815366bb541b6cc9d24f6cea2b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/f83ac56a.failed

Convert fpstate_init() and related code to the new register storage
mechanism in preparation for dynamically sized buffers.

No functional change.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20211013145322.292157401@linutronix.de
(cherry picked from commit f83ac56acdad0815366bb541b6cc9d24f6cea2b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/fpu/core.c
#	arch/x86/kernel/fpu/internal.h
#	arch/x86/kernel/fpu/xstate.c
diff --cc arch/x86/kernel/fpu/core.c
index 3f16056105e8,19e14b5c519d..000000000000
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@@ -147,6 -155,11 +147,14 @@@ void restore_fpregs_from_fpstate(union 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ void fpu_reset_from_exception_fixup(void)
+ {
+ 	restore_fpregs_from_fpstate(&init_fpstate.regs, xfeatures_mask_fpstate());
+ }
+ 
++>>>>>>> f83ac56acdad (x86/fpu: Convert fpstate_init() to struct fpstate)
  #if IS_ENABLED(CONFIG_KVM)
  void fpu_swap_kvm_fpu(struct fpu *save, struct fpu *rstor, u64 restore_mask)
  {
@@@ -316,18 -329,25 +324,23 @@@ void fpstate_init_user(struct fpstate *
  		return;
  	}
  
- 	xstate_init_xcomp_bv(&state->xsave, xfeatures_mask_uabi());
+ 	xstate_init_xcomp_bv(&fpstate->regs.xsave, xfeatures_mask_uabi());
  
  	if (cpu_feature_enabled(X86_FEATURE_FXSR))
- 		fpstate_init_fxstate(&state->fxsave);
+ 		fpstate_init_fxstate(fpstate);
  	else
- 		fpstate_init_fstate(&state->fsave);
+ 		fpstate_init_fstate(fpstate);
  }
  
 -void fpstate_reset(struct fpu *fpu)
 -{
 -	/* Set the fpstate pointer to the default fpstate */
 -	fpu->fpstate = &fpu->__fpstate;
 -}
 -
  #if IS_ENABLED(CONFIG_KVM)
  void fpu_init_fpstate_user(struct fpu *fpu)
  {
++<<<<<<< HEAD
 +	fpstate_init_user(&fpu->state);
++=======
+ 	fpstate_reset(fpu);
+ 	fpstate_init_user(fpu->fpstate);
++>>>>>>> f83ac56acdad (x86/fpu: Convert fpstate_init() to struct fpstate)
  }
  EXPORT_SYMBOL_GPL(fpu_init_fpstate_user);
  #endif
diff --cc arch/x86/kernel/fpu/internal.h
index 5ddc09e03c2a,e1d8a352f12d..000000000000
--- a/arch/x86/kernel/fpu/internal.h
+++ b/arch/x86/kernel/fpu/internal.h
@@@ -2,6 -2,8 +2,11 @@@
  #ifndef __X86_KERNEL_FPU_INTERNAL_H
  #define __X86_KERNEL_FPU_INTERNAL_H
  
++<<<<<<< HEAD
++=======
+ extern struct fpstate init_fpstate;
+ 
++>>>>>>> f83ac56acdad (x86/fpu: Convert fpstate_init() to struct fpstate)
  /* CPU feature check wrappers */
  static __always_inline __pure bool use_xsave(void)
  {
@@@ -22,4 -24,8 +27,11 @@@ static __always_inline __pure bool use_
  /* Init functions */
  extern void fpu__init_prepare_fx_sw_frame(void);
  
++<<<<<<< HEAD
++=======
+ /* Used in init.c */
+ extern void fpstate_init_user(struct fpstate *fpstate);
+ extern void fpstate_reset(struct fpu *fpu);
+ 
++>>>>>>> f83ac56acdad (x86/fpu: Convert fpstate_init() to struct fpstate)
  #endif
diff --cc arch/x86/kernel/fpu/xstate.c
index 8c27dcecbad5,937ad5b394ca..000000000000
--- a/arch/x86/kernel/fpu/xstate.c
+++ b/arch/x86/kernel/fpu/xstate.c
@@@ -1005,12 -977,11 +1005,16 @@@ static void copy_feature(bool from_xsta
   *
   * It supports partial copy but @to.pos always starts from zero.
   */
 -void __copy_xstate_to_uabi_buf(struct membuf to, struct xregs_state *xsave,
 -			       u32 pkru_val, enum xstate_copy_mode copy_mode)
 +void copy_xstate_to_uabi_buf(struct membuf to, struct task_struct *tsk,
 +			     enum xstate_copy_mode copy_mode)
  {
  	const unsigned int off_mxcsr = offsetof(struct fxregs_state, mxcsr);
++<<<<<<< HEAD
 +	struct xregs_state *xsave = &tsk->thread.fpu.state.xsave;
 +	struct xregs_state *xinit = &init_fpstate.xsave;
++=======
+ 	struct xregs_state *xinit = &init_fpstate.regs.xsave;
++>>>>>>> f83ac56acdad (x86/fpu: Convert fpstate_init() to struct fpstate)
  	struct xstate_header header;
  	unsigned int zerofrom;
  	u64 mask;
* Unmerged path arch/x86/kernel/fpu/core.c
* Unmerged path arch/x86/kernel/fpu/internal.h
diff --git a/arch/x86/kernel/fpu/signal.c b/arch/x86/kernel/fpu/signal.c
index f74c29985497..bc438166d32c 100644
--- a/arch/x86/kernel/fpu/signal.c
+++ b/arch/x86/kernel/fpu/signal.c
@@ -240,7 +240,7 @@ static int __restore_fpregs_from_user(void __user *buf, u64 xrestore,
 			ret = fxrstor_from_user_sigframe(buf);
 
 		if (!ret && unlikely(init_bv))
-			os_xrstor(&init_fpstate.xsave, init_bv);
+			os_xrstor(&init_fpstate.regs.xsave, init_bv);
 		return ret;
 	} else if (use_fxsr()) {
 		return fxrstor_from_user_sigframe(buf);
* Unmerged path arch/x86/kernel/fpu/xstate.c
