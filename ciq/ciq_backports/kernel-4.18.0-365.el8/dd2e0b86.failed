tcp: remove indirect calls for icsk->icsk_af_ops->send_check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Eric Dumazet <edumazet@google.com>
commit dd2e0b86fc4ee146ac8f3275833d0187efeb950a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/dd2e0b86.failed

Mitigate RETPOLINE costs in __tcp_transmit_skb()
by using INDIRECT_CALL_INET() wrapper.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit dd2e0b86fc4ee146ac8f3275833d0187efeb950a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tcp.h
#	net/ipv4/tcp_output.c
diff --cc include/net/tcp.h
index eb747e5c8009,cd9cc348dbf9..000000000000
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@@ -950,10 -932,20 +950,17 @@@ static inline int tcp_v6_sdif(const str
  #endif
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ INDIRECT_CALLABLE_DECLARE(void tcp_v6_send_check(struct sock *sk, struct sk_buff *skb));
+ 
+ #endif
++>>>>>>> dd2e0b86fc4e (tcp: remove indirect calls for icsk->icsk_af_ops->send_check)
 +
 +extern const struct inet_connection_sock_af_ops ipv6_specific;
  
 -static inline bool inet_exact_dif_match(struct net *net, struct sk_buff *skb)
 -{
 -#if IS_ENABLED(CONFIG_NET_L3_MASTER_DEV)
 -	if (!net->ipv4.sysctl_tcp_l3mdev_accept &&
 -	    skb && ipv4_l3mdev_skb(IPCB(skb)->flags))
 -		return true;
  #endif
 -	return false;
 -}
  
  /* TCP_SKB_CB reference means this can not be used from early demux */
  static inline int tcp_v4_sdif(struct sk_buff *skb)
diff --cc net/ipv4/tcp_output.c
index 13eacd35b79b,04b70fe31fa2..000000000000
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@@ -1240,6 -1064,10 +1240,13 @@@ static void tcp_update_skb_after_send(s
  	list_move_tail(&skb->tcp_tsorted_anchor, &tp->tsorted_sent_queue);
  }
  
++<<<<<<< HEAD
++=======
+ INDIRECT_CALLABLE_DECLARE(int ip_queue_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl));
+ INDIRECT_CALLABLE_DECLARE(int inet6_csk_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl));
+ INDIRECT_CALLABLE_DECLARE(void tcp_v4_send_check(struct sock *sk, struct sk_buff *skb));
+ 
++>>>>>>> dd2e0b86fc4e (tcp: remove indirect calls for icsk->icsk_af_ops->send_check)
  /* This routine actually transmits TCP packets queued in by
   * tcp_do_sendmsg().  This is used by both the initial
   * transmission and possible later retransmissions.
@@@ -1377,10 -1211,9 +1384,16 @@@ static int __tcp_transmit_skb(struct so
  	}
  #endif
  
++<<<<<<< HEAD
 +	/* BPF prog is the last one writing header option */
 +	bpf_skops_write_hdr_opt(sk, skb, NULL, NULL, 0, &opts);
 +
 +	icsk->icsk_af_ops->send_check(sk, skb);
++=======
+ 	INDIRECT_CALL_INET(icsk->icsk_af_ops->send_check,
+ 			   tcp_v6_send_check, tcp_v4_send_check,
+ 			   sk, skb);
++>>>>>>> dd2e0b86fc4e (tcp: remove indirect calls for icsk->icsk_af_ops->send_check)
  
  	if (likely(tcb->tcp_flags & TCPHDR_ACK))
  		tcp_event_ack_sent(sk, tcp_skb_pcount(skb), rcv_nxt);
diff --git a/include/net/ip6_checksum.h b/include/net/ip6_checksum.h
index 3ffacfeeaca2..ac4c27a4bb52 100644
--- a/include/net/ip6_checksum.h
+++ b/include/net/ip6_checksum.h
@@ -89,15 +89,6 @@ static inline void tcp_v6_gso_csum_prep(struct sk_buff *skb)
 	th->check = ~tcp_v6_check(0, &ipv6h->saddr, &ipv6h->daddr, 0);
 }
 
-#if IS_ENABLED(CONFIG_IPV6)
-static inline void tcp_v6_send_check(struct sock *sk, struct sk_buff *skb)
-{
-	struct ipv6_pinfo *np = inet6_sk(sk);
-
-	__tcp_v6_send_check(skb, &np->saddr, &sk->sk_v6_daddr);
-}
-#endif
-
 static inline __sum16 udp_v6_check(int len,
 				   const struct in6_addr *saddr,
 				   const struct in6_addr *daddr,
* Unmerged path include/net/tcp.h
* Unmerged path net/ipv4/tcp_output.c
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index e0616d27e5eb..b2e8df6da717 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -1757,6 +1757,13 @@ static struct timewait_sock_ops tcp6_timewait_sock_ops = {
 	.twsk_destructor = tcp_twsk_destructor,
 };
 
+INDIRECT_CALLABLE_SCOPE void tcp_v6_send_check(struct sock *sk, struct sk_buff *skb)
+{
+	struct ipv6_pinfo *np = inet6_sk(sk);
+
+	__tcp_v6_send_check(skb, &np->saddr, &sk->sk_v6_daddr);
+}
+
 const struct inet_connection_sock_af_ops ipv6_specific = {
 	.queue_xmit	   = inet6_csk_xmit,
 	.send_check	   = tcp_v6_send_check,
