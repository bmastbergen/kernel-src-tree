fanotify: Fold dequeue_event() into process_access_response()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Jan Kara <jack@suse.cz>
commit af6a51130626bfd3e60041d80335b2c31590d56d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/af6a5113.failed

Fold dequeue_event() into process_access_response(). This will make
changes to use of ->response field easier.

	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit af6a51130626bfd3e60041d80335b2c31590d56d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/fanotify/fanotify_user.c
diff --cc fs/notify/fanotify/fanotify_user.c
index 48689619c0fd,e47d2a7709bf..000000000000
--- a/fs/notify/fanotify/fanotify_user.c
+++ b/fs/notify/fanotify/fanotify_user.c
@@@ -114,58 -138,6 +114,61 @@@ static int create_fd(struct fsnotify_gr
  	return client_fd;
  }
  
++<<<<<<< HEAD
 +static int fill_event_metadata(struct fsnotify_group *group,
 +			       struct fanotify_event_metadata *metadata,
 +			       struct fsnotify_event *fsn_event,
 +			       struct file **file)
 +{
 +	int ret = 0;
 +	struct fanotify_event_info *event;
 +
 +	pr_debug("%s: group=%p metadata=%p event=%p\n", __func__,
 +		 group, metadata, fsn_event);
 +
 +	*file = NULL;
 +	event = container_of(fsn_event, struct fanotify_event_info, fse);
 +	metadata->event_len = FAN_EVENT_METADATA_LEN;
 +	metadata->metadata_len = FAN_EVENT_METADATA_LEN;
 +	metadata->vers = FANOTIFY_METADATA_VERSION;
 +	metadata->reserved = 0;
 +	metadata->mask = fsn_event->mask & FANOTIFY_OUTGOING_EVENTS;
 +	metadata->pid = pid_vnr(event->pid);
 +	if (unlikely(fsn_event->mask & FAN_Q_OVERFLOW))
 +		metadata->fd = FAN_NOFD;
 +	else {
 +		metadata->fd = create_fd(group, event, file);
 +		if (metadata->fd < 0)
 +			ret = metadata->fd;
 +	}
 +
 +	return ret;
 +}
 +
 +static struct fanotify_perm_event_info *dequeue_event(
 +				struct fsnotify_group *group, int fd)
 +{
 +	struct fanotify_perm_event_info *event, *return_e = NULL;
 +
 +	spin_lock(&group->notification_lock);
 +	list_for_each_entry(event, &group->fanotify_data.access_list,
 +			    fae.fse.list) {
 +		if (event->fd != fd)
 +			continue;
 +
 +		list_del_init(&event->fae.fse.list);
 +		return_e = event;
 +		break;
 +	}
 +	spin_unlock(&group->notification_lock);
 +
 +	pr_debug("%s: found return_re=%p\n", __func__, return_e);
 +
 +	return return_e;
 +}
 +
++=======
++>>>>>>> af6a51130626 (fanotify: Fold dequeue_event() into process_access_response())
  static int process_access_response(struct fsnotify_group *group,
  				   struct fanotify_response *response_struct)
  {
@@@ -194,31 -166,93 +197,38 @@@
  	if ((response & FAN_AUDIT) && !FAN_GROUP_FLAG(group, FAN_ENABLE_AUDIT))
  		return -EINVAL;
  
- 	event = dequeue_event(group, fd);
- 	if (!event)
- 		return -ENOENT;
+ 	spin_lock(&group->notification_lock);
+ 	list_for_each_entry(event, &group->fanotify_data.access_list,
+ 			    fae.fse.list) {
+ 		if (event->fd != fd)
+ 			continue;
  
- 	event->response = response;
- 	wake_up(&group->fanotify_data.access_waitq);
+ 		list_del_init(&event->fae.fse.list);
+ 		event->response = response;
+ 		spin_unlock(&group->notification_lock);
+ 		wake_up(&group->fanotify_data.access_waitq);
+ 		return 0;
+ 	}
+ 	spin_unlock(&group->notification_lock);
  
- 	return 0;
+ 	return -ENOENT;
  }
  
 -static int copy_fid_to_user(struct fanotify_event *event, char __user *buf)
 -{
 -	struct fanotify_event_info_fid info = { };
 -	struct file_handle handle = { };
 -	size_t fh_len = event->fh_len;
 -	size_t len = fanotify_event_info_len(event);
 -
 -	if (!len)
 -		return 0;
 -
 -	if (WARN_ON_ONCE(len < sizeof(info) + sizeof(handle) + fh_len))
 -		return -EFAULT;
 -
 -	/* Copy event info fid header followed by vaiable sized file handle */
 -	info.hdr.info_type = FAN_EVENT_INFO_TYPE_FID;
 -	info.hdr.len = len;
 -	info.fsid = event->fid.fsid;
 -	if (copy_to_user(buf, &info, sizeof(info)))
 -		return -EFAULT;
 -
 -	buf += sizeof(info);
 -	len -= sizeof(info);
 -	handle.handle_type = event->fh_type;
 -	handle.handle_bytes = fh_len;
 -	if (copy_to_user(buf, &handle, sizeof(handle)))
 -		return -EFAULT;
 -
 -	buf += sizeof(handle);
 -	len -= sizeof(handle);
 -	if (copy_to_user(buf, fanotify_event_fh(event), fh_len))
 -		return -EFAULT;
 -
 -	/* Pad with 0's */
 -	buf += fh_len;
 -	len -= fh_len;
 -	WARN_ON_ONCE(len < 0 || len >= FANOTIFY_EVENT_ALIGN);
 -	if (len > 0 && clear_user(buf, len))
 -		return -EFAULT;
 -
 -	return 0;
 -}
 -
  static ssize_t copy_event_to_user(struct fsnotify_group *group,
 -				  struct fsnotify_event *fsn_event,
 +				  struct fsnotify_event *event,
  				  char __user *buf, size_t count)
  {
 -	struct fanotify_event_metadata metadata;
 -	struct fanotify_event *event;
 -	struct file *f = NULL;
 -	int ret, fd = FAN_NOFD;
 -
 -	pr_debug("%s: group=%p event=%p\n", __func__, group, fsn_event);
 -
 -	event = container_of(fsn_event, struct fanotify_event, fse);
 -	metadata.event_len = FAN_EVENT_METADATA_LEN;
 -	metadata.metadata_len = FAN_EVENT_METADATA_LEN;
 -	metadata.vers = FANOTIFY_METADATA_VERSION;
 -	metadata.reserved = 0;
 -	metadata.mask = event->mask & FANOTIFY_OUTGOING_EVENTS;
 -	metadata.pid = pid_vnr(event->pid);
 -
 -	if (fanotify_event_has_path(event)) {
 -		fd = create_fd(group, event, &f);
 -		if (fd < 0)
 -			return fd;
 -	} else if (fanotify_event_has_fid(event)) {
 -		metadata.event_len += fanotify_event_info_len(event);
 -	}
 -	metadata.fd = fd;
 +	struct fanotify_event_metadata fanotify_event_metadata;
 +	struct file *f;
 +	int fd, ret;
 +
 +	pr_debug("%s: group=%p event=%p\n", __func__, group, event);
  
 +	ret = fill_event_metadata(group, &fanotify_event_metadata, event, &f);
 +	if (ret < 0)
 +		return ret;
 +
 +	fd = fanotify_event_metadata.fd;
  	ret = -EFAULT;
  	/*
  	 * Sanity check copy size in case get_one_event() and
* Unmerged path fs/notify/fanotify/fanotify_user.c
