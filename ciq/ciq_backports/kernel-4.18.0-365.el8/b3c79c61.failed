KVM: arm64: selftests: Introduce ARM64_SYS_KVM_REG

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Raghavendra Rao Ananta <rananta@google.com>
commit b3c79c6130bcfdb0ff3819077deaddce981a0718
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/b3c79c61.failed

With the inclusion of sysreg.h, that brings in system register
encodings, it would be redundant to re-define register encodings
again in processor.h to use it with ARM64_SYS_REG for the KVM
functions such as set_reg() or get_reg(). Hence, add helper macro,
ARM64_SYS_KVM_REG, that converts SYS_* definitions in sysreg.h
into ARM64_SYS_REG definitions.

Also replace all the users of ARM64_SYS_REG, relying on
the encodings created in processor.h, with ARM64_SYS_KVM_REG and
remove the definitions.

	Signed-off-by: Raghavendra Rao Ananta <rananta@google.com>
	Reviewed-by: Ricardo Koller <ricarkol@google.com>
	Reviewed-by: Andrew Jones <drjones@redhat.com>
	Signed-off-by: Marc Zyngier <maz@kernel.org>
Link: https://lore.kernel.org/r/20211007233439.1826892-5-rananta@google.com
(cherry picked from commit b3c79c6130bcfdb0ff3819077deaddce981a0718)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/aarch64/psci_cpu_on_test.c
#	tools/testing/selftests/kvm/include/aarch64/processor.h
diff --cc tools/testing/selftests/kvm/include/aarch64/processor.h
index b3978d5d2a09,93797783abad..000000000000
--- a/tools/testing/selftests/kvm/include/aarch64/processor.h
+++ b/tools/testing/selftests/kvm/include/aarch64/processor.h
@@@ -16,14 -16,17 +16,28 @@@
  #define ARM64_CORE_REG(x) (KVM_REG_ARM64 | KVM_REG_SIZE_U64 | \
  			   KVM_REG_ARM_CORE | KVM_REG_ARM_CORE_REG(x))
  
++<<<<<<< HEAD
 +#define CPACR_EL1               3, 0,  1, 0, 2
 +#define TCR_EL1                 3, 0,  2, 0, 2
 +#define MAIR_EL1                3, 0, 10, 2, 0
 +#define TTBR0_EL1               3, 0,  2, 0, 0
 +#define SCTLR_EL1               3, 0,  1, 0, 0
 +#define VBAR_EL1                3, 0, 12, 0, 0
 +
 +#define ID_AA64DFR0_EL1         3, 0,  0, 5, 0
++=======
+ /*
+  * KVM_ARM64_SYS_REG(sys_reg_id): Helper macro to convert
+  * SYS_* register definitions in asm/sysreg.h to use in KVM
+  * calls such as get_reg() and set_reg().
+  */
+ #define KVM_ARM64_SYS_REG(sys_reg_id)			\
+ 	ARM64_SYS_REG(sys_reg_Op0(sys_reg_id),		\
+ 			sys_reg_Op1(sys_reg_id),	\
+ 			sys_reg_CRn(sys_reg_id),	\
+ 			sys_reg_CRm(sys_reg_id),	\
+ 			sys_reg_Op2(sys_reg_id))
++>>>>>>> b3c79c6130bc (KVM: arm64: selftests: Introduce ARM64_SYS_KVM_REG)
  
  /*
   * Default MAIR
* Unmerged path tools/testing/selftests/kvm/aarch64/psci_cpu_on_test.c
diff --git a/tools/testing/selftests/kvm/aarch64/debug-exceptions.c b/tools/testing/selftests/kvm/aarch64/debug-exceptions.c
index 11fd23e21cb4..ea189d83abf7 100644
--- a/tools/testing/selftests/kvm/aarch64/debug-exceptions.c
+++ b/tools/testing/selftests/kvm/aarch64/debug-exceptions.c
@@ -190,7 +190,7 @@ static int debug_version(struct kvm_vm *vm)
 {
 	uint64_t id_aa64dfr0;
 
-	get_reg(vm, VCPU_ID, ARM64_SYS_REG(ID_AA64DFR0_EL1), &id_aa64dfr0);
+	get_reg(vm, VCPU_ID, KVM_ARM64_SYS_REG(SYS_ID_AA64DFR0_EL1), &id_aa64dfr0);
 	return id_aa64dfr0 & 0xf;
 }
 
* Unmerged path tools/testing/selftests/kvm/aarch64/psci_cpu_on_test.c
* Unmerged path tools/testing/selftests/kvm/include/aarch64/processor.h
diff --git a/tools/testing/selftests/kvm/lib/aarch64/processor.c b/tools/testing/selftests/kvm/lib/aarch64/processor.c
index 632b74d6b3ca..db64ee206064 100644
--- a/tools/testing/selftests/kvm/lib/aarch64/processor.c
+++ b/tools/testing/selftests/kvm/lib/aarch64/processor.c
@@ -232,10 +232,10 @@ void aarch64_vcpu_setup(struct kvm_vm *vm, int vcpuid, struct kvm_vcpu_init *ini
 	 * Enable FP/ASIMD to avoid trapping when accessing Q0-Q15
 	 * registers, which the variable argument list macros do.
 	 */
-	set_reg(vm, vcpuid, ARM64_SYS_REG(CPACR_EL1), 3 << 20);
+	set_reg(vm, vcpuid, KVM_ARM64_SYS_REG(SYS_CPACR_EL1), 3 << 20);
 
-	get_reg(vm, vcpuid, ARM64_SYS_REG(SCTLR_EL1), &sctlr_el1);
-	get_reg(vm, vcpuid, ARM64_SYS_REG(TCR_EL1), &tcr_el1);
+	get_reg(vm, vcpuid, KVM_ARM64_SYS_REG(SYS_SCTLR_EL1), &sctlr_el1);
+	get_reg(vm, vcpuid, KVM_ARM64_SYS_REG(SYS_TCR_EL1), &tcr_el1);
 
 	switch (vm->mode) {
 	case VM_MODE_P52V48_4K:
@@ -273,10 +273,10 @@ void aarch64_vcpu_setup(struct kvm_vm *vm, int vcpuid, struct kvm_vcpu_init *ini
 	tcr_el1 |= (1 << 8) | (1 << 10) | (3 << 12);
 	tcr_el1 |= (64 - vm->va_bits) /* T0SZ */;
 
-	set_reg(vm, vcpuid, ARM64_SYS_REG(SCTLR_EL1), sctlr_el1);
-	set_reg(vm, vcpuid, ARM64_SYS_REG(TCR_EL1), tcr_el1);
-	set_reg(vm, vcpuid, ARM64_SYS_REG(MAIR_EL1), DEFAULT_MAIR_EL1);
-	set_reg(vm, vcpuid, ARM64_SYS_REG(TTBR0_EL1), vm->pgd);
+	set_reg(vm, vcpuid, KVM_ARM64_SYS_REG(SYS_SCTLR_EL1), sctlr_el1);
+	set_reg(vm, vcpuid, KVM_ARM64_SYS_REG(SYS_TCR_EL1), tcr_el1);
+	set_reg(vm, vcpuid, KVM_ARM64_SYS_REG(SYS_MAIR_EL1), DEFAULT_MAIR_EL1);
+	set_reg(vm, vcpuid, KVM_ARM64_SYS_REG(SYS_TTBR0_EL1), vm->pgd);
 }
 
 void vcpu_dump(FILE *stream, struct kvm_vm *vm, uint32_t vcpuid, uint8_t indent)
@@ -362,7 +362,7 @@ void vcpu_init_descriptor_tables(struct kvm_vm *vm, uint32_t vcpuid)
 {
 	extern char vectors;
 
-	set_reg(vm, vcpuid, ARM64_SYS_REG(VBAR_EL1), (uint64_t)&vectors);
+	set_reg(vm, vcpuid, KVM_ARM64_SYS_REG(SYS_VBAR_EL1), (uint64_t)&vectors);
 }
 
 void route_exception(struct ex_regs *regs, int vector)
