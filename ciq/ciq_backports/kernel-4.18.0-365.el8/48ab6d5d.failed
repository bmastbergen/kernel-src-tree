dma-mapping: fix 32-bit overflow with CONFIG_ARM_LPAE=n

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Geert Uytterhoeven <geert+renesas@glider.be>
commit 48ab6d5d1f096d6fac5b59f94af0aa394115a001
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/48ab6d5d.failed

On r8a7791/koelsch and shmobile_defconfig, PCIe probing fails with:

    rcar-pcie fe000000.pcie: Adjusted size 0x0 invalid
    rcar-pcie: probe of fe000000.pcie failed with error -22

of_dma_get_range() returns the following map:

    cpu_start 0x40000000 dma_start 0x40000000 size 0x080000000 offset 0
    cpu_start 0x00000000 dma_start 0x00000000 size 0x100000000 offset 0

If CONFIG_ARM_LPAE=n, dma_addr_t is 32-bit.  Hence when assigning
r->dma_start + r->size to dma_end, this value will be truncated to
32-bit, yielding zero when processing the second table entry.
Consequently, both dma_start and dma_end will be zero, leading to a zero
size.

Fix this by changing the dma_start and dma_end variables from dma_addr_t
to u64.

Fixes: e0d072782c734d27 ("dma-mapping: introduce DMA range map, supplanting dma_pfn_offset")
	Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 48ab6d5d1f096d6fac5b59f94af0aa394115a001)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/of/device.c
diff --cc drivers/of/device.c
index f137835e2a84,3a469c79e6b0..000000000000
--- a/drivers/of/device.c
+++ b/drivers/of/device.c
@@@ -90,14 -91,14 +90,22 @@@ int of_device_add(struct platform_devic
  int of_dma_configure_id(struct device *dev, struct device_node *np,
  			bool force_dma, const u32 *id)
  {
++<<<<<<< HEAD
 +	u64 dma_addr, paddr, size = 0;
++=======
+ 	const struct iommu_ops *iommu;
+ 	const struct bus_dma_region *map = NULL;
+ 	u64 dma_start = 0;
+ 	u64 mask, end, size = 0;
+ 	bool coherent;
++>>>>>>> 48ab6d5d1f09 (dma-mapping: fix 32-bit overflow with CONFIG_ARM_LPAE=n)
  	int ret;
 +	bool coherent;
 +	unsigned long offset;
 +	const struct iommu_ops *iommu;
 +	u64 mask, end;
  
 -	ret = of_dma_get_range(np, &map);
 +	ret = of_dma_get_range(np, &dma_addr, &paddr, &size);
  	if (ret < 0) {
  		/*
  		 * For legacy reasons, we have to assume some devices need
@@@ -106,10 -107,19 +114,26 @@@
  		 */
  		if (!force_dma)
  			return ret == -ENODEV ? 0 : ret;
++<<<<<<< HEAD
 +
 +		dma_addr = offset = 0;
 +	} else {
 +		offset = PFN_DOWN(paddr - dma_addr);
++=======
+ 	} else {
+ 		const struct bus_dma_region *r = map;
+ 		u64 dma_end = 0;
+ 
+ 		/* Determine the overall bounds of all DMA regions */
+ 		for (dma_start = ~0ULL; r->size; r++) {
+ 			/* Take lower and upper limits */
+ 			if (r->dma_start < dma_start)
+ 				dma_start = r->dma_start;
+ 			if (r->dma_start + r->size > dma_end)
+ 				dma_end = r->dma_start + r->size;
+ 		}
+ 		size = dma_end - dma_start;
++>>>>>>> 48ab6d5d1f09 (dma-mapping: fix 32-bit overflow with CONFIG_ARM_LPAE=n)
  
  		/*
  		 * Add a work around to treat the size as mask + 1 in case
* Unmerged path drivers/of/device.c
