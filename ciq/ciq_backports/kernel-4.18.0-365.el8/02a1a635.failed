drm/i915/wm: provide wrappers around watermark vfuncs calls (v3)

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Dave Airlie <airlied@redhat.com>
commit 02a1a6351e439638cb04852eb57c129b60ce36b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/02a1a635.failed

This moves one wrapper from the pm->display side, and creates
wrappers for all the others, this should simplify things later.

One thing to note is that the code checks the existence of some
of these ptrs, so the wrappers are a bit complicated by that.

Suggested by Jani.

v2: fixup warnings in wrong place error.

v3 by Jani: fix intel_compute_global_watermarks() return value check

	Reviewed-by: Jani Nikula <jani.nikula@intel.com>
	Signed-off-by: Dave Airlie <airlied@redhat.com>
	Signed-off-by: Jani Nikula <jani.nikula@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/ee2760c45896568c9dd9114a575509619bd44ef2.1632869550.git.jani.nikula@intel.com
(cherry picked from commit 02a1a6351e439638cb04852eb57c129b60ce36b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_display.c
#	drivers/gpu/drm/i915/intel_pm.c
#	drivers/gpu/drm/i915/intel_pm.h
diff --cc drivers/gpu/drm/i915/display/intel_display.c
index 85c872f93b98,9af433a7cbf1..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@@ -4986,10 -2632,9 +5081,16 @@@ static void intel_pre_plane_update(stru
  		 * we'll continue to update watermarks the old way, if flags tell
  		 * us to.
  		 */
++<<<<<<< HEAD
 +		if (dev_priv->display.initial_watermarks)
 +			dev_priv->display.initial_watermarks(state, crtc);
 +		else if (new_crtc_state->update_wm_pre)
 +			intel_update_watermarks(crtc);
++=======
+ 		if (!intel_initial_watermarks(state, crtc))
+ 			if (new_crtc_state->update_wm_pre)
+ 				intel_update_watermarks(dev_priv);
++>>>>>>> 02a1a6351e43 (drm/i915/wm: provide wrappers around watermark vfuncs calls (v3))
  	}
  
  	/*
@@@ -5364,9 -3006,8 +5465,14 @@@ static void ilk_crtc_enable(struct inte
  	/* update DSPCNTR to configure gamma for pipe bottom color */
  	intel_disable_primary_plane(new_crtc_state);
  
++<<<<<<< HEAD
 +	if (dev_priv->display.initial_watermarks)
 +		dev_priv->display.initial_watermarks(state, crtc);
 +	intel_enable_pipe(new_crtc_state);
++=======
+ 	intel_initial_watermarks(state, crtc);
+ 	intel_enable_transcoder(new_crtc_state);
++>>>>>>> 02a1a6351e43 (drm/i915/wm: provide wrappers around watermark vfuncs calls (v3))
  
  	if (new_crtc_state->has_pch_encoder)
  		ilk_pch_enable(state, new_crtc_state);
@@@ -5563,19 -3213,20 +5669,18 @@@ static void hsw_crtc_enable(struct inte
  
  	hsw_set_linetime_wm(new_crtc_state);
  
 -	if (DISPLAY_VER(dev_priv) >= 11)
 -		icl_set_pipe_chicken(new_crtc_state);
 +	if (INTEL_GEN(dev_priv) >= 11)
 +		icl_set_pipe_chicken(crtc);
  
- 	if (dev_priv->display.initial_watermarks)
- 		dev_priv->display.initial_watermarks(state, crtc);
+ 	intel_initial_watermarks(state, crtc);
  
 -	if (DISPLAY_VER(dev_priv) >= 11) {
 -		const struct intel_dbuf_state *dbuf_state =
 -				intel_atomic_get_new_dbuf_state(state);
 +	if (INTEL_GEN(dev_priv) >= 11)
 +		icl_pipe_mbus_enable(crtc);
  
 -		icl_pipe_mbus_enable(crtc, dbuf_state->joined_mbus);
 -	}
 -
 -	if (new_crtc_state->bigjoiner_slave)
 +	if (new_crtc_state->bigjoiner_slave) {
 +		trace_intel_pipe_enable(crtc);
  		intel_crtc_vblank_on(new_crtc_state);
 +	}
  
  	intel_encoders_enable(state, crtc);
  
@@@ -5955,8 -3633,8 +6060,13 @@@ static void valleyview_crtc_enable(stru
  	/* update DSPCNTR to configure gamma for pipe bottom color */
  	intel_disable_primary_plane(new_crtc_state);
  
++<<<<<<< HEAD
 +	dev_priv->display.initial_watermarks(state, crtc);
 +	intel_enable_pipe(new_crtc_state);
++=======
+ 	intel_initial_watermarks(state, crtc);
+ 	intel_enable_transcoder(new_crtc_state);
++>>>>>>> 02a1a6351e43 (drm/i915/wm: provide wrappers around watermark vfuncs calls (v3))
  
  	intel_crtc_vblank_on(new_crtc_state);
  
@@@ -6011,11 -3676,9 +6121,17 @@@ static void i9xx_crtc_enable(struct int
  	/* update DSPCNTR to configure gamma for pipe bottom color */
  	intel_disable_primary_plane(new_crtc_state);
  
++<<<<<<< HEAD
 +	if (dev_priv->display.initial_watermarks)
 +		dev_priv->display.initial_watermarks(state, crtc);
 +	else
 +		intel_update_watermarks(crtc);
 +	intel_enable_pipe(new_crtc_state);
++=======
+ 	if (!intel_initial_watermarks(state, crtc))
+ 		intel_update_watermarks(dev_priv);
+ 	intel_enable_transcoder(new_crtc_state);
++>>>>>>> 02a1a6351e43 (drm/i915/wm: provide wrappers around watermark vfuncs calls (v3))
  
  	intel_crtc_vblank_on(new_crtc_state);
  
@@@ -9988,35 -6855,26 +10104,26 @@@ static int intel_crtc_atomic_check(stru
  			return ret;
  	}
  
- 	if (dev_priv->display.compute_pipe_wm) {
- 		ret = dev_priv->display.compute_pipe_wm(state, crtc);
- 		if (ret) {
- 			drm_dbg_kms(&dev_priv->drm,
- 				    "Target pipe watermarks are invalid\n");
- 			return ret;
- 		}
- 
+ 	ret = intel_compute_pipe_wm(state, crtc);
+ 	if (ret) {
+ 		drm_dbg_kms(&dev_priv->drm,
+ 			    "Target pipe watermarks are invalid\n");
+ 		return ret;
  	}
  
- 	if (dev_priv->display.compute_intermediate_wm) {
- 		if (drm_WARN_ON(&dev_priv->drm,
- 				!dev_priv->display.compute_pipe_wm))
- 			return 0;
- 
- 		/*
- 		 * Calculate 'intermediate' watermarks that satisfy both the
- 		 * old state and the new state.  We can program these
- 		 * immediately.
- 		 */
- 		ret = dev_priv->display.compute_intermediate_wm(state, crtc);
- 		if (ret) {
- 			drm_dbg_kms(&dev_priv->drm,
- 				    "No valid intermediate pipe watermarks are possible\n");
- 			return ret;
- 		}
+ 	/*
+ 	 * Calculate 'intermediate' watermarks that satisfy both the
+ 	 * old state and the new state.  We can program these
+ 	 * immediately.
+ 	 */
+ 	ret = intel_compute_intermediate_wm(state, crtc);
+ 	if (ret) {
+ 		drm_dbg_kms(&dev_priv->drm,
+ 			    "No valid intermediate pipe watermarks are possible\n");
+ 		return ret;
  	}
  
 -	if (DISPLAY_VER(dev_priv) >= 9) {
 +	if (INTEL_GEN(dev_priv) >= 9) {
  		if (mode_changed || crtc_state->update_pipe) {
  			ret = skl_update_scaler_crtc(crtc_state);
  			if (ret)
@@@ -12844,14 -9780,30 +12934,13 @@@ static void commit_pipe_config(struct i
  
  		if (new_crtc_state->update_pipe)
  			intel_pipe_fastset(old_crtc_state, new_crtc_state);
 -	}
  
 -	intel_psr2_program_trans_man_trk_ctl(new_crtc_state);
 +		intel_psr2_program_trans_man_trk_ctl(new_crtc_state);
 +	}
  
- 	if (dev_priv->display.atomic_update_watermarks)
- 		dev_priv->display.atomic_update_watermarks(state, crtc);
+ 	intel_atomic_update_watermarks(state, crtc);
  }
  
 -static void commit_pipe_post_planes(struct intel_atomic_state *state,
 -				    struct intel_crtc *crtc)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
 -	const struct intel_crtc_state *new_crtc_state =
 -		intel_atomic_get_new_crtc_state(state, crtc);
 -
 -	/*
 -	 * Disable the scaler(s) after the plane(s) so that we don't
 -	 * get a catastrophic underrun even if the two operations
 -	 * end up happening in two different frames.
 -	 */
 -	if (DISPLAY_VER(dev_priv) >= 9 &&
 -	    !intel_crtc_needs_modeset(new_crtc_state))
 -		skl_detach_scalers(new_crtc_state);
 -}
 -
  static void intel_enable_crtc(struct intel_atomic_state *state,
  			      struct intel_crtc *crtc)
  {
@@@ -13381,11 -10332,10 +13469,10 @@@ static void intel_atomic_commit_tail(st
  		 * chance of catching underruns with the intermediate watermarks
  		 * vs. the new plane configuration.
  		 */
 -		if (DISPLAY_VER(dev_priv) == 2 && planes_enabling(old_crtc_state, new_crtc_state))
 +		if (IS_GEN(dev_priv, 2) && planes_enabling(old_crtc_state, new_crtc_state))
  			intel_set_cpu_fifo_underrun_reporting(dev_priv, crtc->pipe, true);
  
- 		if (dev_priv->display.optimize_watermarks)
- 			dev_priv->display.optimize_watermarks(state, crtc);
+ 		intel_optimize_watermarks(state, crtc);
  	}
  
  	intel_dbuf_post_plane_update(state);
diff --cc drivers/gpu/drm/i915/intel_pm.c
index 7f3ec682595b,11c9df62391d..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -6727,47 -7130,6 +6727,50 @@@ void ilk_wm_get_hw_state(struct drm_i91
  		!(intel_uncore_read(&dev_priv->uncore, DISP_ARB_CTL) & DISP_FBC_WM_DIS);
  }
  
++<<<<<<< HEAD
 +/**
 + * intel_update_watermarks - update FIFO watermark values based on current modes
 + * @crtc: the #intel_crtc on which to compute the WM
 + *
 + * Calculate watermark values for the various WM regs based on current mode
 + * and plane configuration.
 + *
 + * There are several cases to deal with here:
 + *   - normal (i.e. non-self-refresh)
 + *   - self-refresh (SR) mode
 + *   - lines are large relative to FIFO size (buffer can hold up to 2)
 + *   - lines are small relative to FIFO size (buffer can hold more than 2
 + *     lines), so need to account for TLB latency
 + *
 + *   The normal calculation is:
 + *     watermark = dotclock * bytes per pixel * latency
 + *   where latency is platform & configuration dependent (we assume pessimal
 + *   values here).
 + *
 + *   The SR calculation is:
 + *     watermark = (trunc(latency/line time)+1) * surface width *
 + *       bytes per pixel
 + *   where
 + *     line time = htotal / dotclock
 + *     surface width = hdisplay for normal plane and 64 for cursor
 + *   and latency is assumed to be high, as above.
 + *
 + * The final value programmed to the register should always be rounded up,
 + * and include an extra 2 entries to account for clock crossings.
 + *
 + * We don't use the sprite, so we can ignore that.  And on Crestline we have
 + * to set the non-SR watermarks to 8.
 + */
 +void intel_update_watermarks(struct intel_crtc *crtc)
 +{
 +	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 +
 +	if (dev_priv->display.update_wm)
 +		dev_priv->display.update_wm(crtc);
 +}
 +
++=======
++>>>>>>> 02a1a6351e43 (drm/i915/wm: provide wrappers around watermark vfuncs calls (v3))
  void intel_enable_ipc(struct drm_i915_private *dev_priv)
  {
  	u32 val;
diff --cc drivers/gpu/drm/i915/intel_pm.h
index 97550cf0b6df,990cdcaf85ce..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.h
+++ b/drivers/gpu/drm/i915/intel_pm.h
@@@ -29,7 -29,6 +29,10 @@@ struct skl_wm_level
  void intel_init_clock_gating(struct drm_i915_private *dev_priv);
  void intel_suspend_hw(struct drm_i915_private *dev_priv);
  int ilk_wm_max_level(const struct drm_i915_private *dev_priv);
++<<<<<<< HEAD
 +void intel_update_watermarks(struct intel_crtc *crtc);
++=======
++>>>>>>> 02a1a6351e43 (drm/i915/wm: provide wrappers around watermark vfuncs calls (v3))
  void intel_init_pm(struct drm_i915_private *dev_priv);
  void intel_init_clock_gating_hooks(struct drm_i915_private *dev_priv);
  void intel_pm_setup(struct drm_i915_private *dev_priv);
* Unmerged path drivers/gpu/drm/i915/display/intel_display.c
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
* Unmerged path drivers/gpu/drm/i915/intel_pm.h
