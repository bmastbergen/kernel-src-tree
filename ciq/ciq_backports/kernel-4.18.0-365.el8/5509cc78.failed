x86/fpu/signal: Use fpstate for size and features

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 5509cc78080d29b23706dbf076d51691b69f3c79
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/5509cc78.failed

For dynamically enabled features it's required to get the features which
are enabled for that context when restoring from sigframe.

The same applies for all signal frame size calculations.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/87ilxz5iew.ffs@tglx
(cherry picked from commit 5509cc78080d29b23706dbf076d51691b69f3c79)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/fpu/signal.c
diff --cc arch/x86/kernel/fpu/signal.c
index f74c29985497,f9af1747be6e..000000000000
--- a/arch/x86/kernel/fpu/signal.c
+++ b/arch/x86/kernel/fpu/signal.c
@@@ -88,14 -90,16 +88,19 @@@ static inline int save_fsave_header(str
  	} else {
  		struct fregs_state __user *fp = buf;
  		u32 swd;
 -
  		if (__get_user(swd, &fp->swd) || __put_user(swd, &fp->status))
 -			return false;
 +			return -1;
  	}
  
 -	return true;
 +	return 0;
  }
  
++<<<<<<< HEAD
 +static inline int save_xstate_epilog(void __user *buf, int ia32_frame)
++=======
+ static inline bool save_xstate_epilog(void __user *buf, int ia32_frame,
+ 				      unsigned int usize)
++>>>>>>> 5509cc78080d (x86/fpu/signal: Use fpstate for size and features)
  {
  	struct xregs_state __user *x = buf;
  	struct _fpx_sw_bytes *sw_bytes;
@@@ -165,9 -169,10 +170,10 @@@ static inline int copy_fpregs_to_sigfra
   * For [f]xsave state, update the SW reserved fields in the [f]xsave frame
   * indicating the absence/presence of the extended state to the user.
   */
 -bool copy_fpstate_to_sigframe(void __user *buf, void __user *buf_fx, int size)
 +int copy_fpstate_to_sigframe(void __user *buf, void __user *buf_fx, int size)
  {
  	struct task_struct *tsk = current;
+ 	struct fpstate *fpstate = tsk->thread.fpu.fpstate;
  	int ia32_fxstate = (buf != buf_fx);
  	int ret;
  
@@@ -212,26 -217,27 +218,32 @@@ retry
  	fpregs_unlock();
  
  	if (ret) {
- 		if (!__clear_user(buf_fx, fpu_user_xstate_size))
+ 		if (!__clear_user(buf_fx, fpstate->user_size))
  			goto retry;
 -		return false;
 +		return -1;
  	}
  
  	/* Save the fsave header for the 32-bit frames. */
 -	if ((ia32_fxstate || !use_fxsr()) && !save_fsave_header(tsk, buf))
 -		return false;
 +	if ((ia32_fxstate || !use_fxsr()) && save_fsave_header(tsk, buf))
 +		return -1;
  
++<<<<<<< HEAD
 +	if (use_fxsr() && save_xstate_epilog(buf_fx, ia32_fxstate))
 +		return -1;
++=======
+ 	if (use_fxsr() &&
+ 	    !save_xstate_epilog(buf_fx, ia32_fxstate, fpstate->user_size))
+ 		return false;
++>>>>>>> 5509cc78080d (x86/fpu/signal: Use fpstate for size and features)
  
 -	return true;
 +	return 0;
  }
  
- static int __restore_fpregs_from_user(void __user *buf, u64 xrestore,
- 				      bool fx_only)
+ static int __restore_fpregs_from_user(void __user *buf, u64 ufeatures,
+ 				      u64 xrestore, bool fx_only)
  {
  	if (use_xsave()) {
- 		u64 init_bv = xfeatures_mask_uabi() & ~xrestore;
+ 		u64 init_bv = ufeatures & ~xrestore;
  		int ret;
  
  		if (likely(!fx_only))
@@@ -331,6 -336,7 +344,10 @@@ static int __fpu_restore_sig(void __use
  		user_xfeatures = fx_sw_user.xfeatures;
  	} else {
  		user_xfeatures = XFEATURE_MASK_FPSSE;
++<<<<<<< HEAD
++=======
+ 		state_size = fpu->fpstate->user_size;
++>>>>>>> 5509cc78080d (x86/fpu/signal: Use fpstate for size and features)
  	}
  
  	if (likely(!ia32_fxstate)) {
@@@ -421,12 -426,14 +438,18 @@@
  		fpregs_mark_activate();
  
  	fpregs_unlock();
 -	return success;
 +	return ret;
  }
++<<<<<<< HEAD
 +static inline int xstate_sigframe_size(void)
++=======
+ 
+ static inline unsigned int xstate_sigframe_size(struct fpstate *fpstate)
++>>>>>>> 5509cc78080d (x86/fpu/signal: Use fpstate for size and features)
  {
- 	return use_xsave() ? fpu_user_xstate_size + FP_XSTATE_MAGIC2_SIZE :
- 			fpu_user_xstate_size;
+ 	unsigned int size = fpstate->user_size;
+ 
+ 	return use_xsave() ? size + FP_XSTATE_MAGIC2_SIZE : size;
  }
  
  /*
* Unmerged path arch/x86/kernel/fpu/signal.c
