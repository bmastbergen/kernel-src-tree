drm/i915/display: Fix glitches when moving cursor with PSR2 selective fetch enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author José Roberto de Souza <jose.souza@intel.com>
commit ef39826c12b409010b8fb29fc47e2586cd2635ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/ef39826c.failed

Legacy cursor APIs are handled by intel_legacy_cursor_update(), that
calls drm_atomic_helper_update_plane() when going through the
slow/atomic path to update cursor, what was the case for PSR2
selective fetch.

drm_atomic_helper_update_plane() sets
drm_atomic_state->legacy_cursor_update to true when updating the
cursor plane, to allow several cursor updates to happen within the
same frame, as userspace does that.
If drivers waited for a vblank increment at the end of every cursor
movement that would cause a visible lag in the cursor.

But this optimization do not properly work with PSR2 selective fetch
dirt area calculation, for example if within a single frame the cursor
had 3 moves the final dirt area programmed to PSR2_MAN_TRK_CTL would
be based in the second movement as old state and third movement as new
state, not updating the area where cursor was in the first state.

So here switching back to the fast path approach in
intel_legacy_cursor_update() and handling cursor movements as
frontbuffer rendering(psr_force_hw_tracking_exit()), that is not the
most optimal for power-savings but is the solution that we have until
mailbox style updates is implemented.

Also removing the cursor workaround as not it is properly undestand
the issue and is know that it will never cover all the cases.

	Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
	Cc: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
	Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
	Acked-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
	Reviewed-by: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210930001409.254817-5-jose.souza@intel.com
(cherry picked from commit ef39826c12b409010b8fb29fc47e2586cd2635ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_fbc.c
#	drivers/gpu/drm/i915/display/intel_psr.c
diff --cc drivers/gpu/drm/i915/display/intel_fbc.c
index 5fd4fa4805ef,1f66de77a6b1..000000000000
--- a/drivers/gpu/drm/i915/display/intel_fbc.c
+++ b/drivers/gpu/drm/i915/display/intel_fbc.c
@@@ -1134,7 -1200,7 +1134,11 @@@ void intel_fbc_invalidate(struct drm_i9
  	if (!HAS_FBC(dev_priv))
  		return;
  
++<<<<<<< HEAD
 +	if (origin == ORIGIN_GTT || origin == ORIGIN_FLIP)
++=======
+ 	if (origin == ORIGIN_FLIP || origin == ORIGIN_CURSOR_UPDATE)
++>>>>>>> ef39826c12b4 (drm/i915/display: Fix glitches when moving cursor with PSR2 selective fetch enabled)
  		return;
  
  	mutex_lock(&fbc->lock);
diff --cc drivers/gpu/drm/i915/display/intel_psr.c
index 2c6c4a4f9477,eddf4138b6a8..000000000000
--- a/drivers/gpu/drm/i915/display/intel_psr.c
+++ b/drivers/gpu/drm/i915/display/intel_psr.c
@@@ -1309,6 -1548,59 +1309,62 @@@ static void clip_area_update(struct drm
  		overlap_damage_area->y2 = damage_area->y2;
  }
  
++<<<<<<< HEAD
++=======
+ static void intel_psr2_sel_fetch_pipe_alignment(const struct intel_crtc_state *crtc_state,
+ 						struct drm_rect *pipe_clip)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);
+ 	const u16 y_alignment = crtc_state->su_y_granularity;
+ 
+ 	pipe_clip->y1 -= pipe_clip->y1 % y_alignment;
+ 	if (pipe_clip->y2 % y_alignment)
+ 		pipe_clip->y2 = ((pipe_clip->y2 / y_alignment) + 1) * y_alignment;
+ 
+ 	if (IS_ALDERLAKE_P(dev_priv) && crtc_state->dsc.compression_enable)
+ 		drm_warn(&dev_priv->drm, "Missing PSR2 sel fetch alignment with DSC\n");
+ }
+ 
+ /*
+  * TODO: Not clear how to handle planes with negative position,
+  * also planes are not updated if they have a negative X
+  * position so for now doing a full update in this cases
+  *
+  * TODO: We are missing multi-planar formats handling, until it is
+  * implemented it will send full frame updates.
+  *
+  * Plane scaling and rotation is not supported by selective fetch and both
+  * properties can change without a modeset, so need to be check at every
+  * atomic commmit.
+  */
+ static bool psr2_sel_fetch_plane_state_supported(const struct intel_plane_state *plane_state)
+ {
+ 	if (plane_state->uapi.dst.y1 < 0 ||
+ 	    plane_state->uapi.dst.x1 < 0 ||
+ 	    plane_state->scaler_id >= 0 ||
+ 	    plane_state->hw.fb->format->num_planes > 1 ||
+ 	    plane_state->uapi.rotation != DRM_MODE_ROTATE_0)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ /*
+  * Check for pipe properties that is not supported by selective fetch.
+  *
+  * TODO: pipe scaling causes a modeset but skl_update_scaler_crtc() is executed
+  * after intel_psr_compute_config(), so for now keeping PSR2 selective fetch
+  * enabled and going to the full update path.
+  */
+ static bool psr2_sel_fetch_pipe_state_supported(const struct intel_crtc_state *crtc_state)
+ {
+ 	if (crtc_state->scaler_state.scaler_id >= 0)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
++>>>>>>> ef39826c12b4 (drm/i915/display: Fix glitches when moving cursor with PSR2 selective fetch enabled)
  int intel_psr2_sel_fetch_update(struct intel_atomic_state *state,
  				struct intel_crtc *crtc)
  {
@@@ -1753,31 -2099,24 +1809,49 @@@ void intel_psr_invalidate(struct drm_i9
   * accordingly in future.
   */
  static void
++<<<<<<< HEAD
 +tgl_dc3co_flush(struct drm_i915_private *dev_priv,
 +		unsigned int frontbuffer_bits, enum fb_op_origin origin)
 +{
 +	mutex_lock(&dev_priv->psr.lock);
 +
 +	if (!dev_priv->psr.dc3co_enabled)
 +		goto unlock;
 +
 +	if (!dev_priv->psr.psr2_enabled || !dev_priv->psr.active)
 +		goto unlock;
++=======
+ tgl_dc3co_flush_locked(struct intel_dp *intel_dp, unsigned int frontbuffer_bits,
+ 		       enum fb_op_origin origin)
+ {
+ 	if (!intel_dp->psr.dc3co_exitline || !intel_dp->psr.psr2_enabled ||
+ 	    !intel_dp->psr.active)
+ 		return;
++>>>>>>> ef39826c12b4 (drm/i915/display: Fix glitches when moving cursor with PSR2 selective fetch enabled)
  
  	/*
  	 * At every frontbuffer flush flip event modified delay of delayed work,
  	 * when delayed work schedules that means display has been idle.
  	 */
  	if (!(frontbuffer_bits &
++<<<<<<< HEAD
 +	    INTEL_FRONTBUFFER_ALL_MASK(dev_priv->psr.pipe)))
 +		goto unlock;
 +
 +	tgl_psr2_enable_dc3co(dev_priv);
 +	mod_delayed_work(system_wq, &dev_priv->psr.dc3co_work,
 +			 dev_priv->psr.dc3co_exit_delay);
 +
 +unlock:
 +	mutex_unlock(&dev_priv->psr.lock);
++=======
+ 	    INTEL_FRONTBUFFER_ALL_MASK(intel_dp->psr.pipe)))
+ 		return;
+ 
+ 	tgl_psr2_enable_dc3co(intel_dp);
+ 	mod_delayed_work(system_wq, &intel_dp->psr.dc3co_work,
+ 			 intel_dp->psr.dc3co_exit_delay);
++>>>>>>> ef39826c12b4 (drm/i915/display: Fix glitches when moving cursor with PSR2 selective fetch enabled)
  }
  
  /**
@@@ -1796,30 -2135,48 +1870,72 @@@
  void intel_psr_flush(struct drm_i915_private *dev_priv,
  		     unsigned frontbuffer_bits, enum fb_op_origin origin)
  {
 -	struct intel_encoder *encoder;
 +	if (!CAN_PSR(dev_priv))
 +		return;
  
++<<<<<<< HEAD
 +	if (origin == ORIGIN_FLIP) {
 +		tgl_dc3co_flush(dev_priv, frontbuffer_bits, origin);
 +		return;
++=======
+ 	for_each_intel_encoder_with_psr(&dev_priv->drm, encoder) {
+ 		unsigned int pipe_frontbuffer_bits = frontbuffer_bits;
+ 		struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
+ 
+ 		mutex_lock(&intel_dp->psr.lock);
+ 		if (!intel_dp->psr.enabled) {
+ 			mutex_unlock(&intel_dp->psr.lock);
+ 			continue;
+ 		}
+ 
+ 		pipe_frontbuffer_bits &=
+ 			INTEL_FRONTBUFFER_ALL_MASK(intel_dp->psr.pipe);
+ 		intel_dp->psr.busy_frontbuffer_bits &= ~pipe_frontbuffer_bits;
+ 
+ 		/*
+ 		 * If the PSR is paused by an explicit intel_psr_paused() call,
+ 		 * we have to ensure that the PSR is not activated until
+ 		 * intel_psr_resume() is called.
+ 		 */
+ 		if (intel_dp->psr.paused) {
+ 			mutex_unlock(&intel_dp->psr.lock);
+ 			continue;
+ 		}
+ 
+ 		if (origin == ORIGIN_FLIP ||
+ 		    (origin == ORIGIN_CURSOR_UPDATE &&
+ 		     !intel_dp->psr.psr2_sel_fetch_enabled)) {
+ 			tgl_dc3co_flush_locked(intel_dp, frontbuffer_bits, origin);
+ 			mutex_unlock(&intel_dp->psr.lock);
+ 			continue;
+ 		}
+ 
+ 		/* By definition flush = invalidate + flush */
+ 		if (pipe_frontbuffer_bits)
+ 			psr_force_hw_tracking_exit(intel_dp);
+ 
+ 		if (!intel_dp->psr.active && !intel_dp->psr.busy_frontbuffer_bits)
+ 			schedule_work(&intel_dp->psr.work);
+ 		mutex_unlock(&intel_dp->psr.lock);
++>>>>>>> ef39826c12b4 (drm/i915/display: Fix glitches when moving cursor with PSR2 selective fetch enabled)
  	}
 +
 +	mutex_lock(&dev_priv->psr.lock);
 +	if (!dev_priv->psr.enabled) {
 +		mutex_unlock(&dev_priv->psr.lock);
 +		return;
 +	}
 +
 +	frontbuffer_bits &= INTEL_FRONTBUFFER_ALL_MASK(dev_priv->psr.pipe);
 +	dev_priv->psr.busy_frontbuffer_bits &= ~frontbuffer_bits;
 +
 +	/* By definition flush = invalidate + flush */
 +	if (frontbuffer_bits)
 +		psr_force_hw_tracking_exit(dev_priv);
 +
 +	if (!dev_priv->psr.active && !dev_priv->psr.busy_frontbuffer_bits)
 +		schedule_work(&dev_priv->psr.work);
 +	mutex_unlock(&dev_priv->psr.lock);
  }
  
  /**
diff --git a/drivers/gpu/drm/i915/display/intel_cursor.c b/drivers/gpu/drm/i915/display/intel_cursor.c
index 21fe4d2753e9..bebc6d7cdcb9 100644
--- a/drivers/gpu/drm/i915/display/intel_cursor.c
+++ b/drivers/gpu/drm/i915/display/intel_cursor.c
@@ -686,7 +686,7 @@ intel_legacy_cursor_update(struct drm_plane *_plane,
 		goto out_free;
 
 	intel_frontbuffer_flush(to_intel_frontbuffer(new_plane_state->hw.fb),
-				ORIGIN_FLIP);
+				ORIGIN_CURSOR_UPDATE);
 	intel_frontbuffer_track(to_intel_frontbuffer(old_plane_state->hw.fb),
 				to_intel_frontbuffer(new_plane_state->hw.fb),
 				plane->frontbuffer_bit);
* Unmerged path drivers/gpu/drm/i915/display/intel_fbc.c
diff --git a/drivers/gpu/drm/i915/display/intel_frontbuffer.h b/drivers/gpu/drm/i915/display/intel_frontbuffer.h
index 6d41f5394425..608e0cefece7 100644
--- a/drivers/gpu/drm/i915/display/intel_frontbuffer.h
+++ b/drivers/gpu/drm/i915/display/intel_frontbuffer.h
@@ -38,6 +38,7 @@ enum fb_op_origin {
 	ORIGIN_CS,
 	ORIGIN_FLIP,
 	ORIGIN_DIRTYFB,
+	ORIGIN_CURSOR_UPDATE,
 };
 
 struct intel_frontbuffer {
* Unmerged path drivers/gpu/drm/i915/display/intel_psr.c
