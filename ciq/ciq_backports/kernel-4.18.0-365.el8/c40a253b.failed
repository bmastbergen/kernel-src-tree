drm/i915: Introduce encoder->get_buf_trans()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit c40a253b719af14fb2c62be72ef7368bd0f8298d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/c40a253b.failed

Convert the get_buf_trans() functions into an encoder vfunc.
Allows us to get rid of bunch of platform if-ladders.

v2: Handle adl-p

	Reviewed-by: Jani Nikula <jani.nikula@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210608073603.2408-10-ville.syrjala@linux.intel.com
(cherry picked from commit c40a253b719af14fb2c62be72ef7368bd0f8298d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_crt.c
#	drivers/gpu/drm/i915/display/intel_ddi.c
#	drivers/gpu/drm/i915/display/intel_ddi_buf_trans.c
#	drivers/gpu/drm/i915/display/intel_ddi_buf_trans.h
#	drivers/gpu/drm/i915/display/intel_display_types.h
#	drivers/gpu/drm/i915/display/intel_fdi.c
diff --cc drivers/gpu/drm/i915/display/intel_crt.c
index f1964b066052,408f82b0dc7d..000000000000
--- a/drivers/gpu/drm/i915/display/intel_crt.c
+++ b/drivers/gpu/drm/i915/display/intel_crt.c
@@@ -36,8 -36,12 +36,13 @@@
  #include "i915_drv.h"
  #include "intel_connector.h"
  #include "intel_crt.h"
 -#include "intel_crtc.h"
  #include "intel_ddi.h"
++<<<<<<< HEAD
++=======
+ #include "intel_ddi_buf_trans.h"
+ #include "intel_de.h"
++>>>>>>> c40a253b719a (drm/i915: Introduce encoder->get_buf_trans())
  #include "intel_display_types.h"
 -#include "intel_fdi.h"
  #include "intel_fifo_underrun.h"
  #include "intel_gmbus.h"
  #include "intel_hotplug.h"
@@@ -1077,6 -1081,9 +1082,12 @@@ void intel_crt_init(struct drm_i915_pri
  		crt->base.post_disable = hsw_post_disable_crt;
  		crt->base.enable_clock = hsw_ddi_enable_clock;
  		crt->base.disable_clock = hsw_ddi_disable_clock;
++<<<<<<< HEAD
++=======
+ 		crt->base.is_clock_enabled = hsw_ddi_is_clock_enabled;
+ 
+ 		intel_ddi_buf_trans_init(&crt->base);
++>>>>>>> c40a253b719a (drm/i915: Introduce encoder->get_buf_trans())
  	} else {
  		if (HAS_PCH_SPLIT(dev_priv)) {
  			crt->base.compute_config = pch_crt_compute_config;
diff --cc drivers/gpu/drm/i915/display/intel_ddi.c
index 0f72647ed48c,59acfc20a42c..000000000000
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@@ -1571,20 -102,15 +1571,26 @@@ static void intel_prepare_dp_ddi_buffer
  	u32 iboost_bit = 0;
  	int i, n_entries;
  	enum port port = encoder->port;
 -	const struct intel_ddi_buf_trans *ddi_translations;
 -
 +	const struct ddi_buf_trans *ddi_translations;
 +
++<<<<<<< HEAD
 +	if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_ANALOG))
 +		ddi_translations = intel_ddi_get_buf_trans_fdi(dev_priv,
 +							       &n_entries);
 +	else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
 +		ddi_translations = intel_ddi_get_buf_trans_edp(encoder,
 +							       &n_entries);
 +	else
 +		ddi_translations = intel_ddi_get_buf_trans_dp(encoder,
 +							      &n_entries);
++=======
+ 	ddi_translations = encoder->get_buf_trans(encoder, crtc_state, &n_entries);
+ 	if (drm_WARN_ON_ONCE(&dev_priv->drm, !ddi_translations))
+ 		return;
++>>>>>>> c40a253b719a (drm/i915: Introduce encoder->get_buf_trans())
  
  	/* If we're boosting the current, set bit 31 of trans1 */
 -	if (DISPLAY_VER(dev_priv) == 9 && !IS_BROXTON(dev_priv) &&
 -	    intel_bios_encoder_dp_boost_level(encoder->devdata))
 +	if (IS_GEN9_BC(dev_priv) && intel_bios_dp_boost_level(encoder))
  		iboost_bit = DDI_BUF_BALANCE_LEG_ENABLE;
  
  	for (i = 0; i < n_entries; i++) {
@@@ -1607,10 -134,9 +1613,14 @@@ static void intel_prepare_hdmi_ddi_buff
  	u32 iboost_bit = 0;
  	int n_entries;
  	enum port port = encoder->port;
 -	const struct intel_ddi_buf_trans *ddi_translations;
 +	const struct ddi_buf_trans *ddi_translations;
 +
++<<<<<<< HEAD
 +	ddi_translations = intel_ddi_get_buf_trans_hdmi(encoder, &n_entries);
  
++=======
+ 	ddi_translations = encoder->get_buf_trans(encoder, crtc_state, &n_entries);
++>>>>>>> c40a253b719a (drm/i915: Introduce encoder->get_buf_trans())
  	if (drm_WARN_ON_ONCE(&dev_priv->drm, !ddi_translations))
  		return;
  	if (drm_WARN_ON_ONCE(&dev_priv->drm, level >= n_entries))
@@@ -2529,21 -937,15 +2539,25 @@@ static void skl_ddi_set_iboost(struct i
  	u8 iboost;
  
  	if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))
 -		iboost = intel_bios_encoder_hdmi_boost_level(encoder->devdata);
 +		iboost = intel_bios_hdmi_boost_level(encoder);
  	else
 -		iboost = intel_bios_encoder_dp_boost_level(encoder->devdata);
 +		iboost = intel_bios_dp_boost_level(encoder);
  
  	if (iboost == 0) {
 -		const struct intel_ddi_buf_trans *ddi_translations;
 +		const struct ddi_buf_trans *ddi_translations;
  		int n_entries;
  
++<<<<<<< HEAD
 +		if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))
 +			ddi_translations = intel_ddi_get_buf_trans_hdmi(encoder, &n_entries);
 +		else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
 +			ddi_translations = intel_ddi_get_buf_trans_edp(encoder, &n_entries);
 +		else
 +			ddi_translations = intel_ddi_get_buf_trans_dp(encoder, &n_entries);
 +
++=======
+ 		ddi_translations = encoder->get_buf_trans(encoder, crtc_state, &n_entries);
++>>>>>>> c40a253b719a (drm/i915: Introduce encoder->get_buf_trans())
  		if (drm_WARN_ON_ONCE(&dev_priv->drm, !ddi_translations))
  			return;
  		if (drm_WARN_ON_ONCE(&dev_priv->drm, level >= n_entries))
@@@ -2573,13 -975,7 +2587,17 @@@ static void bxt_ddi_vswing_sequence(str
  	enum port port = encoder->port;
  	int n_entries;
  
++<<<<<<< HEAD
 +	if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))
 +		ddi_translations = bxt_get_buf_trans_hdmi(encoder, &n_entries);
 +	else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
 +		ddi_translations = bxt_get_buf_trans_edp(encoder, &n_entries);
 +	else
 +		ddi_translations = bxt_get_buf_trans_dp(encoder, &n_entries);
 +
++=======
+ 	ddi_translations = encoder->get_buf_trans(encoder, crtc_state, &n_entries);
++>>>>>>> c40a253b719a (drm/i915: Introduce encoder->get_buf_trans())
  	if (drm_WARN_ON_ONCE(&dev_priv->drm, !ddi_translations))
  		return;
  	if (drm_WARN_ON_ONCE(&dev_priv->drm, level >= n_entries))
@@@ -2597,42 -993,9 +2615,44 @@@ static u8 intel_ddi_dp_voltage_max(stru
  {
  	struct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;
  	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
- 	enum port port = encoder->port;
- 	enum phy phy = intel_port_to_phy(dev_priv, port);
  	int n_entries;
  
++<<<<<<< HEAD
 +	if (IS_ALDERLAKE_S(dev_priv)) {
 +		adls_get_combo_buf_trans(encoder, crtc_state, &n_entries);
 +	} else if (INTEL_GEN(dev_priv) >= 12) {
 +		if (intel_phy_is_combo(dev_priv, phy))
 +			tgl_get_combo_buf_trans(encoder, crtc_state, &n_entries);
 +		else
 +			tgl_get_dkl_buf_trans(encoder, crtc_state, &n_entries);
 +	} else if (INTEL_GEN(dev_priv) == 11) {
 +		if (IS_PLATFORM(dev_priv, INTEL_JASPERLAKE))
 +			jsl_get_combo_buf_trans(encoder, crtc_state, &n_entries);
 +		else if (IS_PLATFORM(dev_priv, INTEL_ELKHARTLAKE))
 +			ehl_get_combo_buf_trans(encoder, crtc_state, &n_entries);
 +		else if (intel_phy_is_combo(dev_priv, phy))
 +			icl_get_combo_buf_trans(encoder, crtc_state, &n_entries);
 +		else
 +			icl_get_mg_buf_trans(encoder, crtc_state, &n_entries);
 +	} else if (IS_CANNONLAKE(dev_priv)) {
 +		if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
 +			cnl_get_buf_trans_edp(encoder, &n_entries);
 +		else
 +			cnl_get_buf_trans_dp(encoder, &n_entries);
 +	} else if (IS_GEN9_LP(dev_priv)) {
 +		if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
 +			bxt_get_buf_trans_edp(encoder, &n_entries);
 +		else
 +			bxt_get_buf_trans_dp(encoder, &n_entries);
 +	} else {
 +		if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
 +			intel_ddi_get_buf_trans_edp(encoder, &n_entries);
 +		else
 +			intel_ddi_get_buf_trans_dp(encoder, &n_entries);
 +	}
++=======
+ 	encoder->get_buf_trans(encoder, crtc_state, &n_entries);
++>>>>>>> c40a253b719a (drm/i915: Introduce encoder->get_buf_trans())
  
  	if (drm_WARN_ON(&dev_priv->drm, n_entries < 1))
  		n_entries = 1;
@@@ -2664,13 -1027,7 +2684,17 @@@ static void cnl_ddi_vswing_program(stru
  	int n_entries, ln;
  	u32 val;
  
++<<<<<<< HEAD
 +	if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))
 +		ddi_translations = cnl_get_buf_trans_hdmi(encoder, &n_entries);
 +	else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
 +		ddi_translations = cnl_get_buf_trans_edp(encoder, &n_entries);
 +	else
 +		ddi_translations = cnl_get_buf_trans_dp(encoder, &n_entries);
 +
++=======
+ 	ddi_translations = encoder->get_buf_trans(encoder, crtc_state, &n_entries);
++>>>>>>> c40a253b719a (drm/i915: Introduce encoder->get_buf_trans())
  	if (drm_WARN_ON_ONCE(&dev_priv->drm, !ddi_translations))
  		return;
  	if (drm_WARN_ON_ONCE(&dev_priv->drm, level >= n_entries))
@@@ -2790,17 -1147,7 +2814,21 @@@ static void icl_ddi_combo_vswing_progra
  	int n_entries, ln;
  	u32 val;
  
++<<<<<<< HEAD
 +	if (IS_ALDERLAKE_S(dev_priv))
 +		ddi_translations = adls_get_combo_buf_trans(encoder, crtc_state, &n_entries);
 +	else if (INTEL_GEN(dev_priv) >= 12)
 +		ddi_translations = tgl_get_combo_buf_trans(encoder, crtc_state, &n_entries);
 +	else if (IS_PLATFORM(dev_priv, INTEL_JASPERLAKE))
 +		ddi_translations = jsl_get_combo_buf_trans(encoder, crtc_state, &n_entries);
 +	else if (IS_PLATFORM(dev_priv, INTEL_ELKHARTLAKE))
 +		ddi_translations = ehl_get_combo_buf_trans(encoder, crtc_state, &n_entries);
 +	else
 +		ddi_translations = icl_get_combo_buf_trans(encoder, crtc_state, &n_entries);
 +
++=======
+ 	ddi_translations = encoder->get_buf_trans(encoder, crtc_state, &n_entries);
++>>>>>>> c40a253b719a (drm/i915: Introduce encoder->get_buf_trans())
  	if (drm_WARN_ON_ONCE(&dev_priv->drm, !ddi_translations))
  		return;
  	if (drm_WARN_ON_ONCE(&dev_priv->drm, level >= n_entries))
@@@ -3065,8 -1411,7 +3092,12 @@@ tgl_dkl_phy_ddi_vswing_sequence(struct 
  	if (enc_to_dig_port(encoder)->tc_mode == TC_PORT_TBT_ALT)
  		return;
  
++<<<<<<< HEAD
 +	ddi_translations = tgl_get_dkl_buf_trans(encoder, crtc_state, &n_entries);
 +
++=======
+ 	ddi_translations = encoder->get_buf_trans(encoder, crtc_state, &n_entries);
++>>>>>>> c40a253b719a (drm/i915: Introduce encoder->get_buf_trans())
  	if (drm_WARN_ON_ONCE(&dev_priv->drm, !ddi_translations))
  		return;
  	if (drm_WARN_ON_ONCE(&dev_priv->drm, level >= n_entries))
@@@ -5727,9 -4646,17 +5758,17 @@@ void intel_ddi_init(struct drm_i915_pri
  	} else if (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv)) {
  		encoder->enable_clock = hsw_ddi_enable_clock;
  		encoder->disable_clock = hsw_ddi_disable_clock;
 -		encoder->is_clock_enabled = hsw_ddi_is_clock_enabled;
 -		encoder->get_config = hsw_ddi_get_config;
  	}
  
++<<<<<<< HEAD
 +	if (IS_DG1(dev_priv))
++=======
+ 	intel_ddi_buf_trans_init(encoder);
+ 
+ 	if (DISPLAY_VER(dev_priv) >= 13)
+ 		encoder->hpd_pin = xelpd_hpd_pin(dev_priv, port);
+ 	else if (IS_DG1(dev_priv))
++>>>>>>> c40a253b719a (drm/i915: Introduce encoder->get_buf_trans())
  		encoder->hpd_pin = dg1_hpd_pin(dev_priv, port);
  	else if (IS_ROCKETLAKE(dev_priv))
  		encoder->hpd_pin = rkl_hpd_pin(dev_priv, port);
diff --cc drivers/gpu/drm/i915/display/intel_display_types.h
index cc8308e725ba,1185834cade3..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@@ -225,6 -260,13 +226,16 @@@ struct intel_encoder 
  	void (*enable_clock)(struct intel_encoder *encoder,
  			     const struct intel_crtc_state *crtc_state);
  	void (*disable_clock)(struct intel_encoder *encoder);
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Returns whether the port clock is enabled or not.
+ 	 */
+ 	bool (*is_clock_enabled)(struct intel_encoder *encoder);
+ 	const struct intel_ddi_buf_trans *(*get_buf_trans)(struct intel_encoder *encoder,
+ 							   const struct intel_crtc_state *crtc_state,
+ 							   int *n_entries);
++>>>>>>> c40a253b719a (drm/i915: Introduce encoder->get_buf_trans())
  	enum hpd_pin hpd_pin;
  	enum intel_display_power_domain power_domain;
  	/* for communication with audio component; protected by av_mutex */
diff --cc drivers/gpu/drm/i915/display/intel_fdi.c
index b2eb96ae10a2,15ea28726e7a..000000000000
--- a/drivers/gpu/drm/i915/display/intel_fdi.c
+++ b/drivers/gpu/drm/i915/display/intel_fdi.c
@@@ -3,6 -3,8 +3,11 @@@
   * Copyright 짤 2020 Intel Corporation
   */
  #include "intel_atomic.h"
++<<<<<<< HEAD
++=======
+ #include "intel_ddi.h"
+ #include "intel_de.h"
++>>>>>>> c40a253b719a (drm/i915: Introduce encoder->get_buf_trans())
  #include "intel_display_types.h"
  #include "intel_fdi.h"
  
@@@ -550,6 -552,142 +555,145 @@@ train_done
  	drm_dbg_kms(&dev_priv->drm, "FDI train done.\n");
  }
  
++<<<<<<< HEAD
++=======
+ /* Starting with Haswell, different DDI ports can work in FDI mode for
+  * connection to the PCH-located connectors. For this, it is necessary to train
+  * both the DDI port and PCH receiver for the desired DDI buffer settings.
+  *
+  * The recommended port to work in FDI mode is DDI E, which we use here. Also,
+  * please note that when FDI mode is active on DDI E, it shares 2 lines with
+  * DDI A (which is used for eDP)
+  */
+ void hsw_fdi_link_train(struct intel_encoder *encoder,
+ 			const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	u32 temp, i, rx_ctl_val;
+ 	int n_entries;
+ 
+ 	encoder->get_buf_trans(encoder, crtc_state, &n_entries);
+ 
+ 	hsw_prepare_dp_ddi_buffers(encoder, crtc_state);
+ 
+ 	/* Set the FDI_RX_MISC pwrdn lanes and the 2 workarounds listed at the
+ 	 * mode set "sequence for CRT port" document:
+ 	 * - TP1 to TP2 time with the default value
+ 	 * - FDI delay to 90h
+ 	 *
+ 	 * WaFDIAutoLinkSetTimingOverrride:hsw
+ 	 */
+ 	intel_de_write(dev_priv, FDI_RX_MISC(PIPE_A),
+ 		       FDI_RX_PWRDN_LANE1_VAL(2) | FDI_RX_PWRDN_LANE0_VAL(2) | FDI_RX_TP1_TO_TP2_48 | FDI_RX_FDI_DELAY_90);
+ 
+ 	/* Enable the PCH Receiver FDI PLL */
+ 	rx_ctl_val = dev_priv->fdi_rx_config | FDI_RX_ENHANCE_FRAME_ENABLE |
+ 		     FDI_RX_PLL_ENABLE |
+ 		     FDI_DP_PORT_WIDTH(crtc_state->fdi_lanes);
+ 	intel_de_write(dev_priv, FDI_RX_CTL(PIPE_A), rx_ctl_val);
+ 	intel_de_posting_read(dev_priv, FDI_RX_CTL(PIPE_A));
+ 	udelay(220);
+ 
+ 	/* Switch from Rawclk to PCDclk */
+ 	rx_ctl_val |= FDI_PCDCLK;
+ 	intel_de_write(dev_priv, FDI_RX_CTL(PIPE_A), rx_ctl_val);
+ 
+ 	/* Configure Port Clock Select */
+ 	drm_WARN_ON(&dev_priv->drm, crtc_state->shared_dpll->info->id != DPLL_ID_SPLL);
+ 	intel_ddi_enable_clock(encoder, crtc_state);
+ 
+ 	/* Start the training iterating through available voltages and emphasis,
+ 	 * testing each value twice. */
+ 	for (i = 0; i < n_entries * 2; i++) {
+ 		/* Configure DP_TP_CTL with auto-training */
+ 		intel_de_write(dev_priv, DP_TP_CTL(PORT_E),
+ 			       DP_TP_CTL_FDI_AUTOTRAIN |
+ 			       DP_TP_CTL_ENHANCED_FRAME_ENABLE |
+ 			       DP_TP_CTL_LINK_TRAIN_PAT1 |
+ 			       DP_TP_CTL_ENABLE);
+ 
+ 		/* Configure and enable DDI_BUF_CTL for DDI E with next voltage.
+ 		 * DDI E does not support port reversal, the functionality is
+ 		 * achieved on the PCH side in FDI_RX_CTL, so no need to set the
+ 		 * port reversal bit */
+ 		intel_de_write(dev_priv, DDI_BUF_CTL(PORT_E),
+ 			       DDI_BUF_CTL_ENABLE | ((crtc_state->fdi_lanes - 1) << 1) | DDI_BUF_TRANS_SELECT(i / 2));
+ 		intel_de_posting_read(dev_priv, DDI_BUF_CTL(PORT_E));
+ 
+ 		udelay(600);
+ 
+ 		/* Program PCH FDI Receiver TU */
+ 		intel_de_write(dev_priv, FDI_RX_TUSIZE1(PIPE_A), TU_SIZE(64));
+ 
+ 		/* Enable PCH FDI Receiver with auto-training */
+ 		rx_ctl_val |= FDI_RX_ENABLE | FDI_LINK_TRAIN_AUTO;
+ 		intel_de_write(dev_priv, FDI_RX_CTL(PIPE_A), rx_ctl_val);
+ 		intel_de_posting_read(dev_priv, FDI_RX_CTL(PIPE_A));
+ 
+ 		/* Wait for FDI receiver lane calibration */
+ 		udelay(30);
+ 
+ 		/* Unset FDI_RX_MISC pwrdn lanes */
+ 		temp = intel_de_read(dev_priv, FDI_RX_MISC(PIPE_A));
+ 		temp &= ~(FDI_RX_PWRDN_LANE1_MASK | FDI_RX_PWRDN_LANE0_MASK);
+ 		intel_de_write(dev_priv, FDI_RX_MISC(PIPE_A), temp);
+ 		intel_de_posting_read(dev_priv, FDI_RX_MISC(PIPE_A));
+ 
+ 		/* Wait for FDI auto training time */
+ 		udelay(5);
+ 
+ 		temp = intel_de_read(dev_priv, DP_TP_STATUS(PORT_E));
+ 		if (temp & DP_TP_STATUS_AUTOTRAIN_DONE) {
+ 			drm_dbg_kms(&dev_priv->drm,
+ 				    "FDI link training done on step %d\n", i);
+ 			break;
+ 		}
+ 
+ 		/*
+ 		 * Leave things enabled even if we failed to train FDI.
+ 		 * Results in less fireworks from the state checker.
+ 		 */
+ 		if (i == n_entries * 2 - 1) {
+ 			drm_err(&dev_priv->drm, "FDI link training failed!\n");
+ 			break;
+ 		}
+ 
+ 		rx_ctl_val &= ~FDI_RX_ENABLE;
+ 		intel_de_write(dev_priv, FDI_RX_CTL(PIPE_A), rx_ctl_val);
+ 		intel_de_posting_read(dev_priv, FDI_RX_CTL(PIPE_A));
+ 
+ 		temp = intel_de_read(dev_priv, DDI_BUF_CTL(PORT_E));
+ 		temp &= ~DDI_BUF_CTL_ENABLE;
+ 		intel_de_write(dev_priv, DDI_BUF_CTL(PORT_E), temp);
+ 		intel_de_posting_read(dev_priv, DDI_BUF_CTL(PORT_E));
+ 
+ 		/* Disable DP_TP_CTL and FDI_RX_CTL and retry */
+ 		temp = intel_de_read(dev_priv, DP_TP_CTL(PORT_E));
+ 		temp &= ~(DP_TP_CTL_ENABLE | DP_TP_CTL_LINK_TRAIN_MASK);
+ 		temp |= DP_TP_CTL_LINK_TRAIN_PAT1;
+ 		intel_de_write(dev_priv, DP_TP_CTL(PORT_E), temp);
+ 		intel_de_posting_read(dev_priv, DP_TP_CTL(PORT_E));
+ 
+ 		intel_wait_ddi_buf_idle(dev_priv, PORT_E);
+ 
+ 		/* Reset FDI_RX_MISC pwrdn lanes */
+ 		temp = intel_de_read(dev_priv, FDI_RX_MISC(PIPE_A));
+ 		temp &= ~(FDI_RX_PWRDN_LANE1_MASK | FDI_RX_PWRDN_LANE0_MASK);
+ 		temp |= FDI_RX_PWRDN_LANE1_VAL(2) | FDI_RX_PWRDN_LANE0_VAL(2);
+ 		intel_de_write(dev_priv, FDI_RX_MISC(PIPE_A), temp);
+ 		intel_de_posting_read(dev_priv, FDI_RX_MISC(PIPE_A));
+ 	}
+ 
+ 	/* Enable normal pixel sending for FDI */
+ 	intel_de_write(dev_priv, DP_TP_CTL(PORT_E),
+ 		       DP_TP_CTL_FDI_AUTOTRAIN |
+ 		       DP_TP_CTL_LINK_TRAIN_NORMAL |
+ 		       DP_TP_CTL_ENHANCED_FRAME_ENABLE |
+ 		       DP_TP_CTL_ENABLE);
+ }
+ 
++>>>>>>> c40a253b719a (drm/i915: Introduce encoder->get_buf_trans())
  void ilk_fdi_pll_enable(const struct intel_crtc_state *crtc_state)
  {
  	struct intel_crtc *intel_crtc = to_intel_crtc(crtc_state->uapi.crtc);
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi_buf_trans.c
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi_buf_trans.h
* Unmerged path drivers/gpu/drm/i915/display/intel_crt.c
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi.c
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi_buf_trans.c
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi_buf_trans.h
* Unmerged path drivers/gpu/drm/i915/display/intel_display_types.h
* Unmerged path drivers/gpu/drm/i915/display/intel_fdi.c
