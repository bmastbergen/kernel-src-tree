powerpc/watchdog: read TB close to where it is used

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Nicholas Piggin <npiggin@gmail.com>
commit 1f01bf90765fa5f88fbae452c131c1edf5cda7ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/1f01bf90.failed

When taking watchdog actions, printing messages, comparing and
re-setting wd_smp_last_reset_tb, etc., read TB close to the point of use
and under wd_smp_lock or printing lock (if applicable).

This should keep timebase mostly monotonic with kernel log messages, and
could prevent (in theory) a laggy CPU updating wd_smp_last_reset_tb to
something a long way in the past, and causing other CPUs to appear to be
stuck.

These additional TB reads are all slowpath (lockup has been detected),
so performance does not matter.

	Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
	Reviewed-by: Laurent Dufour <ldufour@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20211110025056.2084347-5-npiggin@gmail.com

(cherry picked from commit 1f01bf90765fa5f88fbae452c131c1edf5cda7ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/watchdog.c
diff --cc arch/powerpc/kernel/watchdog.c
index ad2f126d0d8d,b6533539386b..000000000000
--- a/arch/powerpc/kernel/watchdog.c
+++ b/arch/powerpc/kernel/watchdog.c
@@@ -146,9 -175,11 +146,10 @@@ static bool set_cpu_stuck(int cpu
  	return false;
  }
  
- static void watchdog_smp_panic(int cpu, u64 tb)
+ static void watchdog_smp_panic(int cpu)
  {
 -	static cpumask_t wd_smp_cpus_ipi; // protected by reporting
  	unsigned long flags;
+ 	u64 tb;
  	int c;
  
  	wd_smp_lock(&flags);
@@@ -157,11 -189,26 +159,29 @@@
  		goto out;
  	if (cpumask_test_cpu(cpu, &wd_smp_cpus_pending))
  		goto out;
 -	if (!wd_try_report())
 +	if (cpumask_weight(&wd_smp_cpus_pending) == 0)
  		goto out;
++<<<<<<< HEAD
++=======
+ 	for_each_online_cpu(c) {
+ 		if (!cpumask_test_cpu(c, &wd_smp_cpus_pending))
+ 			continue;
+ 		if (c == cpu)
+ 			continue; // should not happen
+ 
+ 		__cpumask_set_cpu(c, &wd_smp_cpus_ipi);
+ 		if (set_cpu_stuck(c))
+ 			break;
+ 	}
+ 	if (cpumask_empty(&wd_smp_cpus_ipi)) {
+ 		wd_end_reporting();
+ 		goto out;
+ 	}
+ 	wd_smp_unlock(&flags);
++>>>>>>> 1f01bf90765f (powerpc/watchdog: read TB close to where it is used)
  
  	pr_emerg("CPU %d detected hard LOCKUP on other CPUs %*pbl\n",
 -		 cpu, cpumask_pr_args(&wd_smp_cpus_ipi));
 +		 cpu, cpumask_pr_args(&wd_smp_cpus_pending));
  	pr_emerg("CPU %d TB:%lld, last SMP heartbeat TB:%lld (%lldms ago)\n",
  		 cpu, tb, wd_smp_last_reset_tb,
  		 tb_to_ns(tb - wd_smp_last_reset_tb) / 1000000);
@@@ -209,10 -251,8 +229,10 @@@ static void wd_smp_clear_cpu_pending(in
  			struct pt_regs *regs = get_irq_regs();
  			unsigned long flags;
  
 +			wd_smp_lock(&flags);
 +
  			pr_emerg("CPU %d became unstuck TB:%lld\n",
- 				 cpu, tb);
+ 				 cpu, get_tb());
  			print_irqtrace_events(current);
  			if (regs)
  				show_regs(regs);
@@@ -292,13 -333,13 +312,13 @@@ static void watchdog_timer_interrupt(in
  
  	per_cpu(wd_timer_tb, cpu) = tb;
  
- 	wd_smp_clear_cpu_pending(cpu, tb);
+ 	wd_smp_clear_cpu_pending(cpu);
  
  	if ((s64)(tb - wd_smp_last_reset_tb) >= (s64)wd_smp_panic_timeout_tb)
- 		watchdog_smp_panic(cpu, tb);
+ 		watchdog_smp_panic(cpu);
  }
  
 -DEFINE_INTERRUPT_HANDLER_NMI(soft_nmi_interrupt)
 +void soft_nmi_interrupt(struct pt_regs *regs)
  {
  	unsigned long flags;
  	int cpu = raw_smp_processor_id();
@@@ -316,9 -358,24 +336,20 @@@
  		wd_smp_lock(&flags);
  		if (cpumask_test_cpu(cpu, &wd_smp_cpus_stuck)) {
  			wd_smp_unlock(&flags);
 -			return 0;
 +			goto out;
  		}
++<<<<<<< HEAD
 +		set_cpu_stuck(cpu, tb);
++=======
+ 		if (!wd_try_report()) {
+ 			wd_smp_unlock(&flags);
+ 			/* Couldn't report, try again in 100ms */
+ 			mtspr(SPRN_DEC, 100 * tb_ticks_per_usec * 1000);
+ 			return 0;
+ 		}
+ 
+ 		set_cpu_stuck(cpu);
 -
 -		wd_smp_unlock(&flags);
++>>>>>>> 1f01bf90765f (powerpc/watchdog: read TB close to where it is used)
  
  		pr_emerg("CPU %d self-detected hard LOCKUP @ %pS\n",
  			 cpu, (void *)regs->nip);
* Unmerged path arch/powerpc/kernel/watchdog.c
