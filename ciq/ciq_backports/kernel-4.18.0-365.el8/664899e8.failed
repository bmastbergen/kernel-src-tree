netfilter: nftables: relax check for stateful expressions in set definition

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 664899e85c1312e51d2761e7f8b2f25d053e8489
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/664899e8.failed

Restore the original behaviour where users are allowed to add an element
with any stateful expression if the set definition specifies no stateful
expressions. Make sure upper maximum number of stateful expressions of
NFT_SET_EXPR_MAX is not reached.

Fixes: 8cfd9b0f8515 ("netfilter: nftables: generalize set expressions support")
Fixes: 48b0ae046ee9 ("netfilter: nftables: netlink support for several set element expressions")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 664899e85c1312e51d2761e7f8b2f25d053e8489)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index 846331e7436a,8ee9f40cc0ea..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -4945,8 -5238,50 +4945,9 @@@ static void nf_tables_set_elem_destroy(
  static int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,
  			    const struct nlattr *attr, u32 nlmsg_flags)
  {
 -	struct nft_expr *expr_array[NFT_SET_EXPR_MAX] = {};
  	struct nlattr *nla[NFTA_SET_ELEM_MAX + 1];
  	u8 genmask = nft_genmask_next(ctx->net);
+ 	u32 flags = 0, size = 0, num_exprs = 0;
  	struct nft_set_ext_tmpl tmpl;
  	struct nft_set_ext *ext, *ext2;
  	struct nft_set_elem elem;
@@@ -4954,13 -5289,12 +4955,16 @@@
  	struct nft_object *obj = NULL;
  	struct nft_userdata *udata;
  	struct nft_data_desc desc;
 +	struct nft_data data;
  	enum nft_registers dreg;
  	struct nft_trans *trans;
++<<<<<<< HEAD
 +	u32 flags = 0;
++=======
++>>>>>>> 664899e85c13 (netfilter: nftables: relax check for stateful expressions in set definition)
  	u64 timeout;
 -	u64 expiration;
 -	int err, i;
  	u8 ulen;
 +	int err;
  
  	err = nla_parse_nested_deprecated(nla, NFTA_SET_ELEM_MAX, attr,
  					  nft_set_elem_policy, NULL);
@@@ -5008,6 -5343,76 +5012,79 @@@
  		timeout = set->timeout;
  	}
  
++<<<<<<< HEAD
++=======
+ 	expiration = 0;
+ 	if (nla[NFTA_SET_ELEM_EXPIRATION] != NULL) {
+ 		if (!(set->flags & NFT_SET_TIMEOUT))
+ 			return -EINVAL;
+ 		err = nf_msecs_to_jiffies64(nla[NFTA_SET_ELEM_EXPIRATION],
+ 					    &expiration);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (nla[NFTA_SET_ELEM_EXPR]) {
+ 		struct nft_expr *expr;
+ 
+ 		if (set->num_exprs && set->num_exprs != 1)
+ 			return -EOPNOTSUPP;
+ 
+ 		expr = nft_set_elem_expr_alloc(ctx, set,
+ 					       nla[NFTA_SET_ELEM_EXPR]);
+ 		if (IS_ERR(expr))
+ 			return PTR_ERR(expr);
+ 
+ 		expr_array[0] = expr;
+ 		num_exprs = 1;
+ 
+ 		if (set->num_exprs && set->exprs[0]->ops != expr->ops) {
+ 			err = -EOPNOTSUPP;
+ 			goto err_set_elem_expr;
+ 		}
+ 	} else if (nla[NFTA_SET_ELEM_EXPRESSIONS]) {
+ 		struct nft_expr *expr;
+ 		struct nlattr *tmp;
+ 		int left;
+ 
+ 		i = 0;
+ 		nla_for_each_nested(tmp, nla[NFTA_SET_ELEM_EXPRESSIONS], left) {
+ 			if (i == NFT_SET_EXPR_MAX ||
+ 			    (set->num_exprs && set->num_exprs == i)) {
+ 				err = -E2BIG;
+ 				goto err_set_elem_expr;
+ 			}
+ 			if (nla_type(tmp) != NFTA_LIST_ELEM) {
+ 				err = -EINVAL;
+ 				goto err_set_elem_expr;
+ 			}
+ 			expr = nft_set_elem_expr_alloc(ctx, set, tmp);
+ 			if (IS_ERR(expr)) {
+ 				err = PTR_ERR(expr);
+ 				goto err_set_elem_expr;
+ 			}
+ 			expr_array[i] = expr;
+ 			num_exprs++;
+ 
+ 			if (set->num_exprs && expr->ops != set->exprs[i]->ops) {
+ 				err = -EOPNOTSUPP;
+ 				goto err_set_elem_expr;
+ 			}
+ 			i++;
+ 		}
+ 		if (set->num_exprs && set->num_exprs != i) {
+ 			err = -EOPNOTSUPP;
+ 			goto err_set_elem_expr;
+ 		}
+ 	} else if (set->num_exprs > 0) {
+ 		err = nft_set_elem_expr_clone(ctx, set, expr_array);
+ 		if (err < 0)
+ 			goto err_set_elem_expr_clone;
+ 
+ 		num_exprs = set->num_exprs;
+ 	}
+ 
++>>>>>>> 664899e85c13 (netfilter: nftables: relax check for stateful expressions in set definition)
  	err = nft_setelem_parse_key(ctx, set, &elem.key.val,
  				    nla[NFTA_SET_ELEM_KEY]);
  	if (err < 0)
@@@ -5030,6 -5435,15 +5107,18 @@@
  			nft_set_ext_add(&tmpl, NFT_SET_EXT_TIMEOUT);
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (num_exprs) {
+ 		for (i = 0; i < num_exprs; i++)
+ 			size += expr_array[i]->ops->size;
+ 
+ 		nft_set_ext_add_length(&tmpl, NFT_SET_EXT_EXPRESSIONS,
+ 				       sizeof(struct nft_set_elem_expr) +
+ 				       size);
+ 	}
+ 
++>>>>>>> 664899e85c13 (netfilter: nftables: relax check for stateful expressions in set definition)
  	if (nla[NFTA_SET_ELEM_OBJREF] != NULL) {
  		if (!(set->flags & NFT_SET_OBJECT)) {
  			err = -EINVAL;
@@@ -5114,6 -5524,8 +5203,11 @@@
  		*nft_set_ext_obj(ext) = obj;
  		obj->use++;
  	}
++<<<<<<< HEAD
++=======
+ 	for (i = 0; i < num_exprs; i++)
+ 		nft_set_elem_expr_setup(ext, i, expr_array);
++>>>>>>> 664899e85c13 (netfilter: nftables: relax check for stateful expressions in set definition)
  
  	trans = nft_trans_elem_alloc(ctx, NFT_MSG_NEWSETELEM, set);
  	if (trans == NULL)
@@@ -5170,7 -5585,10 +5264,14 @@@ err_parse_key_end
  	nft_data_release(&elem.key_end.val, NFT_DATA_VALUE);
  err_parse_key:
  	nft_data_release(&elem.key.val, NFT_DATA_VALUE);
++<<<<<<< HEAD
 +
++=======
+ err_set_elem_expr:
+ 	for (i = 0; i < num_exprs && expr_array[i]; i++)
+ 		nft_expr_destroy(ctx, expr_array[i]);
+ err_set_elem_expr_clone:
++>>>>>>> 664899e85c13 (netfilter: nftables: relax check for stateful expressions in set definition)
  	return err;
  }
  
* Unmerged path net/netfilter/nf_tables_api.c
