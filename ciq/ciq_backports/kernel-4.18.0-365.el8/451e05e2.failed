drm/i915/dmc: Introduce DMC_FW_MAIN

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Anusha Srivatsa <anusha.srivatsa@intel.com>
commit 451e05e20270454ef9a9c52e32e2f8863a368b04
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/451e05e2.failed

This is a prep patch for Pipe DMC plugging.

Add dmc_info struct in intel_dmc to have all common fields
shared between all DMC's in the package.
Add DMC_FW_MAIN(dmc_id 0) to refer to the blob.

v2: Remove dmc_offset and start_mmioaddr from dmc_info struct (Jose)

	Cc: Souza, Jose <jose.souza@intel.com>
	Signed-off-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
	Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210621191415.29823-2-anusha.srivatsa@intel.com
(cherry picked from commit 451e05e20270454ef9a9c52e32e2f8863a368b04)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_csr.c
#	drivers/gpu/drm/i915/display/intel_dmc.h
diff --cc drivers/gpu/drm/i915/display/intel_csr.c
index 67dc64df78a5,269a57d936ab..000000000000
--- a/drivers/gpu/drm/i915/display/intel_csr.c
+++ b/drivers/gpu/drm/i915/display/intel_csr.c
@@@ -228,6 -237,11 +228,14 @@@ struct stepping_info 
  	char substepping;
  };
  
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
++=======
+ bool intel_dmc_has_payload(struct drm_i915_private *i915)
+ {
+ 	return i915->dmc.dmc_info[DMC_FW_MAIN].payload;
+ }
+ 
++>>>>>>> 451e05e20270 (drm/i915/dmc: Introduce DMC_FW_MAIN):drivers/gpu/drm/i915/display/intel_dmc.c
  static const struct stepping_info skl_stepping_info[] = {
  	{'A', '0'}, {'B', '0'}, {'C', '0'},
  	{'D', '0'}, {'E', '0'}, {'F', '0'},
@@@ -300,40 -314,41 +308,64 @@@ static void gen9_set_dc_state_debugmask
   * Everytime display comes back from low power state this function is called to
   * copy the firmware from internal memory to registers.
   */
 -void intel_dmc_load_program(struct drm_i915_private *dev_priv)
 +void intel_csr_load_program(struct drm_i915_private *dev_priv)
  {
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +	u32 *payload = dev_priv->csr.dmc_payload;
++=======
+ 	struct intel_dmc *dmc = &dev_priv->dmc;
+ 	struct dmc_fw_info *dmc_info = &dmc->dmc_info[DMC_FW_MAIN];
++>>>>>>> 451e05e20270 (drm/i915/dmc: Introduce DMC_FW_MAIN):drivers/gpu/drm/i915/display/intel_dmc.c
  	u32 i, fw_size;
  
 -	if (!HAS_DMC(dev_priv)) {
 +	if (!HAS_CSR(dev_priv)) {
  		drm_err(&dev_priv->drm,
 -			"No DMC support available for this platform\n");
 +			"No CSR support available for this platform\n");
  		return;
  	}
  
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +	if (!dev_priv->csr.dmc_payload) {
++=======
+ 	if (!dev_priv->dmc.dmc_info[DMC_FW_MAIN].payload) {
++>>>>>>> 451e05e20270 (drm/i915/dmc: Introduce DMC_FW_MAIN):drivers/gpu/drm/i915/display/intel_dmc.c
  		drm_err(&dev_priv->drm,
  			"Tried to program CSR with empty payload\n");
  		return;
  	}
  
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +	fw_size = dev_priv->csr.dmc_fw_size;
++=======
+ 	fw_size = dmc_info->dmc_fw_size;
++>>>>>>> 451e05e20270 (drm/i915/dmc: Introduce DMC_FW_MAIN):drivers/gpu/drm/i915/display/intel_dmc.c
  	assert_rpm_wakelock_held(&dev_priv->runtime_pm);
  
  	preempt_disable();
  
  	for (i = 0; i < fw_size; i++)
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +		intel_uncore_write_fw(&dev_priv->uncore, CSR_PROGRAM(i),
 +				      payload[i]);
 +
 +	preempt_enable();
 +
 +	for (i = 0; i < dev_priv->csr.mmio_count; i++) {
 +		intel_de_write(dev_priv, dev_priv->csr.mmioaddr[i],
 +			       dev_priv->csr.mmiodata[i]);
++=======
+ 		intel_uncore_write_fw(&dev_priv->uncore, DMC_PROGRAM(i),
+ 				      dmc_info->payload[i]);
+ 
+ 	preempt_enable();
+ 
+ 	for (i = 0; i < dmc_info->mmio_count; i++) {
+ 		intel_de_write(dev_priv, dmc_info->mmioaddr[i],
+ 			       dmc_info->mmiodata[i]);
++>>>>>>> 451e05e20270 (drm/i915/dmc: Introduce DMC_FW_MAIN):drivers/gpu/drm/i915/display/intel_dmc.c
  	}
  
 -	dev_priv->dmc.dc_state = 0;
 +	dev_priv->csr.dc_state = 0;
  
  	gen9_set_dc_state_debugmask(dev_priv);
  }
@@@ -382,17 -397,19 +414,27 @@@ static u32 find_dmc_fw_offset(const str
  	return dmc_offset;
  }
  
 -static u32 parse_dmc_fw_header(struct intel_dmc *dmc,
 -			       const struct intel_dmc_header_base *dmc_header,
 -			       size_t rem_size)
 +static u32 parse_csr_fw_dmc(struct intel_csr *csr,
 +			    const struct intel_dmc_header_base *dmc_header,
 +			    size_t rem_size)
  {
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
++=======
+ 	struct drm_i915_private *i915 = container_of(dmc, typeof(*i915), dmc);
+ 	struct dmc_fw_info *dmc_info = &dmc->dmc_info[DMC_FW_MAIN];
++>>>>>>> 451e05e20270 (drm/i915/dmc: Introduce DMC_FW_MAIN):drivers/gpu/drm/i915/display/intel_dmc.c
  	unsigned int header_len_bytes, dmc_header_size, payload_size, i;
  	const u32 *mmioaddr, *mmiodata;
  	u32 mmio_count, mmio_count_max;
  	u8 *payload;
  
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +	BUILD_BUG_ON(ARRAY_SIZE(csr->mmioaddr) < DMC_V3_MAX_MMIO_COUNT ||
 +		     ARRAY_SIZE(csr->mmioaddr) < DMC_V1_MAX_MMIO_COUNT);
++=======
+ 	BUILD_BUG_ON(ARRAY_SIZE(dmc_info->mmioaddr) < DMC_V3_MAX_MMIO_COUNT ||
+ 		     ARRAY_SIZE(dmc_info->mmioaddr) < DMC_V1_MAX_MMIO_COUNT);
++>>>>>>> 451e05e20270 (drm/i915/dmc: Introduce DMC_FW_MAIN):drivers/gpu/drm/i915/display/intel_dmc.c
  
  	/*
  	 * Check if we can access common fields, we will checkc again below
@@@ -448,16 -465,16 +490,23 @@@
  	}
  
  	for (i = 0; i < mmio_count; i++) {
 -		if (mmioaddr[i] < DMC_MMIO_START_RANGE ||
 -		    mmioaddr[i] > DMC_MMIO_END_RANGE) {
 -			drm_err(&i915->drm, "DMC firmware has wrong mmio address 0x%x\n",
 -				mmioaddr[i]);
 +		if (mmioaddr[i] < CSR_MMIO_START_RANGE ||
 +		    mmioaddr[i] > CSR_MMIO_END_RANGE) {
 +			DRM_ERROR("DMC firmware has wrong mmio address 0x%x\n",
 +				  mmioaddr[i]);
  			return 0;
  		}
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +		csr->mmioaddr[i] = _MMIO(mmioaddr[i]);
 +		csr->mmiodata[i] = mmiodata[i];
 +	}
 +	csr->mmio_count = mmio_count;
++=======
+ 		dmc_info->mmioaddr[i] = _MMIO(mmioaddr[i]);
+ 		dmc_info->mmiodata[i] = mmiodata[i];
+ 	}
+ 	dmc_info->mmio_count = mmio_count;
++>>>>>>> 451e05e20270 (drm/i915/dmc: Introduce DMC_FW_MAIN):drivers/gpu/drm/i915/display/intel_dmc.c
  
  	rem_size -= header_len_bytes;
  
@@@ -466,20 -483,18 +515,31 @@@
  	if (rem_size < payload_size)
  		goto error_truncated;
  
 -	if (payload_size > dmc->max_fw_size) {
 -		drm_err(&i915->drm, "DMC FW too big (%u bytes)\n", payload_size);
 +	if (payload_size > csr->max_fw_size) {
 +		DRM_ERROR("DMC FW too big (%u bytes)\n", payload_size);
  		return 0;
  	}
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +	csr->dmc_fw_size = dmc_header->fw_size;
 +
 +	csr->dmc_payload = kmalloc(payload_size, GFP_KERNEL);
 +	if (!csr->dmc_payload) {
 +		DRM_ERROR("Memory allocation failed for dmc payload\n");
++=======
+ 	dmc_info->dmc_fw_size = dmc_header->fw_size;
+ 
+ 	dmc_info->payload = kmalloc(payload_size, GFP_KERNEL);
+ 	if (!dmc_info->payload)
++>>>>>>> 451e05e20270 (drm/i915/dmc: Introduce DMC_FW_MAIN):drivers/gpu/drm/i915/display/intel_dmc.c
  		return 0;
 +	}
  
  	payload = (u8 *)(dmc_header) + header_len_bytes;
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +	memcpy(csr->dmc_payload, payload, payload_size);
++=======
+ 	memcpy(dmc_info->payload, payload, payload_size);
++>>>>>>> 451e05e20270 (drm/i915/dmc: Introduce DMC_FW_MAIN):drivers/gpu/drm/i915/display/intel_dmc.c
  
  	return header_len_bytes + payload_size;
  
@@@ -799,13 -821,13 +859,17 @@@ void intel_csr_ucode_resume(struct drm_
   * Firmmware unloading includes freeing the internal memory and reset the
   * firmware loading status.
   */
 -void intel_dmc_ucode_fini(struct drm_i915_private *dev_priv)
 +void intel_csr_ucode_fini(struct drm_i915_private *dev_priv)
  {
 -	if (!HAS_DMC(dev_priv))
 +	if (!HAS_CSR(dev_priv))
  		return;
  
 -	intel_dmc_ucode_suspend(dev_priv);
 -	drm_WARN_ON(&dev_priv->drm, dev_priv->dmc.wakeref);
 +	intel_csr_ucode_suspend(dev_priv);
 +	drm_WARN_ON(&dev_priv->drm, dev_priv->csr.wakeref);
  
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +	kfree(dev_priv->csr.dmc_payload);
++=======
+ 	kfree(dev_priv->dmc.dmc_info[DMC_FW_MAIN].payload);
++>>>>>>> 451e05e20270 (drm/i915/dmc: Introduce DMC_FW_MAIN):drivers/gpu/drm/i915/display/intel_dmc.c
  }
* Unmerged path drivers/gpu/drm/i915/display/intel_dmc.h
* Unmerged path drivers/gpu/drm/i915/display/intel_csr.c
* Unmerged path drivers/gpu/drm/i915/display/intel_dmc.h
