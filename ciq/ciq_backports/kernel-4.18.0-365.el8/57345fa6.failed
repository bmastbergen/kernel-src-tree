kasan: inline (un)poison_range and check_invalid_free

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Andrey Konovalov <andreyknvl@google.com>
commit 57345fa68a2769e3bd2b6ca01794fba74e6fa938
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/57345fa6.failed

Using (un)poison_range() or check_invalid_free() currently results in
function calls. Move their definitions to mm/kasan/kasan.h and turn them
into static inline functions for hardware tag-based mode to avoid
unneeded function calls.

Link: https://lkml.kernel.org/r/7007955b69eb31b5376a7dc1e0f4ac49138504f2.1606162397.git.andreyknvl@google.com
Link: https://linux-review.googlesource.com/id/Ia9d8191024a12d1374675b3d27197f10193f50bb
	Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
	Reviewed-by: Marco Elver <elver@google.com>
	Tested-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Branislav Rankov <Branislav.Rankov@arm.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Evgenii Stepanov <eugenis@google.com>
	Cc: Kevin Brodsky <kevin.brodsky@arm.com>
	Cc: Vasily Gorbik <gor@linux.ibm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 57345fa68a2769e3bd2b6ca01794fba74e6fa938)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/kasan/hw_tags.c
#	mm/kasan/kasan.h
diff --cc mm/kasan/kasan.h
index 2db4c5c1b473,6e811d0f6242..000000000000
--- a/mm/kasan/kasan.h
+++ b/mm/kasan/kasan.h
@@@ -134,10 -149,12 +134,19 @@@ struct kasan_free_meta 
  #endif
  };
  
++<<<<<<< HEAD
 +struct kasan_alloc_meta *get_alloc_info(struct kmem_cache *cache,
 +					const void *object);
 +struct kasan_free_meta *get_free_info(struct kmem_cache *cache,
 +					const void *object);
++=======
+ struct kasan_alloc_meta *kasan_get_alloc_meta(struct kmem_cache *cache,
+ 						const void *object);
+ struct kasan_free_meta *kasan_get_free_meta(struct kmem_cache *cache,
+ 						const void *object);
+ 
+ #if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)
++>>>>>>> 57345fa68a27 (kasan: inline (un)poison_range and check_invalid_free)
  
  static inline const void *kasan_shadow_to_mem(const void *shadow_addr)
  {
@@@ -163,8 -178,30 +172,26 @@@ void kasan_poison_shadow(const void *ad
  bool check_memory_region(unsigned long addr, size_t size, bool write,
  				unsigned long ret_ip);
  
++<<<<<<< HEAD
++=======
+ #else /* CONFIG_KASAN_GENERIC || CONFIG_KASAN_SW_TAGS */
+ 
+ static inline bool addr_has_metadata(const void *addr)
+ {
+ 	return true;
+ }
+ 
+ #endif /* CONFIG_KASAN_GENERIC || CONFIG_KASAN_SW_TAGS */
+ 
+ #if defined(CONFIG_KASAN_SW_TAGS) || defined(CONFIG_KASAN_HW_TAGS)
+ void print_tags(u8 addr_tag, const void *addr);
+ #else
+ static inline void print_tags(u8 addr_tag, const void *addr) { }
+ #endif
+ 
++>>>>>>> 57345fa68a27 (kasan: inline (un)poison_range and check_invalid_free)
  void *find_first_bad_addr(void *addr, size_t size);
  const char *get_bug_type(struct kasan_access_info *info);
 -void metadata_fetch_row(char *buffer, void *row);
 -
 -#if defined(CONFIG_KASAN_GENERIC) && CONFIG_KASAN_STACK
 -void print_address_stack_frame(const void *addr);
 -#else
 -static inline void print_address_stack_frame(const void *addr) { }
 -#endif
  
  bool kasan_report(unsigned long addr, size_t size,
  		bool is_write, unsigned long ip);
@@@ -249,6 -265,45 +276,48 @@@ static inline const void *arch_kasan_se
  
  #endif /* CONFIG_KASAN_HW_TAGS */
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_KASAN_SW_TAGS
+ u8 random_tag(void);
+ #elif defined(CONFIG_KASAN_HW_TAGS)
+ static inline u8 random_tag(void) { return hw_get_random_tag(); }
+ #else
+ static inline u8 random_tag(void) { return 0; }
+ #endif
+ 
+ #ifdef CONFIG_KASAN_HW_TAGS
+ 
+ static inline void poison_range(const void *address, size_t size, u8 value)
+ {
+ 	hw_set_mem_tag_range(kasan_reset_tag(address),
+ 			round_up(size, KASAN_GRANULE_SIZE), value);
+ }
+ 
+ static inline void unpoison_range(const void *address, size_t size)
+ {
+ 	hw_set_mem_tag_range(kasan_reset_tag(address),
+ 			round_up(size, KASAN_GRANULE_SIZE), get_tag(address));
+ }
+ 
+ static inline bool check_invalid_free(void *addr)
+ {
+ 	u8 ptr_tag = get_tag(addr);
+ 	u8 mem_tag = hw_get_mem_tag(addr);
+ 
+ 	return (mem_tag == KASAN_TAG_INVALID) ||
+ 		(ptr_tag != KASAN_TAG_KERNEL && ptr_tag != mem_tag);
+ }
+ 
+ #else /* CONFIG_KASAN_HW_TAGS */
+ 
+ void poison_range(const void *address, size_t size, u8 value);
+ void unpoison_range(const void *address, size_t size);
+ bool check_invalid_free(void *addr);
+ 
+ #endif /* CONFIG_KASAN_HW_TAGS */
+ 
++>>>>>>> 57345fa68a27 (kasan: inline (un)poison_range and check_invalid_free)
  /*
   * Exported functions for interfaces called from assembly or from generated
   * code. Declarations here to avoid warning about missing declarations.
* Unmerged path mm/kasan/hw_tags.c
* Unmerged path mm/kasan/hw_tags.c
* Unmerged path mm/kasan/kasan.h
