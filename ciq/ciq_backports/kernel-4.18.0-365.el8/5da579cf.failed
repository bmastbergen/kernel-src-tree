drm/i915/display: Drop unnecessary frontbuffer flushes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author José Roberto de Souza <jose.souza@intel.com>
commit 5da579cff38d64d024c1b99bafa3347c0d5fc107
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/5da579cf.failed

This unnecessary flushes are hurting power-savings are it causes
features like PSR, FBC and DRRS to disable it self to handle
frontbuffer rendering, below some explanation of why each removed
call is not necessary.

The flush in intel_prepare_plane_fb() is not required as framebuffer
will be flipped and power-saving features do the proper flip handling
in hardware.

intel_find_initial_plane_obj() flush is not required because it is
only executed during driver load and at this point the power-saving
features are not even enabled.

And the last one intelfb_create(), is also not required as at this
point the fbdev was just allocated, userspace will draw on
it what will trigger frontbuffer invalidates and flushes later on.

	Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
	Cc: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
	Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
	Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210930001409.254817-3-jose.souza@intel.com
(cherry picked from commit 5da579cff38d64d024c1b99bafa3347c0d5fc107)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_display.c
diff --cc drivers/gpu/drm/i915/display/intel_display.c
index be4f122dd751,1ce1d46dca5b..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@@ -2859,742 -1679,50 +2859,746 @@@ intel_find_initial_plane_obj(struct int
  		intel_plane_disable_noatomic(slave, to_intel_plane(slave->base.primary));
  	}
  
 -	return;
 +	return;
 +
 +valid_fb:
 +	intel_state->hw.rotation = plane_config->rotation;
 +	intel_fill_fb_ggtt_view(&intel_state->view, fb,
 +				intel_state->hw.rotation);
 +	intel_state->color_plane[0].stride =
 +		intel_fb_pitch(fb, 0, intel_state->hw.rotation);
 +
 +	__i915_vma_pin(vma);
 +	intel_state->vma = i915_vma_get(vma);
 +	if (intel_plane_uses_fence(intel_state) && i915_vma_pin_fence(vma) == 0)
 +		if (vma->fence)
 +			intel_state->flags |= PLANE_HAS_FENCE;
 +
 +	plane_state->src_x = 0;
 +	plane_state->src_y = 0;
 +	plane_state->src_w = fb->width << 16;
 +	plane_state->src_h = fb->height << 16;
 +
 +	plane_state->crtc_x = 0;
 +	plane_state->crtc_y = 0;
 +	plane_state->crtc_w = fb->width;
 +	plane_state->crtc_h = fb->height;
 +
 +	intel_state->uapi.src = drm_plane_state_src(plane_state);
 +	intel_state->uapi.dst = drm_plane_state_dest(plane_state);
 +
 +	if (plane_config->tiling)
 +		dev_priv->preserve_bios_swizzle = true;
 +
 +	plane_state->fb = fb;
 +	drm_framebuffer_get(fb);
 +
 +	plane_state->crtc = &intel_crtc->base;
 +	intel_plane_copy_uapi_to_hw_state(intel_state, intel_state,
 +					  intel_crtc);
 +
++<<<<<<< HEAD
 +	intel_frontbuffer_flush(to_intel_frontbuffer(fb), ORIGIN_DIRTYFB);
 +
 +	atomic_or(to_intel_plane(primary)->frontbuffer_bit,
 +		  &to_intel_frontbuffer(fb)->bits);
 +}
 +
 +
 +static bool
 +skl_check_main_ccs_coordinates(struct intel_plane_state *plane_state,
 +			       int main_x, int main_y, u32 main_offset,
 +			       int ccs_plane)
 +{
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	int aux_x = plane_state->color_plane[ccs_plane].x;
 +	int aux_y = plane_state->color_plane[ccs_plane].y;
 +	u32 aux_offset = plane_state->color_plane[ccs_plane].offset;
 +	u32 alignment = intel_surf_alignment(fb, ccs_plane);
 +	int hsub;
 +	int vsub;
 +
 +	intel_fb_plane_get_subsampling(&hsub, &vsub, fb, ccs_plane);
 +	while (aux_offset >= main_offset && aux_y <= main_y) {
 +		int x, y;
 +
 +		if (aux_x == main_x && aux_y == main_y)
 +			break;
 +
 +		if (aux_offset == 0)
 +			break;
 +
 +		x = aux_x / hsub;
 +		y = aux_y / vsub;
 +		aux_offset = intel_plane_adjust_aligned_offset(&x, &y,
 +							       plane_state,
 +							       ccs_plane,
 +							       aux_offset,
 +							       aux_offset -
 +								alignment);
 +		aux_x = x * hsub + aux_x % hsub;
 +		aux_y = y * vsub + aux_y % vsub;
 +	}
 +
 +	if (aux_x != main_x || aux_y != main_y)
 +		return false;
 +
 +	plane_state->color_plane[ccs_plane].offset = aux_offset;
 +	plane_state->color_plane[ccs_plane].x = aux_x;
 +	plane_state->color_plane[ccs_plane].y = aux_y;
 +
 +	return true;
++=======
++	atomic_or(plane->frontbuffer_bit, &to_intel_frontbuffer(fb)->bits);
++>>>>>>> 5da579cff38d (drm/i915/display: Drop unnecessary frontbuffer flushes)
 +}
 +
 +unsigned int
 +intel_plane_fence_y_offset(const struct intel_plane_state *plane_state)
 +{
 +	int x = 0, y = 0;
 +
 +	intel_plane_adjust_aligned_offset(&x, &y, plane_state, 0,
 +					  plane_state->color_plane[0].offset, 0);
 +
 +	return y;
 +}
 +
 +static int intel_plane_min_width(struct intel_plane *plane,
 +				 const struct drm_framebuffer *fb,
 +				 int color_plane,
 +				 unsigned int rotation)
 +{
 +	if (plane->min_width)
 +		return plane->min_width(fb, color_plane, rotation);
 +	else
 +		return 1;
 +}
 +
 +static int intel_plane_max_width(struct intel_plane *plane,
 +				 const struct drm_framebuffer *fb,
 +				 int color_plane,
 +				 unsigned int rotation)
 +{
 +	if (plane->max_width)
 +		return plane->max_width(fb, color_plane, rotation);
 +	else
 +		return INT_MAX;
 +}
 +
 +static int intel_plane_max_height(struct intel_plane *plane,
 +				  const struct drm_framebuffer *fb,
 +				  int color_plane,
 +				  unsigned int rotation)
 +{
 +	if (plane->max_height)
 +		return plane->max_height(fb, color_plane, rotation);
 +	else
 +		return INT_MAX;
 +}
 +
 +int skl_calc_main_surface_offset(const struct intel_plane_state *plane_state,
 +				 int *x, int *y, u32 *offset)
 +{
 +	struct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);
 +	struct drm_i915_private *dev_priv = to_i915(plane->base.dev);
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	const int aux_plane = intel_main_to_aux_plane(fb, 0);
 +	const u32 aux_offset = plane_state->color_plane[aux_plane].offset;
 +	const u32 alignment = intel_surf_alignment(fb, 0);
 +	const int w = drm_rect_width(&plane_state->uapi.src) >> 16;
 +
 +	intel_add_fb_offsets(x, y, plane_state, 0);
 +	*offset = intel_plane_compute_aligned_offset(x, y, plane_state, 0);
 +	if (drm_WARN_ON(&dev_priv->drm, alignment && !is_power_of_2(alignment)))
 +		return -EINVAL;
 +
 +	/*
 +	 * AUX surface offset is specified as the distance from the
 +	 * main surface offset, and it must be non-negative. Make
 +	 * sure that is what we will get.
 +	 */
 +	if (aux_plane && *offset > aux_offset)
 +		*offset = intel_plane_adjust_aligned_offset(x, y, plane_state, 0,
 +							    *offset,
 +							    aux_offset & ~(alignment - 1));
 +
 +	/*
 +	 * When using an X-tiled surface, the plane blows up
 +	 * if the x offset + width exceed the stride.
 +	 *
 +	 * TODO: linear and Y-tiled seem fine, Yf untested,
 +	 */
 +	if (fb->modifier == I915_FORMAT_MOD_X_TILED) {
 +		int cpp = fb->format->cpp[0];
 +
 +		while ((*x + w) * cpp > plane_state->color_plane[0].stride) {
 +			if (*offset == 0) {
 +				drm_dbg_kms(&dev_priv->drm,
 +					    "Unable to find suitable display surface offset due to X-tiling\n");
 +				return -EINVAL;
 +			}
 +
 +			*offset = intel_plane_adjust_aligned_offset(x, y, plane_state, 0,
 +								    *offset,
 +								    *offset - alignment);
 +		}
 +	}
 +
 +	return 0;
 +}
 +
 +static int skl_check_main_surface(struct intel_plane_state *plane_state)
 +{
 +	struct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);
 +	struct drm_i915_private *dev_priv = to_i915(plane->base.dev);
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	const unsigned int rotation = plane_state->hw.rotation;
 +	int x = plane_state->uapi.src.x1 >> 16;
 +	int y = plane_state->uapi.src.y1 >> 16;
 +	const int w = drm_rect_width(&plane_state->uapi.src) >> 16;
 +	const int h = drm_rect_height(&plane_state->uapi.src) >> 16;
 +	const int min_width = intel_plane_min_width(plane, fb, 0, rotation);
 +	const int max_width = intel_plane_max_width(plane, fb, 0, rotation);
 +	const int max_height = intel_plane_max_height(plane, fb, 0, rotation);
 +	const int aux_plane = intel_main_to_aux_plane(fb, 0);
 +	const u32 alignment = intel_surf_alignment(fb, 0);
 +	u32 offset;
 +	int ret;
 +
 +	if (w > max_width || w < min_width || h > max_height) {
 +		drm_dbg_kms(&dev_priv->drm,
 +			    "requested Y/RGB source size %dx%d outside limits (min: %dx1 max: %dx%d)\n",
 +			    w, h, min_width, max_width, max_height);
 +		return -EINVAL;
 +	}
 +
 +	ret = skl_calc_main_surface_offset(plane_state, &x, &y, &offset);
 +	if (ret)
 +		return ret;
 +
 +	/*
 +	 * CCS AUX surface doesn't have its own x/y offsets, we must make sure
 +	 * they match with the main surface x/y offsets.
 +	 */
 +	if (is_ccs_modifier(fb->modifier)) {
 +		while (!skl_check_main_ccs_coordinates(plane_state, x, y,
 +						       offset, aux_plane)) {
 +			if (offset == 0)
 +				break;
 +
 +			offset = intel_plane_adjust_aligned_offset(&x, &y, plane_state, 0,
 +								   offset, offset - alignment);
 +		}
 +
 +		if (x != plane_state->color_plane[aux_plane].x ||
 +		    y != plane_state->color_plane[aux_plane].y) {
 +			drm_dbg_kms(&dev_priv->drm,
 +				    "Unable to find suitable display surface offset due to CCS\n");
 +			return -EINVAL;
 +		}
 +	}
 +
 +	drm_WARN_ON(&dev_priv->drm, x > 8191 || y > 8191);
 +
 +	plane_state->color_plane[0].offset = offset;
 +	plane_state->color_plane[0].x = x;
 +	plane_state->color_plane[0].y = y;
 +
 +	/*
 +	 * Put the final coordinates back so that the src
 +	 * coordinate checks will see the right values.
 +	 */
 +	drm_rect_translate_to(&plane_state->uapi.src,
 +			      x << 16, y << 16);
 +
 +	return 0;
 +}
 +
 +static int skl_check_nv12_aux_surface(struct intel_plane_state *plane_state)
 +{
 +	struct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);
 +	struct drm_i915_private *i915 = to_i915(plane->base.dev);
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	unsigned int rotation = plane_state->hw.rotation;
 +	int uv_plane = 1;
 +	int max_width = intel_plane_max_width(plane, fb, uv_plane, rotation);
 +	int max_height = intel_plane_max_height(plane, fb, uv_plane, rotation);
 +	int x = plane_state->uapi.src.x1 >> 17;
 +	int y = plane_state->uapi.src.y1 >> 17;
 +	int w = drm_rect_width(&plane_state->uapi.src) >> 17;
 +	int h = drm_rect_height(&plane_state->uapi.src) >> 17;
 +	u32 offset;
 +
 +	/* FIXME not quite sure how/if these apply to the chroma plane */
 +	if (w > max_width || h > max_height) {
 +		drm_dbg_kms(&i915->drm,
 +			    "CbCr source size %dx%d too big (limit %dx%d)\n",
 +			    w, h, max_width, max_height);
 +		return -EINVAL;
 +	}
 +
 +	intel_add_fb_offsets(&x, &y, plane_state, uv_plane);
 +	offset = intel_plane_compute_aligned_offset(&x, &y,
 +						    plane_state, uv_plane);
 +
 +	if (is_ccs_modifier(fb->modifier)) {
 +		int ccs_plane = main_to_ccs_plane(fb, uv_plane);
 +		u32 aux_offset = plane_state->color_plane[ccs_plane].offset;
 +		u32 alignment = intel_surf_alignment(fb, uv_plane);
 +
 +		if (offset > aux_offset)
 +			offset = intel_plane_adjust_aligned_offset(&x, &y,
 +								   plane_state,
 +								   uv_plane,
 +								   offset,
 +								   aux_offset & ~(alignment - 1));
 +
 +		while (!skl_check_main_ccs_coordinates(plane_state, x, y,
 +						       offset, ccs_plane)) {
 +			if (offset == 0)
 +				break;
 +
 +			offset = intel_plane_adjust_aligned_offset(&x, &y,
 +								   plane_state,
 +								   uv_plane,
 +								   offset, offset - alignment);
 +		}
 +
 +		if (x != plane_state->color_plane[ccs_plane].x ||
 +		    y != plane_state->color_plane[ccs_plane].y) {
 +			drm_dbg_kms(&i915->drm,
 +				    "Unable to find suitable display surface offset due to CCS\n");
 +			return -EINVAL;
 +		}
 +	}
 +
 +	drm_WARN_ON(&i915->drm, x > 8191 || y > 8191);
 +
 +	plane_state->color_plane[uv_plane].offset = offset;
 +	plane_state->color_plane[uv_plane].x = x;
 +	plane_state->color_plane[uv_plane].y = y;
 +
 +	return 0;
 +}
 +
 +static int skl_check_ccs_aux_surface(struct intel_plane_state *plane_state)
 +{
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	int src_x = plane_state->uapi.src.x1 >> 16;
 +	int src_y = plane_state->uapi.src.y1 >> 16;
 +	u32 offset;
 +	int ccs_plane;
 +
 +	for (ccs_plane = 0; ccs_plane < fb->format->num_planes; ccs_plane++) {
 +		int main_hsub, main_vsub;
 +		int hsub, vsub;
 +		int x, y;
 +
 +		if (!is_ccs_plane(fb, ccs_plane) ||
 +		    is_gen12_ccs_cc_plane(fb, ccs_plane))
 +			continue;
 +
 +		intel_fb_plane_get_subsampling(&main_hsub, &main_vsub, fb,
 +					       ccs_to_main_plane(fb, ccs_plane));
 +		intel_fb_plane_get_subsampling(&hsub, &vsub, fb, ccs_plane);
 +
 +		hsub *= main_hsub;
 +		vsub *= main_vsub;
 +		x = src_x / hsub;
 +		y = src_y / vsub;
 +
 +		intel_add_fb_offsets(&x, &y, plane_state, ccs_plane);
 +
 +		offset = intel_plane_compute_aligned_offset(&x, &y,
 +							    plane_state,
 +							    ccs_plane);
 +
 +		plane_state->color_plane[ccs_plane].offset = offset;
 +		plane_state->color_plane[ccs_plane].x = (x * hsub +
 +							 src_x % hsub) /
 +							main_hsub;
 +		plane_state->color_plane[ccs_plane].y = (y * vsub +
 +							 src_y % vsub) /
 +							main_vsub;
 +	}
 +
 +	return 0;
 +}
 +
 +int skl_check_plane_surface(struct intel_plane_state *plane_state)
 +{
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	int ret, i;
 +
 +	ret = intel_plane_compute_gtt(plane_state);
 +	if (ret)
 +		return ret;
 +
 +	if (!plane_state->uapi.visible)
 +		return 0;
 +
 +	/*
 +	 * Handle the AUX surface first since the main surface setup depends on
 +	 * it.
 +	 */
 +	if (is_ccs_modifier(fb->modifier)) {
 +		ret = skl_check_ccs_aux_surface(plane_state);
 +		if (ret)
 +			return ret;
 +	}
 +
 +	if (intel_format_info_is_yuv_semiplanar(fb->format,
 +						fb->modifier)) {
 +		ret = skl_check_nv12_aux_surface(plane_state);
 +		if (ret)
 +			return ret;
 +	}
 +
 +	for (i = fb->format->num_planes; i < ARRAY_SIZE(plane_state->color_plane); i++) {
 +		plane_state->color_plane[i].offset = 0;
 +		plane_state->color_plane[i].x = 0;
 +		plane_state->color_plane[i].y = 0;
 +	}
 +
 +	ret = skl_check_main_surface(plane_state);
 +	if (ret)
 +		return ret;
 +
 +	return 0;
 +}
 +
 +static void skl_detach_scaler(struct intel_crtc *intel_crtc, int id)
 +{
 +	struct drm_device *dev = intel_crtc->base.dev;
 +	struct drm_i915_private *dev_priv = to_i915(dev);
 +	unsigned long irqflags;
 +
 +	spin_lock_irqsave(&dev_priv->uncore.lock, irqflags);
 +
 +	intel_de_write_fw(dev_priv, SKL_PS_CTRL(intel_crtc->pipe, id), 0);
 +	intel_de_write_fw(dev_priv, SKL_PS_WIN_POS(intel_crtc->pipe, id), 0);
 +	intel_de_write_fw(dev_priv, SKL_PS_WIN_SZ(intel_crtc->pipe, id), 0);
 +
 +	spin_unlock_irqrestore(&dev_priv->uncore.lock, irqflags);
 +}
 +
 +/*
 + * This function detaches (aka. unbinds) unused scalers in hardware
 + */
 +static void skl_detach_scalers(const struct intel_crtc_state *crtc_state)
 +{
 +	struct intel_crtc *intel_crtc = to_intel_crtc(crtc_state->uapi.crtc);
 +	const struct intel_crtc_scaler_state *scaler_state =
 +		&crtc_state->scaler_state;
 +	int i;
 +
 +	/* loop through and disable scalers that aren't in use */
 +	for (i = 0; i < intel_crtc->num_scalers; i++) {
 +		if (!scaler_state->scalers[i].in_use)
 +			skl_detach_scaler(intel_crtc, i);
 +	}
 +}
 +
 +static unsigned int skl_plane_stride_mult(const struct drm_framebuffer *fb,
 +					  int color_plane, unsigned int rotation)
 +{
 +	/*
 +	 * The stride is either expressed as a multiple of 64 bytes chunks for
 +	 * linear buffers or in number of tiles for tiled buffers.
 +	 */
 +	if (is_surface_linear(fb, color_plane))
 +		return 64;
 +	else if (drm_rotation_90_or_270(rotation))
 +		return intel_tile_height(fb, color_plane);
 +	else
 +		return intel_tile_width_bytes(fb, color_plane);
 +}
 +
 +u32 skl_plane_stride(const struct intel_plane_state *plane_state,
 +		     int color_plane)
 +{
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	unsigned int rotation = plane_state->hw.rotation;
 +	u32 stride = plane_state->color_plane[color_plane].stride;
 +
 +	if (color_plane >= fb->format->num_planes)
 +		return 0;
 +
 +	return stride / skl_plane_stride_mult(fb, color_plane, rotation);
 +}
 +
 +static u32 skl_plane_ctl_format(u32 pixel_format)
 +{
 +	switch (pixel_format) {
 +	case DRM_FORMAT_C8:
 +		return PLANE_CTL_FORMAT_INDEXED;
 +	case DRM_FORMAT_RGB565:
 +		return PLANE_CTL_FORMAT_RGB_565;
 +	case DRM_FORMAT_XBGR8888:
 +	case DRM_FORMAT_ABGR8888:
 +		return PLANE_CTL_FORMAT_XRGB_8888 | PLANE_CTL_ORDER_RGBX;
 +	case DRM_FORMAT_XRGB8888:
 +	case DRM_FORMAT_ARGB8888:
 +		return PLANE_CTL_FORMAT_XRGB_8888;
 +	case DRM_FORMAT_XBGR2101010:
 +	case DRM_FORMAT_ABGR2101010:
 +		return PLANE_CTL_FORMAT_XRGB_2101010 | PLANE_CTL_ORDER_RGBX;
 +	case DRM_FORMAT_XRGB2101010:
 +	case DRM_FORMAT_ARGB2101010:
 +		return PLANE_CTL_FORMAT_XRGB_2101010;
 +	case DRM_FORMAT_XBGR16161616F:
 +	case DRM_FORMAT_ABGR16161616F:
 +		return PLANE_CTL_FORMAT_XRGB_16161616F | PLANE_CTL_ORDER_RGBX;
 +	case DRM_FORMAT_XRGB16161616F:
 +	case DRM_FORMAT_ARGB16161616F:
 +		return PLANE_CTL_FORMAT_XRGB_16161616F;
 +	case DRM_FORMAT_XYUV8888:
 +		return PLANE_CTL_FORMAT_XYUV;
 +	case DRM_FORMAT_YUYV:
 +		return PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_YUYV;
 +	case DRM_FORMAT_YVYU:
 +		return PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_YVYU;
 +	case DRM_FORMAT_UYVY:
 +		return PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_UYVY;
 +	case DRM_FORMAT_VYUY:
 +		return PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_VYUY;
 +	case DRM_FORMAT_NV12:
 +		return PLANE_CTL_FORMAT_NV12;
 +	case DRM_FORMAT_P010:
 +		return PLANE_CTL_FORMAT_P010;
 +	case DRM_FORMAT_P012:
 +		return PLANE_CTL_FORMAT_P012;
 +	case DRM_FORMAT_P016:
 +		return PLANE_CTL_FORMAT_P016;
 +	case DRM_FORMAT_Y210:
 +		return PLANE_CTL_FORMAT_Y210;
 +	case DRM_FORMAT_Y212:
 +		return PLANE_CTL_FORMAT_Y212;
 +	case DRM_FORMAT_Y216:
 +		return PLANE_CTL_FORMAT_Y216;
 +	case DRM_FORMAT_XVYU2101010:
 +		return PLANE_CTL_FORMAT_Y410;
 +	case DRM_FORMAT_XVYU12_16161616:
 +		return PLANE_CTL_FORMAT_Y412;
 +	case DRM_FORMAT_XVYU16161616:
 +		return PLANE_CTL_FORMAT_Y416;
 +	default:
 +		MISSING_CASE(pixel_format);
 +	}
 +
 +	return 0;
 +}
 +
 +static u32 skl_plane_ctl_alpha(const struct intel_plane_state *plane_state)
 +{
 +	if (!plane_state->hw.fb->format->has_alpha)
 +		return PLANE_CTL_ALPHA_DISABLE;
 +
 +	switch (plane_state->hw.pixel_blend_mode) {
 +	case DRM_MODE_BLEND_PIXEL_NONE:
 +		return PLANE_CTL_ALPHA_DISABLE;
 +	case DRM_MODE_BLEND_PREMULTI:
 +		return PLANE_CTL_ALPHA_SW_PREMULTIPLY;
 +	case DRM_MODE_BLEND_COVERAGE:
 +		return PLANE_CTL_ALPHA_HW_PREMULTIPLY;
 +	default:
 +		MISSING_CASE(plane_state->hw.pixel_blend_mode);
 +		return PLANE_CTL_ALPHA_DISABLE;
 +	}
 +}
 +
 +static u32 glk_plane_color_ctl_alpha(const struct intel_plane_state *plane_state)
 +{
 +	if (!plane_state->hw.fb->format->has_alpha)
 +		return PLANE_COLOR_ALPHA_DISABLE;
 +
 +	switch (plane_state->hw.pixel_blend_mode) {
 +	case DRM_MODE_BLEND_PIXEL_NONE:
 +		return PLANE_COLOR_ALPHA_DISABLE;
 +	case DRM_MODE_BLEND_PREMULTI:
 +		return PLANE_COLOR_ALPHA_SW_PREMULTIPLY;
 +	case DRM_MODE_BLEND_COVERAGE:
 +		return PLANE_COLOR_ALPHA_HW_PREMULTIPLY;
 +	default:
 +		MISSING_CASE(plane_state->hw.pixel_blend_mode);
 +		return PLANE_COLOR_ALPHA_DISABLE;
 +	}
 +}
 +
 +static u32 skl_plane_ctl_tiling(u64 fb_modifier)
 +{
 +	switch (fb_modifier) {
 +	case DRM_FORMAT_MOD_LINEAR:
 +		break;
 +	case I915_FORMAT_MOD_X_TILED:
 +		return PLANE_CTL_TILED_X;
 +	case I915_FORMAT_MOD_Y_TILED:
 +		return PLANE_CTL_TILED_Y;
 +	case I915_FORMAT_MOD_Y_TILED_CCS:
 +	case I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS_CC:
 +		return PLANE_CTL_TILED_Y | PLANE_CTL_RENDER_DECOMPRESSION_ENABLE;
 +	case I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS:
 +		return PLANE_CTL_TILED_Y |
 +		       PLANE_CTL_RENDER_DECOMPRESSION_ENABLE |
 +		       PLANE_CTL_CLEAR_COLOR_DISABLE;
 +	case I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS:
 +		return PLANE_CTL_TILED_Y | PLANE_CTL_MEDIA_DECOMPRESSION_ENABLE;
 +	case I915_FORMAT_MOD_Yf_TILED:
 +		return PLANE_CTL_TILED_YF;
 +	case I915_FORMAT_MOD_Yf_TILED_CCS:
 +		return PLANE_CTL_TILED_YF | PLANE_CTL_RENDER_DECOMPRESSION_ENABLE;
 +	default:
 +		MISSING_CASE(fb_modifier);
 +	}
 +
 +	return 0;
 +}
 +
 +static u32 skl_plane_ctl_rotate(unsigned int rotate)
 +{
 +	switch (rotate) {
 +	case DRM_MODE_ROTATE_0:
 +		break;
 +	/*
 +	 * DRM_MODE_ROTATE_ is counter clockwise to stay compatible with Xrandr
 +	 * while i915 HW rotation is clockwise, thats why this swapping.
 +	 */
 +	case DRM_MODE_ROTATE_90:
 +		return PLANE_CTL_ROTATE_270;
 +	case DRM_MODE_ROTATE_180:
 +		return PLANE_CTL_ROTATE_180;
 +	case DRM_MODE_ROTATE_270:
 +		return PLANE_CTL_ROTATE_90;
 +	default:
 +		MISSING_CASE(rotate);
 +	}
 +
 +	return 0;
 +}
 +
 +static u32 cnl_plane_ctl_flip(unsigned int reflect)
 +{
 +	switch (reflect) {
 +	case 0:
 +		break;
 +	case DRM_MODE_REFLECT_X:
 +		return PLANE_CTL_FLIP_HORIZONTAL;
 +	case DRM_MODE_REFLECT_Y:
 +	default:
 +		MISSING_CASE(reflect);
 +	}
 +
 +	return 0;
 +}
 +
 +u32 skl_plane_ctl_crtc(const struct intel_crtc_state *crtc_state)
 +{
 +	struct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);
 +	u32 plane_ctl = 0;
 +
 +	if (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv))
 +		return plane_ctl;
 +
 +	if (crtc_state->gamma_enable)
 +		plane_ctl |= PLANE_CTL_PIPE_GAMMA_ENABLE;
 +
 +	if (crtc_state->csc_enable)
 +		plane_ctl |= PLANE_CTL_PIPE_CSC_ENABLE;
 +
 +	return plane_ctl;
 +}
 +
 +u32 skl_plane_ctl(const struct intel_crtc_state *crtc_state,
 +		  const struct intel_plane_state *plane_state)
 +{
 +	struct drm_i915_private *dev_priv =
 +		to_i915(plane_state->uapi.plane->dev);
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	unsigned int rotation = plane_state->hw.rotation;
 +	const struct drm_intel_sprite_colorkey *key = &plane_state->ckey;
 +	u32 plane_ctl;
 +
 +	plane_ctl = PLANE_CTL_ENABLE;
 +
 +	if (INTEL_GEN(dev_priv) < 10 && !IS_GEMINILAKE(dev_priv)) {
 +		plane_ctl |= skl_plane_ctl_alpha(plane_state);
 +		plane_ctl |= PLANE_CTL_PLANE_GAMMA_DISABLE;
 +
 +		if (plane_state->hw.color_encoding == DRM_COLOR_YCBCR_BT709)
 +			plane_ctl |= PLANE_CTL_YUV_TO_RGB_CSC_FORMAT_BT709;
 +
 +		if (plane_state->hw.color_range == DRM_COLOR_YCBCR_FULL_RANGE)
 +			plane_ctl |= PLANE_CTL_YUV_RANGE_CORRECTION_DISABLE;
 +	}
 +
 +	plane_ctl |= skl_plane_ctl_format(fb->format->format);
 +	plane_ctl |= skl_plane_ctl_tiling(fb->modifier);
 +	plane_ctl |= skl_plane_ctl_rotate(rotation & DRM_MODE_ROTATE_MASK);
  
 -valid_fb:
 -	plane_state->uapi.rotation = plane_config->rotation;
 -	intel_fb_fill_view(to_intel_framebuffer(fb),
 -			   plane_state->uapi.rotation, &plane_state->view);
 +	if (INTEL_GEN(dev_priv) >= 10)
 +		plane_ctl |= cnl_plane_ctl_flip(rotation &
 +						DRM_MODE_REFLECT_MASK);
  
 -	__i915_vma_pin(vma);
 -	plane_state->ggtt_vma = i915_vma_get(vma);
 -	if (intel_plane_uses_fence(plane_state) &&
 -	    i915_vma_pin_fence(vma) == 0 && vma->fence)
 -		plane_state->flags |= PLANE_HAS_FENCE;
 +	if (key->flags & I915_SET_COLORKEY_DESTINATION)
 +		plane_ctl |= PLANE_CTL_KEY_ENABLE_DESTINATION;
 +	else if (key->flags & I915_SET_COLORKEY_SOURCE)
 +		plane_ctl |= PLANE_CTL_KEY_ENABLE_SOURCE;
  
 -	plane_state->uapi.src_x = 0;
 -	plane_state->uapi.src_y = 0;
 -	plane_state->uapi.src_w = fb->width << 16;
 -	plane_state->uapi.src_h = fb->height << 16;
 +	return plane_ctl;
 +}
  
 -	plane_state->uapi.crtc_x = 0;
 -	plane_state->uapi.crtc_y = 0;
 -	plane_state->uapi.crtc_w = fb->width;
 -	plane_state->uapi.crtc_h = fb->height;
 +u32 glk_plane_color_ctl_crtc(const struct intel_crtc_state *crtc_state)
 +{
 +	struct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);
 +	u32 plane_color_ctl = 0;
  
 -	if (plane_config->tiling)
 -		dev_priv->preserve_bios_swizzle = true;
 +	if (INTEL_GEN(dev_priv) >= 11)
 +		return plane_color_ctl;
  
 -	plane_state->uapi.fb = fb;
 -	drm_framebuffer_get(fb);
 +	if (crtc_state->gamma_enable)
 +		plane_color_ctl |= PLANE_COLOR_PIPE_GAMMA_ENABLE;
  
 -	plane_state->uapi.crtc = &crtc->base;
 -	intel_plane_copy_uapi_to_hw_state(plane_state, plane_state, crtc);
 +	if (crtc_state->csc_enable)
 +		plane_color_ctl |= PLANE_COLOR_PIPE_CSC_ENABLE;
  
 -	atomic_or(plane->frontbuffer_bit, &to_intel_frontbuffer(fb)->bits);
 +	return plane_color_ctl;
  }
  
 -unsigned int
 -intel_plane_fence_y_offset(const struct intel_plane_state *plane_state)
 +u32 glk_plane_color_ctl(const struct intel_crtc_state *crtc_state,
 +			const struct intel_plane_state *plane_state)
  {
 -	int x = 0, y = 0;
 +	struct drm_i915_private *dev_priv =
 +		to_i915(plane_state->uapi.plane->dev);
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	struct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);
 +	u32 plane_color_ctl = 0;
  
 -	intel_plane_adjust_aligned_offset(&x, &y, plane_state, 0,
 -					  plane_state->view.color_plane[0].offset, 0);
 +	plane_color_ctl |= PLANE_COLOR_PLANE_GAMMA_DISABLE;
 +	plane_color_ctl |= glk_plane_color_ctl_alpha(plane_state);
  
 -	return y;
 +	if (fb->format->is_yuv && !icl_is_hdr_plane(dev_priv, plane->id)) {
 +		switch (plane_state->hw.color_encoding) {
 +		case DRM_COLOR_YCBCR_BT709:
 +			plane_color_ctl |= PLANE_COLOR_CSC_MODE_YUV709_TO_RGB709;
 +			break;
 +		case DRM_COLOR_YCBCR_BT2020:
 +			plane_color_ctl |=
 +				PLANE_COLOR_CSC_MODE_YUV2020_TO_RGB2020;
 +			break;
 +		default:
 +			plane_color_ctl |=
 +				PLANE_COLOR_CSC_MODE_YUV601_TO_RGB601;
 +		}
 +		if (plane_state->hw.color_range == DRM_COLOR_YCBCR_FULL_RANGE)
 +			plane_color_ctl |= PLANE_COLOR_YUV_RANGE_CORRECTION_DISABLE;
 +	} else if (fb->format->is_yuv) {
 +		plane_color_ctl |= PLANE_COLOR_INPUT_CSC_ENABLE;
 +		if (plane_state->hw.color_range == DRM_COLOR_YCBCR_FULL_RANGE)
 +			plane_color_ctl |= PLANE_COLOR_YUV_RANGE_CORRECTION_DISABLE;
 +	}
 +
 +	return plane_color_ctl;
  }
  
  static int
* Unmerged path drivers/gpu/drm/i915/display/intel_display.c
diff --git a/drivers/gpu/drm/i915/display/intel_fbdev.c b/drivers/gpu/drm/i915/display/intel_fbdev.c
index 84f853f113b9..cfb81a85c4c8 100644
--- a/drivers/gpu/drm/i915/display/intel_fbdev.c
+++ b/drivers/gpu/drm/i915/display/intel_fbdev.c
@@ -218,8 +218,6 @@ static int intelfb_create(struct drm_fb_helper *helper,
 		goto out_unlock;
 	}
 
-	intel_frontbuffer_flush(to_frontbuffer(ifbdev), ORIGIN_DIRTYFB);
-
 	info = drm_fb_helper_alloc_fbi(helper);
 	if (IS_ERR(info)) {
 		drm_err(&dev_priv->drm, "Failed to allocate fb_info\n");
