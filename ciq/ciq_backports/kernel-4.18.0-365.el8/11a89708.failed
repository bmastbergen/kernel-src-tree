drm/i915/tc: Add/use helpers to retrieve TypeC port properties

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Imre Deak <imre.deak@intel.com>
commit 11a8970865b49c2a1e714ea3ba910d05fdde6944
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/11a89708.failed

Instead of directly accessing the TypeC port internal struct members,
add/use helpers to retrieve the corresponding properties.

No functional change.

	Cc: José Roberto de Souza <jose.souza@intel.com>
	Signed-off-by: Imre Deak <imre.deak@intel.com>
	Reviewed-by: José Roberto de Souza <jose.souza@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210921002313.1132357-6-imre.deak@intel.com
(cherry picked from commit 11a8970865b49c2a1e714ea3ba910d05fdde6944)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_ddi.c
#	drivers/gpu/drm/i915/display/intel_display_power.c
diff --cc drivers/gpu/drm/i915/display/intel_ddi.c
index 0f72647ed48c,0fe77854b455..000000000000
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@@ -1859,6 -285,12 +1859,15 @@@ static void intel_ddi_init_dp_buf_reg(s
  	intel_dp->DP = dig_port->saved_port_bits |
  		DDI_BUF_CTL_ENABLE | DDI_BUF_TRANS_SELECT(0);
  	intel_dp->DP |= DDI_PORT_WIDTH(crtc_state->lane_count);
++<<<<<<< HEAD
++=======
+ 
+ 	if (IS_ALDERLAKE_P(i915) && intel_phy_is_tc(i915, phy)) {
+ 		intel_dp->DP |= ddi_buf_phy_link_rate(crtc_state->port_clock);
+ 		if (!intel_tc_port_in_tbt_alt_mode(dig_port))
+ 			intel_dp->DP |= DDI_BUF_CTL_TC_PHY_OWNERSHIP;
+ 	}
++>>>>>>> 11a8970865b4 (drm/i915/tc: Add/use helpers to retrieve TypeC port properties)
  }
  
  static int icl_calc_tbt_pll_link(struct drm_i915_private *dev_priv,
@@@ -2924,11 -1179,10 +2932,11 @@@ static void icl_mg_phy_ddi_vswing_seque
  	int n_entries, ln;
  	u32 val;
  
- 	if (enc_to_dig_port(encoder)->tc_mode == TC_PORT_TBT_ALT)
+ 	if (intel_tc_port_in_tbt_alt_mode(enc_to_dig_port(encoder)))
  		return;
  
 -	ddi_translations = encoder->get_buf_trans(encoder, crtc_state, &n_entries);
 +	ddi_translations = icl_get_mg_buf_trans(encoder, crtc_state, &n_entries);
 +
  	if (drm_WARN_ON_ONCE(&dev_priv->drm, !ddi_translations))
  		return;
  	if (drm_WARN_ON_ONCE(&dev_priv->drm, level >= n_entries))
@@@ -3062,11 -1316,10 +3070,11 @@@ tgl_dkl_phy_ddi_vswing_sequence(struct 
  	u32 val, dpcnt_mask, dpcnt_val;
  	int n_entries, ln;
  
- 	if (enc_to_dig_port(encoder)->tc_mode == TC_PORT_TBT_ALT)
+ 	if (intel_tc_port_in_tbt_alt_mode(enc_to_dig_port(encoder)))
  		return;
  
 -	ddi_translations = encoder->get_buf_trans(encoder, crtc_state, &n_entries);
 +	ddi_translations = tgl_get_dkl_buf_trans(encoder, crtc_state, &n_entries);
 +
  	if (drm_WARN_ON_ONCE(&dev_priv->drm, !ddi_translations))
  		return;
  	if (drm_WARN_ON_ONCE(&dev_priv->drm, level >= n_entries))
@@@ -3567,10 -2081,12 +3575,15 @@@ icl_program_mg_dp_mode(struct intel_dig
  	u32 ln0, ln1, pin_assignment;
  	u8 width;
  
++<<<<<<< HEAD
 +	if (dig_port->tc_mode == TC_PORT_TBT_ALT)
++=======
+ 	if (!intel_phy_is_tc(dev_priv, phy) ||
+ 	    intel_tc_port_in_tbt_alt_mode(dig_port))
++>>>>>>> 11a8970865b4 (drm/i915/tc: Add/use helpers to retrieve TypeC port properties)
  		return;
  
 -	if (DISPLAY_VER(dev_priv) >= 12) {
 +	if (INTEL_GEN(dev_priv) >= 12) {
  		intel_de_write(dev_priv, HIP_INDEX_REG(tc_port),
  			       HIP_INDEX_VAL(tc_port, 0x0));
  		ln0 = intel_de_read(dev_priv, DKL_DP_MODE(tc_port));
@@@ -3759,6 -2275,189 +3772,192 @@@ static void intel_ddi_power_up_lanes(st
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /* Splitter enable for eDP MSO is limited to certain pipes. */
+ static u8 intel_ddi_splitter_pipe_mask(struct drm_i915_private *i915)
+ {
+ 	if (IS_ALDERLAKE_P(i915))
+ 		return BIT(PIPE_A) | BIT(PIPE_B);
+ 	else
+ 		return BIT(PIPE_A);
+ }
+ 
+ static void intel_ddi_mso_get_config(struct intel_encoder *encoder,
+ 				     struct intel_crtc_state *pipe_config)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);
+ 	struct drm_i915_private *i915 = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 	u32 dss1;
+ 
+ 	if (!HAS_MSO(i915))
+ 		return;
+ 
+ 	dss1 = intel_de_read(i915, ICL_PIPE_DSS_CTL1(pipe));
+ 
+ 	pipe_config->splitter.enable = dss1 & SPLITTER_ENABLE;
+ 	if (!pipe_config->splitter.enable)
+ 		return;
+ 
+ 	if (drm_WARN_ON(&i915->drm, !(intel_ddi_splitter_pipe_mask(i915) & BIT(pipe)))) {
+ 		pipe_config->splitter.enable = false;
+ 		return;
+ 	}
+ 
+ 	switch (dss1 & SPLITTER_CONFIGURATION_MASK) {
+ 	default:
+ 		drm_WARN(&i915->drm, true,
+ 			 "Invalid splitter configuration, dss1=0x%08x\n", dss1);
+ 		fallthrough;
+ 	case SPLITTER_CONFIGURATION_2_SEGMENT:
+ 		pipe_config->splitter.link_count = 2;
+ 		break;
+ 	case SPLITTER_CONFIGURATION_4_SEGMENT:
+ 		pipe_config->splitter.link_count = 4;
+ 		break;
+ 	}
+ 
+ 	pipe_config->splitter.pixel_overlap = REG_FIELD_GET(OVERLAP_PIXELS_MASK, dss1);
+ }
+ 
+ static void intel_ddi_mso_configure(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
+ 	struct drm_i915_private *i915 = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 	u32 dss1 = 0;
+ 
+ 	if (!HAS_MSO(i915))
+ 		return;
+ 
+ 	if (crtc_state->splitter.enable) {
+ 		dss1 |= SPLITTER_ENABLE;
+ 		dss1 |= OVERLAP_PIXELS(crtc_state->splitter.pixel_overlap);
+ 		if (crtc_state->splitter.link_count == 2)
+ 			dss1 |= SPLITTER_CONFIGURATION_2_SEGMENT;
+ 		else
+ 			dss1 |= SPLITTER_CONFIGURATION_4_SEGMENT;
+ 	}
+ 
+ 	intel_de_rmw(i915, ICL_PIPE_DSS_CTL1(pipe),
+ 		     SPLITTER_ENABLE | SPLITTER_CONFIGURATION_MASK |
+ 		     OVERLAP_PIXELS_MASK, dss1);
+ }
+ 
+ static void dg2_ddi_pre_enable_dp(struct intel_atomic_state *state,
+ 				  struct intel_encoder *encoder,
+ 				  const struct intel_crtc_state *crtc_state,
+ 				  const struct drm_connector_state *conn_state)
+ {
+ 	struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
+ 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+ 	struct intel_digital_port *dig_port = enc_to_dig_port(encoder);
+ 	bool is_mst = intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST);
+ 	int level = intel_ddi_dp_level(intel_dp, crtc_state);
+ 
+ 	intel_dp_set_link_params(intel_dp, crtc_state->port_clock,
+ 				 crtc_state->lane_count);
+ 
+ 	/*
+ 	 * 1. Enable Power Wells
+ 	 *
+ 	 * This was handled at the beginning of intel_atomic_commit_tail(),
+ 	 * before we called down into this function.
+ 	 */
+ 
+ 	/* 2. Enable Panel Power if PPS is required */
+ 	intel_pps_on(intel_dp);
+ 
+ 	/*
+ 	 * 3. Enable the port PLL.
+ 	 */
+ 	intel_ddi_enable_clock(encoder, crtc_state);
+ 
+ 	/* 4. Enable IO power */
+ 	if (!intel_tc_port_in_tbt_alt_mode(dig_port))
+ 		dig_port->ddi_io_wakeref = intel_display_power_get(dev_priv,
+ 								   dig_port->ddi_io_power_domain);
+ 
+ 	/*
+ 	 * 5. The rest of the below are substeps under the bspec's "Enable and
+ 	 * Train Display Port" step.  Note that steps that are specific to
+ 	 * MST will be handled by intel_mst_pre_enable_dp() before/after it
+ 	 * calls into this function.  Also intel_mst_pre_enable_dp() only calls
+ 	 * us when active_mst_links==0, so any steps designated for "single
+ 	 * stream or multi-stream master transcoder" can just be performed
+ 	 * unconditionally here.
+ 	 */
+ 
+ 	/*
+ 	 * 5.a Configure Transcoder Clock Select to direct the Port clock to the
+ 	 * Transcoder.
+ 	 */
+ 	intel_ddi_enable_pipe_clock(encoder, crtc_state);
+ 
+ 	/* 5.b Configure transcoder for DP 2.0 128b/132b */
+ 	intel_ddi_config_transcoder_dp2(encoder, crtc_state);
+ 
+ 	/*
+ 	 * 5.c Configure TRANS_DDI_FUNC_CTL DDI Select, DDI Mode Select & MST
+ 	 * Transport Select
+ 	 */
+ 	intel_ddi_config_transcoder_func(encoder, crtc_state);
+ 
+ 	/*
+ 	 * 5.d Configure & enable DP_TP_CTL with link training pattern 1
+ 	 * selected
+ 	 *
+ 	 * This will be handled by the intel_dp_start_link_train() farther
+ 	 * down this function.
+ 	 */
+ 
+ 	/* 5.e Configure voltage swing and related IO settings */
+ 	intel_snps_phy_ddi_vswing_sequence(encoder, crtc_state, level);
+ 
+ 	/*
+ 	 * 5.f Configure and enable DDI_BUF_CTL
+ 	 * 5.g Wait for DDI_BUF_CTL DDI Idle Status = 0b (Not Idle), timeout
+ 	 *     after 1200 us.
+ 	 *
+ 	 * We only configure what the register value will be here.  Actual
+ 	 * enabling happens during link training farther down.
+ 	 */
+ 	intel_ddi_init_dp_buf_reg(encoder, crtc_state);
+ 
+ 	if (!is_mst)
+ 		intel_dp_set_power(intel_dp, DP_SET_POWER_D0);
+ 
+ 	intel_dp_configure_protocol_converter(intel_dp, crtc_state);
+ 	intel_dp_sink_set_decompression_state(intel_dp, crtc_state, true);
+ 	/*
+ 	 * DDI FEC: "anticipates enabling FEC encoding sets the FEC_READY bit
+ 	 * in the FEC_CONFIGURATION register to 1 before initiating link
+ 	 * training
+ 	 */
+ 	intel_dp_sink_set_fec_ready(intel_dp, crtc_state);
+ 	intel_dp_check_frl_training(intel_dp);
+ 	intel_dp_pcon_dsc_configure(intel_dp, crtc_state);
+ 
+ 	/*
+ 	 * 5.h Follow DisplayPort specification training sequence (see notes for
+ 	 *     failure handling)
+ 	 * 5.i If DisplayPort multi-stream - Set DP_TP_CTL link training to Idle
+ 	 *     Pattern, wait for 5 idle patterns (DP_TP_STATUS Min_Idles_Sent)
+ 	 *     (timeout after 800 us)
+ 	 */
+ 	intel_dp_start_link_train(intel_dp, crtc_state);
+ 
+ 	/* 5.j Set DP_TP_CTL link training to Normal */
+ 	if (!is_trans_port_sync_mode(crtc_state))
+ 		intel_dp_stop_link_train(intel_dp, crtc_state);
+ 
+ 	/* 5.k Configure and enable FEC if needed */
+ 	intel_ddi_enable_fec(encoder, crtc_state);
+ 	intel_dsc_enable(encoder, crtc_state);
+ }
+ 
++>>>>>>> 11a8970865b4 (drm/i915/tc: Add/use helpers to retrieve TypeC port properties)
  static void tgl_ddi_pre_enable_dp(struct intel_atomic_state *state,
  				  struct intel_encoder *encoder,
  				  const struct intel_crtc_state *crtc_state,
@@@ -3766,10 -2465,9 +3965,9 @@@
  {
  	struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
  	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
- 	enum phy phy = intel_port_to_phy(dev_priv, encoder->port);
  	struct intel_digital_port *dig_port = enc_to_dig_port(encoder);
  	bool is_mst = intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST);
 -	int level = intel_ddi_dp_level(intel_dp, crtc_state);
 +	int level = intel_ddi_dp_level(intel_dp);
  
  	intel_dp_set_link_params(intel_dp,
  				 crtc_state->port_clock,
@@@ -3904,12 -2606,11 +4101,11 @@@ static void hsw_ddi_pre_enable_dp(struc
  	struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
  	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
  	enum port port = encoder->port;
- 	enum phy phy = intel_port_to_phy(dev_priv, port);
  	struct intel_digital_port *dig_port = enc_to_dig_port(encoder);
  	bool is_mst = intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST);
 -	int level = intel_ddi_dp_level(intel_dp, crtc_state);
 +	int level = intel_ddi_dp_level(intel_dp);
  
 -	if (DISPLAY_VER(dev_priv) < 11)
 +	if (INTEL_GEN(dev_priv) < 11)
  		drm_WARN_ON(&dev_priv->drm,
  			    is_mst && (port == PORT_A || port == PORT_E));
  	else
diff --cc drivers/gpu/drm/i915/display/intel_display_power.c
index e2cb6e6ca250,2410c1a617ea..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display_power.c
+++ b/drivers/gpu/drm/i915/display/intel_display_power.c
@@@ -550,7 -560,7 +550,11 @@@ static void icl_tc_port_assert_ref_held
  	if (drm_WARN_ON(&dev_priv->drm, !dig_port))
  		return;
  
++<<<<<<< HEAD
 +	if (INTEL_GEN(dev_priv) == 11 && dig_port->tc_legacy_port)
++=======
+ 	if (DISPLAY_VER(dev_priv) == 11 && intel_tc_cold_requires_aux_pw(dig_port))
++>>>>>>> 11a8970865b4 (drm/i915/tc: Add/use helpers to retrieve TypeC port properties)
  		return;
  
  	drm_WARN_ON(&dev_priv->drm, !intel_tc_port_ref_held(dig_port));
@@@ -618,11 -628,9 +622,16 @@@ icl_tc_phy_aux_power_well_enable(struc
  	 * or need to enable AUX on a legacy TypeC port as part of the TC-cold
  	 * exit sequence.
  	 */
++<<<<<<< HEAD
 +	timeout_expected = is_tbt;
 +	if (INTEL_GEN(dev_priv) == 11 && dig_port->tc_legacy_port) {
++=======
+ 	timeout_expected = is_tbt || intel_tc_cold_requires_aux_pw(dig_port);
+ 	if (DISPLAY_VER(dev_priv) == 11 && intel_tc_cold_requires_aux_pw(dig_port))
++>>>>>>> 11a8970865b4 (drm/i915/tc: Add/use helpers to retrieve TypeC port properties)
  		icl_tc_cold_exit(dev_priv);
 +		timeout_expected = true;
 +	}
  
  	hsw_wait_for_power_well_enable(dev_priv, power_well, timeout_expected);
  
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi.c
diff --git a/drivers/gpu/drm/i915/display/intel_display.c b/drivers/gpu/drm/i915/display/intel_display.c
index 19f6e7572c75..fd988d646afb 100644
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@ -5759,11 +5759,7 @@ enum intel_display_power_domain intel_port_to_power_domain(enum port port)
 enum intel_display_power_domain
 intel_aux_power_domain(struct intel_digital_port *dig_port)
 {
-	struct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);
-	enum phy phy = intel_port_to_phy(dev_priv, dig_port->base.port);
-
-	if (intel_phy_is_tc(dev_priv, phy) &&
-	    dig_port->tc_mode == TC_PORT_TBT_ALT) {
+	if (intel_tc_port_in_tbt_alt_mode(dig_port)) {
 		switch (dig_port->aux_ch) {
 		case AUX_CH_C:
 			return POWER_DOMAIN_AUX_C_TBT;
* Unmerged path drivers/gpu/drm/i915/display/intel_display_power.c
diff --git a/drivers/gpu/drm/i915/display/intel_dp_aux.c b/drivers/gpu/drm/i915/display/intel_dp_aux.c
index 10fe17b7280d..4b8b2b4323f8 100644
--- a/drivers/gpu/drm/i915/display/intel_dp_aux.c
+++ b/drivers/gpu/drm/i915/display/intel_dp_aux.c
@@ -155,9 +155,6 @@ static u32 skl_get_aux_send_ctl(struct intel_dp *intel_dp,
 				u32 unused)
 {
 	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
-	struct drm_i915_private *i915 =
-			to_i915(dig_port->base.base.dev);
-	enum phy phy = intel_port_to_phy(i915, dig_port->base.port);
 	u32 ret;
 
 	/*
@@ -176,8 +173,7 @@ static u32 skl_get_aux_send_ctl(struct intel_dp *intel_dp,
 	      DP_AUX_CH_CTL_FW_SYNC_PULSE_SKL(32) |
 	      DP_AUX_CH_CTL_SYNC_PULSE_SKL(32);
 
-	if (intel_phy_is_tc(i915, phy) &&
-	    dig_port->tc_mode == TC_PORT_TBT_ALT)
+	if (intel_tc_port_in_tbt_alt_mode(dig_port))
 		ret |= DP_AUX_CH_CTL_TBT_IO;
 
 	return ret;
diff --git a/drivers/gpu/drm/i915/display/intel_dpll_mgr.c b/drivers/gpu/drm/i915/display/intel_dpll_mgr.c
index 7a509f1a5c64..78e2ce0ee3f3 100644
--- a/drivers/gpu/drm/i915/display/intel_dpll_mgr.c
+++ b/drivers/gpu/drm/i915/display/intel_dpll_mgr.c
@@ -24,6 +24,7 @@
 #include "intel_display_types.h"
 #include "intel_dpio_phy.h"
 #include "intel_dpll_mgr.h"
+#include "intel_tc.h"
 
 /**
  * DOC: Display PLLs
@@ -3515,8 +3516,8 @@ static void icl_update_active_dpll(struct intel_atomic_state *state,
 		enc_to_dig_port(encoder);
 
 	if (primary_port &&
-	    (primary_port->tc_mode == TC_PORT_DP_ALT ||
-	     primary_port->tc_mode == TC_PORT_LEGACY))
+	    (intel_tc_port_in_dp_alt_mode(primary_port) ||
+	     intel_tc_port_in_legacy_mode(primary_port)))
 		port_dpll_id = ICL_PORT_DPLL_MG_PHY;
 
 	icl_set_active_port_dpll(crtc_state, port_dpll_id);
diff --git a/drivers/gpu/drm/i915/display/intel_tc.c b/drivers/gpu/drm/i915/display/intel_tc.c
index 2cefc13535a0..5629f3f1657d 100644
--- a/drivers/gpu/drm/i915/display/intel_tc.c
+++ b/drivers/gpu/drm/i915/display/intel_tc.c
@@ -23,6 +23,30 @@ static const char *tc_port_mode_name(enum tc_port_mode mode)
 	return names[mode];
 }
 
+static bool intel_tc_port_in_mode(struct intel_digital_port *dig_port,
+				  enum tc_port_mode mode)
+{
+	struct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);
+	enum phy phy = intel_port_to_phy(i915, dig_port->base.port);
+
+	return intel_phy_is_tc(i915, phy) && dig_port->tc_mode == mode;
+}
+
+bool intel_tc_port_in_tbt_alt_mode(struct intel_digital_port *dig_port)
+{
+	return intel_tc_port_in_mode(dig_port, TC_PORT_TBT_ALT);
+}
+
+bool intel_tc_port_in_dp_alt_mode(struct intel_digital_port *dig_port)
+{
+	return intel_tc_port_in_mode(dig_port, TC_PORT_DP_ALT);
+}
+
+bool intel_tc_port_in_legacy_mode(struct intel_digital_port *dig_port)
+{
+	return intel_tc_port_in_mode(dig_port, TC_PORT_LEGACY);
+}
+
 static enum intel_display_power_domain
 tc_cold_get_power_domain(struct intel_digital_port *dig_port)
 {
diff --git a/drivers/gpu/drm/i915/display/intel_tc.h b/drivers/gpu/drm/i915/display/intel_tc.h
index b619e4736f85..51094b524574 100644
--- a/drivers/gpu/drm/i915/display/intel_tc.h
+++ b/drivers/gpu/drm/i915/display/intel_tc.h
@@ -12,6 +12,10 @@
 struct intel_digital_port;
 struct intel_encoder;
 
+bool intel_tc_port_in_tbt_alt_mode(struct intel_digital_port *dig_port);
+bool intel_tc_port_in_dp_alt_mode(struct intel_digital_port *dig_port);
+bool intel_tc_port_in_legacy_mode(struct intel_digital_port *dig_port);
+
 bool intel_tc_port_connected(struct intel_encoder *encoder);
 u32 intel_tc_port_get_lane_mask(struct intel_digital_port *dig_port);
 u32 intel_tc_port_get_pin_assignment_mask(struct intel_digital_port *dig_port);
