drm/i915: s/intel/hsw/ for hsw/bdw/skl buf trans

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 266152ae61f762258706afa1046c931e5cf19d78
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/266152ae.failed

Give the hsw/bdw/skl buf trans stuff a better namespace.

	Reviewed-by: Jani Nikula <jani.nikula@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210608073603.2408-2-ville.syrjala@linux.intel.com
(cherry picked from commit 266152ae61f762258706afa1046c931e5cf19d78)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_ddi.c
#	drivers/gpu/drm/i915/display/intel_ddi.h
#	drivers/gpu/drm/i915/display/intel_ddi_buf_trans.c
#	drivers/gpu/drm/i915/display/intel_ddi_buf_trans.h
#	drivers/gpu/drm/i915/display/intel_fdi.c
diff --cc drivers/gpu/drm/i915/display/intel_ddi.c
index 0f72647ed48c,a542f67ce49a..000000000000
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@@ -1564,27 -95,25 +1564,29 @@@ static int intel_ddi_hdmi_level(struct 
   * values in advance. This function programs the correct values for
   * DP/eDP/FDI use cases.
   */
++<<<<<<< HEAD
 +static void intel_prepare_dp_ddi_buffers(struct intel_encoder *encoder,
 +					 const struct intel_crtc_state *crtc_state)
++=======
+ void hsw_prepare_dp_ddi_buffers(struct intel_encoder *encoder,
+ 				const struct intel_crtc_state *crtc_state)
++>>>>>>> 266152ae61f7 (drm/i915: s/intel/hsw/ for hsw/bdw/skl buf trans)
  {
  	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
  	u32 iboost_bit = 0;
  	int i, n_entries;
  	enum port port = encoder->port;
- 	const struct ddi_buf_trans *ddi_translations;
+ 	const struct hsw_ddi_buf_trans *ddi_translations;
  
  	if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_ANALOG))
- 		ddi_translations = intel_ddi_get_buf_trans_fdi(dev_priv,
- 							       &n_entries);
+ 		ddi_translations = hsw_ddi_get_buf_trans_fdi(dev_priv, &n_entries);
  	else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
- 		ddi_translations = intel_ddi_get_buf_trans_edp(encoder,
- 							       &n_entries);
+ 		ddi_translations = hsw_ddi_get_buf_trans_edp(encoder, &n_entries);
  	else
- 		ddi_translations = intel_ddi_get_buf_trans_dp(encoder,
- 							      &n_entries);
+ 		ddi_translations = hsw_ddi_get_buf_trans_dp(encoder, &n_entries);
  
  	/* If we're boosting the current, set bit 31 of trans1 */
 -	if (DISPLAY_VER(dev_priv) == 9 && !IS_BROXTON(dev_priv) &&
 -	    intel_bios_encoder_dp_boost_level(encoder->devdata))
 +	if (IS_GEN9_BC(dev_priv) && intel_bios_dp_boost_level(encoder))
  		iboost_bit = DDI_BUF_BALANCE_LEG_ENABLE;
  
  	for (i = 0; i < n_entries; i++) {
@@@ -2529,12 -940,12 +2531,12 @@@ static void skl_ddi_set_iboost(struct i
  	u8 iboost;
  
  	if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))
 -		iboost = intel_bios_encoder_hdmi_boost_level(encoder->devdata);
 +		iboost = intel_bios_hdmi_boost_level(encoder);
  	else
 -		iboost = intel_bios_encoder_dp_boost_level(encoder->devdata);
 +		iboost = intel_bios_dp_boost_level(encoder);
  
  	if (iboost == 0) {
- 		const struct ddi_buf_trans *ddi_translations;
+ 		const struct hsw_ddi_buf_trans *ddi_translations;
  		int n_entries;
  
  		if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))
@@@ -2618,20 -1023,14 +2620,20 @@@ static u8 intel_ddi_dp_voltage_max(stru
  		else
  			icl_get_mg_buf_trans(encoder, crtc_state, &n_entries);
  	} else if (IS_CANNONLAKE(dev_priv)) {
 -		cnl_get_buf_trans(encoder, crtc_state, &n_entries);
 -	} else if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {
 -		bxt_get_buf_trans(encoder, crtc_state, &n_entries);
 +		if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
 +			cnl_get_buf_trans_edp(encoder, &n_entries);
 +		else
 +			cnl_get_buf_trans_dp(encoder, &n_entries);
 +	} else if (IS_GEN9_LP(dev_priv)) {
 +		if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
 +			bxt_get_buf_trans_edp(encoder, &n_entries);
 +		else
 +			bxt_get_buf_trans_dp(encoder, &n_entries);
  	} else {
  		if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
- 			intel_ddi_get_buf_trans_edp(encoder, &n_entries);
+ 			hsw_ddi_get_buf_trans_edp(encoder, &n_entries);
  		else
- 			intel_ddi_get_buf_trans_dp(encoder, &n_entries);
+ 			hsw_ddi_get_buf_trans_dp(encoder, &n_entries);
  	}
  
  	if (drm_WARN_ON(&dev_priv->drm, n_entries < 1))
@@@ -3936,10 -2696,10 +3938,10 @@@ static void hsw_ddi_pre_enable_dp(struc
  		icl_ddi_vswing_sequence(encoder, crtc_state, level);
  	else if (IS_CANNONLAKE(dev_priv))
  		cnl_ddi_vswing_sequence(encoder, crtc_state, level);
 -	else if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))
 +	else if (IS_GEN9_LP(dev_priv))
  		bxt_ddi_vswing_sequence(encoder, crtc_state, level);
  	else
- 		intel_prepare_dp_ddi_buffers(encoder, crtc_state);
+ 		hsw_prepare_dp_ddi_buffers(encoder, crtc_state);
  
  	intel_ddi_power_up_lanes(encoder, crtc_state);
  
@@@ -4393,8 -3138,22 +4395,25 @@@ static void intel_enable_ddi_hdmi(struc
  			    "[CONNECTOR:%d:%s] Failed to configure sink scrambling/TMDS bit clock ratio\n",
  			    connector->base.id, connector->name);
  
++<<<<<<< HEAD
++=======
+ 	if (DISPLAY_VER(dev_priv) >= 12)
+ 		tgl_ddi_vswing_sequence(encoder, crtc_state, level);
+ 	else if (DISPLAY_VER(dev_priv) == 11)
+ 		icl_ddi_vswing_sequence(encoder, crtc_state, level);
+ 	else if (IS_CANNONLAKE(dev_priv))
+ 		cnl_ddi_vswing_sequence(encoder, crtc_state, level);
+ 	else if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))
+ 		bxt_ddi_vswing_sequence(encoder, crtc_state, level);
+ 	else
+ 		hsw_prepare_hdmi_ddi_buffers(encoder, level);
+ 
+ 	if (DISPLAY_VER(dev_priv) == 9 && !IS_BROXTON(dev_priv))
+ 		skl_ddi_set_iboost(encoder, crtc_state, level);
+ 
++>>>>>>> 266152ae61f7 (drm/i915: s/intel/hsw/ for hsw/bdw/skl buf trans)
  	/* Display WA #1143: skl,kbl,cfl */
 -	if (DISPLAY_VER(dev_priv) == 9 && !IS_BROXTON(dev_priv)) {
 +	if (IS_GEN9_BC(dev_priv)) {
  		/*
  		 * For some reason these chicken bits have been
  		 * stuffed into a transcoder register, event though
diff --cc drivers/gpu/drm/i915/display/intel_ddi.h
index 7b82a3407a4c,7d448485d887..000000000000
--- a/drivers/gpu/drm/i915/display/intel_ddi.h
+++ b/drivers/gpu/drm/i915/display/intel_ddi.h
@@@ -34,6 -33,17 +34,17 @@@ void intel_ddi_enable_clock(struct inte
  void hsw_ddi_enable_clock(struct intel_encoder *encoder,
  			  const struct intel_crtc_state *crtc_state);
  void hsw_ddi_disable_clock(struct intel_encoder *encoder);
++<<<<<<< HEAD
++=======
+ bool hsw_ddi_is_clock_enabled(struct intel_encoder *encoder);
+ void hsw_ddi_get_config(struct intel_encoder *encoder,
+ 			struct intel_crtc_state *crtc_state);
+ struct intel_shared_dpll *icl_ddi_combo_get_pll(struct intel_encoder *encoder);
+ void hsw_prepare_dp_ddi_buffers(struct intel_encoder *encoder,
+ 				const struct intel_crtc_state *crtc_state);
+ void intel_wait_ddi_buf_idle(struct drm_i915_private *dev_priv,
+ 			     enum port port);
++>>>>>>> 266152ae61f7 (drm/i915: s/intel/hsw/ for hsw/bdw/skl buf trans)
  void intel_ddi_init(struct drm_i915_private *dev_priv, enum port port);
  bool intel_ddi_get_hw_state(struct intel_encoder *encoder, enum pipe *pipe);
  void intel_ddi_enable_transcoder_func(struct intel_encoder *encoder,
diff --cc drivers/gpu/drm/i915/display/intel_fdi.c
index b2eb96ae10a2,a806e1b83613..000000000000
--- a/drivers/gpu/drm/i915/display/intel_fdi.c
+++ b/drivers/gpu/drm/i915/display/intel_fdi.c
@@@ -550,6 -553,142 +550,145 @@@ train_done
  	drm_dbg_kms(&dev_priv->drm, "FDI train done.\n");
  }
  
++<<<<<<< HEAD
++=======
+ /* Starting with Haswell, different DDI ports can work in FDI mode for
+  * connection to the PCH-located connectors. For this, it is necessary to train
+  * both the DDI port and PCH receiver for the desired DDI buffer settings.
+  *
+  * The recommended port to work in FDI mode is DDI E, which we use here. Also,
+  * please note that when FDI mode is active on DDI E, it shares 2 lines with
+  * DDI A (which is used for eDP)
+  */
+ void hsw_fdi_link_train(struct intel_encoder *encoder,
+ 			const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	u32 temp, i, rx_ctl_val;
+ 	int n_entries;
+ 
+ 	hsw_ddi_get_buf_trans_fdi(dev_priv, &n_entries);
+ 
+ 	hsw_prepare_dp_ddi_buffers(encoder, crtc_state);
+ 
+ 	/* Set the FDI_RX_MISC pwrdn lanes and the 2 workarounds listed at the
+ 	 * mode set "sequence for CRT port" document:
+ 	 * - TP1 to TP2 time with the default value
+ 	 * - FDI delay to 90h
+ 	 *
+ 	 * WaFDIAutoLinkSetTimingOverrride:hsw
+ 	 */
+ 	intel_de_write(dev_priv, FDI_RX_MISC(PIPE_A),
+ 		       FDI_RX_PWRDN_LANE1_VAL(2) | FDI_RX_PWRDN_LANE0_VAL(2) | FDI_RX_TP1_TO_TP2_48 | FDI_RX_FDI_DELAY_90);
+ 
+ 	/* Enable the PCH Receiver FDI PLL */
+ 	rx_ctl_val = dev_priv->fdi_rx_config | FDI_RX_ENHANCE_FRAME_ENABLE |
+ 		     FDI_RX_PLL_ENABLE |
+ 		     FDI_DP_PORT_WIDTH(crtc_state->fdi_lanes);
+ 	intel_de_write(dev_priv, FDI_RX_CTL(PIPE_A), rx_ctl_val);
+ 	intel_de_posting_read(dev_priv, FDI_RX_CTL(PIPE_A));
+ 	udelay(220);
+ 
+ 	/* Switch from Rawclk to PCDclk */
+ 	rx_ctl_val |= FDI_PCDCLK;
+ 	intel_de_write(dev_priv, FDI_RX_CTL(PIPE_A), rx_ctl_val);
+ 
+ 	/* Configure Port Clock Select */
+ 	drm_WARN_ON(&dev_priv->drm, crtc_state->shared_dpll->info->id != DPLL_ID_SPLL);
+ 	intel_ddi_enable_clock(encoder, crtc_state);
+ 
+ 	/* Start the training iterating through available voltages and emphasis,
+ 	 * testing each value twice. */
+ 	for (i = 0; i < n_entries * 2; i++) {
+ 		/* Configure DP_TP_CTL with auto-training */
+ 		intel_de_write(dev_priv, DP_TP_CTL(PORT_E),
+ 			       DP_TP_CTL_FDI_AUTOTRAIN |
+ 			       DP_TP_CTL_ENHANCED_FRAME_ENABLE |
+ 			       DP_TP_CTL_LINK_TRAIN_PAT1 |
+ 			       DP_TP_CTL_ENABLE);
+ 
+ 		/* Configure and enable DDI_BUF_CTL for DDI E with next voltage.
+ 		 * DDI E does not support port reversal, the functionality is
+ 		 * achieved on the PCH side in FDI_RX_CTL, so no need to set the
+ 		 * port reversal bit */
+ 		intel_de_write(dev_priv, DDI_BUF_CTL(PORT_E),
+ 			       DDI_BUF_CTL_ENABLE | ((crtc_state->fdi_lanes - 1) << 1) | DDI_BUF_TRANS_SELECT(i / 2));
+ 		intel_de_posting_read(dev_priv, DDI_BUF_CTL(PORT_E));
+ 
+ 		udelay(600);
+ 
+ 		/* Program PCH FDI Receiver TU */
+ 		intel_de_write(dev_priv, FDI_RX_TUSIZE1(PIPE_A), TU_SIZE(64));
+ 
+ 		/* Enable PCH FDI Receiver with auto-training */
+ 		rx_ctl_val |= FDI_RX_ENABLE | FDI_LINK_TRAIN_AUTO;
+ 		intel_de_write(dev_priv, FDI_RX_CTL(PIPE_A), rx_ctl_val);
+ 		intel_de_posting_read(dev_priv, FDI_RX_CTL(PIPE_A));
+ 
+ 		/* Wait for FDI receiver lane calibration */
+ 		udelay(30);
+ 
+ 		/* Unset FDI_RX_MISC pwrdn lanes */
+ 		temp = intel_de_read(dev_priv, FDI_RX_MISC(PIPE_A));
+ 		temp &= ~(FDI_RX_PWRDN_LANE1_MASK | FDI_RX_PWRDN_LANE0_MASK);
+ 		intel_de_write(dev_priv, FDI_RX_MISC(PIPE_A), temp);
+ 		intel_de_posting_read(dev_priv, FDI_RX_MISC(PIPE_A));
+ 
+ 		/* Wait for FDI auto training time */
+ 		udelay(5);
+ 
+ 		temp = intel_de_read(dev_priv, DP_TP_STATUS(PORT_E));
+ 		if (temp & DP_TP_STATUS_AUTOTRAIN_DONE) {
+ 			drm_dbg_kms(&dev_priv->drm,
+ 				    "FDI link training done on step %d\n", i);
+ 			break;
+ 		}
+ 
+ 		/*
+ 		 * Leave things enabled even if we failed to train FDI.
+ 		 * Results in less fireworks from the state checker.
+ 		 */
+ 		if (i == n_entries * 2 - 1) {
+ 			drm_err(&dev_priv->drm, "FDI link training failed!\n");
+ 			break;
+ 		}
+ 
+ 		rx_ctl_val &= ~FDI_RX_ENABLE;
+ 		intel_de_write(dev_priv, FDI_RX_CTL(PIPE_A), rx_ctl_val);
+ 		intel_de_posting_read(dev_priv, FDI_RX_CTL(PIPE_A));
+ 
+ 		temp = intel_de_read(dev_priv, DDI_BUF_CTL(PORT_E));
+ 		temp &= ~DDI_BUF_CTL_ENABLE;
+ 		intel_de_write(dev_priv, DDI_BUF_CTL(PORT_E), temp);
+ 		intel_de_posting_read(dev_priv, DDI_BUF_CTL(PORT_E));
+ 
+ 		/* Disable DP_TP_CTL and FDI_RX_CTL and retry */
+ 		temp = intel_de_read(dev_priv, DP_TP_CTL(PORT_E));
+ 		temp &= ~(DP_TP_CTL_ENABLE | DP_TP_CTL_LINK_TRAIN_MASK);
+ 		temp |= DP_TP_CTL_LINK_TRAIN_PAT1;
+ 		intel_de_write(dev_priv, DP_TP_CTL(PORT_E), temp);
+ 		intel_de_posting_read(dev_priv, DP_TP_CTL(PORT_E));
+ 
+ 		intel_wait_ddi_buf_idle(dev_priv, PORT_E);
+ 
+ 		/* Reset FDI_RX_MISC pwrdn lanes */
+ 		temp = intel_de_read(dev_priv, FDI_RX_MISC(PIPE_A));
+ 		temp &= ~(FDI_RX_PWRDN_LANE1_MASK | FDI_RX_PWRDN_LANE0_MASK);
+ 		temp |= FDI_RX_PWRDN_LANE1_VAL(2) | FDI_RX_PWRDN_LANE0_VAL(2);
+ 		intel_de_write(dev_priv, FDI_RX_MISC(PIPE_A), temp);
+ 		intel_de_posting_read(dev_priv, FDI_RX_MISC(PIPE_A));
+ 	}
+ 
+ 	/* Enable normal pixel sending for FDI */
+ 	intel_de_write(dev_priv, DP_TP_CTL(PORT_E),
+ 		       DP_TP_CTL_FDI_AUTOTRAIN |
+ 		       DP_TP_CTL_LINK_TRAIN_NORMAL |
+ 		       DP_TP_CTL_ENHANCED_FRAME_ENABLE |
+ 		       DP_TP_CTL_ENABLE);
+ }
+ 
++>>>>>>> 266152ae61f7 (drm/i915: s/intel/hsw/ for hsw/bdw/skl buf trans)
  void ilk_fdi_pll_enable(const struct intel_crtc_state *crtc_state)
  {
  	struct intel_crtc *intel_crtc = to_intel_crtc(crtc_state->uapi.crtc);
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi_buf_trans.c
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi_buf_trans.h
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi.c
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi.h
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi_buf_trans.c
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi_buf_trans.h
* Unmerged path drivers/gpu/drm/i915/display/intel_fdi.c
