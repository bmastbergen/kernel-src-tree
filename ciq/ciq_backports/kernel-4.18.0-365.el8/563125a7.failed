netfilter: nftables: generalize set extension to support for several expressions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 563125a73ac30d7036ae69ca35c40500562c1de4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/563125a7.failed

This patch replaces NFT_SET_EXPR by NFT_SET_EXT_EXPRESSIONS. This new
extension allows to attach several expressions to one set element (not
only one single expression as NFT_SET_EXPR provides). This patch
prepares for support for several expressions per set element in the
netlink userspace API.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 563125a73ac30d7036ae69ca35c40500562c1de4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables.h
#	net/netfilter/nf_tables_api.c
#	net/netfilter/nft_dynset.c
diff --cc include/net/netfilter/nf_tables.h
index c33d7d0a7020,bba56f2ce60c..000000000000
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@@ -416,8 -421,21 +416,26 @@@ struct nft_set_type 
  };
  #define to_set_type(o) container_of(o, struct nft_set_type, ops)
  
++<<<<<<< HEAD
 +int nft_register_set(struct nft_set_type *type);
 +void nft_unregister_set(struct nft_set_type *type);
++=======
+ struct nft_set_elem_expr {
+ 	u8				size;
+ 	unsigned char			data[]
+ 		__attribute__((aligned(__alignof__(struct nft_expr))));
+ };
+ 
+ #define nft_setelem_expr_at(__elem_expr, __offset)			\
+ 	((struct nft_expr *)&__elem_expr->data[__offset])
+ 
+ #define nft_setelem_expr_foreach(__expr, __elem_expr, __size)		\
+ 	for (__expr = nft_setelem_expr_at(__elem_expr, 0), __size = 0;	\
+ 	     __size < (__elem_expr)->size;				\
+ 	     __size += (__expr)->ops->size, __expr = ((void *)(__expr)) + (__expr)->ops->size)
+ 
+ #define NFT_SET_EXPR_MAX	2
++>>>>>>> 563125a73ac3 (netfilter: nftables: generalize set extension to support for several expressions)
  
  /**
   * 	struct nft_set - nf_tables set instance
diff --cc net/netfilter/nf_tables_api.c
index 447a0cf7802a,a3d5014dd246..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -4939,6 -5175,47 +4972,50 @@@ static void nf_tables_set_elem_destroy(
  	kfree(elem);
  }
  
++<<<<<<< HEAD
++=======
+ static int nft_set_elem_expr_clone(const struct nft_ctx *ctx,
+ 				   struct nft_set *set,
+ 				   struct nft_expr *expr_array[])
+ {
+ 	struct nft_expr *expr;
+ 	int err, i, k;
+ 
+ 	for (i = 0; i < set->num_exprs; i++) {
+ 		expr = kzalloc(set->exprs[i]->ops->size, GFP_KERNEL);
+ 		if (!expr)
+ 			goto err_expr;
+ 
+ 		err = nft_expr_clone(expr, set->exprs[i]);
+ 		if (err < 0) {
+ 			nft_expr_destroy(ctx, expr);
+ 			goto err_expr;
+ 		}
+ 		expr_array[i] = expr;
+ 	}
+ 
+ 	return 0;
+ 
+ err_expr:
+ 	for (k = i - 1; k >= 0; k++)
+ 		nft_expr_destroy(ctx, expr_array[i]);
+ 
+ 	return -ENOMEM;
+ }
+ 
+ static void nft_set_elem_expr_setup(const struct nft_set_ext *ext, int i,
+ 				    struct nft_expr *expr_array[])
+ {
+ 	struct nft_set_elem_expr *elem_expr = nft_set_ext_expr(ext);
+ 	struct nft_expr *expr = nft_setelem_expr_at(elem_expr, elem_expr->size);
+ 
+ 	memcpy(expr, expr_array[i], expr_array[i]->ops->size);
+ 	elem_expr->size += expr_array[i]->ops->size;
+ 	kfree(expr_array[i]);
+ 	expr_array[i] = NULL;
+ }
+ 
++>>>>>>> 563125a73ac3 (netfilter: nftables: generalize set extension to support for several expressions)
  static int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,
  			    const struct nlattr *attr, u32 nlmsg_flags)
  {
@@@ -4951,13 -5229,13 +5028,19 @@@
  	struct nft_object *obj = NULL;
  	struct nft_userdata *udata;
  	struct nft_data_desc desc;
 +	struct nft_data data;
  	enum nft_registers dreg;
  	struct nft_trans *trans;
- 	u32 flags = 0;
+ 	u32 flags = 0, size = 0;
  	u64 timeout;
++<<<<<<< HEAD
 +	u8 ulen;
 +	int err;
++=======
+ 	u64 expiration;
+ 	int err, i;
+ 	u8 ulen;
++>>>>>>> 563125a73ac3 (netfilter: nftables: generalize set extension to support for several expressions)
  
  	err = nla_parse_nested_deprecated(nla, NFTA_SET_ELEM_MAX, attr,
  					  nft_set_elem_policy, NULL);
@@@ -5027,6 -5338,15 +5110,18 @@@
  			nft_set_ext_add(&tmpl, NFT_SET_EXT_TIMEOUT);
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (set->num_exprs) {
+ 		for (i = 0; i < set->num_exprs; i++)
+ 			size += expr_array[i]->ops->size;
+ 
+ 		nft_set_ext_add_length(&tmpl, NFT_SET_EXT_EXPRESSIONS,
+ 				       sizeof(struct nft_set_elem_expr) +
+ 				       size);
+ 	}
+ 
++>>>>>>> 563125a73ac3 (netfilter: nftables: generalize set extension to support for several expressions)
  	if (nla[NFTA_SET_ELEM_OBJREF] != NULL) {
  		if (!(set->flags & NFT_SET_OBJECT)) {
  			err = -EINVAL;
@@@ -5111,6 -5427,8 +5206,11 @@@
  		*nft_set_ext_obj(ext) = obj;
  		obj->use++;
  	}
++<<<<<<< HEAD
++=======
+ 	for (i = 0; i < set->num_exprs; i++)
+ 		nft_set_elem_expr_setup(ext, i, expr_array);
++>>>>>>> 563125a73ac3 (netfilter: nftables: generalize set extension to support for several expressions)
  
  	trans = nft_trans_elem_alloc(ctx, NFT_MSG_NEWSETELEM, set);
  	if (trans == NULL)
diff --cc net/netfilter/nft_dynset.c
index f4087af55c14,d9e609b2e5d4..000000000000
--- a/net/netfilter/nft_dynset.c
+++ b/net/netfilter/nft_dynset.c
@@@ -109,9 -163,9 +162,9 @@@ static int nft_dynset_init(const struc
  	u8 genmask = nft_genmask_next(ctx->net);
  	struct nft_set *set;
  	u64 timeout;
- 	int err;
+ 	int err, i;
  
 -	lockdep_assert_held(&ctx->net->nft.commit_mutex);
 +	lockdep_assert_held(&ctx->net->nft_commit_mutex);
  
  	if (tb[NFTA_DYNSET_SET_NAME] == NULL ||
  	    tb[NFTA_DYNSET_OP] == NULL ||
@@@ -179,18 -232,23 +232,29 @@@
  	} else if (set->flags & NFT_SET_MAP)
  		return -EINVAL;
  
- 	if (tb[NFTA_DYNSET_EXPR] != NULL) {
+ 	if (tb[NFTA_DYNSET_EXPR]) {
+ 		struct nft_expr *dynset_expr;
+ 
  		if (!(set->flags & NFT_SET_EVAL))
  			return -EINVAL;
 +		if (!nft_set_is_anonymous(set))
 +			return -EOPNOTSUPP;
  
- 		priv->expr = nft_set_elem_expr_alloc(ctx, set,
- 						     tb[NFTA_DYNSET_EXPR]);
- 		if (IS_ERR(priv->expr))
- 			return PTR_ERR(priv->expr);
+ 		dynset_expr = nft_dynset_expr_alloc(ctx, set,
+ 						    tb[NFTA_DYNSET_EXPR], 0);
+ 		if (IS_ERR(dynset_expr))
+ 			return PTR_ERR(dynset_expr);
  
++<<<<<<< HEAD
 +		if (set->expr && set->expr->ops != priv->expr->ops) {
++=======
+ 		priv->num_exprs++;
+ 		priv->expr_array[0] = dynset_expr;
+ 
+ 		if (set->num_exprs > 1 ||
+ 		    (set->num_exprs == 1 &&
+ 		     dynset_expr->ops != set->exprs[0]->ops)) {
++>>>>>>> 563125a73ac3 (netfilter: nftables: generalize set extension to support for several expressions)
  			err = -EOPNOTSUPP;
  			goto err_expr_free;
  		}
@@@ -200,14 -258,13 +264,15 @@@
  	nft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_KEY, set->klen);
  	if (set->flags & NFT_SET_MAP)
  		nft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_DATA, set->dlen);
- 	if (priv->expr != NULL)
- 		nft_set_ext_add_length(&priv->tmpl, NFT_SET_EXT_EXPR,
- 				       priv->expr->ops->size);
+ 
+ 	if (priv->num_exprs)
+ 		nft_dynset_ext_add_expr(priv);
+ 
  	if (set->flags & NFT_SET_TIMEOUT) {
 -		if (timeout || set->timeout)
 +		if (timeout || set->timeout) {
 +			nft_set_ext_add(&priv->tmpl, NFT_SET_EXT_TIMEOUT);
  			nft_set_ext_add(&priv->tmpl, NFT_SET_EXT_EXPIRATION);
 +		}
  	}
  
  	priv->timeout = timeout;
@@@ -267,11 -329,13 +333,13 @@@ static int nft_dynset_dump(struct sk_bu
  	if (nla_put_string(skb, NFTA_DYNSET_SET_NAME, priv->set->name))
  		goto nla_put_failure;
  	if (nla_put_be64(skb, NFTA_DYNSET_TIMEOUT,
 -			 cpu_to_be64(jiffies_to_msecs(priv->timeout)),
 +			 nf_jiffies64_to_msecs(priv->timeout),
  			 NFTA_DYNSET_PAD))
  		goto nla_put_failure;
- 	if (priv->expr && nft_expr_dump(skb, NFTA_DYNSET_EXPR, priv->expr))
- 		goto nla_put_failure;
+ 	if (priv->num_exprs == 1) {
+ 		if (nft_expr_dump(skb, NFTA_DYNSET_EXPR, priv->expr_array[0]))
+ 			goto nla_put_failure;
+ 	}
  	if (nla_put_be32(skb, NFTA_DYNSET_FLAGS, htonl(flags)))
  		goto nla_put_failure;
  	return 0;
* Unmerged path include/net/netfilter/nf_tables.h
* Unmerged path net/netfilter/nf_tables_api.c
* Unmerged path net/netfilter/nft_dynset.c
diff --git a/net/netfilter/nft_set_hash.c b/net/netfilter/nft_set_hash.c
index c842e4dbd0dc..70b1c8847f28 100644
--- a/net/netfilter/nft_set_hash.c
+++ b/net/netfilter/nft_set_hash.c
@@ -278,6 +278,22 @@ static void nft_rhash_walk(const struct nft_ctx *ctx, struct nft_set *set,
 	rhashtable_walk_exit(&hti);
 }
 
+static bool nft_rhash_expr_needs_gc_run(const struct nft_set *set,
+					struct nft_set_ext *ext)
+{
+	struct nft_set_elem_expr *elem_expr = nft_set_ext_expr(ext);
+	struct nft_expr *expr;
+	u32 size;
+
+	nft_setelem_expr_foreach(expr, elem_expr, size) {
+		if (expr->ops->gc &&
+		    expr->ops->gc(read_pnet(&set->net), expr))
+			return true;
+	}
+
+	return false;
+}
+
 static void nft_rhash_gc(struct work_struct *work)
 {
 	struct nft_set *set;
@@ -299,16 +315,13 @@ static void nft_rhash_gc(struct work_struct *work)
 			continue;
 		}
 
-		if (nft_set_ext_exists(&he->ext, NFT_SET_EXT_EXPR)) {
-			struct nft_expr *expr = nft_set_ext_expr(&he->ext);
+		if (nft_set_ext_exists(&he->ext, NFT_SET_EXT_EXPRESSIONS) &&
+		    nft_rhash_expr_needs_gc_run(set, &he->ext))
+			goto needs_gc_run;
 
-			if (expr->ops->gc &&
-			    expr->ops->gc(read_pnet(&set->net), expr))
-				goto gc;
-		}
 		if (!nft_set_elem_expired(&he->ext))
 			continue;
-gc:
+needs_gc_run:
 		if (nft_set_elem_mark_busy(&he->ext))
 			continue;
 
