x86/fpu: Use fpstate::size

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit be31dfdfd75b172af3ddcfa7511cdc3bb7adb25e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/be31dfdf.failed

Make use of fpstate::size in various places which require the buffer size
information for sanity checks or memcpy() sizing.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20211013145322.973518954@linutronix.de
(cherry picked from commit be31dfdfd75b172af3ddcfa7511cdc3bb7adb25e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/fpu/core.c
#	arch/x86/kernel/fpu/signal.c
diff --cc arch/x86/kernel/fpu/core.c
index 3f16056105e8,cb48c80ce5e3..000000000000
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@@ -153,12 -166,12 +153,19 @@@ void fpu_swap_kvm_fpu(struct fpu *save
  	fpregs_lock();
  
  	if (save) {
++<<<<<<< HEAD
 +		if (test_thread_flag(TIF_NEED_FPU_LOAD)) {
 +			memcpy(&save->state, &current->thread.fpu.state,
 +			       fpu_kernel_xstate_size);
 +		} else {
++=======
+ 		struct fpstate *fpcur = current->thread.fpu.fpstate;
+ 
+ 		if (test_thread_flag(TIF_NEED_FPU_LOAD))
+ 			memcpy(&save->fpstate->regs, &fpcur->regs, fpcur->size);
+ 		else
++>>>>>>> be31dfdfd75b (x86/fpu: Use fpstate::size)
  			save_fpregs_to_fpstate(save);
- 		}
  	}
  
  	if (rstor) {
@@@ -367,11 -395,12 +374,18 @@@ int fpu_clone(struct task_struct *dst
  	 * child's FPU context, without any memory-to-memory copying.
  	 */
  	fpregs_lock();
++<<<<<<< HEAD
 +	if (test_thread_flag(TIF_NEED_FPU_LOAD))
 +		memcpy(&dst_fpu->state, &src_fpu->state, fpu_kernel_xstate_size);
 +
 +	else
++=======
+ 	if (test_thread_flag(TIF_NEED_FPU_LOAD)) {
+ 		memcpy(&dst_fpu->fpstate->regs, &src_fpu->fpstate->regs,
+ 		       dst_fpu->fpstate->size);
+ 	} else {
++>>>>>>> be31dfdfd75b (x86/fpu: Use fpstate::size)
  		save_fpregs_to_fpstate(dst_fpu);
 -	}
  	fpregs_unlock();
  
  	trace_x86_fpu_copy_src(src_fpu);
diff --cc arch/x86/kernel/fpu/signal.c
index f74c29985497,aa9329189864..000000000000
--- a/arch/x86/kernel/fpu/signal.c
+++ b/arch/x86/kernel/fpu/signal.c
@@@ -305,19 -307,19 +305,25 @@@ retry
  
  	fpregs_mark_activate();
  	fpregs_unlock();
 -	return true;
 +	return 0;
  }
  
 -static bool __fpu_restore_sig(void __user *buf, void __user *buf_fx,
 -			      bool ia32_fxstate)
 +static int __fpu_restore_sig(void __user *buf, void __user *buf_fx,
 +			     bool ia32_fxstate)
  {
- 	int state_size = fpu_kernel_xstate_size;
  	struct task_struct *tsk = current;
  	struct fpu *fpu = &tsk->thread.fpu;
  	struct user_i387_ia32_struct env;
++<<<<<<< HEAD
 +	u64 user_xfeatures = 0;
 +	bool fx_only = false;
 +	int ret;
++=======
+ 	bool success, fx_only = false;
+ 	union fpregs_state *fpregs;
+ 	unsigned int state_size;
+ 	u64 user_xfeatures = 0;
++>>>>>>> be31dfdfd75b (x86/fpu: Use fpstate::size)
  
  	if (use_xsave()) {
  		struct _fpx_sw_bytes fx_sw_user;
* Unmerged path arch/x86/kernel/fpu/core.c
* Unmerged path arch/x86/kernel/fpu/signal.c
