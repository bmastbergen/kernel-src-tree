netfilter: nf_tables: enable set expiration time for set elements

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Laura Garcia Liebana <nevola@gmail.com>
commit 79ebb5bb4e38a58ca796dd242b855a4982e101d7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/79ebb5bb.failed

Currently, the expiration of every element in a set or map
is a read-only parameter generated at kernel side.

This change will permit to set a certain expiration date
per element that will be required, for example, during
stateful replication among several nodes.

This patch handles the NFTA_SET_ELEM_EXPIRATION in order
to configure the expiration parameter per element, or
will use the timeout in the case that the expiration
is not set.

	Signed-off-by: Laura Garcia Liebana <nevola@gmail.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 79ebb5bb4e38a58ca796dd242b855a4982e101d7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables.h
#	net/netfilter/nf_tables_api.c
diff --cc include/net/netfilter/nf_tables.h
index aa5b025771b4,9e8493aad49d..000000000000
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@@ -665,8 -635,8 +665,13 @@@ static inline struct nft_object **nft_s
  
  void *nft_set_elem_init(const struct nft_set *set,
  			const struct nft_set_ext_tmpl *tmpl,
++<<<<<<< HEAD
 +			const u32 *key, const u32 *key_end, const u32 *data,
 +			u64 timeout, gfp_t gfp);
++=======
+ 			const u32 *key, const u32 *data,
+ 			u64 timeout, u64 expiration, gfp_t gfp);
++>>>>>>> 79ebb5bb4e38 (netfilter: nf_tables: enable set expiration time for set elements)
  void nft_set_elem_destroy(const struct nft_set *set, void *elem,
  			  bool destroy_expr);
  
diff --cc net/netfilter/nf_tables_api.c
index 85840bbc7f25,412bb85e9d29..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -4818,8 -4326,8 +4819,13 @@@ static struct nft_trans *nft_trans_elem
  
  void *nft_set_elem_init(const struct nft_set *set,
  			const struct nft_set_ext_tmpl *tmpl,
++<<<<<<< HEAD
 +			const u32 *key, const u32 *key_end, const u32 *data,
 +			u64 timeout, gfp_t gfp)
++=======
+ 			const u32 *key, const u32 *data,
+ 			u64 timeout, u64 expiration, gfp_t gfp)
++>>>>>>> 79ebb5bb4e38 (netfilter: nf_tables: enable set expiration time for set elements)
  {
  	struct nft_set_ext *ext;
  	void *elem;
@@@ -4832,13 -4340,13 +4838,15 @@@
  	nft_set_ext_init(ext, tmpl);
  
  	memcpy(nft_set_ext_key(ext), key, set->klen);
 +	if (nft_set_ext_exists(ext, NFT_SET_EXT_KEY_END))
 +		memcpy(nft_set_ext_key_end(ext), key_end, set->klen);
  	if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
  		memcpy(nft_set_ext_data(ext), data, set->dlen);
- 	if (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION))
- 		*nft_set_ext_expiration(ext) =
- 			get_jiffies_64() + timeout;
+ 	if (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION)) {
+ 		*nft_set_ext_expiration(ext) = get_jiffies_64() + expiration;
+ 		if (expiration == 0)
+ 			*nft_set_ext_expiration(ext) += timeout;
+ 	}
  	if (nft_set_ext_exists(ext, NFT_SET_EXT_TIMEOUT))
  		*nft_set_ext_timeout(ext) = timeout;
  
@@@ -4952,22 -4455,25 +4961,37 @@@ static int nft_add_set_elem(struct nft_
  		timeout = set->timeout;
  	}
  
++<<<<<<< HEAD
 +	err = nft_setelem_parse_key(ctx, set, &elem.key.val,
 +				    nla[NFTA_SET_ELEM_KEY]);
++=======
+ 	expiration = 0;
+ 	if (nla[NFTA_SET_ELEM_EXPIRATION] != NULL) {
+ 		if (!(set->flags & NFT_SET_TIMEOUT))
+ 			return -EINVAL;
+ 		err = nf_msecs_to_jiffies64(nla[NFTA_SET_ELEM_EXPIRATION],
+ 					    &expiration);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	err = nft_data_init(ctx, &elem.key.val, sizeof(elem.key), &d1,
+ 			    nla[NFTA_SET_ELEM_KEY]);
++>>>>>>> 79ebb5bb4e38 (netfilter: nf_tables: enable set expiration time for set elements)
  	if (err < 0)
 -		goto err1;
 -	err = -EINVAL;
 -	if (d1.type != NFT_DATA_VALUE || d1.len != set->klen)
 -		goto err2;
 +		return err;
 +
 +	nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, set->klen);
 +
 +	if (nla[NFTA_SET_ELEM_KEY_END]) {
 +		err = nft_setelem_parse_key(ctx, set, &elem.key_end.val,
 +					    nla[NFTA_SET_ELEM_KEY_END]);
 +		if (err < 0)
 +			goto err_parse_key;
 +
 +		nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY_END, set->klen);
 +	}
  
 -	nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, d1.len);
  	if (timeout > 0) {
  		nft_set_ext_add(&tmpl, NFT_SET_EXT_EXPIRATION);
  		if (timeout != set->timeout)
@@@ -5040,11 -4546,10 +5064,16 @@@
  	}
  
  	err = -ENOMEM;
++<<<<<<< HEAD
 +	elem.priv = nft_set_elem_init(set, &tmpl, elem.key.val.data,
 +				      elem.key_end.val.data, data.data,
 +				      timeout, GFP_KERNEL);
++=======
+ 	elem.priv = nft_set_elem_init(set, &tmpl, elem.key.val.data, data.data,
+ 				      timeout, expiration, GFP_KERNEL);
++>>>>>>> 79ebb5bb4e38 (netfilter: nf_tables: enable set expiration time for set elements)
  	if (elem.priv == NULL)
 -		goto err3;
 +		goto err_parse_data;
  
  	ext = nft_set_elem_ext(set, elem.priv);
  	if (flags)
@@@ -5231,28 -4736,22 +5260,33 @@@ static int nft_del_setelem(struct nft_c
  	if (flags != 0)
  		nft_set_ext_add(&tmpl, NFT_SET_EXT_FLAGS);
  
 -	err = nft_data_init(ctx, &elem.key.val, sizeof(elem.key), &desc,
 -			    nla[NFTA_SET_ELEM_KEY]);
 +	err = nft_setelem_parse_key(ctx, set, &elem.key.val,
 +				    nla[NFTA_SET_ELEM_KEY]);
  	if (err < 0)
 -		goto err1;
 +		return err;
  
 -	err = -EINVAL;
 -	if (desc.type != NFT_DATA_VALUE || desc.len != set->klen)
 -		goto err2;
 +	nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, set->klen);
  
 -	nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, desc.len);
 +	if (nla[NFTA_SET_ELEM_KEY_END]) {
 +		err = nft_setelem_parse_key(ctx, set, &elem.key_end.val,
 +					    nla[NFTA_SET_ELEM_KEY_END]);
 +		if (err < 0)
 +			return err;
 +
 +		nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY_END, set->klen);
 +	}
  
  	err = -ENOMEM;
++<<<<<<< HEAD
 +	elem.priv = nft_set_elem_init(set, &tmpl, elem.key.val.data,
 +				      elem.key_end.val.data, NULL, 0,
 +				      GFP_KERNEL);
++=======
+ 	elem.priv = nft_set_elem_init(set, &tmpl, elem.key.val.data, NULL, 0,
+ 				      0, GFP_KERNEL);
++>>>>>>> 79ebb5bb4e38 (netfilter: nf_tables: enable set expiration time for set elements)
  	if (elem.priv == NULL)
 -		goto err2;
 +		goto fail_elem;
  
  	ext = nft_set_elem_ext(set, elem.priv);
  	if (flags)
* Unmerged path include/net/netfilter/nf_tables.h
* Unmerged path net/netfilter/nf_tables_api.c
diff --git a/net/netfilter/nft_dynset.c b/net/netfilter/nft_dynset.c
index 28693d7ee5a0..c760827c426c 100644
--- a/net/netfilter/nft_dynset.c
+++ b/net/netfilter/nft_dynset.c
@@ -43,7 +43,7 @@ static void *nft_dynset_new(struct nft_set *set, const struct nft_expr *expr,
 	elem = nft_set_elem_init(set, &priv->tmpl,
 				 &regs->data[priv->sreg_key], NULL,
 				 &regs->data[priv->sreg_data],
-				 timeout, GFP_ATOMIC);
+				 timeout, 0, GFP_ATOMIC);
 	if (elem == NULL)
 		goto err1;
 
