kasan: add macros to simplify checking test constraints

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Andrey Konovalov <andreyknvl@google.com>
commit da17e377723f50c7acd019e39cfeeca342415714
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/da17e377.failed

Some KASAN tests require specific kernel configs to be enabled.
Instead of copy-pasting the checks for these configs add a few helper
macros and use them.

Link: https://linux-review.googlesource.com/id/I237484a7fddfedf4a4aae9cc61ecbcdbe85a0a63
Link: https://lkml.kernel.org/r/6a0fcdb9676b7e869cfc415893ede12d916c246c.1610733117.git.andreyknvl@google.com
	Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
	Suggested-by: Alexander Potapenko <glider@google.com>
	Reviewed-by: Marco Elver <elver@google.com>
	Reviewed-by: Alexander Potapenko <glider@google.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Branislav Rankov <Branislav.Rankov@arm.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Evgenii Stepanov <eugenis@google.com>
	Cc: Kevin Brodsky <kevin.brodsky@arm.com>
	Cc: Peter Collingbourne <pcc@google.com>
	Cc: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit da17e377723f50c7acd019e39cfeeca342415714)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/test_kasan.c
diff --cc lib/test_kasan.c
index 5679dda37d78,714ea27fcc3e..000000000000
--- a/lib/test_kasan.c
+++ b/lib/test_kasan.c
@@@ -27,24 -21,73 +27,67 @@@
  
  #include <asm/page.h>
  
 -#include <kunit/test.h>
 -
  #include "../mm/kasan/kasan.h"
  
 -#define OOB_TAG_OFF (IS_ENABLED(CONFIG_KASAN_GENERIC) ? 0 : KASAN_GRANULE_SIZE)
 +#define OOB_TAG_OFF (IS_ENABLED(CONFIG_KASAN_GENERIC) ? 0 : KASAN_SHADOW_SCALE_SIZE)
  
  /*
 - * Some tests use these global variables to store return values from function
 - * calls that could otherwise be eliminated by the compiler as dead code.
 + * We assign some test results to these globals to make sure the tests
 + * are not eliminated as dead code.
   */
 -void *kasan_ptr_result;
 -int kasan_int_result;
  
 -static struct kunit_resource resource;
 -static struct kunit_kasan_expectation fail_data;
 -static bool multishot;
 +int kasan_int_result;
 +void *kasan_ptr_result;
  
  /*
 - * Temporarily enable multi-shot mode. Otherwise, KASAN would only report the
 - * first detected bug and panic the kernel if panic_on_warn is enabled.
 + * Note: test functions are marked noinline so that their names appear in
 + * reports.
   */
 -static int kasan_test_init(struct kunit *test)
 -{
 -	multishot = kasan_save_enable_multi_shot();
 -	return 0;
 -}
  
++<<<<<<< HEAD
 +static noinline void __init kmalloc_oob_right(void)
++=======
+ static void kasan_test_exit(struct kunit *test)
+ {
+ 	kasan_restore_multi_shot(multishot);
+ }
+ 
+ /**
+  * KUNIT_EXPECT_KASAN_FAIL() - check that the executed expression produces a
+  * KASAN report; causes a test failure otherwise. This relies on a KUnit
+  * resource named "kasan_data". Do not use this name for KUnit resources
+  * outside of KASAN tests.
+  */
+ #define KUNIT_EXPECT_KASAN_FAIL(test, expression) do { \
+ 	fail_data.report_expected = true; \
+ 	fail_data.report_found = false; \
+ 	kunit_add_named_resource(test, \
+ 				NULL, \
+ 				NULL, \
+ 				&resource, \
+ 				"kasan_data", &fail_data); \
+ 	expression; \
+ 	KUNIT_EXPECT_EQ(test, \
+ 			fail_data.report_expected, \
+ 			fail_data.report_found); \
+ } while (0)
+ 
+ #define KASAN_TEST_NEEDS_CONFIG_ON(test, config) do {			\
+ 	if (!IS_ENABLED(config)) {					\
+ 		kunit_info((test), "skipping, " #config " required");	\
+ 		return;							\
+ 	}								\
+ } while (0)
+ 
+ #define KASAN_TEST_NEEDS_CONFIG_OFF(test, config) do {			\
+ 	if (IS_ENABLED(config)) {					\
+ 		kunit_info((test), "skipping, " #config " enabled");	\
+ 		return;							\
+ 	}								\
+ } while (0)
+ 
+ static void kmalloc_oob_right(struct kunit *test)
++>>>>>>> da17e377723f (kasan: add macros to simplify checking test constraints)
  {
  	char *ptr;
  	size_t size = 123;
@@@ -99,18 -128,16 +142,25 @@@ static noinline void __init kmalloc_pag
  	char *ptr;
  	size_t size = KMALLOC_MAX_CACHE_SIZE + 10;
  
++<<<<<<< HEAD
 +	/* Allocate a chunk that does not fit into a SLUB cache to trigger
++=======
+ 	KASAN_TEST_NEEDS_CONFIG_ON(test, CONFIG_SLUB);
+ 
+ 	/*
+ 	 * Allocate a chunk that does not fit into a SLUB cache to trigger
++>>>>>>> da17e377723f (kasan: add macros to simplify checking test constraints)
  	 * the page allocator fallback.
  	 */
 +	pr_info("kmalloc pagealloc allocation: out-of-bounds to right\n");
  	ptr = kmalloc(size, GFP_KERNEL);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr);
 +	if (!ptr) {
 +		pr_err("Allocation failed\n");
 +		return;
 +	}
 +
 +	ptr[size + OOB_TAG_OFF] = 0;
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, ptr[size + OOB_TAG_OFF] = 0);
  	kfree(ptr);
  }
  
@@@ -119,34 -146,29 +169,42 @@@ static noinline void __init kmalloc_pag
  	char *ptr;
  	size_t size = KMALLOC_MAX_CACHE_SIZE + 10;
  
 -	KASAN_TEST_NEEDS_CONFIG_ON(test, CONFIG_SLUB);
 -
++<<<<<<< HEAD
 +	pr_info("kmalloc pagealloc allocation: use-after-free\n");
  	ptr = kmalloc(size, GFP_KERNEL);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr);
 +	if (!ptr) {
 +		pr_err("Allocation failed\n");
 +		return;
 +	}
++=======
++	KASAN_TEST_NEEDS_CONFIG_ON(test, CONFIG_SLUB);
++>>>>>>> da17e377723f (kasan: add macros to simplify checking test constraints)
  
  	kfree(ptr);
 -	KUNIT_EXPECT_KASAN_FAIL(test, ptr[0] = 0);
 +	ptr[0] = 0;
  }
  
 -static void kmalloc_pagealloc_invalid_free(struct kunit *test)
 +static noinline void __init kmalloc_pagealloc_invalid_free(void)
  {
  	char *ptr;
  	size_t size = KMALLOC_MAX_CACHE_SIZE + 10;
  
 -	KASAN_TEST_NEEDS_CONFIG_ON(test, CONFIG_SLUB);
 -
++<<<<<<< HEAD
 +	pr_info("kmalloc pagealloc allocation: invalid-free\n");
  	ptr = kmalloc(size, GFP_KERNEL);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr);
 +	if (!ptr) {
 +		pr_err("Allocation failed\n");
 +		return;
 +	}
++=======
++	KASAN_TEST_NEEDS_CONFIG_ON(test, CONFIG_SLUB);
++>>>>>>> da17e377723f (kasan: add macros to simplify checking test constraints)
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, kfree(ptr + 1));
 +	kfree(ptr + 1);
  }
 +#endif
  
 -static void kmalloc_large_oob_right(struct kunit *test)
 +static noinline void __init kmalloc_large_oob_right(void)
  {
  	char *ptr;
  	size_t size = KMALLOC_MAX_CACHE_SIZE - 256;
@@@ -191,17 -206,33 +249,34 @@@ static noinline void __init kmalloc_oob
  	size_t size1 = 17;
  	size_t size2 = 15;
  
 +	pr_info("out-of-bounds after krealloc less\n");
  	ptr1 = kmalloc(size1, GFP_KERNEL);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr1);
 -
  	ptr2 = krealloc(ptr1, size2, GFP_KERNEL);
++<<<<<<< HEAD
 +	if (!ptr1 || !ptr2) {
 +		pr_err("Allocation failed\n");
 +		kfree(ptr1);
 +		return;
 +	}
++=======
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr2);
+ 
+ 	KUNIT_EXPECT_KASAN_FAIL(test, ptr2[size2 + OOB_TAG_OFF] = 'x');
+ 	kfree(ptr2);
+ }
+ 
+ static void kmalloc_oob_16(struct kunit *test)
+ {
+ 	struct {
+ 		u64 words[2];
+ 	} *ptr1, *ptr2;
+ 
+ 	/* This test is specifically crafted for the generic mode. */
+ 	KASAN_TEST_NEEDS_CONFIG_ON(test, CONFIG_KASAN_GENERIC);
++>>>>>>> da17e377723f (kasan: add macros to simplify checking test constraints)
  
 -	ptr1 = kmalloc(sizeof(*ptr1) - 3, GFP_KERNEL);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr1);
 -
 -	ptr2 = kmalloc(sizeof(*ptr2), GFP_KERNEL);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr2);
 +	ptr2[size2 + OOB_TAG_OFF] = 'x';
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, *ptr1 = *ptr2);
 -	kfree(ptr1);
  	kfree(ptr2);
  }
  
@@@ -485,21 -455,13 +560,29 @@@ static noinline void __init kasan_globa
  	volatile int i = 3;
  	char *p = &global_array[ARRAY_SIZE(global_array) + i];
  
++<<<<<<< HEAD
 +	pr_info("out-of-bounds global variable\n");
 +	*(volatile char *)p;
++=======
+ 	/* Only generic mode instruments globals. */
+ 	KASAN_TEST_NEEDS_CONFIG_ON(test, CONFIG_KASAN_GENERIC);
+ 
+ 	KUNIT_EXPECT_KASAN_FAIL(test, *(volatile char *)p);
++>>>>>>> da17e377723f (kasan: add macros to simplify checking test constraints)
 +}
 +
 +static noinline void __init kasan_stack_oob(void)
 +{
 +	char stack_array[10];
 +	volatile int i = OOB_TAG_OFF;
 +	char *p = &stack_array[ARRAY_SIZE(stack_array) + i];
 +
++<<<<<<< HEAD
 +	pr_info("out-of-bounds on stack\n");
 +	*(volatile char *)p;
  }
  
 -static void ksize_unpoisons_memory(struct kunit *test)
 +static noinline void __init ksize_unpoisons_memory(void)
  {
  	char *ptr;
  	size_t size = 123, real_size;
@@@ -518,72 -479,44 +601,91 @@@
  	kfree(ptr);
  }
  
 -static void kasan_stack_oob(struct kunit *test)
 +static noinline void __init copy_user_test(void)
  {
 -	char stack_array[10];
 -	volatile int i = OOB_TAG_OFF;
 -	char *p = &stack_array[ARRAY_SIZE(stack_array) + i];
 +	char *kmem;
 +	char __user *usermem;
 +	size_t size = 10;
 +	int unused;
 +
 +	kmem = kmalloc(size, GFP_KERNEL);
 +	if (!kmem)
 +		return;
  
 +	usermem = (char __user *)vm_mmap(NULL, 0, PAGE_SIZE,
 +			    PROT_READ | PROT_WRITE | PROT_EXEC,
 +			    MAP_ANONYMOUS | MAP_PRIVATE, 0);
 +	if (IS_ERR(usermem)) {
 +		pr_err("Failed to allocate user memory\n");
 +		kfree(kmem);
 +		return;
 +	}
++=======
+ 	KASAN_TEST_NEEDS_CONFIG_ON(test, CONFIG_KASAN_STACK);
++>>>>>>> da17e377723f (kasan: add macros to simplify checking test constraints)
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, *(volatile char *)p);
 +	pr_info("out-of-bounds in copy_from_user()\n");
 +	unused = copy_from_user(kmem, usermem, size + 1 + OOB_TAG_OFF);
 +
 +	pr_info("out-of-bounds in copy_to_user()\n");
 +	unused = copy_to_user(usermem, kmem, size + 1 + OOB_TAG_OFF);
 +
 +	pr_info("out-of-bounds in __copy_from_user()\n");
 +	unused = __copy_from_user(kmem, usermem, size + 1 + OOB_TAG_OFF);
 +
 +	pr_info("out-of-bounds in __copy_to_user()\n");
 +	unused = __copy_to_user(usermem, kmem, size + 1 + OOB_TAG_OFF);
 +
 +	pr_info("out-of-bounds in __copy_from_user_inatomic()\n");
 +	unused = __copy_from_user_inatomic(kmem, usermem, size + 1 + OOB_TAG_OFF);
 +
 +	pr_info("out-of-bounds in __copy_to_user_inatomic()\n");
 +	unused = __copy_to_user_inatomic(usermem, kmem, size + 1 + OOB_TAG_OFF);
 +
 +	pr_info("out-of-bounds in strncpy_from_user()\n");
 +	unused = strncpy_from_user(kmem, usermem, size + 1 + OOB_TAG_OFF);
 +
 +	vm_munmap((unsigned long)usermem, PAGE_SIZE);
 +	kfree(kmem);
  }
  
 -static void kasan_alloca_oob_left(struct kunit *test)
 +static noinline void __init kasan_alloca_oob_left(void)
  {
  	volatile int i = 10;
  	char alloca_array[i];
  	char *p = alloca_array - 1;
  
++<<<<<<< HEAD
 +	pr_info("out-of-bounds to left on alloca\n");
 +	*(volatile char *)p;
++=======
+ 	/* Only generic mode instruments dynamic allocas. */
+ 	KASAN_TEST_NEEDS_CONFIG_ON(test, CONFIG_KASAN_GENERIC);
+ 	KASAN_TEST_NEEDS_CONFIG_ON(test, CONFIG_KASAN_STACK);
+ 
+ 	KUNIT_EXPECT_KASAN_FAIL(test, *(volatile char *)p);
++>>>>>>> da17e377723f (kasan: add macros to simplify checking test constraints)
  }
  
 -static void kasan_alloca_oob_right(struct kunit *test)
 +static noinline void __init kasan_alloca_oob_right(void)
  {
  	volatile int i = 10;
  	char alloca_array[i];
  	char *p = alloca_array + i;
  
++<<<<<<< HEAD
 +	pr_info("out-of-bounds to right on alloca\n");
 +	*(volatile char *)p;
++=======
+ 	/* Only generic mode instruments dynamic allocas. */
+ 	KASAN_TEST_NEEDS_CONFIG_ON(test, CONFIG_KASAN_GENERIC);
+ 	KASAN_TEST_NEEDS_CONFIG_ON(test, CONFIG_KASAN_STACK);
+ 
+ 	KUNIT_EXPECT_KASAN_FAIL(test, *(volatile char *)p);
++>>>>>>> da17e377723f (kasan: add macros to simplify checking test constraints)
  }
  
 -static void kmem_cache_double_free(struct kunit *test)
 +static noinline void __init kmem_cache_double_free(void)
  {
  	char *p;
  	size_t size = 200;
@@@ -644,12 -571,21 +746,24 @@@ static noinline void __init kasan_memch
  	char *ptr;
  	size_t size = 24;
  
++<<<<<<< HEAD
 +	pr_info("out-of-bounds in memchr\n");
++=======
+ 	/*
+ 	 * str* functions are not instrumented with CONFIG_AMD_MEM_ENCRYPT.
+ 	 * See https://bugzilla.kernel.org/show_bug.cgi?id=206337 for details.
+ 	 */
+ 	KASAN_TEST_NEEDS_CONFIG_OFF(test, CONFIG_AMD_MEM_ENCRYPT);
+ 
+ 	if (OOB_TAG_OFF)
+ 		size = round_up(size, OOB_TAG_OFF);
+ 
++>>>>>>> da17e377723f (kasan: add macros to simplify checking test constraints)
  	ptr = kmalloc(size, GFP_KERNEL | __GFP_ZERO);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr);
 -
 -	KUNIT_EXPECT_KASAN_FAIL(test,
 -		kasan_ptr_result = memchr(ptr, '1', size + 1));
 +	if (!ptr)
 +		return;
  
 +	kasan_ptr_result = memchr(ptr, '1', size + 1);
  	kfree(ptr);
  }
  
@@@ -659,13 -595,21 +773,25 @@@ static noinline void __init kasan_memcm
  	size_t size = 24;
  	int arr[9];
  
++<<<<<<< HEAD
 +	pr_info("out-of-bounds in memcmp\n");
++=======
+ 	/*
+ 	 * str* functions are not instrumented with CONFIG_AMD_MEM_ENCRYPT.
+ 	 * See https://bugzilla.kernel.org/show_bug.cgi?id=206337 for details.
+ 	 */
+ 	KASAN_TEST_NEEDS_CONFIG_OFF(test, CONFIG_AMD_MEM_ENCRYPT);
+ 
+ 	if (OOB_TAG_OFF)
+ 		size = round_up(size, OOB_TAG_OFF);
+ 
++>>>>>>> da17e377723f (kasan: add macros to simplify checking test constraints)
  	ptr = kmalloc(size, GFP_KERNEL | __GFP_ZERO);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr);
 -	memset(arr, 0, sizeof(arr));
 +	if (!ptr)
 +		return;
  
 -	KUNIT_EXPECT_KASAN_FAIL(test,
 -		kasan_int_result = memcmp(ptr, arr, size+1));
 +	memset(arr, 0, sizeof(arr));
 +	kasan_int_result = memcmp(ptr, arr, size + 1);
  	kfree(ptr);
  }
  
@@@ -674,10 -618,14 +800,19 @@@ static noinline void __init kasan_strin
  	char *ptr;
  	size_t size = 24;
  
++<<<<<<< HEAD
 +	pr_info("use-after-free in strchr\n");
++=======
+ 	/*
+ 	 * str* functions are not instrumented with CONFIG_AMD_MEM_ENCRYPT.
+ 	 * See https://bugzilla.kernel.org/show_bug.cgi?id=206337 for details.
+ 	 */
+ 	KASAN_TEST_NEEDS_CONFIG_OFF(test, CONFIG_AMD_MEM_ENCRYPT);
+ 
++>>>>>>> da17e377723f (kasan: add macros to simplify checking test constraints)
  	ptr = kmalloc(size, GFP_KERNEL | __GFP_ZERO);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ptr);
 +	if (!ptr)
 +		return;
  
  	kfree(ptr);
  
@@@ -688,33 -636,61 +823,70 @@@
  	 * will likely point to zeroed byte.
  	 */
  	ptr += 16;
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_ptr_result = strchr(ptr, '1'));
 +	kasan_ptr_result = strchr(ptr, '1');
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_ptr_result = strrchr(ptr, '1'));
 +	pr_info("use-after-free in strrchr\n");
 +	kasan_ptr_result = strrchr(ptr, '1');
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result = strcmp(ptr, "2"));
 +	pr_info("use-after-free in strcmp\n");
 +	kasan_int_result = strcmp(ptr, "2");
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result = strncmp(ptr, "2", 1));
 +	pr_info("use-after-free in strncmp\n");
 +	kasan_int_result = strncmp(ptr, "2", 1);
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result = strlen(ptr));
 +	pr_info("use-after-free in strlen\n");
 +	kasan_int_result = strlen(ptr);
  
 -	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result = strnlen(ptr, 1));
 +	pr_info("use-after-free in strnlen\n");
 +	kasan_int_result = strnlen(ptr, 1);
  }
  
 -static void kasan_bitops_modify(struct kunit *test, int nr, void *addr)
 +static noinline void __init kasan_bitops(void)
  {
++<<<<<<< HEAD
++=======
+ 	KUNIT_EXPECT_KASAN_FAIL(test, set_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, __set_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, clear_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, __clear_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, clear_bit_unlock(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, __clear_bit_unlock(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, change_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, __change_bit(nr, addr));
+ }
+ 
+ static void kasan_bitops_test_and_modify(struct kunit *test, int nr, void *addr)
+ {
+ 	KUNIT_EXPECT_KASAN_FAIL(test, test_and_set_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, __test_and_set_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, test_and_set_bit_lock(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, test_and_clear_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, __test_and_clear_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, test_and_change_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, __test_and_change_bit(nr, addr));
+ 	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result = test_bit(nr, addr));
+ 
+ #if defined(clear_bit_unlock_is_negative_byte)
+ 	KUNIT_EXPECT_KASAN_FAIL(test, kasan_int_result =
+ 				clear_bit_unlock_is_negative_byte(nr, addr));
+ #endif
+ }
+ 
+ static void kasan_bitops_generic(struct kunit *test)
+ {
+ 	long *bits;
+ 
+ 	/* This test is specifically crafted for the generic mode. */
+ 	KASAN_TEST_NEEDS_CONFIG_ON(test, CONFIG_KASAN_GENERIC);
+ 
++>>>>>>> da17e377723f (kasan: add macros to simplify checking test constraints)
  	/*
 -	 * Allocate 1 more byte, which causes kzalloc to round up to 16 bytes;
 +	 * Allocate 1 more byte, which causes kzalloc to round up to 16-bytes;
  	 * this way we do not actually corrupt other memory.
  	 */
 -	bits = kzalloc(sizeof(*bits) + 1, GFP_KERNEL);
 -	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, bits);
 +	long *bits = kzalloc(sizeof(*bits) + 1, GFP_KERNEL);
 +	if (!bits)
 +		return;
  
  	/*
  	 * Below calls try to access bit within allocated memory; however, the
@@@ -780,7 -707,25 +952,29 @@@
  	kfree(bits);
  }
  
++<<<<<<< HEAD
 +static noinline void __init kmalloc_double_kzfree(void)
++=======
+ static void kasan_bitops_tags(struct kunit *test)
+ {
+ 	long *bits;
+ 
+ 	/* This test is specifically crafted for tag-based modes. */
+ 	KASAN_TEST_NEEDS_CONFIG_OFF(test, CONFIG_KASAN_GENERIC);
+ 
+ 	/* Allocation size will be rounded to up granule size, which is 16. */
+ 	bits = kzalloc(sizeof(*bits), GFP_KERNEL);
+ 	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, bits);
+ 
+ 	/* Do the accesses past the 16 allocated bytes. */
+ 	kasan_bitops_modify(test, BITS_PER_LONG, &bits[1]);
+ 	kasan_bitops_test_and_modify(test, BITS_PER_LONG + BITS_PER_BYTE, &bits[1]);
+ 
+ 	kfree(bits);
+ }
+ 
+ static void kmalloc_double_kzfree(struct kunit *test)
++>>>>>>> da17e377723f (kasan: add macros to simplify checking test constraints)
  {
  	char *ptr;
  	size_t size = 16;
@@@ -801,7 -741,7 +995,11 @@@ static noinline void __init vmalloc_oob
  {
  	void *area;
  
++<<<<<<< HEAD
 +	pr_info("vmalloc out-of-bounds\n");
++=======
+ 	KASAN_TEST_NEEDS_CONFIG_ON(test, CONFIG_KASAN_VMALLOC);
++>>>>>>> da17e377723f (kasan: add macros to simplify checking test constraints)
  
  	/*
  	 * We have to be careful not to hit the guard page.
* Unmerged path lib/test_kasan.c
