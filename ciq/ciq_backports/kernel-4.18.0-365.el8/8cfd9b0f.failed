netfilter: nftables: generalize set expressions support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 8cfd9b0f8515e7c361bba27e2a2684cbd427fe01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/8cfd9b0f.failed

Currently, the set infrastucture allows for one single expressions per
element. This patch extends the existing infrastructure to allow for up
to two expressions. This is not updating the netlink API yet, this is
coming as an initial preparation patch.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 8cfd9b0f8515e7c361bba27e2a2684cbd427fe01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables.h
#	net/netfilter/nf_tables_api.c
diff --cc include/net/netfilter/nf_tables.h
index 4256c4e85870,aad7e1381200..000000000000
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@@ -391,8 -396,7 +391,12 @@@ struct nft_set_type 
  };
  #define to_set_type(o) container_of(o, struct nft_set_type, ops)
  
++<<<<<<< HEAD
 +int nft_register_set(struct nft_set_type *type);
 +void nft_unregister_set(struct nft_set_type *type);
++=======
+ #define NFT_SET_EXPR_MAX	2
++>>>>>>> 8cfd9b0f8515 (netfilter: nftables: generalize set expressions support)
  
  /**
   * 	struct nft_set - nf_tables set instance
diff --cc net/netfilter/nf_tables_api.c
index 447a0cf7802a,ade10cd23acc..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -3731,7 -3839,15 +3731,19 @@@ static int nf_tables_fill_set(struct sk
  	    nf_tables_fill_set_concat(skb, set))
  		goto nla_put_failure;
  
++<<<<<<< HEAD
 +	nla_nest_end(skb, desc);
++=======
+ 	nla_nest_end(skb, nest);
+ 
+ 	if (set->num_exprs == 1) {
+ 		nest = nla_nest_start_noflag(skb, NFTA_SET_EXPR);
+ 		if (nf_tables_fill_expr_info(skb, set->exprs[0]) < 0)
+ 			goto nla_put_failure;
+ 
+ 		nla_nest_end(skb, nest);
+ 	}
++>>>>>>> 8cfd9b0f8515 (netfilter: nftables: generalize set expressions support)
  
  	nlmsg_end(skb, nlh);
  	return 0;
@@@ -4141,7 -4271,17 +4153,21 @@@ static int nf_tables_newset(struct net 
  	err = nf_tables_set_alloc_name(&ctx, set, name);
  	kfree(name);
  	if (err < 0)
++<<<<<<< HEAD
 +		goto err2;
++=======
+ 		goto err_set_alloc_name;
+ 
+ 	if (nla[NFTA_SET_EXPR]) {
+ 		expr = nft_set_elem_expr_alloc(&ctx, set, nla[NFTA_SET_EXPR]);
+ 		if (IS_ERR(expr)) {
+ 			err = PTR_ERR(expr);
+ 			goto err_set_alloc_name;
+ 		}
+ 		set->exprs[0] = expr;
+ 		set->num_exprs++;
+ 	}
++>>>>>>> 8cfd9b0f8515 (netfilter: nftables: generalize set expressions support)
  
  	udata = NULL;
  	if (udlen) {
@@@ -4183,21 -4323,29 +4209,39 @@@
  	table->use++;
  	return 0;
  
 -err_set_trans:
 +err4:
  	ops->destroy(set);
++<<<<<<< HEAD
 +err3:
++=======
+ err_set_init:
+ 	for (i = 0; i < set->num_exprs; i++)
+ 		nft_expr_destroy(&ctx, set->exprs[i]);
+ err_set_alloc_name:
++>>>>>>> 8cfd9b0f8515 (netfilter: nftables: generalize set expressions support)
  	kfree(set->name);
 -err_set_name:
 +err2:
  	kvfree(set);
 +err1:
 +	module_put(to_set_type(ops)->owner);
  	return err;
  }
  
  static void nft_set_destroy(const struct nft_ctx *ctx, struct nft_set *set)
  {
++<<<<<<< HEAD
++=======
+ 	int i;
+ 
+ 	if (WARN_ON(set->use > 0))
+ 		return;
+ 
+ 	for (i = 0; i < set->num_exprs; i++)
+ 		nft_expr_destroy(ctx, set->exprs[i]);
+ 
++>>>>>>> 8cfd9b0f8515 (netfilter: nftables: generalize set expressions support)
  	set->ops->destroy(set);
 +	module_put(to_set_type(set->ops)->owner);
  	kfree(set->name);
  	kvfree(set);
  }
@@@ -4956,8 -5188,9 +5030,8 @@@ static int nft_add_set_elem(struct nft_
  	struct nft_trans *trans;
  	u32 flags = 0;
  	u64 timeout;
 -	u64 expiration;
  	u8 ulen;
- 	int err;
+ 	int err, i;
  
  	err = nla_parse_nested_deprecated(nla, NFTA_SET_ELEM_MAX, attr,
  					  nft_set_elem_policy, NULL);
@@@ -5005,6 -5238,39 +5079,42 @@@
  		timeout = set->timeout;
  	}
  
++<<<<<<< HEAD
++=======
+ 	expiration = 0;
+ 	if (nla[NFTA_SET_ELEM_EXPIRATION] != NULL) {
+ 		if (!(set->flags & NFT_SET_TIMEOUT))
+ 			return -EINVAL;
+ 		err = nf_msecs_to_jiffies64(nla[NFTA_SET_ELEM_EXPIRATION],
+ 					    &expiration);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (nla[NFTA_SET_ELEM_EXPR]) {
+ 		struct nft_expr *expr;
+ 
+ 		if (set->num_exprs != 1)
+ 			return -EOPNOTSUPP;
+ 
+ 		expr = nft_set_elem_expr_alloc(ctx, set,
+ 					       nla[NFTA_SET_ELEM_EXPR]);
+ 		if (IS_ERR(expr))
+ 			return PTR_ERR(expr);
+ 
+ 		expr_array[0] = expr;
+ 
+ 		if (set->exprs[0] && set->exprs[0]->ops != expr->ops) {
+ 			err = -EOPNOTSUPP;
+ 			goto err_set_elem_expr;
+ 		}
+ 	} else if (set->num_exprs > 0) {
+ 		err = nft_set_elem_expr_clone(ctx, set, expr_array);
+ 		if (err < 0)
+ 			goto err_set_elem_expr_clone;
+ 	}
+ 
++>>>>>>> 8cfd9b0f8515 (netfilter: nftables: generalize set expressions support)
  	err = nft_setelem_parse_key(ctx, set, &elem.key.val,
  				    nla[NFTA_SET_ELEM_KEY]);
  	if (err < 0)
@@@ -5027,6 -5293,10 +5137,13 @@@
  			nft_set_ext_add(&tmpl, NFT_SET_EXT_TIMEOUT);
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (set->num_exprs == 1)
+ 		nft_set_ext_add_length(&tmpl, NFT_SET_EXT_EXPR,
+ 				       expr_array[0]->ops->size);
+ 
++>>>>>>> 8cfd9b0f8515 (netfilter: nftables: generalize set expressions support)
  	if (nla[NFTA_SET_ELEM_OBJREF] != NULL) {
  		if (!(set->flags & NFT_SET_OBJECT)) {
  			err = -EINVAL;
@@@ -5111,6 -5377,13 +5228,16 @@@
  		*nft_set_ext_obj(ext) = obj;
  		obj->use++;
  	}
++<<<<<<< HEAD
++=======
+ 	if (set->num_exprs == 1) {
+ 		struct nft_expr *expr = expr_array[0];
+ 
+ 		memcpy(nft_set_ext_expr(ext), expr, expr->ops->size);
+ 		kfree(expr);
+ 		expr_array[0] = NULL;
+ 	}
++>>>>>>> 8cfd9b0f8515 (netfilter: nftables: generalize set expressions support)
  
  	trans = nft_trans_elem_alloc(ctx, NFT_MSG_NEWSETELEM, set);
  	if (trans == NULL)
@@@ -5167,7 -5443,10 +5294,14 @@@ err_parse_key_end
  	nft_data_release(&elem.key_end.val, NFT_DATA_VALUE);
  err_parse_key:
  	nft_data_release(&elem.key.val, NFT_DATA_VALUE);
++<<<<<<< HEAD
 +
++=======
+ err_set_elem_expr:
+ 	for (i = 0; i < set->num_exprs && expr_array[i]; i++)
+ 		nft_expr_destroy(ctx, expr_array[i]);
+ err_set_elem_expr_clone:
++>>>>>>> 8cfd9b0f8515 (netfilter: nftables: generalize set expressions support)
  	return err;
  }
  
* Unmerged path include/net/netfilter/nf_tables.h
* Unmerged path net/netfilter/nf_tables_api.c
diff --git a/net/netfilter/nft_dynset.c b/net/netfilter/nft_dynset.c
index f4087af55c14..598767261540 100644
--- a/net/netfilter/nft_dynset.c
+++ b/net/netfilter/nft_dynset.c
@@ -190,7 +190,8 @@ static int nft_dynset_init(const struct nft_ctx *ctx,
 		if (IS_ERR(priv->expr))
 			return PTR_ERR(priv->expr);
 
-		if (set->expr && set->expr->ops != priv->expr->ops) {
+		if (set->num_exprs == 1 &&
+		    set->exprs[0]->ops != priv->expr->ops) {
 			err = -EOPNOTSUPP;
 			goto err_expr_free;
 		}
