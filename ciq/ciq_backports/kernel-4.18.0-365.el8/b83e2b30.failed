ACPI: scan: Add function to fetch dependent of ACPI device

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Daniel Scally <djrscally@gmail.com>
commit b83e2b306736cb0d108df791fd4ee39f6d52184f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/b83e2b30.failed

In some ACPI tables we encounter, devices use the _DEP method to assert
a dependence on other ACPI devices as opposed to the OpRegions that the
specification intends.

We need to be able to find those devices "from" the dependee, so add
a callback and a wrapper to walk over the acpi_dep_list and return
the dependent ACPI device.

	Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
	Signed-off-by: Daniel Scally <djrscally@gmail.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit b83e2b306736cb0d108df791fd4ee39f6d52184f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
#	include/acpi/acpi_bus.h
diff --cc drivers/acpi/scan.c
index 7c82197723ba,708c1d84e7bf..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -2118,10 -2101,56 +2118,60 @@@ static void acpi_bus_attach(struct acpi
  		device->handler->hotplug.notify_online(device);
  }
  
++<<<<<<< HEAD
 +void acpi_walk_dep_device_list(acpi_handle handle)
++=======
+ static int acpi_dev_get_first_consumer_dev_cb(struct acpi_dep_data *dep, void *data)
+ {
+ 	struct acpi_device *adev;
+ 
+ 	adev = acpi_bus_get_acpi_device(dep->consumer);
+ 	if (!adev)
+ 		/* If we don't find an adev then we want to continue parsing */
+ 		return 0;
+ 
+ 	*(struct acpi_device **)data = adev;
+ 
+ 	return 1;
+ }
+ 
+ static int acpi_scan_clear_dep(struct acpi_dep_data *dep, void *data)
+ {
+ 	struct acpi_device *adev;
+ 
+ 	acpi_bus_get_device(dep->consumer, &adev);
+ 
+ 	if (adev) {
+ 		adev->dep_unmet--;
+ 		if (!adev->dep_unmet)
+ 			acpi_bus_attach(adev, true);
+ 	}
+ 
+ 	list_del(&dep->node);
+ 	kfree(dep);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * acpi_walk_dep_device_list - Apply a callback to every entry in acpi_dep_list
+  * @handle:	The ACPI handle of the supplier device
+  * @callback:	Pointer to the callback function to apply
+  * @data:	Pointer to some data to pass to the callback
+  *
+  * The return value of the callback determines this function's behaviour. If 0
+  * is returned we continue to iterate over acpi_dep_list. If a positive value
+  * is returned then the loop is broken but this function returns 0. If a
+  * negative value is returned by the callback then the loop is broken and that
+  * value is returned as the final error.
+  */
+ int acpi_walk_dep_device_list(acpi_handle handle,
+ 			      int (*callback)(struct acpi_dep_data *, void *),
+ 			      void *data)
++>>>>>>> b83e2b306736 (ACPI: scan: Add function to fetch dependent of ACPI device)
  {
  	struct acpi_dep_data *dep, *tmp;
 -	int ret;
 +	struct acpi_device *adev;
  
  	mutex_lock(&acpi_dep_list_lock);
  	list_for_each_entry_safe(dep, tmp, &acpi_dep_list, node) {
@@@ -2143,6 -2167,39 +2193,42 @@@
  EXPORT_SYMBOL_GPL(acpi_walk_dep_device_list);
  
  /**
++<<<<<<< HEAD
++=======
+  * acpi_dev_clear_dependencies - Inform consumers that the device is now active
+  * @supplier: Pointer to the supplier &struct acpi_device
+  *
+  * Clear dependencies on the given device.
+  */
+ void acpi_dev_clear_dependencies(struct acpi_device *supplier)
+ {
+ 	acpi_walk_dep_device_list(supplier->handle, acpi_scan_clear_dep, NULL);
+ }
+ EXPORT_SYMBOL_GPL(acpi_dev_clear_dependencies);
+ 
+ /**
+  * acpi_dev_get_first_consumer_dev - Return ACPI device dependent on @supplier
+  * @supplier: Pointer to the dependee device
+  *
+  * Returns the first &struct acpi_device which declares itself dependent on
+  * @supplier via the _DEP buffer, parsed from the acpi_dep_list.
+  *
+  * The caller is responsible for putting the reference to adev when it is no
+  * longer needed.
+  */
+ struct acpi_device *acpi_dev_get_first_consumer_dev(struct acpi_device *supplier)
+ {
+ 	struct acpi_device *adev = NULL;
+ 
+ 	acpi_walk_dep_device_list(supplier->handle,
+ 				  acpi_dev_get_first_consumer_dev_cb, &adev);
+ 
+ 	return adev;
+ }
+ EXPORT_SYMBOL_GPL(acpi_dev_get_first_consumer_dev);
+ 
+ /**
++>>>>>>> b83e2b306736 (ACPI: scan: Add function to fetch dependent of ACPI device)
   * acpi_bus_scan - Add ACPI device node objects in a given namespace scope.
   * @handle: Root of the namespace scope to scan.
   *
diff --cc include/acpi/acpi_bus.h
index 524865b46db1,4bed30e61c5b..000000000000
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@@ -693,6 -691,8 +693,11 @@@ static inline bool acpi_device_can_powe
  
  bool acpi_dev_hid_uid_match(struct acpi_device *adev, const char *hid2, const char *uid2);
  
++<<<<<<< HEAD
++=======
+ void acpi_dev_clear_dependencies(struct acpi_device *supplier);
+ struct acpi_device *acpi_dev_get_first_consumer_dev(struct acpi_device *supplier);
++>>>>>>> b83e2b306736 (ACPI: scan: Add function to fetch dependent of ACPI device)
  struct acpi_device *
  acpi_dev_get_next_match_dev(struct acpi_device *adev, const char *hid, const char *uid, s64 hrv);
  struct acpi_device *
* Unmerged path drivers/acpi/scan.c
* Unmerged path include/acpi/acpi_bus.h
