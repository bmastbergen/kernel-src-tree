drm/i915: Clean dpll calling convention

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 6205372b4b6dab7fc000a00c7703c68fe4cf5c8b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/6205372b.failed

Stop passing both the crtc and its state to the DPLL functions.
The state alone is enough.

	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210715093530.31711-6-ville.syrjala@linux.intel.com
	Reviewed-by: Jani Nikula <jani.nikula@intel.com>
(cherry picked from commit 6205372b4b6dab7fc000a00c7703c68fe4cf5c8b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_dpll.c
#	drivers/gpu/drm/i915/display/intel_dpll.h
diff --cc drivers/gpu/drm/i915/display/intel_dpll.c
index de345d1ba1af,75de70251530..000000000000
--- a/drivers/gpu/drm/i915/display/intel_dpll.c
+++ b/drivers/gpu/drm/i915/display/intel_dpll.c
@@@ -766,11 -778,12 +766,17 @@@ static u32 pnv_dpll_compute_fp(struct d
  	return (1 << dpll->n) << 16 | dpll->m2;
  }
  
++<<<<<<< HEAD
 +static void i9xx_update_pll_dividers(struct intel_crtc *crtc,
 +				     struct intel_crtc_state *crtc_state,
 +				     struct dpll *reduced_clock)
++=======
+ static void i9xx_update_pll_dividers(struct intel_crtc_state *crtc_state,
+ 				     const struct dpll *reduced_clock)
++>>>>>>> 6205372b4b6d (drm/i915: Clean dpll calling convention)
  {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
  	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -	const struct dpll *clock = &crtc_state->dpll;
  	u32 fp, fp2 = 0;
  
  	if (IS_PINEVIEW(dev_priv)) {
@@@ -793,15 -806,15 +799,21 @@@
  	}
  }
  
++<<<<<<< HEAD
 +static void i9xx_compute_dpll(struct intel_crtc *crtc,
 +			      struct intel_crtc_state *crtc_state,
 +			      struct dpll *reduced_clock)
++=======
+ static void i9xx_compute_dpll(struct intel_crtc_state *crtc_state,
+ 			      const struct dpll *reduced_clock)
++>>>>>>> 6205372b4b6d (drm/i915: Clean dpll calling convention)
  {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
  	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -	const struct dpll *clock = &crtc_state->dpll;
  	u32 dpll;
 +	struct dpll *clock = &crtc_state->dpll;
  
- 	i9xx_update_pll_dividers(crtc, crtc_state, reduced_clock);
+ 	i9xx_update_pll_dividers(crtc_state, reduced_clock);
  
  	dpll = DPLL_VGA_MODE_DIS;
  
@@@ -866,16 -879,15 +878,25 @@@
  	}
  }
  
++<<<<<<< HEAD
 +static void i8xx_compute_dpll(struct intel_crtc *crtc,
 +			      struct intel_crtc_state *crtc_state,
 +			      struct dpll *reduced_clock)
 +{
 +	struct drm_device *dev = crtc->base.dev;
 +	struct drm_i915_private *dev_priv = to_i915(dev);
++=======
+ static void i8xx_compute_dpll(struct intel_crtc_state *crtc_state,
+ 			      const struct dpll *reduced_clock)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	const struct dpll *clock = &crtc_state->dpll;
++>>>>>>> 6205372b4b6d (drm/i915: Clean dpll calling convention)
  	u32 dpll;
 +	struct dpll *clock = &crtc_state->dpll;
  
- 	i9xx_update_pll_dividers(crtc, crtc_state, reduced_clock);
+ 	i9xx_update_pll_dividers(crtc_state, reduced_clock);
  
  	dpll = DPLL_VGA_MODE_DIS;
  
@@@ -944,12 -957,12 +965,18 @@@ static bool ilk_needs_fb_cb_tune(struc
  	return i9xx_dpll_compute_m(dpll) < factor * dpll->n;
  }
  
++<<<<<<< HEAD
 +
 +static void ilk_update_pll_dividers(struct intel_crtc *crtc,
 +				    struct intel_crtc_state *crtc_state,
 +				    struct dpll *reduced_clock)
++=======
+ static void ilk_update_pll_dividers(struct intel_crtc_state *crtc_state,
+ 				    const struct dpll *reduced_clock)
++>>>>>>> 6205372b4b6d (drm/i915: Clean dpll calling convention)
  {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
  	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -	const struct dpll *clock = &crtc_state->dpll;
  	u32 fp, fp2 = 0;
  	int factor;
  
@@@ -981,14 -994,15 +1008,20 @@@
  	crtc_state->dpll_hw_state.fp1 = reduced_clock ? fp2 : fp;
  }
  
++<<<<<<< HEAD
 +static void ilk_compute_dpll(struct intel_crtc *crtc,
 +			     struct intel_crtc_state *crtc_state,
 +			     struct dpll *reduced_clock)
++=======
+ static void ilk_compute_dpll(struct intel_crtc_state *crtc_state,
+ 			     const struct dpll *reduced_clock)
++>>>>>>> 6205372b4b6d (drm/i915: Clean dpll calling convention)
  {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
  	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 -	const struct dpll *clock = &crtc_state->dpll;
  	u32 dpll;
  
- 	ilk_update_pll_dividers(crtc, crtc_state, reduced_clock);
+ 	ilk_update_pll_dividers(crtc_state, reduced_clock);
  
  	dpll = 0;
  
@@@ -1370,3 -1381,509 +1400,512 @@@ intel_dpll_init_clock_hook(struct drm_i
  	else
  		dev_priv->display.crtc_compute_clock = i8xx_crtc_compute_clock;
  }
++<<<<<<< HEAD
++=======
+ 
+ static bool i9xx_has_pps(struct drm_i915_private *dev_priv)
+ {
+ 	if (IS_I830(dev_priv))
+ 		return false;
+ 
+ 	return IS_PINEVIEW(dev_priv) || IS_MOBILE(dev_priv);
+ }
+ 
+ void i9xx_enable_pll(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	i915_reg_t reg = DPLL(crtc->pipe);
+ 	u32 dpll = crtc_state->dpll_hw_state.dpll;
+ 	int i;
+ 
+ 	assert_pipe_disabled(dev_priv, crtc_state->cpu_transcoder);
+ 
+ 	/* PLL is protected by panel, make sure we can write it */
+ 	if (i9xx_has_pps(dev_priv))
+ 		assert_panel_unlocked(dev_priv, crtc->pipe);
+ 
+ 	/*
+ 	 * Apparently we need to have VGA mode enabled prior to changing
+ 	 * the P1/P2 dividers. Otherwise the DPLL will keep using the old
+ 	 * dividers, even though the register value does change.
+ 	 */
+ 	intel_de_write(dev_priv, reg, dpll & ~DPLL_VGA_MODE_DIS);
+ 	intel_de_write(dev_priv, reg, dpll);
+ 
+ 	/* Wait for the clocks to stabilize. */
+ 	intel_de_posting_read(dev_priv, reg);
+ 	udelay(150);
+ 
+ 	if (DISPLAY_VER(dev_priv) >= 4) {
+ 		intel_de_write(dev_priv, DPLL_MD(crtc->pipe),
+ 			       crtc_state->dpll_hw_state.dpll_md);
+ 	} else {
+ 		/* The pixel multiplier can only be updated once the
+ 		 * DPLL is enabled and the clocks are stable.
+ 		 *
+ 		 * So write it again.
+ 		 */
+ 		intel_de_write(dev_priv, reg, dpll);
+ 	}
+ 
+ 	/* We do this three times for luck */
+ 	for (i = 0; i < 3; i++) {
+ 		intel_de_write(dev_priv, reg, dpll);
+ 		intel_de_posting_read(dev_priv, reg);
+ 		udelay(150); /* wait for warmup */
+ 	}
+ }
+ 
+ static void vlv_pllb_recal_opamp(struct drm_i915_private *dev_priv,
+ 				 enum pipe pipe)
+ {
+ 	u32 reg_val;
+ 
+ 	/*
+ 	 * PLLB opamp always calibrates to max value of 0x3f, force enable it
+ 	 * and set it to a reasonable value instead.
+ 	 */
+ 	reg_val = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW9(1));
+ 	reg_val &= 0xffffff00;
+ 	reg_val |= 0x00000030;
+ 	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW9(1), reg_val);
+ 
+ 	reg_val = vlv_dpio_read(dev_priv, pipe, VLV_REF_DW13);
+ 	reg_val &= 0x00ffffff;
+ 	reg_val |= 0x8c000000;
+ 	vlv_dpio_write(dev_priv, pipe, VLV_REF_DW13, reg_val);
+ 
+ 	reg_val = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW9(1));
+ 	reg_val &= 0xffffff00;
+ 	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW9(1), reg_val);
+ 
+ 	reg_val = vlv_dpio_read(dev_priv, pipe, VLV_REF_DW13);
+ 	reg_val &= 0x00ffffff;
+ 	reg_val |= 0xb0000000;
+ 	vlv_dpio_write(dev_priv, pipe, VLV_REF_DW13, reg_val);
+ }
+ 
+ static void _vlv_enable_pll(const struct intel_crtc_state *pipe_config)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 
+ 	intel_de_write(dev_priv, DPLL(pipe), pipe_config->dpll_hw_state.dpll);
+ 	intel_de_posting_read(dev_priv, DPLL(pipe));
+ 	udelay(150);
+ 
+ 	if (intel_de_wait_for_set(dev_priv, DPLL(pipe), DPLL_LOCK_VLV, 1))
+ 		drm_err(&dev_priv->drm, "DPLL %d failed to lock\n", pipe);
+ }
+ 
+ void vlv_enable_pll(const struct intel_crtc_state *pipe_config)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 
+ 	assert_pipe_disabled(dev_priv, pipe_config->cpu_transcoder);
+ 
+ 	/* PLL is protected by panel, make sure we can write it */
+ 	assert_panel_unlocked(dev_priv, pipe);
+ 
+ 	if (pipe_config->dpll_hw_state.dpll & DPLL_VCO_ENABLE)
+ 		_vlv_enable_pll(pipe_config);
+ 
+ 	intel_de_write(dev_priv, DPLL_MD(pipe),
+ 		       pipe_config->dpll_hw_state.dpll_md);
+ 	intel_de_posting_read(dev_priv, DPLL_MD(pipe));
+ }
+ 
+ 
+ static void _chv_enable_pll(const struct intel_crtc_state *pipe_config)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 	enum dpio_channel port = vlv_pipe_to_channel(pipe);
+ 	u32 tmp;
+ 
+ 	vlv_dpio_get(dev_priv);
+ 
+ 	/* Enable back the 10bit clock to display controller */
+ 	tmp = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW14(port));
+ 	tmp |= DPIO_DCLKP_EN;
+ 	vlv_dpio_write(dev_priv, pipe, CHV_CMN_DW14(port), tmp);
+ 
+ 	vlv_dpio_put(dev_priv);
+ 
+ 	/*
+ 	 * Need to wait > 100ns between dclkp clock enable bit and PLL enable.
+ 	 */
+ 	udelay(1);
+ 
+ 	/* Enable PLL */
+ 	intel_de_write(dev_priv, DPLL(pipe), pipe_config->dpll_hw_state.dpll);
+ 
+ 	/* Check PLL is locked */
+ 	if (intel_de_wait_for_set(dev_priv, DPLL(pipe), DPLL_LOCK_VLV, 1))
+ 		drm_err(&dev_priv->drm, "PLL %d failed to lock\n", pipe);
+ }
+ 
+ void chv_enable_pll(const struct intel_crtc_state *pipe_config)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 
+ 	assert_pipe_disabled(dev_priv, pipe_config->cpu_transcoder);
+ 
+ 	/* PLL is protected by panel, make sure we can write it */
+ 	assert_panel_unlocked(dev_priv, pipe);
+ 
+ 	if (pipe_config->dpll_hw_state.dpll & DPLL_VCO_ENABLE)
+ 		_chv_enable_pll(pipe_config);
+ 
+ 	if (pipe != PIPE_A) {
+ 		/*
+ 		 * WaPixelRepeatModeFixForC0:chv
+ 		 *
+ 		 * DPLLCMD is AWOL. Use chicken bits to propagate
+ 		 * the value from DPLLBMD to either pipe B or C.
+ 		 */
+ 		intel_de_write(dev_priv, CBR4_VLV, CBR_DPLLBMD_PIPE(pipe));
+ 		intel_de_write(dev_priv, DPLL_MD(PIPE_B),
+ 			       pipe_config->dpll_hw_state.dpll_md);
+ 		intel_de_write(dev_priv, CBR4_VLV, 0);
+ 		dev_priv->chv_dpll_md[pipe] = pipe_config->dpll_hw_state.dpll_md;
+ 
+ 		/*
+ 		 * DPLLB VGA mode also seems to cause problems.
+ 		 * We should always have it disabled.
+ 		 */
+ 		drm_WARN_ON(&dev_priv->drm,
+ 			    (intel_de_read(dev_priv, DPLL(PIPE_B)) &
+ 			     DPLL_VGA_MODE_DIS) == 0);
+ 	} else {
+ 		intel_de_write(dev_priv, DPLL_MD(pipe),
+ 			       pipe_config->dpll_hw_state.dpll_md);
+ 		intel_de_posting_read(dev_priv, DPLL_MD(pipe));
+ 	}
+ }
+ 
+ void vlv_prepare_pll(const struct intel_crtc_state *pipe_config)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 	u32 mdiv;
+ 	u32 bestn, bestm1, bestm2, bestp1, bestp2;
+ 	u32 coreclk, reg_val;
+ 
+ 	/* Enable Refclk */
+ 	intel_de_write(dev_priv, DPLL(pipe),
+ 		       pipe_config->dpll_hw_state.dpll & ~(DPLL_VCO_ENABLE | DPLL_EXT_BUFFER_ENABLE_VLV));
+ 
+ 	/* No need to actually set up the DPLL with DSI */
+ 	if ((pipe_config->dpll_hw_state.dpll & DPLL_VCO_ENABLE) == 0)
+ 		return;
+ 
+ 	vlv_dpio_get(dev_priv);
+ 
+ 	bestn = pipe_config->dpll.n;
+ 	bestm1 = pipe_config->dpll.m1;
+ 	bestm2 = pipe_config->dpll.m2;
+ 	bestp1 = pipe_config->dpll.p1;
+ 	bestp2 = pipe_config->dpll.p2;
+ 
+ 	/* See eDP HDMI DPIO driver vbios notes doc */
+ 
+ 	/* PLL B needs special handling */
+ 	if (pipe == PIPE_B)
+ 		vlv_pllb_recal_opamp(dev_priv, pipe);
+ 
+ 	/* Set up Tx target for periodic Rcomp update */
+ 	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW9_BCAST, 0x0100000f);
+ 
+ 	/* Disable target IRef on PLL */
+ 	reg_val = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW8(pipe));
+ 	reg_val &= 0x00ffffff;
+ 	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW8(pipe), reg_val);
+ 
+ 	/* Disable fast lock */
+ 	vlv_dpio_write(dev_priv, pipe, VLV_CMN_DW0, 0x610);
+ 
+ 	/* Set idtafcrecal before PLL is enabled */
+ 	mdiv = ((bestm1 << DPIO_M1DIV_SHIFT) | (bestm2 & DPIO_M2DIV_MASK));
+ 	mdiv |= ((bestp1 << DPIO_P1_SHIFT) | (bestp2 << DPIO_P2_SHIFT));
+ 	mdiv |= ((bestn << DPIO_N_SHIFT));
+ 	mdiv |= (1 << DPIO_K_SHIFT);
+ 
+ 	/*
+ 	 * Post divider depends on pixel clock rate, DAC vs digital (and LVDS,
+ 	 * but we don't support that).
+ 	 * Note: don't use the DAC post divider as it seems unstable.
+ 	 */
+ 	mdiv |= (DPIO_POST_DIV_HDMIDP << DPIO_POST_DIV_SHIFT);
+ 	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW3(pipe), mdiv);
+ 
+ 	mdiv |= DPIO_ENABLE_CALIBRATION;
+ 	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW3(pipe), mdiv);
+ 
+ 	/* Set HBR and RBR LPF coefficients */
+ 	if (pipe_config->port_clock == 162000 ||
+ 	    intel_crtc_has_type(pipe_config, INTEL_OUTPUT_ANALOG) ||
+ 	    intel_crtc_has_type(pipe_config, INTEL_OUTPUT_HDMI))
+ 		vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW10(pipe),
+ 				 0x009f0003);
+ 	else
+ 		vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW10(pipe),
+ 				 0x00d0000f);
+ 
+ 	if (intel_crtc_has_dp_encoder(pipe_config)) {
+ 		/* Use SSC source */
+ 		if (pipe == PIPE_A)
+ 			vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),
+ 					 0x0df40000);
+ 		else
+ 			vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),
+ 					 0x0df70000);
+ 	} else { /* HDMI or VGA */
+ 		/* Use bend source */
+ 		if (pipe == PIPE_A)
+ 			vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),
+ 					 0x0df70000);
+ 		else
+ 			vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),
+ 					 0x0df40000);
+ 	}
+ 
+ 	coreclk = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW7(pipe));
+ 	coreclk = (coreclk & 0x0000ff00) | 0x01c00000;
+ 	if (intel_crtc_has_dp_encoder(pipe_config))
+ 		coreclk |= 0x01000000;
+ 	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW7(pipe), coreclk);
+ 
+ 	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW11(pipe), 0x87871000);
+ 
+ 	vlv_dpio_put(dev_priv);
+ }
+ 
+ void chv_prepare_pll(const struct intel_crtc_state *pipe_config)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 	enum dpio_channel port = vlv_pipe_to_channel(pipe);
+ 	u32 loopfilter, tribuf_calcntr;
+ 	u32 bestn, bestm1, bestm2, bestp1, bestp2, bestm2_frac;
+ 	u32 dpio_val;
+ 	int vco;
+ 
+ 	/* Enable Refclk and SSC */
+ 	intel_de_write(dev_priv, DPLL(pipe),
+ 		       pipe_config->dpll_hw_state.dpll & ~DPLL_VCO_ENABLE);
+ 
+ 	/* No need to actually set up the DPLL with DSI */
+ 	if ((pipe_config->dpll_hw_state.dpll & DPLL_VCO_ENABLE) == 0)
+ 		return;
+ 
+ 	bestn = pipe_config->dpll.n;
+ 	bestm2_frac = pipe_config->dpll.m2 & 0x3fffff;
+ 	bestm1 = pipe_config->dpll.m1;
+ 	bestm2 = pipe_config->dpll.m2 >> 22;
+ 	bestp1 = pipe_config->dpll.p1;
+ 	bestp2 = pipe_config->dpll.p2;
+ 	vco = pipe_config->dpll.vco;
+ 	dpio_val = 0;
+ 	loopfilter = 0;
+ 
+ 	vlv_dpio_get(dev_priv);
+ 
+ 	/* p1 and p2 divider */
+ 	vlv_dpio_write(dev_priv, pipe, CHV_CMN_DW13(port),
+ 			5 << DPIO_CHV_S1_DIV_SHIFT |
+ 			bestp1 << DPIO_CHV_P1_DIV_SHIFT |
+ 			bestp2 << DPIO_CHV_P2_DIV_SHIFT |
+ 			1 << DPIO_CHV_K_DIV_SHIFT);
+ 
+ 	/* Feedback post-divider - m2 */
+ 	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW0(port), bestm2);
+ 
+ 	/* Feedback refclk divider - n and m1 */
+ 	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW1(port),
+ 			DPIO_CHV_M1_DIV_BY_2 |
+ 			1 << DPIO_CHV_N_DIV_SHIFT);
+ 
+ 	/* M2 fraction division */
+ 	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW2(port), bestm2_frac);
+ 
+ 	/* M2 fraction division enable */
+ 	dpio_val = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW3(port));
+ 	dpio_val &= ~(DPIO_CHV_FEEDFWD_GAIN_MASK | DPIO_CHV_FRAC_DIV_EN);
+ 	dpio_val |= (2 << DPIO_CHV_FEEDFWD_GAIN_SHIFT);
+ 	if (bestm2_frac)
+ 		dpio_val |= DPIO_CHV_FRAC_DIV_EN;
+ 	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW3(port), dpio_val);
+ 
+ 	/* Program digital lock detect threshold */
+ 	dpio_val = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW9(port));
+ 	dpio_val &= ~(DPIO_CHV_INT_LOCK_THRESHOLD_MASK |
+ 					DPIO_CHV_INT_LOCK_THRESHOLD_SEL_COARSE);
+ 	dpio_val |= (0x5 << DPIO_CHV_INT_LOCK_THRESHOLD_SHIFT);
+ 	if (!bestm2_frac)
+ 		dpio_val |= DPIO_CHV_INT_LOCK_THRESHOLD_SEL_COARSE;
+ 	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW9(port), dpio_val);
+ 
+ 	/* Loop filter */
+ 	if (vco == 5400000) {
+ 		loopfilter |= (0x3 << DPIO_CHV_PROP_COEFF_SHIFT);
+ 		loopfilter |= (0x8 << DPIO_CHV_INT_COEFF_SHIFT);
+ 		loopfilter |= (0x1 << DPIO_CHV_GAIN_CTRL_SHIFT);
+ 		tribuf_calcntr = 0x9;
+ 	} else if (vco <= 6200000) {
+ 		loopfilter |= (0x5 << DPIO_CHV_PROP_COEFF_SHIFT);
+ 		loopfilter |= (0xB << DPIO_CHV_INT_COEFF_SHIFT);
+ 		loopfilter |= (0x3 << DPIO_CHV_GAIN_CTRL_SHIFT);
+ 		tribuf_calcntr = 0x9;
+ 	} else if (vco <= 6480000) {
+ 		loopfilter |= (0x4 << DPIO_CHV_PROP_COEFF_SHIFT);
+ 		loopfilter |= (0x9 << DPIO_CHV_INT_COEFF_SHIFT);
+ 		loopfilter |= (0x3 << DPIO_CHV_GAIN_CTRL_SHIFT);
+ 		tribuf_calcntr = 0x8;
+ 	} else {
+ 		/* Not supported. Apply the same limits as in the max case */
+ 		loopfilter |= (0x4 << DPIO_CHV_PROP_COEFF_SHIFT);
+ 		loopfilter |= (0x9 << DPIO_CHV_INT_COEFF_SHIFT);
+ 		loopfilter |= (0x3 << DPIO_CHV_GAIN_CTRL_SHIFT);
+ 		tribuf_calcntr = 0;
+ 	}
+ 	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW6(port), loopfilter);
+ 
+ 	dpio_val = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW8(port));
+ 	dpio_val &= ~DPIO_CHV_TDC_TARGET_CNT_MASK;
+ 	dpio_val |= (tribuf_calcntr << DPIO_CHV_TDC_TARGET_CNT_SHIFT);
+ 	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW8(port), dpio_val);
+ 
+ 	/* AFC Recal */
+ 	vlv_dpio_write(dev_priv, pipe, CHV_CMN_DW14(port),
+ 			vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW14(port)) |
+ 			DPIO_AFC_RECAL);
+ 
+ 	vlv_dpio_put(dev_priv);
+ }
+ 
+ /**
+  * vlv_force_pll_on - forcibly enable just the PLL
+  * @dev_priv: i915 private structure
+  * @pipe: pipe PLL to enable
+  * @dpll: PLL configuration
+  *
+  * Enable the PLL for @pipe using the supplied @dpll config. To be used
+  * in cases where we need the PLL enabled even when @pipe is not going to
+  * be enabled.
+  */
+ int vlv_force_pll_on(struct drm_i915_private *dev_priv, enum pipe pipe,
+ 		     const struct dpll *dpll)
+ {
+ 	struct intel_crtc *crtc = intel_get_crtc_for_pipe(dev_priv, pipe);
+ 	struct intel_crtc_state *pipe_config;
+ 
+ 	pipe_config = intel_crtc_state_alloc(crtc);
+ 	if (!pipe_config)
+ 		return -ENOMEM;
+ 
+ 	pipe_config->cpu_transcoder = (enum transcoder)pipe;
+ 	pipe_config->pixel_multiplier = 1;
+ 	pipe_config->dpll = *dpll;
+ 	pipe_config->output_types = BIT(INTEL_OUTPUT_EDP);
+ 
+ 	if (IS_CHERRYVIEW(dev_priv)) {
+ 		chv_compute_dpll(pipe_config);
+ 		chv_prepare_pll(pipe_config);
+ 		chv_enable_pll(pipe_config);
+ 	} else {
+ 		vlv_compute_dpll(pipe_config);
+ 		vlv_prepare_pll(pipe_config);
+ 		vlv_enable_pll(pipe_config);
+ 	}
+ 
+ 	kfree(pipe_config);
+ 
+ 	return 0;
+ }
+ 
+ void vlv_disable_pll(struct drm_i915_private *dev_priv, enum pipe pipe)
+ {
+ 	u32 val;
+ 
+ 	/* Make sure the pipe isn't still relying on us */
+ 	assert_pipe_disabled(dev_priv, (enum transcoder)pipe);
+ 
+ 	val = DPLL_INTEGRATED_REF_CLK_VLV |
+ 		DPLL_REF_CLK_ENABLE_VLV | DPLL_VGA_MODE_DIS;
+ 	if (pipe != PIPE_A)
+ 		val |= DPLL_INTEGRATED_CRI_CLK_VLV;
+ 
+ 	intel_de_write(dev_priv, DPLL(pipe), val);
+ 	intel_de_posting_read(dev_priv, DPLL(pipe));
+ }
+ 
+ void chv_disable_pll(struct drm_i915_private *dev_priv, enum pipe pipe)
+ {
+ 	enum dpio_channel port = vlv_pipe_to_channel(pipe);
+ 	u32 val;
+ 
+ 	/* Make sure the pipe isn't still relying on us */
+ 	assert_pipe_disabled(dev_priv, (enum transcoder)pipe);
+ 
+ 	val = DPLL_SSC_REF_CLK_CHV |
+ 		DPLL_REF_CLK_ENABLE_VLV | DPLL_VGA_MODE_DIS;
+ 	if (pipe != PIPE_A)
+ 		val |= DPLL_INTEGRATED_CRI_CLK_VLV;
+ 
+ 	intel_de_write(dev_priv, DPLL(pipe), val);
+ 	intel_de_posting_read(dev_priv, DPLL(pipe));
+ 
+ 	vlv_dpio_get(dev_priv);
+ 
+ 	/* Disable 10bit clock to display controller */
+ 	val = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW14(port));
+ 	val &= ~DPIO_DCLKP_EN;
+ 	vlv_dpio_write(dev_priv, pipe, CHV_CMN_DW14(port), val);
+ 
+ 	vlv_dpio_put(dev_priv);
+ }
+ 
+ void i9xx_disable_pll(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 
+ 	/* Don't disable pipe or pipe PLLs if needed */
+ 	if (IS_I830(dev_priv))
+ 		return;
+ 
+ 	/* Make sure the pipe isn't still relying on us */
+ 	assert_pipe_disabled(dev_priv, crtc_state->cpu_transcoder);
+ 
+ 	intel_de_write(dev_priv, DPLL(pipe), DPLL_VGA_MODE_DIS);
+ 	intel_de_posting_read(dev_priv, DPLL(pipe));
+ }
+ 
+ 
+ /**
+  * vlv_force_pll_off - forcibly disable just the PLL
+  * @dev_priv: i915 private structure
+  * @pipe: pipe PLL to disable
+  *
+  * Disable the PLL for @pipe. To be used in cases where we need
+  * the PLL enabled even when @pipe is not going to be enabled.
+  */
+ void vlv_force_pll_off(struct drm_i915_private *dev_priv, enum pipe pipe)
+ {
+ 	if (IS_CHERRYVIEW(dev_priv))
+ 		chv_disable_pll(dev_priv, pipe);
+ 	else
+ 		vlv_disable_pll(dev_priv, pipe);
+ }
++>>>>>>> 6205372b4b6d (drm/i915: Clean dpll calling convention)
diff --cc drivers/gpu/drm/i915/display/intel_dpll.h
index caf4615092e1,29f31075cdf0..000000000000
--- a/drivers/gpu/drm/i915/display/intel_dpll.h
+++ b/drivers/gpu/drm/i915/display/intel_dpll.h
@@@ -15,9 -18,23 +15,31 @@@ void intel_dpll_init_clock_hook(struct 
  int vlv_calc_dpll_params(int refclk, struct dpll *clock);
  int pnv_calc_dpll_params(int refclk, struct dpll *clock);
  int i9xx_calc_dpll_params(int refclk, struct dpll *clock);
++<<<<<<< HEAD
 +void vlv_compute_dpll(struct intel_crtc *crtc,
 +		      struct intel_crtc_state *pipe_config);
 +void chv_compute_dpll(struct intel_crtc *crtc,
 +		      struct intel_crtc_state *pipe_config);
 +
++=======
+ u32 i9xx_dpll_compute_fp(const struct dpll *dpll);
+ void vlv_compute_dpll(struct intel_crtc_state *crtc_state);
+ void chv_compute_dpll(struct intel_crtc_state *crtc_state);
+ 
+ int vlv_force_pll_on(struct drm_i915_private *dev_priv, enum pipe pipe,
+ 		     const struct dpll *dpll);
+ void vlv_force_pll_off(struct drm_i915_private *dev_priv, enum pipe pipe);
+ void i9xx_enable_pll(const struct intel_crtc_state *crtc_state);
+ void vlv_enable_pll(const struct intel_crtc_state *crtc_state);
+ void chv_enable_pll(const struct intel_crtc_state *crtc_state);
+ void vlv_disable_pll(struct drm_i915_private *dev_priv, enum pipe pipe);
+ void chv_disable_pll(struct drm_i915_private *dev_priv, enum pipe pipe);
+ void i9xx_disable_pll(const struct intel_crtc_state *crtc_state);
+ void vlv_prepare_pll(const struct intel_crtc_state *crtc_state);
+ void chv_prepare_pll(const struct intel_crtc_state *crtc_state);
+ bool bxt_find_best_dpll(struct intel_crtc_state *crtc_state,
+ 			struct dpll *best_clock);
+ int chv_calc_dpll_params(int refclk, struct dpll *pll_clock);
+ 
++>>>>>>> 6205372b4b6d (drm/i915: Clean dpll calling convention)
  #endif
diff --git a/drivers/gpu/drm/i915/display/intel_display.c b/drivers/gpu/drm/i915/display/intel_display.c
index be4f122dd751..58ff75b96404 100644
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@ -5939,11 +5939,11 @@ static void valleyview_crtc_enable(struct intel_atomic_state *state,
 	intel_encoders_pre_pll_enable(state, crtc);
 
 	if (IS_CHERRYVIEW(dev_priv)) {
-		chv_prepare_pll(crtc, new_crtc_state);
-		chv_enable_pll(crtc, new_crtc_state);
+		chv_prepare_pll(new_crtc_state);
+		chv_enable_pll(new_crtc_state);
 	} else {
-		vlv_prepare_pll(crtc, new_crtc_state);
-		vlv_enable_pll(crtc, new_crtc_state);
+		vlv_prepare_pll(new_crtc_state);
+		vlv_enable_pll(new_crtc_state);
 	}
 
 	intel_encoders_pre_enable(state, crtc);
@@ -6002,7 +6002,7 @@ static void i9xx_crtc_enable(struct intel_atomic_state *state,
 
 	intel_encoders_pre_enable(state, crtc);
 
-	i9xx_enable_pll(crtc, new_crtc_state);
+	i9xx_enable_pll(new_crtc_state);
 
 	i9xx_pfit_enable(new_crtc_state);
 
@@ -9970,7 +9970,7 @@ static int intel_crtc_atomic_check(struct intel_atomic_state *state,
 	    dev_priv->display.crtc_compute_clock &&
 	    !crtc_state->bigjoiner_slave &&
 	    !drm_WARN_ON(&dev_priv->drm, crtc_state->shared_dpll)) {
-		ret = dev_priv->display.crtc_compute_clock(crtc, crtc_state);
+		ret = dev_priv->display.crtc_compute_clock(crtc_state);
 		if (ret)
 			return ret;
 	}
* Unmerged path drivers/gpu/drm/i915/display/intel_dpll.c
* Unmerged path drivers/gpu/drm/i915/display/intel_dpll.h
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index 6638c0aec2d4..b10470cb3359 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -288,8 +288,7 @@ struct drm_i915_display_funcs {
 				struct intel_crtc_state *);
 	void (*get_initial_plane_config)(struct intel_crtc *,
 					 struct intel_initial_plane_config *);
-	int (*crtc_compute_clock)(struct intel_crtc *crtc,
-				  struct intel_crtc_state *crtc_state);
+	int (*crtc_compute_clock)(struct intel_crtc_state *crtc_state);
 	void (*crtc_enable)(struct intel_atomic_state *state,
 			    struct intel_crtc *crtc);
 	void (*crtc_disable)(struct intel_atomic_state *state,
