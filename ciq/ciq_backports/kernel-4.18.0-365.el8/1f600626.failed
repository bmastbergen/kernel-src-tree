kasan: rename KASAN_SHADOW_* to KASAN_GRANULE_*

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Andrey Konovalov <andreyknvl@google.com>
commit 1f600626b3a9b77001b3ef90a79bf68c9f7e4cda
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/1f600626.failed

This is a preparatory commit for the upcoming addition of a new hardware
tag-based (MTE-based) KASAN mode.

The new mode won't be using shadow memory, but will still use the concept
of memory granules.  Each memory granule maps to a single metadata entry:
8 bytes per one shadow byte for generic mode, 16 bytes per one shadow byte
for software tag-based mode, and 16 bytes per one allocation tag for
hardware tag-based mode.

Rename KASAN_SHADOW_SCALE_SIZE to KASAN_GRANULE_SIZE, and
KASAN_SHADOW_MASK to KASAN_GRANULE_MASK.

Also use MASK when used as a mask, otherwise use SIZE.

No functional changes.

Link: https://lkml.kernel.org/r/939b5754e47f528a6e6a6f28ffc5815d8d128033.1606161801.git.andreyknvl@google.com
	Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
	Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Reviewed-by: Marco Elver <elver@google.com>
	Reviewed-by: Alexander Potapenko <glider@google.com>
	Tested-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Branislav Rankov <Branislav.Rankov@arm.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Evgenii Stepanov <eugenis@google.com>
	Cc: Kevin Brodsky <kevin.brodsky@arm.com>
	Cc: Vasily Gorbik <gor@linux.ibm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 1f600626b3a9b77001b3ef90a79bf68c9f7e4cda)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/test_kasan_module.c
#	mm/kasan/common.c
#	mm/kasan/report.c
diff --cc mm/kasan/common.c
index 5c1cf01c4cee,166e36e0033e..000000000000
--- a/mm/kasan/common.c
+++ b/mm/kasan/common.c
@@@ -130,9 -106,9 +130,9 @@@ void *memcpy(void *dest, const void *sr
  
  /*
   * Poisons the shadow memory for 'size' bytes starting from 'addr'.
-  * Memory addresses should be aligned to KASAN_SHADOW_SCALE_SIZE.
+  * Memory addresses should be aligned to KASAN_GRANULE_SIZE.
   */
 -void poison_range(const void *address, size_t size, u8 value)
 +void kasan_poison_shadow(const void *address, size_t size, u8 value)
  {
  	void *shadow_start, *shadow_end;
  
@@@ -160,9 -136,9 +160,9 @@@ void kasan_unpoison_shadow(const void *
  	 */
  	address = reset_tag(address);
  
 -	poison_range(address, size, tag);
 +	kasan_poison_shadow(address, size, tag);
  
- 	if (size & KASAN_SHADOW_MASK) {
+ 	if (size & KASAN_GRANULE_MASK) {
  		u8 *shadow = (u8 *)kasan_mem_to_shadow(address + size);
  
  		if (IS_ENABLED(CONFIG_KASAN_SW_TAGS))
@@@ -319,8 -300,8 +319,13 @@@ void kasan_unpoison_object_data(struct 
  
  void kasan_poison_object_data(struct kmem_cache *cache, void *object)
  {
++<<<<<<< HEAD
 +	kasan_poison_shadow(object,
 +			round_up(cache->object_size, KASAN_SHADOW_SCALE_SIZE),
++=======
+ 	poison_range(object,
+ 			round_up(cache->object_size, KASAN_GRANULE_SIZE),
++>>>>>>> 1f600626b3a9 (kasan: rename KASAN_SHADOW_* to KASAN_GRANULE_*)
  			KASAN_KMALLOC_REDZONE);
  }
  
@@@ -431,8 -412,8 +436,13 @@@ static bool __kasan_slab_free(struct km
  		return true;
  	}
  
++<<<<<<< HEAD
 +	rounded_up_size = round_up(cache->object_size, KASAN_SHADOW_SCALE_SIZE);
 +	kasan_poison_shadow(object, rounded_up_size, KASAN_KMALLOC_FREE);
++=======
+ 	rounded_up_size = round_up(cache->object_size, KASAN_GRANULE_SIZE);
+ 	poison_range(object, rounded_up_size, KASAN_KMALLOC_FREE);
++>>>>>>> 1f600626b3a9 (kasan: rename KASAN_SHADOW_* to KASAN_GRANULE_*)
  
  	if ((IS_ENABLED(CONFIG_KASAN_GENERIC) && !quarantine) ||
  			unlikely(!(cache->flags & SLAB_KASAN)))
@@@ -510,12 -491,12 +520,12 @@@ void * __must_check kasan_kmalloc_large
  
  	page = virt_to_page(ptr);
  	redzone_start = round_up((unsigned long)(ptr + size),
- 				KASAN_SHADOW_SCALE_SIZE);
+ 				KASAN_GRANULE_SIZE);
  	redzone_end = (unsigned long)ptr + page_size(page);
  
 -	unpoison_range(ptr, size);
 -	poison_range((void *)redzone_start, redzone_end - redzone_start,
 -		     KASAN_PAGE_REDZONE);
 +	kasan_unpoison_shadow(ptr, size);
 +	kasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,
 +		KASAN_PAGE_REDZONE);
  
  	return (void *)ptr;
  }
@@@ -822,8 -748,8 +832,13 @@@ void kasan_poison_vmalloc(const void *s
  	if (!is_vmalloc_or_module_addr(start))
  		return;
  
++<<<<<<< HEAD
 +	size = round_up(size, KASAN_SHADOW_SCALE_SIZE);
 +	kasan_poison_shadow(start, size, KASAN_VMALLOC_INVALID);
++=======
+ 	size = round_up(size, KASAN_GRANULE_SIZE);
+ 	poison_range(start, size, KASAN_VMALLOC_INVALID);
++>>>>>>> 1f600626b3a9 (kasan: rename KASAN_SHADOW_* to KASAN_GRANULE_*)
  }
  
  void kasan_unpoison_vmalloc(const void *start, unsigned long size)
@@@ -965,4 -891,44 +980,47 @@@ void kasan_release_vmalloc(unsigned lon
  				       (unsigned long)shadow_end);
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ #else /* CONFIG_KASAN_VMALLOC */
+ 
+ int kasan_module_alloc(void *addr, size_t size)
+ {
+ 	void *ret;
+ 	size_t scaled_size;
+ 	size_t shadow_size;
+ 	unsigned long shadow_start;
+ 
+ 	shadow_start = (unsigned long)kasan_mem_to_shadow(addr);
+ 	scaled_size = (size + KASAN_GRANULE_SIZE - 1) >>
+ 				KASAN_SHADOW_SCALE_SHIFT;
+ 	shadow_size = round_up(scaled_size, PAGE_SIZE);
+ 
+ 	if (WARN_ON(!PAGE_ALIGNED(shadow_start)))
+ 		return -EINVAL;
+ 
+ 	ret = __vmalloc_node_range(shadow_size, 1, shadow_start,
+ 			shadow_start + shadow_size,
+ 			GFP_KERNEL,
+ 			PAGE_KERNEL, VM_NO_GUARD, NUMA_NO_NODE,
+ 			__builtin_return_address(0));
+ 
+ 	if (ret) {
+ 		__memset(ret, KASAN_SHADOW_INIT, shadow_size);
+ 		find_vm_area(addr)->flags |= VM_KASAN;
+ 		kmemleak_ignore(ret);
+ 		return 0;
+ 	}
+ 
+ 	return -ENOMEM;
+ }
+ 
+ void kasan_free_shadow(const struct vm_struct *vm)
+ {
+ 	if (vm->flags & VM_KASAN)
+ 		vfree(kasan_mem_to_shadow(vm->addr));
+ }
+ 
++>>>>>>> 1f600626b3a9 (kasan: rename KASAN_SHADOW_* to KASAN_GRANULE_*)
  #endif
diff --cc mm/kasan/report.c
index abb2fbfc9202,d16ccbc7e4b2..000000000000
--- a/mm/kasan/report.c
+++ b/mm/kasan/report.c
@@@ -512,3 -546,59 +512,62 @@@ void __kasan_report(unsigned long addr
  
  	end_report(&flags);
  }
++<<<<<<< HEAD
++=======
+ 
+ bool kasan_report(unsigned long addr, size_t size, bool is_write,
+ 			unsigned long ip)
+ {
+ 	unsigned long flags = user_access_save();
+ 	bool ret = false;
+ 
+ 	if (likely(report_enabled())) {
+ 		__kasan_report(addr, size, is_write, ip);
+ 		ret = true;
+ 	}
+ 
+ 	user_access_restore(flags);
+ 
+ 	return ret;
+ }
+ 
+ #ifdef CONFIG_KASAN_INLINE
+ /*
+  * With CONFIG_KASAN_INLINE, accesses to bogus pointers (outside the high
+  * canonical half of the address space) cause out-of-bounds shadow memory reads
+  * before the actual access. For addresses in the low canonical half of the
+  * address space, as well as most non-canonical addresses, that out-of-bounds
+  * shadow memory access lands in the non-canonical part of the address space.
+  * Help the user figure out what the original bogus pointer was.
+  */
+ void kasan_non_canonical_hook(unsigned long addr)
+ {
+ 	unsigned long orig_addr;
+ 	const char *bug_type;
+ 
+ 	if (addr < KASAN_SHADOW_OFFSET)
+ 		return;
+ 
+ 	orig_addr = (addr - KASAN_SHADOW_OFFSET) << KASAN_SHADOW_SCALE_SHIFT;
+ 	/*
+ 	 * For faults near the shadow address for NULL, we can be fairly certain
+ 	 * that this is a KASAN shadow memory access.
+ 	 * For faults that correspond to shadow for low canonical addresses, we
+ 	 * can still be pretty sure - that shadow region is a fairly narrow
+ 	 * chunk of the non-canonical address space.
+ 	 * But faults that look like shadow for non-canonical addresses are a
+ 	 * really large chunk of the address space. In that case, we still
+ 	 * print the decoded address, but make it clear that this is not
+ 	 * necessarily what's actually going on.
+ 	 */
+ 	if (orig_addr < PAGE_SIZE)
+ 		bug_type = "null-ptr-deref";
+ 	else if (orig_addr < TASK_SIZE)
+ 		bug_type = "probably user-memory-access";
+ 	else
+ 		bug_type = "maybe wild-memory-access";
+ 	pr_alert("KASAN: %s in range [0x%016lx-0x%016lx]\n", bug_type,
+ 		 orig_addr, orig_addr + KASAN_GRANULE_SIZE - 1);
+ }
+ #endif
++>>>>>>> 1f600626b3a9 (kasan: rename KASAN_SHADOW_* to KASAN_GRANULE_*)
* Unmerged path lib/test_kasan_module.c
diff --git a/Documentation/dev-tools/kasan.rst b/Documentation/dev-tools/kasan.rst
index 19b982c535c7..83332ea38967 100644
--- a/Documentation/dev-tools/kasan.rst
+++ b/Documentation/dev-tools/kasan.rst
@@ -264,7 +264,7 @@ Most mappings in vmalloc space are small, requiring less than a full
 page of shadow space. Allocating a full shadow page per mapping would
 therefore be wasteful. Furthermore, to ensure that different mappings
 use different shadow pages, mappings would have to be aligned to
-``KASAN_SHADOW_SCALE_SIZE * PAGE_SIZE``.
+``KASAN_GRANULE_SIZE * PAGE_SIZE``.
 
 Instead, we share backing space across multiple mappings. We allocate
 a backing page when a mapping in vmalloc space uses a particular page
diff --git a/lib/test_kasan.c b/lib/test_kasan.c
index 5679dda37d78..9be5e1d702fb 100644
--- a/lib/test_kasan.c
+++ b/lib/test_kasan.c
@@ -29,7 +29,7 @@
 
 #include "../mm/kasan/kasan.h"
 
-#define OOB_TAG_OFF (IS_ENABLED(CONFIG_KASAN_GENERIC) ? 0 : KASAN_SHADOW_SCALE_SIZE)
+#define OOB_TAG_OFF (IS_ENABLED(CONFIG_KASAN_GENERIC) ? 0 : KASAN_GRANULE_SIZE)
 
 /*
  * We assign some test results to these globals to make sure the tests
* Unmerged path lib/test_kasan_module.c
* Unmerged path mm/kasan/common.c
diff --git a/mm/kasan/generic.c b/mm/kasan/generic.c
index d341859a1b95..a9336037846f 100644
--- a/mm/kasan/generic.c
+++ b/mm/kasan/generic.c
@@ -46,7 +46,7 @@ static __always_inline bool memory_is_poisoned_1(unsigned long addr)
 	s8 shadow_value = *(s8 *)kasan_mem_to_shadow((void *)addr);
 
 	if (unlikely(shadow_value)) {
-		s8 last_accessible_byte = addr & KASAN_SHADOW_MASK;
+		s8 last_accessible_byte = addr & KASAN_GRANULE_MASK;
 		return unlikely(last_accessible_byte >= shadow_value);
 	}
 
@@ -62,7 +62,7 @@ static __always_inline bool memory_is_poisoned_2_4_8(unsigned long addr,
 	 * Access crosses 8(shadow size)-byte boundary. Such access maps
 	 * into 2 shadow bytes, so we need to check them both.
 	 */
-	if (unlikely(((addr + size - 1) & KASAN_SHADOW_MASK) < size - 1))
+	if (unlikely(((addr + size - 1) & KASAN_GRANULE_MASK) < size - 1))
 		return *shadow_addr || memory_is_poisoned_1(addr + size - 1);
 
 	return memory_is_poisoned_1(addr + size - 1);
@@ -73,7 +73,7 @@ static __always_inline bool memory_is_poisoned_16(unsigned long addr)
 	u16 *shadow_addr = (u16 *)kasan_mem_to_shadow((void *)addr);
 
 	/* Unaligned 16-bytes access maps into 3 shadow bytes. */
-	if (unlikely(!IS_ALIGNED(addr, KASAN_SHADOW_SCALE_SIZE)))
+	if (unlikely(!IS_ALIGNED(addr, KASAN_GRANULE_SIZE)))
 		return *shadow_addr || memory_is_poisoned_1(addr + 15);
 
 	return *shadow_addr;
@@ -134,7 +134,7 @@ static __always_inline bool memory_is_poisoned_n(unsigned long addr,
 		s8 *last_shadow = (s8 *)kasan_mem_to_shadow((void *)last_byte);
 
 		if (unlikely(ret != (unsigned long)last_shadow ||
-			((long)(last_byte & KASAN_SHADOW_MASK) >= *last_shadow)))
+			((long)(last_byte & KASAN_GRANULE_MASK) >= *last_shadow)))
 			return true;
 	}
 	return false;
@@ -200,7 +200,7 @@ void kasan_cache_shutdown(struct kmem_cache *cache)
 
 static void register_global(struct kasan_global *global)
 {
-	size_t aligned_size = round_up(global->size, KASAN_SHADOW_SCALE_SIZE);
+	size_t aligned_size = round_up(global->size, KASAN_GRANULE_SIZE);
 
 	kasan_unpoison_shadow(global->beg, global->size);
 
@@ -274,10 +274,10 @@ EXPORT_SYMBOL(__asan_handle_no_return);
 /* Emitted by compiler to poison alloca()ed objects. */
 void __asan_alloca_poison(unsigned long addr, size_t size)
 {
-	size_t rounded_up_size = round_up(size, KASAN_SHADOW_SCALE_SIZE);
+	size_t rounded_up_size = round_up(size, KASAN_GRANULE_SIZE);
 	size_t padding_size = round_up(size, KASAN_ALLOCA_REDZONE_SIZE) -
 			rounded_up_size;
-	size_t rounded_down_size = round_down(size, KASAN_SHADOW_SCALE_SIZE);
+	size_t rounded_down_size = round_down(size, KASAN_GRANULE_SIZE);
 
 	const void *left_redzone = (const void *)(addr -
 			KASAN_ALLOCA_REDZONE_SIZE);
diff --git a/mm/kasan/generic_report.c b/mm/kasan/generic_report.c
index 6bb3f66992df..7d5b9e5c7cfe 100644
--- a/mm/kasan/generic_report.c
+++ b/mm/kasan/generic_report.c
@@ -34,7 +34,7 @@ void *find_first_bad_addr(void *addr, size_t size)
 	void *p = addr;
 
 	while (p < addr + size && !(*(u8 *)kasan_mem_to_shadow(p)))
-		p += KASAN_SHADOW_SCALE_SIZE;
+		p += KASAN_GRANULE_SIZE;
 	return p;
 }
 
@@ -46,14 +46,14 @@ static const char *get_shadow_bug_type(struct kasan_access_info *info)
 	shadow_addr = (u8 *)kasan_mem_to_shadow(info->first_bad_addr);
 
 	/*
-	 * If shadow byte value is in [0, KASAN_SHADOW_SCALE_SIZE) we can look
+	 * If shadow byte value is in [0, KASAN_GRANULE_SIZE) we can look
 	 * at the next shadow byte to determine the type of the bad access.
 	 */
-	if (*shadow_addr > 0 && *shadow_addr <= KASAN_SHADOW_SCALE_SIZE - 1)
+	if (*shadow_addr > 0 && *shadow_addr <= KASAN_GRANULE_SIZE - 1)
 		shadow_addr++;
 
 	switch (*shadow_addr) {
-	case 0 ... KASAN_SHADOW_SCALE_SIZE - 1:
+	case 0 ... KASAN_GRANULE_SIZE - 1:
 		/*
 		 * In theory it's still possible to see these shadow values
 		 * due to a data race in the kernel code.
diff --git a/mm/kasan/init.c b/mm/kasan/init.c
index b4f57b054115..f43276b96fde 100644
--- a/mm/kasan/init.c
+++ b/mm/kasan/init.c
@@ -456,8 +456,8 @@ void kasan_remove_zero_shadow(void *start, unsigned long size)
 	end = addr + (size >> KASAN_SHADOW_SCALE_SHIFT);
 
 	if (WARN_ON((unsigned long)start %
-			(KASAN_SHADOW_SCALE_SIZE * PAGE_SIZE)) ||
-	    WARN_ON(size % (KASAN_SHADOW_SCALE_SIZE * PAGE_SIZE)))
+			(KASAN_GRANULE_SIZE * PAGE_SIZE)) ||
+	    WARN_ON(size % (KASAN_GRANULE_SIZE * PAGE_SIZE)))
 		return;
 
 	for (; addr < end; addr = next) {
@@ -492,8 +492,8 @@ int kasan_add_zero_shadow(void *start, unsigned long size)
 	shadow_end = shadow_start + (size >> KASAN_SHADOW_SCALE_SHIFT);
 
 	if (WARN_ON((unsigned long)start %
-			(KASAN_SHADOW_SCALE_SIZE * PAGE_SIZE)) ||
-	    WARN_ON(size % (KASAN_SHADOW_SCALE_SIZE * PAGE_SIZE)))
+			(KASAN_GRANULE_SIZE * PAGE_SIZE)) ||
+	    WARN_ON(size % (KASAN_GRANULE_SIZE * PAGE_SIZE)))
 		return -EINVAL;
 
 	ret = kasan_populate_early_shadow(shadow_start, shadow_end);
diff --git a/mm/kasan/kasan.h b/mm/kasan/kasan.h
index ac499456740f..6dacd5f98ae3 100644
--- a/mm/kasan/kasan.h
+++ b/mm/kasan/kasan.h
@@ -5,8 +5,8 @@
 #include <linux/kasan.h>
 #include <linux/stackdepot.h>
 
-#define KASAN_SHADOW_SCALE_SIZE (1UL << KASAN_SHADOW_SCALE_SHIFT)
-#define KASAN_SHADOW_MASK       (KASAN_SHADOW_SCALE_SIZE - 1)
+#define KASAN_GRANULE_SIZE	(1UL << KASAN_SHADOW_SCALE_SHIFT)
+#define KASAN_GRANULE_MASK	(KASAN_GRANULE_SIZE - 1)
 
 #define KASAN_TAG_KERNEL	0xFF /* native kernel pointers tag */
 #define KASAN_TAG_INVALID	0xFE /* inaccessible memory tag */
* Unmerged path mm/kasan/report.c
diff --git a/mm/kasan/tags_report.c b/mm/kasan/tags_report.c
index 5f183501b871..c87d5a343b4e 100644
--- a/mm/kasan/tags_report.c
+++ b/mm/kasan/tags_report.c
@@ -76,7 +76,7 @@ void *find_first_bad_addr(void *addr, size_t size)
 	void *end = p + size;
 
 	while (p < end && tag == *(u8 *)kasan_mem_to_shadow(p))
-		p += KASAN_SHADOW_SCALE_SIZE;
+		p += KASAN_GRANULE_SIZE;
 	return p;
 }
 
