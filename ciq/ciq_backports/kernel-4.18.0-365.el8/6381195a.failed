ACPI: power: Rework turning off unused power resources

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 6381195ad7d06ef979528c7452f3ff93659f86b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/6381195a.failed

Make turning off unused power resources (after the enumeration of
devices and during system-wide resume from S3) more straightforward
by using the observation that the power resource state stored in
struct acpi_power_resource can be used to determine whether or not
the give power resource has any users.

Namely, when the state of the power resource is unknown, its _STA
method has never been evaluated (or the evaluation of it has failed)
and its _ON and _OFF methods have never been executed (or they have
failed to execute), so for all practical purposes it can be assumed
to have no users (or to be unusable).  Therefore, instead of checking
the number of power resource users, it is sufficient to check if its
state is known.

Moreover, if the last known state of a given power resource is "off",
it is not necessary to turn it off, because it has been used to
initialize the power state or the wakeup power resources list of at
least one device and either its _STA method has returned 0 ("off"),
or its _OFF method has been successfully executed already.

Accordingly, modify acpi_turn_off_unused_power_resources() to do the
above checks (which are suitable for both uses of it) instead of
using the number of power resource users or evaluating its _STA
method, drop its argument (which is not useful any more) and update
its callers.

Also drop the users field from struct acpi_power_resource as it is
not useful any more.

	Tested-by: Dave Olsthoorn <dave@bewaar.me>
	Tested-by: Shujun Wang <wsj20369@163.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 6381195ad7d06ef979528c7452f3ff93659f86b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/power.c
diff --cc drivers/acpi/power.c
index 3fdfde3a851a,f145f645ab06..000000000000
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@@ -65,7 -52,7 +65,11 @@@ struct acpi_power_resource 
  	u32 system_level;
  	u32 order;
  	unsigned int ref_count;
++<<<<<<< HEAD
 +	unsigned int users;
++=======
+ 	u8 state;
++>>>>>>> 6381195ad7d0 (ACPI: power: Rework turning off unused power resources)
  	bool wakeup_enabled;
  	struct mutex resource_lock;
  	struct list_head dependents;
@@@ -1029,38 -1015,10 +1031,34 @@@ void acpi_resume_power_resources(void
  }
  #endif
  
++<<<<<<< HEAD
 +static void acpi_power_turn_off_if_unused(struct acpi_power_resource *resource,
 +				       bool init)
 +{
 +	if (resource->ref_count > 0)
 +		return;
 +
 +	if (init) {
 +		if (resource->users > 0)
 +			return;
 +	} else {
 +		int result, state;
 +
 +		result = acpi_power_get_state(resource->device.handle, &state);
 +		if (result || state == ACPI_POWER_RESOURCE_STATE_OFF)
 +			return;
 +	}
 +
 +	dev_info(&resource->device.dev, "Turning OFF\n");
 +	__acpi_power_off(resource);
 +}
 +
++=======
++>>>>>>> 6381195ad7d0 (ACPI: power: Rework turning off unused power resources)
  /**
   * acpi_turn_off_unused_power_resources - Turn off power resources not in use.
-  * @init: Control switch.
-  *
-  * If @ainit is set, unconditionally turn off all of the ACPI power resources
-  * without any users.
-  *
-  * Otherwise, turn off all ACPI power resources without active references (that
-  * is, the ones that should be "off" at the moment) that are "on".
   */
- void acpi_turn_off_unused_power_resources(bool init)
+ void acpi_turn_off_unused_power_resources(void)
  {
  	struct acpi_power_resource *resource;
  
diff --git a/drivers/acpi/internal.h b/drivers/acpi/internal.h
index dcf19a020b0a..e496e8750764 100644
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@ -147,7 +147,7 @@ int acpi_device_sleep_wake(struct acpi_device *dev,
 int acpi_power_get_inferred_state(struct acpi_device *device, int *state);
 int acpi_power_on_resources(struct acpi_device *device, int state);
 int acpi_power_transition(struct acpi_device *device, int state);
-void acpi_turn_off_unused_power_resources(bool init);
+void acpi_turn_off_unused_power_resources(void);
 
 /* --------------------------------------------------------------------------
                               Device Power Management
* Unmerged path drivers/acpi/power.c
diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b813ab6b3845..52859bddeaf4 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2366,7 +2366,7 @@ int __init acpi_scan_init(void)
 		}
 	}
 
-	acpi_turn_off_unused_power_resources(true);
+	acpi_turn_off_unused_power_resources();
 
 	acpi_scan_initialized = true;
 
diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index aa77b6da4766..b96e0234e146 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -506,7 +506,7 @@ static void acpi_pm_start(u32 acpi_state)
  */
 static void acpi_pm_end(void)
 {
-	acpi_turn_off_unused_power_resources(false);
+	acpi_turn_off_unused_power_resources();
 	acpi_scan_lock_release();
 	/*
 	 * This is necessary in case acpi_pm_finish() is not called during a
