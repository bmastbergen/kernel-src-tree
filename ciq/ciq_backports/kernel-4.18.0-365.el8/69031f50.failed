swiotlb: Set dev->dma_io_tlb_mem to the swiotlb pool used

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Claire Chang <tientzu@chromium.org>
commit 69031f500865ee3eee19566a1b9c40a189817eaa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/69031f50.failed

Always have the pointer to the swiotlb pool used in struct device. This
could help simplify the code for other pools.

	Signed-off-by: Claire Chang <tientzu@chromium.org>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Tested-by: Stefano Stabellini <sstabellini@kernel.org>
	Tested-by: Will Deacon <will@kernel.org>
	Acked-by: Stefano Stabellini <sstabellini@kernel.org>
	Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
(cherry picked from commit 69031f500865ee3eee19566a1b9c40a189817eaa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/core.c
#	kernel/dma/swiotlb.c
diff --cc drivers/base/core.c
index 88a9aafab2f4,ea5b85354526..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -26,7 -26,10 +26,12 @@@
  #include <linux/pm_runtime.h>
  #include <linux/netdevice.h>
  #include <linux/sched/signal.h>
++<<<<<<< HEAD
++=======
+ #include <linux/sched/mm.h>
+ #include <linux/swiotlb.h>
++>>>>>>> 69031f500865 (swiotlb: Set dev->dma_io_tlb_mem to the swiotlb pool used)
  #include <linux/sysfs.h>
 -#include <linux/dma-map-ops.h> /* for dma_default_coherent */
  
  #include "base.h"
  #include "power/power.h"
@@@ -2579,8 -2840,16 +2584,19 @@@ void device_initialize(struct device *d
  #endif
  	INIT_LIST_HEAD(&dev->links.consumers);
  	INIT_LIST_HEAD(&dev->links.suppliers);
 -	INIT_LIST_HEAD(&dev->links.defer_sync);
 +	INIT_LIST_HEAD(&dev->links_defer_sync);
  	dev->links.status = DL_DEV_NO_DRIVER;
++<<<<<<< HEAD
++=======
+ #if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \
+     defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \
+     defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)
+ 	dev->dma_coherent = dma_default_coherent;
+ #endif
+ #ifdef CONFIG_SWIOTLB
+ 	dev->dma_io_tlb_mem = io_tlb_default_mem;
+ #endif
++>>>>>>> 69031f500865 (swiotlb: Set dev->dma_io_tlb_mem to the swiotlb pool used)
  }
  EXPORT_SYMBOL_GPL(device_initialize);
  
diff --cc kernel/dma/swiotlb.c
index be0e4e04c6fd,33d413beddd4..000000000000
--- a/kernel/dma/swiotlb.c
+++ b/kernel/dma/swiotlb.c
@@@ -467,11 -345,32 +467,18 @@@ void __init swiotlb_exit(void
  /*
   * Bounce: copy the swiotlb buffer from or back to the original dma location
   */
 -static void swiotlb_bounce(struct device *dev, phys_addr_t tlb_addr, size_t size,
 -			   enum dma_data_direction dir)
 +static void swiotlb_bounce(phys_addr_t orig_addr, phys_addr_t tlb_addr,
 +			   size_t size, enum dma_data_direction dir)
  {
++<<<<<<< HEAD
++=======
+ 	struct io_tlb_mem *mem = dev->dma_io_tlb_mem;
+ 	int index = (tlb_addr - mem->start) >> IO_TLB_SHIFT;
+ 	phys_addr_t orig_addr = mem->slots[index].orig_addr;
+ 	size_t alloc_size = mem->slots[index].alloc_size;
++>>>>>>> 69031f500865 (swiotlb: Set dev->dma_io_tlb_mem to the swiotlb pool used)
  	unsigned long pfn = PFN_DOWN(orig_addr);
  	unsigned char *vaddr = phys_to_virt(tlb_addr);
 -	unsigned int tlb_offset;
 -
 -	if (orig_addr == INVALID_PHYS_ADDR)
 -		return;
 -
 -	tlb_offset = (tlb_addr & (IO_TLB_SIZE - 1)) -
 -		     swiotlb_align_offset(dev, orig_addr);
 -
 -	orig_addr += tlb_offset;
 -	alloc_size -= tlb_offset;
 -
 -	if (size > alloc_size) {
 -		dev_WARN_ONCE(dev, 1,
 -			"Buffer overflow detected. Allocation size: %zu. Mapping size: %zu.\n",
 -			alloc_size, size);
 -		size = alloc_size;
 -	}
  
  	if (PageHighMem(pfn_to_page(pfn))) {
  		/* The buffer does not have a mapping.  Map it in and copy */
@@@ -538,9 -429,10 +545,13 @@@ static unsigned int wrap_index(unsigne
  static int find_slots(struct device *dev, phys_addr_t orig_addr,
  		size_t alloc_size)
  {
++<<<<<<< HEAD
++=======
+ 	struct io_tlb_mem *mem = dev->dma_io_tlb_mem;
++>>>>>>> 69031f500865 (swiotlb: Set dev->dma_io_tlb_mem to the swiotlb pool used)
  	unsigned long boundary_mask = dma_get_seg_boundary(dev);
  	dma_addr_t tbl_dma_addr =
 -		phys_to_dma_unencrypted(dev, mem->start) & boundary_mask;
 +		phys_to_dma_unencrypted(dev, io_tlb_start) & boundary_mask;
  	unsigned long max_slots = get_max_slots(boundary_mask);
  	unsigned int iotlb_align_mask =
  		dma_get_min_align_mask(dev) & ~(IO_TLB_SIZE - 1);
@@@ -614,6 -506,7 +625,10 @@@ phys_addr_t swiotlb_tbl_map_single(stru
  		size_t mapping_size, size_t alloc_size,
  		enum dma_data_direction dir, unsigned long attrs)
  {
++<<<<<<< HEAD
++=======
+ 	struct io_tlb_mem *mem = dev->dma_io_tlb_mem;
++>>>>>>> 69031f500865 (swiotlb: Set dev->dma_io_tlb_mem to the swiotlb pool used)
  	unsigned int offset = swiotlb_align_offset(dev, orig_addr);
  	unsigned int i;
  	int index;
@@@ -671,16 -554,15 +686,20 @@@ static void validate_sync_size_and_trun
   * tlb_addr is the physical address of the bounce buffer to unmap.
   */
  void swiotlb_tbl_unmap_single(struct device *hwdev, phys_addr_t tlb_addr,
 -			      size_t mapping_size, enum dma_data_direction dir,
 -			      unsigned long attrs)
 +			      size_t mapping_size, size_t alloc_size,
 +			      enum dma_data_direction dir, unsigned long attrs)
  {
++<<<<<<< HEAD
++=======
+ 	struct io_tlb_mem *mem = hwdev->dma_io_tlb_mem;
++>>>>>>> 69031f500865 (swiotlb: Set dev->dma_io_tlb_mem to the swiotlb pool used)
  	unsigned long flags;
  	unsigned int offset = swiotlb_align_offset(hwdev, tlb_addr);
 -	int index = (tlb_addr - offset - mem->start) >> IO_TLB_SHIFT;
 -	int nslots = nr_slots(mem->slots[index].alloc_size + offset);
 -	int count, i;
 +	int i, count, nslots = nr_slots(alloc_size + offset);
 +	int index = (tlb_addr - offset - io_tlb_start) >> IO_TLB_SHIFT;
 +	phys_addr_t orig_addr = io_tlb_orig_addr[index];
 +
 +	validate_sync_size_and_truncate(hwdev, io_tlb_orig_size[index], &mapping_size);
  
  	/*
  	 * First, sync the memory before unmapping the entry
* Unmerged path drivers/base/core.c
diff --git a/include/linux/device.h b/include/linux/device.h
index 08956d517202..1cc67e7bccbe 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -1159,6 +1159,7 @@ struct device_extended_rh {
  * @dma_pools:	Dma pools (if dma'ble device).
  * @dma_mem:	Internal for coherent mem override.
  * @cma_area:	Contiguous memory area for dma allocations
+ * @dma_io_tlb_mem: Pointer to the swiotlb pool used.  Not for driver use.
  * @archdata:	For arch-specific additions.
  * @of_node:	Associated device tree node.
  * @fwnode:	Associated device node supplied by platform firmware.
@@ -1257,6 +1258,9 @@ struct device {
 #ifdef CONFIG_DMA_CMA
 	struct cma *cma_area;		/* contiguous memory area for dma
 					   allocations */
+#endif
+#ifdef CONFIG_SWIOTLB
+	struct io_tlb_mem *dma_io_tlb_mem;
 #endif
 	/* arch specific additions */
 	struct dev_archdata	archdata;
* Unmerged path kernel/dma/swiotlb.c
