mac80211: refactor SKB queue processing a bit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 07bd1c79c9fbf038483c50031b0f302613a54eb6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/07bd1c79.failed

This is a very long loop body, move it into its own function
instead, keeping only the kcov and free outside in the loop
body.

Link: https://lore.kernel.org/r/20210517230754.6bc6cdd68570.I28a86ebdb19601ca1965c4dc654cc49fc1064efa@changeid
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 07bd1c79c9fbf038483c50031b0f302613a54eb6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/iface.c
diff --cc net/mac80211/iface.c
index 54476a3fd256,30dd3b3778f6..000000000000
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@@ -1340,117 -1454,12 +1457,19 @@@ static void ieee80211_iface_work(struc
  
  	/* first process frames */
  	while ((skb = skb_dequeue(&sdata->skb_queue))) {
++<<<<<<< HEAD
 +		struct ieee80211_mgmt *mgmt = (void *)skb->data;
 +
 +		if (ieee80211_is_action(mgmt->frame_control) &&
 +		    mgmt->u.action.category == WLAN_CATEGORY_BACK) {
 +			int len = skb->len;
++=======
+ 		kcov_remote_start_common(skb_get_kcov_handle(skb));
++>>>>>>> 07bd1c79c9fb (mac80211: refactor SKB queue processing a bit)
  
- 			mutex_lock(&local->sta_mtx);
- 			sta = sta_info_get_bss(sdata, mgmt->sa);
- 			if (sta) {
- 				switch (mgmt->u.action.u.addba_req.action_code) {
- 				case WLAN_ACTION_ADDBA_REQ:
- 					ieee80211_process_addba_request(
- 							local, sta, mgmt, len);
- 					break;
- 				case WLAN_ACTION_ADDBA_RESP:
- 					ieee80211_process_addba_resp(local, sta,
- 								     mgmt, len);
- 					break;
- 				case WLAN_ACTION_DELBA:
- 					ieee80211_process_delba(sdata, sta,
- 								mgmt, len);
- 					break;
- 				default:
- 					WARN_ON(1);
- 					break;
- 				}
- 			}
- 			mutex_unlock(&local->sta_mtx);
- 		} else if (ieee80211_is_action(mgmt->frame_control) &&
- 			   mgmt->u.action.category == WLAN_CATEGORY_VHT) {
- 			switch (mgmt->u.action.u.vht_group_notif.action_code) {
- 			case WLAN_VHT_ACTION_OPMODE_NOTIF: {
- 				struct ieee80211_rx_status *status;
- 				enum nl80211_band band;
- 				u8 opmode;
- 
- 				status = IEEE80211_SKB_RXCB(skb);
- 				band = status->band;
- 				opmode = mgmt->u.action.u.vht_opmode_notif.operating_mode;
- 
- 				mutex_lock(&local->sta_mtx);
- 				sta = sta_info_get_bss(sdata, mgmt->sa);
- 
- 				if (sta)
- 					ieee80211_vht_handle_opmode(sdata, sta,
- 								    opmode,
- 								    band);
- 
- 				mutex_unlock(&local->sta_mtx);
- 				break;
- 			}
- 			case WLAN_VHT_ACTION_GROUPID_MGMT:
- 				ieee80211_process_mu_groups(sdata, mgmt);
- 				break;
- 			default:
- 				WARN_ON(1);
- 				break;
- 			}
- 		} else if (ieee80211_is_ext(mgmt->frame_control)) {
- 			if (sdata->vif.type == NL80211_IFTYPE_STATION)
- 				ieee80211_sta_rx_queued_ext(sdata, skb);
- 			else
- 				WARN_ON(1);
- 		} else if (ieee80211_is_data_qos(mgmt->frame_control)) {
- 			struct ieee80211_hdr *hdr = (void *)mgmt;
- 			/*
- 			 * So the frame isn't mgmt, but frame_control
- 			 * is at the right place anyway, of course, so
- 			 * the if statement is correct.
- 			 *
- 			 * Warn if we have other data frame types here,
- 			 * they must not get here.
- 			 */
- 			WARN_ON(hdr->frame_control &
- 					cpu_to_le16(IEEE80211_STYPE_NULLFUNC));
- 			WARN_ON(!(hdr->seq_ctrl &
- 					cpu_to_le16(IEEE80211_SCTL_FRAG)));
- 			/*
- 			 * This was a fragment of a frame, received while
- 			 * a block-ack session was active. That cannot be
- 			 * right, so terminate the session.
- 			 */
- 			mutex_lock(&local->sta_mtx);
- 			sta = sta_info_get_bss(sdata, mgmt->sa);
- 			if (sta) {
- 				u16 tid = ieee80211_get_tid(hdr);
- 
- 				__ieee80211_stop_rx_ba_session(
- 					sta, tid, WLAN_BACK_RECIPIENT,
- 					WLAN_REASON_QSTA_REQUIRE_SETUP,
- 					true);
- 			}
- 			mutex_unlock(&local->sta_mtx);
- 		} else switch (sdata->vif.type) {
- 		case NL80211_IFTYPE_STATION:
- 			ieee80211_sta_rx_queued_mgmt(sdata, skb);
- 			break;
- 		case NL80211_IFTYPE_ADHOC:
- 			ieee80211_ibss_rx_queued_mgmt(sdata, skb);
- 			break;
- 		case NL80211_IFTYPE_MESH_POINT:
- 			if (!ieee80211_vif_is_mesh(&sdata->vif))
- 				break;
- 			ieee80211_mesh_rx_queued_mgmt(sdata, skb);
- 			break;
- 		default:
- 			WARN(1, "frame for unexpected interface type");
- 			break;
- 		}
+ 		ieee80211_iface_process_skb(local, sdata, skb);
  
  		kfree_skb(skb);
 -		kcov_remote_stop();
  	}
  
  	/* then other type-dependent work */
* Unmerged path net/mac80211/iface.c
