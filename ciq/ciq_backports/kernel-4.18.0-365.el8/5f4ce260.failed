ACPI: scan: Fix race related to dropping dependencies

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 5f4ce26078fde9cd406c008ba35e31bbb26a23a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/5f4ce260.failed

If acpi_add_single_object() runs concurrently with respect to
acpi_scan_clear_dep() which deletes a dependencies list entry where
the device being added is the consumer, the device's dep_unmet
counter may not be updated to reflect that change.

Namely, if the dependencies list entry is deleted right after
calling acpi_scan_dep_init() and before calling acpi_device_add(),
acpi_scan_clear_dep() will not find the device object corresponding
to the consumer device ACPI handle and it will not update its
dep_unmet counter to reflect the deletion of the list entry.
Consequently, the dep_unmet counter of the device will never
become zero going forward which may prevent it from being
completely enumerated.

To address this problem, modify acpi_add_single_object() to run
acpi_tie_acpi_dev(), to attach the ACPI device object created by it
to the corresponding ACPI namespace node, under acpi_dep_list_lock
along with acpi_scan_dep_init() whenever the latter is called.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Hans de Goede <hdegoede@redhat.com>
(cherry picked from commit 5f4ce26078fde9cd406c008ba35e31bbb26a23a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
diff --cc drivers/acpi/scan.c
index 70d0d2830632,1c6205661000..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -632,24 -618,44 +632,64 @@@ static struct acpi_device_bus_id *acpi_
  	return NULL;
  }
  
++<<<<<<< HEAD
 +int acpi_device_add(struct acpi_device *device,
 +		    void (*release)(struct device *))
++=======
+ static int acpi_device_set_name(struct acpi_device *device,
+ 				struct acpi_device_bus_id *acpi_device_bus_id)
+ {
+ 	struct ida *instance_ida = &acpi_device_bus_id->instance_ida;
+ 	int result;
+ 
+ 	result = ida_simple_get(instance_ida, 0, ACPI_MAX_DEVICE_INSTANCES, GFP_KERNEL);
+ 	if (result < 0)
+ 		return result;
+ 
+ 	device->pnp.instance_no = result;
+ 	dev_set_name(&device->dev, "%s:%02x", acpi_device_bus_id->bus_id, result);
+ 	return 0;
+ }
+ 
+ static int acpi_tie_acpi_dev(struct acpi_device *adev)
+ {
+ 	acpi_handle handle = adev->handle;
+ 	acpi_status status;
+ 
+ 	if (!handle)
+ 		return 0;
+ 
+ 	status = acpi_attach_data(handle, acpi_scan_drop_device, adev);
+ 	if (ACPI_FAILURE(status)) {
+ 		acpi_handle_err(handle, "Unable to attach device data\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int __acpi_device_add(struct acpi_device *device,
+ 			     void (*release)(struct device *))
++>>>>>>> 5f4ce26078fd (ACPI: scan: Fix race related to dropping dependencies)
  {
  	struct acpi_device_bus_id *acpi_device_bus_id;
  	int result;
  
++<<<<<<< HEAD
 +	if (device->handle) {
 +		acpi_status status;
 +
 +		status = acpi_attach_data(device->handle, acpi_scan_drop_device,
 +					  device);
 +		if (ACPI_FAILURE(status)) {
 +			acpi_handle_err(device->handle,
 +					"Unable to attach device data\n");
 +			return -ENODEV;
 +		}
 +	}
 +
++=======
++>>>>>>> 5f4ce26078fd (ACPI: scan: Fix race related to dropping dependencies)
  	/*
  	 * Linkage
  	 * -------
@@@ -1707,9 -1703,9 +1754,14 @@@ static void acpi_scan_init_status(struc
  static int acpi_add_single_object(struct acpi_device **child,
  				  acpi_handle handle, int type, bool dep_init)
  {
++<<<<<<< HEAD
++=======
+ 	struct acpi_device *device;
+ 	bool release_dep_lock = false;
++>>>>>>> 5f4ce26078fd (ACPI: scan: Fix race related to dropping dependencies)
  	int result;
 +	struct acpi_device *device;
 +	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
  
  	device = kzalloc(sizeof(struct acpi_device), GFP_KERNEL);
  	if (!device)
* Unmerged path drivers/acpi/scan.c
