mt76: mt7663s: rely on mt76_connac_pm_ref/mt76_connac_pm_unref in tx path

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit c2f9e631f098caf7176cbabda7a9cc2721352ff2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/c2f9e631.failed

Similar to mt7663e, rely on mt76_connac_pm_ref/mt76_connac_pm_unref to
check PM state and increment/decrement wake counter

	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: Felix Fietkau <nbd@nbd.name>
(cherry picked from commit c2f9e631f098caf7176cbabda7a9cc2721352ff2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/mediatek/mt76/mt7615/mac.c
diff --cc drivers/net/wireless/mediatek/mt76/mt7615/mac.c
index a1f486acee38,bd0d18914994..000000000000
--- a/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/mac.c
@@@ -1942,14 -1942,21 +1942,30 @@@ void mt7615_pm_wake_work(struct work_st
  	mphy = dev->phy.mt76;
  
  	if (!mt7615_mcu_set_drv_ctrl(dev)) {
+ 		struct mt76_dev *mdev = &dev->mt76;
  		int i;
  
++<<<<<<< HEAD
 +		mt76_for_each_q_rx(&dev->mt76, i)
 +			napi_schedule(&dev->mt76.napi[i]);
 +		mt76_connac_pm_dequeue_skbs(mphy, &dev->pm);
 +		mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_WM], false);
 +		ieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,
 +					     MT7615_WATCHDOG_TIME);
++=======
+ 		if (mt76_is_sdio(mdev)) {
+ 			mt76_worker_schedule(&mdev->sdio.txrx_worker);
+ 		} else {
+ 			mt76_for_each_q_rx(mdev, i)
+ 				napi_schedule(&mdev->napi[i]);
+ 			mt76_connac_pm_dequeue_skbs(mphy, &dev->pm);
+ 			mt76_queue_tx_cleanup(dev, mdev->q_mcu[MT_MCUQ_WM],
+ 					      false);
+ 		}
+ 		if (test_bit(MT76_STATE_RUNNING, &mphy->state))
+ 			ieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,
+ 						     MT7615_WATCHDOG_TIME);
++>>>>>>> c2f9e631f098 (mt76: mt7663s: rely on mt76_connac_pm_ref/mt76_connac_pm_unref in tx path)
  	}
  
  	ieee80211_wake_queues(mphy->hw);
* Unmerged path drivers/net/wireless/mediatek/mt76/mt7615/mac.c
diff --git a/drivers/net/wireless/mediatek/mt76/mt7615/sdio_txrx.c b/drivers/net/wireless/mediatek/mt76/mt7615/sdio_txrx.c
index 4393dd21ebbb..04f4c89b7499 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7615/sdio_txrx.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7615/sdio_txrx.c
@@ -283,9 +283,15 @@ void mt7663s_txrx_worker(struct mt76_worker *w)
 {
 	struct mt76_sdio *sdio = container_of(w, struct mt76_sdio,
 					      txrx_worker);
-	struct mt76_dev *dev = container_of(sdio, struct mt76_dev, sdio);
+	struct mt76_dev *mdev = container_of(sdio, struct mt76_dev, sdio);
+	struct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);
 	int i, nframes, ret;
 
+	if (!mt76_connac_pm_ref(&dev->mphy, &dev->pm)) {
+		queue_work(mdev->wq, &dev->pm.wake_work);
+		return;
+	}
+
 	/* disable interrupt */
 	sdio_claim_host(sdio->func);
 	sdio_writel(sdio->func, WHLPCR_INT_EN_CLR, MCR_WHLPCR, NULL);
@@ -295,16 +301,16 @@ void mt7663s_txrx_worker(struct mt76_worker *w)
 
 		/* tx */
 		for (i = 0; i <= MT_TXQ_PSD; i++) {
-			ret = mt7663s_tx_run_queue(dev, dev->phy.q_tx[i]);
+			ret = mt7663s_tx_run_queue(mdev, mdev->phy.q_tx[i]);
 			if (ret > 0)
 				nframes += ret;
 		}
-		ret = mt7663s_tx_run_queue(dev, dev->q_mcu[MT_MCUQ_WM]);
+		ret = mt7663s_tx_run_queue(mdev, mdev->q_mcu[MT_MCUQ_WM]);
 		if (ret > 0)
 			nframes += ret;
 
 		/* rx */
-		ret = mt7663s_rx_handler(dev);
+		ret = mt7663s_rx_handler(mdev);
 		if (ret > 0)
 			nframes += ret;
 	} while (nframes > 0);
@@ -312,6 +318,8 @@ void mt7663s_txrx_worker(struct mt76_worker *w)
 	/* enable interrupt */
 	sdio_writel(sdio->func, WHLPCR_INT_EN_SET, MCR_WHLPCR, NULL);
 	sdio_release_host(sdio->func);
+
+	mt76_connac_pm_unref(&dev->mphy, &dev->pm);
 }
 
 void mt7663s_sdio_irq(struct sdio_func *func)
