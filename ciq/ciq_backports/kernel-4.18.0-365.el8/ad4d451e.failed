ACPI: scan: Rearrange acpi_dev_get_first_consumer_dev_cb()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit ad4d451e14e58792e9b7c8a4bfc3276f0128e94a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/ad4d451e.failed

Make acpi_dev_get_first_consumer_dev_cb() a bit more straightforward
and rewrite the comment in it.

No functional impact.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Hans de Goede <hdegoede@redhat.com>
(cherry picked from commit ad4d451e14e58792e9b7c8a4bfc3276f0128e94a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
diff --cc drivers/acpi/scan.c
index 70d0d2830632,524d85dc540c..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -2113,10 -2096,55 +2113,59 @@@ static void acpi_bus_attach(struct acpi
  		device->handler->hotplug.notify_online(device);
  }
  
++<<<<<<< HEAD
 +void acpi_walk_dep_device_list(acpi_handle handle)
++=======
+ static int acpi_dev_get_first_consumer_dev_cb(struct acpi_dep_data *dep, void *data)
+ {
+ 	struct acpi_device *adev;
+ 
+ 	adev = acpi_bus_get_acpi_device(dep->consumer);
+ 	if (adev) {
+ 		*(struct acpi_device **)data = adev;
+ 		return 1;
+ 	}
+ 	/* Continue parsing if the device object is not present. */
+ 	return 0;
+ }
+ 
+ static int acpi_scan_clear_dep(struct acpi_dep_data *dep, void *data)
+ {
+ 	struct acpi_device *adev;
+ 
+ 	acpi_bus_get_device(dep->consumer, &adev);
+ 
+ 	if (adev) {
+ 		adev->dep_unmet--;
+ 		if (!adev->dep_unmet)
+ 			acpi_bus_attach(adev, true);
+ 	}
+ 
+ 	list_del(&dep->node);
+ 	kfree(dep);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * acpi_walk_dep_device_list - Apply a callback to every entry in acpi_dep_list
+  * @handle:	The ACPI handle of the supplier device
+  * @callback:	Pointer to the callback function to apply
+  * @data:	Pointer to some data to pass to the callback
+  *
+  * The return value of the callback determines this function's behaviour. If 0
+  * is returned we continue to iterate over acpi_dep_list. If a positive value
+  * is returned then the loop is broken but this function returns 0. If a
+  * negative value is returned by the callback then the loop is broken and that
+  * value is returned as the final error.
+  */
+ int acpi_walk_dep_device_list(acpi_handle handle,
+ 			      int (*callback)(struct acpi_dep_data *, void *),
+ 			      void *data)
++>>>>>>> ad4d451e14e5 (ACPI: scan: Rearrange acpi_dev_get_first_consumer_dev_cb())
  {
  	struct acpi_dep_data *dep, *tmp;
 -	int ret = 0;
 +	struct acpi_device *adev;
  
  	mutex_lock(&acpi_dep_list_lock);
  	list_for_each_entry_safe(dep, tmp, &acpi_dep_list, node) {
* Unmerged path drivers/acpi/scan.c
