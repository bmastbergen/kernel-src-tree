kasan: clarify HW_TAGS impact on TBI

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Andrey Konovalov <andreyknvl@google.com>
commit 4062c24598b160f929d93a4a6fbf50b0b0b13d11
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/4062c245.failed

Mention in the documentation that enabling CONFIG_KASAN_HW_TAGS always
results in in-kernel TBI (Top Byte Ignore) being enabled.

Also do a few minor documentation cleanups.

Link: https://linux-review.googlesource.com/id/Iba2a6697e3c6304cb53f89ec61dedc77fa29e3ae
Link: https://lkml.kernel.org/r/3b4ea6875bb14d312092ad14ac55cb456c83c08e.1610733117.git.andreyknvl@google.com
	Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
	Reviewed-by: Marco Elver <elver@google.com>
	Reviewed-by: Alexander Potapenko <glider@google.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Branislav Rankov <Branislav.Rankov@arm.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Evgenii Stepanov <eugenis@google.com>
	Cc: Kevin Brodsky <kevin.brodsky@arm.com>
	Cc: Peter Collingbourne <pcc@google.com>
	Cc: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 4062c24598b160f929d93a4a6fbf50b0b0b13d11)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/dev-tools/kasan.rst
diff --cc Documentation/dev-tools/kasan.rst
index 19b982c535c7,0ae0efe82e8e..000000000000
--- a/Documentation/dev-tools/kasan.rst
+++ b/Documentation/dev-tools/kasan.rst
@@@ -136,22 -131,58 +136,61 @@@ freed (in case of a use-after-free bug 
  the accessed slab object and information about the accessed memory page.
  
  In the last section the report shows memory state around the accessed address.
 -Internally KASAN tracks memory state separately for each memory granule, which
 -is either 8 or 16 aligned bytes depending on KASAN mode. Each number in the
 -memory state section of the report shows the state of one of the memory
 -granules that surround the accessed address.
 -
 -For generic KASAN the size of each memory granule is 8. The state of each
 -granule is encoded in one shadow byte. Those 8 bytes can be accessible,
 -partially accessible, freed or be a part of a redzone. KASAN uses the following
 -encoding for each shadow byte: 0 means that all 8 bytes of the corresponding
 -memory region are accessible; number N (1 <= N <= 7) means that the first N
 -bytes are accessible, and other (8 - N) bytes are not; any negative value
 -indicates that the entire 8-byte word is inaccessible. KASAN uses different
 -negative values to distinguish between different kinds of inaccessible memory
 -like redzones or freed memory (see mm/kasan/kasan.h).
 +Reading this part requires some understanding of how KASAN works.
 +
 +The state of each 8 aligned bytes of memory is encoded in one shadow byte.
 +Those 8 bytes can be accessible, partially accessible, freed or be a redzone.
 +We use the following encoding for each shadow byte: 0 means that all 8 bytes
 +of the corresponding memory region are accessible; number N (1 <= N <= 7) means
 +that the first N bytes are accessible, and other (8 - N) bytes are not;
 +any negative value indicates that the entire 8-byte word is inaccessible.
 +We use different negative values to distinguish between different kinds of
 +inaccessible memory like redzones or freed memory (see mm/kasan/kasan.h).
  
  In the report above the arrows point to the shadow byte 03, which means that
++<<<<<<< HEAD
 +the accessed address is partially accessible.
 +
 +For tag-based KASAN this last report section shows the memory tags around the
 +accessed address (see Implementation details section).
++=======
+ the accessed address is partially accessible. For tag-based KASAN modes this
+ last report section shows the memory tags around the accessed address
+ (see the `Implementation details`_ section).
+ 
+ Boot parameters
+ ~~~~~~~~~~~~~~~
+ 
+ Hardware tag-based KASAN mode (see the section about various modes below) is
+ intended for use in production as a security mitigation. Therefore it supports
+ boot parameters that allow to disable KASAN competely or otherwise control
+ particular KASAN features.
+ 
+ - ``kasan=off`` or ``=on`` controls whether KASAN is enabled (default: ``on``).
+ 
+ - ``kasan.stacktrace=off`` or ``=on`` disables or enables alloc and free stack
+   traces collection (default: ``on``).
+ 
+ - ``kasan.fault=report`` or ``=panic`` controls whether to only print a KASAN
+   report or also panic the kernel (default: ``report``).
+ 
+ For developers
+ ~~~~~~~~~~~~~~
+ 
+ Software KASAN modes use compiler instrumentation to insert validity checks.
+ Such instrumentation might be incompatible with some part of the kernel, and
+ therefore needs to be disabled. To disable instrumentation for specific files
+ or directories, add a line similar to the following to the respective kernel
+ Makefile:
+ 
+ - For a single file (e.g. main.o)::
+ 
+     KASAN_SANITIZE_main.o := n
+ 
+ - For all files in one directory::
+ 
+     KASAN_SANITIZE := n
++>>>>>>> 4062c24598b1 (kasan: clarify HW_TAGS impact on TBI)
  
  
  Implementation details
@@@ -215,10 -257,44 +254,17 @@@ simply printed from the function that p
  instrumentation a brk instruction is emitted by the compiler, and a dedicated
  brk handler is used to print bug reports.
  
 -Software tag-based KASAN uses 0xFF as a match-all pointer tag (accesses through
 -pointers with 0xFF pointer tag aren't checked). The value 0xFE is currently
 -reserved to tag freed memory regions.
 -
 -Software tag-based KASAN currently only supports tagging of
 -kmem_cache_alloc/kmalloc and page_alloc memory.
 -
 -Hardware tag-based KASAN
 -~~~~~~~~~~~~~~~~~~~~~~~~
 -
 -Hardware tag-based KASAN is similar to the software mode in concept, but uses
 -hardware memory tagging support instead of compiler instrumentation and
 -shadow memory.
 -
 -Hardware tag-based KASAN is currently only implemented for arm64 architecture
 -and based on both arm64 Memory Tagging Extension (MTE) introduced in ARMv8.5
 -Instruction Set Architecture, and Top Byte Ignore (TBI).
 -
 -Special arm64 instructions are used to assign memory tags for each allocation.
 -Same tags are assigned to pointers to those allocations. On every memory
 -access, hardware makes sure that tag of the memory that is being accessed is
 -equal to tag of the pointer that is used to access this memory. In case of a
 -tag mismatch a fault is generated and a report is printed.
 -
 -Hardware tag-based KASAN uses 0xFF as a match-all pointer tag (accesses through
 -pointers with 0xFF pointer tag aren't checked). The value 0xFE is currently
 -reserved to tag freed memory regions.
 -
 -Hardware tag-based KASAN currently only supports tagging of
 -kmem_cache_alloc/kmalloc and page_alloc memory.
 +A potential expansion of this mode is a hardware tag-based mode, which would
 +use hardware memory tagging support instead of compiler instrumentation and
 +manual shadow memory manipulation.
  
+ If the hardware doesn't support MTE (pre ARMv8.5), hardware tag-based KASAN
+ won't be enabled. In this case all boot parameters are ignored.
+ 
+ Note, that enabling CONFIG_KASAN_HW_TAGS always results in in-kernel TBI being
+ enabled. Even when kasan.mode=off is provided, or when the hardware doesn't
+ support MTE (but supports TBI).
+ 
  What memory accesses are sanitised by KASAN?
  --------------------------------------------
  
* Unmerged path Documentation/dev-tools/kasan.rst
