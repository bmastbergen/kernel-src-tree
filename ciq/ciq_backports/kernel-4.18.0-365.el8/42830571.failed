skmsg: Pass source psock to sk_psock_skb_redirect()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Cong Wang <cong.wang@bytedance.com>
commit 42830571f1fd9751b3fbf38084bbb253320e185f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/42830571.failed

sk_psock_skb_redirect() only takes skb as a parameter, we
will need to know where this skb is from, so just pass
the source psock to this function as a new parameter.
This patch prepares for the next one.

	Signed-off-by: Cong Wang <cong.wang@bytedance.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
	Acked-by: Jakub Sitnicki <jakub@cloudflare.com>
Link: https://lore.kernel.org/bpf/20210615021342.7416-8-xiyou.wangcong@gmail.com
(cherry picked from commit 42830571f1fd9751b3fbf38084bbb253320e185f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/skmsg.c
diff --cc net/core/skmsg.c
index cfa6fc7cc1e0,3aa9065811ad..000000000000
--- a/net/core/skmsg.c
+++ b/net/core/skmsg.c
@@@ -744,21 -824,7 +744,25 @@@ out
  }
  EXPORT_SYMBOL_GPL(sk_psock_msg_verdict);
  
++<<<<<<< HEAD
 +static int sk_psock_bpf_run(struct sk_psock *psock, struct bpf_prog *prog,
 +			    struct sk_buff *skb)
 +{
 +	return bpf_prog_run_pin_on_cpu(prog, skb);
 +}
 +
 +static struct sk_psock *sk_psock_from_strp(struct strparser *strp)
 +{
 +	struct sk_psock_parser *parser;
 +
 +	parser = container_of(strp, struct sk_psock_parser, strp);
 +	return container_of(parser, struct sk_psock, parser);
 +}
 +
 +static void sk_psock_skb_redirect(struct sk_buff *skb)
++=======
+ static int sk_psock_skb_redirect(struct sk_psock *from, struct sk_buff *skb)
++>>>>>>> 42830571f1fd (skmsg: Pass source psock to sk_psock_skb_redirect())
  {
  	struct sk_psock *psock_other;
  	struct sock *sk_other;
@@@ -784,9 -857,12 +788,10 @@@
  
  	skb_queue_tail(&psock_other->ingress_skb, skb);
  	schedule_work(&psock_other->work);
 -	spin_unlock_bh(&psock_other->ingress_lock);
 -	return 0;
  }
  
- static void sk_psock_tls_verdict_apply(struct sk_buff *skb, struct sock *sk, int verdict)
+ static void sk_psock_tls_verdict_apply(struct sk_buff *skb,
+ 				       struct sk_psock *from, int verdict)
  {
  	switch (verdict) {
  	case __SK_REDIRECT:
@@@ -805,15 -881,16 +810,15 @@@ int sk_psock_tls_strp_read(struct sk_ps
  	int ret = __SK_PASS;
  
  	rcu_read_lock();
 -	prog = READ_ONCE(psock->progs.stream_verdict);
 +	prog = READ_ONCE(psock->progs.skb_verdict);
  	if (likely(prog)) {
  		skb->sk = psock->sk;
 -		skb_dst_drop(skb);
 -		skb_bpf_redirect_clear(skb);
 -		ret = bpf_prog_run_pin_on_cpu(prog, skb);
 -		ret = sk_psock_map_verd(ret, skb_bpf_redirect_fetch(skb));
 +		tcp_skb_bpf_redirect_clear(skb);
 +		ret = sk_psock_bpf_run(psock, prog, skb);
 +		ret = sk_psock_map_verd(ret, tcp_skb_bpf_redirect_fetch(skb));
  		skb->sk = NULL;
  	}
- 	sk_psock_tls_verdict_apply(skb, psock->sk, ret);
+ 	sk_psock_tls_verdict_apply(skb, psock, ret);
  	rcu_read_unlock();
  	return ret;
  }
@@@ -852,10 -937,9 +857,14 @@@ static void sk_psock_verdict_apply(stru
  		}
  		break;
  	case __SK_REDIRECT:
++<<<<<<< HEAD
 +		sk_psock_skb_redirect(skb);
++=======
+ 		err = sk_psock_skb_redirect(psock, skb);
++>>>>>>> 42830571f1fd (skmsg: Pass source psock to sk_psock_skb_redirect())
  		break;
  	case __SK_DROP:
 +		/* fall-through */
  	default:
  out_free:
  		kfree_skb(skb);
* Unmerged path net/core/skmsg.c
