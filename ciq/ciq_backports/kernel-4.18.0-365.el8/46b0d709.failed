drm/i915: Make display workaround upper bounds exclusive

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Matt Roper <matthew.d.roper@intel.com>
commit 46b0d7091cb9702265007d0f472846b01c773872
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/46b0d709.failed

Workarounds are documented in the bspec with an exclusive upper bound
(i.e., a "fixed" stepping that no longer needs the workaround).  This
makes our driver's use of an inclusive upper bound for stepping ranges
confusing; the differing notation between code and bspec makes it very
easy for mistakes to creep in.

Let's switch the upper bound of our IS_{GT,DISP}_STEP macros over to use
an exclusive upper bound like the bspec does.  This also has the benefit
of helping make sure workarounds are properly handled for new minor
steppings that show up (e.g., an A1 between the A0 and B0 we already
knew about) --- if the new intermediate stepping pulls in hardware fixes
early, there will be an update to the workaround definition which lets
us know we need to change our code.  If the new stepping does not pull a
hardware fix earlier, then the new stepping will already be captured
properly by the "[begin, fix)" range in the code.

We'll probably need to be extra vigilant in code review of new
workarounds for the near future to make sure developers notice the new
semantics of workaround bounds.  But we just migrated a bunch of our
platforms from the IS_REVID bounds over to IS_{GT,DISP}_STEP, so people
are already adjusting to the new macros and now is a good time to make
this change too.

[mattrope: Split out display changes to apply through intel-next tree]
	Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
	Reviewed-by: Jos√© Roberto de Souza <jose.souza@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210717051426.4120328-8-matthew.d.roper@intel.com
(cherry picked from commit 46b0d7091cb9702265007d0f472846b01c773872)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_cdclk.c
#	drivers/gpu/drm/i915/display/intel_display_power.c
#	drivers/gpu/drm/i915/display/intel_psr.c
#	drivers/gpu/drm/i915/display/skl_universal_plane.c
diff --cc drivers/gpu/drm/i915/display/intel_cdclk.c
index 2e878cc274b7,944fb13b9d98..000000000000
--- a/drivers/gpu/drm/i915/display/intel_cdclk.c
+++ b/drivers/gpu/drm/i915/display/intel_cdclk.c
@@@ -2846,7 -2873,17 +2846,21 @@@ u32 intel_read_rawclk(struct drm_i915_p
   */
  void intel_init_cdclk_hooks(struct drm_i915_private *dev_priv)
  {
++<<<<<<< HEAD
 +	if (IS_ROCKETLAKE(dev_priv)) {
++=======
+ 	if (IS_ALDERLAKE_P(dev_priv)) {
+ 		dev_priv->display.set_cdclk = bxt_set_cdclk;
+ 		dev_priv->display.bw_calc_min_cdclk = skl_bw_calc_min_cdclk;
+ 		dev_priv->display.modeset_calc_cdclk = bxt_modeset_calc_cdclk;
+ 		dev_priv->display.calc_voltage_level = tgl_calc_voltage_level;
+ 		/* Wa_22011320316:adl-p[a0] */
+ 		if (IS_ADLP_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0))
+ 			dev_priv->cdclk.table = adlp_a_step_cdclk_table;
+ 		else
+ 			dev_priv->cdclk.table = adlp_cdclk_table;
+ 	} else if (IS_ROCKETLAKE(dev_priv)) {
++>>>>>>> 46b0d7091cb9 (drm/i915: Make display workaround upper bounds exclusive)
  		dev_priv->display.set_cdclk = bxt_set_cdclk;
  		dev_priv->display.bw_calc_min_cdclk = skl_bw_calc_min_cdclk;
  		dev_priv->display.modeset_calc_cdclk = bxt_modeset_calc_cdclk;
diff --cc drivers/gpu/drm/i915/display/intel_display_power.c
index e2cb6e6ca250,bec380e58f40..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display_power.c
+++ b/drivers/gpu/drm/i915/display/intel_display_power.c
@@@ -5340,8 -5799,9 +5340,14 @@@ static void tgl_bw_buddy_init(struct dr
  	int config, i;
  
  	if (IS_ALDERLAKE_S(dev_priv) ||
++<<<<<<< HEAD
 +	    IS_DG1_REVID(dev_priv, DG1_REVID_A0, DG1_REVID_A0) ||
 +	    IS_TGL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0))
++=======
+ 	    IS_DG1_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0) ||
+ 	    IS_RKL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0) ||
+ 	    IS_TGL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_C0))
++>>>>>>> 46b0d7091cb9 (drm/i915: Make display workaround upper bounds exclusive)
  		/* Wa_1409767108:tgl,dg1,adl-s */
  		table = wa_1409767108_buddy_page_masks;
  	else
diff --cc drivers/gpu/drm/i915/display/intel_psr.c
index 2c6c4a4f9477,a54e71e4e568..000000000000
--- a/drivers/gpu/drm/i915/display/intel_psr.c
+++ b/drivers/gpu/drm/i915/display/intel_psr.c
@@@ -522,18 -534,47 +522,49 @@@ static u32 intel_psr2_get_tp_time(struc
  static void hsw_activate_psr2(struct intel_dp *intel_dp)
  {
  	struct drm_i915_private *dev_priv = dp_to_i915(intel_dp);
 -	u32 val = EDP_PSR2_ENABLE;
 -
 -	val |= psr_compute_idle_frames(intel_dp) << EDP_PSR2_IDLE_FRAME_SHIFT;
 +	u32 val;
  
 -	if (!IS_ALDERLAKE_P(dev_priv))
 -		val |= EDP_SU_TRACK_ENABLE;
 +	val = psr_compute_idle_frames(intel_dp) << EDP_PSR2_IDLE_FRAME_SHIFT;
  
 -	if (DISPLAY_VER(dev_priv) >= 10 && DISPLAY_VER(dev_priv) <= 12)
 +	val |= EDP_PSR2_ENABLE | EDP_SU_TRACK_ENABLE;
 +	if (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv))
  		val |= EDP_Y_COORDINATE_ENABLE;
  
 -	val |= EDP_PSR2_FRAME_BEFORE_SU(intel_dp->psr.sink_sync_latency + 1);
 +	val |= EDP_PSR2_FRAME_BEFORE_SU(dev_priv->psr.sink_sync_latency + 1);
  	val |= intel_psr2_get_tp_time(intel_dp);
  
++<<<<<<< HEAD
 +	if (INTEL_GEN(dev_priv) >= 12) {
++=======
+ 	/* Wa_22012278275:adl-p */
+ 	if (IS_ADLP_DISPLAY_STEP(dev_priv, STEP_A0, STEP_E0)) {
+ 		static const u8 map[] = {
+ 			2, /* 5 lines */
+ 			1, /* 6 lines */
+ 			0, /* 7 lines */
+ 			3, /* 8 lines */
+ 			6, /* 9 lines */
+ 			5, /* 10 lines */
+ 			4, /* 11 lines */
+ 			7, /* 12 lines */
+ 		};
+ 		/*
+ 		 * Still using the default IO_BUFFER_WAKE and FAST_WAKE, see
+ 		 * comments bellow for more information
+ 		 */
+ 		u32 tmp, lines = 7;
+ 
+ 		val |= TGL_EDP_PSR2_BLOCK_COUNT_NUM_2;
+ 
+ 		tmp = map[lines - TGL_EDP_PSR2_IO_BUFFER_WAKE_MIN_LINES];
+ 		tmp = tmp << TGL_EDP_PSR2_IO_BUFFER_WAKE_SHIFT;
+ 		val |= tmp;
+ 
+ 		tmp = map[lines - TGL_EDP_PSR2_FAST_WAKE_MIN_LINES];
+ 		tmp = tmp << TGL_EDP_PSR2_FAST_WAKE_MIN_SHIFT;
+ 		val |= tmp;
+ 	} else if (DISPLAY_VER(dev_priv) >= 12) {
++>>>>>>> 46b0d7091cb9 (drm/i915: Make display workaround upper bounds exclusive)
  		/*
  		 * TODO: 7 lines of IO_BUFFER_WAKE and FAST_WAKE are default
  		 * values from BSpec. In order to setting an optimal power
@@@ -549,10 -590,12 +580,19 @@@
  		val |= EDP_PSR2_FAST_WAKE(7);
  	}
  
++<<<<<<< HEAD
 +	if (dev_priv->psr.psr2_sel_fetch_enabled) {
 +		/* WA 1408330847 */
 +		if (IS_TGL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_A0) ||
 +		    IS_RKL_REVID(dev_priv, RKL_REVID_A0, RKL_REVID_A0))
++=======
+ 	if (intel_dp->psr.req_psr2_sdp_prior_scanline)
+ 		val |= EDP_PSR2_SU_SDP_SCANLINE;
+ 
+ 	if (intel_dp->psr.psr2_sel_fetch_enabled) {
+ 		/* Wa_1408330847 */
+ 		if (IS_TGL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0))
++>>>>>>> 46b0d7091cb9 (drm/i915: Make display workaround upper bounds exclusive)
  			intel_de_rmw(dev_priv, CHICKEN_PAR1_1,
  				     DIS_RAM_BYPASS_PSR2_MAN_TRACK,
  				     DIS_RAM_BYPASS_PSR2_MAN_TRACK);
@@@ -661,12 -728,14 +701,20 @@@ tgl_dc3co_exitline_compute_config(struc
  	if (crtc_state->enable_psr2_sel_fetch)
  		return;
  
 -	if (!(dev_priv->dmc.allowed_dc_mask & DC_STATE_EN_DC3CO))
 +	if (!(dev_priv->csr.allowed_dc_mask & DC_STATE_EN_DC3CO))
  		return;
  
++<<<<<<< HEAD
 +	/* B.Specs:49196 DC3CO only works with pipeA and DDIA.*/
 +	if (to_intel_crtc(crtc_state->uapi.crtc)->pipe != PIPE_A ||
 +	    dig_port->base.port != PORT_A)
++=======
+ 	if (!dc3co_is_pipe_port_compatible(intel_dp, crtc_state))
+ 		return;
+ 
+ 	/* Wa_16011303918:adl-p */
+ 	if (IS_ADLP_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0))
++>>>>>>> 46b0d7091cb9 (drm/i915: Make display workaround upper bounds exclusive)
  		return;
  
  	/*
@@@ -711,6 -781,13 +759,16 @@@ static bool intel_psr2_sel_fetch_config
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Wa_14010254185 Wa_14010103792 */
+ 	if (IS_TGL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_C0)) {
+ 		drm_dbg_kms(&dev_priv->drm,
+ 			    "PSR2 sel fetch not enabled, missing the implementation of WAs\n");
+ 		return false;
+ 	}
+ 
++>>>>>>> 46b0d7091cb9 (drm/i915: Make display workaround upper bounds exclusive)
  	return crtc_state->enable_psr2_sel_fetch = true;
  }
  
@@@ -803,6 -943,18 +861,21 @@@ static bool intel_psr2_config_valid(str
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Wa_2209313811 */
+ 	if (!crtc_state->enable_psr2_sel_fetch &&
+ 	    IS_TGL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_C0)) {
+ 		drm_dbg_kms(&dev_priv->drm, "PSR2 HW tracking is not supported this Display stepping\n");
+ 		return false;
+ 	}
+ 
+ 	if (!psr2_granularity_check(intel_dp, crtc_state)) {
+ 		drm_dbg_kms(&dev_priv->drm, "PSR2 not enabled, SU granularity not compatible\n");
+ 		return false;
+ 	}
+ 
++>>>>>>> 46b0d7091cb9 (drm/i915: Make display workaround upper bounds exclusive)
  	if (!crtc_state->enable_psr2_sel_fetch &&
  	    (crtc_hdisplay > psr_max_h || crtc_vdisplay > psr_max_v)) {
  		drm_dbg_kms(&dev_priv->drm,
@@@ -812,6 -964,20 +885,23 @@@
  		return false;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (!_compute_psr2_sdp_prior_scanline_indication(intel_dp, crtc_state)) {
+ 		drm_dbg_kms(&dev_priv->drm,
+ 			    "PSR2 not enabled, PSR2 SDP indication do not fit in hblank\n");
+ 		return false;
+ 	}
+ 
+ 	/* Wa_16011303918:adl-p */
+ 	if (crtc_state->vrr.enable &&
+ 	    IS_ADLP_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0)) {
+ 		drm_dbg_kms(&dev_priv->drm,
+ 			    "PSR2 not enabled, not compatible with HW stepping + VRR\n");
+ 		return false;
+ 	}
+ 
++>>>>>>> 46b0d7091cb9 (drm/i915: Make display workaround upper bounds exclusive)
  	tgl_dc3co_exitline_compute_config(intel_dp, crtc_state);
  	return true;
  }
@@@ -968,11 -1162,11 +1058,16 @@@ static void intel_psr_enable_source(str
  
  	if (HAS_PSR_HW_TRACKING(dev_priv) && HAS_PSR2_SEL_FETCH(dev_priv))
  		intel_de_rmw(dev_priv, CHICKEN_PAR1_1, IGNORE_PSR2_HW_TRACKING,
 -			     intel_dp->psr.psr2_sel_fetch_enabled ?
 +			     dev_priv->psr.psr2_sel_fetch_enabled ?
  			     IGNORE_PSR2_HW_TRACKING : 0);
  
++<<<<<<< HEAD
 +	/* Wa_16011168373:adlp */
 +	if (IS_ADLP_DISPLAY_STEP(dev_priv, STEP_A0, STEP_A0) &&
++=======
+ 	/* Wa_16011168373:adl-p */
+ 	if (IS_ADLP_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0) &&
++>>>>>>> 46b0d7091cb9 (drm/i915: Make display workaround upper bounds exclusive)
  	    intel_dp->psr.psr2_enabled)
  		intel_de_rmw(dev_priv,
  			     TRANS_SET_CONTEXT_LATENCY(intel_dp->psr.transcoder),
@@@ -1128,16 -1327,31 +1223,42 @@@ static void intel_psr_disable_locked(st
  	if (intel_de_wait_for_clear(dev_priv, psr_status,
  				    psr_status_mask, 2000))
  		drm_err(&dev_priv->drm, "Timed out waiting PSR idle state\n");
 -}
  
++<<<<<<< HEAD
 +	/* WA 1408330847 */
 +	if (dev_priv->psr.psr2_sel_fetch_enabled &&
 +	    (IS_TGL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_A0) ||
 +	     IS_RKL_REVID(dev_priv, RKL_REVID_A0, RKL_REVID_A0)))
 +		intel_de_rmw(dev_priv, CHICKEN_PAR1_1,
 +			     DIS_RAM_BYPASS_PSR2_MAN_TRACK, 0);
 +
 +	/* Wa_16011168373:adlp */
 +	if (IS_ADLP_DISPLAY_STEP(dev_priv, STEP_A0, STEP_A0) &&
++=======
+ static void intel_psr_disable_locked(struct intel_dp *intel_dp)
+ {
+ 	struct drm_i915_private *dev_priv = dp_to_i915(intel_dp);
+ 
+ 	lockdep_assert_held(&intel_dp->psr.lock);
+ 
+ 	if (!intel_dp->psr.enabled)
+ 		return;
+ 
+ 	drm_dbg_kms(&dev_priv->drm, "Disabling PSR%s\n",
+ 		    intel_dp->psr.psr2_enabled ? "2" : "1");
+ 
+ 	intel_psr_exit(intel_dp);
+ 	intel_psr_wait_exit_locked(intel_dp);
+ 
+ 	/* Wa_1408330847 */
+ 	if (intel_dp->psr.psr2_sel_fetch_enabled &&
+ 	    IS_TGL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0))
+ 		intel_de_rmw(dev_priv, CHICKEN_PAR1_1,
+ 			     DIS_RAM_BYPASS_PSR2_MAN_TRACK, 0);
+ 
+ 	/* Wa_16011168373:adl-p */
+ 	if (IS_ADLP_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B0) &&
++>>>>>>> 46b0d7091cb9 (drm/i915: Make display workaround upper bounds exclusive)
  	    intel_dp->psr.psr2_enabled)
  		intel_de_rmw(dev_priv,
  			     TRANS_SET_CONTEXT_LATENCY(intel_dp->psr.transcoder),
* Unmerged path drivers/gpu/drm/i915/display/skl_universal_plane.c
* Unmerged path drivers/gpu/drm/i915/display/intel_cdclk.c
* Unmerged path drivers/gpu/drm/i915/display/intel_display_power.c
* Unmerged path drivers/gpu/drm/i915/display/intel_psr.c
* Unmerged path drivers/gpu/drm/i915/display/skl_universal_plane.c
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index 886740d42b42..8e6487f97894 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -1318,7 +1318,7 @@ static inline struct drm_i915_private *pdev_to_i915(struct pci_dev *pdev)
 
 #define IS_DISPLAY_STEP(__i915, since, until) \
 	(drm_WARN_ON(&(__i915)->drm, INTEL_DISPLAY_STEP(__i915) == STEP_NONE), \
-	 INTEL_DISPLAY_STEP(__i915) >= (since) && INTEL_DISPLAY_STEP(__i915) <= (until))
+	 INTEL_DISPLAY_STEP(__i915) >= (since) && INTEL_DISPLAY_STEP(__i915) < (until))
 
 #define IS_GT_STEP(__i915, since, until) \
 	(drm_WARN_ON(&(__i915)->drm, INTEL_GT_STEP(__i915) == STEP_NONE), \
diff --git a/drivers/gpu/drm/i915/intel_device_info.c b/drivers/gpu/drm/i915/intel_device_info.c
index 2b89e5f65e1a..bba30109ce03 100644
--- a/drivers/gpu/drm/i915/intel_device_info.c
+++ b/drivers/gpu/drm/i915/intel_device_info.c
@@ -251,7 +251,7 @@ void intel_device_info_runtime_init(struct drm_i915_private *dev_priv)
 	enum pipe pipe;
 
 	/* Wa_14011765242: adl-s A0,A1 */
-	if (IS_ADLS_DISPLAY_STEP(dev_priv, STEP_A0, STEP_A1))
+	if (IS_ADLS_DISPLAY_STEP(dev_priv, STEP_A0, STEP_A2))
 		for_each_pipe(dev_priv, pipe)
 			runtime->num_scalers[pipe] = 0;
 	else if (INTEL_GEN(dev_priv) >= 10) {
diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c
index bac0c94e6962..c4d67ceaab91 100644
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@ -7072,7 +7072,7 @@ static void gen12lp_init_clock_gating(struct drm_i915_private *dev_priv)
 			   ILK_DPFC_CHICKEN_COMP_DUMMY_PIXEL);
 
 	/* Wa_1409825376:tgl (pre-prod)*/
-	if (IS_TGL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_B1))
+	if (IS_TGL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_C0))
 		intel_uncore_write(&dev_priv->uncore, GEN9_CLKGATE_DIS_3, intel_uncore_read(&dev_priv->uncore, GEN9_CLKGATE_DIS_3) |
 			   TGL_VRH_GATING_DIS);
 
