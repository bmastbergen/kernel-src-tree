x86/fpu/signal: Prepare for variable sigframe length

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Chang S. Bae <chang.seok.bae@intel.com>
commit 53599b4d54b9b8dda1d537a558946869d2acbddc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/53599b4d.failed

The software reserved portion of the fxsave frame in the signal frame
is copied from structures which have been set up at boot time. With
dynamically enabled features the content of these structures is no
longer correct because the xfeatures and size can be different per task.

Calculate the software reserved portion at runtime and fill in the
xfeatures and size values from the tasks active fpstate.

	Signed-off-by: Chang S. Bae <chang.seok.bae@intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Chang S. Bae <chang.seok.bae@intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20211021225527.10184-10-chang.seok.bae@intel.com
(cherry picked from commit 53599b4d54b9b8dda1d537a558946869d2acbddc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/fpu/internal.h
#	arch/x86/kernel/fpu/signal.c
diff --cc arch/x86/kernel/fpu/internal.h
index 5ddc09e03c2a,dbdb31f55fc7..000000000000
--- a/arch/x86/kernel/fpu/internal.h
+++ b/arch/x86/kernel/fpu/internal.h
@@@ -19,7 -21,8 +19,13 @@@ static __always_inline __pure bool use_
  # define WARN_ON_FPU(x) ({ (void)(x); 0; })
  #endif
  
++<<<<<<< HEAD
 +/* Init functions */
 +extern void fpu__init_prepare_fx_sw_frame(void);
++=======
+ /* Used in init.c */
+ extern void fpstate_init_user(struct fpstate *fpstate);
+ extern void fpstate_reset(struct fpu *fpu);
++>>>>>>> 53599b4d54b9 (x86/fpu/signal: Prepare for variable sigframe length)
  
  #endif
diff --cc arch/x86/kernel/fpu/signal.c
index f74c29985497,3b7f7d07c0b5..000000000000
--- a/arch/x86/kernel/fpu/signal.c
+++ b/arch/x86/kernel/fpu/signal.c
@@@ -17,10 -17,9 +17,7 @@@
  
  #include "context.h"
  #include "internal.h"
 -#include "legacy.h"
 -#include "xstate.h"
  
- static struct _fpx_sw_bytes fx_sw_reserved __ro_after_init;
- static struct _fpx_sw_bytes fx_sw_reserved_ia32 __ro_after_init;
- 
  /*
   * Check for the presence of extended state information in the
   * user fpstate pointer in the sigcontext.
@@@ -88,17 -87,38 +85,41 @@@ static inline int save_fsave_header(str
  	} else {
  		struct fregs_state __user *fp = buf;
  		u32 swd;
 -
  		if (__get_user(swd, &fp->swd) || __put_user(swd, &fp->status))
 -			return false;
 +			return -1;
  	}
  
 -	return true;
 +	return 0;
  }
  
++<<<<<<< HEAD
 +static inline int save_xstate_epilog(void __user *buf, int ia32_frame)
++=======
+ /*
+  * Prepare the SW reserved portion of the fxsave memory layout, indicating
+  * the presence of the extended state information in the memory layout
+  * pointed to by the fpstate pointer in the sigcontext.
+  * This is saved when ever the FP and extended state context is
+  * saved on the user stack during the signal handler delivery to the user.
+  */
+ static inline void save_sw_bytes(struct _fpx_sw_bytes *sw_bytes, bool ia32_frame,
+ 				 struct fpstate *fpstate)
+ {
+ 	sw_bytes->magic1 = FP_XSTATE_MAGIC1;
+ 	sw_bytes->extended_size = fpstate->user_size + FP_XSTATE_MAGIC2_SIZE;
+ 	sw_bytes->xfeatures = fpstate->user_xfeatures;
+ 	sw_bytes->xstate_size = fpstate->user_size;
+ 
+ 	if (ia32_frame)
+ 		sw_bytes->extended_size += sizeof(struct fregs_state);
+ }
+ 
+ static inline bool save_xstate_epilog(void __user *buf, int ia32_frame,
+ 				      struct fpstate *fpstate)
++>>>>>>> 53599b4d54b9 (x86/fpu/signal: Prepare for variable sigframe length)
  {
  	struct xregs_state __user *x = buf;
- 	struct _fpx_sw_bytes *sw_bytes;
+ 	struct _fpx_sw_bytes sw_bytes;
  	u32 xfeatures;
  	int err;
  
@@@ -110,7 -130,7 +131,11 @@@
  		return !err;
  
  	err |= __put_user(FP_XSTATE_MAGIC2,
++<<<<<<< HEAD
 +			  (__u32 __user *)(buf + fpu_user_xstate_size));
++=======
+ 			  (__u32 __user *)(buf + fpstate->user_size));
++>>>>>>> 53599b4d54b9 (x86/fpu/signal: Prepare for variable sigframe length)
  
  	/*
  	 * Read the xfeatures which we copied (directly from the cpu or
@@@ -165,10 -185,11 +190,15 @@@ static inline int copy_fpregs_to_sigfra
   * For [f]xsave state, update the SW reserved fields in the [f]xsave frame
   * indicating the absence/presence of the extended state to the user.
   */
 -bool copy_fpstate_to_sigframe(void __user *buf, void __user *buf_fx, int size)
 +int copy_fpstate_to_sigframe(void __user *buf, void __user *buf_fx, int size)
  {
  	struct task_struct *tsk = current;
++<<<<<<< HEAD
 +	int ia32_fxstate = (buf != buf_fx);
++=======
+ 	struct fpstate *fpstate = tsk->thread.fpu.fpstate;
+ 	bool ia32_fxstate = (buf != buf_fx);
++>>>>>>> 53599b4d54b9 (x86/fpu/signal: Prepare for variable sigframe length)
  	int ret;
  
  	ia32_fxstate &= (IS_ENABLED(CONFIG_X86_32) ||
@@@ -218,20 -239,20 +248,25 @@@ retry
  	}
  
  	/* Save the fsave header for the 32-bit frames. */
 -	if ((ia32_fxstate || !use_fxsr()) && !save_fsave_header(tsk, buf))
 -		return false;
 +	if ((ia32_fxstate || !use_fxsr()) && save_fsave_header(tsk, buf))
 +		return -1;
  
++<<<<<<< HEAD
 +	if (use_fxsr() && save_xstate_epilog(buf_fx, ia32_fxstate))
 +		return -1;
++=======
+ 	if (use_fxsr() && !save_xstate_epilog(buf_fx, ia32_fxstate, fpstate))
+ 		return false;
++>>>>>>> 53599b4d54b9 (x86/fpu/signal: Prepare for variable sigframe length)
  
 -	return true;
 +	return 0;
  }
  
 -static int __restore_fpregs_from_user(void __user *buf, u64 ufeatures,
 -				      u64 xrestore, bool fx_only)
 +static int __restore_fpregs_from_user(void __user *buf, u64 xrestore,
 +				      bool fx_only)
  {
  	if (use_xsave()) {
 -		u64 init_bv = ufeatures & ~xrestore;
 +		u64 init_bv = xfeatures_mask_uabi() & ~xrestore;
  		int ret;
  
  		if (likely(!fx_only))
@@@ -510,28 -538,3 +545,31 @@@ unsigned long fpu__get_fpstate_size(voi
  	return ret;
  }
  
++<<<<<<< HEAD
 +/*
 + * Prepare the SW reserved portion of the fxsave memory layout, indicating
 + * the presence of the extended state information in the memory layout
 + * pointed by the fpstate pointer in the sigcontext.
 + * This will be saved when ever the FP and extended state context is
 + * saved on the user stack during the signal handler delivery to the user.
 + */
 +void __init fpu__init_prepare_fx_sw_frame(void)
 +{
 +	int size = fpu_user_xstate_size + FP_XSTATE_MAGIC2_SIZE;
 +
 +	fx_sw_reserved.magic1 = FP_XSTATE_MAGIC1;
 +	fx_sw_reserved.extended_size = size;
 +	fx_sw_reserved.xfeatures = xfeatures_mask_uabi();
 +	fx_sw_reserved.xstate_size = fpu_user_xstate_size;
 +
 +	if (IS_ENABLED(CONFIG_IA32_EMULATION) ||
 +	    IS_ENABLED(CONFIG_X86_32)) {
 +		int fsave_header_size = sizeof(struct fregs_state);
 +
 +		fx_sw_reserved_ia32 = fx_sw_reserved;
 +		fx_sw_reserved_ia32.extended_size = size + fsave_header_size;
 +	}
 +}
 +
++=======
++>>>>>>> 53599b4d54b9 (x86/fpu/signal: Prepare for variable sigframe length)
* Unmerged path arch/x86/kernel/fpu/internal.h
* Unmerged path arch/x86/kernel/fpu/signal.c
diff --git a/arch/x86/kernel/fpu/xstate.c b/arch/x86/kernel/fpu/xstate.c
index f744359fb635..3a161448cd67 100644
--- a/arch/x86/kernel/fpu/xstate.c
+++ b/arch/x86/kernel/fpu/xstate.c
@@ -817,7 +817,6 @@ void __init fpu__init_system_xstate(void)
 	 */
 	update_regset_xstate_info(fpu_user_xstate_size, xfeatures_mask_uabi());
 
-	fpu__init_prepare_fx_sw_frame();
 	setup_init_fpu_buf();
 	setup_xstate_comp_offsets();
 	setup_supervisor_only_offsets();
