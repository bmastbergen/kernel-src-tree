bnxt_en: Fix UDP tunnel logic

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Michael Chan <michael.chan@broadcom.com>
commit 7ae9dc356f247ad9f9634b3da61a45eb72968b2e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/7ae9dc35.failed

The current logic assumes that when the driver sends the message to the
firmware to add the VXLAN or Geneve port, the firmware will never fail
the operation.  The UDP ports are always stored and are used to check
the tunnel packets in .ndo_features_check().  These tunnnel packets
will fail to offload on the transmit side if firmware fails the call to
add the UDP ports.

To fix the problem, bp->vxlan_port and bp->nge_port will only be set to
the offloaded ports when the HWRM_TUNNEL_DST_PORT_ALLOC firmware call
succeeds.  When deleting a UDP port, we check that the port was
previously added successfuly first by checking the FW ID.

Fixes: 1698d600b361 ("bnxt_en: Implement .ndo_features_check().")
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7ae9dc356f247ad9f9634b3da61a45eb72968b2e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 8cfaddda9936,40a390652d8d..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -4898,19 -4638,31 +4898,44 @@@ static int bnxt_hwrm_func_drv_unrgtr(st
  
  static int bnxt_hwrm_tunnel_dst_port_free(struct bnxt *bp, u8 tunnel_type)
  {
 -	struct hwrm_tunnel_dst_port_free_input *req;
 -	int rc;
 +	u32 rc = 0;
 +	struct hwrm_tunnel_dst_port_free_input req = {0};
  
++<<<<<<< HEAD
 +	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_TUNNEL_DST_PORT_FREE, -1, -1);
 +	req.tunnel_type = tunnel_type;
 +
 +	switch (tunnel_type) {
 +	case TUNNEL_DST_PORT_FREE_REQ_TUNNEL_TYPE_VXLAN:
 +		req.tunnel_dst_port_id = cpu_to_le16(bp->vxlan_fw_dst_port_id);
 +		bp->vxlan_fw_dst_port_id = INVALID_HW_RING_ID;
 +		break;
 +	case TUNNEL_DST_PORT_FREE_REQ_TUNNEL_TYPE_GENEVE:
 +		req.tunnel_dst_port_id = cpu_to_le16(bp->nge_fw_dst_port_id);
++=======
+ 	if (tunnel_type == TUNNEL_DST_PORT_FREE_REQ_TUNNEL_TYPE_VXLAN &&
+ 	    bp->vxlan_fw_dst_port_id == INVALID_HW_RING_ID)
+ 		return 0;
+ 	if (tunnel_type == TUNNEL_DST_PORT_FREE_REQ_TUNNEL_TYPE_GENEVE &&
+ 	    bp->nge_fw_dst_port_id == INVALID_HW_RING_ID)
+ 		return 0;
+ 
+ 	rc = hwrm_req_init(bp, req, HWRM_TUNNEL_DST_PORT_FREE);
+ 	if (rc)
+ 		return rc;
+ 
+ 	req->tunnel_type = tunnel_type;
+ 
+ 	switch (tunnel_type) {
+ 	case TUNNEL_DST_PORT_FREE_REQ_TUNNEL_TYPE_VXLAN:
+ 		req->tunnel_dst_port_id = cpu_to_le16(bp->vxlan_fw_dst_port_id);
+ 		bp->vxlan_port = 0;
+ 		bp->vxlan_fw_dst_port_id = INVALID_HW_RING_ID;
+ 		break;
+ 	case TUNNEL_DST_PORT_FREE_REQ_TUNNEL_TYPE_GENEVE:
+ 		req->tunnel_dst_port_id = cpu_to_le16(bp->nge_fw_dst_port_id);
+ 		bp->nge_port = 0;
++>>>>>>> 7ae9dc356f24 (bnxt_en: Fix UDP tunnel logic)
  		bp->nge_fw_dst_port_id = INVALID_HW_RING_ID;
  		break;
  	default:
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
