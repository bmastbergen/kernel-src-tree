tcp: remove indirect calls for icsk->icsk_af_ops->queue_xmit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 05e22e8395058745bd0312bc488b522197852aff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/05e22e83.failed

Mitigate RETPOLINE costs in __tcp_transmit_skb()
by using INDIRECT_CALL_INET() wrapper.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 05e22e8395058745bd0312bc488b522197852aff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_output.c
diff --cc net/ipv4/tcp_output.c
index 13eacd35b79b,be1bd37185d8..000000000000
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@@ -1406,7 -1236,11 +1409,15 @@@ static int __tcp_transmit_skb(struct so
  	memset(skb->cb, 0, max(sizeof(struct inet_skb_parm),
  			       sizeof(struct inet6_skb_parm)));
  
++<<<<<<< HEAD
 +	err = icsk->icsk_af_ops->queue_xmit(sk, skb, &inet->cork.fl);
++=======
+ 	tcp_add_tx_delay(skb, tp);
+ 
+ 	err = INDIRECT_CALL_INET(icsk->icsk_af_ops->queue_xmit,
+ 				 inet6_csk_xmit, ip_queue_xmit,
+ 				 sk, skb, &inet->cork.fl);
++>>>>>>> 05e22e839505 (tcp: remove indirect calls for icsk->icsk_af_ops->queue_xmit)
  
  	if (unlikely(err > 0)) {
  		tcp_enter_cwr(sk);
diff --git a/include/net/ip.h b/include/net/ip.h
index 2849834cdc17..0bd232137475 100644
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -176,11 +176,7 @@ struct sk_buff *ip_make_skb(struct sock *sk, struct flowi4 *fl4,
 			    struct ipcm_cookie *ipc, struct rtable **rtp,
 			    struct inet_cork *cork, unsigned int flags);
 
-static inline int ip_queue_xmit(struct sock *sk, struct sk_buff *skb,
-				struct flowi *fl)
-{
-	return __ip_queue_xmit(sk, skb, fl, inet_sk(sk)->tos);
-}
+int ip_queue_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl);
 
 static inline struct sk_buff *ip_finish_skb(struct sock *sk, struct flowi4 *fl4)
 {
diff --git a/include/net/tcp.h b/include/net/tcp.h
index eb747e5c8009..f906b192e50e 100644
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -30,6 +30,7 @@
 #include <linux/cryptohash.h>
 #include <linux/kref.h>
 #include <linux/ktime.h>
+#include <linux/indirect_call_wrapper.h>
 
 #include <net/inet_connection_sock.h>
 #include <net/inet_timewait_sock.h>
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index 3535b3351db2..e18239b9a992 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -527,6 +527,12 @@ int __ip_queue_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl,
 }
 EXPORT_SYMBOL(__ip_queue_xmit);
 
+int ip_queue_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl)
+{
+	return __ip_queue_xmit(sk, skb, fl, inet_sk(sk)->tos);
+}
+EXPORT_SYMBOL(ip_queue_xmit);
+
 static void ip_copy_metadata(struct sk_buff *to, struct sk_buff *from)
 {
 	to->pkt_type = from->pkt_type;
* Unmerged path net/ipv4/tcp_output.c
