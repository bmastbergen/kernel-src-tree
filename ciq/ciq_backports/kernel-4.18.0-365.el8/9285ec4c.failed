timekeeping: Use proper clock specifier names in functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Jason A. Donenfeld <Jason@zx2c4.com>
commit 9285ec4c8b61d4930a575081abeba2cd4f449a74
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/9285ec4c.failed

This makes boot uniformly boottime and tai uniformly clocktai, to
address the remaining oversights.

	Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Arnd Bergmann <arnd@arndb.de>
Link: https://lkml.kernel.org/r/20190621203249.3909-2-Jason@zx2c4.com

(cherry picked from commit 9285ec4c8b61d4930a575081abeba2cd4f449a74)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/core-api/timekeeping.rst
#	arch/x86/kvm/x86.c
#	drivers/net/wireless/ti/wlcore/rx.c
#	drivers/net/wireless/virt_wifi.c
#	kernel/bpf/syscall.c
diff --cc arch/x86/kvm/x86.c
index a21d8033ffa2,81a0914a1ec1..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -2502,8 -1729,9 +2502,13 @@@ static void kvm_synchronize_tsc(struct 
  	bool synchronizing = false;
  
  	raw_spin_lock_irqsave(&kvm->arch.tsc_write_lock, flags);
++<<<<<<< HEAD
 +	offset = kvm_compute_l1_tsc_offset(vcpu, data);
 +	ns = get_kvmclock_base_ns();
++=======
+ 	offset = kvm_compute_tsc_offset(vcpu, data);
+ 	ns = ktime_get_boottime_ns();
++>>>>>>> 9285ec4c8b61 (timekeeping: Use proper clock specifier names in functions)
  	elapsed = ns - kvm->arch.last_tsc_nsec;
  
  	if (vcpu->arch.virtual_tsc_khz) {
@@@ -2835,13 -2068,12 +2840,18 @@@ u64 get_kvmclock_ns(struct kvm *kvm
  {
  	struct kvm_arch *ka = &kvm->arch;
  	struct pvclock_vcpu_time_info hv_clock;
 +	unsigned long flags;
  	u64 ret;
  
 -	spin_lock(&ka->pvclock_gtod_sync_lock);
 +	raw_spin_lock_irqsave(&ka->pvclock_gtod_sync_lock, flags);
  	if (!ka->use_master_clock) {
++<<<<<<< HEAD
 +		raw_spin_unlock_irqrestore(&ka->pvclock_gtod_sync_lock, flags);
 +		return get_kvmclock_base_ns() + ka->kvmclock_offset;
++=======
+ 		spin_unlock(&ka->pvclock_gtod_sync_lock);
+ 		return ktime_get_boottime_ns() + ka->kvmclock_offset;
++>>>>>>> 9285ec4c8b61 (timekeeping: Use proper clock specifier names in functions)
  	}
  
  	hv_clock.tsc_timestamp = ka->master_cycle_now;
@@@ -2857,7 -2089,7 +2867,11 @@@
  				   &hv_clock.tsc_to_system_mul);
  		ret = __pvclock_read_cycles(&hv_clock, rdtsc());
  	} else
++<<<<<<< HEAD
 +		ret = get_kvmclock_base_ns() + ka->kvmclock_offset;
++=======
+ 		ret = ktime_get_boottime_ns() + ka->kvmclock_offset;
++>>>>>>> 9285ec4c8b61 (timekeeping: Use proper clock specifier names in functions)
  
  	put_cpu();
  
@@@ -2958,7 -2188,7 +2972,11 @@@ static int kvm_guest_time_update(struc
  	}
  	if (!use_master_clock) {
  		host_tsc = rdtsc();
++<<<<<<< HEAD
 +		kernel_ns = get_kvmclock_base_ns();
++=======
+ 		kernel_ns = ktime_get_boottime_ns();
++>>>>>>> 9285ec4c8b61 (timekeeping: Use proper clock specifier names in functions)
  	}
  
  	tsc_timestamp = kvm_read_l1_tsc(v, host_tsc);
@@@ -11270,9 -9244,9 +11288,13 @@@ int kvm_arch_init_vm(struct kvm *kvm, u
  
  	raw_spin_lock_init(&kvm->arch.tsc_write_lock);
  	mutex_init(&kvm->arch.apic_map_lock);
 -	spin_lock_init(&kvm->arch.pvclock_gtod_sync_lock);
 +	raw_spin_lock_init(&kvm->arch.pvclock_gtod_sync_lock);
  
++<<<<<<< HEAD
 +	kvm->arch.kvmclock_offset = -get_kvmclock_base_ns();
++=======
+ 	kvm->arch.kvmclock_offset = -ktime_get_boottime_ns();
++>>>>>>> 9285ec4c8b61 (timekeeping: Use proper clock specifier names in functions)
  	pvclock_update_vm_gtod_copy(kvm);
  
  	kvm->arch.guest_can_read_msr_platform_info = true;
diff --cc drivers/net/wireless/ti/wlcore/rx.c
index 0f15696195f8,307fab21050b..000000000000
--- a/drivers/net/wireless/ti/wlcore/rx.c
+++ b/drivers/net/wireless/ti/wlcore/rx.c
@@@ -106,6 -92,9 +106,12 @@@ static void wl1271_rx_status(struct wl1
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (beacon || probe_rsp)
+ 		status->boottime_ns = ktime_get_boottime_ns();
+ 
++>>>>>>> 9285ec4c8b61 (timekeeping: Use proper clock specifier names in functions)
  	if (beacon)
  		wlcore_set_pending_regdomain_ch(wl, (u16)desc->channel,
  						status->band);
diff --cc kernel/bpf/syscall.c
index e753da7967bb,96c8928b468b..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -2230,13 -1664,12 +2230,20 @@@ static int bpf_prog_load(union bpf_att
  	/* find program type: socket_filter vs tracing_filter */
  	err = find_prog_type(type, prog);
  	if (err < 0)
 -		goto free_prog;
 +		goto free_prog_sec;
  
++<<<<<<< HEAD
 +	prog->aux->load_time = ktime_get_boot_ns();
 +	err = bpf_obj_name_cpy(prog->aux->name, attr->prog_name,
 +			       sizeof(attr->prog_name));
 +	if (err < 0)
 +		goto free_prog_sec;
++=======
+ 	prog->aux->load_time = ktime_get_boottime_ns();
+ 	err = bpf_obj_name_cpy(prog->aux->name, attr->prog_name);
+ 	if (err)
+ 		goto free_prog;
++>>>>>>> 9285ec4c8b61 (timekeeping: Use proper clock specifier names in functions)
  
  	/* run eBPF verifier */
  	err = bpf_check(&prog, attr, uattr);
* Unmerged path Documentation/core-api/timekeeping.rst
* Unmerged path drivers/net/wireless/virt_wifi.c
* Unmerged path Documentation/core-api/timekeeping.rst
diff --git a/arch/x86/kvm/pmu.c b/arch/x86/kvm/pmu.c
index 28209af707ac..0772bad9165c 100644
--- a/arch/x86/kvm/pmu.c
+++ b/arch/x86/kvm/pmu.c
@@ -344,10 +344,10 @@ static int kvm_pmu_rdpmc_vmware(struct kvm_vcpu *vcpu, unsigned idx, u64 *data)
 		ctr_val = rdtsc();
 		break;
 	case VMWARE_BACKDOOR_PMC_REAL_TIME:
-		ctr_val = ktime_get_boot_ns();
+		ctr_val = ktime_get_boottime_ns();
 		break;
 	case VMWARE_BACKDOOR_PMC_APPARENT_TIME:
-		ctr_val = ktime_get_boot_ns() +
+		ctr_val = ktime_get_boottime_ns() +
 			vcpu->kvm->arch.kvmclock_offset;
 		break;
 	default:
* Unmerged path arch/x86/kvm/x86.c
diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index 1a9f8f4ffb88..18f13355000a 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -158,7 +158,7 @@ static int dht11_decode(struct dht11 *dht11, int offset)
 		return -EIO;
 	}
 
-	dht11->timestamp = ktime_get_boot_ns();
+	dht11->timestamp = ktime_get_boottime_ns();
 	if (hum_int < 4) {  /* DHT22: 100000 = (3*256+232)*100 */
 		dht11->temperature = (((temp_int & 0x7f) << 8) + temp_dec) *
 					((temp_int & 0x80) ? -100 : 100);
@@ -186,7 +186,7 @@ static irqreturn_t dht11_handle_irq(int irq, void *data)
 
 	/* TODO: Consider making the handler safe for IRQ sharing */
 	if (dht11->num_edges < DHT11_EDGES_PER_READ && dht11->num_edges >= 0) {
-		dht11->edges[dht11->num_edges].ts = ktime_get_boot_ns();
+		dht11->edges[dht11->num_edges].ts = ktime_get_boottime_ns();
 		dht11->edges[dht11->num_edges++].value =
 						gpio_get_value(dht11->gpio);
 
@@ -205,7 +205,7 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 	int ret, timeres, offset;
 
 	mutex_lock(&dht11->lock);
-	if (dht11->timestamp + DHT11_DATA_VALID_TIME < ktime_get_boot_ns()) {
+	if (dht11->timestamp + DHT11_DATA_VALID_TIME < ktime_get_boottime_ns()) {
 		timeres = ktime_get_resolution_ns();
 		dev_dbg(dht11->dev, "current timeresolution: %dns\n", timeres);
 		if (timeres > DHT11_MIN_TIMERES) {
@@ -331,7 +331,7 @@ static int dht11_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
-	dht11->timestamp = ktime_get_boot_ns() - DHT11_DATA_VALID_TIME - 1;
+	dht11->timestamp = ktime_get_boottime_ns() - DHT11_DATA_VALID_TIME - 1;
 	dht11->num_edges = -1;
 
 	platform_set_drvdata(pdev, iio);
diff --git a/drivers/iio/industrialio-core.c b/drivers/iio/industrialio-core.c
index d2df625b3636..4462133c05f8 100644
--- a/drivers/iio/industrialio-core.c
+++ b/drivers/iio/industrialio-core.c
@@ -222,9 +222,9 @@ s64 iio_get_time_ns(const struct iio_dev *indio_dev)
 		ktime_get_coarse_ts64(&tp);
 		return timespec64_to_ns(&tp);
 	case CLOCK_BOOTTIME:
-		return ktime_get_boot_ns();
+		return ktime_get_boottime_ns();
 	case CLOCK_TAI:
-		return ktime_get_tai_ns();
+		return ktime_get_clocktai_ns();
 	default:
 		BUG();
 	}
diff --git a/drivers/infiniband/hw/mlx4/alias_GUID.c b/drivers/infiniband/hw/mlx4/alias_GUID.c
index ca059c93ef60..571d9c542024 100644
--- a/drivers/infiniband/hw/mlx4/alias_GUID.c
+++ b/drivers/infiniband/hw/mlx4/alias_GUID.c
@@ -310,7 +310,7 @@ static void aliasguid_query_handler(int status,
 	if (status) {
 		pr_debug("(port: %d) failed: status = %d\n",
 			 cb_ctx->port, status);
-		rec->time_to_run = ktime_get_boot_ns() + 1 * NSEC_PER_SEC;
+		rec->time_to_run = ktime_get_boottime_ns() + 1 * NSEC_PER_SEC;
 		goto out;
 	}
 
@@ -416,7 +416,7 @@ static void aliasguid_query_handler(int status,
 			 be64_to_cpu((__force __be64)rec->guid_indexes),
 			 be64_to_cpu((__force __be64)applied_guid_indexes),
 			 be64_to_cpu((__force __be64)declined_guid_indexes));
-		rec->time_to_run = ktime_get_boot_ns() +
+		rec->time_to_run = ktime_get_boottime_ns() +
 			resched_delay_sec * NSEC_PER_SEC;
 	} else {
 		rec->status = MLX4_GUID_INFO_STATUS_SET;
@@ -709,7 +709,7 @@ static int get_low_record_time_index(struct mlx4_ib_dev *dev, u8 port,
 		}
 	}
 	if (resched_delay_sec) {
-		u64 curr_time = ktime_get_boot_ns();
+		u64 curr_time = ktime_get_boottime_ns();
 
 		*resched_delay_sec = (low_record_time < curr_time) ? 0 :
 			div_u64((low_record_time - curr_time), NSEC_PER_SEC);
diff --git a/drivers/leds/trigger/ledtrig-activity.c b/drivers/leds/trigger/ledtrig-activity.c
index 0bec2b0d93af..f082c507a9da 100644
--- a/drivers/leds/trigger/ledtrig-activity.c
+++ b/drivers/leds/trigger/ledtrig-activity.c
@@ -73,7 +73,7 @@ static void led_activity_function(struct timer_list *t)
 	 * down to 16us, ensuring we won't overflow 32-bit computations below
 	 * even up to 3k CPUs, while keeping divides cheap on smaller systems.
 	 */
-	curr_boot = ktime_get_boot_ns() * cpus;
+	curr_boot = ktime_get_boottime_ns() * cpus;
 	diff_boot = (curr_boot - activity_data->last_boot) >> 16;
 	diff_used = (curr_used - activity_data->last_used) >> 16;
 	activity_data->last_boot = curr_boot;
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/ftm-initiator.c b/drivers/net/wireless/intel/iwlwifi/mvm/ftm-initiator.c
index d5022f41c7a8..a456b8a0ae58 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/ftm-initiator.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/ftm-initiator.c
@@ -135,7 +135,7 @@ void iwl_mvm_ftm_restart(struct iwl_mvm *mvm)
 	struct cfg80211_pmsr_result result = {
 		.status = NL80211_PMSR_STATUS_FAILURE,
 		.final = 1,
-		.host_time = ktime_get_boot_ns(),
+		.host_time = ktime_get_boottime_ns(),
 		.type = NL80211_PMSR_TYPE_FTM,
 	};
 	int i;
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/rx.c b/drivers/net/wireless/intel/iwlwifi/mvm/rx.c
index 664b38b67e0d..8ef5399ad9be 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/rx.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/rx.c
@@ -517,7 +517,7 @@ void iwl_mvm_rx_rx_mpdu(struct iwl_mvm *mvm, struct napi_struct *napi,
 
 	if (unlikely(ieee80211_is_beacon(hdr->frame_control) ||
 		     ieee80211_is_probe_resp(hdr->frame_control)))
-		rx_status->boottime_ns = ktime_get_boot_ns();
+		rx_status->boottime_ns = ktime_get_boottime_ns();
 
 	iwl_mvm_pass_packet_to_mac80211(mvm, sta, napi, skb, hdr, len,
 					crypt_len, rxb);
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c b/drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c
index 3c52ef8a9ee8..8e26422ca326 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c
@@ -1971,7 +1971,7 @@ void iwl_mvm_rx_mpdu_mq(struct iwl_mvm *mvm, struct napi_struct *napi,
 
 		if (unlikely(ieee80211_is_beacon(hdr->frame_control) ||
 			     ieee80211_is_probe_resp(hdr->frame_control)))
-			rx_status->boottime_ns = ktime_get_boot_ns();
+			rx_status->boottime_ns = ktime_get_boottime_ns();
 	}
 
 	if (iwl_mvm_create_skb(mvm, skb, hdr, len, crypt_len, rxb)) {
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/utils.c b/drivers/net/wireless/intel/iwlwifi/mvm/utils.c
index 74a8ba214aa8..c566be99a4c7 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/utils.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/utils.c
@@ -1412,7 +1412,7 @@ void iwl_mvm_get_sync_time(struct iwl_mvm *mvm, u32 *gp2, u64 *boottime)
 	}
 
 	*gp2 = iwl_mvm_get_systime(mvm);
-	*boottime = ktime_get_boot_ns();
+	*boottime = ktime_get_boottime_ns();
 
 	if (!ps_disabled) {
 		mvm->ps_disabled = ps_disabled;
diff --git a/drivers/net/wireless/mac80211_hwsim.c b/drivers/net/wireless/mac80211_hwsim.c
index 9e975817b139..184e3b0186f9 100644
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@ -1504,7 +1504,7 @@ static bool mac80211_hwsim_tx_frame_no_nl(struct ieee80211_hw *hw,
 	 */
 	if (ieee80211_is_beacon(hdr->frame_control) ||
 	    ieee80211_is_probe_resp(hdr->frame_control)) {
-		rx_status.boottime_ns = ktime_get_boot_ns();
+		rx_status.boottime_ns = ktime_get_boottime_ns();
 		now = data->abs_bcn_ts;
 	} else {
 		now = mac80211_hwsim_get_tsf_raw();
diff --git a/drivers/net/wireless/ti/wlcore/main.c b/drivers/net/wireless/ti/wlcore/main.c
index 01f66703a946..5584178bb8e2 100644
--- a/drivers/net/wireless/ti/wlcore/main.c
+++ b/drivers/net/wireless/ti/wlcore/main.c
@@ -485,7 +485,7 @@ static int wlcore_fw_status(struct wl1271 *wl, struct wl_fw_status *status)
 	}
 
 	/* update the host-chipset time offset */
-	wl->time_offset = (ktime_get_boot_ns() >> 10) -
+	wl->time_offset = (ktime_get_boottime_ns() >> 10) -
 		(s64)(status->fw_localtime);
 
 	wl->fw_fast_lnk_map = status->link_fast_bitmap;
* Unmerged path drivers/net/wireless/ti/wlcore/rx.c
diff --git a/drivers/net/wireless/ti/wlcore/tx.c b/drivers/net/wireless/ti/wlcore/tx.c
index 00e9b4624dcf..1d12b293c8a5 100644
--- a/drivers/net/wireless/ti/wlcore/tx.c
+++ b/drivers/net/wireless/ti/wlcore/tx.c
@@ -286,7 +286,7 @@ static void wl1271_tx_fill_hdr(struct wl1271 *wl, struct wl12xx_vif *wlvif,
 	}
 
 	/* configure packet life time */
-	hosttime = (ktime_get_boot_ns() >> 10);
+	hosttime = (ktime_get_boottime_ns() >> 10);
 	desc->start_time = cpu_to_le32(hosttime - wl->time_offset);
 
 	is_dummy = wl12xx_is_dummy_packet(wl, skb);
* Unmerged path drivers/net/wireless/virt_wifi.c
diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index edace6b656e9..43d6546bcfb3 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -116,12 +116,12 @@ static inline u64 ktime_get_real_ns(void)
 	return ktime_to_ns(ktime_get_real());
 }
 
-static inline u64 ktime_get_boot_ns(void)
+static inline u64 ktime_get_boottime_ns(void)
 {
 	return ktime_to_ns(ktime_get_boottime());
 }
 
-static inline u64 ktime_get_tai_ns(void)
+static inline u64 ktime_get_clocktai_ns(void)
 {
 	return ktime_to_ns(ktime_get_clocktai());
 }
diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index ca3cce4791a4..c3907d71279b 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -2418,7 +2418,7 @@ enum cfg80211_signal_type {
  *	received by the device (not just by the host, in case it was
  *	buffered on the device) and be accurate to about 10ms.
  *	If the frame isn't buffered, just passing the return value of
- *	ktime_get_boot_ns() is likely appropriate.
+ *	ktime_get_boottime_ns() is likely appropriate.
  * @parent_tsf: the time at the start of reception of the first octet of the
  *	timestamp field of the frame. The time is the TSF of the BSS specified
  *	by %parent_bssid.
* Unmerged path kernel/bpf/syscall.c
diff --git a/kernel/events/core.c b/kernel/events/core.c
index ddf1e03f2528..2e9baa370c9a 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -11863,11 +11863,11 @@ static int perf_event_set_clock(struct perf_event *event, clockid_t clk_id)
 		break;
 
 	case CLOCK_BOOTTIME:
-		event->clock = &ktime_get_boot_ns;
+		event->clock = &ktime_get_boottime_ns;
 		break;
 
 	case CLOCK_TAI:
-		event->clock = &ktime_get_tai_ns;
+		event->clock = &ktime_get_clocktai_ns;
 		break;
 
 	default:
diff --git a/kernel/fork.c b/kernel/fork.c
index 7fbe680085b2..0cd5a07a42e0 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -2130,7 +2130,7 @@ static __latent_entropy struct task_struct *copy_process(
 	 */
 
 	p->start_time = ktime_get_ns();
-	p->real_start_time = ktime_get_boot_ns();
+	p->real_start_time = ktime_get_boottime_ns();
 
 	/*
 	 * Make it visible to the rest of the system, but dont wake it up yet.
