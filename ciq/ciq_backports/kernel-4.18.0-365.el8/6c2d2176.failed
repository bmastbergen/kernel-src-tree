netfilter: ctnetlink: memleak in filter initialization error path

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 6c2d2176a85eb2fd65eb7cfe94b3bad0acce99c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/6c2d2176.failed

Release the filter object in case of error.

Fixes: cb8aa9a3affb ("netfilter: ctnetlink: add kernel side filtering for dump")
	Reported-by: syzbot+38b8b548a851a01793c5@syzkaller.appspotmail.com
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 6c2d2176a85eb2fd65eb7cfe94b3bad0acce99c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_netlink.c
diff --cc net/netfilter/nf_conntrack_netlink.c
index 42c27d1c2011,832eabecfbdd..000000000000
--- a/net/netfilter/nf_conntrack_netlink.c
+++ b/net/netfilter/nf_conntrack_netlink.c
@@@ -871,14 -928,77 +871,78 @@@ ctnetlink_alloc_filter(const struct nla
  	filter->family = family;
  
  #ifdef CONFIG_NF_CONNTRACK_MARK
 -	if (cda[CTA_MARK]) {
 +	if (cda[CTA_MARK] && cda[CTA_MARK_MASK]) {
  		filter->mark.val = ntohl(nla_get_be32(cda[CTA_MARK]));
++<<<<<<< HEAD
 +		filter->mark.mask = ntohl(nla_get_be32(cda[CTA_MARK_MASK]));
 +	}
 +#endif
++=======
+ 		filter->cta_flags |= CTA_FILTER_FLAG(CTA_MARK);
+ 
+ 		if (cda[CTA_MARK_MASK]) {
+ 			filter->mark.mask = ntohl(nla_get_be32(cda[CTA_MARK_MASK]));
+ 			filter->cta_flags |= CTA_FILTER_FLAG(CTA_MARK_MASK);
+ 		} else {
+ 			filter->mark.mask = 0xffffffff;
+ 		}
+ 	} else if (cda[CTA_MARK_MASK]) {
+ 		err = -EINVAL;
+ 		goto err_filter;
+ 	}
+ #endif
+ 	if (!cda[CTA_FILTER])
+ 		return filter;
+ 
+ 	err = ctnetlink_parse_zone(cda[CTA_ZONE], &filter->zone);
+ 	if (err < 0)
+ 		goto err_filter;
+ 
+ 	err = ctnetlink_parse_filter(cda[CTA_FILTER], filter);
+ 	if (err < 0)
+ 		goto err_filter;
+ 
+ 	if (filter->orig_flags) {
+ 		if (!cda[CTA_TUPLE_ORIG]) {
+ 			err = -EINVAL;
+ 			goto err_filter;
+ 		}
+ 
+ 		err = ctnetlink_parse_tuple_filter(cda, &filter->orig,
+ 						   CTA_TUPLE_ORIG,
+ 						   filter->family,
+ 						   &filter->zone,
+ 						   filter->orig_flags);
+ 		if (err < 0)
+ 			goto err_filter;
+ 	}
+ 
+ 	if (filter->reply_flags) {
+ 		if (!cda[CTA_TUPLE_REPLY]) {
+ 			err = -EINVAL;
+ 			goto err_filter;
+ 		}
+ 
+ 		err = ctnetlink_parse_tuple_filter(cda, &filter->reply,
+ 						   CTA_TUPLE_REPLY,
+ 						   filter->family,
+ 						   &filter->zone,
+ 						   filter->orig_flags);
+ 		if (err < 0) {
+ 			err = -EINVAL;
+ 			goto err_filter;
+ 		}
+ 	}
+ 
++>>>>>>> 6c2d2176a85e (netfilter: ctnetlink: memleak in filter initialization error path)
  	return filter;
+ 
+ err_filter:
+ 	kfree(filter);
+ 
+ 	return ERR_PTR(err);
  }
  
 -static bool ctnetlink_needs_filter(u8 family, const struct nlattr * const *cda)
 -{
 -	return family || cda[CTA_MARK] || cda[CTA_FILTER];
 -}
 -
  static int ctnetlink_start(struct netlink_callback *cb)
  {
  	const struct nlattr * const *cda = cb->data;
* Unmerged path net/netfilter/nf_conntrack_netlink.c
