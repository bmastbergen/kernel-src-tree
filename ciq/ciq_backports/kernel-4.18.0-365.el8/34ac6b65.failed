drm/i915/display: Handle frontbuffer rendering when PSR2 selective fetch is enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author José Roberto de Souza <jose.souza@intel.com>
commit 34ac6b651f39e63da8d0ae0edd2db32fbb1bc02c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/34ac6b65.failed

When PSR2 selective fetch is enabled writes to CURSURFLIVE alone do
not causes the panel to be updated when doing frontbuffer rendering.

From what I was able to figure from experiments the writes to
CURSURFLIVE takes PSR2 from deep sleep but panel is not updated
because PSR2_MAN_TRK_CTL has no start and end region set.

As we don't have the dirt area from current flush and invalidate API
and even if we did userspace could do several draws to frontbuffer and
we would need a way to append all the damaged areas of all the draws
that need to be part of next frame.

So here only programing PSR2_MAN_TRK_CTL to do a single full frame
fetch.

It is a safe approach as if scanout is in the visible area
the single full frame will only be visible for hardware in the next
frame because of the double buffering, and if scanout is in vblank
area it will be draw in the current frame.

No need to disable PSR and wait a few miliseconds to enable it again.

	Cc: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
	Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
	Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
	Reviewed-by: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210930001409.254817-4-jose.souza@intel.com
(cherry picked from commit 34ac6b651f39e63da8d0ae0edd2db32fbb1bc02c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_psr.c
diff --cc drivers/gpu/drm/i915/display/intel_psr.c
index 2c6c4a4f9477,9a5259bbebab..000000000000
--- a/drivers/gpu/drm/i915/display/intel_psr.c
+++ b/drivers/gpu/drm/i915/display/intel_psr.c
@@@ -1174,44 -1337,108 +1174,136 @@@ void intel_psr_disable(struct intel_dp 
  
  	intel_psr_disable_locked(intel_dp);
  
 -	mutex_unlock(&intel_dp->psr.lock);
 -	cancel_work_sync(&intel_dp->psr.work);
 -	cancel_delayed_work_sync(&intel_dp->psr.dc3co_work);
 +	mutex_unlock(&dev_priv->psr.lock);
 +	cancel_work_sync(&dev_priv->psr.work);
 +	cancel_delayed_work_sync(&dev_priv->psr.dc3co_work);
  }
  
 -/**
 - * intel_psr_pause - Pause PSR
 - * @intel_dp: Intel DP
 - *
 - * This function need to be called after enabling psr.
 - */
 -void intel_psr_pause(struct intel_dp *intel_dp)
 +static void psr_force_hw_tracking_exit(struct drm_i915_private *dev_priv)
  {
++<<<<<<< HEAD
 +	if (IS_TIGERLAKE(dev_priv))
 +		/*
 +		 * Writes to CURSURFLIVE in TGL are causing IOMMU errors and
 +		 * visual glitches that are often reproduced when executing
 +		 * CPU intensive workloads while a eDP 4K panel is attached.
 +		 *
 +		 * Manually exiting PSR causes the frontbuffer to be updated
 +		 * without glitches and the IOMMU errors are also gone but
 +		 * this comes at the cost of less time with PSR active.
 +		 *
 +		 * So using this workaround until this issue is root caused
 +		 * and a better fix is found.
 +		 */
 +		intel_psr_exit(dev_priv);
 +	else if (INTEL_GEN(dev_priv) >= 9)
 +		/*
 +		 * Display WA #0884: skl+
 +		 * This documented WA for bxt can be safely applied
 +		 * broadly so we can force HW tracking to exit PSR
 +		 * instead of disabling and re-enabling.
 +		 * Workaround tells us to write 0 to CUR_SURFLIVE_A,
 +		 * but it makes more sense write to the current active
 +		 * pipe.
 +		 */
 +		intel_de_write(dev_priv, CURSURFLIVE(dev_priv->psr.pipe), 0);
 +	else
 +		/*
 +		 * A write to CURSURFLIVE do not cause HW tracking to exit PSR
 +		 * on older gens so doing the manual exit instead.
 +		 */
 +		intel_psr_exit(dev_priv);
++=======
+ 	struct intel_psr *psr = &intel_dp->psr;
+ 
+ 	if (!CAN_PSR(intel_dp))
+ 		return;
+ 
+ 	mutex_lock(&psr->lock);
+ 
+ 	if (!psr->enabled) {
+ 		mutex_unlock(&psr->lock);
+ 		return;
+ 	}
+ 
+ 	intel_psr_exit(intel_dp);
+ 	intel_psr_wait_exit_locked(intel_dp);
+ 	psr->paused = true;
+ 
+ 	mutex_unlock(&psr->lock);
+ 
+ 	cancel_work_sync(&psr->work);
+ 	cancel_delayed_work_sync(&psr->dc3co_work);
+ }
+ 
+ /**
+  * intel_psr_resume - Resume PSR
+  * @intel_dp: Intel DP
+  *
+  * This function need to be called after pausing psr.
+  */
+ void intel_psr_resume(struct intel_dp *intel_dp)
+ {
+ 	struct intel_psr *psr = &intel_dp->psr;
+ 
+ 	if (!CAN_PSR(intel_dp))
+ 		return;
+ 
+ 	mutex_lock(&psr->lock);
+ 
+ 	if (!psr->paused)
+ 		goto unlock;
+ 
+ 	psr->paused = false;
+ 	intel_psr_activate(intel_dp);
+ 
+ unlock:
+ 	mutex_unlock(&psr->lock);
+ }
+ 
+ static inline u32 man_trk_ctl_single_full_frame_bit_get(struct drm_i915_private *dev_priv)
+ {
+ 	return IS_ALDERLAKE_P(dev_priv) ?
+ 	       ADLP_PSR2_MAN_TRK_CTL_SF_SINGLE_FULL_FRAME :
+ 	       PSR2_MAN_TRK_CTL_SF_SINGLE_FULL_FRAME;
+ }
+ 
+ static void psr_force_hw_tracking_exit(struct intel_dp *intel_dp)
+ {
+ 	struct drm_i915_private *dev_priv = dp_to_i915(intel_dp);
+ 
+ 	if (intel_dp->psr.psr2_sel_fetch_enabled)
+ 		intel_de_rmw(dev_priv,
+ 			     PSR2_MAN_TRK_CTL(intel_dp->psr.transcoder), 0,
+ 			     man_trk_ctl_single_full_frame_bit_get(dev_priv));
+ 
+ 	/*
+ 	 * Display WA #0884: skl+
+ 	 * This documented WA for bxt can be safely applied
+ 	 * broadly so we can force HW tracking to exit PSR
+ 	 * instead of disabling and re-enabling.
+ 	 * Workaround tells us to write 0 to CUR_SURFLIVE_A,
+ 	 * but it makes more sense write to the current active
+ 	 * pipe.
+ 	 *
+ 	 * This workaround do not exist for platforms with display 10 or newer
+ 	 * but testing proved that it works for up display 13, for newer
+ 	 * than that testing will be needed.
+ 	 */
+ 	intel_de_write(dev_priv, CURSURFLIVE(intel_dp->psr.pipe), 0);
+ }
+ 
+ void intel_psr2_disable_plane_sel_fetch(struct intel_plane *plane,
+ 					const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(plane->base.dev);
+ 	enum pipe pipe = plane->pipe;
+ 
+ 	if (!crtc_state->enable_psr2_sel_fetch)
+ 		return;
+ 
+ 	intel_de_write_fw(dev_priv, PLANE_SEL_FETCH_CTL(pipe, plane->id), 0);
++>>>>>>> 34ac6b651f39 (drm/i915/display: Handle frontbuffer rendering when PSR2 selective fetch is enabled)
  }
  
  void intel_psr2_program_plane_sel_fetch(struct intel_plane *plane,
* Unmerged path drivers/gpu/drm/i915/display/intel_psr.c
