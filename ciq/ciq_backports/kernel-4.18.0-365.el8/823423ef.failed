bdi: invert BDI_CAP_NO_ACCT_WB

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 823423ef55f4d9c470b1edc9c5b5c93d06abfaae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/823423ef.failed

Replace BDI_CAP_NO_ACCT_WB with a positive BDI_CAP_WRITEBACK_ACCT to
make the checks more obvious.  Also remove the pointless
bdi_cap_account_writeback wrapper that just obsfucates the check.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 823423ef55f4d9c470b1edc9c5b5c93d06abfaae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/backing-dev.h
diff --cc include/linux/backing-dev.h
index d0dea95dff96,b217344a2c63..000000000000
--- a/include/linux/backing-dev.h
+++ b/include/linux/backing-dev.h
@@@ -120,22 -120,17 +120,26 @@@ int bdi_set_max_ratio(struct backing_de
   *
   * BDI_CAP_NO_ACCT_DIRTY:  Dirty pages shouldn't contribute to accounting
   * BDI_CAP_NO_WRITEBACK:   Don't write pages back
-  * BDI_CAP_NO_ACCT_WB:     Don't automatically account writeback pages
+  * BDI_CAP_WRITEBACK_ACCT: Automatically account writeback pages
   * BDI_CAP_STRICTLIMIT:    Keep number of dirty pages below bdi threshold.
 + *
 + * BDI_CAP_SYNCHRONOUS_IO: Device is so fast that asynchronous IO would be
 + *			   inefficient.
   */
  #define BDI_CAP_NO_ACCT_DIRTY	0x00000001
  #define BDI_CAP_NO_WRITEBACK	0x00000002
++<<<<<<< HEAD
 +#define BDI_CAP_NO_ACCT_WB	0x00000004
 +#define BDI_CAP_STABLE_WRITES	0x00000008
++=======
+ #define BDI_CAP_WRITEBACK_ACCT	0x00000004
++>>>>>>> 823423ef55f4 (bdi: invert BDI_CAP_NO_ACCT_WB)
  #define BDI_CAP_STRICTLIMIT	0x00000010
  #define BDI_CAP_CGROUP_WRITEBACK 0x00000020
 +#define BDI_CAP_SYNCHRONOUS_IO	0x00000040
  
  #define BDI_CAP_NO_ACCT_AND_WRITEBACK \
- 	(BDI_CAP_NO_WRITEBACK | BDI_CAP_NO_ACCT_DIRTY | BDI_CAP_NO_ACCT_WB)
+ 	(BDI_CAP_NO_WRITEBACK | BDI_CAP_NO_ACCT_DIRTY)
  
  extern struct backing_dev_info noop_backing_dev_info;
  
diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c
index b9f3653ce806..7d5d93170684 100644
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@ -1154,7 +1154,8 @@ static int fuse_bdi_init(struct fuse_conn *fc, struct super_block *sb)
 		return err;
 
 	/* fuse does it's own writeback accounting */
-	sb->s_bdi->capabilities = BDI_CAP_NO_ACCT_WB | BDI_CAP_STRICTLIMIT;
+	sb->s_bdi->capabilities &= ~BDI_CAP_WRITEBACK_ACCT;
+	sb->s_bdi->capabilities |= BDI_CAP_STRICTLIMIT;
 
 	/*
 	 * For a single fuse filesystem use max 1% of dirty +
* Unmerged path include/linux/backing-dev.h
diff --git a/mm/backing-dev.c b/mm/backing-dev.c
index 38a0dae72f1f..257abe07a2c0 100644
--- a/mm/backing-dev.c
+++ b/mm/backing-dev.c
@@ -904,6 +904,7 @@ struct backing_dev_info *bdi_alloc(int node_id)
 		kfree(bdi);
 		return NULL;
 	}
+	bdi->capabilities = BDI_CAP_WRITEBACK_ACCT;
 	bdi->ra_pages = VM_READAHEAD_PAGES;
 	bdi->io_pages = VM_READAHEAD_PAGES;
 	return bdi;
diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index ad83d12ad7d6..e9925df99ec3 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -2744,7 +2744,7 @@ int test_clear_page_writeback(struct page *page)
 		if (ret) {
 			__xa_clear_mark(&mapping->i_pages, page_index(page),
 						PAGECACHE_TAG_WRITEBACK);
-			if (bdi_cap_account_writeback(bdi)) {
+			if (bdi->capabilities & BDI_CAP_WRITEBACK_ACCT) {
 				struct bdi_writeback *wb = inode_to_wb(inode);
 
 				dec_wb_stat(wb, WB_WRITEBACK);
@@ -2791,7 +2791,7 @@ int __test_set_page_writeback(struct page *page, bool keep_write)
 						   PAGECACHE_TAG_WRITEBACK);
 
 			xas_set_mark(&xas, PAGECACHE_TAG_WRITEBACK);
-			if (bdi_cap_account_writeback(bdi))
+			if (bdi->capabilities & BDI_CAP_WRITEBACK_ACCT)
 				inc_wb_stat(inode_to_wb(inode), WB_WRITEBACK);
 
 			/*
