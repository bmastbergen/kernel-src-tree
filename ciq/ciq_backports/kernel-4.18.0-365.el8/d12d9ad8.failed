kasan, mm: optimize krealloc poisoning

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Andrey Konovalov <andreyknvl@google.com>
commit d12d9ad816299052385bac351fad338a073121b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/d12d9ad8.failed

Currently, krealloc() always calls ksize(), which unpoisons the whole
object including the redzone.  This is inefficient, as kasan_krealloc()
repoisons the redzone for objects that fit into the same buffer.

This patch changes krealloc() instrumentation to use uninstrumented
__ksize() that doesn't unpoison the memory.  Instead, kasan_kreallos() is
changed to unpoison the memory excluding the redzone.

For objects that don't fit into the old allocation, this patch disables
KASAN accessibility checks when copying memory into a new object instead
of unpoisoning it.

Link: https://lkml.kernel.org/r/9bef90327c9cb109d736c40115684fd32f49e6b0.1612546384.git.andreyknvl@google.com
	Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
	Reviewed-by: Marco Elver <elver@google.com>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Branislav Rankov <Branislav.Rankov@arm.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Evgenii Stepanov <eugenis@google.com>
	Cc: Kevin Brodsky <kevin.brodsky@arm.com>
	Cc: Peter Collingbourne <pcc@google.com>
	Cc: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit d12d9ad816299052385bac351fad338a073121b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/kasan/common.c
#	mm/slab_common.c
diff --cc mm/kasan/common.c
index 0d0cb20ec1a4,1e510649833b..000000000000
--- a/mm/kasan/common.c
+++ b/mm/kasan/common.c
@@@ -463,42 -471,50 +463,62 @@@ static void *__kasan_kmalloc(struct kme
  	if (unlikely(object == NULL))
  		return NULL;
  
++<<<<<<< HEAD
++=======
+ 	if (is_kfence_address(kasan_reset_tag(object)))
+ 		return (void *)object;
+ 
+ 	/*
+ 	 * The object has already been unpoisoned by kasan_slab_alloc() for
+ 	 * kmalloc() or by kasan_krealloc() for krealloc().
+ 	 */
+ 
+ 	/*
+ 	 * The redzone has byte-level precision for the generic mode.
+ 	 * Partially poison the last object granule to cover the unaligned
+ 	 * part of the redzone.
+ 	 */
+ 	if (IS_ENABLED(CONFIG_KASAN_GENERIC))
+ 		kasan_poison_last_granule((void *)object, size);
+ 
+ 	/* Poison the aligned part of the redzone. */
++>>>>>>> d12d9ad81629 (kasan, mm: optimize krealloc poisoning)
  	redzone_start = round_up((unsigned long)(object + size),
 -				KASAN_GRANULE_SIZE);
 -	redzone_end = (unsigned long)object + cache->object_size;
 -	kasan_poison((void *)redzone_start, redzone_end - redzone_start,
 -			   KASAN_KMALLOC_REDZONE);
 +				KASAN_SHADOW_SCALE_SIZE);
 +	redzone_end = round_up((unsigned long)object + cache->object_size,
 +				KASAN_SHADOW_SCALE_SIZE);
  
 -	/*
 -	 * Save alloc info (if possible) for kmalloc() allocations.
 -	 * This also rewrites the alloc info when called from kasan_krealloc().
 -	 */
 -	if (kasan_stack_collection_enabled())
 -		set_alloc_info(cache, (void *)object, flags, true);
 +	if (IS_ENABLED(CONFIG_KASAN_SW_TAGS))
 +		tag = assign_tag(cache, object, false, keep_tag);
  
 -	/* Keep the tag that was set by kasan_slab_alloc(). */
 -	return (void *)object;
 +	/* Tag is ignored in set_tag without CONFIG_KASAN_SW_TAGS */
 +	kasan_unpoison_shadow(set_tag(object, tag), size);
 +	kasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,
 +		KASAN_KMALLOC_REDZONE);
 +
 +	if (cache->flags & SLAB_KASAN)
 +		kasan_set_track(&get_alloc_info(cache, object)->alloc_track, flags);
 +
 +	return set_tag(object, tag);
 +}
 +
 +void * __must_check kasan_slab_alloc(struct kmem_cache *cache, void *object,
 +					gfp_t flags)
 +{
 +	return __kasan_kmalloc(cache, object, cache->object_size, flags, false);
  }
  
 -void * __must_check __kasan_kmalloc(struct kmem_cache *cache, const void *object,
 -					size_t size, gfp_t flags)
 +void * __must_check kasan_kmalloc(struct kmem_cache *cache, const void *object,
 +				size_t size, gfp_t flags)
  {
 -	return ____kasan_kmalloc(cache, object, size, flags);
 +	return __kasan_kmalloc(cache, object, size, flags, true);
  }
 -EXPORT_SYMBOL(__kasan_kmalloc);
 +EXPORT_SYMBOL(kasan_kmalloc);
  
 -void * __must_check __kasan_kmalloc_large(const void *ptr, size_t size,
 +void * __must_check kasan_kmalloc_large(const void *ptr, size_t size,
  						gfp_t flags)
  {
 +	struct page *page;
  	unsigned long redzone_start;
  	unsigned long redzone_end;
  
@@@ -508,14 -524,25 +528,31 @@@
  	if (unlikely(ptr == NULL))
  		return NULL;
  
++<<<<<<< HEAD
 +	page = virt_to_page(ptr);
++=======
+ 	/*
+ 	 * The object has already been unpoisoned by kasan_alloc_pages() for
+ 	 * alloc_pages() or by kasan_krealloc() for krealloc().
+ 	 */
+ 
+ 	/*
+ 	 * The redzone has byte-level precision for the generic mode.
+ 	 * Partially poison the last object granule to cover the unaligned
+ 	 * part of the redzone.
+ 	 */
+ 	if (IS_ENABLED(CONFIG_KASAN_GENERIC))
+ 		kasan_poison_last_granule(ptr, size);
+ 
+ 	/* Poison the aligned part of the redzone. */
++>>>>>>> d12d9ad81629 (kasan, mm: optimize krealloc poisoning)
  	redzone_start = round_up((unsigned long)(ptr + size),
 -				KASAN_GRANULE_SIZE);
 -	redzone_end = (unsigned long)ptr + page_size(virt_to_page(ptr));
 -	kasan_poison((void *)redzone_start, redzone_end - redzone_start,
 -		     KASAN_PAGE_REDZONE);
 +				KASAN_SHADOW_SCALE_SIZE);
 +	redzone_end = (unsigned long)ptr + page_size(page);
 +
 +	kasan_unpoison_shadow(ptr, size);
 +	kasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,
 +		KASAN_PAGE_REDZONE);
  
  	return (void *)ptr;
  }
@@@ -527,442 -554,27 +564,450 @@@ void * __must_check kasan_krealloc(cons
  	if (unlikely(object == ZERO_SIZE_PTR))
  		return (void *)object;
  
+ 	/*
+ 	 * Unpoison the object's data.
+ 	 * Part of it might already have been unpoisoned, but it's unknown
+ 	 * how big that part is.
+ 	 */
+ 	kasan_unpoison(object, size);
+ 
  	page = virt_to_head_page(object);
  
+ 	/* Piggy-back on kmalloc() instrumentation to poison the redzone. */
  	if (unlikely(!PageSlab(page)))
 -		return __kasan_kmalloc_large(object, size, flags);
 +		return kasan_kmalloc_large(object, size, flags);
  	else
 -		return ____kasan_kmalloc(page->slab_cache, object, size, flags);
 +		return __kasan_kmalloc(page->slab_cache, object, size,
 +						flags, true);
  }
  
 -bool __kasan_check_byte(const void *address, unsigned long ip)
 +void kasan_poison_kfree(void *ptr, unsigned long ip)
  {
 -	if (!kasan_byte_accessible(address)) {
 -		kasan_report((unsigned long)address, 1, false, ip);
 +	struct page *page;
 +
 +	page = virt_to_head_page(ptr);
 +
 +	if (unlikely(!PageSlab(page))) {
 +		if (ptr != page_address(page)) {
 +			kasan_report_invalid_free(ptr, ip);
 +			return;
 +		}
 +		kasan_poison_shadow(ptr, page_size(page), KASAN_FREE_PAGE);
 +	} else {
 +		__kasan_slab_free(page->slab_cache, ptr, ip, false);
 +	}
 +}
 +
 +void kasan_kfree_large(void *ptr, unsigned long ip)
 +{
 +	if (ptr != page_address(virt_to_head_page(ptr)))
 +		kasan_report_invalid_free(ptr, ip);
 +	/* The object will be poisoned by kasan_free_pages(). */
 +}
 +
 +#ifndef CONFIG_KASAN_VMALLOC
 +int kasan_module_alloc(void *addr, size_t size)
 +{
 +	void *ret;
 +	size_t scaled_size;
 +	size_t shadow_size;
 +	unsigned long shadow_start;
 +
 +	shadow_start = (unsigned long)kasan_mem_to_shadow(addr);
 +	scaled_size = (size + KASAN_SHADOW_MASK) >> KASAN_SHADOW_SCALE_SHIFT;
 +	shadow_size = round_up(scaled_size, PAGE_SIZE);
 +
 +	if (WARN_ON(!PAGE_ALIGNED(shadow_start)))
 +		return -EINVAL;
 +
 +	ret = __vmalloc_node_range(shadow_size, 1, shadow_start,
 +			shadow_start + shadow_size,
 +			GFP_KERNEL,
 +			PAGE_KERNEL, VM_NO_GUARD, NUMA_NO_NODE,
 +			__builtin_return_address(0));
 +
 +	if (ret) {
 +		__memset(ret, KASAN_SHADOW_INIT, shadow_size);
 +		find_vm_area(addr)->flags |= VM_KASAN;
 +		kmemleak_ignore(ret);
 +		return 0;
 +	}
 +
 +	return -ENOMEM;
 +}
 +
 +void kasan_free_shadow(const struct vm_struct *vm)
 +{
 +	if (vm->flags & VM_KASAN)
 +		vfree(kasan_mem_to_shadow(vm->addr));
 +}
 +#endif
 +
 +extern void __kasan_report(unsigned long addr, size_t size, bool is_write, unsigned long ip);
 +extern bool report_enabled(void);
 +
 +bool kasan_report(unsigned long addr, size_t size, bool is_write, unsigned long ip)
 +{
 +	unsigned long flags = user_access_save();
 +	bool ret = false;
 +
 +	if (likely(report_enabled())) {
 +		__kasan_report(addr, size, is_write, ip);
 +		ret = true;
 +	}
 +
 +	user_access_restore(flags);
 +
 +	return ret;
 +}
 +
 +#ifdef CONFIG_MEMORY_HOTPLUG
 +static bool shadow_mapped(unsigned long addr)
 +{
 +	pgd_t *pgd = pgd_offset_k(addr);
 +	p4d_t *p4d;
 +	pud_t *pud;
 +	pmd_t *pmd;
 +	pte_t *pte;
 +
 +	if (pgd_none(*pgd))
 +		return false;
 +	p4d = p4d_offset(pgd, addr);
 +	if (p4d_none(*p4d))
 +		return false;
 +	pud = pud_offset(p4d, addr);
 +	if (pud_none(*pud))
  		return false;
 +
 +	/*
 +	 * We can't use pud_large() or pud_huge(), the first one is
 +	 * arch-specific, the last one depends on HUGETLB_PAGE.  So let's abuse
 +	 * pud_bad(), if pud is bad then it's bad because it's huge.
 +	 */
 +	if (pud_bad(*pud))
 +		return true;
 +	pmd = pmd_offset(pud, addr);
 +	if (pmd_none(*pmd))
 +		return false;
 +
 +	if (pmd_bad(*pmd))
 +		return true;
 +	pte = pte_offset_kernel(pmd, addr);
 +	return !pte_none(*pte);
 +}
 +
 +static int __meminit kasan_mem_notifier(struct notifier_block *nb,
 +			unsigned long action, void *data)
 +{
 +	struct memory_notify *mem_data = data;
 +	unsigned long nr_shadow_pages, start_kaddr, shadow_start;
 +	unsigned long shadow_end, shadow_size;
 +
 +	nr_shadow_pages = mem_data->nr_pages >> KASAN_SHADOW_SCALE_SHIFT;
 +	start_kaddr = (unsigned long)pfn_to_kaddr(mem_data->start_pfn);
 +	shadow_start = (unsigned long)kasan_mem_to_shadow((void *)start_kaddr);
 +	shadow_size = nr_shadow_pages << PAGE_SHIFT;
 +	shadow_end = shadow_start + shadow_size;
 +
 +	if (WARN_ON(mem_data->nr_pages % KASAN_SHADOW_SCALE_SIZE) ||
 +		WARN_ON(start_kaddr % (KASAN_SHADOW_SCALE_SIZE << PAGE_SHIFT)))
 +		return NOTIFY_BAD;
 +
 +	switch (action) {
 +	case MEM_GOING_ONLINE: {
 +		void *ret;
 +
 +		/*
 +		 * If shadow is mapped already than it must have been mapped
 +		 * during the boot. This could happen if we onlining previously
 +		 * offlined memory.
 +		 */
 +		if (shadow_mapped(shadow_start))
 +			return NOTIFY_OK;
 +
 +		ret = __vmalloc_node_range(shadow_size, PAGE_SIZE, shadow_start,
 +					shadow_end, GFP_KERNEL,
 +					PAGE_KERNEL, VM_NO_GUARD,
 +					pfn_to_nid(mem_data->start_pfn),
 +					__builtin_return_address(0));
 +		if (!ret)
 +			return NOTIFY_BAD;
 +
 +		kmemleak_ignore(ret);
 +		return NOTIFY_OK;
 +	}
 +	case MEM_CANCEL_ONLINE:
 +	case MEM_OFFLINE: {
 +		struct vm_struct *vm;
 +
 +		/*
 +		 * shadow_start was either mapped during boot by kasan_init()
 +		 * or during memory online by __vmalloc_node_range().
 +		 * In the latter case we can use vfree() to free shadow.
 +		 * Non-NULL result of the find_vm_area() will tell us if
 +		 * that was the second case.
 +		 *
 +		 * Currently it's not possible to free shadow mapped
 +		 * during boot by kasan_init(). It's because the code
 +		 * to do that hasn't been written yet. So we'll just
 +		 * leak the memory.
 +		 */
 +		vm = find_vm_area((void *)shadow_start);
 +		if (vm)
 +			vfree((void *)shadow_start);
 +	}
 +	}
 +
 +	return NOTIFY_OK;
 +}
 +
 +static int __init kasan_memhotplug_init(void)
 +{
 +	hotplug_memory_notifier(kasan_mem_notifier, 0);
 +
 +	return 0;
 +}
 +
 +core_initcall(kasan_memhotplug_init);
 +#endif
 +
 +#ifdef CONFIG_KASAN_VMALLOC
 +static int kasan_populate_vmalloc_pte(pte_t *ptep, unsigned long addr,
 +				      void *unused)
 +{
 +	unsigned long page;
 +	pte_t pte;
 +
 +	if (likely(!pte_none(*ptep)))
 +		return 0;
 +
 +	page = __get_free_page(GFP_KERNEL);
 +	if (!page)
 +		return -ENOMEM;
 +
 +	memset((void *)page, KASAN_VMALLOC_INVALID, PAGE_SIZE);
 +	pte = pfn_pte(PFN_DOWN(__pa(page)), PAGE_KERNEL);
 +
 +	spin_lock(&init_mm.page_table_lock);
 +	if (likely(pte_none(*ptep))) {
 +		set_pte_at(&init_mm, addr, ptep, pte);
 +		page = 0;
 +	}
 +	spin_unlock(&init_mm.page_table_lock);
 +	if (page)
 +		free_page(page);
 +	return 0;
 +}
 +
 +int kasan_populate_vmalloc(unsigned long addr, unsigned long size)
 +{
 +	unsigned long shadow_start, shadow_end;
 +	int ret;
 +
 +	if (!is_vmalloc_or_module_addr((void *)addr))
 +		return 0;
 +
 +	shadow_start = (unsigned long)kasan_mem_to_shadow((void *)addr);
 +	shadow_start = ALIGN_DOWN(shadow_start, PAGE_SIZE);
 +	shadow_end = (unsigned long)kasan_mem_to_shadow((void *)addr + size);
 +	shadow_end = ALIGN(shadow_end, PAGE_SIZE);
 +
 +	ret = apply_to_page_range(&init_mm, shadow_start,
 +				  shadow_end - shadow_start,
 +				  kasan_populate_vmalloc_pte, NULL);
 +	if (ret)
 +		return ret;
 +
 +	flush_cache_vmap(shadow_start, shadow_end);
 +
 +	/*
 +	 * We need to be careful about inter-cpu effects here. Consider:
 +	 *
 +	 *   CPU#0				  CPU#1
 +	 * WRITE_ONCE(p, vmalloc(100));		while (x = READ_ONCE(p)) ;
 +	 *					p[99] = 1;
 +	 *
 +	 * With compiler instrumentation, that ends up looking like this:
 +	 *
 +	 *   CPU#0				  CPU#1
 +	 * // vmalloc() allocates memory
 +	 * // let a = area->addr
 +	 * // we reach kasan_populate_vmalloc
 +	 * // and call kasan_unpoison_shadow:
 +	 * STORE shadow(a), unpoison_val
 +	 * ...
 +	 * STORE shadow(a+99), unpoison_val	x = LOAD p
 +	 * // rest of vmalloc process		<data dependency>
 +	 * STORE p, a				LOAD shadow(x+99)
 +	 *
 +	 * If there is no barrier between the end of unpoisioning the shadow
 +	 * and the store of the result to p, the stores could be committed
 +	 * in a different order by CPU#0, and CPU#1 could erroneously observe
 +	 * poison in the shadow.
 +	 *
 +	 * We need some sort of barrier between the stores.
 +	 *
 +	 * In the vmalloc() case, this is provided by a smp_wmb() in
 +	 * clear_vm_uninitialized_flag(). In the per-cpu allocator and in
 +	 * get_vm_area() and friends, the caller gets shadow allocated but
 +	 * doesn't have any pages mapped into the virtual address space that
 +	 * has been reserved. Mapping those pages in will involve taking and
 +	 * releasing a page-table lock, which will provide the barrier.
 +	 */
 +
 +	return 0;
 +}
 +
 +/*
 + * Poison the shadow for a vmalloc region. Called as part of the
 + * freeing process at the time the region is freed.
 + */
 +void kasan_poison_vmalloc(const void *start, unsigned long size)
 +{
 +	if (!is_vmalloc_or_module_addr(start))
 +		return;
 +
 +	size = round_up(size, KASAN_SHADOW_SCALE_SIZE);
 +	kasan_poison_shadow(start, size, KASAN_VMALLOC_INVALID);
 +}
 +
 +void kasan_unpoison_vmalloc(const void *start, unsigned long size)
 +{
 +	if (!is_vmalloc_or_module_addr(start))
 +		return;
 +
 +	kasan_unpoison_shadow(start, size);
 +}
 +
 +static int kasan_depopulate_vmalloc_pte(pte_t *ptep, unsigned long addr,
 +					void *unused)
 +{
 +	unsigned long page;
 +
 +	page = (unsigned long)__va(pte_pfn(*ptep) << PAGE_SHIFT);
 +
 +	spin_lock(&init_mm.page_table_lock);
 +
 +	if (likely(!pte_none(*ptep))) {
 +		pte_clear(&init_mm, addr, ptep);
 +		free_page(page);
  	}
 -	return true;
 +	spin_unlock(&init_mm.page_table_lock);
 +
 +	return 0;
  }
 +
 +/*
 + * Release the backing for the vmalloc region [start, end), which
 + * lies within the free region [free_region_start, free_region_end).
 + *
 + * This can be run lazily, long after the region was freed. It runs
 + * under vmap_area_lock, so it's not safe to interact with the vmalloc/vmap
 + * infrastructure.
 + *
 + * How does this work?
 + * -------------------
 + *
 + * We have a region that is page aligned, labelled as A.
 + * That might not map onto the shadow in a way that is page-aligned:
 + *
 + *                    start                     end
 + *                    v                         v
 + * |????????|????????|AAAAAAAA|AA....AA|AAAAAAAA|????????| < vmalloc
 + *  -------- -------- --------          -------- --------
 + *      |        |       |                 |        |
 + *      |        |       |         /-------/        |
 + *      \-------\|/------/         |/---------------/
 + *              |||                ||
 + *             |??AAAAAA|AAAAAAAA|AA??????|                < shadow
 + *                 (1)      (2)      (3)
 + *
 + * First we align the start upwards and the end downwards, so that the
 + * shadow of the region aligns with shadow page boundaries. In the
 + * example, this gives us the shadow page (2). This is the shadow entirely
 + * covered by this allocation.
 + *
 + * Then we have the tricky bits. We want to know if we can free the
 + * partially covered shadow pages - (1) and (3) in the example. For this,
 + * we are given the start and end of the free region that contains this
 + * allocation. Extending our previous example, we could have:
 + *
 + *  free_region_start                                    free_region_end
 + *  |                 start                     end      |
 + *  v                 v                         v        v
 + * |FFFFFFFF|FFFFFFFF|AAAAAAAA|AA....AA|AAAAAAAA|FFFFFFFF| < vmalloc
 + *  -------- -------- --------          -------- --------
 + *      |        |       |                 |        |
 + *      |        |       |         /-------/        |
 + *      \-------\|/------/         |/---------------/
 + *              |||                ||
 + *             |FFAAAAAA|AAAAAAAA|AAF?????|                < shadow
 + *                 (1)      (2)      (3)
 + *
 + * Once again, we align the start of the free region up, and the end of
 + * the free region down so that the shadow is page aligned. So we can free
 + * page (1) - we know no allocation currently uses anything in that page,
 + * because all of it is in the vmalloc free region. But we cannot free
 + * page (3), because we can't be sure that the rest of it is unused.
 + *
 + * We only consider pages that contain part of the original region for
 + * freeing: we don't try to free other pages from the free region or we'd
 + * end up trying to free huge chunks of virtual address space.
 + *
 + * Concurrency
 + * -----------
 + *
 + * How do we know that we're not freeing a page that is simultaneously
 + * being used for a fresh allocation in kasan_populate_vmalloc(_pte)?
 + *
 + * We _can_ have kasan_release_vmalloc and kasan_populate_vmalloc running
 + * at the same time. While we run under free_vmap_area_lock, the population
 + * code does not.
 + *
 + * free_vmap_area_lock instead operates to ensure that the larger range
 + * [free_region_start, free_region_end) is safe: because __alloc_vmap_area and
 + * the per-cpu region-finding algorithm both run under free_vmap_area_lock,
 + * no space identified as free will become used while we are running. This
 + * means that so long as we are careful with alignment and only free shadow
 + * pages entirely covered by the free region, we will not run in to any
 + * trouble - any simultaneous allocations will be for disjoint regions.
 + */
 +void kasan_release_vmalloc(unsigned long start, unsigned long end,
 +			   unsigned long free_region_start,
 +			   unsigned long free_region_end)
 +{
 +	void *shadow_start, *shadow_end;
 +	unsigned long region_start, region_end;
 +	unsigned long size;
 +
 +	region_start = ALIGN(start, PAGE_SIZE * KASAN_SHADOW_SCALE_SIZE);
 +	region_end = ALIGN_DOWN(end, PAGE_SIZE * KASAN_SHADOW_SCALE_SIZE);
 +
 +	free_region_start = ALIGN(free_region_start,
 +				  PAGE_SIZE * KASAN_SHADOW_SCALE_SIZE);
 +
 +	if (start != region_start &&
 +	    free_region_start < region_start)
 +		region_start -= PAGE_SIZE * KASAN_SHADOW_SCALE_SIZE;
 +
 +	free_region_end = ALIGN_DOWN(free_region_end,
 +				     PAGE_SIZE * KASAN_SHADOW_SCALE_SIZE);
 +
 +	if (end != region_end &&
 +	    free_region_end > region_end)
 +		region_end += PAGE_SIZE * KASAN_SHADOW_SCALE_SIZE;
 +
 +	shadow_start = kasan_mem_to_shadow((void *)region_start);
 +	shadow_end = kasan_mem_to_shadow((void *)region_end);
 +
 +	if (shadow_end > shadow_start) {
 +		size = shadow_end - shadow_start;
 +		apply_to_existing_page_range(&init_mm,
 +					     (unsigned long)shadow_start,
 +					     size, kasan_depopulate_vmalloc_pte,
 +					     NULL);
 +		flush_tlb_kernel_range((unsigned long)shadow_start,
 +				       (unsigned long)shadow_end);
 +	}
 +}
 +#endif
diff --cc mm/slab_common.c
index b485099f723a,88e833986332..000000000000
--- a/mm/slab_common.c
+++ b/mm/slab_common.c
@@@ -1173,8 -1136,15 +1173,19 @@@ static __always_inline void *__do_kreal
  	void *ret;
  	size_t ks;
  
++<<<<<<< HEAD
 +	ks = ksize(p);
++=======
+ 	/* Don't use instrumented ksize to allow precise KASAN poisoning. */
+ 	if (likely(!ZERO_OR_NULL_PTR(p))) {
+ 		if (!kasan_check_byte(p))
+ 			return NULL;
+ 		ks = kfence_ksize(p) ?: __ksize(p);
+ 	} else
+ 		ks = 0;
++>>>>>>> d12d9ad81629 (kasan, mm: optimize krealloc poisoning)
  
+ 	/* If the object still fits, repoison it precisely. */
  	if (ks >= new_size) {
  		p = kasan_krealloc((void *)p, new_size, flags);
  		return (void *)p;
* Unmerged path mm/kasan/common.c
* Unmerged path mm/slab_common.c
