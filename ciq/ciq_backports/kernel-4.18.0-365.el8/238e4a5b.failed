media: rename VFL_TYPE_GRABBER to _VIDEO

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Hans Verkuil <hverkuil-cisco@xs4all.nl>
commit 238e4a5baa361256ae1641ad9455bb2bb359273f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/238e4a5b.failed

We currently have the following devnode types:

enum vfl_devnode_type {
        VFL_TYPE_GRABBER        = 0,
        VFL_TYPE_VBI,
        VFL_TYPE_RADIO,
        VFL_TYPE_SUBDEV,
        VFL_TYPE_SDR,
        VFL_TYPE_TOUCH,
        VFL_TYPE_MAX /* Shall be the last one */
};

They all make sense, except for the first: GRABBER really refers to /dev/videoX
devices, which can be capture, output or m2m, so 'grabber' doesn't even refer to
their function anymore.

Let's call a spade a spade and rename this to VFL_TYPE_VIDEO.

	Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
	Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
	Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
(cherry picked from commit 238e4a5baa361256ae1641ad9455bb2bb359273f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/v4l2-core/v4l2-dev.c
#	drivers/media/v4l2-core/v4l2-ioctl.c
diff --cc drivers/media/v4l2-core/v4l2-dev.c
index 55196d3a9a03,97b6a3af1361..000000000000
--- a/drivers/media/v4l2-core/v4l2-dev.c
+++ b/drivers/media/v4l2-core/v4l2-dev.c
@@@ -523,13 -533,23 +523,23 @@@ static int get_index(struct video_devic
   */
  static void determine_valid_ioctls(struct video_device *vdev)
  {
 -	const u32 vid_caps = V4L2_CAP_VIDEO_CAPTURE |
 -			     V4L2_CAP_VIDEO_CAPTURE_MPLANE |
 -			     V4L2_CAP_VIDEO_OUTPUT |
 -			     V4L2_CAP_VIDEO_OUTPUT_MPLANE |
 -			     V4L2_CAP_VIDEO_M2M | V4L2_CAP_VIDEO_M2M_MPLANE;
 -	const u32 meta_caps = V4L2_CAP_META_CAPTURE |
 -			      V4L2_CAP_META_OUTPUT;
  	DECLARE_BITMAP(valid_ioctls, BASE_VIDIOC_PRIVATE);
  	const struct v4l2_ioctl_ops *ops = vdev->ioctl_ops;
++<<<<<<< HEAD
 +	bool is_vid = vdev->vfl_type == VFL_TYPE_GRABBER;
++=======
+ 	bool is_vid = vdev->vfl_type == VFL_TYPE_VIDEO &&
+ 		      (vdev->device_caps & vid_caps);
++>>>>>>> 238e4a5baa36 (media: rename VFL_TYPE_GRABBER to _VIDEO)
  	bool is_vbi = vdev->vfl_type == VFL_TYPE_VBI;
  	bool is_radio = vdev->vfl_type == VFL_TYPE_RADIO;
  	bool is_sdr = vdev->vfl_type == VFL_TYPE_SDR;
  	bool is_tch = vdev->vfl_type == VFL_TYPE_TOUCH;
++<<<<<<< HEAD
++=======
+ 	bool is_meta = vdev->vfl_type == VFL_TYPE_VIDEO &&
+ 		       (vdev->device_caps & meta_caps);
++>>>>>>> 238e4a5baa36 (media: rename VFL_TYPE_GRABBER to _VIDEO)
  	bool is_rx = vdev->vfl_dir != VFL_DIR_TX;
  	bool is_tx = vdev->vfl_dir != VFL_DIR_RX;
  
@@@ -749,8 -782,8 +759,13 @@@ static int video_register_media_control
  	vdev->entity.obj_type = MEDIA_ENTITY_TYPE_VIDEO_DEVICE;
  	vdev->entity.function = MEDIA_ENT_F_UNKNOWN;
  
++<<<<<<< HEAD
 +	switch (type) {
 +	case VFL_TYPE_GRABBER:
++=======
+ 	switch (vdev->vfl_type) {
+ 	case VFL_TYPE_VIDEO:
++>>>>>>> 238e4a5baa36 (media: rename VFL_TYPE_GRABBER to _VIDEO)
  		intf_type = MEDIA_INTF_T_V4L_VIDEO;
  		vdev->entity.function = MEDIA_ENT_F_IO_V4L;
  		break;
diff --cc drivers/media/v4l2-core/v4l2-ioctl.c
index 110c55b528d1,fbcc7a20eedf..000000000000
--- a/drivers/media/v4l2-core/v4l2-ioctl.c
+++ b/drivers/media/v4l2-core/v4l2-ioctl.c
@@@ -897,12 -932,22 +897,22 @@@ static int check_ext_ctrls(struct v4l2_
  
  static int check_fmt(struct file *file, enum v4l2_buf_type type)
  {
 -	const u32 vid_caps = V4L2_CAP_VIDEO_CAPTURE |
 -			     V4L2_CAP_VIDEO_CAPTURE_MPLANE |
 -			     V4L2_CAP_VIDEO_OUTPUT |
 -			     V4L2_CAP_VIDEO_OUTPUT_MPLANE |
 -			     V4L2_CAP_VIDEO_M2M | V4L2_CAP_VIDEO_M2M_MPLANE;
 -	const u32 meta_caps = V4L2_CAP_META_CAPTURE |
 -			      V4L2_CAP_META_OUTPUT;
  	struct video_device *vfd = video_devdata(file);
  	const struct v4l2_ioctl_ops *ops = vfd->ioctl_ops;
++<<<<<<< HEAD
 +	bool is_vid = vfd->vfl_type == VFL_TYPE_GRABBER;
 +	bool is_vbi = vfd->vfl_type == VFL_TYPE_VBI;
 +	bool is_sdr = vfd->vfl_type == VFL_TYPE_SDR;
 +	bool is_tch = vfd->vfl_type == VFL_TYPE_TOUCH;
++=======
+ 	bool is_vid = vfd->vfl_type == VFL_TYPE_VIDEO &&
+ 		      (vfd->device_caps & vid_caps);
+ 	bool is_vbi = vfd->vfl_type == VFL_TYPE_VBI;
+ 	bool is_sdr = vfd->vfl_type == VFL_TYPE_SDR;
+ 	bool is_tch = vfd->vfl_type == VFL_TYPE_TOUCH;
+ 	bool is_meta = vfd->vfl_type == VFL_TYPE_VIDEO &&
+ 		       (vfd->device_caps & meta_caps);
++>>>>>>> 238e4a5baa36 (media: rename VFL_TYPE_GRABBER to _VIDEO)
  	bool is_rx = vfd->vfl_dir != VFL_DIR_TX;
  	bool is_tx = vfd->vfl_dir != VFL_DIR_RX;
  
diff --git a/Documentation/media/kapi/v4l2-dev.rst b/Documentation/media/kapi/v4l2-dev.rst
index eb03ccc41c41..8093e3621891 100644
--- a/Documentation/media/kapi/v4l2-dev.rst
+++ b/Documentation/media/kapi/v4l2-dev.rst
@@ -183,7 +183,7 @@ This will create the character device for you.
 
 .. code-block:: c
 
-	err = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+	err = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
 	if (err) {
 		video_device_release(vdev); /* or kfree(my_vdev); */
 		return err;
@@ -199,7 +199,7 @@ types exist:
 ========================== ====================	 ==============================
 :c:type:`vfl_devnode_type` Device name		 Usage
 ========================== ====================	 ==============================
-``VFL_TYPE_GRABBER``       ``/dev/videoX``       for video input/output devices
+``VFL_TYPE_VIDEO``         ``/dev/videoX``       for video input/output devices
 ``VFL_TYPE_VBI``           ``/dev/vbiX``         for vertical blank data (i.e.
 						 closed captions, teletext)
 ``VFL_TYPE_RADIO``         ``/dev/radioX``       for radio tuners
diff --git a/Documentation/translations/zh_CN/video4linux/v4l2-framework.txt b/Documentation/translations/zh_CN/video4linux/v4l2-framework.txt
index 66c7c568bd86..9c39ee58ea50 100644
--- a/Documentation/translations/zh_CN/video4linux/v4l2-framework.txt
+++ b/Documentation/translations/zh_CN/video4linux/v4l2-framework.txt
@@ -649,7 +649,7 @@ video_device注册
 
 接下来你需要注册视频设备：这会为你创建一个字符设备。
 
-	err = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+	err = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
 	if (err) {
 		video_device_release(vdev); /* or kfree(my_vdev); */
 		return err;
@@ -660,7 +660,7 @@ video_device注册
 
 注册哪种设备是根据类型（type）参数。存在以下类型：
 
-VFL_TYPE_GRABBER: 用于视频输入/输出设备的 videoX
+VFL_TYPE_VIDEO: 用于视频输入/输出设备的 videoX
 VFL_TYPE_VBI: 用于垂直消隐数据的 vbiX (例如，隐藏式字幕，图文电视)
 VFL_TYPE_RADIO: 用于广播调谐器的 radioX
 
* Unmerged path drivers/media/v4l2-core/v4l2-dev.c
* Unmerged path drivers/media/v4l2-core/v4l2-ioctl.c
diff --git a/include/media/v4l2-dev.h b/include/media/v4l2-dev.h
index 456ac13eca1d..4db9d65b5f42 100644
--- a/include/media/v4l2-dev.h
+++ b/include/media/v4l2-dev.h
@@ -24,7 +24,8 @@
 /**
  * enum vfl_devnode_type - type of V4L2 device node
  *
- * @VFL_TYPE_GRABBER:	for video input/output devices
+ * @VFL_TYPE_VIDEO:	for video input/output devices
+ * @VFL_TYPE_GRABBER:	deprecated, same as VFL_TYPE_VIDEO
  * @VFL_TYPE_VBI:	for vertical blank data (i.e. closed captions, teletext)
  * @VFL_TYPE_RADIO:	for radio tuners
  * @VFL_TYPE_SUBDEV:	for V4L2 subdevices
@@ -33,7 +34,8 @@
  * @VFL_TYPE_MAX:	number of VFL types, must always be last in the enum
  */
 enum vfl_devnode_type {
-	VFL_TYPE_GRABBER	= 0,
+	VFL_TYPE_VIDEO,
+	VFL_TYPE_GRABBER = VFL_TYPE_VIDEO,
 	VFL_TYPE_VBI,
 	VFL_TYPE_RADIO,
 	VFL_TYPE_SUBDEV,
diff --git a/samples/v4l/v4l2-pci-skeleton.c b/samples/v4l/v4l2-pci-skeleton.c
index f520e3aef9c6..30b28a303d11 100644
--- a/samples/v4l/v4l2-pci-skeleton.c
+++ b/samples/v4l/v4l2-pci-skeleton.c
@@ -877,7 +877,7 @@ static int skeleton_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	vdev->tvnorms = SKEL_TVNORMS;
 	video_set_drvdata(vdev, skel);
 
-	ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
 	if (ret)
 		goto free_hdl;
 
