xen/arm: introduce phys/dma translations in xen_dma_sync_for_*

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Stefano Stabellini <stefano.stabellini@xilinx.com>
commit 63f0620cc552c4cd5bb2747f77efce407487cb12
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/63f0620c.failed

xen_dma_sync_for_cpu, xen_dma_sync_for_device, xen_arch_need_swiotlb are
getting called passing dma addresses. On some platforms dma addresses
could be different from physical addresses. Before doing any operations
on these addresses we need to convert them back to physical addresses
using dma_to_phys.

Move the arch_sync_dma_for_cpu and arch_sync_dma_for_device calls from
xen_dma_sync_for_cpu/device to swiotlb-xen.c, and add a call dma_to_phys
to do address translations there.

dma_cache_maint is fixed by the next patch.

	Signed-off-by: Stefano Stabellini <stefano.stabellini@xilinx.com>
	Tested-by: Corey Minyard <cminyard@mvista.com>
	Tested-by: Roman Shaposhnik <roman@zededa.com>
	Acked-by: Juergen Gross <jgross@suse.com>
Link: https://lore.kernel.org/r/20200710223427.6897-10-sstabellini@kernel.org
	Signed-off-by: Juergen Gross <jgross@suse.com>
(cherry picked from commit 63f0620cc552c4cd5bb2747f77efce407487cb12)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/xen/mm.c
#	drivers/xen/swiotlb-xen.c
#	include/xen/swiotlb-xen.h
diff --cc arch/arm/xen/mm.c
index cb44aa290e73,a8251a70f442..000000000000
--- a/arch/arm/xen/mm.c
+++ b/arch/arm/xen/mm.c
@@@ -1,5 -1,7 +1,10 @@@
 -// SPDX-License-Identifier: GPL-2.0-only
  #include <linux/cpu.h>
++<<<<<<< HEAD
 +#include <linux/dma-mapping.h>
++=======
+ #include <linux/dma-direct.h>
+ #include <linux/dma-noncoherent.h>
++>>>>>>> 63f0620cc552 (xen/arm: introduce phys/dma translations in xen_dma_sync_for_*)
  #include <linux/gfp.h>
  #include <linux/highmem.h>
  #include <linux/export.h>
@@@ -35,105 -40,52 +40,129 @@@ unsigned long xen_get_swiotlb_free_page
  	return __get_free_pages(flags, order);
  }
  
 +enum dma_cache_op {
 +       DMA_UNMAP,
 +       DMA_MAP,
 +};
  static bool hypercall_cflush = false;
  
 -/* buffers in highmem or foreign pages cannot cross page boundaries */
 -static void dma_cache_maint(dma_addr_t handle, size_t size, u32 op)
 +/* functions called by SWIOTLB */
 +
 +static void dma_cache_maint(dma_addr_t handle, unsigned long offset,
 +	size_t size, enum dma_data_direction dir, enum dma_cache_op op)
  {
  	struct gnttab_cache_flush cflush;
 +	unsigned long xen_pfn;
 +	size_t left = size;
  
 -	cflush.a.dev_bus_addr = handle & XEN_PAGE_MASK;
 -	cflush.offset = xen_offset_in_page(handle);
 -	cflush.op = op;
 +	xen_pfn = (handle >> XEN_PAGE_SHIFT) + offset / XEN_PAGE_SIZE;
 +	offset %= XEN_PAGE_SIZE;
  
  	do {
 -		if (size + cflush.offset > XEN_PAGE_SIZE)
 -			cflush.length = XEN_PAGE_SIZE - cflush.offset;
 -		else
 -			cflush.length = size;
 +		size_t len = left;
 +	
 +		/* buffers in highmem or foreign pages cannot cross page
 +		 * boundaries */
 +		if (len + offset > XEN_PAGE_SIZE)
 +			len = XEN_PAGE_SIZE - offset;
 +
 +		cflush.op = 0;
 +		cflush.a.dev_bus_addr = xen_pfn << XEN_PAGE_SHIFT;
 +		cflush.offset = offset;
 +		cflush.length = len;
 +
 +		if (op == DMA_UNMAP && dir != DMA_TO_DEVICE)
 +			cflush.op = GNTTAB_CACHE_INVAL;
 +		if (op == DMA_MAP) {
 +			if (dir == DMA_FROM_DEVICE)
 +				cflush.op = GNTTAB_CACHE_INVAL;
 +			else
 +				cflush.op = GNTTAB_CACHE_CLEAN;
 +		}
 +		if (cflush.op)
 +			HYPERVISOR_grant_table_op(GNTTABOP_cache_flush, &cflush, 1);
 +
 +		offset = 0;
 +		xen_pfn++;
 +		left -= len;
 +	} while (left);
 +}
  
 -		HYPERVISOR_grant_table_op(GNTTABOP_cache_flush, &cflush, 1);
++<<<<<<< HEAD
 +static void __xen_dma_page_dev_to_cpu(struct device *hwdev, dma_addr_t handle,
 +		size_t size, enum dma_data_direction dir)
 +{
 +	dma_cache_maint(handle & PAGE_MASK, handle & ~PAGE_MASK, size, dir, DMA_UNMAP);
 +}
  
 -		cflush.offset = 0;
 -		cflush.a.dev_bus_addr += cflush.length;
 -		size -= cflush.length;
 -	} while (size);
 +static void __xen_dma_page_cpu_to_dev(struct device *hwdev, dma_addr_t handle,
 +		size_t size, enum dma_data_direction dir)
 +{
 +	dma_cache_maint(handle & PAGE_MASK, handle & ~PAGE_MASK, size, dir, DMA_MAP);
  }
  
 +void __xen_dma_map_page(struct device *hwdev, struct page *page,
 +	     dma_addr_t dev_addr, unsigned long offset, size_t size,
 +	     enum dma_data_direction dir, unsigned long attrs)
 +{
 +	if (is_device_dma_coherent(hwdev))
 +		return;
 +	if (attrs & DMA_ATTR_SKIP_CPU_SYNC)
 +		return;
 +
 +	__xen_dma_page_cpu_to_dev(hwdev, dev_addr, size, dir);
 +}
 +
 +void __xen_dma_unmap_page(struct device *hwdev, dma_addr_t handle,
 +		size_t size, enum dma_data_direction dir,
 +		unsigned long attrs)
 +
 +{
 +	if (is_device_dma_coherent(hwdev))
 +		return;
 +	if (attrs & DMA_ATTR_SKIP_CPU_SYNC)
 +		return;
 +
 +	__xen_dma_page_dev_to_cpu(hwdev, handle, size, dir);
 +}
 +
 +void __xen_dma_sync_single_for_cpu(struct device *hwdev,
 +		dma_addr_t handle, size_t size, enum dma_data_direction dir)
 +{
 +	if (is_device_dma_coherent(hwdev))
 +		return;
 +	__xen_dma_page_dev_to_cpu(hwdev, handle, size, dir);
 +}
 +
 +void __xen_dma_sync_single_for_device(struct device *hwdev,
 +		dma_addr_t handle, size_t size, enum dma_data_direction dir)
 +{
 +	if (is_device_dma_coherent(hwdev))
 +		return;
 +	__xen_dma_page_cpu_to_dev(hwdev, handle, size, dir);
++=======
+ /*
+  * Dom0 is mapped 1:1, and while the Linux page can span across multiple Xen
+  * pages, it is not possible for it to contain a mix of local and foreign Xen
+  * pages.  Calling pfn_valid on a foreign mfn will always return false, so if
+  * pfn_valid returns true the pages is local and we can use the native
+  * dma-direct functions, otherwise we call the Xen specific version.
+  */
+ void xen_dma_sync_for_cpu(struct device *dev, dma_addr_t handle,
+ 			  size_t size, enum dma_data_direction dir)
+ {
+ 	if (dir != DMA_TO_DEVICE)
+ 		dma_cache_maint(handle, size, GNTTAB_CACHE_INVAL);
+ }
+ 
+ void xen_dma_sync_for_device(struct device *dev, dma_addr_t handle,
+ 			     size_t size, enum dma_data_direction dir)
+ {
+ 	if (dir == DMA_FROM_DEVICE)
+ 		dma_cache_maint(handle, size, GNTTAB_CACHE_INVAL);
+ 	else
+ 		dma_cache_maint(handle, size, GNTTAB_CACHE_CLEAN);
++>>>>>>> 63f0620cc552 (xen/arm: introduce phys/dma translations in xen_dma_sync_for_*)
  }
  
  bool xen_arch_need_swiotlb(struct device *dev,
diff --cc drivers/xen/swiotlb-xen.c
index d199863cc446,39a0f2e0847c..000000000000
--- a/drivers/xen/swiotlb-xen.c
+++ b/drivers/xen/swiotlb-xen.c
@@@ -421,8 -413,12 +421,17 @@@ static dma_addr_t xen_swiotlb_map_page(
  	}
  
  done:
++<<<<<<< HEAD
 +	if (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))
 +		xen_dma_sync_for_device(dev_addr, phys, size, dir);
++=======
+ 	if (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC)) {
+ 		if (pfn_valid(PFN_DOWN(dma_to_phys(dev, dev_addr))))
+ 			arch_sync_dma_for_device(phys, size, dir);
+ 		else
+ 			xen_dma_sync_for_device(dev, dev_addr, size, dir);
+ 	}
++>>>>>>> 63f0620cc552 (xen/arm: introduce phys/dma translations in xen_dma_sync_for_*)
  	return dev_addr;
  }
  
@@@ -441,8 -437,12 +450,17 @@@ static void xen_swiotlb_unmap_page(stru
  
  	BUG_ON(dir == DMA_NONE);
  
++<<<<<<< HEAD
 +	if (!dev_is_dma_coherent(hwdev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))
 +		xen_dma_sync_for_cpu(dev_addr, paddr, size, dir);
++=======
+ 	if (!dev_is_dma_coherent(hwdev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC)) {
+ 		if (pfn_valid(PFN_DOWN(dma_to_phys(hwdev, dev_addr))))
+ 			arch_sync_dma_for_cpu(paddr, size, dir);
+ 		else
+ 			xen_dma_sync_for_cpu(hwdev, dev_addr, size, dir);
+ 	}
++>>>>>>> 63f0620cc552 (xen/arm: introduce phys/dma translations in xen_dma_sync_for_*)
  
  	/* NOTE: We use dev_addr here, not paddr! */
  	if (is_xen_swiotlb_buffer(hwdev, dev_addr))
@@@ -455,8 -455,12 +473,17 @@@ xen_swiotlb_sync_single_for_cpu(struct 
  {
  	phys_addr_t paddr = xen_dma_to_phys(dev, dma_addr);
  
++<<<<<<< HEAD
 +	if (!dev_is_dma_coherent(dev))
 +		xen_dma_sync_for_cpu(dma_addr, paddr, size, dir);
++=======
+ 	if (!dev_is_dma_coherent(dev)) {
+ 		if (pfn_valid(PFN_DOWN(dma_to_phys(dev, dma_addr))))
+ 			arch_sync_dma_for_cpu(paddr, size, dir);
+ 		else
+ 			xen_dma_sync_for_cpu(dev, dma_addr, size, dir);
+ 	}
++>>>>>>> 63f0620cc552 (xen/arm: introduce phys/dma translations in xen_dma_sync_for_*)
  
  	if (is_xen_swiotlb_buffer(dev, dma_addr))
  		swiotlb_tbl_sync_single(dev, paddr, size, dir, SYNC_FOR_CPU);
@@@ -471,8 -475,12 +498,17 @@@ xen_swiotlb_sync_single_for_device(stru
  	if (is_xen_swiotlb_buffer(dev, dma_addr))
  		swiotlb_tbl_sync_single(dev, paddr, size, dir, SYNC_FOR_DEVICE);
  
++<<<<<<< HEAD
 +	if (!dev_is_dma_coherent(dev))
 +		xen_dma_sync_for_device(dma_addr, paddr, size, dir);
++=======
+ 	if (!dev_is_dma_coherent(dev)) {
+ 		if (pfn_valid(PFN_DOWN(dma_to_phys(dev, dma_addr))))
+ 			arch_sync_dma_for_device(paddr, size, dir);
+ 		else
+ 			xen_dma_sync_for_device(dev, dma_addr, size, dir);
+ 	}
++>>>>>>> 63f0620cc552 (xen/arm: introduce phys/dma translations in xen_dma_sync_for_*)
  }
  
  /*
diff --cc include/xen/swiotlb-xen.h
index ffc0d3902b71,d5eaf9d682b8..000000000000
--- a/include/xen/swiotlb-xen.h
+++ b/include/xen/swiotlb-xen.h
@@@ -4,10 -4,10 +4,17 @@@
  
  #include <linux/swiotlb.h>
  
++<<<<<<< HEAD
 +void xen_dma_sync_for_cpu(dma_addr_t handle, phys_addr_t paddr, size_t size,
 +		enum dma_data_direction dir);
 +void xen_dma_sync_for_device(dma_addr_t handle, phys_addr_t paddr, size_t size,
 +		enum dma_data_direction dir);
++=======
+ void xen_dma_sync_for_cpu(struct device *dev, dma_addr_t handle,
+ 			  size_t size, enum dma_data_direction dir);
+ void xen_dma_sync_for_device(struct device *dev, dma_addr_t handle,
+ 			     size_t size, enum dma_data_direction dir);
++>>>>>>> 63f0620cc552 (xen/arm: introduce phys/dma translations in xen_dma_sync_for_*)
  
  extern int xen_swiotlb_init(int verbose, bool early);
  extern const struct dma_map_ops xen_swiotlb_dma_ops;
* Unmerged path arch/arm/xen/mm.c
* Unmerged path drivers/xen/swiotlb-xen.c
* Unmerged path include/xen/swiotlb-xen.h
