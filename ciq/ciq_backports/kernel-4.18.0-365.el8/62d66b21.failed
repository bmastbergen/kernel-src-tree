drm/i915: Fold i9xx_set_pll_dividers() into i9xx_enable_pll()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 62d66b2183861ccdb5b8d9166d9a133489523a31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/62d66b21.failed

Can't think of a good reason why we'd need to program the FP
dividers so early. Let's just do it when programming the rest
of the DPLL.

	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210715093530.31711-12-ville.syrjala@linux.intel.com
	Reviewed-by: Jani Nikula <jani.nikula@intel.com>
(cherry picked from commit 62d66b2183861ccdb5b8d9166d9a133489523a31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_dpll.c
diff --cc drivers/gpu/drm/i915/display/intel_dpll.c
index de345d1ba1af,210f91f4a576..000000000000
--- a/drivers/gpu/drm/i915/display/intel_dpll.c
+++ b/drivers/gpu/drm/i915/display/intel_dpll.c
@@@ -1370,3 -1383,506 +1370,509 @@@ intel_dpll_init_clock_hook(struct drm_i
  	else
  		dev_priv->display.crtc_compute_clock = i8xx_crtc_compute_clock;
  }
++<<<<<<< HEAD
++=======
+ 
+ static bool i9xx_has_pps(struct drm_i915_private *dev_priv)
+ {
+ 	if (IS_I830(dev_priv))
+ 		return false;
+ 
+ 	return IS_PINEVIEW(dev_priv) || IS_MOBILE(dev_priv);
+ }
+ 
+ void i9xx_enable_pll(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	u32 dpll = crtc_state->dpll_hw_state.dpll;
+ 	enum pipe pipe = crtc->pipe;
+ 	int i;
+ 
+ 	assert_pipe_disabled(dev_priv, crtc_state->cpu_transcoder);
+ 
+ 	/* PLL is protected by panel, make sure we can write it */
+ 	if (i9xx_has_pps(dev_priv))
+ 		assert_panel_unlocked(dev_priv, pipe);
+ 
+ 	intel_de_write(dev_priv, FP0(pipe), crtc_state->dpll_hw_state.fp0);
+ 	intel_de_write(dev_priv, FP1(pipe), crtc_state->dpll_hw_state.fp1);
+ 
+ 	/*
+ 	 * Apparently we need to have VGA mode enabled prior to changing
+ 	 * the P1/P2 dividers. Otherwise the DPLL will keep using the old
+ 	 * dividers, even though the register value does change.
+ 	 */
+ 	intel_de_write(dev_priv, DPLL(pipe), dpll & ~DPLL_VGA_MODE_DIS);
+ 	intel_de_write(dev_priv, DPLL(pipe), dpll);
+ 
+ 	/* Wait for the clocks to stabilize. */
+ 	intel_de_posting_read(dev_priv, DPLL(pipe));
+ 	udelay(150);
+ 
+ 	if (DISPLAY_VER(dev_priv) >= 4) {
+ 		intel_de_write(dev_priv, DPLL_MD(pipe),
+ 			       crtc_state->dpll_hw_state.dpll_md);
+ 	} else {
+ 		/* The pixel multiplier can only be updated once the
+ 		 * DPLL is enabled and the clocks are stable.
+ 		 *
+ 		 * So write it again.
+ 		 */
+ 		intel_de_write(dev_priv, DPLL(pipe), dpll);
+ 	}
+ 
+ 	/* We do this three times for luck */
+ 	for (i = 0; i < 3; i++) {
+ 		intel_de_write(dev_priv, DPLL(pipe), dpll);
+ 		intel_de_posting_read(dev_priv, DPLL(pipe));
+ 		udelay(150); /* wait for warmup */
+ 	}
+ }
+ 
+ static void vlv_pllb_recal_opamp(struct drm_i915_private *dev_priv,
+ 				 enum pipe pipe)
+ {
+ 	u32 reg_val;
+ 
+ 	/*
+ 	 * PLLB opamp always calibrates to max value of 0x3f, force enable it
+ 	 * and set it to a reasonable value instead.
+ 	 */
+ 	reg_val = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW9(1));
+ 	reg_val &= 0xffffff00;
+ 	reg_val |= 0x00000030;
+ 	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW9(1), reg_val);
+ 
+ 	reg_val = vlv_dpio_read(dev_priv, pipe, VLV_REF_DW13);
+ 	reg_val &= 0x00ffffff;
+ 	reg_val |= 0x8c000000;
+ 	vlv_dpio_write(dev_priv, pipe, VLV_REF_DW13, reg_val);
+ 
+ 	reg_val = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW9(1));
+ 	reg_val &= 0xffffff00;
+ 	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW9(1), reg_val);
+ 
+ 	reg_val = vlv_dpio_read(dev_priv, pipe, VLV_REF_DW13);
+ 	reg_val &= 0x00ffffff;
+ 	reg_val |= 0xb0000000;
+ 	vlv_dpio_write(dev_priv, pipe, VLV_REF_DW13, reg_val);
+ }
+ 
+ static void vlv_prepare_pll(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 	u32 mdiv;
+ 	u32 bestn, bestm1, bestm2, bestp1, bestp2;
+ 	u32 coreclk, reg_val;
+ 
+ 	vlv_dpio_get(dev_priv);
+ 
+ 	bestn = crtc_state->dpll.n;
+ 	bestm1 = crtc_state->dpll.m1;
+ 	bestm2 = crtc_state->dpll.m2;
+ 	bestp1 = crtc_state->dpll.p1;
+ 	bestp2 = crtc_state->dpll.p2;
+ 
+ 	/* See eDP HDMI DPIO driver vbios notes doc */
+ 
+ 	/* PLL B needs special handling */
+ 	if (pipe == PIPE_B)
+ 		vlv_pllb_recal_opamp(dev_priv, pipe);
+ 
+ 	/* Set up Tx target for periodic Rcomp update */
+ 	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW9_BCAST, 0x0100000f);
+ 
+ 	/* Disable target IRef on PLL */
+ 	reg_val = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW8(pipe));
+ 	reg_val &= 0x00ffffff;
+ 	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW8(pipe), reg_val);
+ 
+ 	/* Disable fast lock */
+ 	vlv_dpio_write(dev_priv, pipe, VLV_CMN_DW0, 0x610);
+ 
+ 	/* Set idtafcrecal before PLL is enabled */
+ 	mdiv = ((bestm1 << DPIO_M1DIV_SHIFT) | (bestm2 & DPIO_M2DIV_MASK));
+ 	mdiv |= ((bestp1 << DPIO_P1_SHIFT) | (bestp2 << DPIO_P2_SHIFT));
+ 	mdiv |= ((bestn << DPIO_N_SHIFT));
+ 	mdiv |= (1 << DPIO_K_SHIFT);
+ 
+ 	/*
+ 	 * Post divider depends on pixel clock rate, DAC vs digital (and LVDS,
+ 	 * but we don't support that).
+ 	 * Note: don't use the DAC post divider as it seems unstable.
+ 	 */
+ 	mdiv |= (DPIO_POST_DIV_HDMIDP << DPIO_POST_DIV_SHIFT);
+ 	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW3(pipe), mdiv);
+ 
+ 	mdiv |= DPIO_ENABLE_CALIBRATION;
+ 	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW3(pipe), mdiv);
+ 
+ 	/* Set HBR and RBR LPF coefficients */
+ 	if (crtc_state->port_clock == 162000 ||
+ 	    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_ANALOG) ||
+ 	    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))
+ 		vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW10(pipe),
+ 				 0x009f0003);
+ 	else
+ 		vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW10(pipe),
+ 				 0x00d0000f);
+ 
+ 	if (intel_crtc_has_dp_encoder(crtc_state)) {
+ 		/* Use SSC source */
+ 		if (pipe == PIPE_A)
+ 			vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),
+ 					 0x0df40000);
+ 		else
+ 			vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),
+ 					 0x0df70000);
+ 	} else { /* HDMI or VGA */
+ 		/* Use bend source */
+ 		if (pipe == PIPE_A)
+ 			vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),
+ 					 0x0df70000);
+ 		else
+ 			vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),
+ 					 0x0df40000);
+ 	}
+ 
+ 	coreclk = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW7(pipe));
+ 	coreclk = (coreclk & 0x0000ff00) | 0x01c00000;
+ 	if (intel_crtc_has_dp_encoder(crtc_state))
+ 		coreclk |= 0x01000000;
+ 	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW7(pipe), coreclk);
+ 
+ 	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW11(pipe), 0x87871000);
+ 
+ 	vlv_dpio_put(dev_priv);
+ }
+ 
+ static void _vlv_enable_pll(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 
+ 	intel_de_write(dev_priv, DPLL(pipe), crtc_state->dpll_hw_state.dpll);
+ 	intel_de_posting_read(dev_priv, DPLL(pipe));
+ 	udelay(150);
+ 
+ 	if (intel_de_wait_for_set(dev_priv, DPLL(pipe), DPLL_LOCK_VLV, 1))
+ 		drm_err(&dev_priv->drm, "DPLL %d failed to lock\n", pipe);
+ }
+ 
+ void vlv_enable_pll(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 
+ 	assert_pipe_disabled(dev_priv, crtc_state->cpu_transcoder);
+ 
+ 	/* PLL is protected by panel, make sure we can write it */
+ 	assert_panel_unlocked(dev_priv, pipe);
+ 
+ 	/* Enable Refclk */
+ 	intel_de_write(dev_priv, DPLL(pipe),
+ 		       crtc_state->dpll_hw_state.dpll &
+ 		       ~(DPLL_VCO_ENABLE | DPLL_EXT_BUFFER_ENABLE_VLV));
+ 
+ 	if (crtc_state->dpll_hw_state.dpll & DPLL_VCO_ENABLE) {
+ 		vlv_prepare_pll(crtc_state);
+ 		_vlv_enable_pll(crtc_state);
+ 	}
+ 
+ 	intel_de_write(dev_priv, DPLL_MD(pipe),
+ 		       crtc_state->dpll_hw_state.dpll_md);
+ 	intel_de_posting_read(dev_priv, DPLL_MD(pipe));
+ }
+ 
+ static void chv_prepare_pll(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 	enum dpio_channel port = vlv_pipe_to_channel(pipe);
+ 	u32 loopfilter, tribuf_calcntr;
+ 	u32 bestn, bestm1, bestm2, bestp1, bestp2, bestm2_frac;
+ 	u32 dpio_val;
+ 	int vco;
+ 
+ 	bestn = crtc_state->dpll.n;
+ 	bestm2_frac = crtc_state->dpll.m2 & 0x3fffff;
+ 	bestm1 = crtc_state->dpll.m1;
+ 	bestm2 = crtc_state->dpll.m2 >> 22;
+ 	bestp1 = crtc_state->dpll.p1;
+ 	bestp2 = crtc_state->dpll.p2;
+ 	vco = crtc_state->dpll.vco;
+ 	dpio_val = 0;
+ 	loopfilter = 0;
+ 
+ 	vlv_dpio_get(dev_priv);
+ 
+ 	/* p1 and p2 divider */
+ 	vlv_dpio_write(dev_priv, pipe, CHV_CMN_DW13(port),
+ 			5 << DPIO_CHV_S1_DIV_SHIFT |
+ 			bestp1 << DPIO_CHV_P1_DIV_SHIFT |
+ 			bestp2 << DPIO_CHV_P2_DIV_SHIFT |
+ 			1 << DPIO_CHV_K_DIV_SHIFT);
+ 
+ 	/* Feedback post-divider - m2 */
+ 	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW0(port), bestm2);
+ 
+ 	/* Feedback refclk divider - n and m1 */
+ 	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW1(port),
+ 			DPIO_CHV_M1_DIV_BY_2 |
+ 			1 << DPIO_CHV_N_DIV_SHIFT);
+ 
+ 	/* M2 fraction division */
+ 	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW2(port), bestm2_frac);
+ 
+ 	/* M2 fraction division enable */
+ 	dpio_val = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW3(port));
+ 	dpio_val &= ~(DPIO_CHV_FEEDFWD_GAIN_MASK | DPIO_CHV_FRAC_DIV_EN);
+ 	dpio_val |= (2 << DPIO_CHV_FEEDFWD_GAIN_SHIFT);
+ 	if (bestm2_frac)
+ 		dpio_val |= DPIO_CHV_FRAC_DIV_EN;
+ 	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW3(port), dpio_val);
+ 
+ 	/* Program digital lock detect threshold */
+ 	dpio_val = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW9(port));
+ 	dpio_val &= ~(DPIO_CHV_INT_LOCK_THRESHOLD_MASK |
+ 					DPIO_CHV_INT_LOCK_THRESHOLD_SEL_COARSE);
+ 	dpio_val |= (0x5 << DPIO_CHV_INT_LOCK_THRESHOLD_SHIFT);
+ 	if (!bestm2_frac)
+ 		dpio_val |= DPIO_CHV_INT_LOCK_THRESHOLD_SEL_COARSE;
+ 	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW9(port), dpio_val);
+ 
+ 	/* Loop filter */
+ 	if (vco == 5400000) {
+ 		loopfilter |= (0x3 << DPIO_CHV_PROP_COEFF_SHIFT);
+ 		loopfilter |= (0x8 << DPIO_CHV_INT_COEFF_SHIFT);
+ 		loopfilter |= (0x1 << DPIO_CHV_GAIN_CTRL_SHIFT);
+ 		tribuf_calcntr = 0x9;
+ 	} else if (vco <= 6200000) {
+ 		loopfilter |= (0x5 << DPIO_CHV_PROP_COEFF_SHIFT);
+ 		loopfilter |= (0xB << DPIO_CHV_INT_COEFF_SHIFT);
+ 		loopfilter |= (0x3 << DPIO_CHV_GAIN_CTRL_SHIFT);
+ 		tribuf_calcntr = 0x9;
+ 	} else if (vco <= 6480000) {
+ 		loopfilter |= (0x4 << DPIO_CHV_PROP_COEFF_SHIFT);
+ 		loopfilter |= (0x9 << DPIO_CHV_INT_COEFF_SHIFT);
+ 		loopfilter |= (0x3 << DPIO_CHV_GAIN_CTRL_SHIFT);
+ 		tribuf_calcntr = 0x8;
+ 	} else {
+ 		/* Not supported. Apply the same limits as in the max case */
+ 		loopfilter |= (0x4 << DPIO_CHV_PROP_COEFF_SHIFT);
+ 		loopfilter |= (0x9 << DPIO_CHV_INT_COEFF_SHIFT);
+ 		loopfilter |= (0x3 << DPIO_CHV_GAIN_CTRL_SHIFT);
+ 		tribuf_calcntr = 0;
+ 	}
+ 	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW6(port), loopfilter);
+ 
+ 	dpio_val = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW8(port));
+ 	dpio_val &= ~DPIO_CHV_TDC_TARGET_CNT_MASK;
+ 	dpio_val |= (tribuf_calcntr << DPIO_CHV_TDC_TARGET_CNT_SHIFT);
+ 	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW8(port), dpio_val);
+ 
+ 	/* AFC Recal */
+ 	vlv_dpio_write(dev_priv, pipe, CHV_CMN_DW14(port),
+ 			vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW14(port)) |
+ 			DPIO_AFC_RECAL);
+ 
+ 	vlv_dpio_put(dev_priv);
+ }
+ 
+ static void _chv_enable_pll(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 	enum dpio_channel port = vlv_pipe_to_channel(pipe);
+ 	u32 tmp;
+ 
+ 	vlv_dpio_get(dev_priv);
+ 
+ 	/* Enable back the 10bit clock to display controller */
+ 	tmp = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW14(port));
+ 	tmp |= DPIO_DCLKP_EN;
+ 	vlv_dpio_write(dev_priv, pipe, CHV_CMN_DW14(port), tmp);
+ 
+ 	vlv_dpio_put(dev_priv);
+ 
+ 	/*
+ 	 * Need to wait > 100ns between dclkp clock enable bit and PLL enable.
+ 	 */
+ 	udelay(1);
+ 
+ 	/* Enable PLL */
+ 	intel_de_write(dev_priv, DPLL(pipe), crtc_state->dpll_hw_state.dpll);
+ 
+ 	/* Check PLL is locked */
+ 	if (intel_de_wait_for_set(dev_priv, DPLL(pipe), DPLL_LOCK_VLV, 1))
+ 		drm_err(&dev_priv->drm, "PLL %d failed to lock\n", pipe);
+ }
+ 
+ void chv_enable_pll(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 
+ 	assert_pipe_disabled(dev_priv, crtc_state->cpu_transcoder);
+ 
+ 	/* PLL is protected by panel, make sure we can write it */
+ 	assert_panel_unlocked(dev_priv, pipe);
+ 
+ 	/* Enable Refclk and SSC */
+ 	intel_de_write(dev_priv, DPLL(pipe),
+ 		       crtc_state->dpll_hw_state.dpll & ~DPLL_VCO_ENABLE);
+ 
+ 	if (crtc_state->dpll_hw_state.dpll & DPLL_VCO_ENABLE) {
+ 		chv_prepare_pll(crtc_state);
+ 		_chv_enable_pll(crtc_state);
+ 	}
+ 
+ 	if (pipe != PIPE_A) {
+ 		/*
+ 		 * WaPixelRepeatModeFixForC0:chv
+ 		 *
+ 		 * DPLLCMD is AWOL. Use chicken bits to propagate
+ 		 * the value from DPLLBMD to either pipe B or C.
+ 		 */
+ 		intel_de_write(dev_priv, CBR4_VLV, CBR_DPLLBMD_PIPE(pipe));
+ 		intel_de_write(dev_priv, DPLL_MD(PIPE_B),
+ 			       crtc_state->dpll_hw_state.dpll_md);
+ 		intel_de_write(dev_priv, CBR4_VLV, 0);
+ 		dev_priv->chv_dpll_md[pipe] = crtc_state->dpll_hw_state.dpll_md;
+ 
+ 		/*
+ 		 * DPLLB VGA mode also seems to cause problems.
+ 		 * We should always have it disabled.
+ 		 */
+ 		drm_WARN_ON(&dev_priv->drm,
+ 			    (intel_de_read(dev_priv, DPLL(PIPE_B)) &
+ 			     DPLL_VGA_MODE_DIS) == 0);
+ 	} else {
+ 		intel_de_write(dev_priv, DPLL_MD(pipe),
+ 			       crtc_state->dpll_hw_state.dpll_md);
+ 		intel_de_posting_read(dev_priv, DPLL_MD(pipe));
+ 	}
+ }
+ 
+ /**
+  * vlv_force_pll_on - forcibly enable just the PLL
+  * @dev_priv: i915 private structure
+  * @pipe: pipe PLL to enable
+  * @dpll: PLL configuration
+  *
+  * Enable the PLL for @pipe using the supplied @dpll config. To be used
+  * in cases where we need the PLL enabled even when @pipe is not going to
+  * be enabled.
+  */
+ int vlv_force_pll_on(struct drm_i915_private *dev_priv, enum pipe pipe,
+ 		     const struct dpll *dpll)
+ {
+ 	struct intel_crtc *crtc = intel_get_crtc_for_pipe(dev_priv, pipe);
+ 	struct intel_crtc_state *crtc_state;
+ 
+ 	crtc_state = intel_crtc_state_alloc(crtc);
+ 	if (!crtc_state)
+ 		return -ENOMEM;
+ 
+ 	crtc_state->cpu_transcoder = (enum transcoder)pipe;
+ 	crtc_state->pixel_multiplier = 1;
+ 	crtc_state->dpll = *dpll;
+ 	crtc_state->output_types = BIT(INTEL_OUTPUT_EDP);
+ 
+ 	if (IS_CHERRYVIEW(dev_priv)) {
+ 		chv_compute_dpll(crtc_state);
+ 		chv_enable_pll(crtc_state);
+ 	} else {
+ 		vlv_compute_dpll(crtc_state);
+ 		vlv_enable_pll(crtc_state);
+ 	}
+ 
+ 	kfree(crtc_state);
+ 
+ 	return 0;
+ }
+ 
+ void vlv_disable_pll(struct drm_i915_private *dev_priv, enum pipe pipe)
+ {
+ 	u32 val;
+ 
+ 	/* Make sure the pipe isn't still relying on us */
+ 	assert_pipe_disabled(dev_priv, (enum transcoder)pipe);
+ 
+ 	val = DPLL_INTEGRATED_REF_CLK_VLV |
+ 		DPLL_REF_CLK_ENABLE_VLV | DPLL_VGA_MODE_DIS;
+ 	if (pipe != PIPE_A)
+ 		val |= DPLL_INTEGRATED_CRI_CLK_VLV;
+ 
+ 	intel_de_write(dev_priv, DPLL(pipe), val);
+ 	intel_de_posting_read(dev_priv, DPLL(pipe));
+ }
+ 
+ void chv_disable_pll(struct drm_i915_private *dev_priv, enum pipe pipe)
+ {
+ 	enum dpio_channel port = vlv_pipe_to_channel(pipe);
+ 	u32 val;
+ 
+ 	/* Make sure the pipe isn't still relying on us */
+ 	assert_pipe_disabled(dev_priv, (enum transcoder)pipe);
+ 
+ 	val = DPLL_SSC_REF_CLK_CHV |
+ 		DPLL_REF_CLK_ENABLE_VLV | DPLL_VGA_MODE_DIS;
+ 	if (pipe != PIPE_A)
+ 		val |= DPLL_INTEGRATED_CRI_CLK_VLV;
+ 
+ 	intel_de_write(dev_priv, DPLL(pipe), val);
+ 	intel_de_posting_read(dev_priv, DPLL(pipe));
+ 
+ 	vlv_dpio_get(dev_priv);
+ 
+ 	/* Disable 10bit clock to display controller */
+ 	val = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW14(port));
+ 	val &= ~DPIO_DCLKP_EN;
+ 	vlv_dpio_write(dev_priv, pipe, CHV_CMN_DW14(port), val);
+ 
+ 	vlv_dpio_put(dev_priv);
+ }
+ 
+ void i9xx_disable_pll(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	enum pipe pipe = crtc->pipe;
+ 
+ 	/* Don't disable pipe or pipe PLLs if needed */
+ 	if (IS_I830(dev_priv))
+ 		return;
+ 
+ 	/* Make sure the pipe isn't still relying on us */
+ 	assert_pipe_disabled(dev_priv, crtc_state->cpu_transcoder);
+ 
+ 	intel_de_write(dev_priv, DPLL(pipe), DPLL_VGA_MODE_DIS);
+ 	intel_de_posting_read(dev_priv, DPLL(pipe));
+ }
+ 
+ 
+ /**
+  * vlv_force_pll_off - forcibly disable just the PLL
+  * @dev_priv: i915 private structure
+  * @pipe: pipe PLL to disable
+  *
+  * Disable the PLL for @pipe. To be used in cases where we need
+  * the PLL enabled even when @pipe is not going to be enabled.
+  */
+ void vlv_force_pll_off(struct drm_i915_private *dev_priv, enum pipe pipe)
+ {
+ 	if (IS_CHERRYVIEW(dev_priv))
+ 		chv_disable_pll(dev_priv, pipe);
+ 	else
+ 		vlv_disable_pll(dev_priv, pipe);
+ }
++>>>>>>> 62d66b218386 (drm/i915: Fold i9xx_set_pll_dividers() into i9xx_enable_pll())
diff --git a/drivers/gpu/drm/i915/display/intel_display.c b/drivers/gpu/drm/i915/display/intel_display.c
index be4f122dd751..00eafa95f487 100644
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@ -5963,17 +5963,6 @@ static void valleyview_crtc_enable(struct intel_atomic_state *state,
 	intel_encoders_enable(state, crtc);
 }
 
-static void i9xx_set_pll_dividers(const struct intel_crtc_state *crtc_state)
-{
-	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
-	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
-
-	intel_de_write(dev_priv, FP0(crtc->pipe),
-		       crtc_state->dpll_hw_state.fp0);
-	intel_de_write(dev_priv, FP1(crtc->pipe),
-		       crtc_state->dpll_hw_state.fp1);
-}
-
 static void i9xx_crtc_enable(struct intel_atomic_state *state,
 			     struct intel_crtc *crtc)
 {
@@ -5985,8 +5974,6 @@ static void i9xx_crtc_enable(struct intel_atomic_state *state,
 	if (drm_WARN_ON(&dev_priv->drm, crtc->active))
 		return;
 
-	i9xx_set_pll_dividers(new_crtc_state);
-
 	if (intel_crtc_has_dp_encoder(new_crtc_state))
 		intel_dp_set_m_n(new_crtc_state, M1_N1);
 
* Unmerged path drivers/gpu/drm/i915/display/intel_dpll.c
