swiotlb-xen: limit init retries

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Jan Beulich <jbeulich@suse.com>
commit cabb7f89b24ed40c4640dac3bca044452ab0b386
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/cabb7f89.failed

Due to the use of max(1024, ...) there's no point retrying (and issuing
bogus log messages) when the number of slabs is already no larger than
this minimum value.

	Signed-off-by: Jan Beulich <jbeulich@suse.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>

Link: https://lore.kernel.org/r/984fa426-2b7b-4b77-5ce8-766619575b7f@suse.com
	Signed-off-by: Juergen Gross <jgross@suse.com>
(cherry picked from commit cabb7f89b24ed40c4640dac3bca044452ab0b386)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/xen/swiotlb-xen.c
diff --cc drivers/xen/swiotlb-xen.c
index 8ccd85660984,d30dc5e68a22..000000000000
--- a/drivers/xen/swiotlb-xen.c
+++ b/drivers/xen/swiotlb-xen.c
@@@ -227,34 -201,64 +227,85 @@@ retry
  		m_ret = XEN_SWIOTLB_EFIXUP;
  		goto error;
  	}
 -	rc = swiotlb_late_init_with_tbl(start, nslabs);
 -	if (rc)
 -		return rc;
 -	swiotlb_set_max_segment(PAGE_SIZE);
 -	return 0;
 +	if (early) {
 +		if (swiotlb_init_with_tbl(start, nslabs,
 +			 verbose))
 +			panic("Cannot allocate SWIOTLB buffer");
 +		rc = 0;
 +	} else
 +		rc = swiotlb_late_init_with_tbl(start, nslabs);
 +
 +	if (!rc)
 +		swiotlb_set_max_segment(PAGE_SIZE);
 +
 +	return rc;
  error:
++<<<<<<< HEAD
 +	if (repeat--) {
 +		nslabs = max(1024UL, /* Min is 2MB */
 +					(nslabs >> 1));
 +		pr_info("Lowering to %luMB\n",
 +			(nslabs << IO_TLB_SHIFT) >> 20);
++=======
+ 	if (nslabs > 1024 && repeat--) {
+ 		/* Min is 2MB */
+ 		nslabs = max(1024UL, ALIGN(nslabs >> 1, IO_TLB_SEGSIZE));
+ 		bytes = nslabs << IO_TLB_SHIFT;
+ 		pr_info("Lowering to %luMB\n", bytes >> 20);
++>>>>>>> cabb7f89b24e (swiotlb-xen: limit init retries)
  		goto retry;
  	}
 -exit:
  	pr_err("%s (rc:%d)\n", xen_swiotlb_error(m_ret), rc);
 +	if (early)
 +		panic("%s (rc:%d)", xen_swiotlb_error(m_ret), rc);
 +	else
 +		free_pages((unsigned long)start, order);
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_X86
+ void __init xen_swiotlb_init_early(void)
+ {
+ 	unsigned long bytes = swiotlb_size_or_default();
+ 	unsigned long nslabs = bytes >> IO_TLB_SHIFT;
+ 	unsigned int repeat = 3;
+ 	char *start;
+ 	int rc;
+ 
+ retry:
+ 	/*
+ 	 * Get IO TLB memory from any location.
+ 	 */
+ 	start = memblock_alloc(PAGE_ALIGN(bytes), PAGE_SIZE);
+ 	if (!start)
+ 		panic("%s: Failed to allocate %lu bytes align=0x%lx\n",
+ 		      __func__, PAGE_ALIGN(bytes), PAGE_SIZE);
+ 
+ 	/*
+ 	 * And replace that memory with pages under 4GB.
+ 	 */
+ 	rc = xen_swiotlb_fixup(start, nslabs);
+ 	if (rc) {
+ 		memblock_free(__pa(start), PAGE_ALIGN(bytes));
+ 		if (nslabs > 1024 && repeat--) {
+ 			/* Min is 2MB */
+ 			nslabs = max(1024UL, ALIGN(nslabs >> 1, IO_TLB_SEGSIZE));
+ 			bytes = nslabs << IO_TLB_SHIFT;
+ 			pr_info("Lowering to %luMB\n", bytes >> 20);
+ 			goto retry;
+ 		}
+ 		panic("%s (rc:%d)", xen_swiotlb_error(XEN_SWIOTLB_EFIXUP), rc);
+ 	}
+ 
+ 	if (swiotlb_init_with_tbl(start, nslabs, false))
+ 		panic("Cannot allocate SWIOTLB buffer");
+ 	swiotlb_set_max_segment(PAGE_SIZE);
+ }
+ #endif /* CONFIG_X86 */
+ 
++>>>>>>> cabb7f89b24e (swiotlb-xen: limit init retries)
  static void *
  xen_swiotlb_alloc_coherent(struct device *hwdev, size_t size,
  			   dma_addr_t *dma_handle, gfp_t flags,
* Unmerged path drivers/xen/swiotlb-xen.c
