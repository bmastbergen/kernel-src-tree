md: check level before create and exit io_acct_set

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Guoqing Jiang <jgq516@gmail.com>
commit daee2024715ddf430a069c0c4eab8417146934cf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/daee2024.failed

The bio_set (io_acct_set) is used by personalities to clone bio and
trace the timestamp of bio. Some personalities such as raid1/10 don't
need the bio_set, so add check to not create it unconditionally.

Also update the comment for md_account_bio to make it more clear.

	Suggested-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Guoqing Jiang <jiangguoqing@kylinos.cn>
	Signed-off-by: Song Liu <song@kernel.org>
(cherry picked from commit daee2024715ddf430a069c0c4eab8417146934cf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
diff --cc drivers/md/md.c
index 20d98e2f9902,56b606184c87..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -2384,7 -2340,9 +2384,13 @@@ int md_integrity_register(struct mddev 
  			       bdev_get_integrity(reference->bdev));
  
  	pr_debug("md: data integrity enabled on %s\n", mdname(mddev));
++<<<<<<< HEAD
 +	if (bioset_integrity_create(&mddev->bio_set, BIO_POOL_SIZE)) {
++=======
+ 	if (bioset_integrity_create(&mddev->bio_set, BIO_POOL_SIZE) ||
+ 	    (mddev->level != 1 && mddev->level != 10 &&
+ 	     bioset_integrity_create(&mddev->io_acct_set, BIO_POOL_SIZE))) {
++>>>>>>> daee2024715d (md: check level before create and exit io_acct_set)
  		pr_err("md: failed to create integrity pool for %s\n",
  		       mdname(mddev));
  		return -EINVAL;
@@@ -5619,6 -5571,8 +5625,11 @@@ static void md_free(struct kobject *ko
  
  	bioset_exit(&mddev->bio_set);
  	bioset_exit(&mddev->sync_set);
++<<<<<<< HEAD
++=======
+ 	if (mddev->level != 1 && mddev->level != 10)
+ 		bioset_exit(&mddev->io_acct_set);
++>>>>>>> daee2024715d (md: check level before create and exit io_acct_set)
  	kfree(mddev);
  }
  
@@@ -5910,7 -5866,14 +5921,18 @@@ int md_run(struct mddev *mddev
  	if (!bioset_initialized(&mddev->sync_set)) {
  		err = bioset_init(&mddev->sync_set, BIO_POOL_SIZE, 0, BIOSET_NEED_BVECS);
  		if (err)
++<<<<<<< HEAD
 +			return err;
++=======
+ 			goto exit_bio_set;
+ 	}
+ 	if (mddev->level != 1 && mddev->level != 10 &&
+ 	    !bioset_initialized(&mddev->io_acct_set)) {
+ 		err = bioset_init(&mddev->io_acct_set, BIO_POOL_SIZE,
+ 				  offsetof(struct md_io_acct, bio_clone), 0);
+ 		if (err)
+ 			goto exit_sync_set;
++>>>>>>> daee2024715d (md: check level before create and exit io_acct_set)
  	}
  
  	spin_lock(&pers_lock);
@@@ -6089,8 -6051,12 +6111,16 @@@ bitmap_abort
  	module_put(pers->owner);
  	md_bitmap_destroy(mddev);
  abort:
++<<<<<<< HEAD
++=======
+ 	if (mddev->level != 1 && mddev->level != 10)
+ 		bioset_exit(&mddev->io_acct_set);
+ exit_sync_set:
+ 	bioset_exit(&mddev->sync_set);
+ exit_bio_set:
++>>>>>>> daee2024715d (md: check level before create and exit io_acct_set)
  	bioset_exit(&mddev->bio_set);
 +	bioset_exit(&mddev->sync_set);
  	return err;
  }
  EXPORT_SYMBOL_GPL(md_run);
@@@ -6315,6 -6280,8 +6345,11 @@@ void md_stop(struct mddev *mddev
  	__md_stop(mddev);
  	bioset_exit(&mddev->bio_set);
  	bioset_exit(&mddev->sync_set);
++<<<<<<< HEAD
++=======
+ 	if (mddev->level != 1 && mddev->level != 10)
+ 		bioset_exit(&mddev->io_acct_set);
++>>>>>>> daee2024715d (md: check level before create and exit io_acct_set)
  }
  
  EXPORT_SYMBOL_GPL(md_stop);
@@@ -8634,6 -8586,41 +8669,44 @@@ void md_submit_discard_bio(struct mdde
  }
  EXPORT_SYMBOL_GPL(md_submit_discard_bio);
  
++<<<<<<< HEAD
++=======
+ static void md_end_io_acct(struct bio *bio)
+ {
+ 	struct md_io_acct *md_io_acct = bio->bi_private;
+ 	struct bio *orig_bio = md_io_acct->orig_bio;
+ 
+ 	orig_bio->bi_status = bio->bi_status;
+ 
+ 	bio_end_io_acct(orig_bio, md_io_acct->start_time);
+ 	bio_put(bio);
+ 	bio_endio(orig_bio);
+ }
+ 
+ /*
+  * Used by personalities that don't already clone the bio and thus can't
+  * easily add the timestamp to their extended bio structure.
+  */
+ void md_account_bio(struct mddev *mddev, struct bio **bio)
+ {
+ 	struct md_io_acct *md_io_acct;
+ 	struct bio *clone;
+ 
+ 	if (!blk_queue_io_stat((*bio)->bi_bdev->bd_disk->queue))
+ 		return;
+ 
+ 	clone = bio_clone_fast(*bio, GFP_NOIO, &mddev->io_acct_set);
+ 	md_io_acct = container_of(clone, struct md_io_acct, bio_clone);
+ 	md_io_acct->orig_bio = *bio;
+ 	md_io_acct->start_time = bio_start_io_acct(*bio);
+ 
+ 	clone->bi_end_io = md_end_io_acct;
+ 	clone->bi_private = md_io_acct;
+ 	*bio = clone;
+ }
+ EXPORT_SYMBOL_GPL(md_account_bio);
+ 
++>>>>>>> daee2024715d (md: check level before create and exit io_acct_set)
  /* md_allow_write(mddev)
   * Calling this ensures that the array is marked 'active' so that writes
   * may proceed without blocking.  It is important to call this before
* Unmerged path drivers/md/md.c
