drm/i915: Introduce hsw_get_buf_trans()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit d6b10b1ae436621fb4cd977d4e41cf762ec17a97
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/d6b10b1a.failed

All the other platforms handle the output_type stuff in their
*_get_buf_trans() functions. Do the same for hsw/bdw/skl.

	Reviewed-by: Jani Nikula <jani.nikula@intel.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210608073603.2408-3-ville.syrjala@linux.intel.com
(cherry picked from commit d6b10b1ae436621fb4cd977d4e41cf762ec17a97)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_ddi.c
#	drivers/gpu/drm/i915/display/intel_ddi_buf_trans.c
#	drivers/gpu/drm/i915/display/intel_ddi_buf_trans.h
#	drivers/gpu/drm/i915/display/intel_fdi.c
diff --cc drivers/gpu/drm/i915/display/intel_ddi.c
index 0f72647ed48c,b6feb71a1af0..000000000000
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@@ -1571,20 -102,16 +1571,27 @@@ static void intel_prepare_dp_ddi_buffer
  	u32 iboost_bit = 0;
  	int i, n_entries;
  	enum port port = encoder->port;
 -	const struct hsw_ddi_buf_trans *ddi_translations;
 -
 +	const struct ddi_buf_trans *ddi_translations;
 +
++<<<<<<< HEAD
 +	if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_ANALOG))
 +		ddi_translations = intel_ddi_get_buf_trans_fdi(dev_priv,
 +							       &n_entries);
 +	else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
 +		ddi_translations = intel_ddi_get_buf_trans_edp(encoder,
 +							       &n_entries);
 +	else
 +		ddi_translations = intel_ddi_get_buf_trans_dp(encoder,
 +							      &n_entries);
++=======
+ 	ddi_translations = hsw_get_buf_trans(encoder, crtc_state, &n_entries);
+ 
+ 	if (drm_WARN_ON_ONCE(&dev_priv->drm, !ddi_translations))
+ 		return;
++>>>>>>> d6b10b1ae436 (drm/i915: Introduce hsw_get_buf_trans())
  
  	/* If we're boosting the current, set bit 31 of trans1 */
 -	if (DISPLAY_VER(dev_priv) == 9 && !IS_BROXTON(dev_priv) &&
 -	    intel_bios_encoder_dp_boost_level(encoder->devdata))
 +	if (IS_GEN9_BC(dev_priv) && intel_bios_dp_boost_level(encoder))
  		iboost_bit = DDI_BUF_BALANCE_LEG_ENABLE;
  
  	for (i = 0; i < n_entries; i++) {
@@@ -1600,16 -127,17 +1607,26 @@@
   * values in advance. This function programs the correct values for
   * HDMI/DVI use cases.
   */
++<<<<<<< HEAD
 +static void intel_prepare_hdmi_ddi_buffers(struct intel_encoder *encoder,
 +					   int level)
++=======
+ static void hsw_prepare_hdmi_ddi_buffers(struct intel_encoder *encoder,
+ 					 const struct intel_crtc_state *crtc_state,
+ 					 int level)
++>>>>>>> d6b10b1ae436 (drm/i915: Introduce hsw_get_buf_trans())
  {
  	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
  	u32 iboost_bit = 0;
  	int n_entries;
  	enum port port = encoder->port;
 -	const struct hsw_ddi_buf_trans *ddi_translations;
 +	const struct ddi_buf_trans *ddi_translations;
  
++<<<<<<< HEAD
 +	ddi_translations = intel_ddi_get_buf_trans_hdmi(encoder, &n_entries);
++=======
+ 	ddi_translations = hsw_get_buf_trans(encoder, crtc_state,  &n_entries);
++>>>>>>> d6b10b1ae436 (drm/i915: Introduce hsw_get_buf_trans())
  
  	if (drm_WARN_ON_ONCE(&dev_priv->drm, !ddi_translations))
  		return;
@@@ -2529,20 -939,15 +2546,24 @@@ static void skl_ddi_set_iboost(struct i
  	u8 iboost;
  
  	if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))
 -		iboost = intel_bios_encoder_hdmi_boost_level(encoder->devdata);
 +		iboost = intel_bios_hdmi_boost_level(encoder);
  	else
 -		iboost = intel_bios_encoder_dp_boost_level(encoder->devdata);
 +		iboost = intel_bios_dp_boost_level(encoder);
  
  	if (iboost == 0) {
 -		const struct hsw_ddi_buf_trans *ddi_translations;
 +		const struct ddi_buf_trans *ddi_translations;
  		int n_entries;
  
++<<<<<<< HEAD
 +		if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI))
 +			ddi_translations = intel_ddi_get_buf_trans_hdmi(encoder, &n_entries);
 +		else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
 +			ddi_translations = intel_ddi_get_buf_trans_edp(encoder, &n_entries);
 +		else
 +			ddi_translations = intel_ddi_get_buf_trans_dp(encoder, &n_entries);
++=======
+ 		ddi_translations = hsw_get_buf_trans(encoder, crtc_state, &n_entries);
++>>>>>>> d6b10b1ae436 (drm/i915: Introduce hsw_get_buf_trans())
  
  		if (drm_WARN_ON_ONCE(&dev_priv->drm, !ddi_translations))
  			return;
@@@ -2618,20 -1017,11 +2639,24 @@@ static u8 intel_ddi_dp_voltage_max(stru
  		else
  			icl_get_mg_buf_trans(encoder, crtc_state, &n_entries);
  	} else if (IS_CANNONLAKE(dev_priv)) {
 -		cnl_get_buf_trans(encoder, crtc_state, &n_entries);
 -	} else if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv)) {
 -		bxt_get_buf_trans(encoder, crtc_state, &n_entries);
 +		if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
 +			cnl_get_buf_trans_edp(encoder, &n_entries);
 +		else
 +			cnl_get_buf_trans_dp(encoder, &n_entries);
 +	} else if (IS_GEN9_LP(dev_priv)) {
 +		if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
 +			bxt_get_buf_trans_edp(encoder, &n_entries);
 +		else
 +			bxt_get_buf_trans_dp(encoder, &n_entries);
  	} else {
++<<<<<<< HEAD
 +		if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
 +			intel_ddi_get_buf_trans_edp(encoder, &n_entries);
 +		else
 +			intel_ddi_get_buf_trans_dp(encoder, &n_entries);
++=======
+ 		hsw_get_buf_trans(encoder, crtc_state, &n_entries);
++>>>>>>> d6b10b1ae436 (drm/i915: Introduce hsw_get_buf_trans())
  	}
  
  	if (drm_WARN_ON(&dev_priv->drm, n_entries < 1))
@@@ -4393,8 -3129,22 +4418,25 @@@ static void intel_enable_ddi_hdmi(struc
  			    "[CONNECTOR:%d:%s] Failed to configure sink scrambling/TMDS bit clock ratio\n",
  			    connector->base.id, connector->name);
  
++<<<<<<< HEAD
++=======
+ 	if (DISPLAY_VER(dev_priv) >= 12)
+ 		tgl_ddi_vswing_sequence(encoder, crtc_state, level);
+ 	else if (DISPLAY_VER(dev_priv) == 11)
+ 		icl_ddi_vswing_sequence(encoder, crtc_state, level);
+ 	else if (IS_CANNONLAKE(dev_priv))
+ 		cnl_ddi_vswing_sequence(encoder, crtc_state, level);
+ 	else if (IS_GEMINILAKE(dev_priv) || IS_BROXTON(dev_priv))
+ 		bxt_ddi_vswing_sequence(encoder, crtc_state, level);
+ 	else
+ 		hsw_prepare_hdmi_ddi_buffers(encoder, crtc_state, level);
+ 
+ 	if (DISPLAY_VER(dev_priv) == 9 && !IS_BROXTON(dev_priv))
+ 		skl_ddi_set_iboost(encoder, crtc_state, level);
+ 
++>>>>>>> d6b10b1ae436 (drm/i915: Introduce hsw_get_buf_trans())
  	/* Display WA #1143: skl,kbl,cfl */
 -	if (DISPLAY_VER(dev_priv) == 9 && !IS_BROXTON(dev_priv)) {
 +	if (IS_GEN9_BC(dev_priv)) {
  		/*
  		 * For some reason these chicken bits have been
  		 * stuffed into a transcoder register, event though
diff --cc drivers/gpu/drm/i915/display/intel_fdi.c
index b2eb96ae10a2,c602ed17c4fb..000000000000
--- a/drivers/gpu/drm/i915/display/intel_fdi.c
+++ b/drivers/gpu/drm/i915/display/intel_fdi.c
@@@ -550,6 -553,142 +550,145 @@@ train_done
  	drm_dbg_kms(&dev_priv->drm, "FDI train done.\n");
  }
  
++<<<<<<< HEAD
++=======
+ /* Starting with Haswell, different DDI ports can work in FDI mode for
+  * connection to the PCH-located connectors. For this, it is necessary to train
+  * both the DDI port and PCH receiver for the desired DDI buffer settings.
+  *
+  * The recommended port to work in FDI mode is DDI E, which we use here. Also,
+  * please note that when FDI mode is active on DDI E, it shares 2 lines with
+  * DDI A (which is used for eDP)
+  */
+ void hsw_fdi_link_train(struct intel_encoder *encoder,
+ 			const struct intel_crtc_state *crtc_state)
+ {
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
+ 	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+ 	u32 temp, i, rx_ctl_val;
+ 	int n_entries;
+ 
+ 	hsw_get_buf_trans(encoder, crtc_state, &n_entries);
+ 
+ 	hsw_prepare_dp_ddi_buffers(encoder, crtc_state);
+ 
+ 	/* Set the FDI_RX_MISC pwrdn lanes and the 2 workarounds listed at the
+ 	 * mode set "sequence for CRT port" document:
+ 	 * - TP1 to TP2 time with the default value
+ 	 * - FDI delay to 90h
+ 	 *
+ 	 * WaFDIAutoLinkSetTimingOverrride:hsw
+ 	 */
+ 	intel_de_write(dev_priv, FDI_RX_MISC(PIPE_A),
+ 		       FDI_RX_PWRDN_LANE1_VAL(2) | FDI_RX_PWRDN_LANE0_VAL(2) | FDI_RX_TP1_TO_TP2_48 | FDI_RX_FDI_DELAY_90);
+ 
+ 	/* Enable the PCH Receiver FDI PLL */
+ 	rx_ctl_val = dev_priv->fdi_rx_config | FDI_RX_ENHANCE_FRAME_ENABLE |
+ 		     FDI_RX_PLL_ENABLE |
+ 		     FDI_DP_PORT_WIDTH(crtc_state->fdi_lanes);
+ 	intel_de_write(dev_priv, FDI_RX_CTL(PIPE_A), rx_ctl_val);
+ 	intel_de_posting_read(dev_priv, FDI_RX_CTL(PIPE_A));
+ 	udelay(220);
+ 
+ 	/* Switch from Rawclk to PCDclk */
+ 	rx_ctl_val |= FDI_PCDCLK;
+ 	intel_de_write(dev_priv, FDI_RX_CTL(PIPE_A), rx_ctl_val);
+ 
+ 	/* Configure Port Clock Select */
+ 	drm_WARN_ON(&dev_priv->drm, crtc_state->shared_dpll->info->id != DPLL_ID_SPLL);
+ 	intel_ddi_enable_clock(encoder, crtc_state);
+ 
+ 	/* Start the training iterating through available voltages and emphasis,
+ 	 * testing each value twice. */
+ 	for (i = 0; i < n_entries * 2; i++) {
+ 		/* Configure DP_TP_CTL with auto-training */
+ 		intel_de_write(dev_priv, DP_TP_CTL(PORT_E),
+ 			       DP_TP_CTL_FDI_AUTOTRAIN |
+ 			       DP_TP_CTL_ENHANCED_FRAME_ENABLE |
+ 			       DP_TP_CTL_LINK_TRAIN_PAT1 |
+ 			       DP_TP_CTL_ENABLE);
+ 
+ 		/* Configure and enable DDI_BUF_CTL for DDI E with next voltage.
+ 		 * DDI E does not support port reversal, the functionality is
+ 		 * achieved on the PCH side in FDI_RX_CTL, so no need to set the
+ 		 * port reversal bit */
+ 		intel_de_write(dev_priv, DDI_BUF_CTL(PORT_E),
+ 			       DDI_BUF_CTL_ENABLE | ((crtc_state->fdi_lanes - 1) << 1) | DDI_BUF_TRANS_SELECT(i / 2));
+ 		intel_de_posting_read(dev_priv, DDI_BUF_CTL(PORT_E));
+ 
+ 		udelay(600);
+ 
+ 		/* Program PCH FDI Receiver TU */
+ 		intel_de_write(dev_priv, FDI_RX_TUSIZE1(PIPE_A), TU_SIZE(64));
+ 
+ 		/* Enable PCH FDI Receiver with auto-training */
+ 		rx_ctl_val |= FDI_RX_ENABLE | FDI_LINK_TRAIN_AUTO;
+ 		intel_de_write(dev_priv, FDI_RX_CTL(PIPE_A), rx_ctl_val);
+ 		intel_de_posting_read(dev_priv, FDI_RX_CTL(PIPE_A));
+ 
+ 		/* Wait for FDI receiver lane calibration */
+ 		udelay(30);
+ 
+ 		/* Unset FDI_RX_MISC pwrdn lanes */
+ 		temp = intel_de_read(dev_priv, FDI_RX_MISC(PIPE_A));
+ 		temp &= ~(FDI_RX_PWRDN_LANE1_MASK | FDI_RX_PWRDN_LANE0_MASK);
+ 		intel_de_write(dev_priv, FDI_RX_MISC(PIPE_A), temp);
+ 		intel_de_posting_read(dev_priv, FDI_RX_MISC(PIPE_A));
+ 
+ 		/* Wait for FDI auto training time */
+ 		udelay(5);
+ 
+ 		temp = intel_de_read(dev_priv, DP_TP_STATUS(PORT_E));
+ 		if (temp & DP_TP_STATUS_AUTOTRAIN_DONE) {
+ 			drm_dbg_kms(&dev_priv->drm,
+ 				    "FDI link training done on step %d\n", i);
+ 			break;
+ 		}
+ 
+ 		/*
+ 		 * Leave things enabled even if we failed to train FDI.
+ 		 * Results in less fireworks from the state checker.
+ 		 */
+ 		if (i == n_entries * 2 - 1) {
+ 			drm_err(&dev_priv->drm, "FDI link training failed!\n");
+ 			break;
+ 		}
+ 
+ 		rx_ctl_val &= ~FDI_RX_ENABLE;
+ 		intel_de_write(dev_priv, FDI_RX_CTL(PIPE_A), rx_ctl_val);
+ 		intel_de_posting_read(dev_priv, FDI_RX_CTL(PIPE_A));
+ 
+ 		temp = intel_de_read(dev_priv, DDI_BUF_CTL(PORT_E));
+ 		temp &= ~DDI_BUF_CTL_ENABLE;
+ 		intel_de_write(dev_priv, DDI_BUF_CTL(PORT_E), temp);
+ 		intel_de_posting_read(dev_priv, DDI_BUF_CTL(PORT_E));
+ 
+ 		/* Disable DP_TP_CTL and FDI_RX_CTL and retry */
+ 		temp = intel_de_read(dev_priv, DP_TP_CTL(PORT_E));
+ 		temp &= ~(DP_TP_CTL_ENABLE | DP_TP_CTL_LINK_TRAIN_MASK);
+ 		temp |= DP_TP_CTL_LINK_TRAIN_PAT1;
+ 		intel_de_write(dev_priv, DP_TP_CTL(PORT_E), temp);
+ 		intel_de_posting_read(dev_priv, DP_TP_CTL(PORT_E));
+ 
+ 		intel_wait_ddi_buf_idle(dev_priv, PORT_E);
+ 
+ 		/* Reset FDI_RX_MISC pwrdn lanes */
+ 		temp = intel_de_read(dev_priv, FDI_RX_MISC(PIPE_A));
+ 		temp &= ~(FDI_RX_PWRDN_LANE1_MASK | FDI_RX_PWRDN_LANE0_MASK);
+ 		temp |= FDI_RX_PWRDN_LANE1_VAL(2) | FDI_RX_PWRDN_LANE0_VAL(2);
+ 		intel_de_write(dev_priv, FDI_RX_MISC(PIPE_A), temp);
+ 		intel_de_posting_read(dev_priv, FDI_RX_MISC(PIPE_A));
+ 	}
+ 
+ 	/* Enable normal pixel sending for FDI */
+ 	intel_de_write(dev_priv, DP_TP_CTL(PORT_E),
+ 		       DP_TP_CTL_FDI_AUTOTRAIN |
+ 		       DP_TP_CTL_LINK_TRAIN_NORMAL |
+ 		       DP_TP_CTL_ENHANCED_FRAME_ENABLE |
+ 		       DP_TP_CTL_ENABLE);
+ }
+ 
++>>>>>>> d6b10b1ae436 (drm/i915: Introduce hsw_get_buf_trans())
  void ilk_fdi_pll_enable(const struct intel_crtc_state *crtc_state)
  {
  	struct intel_crtc *intel_crtc = to_intel_crtc(crtc_state->uapi.crtc);
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi_buf_trans.c
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi_buf_trans.h
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi.c
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi_buf_trans.c
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi_buf_trans.h
* Unmerged path drivers/gpu/drm/i915/display/intel_fdi.c
