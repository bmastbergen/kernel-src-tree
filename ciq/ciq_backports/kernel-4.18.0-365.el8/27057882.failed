drm/i915: split watermark vfuncs from display vtable.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Dave Airlie <airlied@redhat.com>
commit 27057882f62efdf110ed08282982b2d4a23382a9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/27057882.failed

These are the watermark api between display and pm.

	Reviewed-by: Jani Nikula <jani.nikula@intel.com>
	Signed-off-by: Dave Airlie <airlied@redhat.com>
	Signed-off-by: Jani Nikula <jani.nikula@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/7130356324ef3de59b4e913f025d7dce822157ee.1632869550.git.jani.nikula@intel.com
(cherry picked from commit 27057882f62efdf110ed08282982b2d4a23382a9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_display.c
#	drivers/gpu/drm/i915/i915_drv.h
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/display/intel_display.c
index b4efdab01733,6475435b8316..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@@ -121,6 -126,101 +121,104 @@@ static void ilk_pfit_enable(const struc
  static void intel_modeset_setup_hw_state(struct drm_device *dev,
  					 struct drm_modeset_acquire_ctx *ctx);
  
++<<<<<<< HEAD
++=======
+ /**
+  * intel_update_watermarks - update FIFO watermark values based on current modes
+  * @dev_priv: i915 device
+  *
+  * Calculate watermark values for the various WM regs based on current mode
+  * and plane configuration.
+  *
+  * There are several cases to deal with here:
+  *   - normal (i.e. non-self-refresh)
+  *   - self-refresh (SR) mode
+  *   - lines are large relative to FIFO size (buffer can hold up to 2)
+  *   - lines are small relative to FIFO size (buffer can hold more than 2
+  *     lines), so need to account for TLB latency
+  *
+  *   The normal calculation is:
+  *     watermark = dotclock * bytes per pixel * latency
+  *   where latency is platform & configuration dependent (we assume pessimal
+  *   values here).
+  *
+  *   The SR calculation is:
+  *     watermark = (trunc(latency/line time)+1) * surface width *
+  *       bytes per pixel
+  *   where
+  *     line time = htotal / dotclock
+  *     surface width = hdisplay for normal plane and 64 for cursor
+  *   and latency is assumed to be high, as above.
+  *
+  * The final value programmed to the register should always be rounded up,
+  * and include an extra 2 entries to account for clock crossings.
+  *
+  * We don't use the sprite, so we can ignore that.  And on Crestline we have
+  * to set the non-SR watermarks to 8.
+  */
+ static void intel_update_watermarks(struct drm_i915_private *dev_priv)
+ {
+ 	if (dev_priv->wm_disp.update_wm)
+ 		dev_priv->wm_disp.update_wm(dev_priv);
+ }
+ 
+ static int intel_compute_pipe_wm(struct intel_atomic_state *state,
+ 				 struct intel_crtc *crtc)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+ 	if (dev_priv->wm_disp.compute_pipe_wm)
+ 		return dev_priv->wm_disp.compute_pipe_wm(state, crtc);
+ 	return 0;
+ }
+ 
+ static int intel_compute_intermediate_wm(struct intel_atomic_state *state,
+ 					 struct intel_crtc *crtc)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+ 	if (!dev_priv->wm_disp.compute_intermediate_wm)
+ 		return 0;
+ 	if (drm_WARN_ON(&dev_priv->drm,
+ 			!dev_priv->wm_disp.compute_pipe_wm))
+ 		return 0;
+ 	return dev_priv->wm_disp.compute_intermediate_wm(state, crtc);
+ }
+ 
+ static bool intel_initial_watermarks(struct intel_atomic_state *state,
+ 				     struct intel_crtc *crtc)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+ 	if (dev_priv->wm_disp.initial_watermarks) {
+ 		dev_priv->wm_disp.initial_watermarks(state, crtc);
+ 		return true;
+ 	}
+ 	return false;
+ }
+ 
+ static void intel_atomic_update_watermarks(struct intel_atomic_state *state,
+ 					   struct intel_crtc *crtc)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+ 	if (dev_priv->wm_disp.atomic_update_watermarks)
+ 		dev_priv->wm_disp.atomic_update_watermarks(state, crtc);
+ }
+ 
+ static void intel_optimize_watermarks(struct intel_atomic_state *state,
+ 				      struct intel_crtc *crtc)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+ 	if (dev_priv->wm_disp.optimize_watermarks)
+ 		dev_priv->wm_disp.optimize_watermarks(state, crtc);
+ }
+ 
+ static int intel_compute_global_watermarks(struct intel_atomic_state *state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+ 	if (dev_priv->wm_disp.compute_global_watermarks)
+ 		return dev_priv->wm_disp.compute_global_watermarks(state);
+ 	return 0;
+ }
+ 
++>>>>>>> 27057882f62e (drm/i915: split watermark vfuncs from display vtable.)
  /* returns HPLL frequency in kHz */
  int vlv_get_hpll_vco(struct drm_i915_private *dev_priv)
  {
@@@ -6077,11 -3740,11 +6175,16 @@@ static void i9xx_crtc_disable(struct in
  
  	intel_encoders_post_pll_disable(state, crtc);
  
 -	if (DISPLAY_VER(dev_priv) != 2)
 +	if (!IS_GEN(dev_priv, 2))
  		intel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, false);
  
++<<<<<<< HEAD
 +	if (!dev_priv->display.initial_watermarks)
 +		intel_update_watermarks(crtc);
++=======
+ 	if (!dev_priv->wm_disp.initial_watermarks)
+ 		intel_update_watermarks(dev_priv);
++>>>>>>> 27057882f62e (drm/i915: split watermark vfuncs from display vtable.)
  
  	/* clock the pipe down to 640x480@60 to potentially save power */
  	if (IS_I830(dev_priv))
diff --cc drivers/gpu/drm/i915/i915_drv.h
index 6638c0aec2d4,d1a0e110ac4f..000000000000
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@@ -259,15 -323,15 +259,27 @@@ struct intel_crtc
  struct intel_limit;
  struct dpll;
  
++<<<<<<< HEAD
 +struct drm_i915_display_funcs {
 +	void (*get_cdclk)(struct drm_i915_private *dev_priv,
 +			  struct intel_cdclk_config *cdclk_config);
 +	void (*set_cdclk)(struct drm_i915_private *dev_priv,
 +			  const struct intel_cdclk_config *cdclk_config,
 +			  enum pipe pipe);
 +	int (*bw_calc_min_cdclk)(struct intel_atomic_state *state);
 +	int (*get_fifo_size)(struct drm_i915_private *dev_priv,
 +			     enum i9xx_plane_id i9xx_plane);
++=======
+ /* functions used internal in intel_pm.c */
+ struct drm_i915_clock_gating_funcs {
+ 	void (*init_clock_gating)(struct drm_i915_private *dev_priv);
+ };
+ 
+ /* functions used for watermark calcs for display. */
+ struct drm_i915_wm_disp_funcs {
+ 	/* update_wm is for legacy wm management */
+ 	void (*update_wm)(struct drm_i915_private *dev_priv);
++>>>>>>> 27057882f62e (drm/i915: split watermark vfuncs from display vtable.)
  	int (*compute_pipe_wm)(struct intel_atomic_state *state,
  			       struct intel_crtc *crtc);
  	int (*compute_intermediate_wm)(struct intel_atomic_state *state,
@@@ -279,7 -343,15 +291,19 @@@
  	void (*optimize_watermarks)(struct intel_atomic_state *state,
  				    struct intel_crtc *crtc);
  	int (*compute_global_watermarks)(struct intel_atomic_state *state);
++<<<<<<< HEAD
 +	void (*update_wm)(struct intel_crtc *crtc);
++=======
+ };
+ 
+ struct drm_i915_display_funcs {
+ 	void (*get_cdclk)(struct drm_i915_private *dev_priv,
+ 			  struct intel_cdclk_config *cdclk_config);
+ 	void (*set_cdclk)(struct drm_i915_private *dev_priv,
+ 			  const struct intel_cdclk_config *cdclk_config,
+ 			  enum pipe pipe);
+ 	int (*bw_calc_min_cdclk)(struct intel_atomic_state *state);
++>>>>>>> 27057882f62e (drm/i915: split watermark vfuncs from display vtable.)
  	int (*modeset_calc_cdclk)(struct intel_cdclk_state *state);
  	u8 (*calc_voltage_level)(int cdclk);
  	/* Returns the active state of the crtc, and if the crtc is active,
@@@ -962,6 -963,12 +986,15 @@@ struct drm_i915_private 
  	/* unbound hipri wq for page flips/plane updates */
  	struct workqueue_struct *flip_wq;
  
++<<<<<<< HEAD
++=======
+ 	/* pm private clock gating functions */
+ 	struct drm_i915_clock_gating_funcs clock_gating_funcs;
+ 
+ 	/* pm display functions */
+ 	struct drm_i915_wm_disp_funcs wm_disp;
+ 
++>>>>>>> 27057882f62e (drm/i915: split watermark vfuncs from display vtable.)
  	/* Display functions */
  	struct drm_i915_display_funcs display;
  
diff --cc drivers/gpu/drm/i915/intel_pm.c
index 7f3ec682595b,b37888781ec9..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -7626,22 -7958,22 +7626,22 @@@ void intel_init_pm(struct drm_i915_priv
  		skl_setup_sagv_block_time(dev_priv);
  
  	/* For FIFO watermark updates */
 -	if (DISPLAY_VER(dev_priv) >= 9) {
 +	if (INTEL_GEN(dev_priv) >= 9) {
  		skl_setup_wm_latency(dev_priv);
- 		dev_priv->display.compute_global_watermarks = skl_compute_wm;
+ 		dev_priv->wm_disp.compute_global_watermarks = skl_compute_wm;
  	} else if (HAS_PCH_SPLIT(dev_priv)) {
  		ilk_setup_wm_latency(dev_priv);
  
 -		if ((DISPLAY_VER(dev_priv) == 5 && dev_priv->wm.pri_latency[1] &&
 +		if ((IS_GEN(dev_priv, 5) && dev_priv->wm.pri_latency[1] &&
  		     dev_priv->wm.spr_latency[1] && dev_priv->wm.cur_latency[1]) ||
 -		    (DISPLAY_VER(dev_priv) != 5 && dev_priv->wm.pri_latency[0] &&
 +		    (!IS_GEN(dev_priv, 5) && dev_priv->wm.pri_latency[0] &&
  		     dev_priv->wm.spr_latency[0] && dev_priv->wm.cur_latency[0])) {
- 			dev_priv->display.compute_pipe_wm = ilk_compute_pipe_wm;
- 			dev_priv->display.compute_intermediate_wm =
+ 			dev_priv->wm_disp.compute_pipe_wm = ilk_compute_pipe_wm;
+ 			dev_priv->wm_disp.compute_intermediate_wm =
  				ilk_compute_intermediate_wm;
- 			dev_priv->display.initial_watermarks =
+ 			dev_priv->wm_disp.initial_watermarks =
  				ilk_initial_watermarks;
- 			dev_priv->display.optimize_watermarks =
+ 			dev_priv->wm_disp.optimize_watermarks =
  				ilk_optimize_watermarks;
  		} else {
  			drm_dbg_kms(&dev_priv->drm,
@@@ -7674,22 -8006,18 +7674,35 @@@
  				 dev_priv->fsb_freq, dev_priv->mem_freq);
  			/* Disable CxSR and never update its watermark again */
  			intel_set_memory_cxsr(dev_priv, false);
- 			dev_priv->display.update_wm = NULL;
+ 			dev_priv->wm_disp.update_wm = NULL;
  		} else
++<<<<<<< HEAD
 +			dev_priv->display.update_wm = pnv_update_wm;
 +	} else if (IS_GEN(dev_priv, 4)) {
 +		dev_priv->display.update_wm = i965_update_wm;
 +	} else if (IS_GEN(dev_priv, 3)) {
 +		dev_priv->display.update_wm = i9xx_update_wm;
 +		dev_priv->display.get_fifo_size = i9xx_get_fifo_size;
 +	} else if (IS_GEN(dev_priv, 2)) {
 +		if (INTEL_NUM_PIPES(dev_priv) == 1) {
 +			dev_priv->display.update_wm = i845_update_wm;
 +			dev_priv->display.get_fifo_size = i845_get_fifo_size;
 +		} else {
 +			dev_priv->display.update_wm = i9xx_update_wm;
 +			dev_priv->display.get_fifo_size = i830_get_fifo_size;
 +		}
++=======
+ 			dev_priv->wm_disp.update_wm = pnv_update_wm;
+ 	} else if (DISPLAY_VER(dev_priv) == 4) {
+ 		dev_priv->wm_disp.update_wm = i965_update_wm;
+ 	} else if (DISPLAY_VER(dev_priv) == 3) {
+ 		dev_priv->wm_disp.update_wm = i9xx_update_wm;
+ 	} else if (DISPLAY_VER(dev_priv) == 2) {
+ 		if (INTEL_NUM_PIPES(dev_priv) == 1)
+ 			dev_priv->wm_disp.update_wm = i845_update_wm;
+ 		else
+ 			dev_priv->wm_disp.update_wm = i9xx_update_wm;
++>>>>>>> 27057882f62e (drm/i915: split watermark vfuncs from display vtable.)
  	} else {
  		drm_err(&dev_priv->drm,
  			"unexpected fall-through in %s\n", __func__);
* Unmerged path drivers/gpu/drm/i915/display/intel_display.c
* Unmerged path drivers/gpu/drm/i915/i915_drv.h
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
