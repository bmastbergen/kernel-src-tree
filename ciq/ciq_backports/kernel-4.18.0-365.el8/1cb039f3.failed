bdi: replace BDI_CAP_STABLE_WRITES with a queue and a sb flag

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 1cb039f3dc1619eb795c54aad0a98fdb379b4237
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/1cb039f3.failed

The BDI_CAP_STABLE_WRITES is one of the few bits of information in the
backing_dev_info shared between the block drivers and the writeback code.
To help untangling the dependency replace it with a queue flag and a
superblock flag derived from it.  This also helps with the case of e.g.
a file system requiring stable writes due to its own checksumming, but
not forcing it on other users of the block device like the swap code.

One downside is that we an't support the stable_pages_required bdi
attribute in sysfs anymore.  It is replaced with a queue attribute which
also is writable for easier testing.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 1cb039f3dc1619eb795c54aad0a98fdb379b4237)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-sysfs.c
#	drivers/block/zram/zram_drv.c
#	drivers/md/dm-table.c
#	drivers/nvme/host/multipath.c
#	include/linux/backing-dev.h
#	include/linux/blkdev.h
diff --cc block/blk-sysfs.c
index 69ff6dc18eaa,76b54c7750b0..000000000000
--- a/block/blk-sysfs.c
+++ b/block/blk-sysfs.c
@@@ -629,167 -611,12 +630,174 @@@ static struct queue_sysfs_entry queue_h
  	.show = queue_logical_block_size_show,
  };
  
++<<<<<<< HEAD
 +static struct queue_sysfs_entry queue_logical_block_size_entry = {
 +	.attr = {.name = "logical_block_size", .mode = 0444 },
 +	.show = queue_logical_block_size_show,
 +};
++=======
+ QUEUE_RW_ENTRY(queue_nonrot, "rotational");
+ QUEUE_RW_ENTRY(queue_iostats, "iostats");
+ QUEUE_RW_ENTRY(queue_random, "add_random");
+ QUEUE_RW_ENTRY(queue_stable_writes, "stable_writes");
++>>>>>>> 1cb039f3dc16 (bdi: replace BDI_CAP_STABLE_WRITES with a queue and a sb flag)
 +
 +static struct queue_sysfs_entry queue_physical_block_size_entry = {
 +	.attr = {.name = "physical_block_size", .mode = 0444 },
 +	.show = queue_physical_block_size_show,
 +};
 +
 +static struct queue_sysfs_entry queue_chunk_sectors_entry = {
 +	.attr = {.name = "chunk_sectors", .mode = 0444 },
 +	.show = queue_chunk_sectors_show,
 +};
 +
 +static struct queue_sysfs_entry queue_io_min_entry = {
 +	.attr = {.name = "minimum_io_size", .mode = 0444 },
 +	.show = queue_io_min_show,
 +};
 +
 +static struct queue_sysfs_entry queue_io_opt_entry = {
 +	.attr = {.name = "optimal_io_size", .mode = 0444 },
 +	.show = queue_io_opt_show,
 +};
 +
 +static struct queue_sysfs_entry queue_discard_granularity_entry = {
 +	.attr = {.name = "discard_granularity", .mode = 0444 },
 +	.show = queue_discard_granularity_show,
 +};
 +
 +static struct queue_sysfs_entry queue_discard_max_hw_entry = {
 +	.attr = {.name = "discard_max_hw_bytes", .mode = 0444 },
 +	.show = queue_discard_max_hw_show,
 +};
 +
 +static struct queue_sysfs_entry queue_discard_max_entry = {
 +	.attr = {.name = "discard_max_bytes", .mode = 0644 },
 +	.show = queue_discard_max_show,
 +	.store = queue_discard_max_store,
 +};
 +
 +static struct queue_sysfs_entry queue_discard_zeroes_data_entry = {
 +	.attr = {.name = "discard_zeroes_data", .mode = 0444 },
 +	.show = queue_discard_zeroes_data_show,
 +};
 +
 +static struct queue_sysfs_entry queue_unpriv_sgio_entry = {
 +	.attr = {.name = "unpriv_sgio", .mode = S_IRUGO | S_IWUSR },
 +	.show = queue_show_unpriv_sgio,
 +	.store = queue_store_unpriv_sgio,
 +};
 +
 +static struct queue_sysfs_entry queue_write_same_max_entry = {
 +	.attr = {.name = "write_same_max_bytes", .mode = 0444 },
 +	.show = queue_write_same_max_show,
 +};
 +
 +static struct queue_sysfs_entry queue_write_zeroes_max_entry = {
 +	.attr = {.name = "write_zeroes_max_bytes", .mode = 0444 },
 +	.show = queue_write_zeroes_max_show,
 +};
 +
 +static struct queue_sysfs_entry queue_zone_append_max_entry = {
 +	.attr = {.name = "zone_append_max_bytes", .mode = 0444 },
 +	.show = queue_zone_append_max_show,
 +};
 +
 +static struct queue_sysfs_entry queue_nonrot_entry = {
 +	.attr = {.name = "rotational", .mode = 0644 },
 +	.show = queue_show_nonrot,
 +	.store = queue_store_nonrot,
 +};
 +
 +static struct queue_sysfs_entry queue_zoned_entry = {
 +	.attr = {.name = "zoned", .mode = 0444 },
 +	.show = queue_zoned_show,
 +};
 +
 +static struct queue_sysfs_entry queue_nr_zones_entry = {
 +	.attr = {.name = "nr_zones", .mode = 0444 },
 +	.show = queue_nr_zones_show,
 +};
 +
 +static struct queue_sysfs_entry queue_nomerges_entry = {
 +	.attr = {.name = "nomerges", .mode = 0644 },
 +	.show = queue_nomerges_show,
 +	.store = queue_nomerges_store,
 +};
 +
 +static struct queue_sysfs_entry queue_rq_affinity_entry = {
 +	.attr = {.name = "rq_affinity", .mode = 0644 },
 +	.show = queue_rq_affinity_show,
 +	.store = queue_rq_affinity_store,
 +};
 +
 +static struct queue_sysfs_entry queue_iostats_entry = {
 +	.attr = {.name = "iostats", .mode = 0644 },
 +	.show = queue_show_iostats,
 +	.store = queue_store_iostats,
 +};
 +
 +static struct queue_sysfs_entry queue_random_entry = {
 +	.attr = {.name = "add_random", .mode = 0644 },
 +	.show = queue_show_random,
 +	.store = queue_store_random,
 +};
 +
 +static struct queue_sysfs_entry queue_poll_entry = {
 +	.attr = {.name = "io_poll", .mode = 0644 },
 +	.show = queue_poll_show,
 +	.store = queue_poll_store,
 +};
 +
 +static struct queue_sysfs_entry queue_poll_delay_entry = {
 +	.attr = {.name = "io_poll_delay", .mode = 0644 },
 +	.show = queue_poll_delay_show,
 +	.store = queue_poll_delay_store,
 +};
 +
 +static struct queue_sysfs_entry queue_wc_entry = {
 +	.attr = {.name = "write_cache", .mode = 0644 },
 +	.show = queue_wc_show,
 +	.store = queue_wc_store,
 +};
  
 -static struct attribute *queue_attrs[] = {
 +static struct queue_sysfs_entry queue_fua_entry = {
 +	.attr = {.name = "fua", .mode = 0444 },
 +	.show = queue_fua_show,
 +};
 +
 +static struct queue_sysfs_entry queue_dax_entry = {
 +	.attr = {.name = "dax", .mode = 0444 },
 +	.show = queue_dax_show,
 +};
 +
 +static struct queue_sysfs_entry queue_io_timeout_entry = {
 +	.attr = {.name = "io_timeout", .mode = 0644 },
 +	.show = queue_io_timeout_show,
 +	.store = queue_io_timeout_store,
 +};
 +
 +static struct queue_sysfs_entry queue_wb_lat_entry = {
 +	.attr = {.name = "wbt_lat_usec", .mode = 0644 },
 +	.show = queue_wb_lat_show,
 +	.store = queue_wb_lat_store,
 +};
 +
 +#ifdef CONFIG_BLK_DEV_THROTTLING_LOW
 +static struct queue_sysfs_entry throtl_sample_time_entry = {
 +	.attr = {.name = "throttle_sample_time", .mode = 0644 },
 +	.show = blk_throtl_sample_time_show,
 +	.store = blk_throtl_sample_time_store,
 +};
 +#endif
 +
 +static struct queue_sysfs_entry queue_virt_boundary_mask_entry = {
 +	.attr = {.name = "virt_boundary_mask", .mode = 0444 },
 +	.show = queue_virt_boundary_mask_show,
 +};
 +
 +static struct attribute *default_attrs[] = {
  	&queue_requests_entry.attr,
  	&queue_ra_entry.attr,
  	&queue_max_hw_sectors_entry.attr,
diff --cc drivers/block/zram/zram_drv.c
index 67307d00ac23,bff3d4021c18..000000000000
--- a/drivers/block/zram/zram_drv.c
+++ b/drivers/block/zram/zram_drv.c
@@@ -1705,8 -1955,7 +1705,12 @@@ static int zram_add(void
  	if (ZRAM_LOGICAL_BLOCK_SIZE == PAGE_SIZE)
  		blk_queue_max_write_zeroes_sectors(zram->disk->queue, UINT_MAX);
  
++<<<<<<< HEAD
 +	zram->disk->queue->backing_dev_info->capabilities |=
 +			(BDI_CAP_STABLE_WRITES | BDI_CAP_SYNCHRONOUS_IO);
++=======
+ 	blk_queue_flag_set(QUEUE_FLAG_STABLE_WRITES, zram->disk->queue);
++>>>>>>> 1cb039f3dc16 (bdi: replace BDI_CAP_STABLE_WRITES with a queue and a sb flag)
  	device_add_disk(NULL, zram->disk, zram_disk_attr_groups);
  
  	strlcpy(zram->compressor, default_compressor, sizeof(zram->compressor));
diff --cc drivers/md/dm-table.c
index 38d793c6680e,405d7cf10eb9..000000000000
--- a/drivers/md/dm-table.c
+++ b/drivers/md/dm-table.c
@@@ -1808,7 -1815,28 +1808,32 @@@ static int device_requires_stable_pages
  {
  	struct request_queue *q = bdev_get_queue(dev->bdev);
  
++<<<<<<< HEAD
 +	return bdi_cap_stable_pages_required(q->backing_dev_info);
++=======
+ 	return q && blk_queue_stable_writes(q);
+ }
+ 
+ /*
+  * If any underlying device requires stable pages, a table must require
+  * them as well.  Only targets that support iterate_devices are considered:
+  * don't want error, zero, etc to require stable pages.
+  */
+ static bool dm_table_requires_stable_pages(struct dm_table *t)
+ {
+ 	struct dm_target *ti;
+ 	unsigned i;
+ 
+ 	for (i = 0; i < dm_table_get_num_targets(t); i++) {
+ 		ti = dm_table_get_target(t, i);
+ 
+ 		if (ti->type->iterate_devices &&
+ 		    ti->type->iterate_devices(ti, device_requires_stable_pages, NULL))
+ 			return true;
+ 	}
+ 
+ 	return false;
++>>>>>>> 1cb039f3dc16 (bdi: replace BDI_CAP_STABLE_WRITES with a queue and a sb flag)
  }
  
  void dm_table_set_restrictions(struct dm_table *t, struct request_queue *q,
@@@ -1875,14 -1898,11 +1900,19 @@@
  	/*
  	 * Some devices don't use blk_integrity but still want stable pages
  	 * because they do their own checksumming.
 +	 * If any underlying device requires stable pages, a table must require
 +	 * them as well.  Only targets that support iterate_devices are considered:
 +	 * don't want error, zero, etc to require stable pages.
  	 */
++<<<<<<< HEAD
 +	if (dm_table_any_dev_attr(t, device_requires_stable_pages, NULL))
 +		q->backing_dev_info->capabilities |= BDI_CAP_STABLE_WRITES;
++=======
+ 	if (dm_table_requires_stable_pages(t))
+ 		blk_queue_flag_set(QUEUE_FLAG_STABLE_WRITES, q);
++>>>>>>> 1cb039f3dc16 (bdi: replace BDI_CAP_STABLE_WRITES with a queue and a sb flag)
  	else
- 		q->backing_dev_info->capabilities &= ~BDI_CAP_STABLE_WRITES;
+ 		blk_queue_flag_clear(QUEUE_FLAG_STABLE_WRITES, q);
  
  	/*
  	 * Determine whether or not this queue's I/O timings contribute
diff --cc drivers/nvme/host/multipath.c
index fa9a385360f1,74896be40c17..000000000000
--- a/drivers/nvme/host/multipath.c
+++ b/drivers/nvme/host/multipath.c
@@@ -780,28 -673,9 +780,34 @@@ void nvme_mpath_add_disk(struct nvme_n
  		nvme_mpath_set_live(ns);
  	}
  
++<<<<<<< HEAD
 +	if (bdi_cap_stable_pages_required(ns->queue->backing_dev_info)) {
 +		struct gendisk *disk = ns->head->disk;
 +
 +		if (disk)
 +			disk->queue->backing_dev_info->capabilities |=
 +					BDI_CAP_STABLE_WRITES;
 +	}
 +#ifdef CONFIG_BLK_DEV_ZONED
 +	if (blk_queue_is_zoned(ns->queue) && ns->head->disk)
 +		ns->head->disk->queue->nr_zones = ns->queue->nr_zones;
 +#endif
 +}
 +
 +void nvme_mpath_shutdown_disk(struct nvme_ns_head *head)
 +{
 +	if (!head->disk)
 +		return;
 +	kblockd_schedule_work(&head->requeue_work);
 +	if (head->disk->flags & GENHD_FL_UP) {
 +		nvme_cdev_del(&head->cdev, &head->cdev_device);
 +		del_gendisk(head->disk);
 +	}
++=======
+ 	if (blk_queue_stable_writes(ns->queue) && ns->head->disk)
+ 		blk_queue_flag_set(QUEUE_FLAG_STABLE_WRITES,
+ 				   ns->head->disk->queue);
++>>>>>>> 1cb039f3dc16 (bdi: replace BDI_CAP_STABLE_WRITES with a queue and a sb flag)
  }
  
  void nvme_mpath_remove_disk(struct nvme_ns_head *head)
diff --cc include/linux/backing-dev.h
index d0dea95dff96,5da4ea3dd0cc..000000000000
--- a/include/linux/backing-dev.h
+++ b/include/linux/backing-dev.h
@@@ -129,10 -126,8 +129,9 @@@ int bdi_set_max_ratio(struct backing_de
  #define BDI_CAP_NO_ACCT_DIRTY	0x00000001
  #define BDI_CAP_NO_WRITEBACK	0x00000002
  #define BDI_CAP_NO_ACCT_WB	0x00000004
- #define BDI_CAP_STABLE_WRITES	0x00000008
  #define BDI_CAP_STRICTLIMIT	0x00000010
  #define BDI_CAP_CGROUP_WRITEBACK 0x00000020
 +#define BDI_CAP_SYNCHRONOUS_IO	0x00000040
  
  #define BDI_CAP_NO_ACCT_AND_WRITEBACK \
  	(BDI_CAP_NO_WRITEBACK | BDI_CAP_NO_ACCT_DIRTY | BDI_CAP_NO_ACCT_WB)
@@@ -178,16 -169,6 +177,19 @@@ static inline int wb_congested(struct b
  long congestion_wait(int sync, long timeout);
  long wait_iff_congested(int sync, long timeout);
  
++<<<<<<< HEAD
 +static inline bool bdi_cap_synchronous_io(struct backing_dev_info *bdi)
 +{
 +	return bdi->capabilities & BDI_CAP_SYNCHRONOUS_IO;
 +}
 +
 +static inline bool bdi_cap_stable_pages_required(struct backing_dev_info *bdi)
 +{
 +	return bdi->capabilities & BDI_CAP_STABLE_WRITES;
 +}
 +
++=======
++>>>>>>> 1cb039f3dc16 (bdi: replace BDI_CAP_STABLE_WRITES with a queue and a sb flag)
  static inline bool bdi_cap_writeback_dirty(struct backing_dev_info *bdi)
  {
  	return !(bdi->capabilities & BDI_CAP_NO_WRITEBACK);
diff --cc include/linux/blkdev.h
index e7e3d53ccfb5,8e77f12de522..000000000000
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@@ -627,45 -591,38 +627,77 @@@ struct request_queue 
  };
  
  /* Keep blk_queue_flag_name[] in sync with the definitions below */
++<<<<<<< HEAD
 +#define QUEUE_FLAG_STOPPED	1	/* queue is stopped */
 +#define QUEUE_FLAG_DYING	2	/* queue being torn down */
 +#define QUEUE_FLAG_HCTX_ACTIVE  3	/* at least one blk-mq hctx is active */
 +#define QUEUE_FLAG_NOMERGES     5	/* disable merge attempts */
 +#define QUEUE_FLAG_SAME_COMP	6	/* complete on same CPU-group */
 +#define QUEUE_FLAG_FAIL_IO	7	/* fake timeout */
 +#define QUEUE_FLAG_UNPRIV_SGIO  8	/* SG_IO free for unprivileged users */
 +#define QUEUE_FLAG_NONROT	9	/* non-rotational device (SSD) */
 +#define QUEUE_FLAG_VIRT        QUEUE_FLAG_NONROT /* paravirt device */
 +#define QUEUE_FLAG_IO_STAT     10	/* do IO stats */
 +#define QUEUE_FLAG_DISCARD     11	/* supports DISCARD */
 +#define QUEUE_FLAG_NOXMERGES   12	/* No extended merges */
 +#define QUEUE_FLAG_ADD_RANDOM  13	/* Contributes to random pool */
 +#define QUEUE_FLAG_SECERASE    14	/* supports secure erase */
 +#define QUEUE_FLAG_SAME_FORCE  15	/* force complete on same CPU */
 +#define QUEUE_FLAG_DEAD        16	/* queue tear-down finished */
 +#define QUEUE_FLAG_INIT_DONE   17	/* queue is initialized */
 +#define QUEUE_FLAG_NO_SG_MERGE 18	/* don't attempt to merge SG segments (obsolete) */
 +#define QUEUE_FLAG_POLL	       19	/* IO polling enabled if set */
 +#define QUEUE_FLAG_WC	       20	/* Write back caching */
 +#define QUEUE_FLAG_FUA	       21	/* device supports FUA writes */
 +#define QUEUE_FLAG_RQ_ALLOC_TIME 22	/* record rq->alloc_time_ns */
 +#define QUEUE_FLAG_DAX         23	/* device supports DAX */
 +#define QUEUE_FLAG_STATS       24	/* track rq completion times */
 +#define QUEUE_FLAG_POLL_STATS  25	/* collecting stats for hybrid polling */
 +#define QUEUE_FLAG_REGISTERED  26	/* queue has been registered to a disk */
 +#define QUEUE_FLAG_SCSI_PASSTHROUGH 27	/* queue supports SCSI commands */
 +#define QUEUE_FLAG_QUIESCED    28	/* queue has been quiesced */
 +#define QUEUE_FLAG_PCI_P2PDMA  29	/* device supports PCI p2p requests */
 +#define QUEUE_FLAG_ZONE_RESETALL 30	/* supports Zone Reset All */
 +#define QUEUE_FLAG_NOWAIT      31	/* device supports NOWAIT */
 +
 +#define QUEUE_FLAG_DEFAULT	((1 << QUEUE_FLAG_IO_STAT) |		\
 +				 (1 << QUEUE_FLAG_SAME_COMP)	|	\
 +				 (1 << QUEUE_FLAG_ADD_RANDOM))
++=======
+ #define QUEUE_FLAG_STOPPED	0	/* queue is stopped */
+ #define QUEUE_FLAG_DYING	1	/* queue being torn down */
+ #define QUEUE_FLAG_NOMERGES     3	/* disable merge attempts */
+ #define QUEUE_FLAG_SAME_COMP	4	/* complete on same CPU-group */
+ #define QUEUE_FLAG_FAIL_IO	5	/* fake timeout */
+ #define QUEUE_FLAG_NONROT	6	/* non-rotational device (SSD) */
+ #define QUEUE_FLAG_VIRT		QUEUE_FLAG_NONROT /* paravirt device */
+ #define QUEUE_FLAG_IO_STAT	7	/* do disk/partitions IO accounting */
+ #define QUEUE_FLAG_DISCARD	8	/* supports DISCARD */
+ #define QUEUE_FLAG_NOXMERGES	9	/* No extended merges */
+ #define QUEUE_FLAG_ADD_RANDOM	10	/* Contributes to random pool */
+ #define QUEUE_FLAG_SECERASE	11	/* supports secure erase */
+ #define QUEUE_FLAG_SAME_FORCE	12	/* force complete on same CPU */
+ #define QUEUE_FLAG_DEAD		13	/* queue tear-down finished */
+ #define QUEUE_FLAG_INIT_DONE	14	/* queue is initialized */
+ #define QUEUE_FLAG_STABLE_WRITES 15	/* don't modify blks until WB is done */
+ #define QUEUE_FLAG_POLL		16	/* IO polling enabled if set */
+ #define QUEUE_FLAG_WC		17	/* Write back caching */
+ #define QUEUE_FLAG_FUA		18	/* device supports FUA writes */
+ #define QUEUE_FLAG_DAX		19	/* device supports DAX */
+ #define QUEUE_FLAG_STATS	20	/* track IO start and completion times */
+ #define QUEUE_FLAG_POLL_STATS	21	/* collecting stats for hybrid polling */
+ #define QUEUE_FLAG_REGISTERED	22	/* queue has been registered to a disk */
+ #define QUEUE_FLAG_SCSI_PASSTHROUGH 23	/* queue supports SCSI commands */
+ #define QUEUE_FLAG_QUIESCED	24	/* queue has been quiesced */
+ #define QUEUE_FLAG_PCI_P2PDMA	25	/* device supports PCI p2p requests */
+ #define QUEUE_FLAG_ZONE_RESETALL 26	/* supports Zone Reset All */
+ #define QUEUE_FLAG_RQ_ALLOC_TIME 27	/* record rq->alloc_time_ns */
+ #define QUEUE_FLAG_HCTX_ACTIVE 28	/* at least one blk-mq hctx is active */
++>>>>>>> 1cb039f3dc16 (bdi: replace BDI_CAP_STABLE_WRITES with a queue and a sb flag)
  
  #define QUEUE_FLAG_MQ_DEFAULT	((1 << QUEUE_FLAG_IO_STAT) |		\
 -				 (1 << QUEUE_FLAG_SAME_COMP))
 +				 (1 << QUEUE_FLAG_SAME_COMP) |		\
 +				 (1 << QUEUE_FLAG_NOWAIT))
  
  void blk_queue_flag_set(unsigned int flag, struct request_queue *q);
  void blk_queue_flag_clear(unsigned int flag, struct request_queue *q);
@@@ -678,9 -635,9 +710,11 @@@ bool blk_queue_flag_test_and_set(unsign
  #define blk_queue_nomerges(q)	test_bit(QUEUE_FLAG_NOMERGES, &(q)->queue_flags)
  #define blk_queue_noxmerges(q)	\
  	test_bit(QUEUE_FLAG_NOXMERGES, &(q)->queue_flags)
 +#define blk_queue_unpriv_sgio(q) \
 +	test_bit(QUEUE_FLAG_UNPRIV_SGIO, &(q)->queue_flags)
  #define blk_queue_nonrot(q)	test_bit(QUEUE_FLAG_NONROT, &(q)->queue_flags)
+ #define blk_queue_stable_writes(q) \
+ 	test_bit(QUEUE_FLAG_STABLE_WRITES, &(q)->queue_flags)
  #define blk_queue_io_stat(q)	test_bit(QUEUE_FLAG_IO_STAT, &(q)->queue_flags)
  #define blk_queue_add_random(q)	test_bit(QUEUE_FLAG_ADD_RANDOM, &(q)->queue_flags)
  #define blk_queue_discard(q)	test_bit(QUEUE_FLAG_DISCARD, &(q)->queue_flags)
diff --git a/block/blk-integrity.c b/block/blk-integrity.c
index 6faee5063958..468b5c5c69a1 100644
--- a/block/blk-integrity.c
+++ b/block/blk-integrity.c
@@ -443,7 +443,7 @@ void blk_integrity_register(struct gendisk *disk, struct blk_integrity *template
 	bi->tuple_size = template->tuple_size;
 	bi->tag_size = template->tag_size;
 
-	disk->queue->backing_dev_info->capabilities |= BDI_CAP_STABLE_WRITES;
+	blk_queue_flag_set(QUEUE_FLAG_STABLE_WRITES, disk->queue);
 
 	if (!bi->profile->ext_ops)
 		((struct blk_integrity_profile *)bi->profile)->ext_ops =
@@ -471,7 +471,7 @@ EXPORT_SYMBOL(blk_integrity_register);
  */
 void blk_integrity_unregister(struct gendisk *disk)
 {
-	disk->queue->backing_dev_info->capabilities &= ~BDI_CAP_STABLE_WRITES;
+	blk_queue_flag_clear(QUEUE_FLAG_STABLE_WRITES, disk->queue);
 	memset(&disk->queue->integrity, 0, sizeof(struct blk_integrity));
 }
 EXPORT_SYMBOL(blk_integrity_unregister);
diff --git a/block/blk-mq-debugfs.c b/block/blk-mq-debugfs.c
index 22564ae737cd..c3ab8601a3d1 100644
--- a/block/blk-mq-debugfs.c
+++ b/block/blk-mq-debugfs.c
@@ -127,6 +127,7 @@ static const char *const blk_queue_flag_name[] = {
 	QUEUE_FLAG_NAME(SAME_FORCE),
 	QUEUE_FLAG_NAME(DEAD),
 	QUEUE_FLAG_NAME(INIT_DONE),
+	QUEUE_FLAG_NAME(STABLE_WRITES),
 	QUEUE_FLAG_NAME(POLL),
 	QUEUE_FLAG_NAME(WC),
 	QUEUE_FLAG_NAME(FUA),
* Unmerged path block/blk-sysfs.c
diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c
index e13bec724cee..c2a2e4c8097d 100644
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@ -5072,7 +5072,7 @@ static int rbd_init_disk(struct rbd_device *rbd_dev)
 	}
 
 	if (!ceph_test_opt(rbd_dev->rbd_client->client, NOCRC))
-		q->backing_dev_info->capabilities |= BDI_CAP_STABLE_WRITES;
+		blk_queue_flag_set(QUEUE_FLAG_STABLE_WRITES, q);
 
 	/*
 	 * disk_release() expects a queue ref from add_disk() and will
* Unmerged path drivers/block/zram/zram_drv.c
* Unmerged path drivers/md/dm-table.c
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index 08041f68d898..b54239f005d1 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -6865,14 +6865,14 @@ raid5_store_skip_copy(struct mddev *mddev, const char *page, size_t len)
 	if (!conf)
 		err = -ENODEV;
 	else if (new != conf->skip_copy) {
+		struct request_queue *q = mddev->queue;
+
 		mddev_suspend(mddev);
 		conf->skip_copy = new;
 		if (new)
-			mddev->queue->backing_dev_info->capabilities |=
-				BDI_CAP_STABLE_WRITES;
+			blk_queue_flag_set(QUEUE_FLAG_STABLE_WRITES, q);
 		else
-			mddev->queue->backing_dev_info->capabilities &=
-				~BDI_CAP_STABLE_WRITES;
+			blk_queue_flag_clear(QUEUE_FLAG_STABLE_WRITES, q);
 		mddev_resume(mddev);
 	}
 	mddev_unlock(mddev);
diff --git a/drivers/mmc/core/queue.c b/drivers/mmc/core/queue.c
index f144a67cc1ec..0e2405a422a3 100644
--- a/drivers/mmc/core/queue.c
+++ b/drivers/mmc/core/queue.c
@@ -431,8 +431,7 @@ int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card)
 	}
 
 	if (mmc_host_is_spi(host) && host->use_spi_crc)
-		mq->queue->backing_dev_info->capabilities |=
-			BDI_CAP_STABLE_WRITES;
+		blk_queue_flag_set(QUEUE_FLAG_STABLE_WRITES, mq->queue);
 
 	mq->queue->queuedata = mq;
 	blk_queue_rq_timeout(mq->queue, 60 * HZ);
diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index e48148581e1a..fc152159a162 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -3840,8 +3840,7 @@ static void nvme_alloc_ns(struct nvme_ctrl *ctrl, unsigned nsid,
 		goto out_free_ns;
 
 	if (ctrl->opts && ctrl->opts->data_digest)
-		ns->queue->backing_dev_info->capabilities
-			|= BDI_CAP_STABLE_WRITES;
+		blk_queue_flag_set(QUEUE_FLAG_STABLE_WRITES, ns->queue);
 
 	blk_queue_flag_set(QUEUE_FLAG_NONROT, ns->queue);
 	if (ctrl->ops->flags & NVME_F_PCI_P2PDMA)
* Unmerged path drivers/nvme/host/multipath.c
diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 3d3a0f305af6..45ea69ba88b2 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -991,8 +991,8 @@ static int iscsi_sw_tcp_slave_configure(struct scsi_device *sdev)
 	struct iscsi_conn *conn = session->leadconn;
 
 	if (conn->datadgst_en)
-		sdev->request_queue->backing_dev_info->capabilities
-			|= BDI_CAP_STABLE_WRITES;
+		blk_queue_flag_set(QUEUE_FLAG_STABLE_WRITES,
+				   sdev->request_queue);
 	blk_queue_dma_alignment(sdev->request_queue, 0);
 	return 0;
 }
diff --git a/fs/super.c b/fs/super.c
index a7add507343f..1b312487dfdb 100644
--- a/fs/super.c
+++ b/fs/super.c
@@ -1255,6 +1255,8 @@ static int set_bdev_super(struct super_block *s, void *data)
 	s->s_dev = s->s_bdev->bd_dev;
 	s->s_bdi = bdi_get(s->s_bdev->bd_bdi);
 
+	if (blk_queue_stable_writes(s->s_bdev->bd_disk->queue))
+		s->s_iflags |= SB_I_STABLE_WRITES;
 	return 0;
 }
 
* Unmerged path include/linux/backing-dev.h
* Unmerged path include/linux/blkdev.h
diff --git a/include/linux/fs.h b/include/linux/fs.h
index dc6dbdf38549..704fc02c485c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1384,6 +1384,7 @@ extern int send_sigurg(struct fown_struct *fown);
 #define SB_I_CGROUPWB	0x00000001	/* cgroup-aware writeback enabled */
 #define SB_I_NOEXEC	0x00000002	/* Ignore executables on this fs */
 #define SB_I_NODEV	0x00000004	/* Ignore devices on this fs */
+#define SB_I_STABLE_WRITES 0x00000008	/* don't modify blks until WB is done */
 
 /* sb->s_iflags to limit user namespace mounts */
 #define SB_I_USERNS_VISIBLE		0x00000010 /* fstype already mounted */
diff --git a/mm/backing-dev.c b/mm/backing-dev.c
index 38a0dae72f1f..962e608d0721 100644
--- a/mm/backing-dev.c
+++ b/mm/backing-dev.c
@@ -220,10 +220,9 @@ static ssize_t stable_pages_required_show(struct device *dev,
 					  struct device_attribute *attr,
 					  char *page)
 {
-	struct backing_dev_info *bdi = dev_get_drvdata(dev);
-
-	return snprintf(page, PAGE_SIZE-1, "%d\n",
-			bdi_cap_stable_pages_required(bdi) ? 1 : 0);
+	dev_warn_once(dev,
+		"the stable_pages_required attribute has been removed. Use the stable_writes queue attribute instead.\n");
+	return snprintf(page, PAGE_SIZE-1, "%d\n", 0);
 }
 static DEVICE_ATTR_RO(stable_pages_required);
 
diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index ad83d12ad7d6..10c43a30c51f 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -2849,7 +2849,7 @@ EXPORT_SYMBOL_GPL(wait_on_page_writeback);
  */
 void wait_for_stable_page(struct page *page)
 {
-	if (bdi_cap_stable_pages_required(inode_to_bdi(page->mapping->host)))
+	if (page->mapping->host->i_sb->s_iflags & SB_I_STABLE_WRITES)
 		wait_on_page_writeback(page);
 }
 EXPORT_SYMBOL_GPL(wait_for_stable_page);
diff --git a/mm/swapfile.c b/mm/swapfile.c
index 85dbb252f95e..aac87679f257 100644
--- a/mm/swapfile.c
+++ b/mm/swapfile.c
@@ -3249,7 +3249,7 @@ SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)
 		goto bad_swap_unlock_inode;
 	}
 
-	if (bdi_cap_stable_pages_required(inode_to_bdi(inode)))
+	if (p->bdev && blk_queue_stable_writes(p->bdev->bd_disk->queue))
 		p->flags |= SWP_STABLE_WRITES;
 
 	if (bdi_cap_synchronous_io(inode_to_bdi(inode)))
