x86/fpu: Move xstate feature masks to fpu_*_cfg

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 1c253ff2287fe31307a67938c4487936db967ff5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/1c253ff2.failed

Move the feature mask storage to the kernel and user config
structs. Default and maximum feature set are the same for now.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20211014230739.352041752@linutronix.de
(cherry picked from commit 1c253ff2287fe31307a67938c4487936db967ff5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/fpu/xstate.h
#	arch/x86/kernel/fpu/core.c
#	arch/x86/kernel/fpu/init.c
#	arch/x86/kernel/fpu/signal.c
#	arch/x86/kernel/fpu/xstate.c
diff --cc arch/x86/include/asm/fpu/xstate.h
index 2df5bd667a43,fe7c9af9ea42..000000000000
--- a/arch/x86/include/asm/fpu/xstate.h
+++ b/arch/x86/include/asm/fpu/xstate.h
@@@ -78,17 -78,9 +78,20 @@@
  				      XFEATURE_MASK_INDEPENDENT | \
  				      XFEATURE_MASK_SUPERVISOR_UNSUPPORTED)
  
++<<<<<<< HEAD
 +#ifdef CONFIG_X86_64
 +#define REX_PREFIX	"0x48, "
 +#else
 +#define REX_PREFIX
 +#endif
 +
 +extern u64 xfeatures_mask_all;
 +
++=======
++>>>>>>> 1c253ff2287f (x86/fpu: Move xstate feature masks to fpu_*_cfg)
  static inline u64 xfeatures_mask_supervisor(void)
  {
- 	return xfeatures_mask_all & XFEATURE_MASK_SUPERVISOR_SUPPORTED;
+ 	return fpu_kernel_cfg.max_features & XFEATURE_MASK_SUPERVISOR_SUPPORTED;
  }
  
  /*
diff --cc arch/x86/kernel/fpu/core.c
index 2859edb41245,501e21c341f1..000000000000
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@@ -320,12 -333,24 +320,28 @@@ void fpstate_init_user(union fpregs_sta
  		return;
  	}
  
 -	xstate_init_xcomp_bv(&fpstate->regs.xsave, xfeatures_mask_uabi());
 +	xstate_init_xcomp_bv(&state->xsave, xfeatures_mask_uabi());
  
  	if (cpu_feature_enabled(X86_FEATURE_FXSR))
 -		fpstate_init_fxstate(fpstate);
 +		fpstate_init_fxstate(&state->fxsave);
  	else
++<<<<<<< HEAD
 +		fpstate_init_fstate(&state->fsave);
++=======
+ 		fpstate_init_fstate(fpstate);
+ }
+ 
+ void fpstate_reset(struct fpu *fpu)
+ {
+ 	/* Set the fpstate pointer to the default fpstate */
+ 	fpu->fpstate = &fpu->__fpstate;
+ 
+ 	/* Initialize sizes and feature masks */
+ 	fpu->fpstate->size		= fpu_kernel_cfg.default_size;
+ 	fpu->fpstate->user_size		= fpu_user_cfg.default_size;
+ 	fpu->fpstate->xfeatures		= fpu_kernel_cfg.default_features;
+ 	fpu->fpstate->user_xfeatures	= fpu_user_cfg.default_features;
++>>>>>>> 1c253ff2287f (x86/fpu: Move xstate feature masks to fpu_*_cfg)
  }
  
  #if IS_ENABLED(CONFIG_KVM)
diff --cc arch/x86/kernel/fpu/init.c
index f076729aabd0,7074154131e6..000000000000
--- a/arch/x86/kernel/fpu/init.c
+++ b/arch/x86/kernel/fpu/init.c
@@@ -193,18 -187,31 +193,33 @@@ static void __init fpu__init_task_struc
   */
  static void __init fpu__init_system_xstate_size_legacy(void)
  {
 -	unsigned int size;
 -
  	/*
 -	 * Note that the size configuration might be overwritten later
 -	 * during fpu__init_system_xstate().
 +	 * Note that xstate sizes might be overwritten later during
 +	 * fpu__init_system_xstate().
  	 */
  	if (!cpu_feature_enabled(X86_FEATURE_FPU))
 -		size = sizeof(struct swregs_state);
 +		fpu_kernel_xstate_size = sizeof(struct swregs_state);
  	else if (cpu_feature_enabled(X86_FEATURE_FXSR))
 -		size = sizeof(struct fxregs_state);
 +		fpu_kernel_xstate_size = sizeof(struct fxregs_state);
  	else
 -		size = sizeof(struct fregs_state);
 +		fpu_kernel_xstate_size = sizeof(struct fregs_state);
  
++<<<<<<< HEAD
 +	fpu_user_xstate_size = fpu_kernel_xstate_size;
++=======
+ 	fpu_kernel_cfg.max_size = size;
+ 	fpu_kernel_cfg.default_size = size;
+ 	fpu_user_cfg.max_size = size;
+ 	fpu_user_cfg.default_size = size;
+ 	fpstate_reset(&current->thread.fpu);
+ }
+ 
+ static void __init fpu__init_init_fpstate(void)
+ {
+ 	/* Bring init_fpstate size and features up to date */
+ 	init_fpstate.size		= fpu_kernel_cfg.max_size;
+ 	init_fpstate.xfeatures		= fpu_kernel_cfg.max_features;
++>>>>>>> 1c253ff2287f (x86/fpu: Move xstate feature masks to fpu_*_cfg)
  }
  
  /*
diff --cc arch/x86/kernel/fpu/signal.c
index f74c29985497,c14f477f5651..000000000000
--- a/arch/x86/kernel/fpu/signal.c
+++ b/arch/x86/kernel/fpu/signal.c
@@@ -411,13 -416,14 +411,19 @@@ static int __fpu_restore_sig(void __use
  		 */
  		u64 mask = user_xfeatures | xfeatures_mask_supervisor();
  
++<<<<<<< HEAD
 +		fpu->state.xsave.header.xfeatures &= mask;
 +		ret = os_xrstor_safe(&fpu->state.xsave, xfeatures_mask_all);
++=======
+ 		fpregs->xsave.header.xfeatures &= mask;
+ 		success = !os_xrstor_safe(&fpregs->xsave,
+ 					  fpu_kernel_cfg.max_features);
++>>>>>>> 1c253ff2287f (x86/fpu: Move xstate feature masks to fpu_*_cfg)
  	} else {
 -		success = !fxrstor_safe(&fpregs->fxsave);
 +		ret = fxrstor_safe(&fpu->state.fxsave);
  	}
  
 -	if (likely(success))
 +	if (likely(!ret))
  		fpregs_mark_activate();
  
  	fpregs_unlock();
diff --cc arch/x86/kernel/fpu/xstate.c
index bffa08a391ba,8b496c0eb1a5..000000000000
--- a/arch/x86/kernel/fpu/xstate.c
+++ b/arch/x86/kernel/fpu/xstate.c
@@@ -407,7 -395,7 +401,11 @@@ static void __init setup_init_fpu_buf(v
  	setup_xstate_features();
  	print_xstate_features();
  
++<<<<<<< HEAD
 +	xstate_init_xcomp_bv(&init_fpstate.xsave, xfeatures_mask_all);
++=======
+ 	xstate_init_xcomp_bv(&init_fpstate.regs.xsave, fpu_kernel_cfg.max_features);
++>>>>>>> 1c253ff2287f (x86/fpu: Move xstate feature masks to fpu_*_cfg)
  
  	/*
  	 * Init all the features state with header.xfeatures being 0x0
@@@ -724,11 -716,19 +722,11 @@@ static int __init init_xstate_size(void
   * We enabled the XSAVE hardware, but something went wrong and
   * we can not use it.  Disable it.
   */
 -static void __init fpu__init_disable_system_xstate(unsigned int legacy_size)
 +static void __init fpu__init_disable_system_xstate(void)
  {
- 	xfeatures_mask_all = 0;
+ 	fpu_kernel_cfg.max_features = 0;
  	cr4_clear_bits(X86_CR4_OSXSAVE);
  	setup_clear_cpu_cap(X86_FEATURE_XSAVE);
 -
 -	/* Restore the legacy size.*/
 -	fpu_kernel_cfg.max_size = legacy_size;
 -	fpu_kernel_cfg.default_size = legacy_size;
 -	fpu_user_cfg.max_size = legacy_size;
 -	fpu_user_cfg.default_size = legacy_size;
 -
 -	fpstate_reset(&current->thread.fpu);
  }
  
  /*
@@@ -824,8 -834,8 +829,13 @@@ void __init fpu__init_system_xstate(voi
  
  	print_xstate_offset_size();
  	pr_info("x86/fpu: Enabled xstate features 0x%llx, context size is %d bytes, using '%s' format.\n",
++<<<<<<< HEAD
 +		xfeatures_mask_all,
 +		fpu_kernel_xstate_size,
++=======
+ 		fpu_kernel_cfg.max_features,
+ 		fpu_kernel_cfg.max_size,
++>>>>>>> 1c253ff2287f (x86/fpu: Move xstate feature masks to fpu_*_cfg)
  		boot_cpu_has(X86_FEATURE_XSAVES) ? "compacted" : "standard");
  	return;
  
* Unmerged path arch/x86/include/asm/fpu/xstate.h
* Unmerged path arch/x86/kernel/fpu/core.c
* Unmerged path arch/x86/kernel/fpu/init.c
* Unmerged path arch/x86/kernel/fpu/signal.c
* Unmerged path arch/x86/kernel/fpu/xstate.c
