dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 9f4df96b8781e40d0cb0e32eb3d1f6d87375adf9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/9f4df96b.failed

Move more nitty gritty DMA implementation details into the common
internal header.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 9f4df96b8781e40d0cb0e32eb3d1f6d87375adf9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	MAINTAINERS
#	arch/arc/mm/dma.c
#	arch/arm/mm/dma-mapping.c
#	arch/arm/xen/mm.c
#	arch/arm64/mm/dma-mapping.c
#	arch/csky/mm/dma-mapping.c
#	arch/hexagon/kernel/dma.c
#	arch/ia64/mm/init.c
#	arch/m68k/kernel/dma.c
#	arch/microblaze/kernel/dma.c
#	arch/microblaze/mm/consistent.c
#	arch/mips/jazz/jazzdma.c
#	arch/mips/mm/dma-noncoherent.c
#	arch/nds32/kernel/dma.c
#	arch/openrisc/kernel/dma.c
#	arch/parisc/kernel/pci-dma.c
#	arch/powerpc/mm/dma-noncoherent.c
#	arch/sh/kernel/dma-coherent.c
#	arch/sparc/kernel/ioport.c
#	arch/xtensa/kernel/pci-dma.c
#	include/linux/dma-map-ops.h
#	include/linux/dma-noncoherent.h
#	kernel/dma/ops_helpers.c
diff --cc MAINTAINERS
index 4850069063f0,c0dbe6e9de65..000000000000
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@@ -4488,7 -5202,34 +4488,38 @@@ F:	kernel/dma
  F:	include/asm-generic/dma-mapping.h
  F:	include/linux/dma-direct.h
  F:	include/linux/dma-mapping.h
++<<<<<<< HEAD
 +F:	include/linux/dma-noncoherent.h
++=======
+ F:	include/linux/dma-map-ops.h
+ F:	kernel/dma/
+ 
+ DMA-BUF HEAPS FRAMEWORK
+ M:	Sumit Semwal <sumit.semwal@linaro.org>
+ R:	Andrew F. Davis <afd@ti.com>
+ R:	Benjamin Gaignard <benjamin.gaignard@linaro.org>
+ R:	Liam Mark <lmark@codeaurora.org>
+ R:	Laura Abbott <labbott@redhat.com>
+ R:	Brian Starkey <Brian.Starkey@arm.com>
+ R:	John Stultz <john.stultz@linaro.org>
+ L:	linux-media@vger.kernel.org
+ L:	dri-devel@lists.freedesktop.org
+ L:	linaro-mm-sig@lists.linaro.org (moderated for non-subscribers)
+ S:	Maintained
+ T:	git git://anongit.freedesktop.org/drm/drm-misc
+ F:	drivers/dma-buf/dma-heap.c
+ F:	drivers/dma-buf/heaps/*
+ F:	include/linux/dma-heap.h
+ F:	include/uapi/linux/dma-heap.h
+ 
+ DMC FREQUENCY DRIVER FOR SAMSUNG EXYNOS5422
+ M:	Lukasz Luba <lukasz.luba@arm.com>
+ L:	linux-pm@vger.kernel.org
+ L:	linux-samsung-soc@vger.kernel.org
+ S:	Maintained
+ F:	Documentation/devicetree/bindings/memory-controllers/exynos5422-dmc.txt
+ F:	drivers/memory/samsung/exynos5422-dmc.c
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  
  DME1737 HARDWARE MONITOR DRIVER
  M:	Juerg Haefliger <juergh@gmail.com>
diff --cc arch/arc/mm/dma.c
index ec47e6079f5d,517988e60cfc..000000000000
--- a/arch/arc/mm/dma.c
+++ b/arch/arc/mm/dma.c
@@@ -1,77 -1,22 +1,81 @@@
 -// SPDX-License-Identifier: GPL-2.0-only
  /*
   * Copyright (C) 2004, 2007-2010, 2011-2012 Synopsys, Inc. (www.synopsys.com)
 + *
 + * This program is free software; you can redistribute it and/or modify
 + * it under the terms of the GNU General Public License version 2 as
 + * published by the Free Software Foundation.
   */
  
 -#include <linux/dma-map-ops.h>
 -#include <asm/cache.h>
 -#include <asm/cacheflush.h>
 -
  /*
 - * ARCH specific callbacks for generic noncoherent DMA ops
 - *  - hardware IOC not available (or "dma-coherent" not set for device in DT)
 - *  - But still handle both coherent and non-coherent requests from caller
 + * DMA Coherent API Notes
 + *
 + * I/O is inherently non-coherent on ARC. So a coherent DMA buffer is
 + * implemented by accessing it using a kernel virtual address, with
 + * Cache bit off in the TLB entry.
   *
 - * For DMA coherent hardware (IOC) generic code suffices
 + * The default DMA address == Phy address which is 0x8000_0000 based.
   */
  
 -void arch_dma_prep_coherent(struct page *page, size_t size)
++<<<<<<< HEAD
 +#include <linux/dma-noncoherent.h>
++=======
++#include <linux/dma-map-ops.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
 +#include <asm/cache.h>
 +#include <asm/cacheflush.h>
 +
 +void *arch_dma_alloc(struct device *dev, size_t size, dma_addr_t *dma_handle,
 +		gfp_t gfp, unsigned long attrs)
  {
 +	unsigned long order = get_order(size);
 +	struct page *page;
 +	phys_addr_t paddr;
 +	void *kvaddr;
 +	int need_coh = 1, need_kvaddr = 0;
 +
 +	page = alloc_pages(gfp, order);
 +	if (!page)
 +		return NULL;
 +
 +	/*
 +	 * IOC relies on all data (even coherent DMA data) being in cache
 +	 * Thus allocate normal cached memory
 +	 *
 +	 * The gains with IOC are two pronged:
 +	 *   -For streaming data, elides need for cache maintenance, saving
 +	 *    cycles in flush code, and bus bandwidth as all the lines of a
 +	 *    buffer need to be flushed out to memory
 +	 *   -For coherent data, Read/Write to buffers terminate early in cache
 +	 *   (vs. always going to memory - thus are faster)
 +	 */
 +	if ((is_isa_arcv2() && ioc_enable) ||
 +	    (attrs & DMA_ATTR_NON_CONSISTENT))
 +		need_coh = 0;
 +
 +	/*
 +	 * - A coherent buffer needs MMU mapping to enforce non-cachability
 +	 * - A highmem page needs a virtual handle (hence MMU mapping)
 +	 *   independent of cachability
 +	 */
 +	if (PageHighMem(page) || need_coh)
 +		need_kvaddr = 1;
 +
 +	/* This is linear addr (0x8000_0000 based) */
 +	paddr = page_to_phys(page);
 +
 +	*dma_handle = paddr;
 +
 +	/* This is kernel Virtual address (0x7000_0000 based) */
 +	if (need_kvaddr) {
 +		kvaddr = ioremap_nocache(paddr, size);
 +		if (kvaddr == NULL) {
 +			__free_pages(page, order);
 +			return NULL;
 +		}
 +	} else {
 +		kvaddr = (void *)(u32)paddr;
 +	}
 +
  	/*
  	 * Evict any existing L1 and/or L2 lines for the backing page
  	 * in case it was used earlier as a normal "cached" page.
diff --cc arch/arm/mm/dma-mapping.c
index e5a585d6d58c,c4b8df2ad328..000000000000
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@@ -18,8 -15,7 +18,12 @@@
  #include <linux/init.h>
  #include <linux/device.h>
  #include <linux/dma-direct.h>
++<<<<<<< HEAD
 +#include <linux/dma-mapping.h>
 +#include <linux/dma-contiguous.h>
++=======
+ #include <linux/dma-map-ops.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  #include <linux/highmem.h>
  #include <linux/memblock.h>
  #include <linux/slab.h>
diff --cc arch/arm/xen/mm.c
index cb44aa290e73,5c80088db13b..000000000000
--- a/arch/arm/xen/mm.c
+++ b/arch/arm/xen/mm.c
@@@ -1,5 -1,7 +1,10 @@@
 -// SPDX-License-Identifier: GPL-2.0-only
  #include <linux/cpu.h>
++<<<<<<< HEAD
 +#include <linux/dma-mapping.h>
++=======
+ #include <linux/dma-direct.h>
+ #include <linux/dma-map-ops.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  #include <linux/gfp.h>
  #include <linux/highmem.h>
  #include <linux/export.h>
diff --cc arch/arm64/mm/dma-mapping.c
index 8f556361d408,93e87b287556..000000000000
--- a/arch/arm64/mm/dma-mapping.c
+++ b/arch/arm64/mm/dma-mapping.c
@@@ -18,19 -5,11 +18,23 @@@
   */
  
  #include <linux/gfp.h>
 +#include <linux/acpi.h>
 +#include <linux/memblock.h>
  #include <linux/cache.h>
++<<<<<<< HEAD
 +#include <linux/export.h>
 +#include <linux/slab.h>
 +#include <linux/genalloc.h>
 +#include <linux/dma-direct.h>
 +#include <linux/dma-noncoherent.h>
 +#include <linux/dma-contiguous.h>
++=======
+ #include <linux/dma-map-ops.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  #include <linux/dma-iommu.h>
 -#include <xen/xen.h>
 -#include <xen/swiotlb-xen.h>
 +#include <linux/vmalloc.h>
 +#include <linux/swiotlb.h>
 +#include <linux/pci.h>
  
  #include <asm/cacheflush.h>
  
diff --cc arch/hexagon/kernel/dma.c
index 8e1d2a7bf90d,00b9a81075dd..000000000000
--- a/arch/hexagon/kernel/dma.c
+++ b/arch/hexagon/kernel/dma.c
@@@ -2,27 -3,11 +2,31 @@@
   * DMA implementation for Hexagon
   *
   * Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
 + *
 + * This program is free software; you can redistribute it and/or modify
 + * it under the terms of the GNU General Public License version 2 and
 + * only version 2 as published by the Free Software Foundation.
 + *
 + * This program is distributed in the hope that it will be useful,
 + * but WITHOUT ANY WARRANTY; without even the implied warranty of
 + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 + * GNU General Public License for more details.
 + *
 + * You should have received a copy of the GNU General Public License
 + * along with this program; if not, write to the Free Software
 + * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 + * 02110-1301, USA.
   */
  
++<<<<<<< HEAD
 +#include <linux/dma-mapping.h>
 +#include <linux/dma-direct.h>
++=======
+ #include <linux/dma-map-ops.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  #include <linux/memblock.h>
  #include <linux/genalloc.h>
 +#include <asm/dma-mapping.h>
  #include <linux/module.h>
  #include <asm/page.h>
  
diff --cc arch/ia64/mm/init.c
index 5ab64d9d3462,ccba04d12671..000000000000
--- a/arch/ia64/mm/init.c
+++ b/arch/ia64/mm/init.c
@@@ -8,6 -8,8 +8,11 @@@
  #include <linux/kernel.h>
  #include <linux/init.h>
  
++<<<<<<< HEAD
++=======
+ #include <linux/dma-map-ops.h>
+ #include <linux/dmar.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  #include <linux/efi.h>
  #include <linux/elf.h>
  #include <linux/memblock.h>
diff --cc arch/m68k/kernel/dma.c
index 463572c4943f,1c1b875fadc1..000000000000
--- a/arch/m68k/kernel/dma.c
+++ b/arch/m68k/kernel/dma.c
@@@ -6,7 -6,7 +6,11 @@@
  
  #undef DEBUG
  
++<<<<<<< HEAD
 +#include <linux/dma-mapping.h>
++=======
+ #include <linux/dma-map-ops.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  #include <linux/device.h>
  #include <linux/kernel.h>
  #include <linux/platform_device.h>
diff --cc arch/microblaze/kernel/dma.c
index 3145e7dc8ab1,04d091ade417..000000000000
--- a/arch/microblaze/kernel/dma.c
+++ b/arch/microblaze/kernel/dma.c
@@@ -8,9 -8,8 +8,13 @@@
   */
  
  #include <linux/device.h>
++<<<<<<< HEAD
 +#include <linux/dma-mapping.h>
++=======
+ #include <linux/dma-map-ops.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  #include <linux/gfp.h>
 +#include <linux/dma-debug.h>
  #include <linux/export.h>
  #include <linux/bug.h>
  #include <asm/cacheflush.h>
diff --cc arch/microblaze/mm/consistent.c
index b0ac81828e6a,81dffe43b18c..000000000000
--- a/arch/microblaze/mm/consistent.c
+++ b/arch/microblaze/mm/consistent.c
@@@ -3,264 -4,49 +3,268 @@@
   * Copyright (C) 2010 Michal Simek <monstr@monstr.eu>
   * Copyright (C) 2010 PetaLogix
   * Copyright (C) 2005 John Williams <jwilliams@itee.uq.edu.au>
 + *
 + * Based on PowerPC version derived from arch/arm/mm/consistent.c
 + * Copyright (C) 2001 Dan Malek (dmalek@jlc.net)
 + * Copyright (C) 2000 Russell King
 + *
 + * This program is free software; you can redistribute it and/or modify
 + * it under the terms of the GNU General Public License version 2 as
 + * published by the Free Software Foundation.
   */
  
 +#include <linux/export.h>
 +#include <linux/signal.h>
 +#include <linux/sched.h>
  #include <linux/kernel.h>
 +#include <linux/errno.h>
  #include <linux/string.h>
  #include <linux/types.h>
 +#include <linux/ptrace.h>
 +#include <linux/mman.h>
  #include <linux/mm.h>
 +#include <linux/swap.h>
 +#include <linux/stddef.h>
 +#include <linux/vmalloc.h>
  #include <linux/init.h>
++<<<<<<< HEAD
 +#include <linux/delay.h>
 +#include <linux/memblock.h>
 +#include <linux/highmem.h>
 +#include <linux/pci.h>
 +#include <linux/interrupt.h>
 +#include <linux/gfp.h>
 +
 +#include <asm/pgalloc.h>
 +#include <linux/io.h>
 +#include <linux/hardirq.h>
 +#include <linux/mmu_context.h>
 +#include <asm/mmu.h>
 +#include <linux/uaccess.h>
 +#include <asm/pgtable.h>
++=======
+ #include <linux/dma-map-ops.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  #include <asm/cpuinfo.h>
 -#include <asm/cacheflush.h>
 +#include <asm/tlbflush.h>
  
 -void arch_dma_prep_coherent(struct page *page, size_t size)
 +#ifndef CONFIG_MMU
 +/* I have to use dcache values because I can't relate on ram size */
 +# define UNCACHED_SHADOW_MASK (cpuinfo.dcache_high - cpuinfo.dcache_base + 1)
 +#endif
 +
 +/*
 + * Consistent memory allocators. Used for DMA devices that want to
 + * share uncached memory with the processor core.
 + * My crufty no-MMU approach is simple. In the HW platform we can optionally
 + * mirror the DDR up above the processor cacheable region.  So, memory accessed
 + * in this mirror region will not be cached.  It's alloced from the same
 + * pool as normal memory, but the handle we return is shifted up into the
 + * uncached region.  This will no doubt cause big problems if memory allocated
 + * here is not also freed properly. -- JW
 + */
 +void *consistent_alloc(gfp_t gfp, size_t size, dma_addr_t *dma_handle)
  {
 -	phys_addr_t paddr = page_to_phys(page);
 +	unsigned long order, vaddr;
 +	void *ret;
 +	unsigned int i, err = 0;
 +	struct page *page, *end;
  
 -	flush_dcache_range(paddr, paddr + size);
 -}
 +#ifdef CONFIG_MMU
 +	phys_addr_t pa;
 +	struct vm_struct *area;
 +	unsigned long va;
 +#endif
 +
 +	if (in_interrupt())
 +		BUG();
 +
 +	/* Only allocate page size areas. */
 +	size = PAGE_ALIGN(size);
 +	order = get_order(size);
 +
 +	vaddr = __get_free_pages(gfp, order);
 +	if (!vaddr)
 +		return NULL;
 +
 +	/*
 +	 * we need to ensure that there are no cachelines in use,
 +	 * or worse dirty in this area.
 +	 */
 +	flush_dcache_range(virt_to_phys((void *)vaddr),
 +					virt_to_phys((void *)vaddr) + size);
  
  #ifndef CONFIG_MMU
 +	ret = (void *)vaddr;
 +	/*
 +	 * Here's the magic!  Note if the uncached shadow is not implemented,
 +	 * it's up to the calling code to also test that condition and make
 +	 * other arranegments, such as manually flushing the cache and so on.
 +	 */
 +# ifdef CONFIG_XILINX_UNCACHED_SHADOW
 +	ret = (void *)((unsigned) ret | UNCACHED_SHADOW_MASK);
 +# endif
 +	if ((unsigned int)ret > cpuinfo.dcache_base &&
 +				(unsigned int)ret < cpuinfo.dcache_high)
 +		pr_warn("ERROR: Your cache coherent area is CACHED!!!\n");
 +
 +	/* dma_handle is same as physical (shadowed) address */
 +	*dma_handle = (dma_addr_t)ret;
 +#else
 +	/* Allocate some common virtual space to map the new pages. */
 +	area = get_vm_area(size, VM_ALLOC);
 +	if (!area) {
 +		free_pages(vaddr, order);
 +		return NULL;
 +	}
 +	va = (unsigned long) area->addr;
 +	ret = (void *)va;
 +
 +	/* This gives us the real physical address of the first page. */
 +	*dma_handle = pa = __virt_to_phys(vaddr);
 +#endif
 +
 +	/*
 +	 * free wasted pages.  We skip the first page since we know
 +	 * that it will have count = 1 and won't require freeing.
 +	 * We also mark the pages in use as reserved so that
 +	 * remap_page_range works.
 +	 */
 +	page = virt_to_page(vaddr);
 +	end = page + (1 << order);
 +
 +	split_page(page, order);
 +
 +	for (i = 0; i < size && err == 0; i += PAGE_SIZE) {
 +#ifdef CONFIG_MMU
 +		/* MS: This is the whole magic - use cache inhibit pages */
 +		err = map_page(va + i, pa + i, _PAGE_KERNEL | _PAGE_NO_CACHE);
 +#endif
 +
 +		SetPageReserved(page);
 +		page++;
 +	}
 +
 +	/* Free the otherwise unused pages. */
 +	while (page < end) {
 +		__free_page(page);
 +		page++;
 +	}
 +
 +	if (err) {
 +		free_pages(vaddr, order);
 +		return NULL;
 +	}
 +
 +	return ret;
 +}
 +EXPORT_SYMBOL(consistent_alloc);
 +
 +#ifdef CONFIG_MMU
 +static pte_t *consistent_virt_to_pte(void *vaddr)
 +{
 +	unsigned long addr = (unsigned long)vaddr;
 +
 +	return pte_offset_kernel(pmd_offset(pgd_offset_k(addr), addr), addr);
 +}
 +
 +unsigned long consistent_virt_to_pfn(void *vaddr)
 +{
 +	pte_t *ptep = consistent_virt_to_pte(vaddr);
 +
 +	if (pte_none(*ptep) || !pte_present(*ptep))
 +		return 0;
 +
 +	return pte_pfn(*ptep);
 +}
 +#endif
 +
  /*
 - * Consistent memory allocators. Used for DMA devices that want to share
 - * uncached memory with the processor core.  My crufty no-MMU approach is
 - * simple.  In the HW platform we can optionally mirror the DDR up above the
 - * processor cacheable region.  So, memory accessed in this mirror region will
 - * not be cached.  It's alloced from the same pool as normal memory, but the
 - * handle we return is shifted up into the uncached region.  This will no doubt
 - * cause big problems if memory allocated here is not also freed properly. -- JW
 - *
 - * I have to use dcache values because I can't relate on ram size:
 + * free page(s) as defined by the above mapping.
   */
 -#ifdef CONFIG_XILINX_UNCACHED_SHADOW
 -#define UNCACHED_SHADOW_MASK (cpuinfo.dcache_high - cpuinfo.dcache_base + 1)
 +void consistent_free(size_t size, void *vaddr)
 +{
 +	struct page *page;
 +
 +	if (in_interrupt())
 +		BUG();
 +
 +	size = PAGE_ALIGN(size);
 +
 +#ifndef CONFIG_MMU
 +	/* Clear SHADOW_MASK bit in address, and free as per usual */
 +# ifdef CONFIG_XILINX_UNCACHED_SHADOW
 +	vaddr = (void *)((unsigned)vaddr & ~UNCACHED_SHADOW_MASK);
 +# endif
 +	page = virt_to_page(vaddr);
 +
 +	do {
 +		__free_reserved_page(page);
 +		page++;
 +	} while (size -= PAGE_SIZE);
  #else
 -#define UNCACHED_SHADOW_MASK 0
 -#endif /* CONFIG_XILINX_UNCACHED_SHADOW */
 +	do {
 +		pte_t *ptep = consistent_virt_to_pte(vaddr);
 +		unsigned long pfn;
  
 -void *arch_dma_set_uncached(void *ptr, size_t size)
 +		if (!pte_none(*ptep) && pte_present(*ptep)) {
 +			pfn = pte_pfn(*ptep);
 +			pte_clear(&init_mm, (unsigned int)vaddr, ptep);
 +			if (pfn_valid(pfn)) {
 +				page = pfn_to_page(pfn);
 +				__free_reserved_page(page);
 +			}
 +		}
 +		vaddr += PAGE_SIZE;
 +	} while (size -= PAGE_SIZE);
 +
 +	/* flush tlb */
 +	flush_tlb_all();
 +#endif
 +}
 +EXPORT_SYMBOL(consistent_free);
 +
 +/*
 + * make an area consistent.
 + */
 +void consistent_sync(void *vaddr, size_t size, int direction)
  {
 -	unsigned long addr = (unsigned long)ptr;
 +	unsigned long start;
 +	unsigned long end;
  
 -	addr |= UNCACHED_SHADOW_MASK;
 -	if (addr > cpuinfo.dcache_base && addr < cpuinfo.dcache_high)
 -		pr_warn("ERROR: Your cache coherent area is CACHED!!!\n");
 -	return (void *)addr;
 +	start = (unsigned long)vaddr;
 +
 +	/* Convert start address back down to unshadowed memory region */
 +#ifdef CONFIG_XILINX_UNCACHED_SHADOW
 +	start &= ~UNCACHED_SHADOW_MASK;
 +#endif
 +	end = start + size;
 +
 +	switch (direction) {
 +	case PCI_DMA_NONE:
 +		BUG();
 +	case PCI_DMA_FROMDEVICE:	/* invalidate only */
 +		invalidate_dcache_range(start, end);
 +		break;
 +	case PCI_DMA_TODEVICE:		/* writeback only */
 +		flush_dcache_range(start, end);
 +		break;
 +	case PCI_DMA_BIDIRECTIONAL:	/* writeback and invalidate */
 +		flush_dcache_range(start, end);
 +		break;
 +	}
 +}
 +EXPORT_SYMBOL(consistent_sync);
 +
 +/*
 + * consistent_sync_page makes memory consistent. identical
 + * to consistent_sync, but takes a struct page instead of a
 + * virtual address
 + */
 +void consistent_sync_page(struct page *page, unsigned long offset,
 +	size_t size, int direction)
 +{
 +	unsigned long start = (unsigned long)page_address(page) + offset;
 +	consistent_sync((void *)start, size, direction);
  }
 -#endif /* CONFIG_MMU */
 +EXPORT_SYMBOL(consistent_sync_page);
diff --cc arch/mips/jazz/jazzdma.c
index e792328651d1,461457b28982..000000000000
--- a/arch/mips/jazz/jazzdma.c
+++ b/arch/mips/jazz/jazzdma.c
@@@ -16,6 -16,7 +16,10 @@@
  #include <linux/memblock.h>
  #include <linux/spinlock.h>
  #include <linux/gfp.h>
++<<<<<<< HEAD
++=======
+ #include <linux/dma-map-ops.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  #include <asm/mipsregs.h>
  #include <asm/jazz.h>
  #include <asm/io.h>
diff --cc arch/nds32/kernel/dma.c
index d0dbd4fe9645,2ac8e6c82a61..000000000000
--- a/arch/nds32/kernel/dma.c
+++ b/arch/nds32/kernel/dma.c
@@@ -3,12 -3,9 +3,16 @@@
  
  #include <linux/types.h>
  #include <linux/mm.h>
++<<<<<<< HEAD
 +#include <linux/string.h>
 +#include <linux/dma-noncoherent.h>
 +#include <linux/io.h>
++=======
+ #include <linux/dma-map-ops.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  #include <linux/cache.h>
  #include <linux/highmem.h>
 +#include <linux/slab.h>
  #include <asm/cacheflush.h>
  #include <asm/tlbflush.h>
  #include <asm/proc-fns.h>
diff --cc arch/openrisc/kernel/dma.c
index a4b781abe55f,1b16d97e7da7..000000000000
--- a/arch/openrisc/kernel/dma.c
+++ b/arch/openrisc/kernel/dma.c
@@@ -9,19 -10,10 +9,23 @@@
   * Copyright (C) 2003 Matjaz Breskvar <phoenix@bsemi.com>
   * Copyright (C) 2010-2011 Jonas Bonn <jonas@southpole.se>
   *
 + *      This program is free software; you can redistribute it and/or
 + *      modify it under the terms of the GNU General Public License
 + *      as published by the Free Software Foundation; either version
 + *      2 of the License, or (at your option) any later version.
 + *
   * DMA mapping callbacks...
 + * As alloc_coherent is the only DMA callback being used currently, that's
 + * the only thing implemented properly.  The rest need looking into...
   */
  
++<<<<<<< HEAD
 +#include <linux/dma-mapping.h>
 +#include <linux/dma-debug.h>
 +#include <linux/export.h>
++=======
+ #include <linux/dma-map-ops.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  #include <linux/pagewalk.h>
  
  #include <asm/cpuinfo.h>
diff --cc arch/parisc/kernel/pci-dma.c
index 3698738b8d24,36610a5c029f..000000000000
--- a/arch/parisc/kernel/pci-dma.c
+++ b/arch/parisc/kernel/pci-dma.c
@@@ -26,8 -25,8 +26,13 @@@
  #include <linux/seq_file.h>
  #include <linux/string.h>
  #include <linux/types.h>
++<<<<<<< HEAD
 +#include <linux/scatterlist.h>
 +#include <linux/export.h>
++=======
+ #include <linux/dma-direct.h>
+ #include <linux/dma-map-ops.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  
  #include <asm/cacheflush.h>
  #include <asm/dma.h>    /* for DMA_CHUNK_SIZE */
diff --cc arch/powerpc/mm/dma-noncoherent.c
index 07cc2eecc4ee,30260b5d146d..000000000000
--- a/arch/powerpc/mm/dma-noncoherent.c
+++ b/arch/powerpc/mm/dma-noncoherent.c
@@@ -30,8 -11,7 +30,12 @@@
  #include <linux/types.h>
  #include <linux/highmem.h>
  #include <linux/dma-direct.h>
++<<<<<<< HEAD
 +#include <linux/dma-noncoherent.h>
 +#include <linux/export.h>
++=======
+ #include <linux/dma-map-ops.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  
  #include <asm/tlbflush.h>
  #include <asm/dma.h>
diff --cc arch/sparc/kernel/ioport.c
index cca9134cfa7d,8e1d72a16759..000000000000
--- a/arch/sparc/kernel/ioport.c
+++ b/arch/sparc/kernel/ioport.c
@@@ -38,6 -38,7 +38,10 @@@
  #include <linux/proc_fs.h>
  #include <linux/seq_file.h>
  #include <linux/scatterlist.h>
++<<<<<<< HEAD
++=======
+ #include <linux/dma-map-ops.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  #include <linux/of_device.h>
  
  #include <asm/io.h>
diff --cc arch/xtensa/kernel/pci-dma.c
index a02dc563d290,94955caa4488..000000000000
--- a/arch/xtensa/kernel/pci-dma.c
+++ b/arch/xtensa/kernel/pci-dma.c
@@@ -15,7 -11,7 +15,11 @@@
   * Joe Taylor <joe@tensilica.com, joetylr@yahoo.com>
   */
  
++<<<<<<< HEAD
 +#include <linux/dma-contiguous.h>
++=======
+ #include <linux/dma-map-ops.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  #include <linux/dma-direct.h>
  #include <linux/gfp.h>
  #include <linux/highmem.h>
diff --cc kernel/dma/ops_helpers.c
index 5828e5e01b79,910ae69cae77..000000000000
--- a/kernel/dma/ops_helpers.c
+++ b/kernel/dma/ops_helpers.c
@@@ -3,8 -3,7 +3,12 @@@
   * Helpers for DMA ops implementations.  These generally rely on the fact that
   * the allocated memory contains normal pages in the direct kernel mapping.
   */
++<<<<<<< HEAD
 +#include <linux/dma-contiguous.h>
 +#include <linux/dma-noncoherent.h>
++=======
+ #include <linux/dma-map-ops.h>
++>>>>>>> 9f4df96b8781 (dma-mapping: merge <linux/dma-noncoherent.h> into <linux/dma-map-ops.h>)
  
  /*
   * Create scatter-list for the already allocated DMA buffer.
* Unmerged path arch/csky/mm/dma-mapping.c
* Unmerged path arch/mips/mm/dma-noncoherent.c
* Unmerged path arch/sh/kernel/dma-coherent.c
* Unmerged path include/linux/dma-map-ops.h
* Unmerged path include/linux/dma-noncoherent.h
* Unmerged path MAINTAINERS
* Unmerged path arch/arc/mm/dma.c
* Unmerged path arch/arm/mm/dma-mapping.c
* Unmerged path arch/arm/xen/mm.c
* Unmerged path arch/arm64/mm/dma-mapping.c
diff --git a/arch/c6x/mm/dma-coherent.c b/arch/c6x/mm/dma-coherent.c
index 01305c787201..fc99cfff7670 100644
--- a/arch/c6x/mm/dma-coherent.c
+++ b/arch/c6x/mm/dma-coherent.c
@@ -19,7 +19,7 @@
 #include <linux/bitops.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
-#include <linux/dma-noncoherent.h>
+#include <linux/dma-map-ops.h>
 #include <linux/memblock.h>
 
 #include <asm/cacheflush.h>
* Unmerged path arch/csky/mm/dma-mapping.c
* Unmerged path arch/hexagon/kernel/dma.c
* Unmerged path arch/ia64/mm/init.c
* Unmerged path arch/m68k/kernel/dma.c
* Unmerged path arch/microblaze/kernel/dma.c
* Unmerged path arch/microblaze/mm/consistent.c
* Unmerged path arch/mips/jazz/jazzdma.c
* Unmerged path arch/mips/mm/dma-noncoherent.c
* Unmerged path arch/nds32/kernel/dma.c
* Unmerged path arch/openrisc/kernel/dma.c
* Unmerged path arch/parisc/kernel/pci-dma.c
* Unmerged path arch/powerpc/mm/dma-noncoherent.c
* Unmerged path arch/sh/kernel/dma-coherent.c
* Unmerged path arch/sparc/kernel/ioport.c
* Unmerged path arch/xtensa/kernel/pci-dma.c
diff --git a/drivers/iommu/dma-iommu.c b/drivers/iommu/dma-iommu.c
index 7a9d033bfda4..a8380c561e5d 100644
--- a/drivers/iommu/dma-iommu.c
+++ b/drivers/iommu/dma-iommu.c
@@ -23,7 +23,6 @@
 #include <linux/device.h>
 #include <linux/dma-contiguous.h>
 #include <linux/dma-iommu.h>
-#include <linux/dma-noncoherent.h>
 #include <linux/gfp.h>
 #include <linux/huge_mm.h>
 #include <linux/iommu.h>
diff --git a/drivers/xen/swiotlb-xen.c b/drivers/xen/swiotlb-xen.c
index d199863cc446..55cd99f1d809 100644
--- a/drivers/xen/swiotlb-xen.c
+++ b/drivers/xen/swiotlb-xen.c
@@ -37,7 +37,7 @@
 
 #include <linux/memblock.h>
 #include <linux/dma-direct.h>
-#include <linux/dma-noncoherent.h>
+#include <linux/dma-map-ops.h>
 #include <linux/export.h>
 #include <xen/swiotlb-xen.h>
 #include <xen/page.h>
diff --git a/include/linux/dma-direct.h b/include/linux/dma-direct.h
index 28fdd6ebdd10..78067d533049 100644
--- a/include/linux/dma-direct.h
+++ b/include/linux/dma-direct.h
@@ -7,7 +7,7 @@
 #define _LINUX_DMA_DIRECT_H 1
 
 #include <linux/dma-mapping.h>
-#include <linux/dma-noncoherent.h>
+#include <linux/dma-map-ops.h>
 #include <linux/memblock.h> /* for min_low_pfn */
 #include <linux/mem_encrypt.h>
 #include <linux/swiotlb.h>
* Unmerged path include/linux/dma-map-ops.h
* Unmerged path include/linux/dma-noncoherent.h
* Unmerged path kernel/dma/ops_helpers.c
diff --git a/kernel/dma/pool.c b/kernel/dma/pool.c
index fe11643ff9cc..07c3a4238fd4 100644
--- a/kernel/dma/pool.c
+++ b/kernel/dma/pool.c
@@ -7,7 +7,6 @@
 #include <linux/debugfs.h>
 #include <linux/dma-contiguous.h>
 #include <linux/dma-direct.h>
-#include <linux/dma-noncoherent.h>
 #include <linux/init.h>
 #include <linux/genalloc.h>
 #include <linux/set_memory.h>
diff --git a/kernel/dma/swiotlb.c b/kernel/dma/swiotlb.c
index 3c95233605f4..260f2efe23ca 100644
--- a/kernel/dma/swiotlb.c
+++ b/kernel/dma/swiotlb.c
@@ -21,7 +21,7 @@
 
 #include <linux/cache.h>
 #include <linux/dma-direct.h>
-#include <linux/dma-noncoherent.h>
+#include <linux/dma-map-ops.h>
 #include <linux/mm.h>
 #include <linux/export.h>
 #include <linux/spinlock.h>
