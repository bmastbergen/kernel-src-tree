sock_map: Kill sock_map_link_no_progs()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Cong Wang <cong.wang@bytedance.com>
commit b017055255d620b365299c3824610e0098414664
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/b0170552.failed

Now we can fold sock_map_link_no_progs() into sock_map_link()
and get rid of sock_map_link_no_progs().

	Signed-off-by: Cong Wang <cong.wang@bytedance.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20210331023237.41094-9-xiyou.wangcong@gmail.com
(cherry picked from commit b017055255d620b365299c3824610e0098414664)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/sock_map.c
diff --cc net/core/sock_map.c
index f2963865e78e,42d797291d34..000000000000
--- a/net/core/sock_map.c
+++ b/net/core/sock_map.c
@@@ -225,26 -225,37 +225,52 @@@ out
  	return psock;
  }
  
++<<<<<<< HEAD
 +static int sock_map_link(struct bpf_map *map, struct sk_psock_progs *progs,
 +			 struct sock *sk)
 +{
 +	struct bpf_prog *msg_parser, *skb_parser, *skb_verdict;
 +	struct sk_psock *psock;
 +	int ret;
 +
 +	skb_verdict = READ_ONCE(progs->skb_verdict);
 +	if (skb_verdict) {
 +		skb_verdict = bpf_prog_inc_not_zero(skb_verdict);
 +		if (IS_ERR(skb_verdict))
 +			return PTR_ERR(skb_verdict);
++=======
+ static bool sock_map_redirect_allowed(const struct sock *sk);
+ 
+ static int sock_map_link(struct bpf_map *map, struct sock *sk)
+ {
+ 	struct sk_psock_progs *progs = sock_map_progs(map);
+ 	struct bpf_prog *stream_verdict = NULL;
+ 	struct bpf_prog *stream_parser = NULL;
+ 	struct bpf_prog *msg_parser = NULL;
+ 	struct sk_psock *psock;
+ 	int ret;
+ 
+ 	/* Only sockets we can redirect into/from in BPF need to hold
+ 	 * refs to parser/verdict progs and have their sk_data_ready
+ 	 * and sk_write_space callbacks overridden.
+ 	 */
+ 	if (!sock_map_redirect_allowed(sk))
+ 		goto no_progs;
+ 
+ 	stream_verdict = READ_ONCE(progs->stream_verdict);
+ 	if (stream_verdict) {
+ 		stream_verdict = bpf_prog_inc_not_zero(stream_verdict);
+ 		if (IS_ERR(stream_verdict))
+ 			return PTR_ERR(stream_verdict);
++>>>>>>> b017055255d6 (sock_map: Kill sock_map_link_no_progs())
  	}
  
 -	stream_parser = READ_ONCE(progs->stream_parser);
 -	if (stream_parser) {
 -		stream_parser = bpf_prog_inc_not_zero(stream_parser);
 -		if (IS_ERR(stream_parser)) {
 -			ret = PTR_ERR(stream_parser);
 -			goto out_put_stream_verdict;
 +	skb_parser = READ_ONCE(progs->skb_parser);
 +	if (skb_parser) {
 +		skb_parser = bpf_prog_inc_not_zero(skb_parser);
 +		if (IS_ERR(skb_parser)) {
 +			ret = PTR_ERR(skb_parser);
 +			goto out_put_skb_verdict;
  		}
  	}
  
@@@ -488,14 -477,7 +492,18 @@@ static int sock_map_update_common(struc
  	if (!link)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	/* Only sockets we can redirect into/from in BPF need to hold
 +	 * refs to parser/verdict progs and have their sk_data_ready
 +	 * and sk_write_space callbacks overridden.
 +	 */
 +	if (sock_map_redirect_allowed(sk))
 +		ret = sock_map_link(map, &stab->progs, sk);
 +	else
 +		ret = sock_map_link_no_progs(map, sk);
++=======
+ 	ret = sock_map_link(map, sk);
++>>>>>>> b017055255d6 (sock_map: Kill sock_map_link_no_progs())
  	if (ret < 0)
  		goto out_free;
  
@@@ -1002,14 -982,7 +1010,18 @@@ static int sock_hash_update_common(stru
  	if (!link)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	/* Only sockets we can redirect into/from in BPF need to hold
 +	 * refs to parser/verdict progs and have their sk_data_ready
 +	 * and sk_write_space callbacks overridden.
 +	 */
 +	if (sock_map_redirect_allowed(sk))
 +		ret = sock_map_link(map, &htab->progs, sk);
 +	else
 +		ret = sock_map_link_no_progs(map, sk);
++=======
+ 	ret = sock_map_link(map, sk);
++>>>>>>> b017055255d6 (sock_map: Kill sock_map_link_no_progs())
  	if (ret < 0)
  		goto out_free;
  
* Unmerged path net/core/sock_map.c
