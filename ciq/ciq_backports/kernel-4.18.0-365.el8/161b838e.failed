netfilter: nftables: fix incorrect increment of loop counter

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Colin Ian King <colin.king@canonical.com>
commit 161b838e25c6f83495e27e3f546b893622d442bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/161b838e.failed

The intention of the err_expr cleanup path is to iterate over the
allocated expr_array objects and free them, starting from i - 1 and
working down to the start of the array. Currently the loop counter
is being incremented instead of decremented and also the index i is
being used instead of k, repeatedly destroying the same expr_array
element.  Fix this by decrementing k and using k as the index into
expr_array.

Addresses-Coverity: ("Infinite loop")
Fixes: 8cfd9b0f8515 ("netfilter: nftables: generalize set expressions support")
	Signed-off-by: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 161b838e25c6f83495e27e3f546b893622d442bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index 9f4a0cc92500,4186b1e52d58..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -4943,6 -5231,47 +4943,50 @@@ static void nf_tables_set_elem_destroy(
  	kfree(elem);
  }
  
++<<<<<<< HEAD
++=======
+ static int nft_set_elem_expr_clone(const struct nft_ctx *ctx,
+ 				   struct nft_set *set,
+ 				   struct nft_expr *expr_array[])
+ {
+ 	struct nft_expr *expr;
+ 	int err, i, k;
+ 
+ 	for (i = 0; i < set->num_exprs; i++) {
+ 		expr = kzalloc(set->exprs[i]->ops->size, GFP_KERNEL);
+ 		if (!expr)
+ 			goto err_expr;
+ 
+ 		err = nft_expr_clone(expr, set->exprs[i]);
+ 		if (err < 0) {
+ 			nft_expr_destroy(ctx, expr);
+ 			goto err_expr;
+ 		}
+ 		expr_array[i] = expr;
+ 	}
+ 
+ 	return 0;
+ 
+ err_expr:
+ 	for (k = i - 1; k >= 0; k--)
+ 		nft_expr_destroy(ctx, expr_array[k]);
+ 
+ 	return -ENOMEM;
+ }
+ 
+ static void nft_set_elem_expr_setup(const struct nft_set_ext *ext, int i,
+ 				    struct nft_expr *expr_array[])
+ {
+ 	struct nft_set_elem_expr *elem_expr = nft_set_ext_expr(ext);
+ 	struct nft_expr *expr = nft_setelem_expr_at(elem_expr, elem_expr->size);
+ 
+ 	memcpy(expr, expr_array[i], expr_array[i]->ops->size);
+ 	elem_expr->size += expr_array[i]->ops->size;
+ 	kfree(expr_array[i]);
+ 	expr_array[i] = NULL;
+ }
+ 
++>>>>>>> 161b838e25c6 (netfilter: nftables: fix incorrect increment of loop counter)
  static int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,
  			    const struct nlattr *attr, u32 nlmsg_flags)
  {
* Unmerged path net/netfilter/nf_tables_api.c
