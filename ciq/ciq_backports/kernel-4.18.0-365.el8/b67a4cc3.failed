KVM: SEV: Refactor out sev_es_state struct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Peter Gonda <pgonda@google.com>
commit b67a4cc35c9f726999fa29880713ce72d4e39e8d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/b67a4cc3.failed

Move SEV-ES vCPU metadata into new sev_es_state struct from vcpu_svm.

	Signed-off-by: Peter Gonda <pgonda@google.com>
	Suggested-by: Tom Lendacky <thomas.lendacky@amd.com>
	Acked-by: Tom Lendacky <thomas.lendacky@amd.com>
	Reviewed-by: Sean Christopherson <seanjc@google.com>
	Cc: Marc Orr <marcorr@google.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Dr. David Alan Gilbert <dgilbert@redhat.com>
	Cc: Brijesh Singh <brijesh.singh@amd.com>
	Cc: Tom Lendacky <thomas.lendacky@amd.com>
	Cc: Vitaly Kuznetsov <vkuznets@redhat.com>
	Cc: Wanpeng Li <wanpengli@tencent.com>
	Cc: Jim Mattson <jmattson@google.com>
	Cc: Joerg Roedel <joro@8bytes.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: kvm@vger.kernel.org
	Cc: linux-kernel@vger.kernel.org
Message-Id: <20211021174303.385706-2-pgonda@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit b67a4cc35c9f726999fa29880713ce72d4e39e8d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/sev.c
#	arch/x86/kvm/svm/svm.h
diff --cc arch/x86/kvm/svm/sev.c
index 7e244e846ff0,d53f71054475..000000000000
--- a/arch/x86/kvm/svm/sev.c
+++ b/arch/x86/kvm/svm/sev.c
@@@ -617,14 -616,9 +617,14 @@@ static int __sev_launch_update_vmsa(str
  
  	vmsa.reserved = 0;
  	vmsa.handle = to_kvm_svm(kvm)->sev_info.handle;
- 	vmsa.address = __sme_pa(svm->vmsa);
+ 	vmsa.address = __sme_pa(svm->sev_es.vmsa);
  	vmsa.len = PAGE_SIZE;
 -	return sev_issue_cmd(kvm, SEV_CMD_LAUNCH_UPDATE_VMSA, &vmsa, error);
 +	ret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_UPDATE_VMSA, &vmsa, error);
 +	if (ret)
 +	  return ret;
 +
 +	vcpu->arch.guest_state_protected = true;
 +	return 0;
  }
  
  static int sev_launch_update_vmsa(struct kvm *kvm, struct kvm_sev_cmd *argp)
@@@ -2592,20 -2580,11 +2593,25 @@@ int sev_handle_vmgexit(struct kvm_vcpu 
  
  int sev_es_string_io(struct vcpu_svm *svm, int size, unsigned int port, int in)
  {
 -	if (!setup_vmgexit_scratch(svm, in, svm->vmcb->control.exit_info_2))
 +	int count;
 +	int bytes;
 +
 +	if (svm->vmcb->control.exit_info_2 > INT_MAX)
 +		return -EINVAL;
 +
++<<<<<<< HEAD
 +	count = svm->vmcb->control.exit_info_2;
 +	if (unlikely(check_mul_overflow(count, size, &bytes)))
 +		return -EINVAL;
 +
 +	if (!setup_vmgexit_scratch(svm, in, bytes))
  		return -EINVAL;
  
 +	return kvm_sev_es_string_io(&svm->vcpu, size, port, svm->ghcb_sa, count, in);
++=======
+ 	return kvm_sev_es_string_io(&svm->vcpu, size, port, svm->sev_es.ghcb_sa,
+ 				    svm->sev_es.ghcb_sa_len / size, in);
++>>>>>>> b67a4cc35c9f (KVM: SEV: Refactor out sev_es_state struct)
  }
  
  void sev_es_init_vmcb(struct vcpu_svm *svm)
diff --cc arch/x86/kvm/svm/svm.h
index 5d30db599e10,80048841cad9..000000000000
--- a/arch/x86/kvm/svm/svm.h
+++ b/arch/x86/kvm/svm/svm.h
@@@ -183,17 -200,7 +197,21 @@@ struct vcpu_svm 
  		DECLARE_BITMAP(write, MAX_DIRECT_ACCESS_MSRS);
  	} shadow_msr_intercept;
  
++<<<<<<< HEAD
 +	/* SEV-ES support */
 +	struct vmcb_save_area *vmsa;
 +	struct ghcb *ghcb;
 +	struct kvm_host_map ghcb_map;
 +	bool received_first_sipi;
 +
 +	/* SEV-ES scratch area support */
 +	void *ghcb_sa;
 +	u32 ghcb_sa_len;
 +	bool ghcb_sa_sync;
 +	bool ghcb_sa_free;
++=======
+ 	struct vcpu_sev_es_state sev_es;
++>>>>>>> b67a4cc35c9f (KVM: SEV: Refactor out sev_es_state struct)
  
  	bool guest_state_loaded;
  };
* Unmerged path arch/x86/kvm/svm/sev.c
diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.c
index 35e48522a597..22d692652576 100644
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@ -1405,7 +1405,7 @@ static int svm_create_vcpu(struct kvm_vcpu *vcpu)
 	svm->vmcb01.pa = __sme_set(page_to_pfn(vmcb01_page) << PAGE_SHIFT);
 
 	if (vmsa_page)
-		svm->vmsa = page_address(vmsa_page);
+		svm->sev_es.vmsa = page_address(vmsa_page);
 
 	svm->guest_state_loaded = false;
 
@@ -2795,11 +2795,11 @@ static int svm_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 static int svm_complete_emulated_msr(struct kvm_vcpu *vcpu, int err)
 {
 	struct vcpu_svm *svm = to_svm(vcpu);
-	if (!err || !sev_es_guest(vcpu->kvm) || WARN_ON_ONCE(!svm->ghcb))
+	if (!err || !sev_es_guest(vcpu->kvm) || WARN_ON_ONCE(!svm->sev_es.ghcb))
 		return kvm_complete_insn_gp(vcpu, err);
 
-	ghcb_set_sw_exit_info_1(svm->ghcb, 1);
-	ghcb_set_sw_exit_info_2(svm->ghcb,
+	ghcb_set_sw_exit_info_1(svm->sev_es.ghcb, 1);
+	ghcb_set_sw_exit_info_2(svm->sev_es.ghcb,
 				X86_TRAP_GP |
 				SVM_EVTINJ_TYPE_EXEPT |
 				SVM_EVTINJ_VALID);
* Unmerged path arch/x86/kvm/svm/svm.h
