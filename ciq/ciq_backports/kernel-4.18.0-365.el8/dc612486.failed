ACPI: scan: Fix device object rescan in acpi_scan_clear_dep()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit dc612486c91983a113adefedac030575ea7a4c4a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/dc612486.failed

In general, acpi_bus_attach() can only be run safely under
acpi_scan_lock, but that lock cannot be acquired under
acpi_dep_list_lock, so make acpi_scan_clear_dep() schedule deferred
execution of acpi_bus_attach() under acpi_scan_lock instead of
calling it directly.

This also fixes a possible race between acpi_scan_clear_dep() and
device removal that might cause a device object that went away to
be accessed, because acpi_scan_clear_dep() is changed to acquire
a reference on the consumer device object.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Hans de Goede <hdegoede@redhat.com>
(cherry picked from commit dc612486c91983a113adefedac030575ea7a4c4a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
diff --cc drivers/acpi/scan.c
index 70d0d2830632,b0bdd9b90e44..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -2113,10 -2096,95 +2113,99 @@@ static void acpi_bus_attach(struct acpi
  		device->handler->hotplug.notify_online(device);
  }
  
++<<<<<<< HEAD
 +void acpi_walk_dep_device_list(acpi_handle handle)
++=======
+ static int acpi_dev_get_first_consumer_dev_cb(struct acpi_dep_data *dep, void *data)
+ {
+ 	struct acpi_device *adev;
+ 
+ 	adev = acpi_bus_get_acpi_device(dep->consumer);
+ 	if (adev) {
+ 		*(struct acpi_device **)data = adev;
+ 		return 1;
+ 	}
+ 	/* Continue parsing if the device object is not present. */
+ 	return 0;
+ }
+ 
+ struct acpi_scan_clear_dep_work {
+ 	struct work_struct work;
+ 	struct acpi_device *adev;
+ };
+ 
+ static void acpi_scan_clear_dep_fn(struct work_struct *work)
+ {
+ 	struct acpi_scan_clear_dep_work *cdw;
+ 
+ 	cdw = container_of(work, struct acpi_scan_clear_dep_work, work);
+ 
+ 	acpi_scan_lock_acquire();
+ 	acpi_bus_attach(cdw->adev, true);
+ 	acpi_scan_lock_release();
+ 
+ 	acpi_dev_put(cdw->adev);
+ 	kfree(cdw);
+ }
+ 
+ static bool acpi_scan_clear_dep_queue(struct acpi_device *adev)
+ {
+ 	struct acpi_scan_clear_dep_work *cdw;
+ 
+ 	if (adev->dep_unmet)
+ 		return false;
+ 
+ 	cdw = kmalloc(sizeof(*cdw), GFP_KERNEL);
+ 	if (!cdw)
+ 		return false;
+ 
+ 	cdw->adev = adev;
+ 	INIT_WORK(&cdw->work, acpi_scan_clear_dep_fn);
+ 	/*
+ 	 * Since the work function may block on the lock until the entire
+ 	 * initial enumeration of devices is complete, put it into the unbound
+ 	 * workqueue.
+ 	 */
+ 	queue_work(system_unbound_wq, &cdw->work);
+ 
+ 	return true;
+ }
+ 
+ static int acpi_scan_clear_dep(struct acpi_dep_data *dep, void *data)
+ {
+ 	struct acpi_device *adev = acpi_bus_get_acpi_device(dep->consumer);
+ 
+ 	if (adev) {
+ 		adev->dep_unmet--;
+ 		if (!acpi_scan_clear_dep_queue(adev))
+ 			acpi_dev_put(adev);
+ 	}
+ 
+ 	list_del(&dep->node);
+ 	kfree(dep);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * acpi_walk_dep_device_list - Apply a callback to every entry in acpi_dep_list
+  * @handle:	The ACPI handle of the supplier device
+  * @callback:	Pointer to the callback function to apply
+  * @data:	Pointer to some data to pass to the callback
+  *
+  * The return value of the callback determines this function's behaviour. If 0
+  * is returned we continue to iterate over acpi_dep_list. If a positive value
+  * is returned then the loop is broken but this function returns 0. If a
+  * negative value is returned by the callback then the loop is broken and that
+  * value is returned as the final error.
+  */
+ static int acpi_walk_dep_device_list(acpi_handle handle,
+ 				int (*callback)(struct acpi_dep_data *, void *),
+ 				void *data)
++>>>>>>> dc612486c919 (ACPI: scan: Fix device object rescan in acpi_scan_clear_dep())
  {
  	struct acpi_dep_data *dep, *tmp;
 -	int ret = 0;
 +	struct acpi_device *adev;
  
  	mutex_lock(&acpi_dep_list_lock);
  	list_for_each_entry_safe(dep, tmp, &acpi_dep_list, node) {
* Unmerged path drivers/acpi/scan.c
