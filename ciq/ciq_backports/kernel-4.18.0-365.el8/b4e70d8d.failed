netfilter: nftables: add set expression flags

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit b4e70d8dd9ea6bd5d5fb3122586f652326ca09cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/b4e70d8d.failed

The set flag NFT_SET_EXPR provides a hint to the kernel that userspace
supports for multiple expressions per set element. In the same
direction, NFT_DYNSET_F_EXPR specifies that dynset expression defines
multiple expressions per set element.

This allows new userspace software with old kernels to bail out with
EOPNOTSUPP. This update is similar to ef516e8625dd ("netfilter:
nf_tables: reintroduce the NFT_SET_CONCAT flag"). The NFT_SET_EXPR flag
needs to be set on when the NFTA_SET_EXPRESSIONS attribute is specified.
The NFT_SET_EXPR flag is not set on with NFTA_SET_EXPR to retain
backward compatibility in old userspace binaries.

Fixes: 48b0ae046ee9 ("netfilter: nftables: netlink support for several set element expressions")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit b4e70d8dd9ea6bd5d5fb3122586f652326ca09cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
#	net/netfilter/nft_dynset.c
diff --cc net/netfilter/nf_tables_api.c
index 9f4a0cc92500,15c467f1a9dd..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -4145,7 -4289,44 +4145,48 @@@ static int nf_tables_newset(struct net 
  	err = nf_tables_set_alloc_name(&ctx, set, name);
  	kfree(name);
  	if (err < 0)
++<<<<<<< HEAD
 +		goto err2;
++=======
+ 		goto err_set_alloc_name;
+ 
+ 	if (nla[NFTA_SET_EXPR]) {
+ 		expr = nft_set_elem_expr_alloc(&ctx, set, nla[NFTA_SET_EXPR]);
+ 		if (IS_ERR(expr)) {
+ 			err = PTR_ERR(expr);
+ 			goto err_set_alloc_name;
+ 		}
+ 		set->exprs[0] = expr;
+ 		set->num_exprs++;
+ 	} else if (nla[NFTA_SET_EXPRESSIONS]) {
+ 		struct nft_expr *expr;
+ 		struct nlattr *tmp;
+ 		int left;
+ 
+ 		if (!(flags & NFT_SET_EXPR)) {
+ 			err = -EINVAL;
+ 			goto err_set_alloc_name;
+ 		}
+ 		i = 0;
+ 		nla_for_each_nested(tmp, nla[NFTA_SET_EXPRESSIONS], left) {
+ 			if (i == NFT_SET_EXPR_MAX) {
+ 				err = -E2BIG;
+ 				goto err_set_init;
+ 			}
+ 			if (nla_type(tmp) != NFTA_LIST_ELEM) {
+ 				err = -EINVAL;
+ 				goto err_set_init;
+ 			}
+ 			expr = nft_set_elem_expr_alloc(&ctx, set, tmp);
+ 			if (IS_ERR(expr)) {
+ 				err = PTR_ERR(expr);
+ 				goto err_set_init;
+ 			}
+ 			set->exprs[i++] = expr;
+ 			set->num_exprs++;
+ 		}
+ 	}
++>>>>>>> b4e70d8dd9ea (netfilter: nftables: add set expression flags)
  
  	udata = NULL;
  	if (udlen) {
diff --cc net/netfilter/nft_dynset.c
index d04066e5665a,0b053f75cd60..000000000000
--- a/net/netfilter/nft_dynset.c
+++ b/net/netfilter/nft_dynset.c
@@@ -23,8 -19,10 +23,13 @@@ struct nft_dynset 
  	enum nft_registers		sreg_key:8;
  	enum nft_registers		sreg_data:8;
  	bool				invert;
++<<<<<<< HEAD
++=======
+ 	bool				expr;
+ 	u8				num_exprs;
++>>>>>>> b4e70d8dd9ea (netfilter: nftables: add set expression flags)
  	u64				timeout;
 -	struct nft_expr			*expr_array[NFT_SET_EXPR_MAX];
 +	struct nft_expr			*expr;
  	struct nft_set_binding		binding;
  };
  
@@@ -179,16 -237,61 +185,67 @@@ static int nft_dynset_init(const struc
  	} else if (set->flags & NFT_SET_MAP)
  		return -EINVAL;
  
 -	if ((tb[NFTA_DYNSET_EXPR] || tb[NFTA_DYNSET_EXPRESSIONS]) &&
 -	    !(set->flags & NFT_SET_EVAL))
 -		return -EINVAL;
 +	if (tb[NFTA_DYNSET_EXPR] != NULL) {
 +		if (!(set->flags & NFT_SET_EVAL))
 +			return -EINVAL;
  
 -	if (tb[NFTA_DYNSET_EXPR]) {
 -		struct nft_expr *dynset_expr;
 +		priv->expr = nft_set_elem_expr_alloc(ctx, set,
 +						     tb[NFTA_DYNSET_EXPR]);
 +		if (IS_ERR(priv->expr))
 +			return PTR_ERR(priv->expr);
  
++<<<<<<< HEAD
 +		if (set->expr && set->expr->ops != priv->expr->ops) {
++=======
+ 		dynset_expr = nft_dynset_expr_alloc(ctx, set,
+ 						    tb[NFTA_DYNSET_EXPR], 0);
+ 		if (IS_ERR(dynset_expr))
+ 			return PTR_ERR(dynset_expr);
+ 
+ 		priv->num_exprs++;
+ 		priv->expr_array[0] = dynset_expr;
+ 
+ 		if (set->num_exprs > 1 ||
+ 		    (set->num_exprs == 1 &&
+ 		     dynset_expr->ops != set->exprs[0]->ops)) {
+ 			err = -EOPNOTSUPP;
+ 			goto err_expr_free;
+ 		}
+ 	} else if (tb[NFTA_DYNSET_EXPRESSIONS]) {
+ 		struct nft_expr *dynset_expr;
+ 		struct nlattr *tmp;
+ 		int left;
+ 
+ 		if (!priv->expr)
+ 			return -EINVAL;
+ 
+ 		i = 0;
+ 		nla_for_each_nested(tmp, tb[NFTA_DYNSET_EXPRESSIONS], left) {
+ 			if (i == NFT_SET_EXPR_MAX) {
+ 				err = -E2BIG;
+ 				goto err_expr_free;
+ 			}
+ 			if (nla_type(tmp) != NFTA_LIST_ELEM) {
+ 				err = -EINVAL;
+ 				goto err_expr_free;
+ 			}
+ 			dynset_expr = nft_dynset_expr_alloc(ctx, set, tmp, i);
+ 			if (IS_ERR(dynset_expr)) {
+ 				err = PTR_ERR(dynset_expr);
+ 				goto err_expr_free;
+ 			}
+ 			priv->expr_array[i] = dynset_expr;
+ 			priv->num_exprs++;
+ 
+ 			if (set->num_exprs &&
+ 			    dynset_expr->ops != set->exprs[i]->ops) {
+ 				err = -EOPNOTSUPP;
+ 				goto err_expr_free;
+ 			}
+ 			i++;
+ 		}
+ 		if (set->num_exprs && set->num_exprs != i) {
++>>>>>>> b4e70d8dd9ea (netfilter: nftables: add set expression flags)
  			err = -EOPNOTSUPP;
  			goto err_expr_free;
  		}
diff --git a/include/uapi/linux/netfilter/nf_tables.h b/include/uapi/linux/netfilter/nf_tables.h
index 0e84aea666bb..79f422a0c681 100644
--- a/include/uapi/linux/netfilter/nf_tables.h
+++ b/include/uapi/linux/netfilter/nf_tables.h
@@ -276,6 +276,7 @@ enum nft_rule_compat_attributes {
  * @NFT_SET_EVAL: set can be updated from the evaluation path
  * @NFT_SET_OBJECT: set contains stateful objects
  * @NFT_SET_CONCAT: set contains a concatenation
+ * @NFT_SET_EXPR: set contains expressions
  */
 enum nft_set_flags {
 	NFT_SET_ANONYMOUS		= 0x1,
@@ -286,6 +287,7 @@ enum nft_set_flags {
 	NFT_SET_EVAL			= 0x20,
 	NFT_SET_OBJECT			= 0x40,
 	NFT_SET_CONCAT			= 0x80,
+	NFT_SET_EXPR			= 0x100,
 };
 
 /**
@@ -660,6 +662,7 @@ enum nft_dynset_ops {
 
 enum nft_dynset_flags {
 	NFT_DYNSET_F_INV	= (1 << 0),
+	NFT_DYNSET_F_EXPR	= (1 << 1),
 };
 
 /**
* Unmerged path net/netfilter/nf_tables_api.c
* Unmerged path net/netfilter/nft_dynset.c
