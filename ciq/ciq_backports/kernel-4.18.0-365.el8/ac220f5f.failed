drm/i915/display/psr: Handle plane and pipe restrictions at every page flip

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author José Roberto de Souza <jose.souza@intel.com>
commit ac220f5f754b1d2f4a69428f515c3f1b10d1fad0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/ac220f5f.failed

PSR2 selective is not supported over rotated and scaled planes.
We had the rotation check in intel_psr2_sel_fetch_config_valid()
but that code path is only execute when a modeset is needed and
those plane parameters can change without a modeset.

Pipe selective fetch restrictions are also needed, it could be added
in intel_psr_compute_config() but pippe scaling is computed after
it is executed, so leaving as is for now.
There is no much loss in this approach as it would cause selective
fetch to not enabled as for alderlake-P and newer will cause it to
switch to PSR1 that will have the same power-savings as do full pipe
fetch.

Also need to check those restricions in the second
for_each_oldnew_intel_plane_in_state() loop because the state could
only have a plane that is not affected by those restricitons but
the damaged area intersect with planes that has those restrictions,
so a full pipe fetch is required.

v2:
- also handling pipe restrictions

BSpec: 55229
	Reviewed-by: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com> # v1
	Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
	Cc: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
	Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210930001409.254817-1-jose.souza@intel.com
(cherry picked from commit ac220f5f754b1d2f4a69428f515c3f1b10d1fad0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_psr.c
diff --cc drivers/gpu/drm/i915/display/intel_psr.c
index 2c6c4a4f9477,3cdd193ddb13..000000000000
--- a/drivers/gpu/drm/i915/display/intel_psr.c
+++ b/drivers/gpu/drm/i915/display/intel_psr.c
@@@ -685,13 -720,10 +685,9 @@@ tgl_dc3co_exitline_compute_config(struc
  static bool intel_psr2_sel_fetch_config_valid(struct intel_dp *intel_dp,
  					      struct intel_crtc_state *crtc_state)
  {
- 	struct intel_atomic_state *state = to_intel_atomic_state(crtc_state->uapi.state);
  	struct drm_i915_private *dev_priv = dp_to_i915(intel_dp);
- 	struct intel_plane_state *plane_state;
- 	struct intel_plane *plane;
- 	int i;
  
 -	if (!dev_priv->params.enable_psr2_sel_fetch &&
 -	    intel_dp->psr.debug != I915_PSR_DEBUG_ENABLE_SEL_FETCH) {
 +	if (!dev_priv->params.enable_psr2_sel_fetch) {
  		drm_dbg_kms(&dev_priv->drm,
  			    "PSR2 sel fetch not enabled, disabled by parameter\n");
  		return false;
@@@ -703,12 -735,11 +699,20 @@@
  		return false;
  	}
  
++<<<<<<< HEAD
 +	for_each_new_intel_plane_in_state(state, plane, plane_state, i) {
 +		if (plane_state->uapi.rotation != DRM_MODE_ROTATE_0) {
 +			drm_dbg_kms(&dev_priv->drm,
 +				    "PSR2 sel fetch not enabled, plane rotated\n");
 +			return false;
 +		}
++=======
+ 	/* Wa_14010254185 Wa_14010103792 */
+ 	if (IS_TGL_DISPLAY_STEP(dev_priv, STEP_A0, STEP_C0)) {
+ 		drm_dbg_kms(&dev_priv->drm,
+ 			    "PSR2 sel fetch not enabled, missing the implementation of WAs\n");
+ 		return false;
++>>>>>>> ac220f5f754b (drm/i915/display/psr: Handle plane and pipe restrictions at every page flip)
  	}
  
  	return crtc_state->enable_psr2_sel_fetch = true;
@@@ -1309,6 -1532,77 +1313,80 @@@ static void clip_area_update(struct drm
  		overlap_damage_area->y2 = damage_area->y2;
  }
  
++<<<<<<< HEAD
++=======
+ static void intel_psr2_sel_fetch_pipe_alignment(const struct intel_crtc_state *crtc_state,
+ 						struct drm_rect *pipe_clip)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);
+ 	const u16 y_alignment = crtc_state->su_y_granularity;
+ 
+ 	pipe_clip->y1 -= pipe_clip->y1 % y_alignment;
+ 	if (pipe_clip->y2 % y_alignment)
+ 		pipe_clip->y2 = ((pipe_clip->y2 / y_alignment) + 1) * y_alignment;
+ 
+ 	if (IS_ALDERLAKE_P(dev_priv) && crtc_state->dsc.compression_enable)
+ 		drm_warn(&dev_priv->drm, "Missing PSR2 sel fetch alignment with DSC\n");
+ }
+ 
+ /*
+  * FIXME: Not sure why but when moving the cursor fast it causes some artifacts
+  * of the cursor to be left in the cursor path, adding some pixels above the
+  * cursor to the damaged area fixes the issue.
+  */
+ static void cursor_area_workaround(const struct intel_plane_state *new_plane_state,
+ 				   struct drm_rect *damaged_area,
+ 				   struct drm_rect *pipe_clip)
+ {
+ 	const struct intel_plane *plane = to_intel_plane(new_plane_state->uapi.plane);
+ 	int height;
+ 
+ 	if (plane->id != PLANE_CURSOR)
+ 		return;
+ 
+ 	height = drm_rect_height(&new_plane_state->uapi.dst) / 2;
+ 	damaged_area->y1 -=  height;
+ 	damaged_area->y1 = max(damaged_area->y1, 0);
+ 
+ 	clip_area_update(pipe_clip, damaged_area);
+ }
+ 
+ /*
+  * TODO: Not clear how to handle planes with negative position,
+  * also planes are not updated if they have a negative X
+  * position so for now doing a full update in this cases
+  *
+  * Plane scaling and rotation is not supported by selective fetch and both
+  * properties can change without a modeset, so need to be check at every
+  * atomic commmit.
+  */
+ static bool psr2_sel_fetch_plane_state_supported(const struct intel_plane_state *plane_state)
+ {
+ 	if (plane_state->uapi.dst.y1 < 0 ||
+ 	    plane_state->uapi.dst.x1 < 0 ||
+ 	    plane_state->scaler_id >= 0 ||
+ 	    plane_state->uapi.rotation != DRM_MODE_ROTATE_0)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ /*
+  * Check for pipe properties that is not supported by selective fetch.
+  *
+  * TODO: pipe scaling causes a modeset but skl_update_scaler_crtc() is executed
+  * after intel_psr_compute_config(), so for now keeping PSR2 selective fetch
+  * enabled and going to the full update path.
+  */
+ static bool psr2_sel_fetch_pipe_state_supported(const struct intel_crtc_state *crtc_state)
+ {
+ 	if (crtc_state->scaler_state.scaler_id >= 0)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
++>>>>>>> ac220f5f754b (drm/i915/display/psr: Handle plane and pipe restrictions at every page flip)
  int intel_psr2_sel_fetch_update(struct intel_atomic_state *state,
  				struct intel_crtc *crtc)
  {
@@@ -1322,9 -1616,10 +1400,16 @@@
  	if (!crtc_state->enable_psr2_sel_fetch)
  		return 0;
  
++<<<<<<< HEAD
 +	ret = drm_atomic_add_affected_planes(&state->base, &crtc->base);
 +	if (ret)
 +		return ret;
++=======
+ 	if (!psr2_sel_fetch_pipe_state_supported(crtc_state)) {
+ 		full_update = true;
+ 		goto skip_sel_fetch_set_loop;
+ 	}
++>>>>>>> ac220f5f754b (drm/i915/display/psr: Handle plane and pipe restrictions at every page flip)
  
  	/*
  	 * Calculate minimal selective fetch area of each plane and calculate
* Unmerged path drivers/gpu/drm/i915/display/intel_psr.c
