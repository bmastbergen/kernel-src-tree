bnxt_en: Improve wait for firmware commands completion

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Pavan Chebbi <pavan.chebbi@broadcom.com>
commit 80a9641f09f890a27a57e8ad30472553e0f769a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/80a9641f.failed

In situations where FW has crashed, the bnxt_hwrm_do_send_msg() call
will have to wait until timeout for each firmware message.  This
generally takes about half a second for each firmware message.  If we
try to unload the driver n this state, the unload sequence will take
a long time to complete.

Improve this by checking the health register if it is available and
abort the wait for the firmware response if the register shows that
firmware is not healthy.  The very first message HWRM_VER_GET is
excluded from this check because that message is used to poll for
firmware to come out of reset during error recovery.

	Signed-off-by: Pavan Chebbi <pavan.chebbi@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 80a9641f09f890a27a57e8ad30472553e0f769a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 26cd8c410fc6,deba552465f6..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -7568,6 -7547,32 +7575,35 @@@ static void __bnxt_map_fw_health_reg(st
  					 BNXT_FW_HEALTH_WIN_MAP_OFF);
  }
  
++<<<<<<< HEAD
++=======
+ bool bnxt_is_fw_healthy(struct bnxt *bp)
+ {
+ 	if (bp->fw_health && bp->fw_health->status_reliable) {
+ 		u32 fw_status;
+ 
+ 		fw_status = bnxt_fw_health_readl(bp, BNXT_FW_HEALTH_REG);
+ 		if (fw_status && !BNXT_FW_IS_HEALTHY(fw_status))
+ 			return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static void bnxt_inv_fw_health_reg(struct bnxt *bp)
+ {
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 	u32 reg_type;
+ 
+ 	if (!fw_health || !fw_health->status_reliable)
+ 		return;
+ 
+ 	reg_type = BNXT_FW_HEALTH_REG_TYPE(fw_health->regs[BNXT_FW_HEALTH_REG]);
+ 	if (reg_type == BNXT_FW_HEALTH_REG_TYPE_GRC)
+ 		fw_health->status_reliable = false;
+ }
+ 
++>>>>>>> 80a9641f09f8 (bnxt_en: Improve wait for firmware commands completion)
  static void bnxt_try_map_fw_health_reg(struct bnxt *bp)
  {
  	void __iomem *hs;
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.h b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
index 7078f9ca9b3f..886f242ffe70 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@ -668,6 +668,10 @@ struct nqe_cn {
 #define HWRM_MIN_TIMEOUT		25
 #define HWRM_MAX_TIMEOUT		40
 
+#define HWRM_WAIT_MUST_ABORT(bp, req)					\
+	(le16_to_cpu((req)->req_type) != HWRM_VER_GET &&		\
+	 !bnxt_is_fw_healthy(bp))
+
 #define HWRM_TOTAL_TIMEOUT(n)	(((n) <= HWRM_SHORT_TIMEOUT_COUNTER) ?	\
 	((n) * HWRM_SHORT_MIN_TIMEOUT) :				\
 	(HWRM_SHORT_TIMEOUT_COUNTER * HWRM_SHORT_MIN_TIMEOUT +		\
@@ -2234,6 +2238,7 @@ int bnxt_hwrm_set_link_setting(struct bnxt *, bool, bool);
 int bnxt_hwrm_alloc_wol_fltr(struct bnxt *bp);
 int bnxt_hwrm_free_wol_fltr(struct bnxt *bp);
 int bnxt_hwrm_func_resc_qcaps(struct bnxt *bp, bool all);
+bool bnxt_is_fw_healthy(struct bnxt *bp);
 int bnxt_hwrm_fw_set_time(struct bnxt *);
 int bnxt_open_nic(struct bnxt *, bool, bool);
 int bnxt_half_open_nic(struct bnxt *bp);
