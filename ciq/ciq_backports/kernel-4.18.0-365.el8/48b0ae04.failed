netfilter: nftables: netlink support for several set element expressions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 48b0ae046ee96eac999839f6d26c624b8c93ed66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/48b0ae04.failed

This patch adds three new netlink attributes to encapsulate a list of
expressions per set elements:

- NFTA_SET_EXPRESSIONS: this attribute provides the set definition in
  terms of expressions. New set elements get attached the list of
  expressions that is specified by this new netlink attribute.
- NFTA_SET_ELEM_EXPRESSIONS: this attribute allows users to restore (or
  initialize) the stateful information of set elements when adding an
  element to the set.
- NFTA_DYNSET_EXPRESSIONS: this attribute specifies the list of
  expressions that the set element gets when it is inserted from the
  packet path.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 48b0ae046ee96eac999839f6d26c624b8c93ed66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/netfilter/nf_tables.h
#	net/netfilter/nf_tables_api.c
#	net/netfilter/nft_dynset.c
diff --cc include/uapi/linux/netfilter/nf_tables.h
index 0e84aea666bb,28b6ee53305f..000000000000
--- a/include/uapi/linux/netfilter/nf_tables.h
+++ b/include/uapi/linux/netfilter/nf_tables.h
@@@ -343,6 -360,8 +343,11 @@@ enum nft_set_field_attributes 
   * @NFTA_SET_USERDATA: user data (NLA_BINARY)
   * @NFTA_SET_OBJ_TYPE: stateful object type (NLA_U32: NFT_OBJECT_*)
   * @NFTA_SET_HANDLE: set handle (NLA_U64)
++<<<<<<< HEAD
++=======
+  * @NFTA_SET_EXPR: set expression (NLA_NESTED: nft_expr_attributes)
+  * @NFTA_SET_EXPRESSIONS: list of expressions (NLA_NESTED: nft_list_attributes)
++>>>>>>> 48b0ae046ee9 (netfilter: nftables: netlink support for several set element expressions)
   */
  enum nft_set_attributes {
  	NFTA_SET_UNSPEC,
@@@ -362,6 -381,8 +367,11 @@@
  	NFTA_SET_PAD,
  	NFTA_SET_OBJ_TYPE,
  	NFTA_SET_HANDLE,
++<<<<<<< HEAD
++=======
+ 	NFTA_SET_EXPR,
+ 	NFTA_SET_EXPRESSIONS,
++>>>>>>> 48b0ae046ee9 (netfilter: nftables: netlink support for several set element expressions)
  	__NFTA_SET_MAX
  };
  #define NFTA_SET_MAX		(__NFTA_SET_MAX - 1)
diff --cc net/netfilter/nf_tables_api.c
index 846331e7436a,243e3c2c7629..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -3458,6 -3565,8 +3458,11 @@@ static const struct nla_policy nft_set_
  					    .len  = NFT_USERDATA_MAXLEN },
  	[NFTA_SET_OBJ_TYPE]		= { .type = NLA_U32 },
  	[NFTA_SET_HANDLE]		= { .type = NLA_U64 },
++<<<<<<< HEAD
++=======
+ 	[NFTA_SET_EXPR]			= { .type = NLA_NESTED },
+ 	[NFTA_SET_EXPRESSIONS]		= { .type = NLA_NESTED },
++>>>>>>> 48b0ae046ee9 (netfilter: nftables: netlink support for several set element expressions)
  };
  
  static const struct nla_policy nft_set_desc_policy[NFTA_SET_DESC_MAX + 1] = {
@@@ -3661,9 -3771,10 +3666,10 @@@ static int nf_tables_fill_set(struct sk
  {
  	struct nfgenmsg *nfmsg;
  	struct nlmsghdr *nlh;
 +	struct nlattr *desc;
  	u32 portid = ctx->portid;
 -	struct nlattr *nest;
  	u32 seq = ctx->seq;
+ 	int i;
  
  	event = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);
  	nlh = nlmsg_put(skb, portid, seq, event, sizeof(struct nfgenmsg),
@@@ -3731,7 -3841,26 +3737,30 @@@
  	    nf_tables_fill_set_concat(skb, set))
  		goto nla_put_failure;
  
++<<<<<<< HEAD
 +	nla_nest_end(skb, desc);
++=======
+ 	nla_nest_end(skb, nest);
+ 
+ 	if (set->num_exprs == 1) {
+ 		nest = nla_nest_start_noflag(skb, NFTA_SET_EXPR);
+ 		if (nf_tables_fill_expr_info(skb, set->exprs[0]) < 0)
+ 			goto nla_put_failure;
+ 
+ 		nla_nest_end(skb, nest);
+ 	} else if (set->num_exprs > 1) {
+ 		nest = nla_nest_start_noflag(skb, NFTA_SET_EXPRESSIONS);
+ 		if (nest == NULL)
+ 			goto nla_put_failure;
+ 
+ 		for (i = 0; i < set->num_exprs; i++) {
+ 			if (nft_expr_dump(skb, NFTA_LIST_ELEM,
+ 					  set->exprs[i]) < 0)
+ 				goto nla_put_failure;
+ 		}
+ 		nla_nest_end(skb, nest);
+ 	}
++>>>>>>> 48b0ae046ee9 (netfilter: nftables: netlink support for several set element expressions)
  
  	nlmsg_end(skb, nlh);
  	return 0;
@@@ -4144,7 -4284,40 +4173,44 @@@ static int nf_tables_newset(struct net 
  	err = nf_tables_set_alloc_name(&ctx, set, name);
  	kfree(name);
  	if (err < 0)
++<<<<<<< HEAD
 +		goto err2;
++=======
+ 		goto err_set_alloc_name;
+ 
+ 	if (nla[NFTA_SET_EXPR]) {
+ 		expr = nft_set_elem_expr_alloc(&ctx, set, nla[NFTA_SET_EXPR]);
+ 		if (IS_ERR(expr)) {
+ 			err = PTR_ERR(expr);
+ 			goto err_set_alloc_name;
+ 		}
+ 		set->exprs[0] = expr;
+ 		set->num_exprs++;
+ 	} else if (nla[NFTA_SET_EXPRESSIONS]) {
+ 		struct nft_expr *expr;
+ 		struct nlattr *tmp;
+ 		int left;
+ 
+ 		i = 0;
+ 		nla_for_each_nested(tmp, nla[NFTA_SET_EXPRESSIONS], left) {
+ 			if (i == NFT_SET_EXPR_MAX) {
+ 				err = -E2BIG;
+ 				goto err_set_init;
+ 			}
+ 			if (nla_type(tmp) != NFTA_LIST_ELEM) {
+ 				err = -EINVAL;
+ 				goto err_set_init;
+ 			}
+ 			expr = nft_set_elem_expr_alloc(&ctx, set, tmp);
+ 			if (IS_ERR(expr)) {
+ 				err = PTR_ERR(expr);
+ 				goto err_set_init;
+ 			}
+ 			set->exprs[i++] = expr;
+ 			set->num_exprs++;
+ 		}
+ 	}
++>>>>>>> 48b0ae046ee9 (netfilter: nftables: netlink support for several set element expressions)
  
  	udata = NULL;
  	if (udlen) {
@@@ -4406,6 -4610,43 +4473,46 @@@ static int nft_ctx_init_from_elemattr(s
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int nft_set_elem_expr_dump(struct sk_buff *skb,
+ 				  const struct nft_set *set,
+ 				  const struct nft_set_ext *ext)
+ {
+ 	struct nft_set_elem_expr *elem_expr;
+ 	u32 size, num_exprs = 0;
+ 	struct nft_expr *expr;
+ 	struct nlattr *nest;
+ 
+ 	elem_expr = nft_set_ext_expr(ext);
+ 	nft_setelem_expr_foreach(expr, elem_expr, size)
+ 		num_exprs++;
+ 
+ 	if (num_exprs == 1) {
+ 		expr = nft_setelem_expr_at(elem_expr, 0);
+ 		if (nft_expr_dump(skb, NFTA_SET_ELEM_EXPR, expr) < 0)
+ 			return -1;
+ 
+ 		return 0;
+ 	} else if (num_exprs > 1) {
+ 		nest = nla_nest_start_noflag(skb, NFTA_SET_ELEM_EXPRESSIONS);
+ 		if (nest == NULL)
+ 			goto nla_put_failure;
+ 
+ 		nft_setelem_expr_foreach(expr, elem_expr, size) {
+ 			expr = nft_setelem_expr_at(elem_expr, size);
+ 			if (nft_expr_dump(skb, NFTA_LIST_ELEM, expr) < 0)
+ 				goto nla_put_failure;
+ 		}
+ 		nla_nest_end(skb, nest);
+ 	}
+ 	return 0;
+ 
+ nla_put_failure:
+ 	return -1;
+ }
+ 
++>>>>>>> 48b0ae046ee9 (netfilter: nftables: netlink support for several set element expressions)
  static int nf_tables_fill_setelem(struct sk_buff *skb,
  				  const struct nft_set *set,
  				  const struct nft_set_elem *elem)
@@@ -5008,6 -5335,74 +5116,77 @@@ static int nft_add_set_elem(struct nft_
  		timeout = set->timeout;
  	}
  
++<<<<<<< HEAD
++=======
+ 	expiration = 0;
+ 	if (nla[NFTA_SET_ELEM_EXPIRATION] != NULL) {
+ 		if (!(set->flags & NFT_SET_TIMEOUT))
+ 			return -EINVAL;
+ 		err = nf_msecs_to_jiffies64(nla[NFTA_SET_ELEM_EXPIRATION],
+ 					    &expiration);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (nla[NFTA_SET_ELEM_EXPR]) {
+ 		struct nft_expr *expr;
+ 
+ 		if (set->num_exprs != 1)
+ 			return -EOPNOTSUPP;
+ 
+ 		expr = nft_set_elem_expr_alloc(ctx, set,
+ 					       nla[NFTA_SET_ELEM_EXPR]);
+ 		if (IS_ERR(expr))
+ 			return PTR_ERR(expr);
+ 
+ 		expr_array[0] = expr;
+ 
+ 		if (set->exprs[0] && set->exprs[0]->ops != expr->ops) {
+ 			err = -EOPNOTSUPP;
+ 			goto err_set_elem_expr;
+ 		}
+ 	} else if (nla[NFTA_SET_ELEM_EXPRESSIONS]) {
+ 		struct nft_expr *expr;
+ 		struct nlattr *tmp;
+ 		int left;
+ 
+ 		if (set->num_exprs == 0)
+ 			return -EOPNOTSUPP;
+ 
+ 		i = 0;
+ 		nla_for_each_nested(tmp, nla[NFTA_SET_ELEM_EXPRESSIONS], left) {
+ 			if (i == set->num_exprs) {
+ 				err = -E2BIG;
+ 				goto err_set_elem_expr;
+ 			}
+ 			if (nla_type(tmp) != NFTA_LIST_ELEM) {
+ 				err = -EINVAL;
+ 				goto err_set_elem_expr;
+ 			}
+ 			expr = nft_set_elem_expr_alloc(ctx, set, tmp);
+ 			if (IS_ERR(expr)) {
+ 				err = PTR_ERR(expr);
+ 				goto err_set_elem_expr;
+ 			}
+ 			expr_array[i] = expr;
+ 
+ 			if (expr->ops != set->exprs[i]->ops) {
+ 				err = -EOPNOTSUPP;
+ 				goto err_set_elem_expr;
+ 			}
+ 			i++;
+ 		}
+ 		if (set->num_exprs != i) {
+ 			err = -EOPNOTSUPP;
+ 			goto err_set_elem_expr;
+ 		}
+ 	} else if (set->num_exprs > 0) {
+ 		err = nft_set_elem_expr_clone(ctx, set, expr_array);
+ 		if (err < 0)
+ 			goto err_set_elem_expr_clone;
+ 	}
+ 
++>>>>>>> 48b0ae046ee9 (netfilter: nftables: netlink support for several set element expressions)
  	err = nft_setelem_parse_key(ctx, set, &elem.key.val,
  				    nla[NFTA_SET_ELEM_KEY]);
  	if (err < 0)
diff --cc net/netfilter/nft_dynset.c
index abb6d9645c0c,13c426d5dcf9..000000000000
--- a/net/netfilter/nft_dynset.c
+++ b/net/netfilter/nft_dynset.c
@@@ -179,16 -233,24 +180,30 @@@ static int nft_dynset_init(const struc
  	} else if (set->flags & NFT_SET_MAP)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (tb[NFTA_DYNSET_EXPR] != NULL) {
 +		if (!(set->flags & NFT_SET_EVAL))
 +			return -EINVAL;
 +
 +		priv->expr = nft_set_elem_expr_alloc(ctx, set,
 +						     tb[NFTA_DYNSET_EXPR]);
 +		if (IS_ERR(priv->expr))
 +			return PTR_ERR(priv->expr);
++=======
+ 	if ((tb[NFTA_DYNSET_EXPR] || tb[NFTA_DYNSET_EXPRESSIONS]) &&
+ 	    !(set->flags & NFT_SET_EVAL))
+ 		return -EINVAL;
+ 
+ 	if (tb[NFTA_DYNSET_EXPR]) {
+ 		struct nft_expr *dynset_expr;
+ 
+ 		dynset_expr = nft_dynset_expr_alloc(ctx, set,
+ 						    tb[NFTA_DYNSET_EXPR], 0);
+ 		if (IS_ERR(dynset_expr))
+ 			return PTR_ERR(dynset_expr);
++>>>>>>> 48b0ae046ee9 (netfilter: nftables: netlink support for several set element expressions)
  
 -		priv->num_exprs++;
 -		priv->expr_array[0] = dynset_expr;
 -
 -		if (set->num_exprs > 1 ||
 -		    (set->num_exprs == 1 &&
 -		     dynset_expr->ops != set->exprs[0]->ops)) {
 +		if (set->expr && set->expr->ops != priv->expr->ops) {
  			err = -EOPNOTSUPP;
  			goto err_expr_free;
  		}
@@@ -265,11 -366,26 +315,31 @@@ static int nft_dynset_dump(struct sk_bu
  	if (nla_put_string(skb, NFTA_DYNSET_SET_NAME, priv->set->name))
  		goto nla_put_failure;
  	if (nla_put_be64(skb, NFTA_DYNSET_TIMEOUT,
 -			 cpu_to_be64(jiffies_to_msecs(priv->timeout)),
 +			 nf_jiffies64_to_msecs(priv->timeout),
  			 NFTA_DYNSET_PAD))
  		goto nla_put_failure;
++<<<<<<< HEAD
 +	if (priv->expr && nft_expr_dump(skb, NFTA_DYNSET_EXPR, priv->expr))
 +		goto nla_put_failure;
++=======
+ 	if (priv->num_exprs == 1) {
+ 		if (nft_expr_dump(skb, NFTA_DYNSET_EXPR, priv->expr_array[0]))
+ 			goto nla_put_failure;
+ 	} else if (priv->num_exprs > 1) {
+ 		struct nlattr *nest;
+ 
+ 		nest = nla_nest_start_noflag(skb, NFTA_DYNSET_EXPRESSIONS);
+ 		if (!nest)
+ 			goto nla_put_failure;
+ 
+ 		for (i = 0; i < priv->num_exprs; i++) {
+ 			if (nft_expr_dump(skb, NFTA_LIST_ELEM,
+ 					  priv->expr_array[i]))
+ 				goto nla_put_failure;
+ 		}
+ 		nla_nest_end(skb, nest);
+ 	}
++>>>>>>> 48b0ae046ee9 (netfilter: nftables: netlink support for several set element expressions)
  	if (nla_put_be32(skb, NFTA_DYNSET_FLAGS, htonl(flags)))
  		goto nla_put_failure;
  	return 0;
* Unmerged path include/uapi/linux/netfilter/nf_tables.h
* Unmerged path net/netfilter/nf_tables_api.c
* Unmerged path net/netfilter/nft_dynset.c
