x86/fpu: Prepare for sanitizing KVM FPU code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 75c52dad5e327605f1025f399dafdf4aaf5dae9c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/75c52dad.failed

For the upcoming AMX support it's necessary to do a proper integration with
KVM. To avoid more nasty hackery in KVM which violate encapsulation extend
struct fpu and fpstate so the fpstate switching can be consolidated and
simplified.

Currently KVM allocates two FPU structs which are used for saving the user
state of the vCPU thread and restoring the guest state when entering
vcpu_run() and doing the reverse operation before leaving vcpu_run().

With the new fpstate mechanism this can be reduced to one extra buffer by
swapping the fpstate pointer in current::thread::fpu. This makes the
upcoming support for AMX and XFD simpler because then fpstate information
(features, sizes, xfd) are always consistent and it does not require any
nasty workarounds.

Add fpu::__task_fpstate to save the regular fpstate pointer while the task
is inside vcpu_run(). Add some state fields to fpstate to indicate the
nature of the state.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20211022185312.896403942@linutronix.de
(cherry picked from commit 75c52dad5e327605f1025f399dafdf4aaf5dae9c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/fpu/types.h
diff --cc arch/x86/include/asm/fpu/types.h
index 696fdf451047,c72cb2269adc..000000000000
--- a/arch/x86/include/asm/fpu/types.h
+++ b/arch/x86/include/asm/fpu/types.h
@@@ -311,6 -309,49 +311,52 @@@ union fpregs_state 
  	u8 __padding[PAGE_SIZE];
  };
  
++<<<<<<< HEAD
++=======
+ struct fpstate {
+ 	/* @kernel_size: The size of the kernel register image */
+ 	unsigned int		size;
+ 
+ 	/* @user_size: The size in non-compacted UABI format */
+ 	unsigned int		user_size;
+ 
+ 	/* @xfeatures:		xfeatures for which the storage is sized */
+ 	u64			xfeatures;
+ 
+ 	/* @user_xfeatures:	xfeatures valid in UABI buffers */
+ 	u64			user_xfeatures;
+ 
+ 	/* @is_valloc:		Indicator for dynamically allocated state */
+ 	unsigned int		is_valloc	: 1;
+ 
+ 	/* @is_guest:		Indicator for guest state (KVM) */
+ 	unsigned int		is_guest	: 1;
+ 
+ 	/*
+ 	 * @is_confidential:	Indicator for KVM confidential mode.
+ 	 *			The FPU registers are restored by the
+ 	 *			vmentry firmware from encrypted guest
+ 	 *			memory. On vmexit the FPU registers are
+ 	 *			saved by firmware to encrypted guest memory
+ 	 *			and the registers are scrubbed before
+ 	 *			returning to the host. So there is no
+ 	 *			content which is worth saving and restoring.
+ 	 *			The fpstate has to be there so that
+ 	 *			preemption and softirq FPU usage works
+ 	 *			without special casing.
+ 	 */
+ 	unsigned int		is_confidential	: 1;
+ 
+ 	/* @in_use:		State is in use */
+ 	unsigned int		in_use		: 1;
+ 
+ 	/* @regs: The register state union for all supported formats */
+ 	union fpregs_state	regs;
+ 
+ 	/* @regs is dynamically sized! Don't add anything after @regs! */
+ } __aligned(64);
+ 
++>>>>>>> 75c52dad5e32 (x86/fpu: Prepare for sanitizing KVM FPU code)
  /*
   * Highest level per task FPU state data structure that
   * contains the FPU register state plus various FPU
@@@ -331,20 -372,40 +377,41 @@@ struct fpu 
  	 */
  	unsigned int			last_cpu;
  
 -	/*
 -	 * @avx512_timestamp:
 -	 *
 -	 * Records the timestamp of AVX512 use during last context switch.
 -	 */
 -	unsigned long			avx512_timestamp;
 +	RH_KABI_DEPRECATE(unsigned char, initialized)
  
  	/*
 -	 * @fpstate:
 +	 * @state:
  	 *
 -	 * Pointer to the active struct fpstate. Initialized to
 -	 * point at @__fpstate below.
 +	 * In-memory copy of all FPU registers that we save/restore
 +	 * over context switches. If the task is using the FPU then
 +	 * the registers in the FPU are more recent than this state
 +	 * copy. If the task context-switches away then they get
 +	 * saved here and represent the FPU state.
  	 */
 -	struct fpstate			*fpstate;
 -
 +	union fpregs_state		state;
  	/*
++<<<<<<< HEAD
 +	 * WARNING: 'state' is dynamically-sized.  Do not put
++=======
+ 	 * @__task_fpstate:
+ 	 *
+ 	 * Pointer to an inactive struct fpstate. Initialized to NULL. Is
+ 	 * used only for KVM support to swap out the regular task fpstate.
+ 	 */
+ 	struct fpstate			*__task_fpstate;
+ 
+ 	/*
+ 	 * @__fpstate:
+ 	 *
+ 	 * Initial in-memory storage for FPU registers which are saved in
+ 	 * context switch and when the kernel uses the FPU. The registers
+ 	 * are restored from this storage on return to user space if they
+ 	 * are not longer containing the tasks FPU register state.
+ 	 */
+ 	struct fpstate			__fpstate;
+ 	/*
+ 	 * WARNING: '__fpstate' is dynamically-sized.  Do not put
++>>>>>>> 75c52dad5e32 (x86/fpu: Prepare for sanitizing KVM FPU code)
  	 * anything after it here.
  	 */
  };
* Unmerged path arch/x86/include/asm/fpu/types.h
