KVM: SVM: Do not terminate SEV-ES guests on GHCB validation failure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Tom Lendacky <thomas.lendacky@amd.com>
commit ad5b353240c8837109d1bcc6c3a9a501d7f6a960
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/ad5b3532.failed

Currently, an SEV-ES guest is terminated if the validation of the VMGEXIT
exit code or exit parameters fails.

The VMGEXIT instruction can be issued from userspace, even though
userspace (likely) can't update the GHCB. To prevent userspace from being
able to kill the guest, return an error through the GHCB when validation
fails rather than terminating the guest. For cases where the GHCB can't be
updated (e.g. the GHCB can't be mapped, etc.), just return back to the
guest.

The new error codes are documented in the lasest update to the GHCB
specification.

Fixes: 291bd20d5d88 ("KVM: SVM: Add initial support for a VMGEXIT VMEXIT")
	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
Message-Id: <b57280b5562893e2616257ac9c2d4525a9aeeb42.1638471124.git.thomas.lendacky@amd.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit ad5b353240c8837109d1bcc6c3a9a501d7f6a960)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/sev.c
diff --cc arch/x86/kvm/svm/sev.c
index 2917da934694,7656a2c5662a..000000000000
--- a/arch/x86/kvm/svm/sev.c
+++ b/arch/x86/kvm/svm/sev.c
@@@ -2139,16 -2356,13 +2139,13 @@@ static bool sev_es_validate_vmgexit(str
  {
  	struct kvm_vcpu *vcpu;
  	struct ghcb *ghcb;
- 	u64 exit_code = 0;
+ 	u64 exit_code;
+ 	u64 reason;
  
 -	ghcb = svm->sev_es.ghcb;
 +	ghcb = svm->ghcb;
  
- 	/* Only GHCB Usage code 0 is supported */
- 	if (ghcb->ghcb_usage)
- 		goto vmgexit_err;
- 
  	/*
- 	 * Retrieve the exit code now even though is may not be marked valid
+ 	 * Retrieve the exit code now even though it may not be marked valid
  	 * as it could help with debugging.
  	 */
  	exit_code = ghcb_get_sw_exit_code(ghcb);
@@@ -2312,10 -2539,10 +2321,10 @@@ void pre_sev_run(struct vcpu_svm *svm, 
  }
  
  #define GHCB_SCRATCH_AREA_LIMIT		(16ULL * PAGE_SIZE)
- static int setup_vmgexit_scratch(struct vcpu_svm *svm, bool sync, u64 len)
+ static bool setup_vmgexit_scratch(struct vcpu_svm *svm, bool sync, u64 len)
  {
  	struct vmcb_control_area *control = &svm->vmcb->control;
 -	struct ghcb *ghcb = svm->sev_es.ghcb;
 +	struct ghcb *ghcb = svm->ghcb;
  	u64 ghcb_scratch_beg, ghcb_scratch_end;
  	u64 scratch_gpa_beg, scratch_gpa_end;
  	void *scratch_va;
@@@ -2348,10 -2575,10 +2357,10 @@@
  		    scratch_gpa_end > ghcb_scratch_end) {
  			pr_err("vmgexit: scratch area is outside of GHCB shared buffer area (%#llx - %#llx)\n",
  			       scratch_gpa_beg, scratch_gpa_end);
- 			return -EINVAL;
+ 			goto e_scratch;
  		}
  
 -		scratch_va = (void *)svm->sev_es.ghcb;
 +		scratch_va = (void *)svm->ghcb;
  		scratch_va += (scratch_gpa_beg - control->ghcb_gpa);
  	} else {
  		/*
@@@ -2361,18 -2588,18 +2370,23 @@@
  		if (len > GHCB_SCRATCH_AREA_LIMIT) {
  			pr_err("vmgexit: scratch area exceeds KVM limits (%#llx requested, %#llx limit)\n",
  			       len, GHCB_SCRATCH_AREA_LIMIT);
- 			return -EINVAL;
+ 			goto e_scratch;
  		}
 -		scratch_va = kvzalloc(len, GFP_KERNEL_ACCOUNT);
 +		scratch_va = kzalloc(len, GFP_KERNEL_ACCOUNT);
  		if (!scratch_va)
- 			return -ENOMEM;
+ 			goto e_scratch;
  
  		if (kvm_read_guest(svm->vcpu.kvm, scratch_gpa_beg, scratch_va, len)) {
  			/* Unable to copy scratch area from guest */
  			pr_err("vmgexit: kvm_read_guest for scratch area failed\n");
  
++<<<<<<< HEAD
 +			kfree(scratch_va);
 +			return -EFAULT;
++=======
+ 			kvfree(scratch_va);
+ 			goto e_scratch;
++>>>>>>> ad5b353240c8 (KVM: SVM: Do not terminate SEV-ES guests on GHCB validation failure)
  		}
  
  		/*
@@@ -2381,14 -2608,20 +2395,20 @@@
  		 * the vCPU next time (i.e. a read was requested so the data
  		 * must be written back to the guest memory).
  		 */
 -		svm->sev_es.ghcb_sa_sync = sync;
 -		svm->sev_es.ghcb_sa_free = true;
 +		svm->ghcb_sa_sync = sync;
 +		svm->ghcb_sa_free = true;
  	}
  
 -	svm->sev_es.ghcb_sa = scratch_va;
 -	svm->sev_es.ghcb_sa_len = len;
 +	svm->ghcb_sa = scratch_va;
 +	svm->ghcb_sa_len = len;
  
- 	return 0;
+ 	return true;
+ 
+ e_scratch:
+ 	ghcb_set_sw_exit_info_1(ghcb, 2);
+ 	ghcb_set_sw_exit_info_2(ghcb, GHCB_ERR_INVALID_SCRATCH_AREA);
+ 
+ 	return false;
  }
  
  static void set_ghcb_msr_bits(struct vcpu_svm *svm, u64 value, u64 mask,
@@@ -2502,18 -2738,22 +2525,22 @@@ int sev_handle_vmgexit(struct kvm_vcpu 
  
  	if (!ghcb_gpa) {
  		vcpu_unimpl(vcpu, "vmgexit: GHCB gpa is not set\n");
- 		return -EINVAL;
+ 
+ 		/* Without a GHCB, just return right back to the guest */
+ 		return 1;
  	}
  
 -	if (kvm_vcpu_map(vcpu, ghcb_gpa >> PAGE_SHIFT, &svm->sev_es.ghcb_map)) {
 +	if (kvm_vcpu_map(vcpu, ghcb_gpa >> PAGE_SHIFT, &svm->ghcb_map)) {
  		/* Unable to map GHCB from guest */
  		vcpu_unimpl(vcpu, "vmgexit: error mapping GHCB [%#llx] from guest\n",
  			    ghcb_gpa);
- 		return -EINVAL;
+ 
+ 		/* Without a GHCB, just return right back to the guest */
+ 		return 1;
  	}
  
 -	svm->sev_es.ghcb = svm->sev_es.ghcb_map.hva;
 -	ghcb = svm->sev_es.ghcb_map.hva;
 +	svm->ghcb = svm->ghcb_map.hva;
 +	ghcb = svm->ghcb_map.hva;
  
  	trace_kvm_vmgexit_enter(vcpu->vcpu_id, ghcb);
  
@@@ -2536,11 -2775,10 +2562,10 @@@
  		ret = kvm_sev_es_mmio_read(vcpu,
  					   control->exit_info_1,
  					   control->exit_info_2,
 -					   svm->sev_es.ghcb_sa);
 +					   svm->ghcb_sa);
  		break;
  	case SVM_VMGEXIT_MMIO_WRITE:
- 		ret = setup_vmgexit_scratch(svm, false, control->exit_info_2);
- 		if (ret)
+ 		if (!setup_vmgexit_scratch(svm, false, control->exit_info_2))
  			break;
  
  		ret = kvm_sev_es_mmio_write(vcpu,
@@@ -2605,11 -2838,11 +2625,10 @@@ int sev_es_string_io(struct vcpu_svm *s
  	if (unlikely(check_mul_overflow(count, size, &bytes)))
  		return -EINVAL;
  
- 	r = setup_vmgexit_scratch(svm, in, bytes);
- 	if (r)
- 		return r;
+ 	if (!setup_vmgexit_scratch(svm, in, bytes))
+ 		return 1;
  
 -	return kvm_sev_es_string_io(&svm->vcpu, size, port, svm->sev_es.ghcb_sa,
 -				    count, in);
 +	return kvm_sev_es_string_io(&svm->vcpu, size, port, svm->ghcb_sa, count, in);
  }
  
  void sev_es_init_vmcb(struct vcpu_svm *svm)
diff --git a/arch/x86/include/asm/sev-common.h b/arch/x86/include/asm/sev-common.h
index 629c3df243f0..7612bd96d548 100644
--- a/arch/x86/include/asm/sev-common.h
+++ b/arch/x86/include/asm/sev-common.h
@@ -59,4 +59,15 @@
 
 #define GHCB_RESP_CODE(v)		((v) & GHCB_MSR_INFO_MASK)
 
+/*
+ * Error codes related to GHCB input that can be communicated back to the guest
+ * by setting the lower 32-bits of the GHCB SW_EXITINFO1 field to 2.
+ */
+#define GHCB_ERR_NOT_REGISTERED		1
+#define GHCB_ERR_INVALID_USAGE		2
+#define GHCB_ERR_INVALID_SCRATCH_AREA	3
+#define GHCB_ERR_MISSING_INPUT		4
+#define GHCB_ERR_INVALID_INPUT		5
+#define GHCB_ERR_INVALID_EVENT		6
+
 #endif
* Unmerged path arch/x86/kvm/svm/sev.c
