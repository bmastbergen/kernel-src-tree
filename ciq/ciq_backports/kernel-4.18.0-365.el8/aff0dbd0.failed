ACPI: scan: Make acpi_walk_dep_device_list()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit aff0dbd03d3b750e2331f7cb93e01fe25ed27086
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/aff0dbd0.failed

Because acpi_walk_dep_device_list() is only called by the code in the
file in which it is defined, make it static, drop the export of it
and drop its header from acpi.h.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Hans de Goede <hdegoede@redhat.com>
(cherry picked from commit aff0dbd03d3b750e2331f7cb93e01fe25ed27086)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
#	include/linux/acpi.h
diff --cc drivers/acpi/scan.c
index 70d0d2830632,b7f9b7ac0d04..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -2113,10 -2096,55 +2113,59 @@@ static void acpi_bus_attach(struct acpi
  		device->handler->hotplug.notify_online(device);
  }
  
++<<<<<<< HEAD
 +void acpi_walk_dep_device_list(acpi_handle handle)
++=======
+ static int acpi_dev_get_first_consumer_dev_cb(struct acpi_dep_data *dep, void *data)
+ {
+ 	struct acpi_device *adev;
+ 
+ 	adev = acpi_bus_get_acpi_device(dep->consumer);
+ 	if (adev) {
+ 		*(struct acpi_device **)data = adev;
+ 		return 1;
+ 	}
+ 	/* Continue parsing if the device object is not present. */
+ 	return 0;
+ }
+ 
+ static int acpi_scan_clear_dep(struct acpi_dep_data *dep, void *data)
+ {
+ 	struct acpi_device *adev;
+ 
+ 	acpi_bus_get_device(dep->consumer, &adev);
+ 
+ 	if (adev) {
+ 		adev->dep_unmet--;
+ 		if (!adev->dep_unmet)
+ 			acpi_bus_attach(adev, true);
+ 	}
+ 
+ 	list_del(&dep->node);
+ 	kfree(dep);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * acpi_walk_dep_device_list - Apply a callback to every entry in acpi_dep_list
+  * @handle:	The ACPI handle of the supplier device
+  * @callback:	Pointer to the callback function to apply
+  * @data:	Pointer to some data to pass to the callback
+  *
+  * The return value of the callback determines this function's behaviour. If 0
+  * is returned we continue to iterate over acpi_dep_list. If a positive value
+  * is returned then the loop is broken but this function returns 0. If a
+  * negative value is returned by the callback then the loop is broken and that
+  * value is returned as the final error.
+  */
+ static int acpi_walk_dep_device_list(acpi_handle handle,
+ 				int (*callback)(struct acpi_dep_data *, void *),
+ 				void *data)
++>>>>>>> aff0dbd03d3b (ACPI: scan: Make acpi_walk_dep_device_list())
  {
  	struct acpi_dep_data *dep, *tmp;
 -	int ret = 0;
 +	struct acpi_device *adev;
  
  	mutex_lock(&acpi_dep_list_lock);
  	list_for_each_entry_safe(dep, tmp, &acpi_dep_list, node) {
@@@ -2134,8 -2155,42 +2183,7 @@@
  		}
  	}
  	mutex_unlock(&acpi_dep_list_lock);
 -
 -	return ret > 0 ? 0 : ret;
 -}
 -
 -/**
 - * acpi_dev_clear_dependencies - Inform consumers that the device is now active
 - * @supplier: Pointer to the supplier &struct acpi_device
 - *
 - * Clear dependencies on the given device.
 - */
 -void acpi_dev_clear_dependencies(struct acpi_device *supplier)
 -{
 -	acpi_walk_dep_device_list(supplier->handle, acpi_scan_clear_dep, NULL);
 -}
 -EXPORT_SYMBOL_GPL(acpi_dev_clear_dependencies);
 -
 -/**
 - * acpi_dev_get_first_consumer_dev - Return ACPI device dependent on @supplier
 - * @supplier: Pointer to the dependee device
 - *
 - * Returns the first &struct acpi_device which declares itself dependent on
 - * @supplier via the _DEP buffer, parsed from the acpi_dep_list.
 - *
 - * The caller is responsible for putting the reference to adev when it is no
 - * longer needed.
 - */
 -struct acpi_device *acpi_dev_get_first_consumer_dev(struct acpi_device *supplier)
 -{
 -	struct acpi_device *adev = NULL;
 -
 -	acpi_walk_dep_device_list(supplier->handle,
 -				  acpi_dev_get_first_consumer_dev_cb, &adev);
 -
 -	return adev;
  }
- EXPORT_SYMBOL_GPL(acpi_walk_dep_device_list);
 -EXPORT_SYMBOL_GPL(acpi_dev_get_first_consumer_dev);
  
  /**
   * acpi_bus_scan - Add ACPI device node objects in a given namespace scope.
diff --cc include/linux/acpi.h
index 5d4a9187f573,0a6d2845fcaf..000000000000
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@@ -680,7 -666,6 +680,10 @@@ extern bool acpi_driver_match_device(st
  				     const struct device_driver *drv);
  int acpi_device_uevent_modalias(struct device *, struct kobj_uevent_env *);
  int acpi_device_modalias(struct device *, char *, int);
++<<<<<<< HEAD
 +void acpi_walk_dep_device_list(acpi_handle handle);
++=======
++>>>>>>> aff0dbd03d3b (ACPI: scan: Make acpi_walk_dep_device_list())
  
  struct platform_device *acpi_create_platform_device(struct acpi_device *,
  						    struct property_entry *);
* Unmerged path drivers/acpi/scan.c
* Unmerged path include/linux/acpi.h
