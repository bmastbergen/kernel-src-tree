kasan: open-code kasan_unpoison_slab

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Andrey Konovalov <andreyknvl@google.com>
commit bffe690708c8b4fdb8f0bff8ff22b347fc6c709a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/bffe6907.failed

There's the external annotation kasan_unpoison_slab() that is currently
defined as static inline and uses kasan_unpoison_range(). Open-code this
function in mempool.c. Otherwise with an upcoming change this function
will result in an unnecessary function call.

Link: https://lkml.kernel.org/r/131a6694a978a9a8b150187e539eecc8bcbf759b.1606162397.git.andreyknvl@google.com
Link: https://linux-review.googlesource.com/id/Ia7c8b659f79209935cbaab3913bf7f082cc43a0e
	Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
	Reviewed-by: Marco Elver <elver@google.com>
	Tested-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Branislav Rankov <Branislav.Rankov@arm.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Evgenii Stepanov <eugenis@google.com>
	Cc: Kevin Brodsky <kevin.brodsky@arm.com>
	Cc: Vasily Gorbik <gor@linux.ibm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit bffe690708c8b4fdb8f0bff8ff22b347fc6c709a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/kasan.h
#	mm/mempool.c
diff --cc include/linux/kasan.h
index f00d17cf6822,7350de3e9fe4..000000000000
--- a/include/linux/kasan.h
+++ b/include/linux/kasan.h
@@@ -69,27 -107,6 +69,30 @@@ struct kasan_cache 
  	int free_meta_offset;
  };
  
++<<<<<<< HEAD
 +/*
 + * These functions provide a special case to support backing module
 + * allocations with real shadow memory. With KASAN vmalloc, the special
 + * case is unnecessary, as the work is handled in the generic case.
 + */
 +#ifndef CONFIG_KASAN_VMALLOC
 +int kasan_module_alloc(void *addr, size_t size);
 +void kasan_free_shadow(const struct vm_struct *vm);
 +#else
 +static inline int kasan_module_alloc(void *addr, size_t size) { return 0; }
 +static inline void kasan_free_shadow(const struct vm_struct *vm) {}
 +#endif
 +
 +int kasan_add_zero_shadow(void *start, unsigned long size);
 +void kasan_remove_zero_shadow(void *start, unsigned long size);
 +
 +size_t __ksize(const void *);
 +static inline void kasan_unpoison_slab(const void *ptr)
 +{
 +	kasan_unpoison_shadow(ptr, __ksize(ptr));
 +}
++=======
++>>>>>>> bffe690708c8 (kasan: open-code kasan_unpoison_slab)
  size_t kasan_metadata_size(struct kmem_cache *cache);
  
  bool kasan_save_enable_multi_shot(void);
@@@ -150,18 -162,6 +153,21 @@@ static inline bool kasan_slab_free(stru
  	return false;
  }
  
++<<<<<<< HEAD
 +static inline int kasan_module_alloc(void *addr, size_t size) { return 0; }
 +static inline void kasan_free_shadow(const struct vm_struct *vm) {}
 +
 +static inline int kasan_add_zero_shadow(void *start, unsigned long size)
 +{
 +	return 0;
 +}
 +static inline void kasan_remove_zero_shadow(void *start,
 +					unsigned long size)
 +{}
 +
 +static inline void kasan_unpoison_slab(const void *ptr) { }
++=======
++>>>>>>> bffe690708c8 (kasan: open-code kasan_unpoison_slab)
  static inline size_t kasan_metadata_size(struct kmem_cache *cache) { return 0; }
  
  #endif /* CONFIG_KASAN */
diff --cc mm/mempool.c
index 6bfbd4d73ec5,583a9865b181..000000000000
--- a/mm/mempool.c
+++ b/mm/mempool.c
@@@ -111,11 -109,11 +111,16 @@@ static __always_inline void kasan_poiso
  		kasan_free_pages(element, (unsigned long)pool->pool_data);
  }
  
 -static void kasan_unpoison_element(mempool_t *pool, void *element)
 +static void kasan_unpoison_element(mempool_t *pool, void *element, gfp_t flags)
  {
  	if (pool->alloc == mempool_alloc_slab || pool->alloc == mempool_kmalloc)
++<<<<<<< HEAD
 +		kasan_unpoison_slab(element);
 +	if (pool->alloc == mempool_alloc_pages)
++=======
+ 		kasan_unpoison_range(element, __ksize(element));
+ 	else if (pool->alloc == mempool_alloc_pages)
++>>>>>>> bffe690708c8 (kasan: open-code kasan_unpoison_slab)
  		kasan_alloc_pages(element, (unsigned long)pool->pool_data);
  }
  
* Unmerged path include/linux/kasan.h
* Unmerged path mm/mempool.c
