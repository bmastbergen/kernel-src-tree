kasan: unify large kfree checks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Andrey Konovalov <andreyknvl@google.com>
commit 200072ce33b298cf14d3ed2a570f5eb27609677d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/200072ce.failed

Unify checks in kasan_kfree_large() and in kasan_slab_free_mempool() for
large allocations as it's done for small kfree() allocations.

With this change, kasan_slab_free_mempool() starts checking that the first
byte of the memory that's being freed is accessible.

Link: https://lkml.kernel.org/r/14ffc4cd867e0b1ed58f7527e3b748a1b4ad08aa.1612546384.git.andreyknvl@google.com
	Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
	Reviewed-by: Marco Elver <elver@google.com>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Branislav Rankov <Branislav.Rankov@arm.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Evgenii Stepanov <eugenis@google.com>
	Cc: Kevin Brodsky <kevin.brodsky@arm.com>
	Cc: Peter Collingbourne <pcc@google.com>
	Cc: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 200072ce33b298cf14d3ed2a570f5eb27609677d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/kasan.h
#	mm/kasan/common.c
diff --cc include/linux/kasan.h
index 71e7b6777f1b,b91732bd05d7..000000000000
--- a/include/linux/kasan.h
+++ b/include/linux/kasan.h
@@@ -67,30 -83,189 +67,201 @@@ bool kasan_slab_free(struct kmem_cache 
  struct kasan_cache {
  	int alloc_meta_offset;
  	int free_meta_offset;
 -	bool is_kmalloc;
  };
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_KASAN_HW_TAGS
+ 
+ DECLARE_STATIC_KEY_FALSE(kasan_flag_enabled);
+ 
+ static __always_inline bool kasan_enabled(void)
+ {
+ 	return static_branch_likely(&kasan_flag_enabled);
+ }
+ 
+ #else /* CONFIG_KASAN_HW_TAGS */
+ 
+ static inline bool kasan_enabled(void)
+ {
+ 	return true;
+ }
+ 
+ #endif /* CONFIG_KASAN_HW_TAGS */
+ 
+ slab_flags_t __kasan_never_merge(void);
+ static __always_inline slab_flags_t kasan_never_merge(void)
+ {
+ 	if (kasan_enabled())
+ 		return __kasan_never_merge();
+ 	return 0;
+ }
+ 
+ void __kasan_unpoison_range(const void *addr, size_t size);
+ static __always_inline void kasan_unpoison_range(const void *addr, size_t size)
+ {
+ 	if (kasan_enabled())
+ 		__kasan_unpoison_range(addr, size);
+ }
+ 
+ void __kasan_alloc_pages(struct page *page, unsigned int order);
+ static __always_inline void kasan_alloc_pages(struct page *page,
+ 						unsigned int order)
+ {
+ 	if (kasan_enabled())
+ 		__kasan_alloc_pages(page, order);
+ }
+ 
+ void __kasan_free_pages(struct page *page, unsigned int order);
+ static __always_inline void kasan_free_pages(struct page *page,
+ 						unsigned int order)
+ {
+ 	if (kasan_enabled())
+ 		__kasan_free_pages(page, order);
+ }
+ 
+ void __kasan_cache_create(struct kmem_cache *cache, unsigned int *size,
+ 				slab_flags_t *flags);
+ static __always_inline void kasan_cache_create(struct kmem_cache *cache,
+ 				unsigned int *size, slab_flags_t *flags)
+ {
+ 	if (kasan_enabled())
+ 		__kasan_cache_create(cache, size, flags);
+ }
+ 
+ void __kasan_cache_create_kmalloc(struct kmem_cache *cache);
+ static __always_inline void kasan_cache_create_kmalloc(struct kmem_cache *cache)
+ {
+ 	if (kasan_enabled())
+ 		__kasan_cache_create_kmalloc(cache);
+ }
+ 
+ size_t __kasan_metadata_size(struct kmem_cache *cache);
+ static __always_inline size_t kasan_metadata_size(struct kmem_cache *cache)
+ {
+ 	if (kasan_enabled())
+ 		return __kasan_metadata_size(cache);
+ 	return 0;
+ }
+ 
+ void __kasan_poison_slab(struct page *page);
+ static __always_inline void kasan_poison_slab(struct page *page)
+ {
+ 	if (kasan_enabled())
+ 		__kasan_poison_slab(page);
+ }
+ 
+ void __kasan_unpoison_object_data(struct kmem_cache *cache, void *object);
+ static __always_inline void kasan_unpoison_object_data(struct kmem_cache *cache,
+ 							void *object)
+ {
+ 	if (kasan_enabled())
+ 		__kasan_unpoison_object_data(cache, object);
+ }
+ 
+ void __kasan_poison_object_data(struct kmem_cache *cache, void *object);
+ static __always_inline void kasan_poison_object_data(struct kmem_cache *cache,
+ 							void *object)
+ {
+ 	if (kasan_enabled())
+ 		__kasan_poison_object_data(cache, object);
+ }
+ 
+ void * __must_check __kasan_init_slab_obj(struct kmem_cache *cache,
+ 					  const void *object);
+ static __always_inline void * __must_check kasan_init_slab_obj(
+ 				struct kmem_cache *cache, const void *object)
+ {
+ 	if (kasan_enabled())
+ 		return __kasan_init_slab_obj(cache, object);
+ 	return (void *)object;
+ }
+ 
+ bool __kasan_slab_free(struct kmem_cache *s, void *object, unsigned long ip);
+ static __always_inline bool kasan_slab_free(struct kmem_cache *s, void *object)
+ {
+ 	if (kasan_enabled())
+ 		return __kasan_slab_free(s, object, _RET_IP_);
+ 	return false;
+ }
+ 
+ void __kasan_kfree_large(void *ptr, unsigned long ip);
+ static __always_inline void kasan_kfree_large(void *ptr)
+ {
+ 	if (kasan_enabled())
+ 		__kasan_kfree_large(ptr, _RET_IP_);
+ }
+ 
+ void __kasan_slab_free_mempool(void *ptr, unsigned long ip);
+ static __always_inline void kasan_slab_free_mempool(void *ptr)
+ {
+ 	if (kasan_enabled())
+ 		__kasan_slab_free_mempool(ptr, _RET_IP_);
+ }
+ 
+ void * __must_check __kasan_slab_alloc(struct kmem_cache *s,
+ 				       void *object, gfp_t flags);
+ static __always_inline void * __must_check kasan_slab_alloc(
+ 				struct kmem_cache *s, void *object, gfp_t flags)
+ {
+ 	if (kasan_enabled())
+ 		return __kasan_slab_alloc(s, object, flags);
+ 	return object;
+ }
+ 
+ void * __must_check __kasan_kmalloc(struct kmem_cache *s, const void *object,
+ 				    size_t size, gfp_t flags);
+ static __always_inline void * __must_check kasan_kmalloc(struct kmem_cache *s,
+ 				const void *object, size_t size, gfp_t flags)
+ {
+ 	if (kasan_enabled())
+ 		return __kasan_kmalloc(s, object, size, flags);
+ 	return (void *)object;
+ }
+ 
+ void * __must_check __kasan_kmalloc_large(const void *ptr,
+ 					  size_t size, gfp_t flags);
+ static __always_inline void * __must_check kasan_kmalloc_large(const void *ptr,
+ 						      size_t size, gfp_t flags)
+ {
+ 	if (kasan_enabled())
+ 		return __kasan_kmalloc_large(ptr, size, flags);
+ 	return (void *)ptr;
+ }
+ 
+ void * __must_check __kasan_krealloc(const void *object,
+ 				     size_t new_size, gfp_t flags);
+ static __always_inline void * __must_check kasan_krealloc(const void *object,
+ 						 size_t new_size, gfp_t flags)
+ {
+ 	if (kasan_enabled())
+ 		return __kasan_krealloc(object, new_size, flags);
+ 	return (void *)object;
+ }
+ 
++>>>>>>> 200072ce33b2 (kasan: unify large kfree checks)
  /*
 - * Unlike kasan_check_read/write(), kasan_check_byte() is performed even for
 - * the hardware tag-based mode that doesn't rely on compiler instrumentation.
 + * These functions provide a special case to support backing module
 + * allocations with real shadow memory. With KASAN vmalloc, the special
 + * case is unnecessary, as the work is handled in the generic case.
   */
 -bool __kasan_check_byte(const void *addr, unsigned long ip);
 -static __always_inline bool kasan_check_byte(const void *addr)
 +#ifndef CONFIG_KASAN_VMALLOC
 +int kasan_module_alloc(void *addr, size_t size);
 +void kasan_free_shadow(const struct vm_struct *vm);
 +#else
 +static inline int kasan_module_alloc(void *addr, size_t size) { return 0; }
 +static inline void kasan_free_shadow(const struct vm_struct *vm) {}
 +#endif
 +
 +int kasan_add_zero_shadow(void *start, unsigned long size);
 +void kasan_remove_zero_shadow(void *start, unsigned long size);
 +
 +size_t __ksize(const void *);
 +static inline void kasan_unpoison_slab(const void *ptr)
  {
 -	if (kasan_enabled())
 -		return __kasan_check_byte(addr, _RET_IP_);
 -	return true;
 +	kasan_unpoison_shadow(ptr, __ksize(ptr));
  }
 -
 +size_t kasan_metadata_size(struct kmem_cache *cache);
  
  bool kasan_save_enable_multi_shot(void);
  void kasan_restore_multi_shot(bool enabled);
@@@ -121,13 -298,17 +292,24 @@@ static inline void *kasan_init_slab_obj
  {
  	return (void *)object;
  }
 -static inline bool kasan_slab_free(struct kmem_cache *s, void *object)
 +
 +static inline void *kasan_kmalloc_large(void *ptr, size_t size, gfp_t flags)
  {
++<<<<<<< HEAD
 +	return ptr;
++=======
+ 	return false;
+ }
+ static inline void kasan_kfree_large(void *ptr) {}
+ static inline void kasan_slab_free_mempool(void *ptr) {}
+ static inline void *kasan_slab_alloc(struct kmem_cache *s, void *object,
+ 				   gfp_t flags)
+ {
+ 	return object;
++>>>>>>> 200072ce33b2 (kasan: unify large kfree checks)
  }
 +static inline void kasan_kfree_large(void *ptr, unsigned long ip) {}
 +static inline void kasan_poison_kfree(void *ptr, unsigned long ip) {}
  static inline void *kasan_kmalloc(struct kmem_cache *s, const void *object,
  				size_t size, gfp_t flags)
  {
@@@ -138,33 -323,18 +320,37 @@@ static inline void *kasan_krealloc(cons
  {
  	return (void *)object;
  }
++<<<<<<< HEAD
 +
 +static inline void *kasan_slab_alloc(struct kmem_cache *s, void *object,
 +				   gfp_t flags)
++=======
+ static inline bool kasan_check_byte(const void *address)
++>>>>>>> 200072ce33b2 (kasan: unify large kfree checks)
  {
 -	return true;
 +	return object;
 +}
 +static inline bool kasan_slab_free(struct kmem_cache *s, void *object,
 +				   unsigned long ip)
 +{
 +	return false;
  }
  
 -#endif /* CONFIG_KASAN */
 +static inline int kasan_module_alloc(void *addr, size_t size) { return 0; }
 +static inline void kasan_free_shadow(const struct vm_struct *vm) {}
  
 -#if defined(CONFIG_KASAN) && CONFIG_KASAN_STACK
 -void kasan_unpoison_task_stack(struct task_struct *task);
 -#else
 -static inline void kasan_unpoison_task_stack(struct task_struct *task) {}
 -#endif
 +static inline int kasan_add_zero_shadow(void *start, unsigned long size)
 +{
 +	return 0;
 +}
 +static inline void kasan_remove_zero_shadow(void *start,
 +					unsigned long size)
 +{}
 +
 +static inline void kasan_unpoison_slab(const void *ptr) { }
 +static inline size_t kasan_metadata_size(struct kmem_cache *cache) { return 0; }
 +
 +#endif /* CONFIG_KASAN */
  
  #ifdef CONFIG_KASAN_GENERIC
  
diff --cc mm/kasan/common.c
index 0d0cb20ec1a4,8a3d66393dc5..000000000000
--- a/mm/kasan/common.c
+++ b/mm/kasan/common.c
@@@ -431,27 -348,119 +431,127 @@@ static bool __kasan_slab_free(struct km
  		return true;
  	}
  
 -	kasan_poison(object, cache->object_size, KASAN_KMALLOC_FREE);
 +	rounded_up_size = round_up(cache->object_size, KASAN_SHADOW_SCALE_SIZE);
 +	kasan_poison_shadow(object, rounded_up_size, KASAN_KMALLOC_FREE);
  
 -	if ((IS_ENABLED(CONFIG_KASAN_GENERIC) && !quarantine))
 +	if ((IS_ENABLED(CONFIG_KASAN_GENERIC) && !quarantine) ||
 +			unlikely(!(cache->flags & SLAB_KASAN)))
  		return false;
  
 -	if (kasan_stack_collection_enabled())
 -		kasan_set_free_info(cache, object, tag);
 +	kasan_set_free_info(cache, object, tag);
 +
 +	quarantine_put(cache, object);
  
 -	return kasan_quarantine_put(cache, object);
 +	return IS_ENABLED(CONFIG_KASAN_GENERIC);
  }
  
 -bool __kasan_slab_free(struct kmem_cache *cache, void *object, unsigned long ip)
 +bool kasan_slab_free(struct kmem_cache *cache, void *object, unsigned long ip)
  {
 -	return ____kasan_slab_free(cache, object, ip, true);
 +	return __kasan_slab_free(cache, object, ip, true);
  }
  
++<<<<<<< HEAD
 +static void *__kasan_kmalloc(struct kmem_cache *cache, const void *object,
 +				size_t size, gfp_t flags, bool keep_tag)
++=======
+ static bool ____kasan_kfree_large(void *ptr, unsigned long ip)
+ {
+ 	if (ptr != page_address(virt_to_head_page(ptr))) {
+ 		kasan_report_invalid_free(ptr, ip);
+ 		return true;
+ 	}
+ 
+ 	if (!kasan_byte_accessible(ptr)) {
+ 		kasan_report_invalid_free(ptr, ip);
+ 		return true;
+ 	}
+ 
+ 	/*
+ 	 * The object will be poisoned by kasan_free_pages() or
+ 	 * kasan_slab_free_mempool().
+ 	 */
+ 
+ 	return false;
+ }
+ 
+ void __kasan_kfree_large(void *ptr, unsigned long ip)
+ {
+ 	____kasan_kfree_large(ptr, ip);
+ }
+ 
+ void __kasan_slab_free_mempool(void *ptr, unsigned long ip)
+ {
+ 	struct page *page;
+ 
+ 	page = virt_to_head_page(ptr);
+ 
+ 	/*
+ 	 * Even though this function is only called for kmem_cache_alloc and
+ 	 * kmalloc backed mempool allocations, those allocations can still be
+ 	 * !PageSlab() when the size provided to kmalloc is larger than
+ 	 * KMALLOC_MAX_SIZE, and kmalloc falls back onto page_alloc.
+ 	 */
+ 	if (unlikely(!PageSlab(page))) {
+ 		if (____kasan_kfree_large(ptr, ip))
+ 			return;
+ 		kasan_poison(ptr, page_size(page), KASAN_FREE_PAGE);
+ 	} else {
+ 		____kasan_slab_free(page->slab_cache, ptr, ip, false);
+ 	}
+ }
+ 
+ static void set_alloc_info(struct kmem_cache *cache, void *object,
+ 				gfp_t flags, bool is_kmalloc)
+ {
+ 	struct kasan_alloc_meta *alloc_meta;
+ 
+ 	/* Don't save alloc info for kmalloc caches in kasan_slab_alloc(). */
+ 	if (cache->kasan_info.is_kmalloc && !is_kmalloc)
+ 		return;
+ 
+ 	alloc_meta = kasan_get_alloc_meta(cache, object);
+ 	if (alloc_meta)
+ 		kasan_set_track(&alloc_meta->alloc_track, flags);
+ }
+ 
+ void * __must_check __kasan_slab_alloc(struct kmem_cache *cache,
+ 					void *object, gfp_t flags)
+ {
+ 	u8 tag;
+ 	void *tagged_object;
+ 
+ 	if (gfpflags_allow_blocking(flags))
+ 		kasan_quarantine_reduce();
+ 
+ 	if (unlikely(object == NULL))
+ 		return NULL;
+ 
+ 	if (is_kfence_address(object))
+ 		return (void *)object;
+ 
+ 	/*
+ 	 * Generate and assign random tag for tag-based modes.
+ 	 * Tag is ignored in set_tag() for the generic mode.
+ 	 */
+ 	tag = assign_tag(cache, object, false);
+ 	tagged_object = set_tag(object, tag);
+ 
+ 	/*
+ 	 * Unpoison the whole object.
+ 	 * For kmalloc() allocations, kasan_kmalloc() will do precise poisoning.
+ 	 */
+ 	kasan_unpoison(tagged_object, cache->object_size);
+ 
+ 	/* Save alloc info (if possible) for non-kmalloc() allocations. */
+ 	if (kasan_stack_collection_enabled())
+ 		set_alloc_info(cache, (void *)object, flags, false);
+ 
+ 	return tagged_object;
+ }
+ 
+ static void *____kasan_kmalloc(struct kmem_cache *cache, const void *object,
+ 					size_t size, gfp_t flags)
++>>>>>>> 200072ce33b2 (kasan: unify large kfree checks)
  {
  	unsigned long redzone_start;
  	unsigned long redzone_end;
@@@ -530,439 -557,16 +630,443 @@@ void * __must_check kasan_krealloc(cons
  	page = virt_to_head_page(object);
  
  	if (unlikely(!PageSlab(page)))
 -		return __kasan_kmalloc_large(object, size, flags);
 +		return kasan_kmalloc_large(object, size, flags);
  	else
 -		return ____kasan_kmalloc(page->slab_cache, object, size, flags);
 +		return __kasan_kmalloc(page->slab_cache, object, size,
 +						flags, true);
  }
  
++<<<<<<< HEAD
 +void kasan_poison_kfree(void *ptr, unsigned long ip)
 +{
 +	struct page *page;
 +
 +	page = virt_to_head_page(ptr);
 +
 +	if (unlikely(!PageSlab(page))) {
 +		if (ptr != page_address(page)) {
 +			kasan_report_invalid_free(ptr, ip);
 +			return;
 +		}
 +		kasan_poison_shadow(ptr, page_size(page), KASAN_FREE_PAGE);
 +	} else {
 +		__kasan_slab_free(page->slab_cache, ptr, ip, false);
 +	}
 +}
 +
 +void kasan_kfree_large(void *ptr, unsigned long ip)
 +{
 +	if (ptr != page_address(virt_to_head_page(ptr)))
 +		kasan_report_invalid_free(ptr, ip);
 +	/* The object will be poisoned by kasan_free_pages(). */
 +}
 +
 +#ifndef CONFIG_KASAN_VMALLOC
 +int kasan_module_alloc(void *addr, size_t size)
++=======
+ bool __kasan_check_byte(const void *address, unsigned long ip)
++>>>>>>> 200072ce33b2 (kasan: unify large kfree checks)
 +{
 +	void *ret;
 +	size_t scaled_size;
 +	size_t shadow_size;
 +	unsigned long shadow_start;
 +
 +	shadow_start = (unsigned long)kasan_mem_to_shadow(addr);
 +	scaled_size = (size + KASAN_SHADOW_MASK) >> KASAN_SHADOW_SCALE_SHIFT;
 +	shadow_size = round_up(scaled_size, PAGE_SIZE);
 +
 +	if (WARN_ON(!PAGE_ALIGNED(shadow_start)))
 +		return -EINVAL;
 +
 +	ret = __vmalloc_node_range(shadow_size, 1, shadow_start,
 +			shadow_start + shadow_size,
 +			GFP_KERNEL,
 +			PAGE_KERNEL, VM_NO_GUARD, NUMA_NO_NODE,
 +			__builtin_return_address(0));
 +
 +	if (ret) {
 +		__memset(ret, KASAN_SHADOW_INIT, shadow_size);
 +		find_vm_area(addr)->flags |= VM_KASAN;
 +		kmemleak_ignore(ret);
 +		return 0;
 +	}
 +
 +	return -ENOMEM;
 +}
 +
 +void kasan_free_shadow(const struct vm_struct *vm)
 +{
 +	if (vm->flags & VM_KASAN)
 +		vfree(kasan_mem_to_shadow(vm->addr));
 +}
 +#endif
 +
 +extern void __kasan_report(unsigned long addr, size_t size, bool is_write, unsigned long ip);
 +extern bool report_enabled(void);
 +
 +bool kasan_report(unsigned long addr, size_t size, bool is_write, unsigned long ip)
  {
 -	if (!kasan_byte_accessible(address)) {
 -		kasan_report((unsigned long)address, 1, false, ip);
 +	unsigned long flags = user_access_save();
 +	bool ret = false;
 +
 +	if (likely(report_enabled())) {
 +		__kasan_report(addr, size, is_write, ip);
 +		ret = true;
 +	}
 +
 +	user_access_restore(flags);
 +
 +	return ret;
 +}
 +
 +#ifdef CONFIG_MEMORY_HOTPLUG
 +static bool shadow_mapped(unsigned long addr)
 +{
 +	pgd_t *pgd = pgd_offset_k(addr);
 +	p4d_t *p4d;
 +	pud_t *pud;
 +	pmd_t *pmd;
 +	pte_t *pte;
 +
 +	if (pgd_none(*pgd))
 +		return false;
 +	p4d = p4d_offset(pgd, addr);
 +	if (p4d_none(*p4d))
  		return false;
 +	pud = pud_offset(p4d, addr);
 +	if (pud_none(*pud))
 +		return false;
 +
 +	/*
 +	 * We can't use pud_large() or pud_huge(), the first one is
 +	 * arch-specific, the last one depends on HUGETLB_PAGE.  So let's abuse
 +	 * pud_bad(), if pud is bad then it's bad because it's huge.
 +	 */
 +	if (pud_bad(*pud))
 +		return true;
 +	pmd = pmd_offset(pud, addr);
 +	if (pmd_none(*pmd))
 +		return false;
 +
 +	if (pmd_bad(*pmd))
 +		return true;
 +	pte = pte_offset_kernel(pmd, addr);
 +	return !pte_none(*pte);
 +}
 +
 +static int __meminit kasan_mem_notifier(struct notifier_block *nb,
 +			unsigned long action, void *data)
 +{
 +	struct memory_notify *mem_data = data;
 +	unsigned long nr_shadow_pages, start_kaddr, shadow_start;
 +	unsigned long shadow_end, shadow_size;
 +
 +	nr_shadow_pages = mem_data->nr_pages >> KASAN_SHADOW_SCALE_SHIFT;
 +	start_kaddr = (unsigned long)pfn_to_kaddr(mem_data->start_pfn);
 +	shadow_start = (unsigned long)kasan_mem_to_shadow((void *)start_kaddr);
 +	shadow_size = nr_shadow_pages << PAGE_SHIFT;
 +	shadow_end = shadow_start + shadow_size;
 +
 +	if (WARN_ON(mem_data->nr_pages % KASAN_SHADOW_SCALE_SIZE) ||
 +		WARN_ON(start_kaddr % (KASAN_SHADOW_SCALE_SIZE << PAGE_SHIFT)))
 +		return NOTIFY_BAD;
 +
 +	switch (action) {
 +	case MEM_GOING_ONLINE: {
 +		void *ret;
 +
 +		/*
 +		 * If shadow is mapped already than it must have been mapped
 +		 * during the boot. This could happen if we onlining previously
 +		 * offlined memory.
 +		 */
 +		if (shadow_mapped(shadow_start))
 +			return NOTIFY_OK;
 +
 +		ret = __vmalloc_node_range(shadow_size, PAGE_SIZE, shadow_start,
 +					shadow_end, GFP_KERNEL,
 +					PAGE_KERNEL, VM_NO_GUARD,
 +					pfn_to_nid(mem_data->start_pfn),
 +					__builtin_return_address(0));
 +		if (!ret)
 +			return NOTIFY_BAD;
 +
 +		kmemleak_ignore(ret);
 +		return NOTIFY_OK;
 +	}
 +	case MEM_CANCEL_ONLINE:
 +	case MEM_OFFLINE: {
 +		struct vm_struct *vm;
 +
 +		/*
 +		 * shadow_start was either mapped during boot by kasan_init()
 +		 * or during memory online by __vmalloc_node_range().
 +		 * In the latter case we can use vfree() to free shadow.
 +		 * Non-NULL result of the find_vm_area() will tell us if
 +		 * that was the second case.
 +		 *
 +		 * Currently it's not possible to free shadow mapped
 +		 * during boot by kasan_init(). It's because the code
 +		 * to do that hasn't been written yet. So we'll just
 +		 * leak the memory.
 +		 */
 +		vm = find_vm_area((void *)shadow_start);
 +		if (vm)
 +			vfree((void *)shadow_start);
  	}
 -	return true;
 +	}
 +
 +	return NOTIFY_OK;
 +}
 +
 +static int __init kasan_memhotplug_init(void)
 +{
 +	hotplug_memory_notifier(kasan_mem_notifier, 0);
 +
 +	return 0;
  }
 +
 +core_initcall(kasan_memhotplug_init);
 +#endif
 +
 +#ifdef CONFIG_KASAN_VMALLOC
 +static int kasan_populate_vmalloc_pte(pte_t *ptep, unsigned long addr,
 +				      void *unused)
 +{
 +	unsigned long page;
 +	pte_t pte;
 +
 +	if (likely(!pte_none(*ptep)))
 +		return 0;
 +
 +	page = __get_free_page(GFP_KERNEL);
 +	if (!page)
 +		return -ENOMEM;
 +
 +	memset((void *)page, KASAN_VMALLOC_INVALID, PAGE_SIZE);
 +	pte = pfn_pte(PFN_DOWN(__pa(page)), PAGE_KERNEL);
 +
 +	spin_lock(&init_mm.page_table_lock);
 +	if (likely(pte_none(*ptep))) {
 +		set_pte_at(&init_mm, addr, ptep, pte);
 +		page = 0;
 +	}
 +	spin_unlock(&init_mm.page_table_lock);
 +	if (page)
 +		free_page(page);
 +	return 0;
 +}
 +
 +int kasan_populate_vmalloc(unsigned long addr, unsigned long size)
 +{
 +	unsigned long shadow_start, shadow_end;
 +	int ret;
 +
 +	if (!is_vmalloc_or_module_addr((void *)addr))
 +		return 0;
 +
 +	shadow_start = (unsigned long)kasan_mem_to_shadow((void *)addr);
 +	shadow_start = ALIGN_DOWN(shadow_start, PAGE_SIZE);
 +	shadow_end = (unsigned long)kasan_mem_to_shadow((void *)addr + size);
 +	shadow_end = ALIGN(shadow_end, PAGE_SIZE);
 +
 +	ret = apply_to_page_range(&init_mm, shadow_start,
 +				  shadow_end - shadow_start,
 +				  kasan_populate_vmalloc_pte, NULL);
 +	if (ret)
 +		return ret;
 +
 +	flush_cache_vmap(shadow_start, shadow_end);
 +
 +	/*
 +	 * We need to be careful about inter-cpu effects here. Consider:
 +	 *
 +	 *   CPU#0				  CPU#1
 +	 * WRITE_ONCE(p, vmalloc(100));		while (x = READ_ONCE(p)) ;
 +	 *					p[99] = 1;
 +	 *
 +	 * With compiler instrumentation, that ends up looking like this:
 +	 *
 +	 *   CPU#0				  CPU#1
 +	 * // vmalloc() allocates memory
 +	 * // let a = area->addr
 +	 * // we reach kasan_populate_vmalloc
 +	 * // and call kasan_unpoison_shadow:
 +	 * STORE shadow(a), unpoison_val
 +	 * ...
 +	 * STORE shadow(a+99), unpoison_val	x = LOAD p
 +	 * // rest of vmalloc process		<data dependency>
 +	 * STORE p, a				LOAD shadow(x+99)
 +	 *
 +	 * If there is no barrier between the end of unpoisioning the shadow
 +	 * and the store of the result to p, the stores could be committed
 +	 * in a different order by CPU#0, and CPU#1 could erroneously observe
 +	 * poison in the shadow.
 +	 *
 +	 * We need some sort of barrier between the stores.
 +	 *
 +	 * In the vmalloc() case, this is provided by a smp_wmb() in
 +	 * clear_vm_uninitialized_flag(). In the per-cpu allocator and in
 +	 * get_vm_area() and friends, the caller gets shadow allocated but
 +	 * doesn't have any pages mapped into the virtual address space that
 +	 * has been reserved. Mapping those pages in will involve taking and
 +	 * releasing a page-table lock, which will provide the barrier.
 +	 */
 +
 +	return 0;
 +}
 +
 +/*
 + * Poison the shadow for a vmalloc region. Called as part of the
 + * freeing process at the time the region is freed.
 + */
 +void kasan_poison_vmalloc(const void *start, unsigned long size)
 +{
 +	if (!is_vmalloc_or_module_addr(start))
 +		return;
 +
 +	size = round_up(size, KASAN_SHADOW_SCALE_SIZE);
 +	kasan_poison_shadow(start, size, KASAN_VMALLOC_INVALID);
 +}
 +
 +void kasan_unpoison_vmalloc(const void *start, unsigned long size)
 +{
 +	if (!is_vmalloc_or_module_addr(start))
 +		return;
 +
 +	kasan_unpoison_shadow(start, size);
 +}
 +
 +static int kasan_depopulate_vmalloc_pte(pte_t *ptep, unsigned long addr,
 +					void *unused)
 +{
 +	unsigned long page;
 +
 +	page = (unsigned long)__va(pte_pfn(*ptep) << PAGE_SHIFT);
 +
 +	spin_lock(&init_mm.page_table_lock);
 +
 +	if (likely(!pte_none(*ptep))) {
 +		pte_clear(&init_mm, addr, ptep);
 +		free_page(page);
 +	}
 +	spin_unlock(&init_mm.page_table_lock);
 +
 +	return 0;
 +}
 +
 +/*
 + * Release the backing for the vmalloc region [start, end), which
 + * lies within the free region [free_region_start, free_region_end).
 + *
 + * This can be run lazily, long after the region was freed. It runs
 + * under vmap_area_lock, so it's not safe to interact with the vmalloc/vmap
 + * infrastructure.
 + *
 + * How does this work?
 + * -------------------
 + *
 + * We have a region that is page aligned, labelled as A.
 + * That might not map onto the shadow in a way that is page-aligned:
 + *
 + *                    start                     end
 + *                    v                         v
 + * |????????|????????|AAAAAAAA|AA....AA|AAAAAAAA|????????| < vmalloc
 + *  -------- -------- --------          -------- --------
 + *      |        |       |                 |        |
 + *      |        |       |         /-------/        |
 + *      \-------\|/------/         |/---------------/
 + *              |||                ||
 + *             |??AAAAAA|AAAAAAAA|AA??????|                < shadow
 + *                 (1)      (2)      (3)
 + *
 + * First we align the start upwards and the end downwards, so that the
 + * shadow of the region aligns with shadow page boundaries. In the
 + * example, this gives us the shadow page (2). This is the shadow entirely
 + * covered by this allocation.
 + *
 + * Then we have the tricky bits. We want to know if we can free the
 + * partially covered shadow pages - (1) and (3) in the example. For this,
 + * we are given the start and end of the free region that contains this
 + * allocation. Extending our previous example, we could have:
 + *
 + *  free_region_start                                    free_region_end
 + *  |                 start                     end      |
 + *  v                 v                         v        v
 + * |FFFFFFFF|FFFFFFFF|AAAAAAAA|AA....AA|AAAAAAAA|FFFFFFFF| < vmalloc
 + *  -------- -------- --------          -------- --------
 + *      |        |       |                 |        |
 + *      |        |       |         /-------/        |
 + *      \-------\|/------/         |/---------------/
 + *              |||                ||
 + *             |FFAAAAAA|AAAAAAAA|AAF?????|                < shadow
 + *                 (1)      (2)      (3)
 + *
 + * Once again, we align the start of the free region up, and the end of
 + * the free region down so that the shadow is page aligned. So we can free
 + * page (1) - we know no allocation currently uses anything in that page,
 + * because all of it is in the vmalloc free region. But we cannot free
 + * page (3), because we can't be sure that the rest of it is unused.
 + *
 + * We only consider pages that contain part of the original region for
 + * freeing: we don't try to free other pages from the free region or we'd
 + * end up trying to free huge chunks of virtual address space.
 + *
 + * Concurrency
 + * -----------
 + *
 + * How do we know that we're not freeing a page that is simultaneously
 + * being used for a fresh allocation in kasan_populate_vmalloc(_pte)?
 + *
 + * We _can_ have kasan_release_vmalloc and kasan_populate_vmalloc running
 + * at the same time. While we run under free_vmap_area_lock, the population
 + * code does not.
 + *
 + * free_vmap_area_lock instead operates to ensure that the larger range
 + * [free_region_start, free_region_end) is safe: because __alloc_vmap_area and
 + * the per-cpu region-finding algorithm both run under free_vmap_area_lock,
 + * no space identified as free will become used while we are running. This
 + * means that so long as we are careful with alignment and only free shadow
 + * pages entirely covered by the free region, we will not run in to any
 + * trouble - any simultaneous allocations will be for disjoint regions.
 + */
 +void kasan_release_vmalloc(unsigned long start, unsigned long end,
 +			   unsigned long free_region_start,
 +			   unsigned long free_region_end)
 +{
 +	void *shadow_start, *shadow_end;
 +	unsigned long region_start, region_end;
 +	unsigned long size;
 +
 +	region_start = ALIGN(start, PAGE_SIZE * KASAN_SHADOW_SCALE_SIZE);
 +	region_end = ALIGN_DOWN(end, PAGE_SIZE * KASAN_SHADOW_SCALE_SIZE);
 +
 +	free_region_start = ALIGN(free_region_start,
 +				  PAGE_SIZE * KASAN_SHADOW_SCALE_SIZE);
 +
 +	if (start != region_start &&
 +	    free_region_start < region_start)
 +		region_start -= PAGE_SIZE * KASAN_SHADOW_SCALE_SIZE;
 +
 +	free_region_end = ALIGN_DOWN(free_region_end,
 +				     PAGE_SIZE * KASAN_SHADOW_SCALE_SIZE);
 +
 +	if (end != region_end &&
 +	    free_region_end > region_end)
 +		region_end += PAGE_SIZE * KASAN_SHADOW_SCALE_SIZE;
 +
 +	shadow_start = kasan_mem_to_shadow((void *)region_start);
 +	shadow_end = kasan_mem_to_shadow((void *)region_end);
 +
 +	if (shadow_end > shadow_start) {
 +		size = shadow_end - shadow_start;
 +		apply_to_existing_page_range(&init_mm,
 +					     (unsigned long)shadow_start,
 +					     size, kasan_depopulate_vmalloc_pte,
 +					     NULL);
 +		flush_tlb_kernel_range((unsigned long)shadow_start,
 +				       (unsigned long)shadow_end);
 +	}
 +}
 +#endif
* Unmerged path include/linux/kasan.h
* Unmerged path mm/kasan/common.c
