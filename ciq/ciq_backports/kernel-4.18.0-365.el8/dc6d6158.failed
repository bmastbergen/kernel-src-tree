drm/i915/display: split out dpt out of intel_display.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Jani Nikula <jani.nikula@intel.com>
commit dc6d6158a6e8b11a11544a541583296d9323050f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/dc6d6158.failed

Let's try to reduce the size of intel_display.c, not increase it.

	Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
	Signed-off-by: Jani Nikula <jani.nikula@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/934a2a0db05e835f6843befef6082e2034f23b3a.1629721467.git.jani.nikula@intel.com
(cherry picked from commit dc6d6158a6e8b11a11544a541583296d9323050f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_display.c
diff --cc drivers/gpu/drm/i915/display/intel_display.c
index 19f6e7572c75,eea9553845b2..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@@ -73,9 -80,11 +73,10 @@@
  #include "intel_cdclk.h"
  #include "intel_color.h"
  #include "intel_crtc.h"
 -#include "intel_de.h"
 +#include "intel_csr.h"
  #include "intel_display_types.h"
 -#include "intel_dmc.h"
  #include "intel_dp_link_training.h"
+ #include "intel_dpt.h"
  #include "intel_fbc.h"
  #include "intel_fdi.h"
  #include "intel_fbdev.h"
@@@ -2674,927 -1743,96 +2675,963 @@@ intel_alloc_initial_plane_obj(struct in
  {
  	struct drm_device *dev = crtc->base.dev;
  	struct drm_i915_private *dev_priv = to_i915(dev);
 -	struct intel_crtc_state *crtc_state =
 -		to_intel_crtc_state(crtc->base.state);
 -	struct intel_plane *plane =
 -		to_intel_plane(crtc->base.primary);
 -	struct intel_plane_state *plane_state =
 -		to_intel_plane_state(plane->base.state);
 -	struct drm_framebuffer *fb;
 +	struct drm_mode_fb_cmd2 mode_cmd = { 0 };
 +	struct drm_framebuffer *fb = &plane_config->fb->base;
 +	struct i915_vma *vma;
 +
 +	switch (fb->modifier) {
 +	case DRM_FORMAT_MOD_LINEAR:
 +	case I915_FORMAT_MOD_X_TILED:
 +	case I915_FORMAT_MOD_Y_TILED:
 +		break;
 +	default:
 +		drm_dbg(&dev_priv->drm,
 +			"Unsupported modifier for initial FB: 0x%llx\n",
 +			fb->modifier);
 +		return false;
 +	}
 +
 +	vma = initial_plane_vma(dev_priv, plane_config);
 +	if (!vma)
 +		return false;
 +
 +	mode_cmd.pixel_format = fb->format->format;
 +	mode_cmd.width = fb->width;
 +	mode_cmd.height = fb->height;
 +	mode_cmd.pitches[0] = fb->pitches[0];
 +	mode_cmd.modifier[0] = fb->modifier;
 +	mode_cmd.flags = DRM_MODE_FB_MODIFIERS;
 +
 +	if (intel_framebuffer_init(to_intel_framebuffer(fb),
 +				   vma->obj, &mode_cmd)) {
 +		drm_dbg_kms(&dev_priv->drm, "intel fb init failed\n");
 +		goto err_vma;
 +	}
 +
 +	plane_config->vma = vma;
 +	return true;
 +
 +err_vma:
 +	i915_vma_put(vma);
 +	return false;
 +}
 +
 +static void
 +intel_set_plane_visible(struct intel_crtc_state *crtc_state,
 +			struct intel_plane_state *plane_state,
 +			bool visible)
 +{
 +	struct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);
 +
 +	plane_state->uapi.visible = visible;
 +
 +	if (visible)
 +		crtc_state->uapi.plane_mask |= drm_plane_mask(&plane->base);
 +	else
 +		crtc_state->uapi.plane_mask &= ~drm_plane_mask(&plane->base);
 +}
 +
 +static void fixup_plane_bitmasks(struct intel_crtc_state *crtc_state)
 +{
 +	struct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);
 +	struct drm_plane *plane;
 +
 +	/*
 +	 * Active_planes aliases if multiple "primary" or cursor planes
 +	 * have been used on the same (or wrong) pipe. plane_mask uses
 +	 * unique ids, hence we can use that to reconstruct active_planes.
 +	 */
 +	crtc_state->enabled_planes = 0;
 +	crtc_state->active_planes = 0;
 +
 +	drm_for_each_plane_mask(plane, &dev_priv->drm,
 +				crtc_state->uapi.plane_mask) {
 +		crtc_state->enabled_planes |= BIT(to_intel_plane(plane)->id);
 +		crtc_state->active_planes |= BIT(to_intel_plane(plane)->id);
 +	}
 +}
 +
 +static void intel_plane_disable_noatomic(struct intel_crtc *crtc,
 +					 struct intel_plane *plane)
 +{
 +	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 +	struct intel_crtc_state *crtc_state =
 +		to_intel_crtc_state(crtc->base.state);
 +	struct intel_plane_state *plane_state =
 +		to_intel_plane_state(plane->base.state);
 +
 +	drm_dbg_kms(&dev_priv->drm,
 +		    "Disabling [PLANE:%d:%s] on [CRTC:%d:%s]\n",
 +		    plane->base.base.id, plane->base.name,
 +		    crtc->base.base.id, crtc->base.name);
 +
 +	intel_set_plane_visible(crtc_state, plane_state, false);
 +	fixup_plane_bitmasks(crtc_state);
 +	crtc_state->data_rate[plane->id] = 0;
 +	crtc_state->min_cdclk[plane->id] = 0;
 +
 +	if (plane->id == PLANE_PRIMARY)
 +		hsw_disable_ips(crtc_state);
 +
 +	/*
 +	 * Vblank time updates from the shadow to live plane control register
 +	 * are blocked if the memory self-refresh mode is active at that
 +	 * moment. So to make sure the plane gets truly disabled, disable
 +	 * first the self-refresh mode. The self-refresh enable bit in turn
 +	 * will be checked/applied by the HW only at the next frame start
 +	 * event which is after the vblank start event, so we need to have a
 +	 * wait-for-vblank between disabling the plane and the pipe.
 +	 */
 +	if (HAS_GMCH(dev_priv) &&
 +	    intel_set_memory_cxsr(dev_priv, false))
 +		intel_wait_for_vblank(dev_priv, crtc->pipe);
 +
 +	/*
 +	 * Gen2 reports pipe underruns whenever all planes are disabled.
 +	 * So disable underrun reporting before all the planes get disabled.
 +	 */
 +	if (IS_GEN(dev_priv, 2) && !crtc_state->active_planes)
 +		intel_set_cpu_fifo_underrun_reporting(dev_priv, crtc->pipe, false);
 +
 +	intel_disable_plane(plane, crtc_state);
++<<<<<<< HEAD
++=======
++	intel_wait_for_vblank(dev_priv, crtc->pipe);
++}
++
++static bool
++intel_reuse_initial_plane_obj(struct drm_i915_private *i915,
++			      const struct intel_initial_plane_config *plane_config,
++			      struct drm_framebuffer **fb,
++			      struct i915_vma **vma)
++{
++	struct intel_crtc *crtc;
++
++	for_each_intel_crtc(&i915->drm, crtc) {
++		struct intel_crtc_state *crtc_state =
++			to_intel_crtc_state(crtc->base.state);
++		struct intel_plane *plane =
++			to_intel_plane(crtc->base.primary);
++		struct intel_plane_state *plane_state =
++			to_intel_plane_state(plane->base.state);
++
++		if (!crtc_state->uapi.active)
++			continue;
++
++		if (!plane_state->ggtt_vma)
++			continue;
++
++		if (intel_plane_ggtt_offset(plane_state) == plane_config->base) {
++			*fb = plane_state->hw.fb;
++			*vma = plane_state->ggtt_vma;
++			return true;
++		}
++	}
++
++	return false;
++>>>>>>> dc6d6158a6e8 (drm/i915/display: split out dpt out of intel_display.c)
 +}
 +
 +static void
 +intel_find_initial_plane_obj(struct intel_crtc *intel_crtc,
 +			     struct intel_initial_plane_config *plane_config)
 +{
 +	struct drm_device *dev = intel_crtc->base.dev;
 +	struct drm_i915_private *dev_priv = to_i915(dev);
 +	struct drm_crtc *c;
 +	struct drm_plane *primary = intel_crtc->base.primary;
 +	struct drm_plane_state *plane_state = primary->state;
 +	struct intel_plane *intel_plane = to_intel_plane(primary);
 +	struct intel_plane_state *intel_state =
 +		to_intel_plane_state(plane_state);
 +	struct intel_crtc_state *crtc_state =
 +		to_intel_crtc_state(intel_crtc->base.state);
 +	struct drm_framebuffer *fb;
  	struct i915_vma *vma;
  
 -	/*
 -	 * TODO:
 -	 *   Disable planes if get_initial_plane_config() failed.
 -	 *   Make sure things work if the surface base is not page aligned.
 -	 */
 -	if (!plane_config->fb)
 -		return;
 +	if (!plane_config->fb)
 +		return;
 +
 +	if (intel_alloc_initial_plane_obj(intel_crtc, plane_config)) {
 +		fb = &plane_config->fb->base;
 +		vma = plane_config->vma;
 +		goto valid_fb;
 +	}
 +
 +	/*
 +	 * Failed to alloc the obj, check to see if we should share
 +	 * an fb with another CRTC instead
 +	 */
 +	for_each_crtc(dev, c) {
 +		struct intel_plane_state *state;
 +
 +		if (c == &intel_crtc->base)
 +			continue;
 +
 +		if (!to_intel_crtc_state(c->state)->uapi.active)
 +			continue;
 +
 +		state = to_intel_plane_state(c->primary->state);
 +		if (!state->vma)
 +			continue;
 +
 +		if (intel_plane_ggtt_offset(state) == plane_config->base) {
 +			fb = state->hw.fb;
 +			vma = state->vma;
 +			goto valid_fb;
 +		}
 +	}
 +
 +	/*
 +	 * We've failed to reconstruct the BIOS FB.  Current display state
 +	 * indicates that the primary plane is visible, but has a NULL FB,
 +	 * which will lead to problems later if we don't fix it up.  The
 +	 * simplest solution is to just disable the primary plane now and
 +	 * pretend the BIOS never had it enabled.
 +	 */
 +	intel_plane_disable_noatomic(intel_crtc, intel_plane);
 +	if (crtc_state->bigjoiner) {
 +		struct intel_crtc *slave =
 +			crtc_state->bigjoiner_linked_crtc;
 +		intel_plane_disable_noatomic(slave, to_intel_plane(slave->base.primary));
 +	}
 +
 +	return;
 +
 +valid_fb:
 +	intel_state->hw.rotation = plane_config->rotation;
 +	intel_fill_fb_ggtt_view(&intel_state->view, fb,
 +				intel_state->hw.rotation);
 +	intel_state->color_plane[0].stride =
 +		intel_fb_pitch(fb, 0, intel_state->hw.rotation);
 +
 +	__i915_vma_pin(vma);
 +	intel_state->vma = i915_vma_get(vma);
 +	if (intel_plane_uses_fence(intel_state) && i915_vma_pin_fence(vma) == 0)
 +		if (vma->fence)
 +			intel_state->flags |= PLANE_HAS_FENCE;
 +
 +	plane_state->src_x = 0;
 +	plane_state->src_y = 0;
 +	plane_state->src_w = fb->width << 16;
 +	plane_state->src_h = fb->height << 16;
 +
 +	plane_state->crtc_x = 0;
 +	plane_state->crtc_y = 0;
 +	plane_state->crtc_w = fb->width;
 +	plane_state->crtc_h = fb->height;
 +
 +	intel_state->uapi.src = drm_plane_state_src(plane_state);
 +	intel_state->uapi.dst = drm_plane_state_dest(plane_state);
 +
 +	if (plane_config->tiling)
 +		dev_priv->preserve_bios_swizzle = true;
 +
 +	plane_state->fb = fb;
 +	drm_framebuffer_get(fb);
 +
 +	plane_state->crtc = &intel_crtc->base;
 +	intel_plane_copy_uapi_to_hw_state(intel_state, intel_state,
 +					  intel_crtc);
 +
 +	intel_frontbuffer_flush(to_intel_frontbuffer(fb), ORIGIN_DIRTYFB);
 +
 +	atomic_or(to_intel_plane(primary)->frontbuffer_bit,
 +		  &to_intel_frontbuffer(fb)->bits);
 +}
 +
 +
 +static bool
 +skl_check_main_ccs_coordinates(struct intel_plane_state *plane_state,
 +			       int main_x, int main_y, u32 main_offset,
 +			       int ccs_plane)
 +{
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	int aux_x = plane_state->color_plane[ccs_plane].x;
 +	int aux_y = plane_state->color_plane[ccs_plane].y;
 +	u32 aux_offset = plane_state->color_plane[ccs_plane].offset;
 +	u32 alignment = intel_surf_alignment(fb, ccs_plane);
 +	int hsub;
 +	int vsub;
 +
 +	intel_fb_plane_get_subsampling(&hsub, &vsub, fb, ccs_plane);
 +	while (aux_offset >= main_offset && aux_y <= main_y) {
 +		int x, y;
 +
 +		if (aux_x == main_x && aux_y == main_y)
 +			break;
 +
 +		if (aux_offset == 0)
 +			break;
 +
 +		x = aux_x / hsub;
 +		y = aux_y / vsub;
 +		aux_offset = intel_plane_adjust_aligned_offset(&x, &y,
 +							       plane_state,
 +							       ccs_plane,
 +							       aux_offset,
 +							       aux_offset -
 +								alignment);
 +		aux_x = x * hsub + aux_x % hsub;
 +		aux_y = y * vsub + aux_y % vsub;
 +	}
 +
 +	if (aux_x != main_x || aux_y != main_y)
 +		return false;
 +
 +	plane_state->color_plane[ccs_plane].offset = aux_offset;
 +	plane_state->color_plane[ccs_plane].x = aux_x;
 +	plane_state->color_plane[ccs_plane].y = aux_y;
 +
 +	return true;
 +}
 +
 +unsigned int
 +intel_plane_fence_y_offset(const struct intel_plane_state *plane_state)
 +{
 +	int x = 0, y = 0;
 +
 +	intel_plane_adjust_aligned_offset(&x, &y, plane_state, 0,
 +					  plane_state->color_plane[0].offset, 0);
 +
 +	return y;
 +}
 +
 +static int intel_plane_min_width(struct intel_plane *plane,
 +				 const struct drm_framebuffer *fb,
 +				 int color_plane,
 +				 unsigned int rotation)
 +{
 +	if (plane->min_width)
 +		return plane->min_width(fb, color_plane, rotation);
 +	else
 +		return 1;
 +}
 +
 +static int intel_plane_max_width(struct intel_plane *plane,
 +				 const struct drm_framebuffer *fb,
 +				 int color_plane,
 +				 unsigned int rotation)
 +{
 +	if (plane->max_width)
 +		return plane->max_width(fb, color_plane, rotation);
 +	else
 +		return INT_MAX;
 +}
 +
 +static int intel_plane_max_height(struct intel_plane *plane,
 +				  const struct drm_framebuffer *fb,
 +				  int color_plane,
 +				  unsigned int rotation)
 +{
 +	if (plane->max_height)
 +		return plane->max_height(fb, color_plane, rotation);
 +	else
 +		return INT_MAX;
 +}
 +
 +int skl_calc_main_surface_offset(const struct intel_plane_state *plane_state,
 +				 int *x, int *y, u32 *offset)
 +{
 +	struct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);
 +	struct drm_i915_private *dev_priv = to_i915(plane->base.dev);
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	const int aux_plane = intel_main_to_aux_plane(fb, 0);
 +	const u32 aux_offset = plane_state->color_plane[aux_plane].offset;
 +	const u32 alignment = intel_surf_alignment(fb, 0);
 +	const int w = drm_rect_width(&plane_state->uapi.src) >> 16;
 +
 +	intel_add_fb_offsets(x, y, plane_state, 0);
 +	*offset = intel_plane_compute_aligned_offset(x, y, plane_state, 0);
 +	if (drm_WARN_ON(&dev_priv->drm, alignment && !is_power_of_2(alignment)))
 +		return -EINVAL;
 +
 +	/*
 +	 * AUX surface offset is specified as the distance from the
 +	 * main surface offset, and it must be non-negative. Make
 +	 * sure that is what we will get.
 +	 */
 +	if (aux_plane && *offset > aux_offset)
 +		*offset = intel_plane_adjust_aligned_offset(x, y, plane_state, 0,
 +							    *offset,
 +							    aux_offset & ~(alignment - 1));
 +
 +	/*
 +	 * When using an X-tiled surface, the plane blows up
 +	 * if the x offset + width exceed the stride.
 +	 *
 +	 * TODO: linear and Y-tiled seem fine, Yf untested,
 +	 */
 +	if (fb->modifier == I915_FORMAT_MOD_X_TILED) {
 +		int cpp = fb->format->cpp[0];
 +
 +		while ((*x + w) * cpp > plane_state->color_plane[0].stride) {
 +			if (*offset == 0) {
 +				drm_dbg_kms(&dev_priv->drm,
 +					    "Unable to find suitable display surface offset due to X-tiling\n");
 +				return -EINVAL;
 +			}
 +
 +			*offset = intel_plane_adjust_aligned_offset(x, y, plane_state, 0,
 +								    *offset,
 +								    *offset - alignment);
 +		}
 +	}
 +
 +	return 0;
 +}
 +
 +static int skl_check_main_surface(struct intel_plane_state *plane_state)
 +{
 +	struct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);
 +	struct drm_i915_private *dev_priv = to_i915(plane->base.dev);
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	const unsigned int rotation = plane_state->hw.rotation;
 +	int x = plane_state->uapi.src.x1 >> 16;
 +	int y = plane_state->uapi.src.y1 >> 16;
 +	const int w = drm_rect_width(&plane_state->uapi.src) >> 16;
 +	const int h = drm_rect_height(&plane_state->uapi.src) >> 16;
 +	const int min_width = intel_plane_min_width(plane, fb, 0, rotation);
 +	const int max_width = intel_plane_max_width(plane, fb, 0, rotation);
 +	const int max_height = intel_plane_max_height(plane, fb, 0, rotation);
 +	const int aux_plane = intel_main_to_aux_plane(fb, 0);
 +	const u32 alignment = intel_surf_alignment(fb, 0);
 +	u32 offset;
 +	int ret;
 +
 +	if (w > max_width || w < min_width || h > max_height) {
 +		drm_dbg_kms(&dev_priv->drm,
 +			    "requested Y/RGB source size %dx%d outside limits (min: %dx1 max: %dx%d)\n",
 +			    w, h, min_width, max_width, max_height);
 +		return -EINVAL;
 +	}
 +
 +	ret = skl_calc_main_surface_offset(plane_state, &x, &y, &offset);
 +	if (ret)
 +		return ret;
 +
 +	/*
 +	 * CCS AUX surface doesn't have its own x/y offsets, we must make sure
 +	 * they match with the main surface x/y offsets.
 +	 */
 +	if (is_ccs_modifier(fb->modifier)) {
 +		while (!skl_check_main_ccs_coordinates(plane_state, x, y,
 +						       offset, aux_plane)) {
 +			if (offset == 0)
 +				break;
 +
 +			offset = intel_plane_adjust_aligned_offset(&x, &y, plane_state, 0,
 +								   offset, offset - alignment);
 +		}
 +
 +		if (x != plane_state->color_plane[aux_plane].x ||
 +		    y != plane_state->color_plane[aux_plane].y) {
 +			drm_dbg_kms(&dev_priv->drm,
 +				    "Unable to find suitable display surface offset due to CCS\n");
 +			return -EINVAL;
 +		}
 +	}
 +
 +	drm_WARN_ON(&dev_priv->drm, x > 8191 || y > 8191);
 +
 +	plane_state->color_plane[0].offset = offset;
 +	plane_state->color_plane[0].x = x;
 +	plane_state->color_plane[0].y = y;
 +
 +	/*
 +	 * Put the final coordinates back so that the src
 +	 * coordinate checks will see the right values.
 +	 */
 +	drm_rect_translate_to(&plane_state->uapi.src,
 +			      x << 16, y << 16);
 +
 +	return 0;
 +}
 +
 +static int skl_check_nv12_aux_surface(struct intel_plane_state *plane_state)
 +{
 +	struct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);
 +	struct drm_i915_private *i915 = to_i915(plane->base.dev);
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	unsigned int rotation = plane_state->hw.rotation;
 +	int uv_plane = 1;
 +	int max_width = intel_plane_max_width(plane, fb, uv_plane, rotation);
 +	int max_height = intel_plane_max_height(plane, fb, uv_plane, rotation);
 +	int x = plane_state->uapi.src.x1 >> 17;
 +	int y = plane_state->uapi.src.y1 >> 17;
 +	int w = drm_rect_width(&plane_state->uapi.src) >> 17;
 +	int h = drm_rect_height(&plane_state->uapi.src) >> 17;
 +	u32 offset;
 +
 +	/* FIXME not quite sure how/if these apply to the chroma plane */
 +	if (w > max_width || h > max_height) {
 +		drm_dbg_kms(&i915->drm,
 +			    "CbCr source size %dx%d too big (limit %dx%d)\n",
 +			    w, h, max_width, max_height);
 +		return -EINVAL;
 +	}
 +
 +	intel_add_fb_offsets(&x, &y, plane_state, uv_plane);
 +	offset = intel_plane_compute_aligned_offset(&x, &y,
 +						    plane_state, uv_plane);
 +
 +	if (is_ccs_modifier(fb->modifier)) {
 +		int ccs_plane = main_to_ccs_plane(fb, uv_plane);
 +		u32 aux_offset = plane_state->color_plane[ccs_plane].offset;
 +		u32 alignment = intel_surf_alignment(fb, uv_plane);
 +
 +		if (offset > aux_offset)
 +			offset = intel_plane_adjust_aligned_offset(&x, &y,
 +								   plane_state,
 +								   uv_plane,
 +								   offset,
 +								   aux_offset & ~(alignment - 1));
 +
 +		while (!skl_check_main_ccs_coordinates(plane_state, x, y,
 +						       offset, ccs_plane)) {
 +			if (offset == 0)
 +				break;
 +
 +			offset = intel_plane_adjust_aligned_offset(&x, &y,
 +								   plane_state,
 +								   uv_plane,
 +								   offset, offset - alignment);
 +		}
 +
 +		if (x != plane_state->color_plane[ccs_plane].x ||
 +		    y != plane_state->color_plane[ccs_plane].y) {
 +			drm_dbg_kms(&i915->drm,
 +				    "Unable to find suitable display surface offset due to CCS\n");
 +			return -EINVAL;
 +		}
 +	}
 +
 +	drm_WARN_ON(&i915->drm, x > 8191 || y > 8191);
 +
 +	plane_state->color_plane[uv_plane].offset = offset;
 +	plane_state->color_plane[uv_plane].x = x;
 +	plane_state->color_plane[uv_plane].y = y;
 +
 +	return 0;
 +}
 +
 +static int skl_check_ccs_aux_surface(struct intel_plane_state *plane_state)
 +{
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	int src_x = plane_state->uapi.src.x1 >> 16;
 +	int src_y = plane_state->uapi.src.y1 >> 16;
 +	u32 offset;
 +	int ccs_plane;
 +
 +	for (ccs_plane = 0; ccs_plane < fb->format->num_planes; ccs_plane++) {
 +		int main_hsub, main_vsub;
 +		int hsub, vsub;
 +		int x, y;
 +
 +		if (!is_ccs_plane(fb, ccs_plane) ||
 +		    is_gen12_ccs_cc_plane(fb, ccs_plane))
 +			continue;
 +
 +		intel_fb_plane_get_subsampling(&main_hsub, &main_vsub, fb,
 +					       ccs_to_main_plane(fb, ccs_plane));
 +		intel_fb_plane_get_subsampling(&hsub, &vsub, fb, ccs_plane);
 +
 +		hsub *= main_hsub;
 +		vsub *= main_vsub;
 +		x = src_x / hsub;
 +		y = src_y / vsub;
 +
 +		intel_add_fb_offsets(&x, &y, plane_state, ccs_plane);
 +
 +		offset = intel_plane_compute_aligned_offset(&x, &y,
 +							    plane_state,
 +							    ccs_plane);
 +
 +		plane_state->color_plane[ccs_plane].offset = offset;
 +		plane_state->color_plane[ccs_plane].x = (x * hsub +
 +							 src_x % hsub) /
 +							main_hsub;
 +		plane_state->color_plane[ccs_plane].y = (y * vsub +
 +							 src_y % vsub) /
 +							main_vsub;
 +	}
 +
 +	return 0;
 +}
 +
 +int skl_check_plane_surface(struct intel_plane_state *plane_state)
 +{
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	int ret, i;
 +
 +	ret = intel_plane_compute_gtt(plane_state);
 +	if (ret)
 +		return ret;
 +
 +	if (!plane_state->uapi.visible)
 +		return 0;
 +
 +	/*
 +	 * Handle the AUX surface first since the main surface setup depends on
 +	 * it.
 +	 */
 +	if (is_ccs_modifier(fb->modifier)) {
 +		ret = skl_check_ccs_aux_surface(plane_state);
 +		if (ret)
 +			return ret;
 +	}
 +
 +	if (intel_format_info_is_yuv_semiplanar(fb->format,
 +						fb->modifier)) {
 +		ret = skl_check_nv12_aux_surface(plane_state);
 +		if (ret)
 +			return ret;
 +	}
 +
 +	for (i = fb->format->num_planes; i < ARRAY_SIZE(plane_state->color_plane); i++) {
 +		plane_state->color_plane[i].offset = 0;
 +		plane_state->color_plane[i].x = 0;
 +		plane_state->color_plane[i].y = 0;
 +	}
 +
 +	ret = skl_check_main_surface(plane_state);
 +	if (ret)
 +		return ret;
 +
 +	return 0;
 +}
 +
 +static void skl_detach_scaler(struct intel_crtc *intel_crtc, int id)
 +{
 +	struct drm_device *dev = intel_crtc->base.dev;
 +	struct drm_i915_private *dev_priv = to_i915(dev);
 +	unsigned long irqflags;
 +
 +	spin_lock_irqsave(&dev_priv->uncore.lock, irqflags);
 +
 +	intel_de_write_fw(dev_priv, SKL_PS_CTRL(intel_crtc->pipe, id), 0);
 +	intel_de_write_fw(dev_priv, SKL_PS_WIN_POS(intel_crtc->pipe, id), 0);
 +	intel_de_write_fw(dev_priv, SKL_PS_WIN_SZ(intel_crtc->pipe, id), 0);
 +
 +	spin_unlock_irqrestore(&dev_priv->uncore.lock, irqflags);
 +}
 +
 +/*
 + * This function detaches (aka. unbinds) unused scalers in hardware
 + */
 +static void skl_detach_scalers(const struct intel_crtc_state *crtc_state)
 +{
 +	struct intel_crtc *intel_crtc = to_intel_crtc(crtc_state->uapi.crtc);
 +	const struct intel_crtc_scaler_state *scaler_state =
 +		&crtc_state->scaler_state;
 +	int i;
 +
 +	/* loop through and disable scalers that aren't in use */
 +	for (i = 0; i < intel_crtc->num_scalers; i++) {
 +		if (!scaler_state->scalers[i].in_use)
 +			skl_detach_scaler(intel_crtc, i);
 +	}
 +}
 +
 +static unsigned int skl_plane_stride_mult(const struct drm_framebuffer *fb,
 +					  int color_plane, unsigned int rotation)
 +{
 +	/*
 +	 * The stride is either expressed as a multiple of 64 bytes chunks for
 +	 * linear buffers or in number of tiles for tiled buffers.
 +	 */
 +	if (is_surface_linear(fb, color_plane))
 +		return 64;
 +	else if (drm_rotation_90_or_270(rotation))
 +		return intel_tile_height(fb, color_plane);
 +	else
 +		return intel_tile_width_bytes(fb, color_plane);
 +}
 +
 +u32 skl_plane_stride(const struct intel_plane_state *plane_state,
 +		     int color_plane)
 +{
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	unsigned int rotation = plane_state->hw.rotation;
 +	u32 stride = plane_state->color_plane[color_plane].stride;
 +
 +	if (color_plane >= fb->format->num_planes)
 +		return 0;
 +
 +	return stride / skl_plane_stride_mult(fb, color_plane, rotation);
 +}
 +
 +static u32 skl_plane_ctl_format(u32 pixel_format)
 +{
 +	switch (pixel_format) {
 +	case DRM_FORMAT_C8:
 +		return PLANE_CTL_FORMAT_INDEXED;
 +	case DRM_FORMAT_RGB565:
 +		return PLANE_CTL_FORMAT_RGB_565;
 +	case DRM_FORMAT_XBGR8888:
 +	case DRM_FORMAT_ABGR8888:
 +		return PLANE_CTL_FORMAT_XRGB_8888 | PLANE_CTL_ORDER_RGBX;
 +	case DRM_FORMAT_XRGB8888:
 +	case DRM_FORMAT_ARGB8888:
 +		return PLANE_CTL_FORMAT_XRGB_8888;
 +	case DRM_FORMAT_XBGR2101010:
 +	case DRM_FORMAT_ABGR2101010:
 +		return PLANE_CTL_FORMAT_XRGB_2101010 | PLANE_CTL_ORDER_RGBX;
 +	case DRM_FORMAT_XRGB2101010:
 +	case DRM_FORMAT_ARGB2101010:
 +		return PLANE_CTL_FORMAT_XRGB_2101010;
 +	case DRM_FORMAT_XBGR16161616F:
 +	case DRM_FORMAT_ABGR16161616F:
 +		return PLANE_CTL_FORMAT_XRGB_16161616F | PLANE_CTL_ORDER_RGBX;
 +	case DRM_FORMAT_XRGB16161616F:
 +	case DRM_FORMAT_ARGB16161616F:
 +		return PLANE_CTL_FORMAT_XRGB_16161616F;
 +	case DRM_FORMAT_XYUV8888:
 +		return PLANE_CTL_FORMAT_XYUV;
 +	case DRM_FORMAT_YUYV:
 +		return PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_YUYV;
 +	case DRM_FORMAT_YVYU:
 +		return PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_YVYU;
 +	case DRM_FORMAT_UYVY:
 +		return PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_UYVY;
 +	case DRM_FORMAT_VYUY:
 +		return PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_VYUY;
 +	case DRM_FORMAT_NV12:
 +		return PLANE_CTL_FORMAT_NV12;
 +	case DRM_FORMAT_P010:
 +		return PLANE_CTL_FORMAT_P010;
 +	case DRM_FORMAT_P012:
 +		return PLANE_CTL_FORMAT_P012;
 +	case DRM_FORMAT_P016:
 +		return PLANE_CTL_FORMAT_P016;
 +	case DRM_FORMAT_Y210:
 +		return PLANE_CTL_FORMAT_Y210;
 +	case DRM_FORMAT_Y212:
 +		return PLANE_CTL_FORMAT_Y212;
 +	case DRM_FORMAT_Y216:
 +		return PLANE_CTL_FORMAT_Y216;
 +	case DRM_FORMAT_XVYU2101010:
 +		return PLANE_CTL_FORMAT_Y410;
 +	case DRM_FORMAT_XVYU12_16161616:
 +		return PLANE_CTL_FORMAT_Y412;
 +	case DRM_FORMAT_XVYU16161616:
 +		return PLANE_CTL_FORMAT_Y416;
 +	default:
 +		MISSING_CASE(pixel_format);
 +	}
 +
 +	return 0;
 +}
 +
 +static u32 skl_plane_ctl_alpha(const struct intel_plane_state *plane_state)
 +{
 +	if (!plane_state->hw.fb->format->has_alpha)
 +		return PLANE_CTL_ALPHA_DISABLE;
 +
 +	switch (plane_state->hw.pixel_blend_mode) {
 +	case DRM_MODE_BLEND_PIXEL_NONE:
 +		return PLANE_CTL_ALPHA_DISABLE;
 +	case DRM_MODE_BLEND_PREMULTI:
 +		return PLANE_CTL_ALPHA_SW_PREMULTIPLY;
 +	case DRM_MODE_BLEND_COVERAGE:
 +		return PLANE_CTL_ALPHA_HW_PREMULTIPLY;
 +	default:
 +		MISSING_CASE(plane_state->hw.pixel_blend_mode);
 +		return PLANE_CTL_ALPHA_DISABLE;
 +	}
 +}
 +
 +static u32 glk_plane_color_ctl_alpha(const struct intel_plane_state *plane_state)
 +{
 +	if (!plane_state->hw.fb->format->has_alpha)
 +		return PLANE_COLOR_ALPHA_DISABLE;
 +
 +	switch (plane_state->hw.pixel_blend_mode) {
 +	case DRM_MODE_BLEND_PIXEL_NONE:
 +		return PLANE_COLOR_ALPHA_DISABLE;
 +	case DRM_MODE_BLEND_PREMULTI:
 +		return PLANE_COLOR_ALPHA_SW_PREMULTIPLY;
 +	case DRM_MODE_BLEND_COVERAGE:
 +		return PLANE_COLOR_ALPHA_HW_PREMULTIPLY;
 +	default:
 +		MISSING_CASE(plane_state->hw.pixel_blend_mode);
 +		return PLANE_COLOR_ALPHA_DISABLE;
 +	}
 +}
 +
 +static u32 skl_plane_ctl_tiling(u64 fb_modifier)
 +{
 +	switch (fb_modifier) {
 +	case DRM_FORMAT_MOD_LINEAR:
 +		break;
 +	case I915_FORMAT_MOD_X_TILED:
 +		return PLANE_CTL_TILED_X;
 +	case I915_FORMAT_MOD_Y_TILED:
 +		return PLANE_CTL_TILED_Y;
 +	case I915_FORMAT_MOD_Y_TILED_CCS:
 +	case I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS_CC:
 +		return PLANE_CTL_TILED_Y | PLANE_CTL_RENDER_DECOMPRESSION_ENABLE;
 +	case I915_FORMAT_MOD_Y_TILED_GEN12_RC_CCS:
 +		return PLANE_CTL_TILED_Y |
 +		       PLANE_CTL_RENDER_DECOMPRESSION_ENABLE |
 +		       PLANE_CTL_CLEAR_COLOR_DISABLE;
 +	case I915_FORMAT_MOD_Y_TILED_GEN12_MC_CCS:
 +		return PLANE_CTL_TILED_Y | PLANE_CTL_MEDIA_DECOMPRESSION_ENABLE;
 +	case I915_FORMAT_MOD_Yf_TILED:
 +		return PLANE_CTL_TILED_YF;
 +	case I915_FORMAT_MOD_Yf_TILED_CCS:
 +		return PLANE_CTL_TILED_YF | PLANE_CTL_RENDER_DECOMPRESSION_ENABLE;
 +	default:
 +		MISSING_CASE(fb_modifier);
 +	}
 +
 +	return 0;
 +}
 +
 +static u32 skl_plane_ctl_rotate(unsigned int rotate)
 +{
 +	switch (rotate) {
 +	case DRM_MODE_ROTATE_0:
 +		break;
 +	/*
 +	 * DRM_MODE_ROTATE_ is counter clockwise to stay compatible with Xrandr
 +	 * while i915 HW rotation is clockwise, thats why this swapping.
 +	 */
 +	case DRM_MODE_ROTATE_90:
 +		return PLANE_CTL_ROTATE_270;
 +	case DRM_MODE_ROTATE_180:
 +		return PLANE_CTL_ROTATE_180;
 +	case DRM_MODE_ROTATE_270:
 +		return PLANE_CTL_ROTATE_90;
 +	default:
 +		MISSING_CASE(rotate);
 +	}
 +
 +	return 0;
 +}
 +
 +static u32 cnl_plane_ctl_flip(unsigned int reflect)
 +{
 +	switch (reflect) {
 +	case 0:
 +		break;
 +	case DRM_MODE_REFLECT_X:
 +		return PLANE_CTL_FLIP_HORIZONTAL;
 +	case DRM_MODE_REFLECT_Y:
 +	default:
 +		MISSING_CASE(reflect);
 +	}
 +
 +	return 0;
 +}
 +
 +u32 skl_plane_ctl_crtc(const struct intel_crtc_state *crtc_state)
 +{
 +	struct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);
 +	u32 plane_ctl = 0;
 +
 +	if (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv))
 +		return plane_ctl;
 +
 +	if (crtc_state->gamma_enable)
 +		plane_ctl |= PLANE_CTL_PIPE_GAMMA_ENABLE;
 +
 +	if (crtc_state->csc_enable)
 +		plane_ctl |= PLANE_CTL_PIPE_CSC_ENABLE;
 +
 +	return plane_ctl;
 +}
  
 -	if (intel_alloc_initial_plane_obj(crtc, plane_config)) {
 -		fb = &plane_config->fb->base;
 -		vma = plane_config->vma;
 -		goto valid_fb;
 -	}
 +u32 skl_plane_ctl(const struct intel_crtc_state *crtc_state,
 +		  const struct intel_plane_state *plane_state)
 +{
 +	struct drm_i915_private *dev_priv =
 +		to_i915(plane_state->uapi.plane->dev);
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	unsigned int rotation = plane_state->hw.rotation;
 +	const struct drm_intel_sprite_colorkey *key = &plane_state->ckey;
 +	u32 plane_ctl;
  
 -	/*
 -	 * Failed to alloc the obj, check to see if we should share
 -	 * an fb with another CRTC instead
 -	 */
 -	if (intel_reuse_initial_plane_obj(dev_priv, plane_config, &fb, &vma))
 -		goto valid_fb;
 +	plane_ctl = PLANE_CTL_ENABLE;
  
 -	/*
 -	 * We've failed to reconstruct the BIOS FB.  Current display state
 -	 * indicates that the primary plane is visible, but has a NULL FB,
 -	 * which will lead to problems later if we don't fix it up.  The
 -	 * simplest solution is to just disable the primary plane now and
 -	 * pretend the BIOS never had it enabled.
 -	 */
 -	intel_plane_disable_noatomic(crtc, plane);
 -	if (crtc_state->bigjoiner) {
 -		struct intel_crtc *slave =
 -			crtc_state->bigjoiner_linked_crtc;
 -		intel_plane_disable_noatomic(slave, to_intel_plane(slave->base.primary));
 -	}
 +	if (INTEL_GEN(dev_priv) < 10 && !IS_GEMINILAKE(dev_priv)) {
 +		plane_ctl |= skl_plane_ctl_alpha(plane_state);
 +		plane_ctl |= PLANE_CTL_PLANE_GAMMA_DISABLE;
  
 -	return;
 +		if (plane_state->hw.color_encoding == DRM_COLOR_YCBCR_BT709)
 +			plane_ctl |= PLANE_CTL_YUV_TO_RGB_CSC_FORMAT_BT709;
  
 -valid_fb:
 -	plane_state->uapi.rotation = plane_config->rotation;
 -	intel_fb_fill_view(to_intel_framebuffer(fb),
 -			   plane_state->uapi.rotation, &plane_state->view);
 +		if (plane_state->hw.color_range == DRM_COLOR_YCBCR_FULL_RANGE)
 +			plane_ctl |= PLANE_CTL_YUV_RANGE_CORRECTION_DISABLE;
 +	}
  
 -	__i915_vma_pin(vma);
 -	plane_state->ggtt_vma = i915_vma_get(vma);
 -	if (intel_plane_uses_fence(plane_state) &&
 -	    i915_vma_pin_fence(vma) == 0 && vma->fence)
 -		plane_state->flags |= PLANE_HAS_FENCE;
 +	plane_ctl |= skl_plane_ctl_format(fb->format->format);
 +	plane_ctl |= skl_plane_ctl_tiling(fb->modifier);
 +	plane_ctl |= skl_plane_ctl_rotate(rotation & DRM_MODE_ROTATE_MASK);
  
 -	plane_state->uapi.src_x = 0;
 -	plane_state->uapi.src_y = 0;
 -	plane_state->uapi.src_w = fb->width << 16;
 -	plane_state->uapi.src_h = fb->height << 16;
 +	if (INTEL_GEN(dev_priv) >= 10)
 +		plane_ctl |= cnl_plane_ctl_flip(rotation &
 +						DRM_MODE_REFLECT_MASK);
  
 -	plane_state->uapi.crtc_x = 0;
 -	plane_state->uapi.crtc_y = 0;
 -	plane_state->uapi.crtc_w = fb->width;
 -	plane_state->uapi.crtc_h = fb->height;
 +	if (key->flags & I915_SET_COLORKEY_DESTINATION)
 +		plane_ctl |= PLANE_CTL_KEY_ENABLE_DESTINATION;
 +	else if (key->flags & I915_SET_COLORKEY_SOURCE)
 +		plane_ctl |= PLANE_CTL_KEY_ENABLE_SOURCE;
  
 -	if (plane_config->tiling)
 -		dev_priv->preserve_bios_swizzle = true;
 +	return plane_ctl;
 +}
  
 -	plane_state->uapi.fb = fb;
 -	drm_framebuffer_get(fb);
 +u32 glk_plane_color_ctl_crtc(const struct intel_crtc_state *crtc_state)
 +{
 +	struct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);
 +	u32 plane_color_ctl = 0;
  
 -	plane_state->uapi.crtc = &crtc->base;
 -	intel_plane_copy_uapi_to_hw_state(plane_state, plane_state, crtc);
 +	if (INTEL_GEN(dev_priv) >= 11)
 +		return plane_color_ctl;
  
 -	intel_frontbuffer_flush(to_intel_frontbuffer(fb), ORIGIN_DIRTYFB);
 +	if (crtc_state->gamma_enable)
 +		plane_color_ctl |= PLANE_COLOR_PIPE_GAMMA_ENABLE;
  
 -	atomic_or(plane->frontbuffer_bit, &to_intel_frontbuffer(fb)->bits);
 +	if (crtc_state->csc_enable)
 +		plane_color_ctl |= PLANE_COLOR_PIPE_CSC_ENABLE;
 +
 +	return plane_color_ctl;
  }
  
 -unsigned int
 -intel_plane_fence_y_offset(const struct intel_plane_state *plane_state)
 +u32 glk_plane_color_ctl(const struct intel_crtc_state *crtc_state,
 +			const struct intel_plane_state *plane_state)
  {
 -	int x = 0, y = 0;
 +	struct drm_i915_private *dev_priv =
 +		to_i915(plane_state->uapi.plane->dev);
 +	const struct drm_framebuffer *fb = plane_state->hw.fb;
 +	struct intel_plane *plane = to_intel_plane(plane_state->uapi.plane);
 +	u32 plane_color_ctl = 0;
  
 -	intel_plane_adjust_aligned_offset(&x, &y, plane_state, 0,
 -					  plane_state->view.color_plane[0].offset, 0);
 +	plane_color_ctl |= PLANE_COLOR_PLANE_GAMMA_DISABLE;
 +	plane_color_ctl |= glk_plane_color_ctl_alpha(plane_state);
  
 -	return y;
 +	if (fb->format->is_yuv && !icl_is_hdr_plane(dev_priv, plane->id)) {
 +		switch (plane_state->hw.color_encoding) {
 +		case DRM_COLOR_YCBCR_BT709:
 +			plane_color_ctl |= PLANE_COLOR_CSC_MODE_YUV709_TO_RGB709;
 +			break;
 +		case DRM_COLOR_YCBCR_BT2020:
 +			plane_color_ctl |=
 +				PLANE_COLOR_CSC_MODE_YUV2020_TO_RGB2020;
 +			break;
 +		default:
 +			plane_color_ctl |=
 +				PLANE_COLOR_CSC_MODE_YUV601_TO_RGB601;
 +		}
 +		if (plane_state->hw.color_range == DRM_COLOR_YCBCR_FULL_RANGE)
 +			plane_color_ctl |= PLANE_COLOR_YUV_RANGE_CORRECTION_DISABLE;
 +	} else if (fb->format->is_yuv) {
 +		plane_color_ctl |= PLANE_COLOR_INPUT_CSC_ENABLE;
 +		if (plane_state->hw.color_range == DRM_COLOR_YCBCR_FULL_RANGE)
 +			plane_color_ctl |= PLANE_COLOR_YUV_RANGE_CORRECTION_DISABLE;
 +	}
 +
 +	return plane_color_ctl;
  }
  
  static int
diff --git a/drivers/gpu/drm/i915/Makefile b/drivers/gpu/drm/i915/Makefile
index 2f4559138fc7..e09ff7ddcc9f 100644
--- a/drivers/gpu/drm/i915/Makefile
+++ b/drivers/gpu/drm/i915/Makefile
@@ -209,6 +209,7 @@ i915-y += \
 	display/intel_dpio_phy.o \
 	display/intel_dpll.o \
 	display/intel_dpll_mgr.o \
+	display/intel_dpt.o \
 	display/intel_dsb.o \
 	display/intel_fbc.o \
 	display/intel_fdi.o \
* Unmerged path drivers/gpu/drm/i915/display/intel_display.c
diff --git a/drivers/gpu/drm/i915/display/intel_dpt.c b/drivers/gpu/drm/i915/display/intel_dpt.c
new file mode 100644
index 000000000000..22acd945a9e4
--- /dev/null
+++ b/drivers/gpu/drm/i915/display/intel_dpt.c
@@ -0,0 +1,229 @@
+// SPDX-License-Identifier: MIT
+/*
+ * Copyright © 2021 Intel Corporation
+ */
+
+#include "i915_drv.h"
+#include "intel_display_types.h"
+#include "intel_dpt.h"
+#include "intel_fb.h"
+#include "gt/gen8_ppgtt.h"
+
+struct i915_dpt {
+	struct i915_address_space vm;
+
+	struct drm_i915_gem_object *obj;
+	struct i915_vma *vma;
+	void __iomem *iomem;
+};
+
+#define i915_is_dpt(vm) ((vm)->is_dpt)
+
+static inline struct i915_dpt *
+i915_vm_to_dpt(struct i915_address_space *vm)
+{
+	BUILD_BUG_ON(offsetof(struct i915_dpt, vm));
+	GEM_BUG_ON(!i915_is_dpt(vm));
+	return container_of(vm, struct i915_dpt, vm);
+}
+
+#define dpt_total_entries(dpt) ((dpt)->vm.total >> PAGE_SHIFT)
+
+static void gen8_set_pte(void __iomem *addr, gen8_pte_t pte)
+{
+	writeq(pte, addr);
+}
+
+static void dpt_insert_page(struct i915_address_space *vm,
+			    dma_addr_t addr,
+			    u64 offset,
+			    enum i915_cache_level level,
+			    u32 flags)
+{
+	struct i915_dpt *dpt = i915_vm_to_dpt(vm);
+	gen8_pte_t __iomem *base = dpt->iomem;
+
+	gen8_set_pte(base + offset / I915_GTT_PAGE_SIZE,
+		     vm->pte_encode(addr, level, flags));
+}
+
+static void dpt_insert_entries(struct i915_address_space *vm,
+			       struct i915_vma *vma,
+			       enum i915_cache_level level,
+			       u32 flags)
+{
+	struct i915_dpt *dpt = i915_vm_to_dpt(vm);
+	gen8_pte_t __iomem *base = dpt->iomem;
+	const gen8_pte_t pte_encode = vm->pte_encode(0, level, flags);
+	struct sgt_iter sgt_iter;
+	dma_addr_t addr;
+	int i;
+
+	/*
+	 * Note that we ignore PTE_READ_ONLY here. The caller must be careful
+	 * not to allow the user to override access to a read only page.
+	 */
+
+	i = vma->node.start / I915_GTT_PAGE_SIZE;
+	for_each_sgt_daddr(addr, sgt_iter, vma->pages)
+		gen8_set_pte(&base[i++], pte_encode | addr);
+}
+
+static void dpt_clear_range(struct i915_address_space *vm,
+			    u64 start, u64 length)
+{
+}
+
+static void dpt_bind_vma(struct i915_address_space *vm,
+			 struct i915_vm_pt_stash *stash,
+			 struct i915_vma *vma,
+			 enum i915_cache_level cache_level,
+			 u32 flags)
+{
+	struct drm_i915_gem_object *obj = vma->obj;
+	u32 pte_flags;
+
+	/* Applicable to VLV (gen8+ do not support RO in the GGTT) */
+	pte_flags = 0;
+	if (vma->vm->has_read_only && i915_gem_object_is_readonly(obj))
+		pte_flags |= PTE_READ_ONLY;
+	if (i915_gem_object_is_lmem(obj))
+		pte_flags |= PTE_LM;
+
+	vma->vm->insert_entries(vma->vm, vma, cache_level, pte_flags);
+
+	vma->page_sizes.gtt = I915_GTT_PAGE_SIZE;
+
+	/*
+	 * Without aliasing PPGTT there's no difference between
+	 * GLOBAL/LOCAL_BIND, it's all the same ptes. Hence unconditionally
+	 * upgrade to both bound if we bind either to avoid double-binding.
+	 */
+	atomic_or(I915_VMA_GLOBAL_BIND | I915_VMA_LOCAL_BIND, &vma->flags);
+}
+
+static void dpt_unbind_vma(struct i915_address_space *vm, struct i915_vma *vma)
+{
+	vm->clear_range(vm, vma->node.start, vma->size);
+}
+
+static void dpt_cleanup(struct i915_address_space *vm)
+{
+	struct i915_dpt *dpt = i915_vm_to_dpt(vm);
+
+	i915_gem_object_put(dpt->obj);
+}
+
+struct i915_vma *intel_dpt_pin(struct i915_address_space *vm)
+{
+	struct drm_i915_private *i915 = vm->i915;
+	struct i915_dpt *dpt = i915_vm_to_dpt(vm);
+	intel_wakeref_t wakeref;
+	struct i915_vma *vma;
+	void __iomem *iomem;
+
+	wakeref = intel_runtime_pm_get(&i915->runtime_pm);
+	atomic_inc(&i915->gpu_error.pending_fb_pin);
+
+	vma = i915_gem_object_ggtt_pin(dpt->obj, NULL, 0, 4096,
+				       HAS_LMEM(i915) ? 0 : PIN_MAPPABLE);
+	if (IS_ERR(vma))
+		goto err;
+
+	iomem = i915_vma_pin_iomap(vma);
+	i915_vma_unpin(vma);
+	if (IS_ERR(iomem)) {
+		vma = iomem;
+		goto err;
+	}
+
+	dpt->vma = vma;
+	dpt->iomem = iomem;
+
+	i915_vma_get(vma);
+
+err:
+	atomic_dec(&i915->gpu_error.pending_fb_pin);
+	intel_runtime_pm_put(&i915->runtime_pm, wakeref);
+
+	return vma;
+}
+
+void intel_dpt_unpin(struct i915_address_space *vm)
+{
+	struct i915_dpt *dpt = i915_vm_to_dpt(vm);
+
+	i915_vma_unpin_iomap(dpt->vma);
+	i915_vma_put(dpt->vma);
+}
+
+struct i915_address_space *
+intel_dpt_create(struct intel_framebuffer *fb)
+{
+	struct drm_gem_object *obj = &intel_fb_obj(&fb->base)->base;
+	struct drm_i915_private *i915 = to_i915(obj->dev);
+	struct drm_i915_gem_object *dpt_obj;
+	struct i915_address_space *vm;
+	struct i915_dpt *dpt;
+	size_t size;
+	int ret;
+
+	if (intel_fb_needs_pot_stride_remap(fb))
+		size = intel_remapped_info_size(&fb->remapped_view.gtt.remapped);
+	else
+		size = DIV_ROUND_UP_ULL(obj->size, I915_GTT_PAGE_SIZE);
+
+	size = round_up(size * sizeof(gen8_pte_t), I915_GTT_PAGE_SIZE);
+
+	if (HAS_LMEM(i915))
+		dpt_obj = i915_gem_object_create_lmem(i915, size, 0);
+	else
+		dpt_obj = i915_gem_object_create_stolen(i915, size);
+	if (IS_ERR(dpt_obj))
+		return ERR_CAST(dpt_obj);
+
+	ret = i915_gem_object_set_cache_level(dpt_obj, I915_CACHE_NONE);
+	if (ret) {
+		i915_gem_object_put(dpt_obj);
+		return ERR_PTR(ret);
+	}
+
+	dpt = kzalloc(sizeof(*dpt), GFP_KERNEL);
+	if (!dpt) {
+		i915_gem_object_put(dpt_obj);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	vm = &dpt->vm;
+
+	vm->gt = &i915->gt;
+	vm->i915 = i915;
+	vm->dma = i915->drm.dev;
+	vm->total = (size / sizeof(gen8_pte_t)) * I915_GTT_PAGE_SIZE;
+	vm->is_dpt = true;
+
+	i915_address_space_init(vm, VM_CLASS_DPT);
+
+	vm->insert_page = dpt_insert_page;
+	vm->clear_range = dpt_clear_range;
+	vm->insert_entries = dpt_insert_entries;
+	vm->cleanup = dpt_cleanup;
+
+	vm->vma_ops.bind_vma    = dpt_bind_vma;
+	vm->vma_ops.unbind_vma  = dpt_unbind_vma;
+	vm->vma_ops.set_pages   = ggtt_set_pages;
+	vm->vma_ops.clear_pages = clear_pages;
+
+	vm->pte_encode = gen8_ggtt_pte_encode;
+
+	dpt->obj = dpt_obj;
+
+	return &dpt->vm;
+}
+
+void intel_dpt_destroy(struct i915_address_space *vm)
+{
+	struct i915_dpt *dpt = i915_vm_to_dpt(vm);
+
+	i915_vm_close(&dpt->vm);
+}
diff --git a/drivers/gpu/drm/i915/display/intel_dpt.h b/drivers/gpu/drm/i915/display/intel_dpt.h
new file mode 100644
index 000000000000..45142b8f849f
--- /dev/null
+++ b/drivers/gpu/drm/i915/display/intel_dpt.h
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * Copyright © 2021 Intel Corporation
+ */
+
+#ifndef __INTEL_DPT_H__
+#define __INTEL_DPT_H__
+
+struct i915_address_space;
+struct i915_vma;
+struct intel_framebuffer;
+
+void intel_dpt_destroy(struct i915_address_space *vm);
+struct i915_vma *intel_dpt_pin(struct i915_address_space *vm);
+void intel_dpt_unpin(struct i915_address_space *vm);
+struct i915_address_space *
+intel_dpt_create(struct intel_framebuffer *fb);
+
+#endif /* __INTEL_DPT_H__ */
