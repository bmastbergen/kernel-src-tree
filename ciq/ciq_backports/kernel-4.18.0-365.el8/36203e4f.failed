drm/i915/display/adl_p: Implement PSR changes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author José Roberto de Souza <jose.souza@intel.com>
commit 36203e4fb4cb7d65dc471493caf132ebd8d263bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/36203e4f.failed

Implements changes around PSR for alderlake-P:

- EDP_SU_TRACK_ENABLE was removed and bit 30 now has other function
- Some bits of PSR2_MAN_TRK_CTL moved and SF_PARTIAL_FRAME_UPDATE was
  removed setting SU_REGION_START/END_ADDR will do this job
- SU_REGION_START/END_ADDR have now line granularity but will need to
  be aligned with DSC when the PSRS + DSC support lands

BSpec: 50422
BSpec: 50424
	Cc: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
	Cc: Anusha Srivatsa <anusha.srivatsa@intel.com>
	Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
	Signed-off-by: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
	Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210625235600.765677-1-jose.souza@intel.com
(cherry picked from commit 36203e4fb4cb7d65dc471493caf132ebd8d263bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_psr.c
diff --cc drivers/gpu/drm/i915/display/intel_psr.c
index 2c6c4a4f9477,7218a5f6a1b3..000000000000
--- a/drivers/gpu/drm/i915/display/intel_psr.c
+++ b/drivers/gpu/drm/i915/display/intel_psr.c
@@@ -522,18 -534,47 +522,25 @@@ static u32 intel_psr2_get_tp_time(struc
  static void hsw_activate_psr2(struct intel_dp *intel_dp)
  {
  	struct drm_i915_private *dev_priv = dp_to_i915(intel_dp);
- 	u32 val;
+ 	u32 val = EDP_PSR2_ENABLE;
+ 
+ 	val |= psr_compute_idle_frames(intel_dp) << EDP_PSR2_IDLE_FRAME_SHIFT;
  
- 	val = psr_compute_idle_frames(intel_dp) << EDP_PSR2_IDLE_FRAME_SHIFT;
+ 	if (!IS_ALDERLAKE_P(dev_priv))
+ 		val |= EDP_SU_TRACK_ENABLE;
  
++<<<<<<< HEAD
 +	val |= EDP_PSR2_ENABLE | EDP_SU_TRACK_ENABLE;
 +	if (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv))
++=======
+ 	if (DISPLAY_VER(dev_priv) >= 10 && DISPLAY_VER(dev_priv) <= 12)
++>>>>>>> 36203e4fb4cb (drm/i915/display/adl_p: Implement PSR changes)
  		val |= EDP_Y_COORDINATE_ENABLE;
  
 -	val |= EDP_PSR2_FRAME_BEFORE_SU(intel_dp->psr.sink_sync_latency + 1);
 +	val |= EDP_PSR2_FRAME_BEFORE_SU(dev_priv->psr.sink_sync_latency + 1);
  	val |= intel_psr2_get_tp_time(intel_dp);
  
 -	/* Wa_22012278275:adl-p */
 -	if (IS_ADLP_DISPLAY_STEP(dev_priv, STEP_A0, STEP_D1)) {
 -		static const u8 map[] = {
 -			2, /* 5 lines */
 -			1, /* 6 lines */
 -			0, /* 7 lines */
 -			3, /* 8 lines */
 -			6, /* 9 lines */
 -			5, /* 10 lines */
 -			4, /* 11 lines */
 -			7, /* 12 lines */
 -		};
 -		/*
 -		 * Still using the default IO_BUFFER_WAKE and FAST_WAKE, see
 -		 * comments bellow for more information
 -		 */
 -		u32 tmp, lines = 7;
 -
 -		val |= TGL_EDP_PSR2_BLOCK_COUNT_NUM_2;
 -
 -		tmp = map[lines - TGL_EDP_PSR2_IO_BUFFER_WAKE_MIN_LINES];
 -		tmp = tmp << TGL_EDP_PSR2_IO_BUFFER_WAKE_SHIFT;
 -		val |= tmp;
 -
 -		tmp = map[lines - TGL_EDP_PSR2_FAST_WAKE_MIN_LINES];
 -		tmp = tmp << TGL_EDP_PSR2_FAST_WAKE_MIN_SHIFT;
 -		val |= tmp;
 -	} else if (DISPLAY_VER(dev_priv) >= 12) {
 +	if (INTEL_GEN(dev_priv) >= 12) {
  		/*
  		 * TODO: 7 lines of IO_BUFFER_WAKE and FAST_WAKE are default
  		 * values from BSpec. In order to setting an optimal power
@@@ -714,6 -785,74 +721,70 @@@ static bool intel_psr2_sel_fetch_config
  	return crtc_state->enable_psr2_sel_fetch = true;
  }
  
++<<<<<<< HEAD
++=======
+ static bool psr2_granularity_check(struct intel_dp *intel_dp,
+ 				   struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_i915_private *dev_priv = dp_to_i915(intel_dp);
+ 	const int crtc_hdisplay = crtc_state->hw.adjusted_mode.crtc_hdisplay;
+ 	const int crtc_vdisplay = crtc_state->hw.adjusted_mode.crtc_vdisplay;
+ 	u16 y_granularity = 0;
+ 
+ 	/* PSR2 HW only send full lines so we only need to validate the width */
+ 	if (crtc_hdisplay % intel_dp->psr.su_w_granularity)
+ 		return false;
+ 
+ 	if (crtc_vdisplay % intel_dp->psr.su_y_granularity)
+ 		return false;
+ 
+ 	/* HW tracking is only aligned to 4 lines */
+ 	if (!crtc_state->enable_psr2_sel_fetch)
+ 		return intel_dp->psr.su_y_granularity == 4;
+ 
+ 	/*
+ 	 * adl_p has 1 line granularity. For other platforms with SW tracking we
+ 	 * can adjust the y coordinates to match sink requirement if multiple of
+ 	 * 4.
+ 	 */
+ 	if (IS_ALDERLAKE_P(dev_priv))
+ 		y_granularity = intel_dp->psr.su_y_granularity;
+ 	else if (intel_dp->psr.su_y_granularity <= 2)
+ 		y_granularity = 4;
+ 	else if ((intel_dp->psr.su_y_granularity % 4) == 0)
+ 		y_granularity = intel_dp->psr.su_y_granularity;
+ 
+ 	if (y_granularity == 0 || crtc_vdisplay % y_granularity)
+ 		return false;
+ 
+ 	crtc_state->su_y_granularity = y_granularity;
+ 	return true;
+ }
+ 
+ static bool _compute_psr2_sdp_prior_scanline_indication(struct intel_dp *intel_dp,
+ 							struct intel_crtc_state *crtc_state)
+ {
+ 	const struct drm_display_mode *adjusted_mode = &crtc_state->uapi.adjusted_mode;
+ 	struct drm_i915_private *dev_priv = dp_to_i915(intel_dp);
+ 	u32 hblank_total, hblank_ns, req_ns;
+ 
+ 	hblank_total = adjusted_mode->crtc_hblank_end - adjusted_mode->crtc_hblank_start;
+ 	hblank_ns = div_u64(1000000ULL * hblank_total, adjusted_mode->crtc_clock);
+ 
+ 	/* From spec: (72 / number of lanes) * 1000 / symbol clock frequency MHz */
+ 	req_ns = (72 / crtc_state->lane_count) * 1000 / (crtc_state->port_clock / 1000);
+ 
+ 	if ((hblank_ns - req_ns) > 100)
+ 		return true;
+ 
+ 	if (DISPLAY_VER(dev_priv) < 13 || intel_dp->edp_dpcd[0] < DP_EDP_14b)
+ 		return false;
+ 
+ 	crtc_state->req_psr2_sdp_prior_scanline = true;
+ 	return true;
+ }
+ 
++>>>>>>> 36203e4fb4cb (drm/i915/display/adl_p: Implement PSR changes)
  static bool intel_psr2_config_valid(struct intel_dp *intel_dp,
  				    struct intel_crtc_state *crtc_state)
  {
@@@ -1309,6 -1577,20 +1391,23 @@@ static void clip_area_update(struct drm
  		overlap_damage_area->y2 = damage_area->y2;
  }
  
++<<<<<<< HEAD
++=======
+ static void intel_psr2_sel_fetch_pipe_alignment(const struct intel_crtc_state *crtc_state,
+ 						struct drm_rect *pipe_clip)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);
+ 	const u16 y_alignment = crtc_state->su_y_granularity;
+ 
+ 	pipe_clip->y1 -= pipe_clip->y1 % y_alignment;
+ 	if (pipe_clip->y2 % y_alignment)
+ 		pipe_clip->y2 = ((pipe_clip->y2 / y_alignment) + 1) * y_alignment;
+ 
+ 	if (IS_ALDERLAKE_P(dev_priv) && crtc_state->dsc.compression_enable)
+ 		drm_warn(&dev_priv->drm, "Missing PSR2 sel fetch alignment with DSC\n");
+ }
+ 
++>>>>>>> 36203e4fb4cb (drm/i915/display/adl_p: Implement PSR changes)
  int intel_psr2_sel_fetch_update(struct intel_atomic_state *state,
  				struct intel_crtc *crtc)
  {
* Unmerged path drivers/gpu/drm/i915/display/intel_psr.c
diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h
index f515475c1335..68ba5aeb998b 100644
--- a/drivers/gpu/drm/i915/i915_reg.h
+++ b/drivers/gpu/drm/i915/i915_reg.h
@@ -4563,7 +4563,7 @@ enum {
 #define _PSR2_CTL_EDP				0x6f900
 #define EDP_PSR2_CTL(tran)			_MMIO_TRANS2(tran, _PSR2_CTL_A)
 #define   EDP_PSR2_ENABLE			(1 << 31)
-#define   EDP_SU_TRACK_ENABLE			(1 << 30)
+#define   EDP_SU_TRACK_ENABLE			(1 << 30) /* up to adl-p */
 #define   TGL_EDP_PSR2_BLOCK_COUNT_NUM_2	(0 << 28)
 #define   TGL_EDP_PSR2_BLOCK_COUNT_NUM_3	(1 << 28)
 #define   EDP_Y_COORDINATE_VALID		(1 << 26) /* GLK and CNL+ */
@@ -4630,17 +4630,23 @@ enum {
 #define PSR2_SU_STATUS_MASK(frame)	(0x3ff << PSR2_SU_STATUS_SHIFT(frame))
 #define PSR2_SU_STATUS_FRAMES		8
 
-#define _PSR2_MAN_TRK_CTL_A				0x60910
-#define _PSR2_MAN_TRK_CTL_EDP				0x6f910
-#define PSR2_MAN_TRK_CTL(tran)				_MMIO_TRANS2(tran, _PSR2_MAN_TRK_CTL_A)
-#define  PSR2_MAN_TRK_CTL_ENABLE			REG_BIT(31)
-#define  PSR2_MAN_TRK_CTL_SU_REGION_START_ADDR_MASK	REG_GENMASK(30, 21)
-#define  PSR2_MAN_TRK_CTL_SU_REGION_START_ADDR(val)	REG_FIELD_PREP(PSR2_MAN_TRK_CTL_SU_REGION_START_ADDR_MASK, val)
+#define _PSR2_MAN_TRK_CTL_A					0x60910
+#define _PSR2_MAN_TRK_CTL_EDP					0x6f910
+#define PSR2_MAN_TRK_CTL(tran)					_MMIO_TRANS2(tran, _PSR2_MAN_TRK_CTL_A)
+#define  PSR2_MAN_TRK_CTL_ENABLE				REG_BIT(31)
+#define  PSR2_MAN_TRK_CTL_SU_REGION_START_ADDR_MASK		REG_GENMASK(30, 21)
+#define  PSR2_MAN_TRK_CTL_SU_REGION_START_ADDR(val)		REG_FIELD_PREP(PSR2_MAN_TRK_CTL_SU_REGION_START_ADDR_MASK, val)
 #define  PSR2_MAN_TRK_CTL_SU_REGION_END_ADDR_MASK		REG_GENMASK(20, 11)
 #define  PSR2_MAN_TRK_CTL_SU_REGION_END_ADDR(val)		REG_FIELD_PREP(PSR2_MAN_TRK_CTL_SU_REGION_END_ADDR_MASK, val)
-#define  PSR2_MAN_TRK_CTL_SF_SINGLE_FULL_FRAME		REG_BIT(3)
-#define  PSR2_MAN_TRK_CTL_SF_CONTINUOS_FULL_FRAME	REG_BIT(2)
-#define  PSR2_MAN_TRK_CTL_SF_PARTIAL_FRAME_UPDATE	REG_BIT(1)
+#define  PSR2_MAN_TRK_CTL_SF_SINGLE_FULL_FRAME			REG_BIT(3)
+#define  PSR2_MAN_TRK_CTL_SF_CONTINUOS_FULL_FRAME		REG_BIT(2)
+#define  PSR2_MAN_TRK_CTL_SF_PARTIAL_FRAME_UPDATE		REG_BIT(1)
+#define  ADLP_PSR2_MAN_TRK_CTL_SU_REGION_START_ADDR_MASK	REG_GENMASK(28, 16)
+#define  ADLP_PSR2_MAN_TRK_CTL_SU_REGION_START_ADDR(val)	REG_FIELD_PREP(ADLP_PSR2_MAN_TRK_CTL_SU_REGION_START_ADDR_MASK, val)
+#define  ADLP_PSR2_MAN_TRK_CTL_SU_REGION_END_ADDR_MASK		REG_GENMASK(12, 0)
+#define  ADLP_PSR2_MAN_TRK_CTL_SU_REGION_END_ADDR(val)		REG_FIELD_PREP(ADLP_PSR2_MAN_TRK_CTL_SU_REGION_END_ADDR_MASK, val)
+#define  ADLP_PSR2_MAN_TRK_CTL_SF_SINGLE_FULL_FRAME		REG_BIT(14)
+#define  ADLP_PSR2_MAN_TRK_CTL_SF_CONTINUOS_FULL_FRAME		REG_BIT(13)
 
 /* Icelake DSC Rate Control Range Parameter Registers */
 #define DSCA_RC_RANGE_PARAMETERS_0		_MMIO(0x6B240)
