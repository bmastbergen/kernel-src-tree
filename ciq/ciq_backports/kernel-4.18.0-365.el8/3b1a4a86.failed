kasan: group vmalloc code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Andrey Konovalov <andreyknvl@google.com>
commit 3b1a4a8640876a966ab68ab4f561642e19674671
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/3b1a4a86.failed

This is a preparatory commit for the upcoming addition of a new hardware
tag-based (MTE-based) KASAN mode.

Group all vmalloc-related function declarations in include/linux/kasan.h,
and their implementations in mm/kasan/common.c.

No functional changes.

Link: https://lkml.kernel.org/r/80a6fdd29b039962843bd6cf22ce2643a7c8904e.1606161801.git.andreyknvl@google.com
	Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
	Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Reviewed-by: Marco Elver <elver@google.com>
	Reviewed-by: Alexander Potapenko <glider@google.com>
	Tested-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Branislav Rankov <Branislav.Rankov@arm.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Evgenii Stepanov <eugenis@google.com>
	Cc: Kevin Brodsky <kevin.brodsky@arm.com>
	Cc: Vasily Gorbik <gor@linux.ibm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 3b1a4a8640876a966ab68ab4f561642e19674671)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/kasan/common.c
diff --cc mm/kasan/common.c
index 5c1cf01c4cee,89e5ef9417a7..000000000000
--- a/mm/kasan/common.c
+++ b/mm/kasan/common.c
@@@ -560,62 -536,6 +560,65 @@@ void kasan_kfree_large(void *ptr, unsig
  	/* The object will be poisoned by page_alloc. */
  }
  
++<<<<<<< HEAD
 +#ifndef CONFIG_KASAN_VMALLOC
 +int kasan_module_alloc(void *addr, size_t size)
 +{
 +	void *ret;
 +	size_t scaled_size;
 +	size_t shadow_size;
 +	unsigned long shadow_start;
 +
 +	shadow_start = (unsigned long)kasan_mem_to_shadow(addr);
 +	scaled_size = (size + KASAN_SHADOW_MASK) >> KASAN_SHADOW_SCALE_SHIFT;
 +	shadow_size = round_up(scaled_size, PAGE_SIZE);
 +
 +	if (WARN_ON(!PAGE_ALIGNED(shadow_start)))
 +		return -EINVAL;
 +
 +	ret = __vmalloc_node_range(shadow_size, 1, shadow_start,
 +			shadow_start + shadow_size,
 +			GFP_KERNEL,
 +			PAGE_KERNEL, VM_NO_GUARD, NUMA_NO_NODE,
 +			__builtin_return_address(0));
 +
 +	if (ret) {
 +		__memset(ret, KASAN_SHADOW_INIT, shadow_size);
 +		find_vm_area(addr)->flags |= VM_KASAN;
 +		kmemleak_ignore(ret);
 +		return 0;
 +	}
 +
 +	return -ENOMEM;
 +}
 +
 +void kasan_free_shadow(const struct vm_struct *vm)
 +{
 +	if (vm->flags & VM_KASAN)
 +		vfree(kasan_mem_to_shadow(vm->addr));
 +}
 +#endif
 +
 +extern void __kasan_report(unsigned long addr, size_t size, bool is_write, unsigned long ip);
 +extern bool report_enabled(void);
 +
 +bool kasan_report(unsigned long addr, size_t size, bool is_write, unsigned long ip)
 +{
 +	unsigned long flags = user_access_save();
 +	bool ret = false;
 +
 +	if (likely(report_enabled())) {
 +		__kasan_report(addr, size, is_write, ip);
 +		ret = true;
 +	}
 +
 +	user_access_restore(flags);
 +
 +	return ret;
 +}
 +
++=======
++>>>>>>> 3b1a4a864087 (kasan: group vmalloc code)
  #ifdef CONFIG_MEMORY_HOTPLUG
  static bool shadow_mapped(unsigned long addr)
  {
diff --git a/include/linux/kasan.h b/include/linux/kasan.h
index f00d17cf6822..029b88c98088 100644
--- a/include/linux/kasan.h
+++ b/include/linux/kasan.h
@@ -69,19 +69,6 @@ struct kasan_cache {
 	int free_meta_offset;
 };
 
-/*
- * These functions provide a special case to support backing module
- * allocations with real shadow memory. With KASAN vmalloc, the special
- * case is unnecessary, as the work is handled in the generic case.
- */
-#ifndef CONFIG_KASAN_VMALLOC
-int kasan_module_alloc(void *addr, size_t size);
-void kasan_free_shadow(const struct vm_struct *vm);
-#else
-static inline int kasan_module_alloc(void *addr, size_t size) { return 0; }
-static inline void kasan_free_shadow(const struct vm_struct *vm) {}
-#endif
-
 int kasan_add_zero_shadow(void *start, unsigned long size);
 void kasan_remove_zero_shadow(void *start, unsigned long size);
 
@@ -150,9 +137,6 @@ static inline bool kasan_slab_free(struct kmem_cache *s, void *object,
 	return false;
 }
 
-static inline int kasan_module_alloc(void *addr, size_t size) { return 0; }
-static inline void kasan_free_shadow(const struct vm_struct *vm) {}
-
 static inline int kasan_add_zero_shadow(void *start, unsigned long size)
 {
 	return 0;
@@ -205,13 +189,16 @@ static inline void *kasan_reset_tag(const void *addr)
 #endif /* CONFIG_KASAN_SW_TAGS */
 
 #ifdef CONFIG_KASAN_VMALLOC
+
 int kasan_populate_vmalloc(unsigned long addr, unsigned long size);
 void kasan_poison_vmalloc(const void *start, unsigned long size);
 void kasan_unpoison_vmalloc(const void *start, unsigned long size);
 void kasan_release_vmalloc(unsigned long start, unsigned long end,
 			   unsigned long free_region_start,
 			   unsigned long free_region_end);
-#else
+
+#else /* CONFIG_KASAN_VMALLOC */
+
 static inline int kasan_populate_vmalloc(unsigned long start,
 					unsigned long size)
 {
@@ -226,6 +213,24 @@ static inline void kasan_release_vmalloc(unsigned long start,
 					 unsigned long end,
 					 unsigned long free_region_start,
 					 unsigned long free_region_end) {}
-#endif
+
+#endif /* CONFIG_KASAN_VMALLOC */
+
+#if defined(CONFIG_KASAN) && !defined(CONFIG_KASAN_VMALLOC)
+
+/*
+ * These functions provide a special case to support backing module
+ * allocations with real shadow memory. With KASAN vmalloc, the special
+ * case is unnecessary, as the work is handled in the generic case.
+ */
+int kasan_module_alloc(void *addr, size_t size);
+void kasan_free_shadow(const struct vm_struct *vm);
+
+#else /* CONFIG_KASAN && !CONFIG_KASAN_VMALLOC */
+
+static inline int kasan_module_alloc(void *addr, size_t size) { return 0; }
+static inline void kasan_free_shadow(const struct vm_struct *vm) {}
+
+#endif /* CONFIG_KASAN && !CONFIG_KASAN_VMALLOC */
 
 #endif /* LINUX_KASAN_H */
* Unmerged path mm/kasan/common.c
