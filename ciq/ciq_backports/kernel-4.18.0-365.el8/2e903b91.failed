kasan, arm64: implement HW_TAGS runtime

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Andrey Konovalov <andreyknvl@google.com>
commit 2e903b91479782b7dedd869603423d77e079d3de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/2e903b91.failed

Provide implementation of KASAN functions required for the hardware
tag-based mode.  Those include core functions for memory and pointer
tagging (tags_hw.c) and bug reporting (report_tags_hw.c).  Also adapt
common KASAN code to support the new mode.

Link: https://lkml.kernel.org/r/cfd0fbede579a6b66755c98c88c108e54f9c56bf.1606161801.git.andreyknvl@google.com
	Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
	Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Acked-by: Catalin Marinas <catalin.marinas@arm.com>
	Reviewed-by: Alexander Potapenko <glider@google.com>
	Tested-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Branislav Rankov <Branislav.Rankov@arm.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Evgenii Stepanov <eugenis@google.com>
	Cc: Kevin Brodsky <kevin.brodsky@arm.com>
	Cc: Marco Elver <elver@google.com>
	Cc: Vasily Gorbik <gor@linux.ibm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 2e903b91479782b7dedd869603423d77e079d3de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/memory.h
#	arch/arm64/kernel/cpufeature.c
#	include/linux/kasan.h
#	mm/kasan/Makefile
#	mm/kasan/common.c
#	mm/kasan/kasan.h
#	mm/kasan/shadow.c
diff --cc arch/arm64/include/asm/memory.h
index f6715969d223,18fce223b67b..000000000000
--- a/arch/arm64/include/asm/memory.h
+++ b/arch/arm64/include/asm/memory.h
@@@ -252,7 -222,7 +252,11 @@@ extern u64			vabits_user
  #define __tag_shifted(tag)	0UL
  #define __tag_reset(addr)	(addr)
  #define __tag_get(addr)		0
++<<<<<<< HEAD
 +#endif
++=======
+ #endif /* CONFIG_KASAN_SW_TAGS || CONFIG_KASAN_HW_TAGS */
++>>>>>>> 2e903b914797 (kasan, arm64: implement HW_TAGS runtime)
  
  static inline const void *__tag_set(const void *addr, u8 tag)
  {
diff --cc arch/arm64/kernel/cpufeature.c
index 0dc0728a1688,7ffb5f1d8b68..000000000000
--- a/arch/arm64/kernel/cpufeature.c
+++ b/arch/arm64/kernel/cpufeature.c
@@@ -1382,6 -1683,73 +1383,76 @@@ static bool can_use_gic_priorities(cons
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARM64_BTI
+ static void bti_enable(const struct arm64_cpu_capabilities *__unused)
+ {
+ 	/*
+ 	 * Use of X16/X17 for tail-calls and trampolines that jump to
+ 	 * function entry points using BR is a requirement for
+ 	 * marking binaries with GNU_PROPERTY_AARCH64_FEATURE_1_BTI.
+ 	 * So, be strict and forbid other BRs using other registers to
+ 	 * jump onto a PACIxSP instruction:
+ 	 */
+ 	sysreg_clear_set(sctlr_el1, 0, SCTLR_EL1_BT0 | SCTLR_EL1_BT1);
+ 	isb();
+ }
+ #endif /* CONFIG_ARM64_BTI */
+ 
+ #ifdef CONFIG_ARM64_MTE
+ static void cpu_enable_mte(struct arm64_cpu_capabilities const *cap)
+ {
+ 	static bool cleared_zero_page = false;
+ 
+ 	/*
+ 	 * Clear the tags in the zero page. This needs to be done via the
+ 	 * linear map which has the Tagged attribute.
+ 	 */
+ 	if (!cleared_zero_page) {
+ 		cleared_zero_page = true;
+ 		mte_clear_page_tags(lm_alias(empty_zero_page));
+ 	}
+ 
+ 	kasan_init_hw_tags_cpu();
+ }
+ #endif /* CONFIG_ARM64_MTE */
+ 
+ #ifdef CONFIG_KVM
+ static bool is_kvm_protected_mode(const struct arm64_cpu_capabilities *entry, int __unused)
+ {
+ 	if (kvm_get_mode() != KVM_MODE_PROTECTED)
+ 		return false;
+ 
+ 	if (is_kernel_in_hyp_mode()) {
+ 		pr_warn("Protected KVM not available with VHE\n");
+ 		return false;
+ 	}
+ 
+ 	return true;
+ }
+ #endif /* CONFIG_KVM */
+ 
+ /* Internal helper functions to match cpu capability type */
+ static bool
+ cpucap_late_cpu_optional(const struct arm64_cpu_capabilities *cap)
+ {
+ 	return !!(cap->type & ARM64_CPUCAP_OPTIONAL_FOR_LATE_CPU);
+ }
+ 
+ static bool
+ cpucap_late_cpu_permitted(const struct arm64_cpu_capabilities *cap)
+ {
+ 	return !!(cap->type & ARM64_CPUCAP_PERMITTED_FOR_LATE_CPU);
+ }
+ 
+ static bool
+ cpucap_panic_on_conflict(const struct arm64_cpu_capabilities *cap)
+ {
+ 	return !!(cap->type & ARM64_CPUCAP_PANIC_ON_CONFLICT);
+ }
+ 
++>>>>>>> 2e903b914797 (kasan, arm64: implement HW_TAGS runtime)
  static const struct arm64_cpu_capabilities arm64_features[] = {
  	{
  		.desc = "GIC system register CPU interface",
diff --cc include/linux/kasan.h
index f00d17cf6822,d22ec4c9c1bd..000000000000
--- a/include/linux/kasan.h
+++ b/include/linux/kasan.h
@@@ -182,29 -190,38 +182,51 @@@ static inline void kasan_record_aux_sta
  
  #endif /* CONFIG_KASAN_GENERIC */
  
++<<<<<<< HEAD
 +#ifdef CONFIG_KASAN_SW_TAGS
 +
 +#define KASAN_SHADOW_INIT 0xFF
 +
 +void kasan_init_tags(void);
++=======
+ #if defined(CONFIG_KASAN_SW_TAGS) || defined(CONFIG_KASAN_HW_TAGS)
++>>>>>>> 2e903b914797 (kasan, arm64: implement HW_TAGS runtime)
  
  void *kasan_reset_tag(const void *addr);
  
  bool kasan_report(unsigned long addr, size_t size,
  		bool is_write, unsigned long ip);
  
++<<<<<<< HEAD
 +#else /* CONFIG_KASAN_SW_TAGS */
 +
 +static inline void kasan_init_tags(void) { }
++=======
+ #else /* CONFIG_KASAN_SW_TAGS || CONFIG_KASAN_HW_TAGS */
++>>>>>>> 2e903b914797 (kasan, arm64: implement HW_TAGS runtime)
  
  static inline void *kasan_reset_tag(const void *addr)
  {
  	return (void *)addr;
  }
  
- #endif /* CONFIG_KASAN_SW_TAGS */
+ #endif /* CONFIG_KASAN_SW_TAGS || CONFIG_KASAN_HW_TAGS*/
+ 
+ #ifdef CONFIG_KASAN_SW_TAGS
+ void __init kasan_init_sw_tags(void);
+ #else
+ static inline void kasan_init_sw_tags(void) { }
+ #endif
+ 
+ #ifdef CONFIG_KASAN_HW_TAGS
+ void kasan_init_hw_tags_cpu(void);
+ void __init kasan_init_hw_tags(void);
+ #else
+ static inline void kasan_init_hw_tags_cpu(void) { }
+ static inline void kasan_init_hw_tags(void) { }
+ #endif
  
  #ifdef CONFIG_KASAN_VMALLOC
 -
  int kasan_populate_vmalloc(unsigned long addr, unsigned long size);
  void kasan_poison_vmalloc(const void *start, unsigned long size);
  void kasan_unpoison_vmalloc(const void *start, unsigned long size);
diff --cc mm/kasan/Makefile
index b5517de7fc87,9fe39a66388a..000000000000
--- a/mm/kasan/Makefile
+++ b/mm/kasan/Makefile
@@@ -10,8 -9,12 +10,17 @@@ CFLAGS_REMOVE_generic_report.o = $(CC_F
  CFLAGS_REMOVE_init.o = $(CC_FLAGS_FTRACE)
  CFLAGS_REMOVE_quarantine.o = $(CC_FLAGS_FTRACE)
  CFLAGS_REMOVE_report.o = $(CC_FLAGS_FTRACE)
++<<<<<<< HEAD
 +CFLAGS_REMOVE_tags.o = $(CC_FLAGS_FTRACE)
 +CFLAGS_REMOVE_tags_report.o = $(CC_FLAGS_FTRACE)
++=======
+ CFLAGS_REMOVE_report_generic.o = $(CC_FLAGS_FTRACE)
+ CFLAGS_REMOVE_report_hw_tags.o = $(CC_FLAGS_FTRACE)
+ CFLAGS_REMOVE_report_sw_tags.o = $(CC_FLAGS_FTRACE)
+ CFLAGS_REMOVE_shadow.o = $(CC_FLAGS_FTRACE)
+ CFLAGS_REMOVE_hw_tags.o = $(CC_FLAGS_FTRACE)
+ CFLAGS_REMOVE_sw_tags.o = $(CC_FLAGS_FTRACE)
++>>>>>>> 2e903b914797 (kasan, arm64: implement HW_TAGS runtime)
  
  # Function splitter causes unnecessary splits in __asan_load1/__asan_store1
  # see: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63533
@@@ -26,9 -28,14 +35,23 @@@ CFLAGS_generic_report.o := $(CC_FLAGS_K
  CFLAGS_init.o := $(CC_FLAGS_KASAN_RUNTIME)
  CFLAGS_quarantine.o := $(CC_FLAGS_KASAN_RUNTIME)
  CFLAGS_report.o := $(CC_FLAGS_KASAN_RUNTIME)
++<<<<<<< HEAD
 +CFLAGS_tags.o := $(CC_FLAGS_KASAN_RUNTIME)
 +CFLAGS_tags_report.o := $(CC_FLAGS_KASAN_RUNTIME)
 +
 +obj-$(CONFIG_KASAN) := common.o report.o
 +obj-$(CONFIG_KASAN_GENERIC) += init.o generic.o generic_report.o quarantine.o
 +obj-$(CONFIG_KASAN_SW_TAGS) += init.o tags.o tags_report.o
++=======
+ CFLAGS_report_generic.o := $(CC_FLAGS_KASAN_RUNTIME)
+ CFLAGS_report_hw_tags.o := $(CC_FLAGS_KASAN_RUNTIME)
+ CFLAGS_report_sw_tags.o := $(CC_FLAGS_KASAN_RUNTIME)
+ CFLAGS_shadow.o := $(CC_FLAGS_KASAN_RUNTIME)
+ CFLAGS_hw_tags.o := $(CC_FLAGS_KASAN_RUNTIME)
+ CFLAGS_sw_tags.o := $(CC_FLAGS_KASAN_RUNTIME)
+ 
+ obj-$(CONFIG_KASAN) := common.o report.o
+ obj-$(CONFIG_KASAN_GENERIC) += init.o generic.o report_generic.o shadow.o quarantine.o
+ obj-$(CONFIG_KASAN_HW_TAGS) += hw_tags.o report_hw_tags.o
+ obj-$(CONFIG_KASAN_SW_TAGS) += init.o report_sw_tags.o shadow.o sw_tags.o
++>>>>>>> 2e903b914797 (kasan, arm64: implement HW_TAGS runtime)
diff --cc mm/kasan/common.c
index 5c1cf01c4cee,02613883846e..000000000000
--- a/mm/kasan/common.c
+++ b/mm/kasan/common.c
@@@ -464,17 -337,17 +463,24 @@@ static void *__kasan_kmalloc(struct kme
  		return NULL;
  
  	redzone_start = round_up((unsigned long)(object + size),
 -				KASAN_GRANULE_SIZE);
 +				KASAN_SHADOW_SCALE_SIZE);
  	redzone_end = round_up((unsigned long)object + cache->object_size,
 -				KASAN_GRANULE_SIZE);
 +				KASAN_SHADOW_SCALE_SIZE);
  
- 	if (IS_ENABLED(CONFIG_KASAN_SW_TAGS))
+ 	if (IS_ENABLED(CONFIG_KASAN_SW_TAGS) || IS_ENABLED(CONFIG_KASAN_HW_TAGS))
  		tag = assign_tag(cache, object, false, keep_tag);
  
++<<<<<<< HEAD
 +	/* Tag is ignored in set_tag without CONFIG_KASAN_SW_TAGS */
 +	kasan_unpoison_shadow(set_tag(object, tag), size);
 +	kasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,
 +		KASAN_KMALLOC_REDZONE);
++=======
+ 	/* Tag is ignored in set_tag without CONFIG_KASAN_SW/HW_TAGS */
+ 	unpoison_range(set_tag(object, tag), size);
+ 	poison_range((void *)redzone_start, redzone_end - redzone_start,
+ 		     KASAN_KMALLOC_REDZONE);
++>>>>>>> 2e903b914797 (kasan, arm64: implement HW_TAGS runtime)
  
  	if (cache->flags & SLAB_KASAN)
  		kasan_set_track(&get_alloc_info(cache, object)->alloc_track, flags);
diff --cc mm/kasan/kasan.h
index ff4e9ead48d8,64560cc71191..000000000000
--- a/mm/kasan/kasan.h
+++ b/mm/kasan/kasan.h
@@@ -150,8 -170,6 +155,11 @@@ static inline bool addr_has_shadow(cons
  	return (addr >= kasan_shadow_to_mem((void *)KASAN_SHADOW_START));
  }
  
++<<<<<<< HEAD
 +void kasan_poison_shadow(const void *address, size_t size, u8 value);
 +
++=======
++>>>>>>> 2e903b914797 (kasan, arm64: implement HW_TAGS runtime)
  /**
   * check_memory_region - Check memory region, and report if invalid access.
   * @addr: the accessed address
@@@ -163,8 -181,26 +171,22 @@@
  bool check_memory_region(unsigned long addr, size_t size, bool write,
  				unsigned long ret_ip);
  
++<<<<<<< HEAD
++=======
+ #else /* CONFIG_KASAN_GENERIC || CONFIG_KASAN_SW_TAGS */
+ 
+ static inline bool addr_has_metadata(const void *addr)
+ {
+ 	return true;
+ }
+ 
+ #endif /* CONFIG_KASAN_GENERIC || CONFIG_KASAN_SW_TAGS */
+ 
+ bool check_invalid_free(void *addr);
+ 
++>>>>>>> 2e903b914797 (kasan, arm64: implement HW_TAGS runtime)
  void *find_first_bad_addr(void *addr, size_t size);
  const char *get_bug_type(struct kasan_access_info *info);
 -void metadata_fetch_row(char *buffer, void *row);
 -
 -#if defined(CONFIG_KASAN_GENERIC) && CONFIG_KASAN_STACK
 -void print_address_stack_frame(const void *addr);
 -#else
 -static inline void print_address_stack_frame(const void *addr) { }
 -#endif
  
  bool kasan_report(unsigned long addr, size_t size,
  		bool is_write, unsigned long ip);
* Unmerged path mm/kasan/shadow.c
* Unmerged path arch/arm64/include/asm/memory.h
* Unmerged path arch/arm64/kernel/cpufeature.c
diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c
index afb082472507..91c686f76072 100644
--- a/arch/arm64/kernel/smp.c
+++ b/arch/arm64/kernel/smp.c
@@ -452,6 +452,8 @@ void __init smp_prepare_boot_cpu(void)
 	/* Conditionally switch to GIC PMR for interrupt masking */
 	if (system_uses_irq_prio_masking())
 		init_gic_priority_masking();
+
+	kasan_init_hw_tags();
 }
 
 static u64 __init of_get_cpu_mpidr(struct device_node *dn)
* Unmerged path include/linux/kasan.h
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 3b01604de2d9..48a6c7a4b7ec 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1375,7 +1375,7 @@ static inline bool cpupid_match_pid(struct task_struct *task, int cpupid)
 }
 #endif /* CONFIG_NUMA_BALANCING */
 
-#ifdef CONFIG_KASAN_SW_TAGS
+#if defined(CONFIG_KASAN_SW_TAGS) || defined(CONFIG_KASAN_HW_TAGS)
 static inline u8 page_kasan_tag(const struct page *page)
 {
 	return (page->flags >> KASAN_TAG_PGSHIFT) & KASAN_TAG_MASK;
diff --git a/include/linux/page-flags-layout.h b/include/linux/page-flags-layout.h
index e200eef6a7fd..7d4ec26d8a3e 100644
--- a/include/linux/page-flags-layout.h
+++ b/include/linux/page-flags-layout.h
@@ -77,7 +77,7 @@
 #define LAST_CPUPID_SHIFT 0
 #endif
 
-#ifdef CONFIG_KASAN_SW_TAGS
+#if defined(CONFIG_KASAN_SW_TAGS) || defined(CONFIG_KASAN_HW_TAGS)
 #define KASAN_TAG_WIDTH 8
 #else
 #define KASAN_TAG_WIDTH 0
* Unmerged path mm/kasan/Makefile
* Unmerged path mm/kasan/common.c
diff --git a/mm/kasan/hw_tags.c b/mm/kasan/hw_tags.c
new file mode 100644
index 000000000000..66419e908e21
--- /dev/null
+++ b/mm/kasan/hw_tags.c
@@ -0,0 +1,80 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * This file contains core hardware tag-based KASAN code.
+ *
+ * Copyright (c) 2020 Google, Inc.
+ * Author: Andrey Konovalov <andreyknvl@google.com>
+ */
+
+#define pr_fmt(fmt) "kasan: " fmt
+
+#include <linux/kasan.h>
+#include <linux/kernel.h>
+#include <linux/memory.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/types.h>
+
+#include "kasan.h"
+
+/* kasan_init_hw_tags_cpu() is called for each CPU. */
+void kasan_init_hw_tags_cpu(void)
+{
+	hw_init_tags(KASAN_TAG_MAX);
+	hw_enable_tagging();
+}
+
+/* kasan_init_hw_tags() is called once on boot CPU. */
+void __init kasan_init_hw_tags(void)
+{
+	pr_info("KernelAddressSanitizer initialized\n");
+}
+
+void *kasan_reset_tag(const void *addr)
+{
+	return reset_tag(addr);
+}
+
+void poison_range(const void *address, size_t size, u8 value)
+{
+	hw_set_mem_tag_range(reset_tag(address),
+			round_up(size, KASAN_GRANULE_SIZE), value);
+}
+
+void unpoison_range(const void *address, size_t size)
+{
+	hw_set_mem_tag_range(reset_tag(address),
+			round_up(size, KASAN_GRANULE_SIZE), get_tag(address));
+}
+
+u8 random_tag(void)
+{
+	return hw_get_random_tag();
+}
+
+bool check_invalid_free(void *addr)
+{
+	u8 ptr_tag = get_tag(addr);
+	u8 mem_tag = hw_get_mem_tag(addr);
+
+	return (mem_tag == KASAN_TAG_INVALID) ||
+		(ptr_tag != KASAN_TAG_KERNEL && ptr_tag != mem_tag);
+}
+
+void kasan_set_free_info(struct kmem_cache *cache,
+				void *object, u8 tag)
+{
+	struct kasan_alloc_meta *alloc_meta;
+
+	alloc_meta = get_alloc_info(cache, object);
+	kasan_set_track(&alloc_meta->free_track[0], GFP_NOWAIT);
+}
+
+struct kasan_track *kasan_get_free_track(struct kmem_cache *cache,
+				void *object, u8 tag)
+{
+	struct kasan_alloc_meta *alloc_meta;
+
+	alloc_meta = get_alloc_info(cache, object);
+	return &alloc_meta->free_track[0];
+}
* Unmerged path mm/kasan/kasan.h
diff --git a/mm/kasan/report_hw_tags.c b/mm/kasan/report_hw_tags.c
new file mode 100644
index 000000000000..da543eb832cd
--- /dev/null
+++ b/mm/kasan/report_hw_tags.c
@@ -0,0 +1,42 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * This file contains hardware tag-based KASAN specific error reporting code.
+ *
+ * Copyright (c) 2020 Google, Inc.
+ * Author: Andrey Konovalov <andreyknvl@google.com>
+ */
+
+#include <linux/kasan.h>
+#include <linux/kernel.h>
+#include <linux/memory.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/types.h>
+
+#include "kasan.h"
+
+const char *get_bug_type(struct kasan_access_info *info)
+{
+	return "invalid-access";
+}
+
+void *find_first_bad_addr(void *addr, size_t size)
+{
+	return reset_tag(addr);
+}
+
+void metadata_fetch_row(char *buffer, void *row)
+{
+	int i;
+
+	for (i = 0; i < META_BYTES_PER_ROW; i++)
+		buffer[i] = hw_get_mem_tag(row + i * KASAN_GRANULE_SIZE);
+}
+
+void print_tags(u8 addr_tag, const void *addr)
+{
+	u8 memory_tag = hw_get_mem_tag((void *)addr);
+
+	pr_err("Pointer tag: [%02x], memory tag: [%02x]\n",
+		addr_tag, memory_tag);
+}
* Unmerged path mm/kasan/shadow.c
diff --git a/mm/kasan/tags.c b/mm/kasan/tags.c
index 5c8b08a25715..393aa7818e95 100644
--- a/mm/kasan/tags.c
+++ b/mm/kasan/tags.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * This file contains core tag-based KASAN code.
+ * This file contains core software tag-based KASAN code.
  *
  * Copyright (c) 2018 Google, Inc.
  * Author: Andrey Konovalov <andreyknvl@google.com>
diff --git a/mm/kasan/tags_report.c b/mm/kasan/tags_report.c
index 5f183501b871..510f4915c683 100644
--- a/mm/kasan/tags_report.c
+++ b/mm/kasan/tags_report.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * This file contains tag-based KASAN specific error reporting code.
+ * This file contains software tag-based KASAN specific error reporting code.
  *
  * Copyright (c) 2014 Samsung Electronics Co., Ltd.
  * Author: Andrey Ryabinin <ryabinin.a.a@gmail.com>
