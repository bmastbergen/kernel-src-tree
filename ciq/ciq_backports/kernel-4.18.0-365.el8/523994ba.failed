net: intel: igc_ptp: fix build for UML

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Randy Dunlap <rdunlap@infradead.org>
commit 523994ba3ad1b7b55abe4a72e156897b5e2db825
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/523994ba.failed

On a UML build, the igc_ptp driver uses CONFIG_X86_TSC for timestamp
conversion. The function that is used is not available on UML builds,
so have the function use the default system_counterval_t timestamp
instead for UML builds.

Prevents this build error on UML:

../drivers/net/ethernet/intel/igc/igc_ptp.c: In function ‘igc_device_tstamp_to_system’:
../drivers/net/ethernet/intel/igc/igc_ptp.c:777:9: error: implicit declaration of function ‘convert_art_ns_to_tsc’ [-Werror=implicit-function-declaration]
  return convert_art_ns_to_tsc(tstamp);
../drivers/net/ethernet/intel/igc/igc_ptp.c:777:9: error: incompatible types when returning type ‘int’ but ‘struct system_counterval_t’ was expected
  return convert_art_ns_to_tsc(tstamp);

Fixes: 68f5d3f3b654 ("um: add PCI over virtio emulation driver")
	Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
	Cc: linux-um@lists.infradead.org
	Cc: Jeff Dike <jdike@addtoit.com>
	Cc: Richard Weinberger <richard@nod.at>
	Cc: Anton Ivanov <anton.ivanov@cambridgegreys.com>
	Cc: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Cc: Tony Nguyen <anthony.l.nguyen@intel.com>
	Cc: intel-wired-lan@lists.osuosl.org
Link: https://lore.kernel.org/r/20211014050516.6846-1-rdunlap@infradead.org
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 523994ba3ad1b7b55abe4a72e156897b5e2db825)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/igc/igc_ptp.c
diff --cc drivers/net/ethernet/intel/igc/igc_ptp.c
index eedbed81ccda,30568e3544cd..000000000000
--- a/drivers/net/ethernet/intel/igc/igc_ptp.c
+++ b/drivers/net/ethernet/intel/igc/igc_ptp.c
@@@ -475,6 -757,147 +475,150 @@@ int igc_ptp_get_ts_config(struct net_de
  		-EFAULT : 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* The two conditions below must be met for cross timestamping via
+  * PCIe PTM:
+  *
+  * 1. We have an way to convert the timestamps in the PTM messages
+  *    to something related to the system clocks (right now, only
+  *    X86 systems with support for the Always Running Timer allow that);
+  *
+  * 2. We have PTM enabled in the path from the device to the PCIe root port.
+  */
+ static bool igc_is_crosststamp_supported(struct igc_adapter *adapter)
+ {
+ 	return IS_ENABLED(CONFIG_X86_TSC) ? pcie_ptm_enabled(adapter->pdev) : false;
+ }
+ 
+ static struct system_counterval_t igc_device_tstamp_to_system(u64 tstamp)
+ {
+ #if IS_ENABLED(CONFIG_X86_TSC) && !defined(CONFIG_UML)
+ 	return convert_art_ns_to_tsc(tstamp);
+ #else
+ 	return (struct system_counterval_t) { };
+ #endif
+ }
+ 
+ static void igc_ptm_log_error(struct igc_adapter *adapter, u32 ptm_stat)
+ {
+ 	struct net_device *netdev = adapter->netdev;
+ 
+ 	switch (ptm_stat) {
+ 	case IGC_PTM_STAT_RET_ERR:
+ 		netdev_err(netdev, "PTM Error: Root port timeout\n");
+ 		break;
+ 	case IGC_PTM_STAT_BAD_PTM_RES:
+ 		netdev_err(netdev, "PTM Error: Bad response, PTM Response Data expected\n");
+ 		break;
+ 	case IGC_PTM_STAT_T4M1_OVFL:
+ 		netdev_err(netdev, "PTM Error: T4 minus T1 overflow\n");
+ 		break;
+ 	case IGC_PTM_STAT_ADJUST_1ST:
+ 		netdev_err(netdev, "PTM Error: 1588 timer adjusted during first PTM cycle\n");
+ 		break;
+ 	case IGC_PTM_STAT_ADJUST_CYC:
+ 		netdev_err(netdev, "PTM Error: 1588 timer adjusted during non-first PTM cycle\n");
+ 		break;
+ 	default:
+ 		netdev_err(netdev, "PTM Error: Unknown error (%#x)\n", ptm_stat);
+ 		break;
+ 	}
+ }
+ 
+ static int igc_phc_get_syncdevicetime(ktime_t *device,
+ 				      struct system_counterval_t *system,
+ 				      void *ctx)
+ {
+ 	u32 stat, t2_curr_h, t2_curr_l, ctrl;
+ 	struct igc_adapter *adapter = ctx;
+ 	struct igc_hw *hw = &adapter->hw;
+ 	int err, count = 100;
+ 	ktime_t t1, t2_curr;
+ 
+ 	/* Get a snapshot of system clocks to use as historic value. */
+ 	ktime_get_snapshot(&adapter->snapshot);
+ 
+ 	do {
+ 		/* Doing this in a loop because in the event of a
+ 		 * badly timed (ha!) system clock adjustment, we may
+ 		 * get PTM errors from the PCI root, but these errors
+ 		 * are transitory. Repeating the process returns valid
+ 		 * data eventually.
+ 		 */
+ 
+ 		/* To "manually" start the PTM cycle we need to clear and
+ 		 * then set again the TRIG bit.
+ 		 */
+ 		ctrl = rd32(IGC_PTM_CTRL);
+ 		ctrl &= ~IGC_PTM_CTRL_TRIG;
+ 		wr32(IGC_PTM_CTRL, ctrl);
+ 		ctrl |= IGC_PTM_CTRL_TRIG;
+ 		wr32(IGC_PTM_CTRL, ctrl);
+ 
+ 		/* The cycle only starts "for real" when software notifies
+ 		 * that it has read the registers, this is done by setting
+ 		 * VALID bit.
+ 		 */
+ 		wr32(IGC_PTM_STAT, IGC_PTM_STAT_VALID);
+ 
+ 		err = readx_poll_timeout(rd32, IGC_PTM_STAT, stat,
+ 					 stat, IGC_PTM_STAT_SLEEP,
+ 					 IGC_PTM_STAT_TIMEOUT);
+ 		if (err < 0) {
+ 			netdev_err(adapter->netdev, "Timeout reading IGC_PTM_STAT register\n");
+ 			return err;
+ 		}
+ 
+ 		if ((stat & IGC_PTM_STAT_VALID) == IGC_PTM_STAT_VALID)
+ 			break;
+ 
+ 		if (stat & ~IGC_PTM_STAT_VALID) {
+ 			/* An error occurred, log it. */
+ 			igc_ptm_log_error(adapter, stat);
+ 			/* The STAT register is write-1-to-clear (W1C),
+ 			 * so write the previous error status to clear it.
+ 			 */
+ 			wr32(IGC_PTM_STAT, stat);
+ 			continue;
+ 		}
+ 	} while (--count);
+ 
+ 	if (!count) {
+ 		netdev_err(adapter->netdev, "Exceeded number of tries for PTM cycle\n");
+ 		return -ETIMEDOUT;
+ 	}
+ 
+ 	t1 = ktime_set(rd32(IGC_PTM_T1_TIM0_H), rd32(IGC_PTM_T1_TIM0_L));
+ 
+ 	t2_curr_l = rd32(IGC_PTM_CURR_T2_L);
+ 	t2_curr_h = rd32(IGC_PTM_CURR_T2_H);
+ 
+ 	/* FIXME: When the register that tells the endianness of the
+ 	 * PTM registers are implemented, check them here and add the
+ 	 * appropriate conversion.
+ 	 */
+ 	t2_curr_h = swab32(t2_curr_h);
+ 
+ 	t2_curr = ((s64)t2_curr_h << 32 | t2_curr_l);
+ 
+ 	*device = t1;
+ 	*system = igc_device_tstamp_to_system(t2_curr);
+ 
+ 	return 0;
+ }
+ 
+ static int igc_ptp_getcrosststamp(struct ptp_clock_info *ptp,
+ 				  struct system_device_crosststamp *cts)
+ {
+ 	struct igc_adapter *adapter = container_of(ptp, struct igc_adapter,
+ 						   ptp_caps);
+ 
+ 	return get_device_system_crosststamp(igc_phc_get_syncdevicetime,
+ 					     adapter, &adapter->snapshot, cts);
+ }
+ 
++>>>>>>> 523994ba3ad1 (net: intel: igc_ptp: fix build for UML)
  /**
   * igc_ptp_init - Initialize PTP functionality
   * @adapter: Board private structure
* Unmerged path drivers/net/ethernet/intel/igc/igc_ptp.c
