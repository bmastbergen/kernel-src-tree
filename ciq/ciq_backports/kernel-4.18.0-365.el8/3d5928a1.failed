drm/i915/xelpd: Pipe A DMC plugging

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Anusha Srivatsa <anusha.srivatsa@intel.com>
commit 3d5928a168a9546b23c6b3439c6158d7a028326c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/3d5928a1.failed

This patch adds Pipe A plumbing to the already
existing parsing and loading functions which is
taken care of in the prep patches. Adding MAX_DMC_FW
to keep track for both Main and Pipe A DMC while loading
the respective blobs.

Also adding present field in dmc_info.
s/find_dmc_fw_offset/csr_set_dmc_fw_offset. While at it add
fw_info_matches_stepping() helper. CSR_PROGRAM() should now
take the starting address of the particular blob (Main or Pipe)
and not hardcode it.

v2: Add dmc_offset and start_mmioaddr fields for dmc_info struct.

v3: Add a missing corner cases of stepping-substepping combination in
fw_info_matches_stepping() helper.

v4: Add macro for start_mmioaddr for V1 package. Simplify code
in dmc_set_fw_offset (Lucas)

	Cc: Souza, Jose <jose.souza@intel.com>
	Cc: Lucas De Marchi <lucas.demarchi@intel.com>
	Signed-off-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
	Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210621191415.29823-3-anusha.srivatsa@intel.com
(cherry picked from commit 3d5928a168a9546b23c6b3439c6158d7a028326c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_csr.c
#	drivers/gpu/drm/i915/display/intel_display_debugfs.c
#	drivers/gpu/drm/i915/display/intel_display_power.c
#	drivers/gpu/drm/i915/display/intel_dmc.h
#	drivers/gpu/drm/i915/i915_reg.h
diff --cc drivers/gpu/drm/i915/display/intel_csr.c
index 67dc64df78a5,18e0d225a478..000000000000
--- a/drivers/gpu/drm/i915/display/intel_csr.c
+++ b/drivers/gpu/drm/i915/display/intel_csr.c
@@@ -300,14 -315,14 +301,19 @@@ static void gen9_set_dc_state_debugmask
   * Everytime display comes back from low power state this function is called to
   * copy the firmware from internal memory to registers.
   */
 -void intel_dmc_load_program(struct drm_i915_private *dev_priv)
 +void intel_csr_load_program(struct drm_i915_private *dev_priv)
  {
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +	u32 *payload = dev_priv->csr.dmc_payload;
 +	u32 i, fw_size;
++=======
+ 	struct intel_dmc *dmc = &dev_priv->dmc;
+ 	u32 id, i;
++>>>>>>> 3d5928a168a9 (drm/i915/xelpd: Pipe A DMC plugging):drivers/gpu/drm/i915/display/intel_dmc.c
  
 -	if (!HAS_DMC(dev_priv)) {
 +	if (!HAS_CSR(dev_priv)) {
  		drm_err(&dev_priv->drm,
 -			"No DMC support available for this platform\n");
 +			"No CSR support available for this platform\n");
  		return;
  	}
  
@@@ -317,23 -332,28 +323,44 @@@
  		return;
  	}
  
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +	fw_size = dev_priv->csr.dmc_fw_size;
++=======
++>>>>>>> 3d5928a168a9 (drm/i915/xelpd: Pipe A DMC plugging):drivers/gpu/drm/i915/display/intel_dmc.c
  	assert_rpm_wakelock_held(&dev_priv->runtime_pm);
  
  	preempt_disable();
  
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +	for (i = 0; i < fw_size; i++)
 +		intel_uncore_write_fw(&dev_priv->uncore, CSR_PROGRAM(i),
 +				      payload[i]);
 +
 +	preempt_enable();
 +
 +	for (i = 0; i < dev_priv->csr.mmio_count; i++) {
 +		intel_de_write(dev_priv, dev_priv->csr.mmioaddr[i],
 +			       dev_priv->csr.mmiodata[i]);
++=======
+ 	for (id = 0; id < DMC_FW_MAX; id++) {
+ 		for (i = 0; i < dmc->dmc_info[id].dmc_fw_size; i++) {
+ 			intel_uncore_write_fw(&dev_priv->uncore,
+ 					      DMC_PROGRAM(dmc->dmc_info[id].start_mmioaddr, i),
+ 					      dmc->dmc_info[id].payload[i]);
+ 		}
+ 	}
+ 
+ 	preempt_enable();
+ 
+ 	for (id = 0; id < DMC_FW_MAX; id++) {
+ 		for (i = 0; i < dmc->dmc_info[id].mmio_count; i++) {
+ 			intel_de_write(dev_priv, dmc->dmc_info[id].mmioaddr[i],
+ 				       dmc->dmc_info[id].mmiodata[i]);
+ 		}
++>>>>>>> 3d5928a168a9 (drm/i915/xelpd: Pipe A DMC plugging):drivers/gpu/drm/i915/display/intel_dmc.c
  	}
  
 -	dev_priv->dmc.dc_state = 0;
 +	dev_priv->csr.dc_state = 0;
  
  	gen9_set_dc_state_debugmask(dev_priv);
  }
@@@ -347,52 -385,45 +392,57 @@@ static void dmc_set_fw_offset(struct in
  			      const struct stepping_info *si,
  			      u8 package_ver)
  {
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +	u32 dmc_offset = CSR_DEFAULT_FW_OFFSET;
 +	unsigned int i;
++=======
+ 	unsigned int i, id;
+ 
+ 	struct drm_i915_private *i915 = container_of(dmc, typeof(*i915), dmc);
++>>>>>>> 3d5928a168a9 (drm/i915/xelpd: Pipe A DMC plugging):drivers/gpu/drm/i915/display/intel_dmc.c
  
  	for (i = 0; i < num_entries; i++) {
- 		if (package_ver > 1 && fw_info[i].dmc_id != 0)
- 			continue;
+ 		id = package_ver <= 1 ? DMC_FW_MAIN : fw_info[i].dmc_id;
  
- 		if (fw_info[i].substepping == '*' &&
- 		    si->stepping == fw_info[i].stepping) {
- 			dmc_offset = fw_info[i].offset;
- 			break;
+ 		if (id >= DMC_FW_MAX) {
+ 			drm_dbg(&i915->drm, "Unsupported firmware id: %u\n", id);
+ 			continue;
  		}
  
- 		if (si->stepping == fw_info[i].stepping &&
- 		    si->substepping == fw_info[i].substepping) {
- 			dmc_offset = fw_info[i].offset;
- 			break;
- 		}
+ 		/* More specific versions come first, so we don't even have to
+ 		 * check for the stepping since we already found a previous FW
+ 		 * for this id.
+ 		 */
+ 		if (dmc->dmc_info[id].present)
+ 			continue;
  
- 		if (fw_info[i].stepping == '*' &&
- 		    fw_info[i].substepping == '*') {
- 			/*
- 			 * In theory we should stop the search as generic
- 			 * entries should always come after the more specific
- 			 * ones, but let's continue to make sure to work even
- 			 * with "broken" firmwares. If we don't find a more
- 			 * specific one, then we use this entry
- 			 */
- 			dmc_offset = fw_info[i].offset;
+ 		if (fw_info_matches_stepping(&fw_info[i], si)) {
+ 			dmc->dmc_info[id].present = true;
+ 			dmc->dmc_info[id].dmc_offset = fw_info[i].offset;
  		}
  	}
- 
- 	return dmc_offset;
  }
  
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +static u32 parse_csr_fw_dmc(struct intel_csr *csr,
 +			    const struct intel_dmc_header_base *dmc_header,
 +			    size_t rem_size)
 +{
++=======
+ static u32 parse_dmc_fw_header(struct intel_dmc *dmc,
+ 			       const struct intel_dmc_header_base *dmc_header,
+ 			       size_t rem_size, u8 dmc_id)
+ {
+ 	struct drm_i915_private *i915 = container_of(dmc, typeof(*i915), dmc);
+ 	struct dmc_fw_info *dmc_info = &dmc->dmc_info[dmc_id];
++>>>>>>> 3d5928a168a9 (drm/i915/xelpd: Pipe A DMC plugging):drivers/gpu/drm/i915/display/intel_dmc.c
  	unsigned int header_len_bytes, dmc_header_size, payload_size, i;
  	const u32 *mmioaddr, *mmiodata;
- 	u32 mmio_count, mmio_count_max;
+ 	u32 mmio_count, mmio_count_max, start_mmioaddr;
  	u8 *payload;
  
 -	BUILD_BUG_ON(ARRAY_SIZE(dmc_info->mmioaddr) < DMC_V3_MAX_MMIO_COUNT ||
 -		     ARRAY_SIZE(dmc_info->mmioaddr) < DMC_V1_MAX_MMIO_COUNT);
 +	BUILD_BUG_ON(ARRAY_SIZE(csr->mmioaddr) < DMC_V3_MAX_MMIO_COUNT ||
 +		     ARRAY_SIZE(csr->mmioaddr) < DMC_V1_MAX_MMIO_COUNT);
  
  	/*
  	 * Check if we can access common fields, we will checkc again below
@@@ -428,10 -460,11 +479,11 @@@
  		mmio_count = v1->mmio_count;
  		mmio_count_max = DMC_V1_MAX_MMIO_COUNT;
  		header_len_bytes = dmc_header->header_len;
+ 		start_mmioaddr = DMC_V1_MMIO_START_RANGE;
  		dmc_header_size = sizeof(*v1);
  	} else {
 -		drm_err(&i915->drm, "Unknown DMC fw header version: %u\n",
 -			dmc_header->header_ver);
 +		DRM_ERROR("Unknown DMC fw header version: %u\n",
 +			  dmc_header->header_ver);
  		return 0;
  	}
  
@@@ -448,16 -481,11 +500,24 @@@
  	}
  
  	for (i = 0; i < mmio_count; i++) {
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +		if (mmioaddr[i] < CSR_MMIO_START_RANGE ||
 +		    mmioaddr[i] > CSR_MMIO_END_RANGE) {
 +			DRM_ERROR("DMC firmware has wrong mmio address 0x%x\n",
 +				  mmioaddr[i]);
 +			return 0;
 +		}
 +		csr->mmioaddr[i] = _MMIO(mmioaddr[i]);
 +		csr->mmiodata[i] = mmiodata[i];
 +	}
 +	csr->mmio_count = mmio_count;
++=======
+ 		dmc_info->mmioaddr[i] = _MMIO(mmioaddr[i]);
+ 		dmc_info->mmiodata[i] = mmiodata[i];
+ 	}
+ 	dmc_info->mmio_count = mmio_count;
+ 	dmc_info->start_mmioaddr = start_mmioaddr;
++>>>>>>> 3d5928a168a9 (drm/i915/xelpd: Pipe A DMC plugging):drivers/gpu/drm/i915/display/intel_dmc.c
  
  	rem_size -= header_len_bytes;
  
@@@ -494,8 -520,9 +554,8 @@@ parse_csr_fw_package(struct intel_csr *
  		     const struct stepping_info *si,
  		     size_t rem_size)
  {
 -	struct drm_i915_private *i915 = container_of(dmc, typeof(*i915), dmc);
  	u32 package_size = sizeof(struct intel_package_header);
- 	u32 num_entries, max_entries, dmc_offset;
+ 	u32 num_entries, max_entries;
  	const struct intel_fw_info *fw_info;
  
  	if (rem_size < package_size)
@@@ -531,19 -558,14 +591,24 @@@
  
  	fw_info = (const struct intel_fw_info *)
  		((u8 *)package_header + sizeof(*package_header));
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +	dmc_offset = find_dmc_fw_offset(fw_info, num_entries, si,
 +					package_header->header_ver);
 +	if (dmc_offset == CSR_DEFAULT_FW_OFFSET) {
 +		DRM_ERROR("DMC firmware not supported for %c stepping\n",
 +			  si->stepping);
 +		return 0;
 +	}
++=======
+ 	dmc_set_fw_offset(dmc, fw_info, num_entries, si,
+ 			  package_header->header_ver);
++>>>>>>> 3d5928a168a9 (drm/i915/xelpd: Pipe A DMC plugging):drivers/gpu/drm/i915/display/intel_dmc.c
  
  	/* dmc_offset is in dwords */
- 	return package_size + dmc_offset * 4;
+ 	return package_size;
  
  error_truncated:
 -	drm_err(&i915->drm, "Truncated DMC firmware, refusing.\n");
 +	DRM_ERROR("Truncated DMC firmware, refusing.\n");
  	return 0;
  }
  
@@@ -587,10 -611,11 +652,11 @@@ static void parse_csr_fw(struct drm_i91
  	struct intel_css_header *css_header;
  	struct intel_package_header *package_header;
  	struct intel_dmc_header_base *dmc_header;
 -	struct intel_dmc *dmc = &dev_priv->dmc;
 +	struct intel_csr *csr = &dev_priv->csr;
  	const struct stepping_info *si = intel_get_stepping_info(dev_priv);
  	u32 readcount = 0;
- 	u32 r;
+ 	u32 r, offset;
+ 	int id;
  
  	if (!fw)
  		return;
@@@ -611,15 -636,25 +677,31 @@@
  
  	readcount += r;
  
++<<<<<<< HEAD:drivers/gpu/drm/i915/display/intel_csr.c
 +	/* Extract dmc_header information */
 +	dmc_header = (struct intel_dmc_header_base *)&fw->data[readcount];
 +	parse_csr_fw_dmc(csr, dmc_header, fw->size - readcount);
++=======
+ 	for (id = 0; id < DMC_FW_MAX; id++) {
+ 		if (!dev_priv->dmc.dmc_info[id].present)
+ 			continue;
+ 
+ 		offset = readcount + dmc->dmc_info[id].dmc_offset * 4;
+ 		if (fw->size - offset < 0) {
+ 			drm_err(&dev_priv->drm, "Reading beyond the fw_size\n");
+ 			continue;
+ 		}
+ 
+ 		dmc_header = (struct intel_dmc_header_base *)&fw->data[offset];
+ 		parse_dmc_fw_header(dmc, dmc_header, fw->size - offset, id);
+ 	}
++>>>>>>> 3d5928a168a9 (drm/i915/xelpd: Pipe A DMC plugging):drivers/gpu/drm/i915/display/intel_dmc.c
  }
  
 -static void intel_dmc_runtime_pm_get(struct drm_i915_private *dev_priv)
 +static void intel_csr_runtime_pm_get(struct drm_i915_private *dev_priv)
  {
 -	drm_WARN_ON(&dev_priv->drm, dev_priv->dmc.wakeref);
 -	dev_priv->dmc.wakeref =
 +	drm_WARN_ON(&dev_priv->drm, dev_priv->csr.wakeref);
 +	dev_priv->csr.wakeref =
  		intel_display_power_get(dev_priv, POWER_DOMAIN_INIT);
  }
  
diff --cc drivers/gpu/drm/i915/display/intel_display_debugfs.c
index d62b18d5ecd8,2a1c39a0e56e..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display_debugfs.c
+++ b/drivers/gpu/drm/i915/display/intel_display_debugfs.c
@@@ -509,16 -542,18 +509,23 @@@ static int i915_dmc_info(struct seq_fil
  
  	wakeref = intel_runtime_pm_get(&dev_priv->runtime_pm);
  
++<<<<<<< HEAD
 +	seq_printf(m, "fw loaded: %s\n", yesno(csr->dmc_payload != NULL));
 +	seq_printf(m, "path: %s\n", csr->fw_path);
++=======
+ 	seq_printf(m, "fw loaded: %s\n", yesno(intel_dmc_has_payload(dev_priv)));
+ 	seq_printf(m, "path: %s\n", dmc->fw_path);
+ 	seq_printf(m, "Pipe A fw support: %s\n", yesno(INTEL_GEN(dev_priv) >= 12));
+ 	seq_printf(m, "Pipe A fw loaded: %s\n", yesno(dmc->dmc_info[DMC_FW_PIPEA].payload));
++>>>>>>> 3d5928a168a9 (drm/i915/xelpd: Pipe A DMC plugging)
  
 -	if (!intel_dmc_has_payload(dev_priv))
 +	if (!csr->dmc_payload)
  		goto out;
  
 -	seq_printf(m, "version: %d.%d\n", DMC_VERSION_MAJOR(dmc->version),
 -		   DMC_VERSION_MINOR(dmc->version));
 +	seq_printf(m, "version: %d.%d\n", CSR_VERSION_MAJOR(csr->version),
 +		   CSR_VERSION_MINOR(csr->version));
  
 -	if (DISPLAY_VER(dev_priv) >= 12) {
 +	if (INTEL_GEN(dev_priv) >= 12) {
  		if (IS_DGFX(dev_priv)) {
  			dc5_reg = DG1_DMC_DEBUG_DC5_COUNT;
  		} else {
@@@ -549,10 -584,10 +556,14 @@@
  
  out:
  	seq_printf(m, "program base: 0x%08x\n",
++<<<<<<< HEAD
 +		   intel_de_read(dev_priv, CSR_PROGRAM(0)));
++=======
+ 		   intel_de_read(dev_priv, DMC_PROGRAM(dmc->dmc_info[DMC_FW_MAIN].start_mmioaddr, 0)));
++>>>>>>> 3d5928a168a9 (drm/i915/xelpd: Pipe A DMC plugging)
  	seq_printf(m, "ssp base: 0x%08x\n",
 -		   intel_de_read(dev_priv, DMC_SSP_BASE));
 -	seq_printf(m, "htp: 0x%08x\n", intel_de_read(dev_priv, DMC_HTP_SKL));
 +		   intel_de_read(dev_priv, CSR_SSP_BASE));
 +	seq_printf(m, "htp: 0x%08x\n", intel_de_read(dev_priv, CSR_HTP_SKL));
  
  	intel_runtime_pm_put(&dev_priv->runtime_pm, wakeref);
  
diff --cc drivers/gpu/drm/i915/display/intel_display_power.c
index e2cb6e6ca250,285380079aab..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display_power.c
+++ b/drivers/gpu/drm/i915/display/intel_display_power.c
@@@ -951,15 -958,16 +951,25 @@@ static void bxt_disable_dc9(struct drm_
  	intel_pps_unlock_regs_wa(dev_priv);
  }
  
 -static void assert_dmc_loaded(struct drm_i915_private *dev_priv)
 +static void assert_csr_loaded(struct drm_i915_private *dev_priv)
  {
  	drm_WARN_ONCE(&dev_priv->drm,
++<<<<<<< HEAD
 +		      !intel_de_read(dev_priv, CSR_PROGRAM(0)),
 +		      "CSR program storage start is NULL\n");
 +	drm_WARN_ONCE(&dev_priv->drm, !intel_de_read(dev_priv, CSR_SSP_BASE),
 +		      "CSR SSP Base Not fine\n");
 +	drm_WARN_ONCE(&dev_priv->drm, !intel_de_read(dev_priv, CSR_HTP_SKL),
 +		      "CSR HTP Not fine\n");
++=======
+ 		      !intel_de_read(dev_priv,
+ 				     DMC_PROGRAM(dev_priv->dmc.dmc_info[DMC_FW_MAIN].start_mmioaddr, 0)),
+ 				     "DMC program storage start is NULL\n");
+ 	drm_WARN_ONCE(&dev_priv->drm, !intel_de_read(dev_priv, DMC_SSP_BASE),
+ 		      "DMC SSP Base Not fine\n");
+ 	drm_WARN_ONCE(&dev_priv->drm, !intel_de_read(dev_priv, DMC_HTP_SKL),
+ 		      "DMC HTP Not fine\n");
++>>>>>>> 3d5928a168a9 (drm/i915/xelpd: Pipe A DMC plugging)
  }
  
  static struct i915_power_well *
diff --cc drivers/gpu/drm/i915/i915_reg.h
index e96989dea1ef,61fdd61b33b3..000000000000
--- a/drivers/gpu/drm/i915/i915_reg.h
+++ b/drivers/gpu/drm/i915/i915_reg.h
@@@ -7680,20 -7738,20 +7680,37 @@@ enum 
  #define  GAMMA_MODE_MODE_SPLIT	(3 << 0) /* ivb-bdw */
  #define  GAMMA_MODE_MODE_12BIT_MULTI_SEGMENTED	(3 << 0) /* icl + */
  
++<<<<<<< HEAD
 +/* DMC/CSR */
 +#define CSR_PROGRAM(i)		_MMIO(0x80000 + (i) * 4)
 +#define CSR_SSP_BASE_ADDR_GEN9	0x00002FC0
 +#define CSR_HTP_ADDR_SKL	0x00500034
 +#define CSR_SSP_BASE		_MMIO(0x8F074)
 +#define CSR_HTP_SKL		_MMIO(0x8F004)
 +#define CSR_LAST_WRITE		_MMIO(0x8F034)
 +#define CSR_LAST_WRITE_VALUE	0xc003b400
 +/* MMIO address range for CSR program (0x80000 - 0x82FFF) */
 +#define CSR_MMIO_START_RANGE	0x80000
 +#define CSR_MMIO_END_RANGE	0x8FFFF
 +#define SKL_CSR_DC3_DC5_COUNT	_MMIO(0x80030)
 +#define SKL_CSR_DC5_DC6_COUNT	_MMIO(0x8002C)
 +#define BXT_CSR_DC3_DC5_COUNT	_MMIO(0x80038)
++=======
+ /* DMC */
+ #define DMC_PROGRAM(addr, i)	_MMIO((addr) + (i) * 4)
+ #define DMC_SSP_BASE_ADDR_GEN9	0x00002FC0
+ #define DMC_HTP_ADDR_SKL	0x00500034
+ #define DMC_SSP_BASE		_MMIO(0x8F074)
+ #define DMC_HTP_SKL		_MMIO(0x8F004)
+ #define DMC_LAST_WRITE		_MMIO(0x8F034)
+ #define DMC_LAST_WRITE_VALUE	0xc003b400
+ /* MMIO address range for DMC program (0x80000 - 0x82FFF) */
+ #define DMC_MMIO_START_RANGE	0x80000
+ #define DMC_MMIO_END_RANGE	0x8FFFF
+ #define SKL_DMC_DC3_DC5_COUNT	_MMIO(0x80030)
+ #define SKL_DMC_DC5_DC6_COUNT	_MMIO(0x8002C)
+ #define BXT_DMC_DC3_DC5_COUNT	_MMIO(0x80038)
++>>>>>>> 3d5928a168a9 (drm/i915/xelpd: Pipe A DMC plugging)
  #define TGL_DMC_DEBUG_DC5_COUNT	_MMIO(0x101084)
  #define TGL_DMC_DEBUG_DC6_COUNT	_MMIO(0x101088)
  #define DG1_DMC_DEBUG_DC5_COUNT	_MMIO(0x134154)
* Unmerged path drivers/gpu/drm/i915/display/intel_dmc.h
* Unmerged path drivers/gpu/drm/i915/display/intel_csr.c
* Unmerged path drivers/gpu/drm/i915/display/intel_display_debugfs.c
* Unmerged path drivers/gpu/drm/i915/display/intel_display_power.c
* Unmerged path drivers/gpu/drm/i915/display/intel_dmc.h
* Unmerged path drivers/gpu/drm/i915/i915_reg.h
