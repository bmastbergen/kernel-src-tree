drm/i915/display: Workaround cursor left overs with PSR2 selective fetch enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author José Roberto de Souza <jose.souza@intel.com>
commit 1f3a11c341ab211d6ba55ef3d58026b7b5319945
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/1f3a11c3.failed

Not sure why but when moving the cursor fast it causes some artifacts
of the cursor to be left in the cursor path, adding some pixels above
the cursor to the damaged area fixes the issue, so leaving this as a
workaround until proper fix is found.

This is reproducile on TGL and ADL-P.

	Cc: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
	Reviewed-by: Gwan-gyeong Mun <gwan-gyeong.mun@intel.com>
	Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210914212507.177511-3-jose.souza@intel.com
(cherry picked from commit 1f3a11c341ab211d6ba55ef3d58026b7b5319945)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_psr.c
diff --cc drivers/gpu/drm/i915/display/intel_psr.c
index 2c6c4a4f9477,f8fa30e50e70..000000000000
--- a/drivers/gpu/drm/i915/display/intel_psr.c
+++ b/drivers/gpu/drm/i915/display/intel_psr.c
@@@ -1309,6 -1529,42 +1309,45 @@@ static void clip_area_update(struct drm
  		overlap_damage_area->y2 = damage_area->y2;
  }
  
++<<<<<<< HEAD
++=======
+ static void intel_psr2_sel_fetch_pipe_alignment(const struct intel_crtc_state *crtc_state,
+ 						struct drm_rect *pipe_clip)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(crtc_state->uapi.crtc->dev);
+ 	const u16 y_alignment = crtc_state->su_y_granularity;
+ 
+ 	pipe_clip->y1 -= pipe_clip->y1 % y_alignment;
+ 	if (pipe_clip->y2 % y_alignment)
+ 		pipe_clip->y2 = ((pipe_clip->y2 / y_alignment) + 1) * y_alignment;
+ 
+ 	if (IS_ALDERLAKE_P(dev_priv) && crtc_state->dsc.compression_enable)
+ 		drm_warn(&dev_priv->drm, "Missing PSR2 sel fetch alignment with DSC\n");
+ }
+ 
+ /*
+  * FIXME: Not sure why but when moving the cursor fast it causes some artifacts
+  * of the cursor to be left in the cursor path, adding some pixels above the
+  * cursor to the damaged area fixes the issue.
+  */
+ static void cursor_area_workaround(const struct intel_plane_state *new_plane_state,
+ 				   struct drm_rect *damaged_area,
+ 				   struct drm_rect *pipe_clip)
+ {
+ 	const struct intel_plane *plane = to_intel_plane(new_plane_state->uapi.plane);
+ 	int height;
+ 
+ 	if (plane->id != PLANE_CURSOR)
+ 		return;
+ 
+ 	height = drm_rect_height(&new_plane_state->uapi.dst) / 2;
+ 	damaged_area->y1 -=  height;
+ 	damaged_area->y1 = max(damaged_area->y1, 0);
+ 
+ 	clip_area_update(pipe_clip, damaged_area);
+ }
+ 
++>>>>>>> 1f3a11c341ab (drm/i915/display: Workaround cursor left overs with PSR2 selective fetch enabled)
  int intel_psr2_sel_fetch_update(struct intel_atomic_state *state,
  				struct intel_crtc *crtc)
  {
* Unmerged path drivers/gpu/drm/i915/display/intel_psr.c
