igc: enable auxiliary PHC functions for the i225

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Ederson de Souza <ederson.desouza@intel.com>
commit 87938851b6efb6d5b44ae93c83226c6f991d5cc1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/87938851.failed

The i225 device offers a number of special PTP Hardware Clock features on
the Software Defined Pins (SDPs) - much like i210, which is used as
inspiration for this patch. It enables two possible functions, namely
time stamping external events and periodic output signals.

The assignment of PHC functions to the four SDP can be freely chosen by
the user.

For the external events time stamping, when the SDP (configured as input
by user) level changes, an interrupt is generated and the kernel
Precision Time Protocol (PTP) is informed.

For the periodic output signals, the i225 is configured to generate them
(so the SDP level will change periodically) and the driver also has to
keep updating the time of the next level change. However, this work is
not necessary for some frequencies as the i225 takes care of them
(namely, anything with a half-cycle of 500ms, 250ms, 125ms or < 70ms).

While i225 allows up to four timers to be used to source the time used
on the external events or output signals, this patch uses only one of
those timers. Main reason is to keep it simple, as it's not clear how
these extra timers would be exposed to users. Note that currently a NIC
can expose a single PTP device.

	Signed-off-by: Ederson de Souza <ederson.desouza@intel.com>
	Tested-by: Dvora Fuxbrumer <dvorax.fuxbrumer@linux.intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 87938851b6efb6d5b44ae93c83226c6f991d5cc1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/igc/igc.h
#	drivers/net/ethernet/intel/igc/igc_main.c
#	drivers/net/ethernet/intel/igc/igc_ptp.c
diff --cc drivers/net/ethernet/intel/igc/igc.h
index b00cd8696b6d,25871351730b..000000000000
--- a/drivers/net/ethernet/intel/igc/igc.h
+++ b/drivers/net/ethernet/intel/igc/igc.h
@@@ -219,6 -226,16 +224,19 @@@ struct igc_adapter 
  	ktime_t ptp_reset_start; /* Reset time in clock mono */
  
  	char fw_version[32];
++<<<<<<< HEAD
++=======
+ 
+ 	struct bpf_prog *xdp_prog;
+ 
+ 	bool pps_sys_wrap_on;
+ 
+ 	struct ptp_pin_desc sdp_config[IGC_N_SDP];
+ 	struct {
+ 		struct timespec64 start;
+ 		struct timespec64 period;
+ 	} perout[IGC_N_PEROUT];
++>>>>>>> 87938851b6ef (igc: enable auxiliary PHC functions for the i225)
  };
  
  void igc_up(struct igc_adapter *adapter);
diff --cc drivers/net/ethernet/intel/igc/igc_main.c
index 261f28037c1a,069471b7ffb0..000000000000
--- a/drivers/net/ethernet/intel/igc/igc_main.c
+++ b/drivers/net/ethernet/intel/igc/igc_main.c
@@@ -3992,9 -4250,20 +3992,18 @@@ igc_features_check(struct sk_buff *skb
  
  static void igc_tsync_interrupt(struct igc_adapter *adapter)
  {
+ 	u32 ack, tsauxc, sec, nsec, tsicr;
  	struct igc_hw *hw = &adapter->hw;
++<<<<<<< HEAD
 +	u32 tsicr = rd32(IGC_TSICR);
 +	u32 ack = 0;
++=======
+ 	struct ptp_clock_event event;
+ 	struct timespec64 ts;
+ 
+ 	tsicr = rd32(IGC_TSICR);
+ 	ack = 0;
 -
 -	if (tsicr & IGC_TSICR_SYS_WRAP) {
 -		event.type = PTP_CLOCK_PPS;
 -		if (adapter->ptp_caps.pps)
 -			ptp_clock_event(adapter->ptp_clock, &event);
 -		ack |= IGC_TSICR_SYS_WRAP;
 -	}
++>>>>>>> 87938851b6ef (igc: enable auxiliary PHC functions for the i225)
  
  	if (tsicr & IGC_TSICR_TXTS) {
  		/* retrieve hardware timestamp */
diff --cc drivers/net/ethernet/intel/igc/igc_ptp.c
index dfa3b247fcd8,69617d2c1be2..000000000000
--- a/drivers/net/ethernet/intel/igc/igc_ptp.c
+++ b/drivers/net/ethernet/intel/igc/igc_ptp.c
@@@ -123,6 -241,151 +241,154 @@@ static void igc_pin_extts(struct igc_ad
  static int igc_ptp_feature_enable_i225(struct ptp_clock_info *ptp,
  				       struct ptp_clock_request *rq, int on)
  {
++<<<<<<< HEAD
++=======
+ 	struct igc_adapter *igc =
+ 		container_of(ptp, struct igc_adapter, ptp_caps);
+ 	struct igc_hw *hw = &igc->hw;
+ 	unsigned long flags;
+ 	struct timespec64 ts;
+ 	int use_freq = 0, pin = -1;
+ 	u32 tsim, tsauxc, tsauxc_mask, tsim_mask, trgttiml, trgttimh, freqout;
+ 	s64 ns;
+ 
+ 	switch (rq->type) {
+ 	case PTP_CLK_REQ_EXTTS:
+ 		/* Reject requests with unsupported flags */
+ 		if (rq->extts.flags & ~(PTP_ENABLE_FEATURE |
+ 					PTP_RISING_EDGE |
+ 					PTP_FALLING_EDGE |
+ 					PTP_STRICT_FLAGS))
+ 			return -EOPNOTSUPP;
+ 
+ 		/* Reject requests failing to enable both edges. */
+ 		if ((rq->extts.flags & PTP_STRICT_FLAGS) &&
+ 		    (rq->extts.flags & PTP_ENABLE_FEATURE) &&
+ 		    (rq->extts.flags & PTP_EXTTS_EDGES) != PTP_EXTTS_EDGES)
+ 			return -EOPNOTSUPP;
+ 
+ 		if (on) {
+ 			pin = ptp_find_pin(igc->ptp_clock, PTP_PF_EXTTS,
+ 					   rq->extts.index);
+ 			if (pin < 0)
+ 				return -EBUSY;
+ 		}
+ 		if (rq->extts.index == 1) {
+ 			tsauxc_mask = IGC_TSAUXC_EN_TS1;
+ 			tsim_mask = IGC_TSICR_AUTT1;
+ 		} else {
+ 			tsauxc_mask = IGC_TSAUXC_EN_TS0;
+ 			tsim_mask = IGC_TSICR_AUTT0;
+ 		}
+ 		spin_lock_irqsave(&igc->tmreg_lock, flags);
+ 		tsauxc = rd32(IGC_TSAUXC);
+ 		tsim = rd32(IGC_TSIM);
+ 		if (on) {
+ 			igc_pin_extts(igc, rq->extts.index, pin);
+ 			tsauxc |= tsauxc_mask;
+ 			tsim |= tsim_mask;
+ 		} else {
+ 			tsauxc &= ~tsauxc_mask;
+ 			tsim &= ~tsim_mask;
+ 		}
+ 		wr32(IGC_TSAUXC, tsauxc);
+ 		wr32(IGC_TSIM, tsim);
+ 		spin_unlock_irqrestore(&igc->tmreg_lock, flags);
+ 		return 0;
+ 
+ 	case PTP_CLK_REQ_PEROUT:
+ 		/* Reject requests with unsupported flags */
+ 		if (rq->perout.flags)
+ 			return -EOPNOTSUPP;
+ 
+ 		if (on) {
+ 			pin = ptp_find_pin(igc->ptp_clock, PTP_PF_PEROUT,
+ 					   rq->perout.index);
+ 			if (pin < 0)
+ 				return -EBUSY;
+ 		}
+ 		ts.tv_sec = rq->perout.period.sec;
+ 		ts.tv_nsec = rq->perout.period.nsec;
+ 		ns = timespec64_to_ns(&ts);
+ 		ns = ns >> 1;
+ 		if (on && (ns <= 70000000LL || ns == 125000000LL ||
+ 			   ns == 250000000LL || ns == 500000000LL)) {
+ 			if (ns < 8LL)
+ 				return -EINVAL;
+ 			use_freq = 1;
+ 		}
+ 		ts = ns_to_timespec64(ns);
+ 		if (rq->perout.index == 1) {
+ 			if (use_freq) {
+ 				tsauxc_mask = IGC_TSAUXC_EN_CLK1;
+ 				tsim_mask = 0;
+ 			} else {
+ 				tsauxc_mask = IGC_TSAUXC_EN_TT1;
+ 				tsim_mask = IGC_TSICR_TT1;
+ 			}
+ 			trgttiml = IGC_TRGTTIML1;
+ 			trgttimh = IGC_TRGTTIMH1;
+ 			freqout = IGC_FREQOUT1;
+ 		} else {
+ 			if (use_freq) {
+ 				tsauxc_mask = IGC_TSAUXC_EN_CLK0;
+ 				tsim_mask = 0;
+ 			} else {
+ 				tsauxc_mask = IGC_TSAUXC_EN_TT0;
+ 				tsim_mask = IGC_TSICR_TT0;
+ 			}
+ 			trgttiml = IGC_TRGTTIML0;
+ 			trgttimh = IGC_TRGTTIMH0;
+ 			freqout = IGC_FREQOUT0;
+ 		}
+ 		spin_lock_irqsave(&igc->tmreg_lock, flags);
+ 		tsauxc = rd32(IGC_TSAUXC);
+ 		tsim = rd32(IGC_TSIM);
+ 		if (rq->perout.index == 1) {
+ 			tsauxc &= ~(IGC_TSAUXC_EN_TT1 | IGC_TSAUXC_EN_CLK1);
+ 			tsim &= ~IGC_TSICR_TT1;
+ 		} else {
+ 			tsauxc &= ~(IGC_TSAUXC_EN_TT0 | IGC_TSAUXC_EN_CLK0);
+ 			tsim &= ~IGC_TSICR_TT0;
+ 		}
+ 		if (on) {
+ 			int i = rq->perout.index;
+ 
+ 			igc_pin_perout(igc, i, pin, use_freq);
+ 			igc->perout[i].start.tv_sec = rq->perout.start.sec;
+ 			igc->perout[i].start.tv_nsec = rq->perout.start.nsec;
+ 			igc->perout[i].period.tv_sec = ts.tv_sec;
+ 			igc->perout[i].period.tv_nsec = ts.tv_nsec;
+ 			wr32(trgttimh, rq->perout.start.sec);
+ 			/* For now, always select timer 0 as source. */
+ 			wr32(trgttiml, rq->perout.start.nsec | IGC_TT_IO_TIMER_SEL_SYSTIM0);
+ 			if (use_freq)
+ 				wr32(freqout, ns);
+ 			tsauxc |= tsauxc_mask;
+ 			tsim |= tsim_mask;
+ 		}
+ 		wr32(IGC_TSAUXC, tsauxc);
+ 		wr32(IGC_TSIM, tsim);
+ 		spin_unlock_irqrestore(&igc->tmreg_lock, flags);
+ 		return 0;
+ 
+ 	case PTP_CLK_REQ_PPS:
+ 		spin_lock_irqsave(&igc->tmreg_lock, flags);
+ 		tsim = rd32(IGC_TSIM);
+ 		if (on)
+ 			tsim |= IGC_TSICR_SYS_WRAP;
+ 		else
+ 			tsim &= ~IGC_TSICR_SYS_WRAP;
+ 		igc->pps_sys_wrap_on = on;
+ 		wr32(IGC_TSIM, tsim);
+ 		spin_unlock_irqrestore(&igc->tmreg_lock, flags);
+ 		return 0;
+ 
+ 	default:
+ 		break;
+ 	}
+ 
++>>>>>>> 87938851b6ef (igc: enable auxiliary PHC functions for the i225)
  	return -EOPNOTSUPP;
  }
  
@@@ -497,6 -782,12 +785,15 @@@ void igc_ptp_init(struct igc_adapter *a
  		adapter->ptp_caps.gettimex64 = igc_ptp_gettimex64_i225;
  		adapter->ptp_caps.settime64 = igc_ptp_settime_i225;
  		adapter->ptp_caps.enable = igc_ptp_feature_enable_i225;
++<<<<<<< HEAD
++=======
+ 		adapter->ptp_caps.pps = 1;
+ 		adapter->ptp_caps.pin_config = adapter->sdp_config;
+ 		adapter->ptp_caps.n_ext_ts = IGC_N_EXTTS;
+ 		adapter->ptp_caps.n_per_out = IGC_N_PEROUT;
+ 		adapter->ptp_caps.n_pins = IGC_N_SDP;
+ 		adapter->ptp_caps.verify = igc_ptp_verify_pin;
++>>>>>>> 87938851b6ef (igc: enable auxiliary PHC functions for the i225)
  		break;
  	default:
  		adapter->ptp_clock = NULL;
* Unmerged path drivers/net/ethernet/intel/igc/igc.h
diff --git a/drivers/net/ethernet/intel/igc/igc_defines.h b/drivers/net/ethernet/intel/igc/igc_defines.h
index 35ed997af075..0103dda32f39 100644
--- a/drivers/net/ethernet/intel/igc/igc_defines.h
+++ b/drivers/net/ethernet/intel/igc/igc_defines.h
@@ -8,6 +8,8 @@
 #define REQ_TX_DESCRIPTOR_MULTIPLE	8
 #define REQ_RX_DESCRIPTOR_MULTIPLE	8
 
+#define IGC_CTRL_EXT_SDP2_DIR	0x00000400 /* SDP2 Data direction */
+#define IGC_CTRL_EXT_SDP3_DIR	0x00000800 /* SDP3 Data direction */
 #define IGC_CTRL_EXT_DRV_LOAD	0x10000000 /* Drv loaded bit for FW */
 
 /* Definitions for power management and wakeup registers */
@@ -96,6 +98,9 @@
 #define IGC_CTRL_RFCE		0x08000000  /* Receive Flow Control enable */
 #define IGC_CTRL_TFCE		0x10000000  /* Transmit flow control enable */
 
+#define IGC_CTRL_SDP0_DIR 0x00400000	/* SDP0 Data direction */
+#define IGC_CTRL_SDP1_DIR 0x00800000	/* SDP1 Data direction */
+
 /* As per the EAS the maximum supported size is 9.5KB (9728 bytes) */
 #define MAX_JUMBO_FRAME_SIZE	0x2600
 
@@ -403,6 +408,64 @@
 #define IGC_TSYNCTXCTL_START_SYNC		0x80000000  /* initiate sync */
 #define IGC_TSYNCTXCTL_TXSYNSIG			0x00000020  /* Sample TX tstamp in PHY sop */
 
+/* Timer selection bits */
+#define IGC_AUX_IO_TIMER_SEL_SYSTIM0	(0u << 30) /* Select SYSTIM0 for auxiliary time stamp */
+#define IGC_AUX_IO_TIMER_SEL_SYSTIM1	(1u << 30) /* Select SYSTIM1 for auxiliary time stamp */
+#define IGC_AUX_IO_TIMER_SEL_SYSTIM2	(2u << 30) /* Select SYSTIM2 for auxiliary time stamp */
+#define IGC_AUX_IO_TIMER_SEL_SYSTIM3	(3u << 30) /* Select SYSTIM3 for auxiliary time stamp */
+#define IGC_TT_IO_TIMER_SEL_SYSTIM0	(0u << 30) /* Select SYSTIM0 for target time stamp */
+#define IGC_TT_IO_TIMER_SEL_SYSTIM1	(1u << 30) /* Select SYSTIM1 for target time stamp */
+#define IGC_TT_IO_TIMER_SEL_SYSTIM2	(2u << 30) /* Select SYSTIM2 for target time stamp */
+#define IGC_TT_IO_TIMER_SEL_SYSTIM3	(3u << 30) /* Select SYSTIM3 for target time stamp */
+
+/* TSAUXC Configuration Bits */
+#define IGC_TSAUXC_EN_TT0	BIT(0)  /* Enable target time 0. */
+#define IGC_TSAUXC_EN_TT1	BIT(1)  /* Enable target time 1. */
+#define IGC_TSAUXC_EN_CLK0	BIT(2)  /* Enable Configurable Frequency Clock 0. */
+#define IGC_TSAUXC_EN_CLK1	BIT(5)  /* Enable Configurable Frequency Clock 1. */
+#define IGC_TSAUXC_EN_TS0	BIT(8)  /* Enable hardware timestamp 0. */
+#define IGC_TSAUXC_AUTT0	BIT(9)  /* Auxiliary Timestamp Taken. */
+#define IGC_TSAUXC_EN_TS1	BIT(10) /* Enable hardware timestamp 0. */
+#define IGC_TSAUXC_AUTT1	BIT(11) /* Auxiliary Timestamp Taken. */
+#define IGC_TSAUXC_PLSG		BIT(17) /* Generate a pulse. */
+#define IGC_TSAUXC_DISABLE1	BIT(27) /* Disable SYSTIM0 Count Operation. */
+#define IGC_TSAUXC_DISABLE2	BIT(28) /* Disable SYSTIM1 Count Operation. */
+#define IGC_TSAUXC_DISABLE3	BIT(29) /* Disable SYSTIM2 Count Operation. */
+#define IGC_TSAUXC_DIS_TS_CLEAR	BIT(30) /* Disable EN_TT0/1 auto clear. */
+#define IGC_TSAUXC_DISABLE0	BIT(31) /* Disable SYSTIM0 Count Operation. */
+
+/* SDP Configuration Bits */
+#define IGC_AUX0_SEL_SDP0	(0u << 0)  /* Assign SDP0 to auxiliary time stamp 0. */
+#define IGC_AUX0_SEL_SDP1	(1u << 0)  /* Assign SDP1 to auxiliary time stamp 0. */
+#define IGC_AUX0_SEL_SDP2	(2u << 0)  /* Assign SDP2 to auxiliary time stamp 0. */
+#define IGC_AUX0_SEL_SDP3	(3u << 0)  /* Assign SDP3 to auxiliary time stamp 0. */
+#define IGC_AUX0_TS_SDP_EN	(1u << 2)  /* Enable auxiliary time stamp trigger 0. */
+#define IGC_AUX1_SEL_SDP0	(0u << 3)  /* Assign SDP0 to auxiliary time stamp 1. */
+#define IGC_AUX1_SEL_SDP1	(1u << 3)  /* Assign SDP1 to auxiliary time stamp 1. */
+#define IGC_AUX1_SEL_SDP2	(2u << 3)  /* Assign SDP2 to auxiliary time stamp 1. */
+#define IGC_AUX1_SEL_SDP3	(3u << 3)  /* Assign SDP3 to auxiliary time stamp 1. */
+#define IGC_AUX1_TS_SDP_EN	(1u << 5)  /* Enable auxiliary time stamp trigger 1. */
+#define IGC_TS_SDP0_SEL_TT0	(0u << 6)  /* Target time 0 is output on SDP0. */
+#define IGC_TS_SDP0_SEL_TT1	(1u << 6)  /* Target time 1 is output on SDP0. */
+#define IGC_TS_SDP0_SEL_FC0	(2u << 6)  /* Freq clock  0 is output on SDP0. */
+#define IGC_TS_SDP0_SEL_FC1	(3u << 6)  /* Freq clock  1 is output on SDP0. */
+#define IGC_TS_SDP0_EN		(1u << 8)  /* SDP0 is assigned to Tsync. */
+#define IGC_TS_SDP1_SEL_TT0	(0u << 9)  /* Target time 0 is output on SDP1. */
+#define IGC_TS_SDP1_SEL_TT1	(1u << 9)  /* Target time 1 is output on SDP1. */
+#define IGC_TS_SDP1_SEL_FC0	(2u << 9)  /* Freq clock  0 is output on SDP1. */
+#define IGC_TS_SDP1_SEL_FC1	(3u << 9)  /* Freq clock  1 is output on SDP1. */
+#define IGC_TS_SDP1_EN		(1u << 11) /* SDP1 is assigned to Tsync. */
+#define IGC_TS_SDP2_SEL_TT0	(0u << 12) /* Target time 0 is output on SDP2. */
+#define IGC_TS_SDP2_SEL_TT1	(1u << 12) /* Target time 1 is output on SDP2. */
+#define IGC_TS_SDP2_SEL_FC0	(2u << 12) /* Freq clock  0 is output on SDP2. */
+#define IGC_TS_SDP2_SEL_FC1	(3u << 12) /* Freq clock  1 is output on SDP2. */
+#define IGC_TS_SDP2_EN		(1u << 14) /* SDP2 is assigned to Tsync. */
+#define IGC_TS_SDP3_SEL_TT0	(0u << 15) /* Target time 0 is output on SDP3. */
+#define IGC_TS_SDP3_SEL_TT1	(1u << 15) /* Target time 1 is output on SDP3. */
+#define IGC_TS_SDP3_SEL_FC0	(2u << 15) /* Freq clock  0 is output on SDP3. */
+#define IGC_TS_SDP3_SEL_FC1	(3u << 15) /* Freq clock  1 is output on SDP3. */
+#define IGC_TS_SDP3_EN		(1u << 17) /* SDP3 is assigned to Tsync. */
+
 /* Transmit Scheduling */
 #define IGC_TQAVCTRL_TRANSMIT_MODE_TSN	0x00000001
 #define IGC_TQAVCTRL_ENHANCED_QAV	0x00000008
* Unmerged path drivers/net/ethernet/intel/igc/igc_main.c
* Unmerged path drivers/net/ethernet/intel/igc/igc_ptp.c
diff --git a/drivers/net/ethernet/intel/igc/igc_regs.h b/drivers/net/ethernet/intel/igc/igc_regs.h
index 3e5cb7aef9da..cc174853554b 100644
--- a/drivers/net/ethernet/intel/igc/igc_regs.h
+++ b/drivers/net/ethernet/intel/igc/igc_regs.h
@@ -192,6 +192,16 @@
 #define IGC_TSYNCTXCTL	0x0B614  /* Tx Time Sync Control register - RW */
 #define IGC_TSYNCRXCFG	0x05F50  /* Time Sync Rx Configuration - RW */
 #define IGC_TSSDP	0x0003C  /* Time Sync SDP Configuration Register - RW */
+#define IGC_TRGTTIML0	0x0B644 /* Target Time Register 0 Low  - RW */
+#define IGC_TRGTTIMH0	0x0B648 /* Target Time Register 0 High - RW */
+#define IGC_TRGTTIML1	0x0B64C /* Target Time Register 1 Low  - RW */
+#define IGC_TRGTTIMH1	0x0B650 /* Target Time Register 1 High - RW */
+#define IGC_FREQOUT0	0x0B654 /* Frequency Out 0 Control Register - RW */
+#define IGC_FREQOUT1	0x0B658 /* Frequency Out 1 Control Register - RW */
+#define IGC_AUXSTMPL0	0x0B65C /* Auxiliary Time Stamp 0 Register Low  - RO */
+#define IGC_AUXSTMPH0	0x0B660 /* Auxiliary Time Stamp 0 Register High - RO */
+#define IGC_AUXSTMPL1	0x0B664 /* Auxiliary Time Stamp 1 Register Low  - RO */
+#define IGC_AUXSTMPH1	0x0B668 /* Auxiliary Time Stamp 1 Register High - RO */
 
 #define IGC_IMIR(_i)	(0x05A80 + ((_i) * 4))  /* Immediate Interrupt */
 #define IGC_IMIREXT(_i)	(0x05AA0 + ((_i) * 4))  /* Immediate INTR Ext*/
