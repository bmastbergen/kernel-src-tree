kasan: add and integrate kasan boot parameters

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Andrey Konovalov <andreyknvl@google.com>
commit 8028caaca7a8107a52bb28fd92dea35bebd7ae8e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/8028caac.failed

Hardware tag-based KASAN mode is intended to eventually be used in
production as a security mitigation. Therefore there's a need for finer
control over KASAN features and for an existence of a kill switch.

This change adds a few boot parameters for hardware tag-based KASAN that
allow to disable or otherwise control particular KASAN features.

The features that can be controlled are:

1. Whether KASAN is enabled at all.
2. Whether KASAN collects and saves alloc/free stacks.
3. Whether KASAN panics on a detected bug or not.

With this change a new boot parameter kasan.mode allows to choose one of
three main modes:

- kasan.mode=off - KASAN is disabled, no tag checks are performed
- kasan.mode=prod - only essential production features are enabled
- kasan.mode=full - all KASAN features are enabled

The chosen mode provides default control values for the features mentioned
above. However it's also possible to override the default values by
providing:

- kasan.stacktrace=off/on - enable alloc/free stack collection
                            (default: on for mode=full, otherwise off)
- kasan.fault=report/panic - only report tag fault or also panic
                             (default: report)

If kasan.mode parameter is not provided, it defaults to full when
CONFIG_DEBUG_KERNEL is enabled, and to prod otherwise.

It is essential that switching between these modes doesn't require
rebuilding the kernel with different configs, as this is required by
the Android GKI (Generic Kernel Image) initiative [1].

[1] https://source.android.com/devices/architecture/kernel/generic-kernel-image

[andreyknvl@google.com: don't use read-only static keys]
  Link: https://lkml.kernel.org/r/f2ded589eba1597f7360a972226083de9afd86e2.1607537948.git.andreyknvl@google.com

Link: https://lkml.kernel.org/r/cb093613879d8d8841173f090133eddeb4c35f1f.1606162397.git.andreyknvl@google.com
Link: https://linux-review.googlesource.com/id/If7d37003875b2ed3e0935702c8015c223d6416a4
	Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
	Reviewed-by: Marco Elver <elver@google.com>
	Reviewed-by: Dmitry Vyukov <dvyukov@google.com>
	Tested-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Branislav Rankov <Branislav.Rankov@arm.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Evgenii Stepanov <eugenis@google.com>
	Cc: Kevin Brodsky <kevin.brodsky@arm.com>
	Cc: Vasily Gorbik <gor@linux.ibm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8028caaca7a8107a52bb28fd92dea35bebd7ae8e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/kasan/common.c
#	mm/kasan/hw_tags.c
#	mm/kasan/kasan.h
diff --cc mm/kasan/common.c
index e989322c0f3f,219c2979bd3e..000000000000
--- a/mm/kasan/common.c
+++ b/mm/kasan/common.c
@@@ -373,17 -267,18 +380,24 @@@ static u8 assign_tag(struct kmem_cache 
  void * __must_check kasan_init_slab_obj(struct kmem_cache *cache,
  						const void *object)
  {
 -	struct kasan_alloc_meta *alloc_meta;
 +	struct kasan_alloc_meta *alloc_info;
  
- 	if (!(cache->flags & SLAB_KASAN))
- 		return (void *)object;
+ 	if (kasan_stack_collection_enabled()) {
+ 		if (!(cache->flags & SLAB_KASAN))
+ 			return (void *)object;
  
++<<<<<<< HEAD
 +	alloc_info = get_alloc_info(cache, object);
 +	__memset(alloc_info, 0, sizeof(*alloc_info));
++=======
+ 		alloc_meta = kasan_get_alloc_meta(cache, object);
+ 		__memset(alloc_meta, 0, sizeof(*alloc_meta));
+ 	}
++>>>>>>> 8028caaca7a8 (kasan: add and integrate kasan boot parameters)
  
 -	if (IS_ENABLED(CONFIG_KASAN_SW_TAGS) || IS_ENABLED(CONFIG_KASAN_HW_TAGS))
 -		object = set_tag(object, assign_tag(cache, object, true, false));
 +	if (IS_ENABLED(CONFIG_KASAN_SW_TAGS))
 +		object = set_tag(object,
 +				assign_tag(cache, object, true, false));
  
  	return (void *)object;
  }
@@@ -431,9 -309,12 +445,12 @@@ static bool __kasan_slab_free(struct km
  		return true;
  	}
  
 -	rounded_up_size = round_up(cache->object_size, KASAN_GRANULE_SIZE);
 -	poison_range(object, rounded_up_size, KASAN_KMALLOC_FREE);
 +	rounded_up_size = round_up(cache->object_size, KASAN_SHADOW_SCALE_SIZE);
 +	kasan_poison_shadow(object, rounded_up_size, KASAN_KMALLOC_FREE);
  
+ 	if (!kasan_stack_collection_enabled())
+ 		return false;
+ 
  	if ((IS_ENABLED(CONFIG_KASAN_GENERIC) && !quarantine) ||
  			unlikely(!(cache->flags & SLAB_KASAN)))
  		return false;
@@@ -464,20 -350,20 +481,25 @@@ static void *__kasan_kmalloc(struct kme
  		return NULL;
  
  	redzone_start = round_up((unsigned long)(object + size),
 -				KASAN_GRANULE_SIZE);
 +				KASAN_SHADOW_SCALE_SIZE);
  	redzone_end = round_up((unsigned long)object + cache->object_size,
 -				KASAN_GRANULE_SIZE);
 +				KASAN_SHADOW_SCALE_SIZE);
  
 -	if (IS_ENABLED(CONFIG_KASAN_SW_TAGS) || IS_ENABLED(CONFIG_KASAN_HW_TAGS))
 +	if (IS_ENABLED(CONFIG_KASAN_SW_TAGS))
  		tag = assign_tag(cache, object, false, keep_tag);
  
 -	/* Tag is ignored in set_tag without CONFIG_KASAN_SW/HW_TAGS */
 -	unpoison_range(set_tag(object, tag), size);
 -	poison_range((void *)redzone_start, redzone_end - redzone_start,
 -		     KASAN_KMALLOC_REDZONE);
 +	/* Tag is ignored in set_tag without CONFIG_KASAN_SW_TAGS */
 +	kasan_unpoison_shadow(set_tag(object, tag), size);
 +	kasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,
 +		KASAN_KMALLOC_REDZONE);
  
++<<<<<<< HEAD
 +	if (cache->flags & SLAB_KASAN)
 +		kasan_set_track(&get_alloc_info(cache, object)->alloc_track, flags);
++=======
+ 	if (kasan_stack_collection_enabled() && (cache->flags & SLAB_KASAN))
+ 		set_alloc_info(cache, (void *)object, flags);
++>>>>>>> 8028caaca7a8 (kasan: add and integrate kasan boot parameters)
  
  	return set_tag(object, tag);
  }
diff --cc mm/kasan/kasan.h
index 2db4c5c1b473,ca43de9811de..000000000000
--- a/mm/kasan/kasan.h
+++ b/mm/kasan/kasan.h
@@@ -5,8 -5,32 +5,37 @@@
  #include <linux/kasan.h>
  #include <linux/stackdepot.h>
  
++<<<<<<< HEAD
 +#define KASAN_SHADOW_SCALE_SIZE (1UL << KASAN_SHADOW_SCALE_SHIFT)
 +#define KASAN_SHADOW_MASK       (KASAN_SHADOW_SCALE_SIZE - 1)
++=======
+ #ifdef CONFIG_KASAN_HW_TAGS
+ #include <linux/static_key.h>
+ DECLARE_STATIC_KEY_FALSE(kasan_flag_stacktrace);
+ static inline bool kasan_stack_collection_enabled(void)
+ {
+ 	return static_branch_unlikely(&kasan_flag_stacktrace);
+ }
+ #else
+ static inline bool kasan_stack_collection_enabled(void)
+ {
+ 	return true;
+ }
+ #endif
+ 
+ extern bool kasan_flag_panic __ro_after_init;
+ 
+ #if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)
+ #define KASAN_GRANULE_SIZE	(1UL << KASAN_SHADOW_SCALE_SHIFT)
+ #else
+ #include <asm/mte-kasan.h>
+ #define KASAN_GRANULE_SIZE	MTE_GRANULE_SIZE
+ #endif
+ 
+ #define KASAN_GRANULE_MASK	(KASAN_GRANULE_SIZE - 1)
+ 
+ #define KASAN_MEMORY_PER_SHADOW_PAGE	(KASAN_GRANULE_SIZE << PAGE_SHIFT)
++>>>>>>> 8028caaca7a8 (kasan: add and integrate kasan boot parameters)
  
  #define KASAN_TAG_KERNEL	0xFF /* native kernel pointers tag */
  #define KASAN_TAG_INVALID	0xFE /* inaccessible memory tag */
* Unmerged path mm/kasan/hw_tags.c
* Unmerged path mm/kasan/common.c
* Unmerged path mm/kasan/hw_tags.c
* Unmerged path mm/kasan/kasan.h
diff --git a/mm/kasan/report.c b/mm/kasan/report.c
index a0772fe304d1..c779e190b634 100644
--- a/mm/kasan/report.c
+++ b/mm/kasan/report.c
@@ -97,6 +97,10 @@ static void end_report(unsigned long *flags)
 		panic_on_warn = 0;
 		panic("panic_on_warn set ...\n");
 	}
+#ifdef CONFIG_KASAN_HW_TAGS
+	if (kasan_flag_panic)
+		panic("kasan.fault=panic set ...\n");
+#endif
 	kasan_enable_current();
 }
 
@@ -159,8 +163,8 @@ static void describe_object_addr(struct kmem_cache *cache, void *object,
 		(void *)(object_addr + cache->object_size));
 }
 
-static void describe_object(struct kmem_cache *cache, void *object,
-				const void *addr, u8 tag)
+static void describe_object_stacks(struct kmem_cache *cache, void *object,
+					const void *addr, u8 tag)
 {
 	struct kasan_alloc_meta *alloc_info = get_alloc_info(cache, object);
 
@@ -188,7 +192,13 @@ static void describe_object(struct kmem_cache *cache, void *object,
 		}
 #endif
 	}
+}
 
+static void describe_object(struct kmem_cache *cache, void *object,
+				const void *addr, u8 tag)
+{
+	if (kasan_stack_collection_enabled())
+		describe_object_stacks(cache, object, addr, tag);
 	describe_object_addr(cache, object, addr);
 }
 
