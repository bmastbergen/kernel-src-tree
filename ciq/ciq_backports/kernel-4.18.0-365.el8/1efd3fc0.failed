swiotlb: Emit diagnostic in swiotlb_exit()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Will Deacon <will@kernel.org>
commit 1efd3fc0ccf52e1aa5f0bf5b0d82847180d20951
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/1efd3fc0.failed

A recent debugging session would have been made a little bit easier if
we had noticed sooner that swiotlb_exit() was being called during boot.

Add a simple diagnostic message to swiotlb_exit() to complement the one
from swiotlb_print_info() during initialisation.

	Cc: Claire Chang <tientzu@chromium.org>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Robin Murphy <robin.murphy@arm.com>
Link: https://lore.kernel.org/r/20210705190352.GA19461@willie-the-truck
	Suggested-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Tested-by: Nathan Chancellor <nathan@kernel.org>
	Tested-by: Claire Chang <tientzu@chromium.org>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Will Deacon <will@kernel.org>
	Signed-off-by: Konrad Rzeszutek Wilk <konrad@kernel.org>
(cherry picked from commit 1efd3fc0ccf52e1aa5f0bf5b0d82847180d20951)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/dma/swiotlb.c
diff --cc kernel/dma/swiotlb.c
index be0e4e04c6fd,b3c793ed9e64..000000000000
--- a/kernel/dma/swiotlb.c
+++ b/kernel/dma/swiotlb.c
@@@ -439,29 -328,27 +439,47 @@@ cleanup3
  
  void __init swiotlb_exit(void)
  {
 -	size_t size;
 -	struct io_tlb_mem *mem = &io_tlb_default_mem;
 -
 -	if (!mem->nslabs)
 +	if (!io_tlb_orig_addr)
  		return;
  
++<<<<<<< HEAD
 +	if (late_alloc) {
 +		free_pages((unsigned long)io_tlb_orig_size,
 +			   get_order(io_tlb_nslabs * sizeof(size_t)));
 +		free_pages((unsigned long)io_tlb_orig_addr,
 +			   get_order(io_tlb_nslabs * sizeof(phys_addr_t)));
 +		free_pages((unsigned long)io_tlb_list, get_order(io_tlb_nslabs *
 +								 sizeof(int)));
 +		free_pages((unsigned long)phys_to_virt(io_tlb_start),
 +			   get_order(io_tlb_nslabs << IO_TLB_SHIFT));
 +	} else {
 +		memblock_free_late(__pa(io_tlb_orig_addr),
 +				   PAGE_ALIGN(io_tlb_nslabs * sizeof(phys_addr_t)));
 +		memblock_free_late(__pa(io_tlb_orig_size),
 +				   PAGE_ALIGN(io_tlb_nslabs * sizeof(size_t)));
 +		memblock_free_late(__pa(io_tlb_list),
 +				   PAGE_ALIGN(io_tlb_nslabs * sizeof(int)));
 +		memblock_free_late(io_tlb_start,
 +				   PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT));
 +	}
 +	swiotlb_cleanup();
++=======
+ 	pr_info("tearing down default memory pool\n");
+ 	size = array_size(sizeof(*mem->slots), mem->nslabs);
+ 	if (mem->late_alloc)
+ 		free_pages((unsigned long)mem->slots, get_order(size));
+ 	else
+ 		memblock_free_late(__pa(mem->slots), PAGE_ALIGN(size));
+ 	memset(mem, 0, sizeof(*mem));
+ }
+ 
+ /*
+  * Return the offset into a iotlb slot required to keep the device happy.
+  */
+ static unsigned int swiotlb_align_offset(struct device *dev, u64 addr)
+ {
+ 	return addr & dma_get_min_align_mask(dev) & (IO_TLB_SIZE - 1);
++>>>>>>> 1efd3fc0ccf5 (swiotlb: Emit diagnostic in swiotlb_exit())
  }
  
  /*
* Unmerged path kernel/dma/swiotlb.c
