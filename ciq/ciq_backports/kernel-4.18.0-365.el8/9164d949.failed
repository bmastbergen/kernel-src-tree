x86/cpu: Add get_llc_id() helper function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Kim Phillips <kim.phillips@amd.com>
commit 9164d9493a792682143af12b182be12d7c32b195
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/9164d949.failed

Factor out a helper function rather than export cpu_llc_id, which is
needed in order to be able to build the AMD uncore driver as a module.

	Signed-off-by: Kim Phillips <kim.phillips@amd.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
Link: https://lore.kernel.org/r/20210817221048.88063-7-kim.phillips@amd.com
(cherry picked from commit 9164d9493a792682143af12b182be12d7c32b195)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/processor.h
diff --cc arch/x86/include/asm/processor.h
index 36df2cabb7a7,33dd1575104e..000000000000
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@@ -861,23 -795,7 +861,27 @@@ extern int set_tsc_mode(unsigned int va
  
  DECLARE_PER_CPU(u64, msr_misc_features_shadow);
  
++<<<<<<< HEAD
 +/* Register/unregister a process' MPX related resource */
 +#define MPX_ENABLE_MANAGEMENT()	mpx_enable_management()
 +#define MPX_DISABLE_MANAGEMENT()	mpx_disable_management()
 +
 +#ifdef CONFIG_X86_INTEL_MPX
 +extern int mpx_enable_management(void);
 +extern int mpx_disable_management(void);
 +#else
 +static inline int mpx_enable_management(void)
 +{
 +	return -EINVAL;
 +}
 +static inline int mpx_disable_management(void)
 +{
 +	return -EINVAL;
 +}
 +#endif /* CONFIG_X86_INTEL_MPX */
++=======
+ extern u16 get_llc_id(unsigned int cpu);
++>>>>>>> 9164d9493a79 (x86/cpu: Add get_llc_id() helper function)
  
  #ifdef CONFIG_CPU_SUP_AMD
  extern u32 amd_get_nodes_per_socket(void);
diff --git a/arch/x86/events/amd/uncore.c b/arch/x86/events/amd/uncore.c
index 0bba508ee145..20c3a4412cd0 100644
--- a/arch/x86/events/amd/uncore.c
+++ b/arch/x86/events/amd/uncore.c
@@ -455,7 +455,7 @@ static int amd_uncore_cpu_starting(unsigned int cpu)
 
 	if (amd_uncore_llc) {
 		uncore = *per_cpu_ptr(amd_uncore_llc, cpu);
-		uncore->id = per_cpu(cpu_llc_id, cpu);
+		uncore->id = get_llc_id(cpu);
 
 		uncore = amd_uncore_find_online_sibling(uncore, amd_uncore_llc);
 		*per_cpu_ptr(amd_uncore_llc, cpu) = uncore;
* Unmerged path arch/x86/include/asm/processor.h
diff --git a/arch/x86/kernel/cpu/amd.c b/arch/x86/kernel/cpu/amd.c
index 6ca098a5282d..42cab669db36 100644
--- a/arch/x86/kernel/cpu/amd.c
+++ b/arch/x86/kernel/cpu/amd.c
@@ -442,7 +442,7 @@ static void srat_detect_node(struct cpuinfo_x86 *c)
 
 	node = numa_cpu_node(cpu);
 	if (node == NUMA_NO_NODE)
-		node = per_cpu(cpu_llc_id, cpu);
+		node = get_llc_id(cpu);
 
 	/*
 	 * On multi-fabric platform (e.g. Numascale NumaChip) a
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index 4a595b9d05fe..b2d0413043e2 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -78,6 +78,12 @@ EXPORT_SYMBOL(smp_num_siblings);
 /* Last level cache ID of each logical CPU */
 DEFINE_PER_CPU_READ_MOSTLY(u16, cpu_llc_id) = BAD_APICID;
 
+u16 get_llc_id(unsigned int cpu)
+{
+	return per_cpu(cpu_llc_id, cpu);
+}
+EXPORT_SYMBOL_GPL(get_llc_id);
+
 /* correctly size the local cpu masks */
 void __init setup_cpu_local_masks(void)
 {
