ice: fix rate limit update after coalesce change

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Jesse Brandeburg <jesse.brandeburg@intel.com>
commit d16a4f45f3a3afcb56910a7242cc621c071e80e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/d16a4f45.failed

If the adaptive settings are changed with
ethtool -C ethx adaptive-rx off adaptive-tx off
then the interrupt rate limit should be maintained as a user set value,
but only if BOTH adaptive settings are off. Fix a bug where the rate
limit that was being used in adaptive mode was staying set in the
register but was not reported correctly by ethtool -c ethx. Due to long
lines include a small refactor of q_vector variable.

Fixes: b8b4772377dd ("ice: refactor interrupt moderation writes")
	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Tested-by: Gurucharan G <gurucharanx.g@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit d16a4f45f3a3afcb56910a7242cc621c071e80e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_ethtool.c
diff --cc drivers/net/ethernet/intel/ice/ice_ethtool.c
index 805e30873479,f4b3c5b73c7d..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ethtool.c
+++ b/drivers/net/ethernet/intel/ice/ice_ethtool.c
@@@ -3638,17 -3651,14 +3641,26 @@@ ice_set_rc_coalesce(struct ethtool_coal
  				    ICE_MAX_INTRL);
  			return -EINVAL;
  		}
++<<<<<<< HEAD
 +		if (ec->rx_coalesce_usecs_high != rc->ring->q_vector->intrl &&
++=======
+ 		if (ec->rx_coalesce_usecs_high != q_vector->intrl &&
++>>>>>>> d16a4f45f3a3 (ice: fix rate limit update after coalesce change)
  		    (ec->use_adaptive_rx_coalesce || ec->use_adaptive_tx_coalesce)) {
  			netdev_info(vsi->netdev, "Invalid value, %s-usecs-high cannot be changed if adaptive-tx or adaptive-rx is enabled\n",
  				    c_type_str);
  			return -EINVAL;
  		}
++<<<<<<< HEAD
 +		if (ec->rx_coalesce_usecs_high != rc->ring->q_vector->intrl) {
 +			rc->ring->q_vector->intrl = ec->rx_coalesce_usecs_high;
 +			ice_write_intrl(rc->ring->q_vector,
 +					ec->rx_coalesce_usecs_high);
 +		}
++=======
+ 		if (ec->rx_coalesce_usecs_high != q_vector->intrl)
+ 			q_vector->intrl = ec->rx_coalesce_usecs_high;
++>>>>>>> d16a4f45f3a3 (ice: fix rate limit update after coalesce change)
  
  		use_adaptive_coalesce = ec->use_adaptive_rx_coalesce;
  		coalesce_usecs = ec->rx_coalesce_usecs;
* Unmerged path drivers/net/ethernet/intel/ice/ice_ethtool.c
diff --git a/drivers/net/ethernet/intel/ice/ice_lib.c b/drivers/net/ethernet/intel/ice/ice_lib.c
index 414dccdfaaac..97fff4d86fc2 100644
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@ -3036,7 +3036,7 @@ ice_vsi_rebuild_set_coalesce(struct ice_vsi *vsi,
 		}
 
 		vsi->q_vectors[i]->intrl = coalesce[i].intrl;
-		ice_write_intrl(vsi->q_vectors[i], coalesce[i].intrl);
+		ice_set_q_vector_intrl(vsi->q_vectors[i]);
 	}
 
 	/* the number of queue vectors increased so write whatever is in
@@ -3054,7 +3054,7 @@ ice_vsi_rebuild_set_coalesce(struct ice_vsi *vsi,
 		ice_write_itr(rc, rc->itr_setting);
 
 		vsi->q_vectors[i]->intrl = coalesce[0].intrl;
-		ice_write_intrl(vsi->q_vectors[i], coalesce[0].intrl);
+		ice_set_q_vector_intrl(vsi->q_vectors[i]);
 	}
 }
 
