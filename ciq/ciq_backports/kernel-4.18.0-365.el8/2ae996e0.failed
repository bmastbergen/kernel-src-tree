x86/fpu: Calculate the default sizes independently

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Chang S. Bae <chang.seok.bae@intel.com>
commit 2ae996e0c1a38ca57a52438ab9deec6761dcba62
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/2ae996e0.failed

When dynamically enabled states are supported the maximum and default sizes
for the kernel buffers and user space interfaces are not longer identical.

Put the necessary calculations in place which only take the default enabled
features into account.

	Signed-off-by: Chang S. Bae <chang.seok.bae@intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lore.kernel.org/r/20211021225527.10184-22-chang.seok.bae@intel.com
(cherry picked from commit 2ae996e0c1a38ca57a52438ab9deec6761dcba62)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/fpu/xstate.c
diff --cc arch/x86/kernel/fpu/xstate.c
index f744359fb635,b0f6e9a0cf2e..000000000000
--- a/arch/x86/kernel/fpu/xstate.c
+++ b/arch/x86/kernel/fpu/xstate.c
@@@ -724,8 -809,12 +728,17 @@@ static int __init init_xstate_size(void
  	if (!paranoid_xstate_size_valid(kernel_size))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	fpu_kernel_xstate_size = kernel_size;
 +	fpu_user_xstate_size = user_size;
++=======
+ 	fpu_kernel_cfg.max_size = kernel_size;
+ 	fpu_user_cfg.max_size = user_size;
+ 
+ 	fpu_kernel_cfg.default_size = kernel_default_size;
+ 	fpu_user_cfg.default_size =
+ 		xstate_calculate_size(fpu_user_cfg.default_features, false);
++>>>>>>> 2ae996e0c1a3 (x86/fpu: Calculate the default sizes independently)
  
  	return 0;
  }
@@@ -795,15 -892,31 +808,34 @@@ void __init fpu__init_system_xstate(voi
  	 * Clear XSAVE features that are disabled in the normal CPUID.
  	 */
  	for (i = 0; i < ARRAY_SIZE(xsave_cpuid_features); i++) {
 -		unsigned short cid = xsave_cpuid_features[i];
 -
 -		/* Careful: X86_FEATURE_FPU is 0! */
 -		if ((i != XFEATURE_FP && !cid) || !boot_cpu_has(cid))
 -			fpu_kernel_cfg.max_features &= ~BIT_ULL(i);
 +		if (!boot_cpu_has(xsave_cpuid_features[i]))
 +			xfeatures_mask_all &= ~BIT_ULL(i);
  	}
  
++<<<<<<< HEAD
 +	xfeatures_mask_all &= XFEATURE_MASK_USER_SUPPORTED |
 +			      XFEATURE_MASK_SUPERVISOR_SUPPORTED;
 +
++=======
+ 	if (!cpu_feature_enabled(X86_FEATURE_XFD))
+ 		fpu_kernel_cfg.max_features &= ~XFEATURE_MASK_USER_DYNAMIC;
+ 
+ 	fpu_kernel_cfg.max_features &= XFEATURE_MASK_USER_SUPPORTED |
+ 			      XFEATURE_MASK_SUPERVISOR_SUPPORTED;
+ 
+ 	fpu_user_cfg.max_features = fpu_kernel_cfg.max_features;
+ 	fpu_user_cfg.max_features &= XFEATURE_MASK_USER_SUPPORTED;
+ 
+ 	/* Clean out dynamic features from default */
+ 	fpu_kernel_cfg.default_features = fpu_kernel_cfg.max_features;
+ 	fpu_kernel_cfg.default_features &= ~XFEATURE_MASK_USER_DYNAMIC;
+ 
+ 	fpu_user_cfg.default_features = fpu_user_cfg.max_features;
+ 	fpu_user_cfg.default_features &= ~XFEATURE_MASK_USER_DYNAMIC;
+ 
++>>>>>>> 2ae996e0c1a3 (x86/fpu: Calculate the default sizes independently)
  	/* Store it for paranoia check at the end */
 -	xfeatures = fpu_kernel_cfg.max_features;
 +	xfeatures = xfeatures_mask_all;
  
  	/* Enable xstate instructions to be able to continue with initialization: */
  	fpu__init_cpu_xstate();
@@@ -811,6 -924,9 +843,12 @@@
  	if (err)
  		goto out_disable;
  
++<<<<<<< HEAD
++=======
+ 	/* Reset the state for the current task */
+ 	fpstate_reset(&current->thread.fpu);
+ 
++>>>>>>> 2ae996e0c1a3 (x86/fpu: Calculate the default sizes independently)
  	/*
  	 * Update info used for ptrace frames; use standard-format size and no
  	 * supervisor xstates:
* Unmerged path arch/x86/kernel/fpu/xstate.c
