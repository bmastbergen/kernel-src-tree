bnxt_en: Event handler for PPS events

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Pavan Chebbi <pavan.chebbi@broadcom.com>
commit 099fdeda659d2071a97753a6479d13342ff2b285
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/099fdeda.failed

Once the PPS pins are configured, the FW can report
PPS values using ASYNC event. This patch adds the
ASYNC event handler and subsequent reporting of the
events to kernel.

	Signed-off-by: Pavan Chebbi <pavan.chebbi@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 099fdeda659d2071a97753a6479d13342ff2b285)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt_ptp.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt_ptp.h
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_ptp.c
index 5b51c9e0464e,e33e311e2341..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ptp.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ptp.c
@@@ -155,10 -155,207 +155,165 @@@ static int bnxt_ptp_adjfreq(struct ptp_
  	return rc;
  }
  
++<<<<<<< HEAD
 +static int bnxt_ptp_enable(struct ptp_clock_info *ptp,
++=======
+ void bnxt_ptp_pps_event(struct bnxt *bp, u32 data1, u32 data2)
+ {
+ 	struct bnxt_ptp_cfg *ptp = bp->ptp_cfg;
+ 	struct ptp_clock_event event;
+ 	u64 ns, pps_ts;
+ 
+ 	pps_ts = EVENT_PPS_TS(data2, data1);
+ 	spin_lock_bh(&ptp->ptp_lock);
+ 	ns = timecounter_cyc2time(&ptp->tc, pps_ts);
+ 	spin_unlock_bh(&ptp->ptp_lock);
+ 
+ 	switch (EVENT_DATA2_PPS_EVENT_TYPE(data2)) {
+ 	case ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE_INTERNAL:
+ 		event.pps_times.ts_real = ns_to_timespec64(ns);
+ 		event.type = PTP_CLOCK_PPSUSR;
+ 		event.index = EVENT_DATA2_PPS_PIN_NUM(data2);
+ 		break;
+ 	case ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE_EXTERNAL:
+ 		event.timestamp = ns;
+ 		event.type = PTP_CLOCK_EXTTS;
+ 		event.index = EVENT_DATA2_PPS_PIN_NUM(data2);
+ 		break;
+ 	}
+ 
+ 	ptp_clock_event(bp->ptp_cfg->ptp_clock, &event);
+ }
+ 
+ static int bnxt_ptp_cfg_pin(struct bnxt *bp, u8 pin, u8 usage)
+ {
+ 	struct hwrm_func_ptp_pin_cfg_input req = {0};
+ 	struct bnxt_ptp_cfg *ptp = bp->ptp_cfg;
+ 	u8 state = usage != BNXT_PPS_PIN_NONE;
+ 	u8 *pin_state, *pin_usg;
+ 	u32 enables;
+ 	int rc;
+ 
+ 	if (!TSIO_PIN_VALID(pin)) {
+ 		netdev_err(ptp->bp->dev, "1PPS: Invalid pin. Check pin-function configuration\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_FUNC_PTP_PIN_CFG, -1, -1);
+ 	enables = (FUNC_PTP_PIN_CFG_REQ_ENABLES_PIN0_STATE |
+ 		   FUNC_PTP_PIN_CFG_REQ_ENABLES_PIN0_USAGE) << (pin * 2);
+ 	req.enables = cpu_to_le32(enables);
+ 
+ 	pin_state = &req.pin0_state;
+ 	pin_usg = &req.pin0_usage;
+ 
+ 	*(pin_state + (pin * 2)) = state;
+ 	*(pin_usg + (pin * 2)) = usage;
+ 
+ 	rc = hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ 	if (rc)
+ 		return rc;
+ 
+ 	ptp->pps_info.pins[pin].usage = usage;
+ 	ptp->pps_info.pins[pin].state = state;
+ 
+ 	return 0;
+ }
+ 
+ static int bnxt_ptp_cfg_event(struct bnxt *bp, u8 event)
+ {
+ 	struct hwrm_func_ptp_cfg_input req = {0};
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_FUNC_PTP_CFG, -1, -1);
+ 	req.enables = cpu_to_le16(FUNC_PTP_CFG_REQ_ENABLES_PTP_PPS_EVENT);
+ 	req.ptp_pps_event = event;
+ 	return hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ }
+ 
+ void bnxt_ptp_reapply_pps(struct bnxt *bp)
+ {
+ 	struct bnxt_ptp_cfg *ptp = bp->ptp_cfg;
+ 	struct bnxt_pps *pps;
+ 	u32 pin = 0;
+ 	int rc;
+ 
+ 	if (!ptp || !(bp->fw_cap & BNXT_FW_CAP_PTP_PPS) ||
+ 	    !(ptp->ptp_info.pin_config))
+ 		return;
+ 	pps = &ptp->pps_info;
+ 	for (pin = 0; pin < BNXT_MAX_TSIO_PINS; pin++) {
+ 		if (pps->pins[pin].state) {
+ 			rc = bnxt_ptp_cfg_pin(bp, pin, pps->pins[pin].usage);
+ 			if (!rc && pps->pins[pin].event)
+ 				rc = bnxt_ptp_cfg_event(bp,
+ 							pps->pins[pin].event);
+ 			if (rc)
+ 				netdev_err(bp->dev, "1PPS: Failed to configure pin%d\n",
+ 					   pin);
+ 		}
+ 	}
+ }
+ 
+ static int bnxt_get_target_cycles(struct bnxt_ptp_cfg *ptp, u64 target_ns,
+ 				  u64 *cycles_delta)
+ {
+ 	u64 cycles_now;
+ 	u64 nsec_now, nsec_delta;
+ 	int rc;
+ 
+ 	spin_lock_bh(&ptp->ptp_lock);
+ 	rc = bnxt_refclk_read(ptp->bp, NULL, &cycles_now);
+ 	if (rc) {
+ 		spin_unlock_bh(&ptp->ptp_lock);
+ 		return rc;
+ 	}
+ 	nsec_now = timecounter_cyc2time(&ptp->tc, cycles_now);
+ 	spin_unlock_bh(&ptp->ptp_lock);
+ 
+ 	nsec_delta = target_ns - nsec_now;
+ 	*cycles_delta = div64_u64(nsec_delta << ptp->cc.shift, ptp->cc.mult);
+ 	return 0;
+ }
+ 
+ static int bnxt_ptp_perout_cfg(struct bnxt_ptp_cfg *ptp,
+ 			       struct ptp_clock_request *rq)
+ {
+ 	struct hwrm_func_ptp_cfg_input req = {0};
+ 	struct bnxt *bp = ptp->bp;
+ 	struct timespec64 ts;
+ 	u64 target_ns, delta;
+ 	u16 enables;
+ 	int rc;
+ 
+ 	ts.tv_sec = rq->perout.start.sec;
+ 	ts.tv_nsec = rq->perout.start.nsec;
+ 	target_ns = timespec64_to_ns(&ts);
+ 
+ 	rc = bnxt_get_target_cycles(ptp, target_ns, &delta);
+ 	if (rc)
+ 		return rc;
+ 
+ 	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_FUNC_PTP_CFG, -1, -1);
+ 
+ 	enables = FUNC_PTP_CFG_REQ_ENABLES_PTP_FREQ_ADJ_EXT_PERIOD |
+ 		  FUNC_PTP_CFG_REQ_ENABLES_PTP_FREQ_ADJ_EXT_UP |
+ 		  FUNC_PTP_CFG_REQ_ENABLES_PTP_FREQ_ADJ_EXT_PHASE;
+ 	req.enables = cpu_to_le16(enables);
+ 	req.ptp_pps_event = 0;
+ 	req.ptp_freq_adj_dll_source = 0;
+ 	req.ptp_freq_adj_dll_phase = 0;
+ 	req.ptp_freq_adj_ext_period = cpu_to_le32(NSEC_PER_SEC);
+ 	req.ptp_freq_adj_ext_up = 0;
+ 	req.ptp_freq_adj_ext_phase_lower = cpu_to_le32(delta);
+ 
+ 	return hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ }
+ 
+ static int bnxt_ptp_enable(struct ptp_clock_info *ptp_info,
++>>>>>>> 099fdeda659d (bnxt_en: Event handler for PPS events)
  			   struct ptp_clock_request *rq, int on)
  {
 -	struct bnxt_ptp_cfg *ptp = container_of(ptp_info, struct bnxt_ptp_cfg,
 -						ptp_info);
 -	struct bnxt *bp = ptp->bp;
 -	u8 pin_id;
 -	int rc;
 -
 -	switch (rq->type) {
 -	case PTP_CLK_REQ_EXTTS:
 -		/* Configure an External PPS IN */
 -		pin_id = ptp_find_pin(ptp->ptp_clock, PTP_PF_EXTTS,
 -				      rq->extts.index);
 -		if (!on)
 -			break;
 -		rc = bnxt_ptp_cfg_pin(bp, pin_id, BNXT_PPS_PIN_PPS_IN);
 -		if (rc)
 -			return rc;
 -		rc = bnxt_ptp_cfg_event(bp, BNXT_PPS_EVENT_EXTERNAL);
 -		if (!rc)
 -			ptp->pps_info.pins[pin_id].event = BNXT_PPS_EVENT_EXTERNAL;
 -		return rc;
 -	case PTP_CLK_REQ_PEROUT:
 -		/* Configure a Periodic PPS OUT */
 -		pin_id = ptp_find_pin(ptp->ptp_clock, PTP_PF_PEROUT,
 -				      rq->perout.index);
 -		if (!on)
 -			break;
 -
 -		rc = bnxt_ptp_cfg_pin(bp, pin_id, BNXT_PPS_PIN_PPS_OUT);
 -		if (!rc)
 -			rc = bnxt_ptp_perout_cfg(ptp, rq);
 -
 -		return rc;
 -	case PTP_CLK_REQ_PPS:
 -		/* Configure PHC PPS IN */
 -		rc = bnxt_ptp_cfg_pin(bp, 0, BNXT_PPS_PIN_PPS_IN);
 -		if (rc)
 -			return rc;
 -		rc = bnxt_ptp_cfg_event(bp, BNXT_PPS_EVENT_INTERNAL);
 -		if (!rc)
 -			ptp->pps_info.pins[0].event = BNXT_PPS_EVENT_INTERNAL;
 -		return rc;
 -	default:
 -		netdev_err(ptp->bp->dev, "Unrecognized PIN function\n");
 -		return -EOPNOTSUPP;
 -	}
 -
 -	return bnxt_ptp_cfg_pin(bp, pin_id, BNXT_PPS_PIN_NONE);
 +	return -EOPNOTSUPP;
  }
  
  static int bnxt_hwrm_ptp_cfg(struct bnxt *bp)
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_ptp.h
index 619a6a1bf9fa,88923346ab50..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ptp.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ptp.h
@@@ -22,9 -22,38 +22,39 @@@
  				 PORT_TS_QUERY_REQ_ENABLES_TS_REQ_TIMEOUT)
  
  struct pps_pin {
 -	u8 event;
  	u8 usage;
 -	u8 state;
  };
  
++<<<<<<< HEAD
++=======
+ #define TSIO_PIN_VALID(pin) ((pin) < (BNXT_MAX_TSIO_PINS))
+ 
+ #define EVENT_DATA2_PPS_EVENT_TYPE(data2)				\
+ 	((data2) & ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE)
+ 
+ #define EVENT_DATA2_PPS_PIN_NUM(data2)					\
+ 	(((data2) &							\
+ 	  ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_PIN_NUMBER_MASK) >>\
+ 	 ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_PIN_NUMBER_SFT)
+ 
+ #define BNXT_DATA2_UPPER_MSK						\
+ 	ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_PPS_TIMESTAMP_UPPER_MASK
+ 
+ #define BNXT_DATA2_UPPER_SFT						\
+ 	(32 -								\
+ 	 ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_PPS_TIMESTAMP_UPPER_SFT)
+ 
+ #define BNXT_DATA1_LOWER_MSK						\
+ 	ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA1_PPS_TIMESTAMP_LOWER_MASK
+ 
+ #define BNXT_DATA1_LOWER_SFT						\
+ 	  ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA1_PPS_TIMESTAMP_LOWER_SFT
+ 
+ #define EVENT_PPS_TS(data2, data1)					\
+ 	(((u64)((data2) & BNXT_DATA2_UPPER_MSK) << BNXT_DATA2_UPPER_SFT) |\
+ 	 (((data1) & BNXT_DATA1_LOWER_MSK) >> BNXT_DATA1_LOWER_SFT))
+ 
++>>>>>>> 099fdeda659d (bnxt_en: Event handler for PPS events)
  #define BNXT_PPS_PIN_DISABLE	0
  #define BNXT_PPS_PIN_ENABLE	1
  #define BNXT_PPS_PIN_NONE	0
@@@ -93,6 -122,8 +123,11 @@@ do {						
  #endif
  
  int bnxt_ptp_parse(struct sk_buff *skb, u16 *seq_id);
++<<<<<<< HEAD
++=======
+ void bnxt_ptp_pps_event(struct bnxt *bp, u32 data1, u32 data2);
+ void bnxt_ptp_reapply_pps(struct bnxt *bp);
++>>>>>>> 099fdeda659d (bnxt_en: Event handler for PPS events)
  int bnxt_hwtstamp_set(struct net_device *dev, struct ifreq *ifr);
  int bnxt_hwtstamp_get(struct net_device *dev, struct ifreq *ifr);
  int bnxt_get_tx_ts_p5(struct bnxt *bp, struct sk_buff *skb);
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
index df2601759f4a..16e07a80f1af 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -278,6 +278,7 @@ static const u16 bnxt_async_events_arr[] = {
 	ASYNC_EVENT_CMPL_EVENT_ID_DEBUG_NOTIFICATION,
 	ASYNC_EVENT_CMPL_EVENT_ID_RING_MONITOR_MSG,
 	ASYNC_EVENT_CMPL_EVENT_ID_ECHO_REQUEST,
+	ASYNC_EVENT_CMPL_EVENT_ID_PPS_TIMESTAMP,
 };
 
 static struct workqueue_struct *bnxt_pf_wq;
@@ -2203,6 +2204,10 @@ static int bnxt_async_event_process(struct bnxt *bp,
 		}
 		goto async_event_process_exit;
 	}
+	case ASYNC_EVENT_CMPL_EVENT_ID_PPS_TIMESTAMP: {
+		bnxt_ptp_pps_event(bp, data1, data2);
+		goto async_event_process_exit;
+	}
 	default:
 		goto async_event_process_exit;
 	}
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_ptp.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_ptp.h
