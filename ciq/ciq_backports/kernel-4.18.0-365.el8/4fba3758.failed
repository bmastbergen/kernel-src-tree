kasan: move kasan_report() into report.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Andrey Konovalov <andreyknvl@google.com>
commit 4fba37586e4e73f9f9a855e610e151ef7da2b481
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/4fba3758.failed

The kasan_report() functions belongs to report.c, as it's a common
functions that does error reporting.

	Reported-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Tested-by: Leon Romanovsky <leon@kernel.org>
	Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: Alexander Potapenko <glider@google.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: Leon Romanovsky <leonro@mellanox.com>
Link: http://lkml.kernel.org/r/78a81fde6eeda9db72a7fd55fbc33173a515e4b1.1589297433.git.andreyknvl@google.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 4fba37586e4e73f9f9a855e610e151ef7da2b481)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/kasan/report.c
diff --cc mm/kasan/report.c
index 867299adf9a2,51ec45407a0b..000000000000
--- a/mm/kasan/report.c
+++ b/mm/kasan/report.c
@@@ -517,3 -519,59 +519,62 @@@ static void __kasan_report(unsigned lon
  
  	end_report(&flags);
  }
++<<<<<<< HEAD
++=======
+ 
+ bool kasan_report(unsigned long addr, size_t size, bool is_write,
+ 			unsigned long ip)
+ {
+ 	unsigned long flags = user_access_save();
+ 	bool ret = false;
+ 
+ 	if (likely(report_enabled())) {
+ 		__kasan_report(addr, size, is_write, ip);
+ 		ret = true;
+ 	}
+ 
+ 	user_access_restore(flags);
+ 
+ 	return ret;
+ }
+ 
+ #ifdef CONFIG_KASAN_INLINE
+ /*
+  * With CONFIG_KASAN_INLINE, accesses to bogus pointers (outside the high
+  * canonical half of the address space) cause out-of-bounds shadow memory reads
+  * before the actual access. For addresses in the low canonical half of the
+  * address space, as well as most non-canonical addresses, that out-of-bounds
+  * shadow memory access lands in the non-canonical part of the address space.
+  * Help the user figure out what the original bogus pointer was.
+  */
+ void kasan_non_canonical_hook(unsigned long addr)
+ {
+ 	unsigned long orig_addr;
+ 	const char *bug_type;
+ 
+ 	if (addr < KASAN_SHADOW_OFFSET)
+ 		return;
+ 
+ 	orig_addr = (addr - KASAN_SHADOW_OFFSET) << KASAN_SHADOW_SCALE_SHIFT;
+ 	/*
+ 	 * For faults near the shadow address for NULL, we can be fairly certain
+ 	 * that this is a KASAN shadow memory access.
+ 	 * For faults that correspond to shadow for low canonical addresses, we
+ 	 * can still be pretty sure - that shadow region is a fairly narrow
+ 	 * chunk of the non-canonical address space.
+ 	 * But faults that look like shadow for non-canonical addresses are a
+ 	 * really large chunk of the address space. In that case, we still
+ 	 * print the decoded address, but make it clear that this is not
+ 	 * necessarily what's actually going on.
+ 	 */
+ 	if (orig_addr < PAGE_SIZE)
+ 		bug_type = "null-ptr-deref";
+ 	else if (orig_addr < TASK_SIZE)
+ 		bug_type = "probably user-memory-access";
+ 	else
+ 		bug_type = "maybe wild-memory-access";
+ 	pr_alert("KASAN: %s in range [0x%016lx-0x%016lx]\n", bug_type,
+ 		 orig_addr, orig_addr + KASAN_SHADOW_MASK);
+ }
+ #endif
++>>>>>>> 4fba37586e4e (kasan: move kasan_report() into report.c)
diff --git a/mm/kasan/common.c b/mm/kasan/common.c
index ebb081aceddc..c337daadca30 100644
--- a/mm/kasan/common.c
+++ b/mm/kasan/common.c
@@ -34,7 +34,6 @@
 #include <linux/types.h>
 #include <linux/vmalloc.h>
 #include <linux/bug.h>
-#include <linux/uaccess.h>
 
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
@@ -618,24 +617,6 @@ void kasan_free_shadow(const struct vm_struct *vm)
 }
 #endif
 
-extern void __kasan_report(unsigned long addr, size_t size, bool is_write, unsigned long ip);
-extern bool report_enabled(void);
-
-bool kasan_report(unsigned long addr, size_t size, bool is_write, unsigned long ip)
-{
-	unsigned long flags = user_access_save();
-	bool ret = false;
-
-	if (likely(report_enabled())) {
-		__kasan_report(addr, size, is_write, ip);
-		ret = true;
-	}
-
-	user_access_restore(flags);
-
-	return ret;
-}
-
 #ifdef CONFIG_MEMORY_HOTPLUG
 static bool shadow_mapped(unsigned long addr)
 {
* Unmerged path mm/kasan/report.c
