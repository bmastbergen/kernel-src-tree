swiotlb: Update is_swiotlb_active to add a struct device argument

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-365.el8
commit-author Claire Chang <tientzu@chromium.org>
commit 6f2beb268a5d35504a636c4a3b7aaa76ec32d96c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-365.el8/6f2beb26.failed

Update is_swiotlb_active to add a struct device argument. This will be
useful later to allow for different pools.

	Signed-off-by: Claire Chang <tientzu@chromium.org>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Tested-by: Stefano Stabellini <sstabellini@kernel.org>
	Tested-by: Will Deacon <will@kernel.org>
	Acked-by: Stefano Stabellini <sstabellini@kernel.org>
	Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
(cherry picked from commit 6f2beb268a5d35504a636c4a3b7aaa76ec32d96c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/gem/i915_gem_internal.c
#	drivers/gpu/drm/nouveau/nouveau_ttm.c
#	drivers/pci/xen-pcifront.c
#	include/linux/swiotlb.h
#	kernel/dma/swiotlb.c
diff --cc drivers/gpu/drm/i915/gem/i915_gem_internal.c
index ad22f42541bd,89a894354263..000000000000
--- a/drivers/gpu/drm/i915/gem/i915_gem_internal.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_internal.c
@@@ -42,7 -42,7 +42,11 @@@ static int i915_gem_object_get_pages_in
  
  	max_order = MAX_ORDER;
  #ifdef CONFIG_SWIOTLB
++<<<<<<< HEAD
 +	if (swiotlb_nr_tbl()) {
++=======
+ 	if (is_swiotlb_active(obj->base.dev->dev)) {
++>>>>>>> 6f2beb268a5d (swiotlb: Update is_swiotlb_active to add a struct device argument)
  		unsigned int max_segment;
  
  		max_segment = swiotlb_max_segment();
diff --cc drivers/gpu/drm/nouveau/nouveau_ttm.c
index a37bc3d7b38b,2ca9d9a9e5d5..000000000000
--- a/drivers/gpu/drm/nouveau/nouveau_ttm.c
+++ b/drivers/gpu/drm/nouveau/nouveau_ttm.c
@@@ -321,13 -276,13 +321,17 @@@ nouveau_ttm_init(struct nouveau_drm *dr
  	}
  
  #if IS_ENABLED(CONFIG_SWIOTLB) && IS_ENABLED(CONFIG_X86)
++<<<<<<< HEAD
 +	need_swiotlb = !!swiotlb_nr_tbl();
++=======
+ 	need_swiotlb = is_swiotlb_active(dev->dev);
++>>>>>>> 6f2beb268a5d (swiotlb: Update is_swiotlb_active to add a struct device argument)
  #endif
  
 -	ret = ttm_device_init(&drm->ttm.bdev, &nouveau_bo_driver, drm->dev->dev,
 -				  dev->anon_inode->i_mapping,
 -				  dev->vma_offset_manager, need_swiotlb,
 -				  drm->client.mmu.dmabits <= 32);
 +	ret = ttm_bo_device_init(&drm->ttm.bdev, &nouveau_bo_driver,
 +				 drm->dev->dev, dev->anon_inode->i_mapping,
 +				 dev->vma_offset_manager, need_swiotlb,
 +				 drm->client.mmu.dmabits <= 32);
  	if (ret) {
  		NV_ERROR(drm, "error initialising bo driver, %d\n", ret);
  		return ret;
diff --cc drivers/pci/xen-pcifront.c
index d1b16cf3403f,0d56985bfe81..000000000000
--- a/drivers/pci/xen-pcifront.c
+++ b/drivers/pci/xen-pcifront.c
@@@ -699,7 -693,7 +699,11 @@@ static int pcifront_connect_and_init_dm
  
  	spin_unlock(&pcifront_dev_lock);
  
++<<<<<<< HEAD
 +	if (!err && !swiotlb_nr_tbl()) {
++=======
+ 	if (!err && !is_swiotlb_active(&pdev->xdev->dev)) {
++>>>>>>> 6f2beb268a5d (swiotlb: Update is_swiotlb_active to add a struct device argument)
  		err = pci_xen_swiotlb_init_late();
  		if (err)
  			dev_err(&pdev->xdev->dev, "Could not setup SWIOTLB!\n");
diff --cc include/linux/swiotlb.h
index 5857a937c637,dd1c30a83058..000000000000
--- a/include/linux/swiotlb.h
+++ b/include/linux/swiotlb.h
@@@ -81,11 -112,11 +81,16 @@@ static inline bool is_swiotlb_buffer(ph
  void __init swiotlb_exit(void);
  unsigned int swiotlb_max_segment(void);
  size_t swiotlb_max_mapping_size(struct device *dev);
++<<<<<<< HEAD
 +bool is_swiotlb_active(void);
 +void __init swiotlb_adjust_size(unsigned long new_size);
++=======
+ bool is_swiotlb_active(struct device *dev);
+ void __init swiotlb_adjust_size(unsigned long size);
++>>>>>>> 6f2beb268a5d (swiotlb: Update is_swiotlb_active to add a struct device argument)
  #else
  #define swiotlb_force SWIOTLB_NO_FORCE
 -static inline bool is_swiotlb_buffer(struct device *dev, phys_addr_t paddr)
 +static inline bool is_swiotlb_buffer(phys_addr_t paddr)
  {
  	return false;
  }
diff --cc kernel/dma/swiotlb.c
index be0e4e04c6fd,d8677d6637dd..000000000000
--- a/kernel/dma/swiotlb.c
+++ b/kernel/dma/swiotlb.c
@@@ -796,24 -662,30 +796,28 @@@ size_t swiotlb_max_mapping_size(struct 
  	return ((size_t)IO_TLB_SIZE) * IO_TLB_SEGSIZE;
  }
  
- bool is_swiotlb_active(void)
+ bool is_swiotlb_active(struct device *dev)
  {
++<<<<<<< HEAD
 +	/*
 +	 * When SWIOTLB is initialized, even if io_tlb_start points to physical
 +	 * address zero, io_tlb_end surely doesn't.
 +	 */
 +	return io_tlb_end != 0;
++=======
+ 	return dev->dma_io_tlb_mem != NULL;
++>>>>>>> 6f2beb268a5d (swiotlb: Update is_swiotlb_active to add a struct device argument)
  }
 -EXPORT_SYMBOL_GPL(is_swiotlb_active);
  
  #ifdef CONFIG_DEBUG_FS
 -static struct dentry *debugfs_dir;
  
 -static void swiotlb_create_debugfs_files(struct io_tlb_mem *mem)
 +static int __init swiotlb_create_debugfs(void)
  {
 -	debugfs_create_ulong("io_tlb_nslabs", 0400, mem->debugfs, &mem->nslabs);
 -	debugfs_create_ulong("io_tlb_used", 0400, mem->debugfs, &mem->used);
 -}
 -
 -static int __init swiotlb_create_default_debugfs(void)
 -{
 -	struct io_tlb_mem *mem = io_tlb_default_mem;
 +	struct dentry *root;
  
 -	debugfs_dir = debugfs_create_dir("swiotlb", NULL);
 -	if (mem) {
 -		mem->debugfs = debugfs_dir;
 -		swiotlb_create_debugfs_files(mem);
 -	}
 +	root = debugfs_create_dir("swiotlb", NULL);
 +	debugfs_create_ulong("io_tlb_nslabs", 0400, root, &io_tlb_nslabs);
 +	debugfs_create_ulong("io_tlb_used", 0400, root, &io_tlb_used);
  	return 0;
  }
  
* Unmerged path drivers/gpu/drm/i915/gem/i915_gem_internal.c
* Unmerged path drivers/gpu/drm/nouveau/nouveau_ttm.c
* Unmerged path drivers/pci/xen-pcifront.c
* Unmerged path include/linux/swiotlb.h
diff --git a/kernel/dma/direct.c b/kernel/dma/direct.c
index 7d488b64b9de..249e22decbef 100644
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@ -487,7 +487,7 @@ int dma_direct_supported(struct device *dev, u64 mask)
 size_t dma_direct_max_mapping_size(struct device *dev)
 {
 	/* If SWIOTLB is active, use its maximum mapping size */
-	if (is_swiotlb_active() &&
+	if (is_swiotlb_active(dev) &&
 	    (dma_addressing_limited(dev) || swiotlb_force == SWIOTLB_FORCE))
 		return swiotlb_max_mapping_size(dev);
 	return SIZE_MAX;
* Unmerged path kernel/dma/swiotlb.c
