powerpc/rtas: Fix typo of ibm,open-errinjct in RTAS filter

jira LE-1907
cve CVE-2020-27777
Rebuild_History Non-Buildable kernel-3.10.0-1160.41.1.el7
commit-author Tyrel Datwyler <tyreld@linux.ibm.com>
commit f10881a46f8914428110d110140a455c66bdf27b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.41.1.el7/f10881a4.failed

Commit bd59380c5ba4 ("powerpc/rtas: Restrict RTAS requests from userspace")
introduced the following error when invoking the errinjct userspace
tool:

  [root@ltcalpine2-lp5 librtas]# errinjct open
  [327884.071171] sys_rtas: RTAS call blocked - exploit attempt?
  [327884.071186] sys_rtas: token=0x26, nargs=0 (called by errinjct)
  errinjct: Could not open RTAS error injection facility
  errinjct: librtas: open: Unexpected I/O error

The entry for ibm,open-errinjct in rtas_filter array has a typo where
the "j" is omitted in the rtas call name. After fixing this typo the
errinjct tool functions again as expected.

  [root@ltcalpine2-lp5 linux]# errinjct open
  RTAS error injection facility open, token = 1

Fixes: bd59380c5ba4 ("powerpc/rtas: Restrict RTAS requests from userspace")
	Cc: stable@vger.kernel.org
	Signed-off-by: Tyrel Datwyler <tyreld@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20201208195434.8289-1-tyreld@linux.ibm.com
(cherry picked from commit f10881a46f8914428110d110140a455c66bdf27b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/rtas.c
diff --cc arch/powerpc/kernel/rtas.c
index d584a8a52bc6,d126d71ea5bd..000000000000
--- a/arch/powerpc/kernel/rtas.c
+++ b/arch/powerpc/kernel/rtas.c
@@@ -1045,8 -919,151 +1045,154 @@@ struct pseries_errorlog *get_pseries_er
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PPC_RTAS_FILTER
+ 
+ /*
+  * The sys_rtas syscall, as originally designed, allows root to pass
+  * arbitrary physical addresses to RTAS calls. A number of RTAS calls
+  * can be abused to write to arbitrary memory and do other things that
+  * are potentially harmful to system integrity, and thus should only
+  * be used inside the kernel and not exposed to userspace.
+  *
+  * All known legitimate users of the sys_rtas syscall will only ever
+  * pass addresses that fall within the RMO buffer, and use a known
+  * subset of RTAS calls.
+  *
+  * Accordingly, we filter RTAS requests to check that the call is
+  * permitted, and that provided pointers fall within the RMO buffer.
+  * The rtas_filters list contains an entry for each permitted call,
+  * with the indexes of the parameters which are expected to contain
+  * addresses and sizes of buffers allocated inside the RMO buffer.
+  */
+ struct rtas_filter {
+ 	const char *name;
+ 	int token;
+ 	/* Indexes into the args buffer, -1 if not used */
+ 	int buf_idx1;
+ 	int size_idx1;
+ 	int buf_idx2;
+ 	int size_idx2;
+ 
+ 	int fixed_size;
+ };
+ 
+ static struct rtas_filter rtas_filters[] __ro_after_init = {
+ 	{ "ibm,activate-firmware", -1, -1, -1, -1, -1 },
+ 	{ "ibm,configure-connector", -1, 0, -1, 1, -1, 4096 },	/* Special cased */
+ 	{ "display-character", -1, -1, -1, -1, -1 },
+ 	{ "ibm,display-message", -1, 0, -1, -1, -1 },
+ 	{ "ibm,errinjct", -1, 2, -1, -1, -1, 1024 },
+ 	{ "ibm,close-errinjct", -1, -1, -1, -1, -1 },
+ 	{ "ibm,open-errinjct", -1, -1, -1, -1, -1 },
+ 	{ "ibm,get-config-addr-info2", -1, -1, -1, -1, -1 },
+ 	{ "ibm,get-dynamic-sensor-state", -1, 1, -1, -1, -1 },
+ 	{ "ibm,get-indices", -1, 2, 3, -1, -1 },
+ 	{ "get-power-level", -1, -1, -1, -1, -1 },
+ 	{ "get-sensor-state", -1, -1, -1, -1, -1 },
+ 	{ "ibm,get-system-parameter", -1, 1, 2, -1, -1 },
+ 	{ "get-time-of-day", -1, -1, -1, -1, -1 },
+ 	{ "ibm,get-vpd", -1, 0, -1, 1, 2 },
+ 	{ "ibm,lpar-perftools", -1, 2, 3, -1, -1 },
+ 	{ "ibm,platform-dump", -1, 4, 5, -1, -1 },
+ 	{ "ibm,read-slot-reset-state", -1, -1, -1, -1, -1 },
+ 	{ "ibm,scan-log-dump", -1, 0, 1, -1, -1 },
+ 	{ "ibm,set-dynamic-indicator", -1, 2, -1, -1, -1 },
+ 	{ "ibm,set-eeh-option", -1, -1, -1, -1, -1 },
+ 	{ "set-indicator", -1, -1, -1, -1, -1 },
+ 	{ "set-power-level", -1, -1, -1, -1, -1 },
+ 	{ "set-time-for-power-on", -1, -1, -1, -1, -1 },
+ 	{ "ibm,set-system-parameter", -1, 1, -1, -1, -1 },
+ 	{ "set-time-of-day", -1, -1, -1, -1, -1 },
+ #ifdef CONFIG_CPU_BIG_ENDIAN
+ 	{ "ibm,suspend-me", -1, -1, -1, -1, -1 },
+ 	{ "ibm,update-nodes", -1, 0, -1, -1, -1, 4096 },
+ 	{ "ibm,update-properties", -1, 0, -1, -1, -1, 4096 },
+ #endif
+ 	{ "ibm,physical-attestation", -1, 0, 1, -1, -1 },
+ };
+ 
+ static bool in_rmo_buf(u32 base, u32 end)
+ {
+ 	return base >= rtas_rmo_buf &&
+ 		base < (rtas_rmo_buf + RTAS_RMOBUF_MAX) &&
+ 		base <= end &&
+ 		end >= rtas_rmo_buf &&
+ 		end < (rtas_rmo_buf + RTAS_RMOBUF_MAX);
+ }
+ 
+ static bool block_rtas_call(int token, int nargs,
+ 			    struct rtas_args *args)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(rtas_filters); i++) {
+ 		struct rtas_filter *f = &rtas_filters[i];
+ 		u32 base, size, end;
+ 
+ 		if (token != f->token)
+ 			continue;
+ 
+ 		if (f->buf_idx1 != -1) {
+ 			base = be32_to_cpu(args->args[f->buf_idx1]);
+ 			if (f->size_idx1 != -1)
+ 				size = be32_to_cpu(args->args[f->size_idx1]);
+ 			else if (f->fixed_size)
+ 				size = f->fixed_size;
+ 			else
+ 				size = 1;
+ 
+ 			end = base + size - 1;
+ 			if (!in_rmo_buf(base, end))
+ 				goto err;
+ 		}
+ 
+ 		if (f->buf_idx2 != -1) {
+ 			base = be32_to_cpu(args->args[f->buf_idx2]);
+ 			if (f->size_idx2 != -1)
+ 				size = be32_to_cpu(args->args[f->size_idx2]);
+ 			else if (f->fixed_size)
+ 				size = f->fixed_size;
+ 			else
+ 				size = 1;
+ 			end = base + size - 1;
+ 
+ 			/*
+ 			 * Special case for ibm,configure-connector where the
+ 			 * address can be 0
+ 			 */
+ 			if (!strcmp(f->name, "ibm,configure-connector") &&
+ 			    base == 0)
+ 				return false;
+ 
+ 			if (!in_rmo_buf(base, end))
+ 				goto err;
+ 		}
+ 
+ 		return false;
+ 	}
+ 
+ err:
+ 	pr_err_ratelimited("sys_rtas: RTAS call blocked - exploit attempt?\n");
+ 	pr_err_ratelimited("sys_rtas: token=0x%x, nargs=%d (called by %s)\n",
+ 			   token, nargs, current->comm);
+ 	return true;
+ }
+ 
+ #else
+ 
+ static bool block_rtas_call(int token, int nargs,
+ 			    struct rtas_args *args)
+ {
+ 	return false;
+ }
+ 
+ #endif /* CONFIG_PPC_RTAS_FILTER */
+ 
++>>>>>>> f10881a46f89 (powerpc/rtas: Fix typo of ibm,open-errinjct in RTAS filter)
  /* We assume to be passed big endian arguments */
 -SYSCALL_DEFINE1(rtas, struct rtas_args __user *, uargs)
 +asmlinkage int ppc_rtas(struct rtas_args __user *uargs)
  {
  	struct rtas_args args;
  	unsigned long flags;
* Unmerged path arch/powerpc/kernel/rtas.c
