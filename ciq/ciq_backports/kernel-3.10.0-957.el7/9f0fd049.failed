powerpc/powernv: Add a virtual irqchip for opal events

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [powerpc] powernv: Add a virtual irqchip for opal events (Gustavo Duarte) [1577105]
Rebuild_FUZZ: 92.00%
commit-author Alistair Popple <alistair@popple.id.au>
commit 9f0fd0499d30dbd61632463f293e2e826fa363b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9f0fd049.failed

Whenever an interrupt is received for opal the linux kernel gets a
bitfield indicating certain events that have occurred and need handling
by the various device drivers. Currently this is handled using a
notifier interface where we call every device driver that has
registered to receive opal events.

This approach has several drawbacks. For example each driver has to do
its own checking to see if the event is relevant as well as event
masking. There is also no easy method of recording the number of times
we receive particular events.

This patch solves these issues by exposing opal events via the
standard interrupt APIs by adding a new interrupt chip and
domain. Drivers can then register for the appropriate events using
standard kernel calls such as irq_of_parse_and_map().

	Signed-off-by: Alistair Popple <alistair@popple.id.au>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 9f0fd0499d30dbd61632463f293e2e826fa363b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/opal.h
#	arch/powerpc/platforms/powernv/Makefile
#	arch/powerpc/platforms/powernv/opal.c
diff --cc arch/powerpc/include/asm/opal.h
index b2af73d0b7ad,1412814347ba..000000000000
--- a/arch/powerpc/include/asm/opal.h
+++ b/arch/powerpc/include/asm/opal.h
@@@ -1244,6 -240,10 +1244,13 @@@ extern int opal_elog_init(void)
  extern void opal_platform_dump_init(void);
  extern void opal_sys_param_init(void);
  extern void opal_msglog_init(void);
++<<<<<<< HEAD
++=======
+ extern int opal_async_comp_init(void);
+ extern int opal_sensor_init(void);
+ extern int opal_hmi_handler_init(void);
+ extern int opal_event_init(void);
++>>>>>>> 9f0fd0499d30 (powerpc/powernv: Add a virtual irqchip for opal events)
  
  extern int opal_machine_check(struct pt_regs *regs);
  extern bool opal_mce_check_early_recovery(struct pt_regs *regs);
@@@ -1255,7 -255,7 +1262,11 @@@ extern int opal_resync_timebase(void)
  
  extern void opal_lpc_init(void);
  
++<<<<<<< HEAD
 +extern void opal_kmsg_init(void);
++=======
+ extern int opal_event_request(unsigned int opal_event_nr);
++>>>>>>> 9f0fd0499d30 (powerpc/powernv: Add a virtual irqchip for opal events)
  
  struct opal_sg_list *opal_vmalloc_to_sg_list(void *vmalloc_addr,
  					     unsigned long vmalloc_size);
diff --cc arch/powerpc/platforms/powernv/Makefile
index 52cfe5f4805b,26bd7e417b7c..000000000000
--- a/arch/powerpc/platforms/powernv/Makefile
+++ b/arch/powerpc/platforms/powernv/Makefile
@@@ -1,11 -1,10 +1,15 @@@
 -obj-y			+= setup.o opal-wrappers.o opal.o opal-async.o idle.o
 +obj-y			+= setup.o opal-wrappers.o opal.o opal-async.o
  obj-y			+= opal-rtc.o opal-nvram.o opal-lpc.o opal-flash.o
  obj-y			+= rng.o opal-elog.o opal-dump.o opal-sysparam.o opal-sensor.o
++<<<<<<< HEAD
 +obj-y			+= opal-msglog.o opal-hmi.o opal-power.o
 +obj-y			+= opal-kmsg.o
++=======
+ obj-y			+= opal-msglog.o opal-hmi.o opal-power.o opal-irqchip.o
++>>>>>>> 9f0fd0499d30 (powerpc/powernv: Add a virtual irqchip for opal events)
  
  obj-$(CONFIG_SMP)	+= smp.o subcore.o subcore-asm.o
 -obj-$(CONFIG_PCI)	+= pci.o pci-p5ioc2.o pci-ioda.o
 +obj-$(CONFIG_PCI)	+= pci.o pci-p5ioc2.o pci-ioda.o npu-dma.o
  obj-$(CONFIG_EEH)	+= eeh-powernv.o
  obj-$(CONFIG_PPC_SCOM)	+= opal-xscom.o
  obj-$(CONFIG_MEMORY_FAILURE)	+= opal-memory-errors.o
diff --cc arch/powerpc/platforms/powernv/opal.c
index c7b94f2cf1eb,3baca718261a..000000000000
--- a/arch/powerpc/platforms/powernv/opal.c
+++ b/arch/powerpc/platforms/powernv/opal.c
@@@ -53,9 -53,6 +53,12 @@@ static int mc_recoverable_range_len
  
  struct device_node *opal_node;
  static DEFINE_SPINLOCK(opal_write_lock);
++<<<<<<< HEAD
 +extern u64 opal_mc_secondary_handler[];
 +static unsigned int *opal_irqs;
 +static unsigned int opal_irq_count;
++=======
++>>>>>>> 9f0fd0499d30 (powerpc/powernv: Add a virtual irqchip for opal events)
  static ATOMIC_NOTIFIER_HEAD(opal_notifier_head);
  static struct atomic_notifier_head opal_msg_notifier_head[OPAL_MSG_TYPE_MAX];
  static DEFINE_SPINLOCK(opal_notifier_lock);
@@@ -767,43 -707,30 +761,70 @@@ static void opal_i2c_create_devs(void
  		of_platform_device_create(np, NULL, NULL);
  }
  
++<<<<<<< HEAD
 +static void __init opal_irq_init(struct device_node *dn)
 +{
 +	const __be32 *irqs;
 +	int i, irqlen;
 +
 +	/* Get interrupt property */
 +	irqs = of_get_property(opal_node, "opal-interrupts", &irqlen);
 +	pr_debug("Found %d interrupts reserved for OPAL\n",
 +		 irqs ? (irqlen / 4) : 0);
 +
 +	/* Install interrupt handlers */
 +	opal_irq_count = irqlen / 4;
 +	opal_irqs = kzalloc(opal_irq_count * sizeof(unsigned int), GFP_KERNEL);
 +	for (i = 0; irqs && i < opal_irq_count; i++, irqs++) {
 +		unsigned int irq, virq;
 +		int rc;
 +
 +		/* Get hardware and virtual IRQ */
 +		irq = be32_to_cpup(irqs);
 +		virq = irq_create_mapping(NULL, irq);
 +		if (virq == NO_IRQ) {
 +			pr_warn("Failed to map irq 0x%x\n", irq);
 +			continue;
 +		}
 +
 +		/* Install interrupt handler */
 +		rc = request_irq(virq, opal_interrupt, 0, "opal", NULL);
 +		if (rc) {
 +			irq_dispose_mapping(virq);
 +			pr_warn("Error %d requesting irq %d (0x%x)\n",
 +				 rc, virq, irq);
 +			continue;
 +		}
 +
 +		/* Cache IRQ */
 +		opal_irqs[i] = virq;
 +	}
++=======
+ static int kopald(void *unused)
+ {
+ 	__be64 events;
+ 
+ 	set_freezable();
+ 	do {
+ 		try_to_freeze();
+ 		opal_poll_events(&events);
+ 		opal_handle_events(be64_to_cpu(events));
+ 		msleep_interruptible(opal_heartbeat);
+ 	} while (!kthread_should_stop());
+ 
+ 	return 0;
+ }
+ 
+ static void opal_init_heartbeat(void)
+ {
+ 	/* Old firwmware, we assume the HVC heartbeat is sufficient */
+ 	if (of_property_read_u32(opal_node, "ibm,heartbeat-ms",
+ 				 &opal_heartbeat) != 0)
+ 		opal_heartbeat = 0;
+ 
+ 	if (opal_heartbeat)
+ 		kthread_run(kopald, NULL, "kopald");
++>>>>>>> 9f0fd0499d30 (powerpc/powernv: Add a virtual irqchip for opal events)
  }
  
  static int __init opal_init(void)
@@@ -837,15 -776,8 +861,20 @@@
  	/* Create i2c platform devices */
  	opal_i2c_create_devs();
  
++<<<<<<< HEAD
 +	/* Find all OPAL interrupts and request them */
 +	opal_irq_init(opal_node);
 +
 +	/* Create leds platform devices */
 +	leds = of_find_node_by_path("/ibm,opal/leds");
 +	if (leds) {
 +		of_platform_device_create(leds, "opal_leds", NULL);
 +		of_node_put(leds);
 +	}
++=======
+ 	/* Setup a heatbeat thread if requested by OPAL */
+ 	opal_init_heartbeat();
++>>>>>>> 9f0fd0499d30 (powerpc/powernv: Add a virtual irqchip for opal events)
  
  	/* Create "opal" kobject under /sys/firmware */
  	rc = opal_sysfs_init();
* Unmerged path arch/powerpc/include/asm/opal.h
* Unmerged path arch/powerpc/platforms/powernv/Makefile
diff --git a/arch/powerpc/platforms/powernv/opal-irqchip.c b/arch/powerpc/platforms/powernv/opal-irqchip.c
new file mode 100644
index 000000000000..bd5125dcf0d7
--- /dev/null
+++ b/arch/powerpc/platforms/powernv/opal-irqchip.c
@@ -0,0 +1,253 @@
+/*
+ * This file implements an irqchip for OPAL events. Whenever there is
+ * an interrupt that is handled by OPAL we get passed a list of events
+ * that Linux needs to do something about. These basically look like
+ * interrupts to Linux so we implement an irqchip to handle them.
+ *
+ * Copyright Alistair Popple, IBM Corporation 2014.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/bitops.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/irq_work.h>
+
+#include <asm/machdep.h>
+#include <asm/opal.h>
+
+#include "powernv.h"
+
+/* Maximum number of events supported by OPAL firmware */
+#define MAX_NUM_EVENTS 64
+
+struct opal_event_irqchip {
+	struct irq_chip irqchip;
+	struct irq_domain *domain;
+	unsigned long mask;
+};
+static struct opal_event_irqchip opal_event_irqchip;
+
+static unsigned int opal_irq_count;
+static unsigned int *opal_irqs;
+
+static void opal_handle_irq_work(struct irq_work *work);
+static __be64 last_outstanding_events;
+static struct irq_work opal_event_irq_work = {
+	.func = opal_handle_irq_work,
+};
+
+static void opal_event_mask(struct irq_data *d)
+{
+	clear_bit(d->hwirq, &opal_event_irqchip.mask);
+}
+
+static void opal_event_unmask(struct irq_data *d)
+{
+	set_bit(d->hwirq, &opal_event_irqchip.mask);
+
+	opal_poll_events(&last_outstanding_events);
+	if (last_outstanding_events & opal_event_irqchip.mask)
+		/* Need to retrigger the interrupt */
+		irq_work_queue(&opal_event_irq_work);
+}
+
+static int opal_event_set_type(struct irq_data *d, unsigned int flow_type)
+{
+	/*
+	 * For now we only support level triggered events. The irq
+	 * handler will be called continuously until the event has
+	 * been cleared in OPAL.
+	 */
+	if (flow_type != IRQ_TYPE_LEVEL_HIGH)
+		return -EINVAL;
+
+	return 0;
+}
+
+static struct opal_event_irqchip opal_event_irqchip = {
+	.irqchip = {
+		.name = "OPAL EVT",
+		.irq_mask = opal_event_mask,
+		.irq_unmask = opal_event_unmask,
+		.irq_set_type = opal_event_set_type,
+	},
+	.mask = 0,
+};
+
+static int opal_event_map(struct irq_domain *d, unsigned int irq,
+			irq_hw_number_t hwirq)
+{
+	irq_set_chip_data(irq, &opal_event_irqchip);
+	irq_set_chip_and_handler(irq, &opal_event_irqchip.irqchip,
+				handle_level_irq);
+
+	return 0;
+}
+
+void opal_handle_events(uint64_t events)
+{
+	int virq, hwirq = 0;
+	u64 mask = opal_event_irqchip.mask;
+	u64 notifier_mask = 0;
+
+	if (!in_irq() && (events & mask)) {
+		last_outstanding_events = events;
+		irq_work_queue(&opal_event_irq_work);
+		return;
+	}
+
+	while (events) {
+		hwirq = fls64(events) - 1;
+		virq = irq_find_mapping(opal_event_irqchip.domain,
+					hwirq);
+		if (virq) {
+			if (BIT_ULL(hwirq) & mask)
+				generic_handle_irq(virq);
+		} else
+			notifier_mask |= BIT_ULL(hwirq);
+		events &= ~BIT_ULL(hwirq);
+	}
+
+	opal_do_notifier(notifier_mask);
+}
+
+static irqreturn_t opal_interrupt(int irq, void *data)
+{
+	__be64 events;
+
+	opal_handle_interrupt(virq_to_hw(irq), &events);
+	opal_handle_events(be64_to_cpu(events));
+
+	return IRQ_HANDLED;
+}
+
+static void opal_handle_irq_work(struct irq_work *work)
+{
+	opal_handle_events(be64_to_cpu(last_outstanding_events));
+}
+
+static int opal_event_match(struct irq_domain *h, struct device_node *node)
+{
+	return h->of_node == node;
+}
+
+static int opal_event_xlate(struct irq_domain *h, struct device_node *np,
+			   const u32 *intspec, unsigned int intsize,
+			   irq_hw_number_t *out_hwirq, unsigned int *out_flags)
+{
+	*out_hwirq = intspec[0];
+	*out_flags = IRQ_TYPE_LEVEL_HIGH;
+
+	return 0;
+}
+
+static const struct irq_domain_ops opal_event_domain_ops = {
+	.match	= opal_event_match,
+	.map	= opal_event_map,
+	.xlate	= opal_event_xlate,
+};
+
+void opal_event_shutdown(void)
+{
+	unsigned int i;
+
+	/* First free interrupts, which will also mask them */
+	for (i = 0; i < opal_irq_count; i++) {
+		if (opal_irqs[i])
+			free_irq(opal_irqs[i], NULL);
+		opal_irqs[i] = 0;
+	}
+}
+
+int __init opal_event_init(void)
+{
+	struct device_node *dn, *opal_node;
+	const __be32 *irqs;
+	int i, irqlen, rc = 0;
+
+	opal_node = of_find_node_by_path("/ibm,opal");
+	if (!opal_node) {
+		pr_warn("opal: Node not found\n");
+		return -ENODEV;
+	}
+
+	/* If dn is NULL it means the domain won't be linked to a DT
+	 * node so therefore irq_of_parse_and_map(...) wont work. But
+	 * that shouldn't be problem because if we're running a
+	 * version of skiboot that doesn't have the dn then the
+	 * devices won't have the correct properties and will have to
+	 * fall back to the legacy method (opal_event_request(...))
+	 * anyway. */
+	dn = of_find_compatible_node(NULL, NULL, "ibm,opal-event");
+	opal_event_irqchip.domain = irq_domain_add_linear(dn, MAX_NUM_EVENTS,
+				&opal_event_domain_ops, &opal_event_irqchip);
+	of_node_put(dn);
+	if (!opal_event_irqchip.domain) {
+		pr_warn("opal: Unable to create irq domain\n");
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	/* Get interrupt property */
+	irqs = of_get_property(opal_node, "opal-interrupts", &irqlen);
+	opal_irq_count = irqs ? (irqlen / 4) : 0;
+	pr_debug("Found %d interrupts reserved for OPAL\n", opal_irq_count);
+
+	/* Install interrupt handlers */
+	opal_irqs = kcalloc(opal_irq_count, sizeof(*opal_irqs), GFP_KERNEL);
+	for (i = 0; irqs && i < opal_irq_count; i++, irqs++) {
+		unsigned int irq, virq;
+
+		/* Get hardware and virtual IRQ */
+		irq = be32_to_cpup(irqs);
+		virq = irq_create_mapping(NULL, irq);
+		if (virq == NO_IRQ) {
+			pr_warn("Failed to map irq 0x%x\n", irq);
+			continue;
+		}
+
+		/* Install interrupt handler */
+		rc = request_irq(virq, opal_interrupt, 0, "opal", NULL);
+		if (rc) {
+			irq_dispose_mapping(virq);
+			pr_warn("Error %d requesting irq %d (0x%x)\n",
+				 rc, virq, irq);
+			continue;
+		}
+
+		/* Cache IRQ */
+		opal_irqs[i] = virq;
+	}
+
+out:
+	of_node_put(opal_node);
+	return rc;
+}
+
+/**
+ * opal_event_request(unsigned int opal_event_nr) - Request an event
+ * @opal_event_nr: the opal event number to request
+ *
+ * This routine can be used to find the linux virq number which can
+ * then be passed to request_irq to assign a handler for a particular
+ * opal event. This should only be used by legacy devices which don't
+ * have proper device tree bindings. Most devices should use
+ * irq_of_parse_and_map() instead.
+ */
+int opal_event_request(unsigned int opal_event_nr)
+{
+	return irq_create_mapping(opal_event_irqchip.domain, opal_event_nr);
+}
+EXPORT_SYMBOL(opal_event_request);
* Unmerged path arch/powerpc/platforms/powernv/opal.c
diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index 1e56962df621..6161faada984 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -27,6 +27,10 @@ extern u32 pnv_get_supported_cpuidle_states(void);
 
 extern void pnv_lpc_init(void);
 
+extern void opal_do_notifier(uint64_t events);
+extern void opal_handle_events(uint64_t events);
+extern void opal_event_shutdown(void);
+
 bool cpu_core_split_required(void);
 
 #endif /* _POWERNV_H */
