drm/nouveau/kms/nv50-: move fb ctxdma tracking into windows

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ben Skeggs <bskeggs@redhat.com>
commit 5bca1621c07c3ad37b5a4943450a892e18984df0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5bca1621.failed

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit 5bca1621c07c3ad37b5a4943450a892e18984df0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/dispnv50/disp.c
diff --cc drivers/gpu/drm/nouveau/dispnv50/disp.c
index a2ea42f947c7,fc3055d5c8c9..000000000000
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.c
@@@ -412,83 -416,8 +411,88 @@@ struct nv50_dmac 
  };
  
  static void
++<<<<<<< HEAD
 +nv50_dmac_ctxdma_del(struct nv50_dmac_ctxdma *ctxdma)
 +{
 +	nvif_object_fini(&ctxdma->object);
 +	list_del(&ctxdma->head);
 +	kfree(ctxdma);
 +}
 +
 +static struct nv50_dmac_ctxdma *
 +nv50_dmac_ctxdma_new(struct nv50_dmac *dmac, struct nouveau_framebuffer *fb)
 +{
 +	struct nouveau_drm *drm = nouveau_drm(fb->base.dev);
 +	struct nv50_dmac_ctxdma *ctxdma;
 +	const u8    kind = (fb->nvbo->tile_flags & 0x0000ff00) >> 8;
 +	const u32 handle = 0xfb000000 | kind;
 +	struct {
 +		struct nv_dma_v0 base;
 +		union {
 +			struct nv50_dma_v0 nv50;
 +			struct gf100_dma_v0 gf100;
 +			struct gf119_dma_v0 gf119;
 +		};
 +	} args = {};
 +	u32 argc = sizeof(args.base);
 +	int ret;
 +
 +	list_for_each_entry(ctxdma, &dmac->ctxdma, head) {
 +		if (ctxdma->object.handle == handle)
 +			return ctxdma;
 +	}
 +
 +	if (!(ctxdma = kzalloc(sizeof(*ctxdma), GFP_KERNEL)))
 +		return ERR_PTR(-ENOMEM);
 +	list_add(&ctxdma->head, &dmac->ctxdma);
 +
 +	args.base.target = NV_DMA_V0_TARGET_VRAM;
 +	args.base.access = NV_DMA_V0_ACCESS_RDWR;
 +	args.base.start  = 0;
 +	args.base.limit  = drm->client.device.info.ram_user - 1;
 +
 +	if (drm->client.device.info.chipset < 0x80) {
 +		args.nv50.part = NV50_DMA_V0_PART_256;
 +		argc += sizeof(args.nv50);
 +	} else
 +	if (drm->client.device.info.chipset < 0xc0) {
 +		args.nv50.part = NV50_DMA_V0_PART_256;
 +		args.nv50.kind = kind;
 +		argc += sizeof(args.nv50);
 +	} else
 +	if (drm->client.device.info.chipset < 0xd0) {
 +		args.gf100.kind = kind;
 +		argc += sizeof(args.gf100);
 +	} else {
 +		args.gf119.page = GF119_DMA_V0_PAGE_LP;
 +		args.gf119.kind = kind;
 +		argc += sizeof(args.gf119);
 +	}
 +
 +	ret = nvif_object_init(&dmac->base.user, handle, NV_DMA_IN_MEMORY,
 +			       &args, argc, &ctxdma->object);
 +	if (ret) {
 +		nv50_dmac_ctxdma_del(ctxdma);
 +		return ERR_PTR(ret);
 +	}
 +
 +	return ctxdma;
 +}
 +
 +static void
 +nv50_dmac_destroy(struct nv50_dmac *dmac, struct nvif_object *disp)
 +{
 +	struct nvif_device *device = dmac->base.device;
 +	struct nv50_dmac_ctxdma *ctxdma, *ctxtmp;
 +
 +	list_for_each_entry_safe(ctxdma, ctxtmp, &dmac->ctxdma, head) {
 +		nv50_dmac_ctxdma_del(ctxdma);
 +	}
 +
++=======
+ nv50_dmac_destroy(struct nv50_dmac *dmac)
+ {
++>>>>>>> 5bca1621c07c (drm/nouveau/kms/nv50-: move fb ctxdma tracking into windows)
  	nvif_object_fini(&dmac->vram);
  	nvif_object_fini(&dmac->sync);
  
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/disp.c
