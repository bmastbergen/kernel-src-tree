treewide: setup_timer() -> timer_setup()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] aquantia: treewide: setup_timer() -> timer_setup() (David Arcari) [1570787]
Rebuild_FUZZ: 88.89%
commit-author Kees Cook <keescook@chromium.org>
commit e99e88a9d2b067465adaa9c111ada99a041bef9a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/e99e88a9.failed

This converts all remaining cases of the old setup_timer() API into using
timer_setup(), where the callback argument is the structure already
holding the struct timer_list. These should have no behavioral changes,
since they just change which pointer is passed into the callback with
the same available pointers after conversion. It handles the following
examples, in addition to some other variations.

Casting from unsigned long:

    void my_callback(unsigned long data)
    {
        struct something *ptr = (struct something *)data;
    ...
    }
    ...
    setup_timer(&ptr->my_timer, my_callback, ptr);

and forced object casts:

    void my_callback(struct something *ptr)
    {
    ...
    }
    ...
    setup_timer(&ptr->my_timer, my_callback, (unsigned long)ptr);

become:

    void my_callback(struct timer_list *t)
    {
        struct something *ptr = from_timer(ptr, t, my_timer);
    ...
    }
    ...
    timer_setup(&ptr->my_timer, my_callback, 0);

Direct function assignments:

    void my_callback(unsigned long data)
    {
        struct something *ptr = (struct something *)data;
    ...
    }
    ...
    ptr->my_timer.function = my_callback;

have a temporary cast added, along with converting the args:

    void my_callback(struct timer_list *t)
    {
        struct something *ptr = from_timer(ptr, t, my_timer);
    ...
    }
    ...
    ptr->my_timer.function = (TIMER_FUNC_TYPE)my_callback;

And finally, callbacks without a data assignment:

    void my_callback(unsigned long data)
    {
    ...
    }
    ...
    setup_timer(&ptr->my_timer, my_callback, 0);

have their argument renamed to verify they're unused during conversion:

    void my_callback(struct timer_list *unused)
    {
    ...
    }
    ...
    timer_setup(&ptr->my_timer, my_callback, 0);

The conversion is done with the following Coccinelle script:

spatch --very-quiet --all-includes --include-headers \
	-I ./arch/x86/include -I ./arch/x86/include/generated \
	-I ./include -I ./arch/x86/include/uapi \
	-I ./arch/x86/include/generated/uapi -I ./include/uapi \
	-I ./include/generated/uapi --include ./include/linux/kconfig.h \
	--dir . \
	--cocci-file ~/src/data/timer_setup.cocci

@fix_address_of@
expression e;
@@

 setup_timer(
-&(e)
+&e
 , ...)

// Update any raw setup_timer() usages that have a NULL callback, but
// would otherwise match change_timer_function_usage, since the latter
// will update all function assignments done in the face of a NULL
// function initialization in setup_timer().
@change_timer_function_usage_NULL@
expression _E;
identifier _timer;
type _cast_data;
@@

(
-setup_timer(&_E->_timer, NULL, _E);
+timer_setup(&_E->_timer, NULL, 0);
|
-setup_timer(&_E->_timer, NULL, (_cast_data)_E);
+timer_setup(&_E->_timer, NULL, 0);
|
-setup_timer(&_E._timer, NULL, &_E);
+timer_setup(&_E._timer, NULL, 0);
|
-setup_timer(&_E._timer, NULL, (_cast_data)&_E);
+timer_setup(&_E._timer, NULL, 0);
)

@change_timer_function_usage@
expression _E;
identifier _timer;
struct timer_list _stl;
identifier _callback;
type _cast_func, _cast_data;
@@

(
-setup_timer(&_E->_timer, _callback, _E);
+timer_setup(&_E->_timer, _callback, 0);
|
-setup_timer(&_E->_timer, &_callback, _E);
+timer_setup(&_E->_timer, _callback, 0);
|
-setup_timer(&_E->_timer, _callback, (_cast_data)_E);
+timer_setup(&_E->_timer, _callback, 0);
|
-setup_timer(&_E->_timer, &_callback, (_cast_data)_E);
+timer_setup(&_E->_timer, _callback, 0);
|
-setup_timer(&_E->_timer, (_cast_func)_callback, _E);
+timer_setup(&_E->_timer, _callback, 0);
|
-setup_timer(&_E->_timer, (_cast_func)&_callback, _E);
+timer_setup(&_E->_timer, _callback, 0);
|
-setup_timer(&_E->_timer, (_cast_func)_callback, (_cast_data)_E);
+timer_setup(&_E->_timer, _callback, 0);
|
-setup_timer(&_E->_timer, (_cast_func)&_callback, (_cast_data)_E);
+timer_setup(&_E->_timer, _callback, 0);
|
-setup_timer(&_E._timer, _callback, (_cast_data)_E);
+timer_setup(&_E._timer, _callback, 0);
|
-setup_timer(&_E._timer, _callback, (_cast_data)&_E);
+timer_setup(&_E._timer, _callback, 0);
|
-setup_timer(&_E._timer, &_callback, (_cast_data)_E);
+timer_setup(&_E._timer, _callback, 0);
|
-setup_timer(&_E._timer, &_callback, (_cast_data)&_E);
+timer_setup(&_E._timer, _callback, 0);
|
-setup_timer(&_E._timer, (_cast_func)_callback, (_cast_data)_E);
+timer_setup(&_E._timer, _callback, 0);
|
-setup_timer(&_E._timer, (_cast_func)_callback, (_cast_data)&_E);
+timer_setup(&_E._timer, _callback, 0);
|
-setup_timer(&_E._timer, (_cast_func)&_callback, (_cast_data)_E);
+timer_setup(&_E._timer, _callback, 0);
|
-setup_timer(&_E._timer, (_cast_func)&_callback, (_cast_data)&_E);
+timer_setup(&_E._timer, _callback, 0);
|
 _E->_timer@_stl.function = _callback;
|
 _E->_timer@_stl.function = &_callback;
|
 _E->_timer@_stl.function = (_cast_func)_callback;
|
 _E->_timer@_stl.function = (_cast_func)&_callback;
|
 _E._timer@_stl.function = _callback;
|
 _E._timer@_stl.function = &_callback;
|
 _E._timer@_stl.function = (_cast_func)_callback;
|
 _E._timer@_stl.function = (_cast_func)&_callback;
)

// callback(unsigned long arg)
@change_callback_handle_cast
 depends on change_timer_function_usage@
identifier change_timer_function_usage._callback;
identifier change_timer_function_usage._timer;
type _origtype;
identifier _origarg;
type _handletype;
identifier _handle;
@@

 void _callback(
-_origtype _origarg
+struct timer_list *t
 )
 {
(
	... when != _origarg
	_handletype *_handle =
-(_handletype *)_origarg;
+from_timer(_handle, t, _timer);
	... when != _origarg
|
	... when != _origarg
	_handletype *_handle =
-(void *)_origarg;
+from_timer(_handle, t, _timer);
	... when != _origarg
|
	... when != _origarg
	_handletype *_handle;
	... when != _handle
	_handle =
-(_handletype *)_origarg;
+from_timer(_handle, t, _timer);
	... when != _origarg
|
	... when != _origarg
	_handletype *_handle;
	... when != _handle
	_handle =
-(void *)_origarg;
+from_timer(_handle, t, _timer);
	... when != _origarg
)
 }

// callback(unsigned long arg) without existing variable
@change_callback_handle_cast_no_arg
 depends on change_timer_function_usage &&
                     !change_callback_handle_cast@
identifier change_timer_function_usage._callback;
identifier change_timer_function_usage._timer;
type _origtype;
identifier _origarg;
type _handletype;
@@

 void _callback(
-_origtype _origarg
+struct timer_list *t
 )
 {
+	_handletype *_origarg = from_timer(_origarg, t, _timer);
+
	... when != _origarg
-	(_handletype *)_origarg
+	_origarg
	... when != _origarg
 }

// Avoid already converted callbacks.
@match_callback_converted
 depends on change_timer_function_usage &&
            !change_callback_handle_cast &&
	    !change_callback_handle_cast_no_arg@
identifier change_timer_function_usage._callback;
identifier t;
@@

 void _callback(struct timer_list *t)
 { ... }

// callback(struct something *handle)
@change_callback_handle_arg
 depends on change_timer_function_usage &&
	    !match_callback_converted &&
            !change_callback_handle_cast &&
            !change_callback_handle_cast_no_arg@
identifier change_timer_function_usage._callback;
identifier change_timer_function_usage._timer;
type _handletype;
identifier _handle;
@@

 void _callback(
-_handletype *_handle
+struct timer_list *t
 )
 {
+	_handletype *_handle = from_timer(_handle, t, _timer);
	...
 }

// If change_callback_handle_arg ran on an empty function, remove
// the added handler.
@unchange_callback_handle_arg
 depends on change_timer_function_usage &&
	    change_callback_handle_arg@
identifier change_timer_function_usage._callback;
identifier change_timer_function_usage._timer;
type _handletype;
identifier _handle;
identifier t;
@@

 void _callback(struct timer_list *t)
 {
-	_handletype *_handle = from_timer(_handle, t, _timer);
 }

// We only want to refactor the setup_timer() data argument if we've found
// the matching callback. This undoes changes in change_timer_function_usage.
@unchange_timer_function_usage
 depends on change_timer_function_usage &&
            !change_callback_handle_cast &&
            !change_callback_handle_cast_no_arg &&
	    !change_callback_handle_arg@
expression change_timer_function_usage._E;
identifier change_timer_function_usage._timer;
identifier change_timer_function_usage._callback;
type change_timer_function_usage._cast_data;
@@

(
-timer_setup(&_E->_timer, _callback, 0);
+setup_timer(&_E->_timer, _callback, (_cast_data)_E);
|
-timer_setup(&_E._timer, _callback, 0);
+setup_timer(&_E._timer, _callback, (_cast_data)&_E);
)

// If we fixed a callback from a .function assignment, fix the
// assignment cast now.
@change_timer_function_assignment
 depends on change_timer_function_usage &&
            (change_callback_handle_cast ||
             change_callback_handle_cast_no_arg ||
             change_callback_handle_arg)@
expression change_timer_function_usage._E;
identifier change_timer_function_usage._timer;
identifier change_timer_function_usage._callback;
type _cast_func;
typedef TIMER_FUNC_TYPE;
@@

(
 _E->_timer.function =
-_callback
+(TIMER_FUNC_TYPE)_callback
 ;
|
 _E->_timer.function =
-&_callback
+(TIMER_FUNC_TYPE)_callback
 ;
|
 _E->_timer.function =
-(_cast_func)_callback;
+(TIMER_FUNC_TYPE)_callback
 ;
|
 _E->_timer.function =
-(_cast_func)&_callback
+(TIMER_FUNC_TYPE)_callback
 ;
|
 _E._timer.function =
-_callback
+(TIMER_FUNC_TYPE)_callback
 ;
|
 _E._timer.function =
-&_callback;
+(TIMER_FUNC_TYPE)_callback
 ;
|
 _E._timer.function =
-(_cast_func)_callback
+(TIMER_FUNC_TYPE)_callback
 ;
|
 _E._timer.function =
-(_cast_func)&_callback
+(TIMER_FUNC_TYPE)_callback
 ;
)

// Sometimes timer functions are called directly. Replace matched args.
@change_timer_function_calls
 depends on change_timer_function_usage &&
            (change_callback_handle_cast ||
             change_callback_handle_cast_no_arg ||
             change_callback_handle_arg)@
expression _E;
identifier change_timer_function_usage._timer;
identifier change_timer_function_usage._callback;
type _cast_data;
@@

 _callback(
(
-(_cast_data)_E
+&_E->_timer
|
-(_cast_data)&_E
+&_E._timer
|
-_E
+&_E->_timer
)
 )

// If a timer has been configured without a data argument, it can be
// converted without regard to the callback argument, since it is unused.
@match_timer_function_unused_data@
expression _E;
identifier _timer;
identifier _callback;
@@

(
-setup_timer(&_E->_timer, _callback, 0);
+timer_setup(&_E->_timer, _callback, 0);
|
-setup_timer(&_E->_timer, _callback, 0L);
+timer_setup(&_E->_timer, _callback, 0);
|
-setup_timer(&_E->_timer, _callback, 0UL);
+timer_setup(&_E->_timer, _callback, 0);
|
-setup_timer(&_E._timer, _callback, 0);
+timer_setup(&_E._timer, _callback, 0);
|
-setup_timer(&_E._timer, _callback, 0L);
+timer_setup(&_E._timer, _callback, 0);
|
-setup_timer(&_E._timer, _callback, 0UL);
+timer_setup(&_E._timer, _callback, 0);
|
-setup_timer(&_timer, _callback, 0);
+timer_setup(&_timer, _callback, 0);
|
-setup_timer(&_timer, _callback, 0L);
+timer_setup(&_timer, _callback, 0);
|
-setup_timer(&_timer, _callback, 0UL);
+timer_setup(&_timer, _callback, 0);
|
-setup_timer(_timer, _callback, 0);
+timer_setup(_timer, _callback, 0);
|
-setup_timer(_timer, _callback, 0L);
+timer_setup(_timer, _callback, 0);
|
-setup_timer(_timer, _callback, 0UL);
+timer_setup(_timer, _callback, 0);
)

@change_callback_unused_data
 depends on match_timer_function_unused_data@
identifier match_timer_function_unused_data._callback;
type _origtype;
identifier _origarg;
@@

 void _callback(
-_origtype _origarg
+struct timer_list *unused
 )
 {
	... when != _origarg
 }

	Signed-off-by: Kees Cook <keescook@chromium.org>
(cherry picked from commit e99e88a9d2b067465adaa9c111ada99a041bef9a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/mach-iop32x/n2100.c
#	arch/blackfin/kernel/nmi.c
#	arch/mips/lasat/picvue_proc.c
#	arch/powerpc/kernel/tau_6xx.c
#	arch/powerpc/oprofile/op_model_cell.c
#	arch/powerpc/platforms/powermac/low_i2c.c
#	arch/sh/drivers/pci/common.c
#	arch/sh/drivers/push-switch.c
#	block/blk-throttle.c
#	drivers/atm/ambassador.c
#	drivers/atm/firestream.c
#	drivers/atm/horizon.c
#	drivers/atm/idt77252.c
#	drivers/atm/lanai.c
#	drivers/atm/nicstar.c
#	drivers/block/DAC960.c
#	drivers/block/skd_main.c
#	drivers/block/sunvdc.c
#	drivers/block/umem.c
#	drivers/char/ipmi/ipmi_si_intf.c
#	drivers/gpu/drm/exynos/exynos_drm_vidi.c
#	drivers/gpu/drm/msm/adreno/a5xx_preempt.c
#	drivers/gpu/drm/msm/msm_gpu.c
#	drivers/gpu/drm/rockchip/rockchip_drm_psr.c
#	drivers/gpu/drm/vgem/vgem_fence.c
#	drivers/hid/hid-wiimote-core.c
#	drivers/iio/common/ssp_sensors/ssp_dev.c
#	drivers/input/gameport/gameport.c
#	drivers/input/joystick/db9.c
#	drivers/input/joystick/gamecon.c
#	drivers/input/joystick/turbografx.c
#	drivers/iommu/iova.c
#	drivers/isdn/capi/capidrv.c
#	drivers/isdn/divert/isdn_divert.c
#	drivers/isdn/hardware/eicon/divasi.c
#	drivers/isdn/hardware/mISDN/hfcmulti.c
#	drivers/isdn/hardware/mISDN/hfcpci.c
#	drivers/isdn/hardware/mISDN/mISDNisar.c
#	drivers/isdn/i4l/isdn_common.c
#	drivers/isdn/i4l/isdn_net.c
#	drivers/isdn/i4l/isdn_ppp.c
#	drivers/isdn/i4l/isdn_tty.c
#	drivers/media/platform/mem2mem_testdev.c
#	drivers/media/platform/s5p-mfc/s5p_mfc.c
#	drivers/media/platform/sti/c8sectpfe/c8sectpfe-core.c
#	drivers/media/usb/au0828/au0828-dvb.c
#	drivers/media/usb/au0828/au0828-video.c
#	drivers/memstick/core/ms_block.c
#	drivers/mmc/core/host.c
#	drivers/net/caif/caif_hsi.c
#	drivers/net/dsa/mv88e6xxx/phy.c
#	drivers/net/eql.c
#	drivers/net/ethernet/adi/bfin_mac.c
#	drivers/net/ethernet/aquantia/atlantic/aq_nic.c
#	drivers/net/ethernet/atheros/atl1e/atl1e_main.c
#	drivers/net/ethernet/atheros/atlx/atl2.c
#	drivers/net/ethernet/broadcom/b44.c
#	drivers/net/ethernet/marvell/mv643xx_eth.c
#	drivers/net/ethernet/marvell/pxa168_eth.c
#	drivers/net/ethernet/pasemi/pasemi_mac.c
#	drivers/net/ethernet/qlogic/qla3xxx.c
#	drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
#	drivers/net/ethernet/synopsys/dwc-xlgmac-net.c
#	drivers/net/ethernet/ti/cpsw_ale.c
#	drivers/net/ethernet/ti/netcp_ethss.c
#	drivers/net/ethernet/toshiba/spider_net.c
#	drivers/net/slip/slip.c
#	drivers/net/wan/hdlc_ppp.c
#	drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
#	drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
#	drivers/net/wireless/hostap/hostap_ap.c
#	drivers/net/wireless/hostap/hostap_hw.c
#	drivers/net/wireless/orinoco/orinoco_usb.c
#	drivers/net/wireless/quantenna/qtnfmac/core.c
#	drivers/nfc/pn533.c
#	drivers/nfc/st-nci/ndlc.c
#	drivers/s390/block/dasd.c
#	drivers/s390/net/fsm.c
#	drivers/scsi/arcmsr/arcmsr_hba.c
#	drivers/scsi/arm/fas216.c
#	drivers/scsi/bfa/bfad.c
#	drivers/scsi/esas2r/esas2r_main.c
#	drivers/scsi/ncr53c8xx.c
#	drivers/staging/et131x/et131x.c
#	drivers/staging/greybus/operation.c
#	drivers/staging/lustre/lnet/lnet/net_fault.c
#	drivers/staging/lustre/lustre/ptlrpc/service.c
#	drivers/staging/media/imx/imx-ic-prpencvf.c
#	drivers/staging/media/imx/imx-media-csi.c
#	drivers/staging/most/hdm-usb/hdm_usb.c
#	drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
#	drivers/staging/rtl8712/recv_linux.c
#	drivers/staging/rtl8712/rtl8712_led.c
#	drivers/staging/unisys/visorbus/visorbus_main.c
#	drivers/staging/unisys/visornic/visornic_main.c
#	drivers/staging/wilc1000/wilc_wfi_cfgoperations.c
#	drivers/tty/n_gsm.c
#	drivers/tty/serial/fsl_lpuart.c
#	drivers/tty/serial/ifx6x60.c
#	drivers/tty/serial/imx.c
#	drivers/tty/serial/kgdb_nmi.c
#	drivers/tty/serial/max3100.c
#	drivers/tty/serial/mux.c
#	drivers/tty/serial/pnx8xxx_uart.c
#	drivers/tty/serial/sa1100.c
#	drivers/tty/serial/sh-sci.c
#	drivers/tty/serial/sn_console.c
#	drivers/usb/core/hcd.c
#	drivers/usb/dwc2/hcd.c
#	drivers/usb/dwc2/hcd_queue.c
#	drivers/usb/gadget/dummy_hcd.c
#	drivers/usb/gadget/m66592-udc.c
#	drivers/usb/gadget/omap_udc.c
#	drivers/usb/gadget/pxa25x_udc.c
#	drivers/usb/gadget/r8a66597-udc.c
#	drivers/usb/host/ohci-hcd.c
#	drivers/usb/host/oxu210hp-hcd.c
#	drivers/usb/host/r8a66597-hcd.c
#	drivers/usb/host/sl811-hcd.c
#	drivers/uwb/drp.c
#	drivers/uwb/neh.c
#	drivers/uwb/rsv.c
#	drivers/video/omap2/dss/dsi.c
#	drivers/watchdog/at91sam9_wdt.c
#	drivers/watchdog/mpc8xxx_wdt.c
#	drivers/watchdog/shwdt.c
#	fs/ocfs2/cluster/tcp.c
#	kernel/padata.c
#	kernel/time/clocksource.c
#	net/802/mrp.c
#	net/batman-adv/tp_meter.c
#	net/core/drop_monitor.c
#	net/core/neighbour.c
#	net/decnet/dn_route.c
#	net/ipv4/igmp.c
#	net/ipv4/ipmr.c
#	net/ipv6/mcast.c
#	net/ncsi/ncsi-manage.c
#	net/rxrpc/call_object.c
diff --cc arch/arm/mach-iop32x/n2100.c
index ea0984a7449e,3b73813c6b04..000000000000
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@@ -297,9 -305,9 +297,9 @@@ static void n2100_restart(char mode, co
  
  static struct timer_list power_button_poll_timer;
  
- static void power_button_poll(unsigned long dummy)
+ static void power_button_poll(struct timer_list *unused)
  {
 -	if (gpio_get_value(N2100_POWER_BUTTON) == 0) {
 +	if (gpio_line_get(N2100_POWER_BUTTON) == 0) {
  		ctrl_alt_del();
  		return;
  	}
@@@ -308,6 -316,32 +308,35 @@@
  	add_timer(&power_button_poll_timer);
  }
  
++<<<<<<< HEAD
++=======
+ static int __init n2100_request_gpios(void)
+ {
+ 	int ret;
+ 
+ 	if (!machine_is_n2100())
+ 		return 0;
+ 
+ 	ret = gpio_request(N2100_HARDWARE_RESET, "reset");
+ 	if (ret)
+ 		pr_err("could not request reset GPIO\n");
+ 
+ 	ret = gpio_request(N2100_POWER_BUTTON, "power");
+ 	if (ret)
+ 		pr_err("could not request power GPIO\n");
+ 	else {
+ 		ret = gpio_direction_input(N2100_POWER_BUTTON);
+ 		if (ret)
+ 			pr_err("could not set power GPIO as input\n");
+ 	}
+ 	/* Set up power button poll timer */
+ 	timer_setup(&power_button_poll_timer, power_button_poll, 0);
+ 	power_button_poll_timer.expires = jiffies + (HZ / 10);
+ 	add_timer(&power_button_poll_timer);
+ 	return 0;
+ }
+ device_initcall(n2100_request_gpios);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  static void __init n2100_init_machine(void)
  {
diff --cc arch/blackfin/kernel/nmi.c
index 9919d29287dc,8a211d95821f..000000000000
--- a/arch/blackfin/kernel/nmi.c
+++ b/arch/blackfin/kernel/nmi.c
@@@ -179,8 -180,7 +179,12 @@@ static int __init init_nmi_wdt(void
  	nmi_wdt_start();
  	nmi_active = true;
  
++<<<<<<< HEAD
 +	init_timer(&ntimer);
 +	ntimer.function = nmi_wdt_timer;
++=======
+ 	timer_setup(&ntimer, nmi_wdt_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	ntimer.expires = jiffies + NMI_CHECK_TIMEOUT;
  	add_timer(&ntimer);
  
diff --cc arch/mips/lasat/picvue_proc.c
index 638c5db122c9,5d89e1ec5fcc..000000000000
--- a/arch/mips/lasat/picvue_proc.c
+++ b/arch/mips/lasat/picvue_proc.c
@@@ -202,8 -197,7 +202,12 @@@ static int __init pvc_proc_init(void
  	if (proc_entry == NULL)
  		goto error;
  
++<<<<<<< HEAD
 +	init_timer(&timer);
 +	timer.function = pvc_proc_timerfunc;
++=======
+ 	timer_setup(&timer, pvc_proc_timerfunc, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	return 0;
  error:
diff --cc arch/powerpc/kernel/tau_6xx.c
index a753b72efbc0,8cdd852aedd1..000000000000
--- a/arch/powerpc/kernel/tau_6xx.c
+++ b/arch/powerpc/kernel/tau_6xx.c
@@@ -229,8 -230,7 +229,12 @@@ int __init TAU_init(void
  
  
  	/* first, set up the window shrinking timer */
++<<<<<<< HEAD
 +	init_timer(&tau_timer);
 +	tau_timer.function = tau_timeout_smp;
++=======
+ 	timer_setup(&tau_timer, tau_timeout_smp, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	tau_timer.expires = jiffies + shrink_timer;
  	add_timer(&tau_timer);
  
diff --cc arch/powerpc/oprofile/op_model_cell.c
index 863d89386f60,b90a21bc2f3f..000000000000
--- a/arch/powerpc/oprofile/op_model_cell.c
+++ b/arch/powerpc/oprofile/op_model_cell.c
@@@ -555,9 -555,7 +555,13 @@@ static void cell_virtual_cntr(struct ti
  
  static void start_virt_cntrs(void)
  {
++<<<<<<< HEAD
 +	init_timer(&timer_virt_cntr);
 +	timer_virt_cntr.function = cell_virtual_cntr;
 +	timer_virt_cntr.data = 0UL;
++=======
+ 	timer_setup(&timer_virt_cntr, cell_virtual_cntr, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	timer_virt_cntr.expires = jiffies + HZ / 10;
  	add_timer(&timer_virt_cntr);
  }
@@@ -679,9 -677,7 +683,13 @@@ static void spu_evnt_swap(struct timer_
  
  static void start_spu_event_swap(void)
  {
++<<<<<<< HEAD
 +	init_timer(&timer_spu_event_swap);
 +	timer_spu_event_swap.function = spu_evnt_swap;
 +	timer_spu_event_swap.data = 0UL;
++=======
+ 	timer_setup(&timer_spu_event_swap, spu_evnt_swap, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	timer_spu_event_swap.expires = jiffies + HZ / 25;
  	add_timer(&timer_spu_event_swap);
  }
diff --cc arch/powerpc/platforms/powermac/low_i2c.c
index fc536f2971c0,3408f315ef48..000000000000
--- a/arch/powerpc/platforms/powermac/low_i2c.c
+++ b/arch/powerpc/platforms/powermac/low_i2c.c
@@@ -512,9 -513,7 +512,13 @@@ static struct pmac_i2c_host_kw *__init 
  	mutex_init(&host->mutex);
  	init_completion(&host->complete);
  	spin_lock_init(&host->lock);
++<<<<<<< HEAD
 +	init_timer(&host->timeout_timer);
 +	host->timeout_timer.function = kw_i2c_timeout;
 +	host->timeout_timer.data = (unsigned long)host;
++=======
+ 	timer_setup(&host->timeout_timer, kw_i2c_timeout, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	psteps = of_get_property(np, "AAPL,address-step", NULL);
  	steps = psteps ? (*psteps) : 0x10;
diff --cc arch/sh/drivers/pci/common.c
index dbf138199871,fe163ecd0719..000000000000
--- a/arch/sh/drivers/pci/common.c
+++ b/arch/sh/drivers/pci/common.c
@@@ -105,15 -106,11 +105,23 @@@ static void pcibios_enable_serr(struct 
  void pcibios_enable_timers(struct pci_channel *hose)
  {
  	if (hose->err_irq) {
++<<<<<<< HEAD
 +		init_timer(&hose->err_timer);
 +		hose->err_timer.data = (unsigned long)hose;
 +		hose->err_timer.function = pcibios_enable_err;
 +	}
 +
 +	if (hose->serr_irq) {
 +		init_timer(&hose->serr_timer);
 +		hose->serr_timer.data = (unsigned long)hose;
 +		hose->serr_timer.function = pcibios_enable_serr;
++=======
+ 		timer_setup(&hose->err_timer, pcibios_enable_err, 0);
+ 	}
+ 
+ 	if (hose->serr_irq) {
+ 		timer_setup(&hose->serr_timer, pcibios_enable_serr, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	}
  }
  
diff --cc arch/sh/drivers/push-switch.c
index 5bfb341cc5c4,a17181160233..000000000000
--- a/arch/sh/drivers/push-switch.c
+++ b/arch/sh/drivers/push-switch.c
@@@ -78,10 -78,7 +78,14 @@@ static int switch_drv_probe(struct plat
  	}
  
  	INIT_WORK(&psw->work, switch_work_handler);
++<<<<<<< HEAD
 +	init_timer(&psw->debounce);
 +
 +	psw->debounce.function = switch_timer;
 +	psw->debounce.data = (unsigned long)psw;
++=======
+ 	timer_setup(&psw->debounce, switch_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	/* Workqueue API brain-damage */
  	psw->pdev = pdev;
diff --cc block/blk-throttle.c
index 3884a76fd0a6,825bc29767e6..000000000000
--- a/block/blk-throttle.c
+++ b/block/blk-throttle.c
@@@ -166,16 -208,24 +166,20 @@@ struct throtl_dat
  
  	/* Work for dispatching throttled bios */
  	struct work_struct dispatch_work;
 -	unsigned int limit_index;
 -	bool limit_valid[LIMIT_CNT];
 -
 -	unsigned long low_upgrade_time;
 -	unsigned long low_downgrade_time;
 -
 -	unsigned int scale;
 +};
  
 -	struct latency_bucket tmp_buckets[LATENCY_BUCKET_SIZE];
 -	struct avg_latency_bucket avg_buckets[LATENCY_BUCKET_SIZE];
 -	struct latency_bucket __percpu *latency_buckets;
 -	unsigned long last_calculate_time;
 -	unsigned long filtered_latency;
++<<<<<<< HEAD
 +/* list and work item to allocate percpu group stats */
 +static DEFINE_SPINLOCK(tg_stats_alloc_lock);
 +static LIST_HEAD(tg_stats_alloc_list);
  
 -	bool track_bio_latency;
 -};
 +static void tg_stats_alloc_fn(struct work_struct *);
 +static DECLARE_DELAYED_WORK(tg_stats_alloc_work, tg_stats_alloc_fn);
  
 +static void throtl_pending_timer_fn(unsigned long arg);
++=======
+ static void throtl_pending_timer_fn(struct timer_list *t);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  static inline struct throtl_grp *pd_to_tg(struct blkg_policy_data *pd)
  {
@@@ -383,26 -478,53 +387,30 @@@ static void throtl_service_queue_init(s
  	INIT_LIST_HEAD(&sq->queued[0]);
  	INIT_LIST_HEAD(&sq->queued[1]);
  	sq->pending_tree = RB_ROOT;
++<<<<<<< HEAD
 +	sq->parent_sq = parent_sq;
 +	setup_timer(&sq->pending_timer, throtl_pending_timer_fn,
 +		    (unsigned long)sq);
++=======
+ 	timer_setup(&sq->pending_timer, throtl_pending_timer_fn, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  }
  
 -static struct blkg_policy_data *throtl_pd_alloc(gfp_t gfp, int node)
 +static void throtl_service_queue_exit(struct throtl_service_queue *sq)
  {
 -	struct throtl_grp *tg;
 -	int rw;
 -
 -	tg = kzalloc_node(sizeof(*tg), gfp, node);
 -	if (!tg)
 -		return NULL;
 -
 -	throtl_service_queue_init(&tg->service_queue);
 -
 -	for (rw = READ; rw <= WRITE; rw++) {
 -		throtl_qnode_init(&tg->qnode_on_self[rw], tg);
 -		throtl_qnode_init(&tg->qnode_on_parent[rw], tg);
 -	}
 -
 -	RB_CLEAR_NODE(&tg->rb_node);
 -	tg->bps[READ][LIMIT_MAX] = U64_MAX;
 -	tg->bps[WRITE][LIMIT_MAX] = U64_MAX;
 -	tg->iops[READ][LIMIT_MAX] = UINT_MAX;
 -	tg->iops[WRITE][LIMIT_MAX] = UINT_MAX;
 -	tg->bps_conf[READ][LIMIT_MAX] = U64_MAX;
 -	tg->bps_conf[WRITE][LIMIT_MAX] = U64_MAX;
 -	tg->iops_conf[READ][LIMIT_MAX] = UINT_MAX;
 -	tg->iops_conf[WRITE][LIMIT_MAX] = UINT_MAX;
 -	/* LIMIT_LOW will have default value 0 */
 -
 -	tg->latency_target = DFL_LATENCY_TARGET;
 -	tg->latency_target_conf = DFL_LATENCY_TARGET;
 -	tg->idletime_threshold = DFL_IDLE_THRESHOLD;
 -	tg->idletime_threshold_conf = DFL_IDLE_THRESHOLD;
 -
 -	return &tg->pd;
 +	del_timer_sync(&sq->pending_timer);
  }
  
 -static void throtl_pd_init(struct blkg_policy_data *pd)
 +static void throtl_pd_init(struct blkcg_gq *blkg)
  {
 -	struct throtl_grp *tg = pd_to_tg(pd);
 -	struct blkcg_gq *blkg = tg_to_blkg(tg);
 +	struct throtl_grp *tg = blkg_to_tg(blkg);
  	struct throtl_data *td = blkg->q->td;
 -	struct throtl_service_queue *sq = &tg->service_queue;
 +	struct throtl_service_queue *parent_sq;
 +	unsigned long flags;
 +	int rw;
  
  	/*
 -	 * If on the default hierarchy, we switch to properly hierarchical
 +	 * If sane_hierarchy is enabled, we switch to properly hierarchical
  	 * behavior where limits on a given throtl_grp are applied to the
  	 * whole subtree rather than just the group itself.  e.g. If 16M
  	 * read_bps limit is set on the root group, the whole system can't
diff --cc drivers/atm/ambassador.c
index 77a7480dc4d1,dd286ad404f8..000000000000
--- a/drivers/atm/ambassador.c
+++ b/drivers/atm/ambassador.c
@@@ -2267,9 -2267,7 +2267,13 @@@ static int amb_probe(struct pci_dev *pc
  	dev->atm_dev->ci_range.vpi_bits = NUM_VPI_BITS;
  	dev->atm_dev->ci_range.vci_bits = NUM_VCI_BITS;
  
++<<<<<<< HEAD
 +	init_timer(&dev->housekeeping);
 +	dev->housekeeping.function = do_housekeeping;
 +	dev->housekeeping.data = (unsigned long) dev;
++=======
+ 	timer_setup(&dev->housekeeping, do_housekeeping, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	mod_timer(&dev->housekeeping, jiffies);
  
  	// enable host interrupts
diff --cc drivers/atm/firestream.c
index b41c9481b67b,d97c05690faa..000000000000
--- a/drivers/atm/firestream.c
+++ b/drivers/atm/firestream.c
@@@ -1881,9 -1885,7 +1881,13 @@@ static int fs_init(struct fs_dev *dev
  	}
  
  #ifdef FS_POLL_FREQ
++<<<<<<< HEAD
 +	init_timer (&dev->timer);
 +	dev->timer.data = (unsigned long) dev;
 +	dev->timer.function = fs_poll;
++=======
+ 	timer_setup(&dev->timer, fs_poll, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	dev->timer.expires = jiffies + FS_POLL_FREQ;
  	add_timer (&dev->timer);
  #endif
diff --cc drivers/atm/horizon.c
index 1dc0519333f2,5ddc203206b8..000000000000
--- a/drivers/atm/horizon.c
+++ b/drivers/atm/horizon.c
@@@ -2819,9 -2796,7 +2819,13 @@@ static int hrz_probe(struct pci_dev *pc
  	dev->atm_dev->ci_range.vpi_bits = vpi_bits;
  	dev->atm_dev->ci_range.vci_bits = 10-vpi_bits;
  
++<<<<<<< HEAD
 +	init_timer(&dev->housekeeping);
 +	dev->housekeeping.function = do_housekeeping;
 +	dev->housekeeping.data = (unsigned long) dev;
++=======
+ 	timer_setup(&dev->housekeeping, do_housekeeping, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	mod_timer(&dev->housekeeping, jiffies);
  
  out:
diff --cc drivers/atm/idt77252.c
index 6f908aaeab53,0277f36be85b..000000000000
--- a/drivers/atm/idt77252.c
+++ b/drivers/atm/idt77252.c
@@@ -3634,9 -3634,7 +3634,13 @@@ static int idt77252_init_one(struct pci
  	spin_lock_init(&card->cmd_lock);
  	spin_lock_init(&card->tst_lock);
  
++<<<<<<< HEAD
 +	init_timer(&card->tst_timer);
 +	card->tst_timer.data = (unsigned long)card;
 +	card->tst_timer.function = tst_timer;
++=======
+ 	timer_setup(&card->tst_timer, tst_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	/* Do the I/O remapping... */
  	card->membase = ioremap(membase, 1024);
diff --cc drivers/atm/lanai.c
index fa7d701933ba,6664aa50789e..000000000000
--- a/drivers/atm/lanai.c
+++ b/drivers/atm/lanai.c
@@@ -1798,10 -1790,8 +1798,14 @@@ static void lanai_timed_poll(struct tim
  
  static inline void lanai_timed_poll_start(struct lanai_dev *lanai)
  {
++<<<<<<< HEAD
 +	init_timer(&lanai->timer);
++=======
+ 	timer_setup(&lanai->timer, lanai_timed_poll, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	lanai->timer.expires = jiffies + LANAI_POLL_PERIOD;
 +	lanai->timer.data = (unsigned long) lanai;
 +	lanai->timer.function = lanai_timed_poll;
  	add_timer(&lanai->timer);
  }
  
diff --cc drivers/atm/nicstar.c
index cce7fac5528d,cbec9adc01c7..000000000000
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@@ -152,8 -145,7 +152,12 @@@ static int ns_ioctl(struct atm_dev *dev
  #ifdef EXTRA_DEBUG
  static void which_list(ns_dev * card, struct sk_buff *skb);
  #endif
++<<<<<<< HEAD
 +static void ns_poll(unsigned long arg);
 +static int ns_parse_mac(char *mac, unsigned char *esi);
++=======
+ static void ns_poll(struct timer_list *unused);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  static void ns_phy_put(struct atm_dev *dev, unsigned char value,
  		       unsigned long addr);
  static unsigned char ns_phy_get(struct atm_dev *dev, unsigned long addr);
@@@ -292,10 -284,8 +296,14 @@@ static int __init nicstar_init(void
  	XPRINTK("nicstar: nicstar_init() returned.\n");
  
  	if (!error) {
++<<<<<<< HEAD
 +		init_timer(&ns_timer);
++=======
+ 		timer_setup(&ns_timer, ns_poll, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  		ns_timer.expires = jiffies + NS_POLL_PERIOD;
 +		ns_timer.data = 0UL;
 +		ns_timer.function = ns_poll;
  		add_timer(&ns_timer);
  	}
  
diff --cc drivers/block/DAC960.c
index eb3950113e42,442e777bdfb2..000000000000
--- a/drivers/block/DAC960.c
+++ b/drivers/block/DAC960.c
@@@ -3076,11 -3079,10 +3076,16 @@@ DAC960_InitializeController(DAC960_Cont
        /*
  	Initialize the Monitoring Timer.
        */
++<<<<<<< HEAD
 +      init_timer(&Controller->MonitoringTimer);
++=======
+       timer_setup(&Controller->MonitoringTimer,
+                   DAC960_MonitoringTimerFunction, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
        Controller->MonitoringTimer.expires =
  	jiffies + DAC960_MonitoringTimerInterval;
 +      Controller->MonitoringTimer.data = (unsigned long) Controller;
 +      Controller->MonitoringTimer.function = DAC960_MonitoringTimerFunction;
        add_timer(&Controller->MonitoringTimer);
        Controller->ControllerInitialized = true;
        return true;
diff --cc drivers/block/sunvdc.c
index 5814deb6963d,5ca56bfae63c..000000000000
--- a/drivers/block/sunvdc.c
+++ b/drivers/block/sunvdc.c
@@@ -65,12 -73,15 +65,18 @@@ struct vdc_port 
  	u64			operations;
  	u32			vdisk_size;
  	u8			vdisk_type;
 -	u8			vdisk_mtype;
 -	u32			vdisk_phys_blksz;
  
  	char			disk_name[32];
 -};
  
++<<<<<<< HEAD
 +	struct vio_disk_geom	geom;
 +	struct vio_disk_vtoc	label;
 +};
++=======
+ static void vdc_ldc_reset(struct vdc_port *port);
+ static void vdc_ldc_reset_work(struct work_struct *work);
+ static void vdc_ldc_reset_timer(struct timer_list *t);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  static inline struct vdc_port *to_vdc_port(struct vio_driver_state *vio)
  {
@@@ -765,6 -966,16 +771,19 @@@ static int vdc_port_probe(struct vio_de
  	else
  		snprintf(port->disk_name, sizeof(port->disk_name),
  			 VDCBLK_NAME "%c", 'a' + ((int)vdev->dev_no % 26));
++<<<<<<< HEAD
++=======
+ 	port->vdisk_size = -1;
+ 
+ 	/* Actual wall time may be double due to do_generic_file_read() doing
+ 	 * a readahead I/O first, and once that fails it will try to read a
+ 	 * single page.
+ 	 */
+ 	ldc_timeout = mdesc_get_property(hp, vdev->mp, "vdc-timeout", NULL);
+ 	port->ldc_timeout = ldc_timeout ? *ldc_timeout : 0;
+ 	timer_setup(&port->ldc_reset_timer, vdc_ldc_reset_timer, 0);
+ 	INIT_WORK(&port->ldc_reset_work, vdc_ldc_reset_work);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	err = vio_driver_init(&port->vio, vdev, VDEV_DISK,
  			      vdc_versions, ARRAY_SIZE(vdc_versions),
@@@ -826,6 -1053,102 +845,105 @@@ static int vdc_port_remove(struct vio_d
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void vdc_requeue_inflight(struct vdc_port *port)
+ {
+ 	struct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];
+ 	u32 idx;
+ 
+ 	for (idx = dr->cons; idx != dr->prod; idx = vio_dring_next(dr, idx)) {
+ 		struct vio_disk_desc *desc = vio_dring_entry(dr, idx);
+ 		struct vdc_req_entry *rqe = &port->rq_arr[idx];
+ 		struct request *req;
+ 
+ 		ldc_unmap(port->vio.lp, desc->cookies, desc->ncookies);
+ 		desc->hdr.state = VIO_DESC_FREE;
+ 		dr->cons = vio_dring_next(dr, idx);
+ 
+ 		req = rqe->req;
+ 		if (req == NULL) {
+ 			vdc_end_special(port, desc);
+ 			continue;
+ 		}
+ 
+ 		rqe->req = NULL;
+ 		blk_requeue_request(port->disk->queue, req);
+ 	}
+ }
+ 
+ static void vdc_queue_drain(struct vdc_port *port)
+ {
+ 	struct request *req;
+ 
+ 	while ((req = blk_fetch_request(port->disk->queue)) != NULL)
+ 		__blk_end_request_all(req, BLK_STS_IOERR);
+ }
+ 
+ static void vdc_ldc_reset_timer(struct timer_list *t)
+ {
+ 	struct vdc_port *port = from_timer(port, t, ldc_reset_timer);
+ 	struct vio_driver_state *vio = &port->vio;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&vio->lock, flags);
+ 	if (!(port->vio.hs_state & VIO_HS_COMPLETE)) {
+ 		pr_warn(PFX "%s ldc down %llu seconds, draining queue\n",
+ 			port->disk_name, port->ldc_timeout);
+ 		vdc_queue_drain(port);
+ 		vdc_blk_queue_start(port);
+ 	}
+ 	spin_unlock_irqrestore(&vio->lock, flags);
+ }
+ 
+ static void vdc_ldc_reset_work(struct work_struct *work)
+ {
+ 	struct vdc_port *port;
+ 	struct vio_driver_state *vio;
+ 	unsigned long flags;
+ 
+ 	port = container_of(work, struct vdc_port, ldc_reset_work);
+ 	vio = &port->vio;
+ 
+ 	spin_lock_irqsave(&vio->lock, flags);
+ 	vdc_ldc_reset(port);
+ 	spin_unlock_irqrestore(&vio->lock, flags);
+ }
+ 
+ static void vdc_ldc_reset(struct vdc_port *port)
+ {
+ 	int err;
+ 
+ 	assert_spin_locked(&port->vio.lock);
+ 
+ 	pr_warn(PFX "%s ldc link reset\n", port->disk_name);
+ 	blk_stop_queue(port->disk->queue);
+ 	vdc_requeue_inflight(port);
+ 	vdc_port_down(port);
+ 
+ 	err = vio_ldc_alloc(&port->vio, &vdc_ldc_cfg, port);
+ 	if (err) {
+ 		pr_err(PFX "%s vio_ldc_alloc:%d\n", port->disk_name, err);
+ 		return;
+ 	}
+ 
+ 	err = vdc_alloc_tx_ring(port);
+ 	if (err) {
+ 		pr_err(PFX "%s vio_alloc_tx_ring:%d\n", port->disk_name, err);
+ 		goto err_free_ldc;
+ 	}
+ 
+ 	if (port->ldc_timeout)
+ 		mod_timer(&port->ldc_reset_timer,
+ 			  round_jiffies(jiffies + HZ * port->ldc_timeout));
+ 	mod_timer(&port->vio.timer, round_jiffies(jiffies + HZ));
+ 	return;
+ 
+ err_free_ldc:
+ 	vio_ldc_free(&port->vio);
+ }
+ 
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  static const struct vio_device_id vdc_port_match[] = {
  	{
  		.type = "vdc-port",
diff --cc drivers/block/umem.c
index ad70868f8a96,8077123678ad..000000000000
--- a/drivers/block/umem.c
+++ b/drivers/block/umem.c
@@@ -741,8 -738,7 +741,12 @@@ static void check_all_batteries(struct 
  
  static void init_battery_timer(void)
  {
++<<<<<<< HEAD
 +	init_timer(&battery_timer);
 +	battery_timer.function = check_all_batteries;
++=======
+ 	timer_setup(&battery_timer, check_all_batteries, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	battery_timer.expires = jiffies + (HZ * 60);
  	add_timer(&battery_timer);
  }
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 709742a62b66,779869ed32b1..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -1148,11 -1091,9 +1148,15 @@@ static void set_need_watch(void *send_i
  	spin_unlock_irqrestore(&smi_info->si_lock, flags);
  }
  
++<<<<<<< HEAD
 +static int initialized;
 +
 +static void smi_timeout(unsigned long data)
++=======
+ static void smi_timeout(struct timer_list *t)
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  {
- 	struct smi_info   *smi_info = (struct smi_info *) data;
+ 	struct smi_info   *smi_info = from_timer(smi_info, t, si_timer);
  	enum si_sm_result smi_result;
  	unsigned long     flags;
  	unsigned long     jiffies_now;
diff --cc drivers/gpu/drm/exynos/exynos_drm_vidi.c
index 24376c194a5e,e6b0940b1ac2..000000000000
--- a/drivers/gpu/drm/exynos/exynos_drm_vidi.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_vidi.c
@@@ -242,89 -108,16 +242,95 @@@ static int vidi_enable_vblank(struct de
  	return 0;
  }
  
 -static void vidi_disable_vblank(struct exynos_drm_crtc *crtc)
 +static void vidi_disable_vblank(struct device *dev)
  {
 +	struct vidi_context *ctx = get_vidi_context(dev);
 +
 +	DRM_DEBUG_KMS("%s\n", __FILE__);
 +
 +	if (ctx->suspended)
 +		return;
 +
 +	if (test_and_clear_bit(0, &ctx->irq_flags))
 +		ctx->vblank_on = false;
 +}
 +
 +static struct exynos_drm_manager_ops vidi_manager_ops = {
 +	.dpms = vidi_dpms,
 +	.apply = vidi_apply,
 +	.commit = vidi_commit,
 +	.enable_vblank = vidi_enable_vblank,
 +	.disable_vblank = vidi_disable_vblank,
 +};
 +
++<<<<<<< HEAD
 +static void vidi_win_mode_set(struct device *dev,
 +			      struct exynos_drm_overlay *overlay)
 +{
 +	struct vidi_context *ctx = get_vidi_context(dev);
 +	struct vidi_win_data *win_data;
 +	int win;
 +	unsigned long offset;
++=======
++static void vidi_fake_vblank_timer(struct timer_list *t)
++{
++	struct vidi_context *ctx = from_timer(ctx, t, timer);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
 +
 +	DRM_DEBUG_KMS("%s\n", __FILE__);
 +
 +	if (!overlay) {
 +		dev_err(dev, "overlay is NULL\n");
 +		return;
 +	}
 +
 +	win = overlay->zpos;
 +	if (win == DEFAULT_ZPOS)
 +		win = ctx->default_win;
 +
 +	if (win < 0 || win > WINDOWS_NR)
 +		return;
 +
 +	offset = overlay->fb_x * (overlay->bpp >> 3);
 +	offset += overlay->fb_y * overlay->pitch;
 +
 +	DRM_DEBUG_KMS("offset = 0x%lx, pitch = %x\n", offset, overlay->pitch);
 +
 +	win_data = &ctx->win_data[win];
 +
 +	win_data->offset_x = overlay->crtc_x;
 +	win_data->offset_y = overlay->crtc_y;
 +	win_data->ovl_width = overlay->crtc_width;
 +	win_data->ovl_height = overlay->crtc_height;
 +	win_data->fb_width = overlay->fb_width;
 +	win_data->fb_height = overlay->fb_height;
 +	win_data->dma_addr = overlay->dma_addr[0] + offset;
 +	win_data->bpp = overlay->bpp;
 +	win_data->buf_offsize = (overlay->fb_width - overlay->crtc_width) *
 +				(overlay->bpp >> 3);
 +	win_data->line_size = overlay->crtc_width * (overlay->bpp >> 3);
 +
 +	/*
 +	 * some parts of win_data should be transferred to user side
 +	 * through specific ioctl.
 +	 */
 +
 +	DRM_DEBUG_KMS("offset_x = %d, offset_y = %d\n",
 +			win_data->offset_x, win_data->offset_y);
 +	DRM_DEBUG_KMS("ovl_width = %d, ovl_height = %d\n",
 +			win_data->ovl_width, win_data->ovl_height);
 +	DRM_DEBUG_KMS("paddr = 0x%lx\n", (unsigned long)win_data->dma_addr);
 +	DRM_DEBUG_KMS("fb_width = %d, crtc_width = %d\n",
 +			overlay->fb_width, overlay->crtc_width);
  }
  
 -static void vidi_update_plane(struct exynos_drm_crtc *crtc,
 -			      struct exynos_drm_plane *plane)
 +static void vidi_win_commit(struct device *dev, int zpos)
  {
 -	struct drm_plane_state *state = plane->base.state;
 -	struct vidi_context *ctx = crtc->ctx;
 -	dma_addr_t addr;
 +	struct vidi_context *ctx = get_vidi_context(dev);
 +	struct vidi_win_data *win_data;
 +	int win = zpos;
 +
 +	DRM_DEBUG_KMS("%s\n", __FILE__);
  
  	if (ctx->suspended)
  		return;
@@@ -585,38 -271,80 +591,42 @@@ int vidi_connection_ioctl(struct drm_de
  	return 0;
  }
  
 -static enum drm_connector_status vidi_detect(struct drm_connector *connector,
 -			bool force)
 -{
 -	struct vidi_context *ctx = ctx_from_connector(connector);
 -
 -	/*
 -	 * connection request would come from user side
 -	 * to do hotplug through specific ioctl.
 -	 */
 -	return ctx->connected ? connector_status_connected :
 -			connector_status_disconnected;
 -}
 -
 -static void vidi_connector_destroy(struct drm_connector *connector)
 +static int vidi_probe(struct platform_device *pdev)
  {
 -}
 -
 -static const struct drm_connector_funcs vidi_connector_funcs = {
 -	.fill_modes = drm_helper_probe_single_connector_modes,
 -	.detect = vidi_detect,
 -	.destroy = vidi_connector_destroy,
 -	.reset = drm_atomic_helper_connector_reset,
 -	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
 -	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
 -};
 +	struct device *dev = &pdev->dev;
 +	struct vidi_context *ctx;
 +	struct exynos_drm_subdrv *subdrv;
 +	int ret;
  
 -static int vidi_get_modes(struct drm_connector *connector)
 -{
 -	struct vidi_context *ctx = ctx_from_connector(connector);
 -	struct edid *edid;
 -	int edid_len;
 +	DRM_DEBUG_KMS("%s\n", __FILE__);
  
 -	/*
 -	 * the edid data comes from user side and it would be set
 -	 * to ctx->raw_edid through specific ioctl.
 -	 */
 -	if (!ctx->raw_edid) {
 -		DRM_DEBUG_KMS("raw_edid is null.\n");
 -		return -EFAULT;
 -	}
 -
 -	edid_len = (1 + ctx->raw_edid->extensions) * EDID_LENGTH;
 -	edid = kmemdup(ctx->raw_edid, edid_len, GFP_KERNEL);
 -	if (!edid) {
 -		DRM_DEBUG_KMS("failed to allocate edid\n");
 +	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
 +	if (!ctx)
  		return -ENOMEM;
 -	}
  
 -	drm_mode_connector_update_edid_property(connector, edid);
 +	ctx->default_win = 0;
  
 -	return drm_add_edid_modes(connector, edid);
 -}
++<<<<<<< HEAD
 +	INIT_WORK(&ctx->work, vidi_fake_vblank_handler);
  
 -static const struct drm_connector_helper_funcs vidi_connector_helper_funcs = {
 -	.get_modes = vidi_get_modes,
 -};
 +	subdrv = &ctx->subdrv;
 +	subdrv->dev = dev;
 +	subdrv->manager = &vidi_manager;
 +	subdrv->probe = vidi_subdrv_probe;
 +	subdrv->remove = vidi_subdrv_remove;
++=======
++	timer_setup(&ctx->timer, vidi_fake_vblank_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
 -static int vidi_create_connector(struct drm_encoder *encoder)
 -{
 -	struct vidi_context *ctx = encoder_to_vidi(encoder);
 -	struct drm_connector *connector = &ctx->connector;
 -	int ret;
 +	mutex_init(&ctx->lock);
  
 -	connector->polled = DRM_CONNECTOR_POLL_HPD;
 +	platform_set_drvdata(pdev, ctx);
  
 -	ret = drm_connector_init(ctx->drm_dev, connector,
 -			&vidi_connector_funcs, DRM_MODE_CONNECTOR_VIRTUAL);
 -	if (ret) {
 -		DRM_ERROR("Failed to initialize connector with drm\n");
 -		return ret;
 -	}
 +	ret = device_create_file(dev, &dev_attr_connection);
 +	if (ret < 0)
 +		DRM_INFO("failed to create connection sysfs.\n");
  
 -	drm_connector_helper_add(connector, &vidi_connector_helper_funcs);
 -	drm_mode_connector_attach_encoder(connector, encoder);
 +	exynos_drm_subdrv_register(subdrv);
  
  	return 0;
  }
diff --cc drivers/hid/hid-wiimote-core.c
index ef71ef0c4a8d,579884ebd94d..000000000000
--- a/drivers/hid/hid-wiimote-core.c
+++ b/drivers/hid/hid-wiimote-core.c
@@@ -423,237 -474,751 +423,258 @@@ static int wiimote_battery_get_property
  	if (ret)
  		return ret;
  
 -	return 0;
 -}
 -
 -/* requires the cmd-mutex to be held */
 -static bool wiimote_cmd_map_mp(struct wiimote_data *wdata, __u8 exttype)
 -{
 -	__u8 wmem;
 -
 -	/* map MP with correct pass-through mode */
 -	switch (exttype) {
 -	case WIIMOTE_EXT_CLASSIC_CONTROLLER:
 -		wmem = 0x07;
 -		break;
 -	case WIIMOTE_EXT_NUNCHUK:
 -		wmem = 0x05;
 -		break;
 -	default:
 -		wmem = 0x04;
 -		break;
 +	switch (psp) {
 +		case POWER_SUPPLY_PROP_CAPACITY:
 +			val->intval = state * 100 / 255;
 +			break;
 +		default:
 +			ret = -EINVAL;
 +			break;
  	}
  
 -	return wiimote_cmd_write(wdata, 0xa600fe, &wmem, sizeof(wmem));
 +	return ret;
  }
  
 -/* requires the cmd-mutex to be held */
 -static bool wiimote_cmd_read_mp(struct wiimote_data *wdata, __u8 *rmem)
 +static int wiimote_init_ir(struct wiimote_data *wdata, __u16 mode)
  {
  	int ret;
 +	unsigned long flags;
 +	__u8 format = 0;
 +	static const __u8 data_enable[] = { 0x01 };
 +	static const __u8 data_sens1[] = { 0x02, 0x00, 0x00, 0x71, 0x01,
 +						0x00, 0xaa, 0x00, 0x64 };
 +	static const __u8 data_sens2[] = { 0x63, 0x03 };
 +	static const __u8 data_fin[] = { 0x08 };
  
 -	/* read motion plus ID */
 -	ret = wiimote_cmd_read(wdata, 0xa600fa, rmem, 6);
 -	if (ret != 6)
 -		return false;
 -
 -	hid_dbg(wdata->hdev, "motion plus ID: %6phC\n", rmem);
 -
 -	if (rmem[5] == 0x05)
 -		return true;
 -
 -	hid_info(wdata->hdev, "unknown motion plus ID: %6phC\n", rmem);
 -
 -	return false;
 -}
 +	spin_lock_irqsave(&wdata->state.lock, flags);
  
 -/* requires the cmd-mutex to be held */
 -static __u8 wiimote_cmd_read_mp_mapped(struct wiimote_data *wdata)
++<<<<<<< HEAD
 +	if (mode == (wdata->state.flags & WIIPROTO_FLAGS_IR)) {
 +		spin_unlock_irqrestore(&wdata->state.lock, flags);
 +		return 0;
++=======
++static void wiimote_init_timeout(struct timer_list *t)
+ {
 -	int ret;
 -	__u8 rmem[6];
 -
 -	/* read motion plus ID */
 -	ret = wiimote_cmd_read(wdata, 0xa400fa, rmem, 6);
 -	if (ret != 6)
 -		return WIIMOTE_MP_NONE;
 -
 -	hid_dbg(wdata->hdev, "mapped motion plus ID: %6phC\n", rmem);
 -
 -	if (rmem[0] == 0xff && rmem[1] == 0xff && rmem[2] == 0xff &&
 -	    rmem[3] == 0xff && rmem[4] == 0xff && rmem[5] == 0xff)
 -		return WIIMOTE_MP_NONE;
 -
 -	if (rmem[4] == 0x04 && rmem[5] == 0x05)
 -		return WIIMOTE_MP_SINGLE;
 -	else if (rmem[4] == 0x05 && rmem[5] == 0x05)
 -		return WIIMOTE_MP_PASSTHROUGH_NUNCHUK;
 -	else if (rmem[4] == 0x07 && rmem[5] == 0x05)
 -		return WIIMOTE_MP_PASSTHROUGH_CLASSIC;
++	struct wiimote_data *wdata = from_timer(wdata, t, timer);
+ 
 -	return WIIMOTE_MP_UNKNOWN;
++	wiimote_schedule(wdata);
+ }
+ 
 -/* device module handling */
 -
 -static const __u8 * const wiimote_devtype_mods[WIIMOTE_DEV_NUM] = {
 -	[WIIMOTE_DEV_PENDING] = (const __u8[]){
 -		WIIMOD_NULL,
 -	},
 -	[WIIMOTE_DEV_UNKNOWN] = (const __u8[]){
 -		WIIMOD_NO_MP,
 -		WIIMOD_NULL,
 -	},
 -	[WIIMOTE_DEV_GENERIC] = (const __u8[]){
 -		WIIMOD_KEYS,
 -		WIIMOD_RUMBLE,
 -		WIIMOD_BATTERY,
 -		WIIMOD_LED1,
 -		WIIMOD_LED2,
 -		WIIMOD_LED3,
 -		WIIMOD_LED4,
 -		WIIMOD_ACCEL,
 -		WIIMOD_IR,
 -		WIIMOD_NULL,
 -	},
 -	[WIIMOTE_DEV_GEN10] = (const __u8[]){
 -		WIIMOD_KEYS,
 -		WIIMOD_RUMBLE,
 -		WIIMOD_BATTERY,
 -		WIIMOD_LED1,
 -		WIIMOD_LED2,
 -		WIIMOD_LED3,
 -		WIIMOD_LED4,
 -		WIIMOD_ACCEL,
 -		WIIMOD_IR,
 -		WIIMOD_NULL,
 -	},
 -	[WIIMOTE_DEV_GEN20] = (const __u8[]){
 -		WIIMOD_KEYS,
 -		WIIMOD_RUMBLE,
 -		WIIMOD_BATTERY,
 -		WIIMOD_LED1,
 -		WIIMOD_LED2,
 -		WIIMOD_LED3,
 -		WIIMOD_LED4,
 -		WIIMOD_ACCEL,
 -		WIIMOD_IR,
 -		WIIMOD_BUILTIN_MP,
 -		WIIMOD_NULL,
 -	},
 -	[WIIMOTE_DEV_BALANCE_BOARD] = (const __u8[]) {
 -		WIIMOD_BATTERY,
 -		WIIMOD_LED1,
 -		WIIMOD_NO_MP,
 -		WIIMOD_NULL,
 -	},
 -	[WIIMOTE_DEV_PRO_CONTROLLER] = (const __u8[]) {
 -		WIIMOD_BATTERY,
 -		WIIMOD_LED1,
 -		WIIMOD_LED2,
 -		WIIMOD_LED3,
 -		WIIMOD_LED4,
 -		WIIMOD_NO_MP,
 -		WIIMOD_NULL,
 -	},
 -};
++/* protocol handlers */
+ 
 -static void wiimote_modules_load(struct wiimote_data *wdata,
 -				 unsigned int devtype)
++static void handler_keys(struct wiimote_data *wdata, const __u8 *payload)
+ {
 -	bool need_input = false;
 -	const __u8 *mods, *iter;
++	const __u8 *iter, *mods;
+ 	const struct wiimod_ops *ops;
 -	int ret;
+ 
 -	mods = wiimote_devtype_mods[devtype];
 -
 -	for (iter = mods; *iter != WIIMOD_NULL; ++iter) {
 -		if (wiimod_table[*iter]->flags & WIIMOD_FLAG_INPUT) {
 -			need_input = true;
 -			break;
 -		}
 -	}
 -
 -	if (need_input) {
 -		wdata->input = input_allocate_device();
 -		if (!wdata->input)
 -			return;
 -
 -		input_set_drvdata(wdata->input, wdata);
 -		wdata->input->dev.parent = &wdata->hdev->dev;
 -		wdata->input->id.bustype = wdata->hdev->bus;
 -		wdata->input->id.vendor = wdata->hdev->vendor;
 -		wdata->input->id.product = wdata->hdev->product;
 -		wdata->input->id.version = wdata->hdev->version;
 -		wdata->input->name = WIIMOTE_NAME;
 -	}
 -
 -	for (iter = mods; *iter != WIIMOD_NULL; ++iter) {
 -		ops = wiimod_table[*iter];
 -		if (!ops->probe)
 -			continue;
 -
 -		ret = ops->probe(ops, wdata);
 -		if (ret)
 -			goto error;
 -	}
 -
 -	if (wdata->input) {
 -		ret = input_register_device(wdata->input);
 -		if (ret)
 -			goto error;
 -	}
 -
 -	spin_lock_irq(&wdata->state.lock);
 -	wdata->state.devtype = devtype;
 -	spin_unlock_irq(&wdata->state.lock);
 -	return;
 -
 -error:
 -	for ( ; iter-- != mods; ) {
 -		ops = wiimod_table[*iter];
 -		if (ops->remove)
 -			ops->remove(ops, wdata);
++	ops = wiimod_ext_table[wdata->state.exttype];
++	if (ops->in_keys) {
++		ops->in_keys(wdata, payload);
++		return;
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	}
  
 -	if (wdata->input) {
 -		input_free_device(wdata->input);
 -		wdata->input = NULL;
 +	if (mode == 0) {
 +		wdata->state.flags &= ~WIIPROTO_FLAGS_IR;
 +		wiiproto_req_ir1(wdata, 0);
 +		wiiproto_req_ir2(wdata, 0);
 +		wiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);
 +		spin_unlock_irqrestore(&wdata->state.lock, flags);
 +		return 0;
  	}
 -}
  
 -static void wiimote_modules_unload(struct wiimote_data *wdata)
 -{
 -	const __u8 *mods, *iter;
 -	const struct wiimod_ops *ops;
 -	unsigned long flags;
 +	spin_unlock_irqrestore(&wdata->state.lock, flags);
  
 -	mods = wiimote_devtype_mods[wdata->state.devtype];
 +	ret = wiimote_cmd_acquire(wdata);
 +	if (ret)
 +		return ret;
  
 +	/* send PIXEL CLOCK ENABLE cmd first */
  	spin_lock_irqsave(&wdata->state.lock, flags);
 -	wdata->state.devtype = WIIMOTE_DEV_UNKNOWN;
 +	wiimote_cmd_set(wdata, WIIPROTO_REQ_IR1, 0);
 +	wiiproto_req_ir1(wdata, 0x06);
  	spin_unlock_irqrestore(&wdata->state.lock, flags);
  
 -	/* find end of list */
 -	for (iter = mods; *iter != WIIMOD_NULL; ++iter)
 -		/* empty */ ;
 -
 -	if (wdata->input) {
 -		input_get_device(wdata->input);
 -		input_unregister_device(wdata->input);
 +	ret = wiimote_cmd_wait(wdata);
 +	if (ret)
 +		goto unlock;
 +	if (wdata->state.cmd_err) {
 +		ret = -EIO;
 +		goto unlock;
  	}
  
 -	for ( ; iter-- != mods; ) {
 -		ops = wiimod_table[*iter];
 -		if (ops->remove)
 -			ops->remove(ops, wdata);
 -	}
 +	/* enable IR LOGIC */
 +	spin_lock_irqsave(&wdata->state.lock, flags);
 +	wiimote_cmd_set(wdata, WIIPROTO_REQ_IR2, 0);
 +	wiiproto_req_ir2(wdata, 0x06);
 +	spin_unlock_irqrestore(&wdata->state.lock, flags);
  
 -	if (wdata->input) {
 -		input_put_device(wdata->input);
 -		wdata->input = NULL;
 +	ret = wiimote_cmd_wait(wdata);
 +	if (ret)
 +		goto unlock;
 +	if (wdata->state.cmd_err) {
 +		ret = -EIO;
 +		goto unlock;
  	}
 -}
  
 -/* device extension handling */
 +	/* enable IR cam but do not make it send data, yet */
 +	ret = wiimote_cmd_write(wdata, 0xb00030, data_enable,
 +							sizeof(data_enable));
 +	if (ret)
 +		goto unlock;
  
 -static void wiimote_ext_load(struct wiimote_data *wdata, unsigned int ext)
 -{
 -	unsigned long flags;
 -	const struct wiimod_ops *ops;
 -	int ret;
 +	/* write first sensitivity block */
 +	ret = wiimote_cmd_write(wdata, 0xb00000, data_sens1,
 +							sizeof(data_sens1));
 +	if (ret)
 +		goto unlock;
  
 -	ops = wiimod_ext_table[ext];
 +	/* write second sensitivity block */
 +	ret = wiimote_cmd_write(wdata, 0xb0001a, data_sens2,
 +							sizeof(data_sens2));
 +	if (ret)
 +		goto unlock;
  
 -	if (ops->probe) {
 -		ret = ops->probe(ops, wdata);
 -		if (ret)
 -			ext = WIIMOTE_EXT_UNKNOWN;
 +	/* put IR cam into desired state */
 +	switch (mode) {
 +		case WIIPROTO_FLAG_IR_FULL:
 +			format = 5;
 +			break;
 +		case WIIPROTO_FLAG_IR_EXT:
 +			format = 3;
 +			break;
 +		case WIIPROTO_FLAG_IR_BASIC:
 +			format = 1;
 +			break;
  	}
 +	ret = wiimote_cmd_write(wdata, 0xb00033, &format, sizeof(format));
 +	if (ret)
 +		goto unlock;
  
 -	spin_lock_irqsave(&wdata->state.lock, flags);
 -	wdata->state.exttype = ext;
 -	spin_unlock_irqrestore(&wdata->state.lock, flags);
 -}
 -
 -static void wiimote_ext_unload(struct wiimote_data *wdata)
 -{
 -	unsigned long flags;
 -	const struct wiimod_ops *ops;
 -
 -	ops = wiimod_ext_table[wdata->state.exttype];
 +	/* make IR cam send data */
 +	ret = wiimote_cmd_write(wdata, 0xb00030, data_fin, sizeof(data_fin));
 +	if (ret)
 +		goto unlock;
  
 +	/* request new DRM mode compatible to IR mode */
  	spin_lock_irqsave(&wdata->state.lock, flags);
 -	wdata->state.exttype = WIIMOTE_EXT_UNKNOWN;
 -	wdata->state.flags &= ~WIIPROTO_FLAG_EXT_USED;
 +	wdata->state.flags &= ~WIIPROTO_FLAGS_IR;
 +	wdata->state.flags |= mode & WIIPROTO_FLAGS_IR;
 +	wiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);
  	spin_unlock_irqrestore(&wdata->state.lock, flags);
  
 -	if (ops->remove)
 -		ops->remove(ops, wdata);
 +unlock:
 +	wiimote_cmd_release(wdata);
 +	return ret;
  }
  
 -static void wiimote_mp_load(struct wiimote_data *wdata)
 +static enum led_brightness wiimote_leds_get(struct led_classdev *led_dev)
  {
 +	struct wiimote_data *wdata;
 +	struct device *dev = led_dev->dev->parent;
 +	int i;
  	unsigned long flags;
 -	const struct wiimod_ops *ops;
 -	int ret;
 -	__u8 mode = 2;
 +	bool value = false;
 +
 +	wdata = hid_get_drvdata(container_of(dev, struct hid_device, dev));
  
 -	ops = &wiimod_mp;
 -	if (ops->probe) {
 -		ret = ops->probe(ops, wdata);
 -		if (ret)
 -			mode = 1;
 +	for (i = 0; i < 4; ++i) {
 +		if (wdata->leds[i] == led_dev) {
 +			spin_lock_irqsave(&wdata->state.lock, flags);
 +			value = wdata->state.flags & WIIPROTO_FLAG_LED(i + 1);
 +			spin_unlock_irqrestore(&wdata->state.lock, flags);
 +			break;
 +		}
  	}
  
 -	spin_lock_irqsave(&wdata->state.lock, flags);
 -	wdata->state.mp = mode;
 -	spin_unlock_irqrestore(&wdata->state.lock, flags);
 +	return value ? LED_FULL : LED_OFF;
  }
  
 -static void wiimote_mp_unload(struct wiimote_data *wdata)
 +static void wiimote_leds_set(struct led_classdev *led_dev,
 +						enum led_brightness value)
  {
 +	struct wiimote_data *wdata;
 +	struct device *dev = led_dev->dev->parent;
 +	int i;
  	unsigned long flags;
 -	const struct wiimod_ops *ops;
 -
 -	if (wdata->state.mp < 2)
 -		return;
 +	__u8 state, flag;
  
 -	ops = &wiimod_mp;
 +	wdata = hid_get_drvdata(container_of(dev, struct hid_device, dev));
  
 -	spin_lock_irqsave(&wdata->state.lock, flags);
 -	wdata->state.mp = 0;
 -	wdata->state.flags &= ~WIIPROTO_FLAG_MP_USED;
 -	spin_unlock_irqrestore(&wdata->state.lock, flags);
 -
 -	if (ops->remove)
 -		ops->remove(ops, wdata);
 -}
 -
 -/* device (re-)initialization and detection */
 -
 -static const char *wiimote_devtype_names[WIIMOTE_DEV_NUM] = {
 -	[WIIMOTE_DEV_PENDING] = "Pending",
 -	[WIIMOTE_DEV_UNKNOWN] = "Unknown",
 -	[WIIMOTE_DEV_GENERIC] = "Generic",
 -	[WIIMOTE_DEV_GEN10] = "Nintendo Wii Remote (Gen 1)",
 -	[WIIMOTE_DEV_GEN20] = "Nintendo Wii Remote Plus (Gen 2)",
 -	[WIIMOTE_DEV_BALANCE_BOARD] = "Nintendo Wii Balance Board",
 -	[WIIMOTE_DEV_PRO_CONTROLLER] = "Nintendo Wii U Pro Controller",
 -};
 -
 -/* Try to guess the device type based on all collected information. We
 - * first try to detect by static extension types, then VID/PID and the
 - * device name. If we cannot detect the device, we use
 - * WIIMOTE_DEV_GENERIC so all modules will get probed on the device. */
 -static void wiimote_init_set_type(struct wiimote_data *wdata,
 -				  __u8 exttype)
 -{
 -	__u8 devtype = WIIMOTE_DEV_GENERIC;
 -	__u16 vendor, product;
 -	const char *name;
 -
 -	vendor = wdata->hdev->vendor;
 -	product = wdata->hdev->product;
 -	name = wdata->hdev->name;
 -
 -	if (exttype == WIIMOTE_EXT_BALANCE_BOARD) {
 -		devtype = WIIMOTE_DEV_BALANCE_BOARD;
 -		goto done;
 -	} else if (exttype == WIIMOTE_EXT_PRO_CONTROLLER) {
 -		devtype = WIIMOTE_DEV_PRO_CONTROLLER;
 -		goto done;
 -	}
 -
 -	if (!strcmp(name, "Nintendo RVL-CNT-01")) {
 -		devtype = WIIMOTE_DEV_GEN10;
 -		goto done;
 -	} else if (!strcmp(name, "Nintendo RVL-CNT-01-TR")) {
 -		devtype = WIIMOTE_DEV_GEN20;
 -		goto done;
 -	} else if (!strcmp(name, "Nintendo RVL-WBC-01")) {
 -		devtype = WIIMOTE_DEV_BALANCE_BOARD;
 -		goto done;
 -	} else if (!strcmp(name, "Nintendo RVL-CNT-01-UC")) {
 -		devtype = WIIMOTE_DEV_PRO_CONTROLLER;
 -		goto done;
 -	}
 -
 -	if (vendor == USB_VENDOR_ID_NINTENDO) {
 -		if (product == USB_DEVICE_ID_NINTENDO_WIIMOTE) {
 -			devtype = WIIMOTE_DEV_GEN10;
 -			goto done;
 -		} else if (product == USB_DEVICE_ID_NINTENDO_WIIMOTE2) {
 -			devtype = WIIMOTE_DEV_GEN20;
 -			goto done;
 +	for (i = 0; i < 4; ++i) {
 +		if (wdata->leds[i] == led_dev) {
 +			flag = WIIPROTO_FLAG_LED(i + 1);
 +			spin_lock_irqsave(&wdata->state.lock, flags);
 +			state = wdata->state.flags;
 +			if (value == LED_OFF)
 +				wiiproto_req_leds(wdata, state & ~flag);
 +			else
 +				wiiproto_req_leds(wdata, state | flag);
 +			spin_unlock_irqrestore(&wdata->state.lock, flags);
 +			break;
  		}
  	}
 -
 -done:
 -	if (devtype == WIIMOTE_DEV_GENERIC)
 -		hid_info(wdata->hdev, "cannot detect device; NAME: %s VID: %04x PID: %04x EXT: %04x\n",
 -			name, vendor, product, exttype);
 -	else
 -		hid_info(wdata->hdev, "detected device: %s\n",
 -			 wiimote_devtype_names[devtype]);
 -
 -	wiimote_modules_load(wdata, devtype);
  }
  
 -static void wiimote_init_detect(struct wiimote_data *wdata)
 +static int wiimote_ff_play(struct input_dev *dev, void *data,
 +							struct ff_effect *eff)
  {
 -	__u8 exttype = WIIMOTE_EXT_NONE, extdata[6];
 -	bool ext;
 -	int ret;
 -
 -	wiimote_cmd_acquire_noint(wdata);
 -
 -	spin_lock_irq(&wdata->state.lock);
 -	wdata->state.devtype = WIIMOTE_DEV_UNKNOWN;
 -	wiimote_cmd_set(wdata, WIIPROTO_REQ_SREQ, 0);
 -	wiiproto_req_status(wdata);
 -	spin_unlock_irq(&wdata->state.lock);
 -
 -	ret = wiimote_cmd_wait_noint(wdata);
 -	if (ret)
 -		goto out_release;
 -
 -	spin_lock_irq(&wdata->state.lock);
 -	ext = wdata->state.flags & WIIPROTO_FLAG_EXT_PLUGGED;
 -	spin_unlock_irq(&wdata->state.lock);
 -
 -	if (!ext)
 -		goto out_release;
 -
 -	wiimote_cmd_init_ext(wdata);
 -	exttype = wiimote_cmd_read_ext(wdata, extdata);
 -
 -out_release:
 -	wiimote_cmd_release(wdata);
 -	wiimote_init_set_type(wdata, exttype);
 -
 -	/* schedule MP timer */
 -	spin_lock_irq(&wdata->state.lock);
 -	if (!(wdata->state.flags & WIIPROTO_FLAG_BUILTIN_MP) &&
 -	    !(wdata->state.flags & WIIPROTO_FLAG_NO_MP))
 -		mod_timer(&wdata->timer, jiffies + HZ * 4);
 -	spin_unlock_irq(&wdata->state.lock);
 -}
 +	struct wiimote_data *wdata = input_get_drvdata(dev);
 +	__u8 value;
 +	unsigned long flags;
  
 -/*
 - * MP hotplug events are not generated by the wiimote. Therefore, we need
 - * polling to detect it. We use a 4s interval for polling MP registers. This
 - * seems reasonable considering applications can trigger it manually via
 - * sysfs requests.
 - */
 -static void wiimote_init_poll_mp(struct wiimote_data *wdata)
 -{
 -	bool mp;
 -	__u8 mpdata[6];
 +	/*
 +	 * The wiimote supports only a single rumble motor so if any magnitude
 +	 * is set to non-zero then we start the rumble motor. If both are set to
 +	 * zero, we stop the rumble motor.
 +	 */
  
 -	wiimote_cmd_acquire_noint(wdata);
 -	wiimote_cmd_init_mp(wdata);
 -	mp = wiimote_cmd_read_mp(wdata, mpdata);
 -	wiimote_cmd_release(wdata);
 +	if (eff->u.rumble.strong_magnitude || eff->u.rumble.weak_magnitude)
 +		value = 1;
 +	else
 +		value = 0;
  
 -	/* load/unload MP module if it changed */
 -	if (mp) {
 -		if (!wdata->state.mp) {
 -			hid_info(wdata->hdev, "detected extension: Nintendo Wii Motion Plus\n");
 -			wiimote_mp_load(wdata);
 -		}
 -	} else if (wdata->state.mp) {
 -		wiimote_mp_unload(wdata);
 -	}
 +	spin_lock_irqsave(&wdata->state.lock, flags);
 +	wiiproto_req_rumble(wdata, value);
 +	spin_unlock_irqrestore(&wdata->state.lock, flags);
  
 -	mod_timer(&wdata->timer, jiffies + HZ * 4);
 +	return 0;
  }
  
 -/*
 - * Check whether the wiimote is in the expected state. The extension registers
 - * may change during hotplug and initialization so we might get hotplug events
 - * that we caused by remapping some memory.
 - * We use some heuristics here to check known states. If the wiimote is in the
 - * expected state, we can ignore the hotplug event.
 - *
 - * Returns "true" if the device is in expected state, "false" if we should
 - * redo hotplug handling and extension initialization.
 - */
 -static bool wiimote_init_check(struct wiimote_data *wdata)
 +static int wiimote_input_open(struct input_dev *dev)
  {
 -	__u32 flags;
 -	__u8 type, data[6];
 -	bool ret, poll_mp;
 -
 -	spin_lock_irq(&wdata->state.lock);
 -	flags = wdata->state.flags;
 -	spin_unlock_irq(&wdata->state.lock);
 -
 -	wiimote_cmd_acquire_noint(wdata);
 -
 -	/* If MP is used and active, but the extension is not, we expect:
 -	 *   read_mp_mapped() == WIIMOTE_MP_SINGLE
 -	 *   state.flags == !EXT_ACTIVE && !MP_PLUGGED && MP_ACTIVE
 -	 * We do not check EXT_PLUGGED because it might change during
 -	 * initialization of MP without extensions.
 -	 *  - If MP is unplugged/replugged, read_mp_mapped() fails
 -	 *  - If EXT is plugged, MP_PLUGGED will get set */
 -	if (wdata->state.exttype == WIIMOTE_EXT_NONE &&
 -	    wdata->state.mp > 0 && (flags & WIIPROTO_FLAG_MP_USED)) {
 -		type = wiimote_cmd_read_mp_mapped(wdata);
 -		ret = type == WIIMOTE_MP_SINGLE;
 -
 -		spin_lock_irq(&wdata->state.lock);
 -		ret = ret && !(wdata->state.flags & WIIPROTO_FLAG_EXT_ACTIVE);
 -		ret = ret && !(wdata->state.flags & WIIPROTO_FLAG_MP_PLUGGED);
 -		ret = ret && (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE);
 -		spin_unlock_irq(&wdata->state.lock);
 -
 -		if (!ret)
 -			hid_dbg(wdata->hdev, "state left: !EXT && MP\n");
 -
 -		/* while MP is mapped, we get EXT_PLUGGED events */
 -		poll_mp = false;
 -
 -		goto out_release;
 -	}
 -
 -	/* If MP is unused, but the extension port is used, we expect:
 -	 *   read_ext == state.exttype
 -	 *   state.flags == !MP_ACTIVE && EXT_ACTIVE
 -	 * - If MP is plugged/unplugged, our timer detects it
 -	 * - If EXT is unplugged/replugged, EXT_ACTIVE will become unset */
 -	if (!(flags & WIIPROTO_FLAG_MP_USED) &&
 -	    wdata->state.exttype != WIIMOTE_EXT_NONE) {
 -		type = wiimote_cmd_read_ext(wdata, data);
 -		ret = type == wdata->state.exttype;
 -
 -		spin_lock_irq(&wdata->state.lock);
 -		ret = ret && !(wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE);
 -		ret = ret && (wdata->state.flags & WIIPROTO_FLAG_EXT_ACTIVE);
 -		spin_unlock_irq(&wdata->state.lock);
 -
 -		if (!ret)
 -			hid_dbg(wdata->hdev, "state left: EXT && !MP\n");
 -
 -		/* poll MP for hotplug events */
 -		poll_mp = true;
 +	struct wiimote_data *wdata = input_get_drvdata(dev);
  
 -		goto out_release;
 -	}
 -
 -	/* If neither MP nor an extension are used, we expect:
 -	 *   read_ext() == WIIMOTE_EXT_NONE
 -	 *   state.flags == !MP_ACTIVE && !EXT_ACTIVE && !EXT_PLUGGED
 -	 * No need to perform any action in this case as everything is
 -	 * disabled already.
 -	 * - If MP is plugged/unplugged, our timer detects it
 -	 * - If EXT is plugged, EXT_PLUGGED will be set */
 -	if (!(flags & WIIPROTO_FLAG_MP_USED) &&
 -	    wdata->state.exttype == WIIMOTE_EXT_NONE) {
 -		type = wiimote_cmd_read_ext(wdata, data);
 -		ret = type == wdata->state.exttype;
 -
 -		spin_lock_irq(&wdata->state.lock);
 -		ret = ret && !(wdata->state.flags & WIIPROTO_FLAG_EXT_ACTIVE);
 -		ret = ret && !(wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE);
 -		ret = ret && !(wdata->state.flags & WIIPROTO_FLAG_EXT_PLUGGED);
 -		spin_unlock_irq(&wdata->state.lock);
 -
 -		if (!ret)
 -			hid_dbg(wdata->hdev, "state left: !EXT && !MP\n");
 -
 -		/* poll MP for hotplug events */
 -		poll_mp = true;
 -
 -		goto out_release;
 -	}
 -
 -	/* The trickiest part is if both EXT and MP are active. We cannot read
 -	 * the EXT ID, anymore, because MP is mapped over it. However, we use
 -	 * a handy trick here:
 -	 *   - EXT_ACTIVE is unset whenever !MP_PLUGGED is sent
 -	 * MP_PLUGGED might be re-sent again before we are scheduled, but
 -	 * EXT_ACTIVE will stay unset.
 -	 * So it is enough to check for mp_mapped() and MP_ACTIVE and
 -	 * EXT_ACTIVE. EXT_PLUGGED is a sanity check. */
 -	if (wdata->state.exttype != WIIMOTE_EXT_NONE &&
 -	    wdata->state.mp > 0 && (flags & WIIPROTO_FLAG_MP_USED)) {
 -		type = wiimote_cmd_read_mp_mapped(wdata);
 -		ret = type != WIIMOTE_MP_NONE;
 -		ret = ret && type != WIIMOTE_MP_UNKNOWN;
 -		ret = ret && type != WIIMOTE_MP_SINGLE;
 -
 -		spin_lock_irq(&wdata->state.lock);
 -		ret = ret && (wdata->state.flags & WIIPROTO_FLAG_EXT_PLUGGED);
 -		ret = ret && (wdata->state.flags & WIIPROTO_FLAG_EXT_ACTIVE);
 -		ret = ret && (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE);
 -		spin_unlock_irq(&wdata->state.lock);
 -
 -		if (!ret)
 -			hid_dbg(wdata->hdev, "state left: EXT && MP\n");
 -
 -		/* while MP is mapped, we get EXT_PLUGGED events */
 -		poll_mp = false;
 -
 -		goto out_release;
 -	}
 -
 -	/* unknown state */
 -	ret = false;
 -
 -out_release:
 -	wiimote_cmd_release(wdata);
 -
 -	/* only poll for MP if requested and if state didn't change */
 -	if (ret && poll_mp && !(flags & WIIPROTO_FLAG_BUILTIN_MP) &&
 -	    !(flags & WIIPROTO_FLAG_NO_MP))
 -		wiimote_init_poll_mp(wdata);
 -
 -	return ret;
 +	return hid_hw_open(wdata->hdev);
  }
  
 -static const char *wiimote_exttype_names[WIIMOTE_EXT_NUM] = {
 -	[WIIMOTE_EXT_NONE] = "None",
 -	[WIIMOTE_EXT_UNKNOWN] = "Unknown",
 -	[WIIMOTE_EXT_NUNCHUK] = "Nintendo Wii Nunchuk",
 -	[WIIMOTE_EXT_CLASSIC_CONTROLLER] = "Nintendo Wii Classic Controller",
 -	[WIIMOTE_EXT_BALANCE_BOARD] = "Nintendo Wii Balance Board",
 -	[WIIMOTE_EXT_PRO_CONTROLLER] = "Nintendo Wii U Pro Controller",
 -};
 -
 -/*
 - * Handle hotplug events
 - * If we receive an hotplug event and the device-check failed, we deinitialize
 - * the extension ports, re-read all extension IDs and set the device into
 - * the desired state. This involves mapping MP into the main extension
 - * registers, setting up extension passthrough modes and initializing the
 - * requested extensions.
 - */
 -static void wiimote_init_hotplug(struct wiimote_data *wdata)
 +static void wiimote_input_close(struct input_dev *dev)
  {
 -	__u8 exttype, extdata[6], mpdata[6];
 -	__u32 flags;
 -	bool mp;
 -
 -	hid_dbg(wdata->hdev, "detect extensions..\n");
 -
 -	wiimote_cmd_acquire_noint(wdata);
 -
 -	spin_lock_irq(&wdata->state.lock);
 -
 -	/* get state snapshot that we will then work on */
 -	flags = wdata->state.flags;
 -
 -	/* disable event forwarding temporarily */
 -	wdata->state.flags &= ~WIIPROTO_FLAG_EXT_ACTIVE;
 -	wdata->state.flags &= ~WIIPROTO_FLAG_MP_ACTIVE;
 -
 -	spin_unlock_irq(&wdata->state.lock);
 -
 -	/* init extension and MP (deactivates current extension or MP) */
 -	wiimote_cmd_init_ext(wdata);
 -	if (flags & WIIPROTO_FLAG_NO_MP) {
 -		mp = false;
 -	} else {
 -		wiimote_cmd_init_mp(wdata);
 -		mp = wiimote_cmd_read_mp(wdata, mpdata);
 -	}
 -	exttype = wiimote_cmd_read_ext(wdata, extdata);
 +	struct wiimote_data *wdata = input_get_drvdata(dev);
  
 -	wiimote_cmd_release(wdata);
 -
 -	/* load/unload extension module if it changed */
 -	if (exttype != wdata->state.exttype) {
 -		/* unload previous extension */
 -		wiimote_ext_unload(wdata);
 -
 -		if (exttype == WIIMOTE_EXT_UNKNOWN) {
 -			hid_info(wdata->hdev, "cannot detect extension; %6phC\n",
 -				 extdata);
 -		} else if (exttype == WIIMOTE_EXT_NONE) {
 -			spin_lock_irq(&wdata->state.lock);
 -			wdata->state.exttype = WIIMOTE_EXT_NONE;
 -			spin_unlock_irq(&wdata->state.lock);
 -		} else {
 -			hid_info(wdata->hdev, "detected extension: %s\n",
 -				 wiimote_exttype_names[exttype]);
 -			/* try loading new extension */
 -			wiimote_ext_load(wdata, exttype);
 -		}
 -	}
 -
 -	/* load/unload MP module if it changed */
 -	if (mp) {
 -		if (!wdata->state.mp) {
 -			hid_info(wdata->hdev, "detected extension: Nintendo Wii Motion Plus\n");
 -			wiimote_mp_load(wdata);
 -		}
 -	} else if (wdata->state.mp) {
 -		wiimote_mp_unload(wdata);
 -	}
 -
 -	/* if MP is not used, do not map or activate it */
 -	if (!(flags & WIIPROTO_FLAG_MP_USED))
 -		mp = false;
 -
 -	/* map MP into main extension registers if used */
 -	if (mp) {
 -		wiimote_cmd_acquire_noint(wdata);
 -		wiimote_cmd_map_mp(wdata, exttype);
 -		wiimote_cmd_release(wdata);
 -
 -		/* delete MP hotplug timer */
 -		del_timer_sync(&wdata->timer);
 -	} else {
 -		/* reschedule MP hotplug timer */
 -		if (!(flags & WIIPROTO_FLAG_BUILTIN_MP) &&
 -		    !(flags & WIIPROTO_FLAG_NO_MP))
 -			mod_timer(&wdata->timer, jiffies + HZ * 4);
 -	}
 -
 -	spin_lock_irq(&wdata->state.lock);
 -
 -	/* enable data forwarding again and set expected hotplug state */
 -	if (mp) {
 -		wdata->state.flags |= WIIPROTO_FLAG_MP_ACTIVE;
 -		if (wdata->state.exttype == WIIMOTE_EXT_NONE) {
 -			wdata->state.flags &= ~WIIPROTO_FLAG_EXT_PLUGGED;
 -			wdata->state.flags &= ~WIIPROTO_FLAG_MP_PLUGGED;
 -		} else {
 -			wdata->state.flags &= ~WIIPROTO_FLAG_EXT_PLUGGED;
 -			wdata->state.flags |= WIIPROTO_FLAG_MP_PLUGGED;
 -			wdata->state.flags |= WIIPROTO_FLAG_EXT_ACTIVE;
 -		}
 -	} else if (wdata->state.exttype != WIIMOTE_EXT_NONE) {
 -		wdata->state.flags |= WIIPROTO_FLAG_EXT_ACTIVE;
 -	}
 -
 -	/* request status report for hotplug state updates */
 -	wiiproto_req_status(wdata);
 -
 -	spin_unlock_irq(&wdata->state.lock);
 -
 -	hid_dbg(wdata->hdev, "detected extensions: MP: %d EXT: %d\n",
 -		wdata->state.mp, wdata->state.exttype);
 +	hid_hw_close(wdata->hdev);
  }
  
 -static void wiimote_init_worker(struct work_struct *work)
 +static int wiimote_accel_open(struct input_dev *dev)
  {
 -	struct wiimote_data *wdata = container_of(work, struct wiimote_data,
 -						  init_worker);
 -	bool changed = false;
 -
 -	if (wdata->state.devtype == WIIMOTE_DEV_PENDING) {
 -		wiimote_init_detect(wdata);
 -		changed = true;
 -	}
 +	struct wiimote_data *wdata = input_get_drvdata(dev);
 +	int ret;
 +	unsigned long flags;
  
 -	if (changed || !wiimote_init_check(wdata))
 -		wiimote_init_hotplug(wdata);
 +	ret = hid_hw_open(wdata->hdev);
 +	if (ret)
 +		return ret;
  
 -	if (changed)
 -		kobject_uevent(&wdata->hdev->dev.kobj, KOBJ_CHANGE);
 -}
 +	spin_lock_irqsave(&wdata->state.lock, flags);
 +	wiiproto_req_accel(wdata, true);
 +	spin_unlock_irqrestore(&wdata->state.lock, flags);
  
 -void __wiimote_schedule(struct wiimote_data *wdata)
 -{
 -	if (!(wdata->state.flags & WIIPROTO_FLAG_EXITING))
 -		schedule_work(&wdata->init_worker);
 +	return 0;
  }
  
 -static void wiimote_schedule(struct wiimote_data *wdata)
 +static void wiimote_accel_close(struct input_dev *dev)
  {
 +	struct wiimote_data *wdata = input_get_drvdata(dev);
  	unsigned long flags;
  
  	spin_lock_irqsave(&wdata->state.lock, flags);
@@@ -1163,16 -1737,12 +1184,23 @@@ static struct wiimote_data *wiimote_cre
  	init_completion(&wdata->state.ready);
  	mutex_init(&wdata->state.sync);
  	wdata->state.drm = WIIPROTO_REQ_DRM_K;
++<<<<<<< HEAD
++=======
+ 	wdata->state.cmd_battery = 0xff;
+ 
+ 	INIT_WORK(&wdata->init_worker, wiimote_init_worker);
+ 	timer_setup(&wdata->timer, wiimote_init_timeout, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	return wdata;
 +
 +err_ir:
 +	input_free_device(wdata->accel);
 +err_input:
 +	input_free_device(wdata->input);
 +err:
 +	kfree(wdata);
 +	return NULL;
  }
  
  static void wiimote_destroy(struct wiimote_data *wdata)
diff --cc drivers/input/gameport/gameport.c
index da739d9d1905,73862a836062..000000000000
--- a/drivers/input/gameport/gameport.c
+++ b/drivers/input/gameport/gameport.c
@@@ -502,9 -542,7 +502,13 @@@ static void gameport_init_port(struct g
  
  	INIT_LIST_HEAD(&gameport->node);
  	spin_lock_init(&gameport->timer_lock);
++<<<<<<< HEAD
 +	init_timer(&gameport->poll_timer);
 +	gameport->poll_timer.function = gameport_run_poll_handler;
 +	gameport->poll_timer.data = (unsigned long)gameport;
++=======
+ 	timer_setup(&gameport->poll_timer, gameport_run_poll_handler, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  }
  
  /*
diff --cc drivers/input/joystick/db9.c
index 8e7de5c7754f,de0dd4756c84..000000000000
--- a/drivers/input/joystick/db9.c
+++ b/drivers/input/joystick/db9.c
@@@ -601,9 -608,8 +601,14 @@@ static struct db9 __init *db9_probe(in
  	mutex_init(&db9->mutex);
  	db9->pd = pd;
  	db9->mode = mode;
++<<<<<<< HEAD
 +	init_timer(&db9->timer);
 +	db9->timer.data = (long) db9;
 +	db9->timer.function = db9_timer;
++=======
+ 	db9->parportno = pp->number;
+ 	timer_setup(&db9->timer, db9_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	for (i = 0; i < (min(db9_mode->n_pads, DB9_MAX_DEVICES)); i++) {
  
diff --cc drivers/input/joystick/gamecon.c
index e68e49786483,2ffb2e8bdc3b..000000000000
--- a/drivers/input/joystick/gamecon.c
+++ b/drivers/input/joystick/gamecon.c
@@@ -958,7 -973,8 +958,12 @@@ static struct gc __init *gc_probe(int p
  
  	mutex_init(&gc->mutex);
  	gc->pd = pd;
++<<<<<<< HEAD
 +	setup_timer(&gc->timer, gc_timer, (long) gc);
++=======
+ 	gc->parportno = pp->number;
+ 	timer_setup(&gc->timer, gc_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	for (i = 0; i < n_pads && i < GC_MAX_DEVICES; i++) {
  		if (!pads[i])
diff --cc drivers/input/joystick/turbografx.c
index 27b6a3ce18ca,e2685753e460..000000000000
--- a/drivers/input/joystick/turbografx.c
+++ b/drivers/input/joystick/turbografx.c
@@@ -188,9 -199,8 +188,14 @@@ static struct tgfx __init *tgfx_probe(i
  
  	mutex_init(&tgfx->sem);
  	tgfx->pd = pd;
++<<<<<<< HEAD
 +	init_timer(&tgfx->timer);
 +	tgfx->timer.data = (long) tgfx;
 +	tgfx->timer.function = tgfx_timer;
++=======
+ 	tgfx->parportno = pp->number;
+ 	timer_setup(&tgfx->timer, tgfx_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	for (i = 0; i < n_devs; i++) {
  		if (n_buttons[i] < 1)
diff --cc drivers/iommu/iova.c
index f106fd9782bf,83fe2621effe..000000000000
--- a/drivers/iommu/iova.c
+++ b/drivers/iommu/iova.c
@@@ -31,6 -35,8 +31,11 @@@ static unsigned long iova_rcache_get(st
  				     unsigned long limit_pfn);
  static void init_iova_rcaches(struct iova_domain *iovad);
  static void free_iova_rcaches(struct iova_domain *iovad);
++<<<<<<< HEAD
++=======
+ static void fq_destroy_all_entries(struct iova_domain *iovad);
+ static void fq_flush_timeout(struct timer_list *t);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  void
  init_iova_domain(struct iova_domain *iovad, unsigned long granule,
@@@ -53,19 -65,62 +58,71 @@@
  }
  EXPORT_SYMBOL_GPL(init_iova_domain);
  
++<<<<<<< HEAD
++=======
+ static void free_iova_flush_queue(struct iova_domain *iovad)
+ {
+ 	if (!iovad->fq)
+ 		return;
+ 
+ 	if (timer_pending(&iovad->fq_timer))
+ 		del_timer(&iovad->fq_timer);
+ 
+ 	fq_destroy_all_entries(iovad);
+ 
+ 	free_percpu(iovad->fq);
+ 
+ 	iovad->fq         = NULL;
+ 	iovad->flush_cb   = NULL;
+ 	iovad->entry_dtor = NULL;
+ }
+ 
+ int init_iova_flush_queue(struct iova_domain *iovad,
+ 			  iova_flush_cb flush_cb, iova_entry_dtor entry_dtor)
+ {
+ 	int cpu;
+ 
+ 	atomic64_set(&iovad->fq_flush_start_cnt,  0);
+ 	atomic64_set(&iovad->fq_flush_finish_cnt, 0);
+ 
+ 	iovad->fq = alloc_percpu(struct iova_fq);
+ 	if (!iovad->fq)
+ 		return -ENOMEM;
+ 
+ 	iovad->flush_cb   = flush_cb;
+ 	iovad->entry_dtor = entry_dtor;
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		struct iova_fq *fq;
+ 
+ 		fq = per_cpu_ptr(iovad->fq, cpu);
+ 		fq->head = 0;
+ 		fq->tail = 0;
+ 
+ 		spin_lock_init(&fq->lock);
+ 	}
+ 
+ 	timer_setup(&iovad->fq_timer, fq_flush_timeout, 0);
+ 	atomic_set(&iovad->fq_timer_on, 0);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(init_iova_flush_queue);
+ 
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  static struct rb_node *
 -__get_cached_rbnode(struct iova_domain *iovad, unsigned long limit_pfn)
 +__get_cached_rbnode(struct iova_domain *iovad, unsigned long *limit_pfn)
  {
 -	if (limit_pfn <= iovad->dma_32bit_pfn)
 -		return iovad->cached32_node;
 -
 -	return iovad->cached_node;
 +	if ((*limit_pfn != iovad->dma_32bit_pfn) ||
 +		(iovad->cached32_node == NULL))
 +		return rb_last(&iovad->rbroot);
 +	else {
 +		struct rb_node *prev_node = rb_prev(iovad->cached32_node);
 +		struct iova *curr_iova =
 +			container_of(iovad->cached32_node, struct iova, node);
 +		*limit_pfn = curr_iova->pfn_lo - 1;
 +		return prev_node;
 +	}
  }
  
  static void
@@@ -449,6 -448,133 +506,136 @@@ free_iova_fast(struct iova_domain *iova
  }
  EXPORT_SYMBOL_GPL(free_iova_fast);
  
++<<<<<<< HEAD
++=======
+ #define fq_ring_for_each(i, fq) \
+ 	for ((i) = (fq)->head; (i) != (fq)->tail; (i) = ((i) + 1) % IOVA_FQ_SIZE)
+ 
+ static inline bool fq_full(struct iova_fq *fq)
+ {
+ 	assert_spin_locked(&fq->lock);
+ 	return (((fq->tail + 1) % IOVA_FQ_SIZE) == fq->head);
+ }
+ 
+ static inline unsigned fq_ring_add(struct iova_fq *fq)
+ {
+ 	unsigned idx = fq->tail;
+ 
+ 	assert_spin_locked(&fq->lock);
+ 
+ 	fq->tail = (idx + 1) % IOVA_FQ_SIZE;
+ 
+ 	return idx;
+ }
+ 
+ static void fq_ring_free(struct iova_domain *iovad, struct iova_fq *fq)
+ {
+ 	u64 counter = atomic64_read(&iovad->fq_flush_finish_cnt);
+ 	unsigned idx;
+ 
+ 	assert_spin_locked(&fq->lock);
+ 
+ 	fq_ring_for_each(idx, fq) {
+ 
+ 		if (fq->entries[idx].counter >= counter)
+ 			break;
+ 
+ 		if (iovad->entry_dtor)
+ 			iovad->entry_dtor(fq->entries[idx].data);
+ 
+ 		free_iova_fast(iovad,
+ 			       fq->entries[idx].iova_pfn,
+ 			       fq->entries[idx].pages);
+ 
+ 		fq->head = (fq->head + 1) % IOVA_FQ_SIZE;
+ 	}
+ }
+ 
+ static void iova_domain_flush(struct iova_domain *iovad)
+ {
+ 	atomic64_inc(&iovad->fq_flush_start_cnt);
+ 	iovad->flush_cb(iovad);
+ 	atomic64_inc(&iovad->fq_flush_finish_cnt);
+ }
+ 
+ static void fq_destroy_all_entries(struct iova_domain *iovad)
+ {
+ 	int cpu;
+ 
+ 	/*
+ 	 * This code runs when the iova_domain is being detroyed, so don't
+ 	 * bother to free iovas, just call the entry_dtor on all remaining
+ 	 * entries.
+ 	 */
+ 	if (!iovad->entry_dtor)
+ 		return;
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		struct iova_fq *fq = per_cpu_ptr(iovad->fq, cpu);
+ 		int idx;
+ 
+ 		fq_ring_for_each(idx, fq)
+ 			iovad->entry_dtor(fq->entries[idx].data);
+ 	}
+ }
+ 
+ static void fq_flush_timeout(struct timer_list *t)
+ {
+ 	struct iova_domain *iovad = from_timer(iovad, t, fq_timer);
+ 	int cpu;
+ 
+ 	atomic_set(&iovad->fq_timer_on, 0);
+ 	iova_domain_flush(iovad);
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		unsigned long flags;
+ 		struct iova_fq *fq;
+ 
+ 		fq = per_cpu_ptr(iovad->fq, cpu);
+ 		spin_lock_irqsave(&fq->lock, flags);
+ 		fq_ring_free(iovad, fq);
+ 		spin_unlock_irqrestore(&fq->lock, flags);
+ 	}
+ }
+ 
+ void queue_iova(struct iova_domain *iovad,
+ 		unsigned long pfn, unsigned long pages,
+ 		unsigned long data)
+ {
+ 	struct iova_fq *fq = raw_cpu_ptr(iovad->fq);
+ 	unsigned long flags;
+ 	unsigned idx;
+ 
+ 	spin_lock_irqsave(&fq->lock, flags);
+ 
+ 	/*
+ 	 * First remove all entries from the flush queue that have already been
+ 	 * flushed out on another CPU. This makes the fq_full() check below less
+ 	 * likely to be true.
+ 	 */
+ 	fq_ring_free(iovad, fq);
+ 
+ 	if (fq_full(fq)) {
+ 		iova_domain_flush(iovad);
+ 		fq_ring_free(iovad, fq);
+ 	}
+ 
+ 	idx = fq_ring_add(fq);
+ 
+ 	fq->entries[idx].iova_pfn = pfn;
+ 	fq->entries[idx].pages    = pages;
+ 	fq->entries[idx].data     = data;
+ 	fq->entries[idx].counter  = atomic64_read(&iovad->fq_flush_start_cnt);
+ 
+ 	spin_unlock_irqrestore(&fq->lock, flags);
+ 
+ 	if (atomic_cmpxchg(&iovad->fq_timer_on, 0, 1) == 0)
+ 		mod_timer(&iovad->fq_timer,
+ 			  jiffies + msecs_to_jiffies(IOVA_FQ_TIMEOUT));
+ }
+ EXPORT_SYMBOL_GPL(queue_iova);
+ 
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  /**
   * put_iova_domain - destroys the iova doamin
   * @iovad: - iova domain in question.
diff --cc drivers/isdn/capi/capidrv.c
index cc9f1927a322,49fef08858c5..000000000000
--- a/drivers/isdn/capi/capidrv.c
+++ b/drivers/isdn/capi/capidrv.c
@@@ -2053,7 -2264,7 +2053,11 @@@ static int capidrv_addcontr(u16 contr, 
  		return -1;
  	}
  	card->owner = THIS_MODULE;
++<<<<<<< HEAD
 +	init_timer(&card->listentimer);
++=======
+ 	timer_setup(&card->listentimer, listentimerfunc, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	strcpy(card->name, id);
  	card->contrnr = contr;
  	card->nbchan = profp->nbchannel;
diff --cc drivers/isdn/divert/isdn_divert.c
index 50749a70c5ca,5620fd2c6009..000000000000
--- a/drivers/isdn/divert/isdn_divert.c
+++ b/drivers/isdn/divert/isdn_divert.c
@@@ -157,10 -157,8 +157,14 @@@ int cf_command(int drvid, int mode
  	/* allocate mem for information struct */
  	if (!(cs = kmalloc(sizeof(struct call_struc), GFP_ATOMIC)))
  		return (-ENOMEM); /* no memory */
++<<<<<<< HEAD
 +	init_timer(&cs->timer);
++=======
+ 	timer_setup(&cs->timer, deflect_timer_expire, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	cs->info[0] = '\0';
 +	cs->timer.function = deflect_timer_expire;
 +	cs->timer.data = (ulong) cs; /* pointer to own structure */
  	cs->ics.driver = drvid;
  	cs->ics.command = ISDN_CMD_PROT_IO; /* protocol specific io */
  	cs->ics.arg = DSS1_CMD_INVOKE; /* invoke supplementary service */
@@@ -452,10 -450,8 +456,14 @@@ static int isdn_divert_icall(isdn_ctrl 
  					return (0); /* no external deflection needed */
  			if (!(cs = kmalloc(sizeof(struct call_struc), GFP_ATOMIC)))
  				return (0); /* no memory */
++<<<<<<< HEAD
 +			init_timer(&cs->timer);
++=======
+ 			timer_setup(&cs->timer, deflect_timer_expire, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  			cs->info[0] = '\0';
 +			cs->timer.function = deflect_timer_expire;
 +			cs->timer.data = (ulong) cs; /* pointer to own structure */
  
  			cs->ics = *ic; /* copy incoming data */
  			if (!cs->ics.parm.setup.phone[0]) strcpy(cs->ics.parm.setup.phone, "0");
diff --cc drivers/isdn/hardware/eicon/divasi.c
index 4103a8c178d7,0033d74a7291..000000000000
--- a/drivers/isdn/hardware/eicon/divasi.c
+++ b/drivers/isdn/hardware/eicon/divasi.c
@@@ -300,9 -300,7 +300,13 @@@ static int um_idi_open_adapter(struct f
  	p_os = (diva_um_idi_os_context_t *) diva_um_id_get_os_context(e);
  	init_waitqueue_head(&p_os->read_wait);
  	init_waitqueue_head(&p_os->close_wait);
++<<<<<<< HEAD
 +	init_timer(&p_os->diva_timer_id);
 +	p_os->diva_timer_id.function = (void *) diva_um_timer_function;
 +	p_os->diva_timer_id.data = (unsigned long) p_os;
++=======
+ 	timer_setup(&p_os->diva_timer_id, diva_um_timer_function, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	p_os->aborted = 0;
  	p_os->adapter_nr = adapter_nr;
  	return (1);
diff --cc drivers/isdn/hardware/mISDN/hfcmulti.c
index 28543d795188,4d85645c87f7..000000000000
--- a/drivers/isdn/hardware/mISDN/hfcmulti.c
+++ b/drivers/isdn/hardware/mISDN/hfcmulti.c
@@@ -3878,9 -3877,7 +3878,13 @@@ hfcmulti_initmode(struct dchannel *dch
  		if (hc->dnum[pt]) {
  			mode_hfcmulti(hc, dch->slot, dch->dev.D.protocol,
  				      -1, 0, -1, 0);
++<<<<<<< HEAD
 +			dch->timer.function = (void *) hfcmulti_dbusy_timer;
 +			dch->timer.data = (long) dch;
 +			init_timer(&dch->timer);
++=======
+ 			timer_setup(&dch->timer, hfcmulti_dbusy_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  		}
  		for (i = 1; i <= 31; i++) {
  			if (!((1 << i) & hc->bmask[pt])) /* skip unused chan */
@@@ -3986,9 -3983,7 +3990,13 @@@
  		hc->chan[i].slot_rx = -1;
  		hc->chan[i].conf = -1;
  		mode_hfcmulti(hc, i, dch->dev.D.protocol, -1, 0, -1, 0);
++<<<<<<< HEAD
 +		dch->timer.function = (void *) hfcmulti_dbusy_timer;
 +		dch->timer.data = (long) dch;
 +		init_timer(&dch->timer);
++=======
+ 		timer_setup(&dch->timer, hfcmulti_dbusy_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  		hc->chan[i - 2].slot_tx = -1;
  		hc->chan[i - 2].slot_rx = -1;
  		hc->chan[i - 2].conf = -1;
diff --cc drivers/isdn/hardware/mISDN/hfcpci.c
index eab9167937e2,ba3fe14bbe00..000000000000
--- a/drivers/isdn/hardware/mISDN/hfcpci.c
+++ b/drivers/isdn/hardware/mISDN/hfcpci.c
@@@ -1717,9 -1717,7 +1717,13 @@@ static voi
  inithfcpci(struct hfc_pci *hc)
  {
  	printk(KERN_DEBUG "inithfcpci: entered\n");
++<<<<<<< HEAD
 +	hc->dch.timer.function = (void *) hfcpci_dbusy_timer;
 +	hc->dch.timer.data = (long) &hc->dch;
 +	init_timer(&hc->dch.timer);
++=======
+ 	timer_setup(&hc->dch.timer, hfcpci_dbusy_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	hc->chanlimit = 2;
  	mode_hfcpci(&hc->bch[0], 1, -1);
  	mode_hfcpci(&hc->bch[1], 2, -1);
diff --cc drivers/isdn/hardware/mISDN/mISDNisar.c
index feafa91c2ed9,b791688d0228..000000000000
--- a/drivers/isdn/hardware/mISDN/mISDNisar.c
+++ b/drivers/isdn/hardware/mISDN/mISDNisar.c
@@@ -1635,13 -1635,9 +1635,19 @@@ init_isar(struct isar_hw *isar
  	}
  	if (isar->version != 1)
  		return -EINVAL;
++<<<<<<< HEAD
 +	isar->ch[0].ftimer.function = &ftimer_handler;
 +	isar->ch[0].ftimer.data = (long)&isar->ch[0];
 +	init_timer(&isar->ch[0].ftimer);
 +	test_and_set_bit(FLG_INITIALIZED, &isar->ch[0].bch.Flags);
 +	isar->ch[1].ftimer.function = &ftimer_handler;
 +	isar->ch[1].ftimer.data = (long)&isar->ch[1];
 +	init_timer(&isar->ch[1].ftimer);
++=======
+ 	timer_setup(&isar->ch[0].ftimer, ftimer_handler, 0);
+ 	test_and_set_bit(FLG_INITIALIZED, &isar->ch[0].bch.Flags);
+ 	timer_setup(&isar->ch[1].ftimer, ftimer_handler, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	test_and_set_bit(FLG_INITIALIZED, &isar->ch[1].bch.Flags);
  	return 0;
  }
diff --cc drivers/isdn/i4l/isdn_common.c
index 9bb12ba3191f,8b03d618185e..000000000000
--- a/drivers/isdn/i4l/isdn_common.c
+++ b/drivers/isdn/i4l/isdn_common.c
@@@ -2308,8 -2294,7 +2308,12 @@@ static int __init isdn_init(void
  		printk(KERN_WARNING "isdn: Could not allocate device-struct.\n");
  		return -EIO;
  	}
++<<<<<<< HEAD
 +	init_timer(&dev->timer);
 +	dev->timer.function = isdn_timer_funct;
++=======
+ 	timer_setup(&dev->timer, isdn_timer_funct, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	spin_lock_init(&dev->lock);
  	spin_lock_init(&dev->timerlock);
  #ifdef MODULE
diff --cc drivers/isdn/i4l/isdn_net.c
index 04cd70e763c5,c138f66f2659..000000000000
--- a/drivers/isdn/i4l/isdn_net.c
+++ b/drivers/isdn/i4l/isdn_net.c
@@@ -1615,9 -1615,8 +1615,14 @@@ isdn_net_ciscohdlck_connected(isdn_net_
  	/* send slarp request because interface/seq.no.s reset */
  	isdn_net_ciscohdlck_slarp_send_request(lp);
  
++<<<<<<< HEAD
 +	init_timer(&lp->cisco_timer);
 +	lp->cisco_timer.data = (unsigned long) lp;
 +	lp->cisco_timer.function = isdn_net_ciscohdlck_slarp_send_keepalive;
++=======
+ 	timer_setup(&lp->cisco_timer,
+ 		    isdn_net_ciscohdlck_slarp_send_keepalive, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	lp->cisco_timer.expires = jiffies + lp->cisco_keepalive_period * HZ;
  	add_timer(&lp->cisco_timer);
  }
diff --cc drivers/isdn/i4l/isdn_ppp.c
index 8d2de72b972c,e07aefb9151d..000000000000
--- a/drivers/isdn/i4l/isdn_ppp.c
+++ b/drivers/isdn/i4l/isdn_ppp.c
@@@ -2341,9 -2376,7 +2341,13 @@@ static struct ippp_ccp_reset_state *isd
  		rs->state = CCPResetIdle;
  		rs->is = is;
  		rs->id = id;
++<<<<<<< HEAD
 +		init_timer(&rs->timer);
 +		rs->timer.data = (unsigned long)rs;
 +		rs->timer.function = isdn_ppp_ccp_timer_callback;
++=======
+ 		timer_setup(&rs->timer, isdn_ppp_ccp_timer_callback, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  		is->reset->rs[id] = rs;
  	}
  	return rs;
diff --cc drivers/isdn/i4l/isdn_tty.c
index 732f68a5c9c3,960f26348bb5..000000000000
--- a/drivers/isdn/i4l/isdn_tty.c
+++ b/drivers/isdn/i4l/isdn_tty.c
@@@ -1819,9 -1812,7 +1819,13 @@@ isdn_tty_modem_init(void
  		info->isdn_channel = -1;
  		info->drv_index = -1;
  		info->xmit_size = ISDN_SERIAL_XMIT_SIZE;
++<<<<<<< HEAD
 +		init_timer(&info->nc_timer);
 +		info->nc_timer.function = isdn_tty_modem_do_ncarrier;
 +		info->nc_timer.data = (unsigned long) info;
++=======
+ 		timer_setup(&info->nc_timer, isdn_tty_modem_do_ncarrier, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  		skb_queue_head_init(&info->xmit_queue);
  #ifdef CONFIG_ISDN_AUDIO
  		skb_queue_head_init(&info->dtmf_queue);
diff --cc drivers/media/platform/mem2mem_testdev.c
index 4cc7f65d7d76,7bf9fa2f8534..000000000000
--- a/drivers/media/platform/mem2mem_testdev.c
+++ b/drivers/media/platform/mem2mem_testdev.c
@@@ -395,14 -388,14 +395,20 @@@ static void device_run(void *priv
  	schedule_irq(dev, ctx->transtime);
  }
  
- static void device_isr(unsigned long priv)
+ static void device_isr(struct timer_list *t)
  {
++<<<<<<< HEAD:drivers/media/platform/mem2mem_testdev.c
 +	struct m2mtest_dev *m2mtest_dev = (struct m2mtest_dev *)priv;
 +	struct m2mtest_ctx *curr_ctx;
 +	struct vb2_buffer *src_vb, *dst_vb;
++=======
+ 	struct vim2m_dev *vim2m_dev = from_timer(vim2m_dev, t, timer);
+ 	struct vim2m_ctx *curr_ctx;
+ 	struct vb2_v4l2_buffer *src_vb, *dst_vb;
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup()):drivers/media/platform/vim2m.c
  	unsigned long flags;
  
 -	curr_ctx = v4l2_m2m_get_curr_priv(vim2m_dev->m2m_dev);
 +	curr_ctx = v4l2_m2m_get_curr_priv(m2mtest_dev->m2m_dev);
  
  	if (NULL == curr_ctx) {
  		pr_err("Instance released before the end of transaction\n");
@@@ -1059,12 -1020,11 +1065,12 @@@ static int m2mtest_probe(struct platfor
  	}
  
  	video_set_drvdata(vfd, dev);
 -	snprintf(vfd->name, sizeof(vfd->name), "%s", vim2m_videodev.name);
 -	v4l2_info(&dev->v4l2_dev,
 +	snprintf(vfd->name, sizeof(vfd->name), "%s", m2mtest_videodev.name);
 +	dev->vfd = vfd;
 +	v4l2_info(&dev->v4l2_dev, MEM2MEM_TEST_MODULE_NAME
  			"Device registered as /dev/video%d\n", vfd->num);
  
- 	setup_timer(&dev->timer, device_isr, (long)dev);
+ 	timer_setup(&dev->timer, device_isr, 0);
  	platform_set_drvdata(pdev, dev);
  
  	dev->m2m_dev = v4l2_m2m_init(&m2m_ops);
diff --cc drivers/media/platform/s5p-mfc/s5p_mfc.c
index d12faa691af8,bc68dbbcaec1..000000000000
--- a/drivers/media/platform/s5p-mfc/s5p_mfc.c
+++ b/drivers/media/platform/s5p-mfc/s5p_mfc.c
@@@ -105,9 -131,23 +105,27 @@@ static void wake_up_dev(struct s5p_mfc_
  	wake_up(&dev->queue);
  }
  
++<<<<<<< HEAD
 +static void s5p_mfc_watchdog(unsigned long arg)
++=======
+ void s5p_mfc_cleanup_queue(struct list_head *lh, struct vb2_queue *vq)
  {
- 	struct s5p_mfc_dev *dev = (struct s5p_mfc_dev *)arg;
+ 	struct s5p_mfc_buf *b;
+ 	int i;
+ 
+ 	while (!list_empty(lh)) {
+ 		b = list_entry(lh->next, struct s5p_mfc_buf, list);
+ 		for (i = 0; i < b->b->vb2_buf.num_planes; i++)
+ 			vb2_set_plane_payload(&b->b->vb2_buf, i, 0);
+ 		vb2_buffer_done(&b->b->vb2_buf, VB2_BUF_STATE_ERROR);
+ 		list_del(&b->list);
+ 	}
+ }
+ 
+ static void s5p_mfc_watchdog(struct timer_list *t)
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
+ {
+ 	struct s5p_mfc_dev *dev = from_timer(dev, t, watchdog_timer);
  
  	if (test_bit(0, &dev->hw_lock))
  		atomic_inc(&dev->watchdog_cnt);
@@@ -1140,10 -1310,11 +1158,18 @@@ static int s5p_mfc_probe(struct platfor
  	}
  
  	mutex_init(&dev->mfc_mutex);
++<<<<<<< HEAD
 +
 +	ret = s5p_mfc_alloc_firmware(dev);
 +	if (ret)
 +		goto err_alloc_fw;
++=======
+ 	init_waitqueue_head(&dev->queue);
+ 	dev->hw_lock = 0;
+ 	INIT_WORK(&dev->watchdog_work, s5p_mfc_watchdog_worker);
+ 	atomic_set(&dev->watchdog_cnt, 0);
+ 	timer_setup(&dev->watchdog_timer, s5p_mfc_watchdog, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
  	if (ret)
diff --cc drivers/media/usb/au0828/au0828-dvb.c
index 9a6f15613a38,d9093a3c57c5..000000000000
--- a/drivers/media/usb/au0828/au0828-dvb.c
+++ b/drivers/media/usb/au0828/au0828-dvb.c
@@@ -103,6 -105,15 +103,18 @@@ static struct tda18271_config hauppauge
  
  static void au0828_restart_dvb_streaming(struct work_struct *work);
  
++<<<<<<< HEAD
++=======
+ static void au0828_bulk_timeout(struct timer_list *t)
+ {
+ 	struct au0828_dev *dev = from_timer(dev, t, bulk_timeout);
+ 
+ 	dprintk(1, "%s called\n", __func__);
+ 	dev->bulk_timeout_running = 0;
+ 	schedule_work(&dev->restart_streaming);
+ }
+ 
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  /*-------------------------------------------------------------------*/
  static void urb_completion(struct urb *purb)
  {
@@@ -495,5 -647,48 +507,10 @@@ int au0828_dvb_register(struct au0828_d
  		return ret;
  	}
  
++<<<<<<< HEAD
++=======
+ 	timer_setup(&dev->bulk_timeout, au0828_bulk_timeout, 0);
+ 
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	return 0;
  }
 -
 -void au0828_dvb_suspend(struct au0828_dev *dev)
 -{
 -	struct au0828_dvb *dvb = &dev->dvb;
 -	int rc;
 -
 -	if (dvb->frontend) {
 -		if (dev->urb_streaming) {
 -			cancel_work_sync(&dev->restart_streaming);
 -			/* Stop transport */
 -			mutex_lock(&dvb->lock);
 -			stop_urb_transfer(dev);
 -			au0828_stop_transport(dev, 1);
 -			mutex_unlock(&dvb->lock);
 -			dev->need_urb_start = true;
 -		}
 -		/* suspend frontend - does tuner and fe to sleep */
 -		rc = dvb_frontend_suspend(dvb->frontend);
 -		pr_info("au0828_dvb_suspend(): Suspending DVB fe %d\n", rc);
 -	}
 -}
 -
 -void au0828_dvb_resume(struct au0828_dev *dev)
 -{
 -	struct au0828_dvb *dvb = &dev->dvb;
 -	int rc;
 -
 -	if (dvb->frontend) {
 -		/* resume frontend - does fe and tuner init */
 -		rc = dvb_frontend_resume(dvb->frontend);
 -		pr_info("au0828_dvb_resume(): Resuming DVB fe %d\n", rc);
 -		if (dev->need_urb_start) {
 -			/* Start transport */
 -			mutex_lock(&dvb->lock);
 -			au0828_start_transport(dev);
 -			start_urb_transfer(dev);
 -			mutex_unlock(&dvb->lock);
 -		}
 -	}
 -}
diff --cc drivers/media/usb/au0828/au0828-video.c
index 75ac9947cdac,a240153821e0..000000000000
--- a/drivers/media/usb/au0828/au0828-video.c
+++ b/drivers/media/usb/au0828/au0828-video.c
@@@ -2003,17 -1951,10 +2003,22 @@@ int au0828_analog_register(struct au082
  
  	/* init video dma queues */
  	INIT_LIST_HEAD(&dev->vidq.active);
 +	INIT_LIST_HEAD(&dev->vidq.queued);
  	INIT_LIST_HEAD(&dev->vbiq.active);
 +	INIT_LIST_HEAD(&dev->vbiq.queued);
  
++<<<<<<< HEAD
 +	dev->vid_timeout.function = au0828_vid_buffer_timeout;
 +	dev->vid_timeout.data = (unsigned long) dev;
 +	init_timer(&dev->vid_timeout);
 +
 +	dev->vbi_timeout.function = au0828_vbi_buffer_timeout;
 +	dev->vbi_timeout.data = (unsigned long) dev;
 +	init_timer(&dev->vbi_timeout);
++=======
+ 	timer_setup(&dev->vid_timeout, au0828_vid_buffer_timeout, 0);
+ 	timer_setup(&dev->vbi_timeout, au0828_vbi_buffer_timeout, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	dev->width = NTSC_STD_W;
  	dev->height = NTSC_STD_H;
diff --cc drivers/mmc/core/host.c
index d793f9c6e54a,64b03d6eaf18..000000000000
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@@ -384,7 -388,8 +384,12 @@@ struct mmc_host *mmc_alloc_host(int ext
  	spin_lock_init(&host->lock);
  	init_waitqueue_head(&host->wq);
  	INIT_DELAYED_WORK(&host->detect, mmc_rescan);
++<<<<<<< HEAD
 +	setup_timer(&host->retune_timer, mmc_retune_timer, (unsigned long)host);
++=======
+ 	INIT_DELAYED_WORK(&host->sdio_irq_work, sdio_irq_work);
+ 	timer_setup(&host->retune_timer, mmc_retune_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	/*
  	 * By default, hosts do not support SGIO or large requests.
diff --cc drivers/net/caif/caif_hsi.c
index 5e40a8b68cbe,b8029ea03307..000000000000
--- a/drivers/net/caif/caif_hsi.c
+++ b/drivers/net/caif/caif_hsi.c
@@@ -1215,17 -1211,11 +1215,25 @@@ static int cfhsi_open(struct net_devic
  	init_waitqueue_head(&cfhsi->flush_fifo_wait);
  
  	/* Setup the inactivity timer. */
++<<<<<<< HEAD
 +	init_timer(&cfhsi->inactivity_timer);
 +	cfhsi->inactivity_timer.data = (unsigned long)cfhsi;
 +	cfhsi->inactivity_timer.function = cfhsi_inactivity_tout;
 +	/* Setup the slowpath RX timer. */
 +	init_timer(&cfhsi->rx_slowpath_timer);
 +	cfhsi->rx_slowpath_timer.data = (unsigned long)cfhsi;
 +	cfhsi->rx_slowpath_timer.function = cfhsi_rx_slowpath;
 +	/* Setup the aggregation timer. */
 +	init_timer(&cfhsi->aggregation_timer);
 +	cfhsi->aggregation_timer.data = (unsigned long)cfhsi;
 +	cfhsi->aggregation_timer.function = cfhsi_aggregation_tout;
++=======
+ 	timer_setup(&cfhsi->inactivity_timer, cfhsi_inactivity_tout, 0);
+ 	/* Setup the slowpath RX timer. */
+ 	timer_setup(&cfhsi->rx_slowpath_timer, cfhsi_rx_slowpath, 0);
+ 	/* Setup the aggregation timer. */
+ 	timer_setup(&cfhsi->aggregation_timer, cfhsi_aggregation_tout, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	/* Activate HSI interface. */
  	res = cfhsi->ops->cfhsi_up(cfhsi->ops);
diff --cc drivers/net/eql.c
index e2f89dfc57f5,74263f8efe1a..000000000000
--- a/drivers/net/eql.c
+++ b/drivers/net/eql.c
@@@ -178,10 -178,8 +178,14 @@@ static void __init eql_setup(struct net
  {
  	equalizer_t *eql = netdev_priv(dev);
  
++<<<<<<< HEAD
 +	init_timer(&eql->timer);
 +	eql->timer.data     	= (unsigned long) eql;
++=======
+ 	timer_setup(&eql->timer, eql_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	eql->timer.expires  	= jiffies + EQL_DEFAULT_RESCHED_IVAL;
 +	eql->timer.function 	= eql_timer;
  
  	spin_lock_init(&eql->queue.lock);
  	INIT_LIST_HEAD(&eql->queue.all_slaves);
diff --cc drivers/net/ethernet/adi/bfin_mac.c
index dada66bfe0d6,7120f2b9c6ef..000000000000
--- a/drivers/net/ethernet/adi/bfin_mac.c
+++ b/drivers/net/ethernet/adi/bfin_mac.c
@@@ -1677,9 -1652,10 +1679,16 @@@ static int bfin_mac_probe(struct platfo
  	ndev->netdev_ops = &bfin_mac_netdev_ops;
  	ndev->ethtool_ops = &bfin_mac_ethtool_ops;
  
++<<<<<<< HEAD
 +	init_timer(&lp->tx_reclaim_timer);
 +	lp->tx_reclaim_timer.data = (unsigned long)lp;
 +	lp->tx_reclaim_timer.function = tx_reclaim_skb_timeout;
++=======
+ 	timer_setup(&lp->tx_reclaim_timer, tx_reclaim_skb_timeout, 0);
+ 
+ 	lp->flags = 0;
+ 	netif_napi_add(ndev, &lp->napi, bfin_mac_poll, CONFIG_BFIN_RX_DESC_NUM);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	spin_lock_init(&lp->lock);
  
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_nic.c
index 5c08679f0a07,78dfb2ab78ce..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
@@@ -165,13 -163,16 +165,18 @@@ static int aq_nic_update_link_status(st
  	return 0;
  }
  
- static void aq_nic_service_timer_cb(unsigned long param)
+ static void aq_nic_service_timer_cb(struct timer_list *t)
  {
++<<<<<<< HEAD
 +	struct aq_nic_s *self = (struct aq_nic_s *)param;
 +	int ctimer = AQ_CFG_SERVICE_TIMER_INTERVAL;
++=======
+ 	struct aq_nic_s *self = from_timer(self, t, service_timer);
+ 	struct net_device *ndev = aq_nic_get_ndev(self);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	int err = 0;
 -	unsigned int i = 0U;
 -	struct aq_ring_stats_rx_s stats_rx;
 -	struct aq_ring_stats_tx_s stats_tx;
  
 -	if (aq_utils_obj_test(&self->header.flags, AQ_NIC_FLAGS_IS_NOT_READY))
 +	if (aq_utils_obj_test(&self->flags, AQ_NIC_FLAGS_IS_NOT_READY))
  		goto err_exit;
  
  	err = aq_nic_update_link_status(self);
@@@ -181,19 -182,28 +186,19 @@@
  	if (self->aq_hw_ops.hw_update_stats)
  		self->aq_hw_ops.hw_update_stats(self->aq_hw);
  
 -	memset(&stats_rx, 0U, sizeof(struct aq_ring_stats_rx_s));
 -	memset(&stats_tx, 0U, sizeof(struct aq_ring_stats_tx_s));
 -	for (i = AQ_DIMOF(self->aq_vec); i--;) {
 -		if (self->aq_vec[i])
 -			aq_vec_add_stats(self->aq_vec[i], &stats_rx, &stats_tx);
 -	}
 +	aq_nic_update_ndev_stats(self);
  
 -	ndev->stats.rx_packets = stats_rx.packets;
 -	ndev->stats.rx_bytes = stats_rx.bytes;
 -	ndev->stats.rx_errors = stats_rx.errors;
 -	ndev->stats.tx_packets = stats_tx.packets;
 -	ndev->stats.tx_bytes = stats_tx.bytes;
 -	ndev->stats.tx_errors = stats_tx.errors;
 +	/* If no link - use faster timer rate to detect link up asap */
 +	if (!netif_carrier_ok(self->ndev))
 +		ctimer = max(ctimer / 2, 1);
  
  err_exit:
 -	mod_timer(&self->service_timer,
 -		  jiffies + AQ_CFG_SERVICE_TIMER_INTERVAL);
 +	mod_timer(&self->service_timer, jiffies + ctimer);
  }
  
- static void aq_nic_polling_timer_cb(unsigned long param)
+ static void aq_nic_polling_timer_cb(struct timer_list *t)
  {
- 	struct aq_nic_s *self = (struct aq_nic_s *)param;
+ 	struct aq_nic_s *self = from_timer(self, t, polling_timer);
  	struct aq_vec_s *aq_vec = NULL;
  	unsigned int i = 0U;
  
diff --cc drivers/net/ethernet/atheros/atl1e/atl1e_main.c
index 585a55327c62,9dc6da039a6d..000000000000
--- a/drivers/net/ethernet/atheros/atl1e/atl1e_main.c
+++ b/drivers/net/ethernet/atheros/atl1e/atl1e_main.c
@@@ -2330,9 -2362,7 +2331,13 @@@ static int atl1e_probe(struct pci_dev *
  
  	netif_napi_add(netdev, &adapter->napi, atl1e_clean, 64);
  
++<<<<<<< HEAD
 +	init_timer(&adapter->phy_config_timer);
 +	adapter->phy_config_timer.function = atl1e_phy_config;
 +	adapter->phy_config_timer.data = (unsigned long) adapter;
++=======
+ 	timer_setup(&adapter->phy_config_timer, atl1e_phy_config, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	/* get user settings */
  	atl1e_check_options(adapter);
diff --cc drivers/net/ethernet/atheros/atlx/atl2.c
index 3a17664d4d4e,db4bcc51023a..000000000000
--- a/drivers/net/ethernet/atheros/atlx/atl2.c
+++ b/drivers/net/ethernet/atheros/atlx/atl2.c
@@@ -1437,13 -1435,9 +1438,19 @@@ static int atl2_probe(struct pci_dev *p
  
  	atl2_check_options(adapter);
  
++<<<<<<< HEAD
 +	init_timer(&adapter->watchdog_timer);
 +	adapter->watchdog_timer.function = atl2_watchdog;
 +	adapter->watchdog_timer.data = (unsigned long) adapter;
 +
 +	init_timer(&adapter->phy_config_timer);
 +	adapter->phy_config_timer.function = atl2_phy_config;
 +	adapter->phy_config_timer.data = (unsigned long) adapter;
++=======
+ 	timer_setup(&adapter->watchdog_timer, atl2_watchdog, 0);
+ 
+ 	timer_setup(&adapter->phy_config_timer, atl2_phy_config, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	INIT_WORK(&adapter->reset_task, atl2_reset_task);
  	INIT_WORK(&adapter->link_chg_task, atl2_link_chg_task);
diff --cc drivers/net/ethernet/broadcom/b44.c
index 468c4c17635e,e445ab724827..000000000000
--- a/drivers/net/ethernet/broadcom/b44.c
+++ b/drivers/net/ethernet/broadcom/b44.c
@@@ -1443,10 -1474,8 +1443,14 @@@ static int b44_open(struct net_device *
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	init_timer(&bp->timer);
++=======
+ 	timer_setup(&bp->timer, b44_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	bp->timer.expires = jiffies + HZ;
 +	bp->timer.data = (unsigned long) bp;
 +	bp->timer.function = b44_timer;
  	add_timer(&bp->timer);
  
  	b44_enable_ints(bp);
diff --cc drivers/net/ethernet/marvell/mv643xx_eth.c
index 96eef22501e0,62f204f32316..000000000000
--- a/drivers/net/ethernet/marvell/mv643xx_eth.c
+++ b/drivers/net/ethernet/marvell/mv643xx_eth.c
@@@ -2733,9 -3178,7 +2733,13 @@@ static int mv643xx_eth_probe(struct pla
  
  	mib_counters_clear(mp);
  
++<<<<<<< HEAD
 +	init_timer(&mp->mib_counters_timer);
 +	mp->mib_counters_timer.data = (unsigned long)mp;
 +	mp->mib_counters_timer.function = mib_counters_timer_wrapper;
++=======
+ 	timer_setup(&mp->mib_counters_timer, mib_counters_timer_wrapper, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	mp->mib_counters_timer.expires = jiffies + 30 * HZ;
  
  	spin_lock_init(&mp->mib_counters_lock);
@@@ -2744,9 -3187,7 +2748,13 @@@
  
  	netif_napi_add(dev, &mp->napi, mv643xx_eth_poll, NAPI_POLL_WEIGHT);
  
++<<<<<<< HEAD
 +	init_timer(&mp->rx_oom);
 +	mp->rx_oom.data = (unsigned long)mp;
 +	mp->rx_oom.function = oom_timer_wrapper;
++=======
+ 	timer_setup(&mp->rx_oom, oom_timer_wrapper, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  
  	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
diff --cc drivers/net/ethernet/marvell/pxa168_eth.c
index 420c0eb4bc75,7bbd86f08e5f..000000000000
--- a/drivers/net/ethernet/marvell/pxa168_eth.c
+++ b/drivers/net/ethernet/marvell/pxa168_eth.c
@@@ -1532,14 -1496,12 +1532,18 @@@ static int pxa168_eth_probe(struct plat
  	netif_napi_add(dev, &pep->napi, pxa168_rx_poll, pep->rx_ring_size);
  
  	memset(&pep->timeout, 0, sizeof(struct timer_list));
++<<<<<<< HEAD
 +	init_timer(&pep->timeout);
 +	pep->timeout.function = rxq_refill_timer_wrapper;
 +	pep->timeout.data = (unsigned long)pep;
++=======
+ 	timer_setup(&pep->timeout, rxq_refill_timer_wrapper, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	pep->smi_bus = mdiobus_alloc();
 -	if (!pep->smi_bus) {
 +	if (pep->smi_bus == NULL) {
  		err = -ENOMEM;
 -		goto err_netdev;
 +		goto err_base;
  	}
  	pep->smi_bus->priv = pep;
  	pep->smi_bus->name = "pxa168_eth smi";
diff --cc drivers/net/ethernet/pasemi/pasemi_mac.c
index c8a6ad2e9b98,c9a55b774935..000000000000
--- a/drivers/net/ethernet/pasemi/pasemi_mac.c
+++ b/drivers/net/ethernet/pasemi/pasemi_mac.c
@@@ -1238,14 -1196,11 +1238,19 @@@ static int pasemi_mac_open(struct net_d
  		goto out_rx_int;
  	}
  
 -	if (dev->phydev)
 -		phy_start(dev->phydev);
 +	if (mac->phydev)
 +		phy_start(mac->phydev);
  
++<<<<<<< HEAD
 +	init_timer(&mac->tx->clean_timer);
 +	mac->tx->clean_timer.function = pasemi_mac_tx_timer;
 +	mac->tx->clean_timer.data = (unsigned long)mac->tx;
 +	mac->tx->clean_timer.expires = jiffies+HZ;
 +	add_timer(&mac->tx->clean_timer);
++=======
+ 	timer_setup(&mac->tx->clean_timer, pasemi_mac_tx_timer, 0);
+ 	mod_timer(&mac->tx->clean_timer, jiffies + HZ);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	return 0;
  
diff --cc drivers/net/ethernet/qlogic/qla3xxx.c
index ee7cbd7fe16b,9e5264d8773b..000000000000
--- a/drivers/net/ethernet/qlogic/qla3xxx.c
+++ b/drivers/net/ethernet/qlogic/qla3xxx.c
@@@ -3891,10 -3891,8 +3891,14 @@@ static int ql3xxx_probe(struct pci_dev 
  	INIT_DELAYED_WORK(&qdev->tx_timeout_work, ql_tx_timeout_work);
  	INIT_DELAYED_WORK(&qdev->link_state_work, ql_link_state_machine_work);
  
++<<<<<<< HEAD
 +	init_timer(&qdev->adapter_timer);
 +	qdev->adapter_timer.function = ql3xxx_timer;
++=======
+ 	timer_setup(&qdev->adapter_timer, ql3xxx_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	qdev->adapter_timer.expires = jiffies + HZ * 2;	/* two second delay */
 +	qdev->adapter_timer.data = (unsigned long)qdev;
  
  	if (!cards_found) {
  		pr_alert("%s\n", DRV_STRING);
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 2b0083b9138f,f63c2ddced3c..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@@ -313,29 -377,46 +313,36 @@@ bool stmmac_eee_init(struct stmmac_pri
  
  	/* MAC core supports the EEE feature. */
  	if (priv->dma_cap.eee) {
 -		int tx_lpi_timer = priv->tx_lpi_timer;
 -
  		/* Check if the PHY supports EEE */
 -		if (phy_init_eee(ndev->phydev, 1)) {
 -			/* To manage at run-time if the EEE cannot be supported
 -			 * anymore (for example because the lp caps have been
 -			 * changed).
 -			 * In that case the driver disable own timers.
 -			 */
 -			spin_lock_irqsave(&priv->lock, flags);
 -			if (priv->eee_active) {
 -				netdev_dbg(priv->dev, "disable EEE\n");
 -				del_timer_sync(&priv->eee_ctrl_timer);
 -				priv->hw->mac->set_eee_timer(priv->hw, 0,
 -							     tx_lpi_timer);
 -			}
 -			priv->eee_active = 0;
 -			spin_unlock_irqrestore(&priv->lock, flags);
 +		if (phy_init_eee(priv->phydev, 1))
  			goto out;
 -		}
 -		/* Activate the EEE and start timers */
 -		spin_lock_irqsave(&priv->lock, flags);
 +
  		if (!priv->eee_active) {
  			priv->eee_active = 1;
++<<<<<<< HEAD
 +			init_timer(&priv->eee_ctrl_timer);
 +			priv->eee_ctrl_timer.function = stmmac_eee_ctrl_timer;
 +			priv->eee_ctrl_timer.data = (unsigned long)priv;
 +			priv->eee_ctrl_timer.expires = STMMAC_LPI_T(eee_timer);
 +			add_timer(&priv->eee_ctrl_timer);
++=======
+ 			timer_setup(&priv->eee_ctrl_timer,
+ 				    stmmac_eee_ctrl_timer, 0);
+ 			mod_timer(&priv->eee_ctrl_timer,
+ 				  STMMAC_LPI_T(eee_timer));
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
 -			priv->hw->mac->set_eee_timer(priv->hw,
 +			priv->hw->mac->set_eee_timer(priv->ioaddr,
  						     STMMAC_DEFAULT_LIT_LS,
 -						     tx_lpi_timer);
 -		}
 -		/* Set HW EEE according to the speed */
 -		priv->hw->mac->set_eee_pls(priv->hw, ndev->phydev->link);
 +						     priv->tx_lpi_timer);
 +		} else
 +			/* Set HW EEE according to the speed */
 +			priv->hw->mac->set_eee_pls(priv->ioaddr,
 +						   priv->phydev->link);
  
 -		ret = true;
 -		spin_unlock_irqrestore(&priv->lock, flags);
 +		pr_info("stmmac: Energy-Efficient Ethernet initialized\n");
  
 -		netdev_dbg(priv->dev, "Energy-Efficient Ethernet initialized\n");
 +		ret = true;
  	}
  out:
  	return ret;
@@@ -1489,70 -2124,434 +1496,80 @@@ static void stmmac_check_ether_addr(str
  					     priv->dev->dev_addr, 0);
  		if (!is_valid_ether_addr(priv->dev->dev_addr))
  			eth_hw_addr_random(priv->dev);
 -		netdev_info(priv->dev, "device MAC address %pM\n",
 -			    priv->dev->dev_addr);
 -	}
 -}
 -
 -/**
 - * stmmac_init_dma_engine - DMA init.
 - * @priv: driver private structure
 - * Description:
 - * It inits the DMA invoking the specific MAC/GMAC callback.
 - * Some DMA parameters can be passed from the platform;
 - * in case of these are not passed a default is kept for the MAC or GMAC.
 - */
 -static int stmmac_init_dma_engine(struct stmmac_priv *priv)
 -{
 -	u32 rx_channels_count = priv->plat->rx_queues_to_use;
 -	u32 tx_channels_count = priv->plat->tx_queues_to_use;
 -	struct stmmac_rx_queue *rx_q;
 -	struct stmmac_tx_queue *tx_q;
 -	u32 dummy_dma_rx_phy = 0;
 -	u32 dummy_dma_tx_phy = 0;
 -	u32 chan = 0;
 -	int atds = 0;
 -	int ret = 0;
 -
 -	if (!priv->plat->dma_cfg || !priv->plat->dma_cfg->pbl) {
 -		dev_err(priv->device, "Invalid DMA configuration\n");
 -		return -EINVAL;
 -	}
 -
 -	if (priv->extend_desc && (priv->mode == STMMAC_RING_MODE))
 -		atds = 1;
 -
 -	ret = priv->hw->dma->reset(priv->ioaddr);
 -	if (ret) {
 -		dev_err(priv->device, "Failed to reset the dma\n");
 -		return ret;
 -	}
 -
 -	if (priv->synopsys_id >= DWMAC_CORE_4_00) {
 -		/* DMA Configuration */
 -		priv->hw->dma->init(priv->ioaddr, priv->plat->dma_cfg,
 -				    dummy_dma_tx_phy, dummy_dma_rx_phy, atds);
 -
 -		/* DMA RX Channel Configuration */
 -		for (chan = 0; chan < rx_channels_count; chan++) {
 -			rx_q = &priv->rx_queue[chan];
 -
 -			priv->hw->dma->init_rx_chan(priv->ioaddr,
 -						    priv->plat->dma_cfg,
 -						    rx_q->dma_rx_phy, chan);
 -
 -			rx_q->rx_tail_addr = rx_q->dma_rx_phy +
 -				    (DMA_RX_SIZE * sizeof(struct dma_desc));
 -			priv->hw->dma->set_rx_tail_ptr(priv->ioaddr,
 -						       rx_q->rx_tail_addr,
 -						       chan);
 -		}
 -
 -		/* DMA TX Channel Configuration */
 -		for (chan = 0; chan < tx_channels_count; chan++) {
 -			tx_q = &priv->tx_queue[chan];
 -
 -			priv->hw->dma->init_chan(priv->ioaddr,
 -						 priv->plat->dma_cfg,
 -						 chan);
 -
 -			priv->hw->dma->init_tx_chan(priv->ioaddr,
 -						    priv->plat->dma_cfg,
 -						    tx_q->dma_tx_phy, chan);
 -
 -			tx_q->tx_tail_addr = tx_q->dma_tx_phy +
 -				    (DMA_TX_SIZE * sizeof(struct dma_desc));
 -			priv->hw->dma->set_tx_tail_ptr(priv->ioaddr,
 -						       tx_q->tx_tail_addr,
 -						       chan);
 -		}
 -	} else {
 -		rx_q = &priv->rx_queue[chan];
 -		tx_q = &priv->tx_queue[chan];
 -		priv->hw->dma->init(priv->ioaddr, priv->plat->dma_cfg,
 -				    tx_q->dma_tx_phy, rx_q->dma_rx_phy, atds);
 -	}
 -
 -	if (priv->plat->axi && priv->hw->dma->axi)
 -		priv->hw->dma->axi(priv->ioaddr, priv->plat->axi);
 -
 -	return ret;
 -}
 -
 -/**
 - * stmmac_tx_timer - mitigation sw timer for tx.
 - * @data: data pointer
 - * Description:
 - * This is the timer handler to directly invoke the stmmac_tx_clean.
 - */
 -static void stmmac_tx_timer(struct timer_list *t)
 -{
 -	struct stmmac_priv *priv = from_timer(priv, t, txtimer);
 -	u32 tx_queues_count = priv->plat->tx_queues_to_use;
 -	u32 queue;
 -
 -	/* let's scan all the tx queues */
 -	for (queue = 0; queue < tx_queues_count; queue++)
 -		stmmac_tx_clean(priv, queue);
 -}
 -
 -/**
 - * stmmac_init_tx_coalesce - init tx mitigation options.
 - * @priv: driver private structure
 - * Description:
 - * This inits the transmit coalesce parameters: i.e. timer rate,
 - * timer handler and default threshold used for enabling the
 - * interrupt on completion bit.
 - */
 -static void stmmac_init_tx_coalesce(struct stmmac_priv *priv)
 -{
 -	priv->tx_coal_frames = STMMAC_TX_FRAMES;
 -	priv->tx_coal_timer = STMMAC_COAL_TX_TIMER;
 -	timer_setup(&priv->txtimer, stmmac_tx_timer, 0);
 -	priv->txtimer.expires = STMMAC_COAL_TIMER(priv->tx_coal_timer);
 -	add_timer(&priv->txtimer);
 -}
 -
 -static void stmmac_set_rings_length(struct stmmac_priv *priv)
 -{
 -	u32 rx_channels_count = priv->plat->rx_queues_to_use;
 -	u32 tx_channels_count = priv->plat->tx_queues_to_use;
 -	u32 chan;
 -
 -	/* set TX ring length */
 -	if (priv->hw->dma->set_tx_ring_len) {
 -		for (chan = 0; chan < tx_channels_count; chan++)
 -			priv->hw->dma->set_tx_ring_len(priv->ioaddr,
 -						       (DMA_TX_SIZE - 1), chan);
 -	}
 -
 -	/* set RX ring length */
 -	if (priv->hw->dma->set_rx_ring_len) {
 -		for (chan = 0; chan < rx_channels_count; chan++)
 -			priv->hw->dma->set_rx_ring_len(priv->ioaddr,
 -						       (DMA_RX_SIZE - 1), chan);
 -	}
 -}
 -
 -/**
 - *  stmmac_set_tx_queue_weight - Set TX queue weight
 - *  @priv: driver private structure
 - *  Description: It is used for setting TX queues weight
 - */
 -static void stmmac_set_tx_queue_weight(struct stmmac_priv *priv)
 -{
 -	u32 tx_queues_count = priv->plat->tx_queues_to_use;
 -	u32 weight;
 -	u32 queue;
 -
 -	for (queue = 0; queue < tx_queues_count; queue++) {
 -		weight = priv->plat->tx_queues_cfg[queue].weight;
 -		priv->hw->mac->set_mtl_tx_queue_weight(priv->hw, weight, queue);
 -	}
 -}
 -
 -/**
 - *  stmmac_configure_cbs - Configure CBS in TX queue
 - *  @priv: driver private structure
 - *  Description: It is used for configuring CBS in AVB TX queues
 - */
 -static void stmmac_configure_cbs(struct stmmac_priv *priv)
 -{
 -	u32 tx_queues_count = priv->plat->tx_queues_to_use;
 -	u32 mode_to_use;
 -	u32 queue;
 -
 -	/* queue 0 is reserved for legacy traffic */
 -	for (queue = 1; queue < tx_queues_count; queue++) {
 -		mode_to_use = priv->plat->tx_queues_cfg[queue].mode_to_use;
 -		if (mode_to_use == MTL_QUEUE_DCB)
 -			continue;
 -
 -		priv->hw->mac->config_cbs(priv->hw,
 -				priv->plat->tx_queues_cfg[queue].send_slope,
 -				priv->plat->tx_queues_cfg[queue].idle_slope,
 -				priv->plat->tx_queues_cfg[queue].high_credit,
 -				priv->plat->tx_queues_cfg[queue].low_credit,
 -				queue);
 -	}
 -}
 -
 -/**
 - *  stmmac_rx_queue_dma_chan_map - Map RX queue to RX dma channel
 - *  @priv: driver private structure
 - *  Description: It is used for mapping RX queues to RX dma channels
 - */
 -static void stmmac_rx_queue_dma_chan_map(struct stmmac_priv *priv)
 -{
 -	u32 rx_queues_count = priv->plat->rx_queues_to_use;
 -	u32 queue;
 -	u32 chan;
 -
 -	for (queue = 0; queue < rx_queues_count; queue++) {
 -		chan = priv->plat->rx_queues_cfg[queue].chan;
 -		priv->hw->mac->map_mtl_to_dma(priv->hw, queue, chan);
 -	}
 -}
 -
 -/**
 - *  stmmac_mac_config_rx_queues_prio - Configure RX Queue priority
 - *  @priv: driver private structure
 - *  Description: It is used for configuring the RX Queue Priority
 - */
 -static void stmmac_mac_config_rx_queues_prio(struct stmmac_priv *priv)
 -{
 -	u32 rx_queues_count = priv->plat->rx_queues_to_use;
 -	u32 queue;
 -	u32 prio;
 -
 -	for (queue = 0; queue < rx_queues_count; queue++) {
 -		if (!priv->plat->rx_queues_cfg[queue].use_prio)
 -			continue;
 -
 -		prio = priv->plat->rx_queues_cfg[queue].prio;
 -		priv->hw->mac->rx_queue_prio(priv->hw, prio, queue);
 -	}
 -}
 -
 -/**
 - *  stmmac_mac_config_tx_queues_prio - Configure TX Queue priority
 - *  @priv: driver private structure
 - *  Description: It is used for configuring the TX Queue Priority
 - */
 -static void stmmac_mac_config_tx_queues_prio(struct stmmac_priv *priv)
 -{
 -	u32 tx_queues_count = priv->plat->tx_queues_to_use;
 -	u32 queue;
 -	u32 prio;
 -
 -	for (queue = 0; queue < tx_queues_count; queue++) {
 -		if (!priv->plat->tx_queues_cfg[queue].use_prio)
 -			continue;
 -
 -		prio = priv->plat->tx_queues_cfg[queue].prio;
 -		priv->hw->mac->tx_queue_prio(priv->hw, prio, queue);
 -	}
 -}
 -
 -/**
 - *  stmmac_mac_config_rx_queues_routing - Configure RX Queue Routing
 - *  @priv: driver private structure
 - *  Description: It is used for configuring the RX queue routing
 - */
 -static void stmmac_mac_config_rx_queues_routing(struct stmmac_priv *priv)
 -{
 -	u32 rx_queues_count = priv->plat->rx_queues_to_use;
 -	u32 queue;
 -	u8 packet;
 -
 -	for (queue = 0; queue < rx_queues_count; queue++) {
 -		/* no specific packet type routing specified for the queue */
 -		if (priv->plat->rx_queues_cfg[queue].pkt_route == 0x0)
 -			continue;
 -
 -		packet = priv->plat->rx_queues_cfg[queue].pkt_route;
 -		priv->hw->mac->rx_queue_prio(priv->hw, packet, queue);
 -	}
 -}
 -
 -/**
 - *  stmmac_mtl_configuration - Configure MTL
 - *  @priv: driver private structure
 - *  Description: It is used for configurring MTL
 - */
 -static void stmmac_mtl_configuration(struct stmmac_priv *priv)
 -{
 -	u32 rx_queues_count = priv->plat->rx_queues_to_use;
 -	u32 tx_queues_count = priv->plat->tx_queues_to_use;
 -
 -	if (tx_queues_count > 1 && priv->hw->mac->set_mtl_tx_queue_weight)
 -		stmmac_set_tx_queue_weight(priv);
 -
 -	/* Configure MTL RX algorithms */
 -	if (rx_queues_count > 1 && priv->hw->mac->prog_mtl_rx_algorithms)
 -		priv->hw->mac->prog_mtl_rx_algorithms(priv->hw,
 -						priv->plat->rx_sched_algorithm);
 -
 -	/* Configure MTL TX algorithms */
 -	if (tx_queues_count > 1 && priv->hw->mac->prog_mtl_tx_algorithms)
 -		priv->hw->mac->prog_mtl_tx_algorithms(priv->hw,
 -						priv->plat->tx_sched_algorithm);
 -
 -	/* Configure CBS in AVB TX queues */
 -	if (tx_queues_count > 1 && priv->hw->mac->config_cbs)
 -		stmmac_configure_cbs(priv);
 -
 -	/* Map RX MTL to DMA channels */
 -	if (priv->hw->mac->map_mtl_to_dma)
 -		stmmac_rx_queue_dma_chan_map(priv);
 -
 -	/* Enable MAC RX Queues */
 -	if (priv->hw->mac->rx_queue_enable)
 -		stmmac_mac_enable_rx_queues(priv);
 -
 -	/* Set RX priorities */
 -	if (rx_queues_count > 1 && priv->hw->mac->rx_queue_prio)
 -		stmmac_mac_config_rx_queues_prio(priv);
 -
 -	/* Set TX priorities */
 -	if (tx_queues_count > 1 && priv->hw->mac->tx_queue_prio)
 -		stmmac_mac_config_tx_queues_prio(priv);
 -
 -	/* Set RX routing */
 -	if (rx_queues_count > 1 && priv->hw->mac->rx_queue_routing)
 -		stmmac_mac_config_rx_queues_routing(priv);
 -}
 -
 -/**
 - * stmmac_hw_setup - setup mac in a usable state.
 - *  @dev : pointer to the device structure.
 - *  Description:
 - *  this is the main function to setup the HW in a usable state because the
 - *  dma engine is reset, the core registers are configured (e.g. AXI,
 - *  Checksum features, timers). The DMA is ready to start receiving and
 - *  transmitting.
 - *  Return value:
 - *  0 on success and an appropriate (-)ve integer as defined in errno.h
 - *  file on failure.
 - */
 -static int stmmac_hw_setup(struct net_device *dev, bool init_ptp)
 -{
 -	struct stmmac_priv *priv = netdev_priv(dev);
 -	u32 rx_cnt = priv->plat->rx_queues_to_use;
 -	u32 tx_cnt = priv->plat->tx_queues_to_use;
 -	u32 chan;
 -	int ret;
 -
 -	/* DMA initialization and SW reset */
 -	ret = stmmac_init_dma_engine(priv);
 -	if (ret < 0) {
 -		netdev_err(priv->dev, "%s: DMA engine initialization failed\n",
 -			   __func__);
 -		return ret;
 -	}
 -
 -	/* Copy the MAC addr into the HW  */
 -	priv->hw->mac->set_umac_addr(priv->hw, dev->dev_addr, 0);
 -
 -	/* PS and related bits will be programmed according to the speed */
 -	if (priv->hw->pcs) {
 -		int speed = priv->plat->mac_port_sel_speed;
 -
 -		if ((speed == SPEED_10) || (speed == SPEED_100) ||
 -		    (speed == SPEED_1000)) {
 -			priv->hw->ps = speed;
 -		} else {
 -			dev_warn(priv->device, "invalid port speed\n");
 -			priv->hw->ps = 0;
 -		}
 -	}
 -
 -	/* Initialize the MAC Core */
 -	priv->hw->mac->core_init(priv->hw, dev->mtu);
 -
 -	/* Initialize MTL*/
 -	if (priv->synopsys_id >= DWMAC_CORE_4_00)
 -		stmmac_mtl_configuration(priv);
 -
 -	ret = priv->hw->mac->rx_ipc(priv->hw);
 -	if (!ret) {
 -		netdev_warn(priv->dev, "RX IPC Checksum Offload disabled\n");
 -		priv->plat->rx_coe = STMMAC_RX_COE_NONE;
 -		priv->hw->rx_csum = 0;
 -	}
 -
 -	/* Enable the MAC Rx/Tx */
 -	priv->hw->mac->set_mac(priv->ioaddr, true);
 -
 -	/* Set the HW DMA mode and the COE */
 -	stmmac_dma_operation_mode(priv);
 -
 -	stmmac_mmc_setup(priv);
 -
 -	if (init_ptp) {
 -		ret = clk_prepare_enable(priv->plat->clk_ptp_ref);
 -		if (ret < 0)
 -			netdev_warn(priv->dev, "failed to enable PTP reference clock: %d\n", ret);
 -
 -		ret = stmmac_init_ptp(priv);
 -		if (ret == -EOPNOTSUPP)
 -			netdev_warn(priv->dev, "PTP not supported by HW\n");
 -		else if (ret)
 -			netdev_warn(priv->dev, "PTP init failed\n");
 -	}
 -
 -#ifdef CONFIG_DEBUG_FS
 -	ret = stmmac_init_fs(dev);
 -	if (ret < 0)
 -		netdev_warn(priv->dev, "%s: failed debugFS registration\n",
 -			    __func__);
 -#endif
 -	/* Start the ball rolling... */
 -	stmmac_start_all_dma(priv);
 -
 -	priv->tx_lpi_timer = STMMAC_DEFAULT_TWT_LS;
 -
 -	if ((priv->use_riwt) && (priv->hw->dma->rx_watchdog)) {
 -		priv->rx_riwt = MAX_DMA_RIWT;
 -		priv->hw->dma->rx_watchdog(priv->ioaddr, MAX_DMA_RIWT, rx_cnt);
  	}
 +	pr_warn("%s: device MAC address %pM\n", priv->dev->name,
 +		priv->dev->dev_addr);
 +}
  
 -	if (priv->hw->pcs && priv->hw->mac->pcs_ctrl_ane)
 -		priv->hw->mac->pcs_ctrl_ane(priv->hw, 1, priv->hw->ps, 0);
 -
 -	/* set TX and RX rings length */
 -	stmmac_set_rings_length(priv);
 +/**
 + * stmmac_init_dma_engine: DMA init.
 + * @priv: driver private structure
 + * Description:
 + * It inits the DMA invoking the specific MAC/GMAC callback.
 + * Some DMA parameters can be passed from the platform;
 + * in case of these are not passed a default is kept for the MAC or GMAC.
 + */
 +static int stmmac_init_dma_engine(struct stmmac_priv *priv)
 +{
 +	int pbl = DEFAULT_DMA_PBL, fixed_burst = 0, burst_len = 0;
 +	int mixed_burst = 0;
 +	int atds = 0;
  
 -	/* Enable TSO */
 -	if (priv->tso) {
 -		for (chan = 0; chan < tx_cnt; chan++)
 -			priv->hw->dma->enable_tso(priv->ioaddr, 1, chan);
 +	if (priv->plat->dma_cfg) {
 +		pbl = priv->plat->dma_cfg->pbl;
 +		fixed_burst = priv->plat->dma_cfg->fixed_burst;
 +		mixed_burst = priv->plat->dma_cfg->mixed_burst;
 +		burst_len = priv->plat->dma_cfg->burst_len;
  	}
  
 -	return 0;
 +	if (priv->extend_desc && (priv->mode == STMMAC_RING_MODE))
 +		atds = 1;
 +
 +	return priv->hw->dma->init(priv->ioaddr, pbl, fixed_burst, mixed_burst,
 +				   burst_len, priv->dma_tx_phy,
 +				   priv->dma_rx_phy, atds);
  }
  
 -static void stmmac_hw_teardown(struct net_device *dev)
 +/**
 + * stmmac_tx_timer: mitigation sw timer for tx.
 + * @data: data pointer
 + * Description:
 + * This is the timer handler to directly invoke the stmmac_tx_clean.
 + */
- static void stmmac_tx_timer(unsigned long data)
++static void stmmac_tx_timer(struct timer_list *t)
  {
 -	struct stmmac_priv *priv = netdev_priv(dev);
++<<<<<<< HEAD
 +	struct stmmac_priv *priv = (struct stmmac_priv *)data;
++=======
++	struct stmmac_priv *priv = from_timer(priv, t, txtimer);
++	u32 tx_queues_count = priv->plat->tx_queues_to_use;
++	u32 queue;
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
 +
 +	stmmac_tx_clean(priv);
 +}
  
 -	clk_disable_unprepare(priv->plat->clk_ptp_ref);
 +/**
 + * stmmac_init_tx_coalesce: init tx mitigation options.
 + * @priv: driver private structure
 + * Description:
 + * This inits the transmit coalesce parameters: i.e. timer rate,
 + * timer handler and default threshold used for enabling the
 + * interrupt on completion bit.
 + */
 +static void stmmac_init_tx_coalesce(struct stmmac_priv *priv)
 +{
 +	priv->tx_coal_frames = STMMAC_TX_FRAMES;
 +	priv->tx_coal_timer = STMMAC_COAL_TX_TIMER;
++<<<<<<< HEAD
 +	init_timer(&priv->txtimer);
++=======
++	timer_setup(&priv->txtimer, stmmac_tx_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
 +	priv->txtimer.expires = STMMAC_COAL_TIMER(priv->tx_coal_timer);
 +	priv->txtimer.data = (unsigned long)priv;
 +	priv->txtimer.function = stmmac_tx_timer;
 +	add_timer(&priv->txtimer);
  }
  
  /**
diff --cc drivers/net/ethernet/ti/cpsw_ale.c
index 7fa60d6092ed,b432a75fb874..000000000000
--- a/drivers/net/ethernet/ti/cpsw_ale.c
+++ b/drivers/net/ethernet/ti/cpsw_ale.c
@@@ -676,10 -763,11 +676,10 @@@ int cpsw_ale_control_get(struct cpsw_al
  	tmp = __raw_readl(ale->params.ale_regs + offset) >> shift;
  	return tmp & BITMASK(info->bits);
  }
 -EXPORT_SYMBOL_GPL(cpsw_ale_control_get);
  
- static void cpsw_ale_timer(unsigned long arg)
+ static void cpsw_ale_timer(struct timer_list *t)
  {
- 	struct cpsw_ale *ale = (struct cpsw_ale *)arg;
+ 	struct cpsw_ale *ale = from_timer(ale, t, timer);
  
  	cpsw_ale_control_set(ale, 0, ALE_AGEOUT, 1);
  
@@@ -710,9 -859,7 +710,13 @@@ void cpsw_ale_start(struct cpsw_ale *al
  	cpsw_ale_control_set(ale, 0, ALE_ENABLE, 1);
  	cpsw_ale_control_set(ale, 0, ALE_CLEAR, 1);
  
++<<<<<<< HEAD
 +	init_timer(&ale->timer);
 +	ale->timer.data	    = (unsigned long)ale;
 +	ale->timer.function = cpsw_ale_timer;
++=======
+ 	timer_setup(&ale->timer, cpsw_ale_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	if (ale->ageout) {
  		ale->timer.expires = jiffies + ale->ageout;
  		add_timer(&ale->timer);
diff --cc drivers/net/ethernet/toshiba/spider_net.c
index bb24004dedf4,d925b8203996..000000000000
--- a/drivers/net/ethernet/toshiba/spider_net.c
+++ b/drivers/net/ethernet/toshiba/spider_net.c
@@@ -2309,16 -2257,11 +2310,24 @@@ spider_net_setup_netdev(struct spider_n
  
  	pci_set_drvdata(card->pdev, netdev);
  
++<<<<<<< HEAD
 +	init_timer(&card->tx_timer);
 +	card->tx_timer.function =
 +		(void (*)(unsigned long)) spider_net_cleanup_tx_ring;
 +	card->tx_timer.data = (unsigned long) card;
 +	netdev->irq = card->pdev->irq;
 +
 +	card->aneg_count = 0;
 +	init_timer(&card->aneg_timer);
 +	card->aneg_timer.function = spider_net_link_phy;
 +	card->aneg_timer.data = (unsigned long) card;
++=======
+ 	timer_setup(&card->tx_timer, spider_net_cleanup_tx_ring, 0);
+ 	netdev->irq = card->pdev->irq;
+ 
+ 	card->aneg_count = 0;
+ 	timer_setup(&card->aneg_timer, spider_net_link_phy, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	netif_napi_add(netdev, &card->napi,
  		       spider_net_poll, SPIDER_NET_NAPI_WEIGHT);
diff --cc drivers/net/slip/slip.c
index 3a65fc0cbfe5,cc63102ca96e..000000000000
--- a/drivers/net/slip/slip.c
+++ b/drivers/net/slip/slip.c
@@@ -764,12 -763,8 +764,17 @@@ static struct slip *sl_alloc(dev_t line
  	sl->mode        = SL_MODE_DEFAULT;
  #ifdef CONFIG_SLIP_SMART
  	/* initialize timer_list struct */
++<<<<<<< HEAD
 +	init_timer(&sl->keepalive_timer);
 +	sl->keepalive_timer.data = (unsigned long)sl;
 +	sl->keepalive_timer.function = sl_keepalive;
 +	init_timer(&sl->outfill_timer);
 +	sl->outfill_timer.data = (unsigned long)sl;
 +	sl->outfill_timer.function = sl_outfill;
++=======
+ 	timer_setup(&sl->keepalive_timer, sl_keepalive, 0);
+ 	timer_setup(&sl->outfill_timer, sl_outfill, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  #endif
  	slip_devs[i] = dev;
  	return sl;
diff --cc drivers/net/wan/hdlc_ppp.c
index 0d7645581f91,afeca6bcdade..000000000000
--- a/drivers/net/wan/hdlc_ppp.c
+++ b/drivers/net/wan/hdlc_ppp.c
@@@ -610,9 -610,7 +610,13 @@@ static void ppp_start(struct net_devic
  	for (i = 0; i < IDX_COUNT; i++) {
  		struct proto *proto = &ppp->protos[i];
  		proto->dev = dev;
++<<<<<<< HEAD
 +		init_timer(&proto->timer);
 +		proto->timer.function = ppp_timer;
 +		proto->timer.data = (unsigned long)proto;
++=======
+ 		timer_setup(&proto->timer, ppp_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  		proto->state = CLOSED;
  	}
  	ppp->protos[IDX_LCP].pid = PID_LCP;
diff --cc drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
index 4157c90ad973,15fa00d79fc6..000000000000
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
@@@ -3261,9 -3150,7 +3261,13 @@@ static void brcmf_init_escan(struct brc
  			    brcmf_cfg80211_escan_handler);
  	cfg->escan_info.escan_state = WL_ESCAN_STATE_IDLE;
  	/* Init scan_timeout timer */
++<<<<<<< HEAD
 +	init_timer(&cfg->escan_timeout);
 +	cfg->escan_timeout.data = (unsigned long) cfg;
 +	cfg->escan_timeout.function = brcmf_escan_timeout;
++=======
+ 	timer_setup(&cfg->escan_timeout, brcmf_escan_timeout, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	INIT_WORK(&cfg->escan_timeout_work,
  		  brcmf_cfg80211_escan_timeout_worker);
  }
diff --cc drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
index 0efac4f4e23b,310c4e2746aa..000000000000
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
@@@ -4148,10 -4169,7 +4148,14 @@@ struct brcmf_sdio *brcmf_sdio_probe(str
  	init_waitqueue_head(&bus->dcmd_resp_wait);
  
  	/* Set up the watchdog timer */
++<<<<<<< HEAD
 +	init_timer(&bus->timer);
 +	bus->timer.data = (unsigned long)bus;
 +	bus->timer.function = brcmf_sdio_watchdog;
 +
++=======
+ 	timer_setup(&bus->timer, brcmf_sdio_watchdog, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	/* Initialize watchdog thread */
  	init_completion(&bus->watchdog_wait);
  	bus->watchdog_tsk = kthread_run(brcmf_sdio_watchdog_thread,
diff --cc drivers/net/wireless/hostap/hostap_ap.c
index d6033a8e5dea,b4dfe1893d18..000000000000
--- a/drivers/net/wireless/hostap/hostap_ap.c
+++ b/drivers/net/wireless/hostap/hostap_ap.c
@@@ -1190,10 -1189,8 +1190,14 @@@ static struct sta_info * ap_add_sta(str
  	}
  
  #ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT
++<<<<<<< HEAD:drivers/net/wireless/hostap/hostap_ap.c
 +	init_timer(&sta->timer);
++=======
+ 	timer_setup(&sta->timer, ap_handle_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup()):drivers/net/wireless/intersil/hostap/hostap_ap.c
  	sta->timer.expires = jiffies + ap->max_inactivity;
 +	sta->timer.data = (unsigned long) sta;
 +	sta->timer.function = ap_handle_timer;
  	if (!ap->local->hostapd)
  		add_timer(&sta->timer);
  #endif /* PRISM2_NO_KERNEL_IEEE80211_MGMT */
diff --cc drivers/net/wireless/hostap/hostap_hw.c
index 6307a4e36c85,5c4a17a18968..000000000000
--- a/drivers/net/wireless/hostap/hostap_hw.c
+++ b/drivers/net/wireless/hostap/hostap_hw.c
@@@ -3221,13 -3225,8 +3221,18 @@@ while (0
  
  	lib80211_crypt_info_init(&local->crypt_info, dev->name, &local->lock);
  
++<<<<<<< HEAD:drivers/net/wireless/hostap/hostap_hw.c
 +	init_timer(&local->passive_scan_timer);
 +	local->passive_scan_timer.data = (unsigned long) local;
 +	local->passive_scan_timer.function = hostap_passive_scan;
 +
 +	init_timer(&local->tick_timer);
 +	local->tick_timer.data = (unsigned long) local;
 +	local->tick_timer.function = hostap_tick_timer;
++=======
+ 	timer_setup(&local->passive_scan_timer, hostap_passive_scan, 0);
+ 	timer_setup(&local->tick_timer, hostap_tick_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup()):drivers/net/wireless/intersil/hostap/hostap_hw.c
  	local->tick_timer.expires = jiffies + 2 * HZ;
  	add_timer(&local->tick_timer);
  
diff --cc drivers/net/wireless/orinoco/orinoco_usb.c
index 1f9cb55c3360,94ad6fe29e69..000000000000
--- a/drivers/net/wireless/orinoco/orinoco_usb.c
+++ b/drivers/net/wireless/orinoco/orinoco_usb.c
@@@ -376,12 -362,10 +376,16 @@@ static struct request_context *ezusb_al
  	ctx->out_rid = out_rid;
  	ctx->in_rid = in_rid;
  
 -	refcount_set(&ctx->refcount, 1);
 +	atomic_set(&ctx->refcount, 1);
  	init_completion(&ctx->done);
  
++<<<<<<< HEAD:drivers/net/wireless/orinoco/orinoco_usb.c
 +	init_timer(&ctx->timer);
 +	ctx->timer.function = ezusb_request_timerfn;
 +	ctx->timer.data = (u_long) ctx;
++=======
+ 	timer_setup(&ctx->timer, ezusb_request_timerfn, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup()):drivers/net/wireless/intersil/orinoco/orinoco_usb.c
  	return ctx;
  }
  
diff --cc drivers/nfc/pn533.c
index 8f6f2baa930d,a0cc1cc45292..000000000000
--- a/drivers/nfc/pn533.c
+++ b/drivers/nfc/pn533.c
@@@ -1644,11 -1232,11 +1644,11 @@@ static int pn533_init_target_complete(s
  	return 0;
  }
  
- static void pn533_listen_mode_timer(unsigned long data)
+ static void pn533_listen_mode_timer(struct timer_list *t)
  {
- 	struct pn533 *dev = (struct pn533 *)data;
+ 	struct pn533 *dev = from_timer(dev, t, listen_timer);
  
 -	dev_dbg(dev->dev, "Listen mode timeout\n");
 +	nfc_dev_dbg(&dev->interface->dev, "Listen mode timeout");
  
  	dev->cancel_listen = 1;
  
@@@ -2663,108 -2565,86 +2663,112 @@@ static int pn533_setup(struct pn533 *de
  	return 0;
  }
  
 -int pn533_finalize_setup(struct pn533 *dev)
 +static int pn533_probe(struct usb_interface *interface,
 +			const struct usb_device_id *id)
  {
 -
  	struct pn533_fw_version fw_ver;
 -	int rc;
 +	struct pn533 *dev;
 +	struct usb_host_interface *iface_desc;
 +	struct usb_endpoint_descriptor *endpoint;
 +	int in_endpoint = 0;
 +	int out_endpoint = 0;
 +	int rc = -ENOMEM;
 +	int i;
 +	u32 protocols;
  
 -	memset(&fw_ver, 0, sizeof(fw_ver));
 +	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 +	if (!dev)
 +		return -ENOMEM;
  
 -	rc = pn533_get_firmware_version(dev, &fw_ver);
 -	if (rc) {
 -		nfc_err(dev->dev, "Unable to get FW version\n");
 -		return rc;
 -	}
 +	dev->udev = usb_get_dev(interface_to_usbdev(interface));
 +	dev->interface = interface;
 +	mutex_init(&dev->cmd_lock);
  
 -	nfc_info(dev->dev, "NXP PN5%02X firmware ver %d.%d now attached\n",
 -		fw_ver.ic, fw_ver.ver, fw_ver.rev);
 +	iface_desc = interface->cur_altsetting;
 +	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
 +		endpoint = &iface_desc->endpoint[i].desc;
  
 -	rc = pn533_setup(dev);
 -	if (rc)
 -		return rc;
 +		if (!in_endpoint && usb_endpoint_is_bulk_in(endpoint))
 +			in_endpoint = endpoint->bEndpointAddress;
  
 -	return 0;
 -}
 -EXPORT_SYMBOL_GPL(pn533_finalize_setup);
 +		if (!out_endpoint && usb_endpoint_is_bulk_out(endpoint))
 +			out_endpoint = endpoint->bEndpointAddress;
 +	}
  
 -struct pn533 *pn533_register_device(u32 device_type,
 -				u32 protocols,
 -				enum pn533_protocol_type protocol_type,
 -				void *phy,
 -				struct pn533_phy_ops *phy_ops,
 -				struct pn533_frame_ops *fops,
 -				struct device *dev,
 -				struct device *parent)
 -{
 -	struct pn533 *priv;
 -	int rc = -ENOMEM;
 +	if (!in_endpoint || !out_endpoint) {
 +		nfc_dev_err(&interface->dev,
 +			    "Could not find bulk-in or bulk-out endpoint");
 +		rc = -ENODEV;
 +		goto error;
 +	}
  
 -	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 -	if (!priv)
 -		return ERR_PTR(-ENOMEM);
 +	dev->in_urb = usb_alloc_urb(0, GFP_KERNEL);
 +	dev->out_urb = usb_alloc_urb(0, GFP_KERNEL);
  
 -	priv->phy = phy;
 -	priv->phy_ops = phy_ops;
 -	priv->dev = dev;
 -	if (fops != NULL)
 -		priv->ops = fops;
 -	else
 -		priv->ops = &pn533_std_frame_ops;
 -
 -	priv->protocol_type = protocol_type;
 -	priv->device_type = device_type;
 -
 -	mutex_init(&priv->cmd_lock);
 -
 -	INIT_WORK(&priv->cmd_work, pn533_wq_cmd);
 -	INIT_WORK(&priv->cmd_complete_work, pn533_wq_cmd_complete);
 -	INIT_WORK(&priv->mi_rx_work, pn533_wq_mi_recv);
 -	INIT_WORK(&priv->mi_tx_work, pn533_wq_mi_send);
 -	INIT_WORK(&priv->tg_work, pn533_wq_tg_get_data);
 -	INIT_WORK(&priv->mi_tm_rx_work, pn533_wq_tm_mi_recv);
 -	INIT_WORK(&priv->mi_tm_tx_work, pn533_wq_tm_mi_send);
 -	INIT_DELAYED_WORK(&priv->poll_work, pn533_wq_poll);
 -	INIT_WORK(&priv->rf_work, pn533_wq_rf);
 -	priv->wq = alloc_ordered_workqueue("pn533", 0);
 -	if (priv->wq == NULL)
 +	if (!dev->in_urb || !dev->out_urb)
  		goto error;
  
++<<<<<<< HEAD:drivers/nfc/pn533.c
 +	usb_fill_bulk_urb(dev->in_urb, dev->udev,
 +			  usb_rcvbulkpipe(dev->udev, in_endpoint),
 +			  NULL, 0, NULL, dev);
 +	usb_fill_bulk_urb(dev->out_urb, dev->udev,
 +			  usb_sndbulkpipe(dev->udev, out_endpoint),
 +			  NULL, 0, pn533_send_complete, dev);
++=======
+ 	timer_setup(&priv->listen_timer, pn533_listen_mode_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup()):drivers/nfc/pn533/pn533.c
 +
 +	INIT_WORK(&dev->cmd_work, pn533_wq_cmd);
 +	INIT_WORK(&dev->cmd_complete_work, pn533_wq_cmd_complete);
 +	INIT_WORK(&dev->mi_work, pn533_wq_mi_recv);
 +	INIT_WORK(&dev->tg_work, pn533_wq_tg_get_data);
 +	INIT_WORK(&dev->poll_work, pn533_wq_poll);
 +	dev->wq = alloc_ordered_workqueue("pn533", 0);
 +	if (dev->wq == NULL)
 +		goto error;
  
 -	skb_queue_head_init(&priv->resp_q);
 -	skb_queue_head_init(&priv->fragment_skb);
 +	init_timer(&dev->listen_timer);
 +	dev->listen_timer.data = (unsigned long) dev;
 +	dev->listen_timer.function = pn533_listen_mode_timer;
  
 -	INIT_LIST_HEAD(&priv->cmd_queue);
 +	skb_queue_head_init(&dev->resp_q);
  
 -	priv->nfc_dev = nfc_allocate_device(&pn533_nfc_ops, protocols,
 -					   priv->ops->tx_header_len +
 -					   PN533_CMD_DATAEXCH_HEAD_LEN,
 -					   priv->ops->tx_tail_len);
 -	if (!priv->nfc_dev) {
 -		rc = -ENOMEM;
 +	INIT_LIST_HEAD(&dev->cmd_queue);
 +
 +	usb_set_intfdata(interface, dev);
 +
 +	dev->ops = &pn533_std_frame_ops;
 +
 +	dev->protocol_type = PN533_PROTO_REQ_ACK_RESP;
 +	dev->device_type = id->driver_info;
 +	switch (dev->device_type) {
 +	case PN533_DEVICE_STD:
 +		protocols = PN533_ALL_PROTOCOLS;
 +		break;
 +
 +	case PN533_DEVICE_PASORI:
 +		protocols = PN533_NO_TYPE_B_PROTOCOLS;
 +		break;
 +
 +	case PN533_DEVICE_ACR122U:
 +		protocols = PN533_NO_TYPE_B_PROTOCOLS;
 +		dev->ops = &pn533_acr122_frame_ops;
 +		dev->protocol_type = PN533_PROTO_REQ_RESP,
 +
 +		rc = pn533_acr122_poweron_rdr(dev);
 +		if (rc < 0) {
 +			nfc_dev_err(&dev->interface->dev,
 +				    "Couldn't poweron the reader (error %d)",
 +				    rc);
 +			goto destroy_wq;
 +		}
 +		break;
 +
 +	default:
 +		nfc_dev_err(&dev->interface->dev, "Unknown device type %d\n",
 +			    dev->device_type);
 +		rc = -EINVAL;
  		goto destroy_wq;
  	}
  
diff --cc drivers/s390/block/dasd.c
index fed9a313d323,0f1ff0813493..000000000000
--- a/drivers/s390/block/dasd.c
+++ b/drivers/s390/block/dasd.c
@@@ -119,9 -119,7 +119,13 @@@ struct dasd_device *dasd_alloc_device(v
  		     (void (*)(unsigned long)) dasd_device_tasklet,
  		     (unsigned long) device);
  	INIT_LIST_HEAD(&device->ccw_queue);
++<<<<<<< HEAD
 +	init_timer(&device->timer);
 +	device->timer.function = dasd_device_timeout;
 +	device->timer.data = (unsigned long) device;
++=======
+ 	timer_setup(&device->timer, dasd_device_timeout, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	INIT_WORK(&device->kick_work, do_kick_device);
  	INIT_WORK(&device->restore_device, do_restore_device);
  	INIT_WORK(&device->reload_device, do_reload_device);
@@@ -164,9 -161,7 +168,13 @@@ struct dasd_block *dasd_alloc_block(voi
  		     (unsigned long) block);
  	INIT_LIST_HEAD(&block->ccw_queue);
  	spin_lock_init(&block->queue_lock);
++<<<<<<< HEAD
 +	init_timer(&block->timer);
 +	block->timer.function = dasd_block_timeout;
 +	block->timer.data = (unsigned long) block;
++=======
+ 	timer_setup(&block->timer, dasd_block_timeout, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	spin_lock_init(&block->profile.lock);
  
  	return block;
diff --cc drivers/s390/net/fsm.c
index e5dea67f902e,c81adf8042d7..000000000000
--- a/drivers/s390/net/fsm.c
+++ b/drivers/s390/net/fsm.c
@@@ -148,7 -147,7 +149,11 @@@ fsm_settimer(fsm_instance *fi, fsm_time
  	printk(KERN_DEBUG "fsm(%s): Create timer %p\n", fi->name,
  	       this);
  #endif
++<<<<<<< HEAD
 +	init_timer(&this->tl);
++=======
+ 	timer_setup(&this->tl, fsm_expire_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  }
  
  void
@@@ -170,9 -169,7 +175,13 @@@ fsm_addtimer(fsm_timer *this, int milli
  	       this->fi->name, this, millisec);
  #endif
  
++<<<<<<< HEAD
 +	init_timer(&this->tl);
 +	this->tl.function = (void *)fsm_expire_timer;
 +	this->tl.data = (long)this;
++=======
+ 	timer_setup(&this->tl, fsm_expire_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	this->expire_event = event;
  	this->event_arg = arg;
  	this->tl.expires = jiffies + (millisec * HZ) / 1000;
@@@ -191,9 -188,7 +200,13 @@@ fsm_modtimer(fsm_timer *this, int milli
  #endif
  
  	del_timer(&this->tl);
++<<<<<<< HEAD
 +	init_timer(&this->tl);
 +	this->tl.function = (void *)fsm_expire_timer;
 +	this->tl.data = (long)this;
++=======
+ 	timer_setup(&this->tl, fsm_expire_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	this->expire_event = event;
  	this->event_arg = arg;
  	this->tl.expires = jiffies + (millisec * HZ) / 1000;
diff --cc drivers/scsi/arcmsr/arcmsr_hba.c
index 278c9fa62067,21f6421536a0..000000000000
--- a/drivers/scsi/arcmsr/arcmsr_hba.c
+++ b/drivers/scsi/arcmsr/arcmsr_hba.c
@@@ -94,13 -96,15 +94,22 @@@ static void arcmsr_shutdown(struct pci_
  static void arcmsr_iop_init(struct AdapterControlBlock *acb);
  static void arcmsr_free_ccb_pool(struct AdapterControlBlock *acb);
  static u32 arcmsr_disable_outbound_ints(struct AdapterControlBlock *acb);
 -static void arcmsr_enable_outbound_ints(struct AdapterControlBlock *acb,
 -	u32 intmask_org);
  static void arcmsr_stop_adapter_bgrb(struct AdapterControlBlock *acb);
++<<<<<<< HEAD
 +static void arcmsr_flush_hba_cache(struct AdapterControlBlock *acb);
 +static void arcmsr_flush_hbb_cache(struct AdapterControlBlock *acb);
 +static void arcmsr_request_device_map(unsigned long pacb);
 +static void arcmsr_request_hba_device_map(struct AdapterControlBlock *acb);
 +static void arcmsr_request_hbb_device_map(struct AdapterControlBlock *acb);
 +static void arcmsr_request_hbc_device_map(struct AdapterControlBlock *acb);
++=======
+ static void arcmsr_hbaA_flush_cache(struct AdapterControlBlock *acb);
+ static void arcmsr_hbaB_flush_cache(struct AdapterControlBlock *acb);
+ static void arcmsr_request_device_map(struct timer_list *t);
+ static void arcmsr_hbaA_request_device_map(struct AdapterControlBlock *acb);
+ static void arcmsr_hbaB_request_device_map(struct AdapterControlBlock *acb);
+ static void arcmsr_hbaC_request_device_map(struct AdapterControlBlock *acb);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  static void arcmsr_message_isr_bh_fn(struct work_struct *work);
  static bool arcmsr_get_firmware_spec(struct AdapterControlBlock *acb);
  static void arcmsr_start_adapter_bgrb(struct AdapterControlBlock *acb);
@@@ -682,10 -837,8 +691,14 @@@ static int arcmsr_probe(struct pci_dev 
  	atomic_set(&acb->rq_map_token, 16);
  	atomic_set(&acb->ante_token_value, 16);
  	acb->fw_flag = FW_NORMAL;
++<<<<<<< HEAD
 +	init_timer(&acb->eternal_timer);
++=======
+ 	timer_setup(&acb->eternal_timer, arcmsr_request_device_map, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	acb->eternal_timer.expires = jiffies + msecs_to_jiffies(6 * HZ);
 +	acb->eternal_timer.data = (unsigned long) acb;
 +	acb->eternal_timer.function = &arcmsr_request_device_map;
  	add_timer(&acb->eternal_timer);
  	if(arcmsr_alloc_sysfs_attr(acb))
  		goto out_free_sysfs;
@@@ -710,7 -867,85 +723,89 @@@ pci_disable_dev
  	return -ENODEV;
  }
  
++<<<<<<< HEAD
 +static uint8_t arcmsr_abort_hba_allcmd(struct AdapterControlBlock *acb)
++=======
+ static void arcmsr_free_irq(struct pci_dev *pdev,
+ 		struct AdapterControlBlock *acb)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < acb->vector_count; i++)
+ 		free_irq(pci_irq_vector(pdev, i), acb);
+ 	pci_free_irq_vectors(pdev);
+ }
+ 
+ static int arcmsr_suspend(struct pci_dev *pdev, pm_message_t state)
+ {
+ 	uint32_t intmask_org;
+ 	struct Scsi_Host *host = pci_get_drvdata(pdev);
+ 	struct AdapterControlBlock *acb =
+ 		(struct AdapterControlBlock *)host->hostdata;
+ 
+ 	intmask_org = arcmsr_disable_outbound_ints(acb);
+ 	arcmsr_free_irq(pdev, acb);
+ 	del_timer_sync(&acb->eternal_timer);
+ 	flush_work(&acb->arcmsr_do_message_isr_bh);
+ 	arcmsr_stop_adapter_bgrb(acb);
+ 	arcmsr_flush_adapter_cache(acb);
+ 	pci_set_drvdata(pdev, host);
+ 	pci_save_state(pdev);
+ 	pci_disable_device(pdev);
+ 	pci_set_power_state(pdev, pci_choose_state(pdev, state));
+ 	return 0;
+ }
+ 
+ static int arcmsr_resume(struct pci_dev *pdev)
+ {
+ 	int error;
+ 	struct Scsi_Host *host = pci_get_drvdata(pdev);
+ 	struct AdapterControlBlock *acb =
+ 		(struct AdapterControlBlock *)host->hostdata;
+ 
+ 	pci_set_power_state(pdev, PCI_D0);
+ 	pci_enable_wake(pdev, PCI_D0, 0);
+ 	pci_restore_state(pdev);
+ 	if (pci_enable_device(pdev)) {
+ 		pr_warn("%s: pci_enable_device error\n", __func__);
+ 		return -ENODEV;
+ 	}
+ 	error = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));
+ 	if (error) {
+ 		error = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
+ 		if (error) {
+ 			pr_warn("scsi%d: No suitable DMA mask available\n",
+ 			       host->host_no);
+ 			goto controller_unregister;
+ 		}
+ 	}
+ 	pci_set_master(pdev);
+ 	if (arcmsr_request_irq(pdev, acb) == FAILED)
+ 		goto controller_stop;
+ 	arcmsr_iop_init(acb);
+ 	INIT_WORK(&acb->arcmsr_do_message_isr_bh, arcmsr_message_isr_bh_fn);
+ 	atomic_set(&acb->rq_map_token, 16);
+ 	atomic_set(&acb->ante_token_value, 16);
+ 	acb->fw_flag = FW_NORMAL;
+ 	timer_setup(&acb->eternal_timer, arcmsr_request_device_map, 0);
+ 	acb->eternal_timer.expires = jiffies + msecs_to_jiffies(6 * HZ);
+ 	add_timer(&acb->eternal_timer);
+ 	return 0;
+ controller_stop:
+ 	arcmsr_stop_adapter_bgrb(acb);
+ 	arcmsr_flush_adapter_cache(acb);
+ controller_unregister:
+ 	scsi_remove_host(host);
+ 	arcmsr_free_ccb_pool(acb);
+ 	arcmsr_unmap_pciregion(acb);
+ 	pci_release_regions(pdev);
+ 	scsi_host_put(host);
+ 	pci_disable_device(pdev);
+ 	return -ENODEV;
+ }
+ 
+ static uint8_t arcmsr_hbaA_abort_allcmd(struct AdapterControlBlock *acb)
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  {
  	struct MessageUnit_A __iomem *reg = acb->pmuA;
  	writel(ARCMSR_INBOUND_MESG0_ABORT_CMD, &reg->inbound_msgaddr0);
@@@ -2696,12 -3426,41 +2791,45 @@@ static void arcmsr_request_hbc_device_m
  	return;
  }
  
++<<<<<<< HEAD
 +static void arcmsr_request_device_map(unsigned long pacb)
++=======
+ static void arcmsr_hbaD_request_device_map(struct AdapterControlBlock *acb)
+ {
+ 	struct MessageUnit_D *reg = acb->pmuD;
+ 
+ 	if (unlikely(atomic_read(&acb->rq_map_token) == 0) ||
+ 		((acb->acb_flags & ACB_F_BUS_RESET) != 0) ||
+ 		((acb->acb_flags & ACB_F_ABORT) != 0)) {
+ 		mod_timer(&acb->eternal_timer,
+ 			jiffies + msecs_to_jiffies(6 * HZ));
+ 	} else {
+ 		acb->fw_flag = FW_NORMAL;
+ 		if (atomic_read(&acb->ante_token_value) ==
+ 			atomic_read(&acb->rq_map_token)) {
+ 			atomic_set(&acb->rq_map_token, 16);
+ 		}
+ 		atomic_set(&acb->ante_token_value,
+ 			atomic_read(&acb->rq_map_token));
+ 		if (atomic_dec_and_test(&acb->rq_map_token)) {
+ 			mod_timer(&acb->eternal_timer, jiffies +
+ 				msecs_to_jiffies(6 * HZ));
+ 			return;
+ 		}
+ 		writel(ARCMSR_INBOUND_MESG0_GET_CONFIG,
+ 			reg->inbound_msgaddr0);
+ 		mod_timer(&acb->eternal_timer, jiffies +
+ 			msecs_to_jiffies(6 * HZ));
+ 	}
+ }
+ 
+ static void arcmsr_request_device_map(struct timer_list *t)
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  {
- 	struct AdapterControlBlock *acb = (struct AdapterControlBlock *)pacb;
+ 	struct AdapterControlBlock *acb = from_timer(acb, t, eternal_timer);
  	switch (acb->adapter_type) {
  		case ACB_ADAPTER_TYPE_A: {
 -			arcmsr_hbaA_request_device_map(acb);
 +			arcmsr_request_hba_device_map(acb);
  		}
  		break;
  		case ACB_ADAPTER_TYPE_B: {
diff --cc drivers/scsi/arm/fas216.c
index 63392e92520f,f4775ca70bab..000000000000
--- a/drivers/scsi/arm/fas216.c
+++ b/drivers/scsi/arm/fas216.c
@@@ -2844,9 -2849,7 +2844,13 @@@ int fas216_init(struct Scsi_Host *host
  	info->rst_dev_status = -1;
  	info->rst_bus_status = -1;
  	init_waitqueue_head(&info->eh_wait);
++<<<<<<< HEAD
 +	init_timer(&info->eh_timer);
 +	info->eh_timer.data  = (unsigned long)info;
 +	info->eh_timer.function = fas216_eh_timer;
++=======
+ 	timer_setup(&info->eh_timer, fas216_eh_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	
  	spin_lock_init(&info->host_lock);
  
diff --cc drivers/scsi/bfa/bfad.c
index 19a75023d025,cf0466686804..000000000000
--- a/drivers/scsi/bfa/bfad.c
+++ b/drivers/scsi/bfa/bfad.c
@@@ -719,9 -719,7 +719,13 @@@ bfad_bfa_tmo(struct timer_list *t
  void
  bfad_init_timer(struct bfad_s *bfad)
  {
++<<<<<<< HEAD
 +	init_timer(&bfad->hal_tmo);
 +	bfad->hal_tmo.function = bfad_bfa_tmo;
 +	bfad->hal_tmo.data = (unsigned long)bfad;
++=======
+ 	timer_setup(&bfad->hal_tmo, bfad_bfa_tmo, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	mod_timer(&bfad->hal_tmo,
  		  jiffies + msecs_to_jiffies(BFA_TIMER_FREQ));
diff --cc drivers/scsi/ncr53c8xx.c
index 5982a587babc,dc4e801b2cef..000000000000
--- a/drivers/scsi/ncr53c8xx.c
+++ b/drivers/scsi/ncr53c8xx.c
@@@ -8360,9 -8357,7 +8360,13 @@@ struct Scsi_Host * __init ncr_attach(st
  	if (!np->scripth0)
  		goto attach_error;
  
++<<<<<<< HEAD
 +	init_timer(&np->timer);
 +	np->timer.data     = (unsigned long) np;
 +	np->timer.function = ncr53c8xx_timeout;
++=======
+ 	timer_setup(&np->timer, ncr53c8xx_timeout, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	/* Try to map the controller chip to virtual and physical memory. */
  
diff --cc drivers/staging/et131x/et131x.c
index f73e58f5ef8d,48220b6c600d..000000000000
--- a/drivers/staging/et131x/et131x.c
+++ b/drivers/staging/et131x/et131x.c
@@@ -3681,10 -3080,10 +3681,15 @@@ err_out
   * The routine called when the error timer expires, to track the number of
   * recurring errors.
   */
- static void et131x_error_timer_handler(unsigned long data)
+ static void et131x_error_timer_handler(struct timer_list *t)
  {
++<<<<<<< HEAD:drivers/staging/et131x/et131x.c
 +	struct et131x_adapter *adapter = (struct et131x_adapter *) data;
 +	struct phy_device *phydev = adapter->phydev;
++=======
+ 	struct et131x_adapter *adapter = from_timer(adapter, t, error_timer);
+ 	struct phy_device *phydev = adapter->netdev->phydev;
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup()):drivers/net/ethernet/agere/et131x.c
  
  	if (et1310_in_phy_coma(adapter)) {
  		/* Bring the device immediately out of coma, to
@@@ -4354,10 -3624,9 +4359,16 @@@ static int et131x_open(struct net_devic
  	int result;
  
  	/* Start the timer to track NIC errors */
++<<<<<<< HEAD:drivers/staging/et131x/et131x.c
 +	init_timer(&adapter->error_timer);
 +	adapter->error_timer.expires = jiffies + TX_ERROR_PERIOD * HZ / 1000;
 +	adapter->error_timer.function = et131x_error_timer_handler;
 +	adapter->error_timer.data = (unsigned long)adapter;
++=======
+ 	timer_setup(&adapter->error_timer, et131x_error_timer_handler, 0);
+ 	adapter->error_timer.expires = jiffies +
+ 		msecs_to_jiffies(TX_ERROR_PERIOD);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup()):drivers/net/ethernet/agere/et131x.c
  	add_timer(&adapter->error_timer);
  
  	result = request_irq(irq, et131x_isr,
diff --cc drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
index 5ff6803c9763,f56fdc7a4b61..000000000000
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
@@@ -391,10 -391,10 +391,14 @@@ void ieee80211_send_beacon(struct ieee8
  }
  
  
++<<<<<<< HEAD
 +void ieee80211_send_beacon_cb(unsigned long _ieee)
++=======
+ static void ieee80211_send_beacon_cb(struct timer_list *t)
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  {
  	struct ieee80211_device *ieee =
- 		(struct ieee80211_device *) _ieee;
+ 		from_timer(ieee, t, beacon_timer);
  	unsigned long flags;
  
  	spin_lock_irqsave(&ieee->beacon_lock, flags);
@@@ -1250,9 -1251,11 +1254,15 @@@ void ieee80211_associate_abort(struct i
  	spin_unlock_irqrestore(&ieee->lock, flags);
  }
  
++<<<<<<< HEAD
 +void ieee80211_associate_abort_cb(unsigned long dev)
++=======
+ static void ieee80211_associate_abort_cb(struct timer_list *t)
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  {
- 	ieee80211_associate_abort((struct ieee80211_device *) dev);
+ 	struct ieee80211_device *dev = from_timer(dev, t, associate_timer);
+ 
+ 	ieee80211_associate_abort(dev);
  }
  
  
@@@ -2711,29 -2717,24 +2721,35 @@@ void ieee80211_softmac_init(struct ieee
  	ieee->sta_edca_param[2] = 0x005E4342;
  	ieee->sta_edca_param[3] = 0x002F3262;
  	ieee->aggregation = true;
 -	ieee->enable_rx_imm_BA = true;
 +	ieee->enable_rx_imm_BA = 1;
  	ieee->tx_pending.txb = NULL;
  
++<<<<<<< HEAD
 +	init_timer(&ieee->associate_timer);
 +	ieee->associate_timer.data = (unsigned long)ieee;
 +	ieee->associate_timer.function = ieee80211_associate_abort_cb;
 +
 +	init_timer(&ieee->beacon_timer);
 +	ieee->beacon_timer.data = (unsigned long) ieee;
 +	ieee->beacon_timer.function = ieee80211_send_beacon_cb;
++=======
+ 	timer_setup(&ieee->associate_timer, ieee80211_associate_abort_cb, 0);
+ 
+ 	timer_setup(&ieee->beacon_timer, ieee80211_send_beacon_cb, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
 +	ieee->wq = create_workqueue(DRV_NAME);
  
 -	INIT_DELAYED_WORK(&ieee->start_ibss_wq, ieee80211_start_ibss_wq);
 +	INIT_DELAYED_WORK(&ieee->start_ibss_wq,ieee80211_start_ibss_wq);
  	INIT_WORK(&ieee->associate_complete_wq, ieee80211_associate_complete_wq);
  	INIT_WORK(&ieee->associate_procedure_wq, ieee80211_associate_procedure_wq);
 -	INIT_DELAYED_WORK(&ieee->softmac_scan_wq, ieee80211_softmac_scan_wq);
 +	INIT_DELAYED_WORK(&ieee->softmac_scan_wq,ieee80211_softmac_scan_wq);
  	INIT_DELAYED_WORK(&ieee->associate_retry_wq, ieee80211_associate_retry_wq);
 -	INIT_WORK(&ieee->wx_sync_scan_wq, ieee80211_wx_sync_scan_wq);
 +	INIT_WORK(&ieee->wx_sync_scan_wq,ieee80211_wx_sync_scan_wq);
  
  
 -	mutex_init(&ieee->wx_mutex);
 -	mutex_init(&ieee->scan_mutex);
 +	sema_init(&ieee->wx_sem, 1);
 +	sema_init(&ieee->scan_sem, 1);
  
  	spin_lock_init(&ieee->mgmt_tx_lock);
  	spin_lock_init(&ieee->beacon_lock);
diff --cc drivers/staging/rtl8712/recv_linux.c
index 495ee1205e02,986a55bb9877..000000000000
--- a/drivers/staging/rtl8712/recv_linux.c
+++ b/drivers/staging/rtl8712/recv_linux.c
@@@ -132,37 -133,21 +132,49 @@@ void r8712_recv_indicatepkt(struct _ada
  	return;
  _recv_indicatepkt_drop:
  	 /*enqueue back to free_recv_queue*/
 -	if (precv_frame)
 +	 if (precv_frame)
  		r8712_free_recvframe(precv_frame, pfree_recv_queue);
 -	precvpriv->rx_drop++;
 +	 precvpriv->rx_drop++;
  }
  
++<<<<<<< HEAD
 +void r8712_os_read_port(struct _adapter *padapter, struct recv_buf *precvbuf)
 +{
 +	struct recv_priv *precvpriv = &padapter->recvpriv;
 +
 +	precvbuf->ref_cnt--;
 +	/*free skb in recv_buf*/
 +	dev_kfree_skb_any(precvbuf->pskb);
 +	precvbuf->pskb = NULL;
 +	precvbuf->reuse = false;
 +	if (precvbuf->irp_pending == false)
 +		r8712_read_port(padapter, precvpriv->ff_hwaddr, 0,
 +			 (unsigned char *)precvbuf);
 +}
 +
 +static void _r8712_reordering_ctrl_timeout_handler (void *FunctionContext)
 +{
 +	struct recv_reorder_ctrl *preorder_ctrl =
 +			 (struct recv_reorder_ctrl *)FunctionContext;
++=======
+ static void _r8712_reordering_ctrl_timeout_handler (struct timer_list *t)
+ {
+ 	struct recv_reorder_ctrl *preorder_ctrl =
+ 			 from_timer(preorder_ctrl, t, reordering_ctrl_timer);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	r8712_reordering_ctrl_timeout_handler(preorder_ctrl);
  }
  
  void r8712_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl)
  {
++<<<<<<< HEAD
 +	struct _adapter *padapter = preorder_ctrl->padapter;
 +
 +	_init_timer(&(preorder_ctrl->reordering_ctrl_timer), padapter->pnetdev,
 +		    _r8712_reordering_ctrl_timeout_handler, preorder_ctrl);
++=======
+ 	timer_setup(&preorder_ctrl->reordering_ctrl_timer,
+ 		    _r8712_reordering_ctrl_timeout_handler, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  }
diff --cc drivers/staging/rtl8712/rtl8712_led.c
index 6cb1a0af5177,455fba721135..000000000000
--- a/drivers/staging/rtl8712/rtl8712_led.c
+++ b/drivers/staging/rtl8712/rtl8712_led.c
@@@ -97,8 -99,8 +97,13 @@@ static void InitLed871x(struct _adapte
  	pLed->bLedBlinkInProgress = false;
  	pLed->BlinkTimes = 0;
  	pLed->BlinkingLedState = LED_UNKNOWN;
++<<<<<<< HEAD
 +	_init_timer(&(pLed->BlinkTimer), nic, BlinkTimerCallback, pLed);
 +	_init_workitem(&(pLed->BlinkWorkItem), BlinkWorkItemCallback, pLed);
++=======
+ 	timer_setup(&pLed->BlinkTimer, BlinkTimerCallback, 0);
+ 	INIT_WORK(&pLed->BlinkWorkItem, BlinkWorkItemCallback);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  }
  
  /*
@@@ -818,16 -824,16 +823,16 @@@ static void SwLedBlink6(struct LED_871
   *		Callback function of LED BlinkTimer,
   *		it just schedules to corresponding BlinkWorkItem.
   */
- static void BlinkTimerCallback(unsigned long data)
+ static void BlinkTimerCallback(struct timer_list *t)
  {
- 	struct LED_871x  *pLed = (struct LED_871x *)data;
+ 	struct LED_871x  *pLed = from_timer(pLed, t, BlinkTimer);
  
  	/* This fixed the crash problem on Fedora 12 when trying to do the
 -	 * insmod;ifconfig up;rmmod commands.
 -	 */
 -	if (pLed->padapter->bSurpriseRemoved || pLed->padapter->bDriverStopped)
 +	 * insmod;ifconfig up;rmmod commands. */
 +	if ((pLed->padapter->bSurpriseRemoved == true) ||
 +	    (pLed->padapter->bDriverStopped == true))
  		return;
 -	schedule_work(&pLed->BlinkWorkItem);
 +	_set_workitem(&(pLed->BlinkWorkItem));
  }
  
  /*	Description:
diff --cc drivers/staging/unisys/visorbus/visorbus_main.c
index cc4a0292c287,6cb6eb0673c6..000000000000
--- a/drivers/staging/unisys/visorbus/visorbus_main.c
+++ b/drivers/staging/unisys/visorbus/visorbus_main.c
@@@ -583,237 -386,166 +583,243 @@@ static ssize_t channel_id_show(struct d
  	struct visor_device *vdev = to_visor_device(dev);
  	int len = 0;
  
 -	visorchannel_id(vdev->visorchannel, buf);
 -	len = strlen(buf);
 -	buf[len++] = '\n';
 +	if (vdev->visorchannel) {
 +		visorchannel_id(vdev->visorchannel, buf);
 +		len = strlen(buf);
 +		buf[len++] = '\n';
 +	}
  	return len;
  }
 +
 +static ssize_t client_bus_info_show(struct device *dev,
 +				    struct device_attribute *attr,
 +				    char *buf) {
 +	struct visor_device *vdev = to_visor_device(dev);
 +	struct visorchannel *channel = vdev->visorchannel;
 +
 +	int i, x, remain = PAGE_SIZE;
 +	unsigned long off;
 +	char *p = buf;
 +	u8 *partition_name;
 +	struct ultra_vbus_deviceinfo dev_info;
 +
 +	partition_name = "";
 +	if (channel) {
 +		if (vdev->name)
 +			partition_name = vdev->name;
 +		x = snprintf(p, remain,
 +			     "Client device / client driver info for %s partition (vbus #%d):\n",
 +			     partition_name, vdev->chipset_dev_no);
 +		p += x;
 +		remain -= x;
 +		x = visorchannel_read(channel,
 +				      offsetof(struct
 +					       spar_vbus_channel_protocol,
 +					       chp_info),
 +				      &dev_info, sizeof(dev_info));
 +		if (x >= 0) {
 +			x = vbuschannel_devinfo_to_string(&dev_info, p,
 +							  remain, -1);
 +			p += x;
 +			remain -= x;
 +		}
 +		x = visorchannel_read(channel,
 +				      offsetof(struct
 +					       spar_vbus_channel_protocol,
 +					       bus_info),
 +				      &dev_info, sizeof(dev_info));
 +		if (x >= 0) {
 +			x = vbuschannel_devinfo_to_string(&dev_info, p,
 +							  remain, -1);
 +			p += x;
 +			remain -= x;
 +		}
 +		off = offsetof(struct spar_vbus_channel_protocol, dev_info);
 +		i = 0;
 +		while (off + sizeof(dev_info) <=
 +		       visorchannel_get_nbytes(channel)) {
 +			x = visorchannel_read(channel,
 +					      off, &dev_info, sizeof(dev_info));
 +			if (x >= 0) {
 +				x = vbuschannel_devinfo_to_string
 +				    (&dev_info, p, remain, i);
 +				p += x;
 +				remain -= x;
 +			}
 +			off += sizeof(dev_info);
 +			i++;
 +		}
 +	}
 +	return PAGE_SIZE - remain;
 +}
 +
 +static DEVICE_ATTR_RO(partition_handle);
 +static DEVICE_ATTR_RO(partition_guid);
 +static DEVICE_ATTR_RO(partition_name);
 +static DEVICE_ATTR_RO(channel_addr);
 +static DEVICE_ATTR_RO(channel_bytes);
  static DEVICE_ATTR_RO(channel_id);
 +static DEVICE_ATTR_RO(client_bus_info);
 +
 +static struct attribute *dev_attrs[] = {
 +		&dev_attr_partition_handle.attr,
 +		&dev_attr_partition_guid.attr,
 +		&dev_attr_partition_name.attr,
 +		&dev_attr_channel_addr.attr,
 +		&dev_attr_channel_bytes.attr,
 +		&dev_attr_channel_id.attr,
 +		&dev_attr_client_bus_info.attr,
 +		NULL
 +};
  
 -static struct attribute *visorbus_attrs[] = {
 -	&dev_attr_partition_handle.attr,
 -	&dev_attr_partition_guid.attr,
 -	&dev_attr_partition_name.attr,
 -	&dev_attr_channel_addr.attr,
 -	&dev_attr_channel_bytes.attr,
 -	&dev_attr_channel_id.attr,
 -	NULL
++<<<<<<< HEAD
 +static struct attribute_group dev_attr_grp = {
 +		.attrs = dev_attrs,
  };
  
 -ATTRIBUTE_GROUPS(visorbus);
 +static const struct attribute_group *visorbus_groups[] = {
 +		&dev_attr_grp,
 +		NULL
 +};
  
 -/*
 - *  BUS debugfs entries
 +/*  DRIVER attributes
   *
 - *  define & implement display of debugfs attributes under
 - *  /sys/kernel/debug/visorbus/visorbus<n>.
 - */
 -
 -/*
 - * vbuschannel_print_devinfo() - format a struct visor_vbus_deviceinfo
 - *                               and write it to a seq_file
 - * @devinfo: the struct visor_vbus_deviceinfo to format
 - * @seq: seq_file to write to
 - * @devix: the device index to be included in the output data, or -1 if no
 - *         device index is to be included
 + *  define & implement display of driver attributes under
 + *  /sys/bus/visorbus/drivers/<drivername>.
   *
 - * Reads @devInfo, and writes it in human-readable notation to @seq.
   */
 -static void vbuschannel_print_devinfo(struct visor_vbus_deviceinfo *devinfo,
 -				      struct seq_file *seq, int devix)
 -{
 -	/* uninitialized vbus device entry */
 -	if (!isprint(devinfo->devtype[0]))
 -		return;
 -	if (devix >= 0)
 -		seq_printf(seq, "[%d]", devix);
 -	else
 -		/* vbus device entry is for bus or chipset */
 -		seq_puts(seq, "   ");
 -	/*
 -	 * Note: because the s-Par back-end is free to scribble in this area,
 -	 * we never assume '\0'-termination.
 -	 */
 -	seq_printf(seq, "%-*.*s ", (int)sizeof(devinfo->devtype),
 -		   (int)sizeof(devinfo->devtype), devinfo->devtype);
 -	seq_printf(seq, "%-*.*s ", (int)sizeof(devinfo->drvname),
 -		   (int)sizeof(devinfo->drvname), devinfo->drvname);
 -	seq_printf(seq, "%.*s\n", (int)sizeof(devinfo->infostrs),
 -		   devinfo->infostrs);
 -}
  
 -static int bus_info_debugfs_show(struct seq_file *seq, void *v)
 +static ssize_t
 +DRIVER_ATTR_version(struct device_driver *xdrv, char *buf)
  {
 -	int i = 0;
 -	unsigned long off;
 -	struct visor_vbus_deviceinfo dev_info;
 -	struct visor_device *vdev = seq->private;
 -	struct visorchannel *channel = vdev->visorchannel;
 +	struct visor_driver *drv = to_visor_driver(xdrv);
  
 -	if (!channel)
 -		return 0;
 -
 -	seq_printf(seq,
 -		   "Client device/driver info for %s partition (vbus #%u):\n",
 -		   ((vdev->name) ? (char *)(vdev->name) : ""),
 -		   vdev->chipset_bus_no);
 -	if (visorchannel_read(channel,
 -			      offsetof(struct visor_vbus_channel, chp_info),
 -			      &dev_info, sizeof(dev_info)) >= 0)
 -		vbuschannel_print_devinfo(&dev_info, seq, -1);
 -	if (visorchannel_read(channel,
 -			      offsetof(struct visor_vbus_channel, bus_info),
 -			      &dev_info, sizeof(dev_info)) >= 0)
 -		vbuschannel_print_devinfo(&dev_info, seq, -1);
 -
 -	off = offsetof(struct visor_vbus_channel, dev_info);
 -	while (off + sizeof(dev_info) <= visorchannel_get_nbytes(channel)) {
 -		if (visorchannel_read(channel, off, &dev_info,
 -				      sizeof(dev_info)) >= 0)
 -			vbuschannel_print_devinfo(&dev_info, seq, i);
 -		off += sizeof(dev_info);
 -		i++;
 -	}
 -	return 0;
 +	return snprintf(buf, PAGE_SIZE, "%s\n", drv->version);
  }
  
 -static int bus_info_debugfs_open(struct inode *inode, struct file *file)
 +static int
 +register_driver_attributes(struct visor_driver *drv)
  {
 -	return single_open(file, bus_info_debugfs_show, inode->i_private);
 +	int rc;
 +	struct driver_attribute version =
 +	    __ATTR(version, S_IRUGO, DRIVER_ATTR_version, NULL);
 +	drv->version_attr = version;
 +	rc = driver_create_file(&drv->driver, &drv->version_attr);
 +	return rc;
  }
  
 -static const struct file_operations bus_info_debugfs_fops = {
 -	.owner = THIS_MODULE,
 -	.open = bus_info_debugfs_open,
 -	.read = seq_read,
 -	.llseek = seq_lseek,
 -	.release = single_release,
 -};
 +static void
 +unregister_driver_attributes(struct visor_driver *drv)
 +{
 +	driver_remove_file(&drv->driver, &drv->version_attr);
 +}
  
 +static void
 +dev_periodic_work(void *xdev)
 +{
 +	struct visor_device *dev = (struct visor_device *)xdev;
++=======
+ static void dev_periodic_work(struct timer_list *t)
+ {
+ 	struct visor_device *dev = from_timer(dev, t, timer);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	struct visor_driver *drv = to_visor_driver(dev->device.driver);
  
 -	drv->channel_interrupt(dev);
 -	mod_timer(&dev->timer, jiffies + POLLJIFFIES_NORMALCHANNEL);
 +	down(&dev->visordriver_callback_lock);
 +	if (drv->channel_interrupt)
 +		drv->channel_interrupt(dev);
 +	up(&dev->visordriver_callback_lock);
 +	if (!visor_periodic_work_nextperiod(dev->periodic_work))
 +		put_device(&dev->device);
  }
  
 -static int dev_start_periodic_work(struct visor_device *dev)
 +static void
 +dev_start_periodic_work(struct visor_device *dev)
  {
 -	if (dev->being_removed || dev->timer_active)
 -		return -EINVAL;
 -
 +	if (dev->being_removed)
 +		return;
  	/* now up by at least 2 */
  	get_device(&dev->device);
 -	dev->timer.expires = jiffies + POLLJIFFIES_NORMALCHANNEL;
 -	add_timer(&dev->timer);
 -	dev->timer_active = true;
 -	return 0;
 +	if (!visor_periodic_work_start(dev->periodic_work))
 +		put_device(&dev->device);
  }
  
 -static void dev_stop_periodic_work(struct visor_device *dev)
 +static void
 +dev_stop_periodic_work(struct visor_device *dev)
  {
 -	if (!dev->timer_active)
 -		return;
 +	if (visor_periodic_work_stop(dev->periodic_work))
 +		put_device(&dev->device);
 +}
  
 -	del_timer_sync(&dev->timer);
 -	dev->timer_active = false;
 -	put_device(&dev->device);
 +/** This is called automatically upon adding a visor_device (device_add), or
 + *  adding a visor_driver (visorbus_register_visor_driver), but only after
 + *  visorbus_match has returned 1 to indicate a successful match between
 + *  driver and device.
 + */
 +static int
 +visordriver_probe_device(struct device *xdev)
 +{
 +	int rc;
 +	struct visor_driver *drv;
 +	struct visor_device *dev;
 +
 +	drv = to_visor_driver(xdev->driver);
 +	dev = to_visor_device(xdev);
 +	down(&dev->visordriver_callback_lock);
 +	dev->being_removed = false;
 +	/*
 +	 * ensure that the dev->being_removed flag is cleared before
 +	 * we start the probe
 +	 */
 +	wmb();
 +	get_device(&dev->device);
 +	if (!drv->probe) {
 +		up(&dev->visordriver_callback_lock);
 +		rc = -1;
 +		goto away;
 +	}
 +	rc = drv->probe(dev);
 +	if (rc < 0)
 +		goto away;
 +
 +	fix_vbus_dev_info(dev);
 +	up(&dev->visordriver_callback_lock);
 +	rc = 0;
 +away:
 +	if (rc != 0)
 +		put_device(&dev->device);
 +	return rc;
  }
  
 -/*
 - * visordriver_remove_device() - handle visor device going away
 - * @xdev: struct device for the visor device being removed
 - *
 - * This is called when device_unregister() is called for each child device
 - * instance, to notify the appropriate visorbus function driver that the device
 - * is going away, and to decrease the reference count of the device.
 - *
 - * Return: 0 iff successful
 +/** This is called when device_unregister() is called for each child device
 + *  instance, to notify the appropriate visorbus_driver that the device is
 + *  going away, and to decrease the reference count of the device.
   */
 -static int visordriver_remove_device(struct device *xdev)
 +static int
 +visordriver_remove_device(struct device *xdev)
  {
 -	struct visor_device *dev = to_visor_device(xdev);
 -	struct visor_driver *drv = to_visor_driver(xdev->driver);
 +	struct visor_device *dev;
 +	struct visor_driver *drv;
  
 -	mutex_lock(&dev->visordriver_callback_lock);
 +	dev = to_visor_device(xdev);
 +	drv = to_visor_driver(xdev->driver);
 +	down(&dev->visordriver_callback_lock);
  	dev->being_removed = true;
 -	drv->remove(dev);
 -	mutex_unlock(&dev->visordriver_callback_lock);
 +	/*
 +	 * ensure that the dev->being_removed flag is set before we start the
 +	 * actual removal
 +	 */
 +	wmb();
 +	if (drv) {
 +		if (drv->remove)
 +			drv->remove(dev);
 +	}
 +	up(&dev->visordriver_callback_lock);
  	dev_stop_periodic_work(dev);
 +	devmajorminor_remove_all_files(dev);
 +
  	put_device(&dev->device);
 +
  	return 0;
  }
  
@@@ -980,25 -667,18 +986,33 @@@ create_visor_device(struct visor_devic
  	dev->device.release = visorbus_release_device;
  	/* keep a reference just for us (now 2) */
  	get_device(&dev->device);
++<<<<<<< HEAD
 +	dev->periodic_work =
 +		visor_periodic_work_create(POLLJIFFIES_NORMALCHANNEL,
 +					   periodic_dev_workqueue,
 +					   dev_periodic_work,
 +					   dev, dev_name(&dev->device));
 +	if (!dev->periodic_work) {
 +		POSTCODE_LINUX_3(DEVICE_CREATE_FAILURE_PC, chipset_dev_no,
 +				 DIAG_SEVERITY_ERR);
 +		goto away;
 +	}
 +
 +	/* bus_id must be a unique name with respect to this bus TYPE
 +	 * (NOT bus instance).  That's why we need to include the bus
 +	 * number within the name.
++=======
+ 	timer_setup(&dev->timer, dev_periodic_work, 0);
+ 	/*
+ 	 * bus_id must be a unique name with respect to this bus TYPE (NOT bus
+ 	 * instance).  That's why we need to include the bus number within the
+ 	 * name.
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	 */
 -	err = dev_set_name(&dev->device, "vbus%u:dev%u",
 -			   chipset_bus_no, chipset_dev_no);
 -	if (err)
 -		goto err_put;
 -	/*
 -	 * device_add does this:
 +	dev_set_name(&dev->device, "vbus%u:dev%u",
 +		     chipset_bus_no, chipset_dev_no);
 +
 +	/*  device_add does this:
  	 *    bus_add_device(dev)
  	 *    ->device_attach(dev)
  	 *      ->for each driver drv registered on the bus that dev is on
diff --cc drivers/staging/unisys/visornic/visornic_main.c
index 10459e8373b7,6d8239163ba5..000000000000
--- a/drivers/staging/unisys/visornic/visornic_main.c
+++ b/drivers/staging/unisys/visornic/visornic_main.c
@@@ -1740,18 -1760,16 +1740,23 @@@ static int visornic_poll(struct napi_st
  	return rx_count;
  }
  
 -/* poll_for_irq	- checks the status of the response queue
 - * @v: Void pointer to the visronic devdata struct.
 +/**
 + *	poll_for_irq	- Checks the status of the response queue.
 + *	@v: void pointer to the visronic devdata
   *
 - * Main function of the vnic_incoming thread. Periodically check the response
 - * queue and drain it if needed.
 + *	Main function of the vnic_incoming thread. Peridocially check the
 + *	response queue and drain it if needed.
 + *	Returns when thread has stopped.
   */
++<<<<<<< HEAD
 +static void
 +poll_for_irq(unsigned long v)
++=======
+ static void poll_for_irq(struct timer_list *t)
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  {
- 	struct visornic_devdata *devdata = (struct visornic_devdata *)v;
+ 	struct visornic_devdata *devdata = from_timer(devdata, t,
+ 						      irq_poll_timer);
  
  	if (!visorchannel_signalempty(
  				   devdata->dev->visorchannel,
@@@ -1880,12 -1898,10 +1885,17 @@@ static int visornic_probe(struct visor_
  
  	/* TODO: Setup Interrupt information */
  	/* Let's start our threads to get responses */
 -	netif_napi_add(netdev, &devdata->napi, visornic_poll, NAPI_WEIGHT);
 -
 +	netif_napi_add(netdev, &devdata->napi, visornic_poll, 64);
 +
++<<<<<<< HEAD
 +	setup_timer(&devdata->irq_poll_timer, poll_for_irq,
 +		    (unsigned long)devdata);
 +	/*
 +	 * Note: This time has to start running before the while
++=======
+ 	timer_setup(&devdata->irq_poll_timer, poll_for_irq, 0);
+ 	/* Note: This time has to start running before the while
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	 * loop below because the napi routine is responsible for
  	 * setting enab_dis_acked
  	 */
diff --cc drivers/tty/n_gsm.c
index 86e3e207c94b,5131bdc9e765..000000000000
--- a/drivers/tty/n_gsm.c
+++ b/drivers/tty/n_gsm.c
@@@ -1638,9 -1634,7 +1638,13 @@@ static struct gsm_dlci *gsm_dlci_alloc(
  	}
  
  	skb_queue_head_init(&dlci->skb_list);
++<<<<<<< HEAD
 +	init_timer(&dlci->t1);
 +	dlci->t1.function = gsm_dlci_t1;
 +	dlci->t1.data = (unsigned long)dlci;
++=======
+ 	timer_setup(&dlci->t1, gsm_dlci_t1, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	tty_port_init(&dlci->port);
  	dlci->port.ops = &gsm_port_ops;
  	dlci->gsm = gsm;
@@@ -2077,9 -2088,7 +2081,13 @@@ int gsm_activate_mux(struct gsm_mux *gs
  	struct gsm_dlci *dlci;
  	int i = 0;
  
++<<<<<<< HEAD
 +	init_timer(&gsm->t2_timer);
 +	gsm->t2_timer.function = gsm_control_retransmit;
 +	gsm->t2_timer.data = (unsigned long)gsm;
++=======
+ 	timer_setup(&gsm->t2_timer, gsm_control_retransmit, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	init_waitqueue_head(&gsm->event);
  	spin_lock_init(&gsm->control_lock);
  	spin_lock_init(&gsm->tx_lock);
diff --cc drivers/tty/serial/ifx6x60.c
index 8b1534c424af,ffefd218761e..000000000000
--- a/drivers/tty/serial/ifx6x60.c
+++ b/drivers/tty/serial/ifx6x60.c
@@@ -1026,9 -1016,7 +1026,13 @@@ static int ifx_spi_spi_probe(struct spi
  	spin_lock_init(&ifx_dev->write_lock);
  	spin_lock_init(&ifx_dev->power_lock);
  	ifx_dev->power_status = 0;
++<<<<<<< HEAD
 +	init_timer(&ifx_dev->spi_timer);
 +	ifx_dev->spi_timer.function = ifx_spi_timeout;
 +	ifx_dev->spi_timer.data = (unsigned long)ifx_dev;
++=======
+ 	timer_setup(&ifx_dev->spi_timer, ifx_spi_timeout, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	ifx_dev->modem = pl_data->modem_type;
  	ifx_dev->use_dma = pl_data->use_dma;
  	ifx_dev->max_hz = pl_data->max_hz;
diff --cc drivers/tty/serial/imx.c
index 8cdfbd365892,e4b3d9123a03..000000000000
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@@ -661,10 -902,181 +661,21 @@@ static void imx_break_ctl(struct uart_p
  	spin_unlock_irqrestore(&sport->port.lock, flags);
  }
  
++<<<<<<< HEAD
 +#define TXTL 2 /* reset default */
 +#define RXTL 1 /* reset default */
++=======
+ /*
+  * This is our per-port timeout handler, for checking the
+  * modem status signals.
+  */
+ static void imx_timeout(struct timer_list *t)
+ {
+ 	struct imx_port *sport = from_timer(sport, t, timer);
+ 	unsigned long flags;
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
 -	if (sport->port.state) {
 -		spin_lock_irqsave(&sport->port.lock, flags);
 -		imx_mctrl_check(sport);
 -		spin_unlock_irqrestore(&sport->port.lock, flags);
 -
 -		mod_timer(&sport->timer, jiffies + MCTRL_TIMEOUT);
 -	}
 -}
 -
 -#define RX_BUF_SIZE	(PAGE_SIZE)
 -
 -/*
 - * There are two kinds of RX DMA interrupts(such as in the MX6Q):
 - *   [1] the RX DMA buffer is full.
 - *   [2] the aging timer expires
 - *
 - * Condition [2] is triggered when a character has been sitting in the FIFO
 - * for at least 8 byte durations.
 - */
 -static void dma_rx_callback(void *data)
 -{
 -	struct imx_port *sport = data;
 -	struct dma_chan	*chan = sport->dma_chan_rx;
 -	struct scatterlist *sgl = &sport->rx_sgl;
 -	struct tty_port *port = &sport->port.state->port;
 -	struct dma_tx_state state;
 -	struct circ_buf *rx_ring = &sport->rx_ring;
 -	enum dma_status status;
 -	unsigned int w_bytes = 0;
 -	unsigned int r_bytes;
 -	unsigned int bd_size;
 -
 -	status = dmaengine_tx_status(chan, (dma_cookie_t)0, &state);
 -
 -	if (status == DMA_ERROR) {
 -		dev_err(sport->port.dev, "DMA transaction error.\n");
 -		clear_rx_errors(sport);
 -		return;
 -	}
 -
 -	if (!(sport->port.ignore_status_mask & URXD_DUMMY_READ)) {
 -
 -		/*
 -		 * The state-residue variable represents the empty space
 -		 * relative to the entire buffer. Taking this in consideration
 -		 * the head is always calculated base on the buffer total
 -		 * length - DMA transaction residue. The UART script from the
 -		 * SDMA firmware will jump to the next buffer descriptor,
 -		 * once a DMA transaction if finalized (IMX53 RM - A.4.1.2.4).
 -		 * Taking this in consideration the tail is always at the
 -		 * beginning of the buffer descriptor that contains the head.
 -		 */
 -
 -		/* Calculate the head */
 -		rx_ring->head = sg_dma_len(sgl) - state.residue;
 -
 -		/* Calculate the tail. */
 -		bd_size = sg_dma_len(sgl) / sport->rx_periods;
 -		rx_ring->tail = ((rx_ring->head-1) / bd_size) * bd_size;
 -
 -		if (rx_ring->head <= sg_dma_len(sgl) &&
 -		    rx_ring->head > rx_ring->tail) {
 -
 -			/* Move data from tail to head */
 -			r_bytes = rx_ring->head - rx_ring->tail;
 -
 -			/* CPU claims ownership of RX DMA buffer */
 -			dma_sync_sg_for_cpu(sport->port.dev, sgl, 1,
 -				DMA_FROM_DEVICE);
 -
 -			w_bytes = tty_insert_flip_string(port,
 -				sport->rx_buf + rx_ring->tail, r_bytes);
 -
 -			/* UART retrieves ownership of RX DMA buffer */
 -			dma_sync_sg_for_device(sport->port.dev, sgl, 1,
 -				DMA_FROM_DEVICE);
 -
 -			if (w_bytes != r_bytes)
 -				sport->port.icount.buf_overrun++;
 -
 -			sport->port.icount.rx += w_bytes;
 -		} else	{
 -			WARN_ON(rx_ring->head > sg_dma_len(sgl));
 -			WARN_ON(rx_ring->head <= rx_ring->tail);
 -		}
 -	}
 -
 -	if (w_bytes) {
 -		tty_flip_buffer_push(port);
 -		dev_dbg(sport->port.dev, "We get %d bytes.\n", w_bytes);
 -	}
 -}
 -
 -/* RX DMA buffer periods */
 -#define RX_DMA_PERIODS 4
 -
 -static int start_rx_dma(struct imx_port *sport)
 -{
 -	struct scatterlist *sgl = &sport->rx_sgl;
 -	struct dma_chan	*chan = sport->dma_chan_rx;
 -	struct device *dev = sport->port.dev;
 -	struct dma_async_tx_descriptor *desc;
 -	int ret;
 -
 -	sport->rx_ring.head = 0;
 -	sport->rx_ring.tail = 0;
 -	sport->rx_periods = RX_DMA_PERIODS;
 -
 -	sg_init_one(sgl, sport->rx_buf, RX_BUF_SIZE);
 -	ret = dma_map_sg(dev, sgl, 1, DMA_FROM_DEVICE);
 -	if (ret == 0) {
 -		dev_err(dev, "DMA mapping error for RX.\n");
 -		return -EINVAL;
 -	}
 -
 -	desc = dmaengine_prep_dma_cyclic(chan, sg_dma_address(sgl),
 -		sg_dma_len(sgl), sg_dma_len(sgl) / sport->rx_periods,
 -		DMA_DEV_TO_MEM, DMA_PREP_INTERRUPT);
 -
 -	if (!desc) {
 -		dma_unmap_sg(dev, sgl, 1, DMA_FROM_DEVICE);
 -		dev_err(dev, "We cannot prepare for the RX slave dma!\n");
 -		return -EINVAL;
 -	}
 -	desc->callback = dma_rx_callback;
 -	desc->callback_param = sport;
 -
 -	dev_dbg(dev, "RX: prepare for the DMA.\n");
 -	sport->dma_is_rxing = 1;
 -	sport->rx_cookie = dmaengine_submit(desc);
 -	dma_async_issue_pending(chan);
 -	return 0;
 -}
 -
 -static void clear_rx_errors(struct imx_port *sport)
 -{
 -	unsigned int status_usr1, status_usr2;
 -
 -	status_usr1 = readl(sport->port.membase + USR1);
 -	status_usr2 = readl(sport->port.membase + USR2);
 -
 -	if (status_usr2 & USR2_BRCD) {
 -		sport->port.icount.brk++;
 -		writel(USR2_BRCD, sport->port.membase + USR2);
 -	} else if (status_usr1 & USR1_FRAMERR) {
 -		sport->port.icount.frame++;
 -		writel(USR1_FRAMERR, sport->port.membase + USR1);
 -	} else if (status_usr1 & USR1_PARITYERR) {
 -		sport->port.icount.parity++;
 -		writel(USR1_PARITYERR, sport->port.membase + USR1);
 -	}
 -
 -	if (status_usr2 & USR2_ORE) {
 -		sport->port.icount.overrun++;
 -		writel(USR2_ORE, sport->port.membase + USR2);
 -	}
 -
 -}
 -
 -#define TXTL_DEFAULT 2 /* reset default */
 -#define RXTL_DEFAULT 1 /* reset default */
 -#define TXTL_DMA 8 /* DMA burst setting */
 -#define RXTL_DMA 9 /* DMA burst setting */
 -
 -static void imx_setup_ufcr(struct imx_port *sport,
 -			  unsigned char txwl, unsigned char rxwl)
 +static int imx_setup_ufcr(struct imx_port *sport, unsigned int mode)
  {
  	unsigned int val;
  
@@@ -1493,23 -2076,17 +1504,27 @@@ static int serial_imx_probe(struct plat
  	sport->port.membase = base;
  	sport->port.type = PORT_IMX,
  	sport->port.iotype = UPIO_MEM;
 -	sport->port.irq = rxirq;
 +	sport->port.irq = platform_get_irq(pdev, 0);
 +	sport->rxirq = platform_get_irq(pdev, 0);
 +	sport->txirq = platform_get_irq(pdev, 1);
 +	sport->rtsirq = platform_get_irq(pdev, 2);
  	sport->port.fifosize = 32;
  	sport->port.ops = &imx_pops;
 -	sport->port.rs485_config = imx_rs485_config;
 -	sport->port.rs485.flags |= SER_RS485_RTS_ON_SEND;
  	sport->port.flags = UPF_BOOT_AUTOCONF;
++<<<<<<< HEAD
 +	init_timer(&sport->timer);
 +	sport->timer.function = imx_timeout;
 +	sport->timer.data     = (unsigned long)sport;
++=======
+ 	timer_setup(&sport->timer, imx_timeout, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
 -	sport->gpios = mctrl_gpio_init(&sport->port, 0);
 -	if (IS_ERR(sport->gpios))
 -		return PTR_ERR(sport->gpios);
 +	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
 +	if (IS_ERR(pinctrl)) {
 +		ret = PTR_ERR(pinctrl);
 +		dev_err(&pdev->dev, "failed to get default pinctrl: %d\n", ret);
 +		return ret;
 +	}
  
  	sport->clk_ipg = devm_clk_get(&pdev->dev, "ipg");
  	if (IS_ERR(sport->clk_ipg)) {
diff --cc drivers/tty/serial/kgdb_nmi.c
index 5dafcf1c227b,4029272891f9..000000000000
--- a/drivers/tty/serial/kgdb_nmi.c
+++ b/drivers/tty/serial/kgdb_nmi.c
@@@ -200,14 -188,16 +200,14 @@@ bool kgdb_nmi_poll_knock(void
   * The tasklet is cheap, it does not cause wakeups when reschedules itself,
   * instead it waits for the next tick.
   */
- static void kgdb_nmi_tty_receiver(unsigned long data)
+ static void kgdb_nmi_tty_receiver(struct timer_list *t)
  {
- 	struct kgdb_nmi_tty_priv *priv = (void *)data;
+ 	struct kgdb_nmi_tty_priv *priv = from_timer(priv, t, timer);
  	char ch;
  
 -	priv->timer.expires = jiffies + (HZ/100);
 -	add_timer(&priv->timer);
 +	tasklet_schedule(&priv->tlet);
  
 -	if (likely(!atomic_read(&kgdb_nmi_num_readers) ||
 -		   !kfifo_len(&priv->fifo)))
 +	if (likely(!kgdb_nmi_tty_enabled || !kfifo_len(&priv->fifo)))
  		return;
  
  	while (kfifo_out(&priv->fifo, &ch, 1))
@@@ -247,7 -241,7 +247,11 @@@ static int kgdb_nmi_tty_install(struct 
  		return -ENOMEM;
  
  	INIT_KFIFO(priv->fifo);
++<<<<<<< HEAD
 +	tasklet_init(&priv->tlet, kgdb_nmi_tty_receiver, (unsigned long)priv);
++=======
+ 	timer_setup(&priv->timer, kgdb_nmi_tty_receiver, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	tty_port_init(&priv->port);
  	priv->port.ops = &kgdb_nmi_tty_port_ops;
  	tty->driver_data = priv;
diff --cc drivers/tty/serial/max3100.c
index 35866d5872ad,371569a0fd00..000000000000
--- a/drivers/tty/serial/max3100.c
+++ b/drivers/tty/serial/max3100.c
@@@ -787,9 -780,7 +787,13 @@@ static int max3100_probe(struct spi_dev
  		max3100s[i]->poll_time = 1;
  	max3100s[i]->max3100_hw_suspend = pdata->max3100_hw_suspend;
  	max3100s[i]->minor = i;
++<<<<<<< HEAD
 +	init_timer(&max3100s[i]->timer);
 +	max3100s[i]->timer.function = max3100_timeout;
 +	max3100s[i]->timer.data = (unsigned long) max3100s[i];
++=======
+ 	timer_setup(&max3100s[i]->timer, max3100_timeout, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	dev_dbg(&spi->dev, "%s: adding port %d\n", __func__, i);
  	max3100s[i]->port.irq = max3100s[i]->irq;
diff --cc drivers/tty/serial/mux.c
index 7fd6aaaacd8e,00ce31e8d19a..000000000000
--- a/drivers/tty/serial/mux.c
+++ b/drivers/tty/serial/mux.c
@@@ -592,8 -572,7 +592,12 @@@ static int __init mux_init(void
  
  	if(port_cnt > 0) {
  		/* Start the Mux timer */
++<<<<<<< HEAD
 +		init_timer(&mux_timer);
 +		mux_timer.function = mux_poll;
++=======
+ 		timer_setup(&mux_timer, mux_poll, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  		mod_timer(&mux_timer, jiffies + MUX_POLL_DELAY);
  
  #ifdef CONFIG_SERIAL_MUX_CONSOLE
diff --cc drivers/tty/serial/pnx8xxx_uart.c
index 7e277a5384a7,223a9499104e..000000000000
--- a/drivers/tty/serial/pnx8xxx_uart.c
+++ b/drivers/tty/serial/pnx8xxx_uart.c
@@@ -648,9 -662,7 +648,13 @@@ static void __init pnx8xxx_init_ports(v
  	first = 0;
  
  	for (i = 0; i < NR_PORTS; i++) {
++<<<<<<< HEAD
 +		init_timer(&pnx8xxx_ports[i].timer);
 +		pnx8xxx_ports[i].timer.function = pnx8xxx_timeout;
 +		pnx8xxx_ports[i].timer.data     = (unsigned long)&pnx8xxx_ports[i];
++=======
+ 		timer_setup(&pnx8xxx_ports[i].timer, pnx8xxx_timeout, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  		pnx8xxx_ports[i].port.ops = &pnx8xxx_pops;
  	}
  }
diff --cc drivers/tty/serial/sa1100.c
index af6b3e3ad24d,a399772be3fc..000000000000
--- a/drivers/tty/serial/sa1100.c
+++ b/drivers/tty/serial/sa1100.c
@@@ -623,9 -627,7 +623,13 @@@ static void __init sa1100_init_ports(vo
  		sa1100_ports[i].port.fifosize  = 8;
  		sa1100_ports[i].port.line      = i;
  		sa1100_ports[i].port.iotype    = UPIO_MEM;
++<<<<<<< HEAD
 +		init_timer(&sa1100_ports[i].timer);
 +		sa1100_ports[i].timer.function = sa1100_timeout;
 +		sa1100_ports[i].timer.data     = (unsigned long)&sa1100_ports[i];
++=======
+ 		timer_setup(&sa1100_ports[i].timer, sa1100_timeout, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	}
  
  	/*
diff --cc drivers/tty/serial/sh-sci.c
index 156418619949,d9f399c4e90c..000000000000
--- a/drivers/tty/serial/sh-sci.c
+++ b/drivers/tty/serial/sh-sci.c
@@@ -845,9 -990,626 +845,630 @@@ static int sci_handle_breaks(struct uar
  	return copied;
  }
  
++<<<<<<< HEAD
++=======
+ static int scif_set_rtrg(struct uart_port *port, int rx_trig)
+ {
+ 	unsigned int bits;
+ 
+ 	if (rx_trig < 1)
+ 		rx_trig = 1;
+ 	if (rx_trig >= port->fifosize)
+ 		rx_trig = port->fifosize;
+ 
+ 	/* HSCIF can be set to an arbitrary level. */
+ 	if (sci_getreg(port, HSRTRGR)->size) {
+ 		serial_port_out(port, HSRTRGR, rx_trig);
+ 		return rx_trig;
+ 	}
+ 
+ 	switch (port->type) {
+ 	case PORT_SCIF:
+ 		if (rx_trig < 4) {
+ 			bits = 0;
+ 			rx_trig = 1;
+ 		} else if (rx_trig < 8) {
+ 			bits = SCFCR_RTRG0;
+ 			rx_trig = 4;
+ 		} else if (rx_trig < 14) {
+ 			bits = SCFCR_RTRG1;
+ 			rx_trig = 8;
+ 		} else {
+ 			bits = SCFCR_RTRG0 | SCFCR_RTRG1;
+ 			rx_trig = 14;
+ 		}
+ 		break;
+ 	case PORT_SCIFA:
+ 	case PORT_SCIFB:
+ 		if (rx_trig < 16) {
+ 			bits = 0;
+ 			rx_trig = 1;
+ 		} else if (rx_trig < 32) {
+ 			bits = SCFCR_RTRG0;
+ 			rx_trig = 16;
+ 		} else if (rx_trig < 48) {
+ 			bits = SCFCR_RTRG1;
+ 			rx_trig = 32;
+ 		} else {
+ 			bits = SCFCR_RTRG0 | SCFCR_RTRG1;
+ 			rx_trig = 48;
+ 		}
+ 		break;
+ 	default:
+ 		WARN(1, "unknown FIFO configuration");
+ 		return 1;
+ 	}
+ 
+ 	serial_port_out(port, SCFCR,
+ 		(serial_port_in(port, SCFCR) &
+ 		~(SCFCR_RTRG1 | SCFCR_RTRG0)) | bits);
+ 
+ 	return rx_trig;
+ }
+ 
+ static int scif_rtrg_enabled(struct uart_port *port)
+ {
+ 	if (sci_getreg(port, HSRTRGR)->size)
+ 		return serial_port_in(port, HSRTRGR) != 0;
+ 	else
+ 		return (serial_port_in(port, SCFCR) &
+ 			(SCFCR_RTRG0 | SCFCR_RTRG1)) != 0;
+ }
+ 
+ static void rx_fifo_timer_fn(struct timer_list *t)
+ {
+ 	struct sci_port *s = from_timer(s, t, rx_fifo_timer);
+ 	struct uart_port *port = &s->port;
+ 
+ 	dev_dbg(port->dev, "Rx timed out\n");
+ 	scif_set_rtrg(port, 1);
+ }
+ 
+ static ssize_t rx_trigger_show(struct device *dev,
+ 			       struct device_attribute *attr,
+ 			       char *buf)
+ {
+ 	struct uart_port *port = dev_get_drvdata(dev);
+ 	struct sci_port *sci = to_sci_port(port);
+ 
+ 	return sprintf(buf, "%d\n", sci->rx_trigger);
+ }
+ 
+ static ssize_t rx_trigger_store(struct device *dev,
+ 				struct device_attribute *attr,
+ 				const char *buf,
+ 				size_t count)
+ {
+ 	struct uart_port *port = dev_get_drvdata(dev);
+ 	struct sci_port *sci = to_sci_port(port);
+ 	int ret;
+ 	long r;
+ 
+ 	ret = kstrtol(buf, 0, &r);
+ 	if (ret)
+ 		return ret;
+ 
+ 	sci->rx_trigger = scif_set_rtrg(port, r);
+ 	if (port->type == PORT_SCIFA || port->type == PORT_SCIFB)
+ 		scif_set_rtrg(port, 1);
+ 
+ 	return count;
+ }
+ 
+ static DEVICE_ATTR(rx_fifo_trigger, 0644, rx_trigger_show, rx_trigger_store);
+ 
+ static ssize_t rx_fifo_timeout_show(struct device *dev,
+ 			       struct device_attribute *attr,
+ 			       char *buf)
+ {
+ 	struct uart_port *port = dev_get_drvdata(dev);
+ 	struct sci_port *sci = to_sci_port(port);
+ 	int v;
+ 
+ 	if (port->type == PORT_HSCIF)
+ 		v = sci->hscif_tot >> HSSCR_TOT_SHIFT;
+ 	else
+ 		v = sci->rx_fifo_timeout;
+ 
+ 	return sprintf(buf, "%d\n", v);
+ }
+ 
+ static ssize_t rx_fifo_timeout_store(struct device *dev,
+ 				struct device_attribute *attr,
+ 				const char *buf,
+ 				size_t count)
+ {
+ 	struct uart_port *port = dev_get_drvdata(dev);
+ 	struct sci_port *sci = to_sci_port(port);
+ 	int ret;
+ 	long r;
+ 
+ 	ret = kstrtol(buf, 0, &r);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (port->type == PORT_HSCIF) {
+ 		if (r < 0 || r > 3)
+ 			return -EINVAL;
+ 		sci->hscif_tot = r << HSSCR_TOT_SHIFT;
+ 	} else {
+ 		sci->rx_fifo_timeout = r;
+ 		scif_set_rtrg(port, 1);
+ 		if (r > 0)
+ 			timer_setup(&sci->rx_fifo_timer, rx_fifo_timer_fn, 0);
+ 	}
+ 
+ 	return count;
+ }
+ 
+ static DEVICE_ATTR(rx_fifo_timeout, 0644, rx_fifo_timeout_show, rx_fifo_timeout_store);
+ 
+ 
+ #ifdef CONFIG_SERIAL_SH_SCI_DMA
+ static void sci_dma_tx_complete(void *arg)
+ {
+ 	struct sci_port *s = arg;
+ 	struct uart_port *port = &s->port;
+ 	struct circ_buf *xmit = &port->state->xmit;
+ 	unsigned long flags;
+ 
+ 	dev_dbg(port->dev, "%s(%d)\n", __func__, port->line);
+ 
+ 	spin_lock_irqsave(&port->lock, flags);
+ 
+ 	xmit->tail += s->tx_dma_len;
+ 	xmit->tail &= UART_XMIT_SIZE - 1;
+ 
+ 	port->icount.tx += s->tx_dma_len;
+ 
+ 	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+ 		uart_write_wakeup(port);
+ 
+ 	if (!uart_circ_empty(xmit)) {
+ 		s->cookie_tx = 0;
+ 		schedule_work(&s->work_tx);
+ 	} else {
+ 		s->cookie_tx = -EINVAL;
+ 		if (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {
+ 			u16 ctrl = serial_port_in(port, SCSCR);
+ 			serial_port_out(port, SCSCR, ctrl & ~SCSCR_TIE);
+ 		}
+ 	}
+ 
+ 	spin_unlock_irqrestore(&port->lock, flags);
+ }
+ 
+ /* Locking: called with port lock held */
+ static int sci_dma_rx_push(struct sci_port *s, void *buf, size_t count)
+ {
+ 	struct uart_port *port = &s->port;
+ 	struct tty_port *tport = &port->state->port;
+ 	int copied;
+ 
+ 	copied = tty_insert_flip_string(tport, buf, count);
+ 	if (copied < count)
+ 		port->icount.buf_overrun++;
+ 
+ 	port->icount.rx += copied;
+ 
+ 	return copied;
+ }
+ 
+ static int sci_dma_rx_find_active(struct sci_port *s)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(s->cookie_rx); i++)
+ 		if (s->active_rx == s->cookie_rx[i])
+ 			return i;
+ 
+ 	return -1;
+ }
+ 
+ static void sci_rx_dma_release(struct sci_port *s, bool enable_pio)
+ {
+ 	struct dma_chan *chan = s->chan_rx;
+ 	struct uart_port *port = &s->port;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&port->lock, flags);
+ 	s->chan_rx = NULL;
+ 	s->cookie_rx[0] = s->cookie_rx[1] = -EINVAL;
+ 	spin_unlock_irqrestore(&port->lock, flags);
+ 	dmaengine_terminate_all(chan);
+ 	dma_free_coherent(chan->device->dev, s->buf_len_rx * 2, s->rx_buf[0],
+ 			  sg_dma_address(&s->sg_rx[0]));
+ 	dma_release_channel(chan);
+ 	if (enable_pio) {
+ 		spin_lock_irqsave(&port->lock, flags);
+ 		sci_start_rx(port);
+ 		spin_unlock_irqrestore(&port->lock, flags);
+ 	}
+ }
+ 
+ static void sci_dma_rx_complete(void *arg)
+ {
+ 	struct sci_port *s = arg;
+ 	struct dma_chan *chan = s->chan_rx;
+ 	struct uart_port *port = &s->port;
+ 	struct dma_async_tx_descriptor *desc;
+ 	unsigned long flags;
+ 	int active, count = 0;
+ 
+ 	dev_dbg(port->dev, "%s(%d) active cookie %d\n", __func__, port->line,
+ 		s->active_rx);
+ 
+ 	spin_lock_irqsave(&port->lock, flags);
+ 
+ 	active = sci_dma_rx_find_active(s);
+ 	if (active >= 0)
+ 		count = sci_dma_rx_push(s, s->rx_buf[active], s->buf_len_rx);
+ 
+ 	mod_timer(&s->rx_timer, jiffies + s->rx_timeout);
+ 
+ 	if (count)
+ 		tty_flip_buffer_push(&port->state->port);
+ 
+ 	desc = dmaengine_prep_slave_sg(s->chan_rx, &s->sg_rx[active], 1,
+ 				       DMA_DEV_TO_MEM,
+ 				       DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+ 	if (!desc)
+ 		goto fail;
+ 
+ 	desc->callback = sci_dma_rx_complete;
+ 	desc->callback_param = s;
+ 	s->cookie_rx[active] = dmaengine_submit(desc);
+ 	if (dma_submit_error(s->cookie_rx[active]))
+ 		goto fail;
+ 
+ 	s->active_rx = s->cookie_rx[!active];
+ 
+ 	dma_async_issue_pending(chan);
+ 
+ 	spin_unlock_irqrestore(&port->lock, flags);
+ 	dev_dbg(port->dev, "%s: cookie %d #%d, new active cookie %d\n",
+ 		__func__, s->cookie_rx[active], active, s->active_rx);
+ 	return;
+ 
+ fail:
+ 	spin_unlock_irqrestore(&port->lock, flags);
+ 	dev_warn(port->dev, "Failed submitting Rx DMA descriptor\n");
+ 	sci_rx_dma_release(s, true);
+ }
+ 
+ static void sci_tx_dma_release(struct sci_port *s, bool enable_pio)
+ {
+ 	struct dma_chan *chan = s->chan_tx;
+ 	struct uart_port *port = &s->port;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&port->lock, flags);
+ 	s->chan_tx = NULL;
+ 	s->cookie_tx = -EINVAL;
+ 	spin_unlock_irqrestore(&port->lock, flags);
+ 	dmaengine_terminate_all(chan);
+ 	dma_unmap_single(chan->device->dev, s->tx_dma_addr, UART_XMIT_SIZE,
+ 			 DMA_TO_DEVICE);
+ 	dma_release_channel(chan);
+ 	if (enable_pio) {
+ 		spin_lock_irqsave(&port->lock, flags);
+ 		sci_start_tx(port);
+ 		spin_unlock_irqrestore(&port->lock, flags);
+ 	}
+ }
+ 
+ static void sci_submit_rx(struct sci_port *s)
+ {
+ 	struct dma_chan *chan = s->chan_rx;
+ 	int i;
+ 
+ 	for (i = 0; i < 2; i++) {
+ 		struct scatterlist *sg = &s->sg_rx[i];
+ 		struct dma_async_tx_descriptor *desc;
+ 
+ 		desc = dmaengine_prep_slave_sg(chan,
+ 			sg, 1, DMA_DEV_TO_MEM,
+ 			DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+ 		if (!desc)
+ 			goto fail;
+ 
+ 		desc->callback = sci_dma_rx_complete;
+ 		desc->callback_param = s;
+ 		s->cookie_rx[i] = dmaengine_submit(desc);
+ 		if (dma_submit_error(s->cookie_rx[i]))
+ 			goto fail;
+ 
+ 	}
+ 
+ 	s->active_rx = s->cookie_rx[0];
+ 
+ 	dma_async_issue_pending(chan);
+ 	return;
+ 
+ fail:
+ 	if (i)
+ 		dmaengine_terminate_all(chan);
+ 	for (i = 0; i < 2; i++)
+ 		s->cookie_rx[i] = -EINVAL;
+ 	s->active_rx = -EINVAL;
+ 	sci_rx_dma_release(s, true);
+ }
+ 
+ static void work_fn_tx(struct work_struct *work)
+ {
+ 	struct sci_port *s = container_of(work, struct sci_port, work_tx);
+ 	struct dma_async_tx_descriptor *desc;
+ 	struct dma_chan *chan = s->chan_tx;
+ 	struct uart_port *port = &s->port;
+ 	struct circ_buf *xmit = &port->state->xmit;
+ 	dma_addr_t buf;
+ 
+ 	/*
+ 	 * DMA is idle now.
+ 	 * Port xmit buffer is already mapped, and it is one page... Just adjust
+ 	 * offsets and lengths. Since it is a circular buffer, we have to
+ 	 * transmit till the end, and then the rest. Take the port lock to get a
+ 	 * consistent xmit buffer state.
+ 	 */
+ 	spin_lock_irq(&port->lock);
+ 	buf = s->tx_dma_addr + (xmit->tail & (UART_XMIT_SIZE - 1));
+ 	s->tx_dma_len = min_t(unsigned int,
+ 		CIRC_CNT(xmit->head, xmit->tail, UART_XMIT_SIZE),
+ 		CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE));
+ 	spin_unlock_irq(&port->lock);
+ 
+ 	desc = dmaengine_prep_slave_single(chan, buf, s->tx_dma_len,
+ 					   DMA_MEM_TO_DEV,
+ 					   DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+ 	if (!desc) {
+ 		dev_warn(port->dev, "Failed preparing Tx DMA descriptor\n");
+ 		/* switch to PIO */
+ 		sci_tx_dma_release(s, true);
+ 		return;
+ 	}
+ 
+ 	dma_sync_single_for_device(chan->device->dev, buf, s->tx_dma_len,
+ 				   DMA_TO_DEVICE);
+ 
+ 	spin_lock_irq(&port->lock);
+ 	desc->callback = sci_dma_tx_complete;
+ 	desc->callback_param = s;
+ 	spin_unlock_irq(&port->lock);
+ 	s->cookie_tx = dmaengine_submit(desc);
+ 	if (dma_submit_error(s->cookie_tx)) {
+ 		dev_warn(port->dev, "Failed submitting Tx DMA descriptor\n");
+ 		/* switch to PIO */
+ 		sci_tx_dma_release(s, true);
+ 		return;
+ 	}
+ 
+ 	dev_dbg(port->dev, "%s: %p: %d...%d, cookie %d\n",
+ 		__func__, xmit->buf, xmit->tail, xmit->head, s->cookie_tx);
+ 
+ 	dma_async_issue_pending(chan);
+ }
+ 
+ static void rx_timer_fn(struct timer_list *t)
+ {
+ 	struct sci_port *s = from_timer(s, t, rx_timer);
+ 	struct dma_chan *chan = s->chan_rx;
+ 	struct uart_port *port = &s->port;
+ 	struct dma_tx_state state;
+ 	enum dma_status status;
+ 	unsigned long flags;
+ 	unsigned int read;
+ 	int active, count;
+ 	u16 scr;
+ 
+ 	dev_dbg(port->dev, "DMA Rx timed out\n");
+ 
+ 	spin_lock_irqsave(&port->lock, flags);
+ 
+ 	active = sci_dma_rx_find_active(s);
+ 	if (active < 0) {
+ 		spin_unlock_irqrestore(&port->lock, flags);
+ 		return;
+ 	}
+ 
+ 	status = dmaengine_tx_status(s->chan_rx, s->active_rx, &state);
+ 	if (status == DMA_COMPLETE) {
+ 		spin_unlock_irqrestore(&port->lock, flags);
+ 		dev_dbg(port->dev, "Cookie %d #%d has already completed\n",
+ 			s->active_rx, active);
+ 
+ 		/* Let packet complete handler take care of the packet */
+ 		return;
+ 	}
+ 
+ 	dmaengine_pause(chan);
+ 
+ 	/*
+ 	 * sometimes DMA transfer doesn't stop even if it is stopped and
+ 	 * data keeps on coming until transaction is complete so check
+ 	 * for DMA_COMPLETE again
+ 	 * Let packet complete handler take care of the packet
+ 	 */
+ 	status = dmaengine_tx_status(s->chan_rx, s->active_rx, &state);
+ 	if (status == DMA_COMPLETE) {
+ 		spin_unlock_irqrestore(&port->lock, flags);
+ 		dev_dbg(port->dev, "Transaction complete after DMA engine was stopped");
+ 		return;
+ 	}
+ 
+ 	/* Handle incomplete DMA receive */
+ 	dmaengine_terminate_all(s->chan_rx);
+ 	read = sg_dma_len(&s->sg_rx[active]) - state.residue;
+ 
+ 	if (read) {
+ 		count = sci_dma_rx_push(s, s->rx_buf[active], read);
+ 		if (count)
+ 			tty_flip_buffer_push(&port->state->port);
+ 	}
+ 
+ 	if (port->type == PORT_SCIFA || port->type == PORT_SCIFB)
+ 		sci_submit_rx(s);
+ 
+ 	/* Direct new serial port interrupts back to CPU */
+ 	scr = serial_port_in(port, SCSCR);
+ 	if (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {
+ 		scr &= ~SCSCR_RDRQE;
+ 		enable_irq(s->irqs[SCIx_RXI_IRQ]);
+ 	}
+ 	serial_port_out(port, SCSCR, scr | SCSCR_RIE);
+ 
+ 	spin_unlock_irqrestore(&port->lock, flags);
+ }
+ 
+ static struct dma_chan *sci_request_dma_chan(struct uart_port *port,
+ 					     enum dma_transfer_direction dir)
+ {
+ 	struct dma_chan *chan;
+ 	struct dma_slave_config cfg;
+ 	int ret;
+ 
+ 	chan = dma_request_slave_channel(port->dev,
+ 					 dir == DMA_MEM_TO_DEV ? "tx" : "rx");
+ 	if (!chan) {
+ 		dev_warn(port->dev, "dma_request_slave_channel failed\n");
+ 		return NULL;
+ 	}
+ 
+ 	memset(&cfg, 0, sizeof(cfg));
+ 	cfg.direction = dir;
+ 	if (dir == DMA_MEM_TO_DEV) {
+ 		cfg.dst_addr = port->mapbase +
+ 			(sci_getreg(port, SCxTDR)->offset << port->regshift);
+ 		cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+ 	} else {
+ 		cfg.src_addr = port->mapbase +
+ 			(sci_getreg(port, SCxRDR)->offset << port->regshift);
+ 		cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+ 	}
+ 
+ 	ret = dmaengine_slave_config(chan, &cfg);
+ 	if (ret) {
+ 		dev_warn(port->dev, "dmaengine_slave_config failed %d\n", ret);
+ 		dma_release_channel(chan);
+ 		return NULL;
+ 	}
+ 
+ 	return chan;
+ }
+ 
+ static void sci_request_dma(struct uart_port *port)
+ {
+ 	struct sci_port *s = to_sci_port(port);
+ 	struct dma_chan *chan;
+ 
+ 	dev_dbg(port->dev, "%s: port %d\n", __func__, port->line);
+ 
+ 	if (!port->dev->of_node)
+ 		return;
+ 
+ 	s->cookie_tx = -EINVAL;
+ 
+ 	/*
+ 	 * Don't request a dma channel if no channel was specified
+ 	 * in the device tree.
+ 	 */
+ 	if (!of_find_property(port->dev->of_node, "dmas", NULL))
+ 		return;
+ 
+ 	chan = sci_request_dma_chan(port, DMA_MEM_TO_DEV);
+ 	dev_dbg(port->dev, "%s: TX: got channel %p\n", __func__, chan);
+ 	if (chan) {
+ 		s->chan_tx = chan;
+ 		/* UART circular tx buffer is an aligned page. */
+ 		s->tx_dma_addr = dma_map_single(chan->device->dev,
+ 						port->state->xmit.buf,
+ 						UART_XMIT_SIZE,
+ 						DMA_TO_DEVICE);
+ 		if (dma_mapping_error(chan->device->dev, s->tx_dma_addr)) {
+ 			dev_warn(port->dev, "Failed mapping Tx DMA descriptor\n");
+ 			dma_release_channel(chan);
+ 			s->chan_tx = NULL;
+ 		} else {
+ 			dev_dbg(port->dev, "%s: mapped %lu@%p to %pad\n",
+ 				__func__, UART_XMIT_SIZE,
+ 				port->state->xmit.buf, &s->tx_dma_addr);
+ 		}
+ 
+ 		INIT_WORK(&s->work_tx, work_fn_tx);
+ 	}
+ 
+ 	chan = sci_request_dma_chan(port, DMA_DEV_TO_MEM);
+ 	dev_dbg(port->dev, "%s: RX: got channel %p\n", __func__, chan);
+ 	if (chan) {
+ 		unsigned int i;
+ 		dma_addr_t dma;
+ 		void *buf;
+ 
+ 		s->chan_rx = chan;
+ 
+ 		s->buf_len_rx = 2 * max_t(size_t, 16, port->fifosize);
+ 		buf = dma_alloc_coherent(chan->device->dev, s->buf_len_rx * 2,
+ 					 &dma, GFP_KERNEL);
+ 		if (!buf) {
+ 			dev_warn(port->dev,
+ 				 "Failed to allocate Rx dma buffer, using PIO\n");
+ 			dma_release_channel(chan);
+ 			s->chan_rx = NULL;
+ 			return;
+ 		}
+ 
+ 		for (i = 0; i < 2; i++) {
+ 			struct scatterlist *sg = &s->sg_rx[i];
+ 
+ 			sg_init_table(sg, 1);
+ 			s->rx_buf[i] = buf;
+ 			sg_dma_address(sg) = dma;
+ 			sg_dma_len(sg) = s->buf_len_rx;
+ 
+ 			buf += s->buf_len_rx;
+ 			dma += s->buf_len_rx;
+ 		}
+ 
+ 		timer_setup(&s->rx_timer, rx_timer_fn, 0);
+ 
+ 		if (port->type == PORT_SCIFA || port->type == PORT_SCIFB)
+ 			sci_submit_rx(s);
+ 	}
+ }
+ 
+ static void sci_free_dma(struct uart_port *port)
+ {
+ 	struct sci_port *s = to_sci_port(port);
+ 
+ 	if (s->chan_tx)
+ 		sci_tx_dma_release(s, false);
+ 	if (s->chan_rx)
+ 		sci_rx_dma_release(s, false);
+ }
+ 
+ static void sci_flush_buffer(struct uart_port *port)
+ {
+ 	/*
+ 	 * In uart_flush_buffer(), the xmit circular buffer has just been
+ 	 * cleared, so we have to reset tx_dma_len accordingly.
+ 	 */
+ 	to_sci_port(port)->tx_dma_len = 0;
+ }
+ #else /* !CONFIG_SERIAL_SH_SCI_DMA */
+ static inline void sci_request_dma(struct uart_port *port)
+ {
+ }
+ 
+ static inline void sci_free_dma(struct uart_port *port)
+ {
+ }
+ 
+ #define sci_flush_buffer	NULL
+ #endif /* !CONFIG_SERIAL_SH_SCI_DMA */
+ 
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  static irqreturn_t sci_rx_interrupt(int irq, void *ptr)
  {
 +#ifdef CONFIG_SERIAL_SH_SCI_DMA
  	struct uart_port *port = ptr;
  	struct sci_port *s = to_sci_port(port);
  
@@@ -1812,6 -2224,28 +2433,31 @@@ static void sci_reset(struct uart_port 
  	reg = sci_getreg(port, SCFCR);
  	if (reg->size)
  		serial_port_out(port, SCFCR, SCFCR_RFRST | SCFCR_TFRST);
++<<<<<<< HEAD
++=======
+ 
+ 	sci_clear_SCxSR(port,
+ 			SCxSR_RDxF_CLEAR(port) & SCxSR_ERROR_CLEAR(port) &
+ 			SCxSR_BREAK_CLEAR(port));
+ 	if (sci_getreg(port, SCLSR)->size) {
+ 		status = serial_port_in(port, SCLSR);
+ 		status &= ~(SCLSR_TO | SCLSR_ORER);
+ 		serial_port_out(port, SCLSR, status);
+ 	}
+ 
+ 	if (s->rx_trigger > 1) {
+ 		if (s->rx_fifo_timeout) {
+ 			scif_set_rtrg(port, 1);
+ 			timer_setup(&s->rx_fifo_timer, rx_fifo_timer_fn, 0);
+ 		} else {
+ 			if (port->type == PORT_SCIFA ||
+ 			    port->type == PORT_SCIFB)
+ 				scif_set_rtrg(port, 1);
+ 			else
+ 				scif_set_rtrg(port, s->rx_trigger);
+ 		}
+ 	}
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  }
  
  static void sci_set_termios(struct uart_port *port, struct ktermios *termios,
diff --cc drivers/tty/serial/sn_console.c
index f51ffdc696fd,42b9aded4eb1..000000000000
--- a/drivers/tty/serial/sn_console.c
+++ b/drivers/tty/serial/sn_console.c
@@@ -697,9 -668,7 +697,13 @@@ static void __init sn_sal_switch_to_asy
  	 * timer to poll for input and push data from the console
  	 * buffer.
  	 */
++<<<<<<< HEAD
 +	init_timer(&port->sc_timer);
 +	port->sc_timer.function = sn_sal_timer_poll;
 +	port->sc_timer.data = (unsigned long)port;
++=======
+ 	timer_setup(&port->sc_timer, sn_sal_timer_poll, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	if (IS_RUNNING_ON_SIMULATOR())
  		port->sc_interrupt_timeout = 6;
diff --cc drivers/usb/core/hcd.c
index 0531a2c8019c,fc32391a34d5..000000000000
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@@ -2544,9 -2547,7 +2546,13 @@@ struct usb_hcd *__usb_create_hcd(const 
  	hcd->self.bus_name = bus_name;
  	hcd->self.uses_dma = (sysdev->dma_mask != NULL);
  
++<<<<<<< HEAD
 +	init_timer(&hcd->rh_timer);
 +	hcd->rh_timer.function = rh_timer_func;
 +	hcd->rh_timer.data = (unsigned long) hcd;
++=======
+ 	timer_setup(&hcd->rh_timer, rh_timer_func, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  #ifdef CONFIG_PM
  	INIT_WORK(&hcd->wakeup_work, hcd_resume_work);
  #endif
diff --cc drivers/usb/gadget/dummy_hcd.c
index ac0e79e2c2e9,d0128f92ec5a..000000000000
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@@ -2316,9 -2445,7 +2316,13 @@@ static DEVICE_ATTR(urbs, S_IRUGO, show_
  
  static int dummy_start_ss(struct dummy_hcd *dum_hcd)
  {
++<<<<<<< HEAD:drivers/usb/gadget/dummy_hcd.c
 +	init_timer(&dum_hcd->timer);
 +	dum_hcd->timer.function = dummy_timer;
 +	dum_hcd->timer.data = (unsigned long)dum_hcd;
++=======
+ 	timer_setup(&dum_hcd->timer, dummy_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup()):drivers/usb/gadget/udc/dummy_hcd.c
  	dum_hcd->rh_state = DUMMY_RH_RUNNING;
  	dum_hcd->stream_en_ep = 0;
  	INIT_LIST_HEAD(&dum_hcd->urbp_list);
@@@ -2347,9 -2474,7 +2351,13 @@@ static int dummy_start(struct usb_hcd *
  		return dummy_start_ss(dum_hcd);
  
  	spin_lock_init(&dum_hcd->dum->lock);
++<<<<<<< HEAD:drivers/usb/gadget/dummy_hcd.c
 +	init_timer(&dum_hcd->timer);
 +	dum_hcd->timer.function = dummy_timer;
 +	dum_hcd->timer.data = (unsigned long)dum_hcd;
++=======
+ 	timer_setup(&dum_hcd->timer, dummy_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup()):drivers/usb/gadget/udc/dummy_hcd.c
  	dum_hcd->rh_state = DUMMY_RH_RUNNING;
  
  	INIT_LIST_HEAD(&dum_hcd->urbp_list);
diff --cc drivers/usb/gadget/m66592-udc.c
index 51cfe72da5bb,a8288df6aadf..000000000000
--- a/drivers/usb/gadget/m66592-udc.c
+++ b/drivers/usb/gadget/m66592-udc.c
@@@ -1608,9 -1589,7 +1608,13 @@@ static int __init m66592_probe(struct p
  	m66592->gadget.max_speed = USB_SPEED_HIGH;
  	m66592->gadget.name = udc_name;
  
++<<<<<<< HEAD:drivers/usb/gadget/m66592-udc.c
 +	init_timer(&m66592->timer);
 +	m66592->timer.function = m66592_timer;
 +	m66592->timer.data = (unsigned long)m66592;
++=======
+ 	timer_setup(&m66592->timer, m66592_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup()):drivers/usb/gadget/udc/m66592-udc.c
  	m66592->reg = reg;
  
  	ret = request_irq(ires->start, m66592_irq, IRQF_SHARED,
diff --cc drivers/usb/gadget/omap_udc.c
index 91614d068573,dc35a54bad90..000000000000
--- a/drivers/usb/gadget/omap_udc.c
+++ b/drivers/usb/gadget/omap_udc.c
@@@ -2550,9 -2542,7 +2550,13 @@@ omap_ep_setup(char *name, u8 addr, u8 t
  		}
  		if (dbuf && addr)
  			epn_rxtx |= UDC_EPN_RX_DB;
++<<<<<<< HEAD:drivers/usb/gadget/omap_udc.c
 +		init_timer(&ep->timer);
 +		ep->timer.function = pio_out_timer;
 +		ep->timer.data = (unsigned long) ep;
++=======
+ 		timer_setup(&ep->timer, pio_out_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup()):drivers/usb/gadget/udc/omap_udc.c
  	}
  	if (addr)
  		epn_rxtx |= UDC_EPN_RX_VALID;
diff --cc drivers/usb/gadget/pxa25x_udc.c
index ca47c169c716,0e3f5faa000e..000000000000
--- a/drivers/usb/gadget/pxa25x_udc.c
+++ b/drivers/usb/gadget/pxa25x_udc.c
@@@ -2131,9 -2413,7 +2131,13 @@@ static int __init pxa25x_udc_probe(stru
  		gpio_direction_output(dev->mach->gpio_pullup, 0);
  	}
  
++<<<<<<< HEAD:drivers/usb/gadget/pxa25x_udc.c
 +	init_timer(&dev->timer);
 +	dev->timer.function = udc_watchdog;
 +	dev->timer.data = (unsigned long) dev;
++=======
+ 	timer_setup(&dev->timer, udc_watchdog, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup()):drivers/usb/gadget/udc/pxa25x_udc.c
  
  	the_controller = dev;
  	platform_set_drvdata(pdev, dev);
diff --cc drivers/usb/gadget/r8a66597-udc.c
index 7ff7d9cf2061,a3ecce62662b..000000000000
--- a/drivers/usb/gadget/r8a66597-udc.c
+++ b/drivers/usb/gadget/r8a66597-udc.c
@@@ -1917,9 -1874,7 +1917,13 @@@ static int __init r8a66597_probe(struc
  	r8a66597->gadget.max_speed = USB_SPEED_HIGH;
  	r8a66597->gadget.name = udc_name;
  
++<<<<<<< HEAD:drivers/usb/gadget/r8a66597-udc.c
 +	init_timer(&r8a66597->timer);
 +	r8a66597->timer.function = r8a66597_timer;
 +	r8a66597->timer.data = (unsigned long)r8a66597;
++=======
+ 	timer_setup(&r8a66597->timer, r8a66597_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup()):drivers/usb/gadget/udc/r8a66597-udc.c
  	r8a66597->reg = reg;
  
  	if (r8a66597->pdata->on_chip) {
diff --cc drivers/usb/host/ohci-hcd.c
index 5d54c4ac571a,ee9676349333..000000000000
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@@ -499,9 -500,7 +499,13 @@@ static int ohci_init (struct ohci_hcd *
  	if (ohci->hcca)
  		return 0;
  
++<<<<<<< HEAD
 +	setup_timer(&ohci->io_watchdog, io_watchdog_func,
 +			(unsigned long) ohci);
 +	set_timer_slack(&ohci->io_watchdog, msecs_to_jiffies(20));
++=======
+ 	timer_setup(&ohci->io_watchdog, io_watchdog_func, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	ohci->hcca = dma_alloc_coherent (hcd->self.controller,
  			sizeof(*ohci->hcca), &ohci->hcca_dma, GFP_KERNEL);
diff --cc drivers/usb/host/oxu210hp-hcd.c
index 6b8572d8eacf,c5e6e8d0b5ef..000000000000
--- a/drivers/usb/host/oxu210hp-hcd.c
+++ b/drivers/usb/host/oxu210hp-hcd.c
@@@ -2598,9 -2577,7 +2598,13 @@@ static int oxu_hcd_init(struct usb_hcd 
  
  	spin_lock_init(&oxu->lock);
  
++<<<<<<< HEAD
 +	init_timer(&oxu->watchdog);
 +	oxu->watchdog.function = oxu_watchdog;
 +	oxu->watchdog.data = (unsigned long) oxu;
++=======
+ 	timer_setup(&oxu->watchdog, oxu_watchdog, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	/*
  	 * hw default: 1K periodic list heads, one per frame.
diff --cc drivers/usb/host/r8a66597-hcd.c
index 1d6ee3e54ca8,984892dd72f5..000000000000
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@@ -2483,9 -2472,7 +2483,13 @@@ static int r8a66597_probe(struct platfo
  		r8a66597->max_root_hub = 2;
  
  	spin_lock_init(&r8a66597->lock);
++<<<<<<< HEAD
 +	init_timer(&r8a66597->rh_timer);
 +	r8a66597->rh_timer.function = r8a66597_timer;
 +	r8a66597->rh_timer.data = (unsigned long)r8a66597;
++=======
+ 	timer_setup(&r8a66597->rh_timer, r8a66597_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	r8a66597->reg = reg;
  
  	/* make sure no interrupts are pending */
diff --cc drivers/usb/host/sl811-hcd.c
index 2ba4522454cf,fa88a903fa2e..000000000000
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@@ -1690,10 -1691,8 +1690,15 @@@ sl811h_probe(struct platform_device *de
  
  	spin_lock_init(&sl811->lock);
  	INIT_LIST_HEAD(&sl811->async);
++<<<<<<< HEAD
 +	sl811->board = dev->dev.platform_data;
 +	init_timer(&sl811->timer);
 +	sl811->timer.function = sl811h_timer;
 +	sl811->timer.data = (unsigned long) sl811;
++=======
+ 	sl811->board = dev_get_platdata(&dev->dev);
+ 	timer_setup(&sl811->timer, sl811h_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	sl811->addr_reg = addr_reg;
  	sl811->data_reg = data_reg;
  
diff --cc drivers/uwb/drp.c
index 3fbcf789dfaa,625f706b8160..000000000000
--- a/drivers/uwb/drp.c
+++ b/drivers/uwb/drp.c
@@@ -599,12 -636,13 +599,16 @@@ static void uwb_drp_handle_alien_drp(st
  
  	/* alloc and initialize new uwb_cnflt_alien */
  	cnflt = kzalloc(sizeof(struct uwb_cnflt_alien), GFP_KERNEL);
 -	if (!cnflt) {
 +	if (!cnflt)
  		dev_err(dev, "failed to alloc uwb_cnflt_alien struct\n");
 -		return;
 -	}
 -
  	INIT_LIST_HEAD(&cnflt->rc_node);
++<<<<<<< HEAD
 +	init_timer(&cnflt->timer);
 +	cnflt->timer.function = uwb_cnflt_timer;
 +	cnflt->timer.data     = (unsigned long)cnflt;
++=======
+ 	timer_setup(&cnflt->timer, uwb_cnflt_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	cnflt->rc = rc;
  	INIT_WORK(&cnflt->cnflt_update_work, uwb_cnflt_update_work);
diff --cc drivers/uwb/neh.c
index 8cb71bb333c2,fbdca728bd9f..000000000000
--- a/drivers/uwb/neh.c
+++ b/drivers/uwb/neh.c
@@@ -223,9 -223,7 +223,13 @@@ struct uwb_rc_neh *uwb_rc_neh_add(struc
  
  	kref_init(&neh->kref);
  	INIT_LIST_HEAD(&neh->list_node);
++<<<<<<< HEAD
 +	init_timer(&neh->timer);
 +	neh->timer.function = uwb_rc_neh_timer;
 +	neh->timer.data     = (unsigned long)neh;
++=======
+ 	timer_setup(&neh->timer, uwb_rc_neh_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	neh->rc = rc;
  	neh->evt_type = expected_type;
diff --cc drivers/uwb/rsv.c
index f4ae05f78c42,fe25a8cc6fa1..000000000000
--- a/drivers/uwb/rsv.c
+++ b/drivers/uwb/rsv.c
@@@ -463,9 -470,7 +463,13 @@@ static struct uwb_rsv *uwb_rsv_alloc(st
  	INIT_LIST_HEAD(&rsv->rc_node);
  	INIT_LIST_HEAD(&rsv->pal_node);
  	kref_init(&rsv->kref);
++<<<<<<< HEAD
 +	init_timer(&rsv->timer);
 +	rsv->timer.function = uwb_rsv_timer;
 +	rsv->timer.data     = (unsigned long)rsv;
++=======
+ 	timer_setup(&rsv->timer, uwb_rsv_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	rsv->rc = rc;
  	INIT_WORK(&rsv->handle_timeout_work, uwb_rsv_handle_timeout_work);
@@@ -974,9 -987,7 +978,13 @@@ void uwb_rsv_init(struct uwb_rc *rc
  	rc->bow.can_reserve_extra_mases = true;
  	rc->bow.total_expired = 0;
  	rc->bow.window = UWB_DRP_BACKOFF_WIN_MIN >> 1;
++<<<<<<< HEAD
 +	init_timer(&rc->bow.timer);
 +	rc->bow.timer.function = uwb_rsv_backoff_win_timer;
 +	rc->bow.timer.data     = (unsigned long)&rc->bow;
++=======
+ 	timer_setup(&rc->bow.timer, uwb_rsv_backoff_win_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	bitmap_complement(rc->uwb_dev.streams, rc->uwb_dev.streams, UWB_NUM_STREAMS);
  }
diff --cc drivers/video/omap2/dss/dsi.c
index a73dedc33101,c2cf6d98e577..000000000000
--- a/drivers/video/omap2/dss/dsi.c
+++ b/drivers/video/omap2/dss/dsi.c
@@@ -5498,22 -5449,23 +5498,26 @@@ static int omap_dsihw_probe(struct plat
  			     dsi_framedone_timeout_work_callback);
  
  #ifdef DSI_CATCH_MISSING_TE
++<<<<<<< HEAD:drivers/video/omap2/dss/dsi.c
 +	init_timer(&dsi->te_timer);
 +	dsi->te_timer.function = dsi_te_timeout;
 +	dsi->te_timer.data = 0;
++=======
+ 	timer_setup(&dsi->te_timer, dsi_te_timeout, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup()):drivers/gpu/drm/omapdrm/dss/dsi.c
  #endif
 +	dsi_mem = platform_get_resource(dsi->pdev, IORESOURCE_MEM, 0);
 +	if (!dsi_mem) {
 +		DSSERR("can't get IORESOURCE_MEM DSI\n");
 +		return -EINVAL;
 +	}
  
 -	dsi_mem = platform_get_resource_byname(dsidev, IORESOURCE_MEM, "proto");
 -	dsi->proto_base = devm_ioremap_resource(&dsidev->dev, dsi_mem);
 -	if (IS_ERR(dsi->proto_base))
 -		return PTR_ERR(dsi->proto_base);
 -
 -	res = platform_get_resource_byname(dsidev, IORESOURCE_MEM, "phy");
 -	dsi->phy_base = devm_ioremap_resource(&dsidev->dev, res);
 -	if (IS_ERR(dsi->phy_base))
 -		return PTR_ERR(dsi->phy_base);
 -
 -	res = platform_get_resource_byname(dsidev, IORESOURCE_MEM, "pll");
 -	dsi->pll_base = devm_ioremap_resource(&dsidev->dev, res);
 -	if (IS_ERR(dsi->pll_base))
 -		return PTR_ERR(dsi->pll_base);
 +	dsi->base = devm_ioremap(&dsidev->dev, dsi_mem->start,
 +				 resource_size(dsi_mem));
 +	if (!dsi->base) {
 +		DSSERR("can't ioremap DSI\n");
 +		return -ENOMEM;
 +	}
  
  	dsi->irq = platform_get_irq(dsi->pdev, 0);
  	if (dsi->irq < 0) {
diff --cc drivers/watchdog/at91sam9_wdt.c
index be37dde4f864,88c05d0448b2..000000000000
--- a/drivers/watchdog/at91sam9_wdt.c
+++ b/drivers/watchdog/at91sam9_wdt.c
@@@ -88,28 -120,23 +88,37 @@@ static inline void at91_wdt_reset(void
  /*
   * Timer tick
   */
- static void at91_ping(unsigned long data)
+ static void at91_ping(struct timer_list *t)
  {
++<<<<<<< HEAD
 +	if (time_before(jiffies, at91wdt_private.next_heartbeat) ||
 +	    (!watchdog_active(&at91_wdt_dev))) {
 +		at91_wdt_reset();
 +		mod_timer(&at91wdt_private.timer, jiffies + WDT_TIMEOUT);
 +	} else
++=======
+ 	struct at91wdt *wdt = from_timer(wdt, t, timer);
+ 	if (time_before(jiffies, wdt->next_heartbeat) ||
+ 	    !watchdog_active(&wdt->wdd)) {
+ 		at91_wdt_reset(wdt);
+ 		mod_timer(&wdt->timer, jiffies + wdt->heartbeat);
+ 	} else {
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  		pr_crit("I will reset your machine !\n");
 -	}
  }
  
 -static int at91_wdt_start(struct watchdog_device *wdd)
 +static int at91_wdt_ping(struct watchdog_device *wdd)
  {
 -	struct at91wdt *wdt = to_wdt(wdd);
  	/* calculate when the next userspace timeout will be */
 -	wdt->next_heartbeat = jiffies + wdd->timeout * HZ;
 +	at91wdt_private.next_heartbeat = jiffies + wdd->timeout * HZ;
 +	return 0;
 +}
 +
 +static int at91_wdt_start(struct watchdog_device *wdd)
 +{
 +	/* calculate the next userspace timeout and modify the timer */
 +	at91_wdt_ping(wdd);
 +	mod_timer(&at91wdt_private.timer, jiffies + WDT_TIMEOUT);
  	return 0;
  }
  
@@@ -142,19 -192,62 +151,67 @@@ static int at91_wdt_settimeout(unsigne
  	}
  
  	/*
 -	 * Try to reset the watchdog counter 4 or 2 times more often than
 -	 * actually requested, to avoid spurious watchdog reset.
 -	 * If this is not possible because of the min_heartbeat value, reset
 -	 * it at the min_heartbeat period.
 +	 * All counting occurs at SLOW_CLOCK / 128 = 256 Hz
 +	 *
 +	 * Since WDV is a 12-bit counter, the maximum period is
 +	 * 4096 / 256 = 16 seconds.
  	 */
++<<<<<<< HEAD
 +	reg = AT91_WDT_WDRSTEN	/* causes watchdog reset */
 +		/* | AT91_WDT_WDRPROC	causes processor reset only */
 +		| AT91_WDT_WDDBGHLT	/* disabled in debug mode */
 +		| AT91_WDT_WDD		/* restart at any time */
 +		| (timeout & AT91_WDT_WDV);  /* timer value */
 +	wdt_write(AT91_WDT_MR, reg);
++=======
+ 	if ((max_heartbeat / 4) >= min_heartbeat)
+ 		wdt->heartbeat = max_heartbeat / 4;
+ 	else if ((max_heartbeat / 2) >= min_heartbeat)
+ 		wdt->heartbeat = max_heartbeat / 2;
+ 	else
+ 		wdt->heartbeat = min_heartbeat;
+ 
+ 	if (max_heartbeat < min_heartbeat + 4)
+ 		dev_warn(dev,
+ 			 "min heartbeat and max heartbeat might be too close for the system to handle it correctly\n");
+ 
+ 	if ((tmp & AT91_WDT_WDFIEN) && wdt->irq) {
+ 		err = request_irq(wdt->irq, wdt_interrupt,
+ 				  IRQF_SHARED | IRQF_IRQPOLL |
+ 				  IRQF_NO_SUSPEND,
+ 				  pdev->name, wdt);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if ((tmp & wdt->mr_mask) != (wdt->mr & wdt->mr_mask))
+ 		dev_warn(dev,
+ 			 "watchdog already configured differently (mr = %x expecting %x)\n",
+ 			 tmp & wdt->mr_mask, wdt->mr & wdt->mr_mask);
+ 
+ 	timer_setup(&wdt->timer, at91_ping, 0);
+ 
+ 	/*
+ 	 * Use min_heartbeat the first time to avoid spurious watchdog reset:
+ 	 * we don't know for how long the watchdog counter is running, and
+ 	 *  - resetting it right now might trigger a watchdog fault reset
+ 	 *  - waiting for heartbeat time might lead to a watchdog timeout
+ 	 *    reset
+ 	 */
+ 	mod_timer(&wdt->timer, jiffies + min_heartbeat);
+ 
+ 	/* Try to set timeout from device tree first */
+ 	if (watchdog_init_timeout(&wdt->wdd, 0, dev))
+ 		watchdog_init_timeout(&wdt->wdd, heartbeat, dev);
+ 	watchdog_set_nowayout(&wdt->wdd, wdt->nowayout);
+ 	err = watchdog_register_device(&wdt->wdd);
+ 	if (err)
+ 		goto out_stop_timer;
+ 
+ 	wdt->next_heartbeat = jiffies + wdt->wdd.timeout * HZ;
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	return 0;
 -
 -out_stop_timer:
 -	del_timer(&wdt->timer);
 -	return err;
  }
  
  /* ......................................................................... */
diff --cc drivers/watchdog/mpc8xxx_wdt.c
index da2752063bb7,6610e9217dbc..000000000000
--- a/drivers/watchdog/mpc8xxx_wdt.c
+++ b/drivers/watchdog/mpc8xxx_wdt.c
@@@ -67,62 -71,32 +67,70 @@@ module_param(nowayout, bool, 0)
  MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started "
  		 "(default=" __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
  
 -static void mpc8xxx_wdt_keepalive(struct mpc8xxx_wdt_ddata *ddata)
 +/*
 + * We always prescale, but if someone really doesn't want to they can set this
 + * to 0
 + */
 +static int prescale = 1;
 +static unsigned int timeout_sec;
 +
 +static unsigned long wdt_is_open;
 +static DEFINE_SPINLOCK(wdt_spinlock);
 +
 +static void mpc8xxx_wdt_keepalive(void)
  {
  	/* Ping the WDT */
 -	spin_lock(&ddata->lock);
 -	out_be16(&ddata->base->swsrr, 0x556c);
 -	out_be16(&ddata->base->swsrr, 0xaa39);
 -	spin_unlock(&ddata->lock);
 +	spin_lock(&wdt_spinlock);
 +	out_be16(&wd_base->swsrr, 0x556c);
 +	out_be16(&wd_base->swsrr, 0xaa39);
 +	spin_unlock(&wdt_spinlock);
  }
  
++<<<<<<< HEAD
 +static void mpc8xxx_wdt_timer_ping(unsigned long arg);
 +static DEFINE_TIMER(wdt_timer, mpc8xxx_wdt_timer_ping, 0, 0);
 +
 +static void mpc8xxx_wdt_timer_ping(unsigned long arg)
 +{
 +	mpc8xxx_wdt_keepalive();
++=======
+ static void mpc8xxx_wdt_timer_ping(struct timer_list *t)
+ {
+ 	struct mpc8xxx_wdt_ddata *ddata = from_timer(ddata, t, timer);
+ 
+ 	mpc8xxx_wdt_keepalive(ddata);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	/* We're pinging it twice faster than needed, just to be sure. */
 -	mod_timer(&ddata->timer, jiffies + HZ * ddata->wdd.timeout / 2);
 +	mod_timer(&wdt_timer, jiffies + HZ * timeout_sec / 2);
 +}
 +
 +static void mpc8xxx_wdt_pr_warn(const char *msg)
 +{
 +	pr_crit("%s, expect the %s soon!\n", msg,
 +		reset ? "reset" : "machine check exception");
  }
  
 -static int mpc8xxx_wdt_start(struct watchdog_device *w)
 +static ssize_t mpc8xxx_wdt_write(struct file *file, const char __user *buf,
 +				 size_t count, loff_t *ppos)
  {
 -	struct mpc8xxx_wdt_ddata *ddata =
 -		container_of(w, struct mpc8xxx_wdt_ddata, wdd);
 +	if (count)
 +		mpc8xxx_wdt_keepalive();
 +	return count;
 +}
 +
 +static int mpc8xxx_wdt_open(struct inode *inode, struct file *file)
 +{
 +	u32 tmp = SWCRR_SWEN;
 +	if (test_and_set_bit(0, &wdt_is_open))
 +		return -EBUSY;
  
 -	u32 tmp = SWCRR_SWEN | SWCRR_SWPR;
 +	/* Once we start the watchdog we can't stop it */
 +	if (nowayout)
 +		__module_get(THIS_MODULE);
  
  	/* Good, fire up the show */
 +	if (prescale)
 +		tmp |= SWCRR_SWPR;
  	if (reset)
  		tmp |= SWCRR_SWRI;
  
@@@ -205,28 -157,39 +213,37 @@@ static int mpc8xxx_wdt_probe(struct pla
  	if (!freq || freq == -1)
  		return -EINVAL;
  
 -	ddata = devm_kzalloc(&ofdev->dev, sizeof(*ddata), GFP_KERNEL);
 -	if (!ddata)
 +	wd_base = of_iomap(np, 0);
 +	if (!wd_base)
  		return -ENOMEM;
  
 -	res = platform_get_resource(ofdev, IORESOURCE_MEM, 0);
 -	ddata->base = devm_ioremap_resource(&ofdev->dev, res);
 -	if (IS_ERR(ddata->base))
 -		return PTR_ERR(ddata->base);
 -
 -	enabled = in_be32(&ddata->base->swcrr) & SWCRR_SWEN;
 +	enabled = in_be32(&wd_base->swcrr) & SWCRR_SWEN;
  	if (!enabled && wdt_type->hw_enabled) {
  		pr_info("could not be enabled in software\n");
 -		return -ENODEV;
 +		ret = -ENOSYS;
 +		goto err_unmap;
  	}
  
++<<<<<<< HEAD
++=======
+ 	spin_lock_init(&ddata->lock);
+ 	timer_setup(&ddata->timer, mpc8xxx_wdt_timer_ping, 0);
+ 
+ 	ddata->wdd.info = &mpc8xxx_wdt_info,
+ 	ddata->wdd.ops = &mpc8xxx_wdt_ops,
+ 
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	/* Calculate the timeout in seconds */
 -	timeout_sec = (timeout * wdt_type->prescaler) / freq;
 +	if (prescale)
 +		timeout_sec = (timeout * wdt_type->prescaler) / freq;
 +	else
 +		timeout_sec = timeout / freq;
  
 -	ddata->wdd.timeout = timeout_sec;
 -
 -	watchdog_set_nowayout(&ddata->wdd, nowayout);
 -
 -	ret = watchdog_register_device(&ddata->wdd);
 -	if (ret) {
 -		pr_err("cannot register watchdog device (err=%d)\n", ret);
 -		return ret;
 -	}
 +#ifdef MODULE
 +	ret = mpc8xxx_wdt_init_late();
 +	if (ret)
 +		goto err_unmap;
 +#endif
  
  	pr_info("WDT driver for MPC8xxx initialized. mode:%s timeout=%d (%d seconds)\n",
  		reset ? "reset" : "interrupt", timeout, timeout_sec);
diff --cc drivers/watchdog/shwdt.c
index 5fc05c238a4e,a7d6425db807..000000000000
--- a/drivers/watchdog/shwdt.c
+++ b/drivers/watchdog/shwdt.c
@@@ -278,16 -272,12 +278,20 @@@ static int sh_wdt_probe(struct platform
  	rc = watchdog_register_device(&sh_wdt_dev);
  	if (unlikely(rc)) {
  		dev_err(&pdev->dev, "Can't register watchdog (err=%d)\n", rc);
 -		return rc;
 +		goto err;
  	}
  
++<<<<<<< HEAD
 +	init_timer(&wdt->timer);
 +	wdt->timer.function	= sh_wdt_ping;
 +	wdt->timer.data		= (unsigned long)wdt;
++=======
+ 	timer_setup(&wdt->timer, sh_wdt_ping, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	wdt->timer.expires	= next_ping_period(clock_division_ratio);
  
 +	platform_set_drvdata(pdev, wdt);
 +
  	dev_info(&pdev->dev, "initialized.\n");
  
  	pm_runtime_enable(&pdev->dev);
diff --cc fs/ocfs2/cluster/tcp.c
index 976ea9ad380a,bebe59feca58..000000000000
--- a/fs/ocfs2/cluster/tcp.c
+++ b/fs/ocfs2/cluster/tcp.c
@@@ -137,9 -138,9 +137,9 @@@ static int o2net_sys_err_translations[O
  static void o2net_sc_connect_completed(struct work_struct *work);
  static void o2net_rx_until_empty(struct work_struct *work);
  static void o2net_shutdown_sc(struct work_struct *work);
 -static void o2net_listen_data_ready(struct sock *sk);
 +static void o2net_listen_data_ready(struct sock *sk, int bytes);
  static void o2net_sc_send_keep_req(struct work_struct *work);
- static void o2net_idle_timer(unsigned long data);
+ static void o2net_idle_timer(struct timer_list *t);
  static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);
  static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);
  
@@@ -446,9 -450,7 +446,13 @@@ static struct o2net_sock_container *sc_
  	INIT_WORK(&sc->sc_shutdown_work, o2net_shutdown_sc);
  	INIT_DELAYED_WORK(&sc->sc_keepalive_work, o2net_sc_send_keep_req);
  
++<<<<<<< HEAD
 +	init_timer(&sc->sc_idle_timeout);
 +	sc->sc_idle_timeout.function = o2net_idle_timer;
 +	sc->sc_idle_timeout.data = (unsigned long)sc;
++=======
+ 	timer_setup(&sc->sc_idle_timeout, o2net_idle_timer, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  	sclog(sc, "alloced\n");
  
diff --cc kernel/padata.c
index 072f4ee4eb89,57c0074d50cc..000000000000
--- a/kernel/padata.c
+++ b/kernel/padata.c
@@@ -283,11 -276,51 +283,31 @@@ static void padata_reorder(struct paral
  	return;
  }
  
++<<<<<<< HEAD
 +static void padata_reorder_timer(unsigned long arg)
 +{
 +	struct parallel_data *pd = (struct parallel_data *)arg;
++=======
+ static void invoke_padata_reorder(struct work_struct *work)
+ {
+ 	struct padata_parallel_queue *pqueue;
+ 	struct parallel_data *pd;
+ 
+ 	local_bh_disable();
+ 	pqueue = container_of(work, struct padata_parallel_queue, reorder_work);
+ 	pd = pqueue->pd;
+ 	padata_reorder(pd);
+ 	local_bh_enable();
+ }
+ 
+ static void padata_reorder_timer(struct timer_list *t)
+ {
+ 	struct parallel_data *pd = from_timer(pd, t, timer);
+ 	unsigned int weight;
+ 	int target_cpu, cpu;
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
 -	cpu = get_cpu();
 -
 -	/* We don't lock pd here to not interfere with parallel processing
 -	 * padata_reorder() calls on other CPUs. We just need any CPU out of
 -	 * the cpumask.pcpu set. It would be nice if it's the right one but
 -	 * it doesn't matter if we're off to the next one by using an outdated
 -	 * pd->processed value.
 -	 */
 -	weight = cpumask_weight(pd->cpumask.pcpu);
 -	target_cpu = padata_index_to_cpu(pd, pd->processed % weight);
 -
 -	/* ensure to call the reorder callback on the correct CPU */
 -	if (cpu != target_cpu) {
 -		struct padata_parallel_queue *pqueue;
 -		struct padata_instance *pinst;
 -
 -		/* The timer function is serialized wrt itself -- no locking
 -		 * needed.
 -		 */
 -		pinst = pd->pinst;
 -		pqueue = per_cpu_ptr(pd->pqueue, target_cpu);
 -		queue_work_on(target_cpu, pinst->wq, &pqueue->reorder_work);
 -	} else {
 -		padata_reorder(pd);
 -	}
 -
 -	put_cpu();
 +	padata_reorder(pd);
  }
  
  static void padata_serial_worker(struct work_struct *serial_work)
@@@ -428,8 -485,8 +448,13 @@@ static struct parallel_data *padata_all
  
  	padata_init_pqueues(pd);
  	padata_init_squeues(pd);
++<<<<<<< HEAD
 +	setup_timer(&pd->timer, padata_reorder_timer, (unsigned long)pd);
 +	pd->seq_nr = 0;
++=======
+ 	timer_setup(&pd->timer, padata_reorder_timer, 0);
+ 	atomic_set(&pd->seq_nr, -1);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	atomic_set(&pd->reorder_objects, 0);
  	atomic_set(&pd->refcnt, 0);
  	pd->pinst = pinst;
diff --cc kernel/time/clocksource.c
index 036ef072fc3b,65f9e3f24dde..000000000000
--- a/kernel/time/clocksource.c
+++ b/kernel/time/clocksource.c
@@@ -171,10 -171,10 +171,10 @@@ void clocksource_mark_unstable(struct c
  	spin_unlock_irqrestore(&watchdog_lock, flags);
  }
  
- static void clocksource_watchdog(unsigned long data)
+ static void clocksource_watchdog(struct timer_list *unused)
  {
  	struct clocksource *cs;
 -	u64 csnow, wdnow, cslast, wdlast, delta;
 +	u64 csnow, wdnow, delta;
  	int64_t wd_nsec, cs_nsec;
  	int next_cpu, reset_pending;
  
@@@ -279,8 -290,7 +279,12 @@@ static inline void clocksource_start_wa
  {
  	if (watchdog_running || !watchdog || list_empty(&watchdog_list))
  		return;
++<<<<<<< HEAD
 +	init_timer(&watchdog_timer);
 +	watchdog_timer.function = clocksource_watchdog;
++=======
+ 	timer_setup(&watchdog_timer, clocksource_watchdog, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	watchdog_timer.expires = jiffies + WATCHDOG_INTERVAL;
  	add_timer_on(&watchdog_timer, cpumask_first(cpu_online_mask));
  	watchdog_running = 1;
diff --cc net/802/mrp.c
index bdf76f5d21ed,a808dd5bbb27..000000000000
--- a/net/802/mrp.c
+++ b/net/802/mrp.c
@@@ -594,6 -599,24 +594,27 @@@ static void mrp_join_timer(struct timer
  	mrp_join_timer_arm(app);
  }
  
++<<<<<<< HEAD
++=======
+ static void mrp_periodic_timer_arm(struct mrp_applicant *app)
+ {
+ 	mod_timer(&app->periodic_timer,
+ 		  jiffies + msecs_to_jiffies(mrp_periodic_time));
+ }
+ 
+ static void mrp_periodic_timer(struct timer_list *t)
+ {
+ 	struct mrp_applicant *app = from_timer(app, t, periodic_timer);
+ 
+ 	spin_lock(&app->lock);
+ 	mrp_mad_event(app, MRP_EVENT_PERIODIC);
+ 	mrp_pdu_queue(app);
+ 	spin_unlock(&app->lock);
+ 
+ 	mrp_periodic_timer_arm(app);
+ }
+ 
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  static int mrp_pdu_parse_end_mark(struct sk_buff *skb, int *offset)
  {
  	__be16 endmark;
@@@ -842,8 -865,10 +863,13 @@@ int mrp_init_applicant(struct net_devic
  	spin_lock_init(&app->lock);
  	skb_queue_head_init(&app->queue);
  	rcu_assign_pointer(dev->mrp_port->applicants[appl->type], app);
- 	setup_timer(&app->join_timer, mrp_join_timer, (unsigned long)app);
+ 	timer_setup(&app->join_timer, mrp_join_timer, 0);
  	mrp_join_timer_arm(app);
++<<<<<<< HEAD
++=======
+ 	timer_setup(&app->periodic_timer, mrp_periodic_timer, 0);
+ 	mrp_periodic_timer_arm(app);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	return 0;
  
  err3:
diff --cc net/core/drop_monitor.c
index 2d3980de28b3,c7785efeea57..000000000000
--- a/net/core/drop_monitor.c
+++ b/net/core/drop_monitor.c
@@@ -392,9 -412,7 +392,13 @@@ static int __init init_net_drop_monitor
  	for_each_possible_cpu(cpu) {
  		data = &per_cpu(dm_cpu_data, cpu);
  		INIT_WORK(&data->dm_alert_work, send_dm_alert);
++<<<<<<< HEAD
 +		init_timer(&data->send_timer);
 +		data->send_timer.data = (unsigned long)data;
 +		data->send_timer.function = sched_send_work;
++=======
+ 		timer_setup(&data->send_timer, sched_send_work, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  		spin_lock_init(&data->lock);
  		reset_per_cpu_data(data);
  	}
diff --cc net/core/neighbour.c
index 14b4923cc8a1,d1f5fe986edd..000000000000
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@@ -1620,8 -1571,9 +1620,14 @@@ void neigh_table_init(int index, struc
  
  	rwlock_init(&tbl->lock);
  	INIT_DEFERRABLE_WORK(&tbl->gc_work, neigh_periodic_work);
++<<<<<<< HEAD
 +	schedule_delayed_work(&tbl->gc_work, tbl->parms.reachable_time);
 +	setup_timer(&tbl->proxy_timer, neigh_proxy_process, (unsigned long)tbl);
++=======
+ 	queue_delayed_work(system_power_efficient_wq, &tbl->gc_work,
+ 			tbl->parms.reachable_time);
+ 	timer_setup(&tbl->proxy_timer, neigh_proxy_process, 0);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  	skb_queue_head_init_class(&tbl->proxy_queue,
  			&neigh_table_proxy_queue_class);
  
diff --cc net/decnet/dn_route.c
index 1781b04f5c74,324cb9f2f551..000000000000
--- a/net/decnet/dn_route.c
+++ b/net/decnet/dn_route.c
@@@ -184,18 -183,7 +184,22 @@@ static __inline__ unsigned int dn_hash(
  	return dn_rt_hash_mask & (unsigned int)tmp;
  }
  
++<<<<<<< HEAD
 +static inline void dnrt_free(struct dn_route *rt)
 +{
 +	call_rcu_bh(&rt->dst.rcu_head, dst_rcu_free);
 +}
 +
 +static inline void dnrt_drop(struct dn_route *rt)
 +{
 +	dst_release(&rt->dst);
 +	call_rcu_bh(&rt->dst.rcu_head, dst_rcu_free);
 +}
 +
 +static void dn_dst_check_expire(unsigned long dummy)
++=======
+ static void dn_dst_check_expire(struct timer_list *unused)
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  {
  	int i;
  	struct dn_route *rt;
diff --cc net/ipv4/igmp.c
index e1c8403127c2,d1f8f302dbf3..000000000000
--- a/net/ipv4/igmp.c
+++ b/net/ipv4/igmp.c
@@@ -718,12 -749,12 +718,12 @@@ static int igmp_send_report(struct in_d
  	ih->group = group;
  	ih->csum = ip_compute_csum((void *)ih, sizeof(struct igmphdr));
  
 -	return ip_local_out(net, skb->sk, skb);
 +	return ip_local_out(skb);
  }
  
- static void igmp_gq_timer_expire(unsigned long data)
+ static void igmp_gq_timer_expire(struct timer_list *t)
  {
- 	struct in_device *in_dev = (struct in_device *)data;
+ 	struct in_device *in_dev = from_timer(in_dev, t, mr_gq_timer);
  
  	in_dev->mr_gq_running = 0;
  	igmpv3_send_report(in_dev, NULL);
@@@ -1269,11 -1382,11 +1269,16 @@@ void ip_mc_inc_group(struct in_device *
  	/* initial mode is (EX, empty) */
  	im->sfmode = MCAST_EXCLUDE;
  	im->sfcount[MCAST_EXCLUDE] = 1;
 -	refcount_set(&im->refcnt, 1);
 +	atomic_set(&im->refcnt, 1);
  	spin_lock_init(&im->lock);
  #ifdef CONFIG_IP_MULTICAST
++<<<<<<< HEAD
 +	setup_timer(&im->timer, &igmp_timer_expire, (unsigned long)im);
 +	im->unsolicit_count = sysctl_igmp_qrv;
++=======
+ 	timer_setup(&im->timer, igmp_timer_expire, 0);
+ 	im->unsolicit_count = net->ipv4.sysctl_igmp_qrv;
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  #endif
  
  	im->next_rcu = in_dev->mc_list;
@@@ -1569,18 -1689,15 +1574,24 @@@ void ip_mc_down(struct in_device *in_de
  
  void ip_mc_init_dev(struct in_device *in_dev)
  {
 -#ifdef CONFIG_IP_MULTICAST
 -	struct net *net = dev_net(in_dev->dev);
 -#endif
  	ASSERT_RTNL();
  
 +	in_dev->mc_tomb = NULL;
  #ifdef CONFIG_IP_MULTICAST
++<<<<<<< HEAD
 +	in_dev->mr_gq_running = 0;
 +	setup_timer(&in_dev->mr_gq_timer, igmp_gq_timer_expire,
 +			(unsigned long)in_dev);
 +	in_dev->mr_ifc_count = 0;
 +	in_dev->mc_count     = 0;
 +	setup_timer(&in_dev->mr_ifc_timer, igmp_ifc_timer_expire,
 +			(unsigned long)in_dev);
 +	in_dev->mr_qrv = sysctl_igmp_qrv;
++=======
+ 	timer_setup(&in_dev->mr_gq_timer, igmp_gq_timer_expire, 0);
+ 	timer_setup(&in_dev->mr_ifc_timer, igmp_ifc_timer_expire, 0);
+ 	in_dev->mr_qrv = net->ipv4.sysctl_igmp_qrv;
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  #endif
  
  	spin_lock_init(&in_dev->mc_tomb_lock);
diff --cc net/ipv4/ipmr.c
index 26465a77ac8e,fd5f19c988e4..000000000000
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@@ -134,8 -110,9 +134,14 @@@ static int __ipmr_fill_mroute(struct mr
  			      struct mfc_cache *c, struct rtmsg *rtm);
  static void mroute_netlink_event(struct mr_table *mrt, struct mfc_cache *mfc,
  				 int cmd);
++<<<<<<< HEAD
 +static void mroute_clean_tables(struct mr_table *mrt);
 +static void ipmr_expire_process(unsigned long arg);
++=======
+ static void igmpmsg_netlink_event(struct mr_table *mrt, struct sk_buff *pkt);
+ static void mroute_clean_tables(struct mr_table *mrt, bool all);
+ static void ipmr_expire_process(struct timer_list *t);
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  #ifdef CONFIG_IP_MROUTE_MULTIPLE_TABLES
  #define ipmr_for_each_table(mrt, net) \
@@@ -329,18 -371,13 +335,17 @@@ static struct mr_table *ipmr_new_table(
  	write_pnet(&mrt->net, net);
  	mrt->id = id;
  
 -	rhltable_init(&mrt->mfc_hash, &ipmr_rht_params);
 -	INIT_LIST_HEAD(&mrt->mfc_cache_list);
 +	/* Forwarding cache */
 +	for (i = 0; i < MFC_LINES; i++)
 +		INIT_LIST_HEAD(&mrt->mfc_cache_array[i]);
 +
  	INIT_LIST_HEAD(&mrt->mfc_unres_queue);
  
- 	setup_timer(&mrt->ipmr_expire_timer, ipmr_expire_process,
- 		    (unsigned long)mrt);
+ 	timer_setup(&mrt->ipmr_expire_timer, ipmr_expire_process, 0);
  
 +#ifdef CONFIG_IP_PIMSM
  	mrt->mroute_reg_vif_num = -1;
 +#endif
  #ifdef CONFIG_IP_MROUTE_MULTIPLE_TABLES
  	list_add_tail_rcu(&mrt->list, &net->ipv4.mr_tables);
  #endif
@@@ -654,12 -802,10 +659,16 @@@ static void ipmr_destroy_unres(struct m
  	ipmr_cache_free(c);
  }
  
 +
  /* Timer process for the unresolved queue. */
++<<<<<<< HEAD
 +
 +static void ipmr_expire_process(unsigned long arg)
++=======
+ static void ipmr_expire_process(struct timer_list *t)
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  {
- 	struct mr_table *mrt = (struct mr_table *)arg;
+ 	struct mr_table *mrt = from_timer(mrt, t, ipmr_expire_timer);
  	unsigned long now;
  	unsigned long expires;
  	struct mfc_cache *c, *next;
diff --cc net/ipv6/mcast.c
index 3bee885ebde9,fc6d7d143f2c..000000000000
--- a/net/ipv6/mcast.c
+++ b/net/ipv6/mcast.c
@@@ -836,6 -817,48 +836,51 @@@ static void mld_clear_delrec(struct ine
  	read_unlock_bh(&idev->lock);
  }
  
++<<<<<<< HEAD
++=======
+ static void mca_get(struct ifmcaddr6 *mc)
+ {
+ 	refcount_inc(&mc->mca_refcnt);
+ }
+ 
+ static void ma_put(struct ifmcaddr6 *mc)
+ {
+ 	if (refcount_dec_and_test(&mc->mca_refcnt)) {
+ 		in6_dev_put(mc->idev);
+ 		kfree(mc);
+ 	}
+ }
+ 
+ static struct ifmcaddr6 *mca_alloc(struct inet6_dev *idev,
+ 				   const struct in6_addr *addr)
+ {
+ 	struct ifmcaddr6 *mc;
+ 
+ 	mc = kzalloc(sizeof(*mc), GFP_ATOMIC);
+ 	if (!mc)
+ 		return NULL;
+ 
+ 	timer_setup(&mc->mca_timer, igmp6_timer_handler, 0);
+ 
+ 	mc->mca_addr = *addr;
+ 	mc->idev = idev; /* reference taken by caller */
+ 	mc->mca_users = 1;
+ 	/* mca_stamp should be updated upon changes */
+ 	mc->mca_cstamp = mc->mca_tstamp = jiffies;
+ 	refcount_set(&mc->mca_refcnt, 1);
+ 	spin_lock_init(&mc->mca_lock);
+ 
+ 	/* initial mode is (EX, empty) */
+ 	mc->mca_sfmode = MCAST_EXCLUDE;
+ 	mc->mca_sfcount[MCAST_EXCLUDE] = 1;
+ 
+ 	if (ipv6_addr_is_ll_all_nodes(&mc->mca_addr) ||
+ 	    IPV6_ADDR_MC_SCOPE(&mc->mca_addr) < IPV6_ADDR_SCOPE_LINKLOCAL)
+ 		mc->mca_flags |= MAF_NOREPORT;
+ 
+ 	return mc;
+ }
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  
  /*
   *	device multicast group inc (add if not found)
@@@ -2459,10 -2462,9 +2504,14 @@@ static void mld_ifc_event(struct inet6_
  	mld_ifc_start_timer(idev, 1);
  }
  
++<<<<<<< HEAD
 +
 +static void igmp6_timer_handler(unsigned long data)
++=======
+ static void igmp6_timer_handler(struct timer_list *t)
++>>>>>>> e99e88a9d2b0 (treewide: setup_timer() -> timer_setup())
  {
- 	struct ifmcaddr6 *ma = (struct ifmcaddr6 *) data;
+ 	struct ifmcaddr6 *ma = from_timer(ma, t, mca_timer);
  
  	if (mld_in_v1_mode(ma->idev))
  		igmp6_send(&ma->mca_addr, ma->idev->dev, ICMPV6_MGM_REPORT);
* Unmerged path drivers/block/skd_main.c
* Unmerged path drivers/gpu/drm/msm/adreno/a5xx_preempt.c
* Unmerged path drivers/gpu/drm/msm/msm_gpu.c
* Unmerged path drivers/gpu/drm/rockchip/rockchip_drm_psr.c
* Unmerged path drivers/gpu/drm/vgem/vgem_fence.c
* Unmerged path drivers/iio/common/ssp_sensors/ssp_dev.c
* Unmerged path drivers/media/platform/sti/c8sectpfe/c8sectpfe-core.c
* Unmerged path drivers/memstick/core/ms_block.c
* Unmerged path drivers/net/dsa/mv88e6xxx/phy.c
* Unmerged path drivers/net/ethernet/synopsys/dwc-xlgmac-net.c
* Unmerged path drivers/net/ethernet/ti/netcp_ethss.c
* Unmerged path drivers/net/wireless/quantenna/qtnfmac/core.c
* Unmerged path drivers/nfc/st-nci/ndlc.c
* Unmerged path drivers/scsi/esas2r/esas2r_main.c
* Unmerged path drivers/staging/greybus/operation.c
* Unmerged path drivers/staging/lustre/lnet/lnet/net_fault.c
* Unmerged path drivers/staging/lustre/lustre/ptlrpc/service.c
* Unmerged path drivers/staging/media/imx/imx-ic-prpencvf.c
* Unmerged path drivers/staging/media/imx/imx-media-csi.c
* Unmerged path drivers/staging/most/hdm-usb/hdm_usb.c
* Unmerged path drivers/staging/wilc1000/wilc_wfi_cfgoperations.c
* Unmerged path drivers/tty/serial/fsl_lpuart.c
* Unmerged path drivers/usb/dwc2/hcd.c
* Unmerged path drivers/usb/dwc2/hcd_queue.c
* Unmerged path net/batman-adv/tp_meter.c
* Unmerged path net/ncsi/ncsi-manage.c
* Unmerged path net/rxrpc/call_object.c
diff --git a/arch/alpha/kernel/srmcons.c b/arch/alpha/kernel/srmcons.c
index 6f01d9ad7b81..ac77d682a570 100644
--- a/arch/alpha/kernel/srmcons.c
+++ b/arch/alpha/kernel/srmcons.c
@@ -64,9 +64,9 @@ srmcons_do_receive_chars(struct tty_port *port)
 }
 
 static void
-srmcons_receive_chars(unsigned long data)
+srmcons_receive_chars(struct timer_list *t)
 {
-	struct srmcons_private *srmconsp = (struct srmcons_private *)data;
+	struct srmcons_private *srmconsp = from_timer(srmconsp, t, timer);
 	struct tty_port *port = &srmconsp->port;
 	unsigned long flags;
 	int incr = 10;
@@ -205,8 +205,7 @@ static const struct tty_operations srmcons_ops = {
 static int __init
 srmcons_init(void)
 {
-	setup_timer(&srmcons_singleton.timer, srmcons_receive_chars,
-			(unsigned long)&srmcons_singleton);
+	timer_setup(&srmcons_singleton.timer, srmcons_receive_chars, 0);
 	if (srm_is_registered_console) {
 		struct tty_driver *driver;
 		int err;
* Unmerged path arch/arm/mach-iop32x/n2100.c
diff --git a/arch/arm/mach-orion5x/db88f5281-setup.c b/arch/arm/mach-orion5x/db88f5281-setup.c
index 4e1263da38bb..1da60fb5bf67 100644
--- a/arch/arm/mach-orion5x/db88f5281-setup.c
+++ b/arch/arm/mach-orion5x/db88f5281-setup.c
@@ -172,7 +172,7 @@ static struct platform_device db88f5281_nand_flash = {
 static void __iomem *db88f5281_7seg;
 static struct timer_list db88f5281_timer;
 
-static void db88f5281_7seg_event(unsigned long data)
+static void db88f5281_7seg_event(struct timer_list *unused)
 {
 	static int count = 0;
 	writel(0, db88f5281_7seg + (count << 4));
@@ -189,7 +189,7 @@ static int __init db88f5281_7seg_init(void)
 			printk(KERN_ERR "Failed to ioremap db88f5281_7seg\n");
 			return -EIO;
 		}
-		setup_timer(&db88f5281_timer, db88f5281_7seg_event, 0);
+		timer_setup(&db88f5281_timer, db88f5281_7seg_event, 0);
 		mod_timer(&db88f5281_timer, jiffies + 2 * HZ);
 	}
 
* Unmerged path arch/blackfin/kernel/nmi.c
* Unmerged path arch/mips/lasat/picvue_proc.c
* Unmerged path arch/powerpc/kernel/tau_6xx.c
* Unmerged path arch/powerpc/oprofile/op_model_cell.c
diff --git a/arch/powerpc/platforms/cell/spufs/sched.c b/arch/powerpc/platforms/cell/spufs/sched.c
index 49318385d4fa..6dbd71961c96 100644
--- a/arch/powerpc/platforms/cell/spufs/sched.c
+++ b/arch/powerpc/platforms/cell/spufs/sched.c
@@ -992,13 +992,13 @@ static void spu_calc_load(void)
 	CALC_LOAD(spu_avenrun[2], EXP_15, active_tasks);
 }
 
-static void spusched_wake(unsigned long data)
+static void spusched_wake(struct timer_list *unused)
 {
 	mod_timer(&spusched_timer, jiffies + SPUSCHED_TICK);
 	wake_up_process(spusched_task);
 }
 
-static void spuloadavg_wake(unsigned long data)
+static void spuloadavg_wake(struct timer_list *unused)
 {
 	mod_timer(&spuloadavg_timer, jiffies + LOAD_FREQ);
 	spu_calc_load();
@@ -1126,8 +1126,8 @@ int __init spu_sched_init(void)
 	}
 	spin_lock_init(&spu_prio->runq_lock);
 
-	setup_timer(&spusched_timer, spusched_wake, 0);
-	setup_timer(&spuloadavg_timer, spuloadavg_wake, 0);
+	timer_setup(&spusched_timer, spusched_wake, 0);
+	timer_setup(&spuloadavg_timer, spuloadavg_wake, 0);
 
 	spusched_task = kthread_run(spusched_thread, NULL, "spusched");
 	if (IS_ERR(spusched_task)) {
* Unmerged path arch/powerpc/platforms/powermac/low_i2c.c
diff --git a/arch/s390/kernel/time.c b/arch/s390/kernel/time.c
index acae4315adb1..520e9004d272 100644
--- a/arch/s390/kernel/time.c
+++ b/arch/s390/kernel/time.c
@@ -1476,7 +1476,7 @@ static void __init stp_reset(void)
 	}
 }
 
-static void stp_timeout(unsigned long dummy)
+static void stp_timeout(struct timer_list *unused)
 {
 	queue_work(time_sync_wq, &stp_work);
 }
@@ -1485,7 +1485,7 @@ static int __init stp_init(void)
 {
 	if (!test_bit(CLOCK_SYNC_HAS_STP, &clock_sync_flags))
 		return 0;
-	setup_timer(&stp_timer, stp_timeout, 0UL);
+	timer_setup(&stp_timer, stp_timeout, 0);
 	time_init_wq();
 	if (!stp_online)
 		return 0;
diff --git a/arch/sh/drivers/heartbeat.c b/arch/sh/drivers/heartbeat.c
index 7efc9c354fc7..62d6a477c242 100644
--- a/arch/sh/drivers/heartbeat.c
+++ b/arch/sh/drivers/heartbeat.c
@@ -59,9 +59,9 @@ static inline void heartbeat_toggle_bit(struct heartbeat_data *hd,
 	}
 }
 
-static void heartbeat_timer(unsigned long data)
+static void heartbeat_timer(struct timer_list *t)
 {
-	struct heartbeat_data *hd = (struct heartbeat_data *)data;
+	struct heartbeat_data *hd = from_timer(hd, t, timer);
 	static unsigned bit = 0, up = 1;
 
 	heartbeat_toggle_bit(hd, bit, hd->flags & HEARTBEAT_INVERTED);
@@ -133,7 +133,7 @@ static int heartbeat_drv_probe(struct platform_device *pdev)
 		}
 	}
 
-	setup_timer(&hd->timer, heartbeat_timer, (unsigned long)hd);
+	timer_setup(&hd->timer, heartbeat_timer, 0);
 	platform_set_drvdata(pdev, hd);
 
 	return mod_timer(&hd->timer, jiffies + 1);
* Unmerged path arch/sh/drivers/pci/common.c
* Unmerged path arch/sh/drivers/push-switch.c
diff --git a/block/blk-stat.c b/block/blk-stat.c
index d1bdfa182a21..90ba5a2ab3b5 100644
--- a/block/blk-stat.c
+++ b/block/blk-stat.c
@@ -109,9 +109,9 @@ void blk_stat_add(struct request *rq)
 	rcu_read_unlock();
 }
 
-static void blk_stat_timer_fn(unsigned long data)
+static void blk_stat_timer_fn(struct timer_list *t)
 {
-	struct blk_stat_callback *cb = (void *)data;
+	struct blk_stat_callback *cb = from_timer(cb, t, timer);
 	unsigned int bucket;
 	int cpu;
 
@@ -160,7 +160,7 @@ blk_stat_alloc_callback(void (*timer_fn)(struct blk_stat_callback *),
 	cb->bucket_fn = bucket_fn;
 	cb->data = data;
 	cb->buckets = buckets;
-	setup_timer(&cb->timer, blk_stat_timer_fn, (unsigned long)cb);
+	timer_setup(&cb->timer, blk_stat_timer_fn, 0);
 
 	return cb;
 }
* Unmerged path block/blk-throttle.c
* Unmerged path drivers/atm/ambassador.c
* Unmerged path drivers/atm/firestream.c
* Unmerged path drivers/atm/horizon.c
* Unmerged path drivers/atm/idt77252.c
* Unmerged path drivers/atm/lanai.c
* Unmerged path drivers/atm/nicstar.c
* Unmerged path drivers/block/DAC960.c
diff --git a/drivers/block/DAC960.h b/drivers/block/DAC960.h
index 85fa9bb63759..6a6226a2b932 100644
--- a/drivers/block/DAC960.h
+++ b/drivers/block/DAC960.h
@@ -4406,7 +4406,7 @@ static irqreturn_t DAC960_PD_InterruptHandler(int, void *);
 static irqreturn_t DAC960_P_InterruptHandler(int, void *);
 static void DAC960_V1_QueueMonitoringCommand(DAC960_Command_T *);
 static void DAC960_V2_QueueMonitoringCommand(DAC960_Command_T *);
-static void DAC960_MonitoringTimerFunction(unsigned long);
+static void DAC960_MonitoringTimerFunction(struct timer_list *);
 static void DAC960_Message(DAC960_MessageLevel_T, unsigned char *,
 			   DAC960_Controller_T *, ...);
 static void DAC960_CreateProcEntries(DAC960_Controller_T *);
diff --git a/drivers/block/rsxx/dma.c b/drivers/block/rsxx/dma.c
index fc88ba3e1bd2..d5c46a3308b7 100644
--- a/drivers/block/rsxx/dma.c
+++ b/drivers/block/rsxx/dma.c
@@ -354,9 +354,9 @@ static void rsxx_handle_dma_error(struct rsxx_dma_ctrl *ctrl,
 		rsxx_complete_dma(ctrl, dma, status);
 }
 
-static void dma_engine_stalled(unsigned long data)
+static void dma_engine_stalled(struct timer_list *t)
 {
-	struct rsxx_dma_ctrl *ctrl = (struct rsxx_dma_ctrl *)data;
+	struct rsxx_dma_ctrl *ctrl = from_timer(ctrl, t, activity_timer);
 	int cnt;
 
 	if (atomic_read(&ctrl->stats.hw_q_depth) == 0 ||
@@ -838,8 +838,7 @@ static int rsxx_dma_ctrl_init(struct pci_dev *dev,
 	mutex_init(&ctrl->work_lock);
 	INIT_LIST_HEAD(&ctrl->queue);
 
-	setup_timer(&ctrl->activity_timer, dma_engine_stalled,
-					(unsigned long)ctrl);
+	timer_setup(&ctrl->activity_timer, dma_engine_stalled, 0);
 
 	ctrl->issue_wq = alloc_ordered_workqueue(DRIVER_NAME"_issue", 0);
 	if (!ctrl->issue_wq)
* Unmerged path drivers/block/skd_main.c
* Unmerged path drivers/block/sunvdc.c
* Unmerged path drivers/block/umem.c
diff --git a/drivers/block/xsysace.c b/drivers/block/xsysace.c
index 3fd130fdfbc1..d163c42cdb54 100644
--- a/drivers/block/xsysace.c
+++ b/drivers/block/xsysace.c
@@ -770,9 +770,9 @@ static void ace_fsm_tasklet(unsigned long data)
 	spin_unlock_irqrestore(&ace->lock, flags);
 }
 
-static void ace_stall_timer(unsigned long data)
+static void ace_stall_timer(struct timer_list *t)
 {
-	struct ace_device *ace = (void *)data;
+	struct ace_device *ace = from_timer(ace, t, stall_timer);
 	unsigned long flags;
 
 	dev_warn(ace->dev,
@@ -984,7 +984,7 @@ static int ace_setup(struct ace_device *ace)
 	 * Initialize the state machine tasklet and stall timer
 	 */
 	tasklet_init(&ace->fsm_tasklet, ace_fsm_tasklet, (unsigned long)ace);
-	setup_timer(&ace->stall_timer, ace_stall_timer, (unsigned long)ace);
+	timer_setup(&ace->stall_timer, ace_stall_timer, 0);
 
 	/*
 	 * Initialize the request queue
diff --git a/drivers/char/ipmi/bt-bmc.c b/drivers/char/ipmi/bt-bmc.c
index 2f40256a0ee0..da6d0107fa2f 100644
--- a/drivers/char/ipmi/bt-bmc.c
+++ b/drivers/char/ipmi/bt-bmc.c
@@ -348,9 +348,9 @@ static const struct file_operations bt_bmc_fops = {
 	.unlocked_ioctl	= bt_bmc_ioctl,
 };
 
-static void poll_timer(unsigned long data)
+static void poll_timer(struct timer_list *t)
 {
-	struct bt_bmc *bt_bmc = (void *)data;
+	struct bt_bmc *bt_bmc = from_timer(bt_bmc, t, poll_timer);
 
 	bt_bmc->poll_timer.expires += msecs_to_jiffies(500);
 	wake_up(&bt_bmc->queue);
@@ -449,8 +449,7 @@ static int bt_bmc_probe(struct platform_device *pdev)
 		dev_info(dev, "Using IRQ %d\n", bt_bmc->irq);
 	} else {
 		dev_info(dev, "No IRQ; using timer\n");
-		setup_timer(&bt_bmc->poll_timer, poll_timer,
-			    (unsigned long)bt_bmc);
+		timer_setup(&bt_bmc->poll_timer, poll_timer, 0);
 		bt_bmc->poll_timer.expires = jiffies + msecs_to_jiffies(10);
 		add_timer(&bt_bmc->poll_timer);
 	}
diff --git a/drivers/char/ipmi/ipmi_msghandler.c b/drivers/char/ipmi/ipmi_msghandler.c
index e5b2d06618a0..6a102881a350 100644
--- a/drivers/char/ipmi/ipmi_msghandler.c
+++ b/drivers/char/ipmi/ipmi_msghandler.c
@@ -4599,7 +4599,7 @@ static struct timer_list ipmi_timer;
 
 static atomic_t stop_operation;
 
-static void ipmi_timeout(unsigned long data)
+static void ipmi_timeout(struct timer_list *unused)
 {
 	ipmi_smi_t intf;
 	int nt = 0;
@@ -5009,7 +5009,7 @@ static int ipmi_init_msghandler(void)
 
 #endif /* CONFIG_PROC_FS */
 
-	setup_timer(&ipmi_timer, ipmi_timeout, 0);
+	timer_setup(&ipmi_timer, ipmi_timeout, 0);
 	mod_timer(&ipmi_timer, jiffies + IPMI_TIMEOUT_JIFFIES);
 
 	atomic_notifier_chain_register(&panic_notifier_list, &panic_block);
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
diff --git a/drivers/char/ipmi/ipmi_ssif.c b/drivers/char/ipmi/ipmi_ssif.c
index dbbf7ba6446f..05123050e631 100644
--- a/drivers/char/ipmi/ipmi_ssif.c
+++ b/drivers/char/ipmi/ipmi_ssif.c
@@ -553,9 +553,9 @@ static void start_get(struct ssif_info *ssif_info)
 	}
 }
 
-static void retry_timeout(unsigned long data)
+static void retry_timeout(struct timer_list *t)
 {
-	struct ssif_info *ssif_info = (void *) data;
+	struct ssif_info *ssif_info = from_timer(ssif_info, t, retry_timer);
 	unsigned long oflags, *flags;
 	bool waiting;
 
@@ -1707,8 +1707,7 @@ static int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)
 
 	spin_lock_init(&ssif_info->lock);
 	ssif_info->ssif_state = SSIF_NORMAL;
-	setup_timer(&ssif_info->retry_timer, retry_timeout,
-		    (unsigned long)ssif_info);
+	timer_setup(&ssif_info->retry_timer, retry_timeout, 0);
 
 	for (i = 0; i < SSIF_NUM_STATS; i++)
 		atomic_set(&ssif_info->stats[i], 0);
diff --git a/drivers/char/tpm/tpm-dev-common.c b/drivers/char/tpm/tpm-dev-common.c
index 98cf36fb068d..e4a04b2d3c32 100644
--- a/drivers/char/tpm/tpm-dev-common.c
+++ b/drivers/char/tpm/tpm-dev-common.c
@@ -22,9 +22,9 @@
 #include "tpm.h"
 #include "tpm-dev.h"
 
-static void user_reader_timeout(unsigned long ptr)
+static void user_reader_timeout(struct timer_list *t)
 {
-	struct file_priv *priv = (struct file_priv *)ptr;
+	struct file_priv *priv = from_timer(priv, t, user_read_timer);
 
 	pr_warn("TPM user space timeout is deprecated (pid=%d)\n",
 		task_tgid_nr(current));
@@ -47,8 +47,7 @@ void tpm_common_open(struct file *file, struct tpm_chip *chip,
 {
 	priv->chip = chip;
 	mutex_init(&priv->buffer_mutex);
-	setup_timer(&priv->user_read_timer, user_reader_timeout,
-			(unsigned long)priv);
+	timer_setup(&priv->user_read_timer, user_reader_timeout, 0);
 	INIT_WORK(&priv->work, timeout_work);
 
 	file->private_data = priv;
diff --git a/drivers/gpu/drm/drm_vblank.c b/drivers/gpu/drm/drm_vblank.c
index 17e8ef9a1c11..537d77d9e7d8 100644
--- a/drivers/gpu/drm/drm_vblank.c
+++ b/drivers/gpu/drm/drm_vblank.c
@@ -379,9 +379,9 @@ void drm_vblank_disable_and_save(struct drm_device *dev, unsigned int pipe)
 	spin_unlock_irqrestore(&dev->vblank_time_lock, irqflags);
 }
 
-static void vblank_disable_fn(unsigned long arg)
+static void vblank_disable_fn(struct timer_list *t)
 {
-	struct drm_vblank_crtc *vblank = (void *)arg;
+	struct drm_vblank_crtc *vblank = from_timer(vblank, t, disable_timer);
 	struct drm_device *dev = vblank->dev;
 	unsigned int pipe = vblank->pipe;
 	unsigned long irqflags;
@@ -448,8 +448,7 @@ int drm_vblank_init(struct drm_device *dev, unsigned int num_crtcs)
 		vblank->dev = dev;
 		vblank->pipe = i;
 		init_waitqueue_head(&vblank->queue);
-		setup_timer(&vblank->disable_timer, vblank_disable_fn,
-			    (unsigned long)vblank);
+		timer_setup(&vblank->disable_timer, vblank_disable_fn, 0);
 		seqlock_init(&vblank->seqlock);
 	}
 
@@ -1013,7 +1012,7 @@ static void drm_vblank_put(struct drm_device *dev, unsigned int pipe)
 		if (drm_vblank_offdelay == 0)
 			return;
 		else if (drm_vblank_offdelay < 0)
-			vblank_disable_fn((unsigned long)vblank);
+			vblank_disable_fn(&vblank->disable_timer);
 		else if (!dev->vblank_disable_immediate)
 			mod_timer(&vblank->disable_timer,
 				  jiffies + ((drm_vblank_offdelay * HZ)/1000));
@@ -1588,7 +1587,7 @@ bool drm_handle_vblank(struct drm_device *dev, unsigned int pipe)
 	spin_unlock_irqrestore(&dev->event_lock, irqflags);
 
 	if (disable_irq)
-		vblank_disable_fn((unsigned long)vblank);
+		vblank_disable_fn(&vblank->disable_timer);
 
 	return true;
 }
* Unmerged path drivers/gpu/drm/exynos/exynos_drm_vidi.c
diff --git a/drivers/gpu/drm/i2c/tda998x_drv.c b/drivers/gpu/drm/i2c/tda998x_drv.c
index 54e3255dde13..267bb2623060 100644
--- a/drivers/gpu/drm/i2c/tda998x_drv.c
+++ b/drivers/gpu/drm/i2c/tda998x_drv.c
@@ -601,9 +601,9 @@ tda998x_reset(struct tda998x_priv *priv)
  * we have seen a HPD inactive->active transition.  This code implements
  * that delay.
  */
-static void tda998x_edid_delay_done(unsigned long data)
+static void tda998x_edid_delay_done(struct timer_list *t)
 {
-	struct tda998x_priv *priv = (struct tda998x_priv *)data;
+	struct tda998x_priv *priv = from_timer(priv, t, edid_delay_timer);
 
 	priv->edid_delay_active = false;
 	wake_up(&priv->edid_delay_waitq);
@@ -1492,8 +1492,7 @@ static int tda998x_create(struct i2c_client *client, struct tda998x_priv *priv)
 
 	mutex_init(&priv->mutex);	/* protect the page access */
 	init_waitqueue_head(&priv->edid_delay_waitq);
-	setup_timer(&priv->edid_delay_timer, tda998x_edid_delay_done,
-		    (unsigned long)priv);
+	timer_setup(&priv->edid_delay_timer, tda998x_edid_delay_done, 0);
 	INIT_WORK(&priv->detect_work, tda998x_detect_work);
 
 	/* wake up the device: */
* Unmerged path drivers/gpu/drm/msm/adreno/a5xx_preempt.c
* Unmerged path drivers/gpu/drm/msm/msm_gpu.c
* Unmerged path drivers/gpu/drm/rockchip/rockchip_drm_psr.c
* Unmerged path drivers/gpu/drm/vgem/vgem_fence.c
diff --git a/drivers/gpu/drm/via/via_dmablit.c b/drivers/gpu/drm/via/via_dmablit.c
index 98aae9809249..8c8e9be1403b 100644
--- a/drivers/gpu/drm/via/via_dmablit.c
+++ b/drivers/gpu/drm/via/via_dmablit.c
@@ -452,9 +452,9 @@ via_dmablit_sync(struct drm_device *dev, uint32_t handle, int engine)
 
 
 static void
-via_dmablit_timer(unsigned long data)
+via_dmablit_timer(struct timer_list *t)
 {
-	drm_via_blitq_t *blitq = (drm_via_blitq_t *) data;
+	drm_via_blitq_t *blitq = from_timer(blitq, t, poll_timer);
 	struct drm_device *dev = blitq->dev;
 	int engine = (int)
 		(blitq - ((drm_via_private_t *)dev->dev_private)->blit_queues);
@@ -559,8 +559,7 @@ via_init_dmablit(struct drm_device *dev)
 			init_waitqueue_head(blitq->blit_queue + j);
 		init_waitqueue_head(&blitq->busy_queue);
 		INIT_WORK(&blitq->wq, via_dmablit_workqueue);
-		setup_timer(&blitq->poll_timer, via_dmablit_timer,
-				(unsigned long)blitq);
+		timer_setup(&blitq->poll_timer, via_dmablit_timer, 0);
 	}
 }
 
diff --git a/drivers/hid/hid-appleir.c b/drivers/hid/hid-appleir.c
index af78bf264de9..e2b431f6e133 100644
--- a/drivers/hid/hid-appleir.c
+++ b/drivers/hid/hid-appleir.c
@@ -173,9 +173,9 @@ static void battery_flat(struct appleir *appleir)
 	dev_err(&appleir->input_dev->dev, "possible flat battery?\n");
 }
 
-static void key_up_tick(unsigned long data)
+static void key_up_tick(struct timer_list *t)
 {
-	struct appleir *appleir = (struct appleir *)data;
+	struct appleir *appleir = from_timer(appleir, t, key_up_timer);
 	struct hid_device *hid = appleir->hid;
 	unsigned long flags;
 
@@ -300,8 +300,7 @@ static int appleir_probe(struct hid_device *hid, const struct hid_device_id *id)
 	appleir->hid = hid;
 
 	spin_lock_init(&appleir->lock);
-	setup_timer(&appleir->key_up_timer,
-		    key_up_tick, (unsigned long) appleir);
+	timer_setup(&appleir->key_up_timer, key_up_tick, 0);
 
 	hid_set_drvdata(hid, appleir);
 
diff --git a/drivers/hid/hid-prodikeys.c b/drivers/hid/hid-prodikeys.c
index 0a3ff8f2b9f4..52f1cc1a9823 100644
--- a/drivers/hid/hid-prodikeys.c
+++ b/drivers/hid/hid-prodikeys.c
@@ -239,9 +239,9 @@ drop_note:
 	return;
 }
 
-static void pcmidi_sustained_note_release(unsigned long data)
+static void pcmidi_sustained_note_release(struct timer_list *t)
 {
-	struct pcmidi_sustain *pms = (struct pcmidi_sustain *)data;
+	struct pcmidi_sustain *pms = from_timer(pms, t, timer);
 
 	pcmidi_send_note(pms->pm, pms->status, pms->note, pms->velocity);
 	pms->in_use = 0;
@@ -256,8 +256,7 @@ static void init_sustain_timers(struct pcmidi_snd *pm)
 		pms = &pm->sustained_notes[i];
 		pms->in_use = 0;
 		pms->pm = pm;
-		setup_timer(&pms->timer, pcmidi_sustained_note_release,
-			(unsigned long)pms);
+		timer_setup(&pms->timer, pcmidi_sustained_note_release, 0);
 	}
 }
 
* Unmerged path drivers/hid/hid-wiimote-core.c
* Unmerged path drivers/iio/common/ssp_sensors/ssp_dev.c
diff --git a/drivers/infiniband/hw/mlx5/mr.c b/drivers/infiniband/hw/mlx5/mr.c
index ae95e582f2ef..7d11ed580db3 100644
--- a/drivers/infiniband/hw/mlx5/mr.c
+++ b/drivers/infiniband/hw/mlx5/mr.c
@@ -657,9 +657,9 @@ err:
 	return -ENOMEM;
 }
 
-static void delay_time_func(unsigned long ctx)
+static void delay_time_func(struct timer_list *t)
 {
-	struct mlx5_ib_dev *dev = (struct mlx5_ib_dev *)ctx;
+	struct mlx5_ib_dev *dev = from_timer(dev, t, delay_timer);
 
 	dev->fill_delay = 0;
 }
@@ -678,7 +678,7 @@ int mlx5_mr_cache_init(struct mlx5_ib_dev *dev)
 		return -ENOMEM;
 	}
 
-	setup_timer(&dev->delay_timer, delay_time_func, (unsigned long)dev);
+	timer_setup(&dev->delay_timer, delay_time_func, 0);
 	for (i = 0; i < MAX_MR_CACHE_ENTRIES; i++) {
 		ent = &cache->ent[i];
 		INIT_LIST_HEAD(&ent->head);
* Unmerged path drivers/input/gameport/gameport.c
* Unmerged path drivers/input/joystick/db9.c
* Unmerged path drivers/input/joystick/gamecon.c
* Unmerged path drivers/input/joystick/turbografx.c
* Unmerged path drivers/iommu/iova.c
* Unmerged path drivers/isdn/capi/capidrv.c
* Unmerged path drivers/isdn/divert/isdn_divert.c
* Unmerged path drivers/isdn/hardware/eicon/divasi.c
* Unmerged path drivers/isdn/hardware/mISDN/hfcmulti.c
* Unmerged path drivers/isdn/hardware/mISDN/hfcpci.c
* Unmerged path drivers/isdn/hardware/mISDN/mISDNisar.c
* Unmerged path drivers/isdn/i4l/isdn_common.c
* Unmerged path drivers/isdn/i4l/isdn_net.c
* Unmerged path drivers/isdn/i4l/isdn_ppp.c
* Unmerged path drivers/isdn/i4l/isdn_tty.c
* Unmerged path drivers/media/platform/mem2mem_testdev.c
* Unmerged path drivers/media/platform/s5p-mfc/s5p_mfc.c
* Unmerged path drivers/media/platform/sti/c8sectpfe/c8sectpfe-core.c
* Unmerged path drivers/media/usb/au0828/au0828-dvb.c
* Unmerged path drivers/media/usb/au0828/au0828-video.c
* Unmerged path drivers/memstick/core/ms_block.c
diff --git a/drivers/mfd/rtsx_usb.c b/drivers/mfd/rtsx_usb.c
index 29e3b37b7345..6f5610ba3c18 100644
--- a/drivers/mfd/rtsx_usb.c
+++ b/drivers/mfd/rtsx_usb.c
@@ -40,9 +40,9 @@ static struct mfd_cell rtsx_usb_cells[] = {
 	},
 };
 
-static void rtsx_usb_sg_timed_out(unsigned long data)
+static void rtsx_usb_sg_timed_out(struct timer_list *t)
 {
-	struct rtsx_ucr *ucr = (struct rtsx_ucr *)data;
+	struct rtsx_ucr *ucr = from_timer(ucr, t, sg_timer);
 
 	dev_dbg(&ucr->pusb_intf->dev, "%s: sg transfer timed out", __func__);
 	usb_sg_cancel(&ucr->current_sg);
@@ -663,7 +663,7 @@ static int rtsx_usb_probe(struct usb_interface *intf,
 		goto out_init_fail;
 
 	/* initialize USB SG transfer timer */
-	setup_timer(&ucr->sg_timer, rtsx_usb_sg_timed_out, (unsigned long) ucr);
+	timer_setup(&ucr->sg_timer, rtsx_usb_sg_timed_out, 0);
 
 	ret = mfd_add_devices(&intf->dev, usb_dev->devnum, rtsx_usb_cells,
 			ARRAY_SIZE(rtsx_usb_cells), NULL, 0, NULL);
* Unmerged path drivers/mmc/core/host.c
diff --git a/drivers/mtd/sm_ftl.c b/drivers/mtd/sm_ftl.c
index f9d5615c5727..89e1e24c0f56 100644
--- a/drivers/mtd/sm_ftl.c
+++ b/drivers/mtd/sm_ftl.c
@@ -991,9 +991,9 @@ restart:
 
 
 /* flush timer, runs a second after last write */
-static void sm_cache_flush_timer(unsigned long data)
+static void sm_cache_flush_timer(struct timer_list *t)
 {
-	struct sm_ftl *ftl = (struct sm_ftl *)data;
+	struct sm_ftl *ftl = from_timer(ftl, t, timer);
 	queue_work(cache_flush_workqueue, &ftl->flush_work);
 }
 
@@ -1141,7 +1141,7 @@ static void sm_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)
 
 
 	mutex_init(&ftl->mutex);
-	setup_timer(&ftl->timer, sm_cache_flush_timer, (unsigned long)ftl);
+	timer_setup(&ftl->timer, sm_cache_flush_timer, 0);
 	INIT_WORK(&ftl->flush_work, sm_cache_flush_work);
 	init_completion(&ftl->erase_completion);
 
* Unmerged path drivers/net/caif/caif_hsi.c
* Unmerged path drivers/net/dsa/mv88e6xxx/phy.c
* Unmerged path drivers/net/eql.c
* Unmerged path drivers/net/ethernet/adi/bfin_mac.c
diff --git a/drivers/net/ethernet/amazon/ena/ena_netdev.c b/drivers/net/ethernet/amazon/ena/ena_netdev.c
index d8a45b85df52..48a1151d2f76 100644
--- a/drivers/net/ethernet/amazon/ena/ena_netdev.c
+++ b/drivers/net/ethernet/amazon/ena/ena_netdev.c
@@ -2885,9 +2885,9 @@ static void ena_update_host_info(struct ena_admin_host_info *host_info,
 		(netdev->features & GENMASK_ULL(63, 32)) >> 32;
 }
 
-static void ena_timer_service(unsigned long data)
+static void ena_timer_service(struct timer_list *t)
 {
-	struct ena_adapter *adapter = (struct ena_adapter *)data;
+	struct ena_adapter *adapter = from_timer(adapter, t, timer_service);
 	u8 *debug_area = adapter->ena_dev->host_attr.debug_area_virt_addr;
 	struct ena_admin_host_info *host_info =
 		adapter->ena_dev->host_attr.host_info;
@@ -3304,8 +3304,7 @@ static int ena_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	ena_update_hints(adapter, &get_feat_ctx.hw_hints);
 
-	setup_timer(&adapter->timer_service, ena_timer_service,
-		    (unsigned long)adapter);
+	timer_setup(&adapter->timer_service, ena_timer_service, 0);
 	mod_timer(&adapter->timer_service, round_jiffies(jiffies + HZ));
 
 	dev_info(&pdev->dev, "%s found at mem %lx, mac addr %pM Queues %d\n",
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_nic.c
diff --git a/drivers/net/ethernet/atheros/atl1c/atl1c_main.c b/drivers/net/ethernet/atheros/atl1c/atl1c_main.c
index d65ccfd57624..c3db3c62013e 100644
--- a/drivers/net/ethernet/atheros/atl1c/atl1c_main.c
+++ b/drivers/net/ethernet/atheros/atl1c/atl1c_main.c
@@ -224,9 +224,10 @@ static u32 atl1c_wait_until_idle(struct atl1c_hw *hw, u32 modu_ctrl)
  * atl1c_phy_config - Timer Call-back
  * @data: pointer to netdev cast into an unsigned long
  */
-static void atl1c_phy_config(unsigned long data)
+static void atl1c_phy_config(struct timer_list *t)
 {
-	struct atl1c_adapter *adapter = (struct atl1c_adapter *) data;
+	struct atl1c_adapter *adapter = from_timer(adapter, t,
+						   phy_config_timer);
 	struct atl1c_hw *hw = &adapter->hw;
 	unsigned long flags;
 
@@ -2604,8 +2605,7 @@ static int atl1c_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	adapter->mii.phy_id_mask = 0x1f;
 	adapter->mii.reg_num_mask = MDIO_CTRL_REG_MASK;
 	netif_napi_add(netdev, &adapter->napi, atl1c_clean, 64);
-	setup_timer(&adapter->phy_config_timer, atl1c_phy_config,
-			(unsigned long)adapter);
+	timer_setup(&adapter->phy_config_timer, atl1c_phy_config, 0);
 	/* setup the private structure */
 	err = atl1c_sw_init(adapter);
 	if (err) {
* Unmerged path drivers/net/ethernet/atheros/atl1e/atl1e_main.c
diff --git a/drivers/net/ethernet/atheros/atlx/atl1.c b/drivers/net/ethernet/atheros/atlx/atl1.c
index 65a67b7f3162..dfc17f97bf66 100644
--- a/drivers/net/ethernet/atheros/atlx/atl1.c
+++ b/drivers/net/ethernet/atheros/atlx/atl1.c
@@ -2571,9 +2571,10 @@ static irqreturn_t atl1_intr(int irq, void *data)
  * atl1_phy_config - Timer Call-back
  * @data: pointer to netdev cast into an unsigned long
  */
-static void atl1_phy_config(unsigned long data)
+static void atl1_phy_config(struct timer_list *t)
 {
-	struct atl1_adapter *adapter = (struct atl1_adapter *)data;
+	struct atl1_adapter *adapter = from_timer(adapter, t,
+						  phy_config_timer);
 	struct atl1_hw *hw = &adapter->hw;
 	unsigned long flags;
 
@@ -3070,8 +3071,7 @@ static int atl1_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	/* assume we have no link for now */
 	netif_carrier_off(netdev);
 
-	setup_timer(&adapter->phy_config_timer, atl1_phy_config,
-		    (unsigned long)adapter);
+	timer_setup(&adapter->phy_config_timer, atl1_phy_config, 0);
 	adapter->phy_timer_pending = false;
 
 	INIT_WORK(&adapter->reset_dev_task, atl1_reset_dev_task);
* Unmerged path drivers/net/ethernet/atheros/atlx/atl2.c
* Unmerged path drivers/net/ethernet/broadcom/b44.c
diff --git a/drivers/net/ethernet/broadcom/bnx2.c b/drivers/net/ethernet/broadcom/bnx2.c
index b60af4f48ac4..e56d8a71ad5a 100644
--- a/drivers/net/ethernet/broadcom/bnx2.c
+++ b/drivers/net/ethernet/broadcom/bnx2.c
@@ -6183,9 +6183,9 @@ bnx2_5708_serdes_timer(struct bnx2 *bp)
 }
 
 static void
-bnx2_timer(unsigned long data)
+bnx2_timer(struct timer_list *t)
 {
-	struct bnx2 *bp = (struct bnx2 *) data;
+	struct bnx2 *bp = from_timer(bp, t, timer);
 
 	if (!netif_running(bp->dev))
 		return;
@@ -8462,7 +8462,7 @@ bnx2_init_board(struct pci_dev *pdev, struct net_device *dev)
 	bnx2_set_default_link(bp);
 	bp->req_flow_ctrl = FLOW_CTRL_RX | FLOW_CTRL_TX;
 
-	setup_timer(&bp->timer, bnx2_timer, (unsigned long)bp);
+	timer_setup(&bp->timer, bnx2_timer, 0);
 	bp->timer.expires = RUN_AT(BNX2_TIMER_INTERVAL);
 
 #ifdef BCM_CNIC
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
index 0b0df385dd34..169a0c931750 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
@@ -5763,9 +5763,9 @@ void bnx2x_drv_pulse(struct bnx2x *bp)
 		 bp->fw_drv_pulse_wr_seq);
 }
 
-static void bnx2x_timer(unsigned long data)
+static void bnx2x_timer(struct timer_list *t)
 {
-	struct bnx2x *bp = (struct bnx2x *) data;
+	struct bnx2x *bp = from_timer(bp, t, timer);
 
 	if (!netif_running(bp->dev))
 		return;
@@ -12425,7 +12425,7 @@ static int bnx2x_init_bp(struct bnx2x *bp)
 
 	bp->current_interval = CHIP_REV_IS_SLOW(bp) ? 5*HZ : HZ;
 
-	setup_timer(&bp->timer, bnx2x_timer, (unsigned long)bp);
+	timer_setup(&bp->timer, bnx2x_timer, 0);
 	bp->timer.expires = jiffies + bp->current_interval;
 
 	if (SHMEM2_HAS(bp, dcbx_lldp_params_offset) &&
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 44d1856b10e5..b6edf50f2359 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -7395,9 +7395,9 @@ static void bnxt_poll_controller(struct net_device *dev)
 }
 #endif
 
-static void bnxt_timer(unsigned long data)
+static void bnxt_timer(struct timer_list *t)
 {
-	struct bnxt *bp = (struct bnxt *)data;
+	struct bnxt *bp = from_timer(bp, t, timer);
 	struct net_device *dev = bp->dev;
 
 	if (!netif_running(dev))
@@ -7669,7 +7669,7 @@ static int bnxt_init_board(struct pci_dev *pdev, struct net_device *dev)
 
 	bnxt_init_dflt_coal(bp);
 
-	setup_timer(&bp->timer, bnxt_timer, (unsigned long)bp);
+	timer_setup(&bp->timer, bnxt_timer, 0);
 	bp->current_interval = BNXT_TIMER_INTERVAL;
 
 	clear_bit(BNXT_STATE_OPEN, &bp->state);
diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c
index 004b18875b50..e86c33d81b59 100644
--- a/drivers/net/ethernet/broadcom/tg3.c
+++ b/drivers/net/ethernet/broadcom/tg3.c
@@ -10951,9 +10951,9 @@ static void tg3_chk_missed_msi(struct tg3 *tp)
 	}
 }
 
-static void tg3_timer(unsigned long __opaque)
+static void tg3_timer(struct timer_list *t)
 {
-	struct tg3 *tp = (struct tg3 *) __opaque;
+	struct tg3 *tp = from_timer(tp, t, timer);
 
 	spin_lock(&tp->lock);
 
@@ -11110,7 +11110,7 @@ static void tg3_timer_init(struct tg3 *tp)
 	tp->asf_multiplier = (HZ / tp->timer_offset) *
 			     TG3_FW_UPDATE_FREQ_SEC;
 
-	setup_timer(&tp->timer, tg3_timer, (unsigned long)tp);
+	timer_setup(&tp->timer, tg3_timer, 0);
 }
 
 static void tg3_timer_start(struct tg3 *tp)
diff --git a/drivers/net/ethernet/cisco/enic/enic_main.c b/drivers/net/ethernet/cisco/enic/enic_main.c
index e8b29056a6ab..6e228f7cc802 100644
--- a/drivers/net/ethernet/cisco/enic/enic_main.c
+++ b/drivers/net/ethernet/cisco/enic/enic_main.c
@@ -1676,9 +1676,9 @@ static int enic_poll_msix_rq(struct napi_struct *napi, int budget)
 	return work_done;
 }
 
-static void enic_notify_timer(unsigned long data)
+static void enic_notify_timer(struct timer_list *t)
 {
-	struct enic *enic = (struct enic *)data;
+	struct enic *enic = from_timer(enic, t, notify_timer);
 
 	enic_notify_check(enic);
 
@@ -2851,8 +2851,7 @@ static int enic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	/* Setup notification timer, HW reset task, and wq locks
 	 */
 
-	setup_timer(&enic->notify_timer, enic_notify_timer,
-		    (unsigned long)enic);
+	timer_setup(&enic->notify_timer, enic_notify_timer, 0);
 
 	enic_set_rx_coal_setting(enic);
 	INIT_WORK(&enic->reset, enic_reset);
* Unmerged path drivers/net/ethernet/marvell/mv643xx_eth.c
* Unmerged path drivers/net/ethernet/marvell/pxa168_eth.c
diff --git a/drivers/net/ethernet/marvell/skge.c b/drivers/net/ethernet/marvell/skge.c
index c78f62da092c..48194d39c719 100644
--- a/drivers/net/ethernet/marvell/skge.c
+++ b/drivers/net/ethernet/marvell/skge.c
@@ -1477,9 +1477,9 @@ static int xm_check_link(struct net_device *dev)
  * get an interrupt when carrier is detected, need to poll for
  * link coming up.
  */
-static void xm_link_timer(unsigned long arg)
+static void xm_link_timer(struct timer_list *t)
 {
-	struct skge_port *skge = (struct skge_port *) arg;
+	struct skge_port *skge = from_timer(skge, t, link_timer);
 	struct net_device *dev = skge->netdev;
 	struct skge_hw *hw = skge->hw;
 	int port = skge->port;
@@ -3846,7 +3846,7 @@ static struct net_device *skge_devinit(struct skge_hw *hw, int port,
 
 	/* Only used for Genesis XMAC */
 	if (is_genesis(hw))
-	    setup_timer(&skge->link_timer, xm_link_timer, (unsigned long) skge);
+	    timer_setup(&skge->link_timer, xm_link_timer, 0);
 	else {
 		dev->hw_features = NETIF_F_IP_CSUM | NETIF_F_SG |
 		                   NETIF_F_RXCSUM;
diff --git a/drivers/net/ethernet/marvell/sky2.c b/drivers/net/ethernet/marvell/sky2.c
index 2b399abd287a..327e898699b3 100644
--- a/drivers/net/ethernet/marvell/sky2.c
+++ b/drivers/net/ethernet/marvell/sky2.c
@@ -2982,9 +2982,9 @@ static int sky2_rx_hung(struct net_device *dev)
 	}
 }
 
-static void sky2_watchdog(unsigned long arg)
+static void sky2_watchdog(struct timer_list *t)
 {
-	struct sky2_hw *hw = (struct sky2_hw *) arg;
+	struct sky2_hw *hw = from_timer(hw, t, watchdog_timer);
 
 	/* Check for lost IRQ once a second */
 	if (sky2_read32(hw, B0_ISRC)) {
@@ -5047,7 +5047,7 @@ static int sky2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		sky2_show_addr(dev1);
 	}
 
-	setup_timer(&hw->watchdog_timer, sky2_watchdog, (unsigned long) hw);
+	timer_setup(&hw->watchdog_timer, sky2_watchdog, 0);
 	INIT_WORK(&hw->restart_work, sky2_restart);
 
 	pci_set_drvdata(pdev, hw);
diff --git a/drivers/net/ethernet/myricom/myri10ge/myri10ge.c b/drivers/net/ethernet/myricom/myri10ge/myri10ge.c
index eb1a6c95ce8d..14fcbd9eab45 100644
--- a/drivers/net/ethernet/myricom/myri10ge/myri10ge.c
+++ b/drivers/net/ethernet/myricom/myri10ge/myri10ge.c
@@ -3706,7 +3706,7 @@ static void myri10ge_watchdog(struct work_struct *work)
  * cannot detect a NIC with a parity error in a timely fashion if the
  * NIC is lightly loaded.
  */
-static void myri10ge_watchdog_timer(unsigned long arg)
+static void myri10ge_watchdog_timer(struct timer_list *t)
 {
 	struct myri10ge_priv *mgp;
 	struct myri10ge_slice_state *ss;
@@ -3714,7 +3714,7 @@ static void myri10ge_watchdog_timer(unsigned long arg)
 	u32 rx_pause_cnt;
 	u16 cmd;
 
-	mgp = (struct myri10ge_priv *)arg;
+	mgp = from_timer(mgp, t, watchdog_timer);
 
 	rx_pause_cnt = ntohl(mgp->ss[0].fw_stats->dropped_pause);
 	busy_slice_cnt = 0;
@@ -4136,8 +4136,7 @@ static int myri10ge_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	pci_save_state(pdev);
 
 	/* Setup the watchdog timer */
-	setup_timer(&mgp->watchdog_timer, myri10ge_watchdog_timer,
-		    (unsigned long)mgp);
+	timer_setup(&mgp->watchdog_timer, myri10ge_watchdog_timer, 0);
 
 	SET_ETHTOOL_OPS(netdev, &myri10ge_ethtool_ops);
 	INIT_WORK(&mgp->watchdog_work, myri10ge_watchdog);
diff --git a/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c b/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c
index 5a5293af83d7..d1aa67d0d63e 100644
--- a/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c
+++ b/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c
@@ -1081,9 +1081,10 @@ static void pch_gbe_set_mode(struct pch_gbe_adapter *adapter, u16 speed,
  * pch_gbe_watchdog - Watchdog process
  * @data:  Board private structure
  */
-static void pch_gbe_watchdog(unsigned long data)
+static void pch_gbe_watchdog(struct timer_list *t)
 {
-	struct pch_gbe_adapter *adapter = (struct pch_gbe_adapter *)data;
+	struct pch_gbe_adapter *adapter = from_timer(adapter, t,
+						     watchdog_timer);
 	struct net_device *netdev = adapter->netdev;
 	struct pch_gbe_hw *hw = &adapter->hw;
 
@@ -2656,8 +2657,7 @@ static int pch_gbe_probe(struct pci_dev *pdev,
 		dev_err(&pdev->dev, "Invalid MAC address, "
 		                    "interface disabled.\n");
 	}
-	setup_timer(&adapter->watchdog_timer, pch_gbe_watchdog,
-		    (unsigned long)adapter);
+	timer_setup(&adapter->watchdog_timer, pch_gbe_watchdog, 0);
 
 	INIT_WORK(&adapter->reset_task, pch_gbe_reset_task);
 
* Unmerged path drivers/net/ethernet/pasemi/pasemi_mac.c
* Unmerged path drivers/net/ethernet/qlogic/qla3xxx.c
diff --git a/drivers/net/ethernet/rocker/rocker_ofdpa.c b/drivers/net/ethernet/rocker/rocker_ofdpa.c
index 84856e7e3555..45a6fac3f7f9 100644
--- a/drivers/net/ethernet/rocker/rocker_ofdpa.c
+++ b/drivers/net/ethernet/rocker/rocker_ofdpa.c
@@ -2104,9 +2104,9 @@ err_out:
 	return err;
 }
 
-static void ofdpa_fdb_cleanup(unsigned long data)
+static void ofdpa_fdb_cleanup(struct timer_list *t)
 {
-	struct ofdpa *ofdpa = (struct ofdpa *)data;
+	struct ofdpa *ofdpa = from_timer(ofdpa, t, fdb_cleanup_timer);
 	struct ofdpa_port *ofdpa_port;
 	struct ofdpa_fdb_tbl_entry *entry;
 	struct hlist_node *tmp;
@@ -2493,8 +2493,7 @@ static int ofdpa_init(struct rocker *rocker)
 	hash_init(ofdpa->neigh_tbl);
 	spin_lock_init(&ofdpa->neigh_tbl_lock);
 
-	setup_timer(&ofdpa->fdb_cleanup_timer, ofdpa_fdb_cleanup,
-		    (unsigned long) ofdpa);
+	timer_setup(&ofdpa->fdb_cleanup_timer, ofdpa_fdb_cleanup, 0);
 	mod_timer(&ofdpa->fdb_cleanup_timer, jiffies);
 
 	ofdpa->ageing_time = BR_DEFAULT_AGEING_TIME;
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
* Unmerged path drivers/net/ethernet/synopsys/dwc-xlgmac-net.c
* Unmerged path drivers/net/ethernet/ti/cpsw_ale.c
* Unmerged path drivers/net/ethernet/ti/netcp_ethss.c
* Unmerged path drivers/net/ethernet/toshiba/spider_net.c
* Unmerged path drivers/net/slip/slip.c
diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index 3c46a6b55234..1642e63506eb 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -361,9 +361,9 @@ static void tun_flow_delete_by_queue(struct tun_struct *tun, u16 queue_index)
 	spin_unlock_bh(&tun->lock);
 }
 
-static void tun_flow_cleanup(unsigned long data)
+static void tun_flow_cleanup(struct timer_list *t)
 {
-	struct tun_struct *tun = (struct tun_struct *)data;
+	struct tun_struct *tun = from_timer(tun, t, flow_gc_timer);
 	unsigned long delay = tun->ageing_time;
 	unsigned long next_timer = jiffies + delay;
 	unsigned long count = 0;
@@ -1019,7 +1019,9 @@ static void tun_flow_init(struct tun_struct *tun)
 		INIT_HLIST_HEAD(&tun->flows[i]);
 
 	tun->ageing_time = TUN_FLOW_EXPIRE;
-	setup_timer(&tun->flow_gc_timer, tun_flow_cleanup, (unsigned long)tun);
+	timer_setup(&tun->flow_gc_timer, tun_flow_cleanup, 0);
+	mod_timer(&tun->flow_gc_timer,
+		  round_jiffies_up(jiffies + tun->ageing_time));
 }
 
 static void tun_flow_uninit(struct tun_struct *tun)
* Unmerged path drivers/net/wan/hdlc_ppp.c
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/btcoex.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/btcoex.c
index 3559fb5b8fb0..03aae6bc1838 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/btcoex.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/btcoex.c
@@ -280,9 +280,9 @@ static void brcmf_btcoex_restore_part1(struct brcmf_btcoex_info *btci)
 /**
  * brcmf_btcoex_timerfunc() - BT coex timer callback
  */
-static void brcmf_btcoex_timerfunc(ulong data)
+static void brcmf_btcoex_timerfunc(struct timer_list *t)
 {
-	struct brcmf_btcoex_info *bt_local = (struct brcmf_btcoex_info *)data;
+	struct brcmf_btcoex_info *bt_local = from_timer(bt_local, t, timer);
 	brcmf_dbg(TRACE, "enter\n");
 
 	bt_local->timer_on = false;
@@ -380,7 +380,7 @@ int brcmf_btcoex_attach(struct brcmf_cfg80211_info *cfg)
 	/* Set up timer for BT  */
 	btci->timer_on = false;
 	btci->timeout = BRCMF_BTCOEX_OPPR_WIN_TIME;
-	setup_timer(&btci->timer, brcmf_btcoex_timerfunc, (ulong)btci);
+	timer_setup(&btci->timer, brcmf_btcoex_timerfunc, 0);
 	btci->cfg = cfg;
 	btci->saved_regs_part1 = false;
 	btci->saved_regs_part2 = false;
* Unmerged path drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
* Unmerged path drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
* Unmerged path drivers/net/wireless/hostap/hostap_ap.c
* Unmerged path drivers/net/wireless/hostap/hostap_hw.c
diff --git a/drivers/net/wireless/intel/iwlwifi/dvm/main.c b/drivers/net/wireless/intel/iwlwifi/dvm/main.c
index 2acd94da9efe..d11d72615de2 100644
--- a/drivers/net/wireless/intel/iwlwifi/dvm/main.c
+++ b/drivers/net/wireless/intel/iwlwifi/dvm/main.c
@@ -399,9 +399,9 @@ int iwl_send_statistics_request(struct iwl_priv *priv, u8 flags, bool clear)
  * was received.  We need to ensure we receive the statistics in order
  * to update the temperature used for calibrating the TXPOWER.
  */
-static void iwl_bg_statistics_periodic(unsigned long data)
+static void iwl_bg_statistics_periodic(struct timer_list *t)
 {
-	struct iwl_priv *priv = (struct iwl_priv *)data;
+	struct iwl_priv *priv = from_timer(priv, t, statistics_periodic);
 
 	if (test_bit(STATUS_EXIT_PENDING, &priv->status))
 		return;
@@ -556,9 +556,9 @@ static void iwl_continuous_event_trace(struct iwl_priv *priv)
  * this function is to perform continuous uCode event logging operation
  * if enabled
  */
-static void iwl_bg_ucode_trace(unsigned long data)
+static void iwl_bg_ucode_trace(struct timer_list *t)
 {
-	struct iwl_priv *priv = (struct iwl_priv *)data;
+	struct iwl_priv *priv = from_timer(priv, t, ucode_trace);
 
 	if (test_bit(STATUS_EXIT_PENDING, &priv->status))
 		return;
@@ -1085,11 +1085,9 @@ static void iwl_setup_deferred_work(struct iwl_priv *priv)
 	if (priv->lib->bt_params)
 		iwlagn_bt_setup_deferred_work(priv);
 
-	setup_timer(&priv->statistics_periodic, iwl_bg_statistics_periodic,
-		    (unsigned long)priv);
+	timer_setup(&priv->statistics_periodic, iwl_bg_statistics_periodic, 0);
 
-	setup_timer(&priv->ucode_trace, iwl_bg_ucode_trace,
-		    (unsigned long)priv);
+	timer_setup(&priv->ucode_trace, iwl_bg_ucode_trace, 0);
 }
 
 void iwl_cancel_deferred_work(struct iwl_priv *priv)
diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/tx.c b/drivers/net/wireless/intel/iwlwifi/pcie/tx.c
index 4704137a26e0..0c852e18be1a 100644
--- a/drivers/net/wireless/intel/iwlwifi/pcie/tx.c
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/tx.c
@@ -147,9 +147,9 @@ void iwl_pcie_free_dma_ptr(struct iwl_trans *trans, struct iwl_dma_ptr *ptr)
 	memset(ptr, 0, sizeof(*ptr));
 }
 
-static void iwl_pcie_txq_stuck_timer(unsigned long data)
+static void iwl_pcie_txq_stuck_timer(struct timer_list *t)
 {
-	struct iwl_txq *txq = (void *)data;
+	struct iwl_txq *txq = from_timer(txq, t, stuck_timer);
 	struct iwl_trans_pcie *trans_pcie = txq->trans_pcie;
 	struct iwl_trans *trans = iwl_trans_pcie_get_trans(trans_pcie);
 
@@ -495,8 +495,7 @@ int iwl_pcie_txq_alloc(struct iwl_trans *trans, struct iwl_txq *txq,
 	if (WARN_ON(txq->entries || txq->tfds))
 		return -EINVAL;
 
-	setup_timer(&txq->stuck_timer, iwl_pcie_txq_stuck_timer,
-		    (unsigned long)txq);
+	timer_setup(&txq->stuck_timer, iwl_pcie_txq_stuck_timer, 0);
 	txq->trans_pcie = trans_pcie;
 
 	txq->n_window = slots_num;
* Unmerged path drivers/net/wireless/orinoco/orinoco_usb.c
* Unmerged path drivers/net/wireless/quantenna/qtnfmac/core.c
diff --git a/drivers/net/wireless/ti/wlcore/main.c b/drivers/net/wireless/ti/wlcore/main.c
index 953111a502ee..98551a341868 100644
--- a/drivers/net/wireless/ti/wlcore/main.c
+++ b/drivers/net/wireless/ti/wlcore/main.c
@@ -219,9 +219,9 @@ out:
 	mutex_unlock(&wl->mutex);
 }
 
-static void wl1271_rx_streaming_timer(unsigned long data)
+static void wl1271_rx_streaming_timer(struct timer_list *t)
 {
-	struct wl12xx_vif *wlvif = (struct wl12xx_vif *)data;
+	struct wl12xx_vif *wlvif = from_timer(wlvif, t, rx_streaming_timer);
 	struct wl1271 *wl = wlvif->wl;
 	ieee80211_queue_work(wl->hw, &wlvif->rx_streaming_disable_work);
 }
@@ -2175,8 +2175,7 @@ static int wl12xx_init_vif_data(struct wl1271 *wl, struct ieee80211_vif *vif)
 			  wlcore_connection_loss_work);
 	INIT_LIST_HEAD(&wlvif->list);
 
-	setup_timer(&wlvif->rx_streaming_timer, wl1271_rx_streaming_timer,
-		    (unsigned long) wlvif);
+	timer_setup(&wlvif->rx_streaming_timer, wl1271_rx_streaming_timer, 0);
 	return 0;
 }
 
diff --git a/drivers/net/xen-netfront.c b/drivers/net/xen-netfront.c
index 71c4d892e9e3..e9e82311a649 100644
--- a/drivers/net/xen-netfront.c
+++ b/drivers/net/xen-netfront.c
@@ -235,9 +235,9 @@ static bool xennet_can_sg(struct net_device *dev)
 }
 
 
-static void rx_refill_timeout(unsigned long data)
+static void rx_refill_timeout(struct timer_list *t)
 {
-	struct netfront_queue *queue = (struct netfront_queue *)data;
+	struct netfront_queue *queue = from_timer(queue, t, rx_refill_timer);
 	napi_schedule(&queue->napi);
 }
 
@@ -1586,8 +1586,7 @@ static int xennet_init_queue(struct netfront_queue *queue)
 	spin_lock_init(&queue->tx_lock);
 	spin_lock_init(&queue->rx_lock);
 
-	setup_timer(&queue->rx_refill_timer, rx_refill_timeout,
-		    (unsigned long)queue);
+	timer_setup(&queue->rx_refill_timer, rx_refill_timeout, 0);
 
 	snprintf(queue->name, sizeof(queue->name), "%s-q%u",
 		 queue->info->netdev->name, queue->id);
* Unmerged path drivers/nfc/pn533.c
* Unmerged path drivers/nfc/st-nci/ndlc.c
diff --git a/drivers/ntb/test/ntb_pingpong.c b/drivers/ntb/test/ntb_pingpong.c
index 435861189d97..858f4bbeb289 100644
--- a/drivers/ntb/test/ntb_pingpong.c
+++ b/drivers/ntb/test/ntb_pingpong.c
@@ -104,9 +104,9 @@ struct pp_ctx {
 
 static struct dentry *pp_debugfs_dir;
 
-static void pp_ping(unsigned long ctx)
+static void pp_ping(struct timer_list *t)
 {
-	struct pp_ctx *pp = (void *)ctx;
+	struct pp_ctx *pp = from_timer(pp, t, db_timer);
 	unsigned long irqflags;
 	u64 db_bits, db_mask;
 	u32 spad_rd, spad_wr;
@@ -150,7 +150,7 @@ static void pp_link_event(void *ctx)
 
 	if (ntb_link_is_up(pp->ntb, NULL, NULL) == 1) {
 		dev_dbg(&pp->ntb->dev, "link is up\n");
-		pp_ping((unsigned long)pp);
+		pp_ping(&pp->db_timer);
 	} else {
 		dev_dbg(&pp->ntb->dev, "link is down\n");
 		del_timer(&pp->db_timer);
@@ -240,7 +240,7 @@ static int pp_probe(struct ntb_client *client,
 	pp->db_bits = 0;
 	atomic_set(&pp->count, 0);
 	spin_lock_init(&pp->db_lock);
-	setup_timer(&pp->db_timer, pp_ping, (unsigned long)pp);
+	timer_setup(&pp->db_timer, pp_ping, 0);
 	pp->db_delay = msecs_to_jiffies(delay_ms);
 
 	rc = ntb_set_ctx(ntb, pp, &pp_ops);
diff --git a/drivers/platform/x86/sony-laptop.c b/drivers/platform/x86/sony-laptop.c
index 2ac045f27f10..8f680265ef90 100644
--- a/drivers/platform/x86/sony-laptop.c
+++ b/drivers/platform/x86/sony-laptop.c
@@ -351,7 +351,7 @@ static int sony_laptop_input_keycode_map[] = {
 };
 
 /* release buttons after a short delay if pressed */
-static void do_sony_laptop_release_key(unsigned long unused)
+static void do_sony_laptop_release_key(struct timer_list *unused)
 {
 	struct sony_laptop_keypress kp;
 	unsigned long flags;
@@ -458,7 +458,7 @@ static int sony_laptop_setup_input(struct acpi_device *acpi_device)
 		goto err_dec_users;
 	}
 
-	setup_timer(&sony_laptop_input.release_key_timer,
+	timer_setup(&sony_laptop_input.release_key_timer,
 		    do_sony_laptop_release_key, 0);
 
 	/* input keys */
diff --git a/drivers/pps/clients/pps-ktimer.c b/drivers/pps/clients/pps-ktimer.c
index 436b4e4e71a1..04735649052a 100644
--- a/drivers/pps/clients/pps-ktimer.c
+++ b/drivers/pps/clients/pps-ktimer.c
@@ -39,7 +39,7 @@ static struct timer_list ktimer;
  * The kernel timer
  */
 
-static void pps_ktimer_event(unsigned long ptr)
+static void pps_ktimer_event(struct timer_list *unused)
 {
 	struct pps_event_time ts;
 
@@ -85,7 +85,7 @@ static int __init pps_ktimer_init(void)
 		return -ENOMEM;
 	}
 
-	setup_timer(&ktimer, pps_ktimer_event, 0);
+	timer_setup(&ktimer, pps_ktimer_event, 0);
 	mod_timer(&ktimer, jiffies + HZ);
 
 	dev_info(pps->dev, "ktimer PPS source registered\n");
diff --git a/drivers/rtc/rtc-dev.c b/drivers/rtc/rtc-dev.c
index d04939369251..c84733a00162 100644
--- a/drivers/rtc/rtc-dev.c
+++ b/drivers/rtc/rtc-dev.c
@@ -80,9 +80,9 @@ static void rtc_uie_task(struct work_struct *work)
 	if (num)
 		rtc_handle_legacy_irq(rtc, num, RTC_UF);
 }
-static void rtc_uie_timer(unsigned long data)
+static void rtc_uie_timer(struct timer_list *t)
 {
-	struct rtc_device *rtc = (struct rtc_device *)data;
+	struct rtc_device *rtc = from_timer(rtc, t, uie_timer);
 	unsigned long flags;
 
 	spin_lock_irqsave(&rtc->irq_lock, flags);
@@ -472,7 +472,7 @@ void rtc_dev_prepare(struct rtc_device *rtc)
 
 #ifdef CONFIG_RTC_INTF_DEV_UIE_EMUL
 	INIT_WORK(&rtc->uie_task, rtc_uie_task);
-	setup_timer(&rtc->uie_timer, rtc_uie_timer, (unsigned long)rtc);
+	timer_setup(&rtc->uie_timer, rtc_uie_timer, 0);
 #endif
 
 	cdev_init(&rtc->char_dev, &rtc_dev_fops);
* Unmerged path drivers/s390/block/dasd.c
* Unmerged path drivers/s390/net/fsm.c
* Unmerged path drivers/scsi/arcmsr/arcmsr_hba.c
* Unmerged path drivers/scsi/arm/fas216.c
* Unmerged path drivers/scsi/bfa/bfad.c
diff --git a/drivers/scsi/bfa/bfad_drv.h b/drivers/scsi/bfa/bfad_drv.h
index cfcfff48e8e1..4fe980a6441f 100644
--- a/drivers/scsi/bfa/bfad_drv.h
+++ b/drivers/scsi/bfa/bfad_drv.h
@@ -314,7 +314,7 @@ int		bfad_setup_intr(struct bfad_s *bfad);
 void		bfad_remove_intr(struct bfad_s *bfad);
 void		bfad_update_hal_cfg(struct bfa_iocfc_cfg_s *bfa_cfg);
 bfa_status_t	bfad_hal_mem_alloc(struct bfad_s *bfad);
-void		bfad_bfa_tmo(unsigned long data);
+void		bfad_bfa_tmo(struct timer_list *t);
 void		bfad_init_timer(struct bfad_s *bfad);
 int		bfad_pci_init(struct pci_dev *pdev, struct bfad_s *bfad);
 void		bfad_pci_uninit(struct pci_dev *pdev, struct bfad_s *bfad);
diff --git a/drivers/scsi/bnx2fc/bnx2fc_tgt.c b/drivers/scsi/bnx2fc/bnx2fc_tgt.c
index ac221deceec3..9a3bcb726a71 100644
--- a/drivers/scsi/bnx2fc/bnx2fc_tgt.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_tgt.c
@@ -14,8 +14,8 @@
  */
 
 #include "bnx2fc.h"
-static void bnx2fc_upld_timer(unsigned long data);
-static void bnx2fc_ofld_timer(unsigned long data);
+static void bnx2fc_upld_timer(struct timer_list *t);
+static void bnx2fc_ofld_timer(struct timer_list *t);
 static int bnx2fc_init_tgt(struct bnx2fc_rport *tgt,
 			   struct fcoe_port *port,
 			   struct fc_rport_priv *rdata);
@@ -27,10 +27,10 @@ static void bnx2fc_free_session_resc(struct bnx2fc_hba *hba,
 			      struct bnx2fc_rport *tgt);
 static void bnx2fc_free_conn_id(struct bnx2fc_hba *hba, u32 conn_id);
 
-static void bnx2fc_upld_timer(unsigned long data)
+static void bnx2fc_upld_timer(struct timer_list *t)
 {
 
-	struct bnx2fc_rport *tgt = (struct bnx2fc_rport *)data;
+	struct bnx2fc_rport *tgt = from_timer(tgt, t, upld_timer);
 
 	BNX2FC_TGT_DBG(tgt, "upld_timer - Upload compl not received!!\n");
 	/* fake upload completion */
@@ -40,10 +40,10 @@ static void bnx2fc_upld_timer(unsigned long data)
 	wake_up_interruptible(&tgt->upld_wait);
 }
 
-static void bnx2fc_ofld_timer(unsigned long data)
+static void bnx2fc_ofld_timer(struct timer_list *t)
 {
 
-	struct bnx2fc_rport *tgt = (struct bnx2fc_rport *)data;
+	struct bnx2fc_rport *tgt = from_timer(tgt, t, ofld_timer);
 
 	BNX2FC_TGT_DBG(tgt, "entered bnx2fc_ofld_timer\n");
 	/* NOTE: This function should never be called, as
@@ -65,7 +65,7 @@ static void bnx2fc_ofld_timer(unsigned long data)
 
 static void bnx2fc_ofld_wait(struct bnx2fc_rport *tgt)
 {
-	setup_timer(&tgt->ofld_timer, bnx2fc_ofld_timer, (unsigned long)tgt);
+	timer_setup(&tgt->ofld_timer, bnx2fc_ofld_timer, 0);
 	mod_timer(&tgt->ofld_timer, jiffies + BNX2FC_FW_TIMEOUT);
 
 	wait_event_interruptible(tgt->ofld_wait,
@@ -278,7 +278,7 @@ void bnx2fc_flush_active_ios(struct bnx2fc_rport *tgt)
 
 static void bnx2fc_upld_wait(struct bnx2fc_rport *tgt)
 {
-	setup_timer(&tgt->upld_timer, bnx2fc_upld_timer, (unsigned long)tgt);
+	timer_setup(&tgt->upld_timer, bnx2fc_upld_timer, 0);
 	mod_timer(&tgt->upld_timer, jiffies + BNX2FC_FW_TIMEOUT);
 	wait_event_interruptible(tgt->upld_wait,
 				 (test_bit(
* Unmerged path drivers/scsi/esas2r/esas2r_main.c
diff --git a/drivers/scsi/fcoe/fcoe_ctlr.c b/drivers/scsi/fcoe/fcoe_ctlr.c
index f59704679807..5130adf1302e 100644
--- a/drivers/scsi/fcoe/fcoe_ctlr.c
+++ b/drivers/scsi/fcoe/fcoe_ctlr.c
@@ -49,7 +49,7 @@
 #define	FCOE_CTLR_MIN_FKA	500		/* min keep alive (mS) */
 #define	FCOE_CTLR_DEF_FKA	FIP_DEF_FKA	/* default keep alive (mS) */
 
-static void fcoe_ctlr_timeout(unsigned long);
+static void fcoe_ctlr_timeout(struct timer_list *);
 static void fcoe_ctlr_timer_work(struct work_struct *);
 static void fcoe_ctlr_recv_work(struct work_struct *);
 static int fcoe_ctlr_flogi_retry(struct fcoe_ctlr *);
@@ -153,7 +153,7 @@ void fcoe_ctlr_init(struct fcoe_ctlr *fip, enum fip_state mode)
 	mutex_init(&fip->ctlr_mutex);
 	spin_lock_init(&fip->ctlr_lock);
 	fip->flogi_oxid = FC_XID_UNKNOWN;
-	setup_timer(&fip->timer, fcoe_ctlr_timeout, (unsigned long)fip);
+	timer_setup(&fip->timer, fcoe_ctlr_timeout, 0);
 	INIT_WORK(&fip->timer_work, fcoe_ctlr_timer_work);
 	INIT_WORK(&fip->recv_work, fcoe_ctlr_recv_work);
 	skb_queue_head_init(&fip->fip_recv_list);
@@ -1746,9 +1746,9 @@ unlock:
  * fcoe_ctlr_timeout() - FIP timeout handler
  * @arg: The FCoE controller that timed out
  */
-static void fcoe_ctlr_timeout(unsigned long arg)
+static void fcoe_ctlr_timeout(struct timer_list *t)
 {
-	struct fcoe_ctlr *fip = (struct fcoe_ctlr *)arg;
+	struct fcoe_ctlr *fip = from_timer(fip, t, timer);
 
 	schedule_work(&fip->timer_work);
 }
diff --git a/drivers/scsi/fnic/fnic_main.c b/drivers/scsi/fnic/fnic_main.c
index 51a3742e7738..fa2c4c366ff1 100644
--- a/drivers/scsi/fnic/fnic_main.c
+++ b/drivers/scsi/fnic/fnic_main.c
@@ -408,18 +408,18 @@ static int fnic_notify_set(struct fnic *fnic)
 	return err;
 }
 
-static void fnic_notify_timer(unsigned long data)
+static void fnic_notify_timer(struct timer_list *t)
 {
-	struct fnic *fnic = (struct fnic *)data;
+	struct fnic *fnic = from_timer(fnic, t, notify_timer);
 
 	fnic_handle_link_event(fnic);
 	mod_timer(&fnic->notify_timer,
 		  round_jiffies(jiffies + FNIC_NOTIFY_TIMER_PERIOD));
 }
 
-static void fnic_fip_notify_timer(unsigned long data)
+static void fnic_fip_notify_timer(struct timer_list *t)
 {
-	struct fnic *fnic = (struct fnic *)data;
+	struct fnic *fnic = from_timer(fnic, t, fip_timer);
 
 	fnic_handle_fip_timer(fnic);
 }
@@ -785,8 +785,7 @@ static int fnic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		vnic_dev_add_addr(fnic->vdev, fnic->ctlr.ctl_src_addr);
 		fnic->set_vlan = fnic_set_vlan;
 		fcoe_ctlr_init(&fnic->ctlr, FIP_MODE_AUTO);
-		setup_timer(&fnic->fip_timer, fnic_fip_notify_timer,
-							(unsigned long)fnic);
+		timer_setup(&fnic->fip_timer, fnic_fip_notify_timer, 0);
 		spin_lock_init(&fnic->vlans_lock);
 		INIT_WORK(&fnic->fip_frame_work, fnic_handle_fip_frame);
 		INIT_WORK(&fnic->event_work, fnic_handle_event);
@@ -816,8 +815,7 @@ static int fnic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	/* Setup notify timer when using MSI interrupts */
 	if (vnic_dev_get_intr_mode(fnic->vdev) == VNIC_DEV_INTR_MODE_MSI)
-		setup_timer(&fnic->notify_timer,
-			    fnic_notify_timer, (unsigned long)fnic);
+		timer_setup(&fnic->notify_timer, fnic_notify_timer, 0);
 
 	/* allocate RQ buffers and post them to RQ*/
 	for (i = 0; i < fnic->rq_count; i++) {
* Unmerged path drivers/scsi/ncr53c8xx.c
* Unmerged path drivers/staging/et131x/et131x.c
* Unmerged path drivers/staging/greybus/operation.c
* Unmerged path drivers/staging/lustre/lnet/lnet/net_fault.c
* Unmerged path drivers/staging/lustre/lustre/ptlrpc/service.c
* Unmerged path drivers/staging/media/imx/imx-ic-prpencvf.c
* Unmerged path drivers/staging/media/imx/imx-media-csi.c
* Unmerged path drivers/staging/most/hdm-usb/hdm_usb.c
* Unmerged path drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
* Unmerged path drivers/staging/rtl8712/recv_linux.c
* Unmerged path drivers/staging/rtl8712/rtl8712_led.c
* Unmerged path drivers/staging/unisys/visorbus/visorbus_main.c
* Unmerged path drivers/staging/unisys/visornic/visornic_main.c
* Unmerged path drivers/staging/wilc1000/wilc_wfi_cfgoperations.c
diff --git a/drivers/target/target_core_user.c b/drivers/target/target_core_user.c
index 2ac4515b6a67..f809fd341da4 100644
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@ -896,9 +896,9 @@ static int tcmu_check_expired_cmd(int id, void *p, void *data)
 	return 0;
 }
 
-static void tcmu_device_timedout(unsigned long data)
+static void tcmu_device_timedout(struct timer_list *t)
 {
-	struct tcmu_dev *udev = (struct tcmu_dev *)data;
+	struct tcmu_dev *udev = from_timer(udev, t, timeout);
 	unsigned long flags;
 	int handled;
 
@@ -962,8 +962,7 @@ static struct se_device *tcmu_alloc_device(struct se_hba *hba, const char *name)
 	idr_init(&udev->commands);
 	spin_lock_init(&udev->commands_lock);
 
-	setup_timer(&udev->timeout, tcmu_device_timedout,
-		(unsigned long)udev);
+	timer_setup(&udev->timeout, tcmu_device_timedout, 0);
 
 	init_waitqueue_head(&udev->nl_cmd_wq);
 	spin_lock_init(&udev->nl_cmd_lock);
diff --git a/drivers/tty/ipwireless/hardware.c b/drivers/tty/ipwireless/hardware.c
index 2c14842541dd..a6fe2a98d37d 100644
--- a/drivers/tty/ipwireless/hardware.c
+++ b/drivers/tty/ipwireless/hardware.c
@@ -32,7 +32,7 @@ static void handle_received_SETUP_packet(struct ipw_hardware *ipw,
 					 unsigned int address,
 					 const unsigned char *data, int len,
 					 int is_last);
-static void ipwireless_setup_timer(unsigned long data);
+static void ipwireless_setup_timer(struct timer_list *t);
 static void handle_received_CTRL_packet(struct ipw_hardware *hw,
 		unsigned int channel_idx, const unsigned char *data, int len);
 
@@ -1629,8 +1629,7 @@ struct ipw_hardware *ipwireless_hardware_create(void)
 	spin_lock_init(&hw->lock);
 	tasklet_init(&hw->tasklet, ipwireless_do_tasklet, (unsigned long) hw);
 	INIT_WORK(&hw->work_rx, ipw_receive_data_work);
-	setup_timer(&hw->setup_timer, ipwireless_setup_timer,
-			(unsigned long) hw);
+	timer_setup(&hw->setup_timer, ipwireless_setup_timer, 0);
 
 	return hw;
 }
@@ -1664,12 +1663,12 @@ void ipwireless_init_hardware_v2_v3(struct ipw_hardware *hw)
 	hw->init_loops = 0;
 	printk(KERN_INFO IPWIRELESS_PCCARD_NAME
 	       ": waiting for card to start up...\n");
-	ipwireless_setup_timer((unsigned long) hw);
+	ipwireless_setup_timer(&hw->setup_timer);
 }
 
-static void ipwireless_setup_timer(unsigned long data)
+static void ipwireless_setup_timer(struct timer_list *t)
 {
-	struct ipw_hardware *hw = (struct ipw_hardware *) data;
+	struct ipw_hardware *hw = from_timer(hw, t, setup_timer);
 
 	hw->init_loops++;
 
* Unmerged path drivers/tty/n_gsm.c
diff --git a/drivers/tty/n_r3964.c b/drivers/tty/n_r3964.c
index f84b7c3fa6c0..6815606761d5 100644
--- a/drivers/tty/n_r3964.c
+++ b/drivers/tty/n_r3964.c
@@ -117,7 +117,7 @@ static void retry_transmit(struct r3964_info *pInfo);
 static void transmit_block(struct r3964_info *pInfo);
 static void receive_char(struct r3964_info *pInfo, const unsigned char c);
 static void receive_error(struct r3964_info *pInfo, const char flag);
-static void on_timeout(unsigned long priv);
+static void on_timeout(struct timer_list *t);
 static int enable_signals(struct r3964_info *pInfo, struct pid *pid, int arg);
 static int read_telegram(struct r3964_info *pInfo, struct pid *pid,
 		unsigned char __user * buf);
@@ -690,9 +690,9 @@ static void receive_error(struct r3964_info *pInfo, const char flag)
 	}
 }
 
-static void on_timeout(unsigned long priv)
+static void on_timeout(struct timer_list *t)
 {
-	struct r3964_info *pInfo = (void *)priv;
+	struct r3964_info *pInfo = from_timer(pInfo, t, tmr);
 
 	switch (pInfo->state) {
 	case R3964_TX_REQUEST:
@@ -995,7 +995,7 @@ static int r3964_open(struct tty_struct *tty)
 	tty->disc_data = pInfo;
 	tty->receive_room = 65536;
 
-	setup_timer(&pInfo->tmr, on_timeout, (unsigned long)pInfo);
+	timer_setup(&pInfo->tmr, on_timeout, 0);
 
 	return 0;
 }
diff --git a/drivers/tty/serial/crisv10.c b/drivers/tty/serial/crisv10.c
index 19e53959c788..13c2c6f080e4 100644
--- a/drivers/tty/serial/crisv10.c
+++ b/drivers/tty/serial/crisv10.c
@@ -2168,7 +2168,7 @@ static void flush_timeout_function(unsigned long data)
 static struct timer_list flush_timer;
 
 static void
-timed_flush_handler(unsigned long ptr)
+timed_flush_handler(struct timer_list *unused)
 {
 	struct e100_serial *info;
 	int i;
@@ -4338,7 +4338,7 @@ static int __init rs_init(void)
 	/* Setup the timed flush handler system */
 
 #if !defined(CONFIG_ETRAX_SERIAL_FAST_TIMER)
-	setup_timer(&flush_timer, timed_flush_handler, 0);
+	timer_setup(&flush_timer, timed_flush_handler, 0);
 	mod_timer(&flush_timer, jiffies + 5);
 #endif
 
* Unmerged path drivers/tty/serial/fsl_lpuart.c
* Unmerged path drivers/tty/serial/ifx6x60.c
* Unmerged path drivers/tty/serial/imx.c
* Unmerged path drivers/tty/serial/kgdb_nmi.c
* Unmerged path drivers/tty/serial/max3100.c
* Unmerged path drivers/tty/serial/mux.c
* Unmerged path drivers/tty/serial/pnx8xxx_uart.c
* Unmerged path drivers/tty/serial/sa1100.c
* Unmerged path drivers/tty/serial/sh-sci.c
* Unmerged path drivers/tty/serial/sn_console.c
diff --git a/drivers/tty/synclink.c b/drivers/tty/synclink.c
index ccdb675dc166..1cace95f80b0 100644
--- a/drivers/tty/synclink.c
+++ b/drivers/tty/synclink.c
@@ -701,7 +701,7 @@ static void usc_enable_async_clock( struct mgsl_struct *info, u32 DataRate );
 
 static void usc_loopback_frame( struct mgsl_struct *info );
 
-static void mgsl_tx_timeout(unsigned long context);
+static void mgsl_tx_timeout(struct timer_list *t);
 
 
 static void usc_loopmode_cancel_transmit( struct mgsl_struct * info );
@@ -1770,7 +1770,7 @@ static int startup(struct mgsl_struct * info)
 	
 	memset(&info->icount, 0, sizeof(info->icount));
 
-	setup_timer(&info->tx_timer, mgsl_tx_timeout, (unsigned long)info);
+	timer_setup(&info->tx_timer, mgsl_tx_timeout, 0);
 	
 	/* Allocate and claim adapter resources */
 	retval = mgsl_claim_resources(info);
@@ -7533,9 +7533,9 @@ static void mgsl_trace_block(struct mgsl_struct *info,const char* data, int coun
  * Arguments:	context		pointer to device instance data
  * Return Value:	None
  */
-static void mgsl_tx_timeout(unsigned long context)
+static void mgsl_tx_timeout(struct timer_list *t)
 {
-	struct mgsl_struct *info = (struct mgsl_struct*)context;
+	struct mgsl_struct *info = from_timer(info, t, tx_timer);
 	unsigned long flags;
 	
 	if ( debug_level >= DEBUG_LEVEL_INFO )
diff --git a/drivers/tty/synclink_gt.c b/drivers/tty/synclink_gt.c
index 718a1a333de7..8fff369890ae 100644
--- a/drivers/tty/synclink_gt.c
+++ b/drivers/tty/synclink_gt.c
@@ -494,8 +494,8 @@ static void free_bufs(struct slgt_info *info, struct slgt_desc *bufs, int count)
 static int  alloc_tmp_rbuf(struct slgt_info *info);
 static void free_tmp_rbuf(struct slgt_info *info);
 
-static void tx_timeout(unsigned long context);
-static void rx_timeout(unsigned long context);
+static void tx_timeout(struct timer_list *t);
+static void rx_timeout(struct timer_list *t);
 
 /*
  * ioctl handlers
@@ -3608,8 +3608,8 @@ static struct slgt_info *alloc_dev(int adapter_num, int port_num, struct pci_dev
 		info->adapter_num = adapter_num;
 		info->port_num = port_num;
 
-		setup_timer(&info->tx_timer, tx_timeout, (unsigned long)info);
-		setup_timer(&info->rx_timer, rx_timeout, (unsigned long)info);
+		timer_setup(&info->tx_timer, tx_timeout, 0);
+		timer_setup(&info->rx_timer, rx_timeout, 0);
 
 		/* Copy configuration info to device instance data */
 		info->pdev = pdev;
@@ -5122,9 +5122,9 @@ static int adapter_test(struct slgt_info *info)
 /*
  * transmit timeout handler
  */
-static void tx_timeout(unsigned long context)
+static void tx_timeout(struct timer_list *t)
 {
-	struct slgt_info *info = (struct slgt_info*)context;
+	struct slgt_info *info = from_timer(info, t, tx_timer);
 	unsigned long flags;
 
 	DBGINFO(("%s tx_timeout\n", info->device_name));
@@ -5146,9 +5146,9 @@ static void tx_timeout(unsigned long context)
 /*
  * receive buffer polling timer
  */
-static void rx_timeout(unsigned long context)
+static void rx_timeout(struct timer_list *t)
 {
-	struct slgt_info *info = (struct slgt_info*)context;
+	struct slgt_info *info = from_timer(info, t, rx_timer);
 	unsigned long flags;
 
 	DBGINFO(("%s rx_timeout\n", info->device_name));
diff --git a/drivers/tty/synclinkmp.c b/drivers/tty/synclinkmp.c
index 8ae81aa5950b..08c753cd1dbd 100644
--- a/drivers/tty/synclinkmp.c
+++ b/drivers/tty/synclinkmp.c
@@ -615,8 +615,8 @@ static void free_tmp_rx_buf(SLMP_INFO *info);
 
 static void load_pci_memory(SLMP_INFO *info, char* dest, const char* src, unsigned short count);
 static void trace_block(SLMP_INFO *info, const char* data, int count, int xmit);
-static void tx_timeout(unsigned long context);
-static void status_timeout(unsigned long context);
+static void tx_timeout(struct timer_list *t);
+static void status_timeout(struct timer_list *t);
 
 static unsigned char read_reg(SLMP_INFO *info, unsigned char addr);
 static void write_reg(SLMP_INFO *info, unsigned char addr, unsigned char val);
@@ -3789,9 +3789,8 @@ static SLMP_INFO *alloc_dev(int adapter_num, int port_num, struct pci_dev *pdev)
 		info->bus_type = MGSL_BUS_TYPE_PCI;
 		info->irq_flags = IRQF_SHARED;
 
-		setup_timer(&info->tx_timer, tx_timeout, (unsigned long)info);
-		setup_timer(&info->status_timer, status_timeout,
-				(unsigned long)info);
+		timer_setup(&info->tx_timer, tx_timeout, 0);
+		timer_setup(&info->status_timer, status_timeout, 0);
 
 		/* Store the PCI9050 misc control register value because a flaw
 		 * in the PCI9050 prevents LCR registers from being read if
@@ -5463,9 +5462,9 @@ static void trace_block(SLMP_INFO *info,const char* data, int count, int xmit)
 /* called when HDLC frame times out
  * update stats and do tx completion processing
  */
-static void tx_timeout(unsigned long context)
+static void tx_timeout(struct timer_list *t)
 {
-	SLMP_INFO *info = (SLMP_INFO*)context;
+	SLMP_INFO *info = from_timer(info, t, tx_timer);
 	unsigned long flags;
 
 	if ( debug_level >= DEBUG_LEVEL_INFO )
@@ -5490,10 +5489,10 @@ static void tx_timeout(unsigned long context)
 
 /* called to periodically check the DSR/RI modem signal input status
  */
-static void status_timeout(unsigned long context)
+static void status_timeout(struct timer_list *t)
 {
 	u16 status = 0;
-	SLMP_INFO *info = (SLMP_INFO*)context;
+	SLMP_INFO *info = from_timer(info, t, status_timer);
 	unsigned long flags;
 	unsigned char delta;
 
* Unmerged path drivers/usb/core/hcd.c
* Unmerged path drivers/usb/dwc2/hcd.c
* Unmerged path drivers/usb/dwc2/hcd_queue.c
diff --git a/drivers/usb/gadget/at91_udc.c b/drivers/usb/gadget/at91_udc.c
index a9c7eba085f3..439dbbad5ea4 100644
--- a/drivers/usb/gadget/at91_udc.c
+++ b/drivers/usb/gadget/at91_udc.c
@@ -1611,9 +1611,9 @@ static void at91_vbus_timer_work(struct work_struct *work)
 		mod_timer(&udc->vbus_timer, jiffies + VBUS_POLL_TIMEOUT);
 }
 
-static void at91_vbus_timer(unsigned long data)
+static void at91_vbus_timer(struct timer_list *t)
 {
-	struct at91_udc *udc = (struct at91_udc *)data;
+	struct at91_udc *udc = from_timer(udc, t, vbus_timer);
 
 	/*
 	 * If we are polling vbus it is likely that the gpio is on an
@@ -1813,8 +1813,7 @@ static int at91udc_probe(struct platform_device *pdev)
 
 		if (udc->board.vbus_polled) {
 			INIT_WORK(&udc->vbus_timer_work, at91_vbus_timer_work);
-			setup_timer(&udc->vbus_timer, at91_vbus_timer,
-				    (unsigned long)udc);
+			timer_setup(&udc->vbus_timer, at91_vbus_timer, 0);
 			mod_timer(&udc->vbus_timer,
 				  jiffies + VBUS_POLL_TIMEOUT);
 		} else {
* Unmerged path drivers/usb/gadget/dummy_hcd.c
* Unmerged path drivers/usb/gadget/m66592-udc.c
* Unmerged path drivers/usb/gadget/omap_udc.c
* Unmerged path drivers/usb/gadget/pxa25x_udc.c
* Unmerged path drivers/usb/gadget/r8a66597-udc.c
* Unmerged path drivers/usb/host/ohci-hcd.c
* Unmerged path drivers/usb/host/oxu210hp-hcd.c
* Unmerged path drivers/usb/host/r8a66597-hcd.c
* Unmerged path drivers/usb/host/sl811-hcd.c
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 0fc5b1795e80..e06d863c90ba 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -584,8 +584,7 @@ static int uhci_start(struct usb_hcd *hcd)
 		hcd->self.sg_tablesize = ~0;
 
 	spin_lock_init(&uhci->lock);
-	setup_timer(&uhci->fsbr_timer, uhci_fsbr_timeout,
-			(unsigned long) uhci);
+	timer_setup(&uhci->fsbr_timer, uhci_fsbr_timeout, 0);
 	INIT_LIST_HEAD(&uhci->idle_qh_list);
 	init_waitqueue_head(&uhci->waitqh);
 
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index c17ea1589b83..807edf7f5e97 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -89,9 +89,9 @@ static void uhci_urbp_wants_fsbr(struct uhci_hcd *uhci, struct urb_priv *urbp)
 	}
 }
 
-static void uhci_fsbr_timeout(unsigned long _uhci)
+static void uhci_fsbr_timeout(struct timer_list *t)
 {
-	struct uhci_hcd *uhci = (struct uhci_hcd *) _uhci;
+	struct uhci_hcd *uhci = from_timer(uhci, t, fsbr_timer);
 	unsigned long flags;
 
 	spin_lock_irqsave(&uhci->lock, flags);
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 001be9b6f893..b57aa851959d 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -447,14 +447,14 @@ static inline void xhci_msix_sync_irqs(struct xhci_hcd *xhci)
 
 #endif
 
-static void compliance_mode_recovery(unsigned long arg)
+static void compliance_mode_recovery(struct timer_list *t)
 {
 	struct xhci_hcd *xhci;
 	struct usb_hcd *hcd;
 	u32 temp;
 	int i;
 
-	xhci = (struct xhci_hcd *)arg;
+	xhci = from_timer(xhci, t, comp_mode_recovery_timer);
 
 	for (i = 0; i < xhci->num_usb3_ports; i++) {
 		temp = readl(xhci->usb3_ports[i]);
@@ -495,8 +495,8 @@ static void compliance_mode_recovery(unsigned long arg)
 static void compliance_mode_recovery_timer_init(struct xhci_hcd *xhci)
 {
 	xhci->port_status_u0 = 0;
-	setup_timer(&xhci->comp_mode_recovery_timer,
-		    compliance_mode_recovery, (unsigned long)xhci);
+	timer_setup(&xhci->comp_mode_recovery_timer, compliance_mode_recovery,
+		    0);
 	xhci->comp_mode_recovery_timer.expires = jiffies +
 			msecs_to_jiffies(COMP_MODE_RCVRY_MSECS);
 
diff --git a/drivers/usb/serial/mos7840.c b/drivers/usb/serial/mos7840.c
index 57bf87d25bd3..8c2cccd1e6be 100644
--- a/drivers/usb/serial/mos7840.c
+++ b/drivers/usb/serial/mos7840.c
@@ -568,9 +568,9 @@ static void mos7840_set_led_sync(struct usb_serial_port *port, __u16 reg,
 			val, reg, NULL, 0, MOS_WDR_TIMEOUT);
 }
 
-static void mos7840_led_off(unsigned long arg)
+static void mos7840_led_off(struct timer_list *t)
 {
-	struct moschip_port *mcs = (struct moschip_port *) arg;
+	struct moschip_port *mcs = from_timer(mcs, t, led_timer1);
 
 	/* Turn off LED */
 	mos7840_set_led_async(mcs, 0x0300, MODEM_CONTROL_REGISTER);
@@ -578,9 +578,9 @@ static void mos7840_led_off(unsigned long arg)
 				jiffies + msecs_to_jiffies(LED_OFF_MS));
 }
 
-static void mos7840_led_flag_off(unsigned long arg)
+static void mos7840_led_flag_off(struct timer_list *t)
 {
-	struct moschip_port *mcs = (struct moschip_port *) arg;
+	struct moschip_port *mcs = from_timer(mcs, t, led_timer2);
 
 	clear_bit_unlock(MOS7840_FLAG_LED_BUSY, &mcs->flags);
 }
@@ -2301,12 +2301,11 @@ static int mos7840_port_probe(struct usb_serial_port *port)
 			goto error;
 		}
 
-		setup_timer(&mos7840_port->led_timer1, mos7840_led_off,
-			    (unsigned long)mos7840_port);
+		timer_setup(&mos7840_port->led_timer1, mos7840_led_off, 0);
 		mos7840_port->led_timer1.expires =
 			jiffies + msecs_to_jiffies(LED_ON_MS);
-		setup_timer(&mos7840_port->led_timer2, mos7840_led_flag_off,
-			    (unsigned long)mos7840_port);
+		timer_setup(&mos7840_port->led_timer2, mos7840_led_flag_off,
+			    0);
 		mos7840_port->led_timer2.expires =
 			jiffies + msecs_to_jiffies(LED_OFF_MS);
 
diff --git a/drivers/usb/storage/realtek_cr.c b/drivers/usb/storage/realtek_cr.c
index ec83b3b5efa9..1cb1ad222051 100644
--- a/drivers/usb/storage/realtek_cr.c
+++ b/drivers/usb/storage/realtek_cr.c
@@ -763,9 +763,9 @@ static void rts51x_modi_suspend_timer(struct rts51x_chip *chip)
 	mod_timer(&chip->rts51x_suspend_timer, chip->timer_expires);
 }
 
-static void rts51x_suspend_timer_fn(unsigned long data)
+static void rts51x_suspend_timer_fn(struct timer_list *t)
 {
-	struct rts51x_chip *chip = (struct rts51x_chip *)data;
+	struct rts51x_chip *chip = from_timer(chip, t, rts51x_suspend_timer);
 	struct us_data *us = chip->us;
 
 	switch (rts51x_get_stat(chip)) {
@@ -929,8 +929,7 @@ static int realtek_cr_autosuspend_setup(struct us_data *us)
 	us->proto_handler = rts51x_invoke_transport;
 
 	chip->timer_expires = 0;
-	setup_timer(&chip->rts51x_suspend_timer, rts51x_suspend_timer_fn,
-			(unsigned long)chip);
+	timer_setup(&chip->rts51x_suspend_timer, rts51x_suspend_timer_fn, 0);
 	fw5895_init(us);
 
 	/* enable autosuspend function of the usb device */
* Unmerged path drivers/uwb/drp.c
* Unmerged path drivers/uwb/neh.c
* Unmerged path drivers/uwb/rsv.c
diff --git a/drivers/uwb/uwb-internal.h b/drivers/uwb/uwb-internal.h
index 9a103b100f1e..ed5caed3755e 100644
--- a/drivers/uwb/uwb-internal.h
+++ b/drivers/uwb/uwb-internal.h
@@ -327,7 +327,7 @@ void uwb_rsv_put(struct uwb_rsv *rsv);
 bool uwb_rsv_has_two_drp_ies(struct uwb_rsv *rsv);
 void uwb_rsv_dump(char *text, struct uwb_rsv *rsv);
 int uwb_rsv_try_move(struct uwb_rsv *rsv, struct uwb_mas_bm *available);
-void uwb_rsv_backoff_win_timer(unsigned long arg);
+void uwb_rsv_backoff_win_timer(struct timer_list *t);
 void uwb_rsv_backoff_win_increment(struct uwb_rc *rc);
 int uwb_rsv_status(struct uwb_rsv *rsv);
 int uwb_rsv_companion_status(struct uwb_rsv *rsv);
* Unmerged path drivers/video/omap2/dss/dsi.c
* Unmerged path drivers/watchdog/at91sam9_wdt.c
diff --git a/drivers/watchdog/bcm47xx_wdt.c b/drivers/watchdog/bcm47xx_wdt.c
index 2c97fc06e37d..3036a0c342e7 100644
--- a/drivers/watchdog/bcm47xx_wdt.c
+++ b/drivers/watchdog/bcm47xx_wdt.c
@@ -97,9 +97,9 @@ static struct watchdog_ops bcm47xx_wdt_hard_ops = {
 	.set_timeout	= bcm47xx_wdt_hard_set_timeout,
 };
 
-static void bcm47xx_wdt_soft_timer_tick(unsigned long data)
+static void bcm47xx_wdt_soft_timer_tick(struct timer_list *t)
 {
-	struct bcm47xx_wdt *wdt = (struct bcm47xx_wdt *)data;
+	struct bcm47xx_wdt *wdt = from_timer(wdt, t, soft_timer);
 	u32 next_tick = min(wdt->wdd.timeout * 1000, wdt->max_timer_ms);
 
 	if (!atomic_dec_and_test(&wdt->soft_ticks)) {
@@ -124,7 +124,7 @@ static int bcm47xx_wdt_soft_start(struct watchdog_device *wdd)
 	struct bcm47xx_wdt *wdt = bcm47xx_wdt_get(wdd);
 
 	bcm47xx_wdt_soft_keepalive(wdd);
-	bcm47xx_wdt_soft_timer_tick((unsigned long)wdt);
+	bcm47xx_wdt_soft_timer_tick(&wdt->soft_timer);
 
 	return 0;
 }
@@ -191,8 +191,7 @@ static int bcm47xx_wdt_probe(struct platform_device *pdev)
 
 	if (soft) {
 		wdt->wdd.ops = &bcm47xx_wdt_soft_ops;
-		setup_timer(&wdt->soft_timer, bcm47xx_wdt_soft_timer_tick,
-			    (long unsigned int)wdt);
+		timer_setup(&wdt->soft_timer, bcm47xx_wdt_soft_timer_tick, 0);
 	} else {
 		wdt->wdd.ops = &bcm47xx_wdt_hard_ops;
 	}
diff --git a/drivers/watchdog/bcm63xx_wdt.c b/drivers/watchdog/bcm63xx_wdt.c
index b2b80d4ac818..137e607b3d6b 100644
--- a/drivers/watchdog/bcm63xx_wdt.c
+++ b/drivers/watchdog/bcm63xx_wdt.c
@@ -78,7 +78,7 @@ static void bcm63xx_wdt_isr(void *data)
 	die(PFX " fire", regs);
 }
 
-static void bcm63xx_timer_tick(unsigned long unused)
+static void bcm63xx_timer_tick(struct timer_list *unused)
 {
 	if (!atomic_dec_and_test(&bcm63xx_wdt_device.ticks)) {
 		bcm63xx_wdt_hw_start();
@@ -241,7 +241,7 @@ static int bcm63xx_wdt_probe(struct platform_device *pdev)
 	int ret;
 	struct resource *r;
 
-	setup_timer(&bcm63xx_wdt_device.timer, bcm63xx_timer_tick, 0L);
+	timer_setup(&bcm63xx_wdt_device.timer, bcm63xx_timer_tick, 0);
 
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!r) {
diff --git a/drivers/watchdog/cpu5wdt.c b/drivers/watchdog/cpu5wdt.c
index f270bb7bc456..2f51a5a1996a 100644
--- a/drivers/watchdog/cpu5wdt.c
+++ b/drivers/watchdog/cpu5wdt.c
@@ -70,7 +70,7 @@ static struct {
 
 /* generic helper functions */
 
-static void cpu5wdt_trigger(unsigned long unused)
+static void cpu5wdt_trigger(struct timer_list *unused)
 {
 	if (verbose > 2)
 		pr_debug("trigger at %i ticks\n", ticks);
@@ -225,7 +225,7 @@ static int cpu5wdt_init(void)
 
 	init_completion(&cpu5wdt_device.stop);
 	cpu5wdt_device.queue = 0;
-	setup_timer(&cpu5wdt_device.timer, cpu5wdt_trigger, 0);
+	timer_setup(&cpu5wdt_device.timer, cpu5wdt_trigger, 0);
 	cpu5wdt_device.default_ticks = ticks;
 
 	if (!request_region(port, CPU5WDT_EXTENT, PFX)) {
* Unmerged path drivers/watchdog/mpc8xxx_wdt.c
diff --git a/drivers/watchdog/mtx-1_wdt.c b/drivers/watchdog/mtx-1_wdt.c
index 14dab6ff87aa..75dd533dbd32 100644
--- a/drivers/watchdog/mtx-1_wdt.c
+++ b/drivers/watchdog/mtx-1_wdt.c
@@ -69,7 +69,7 @@ static struct {
 	unsigned int gstate;
 } mtx1_wdt_device;
 
-static void mtx1_wdt_trigger(unsigned long unused)
+static void mtx1_wdt_trigger(struct timer_list *unused)
 {
 	spin_lock(&mtx1_wdt_device.lock);
 	if (mtx1_wdt_device.running)
@@ -220,7 +220,7 @@ static int mtx1_wdt_probe(struct platform_device *pdev)
 	init_completion(&mtx1_wdt_device.stop);
 	mtx1_wdt_device.queue = 0;
 	clear_bit(0, &mtx1_wdt_device.inuse);
-	setup_timer(&mtx1_wdt_device.timer, mtx1_wdt_trigger, 0L);
+	timer_setup(&mtx1_wdt_device.timer, mtx1_wdt_trigger, 0);
 	mtx1_wdt_device.default_ticks = ticks;
 
 	ret = misc_register(&mtx1_wdt_misc);
diff --git a/drivers/watchdog/nuc900_wdt.c b/drivers/watchdog/nuc900_wdt.c
index 04c45a102992..ee09a3ee3c81 100644
--- a/drivers/watchdog/nuc900_wdt.c
+++ b/drivers/watchdog/nuc900_wdt.c
@@ -218,7 +218,7 @@ static ssize_t nuc900_wdt_write(struct file *file, const char __user *data,
 	return len;
 }
 
-static void nuc900_wdt_timer_ping(unsigned long data)
+static void nuc900_wdt_timer_ping(struct timer_list *unused)
 {
 	if (time_before(jiffies, nuc900_wdt->next_heartbeat)) {
 		nuc900_wdt_keepalive();
@@ -285,7 +285,7 @@ static int nuc900wdt_probe(struct platform_device *pdev)
 
 	clk_enable(nuc900_wdt->wdt_clock);
 
-	setup_timer(&nuc900_wdt->timer, nuc900_wdt_timer_ping, 0);
+	timer_setup(&nuc900_wdt->timer, nuc900_wdt_timer_ping, 0);
 
 	ret = misc_register(&nuc900wdt_miscdev);
 	if (ret) {
diff --git a/drivers/watchdog/pcwd.c b/drivers/watchdog/pcwd.c
index 58acd550bd68..e438e90e02bc 100644
--- a/drivers/watchdog/pcwd.c
+++ b/drivers/watchdog/pcwd.c
@@ -367,7 +367,7 @@ static void pcwd_show_card_info(void)
 		pr_info("No previous trip detected - Cold boot or reset\n");
 }
 
-static void pcwd_timer_ping(unsigned long data)
+static void pcwd_timer_ping(struct timer_list *unused)
 {
 	int wdrst_stat;
 
@@ -893,7 +893,7 @@ static int pcwd_isa_probe(struct device *dev, unsigned int id)
 	/* clear the "card caused reboot" flag */
 	pcwd_clear_status();
 
-	setup_timer(&pcwd_private.timer, pcwd_timer_ping, 0);
+	timer_setup(&pcwd_private.timer, pcwd_timer_ping, 0);
 
 	/*  Disable the board  */
 	pcwd_stop();
diff --git a/drivers/watchdog/pika_wdt.c b/drivers/watchdog/pika_wdt.c
index 329bc60ad7a2..3e0129a36862 100644
--- a/drivers/watchdog/pika_wdt.c
+++ b/drivers/watchdog/pika_wdt.c
@@ -85,7 +85,7 @@ static inline void pikawdt_reset(void)
 /*
  * Timer tick
  */
-static void pikawdt_ping(unsigned long data)
+static void pikawdt_ping(struct timer_list *unused)
 {
 	if (time_before(jiffies, pikawdt_private.next_heartbeat) ||
 			(!nowayout && !pikawdt_private.open)) {
@@ -269,7 +269,7 @@ static int __init pikawdt_init(void)
 
 	iounmap(fpga);
 
-	setup_timer(&pikawdt_private.timer, pikawdt_ping, 0);
+	timer_setup(&pikawdt_private.timer, pikawdt_ping, 0);
 
 	ret = misc_register(&pikawdt_miscdev);
 	if (ret) {
diff --git a/drivers/watchdog/rdc321x_wdt.c b/drivers/watchdog/rdc321x_wdt.c
index b0f116c2fd53..159f4a23644e 100644
--- a/drivers/watchdog/rdc321x_wdt.c
+++ b/drivers/watchdog/rdc321x_wdt.c
@@ -68,7 +68,7 @@ static struct {
 
 /* generic helper functions */
 
-static void rdc321x_wdt_trigger(unsigned long unused)
+static void rdc321x_wdt_trigger(struct timer_list *unused)
 {
 	unsigned long flags;
 	u32 val;
@@ -263,7 +263,7 @@ static int rdc321x_wdt_probe(struct platform_device *pdev)
 
 	clear_bit(0, &rdc321x_wdt_device.inuse);
 
-	setup_timer(&rdc321x_wdt_device.timer, rdc321x_wdt_trigger, 0);
+	timer_setup(&rdc321x_wdt_device.timer, rdc321x_wdt_trigger, 0);
 
 	rdc321x_wdt_device.default_ticks = ticks;
 
* Unmerged path drivers/watchdog/shwdt.c
* Unmerged path fs/ocfs2/cluster/tcp.c
* Unmerged path kernel/padata.c
* Unmerged path kernel/time/clocksource.c
diff --git a/net/802/garp.c b/net/802/garp.c
index 2dac647ff420..7f50d47470bd 100644
--- a/net/802/garp.c
+++ b/net/802/garp.c
@@ -401,9 +401,9 @@ static void garp_join_timer_arm(struct garp_applicant *app)
 	mod_timer(&app->join_timer, jiffies + delay);
 }
 
-static void garp_join_timer(unsigned long data)
+static void garp_join_timer(struct timer_list *t)
 {
-	struct garp_applicant *app = (struct garp_applicant *)data;
+	struct garp_applicant *app = from_timer(app, t, join_timer);
 
 	spin_lock(&app->lock);
 	garp_gid_event(app, GARP_EVENT_TRANSMIT_PDU);
@@ -584,7 +584,7 @@ int garp_init_applicant(struct net_device *dev, struct garp_application *appl)
 	spin_lock_init(&app->lock);
 	skb_queue_head_init(&app->queue);
 	rcu_assign_pointer(dev->garp_port->applicants[appl->type], app);
-	setup_timer(&app->join_timer, garp_join_timer, (unsigned long)app);
+	timer_setup(&app->join_timer, garp_join_timer, 0);
 	garp_join_timer_arm(app);
 	return 0;
 
* Unmerged path net/802/mrp.c
diff --git a/net/appletalk/aarp.c b/net/appletalk/aarp.c
index 964278dbc86f..c24881364642 100644
--- a/net/appletalk/aarp.c
+++ b/net/appletalk/aarp.c
@@ -309,7 +309,7 @@ static void __aarp_expire_device(struct aarp_entry **n, struct net_device *dev)
 }
 
 /* Handle the timer event */
-static void aarp_expire_timeout(unsigned long unused)
+static void aarp_expire_timeout(struct timer_list *unused)
 {
 	int ct;
 
@@ -883,7 +883,7 @@ void __init aarp_proto_init(void)
 	aarp_dl = register_snap_client(aarp_snap_id, aarp_rcv);
 	if (!aarp_dl)
 		printk(KERN_CRIT "Unable to register AARP with SNAP.\n");
-	setup_timer(&aarp_timer, aarp_expire_timeout, 0);
+	timer_setup(&aarp_timer, aarp_expire_timeout, 0);
 	aarp_timer.expires  = jiffies + sysctl_aarp_expiry_time;
 	add_timer(&aarp_timer);
 	register_netdevice_notifier_rh(&aarp_notifier);
diff --git a/net/appletalk/ddp.c b/net/appletalk/ddp.c
index d7c02df293b0..f6a5352b2c00 100644
--- a/net/appletalk/ddp.c
+++ b/net/appletalk/ddp.c
@@ -158,9 +158,9 @@ found:
 	return s;
 }
 
-static void atalk_destroy_timer(unsigned long data)
+static void atalk_destroy_timer(struct timer_list *t)
 {
-	struct sock *sk = (struct sock *)data;
+	struct sock *sk = from_timer(sk, t, sk_timer);
 
 	if (sk_has_allocations(sk)) {
 		sk->sk_timer.expires = jiffies + SOCK_DESTROY_TIME;
@@ -175,8 +175,7 @@ static inline void atalk_destroy_socket(struct sock *sk)
 	skb_queue_purge(&sk->sk_receive_queue);
 
 	if (sk_has_allocations(sk)) {
-		setup_timer(&sk->sk_timer, atalk_destroy_timer,
-				(unsigned long)sk);
+		timer_setup(&sk->sk_timer, atalk_destroy_timer, 0);
 		sk->sk_timer.expires	= jiffies + SOCK_DESTROY_TIME;
 		add_timer(&sk->sk_timer);
 	} else
* Unmerged path net/batman-adv/tp_meter.c
diff --git a/net/bluetooth/hidp/core.c b/net/bluetooth/hidp/core.c
index bb065657543d..0a64a30dee8e 100644
--- a/net/bluetooth/hidp/core.c
+++ b/net/bluetooth/hidp/core.c
@@ -397,9 +397,9 @@ static int hidp_raw_request(struct hid_device *hid, unsigned char reportnum,
 	}
 }
 
-static void hidp_idle_timeout(unsigned long arg)
+static void hidp_idle_timeout(struct timer_list *t)
 {
-	struct hidp_session *session = (struct hidp_session *) arg;
+	struct hidp_session *session = from_timer(session, t, timer);
 
 	/* The HIDP user-space API only contains calls to add and remove
 	 * devices. There is no way to forward events of any kind. Therefore,
@@ -943,8 +943,7 @@ static int hidp_session_new(struct hidp_session **out, const bdaddr_t *bdaddr,
 
 	/* device management */
 	INIT_WORK(&session->dev_init, hidp_session_dev_work);
-	setup_timer(&session->timer, hidp_idle_timeout,
-		    (unsigned long)session);
+	timer_setup(&session->timer, hidp_idle_timeout, 0);
 
 	/* session data */
 	mutex_init(&session->report_mutex);
diff --git a/net/bluetooth/rfcomm/core.c b/net/bluetooth/rfcomm/core.c
index d434e0dab83e..27e0b0d5025f 100644
--- a/net/bluetooth/rfcomm/core.c
+++ b/net/bluetooth/rfcomm/core.c
@@ -233,9 +233,9 @@ static int rfcomm_check_security(struct rfcomm_dlc *d)
 				 d->out);
 }
 
-static void rfcomm_session_timeout(unsigned long arg)
+static void rfcomm_session_timeout(struct timer_list *t)
 {
-	struct rfcomm_session *s = (void *) arg;
+	struct rfcomm_session *s = from_timer(s, t, timer);
 
 	BT_DBG("session %p state %ld", s, s->state);
 
@@ -258,9 +258,9 @@ static void rfcomm_session_clear_timer(struct rfcomm_session *s)
 }
 
 /* ---- RFCOMM DLCs ---- */
-static void rfcomm_dlc_timeout(unsigned long arg)
+static void rfcomm_dlc_timeout(struct timer_list *t)
 {
-	struct rfcomm_dlc *d = (void *) arg;
+	struct rfcomm_dlc *d = from_timer(d, t, timer);
 
 	BT_DBG("dlc %p state %ld", d, d->state);
 
@@ -307,7 +307,7 @@ struct rfcomm_dlc *rfcomm_dlc_alloc(gfp_t prio)
 	if (!d)
 		return NULL;
 
-	setup_timer(&d->timer, rfcomm_dlc_timeout, (unsigned long)d);
+	timer_setup(&d->timer, rfcomm_dlc_timeout, 0);
 
 	skb_queue_head_init(&d->tx_queue);
 	mutex_init(&d->lock);
@@ -650,7 +650,7 @@ static struct rfcomm_session *rfcomm_session_add(struct socket *sock, int state)
 
 	BT_DBG("session %p sock %p", s, sock);
 
-	setup_timer(&s->timer, rfcomm_session_timeout, (unsigned long) s);
+	timer_setup(&s->timer, rfcomm_session_timeout, 0);
 
 	INIT_LIST_HEAD(&s->dlcs);
 	s->state = state;
diff --git a/net/bluetooth/sco.c b/net/bluetooth/sco.c
index dd35197f2b40..67c4b64c1d5c 100644
--- a/net/bluetooth/sco.c
+++ b/net/bluetooth/sco.c
@@ -72,9 +72,9 @@ struct sco_pinfo {
 #define SCO_CONN_TIMEOUT	(HZ * 40)
 #define SCO_DISCONN_TIMEOUT	(HZ * 2)
 
-static void sco_sock_timeout(unsigned long arg)
+static void sco_sock_timeout(struct timer_list *t)
 {
-	struct sock *sk = (struct sock *)arg;
+	struct sock *sk = from_timer(sk, t, sk_timer);
 
 	BT_DBG("sock %p state %d", sk, sk->sk_state);
 
@@ -486,7 +486,7 @@ static struct sock *sco_sock_alloc(struct net *net, struct socket *sock,
 
 	sco_pi(sk)->setting = BT_VOICE_CVSD_16BIT;
 
-	setup_timer(&sk->sk_timer, sco_sock_timeout, (unsigned long)sk);
+	timer_setup(&sk->sk_timer, sco_sock_timeout, 0);
 
 	bt_sock_link(&sco_sk_list, sk);
 	return sk;
* Unmerged path net/core/drop_monitor.c
diff --git a/net/core/gen_estimator.c b/net/core/gen_estimator.c
index bca1d0651310..8ee5ae8f6220 100644
--- a/net/core/gen_estimator.c
+++ b/net/core/gen_estimator.c
@@ -76,9 +76,9 @@ static void est_fetch_counters(struct net_rate_estimator *e,
 
 }
 
-static void est_timer(unsigned long arg)
+static void est_timer(struct timer_list *t)
 {
-	struct net_rate_estimator *est = (struct net_rate_estimator *)arg;
+	struct net_rate_estimator *est = from_timer(est, t, timer);
 	struct gnet_stats_basic_packed b;
 	u64 rate, brate;
 
@@ -170,7 +170,7 @@ int gen_new_estimator(struct gnet_stats_basic_packed *bstats,
 	}
 
 	est->next_jiffies = jiffies + ((HZ/4) << intvl_log);
-	setup_timer(&est->timer, est_timer, (unsigned long)est);
+	timer_setup(&est->timer, est_timer, 0);
 	mod_timer(&est->timer, est->next_jiffies);
 
 	rcu_assign_pointer(*rate_est, est);
* Unmerged path net/core/neighbour.c
* Unmerged path net/decnet/dn_route.c
diff --git a/net/decnet/dn_timer.c b/net/decnet/dn_timer.c
index d9c150cc59a9..b8f48538daac 100644
--- a/net/decnet/dn_timer.c
+++ b/net/decnet/dn_timer.c
@@ -32,11 +32,11 @@
 
 #define SLOW_INTERVAL (HZ/2)
 
-static void dn_slow_timer(unsigned long arg);
+static void dn_slow_timer(struct timer_list *t);
 
 void dn_start_slow_timer(struct sock *sk)
 {
-	setup_timer(&sk->sk_timer, dn_slow_timer, (unsigned long)sk);
+	timer_setup(&sk->sk_timer, dn_slow_timer, 0);
 	sk_reset_timer(sk, &sk->sk_timer, jiffies + SLOW_INTERVAL);
 }
 
@@ -45,9 +45,9 @@ void dn_stop_slow_timer(struct sock *sk)
 	sk_stop_timer(sk, &sk->sk_timer);
 }
 
-static void dn_slow_timer(unsigned long arg)
+static void dn_slow_timer(struct timer_list *t)
 {
-	struct sock *sk = (struct sock *)arg;
+	struct sock *sk = from_timer(sk, t, sk_timer);
 	struct dn_scp *scp = DN_SK(sk);
 
 	bh_lock_sock(sk);
* Unmerged path net/ipv4/igmp.c
* Unmerged path net/ipv4/ipmr.c
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index 836f13f8d356..04b6221583c4 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -164,7 +164,7 @@ static void addrconf_dad_start(struct inet6_ifaddr *ifp);
 static void addrconf_dad_work(struct work_struct *w);
 static void addrconf_dad_completed(struct inet6_ifaddr *ifp, bool bump_id);
 static void addrconf_dad_run(struct inet6_dev *idev);
-static void addrconf_rs_timer(unsigned long data);
+static void addrconf_rs_timer(struct timer_list *t);
 static void __ipv6_ifa_notify(int event, struct inet6_ifaddr *ifa);
 static void ipv6_ifa_notify(int event, struct inet6_ifaddr *ifa);
 
@@ -325,8 +325,7 @@ static struct inet6_dev *ipv6_add_dev(struct net_device *dev)
 	rwlock_init(&ndev->lock);
 	ndev->dev = dev;
 	INIT_LIST_HEAD(&ndev->addr_list);
-	setup_timer(&ndev->rs_timer, addrconf_rs_timer,
-		    (unsigned long)ndev);
+	timer_setup(&ndev->rs_timer, addrconf_rs_timer, 0);
 	memcpy(&ndev->cnf, dev_net(dev)->ipv6.devconf_dflt, sizeof(ndev->cnf));
 
 	if (ndev->cnf.stable_secret.initialized)
@@ -3377,9 +3376,9 @@ static int addrconf_ifdown(struct net_device *dev, int how)
 	return 0;
 }
 
-static void addrconf_rs_timer(unsigned long data)
+static void addrconf_rs_timer(struct timer_list *t)
 {
-	struct inet6_dev *idev = (struct inet6_dev *)data;
+	struct inet6_dev *idev = from_timer(idev, t, rs_timer);
 	struct net_device *dev = idev->dev;
 	struct in6_addr lladdr;
 
diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c
index 603e87303139..8931659d2169 100644
--- a/net/ipv6/ip6mr.c
+++ b/net/ipv6/ip6mr.c
@@ -119,7 +119,7 @@ static void mr6_netlink_event(struct mr6_table *mrt, struct mfc6_cache *mfc,
 static int ip6mr_rtm_dumproute(struct sk_buff *skb,
 			       struct netlink_callback *cb);
 static void mroute_clean_tables(struct mr6_table *mrt, bool all);
-static void ipmr_expire_process(unsigned long arg);
+static void ipmr_expire_process(struct timer_list *t);
 
 #ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES
 #define ip6mr_for_each_table(mrt, net) \
@@ -319,8 +319,7 @@ static struct mr6_table *ip6mr_new_table(struct net *net, u32 id)
 
 	INIT_LIST_HEAD(&mrt->mfc6_unres_queue);
 
-	setup_timer(&mrt->ipmr_expire_timer, ipmr_expire_process,
-		    (unsigned long)mrt);
+	timer_setup(&mrt->ipmr_expire_timer, ipmr_expire_process, 0);
 
 #ifdef CONFIG_IPV6_PIMSM_V2
 	mrt->mroute_reg_vif_num = -1;
@@ -891,9 +890,9 @@ static void ipmr_do_expire_process(struct mr6_table *mrt)
 		mod_timer(&mrt->ipmr_expire_timer, jiffies + expires);
 }
 
-static void ipmr_expire_process(unsigned long arg)
+static void ipmr_expire_process(struct timer_list *t)
 {
-	struct mr6_table *mrt = (struct mr6_table *)arg;
+	struct mr6_table *mrt = from_timer(mrt, t, ipmr_expire_timer);
 
 	if (!spin_trylock(&mfc_unres_lock)) {
 		mod_timer(&mrt->ipmr_expire_timer, jiffies + 1);
* Unmerged path net/ipv6/mcast.c
* Unmerged path net/ncsi/ncsi-manage.c
diff --git a/net/netfilter/nf_conntrack_expect.c b/net/netfilter/nf_conntrack_expect.c
index 67742f6523b4..d71f74b452be 100644
--- a/net/netfilter/nf_conntrack_expect.c
+++ b/net/netfilter/nf_conntrack_expect.c
@@ -62,9 +62,9 @@ void nf_ct_unlink_expect_report(struct nf_conntrack_expect *exp,
 }
 EXPORT_SYMBOL_GPL(nf_ct_unlink_expect_report);
 
-static void nf_ct_expectation_timed_out(unsigned long ul_expect)
+static void nf_ct_expectation_timed_out(struct timer_list *t)
 {
-	struct nf_conntrack_expect *exp = (void *)ul_expect;
+	struct nf_conntrack_expect *exp = from_timer(exp, t, timeout);
 
 	spin_lock_bh(&nf_conntrack_expect_lock);
 	nf_ct_unlink_expect(exp);
@@ -353,8 +353,7 @@ static int nf_ct_expect_insert(struct nf_conntrack_expect *exp)
 	hlist_add_head_rcu(&exp->hnode, &net->ct.expect_hash[h]);
 	net->ct.expect_count++;
 
-	setup_timer(&exp->timeout, nf_ct_expectation_timed_out,
-		    (unsigned long)exp);
+	timer_setup(&exp->timeout, nf_ct_expectation_timed_out, 0);
 	helper = rcu_dereference_protected(master_help->helper,
 					   lockdep_is_held(&nf_conntrack_expect_lock));
 	if (helper) {
diff --git a/net/netfilter/nfnetlink_log.c b/net/netfilter/nfnetlink_log.c
index 3a3478438bf1..25d873ca2be7 100644
--- a/net/netfilter/nfnetlink_log.c
+++ b/net/netfilter/nfnetlink_log.c
@@ -144,7 +144,7 @@ instance_put(struct nfulnl_instance *inst)
 		call_rcu_bh(&inst->rcu, nfulnl_instance_free_rcu);
 }
 
-static void nfulnl_timer(unsigned long data);
+static void nfulnl_timer(struct timer_list *t);
 
 static struct nfulnl_instance *
 instance_create(struct net *net, u_int16_t group_num,
@@ -177,7 +177,7 @@ instance_create(struct net *net, u_int16_t group_num,
 	/* needs to be two, since we _put() after creation */
 	atomic_set(&inst->use, 2);
 
-	setup_timer(&inst->timer, nfulnl_timer, (unsigned long)inst);
+	timer_setup(&inst->timer, nfulnl_timer, 0);
 
 	inst->net = get_net(net);
 	inst->peer_user_ns = user_ns;
@@ -375,9 +375,9 @@ __nfulnl_flush(struct nfulnl_instance *inst)
 }
 
 static void
-nfulnl_timer(unsigned long data)
+nfulnl_timer(struct timer_list *t)
 {
-	struct nfulnl_instance *inst = (struct nfulnl_instance *)data;
+	struct nfulnl_instance *inst = from_timer(inst, t, timer);
 
 	spin_lock_bh(&inst->lock);
 	if (inst->skb)
diff --git a/net/netfilter/xt_IDLETIMER.c b/net/netfilter/xt_IDLETIMER.c
index f407ebc13481..92a045e7f9b2 100644
--- a/net/netfilter/xt_IDLETIMER.c
+++ b/net/netfilter/xt_IDLETIMER.c
@@ -107,9 +107,9 @@ static void idletimer_tg_work(struct work_struct *work)
 	sysfs_notify(idletimer_tg_kobj, NULL, timer->attr.attr.name);
 }
 
-static void idletimer_tg_expired(unsigned long data)
+static void idletimer_tg_expired(struct timer_list *t)
 {
-	struct idletimer_tg *timer = (struct idletimer_tg *) data;
+	struct idletimer_tg *timer = from_timer(timer, t, timer);
 
 	pr_debug("timer %s expired\n", timer->attr.attr.name);
 
@@ -142,8 +142,7 @@ static int idletimer_tg_create(struct idletimer_tg_info *info)
 
 	list_add(&info->timer->entry, &idletimer_tg_list);
 
-	setup_timer(&info->timer->timer, idletimer_tg_expired,
-		    (unsigned long) info->timer);
+	timer_setup(&info->timer->timer, idletimer_tg_expired, 0);
 	info->timer->refcnt = 1;
 
 	mod_timer(&info->timer->timer,
diff --git a/net/netfilter/xt_LED.c b/net/netfilter/xt_LED.c
index 993de2ba89d3..fe7af097b7b4 100644
--- a/net/netfilter/xt_LED.c
+++ b/net/netfilter/xt_LED.c
@@ -81,9 +81,10 @@ led_tg(struct sk_buff *skb, const struct xt_action_param *par)
 	return XT_CONTINUE;
 }
 
-static void led_timeout_callback(unsigned long data)
+static void led_timeout_callback(struct timer_list *t)
 {
-	struct xt_led_info_internal *ledinternal = (struct xt_led_info_internal *)data;
+	struct xt_led_info_internal *ledinternal = from_timer(ledinternal, t,
+							      timer);
 
 	led_trigger_event(&ledinternal->netfilter_led_trigger, LED_OFF);
 }
@@ -141,8 +142,7 @@ static int led_tg_check(const struct xt_tgchk_param *par)
 
 	/* See if we need to set up a timer */
 	if (ledinfo->delay > 0)
-		setup_timer(&ledinternal->timer, led_timeout_callback,
-			    (unsigned long)ledinternal);
+		timer_setup(&ledinternal->timer, led_timeout_callback, 0);
 
 	list_add_tail(&ledinternal->list, &xt_led_triggers);
 
diff --git a/net/nfc/nci/core.c b/net/nfc/nci/core.c
index 48ada0ec749e..1c0e4cbba851 100644
--- a/net/nfc/nci/core.c
+++ b/net/nfc/nci/core.c
@@ -378,18 +378,18 @@ static int nci_close_device(struct nci_dev *ndev)
 }
 
 /* NCI command timer function */
-static void nci_cmd_timer(unsigned long arg)
+static void nci_cmd_timer(struct timer_list *t)
 {
-	struct nci_dev *ndev = (void *) arg;
+	struct nci_dev *ndev = from_timer(ndev, t, cmd_timer);
 
 	atomic_set(&ndev->cmd_cnt, 1);
 	queue_work(ndev->cmd_wq, &ndev->cmd_work);
 }
 
 /* NCI data exchange timer function */
-static void nci_data_timer(unsigned long arg)
+static void nci_data_timer(struct timer_list *t)
 {
-	struct nci_dev *ndev = (void *) arg;
+	struct nci_dev *ndev = from_timer(ndev, t, data_timer);
 
 	set_bit(NCI_DATA_EXCHANGE_TO, &ndev->flags);
 	queue_work(ndev->rx_wq, &ndev->rx_work);
@@ -754,10 +754,8 @@ int nci_register_device(struct nci_dev *ndev)
 	skb_queue_head_init(&ndev->rx_q);
 	skb_queue_head_init(&ndev->tx_q);
 
-	setup_timer(&ndev->cmd_timer, nci_cmd_timer,
-		    (unsigned long) ndev);
-	setup_timer(&ndev->data_timer, nci_data_timer,
-		    (unsigned long) ndev);
+	timer_setup(&ndev->cmd_timer, nci_cmd_timer, 0);
+	timer_setup(&ndev->data_timer, nci_data_timer, 0);
 
 	mutex_init(&ndev->req_lock);
 
* Unmerged path net/rxrpc/call_object.c
diff --git a/net/wireless/lib80211.c b/net/wireless/lib80211.c
index 459611577d3d..801d4781a73b 100644
--- a/net/wireless/lib80211.c
+++ b/net/wireless/lib80211.c
@@ -44,7 +44,7 @@ static DEFINE_SPINLOCK(lib80211_crypto_lock);
 static void lib80211_crypt_deinit_entries(struct lib80211_crypt_info *info,
 					  int force);
 static void lib80211_crypt_quiescing(struct lib80211_crypt_info *info);
-static void lib80211_crypt_deinit_handler(unsigned long data);
+static void lib80211_crypt_deinit_handler(struct timer_list *t);
 
 int lib80211_crypt_info_init(struct lib80211_crypt_info *info, char *name,
 				spinlock_t *lock)
@@ -55,8 +55,8 @@ int lib80211_crypt_info_init(struct lib80211_crypt_info *info, char *name,
 	info->lock = lock;
 
 	INIT_LIST_HEAD(&info->crypt_deinit_list);
-	setup_timer(&info->crypt_deinit_timer, lib80211_crypt_deinit_handler,
-			(unsigned long)info);
+	timer_setup(&info->crypt_deinit_timer, lib80211_crypt_deinit_handler,
+		    0);
 
 	return 0;
 }
@@ -116,9 +116,10 @@ static void lib80211_crypt_quiescing(struct lib80211_crypt_info *info)
 	spin_unlock_irqrestore(info->lock, flags);
 }
 
-static void lib80211_crypt_deinit_handler(unsigned long data)
+static void lib80211_crypt_deinit_handler(struct timer_list *t)
 {
-	struct lib80211_crypt_info *info = (struct lib80211_crypt_info *)data;
+	struct lib80211_crypt_info *info = from_timer(info, t,
+						      crypt_deinit_timer);
 	unsigned long flags;
 
 	lib80211_crypt_deinit_entries(info, 0);
diff --git a/net/x25/x25_link.c b/net/x25/x25_link.c
index 4acacf3c6617..1aec960bf230 100644
--- a/net/x25/x25_link.c
+++ b/net/x25/x25_link.c
@@ -34,7 +34,7 @@
 LIST_HEAD(x25_neigh_list);
 DEFINE_RWLOCK(x25_neigh_list_lock);
 
-static void x25_t20timer_expiry(unsigned long);
+static void x25_t20timer_expiry(struct timer_list *);
 
 static void x25_transmit_restart_confirmation(struct x25_neigh *nb);
 static void x25_transmit_restart_request(struct x25_neigh *nb);
@@ -47,9 +47,9 @@ static inline void x25_start_t20timer(struct x25_neigh *nb)
 	mod_timer(&nb->t20timer, jiffies + nb->t20);
 }
 
-static void x25_t20timer_expiry(unsigned long param)
+static void x25_t20timer_expiry(struct timer_list *t)
 {
-	struct x25_neigh *nb = (struct x25_neigh *)param;
+	struct x25_neigh *nb = from_timer(nb, t, t20timer);
 
 	x25_transmit_restart_request(nb);
 
@@ -250,7 +250,7 @@ void x25_link_device_up(struct net_device *dev)
 		return;
 
 	skb_queue_head_init(&nb->queue);
-	setup_timer(&nb->t20timer, x25_t20timer_expiry, (unsigned long)nb);
+	timer_setup(&nb->t20timer, x25_t20timer_expiry, 0);
 
 	dev_hold(dev);
 	nb->dev      = dev;
diff --git a/net/xfrm/xfrm_state.c b/net/xfrm/xfrm_state.c
index 23f4c878489d..caf1bebde347 100644
--- a/net/xfrm/xfrm_state.c
+++ b/net/xfrm/xfrm_state.c
@@ -475,7 +475,7 @@ out:
 	return HRTIMER_NORESTART;
 }
 
-static void xfrm_replay_timer_handler(unsigned long data);
+static void xfrm_replay_timer_handler(struct timer_list *t);
 
 struct xfrm_state *xfrm_state_alloc(struct net *net)
 {
@@ -493,8 +493,7 @@ struct xfrm_state *xfrm_state_alloc(struct net *net)
 		INIT_HLIST_NODE(&x->byspi);
 		tasklet_hrtimer_init(&x->mtimer, xfrm_timer_handler,
 					CLOCK_BOOTTIME, HRTIMER_MODE_ABS);
-		setup_timer(&x->rtimer, xfrm_replay_timer_handler,
-				(unsigned long)x);
+		timer_setup(&x->rtimer, xfrm_replay_timer_handler, 0);
 		x->curlft.add_time = get_seconds();
 		x->lft.soft_byte_limit = XFRM_INF;
 		x->lft.soft_packet_limit = XFRM_INF;
@@ -1667,9 +1666,9 @@ void xfrm_state_walk_done(struct xfrm_state_walk *walk, struct net *net)
 }
 EXPORT_SYMBOL(xfrm_state_walk_done);
 
-static void xfrm_replay_timer_handler(unsigned long data)
+static void xfrm_replay_timer_handler(struct timer_list *t)
 {
-	struct xfrm_state *x = (struct xfrm_state *)data;
+	struct xfrm_state *x = from_timer(x, t, rtimer);
 
 	spin_lock(&x->lock);
 
