vti6: Properly adjust vti6 MTU from MTU of lower device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Stefano Brivio <sbrivio@redhat.com>
commit c6741fbed6dc0f183d26c4b6bca4517672f92e6c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c6741fbe.failed

If a lower device is found, we don't need to subtract
LL_MAX_HEADER to calculate our MTU: just use its MTU, the link
layer headers are already taken into account by it.

If the lower device is not found, start from ETH_DATA_LEN
instead, and only in this case subtract a worst-case
LL_MAX_HEADER.

We then need to subtract our additional IPv6 header from the
calculation.

While at it, note that vti6 doesn't have a hardware header, so
it doesn't need to set dev->hard_header_len. And as
vti6_link_config() now always sets the MTU, there's no need to
set a default value in vti6_dev_setup().

This makes the behaviour consistent with IPv4 vti, after
commit a32452366b72 ("vti4: Don't count header length twice."),
which was accidentally reverted by merge commit f895f0cfbb77
("Merge branch 'master' of
git://git.kernel.org/pub/scm/linux/kernel/git/klassert/ipsec").

While commit 53c81e95df17 ("ip6_vti: adjust vti mtu according to
mtu of lower device") improved on the original situation, this
was still not ideal. As reported in that commit message itself,
if we start from an underlying veth MTU of 9000, we end up with
an MTU of 8832, that is, 9000 - LL_MAX_HEADER - sizeof(ipv6hdr).
This should simply be 8880, or 9000 - sizeof(ipv6hdr) instead:
we found the lower device (veth) and we know we don't have any
additional link layer header, so there's no need to subtract an
hypothetical worst-case number.

Fixes: 53c81e95df17 ("ip6_vti: adjust vti mtu according to mtu of lower device")
	Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
	Acked-by: Sabrina Dubroca <sd@queasysnail.net>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit c6741fbed6dc0f183d26c4b6bca4517672f92e6c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_vti.c
diff --cc net/ipv6/ip6_vti.c
index b5465b46c477,2ceef41cc097..000000000000
--- a/net/ipv6/ip6_vti.c
+++ b/net/ipv6/ip6_vti.c
@@@ -856,12 -866,12 +860,17 @@@ static const struct net_device_ops vti6
  static void vti6_dev_setup(struct net_device *dev)
  {
  	dev->netdev_ops = &vti6_netdev_ops;
 -	dev->needs_free_netdev = true;
 -	dev->priv_destructor = vti6_dev_free;
 +	dev->extended->needs_free_netdev = true;
 +	dev->extended->priv_destructor = vti6_dev_free;
  
  	dev->type = ARPHRD_TUNNEL6;
++<<<<<<< HEAD
 +	dev->hard_header_len = LL_MAX_HEADER + sizeof(struct ipv6hdr);
 +	dev->mtu = ETH_DATA_LEN;
++=======
+ 	dev->min_mtu = IPV6_MIN_MTU;
+ 	dev->max_mtu = IP_MAX_MTU;
++>>>>>>> c6741fbed6dc (vti6: Properly adjust vti6 MTU from MTU of lower device)
  	dev->flags |= IFF_NOARP;
  	dev->addr_len = sizeof(struct in6_addr);
  	netif_keep_dst(dev);
* Unmerged path net/ipv6/ip6_vti.c
