blk-mq: clarify dispatch may not be drained/blocked by stopping queue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [blk-mq] clarify dispatch may not be drained/blocked by stopping queue (Ewan Milne) [1549232]
Rebuild_FUZZ: 93.85%
commit-author Ming Lei <ming.lei@redhat.com>
commit 39a70c76b89b81db91a72a86b6c6a9b239013417
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/39a70c76.failed

BLK_MQ_S_STOPPED may not be observed in other concurrent I/O paths,
we can't guarantee that dispatching won't happen after returning
from the APIs of stopping queue.

So clarify the fact and avoid potential misuse.

	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Reviewed-by: Bart Van Assche <Bart.VanAssche@sandisk.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 39a70c76b89b81db91a72a86b6c6a9b239013417)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index af064c8e0d5d,89cbd022b1eb..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -1261,11 -1194,28 +1261,33 @@@ bool blk_mq_queue_stopped(struct reques
  }
  EXPORT_SYMBOL(blk_mq_queue_stopped);
  
++<<<<<<< HEAD
++=======
+ static void __blk_mq_stop_hw_queue(struct blk_mq_hw_ctx *hctx, bool sync)
+ {
+ 	if (sync)
+ 		cancel_delayed_work_sync(&hctx->run_work);
+ 	else
+ 		cancel_delayed_work(&hctx->run_work);
+ 
+ 	set_bit(BLK_MQ_S_STOPPED, &hctx->state);
+ }
+ 
+ /*
+  * This function is often used for pausing .queue_rq() by driver when
+  * there isn't enough resource or some conditions aren't satisfied, and
+  * BLK_MQ_RQ_QUEUE_BUSY is usually returned.
+  *
+  * We do not guarantee that dispatch can be drained or blocked
+  * after blk_mq_stop_hw_queue() returns. Please use
+  * blk_mq_quiesce_queue() for that requirement.
+  */
++>>>>>>> 39a70c76b89b (blk-mq: clarify dispatch may not be drained/blocked by stopping queue)
  void blk_mq_stop_hw_queue(struct blk_mq_hw_ctx *hctx)
  {
 -	__blk_mq_stop_hw_queue(hctx, false);
 +	cancel_delayed_work(&hctx->run_work);
 +	cancel_delayed_work(&hctx->delay_work);
 +	set_bit(BLK_MQ_S_STOPPED, &hctx->state);
  }
  EXPORT_SYMBOL(blk_mq_stop_hw_queue);
  
@@@ -1275,7 -1225,21 +1297,25 @@@ void blk_mq_stop_hw_queues(struct reque
  	int i;
  
  	queue_for_each_hw_ctx(q, hctx, i)
++<<<<<<< HEAD
 +		blk_mq_stop_hw_queue(hctx);
++=======
+ 		__blk_mq_stop_hw_queue(hctx, sync);
+ }
+ 
+ /*
+  * This function is often used for pausing .queue_rq() by driver when
+  * there isn't enough resource or some conditions aren't satisfied, and
+  * BLK_MQ_RQ_QUEUE_BUSY is usually returned.
+  *
+  * We do not guarantee that dispatch can be drained or blocked
+  * after blk_mq_stop_hw_queues() returns. Please use
+  * blk_mq_quiesce_queue() for that requirement.
+  */
+ void blk_mq_stop_hw_queues(struct request_queue *q)
+ {
+ 	__blk_mq_stop_hw_queues(q, false);
++>>>>>>> 39a70c76b89b (blk-mq: clarify dispatch may not be drained/blocked by stopping queue)
  }
  EXPORT_SYMBOL(blk_mq_stop_hw_queues);
  
* Unmerged path block/blk-mq.c
