vmbus: more host signalling avoidance

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Stephen Hemminger <stephen@networkplumber.org>
commit 03bad714a1619c0074eb44d6f217c505fe27030f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/03bad714.failed

Don't signal host if it has disabled interrupts for that
ring buffer. Check the feature bit to see if host supports
pending send size flag.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 03bad714a1619c0074eb44d6f217c505fe27030f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/ring_buffer.c
diff --cc drivers/hv/ring_buffer.c
index 480f1a09972c,741daa6e2fc7..000000000000
--- a/drivers/hv/ring_buffer.c
+++ b/drivers/hv/ring_buffer.c
@@@ -507,6 -395,7 +507,10 @@@ EXPORT_SYMBOL_GPL(__hv_pkt_iter_next)
  void hv_pkt_iter_close(struct vmbus_channel *channel)
  {
  	struct hv_ring_buffer_info *rbi = &channel->inbound;
++<<<<<<< HEAD
++=======
+ 	u32 orig_write_sz = hv_get_bytes_to_write(rbi);
++>>>>>>> 03bad714a161 (vmbus: more host signalling avoidance)
  
  	/*
  	 * Make sure all reads are done before we update the read index since
@@@ -516,6 -405,40 +520,44 @@@
  	virt_rmb();
  	rbi->ring_buffer->read_index = rbi->priv_read_index;
  
++<<<<<<< HEAD
 +	hv_signal_on_read(channel);
++=======
+ 	/*
+ 	 * Issue a full memory barrier before making the signaling decision.
+ 	 * Here is the reason for having this barrier:
+ 	 * If the reading of the pend_sz (in this function)
+ 	 * were to be reordered and read before we commit the new read
+ 	 * index (in the calling function)  we could
+ 	 * have a problem. If the host were to set the pending_sz after we
+ 	 * have sampled pending_sz and go to sleep before we commit the
+ 	 * read index, we could miss sending the interrupt. Issue a full
+ 	 * memory barrier to address this.
+ 	 */
+ 	virt_mb();
+ 
+ 	/* If host has disabled notifications then skip */
+ 	if (rbi->ring_buffer->interrupt_mask)
+ 		return;
+ 
+ 	if (rbi->ring_buffer->feature_bits.feat_pending_send_sz) {
+ 		u32 pending_sz = READ_ONCE(rbi->ring_buffer->pending_send_sz);
+ 
+ 		/*
+ 		 * If there was space before we began iteration,
+ 		 * then host was not blocked. Also handles case where
+ 		 * pending_sz is zero then host has nothing pending
+ 		 * and does not need to be signaled.
+ 		 */
+ 		if (orig_write_sz > pending_sz)
+ 			return;
+ 
+ 		/* If pending write will not fit, don't give false hope. */
+ 		if (hv_get_bytes_to_write(rbi) < pending_sz)
+ 			return;
+ 	}
+ 
+ 	vmbus_setevent(channel);
++>>>>>>> 03bad714a161 (vmbus: more host signalling avoidance)
  }
  EXPORT_SYMBOL_GPL(hv_pkt_iter_close);
* Unmerged path drivers/hv/ring_buffer.c
