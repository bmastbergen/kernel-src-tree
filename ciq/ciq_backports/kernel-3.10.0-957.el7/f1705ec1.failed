net: ipv6: Make address flushing on ifdown optional

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] ipv6: Make address flushing on ifdown optional (Ivan Vecera) [1500871]
Rebuild_FUZZ: 94.85%
commit-author David Ahern <dsa@cumulusnetworks.com>
commit f1705ec197e705b79ea40fe7a2cc5acfa1d3bfac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f1705ec1.failed

Currently, all ipv6 addresses are flushed when the interface is configured
down, including global, static addresses:

    $ ip -6 addr show dev eth1
    3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 state UP qlen 1000
        inet6 2100:1::2/120 scope global
           valid_lft forever preferred_lft forever
        inet6 fe80::e0:f9ff:fe79:34bd/64 scope link
           valid_lft forever preferred_lft forever
    $ ip link set dev eth1 down
    $ ip -6 addr show dev eth1
    << nothing; all addresses have been flushed>>

Add a new sysctl to make this behavior optional. The new setting defaults to
flush all addresses to maintain backwards compatibility. When the set global
addresses with no expire times are not flushed on an admin down. The sysctl
is per-interface or system-wide for all interfaces

    $ sysctl -w net.ipv6.conf.eth1.keep_addr_on_down=1
or
    $ sysctl -w net.ipv6.conf.all.keep_addr_on_down=1

Will keep addresses on eth1 on an admin down.

    $ ip -6 addr show dev eth1
    3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 state UP qlen 1000
        inet6 2100:1::2/120 scope global
           valid_lft forever preferred_lft forever
        inet6 fe80::e0:f9ff:fe79:34bd/64 scope link
           valid_lft forever preferred_lft forever
    $ ip link set dev eth1 down
    $ ip -6 addr show dev eth1
    3: eth1: <BROADCAST,MULTICAST> mtu 1500 state DOWN qlen 1000
        inet6 2100:1::2/120 scope global tentative
           valid_lft forever preferred_lft forever
        inet6 fe80::e0:f9ff:fe79:34bd/64 scope link tentative
           valid_lft forever preferred_lft forever

	Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f1705ec197e705b79ea40fe7a2cc5acfa1d3bfac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/ipv6.h
#	include/uapi/linux/ipv6.h
#	net/ipv6/addrconf.c
diff --cc include/linux/ipv6.h
index 2372ba381596,7edc14fb66b6..000000000000
--- a/include/linux/ipv6.h
+++ b/include/linux/ipv6.h
@@@ -54,10 -61,8 +54,15 @@@ struct ipv6_devconf 
  		bool initialized;
  		struct in6_addr secret;
  	} stable_secret;
++<<<<<<< HEAD
 +#ifdef CONFIG_IPV6_OPTIMISTIC_DAD
 +	__s32		use_optimistic;
 +#endif
 +#endif
++=======
+ 	__s32		use_oif_addrs_only;
+ 	__s32		keep_addr_on_down;
++>>>>>>> f1705ec197e7 (net: ipv6: Make address flushing on ifdown optional)
  	void		*sysctl;
  };
  
diff --cc include/uapi/linux/ipv6.h
index 9ab97f0308fa,395876060f50..000000000000
--- a/include/uapi/linux/ipv6.h
+++ b/include/uapi/linux/ipv6.h
@@@ -167,6 -171,12 +167,15 @@@ enum 
  	DEVCONF_USE_OPTIMISTIC,
  	DEVCONF_ACCEPT_RA_MTU,
  	DEVCONF_STABLE_SECRET,
++<<<<<<< HEAD
++=======
+ 	DEVCONF_USE_OIF_ADDRS_ONLY,
+ 	DEVCONF_ACCEPT_RA_MIN_HOP_LIMIT,
+ 	DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN,
+ 	DEVCONF_DROP_UNICAST_IN_L2_MULTICAST,
+ 	DEVCONF_DROP_UNSOLICITED_NA,
+ 	DEVCONF_KEEP_ADDR_ON_DOWN,
++>>>>>>> f1705ec197e7 (net: ipv6: Make address flushing on ifdown optional)
  	DEVCONF_MAX
  };
  
diff --cc net/ipv6/addrconf.c
index e92da293a901,a2d6f6c242af..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -205,10 -208,15 +205,17 @@@ static struct ipv6_devconf ipv6_devcon
  	.proxy_ndp		= 0,
  	.accept_source_route	= 0,	/* we do not accept RH0 by default. */
  	.disable_ipv6		= 0,
 -	.accept_dad		= 1,
 -	.suppress_frag_ndisc	= 1,
 -	.accept_ra_mtu		= 1,
 +	.accept_dad		= 0,
  	.stable_secret		= {
  		.initialized = false,
++<<<<<<< HEAD
 +	}
++=======
+ 	},
+ 	.use_oif_addrs_only	= 0,
+ 	.ignore_routes_with_linkdown = 0,
+ 	.keep_addr_on_down	= 0,
++>>>>>>> f1705ec197e7 (net: ipv6: Make address flushing on ifdown optional)
  };
  
  static struct ipv6_devconf ipv6_devconf_dflt __read_mostly = {
@@@ -247,6 -257,11 +254,12 @@@
  	.stable_secret		= {
  		.initialized = false,
  	},
++<<<<<<< HEAD
++=======
+ 	.use_oif_addrs_only	= 0,
+ 	.ignore_routes_with_linkdown = 0,
+ 	.keep_addr_on_down	= 0,
++>>>>>>> f1705ec197e7 (net: ipv6: Make address flushing on ifdown optional)
  };
  
  /* Check if a valid qdisc is available */
@@@ -3291,12 -3455,18 +3369,18 @@@ static int addrconf_ifdown(struct net_d
  		struct hlist_head *h = &inet6_addr_lst[i];
  
  		spin_lock_bh(&addrconf_hash_lock);
 -restart:
 +	restart:
  		hlist_for_each_entry_rcu(ifa, h, addr_lst) {
  			if (ifa->idev == idev) {
- 				hlist_del_init_rcu(&ifa->addr_lst);
  				addrconf_del_dad_work(ifa);
- 				goto restart;
+ 				/* combined flag + permanent flag decide if
+ 				 * address is retained on a down event
+ 				 */
+ 				if (!keep_addr ||
+ 				    !(ifa->flags & IFA_F_PERMANENT)) {
+ 					hlist_del_init_rcu(&ifa->addr_lst);
+ 					goto restart;
+ 				}
  			}
  		}
  		spin_unlock_bh(&addrconf_hash_lock);
@@@ -3355,11 -3538,22 +3452,26 @@@
  
  	write_unlock_bh(&idev->lock);
  
++<<<<<<< HEAD
 +	/* Step 5: Discard multicast list */
 +	if (how)
++=======
+ 	/* now clean up addresses to be removed */
+ 	while (!list_empty(&del_list)) {
+ 		ifa = list_first_entry(&del_list,
+ 				       struct inet6_ifaddr, if_list);
+ 		list_del(&ifa->if_list);
+ 
+ 		in6_ifa_put(ifa);
+ 	}
+ 
+ 	/* Step 5: Discard anycast and multicast list */
+ 	if (how) {
+ 		ipv6_ac_destroy_dev(idev);
++>>>>>>> f1705ec197e7 (net: ipv6: Make address flushing on ifdown optional)
  		ipv6_mc_destroy_dev(idev);
 -	} else {
 +	else
  		ipv6_mc_down(idev);
 -	}
  
  	idev->tstamp = jiffies;
  
@@@ -4614,7 -4803,15 +4726,14 @@@ static inline void ipv6_store_devconf(s
  	array[DEVCONF_ACCEPT_DAD] = cnf->accept_dad;
  	array[DEVCONF_FORCE_TLLAO] = cnf->force_tllao;
  	array[DEVCONF_NDISC_NOTIFY] = cnf->ndisc_notify;
 -	array[DEVCONF_SUPPRESS_FRAG_NDISC] = cnf->suppress_frag_ndisc;
 -	array[DEVCONF_ACCEPT_RA_FROM_LOCAL] = cnf->accept_ra_from_local;
 -	array[DEVCONF_ACCEPT_RA_MTU] = cnf->accept_ra_mtu;
 -	array[DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN] = cnf->ignore_routes_with_linkdown;
  	/* we omit DEVCONF_STABLE_SECRET for now */
++<<<<<<< HEAD
++=======
+ 	array[DEVCONF_USE_OIF_ADDRS_ONLY] = cnf->use_oif_addrs_only;
+ 	array[DEVCONF_DROP_UNICAST_IN_L2_MULTICAST] = cnf->drop_unicast_in_l2_multicast;
+ 	array[DEVCONF_DROP_UNSOLICITED_NA] = cnf->drop_unsolicited_na;
+ 	array[DEVCONF_KEEP_ADDR_ON_DOWN] = cnf->keep_addr_on_down;
++>>>>>>> f1705ec197e7 (net: ipv6: Make address flushing on ifdown optional)
  }
  
  static inline size_t inet6_ifla6_size(void)
@@@ -5549,6 -5874,42 +5670,45 @@@ static struct addrconf_sysctl_tabl
  			.proc_handler	= addrconf_sysctl_stable_secret,
  		},
  		{
++<<<<<<< HEAD
++=======
+ 			.procname       = "use_oif_addrs_only",
+ 			.data           = &ipv6_devconf.use_oif_addrs_only,
+ 			.maxlen         = sizeof(int),
+ 			.mode           = 0644,
+ 			.proc_handler   = proc_dointvec,
+ 		},
+ 		{
+ 			.procname	= "ignore_routes_with_linkdown",
+ 			.data		= &ipv6_devconf.ignore_routes_with_linkdown,
+ 			.maxlen		= sizeof(int),
+ 			.mode		= 0644,
+ 			.proc_handler	= addrconf_sysctl_ignore_routes_with_linkdown,
+ 		},
+ 		{
+ 			.procname	= "drop_unicast_in_l2_multicast",
+ 			.data		= &ipv6_devconf.drop_unicast_in_l2_multicast,
+ 			.maxlen		= sizeof(int),
+ 			.mode		= 0644,
+ 			.proc_handler	= proc_dointvec,
+ 		},
+ 		{
+ 			.procname	= "drop_unsolicited_na",
+ 			.data		= &ipv6_devconf.drop_unsolicited_na,
+ 			.maxlen		= sizeof(int),
+ 			.mode		= 0644,
+ 			.proc_handler	= proc_dointvec,
+ 		},
+ 		{
+ 			.procname       = "keep_addr_on_down",
+ 			.data           = &ipv6_devconf.keep_addr_on_down,
+ 			.maxlen         = sizeof(int),
+ 			.mode           = 0644,
+ 			.proc_handler   = proc_dointvec,
+ 
+ 		},
+ 		{
++>>>>>>> f1705ec197e7 (net: ipv6: Make address flushing on ifdown optional)
  			/* sentinel */
  		}
  	},
diff --git a/Documentation/networking/ip-sysctl.txt b/Documentation/networking/ip-sysctl.txt
index 1755c9b2d05f..fdbed48be10b 100644
--- a/Documentation/networking/ip-sysctl.txt
+++ b/Documentation/networking/ip-sysctl.txt
@@ -1395,6 +1395,15 @@ temp_prefered_lft - INTEGER
 	Preferred lifetime (in seconds) for temporary addresses.
 	Default: 86400 (1 day)
 
+keep_addr_on_down - INTEGER
+	Keep all IPv6 addresses on an interface down event. If set static
+	global addresses with no expiration time are not flushed.
+	  >0 : enabled
+	   0 : system default
+	  <0 : disabled
+
+	Default: 0 (addresses are removed)
+
 max_desync_factor - INTEGER
 	Maximum value for DESYNC_FACTOR, which is a random value
 	that ensures that clients don't synchronize with each
* Unmerged path include/linux/ipv6.h
* Unmerged path include/uapi/linux/ipv6.h
* Unmerged path net/ipv6/addrconf.c
