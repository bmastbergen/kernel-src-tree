powerpc/pseries: Set or clear security feature flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [powerpc] pseries: Set or clear security feature flags (Mauricio Oliveira) [1561787]
Rebuild_FUZZ: 91.67%
commit-author Michael Ellerman <mpe@ellerman.id.au>
commit f636c14790ead6cc22cf62279b1f8d7e11a67116
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f636c147.failed

Now that we have feature flags for security related things, set or
clear them based on what we receive from the hypercall.

	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit f636c14790ead6cc22cf62279b1f8d7e11a67116)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/pseries/setup.c
diff --cc arch/powerpc/platforms/pseries/setup.c
index 16f5e74be2ee,fb84c1df6ed7..000000000000
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@@ -67,6 -66,9 +67,12 @@@
  #include <asm/eeh.h>
  #include <asm/reg.h>
  #include <asm/plpar_wrappers.h>
++<<<<<<< HEAD
++=======
+ #include <asm/kexec.h>
+ #include <asm/isa-bridge.h>
+ #include <asm/security_features.h>
++>>>>>>> f636c14790ea (powerpc/pseries: Set or clear security feature flags)
  
  #include "pseries.h"
  
@@@ -501,56 -457,74 +507,106 @@@ static void __init find_and_init_phbs(v
  	 * PCI_PROBE_ONLY and PCI_REASSIGN_ALL_BUS can be set via properties
  	 * in chosen.
  	 */
 -	of_pci_check_probe_only();
 +	if (of_chosen) {
 +		const int *prop;
 +
 +		prop = of_get_property(of_chosen,
 +				"linux,pci-probe-only", NULL);
 +		if (prop) {
 +			if (*prop)
 +				pci_add_flags(PCI_PROBE_ONLY);
 +			else
 +				pci_clear_flags(PCI_PROBE_ONLY);
 +		}
 +
 +#ifdef CONFIG_PPC32 /* Will be made generic soon */
 +		prop = of_get_property(of_chosen,
 +				"linux,pci-assign-all-buses", NULL);
 +		if (prop && *prop)
 +			pci_add_flags(PCI_REASSIGN_ALL_BUS);
 +#endif /* CONFIG_PPC32 */
 +	}
  }
  
++<<<<<<< HEAD
 +static void pSeries_setup_rfi_flush(void)
++=======
+ static void init_cpu_char_feature_flags(struct h_cpu_char_result *result)
+ {
+ 	if (result->character & H_CPU_CHAR_SPEC_BAR_ORI31)
+ 		security_ftr_set(SEC_FTR_SPEC_BAR_ORI31);
+ 
+ 	if (result->character & H_CPU_CHAR_BCCTRL_SERIALISED)
+ 		security_ftr_set(SEC_FTR_BCCTRL_SERIALISED);
+ 
+ 	if (result->character & H_CPU_CHAR_L1D_FLUSH_ORI30)
+ 		security_ftr_set(SEC_FTR_L1D_FLUSH_ORI30);
+ 
+ 	if (result->character & H_CPU_CHAR_L1D_FLUSH_TRIG2)
+ 		security_ftr_set(SEC_FTR_L1D_FLUSH_TRIG2);
+ 
+ 	if (result->character & H_CPU_CHAR_L1D_THREAD_PRIV)
+ 		security_ftr_set(SEC_FTR_L1D_THREAD_PRIV);
+ 
+ 	if (result->character & H_CPU_CHAR_COUNT_CACHE_DISABLED)
+ 		security_ftr_set(SEC_FTR_COUNT_CACHE_DISABLED);
+ 
+ 	/*
+ 	 * The features below are enabled by default, so we instead look to see
+ 	 * if firmware has *disabled* them, and clear them if so.
+ 	 */
+ 	if (!(result->character & H_CPU_BEHAV_FAVOUR_SECURITY))
+ 		security_ftr_clear(SEC_FTR_FAVOUR_SECURITY);
+ 
+ 	if (!(result->character & H_CPU_BEHAV_L1D_FLUSH_PR))
+ 		security_ftr_clear(SEC_FTR_L1D_FLUSH_PR);
+ 
+ 	if (!(result->character & H_CPU_BEHAV_BNDS_CHK_SPEC_BAR))
+ 		security_ftr_clear(SEC_FTR_BNDS_CHK_SPEC_BAR);
+ }
+ 
+ void pseries_setup_rfi_flush(void)
++>>>>>>> f636c14790ea (powerpc/pseries: Set or clear security feature flags)
  {
 -	struct h_cpu_char_result result;
 +	unsigned long character, behaviour, rc;
  	enum l1d_flush_type types;
  	bool enable;
 -	long rc;
  
  	/* Enable by default */
  	enable = true;
 -	types = L1D_FLUSH_FALLBACK;
  
 -	rc = plpar_get_cpu_characteristics(&result);
 +	rc = plpar_get_cpu_characteristics(&character, &behaviour);
  	if (rc == H_SUCCESS) {
++<<<<<<< HEAD
 +		types = L1D_FLUSH_NONE;
 +
 +		if (character & H_GET_CPU_CHAR_CHAR_MTTRIG2_L1_FLUSH)
++=======
+ 		init_cpu_char_feature_flags(&result);
+ 
+ 		if (result.character & H_CPU_CHAR_L1D_FLUSH_TRIG2)
++>>>>>>> f636c14790ea (powerpc/pseries: Set or clear security feature flags)
  			types |= L1D_FLUSH_MTTRIG;
 -		if (result.character & H_CPU_CHAR_L1D_FLUSH_ORI30)
 +		if (character & H_GET_CPU_CHAR_CHAR_ORI30_L1_FLUSH)
  			types |= L1D_FLUSH_ORI;
  
 -		if ((!(result.behaviour & H_CPU_BEHAV_L1D_FLUSH_PR)) ||
 -		    (!(result.behaviour & H_CPU_BEHAV_FAVOUR_SECURITY)))
 +		/* Use fallback if nothing set in hcall */
 +		if (types == L1D_FLUSH_NONE)
 +			types = L1D_FLUSH_FALLBACK;
 +
 +		if (!(behaviour & H_GET_CPU_CHAR_BEHAV_L1_FLUSH_LOW_PRIV))
  			enable = false;
 +	} else {
 +		/* Default to fallback if case hcall is not available */
 +		types = L1D_FLUSH_FALLBACK;
  	}
  
+ 	/*
+ 	 * We're the guest so this doesn't apply to us, clear it to simplify
+ 	 * handling of it elsewhere.
+ 	 */
+ 	security_ftr_clear(SEC_FTR_L1D_FLUSH_HV);
+ 
  	setup_rfi_flush(types, enable);
  }
  
* Unmerged path arch/powerpc/platforms/pseries/setup.c
