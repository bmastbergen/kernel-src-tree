of: Convert to using %pOF instead of full_name

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [usb] Convert to using pOF instead of full_name (Torez Smith) [1540721]
Rebuild_FUZZ: 94.25%
commit-author Rob Herring <robh@kernel.org>
commit 0d638a07d3a1e98a7598eb2812a6236324e4c55f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0d638a07.failed

Now that we have a custom printf format specifier, convert users of
full_name to use %pOF instead. This is preparation to remove storing
of the full path string for each node.

	Signed-off-by: Rob Herring <robh@kernel.org>
(cherry picked from commit 0d638a07d3a1e98a7598eb2812a6236324e4c55f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/of/address.c
#	drivers/of/base.c
#	drivers/of/dynamic.c
#	drivers/of/irq.c
#	drivers/of/of_mdio.c
#	drivers/of/of_pci.c
#	drivers/of/overlay.c
#	drivers/of/platform.c
#	drivers/of/property.c
#	drivers/of/unittest.c
diff --cc drivers/of/address.c
index f5a0a2c40a5e,ca1c0f6301ea..000000000000
--- a/drivers/of/address.c
+++ b/drivers/of/address.c
@@@ -435,7 -559,7 +435,11 @@@ static u64 __of_translate_address(struc
  	int na, ns, pna, pns;
  	u64 result = OF_BAD_ADDR;
  
++<<<<<<< HEAD
 +	pr_debug("OF: ** translation for device %s **\n", of_node_full_name(dev));
++=======
+ 	pr_debug("** translation for device %pOF **\n", dev);
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  
  	/* Increase refcount at current level */
  	of_node_get(dev);
@@@ -449,14 -573,14 +453,24 @@@
  	/* Count address cells & copy address locally */
  	bus->count_cells(dev, &na, &ns);
  	if (!OF_CHECK_COUNTS(na, ns)) {
++<<<<<<< HEAD
 +		pr_debug("OF: Bad cell count for %s\n", of_node_full_name(dev));
++=======
+ 		pr_debug("Bad cell count for %pOF\n", dev);
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  		goto bail;
  	}
  	memcpy(addr, in_addr, na * 4);
  
++<<<<<<< HEAD
 +	pr_debug("OF: bus is %s (na=%d, ns=%d) on %s\n",
 +	    bus->name, na, ns, of_node_full_name(parent));
 +	of_dump_addr("OF: translating address:", addr, na);
++=======
+ 	pr_debug("bus is %s (na=%d, ns=%d) on %pOF\n",
+ 	    bus->name, na, ns, parent);
+ 	of_dump_addr("translating address:", addr, na);
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  
  	/* Translate */
  	for (;;) {
@@@ -476,13 -600,12 +490,22 @@@
  		pbus = of_match_bus(parent);
  		pbus->count_cells(dev, &pna, &pns);
  		if (!OF_CHECK_COUNTS(pna, pns)) {
++<<<<<<< HEAD
 +			printk(KERN_ERR "prom_parse: Bad cell count for %s\n",
 +			       dev->full_name);
 +			break;
 +		}
 +
 +		pr_debug("OF: parent bus is %s (na=%d, ns=%d) on %s\n",
 +		    pbus->name, pna, pns, parent->full_name);
++=======
+ 			pr_err("Bad cell count for %pOF\n", dev);
+ 			break;
+ 		}
+ 
+ 		pr_debug("parent bus is %s (na=%d, ns=%d) on %pOF\n",
+ 		    pbus->name, pna, pns, parent);
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  
  		/* Apply bus translation */
  		if (of_translate_one(dev, bus, pbus, addr, na, ns, pna, rprop))
@@@ -652,3 -767,148 +675,151 @@@ void __iomem *of_iomap(struct device_no
  	return ioremap(res.start, resource_size(&res));
  }
  EXPORT_SYMBOL(of_iomap);
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * of_io_request_and_map - Requests a resource and maps the memory mapped IO
+  *			   for a given device_node
+  * @device:	the device whose io range will be mapped
+  * @index:	index of the io range
+  * @name:	name of the resource
+  *
+  * Returns a pointer to the requested and mapped memory or an ERR_PTR() encoded
+  * error code on failure. Usage example:
+  *
+  *	base = of_io_request_and_map(node, 0, "foo");
+  *	if (IS_ERR(base))
+  *		return PTR_ERR(base);
+  */
+ void __iomem *of_io_request_and_map(struct device_node *np, int index,
+ 					const char *name)
+ {
+ 	struct resource res;
+ 	void __iomem *mem;
+ 
+ 	if (of_address_to_resource(np, index, &res))
+ 		return IOMEM_ERR_PTR(-EINVAL);
+ 
+ 	if (!request_mem_region(res.start, resource_size(&res), name))
+ 		return IOMEM_ERR_PTR(-EBUSY);
+ 
+ 	mem = ioremap(res.start, resource_size(&res));
+ 	if (!mem) {
+ 		release_mem_region(res.start, resource_size(&res));
+ 		return IOMEM_ERR_PTR(-ENOMEM);
+ 	}
+ 
+ 	return mem;
+ }
+ EXPORT_SYMBOL(of_io_request_and_map);
+ 
+ /**
+  * of_dma_get_range - Get DMA range info
+  * @np:		device node to get DMA range info
+  * @dma_addr:	pointer to store initial DMA address of DMA range
+  * @paddr:	pointer to store initial CPU address of DMA range
+  * @size:	pointer to store size of DMA range
+  *
+  * Look in bottom up direction for the first "dma-ranges" property
+  * and parse it.
+  *  dma-ranges format:
+  *	DMA addr (dma_addr)	: naddr cells
+  *	CPU addr (phys_addr_t)	: pna cells
+  *	size			: nsize cells
+  *
+  * It returns -ENODEV if "dma-ranges" property was not found
+  * for this device in DT.
+  */
+ int of_dma_get_range(struct device_node *np, u64 *dma_addr, u64 *paddr, u64 *size)
+ {
+ 	struct device_node *node = of_node_get(np);
+ 	const __be32 *ranges = NULL;
+ 	int len, naddr, nsize, pna;
+ 	int ret = 0;
+ 	u64 dmaaddr;
+ 
+ 	if (!node)
+ 		return -EINVAL;
+ 
+ 	while (1) {
+ 		naddr = of_n_addr_cells(node);
+ 		nsize = of_n_size_cells(node);
+ 		node = of_get_next_parent(node);
+ 		if (!node)
+ 			break;
+ 
+ 		ranges = of_get_property(node, "dma-ranges", &len);
+ 
+ 		/* Ignore empty ranges, they imply no translation required */
+ 		if (ranges && len > 0)
+ 			break;
+ 
+ 		/*
+ 		 * At least empty ranges has to be defined for parent node if
+ 		 * DMA is supported
+ 		 */
+ 		if (!ranges)
+ 			break;
+ 	}
+ 
+ 	if (!ranges) {
+ 		pr_debug("no dma-ranges found for node(%pOF)\n", np);
+ 		ret = -ENODEV;
+ 		goto out;
+ 	}
+ 
+ 	len /= sizeof(u32);
+ 
+ 	pna = of_n_addr_cells(node);
+ 
+ 	/* dma-ranges format:
+ 	 * DMA addr	: naddr cells
+ 	 * CPU addr	: pna cells
+ 	 * size		: nsize cells
+ 	 */
+ 	dmaaddr = of_read_number(ranges, naddr);
+ 	*paddr = of_translate_dma_address(np, ranges);
+ 	if (*paddr == OF_BAD_ADDR) {
+ 		pr_err("translation of DMA address(%pad) to CPU address failed node(%pOF)\n",
+ 		       dma_addr, np);
+ 		ret = -EINVAL;
+ 		goto out;
+ 	}
+ 	*dma_addr = dmaaddr;
+ 
+ 	*size = of_read_number(ranges + naddr + pna, nsize);
+ 
+ 	pr_debug("dma_addr(%llx) cpu_addr(%llx) size(%llx)\n",
+ 		 *dma_addr, *paddr, *size);
+ 
+ out:
+ 	of_node_put(node);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(of_dma_get_range);
+ 
+ /**
+  * of_dma_is_coherent - Check if device is coherent
+  * @np:	device node
+  *
+  * It returns true if "dma-coherent" property was found
+  * for this device in DT.
+  */
+ bool of_dma_is_coherent(struct device_node *np)
+ {
+ 	struct device_node *node = of_node_get(np);
+ 
+ 	while (node) {
+ 		if (of_property_read_bool(node, "dma-coherent")) {
+ 			of_node_put(node);
+ 			return true;
+ 		}
+ 		node = of_get_next_parent(node);
+ 	}
+ 	of_node_put(node);
+ 	return false;
+ }
+ EXPORT_SYMBOL_GPL(of_dma_is_coherent);
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
diff --cc drivers/of/base.c
index 69390e35dae8,5551ac2a9d4c..000000000000
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@@ -936,357 -1119,182 +936,495 @@@ struct device_node *of_find_node_by_pha
  }
  EXPORT_SYMBOL(of_find_node_by_phandle);
  
 -void of_print_phandle_args(const char *msg, const struct of_phandle_args *args)
 +/**
 + * of_property_count_elems_of_size - Count the number of elements in a property
 + *
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + * @elem_size:	size of the individual element
 + *
 + * Search for a property in a device node and count the number of elements of
 + * size elem_size in it. Returns number of elements on sucess, -EINVAL if the
 + * property does not exist or its length does not match a multiple of elem_size
 + * and -ENODATA if the property does not have a value.
 + */
 +int of_property_count_elems_of_size(const struct device_node *np,
 +				const char *propname, int elem_size)
  {
 -	int i;
 -	printk("%s %pOF", msg, args->np);
 -	for (i = 0; i < args->args_count; i++) {
 -		const char delim = i ? ',' : ':';
 +	struct property *prop = of_find_property(np, propname, NULL);
 +
 +	if (!prop)
 +		return -EINVAL;
 +	if (!prop->value)
 +		return -ENODATA;
  
 -		pr_cont("%c%08x", delim, args->args[i]);
 +	if (prop->length % elem_size != 0) {
 +		pr_err("size of %s in node %s is not a multiple of %d\n",
 +		       propname, np->full_name, elem_size);
 +		return -EINVAL;
  	}
 -	pr_cont("\n");
 +
 +	return prop->length / elem_size;
  }
 +EXPORT_SYMBOL_GPL(of_property_count_elems_of_size);
  
 -int of_phandle_iterator_init(struct of_phandle_iterator *it,
 -		const struct device_node *np,
 -		const char *list_name,
 -		const char *cells_name,
 -		int cell_count)
 +/**
 + * of_find_property_value_of_size
 + *
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + * @len:	requested length of property value
 + *
 + * Search for a property in a device node and valid the requested size.
 + * Returns the property value on success, -EINVAL if the property does not
 + *  exist, -ENODATA if property does not have a value, and -EOVERFLOW if the
 + * property data isn't large enough.
 + *
 + */
 +static void *of_find_property_value_of_size(const struct device_node *np,
 +			const char *propname, u32 len)
  {
 -	const __be32 *list;
 -	int size;
 +	struct property *prop = of_find_property(np, propname, NULL);
  
 -	memset(it, 0, sizeof(*it));
 +	if (!prop)
 +		return ERR_PTR(-EINVAL);
 +	if (!prop->value)
 +		return ERR_PTR(-ENODATA);
 +	if (len > prop->length)
 +		return ERR_PTR(-EOVERFLOW);
  
 -	list = of_get_property(np, list_name, &size);
 -	if (!list)
 -		return -ENOENT;
 +	return prop->value;
 +}
 +
 +/**
 + * of_property_read_u32_index - Find and read a u32 from a multi-value property.
 + *
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + * @index:	index of the u32 in the list of values
 + * @out_value:	pointer to return value, modified only if no error.
 + *
 + * Search for a property in a device node and read nth 32-bit value from
 + * it. Returns 0 on success, -EINVAL if the property does not exist,
 + * -ENODATA if property does not have a value, and -EOVERFLOW if the
 + * property data isn't large enough.
 + *
 + * The out_value is modified only if a valid u32 value can be decoded.
 + */
 +int of_property_read_u32_index(const struct device_node *np,
 +				       const char *propname,
 +				       u32 index, u32 *out_value)
 +{
 +	const u32 *val = of_find_property_value_of_size(np, propname,
 +					((index + 1) * sizeof(*out_value)));
  
 -	it->cells_name = cells_name;
 -	it->cell_count = cell_count;
 -	it->parent = np;
 -	it->list_end = list + size / sizeof(*list);
 -	it->phandle_end = list;
 -	it->cur = list;
 +	if (IS_ERR(val))
 +		return PTR_ERR(val);
  
 +	*out_value = be32_to_cpup(((__be32 *)val) + index);
  	return 0;
  }
 -EXPORT_SYMBOL_GPL(of_phandle_iterator_init);
 +EXPORT_SYMBOL_GPL(of_property_read_u32_index);
  
 -int of_phandle_iterator_next(struct of_phandle_iterator *it)
 +/**
 + * of_property_read_u8_array - Find and read an array of u8 from a property.
 + *
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + * @out_value:	pointer to return value, modified only if return value is 0.
 + * @sz:		number of array elements to read
 + *
 + * Search for a property in a device node and read 8-bit value(s) from
 + * it. Returns 0 on success, -EINVAL if the property does not exist,
 + * -ENODATA if property does not have a value, and -EOVERFLOW if the
 + * property data isn't large enough.
 + *
 + * dts entry of array should be like:
 + *	property = /bits/ 8 <0x50 0x60 0x70>;
 + *
 + * The out_value is modified only if a valid u8 value can be decoded.
 + */
 +int of_property_read_u8_array(const struct device_node *np,
 +			const char *propname, u8 *out_values, size_t sz)
  {
 -	uint32_t count = 0;
 +	const u8 *val = of_find_property_value_of_size(np, propname,
 +						(sz * sizeof(*out_values)));
  
 -	if (it->node) {
 -		of_node_put(it->node);
 -		it->node = NULL;
 -	}
 +	if (IS_ERR(val))
 +		return PTR_ERR(val);
  
 -	if (!it->cur || it->phandle_end >= it->list_end)
 -		return -ENOENT;
 +	while (sz--)
 +		*out_values++ = *val++;
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(of_property_read_u8_array);
  
 -	it->cur = it->phandle_end;
 +/**
 + * of_property_read_u16_array - Find and read an array of u16 from a property.
 + *
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + * @out_value:	pointer to return value, modified only if return value is 0.
 + * @sz:		number of array elements to read
 + *
 + * Search for a property in a device node and read 16-bit value(s) from
 + * it. Returns 0 on success, -EINVAL if the property does not exist,
 + * -ENODATA if property does not have a value, and -EOVERFLOW if the
 + * property data isn't large enough.
 + *
 + * dts entry of array should be like:
 + *	property = /bits/ 16 <0x5000 0x6000 0x7000>;
 + *
 + * The out_value is modified only if a valid u16 value can be decoded.
 + */
 +int of_property_read_u16_array(const struct device_node *np,
 +			const char *propname, u16 *out_values, size_t sz)
 +{
 +	const __be16 *val = of_find_property_value_of_size(np, propname,
 +						(sz * sizeof(*out_values)));
  
 -	/* If phandle is 0, then it is an empty entry with no arguments. */
 -	it->phandle = be32_to_cpup(it->cur++);
 +	if (IS_ERR(val))
 +		return PTR_ERR(val);
  
 -	if (it->phandle) {
 +	while (sz--)
 +		*out_values++ = be16_to_cpup(val++);
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(of_property_read_u16_array);
  
 -		/*
 -		 * Find the provider node and parse the #*-cells property to
 -		 * determine the argument length.
 -		 */
 -		it->node = of_find_node_by_phandle(it->phandle);
 +/**
 + * of_property_read_u32_array - Find and read an array of 32 bit integers
 + * from a property.
 + *
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + * @out_value:	pointer to return value, modified only if return value is 0.
 + * @sz:		number of array elements to read
 + *
 + * Search for a property in a device node and read 32-bit value(s) from
 + * it. Returns 0 on success, -EINVAL if the property does not exist,
 + * -ENODATA if property does not have a value, and -EOVERFLOW if the
 + * property data isn't large enough.
 + *
 + * The out_value is modified only if a valid u32 value can be decoded.
 + */
 +int of_property_read_u32_array(const struct device_node *np,
 +			       const char *propname, u32 *out_values,
 +			       size_t sz)
 +{
 +	const __be32 *val = of_find_property_value_of_size(np, propname,
 +						(sz * sizeof(*out_values)));
  
 -		if (it->cells_name) {
 -			if (!it->node) {
 -				pr_err("%pOF: could not find phandle\n",
 -				       it->parent);
 +	if (IS_ERR(val))
 +		return PTR_ERR(val);
 +
 +	while (sz--)
 +		*out_values++ = be32_to_cpup(val++);
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(of_property_read_u32_array);
 +
 +/**
 + * of_property_read_u64 - Find and read a 64 bit integer from a property
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + * @out_value:	pointer to return value, modified only if return value is 0.
 + *
 + * Search for a property in a device node and read a 64-bit value from
 + * it. Returns 0 on success, -EINVAL if the property does not exist,
 + * -ENODATA if property does not have a value, and -EOVERFLOW if the
 + * property data isn't large enough.
 + *
 + * The out_value is modified only if a valid u64 value can be decoded.
 + */
 +int of_property_read_u64(const struct device_node *np, const char *propname,
 +			 u64 *out_value)
 +{
 +	const __be32 *val = of_find_property_value_of_size(np, propname,
 +						sizeof(*out_value));
 +
 +	if (IS_ERR(val))
 +		return PTR_ERR(val);
 +
 +	*out_value = of_read_number(val, 2);
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(of_property_read_u64);
 +
 +/**
 + * of_property_read_u64_array - Find and read an array of 64 bit integers
 + * from a property.
 + *
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + * @out_values:	pointer to return value, modified only if return value is 0.
 + * @sz:		number of array elements to read
 + *
 + * Search for a property in a device node and read 64-bit value(s) from
 + * it. Returns 0 on success, -EINVAL if the property does not exist,
 + * -ENODATA if property does not have a value, and -EOVERFLOW if the
 + * property data isn't large enough.
 + *
 + * The out_values is modified only if a valid u64 value can be decoded.
 + */
 +int of_property_read_u64_array(const struct device_node *np,
 +			       const char *propname, u64 *out_values,
 +			       size_t sz)
 +{
 +	const __be32 *val = of_find_property_value_of_size(np, propname,
 +						(sz * sizeof(*out_values)));
 +
 +	if (IS_ERR(val))
 +		return PTR_ERR(val);
 +
 +	while (sz--) {
 +		*out_values++ = of_read_number(val, 2);
 +		val += 2;
 +	}
 +	return 0;
 +}
 +
 +/**
 + * of_property_read_string - Find and read a string from a property
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + * @out_string:	pointer to null terminated return string, modified only if
 + *		return value is 0.
 + *
 + * Search for a property in a device tree node and retrieve a null
 + * terminated string value (pointer to data, not a copy). Returns 0 on
 + * success, -EINVAL if the property does not exist, -ENODATA if property
 + * does not have a value, and -EILSEQ if the string is not null-terminated
 + * within the length of the property data.
 + *
 + * The out_string pointer is modified only if a valid string can be decoded.
 + */
 +int of_property_read_string(struct device_node *np, const char *propname,
 +				const char **out_string)
 +{
 +	struct property *prop = of_find_property(np, propname, NULL);
 +	if (!prop)
 +		return -EINVAL;
 +	if (!prop->value)
 +		return -ENODATA;
 +	if (strnlen(prop->value, prop->length) >= prop->length)
 +		return -EILSEQ;
 +	*out_string = prop->value;
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(of_property_read_string);
 +
 +/**
 + * of_property_match_string() - Find string in a list and return index
 + * @np: pointer to node containing string list property
 + * @propname: string list property name
 + * @string: pointer to string to search for in string list
 + *
 + * This function searches a string list property and returns the index
 + * of a specific string value.
 + */
 +int of_property_match_string(struct device_node *np, const char *propname,
 +			     const char *string)
 +{
 +	struct property *prop = of_find_property(np, propname, NULL);
 +	size_t l;
 +	int i;
++<<<<<<< HEAD
 +	const char *p, *end;
++=======
++	printk("%s %pOF", msg, args->np);
++	for (i = 0; i < args->args_count; i++) {
++		const char delim = i ? ',' : ':';
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
 +
 +	if (!prop)
 +		return -EINVAL;
 +	if (!prop->value)
 +		return -ENODATA;
 +
 +	p = prop->value;
 +	end = p + prop->length;
 +
 +	for (i = 0; p < end; i++, p += l) {
 +		l = strnlen(p, end - p) + 1;
 +		if (p + l > end)
 +			return -EILSEQ;
 +		pr_debug("comparing %s with %s\n", string, p);
 +		if (strcmp(string, p) == 0)
 +			return i; /* Found it; return index */
 +	}
 +	return -ENODATA;
 +}
 +EXPORT_SYMBOL_GPL(of_property_match_string);
 +
 +/**
 + * of_property_read_string_util() - Utility helper for parsing string properties
 + * @np:		device node from which the property value is to be read.
 + * @propname:	name of the property to be searched.
 + * @out_strs:	output array of string pointers.
 + * @sz:		number of array elements to read.
 + * @skip:	Number of strings to skip over at beginning of list.
 + *
 + * Don't call this function directly. It is a utility helper for the
 + * of_property_read_string*() family of functions.
 + */
 +int of_property_read_string_helper(struct device_node *np, const char *propname,
 +				   const char **out_strs, size_t sz, int skip)
 +{
 +	struct property *prop = of_find_property(np, propname, NULL);
 +	int l = 0, i = 0;
 +	const char *p, *end;
 +
 +	if (!prop)
 +		return -EINVAL;
 +	if (!prop->value)
 +		return -ENODATA;
 +	p = prop->value;
 +	end = p + prop->length;
 +
 +	for (i = 0; p < end && (!out_strs || i < skip + sz); i++, p += l) {
 +		l = strnlen(p, end - p) + 1;
 +		if (p + l > end)
 +			return -EILSEQ;
 +		if (out_strs && i >= skip)
 +			*out_strs++ = p;
 +	}
++<<<<<<< HEAD
 +	i -= skip;
 +	return i <= 0 ? -ENODATA : i;
++=======
++
++	if (!it->cur || it->phandle_end >= it->list_end)
++		return -ENOENT;
++
++	it->cur = it->phandle_end;
++
++	/* If phandle is 0, then it is an empty entry with no arguments. */
++	it->phandle = be32_to_cpup(it->cur++);
++
++	if (it->phandle) {
++
++		/*
++		 * Find the provider node and parse the #*-cells property to
++		 * determine the argument length.
++		 */
++		it->node = of_find_node_by_phandle(it->phandle);
++
++		if (it->cells_name) {
++			if (!it->node) {
++				pr_err("%pOF: could not find phandle\n",
++				       it->parent);
+ 				goto err;
+ 			}
+ 
+ 			if (of_property_read_u32(it->node, it->cells_name,
+ 						 &count)) {
+ 				pr_err("%pOF: could not get %s for %pOF\n",
+ 				       it->parent,
+ 				       it->cells_name,
+ 				       it->node);
+ 				goto err;
+ 			}
+ 		} else {
+ 			count = it->cell_count;
+ 		}
+ 
+ 		/*
+ 		 * Make sure that the arguments actually fit in the remaining
+ 		 * property data length
+ 		 */
+ 		if (it->cur + count > it->list_end) {
+ 			pr_err("%pOF: arguments longer than property\n",
+ 			       it->parent);
+ 			goto err;
+ 		}
+ 	}
+ 
+ 	it->phandle_end = it->cur + count;
+ 	it->cur_count = count;
+ 
+ 	return 0;
+ 
+ err:
+ 	if (it->node) {
+ 		of_node_put(it->node);
+ 		it->node = NULL;
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ EXPORT_SYMBOL_GPL(of_phandle_iterator_next);
+ 
+ int of_phandle_iterator_args(struct of_phandle_iterator *it,
+ 			     uint32_t *args,
+ 			     int size)
+ {
+ 	int i, count;
+ 
+ 	count = it->cur_count;
+ 
+ 	if (WARN_ON(size < count))
+ 		count = size;
+ 
+ 	for (i = 0; i < count; i++)
+ 		args[i] = be32_to_cpup(it->cur++);
+ 
+ 	return count;
+ }
+ 
+ static int __of_parse_phandle_with_args(const struct device_node *np,
+ 					const char *list_name,
+ 					const char *cells_name,
+ 					int cell_count, int index,
+ 					struct of_phandle_args *out_args)
+ {
+ 	struct of_phandle_iterator it;
+ 	int rc, cur_index = 0;
+ 
+ 	/* Loop over the phandles until all the requested entry is found */
+ 	of_for_each_phandle(&it, rc, np, list_name, cells_name, cell_count) {
+ 		/*
+ 		 * All of the error cases bail out of the loop, so at
+ 		 * this point, the parsing is successful. If the requested
+ 		 * index matches, then fill the out_args structure and return,
+ 		 * or return -ENOENT for an empty entry.
+ 		 */
+ 		rc = -ENOENT;
+ 		if (cur_index == index) {
+ 			if (!it.phandle)
+ 				goto err;
+ 
+ 			if (out_args) {
+ 				int c;
+ 
+ 				c = of_phandle_iterator_args(&it,
+ 							     out_args->args,
+ 							     MAX_PHANDLE_ARGS);
+ 				out_args->np = it.node;
+ 				out_args->args_count = c;
+ 			} else {
+ 				of_node_put(it.node);
+ 			}
+ 
+ 			/* Found it! return success */
+ 			return 0;
+ 		}
+ 
+ 		cur_index++;
+ 	}
+ 
+ 	/*
+ 	 * Unlock node before returning result; will be one of:
+ 	 * -ENOENT : index is for empty phandle
+ 	 * -EINVAL : parsing error on data
+ 	 */
+ 
+  err:
+ 	of_node_put(it.node);
+ 	return rc;
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  }
 +EXPORT_SYMBOL_GPL(of_property_read_string_helper);
  
  /**
   * of_parse_phandle - Resolve a phandle property to a device_node pointer
diff --cc drivers/of/irq.c
index 3c15317c39ad,9c4b32522bc2..000000000000
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@@ -126,10 -131,10 +126,14 @@@ int of_irq_map_raw(struct device_node *
  		goto fail;
  	}
  
++<<<<<<< HEAD
 +	pr_debug("of_irq_map_raw: ipar=%s, size=%d\n", of_node_full_name(ipar), intsize);
++=======
+ 	pr_debug("of_irq_parse_raw: ipar=%pOF, size=%d\n", ipar, intsize);
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  
 -	if (out_irq->args_count != intsize)
 -		goto fail;
 +	if (ointsize != intsize)
 +		return -EINVAL;
  
  	/* Look for this #address-cells. We have to implement the old linux
  	 * trick of looking for the parent here as some device-trees rely on it
@@@ -257,7 -268,8 +261,12 @@@
  
  	skiplevel:
  		/* Iterate again with new parent */
++<<<<<<< HEAD
 +		pr_debug(" -> new parent: %s\n", of_node_full_name(newpar));
++=======
+ 		out_irq->np = newpar;
+ 		pr_debug(" -> new parent: %pOF\n", newpar);
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  		of_node_put(ipar);
  		ipar = newpar;
  		newpar = NULL;
@@@ -285,9 -299,9 +294,13 @@@ int of_irq_map_one(struct device_node *
  	struct device_node *p;
  	const __be32 *intspec, *tmp, *addr;
  	u32 intsize, intlen;
 -	int i, res;
 +	int res = -EINVAL;
  
++<<<<<<< HEAD
 +	pr_debug("of_irq_map_one: dev=%s, index=%d\n", of_node_full_name(device), index);
++=======
+ 	pr_debug("of_irq_parse_one: dev=%pOF, index=%d\n", device, index);
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  
  	/* OldWorld mac stuff is "special", handle out of line */
  	if (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)
@@@ -456,20 -552,16 +469,27 @@@ void __init of_irq_init(const struct of
  				continue;
  
  			list_del(&desc->list);
 +			match = of_match_node(matches, desc->dev);
 +			if (WARN(!match->data,
 +			    "of_irq_init: no init function for %s\n",
 +			    match->compatible)) {
 +				kfree(desc);
 +				continue;
 +			}
  
++<<<<<<< HEAD
 +			pr_debug("of_irq_init: init %s @ %p, parent %p\n",
 +				 match->compatible,
++=======
+ 			of_node_set_flag(desc->dev, OF_POPULATED);
+ 
+ 			pr_debug("of_irq_init: init %pOF (%p), parent %p\n",
+ 				 desc->dev,
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  				 desc->dev, desc->interrupt_parent);
 -			ret = desc->irq_init_cb(desc->dev,
 -						desc->interrupt_parent);
 +			irq_init_cb = (of_irq_init_cb_t)match->data;
 +			ret = irq_init_cb(desc->dev, desc->interrupt_parent);
  			if (ret) {
 -				of_node_clear_flag(desc->dev, OF_POPULATED);
  				kfree(desc);
  				continue;
  			}
diff --cc drivers/of/of_mdio.c
index f996232149b2,754b9d6cd1cd..000000000000
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@@ -22,6 -25,158 +22,159 @@@
  MODULE_AUTHOR("Grant Likely <grant.likely@secretlab.ca>");
  MODULE_LICENSE("GPL");
  
++<<<<<<< HEAD
++=======
+ /* Extract the clause 22 phy ID from the compatible string of the form
+  * ethernet-phy-idAAAA.BBBB */
+ static int of_get_phy_id(struct device_node *device, u32 *phy_id)
+ {
+ 	struct property *prop;
+ 	const char *cp;
+ 	unsigned int upper, lower;
+ 
+ 	of_property_for_each_string(device, "compatible", prop, cp) {
+ 		if (sscanf(cp, "ethernet-phy-id%4x.%4x", &upper, &lower) == 2) {
+ 			*phy_id = ((upper & 0xFFFF) << 16) | (lower & 0xFFFF);
+ 			return 0;
+ 		}
+ 	}
+ 	return -EINVAL;
+ }
+ 
+ static void of_mdiobus_register_phy(struct mii_bus *mdio,
+ 				    struct device_node *child, u32 addr)
+ {
+ 	struct phy_device *phy;
+ 	bool is_c45;
+ 	int rc;
+ 	u32 phy_id;
+ 
+ 	is_c45 = of_device_is_compatible(child,
+ 					 "ethernet-phy-ieee802.3-c45");
+ 
+ 	if (!is_c45 && !of_get_phy_id(child, &phy_id))
+ 		phy = phy_device_create(mdio, addr, phy_id, 0, NULL);
+ 	else
+ 		phy = get_phy_device(mdio, addr, is_c45);
+ 	if (IS_ERR(phy))
+ 		return;
+ 
+ 	rc = irq_of_parse_and_map(child, 0);
+ 	if (rc > 0) {
+ 		phy->irq = rc;
+ 		mdio->irq[addr] = rc;
+ 	} else {
+ 		phy->irq = mdio->irq[addr];
+ 	}
+ 
+ 	if (of_property_read_bool(child, "broken-turn-around"))
+ 		mdio->phy_ignore_ta_mask |= 1 << addr;
+ 
+ 	/* Associate the OF node with the device structure so it
+ 	 * can be looked up later */
+ 	of_node_get(child);
+ 	phy->mdio.dev.of_node = child;
+ 
+ 	/* All data is now stored in the phy struct;
+ 	 * register it */
+ 	rc = phy_device_register(phy);
+ 	if (rc) {
+ 		phy_device_free(phy);
+ 		of_node_put(child);
+ 		return;
+ 	}
+ 
+ 	dev_dbg(&mdio->dev, "registered phy %s at address %i\n",
+ 		child->name, addr);
+ }
+ 
+ static void of_mdiobus_register_device(struct mii_bus *mdio,
+ 				       struct device_node *child, u32 addr)
+ {
+ 	struct mdio_device *mdiodev;
+ 	int rc;
+ 
+ 	mdiodev = mdio_device_create(mdio, addr);
+ 	if (IS_ERR(mdiodev))
+ 		return;
+ 
+ 	/* Associate the OF node with the device structure so it
+ 	 * can be looked up later.
+ 	 */
+ 	of_node_get(child);
+ 	mdiodev->dev.of_node = child;
+ 
+ 	/* All data is now stored in the mdiodev struct; register it. */
+ 	rc = mdio_device_register(mdiodev);
+ 	if (rc) {
+ 		mdio_device_free(mdiodev);
+ 		of_node_put(child);
+ 		return;
+ 	}
+ 
+ 	dev_dbg(&mdio->dev, "registered mdio device %s at address %i\n",
+ 		child->name, addr);
+ }
+ 
+ /* The following is a list of PHY compatible strings which appear in
+  * some DTBs. The compatible string is never matched against a PHY
+  * driver, so is pointless. We only expect devices which are not PHYs
+  * to have a compatible string, so they can be matched to an MDIO
+  * driver.  Encourage users to upgrade their DT blobs to remove these.
+  */
+ static const struct of_device_id whitelist_phys[] = {
+ 	{ .compatible = "brcm,40nm-ephy" },
+ 	{ .compatible = "broadcom,bcm5241" },
+ 	{ .compatible = "marvell,88E1111", },
+ 	{ .compatible = "marvell,88e1116", },
+ 	{ .compatible = "marvell,88e1118", },
+ 	{ .compatible = "marvell,88e1145", },
+ 	{ .compatible = "marvell,88e1149r", },
+ 	{ .compatible = "marvell,88e1310", },
+ 	{ .compatible = "marvell,88E1510", },
+ 	{ .compatible = "marvell,88E1514", },
+ 	{ .compatible = "moxa,moxart-rtl8201cp", },
+ 	{}
+ };
+ 
+ /*
+  * Return true if the child node is for a phy. It must either:
+  * o Compatible string of "ethernet-phy-idX.X"
+  * o Compatible string of "ethernet-phy-ieee802.3-c45"
+  * o Compatible string of "ethernet-phy-ieee802.3-c22"
+  * o In the white list above (and issue a warning)
+  * o No compatibility string
+  *
+  * A device which is not a phy is expected to have a compatible string
+  * indicating what sort of device it is.
+  */
+ static bool of_mdiobus_child_is_phy(struct device_node *child)
+ {
+ 	u32 phy_id;
+ 
+ 	if (of_get_phy_id(child, &phy_id) != -EINVAL)
+ 		return true;
+ 
+ 	if (of_device_is_compatible(child, "ethernet-phy-ieee802.3-c45"))
+ 		return true;
+ 
+ 	if (of_device_is_compatible(child, "ethernet-phy-ieee802.3-c22"))
+ 		return true;
+ 
+ 	if (of_match_node(whitelist_phys, child)) {
+ 		pr_warn(FW_WARN
+ 			"%pOF: Whitelisted compatible string. Please remove\n",
+ 			child);
+ 		return true;
+ 	}
+ 
+ 	if (!of_find_property(child, "compatible", NULL))
+ 		return true;
+ 
+ 	return false;
+ }
+ 
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  /**
   * of_mdiobus_register - Register mii_bus and create PHYs from the device tree
   * @mdio: pointer to mii_bus structure
diff --cc drivers/of/of_pci.c
index 46956375720a,3d4cb7090878..000000000000
--- a/drivers/of/of_pci.c
+++ b/drivers/of/of_pci.c
@@@ -89,47 -94,294 +89,287 @@@ int of_pci_parse_bus_range(struct devic
  }
  EXPORT_SYMBOL_GPL(of_pci_parse_bus_range);
  
 -/**
 - * This function will try to obtain the host bridge domain number by
 - * finding a property called "linux,pci-domain" of the given device node.
 - *
 - * @node: device tree node with the domain information
 - *
 - * Returns the associated domain number from DT in the range [0-0xffff], or
 - * a negative value if the required property is not found.
 - */
 -int of_get_pci_domain_nr(struct device_node *node)
 -{
 -	const __be32 *value;
 -	int len;
 -	u16 domain;
 +#ifdef CONFIG_PCI_MSI
 +
 +static LIST_HEAD(of_pci_msi_chip_list);
 +static DEFINE_MUTEX(of_pci_msi_chip_mutex);
  
 -	value = of_get_property(node, "linux,pci-domain", &len);
 -	if (!value || len < sizeof(*value))
 +int of_pci_msi_chip_add(struct msi_controller *chip)
 +{
 +	if (!of_property_read_bool(chip->of_node, "msi-controller"))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	mutex_lock(&of_pci_msi_chip_mutex);
 +	list_add(&chip->list, &of_pci_msi_chip_list);
 +	mutex_unlock(&of_pci_msi_chip_mutex);
++=======
+ 	domain = (u16)be32_to_cpup(value);
+ 
+ 	return domain;
+ }
+ EXPORT_SYMBOL_GPL(of_get_pci_domain_nr);
+ 
+ /**
+  * This function will try to find the limitation of link speed by finding
+  * a property called "max-link-speed" of the given device node.
+  *
+  * @node: device tree node with the max link speed information
+  *
+  * Returns the associated max link speed from DT, or a negative value if the
+  * required property is not found or is invalid.
+  */
+ int of_pci_get_max_link_speed(struct device_node *node)
+ {
+ 	u32 max_link_speed;
+ 
+ 	if (of_property_read_u32(node, "max-link-speed", &max_link_speed) ||
+ 	    max_link_speed > 4)
+ 		return -EINVAL;
+ 
+ 	return max_link_speed;
+ }
+ EXPORT_SYMBOL_GPL(of_pci_get_max_link_speed);
+ 
+ /**
+  * of_pci_check_probe_only - Setup probe only mode if linux,pci-probe-only
+  *                           is present and valid
+  */
+ void of_pci_check_probe_only(void)
+ {
+ 	u32 val;
+ 	int ret;
+ 
+ 	ret = of_property_read_u32(of_chosen, "linux,pci-probe-only", &val);
+ 	if (ret) {
+ 		if (ret == -ENODATA || ret == -EOVERFLOW)
+ 			pr_warn("linux,pci-probe-only without valid value, ignoring\n");
+ 		return;
+ 	}
+ 
+ 	if (val)
+ 		pci_add_flags(PCI_PROBE_ONLY);
+ 	else
+ 		pci_clear_flags(PCI_PROBE_ONLY);
+ 
+ 	pr_info("PROBE_ONLY %sabled\n", val ? "en" : "dis");
+ }
+ EXPORT_SYMBOL_GPL(of_pci_check_probe_only);
+ 
+ #if defined(CONFIG_OF_ADDRESS)
+ /**
+  * of_pci_get_host_bridge_resources - Parse PCI host bridge resources from DT
+  * @dev: device node of the host bridge having the range property
+  * @busno: bus number associated with the bridge root bus
+  * @bus_max: maximum number of buses for this bridge
+  * @resources: list where the range of resources will be added after DT parsing
+  * @io_base: pointer to a variable that will contain on return the physical
+  * address for the start of the I/O range. Can be NULL if the caller doesn't
+  * expect IO ranges to be present in the device tree.
+  *
+  * It is the caller's job to free the @resources list.
+  *
+  * This function will parse the "ranges" property of a PCI host bridge device
+  * node and setup the resource mapping based on its content. It is expected
+  * that the property conforms with the Power ePAPR document.
+  *
+  * It returns zero if the range parsing has been successful or a standard error
+  * value if it failed.
+  */
+ int of_pci_get_host_bridge_resources(struct device_node *dev,
+ 			unsigned char busno, unsigned char bus_max,
+ 			struct list_head *resources, resource_size_t *io_base)
+ {
+ 	struct resource_entry *window;
+ 	struct resource *res;
+ 	struct resource *bus_range;
+ 	struct of_pci_range range;
+ 	struct of_pci_range_parser parser;
+ 	char range_type[4];
+ 	int err;
+ 
+ 	if (io_base)
+ 		*io_base = (resource_size_t)OF_BAD_ADDR;
+ 
+ 	bus_range = kzalloc(sizeof(*bus_range), GFP_KERNEL);
+ 	if (!bus_range)
+ 		return -ENOMEM;
+ 
+ 	pr_info("host bridge %pOF ranges:\n", dev);
+ 
+ 	err = of_pci_parse_bus_range(dev, bus_range);
+ 	if (err) {
+ 		bus_range->start = busno;
+ 		bus_range->end = bus_max;
+ 		bus_range->flags = IORESOURCE_BUS;
+ 		pr_info("  No bus range found for %pOF, using %pR\n",
+ 			dev, bus_range);
+ 	} else {
+ 		if (bus_range->end > bus_range->start + bus_max)
+ 			bus_range->end = bus_range->start + bus_max;
+ 	}
+ 	pci_add_resource(resources, bus_range);
+ 
+ 	/* Check for ranges property */
+ 	err = of_pci_range_parser_init(&parser, dev);
+ 	if (err)
+ 		goto parse_failed;
+ 
+ 	pr_debug("Parsing ranges property...\n");
+ 	for_each_of_pci_range(&parser, &range) {
+ 		/* Read next ranges element */
+ 		if ((range.flags & IORESOURCE_TYPE_BITS) == IORESOURCE_IO)
+ 			snprintf(range_type, 4, " IO");
+ 		else if ((range.flags & IORESOURCE_TYPE_BITS) == IORESOURCE_MEM)
+ 			snprintf(range_type, 4, "MEM");
+ 		else
+ 			snprintf(range_type, 4, "err");
+ 		pr_info("  %s %#010llx..%#010llx -> %#010llx\n", range_type,
+ 			range.cpu_addr, range.cpu_addr + range.size - 1,
+ 			range.pci_addr);
+ 
+ 		/*
+ 		 * If we failed translation or got a zero-sized region
+ 		 * then skip this range
+ 		 */
+ 		if (range.cpu_addr == OF_BAD_ADDR || range.size == 0)
+ 			continue;
+ 
+ 		res = kzalloc(sizeof(struct resource), GFP_KERNEL);
+ 		if (!res) {
+ 			err = -ENOMEM;
+ 			goto parse_failed;
+ 		}
+ 
+ 		err = of_pci_range_to_resource(&range, dev, res);
+ 		if (err) {
+ 			kfree(res);
+ 			continue;
+ 		}
+ 
+ 		if (resource_type(res) == IORESOURCE_IO) {
+ 			if (!io_base) {
+ 				pr_err("I/O range found for %pOF. Please provide an io_base pointer to save CPU base address\n",
+ 					dev);
+ 				err = -EINVAL;
+ 				goto conversion_failed;
+ 			}
+ 			if (*io_base != (resource_size_t)OF_BAD_ADDR)
+ 				pr_warn("More than one I/O resource converted for %pOF. CPU base address for old range lost!\n",
+ 					dev);
+ 			*io_base = range.cpu_addr;
+ 		}
+ 
+ 		pci_add_resource_offset(resources, res,	res->start - range.pci_addr);
+ 	}
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  
  	return 0;
 -
 -conversion_failed:
 -	kfree(res);
 -parse_failed:
 -	resource_list_for_each_entry(window, resources)
 -		kfree(window->res);
 -	pci_free_resource_list(resources);
 -	return err;
  }
 -EXPORT_SYMBOL_GPL(of_pci_get_host_bridge_resources);
 -#endif /* CONFIG_OF_ADDRESS */
 +EXPORT_SYMBOL_GPL(of_pci_msi_chip_add);
  
 -/**
 - * of_pci_map_rid - Translate a requester ID through a downstream mapping.
 - * @np: root complex device node.
 - * @rid: PCI requester ID to map.
 - * @map_name: property name of the map to use.
 - * @map_mask_name: optional property name of the mask to use.
 - * @target: optional pointer to a target device node.
 - * @id_out: optional pointer to receive the translated ID.
 - *
 - * Given a PCI requester ID, look up the appropriate implementation-defined
 - * platform ID and/or the target device which receives transactions on that
 - * ID, as per the "iommu-map" and "msi-map" bindings. Either of @target or
 - * @id_out may be NULL if only the other is required. If @target points to
 - * a non-NULL device node pointer, only entries targeting that node will be
 - * matched; if it points to a NULL value, it will receive the device node of
 - * the first matching target phandle, with a reference held.
 - *
 - * Return: 0 on success or a standard error code on failure.
 - */
 -int of_pci_map_rid(struct device_node *np, u32 rid,
 -		   const char *map_name, const char *map_mask_name,
 -		   struct device_node **target, u32 *id_out)
 +void of_pci_msi_chip_remove(struct msi_controller *chip)
  {
++<<<<<<< HEAD
 +	mutex_lock(&of_pci_msi_chip_mutex);
 +	list_del(&chip->list);
 +	mutex_unlock(&of_pci_msi_chip_mutex);
++=======
+ 	u32 map_mask, masked_rid;
+ 	int map_len;
+ 	const __be32 *map = NULL;
+ 
+ 	if (!np || !map_name || (!target && !id_out))
+ 		return -EINVAL;
+ 
+ 	map = of_get_property(np, map_name, &map_len);
+ 	if (!map) {
+ 		if (target)
+ 			return -ENODEV;
+ 		/* Otherwise, no map implies no translation */
+ 		*id_out = rid;
+ 		return 0;
+ 	}
+ 
+ 	if (!map_len || map_len % (4 * sizeof(*map))) {
+ 		pr_err("%pOF: Error: Bad %s length: %d\n", np,
+ 			map_name, map_len);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* The default is to select all bits. */
+ 	map_mask = 0xffffffff;
+ 
+ 	/*
+ 	 * Can be overridden by "{iommu,msi}-map-mask" property.
+ 	 * If of_property_read_u32() fails, the default is used.
+ 	 */
+ 	if (map_mask_name)
+ 		of_property_read_u32(np, map_mask_name, &map_mask);
+ 
+ 	masked_rid = map_mask & rid;
+ 	for ( ; map_len > 0; map_len -= 4 * sizeof(*map), map += 4) {
+ 		struct device_node *phandle_node;
+ 		u32 rid_base = be32_to_cpup(map + 0);
+ 		u32 phandle = be32_to_cpup(map + 1);
+ 		u32 out_base = be32_to_cpup(map + 2);
+ 		u32 rid_len = be32_to_cpup(map + 3);
+ 
+ 		if (rid_base & ~map_mask) {
+ 			pr_err("%pOF: Invalid %s translation - %s-mask (0x%x) ignores rid-base (0x%x)\n",
+ 				np, map_name, map_name,
+ 				map_mask, rid_base);
+ 			return -EFAULT;
+ 		}
+ 
+ 		if (masked_rid < rid_base || masked_rid >= rid_base + rid_len)
+ 			continue;
+ 
+ 		phandle_node = of_find_node_by_phandle(phandle);
+ 		if (!phandle_node)
+ 			return -ENODEV;
+ 
+ 		if (target) {
+ 			if (*target)
+ 				of_node_put(phandle_node);
+ 			else
+ 				*target = phandle_node;
+ 
+ 			if (*target != phandle_node)
+ 				continue;
+ 		}
+ 
+ 		if (id_out)
+ 			*id_out = masked_rid - rid_base + out_base;
+ 
+ 		pr_debug("%pOF: %s, using mask %08x, rid-base: %08x, out-base: %08x, length: %08x, rid: %08x -> %08x\n",
+ 			np, map_name, map_mask, rid_base, out_base,
+ 			rid_len, rid, *id_out);
+ 		return 0;
+ 	}
+ 
+ 	pr_err("%pOF: Invalid %s translation - no match for rid 0x%x on %pOF\n",
+ 		np, map_name, rid, target && *target ? *target : NULL);
+ 	return -EFAULT;
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  }
 +EXPORT_SYMBOL_GPL(of_pci_msi_chip_remove);
 +
 +struct msi_controller *of_pci_find_msi_chip_by_node(struct device_node *of_node)
 +{
 +	struct msi_controller *c;
 +
 +	mutex_lock(&of_pci_msi_chip_mutex);
 +	list_for_each_entry(c, &of_pci_msi_chip_list, list) {
 +		if (c->of_node == of_node) {
 +			mutex_unlock(&of_pci_msi_chip_mutex);
 +			return c;
 +		}
 +	}
 +	mutex_unlock(&of_pci_msi_chip_mutex);
 +
 +	return NULL;
 +}
 +EXPORT_SYMBOL_GPL(of_pci_find_msi_chip_by_node);
 +
 +#endif /* CONFIG_PCI_MSI */
diff --cc drivers/of/platform.c
index f38c7a12636c,683b2e74bef7..000000000000
--- a/drivers/of/platform.c
+++ b/drivers/of/platform.c
@@@ -249,9 -228,10 +249,9 @@@ static struct amba_device *of_amba_devi
  	const void *prop;
  	int i, ret;
  
- 	pr_debug("Creating amba device %s\n", node->full_name);
+ 	pr_debug("Creating amba device %pOF\n", node);
  
 -	if (!of_device_is_available(node) ||
 -	    of_node_test_and_set_flag(node, OF_POPULATED))
 +	if (!of_device_is_available(node))
  		return NULL;
  
  	dev = amba_device_alloc(NULL, 0, 0);
@@@ -281,12 -258,18 +281,24 @@@
  		dev->irq[i] = irq_of_parse_and_map(node, i);
  
  	ret = of_address_to_resource(node, 0, &dev->res);
++<<<<<<< HEAD
 +	if (ret)
++=======
+ 	if (ret) {
+ 		pr_err("amba: of_address_to_resource() failed (%d) for %pOF\n",
+ 		       ret, node);
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  		goto err_free;
 -	}
  
  	ret = amba_device_add(dev, &iomem_resource);
++<<<<<<< HEAD
 +	if (ret)
++=======
+ 	if (ret) {
+ 		pr_err("amba_device_add() failed (%d) for %pOF\n",
+ 		       ret, node);
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  		goto err_free;
 -	}
  
  	return dev;
  
@@@ -315,14 -302,30 +327,33 @@@ static const struct of_dev_auxdata *of_
  	if (!lookup)
  		return NULL;
  
 -	auxdata = lookup;
 -	for (; auxdata->compatible; auxdata++) {
 -		if (!of_device_is_compatible(np, auxdata->compatible))
 +	for(; lookup->compatible != NULL; lookup++) {
 +		if (!of_device_is_compatible(np, lookup->compatible))
  			continue;
 -		compatible++;
  		if (!of_address_to_resource(np, 0, &res))
 -			if (res.start != auxdata->phys_addr)
 +			if (res.start != lookup->phys_addr)
  				continue;
++<<<<<<< HEAD
 +		pr_debug("%s: devname=%s\n", np->full_name, lookup->name);
 +		return lookup;
++=======
+ 		pr_debug("%pOF: devname=%s\n", np, auxdata->name);
+ 		return auxdata;
+ 	}
+ 
+ 	if (!compatible)
+ 		return NULL;
+ 
+ 	/* Try compatible match if no phys_addr and name are specified */
+ 	auxdata = lookup;
+ 	for (; auxdata->compatible; auxdata++) {
+ 		if (!of_device_is_compatible(np, auxdata->compatible))
+ 			continue;
+ 		if (!auxdata->phys_addr && !auxdata->name) {
+ 			pr_debug("%pOF: compatible match\n", np);
+ 			return auxdata;
+ 		}
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  	}
  
  	return NULL;
@@@ -358,6 -361,12 +389,15 @@@ static int of_platform_bus_create(struc
  		return 0;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (of_node_check_flag(bus, OF_POPULATED_BUS)) {
+ 		pr_debug("%s() - skipping %pOF, already populated\n",
+ 			__func__, bus);
+ 		return 0;
+ 	}
+ 
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  	auxdata = of_dev_lookup(lookup, bus);
  	if (auxdata) {
  		bus_id = auxdata->name;
@@@ -404,8 -418,8 +444,13 @@@ int of_platform_bus_probe(struct device
  	if (!root)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	pr_debug("of_platform_bus_probe()\n");
 +	pr_debug(" starting at: %s\n", root->full_name);
++=======
+ 	pr_debug("%s()\n", __func__);
+ 	pr_debug(" starting at: %pOF\n", root);
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  
  	/* Do a self check of bus type, if there's a match, create children */
  	if (of_match_node(matches, root)) {
@@@ -454,14 -470,233 +499,236 @@@ int of_platform_populate(struct device_
  	if (!root)
  		return -EINVAL;
  
++<<<<<<< HEAD
++=======
+ 	pr_debug("%s()\n", __func__);
+ 	pr_debug(" starting at: %pOF\n", root);
+ 
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  	for_each_child_of_node(root, child) {
  		rc = of_platform_bus_create(child, matches, lookup, parent, true);
 -		if (rc) {
 -			of_node_put(child);
 +		if (rc)
  			break;
 -		}
  	}
 -	of_node_set_flag(root, OF_POPULATED_BUS);
  
  	of_node_put(root);
  	return rc;
  }
  EXPORT_SYMBOL_GPL(of_platform_populate);
++<<<<<<< HEAD
++=======
+ 
+ int of_platform_default_populate(struct device_node *root,
+ 				 const struct of_dev_auxdata *lookup,
+ 				 struct device *parent)
+ {
+ 	return of_platform_populate(root, of_default_bus_match_table, lookup,
+ 				    parent);
+ }
+ EXPORT_SYMBOL_GPL(of_platform_default_populate);
+ 
+ #ifndef CONFIG_PPC
+ static int __init of_platform_default_populate_init(void)
+ {
+ 	struct device_node *node;
+ 
+ 	if (!of_have_populated_dt())
+ 		return -ENODEV;
+ 
+ 	/*
+ 	 * Handle ramoops explicitly, since it is inside /reserved-memory,
+ 	 * which lacks a "compatible" property.
+ 	 */
+ 	node = of_find_node_by_path("/reserved-memory");
+ 	if (node) {
+ 		node = of_find_compatible_node(node, NULL, "ramoops");
+ 		if (node)
+ 			of_platform_device_create(node, NULL, NULL);
+ 	}
+ 
+ 	/* Populate everything else. */
+ 	of_platform_default_populate(NULL, NULL, NULL);
+ 
+ 	return 0;
+ }
+ arch_initcall_sync(of_platform_default_populate_init);
+ #endif
+ 
+ int of_platform_device_destroy(struct device *dev, void *data)
+ {
+ 	/* Do not touch devices not populated from the device tree */
+ 	if (!dev->of_node || !of_node_check_flag(dev->of_node, OF_POPULATED))
+ 		return 0;
+ 
+ 	/* Recurse for any nodes that were treated as busses */
+ 	if (of_node_check_flag(dev->of_node, OF_POPULATED_BUS))
+ 		device_for_each_child(dev, NULL, of_platform_device_destroy);
+ 
+ 	if (dev->bus == &platform_bus_type)
+ 		platform_device_unregister(to_platform_device(dev));
+ #ifdef CONFIG_ARM_AMBA
+ 	else if (dev->bus == &amba_bustype)
+ 		amba_device_unregister(to_amba_device(dev));
+ #endif
+ 
+ 	of_node_clear_flag(dev->of_node, OF_POPULATED);
+ 	of_node_clear_flag(dev->of_node, OF_POPULATED_BUS);
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(of_platform_device_destroy);
+ 
+ /**
+  * of_platform_depopulate() - Remove devices populated from device tree
+  * @parent: device which children will be removed
+  *
+  * Complementary to of_platform_populate(), this function removes children
+  * of the given device (and, recurrently, their children) that have been
+  * created from their respective device tree nodes (and only those,
+  * leaving others - eg. manually created - unharmed).
+  */
+ void of_platform_depopulate(struct device *parent)
+ {
+ 	if (parent->of_node && of_node_check_flag(parent->of_node, OF_POPULATED_BUS)) {
+ 		device_for_each_child(parent, NULL, of_platform_device_destroy);
+ 		of_node_clear_flag(parent->of_node, OF_POPULATED_BUS);
+ 	}
+ }
+ EXPORT_SYMBOL_GPL(of_platform_depopulate);
+ 
+ static void devm_of_platform_populate_release(struct device *dev, void *res)
+ {
+ 	of_platform_depopulate(*(struct device **)res);
+ }
+ 
+ /**
+  * devm_of_platform_populate() - Populate platform_devices from device tree data
+  * @dev: device that requested to populate from device tree data
+  *
+  * Similar to of_platform_populate(), but will automatically call
+  * of_platform_depopulate() when the device is unbound from the bus.
+  *
+  * Returns 0 on success, < 0 on failure.
+  */
+ int devm_of_platform_populate(struct device *dev)
+ {
+ 	struct device **ptr;
+ 	int ret;
+ 
+ 	if (!dev)
+ 		return -EINVAL;
+ 
+ 	ptr = devres_alloc(devm_of_platform_populate_release,
+ 			   sizeof(*ptr), GFP_KERNEL);
+ 	if (!ptr)
+ 		return -ENOMEM;
+ 
+ 	ret = of_platform_populate(dev->of_node, NULL, NULL, dev);
+ 	if (ret) {
+ 		devres_free(ptr);
+ 	} else {
+ 		*ptr = dev;
+ 		devres_add(dev, ptr);
+ 	}
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(devm_of_platform_populate);
+ 
+ static int devm_of_platform_match(struct device *dev, void *res, void *data)
+ {
+ 	struct device **ptr = res;
+ 
+ 	if (!ptr) {
+ 		WARN_ON(!ptr);
+ 		return 0;
+ 	}
+ 
+ 	return *ptr == data;
+ }
+ 
+ /**
+  * devm_of_platform_depopulate() - Remove devices populated from device tree
+  * @dev: device that requested to depopulate from device tree data
+  *
+  * Complementary to devm_of_platform_populate(), this function removes children
+  * of the given device (and, recurrently, their children) that have been
+  * created from their respective device tree nodes (and only those,
+  * leaving others - eg. manually created - unharmed).
+  */
+ void devm_of_platform_depopulate(struct device *dev)
+ {
+ 	int ret;
+ 
+ 	ret = devres_release(dev, devm_of_platform_populate_release,
+ 			     devm_of_platform_match, dev);
+ 
+ 	WARN_ON(ret);
+ }
+ EXPORT_SYMBOL_GPL(devm_of_platform_depopulate);
+ 
+ #ifdef CONFIG_OF_DYNAMIC
+ static int of_platform_notify(struct notifier_block *nb,
+ 				unsigned long action, void *arg)
+ {
+ 	struct of_reconfig_data *rd = arg;
+ 	struct platform_device *pdev_parent, *pdev;
+ 	bool children_left;
+ 
+ 	switch (of_reconfig_get_state_change(action, rd)) {
+ 	case OF_RECONFIG_CHANGE_ADD:
+ 		/* verify that the parent is a bus */
+ 		if (!of_node_check_flag(rd->dn->parent, OF_POPULATED_BUS))
+ 			return NOTIFY_OK;	/* not for us */
+ 
+ 		/* already populated? (driver using of_populate manually) */
+ 		if (of_node_check_flag(rd->dn, OF_POPULATED))
+ 			return NOTIFY_OK;
+ 
+ 		/* pdev_parent may be NULL when no bus platform device */
+ 		pdev_parent = of_find_device_by_node(rd->dn->parent);
+ 		pdev = of_platform_device_create(rd->dn, NULL,
+ 				pdev_parent ? &pdev_parent->dev : NULL);
+ 		of_dev_put(pdev_parent);
+ 
+ 		if (pdev == NULL) {
+ 			pr_err("%s: failed to create for '%pOF'\n",
+ 					__func__, rd->dn);
+ 			/* of_platform_device_create tosses the error code */
+ 			return notifier_from_errno(-EINVAL);
+ 		}
+ 		break;
+ 
+ 	case OF_RECONFIG_CHANGE_REMOVE:
+ 
+ 		/* already depopulated? */
+ 		if (!of_node_check_flag(rd->dn, OF_POPULATED))
+ 			return NOTIFY_OK;
+ 
+ 		/* find our device by node */
+ 		pdev = of_find_device_by_node(rd->dn);
+ 		if (pdev == NULL)
+ 			return NOTIFY_OK;	/* no? not meant for us */
+ 
+ 		/* unregister takes one ref away */
+ 		of_platform_device_destroy(&pdev->dev, &children_left);
+ 
+ 		/* and put the reference of the find */
+ 		of_dev_put(pdev);
+ 		break;
+ 	}
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ static struct notifier_block platform_of_notifier = {
+ 	.notifier_call = of_platform_notify,
+ };
+ 
+ void of_platform_register_reconfig_notifier(void)
+ {
+ 	WARN_ON(of_reconfig_notifier_register(&platform_of_notifier));
+ }
+ #endif /* CONFIG_OF_DYNAMIC */
+ 
++>>>>>>> 0d638a07d3a1 (of: Convert to using %pOF instead of full_name)
  #endif /* CONFIG_OF_ADDRESS */
* Unmerged path drivers/of/dynamic.c
* Unmerged path drivers/of/overlay.c
* Unmerged path drivers/of/property.c
* Unmerged path drivers/of/unittest.c
* Unmerged path drivers/of/address.c
* Unmerged path drivers/of/base.c
diff --git a/drivers/of/device.c b/drivers/of/device.c
index f685e55e0717..5acf5e7d2a63 100644
--- a/drivers/of/device.c
+++ b/drivers/of/device.c
@@ -139,7 +139,7 @@ void of_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 		return;
 
 	add_uevent_var(env, "OF_NAME=%s", dev->of_node->name);
-	add_uevent_var(env, "OF_FULLNAME=%s", dev->of_node->full_name);
+	add_uevent_var(env, "OF_FULLNAME=%pOF", dev->of_node);
 	if (dev->of_node->type && strcmp("<NULL>", dev->of_node->type) != 0)
 		add_uevent_var(env, "OF_TYPE=%s", dev->of_node->type);
 
* Unmerged path drivers/of/dynamic.c
* Unmerged path drivers/of/irq.c
* Unmerged path drivers/of/of_mdio.c
* Unmerged path drivers/of/of_pci.c
* Unmerged path drivers/of/overlay.c
* Unmerged path drivers/of/platform.c
* Unmerged path drivers/of/property.c
* Unmerged path drivers/of/unittest.c
