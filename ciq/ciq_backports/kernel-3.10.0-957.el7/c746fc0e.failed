cxgb4: add geneve offload support for T6

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ganesh Goudar <ganeshgr@chelsio.com>
commit c746fc0e8b2d144e2ee9122e4efd72326ff3cd1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c746fc0e.failed

Add geneve segmentation offload support of T6 cards.

Original work by: Santosh Rastapur <santosh@chelsio.com>
	Signed-off-by: Ganesh Goudar <ganeshgr@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c746fc0e8b2d144e2ee9122e4efd72326ff3cd1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
#	drivers/net/ethernet/chelsio/cxgb4/sge.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index 28baa6f532a1,3e0218735b2b..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@@ -833,6 -844,10 +833,13 @@@ struct adapter 
  	enum chip_type chip;
  
  	int msg_enable;
++<<<<<<< HEAD
++=======
+ 	__be16 vxlan_port;
+ 	u8 vxlan_port_cnt;
+ 	__be16 geneve_port;
+ 	u8 geneve_port_cnt;
++>>>>>>> c746fc0e8b2d (cxgb4: add geneve offload support for T6)
  
  	struct adapter_params params;
  	struct cxgb4_virt_res vres;
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 78a568c4dc20,4716387830ef..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -2939,6 -2964,205 +2939,208 @@@ static int cxgb_setup_tc(struct net_dev
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int cxgb_setup_tc_block(struct net_device *dev,
+ 			       struct tc_block_offload *f)
+ {
+ 	struct port_info *pi = netdev2pinfo(dev);
+ 
+ 	if (f->binder_type != TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (f->command) {
+ 	case TC_BLOCK_BIND:
+ 		return tcf_block_cb_register(f->block, cxgb_setup_tc_block_cb,
+ 					     pi, dev);
+ 	case TC_BLOCK_UNBIND:
+ 		tcf_block_cb_unregister(f->block, cxgb_setup_tc_block_cb, pi);
+ 		return 0;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int cxgb_setup_tc(struct net_device *dev, enum tc_setup_type type,
+ 			 void *type_data)
+ {
+ 	switch (type) {
+ 	case TC_SETUP_BLOCK:
+ 		return cxgb_setup_tc_block(dev, type_data);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static void cxgb_del_udp_tunnel(struct net_device *netdev,
+ 				struct udp_tunnel_info *ti)
+ {
+ 	struct port_info *pi = netdev_priv(netdev);
+ 	struct adapter *adapter = pi->adapter;
+ 	unsigned int chip_ver = CHELSIO_CHIP_VERSION(adapter->params.chip);
+ 	u8 match_all_mac[] = { 0, 0, 0, 0, 0, 0 };
+ 	int ret = 0, i;
+ 
+ 	if (chip_ver < CHELSIO_T6)
+ 		return;
+ 
+ 	switch (ti->type) {
+ 	case UDP_TUNNEL_TYPE_VXLAN:
+ 		if (!adapter->vxlan_port_cnt ||
+ 		    adapter->vxlan_port != ti->port)
+ 			return; /* Invalid VxLAN destination port */
+ 
+ 		adapter->vxlan_port_cnt--;
+ 		if (adapter->vxlan_port_cnt)
+ 			return;
+ 
+ 		adapter->vxlan_port = 0;
+ 		t4_write_reg(adapter, MPS_RX_VXLAN_TYPE_A, 0);
+ 		break;
+ 	case UDP_TUNNEL_TYPE_GENEVE:
+ 		if (!adapter->geneve_port_cnt ||
+ 		    adapter->geneve_port != ti->port)
+ 			return; /* Invalid GENEVE destination port */
+ 
+ 		adapter->geneve_port_cnt--;
+ 		if (adapter->geneve_port_cnt)
+ 			return;
+ 
+ 		adapter->geneve_port = 0;
+ 		t4_write_reg(adapter, MPS_RX_GENEVE_TYPE_A, 0);
+ 	default:
+ 		return;
+ 	}
+ 
+ 	/* Matchall mac entries can be deleted only after all tunnel ports
+ 	 * are brought down or removed.
+ 	 */
+ 	if (!adapter->rawf_cnt)
+ 		return;
+ 	for_each_port(adapter, i) {
+ 		pi = adap2pinfo(adapter, i);
+ 		ret = t4_free_raw_mac_filt(adapter, pi->viid,
+ 					   match_all_mac, match_all_mac,
+ 					   adapter->rawf_start +
+ 					    pi->port_id,
+ 					   1, pi->port_id, true);
+ 		if (ret < 0) {
+ 			netdev_info(netdev, "Failed to free mac filter entry, for port %d\n",
+ 				    i);
+ 			return;
+ 		}
+ 		atomic_dec(&adapter->mps_encap[adapter->rawf_start +
+ 			   pi->port_id].refcnt);
+ 	}
+ }
+ 
+ static void cxgb_add_udp_tunnel(struct net_device *netdev,
+ 				struct udp_tunnel_info *ti)
+ {
+ 	struct port_info *pi = netdev_priv(netdev);
+ 	struct adapter *adapter = pi->adapter;
+ 	unsigned int chip_ver = CHELSIO_CHIP_VERSION(adapter->params.chip);
+ 	u8 match_all_mac[] = { 0, 0, 0, 0, 0, 0 };
+ 	int i, ret;
+ 
+ 	if (chip_ver < CHELSIO_T6 || !adapter->rawf_cnt)
+ 		return;
+ 
+ 	switch (ti->type) {
+ 	case UDP_TUNNEL_TYPE_VXLAN:
+ 		/* Callback for adding vxlan port can be called with the same
+ 		 * port for both IPv4 and IPv6. We should not disable the
+ 		 * offloading when the same port for both protocols is added
+ 		 * and later one of them is removed.
+ 		 */
+ 		if (adapter->vxlan_port_cnt &&
+ 		    adapter->vxlan_port == ti->port) {
+ 			adapter->vxlan_port_cnt++;
+ 			return;
+ 		}
+ 
+ 		/* We will support only one VxLAN port */
+ 		if (adapter->vxlan_port_cnt) {
+ 			netdev_info(netdev, "UDP port %d already offloaded, not adding port %d\n",
+ 				    be16_to_cpu(adapter->vxlan_port),
+ 				    be16_to_cpu(ti->port));
+ 			return;
+ 		}
+ 
+ 		adapter->vxlan_port = ti->port;
+ 		adapter->vxlan_port_cnt = 1;
+ 
+ 		t4_write_reg(adapter, MPS_RX_VXLAN_TYPE_A,
+ 			     VXLAN_V(be16_to_cpu(ti->port)) | VXLAN_EN_F);
+ 		break;
+ 	case UDP_TUNNEL_TYPE_GENEVE:
+ 		if (adapter->geneve_port_cnt &&
+ 		    adapter->geneve_port == ti->port) {
+ 			adapter->geneve_port_cnt++;
+ 			return;
+ 		}
+ 
+ 		/* We will support only one GENEVE port */
+ 		if (adapter->geneve_port_cnt) {
+ 			netdev_info(netdev, "UDP port %d already offloaded, not adding port %d\n",
+ 				    be16_to_cpu(adapter->geneve_port),
+ 				    be16_to_cpu(ti->port));
+ 			return;
+ 		}
+ 
+ 		adapter->geneve_port = ti->port;
+ 		adapter->geneve_port_cnt = 1;
+ 
+ 		t4_write_reg(adapter, MPS_RX_GENEVE_TYPE_A,
+ 			     GENEVE_V(be16_to_cpu(ti->port)) | GENEVE_EN_F);
+ 	default:
+ 		return;
+ 	}
+ 
+ 	/* Create a 'match all' mac filter entry for inner mac,
+ 	 * if raw mac interface is supported. Once the linux kernel provides
+ 	 * driver entry points for adding/deleting the inner mac addresses,
+ 	 * we will remove this 'match all' entry and fallback to adding
+ 	 * exact match filters.
+ 	 */
+ 	for_each_port(adapter, i) {
+ 		pi = adap2pinfo(adapter, i);
+ 
+ 		ret = t4_alloc_raw_mac_filt(adapter, pi->viid,
+ 					    match_all_mac,
+ 					    match_all_mac,
+ 					    adapter->rawf_start +
+ 					    pi->port_id,
+ 					    1, pi->port_id, true);
+ 		if (ret < 0) {
+ 			netdev_info(netdev, "Failed to allocate a mac filter entry, not adding port %d\n",
+ 				    be16_to_cpu(ti->port));
+ 			cxgb_del_udp_tunnel(netdev, ti);
+ 			return;
+ 		}
+ 		atomic_inc(&adapter->mps_encap[ret].refcnt);
+ 	}
+ }
+ 
+ static netdev_features_t cxgb_features_check(struct sk_buff *skb,
+ 					     struct net_device *dev,
+ 					     netdev_features_t features)
+ {
+ 	struct port_info *pi = netdev_priv(dev);
+ 	struct adapter *adapter = pi->adapter;
+ 
+ 	if (CHELSIO_CHIP_VERSION(adapter->params.chip) < CHELSIO_T6)
+ 		return features;
+ 
+ 	/* Check if hw supports offload for this packet */
+ 	if (!skb->encapsulation || cxgb_encap_offload_supported(skb))
+ 		return features;
+ 
+ 	/* Offload is not supported for this encapsulated packet */
+ 	return features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);
+ }
+ 
++>>>>>>> c746fc0e8b2d (cxgb4: add geneve offload support for T6)
  static netdev_features_t cxgb_fix_features(struct net_device *dev,
  					   netdev_features_t features)
  {
diff --cc drivers/net/ethernet/chelsio/cxgb4/sge.c
index a64f3863f5c9,a7af71bf14fb..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/sge.c
@@@ -1119,6 -1138,137 +1119,140 @@@ static inline void txq_advance(struct s
  		q->pidx -= q->size;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_CHELSIO_T4_FCOE
+ static inline int
+ cxgb_fcoe_offload(struct sk_buff *skb, struct adapter *adap,
+ 		  const struct port_info *pi, u64 *cntrl)
+ {
+ 	const struct cxgb_fcoe *fcoe = &pi->fcoe;
+ 
+ 	if (!(fcoe->flags & CXGB_FCOE_ENABLED))
+ 		return 0;
+ 
+ 	if (skb->protocol != htons(ETH_P_FCOE))
+ 		return 0;
+ 
+ 	skb_reset_mac_header(skb);
+ 	skb->mac_len = sizeof(struct ethhdr);
+ 
+ 	skb_set_network_header(skb, skb->mac_len);
+ 	skb_set_transport_header(skb, skb->mac_len + sizeof(struct fcoe_hdr));
+ 
+ 	if (!cxgb_fcoe_sof_eof_supported(adap, skb))
+ 		return -ENOTSUPP;
+ 
+ 	/* FC CRC offload */
+ 	*cntrl = TXPKT_CSUM_TYPE_V(TX_CSUM_FCOE) |
+ 		     TXPKT_L4CSUM_DIS_F | TXPKT_IPCSUM_DIS_F |
+ 		     TXPKT_CSUM_START_V(CXGB_FCOE_TXPKT_CSUM_START) |
+ 		     TXPKT_CSUM_END_V(CXGB_FCOE_TXPKT_CSUM_END) |
+ 		     TXPKT_CSUM_LOC_V(CXGB_FCOE_TXPKT_CSUM_END);
+ 	return 0;
+ }
+ #endif /* CONFIG_CHELSIO_T4_FCOE */
+ 
+ /* Returns tunnel type if hardware supports offloading of the same.
+  * It is called only for T5 and onwards.
+  */
+ enum cpl_tx_tnl_lso_type cxgb_encap_offload_supported(struct sk_buff *skb)
+ {
+ 	u8 l4_hdr = 0;
+ 	enum cpl_tx_tnl_lso_type tnl_type = TX_TNL_TYPE_OPAQUE;
+ 	struct port_info *pi = netdev_priv(skb->dev);
+ 	struct adapter *adapter = pi->adapter;
+ 
+ 	if (skb->inner_protocol_type != ENCAP_TYPE_ETHER ||
+ 	    skb->inner_protocol != htons(ETH_P_TEB))
+ 		return tnl_type;
+ 
+ 	switch (vlan_get_protocol(skb)) {
+ 	case htons(ETH_P_IP):
+ 		l4_hdr = ip_hdr(skb)->protocol;
+ 		break;
+ 	case htons(ETH_P_IPV6):
+ 		l4_hdr = ipv6_hdr(skb)->nexthdr;
+ 		break;
+ 	default:
+ 		return tnl_type;
+ 	}
+ 
+ 	switch (l4_hdr) {
+ 	case IPPROTO_UDP:
+ 		if (adapter->vxlan_port == udp_hdr(skb)->dest)
+ 			tnl_type = TX_TNL_TYPE_VXLAN;
+ 		else if (adapter->geneve_port == udp_hdr(skb)->dest)
+ 			tnl_type = TX_TNL_TYPE_GENEVE;
+ 		break;
+ 	default:
+ 		return tnl_type;
+ 	}
+ 
+ 	return tnl_type;
+ }
+ 
+ static inline void t6_fill_tnl_lso(struct sk_buff *skb,
+ 				   struct cpl_tx_tnl_lso *tnl_lso,
+ 				   enum cpl_tx_tnl_lso_type tnl_type)
+ {
+ 	u32 val;
+ 	int in_eth_xtra_len;
+ 	int l3hdr_len = skb_network_header_len(skb);
+ 	int eth_xtra_len = skb_network_offset(skb) - ETH_HLEN;
+ 	const struct skb_shared_info *ssi = skb_shinfo(skb);
+ 	bool v6 = (ip_hdr(skb)->version == 6);
+ 
+ 	val = CPL_TX_TNL_LSO_OPCODE_V(CPL_TX_TNL_LSO) |
+ 	      CPL_TX_TNL_LSO_FIRST_F |
+ 	      CPL_TX_TNL_LSO_LAST_F |
+ 	      (v6 ? CPL_TX_TNL_LSO_IPV6OUT_F : 0) |
+ 	      CPL_TX_TNL_LSO_ETHHDRLENOUT_V(eth_xtra_len / 4) |
+ 	      CPL_TX_TNL_LSO_IPHDRLENOUT_V(l3hdr_len / 4) |
+ 	      (v6 ? 0 : CPL_TX_TNL_LSO_IPHDRCHKOUT_F) |
+ 	      CPL_TX_TNL_LSO_IPLENSETOUT_F |
+ 	      (v6 ? 0 : CPL_TX_TNL_LSO_IPIDINCOUT_F);
+ 	tnl_lso->op_to_IpIdSplitOut = htonl(val);
+ 
+ 	tnl_lso->IpIdOffsetOut = 0;
+ 
+ 	/* Get the tunnel header length */
+ 	val = skb_inner_mac_header(skb) - skb_mac_header(skb);
+ 	in_eth_xtra_len = skb_inner_network_header(skb) -
+ 			  skb_inner_mac_header(skb) - ETH_HLEN;
+ 
+ 	switch (tnl_type) {
+ 	case TX_TNL_TYPE_VXLAN:
+ 	case TX_TNL_TYPE_GENEVE:
+ 		tnl_lso->UdpLenSetOut_to_TnlHdrLen =
+ 			htons(CPL_TX_TNL_LSO_UDPCHKCLROUT_F |
+ 			CPL_TX_TNL_LSO_UDPLENSETOUT_F);
+ 		break;
+ 	default:
+ 		tnl_lso->UdpLenSetOut_to_TnlHdrLen = 0;
+ 		break;
+ 	}
+ 
+ 	tnl_lso->UdpLenSetOut_to_TnlHdrLen |=
+ 		 htons(CPL_TX_TNL_LSO_TNLHDRLEN_V(val) |
+ 		       CPL_TX_TNL_LSO_TNLTYPE_V(tnl_type));
+ 
+ 	tnl_lso->r1 = 0;
+ 
+ 	val = CPL_TX_TNL_LSO_ETHHDRLEN_V(in_eth_xtra_len / 4) |
+ 	      CPL_TX_TNL_LSO_IPV6_V(inner_ip_hdr(skb)->version == 6) |
+ 	      CPL_TX_TNL_LSO_IPHDRLEN_V(skb_inner_network_header_len(skb) / 4) |
+ 	      CPL_TX_TNL_LSO_TCPHDRLEN_V(inner_tcp_hdrlen(skb) / 4);
+ 	tnl_lso->Flow_to_TcpHdrLen = htonl(val);
+ 
+ 	tnl_lso->IpIdOffset = htons(0);
+ 
+ 	tnl_lso->IpIdSplit_to_Mss = htons(CPL_TX_TNL_LSO_MSS_V(ssi->gso_size));
+ 	tnl_lso->TCPSeqOffset = htonl(0);
+ 	tnl_lso->EthLenOffset_Size = htonl(CPL_TX_TNL_LSO_SIZE_V(skb->len));
+ }
+ 
++>>>>>>> c746fc0e8b2d (cxgb4: add geneve offload support for T6)
  /**
   *	t4_eth_xmit - add a packet to an Ethernet Tx queue
   *	@skb: the packet
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/sge.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4_regs.h b/drivers/net/ethernet/chelsio/cxgb4/t4_regs.h
index d9c06d6dc7b2..a6df73398d17 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_regs.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_regs.h
@@ -2522,6 +2522,17 @@
 #define VXLAN_V(x) ((x) << VXLAN_S)
 #define VXLAN_G(x) (((x) >> VXLAN_S) & VXLAN_M)
 
+#define MPS_RX_GENEVE_TYPE_A 0x11238
+
+#define GENEVE_EN_S    16
+#define GENEVE_EN_V(x) ((x) << GENEVE_EN_S)
+#define GENEVE_EN_F    GENEVE_EN_V(1U)
+
+#define GENEVE_S    0
+#define GENEVE_M    0xffffU
+#define GENEVE_V(x) ((x) << GENEVE_S)
+#define GENEVE_G(x) (((x) >> GENEVE_S) & GENEVE_M)
+
 #define MPS_CLS_TCAM_Y_L_A 0xf000
 #define MPS_CLS_TCAM_DATA0_A 0xf000
 #define MPS_CLS_TCAM_DATA1_A 0xf004
