mm/rmap: factor lock function out of rmap_walk_anon()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mm] rmap: factor lock function out of rmap_walk_anon() (Rafael Aquini) [1562137]
Rebuild_FUZZ: 97.09%
commit-author Joonsoo Kim <iamjoonsoo.kim@lge.com>
commit faecd8dd852d4e4a63a1b8ad43e5df8e41ee0336
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/faecd8dd.failed

When we traverse anon_vma, we need to take a read-side anon_lock.  But
there is subtle difference in the situation so that we can't use same
method to take a lock in each cases.  Therefore, we need to make
rmap_walk_anon() taking difference lock function.

This patch is the first step, factoring lock function for anon_lock out
of rmap_walk_anon().  It will be used in case of removing migration
entry and in default of rmap_walk_anon().

	Signed-off-by: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Reviewed-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Cc: Mel Gorman <mgorman@suse.de>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Hillf Danton <dhillf@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit faecd8dd852d4e4a63a1b8ad43e5df8e41ee0336)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/rmap.c
diff --cc mm/rmap.c
index 794c49685fc7,5a79bf585e27..000000000000
--- a/mm/rmap.c
+++ b/mm/rmap.c
@@@ -1907,17 -1714,10 +1925,15 @@@ static int rmap_walk_anon(struct page *
  	struct anon_vma_chain *avc;
  	int ret = SWAP_AGAIN;
  
- 	/*
- 	 * Note: remove_migration_ptes() cannot use page_lock_anon_vma_read()
- 	 * because that depends on page_mapped(); but not all its usages
- 	 * are holding mmap_sem. Users without mmap_sem are required to
- 	 * take a reference count to prevent the anon_vma disappearing
- 	 */
- 	anon_vma = page_anon_vma(page);
+ 	anon_vma = rmap_walk_anon_lock(page);
  	if (!anon_vma)
  		return ret;
++<<<<<<< HEAD
 +	anon_vma_lock_read(anon_vma);
 +	pgoff = page_to_pgoff(page);
++=======
+ 
++>>>>>>> faecd8dd852d (mm/rmap: factor lock function out of rmap_walk_anon())
  	anon_vma_interval_tree_foreach(avc, &anon_vma->rb_root, pgoff, pgoff) {
  		struct vm_area_struct *vma = avc->vma;
  		unsigned long address = vma_address(page, vma);
* Unmerged path mm/rmap.c
