Input: synaptics - split device info into a separate structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [input] synaptics - split device info into a separate structure (Benjamin Tissoires) [1554926]
Rebuild_FUZZ: 94.02%
commit-author Dmitry Torokhov <dmitry.torokhov@gmail.com>
commit 6c53694fb2223746738d1d0cea71456ca88c8fb2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6c53694f.failed

In preparation for SMBus/Intertouch device support, move static device
information that we query form the touchpad upon initialization into
separate structure. This will allow us to query the device without
allocating memory first.

Also stop using "unsigned long", everything fits into 32 bit chunks.

	Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
(cherry picked from commit 6c53694fb2223746738d1d0cea71456ca88c8fb2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/input/mouse/synaptics.c
diff --cc drivers/input/mouse/synaptics.c
index 5f5887ef5b0a,0e08e2d497e9..000000000000
--- a/drivers/input/mouse/synaptics.c
+++ b/drivers/input/mouse/synaptics.c
@@@ -700,10 -744,61 +733,68 @@@ static int synaptics_parse_hw_state(con
  			 ((buf[0] & 0x04) >> 1) |
  			 ((buf[3] & 0x04) >> 2));
  
++<<<<<<< HEAD
 +		hw->left  = (buf[0] & 0x01) ? 1 : 0;
 +		hw->right = (buf[0] & 0x02) ? 1 : 0;
 +
 +		if (SYN_CAP_CLICKPAD(priv->ext_cap_0c)) {
++=======
+ 		if ((SYN_CAP_ADV_GESTURE(priv->info.ext_cap_0c) ||
+ 			SYN_CAP_IMAGE_SENSOR(priv->info.ext_cap_0c)) &&
+ 		    hw->w == 2) {
+ 			synaptics_parse_agm(buf, priv, hw);
+ 			return 1;
+ 		}
+ 
+ 		hw->x = (((buf[3] & 0x10) << 8) |
+ 			 ((buf[1] & 0x0f) << 8) |
+ 			 buf[4]);
+ 		hw->y = (((buf[3] & 0x20) << 7) |
+ 			 ((buf[1] & 0xf0) << 4) |
+ 			 buf[5]);
+ 		hw->z = buf[2];
+ 
+ 		hw->left  = (buf[0] & 0x01) ? 1 : 0;
+ 		hw->right = (buf[0] & 0x02) ? 1 : 0;
+ 
+ 		if (priv->is_forcepad) {
+ 			/*
+ 			 * ForcePads, like Clickpads, use middle button
+ 			 * bits to report primary button clicks.
+ 			 * Unfortunately they report primary button not
+ 			 * only when user presses on the pad above certain
+ 			 * threshold, but also when there are more than one
+ 			 * finger on the touchpad, which interferes with
+ 			 * out multi-finger gestures.
+ 			 */
+ 			if (hw->z == 0) {
+ 				/* No contacts */
+ 				priv->press = priv->report_press = false;
+ 			} else if (hw->w >= 4 && ((buf[0] ^ buf[3]) & 0x01)) {
+ 				/*
+ 				 * Single-finger touch with pressure above
+ 				 * the threshold. If pressure stays long
+ 				 * enough, we'll start reporting primary
+ 				 * button. We rely on the device continuing
+ 				 * sending data even if finger does not
+ 				 * move.
+ 				 */
+ 				if  (!priv->press) {
+ 					priv->press_start = jiffies;
+ 					priv->press = true;
+ 				} else if (time_after(jiffies,
+ 						priv->press_start +
+ 							msecs_to_jiffies(50))) {
+ 					priv->report_press = true;
+ 				}
+ 			} else {
+ 				priv->press = false;
+ 			}
+ 
+ 			hw->left = priv->report_press;
+ 
+ 		} else if (SYN_CAP_CLICKPAD(priv->info.ext_cap_0c)) {
++>>>>>>> 6c53694fb222 (Input: synaptics - split device info into a separate structure)
  			/*
  			 * Clickpad's button is transmitted as middle button,
  			 * however, since it is primary button, we will report
@@@ -722,22 -817,7 +813,26 @@@
  			hw->down = ((buf[0] ^ buf[3]) & 0x02) ? 1 : 0;
  		}
  
++<<<<<<< HEAD
 +		if ((SYN_CAP_ADV_GESTURE(priv->ext_cap_0c) ||
 +			SYN_CAP_IMAGE_SENSOR(priv->ext_cap_0c)) &&
 +		    hw->w == 2) {
 +			synaptics_parse_agm(buf, priv, hw);
 +			return 1;
 +		}
 +
 +		hw->x = (((buf[3] & 0x10) << 8) |
 +			 ((buf[1] & 0x0f) << 8) |
 +			 buf[4]);
 +		hw->y = (((buf[3] & 0x20) << 7) |
 +			 ((buf[1] & 0xf0) << 4) |
 +			 buf[5]);
 +		hw->z = buf[2];
 +
 +		if (SYN_CAP_MULTI_BUTTON_NO(priv->ext_cap) > 0 &&
++=======
+ 		if (SYN_CAP_MULTI_BUTTON_NO(priv->info.ext_cap) > 0 &&
++>>>>>>> 6c53694fb222 (Input: synaptics - split device info into a separate structure)
  		    ((buf[0] ^ buf[3]) & 0x02)) {
  			synaptics_parse_ext_buttons(buf, priv, hw);
  		}
@@@ -886,75 -953,29 +981,90 @@@ static void synaptics_report_mt_data(st
  {
  	struct input_dev *dev = psmouse->dev;
  	struct synaptics_data *priv = psmouse->private;
 -	const struct synaptics_hw_state *hw[2] = { sgm, &priv->agm };
 -	struct input_mt_pos pos[2];
 -	int slot[2], nsemi, i;
 +	struct synaptics_hw_state *agm = &priv->agm;
 +	struct synaptics_mt_state *old = &priv->mt_state;
  
 -	nsemi = clamp_val(num_fingers, 0, 2);
 +	switch (mt_state->count) {
 +	case 0:
 +		synaptics_report_slot(dev, 0, NULL);
 +		synaptics_report_slot(dev, 1, NULL);
 +		break;
 +	case 1:
 +		if (mt_state->sgm == -1) {
 +			synaptics_report_slot(dev, 0, NULL);
 +			synaptics_report_slot(dev, 1, NULL);
 +		} else if (mt_state->sgm == 0) {
 +			synaptics_report_slot(dev, 0, sgm);
 +			synaptics_report_slot(dev, 1, NULL);
 +		} else {
 +			synaptics_report_slot(dev, 0, NULL);
 +			synaptics_report_slot(dev, 1, sgm);
 +		}
 +		break;
 +	default:
 +		/*
 +		 * If the finger slot contained in SGM is valid, and either
 +		 * hasn't changed, or is new, or the old SGM has now moved to
 +		 * AGM, then report SGM in MTB slot 0.
 +		 * Otherwise, empty MTB slot 0.
 +		 */
 +		if (mt_state->sgm != -1 &&
 +		    (mt_state->sgm == old->sgm ||
 +		     old->sgm == -1 || mt_state->agm == old->sgm))
 +			synaptics_report_slot(dev, 0, sgm);
 +		else
 +			synaptics_report_slot(dev, 0, NULL);
  
 -	for (i = 0; i < nsemi; i++) {
 -		pos[i].x = hw[i]->x;
 -		pos[i].y = synaptics_invert_y(hw[i]->y);
 +		/*
 +		 * If the finger slot contained in AGM is valid, and either
 +		 * hasn't changed, or is new, then report AGM in MTB slot 1.
 +		 * Otherwise, empty MTB slot 1.
 +		 *
 +		 * However, in the case where the AGM is new, make sure that
 +		 * that it is either the same as the old SGM, or there was no
 +		 * SGM.
 +		 *
 +		 * Otherwise, if the SGM was just 1, and the new AGM is 2, then
 +		 * the new AGM will keep the old SGM's tracking ID, which can
 +		 * cause apparent drumroll.  This happens if in the following
 +		 * valid finger sequence:
 +		 *
 +		 *  Action                 SGM  AGM (MTB slot:Contact)
 +		 *  1. Touch contact 0    (0:0)
 +		 *  2. Touch contact 1    (0:0, 1:1)
 +		 *  3. Lift  contact 0    (1:1)
 +		 *  4. Touch contacts 2,3 (0:2, 1:3)
 +		 *
 +		 * In step 4, contact 3, in AGM must not be given the same
 +		 * tracking ID as contact 1 had in step 3.  To avoid this,
 +		 * the first agm with contact 3 is dropped and slot 1 is
 +		 * invalidated (tracking ID = -1).
 +		 */
 +		if (mt_state->agm != -1 &&
 +		    (mt_state->agm == old->agm ||
 +		     (old->agm == -1 &&
 +		      (old->sgm == -1 || mt_state->agm == old->sgm))))
 +			synaptics_report_slot(dev, 1, agm);
 +		else
 +			synaptics_report_slot(dev, 1, NULL);
 +		break;
  	}
  
++<<<<<<< HEAD
++=======
+ 	input_mt_assign_slots(dev, slot, pos, nsemi, DMAX * priv->info.x_res);
+ 
+ 	for (i = 0; i < nsemi; i++) {
+ 		input_mt_slot(dev, slot[i]);
+ 		input_mt_report_slot_state(dev, MT_TOOL_FINGER, true);
+ 		input_report_abs(dev, ABS_MT_POSITION_X, pos[i].x);
+ 		input_report_abs(dev, ABS_MT_POSITION_Y, pos[i].y);
+ 		input_report_abs(dev, ABS_MT_PRESSURE, hw[i]->z);
+ 	}
+ 
+ 	input_mt_drop_unused(dev);
+ 
++>>>>>>> 6c53694fb222 (Input: synaptics - split device info into a separate structure)
  	/* Don't use active slot count to generate BTN_TOOL events. */
  	input_mt_report_pointer_emulation(dev, false);
  
@@@ -1314,7 -1075,12 +1425,16 @@@ static void synaptics_process_packet(st
  		finger_width = 0;
  	}
  
++<<<<<<< HEAD
 +	if (SYN_CAP_ADV_GESTURE(priv->ext_cap_0c))
++=======
+ 	if (cr48_profile_sensor) {
+ 		synaptics_report_mt_data(psmouse, &hw, num_fingers);
+ 		return;
+ 	}
+ 
+ 	if (SYN_CAP_ADV_GESTURE(info->ext_cap_0c))
++>>>>>>> 6c53694fb222 (Input: synaptics - split device info into a separate structure)
  		synaptics_report_semi_mt_data(dev, &hw, &priv->agm,
  					      num_fingers);
  
@@@ -1457,28 -1224,36 +1578,51 @@@ static void set_input_params(struct psm
  
  	/* Absolute mode */
  	__set_bit(EV_ABS, dev->evbit);
- 	set_abs_position_params(dev, priv, ABS_X, ABS_Y);
+ 	set_abs_position_params(dev, &priv->info, ABS_X, ABS_Y);
  	input_set_abs_params(dev, ABS_PRESSURE, 0, 255, 0, 0);
  
++<<<<<<< HEAD
 +	if (SYN_CAP_IMAGE_SENSOR(priv->ext_cap_0c)) {
 +		set_abs_position_params(dev, priv, ABS_MT_POSITION_X,
 +					ABS_MT_POSITION_Y);
++=======
+ 	if (cr48_profile_sensor)
+ 		input_set_abs_params(dev, ABS_MT_PRESSURE, 0, 255, 0, 0);
+ 
+ 	if (SYN_CAP_IMAGE_SENSOR(info->ext_cap_0c)) {
+ 		set_abs_position_params(dev, info,
+ 					ABS_MT_POSITION_X, ABS_MT_POSITION_Y);
++>>>>>>> 6c53694fb222 (Input: synaptics - split device info into a separate structure)
  		/* Image sensors can report per-contact pressure */
  		input_set_abs_params(dev, ABS_MT_PRESSURE, 0, 255, 0, 0);
 -		input_mt_init_slots(dev, 2, INPUT_MT_POINTER | INPUT_MT_TRACK);
 +		input_mt_init_slots(dev, 2, INPUT_MT_POINTER);
  
  		/* Image sensors can signal 4 and 5 finger clicks */
  		__set_bit(BTN_TOOL_QUADTAP, dev->keybit);
  		__set_bit(BTN_TOOL_QUINTTAP, dev->keybit);
++<<<<<<< HEAD
 +	} else if (SYN_CAP_ADV_GESTURE(priv->ext_cap_0c)) {
 +		/* Non-image sensors with AGM use semi-mt */
 +		__set_bit(INPUT_PROP_SEMI_MT, dev->propbit);
 +		input_mt_init_slots(dev, 2, 0);
 +		set_abs_position_params(dev, priv, ABS_MT_POSITION_X,
 +					ABS_MT_POSITION_Y);
++=======
+ 	} else if (SYN_CAP_ADV_GESTURE(info->ext_cap_0c)) {
+ 		set_abs_position_params(dev, info,
+ 					ABS_MT_POSITION_X, ABS_MT_POSITION_Y);
+ 		/*
+ 		 * Profile sensor in CR-48 tracks contacts reasonably well,
+ 		 * other non-image sensors with AGM use semi-mt.
+ 		 */
+ 		input_mt_init_slots(dev, 2,
+ 				    INPUT_MT_POINTER |
+ 				    (cr48_profile_sensor ?
+ 					INPUT_MT_TRACK : INPUT_MT_SEMI_MT));
++>>>>>>> 6c53694fb222 (Input: synaptics - split device info into a separate structure)
  	}
  
- 	if (SYN_CAP_PALMDETECT(priv->capabilities))
+ 	if (SYN_CAP_PALMDETECT(info->capabilities))
  		input_set_abs_params(dev, ABS_TOOL_WIDTH, 0, 15, 0, 0);
  
  	__set_bit(BTN_TOUCH, dev->keybit);
@@@ -1713,10 -1506,18 +1861,12 @@@ static int __synaptics_init(struct psmo
  		goto init_fail;
  	}
  
+ 	synaptics_apply_quirks(psmouse, info);
+ 
  	priv->absolute_mode = absolute_mode;
- 	if (SYN_ID_DISGEST_SUPPORTED(priv->identity))
+ 	if (SYN_ID_DISGEST_SUPPORTED(info->identity))
  		priv->disable_gesture = true;
  
 -	/*
 -	 * Unfortunately ForcePad capability is not exported over PS/2,
 -	 * so we have to resort to checking PNP IDs.
 -	 */
 -	priv->is_forcepad = psmouse_matches_pnp_id(psmouse, forcepad_pnp_ids);
 -
  	if (synaptics_set_mode(psmouse)) {
  		psmouse_err(psmouse, "Unable to initialize device.\n");
  		goto init_fail;
* Unmerged path drivers/input/mouse/synaptics.c
diff --git a/drivers/input/mouse/synaptics.h b/drivers/input/mouse/synaptics.h
index 1b0e490b1040..42355518695c 100644
--- a/drivers/input/mouse/synaptics.h
+++ b/drivers/input/mouse/synaptics.h
@@ -172,19 +172,23 @@ struct synaptics_hw_state {
 	struct synaptics_mt_state mt_state;
 };
 
+/* Data read from the touchpad */
+struct synaptics_device_info {
+	u32 model_id;		/* Model-ID */
+	u32 firmware_id;	/* Firmware-ID */
+	u32 board_id;		/* Board-ID */
+	u32 capabilities;	/* Capabilities */
+	u32 ext_cap;		/* Extended Capabilities */
+	u32 ext_cap_0c;		/* Ext Caps from 0x0c query */
+	u32 ext_cap_10;		/* Ext Caps from 0x10 query */
+	u32 identity;		/* Identification */
+	u32 x_res, y_res;	/* X/Y resolution in units/mm */
+	u32 x_max, y_max;	/* Max coordinates (from FW) */
+	u32 x_min, y_min;	/* Min coordinates (from FW) */
+};
+
 struct synaptics_data {
-	/* Data read from the touchpad */
-	unsigned long int model_id;		/* Model-ID */
-	unsigned long int firmware_id;		/* Firmware-ID */
-	unsigned long int board_id;		/* Board-ID */
-	unsigned long int capabilities;		/* Capabilities */
-	unsigned long int ext_cap;		/* Extended Capabilities */
-	unsigned long int ext_cap_0c;		/* Ext Caps from 0x0c query */
-	unsigned long int ext_cap_10;		/* Ext Caps from 0x10 query */
-	unsigned long int identity;		/* Identification */
-	unsigned int x_res, y_res;		/* X/Y resolution in units/mm */
-	unsigned int x_max, y_max;		/* Max coordinates (from FW) */
-	unsigned int x_min, y_min;		/* Min coordinates (from FW) */
+	struct synaptics_device_info info;
 
 	unsigned char pkt_type;			/* packet type - old, new, etc */
 	unsigned char mode;			/* current mode byte */
