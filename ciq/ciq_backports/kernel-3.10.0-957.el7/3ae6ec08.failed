ipv4: Send a netevent whenever multipath hash policy is changed

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit 3ae6ec08292f01c6782d1a80be0b2cc675e0ecfc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3ae6ec08.failed

Devices performing IPv4 forwarding need to update their multipath hash
policy whenever it is changed.

Inform these devices by generating a netevent.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Reviewed-by: Petr Machata <petrm@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3ae6ec08292f01c6782d1a80be0b2cc675e0ecfc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/sysctl_net_ipv4.c
diff --cc net/ipv4/sysctl_net_ipv4.c
index 12b498f653f9,8dcc2b185fcc..000000000000
--- a/net/ipv4/sysctl_net_ipv4.c
+++ b/net/ipv4/sysctl_net_ipv4.c
@@@ -24,7 -24,8 +24,12 @@@
  #include <net/cipso_ipv4.h>
  #include <net/inet_frag.h>
  #include <net/ping.h>
++<<<<<<< HEAD
 +#include <net/tcp_memcontrol.h>
++=======
+ #include <net/protocol.h>
+ #include <net/netevent.h>
++>>>>>>> 3ae6ec08292f (ipv4: Send a netevent whenever multipath hash policy is changed)
  
  static int zero;
  static int one = 1;
@@@ -298,60 -297,113 +303,169 @@@ bad_key
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static void proc_configure_early_demux(int enabled, int protocol)
+ {
+ 	struct net_protocol *ipprot;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	struct inet6_protocol *ip6prot;
+ #endif
+ 
+ 	rcu_read_lock();
+ 
+ 	ipprot = rcu_dereference(inet_protos[protocol]);
+ 	if (ipprot)
+ 		ipprot->early_demux = enabled ? ipprot->early_demux_handler :
+ 						NULL;
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	ip6prot = rcu_dereference(inet6_protos[protocol]);
+ 	if (ip6prot)
+ 		ip6prot->early_demux = enabled ? ip6prot->early_demux_handler :
+ 						 NULL;
+ #endif
+ 	rcu_read_unlock();
+ }
+ 
+ static int proc_tcp_early_demux(struct ctl_table *table, int write,
+ 				void __user *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int ret = 0;
+ 
+ 	ret = proc_dointvec(table, write, buffer, lenp, ppos);
+ 
+ 	if (write && !ret) {
+ 		int enabled = init_net.ipv4.sysctl_tcp_early_demux;
+ 
+ 		proc_configure_early_demux(enabled, IPPROTO_TCP);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int proc_udp_early_demux(struct ctl_table *table, int write,
+ 				void __user *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int ret = 0;
+ 
+ 	ret = proc_dointvec(table, write, buffer, lenp, ppos);
+ 
+ 	if (write && !ret) {
+ 		int enabled = init_net.ipv4.sysctl_udp_early_demux;
+ 
+ 		proc_configure_early_demux(enabled, IPPROTO_UDP);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int proc_tfo_blackhole_detect_timeout(struct ctl_table *table,
+ 					     int write,
+ 					     void __user *buffer,
+ 					     size_t *lenp, loff_t *ppos)
+ {
+ 	struct net *net = container_of(table->data, struct net,
+ 	    ipv4.sysctl_tcp_fastopen_blackhole_timeout);
+ 	int ret;
+ 
+ 	ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);
+ 	if (write && ret == 0)
+ 		atomic_set(&net->ipv4.tfo_active_disable_times, 0);
+ 
+ 	return ret;
+ }
+ 
+ static int proc_tcp_available_ulp(struct ctl_table *ctl,
+ 				  int write,
+ 				  void __user *buffer, size_t *lenp,
+ 				  loff_t *ppos)
+ {
+ 	struct ctl_table tbl = { .maxlen = TCP_ULP_BUF_MAX, };
+ 	int ret;
+ 
+ 	tbl.data = kmalloc(tbl.maxlen, GFP_USER);
+ 	if (!tbl.data)
+ 		return -ENOMEM;
+ 	tcp_get_available_ulp(tbl.data, TCP_ULP_BUF_MAX);
+ 	ret = proc_dostring(&tbl, write, buffer, lenp, ppos);
+ 	kfree(tbl.data);
+ 
+ 	return ret;
+ }
+ 
+ #ifdef CONFIG_IP_ROUTE_MULTIPATH
+ static int proc_fib_multipath_hash_policy(struct ctl_table *table, int write,
+ 					  void __user *buffer, size_t *lenp,
+ 					  loff_t *ppos)
+ {
+ 	struct net *net = container_of(table->data, struct net,
+ 	    ipv4.sysctl_fib_multipath_hash_policy);
+ 	int ret;
+ 
+ 	ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);
+ 	if (write && ret == 0)
+ 		call_netevent_notifiers(NETEVENT_MULTIPATH_HASH_UPDATE, net);
+ 
+ 	return ret;
+ }
+ #endif
+ 
++>>>>>>> 3ae6ec08292f (ipv4: Send a netevent whenever multipath hash policy is changed)
  static struct ctl_table ipv4_table[] = {
 +	{
 +		.procname	= "tcp_timestamps",
 +		.data		= &sysctl_tcp_timestamps,
 +		.maxlen		= sizeof(int),
 +		.mode		= 0644,
 +		.proc_handler	= proc_dointvec
 +	},
 +	{
 +		.procname	= "tcp_window_scaling",
 +		.data		= &sysctl_tcp_window_scaling,
 +		.maxlen		= sizeof(int),
 +		.mode		= 0644,
 +		.proc_handler	= proc_dointvec
 +	},
 +	{
 +		.procname	= "tcp_sack",
 +		.data		= &sysctl_tcp_sack,
 +		.maxlen		= sizeof(int),
 +		.mode		= 0644,
 +		.proc_handler	= proc_dointvec
 +	},
 +	{
 +		.procname	= "tcp_retrans_collapse",
 +		.data		= &sysctl_tcp_retrans_collapse,
 +		.maxlen		= sizeof(int),
 +		.mode		= 0644,
 +		.proc_handler	= proc_dointvec
 +	},
 +	{
 +		.procname	= "ip_default_ttl",
 +		.data		= &sysctl_ip_default_ttl,
 +		.maxlen		= sizeof(int),
 +		.mode		= 0644,
 +		.proc_handler	= proc_dointvec_minmax,
 +		.extra1		= &ip_ttl_min,
 +		.extra2		= &ip_ttl_max,
 +	},
 +	{
 +		.procname	= "tcp_syn_retries",
 +		.data		= &sysctl_tcp_syn_retries,
 +		.maxlen		= sizeof(int),
 +		.mode		= 0644,
 +		.proc_handler	= proc_dointvec_minmax,
 +		.extra1		= &tcp_syn_retries_min,
 +		.extra2		= &tcp_syn_retries_max
 +	},
 +	{
 +		.procname	= "tcp_synack_retries",
 +		.data		= &sysctl_tcp_synack_retries,
 +		.maxlen		= sizeof(int),
 +		.mode		= 0644,
 +		.proc_handler	= proc_dointvec
 +	},
  	{
  		.procname	= "tcp_max_orphans",
  		.data		= &sysctl_tcp_max_orphans,
@@@ -926,6 -799,370 +1040,373 @@@ static struct ctl_table ipv4_net_table[
  		.mode		= 0644,
  		.proc_handler	= proc_dointvec_jiffies,
  	},
++<<<<<<< HEAD
++=======
+ 	{
+ 		.procname	= "tcp_syn_retries",
+ 		.data		= &init_net.ipv4.sysctl_tcp_syn_retries,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_minmax,
+ 		.extra1		= &tcp_syn_retries_min,
+ 		.extra2		= &tcp_syn_retries_max
+ 	},
+ 	{
+ 		.procname	= "tcp_synack_retries",
+ 		.data		= &init_net.ipv4.sysctl_tcp_synack_retries,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ #ifdef CONFIG_SYN_COOKIES
+ 	{
+ 		.procname	= "tcp_syncookies",
+ 		.data		= &init_net.ipv4.sysctl_tcp_syncookies,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ #endif
+ 	{
+ 		.procname	= "tcp_reordering",
+ 		.data		= &init_net.ipv4.sysctl_tcp_reordering,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_retries1",
+ 		.data		= &init_net.ipv4.sysctl_tcp_retries1,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_minmax,
+ 		.extra2		= &tcp_retr1_max
+ 	},
+ 	{
+ 		.procname	= "tcp_retries2",
+ 		.data		= &init_net.ipv4.sysctl_tcp_retries2,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_orphan_retries",
+ 		.data		= &init_net.ipv4.sysctl_tcp_orphan_retries,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_fin_timeout",
+ 		.data		= &init_net.ipv4.sysctl_tcp_fin_timeout,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	{
+ 		.procname	= "tcp_notsent_lowat",
+ 		.data		= &init_net.ipv4.sysctl_tcp_notsent_lowat,
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_douintvec,
+ 	},
+ 	{
+ 		.procname	= "tcp_tw_reuse",
+ 		.data		= &init_net.ipv4.sysctl_tcp_tw_reuse,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_max_tw_buckets",
+ 		.data		= &init_net.ipv4.tcp_death_row.sysctl_max_tw_buckets,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_max_syn_backlog",
+ 		.data		= &init_net.ipv4.sysctl_max_syn_backlog,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_fastopen",
+ 		.data		= &init_net.ipv4.sysctl_tcp_fastopen,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec,
+ 	},
+ 	{
+ 		.procname	= "tcp_fastopen_key",
+ 		.mode		= 0600,
+ 		.data		= &init_net.ipv4.sysctl_tcp_fastopen,
+ 		.maxlen		= ((TCP_FASTOPEN_KEY_LENGTH * 2) + 10),
+ 		.proc_handler	= proc_tcp_fastopen_key,
+ 	},
+ 	{
+ 		.procname	= "tcp_fastopen_blackhole_timeout_sec",
+ 		.data		= &init_net.ipv4.sysctl_tcp_fastopen_blackhole_timeout,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_tfo_blackhole_detect_timeout,
+ 		.extra1		= &zero,
+ 	},
+ #ifdef CONFIG_IP_ROUTE_MULTIPATH
+ 	{
+ 		.procname	= "fib_multipath_use_neigh",
+ 		.data		= &init_net.ipv4.sysctl_fib_multipath_use_neigh,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_minmax,
+ 		.extra1		= &zero,
+ 		.extra2		= &one,
+ 	},
+ 	{
+ 		.procname	= "fib_multipath_hash_policy",
+ 		.data		= &init_net.ipv4.sysctl_fib_multipath_hash_policy,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_fib_multipath_hash_policy,
+ 		.extra1		= &zero,
+ 		.extra2		= &one,
+ 	},
+ #endif
+ 	{
+ 		.procname	= "ip_unprivileged_port_start",
+ 		.maxlen		= sizeof(int),
+ 		.data		= &init_net.ipv4.sysctl_ip_prot_sock,
+ 		.mode		= 0644,
+ 		.proc_handler	= ipv4_privileged_ports,
+ 	},
+ #ifdef CONFIG_NET_L3_MASTER_DEV
+ 	{
+ 		.procname	= "udp_l3mdev_accept",
+ 		.data		= &init_net.ipv4.sysctl_udp_l3mdev_accept,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_minmax,
+ 		.extra1		= &zero,
+ 		.extra2		= &one,
+ 	},
+ #endif
+ 	{
+ 		.procname	= "tcp_sack",
+ 		.data		= &init_net.ipv4.sysctl_tcp_sack,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_window_scaling",
+ 		.data		= &init_net.ipv4.sysctl_tcp_window_scaling,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_timestamps",
+ 		.data		= &init_net.ipv4.sysctl_tcp_timestamps,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_early_retrans",
+ 		.data		= &init_net.ipv4.sysctl_tcp_early_retrans,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_minmax,
+ 		.extra1		= &zero,
+ 		.extra2		= &four,
+ 	},
+ 	{
+ 		.procname	= "tcp_recovery",
+ 		.data		= &init_net.ipv4.sysctl_tcp_recovery,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec,
+ 	},
+ 	{
+ 		.procname       = "tcp_thin_linear_timeouts",
+ 		.data           = &init_net.ipv4.sysctl_tcp_thin_linear_timeouts,
+ 		.maxlen         = sizeof(int),
+ 		.mode           = 0644,
+ 		.proc_handler   = proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_slow_start_after_idle",
+ 		.data		= &init_net.ipv4.sysctl_tcp_slow_start_after_idle,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_retrans_collapse",
+ 		.data		= &init_net.ipv4.sysctl_tcp_retrans_collapse,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_stdurg",
+ 		.data		= &init_net.ipv4.sysctl_tcp_stdurg,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_rfc1337",
+ 		.data		= &init_net.ipv4.sysctl_tcp_rfc1337,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_abort_on_overflow",
+ 		.data		= &init_net.ipv4.sysctl_tcp_abort_on_overflow,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_fack",
+ 		.data		= &init_net.ipv4.sysctl_tcp_fack,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_max_reordering",
+ 		.data		= &init_net.ipv4.sysctl_tcp_max_reordering,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_dsack",
+ 		.data		= &init_net.ipv4.sysctl_tcp_dsack,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_app_win",
+ 		.data		= &init_net.ipv4.sysctl_tcp_app_win,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_adv_win_scale",
+ 		.data		= &init_net.ipv4.sysctl_tcp_adv_win_scale,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_minmax,
+ 		.extra1		= &tcp_adv_win_scale_min,
+ 		.extra2		= &tcp_adv_win_scale_max,
+ 	},
+ 	{
+ 		.procname	= "tcp_frto",
+ 		.data		= &init_net.ipv4.sysctl_tcp_frto,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_no_metrics_save",
+ 		.data		= &init_net.ipv4.sysctl_tcp_nometrics_save,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec,
+ 	},
+ 	{
+ 		.procname	= "tcp_moderate_rcvbuf",
+ 		.data		= &init_net.ipv4.sysctl_tcp_moderate_rcvbuf,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec,
+ 	},
+ 	{
+ 		.procname	= "tcp_tso_win_divisor",
+ 		.data		= &init_net.ipv4.sysctl_tcp_tso_win_divisor,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec,
+ 	},
+ 	{
+ 		.procname	= "tcp_workaround_signed_windows",
+ 		.data		= &init_net.ipv4.sysctl_tcp_workaround_signed_windows,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_limit_output_bytes",
+ 		.data		= &init_net.ipv4.sysctl_tcp_limit_output_bytes,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_challenge_ack_limit",
+ 		.data		= &init_net.ipv4.sysctl_tcp_challenge_ack_limit,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_min_tso_segs",
+ 		.data		= &init_net.ipv4.sysctl_tcp_min_tso_segs,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_minmax,
+ 		.extra1		= &one,
+ 		.extra2		= &gso_max_segs,
+ 	},
+ 	{
+ 		.procname	= "tcp_min_rtt_wlen",
+ 		.data		= &init_net.ipv4.sysctl_tcp_min_rtt_wlen,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "tcp_autocorking",
+ 		.data		= &init_net.ipv4.sysctl_tcp_autocorking,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_minmax,
+ 		.extra1		= &zero,
+ 		.extra2		= &one,
+ 	},
+ 	{
+ 		.procname	= "tcp_invalid_ratelimit",
+ 		.data		= &init_net.ipv4.sysctl_tcp_invalid_ratelimit,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_ms_jiffies,
+ 	},
+ 	{
+ 		.procname	= "tcp_pacing_ss_ratio",
+ 		.data		= &init_net.ipv4.sysctl_tcp_pacing_ss_ratio,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_minmax,
+ 		.extra1		= &zero,
+ 		.extra2		= &thousand,
+ 	},
+ 	{
+ 		.procname	= "tcp_pacing_ca_ratio",
+ 		.data		= &init_net.ipv4.sysctl_tcp_pacing_ca_ratio,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_minmax,
+ 		.extra1		= &zero,
+ 		.extra2		= &thousand,
+ 	},
++>>>>>>> 3ae6ec08292f (ipv4: Send a netevent whenever multipath hash policy is changed)
  	{ }
  };
  
diff --git a/include/net/netevent.h b/include/net/netevent.h
index f440df172b56..e3f0e8f2f6e8 100644
--- a/include/net/netevent.h
+++ b/include/net/netevent.h
@@ -25,6 +25,7 @@ enum netevent_notif_type {
 	NETEVENT_NEIGH_UPDATE = 1, /* arg is struct neighbour ptr */
 	NETEVENT_REDIRECT,	   /* arg is struct netevent_redirect ptr */
 	NETEVENT_DELAY_PROBE_TIME_UPDATE, /* arg is struct neigh_parms ptr */
+	NETEVENT_MULTIPATH_HASH_UPDATE, /* arg is struct net ptr */
 };
 
 int register_netevent_notifier(struct notifier_block *nb);
* Unmerged path net/ipv4/sysctl_net_ipv4.c
