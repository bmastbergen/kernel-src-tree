net: ipmr: move pimsm_enabled to pim.h and rename

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] ipmr: move pimsm_enabled to pim.h and rename (Ivan Vecera) [1584232]
Rebuild_FUZZ: 94.62%
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit 1973a4ea6ceaa47671227c3077f90508ea30897b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1973a4ea.failed

Move the inline pimsm_enabled() to pim.h and rename it to
ipmr_pimsm_enabled to show it's for the ipv4 ipmr code since pim.h is
used by IPv6 too.

	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1973a4ea6ceaa47671227c3077f90508ea30897b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ipmr.c
diff --cc net/ipv4/ipmr.c
index 14e0af5a16ef,322fdc6ac75b..000000000000
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@@ -718,10 -745,10 +718,16 @@@ static int vif_add(struct net *net, str
  		return -EADDRINUSE;
  
  	switch (vifc->vifc_flags) {
 +#ifdef CONFIG_IP_PIMSM
  	case VIFF_REGISTER:
++<<<<<<< HEAD
 +		/*
 +		 * Special Purpose VIF in PIM
++=======
+ 		if (!ipmr_pimsm_enabled())
+ 			return -EINVAL;
+ 		/* Special Purpose VIF in PIM
++>>>>>>> 1973a4ea6cea (net: ipmr: move pimsm_enabled to pim.h and rename)
  		 * All the packets will be sent to the daemon
  		 */
  		if (mrt->mroute_reg_vif_num >= 0)
@@@ -1348,58 -1358,53 +1354,73 @@@ int ip_mroute_setsockopt(struct sock *s
  			ret = ipmr_mfc_add(net, mrt, &mfc,
  					   sk == rtnl_dereference(mrt->mroute_sk),
  					   parent);
 -		break;
 -	/* Control PIM assert. */
 +		rtnl_unlock();
 +		return ret;
 +		/*
 +		 *	Control PIM assert.
 +		 */
  	case MRT_ASSERT:
 -		if (optlen != sizeof(val)) {
 -			ret = -EINVAL;
 -			break;
 -		}
 -		if (get_user(val, (int __user *)optval)) {
 -			ret = -EFAULT;
 -			break;
 -		}
 -		mrt->mroute_do_assert = val;
 -		break;
 +	{
 +		int v;
 +		if (optlen != sizeof(v))
 +			return -EINVAL;
 +		if (get_user(v, (int __user *)optval))
 +			return -EFAULT;
 +		mrt->mroute_do_assert = v;
 +		return 0;
 +	}
 +#ifdef CONFIG_IP_PIMSM
  	case MRT_PIM:
++<<<<<<< HEAD
 +	{
 +		int v;
++=======
+ 		if (!ipmr_pimsm_enabled()) {
+ 			ret = -ENOPROTOOPT;
+ 			break;
+ 		}
+ 		if (optlen != sizeof(val)) {
+ 			ret = -EINVAL;
+ 			break;
+ 		}
+ 		if (get_user(val, (int __user *)optval)) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
++>>>>>>> 1973a4ea6cea (net: ipmr: move pimsm_enabled to pim.h and rename)
  
 -		val = !!val;
 -		if (val != mrt->mroute_do_pim) {
 -			mrt->mroute_do_pim = val;
 -			mrt->mroute_do_assert = val;
 +		if (optlen != sizeof(v))
 +			return -EINVAL;
 +		if (get_user(v, (int __user *)optval))
 +			return -EFAULT;
 +		v = !!v;
 +
 +		rtnl_lock();
 +		ret = 0;
 +		if (v != mrt->mroute_do_pim) {
 +			mrt->mroute_do_pim = v;
 +			mrt->mroute_do_assert = v;
  		}
 -		break;
 +		rtnl_unlock();
 +		return ret;
 +	}
 +#endif
 +#ifdef CONFIG_IP_MROUTE_MULTIPLE_TABLES
  	case MRT_TABLE:
 -		if (!IS_BUILTIN(CONFIG_IP_MROUTE_MULTIPLE_TABLES)) {
 -			ret = -ENOPROTOOPT;
 -			break;
 -		}
 -		if (optlen != sizeof(uval)) {
 -			ret = -EINVAL;
 -			break;
 -		}
 -		if (get_user(uval, (u32 __user *)optval)) {
 -			ret = -EFAULT;
 -			break;
 -		}
 +	{
 +		u32 v;
 +
 +		if (optlen != sizeof(u32))
 +			return -EINVAL;
 +		if (get_user(v, (u32 __user *)optval))
 +			return -EFAULT;
  
 +		/* "pimreg%u" should not exceed 16 bytes (IFNAMSIZ) */
 +		if (v != RT_TABLE_DEFAULT && v >= 1000000000)
 +			return -EINVAL;
 +
 +		rtnl_lock();
 +		ret = 0;
  		if (sk == rtnl_dereference(mrt->mroute_sk)) {
  			ret = -EBUSY;
  		} else {
@@@ -1437,15 -1438,24 +1458,31 @@@ int ip_mroute_getsockopt(struct sock *s
  		return -EOPNOTSUPP;
  
  	mrt = ipmr_get_table(net, raw_sk(sk)->ipmr_table ? : RT_TABLE_DEFAULT);
 -	if (!mrt)
 +	if (mrt == NULL)
  		return -ENOENT;
  
++<<<<<<< HEAD
 +	if (optname != MRT_VERSION &&
 +#ifdef CONFIG_IP_PIMSM
 +	   optname != MRT_PIM &&
 +#endif
 +	   optname != MRT_ASSERT)
++=======
+ 	switch (optname) {
+ 	case MRT_VERSION:
+ 		val = 0x0305;
+ 		break;
+ 	case MRT_PIM:
+ 		if (!ipmr_pimsm_enabled())
+ 			return -ENOPROTOOPT;
+ 		val = mrt->mroute_do_pim;
+ 		break;
+ 	case MRT_ASSERT:
+ 		val = mrt->mroute_do_assert;
+ 		break;
+ 	default:
++>>>>>>> 1973a4ea6cea (net: ipmr: move pimsm_enabled to pim.h and rename)
  		return -ENOPROTOOPT;
 -	}
  
  	if (get_user(olr, optlen))
  		return -EFAULT;
diff --git a/include/linux/pim.h b/include/linux/pim.h
index 252bf6644c51..e1d756f81348 100644
--- a/include/linux/pim.h
+++ b/include/linux/pim.h
@@ -13,6 +13,11 @@
 
 #define PIM_NULL_REGISTER	cpu_to_be32(0x40000000)
 
+static inline bool ipmr_pimsm_enabled(void)
+{
+	return IS_BUILTIN(CONFIG_IP_PIMSM_V1) || IS_BUILTIN(CONFIG_IP_PIMSM_V2);
+}
+
 /* PIMv2 register message header layout (ietf-draft-idmr-pimvsm-v2-00.ps */
 struct pimreghdr
 {
* Unmerged path net/ipv4/ipmr.c
