scsi: qla2xxx: Fix warning during port_name debug print

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Fix warning during port_name debug print (Himanshu Madhani) [1547714]
Rebuild_FUZZ: 94.23%
commit-author himanshu.madhani@cavium.com <himanshu.madhani@cavium.com>
commit c2dd0e1d9da89fa13bc9e2aa58f2a24c9797a359
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c2dd0e1d.failed

This patch fixes following smatch warning:

drivers/scsi/qla2xxx/qla_iocb.c:2622 qla2x00_els_dcmd2_sp_done() error: '%pC' expects argument of type 'struct clk*', argument 8 has type 'uchar[]'

	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit c2dd0e1d9da89fa13bc9e2aa58f2a24c9797a359)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_iocb.c
diff --cc drivers/scsi/qla2xxx/qla_iocb.c
index 430b293b4d6f,2c6a236dff96..000000000000
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@@ -2563,9 -2566,160 +2563,162 @@@ qla24xx_els_logo_iocb(srb_t *sp, struc
  }
  
  static void
++<<<<<<< HEAD
++=======
+ qla2x00_els_dcmd2_sp_free(void *data)
+ {
+ 	srb_t *sp = data;
+ 	struct srb_iocb *elsio = &sp->u.iocb_cmd;
+ 
+ 	if (elsio->u.els_plogi.els_plogi_pyld)
+ 		dma_free_coherent(&sp->vha->hw->pdev->dev, DMA_POOL_SIZE,
+ 		    elsio->u.els_plogi.els_plogi_pyld,
+ 		    elsio->u.els_plogi.els_plogi_pyld_dma);
+ 
+ 	if (elsio->u.els_plogi.els_resp_pyld)
+ 		dma_free_coherent(&sp->vha->hw->pdev->dev, DMA_POOL_SIZE,
+ 		    elsio->u.els_plogi.els_resp_pyld,
+ 		    elsio->u.els_plogi.els_resp_pyld_dma);
+ 
+ 	del_timer(&elsio->timer);
+ 	qla2x00_rel_sp(sp);
+ }
+ 
+ static void
+ qla2x00_els_dcmd2_iocb_timeout(void *data)
+ {
+ 	srb_t *sp = data;
+ 	fc_port_t *fcport = sp->fcport;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	struct srb_iocb *lio = &sp->u.iocb_cmd;
+ 	unsigned long flags = 0;
+ 	int res;
+ 
+ 	ql_dbg(ql_dbg_io + ql_dbg_disc, vha, 0x3069,
+ 	    "%s hdl=%x ELS Timeout, %8phC portid=%06x\n",
+ 	    sp->name, sp->handle, fcport->port_name, fcport->d_id.b24);
+ 
+ 	/* Abort the exchange */
+ 	spin_lock_irqsave(&ha->hardware_lock, flags);
+ 	res = ha->isp_ops->abort_command(sp);
+ 	ql_dbg(ql_dbg_io, vha, 0x3070,
+ 	    "mbx abort_command %s\n",
+ 	    (res == QLA_SUCCESS) ? "successful" : "failed");
+ 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 
+ 	complete(&lio->u.els_plogi.comp);
+ }
+ 
+ static void
+ qla2x00_els_dcmd2_sp_done(void *ptr, int res)
+ {
+ 	srb_t *sp = ptr;
+ 	fc_port_t *fcport = sp->fcport;
+ 	struct srb_iocb *lio = &sp->u.iocb_cmd;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 
+ 	ql_dbg(ql_dbg_io + ql_dbg_disc, vha, 0x3072,
+ 	    "%s ELS hdl=%x, portid=%06x done %8phC\n",
+ 	    sp->name, sp->handle, fcport->d_id.b24, fcport->port_name);
+ 
+ 	complete(&lio->u.els_plogi.comp);
+ }
+ 
+ int
+ qla24xx_els_dcmd2_iocb(scsi_qla_host_t *vha, int els_opcode,
+ 		       fc_port_t *fcport, port_id_t remote_did)
+ {
+ 	srb_t *sp;
+ 	struct srb_iocb *elsio = NULL;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	int rval = QLA_SUCCESS;
+ 	void	*ptr, *resp_ptr;
+ 	dma_addr_t ptr_dma;
+ 
+ 	/* Alloc SRB structure */
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp) {
+ 		ql_log(ql_log_info, vha, 0x70e6,
+ 		 "SRB allocation failed\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	elsio = &sp->u.iocb_cmd;
+ 	fcport->d_id.b.domain = remote_did.b.domain;
+ 	fcport->d_id.b.area = remote_did.b.area;
+ 	fcport->d_id.b.al_pa = remote_did.b.al_pa;
+ 
+ 	ql_dbg(ql_dbg_io, vha, 0x3073,
+ 	    "Enter: PLOGI portid=%06x\n", fcport->d_id.b24);
+ 
+ 	sp->type = SRB_ELS_DCMD;
+ 	sp->name = "ELS_DCMD";
+ 	sp->fcport = fcport;
+ 	qla2x00_init_timer(sp, ELS_DCMD_TIMEOUT);
+ 	elsio->timeout = qla2x00_els_dcmd2_iocb_timeout;
+ 	sp->done = qla2x00_els_dcmd2_sp_done;
+ 	sp->free = qla2x00_els_dcmd2_sp_free;
+ 
+ 	ptr = elsio->u.els_plogi.els_plogi_pyld =
+ 	    dma_alloc_coherent(&ha->pdev->dev, DMA_POOL_SIZE,
+ 		&elsio->u.els_plogi.els_plogi_pyld_dma, GFP_KERNEL);
+ 	ptr_dma = elsio->u.els_plogi.els_plogi_pyld_dma;
+ 
+ 	if (!elsio->u.els_plogi.els_plogi_pyld) {
+ 		rval = QLA_FUNCTION_FAILED;
+ 		goto out;
+ 	}
+ 
+ 	resp_ptr = elsio->u.els_plogi.els_resp_pyld =
+ 	    dma_alloc_coherent(&ha->pdev->dev, DMA_POOL_SIZE,
+ 		&elsio->u.els_plogi.els_resp_pyld_dma, GFP_KERNEL);
+ 
+ 	if (!elsio->u.els_plogi.els_resp_pyld) {
+ 		rval = QLA_FUNCTION_FAILED;
+ 		goto out;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_io, vha, 0x3073, "PLOGI %p %p\n", ptr, resp_ptr);
+ 
+ 	memset(ptr, 0, sizeof(struct els_plogi_payload));
+ 	memset(resp_ptr, 0, sizeof(struct els_plogi_payload));
+ 	elsio->u.els_plogi.els_cmd = els_opcode;
+ 	elsio->u.els_plogi.els_plogi_pyld->opcode = els_opcode;
+ 	qla24xx_get_port_login_templ(vha, ptr_dma + 4,
+ 		&elsio->u.els_plogi.els_plogi_pyld->data[0],
+ 		sizeof(struct els_plogi_payload));
+ 
+ 	ql_dbg(ql_dbg_io + ql_dbg_buffer, vha, 0x3073, "PLOGI buffer:\n");
+ 	ql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x0109,
+ 	    (uint8_t *)elsio->u.els_plogi.els_plogi_pyld, 0x70);
+ 
+ 	init_completion(&elsio->u.els_plogi.comp);
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS) {
+ 		rval = QLA_FUNCTION_FAILED;
+ 		goto out;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_io, vha, 0x3074,
+ 	    "%s PLOGI sent, hdl=%x, loopid=%x, portid=%06x\n",
+ 	    sp->name, sp->handle, fcport->loop_id, fcport->d_id.b24);
+ 
+ 	wait_for_completion(&elsio->u.els_plogi.comp);
+ 
+ 	if (elsio->u.els_plogi.comp_status != CS_COMPLETE)
+ 		rval = QLA_FUNCTION_FAILED;
+ 
+ out:
+ 	sp->free(sp);
+ 	return rval;
+ }
+ 
+ static void
++>>>>>>> c2dd0e1d9da8 (scsi: qla2xxx: Fix warning during port_name debug print)
  qla24xx_els_iocb(srb_t *sp, struct els_entry_24xx *els_iocb)
  {
 -	struct bsg_job *bsg_job = sp->u.bsg_job;
 -	struct fc_bsg_request *bsg_request = bsg_job->request;
 +	struct fc_bsg_job *bsg_job = sp->u.bsg_job;
  
          els_iocb->entry_type = ELS_IOCB_TYPE;
          els_iocb->entry_count = 1;
* Unmerged path drivers/scsi/qla2xxx/qla_iocb.c
