perf tools: Use scandir() to replace readdir()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Kan Liang <kan.liang@intel.com>
commit ecdad24d7a4480c9af0ff6dbe00ac8bbae720d19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ecdad24d.failed

In perf_event__synthesize_threads() perf goes through all proc files
serially by readdir.

scandir() does a snapshoot of /proc, which is multithreading friendly.

It's possible that some threads which are added during event synthesize.
But the number of lost threads should be small.  They should not impact
the final analysis.

	Signed-off-by: Kan Liang <kan.liang@intel.com>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Lukasz Odzioba <lukasz.odzioba@intel.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/1504806954-150842-3-git-send-email-kan.liang@intel.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit ecdad24d7a4480c9af0ff6dbe00ac8bbae720d19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/event.c
diff --cc tools/perf/util/event.c
index ac6ce5ceef74,17c21ea68a72..000000000000
--- a/tools/perf/util/event.c
+++ b/tools/perf/util/event.c
@@@ -593,11 -683,14 +593,17 @@@ int perf_event__synthesize_threads(stru
  				   bool mmap_data,
  				   unsigned int proc_map_timeout)
  {
- 	DIR *proc;
- 	char proc_path[PATH_MAX];
- 	struct dirent *dirent;
  	union perf_event *comm_event, *mmap_event, *fork_event;
++<<<<<<< HEAD
++=======
+ 	union perf_event *namespaces_event;
+ 	char proc_path[PATH_MAX];
+ 	struct dirent **dirent;
++>>>>>>> ecdad24d7a44 (perf tools: Use scandir() to replace readdir())
  	int err = -1;
+ 	char *end;
+ 	pid_t pid;
+ 	int n, i;
  
  	if (machine__is_default_guest(machine))
  		return 0;
@@@ -614,29 -707,41 +620,55 @@@
  	if (fork_event == NULL)
  		goto out_free_mmap;
  
 -	namespaces_event = malloc(sizeof(namespaces_event->namespaces) +
 -				  (NR_NAMESPACES * sizeof(struct perf_ns_link_info)) +
 -				  machine->id_hdr_size);
 -	if (namespaces_event == NULL)
 -		goto out_free_fork;
 -
  	snprintf(proc_path, sizeof(proc_path), "%s/proc", machine->root_dir);
- 	proc = opendir(proc_path);
+ 	n = scandir(proc_path, &dirent, 0, alphasort);
  
++<<<<<<< HEAD
 +	if (proc == NULL)
 +		goto out_free_fork;
++=======
+ 	if (n < 0)
+ 		goto out_free_namespaces;
++>>>>>>> ecdad24d7a44 (perf tools: Use scandir() to replace readdir())
  
- 	while ((dirent = readdir(proc)) != NULL) {
- 		char *end;
- 		pid_t pid = strtol(dirent->d_name, &end, 10);
- 
- 		if (*end) /* only interested in proper numerical dirents */
+ 	for (i = 0; i < n; i++) {
+ 		if (!isdigit(dirent[i]->d_name[0]))
  			continue;
++<<<<<<< HEAD
 +		/*
 + 		 * We may race with exiting thread, so don't stop just because
 + 		 * one thread couldn't be synthesized.
 + 		 */
 +		__event__synthesize_thread(comm_event, mmap_event, fork_event, pid,
 +					   1, process, tool, machine, mmap_data,
 +					   proc_map_timeout);
 +	}
- 
++=======
++>>>>>>> ecdad24d7a44 (perf tools: Use scandir() to replace readdir())
+ 
+ 		pid = (pid_t)strtol(dirent[i]->d_name, &end, 10);
+ 		/* only interested in proper numerical dirents */
+ 		if (!*end) {
+ 			/*
+ 			 * We may race with exiting thread, so don't stop just because
+ 			 * one thread couldn't be synthesized.
+ 			 */
+ 			__event__synthesize_thread(comm_event, mmap_event, fork_event,
+ 						   namespaces_event, pid, 1, process,
+ 						   tool, machine, mmap_data,
+ 						   proc_map_timeout);
+ 		}
+ 		free(dirent[i]);
+ 	}
+ 	free(dirent);
  	err = 0;
++<<<<<<< HEAD
 +	closedir(proc);
++=======
+ 
+ out_free_namespaces:
+ 	free(namespaces_event);
++>>>>>>> ecdad24d7a44 (perf tools: Use scandir() to replace readdir())
  out_free_fork:
  	free(fork_event);
  out_free_mmap:
* Unmerged path tools/perf/util/event.c
