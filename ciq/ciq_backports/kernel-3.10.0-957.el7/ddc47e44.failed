xfrm: Fix stack-out-of-bounds read on socket policy lookup.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] xfrm: Fix stack-out-of-bounds read on socket policy lookup (Ravi Aysola) [1499471]
Rebuild_FUZZ: 99.15%
commit-author Steffen Klassert <steffen.klassert@secunet.com>
commit ddc47e4404b58f03e98345398fb12d38fe291512
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ddc47e44.failed

When we do tunnel or beet mode, we pass saddr and daddr from the
template to xfrm_state_find(), this is ok. On transport mode,
we pass the addresses from the flowi, assuming that the IP
addresses (and address family) don't change during transformation.
This assumption is wrong in the IPv4 mapped IPv6 case, packet
is IPv4 and template is IPv6.

Fix this by catching address family missmatches of the policy
and the flow already before we do the lookup.

	Reported-by: syzbot <syzkaller@googlegroups.com>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit ddc47e4404b58f03e98345398fb12d38fe291512)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xfrm/xfrm_policy.c
diff --cc net/xfrm/xfrm_policy.c
index 82411ade823d,038ec68f6901..000000000000
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@@ -1183,49 -1164,19 +1183,63 @@@ xfrm_policy_lookup(struct net *net, con
  {
  	struct xfrm_policy *pol;
  
++<<<<<<< HEAD
 +	if (old_obj)
 +		xfrm_pol_put(container_of(old_obj, struct xfrm_policy, flo));
 +
 +	pol = __xfrm_policy_lookup(net, fl, family, flow_to_policy_dir(dir));
 +	if (IS_ERR_OR_NULL(pol))
 +		return ERR_CAST(pol);
 +
 +	/* Resolver returns two references:
 +	 * one for cache and one for caller of flow_cache_lookup() */
 +	xfrm_pol_hold(pol);
 +
 +	return &pol->flo;
 +}
 +
 +static inline int policy_to_flow_dir(int dir)
 +{
 +	if (XFRM_POLICY_IN == FLOW_DIR_IN &&
 +	    XFRM_POLICY_OUT == FLOW_DIR_OUT &&
 +	    XFRM_POLICY_FWD == FLOW_DIR_FWD)
 +		return dir;
 +	switch (dir) {
 +	default:
 +	case XFRM_POLICY_IN:
 +		return FLOW_DIR_IN;
 +	case XFRM_POLICY_OUT:
 +		return FLOW_DIR_OUT;
 +	case XFRM_POLICY_FWD:
 +		return FLOW_DIR_FWD;
 +	}
 +}
 +
 +static struct xfrm_policy *xfrm_sk_policy_lookup(struct sock *sk, int dir,
 +						 const struct flowi *fl)
 +{
 +	struct xfrm_policy *pol;
 +	struct net *net = sock_net(sk);
 +
 +	read_lock_bh(&net->xfrm_policy_lock);
 +	if ((pol = sk->sk_policy[dir]) != NULL) {
 +		bool match = xfrm_selector_match(&pol->selector, fl,
 +						 sk->sk_family);
++=======
+ 	rcu_read_lock();
+  again:
+ 	pol = rcu_dereference(sk->sk_policy[dir]);
+ 	if (pol != NULL) {
+ 		bool match;
++>>>>>>> ddc47e4404b5 (xfrm: Fix stack-out-of-bounds read on socket policy lookup.)
  		int err = 0;
  
+ 		if (pol->family != family) {
+ 			pol = NULL;
+ 			goto out;
+ 		}
+ 
+ 		match = xfrm_selector_match(&pol->selector, fl, family);
  		if (match) {
  			if ((sk->sk_mark & pol->mark.m) != pol->mark.v) {
  				pol = NULL;
* Unmerged path net/xfrm/xfrm_policy.c
