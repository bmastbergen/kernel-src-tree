mmc: sdhci-pci: Do not disable interrupts in sdhci_intel_set_power

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] sdhci-pci: Do not disable interrupts in sdhci_intel_set_power (Gopal Tiwari) [1549495]
Rebuild_FUZZ: 96.06%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 027fb89e61054b4aedd962adb3e2003dec78a716
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/027fb89e.failed

Disabling interrupts for even a millisecond can cause problems for some
devices. That can happen when Intel host controllers wait for the present
state to propagate.

The spin lock is not necessary here. Anything that is racing with changes
to the I/O state is already broken. The mmc core already provides
synchronization via "claiming" the host.

Although the spin lock probably should be removed from the code paths that
lead to this point, such a patch would touch too much code to be suitable
for stable trees. Consequently, for this patch, just drop the spin lock
while waiting.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Cc: stable@vger.kernel.org # v4.9+
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Tested-by: Ludovic Desroches <ludovic.desroches@microchip.com>
(cherry picked from commit 027fb89e61054b4aedd962adb3e2003dec78a716)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci-pci-core.c
diff --cc drivers/mmc/host/sdhci-pci-core.c
index cdfda9db34e1,86560d590786..000000000000
--- a/drivers/mmc/host/sdhci-pci-core.c
+++ b/drivers/mmc/host/sdhci-pci-core.c
@@@ -506,6 -437,49 +506,52 @@@ static int byt_sd_probe_slot(struct sdh
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ #define SDHCI_INTEL_PWR_TIMEOUT_CNT	20
+ #define SDHCI_INTEL_PWR_TIMEOUT_UDELAY	100
+ 
+ static void sdhci_intel_set_power(struct sdhci_host *host, unsigned char mode,
+ 				  unsigned short vdd)
+ {
+ 	int cntr;
+ 	u8 reg;
+ 
+ 	sdhci_set_power(host, mode, vdd);
+ 
+ 	if (mode == MMC_POWER_OFF)
+ 		return;
+ 
+ 	spin_unlock_irq(&host->lock);
+ 
+ 	/*
+ 	 * Bus power might not enable after D3 -> D0 transition due to the
+ 	 * present state not yet having propagated. Retry for up to 2ms.
+ 	 */
+ 	for (cntr = 0; cntr < SDHCI_INTEL_PWR_TIMEOUT_CNT; cntr++) {
+ 		reg = sdhci_readb(host, SDHCI_POWER_CONTROL);
+ 		if (reg & SDHCI_POWER_ON)
+ 			break;
+ 		udelay(SDHCI_INTEL_PWR_TIMEOUT_UDELAY);
+ 		reg |= SDHCI_POWER_ON;
+ 		sdhci_writeb(host, reg, SDHCI_POWER_CONTROL);
+ 	}
+ 
+ 	spin_lock_irq(&host->lock);
+ }
+ 
+ static const struct sdhci_ops sdhci_intel_byt_ops = {
+ 	.set_clock		= sdhci_set_clock,
+ 	.set_power		= sdhci_intel_set_power,
+ 	.enable_dma		= sdhci_pci_enable_dma,
+ 	.set_bus_width		= sdhci_pci_set_bus_width,
+ 	.reset			= sdhci_reset,
+ 	.set_uhs_signaling	= sdhci_set_uhs_signaling,
+ 	.hw_reset		= sdhci_pci_hw_reset,
+ 	.select_drive_strength	= sdhci_pci_select_drive_strength,
+ };
+ 
++>>>>>>> 027fb89e6105 (mmc: sdhci-pci: Do not disable interrupts in sdhci_intel_set_power)
  static const struct sdhci_pci_fixes sdhci_intel_byt_emmc = {
  	.allow_runtime_pm = true,
  	.probe_slot	= byt_emmc_probe_slot,
* Unmerged path drivers/mmc/host/sdhci-pci-core.c
