mm: replace __access_remote_vm() write parameter with gup_flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mm] replace __access_remote_vm() write parameter with gup_flags (Oleg Nesterov) [1576338]
Rebuild_FUZZ: 96.72%
commit-author Lorenzo Stoakes <lstoakes@gmail.com>
commit 442486ec1096781c50227b73f721a63974b0fdda
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/442486ec.failed

This removes the 'write' argument from __access_remote_vm() and replaces
it with 'gup_flags' as use of this function previously silently implied
FOLL_FORCE, whereas after this patch callers explicitly pass this flag.

We make this explicit as use of FOLL_FORCE can result in surprising
behaviour (and hence bugs) within the mm subsystem.

	Signed-off-by: Lorenzo Stoakes <lstoakes@gmail.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 442486ec1096781c50227b73f721a63974b0fdda)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory.c
diff --cc mm/memory.c
index 41eaf1c61cf6,79ebed3a4c2b..000000000000
--- a/mm/memory.c
+++ b/mm/memory.c
@@@ -3834,6 -3873,7 +3834,10 @@@ static int __access_remote_vm(struct ta
  {
  	struct vm_area_struct *vma;
  	void *old_buf = buf;
++<<<<<<< HEAD
++=======
+ 	int write = gup_flags & FOLL_WRITE;
++>>>>>>> 442486ec1096 (mm: replace __access_remote_vm() write parameter with gup_flags)
  
  	down_read(&mm->mmap_sem);
  	/* ignore errors, just check how much was successfully transferred */
@@@ -3843,8 -3883,11 +3847,12 @@@
  		struct page *page = NULL;
  
  		ret = get_user_pages_remote(tsk, mm, addr, 1,
++<<<<<<< HEAD
 +				write, 1, &page, &vma);
++=======
+ 				gup_flags, &page, &vma);
++>>>>>>> 442486ec1096 (mm: replace __access_remote_vm() write parameter with gup_flags)
  		if (ret <= 0) {
 -#ifndef CONFIG_HAVE_IOREMAP_PROT
 -			break;
 -#else
  			/*
  			 * Check if this is a VM_IO | VM_PFNMAP VMA, which
  			 * we can access using slightly different code.
* Unmerged path mm/memory.c
diff --git a/mm/nommu.c b/mm/nommu.c
index 636f04e40f81..98b8efab9b7d 100644
--- a/mm/nommu.c
+++ b/mm/nommu.c
@@ -2036,9 +2036,10 @@ int generic_file_remap_pages(struct vm_area_struct *vma, unsigned long addr,
 EXPORT_SYMBOL(generic_file_remap_pages);
 
 static int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,
-		unsigned long addr, void *buf, int len, int write)
+		unsigned long addr, void *buf, int len, unsigned int gup_flags)
 {
 	struct vm_area_struct *vma;
+	int write = gup_flags & FOLL_WRITE;
 
 	down_read(&mm->mmap_sem);
 
@@ -2080,7 +2081,8 @@ static int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,
 int access_remote_vm(struct mm_struct *mm, unsigned long addr,
 		void *buf, int len, int write)
 {
-	return __access_remote_vm(NULL, mm, addr, buf, len, write);
+	return __access_remote_vm(NULL, mm, addr, buf, len,
+			write ? FOLL_WRITE : 0);
 }
 
 /*
@@ -2098,7 +2100,8 @@ int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, in
 	if (!mm)
 		return 0;
 
-	len = __access_remote_vm(tsk, mm, addr, buf, len, write);
+	len = __access_remote_vm(tsk, mm, addr, buf, len,
+			write ? FOLL_WRITE : 0);
 
 	mmput(mm);
 	return len;
