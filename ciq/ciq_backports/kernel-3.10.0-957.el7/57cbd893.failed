net/mlx5: E-Switch, Move representors definition to a global scope

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Move representors definition to a global scope (Alaa Hleihel) [1595687]
Rebuild_FUZZ: 96.88%
commit-author Mark Bloch <markb@mellanox.com>
commit 57cbd893c4c575a24594fa6c0835247506ce26e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/57cbd893.failed

In preparation for IB representors, move representors structs to a global
scope, also expose functions needed for registration, unregistration,
eswitch mode and creating a flow rule to direct traffic from SQs to the
right VF.

	Signed-off-by: Mark Bloch <markb@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 57cbd893c4c575a24594fa6c0835247506ce26e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 52a968f41531,9c1e1a2d02ef..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -35,17 -35,11 +35,21 @@@
  
  #include <linux/if_ether.h>
  #include <linux/if_link.h>
 +#include <linux/hashtable.h>
  #include <net/devlink.h>
  #include <linux/mlx5/device.h>
+ #include <linux/mlx5/eswitch.h>
  #include "lib/mpfs.h"
  
++<<<<<<< HEAD
 +enum {
 +	SRIOV_NONE,
 +	SRIOV_LEGACY,
 +	SRIOV_OFFLOADS
 +};
 +
++=======
++>>>>>>> 57cbd893c4c5 (net/mlx5: E-Switch, Move representors definition to a global scope)
  #ifdef CONFIG_MLX5_ESWITCH
  
  #define MLX5_MAX_UC_PER_VPORT(dev) \
@@@ -141,27 -135,6 +145,30 @@@ struct mlx5_eswitch_fdb 
  	};
  };
  
++<<<<<<< HEAD
 +struct mlx5_esw_sq {
 +	struct mlx5_flow_handle	*send_to_vport_rule;
 +	struct list_head	 list;
 +};
 +
 +struct mlx5_eswitch_rep {
 +	int		       (*load)(struct mlx5_eswitch *esw,
 +				       struct mlx5_eswitch_rep *rep);
 +	void		       (*unload)(struct mlx5_eswitch *esw,
 +					 struct mlx5_eswitch_rep *rep);
 +	u16		       vport;
 +	u8		       hw_id[ETH_ALEN];
 +	struct net_device      *netdev;
 +
 +	struct mlx5_flow_handle *vport_rx_rule;
 +	struct list_head       vport_sqs_list;
 +	u16		       vlan;
 +	u32		       vlan_refcount;
 +	bool		       valid;
 +};
 +
++=======
++>>>>>>> 57cbd893c4c5 (net/mlx5: E-Switch, Move representors definition to a global scope)
  struct mlx5_esw_offload {
  	struct mlx5_flow_table *ft_offloads;
  	struct mlx5_flow_group *vport_rx_group;
@@@ -280,12 -248,7 +284,16 @@@ int mlx5_devlink_eswitch_inline_mode_ge
  int mlx5_eswitch_inline_mode_get(struct mlx5_eswitch *esw, int nvfs, u8 *mode);
  int mlx5_devlink_eswitch_encap_mode_set(struct devlink *devlink, u8 encap);
  int mlx5_devlink_eswitch_encap_mode_get(struct devlink *devlink, u8 *encap);
++<<<<<<< HEAD
 +void mlx5_eswitch_register_vport_rep(struct mlx5_eswitch *esw,
 +				     int vport_index,
 +				     struct mlx5_eswitch_rep *rep);
 +void mlx5_eswitch_unregister_vport_rep(struct mlx5_eswitch *esw,
 +				       int vport_index);
 +struct net_device *mlx5_eswitch_get_uplink_netdev(struct mlx5_eswitch *esw);
++=======
+ void *mlx5_eswitch_get_uplink_priv(struct mlx5_eswitch *esw, u8 rep_type);
++>>>>>>> 57cbd893c4c5 (net/mlx5: E-Switch, Move representors definition to a global scope)
  
  int mlx5_eswitch_add_vlan_action(struct mlx5_eswitch *esw,
  				 struct mlx5_esw_flow_attr *attr);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 3c1ae524876d,92fdb10dd29f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1137,23 -1151,25 +1138,24 @@@ int mlx5_devlink_eswitch_encap_mode_get
  
  void mlx5_eswitch_register_vport_rep(struct mlx5_eswitch *esw,
  				     int vport_index,
 -				     struct mlx5_eswitch_rep_if *__rep_if,
 -				     u8 rep_type)
 +				     struct mlx5_eswitch_rep *__rep)
  {
  	struct mlx5_esw_offload *offloads = &esw->offloads;
 -	struct mlx5_eswitch_rep_if *rep_if;
 +	struct mlx5_eswitch_rep *rep;
  
 -	rep_if = &offloads->vport_reps[vport_index].rep_if[rep_type];
 +	rep = &offloads->vport_reps[vport_index];
  
 -	rep_if->load   = __rep_if->load;
 -	rep_if->unload = __rep_if->unload;
 -	rep_if->get_proto_dev = __rep_if->get_proto_dev;
 -	rep_if->priv = __rep_if->priv;
 +	rep->load   = __rep->load;
 +	rep->unload = __rep->unload;
 +	rep->netdev = __rep->netdev;
  
 -	rep_if->valid = true;
 +	INIT_LIST_HEAD(&rep->vport_sqs_list);
 +	rep->valid = true;
  }
+ EXPORT_SYMBOL(mlx5_eswitch_register_vport_rep);
  
  void mlx5_eswitch_unregister_vport_rep(struct mlx5_eswitch *esw,
 -				       int vport_index, u8 rep_type)
 +				       int vport_index)
  {
  	struct mlx5_esw_offload *offloads = &esw->offloads;
  	struct mlx5_eswitch_rep *rep;
@@@ -1161,17 -1177,50 +1163,54 @@@
  	rep = &offloads->vport_reps[vport_index];
  
  	if (esw->mode == SRIOV_OFFLOADS && esw->vports[vport_index].enabled)
 -		rep->rep_if[rep_type].unload(rep);
 +		rep->unload(esw, rep);
  
 -	rep->rep_if[rep_type].valid = false;
 +	rep->valid = false;
  }
+ EXPORT_SYMBOL(mlx5_eswitch_unregister_vport_rep);
  
 -void *mlx5_eswitch_get_uplink_priv(struct mlx5_eswitch *esw, u8 rep_type)
 +struct net_device *mlx5_eswitch_get_uplink_netdev(struct mlx5_eswitch *esw)
  {
  #define UPLINK_REP_INDEX 0
  	struct mlx5_esw_offload *offloads = &esw->offloads;
  	struct mlx5_eswitch_rep *rep;
  
  	rep = &offloads->vport_reps[UPLINK_REP_INDEX];
++<<<<<<< HEAD
 +	return rep->netdev;
++=======
+ 	return rep->rep_if[rep_type].priv;
  }
+ 
+ void *mlx5_eswitch_get_proto_dev(struct mlx5_eswitch *esw,
+ 				 int vport,
+ 				 u8 rep_type)
+ {
+ 	struct mlx5_esw_offload *offloads = &esw->offloads;
+ 	struct mlx5_eswitch_rep *rep;
+ 
+ 	if (vport == FDB_UPLINK_VPORT)
+ 		vport = UPLINK_REP_INDEX;
+ 
+ 	rep = &offloads->vport_reps[vport];
+ 
+ 	if (rep->rep_if[rep_type].valid &&
+ 	    rep->rep_if[rep_type].get_proto_dev)
+ 		return rep->rep_if[rep_type].get_proto_dev(rep);
+ 	return NULL;
+ }
+ EXPORT_SYMBOL(mlx5_eswitch_get_proto_dev);
+ 
+ void *mlx5_eswitch_uplink_get_proto_dev(struct mlx5_eswitch *esw, u8 rep_type)
+ {
+ 	return mlx5_eswitch_get_proto_dev(esw, UPLINK_REP_INDEX, rep_type);
++>>>>>>> 57cbd893c4c5 (net/mlx5: E-Switch, Move representors definition to a global scope)
+ }
+ EXPORT_SYMBOL(mlx5_eswitch_uplink_get_proto_dev);
+ 
+ struct mlx5_eswitch_rep *mlx5_eswitch_vport_rep(struct mlx5_eswitch *esw,
+ 						int vport)
+ {
+ 	return &esw->offloads.vport_reps[vport];
+ }
+ EXPORT_SYMBOL(mlx5_eswitch_vport_rep);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 5ecfef87628e..46e66191a8b6 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@ -2176,3 +2176,9 @@ free_out:
 	kvfree(out);
 	return err;
 }
+
+u8 mlx5_eswitch_mode(struct mlx5_eswitch *esw)
+{
+	return esw->mode;
+}
+EXPORT_SYMBOL_GPL(mlx5_eswitch_mode);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index be4dee8a6a5f..aa3ad3e8c4d3 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@ -42,12 +42,6 @@
 #define DRIVER_NAME "mlx5_core"
 #define DRIVER_VERSION "5.0-0"
 
-#define MLX5_TOTAL_VPORTS(mdev) (1 + pci_sriov_get_totalvfs(mdev->pdev))
-#define MLX5_VPORT_MANAGER(mdev) \
-	(MLX5_CAP_GEN(mdev, vport_group_manager) && \
-	(MLX5_CAP_GEN(mdev, port_type) == MLX5_CAP_PORT_TYPE_ETH) && \
-	 mlx5_core_is_pf(mdev))
-
 extern uint mlx5_core_debug_mask;
 
 #define mlx5_core_dbg(__dev, format, ...)				\
diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h
index 43684956d433..8128006eab35 100644
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -1221,6 +1221,12 @@ static inline int mlx5_core_is_pf(struct mlx5_core_dev *dev)
 	return !(dev->priv.pci_dev_data & MLX5_PCI_DEV_IS_VF);
 }
 
+#define MLX5_TOTAL_VPORTS(mdev) (1 + pci_sriov_get_totalvfs((mdev)->pdev))
+#define MLX5_VPORT_MANAGER(mdev) \
+	(MLX5_CAP_GEN(mdev, vport_group_manager) && \
+	 (MLX5_CAP_GEN(mdev, port_type) == MLX5_CAP_PORT_TYPE_ETH) && \
+	 mlx5_core_is_pf(mdev))
+
 static inline int mlx5_get_gid_table_len(u16 param)
 {
 	if (param > 4) {
diff --git a/include/linux/mlx5/eswitch.h b/include/linux/mlx5/eswitch.h
new file mode 100644
index 000000000000..f62bf486c18c
--- /dev/null
+++ b/include/linux/mlx5/eswitch.h
@@ -0,0 +1,57 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * Copyright (c) 2018 Mellanox Technologies. All rights reserved.
+ */
+
+#ifndef _MLX5_ESWITCH_
+#define _MLX5_ESWITCH_
+
+#include <linux/mlx5/driver.h>
+
+enum {
+	SRIOV_NONE,
+	SRIOV_LEGACY,
+	SRIOV_OFFLOADS
+};
+
+enum {
+	REP_ETH,
+	NUM_REP_TYPES,
+};
+
+struct mlx5_eswitch_rep;
+struct mlx5_eswitch_rep_if {
+	int		       (*load)(struct mlx5_core_dev *dev,
+				       struct mlx5_eswitch_rep *rep);
+	void		       (*unload)(struct mlx5_eswitch_rep *rep);
+	void		       *(*get_proto_dev)(struct mlx5_eswitch_rep *rep);
+	void			*priv;
+	bool		       valid;
+};
+
+struct mlx5_eswitch_rep {
+	struct mlx5_eswitch_rep_if rep_if[NUM_REP_TYPES];
+	u16		       vport;
+	u8		       hw_id[ETH_ALEN];
+	u16		       vlan;
+	u32		       vlan_refcount;
+};
+
+void mlx5_eswitch_register_vport_rep(struct mlx5_eswitch *esw,
+				     int vport_index,
+				     struct mlx5_eswitch_rep_if *rep_if,
+				     u8 rep_type);
+void mlx5_eswitch_unregister_vport_rep(struct mlx5_eswitch *esw,
+				       int vport_index,
+				       u8 rep_type);
+void *mlx5_eswitch_get_proto_dev(struct mlx5_eswitch *esw,
+				 int vport,
+				 u8 rep_type);
+struct mlx5_eswitch_rep *mlx5_eswitch_vport_rep(struct mlx5_eswitch *esw,
+						int vport);
+void *mlx5_eswitch_uplink_get_proto_dev(struct mlx5_eswitch *esw, u8 rep_type);
+u8 mlx5_eswitch_mode(struct mlx5_eswitch *esw);
+struct mlx5_flow_handle *
+mlx5_eswitch_add_send_to_vport_rule(struct mlx5_eswitch *esw,
+				    int vport, u32 sqn);
+#endif
