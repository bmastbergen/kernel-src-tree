netfilter: ipset: Fix wraparound in hash:*net* types

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 0b8d9073539e217f79ec1bff65eb205ac796723d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0b8d9073.failed

Fix wraparound bug which could lead to memory exhaustion when adding an
x.x.x.x-255.255.255.255 range to any hash:*net* types.

Fixes Netfilter's bugzilla id #1212, reported by Thomas Schwark.

Fixes: 48596a8ddc46 ("netfilter: ipset: Fix adding an IPv4 range containing more than 2^31 addresses")
	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 0b8d9073539e217f79ec1bff65eb205ac796723d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_hash_ipportnet.c
#	net/netfilter/ipset/ip_set_hash_net.c
#	net/netfilter/ipset/ip_set_hash_netiface.c
#	net/netfilter/ipset/ip_set_hash_netnet.c
#	net/netfilter/ipset/ip_set_hash_netport.c
#	net/netfilter/ipset/ip_set_hash_netportnet.c
diff --cc net/netfilter/ipset/ip_set_hash_ipportnet.c
index bb1a8e8f02c9,88b83d6d3084..000000000000
--- a/net/netfilter/ipset/ip_set_hash_ipportnet.c
+++ b/net/netfilter/ipset/ip_set_hash_ipportnet.c
@@@ -192,12 -163,12 +192,12 @@@ static in
  hash_ipportnet4_uadt(struct ip_set *set, struct nlattr *tb[],
  		     enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
  {
 -	const struct hash_ipportnet4 *h = set->data;
 +	const struct hash_ipportnet *h = set->data;
  	ipset_adtfn adtfn = set->variant->adt[adt];
  	struct hash_ipportnet4_elem e = { .cidr = HOST_MASK - 1 };
 -	struct ip_set_ext ext = IP_SET_INIT_UEXT(set);
 +	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
  	u32 ip = 0, ip_to = 0, p = 0, port, port_to;
- 	u32 ip2_from = 0, ip2_to = 0, ip2_last, ip2;
+ 	u32 ip2_from = 0, ip2_to = 0, ip2;
  	bool with_ports = false;
  	u8 cidr;
  	int ret;
@@@ -295,35 -265,36 +295,54 @@@
  			swap(ip2_from, ip2_to);
  		if (ip2_from + UINT_MAX == ip2_to)
  			return -IPSET_ERR_HASH_RANGE;
 -	} else {
 +	} else
  		ip_set_mask_from_to(ip2_from, ip2_to, e.cidr + 1);
 -	}
  
- 	if (retried)
+ 	if (retried) {
  		ip = ntohl(h->next.ip);
++<<<<<<< HEAD
 +	for (; !before(ip_to, ip); ip++) {
++=======
+ 		p = ntohs(h->next.port);
+ 		ip2 = ntohl(h->next.ip2);
+ 	} else {
+ 		p = port;
+ 		ip2 = ip2_from;
+ 	}
+ 	for (; ip <= ip_to; ip++) {
++>>>>>>> 0b8d9073539e (netfilter: ipset: Fix wraparound in hash:*net* types)
  		e.ip = htonl(ip);
- 		p = retried && ip == ntohl(h->next.ip) ? ntohs(h->next.port)
- 						       : port;
  		for (; p <= port_to; p++) {
  			e.port = htons(p);
++<<<<<<< HEAD
 +			ip2 = retried
 +			      && ip == ntohl(h->next.ip)
 +			      && p == ntohs(h->next.port)
 +				? ntohl(h->next.ip2) : ip2_from;
 +			while (!after(ip2, ip2_to)) {
++=======
+ 			do {
++>>>>>>> 0b8d9073539e (netfilter: ipset: Fix wraparound in hash:*net* types)
  				e.ip2 = htonl(ip2);
- 				ip2_last = ip_set_range_to_cidr(ip2, ip2_to,
- 								&cidr);
+ 				ip2 = ip_set_range_to_cidr(ip2, ip2_to, &cidr);
  				e.cidr = cidr - 1;
  				ret = adtfn(set, &e, &ext, &ext, flags);
  
  				if (ret && !ip_set_eexist(ret, flags))
  					return ret;
++<<<<<<< HEAD
 +				else
 +					ret = 0;
 +				ip2 = ip2_last + 1;
 +			}
++=======
+ 
+ 				ret = 0;
+ 			} while (ip2++ < ip2_to);
+ 			ip2 = ip2_from;
++>>>>>>> 0b8d9073539e (netfilter: ipset: Fix wraparound in hash:*net* types)
  		}
+ 		p = port;
  	}
  	return ret;
  }
diff --cc net/netfilter/ipset/ip_set_hash_net.c
index 0a64dad156d9,5449e23af13a..000000000000
--- a/net/netfilter/ipset/ip_set_hash_net.c
+++ b/net/netfilter/ipset/ip_set_hash_net.c
@@@ -162,25 -139,25 +162,30 @@@ static in
  hash_net4_uadt(struct ip_set *set, struct nlattr *tb[],
  	       enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
  {
 -	const struct hash_net4 *h = set->data;
 +	const struct hash_net *h = set->data;
  	ipset_adtfn adtfn = set->variant->adt[adt];
  	struct hash_net4_elem e = { .cidr = HOST_MASK };
++<<<<<<< HEAD
 +	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
 +	u32 ip = 0, ip_to = 0, last;
++=======
+ 	struct ip_set_ext ext = IP_SET_INIT_UEXT(set);
+ 	u32 ip = 0, ip_to = 0;
++>>>>>>> 0b8d9073539e (netfilter: ipset: Fix wraparound in hash:*net* types)
  	int ret;
  
 -	if (tb[IPSET_ATTR_LINENO])
 -		*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);
 -
  	if (unlikely(!tb[IPSET_ATTR_IP] ||
 -		     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS) ||
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_PACKETS) ||
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_BYTES)))
  		return -IPSET_ERR_PROTOCOL;
  
 -	ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip);
 -	if (ret)
 -		return ret;
 +	if (tb[IPSET_ATTR_LINENO])
 +		*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);
  
 -	ret = ip_set_get_extensions(set, tb, &ext);
 +	ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip) ||
 +	      ip_set_get_extensions(set, tb, &ext);
  	if (ret)
  		return ret;
  
@@@ -215,16 -193,15 +220,26 @@@
  	}
  	if (retried)
  		ip = ntohl(h->next.ip);
++<<<<<<< HEAD
 +	while (!after(ip, ip_to)) {
++=======
+ 	do {
++>>>>>>> 0b8d9073539e (netfilter: ipset: Fix wraparound in hash:*net* types)
  		e.ip = htonl(ip);
- 		last = ip_set_range_to_cidr(ip, ip_to, &e.cidr);
+ 		ip = ip_set_range_to_cidr(ip, ip_to, &e.cidr);
  		ret = adtfn(set, &e, &ext, &ext, flags);
  		if (ret && !ip_set_eexist(ret, flags))
  			return ret;
++<<<<<<< HEAD
 +		else
 +			ret = 0;
 +		ip = last + 1;
 +	}
++=======
+ 
+ 		ret = 0;
+ 	} while (ip++ < ip_to);
++>>>>>>> 0b8d9073539e (netfilter: ipset: Fix wraparound in hash:*net* types)
  	return ret;
  }
  
diff --cc net/netfilter/ipset/ip_set_hash_netiface.c
index adaa3e8ab417,f5164c1efce2..000000000000
--- a/net/netfilter/ipset/ip_set_hash_netiface.c
+++ b/net/netfilter/ipset/ip_set_hash_netiface.c
@@@ -330,27 -196,26 +330,32 @@@ static in
  hash_netiface4_uadt(struct ip_set *set, struct nlattr *tb[],
  		    enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
  {
 -	struct hash_netiface4 *h = set->data;
 +	struct hash_netiface *h = set->data;
  	ipset_adtfn adtfn = set->variant->adt[adt];
  	struct hash_netiface4_elem e = { .cidr = HOST_MASK, .elem = 1 };
++<<<<<<< HEAD
 +	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
 +	u32 ip = 0, ip_to = 0, last;
 +	char iface[IFNAMSIZ];
++=======
+ 	struct ip_set_ext ext = IP_SET_INIT_UEXT(set);
+ 	u32 ip = 0, ip_to = 0;
++>>>>>>> 0b8d9073539e (netfilter: ipset: Fix wraparound in hash:*net* types)
  	int ret;
  
 -	if (tb[IPSET_ATTR_LINENO])
 -		*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);
 -
  	if (unlikely(!tb[IPSET_ATTR_IP] ||
  		     !tb[IPSET_ATTR_IFACE] ||
 -		     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS) ||
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_PACKETS) ||
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_BYTES)))
  		return -IPSET_ERR_PROTOCOL;
  
 -	ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip);
 -	if (ret)
 -		return ret;
 +	if (tb[IPSET_ATTR_LINENO])
 +		*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);
  
 -	ret = ip_set_get_extensions(set, tb, &ext);
 +	ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip) ||
 +	      ip_set_get_extensions(set, tb, &ext);
  	if (ret)
  		return ret;
  
@@@ -399,17 -254,17 +404,27 @@@
  
  	if (retried)
  		ip = ntohl(h->next.ip);
++<<<<<<< HEAD
 +	while (!after(ip, ip_to)) {
++=======
+ 	do {
++>>>>>>> 0b8d9073539e (netfilter: ipset: Fix wraparound in hash:*net* types)
  		e.ip = htonl(ip);
- 		last = ip_set_range_to_cidr(ip, ip_to, &e.cidr);
+ 		ip = ip_set_range_to_cidr(ip, ip_to, &e.cidr);
  		ret = adtfn(set, &e, &ext, &ext, flags);
  
  		if (ret && !ip_set_eexist(ret, flags))
  			return ret;
++<<<<<<< HEAD
 +		else
 +			ret = 0;
 +		ip = last + 1;
 +	}
++=======
+ 
+ 		ret = 0;
+ 	} while (ip++ < ip_to);
++>>>>>>> 0b8d9073539e (netfilter: ipset: Fix wraparound in hash:*net* types)
  	return ret;
  }
  
diff --cc net/netfilter/ipset/ip_set_hash_netport.c
index d98a685cd916,1a187be9ebc8..000000000000
--- a/net/netfilter/ipset/ip_set_hash_netport.c
+++ b/net/netfilter/ipset/ip_set_hash_netport.c
@@@ -183,11 -157,11 +183,16 @@@ static in
  hash_netport4_uadt(struct ip_set *set, struct nlattr *tb[],
  		   enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
  {
 -	const struct hash_netport4 *h = set->data;
 +	const struct hash_netport *h = set->data;
  	ipset_adtfn adtfn = set->variant->adt[adt];
  	struct hash_netport4_elem e = { .cidr = HOST_MASK - 1 };
++<<<<<<< HEAD
 +	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
 +	u32 port, port_to, p = 0, ip = 0, ip_to = 0, last;
++=======
+ 	struct ip_set_ext ext = IP_SET_INIT_UEXT(set);
+ 	u32 port, port_to, p = 0, ip = 0, ip_to = 0;
++>>>>>>> 0b8d9073539e (netfilter: ipset: Fix wraparound in hash:*net* types)
  	bool with_ports = false;
  	u8 cidr;
  	int ret;
@@@ -262,28 -235,30 +267,33 @@@
  			swap(ip, ip_to);
  		if (ip + UINT_MAX == ip_to)
  			return -IPSET_ERR_HASH_RANGE;
 -	} else {
 +	} else
  		ip_set_mask_from_to(ip, ip_to, e.cidr + 1);
 -	}
  
- 	if (retried)
+ 	if (retried) {
  		ip = ntohl(h->next.ip);
++<<<<<<< HEAD
 +	while (!after(ip, ip_to)) {
++=======
+ 		p = ntohs(h->next.port);
+ 	} else {
+ 		p = port;
+ 	}
+ 	do {
++>>>>>>> 0b8d9073539e (netfilter: ipset: Fix wraparound in hash:*net* types)
  		e.ip = htonl(ip);
- 		last = ip_set_range_to_cidr(ip, ip_to, &cidr);
+ 		ip = ip_set_range_to_cidr(ip, ip_to, &cidr);
  		e.cidr = cidr - 1;
- 		p = retried && ip == ntohl(h->next.ip) ? ntohs(h->next.port)
- 						       : port;
  		for (; p <= port_to; p++) {
  			e.port = htons(p);
  			ret = adtfn(set, &e, &ext, &ext, flags);
- 
  			if (ret && !ip_set_eexist(ret, flags))
  				return ret;
 -
 -			ret = 0;
 +			else
 +				ret = 0;
  		}
- 		ip = last + 1;
- 	}
+ 		p = port;
+ 	} while (ip++ < ip_to);
  	return ret;
  }
  
* Unmerged path net/netfilter/ipset/ip_set_hash_netnet.c
* Unmerged path net/netfilter/ipset/ip_set_hash_netportnet.c
* Unmerged path net/netfilter/ipset/ip_set_hash_ipportnet.c
* Unmerged path net/netfilter/ipset/ip_set_hash_net.c
* Unmerged path net/netfilter/ipset/ip_set_hash_netiface.c
* Unmerged path net/netfilter/ipset/ip_set_hash_netnet.c
* Unmerged path net/netfilter/ipset/ip_set_hash_netport.c
* Unmerged path net/netfilter/ipset/ip_set_hash_netportnet.c
