e1000e: Cleanup to fix checkpatch missing blank lines

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author David Ertman <davidx.m.ertman@intel.com>
commit 6cf08d1c50872acb6c8400567b1df2d02a03e58d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6cf08d1c.failed

Fixing "WARNING:SPACING: networking uses a blank line after declarations"

	Signed-off-by: Dave Ertman <davidx.m.ertman@intel.com>
	Tested-by: Aaron Brown <aaron.f.brown@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 6cf08d1c50872acb6c8400567b1df2d02a03e58d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/e1000e/ich8lan.c
#	drivers/net/ethernet/intel/e1000e/netdev.c
diff --cc drivers/net/ethernet/intel/e1000e/ich8lan.c
index 9f0175ab39e5,a2901139b209..000000000000
--- a/drivers/net/ethernet/intel/e1000e/ich8lan.c
+++ b/drivers/net/ethernet/intel/e1000e/ich8lan.c
@@@ -1405,98 -1318,28 +1405,110 @@@ static s32 e1000_check_for_copper_link_
  	 * aggressive resulting in many collisions. To avoid this, increase
  	 * the IPG and reduce Rx latency in the PHY.
  	 */
++<<<<<<< HEAD
 +	if ((hw->mac.type >= e1000_pch2lan) && link) {
 +		u16 speed, duplex;
++=======
+ 	if ((hw->mac.type == e1000_pch2lan) && link) {
+ 		u32 reg;
+ 
+ 		reg = er32(STATUS);
+ 		if (!(reg & (E1000_STATUS_FD | E1000_STATUS_SPEED_MASK))) {
+ 			reg = er32(TIPG);
+ 			reg &= ~E1000_TIPG_IPGT_MASK;
+ 			reg |= 0xFF;
+ 			ew32(TIPG, reg);
++>>>>>>> 6cf08d1c5087 (e1000e: Cleanup to fix checkpatch missing blank lines)
 +
 +		e1000e_get_speed_and_duplex_copper(hw, &speed, &duplex);
 +		tipg_reg = er32(TIPG);
 +		tipg_reg &= ~E1000_TIPG_IPGT_MASK;
  
 +		if (duplex == HALF_DUPLEX && speed == SPEED_10) {
 +			tipg_reg |= 0xFF;
  			/* Reduce Rx latency in analog PHY */
 -			ret_val = hw->phy.ops.acquire(hw);
 -			if (ret_val)
 -				return ret_val;
 +			emi_val = 0;
 +		} else if (hw->mac.type >= e1000_pch_spt &&
 +			   duplex == FULL_DUPLEX && speed != SPEED_1000) {
 +			tipg_reg |= 0xC;
 +			emi_val = 1;
 +		} else {
  
 -			ret_val =
 -			    e1000_write_emi_reg_locked(hw, I82579_RX_CONFIG, 0);
 +			/* Roll back the default values */
 +			tipg_reg |= 0x08;
 +			emi_val = 1;
 +		}
  
 -			hw->phy.ops.release(hw);
 +		ew32(TIPG, tipg_reg);
  
 -			if (ret_val)
 -				return ret_val;
 +		ret_val = hw->phy.ops.acquire(hw);
 +		if (ret_val)
 +			return ret_val;
 +
 +		if (hw->mac.type == e1000_pch2lan)
 +			emi_addr = I82579_RX_CONFIG;
 +		else
 +			emi_addr = I217_RX_CONFIG;
 +		ret_val = e1000_write_emi_reg_locked(hw, emi_addr, emi_val);
 +
 +		if (hw->mac.type >= e1000_pch_lpt) {
 +			u16 phy_reg;
 +
 +			e1e_rphy_locked(hw, I217_PLL_CLOCK_GATE_REG, &phy_reg);
 +			phy_reg &= ~I217_PLL_CLOCK_GATE_MASK;
 +			if (speed == SPEED_100 || speed == SPEED_10)
 +				phy_reg |= 0x3E8;
 +			else
 +				phy_reg |= 0xFA;
 +			e1e_wphy_locked(hw, I217_PLL_CLOCK_GATE_REG, phy_reg);
 +		}
 +		hw->phy.ops.release(hw);
 +
 +		if (ret_val)
 +			return ret_val;
 +
 +		if (hw->mac.type >= e1000_pch_spt) {
 +			u16 data;
 +			u16 ptr_gap;
 +
 +			if (speed == SPEED_1000) {
 +				ret_val = hw->phy.ops.acquire(hw);
 +				if (ret_val)
 +					return ret_val;
 +
 +				ret_val = e1e_rphy_locked(hw,
 +							  PHY_REG(776, 20),
 +							  &data);
 +				if (ret_val) {
 +					hw->phy.ops.release(hw);
 +					return ret_val;
 +				}
 +
 +				ptr_gap = (data & (0x3FF << 2)) >> 2;
 +				if (ptr_gap < 0x18) {
 +					data &= ~(0x3FF << 2);
 +					data |= (0x18 << 2);
 +					ret_val =
 +					    e1e_wphy_locked(hw,
 +							    PHY_REG(776, 20),
 +							    data);
 +				}
 +				hw->phy.ops.release(hw);
 +				if (ret_val)
 +					return ret_val;
 +			} else {
 +				ret_val = hw->phy.ops.acquire(hw);
 +				if (ret_val)
 +					return ret_val;
 +
 +				ret_val = e1e_wphy_locked(hw,
 +							  PHY_REG(776, 20),
 +							  0xC023);
 +				hw->phy.ops.release(hw);
 +				if (ret_val)
 +					return ret_val;
 +
 +			}
  		}
  	}
  
diff --cc drivers/net/ethernet/intel/e1000e/netdev.c
index f468f0dce132,90077e8955a7..000000000000
--- a/drivers/net/ethernet/intel/e1000e/netdev.c
+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
@@@ -1243,7 -1200,8 +1245,12 @@@ static bool e1000_clean_tx_irq(struct e
  	while ((eop_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) &&
  	       (count < tx_ring->count)) {
  		bool cleaned = false;
++<<<<<<< HEAD
 +		dma_rmb();		/* read buffer_info after eop_desc */
++=======
+ 
+ 		rmb();		/* read buffer_info after eop_desc */
++>>>>>>> 6cf08d1c5087 (e1000e: Cleanup to fix checkpatch missing blank lines)
  		for (; !cleaned; count++) {
  			tx_desc = E1000_TX_DESC(*tx_ring, i);
  			buffer_info = &tx_ring->buffer_info[i];
@@@ -4995,8 -4701,9 +5007,9 @@@ static void e1000e_update_stats(struct 
  	adapter->stats.mgpdc += er32(MGTPDC);
  
  	/* Correctable ECC Errors */
 -	if (hw->mac.type == e1000_pch_lpt) {
 +	if (hw->mac.type >= e1000_pch_lpt) {
  		u32 pbeccsts = er32(PBECCSTS);
+ 
  		adapter->corr_errors +=
  		    pbeccsts & E1000_PBECCSTS_CORR_ERR_CNT_MASK;
  		adapter->uncorr_errors +=
@@@ -7578,11 -7155,14 +7594,16 @@@ static struct pci_driver e1000_driver 
   **/
  static int __init e1000_init_module(void)
  {
++<<<<<<< HEAD
++=======
+ 	int ret;
+ 
++>>>>>>> 6cf08d1c5087 (e1000e: Cleanup to fix checkpatch missing blank lines)
  	pr_info("Intel(R) PRO/1000 Network Driver - %s\n",
  		e1000e_driver_version);
 -	pr_info("Copyright(c) 1999 - 2014 Intel Corporation.\n");
 -	ret = pci_register_driver(&e1000_driver);
 +	pr_info("Copyright(c) 1999 - 2015 Intel Corporation.\n");
  
 -	return ret;
 +	return pci_register_driver(&e1000_driver);
  }
  module_init(e1000_init_module);
  
diff --git a/drivers/net/ethernet/intel/e1000e/ethtool.c b/drivers/net/ethernet/intel/e1000e/ethtool.c
index 82432c6d944b..064cff70f12a 100644
--- a/drivers/net/ethernet/intel/e1000e/ethtool.c
+++ b/drivers/net/ethernet/intel/e1000e/ethtool.c
@@ -170,6 +170,7 @@ static int e1000_get_settings(struct net_device *netdev,
 		}
 	} else if (!pm_runtime_suspended(netdev->dev.parent)) {
 		u32 status = er32(STATUS);
+
 		if (status & E1000_STATUS_LU) {
 			if (status & E1000_STATUS_SPEED_1000)
 				speed = SPEED_1000;
@@ -801,6 +802,7 @@ static bool reg_set_and_check(struct e1000_adapter *adapter, u64 *data,
 			      int reg, u32 mask, u32 write)
 {
 	u32 val;
+
 	__ew32(&adapter->hw, reg, write & mask);
 	val = __er32(&adapter->hw, reg);
 	if ((write & mask) != (val & mask)) {
@@ -1748,6 +1750,7 @@ static int e1000_link_test(struct e1000_adapter *adapter, u64 *data)
 	*data = 0;
 	if (hw->phy.media_type == e1000_media_type_internal_serdes) {
 		int i = 0;
+
 		hw->mac.serdes_has_link = false;
 
 		/* On some blade server designs, link establishment
* Unmerged path drivers/net/ethernet/intel/e1000e/ich8lan.c
* Unmerged path drivers/net/ethernet/intel/e1000e/netdev.c
diff --git a/drivers/net/ethernet/intel/e1000e/nvm.c b/drivers/net/ethernet/intel/e1000e/nvm.c
index 85f3ec4e793c..2efd80dfd88e 100644
--- a/drivers/net/ethernet/intel/e1000e/nvm.c
+++ b/drivers/net/ethernet/intel/e1000e/nvm.c
@@ -400,6 +400,7 @@ s32 e1000e_write_nvm_spi(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)
 		/* Loop to allow for up to whole page write of eeprom */
 		while (widx < words) {
 			u16 word_out = data[widx];
+
 			word_out = (word_out >> 8) | (word_out << 8);
 			e1000_shift_out_eec_bits(hw, word_out, 16);
 			widx++;
diff --git a/drivers/net/ethernet/intel/e1000e/param.c b/drivers/net/ethernet/intel/e1000e/param.c
index dc3bfa6ba8d9..47da51864543 100644
--- a/drivers/net/ethernet/intel/e1000e/param.c
+++ b/drivers/net/ethernet/intel/e1000e/param.c
@@ -450,6 +450,7 @@ void e1000e_check_options(struct e1000_adapter *adapter)
 
 		if (num_IntMode > bd) {
 			unsigned int int_mode = IntMode[bd];
+
 			e1000_validate_option(&int_mode, &opt, adapter);
 			adapter->int_mode = int_mode;
 		} else {
@@ -471,6 +472,7 @@ void e1000e_check_options(struct e1000_adapter *adapter)
 
 		if (num_SmartPowerDownEnable > bd) {
 			unsigned int spd = SmartPowerDownEnable[bd];
+
 			e1000_validate_option(&spd, &opt, adapter);
 			if ((adapter->flags & FLAG_HAS_SMART_POWER_DOWN) && spd)
 				adapter->flags |= FLAG_SMART_POWER_DOWN;
@@ -487,6 +489,7 @@ void e1000e_check_options(struct e1000_adapter *adapter)
 
 		if (num_CrcStripping > bd) {
 			unsigned int crc_stripping = CrcStripping[bd];
+
 			e1000_validate_option(&crc_stripping, &opt, adapter);
 			if (crc_stripping == OPTION_ENABLED) {
 				adapter->flags2 |= FLAG2_CRC_STRIPPING;
@@ -509,6 +512,7 @@ void e1000e_check_options(struct e1000_adapter *adapter)
 
 		if (num_KumeranLockLoss > bd) {
 			unsigned int kmrn_lock_loss = KumeranLockLoss[bd];
+
 			e1000_validate_option(&kmrn_lock_loss, &opt, adapter);
 			enabled = kmrn_lock_loss;
 		}
diff --git a/drivers/net/ethernet/intel/e1000e/phy.c b/drivers/net/ethernet/intel/e1000e/phy.c
index 16f06a2d6d48..86ff0969efb6 100644
--- a/drivers/net/ethernet/intel/e1000e/phy.c
+++ b/drivers/net/ethernet/intel/e1000e/phy.c
@@ -2897,6 +2897,7 @@ static s32 __e1000_write_phy_reg_hv(struct e1000_hw *hw, u32 offset, u16 data,
 		    (hw->phy.addr == 2) &&
 		    !(MAX_PHY_REG_ADDRESS & reg) && (data & BIT(11))) {
 			u16 data2 = 0x7EFF;
+
 			ret_val = e1000_access_phy_debug_regs_hv(hw,
 								 BIT(6) | 0x3,
 								 &data2, false);
