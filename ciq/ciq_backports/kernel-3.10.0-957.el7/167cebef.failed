nfp: modify app MTU setting callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author John Hurley <john.hurley@netronome.com>
commit 167cebeffadd45ce1e786889ab9346c15d64389b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/167cebef.failed

Rename the 'change_mtu' app callback to 'check_mtu'. This is called
whenever an MTU change is requested on a netdev. It can reject the
change but is not responsible for implementing it.

Introduce a new 'repr_change_mtu' app callback that is hit when the MTU
of a repr is to be changed. This is responsible for performing the MTU
change and verifying it.

	Signed-off-by: John Hurley <john.hurley@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 167cebeffadd45ce1e786889ab9346c15d64389b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/bpf/main.c
#	drivers/net/ethernet/netronome/nfp/nfp_app.h
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_repr.c
diff --cc drivers/net/ethernet/netronome/nfp/bpf/main.c
index 60a7af297852,752c45763ed9..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/main.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/main.c
@@@ -117,22 -212,159 +117,36 @@@ static void nfp_bpf_vnic_free(struct nf
  static int nfp_bpf_setup_tc(struct nfp_app *app, struct net_device *netdev,
  			    enum tc_setup_type type, void *type_data)
  {
++<<<<<<< HEAD
 +#if 0 /* Not in RHEL7 */
++=======
+ 	switch (type) {
+ 	case TC_SETUP_BLOCK:
+ 		return nfp_bpf_setup_tc_block(netdev, type_data);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int
+ nfp_bpf_check_mtu(struct nfp_app *app, struct net_device *netdev, int new_mtu)
+ {
++>>>>>>> 167cebeffadd (nfp: modify app MTU setting callbacks)
  	struct nfp_net *nn = netdev_priv(netdev);
 -	unsigned int max_mtu;
  
 -	if (~nn->dp.ctrl & NFP_NET_CFG_CTRL_BPF)
 -		return 0;
 -
 -	max_mtu = nn_readb(nn, NFP_NET_CFG_BPF_INL_MTU) * 64 - 32;
 -	if (new_mtu > max_mtu) {
 -		nn_info(nn, "BPF offload active, MTU over %u not supported\n",
 -			max_mtu);
 -		return -EBUSY;
 -	}
 -	return 0;
 -}
 -
 -static int
 -nfp_bpf_parse_cap_adjust_head(struct nfp_app_bpf *bpf, void __iomem *value,
 -			      u32 length)
 -{
 -	struct nfp_bpf_cap_tlv_adjust_head __iomem *cap = value;
 -	struct nfp_cpp *cpp = bpf->app->pf->cpp;
 -
 -	if (length < sizeof(*cap)) {
 -		nfp_err(cpp, "truncated adjust_head TLV: %d\n", length);
 -		return -EINVAL;
 -	}
 -
 -	bpf->adjust_head.flags = readl(&cap->flags);
 -	bpf->adjust_head.off_min = readl(&cap->off_min);
 -	bpf->adjust_head.off_max = readl(&cap->off_max);
 -	bpf->adjust_head.guaranteed_sub = readl(&cap->guaranteed_sub);
 -	bpf->adjust_head.guaranteed_add = readl(&cap->guaranteed_add);
 -
 -	if (bpf->adjust_head.off_min > bpf->adjust_head.off_max) {
 -		nfp_err(cpp, "invalid adjust_head TLV: min > max\n");
 -		return -EINVAL;
 -	}
 -	if (!FIELD_FIT(UR_REG_IMM_MAX, bpf->adjust_head.off_min) ||
 -	    !FIELD_FIT(UR_REG_IMM_MAX, bpf->adjust_head.off_max)) {
 -		nfp_warn(cpp, "disabling adjust_head - driver expects min/max to fit in as immediates\n");
 -		memset(&bpf->adjust_head, 0, sizeof(bpf->adjust_head));
 -		return 0;
 -	}
 -
 -	return 0;
 -}
 -
 -static int
 -nfp_bpf_parse_cap_func(struct nfp_app_bpf *bpf, void __iomem *value, u32 length)
 -{
 -	struct nfp_bpf_cap_tlv_func __iomem *cap = value;
 -
 -	if (length < sizeof(*cap)) {
 -		nfp_err(bpf->app->cpp, "truncated function TLV: %d\n", length);
 -		return -EINVAL;
 -	}
 -
 -	switch (readl(&cap->func_id)) {
 -	case BPF_FUNC_map_lookup_elem:
 -		bpf->helpers.map_lookup = readl(&cap->func_addr);
 -		break;
 -	}
 -
 -	return 0;
 -}
 -
 -static int
 -nfp_bpf_parse_cap_maps(struct nfp_app_bpf *bpf, void __iomem *value, u32 length)
 -{
 -	struct nfp_bpf_cap_tlv_maps __iomem *cap = value;
 -
 -	if (length < sizeof(*cap)) {
 -		nfp_err(bpf->app->cpp, "truncated maps TLV: %d\n", length);
 -		return -EINVAL;
 -	}
 -
 -	bpf->maps.types = readl(&cap->types);
 -	bpf->maps.max_maps = readl(&cap->max_maps);
 -	bpf->maps.max_elems = readl(&cap->max_elems);
 -	bpf->maps.max_key_sz = readl(&cap->max_key_sz);
 -	bpf->maps.max_val_sz = readl(&cap->max_val_sz);
 -	bpf->maps.max_elem_sz = readl(&cap->max_elem_sz);
 -
 -	return 0;
 -}
 -
 -static int nfp_bpf_parse_capabilities(struct nfp_app *app)
 -{
 -	struct nfp_cpp *cpp = app->pf->cpp;
 -	struct nfp_cpp_area *area;
 -	u8 __iomem *mem, *start;
 -
 -	mem = nfp_rtsym_map(app->pf->rtbl, "_abi_bpf_capabilities", "bpf.cap",
 -			    8, &area);
 -	if (IS_ERR(mem))
 -		return PTR_ERR(mem) == -ENOENT ? 0 : PTR_ERR(mem);
 -
 -	start = mem;
 -	while (mem - start + 8 < nfp_cpp_area_size(area)) {
 -		u8 __iomem *value;
 -		u32 type, length;
 -
 -		type = readl(mem);
 -		length = readl(mem + 4);
 -		value = mem + 8;
 -
 -		mem += 8 + length;
 -		if (mem - start > nfp_cpp_area_size(area))
 -			goto err_release_free;
 +	if (TC_H_MAJ(handle) != TC_H_MAJ(TC_H_INGRESS))
 +		return -EOPNOTSUPP;
 +	if (proto != htons(ETH_P_ALL))
 +		return -EOPNOTSUPP;
  
 -		switch (type) {
 -		case NFP_BPF_CAP_TYPE_FUNC:
 -			if (nfp_bpf_parse_cap_func(app->priv, value, length))
 -				goto err_release_free;
 -			break;
 -		case NFP_BPF_CAP_TYPE_ADJUST_HEAD:
 -			if (nfp_bpf_parse_cap_adjust_head(app->priv, value,
 -							  length))
 -				goto err_release_free;
 -			break;
 -		case NFP_BPF_CAP_TYPE_MAPS:
 -			if (nfp_bpf_parse_cap_maps(app->priv, value, length))
 -				goto err_release_free;
 -			break;
 -		default:
 -			nfp_dbg(cpp, "unknown BPF capability: %d\n", type);
 -			break;
 -		}
 -	}
 -	if (mem - start != nfp_cpp_area_size(area)) {
 -		nfp_err(cpp, "BPF capabilities left after parsing, parsed:%zd total length:%zu\n",
 -			mem - start, nfp_cpp_area_size(area));
 -		goto err_release_free;
 +	if (tc->type == TC_SETUP_CLSBPF && nfp_net_ebpf_capable(nn)) {
 +		if (!nn->dp.bpf_offload_xdp)
 +			return nfp_net_bpf_offload(nn, tc->cls_bpf);
 +		else
 +			return -EBUSY;
  	}
 +#endif
  
 -	nfp_cpp_area_release_free(area);
 -
 -	return 0;
 -
 -err_release_free:
 -	nfp_err(cpp, "invalid BPF capabilities at offset:%zd\n", mem - start);
 -	nfp_cpp_area_release_free(area);
  	return -EINVAL;
  }
  
@@@ -147,6 -408,13 +161,16 @@@ const struct nfp_app_type app_bpf = 
  	.id		= NFP_APP_BPF_NIC,
  	.name		= "ebpf",
  
++<<<<<<< HEAD
++=======
+ 	.ctrl_cap_mask	= 0,
+ 
+ 	.init		= nfp_bpf_init,
+ 	.clean		= nfp_bpf_clean,
+ 
+ 	.check_mtu	= nfp_bpf_check_mtu,
+ 
++>>>>>>> 167cebeffadd (nfp: modify app MTU setting callbacks)
  	.extra_cap	= nfp_bpf_extra_cap,
  
  	.vnic_alloc	= nfp_bpf_vnic_alloc,
diff --cc drivers/net/ethernet/netronome/nfp/nfp_app.h
index 96318a0e48d5,2d9cb2528fc7..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_app.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_app.h
@@@ -76,8 -80,14 +76,13 @@@ extern const struct nfp_app_type app_fl
   * @vnic_free:	free up app's vNIC state
   * @vnic_init:	vNIC netdev was registered
   * @vnic_clean:	vNIC netdev about to be unregistered
 - * @repr_init:	representor about to be registered
 - * @repr_preclean:	representor about to unregistered, executed before app
 - *			reference to the it is removed
 - * @repr_clean:	representor about to be unregistered
   * @repr_open:	representor netdev open callback
   * @repr_stop:	representor netdev stop callback
++<<<<<<< HEAD
++=======
+  * @check_mtu:	MTU change request on a netdev (verify it is valid)
+  * @repr_change_mtu:	MTU change request on repr (make and verify change)
++>>>>>>> 167cebeffadd (nfp: modify app MTU setting callbacks)
   * @start:	start application logic
   * @stop:	stop application logic
   * @ctrl_msg_rx:    control message handler
@@@ -109,6 -120,15 +114,14 @@@ struct nfp_app_type 
  	int (*repr_open)(struct nfp_app *app, struct nfp_repr *repr);
  	int (*repr_stop)(struct nfp_app *app, struct nfp_repr *repr);
  
++<<<<<<< HEAD
++=======
+ 	int (*check_mtu)(struct nfp_app *app, struct net_device *netdev,
+ 			 int new_mtu);
+ 	int (*repr_change_mtu)(struct nfp_app *app, struct net_device *netdev,
+ 			       int new_mtu);
+ 
++>>>>>>> 167cebeffadd (nfp: modify app MTU setting callbacks)
  	int (*start)(struct nfp_app *app);
  	void (*stop)(struct nfp_app *app);
  
@@@ -203,6 -226,45 +216,48 @@@ static inline int nfp_app_repr_stop(str
  	return app->type->repr_stop(app, repr);
  }
  
++<<<<<<< HEAD
++=======
+ static inline int
+ nfp_app_repr_init(struct nfp_app *app, struct net_device *netdev)
+ {
+ 	if (!app->type->repr_init)
+ 		return 0;
+ 	return app->type->repr_init(app, netdev);
+ }
+ 
+ static inline void
+ nfp_app_repr_preclean(struct nfp_app *app, struct net_device *netdev)
+ {
+ 	if (app->type->repr_preclean)
+ 		app->type->repr_preclean(app, netdev);
+ }
+ 
+ static inline void
+ nfp_app_repr_clean(struct nfp_app *app, struct net_device *netdev)
+ {
+ 	if (app->type->repr_clean)
+ 		app->type->repr_clean(app, netdev);
+ }
+ 
+ static inline int
+ nfp_app_check_mtu(struct nfp_app *app, struct net_device *netdev, int new_mtu)
+ {
+ 	if (!app || !app->type->check_mtu)
+ 		return 0;
+ 	return app->type->check_mtu(app, netdev, new_mtu);
+ }
+ 
+ static inline int
+ nfp_app_repr_change_mtu(struct nfp_app *app, struct net_device *netdev,
+ 			int new_mtu)
+ {
+ 	if (!app || !app->type->repr_change_mtu)
+ 		return 0;
+ 	return app->type->repr_change_mtu(app, netdev, new_mtu);
+ }
+ 
++>>>>>>> 167cebeffadd (nfp: modify app MTU setting callbacks)
  static inline int nfp_app_start(struct nfp_app *app, struct nfp_net *ctrl)
  {
  	app->ctrl = ctrl;
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 85c724545e26,43a9c207a049..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -3066,6 -3064,11 +3066,14 @@@ static int nfp_net_change_mtu(struct ne
  {
  	struct nfp_net *nn = netdev_priv(netdev);
  	struct nfp_net_dp *dp;
++<<<<<<< HEAD
++=======
+ 	int err;
+ 
+ 	err = nfp_app_check_mtu(nn->app, netdev, new_mtu);
+ 	if (err)
+ 		return err;
++>>>>>>> 167cebeffadd (nfp: modify app MTU setting callbacks)
  
  	dp = nfp_net_clone_dp(nn);
  	if (!dp)
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_repr.c
index 82a6593712ce,0cd077addb26..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_repr.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_repr.c
@@@ -185,6 -193,24 +185,27 @@@ nfp_repr_get_offload_stats(int attr_id
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ static int nfp_repr_change_mtu(struct net_device *netdev, int new_mtu)
+ {
+ 	struct nfp_repr *repr = netdev_priv(netdev);
+ 	int err;
+ 
+ 	err = nfp_app_check_mtu(repr->app, netdev, new_mtu);
+ 	if (err)
+ 		return err;
+ 
+ 	err = nfp_app_repr_change_mtu(repr->app, netdev, new_mtu);
+ 	if (err)
+ 		return err;
+ 
+ 	netdev->mtu = new_mtu;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 167cebeffadd (nfp: modify app MTU setting callbacks)
  static netdev_tx_t nfp_repr_xmit(struct sk_buff *skb, struct net_device *netdev)
  {
  	struct nfp_repr *repr = netdev_priv(netdev);
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_app.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_repr.c
