dax: Report bytes remaining in dax_iomap_actor()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit a77d478642f12ade58fdfac335ae464df1944a1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/a77d4786.failed

In preparation for protecting the dax read(2) path from media errors
with copy_to_iter_mcsafe() (via dax_copy_to_iter()), convert the
implementation to report the bytes successfully transferred.

	Cc: <x86@kernel.org>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit a77d478642f12ade58fdfac335ae464df1944a1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
diff --cc fs/dax.c
index 879d2cfa39b7,34a2d435ae4b..000000000000
--- a/fs/dax.c
+++ b/fs/dax.c
@@@ -1030,9 -991,10 +1030,10 @@@ dax_iomap_actor(int rw, struct inode *i
  	struct iov_iter *iter = data;
  	loff_t end = pos + length, done = 0;
  	ssize_t ret = 0;
+ 	size_t xfer;
  	int id;
  
 -	if (iov_iter_rw(iter) == READ) {
 +	if (!(rw & WRITE)) {
  		end = min(end, i_size_read(inode));
  		if (pos >= end)
  			return 0;
@@@ -1093,23 -1049,26 +1094,46 @@@
  		if (map_len > end - pos)
  			map_len = end - pos;
  
++<<<<<<< HEAD
 +		if (rw & WRITE)
 +			map_len = memcpy_fromiovecend_partial_flushcache(
 +					kaddr, iter->iov,
 +					iter->iov_offset, map_len);
 +		else
 +			map_len = memcpy_toiovecend_partial(iter->iov,
 +					kaddr, iter->iov_offset, map_len);
 +
 +		if (map_len <= 0) {
 +			ret = map_len ? map_len : -EFAULT;
 +			break;
 +		}
 +
 +		iov_iter_advance(iter, map_len);
 +		pos += map_len;
 +		length -= map_len;
 +		done += map_len;
++=======
+ 		/*
+ 		 * The userspace address for the memory copy has already been
+ 		 * validated via access_ok() in either vfs_read() or
+ 		 * vfs_write(), depending on which operation we are doing.
+ 		 */
+ 		if (iov_iter_rw(iter) == WRITE)
+ 			xfer = dax_copy_from_iter(dax_dev, pgoff, kaddr,
+ 					map_len, iter);
+ 		else
+ 			xfer = dax_copy_to_iter(dax_dev, pgoff, kaddr,
+ 					map_len, iter);
+ 
+ 		pos += xfer;
+ 		length -= xfer;
+ 		done += xfer;
+ 
+ 		if (xfer == 0)
+ 			ret = -EFAULT;
+ 		if (xfer < map_len)
+ 			break;
++>>>>>>> a77d478642f1 (dax: Report bytes remaining in dax_iomap_actor())
  	}
  	dax_read_unlock(id);
  
* Unmerged path fs/dax.c
