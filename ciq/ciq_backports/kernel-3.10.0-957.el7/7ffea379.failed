netfilter: ipset: Headers file cleanup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 7ffea37957b900422ce8b82e9651f7a0a6fac733
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7ffea379.failed

Group counter helper functions together.

Ported from a patch proposed by Sergey Popovich <popovich_sergei@mail.ua>.

	Suggested-by: Sergey Popovich <popovich_sergei@mail.ua>
	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 7ffea37957b900422ce8b82e9651f7a0a6fac733)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/ipset/ip_set.h
diff --cc include/linux/netfilter/ipset/ip_set.h
index 3e9c90cf5227,1ea28e30a6dd..000000000000
--- a/include/linux/netfilter/ipset/ip_set.h
+++ b/include/linux/netfilter/ipset/ip_set.h
@@@ -235,27 -334,75 +235,99 @@@ ip_set_update_counter(struct ip_set_cou
  	}
  }
  
++<<<<<<< HEAD
 +static inline bool
 +ip_set_put_counter(struct sk_buff *skb, struct ip_set_counter *counter)
 +{
 +	return nla_put_net64(skb, IPSET_ATTR_BYTES,
 +			     cpu_to_be64(ip_set_get_bytes(counter)),
 +			     IPSET_ATTR_PAD) ||
 +	       nla_put_net64(skb, IPSET_ATTR_PACKETS,
 +			     cpu_to_be64(ip_set_get_packets(counter)),
 +			     IPSET_ATTR_PAD);
 +}
 +
 +static inline void
 +ip_set_init_counter(struct ip_set_counter *counter,
 +		    const struct ip_set_ext *ext)
 +{
 +	if (ext->bytes != ULLONG_MAX)
 +		atomic64_set(&(counter)->bytes, (long long)(ext->bytes));
 +	if (ext->packets != ULLONG_MAX)
 +		atomic64_set(&(counter)->packets, (long long)(ext->packets));
 +}
 +
++=======
+ static inline bool
+ ip_set_put_counter(struct sk_buff *skb, const struct ip_set_counter *counter)
+ {
+ 	return nla_put_net64(skb, IPSET_ATTR_BYTES,
+ 			     cpu_to_be64(ip_set_get_bytes(counter)),
+ 			     IPSET_ATTR_PAD) ||
+ 	       nla_put_net64(skb, IPSET_ATTR_PACKETS,
+ 			     cpu_to_be64(ip_set_get_packets(counter)),
+ 			     IPSET_ATTR_PAD);
+ }
+ 
+ static inline void
+ ip_set_init_counter(struct ip_set_counter *counter,
+ 		    const struct ip_set_ext *ext)
+ {
+ 	if (ext->bytes != ULLONG_MAX)
+ 		atomic64_set(&(counter)->bytes, (long long)(ext->bytes));
+ 	if (ext->packets != ULLONG_MAX)
+ 		atomic64_set(&(counter)->packets, (long long)(ext->packets));
+ }
+ 
+ static inline void
+ ip_set_get_skbinfo(struct ip_set_skbinfo *skbinfo,
+ 		   const struct ip_set_ext *ext,
+ 		   struct ip_set_ext *mext, u32 flags)
+ {
+ 	mext->skbmark = skbinfo->skbmark;
+ 	mext->skbmarkmask = skbinfo->skbmarkmask;
+ 	mext->skbprio = skbinfo->skbprio;
+ 	mext->skbqueue = skbinfo->skbqueue;
+ }
+ 
+ static inline bool
+ ip_set_put_skbinfo(struct sk_buff *skb, const struct ip_set_skbinfo *skbinfo)
+ {
+ 	/* Send nonzero parameters only */
+ 	return ((skbinfo->skbmark || skbinfo->skbmarkmask) &&
+ 		nla_put_net64(skb, IPSET_ATTR_SKBMARK,
+ 			      cpu_to_be64((u64)skbinfo->skbmark << 32 |
+ 					  skbinfo->skbmarkmask),
+ 			      IPSET_ATTR_PAD)) ||
+ 	       (skbinfo->skbprio &&
+ 		nla_put_net32(skb, IPSET_ATTR_SKBPRIO,
+ 			      cpu_to_be32(skbinfo->skbprio))) ||
+ 	       (skbinfo->skbqueue &&
+ 		nla_put_net16(skb, IPSET_ATTR_SKBQUEUE,
+ 			     cpu_to_be16(skbinfo->skbqueue)));
+ }
+ 
+ static inline void
+ ip_set_init_skbinfo(struct ip_set_skbinfo *skbinfo,
+ 		    const struct ip_set_ext *ext)
+ {
+ 	skbinfo->skbmark = ext->skbmark;
+ 	skbinfo->skbmarkmask = ext->skbmarkmask;
+ 	skbinfo->skbprio = ext->skbprio;
+ 	skbinfo->skbqueue = ext->skbqueue;
+ }
+ 
+ /* Netlink CB args */
+ enum {
+ 	IPSET_CB_NET = 0,	/* net namespace */
+ 	IPSET_CB_DUMP,		/* dump single set/all sets */
+ 	IPSET_CB_INDEX,		/* set index */
+ 	IPSET_CB_PRIVATE,	/* set private data */
+ 	IPSET_CB_ARG0,		/* type specific */
+ 	IPSET_CB_ARG1,
+ };
+ 
++>>>>>>> 7ffea37957b9 (netfilter: ipset: Headers file cleanup)
  /* register and unregister set references */
  extern ip_set_id_t ip_set_get_byname(struct net *net,
  				     const char *name, struct ip_set **set);
* Unmerged path include/linux/netfilter/ipset/ip_set.h
