Input: synaptics - disable kernel tracking on SMBus devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [input] synaptics - disable kernel tracking on SMBus devices (Benjamin Tissoires) [1554926]
Rebuild_FUZZ: 93.69%
commit-author Andrew Duggan <aduggan@synaptics.com>
commit 2b30297d481ad305134252557768c22391e0fed6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/2b30297d.failed

In certain situations kernel tracking seems to be getting confused
and incorrectly reporting the slot of a contact. On example is when
the user does a three finger click or tap and then places two fingers
on the touchpad in the same area. The kernel tracking code seems to
continue to think that there are three contacts on the touchpad and
incorrectly alternates the slot of one of the contacts. The result that
is the input subsystem reports a stream of button press and release
events as the reported slot changes.

Kernel tracking was originally enabled to prevent cursor jumps, but it
is unclear how much of an issue kernel jumps actually are. This patch
simply disabled kernel tracking for now.

Fixes: https://bugzilla.redhat.com/show_bug.cgi?id=1482640

	Signed-off-by: Andrew Duggan <aduggan@synaptics.com>
	Tested-by: Kamil PÃ¡ral <kparal@redhat.com>
	Acked-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
(cherry picked from commit 2b30297d481ad305134252557768c22391e0fed6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/input/mouse/synaptics.c
diff --cc drivers/input/mouse/synaptics.c
index 5f5887ef5b0a,ee5466a374bf..000000000000
--- a/drivers/input/mouse/synaptics.c
+++ b/drivers/input/mouse/synaptics.c
@@@ -1819,9 -1678,183 +1819,191 @@@ int synaptics_init(struct psmouse *psmo
  	return -ENOSYS;
  }
  
 +bool synaptics_supported(void)
 +{
 +	return false;
 +}
 +
  #endif /* CONFIG_MOUSE_PS2_SYNAPTICS */
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS
+ 
+ /*
+  * The newest Synaptics device can use a secondary bus (called InterTouch) which
+  * provides a better bandwidth and allow a better control of the touchpads.
+  * This is used to decide if we need to use this bus or not.
+  */
+ enum {
+ 	SYNAPTICS_INTERTOUCH_NOT_SET = -1,
+ 	SYNAPTICS_INTERTOUCH_OFF,
+ 	SYNAPTICS_INTERTOUCH_ON,
+ };
+ 
+ static int synaptics_intertouch = IS_ENABLED(CONFIG_RMI4_SMB) ?
+ 		SYNAPTICS_INTERTOUCH_NOT_SET : SYNAPTICS_INTERTOUCH_OFF;
+ module_param_named(synaptics_intertouch, synaptics_intertouch, int, 0644);
+ MODULE_PARM_DESC(synaptics_intertouch, "Use a secondary bus for the Synaptics device.");
+ 
+ static int synaptics_create_intertouch(struct psmouse *psmouse,
+ 				       struct synaptics_device_info *info,
+ 				       bool leave_breadcrumbs)
+ {
+ 	bool topbuttonpad =
+ 		psmouse_matches_pnp_id(psmouse, topbuttonpad_pnp_ids) &&
+ 		!SYN_CAP_EXT_BUTTONS_STICK(info->ext_cap_10);
+ 	const struct rmi_device_platform_data pdata = {
+ 		.sensor_pdata = {
+ 			.sensor_type = rmi_sensor_touchpad,
+ 			.axis_align.flip_y = true,
+ 			.kernel_tracking = false,
+ 			.topbuttonpad = topbuttonpad,
+ 		},
+ 		.f30_data = {
+ 			.buttonpad = SYN_CAP_CLICKPAD(info->ext_cap_0c),
+ 			.trackstick_buttons =
+ 				!!SYN_CAP_EXT_BUTTONS_STICK(info->ext_cap_10),
+ 		},
+ 	};
+ 	const struct i2c_board_info intertouch_board = {
+ 		I2C_BOARD_INFO("rmi4_smbus", 0x2c),
+ 		.flags = I2C_CLIENT_HOST_NOTIFY,
+ 	};
+ 
+ 	return psmouse_smbus_init(psmouse, &intertouch_board,
+ 				  &pdata, sizeof(pdata),
+ 				  leave_breadcrumbs);
+ }
+ 
+ /**
+  * synaptics_setup_intertouch - called once the PS/2 devices are enumerated
+  * and decides to instantiate a SMBus InterTouch device.
+  */
+ static int synaptics_setup_intertouch(struct psmouse *psmouse,
+ 				      struct synaptics_device_info *info,
+ 				      bool leave_breadcrumbs)
+ {
+ 	int error;
+ 
+ 	if (synaptics_intertouch == SYNAPTICS_INTERTOUCH_OFF)
+ 		return -ENXIO;
+ 
+ 	if (synaptics_intertouch == SYNAPTICS_INTERTOUCH_NOT_SET) {
+ 		if (!psmouse_matches_pnp_id(psmouse, topbuttonpad_pnp_ids) &&
+ 		    !psmouse_matches_pnp_id(psmouse, smbus_pnp_ids)) {
+ 
+ 			if (!psmouse_matches_pnp_id(psmouse, forcepad_pnp_ids))
+ 				psmouse_info(psmouse,
+ 					     "Your touchpad (%s) says it can support a different bus. "
+ 					     "If i2c-hid and hid-rmi are not used, you might want to try setting psmouse.synaptics_intertouch to 1 and report this to linux-input@vger.kernel.org.\n",
+ 					     psmouse->ps2dev.serio->firmware_id);
+ 
+ 			return -ENXIO;
+ 		}
+ 	}
+ 
+ 	psmouse_info(psmouse, "Trying to set up SMBus access\n");
+ 
+ 	error = synaptics_create_intertouch(psmouse, info, leave_breadcrumbs);
+ 	if (error) {
+ 		if (error == -EAGAIN)
+ 			psmouse_info(psmouse, "SMbus companion is not ready yet\n");
+ 		else
+ 			psmouse_err(psmouse, "unable to create intertouch device\n");
+ 
+ 		return error;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int synaptics_init_smbus(struct psmouse *psmouse)
+ {
+ 	struct synaptics_device_info info;
+ 	int error;
+ 
+ 	psmouse_reset(psmouse);
+ 
+ 	error = synaptics_query_hardware(psmouse, &info);
+ 	if (error) {
+ 		psmouse_err(psmouse, "Unable to query device: %d\n", error);
+ 		return error;
+ 	}
+ 
+ 	if (!SYN_CAP_INTERTOUCH(info.ext_cap_0c))
+ 		return -ENXIO;
+ 
+ 	return synaptics_create_intertouch(psmouse, &info, false);
+ }
+ 
+ #else /* CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS */
+ 
+ static int __maybe_unused
+ synaptics_setup_intertouch(struct psmouse *psmouse,
+ 			   struct synaptics_device_info *info,
+ 			   bool leave_breadcrumbs)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int synaptics_init_smbus(struct psmouse *psmouse)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ #endif /* CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS */
+ 
+ #if defined(CONFIG_MOUSE_PS2_SYNAPTICS) || \
+     defined(CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS)
+ 
+ int synaptics_init(struct psmouse *psmouse)
+ {
+ 	struct synaptics_device_info info;
+ 	int error;
+ 	int retval;
+ 
+ 	psmouse_reset(psmouse);
+ 
+ 	error = synaptics_query_hardware(psmouse, &info);
+ 	if (error) {
+ 		psmouse_err(psmouse, "Unable to query device: %d\n", error);
+ 		return error;
+ 	}
+ 
+ 	if (SYN_CAP_INTERTOUCH(info.ext_cap_0c)) {
+ 		if ((!IS_ENABLED(CONFIG_RMI4_SMB) ||
+ 		     !IS_ENABLED(CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS)) &&
+ 		    /* Forcepads need F21, which is not ready */
+ 		    !psmouse_matches_pnp_id(psmouse, forcepad_pnp_ids)) {
+ 			psmouse_warn(psmouse,
+ 				     "The touchpad can support a better bus than the too old PS/2 protocol. "
+ 				     "Make sure MOUSE_PS2_SYNAPTICS_SMBUS and RMI4_SMB are enabled to get a better touchpad experience.\n");
+ 		}
+ 
+ 		error = synaptics_setup_intertouch(psmouse, &info, true);
+ 		if (!error)
+ 			return PSMOUSE_SYNAPTICS_SMBUS;
+ 	}
+ 
+ 	retval = synaptics_setup_ps2(psmouse, &info);
+ 	if (retval < 0) {
+ 		/*
+ 		 * Not using any flavor of Synaptics support, so clean up
+ 		 * SMbus breadcrumbs, if any.
+ 		 */
+ 		psmouse_smbus_cleanup(psmouse);
+ 	}
+ 
+ 	return retval;
+ }
+ 
+ #else /* CONFIG_MOUSE_PS2_SYNAPTICS || CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS */
+ 
+ int synaptics_init(struct psmouse *psmouse)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ #endif /* CONFIG_MOUSE_PS2_SYNAPTICS || CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS */
++>>>>>>> 2b30297d481a (Input: synaptics - disable kernel tracking on SMBus devices)
* Unmerged path drivers/input/mouse/synaptics.c
