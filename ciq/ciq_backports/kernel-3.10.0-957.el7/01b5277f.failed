amd-xgbe: Add ethtool show/set channels support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Tom Lendacky <thomas.lendacky@amd.com>
commit 01b5277fc9984d9fb9156afa0b1be70b3b475825
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/01b5277f.failed

Add ethtool support to show and set the device channel configuration.
Changing the channel configuration will result in a device restart.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 01b5277fc9984d9fb9156afa0b1be70b3b475825)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/xgbe/xgbe-drv.c
#	drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
#	drivers/net/ethernet/amd/xgbe/xgbe.h
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-drv.c
index d6687ed9891d,24f1053b8785..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
@@@ -1205,6 -1312,58 +1205,61 @@@ int xgbe_powerup(struct net_device *net
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void xgbe_free_memory(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_desc_if *desc_if = &pdata->desc_if;
+ 
+ 	/* Free the ring descriptors and buffers */
+ 	desc_if->free_ring_resources(pdata);
+ 
+ 	/* Free the channel and ring structures */
+ 	xgbe_free_channels(pdata);
+ }
+ 
+ static int xgbe_alloc_memory(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_desc_if *desc_if = &pdata->desc_if;
+ 	struct net_device *netdev = pdata->netdev;
+ 	int ret;
+ 
+ 	if (pdata->new_tx_ring_count) {
+ 		pdata->tx_ring_count = pdata->new_tx_ring_count;
+ 		pdata->tx_q_count = pdata->tx_ring_count;
+ 		pdata->new_tx_ring_count = 0;
+ 	}
+ 
+ 	if (pdata->new_rx_ring_count) {
+ 		pdata->rx_ring_count = pdata->new_rx_ring_count;
+ 		pdata->new_rx_ring_count = 0;
+ 	}
+ 
+ 	/* Calculate the Rx buffer size before allocating rings */
+ 	pdata->rx_buf_size = xgbe_calc_rx_buf_size(netdev, netdev->mtu);
+ 
+ 	/* Allocate the channel and ring structures */
+ 	ret = xgbe_alloc_channels(pdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Allocate the ring descriptors and buffers */
+ 	ret = desc_if->alloc_ring_resources(pdata);
+ 	if (ret)
+ 		goto err_channels;
+ 
+ 	/* Initialize the service and Tx timers */
+ 	xgbe_init_timers(pdata);
+ 
+ 	return 0;
+ 
+ err_channels:
+ 	xgbe_free_memory(pdata);
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 01b5277fc998 (amd-xgbe: Add ethtool show/set channels support)
  static int xgbe_start(struct xgbe_prv_data *pdata)
  {
  	struct xgbe_hw_if *hw_if = &pdata->hw_if;
@@@ -1315,10 -1493,22 +1370,28 @@@ static void xgbe_stopdev(struct work_st
  	netdev_alert(pdata->netdev, "device stopped\n");
  }
  
++<<<<<<< HEAD
 +static void xgbe_restart_dev(struct xgbe_prv_data *pdata)
++=======
+ void xgbe_full_restart_dev(struct xgbe_prv_data *pdata)
+ {
+ 	/* If not running, "restart" will happen on open */
+ 	if (!netif_running(pdata->netdev))
+ 		return;
+ 
+ 	xgbe_stop(pdata);
+ 
+ 	xgbe_free_memory(pdata);
+ 	xgbe_alloc_memory(pdata);
+ 
+ 	xgbe_start(pdata);
+ }
+ 
+ void xgbe_restart_dev(struct xgbe_prv_data *pdata)
++>>>>>>> 01b5277fc998 (amd-xgbe: Add ethtool show/set channels support)
  {
 +	DBGPR("-->xgbe_restart_dev\n");
 +
  	/* If not running, "restart" will happen on open */
  	if (!netif_running(pdata->netdev))
  		return;
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
index f80b186779b7,a880f10e3e70..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
@@@ -614,6 -626,217 +614,220 @@@ static int xgbe_get_ts_info(struct net_
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int xgbe_get_module_info(struct net_device *netdev,
+ 				struct ethtool_modinfo *modinfo)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	return pdata->phy_if.module_info(pdata, modinfo);
+ }
+ 
+ static int xgbe_get_module_eeprom(struct net_device *netdev,
+ 				  struct ethtool_eeprom *eeprom, u8 *data)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	return pdata->phy_if.module_eeprom(pdata, eeprom, data);
+ }
+ 
+ static void xgbe_get_ringparam(struct net_device *netdev,
+ 			       struct ethtool_ringparam *ringparam)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	ringparam->rx_max_pending = XGBE_RX_DESC_CNT_MAX;
+ 	ringparam->tx_max_pending = XGBE_TX_DESC_CNT_MAX;
+ 	ringparam->rx_pending = pdata->rx_desc_count;
+ 	ringparam->tx_pending = pdata->tx_desc_count;
+ }
+ 
+ static int xgbe_set_ringparam(struct net_device *netdev,
+ 			      struct ethtool_ringparam *ringparam)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	unsigned int rx, tx;
+ 
+ 	if (ringparam->rx_mini_pending || ringparam->rx_jumbo_pending) {
+ 		netdev_err(netdev, "unsupported ring parameter\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if ((ringparam->rx_pending < XGBE_RX_DESC_CNT_MIN) ||
+ 	    (ringparam->rx_pending > XGBE_RX_DESC_CNT_MAX)) {
+ 		netdev_err(netdev,
+ 			   "rx ring parameter must be between %u and %u\n",
+ 			   XGBE_RX_DESC_CNT_MIN, XGBE_RX_DESC_CNT_MAX);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if ((ringparam->tx_pending < XGBE_TX_DESC_CNT_MIN) ||
+ 	    (ringparam->tx_pending > XGBE_TX_DESC_CNT_MAX)) {
+ 		netdev_err(netdev,
+ 			   "tx ring parameter must be between %u and %u\n",
+ 			   XGBE_TX_DESC_CNT_MIN, XGBE_TX_DESC_CNT_MAX);
+ 		return -EINVAL;
+ 	}
+ 
+ 	rx = __rounddown_pow_of_two(ringparam->rx_pending);
+ 	if (rx != ringparam->rx_pending)
+ 		netdev_notice(netdev,
+ 			      "rx ring parameter rounded to power of two: %u\n",
+ 			      rx);
+ 
+ 	tx = __rounddown_pow_of_two(ringparam->tx_pending);
+ 	if (tx != ringparam->tx_pending)
+ 		netdev_notice(netdev,
+ 			      "tx ring parameter rounded to power of two: %u\n",
+ 			      tx);
+ 
+ 	if ((rx == pdata->rx_desc_count) &&
+ 	    (tx == pdata->tx_desc_count))
+ 		goto out;
+ 
+ 	pdata->rx_desc_count = rx;
+ 	pdata->tx_desc_count = tx;
+ 
+ 	xgbe_restart_dev(pdata);
+ 
+ out:
+ 	return 0;
+ }
+ 
+ static void xgbe_get_channels(struct net_device *netdev,
+ 			      struct ethtool_channels *channels)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	unsigned int rx, tx, combined;
+ 
+ 	/* Calculate maximums allowed:
+ 	 *   - Take into account the number of available IRQs
+ 	 *   - Do not take into account the number of online CPUs so that
+ 	 *     the user can over-subscribe if desired
+ 	 *   - Tx is additionally limited by the number of hardware queues
+ 	 */
+ 	rx = min(pdata->hw_feat.rx_ch_cnt, pdata->rx_max_channel_count);
+ 	rx = min(rx, pdata->channel_irq_count);
+ 	tx = min(pdata->hw_feat.tx_ch_cnt, pdata->tx_max_channel_count);
+ 	tx = min(tx, pdata->channel_irq_count);
+ 	tx = min(tx, pdata->tx_max_q_count);
+ 
+ 	combined = min(rx, tx);
+ 
+ 	channels->max_combined = combined;
+ 	channels->max_rx = rx ? rx - 1 : 0;
+ 	channels->max_tx = tx ? tx - 1 : 0;
+ 
+ 	/* Get current settings based on device state */
+ 	rx = pdata->new_rx_ring_count ? : pdata->rx_ring_count;
+ 	tx = pdata->new_tx_ring_count ? : pdata->tx_ring_count;
+ 
+ 	combined = min(rx, tx);
+ 	rx -= combined;
+ 	tx -= combined;
+ 
+ 	channels->combined_count = combined;
+ 	channels->rx_count = rx;
+ 	channels->tx_count = tx;
+ }
+ 
+ static void xgbe_print_set_channels_input(struct net_device *netdev,
+ 					  struct ethtool_channels *channels)
+ {
+ 	netdev_err(netdev, "channel inputs: combined=%u, rx-only=%u, tx-only=%u\n",
+ 		   channels->combined_count, channels->rx_count,
+ 		   channels->tx_count);
+ }
+ 
+ static int xgbe_set_channels(struct net_device *netdev,
+ 			     struct ethtool_channels *channels)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	unsigned int rx, rx_curr, tx, tx_curr, combined;
+ 
+ 	/* Calculate maximums allowed:
+ 	 *   - Take into account the number of available IRQs
+ 	 *   - Do not take into account the number of online CPUs so that
+ 	 *     the user can over-subscribe if desired
+ 	 *   - Tx is additionally limited by the number of hardware queues
+ 	 */
+ 	rx = min(pdata->hw_feat.rx_ch_cnt, pdata->rx_max_channel_count);
+ 	rx = min(rx, pdata->channel_irq_count);
+ 	tx = min(pdata->hw_feat.tx_ch_cnt, pdata->tx_max_channel_count);
+ 	tx = min(tx, pdata->tx_max_q_count);
+ 	tx = min(tx, pdata->channel_irq_count);
+ 
+ 	combined = min(rx, tx);
+ 
+ 	/* Should not be setting other count */
+ 	if (channels->other_count) {
+ 		netdev_err(netdev,
+ 			   "other channel count must be zero\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Require at least one Combined (Rx and Tx) channel */
+ 	if (!channels->combined_count) {
+ 		netdev_err(netdev,
+ 			   "at least one combined Rx/Tx channel is required\n");
+ 		xgbe_print_set_channels_input(netdev, channels);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Check combined channels */
+ 	if (channels->combined_count > combined) {
+ 		netdev_err(netdev,
+ 			   "combined channel count cannot exceed %u\n",
+ 			   combined);
+ 		xgbe_print_set_channels_input(netdev, channels);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Can have some Rx-only or Tx-only channels, but not both */
+ 	if (channels->rx_count && channels->tx_count) {
+ 		netdev_err(netdev,
+ 			   "cannot specify both Rx-only and Tx-only channels\n");
+ 		xgbe_print_set_channels_input(netdev, channels);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Check that we don't exceed the maximum number of channels */
+ 	if ((channels->combined_count + channels->rx_count) > rx) {
+ 		netdev_err(netdev,
+ 			   "total Rx channels (%u) requested exceeds maximum available (%u)\n",
+ 			   channels->combined_count + channels->rx_count, rx);
+ 		xgbe_print_set_channels_input(netdev, channels);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if ((channels->combined_count + channels->tx_count) > tx) {
+ 		netdev_err(netdev,
+ 			   "total Tx channels (%u) requested exceeds maximum available (%u)\n",
+ 			   channels->combined_count + channels->tx_count, tx);
+ 		xgbe_print_set_channels_input(netdev, channels);
+ 		return -EINVAL;
+ 	}
+ 
+ 	rx = channels->combined_count + channels->rx_count;
+ 	tx = channels->combined_count + channels->tx_count;
+ 
+ 	rx_curr = pdata->new_rx_ring_count ? : pdata->rx_ring_count;
+ 	tx_curr = pdata->new_tx_ring_count ? : pdata->tx_ring_count;
+ 
+ 	if ((rx == rx_curr) && (tx == tx_curr))
+ 		goto out;
+ 
+ 	pdata->new_rx_ring_count = rx;
+ 	pdata->new_tx_ring_count = tx;
+ 
+ 	xgbe_full_restart_dev(pdata);
+ 
+ out:
+ 	return 0;
+ }
+ 
++>>>>>>> 01b5277fc998 (amd-xgbe: Add ethtool show/set channels support)
  static const struct ethtool_ops xgbe_ethtool_ops = {
  	.get_drvinfo = xgbe_get_drvinfo,
  	.get_msglevel = xgbe_get_msglevel,
@@@ -634,6 -857,12 +848,15 @@@
  	.get_ts_info = xgbe_get_ts_info,
  	.get_link_ksettings = xgbe_get_link_ksettings,
  	.set_link_ksettings = xgbe_set_link_ksettings,
++<<<<<<< HEAD
++=======
+ 	.get_module_info = xgbe_get_module_info,
+ 	.get_module_eeprom = xgbe_get_module_eeprom,
+ 	.get_ringparam = xgbe_get_ringparam,
+ 	.set_ringparam = xgbe_set_ringparam,
+ 	.get_channels = xgbe_get_channels,
+ 	.set_channels = xgbe_set_channels,
++>>>>>>> 01b5277fc998 (amd-xgbe: Add ethtool show/set channels support)
  };
  
  const struct ethtool_ops *xgbe_get_ethtool_ops(void)
diff --cc drivers/net/ethernet/amd/xgbe/xgbe.h
index 8ee4166e96ad,7a412cfa8e40..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe.h
@@@ -1244,6 -1338,8 +1247,11 @@@ int xgbe_powerup(struct net_device *, u
  int xgbe_powerdown(struct net_device *, unsigned int);
  void xgbe_init_rx_coalesce(struct xgbe_prv_data *);
  void xgbe_init_tx_coalesce(struct xgbe_prv_data *);
++<<<<<<< HEAD
++=======
+ void xgbe_restart_dev(struct xgbe_prv_data *pdata);
+ void xgbe_full_restart_dev(struct xgbe_prv_data *pdata);
++>>>>>>> 01b5277fc998 (amd-xgbe: Add ethtool show/set channels support)
  
  #ifdef CONFIG_DEBUG_FS
  void xgbe_debugfs_init(struct xgbe_prv_data *);
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-drv.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe.h
