block: Introduce queue flag QUEUE_FLAG_SCSI_PASSTHROUGH

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit 9efc160f4bbd69b17b48edec53067537d04e62b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9efc160f.failed

From the context where a SCSI command is submitted it is not always
possible to figure out whether or not the queue the command is
submitted to has struct scsi_request as the first member of its
private data. Hence introduce the flag QUEUE_FLAG_SCSI_PASSTHROUGH.

	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
	Cc: Omar Sandoval <osandov@fb.com>
	Cc: Don Brace <don.brace@microsemi.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 9efc160f4bbd69b17b48edec53067537d04e62b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/cciss.c
#	drivers/ide/ide-probe.c
#	include/linux/blkdev.h
diff --cc drivers/block/cciss.c
index 90a4e6b940ac,3761066fe89d..000000000000
--- a/drivers/block/cciss.c
+++ b/drivers/block/cciss.c
@@@ -1934,9 -1949,17 +1934,20 @@@ static void cciss_get_serial_no(ctlr_in
  static int cciss_add_disk(ctlr_info_t *h, struct gendisk *disk,
  				int drv_index)
  {
 -	disk->queue = blk_alloc_queue(GFP_KERNEL);
 +	disk->queue = blk_init_queue(do_cciss_request, &h->lock);
  	if (!disk->queue)
  		goto init_queue_failure;
++<<<<<<< HEAD
++=======
+ 
+ 	disk->queue->cmd_size = sizeof(struct scsi_request);
+ 	disk->queue->request_fn = do_cciss_request;
+ 	disk->queue->queue_lock = &h->lock;
+ 	queue_flag_set_unlocked(QUEUE_FLAG_SCSI_PASSTHROUGH, disk->queue);
+ 	if (blk_init_allocated_queue(disk->queue) < 0)
+ 		goto cleanup_queue;
+ 
++>>>>>>> 9efc160f4bbd (block: Introduce queue flag QUEUE_FLAG_SCSI_PASSTHROUGH)
  	sprintf(disk->disk_name, "cciss/c%dd%d", h->ctlr, drv_index);
  	disk->major = h->major;
  	disk->first_minor = drv_index << NWD_SHIFT;
diff --cc drivers/ide/ide-probe.c
index 1a926e7a9ddc,b3f85250dea9..000000000000
--- a/drivers/ide/ide-probe.c
+++ b/drivers/ide/ide-probe.c
@@@ -763,6 -770,15 +763,18 @@@ static int ide_init_queue(ide_drive_t *
  	if (!q)
  		return 1;
  
++<<<<<<< HEAD
++=======
+ 	q->request_fn = do_ide_request;
+ 	q->init_rq_fn = ide_init_rq;
+ 	q->cmd_size = sizeof(struct ide_request);
+ 	queue_flag_set_unlocked(QUEUE_FLAG_SCSI_PASSTHROUGH, q);
+ 	if (blk_init_allocated_queue(q) < 0) {
+ 		blk_cleanup_queue(q);
+ 		return 1;
+ 	}
+ 
++>>>>>>> 9efc160f4bbd (block: Introduce queue flag QUEUE_FLAG_SCSI_PASSTHROUGH)
  	q->queuedata = drive;
  	blk_queue_segment_boundary(q, 0xffff);
  
diff --cc include/linux/blkdev.h
index 2b624b97bb35,019f18c65098..000000000000
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@@ -598,14 -609,16 +598,27 @@@ struct request_queue 
  #define QUEUE_FLAG_SAME_FORCE  18	/* force complete on same CPU */
  #define QUEUE_FLAG_DEAD        19	/* queue tear-down finished */
  #define QUEUE_FLAG_INIT_DONE   20	/* queue is initialized */
++<<<<<<< HEAD
 +#define QUEUE_FLAG_UNPRIV_SGIO 21	/* SG_IO free for unprivileged users */
 +#define QUEUE_FLAG_NO_SG_MERGE 22	/* don't attempt to merge SG segments*/
 +#define QUEUE_FLAG_SG_GAPS     23	/* queue doesn't support SG gaps */
 +#define QUEUE_FLAG_DAX         24	/* device supports DAX */
 +#define QUEUE_FLAG_REGISTERED  25	/* queue has been registered to a disk */
 +#define QUEUE_FLAG_STATS       26	/* track rq completion times */
 +#define QUEUE_FLAG_POLL_STATS  27	/* collecting stats for hybrid polling */
 +#define QUEUE_FLAG_PREEMPT_ONLY	28	/* only process REQ_PREEMPT requests */
++=======
+ #define QUEUE_FLAG_NO_SG_MERGE 21	/* don't attempt to merge SG segments*/
+ #define QUEUE_FLAG_POLL	       22	/* IO polling enabled if set */
+ #define QUEUE_FLAG_WC	       23	/* Write back caching */
+ #define QUEUE_FLAG_FUA	       24	/* device supports FUA writes */
+ #define QUEUE_FLAG_FLUSH_NQ    25	/* flush not queueuable */
+ #define QUEUE_FLAG_DAX         26	/* device supports DAX */
+ #define QUEUE_FLAG_STATS       27	/* track rq completion times */
+ #define QUEUE_FLAG_POLL_STATS  28	/* collecting stats for hybrid polling */
+ #define QUEUE_FLAG_REGISTERED  29	/* queue has been registered to a disk */
+ #define QUEUE_FLAG_SCSI_PASSTHROUGH 30	/* queue supports SCSI commands */
++>>>>>>> 9efc160f4bbd (block: Introduce queue flag QUEUE_FLAG_SCSI_PASSTHROUGH)
  
  #define QUEUE_FLAG_DEFAULT	((1 << QUEUE_FLAG_IO_STAT) |		\
  				 (1 << QUEUE_FLAG_STACKABLE)	|	\
@@@ -694,14 -706,11 +707,19 @@@ static inline void queue_flag_clear(uns
  #define blk_queue_stackable(q)	\
  	test_bit(QUEUE_FLAG_STACKABLE, &(q)->queue_flags)
  #define blk_queue_discard(q)	test_bit(QUEUE_FLAG_DISCARD, &(q)->queue_flags)
 -#define blk_queue_secure_erase(q) \
 -	(test_bit(QUEUE_FLAG_SECERASE, &(q)->queue_flags))
 +#define blk_queue_secdiscard(q)	(blk_queue_discard(q) && \
 +	test_bit(QUEUE_FLAG_SECDISCARD, &(q)->queue_flags))
  #define blk_queue_dax(q)	test_bit(QUEUE_FLAG_DAX, &(q)->queue_flags)
++<<<<<<< HEAD
 +#define blk_queue_preempt_only(q)				\
 +	test_bit(QUEUE_FLAG_PREEMPT_ONLY, &(q)->queue_flags)
 +
 +extern int blk_set_preempt_only(struct request_queue *q);
 +extern void blk_clear_preempt_only(struct request_queue *q);
++=======
+ #define blk_queue_scsi_passthrough(q)	\
+ 	test_bit(QUEUE_FLAG_SCSI_PASSTHROUGH, &(q)->queue_flags)
++>>>>>>> 9efc160f4bbd (block: Introduce queue flag QUEUE_FLAG_SCSI_PASSTHROUGH)
  
  #define blk_noretry_request(rq) \
  	((rq)->cmd_flags & (REQ_FAILFAST_DEV|REQ_FAILFAST_TRANSPORT| \
diff --git a/block/bsg-lib.c b/block/bsg-lib.c
index 650f427d915b..b788f7867d27 100644
--- a/block/bsg-lib.c
+++ b/block/bsg-lib.c
@@ -217,6 +217,7 @@ int bsg_setup_queue(struct device *dev, struct request_queue *q,
 	q->bsg_job_size = dd_job_size;
 	q->bsg_job_fn = job_fn;
 	queue_flag_set_unlocked(QUEUE_FLAG_BIDI, q);
+	queue_flag_set_unlocked(QUEUE_FLAG_SCSI_PASSTHROUGH, q);
 	blk_queue_softirq_done(q, bsg_softirq_done);
 	blk_queue_rq_timeout(q, BLK_DEFAULT_SG_TIMEOUT);
 
* Unmerged path drivers/block/cciss.c
* Unmerged path drivers/ide/ide-probe.c
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index e0f2e99b8896..6e52b3629a8e 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -1967,6 +1967,8 @@ static void __scsi_init_queue(struct Scsi_Host *shost, struct request_queue *q)
 {
 	struct device *dev = shost->dma_dev;
 
+	queue_flag_set_unlocked(QUEUE_FLAG_SCSI_PASSTHROUGH, q);
+
 	/*
 	 * this limit is imposed by hardware restrictions
 	 */
diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index d2cae3cf1a54..61850a6de026 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -255,6 +255,7 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 		q->queuedata = shost;
 
 	queue_flag_set_unlocked(QUEUE_FLAG_BIDI, q);
+	queue_flag_set_unlocked(QUEUE_FLAG_SCSI_PASSTHROUGH, q);
 	return 0;
 }
 
* Unmerged path include/linux/blkdev.h
