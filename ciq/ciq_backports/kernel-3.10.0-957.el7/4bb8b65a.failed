xfs: fix string handling in label get/set functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Arnd Bergmann <arnd@arndb.de>
commit 4bb8b65a04273c5acd6d1e08e08b757b4e6f4913
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4bb8b65a.failed

[sandeen: fix subject, avoid copy-out of uninit data in getlabel]

gcc-8 reports two warnings for the newly added getlabel/setlabel code:

fs/xfs/xfs_ioctl.c: In function 'xfs_ioc_getlabel':
fs/xfs/xfs_ioctl.c:1822:38: error: argument to 'sizeof' in 'strncpy' call is the same expression as the source; did you mean to use the size of the destination? [-Werror=sizeof-pointer-memaccess]
  strncpy(label, sbp->sb_fname, sizeof(sbp->sb_fname));
                                      ^
In function 'strncpy',
    inlined from 'xfs_ioc_setlabel' at /git/arm-soc/fs/xfs/xfs_ioctl.c:1863:2,
    inlined from 'xfs_file_ioctl' at /git/arm-soc/fs/xfs/xfs_ioctl.c:1918:10:
include/linux/string.h:254:9: error: '__builtin_strncpy' output may be truncated copying 12 bytes from a string of length 12 [-Werror=stringop-truncation]
  return __builtin_strncpy(p, q, size);

In both cases, part of the problem is that one of the strncpy()
arguments is a fixed-length character array with zero-padding rather
than a zero-terminated string. In the first one case, we also get an
odd warning about sizeof-pointer-memaccess, which doesn't seem right
(the sizeof is for an array that happens to be the same as the second
strncpy argument).

To work around the bogus warning, I use a plain 'XFSLABEL_MAX' for
the strncpy() length when copying the label in getlabel. For setlabel(),
using memcpy() with the correct length that is already known avoids
the second warning and is slightly simpler.

In a related issue, it appears that we accidentally skip the trailing
\0 when copying a 12-character label back to user space in getlabel().
Using the correct sizeof() argument here copies the extra character.

Link: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85602
Fixes: f7664b31975b ("xfs: implement online get/set fs label")
	Cc: Eric Sandeen <sandeen@redhat.com>
	Cc: Martin Sebor <msebor@gmail.com>
	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 4bb8b65a04273c5acd6d1e08e08b757b4e6f4913)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_ioctl.c
diff --cc fs/xfs/xfs_ioctl.c
index 16aae82f734b,d0236d82326a..000000000000
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@@ -1653,6 -1805,88 +1653,91 @@@ xfs_ioc_swapext
  	return error;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ xfs_ioc_getlabel(
+ 	struct xfs_mount	*mp,
+ 	char			__user *user_label)
+ {
+ 	struct xfs_sb		*sbp = &mp->m_sb;
+ 	char			label[XFSLABEL_MAX + 1];
+ 
+ 	/* Paranoia */
+ 	BUILD_BUG_ON(sizeof(sbp->sb_fname) > FSLABEL_MAX);
+ 
+ 	/* 1 larger than sb_fname, so this ensures a trailing NUL char */
+ 	memset(label, 0, sizeof(label));
+ 	spin_lock(&mp->m_sb_lock);
+ 	strncpy(label, sbp->sb_fname, XFSLABEL_MAX);
+ 	spin_unlock(&mp->m_sb_lock);
+ 
+ 	if (copy_to_user(user_label, label, sizeof(label)))
+ 		return -EFAULT;
+ 	return 0;
+ }
+ 
+ static int
+ xfs_ioc_setlabel(
+ 	struct file		*filp,
+ 	struct xfs_mount	*mp,
+ 	char			__user *newlabel)
+ {
+ 	struct xfs_sb		*sbp = &mp->m_sb;
+ 	char			label[XFSLABEL_MAX + 1];
+ 	size_t			len;
+ 	int			error;
+ 
+ 	if (!capable(CAP_SYS_ADMIN))
+ 		return -EPERM;
+ 	/*
+ 	 * The generic ioctl allows up to FSLABEL_MAX chars, but XFS is much
+ 	 * smaller, at 12 bytes.  We copy one more to be sure we find the
+ 	 * (required) NULL character to test the incoming label length.
+ 	 * NB: The on disk label doesn't need to be null terminated.
+ 	 */
+ 	if (copy_from_user(label, newlabel, XFSLABEL_MAX + 1))
+ 		return -EFAULT;
+ 	len = strnlen(label, XFSLABEL_MAX + 1);
+ 	if (len > sizeof(sbp->sb_fname))
+ 		return -EINVAL;
+ 
+ 	error = mnt_want_write_file(filp);
+ 	if (error)
+ 		return error;
+ 
+ 	spin_lock(&mp->m_sb_lock);
+ 	memset(sbp->sb_fname, 0, sizeof(sbp->sb_fname));
+ 	memcpy(sbp->sb_fname, label, len);
+ 	spin_unlock(&mp->m_sb_lock);
+ 
+ 	/*
+ 	 * Now we do several things to satisfy userspace.
+ 	 * In addition to normal logging of the primary superblock, we also
+ 	 * immediately write these changes to sector zero for the primary, then
+ 	 * update all backup supers (as xfs_db does for a label change), then
+ 	 * invalidate the block device page cache.  This is so that any prior
+ 	 * buffered reads from userspace (i.e. from blkid) are invalidated,
+ 	 * and userspace will see the newly-written label.
+ 	 */
+ 	error = xfs_sync_sb_buf(mp);
+ 	if (error)
+ 		goto out;
+ 	/*
+ 	 * growfs also updates backup supers so lock against that.
+ 	 */
+ 	mutex_lock(&mp->m_growlock);
+ 	error = xfs_update_secondary_sbs(mp);
+ 	mutex_unlock(&mp->m_growlock);
+ 
+ 	invalidate_bdev(mp->m_ddev_targp->bt_bdev);
+ 
+ out:
+ 	mnt_drop_write_file(filp);
+ 	return error;
+ }
+ 
++>>>>>>> 4bb8b65a0427 (xfs: fix string handling in label get/set functions)
  /*
   * Note: some of the ioctl's return positive numbers as a
   * byte count indicating success, such as readlink_by_handle.
* Unmerged path fs/xfs/xfs_ioctl.c
