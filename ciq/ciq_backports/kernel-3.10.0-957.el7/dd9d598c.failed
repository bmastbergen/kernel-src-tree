ip_gre: add the support for i/o_flags update via netlink

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit dd9d598c6657e2d2eed4497ff2c5d744015201dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/dd9d598c.failed

Now ip_gre is using ip_tunnel_changelink to update it's properties, but
ip_tunnel_changelink in ip_tunnel doesn't update i/o_flags as a common
function.

o_flags updates would cause that tunnel->tun_hlen / hlen and dev->mtu /
needed_headroom need to be recalculated, and dev->(hw_)features need to
be updated as well.

Therefore, we can't just add the update into ip_tunnel_update called
in ip_tunnel_changelink, and it's also better not to touch ip_tunnel
codes.

This patch updates i/o_flags and calls ipgre_link_update to recalculate
these gre properties after ip_tunnel_changelink does the common update.

Note that since ipgre_link_update doesn't know the lower dev, it will
update gre->hlen, dev->mtu and dev->needed_headroom with the value of
'new tun_hlen - old tun_hlen'. In this way, we can avoid many redundant
codes, unlike ip6_gre.

	Reported-by: Jianlin Shi <jishi@redhat.com>
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Acked-by: William Tu <u9012063@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit dd9d598c6657e2d2eed4497ff2c5d744015201dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ip_gre.c
diff --cc net/ipv4/ip_gre.c
index 59a1b969ca2f,81e1e20af33b..000000000000
--- a/net/ipv4/ip_gre.c
+++ b/net/ipv4/ip_gre.c
@@@ -960,10 -1327,13 +984,17 @@@ static int ipgre_newlink(struct net *sr
  }
  
  static int ipgre_changelink(struct net_device *dev, struct nlattr *tb[],
 -			    struct nlattr *data[],
 -			    struct netlink_ext_ack *extack)
 +			    struct nlattr *data[])
  {
++<<<<<<< HEAD
 +	struct ip_tunnel_parm p;
 +	struct ip_tunnel_encap ipencap;
++=======
+ 	struct ip_tunnel *t = netdev_priv(dev);
+ 	struct ip_tunnel_encap ipencap;
+ 	__u32 fwmark = t->fwmark;
+ 	struct ip_tunnel_parm p;
++>>>>>>> dd9d598c6657 (ip_gre: add the support for i/o_flags update via netlink)
  	int err;
  
  	if (ipgre_netlink_encap_parms(data, &ipencap)) {
@@@ -974,10 -1343,21 +1005,25 @@@
  			return err;
  	}
  
 -	err = ipgre_netlink_parms(dev, data, tb, &p, &fwmark);
 +	err = ipgre_netlink_parms(dev, data, tb, &p);
  	if (err < 0)
  		return err;
++<<<<<<< HEAD
 +	return ip_tunnel_changelink(dev, tb, &p);
++=======
+ 
+ 	err = ip_tunnel_changelink(dev, tb, &p, fwmark);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	t->parms.i_flags = p.i_flags;
+ 	t->parms.o_flags = p.o_flags;
+ 
+ 	if (strcmp(dev->rtnl_link_ops->kind, "erspan"))
+ 		ipgre_link_update(dev, !tb[IFLA_MTU]);
+ 
+ 	return 0;
++>>>>>>> dd9d598c6657 (ip_gre: add the support for i/o_flags update via netlink)
  }
  
  static size_t ipgre_get_size(const struct net_device *dev)
* Unmerged path net/ipv4/ip_gre.c
