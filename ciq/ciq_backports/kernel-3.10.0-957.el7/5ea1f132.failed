net: ipmr: move struct mr_table and VIF_EXISTS to mroute.h

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] ipmr: move struct mr_table and VIF_EXISTS to mroute.h (Ivan Vecera) [1584232]
Rebuild_FUZZ: 95.50%
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit 5ea1f13299d8b8edcb2969eda4c81f8e3264b706
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5ea1f132.failed

Move the definitions of VIF_EXISTS() and struct mr_table to mroute.h

	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5ea1f13299d8b8edcb2969eda4c81f8e3264b706)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ipmr.c
diff --cc net/ipv4/ipmr.c
index 14e0af5a16ef,ff3dbbb9f11c..000000000000
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@@ -67,26 -67,6 +67,29 @@@
  #include <net/fib_rules.h>
  #include <linux/netconf.h>
  
++<<<<<<< HEAD
 +#if defined(CONFIG_IP_PIMSM_V1) || defined(CONFIG_IP_PIMSM_V2)
 +#define CONFIG_IP_PIMSM	1
 +#endif
 +
 +struct mr_table {
 +	struct list_head	list;
 +	possible_net_t		net;
 +	u32			id;
 +	struct sock __rcu	*mroute_sk;
 +	struct timer_list	ipmr_expire_timer;
 +	struct list_head	mfc_unres_queue;
 +	struct list_head	mfc_cache_array[MFC_LINES];
 +	struct vif_device	vif_table[MAXVIFS];
 +	int			maxvif;
 +	atomic_t		cache_resolve_queue_len;
 +	bool			mroute_do_assert;
 +	bool			mroute_do_pim;
 +	int			mroute_reg_vif_num;
 +};
 +
++=======
++>>>>>>> 5ea1f13299d8 (net: ipmr: move struct mr_table and VIF_EXISTS to mroute.h)
  struct ipmr_rule {
  	struct fib_rule		common;
  };
@@@ -101,12 -86,8 +104,10 @@@ struct ipmr_result 
  
  static DEFINE_RWLOCK(mrt_lock);
  
 -/* Multicast router control variables */
 +/*
 + *	Multicast router control variables
 + */
  
- #define VIF_EXISTS(_mrt, _idx) ((_mrt)->vif_table[_idx].dev != NULL)
- 
  /* Special spinlock for queue of unresolved entries */
  static DEFINE_SPINLOCK(mfc_unres_lock);
  
diff --git a/include/linux/mroute.h b/include/linux/mroute.h
index 7c567a2679ce..bf9b322cb0b0 100644
--- a/include/linux/mroute.h
+++ b/include/linux/mroute.h
@@ -59,6 +59,25 @@ struct vif_device {
 
 #define VIFF_STATIC 0x8000
 
+#define VIF_EXISTS(_mrt, _idx) ((_mrt)->vif_table[_idx].dev != NULL)
+#define MFC_LINES 64
+
+struct mr_table {
+	struct list_head	list;
+	possible_net_t		net;
+	u32			id;
+	struct sock __rcu	*mroute_sk;
+	struct timer_list	ipmr_expire_timer;
+	struct list_head	mfc_unres_queue;
+	struct list_head	mfc_cache_array[MFC_LINES];
+	struct vif_device	vif_table[MAXVIFS];
+	int			maxvif;
+	atomic_t		cache_resolve_queue_len;
+	bool			mroute_do_assert;
+	bool			mroute_do_pim;
+	int			mroute_reg_vif_num;
+};
+
 /* mfc_flags:
  * MFC_STATIC - the entry was added statically (not by a routing daemon)
  */
@@ -91,8 +110,6 @@ struct mfc_cache {
 	struct rcu_head	rcu;
 };
 
-#define MFC_LINES 64
-
 #ifdef __BIG_ENDIAN
 #define MFC_HASH(a,b)	(((((__force u32)(__be32)a)>>24)^(((__force u32)(__be32)b)>>26))&(MFC_LINES-1))
 #else
* Unmerged path net/ipv4/ipmr.c
