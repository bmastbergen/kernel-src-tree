hyper-v: trace channel events

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 991f8f1c6eb634688952fa6a03cc0ce949b6e363
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/991f8f1c.failed

Added an additional set of trace points for when channel gets notified
or signals host.

	Suggested-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 991f8f1c6eb634688952fa6a03cc0ce949b6e363)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/vmbus_drv.c
diff --cc drivers/hv/vmbus_drv.c
index 6942c2cfdf23,6a86746d4f60..000000000000
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@@ -947,6 -946,10 +947,13 @@@ static void vmbus_chan_sched(struct hv_
  			if (channel->rescind)
  				continue;
  
++<<<<<<< HEAD
++=======
+ 			trace_vmbus_chan_sched(channel);
+ 
+ 			++channel->interrupts;
+ 
++>>>>>>> 991f8f1c6eb6 (hyper-v: trace channel events)
  			switch (channel->callback_mode) {
  			case HV_CALL_ISR:
  				vmbus_channel_isr(channel);
diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c
index ff03d846efda..1c967f5d1bb4 100644
--- a/drivers/hv/channel.c
+++ b/drivers/hv/channel.c
@@ -43,6 +43,8 @@ void vmbus_setevent(struct vmbus_channel *channel)
 {
 	struct hv_monitor_page *monitorpage;
 
+	trace_vmbus_setevent(channel);
+
 	/*
 	 * For channels marked as in "low latency" mode
 	 * bypass the monitor page mechanism.
diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 5e36f86d0b0c..8acd2e0e7c8e 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -322,6 +322,8 @@ void vmbus_on_event(unsigned long data)
 	struct vmbus_channel *channel = (void *) data;
 	unsigned long time_limit = jiffies + 2;
 
+	trace_vmbus_on_event(channel);
+
 	do {
 		void (*callback_fn)(void *);
 
diff --git a/drivers/hv/hv_trace.h b/drivers/hv/hv_trace.h
index 5382d9630306..d635ee95b20d 100644
--- a/drivers/hv/hv_trace.h
+++ b/drivers/hv/hv_trace.h
@@ -294,6 +294,29 @@ TRACE_EVENT(vmbus_send_tl_connect_request,
 		    )
 	);
 
+DECLARE_EVENT_CLASS(vmbus_channel,
+	TP_PROTO(const struct vmbus_channel *channel),
+	TP_ARGS(channel),
+	TP_STRUCT__entry(__field(u32, relid)),
+	TP_fast_assign(__entry->relid = channel->offermsg.child_relid),
+	TP_printk("relid 0x%x", __entry->relid)
+);
+
+DEFINE_EVENT(vmbus_channel, vmbus_chan_sched,
+	    TP_PROTO(const struct vmbus_channel *channel),
+	    TP_ARGS(channel)
+);
+
+DEFINE_EVENT(vmbus_channel, vmbus_setevent,
+	    TP_PROTO(const struct vmbus_channel *channel),
+	    TP_ARGS(channel)
+);
+
+DEFINE_EVENT(vmbus_channel, vmbus_on_event,
+	    TP_PROTO(const struct vmbus_channel *channel),
+	    TP_ARGS(channel)
+);
+
 #undef TRACE_INCLUDE_PATH
 #define TRACE_INCLUDE_PATH .
 #undef TRACE_INCLUDE_FILE
* Unmerged path drivers/hv/vmbus_drv.c
