net: sched: fix clsact init error path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] sched: fix clsact init error path (Ivan Vecera) [1572720]
Rebuild_FUZZ: 92.96%
commit-author Jiri Pirko <jiri@mellanox.com>
commit 343723dd51ef1025a860e54df9472b5ba21ee3d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/343723dd.failed

Since in qdisc_create, the destroy op is called when init fails, we
don't do cleanup in init and leave it up to destroy.
This fixes use-after-free when trying to put already freed block.

Fixes: 6e40cf2d4dee ("net: sched: use extended variants of block_get/put in ingress and clsact qdiscs")
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 343723dd51ef1025a860e54df9472b5ba21ee3d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_api.c
diff --cc net/sched/cls_api.c
index 0e9c21220742,b91ea03e3afa..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -289,8 -353,7 +289,12 @@@ void tcf_block_put(struct tcf_block *bl
  
  	if (!block)
  		return;
++<<<<<<< HEAD
 +
 +	/* Hold a refcnt for all chains, so that they don't disappear
++=======
+ 	/* Hold a refcnt for all chains, except 0, so that they don't disappear
++>>>>>>> 343723dd51ef (net: sched: fix clsact init error path)
  	 * while we are iterating.
  	 */
  	list_for_each_entry(chain, &block->chain_list, list)
@@@ -299,16 -363,130 +303,28 @@@
  	list_for_each_entry(chain, &block->chain_list, list)
  		tcf_chain_flush(chain);
  
 -	tcf_block_offload_unbind(block, q, ei);
 +	/* At this point, all the chains should have refcnt >= 1. */
 +	list_for_each_entry_safe(chain, tmp, &block->chain_list, list)
 +		tcf_chain_put(chain);
  
 -	INIT_WORK(&block->work, tcf_block_put_final);
 -	/* Wait for existing RCU callbacks to cool down, make sure their works
 -	 * have been queued before this. We can not flush pending works here
 -	 * because we are holding the RTNL lock.
 -	 */
 -	rcu_barrier();
 -	tcf_queue_work(&block->work);
 +	/* Finally, put chain 0 and allow block to be freed. */
 +	chain = list_first_entry(&block->chain_list, struct tcf_chain, list);
 +	tcf_chain_put(chain);
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL(tcf_block_put_ext);
+ 
+ void tcf_block_put(struct tcf_block *block)
+ {
+ 	struct tcf_block_ext_info ei = {0, };
+ 
+ 	tcf_block_put_ext(block, block->q, &ei);
+ }
+ 
++>>>>>>> 343723dd51ef (net: sched: fix clsact init error path)
  EXPORT_SYMBOL(tcf_block_put);
  
 -struct tcf_block_cb {
 -	struct list_head list;
 -	tc_setup_cb_t *cb;
 -	void *cb_ident;
 -	void *cb_priv;
 -	unsigned int refcnt;
 -};
 -
 -void *tcf_block_cb_priv(struct tcf_block_cb *block_cb)
 -{
 -	return block_cb->cb_priv;
 -}
 -EXPORT_SYMBOL(tcf_block_cb_priv);
 -
 -struct tcf_block_cb *tcf_block_cb_lookup(struct tcf_block *block,
 -					 tc_setup_cb_t *cb, void *cb_ident)
 -{	struct tcf_block_cb *block_cb;
 -
 -	list_for_each_entry(block_cb, &block->cb_list, list)
 -		if (block_cb->cb == cb && block_cb->cb_ident == cb_ident)
 -			return block_cb;
 -	return NULL;
 -}
 -EXPORT_SYMBOL(tcf_block_cb_lookup);
 -
 -void tcf_block_cb_incref(struct tcf_block_cb *block_cb)
 -{
 -	block_cb->refcnt++;
 -}
 -EXPORT_SYMBOL(tcf_block_cb_incref);
 -
 -unsigned int tcf_block_cb_decref(struct tcf_block_cb *block_cb)
 -{
 -	return --block_cb->refcnt;
 -}
 -EXPORT_SYMBOL(tcf_block_cb_decref);
 -
 -struct tcf_block_cb *__tcf_block_cb_register(struct tcf_block *block,
 -					     tc_setup_cb_t *cb, void *cb_ident,
 -					     void *cb_priv)
 -{
 -	struct tcf_block_cb *block_cb;
 -
 -	block_cb = kzalloc(sizeof(*block_cb), GFP_KERNEL);
 -	if (!block_cb)
 -		return NULL;
 -	block_cb->cb = cb;
 -	block_cb->cb_ident = cb_ident;
 -	block_cb->cb_priv = cb_priv;
 -	list_add(&block_cb->list, &block->cb_list);
 -	return block_cb;
 -}
 -EXPORT_SYMBOL(__tcf_block_cb_register);
 -
 -int tcf_block_cb_register(struct tcf_block *block,
 -			  tc_setup_cb_t *cb, void *cb_ident,
 -			  void *cb_priv)
 -{
 -	struct tcf_block_cb *block_cb;
 -
 -	block_cb = __tcf_block_cb_register(block, cb, cb_ident, cb_priv);
 -	return block_cb ? 0 : -ENOMEM;
 -}
 -EXPORT_SYMBOL(tcf_block_cb_register);
 -
 -void __tcf_block_cb_unregister(struct tcf_block_cb *block_cb)
 -{
 -	list_del(&block_cb->list);
 -	kfree(block_cb);
 -}
 -EXPORT_SYMBOL(__tcf_block_cb_unregister);
 -
 -void tcf_block_cb_unregister(struct tcf_block *block,
 -			     tc_setup_cb_t *cb, void *cb_ident)
 -{
 -	struct tcf_block_cb *block_cb;
 -
 -	block_cb = tcf_block_cb_lookup(block, cb, cb_ident);
 -	if (!block_cb)
 -		return;
 -	__tcf_block_cb_unregister(block_cb);
 -}
 -EXPORT_SYMBOL(tcf_block_cb_unregister);
 -
 -static int tcf_block_cb_call(struct tcf_block *block, enum tc_setup_type type,
 -			     void *type_data, bool err_stop)
 -{
 -	struct tcf_block_cb *block_cb;
 -	int ok_count = 0;
 -	int err;
 -
 -	list_for_each_entry(block_cb, &block->cb_list, list) {
 -		err = block_cb->cb(type, type_data, block_cb->cb_priv);
 -		if (err) {
 -			if (err_stop)
 -				return err;
 -		} else {
 -			ok_count++;
 -		}
 -	}
 -	return ok_count;
 -}
 -
  /* Main classifier routine: scans classifier chain attached
   * to this qdisc, (optionally) tests for protocol and asks
   * specific classifiers.
* Unmerged path net/sched/cls_api.c
