net/mlx5e: Add ingress/egress indication for offloaded TC flows

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Add ingress/egress indication for offloaded TC flows (Alaa Hleihel) [1591249]
Rebuild_FUZZ: 96.72%
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit 60bd4af814fec164c42bdd2efd7984b85d6b1e1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/60bd4af8.failed

When an e-switch TC rule is offloaded through the egdev (egress
device) mechanism, we treat this as egress, all other cases (NIC
and e-switch) are considred ingress.

This is preparation step that will allow us to  identify "wrong"
stat/del offload calls made by the TC core on egdev based flows and
ignore them.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Reviewed-by: Paul Blakey <paulb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 60bd4af814fec164c42bdd2efd7984b85d6b1e1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index f9f9996c2b9e,27e8375a476b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -2913,26 -3135,58 +2913,72 @@@ out
  }
  
  #ifdef CONFIG_MLX5_ESWITCH
++<<<<<<< HEAD
 +static int mlx5e_setup_tc_cls_flower(struct net_device *dev,
 +				     struct tc_cls_flower_offload *cls_flower)
++=======
+ static int mlx5e_setup_tc_cls_flower(struct mlx5e_priv *priv,
+ 				     struct tc_cls_flower_offload *cls_flower,
+ 				     int flags)
++>>>>>>> 60bd4af814fe (net/mlx5e: Add ingress/egress indication for offloaded TC flows)
  {
 +	struct mlx5e_priv *priv = netdev_priv(dev);
 +
 +	if (!is_classid_clsact_ingress(cls_flower->common.classid) ||
 +	    cls_flower->common.chain_index)
 +		return -EOPNOTSUPP;
 +
  	switch (cls_flower->command) {
  	case TC_CLSFLOWER_REPLACE:
- 		return mlx5e_configure_flower(priv, cls_flower);
+ 		return mlx5e_configure_flower(priv, cls_flower, flags);
  	case TC_CLSFLOWER_DESTROY:
- 		return mlx5e_delete_flower(priv, cls_flower);
+ 		return mlx5e_delete_flower(priv, cls_flower, flags);
  	case TC_CLSFLOWER_STATS:
- 		return mlx5e_stats_flower(priv, cls_flower);
+ 		return mlx5e_stats_flower(priv, cls_flower, flags);
  	default:
  		return -EOPNOTSUPP;
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ static int mlx5e_setup_tc_block_cb(enum tc_setup_type type, void *type_data,
+ 				   void *cb_priv)
+ {
+ 	struct mlx5e_priv *priv = cb_priv;
+ 
+ 	if (!tc_cls_can_offload_and_chain0(priv->netdev, type_data))
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (type) {
+ 	case TC_SETUP_CLSFLOWER:
+ 		return mlx5e_setup_tc_cls_flower(priv, type_data, MLX5E_TC_INGRESS);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int mlx5e_setup_tc_block(struct net_device *dev,
+ 				struct tc_block_offload *f)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(dev);
+ 
+ 	if (f->binder_type != TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (f->command) {
+ 	case TC_BLOCK_BIND:
+ 		return tcf_block_cb_register(f->block, mlx5e_setup_tc_block_cb,
+ 					     priv, priv);
+ 	case TC_BLOCK_UNBIND:
+ 		tcf_block_cb_unregister(f->block, mlx5e_setup_tc_block_cb,
+ 					priv);
+ 		return 0;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
++>>>>>>> 60bd4af814fe (net/mlx5e: Add ingress/egress indication for offloaded TC flows)
  #endif
  
  static int mlx5e_setup_tc(struct net_device *dev, enum tc_setup_type type,
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 1f6b50ed685e,182b636552a6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -718,26 -723,31 +718,42 @@@ static int mlx5e_rep_get_phys_port_name
  
  static int
  mlx5e_rep_setup_tc_cls_flower(struct mlx5e_priv *priv,
- 			      struct tc_cls_flower_offload *cls_flower)
+ 			      struct tc_cls_flower_offload *cls_flower, int flags)
  {
 +	if (cls_flower->common.chain_index)
 +		return -EOPNOTSUPP;
 +
 +	if (cls_flower->egress_dev) {
 +		struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 +
 +		dev = mlx5_eswitch_get_uplink_netdev(esw);
 +		return __rh_call_ndo_setup_tc(dev, TC_SETUP_CLSFLOWER,
 +					      cls_flower);
 +	}
 +
  	switch (cls_flower->command) {
  	case TC_CLSFLOWER_REPLACE:
- 		return mlx5e_configure_flower(priv, cls_flower);
+ 		return mlx5e_configure_flower(priv, cls_flower, flags);
  	case TC_CLSFLOWER_DESTROY:
- 		return mlx5e_delete_flower(priv, cls_flower);
+ 		return mlx5e_delete_flower(priv, cls_flower, flags);
  	case TC_CLSFLOWER_STATS:
- 		return mlx5e_stats_flower(priv, cls_flower);
+ 		return mlx5e_stats_flower(priv, cls_flower, flags);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int mlx5e_rep_setup_tc_cb_egdev(enum tc_setup_type type, void *type_data,
+ 				       void *cb_priv)
+ {
+ 	struct mlx5e_priv *priv = cb_priv;
+ 
+ 	if (!tc_cls_can_offload_and_chain0(priv->netdev, type_data))
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (type) {
+ 	case TC_SETUP_CLSFLOWER:
+ 		return mlx5e_rep_setup_tc_cls_flower(priv, type_data, MLX5E_TC_EGRESS);
  	default:
  		return -EOPNOTSUPP;
  	}
@@@ -748,9 -758,12 +764,9 @@@ static int mlx5e_rep_setup_tc_cb(enum t
  {
  	struct mlx5e_priv *priv = cb_priv;
  
 -	if (!tc_cls_can_offload_and_chain0(priv->netdev, type_data))
 -		return -EOPNOTSUPP;
 -
  	switch (type) {
  	case TC_SETUP_CLSFLOWER:
- 		return mlx5e_rep_setup_tc_cls_flower(priv, type_data);
+ 		return mlx5e_rep_setup_tc_cls_flower(priv, type_data, MLX5E_TC_INGRESS);
  	default:
  		return -EOPNOTSUPP;
  	}
@@@ -1109,6 -1121,13 +1125,16 @@@ mlx5e_vport_rep_load(struct mlx5_eswitc
  		goto err_detach_netdev;
  	}
  
++<<<<<<< HEAD
++=======
+ 	uplink_rpriv = mlx5_eswitch_get_uplink_priv(dev->priv.eswitch, REP_ETH);
+ 	upriv = netdev_priv(uplink_rpriv->netdev);
+ 	err = tc_setup_cb_egdev_register(netdev, mlx5e_rep_setup_tc_cb_egdev,
+ 					 upriv);
+ 	if (err)
+ 		goto err_neigh_cleanup;
+ 
++>>>>>>> 60bd4af814fe (net/mlx5e: Add ingress/egress indication for offloaded TC flows)
  	err = register_netdev(netdev);
  	if (err) {
  		pr_warn("Failed to register representor netdev for vport %d\n",
@@@ -1118,6 -1137,10 +1144,13 @@@
  
  	return 0;
  
++<<<<<<< HEAD
++=======
+ err_egdev_cleanup:
+ 	tc_setup_cb_egdev_unregister(netdev, mlx5e_rep_setup_tc_cb_egdev,
+ 				     upriv);
+ 
++>>>>>>> 60bd4af814fe (net/mlx5e: Add ingress/egress indication for offloaded TC flows)
  err_neigh_cleanup:
  	mlx5e_rep_neigh_cleanup(rpriv);
  
@@@ -1131,15 -1154,21 +1164,24 @@@ err_destroy_netdev
  }
  
  static void
 -mlx5e_vport_rep_unload(struct mlx5_eswitch_rep *rep)
 +mlx5e_vport_rep_unload(struct mlx5_eswitch *esw, struct mlx5_eswitch_rep *rep)
  {
 -	struct mlx5e_rep_priv *rpriv = mlx5e_rep_to_rep_priv(rep);
 -	struct net_device *netdev = rpriv->netdev;
 +	struct net_device *netdev = rep->netdev;
  	struct mlx5e_priv *priv = netdev_priv(netdev);
 -	struct mlx5e_rep_priv *uplink_rpriv;
 +	struct mlx5e_rep_priv *rpriv = priv->ppriv;
  	void *ppriv = priv->ppriv;
 -	struct mlx5e_priv *upriv;
  
++<<<<<<< HEAD
 +	unregister_netdev(rep->netdev);
 +
++=======
+ 	unregister_netdev(netdev);
+ 	uplink_rpriv = mlx5_eswitch_get_uplink_priv(priv->mdev->priv.eswitch,
+ 						    REP_ETH);
+ 	upriv = netdev_priv(uplink_rpriv->netdev);
+ 	tc_setup_cb_egdev_unregister(netdev, mlx5e_rep_setup_tc_cb_egdev,
+ 				     upriv);
++>>>>>>> 60bd4af814fe (net/mlx5e: Add ingress/egress indication for offloaded TC flows)
  	mlx5e_rep_neigh_cleanup(rpriv);
  	mlx5e_detach_netdev(priv);
  	mlx5e_destroy_netdev(priv);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index a7435cbb0acb..c2f08c392788 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@ -61,12 +61,16 @@ struct mlx5_nic_flow_attr {
 	struct mlx5_flow_table	*hairpin_ft;
 };
 
+#define MLX5E_TC_FLOW_BASE (MLX5E_TC_LAST_EXPORTED_BIT + 1)
+
 enum {
-	MLX5E_TC_FLOW_ESWITCH	= BIT(0),
-	MLX5E_TC_FLOW_NIC	= BIT(1),
-	MLX5E_TC_FLOW_OFFLOADED	= BIT(2),
-	MLX5E_TC_FLOW_HAIRPIN	= BIT(3),
-	MLX5E_TC_FLOW_HAIRPIN_RSS = BIT(4),
+	MLX5E_TC_FLOW_INGRESS	= MLX5E_TC_INGRESS,
+	MLX5E_TC_FLOW_EGRESS	= MLX5E_TC_EGRESS,
+	MLX5E_TC_FLOW_ESWITCH	= BIT(MLX5E_TC_FLOW_BASE),
+	MLX5E_TC_FLOW_NIC	= BIT(MLX5E_TC_FLOW_BASE + 1),
+	MLX5E_TC_FLOW_OFFLOADED	= BIT(MLX5E_TC_FLOW_BASE + 2),
+	MLX5E_TC_FLOW_HAIRPIN	= BIT(MLX5E_TC_FLOW_BASE + 3),
+	MLX5E_TC_FLOW_HAIRPIN_RSS = BIT(MLX5E_TC_FLOW_BASE + 4),
 };
 
 struct mlx5e_tc_flow {
@@ -2557,8 +2561,20 @@ static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
 	return err;
 }
 
+static void get_flags(int flags, u8 *flow_flags)
+{
+	u8 __flow_flags = 0;
+
+	if (flags & MLX5E_TC_INGRESS)
+		__flow_flags |= MLX5E_TC_FLOW_INGRESS;
+	if (flags & MLX5E_TC_EGRESS)
+		__flow_flags |= MLX5E_TC_FLOW_EGRESS;
+
+	*flow_flags = __flow_flags;
+}
+
 int mlx5e_configure_flower(struct mlx5e_priv *priv,
-			   struct tc_cls_flower_offload *f)
+			   struct tc_cls_flower_offload *f, int flags)
 {
 	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 	struct mlx5e_tc_flow_parse_attr *parse_attr;
@@ -2567,11 +2583,13 @@ int mlx5e_configure_flower(struct mlx5e_priv *priv,
 	int attr_size, err = 0;
 	u8 flow_flags = 0;
 
+	get_flags(flags, &flow_flags);
+
 	if (esw && esw->mode == SRIOV_OFFLOADS) {
-		flow_flags = MLX5E_TC_FLOW_ESWITCH;
+		flow_flags |= MLX5E_TC_FLOW_ESWITCH;
 		attr_size  = sizeof(struct mlx5_esw_flow_attr);
 	} else {
-		flow_flags = MLX5E_TC_FLOW_NIC;
+		flow_flags |= MLX5E_TC_FLOW_NIC;
 		attr_size  = sizeof(struct mlx5_nic_flow_attr);
 	}
 
@@ -2630,7 +2648,7 @@ err_free:
 }
 
 int mlx5e_delete_flower(struct mlx5e_priv *priv,
-			struct tc_cls_flower_offload *f)
+			struct tc_cls_flower_offload *f, int flags)
 {
 	struct mlx5e_tc_flow *flow;
 	struct mlx5e_tc_table *tc = &priv->fs.tc;
@@ -2650,7 +2668,7 @@ int mlx5e_delete_flower(struct mlx5e_priv *priv,
 }
 
 int mlx5e_stats_flower(struct mlx5e_priv *priv,
-		       struct tc_cls_flower_offload *f)
+		       struct tc_cls_flower_offload *f, int flags)
 {
 	struct mlx5e_tc_table *tc = &priv->fs.tc;
 	struct mlx5e_tc_flow *flow;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index c14c263a739b..2255345c2e18 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -38,16 +38,23 @@
 #define MLX5E_TC_FLOW_ID_MASK 0x0000ffff
 
 #ifdef CONFIG_MLX5_ESWITCH
+
+enum {
+	MLX5E_TC_INGRESS = BIT(0),
+	MLX5E_TC_EGRESS  = BIT(1),
+	MLX5E_TC_LAST_EXPORTED_BIT = 1,
+};
+
 int mlx5e_tc_init(struct mlx5e_priv *priv);
 void mlx5e_tc_cleanup(struct mlx5e_priv *priv);
 
 int mlx5e_configure_flower(struct mlx5e_priv *priv,
-			   struct tc_cls_flower_offload *f);
+			   struct tc_cls_flower_offload *f, int flags);
 int mlx5e_delete_flower(struct mlx5e_priv *priv,
-			struct tc_cls_flower_offload *f);
+			struct tc_cls_flower_offload *f, int flags);
 
 int mlx5e_stats_flower(struct mlx5e_priv *priv,
-		       struct tc_cls_flower_offload *f);
+		       struct tc_cls_flower_offload *f, int flags);
 
 struct mlx5e_encap_entry;
 void mlx5e_tc_encap_flows_add(struct mlx5e_priv *priv,
