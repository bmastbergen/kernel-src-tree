PCI: pciehp: Rename host->native_hotplug to host->native_pcie_hotplug

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [pci] pciehp: Rename host->native_hotplug to host->native_pcie_hotplug (Jarod Wilson) [1495223]
Rebuild_FUZZ: 96.24%
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 9310f0dc1c6430ca9e370a8341bea9f5dc85f40b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9310f0dc.failed

Rename host->native_hotplug to host->native_pcie_hotplug to make room for a
similar flag for SHPC hotplug.

	Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
[bhelgaas: split to separate patch]
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 9310f0dc1c6430ca9e370a8341bea9f5dc85f40b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/pci_root.c
#	drivers/pci/pcie/portdrv_core.c
#	drivers/pci/probe.c
#	include/linux/pci.h
diff --cc drivers/acpi/pci_root.c
index 6aac47a89714,032a578da5d4..000000000000
--- a/drivers/acpi/pci_root.c
+++ b/drivers/acpi/pci_root.c
@@@ -856,9 -900,17 +856,20 @@@ struct pci_bus *acpi_pci_root_create(st
  	if (!bus)
  		goto out_release_info;
  
++<<<<<<< HEAD
++=======
+ 	host_bridge = to_pci_host_bridge(bus->bridge);
+ 	if (!(root->osc_control_set & OSC_PCI_EXPRESS_NATIVE_HP_CONTROL))
+ 		host_bridge->native_pcie_hotplug = 0;
+ 	if (!(root->osc_control_set & OSC_PCI_EXPRESS_AER_CONTROL))
+ 		host_bridge->native_aer = 0;
+ 	if (!(root->osc_control_set & OSC_PCI_EXPRESS_PME_CONTROL))
+ 		host_bridge->native_pme = 0;
+ 
++>>>>>>> 9310f0dc1c64 (PCI: pciehp: Rename host->native_hotplug to host->native_pcie_hotplug)
  	pci_scan_child_bus(bus);
 -	pci_set_host_bridge_release(host_bridge, acpi_pci_root_release_info,
 -				    info);
 +	pci_set_host_bridge_release(to_pci_host_bridge(bus->bridge),
 +				    acpi_pci_root_release_info, info);
  	if (node != NUMA_NO_NODE)
  		dev_printk(KERN_DEBUG, &bus->dev, "on NUMA node %d\n", node);
  	return bus;
diff --cc drivers/pci/pcie/portdrv_core.c
index b7a5dc54a88e,6cb30aec2452..000000000000
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@@ -189,20 -195,13 +189,25 @@@ static int pcie_init_service_irqs(struc
   */
  static int get_port_device_capability(struct pci_dev *dev)
  {
 -	struct pci_host_bridge *host = pci_find_host_bridge(dev->bus);
  	int services = 0;
 +	int cap_mask = 0;
  
++<<<<<<< HEAD
 +	cap_mask = PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP
 +			| PCIE_PORT_SERVICE_VC | PCIE_PORT_SERVICE_DPC;
 +	if (pci_aer_available())
 +		cap_mask |= PCIE_PORT_SERVICE_AER;
 +
 +	if (pcie_ports_auto)
 +		pcie_port_platform_notify(dev, &cap_mask);
 +
 +	/* Hot-Plug Capable */
 +	if ((cap_mask & PCIE_PORT_SERVICE_HP) && dev->is_hotplug_bridge) {
++=======
+ 	if (dev->is_hotplug_bridge &&
+ 	    (pcie_ports_native || host->native_pcie_hotplug)) {
++>>>>>>> 9310f0dc1c64 (PCI: pciehp: Rename host->native_hotplug to host->native_pcie_hotplug)
  		services |= PCIE_PORT_SERVICE_HP;
 -
  		/*
  		 * Disable hot-plug interrupts in case they have been enabled
  		 * by the BIOS and the hot-plug service driver is not loaded.
diff --cc drivers/pci/probe.c
index 60cc4d4c4ea4,eba2b17d2d80..000000000000
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@@ -557,7 -526,57 +557,59 @@@ static void pci_release_host_bridge_dev
  
  	if (bridge->release_fn)
  		bridge->release_fn(bridge);
 -}
  
++<<<<<<< HEAD
++=======
+ static void pci_release_host_bridge_dev(struct device *dev)
+ {
+ 	devm_pci_release_host_bridge_dev(dev);
+ 	pci_free_host_bridge(to_pci_host_bridge(dev));
+ }
+ 
+ struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
+ {
+ 	struct pci_host_bridge *bridge;
+ 
+ 	bridge = kzalloc(sizeof(*bridge) + priv, GFP_KERNEL);
+ 	if (!bridge)
+ 		return NULL;
+ 
+ 	INIT_LIST_HEAD(&bridge->windows);
+ 	bridge->dev.release = pci_release_host_bridge_dev;
+ 
+ 	/*
+ 	 * We assume we can manage these PCIe features.  Some systems may
+ 	 * reserve these for use by the platform itself, e.g., an ACPI BIOS
+ 	 * may implement its own AER handling and use _OSC to prevent the
+ 	 * OS from interfering.
+ 	 */
+ 	bridge->native_aer = 1;
+ 	bridge->native_pcie_hotplug = 1;
+ 	bridge->native_pme = 1;
+ 
+ 	return bridge;
+ }
+ EXPORT_SYMBOL(pci_alloc_host_bridge);
+ 
+ struct pci_host_bridge *devm_pci_alloc_host_bridge(struct device *dev,
+ 						   size_t priv)
+ {
+ 	struct pci_host_bridge *bridge;
+ 
+ 	bridge = devm_kzalloc(dev, sizeof(*bridge) + priv, GFP_KERNEL);
+ 	if (!bridge)
+ 		return NULL;
+ 
+ 	INIT_LIST_HEAD(&bridge->windows);
+ 	bridge->dev.release = devm_pci_release_host_bridge_dev;
+ 
+ 	return bridge;
+ }
+ EXPORT_SYMBOL(devm_pci_alloc_host_bridge);
+ 
+ void pci_free_host_bridge(struct pci_host_bridge *bridge)
+ {
++>>>>>>> 9310f0dc1c64 (PCI: pciehp: Rename host->native_hotplug to host->native_pcie_hotplug)
  	pci_free_resource_list(&bridge->windows);
  
  	kfree(bridge);
diff --cc include/linux/pci.h
index 2d20a9a169fc,30ec7e86af55..000000000000
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@@ -437,12 -460,22 +437,22 @@@ static inline int pci_channel_offline(s
  }
  
  struct pci_host_bridge {
 -	struct device	dev;
 -	struct pci_bus	*bus;		/* Root bus */
 -	struct pci_ops	*ops;
 -	void		*sysdata;
 -	int		busnr;
 +	struct device dev;
 +	struct pci_bus *bus;		/* root bus */
  	struct list_head windows;	/* resource_entry */
 -	u8 (*swizzle_irq)(struct pci_dev *, u8 *); /* Platform IRQ swizzler */
 -	int (*map_irq)(const struct pci_dev *, u8, u8);
  	void (*release_fn)(struct pci_host_bridge *);
++<<<<<<< HEAD
 +	void *release_data;
 +	unsigned int ignore_reset_delay:1;	/* for entire hierarchy */
++=======
+ 	void		*release_data;
+ 	struct msi_controller *msi;
+ 	unsigned int	ignore_reset_delay:1;	/* For entire hierarchy */
+ 	unsigned int	no_ext_tags:1;		/* No Extended Tags */
+ 	unsigned int	native_aer:1;		/* OS may use PCIe AER */
+ 	unsigned int	native_pcie_hotplug:1;	/* OS may use PCIe hotplug */
+ 	unsigned int	native_pme:1;		/* OS may use PCIe PME */
++>>>>>>> 9310f0dc1c64 (PCI: pciehp: Rename host->native_hotplug to host->native_pcie_hotplug)
  	/* Resource alignment requirements */
  	resource_size_t (*align_resource)(struct pci_dev *dev,
  			const struct resource *res,
* Unmerged path drivers/acpi/pci_root.c
* Unmerged path drivers/pci/pcie/portdrv_core.c
* Unmerged path drivers/pci/probe.c
* Unmerged path include/linux/pci.h
