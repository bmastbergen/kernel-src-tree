drm/nouveau/gr/gf100-: port zcull tile mapping calculations from NVGPU

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ben Skeggs <bskeggs@redhat.com>
commit d00ffc0c403784c9f88d8da357f9f33f855289a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d00ffc0c.failed

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit d00ffc0c403784c9f88d8da357f9f33f855289a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c
#	drivers/gpu/drm/nouveau/nvkm/engine/gr/gf117.c
diff --cc drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c
index 7601140b0017,f6d884156b75..000000000000
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c
@@@ -1909,62 -1959,150 +1909,78 @@@ gf100_gr_new_(const struct gf100_gr_fun
  	return 0;
  }
  
 -void
 -gf100_gr_init_400054(struct gf100_gr *gr)
 -{
 -	nvkm_wr32(gr->base.engine.subdev.device, 0x400054, 0x34ce3464);
 -}
 -
 -void
 -gf100_gr_init_shader_exceptions(struct gf100_gr *gr, int gpc, int tpc)
 -{
 -	struct nvkm_device *device = gr->base.engine.subdev.device;
 -	nvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x644), 0x001ffffe);
 -	nvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x64c), 0x0000000f);
 -}
 -
 -void
 -gf100_gr_init_tex_hww_esr(struct gf100_gr *gr, int gpc, int tpc)
 -{
 -	struct nvkm_device *device = gr->base.engine.subdev.device;
 -	nvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x224), 0xc0000000);
 -}
 -
 -void
 -gf100_gr_init_419eb4(struct gf100_gr *gr)
 -{
 -	struct nvkm_device *device = gr->base.engine.subdev.device;
 -	nvkm_mask(device, 0x419eb4, 0x00001000, 0x00001000);
 -}
 -
 -void
 -gf100_gr_init_419cc0(struct gf100_gr *gr)
 +int
 +gf100_gr_init(struct gf100_gr *gr)
  {
  	struct nvkm_device *device = gr->base.engine.subdev.device;
 -	int gpc, tpc;
 -
 -	nvkm_mask(device, 0x419cc0, 0x00000008, 0x00000008);
 -
 -	for (gpc = 0; gpc < gr->gpc_nr; gpc++) {
 -		for (tpc = 0; tpc < gr->tpc_nr[gpc]; tpc++)
 -			nvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x48c), 0xc0000000);
 -	}
 -}
 -
 -void
 -gf100_gr_init_40601c(struct gf100_gr *gr)
 -{
 -	nvkm_wr32(gr->base.engine.subdev.device, 0x40601c, 0xc0000000);
 -}
 +	struct nvkm_fb *fb = device->fb;
 +	const u32 magicgpc918 = DIV_ROUND_UP(0x00800000, gr->tpc_total);
++<<<<<<< HEAD
 +	u32 data[TPC_MAX / 8] = {};
 +	u8  tpcnr[GPC_MAX];
 +	int gpc, tpc, rop;
 +	int i;
  
 -void
 -gf100_gr_init_fecs_exceptions(struct gf100_gr *gr)
 -{
 -	const u32 data = gr->firmware ? 0x000e0000 : 0x000e0001;
 -	nvkm_wr32(gr->base.engine.subdev.device, 0x409c24, data);
 -}
 +	nvkm_wr32(device, GPC_BCAST(0x0880), 0x00000000);
 +	nvkm_wr32(device, GPC_BCAST(0x08a4), 0x00000000);
 +	nvkm_wr32(device, GPC_BCAST(0x0888), 0x00000000);
 +	nvkm_wr32(device, GPC_BCAST(0x088c), 0x00000000);
 +	nvkm_wr32(device, GPC_BCAST(0x0890), 0x00000000);
 +	nvkm_wr32(device, GPC_BCAST(0x0894), 0x00000000);
 +	nvkm_wr32(device, GPC_BCAST(0x08b4), nvkm_memory_addr(fb->mmu_wr) >> 8);
 +	nvkm_wr32(device, GPC_BCAST(0x08b8), nvkm_memory_addr(fb->mmu_rd) >> 8);
  
 -void
 -gf100_gr_init_gpc_mmu(struct gf100_gr *gr)
 -{
 -	struct nvkm_device *device = gr->base.engine.subdev.device;
 -	struct nvkm_fb *fb = device->fb;
 +	if (gr->fuc_sw_nonctx)
 +		gf100_gr_mmio(gr, gr->fuc_sw_nonctx);
 +	else
 +		gf100_gr_mmio(gr, gr->func->mmio);
  
 -	nvkm_wr32(device, 0x418880, nvkm_rd32(device, 0x100c80) & 0x00000001);
 -	nvkm_wr32(device, 0x4188a4, 0x03000000);
 -	nvkm_wr32(device, 0x418888, 0x00000000);
 -	nvkm_wr32(device, 0x41888c, 0x00000000);
 -	nvkm_wr32(device, 0x418890, 0x00000000);
 -	nvkm_wr32(device, 0x418894, 0x00000000);
 -	nvkm_wr32(device, 0x4188b4, nvkm_memory_addr(fb->mmu_wr) >> 8);
 -	nvkm_wr32(device, 0x4188b8, nvkm_memory_addr(fb->mmu_rd) >> 8);
 -}
 +	nvkm_mask(device, TPC_UNIT(0, 0, 0x05c), 0x00000001, 0x00000001);
  
 -void
 -gf100_gr_init_num_active_ltcs(struct gf100_gr *gr)
 -{
 -	struct nvkm_device *device = gr->base.engine.subdev.device;
 -	nvkm_wr32(device, GPC_BCAST(0x08ac), nvkm_rd32(device, 0x100800));
 -}
 +	memcpy(tpcnr, gr->tpc_nr, sizeof(gr->tpc_nr));
 +	for (i = 0, gpc = -1; i < gr->tpc_total; i++) {
 +		do {
 +			gpc = (gpc + 1) % gr->gpc_nr;
 +		} while (!tpcnr[gpc]);
 +		tpc = gr->tpc_nr[gpc] - tpcnr[gpc]--;
  
 -void
 -gf100_gr_init_zcull(struct gf100_gr *gr)
 -{
 -	struct nvkm_device *device = gr->base.engine.subdev.device;
 -	const u32 magicgpc918 = DIV_ROUND_UP(0x00800000, gr->tpc_total);
 +		data[i / 8] |= tpc << ((i % 8) * 4);
++=======
+ 	const u8 tile_nr = ALIGN(gr->tpc_total, 32);
+ 	u8 bank[GPC_MAX] = {}, gpc, i, j;
+ 	u32 data;
+ 
+ 	for (i = 0; i < tile_nr; i += 8) {
+ 		for (data = 0, j = 0; j < 8 && i + j < gr->tpc_total; j++) {
+ 			data |= bank[gr->tile[i + j]] << (j * 4);
+ 			bank[gr->tile[i + j]]++;
+ 		}
+ 		nvkm_wr32(device, GPC_BCAST(0x0980 + ((i / 8) * 4)), data);
++>>>>>>> d00ffc0c4037 (drm/nouveau/gr/gf100-: port zcull tile mapping calculations from NVGPU)
  	}
  
- 	nvkm_wr32(device, GPC_BCAST(0x0980), data[0]);
- 	nvkm_wr32(device, GPC_BCAST(0x0984), data[1]);
- 	nvkm_wr32(device, GPC_BCAST(0x0988), data[2]);
- 	nvkm_wr32(device, GPC_BCAST(0x098c), data[3]);
+ 	for (gpc = 0; gpc < gr->gpc_nr; gpc++) {
+ 		nvkm_wr32(device, GPC_UNIT(gpc, 0x0914),
+ 			  gr->screen_tile_row_offset << 8 | gr->tpc_nr[gpc]);
+ 		nvkm_wr32(device, GPC_UNIT(gpc, 0x0910), 0x00040000 |
+ 							 gr->tpc_total);
+ 		nvkm_wr32(device, GPC_UNIT(gpc, 0x0918), magicgpc918);
+ 	}
  
 -	nvkm_wr32(device, GPC_BCAST(0x1bd4), magicgpc918);
 -}
 -
 -void
 -gf100_gr_init_vsc_stream_master(struct gf100_gr *gr)
 -{
 -	struct nvkm_device *device = gr->base.engine.subdev.device;
 -	nvkm_mask(device, TPC_UNIT(0, 0, 0x05c), 0x00000001, 0x00000001);
 -}
 -
 -int
 -gf100_gr_init(struct gf100_gr *gr)
 -{
 -	struct nvkm_device *device = gr->base.engine.subdev.device;
 -	int gpc, tpc, rop;
 -
 -	gr->func->init_gpc_mmu(gr);
 +	for (gpc = 0; gpc < gr->gpc_nr; gpc++) {
 +		nvkm_wr32(device, GPC_UNIT(gpc, 0x0914),
 +			  gr->screen_tile_row_offset << 8 | gr->tpc_nr[gpc]);
 +		nvkm_wr32(device, GPC_UNIT(gpc, 0x0910), 0x00040000 |
 +							 gr->tpc_total);
 +		nvkm_wr32(device, GPC_UNIT(gpc, 0x0918), magicgpc918);
 +	}
  
 -	if (gr->fuc_sw_nonctx)
 -		gf100_gr_mmio(gr, gr->fuc_sw_nonctx);
 +	if (device->chipset != 0xd7)
 +		nvkm_wr32(device, GPC_BCAST(0x1bd4), magicgpc918);
  	else
 -		gf100_gr_mmio(gr, gr->func->mmio);
 +		nvkm_wr32(device, GPC_BCAST(0x3fd4), magicgpc918);
  
 -	if (gr->func->init_r405a14)
 -		gr->func->init_r405a14(gr);
 -
 -	if (gr->func->clkgate_pack)
 -		nvkm_therm_clkgate_init(device->therm, gr->func->clkgate_pack);
 -
 -	if (gr->func->init_bios)
 -		gr->func->init_bios(gr);
 -
 -	gr->func->init_vsc_stream_master(gr);
 -	gr->func->init_zcull(gr);
 -	gr->func->init_num_active_ltcs(gr);
 -	if (gr->func->init_rop_active_fbps)
 -		gr->func->init_rop_active_fbps(gr);
 -	if (gr->func->init_bios_2)
 -		gr->func->init_bios_2(gr);
 -	if (gr->func->init_swdx_pes_mask)
 -		gr->func->init_swdx_pes_mask(gr);
 +	nvkm_wr32(device, GPC_BCAST(0x08ac), nvkm_rd32(device, 0x100800));
  
  	nvkm_wr32(device, 0x400500, 0x00010001);
  
diff --cc drivers/gpu/drm/nouveau/nvkm/engine/gr/gf117.c
index 0124e468086e,d6831b41df39..000000000000
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf117.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf117.c
@@@ -120,9 -120,50 +120,40 @@@ gf117_gr_gpccs_ucode = 
  	.data.size = sizeof(gf117_grgpc_data),
  };
  
++<<<<<<< HEAD
++=======
+ void
+ gf117_gr_init_zcull(struct gf100_gr *gr)
+ {
+ 	struct nvkm_device *device = gr->base.engine.subdev.device;
+ 	const u32 magicgpc918 = DIV_ROUND_UP(0x00800000, gr->tpc_total);
+ 	const u8 tile_nr = ALIGN(gr->tpc_total, 32);
+ 	u8 bank[GPC_MAX] = {}, gpc, i, j;
+ 	u32 data;
+ 
+ 	for (i = 0; i < tile_nr; i += 8) {
+ 		for (data = 0, j = 0; j < 8 && i + j < gr->tpc_total; j++) {
+ 			data |= bank[gr->tile[i + j]] << (j * 4);
+ 			bank[gr->tile[i + j]]++;
+ 		}
+ 		nvkm_wr32(device, GPC_BCAST(0x0980 + ((i / 8) * 4)), data);
+ 	}
+ 
+ 	for (gpc = 0; gpc < gr->gpc_nr; gpc++) {
+ 		nvkm_wr32(device, GPC_UNIT(gpc, 0x0914),
+ 			  gr->screen_tile_row_offset << 8 | gr->tpc_nr[gpc]);
+ 		nvkm_wr32(device, GPC_UNIT(gpc, 0x0910), 0x00040000 |
+ 							 gr->tpc_total);
+ 		nvkm_wr32(device, GPC_UNIT(gpc, 0x0918), magicgpc918);
+ 	}
+ 
+ 	nvkm_wr32(device, GPC_BCAST(0x3fd4), magicgpc918);
+ }
+ 
++>>>>>>> d00ffc0c4037 (drm/nouveau/gr/gf100-: port zcull tile mapping calculations from NVGPU)
  static const struct gf100_gr_func
  gf117_gr = {
 -	.oneinit_tiles = gf100_gr_oneinit_tiles,
  	.init = gf100_gr_init,
 -	.init_gpc_mmu = gf100_gr_init_gpc_mmu,
 -	.init_vsc_stream_master = gf100_gr_init_vsc_stream_master,
 -	.init_zcull = gf117_gr_init_zcull,
 -	.init_num_active_ltcs = gf100_gr_init_num_active_ltcs,
 -	.init_fecs_exceptions = gf100_gr_init_fecs_exceptions,
 -	.init_40601c = gf100_gr_init_40601c,
 -	.init_419cc0 = gf100_gr_init_419cc0,
 -	.init_419eb4 = gf100_gr_init_419eb4,
 -	.init_tex_hww_esr = gf100_gr_init_tex_hww_esr,
 -	.init_shader_exceptions = gf100_gr_init_shader_exceptions,
 -	.init_400054 = gf100_gr_init_400054,
 -	.trap_mp = gf100_gr_trap_mp,
  	.mmio = gf117_gr_pack_mmio,
  	.fecs.ucode = &gf117_gr_fecs_ucode,
  	.gpccs.ucode = &gf117_gr_gpccs_ucode,
* Unmerged path drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c
* Unmerged path drivers/gpu/drm/nouveau/nvkm/engine/gr/gf117.c
