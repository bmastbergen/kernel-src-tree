net/mlx5e: Set port trust mode to PCP as default

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Set port trust mode to PCP as default (Alaa Hleihel) [1610866]
Rebuild_FUZZ: 95.65%
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit 2e8e70d249e8c5c79bf88bbb36bb68154ab15471
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/2e8e70d2.failed

The hairpin offload code has dependency on the trust mode being PCP.

Hence we should set PCP as the default for handling cases where we are
disallowed to read the trust mode from the FW, or failed to initialize it.

Fixes: 106be53b6b0a ('net/mlx5e: Set per priority hairpin pairs')
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Reviewed-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 2e8e70d249e8c5c79bf88bbb36bb68154ab15471)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
index 3962e6e9d54e,e33afa8d2417..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
@@@ -833,6 -1063,133 +833,136 @@@ static void mlx5e_ets_init(struct mlx5e
  			   "%s, Failed to init ETS: %d\n", __func__, err);
  }
  
++<<<<<<< HEAD
++=======
+ enum {
+ 	INIT,
+ 	DELETE,
+ };
+ 
+ static void mlx5e_dcbnl_dscp_app(struct mlx5e_priv *priv, int action)
+ {
+ 	struct dcb_app temp;
+ 	int i;
+ 
+ 	if (!MLX5_CAP_GEN(priv->mdev, vport_group_manager))
+ 		return;
+ 
+ 	if (!MLX5_DSCP_SUPPORTED(priv->mdev))
+ 		return;
+ 
+ 	/* No SEL_DSCP entry in non DSCP state */
+ 	if (priv->dcbx_dp.trust_state != MLX5_QPTS_TRUST_DSCP)
+ 		return;
+ 
+ 	temp.selector = IEEE_8021QAZ_APP_SEL_DSCP;
+ 	for (i = 0; i < MLX5E_MAX_DSCP; i++) {
+ 		temp.protocol = i;
+ 		temp.priority = priv->dcbx_dp.dscp2prio[i];
+ 		if (action == INIT)
+ 			dcb_ieee_setapp(priv->netdev, &temp);
+ 		else
+ 			dcb_ieee_delapp(priv->netdev, &temp);
+ 	}
+ 
+ 	priv->dcbx.dscp_app_cnt = (action == INIT) ? MLX5E_MAX_DSCP : 0;
+ }
+ 
+ void mlx5e_dcbnl_init_app(struct mlx5e_priv *priv)
+ {
+ 	mlx5e_dcbnl_dscp_app(priv, INIT);
+ }
+ 
+ void mlx5e_dcbnl_delete_app(struct mlx5e_priv *priv)
+ {
+ 	mlx5e_dcbnl_dscp_app(priv, DELETE);
+ }
+ 
+ static void mlx5e_trust_update_tx_min_inline_mode(struct mlx5e_priv *priv,
+ 						  struct mlx5e_params *params)
+ {
+ 	params->tx_min_inline_mode = mlx5e_params_calculate_tx_min_inline(priv->mdev);
+ 	if (priv->dcbx_dp.trust_state == MLX5_QPTS_TRUST_DSCP &&
+ 	    params->tx_min_inline_mode == MLX5_INLINE_MODE_L2)
+ 		params->tx_min_inline_mode = MLX5_INLINE_MODE_IP;
+ }
+ 
+ static void mlx5e_trust_update_sq_inline_mode(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_channels new_channels = {};
+ 
+ 	mutex_lock(&priv->state_lock);
+ 
+ 	new_channels.params = priv->channels.params;
+ 	mlx5e_trust_update_tx_min_inline_mode(priv, &new_channels.params);
+ 
+ 	if (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {
+ 		priv->channels.params = new_channels.params;
+ 		goto out;
+ 	}
+ 
+ 	/* Skip if tx_min_inline is the same */
+ 	if (new_channels.params.tx_min_inline_mode ==
+ 	    priv->channels.params.tx_min_inline_mode)
+ 		goto out;
+ 
+ 	if (mlx5e_open_channels(priv, &new_channels))
+ 		goto out;
+ 	mlx5e_switch_priv_channels(priv, &new_channels, NULL);
+ 
+ out:
+ 	mutex_unlock(&priv->state_lock);
+ }
+ 
+ static int mlx5e_set_trust_state(struct mlx5e_priv *priv, u8 trust_state)
+ {
+ 	int err;
+ 
+ 	err =  mlx5_set_trust_state(priv->mdev, trust_state);
+ 	if (err)
+ 		return err;
+ 	priv->dcbx_dp.trust_state = trust_state;
+ 	mlx5e_trust_update_sq_inline_mode(priv);
+ 
+ 	return err;
+ }
+ 
+ static int mlx5e_set_dscp2prio(struct mlx5e_priv *priv, u8 dscp, u8 prio)
+ {
+ 	int err;
+ 
+ 	err = mlx5_set_dscp2prio(priv->mdev, dscp, prio);
+ 	if (err)
+ 		return err;
+ 
+ 	priv->dcbx_dp.dscp2prio[dscp] = prio;
+ 	return err;
+ }
+ 
+ static int mlx5e_trust_initialize(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	int err;
+ 
+ 	priv->dcbx_dp.trust_state = MLX5_QPTS_TRUST_PCP;
+ 
+ 	if (!MLX5_DSCP_SUPPORTED(mdev))
+ 		return 0;
+ 
+ 	err = mlx5_query_trust_state(priv->mdev, &priv->dcbx_dp.trust_state);
+ 	if (err)
+ 		return err;
+ 
+ 	mlx5e_trust_update_tx_min_inline_mode(priv, &priv->channels.params);
+ 
+ 	err = mlx5_query_dscp2prio(priv->mdev, priv->dcbx_dp.dscp2prio);
+ 	if (err)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 2e8e70d249e8 (net/mlx5e: Set port trust mode to PCP as default)
  void mlx5e_dcbnl_initialize(struct mlx5e_priv *priv)
  {
  	struct mlx5e_dcbx *dcbx = &priv->dcbx;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
