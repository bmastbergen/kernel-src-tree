x86/speculation: Handle HT correctly on AMD

jira LE-1907
cve CVE-2018-3639
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] speculation: Handle HT correctly on AMD (Waiman Long) [1584569] {CVE-2018-3639}
Rebuild_FUZZ: 95.12%
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 1f50ddb4f4189243c05926b842dc1a0332195f31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1f50ddb4.failed

The AMD64_LS_CFG MSR is a per core MSR on Family 17H CPUs. That means when
hyperthreading is enabled the SSBD bit toggle needs to take both cores into
account. Otherwise the following situation can happen:

CPU0		CPU1

disable SSB
		disable SSB
		enable  SSB <- Enables it for the Core, i.e. for CPU0 as well

So after the SSB enable on CPU1 the task on CPU0 runs with SSB enabled
again.

On Intel the SSBD control is per core as well, but the synchronization
logic is implemented behind the per thread SPEC_CTRL MSR. It works like
this:

  CORE_SPEC_CTRL = THREAD0_SPEC_CTRL | THREAD1_SPEC_CTRL

i.e. if one of the threads enables a mitigation then this affects both and
the mitigation is only disabled in the core when both threads disabled it.

Add the necessary synchronization logic for AMD family 17H. Unfortunately
that requires a spinlock to serialize the access to the MSR, but the locks
are only shared between siblings.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
(cherry picked from commit 1f50ddb4f4189243c05926b842dc1a0332195f31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/spec-ctrl.h
#	arch/x86/kernel/process.c
#	arch/x86/kernel/smpboot.c
diff --cc arch/x86/kernel/process.c
index f741d66041de,d6fe8648d3f6..000000000000
--- a/arch/x86/kernel/process.c
+++ b/arch/x86/kernel/process.c
@@@ -237,7 -277,173 +237,156 @@@ void __switch_to_xtra(struct task_struc
  		 */
  		memset(tss->io_bitmap, 0xff, prev->io_bitmap_max);
  	}
++<<<<<<< HEAD
++=======
+ }
+ 
+ #ifdef CONFIG_SMP
+ 
+ struct ssb_state {
+ 	struct ssb_state	*shared_state;
+ 	raw_spinlock_t		lock;
+ 	unsigned int		disable_state;
+ 	unsigned long		local_state;
+ };
+ 
+ #define LSTATE_SSB	0
+ 
+ static DEFINE_PER_CPU(struct ssb_state, ssb_state);
+ 
+ void speculative_store_bypass_ht_init(void)
+ {
+ 	struct ssb_state *st = this_cpu_ptr(&ssb_state);
+ 	unsigned int this_cpu = smp_processor_id();
+ 	unsigned int cpu;
+ 
+ 	st->local_state = 0;
+ 
+ 	/*
+ 	 * Shared state setup happens once on the first bringup
+ 	 * of the CPU. It's not destroyed on CPU hotunplug.
+ 	 */
+ 	if (st->shared_state)
+ 		return;
+ 
+ 	raw_spin_lock_init(&st->lock);
+ 
+ 	/*
+ 	 * Go over HT siblings and check whether one of them has set up the
+ 	 * shared state pointer already.
+ 	 */
+ 	for_each_cpu(cpu, topology_sibling_cpumask(this_cpu)) {
+ 		if (cpu == this_cpu)
+ 			continue;
+ 
+ 		if (!per_cpu(ssb_state, cpu).shared_state)
+ 			continue;
+ 
+ 		/* Link it to the state of the sibling: */
+ 		st->shared_state = per_cpu(ssb_state, cpu).shared_state;
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * First HT sibling to come up on the core.  Link shared state of
+ 	 * the first HT sibling to itself. The siblings on the same core
+ 	 * which come up later will see the shared state pointer and link
+ 	 * themself to the state of this CPU.
+ 	 */
+ 	st->shared_state = st;
+ }
+ 
+ /*
+  * Logic is: First HT sibling enables SSBD for both siblings in the core
+  * and last sibling to disable it, disables it for the whole core. This how
+  * MSR_SPEC_CTRL works in "hardware":
+  *
+  *  CORE_SPEC_CTRL = THREAD0_SPEC_CTRL | THREAD1_SPEC_CTRL
+  */
+ static __always_inline void amd_set_core_ssb_state(unsigned long tifn)
+ {
+ 	struct ssb_state *st = this_cpu_ptr(&ssb_state);
+ 	u64 msr = x86_amd_ls_cfg_base;
+ 
+ 	if (!static_cpu_has(X86_FEATURE_ZEN)) {
+ 		msr |= ssbd_tif_to_amd_ls_cfg(tifn);
+ 		wrmsrl(MSR_AMD64_LS_CFG, msr);
+ 		return;
+ 	}
+ 
+ 	if (tifn & _TIF_SSBD) {
+ 		/*
+ 		 * Since this can race with prctl(), block reentry on the
+ 		 * same CPU.
+ 		 */
+ 		if (__test_and_set_bit(LSTATE_SSB, &st->local_state))
+ 			return;
+ 
+ 		msr |= x86_amd_ls_cfg_ssbd_mask;
+ 
+ 		raw_spin_lock(&st->shared_state->lock);
+ 		/* First sibling enables SSBD: */
+ 		if (!st->shared_state->disable_state)
+ 			wrmsrl(MSR_AMD64_LS_CFG, msr);
+ 		st->shared_state->disable_state++;
+ 		raw_spin_unlock(&st->shared_state->lock);
+ 	} else {
+ 		if (!__test_and_clear_bit(LSTATE_SSB, &st->local_state))
+ 			return;
+ 
+ 		raw_spin_lock(&st->shared_state->lock);
+ 		st->shared_state->disable_state--;
+ 		if (!st->shared_state->disable_state)
+ 			wrmsrl(MSR_AMD64_LS_CFG, msr);
+ 		raw_spin_unlock(&st->shared_state->lock);
+ 	}
+ }
+ #else
+ static __always_inline void amd_set_core_ssb_state(unsigned long tifn)
+ {
+ 	u64 msr = x86_amd_ls_cfg_base | ssbd_tif_to_amd_ls_cfg(tifn);
+ 
+ 	wrmsrl(MSR_AMD64_LS_CFG, msr);
+ }
+ #endif
+ 
+ static __always_inline void intel_set_ssb_state(unsigned long tifn)
+ {
+ 	u64 msr = x86_spec_ctrl_base | ssbd_tif_to_spec_ctrl(tifn);
+ 
+ 	wrmsrl(MSR_IA32_SPEC_CTRL, msr);
+ }
+ 
+ static __always_inline void __speculative_store_bypass_update(unsigned long tifn)
+ {
+ 	if (static_cpu_has(X86_FEATURE_LS_CFG_SSBD))
+ 		amd_set_core_ssb_state(tifn);
+ 	else
+ 		intel_set_ssb_state(tifn);
+ }
+ 
+ void speculative_store_bypass_update(void)
+ {
+ 	preempt_disable();
+ 	__speculative_store_bypass_update(current_thread_info()->flags);
+ 	preempt_enable();
+ }
+ 
+ void __switch_to_xtra(struct task_struct *prev_p, struct task_struct *next_p,
+ 		      struct tss_struct *tss)
+ {
+ 	struct thread_struct *prev, *next;
+ 	unsigned long tifp, tifn;
+ 
+ 	prev = &prev_p->thread;
+ 	next = &next_p->thread;
+ 
+ 	tifn = READ_ONCE(task_thread_info(next_p)->flags);
+ 	tifp = READ_ONCE(task_thread_info(prev_p)->flags);
+ 	switch_to_bitmap(tss, prev, next, tifp, tifn);
+ 
++>>>>>>> 1f50ddb4f418 (x86/speculation: Handle HT correctly on AMD)
  	propagate_user_return_notify(prev_p, next_p);
 -
 -	if ((tifp & _TIF_BLOCKSTEP || tifn & _TIF_BLOCKSTEP) &&
 -	    arch_has_block_step()) {
 -		unsigned long debugctl, msk;
 -
 -		rdmsrl(MSR_IA32_DEBUGCTLMSR, debugctl);
 -		debugctl &= ~DEBUGCTLMSR_BTF;
 -		msk = tifn & _TIF_BLOCKSTEP;
 -		debugctl |= (msk >> TIF_BLOCKSTEP) << DEBUGCTLMSR_BTF_SHIFT;
 -		wrmsrl(MSR_IA32_DEBUGCTLMSR, debugctl);
 -	}
 -
 -	if ((tifp ^ tifn) & _TIF_NOTSC)
 -		cr4_toggle_bits_irqsoff(X86_CR4_TSD);
 -
 -	if ((tifp ^ tifn) & _TIF_NOCPUID)
 -		set_cpuid_faulting(!!(tifn & _TIF_NOCPUID));
 -
 -	if ((tifp ^ tifn) & _TIF_SSBD)
 -		__speculative_store_bypass_update(tifn);
  }
  
  /*
diff --cc arch/x86/kernel/smpboot.c
index 331c8872578a,9dd324ae4832..000000000000
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@@ -73,16 -74,12 +73,24 @@@
  #include <asm/setup.h>
  #include <asm/uv/uv.h>
  #include <linux/mc146818rtc.h>
 +
 +#include <asm/smpboot_hooks.h>
  #include <asm/i8259.h>
++<<<<<<< HEAD
 +
 +#include <asm/realmode.h>
 +
 +#include <asm/hypervisor.h>
 +
 +/* State of each CPU */
 +DEFINE_PER_CPU(int, cpu_state) = { 0 };
++=======
+ #include <asm/misc.h>
+ #include <asm/qspinlock.h>
+ #include <asm/intel-family.h>
+ #include <asm/cpu_device_id.h>
+ #include <asm/spec-ctrl.h>
++>>>>>>> 1f50ddb4f418 (x86/speculation: Handle HT correctly on AMD)
  
  /* Number of siblings per CPU package */
  int smp_num_siblings = 1;
@@@ -235,10 -245,13 +243,12 @@@ static void notrace start_secondary(voi
  	 */
  	check_tsc_sync_target();
  
+ 	speculative_store_bypass_ht_init();
+ 
  	/*
 -	 * Lock vector_lock, set CPU online and bring the vector
 -	 * allocator online. Online must be set with vector_lock held
 -	 * to prevent a concurrent irq setup/teardown from seeing a
 -	 * half valid vector space.
 +	 * We need to hold vector_lock so there the set of online cpus
 +	 * does not change while we are assigning vectors to cpus.  Holding
 +	 * this lock ensures we don't half assign or remove an irq from a cpu.
  	 */
  	lock_vector_lock();
  	set_cpu_online(smp_processor_id(), true);
@@@ -1293,8 -1295,8 +1303,13 @@@ void __init native_smp_prepare_cpus(uns
  	set_mtrr_aps_delayed_init();
  
  	smp_quirk_init_udelay();
++<<<<<<< HEAD
 +out:
 +	preempt_enable();
++=======
+ 
+ 	speculative_store_bypass_ht_init();
++>>>>>>> 1f50ddb4f418 (x86/speculation: Handle HT correctly on AMD)
  }
  
  void arch_enable_nonboot_cpus_begin(void)
* Unmerged path arch/x86/include/asm/spec-ctrl.h
* Unmerged path arch/x86/include/asm/spec-ctrl.h
* Unmerged path arch/x86/kernel/process.c
* Unmerged path arch/x86/kernel/smpboot.c
