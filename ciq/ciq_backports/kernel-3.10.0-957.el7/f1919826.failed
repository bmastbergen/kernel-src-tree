ceph: check if mds create snaprealm when setting quota

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Yan, Zheng <zyan@redhat.com>
commit f1919826896c82b6af9c46f69e02f2bc04df4be7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f1919826.failed

If mds does not, return -EOPNOTSUPP.

Link: http://tracker.ceph.com/issues/23491
	Signed-off-by: "Yan, Zheng" <zyan@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit f1919826896c82b6af9c46f69e02f2bc04df4be7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/xattr.c
diff --cc fs/ceph/xattr.c
index 4a72e8322a31,315f7e63e7cc..000000000000
--- a/fs/ceph/xattr.c
+++ b/fs/ceph/xattr.c
@@@ -201,6 -224,39 +201,42 @@@ static size_t ceph_vxattrcb_dir_rctime(
  			(long)ci->i_rctime.tv_nsec);
  }
  
++<<<<<<< HEAD
++=======
+ /* quotas */
+ 
+ static bool ceph_vxattrcb_quota_exists(struct ceph_inode_info *ci)
+ {
+ 	bool ret = false;
+ 	spin_lock(&ci->i_ceph_lock);
+ 	if ((ci->i_max_files || ci->i_max_bytes) &&
+ 	    ci->i_vino.snap == CEPH_NOSNAP &&
+ 	    ci->i_snap_realm &&
+ 	    ci->i_snap_realm->ino == ci->i_vino.ino)
+ 		ret = true;
+ 	spin_unlock(&ci->i_ceph_lock);
+ 	return ret;
+ }
+ 
+ static size_t ceph_vxattrcb_quota(struct ceph_inode_info *ci, char *val,
+ 				  size_t size)
+ {
+ 	return snprintf(val, size, "max_bytes=%llu max_files=%llu",
+ 			ci->i_max_bytes, ci->i_max_files);
+ }
+ 
+ static size_t ceph_vxattrcb_quota_max_bytes(struct ceph_inode_info *ci,
+ 					    char *val, size_t size)
+ {
+ 	return snprintf(val, size, "%llu", ci->i_max_bytes);
+ }
+ 
+ static size_t ceph_vxattrcb_quota_max_files(struct ceph_inode_info *ci,
+ 					    char *val, size_t size)
+ {
+ 	return snprintf(val, size, "%llu", ci->i_max_files);
+ }
++>>>>>>> f1919826896c (ceph: check if mds create snaprealm when setting quota)
  
  #define CEPH_XATTR_NAME(_type, _name)	XATTR_CEPH_PREFIX #_type "." #_name
  #define CEPH_XATTR_NAME2(_type, _name, _name2)	\
@@@ -971,12 -1022,13 +1008,16 @@@ int __ceph_setxattr(struct dentry *dent
  	if (ceph_snap(inode) != CEPH_NOSNAP)
  		return -EROFS;
  
 +	if (!ceph_is_valid_xattr(name))
 +		return -EOPNOTSUPP;
 +
  	vxattr = ceph_match_vxattr(inode, name);
- 	if (vxattr && vxattr->readonly)
- 		return -EOPNOTSUPP;
+ 	if (vxattr) {
+ 		if (vxattr->readonly)
+ 			return -EOPNOTSUPP;
+ 		if (value && !strncmp(vxattr->name, "ceph.quota", 10))
+ 			check_realm = true;
+ 	}
  
  	/* pass any unhandled ceph.* xattrs through to the MDS */
  	if (!strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN))
@@@ -1069,7 -1121,16 +1110,20 @@@ do_sync_unlocked
  				    "during filling trace\n", inode);
  		err = -EBUSY;
  	} else {
++<<<<<<< HEAD
 +		err = ceph_sync_setxattr(dentry, name, value, size, flags);
++=======
+ 		err = ceph_sync_setxattr(inode, name, value, size, flags);
+ 		if (err >= 0 && check_realm) {
+ 			/* check if snaprealm was created for quota inode */
+ 			spin_lock(&ci->i_ceph_lock);
+ 			if ((ci->i_max_files || ci->i_max_bytes) &&
+ 			    !(ci->i_snap_realm &&
+ 			      ci->i_snap_realm->ino == ci->i_vino.ino))
+ 				err = -EOPNOTSUPP;
+ 			spin_unlock(&ci->i_ceph_lock);
+ 		}
++>>>>>>> f1919826896c (ceph: check if mds create snaprealm when setting quota)
  	}
  out:
  	ceph_free_cap_flush(prealloc_cf);
* Unmerged path fs/ceph/xattr.c
