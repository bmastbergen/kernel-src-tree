ipv6: Fix idev->addr_list corruption

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Rabin Vincent <rabinv@axis.com>
commit a2d6cbb0670d54806f18192cb0db266b4a6d285a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/a2d6cbb0.failed

addrconf_ifdown() removes elements from the idev->addr_list without
holding the idev->lock.

If this happens while the loop in __ipv6_dev_get_saddr() is handling the
same element, that function ends up in an infinite loop:

  NMI watchdog: BUG: soft lockup - CPU#1 stuck for 23s! [test:1719]
  Call Trace:
   ipv6_get_saddr_eval+0x13c/0x3a0
   __ipv6_dev_get_saddr+0xe4/0x1f0
   ipv6_dev_get_saddr+0x1b4/0x204
   ip6_dst_lookup_tail+0xcc/0x27c
   ip6_dst_lookup_flow+0x38/0x80
   udpv6_sendmsg+0x708/0xba8
   sock_sendmsg+0x18/0x30
   SyS_sendto+0xb8/0xf8
   syscall_common+0x34/0x58

Fixes: 6a923934c33 (Revert "ipv6: Revert optional address flusing on ifdown.")
	Signed-off-by: Rabin Vincent <rabinv@axis.com>
	Acked-by: David Ahern <dsa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a2d6cbb0670d54806f18192cb0db266b4a6d285a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/addrconf.c
diff --cc net/ipv6/addrconf.c
index 836f13f8d356,80ce478c4851..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -3330,20 -3618,45 +3330,57 @@@ static int addrconf_ifdown(struct net_d
  		write_lock_bh(&idev->lock);
  	}
  
++<<<<<<< HEAD
 +	while (!list_empty(&idev->addr_list)) {
 +		ifa = list_first_entry(&idev->addr_list,
 +				       struct inet6_ifaddr, if_list);
 +		addrconf_del_dad_work(ifa);
 +
 +		list_del(&ifa->if_list);
++=======
+ 	/* re-combine the user config with event to determine if permanent
+ 	 * addresses are to be removed from the interface list
+ 	 */
+ 	keep_addr = (!how && _keep_addr > 0 && !idev->cnf.disable_ipv6);
+ 
+ 	INIT_LIST_HEAD(&del_list);
+ 	list_for_each_entry_safe(ifa, tmp, &idev->addr_list, if_list) {
+ 		struct rt6_info *rt = NULL;
+ 		bool keep;
+ 
+ 		addrconf_del_dad_work(ifa);
+ 
+ 		keep = keep_addr && (ifa->flags & IFA_F_PERMANENT) &&
+ 			!addr_is_local(&ifa->addr);
+ 		if (!keep)
+ 			list_move(&ifa->if_list, &del_list);
++>>>>>>> a2d6cbb0670d (ipv6: Fix idev->addr_list corruption)
  
  		write_unlock_bh(&idev->lock);
 +
  		spin_lock_bh(&ifa->lock);
++<<<<<<< HEAD
 +		state = ifa->state;
 +		ifa->state = INET6_IFADDR_STATE_DEAD;
++=======
+ 
+ 		if (keep) {
+ 			/* set state to skip the notifier below */
+ 			state = INET6_IFADDR_STATE_DEAD;
+ 			ifa->state = 0;
+ 			if (!(ifa->flags & IFA_F_NODAD))
+ 				ifa->flags |= IFA_F_TENTATIVE;
+ 
+ 			rt = ifa->rt;
+ 			ifa->rt = NULL;
+ 		} else {
+ 			state = ifa->state;
+ 			ifa->state = INET6_IFADDR_STATE_DEAD;
+ 		}
+ 
++>>>>>>> a2d6cbb0670d (ipv6: Fix idev->addr_list corruption)
  		spin_unlock_bh(&ifa->lock);
  
 -		if (rt)
 -			ip6_del_rt(rt);
 -
  		if (state != INET6_IFADDR_STATE_DEAD) {
  			__ipv6_ifa_notify(RTM_DELADDR, ifa);
  			inet6addr_notifier_call_chain(NETDEV_DOWN, ifa);
* Unmerged path net/ipv6/addrconf.c
