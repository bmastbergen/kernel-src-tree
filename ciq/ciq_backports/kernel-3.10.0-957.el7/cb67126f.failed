HID: hid-sensor-hub: Add support for application collection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [hid] hid-sensor-hub: Add support for application collection (Tony Camuso) [1559170]
Rebuild_FUZZ: 95.58%
commit-author Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
commit cb67126f32f008b9abe97fbfca9b23a797b2458a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/cb67126f.failed

Section 4.2.5 of HID Sensor hub specification allows two methods
defining sensor devices.
- Each sensor device by its own collection
- A top level application collection object, including multiple
sensors.
In the first method, each sensor can be in its own sensor application
collection without a physical collection.
In the second method there is a usage id for collection type, which
is defined as an application collection, with multiple physical
collections in it. It is possible to define fusion sensor with this
and may have its own handler. If there is a callback registered
for the collection type, then forward all reports for sensors in
its collection to this handler.

	Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit cb67126f32f008b9abe97fbfca9b23a797b2458a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/hid-sensor-hub.c
diff --cc drivers/hid/hid-sensor-hub.c
index 3e67ed86c707,c325f85fa3a6..000000000000
--- a/drivers/hid/hid-sensor-hub.c
+++ b/drivers/hid/hid-sensor-hub.c
@@@ -95,21 -79,19 +95,29 @@@ static struct hid_report *sensor_hub_re
  	return NULL;
  }
  
 -static int sensor_hub_get_physical_device_count(struct hid_device *hdev)
 +static int sensor_hub_get_physical_device_count(
 +				struct hid_report_enum *report_enum)
  {
 -	int i;
 -	int count = 0;
 +	struct hid_report *report;
 +	struct hid_field *field;
 +	int cnt = 0;
  
++<<<<<<< HEAD
 +	list_for_each_entry(report, &report_enum->report_list, list) {
 +		field = report->field[0];
 +		if (report->maxfield && field &&
 +					field->physical)
 +			cnt++;
++=======
+ 	for (i = 0; i < hdev->maxcollection; ++i) {
+ 		struct hid_collection *collection = &hdev->collection[i];
+ 		if (collection->type == HID_COLLECTION_PHYSICAL ||
+ 		    collection->type == HID_COLLECTION_APPLICATION)
+ 			++count;
++>>>>>>> cb67126f32f0 (HID: hid-sensor-hub: Add support for application collection)
  	}
  
 -	return count;
 +	return cnt;
  }
  
  static void sensor_hub_fill_attr_info(
@@@ -134,8 -119,14 +142,17 @@@ static struct hid_sensor_hub_callbacks 
  
  	spin_lock(&pdata->dyn_callback_lock);
  	list_for_each_entry(callback, &pdata->dyn_callback_list, list)
++<<<<<<< HEAD
 +		if (callback->usage_id == usage_id) {
++=======
+ 		if ((callback->usage_id == usage_id ||
+ 		     callback->usage_id == HID_USAGE_SENSOR_COLLECTION) &&
+ 			(collection_index >=
+ 				callback->hsdev->start_collection_index) &&
+ 			(collection_index <
+ 				callback->hsdev->end_collection_index)) {
++>>>>>>> cb67126f32f0 (HID: hid-sensor-hub: Add support for application collection)
  			*priv = callback->priv;
 -			*hsdev = callback->hsdev;
  			spin_unlock(&pdata->dyn_callback_lock);
  			return callback->usage_callback;
  		}
@@@ -165,8 -158,20 +182,24 @@@ int sensor_hub_register_callback(struc
  	callback->usage_callback = usage_callback;
  	callback->usage_id = usage_id;
  	callback->priv = NULL;
++<<<<<<< HEAD
 +	list_add_tail(&callback->list, &pdata->dyn_callback_list);
 +	spin_unlock(&pdata->dyn_callback_lock);
++=======
+ 	/*
+ 	 * If there is a handler registered for the collection type, then
+ 	 * it will handle all reports for sensors in this collection. If
+ 	 * there is also an individual sensor handler registration, then
+ 	 * we want to make sure that the reports are directed to collection
+ 	 * handler, as this may be a fusion sensor. So add collection handlers
+ 	 * to the beginning of the list, so that they are matched first.
+ 	 */
+ 	if (usage_id == HID_USAGE_SENSOR_COLLECTION)
+ 		list_add(&callback->list, &pdata->dyn_callback_list);
+ 	else
+ 		list_add_tail(&callback->list, &pdata->dyn_callback_list);
+ 	spin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);
++>>>>>>> cb67126f32f0 (HID: hid-sensor-hub: Add support for application collection)
  
  	return 0;
  }
@@@ -535,10 -565,10 +568,16 @@@ static int sensor_hub_probe(struct hid_
  	struct sensor_hub_data *sd;
  	int i;
  	char *name;
 +	struct hid_report *report;
 +	struct hid_report_enum *report_enum;
 +	struct hid_field *field;
  	int dev_cnt;
++<<<<<<< HEAD
++=======
+ 	struct hid_sensor_hub_device *hsdev;
+ 	struct hid_sensor_hub_device *last_hsdev = NULL;
+ 	struct hid_sensor_hub_device *collection_hsdev = NULL;
++>>>>>>> cb67126f32f0 (HID: hid-sensor-hub: Add support for application collection)
  
  	sd = devm_kzalloc(&hdev->dev, sizeof(*sd), GFP_KERNEL);
  	if (!sd) {
@@@ -587,36 -611,65 +626,82 @@@
  			ret = -ENOMEM;
  			goto err_stop_hw;
  	}
++<<<<<<< HEAD
 +	list_for_each_entry(report, &report_enum->report_list, list) {
 +		hid_dbg(hdev, "Report id:%x\n", report->id);
 +		field = report->field[0];
 +		if (report->maxfield && field &&
 +					field->physical) {
 +			name = kasprintf(GFP_KERNEL, "HID-SENSOR-%x",
 +						field->physical);
 +			if (name  == NULL) {
++=======
+ 
+ 	for (i = 0; i < hdev->maxcollection; ++i) {
+ 		struct hid_collection *collection = &hdev->collection[i];
+ 
+ 		if (collection->type == HID_COLLECTION_PHYSICAL ||
+ 		    collection->type == HID_COLLECTION_APPLICATION) {
+ 
+ 			hsdev = devm_kzalloc(&hdev->dev, sizeof(*hsdev),
+ 					     GFP_KERNEL);
+ 			if (!hsdev) {
+ 				hid_err(hdev, "cannot allocate hid_sensor_hub_device\n");
+ 				ret = -ENOMEM;
+ 				goto err_stop_hw;
+ 			}
+ 			hsdev->hdev = hdev;
+ 			hsdev->vendor_id = hdev->vendor;
+ 			hsdev->product_id = hdev->product;
+ 			hsdev->usage = collection->usage;
+ 			mutex_init(&hsdev->mutex);
+ 			hsdev->start_collection_index = i;
+ 			if (last_hsdev)
+ 				last_hsdev->end_collection_index = i;
+ 			last_hsdev = hsdev;
+ 			name = devm_kasprintf(&hdev->dev, GFP_KERNEL,
+ 					      "HID-SENSOR-%x",
+ 					      collection->usage);
+ 			if (name == NULL) {
++>>>>>>> cb67126f32f0 (HID: hid-sensor-hub: Add support for application collection)
  				hid_err(hdev, "Failed MFD device name\n");
  					ret = -ENOMEM;
 -					goto err_stop_hw;
 +					goto err_free_names;
  			}
 +			sd->hid_sensor_hub_client_devs[
 +				sd->hid_sensor_client_cnt].id = PLATFORM_DEVID_AUTO;
  			sd->hid_sensor_hub_client_devs[
  				sd->hid_sensor_client_cnt].name = name;
  			sd->hid_sensor_hub_client_devs[
  				sd->hid_sensor_client_cnt].platform_data =
 -							hsdev;
 +						sd->hsdev;
  			sd->hid_sensor_hub_client_devs[
  				sd->hid_sensor_client_cnt].pdata_size =
 -							sizeof(*hsdev);
 -			hid_dbg(hdev, "Adding %s:%d\n", name,
 -					hsdev->start_collection_index);
 +						sizeof(*sd->hsdev);
 +			hid_dbg(hdev, "Adding %s:%p\n", name, sd);
  			sd->hid_sensor_client_cnt++;
+ 			if (collection_hsdev)
+ 				collection_hsdev->end_collection_index = i;
+ 			if (collection->type == HID_COLLECTION_APPLICATION &&
+ 			    collection->usage == HID_USAGE_SENSOR_COLLECTION)
+ 				collection_hsdev = hsdev;
  		}
  	}
++<<<<<<< HEAD
 +	ret = mfd_add_devices(&hdev->dev, 0, sd->hid_sensor_hub_client_devs,
 +		sd->hid_sensor_client_cnt, NULL, 0, NULL);
++=======
+ 	if (last_hsdev)
+ 		last_hsdev->end_collection_index = i;
+ 	if (collection_hsdev)
+ 		collection_hsdev->end_collection_index = i;
+ 
+ 	ret = mfd_add_hotplug_devices(&hdev->dev,
+ 			sd->hid_sensor_hub_client_devs,
+ 			sd->hid_sensor_client_cnt);
++>>>>>>> cb67126f32f0 (HID: hid-sensor-hub: Add support for application collection)
  	if (ret < 0)
 -		goto err_stop_hw;
 +		goto err_free_names;
  
  	return ret;
  
* Unmerged path drivers/hid/hid-sensor-hub.c
diff --git a/include/linux/hid-sensor-ids.h b/include/linux/hid-sensor-ids.h
index 161fd05a869c..6026ba554f75 100644
--- a/include/linux/hid-sensor-ids.h
+++ b/include/linux/hid-sensor-ids.h
@@ -21,6 +21,8 @@
 
 #define HID_MAX_PHY_DEVICES					0xFF
 
+#define HID_USAGE_SENSOR_COLLECTION				0x200001
+
 /* Accel 3D (200073) */
 #define HID_USAGE_SENSOR_ACCEL_3D				0x200073
 #define HID_USAGE_SENSOR_ACCEL_X_AXIS				0x200453
