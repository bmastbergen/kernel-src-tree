EDAC, sb_edac: Assign EDAC memory controller per h/w controller

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [edac] sb_edac: Assign EDAC memory controller per h/w controller (Aristeu Rozanski) [1483004 1483026]
Rebuild_FUZZ: 95.00%
commit-author Qiuxu Zhuo <qiuxu.zhuo@intel.com>
commit e2f747b1f42a2f6b0cf5416be1684c1b94a42f0f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/e2f747b1.failed

Tony pointed out: "currently the driver pretends there is one big
8-channel memory controller per socket instead of 2 4-channel
controllers. This is fine with all memory controller populated with
symmetrical DIMM configurations, but runs into difficulties on
asymmetrical setups".

Restructure the driver to assign an EDAC memory controller to each real
h/w memory controller to resolve the issue.

	Signed-off-by: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
	Cc: linux-edac <linux-edac@vger.kernel.org>
Link: http://lkml.kernel.org/r/20170523000731.87793-1-qiuxu.zhuo@intel.com
[ Break some lines at convenient points. ]
	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit e2f747b1f42a2f6b0cf5416be1684c1b94a42f0f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/sb_edac.c
diff --cc drivers/edac/sb_edac.c
index cd451b8e68aa,2c2c7ed9d886..000000000000
--- a/drivers/edac/sb_edac.c
+++ b/drivers/edac/sb_edac.c
@@@ -2465,8 -2467,8 +2464,13 @@@ static int sbridge_mci_bind_devs(struc
  	}
  
  	/* Check if everything were registered */
++<<<<<<< HEAD
 +	if (!pvt->pci_sad0 || !pvt->pci_sad1 || !pvt->pci_ha0 ||
 +	    !pvt-> pci_tad || !pvt->pci_ras  || !pvt->pci_ta)
++=======
+ 	if (!pvt->pci_sad0 || !pvt->pci_sad1 || !pvt->pci_ha ||
+ 	    !pvt->pci_ras || !pvt->pci_ta)
++>>>>>>> e2f747b1f42a (EDAC, sb_edac: Assign EDAC memory controller per h/w controller)
  		goto enodev;
  
  	if (saw_chan_mask != 0x0f)
@@@ -2554,14 -2558,12 +2560,18 @@@ static int ibridge_mci_bind_devs(struc
  	}
  
  	/* Check if everything were registered */
++<<<<<<< HEAD
 +	if (!pvt->pci_sad0 || !pvt->pci_ha0 || !pvt->pci_br0 ||
 +	    !pvt->pci_br1 || !pvt->pci_tad || !pvt->pci_ras  ||
 +	    !pvt->pci_ta)
++=======
+ 	if (!pvt->pci_sad0 || !pvt->pci_ha || !pvt->pci_br0 ||
+ 	    !pvt->pci_br1 || !pvt->pci_ras || !pvt->pci_ta)
++>>>>>>> e2f747b1f42a (EDAC, sb_edac: Assign EDAC memory controller per h/w controller)
  		goto enodev;
  
- 	if (saw_chan_mask != 0x0f && /* -EN */
- 	    saw_chan_mask != 0x33 && /* -EP */
- 	    saw_chan_mask != 0xff)   /* -EX */
+ 	if (saw_chan_mask != 0x0f && /* -EN/-EX */
+ 	    saw_chan_mask != 0x03)   /* -EP */
  		goto enodev;
  	return 0;
  
@@@ -3141,10 -3088,10 +3151,10 @@@ static int sbridge_mce_check_error(stru
  	struct sbridge_pvt *pvt;
  	char *type;
  
 -	if (edac_get_report_status() == EDAC_REPORTING_DISABLED)
 +	if (get_edac_report_status() == EDAC_REPORTING_DISABLED)
  		return NOTIFY_DONE;
  
- 	mci = get_mci_for_node_id(mce->socketid);
+ 	mci = get_mci_for_node_id(mce->socketid, IMC0);
  	if (!mci)
  		return NOTIFY_DONE;
  	pvt = mci->pvt_info;
* Unmerged path drivers/edac/sb_edac.c
