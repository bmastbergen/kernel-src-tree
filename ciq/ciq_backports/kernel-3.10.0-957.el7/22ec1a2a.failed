/dev/mem: Add bounce buffer for copy-out

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Kees Cook <keescook@chromium.org>
commit 22ec1a2aea73b9dfe340dff7945bd85af4cc6280
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/22ec1a2a.failed

As done for /proc/kcore in

  commit df04abfd181a ("fs/proc/kcore.c: Add bounce buffer for ktext data")

this adds a bounce buffer when reading memory via /dev/mem. This
is needed to allow kernel text memory to be read out when built with
CONFIG_HARDENED_USERCOPY (which refuses to read out kernel text) and
without CONFIG_STRICT_DEVMEM (which would have refused to read any RAM
contents at all).

Since this build configuration isn't common (most systems with
CONFIG_HARDENED_USERCOPY also have CONFIG_STRICT_DEVMEM), this also tries
to inform Kconfig about the recommended settings.

This patch is modified from Brad Spengler/PaX Team's changes to /dev/mem
code in the last public patch of grsecurity/PaX based on my understanding
of the code. Changes or omissions from the original code are mine and
don't reflect the original grsecurity/PaX code.

	Reported-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
Fixes: f5509cc18daa ("mm: Hardened usercopy")
	Signed-off-by: Kees Cook <keescook@chromium.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 22ec1a2aea73b9dfe340dff7945bd85af4cc6280)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/mem.c
#	security/Kconfig
diff --cc drivers/char/mem.c
index 0a67d2907a65,052011bcf100..000000000000
--- a/drivers/char/mem.c
+++ b/drivers/char/mem.c
@@@ -108,7 -106,12 +108,16 @@@ static ssize_t read_mem(struct file *fi
  {
  	phys_addr_t p = *ppos;
  	ssize_t read, sz;
++<<<<<<< HEAD
 +	char *ptr;
++=======
+ 	void *ptr;
+ 	char *bounce;
+ 	int err;
+ 
+ 	if (p != *ppos)
+ 		return 0;
++>>>>>>> 22ec1a2aea73 (/dev/mem: Add bounce buffer for copy-out)
  
  	if (!valid_phys_addr_range(p, count))
  		return -EFAULT;
diff --cc security/Kconfig
index 78bddd1d7f28,3b4effd8bbc2..000000000000
--- a/security/Kconfig
+++ b/security/Kconfig
@@@ -144,6 -132,80 +144,83 @@@ config LSM_MMAP_MIN_ADD
  	  this low address space will need the permission specific to the
  	  systems running LSM.
  
++<<<<<<< HEAD
++=======
+ config HAVE_HARDENED_USERCOPY_ALLOCATOR
+ 	bool
+ 	help
+ 	  The heap allocator implements __check_heap_object() for
+ 	  validating memory ranges against heap object sizes in
+ 	  support of CONFIG_HARDENED_USERCOPY.
+ 
+ config HARDENED_USERCOPY
+ 	bool "Harden memory copies between kernel and userspace"
+ 	depends on HAVE_HARDENED_USERCOPY_ALLOCATOR
+ 	select BUG
+ 	imply STRICT_DEVMEM
+ 	help
+ 	  This option checks for obviously wrong memory regions when
+ 	  copying memory to/from the kernel (via copy_to_user() and
+ 	  copy_from_user() functions) by rejecting memory ranges that
+ 	  are larger than the specified heap object, span multiple
+ 	  separately allocated pages, are not on the process stack,
+ 	  or are part of the kernel text. This kills entire classes
+ 	  of heap overflow exploits and similar kernel memory exposures.
+ 
+ config HARDENED_USERCOPY_PAGESPAN
+ 	bool "Refuse to copy allocations that span multiple pages"
+ 	depends on HARDENED_USERCOPY
+ 	depends on EXPERT
+ 	help
+ 	  When a multi-page allocation is done without __GFP_COMP,
+ 	  hardened usercopy will reject attempts to copy it. There are,
+ 	  however, several cases of this in the kernel that have not all
+ 	  been removed. This config is intended to be used only while
+ 	  trying to find such users.
+ 
+ config FORTIFY_SOURCE
+ 	bool "Harden common str/mem functions against buffer overflows"
+ 	depends on ARCH_HAS_FORTIFY_SOURCE
+ 	help
+ 	  Detect overflows of buffers in common string and memory functions
+ 	  where the compiler can determine and validate the buffer sizes.
+ 
+ config STATIC_USERMODEHELPER
+ 	bool "Force all usermode helper calls through a single binary"
+ 	help
+ 	  By default, the kernel can call many different userspace
+ 	  binary programs through the "usermode helper" kernel
+ 	  interface.  Some of these binaries are statically defined
+ 	  either in the kernel code itself, or as a kernel configuration
+ 	  option.  However, some of these are dynamically created at
+ 	  runtime, or can be modified after the kernel has started up.
+ 	  To provide an additional layer of security, route all of these
+ 	  calls through a single executable that can not have its name
+ 	  changed.
+ 
+ 	  Note, it is up to this single binary to then call the relevant
+ 	  "real" usermode helper binary, based on the first argument
+ 	  passed to it.  If desired, this program can filter and pick
+ 	  and choose what real programs are called.
+ 
+ 	  If you wish for all usermode helper programs are to be
+ 	  disabled, choose this option and then set
+ 	  STATIC_USERMODEHELPER_PATH to an empty string.
+ 
+ config STATIC_USERMODEHELPER_PATH
+ 	string "Path to the static usermode helper binary"
+ 	depends on STATIC_USERMODEHELPER
+ 	default "/sbin/usermode-helper"
+ 	help
+ 	  The binary called by the kernel when any usermode helper
+ 	  program is wish to be run.  The "real" application's name will
+ 	  be in the first argument passed to this program on the command
+ 	  line.
+ 
+ 	  If you wish for all usermode helper programs to be disabled,
+ 	  specify an empty string here (i.e. "").
+ 
++>>>>>>> 22ec1a2aea73 (/dev/mem: Add bounce buffer for copy-out)
  source security/selinux/Kconfig
  source security/smack/Kconfig
  source security/tomoyo/Kconfig
* Unmerged path drivers/char/mem.c
* Unmerged path security/Kconfig
