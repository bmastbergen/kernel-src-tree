nvme: get rid of nvme_ctrl_list

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [nvme] get rid of nvme_ctrl_list (David Milburn) [1519689]
Rebuild_FUZZ: 89.29%
commit-author Christoph Hellwig <hch@lst.de>
commit a6a5149b10ec8ab8b4a9479a8230265c1b573be0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/a6a5149b.failed

Use the core chrdev code to set up the link between the character device
and the nvme controller.  This allows us to get rid of the global list
of all controllers, and also ensures that we have both a reference to
the controller and the transport module before the open method of the
character device is called.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Sagi Grimberg <sgi@grimberg.me>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
(cherry picked from commit a6a5149b10ec8ab8b4a9479a8230265c1b573be0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index 7c0569923504,a56a1e0432e7..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -972,34 -1019,21 +966,39 @@@ static int nvme_ioctl(struct block_devi
  	}
  }
  
 +#ifdef CONFIG_COMPAT
 +static int nvme_compat_ioctl(struct block_device *bdev, fmode_t mode,
 +					unsigned int cmd, unsigned long arg)
 +{
 +	switch (cmd) {
 +	case SG_IO:
 +		return -ENOIOCTLCMD;
 +	}
 +	return nvme_ioctl(bdev, mode, cmd, arg);
 +}
 +#else
 +#define nvme_compat_ioctl	NULL
 +#endif
 +
  static int nvme_open(struct block_device *bdev, fmode_t mode)
  {
++<<<<<<< HEAD
 +	return nvme_get_ns_from_disk(bdev->bd_disk) ? 0 : -ENXIO;
++=======
+ 	struct nvme_ns *ns = bdev->bd_disk->private_data;
+ 
+ 	if (!kref_get_unless_zero(&ns->kref))
+ 		return -ENXIO;
+ 	return 0;
++>>>>>>> a6a5149b10ec (nvme: get rid of nvme_ctrl_list)
  }
  
  static void nvme_release(struct gendisk *disk, fmode_t mode)
  {
- 	struct nvme_ns *ns = disk->private_data;
- 
- 	module_put(ns->ctrl->ops->module);
- 	nvme_put_ns(ns);
+ 	nvme_put_ns(disk->private_data);
  }
  
 -static int nvme_getgeo(struct block_device *bdev, struct hd_geometry *geo)
 +static int nvme_getgeo(struct block_device *bd, struct hd_geometry *geo)
  {
  	/* some standard values */
  	geo->heads = 1 << 6;
@@@ -1752,33 -1888,12 +1751,38 @@@ EXPORT_SYMBOL_GPL(nvme_init_identify)
  
  static int nvme_dev_open(struct inode *inode, struct file *file)
  {
- 	struct nvme_ctrl *ctrl;
- 	int instance = iminor(inode);
- 	int ret = -ENODEV;
+ 	struct nvme_ctrl *ctrl =
+ 		container_of(inode->i_cdev, struct nvme_ctrl, cdev);
  
++<<<<<<< HEAD
 +	spin_lock(&dev_list_lock);
 +	list_for_each_entry(ctrl, &nvme_ctrl_list, node) {
 +		if (ctrl->instance != instance)
 +			continue;
 +
 +		if (!ctrl->admin_q) {
 +			ret = -EWOULDBLOCK;
 +			break;
 +		}
 +		if (!kref_get_unless_zero(&ctrl->kref))
 +			break;
 +		file->private_data = ctrl;
 +		ret = 0;
 +		break;
 +	}
 +	spin_unlock(&dev_list_lock);
 +
 +	return ret;
 +}
 +
 +static int nvme_dev_release(struct inode *inode, struct file *file)
 +{
 +	nvme_put_ctrl(file->private_data);
++=======
+ 	if (!ctrl->admin_q)
+ 		return -EWOULDBLOCK;
+ 	file->private_data = ctrl;
++>>>>>>> a6a5149b10ec (nvme: get rid of nvme_ctrl_list)
  	return 0;
  }
  
@@@ -2513,11 -2667,7 +2516,15 @@@ EXPORT_SYMBOL_GPL(nvme_start_ctrl)
  
  void nvme_uninit_ctrl(struct nvme_ctrl *ctrl)
  {
++<<<<<<< HEAD
 +	device_destroy(nvme_class, MKDEV(nvme_char_major, ctrl->instance));
 +
 +	spin_lock(&dev_list_lock);
 +	list_del(&ctrl->node);
 +	spin_unlock(&dev_list_lock);
++=======
+ 	cdev_device_del(&ctrl->cdev, ctrl->device);
++>>>>>>> a6a5149b10ec (nvme: get rid of nvme_ctrl_list)
  }
  EXPORT_SYMBOL_GPL(nvme_uninit_ctrl);
  
@@@ -2565,20 -2708,25 +2572,37 @@@ int nvme_init_ctrl(struct nvme_ctrl *ct
  		goto out;
  	ctrl->instance = ret;
  
++<<<<<<< HEAD
 +	ctrl->device = device_create_with_groups(nvme_class, ctrl->dev,
 +				MKDEV(nvme_char_major, ctrl->instance),
 +				ctrl, nvme_dev_attr_groups,
 +				"nvme%d", ctrl->instance);
 +	if (IS_ERR(ctrl->device)) {
 +		ret = PTR_ERR(ctrl->device);
 +		goto out_release_instance;
 +	}
 +	get_device(ctrl->device);
- 	ida_init(&ctrl->ns_ida);
++=======
+ 	device_initialize(&ctrl->ctrl_device);
+ 	ctrl->device = &ctrl->ctrl_device;
+ 	ctrl->device->devt = MKDEV(MAJOR(nvme_chr_devt), ctrl->instance);
+ 	ctrl->device->class = nvme_class;
+ 	ctrl->device->parent = ctrl->dev;
+ 	ctrl->device->groups = nvme_dev_attr_groups;
+ 	ctrl->device->release = nvme_free_ctrl;
+ 	dev_set_drvdata(ctrl->device, ctrl);
+ 	ret = dev_set_name(ctrl->device, "nvme%d", ctrl->instance);
+ 	if (ret)
+ 		goto out_release_instance;
  
- 	spin_lock(&dev_list_lock);
- 	list_add_tail(&ctrl->node, &nvme_ctrl_list);
- 	spin_unlock(&dev_list_lock);
+ 	cdev_init(&ctrl->cdev, &nvme_dev_fops);
+ 	ctrl->cdev.owner = ops->module;
+ 	ret = cdev_device_add(&ctrl->cdev, ctrl->device);
+ 	if (ret)
+ 		goto out_free_name;
+ 
++>>>>>>> a6a5149b10ec (nvme: get rid of nvme_ctrl_list)
+ 	ida_init(&ctrl->ns_ida);
  
  	/*
  	 * Initialize latency tolerance controls.  The sysfs files won't
* Unmerged path drivers/nvme/host/core.c
diff --git a/drivers/nvme/host/nvme.h b/drivers/nvme/host/nvme.h
index df4c3bd4f65c..27b77f65e9f8 100644
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@ -15,6 +15,7 @@
 #define _NVME_H
 
 #include <linux/nvme.h>
+#include <linux/cdev.h>
 #include <linux/pci.h>
 #include <linux/kref.h>
 #include <linux/blk-mq.h>
@@ -122,7 +123,7 @@ struct nvme_ctrl {
 	struct list_head namespaces;
 	struct mutex namespaces_mutex;
 	struct device *device;	/* char device */
-	struct list_head node;
+	struct cdev cdev;
 	struct ida ns_ida;
 	struct work_struct reset_work;
 
