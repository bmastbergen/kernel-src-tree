crypto: algif_hash - Handle NULL hashes correctly

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [crypto] algif_hash - Handle NULL hashes correctly (Bruno Eduardo de Oliveira Meneguele) [1548921]
Rebuild_FUZZ: 91.11%
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit 493b2ed3f7603a15ff738553384d5a4510ffeb95
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/493b2ed3.failed

Right now attempting to read an empty hash simply returns zeroed
bytes, this patch corrects this by calling the digest function
using an empty input.

	Reported-by: Russell King - ARM Linux <linux@armlinux.org.uk>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 493b2ed3f7603a15ff738553384d5a4510ffeb95)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/algif_hash.c
diff --cc crypto/algif_hash.c
index f3f31cd079cc,2d8466f9e49b..000000000000
--- a/crypto/algif_hash.c
+++ b/crypto/algif_hash.c
@@@ -39,8 -39,39 +39,44 @@@ struct algif_hash_tfm 
  	bool has_key;
  };
  
++<<<<<<< HEAD
 +static int hash_sendmsg(struct kiocb *unused, struct socket *sock,
 +			struct msghdr *msg, size_t ignored)
++=======
+ static int hash_alloc_result(struct sock *sk, struct hash_ctx *ctx)
+ {
+ 	unsigned ds;
+ 
+ 	if (ctx->result)
+ 		return 0;
+ 
+ 	ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
+ 
+ 	ctx->result = sock_kmalloc(sk, ds, GFP_KERNEL);
+ 	if (!ctx->result)
+ 		return -ENOMEM;
+ 
+ 	memset(ctx->result, 0, ds);
+ 
+ 	return 0;
+ }
+ 
+ static void hash_free_result(struct sock *sk, struct hash_ctx *ctx)
+ {
+ 	unsigned ds;
+ 
+ 	if (!ctx->result)
+ 		return;
+ 
+ 	ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
+ 
+ 	sock_kzfree_s(sk, ctx->result, ds);
+ 	ctx->result = NULL;
+ }
+ 
+ static int hash_sendmsg(struct socket *sock, struct msghdr *msg,
+ 			size_t ignored)
++>>>>>>> 493b2ed3f760 (crypto: algif_hash - Handle NULL hashes correctly)
  {
  	int limit = ALG_MAX_PAGES * PAGE_SIZE;
  	struct sock *sk = sock->sk;
@@@ -179,10 -220,16 +236,16 @@@ static int hash_recvmsg(struct kiocb *u
  						 &ctx->completion);
  		if (err)
  			goto unlock;
+ 	} else if (!result) {
+ 		err = af_alg_wait_for_completion(
+ 				crypto_ahash_digest(&ctx->req),
+ 				&ctx->completion);
  	}
  
 -	err = memcpy_to_msg(msg, ctx->result, len);
 +	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);
  
+ 	hash_free_result(sk, ctx);
+ 
  unlock:
  	release_sock(sk);
  
@@@ -402,10 -452,7 +465,14 @@@ static void hash_sock_destruct(struct s
  	struct alg_sock *ask = alg_sk(sk);
  	struct hash_ctx *ctx = ask->private;
  
++<<<<<<< HEAD
 +	memzero_explicit(ctx->result,
 +		     crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req)));
 +	sock_kfree_s(sk, ctx->result,
 +		     crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req)));
++=======
+ 	hash_free_result(sk, ctx);
++>>>>>>> 493b2ed3f760 (crypto: algif_hash - Handle NULL hashes correctly)
  	sock_kfree_s(sk, ctx, ctx->len);
  	af_alg_release_parent(sk);
  }
* Unmerged path crypto/algif_hash.c
