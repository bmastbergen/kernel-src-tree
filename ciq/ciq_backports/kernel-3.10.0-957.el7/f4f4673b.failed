iio: add support for hardware fifo

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iio] add support for hardware fifo (Tony Camuso) [1559170]
Rebuild_FUZZ: 92.06%
commit-author Octavian Purdila <octavian.purdila@intel.com>
commit f4f4673b7535eff4ee1a8cfb1685fa1e1a0cb79d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f4f4673b.failed

Some devices have hardware buffers that can store a number of samples
for later consumption. Hardware usually provides interrupts to notify
the processor when the FIFO is full or when it has reached a certain
watermark level. This helps with reducing the number of interrupts to
the host processor and thus it helps decreasing the power consumption.

This patch enables usage of hardware FIFOs for IIO devices in
conjunction with software device buffers. When the hardware FIFO is
enabled the samples are stored in the hardware FIFO. The samples are
later flushed to the device software buffer when the number of entries
in the hardware FIFO reaches the hardware watermark or when a flush
operation is triggered by the user when doing a non-blocking read
on an empty software device buffer.

In order to implement hardware FIFO support the device drivers must
implement the following new operations: setting and getting the
hardware FIFO watermark level, flushing the hardware FIFO to the
software device buffer. The device must also expose information about
the hardware FIFO such it's minimum and maximum watermark and if
necessary a list of supported watermark values. Finally, the device
driver must activate the hardware FIFO when the device buffer is
enabled, if the current device settings allows it.

The software device buffer watermark is passed by the IIO core to the
device driver as a hint for the hardware FIFO watermark. The device
driver can adjust this value to allow for hardware limitations (such
as capping it to the maximum hardware watermark or adjust it to a
value that is supported by the hardware). It can also disable the
hardware watermark (and implicitly the hardware FIFO) it this value is
below the minimum hardware watermark.

Since a driver may support hardware FIFO only when not in triggered
buffer mode (due to different semantics of hardware FIFO sampling and
triggered sampling) this patch changes the IIO core code to allow
falling back to non-triggered buffered mode if no trigger is enabled.

	Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
	Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit f4f4673b7535eff4ee1a8cfb1685fa1e1a0cb79d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/ABI/testing/sysfs-bus-iio
#	drivers/iio/industrialio-buffer.c
diff --cc Documentation/ABI/testing/sysfs-bus-iio
index 7ba396de2c76,6bf79072179f..000000000000
--- a/Documentation/ABI/testing/sysfs-bus-iio
+++ b/Documentation/ABI/testing/sysfs-bus-iio
@@@ -908,13 -1119,248 +908,257 @@@ Description
  		This attribute is used to read the amount of quadrature error
  		present in the device at a given time.
  
 -What:		/sys/.../iio:deviceX/in_accelX_power_mode
 -KernelVersion:	3.11
 +What:		/sys/bus/iio/devices/iio:device*/buffer/hwfifo_timeout
 +KernelVersion:	4.12
  Contact:	linux-iio@vger.kernel.org
  Description:
++<<<<<<< HEAD
 +		A read/write property to provide capability to delay reporting of
 +		samples till a timeout is reached. This allows host processors to
 +		sleep, while the sensor is storing samples in its internal fifo.
 +		The maximum timeout in seconds can be specified by setting
 +		hwfifo_timeout.The current delay can be read by reading
 +		hwfifo_timeout. A value of 0 means that there is no timeout.
++=======
+ 		Specifies the chip power mode.
+ 		low_noise: reduce noise level from ADC,
+ 		low_power: enable low current consumption.
+ 		For a list of available output power modes read
+ 		in_accel_power_mode_available.
+ 
+ What:		/sys/.../iio:deviceX/in_energy_input
+ What:		/sys/.../iio:deviceX/in_energy_raw
+ KernelVersion:	3.20
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		This attribute is used to read the energy value reported by the
+ 		device (e.g.: human activity sensors report energy burnt by the
+ 		user). Units after application of scale are Joules.
+ 
+ What:		/sys/.../iio:deviceX/in_distance_input
+ What:		/sys/.../iio:deviceX/in_distance_raw
+ KernelVersion:	3.20
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		This attribute is used to read the distance covered by the user
+ 		since the last reboot while activated. Units after application
+ 		of scale are meters.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/store_eeprom
+ KernelVersion:	3.4.0
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Writing '1' stores the current device configuration into
+ 		on-chip EEPROM. After power-up or chip reset the device will
+ 		automatically load the saved configuration.
+ 
+ What:		/sys/.../iio:deviceX/in_proximity_raw
+ What:		/sys/.../iio:deviceX/in_proximity_input
+ What:		/sys/.../iio:deviceX/in_proximityY_raw
+ KernelVersion:	3.4
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Proximity measurement indicating that some
+ 		object is near the sensor, usually be observing
+ 		reflectivity of infrared or ultrasound emitted.
+ 		Often these sensors are unit less and as such conversion
+ 		to SI units is not possible.  Where it is, the units should
+ 		be meters.  If such a conversion is not possible, the reported
+ 		values should behave in the same way as a distance, i.e. lower
+ 		values indicate something is closer to the sensor.
+ 
+ What:		/sys/.../iio:deviceX/in_illuminance_input
+ What:		/sys/.../iio:deviceX/in_illuminance_raw
+ What:		/sys/.../iio:deviceX/in_illuminanceY_input
+ What:		/sys/.../iio:deviceX/in_illuminanceY_raw
+ What:		/sys/.../iio:deviceX/in_illuminanceY_mean_raw
+ What:		/sys/.../iio:deviceX/in_illuminance_ir_raw
+ What:		/sys/.../iio:deviceX/in_illuminance_clear_raw
+ KernelVersion:	3.4
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Illuminance measurement, units after application of scale
+ 		and offset are lux.
+ 
+ What:		/sys/.../iio:deviceX/in_intensityY_raw
+ What:		/sys/.../iio:deviceX/in_intensityY_ir_raw
+ What:		/sys/.../iio:deviceX/in_intensityY_both_raw
+ KernelVersion:	3.4
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Unit-less light intensity. Modifiers both and ir indicate
+ 		that measurements contains visible and infrared light
+ 		components or just infrared light, respectively.
+ 
+ What:		/sys/.../iio:deviceX/in_intensity_red_integration_time
+ What:		/sys/.../iio:deviceX/in_intensity_green_integration_time
+ What:		/sys/.../iio:deviceX/in_intensity_blue_integration_time
+ What:		/sys/.../iio:deviceX/in_intensity_clear_integration_time
+ What:		/sys/.../iio:deviceX/in_illuminance_integration_time
+ KernelVersion:	3.12
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		This attribute is used to get/set the integration time in
+ 		seconds.
+ 
+ What:		/sys/.../iio:deviceX/in_velocity_sqrt(x^2+y^2+z^2)_integration_time
+ KernelVersion:	3.20
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Number of seconds in which to compute speed.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_rot_quaternion_raw
+ KernelVersion:	3.15
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Raw value of quaternion components using a format
+ 		x y z w. Here x, y, and z component represents the axis about
+ 		which a rotation will occur and w component represents the
+ 		amount of rotation.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_rot_from_north_magnetic_tilt_comp_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_rot_from_north_true_tilt_comp_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_rot_from_north_magnetic_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_rot_from_north_true_raw
+ KernelVersion:	3.15
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Raw value of rotation from true/magnetic north measured with
+ 		or without compensation from tilt sensors.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_currentX_raw
+ KernelVersion:	3.18
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Raw current measurement from channel X. Units are in milliamps
+ 		after application of scale and offset. If no offset or scale is
+ 		present, output should be considered as processed with the
+ 		unit in milliamps.
+ 
+ What:		/sys/.../iio:deviceX/in_energy_en
+ What:		/sys/.../iio:deviceX/in_distance_en
+ What:		/sys/.../iio:deviceX/in_velocity_sqrt(x^2+y^2+z^2)_en
+ What:		/sys/.../iio:deviceX/in_steps_en
+ KernelVersion:	3.19
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Activates a device feature that runs in firmware/hardware.
+ 		E.g. for steps: the pedometer saves power while not used;
+ 		when activated, it will count the steps taken by the user in
+ 		firmware and export them through in_steps_input.
+ 
+ What:		/sys/.../iio:deviceX/in_steps_input
+ KernelVersion:	3.19
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		This attribute is used to read the number of steps taken by the user
+ 		since the last reboot while activated.
+ 
+ What:		/sys/.../iio:deviceX/in_velocity_sqrt(x^2+y^2+z^2)_input
+ What:		/sys/.../iio:deviceX/in_velocity_sqrt(x^2+y^2+z^2)_raw
+ KernelVersion:	3.19
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		This attribute is used to read the current speed value of the
+ 		user (which is the norm or magnitude of the velocity vector).
+ 		Units after application of scale are m/s.
+ 
+ What:		/sys/.../iio:deviceX/in_steps_debounce_count
+ KernelVersion:	3.20
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Specifies the number of steps that must occur within
+ 		in_steps_filter_debounce_time for the pedometer to decide the
+ 		consumer is making steps.
+ 
+ What:		/sys/.../iio:deviceX/in_steps_debounce_time
+ KernelVersion:	3.20
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Specifies number of seconds in which we compute the steps
+ 		that occur in order to decide if the consumer is making steps.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/buffer/watermark
+ KernelVersion:	4.2
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		A single positive integer specifying the maximum number of scan
+ 		elements to wait for.
+ 		Poll will block until the watermark is reached.
+ 		Blocking read will wait until the minimum between the requested
+ 		read amount or the low water mark is available.
+ 		Non-blocking read will retrieve the available samples from the
+ 		buffer even if there are less samples then watermark level. This
+ 		allows the application to block on poll with a timeout and read
+ 		the available samples after the timeout expires and thus have a
+ 		maximum delay guarantee.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/buffer/hwfifo_enabled
+ KernelVersion: 4.2
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		A read-only boolean value that indicates if the hardware fifo is
+ 		currently enabled or disabled. If the device does not have a
+ 		hardware fifo this entry is not present.
+ 		The hardware fifo is enabled when the buffer is enabled if the
+ 		current hardware fifo watermark level is set and other current
+ 		device settings allows it (e.g. if a trigger is set that samples
+ 		data differently that the hardware fifo does then hardware fifo
+ 		will not enabled).
+ 		If the hardware fifo is enabled and the level of the hardware
+ 		fifo reaches the hardware fifo watermark level the device will
+ 		flush its hardware fifo to the device buffer. Doing a non
+ 		blocking read on the device when no samples are present in the
+ 		device buffer will also force a flush.
+ 		When the hardware fifo is enabled there is no need to use a
+ 		trigger to use buffer mode since the watermark settings
+ 		guarantees that the hardware fifo is flushed to the device
+ 		buffer.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/buffer/hwfifo_watermark
+ KernelVersion: 4.2
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Read-only entry that contains a single integer specifying the
+ 		current watermark level for the hardware fifo. If the device
+ 		does not have a hardware fifo this entry is not present.
+ 		The watermark level for the hardware fifo is set by the driver
+ 		based on the value set by the user in buffer/watermark but
+ 		taking into account hardware limitations (e.g. most hardware
+ 		buffers are limited to 32-64 samples, some hardware buffers
+ 		watermarks are fixed or have minimum levels).  A value of 0
+ 		means that the hardware watermark is unset.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/buffer/hwfifo_watermark_min
+ KernelVersion: 4.2
+ Contact:       linux-iio@vger.kernel.org
+ Description:
+ 		A single positive integer specifying the minimum watermark level
+ 		for the hardware fifo of this device. If the device does not
+ 		have a hardware fifo this entry is not present.
+ 		If the user sets buffer/watermark to a value less than this one,
+ 		then the hardware watermark will remain unset.
+ 
+ What:	       /sys/bus/iio/devices/iio:deviceX/buffer/hwfifo_watermark_max
+ KernelVersion: 4.2
+ Contact:       linux-iio@vger.kernel.org
+ Description:
+ 		A single positive integer specifying the maximum watermark level
+ 		for the hardware fifo of this device. If the device does not
+ 		have a hardware fifo this entry is not present.
+ 		If the user sets buffer/watermark to a value greater than this
+ 		one, then the hardware watermark will be capped at this value.
+ 
+ What:	       /sys/bus/iio/devices/iio:deviceX/buffer/hwfifo_watermark_available
+ KernelVersion: 4.2
+ Contact:       linux-iio@vger.kernel.org
+ Description:
+ 		A list of positive integers specifying the available watermark
+ 		levels for the hardware fifo. This entry is optional and if it
+ 		is not present it means that all the values between
+ 		hwfifo_watermark_min and hwfifo_watermark_max are supported.
+ 		If the user sets buffer/watermark to a value greater than
+ 		hwfifo_watermak_min but not equal to any of the values in this
+ 		list, the driver will chose an appropriate value for the
+ 		hardware fifo watermark level.
++>>>>>>> f4f4673b7535 (iio: add support for hardware fifo)
diff --cc drivers/iio/industrialio-buffer.c
index ed6b8aa675ce,df919f44d513..000000000000
--- a/drivers/iio/industrialio-buffer.c
+++ b/drivers/iio/industrialio-buffer.c
@@@ -37,12 -37,55 +37,59 @@@ static bool iio_buffer_is_active(struc
  	return !list_empty(&buf->buffer_list);
  }
  
 -static size_t iio_buffer_data_available(struct iio_buffer *buf)
 +static bool iio_buffer_data_available(struct iio_buffer *buf)
  {
 -	return buf->access->data_available(buf);
 -}
 +	if (buf->access->data_available)
 +		return buf->access->data_available(buf);
  
++<<<<<<< HEAD
 +	return buf->stufftoread;
++=======
+ static int iio_buffer_flush_hwfifo(struct iio_dev *indio_dev,
+ 				   struct iio_buffer *buf, size_t required)
+ {
+ 	if (!indio_dev->info->hwfifo_flush_to_buffer)
+ 		return -ENODEV;
+ 
+ 	return indio_dev->info->hwfifo_flush_to_buffer(indio_dev, required);
+ }
+ 
+ static bool iio_buffer_ready(struct iio_dev *indio_dev, struct iio_buffer *buf,
+ 			     size_t to_wait, int to_flush)
+ {
+ 	size_t avail;
+ 	int flushed = 0;
+ 
+ 	/* wakeup if the device was unregistered */
+ 	if (!indio_dev->info)
+ 		return true;
+ 
+ 	/* drain the buffer if it was disabled */
+ 	if (!iio_buffer_is_active(buf)) {
+ 		to_wait = min_t(size_t, to_wait, 1);
+ 		to_flush = 0;
+ 	}
+ 
+ 	avail = iio_buffer_data_available(buf);
+ 
+ 	if (avail >= to_wait) {
+ 		/* force a flush for non-blocking reads */
+ 		if (!to_wait && !avail && to_flush)
+ 			iio_buffer_flush_hwfifo(indio_dev, buf, to_flush);
+ 		return true;
+ 	}
+ 
+ 	if (to_flush)
+ 		flushed = iio_buffer_flush_hwfifo(indio_dev, buf,
+ 						  to_wait - avail);
+ 	if (flushed <= 0)
+ 		return false;
+ 
+ 	if (avail + flushed >= to_wait)
+ 		return true;
+ 
+ 	return false;
++>>>>>>> f4f4673b7535 (iio: add support for hardware fifo)
  }
  
  /**
@@@ -56,6 -99,9 +103,12 @@@ ssize_t iio_buffer_read_first_n_outer(s
  {
  	struct iio_dev *indio_dev = filp->private_data;
  	struct iio_buffer *rb = indio_dev->buffer;
++<<<<<<< HEAD
++=======
+ 	size_t datum_size;
+ 	size_t to_wait = 0;
+ 	size_t to_read;
++>>>>>>> f4f4673b7535 (iio: add support for hardware fifo)
  	int ret;
  
  	if (!indio_dev->info)
@@@ -64,19 -110,28 +117,41 @@@
  	if (!rb || !rb->access->read_first_n)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	do {
 +		if (!iio_buffer_data_available(rb)) {
 +			if (filp->f_flags & O_NONBLOCK)
 +				return -EAGAIN;
++=======
+ 	datum_size = rb->bytes_per_datum;
+ 
+ 	/*
+ 	 * If datum_size is 0 there will never be anything to read from the
+ 	 * buffer, so signal end of file now.
+ 	 */
+ 	if (!datum_size)
+ 		return 0;
+ 
+ 	to_read = min_t(size_t, n / datum_size, rb->watermark);
+ 
+ 	if (!(filp->f_flags & O_NONBLOCK))
+ 		to_wait = to_read;
+ 
+ 	do {
+ 		ret = wait_event_interruptible(rb->pollq,
+ 			iio_buffer_ready(indio_dev, rb, to_wait, to_read));
+ 		if (ret)
+ 			return ret;
++>>>>>>> f4f4673b7535 (iio: add support for hardware fifo)
  
 -		if (!indio_dev->info)
 -			return -ENODEV;
 +			ret = wait_event_interruptible(rb->pollq,
 +					iio_buffer_data_available(rb) ||
 +					indio_dev->info == NULL);
 +			if (ret)
 +				return ret;
 +			if (indio_dev->info == NULL)
 +				return -ENODEV;
 +		}
  
  		ret = rb->access->read_first_n(rb, n, buf);
  		if (ret == 0 && (filp->f_flags & O_NONBLOCK))
@@@ -99,9 -154,8 +174,13 @@@ unsigned int iio_buffer_poll(struct fil
  		return -ENODEV;
  
  	poll_wait(filp, &rb->pollq, wait);
++<<<<<<< HEAD
 +	if (iio_buffer_data_available(rb))
++=======
+ 	if (iio_buffer_ready(indio_dev, rb, rb->watermark, 0))
++>>>>>>> f4f4673b7535 (iio: add support for hardware fifo)
  		return POLLIN | POLLRDNORM;
 +	/* need a way of knowing if there may be enough data... */
  	return 0;
  }
  
@@@ -837,7 -812,188 +913,192 @@@ done
  	mutex_unlock(&indio_dev->mlock);
  	return (ret < 0) ? ret : len;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(iio_buffer_store_enable);
++=======
+ 
+ static const char * const iio_scan_elements_group_name = "scan_elements";
+ 
+ static ssize_t iio_buffer_show_watermark(struct device *dev,
+ 					 struct device_attribute *attr,
+ 					 char *buf)
+ {
+ 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+ 	struct iio_buffer *buffer = indio_dev->buffer;
+ 
+ 	return sprintf(buf, "%u\n", buffer->watermark);
+ }
+ 
+ static ssize_t iio_buffer_store_watermark(struct device *dev,
+ 					  struct device_attribute *attr,
+ 					  const char *buf,
+ 					  size_t len)
+ {
+ 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+ 	struct iio_buffer *buffer = indio_dev->buffer;
+ 	unsigned int val;
+ 	int ret;
+ 
+ 	ret = kstrtouint(buf, 10, &val);
+ 	if (ret)
+ 		return ret;
+ 	if (!val)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&indio_dev->mlock);
+ 
+ 	if (val > buffer->length) {
+ 		ret = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (iio_buffer_is_active(indio_dev->buffer)) {
+ 		ret = -EBUSY;
+ 		goto out;
+ 	}
+ 
+ 	buffer->watermark = val;
+ 
+ 	if (indio_dev->info->hwfifo_set_watermark)
+ 		indio_dev->info->hwfifo_set_watermark(indio_dev, val);
+ out:
+ 	mutex_unlock(&indio_dev->mlock);
+ 
+ 	return ret ? ret : len;
+ }
+ 
+ static DEVICE_ATTR(length, S_IRUGO | S_IWUSR, iio_buffer_read_length,
+ 		   iio_buffer_write_length);
+ static struct device_attribute dev_attr_length_ro = __ATTR(length,
+ 	S_IRUGO, iio_buffer_read_length, NULL);
+ static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR,
+ 		   iio_buffer_show_enable, iio_buffer_store_enable);
+ static DEVICE_ATTR(watermark, S_IRUGO | S_IWUSR,
+ 		   iio_buffer_show_watermark, iio_buffer_store_watermark);
+ 
+ static struct attribute *iio_buffer_attrs[] = {
+ 	&dev_attr_length.attr,
+ 	&dev_attr_enable.attr,
+ 	&dev_attr_watermark.attr,
+ };
+ 
+ int iio_buffer_alloc_sysfs_and_mask(struct iio_dev *indio_dev)
+ {
+ 	struct iio_dev_attr *p;
+ 	struct attribute **attr;
+ 	struct iio_buffer *buffer = indio_dev->buffer;
+ 	int ret, i, attrn, attrcount, attrcount_orig = 0;
+ 	const struct iio_chan_spec *channels;
+ 
+ 	if (!buffer)
+ 		return 0;
+ 
+ 	attrcount = 0;
+ 	if (buffer->attrs) {
+ 		while (buffer->attrs[attrcount] != NULL)
+ 			attrcount++;
+ 	}
+ 
+ 	attr = kcalloc(attrcount + ARRAY_SIZE(iio_buffer_attrs) + 1,
+ 		       sizeof(struct attribute *), GFP_KERNEL);
+ 	if (!attr)
+ 		return -ENOMEM;
+ 
+ 	memcpy(attr, iio_buffer_attrs, sizeof(iio_buffer_attrs));
+ 	if (!buffer->access->set_length)
+ 		attr[0] = &dev_attr_length_ro.attr;
+ 
+ 	if (buffer->attrs)
+ 		memcpy(&attr[ARRAY_SIZE(iio_buffer_attrs)], buffer->attrs,
+ 		       sizeof(struct attribute *) * attrcount);
+ 
+ 	attr[attrcount + ARRAY_SIZE(iio_buffer_attrs)] = NULL;
+ 
+ 	buffer->buffer_group.name = "buffer";
+ 	buffer->buffer_group.attrs = attr;
+ 
+ 	indio_dev->groups[indio_dev->groupcounter++] = &buffer->buffer_group;
+ 
+ 	if (buffer->scan_el_attrs != NULL) {
+ 		attr = buffer->scan_el_attrs->attrs;
+ 		while (*attr++ != NULL)
+ 			attrcount_orig++;
+ 	}
+ 	attrcount = attrcount_orig;
+ 	INIT_LIST_HEAD(&buffer->scan_el_dev_attr_list);
+ 	channels = indio_dev->channels;
+ 	if (channels) {
+ 		/* new magic */
+ 		for (i = 0; i < indio_dev->num_channels; i++) {
+ 			if (channels[i].scan_index < 0)
+ 				continue;
+ 
+ 			/* Establish necessary mask length */
+ 			if (channels[i].scan_index >
+ 			    (int)indio_dev->masklength - 1)
+ 				indio_dev->masklength
+ 					= channels[i].scan_index + 1;
+ 
+ 			ret = iio_buffer_add_channel_sysfs(indio_dev,
+ 							 &channels[i]);
+ 			if (ret < 0)
+ 				goto error_cleanup_dynamic;
+ 			attrcount += ret;
+ 			if (channels[i].type == IIO_TIMESTAMP)
+ 				indio_dev->scan_index_timestamp =
+ 					channels[i].scan_index;
+ 		}
+ 		if (indio_dev->masklength && buffer->scan_mask == NULL) {
+ 			buffer->scan_mask = kcalloc(BITS_TO_LONGS(indio_dev->masklength),
+ 						    sizeof(*buffer->scan_mask),
+ 						    GFP_KERNEL);
+ 			if (buffer->scan_mask == NULL) {
+ 				ret = -ENOMEM;
+ 				goto error_cleanup_dynamic;
+ 			}
+ 		}
+ 	}
+ 
+ 	buffer->scan_el_group.name = iio_scan_elements_group_name;
+ 
+ 	buffer->scan_el_group.attrs = kcalloc(attrcount + 1,
+ 					      sizeof(buffer->scan_el_group.attrs[0]),
+ 					      GFP_KERNEL);
+ 	if (buffer->scan_el_group.attrs == NULL) {
+ 		ret = -ENOMEM;
+ 		goto error_free_scan_mask;
+ 	}
+ 	if (buffer->scan_el_attrs)
+ 		memcpy(buffer->scan_el_group.attrs, buffer->scan_el_attrs,
+ 		       sizeof(buffer->scan_el_group.attrs[0])*attrcount_orig);
+ 	attrn = attrcount_orig;
+ 
+ 	list_for_each_entry(p, &buffer->scan_el_dev_attr_list, l)
+ 		buffer->scan_el_group.attrs[attrn++] = &p->dev_attr.attr;
+ 	indio_dev->groups[indio_dev->groupcounter++] = &buffer->scan_el_group;
+ 
+ 	return 0;
+ 
+ error_free_scan_mask:
+ 	kfree(buffer->scan_mask);
+ error_cleanup_dynamic:
+ 	iio_free_chan_devattr_list(&buffer->scan_el_dev_attr_list);
+ 	kfree(indio_dev->buffer->buffer_group.attrs);
+ 
+ 	return ret;
+ }
+ 
+ void iio_buffer_free_sysfs_and_mask(struct iio_dev *indio_dev)
+ {
+ 	if (!indio_dev->buffer)
+ 		return;
+ 
+ 	kfree(indio_dev->buffer->scan_mask);
+ 	kfree(indio_dev->buffer->buffer_group.attrs);
+ 	kfree(indio_dev->buffer->scan_el_group.attrs);
+ 	iio_free_chan_devattr_list(&indio_dev->buffer->scan_el_dev_attr_list);
+ }
++>>>>>>> f4f4673b7535 (iio: add support for hardware fifo)
  
  /**
   * iio_validate_scan_mask_onehot() - Validates that exactly one channel is selected
* Unmerged path Documentation/ABI/testing/sysfs-bus-iio
* Unmerged path drivers/iio/industrialio-buffer.c
diff --git a/include/linux/iio/iio.h b/include/linux/iio/iio.h
index c1d245faf5c1..e2d6dd5dcbd1 100644
--- a/include/linux/iio/iio.h
+++ b/include/linux/iio/iio.h
@@ -313,6 +313,16 @@ struct iio_dev;
  *			provide a custom of_xlate function that reads the
  *			*args* and returns the appropriate index in registered
  *			IIO channels array.
+ * @hwfifo_set_watermark: function pointer to set the current hardware
+ *			fifo watermark level; see hwfifo_* entries in
+ *			Documentation/ABI/testing/sysfs-bus-iio for details on
+ *			how the hardware fifo operates
+ * @hwfifo_flush_to_buffer: function pointer to flush the samples stored
+ *			in the hardware fifo to the device buffer. The driver
+ *			should not flush more than count samples. The function
+ *			must return the number of samples flushed, 0 if no
+ *			samples were flushed or a negative integer if no samples
+ *			were flushed and there was an error.
  **/
 struct iio_info {
 	struct module			*driver_module;
@@ -381,6 +391,9 @@ struct iio_info {
 				  unsigned *readval);
 	int (*of_xlate)(struct iio_dev *indio_dev,
 			const struct of_phandle_args *iiospec);
+	int (*hwfifo_set_watermark)(struct iio_dev *indio_dev, unsigned val);
+	int (*hwfifo_flush_to_buffer)(struct iio_dev *indio_dev,
+				      unsigned count);
 };
 
 /**
