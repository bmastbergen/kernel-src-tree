cxgb4: Added missing break in ndo_udp_tunnel_{add/del}

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] cxgb4: Added missing break in ndo_udp_tunnel_(add/del) (Arjun Vynipadath) [1608354]
Rebuild_FUZZ: 96.30%
commit-author Arjun Vynipadath <arjun@chelsio.com>
commit 942a656f1f228f06a37adad0e6c347773cfe7bd6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/942a656f.failed

Break statements were missing for Geneve case in
ndo_udp_tunnel_{add/del}, thereby raw mac matchall
entries were not getting added.

Fixes: c746fc0e8b2d("cxgb4: add geneve offload support for T6")
	Signed-off-by: Arjun Vynipadath <arjun@chelsio.com>
	Signed-off-by: Ganesh Goudar <ganeshgr@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 942a656f1f228f06a37adad0e6c347773cfe7bd6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 424afad66cd1,a8926e97935e..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -2991,6 -3036,176 +2991,179 @@@ static int cxgb_setup_tc(struct net_dev
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void cxgb_del_udp_tunnel(struct net_device *netdev,
+ 				struct udp_tunnel_info *ti)
+ {
+ 	struct port_info *pi = netdev_priv(netdev);
+ 	struct adapter *adapter = pi->adapter;
+ 	unsigned int chip_ver = CHELSIO_CHIP_VERSION(adapter->params.chip);
+ 	u8 match_all_mac[] = { 0, 0, 0, 0, 0, 0 };
+ 	int ret = 0, i;
+ 
+ 	if (chip_ver < CHELSIO_T6)
+ 		return;
+ 
+ 	switch (ti->type) {
+ 	case UDP_TUNNEL_TYPE_VXLAN:
+ 		if (!adapter->vxlan_port_cnt ||
+ 		    adapter->vxlan_port != ti->port)
+ 			return; /* Invalid VxLAN destination port */
+ 
+ 		adapter->vxlan_port_cnt--;
+ 		if (adapter->vxlan_port_cnt)
+ 			return;
+ 
+ 		adapter->vxlan_port = 0;
+ 		t4_write_reg(adapter, MPS_RX_VXLAN_TYPE_A, 0);
+ 		break;
+ 	case UDP_TUNNEL_TYPE_GENEVE:
+ 		if (!adapter->geneve_port_cnt ||
+ 		    adapter->geneve_port != ti->port)
+ 			return; /* Invalid GENEVE destination port */
+ 
+ 		adapter->geneve_port_cnt--;
+ 		if (adapter->geneve_port_cnt)
+ 			return;
+ 
+ 		adapter->geneve_port = 0;
+ 		t4_write_reg(adapter, MPS_RX_GENEVE_TYPE_A, 0);
+ 		break;
+ 	default:
+ 		return;
+ 	}
+ 
+ 	/* Matchall mac entries can be deleted only after all tunnel ports
+ 	 * are brought down or removed.
+ 	 */
+ 	if (!adapter->rawf_cnt)
+ 		return;
+ 	for_each_port(adapter, i) {
+ 		pi = adap2pinfo(adapter, i);
+ 		ret = t4_free_raw_mac_filt(adapter, pi->viid,
+ 					   match_all_mac, match_all_mac,
+ 					   adapter->rawf_start +
+ 					    pi->port_id,
+ 					   1, pi->port_id, false);
+ 		if (ret < 0) {
+ 			netdev_info(netdev, "Failed to free mac filter entry, for port %d\n",
+ 				    i);
+ 			return;
+ 		}
+ 		atomic_dec(&adapter->mps_encap[adapter->rawf_start +
+ 			   pi->port_id].refcnt);
+ 	}
+ }
+ 
+ static void cxgb_add_udp_tunnel(struct net_device *netdev,
+ 				struct udp_tunnel_info *ti)
+ {
+ 	struct port_info *pi = netdev_priv(netdev);
+ 	struct adapter *adapter = pi->adapter;
+ 	unsigned int chip_ver = CHELSIO_CHIP_VERSION(adapter->params.chip);
+ 	u8 match_all_mac[] = { 0, 0, 0, 0, 0, 0 };
+ 	int i, ret;
+ 
+ 	if (chip_ver < CHELSIO_T6 || !adapter->rawf_cnt)
+ 		return;
+ 
+ 	switch (ti->type) {
+ 	case UDP_TUNNEL_TYPE_VXLAN:
+ 		/* Callback for adding vxlan port can be called with the same
+ 		 * port for both IPv4 and IPv6. We should not disable the
+ 		 * offloading when the same port for both protocols is added
+ 		 * and later one of them is removed.
+ 		 */
+ 		if (adapter->vxlan_port_cnt &&
+ 		    adapter->vxlan_port == ti->port) {
+ 			adapter->vxlan_port_cnt++;
+ 			return;
+ 		}
+ 
+ 		/* We will support only one VxLAN port */
+ 		if (adapter->vxlan_port_cnt) {
+ 			netdev_info(netdev, "UDP port %d already offloaded, not adding port %d\n",
+ 				    be16_to_cpu(adapter->vxlan_port),
+ 				    be16_to_cpu(ti->port));
+ 			return;
+ 		}
+ 
+ 		adapter->vxlan_port = ti->port;
+ 		adapter->vxlan_port_cnt = 1;
+ 
+ 		t4_write_reg(adapter, MPS_RX_VXLAN_TYPE_A,
+ 			     VXLAN_V(be16_to_cpu(ti->port)) | VXLAN_EN_F);
+ 		break;
+ 	case UDP_TUNNEL_TYPE_GENEVE:
+ 		if (adapter->geneve_port_cnt &&
+ 		    adapter->geneve_port == ti->port) {
+ 			adapter->geneve_port_cnt++;
+ 			return;
+ 		}
+ 
+ 		/* We will support only one GENEVE port */
+ 		if (adapter->geneve_port_cnt) {
+ 			netdev_info(netdev, "UDP port %d already offloaded, not adding port %d\n",
+ 				    be16_to_cpu(adapter->geneve_port),
+ 				    be16_to_cpu(ti->port));
+ 			return;
+ 		}
+ 
+ 		adapter->geneve_port = ti->port;
+ 		adapter->geneve_port_cnt = 1;
+ 
+ 		t4_write_reg(adapter, MPS_RX_GENEVE_TYPE_A,
+ 			     GENEVE_V(be16_to_cpu(ti->port)) | GENEVE_EN_F);
+ 		break;
+ 	default:
+ 		return;
+ 	}
+ 
+ 	/* Create a 'match all' mac filter entry for inner mac,
+ 	 * if raw mac interface is supported. Once the linux kernel provides
+ 	 * driver entry points for adding/deleting the inner mac addresses,
+ 	 * we will remove this 'match all' entry and fallback to adding
+ 	 * exact match filters.
+ 	 */
+ 	for_each_port(adapter, i) {
+ 		pi = adap2pinfo(adapter, i);
+ 
+ 		ret = t4_alloc_raw_mac_filt(adapter, pi->viid,
+ 					    match_all_mac,
+ 					    match_all_mac,
+ 					    adapter->rawf_start +
+ 					    pi->port_id,
+ 					    1, pi->port_id, false);
+ 		if (ret < 0) {
+ 			netdev_info(netdev, "Failed to allocate a mac filter entry, not adding port %d\n",
+ 				    be16_to_cpu(ti->port));
+ 			cxgb_del_udp_tunnel(netdev, ti);
+ 			return;
+ 		}
+ 		atomic_inc(&adapter->mps_encap[ret].refcnt);
+ 	}
+ }
+ 
+ static netdev_features_t cxgb_features_check(struct sk_buff *skb,
+ 					     struct net_device *dev,
+ 					     netdev_features_t features)
+ {
+ 	struct port_info *pi = netdev_priv(dev);
+ 	struct adapter *adapter = pi->adapter;
+ 
+ 	if (CHELSIO_CHIP_VERSION(adapter->params.chip) < CHELSIO_T6)
+ 		return features;
+ 
+ 	/* Check if hw supports offload for this packet */
+ 	if (!skb->encapsulation || cxgb_encap_offload_supported(skb))
+ 		return features;
+ 
+ 	/* Offload is not supported for this encapsulated packet */
+ 	return features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);
+ }
+ 
++>>>>>>> 942a656f1f22 (cxgb4: Added missing break in ndo_udp_tunnel_{add/del})
  static netdev_features_t cxgb_fix_features(struct net_device *dev,
  					   netdev_features_t features)
  {
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
