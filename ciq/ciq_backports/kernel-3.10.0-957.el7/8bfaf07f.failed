net/mlx5e: Present SW stats when state is not opened

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Present SW stats when state is not opened (Alaa Hleihel) [1618609]
Rebuild_FUZZ: 96.00%
commit-author Eran Ben Elisha <eranbe@mellanox.com>
commit 8bfaf07f780683948a3183d3b14a76dfd50bf899
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8bfaf07f.failed

The driver can present all SW stats even when the state not opened.
Fixed get strings, count and stats to support it.

In addition, fix tc2txq to hold a static mapping which doesn't depend on
the amount of open channels, and cannot have the same value on two
different cells  while moving between configurations.
Example:
- OOB 16 channels
- Change to 2 channels, 8 TCs
- tc2txq[15][0] == tc2txq[1][7] == 15
This will cause multiple appearances of the same TX index in statistics
output.

Fixes: 76c3810bade3 ("net/mlx5e: Avoid reset netdev stats on configuration changes")
	Signed-off-by: Eran Ben Elisha <eranbe@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 8bfaf07f780683948a3183d3b14a76dfd50bf899)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_stats.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index a42a2f9547cb,adc55de6d4f4..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -2417,10 -2649,6 +2427,13 @@@ static void mlx5e_build_tx2sq_maps(stru
  	struct mlx5e_txqsq *sq;
  	int i, tc;
  
++<<<<<<< HEAD
 +	for (i = 0; i < priv->channels.num; i++)
 +		for (tc = 0; tc < priv->profile->max_tc; tc++)
 +			priv->channel_tc2txq[i][tc] = i + tc * priv->channels.num;
 +
++=======
++>>>>>>> 8bfaf07f7806 (net/mlx5e: Present SW stats when state is not opened)
  	for (i = 0; i < priv->channels.num; i++) {
  		c = priv->channels.c[i];
  		for (tc = 0; tc < c->num_tc; tc++) {
@@@ -2439,11 -2667,14 +2452,11 @@@ void mlx5e_activate_priv_channels(struc
  	netif_set_real_num_tx_queues(netdev, num_txqs);
  	netif_set_real_num_rx_queues(netdev, priv->channels.num);
  
- 	mlx5e_build_channels_tx_maps(priv);
+ 	mlx5e_build_tx2sq_maps(priv);
  	mlx5e_activate_channels(&priv->channels);
 -	write_lock(&priv->stats_lock);
 -	priv->channels_active = true;
 -	write_unlock(&priv->stats_lock);
  	netif_tx_start_all_queues(priv->netdev);
  
 -	if (MLX5_VPORT_MANAGER(priv->mdev))
 +	if (MLX5_ESWITCH_MANAGER(priv->mdev))
  		mlx5e_add_sqs_fwd_rules(priv);
  
  	mlx5e_wait_channels_min_rx_wqes(&priv->channels);
@@@ -4013,7 -4448,11 +4026,8 @@@ static void mlx5e_nic_init(struct mlx5_
  	err = mlx5e_ipsec_init(priv);
  	if (err)
  		mlx5_core_err(mdev, "IPSec initialization failed, %d\n", err);
 -	err = mlx5e_tls_init(priv);
 -	if (err)
 -		mlx5_core_err(mdev, "TLS initialization failed, %d\n", err);
  	mlx5e_build_nic_netdev(netdev);
+ 	mlx5e_build_tc2txq_maps(priv);
  	mlx5e_vxlan_init(priv);
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_stats.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_stats.c
