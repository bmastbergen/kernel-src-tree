mlxsw: spectrum: qdiscs: Create a generic replace function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Nogah Frankel <nogahf@mellanox.com>
commit 9cf6c9c7585446f1a532d218ae9be8653f4d7a82
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9cf6c9c7.failed

Create a generic qdisc replace function.
For that goal, add three functions to the qdisc ops struct:
* check_params: Checks if the given parameters are offloadable.
* replace: Offload the given parameters.
* clean_stats: clean the qdisc stats for the offloaded qdisc.
integrate RED offloading into using the new internal replace API.

	Signed-off-by: Nogah Frankel <nogahf@mellanox.com>
	Reviewed-by: Yuval Mintz <yuvalm@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9cf6c9c7585446f1a532d218ae9be8653f4d7a82)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
index b5397da94d7f,c896ee721523..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
@@@ -41,6 -41,131 +41,134 @@@
  #include "spectrum.h"
  #include "reg.h"
  
++<<<<<<< HEAD
++=======
+ enum mlxsw_sp_qdisc_type {
+ 	MLXSW_SP_QDISC_NO_QDISC,
+ 	MLXSW_SP_QDISC_RED,
+ };
+ 
+ struct mlxsw_sp_qdisc_ops {
+ 	enum mlxsw_sp_qdisc_type type;
+ 	int (*check_params)(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			    struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			    void *params);
+ 	int (*replace)(struct mlxsw_sp_port *mlxsw_sp_port,
+ 		       struct mlxsw_sp_qdisc *mlxsw_sp_qdisc, void *params);
+ 	int (*destroy)(struct mlxsw_sp_port *mlxsw_sp_port,
+ 		       struct mlxsw_sp_qdisc *mlxsw_sp_qdisc);
+ 	int (*get_stats)(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			 struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			 struct tc_qopt_offload_stats *stats_ptr);
+ 	int (*get_xstats)(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			  struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			  void *xstats_ptr);
+ 	void (*clean_stats)(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			    struct mlxsw_sp_qdisc *mlxsw_sp_qdisc);
+ };
+ 
+ struct mlxsw_sp_qdisc {
+ 	u32 handle;
+ 	u8 tclass_num;
+ 	union {
+ 		struct red_stats red;
+ 	} xstats_base;
+ 	struct mlxsw_sp_qdisc_stats {
+ 		u64 tx_bytes;
+ 		u64 tx_packets;
+ 		u64 drops;
+ 		u64 overlimits;
+ 	} stats_base;
+ 
+ 	struct mlxsw_sp_qdisc_ops *ops;
+ };
+ 
+ static bool
+ mlxsw_sp_qdisc_compare(struct mlxsw_sp_qdisc *mlxsw_sp_qdisc, u32 handle,
+ 		       enum mlxsw_sp_qdisc_type type)
+ {
+ 	return mlxsw_sp_qdisc && mlxsw_sp_qdisc->ops &&
+ 	       mlxsw_sp_qdisc->ops->type == type &&
+ 	       mlxsw_sp_qdisc->handle == handle;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_destroy(struct mlxsw_sp_port *mlxsw_sp_port,
+ 		       struct mlxsw_sp_qdisc *mlxsw_sp_qdisc)
+ {
+ 	int err = 0;
+ 
+ 	if (!mlxsw_sp_qdisc)
+ 		return 0;
+ 
+ 	if (mlxsw_sp_qdisc->ops && mlxsw_sp_qdisc->ops->destroy)
+ 		err = mlxsw_sp_qdisc->ops->destroy(mlxsw_sp_port,
+ 						   mlxsw_sp_qdisc);
+ 
+ 	mlxsw_sp_qdisc->handle = TC_H_UNSPEC;
+ 	mlxsw_sp_qdisc->ops = NULL;
+ 	return err;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_replace(struct mlxsw_sp_port *mlxsw_sp_port, u32 handle,
+ 		       struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 		       struct mlxsw_sp_qdisc_ops *ops, void *params)
+ {
+ 	int err;
+ 
+ 	err = ops->check_params(mlxsw_sp_port, mlxsw_sp_qdisc, params);
+ 	if (err)
+ 		goto err_bad_param;
+ 
+ 	err = ops->replace(mlxsw_sp_port, mlxsw_sp_qdisc, params);
+ 	if (err)
+ 		goto err_config;
+ 
+ 	if (mlxsw_sp_qdisc->handle != handle) {
+ 		mlxsw_sp_qdisc->ops = ops;
+ 		if (ops->clean_stats)
+ 			ops->clean_stats(mlxsw_sp_port, mlxsw_sp_qdisc);
+ 	}
+ 
+ 	mlxsw_sp_qdisc->handle = handle;
+ 	return 0;
+ 
+ err_bad_param:
+ err_config:
+ 	mlxsw_sp_qdisc_destroy(mlxsw_sp_port, mlxsw_sp_qdisc);
+ 	return err;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_get_stats(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			 struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			 struct tc_qopt_offload_stats *stats_ptr)
+ {
+ 	if (mlxsw_sp_qdisc && mlxsw_sp_qdisc->ops &&
+ 	    mlxsw_sp_qdisc->ops->get_stats)
+ 		return mlxsw_sp_qdisc->ops->get_stats(mlxsw_sp_port,
+ 						      mlxsw_sp_qdisc,
+ 						      stats_ptr);
+ 
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_get_xstats(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			  struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			  void *xstats_ptr)
+ {
+ 	if (mlxsw_sp_qdisc && mlxsw_sp_qdisc->ops &&
+ 	    mlxsw_sp_qdisc->ops->get_xstats)
+ 		return mlxsw_sp_qdisc->ops->get_xstats(mlxsw_sp_port,
+ 						      mlxsw_sp_qdisc,
+ 						      xstats_ptr);
+ 
+ 	return -EOPNOTSUPP;
+ }
+ 
++>>>>>>> 9cf6c9c75854 (mlxsw: spectrum: qdiscs: Create a generic replace function)
  static int
  mlxsw_sp_tclass_congestion_enable(struct mlxsw_sp_port *mlxsw_sp_port,
  				  int tclass_num, u32 min, u32 max,
@@@ -128,15 -238,12 +256,24 @@@ mlxsw_sp_qdisc_red_destroy(struct mlxsw
  }
  
  static int
++<<<<<<< HEAD
 +mlxsw_sp_qdisc_red_replace(struct mlxsw_sp_port *mlxsw_sp_port, u32 handle,
 +			   struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
 +			   int tclass_num,
 +			   struct tc_red_qopt_offload_params *p)
 +{
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
 +	u32 min, max;
 +	u64 prob;
 +	int err = 0;
++=======
+ mlxsw_sp_qdisc_red_check_params(struct mlxsw_sp_port *mlxsw_sp_port,
+ 				struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 				void *params)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
+ 	struct tc_red_qopt_offload_params *p = params;
++>>>>>>> 9cf6c9c75854 (mlxsw: spectrum: qdiscs: Create a generic replace function)
  
  	if (p->min > p->max) {
  		dev_err(mlxsw_sp->bus_info->dev,
@@@ -162,26 -282,8 +312,31 @@@ mlxsw_sp_qdisc_red_replace(struct mlxsw
  	prob = DIV_ROUND_UP(prob, 1 << 16);
  	min = mlxsw_sp_bytes_cells(mlxsw_sp, p->min);
  	max = mlxsw_sp_bytes_cells(mlxsw_sp, p->max);
++<<<<<<< HEAD
 +	err = mlxsw_sp_tclass_congestion_enable(mlxsw_sp_port, tclass_num, min,
 +						max, prob, p->is_ecn);
 +	if (err)
 +		goto err_config;
 +
 +	mlxsw_sp_qdisc->type = MLXSW_SP_QDISC_RED;
 +	if (mlxsw_sp_qdisc->handle != handle)
 +		mlxsw_sp_setup_tc_qdisc_clean_stats(mlxsw_sp_port,
 +						    mlxsw_sp_qdisc,
 +						    tclass_num);
 +
 +	mlxsw_sp_qdisc->handle = handle;
 +	return 0;
 +
 +err_bad_param:
 +	err = -EINVAL;
 +err_config:
 +	mlxsw_sp_qdisc_red_destroy(mlxsw_sp_port, mlxsw_sp_qdisc->handle,
 +				   mlxsw_sp_qdisc, tclass_num);
 +	return err;
++=======
+ 	return mlxsw_sp_tclass_congestion_enable(mlxsw_sp_port, tclass_num, min,
+ 						 max, prob, p->is_ecn);
++>>>>>>> 9cf6c9c75854 (mlxsw: spectrum: qdiscs: Create a generic replace function)
  }
  
  static int
@@@ -243,6 -351,16 +398,19 @@@ mlxsw_sp_qdisc_get_red_stats(struct mlx
  
  #define MLXSW_SP_PORT_DEFAULT_TCLASS 0
  
++<<<<<<< HEAD
++=======
+ static struct mlxsw_sp_qdisc_ops mlxsw_sp_qdisc_ops_red = {
+ 	.type = MLXSW_SP_QDISC_RED,
+ 	.check_params = mlxsw_sp_qdisc_red_check_params,
+ 	.replace = mlxsw_sp_qdisc_red_replace,
+ 	.destroy = mlxsw_sp_qdisc_red_destroy,
+ 	.get_stats = mlxsw_sp_qdisc_get_red_stats,
+ 	.get_xstats = mlxsw_sp_qdisc_get_red_xstats,
+ 	.clean_stats = mlxsw_sp_setup_tc_qdisc_red_clean_stats,
+ };
+ 
++>>>>>>> 9cf6c9c75854 (mlxsw: spectrum: qdiscs: Create a generic replace function)
  int mlxsw_sp_setup_tc_red(struct mlxsw_sp_port *mlxsw_sp_port,
  			  struct tc_red_qopt_offload *p)
  {
@@@ -252,25 -369,27 +420,39 @@@
  	if (p->parent != TC_H_ROOT)
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	mlxsw_sp_qdisc = &mlxsw_sp_port->root_qdisc;
 +	tclass_num = MLXSW_SP_PORT_DEFAULT_TCLASS;
++=======
+ 	mlxsw_sp_qdisc = mlxsw_sp_port->root_qdisc;
+ 
+ 	if (p->command == TC_RED_REPLACE)
+ 		return mlxsw_sp_qdisc_replace(mlxsw_sp_port, p->handle,
+ 					      mlxsw_sp_qdisc,
+ 					      &mlxsw_sp_qdisc_ops_red,
+ 					      &p->set);
+ 
+ 	if (!mlxsw_sp_qdisc_compare(mlxsw_sp_qdisc, p->handle,
+ 				    MLXSW_SP_QDISC_RED))
+ 		return -EOPNOTSUPP;
++>>>>>>> 9cf6c9c75854 (mlxsw: spectrum: qdiscs: Create a generic replace function)
  
  	switch (p->command) {
 +	case TC_RED_REPLACE:
 +		return mlxsw_sp_qdisc_red_replace(mlxsw_sp_port, p->handle,
 +						  mlxsw_sp_qdisc, tclass_num,
 +						  &p->set);
  	case TC_RED_DESTROY:
 -		return mlxsw_sp_qdisc_destroy(mlxsw_sp_port, mlxsw_sp_qdisc);
 +		return mlxsw_sp_qdisc_red_destroy(mlxsw_sp_port, p->handle,
 +						  mlxsw_sp_qdisc, tclass_num);
  	case TC_RED_XSTATS:
 -		return mlxsw_sp_qdisc_get_xstats(mlxsw_sp_port, mlxsw_sp_qdisc,
 -						 p->xstats);
 +		return mlxsw_sp_qdisc_get_red_xstats(mlxsw_sp_port, p->handle,
 +						     mlxsw_sp_qdisc, tclass_num,
 +						     p->xstats);
  	case TC_RED_STATS:
 -		return mlxsw_sp_qdisc_get_stats(mlxsw_sp_port, mlxsw_sp_qdisc,
 -						&p->stats);
 +		return mlxsw_sp_qdisc_get_red_stats(mlxsw_sp_port, p->handle,
 +						    mlxsw_sp_qdisc, tclass_num,
 +						    &p->stats);
  	default:
  		return -EOPNOTSUPP;
  	}
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
