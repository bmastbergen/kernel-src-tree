scsi: qla2xxx: Remove unused argument from qlt_schedule_sess_for_deletion()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Remove unused argument from qlt_schedule_sess_for_deletion() (Himanshu Madhani) [1547714]
Rebuild_FUZZ: 95.83%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit 94cff6e114df56d0df74cdabe3481df38d9b0c1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/94cff6e1.failed

Immeadiate flag is not used for scheduling session deletion.
Remove it to simplfy session deletion code path.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 94cff6e114df56d0df74cdabe3481df38d9b0c1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index bc98a1a62b13,aaa8c07b2d8d..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -272,6 -280,102 +272,105 @@@ done
  	return rval;
  }
  
++<<<<<<< HEAD
++=======
+ void
+ qla2x00_async_prlo_done(struct scsi_qla_host *vha, fc_port_t *fcport,
+     uint16_t *data)
+ {
+ 	/* Don't re-login in target mode */
+ 	if (!fcport->tgt_session)
+ 		qla2x00_mark_device_lost(vha, fcport, 1, 0);
+ 	qlt_logo_completion_handler(fcport, data[0]);
+ }
+ 
+ static void
+ qla2x00_async_prlo_sp_done(void *s, int res)
+ {
+ 	srb_t *sp = (srb_t *)s;
+ 	struct srb_iocb *lio = &sp->u.iocb_cmd;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 
+ 	if (!test_bit(UNLOADING, &vha->dpc_flags))
+ 		qla2x00_post_async_prlo_done_work(sp->fcport->vha, sp->fcport,
+ 		    lio->u.logio.data);
+ 	sp->free(sp);
+ }
+ 
+ int
+ qla2x00_async_prlo(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	srb_t *sp;
+ 	struct srb_iocb *lio;
+ 	int rval;
+ 
+ 	rval = QLA_FUNCTION_FAILED;
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	sp->type = SRB_PRLO_CMD;
+ 	sp->name = "prlo";
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	lio = &sp->u.iocb_cmd;
+ 	lio->timeout = qla2x00_async_iocb_timeout;
+ 	sp->done = qla2x00_async_prlo_sp_done;
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x2070,
+ 	    "Async-prlo - hdl=%x loop-id=%x portid=%02x%02x%02x.\n",
+ 	    sp->handle, fcport->loop_id, fcport->d_id.b.domain,
+ 	    fcport->d_id.b.area, fcport->d_id.b.al_pa);
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ done:
+ 	return rval;
+ }
+ 
+ static
+ void qla24xx_handle_adisc_event(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	struct fc_port *fcport = ea->fcport;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x20d2,
+ 	    "%s %8phC DS %d LS %d rc %d login %d|%d rscn %d|%d lid %d\n",
+ 	    __func__, fcport->port_name, fcport->disc_state,
+ 	    fcport->fw_login_state, ea->rc, fcport->login_gen, ea->sp->gen2,
+ 	    fcport->rscn_gen, ea->sp->gen1, fcport->loop_id);
+ 
+ 	if (ea->data[0] != MBS_COMMAND_COMPLETE) {
+ 		ql_dbg(ql_dbg_disc, vha, 0x2066,
+ 		    "%s %8phC: adisc fail: post delete\n",
+ 		    __func__, ea->fcport->port_name);
+ 		qlt_schedule_sess_for_deletion(ea->fcport);
+ 		return;
+ 	}
+ 
+ 	if (ea->fcport->disc_state == DSC_DELETE_PEND)
+ 		return;
+ 
+ 	if (ea->sp->gen2 != ea->fcport->login_gen) {
+ 		/* target side must have changed it. */
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d3,
+ 		    "%s %8phC generation changed\n",
+ 		    __func__, ea->fcport->port_name);
+ 		return;
+ 	} else if (ea->sp->gen1 != ea->fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d4, "%s %d %8phC post gidpn\n",
+ 		    __func__, __LINE__, ea->fcport->port_name);
+ 		qla24xx_post_gidpn_work(vha, ea->fcport);
+ 		return;
+ 	}
+ 
+ 	__qla24xx_handle_gpdb_event(vha, ea);
+ }
+ 
++>>>>>>> 94cff6e114df (scsi: qla2xxx: Remove unused argument from qlt_schedule_sess_for_deletion())
  static void
  qla2x00_async_adisc_sp_done(void *ptr, int res)
  {
@@@ -445,36 -582,29 +544,49 @@@ static void qla24xx_handle_gnl_done_eve
  
  	if (!found) {
  		/* fw has no record of this port */
 -		for (i = 0; i < n; i++) {
 -			e = &vha->gnl.l[i];
 -			id.b.domain = e->port_id[0];
 -			id.b.area = e->port_id[1];
 -			id.b.al_pa = e->port_id[2];
 -			id.b.rsvd_1 = 0;
 -			loop_id = le16_to_cpu(e->nport_handle);
 +		if (fcport->loop_id == FC_NO_LOOP_ID) {
 +			qla2x00_find_new_loop_id(vha, fcport);
 +			fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;
 +		} else {
 +			for (i = 0; i < n; i++) {
 +				e = &vha->gnl.l[i];
 +				id.b.domain = e->port_id[0];
 +				id.b.area = e->port_id[1];
 +				id.b.al_pa = e->port_id[2];
 +				id.b.rsvd_1 = 0;
 +				loop_id = le16_to_cpu(e->nport_handle);
 +
++<<<<<<< HEAD
 +				if (fcport->d_id.b24 == id.b24) {
 +					conflict_fcport =
 +					    qla2x00_find_fcport_by_wwpn(vha,
 +						e->port_name, 0);
 +
 +					ql_dbg(ql_dbg_disc, vha, 0x20e6,
 +					    "%s %d %8phC post del sess\n",
 +					    __func__, __LINE__,
 +					    conflict_fcport->port_name);
 +					qlt_schedule_sess_for_deletion
 +						(conflict_fcport, 1);
 +				}
  
 +				if (fcport->loop_id == loop_id) {
 +					/* FW already picked this loop id for another fcport */
 +					qla2x00_find_new_loop_id(vha, fcport);
 +				}
++=======
+ 			if (fcport->d_id.b24 == id.b24) {
+ 				conflict_fcport =
+ 					qla2x00_find_fcport_by_wwpn(vha,
+ 					    e->port_name, 0);
+ 				ql_dbg(ql_dbg_disc, vha, 0x20e6,
+ 				    "%s %d %8phC post del sess\n",
+ 				    __func__, __LINE__,
+ 				    conflict_fcport->port_name);
+ 				qlt_schedule_sess_for_deletion
+ 					(conflict_fcport);
++>>>>>>> 94cff6e114df (scsi: qla2xxx: Remove unused argument from qlt_schedule_sess_for_deletion())
  			}
 -
 -			/* FW already picked this loop id for another fcport */
 -			if (fcport->loop_id == loop_id)
 -				fcport->loop_id = FC_NO_LOOP_ID;
  		}
  		qla24xx_fcport_handle_login(vha, fcport);
  	}
@@@ -822,23 -1046,112 +934,74 @@@ void qla24xx_handle_gpdb_event(scsi_qla
  		/*
  		 * We have an existing session. A late RSCN delivery
  		 * must have triggered the session to be re-validate.
 -		 * Session is still valid.
 +		 * session is still valid.
  		 */
 -		ql_dbg(ql_dbg_disc, vha, 0x20d6,
 -		    "%s %d %8phC session revalidate success\n",
 -		    __func__, __LINE__, ea->fcport->port_name);
 -		 ea->fcport->disc_state = DSC_LOGIN_COMPLETE;
 +		fcport->disc_state = DSC_LOGIN_COMPLETE;
  	}
  	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
 -}
 -
 -static
 -void qla24xx_handle_gpdb_event(scsi_qla_host_t *vha, struct event_arg *ea)
 -{
 -	fc_port_t *fcport = ea->fcport;
 -	struct port_database_24xx *pd;
 -	struct srb *sp = ea->sp;
 -
 -	pd = (struct port_database_24xx *)sp->u.iocb_cmd.u.mbx.in;
 -
 -	fcport->flags &= ~FCF_ASYNC_SENT;
 -
 -	ql_dbg(ql_dbg_disc, vha, 0x20d2,
 -	    "%s %8phC DS %d LS %d rc %d\n", __func__, fcport->port_name,
 -	    fcport->disc_state, pd->current_login_state, ea->rc);
 -
 -	if (fcport->disc_state == DSC_DELETE_PEND)
 -		return;
 -
 -	switch (pd->current_login_state) {
 -	case PDS_PRLI_COMPLETE:
 -		__qla24xx_parse_gpdb(vha, fcport, pd);
 -		break;
 -	case PDS_PLOGI_PENDING:
 -	case PDS_PLOGI_COMPLETE:
 -	case PDS_PRLI_PENDING:
 -	case PDS_PRLI2_PENDING:
 -		ql_dbg(ql_dbg_disc, vha, 0x20d5, "%s %d %8phC relogin needed\n",
 -		    __func__, __LINE__, fcport->port_name);
 -		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
 -		return;
 -	case PDS_LOGO_PENDING:
 -	case PDS_PORT_UNAVAILABLE:
 -	default:
 -		ql_dbg(ql_dbg_disc, vha, 0x20d5, "%s %d %8phC post del sess\n",
 -		    __func__, __LINE__, fcport->port_name);
 -		qlt_schedule_sess_for_deletion_lock(fcport);
 -		return;
 -	}
 -	__qla24xx_handle_gpdb_event(vha, ea);
  } /* gpdb event */
  
++<<<<<<< HEAD
++=======
+ static void qla_chk_n2n_b4_login(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	u8 login = 0;
+ 	int rc;
+ 
+ 	if (qla_tgt_mode_enabled(vha))
+ 		return;
+ 
+ 	if (qla_dual_mode_enabled(vha)) {
+ 		if (N2N_TOPO(vha->hw)) {
+ 			u64 mywwn, wwn;
+ 
+ 			mywwn = wwn_to_u64(vha->port_name);
+ 			wwn = wwn_to_u64(fcport->port_name);
+ 			if (mywwn > wwn)
+ 				login = 1;
+ 			else if ((fcport->fw_login_state == DSC_LS_PLOGI_COMP)
+ 			    && time_after_eq(jiffies,
+ 				    fcport->plogi_nack_done_deadline))
+ 				login = 1;
+ 		} else {
+ 			login = 1;
+ 		}
+ 	} else {
+ 		/* initiator mode */
+ 		login = 1;
+ 	}
+ 
+ 	if (login) {
+ 		if (fcport->loop_id == FC_NO_LOOP_ID) {
+ 			fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;
+ 			rc = qla2x00_find_new_loop_id(vha, fcport);
+ 			if (rc) {
+ 				ql_dbg(ql_dbg_disc, vha, 0x20e6,
+ 				    "%s %d %8phC post del sess - out of loopid\n",
+ 				    __func__, __LINE__, fcport->port_name);
+ 				fcport->scan_state = 0;
+ 				qlt_schedule_sess_for_deletion(fcport);
+ 				return;
+ 			}
+ 		}
+ 		ql_dbg(ql_dbg_disc, vha, 0x20bf,
+ 		    "%s %d %8phC post login\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		qla2x00_post_async_login_work(vha, fcport, NULL);
+ 	}
+ }
+ 
++>>>>>>> 94cff6e114df (scsi: qla2xxx: Remove unused argument from qlt_schedule_sess_for_deletion())
  int qla24xx_fcport_handle_login(struct scsi_qla_host *vha, fc_port_t *fcport)
  {
 -	u16 data[2];
 -	u64 wwn;
 +	if (fcport->login_retry == 0)
 +		return 0;
 +
 +	if (fcport->scan_state != QLA_FCPORT_FOUND)
 +		return 0;
  
  	ql_dbg(ql_dbg_disc, vha, 0x20d8,
 -	    "%s %8phC DS %d LS %d P %d fl %x confl %p rscn %d|%d login %d retry %d lid %d scan %d\n",
 +	    "%s %8phC DS %d LS %d P %d fl %x confl %p rscn %d|%d login %d|%d retry %d lid %d\n",
  	    __func__, fcport->port_name, fcport->disc_state,
  	    fcport->fw_login_state, fcport->login_pause, fcport->flags,
  	    fcport->conflict, fcport->last_rscn_gen, fcport->rscn_gen,
@@@ -1374,8 -1750,38 +1537,43 @@@ qla24xx_handle_plogi_done_event(struct 
  		    ea->fcport->d_id.b.domain, ea->fcport->d_id.b.area,
  		    ea->fcport->d_id.b.al_pa);
  
++<<<<<<< HEAD
 +		qla2x00_clear_loop_id(ea->fcport);
 +		qla24xx_post_gidpn_work(vha, ea->fcport);
++=======
+ 		lid = ea->iop[1] & 0xffff;
+ 		qlt_find_sess_invalidate_other(vha,
+ 		    wwn_to_u64(ea->fcport->port_name),
+ 		    ea->fcport->d_id, lid, &conflict_fcport);
+ 
+ 		if (conflict_fcport) {
+ 			/*
+ 			 * Another fcport share the same loop_id/nport id.
+ 			 * Conflict fcport needs to finish cleanup before this
+ 			 * fcport can proceed to login.
+ 			 */
+ 			conflict_fcport->conflict = ea->fcport;
+ 			ea->fcport->login_pause = 1;
+ 
+ 			ql_dbg(ql_dbg_disc, vha, 0x20ed,
+ 			    "%s %d %8phC NPortId %06x inuse with loopid 0x%x. post gidpn\n",
+ 			    __func__, __LINE__, ea->fcport->port_name,
+ 			    ea->fcport->d_id.b24, lid);
+ 			qla2x00_clear_loop_id(ea->fcport);
+ 			qla24xx_post_gidpn_work(vha, ea->fcport);
+ 		} else {
+ 			ql_dbg(ql_dbg_disc, vha, 0x20ed,
+ 			    "%s %d %8phC NPortId %06x inuse with loopid 0x%x. sched delete\n",
+ 			    __func__, __LINE__, ea->fcport->port_name,
+ 			    ea->fcport->d_id.b24, lid);
+ 
+ 			qla2x00_clear_loop_id(ea->fcport);
+ 			set_bit(lid, vha->hw->loop_id_map);
+ 			ea->fcport->loop_id = lid;
+ 			ea->fcport->keep_nport_handle = 0;
+ 			qlt_schedule_sess_for_deletion(ea->fcport);
+ 		}
++>>>>>>> 94cff6e114df (scsi: qla2xxx: Remove unused argument from qlt_schedule_sess_for_deletion())
  		break;
  	}
  	return;
diff --git a/drivers/scsi/qla2xxx/qla_gbl.h b/drivers/scsi/qla2xxx/qla_gbl.h
index b82df4e47b9c..cd3cf1283b99 100644
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@ -854,7 +854,7 @@ void qla24xx_do_nack_work(struct scsi_qla_host *, struct qla_work_evt *);
 void qlt_plogi_ack_link(struct scsi_qla_host *, struct qlt_plogi_ack_t *,
 	struct fc_port *, enum qlt_plogi_link_t);
 void qlt_plogi_ack_unref(struct scsi_qla_host *, struct qlt_plogi_ack_t *);
-extern void qlt_schedule_sess_for_deletion(struct fc_port *, bool);
+extern void qlt_schedule_sess_for_deletion(struct fc_port *);
 extern void qlt_schedule_sess_for_deletion_lock(struct fc_port *);
 extern struct fc_port *qlt_find_sess_invalidate_other(scsi_qla_host_t *,
 	uint64_t wwn, port_id_t port_id, uint16_t loop_id, struct fc_port **);
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c
index 3c5690bebff9..31e8deb18c80 100644
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@ -1168,8 +1168,7 @@ static void qla24xx_chk_fcp_state(struct fc_port *sess)
 }
 
 /* ha->tgt.sess_lock supposed to be held on entry */
-void qlt_schedule_sess_for_deletion(struct fc_port *sess,
-	bool immediate)
+void qlt_schedule_sess_for_deletion(struct fc_port *sess)
 {
 	struct qla_tgt *tgt = sess->tgt;
 
@@ -1207,7 +1206,7 @@ void qlt_schedule_sess_for_deletion_lock(struct fc_port *sess)
 	unsigned long flags;
 	struct qla_hw_data *ha = sess->vha->hw;
 	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
-	qlt_schedule_sess_for_deletion(sess, 1);
+	qlt_schedule_sess_for_deletion(sess);
 	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);
 }
 
@@ -1219,7 +1218,7 @@ static void qlt_clear_tgt_db(struct qla_tgt *tgt)
 
 	list_for_each_entry(sess, &vha->vp_fcports, list) {
 		if (sess->se_sess)
-			qlt_schedule_sess_for_deletion(sess, 1);
+			qlt_schedule_sess_for_deletion(sess);
 	}
 
 	/* At this point tgt could be already dead */
@@ -1394,7 +1393,7 @@ qlt_fc_port_deleted(struct scsi_qla_host *vha, fc_port_t *fcport, int max_gen)
 	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf008, "qla_tgt_fc_port_deleted %p", sess);
 
 	sess->local = 1;
-	qlt_schedule_sess_for_deletion(sess, false);
+	qlt_schedule_sess_for_deletion(sess);
 	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
 }
 
@@ -4586,7 +4585,7 @@ qlt_find_sess_invalidate_other(scsi_qla_host_t *vha, uint64_t wwn,
 				 * might have cleared it when requested this session
 				 * deletion, so don't touch it
 				 */
-				qlt_schedule_sess_for_deletion(other_sess, true);
+				qlt_schedule_sess_for_deletion(other_sess);
 			} else {
 				/*
 				 * Another wwn used to have our s_id/loop_id
@@ -4599,8 +4598,7 @@ qlt_find_sess_invalidate_other(scsi_qla_host_t *vha, uint64_t wwn,
 				other_sess->keep_nport_handle = 1;
 				if (other_sess->disc_state != DSC_DELETED)
 					*conflict_sess = other_sess;
-				qlt_schedule_sess_for_deletion(other_sess,
-				    true);
+				qlt_schedule_sess_for_deletion(other_sess);
 			}
 			continue;
 		}
@@ -4614,7 +4612,7 @@ qlt_find_sess_invalidate_other(scsi_qla_host_t *vha, uint64_t wwn,
 
 			/* Same loop_id but different s_id
 			 * Ok to kill and logout */
-			qlt_schedule_sess_for_deletion(other_sess, true);
+			qlt_schedule_sess_for_deletion(other_sess);
 		}
 	}
 
