perf top: Add option to set the number of thread for event synthesize

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Kan Liang <kan.liang@intel.com>
commit 0c6b499495e928777c41ca2de4fbb58788269690
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0c6b4994.failed

Using UINT_MAX to indicate the default thread#, which is the max number
of online CPU.

Committer testing:

  # perf trace --no-inherit -e clone -o /tmp/output perf top --num-thread-synthesize 9
  # cat /tmp/output
         ? (     ?   ):  ... [continued]: clone()) = 26651 (perf)
     0.059 ( 0.010 ms): clone(flags: VM|FS|FILES|SIGHAND|THREAD|SYSVSEM|SETTLS|PARENT_SETTID|CHILD_CLEARTID, child_stack: 0x7f5bfac44f30, parent_tidptr: 0x7f5bfac459d0, child_tidptr: 0x7f5bfac459d0, tls: 0x7f5bfac45700) = 26652 (perf)
     0.116 ( 0.014 ms): clone(flags: VM|FS|FILES|SIGHAND|THREAD|SYSVSEM|SETTLS|PARENT_SETTID|CHILD_CLEARTID, child_stack: 0x7f5bfa443f30, parent_tidptr: 0x7f5bfa4449d0, child_tidptr: 0x7f5bfa4449d0, tls: 0x7f5bfa444700) = 26653 (perf)
     0.141 ( 0.009 ms): clone(flags: VM|FS|FILES|SIGHAND|THREAD|SYSVSEM|SETTLS|PARENT_SETTID|CHILD_CLEARTID, child_stack: 0x7f5bf9c42f30, parent_tidptr: 0x7f5bf9c439d0, child_tidptr: 0x7f5bf9c439d0, tls: 0x7f5bf9c43700) = 26654 (perf)
     0.160 ( 0.012 ms): clone(flags: VM|FS|FILES|SIGHAND|THREAD|SYSVSEM|SETTLS|PARENT_SETTID|CHILD_CLEARTID, child_stack: 0x7f5bf9441f30, parent_tidptr: 0x7f5bf94429d0, child_tidptr: 0x7f5bf94429d0, tls: 0x7f5bf9442700) = 26655 (perf)
     0.232 ( 0.013 ms): clone(flags: VM|FS|FILES|SIGHAND|THREAD|SYSVSEM|SETTLS|PARENT_SETTID|CHILD_CLEARTID, child_stack: 0x7f5bf8c40f30, parent_tidptr: 0x7f5bf8c419d0, child_tidptr: 0x7f5bf8c419d0, tls: 0x7f5bf8c41700) = 26656 (perf)
     0.393 ( 0.011 ms): clone(flags: VM|FS|FILES|SIGHAND|THREAD|SYSVSEM|SETTLS|PARENT_SETTID|CHILD_CLEARTID, child_stack: 0x7f5be3ffef30, parent_tidptr: 0x7f5be3fff9d0, child_tidptr: 0x7f5be3fff9d0, tls: 0x7f5be3fff700) = 26657 (perf)
     0.802 ( 0.012 ms): clone(flags: VM|FS|FILES|SIGHAND|THREAD|SYSVSEM|SETTLS|PARENT_SETTID|CHILD_CLEARTID, child_stack: 0x7f5be37fdf30, parent_tidptr: 0x7f5be37fe9d0, child_tidptr: 0x7f5be37fe9d0, tls: 0x7f5be37fe700) = 26658 (perf)
     1.411 ( 0.022 ms): clone(flags: VM|FS|FILES|SIGHAND|THREAD|SYSVSEM|SETTLS|PARENT_SETTID|CHILD_CLEARTID, child_stack: 0x7f5be2ffcf30, parent_tidptr: 0x7f5be2ffd9d0, child_tidptr: 0x7f5be2ffd9d0, tls: 0x7f5be2ffd700) = 26659 (perf)
   246.422 ( 0.042 ms): clone(flags: VM|FS|FILES|SIGHAND|THREAD|SYSVSEM|SETTLS|PARENT_SETTID|CHILD_CLEARTID, child_stack: 0x7f5be2ffcf30, parent_tidptr: 0x7f5be2ffd9d0, child_tidptr: 0x7f5be2ffd9d0, tls: 0x7f5be2ffd700) = 26660 (perf)
  #

	Signed-off-by: Kan Liang <kan.liang@intel.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Alexei Starovoitov <ast@kernel.org>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: He Kuang <hekuang@huawei.com>
	Cc: Lukasz Odzioba <lukasz.odzioba@intel.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1506696477-146932-5-git-send-email-kan.liang@intel.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 0c6b499495e928777c41ca2de4fbb58788269690)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-top.c
#	tools/perf/util/event.c
diff --cc tools/perf/builtin-top.c
index 0cb8dc7c3247,477a8699f0b5..000000000000
--- a/tools/perf/builtin-top.c
+++ b/tools/perf/builtin-top.c
@@@ -958,8 -958,16 +958,21 @@@ static int __cmd_top(struct perf_top *t
  	if (perf_session__register_idle_thread(top->session) < 0)
  		goto out_delete;
  
++<<<<<<< HEAD
 +	machine__synthesize_threads(&top->session->machines.host, &opts->target,
 +				    top->evlist->threads, false, opts->proc_map_timeout);
++=======
+ 	if (top->nr_threads_synthesize > 1)
+ 		perf_set_multithreaded();
+ 
+ 	machine__synthesize_threads(&top->session->machines.host, &opts->target,
+ 				    top->evlist->threads, false,
+ 				    opts->proc_map_timeout,
+ 				    top->nr_threads_synthesize);
+ 
+ 	if (top->nr_threads_synthesize > 1)
+ 		perf_set_singlethreaded();
++>>>>>>> 0c6b499495e9 (perf top: Add option to set the number of thread for event synthesize)
  
  	if (perf_hpp_list.socket) {
  		ret = perf_env__read_cpu_topology_map(&perf_env);
diff --cc tools/perf/util/event.c
index ac6ce5ceef74,47eff4767edb..000000000000
--- a/tools/perf/util/event.c
+++ b/tools/perf/util/event.c
@@@ -647,6 -742,118 +647,121 @@@ out
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ struct synthesize_threads_arg {
+ 	struct perf_tool *tool;
+ 	perf_event__handler_t process;
+ 	struct machine *machine;
+ 	bool mmap_data;
+ 	unsigned int proc_map_timeout;
+ 	struct dirent **dirent;
+ 	int num;
+ 	int start;
+ };
+ 
+ static void *synthesize_threads_worker(void *arg)
+ {
+ 	struct synthesize_threads_arg *args = arg;
+ 
+ 	__perf_event__synthesize_threads(args->tool, args->process,
+ 					 args->machine, args->mmap_data,
+ 					 args->proc_map_timeout, args->dirent,
+ 					 args->start, args->num);
+ 	return NULL;
+ }
+ 
+ int perf_event__synthesize_threads(struct perf_tool *tool,
+ 				   perf_event__handler_t process,
+ 				   struct machine *machine,
+ 				   bool mmap_data,
+ 				   unsigned int proc_map_timeout,
+ 				   unsigned int nr_threads_synthesize)
+ {
+ 	struct synthesize_threads_arg *args = NULL;
+ 	pthread_t *synthesize_threads = NULL;
+ 	char proc_path[PATH_MAX];
+ 	struct dirent **dirent;
+ 	int num_per_thread;
+ 	int m, n, i, j;
+ 	int thread_nr;
+ 	int base = 0;
+ 	int err = -1;
+ 
+ 
+ 	if (machine__is_default_guest(machine))
+ 		return 0;
+ 
+ 	snprintf(proc_path, sizeof(proc_path), "%s/proc", machine->root_dir);
+ 	n = scandir(proc_path, &dirent, 0, alphasort);
+ 	if (n < 0)
+ 		return err;
+ 
+ 	if (nr_threads_synthesize == UINT_MAX)
+ 		thread_nr = sysconf(_SC_NPROCESSORS_ONLN);
+ 	else
+ 		thread_nr = nr_threads_synthesize;
+ 
+ 	if (thread_nr <= 1) {
+ 		err = __perf_event__synthesize_threads(tool, process,
+ 						       machine, mmap_data,
+ 						       proc_map_timeout,
+ 						       dirent, base, n);
+ 		goto free_dirent;
+ 	}
+ 	if (thread_nr > n)
+ 		thread_nr = n;
+ 
+ 	synthesize_threads = calloc(sizeof(pthread_t), thread_nr);
+ 	if (synthesize_threads == NULL)
+ 		goto free_dirent;
+ 
+ 	args = calloc(sizeof(*args), thread_nr);
+ 	if (args == NULL)
+ 		goto free_threads;
+ 
+ 	num_per_thread = n / thread_nr;
+ 	m = n % thread_nr;
+ 	for (i = 0; i < thread_nr; i++) {
+ 		args[i].tool = tool;
+ 		args[i].process = process;
+ 		args[i].machine = machine;
+ 		args[i].mmap_data = mmap_data;
+ 		args[i].proc_map_timeout = proc_map_timeout;
+ 		args[i].dirent = dirent;
+ 	}
+ 	for (i = 0; i < m; i++) {
+ 		args[i].num = num_per_thread + 1;
+ 		args[i].start = i * args[i].num;
+ 	}
+ 	if (i != 0)
+ 		base = args[i-1].start + args[i-1].num;
+ 	for (j = i; j < thread_nr; j++) {
+ 		args[j].num = num_per_thread;
+ 		args[j].start = base + (j - i) * args[i].num;
+ 	}
+ 
+ 	for (i = 0; i < thread_nr; i++) {
+ 		if (pthread_create(&synthesize_threads[i], NULL,
+ 				   synthesize_threads_worker, &args[i]))
+ 			goto out_join;
+ 	}
+ 	err = 0;
+ out_join:
+ 	for (i = 0; i < thread_nr; i++)
+ 		pthread_join(synthesize_threads[i], NULL);
+ 	free(args);
+ free_threads:
+ 	free(synthesize_threads);
+ free_dirent:
+ 	for (i = 0; i < n; i++)
+ 		free(dirent[i]);
+ 	free(dirent);
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 0c6b499495e9 (perf top: Add option to set the number of thread for event synthesize)
  struct process_symbol_args {
  	const char *name;
  	u64	   start;
diff --git a/tools/perf/Documentation/perf-top.txt b/tools/perf/Documentation/perf-top.txt
index d864ea6fd367..4353262bc462 100644
--- a/tools/perf/Documentation/perf-top.txt
+++ b/tools/perf/Documentation/perf-top.txt
@@ -240,6 +240,9 @@ Default is to monitor all CPUS.
 --force::
 	Don't do ownership validation.
 
+--num-thread-synthesize::
+	The number of threads to run when synthesizing events for existing processes.
+	By default, the number of threads equals to the number of online CPUs.
 
 INTERACTIVE PROMPTING KEYS
 --------------------------
* Unmerged path tools/perf/builtin-top.c
* Unmerged path tools/perf/util/event.c
diff --git a/tools/perf/util/top.h b/tools/perf/util/top.h
index 9bdfb78a9a35..f4296e1e3bb8 100644
--- a/tools/perf/util/top.h
+++ b/tools/perf/util/top.h
@@ -37,6 +37,7 @@ struct perf_top {
 	int		   sym_pcnt_filter;
 	const char	   *sym_filter;
 	float		   min_percent;
+	unsigned int	   nr_threads_synthesize;
 };
 
 #define CONSOLE_CLEAR "[H[2J"
