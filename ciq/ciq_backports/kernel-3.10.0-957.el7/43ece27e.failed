iio:trigger: Add helper function to verify that a trigger belongs to the same device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iio] trigger: Add helper function to verify that a trigger belongs to the same device (Tony Camuso) [1559170]
Rebuild_FUZZ: 97.56%
commit-author Lars-Peter Clausen <lars@metafoo.de>
commit 43ece27e70b2c756e45306791955507f0533e248
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/43ece27e.failed

Some triggers can only be attached to the IIO device that corresponds to
the same physical device. Currently each driver that requires this
implements its own trigger validation function.

Introduce a new helper function called iio_trigger_validate_own_device()
that can be used to do this check. Having a common implementation avoids
code duplication and unnecessary boiler-plate code.

	Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit 43ece27e70b2c756e45306791955507f0533e248)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iio/industrialio-trigger.c
#	include/linux/iio/trigger.h
diff --cc drivers/iio/industrialio-trigger.c
index 27ac10a0a23f,978729f6d7c4..000000000000
--- a/drivers/iio/industrialio-trigger.c
+++ b/drivers/iio/industrialio-trigger.c
@@@ -516,6 -575,169 +516,172 @@@ void iio_trigger_free(struct iio_trigge
  }
  EXPORT_SYMBOL(iio_trigger_free);
  
++<<<<<<< HEAD
++=======
+ static void devm_iio_trigger_release(struct device *dev, void *res)
+ {
+ 	iio_trigger_free(*(struct iio_trigger **)res);
+ }
+ 
+ static int devm_iio_trigger_match(struct device *dev, void *res, void *data)
+ {
+ 	struct iio_trigger **r = res;
+ 
+ 	if (!r || !*r) {
+ 		WARN_ON(!r || !*r);
+ 		return 0;
+ 	}
+ 
+ 	return *r == data;
+ }
+ 
+ /**
+  * devm_iio_trigger_alloc - Resource-managed iio_trigger_alloc()
+  * @dev:		Device to allocate iio_trigger for
+  * @fmt:		trigger name format. If it includes format
+  *			specifiers, the additional arguments following
+  *			format are formatted and inserted in the resulting
+  *			string replacing their respective specifiers.
+  *
+  * Managed iio_trigger_alloc.  iio_trigger allocated with this function is
+  * automatically freed on driver detach.
+  *
+  * If an iio_trigger allocated with this function needs to be freed separately,
+  * devm_iio_trigger_free() must be used.
+  *
+  * RETURNS:
+  * Pointer to allocated iio_trigger on success, NULL on failure.
+  */
+ struct iio_trigger *devm_iio_trigger_alloc(struct device *dev,
+ 						const char *fmt, ...)
+ {
+ 	struct iio_trigger **ptr, *trig;
+ 	va_list vargs;
+ 
+ 	ptr = devres_alloc(devm_iio_trigger_release, sizeof(*ptr),
+ 			   GFP_KERNEL);
+ 	if (!ptr)
+ 		return NULL;
+ 
+ 	/* use raw alloc_dr for kmalloc caller tracing */
+ 	va_start(vargs, fmt);
+ 	trig = viio_trigger_alloc(fmt, vargs);
+ 	va_end(vargs);
+ 	if (trig) {
+ 		*ptr = trig;
+ 		devres_add(dev, ptr);
+ 	} else {
+ 		devres_free(ptr);
+ 	}
+ 
+ 	return trig;
+ }
+ EXPORT_SYMBOL_GPL(devm_iio_trigger_alloc);
+ 
+ /**
+  * devm_iio_trigger_free - Resource-managed iio_trigger_free()
+  * @dev:		Device this iio_dev belongs to
+  * @iio_trig:		the iio_trigger associated with the device
+  *
+  * Free iio_trigger allocated with devm_iio_trigger_alloc().
+  */
+ void devm_iio_trigger_free(struct device *dev, struct iio_trigger *iio_trig)
+ {
+ 	int rc;
+ 
+ 	rc = devres_release(dev, devm_iio_trigger_release,
+ 			    devm_iio_trigger_match, iio_trig);
+ 	WARN_ON(rc);
+ }
+ EXPORT_SYMBOL_GPL(devm_iio_trigger_free);
+ 
+ static void devm_iio_trigger_unreg(struct device *dev, void *res)
+ {
+ 	iio_trigger_unregister(*(struct iio_trigger **)res);
+ }
+ 
+ /**
+  * devm_iio_trigger_register - Resource-managed iio_trigger_register()
+  * @dev:	device this trigger was allocated for
+  * @trig_info:	trigger to register
+  *
+  * Managed iio_trigger_register().  The IIO trigger registered with this
+  * function is automatically unregistered on driver detach. This function
+  * calls iio_trigger_register() internally. Refer to that function for more
+  * information.
+  *
+  * If an iio_trigger registered with this function needs to be unregistered
+  * separately, devm_iio_trigger_unregister() must be used.
+  *
+  * RETURNS:
+  * 0 on success, negative error number on failure.
+  */
+ int devm_iio_trigger_register(struct device *dev, struct iio_trigger *trig_info)
+ {
+ 	struct iio_trigger **ptr;
+ 	int ret;
+ 
+ 	ptr = devres_alloc(devm_iio_trigger_unreg, sizeof(*ptr), GFP_KERNEL);
+ 	if (!ptr)
+ 		return -ENOMEM;
+ 
+ 	*ptr = trig_info;
+ 	ret = iio_trigger_register(trig_info);
+ 	if (!ret)
+ 		devres_add(dev, ptr);
+ 	else
+ 		devres_free(ptr);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(devm_iio_trigger_register);
+ 
+ /**
+  * devm_iio_trigger_unregister - Resource-managed iio_trigger_unregister()
+  * @dev:	device this iio_trigger belongs to
+  * @trig_info:	the trigger associated with the device
+  *
+  * Unregister trigger registered with devm_iio_trigger_register().
+  */
+ void devm_iio_trigger_unregister(struct device *dev,
+ 				 struct iio_trigger *trig_info)
+ {
+ 	int rc;
+ 
+ 	rc = devres_release(dev, devm_iio_trigger_unreg, devm_iio_trigger_match,
+ 			    trig_info);
+ 	WARN_ON(rc);
+ }
+ EXPORT_SYMBOL_GPL(devm_iio_trigger_unregister);
+ 
+ bool iio_trigger_using_own(struct iio_dev *indio_dev)
+ {
+ 	return indio_dev->trig->attached_own_device;
+ }
+ EXPORT_SYMBOL(iio_trigger_using_own);
+ 
+ /**
+  * iio_trigger_validate_own_device - Check if a trigger and IIO device belong to
+  *  the same device
+  * @trig: The IIO trigger to check
+  * @indio_dev: the IIO device to check
+  *
+  * This function can be used as the validate_device callback for triggers that
+  * can only be attached to their own device.
+  *
+  * Return: 0 if both the trigger and the IIO device belong to the same
+  * device, -EINVAL otherwise.
+  */
+ int iio_trigger_validate_own_device(struct iio_trigger *trig,
+ 	struct iio_dev *indio_dev)
+ {
+ 	if (indio_dev->dev.parent != trig->dev.parent)
+ 		return -EINVAL;
+ 	return 0;
+ }
+ EXPORT_SYMBOL(iio_trigger_validate_own_device);
+ 
++>>>>>>> 43ece27e70b2 (iio:trigger: Add helper function to verify that a trigger belongs to the same device)
  void iio_device_register_trigger_consumer(struct iio_dev *indio_dev)
  {
  	indio_dev->groups[indio_dev->groupcounter++] =
diff --cc include/linux/iio/trigger.h
index 1fa26d849585,ea08302f2d7b..000000000000
--- a/include/linux/iio/trigger.h
+++ b/include/linux/iio/trigger.h
@@@ -146,6 -164,15 +146,18 @@@ irqreturn_t iio_trigger_generic_data_rd
  __printf(1, 2) struct iio_trigger *iio_trigger_alloc(const char *fmt, ...);
  void iio_trigger_free(struct iio_trigger *trig);
  
++<<<<<<< HEAD
++=======
+ /**
+  * iio_trigger_using_own() - tells us if we use our own HW trigger ourselves
+  * @indio_dev:  device to check
+  */
+ bool iio_trigger_using_own(struct iio_dev *indio_dev);
+ 
+ int iio_trigger_validate_own_device(struct iio_trigger *trig,
+ 				     struct iio_dev *indio_dev);
+ 
++>>>>>>> 43ece27e70b2 (iio:trigger: Add helper function to verify that a trigger belongs to the same device)
  #else
  struct iio_trigger;
  struct iio_trigger_ops;
* Unmerged path drivers/iio/industrialio-trigger.c
* Unmerged path include/linux/iio/trigger.h
