mmc: block: remove unused struct mmc_card *card

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] block: remove unused struct mmc_card *card (Gopal Tiwari) [1456570]
Rebuild_FUZZ: 94.38%
commit-author Shawn Lin <shawn.lin@rock-chips.com>
commit 292876ef567518cbfc45b446298458c8b9ce7cb7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/292876ef.failed

It was never used and introduced a long standing compile
warning:

drivers/mmc/core/block.c: In function 'power_ro_lock_store':
drivers/mmc/core/block.c:191:19: warning: variable 'card' set but not
used [-Wunused-but-set-variable]

Remove it to fix the warning.

	Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 292876ef567518cbfc45b446298458c8b9ce7cb7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/block.c
diff --cc drivers/mmc/core/block.c
index 781c489f21d5,b8fa62cbb129..000000000000
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@@ -180,7 -188,8 +180,12 @@@ static ssize_t power_ro_lock_store(stru
  {
  	int ret;
  	struct mmc_blk_data *md, *part_md;
++<<<<<<< HEAD
 +	struct mmc_card *card;
++=======
+ 	struct mmc_queue *mq;
+ 	struct request *req;
++>>>>>>> 292876ef5675 (mmc: block: remove unused struct mmc_card *card)
  	unsigned long set;
  
  	if (kstrtoul(buf, 0, &set))
@@@ -190,20 -199,13 +195,24 @@@
  		return count;
  
  	md = mmc_blk_get(dev_to_disk(dev));
++<<<<<<< HEAD
 +	card = md->queue.card;
++=======
+ 	mq = &md->queue;
++>>>>>>> 292876ef5675 (mmc: block: remove unused struct mmc_card *card)
 +
 +	mmc_get_card(card);
 +
 +	ret = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_BOOT_WP,
 +				card->ext_csd.boot_ro_lock |
 +				EXT_CSD_BOOT_WP_B_PWR_WP_EN,
 +				card->ext_csd.part_time);
 +	if (ret)
 +		pr_err("%s: Locking boot partition ro until next power on failed: %d\n", md->disk->disk_name, ret);
 +	else
 +		card->ext_csd.boot_ro_lock |= EXT_CSD_BOOT_WP_B_PWR_WP_EN;
  
 -	/* Dispatch locking to the block layer */
 -	req = blk_get_request(mq->queue, REQ_OP_DRV_OUT, __GFP_RECLAIM);
 -	req_to_mmc_queue_req(req)->drv_op = MMC_DRV_OP_BOOT_WP;
 -	blk_execute_rq(mq->queue, NULL, req, 0);
 -	ret = req_to_mmc_queue_req(req)->drv_op_result;
 +	mmc_put_card(card);
  
  	if (!ret) {
  		pr_info("%s: Locking boot partition ro until next power on\n",
* Unmerged path drivers/mmc/core/block.c
