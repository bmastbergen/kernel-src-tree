PCI: shpchp: Add shpchp_is_native()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [pci] shpchp: Add shpchp_is_native() (Jarod Wilson) [1495223]
Rebuild_FUZZ: 92.31%
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 90cc0c3cc7092ea4c7871fdd5fb00a9ba62842e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/90cc0c3c.failed

In the same way we do for pciehp, add shpchp_is_native(), which returns
true if the bridge should be handled by the native SHPC driver.  Then
convert the driver to use this function.

	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 90cc0c3cc7092ea4c7871fdd5fb00a9ba62842e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/shpchp_core.c
#	include/linux/pci_hotplug.h
diff --cc drivers/pci/hotplug/shpchp_core.c
index 3454dc7385f1,e91be287f292..000000000000
--- a/drivers/pci/hotplug/shpchp_core.c
+++ b/drivers/pci/hotplug/shpchp_core.c
@@@ -284,18 -270,6 +284,21 @@@ static int get_adapter_status(struct ho
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int is_shpc_capable(struct pci_dev *dev)
 +{
 +	if (dev->vendor == PCI_VENDOR_ID_AMD &&
 +	    dev->device == PCI_DEVICE_ID_AMD_GOLAM_7450)
 +		return 1;
 +	if (!pci_find_capability(dev, PCI_CAP_ID_SHPC))
 +		return 0;
 +	if (get_hp_hw_control_from_firmware(dev))
 +		return 0;
 +	return 1;
 +}
 +
++=======
++>>>>>>> 90cc0c3cc709 (PCI: shpchp: Add shpchp_is_native())
  static int shpc_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
  {
  	int rc;
diff --cc include/linux/pci_hotplug.h
index 2e855afa0212,4c378368215c..000000000000
--- a/include/linux/pci_hotplug.h
+++ b/include/linux/pci_hotplug.h
@@@ -176,8 -162,9 +176,14 @@@ struct hotplug_params 
  #ifdef CONFIG_ACPI
  #include <linux/acpi.h>
  int pci_get_hp_params(struct pci_dev *dev, struct hotplug_params *hpp);
++<<<<<<< HEAD
 +bool pciehp_is_native(struct pci_dev *pdev);
 +int acpi_get_hp_hw_control_from_firmware(struct pci_dev *dev, u32 flags);
++=======
+ bool pciehp_is_native(struct pci_dev *bridge);
+ int acpi_get_hp_hw_control_from_firmware(struct pci_dev *bridge);
+ bool shpchp_is_native(struct pci_dev *bridge);
++>>>>>>> 90cc0c3cc709 (PCI: shpchp: Add shpchp_is_native())
  int acpi_pci_check_ejectable(struct pci_bus *pbus, acpi_handle handle);
  int acpi_pci_detect_ejectable(acpi_handle handle);
  #else
@@@ -186,6 -173,12 +192,16 @@@ static inline int pci_get_hp_params(str
  {
  	return -ENODEV;
  }
++<<<<<<< HEAD
 +static inline bool pciehp_is_native(struct pci_dev *pdev) { return true; }
++=======
+ 
+ static inline int acpi_get_hp_hw_control_from_firmware(struct pci_dev *bridge)
+ {
+ 	return 0;
+ }
+ static inline bool pciehp_is_native(struct pci_dev *bridge) { return true; }
+ static inline bool shpchp_is_native(struct pci_dev *bridge) { return true; }
++>>>>>>> 90cc0c3cc709 (PCI: shpchp: Add shpchp_is_native())
  #endif
  #endif
diff --git a/drivers/pci/hotplug/acpi_pcihp.c b/drivers/pci/hotplug/acpi_pcihp.c
index 963af104fae5..057a1e667dfe 100644
--- a/drivers/pci/hotplug/acpi_pcihp.c
+++ b/drivers/pci/hotplug/acpi_pcihp.c
@@ -98,11 +98,11 @@ int acpi_get_hp_hw_control_from_firmware(struct pci_dev *pdev, u32 flags)
 	 * OSHP within the scope of the hotplug controller and its parents,
 	 * up to the host bridge under which this controller exists.
 	 */
-	host = pci_find_host_bridge(pdev->bus);
-	if (host->native_shpc_hotplug)
+	if (shpchp_is_native(pdev))
 		return 0;
 
 	/* If _OSC exists, we should not evaluate OSHP */
+	host = pci_find_host_bridge(pdev->bus);
 	root = acpi_pci_find_root(ACPI_HANDLE(&host->dev));
 	if (root->osc_support_set)
 		goto no_control;
diff --git a/drivers/pci/hotplug/shpchp.h b/drivers/pci/hotplug/shpchp.h
index 4da8fc601467..a9abb6e4f586 100644
--- a/drivers/pci/hotplug/shpchp.h
+++ b/drivers/pci/hotplug/shpchp.h
@@ -119,7 +119,6 @@ struct controller {
 };
 
 /* Define AMD SHPC ID  */
-#define PCI_DEVICE_ID_AMD_GOLAM_7450	0x7450
 #define PCI_DEVICE_ID_AMD_POGO_7458	0x7458
 
 /* AMD PCI-X bridge registers */
* Unmerged path drivers/pci/hotplug/shpchp_core.c
diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index f8c71f6ccc20..5b2509fe85a6 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -315,6 +315,35 @@ bool pciehp_is_native(struct pci_dev *pdev)
 	return root->osc_control_set & OSC_PCI_EXPRESS_NATIVE_HP_CONTROL;
 }
 
+/**
+ * shpchp_is_native - Check whether a hotplug port is handled by the OS
+ * @bridge: Hotplug port to check
+ *
+ * Returns true if the given @bridge is handled by the native SHPC hotplug
+ * driver.
+ */
+bool shpchp_is_native(struct pci_dev *bridge)
+{
+	const struct pci_host_bridge *host;
+
+	if (!IS_ENABLED(CONFIG_HOTPLUG_PCI_SHPC))
+		return false;
+
+	/*
+	 * It is assumed that AMD GOLAM chips support SHPC but they do not
+	 * have SHPC capability.
+	 */
+	if (bridge->vendor == PCI_VENDOR_ID_AMD &&
+	    bridge->device == PCI_DEVICE_ID_AMD_GOLAM_7450)
+		return true;
+
+	if (!pci_find_capability(bridge, PCI_CAP_ID_SHPC))
+		return false;
+
+	host = pci_find_host_bridge(bridge->bus);
+	return host->native_shpc_hotplug;
+}
+
 /**
  * pci_acpi_wake_bus - Root bus wakeup notification fork function.
  * @work: Work item to handle.
* Unmerged path include/linux/pci_hotplug.h
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index d040f457dc0e..68e280637423 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -556,6 +556,7 @@
 #define PCI_DEVICE_ID_AMD_OPUS_7443	0x7443
 #define PCI_DEVICE_ID_AMD_VIPER_7443	0x7443
 #define PCI_DEVICE_ID_AMD_OPUS_7445	0x7445
+#define PCI_DEVICE_ID_AMD_GOLAM_7450	0x7450
 #define PCI_DEVICE_ID_AMD_8111_PCI	0x7460
 #define PCI_DEVICE_ID_AMD_8111_LPC	0x7468
 #define PCI_DEVICE_ID_AMD_8111_IDE	0x7469
