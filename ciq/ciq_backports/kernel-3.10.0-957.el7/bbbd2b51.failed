x86/platform/UV: Use new set memory block size function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] platform/uv: Use new set memory block size function (Frank Ramsay) [1595892]
Rebuild_FUZZ: 96.23%
commit-author mike.travis@hpe.com <mike.travis@hpe.com>
commit bbbd2b51a2aa0d76b3676271e216cf3647773397
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/bbbd2b51.failed

Add a call to the new function to "adjust" the current fixed UV memory
block size of 2GB so it can be changed to a different physical boundary.
This accommodates changes in the Intel BIOS, and therefore UV BIOS,
which now can align boundaries different than the previous UV standard
of 2GB.  It also flags any UV Global Address boundaries from BIOS that
cause a change in the mem block size (boundary).

The current boundary of 2GB has been used on UV since the first system
release in 2009 with Linux 2.6 and has worked fine.  But the new NVDIMM
persistent memory modules (PMEM), along with the Intel BIOS changes to
support these modules caused the memory block size boundary to be set
to a lower limit.  Intel only guarantees that this minimum boundary at
64MB though the current Linux limit is 128MB.

Note that the default remains 2GB if no changes occur.

	Signed-off-by: Mike Travis <mike.travis@hpe.com>
	Reviewed-by: Andrew Banman <andrew.banman@hpe.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Dimitri Sivanich <dimitri.sivanich@hpe.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Russ Anderson <russ.anderson@hpe.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: dan.j.williams@intel.com
	Cc: jgross@suse.com
	Cc: kirill.shutemov@linux.intel.com
	Cc: mhocko@suse.com
	Cc: stable@vger.kernel.org
Link: https://lkml.kernel.org/lkml/20180524201711.732785782@stormcage.americas.sgi.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit bbbd2b51a2aa0d76b3676271e216cf3647773397)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/apic/x2apic_uv_x.c
diff --cc arch/x86/kernel/apic/x2apic_uv_x.c
index 8e1cf1975fe3,2270a777d647..000000000000
--- a/arch/x86/kernel/apic/x2apic_uv_x.c
+++ b/arch/x86/kernel/apic/x2apic_uv_x.c
@@@ -25,6 -25,8 +25,11 @@@
  #include <linux/kdebug.h>
  #include <linux/delay.h>
  #include <linux/crash_dump.h>
++<<<<<<< HEAD
++=======
+ #include <linux/reboot.h>
+ #include <linux/memory.h>
++>>>>>>> bbbd2b51a2aa (x86/platform/UV: Use new set memory block size function)
  
  #include <asm/uv/uv_mmrs.h>
  #include <asm/uv/uv_hub.h>
@@@ -384,7 -393,41 +389,45 @@@ extern int uv_hub_info_version(void
  }
  EXPORT_SYMBOL(uv_hub_info_version);
  
++<<<<<<< HEAD
 +/* Build GAM range lookup table */
++=======
+ /* Default UV memory block size is 2GB */
+ static unsigned long mem_block_size = (2UL << 30);
+ 
+ static __init int adj_blksize(u32 lgre)
+ {
+ 	unsigned long base = (unsigned long)lgre << UV_GAM_RANGE_SHFT;
+ 	unsigned long size;
+ 
+ 	for (size = mem_block_size; size > MIN_MEMORY_BLOCK_SIZE; size >>= 1)
+ 		if (IS_ALIGNED(base, size))
+ 			break;
+ 
+ 	if (size >= mem_block_size)
+ 		return 0;
+ 
+ 	mem_block_size = size;
+ 	return 1;
+ }
+ 
+ static __init void set_block_size(void)
+ {
+ 	unsigned int order = ffs(mem_block_size);
+ 
+ 	if (order) {
+ 		/* adjust for ffs return of 1..64 */
+ 		set_memory_block_size_order(order - 1);
+ 		pr_info("UV: mem_block_size set to 0x%lx\n", mem_block_size);
+ 	} else {
+ 		/* bad or zero value, default to 1UL << 31 (2GB) */
+ 		pr_err("UV: mem_block_size error with 0x%lx\n", mem_block_size);
+ 		set_memory_block_size_order(31);
+ 	}
+ }
+ 
+ /* Build GAM range lookup table: */
++>>>>>>> bbbd2b51a2aa (x86/platform/UV: Use new set memory block size function)
  static __init void build_uv_gr_table(void)
  {
  	struct uv_gam_range_entry *gre = uv_gre_table;
@@@ -1231,21 -1211,34 +1274,50 @@@ static void __init decode_gam_rng_tbl(u
  
  	uv_gre_table = gre;
  	for (; gre->type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {
++<<<<<<< HEAD
 +		if (!index) {
 +			pr_info("UV: GAM Range Table...\n");
 +			pr_info("UV:  # %20s %14s %5s %4s %5s %3s %2s\n",
 +				"Range", "", "Size", "Type", "NASID",
 +				"SID", "PN");
 +		}
 +		pr_info(
 +		"UV: %2d: 0x%014lx-0x%014lx %5luG %3d   %04x  %02x %02x\n",
 +			index++,
 +			(unsigned long)lgre << UV_GAM_RANGE_SHFT,
 +			(unsigned long)gre->limit << UV_GAM_RANGE_SHFT,
 +			((unsigned long)(gre->limit - lgre)) >>
 +				(30 - UV_GAM_RANGE_SHFT), /* 64M -> 1G */
++=======
+ 		unsigned long size = ((unsigned long)(gre->limit - lgre)
+ 					<< UV_GAM_RANGE_SHFT);
+ 		int order = 0;
+ 		char suffix[] = " KMGTPE";
+ 		int flag = ' ';
+ 
+ 		while (size > 9999 && order < sizeof(suffix)) {
+ 			size /= 1024;
+ 			order++;
+ 		}
+ 
+ 		/* adjust max block size to current range start */
+ 		if (gre->type == 1 || gre->type == 2)
+ 			if (adj_blksize(lgre))
+ 				flag = '*';
+ 
+ 		if (!index) {
+ 			pr_info("UV: GAM Range Table...\n");
+ 			pr_info("UV:  # %20s %14s %6s %4s %5s %3s %2s\n", "Range", "", "Size", "Type", "NASID", "SID", "PN");
+ 		}
+ 		pr_info("UV: %2d: 0x%014lx-0x%014lx%c %5lu%c %3d   %04x  %02x %02x\n",
+ 			index++,
+ 			(unsigned long)lgre << UV_GAM_RANGE_SHFT,
+ 			(unsigned long)gre->limit << UV_GAM_RANGE_SHFT,
+ 			flag, size, suffix[order],
++>>>>>>> bbbd2b51a2aa (x86/platform/UV: Use new set memory block size function)
  			gre->type, gre->nasid, gre->sockid, gre->pnode);
  
+ 		/* update to next range start */
  		lgre = gre->limit;
  		if (sock_min > gre->sockid)
  			sock_min = gre->sockid;
@@@ -1473,11 -1460,16 +1545,12 @@@ static void __init uv_system_init_hub(v
  
  	map_low_mmrs();
  
 -	/* Get uv_systab for decoding: */
 -	uv_bios_init();
 -
 -	/* If there's an UVsystab problem then abort UV init: */
 +	uv_bios_init();			/* get uv_systab for decoding */
  	if (decode_uv_systab() < 0)
 -		return;
 -
 +		return;			/* UVsystab problem, abort UV init */
  	build_socket_tables();
  	build_uv_gr_table();
+ 	set_block_size();
  	uv_init_hub_info(&hub_info);
  	uv_possible_blades = num_possible_nodes();
  	if (!_node_to_pnode)
* Unmerged path arch/x86/kernel/apic/x2apic_uv_x.c
