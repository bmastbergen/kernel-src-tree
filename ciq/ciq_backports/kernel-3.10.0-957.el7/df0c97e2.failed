drm/nouveau/kms/nv50-: ensure window updates are submitted when flushing mst disables

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ben Skeggs <bskeggs@redhat.com>
commit df0c97e2c7d06b4f3cc5855604af79fd1a964619
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/df0c97e2.failed

It was possible for this to be skipped when shutting down MST streams, and
leaving the core channel interlocked with a wndw channel update that never
happens - leading to a hung display.

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Tested-By: Lyude Paul <lyude@redhat.com>
(cherry picked from commit df0c97e2c7d06b4f3cc5855604af79fd1a964619)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/dispnv50/disp.c
diff --cc drivers/gpu/drm/nouveau/dispnv50/disp.c
index bf1a1c043744,9382e99a0bc7..000000000000
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.c
@@@ -3851,15 -1585,15 +3851,20 @@@ nv50_pior_create(struct drm_connector *
   *****************************************************************************/
  
  static void
++<<<<<<< HEAD
 +nv50_disp_atomic_commit_core(struct nouveau_drm *drm, u32 interlock)
++=======
+ nv50_disp_atomic_commit_core(struct drm_atomic_state *state, u32 *interlock)
++>>>>>>> df0c97e2c7d0 (drm/nouveau/kms/nv50-: ensure window updates are submitted when flushing mst disables)
  {
+ 	struct nouveau_drm *drm = nouveau_drm(state->dev);
  	struct nv50_disp *disp = nv50_disp(drm->dev);
 -	struct nv50_core *core = disp->core;
 +	struct nv50_dmac *core = &disp->mast.base;
  	struct nv50_mstm *mstm;
  	struct drm_encoder *encoder;
 +	u32 *push;
  
 -	NV_ATOMIC(drm, "commit core %08x\n", interlock[NV50_DISP_INTERLOCK_BASE]);
 +	NV_ATOMIC(drm, "commit core %08x\n", interlock);
  
  	drm_for_each_encoder(encoder, drm->dev) {
  		if (encoder->encoder_type != DRM_MODE_ENCODER_DPMST) {
@@@ -3962,21 -1699,21 +3983,33 @@@ nv50_disp_atomic_commit_tail(struct drm
  
  		if (outp->clr.mask) {
  			help->disable(encoder);
 -			interlock[NV50_DISP_INTERLOCK_CORE] |= 1;
 +			interlock_core |= 1;
  			if (outp->flush_disable) {
++<<<<<<< HEAD
 +				nv50_disp_atomic_commit_core(drm, interlock_chan);
 +				interlock_core = 0;
 +				interlock_chan = 0;
++=======
+ 				nv50_disp_atomic_commit_wndw(state, interlock);
+ 				nv50_disp_atomic_commit_core(state, interlock);
+ 				memset(interlock, 0x00, sizeof(interlock));
++>>>>>>> df0c97e2c7d0 (drm/nouveau/kms/nv50-: ensure window updates are submitted when flushing mst disables)
  			}
  		}
  	}
  
  	/* Flush disable. */
 -	if (interlock[NV50_DISP_INTERLOCK_CORE]) {
 +	if (interlock_core) {
  		if (atom->flush_disable) {
++<<<<<<< HEAD
 +			nv50_disp_atomic_commit_core(drm, interlock_chan);
 +			interlock_core = 0;
 +			interlock_chan = 0;
++=======
+ 			nv50_disp_atomic_commit_wndw(state, interlock);
+ 			nv50_disp_atomic_commit_core(state, interlock);
+ 			memset(interlock, 0x00, sizeof(interlock));
++>>>>>>> df0c97e2c7d0 (drm/nouveau/kms/nv50-: ensure window updates are submitted when flushing mst disables)
  		}
  	}
  
@@@ -4036,19 -1773,18 +4069,34 @@@
  	}
  
  	/* Flush update. */
++<<<<<<< HEAD
 +	if (interlock_core) {
 +		if (!interlock_chan && atom->state.legacy_cursor_update) {
 +			u32 *push = evo_wait(&disp->mast, 2);
 +			if (push) {
 +				evo_mthd(push, 0x0080, 1);
 +				evo_data(push, 0x00000000);
 +				evo_kick(push, &disp->mast);
 +			}
 +		} else {
 +			nv50_disp_atomic_commit_core(drm, interlock_chan);
 +		}
 +	}
 +
++=======
+ 	nv50_disp_atomic_commit_wndw(state, interlock);
+ 
+ 	if (interlock[NV50_DISP_INTERLOCK_CORE]) {
+ 		if (interlock[NV50_DISP_INTERLOCK_BASE] ||
+ 		    interlock[NV50_DISP_INTERLOCK_OVLY] ||
+ 		    interlock[NV50_DISP_INTERLOCK_WNDW] ||
+ 		    !atom->state.legacy_cursor_update)
+ 			nv50_disp_atomic_commit_core(state, interlock);
+ 		else
+ 			disp->core->func->update(disp->core, interlock, false);
+ 	}
+ 
++>>>>>>> df0c97e2c7d0 (drm/nouveau/kms/nv50-: ensure window updates are submitted when flushing mst disables)
  	if (atom->lock_core)
  		mutex_unlock(&disp->mutex);
  
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/disp.c
