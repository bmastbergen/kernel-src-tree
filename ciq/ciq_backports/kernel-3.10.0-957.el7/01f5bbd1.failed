mmc: block: Fix incorrectly initialized requests

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] block: Fix incorrectly initialized requests (Gopal Tiwari) [1456570]
Rebuild_FUZZ: 94.51%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 01f5bbd17a8066b58dba9b5049fad504bce67322
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/01f5bbd1.failed

mmc_init_request() depends on card->bouncesz so it must be calculated
before blk_init_allocated_queue() starts allocating requests.

	Reported-by: Seraphime Kirkovski <kirkseraph@gmail.com>
Fixes: 304419d8a7e9 ("mmc: core: Allocate per-request data using the..")
	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Tested-by: Seraphime Kirkovski <kirkseraph@gmail.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Tested-by: Pavel Machek <pavel@ucw.cz>
(cherry picked from commit 01f5bbd17a8066b58dba9b5049fad504bce67322)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/queue.c
diff --cc drivers/mmc/core/queue.c
index b0ae9d688e28,74c663b1c0a7..000000000000
--- a/drivers/mmc/core/queue.c
+++ b/drivers/mmc/core/queue.c
@@@ -276,21 -240,30 +276,27 @@@ int mmc_init_queue(struct mmc_queue *mq
  	int ret = -ENOMEM;
  
  	if (mmc_dev(host)->dma_mask && *mmc_dev(host)->dma_mask)
 -		limit = (u64)dma_max_pfn(mmc_dev(host)) << PAGE_SHIFT;
 +		limit = *mmc_dev(host)->dma_mask;
  
+ 	/*
+ 	 * mmc_init_request() depends on card->bouncesz so it must be calculated
+ 	 * before blk_init_allocated_queue() starts allocating requests.
+ 	 */
+ 	card->bouncesz = mmc_queue_calc_bouncesz(host);
+ 
  	mq->card = card;
 -	mq->queue = blk_alloc_queue(GFP_KERNEL);
 +	mq->queue = blk_init_queue(mmc_request_fn, lock);
  	if (!mq->queue)
  		return -ENOMEM;
 -	mq->queue->queue_lock = lock;
 -	mq->queue->request_fn = mmc_request_fn;
 -	mq->queue->init_rq_fn = mmc_init_request;
 -	mq->queue->exit_rq_fn = mmc_exit_request;
 -	mq->queue->cmd_size = sizeof(struct mmc_queue_req);
 +
 +	mq->qdepth = 2;
 +	mq->mqrq = kcalloc(mq->qdepth, sizeof(struct mmc_queue_req),
 +			   GFP_KERNEL);
 +	if (!mq->mqrq)
 +		goto blk_cleanup;
 +	mq->mqrq_cur = &mq->mqrq[0];
 +	mq->mqrq_prev = &mq->mqrq[1];
  	mq->queue->queuedata = mq;
 -	mq->qcnt = 0;
 -	ret = blk_init_allocated_queue(mq->queue);
 -	if (ret) {
 -		blk_cleanup_queue(mq->queue);
 -		return ret;
 -	}
  
  	blk_queue_prep_rq(mq->queue, mmc_prep_request);
  	queue_flag_set_unlocked(QUEUE_FLAG_NONROT, mq->queue);
@@@ -298,35 -271,11 +304,43 @@@
  	if (mmc_can_erase(card))
  		mmc_queue_setup_discard(mq->queue, card);
  
++<<<<<<< HEAD
 +#ifdef CONFIG_MMC_BLOCK_BOUNCE
 +	if (host->max_segs == 1) {
 +		unsigned int bouncesz;
 +
 +		bouncesz = MMC_QUEUE_BOUNCESZ;
 +
 +		if (bouncesz > host->max_req_size)
 +			bouncesz = host->max_req_size;
 +		if (bouncesz > host->max_seg_size)
 +			bouncesz = host->max_seg_size;
 +		if (bouncesz > (host->max_blk_count * 512))
 +			bouncesz = host->max_blk_count * 512;
 +
 +		if (bouncesz > 512 &&
 +		    mmc_queue_alloc_bounce_bufs(mq, bouncesz)) {
 +			blk_queue_bounce_limit(mq->queue, BLK_BOUNCE_ANY);
 +			blk_queue_max_hw_sectors(mq->queue, bouncesz / 512);
 +			blk_queue_max_segments(mq->queue, bouncesz / 512);
 +			blk_queue_max_segment_size(mq->queue, bouncesz);
 +
 +			ret = mmc_queue_alloc_bounce_sgs(mq, bouncesz);
 +			if (ret)
 +				goto cleanup_queue;
 +			bounce = true;
 +		}
 +	}
 +#endif
 +
 +	if (!bounce) {
++=======
+ 	if (card->bouncesz) {
+ 		blk_queue_max_hw_sectors(mq->queue, card->bouncesz / 512);
+ 		blk_queue_max_segments(mq->queue, card->bouncesz / 512);
+ 		blk_queue_max_segment_size(mq->queue, card->bouncesz);
+ 	} else {
++>>>>>>> 01f5bbd17a80 (mmc: block: Fix incorrectly initialized requests)
  		blk_queue_bounce_limit(mq->queue, limit);
  		blk_queue_max_hw_sectors(mq->queue,
  			min(host->max_blk_count, host->max_req_size / 512));
* Unmerged path drivers/mmc/core/queue.c
