scsi: qla2xxx: Use IOCB path to submit Control VP MBX command

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Use IOCB path to submit Control VP MBX command (Himanshu Madhani) [1547714]
Rebuild_FUZZ: 94.83%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit 2853192e154b813fe34a6cbee5e34dfef50d29d0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/2853192e.failed

Use IOCB patch to submit Control VP MBX command to reduce
bottle-neck for mbx interface.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 2853192e154b813fe34a6cbee5e34dfef50d29d0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_iocb.c
#	drivers/scsi/qla2xxx/qla_isr.c
#	drivers/scsi/qla2xxx/qla_mbx.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 65a064ba1a4b,969a7dee9f72..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -421,6 -456,26 +421,29 @@@ struct srb_iocb 
  		struct {
  			struct imm_ntfy_from_isp *ntfy;
  		} nack;
++<<<<<<< HEAD
++=======
+ 		struct {
+ 			__le16 comp_status;
+ 			uint16_t rsp_pyld_len;
+ 			uint8_t	aen_op;
+ 			void *desc;
+ 
+ 			/* These are only used with ls4 requests */
+ 			int cmd_len;
+ 			int rsp_len;
+ 			dma_addr_t cmd_dma;
+ 			dma_addr_t rsp_dma;
+ 			enum nvmefc_fcp_datadir dir;
+ 			uint32_t dl;
+ 			uint32_t timeout_sec;
+ 			struct	list_head   entry;
+ 		} nvme;
+ 		struct {
+ 			u16 cmd;
+ 			u16 vp_index;
+ 		} ctrlvp;
++>>>>>>> 2853192e154b (scsi: qla2xxx: Use IOCB path to submit Control VP MBX command)
  	} u;
  
  	struct timer_list timer;
@@@ -446,6 -501,10 +469,13 @@@
  #define SRB_NACK_PLOGI	16
  #define SRB_NACK_PRLI	17
  #define SRB_NACK_LOGO	18
++<<<<<<< HEAD
++=======
+ #define SRB_NVME_CMD	19
+ #define SRB_NVME_LS	20
+ #define SRB_PRLI_CMD	21
+ #define SRB_CTRL_VP	22
++>>>>>>> 2853192e154b (scsi: qla2xxx: Use IOCB path to submit Control VP MBX command)
  
  enum {
  	TYPE_SRB,
@@@ -468,11 -528,14 +498,13 @@@ typedef struct srb 
  	const char *name;
  	int iocbs;
  	struct qla_qpair *qpair;
 -	struct list_head elem;
  	u32 gen1;	/* scratch */
  	u32 gen2;	/* scratch */
+ 	int rc;
+ 	struct completion comp;
  	union {
  		struct srb_iocb iocb_cmd;
 -		struct bsg_job *bsg_job;
 +		struct fc_bsg_job *bsg_job;
  		struct srb_cmd scmd;
  	} u;
  	void (*done)(void *, int);
diff --cc drivers/scsi/qla2xxx/qla_iocb.c
index 430b293b4d6f,2d523b71cc1f..000000000000
--- a/drivers/scsi/qla2xxx/qla_iocb.c
+++ b/drivers/scsi/qla2xxx/qla_iocb.c
@@@ -3214,6 -3335,59 +3214,62 @@@ static void qla2x00_send_notify_ack_ioc
  	nack->u.isp24.vp_index = ntfy->u.isp24.vp_index;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Build NVME LS request
+  */
+ static int
+ qla_nvme_ls(srb_t *sp, struct pt_ls4_request *cmd_pkt)
+ {
+ 	struct srb_iocb *nvme;
+ 	int     rval = QLA_SUCCESS;
+ 
+ 	nvme = &sp->u.iocb_cmd;
+ 	cmd_pkt->entry_type = PT_LS4_REQUEST;
+ 	cmd_pkt->entry_count = 1;
+ 	cmd_pkt->control_flags = CF_LS4_ORIGINATOR << CF_LS4_SHIFT;
+ 
+ 	cmd_pkt->timeout = cpu_to_le16(nvme->u.nvme.timeout_sec);
+ 	cmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);
+ 	cmd_pkt->vp_index = sp->fcport->vha->vp_idx;
+ 
+ 	cmd_pkt->tx_dseg_count = 1;
+ 	cmd_pkt->tx_byte_count = nvme->u.nvme.cmd_len;
+ 	cmd_pkt->dseg0_len = nvme->u.nvme.cmd_len;
+ 	cmd_pkt->dseg0_address[0] = cpu_to_le32(LSD(nvme->u.nvme.cmd_dma));
+ 	cmd_pkt->dseg0_address[1] = cpu_to_le32(MSD(nvme->u.nvme.cmd_dma));
+ 
+ 	cmd_pkt->rx_dseg_count = 1;
+ 	cmd_pkt->rx_byte_count = nvme->u.nvme.rsp_len;
+ 	cmd_pkt->dseg1_len  = nvme->u.nvme.rsp_len;
+ 	cmd_pkt->dseg1_address[0] =  cpu_to_le32(LSD(nvme->u.nvme.rsp_dma));
+ 	cmd_pkt->dseg1_address[1] =  cpu_to_le32(MSD(nvme->u.nvme.rsp_dma));
+ 
+ 	return rval;
+ }
+ 
+ static void
+ qla25xx_ctrlvp_iocb(srb_t *sp, struct vp_ctrl_entry_24xx *vce)
+ {
+ 	int map, pos;
+ 
+ 	vce->entry_type = VP_CTRL_IOCB_TYPE;
+ 	vce->handle = sp->handle;
+ 	vce->entry_count = 1;
+ 	vce->command = cpu_to_le16(sp->u.iocb_cmd.u.ctrlvp.cmd);
+ 	vce->vp_count = cpu_to_le16(1);
+ 
+ 	/*
+ 	 * index map in firmware starts with 1; decrement index
+ 	 * this is ok as we never use index 0
+ 	 */
+ 	map = (sp->u.iocb_cmd.u.ctrlvp.vp_index - 1) / 8;
+ 	pos = (sp->u.iocb_cmd.u.ctrlvp.vp_index - 1) & 7;
+ 	vce->vp_idx_map[map] |= 1 << pos;
+ }
+ 
++>>>>>>> 2853192e154b (scsi: qla2xxx: Use IOCB path to submit Control VP MBX command)
  int
  qla2x00_start_sp(srb_t *sp)
  {
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index 07f970a66c67,a265c2d8c9cc..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -1802,6 -1839,135 +1802,138 @@@ qla24xx_tm_iocb_entry(scsi_qla_host_t *
  	sp->done(sp, 0);
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ qla24xx_nvme_iocb_entry(scsi_qla_host_t *vha, struct req_que *req, void *tsk)
+ {
+ 	const char func[] = "NVME-IOCB";
+ 	fc_port_t *fcport;
+ 	srb_t *sp;
+ 	struct srb_iocb *iocb;
+ 	struct sts_entry_24xx *sts = (struct sts_entry_24xx *)tsk;
+ 	uint16_t        state_flags;
+ 	struct nvmefc_fcp_req *fd;
+ 	uint16_t        ret = 0;
+ 	struct srb_iocb *nvme;
+ 
+ 	sp = qla2x00_get_sp_from_handle(vha, func, req, tsk);
+ 	if (!sp)
+ 		return;
+ 
+ 	iocb = &sp->u.iocb_cmd;
+ 	fcport = sp->fcport;
+ 	iocb->u.nvme.comp_status = le16_to_cpu(sts->comp_status);
+ 	state_flags  = le16_to_cpu(sts->state_flags);
+ 	fd = iocb->u.nvme.desc;
+ 	nvme = &sp->u.iocb_cmd;
+ 
+ 	if (unlikely(nvme->u.nvme.aen_op))
+ 		atomic_dec(&sp->vha->hw->nvme_active_aen_cnt);
+ 
+ 	/*
+ 	 * State flags: Bit 6 and 0.
+ 	 * If 0 is set, we don't care about 6.
+ 	 * both cases resp was dma'd to host buffer
+ 	 * if both are 0, that is good path case.
+ 	 * if six is set and 0 is clear, we need to
+ 	 * copy resp data from status iocb to resp buffer.
+ 	 */
+ 	if (!(state_flags & (SF_FCP_RSP_DMA | SF_NVME_ERSP))) {
+ 		iocb->u.nvme.rsp_pyld_len = 0;
+ 	} else if ((state_flags & SF_FCP_RSP_DMA)) {
+ 		iocb->u.nvme.rsp_pyld_len = le16_to_cpu(sts->nvme_rsp_pyld_len);
+ 	} else if (state_flags & SF_NVME_ERSP) {
+ 		uint32_t *inbuf, *outbuf;
+ 		uint16_t iter;
+ 
+ 		inbuf = (uint32_t *)&sts->nvme_ersp_data;
+ 		outbuf = (uint32_t *)fd->rspaddr;
+ 		iocb->u.nvme.rsp_pyld_len = le16_to_cpu(sts->nvme_rsp_pyld_len);
+ 		iter = iocb->u.nvme.rsp_pyld_len >> 2;
+ 		for (; iter; iter--)
+ 			*outbuf++ = swab32(*inbuf++);
+ 	} else { /* unhandled case */
+ 	    ql_log(ql_log_warn, fcport->vha, 0x503a,
+ 		"NVME-%s error. Unhandled state_flags of %x\n",
+ 		sp->name, state_flags);
+ 	}
+ 
+ 	fd->transferred_length = fd->payload_length -
+ 	    le32_to_cpu(sts->residual_len);
+ 
+ 	/*
+ 	 * If transport error then Failure (HBA rejects request)
+ 	 * otherwise transport will handle.
+ 	 */
+ 	if (sts->entry_status) {
+ 		ql_log(ql_log_warn, fcport->vha, 0x5038,
+ 		    "NVME-%s error - hdl=%x entry-status(%x).\n",
+ 		    sp->name, sp->handle, sts->entry_status);
+ 		ret = QLA_FUNCTION_FAILED;
+ 	} else  {
+ 		switch (le16_to_cpu(sts->comp_status)) {
+ 			case CS_COMPLETE:
+ 				ret = 0;
+ 			break;
+ 
+ 			case CS_ABORTED:
+ 			case CS_RESET:
+ 			case CS_PORT_UNAVAILABLE:
+ 			case CS_PORT_LOGGED_OUT:
+ 			case CS_PORT_BUSY:
+ 				ql_log(ql_log_warn, fcport->vha, 0x5060,
+ 				"NVME-%s ERR Handling - hdl=%x completion status(%x) resid=%x  ox_id=%x\n",
+ 				sp->name, sp->handle, sts->comp_status,
+ 				le32_to_cpu(sts->residual_len), sts->ox_id);
+ 				fd->transferred_length = fd->payload_length;
+ 				ret = QLA_ABORTED;
+ 			break;
+ 
+ 			default:
+ 				ql_log(ql_log_warn, fcport->vha, 0x5060,
+ 				"NVME-%s error - hdl=%x completion status(%x) resid=%x  ox_id=%x\n",
+ 				sp->name, sp->handle, sts->comp_status,
+ 				le32_to_cpu(sts->residual_len), sts->ox_id);
+ 				ret = QLA_FUNCTION_FAILED;
+ 				break;
+ 		}
+ 	}
+ 	sp->done(sp, ret);
+ }
+ 
+ static void qla_ctrlvp_completed(scsi_qla_host_t *vha, struct req_que *req,
+     struct vp_ctrl_entry_24xx *vce)
+ {
+ 	const char func[] = "CTRLVP-IOCB";
+ 	srb_t *sp;
+ 	int rval = QLA_SUCCESS;
+ 
+ 	sp = qla2x00_get_sp_from_handle(vha, func, req, vce);
+ 	if (!sp)
+ 		return;
+ 
+ 	if (vce->entry_status != 0) {
+ 		ql_dbg(ql_dbg_vport, vha, 0x10c4,
+ 		    "%s: Failed to complete IOCB -- error status (%x)\n",
+ 		    sp->name, vce->entry_status);
+ 		rval = QLA_FUNCTION_FAILED;
+ 	} else if (vce->comp_status != cpu_to_le16(CS_COMPLETE)) {
+ 		ql_dbg(ql_dbg_vport, vha, 0x10c5,
+ 		    "%s: Failed to complete IOCB -- completion status (%x) vpidx %x\n",
+ 		    sp->name, le16_to_cpu(vce->comp_status),
+ 		    le16_to_cpu(vce->vp_idx_failed));
+ 		rval = QLA_FUNCTION_FAILED;
+ 	} else {
+ 		ql_dbg(ql_dbg_vport, vha, 0x10c6,
+ 		    "Done %s.\n", __func__);
+ 	}
+ 
+ 	sp->rc = rval;
+ 	sp->done(sp, rval);
+ }
+ 
++>>>>>>> 2853192e154b (scsi: qla2xxx: Use IOCB path to submit Control VP MBX command)
  /**
   * qla2x00_process_response_queue() - Process response queue entries.
   * @ha: SCSI driver HA context
diff --cc drivers/scsi/qla2xxx/qla_mbx.c
index 4649e83dd88d,dea2e66be0b1..000000000000
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@@ -3825,83 -3945,6 +3825,86 @@@ qla24xx_modify_vp_config(scsi_qla_host_
  }
  
  /*
++<<<<<<< HEAD
 + * qla24xx_control_vp
 + *	Enable a virtual port for given host
 + *
 + * Input:
 + *	ha = adapter block pointer.
 + *	vhba = virtual adapter (unused)
 + *	index = index number for enabled VP
 + *
 + * Returns:
 + *	qla2xxx local function return status code.
 + *
 + * Context:
 + *	Kernel context.
 + */
 +int
 +qla24xx_control_vp(scsi_qla_host_t *vha, int cmd)
 +{
 +	int		rval;
 +	int		map, pos;
 +	struct vp_ctrl_entry_24xx   *vce;
 +	dma_addr_t	vce_dma;
 +	struct qla_hw_data *ha = vha->hw;
 +	int	vp_index = vha->vp_idx;
 +	struct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);
 +
 +	ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10c1,
 +	    "Entered %s enabling index %d.\n", __func__, vp_index);
 +
 +	if (vp_index == 0 || vp_index >= ha->max_npiv_vports)
 +		return QLA_PARAMETER_ERROR;
 +
 +	vce = dma_pool_zalloc(ha->s_dma_pool, GFP_KERNEL, &vce_dma);
 +	if (!vce) {
 +		ql_log(ql_log_warn, vha, 0x10c2,
 +		    "Failed to allocate VP control IOCB.\n");
 +		return QLA_MEMORY_ALLOC_FAILED;
 +	}
 +
 +	vce->entry_type = VP_CTRL_IOCB_TYPE;
 +	vce->entry_count = 1;
 +	vce->command = cpu_to_le16(cmd);
 +	vce->vp_count = cpu_to_le16(1);
 +
 +	/* index map in firmware starts with 1; decrement index
 +	 * this is ok as we never use index 0
 +	 */
 +	map = (vp_index - 1) / 8;
 +	pos = (vp_index - 1) & 7;
 +	mutex_lock(&ha->vport_lock);
 +	vce->vp_idx_map[map] |= 1 << pos;
 +	mutex_unlock(&ha->vport_lock);
 +
 +	rval = qla2x00_issue_iocb(base_vha, vce, vce_dma, 0);
 +	if (rval != QLA_SUCCESS) {
 +		ql_dbg(ql_dbg_mbx, vha, 0x10c3,
 +		    "Failed to issue VP control IOCB (%x).\n", rval);
 +	} else if (vce->entry_status != 0) {
 +		ql_dbg(ql_dbg_mbx, vha, 0x10c4,
 +		    "Failed to complete IOCB -- error status (%x).\n",
 +		    vce->entry_status);
 +		rval = QLA_FUNCTION_FAILED;
 +	} else if (vce->comp_status != cpu_to_le16(CS_COMPLETE)) {
 +		ql_dbg(ql_dbg_mbx, vha, 0x10c5,
 +		    "Failed to complet IOCB -- completion status (%x).\n",
 +		    le16_to_cpu(vce->comp_status));
 +		rval = QLA_FUNCTION_FAILED;
 +	} else {
 +		ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10c6,
 +		    "Done %s.\n", __func__);
 +	}
 +
 +	dma_pool_free(ha->s_dma_pool, vce, vce_dma);
 +
 +	return rval;
 +}
 +
 +/*
++=======
++>>>>>>> 2853192e154b (scsi: qla2xxx: Use IOCB path to submit Control VP MBX command)
   * qla2x00_send_change_request
   *	Receive or disable RSCN request from fabric controller
   *
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c
index 83ad7d90d14e..bada5c3aa5c6 100644
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@ -133,6 +133,7 @@ qla2x00_async_iocb_timeout(void *data)
 	case SRB_NACK_PLOGI:
 	case SRB_NACK_PRLI:
 	case SRB_NACK_LOGO:
+	case SRB_CTRL_VP:
 		sp->done(sp, QLA_FUNCTION_TIMEOUT);
 		break;
 	}
diff --git a/drivers/scsi/qla2xxx/qla_inline.h b/drivers/scsi/qla2xxx/qla_inline.h
index 9a2c86eacf44..670cc46b330b 100644
--- a/drivers/scsi/qla2xxx/qla_inline.h
+++ b/drivers/scsi/qla2xxx/qla_inline.h
@@ -275,6 +275,7 @@ qla2x00_init_timer(srb_t *sp, unsigned long tmo)
 	sp->u.iocb_cmd.timer.function = qla2x00_sp_timeout;
 	add_timer(&sp->u.iocb_cmd.timer);
 	sp->free = qla2x00_sp_free;
+	init_completion(&sp->comp);
 	if (IS_QLAFX00(sp->vha->hw) && (sp->type == SRB_FXIOCB_DCMD))
 		init_completion(&sp->u.iocb_cmd.u.fxiocb.fxiocb_comp);
 	if (sp->type == SRB_ELS_DCMD)
* Unmerged path drivers/scsi/qla2xxx/qla_iocb.c
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
* Unmerged path drivers/scsi/qla2xxx/qla_mbx.c
diff --git a/drivers/scsi/qla2xxx/qla_mid.c b/drivers/scsi/qla2xxx/qla_mid.c
index 9bbf11958caa..6e8902e67ecf 100644
--- a/drivers/scsi/qla2xxx/qla_mid.c
+++ b/drivers/scsi/qla2xxx/qla_mid.c
@@ -886,3 +886,79 @@ que_failed:
 failed:
 	return 0;
 }
+
+static void qla_ctrlvp_sp_done(void *s, int res)
+{
+	struct srb *sp = s;
+
+	complete(&sp->comp);
+	/* don't free sp here. Let the caller do the free */
+}
+
+/**
+ * qla24xx_control_vp() - Enable a virtual port for given host
+ * @vha:	adapter block pointer
+ * @cmd:	command type to be sent for enable virtual port
+ *
+ * Return:	qla2xxx local function return status code.
+ */
+int qla24xx_control_vp(scsi_qla_host_t *vha, int cmd)
+{
+	int rval = QLA_MEMORY_ALLOC_FAILED;
+	struct qla_hw_data *ha = vha->hw;
+	int	vp_index = vha->vp_idx;
+	struct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);
+	srb_t *sp;
+
+	ql_dbg(ql_dbg_vport, vha, 0x10c1,
+	    "Entered %s cmd %x index %d.\n", __func__, cmd, vp_index);
+
+	if (vp_index == 0 || vp_index >= ha->max_npiv_vports)
+		return QLA_PARAMETER_ERROR;
+
+	sp = qla2x00_get_sp(base_vha, NULL, GFP_KERNEL);
+	if (!sp)
+		goto done;
+
+	sp->type = SRB_CTRL_VP;
+	sp->name = "ctrl_vp";
+	sp->done = qla_ctrlvp_sp_done;
+	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+	sp->u.iocb_cmd.timeout = qla2x00_async_iocb_timeout;
+	sp->u.iocb_cmd.u.ctrlvp.cmd = cmd;
+	sp->u.iocb_cmd.u.ctrlvp.vp_index = vp_index;
+
+	rval = qla2x00_start_sp(sp);
+	if (rval != QLA_SUCCESS) {
+		ql_dbg(ql_dbg_async, vha, 0xffff,
+		    "%s: %s Failed submission. %x.\n",
+		    __func__, sp->name, rval);
+		goto done_free_sp;
+	}
+
+	ql_dbg(ql_dbg_vport, vha, 0x113f, "%s hndl %x submitted\n",
+	    sp->name, sp->handle);
+
+	wait_for_completion(&sp->comp);
+	rval = sp->rc;
+	switch (rval) {
+	case QLA_FUNCTION_TIMEOUT:
+		ql_dbg(ql_dbg_vport, vha, 0xffff, "%s: %s Timeout. %x.\n",
+		    __func__, sp->name, rval);
+		break;
+	case QLA_SUCCESS:
+		ql_dbg(ql_dbg_vport, vha, 0xffff, "%s: %s done.\n",
+		    __func__, sp->name);
+		goto done_free_sp;
+	default:
+		ql_dbg(ql_dbg_vport, vha, 0xffff, "%s: %s Failed. %x.\n",
+		    __func__, sp->name, rval);
+		goto done_free_sp;
+	}
+done:
+	return rval;
+
+done_free_sp:
+	sp->free(sp);
+	return rval;
+}
