scsi: megaraid_sas: Use megasas_wait_for_adapter_operational to detect controller state in IOCTL path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] megaraid_sas: Use megasas_wait_for_adapter_operational to detect controller state in IOCTL path (Tomas Henzl) [1513838]
Rebuild_FUZZ: 96.94%
commit-author Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
commit 619831f23bf76e7d420991df3baefc8e24cc5432
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/619831f2.failed

In IOCTL path, re-use megasas_wait_for_adapter_operational API to detect
controller state. This will make driver to use this API uniformly in all
cases where we need to wait for adapter to become operational.

	Signed-off-by: Sumit Saxena <sumit.saxena@broadcom.com>
	Signed-off-by: Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 619831f23bf76e7d420991df3baefc8e24cc5432)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas_base.c
diff --cc drivers/scsi/megaraid/megaraid_sas_base.c
index 8a636b558a1d,34d1fb75285a..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@@ -7239,29 -7338,7 +7232,33 @@@ static int megasas_mgmt_ioctl_fw(struc
  		goto out_kfree_ioc;
  	}
  
++<<<<<<< HEAD
 +	for (i = 0; i < wait_time; i++) {
 +
 +		spin_lock_irqsave(&instance->hba_lock, flags);
 +		if (atomic_read(&instance->adprecovery) == MEGASAS_HBA_OPERATIONAL) {
 +			spin_unlock_irqrestore(&instance->hba_lock, flags);
 +			break;
 +		}
 +		spin_unlock_irqrestore(&instance->hba_lock, flags);
 +
 +		if (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {
 +			dev_notice(&instance->pdev->dev, "waiting"
 +				"for controller reset to finish\n");
 +		}
 +
 +		msleep(1000);
 +	}
 +
 +	spin_lock_irqsave(&instance->hba_lock, flags);
 +	if (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {
 +		spin_unlock_irqrestore(&instance->hba_lock, flags);
 +
 +		dev_err(&instance->pdev->dev, "timed out while"
 +			"waiting for HBA to recover\n");
++=======
+ 	if  (megasas_wait_for_adapter_operational(instance)) {
++>>>>>>> 619831f23bf7 (scsi: megaraid_sas: Use megasas_wait_for_adapter_operational to detect controller state in IOCTL path)
  		error = -ENODEV;
  		goto out_up;
  	}
@@@ -7307,33 -7380,8 +7300,35 @@@ static int megasas_mgmt_ioctl_aen(struc
  		return -ENODEV;
  	}
  
++<<<<<<< HEAD
 +	for (i = 0; i < wait_time; i++) {
 +
 +		spin_lock_irqsave(&instance->hba_lock, flags);
 +		if (atomic_read(&instance->adprecovery) == MEGASAS_HBA_OPERATIONAL) {
 +			spin_unlock_irqrestore(&instance->hba_lock,
 +						flags);
 +			break;
 +		}
 +
 +		spin_unlock_irqrestore(&instance->hba_lock, flags);
 +
 +		if (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {
 +			dev_notice(&instance->pdev->dev, "waiting for"
 +				"controller reset to finish\n");
 +		}
 +
 +		msleep(1000);
 +	}
 +
 +	spin_lock_irqsave(&instance->hba_lock, flags);
 +	if (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {
 +		spin_unlock_irqrestore(&instance->hba_lock, flags);
 +		dev_err(&instance->pdev->dev, "timed out while waiting"
 +				"for HBA to recover\n");
++=======
+ 	if  (megasas_wait_for_adapter_operational(instance))
++>>>>>>> 619831f23bf7 (scsi: megaraid_sas: Use megasas_wait_for_adapter_operational to detect controller state in IOCTL path)
  		return -ENODEV;
- 	}
- 	spin_unlock_irqrestore(&instance->hba_lock, flags);
  
  	mutex_lock(&instance->reset_mutex);
  	error = megasas_register_aen(instance, aen.seq_num,
* Unmerged path drivers/scsi/megaraid/megaraid_sas_base.c
