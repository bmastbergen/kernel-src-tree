bpf: introduce bpf_perf_event_output() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Alexei Starovoitov <ast@plumgrid.com>
commit a43eec304259a6c637f4014a6d4767159b6a3aa3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/a43eec30.failed

This helper is used to send raw data from eBPF program into
special PERF_TYPE_SOFTWARE/PERF_COUNT_SW_BPF_OUTPUT perf_event.
User space needs to perf_event_open() it (either for one or all cpus) and
store FD into perf_event_array (similar to bpf_perf_event_read() helper)
before eBPF program can send data into it.

Today the programs triggered by kprobe collect the data and either store
it into the maps or print it via bpf_trace_printk() where latter is the debug
facility and not suitable to stream the data. This new helper replaces
such bpf_trace_printk() usage and allows programs to have dedicated
channel into user space for post-processing of the raw data collected.

	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a43eec304259a6c637f4014a6d4767159b6a3aa3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	kernel/bpf/arraymap.c
#	kernel/bpf/verifier.c
#	kernel/trace/bpf_trace.c
diff --cc include/uapi/linux/bpf.h
index e369860b690e,2e032426cfb7..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -162,6 -167,137 +162,140 @@@ struct xdp_md 
   */
  enum bpf_func_id {
  	BPF_FUNC_unspec,
++<<<<<<< HEAD
++=======
+ 	BPF_FUNC_map_lookup_elem, /* void *map_lookup_elem(&map, &key) */
+ 	BPF_FUNC_map_update_elem, /* int map_update_elem(&map, &key, &value, flags) */
+ 	BPF_FUNC_map_delete_elem, /* int map_delete_elem(&map, &key) */
+ 	BPF_FUNC_probe_read,      /* int bpf_probe_read(void *dst, int size, void *src) */
+ 	BPF_FUNC_ktime_get_ns,    /* u64 bpf_ktime_get_ns(void) */
+ 	BPF_FUNC_trace_printk,    /* int bpf_trace_printk(const char *fmt, int fmt_size, ...) */
+ 	BPF_FUNC_get_prandom_u32, /* u32 prandom_u32(void) */
+ 	BPF_FUNC_get_smp_processor_id, /* u32 raw_smp_processor_id(void) */
+ 
+ 	/**
+ 	 * skb_store_bytes(skb, offset, from, len, flags) - store bytes into packet
+ 	 * @skb: pointer to skb
+ 	 * @offset: offset within packet from skb->mac_header
+ 	 * @from: pointer where to copy bytes from
+ 	 * @len: number of bytes to store into packet
+ 	 * @flags: bit 0 - if true, recompute skb->csum
+ 	 *         other bits - reserved
+ 	 * Return: 0 on success
+ 	 */
+ 	BPF_FUNC_skb_store_bytes,
+ 
+ 	/**
+ 	 * l3_csum_replace(skb, offset, from, to, flags) - recompute IP checksum
+ 	 * @skb: pointer to skb
+ 	 * @offset: offset within packet where IP checksum is located
+ 	 * @from: old value of header field
+ 	 * @to: new value of header field
+ 	 * @flags: bits 0-3 - size of header field
+ 	 *         other bits - reserved
+ 	 * Return: 0 on success
+ 	 */
+ 	BPF_FUNC_l3_csum_replace,
+ 
+ 	/**
+ 	 * l4_csum_replace(skb, offset, from, to, flags) - recompute TCP/UDP checksum
+ 	 * @skb: pointer to skb
+ 	 * @offset: offset within packet where TCP/UDP checksum is located
+ 	 * @from: old value of header field
+ 	 * @to: new value of header field
+ 	 * @flags: bits 0-3 - size of header field
+ 	 *         bit 4 - is pseudo header
+ 	 *         other bits - reserved
+ 	 * Return: 0 on success
+ 	 */
+ 	BPF_FUNC_l4_csum_replace,
+ 
+ 	/**
+ 	 * bpf_tail_call(ctx, prog_array_map, index) - jump into another BPF program
+ 	 * @ctx: context pointer passed to next program
+ 	 * @prog_array_map: pointer to map which type is BPF_MAP_TYPE_PROG_ARRAY
+ 	 * @index: index inside array that selects specific program to run
+ 	 * Return: 0 on success
+ 	 */
+ 	BPF_FUNC_tail_call,
+ 
+ 	/**
+ 	 * bpf_clone_redirect(skb, ifindex, flags) - redirect to another netdev
+ 	 * @skb: pointer to skb
+ 	 * @ifindex: ifindex of the net device
+ 	 * @flags: bit 0 - if set, redirect to ingress instead of egress
+ 	 *         other bits - reserved
+ 	 * Return: 0 on success
+ 	 */
+ 	BPF_FUNC_clone_redirect,
+ 
+ 	/**
+ 	 * u64 bpf_get_current_pid_tgid(void)
+ 	 * Return: current->tgid << 32 | current->pid
+ 	 */
+ 	BPF_FUNC_get_current_pid_tgid,
+ 
+ 	/**
+ 	 * u64 bpf_get_current_uid_gid(void)
+ 	 * Return: current_gid << 32 | current_uid
+ 	 */
+ 	BPF_FUNC_get_current_uid_gid,
+ 
+ 	/**
+ 	 * bpf_get_current_comm(char *buf, int size_of_buf)
+ 	 * stores current->comm into buf
+ 	 * Return: 0 on success
+ 	 */
+ 	BPF_FUNC_get_current_comm,
+ 
+ 	/**
+ 	 * bpf_get_cgroup_classid(skb) - retrieve a proc's classid
+ 	 * @skb: pointer to skb
+ 	 * Return: classid if != 0
+ 	 */
+ 	BPF_FUNC_get_cgroup_classid,
+ 	BPF_FUNC_skb_vlan_push, /* bpf_skb_vlan_push(skb, vlan_proto, vlan_tci) */
+ 	BPF_FUNC_skb_vlan_pop,  /* bpf_skb_vlan_pop(skb) */
+ 
+ 	/**
+ 	 * bpf_skb_[gs]et_tunnel_key(skb, key, size, flags)
+ 	 * retrieve or populate tunnel metadata
+ 	 * @skb: pointer to skb
+ 	 * @key: pointer to 'struct bpf_tunnel_key'
+ 	 * @size: size of 'struct bpf_tunnel_key'
+ 	 * @flags: room for future extensions
+ 	 * Retrun: 0 on success
+ 	 */
+ 	BPF_FUNC_skb_get_tunnel_key,
+ 	BPF_FUNC_skb_set_tunnel_key,
+ 	BPF_FUNC_perf_event_read,	/* u64 bpf_perf_event_read(&map, index) */
+ 	/**
+ 	 * bpf_redirect(ifindex, flags) - redirect to another netdev
+ 	 * @ifindex: ifindex of the net device
+ 	 * @flags: bit 0 - if set, redirect to ingress instead of egress
+ 	 *         other bits - reserved
+ 	 * Return: TC_ACT_REDIRECT
+ 	 */
+ 	BPF_FUNC_redirect,
+ 
+ 	/**
+ 	 * bpf_get_route_realm(skb) - retrieve a dst's tclassid
+ 	 * @skb: pointer to skb
+ 	 * Return: realm if != 0
+ 	 */
+ 	BPF_FUNC_get_route_realm,
+ 
+ 	/**
+ 	 * bpf_perf_event_output(ctx, map, index, data, size) - output perf raw sample
+ 	 * @ctx: struct pt_regs*
+ 	 * @map: pointer to perf_event_array map
+ 	 * @index: index of event in the map
+ 	 * @data: data on stack to be output as raw data
+ 	 * @size: size of data
+ 	 * Return: 0 on success
+ 	 */
+ 	BPF_FUNC_perf_event_output,
++>>>>>>> a43eec304259 (bpf: introduce bpf_perf_event_output() helper)
  	__BPF_FUNC_MAX_ID,
  };
  
* Unmerged path kernel/bpf/arraymap.c
* Unmerged path kernel/bpf/verifier.c
* Unmerged path kernel/trace/bpf_trace.c
* Unmerged path include/uapi/linux/bpf.h
diff --git a/include/uapi/linux/perf_event.h b/include/uapi/linux/perf_event.h
index 1eb19106f8ae..67a9e1f92fec 100644
--- a/include/uapi/linux/perf_event.h
+++ b/include/uapi/linux/perf_event.h
@@ -110,6 +110,7 @@ enum perf_sw_ids {
 	PERF_COUNT_SW_ALIGNMENT_FAULTS		= 7,
 	PERF_COUNT_SW_EMULATION_FAULTS		= 8,
 	PERF_COUNT_SW_DUMMY			= 9,
+	PERF_COUNT_SW_BPF_OUTPUT		= 10,
 
 	PERF_COUNT_SW_MAX,			/* non-ABI */
 };
* Unmerged path kernel/bpf/arraymap.c
* Unmerged path kernel/bpf/verifier.c
* Unmerged path kernel/trace/bpf_trace.c
