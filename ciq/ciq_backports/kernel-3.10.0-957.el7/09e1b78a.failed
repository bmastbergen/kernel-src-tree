drm/nouveau/kms/nv50-: split core implementation by hardware class

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ben Skeggs <bskeggs@redhat.com>
commit 09e1b78aab5715eacab02e4047c7a47d72f6a1e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/09e1b78a.failed

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit 09e1b78aab5715eacab02e4047c7a47d72f6a1e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/amdgpu/amdgpu_powerplay.h
#	drivers/gpu/drm/amd/powerplay/inc/pp_asicblocks.h
#	drivers/gpu/drm/amd/powerplay/inc/pp_instance.h
#	drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.h
#	drivers/gpu/drm/nouveau/dispnv50/Kbuild
#	drivers/gpu/drm/nouveau/dispnv50/core.c
#	drivers/gpu/drm/nouveau/dispnv50/core.h
#	drivers/gpu/drm/nouveau/dispnv50/disp.c
#	drivers/gpu/drm/nouveau/dispnv50/head.c
#	drivers/gpu/drm/nouveau/dispnv50/head.h
#	drivers/gpu/drm/nouveau/dispnv50/head507d.c
diff --cc drivers/gpu/drm/amd/amdgpu/amdgpu_powerplay.h
index c0c4bfdcdb14,2a10ef7d30a8..000000000000
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_powerplay.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_powerplay.h
@@@ -18,16 -18,27 +18,35 @@@
   * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   * OTHER DEALINGS IN THE SOFTWARE.
 + *
 + * Authors: AMD
 + *
   */
 -#include "core.h"
  
++<<<<<<< HEAD:drivers/gpu/drm/amd/amdgpu/amdgpu_powerplay.h
 +#ifndef __AMDGPU_POWERPLAY_H__
 +#define __AMDGPU_POWERPLAY_H__
 +
 +#include "amd_shared.h"
++=======
+ static void
+ dac507d_ctrl(struct nv50_core *core, int or, u32 ctrl,
+ 	     struct nv50_head_atom *asyh)
+ {
+ 	u32 *push, sync = 0;
+ 	if ((push = evo_wait(&core->chan, 3))) {
+ 		if (asyh) {
+ 			sync |= asyh->or.nvsync << 1;
+ 			sync |= asyh->or.nhsync;
+ 		}
+ 		evo_mthd(push, 0x0400 + (or * 0x080), 2);
+ 		evo_data(push, ctrl);
+ 		evo_data(push, sync);
+ 		evo_kick(push, &core->chan);
+ 	}
+ }
++>>>>>>> 09e1b78aab57 (drm/nouveau/kms/nv50-: split core implementation by hardware class):drivers/gpu/drm/nouveau/dispnv50/dac507d.c
 +
 +extern const struct amdgpu_ip_block_version amdgpu_pp_ip_block;
  
 -const struct nv50_outp_func
 -dac507d = {
 -	.ctrl = dac507d_ctrl,
 -};
 +#endif /* __AMDGPU_POWERPLAY_H__ */
diff --cc drivers/gpu/drm/amd/powerplay/inc/pp_asicblocks.h
index 0c1593e53654,d2bac6a341dc..000000000000
--- a/drivers/gpu/drm/amd/powerplay/inc/pp_asicblocks.h
+++ b/drivers/gpu/drm/amd/powerplay/inc/pp_asicblocks.h
@@@ -18,30 -18,27 +18,53 @@@
   * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   * OTHER DEALINGS IN THE SOFTWARE.
 + *
   */
 -#include "core.h"
 +#ifndef PP_ASICBLOCKS_H
 +#define PP_ASICBLOCKS_H
 +
++<<<<<<< HEAD:drivers/gpu/drm/amd/powerplay/inc/pp_asicblocks.h
  
 +enum PHM_AsicBlock {
 +	PHM_AsicBlock_GFX,
 +	PHM_AsicBlock_UVD_MVC,
 +	PHM_AsicBlock_UVD,
 +	PHM_AsicBlock_UVD_HD,
 +	PHM_AsicBlock_UVD_SD,
 +	PHM_AsicBlock_Count
++=======
+ static void
+ pior507d_ctrl(struct nv50_core *core, int or, u32 ctrl,
+ 	      struct nv50_head_atom *asyh)
+ {
+ 	u32 *push;
+ 	if ((push = evo_wait(&core->chan, 2))) {
+ 		if (asyh) {
+ 			ctrl |= asyh->or.depth  << 16;
+ 			ctrl |= asyh->or.nvsync << 13;
+ 			ctrl |= asyh->or.nhsync << 12;
+ 		}
+ 		evo_mthd(push, 0x0700 + (or * 0x040), 1);
+ 		evo_data(push, ctrl);
+ 		evo_kick(push, &core->chan);
+ 	}
+ }
+ 
+ const struct nv50_outp_func
+ pior507d = {
+ 	.ctrl = pior507d_ctrl,
++>>>>>>> 09e1b78aab57 (drm/nouveau/kms/nv50-: split core implementation by hardware class):drivers/gpu/drm/nouveau/dispnv50/pior507d.c
 +};
 +
 +enum PHM_ClockGateSetting {
 +	PHM_ClockGateSetting_StaticOn,
 +	PHM_ClockGateSetting_StaticOff,
 +	PHM_ClockGateSetting_Dynamic
  };
 +
 +struct phm_asic_blocks {
 +	bool gfx : 1;
 +	bool uvd : 1;
 +};
 +
 +#endif
diff --cc drivers/gpu/drm/amd/powerplay/inc/pp_instance.h
index 4c3b537a714f,5222fe6a9b21..000000000000
--- a/drivers/gpu/drm/amd/powerplay/inc/pp_instance.h
+++ b/drivers/gpu/drm/amd/powerplay/inc/pp_instance.h
@@@ -18,28 -18,27 +18,47 @@@
   * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   * OTHER DEALINGS IN THE SOFTWARE.
 + *
   */
 -#include "core.h"
 +#ifndef _PP_INSTANCE_H_
 +#define _PP_INSTANCE_H_
 +
++<<<<<<< HEAD:drivers/gpu/drm/amd/powerplay/inc/pp_instance.h
 +#include "smumgr.h"
 +#include "hwmgr.h"
 +#include "eventmgr.h"
  
 +#define PP_VALID  0x1F1F1F1F
++=======
+ static void
+ sor507d_ctrl(struct nv50_core *core, int or, u32 ctrl,
+ 	     struct nv50_head_atom *asyh)
+ {
+ 	u32 *push;
+ 	if ((push = evo_wait(&core->chan, 2))) {
+ 		if (asyh) {
+ 			ctrl |= asyh->or.depth  << 16;
+ 			ctrl |= asyh->or.nvsync << 13;
+ 			ctrl |= asyh->or.nhsync << 12;
+ 		}
+ 		evo_mthd(push, 0x0600 + (or * 0x40), 1);
+ 		evo_data(push, ctrl);
+ 		evo_kick(push, &core->chan);
+ 	}
+ }
++>>>>>>> 09e1b78aab57 (drm/nouveau/kms/nv50-: split core implementation by hardware class):drivers/gpu/drm/nouveau/dispnv50/sor507d.c
  
 -const struct nv50_outp_func
 -sor507d = {
 -	.ctrl = sor507d_ctrl,
 +struct pp_instance {
 +	uint32_t pp_valid;
 +	uint32_t chip_family;
 +	uint32_t chip_id;
 +	bool pm_en;
 +	uint32_t feature_mask;
 +	void *device;
 +	struct pp_smumgr *smu_mgr;
 +	struct pp_hwmgr *hwmgr;
 +	struct pp_eventmgr *eventmgr;
 +	struct mutex pp_lock;
  };
 +
 +#endif
diff --cc drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.h
index 262c8ded87c0,96d7d8fde669..000000000000
--- a/drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.h
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.h
@@@ -18,45 -18,97 +18,113 @@@
   * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   * OTHER DEALINGS IN THE SOFTWARE.
 + *
   */
 -#include "core.h"
 -#include "head.h"
  
 -#include <nvif/cl507d.h>
 +#ifndef PP_RAVEN_SMUMANAGER_H
 +#define PP_RAVEN_SMUMANAGER_H
 +
 +#include "rv_ppsmc.h"
 +#include "smu10_driver_if.h"
  
 -#include "nouveau_bo.h"
++<<<<<<< HEAD:drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.h
 +enum SMU_TABLE_ID {
 +	WMTABLE = 0,
 +	CLOCKTABLE,
 +	MAX_SMU_TABLE,
 +};
  
 +struct smu_table_entry {
 +	uint32_t version;
 +	uint32_t size;
 +	uint32_t table_id;
 +	uint32_t table_addr_high;
 +	uint32_t table_addr_low;
 +	uint8_t *table;
 +	uint32_t handle;
 +};
++=======
+ void
+ core507d_update(struct nv50_core *core, u32 interlock, bool ntfy)
+ {
+ 	u32 *push;
+ 	if ((push = evo_wait(&core->chan, 5))) {
+ 		if (ntfy) {
+ 			evo_mthd(push, 0x0084, 1);
+ 			evo_data(push, 0x80000000 | NV50_DISP_CORE_NTFY);
+ 		}
+ 		evo_mthd(push, 0x0080, 2);
+ 		evo_data(push, interlock);
+ 		evo_data(push, 0x00000000);
+ 		evo_kick(push, &core->chan);
+ 	}
+ }
+ 
+ int
+ core507d_ntfy_wait_done(struct nouveau_bo *bo, u32 offset,
+ 			struct nvif_device *device)
+ {
+ 	s64 time = nvif_msec(device, 2000ULL,
+ 		if (nouveau_bo_rd32(bo, offset / 4))
+ 			break;
+ 		usleep_range(1, 2);
+ 	);
+ 	return time < 0 ? time : 0;
+ }
+ 
+ void
+ core507d_ntfy_init(struct nouveau_bo *bo, u32 offset)
+ {
+ 	nouveau_bo_wr32(bo, offset / 4, 0x00000000);
+ }
+ 
+ void
+ core507d_init(struct nv50_core *core)
+ {
+ 	u32 *push;
+ 	if ((push = evo_wait(&core->chan, 2))) {
+ 		evo_mthd(push, 0x0088, 1);
+ 		evo_data(push, core->chan.sync.handle);
+ 		evo_kick(push, &core->chan);
+ 	}
+ }
+ 
+ static const struct nv50_core_func
+ core507d = {
+ 	.init = core507d_init,
+ 	.ntfy_init = core507d_ntfy_init,
+ 	.ntfy_wait_done = core507d_ntfy_wait_done,
+ 	.update = core507d_update,
+ 	.head = &head507d,
+ 	.dac = &dac507d,
+ 	.sor = &sor507d,
+ 	.pior = &pior507d,
+ };
+ 
+ int
+ core507d_new_(const struct nv50_core_func *func, struct nouveau_drm *drm,
+ 	      s32 oclass, struct nv50_core **pcore)
+ {
+ 	struct nv50_disp_core_channel_dma_v0 args = {};
+ 	struct nv50_disp *disp = nv50_disp(drm->dev);
+ 	struct nv50_core *core;
+ 	int ret;
++>>>>>>> 09e1b78aab57 (drm/nouveau/kms/nv50-: split core implementation by hardware class):drivers/gpu/drm/nouveau/dispnv50/core507d.c
  
 -	if (!(core = *pcore = kzalloc(sizeof(*core), GFP_KERNEL)))
 -		return -ENOMEM;
 -	core->func = func;
 +struct smu_table_array {
 +	struct smu_table_entry entry[MAX_SMU_TABLE];
 +};
  
 -	ret = nv50_dmac_create(&drm->client.device, &disp->disp->object,
 -			       &oclass, 0, &args, sizeof(args),
 -			       disp->sync->bo.offset, &core->chan);
 -	if (ret) {
 -		NV_ERROR(drm, "core%04x allocation failed: %d\n", oclass, ret);
 -		return ret;
 -	}
 +struct rv_smumgr {
 +	struct smu_table_array            smu_tables;
 +};
  
 -	return 0;
 -}
 +int rv_read_arg_from_smc(struct pp_smumgr *smumgr, uint32_t *arg);
 +bool rv_is_smc_ram_running(struct pp_smumgr *smumgr);
 +int rv_copy_table_from_smc(struct pp_smumgr *smumgr,
 +		uint8_t *table, int16_t table_id);
 +int rv_copy_table_to_smc(struct pp_smumgr *smumgr,
 +		uint8_t *table, int16_t table_id);
  
 -int
 -core507d_new(struct nouveau_drm *drm, s32 oclass, struct nv50_core **pcore)
 -{
 -	return core507d_new_(&core507d, drm, oclass, pcore);
 -}
 +
 +#endif
diff --cc drivers/gpu/drm/nouveau/dispnv50/Kbuild
index 43fc8be49391,cde3ae98191a..000000000000
--- a/drivers/gpu/drm/nouveau/dispnv50/Kbuild
+++ b/drivers/gpu/drm/nouveau/dispnv50/Kbuild
@@@ -1,1 -1,35 +1,38 @@@
  nouveau-y += dispnv50/disp.o
++<<<<<<< HEAD
++=======
+ 
+ nouveau-y += dispnv50/core.o
+ nouveau-y += dispnv50/core507d.o
+ nouveau-y += dispnv50/core827d.o
+ nouveau-y += dispnv50/core907d.o
+ nouveau-y += dispnv50/core917d.o
+ 
+ nouveau-y += dispnv50/dac507d.o
+ nouveau-y += dispnv50/dac907d.o
+ 
+ nouveau-y += dispnv50/pior507d.o
+ 
+ nouveau-y += dispnv50/sor507d.o
+ nouveau-y += dispnv50/sor907d.o
+ 
+ nouveau-y += dispnv50/head.o
+ nouveau-y += dispnv50/head507d.o
+ nouveau-y += dispnv50/head827d.o
+ nouveau-y += dispnv50/head907d.o
+ nouveau-y += dispnv50/head917d.o
+ 
+ nouveau-y += dispnv50/wndw.o
+ 
+ nouveau-y += dispnv50/base.o
+ nouveau-y += dispnv50/base507c.o
+ 
+ nouveau-y += dispnv50/curs.o
+ nouveau-y += dispnv50/curs507a.o
+ 
+ nouveau-y += dispnv50/oimm.o
+ nouveau-y += dispnv50/oimm507b.o
+ 
+ nouveau-y += dispnv50/ovly.o
+ nouveau-y += dispnv50/ovly507e.o
++>>>>>>> 09e1b78aab57 (drm/nouveau/kms/nv50-: split core implementation by hardware class)
diff --cc drivers/gpu/drm/nouveau/dispnv50/disp.c
index a2ea42f947c7,6136beeba3fc..000000000000
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.c
@@@ -3854,10 -1587,9 +3854,13 @@@ static voi
  nv50_disp_atomic_commit_core(struct nouveau_drm *drm, u32 interlock)
  {
  	struct nv50_disp *disp = nv50_disp(drm->dev);
++<<<<<<< HEAD
 +	struct nv50_dmac *core = &disp->mast.base;
++=======
+ 	struct nv50_core *core = disp->core;
++>>>>>>> 09e1b78aab57 (drm/nouveau/kms/nv50-: split core implementation by hardware class)
  	struct nv50_mstm *mstm;
  	struct drm_encoder *encoder;
- 	u32 *push;
  
  	NV_ATOMIC(drm, "commit core %08x\n", interlock);
  
@@@ -4037,16 -1759,10 +4030,21 @@@ nv50_disp_atomic_commit_tail(struct drm
  
  	/* Flush update. */
  	if (interlock_core) {
++<<<<<<< HEAD
 +		if (!interlock_chan && atom->state.legacy_cursor_update) {
 +			u32 *push = evo_wait(&disp->mast, 2);
 +			if (push) {
 +				evo_mthd(push, 0x0080, 1);
 +				evo_data(push, 0x00000000);
 +				evo_kick(push, &disp->mast);
 +			}
 +		} else {
++=======
+ 		if (interlock_chan || !atom->state.legacy_cursor_update)
++>>>>>>> 09e1b78aab57 (drm/nouveau/kms/nv50-: split core implementation by hardware class)
  			nv50_disp_atomic_commit_core(drm, interlock_chan);
- 		}
+ 		else
+ 			disp->core->func->update(disp->core, 0, false);
  	}
  
  	if (atom->lock_core)
@@@ -4346,18 -2062,11 +4344,26 @@@ nv50_display_fini(struct drm_device *de
  int
  nv50_display_init(struct drm_device *dev)
  {
++<<<<<<< HEAD
 +	struct drm_encoder *encoder;
 +	struct drm_plane *plane;
 +	struct drm_crtc *crtc;
 +	u32 *push;
 +
 +	push = evo_wait(nv50_mast(dev), 32);
 +	if (!push)
 +		return -EBUSY;
 +
 +	evo_mthd(push, 0x0088, 1);
 +	evo_data(push, nv50_mast(dev)->base.sync.handle);
 +	evo_kick(push, nv50_mast(dev));
++=======
+ 	struct nv50_core *core = nv50_disp(dev)->core;
+ 	struct drm_encoder *encoder;
+ 	struct drm_plane *plane;
+ 
+ 	core->func->init(core);
++>>>>>>> 09e1b78aab57 (drm/nouveau/kms/nv50-: split core implementation by hardware class)
  
  	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
  		if (encoder->encoder_type != DRM_MODE_ENCODER_DPMST) {
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/core.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/core.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/head.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/head.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/head507d.c
* Unmerged path drivers/gpu/drm/amd/amdgpu/amdgpu_powerplay.h
* Unmerged path drivers/gpu/drm/amd/powerplay/inc/pp_asicblocks.h
* Unmerged path drivers/gpu/drm/amd/powerplay/inc/pp_instance.h
* Unmerged path drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/Kbuild
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/core.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/core.h
diff --git a/drivers/gpu/drm/nouveau/dispnv50/core827d.c b/drivers/gpu/drm/nouveau/dispnv50/core827d.c
new file mode 100644
index 000000000000..6123a068f836
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv50/core827d.c
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2018 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "core.h"
+#include "head.h"
+
+static const struct nv50_core_func
+core827d = {
+	.init = core507d_init,
+	.ntfy_init = core507d_ntfy_init,
+	.ntfy_wait_done = core507d_ntfy_wait_done,
+	.update = core507d_update,
+	.head = &head827d,
+	.dac = &dac507d,
+	.sor = &sor507d,
+	.pior = &pior507d,
+};
+
+int
+core827d_new(struct nouveau_drm *drm, s32 oclass, struct nv50_core **pcore)
+{
+	return core507d_new_(&core827d, drm, oclass, pcore);
+}
diff --git a/drivers/gpu/drm/nouveau/dispnv50/core907d.c b/drivers/gpu/drm/nouveau/dispnv50/core907d.c
new file mode 100644
index 000000000000..ef822f813435
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv50/core907d.c
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2018 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "core.h"
+#include "head.h"
+
+static const struct nv50_core_func
+core907d = {
+	.init = core507d_init,
+	.ntfy_init = core507d_ntfy_init,
+	.ntfy_wait_done = core507d_ntfy_wait_done,
+	.update = core507d_update,
+	.head = &head907d,
+	.dac = &dac907d,
+	.sor = &sor907d,
+};
+
+int
+core907d_new(struct nouveau_drm *drm, s32 oclass, struct nv50_core **pcore)
+{
+	return core507d_new_(&core907d, drm, oclass, pcore);
+}
diff --git a/drivers/gpu/drm/nouveau/dispnv50/core917d.c b/drivers/gpu/drm/nouveau/dispnv50/core917d.c
new file mode 100644
index 000000000000..392338df5bfd
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv50/core917d.c
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2018 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "core.h"
+#include "head.h"
+
+static const struct nv50_core_func
+core917d = {
+	.init = core507d_init,
+	.ntfy_init = core507d_ntfy_init,
+	.ntfy_wait_done = core507d_ntfy_wait_done,
+	.update = core507d_update,
+	.head = &head917d,
+	.dac = &dac907d,
+	.sor = &sor907d,
+};
+
+int
+core917d_new(struct nouveau_drm *drm, s32 oclass, struct nv50_core **pcore)
+{
+	return core507d_new_(&core917d, drm, oclass, pcore);
+}
diff --git a/drivers/gpu/drm/nouveau/dispnv50/dac907d.c b/drivers/gpu/drm/nouveau/dispnv50/dac907d.c
new file mode 100644
index 000000000000..11e87fa53fac
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv50/dac907d.c
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2018 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "core.h"
+
+static void
+dac907d_ctrl(struct nv50_core *core, int or, u32 ctrl,
+	     struct nv50_head_atom *asyh)
+{
+	u32 *push;
+	if ((push = evo_wait(&core->chan, 2))) {
+		evo_mthd(push, 0x0180 + (or * 0x020), 1);
+		evo_data(push, ctrl);
+		evo_kick(push, &core->chan);
+	}
+}
+
+const struct nv50_outp_func
+dac907d = {
+	.ctrl = dac907d_ctrl,
+};
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/disp.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/head.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/head.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/head507d.c
diff --git a/drivers/gpu/drm/nouveau/dispnv50/head827d.c b/drivers/gpu/drm/nouveau/dispnv50/head827d.c
new file mode 100644
index 000000000000..84ce595fbe79
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv50/head827d.c
@@ -0,0 +1,120 @@
+/*
+ * Copyright 2018 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "head.h"
+#include "core.h"
+
+static void
+head827d_curs_clr(struct nv50_head *head)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 *push;
+	if ((push = evo_wait(core, 4))) {
+		evo_mthd(push, 0x0880 + head->base.index * 0x400, 1);
+		evo_data(push, 0x05000000);
+		evo_mthd(push, 0x089c + head->base.index * 0x400, 1);
+		evo_data(push, 0x00000000);
+		evo_kick(push, core);
+	}
+}
+
+static void
+head827d_curs_set(struct nv50_head *head, struct nv50_head_atom *asyh)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 *push;
+	if ((push = evo_wait(core, 5))) {
+		evo_mthd(push, 0x0880 + head->base.index * 0x400, 2);
+		evo_data(push, 0x80000000 | asyh->curs.layout << 26 |
+					    asyh->curs.format << 24);
+		evo_data(push, asyh->curs.offset >> 8);
+		evo_mthd(push, 0x089c + head->base.index * 0x400, 1);
+		evo_data(push, asyh->curs.handle);
+		evo_kick(push, core);
+	}
+}
+
+static void
+head827d_core_set(struct nv50_head *head, struct nv50_head_atom *asyh)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 *push;
+	if ((push = evo_wait(core, 9))) {
+		evo_mthd(push, 0x0860 + head->base.index * 0x400, 1);
+		evo_data(push, asyh->core.offset >> 8);
+		evo_mthd(push, 0x0868 + head->base.index * 0x400, 4);
+		evo_data(push, asyh->core.h << 16 | asyh->core.w);
+		evo_data(push, asyh->core.layout << 20 |
+			       (asyh->core.pitch >> 8) << 8 |
+			       asyh->core.block);
+		evo_data(push, asyh->core.format << 8);
+		evo_data(push, asyh->core.handle);
+		evo_mthd(push, 0x08c0 + head->base.index * 0x400, 1);
+		evo_data(push, asyh->core.y << 16 | asyh->core.x);
+		evo_kick(push, core);
+	}
+}
+
+static void
+head827d_ilut_clr(struct nv50_head *head)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 *push;
+	if ((push = evo_wait(core, 4))) {
+		evo_mthd(push, 0x0840 + (head->base.index * 0x400), 1);
+		evo_data(push, 0x40000000);
+		evo_mthd(push, 0x085c + (head->base.index * 0x400), 1);
+		evo_data(push, 0x00000000);
+		evo_kick(push, core);
+	}
+}
+
+static void
+head827d_ilut_set(struct nv50_head *head, struct nv50_head_atom *asyh)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 *push;
+	if ((push = evo_wait(core, 5))) {
+		evo_mthd(push, 0x0840 + (head->base.index * 0x400), 2);
+		evo_data(push, 0x80000000 | asyh->ilut.mode << 30);
+		evo_data(push, asyh->ilut.offset >> 8);
+		evo_mthd(push, 0x085c + (head->base.index * 0x400), 1);
+		evo_data(push, asyh->ilut.handle);
+		evo_kick(push, core);
+	}
+}
+
+const struct nv50_head_func
+head827d = {
+	.view = head507d_view,
+	.mode = head507d_mode,
+	.ilut_set = head827d_ilut_set,
+	.ilut_clr = head827d_ilut_clr,
+	.core_calc = head507d_core_calc,
+	.core_set = head827d_core_set,
+	.core_clr = head507d_core_clr,
+	.curs_set = head827d_curs_set,
+	.curs_clr = head827d_curs_clr,
+	.base = head507d_base,
+	.ovly = head507d_ovly,
+	.dither = head507d_dither,
+	.procamp = head507d_procamp,
+};
diff --git a/drivers/gpu/drm/nouveau/dispnv50/head907d.c b/drivers/gpu/drm/nouveau/dispnv50/head907d.c
new file mode 100644
index 000000000000..0035eccd62d6
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv50/head907d.c
@@ -0,0 +1,274 @@
+/*
+ * Copyright 2018 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "head.h"
+#include "core.h"
+
+void
+head907d_or(struct nv50_head *head, struct nv50_head_atom *asyh)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 *push;
+	if ((push = evo_wait(core, 3))) {
+		evo_mthd(push, 0x0404 + (head->base.index * 0x300), 2);
+		evo_data(push, 0x00000001 | asyh->or.depth  << 6 |
+					    asyh->or.nvsync << 4 |
+					    asyh->or.nhsync << 3);
+		evo_data(push, 0x31ec6000 | head->base.index << 25 |
+					    asyh->mode.interlace);
+		evo_kick(push, core);
+	}
+}
+
+void
+head907d_procamp(struct nv50_head *head, struct nv50_head_atom *asyh)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 *push;
+	if ((push = evo_wait(core, 2))) {
+		evo_mthd(push, 0x0498 + (head->base.index * 0x300), 1);
+		evo_data(push, asyh->procamp.sat.sin << 20 |
+			       asyh->procamp.sat.cos << 8);
+		evo_kick(push, core);
+	}
+}
+
+static void
+head907d_dither(struct nv50_head *head, struct nv50_head_atom *asyh)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 *push;
+	if ((push = evo_wait(core, 2))) {
+		evo_mthd(push, 0x0490 + (head->base.index * 0x0300), 1);
+		evo_data(push, asyh->dither.mode << 3 |
+			       asyh->dither.bits << 1 |
+			       asyh->dither.enable);
+		evo_kick(push, core);
+	}
+}
+
+void
+head907d_ovly(struct nv50_head *head, struct nv50_head_atom *asyh)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 bounds = 0;
+	u32 *push;
+
+	if (asyh->ovly.cpp) {
+		switch (asyh->ovly.cpp) {
+		case 8: bounds |= 0x00000500; break;
+		case 4: bounds |= 0x00000300; break;
+		case 2: bounds |= 0x00000100; break;
+		default:
+			WARN_ON(1);
+			break;
+		}
+		bounds |= 0x00000001;
+	}
+
+	if ((push = evo_wait(core, 2))) {
+		evo_mthd(push, 0x04d4 + head->base.index * 0x300, 1);
+		evo_data(push, bounds);
+		evo_kick(push, core);
+	}
+}
+
+void
+head907d_base(struct nv50_head *head, struct nv50_head_atom *asyh)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 bounds = 0;
+	u32 *push;
+
+	if (asyh->base.cpp) {
+		switch (asyh->base.cpp) {
+		case 8: bounds |= 0x00000500; break;
+		case 4: bounds |= 0x00000300; break;
+		case 2: bounds |= 0x00000100; break;
+		case 1: bounds |= 0x00000000; break;
+		default:
+			WARN_ON(1);
+			break;
+		}
+		bounds |= 0x00000001;
+	}
+
+	if ((push = evo_wait(core, 2))) {
+		evo_mthd(push, 0x04d0 + head->base.index * 0x300, 1);
+		evo_data(push, bounds);
+		evo_kick(push, core);
+	}
+}
+
+void
+head907d_curs_clr(struct nv50_head *head)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 *push;
+	if ((push = evo_wait(core, 4))) {
+		evo_mthd(push, 0x0480 + head->base.index * 0x300, 1);
+		evo_data(push, 0x05000000);
+		evo_mthd(push, 0x048c + head->base.index * 0x300, 1);
+		evo_data(push, 0x00000000);
+		evo_kick(push, core);
+	}
+}
+
+void
+head907d_curs_set(struct nv50_head *head, struct nv50_head_atom *asyh)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 *push;
+	if ((push = evo_wait(core, 5))) {
+		evo_mthd(push, 0x0480 + head->base.index * 0x300, 2);
+		evo_data(push, 0x80000000 | asyh->curs.layout << 26 |
+					    asyh->curs.format << 24);
+		evo_data(push, asyh->curs.offset >> 8);
+		evo_mthd(push, 0x048c + head->base.index * 0x300, 1);
+		evo_data(push, asyh->curs.handle);
+		evo_kick(push, core);
+	}
+}
+
+void
+head907d_core_clr(struct nv50_head *head)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 *push;
+	if ((push = evo_wait(core, 2))) {
+		evo_mthd(push, 0x0474 + head->base.index * 0x300, 1);
+		evo_data(push, 0x00000000);
+		evo_kick(push, core);
+	}
+}
+
+void
+head907d_core_set(struct nv50_head *head, struct nv50_head_atom *asyh)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 *push;
+	if ((push = evo_wait(core, 9))) {
+		evo_mthd(push, 0x0460 + head->base.index * 0x300, 1);
+		evo_data(push, asyh->core.offset >> 8);
+		evo_mthd(push, 0x0468 + head->base.index * 0x300, 4);
+		evo_data(push, asyh->core.h << 16 | asyh->core.w);
+		evo_data(push, asyh->core.layout << 24 |
+			       (asyh->core.pitch >> 8) << 8 |
+			       asyh->core.block);
+		evo_data(push, asyh->core.format << 8);
+		evo_data(push, asyh->core.handle);
+		evo_mthd(push, 0x04b0 + head->base.index * 0x300, 1);
+		evo_data(push, asyh->core.y << 16 | asyh->core.x);
+		evo_kick(push, core);
+	}
+}
+
+void
+head907d_ilut_clr(struct nv50_head *head)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 *push;
+	if ((push = evo_wait(core, 4))) {
+		evo_mthd(push, 0x0440 + (head->base.index * 0x300), 1);
+		evo_data(push, 0x03000000);
+		evo_mthd(push, 0x045c + (head->base.index * 0x300), 1);
+		evo_data(push, 0x00000000);
+		evo_kick(push, core);
+	}
+}
+
+void
+head907d_ilut_set(struct nv50_head *head, struct nv50_head_atom *asyh)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 *push;
+	if ((push = evo_wait(core, 7))) {
+		evo_mthd(push, 0x0440 + (head->base.index * 0x300), 4);
+		evo_data(push, 0x80000000 | asyh->ilut.mode << 24);
+		evo_data(push, asyh->ilut.offset >> 8);
+		evo_data(push, 0x00000000);
+		evo_data(push, 0x00000000);
+		evo_mthd(push, 0x045c + (head->base.index * 0x300), 1);
+		evo_data(push, asyh->ilut.handle);
+		evo_kick(push, core);
+	}
+}
+
+void
+head907d_mode(struct nv50_head *head, struct nv50_head_atom *asyh)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	struct nv50_head_mode *m = &asyh->mode;
+	u32 *push;
+	if ((push = evo_wait(core, 14))) {
+		evo_mthd(push, 0x0410 + (head->base.index * 0x300), 6);
+		evo_data(push, 0x00000000);
+		evo_data(push, m->v.active  << 16 | m->h.active );
+		evo_data(push, m->v.synce   << 16 | m->h.synce  );
+		evo_data(push, m->v.blanke  << 16 | m->h.blanke );
+		evo_data(push, m->v.blanks  << 16 | m->h.blanks );
+		evo_data(push, m->v.blank2e << 16 | m->v.blank2s);
+		evo_mthd(push, 0x042c + (head->base.index * 0x300), 2);
+		evo_data(push, 0x00000000); /* ??? */
+		evo_data(push, 0xffffff00);
+		evo_mthd(push, 0x0450 + (head->base.index * 0x300), 3);
+		evo_data(push, m->clock * 1000);
+		evo_data(push, 0x00200000); /* ??? */
+		evo_data(push, m->clock * 1000);
+		evo_kick(push, core);
+	}
+}
+
+void
+head907d_view(struct nv50_head *head, struct nv50_head_atom *asyh)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 *push;
+	if ((push = evo_wait(core, 8))) {
+		evo_mthd(push, 0x0494 + (head->base.index * 0x300), 1);
+		evo_data(push, 0x00000000);
+		evo_mthd(push, 0x04b8 + (head->base.index * 0x300), 1);
+		evo_data(push, asyh->view.iH << 16 | asyh->view.iW);
+		evo_mthd(push, 0x04c0 + (head->base.index * 0x300), 3);
+		evo_data(push, asyh->view.oH << 16 | asyh->view.oW);
+		evo_data(push, asyh->view.oH << 16 | asyh->view.oW);
+		evo_data(push, asyh->view.oH << 16 | asyh->view.oW);
+		evo_kick(push, core);
+	}
+}
+
+const struct nv50_head_func
+head907d = {
+	.view = head907d_view,
+	.mode = head907d_mode,
+	.ilut_set = head907d_ilut_set,
+	.ilut_clr = head907d_ilut_clr,
+	.core_calc = head507d_core_calc,
+	.core_set = head907d_core_set,
+	.core_clr = head907d_core_clr,
+	.curs_set = head907d_curs_set,
+	.curs_clr = head907d_curs_clr,
+	.base = head907d_base,
+	.ovly = head907d_ovly,
+	.dither = head907d_dither,
+	.procamp = head907d_procamp,
+	.or = head907d_or,
+};
diff --git a/drivers/gpu/drm/nouveau/dispnv50/head917d.c b/drivers/gpu/drm/nouveau/dispnv50/head917d.c
new file mode 100644
index 000000000000..5341ea3bc7b6
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv50/head917d.c
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2018 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "head.h"
+#include "core.h"
+
+static void
+head917d_dither(struct nv50_head *head, struct nv50_head_atom *asyh)
+{
+	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+	u32 *push;
+	if ((push = evo_wait(core, 2))) {
+		evo_mthd(push, 0x04a0 + (head->base.index * 0x0300), 1);
+		evo_data(push, asyh->dither.mode << 3 |
+			       asyh->dither.bits << 1 |
+			       asyh->dither.enable);
+		evo_kick(push, core);
+	}
+}
+
+const struct nv50_head_func
+head917d = {
+	.view = head907d_view,
+	.mode = head907d_mode,
+	.ilut_set = head907d_ilut_set,
+	.ilut_clr = head907d_ilut_clr,
+	.core_calc = head507d_core_calc,
+	.core_set = head907d_core_set,
+	.core_clr = head907d_core_clr,
+	.curs_set = head907d_curs_set,
+	.curs_clr = head907d_curs_clr,
+	.base = head907d_base,
+	.ovly = head907d_ovly,
+	.dither = head917d_dither,
+	.procamp = head907d_procamp,
+	.or = head907d_or,
+};
diff --git a/drivers/gpu/drm/nouveau/dispnv50/sor907d.c b/drivers/gpu/drm/nouveau/dispnv50/sor907d.c
new file mode 100644
index 000000000000..b0314ec11fb3
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv50/sor907d.c
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2018 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "core.h"
+
+#include <nvif/class.h>
+
+static void
+sor907d_ctrl(struct nv50_core *core, int or, u32 ctrl,
+	     struct nv50_head_atom *asyh)
+{
+	u32 *push;
+	if ((push = evo_wait(&core->chan, 2))) {
+		evo_mthd(push, 0x0200 + (or * 0x20), 1);
+		evo_data(push, ctrl);
+		evo_kick(push, &core->chan);
+	}
+}
+
+const struct nv50_outp_func
+sor907d = {
+	.ctrl = sor907d_ctrl,
+};
