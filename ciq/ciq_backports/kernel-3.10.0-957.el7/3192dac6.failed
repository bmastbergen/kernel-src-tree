net: Rename NETEVENT_MULTIPATH_HASH_UPDATE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] Rename NETEVENT_MULTIPATH_HASH_UPDATE (Ivan Vecera) [1585245]
Rebuild_FUZZ: 93.67%
commit-author David Ahern <dsahern@gmail.com>
commit 3192dac64c73d8c0eb4274a3da23d829fb5177af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3192dac6.failed

Rename NETEVENT_MULTIPATH_HASH_UPDATE to
NETEVENT_IPV4_MPATH_HASH_UPDATE to denote it relates to a change
in the IPv4 hash policy.

	Signed-off-by: David Ahern <dsahern@gmail.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3192dac64c73d8c0eb4274a3da23d829fb5177af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
#	include/net/netevent.h
#	net/ipv4/sysctl_net_ipv4.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index cf1d2efccbc3,93d48c1b2bf8..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -1965,9 -2427,24 +1965,27 @@@ int mlxsw_sp_router_netevent_event(stru
  		 * work.
  		 */
  		neigh_clone(n);
 -		mlxsw_core_schedule_work(&net_work->work);
 +		mlxsw_core_schedule_work(&neigh_work->work);
  		mlxsw_sp_port_dev_put(mlxsw_sp_port);
  		break;
++<<<<<<< HEAD
++=======
+ 	case NETEVENT_IPV4_MPATH_HASH_UPDATE:
+ 		net = ptr;
+ 
+ 		if (!net_eq(net, &init_net))
+ 			return NOTIFY_DONE;
+ 
+ 		net_work = kzalloc(sizeof(*net_work), GFP_ATOMIC);
+ 		if (!net_work)
+ 			return NOTIFY_BAD;
+ 
+ 		router = container_of(nb, struct mlxsw_sp_router, netevent_nb);
+ 		INIT_WORK(&net_work->work, mlxsw_sp_router_mp_hash_event_work);
+ 		net_work->mlxsw_sp = router->mlxsw_sp;
+ 		mlxsw_core_schedule_work(&net_work->work);
+ 		break;
++>>>>>>> 3192dac64c73 (net: Rename NETEVENT_MULTIPATH_HASH_UPDATE)
  	}
  
  	return NOTIFY_DONE;
diff --cc include/net/netevent.h
index f440df172b56,baee605a94ab..000000000000
--- a/include/net/netevent.h
+++ b/include/net/netevent.h
@@@ -25,6 -26,7 +25,10 @@@ enum netevent_notif_type 
  	NETEVENT_NEIGH_UPDATE = 1, /* arg is struct neighbour ptr */
  	NETEVENT_REDIRECT,	   /* arg is struct netevent_redirect ptr */
  	NETEVENT_DELAY_PROBE_TIME_UPDATE, /* arg is struct neigh_parms ptr */
++<<<<<<< HEAD
++=======
+ 	NETEVENT_IPV4_MPATH_HASH_UPDATE, /* arg is struct net ptr */
++>>>>>>> 3192dac64c73 (net: Rename NETEVENT_MULTIPATH_HASH_UPDATE)
  };
  
  int register_netevent_notifier(struct notifier_block *nb);
diff --cc net/ipv4/sysctl_net_ipv4.c
index 12b498f653f9,011de9a20ec6..000000000000
--- a/net/ipv4/sysctl_net_ipv4.c
+++ b/net/ipv4/sysctl_net_ipv4.c
@@@ -298,10 -300,116 +298,119 @@@ bad_key
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static void proc_configure_early_demux(int enabled, int protocol)
+ {
+ 	struct net_protocol *ipprot;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	struct inet6_protocol *ip6prot;
+ #endif
+ 
+ 	rcu_read_lock();
+ 
+ 	ipprot = rcu_dereference(inet_protos[protocol]);
+ 	if (ipprot)
+ 		ipprot->early_demux = enabled ? ipprot->early_demux_handler :
+ 						NULL;
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	ip6prot = rcu_dereference(inet6_protos[protocol]);
+ 	if (ip6prot)
+ 		ip6prot->early_demux = enabled ? ip6prot->early_demux_handler :
+ 						 NULL;
+ #endif
+ 	rcu_read_unlock();
+ }
+ 
+ static int proc_tcp_early_demux(struct ctl_table *table, int write,
+ 				void __user *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int ret = 0;
+ 
+ 	ret = proc_dointvec(table, write, buffer, lenp, ppos);
+ 
+ 	if (write && !ret) {
+ 		int enabled = init_net.ipv4.sysctl_tcp_early_demux;
+ 
+ 		proc_configure_early_demux(enabled, IPPROTO_TCP);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int proc_udp_early_demux(struct ctl_table *table, int write,
+ 				void __user *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int ret = 0;
+ 
+ 	ret = proc_dointvec(table, write, buffer, lenp, ppos);
+ 
+ 	if (write && !ret) {
+ 		int enabled = init_net.ipv4.sysctl_udp_early_demux;
+ 
+ 		proc_configure_early_demux(enabled, IPPROTO_UDP);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int proc_tfo_blackhole_detect_timeout(struct ctl_table *table,
+ 					     int write,
+ 					     void __user *buffer,
+ 					     size_t *lenp, loff_t *ppos)
+ {
+ 	struct net *net = container_of(table->data, struct net,
+ 	    ipv4.sysctl_tcp_fastopen_blackhole_timeout);
+ 	int ret;
+ 
+ 	ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);
+ 	if (write && ret == 0)
+ 		atomic_set(&net->ipv4.tfo_active_disable_times, 0);
+ 
+ 	return ret;
+ }
+ 
+ static int proc_tcp_available_ulp(struct ctl_table *ctl,
+ 				  int write,
+ 				  void __user *buffer, size_t *lenp,
+ 				  loff_t *ppos)
+ {
+ 	struct ctl_table tbl = { .maxlen = TCP_ULP_BUF_MAX, };
+ 	int ret;
+ 
+ 	tbl.data = kmalloc(tbl.maxlen, GFP_USER);
+ 	if (!tbl.data)
+ 		return -ENOMEM;
+ 	tcp_get_available_ulp(tbl.data, TCP_ULP_BUF_MAX);
+ 	ret = proc_dostring(&tbl, write, buffer, lenp, ppos);
+ 	kfree(tbl.data);
+ 
+ 	return ret;
+ }
+ 
+ #ifdef CONFIG_IP_ROUTE_MULTIPATH
+ static int proc_fib_multipath_hash_policy(struct ctl_table *table, int write,
+ 					  void __user *buffer, size_t *lenp,
+ 					  loff_t *ppos)
+ {
+ 	struct net *net = container_of(table->data, struct net,
+ 	    ipv4.sysctl_fib_multipath_hash_policy);
+ 	int ret;
+ 
+ 	ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);
+ 	if (write && ret == 0)
+ 		call_netevent_notifiers(NETEVENT_IPV4_MPATH_HASH_UPDATE, net);
+ 
+ 	return ret;
+ }
+ #endif
+ 
++>>>>>>> 3192dac64c73 (net: Rename NETEVENT_MULTIPATH_HASH_UPDATE)
  static struct ctl_table ipv4_table[] = {
  	{
 -		.procname	= "tcp_max_orphans",
 -		.data		= &sysctl_tcp_max_orphans,
 +		.procname	= "tcp_timestamps",
 +		.data		= &sysctl_tcp_timestamps,
  		.maxlen		= sizeof(int),
  		.mode		= 0644,
  		.proc_handler	= proc_dointvec
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
* Unmerged path include/net/netevent.h
* Unmerged path net/ipv4/sysctl_net_ipv4.c
