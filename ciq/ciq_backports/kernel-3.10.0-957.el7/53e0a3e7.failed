drm/nouveau/kms/nv50-: simplify tracking of channel interlocks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ben Skeggs <bskeggs@redhat.com>
commit 53e0a3e70de69dc9f498d26c6b5495b2771ee374
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/53e0a3e7.failed

Instead of windows returning their core channel interlock mask if they
know core has been modified, it's recorded unconditionally and used if
required when update methods are emitted.

This will be required to support Volta.

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit 53e0a3e70de69dc9f498d26c6b5495b2771ee374)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/powerplay/inc/pp_soc15.h
#	drivers/gpu/drm/amd/powerplay/smumgr/polaris10_smc.h
#	drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.h
#	drivers/gpu/drm/nouveau/dispnv50/Kbuild
#	drivers/gpu/drm/nouveau/dispnv50/base.h
#	drivers/gpu/drm/nouveau/dispnv50/base507c.c
#	drivers/gpu/drm/nouveau/dispnv50/base827c.c
#	drivers/gpu/drm/nouveau/dispnv50/base907c.c
#	drivers/gpu/drm/nouveau/dispnv50/core.h
#	drivers/gpu/drm/nouveau/dispnv50/core507d.c
#	drivers/gpu/drm/nouveau/dispnv50/curs.h
#	drivers/gpu/drm/nouveau/dispnv50/curs507a.c
#	drivers/gpu/drm/nouveau/dispnv50/disp.c
#	drivers/gpu/drm/nouveau/dispnv50/disp.h
#	drivers/gpu/drm/nouveau/dispnv50/ovly.h
#	drivers/gpu/drm/nouveau/dispnv50/wndw.c
#	drivers/gpu/drm/nouveau/dispnv50/wndw.h
diff --cc drivers/gpu/drm/amd/powerplay/inc/pp_soc15.h
index a511611ec7e0,fb842ed2592f..000000000000
--- a/drivers/gpu/drm/amd/powerplay/inc/pp_soc15.h
+++ b/drivers/gpu/drm/amd/powerplay/inc/pp_soc15.h
@@@ -18,33 -18,34 +18,50 @@@
   * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   * OTHER DEALINGS IN THE SOFTWARE.
 + *
   */
 -#include "curs.h"
 +#ifndef PP_SOC15_H
 +#define PP_SOC15_H
  
 -#include <nvif/class.h>
 +#include "vega10/soc15ip.h"
  
 -int
 -nv50_curs_new(struct nouveau_drm *drm, int head, struct nv50_wndw **pwndw)
 +inline static uint32_t soc15_get_register_offset(
 +		uint32_t hw_id,
 +		uint32_t inst,
 +		uint32_t segment,
 +		uint32_t offset)
  {
++<<<<<<< HEAD:drivers/gpu/drm/amd/powerplay/inc/pp_soc15.h
 +	uint32_t reg = 0;
++=======
+ 	struct {
+ 		s32 oclass;
+ 		int version;
+ 		int (*new)(struct nouveau_drm *, int, s32, struct nv50_wndw **);
+ 	} curses[] = {
+ 		{ GK104_DISP_CURSOR, 0, curs907a_new },
+ 		{ GF110_DISP_CURSOR, 0, curs907a_new },
+ 		{ GT214_DISP_CURSOR, 0, curs507a_new },
+ 		{   G82_DISP_CURSOR, 0, curs507a_new },
+ 		{  NV50_DISP_CURSOR, 0, curs507a_new },
+ 		{}
+ 	};
+ 	struct nv50_disp *disp = nv50_disp(drm->dev);
+ 	int cid;
++>>>>>>> 53e0a3e70de6 (drm/nouveau/kms/nv50-: simplify tracking of channel interlocks):drivers/gpu/drm/nouveau/dispnv50/curs.c
  
 -	cid = nvif_mclass(&disp->disp->object, curses);
 -	if (cid < 0) {
 -		NV_ERROR(drm, "No supported cursor immediate class\n");
 -		return cid;
 -	}
 +	if (hw_id == THM_HWID)
 +		reg = THM_BASE.instance[inst].segment[segment] + offset;
 +	else if (hw_id == NBIF_HWID)
 +		reg = NBIF_BASE.instance[inst].segment[segment] + offset;
 +	else if (hw_id == MP1_HWID)
 +		reg = MP1_BASE.instance[inst].segment[segment] + offset;
 +	else if (hw_id == DF_HWID)
 +		reg = DF_BASE.instance[inst].segment[segment] + offset;
 +	else if (hw_id == GC_HWID)
 +		reg = GC_BASE.instance[inst].segment[segment] + offset;
  
 -	return curses[cid].new(drm, head, curses[cid].oclass, pwndw);
 +	return reg;
  }
 +
 +#endif
diff --cc drivers/gpu/drm/amd/powerplay/smumgr/polaris10_smc.h
index 1df8154d0626,be0f16fdcd5b..000000000000
--- a/drivers/gpu/drm/amd/powerplay/smumgr/polaris10_smc.h
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/polaris10_smc.h
@@@ -18,27 -18,40 +18,48 @@@
   * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   * OTHER DEALINGS IN THE SOFTWARE.
 + *
   */
 -#include "ovly.h"
 -#include "oimm.h"
 +#ifndef POLARIS10_SMC_H
 +#define POLARIS10_SMC_H
  
 -#include <nvif/class.h>
 +#include "smumgr.h"
  
++<<<<<<< HEAD:drivers/gpu/drm/amd/powerplay/smumgr/polaris10_smc.h
++=======
+ int
+ nv50_ovly_new(struct nouveau_drm *drm, int head, struct nv50_wndw **pwndw)
+ {
+ 	static const struct {
+ 		s32 oclass;
+ 		int version;
+ 		int (*new)(struct nouveau_drm *, int, s32, struct nv50_wndw **);
+ 	} ovlys[] = {
+ 		{ GK104_DISP_OVERLAY_CONTROL_DMA, 0, ovly907e_new },
+ 		{ GF110_DISP_OVERLAY_CONTROL_DMA, 0, ovly907e_new },
+ 		{ GT214_DISP_OVERLAY_CHANNEL_DMA, 0, ovly827e_new },
+ 		{ GT200_DISP_OVERLAY_CHANNEL_DMA, 0, ovly827e_new },
+ 		{   G82_DISP_OVERLAY_CHANNEL_DMA, 0, ovly827e_new },
+ 		{  NV50_DISP_OVERLAY_CHANNEL_DMA, 0, ovly507e_new },
+ 		{}
+ 	};
+ 	struct nv50_disp *disp = nv50_disp(drm->dev);
+ 	int cid, ret;
++>>>>>>> 53e0a3e70de6 (drm/nouveau/kms/nv50-: simplify tracking of channel interlocks):drivers/gpu/drm/nouveau/dispnv50/ovly.c
  
 -	cid = nvif_mclass(&disp->disp->object, ovlys);
 -	if (cid < 0) {
 -		NV_ERROR(drm, "No supported overlay class\n");
 -		return cid;
 -	}
 +int polaris10_populate_all_graphic_levels(struct pp_hwmgr *hwmgr);
 +int polaris10_populate_all_memory_levels(struct pp_hwmgr *hwmgr);
 +int polaris10_init_smc_table(struct pp_hwmgr *hwmgr);
 +int polaris10_thermal_setup_fan_table(struct pp_hwmgr *hwmgr);
 +int polaris10_thermal_avfs_enable(struct pp_hwmgr *hwmgr);
 +int polaris10_update_smc_table(struct pp_hwmgr *hwmgr, uint32_t type);
 +int polaris10_update_sclk_threshold(struct pp_hwmgr *hwmgr);
 +uint32_t polaris10_get_offsetof(uint32_t type, uint32_t member);
 +uint32_t polaris10_get_mac_definition(uint32_t value);
 +int polaris10_process_firmware_header(struct pp_hwmgr *hwmgr);
 +bool polaris10_is_dpm_running(struct pp_hwmgr *hwmgr);
 +int polaris10_populate_requested_graphic_levels(struct pp_hwmgr *hwmgr,
 +		struct amd_pp_profile *request);
  
 -	ret = ovlys[cid].new(drm, head, ovlys[cid].oclass, pwndw);
 -	if (ret)
 -		return ret;
 +#endif
  
 -	return nv50_oimm_init(drm, *pwndw);
 -}
diff --cc drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.h
index 262c8ded87c0,732eea39e4de..000000000000
--- a/drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.h
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.h
@@@ -18,45 -18,56 +18,76 @@@
   * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   * OTHER DEALINGS IN THE SOFTWARE.
 + *
   */
 -#include "ovly.h"
  
 -#include <nvif/cl507e.h>
 +#ifndef PP_RAVEN_SMUMANAGER_H
 +#define PP_RAVEN_SMUMANAGER_H
 +
 +#include "rv_ppsmc.h"
 +#include "smu10_driver_if.h"
  
 -#include "nouveau_bo.h"
 +enum SMU_TABLE_ID {
 +	WMTABLE = 0,
 +	CLOCKTABLE,
 +	MAX_SMU_TABLE,
 +};
  
 -static const struct nv50_wndw_func
 -ovly507e = {
 +struct smu_table_entry {
 +	uint32_t version;
 +	uint32_t size;
 +	uint32_t table_id;
 +	uint32_t table_addr_high;
 +	uint32_t table_addr_low;
 +	uint8_t *table;
 +	uint32_t handle;
  };
  
 -static const u32
 -ovly507e_format[] = {
 -	0
++<<<<<<< HEAD:drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.h
 +struct smu_table_array {
 +	struct smu_table_entry entry[MAX_SMU_TABLE];
  };
  
 +struct rv_smumgr {
 +	struct smu_table_array            smu_tables;
 +};
++=======
+ int
+ ovly507e_new_(const struct nv50_wndw_func *func, const u32 *format,
+ 	      struct nouveau_drm *drm, int head, s32 oclass, u32 interlock_data,
+ 	      struct nv50_wndw **pwndw)
+ {
+ 	struct nv50_disp_overlay_channel_dma_v0 args = {
+ 		.head = head,
+ 	};
+ 	struct nv50_disp *disp = nv50_disp(drm->dev);
+ 	struct nv50_wndw *wndw;
+ 	int ret;
+ 
+ 	ret = nv50_wndw_new_(func, drm->dev, DRM_PLANE_TYPE_OVERLAY,
+ 			     "ovly", head, format, BIT(head),
+ 			     NV50_DISP_INTERLOCK_OVLY, interlock_data,
+ 			     &wndw);
+ 	if (*pwndw = wndw, ret)
+ 		return ret;
++>>>>>>> 53e0a3e70de6 (drm/nouveau/kms/nv50-: simplify tracking of channel interlocks):drivers/gpu/drm/nouveau/dispnv50/ovly507e.c
  
 -	ret = nv50_dmac_create(&drm->client.device, &disp->disp->object,
 -			       &oclass, 0, &args, sizeof(args),
 -			       disp->sync->bo.offset, &wndw->wndw);
 -	if (ret) {
 -		NV_ERROR(drm, "ovly%04x allocation failed: %d\n", oclass, ret);
 -		return ret;
 -	}
 +int rv_read_arg_from_smc(struct pp_smumgr *smumgr, uint32_t *arg);
 +bool rv_is_smc_ram_running(struct pp_smumgr *smumgr);
 +int rv_copy_table_from_smc(struct pp_smumgr *smumgr,
 +		uint8_t *table, int16_t table_id);
 +int rv_copy_table_to_smc(struct pp_smumgr *smumgr,
 +		uint8_t *table, int16_t table_id);
  
 -	return 0;
 -}
  
++<<<<<<< HEAD:drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.h
 +#endif
++=======
+ int
+ ovly507e_new(struct nouveau_drm *drm, int head, s32 oclass,
+ 	     struct nv50_wndw **pwndw)
+ {
+ 	return ovly507e_new_(&ovly507e, ovly507e_format, drm, head, oclass,
+ 			     0x00000004 << (head * 8), pwndw);
+ }
++>>>>>>> 53e0a3e70de6 (drm/nouveau/kms/nv50-: simplify tracking of channel interlocks):drivers/gpu/drm/nouveau/dispnv50/ovly507e.c
diff --cc drivers/gpu/drm/nouveau/dispnv50/Kbuild
index 43fc8be49391,3e53484b4589..000000000000
--- a/drivers/gpu/drm/nouveau/dispnv50/Kbuild
+++ b/drivers/gpu/drm/nouveau/dispnv50/Kbuild
@@@ -1,1 -1,40 +1,43 @@@
  nouveau-y += dispnv50/disp.o
++<<<<<<< HEAD
++=======
+ 
+ nouveau-y += dispnv50/core.o
+ nouveau-y += dispnv50/core507d.o
+ nouveau-y += dispnv50/core827d.o
+ nouveau-y += dispnv50/core907d.o
+ nouveau-y += dispnv50/core917d.o
+ 
+ nouveau-y += dispnv50/dac507d.o
+ nouveau-y += dispnv50/dac907d.o
+ 
+ nouveau-y += dispnv50/pior507d.o
+ 
+ nouveau-y += dispnv50/sor507d.o
+ nouveau-y += dispnv50/sor907d.o
+ 
+ nouveau-y += dispnv50/head.o
+ nouveau-y += dispnv50/head507d.o
+ nouveau-y += dispnv50/head827d.o
+ nouveau-y += dispnv50/head907d.o
+ nouveau-y += dispnv50/head917d.o
+ 
+ nouveau-y += dispnv50/wndw.o
+ 
+ nouveau-y += dispnv50/base.o
+ nouveau-y += dispnv50/base507c.o
+ nouveau-y += dispnv50/base827c.o
+ nouveau-y += dispnv50/base907c.o
+ 
+ nouveau-y += dispnv50/curs.o
+ nouveau-y += dispnv50/curs507a.o
+ nouveau-y += dispnv50/curs907a.o
+ 
+ nouveau-y += dispnv50/oimm.o
+ nouveau-y += dispnv50/oimm507b.o
+ 
+ nouveau-y += dispnv50/ovly.o
+ nouveau-y += dispnv50/ovly507e.o
+ nouveau-y += dispnv50/ovly827e.o
+ nouveau-y += dispnv50/ovly907e.o
++>>>>>>> 53e0a3e70de6 (drm/nouveau/kms/nv50-: simplify tracking of channel interlocks)
diff --cc drivers/gpu/drm/nouveau/dispnv50/disp.c
index a2ea42f947c7,e80d11c9a456..000000000000
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.c
@@@ -3851,15 -1582,14 +3851,15 @@@ nv50_pior_create(struct drm_connector *
   *****************************************************************************/
  
  static void
- nv50_disp_atomic_commit_core(struct nouveau_drm *drm, u32 interlock)
+ nv50_disp_atomic_commit_core(struct nouveau_drm *drm, u32 *interlock)
  {
  	struct nv50_disp *disp = nv50_disp(drm->dev);
 -	struct nv50_core *core = disp->core;
 +	struct nv50_dmac *core = &disp->mast.base;
  	struct nv50_mstm *mstm;
  	struct drm_encoder *encoder;
 +	u32 *push;
  
- 	NV_ATOMIC(drm, "commit core %08x\n", interlock);
+ 	NV_ATOMIC(drm, "commit core %08x\n", interlock[NV50_DISP_INTERLOCK_BASE]);
  
  	drm_for_each_encoder(encoder, drm->dev) {
  		if (encoder->encoder_type != DRM_MODE_ENCODER_DPMST) {
@@@ -4036,17 -1751,12 +4031,26 @@@ nv50_disp_atomic_commit_tail(struct drm
  	}
  
  	/* Flush update. */
++<<<<<<< HEAD
 +	if (interlock_core) {
 +		if (!interlock_chan && atom->state.legacy_cursor_update) {
 +			u32 *push = evo_wait(&disp->mast, 2);
 +			if (push) {
 +				evo_mthd(push, 0x0080, 1);
 +				evo_data(push, 0x00000000);
 +				evo_kick(push, &disp->mast);
 +			}
 +		} else {
 +			nv50_disp_atomic_commit_core(drm, interlock_chan);
 +		}
++=======
+ 	if (interlock[NV50_DISP_INTERLOCK_CORE]) {
+ 		if (interlock[NV50_DISP_INTERLOCK_BASE] ||
+ 		    !atom->state.legacy_cursor_update)
+ 			nv50_disp_atomic_commit_core(drm, interlock);
+ 		else
+ 			disp->core->func->update(disp->core, interlock, false);
++>>>>>>> 53e0a3e70de6 (drm/nouveau/kms/nv50-: simplify tracking of channel interlocks)
  	}
  
  	if (atom->lock_core)
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/base.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/base507c.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/base827c.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/base907c.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/core.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/core507d.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/curs.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/curs507a.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/disp.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/ovly.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/wndw.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/wndw.h
* Unmerged path drivers/gpu/drm/amd/powerplay/inc/pp_soc15.h
* Unmerged path drivers/gpu/drm/amd/powerplay/smumgr/polaris10_smc.h
* Unmerged path drivers/gpu/drm/amd/powerplay/smumgr/rv_smumgr.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/Kbuild
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/base.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/base507c.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/base827c.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/base907c.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/core.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/core507d.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/curs.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/curs507a.c
diff --git a/drivers/gpu/drm/nouveau/dispnv50/curs907a.c b/drivers/gpu/drm/nouveau/dispnv50/curs907a.c
new file mode 100644
index 000000000000..d742362de03e
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv50/curs907a.c
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2018 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "curs.h"
+
+int
+curs907a_new(struct nouveau_drm *drm, int head, s32 oclass,
+	     struct nv50_wndw **pwndw)
+{
+	return curs507a_new_(&curs507a, drm, head, oclass,
+			     0x00000001 << (head * 4), pwndw);
+}
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/disp.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/disp.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/ovly.h
diff --git a/drivers/gpu/drm/nouveau/dispnv50/ovly827e.c b/drivers/gpu/drm/nouveau/dispnv50/ovly827e.c
new file mode 100644
index 000000000000..a8115f13406e
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv50/ovly827e.c
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2018 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "ovly.h"
+
+#include <nouveau_bo.h>
+
+#include <nvif/cl507e.h>
+
+static const struct nv50_wndw_func
+ovly827e = {
+};
+
+const u32
+ovly827e_format[] = {
+	0
+};
+
+int
+ovly827e_new(struct nouveau_drm *drm, int head, s32 oclass,
+	     struct nv50_wndw **pwndw)
+{
+	return ovly507e_new_(&ovly827e, ovly827e_format, drm, head, oclass,
+			     0x00000004 << (head * 8), pwndw);
+}
diff --git a/drivers/gpu/drm/nouveau/dispnv50/ovly907e.c b/drivers/gpu/drm/nouveau/dispnv50/ovly907e.c
new file mode 100644
index 000000000000..f50da6461d41
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv50/ovly907e.c
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2018 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "ovly.h"
+
+static const struct nv50_wndw_func
+ovly907e = {
+};
+
+int
+ovly907e_new(struct nouveau_drm *drm, int head, s32 oclass,
+	     struct nv50_wndw **pwndw)
+{
+	return ovly507e_new_(&ovly907e, ovly827e_format, drm, head, oclass,
+			     0x00000004 << (head * 4), pwndw);
+}
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/wndw.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/wndw.h
