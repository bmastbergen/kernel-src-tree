perf trace: Allow specifying number of syscall args for tracepointless syscalls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 332337dafc98d88561bf3730f80c59cc93f089e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/332337da.failed

When we don't have syscalls:sys_{enter,exit}_NAME, we had to resort to
dumping all the 6 syscall arguments, fix it by providing that info for
such syscalls, like 'clone'.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/n/tip-dfq1jtrxj8dqvqoeqqpr3slu@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 332337dafc98d88561bf3730f80c59cc93f089e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-trace.c
diff --cc tools/perf/builtin-trace.c
index 5114abbd2e32,e1988d08911d..000000000000
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@@ -602,9 -604,14 +602,14 @@@ static size_t syscall_arg__scnprintf_ge
  static struct syscall_fmt {
  	const char *name;
  	const char *alias;
++<<<<<<< HEAD
 +	size_t	   (*arg_scnprintf[6])(char *bf, size_t size, struct syscall_arg *arg);
 +	void	   *arg_parm[6];
 +	bool	   errmsg;
++=======
+ 	struct syscall_arg_fmt arg[6];
+ 	u8	   nr_args;
++>>>>>>> 332337dafc98 (perf trace: Allow specifying number of syscall args for tracepointless syscalls)
  	bool	   errpid;
  	bool	   timeout;
  	bool	   hexret;
@@@ -1205,6 -1166,26 +1210,29 @@@ static int trace__symbols_init(struct t
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int syscall__alloc_arg_fmts(struct syscall *sc, int nr_args)
+ {
+ 	int idx;
+ 
+ 	if (nr_args == 6 && sc->fmt && sc->fmt->nr_args != 0)
+ 		nr_args = sc->fmt->nr_args;
+ 
+ 	sc->arg_fmt = calloc(nr_args, sizeof(*sc->arg_fmt));
+ 	if (sc->arg_fmt == NULL)
+ 		return -1;
+ 
+ 	for (idx = 0; idx < nr_args; ++idx) {
+ 		if (sc->fmt)
+ 			sc->arg_fmt[idx] = sc->fmt->arg[idx];
+ 	}
+ 
+ 	sc->nr_args = nr_args;
+ 	return 0;
+ }
+ 
++>>>>>>> 332337dafc98 (perf trace: Allow specifying number of syscall args for tracepointless syscalls)
  static int syscall__set_arg_fmts(struct syscall *sc)
  {
  	struct format_field *field;
@@@ -1442,14 -1417,16 +1470,21 @@@ static size_t syscall__scnprintf_args(s
  		 * may end up not having any args, like with gettid(), so only
  		 * print the raw args when we didn't manage to read it.
  		 */
++<<<<<<< HEAD
 +		int i = 0;
 +
 +		while (i < 6) {
 +			val = __syscall_arg__val(args, i);
++=======
+ 		while (arg.idx < sc->nr_args) {
+ 			if (arg.mask & bit)
+ 				goto next_arg;
+ 			val = syscall_arg__val(&arg, arg.idx);
++>>>>>>> 332337dafc98 (perf trace: Allow specifying number of syscall args for tracepointless syscalls)
  			printed += scnprintf(bf + printed, size - printed,
 -					     "%sarg%d: ", printed ? ", " : "", arg.idx);
 -			printed += syscall__scnprintf_val(sc, bf + printed, size - printed, &arg, val);
 -next_arg:
 -			++arg.idx;
 -			bit <<= 1;
 +					     "%sarg%d: %ld",
 +					     printed ? ", " : "", i, val);
 +			++i;
  		}
  	}
  
* Unmerged path tools/perf/builtin-trace.c
