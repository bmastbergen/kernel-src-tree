multicast: do not restore deleted record source filter mode to new one

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Hangbin Liu <liuhangbin@gmail.com>
commit 08d3ffcc0cfaba36f6b86fd568cc3bc773061fa6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/08d3ffcc.failed

There are two scenarios that we will restore deleted records. The first is
when device down and up(or unmap/remap). In this scenario the new filter
mode is same with previous one. Because we get it from in_dev->mc_list and
we do not touch it during device down and up.

The other scenario is when a new socket join a group which was just delete
and not finish sending status reports. In this scenario, we should use the
current filter mode instead of restore old one. Here are 4 cases in total.

old_socket        new_socket       before_fix       after_fix
  IN(A)             IN(A)           ALLOW(A)         ALLOW(A)
  IN(A)             EX( )           TO_IN( )         TO_EX( )
  EX( )             IN(A)           TO_EX( )         ALLOW(A)
  EX( )             EX( )           TO_EX( )         TO_EX( )

Fixes: 24803f38a5c0b (igmp: do not remove igmp souce list info when set link down)
Fixes: 1666d49e1d416 (mld: do not remove mld souce list info when set link down)
	Signed-off-by: Hangbin Liu <liuhangbin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 08d3ffcc0cfaba36f6b86fd568cc3bc773061fa6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/igmp.c
diff --cc net/ipv4/igmp.c
index e1c8403127c2,28fef7d15959..000000000000
--- a/net/ipv4/igmp.c
+++ b/net/ipv4/igmp.c
@@@ -1121,9 -1200,7 +1121,13 @@@ static void igmpv3_del_delrec(struct in
  	spin_lock_bh(&im->lock);
  	if (pmc) {
  		im->interface = pmc->interface;
++<<<<<<< HEAD
 +		im->crcount = in_dev->mr_qrv ?: sysctl_igmp_qrv;
 +		im->sfmode = pmc->sfmode;
 +		if (pmc->sfmode == MCAST_INCLUDE) {
++=======
+ 		if (im->sfmode == MCAST_INCLUDE) {
++>>>>>>> 08d3ffcc0cfa (multicast: do not restore deleted record source filter mode to new one)
  			im->tomb = pmc->tomb;
  			im->sources = pmc->sources;
  			for (psf = im->sources; psf; psf = psf->sf_next)
* Unmerged path net/ipv4/igmp.c
diff --git a/net/ipv6/mcast.c b/net/ipv6/mcast.c
index f87e5b9d260c..10078d277561 100644
--- a/net/ipv6/mcast.c
+++ b/net/ipv6/mcast.c
@@ -801,8 +801,7 @@ static void mld_del_delrec(struct inet6_dev *idev, struct ifmcaddr6 *im)
 	spin_lock_bh(&im->mca_lock);
 	if (pmc) {
 		im->idev = pmc->idev;
-		im->mca_sfmode = pmc->mca_sfmode;
-		if (pmc->mca_sfmode == MCAST_INCLUDE) {
+		if (im->mca_sfmode == MCAST_INCLUDE) {
 			im->mca_tomb = pmc->mca_tomb;
 			im->mca_sources = pmc->mca_sources;
 			for (psf = im->mca_sources; psf; psf = psf->sf_next)
