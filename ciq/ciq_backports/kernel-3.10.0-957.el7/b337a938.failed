timer: Allocate per-cpu tvec_base's statically

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit b337a9380f7effd60d082569dd7e0b97a7549730
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b337a938.failed

Memory for the 'tvec_base' array is allocated separately for the boot CPU (statically)
and non-boot CPUs (dynamically).

The reason is because __TIMER_INITIALIZER() needs to set ->base to a
valid pointer (because we've made NULL special, hint: lock_timer_base())
and we cannot get a compile time pointer to per-cpu entries because we
don't know where we'll map the section, even for the boot cpu.

This can be simplified a bit by statically allocating per-cpu memory.
The only disadvantage is that memory for one of the structures will stay
unused, i.e. for the boot CPU, which uses boot_tvec_bases.

This will also guarantee that tvec_base is cacheline aligned. Even
though tvec_base has ____cacheline_aligned stuck on, kzalloc_node() does
not actually respect that (but guarantees a minimum u64 alignment).

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/17cdf560f2727f687ab159707d0aa591f8a2f82d.1427814611.git.viresh.kumar@linaro.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit b337a9380f7effd60d082569dd7e0b97a7549730)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/timer.c
diff --cc kernel/timer.c
index 2656ecf67862,f3cc653f876c..000000000000
--- a/kernel/timer.c
+++ b/kernel/timer.c
@@@ -86,11 -88,21 +86,22 @@@ struct tvec_base 
  	struct tvec tv3;
  	struct tvec tv4;
  	struct tvec tv5;
 +	RH_KABI_EXTEND(unsigned long all_timers)
  } ____cacheline_aligned;
  
+ /*
+  * __TIMER_INITIALIZER() needs to set ->base to a valid pointer (because we've
+  * made NULL special, hint: lock_timer_base()) and we cannot get a compile time
+  * pointer to per-cpu entries because we don't know where we'll map the section,
+  * even for the boot cpu.
+  *
+  * And so we use boot_tvec_bases for boot CPU and per-cpu __tvec_bases for the
+  * rest of them.
+  */
  struct tvec_base boot_tvec_bases;
  EXPORT_SYMBOL(boot_tvec_bases);
+ static DEFINE_PER_CPU(struct tvec_base, __tvec_bases);
+ 
  static DEFINE_PER_CPU(struct tvec_base *, tvec_bases) = &boot_tvec_bases;
  
  /* Functions below help us manage 'deferrable' flag */
@@@ -1525,47 -1545,25 +1536,50 @@@ EXPORT_SYMBOL(schedule_timeout_uninterr
  
  static int init_timers_cpu(int cpu)
  {
- 	int j;
- 	struct tvec_base *base;
+ 	struct tvec_base *base = per_cpu(tvec_bases, cpu);
  	static char tvec_base_done[NR_CPUS];
+ 	int j;
  
  	if (!tvec_base_done[cpu]) {
- 		static char boot_done;
+ 		static char boot_cpu_skipped;
  
++<<<<<<< HEAD:kernel/timer.c
 +		if (boot_done) {
 +			/*
 +			 * The APs use this path later in boot
 +			 */
 +			base = kmalloc_node(sizeof(*base),
 +						GFP_KERNEL | __GFP_ZERO,
 +						cpu_to_node(cpu));
 +			if (!base)
 +				return -ENOMEM;
 +
 +			/* Make sure that tvec_base is 2 byte aligned */
 +			if (tbase_get_deferrable(base)) {
 +				WARN_ON(1);
 +				kfree(base);
 +				return -ENOMEM;
 +			}
 +			per_cpu(tvec_bases, cpu) = base;
++=======
+ 		if (!boot_cpu_skipped) {
+ 			boot_cpu_skipped = 1; /* skip the boot cpu */
++>>>>>>> b337a9380f7e (timer: Allocate per-cpu tvec_base's statically):kernel/time/timer.c
  		} else {
- 			/*
- 			 * This is for the boot CPU - we use compile-time
- 			 * static initialisation because per-cpu memory isn't
- 			 * ready yet and because the memory allocators are not
- 			 * initialised either.
- 			 */
- 			boot_done = 1;
- 			base = &boot_tvec_bases;
+ 			base = per_cpu_ptr(&__tvec_bases, cpu);
+ 			per_cpu(tvec_bases, cpu) = base;
  		}
+ 
  		spin_lock_init(&base->lock);
  		tvec_base_done[cpu] = 1;
++<<<<<<< HEAD:kernel/timer.c
 +	} else {
 +		base = per_cpu(tvec_bases, cpu);
++=======
+ 		base->cpu = cpu;
++>>>>>>> b337a9380f7e (timer: Allocate per-cpu tvec_base's statically):kernel/time/timer.c
  	}
  
- 
  	for (j = 0; j < TVN_SIZE; j++) {
  		INIT_LIST_HEAD(base->tv5.vec + j);
  		INIT_LIST_HEAD(base->tv4.vec + j);
* Unmerged path kernel/timer.c
