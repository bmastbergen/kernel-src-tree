bpf: x64: add JIT support for multi-function programs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Alexei Starovoitov <ast@fb.com>
commit 1c2a088a6626d4f51d2f2c97b0cbedbfbf3637f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1c2a088a.failed

Typical JIT does several passes over bpf instructions to
compute total size and relative offsets of jumps and calls.
With multitple bpf functions calling each other all relative calls
will have invalid offsets intially therefore we need to additional
last pass over the program to emit calls with correct offsets.
For example in case of three bpf functions:
main:
  call foo
  call bpf_map_lookup
  exit
foo:
  call bar
  exit
bar:
  exit

We will call bpf_int_jit_compile() indepedently for main(), foo() and bar()
x64 JIT typically does 4-5 passes to converge.
After these initial passes the image for these 3 functions
will be good except call targets, since start addresses of
foo() and bar() are unknown when we were JITing main()
(note that call bpf_map_lookup will be resolved properly
during initial passes).
Once start addresses of 3 functions are known we patch
call_insn->imm to point to right functions and call
bpf_int_jit_compile() again which needs only one pass.
Additional safety checks are done to make sure this
last pass doesn't produce image that is larger or smaller
than previous pass.

When constant blinding is on it's applied to all functions
at the first pass, since doing it once again at the last
pass can change size of the JITed code.

Tested on x64 and arm64 hw with JIT on/off, blinding on/off.
x64 jits bpf-to-bpf calls correctly while arm64 falls back to interpreter.
All other JITs that support normal BPF_CALL will behave the same way
since bpf-to-bpf call is equivalent to bpf-to-kernel call from
JITs point of view.

	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Daniel Borkmann <daniel@iogearbox.net>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 1c2a088a6626d4f51d2f2c97b0cbedbfbf3637f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/net/bpf_jit_comp.c
#	include/linux/bpf.h
#	include/linux/bpf_verifier.h
#	include/linux/filter.h
#	kernel/bpf/core.c
#	kernel/bpf/syscall.c
#	kernel/bpf/verifier.c
diff --cc arch/x86/net/bpf_jit_comp.c
index 76c7b3a140ad,87f214fbe66e..000000000000
--- a/arch/x86/net/bpf_jit_comp.c
+++ b/arch/x86/net/bpf_jit_comp.c
@@@ -124,48 -112,1062 +124,105 @@@ static inline void bpf_flush_icache(voi
  #define CHOOSE_LOAD_FUNC(K, func) \
  	((int)K < 0 ? ((int)K >= SKF_LL_OFF ? func##_negative_offset : func) : func##_positive_offset)
  
 -/* pick a register outside of BPF range for JIT internal work */
 -#define AUX_REG (MAX_BPF_JIT_REG + 1)
 -
 -/* The following table maps BPF registers to x64 registers.
 - *
 - * x64 register r12 is unused, since if used as base address
 - * register in load/store instructions, it always needs an
 - * extra byte of encoding and is callee saved.
 - *
 - *  r9 caches skb->len - skb->data_len
 - * r10 caches skb->data, and used for blinding (if enabled)
 - */
 -static const int reg2hex[] = {
 -	[BPF_REG_0] = 0,  /* rax */
 -	[BPF_REG_1] = 7,  /* rdi */
 -	[BPF_REG_2] = 6,  /* rsi */
 -	[BPF_REG_3] = 2,  /* rdx */
 -	[BPF_REG_4] = 1,  /* rcx */
 -	[BPF_REG_5] = 0,  /* r8 */
 -	[BPF_REG_6] = 3,  /* rbx callee saved */
 -	[BPF_REG_7] = 5,  /* r13 callee saved */
 -	[BPF_REG_8] = 6,  /* r14 callee saved */
 -	[BPF_REG_9] = 7,  /* r15 callee saved */
 -	[BPF_REG_FP] = 5, /* rbp readonly */
 -	[BPF_REG_AX] = 2, /* r10 temp register */
 -	[AUX_REG] = 3,    /* r11 temp register */
 -};
 -
 -/* is_ereg() == true if BPF register 'reg' maps to x64 r8..r15
 - * which need extra byte of encoding.
 - * rax,rcx,...,rbp have simpler encoding
 - */
 -static bool is_ereg(u32 reg)
 -{
 -	return (1 << reg) & (BIT(BPF_REG_5) |
 -			     BIT(AUX_REG) |
 -			     BIT(BPF_REG_7) |
 -			     BIT(BPF_REG_8) |
 -			     BIT(BPF_REG_9) |
 -			     BIT(BPF_REG_AX));
 -}
 -
 -/* add modifiers if 'reg' maps to x64 registers r8..r15 */
 -static u8 add_1mod(u8 byte, u32 reg)
 -{
 -	if (is_ereg(reg))
 -		byte |= 1;
 -	return byte;
 -}
 -
 -static u8 add_2mod(u8 byte, u32 r1, u32 r2)
 -{
 -	if (is_ereg(r1))
 -		byte |= 1;
 -	if (is_ereg(r2))
 -		byte |= 4;
 -	return byte;
 -}
 -
 -/* encode 'dst_reg' register into x64 opcode 'byte' */
 -static u8 add_1reg(u8 byte, u32 dst_reg)
 -{
 -	return byte + reg2hex[dst_reg];
 -}
 -
 -/* encode 'dst_reg' and 'src_reg' registers into x64 opcode 'byte' */
 -static u8 add_2reg(u8 byte, u32 dst_reg, u32 src_reg)
 -{
 -	return byte + reg2hex[dst_reg] + (reg2hex[src_reg] << 3);
 -}
 -
 -static void jit_fill_hole(void *area, unsigned int size)
 -{
 -	/* fill whole space with int3 instructions */
 -	memset(area, 0xcc, size);
 -}
 -
 -struct jit_context {
 -	int cleanup_addr; /* epilogue code offset */
 -	bool seen_ld_abs;
 -	bool seen_ax_reg;
 -};
 -
 -/* maximum number of bytes emitted while JITing one eBPF insn */
 -#define BPF_MAX_INSN_SIZE	128
 -#define BPF_INSN_SAFETY		64
 -
 -#define AUX_STACK_SPACE \
 -	(32 /* space for rbx, r13, r14, r15 */ + \
 -	 8 /* space for skb_copy_bits() buffer */)
 -
 -#define PROLOGUE_SIZE 37
 -
 -/* emit x64 prologue code for BPF program and check it's size.
 - * bpf_tail_call helper will skip it while jumping into another program
 - */
 -static void emit_prologue(u8 **pprog, u32 stack_depth)
 -{
 -	u8 *prog = *pprog;
 -	int cnt = 0;
 -
 -	EMIT1(0x55); /* push rbp */
 -	EMIT3(0x48, 0x89, 0xE5); /* mov rbp,rsp */
 -
 -	/* sub rsp, rounded_stack_depth + AUX_STACK_SPACE */
 -	EMIT3_off32(0x48, 0x81, 0xEC,
 -		    round_up(stack_depth, 8) + AUX_STACK_SPACE);
 -
 -	/* sub rbp, AUX_STACK_SPACE */
 -	EMIT4(0x48, 0x83, 0xED, AUX_STACK_SPACE);
 -
 -	/* all classic BPF filters use R6(rbx) save it */
 -
 -	/* mov qword ptr [rbp+0],rbx */
 -	EMIT4(0x48, 0x89, 0x5D, 0);
 -
 -	/* bpf_convert_filter() maps classic BPF register X to R7 and uses R8
 -	 * as temporary, so all tcpdump filters need to spill/fill R7(r13) and
 -	 * R8(r14). R9(r15) spill could be made conditional, but there is only
 -	 * one 'bpf_error' return path out of helper functions inside bpf_jit.S
 -	 * The overhead of extra spill is negligible for any filter other
 -	 * than synthetic ones. Therefore not worth adding complexity.
 -	 */
 -
 -	/* mov qword ptr [rbp+8],r13 */
 -	EMIT4(0x4C, 0x89, 0x6D, 8);
 -	/* mov qword ptr [rbp+16],r14 */
 -	EMIT4(0x4C, 0x89, 0x75, 16);
 -	/* mov qword ptr [rbp+24],r15 */
 -	EMIT4(0x4C, 0x89, 0x7D, 24);
 -
 -	/* Clear the tail call counter (tail_call_cnt): for eBPF tail calls
 -	 * we need to reset the counter to 0. It's done in two instructions,
 -	 * resetting rax register to 0 (xor on eax gets 0 extended), and
 -	 * moving it to the counter location.
 -	 */
 -
 -	/* xor eax, eax */
 -	EMIT2(0x31, 0xc0);
 -	/* mov qword ptr [rbp+32], rax */
 -	EMIT4(0x48, 0x89, 0x45, 32);
 -
 -	BUILD_BUG_ON(cnt != PROLOGUE_SIZE);
 -	*pprog = prog;
 -}
 -
 -/* generate the following code:
 - * ... bpf_tail_call(void *ctx, struct bpf_array *array, u64 index) ...
 - *   if (index >= array->map.max_entries)
 - *     goto out;
 - *   if (++tail_call_cnt > MAX_TAIL_CALL_CNT)
 - *     goto out;
 - *   prog = array->ptrs[index];
 - *   if (prog == NULL)
 - *     goto out;
 - *   goto *(prog->bpf_func + prologue_size);
 - * out:
 +/* Helper to find the offset of pkt_type in sk_buff
 + * We want to make sure its still a 3bit field starting at a byte boundary.
   */
 -static void emit_bpf_tail_call(u8 **pprog)
 +#define PKT_TYPE_MAX 7
 +static int pkt_type_offset(void)
  {
 -	u8 *prog = *pprog;
 -	int label1, label2, label3;
 -	int cnt = 0;
 -
 -	/* rdi - pointer to ctx
 -	 * rsi - pointer to bpf_array
 -	 * rdx - index in bpf_array
 -	 */
 -
 -	/* if (index >= array->map.max_entries)
 -	 *   goto out;
 -	 */
 -	EMIT2(0x89, 0xD2);                        /* mov edx, edx */
 -	EMIT3(0x39, 0x56,                         /* cmp dword ptr [rsi + 16], edx */
 -	      offsetof(struct bpf_array, map.max_entries));
 -#define OFFSET1 43 /* number of bytes to jump */
 -	EMIT2(X86_JBE, OFFSET1);                  /* jbe out */
 -	label1 = cnt;
 -
 -	/* if (tail_call_cnt > MAX_TAIL_CALL_CNT)
 -	 *   goto out;
 -	 */
 -	EMIT2_off32(0x8B, 0x85, 36);              /* mov eax, dword ptr [rbp + 36] */
 -	EMIT3(0x83, 0xF8, MAX_TAIL_CALL_CNT);     /* cmp eax, MAX_TAIL_CALL_CNT */
 -#define OFFSET2 32
 -	EMIT2(X86_JA, OFFSET2);                   /* ja out */
 -	label2 = cnt;
 -	EMIT3(0x83, 0xC0, 0x01);                  /* add eax, 1 */
 -	EMIT2_off32(0x89, 0x85, 36);              /* mov dword ptr [rbp + 36], eax */
 -
 -	/* prog = array->ptrs[index]; */
 -	EMIT4_off32(0x48, 0x8B, 0x84, 0xD6,       /* mov rax, [rsi + rdx * 8 + offsetof(...)] */
 -		    offsetof(struct bpf_array, ptrs));
 -
 -	/* if (prog == NULL)
 -	 *   goto out;
 -	 */
 -	EMIT3(0x48, 0x85, 0xC0);		  /* test rax,rax */
 -#define OFFSET3 10
 -	EMIT2(X86_JE, OFFSET3);                   /* je out */
 -	label3 = cnt;
 -
 -	/* goto *(prog->bpf_func + prologue_size); */
 -	EMIT4(0x48, 0x8B, 0x40,                   /* mov rax, qword ptr [rax + 32] */
 -	      offsetof(struct bpf_prog, bpf_func));
 -	EMIT4(0x48, 0x83, 0xC0, PROLOGUE_SIZE);   /* add rax, prologue_size */
 -
 -	/* now we're ready to jump into next BPF program
 -	 * rdi == ctx (1st arg)
 -	 * rax == prog->bpf_func + prologue_size
 -	 */
 -	EMIT2(0xFF, 0xE0);                        /* jmp rax */
 -
 -	/* out: */
 -	BUILD_BUG_ON(cnt - label1 != OFFSET1);
 -	BUILD_BUG_ON(cnt - label2 != OFFSET2);
 -	BUILD_BUG_ON(cnt - label3 != OFFSET3);
 -	*pprog = prog;
 -}
 -
 -
 -static void emit_load_skb_data_hlen(u8 **pprog)
 -{
 -	u8 *prog = *pprog;
 -	int cnt = 0;
 -
 -	/* r9d = skb->len - skb->data_len (headlen)
 -	 * r10 = skb->data
 -	 */
 -	/* mov %r9d, off32(%rdi) */
 -	EMIT3_off32(0x44, 0x8b, 0x8f, offsetof(struct sk_buff, len));
 -
 -	/* sub %r9d, off32(%rdi) */
 -	EMIT3_off32(0x44, 0x2b, 0x8f, offsetof(struct sk_buff, data_len));
 -
 -	/* mov %r10, off32(%rdi) */
 -	EMIT3_off32(0x4c, 0x8b, 0x97, offsetof(struct sk_buff, data));
 -	*pprog = prog;
 -}
 -
 -static int do_jit(struct bpf_prog *bpf_prog, int *addrs, u8 *image,
 -		  int oldproglen, struct jit_context *ctx)
 -{
 -	struct bpf_insn *insn = bpf_prog->insnsi;
 -	int insn_cnt = bpf_prog->len;
 -	bool seen_ld_abs = ctx->seen_ld_abs | (oldproglen == 0);
 -	bool seen_ax_reg = ctx->seen_ax_reg | (oldproglen == 0);
 -	bool seen_exit = false;
 -	u8 temp[BPF_MAX_INSN_SIZE + BPF_INSN_SAFETY];
 -	int i, cnt = 0;
 -	int proglen = 0;
 -	u8 *prog = temp;
 -
 -	emit_prologue(&prog, bpf_prog->aux->stack_depth);
 -
 -	if (seen_ld_abs)
 -		emit_load_skb_data_hlen(&prog);
 -
 -	for (i = 0; i < insn_cnt; i++, insn++) {
 -		const s32 imm32 = insn->imm;
 -		u32 dst_reg = insn->dst_reg;
 -		u32 src_reg = insn->src_reg;
 -		u8 b1 = 0, b2 = 0, b3 = 0;
 -		s64 jmp_offset;
 -		u8 jmp_cond;
 -		bool reload_skb_data;
 -		int ilen;
 -		u8 *func;
 -
 -		if (dst_reg == BPF_REG_AX || src_reg == BPF_REG_AX)
 -			ctx->seen_ax_reg = seen_ax_reg = true;
 -
 -		switch (insn->code) {
 -			/* ALU */
 -		case BPF_ALU | BPF_ADD | BPF_X:
 -		case BPF_ALU | BPF_SUB | BPF_X:
 -		case BPF_ALU | BPF_AND | BPF_X:
 -		case BPF_ALU | BPF_OR | BPF_X:
 -		case BPF_ALU | BPF_XOR | BPF_X:
 -		case BPF_ALU64 | BPF_ADD | BPF_X:
 -		case BPF_ALU64 | BPF_SUB | BPF_X:
 -		case BPF_ALU64 | BPF_AND | BPF_X:
 -		case BPF_ALU64 | BPF_OR | BPF_X:
 -		case BPF_ALU64 | BPF_XOR | BPF_X:
 -			switch (BPF_OP(insn->code)) {
 -			case BPF_ADD: b2 = 0x01; break;
 -			case BPF_SUB: b2 = 0x29; break;
 -			case BPF_AND: b2 = 0x21; break;
 -			case BPF_OR: b2 = 0x09; break;
 -			case BPF_XOR: b2 = 0x31; break;
 -			}
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_2mod(0x48, dst_reg, src_reg));
 -			else if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT1(add_2mod(0x40, dst_reg, src_reg));
 -			EMIT2(b2, add_2reg(0xC0, dst_reg, src_reg));
 -			break;
 -
 -			/* mov dst, src */
 -		case BPF_ALU64 | BPF_MOV | BPF_X:
 -			EMIT_mov(dst_reg, src_reg);
 -			break;
 -
 -			/* mov32 dst, src */
 -		case BPF_ALU | BPF_MOV | BPF_X:
 -			if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT1(add_2mod(0x40, dst_reg, src_reg));
 -			EMIT2(0x89, add_2reg(0xC0, dst_reg, src_reg));
 -			break;
 -
 -			/* neg dst */
 -		case BPF_ALU | BPF_NEG:
 -		case BPF_ALU64 | BPF_NEG:
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_1mod(0x48, dst_reg));
 -			else if (is_ereg(dst_reg))
 -				EMIT1(add_1mod(0x40, dst_reg));
 -			EMIT2(0xF7, add_1reg(0xD8, dst_reg));
 -			break;
 -
 -		case BPF_ALU | BPF_ADD | BPF_K:
 -		case BPF_ALU | BPF_SUB | BPF_K:
 -		case BPF_ALU | BPF_AND | BPF_K:
 -		case BPF_ALU | BPF_OR | BPF_K:
 -		case BPF_ALU | BPF_XOR | BPF_K:
 -		case BPF_ALU64 | BPF_ADD | BPF_K:
 -		case BPF_ALU64 | BPF_SUB | BPF_K:
 -		case BPF_ALU64 | BPF_AND | BPF_K:
 -		case BPF_ALU64 | BPF_OR | BPF_K:
 -		case BPF_ALU64 | BPF_XOR | BPF_K:
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_1mod(0x48, dst_reg));
 -			else if (is_ereg(dst_reg))
 -				EMIT1(add_1mod(0x40, dst_reg));
 -
 -			switch (BPF_OP(insn->code)) {
 -			case BPF_ADD: b3 = 0xC0; break;
 -			case BPF_SUB: b3 = 0xE8; break;
 -			case BPF_AND: b3 = 0xE0; break;
 -			case BPF_OR: b3 = 0xC8; break;
 -			case BPF_XOR: b3 = 0xF0; break;
 -			}
 -
 -			if (is_imm8(imm32))
 -				EMIT3(0x83, add_1reg(b3, dst_reg), imm32);
 -			else
 -				EMIT2_off32(0x81, add_1reg(b3, dst_reg), imm32);
 -			break;
 -
 -		case BPF_ALU64 | BPF_MOV | BPF_K:
 -			/* optimization: if imm32 is positive,
 -			 * use 'mov eax, imm32' (which zero-extends imm32)
 -			 * to save 2 bytes
 -			 */
 -			if (imm32 < 0) {
 -				/* 'mov rax, imm32' sign extends imm32 */
 -				b1 = add_1mod(0x48, dst_reg);
 -				b2 = 0xC7;
 -				b3 = 0xC0;
 -				EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
 -				break;
 -			}
 -
 -		case BPF_ALU | BPF_MOV | BPF_K:
 -			/* optimization: if imm32 is zero, use 'xor <dst>,<dst>'
 -			 * to save 3 bytes.
 -			 */
 -			if (imm32 == 0) {
 -				if (is_ereg(dst_reg))
 -					EMIT1(add_2mod(0x40, dst_reg, dst_reg));
 -				b2 = 0x31; /* xor */
 -				b3 = 0xC0;
 -				EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
 -				break;
 -			}
 -
 -			/* mov %eax, imm32 */
 -			if (is_ereg(dst_reg))
 -				EMIT1(add_1mod(0x40, dst_reg));
 -			EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
 -			break;
 -
 -		case BPF_LD | BPF_IMM | BPF_DW:
 -			/* optimization: if imm64 is zero, use 'xor <dst>,<dst>'
 -			 * to save 7 bytes.
 -			 */
 -			if (insn[0].imm == 0 && insn[1].imm == 0) {
 -				b1 = add_2mod(0x48, dst_reg, dst_reg);
 -				b2 = 0x31; /* xor */
 -				b3 = 0xC0;
 -				EMIT3(b1, b2, add_2reg(b3, dst_reg, dst_reg));
 -
 -				insn++;
 -				i++;
 -				break;
 -			}
 -
 -			/* movabsq %rax, imm64 */
 -			EMIT2(add_1mod(0x48, dst_reg), add_1reg(0xB8, dst_reg));
 -			EMIT(insn[0].imm, 4);
 -			EMIT(insn[1].imm, 4);
 -
 -			insn++;
 -			i++;
 -			break;
 -
 -			/* dst %= src, dst /= src, dst %= imm32, dst /= imm32 */
 -		case BPF_ALU | BPF_MOD | BPF_X:
 -		case BPF_ALU | BPF_DIV | BPF_X:
 -		case BPF_ALU | BPF_MOD | BPF_K:
 -		case BPF_ALU | BPF_DIV | BPF_K:
 -		case BPF_ALU64 | BPF_MOD | BPF_X:
 -		case BPF_ALU64 | BPF_DIV | BPF_X:
 -		case BPF_ALU64 | BPF_MOD | BPF_K:
 -		case BPF_ALU64 | BPF_DIV | BPF_K:
 -			EMIT1(0x50); /* push rax */
 -			EMIT1(0x52); /* push rdx */
 -
 -			if (BPF_SRC(insn->code) == BPF_X)
 -				/* mov r11, src_reg */
 -				EMIT_mov(AUX_REG, src_reg);
 -			else
 -				/* mov r11, imm32 */
 -				EMIT3_off32(0x49, 0xC7, 0xC3, imm32);
 -
 -			/* mov rax, dst_reg */
 -			EMIT_mov(BPF_REG_0, dst_reg);
 -
 -			/* xor edx, edx
 -			 * equivalent to 'xor rdx, rdx', but one byte less
 -			 */
 -			EMIT2(0x31, 0xd2);
 -
 -			if (BPF_SRC(insn->code) == BPF_X) {
 -				/* if (src_reg == 0) return 0 */
 -
 -				/* cmp r11, 0 */
 -				EMIT4(0x49, 0x83, 0xFB, 0x00);
 -
 -				/* jne .+9 (skip over pop, pop, xor and jmp) */
 -				EMIT2(X86_JNE, 1 + 1 + 2 + 5);
 -				EMIT1(0x5A); /* pop rdx */
 -				EMIT1(0x58); /* pop rax */
 -				EMIT2(0x31, 0xc0); /* xor eax, eax */
 -
 -				/* jmp cleanup_addr
 -				 * addrs[i] - 11, because there are 11 bytes
 -				 * after this insn: div, mov, pop, pop, mov
 -				 */
 -				jmp_offset = ctx->cleanup_addr - (addrs[i] - 11);
 -				EMIT1_off32(0xE9, jmp_offset);
 -			}
 -
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				/* div r11 */
 -				EMIT3(0x49, 0xF7, 0xF3);
 -			else
 -				/* div r11d */
 -				EMIT3(0x41, 0xF7, 0xF3);
 -
 -			if (BPF_OP(insn->code) == BPF_MOD)
 -				/* mov r11, rdx */
 -				EMIT3(0x49, 0x89, 0xD3);
 -			else
 -				/* mov r11, rax */
 -				EMIT3(0x49, 0x89, 0xC3);
 -
 -			EMIT1(0x5A); /* pop rdx */
 -			EMIT1(0x58); /* pop rax */
 -
 -			/* mov dst_reg, r11 */
 -			EMIT_mov(dst_reg, AUX_REG);
 -			break;
 -
 -		case BPF_ALU | BPF_MUL | BPF_K:
 -		case BPF_ALU | BPF_MUL | BPF_X:
 -		case BPF_ALU64 | BPF_MUL | BPF_K:
 -		case BPF_ALU64 | BPF_MUL | BPF_X:
 -			EMIT1(0x50); /* push rax */
 -			EMIT1(0x52); /* push rdx */
 -
 -			/* mov r11, dst_reg */
 -			EMIT_mov(AUX_REG, dst_reg);
 -
 -			if (BPF_SRC(insn->code) == BPF_X)
 -				/* mov rax, src_reg */
 -				EMIT_mov(BPF_REG_0, src_reg);
 -			else
 -				/* mov rax, imm32 */
 -				EMIT3_off32(0x48, 0xC7, 0xC0, imm32);
 -
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_1mod(0x48, AUX_REG));
 -			else if (is_ereg(AUX_REG))
 -				EMIT1(add_1mod(0x40, AUX_REG));
 -			/* mul(q) r11 */
 -			EMIT2(0xF7, add_1reg(0xE0, AUX_REG));
 -
 -			/* mov r11, rax */
 -			EMIT_mov(AUX_REG, BPF_REG_0);
 -
 -			EMIT1(0x5A); /* pop rdx */
 -			EMIT1(0x58); /* pop rax */
 -
 -			/* mov dst_reg, r11 */
 -			EMIT_mov(dst_reg, AUX_REG);
 -			break;
 -
 -			/* shifts */
 -		case BPF_ALU | BPF_LSH | BPF_K:
 -		case BPF_ALU | BPF_RSH | BPF_K:
 -		case BPF_ALU | BPF_ARSH | BPF_K:
 -		case BPF_ALU64 | BPF_LSH | BPF_K:
 -		case BPF_ALU64 | BPF_RSH | BPF_K:
 -		case BPF_ALU64 | BPF_ARSH | BPF_K:
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_1mod(0x48, dst_reg));
 -			else if (is_ereg(dst_reg))
 -				EMIT1(add_1mod(0x40, dst_reg));
 -
 -			switch (BPF_OP(insn->code)) {
 -			case BPF_LSH: b3 = 0xE0; break;
 -			case BPF_RSH: b3 = 0xE8; break;
 -			case BPF_ARSH: b3 = 0xF8; break;
 -			}
 -			EMIT3(0xC1, add_1reg(b3, dst_reg), imm32);
 -			break;
 -
 -		case BPF_ALU | BPF_LSH | BPF_X:
 -		case BPF_ALU | BPF_RSH | BPF_X:
 -		case BPF_ALU | BPF_ARSH | BPF_X:
 -		case BPF_ALU64 | BPF_LSH | BPF_X:
 -		case BPF_ALU64 | BPF_RSH | BPF_X:
 -		case BPF_ALU64 | BPF_ARSH | BPF_X:
 -
 -			/* check for bad case when dst_reg == rcx */
 -			if (dst_reg == BPF_REG_4) {
 -				/* mov r11, dst_reg */
 -				EMIT_mov(AUX_REG, dst_reg);
 -				dst_reg = AUX_REG;
 -			}
 -
 -			if (src_reg != BPF_REG_4) { /* common case */
 -				EMIT1(0x51); /* push rcx */
 -
 -				/* mov rcx, src_reg */
 -				EMIT_mov(BPF_REG_4, src_reg);
 -			}
 -
 -			/* shl %rax, %cl | shr %rax, %cl | sar %rax, %cl */
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_1mod(0x48, dst_reg));
 -			else if (is_ereg(dst_reg))
 -				EMIT1(add_1mod(0x40, dst_reg));
 -
 -			switch (BPF_OP(insn->code)) {
 -			case BPF_LSH: b3 = 0xE0; break;
 -			case BPF_RSH: b3 = 0xE8; break;
 -			case BPF_ARSH: b3 = 0xF8; break;
 -			}
 -			EMIT2(0xD3, add_1reg(b3, dst_reg));
 -
 -			if (src_reg != BPF_REG_4)
 -				EMIT1(0x59); /* pop rcx */
 -
 -			if (insn->dst_reg == BPF_REG_4)
 -				/* mov dst_reg, r11 */
 -				EMIT_mov(insn->dst_reg, AUX_REG);
 -			break;
 -
 -		case BPF_ALU | BPF_END | BPF_FROM_BE:
 -			switch (imm32) {
 -			case 16:
 -				/* emit 'ror %ax, 8' to swap lower 2 bytes */
 -				EMIT1(0x66);
 -				if (is_ereg(dst_reg))
 -					EMIT1(0x41);
 -				EMIT3(0xC1, add_1reg(0xC8, dst_reg), 8);
 -
 -				/* emit 'movzwl eax, ax' */
 -				if (is_ereg(dst_reg))
 -					EMIT3(0x45, 0x0F, 0xB7);
 -				else
 -					EMIT2(0x0F, 0xB7);
 -				EMIT1(add_2reg(0xC0, dst_reg, dst_reg));
 -				break;
 -			case 32:
 -				/* emit 'bswap eax' to swap lower 4 bytes */
 -				if (is_ereg(dst_reg))
 -					EMIT2(0x41, 0x0F);
 -				else
 -					EMIT1(0x0F);
 -				EMIT1(add_1reg(0xC8, dst_reg));
 -				break;
 -			case 64:
 -				/* emit 'bswap rax' to swap 8 bytes */
 -				EMIT3(add_1mod(0x48, dst_reg), 0x0F,
 -				      add_1reg(0xC8, dst_reg));
 -				break;
 -			}
 -			break;
 -
 -		case BPF_ALU | BPF_END | BPF_FROM_LE:
 -			switch (imm32) {
 -			case 16:
 -				/* emit 'movzwl eax, ax' to zero extend 16-bit
 -				 * into 64 bit
 -				 */
 -				if (is_ereg(dst_reg))
 -					EMIT3(0x45, 0x0F, 0xB7);
 -				else
 -					EMIT2(0x0F, 0xB7);
 -				EMIT1(add_2reg(0xC0, dst_reg, dst_reg));
 -				break;
 -			case 32:
 -				/* emit 'mov eax, eax' to clear upper 32-bits */
 -				if (is_ereg(dst_reg))
 -					EMIT1(0x45);
 -				EMIT2(0x89, add_2reg(0xC0, dst_reg, dst_reg));
 -				break;
 -			case 64:
 -				/* nop */
 -				break;
 -			}
 -			break;
 -
 -			/* ST: *(u8*)(dst_reg + off) = imm */
 -		case BPF_ST | BPF_MEM | BPF_B:
 -			if (is_ereg(dst_reg))
 -				EMIT2(0x41, 0xC6);
 -			else
 -				EMIT1(0xC6);
 -			goto st;
 -		case BPF_ST | BPF_MEM | BPF_H:
 -			if (is_ereg(dst_reg))
 -				EMIT3(0x66, 0x41, 0xC7);
 -			else
 -				EMIT2(0x66, 0xC7);
 -			goto st;
 -		case BPF_ST | BPF_MEM | BPF_W:
 -			if (is_ereg(dst_reg))
 -				EMIT2(0x41, 0xC7);
 -			else
 -				EMIT1(0xC7);
 -			goto st;
 -		case BPF_ST | BPF_MEM | BPF_DW:
 -			EMIT2(add_1mod(0x48, dst_reg), 0xC7);
 -
 -st:			if (is_imm8(insn->off))
 -				EMIT2(add_1reg(0x40, dst_reg), insn->off);
 -			else
 -				EMIT1_off32(add_1reg(0x80, dst_reg), insn->off);
 -
 -			EMIT(imm32, bpf_size_to_x86_bytes(BPF_SIZE(insn->code)));
 -			break;
 -
 -			/* STX: *(u8*)(dst_reg + off) = src_reg */
 -		case BPF_STX | BPF_MEM | BPF_B:
 -			/* emit 'mov byte ptr [rax + off], al' */
 -			if (is_ereg(dst_reg) || is_ereg(src_reg) ||
 -			    /* have to add extra byte for x86 SIL, DIL regs */
 -			    src_reg == BPF_REG_1 || src_reg == BPF_REG_2)
 -				EMIT2(add_2mod(0x40, dst_reg, src_reg), 0x88);
 -			else
 -				EMIT1(0x88);
 -			goto stx;
 -		case BPF_STX | BPF_MEM | BPF_H:
 -			if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT3(0x66, add_2mod(0x40, dst_reg, src_reg), 0x89);
 -			else
 -				EMIT2(0x66, 0x89);
 -			goto stx;
 -		case BPF_STX | BPF_MEM | BPF_W:
 -			if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT2(add_2mod(0x40, dst_reg, src_reg), 0x89);
 -			else
 -				EMIT1(0x89);
 -			goto stx;
 -		case BPF_STX | BPF_MEM | BPF_DW:
 -			EMIT2(add_2mod(0x48, dst_reg, src_reg), 0x89);
 -stx:			if (is_imm8(insn->off))
 -				EMIT2(add_2reg(0x40, dst_reg, src_reg), insn->off);
 -			else
 -				EMIT1_off32(add_2reg(0x80, dst_reg, src_reg),
 -					    insn->off);
 -			break;
 -
 -			/* LDX: dst_reg = *(u8*)(src_reg + off) */
 -		case BPF_LDX | BPF_MEM | BPF_B:
 -			/* emit 'movzx rax, byte ptr [rax + off]' */
 -			EMIT3(add_2mod(0x48, src_reg, dst_reg), 0x0F, 0xB6);
 -			goto ldx;
 -		case BPF_LDX | BPF_MEM | BPF_H:
 -			/* emit 'movzx rax, word ptr [rax + off]' */
 -			EMIT3(add_2mod(0x48, src_reg, dst_reg), 0x0F, 0xB7);
 -			goto ldx;
 -		case BPF_LDX | BPF_MEM | BPF_W:
 -			/* emit 'mov eax, dword ptr [rax+0x14]' */
 -			if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT2(add_2mod(0x40, src_reg, dst_reg), 0x8B);
 -			else
 -				EMIT1(0x8B);
 -			goto ldx;
 -		case BPF_LDX | BPF_MEM | BPF_DW:
 -			/* emit 'mov rax, qword ptr [rax+0x14]' */
 -			EMIT2(add_2mod(0x48, src_reg, dst_reg), 0x8B);
 -ldx:			/* if insn->off == 0 we can save one extra byte, but
 -			 * special case of x86 r13 which always needs an offset
 -			 * is not worth the hassle
 -			 */
 -			if (is_imm8(insn->off))
 -				EMIT2(add_2reg(0x40, src_reg, dst_reg), insn->off);
 -			else
 -				EMIT1_off32(add_2reg(0x80, src_reg, dst_reg),
 -					    insn->off);
 -			break;
 -
 -			/* STX XADD: lock *(u32*)(dst_reg + off) += src_reg */
 -		case BPF_STX | BPF_XADD | BPF_W:
 -			/* emit 'lock add dword ptr [rax + off], eax' */
 -			if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT3(0xF0, add_2mod(0x40, dst_reg, src_reg), 0x01);
 -			else
 -				EMIT2(0xF0, 0x01);
 -			goto xadd;
 -		case BPF_STX | BPF_XADD | BPF_DW:
 -			EMIT3(0xF0, add_2mod(0x48, dst_reg, src_reg), 0x01);
 -xadd:			if (is_imm8(insn->off))
 -				EMIT2(add_2reg(0x40, dst_reg, src_reg), insn->off);
 -			else
 -				EMIT1_off32(add_2reg(0x80, dst_reg, src_reg),
 -					    insn->off);
 -			break;
 -
 -			/* call */
 -		case BPF_JMP | BPF_CALL:
 -			func = (u8 *) __bpf_call_base + imm32;
 -			jmp_offset = func - (image + addrs[i]);
 -			if (seen_ld_abs) {
 -				reload_skb_data = bpf_helper_changes_pkt_data(func);
 -				if (reload_skb_data) {
 -					EMIT1(0x57); /* push %rdi */
 -					jmp_offset += 22; /* pop, mov, sub, mov */
 -				} else {
 -					EMIT2(0x41, 0x52); /* push %r10 */
 -					EMIT2(0x41, 0x51); /* push %r9 */
 -					/* need to adjust jmp offset, since
 -					 * pop %r9, pop %r10 take 4 bytes after call insn
 -					 */
 -					jmp_offset += 4;
 -				}
 -			}
 -			if (!imm32 || !is_simm32(jmp_offset)) {
 -				pr_err("unsupported bpf func %d addr %p image %p\n",
 -				       imm32, func, image);
 -				return -EINVAL;
 -			}
 -			EMIT1_off32(0xE8, jmp_offset);
 -			if (seen_ld_abs) {
 -				if (reload_skb_data) {
 -					EMIT1(0x5F); /* pop %rdi */
 -					emit_load_skb_data_hlen(&prog);
 -				} else {
 -					EMIT2(0x41, 0x59); /* pop %r9 */
 -					EMIT2(0x41, 0x5A); /* pop %r10 */
 -				}
 -			}
 -			break;
 -
 -		case BPF_JMP | BPF_TAIL_CALL:
 -			emit_bpf_tail_call(&prog);
 -			break;
 -
 -			/* cond jump */
 -		case BPF_JMP | BPF_JEQ | BPF_X:
 -		case BPF_JMP | BPF_JNE | BPF_X:
 -		case BPF_JMP | BPF_JGT | BPF_X:
 -		case BPF_JMP | BPF_JLT | BPF_X:
 -		case BPF_JMP | BPF_JGE | BPF_X:
 -		case BPF_JMP | BPF_JLE | BPF_X:
 -		case BPF_JMP | BPF_JSGT | BPF_X:
 -		case BPF_JMP | BPF_JSLT | BPF_X:
 -		case BPF_JMP | BPF_JSGE | BPF_X:
 -		case BPF_JMP | BPF_JSLE | BPF_X:
 -			/* cmp dst_reg, src_reg */
 -			EMIT3(add_2mod(0x48, dst_reg, src_reg), 0x39,
 -			      add_2reg(0xC0, dst_reg, src_reg));
 -			goto emit_cond_jmp;
 -
 -		case BPF_JMP | BPF_JSET | BPF_X:
 -			/* test dst_reg, src_reg */
 -			EMIT3(add_2mod(0x48, dst_reg, src_reg), 0x85,
 -			      add_2reg(0xC0, dst_reg, src_reg));
 -			goto emit_cond_jmp;
 -
 -		case BPF_JMP | BPF_JSET | BPF_K:
 -			/* test dst_reg, imm32 */
 -			EMIT1(add_1mod(0x48, dst_reg));
 -			EMIT2_off32(0xF7, add_1reg(0xC0, dst_reg), imm32);
 -			goto emit_cond_jmp;
 -
 -		case BPF_JMP | BPF_JEQ | BPF_K:
 -		case BPF_JMP | BPF_JNE | BPF_K:
 -		case BPF_JMP | BPF_JGT | BPF_K:
 -		case BPF_JMP | BPF_JLT | BPF_K:
 -		case BPF_JMP | BPF_JGE | BPF_K:
 -		case BPF_JMP | BPF_JLE | BPF_K:
 -		case BPF_JMP | BPF_JSGT | BPF_K:
 -		case BPF_JMP | BPF_JSLT | BPF_K:
 -		case BPF_JMP | BPF_JSGE | BPF_K:
 -		case BPF_JMP | BPF_JSLE | BPF_K:
 -			/* cmp dst_reg, imm8/32 */
 -			EMIT1(add_1mod(0x48, dst_reg));
 -
 -			if (is_imm8(imm32))
 -				EMIT3(0x83, add_1reg(0xF8, dst_reg), imm32);
 -			else
 -				EMIT2_off32(0x81, add_1reg(0xF8, dst_reg), imm32);
 -
 -emit_cond_jmp:		/* convert BPF opcode to x86 */
 -			switch (BPF_OP(insn->code)) {
 -			case BPF_JEQ:
 -				jmp_cond = X86_JE;
 -				break;
 -			case BPF_JSET:
 -			case BPF_JNE:
 -				jmp_cond = X86_JNE;
 -				break;
 -			case BPF_JGT:
 -				/* GT is unsigned '>', JA in x86 */
 -				jmp_cond = X86_JA;
 -				break;
 -			case BPF_JLT:
 -				/* LT is unsigned '<', JB in x86 */
 -				jmp_cond = X86_JB;
 -				break;
 -			case BPF_JGE:
 -				/* GE is unsigned '>=', JAE in x86 */
 -				jmp_cond = X86_JAE;
 -				break;
 -			case BPF_JLE:
 -				/* LE is unsigned '<=', JBE in x86 */
 -				jmp_cond = X86_JBE;
 -				break;
 -			case BPF_JSGT:
 -				/* signed '>', GT in x86 */
 -				jmp_cond = X86_JG;
 -				break;
 -			case BPF_JSLT:
 -				/* signed '<', LT in x86 */
 -				jmp_cond = X86_JL;
 -				break;
 -			case BPF_JSGE:
 -				/* signed '>=', GE in x86 */
 -				jmp_cond = X86_JGE;
 -				break;
 -			case BPF_JSLE:
 -				/* signed '<=', LE in x86 */
 -				jmp_cond = X86_JLE;
 -				break;
 -			default: /* to silence gcc warning */
 -				return -EFAULT;
 -			}
 -			jmp_offset = addrs[i + insn->off] - addrs[i];
 -			if (is_imm8(jmp_offset)) {
 -				EMIT2(jmp_cond, jmp_offset);
 -			} else if (is_simm32(jmp_offset)) {
 -				EMIT2_off32(0x0F, jmp_cond + 0x10, jmp_offset);
 -			} else {
 -				pr_err("cond_jmp gen bug %llx\n", jmp_offset);
 -				return -EFAULT;
 -			}
 -
 -			break;
 -
 -		case BPF_JMP | BPF_JA:
 -			jmp_offset = addrs[i + insn->off] - addrs[i];
 -			if (!jmp_offset)
 -				/* optimize out nop jumps */
 -				break;
 -emit_jmp:
 -			if (is_imm8(jmp_offset)) {
 -				EMIT2(0xEB, jmp_offset);
 -			} else if (is_simm32(jmp_offset)) {
 -				EMIT1_off32(0xE9, jmp_offset);
 -			} else {
 -				pr_err("jmp gen bug %llx\n", jmp_offset);
 -				return -EFAULT;
 -			}
 -			break;
 -
 -		case BPF_LD | BPF_IND | BPF_W:
 -			func = sk_load_word;
 -			goto common_load;
 -		case BPF_LD | BPF_ABS | BPF_W:
 -			func = CHOOSE_LOAD_FUNC(imm32, sk_load_word);
 -common_load:
 -			ctx->seen_ld_abs = seen_ld_abs = true;
 -			jmp_offset = func - (image + addrs[i]);
 -			if (!func || !is_simm32(jmp_offset)) {
 -				pr_err("unsupported bpf func %d addr %p image %p\n",
 -				       imm32, func, image);
 -				return -EINVAL;
 -			}
 -			if (BPF_MODE(insn->code) == BPF_ABS) {
 -				/* mov %esi, imm32 */
 -				EMIT1_off32(0xBE, imm32);
 -			} else {
 -				/* mov %rsi, src_reg */
 -				EMIT_mov(BPF_REG_2, src_reg);
 -				if (imm32) {
 -					if (is_imm8(imm32))
 -						/* add %esi, imm8 */
 -						EMIT3(0x83, 0xC6, imm32);
 -					else
 -						/* add %esi, imm32 */
 -						EMIT2_off32(0x81, 0xC6, imm32);
 -				}
 -			}
 -			/* skb pointer is in R6 (%rbx), it will be copied into
 -			 * %rdi if skb_copy_bits() call is necessary.
 -			 * sk_load_* helpers also use %r10 and %r9d.
 -			 * See bpf_jit.S
 -			 */
 -			if (seen_ax_reg)
 -				/* r10 = skb->data, mov %r10, off32(%rbx) */
 -				EMIT3_off32(0x4c, 0x8b, 0x93,
 -					    offsetof(struct sk_buff, data));
 -			EMIT1_off32(0xE8, jmp_offset); /* call */
 -			break;
 -
 -		case BPF_LD | BPF_IND | BPF_H:
 -			func = sk_load_half;
 -			goto common_load;
 -		case BPF_LD | BPF_ABS | BPF_H:
 -			func = CHOOSE_LOAD_FUNC(imm32, sk_load_half);
 -			goto common_load;
 -		case BPF_LD | BPF_IND | BPF_B:
 -			func = sk_load_byte;
 -			goto common_load;
 -		case BPF_LD | BPF_ABS | BPF_B:
 -			func = CHOOSE_LOAD_FUNC(imm32, sk_load_byte);
 -			goto common_load;
 -
 -		case BPF_JMP | BPF_EXIT:
 -			if (seen_exit) {
 -				jmp_offset = ctx->cleanup_addr - addrs[i];
 -				goto emit_jmp;
 -			}
 -			seen_exit = true;
 -			/* update cleanup_addr */
 -			ctx->cleanup_addr = proglen;
 -			/* mov rbx, qword ptr [rbp+0] */
 -			EMIT4(0x48, 0x8B, 0x5D, 0);
 -			/* mov r13, qword ptr [rbp+8] */
 -			EMIT4(0x4C, 0x8B, 0x6D, 8);
 -			/* mov r14, qword ptr [rbp+16] */
 -			EMIT4(0x4C, 0x8B, 0x75, 16);
 -			/* mov r15, qword ptr [rbp+24] */
 -			EMIT4(0x4C, 0x8B, 0x7D, 24);
 -
 -			/* add rbp, AUX_STACK_SPACE */
 -			EMIT4(0x48, 0x83, 0xC5, AUX_STACK_SPACE);
 -			EMIT1(0xC9); /* leave */
 -			EMIT1(0xC3); /* ret */
 -			break;
 -
 -		default:
 -			/* By design x64 JIT should support all BPF instructions
 -			 * This error will be seen if new instruction was added
 -			 * to interpreter, but not to JIT
 -			 * or if there is junk in bpf_prog
 -			 */
 -			pr_err("bpf_jit: unknown opcode %02x\n", insn->code);
 -			return -EINVAL;
 -		}
 -
 -		ilen = prog - temp;
 -		if (ilen > BPF_MAX_INSN_SIZE) {
 -			pr_err("bpf_jit: fatal insn size error\n");
 -			return -EFAULT;
 -		}
 -
 -		if (image) {
 -			if (unlikely(proglen + ilen > oldproglen)) {
 -				pr_err("bpf_jit: fatal error\n");
 -				return -EFAULT;
 -			}
 -			memcpy(image + proglen, temp, ilen);
 -		}
 -		proglen += ilen;
 -		addrs[i] = proglen;
 -		prog = temp;
 +	struct sk_buff skb_probe = {
 +		.pkt_type = ~0,
 +	};
 +	char *ct = (char *)&skb_probe;
 +	unsigned int off;
 +
 +	for (off = 0; off < sizeof(struct sk_buff); off++) {
 +		if (ct[off] == PKT_TYPE_MAX)
 +			return off;
  	}
 -	return proglen;
 +	pr_err_once("Please fix pkt_type_offset(), as pkt_type couldn't be found\n");
 +	return -1;
  }
  
++<<<<<<< HEAD
 +void bpf_jit_compile(struct sk_filter *fp)
 +{
 +	u8 temp[64];
 +	u8 *prog;
 +	unsigned int proglen, oldproglen = 0;
 +	int ilen, i;
 +	int t_offset, f_offset;
 +	u8 t_op, f_op, seen = 0, pass;
++=======
+ struct x64_jit_data {
+ 	struct bpf_binary_header *header;
+ 	int *addrs;
+ 	u8 *image;
+ 	int proglen;
+ 	struct jit_context ctx;
+ };
+ 
+ struct bpf_prog *bpf_int_jit_compile(struct bpf_prog *prog)
+ {
+ 	struct bpf_binary_header *header = NULL;
+ 	struct bpf_prog *tmp, *orig_prog = prog;
+ 	struct x64_jit_data *jit_data;
+ 	int proglen, oldproglen = 0;
+ 	struct jit_context ctx = {};
+ 	bool tmp_blinded = false;
+ 	bool extra_pass = false;
++>>>>>>> 1c2a088a6626 (bpf: x64: add JIT support for multi-function programs)
  	u8 *image = NULL;
 -	int *addrs;
 -	int pass;
 -	int i;
 -
 -	if (!prog->jit_requested)
 -		return orig_prog;
 -
 +	u8 *func;
 +	int pc_ret0 = -1; /* bpf index of first RET #0 instruction (if any) */
 +	unsigned int cleanup_addr; /* epilogue code offset */
 +	unsigned int *addrs;
 +	const struct sock_filter *filter = fp->insns;
 +	int flen = fp->len;
 +
 +	if (!bpf_jit_enable)
 +		return;
 +
++<<<<<<< HEAD
 +	addrs = kmalloc(flen * sizeof(*addrs), GFP_KERNEL);
 +	if (addrs == NULL)
 +		return;
++=======
+ 	tmp = bpf_jit_blind_constants(prog);
+ 	/* If blinding was requested and we failed during blinding,
+ 	 * we must fall back to the interpreter.
+ 	 */
+ 	if (IS_ERR(tmp))
+ 		return orig_prog;
+ 	if (tmp != prog) {
+ 		tmp_blinded = true;
+ 		prog = tmp;
+ 	}
+ 
+ 	jit_data = prog->aux->jit_data;
+ 	if (!jit_data) {
+ 		jit_data = kzalloc(sizeof(*jit_data), GFP_KERNEL);
+ 		if (!jit_data) {
+ 			prog = orig_prog;
+ 			goto out;
+ 		}
+ 		prog->aux->jit_data = jit_data;
+ 	}
+ 	addrs = jit_data->addrs;
+ 	if (addrs) {
+ 		ctx = jit_data->ctx;
+ 		oldproglen = jit_data->proglen;
+ 		image = jit_data->image;
+ 		header = jit_data->header;
+ 		extra_pass = true;
+ 		goto skip_init_addrs;
+ 	}
+ 	addrs = kmalloc(prog->len * sizeof(*addrs), GFP_KERNEL);
+ 	if (!addrs) {
+ 		prog = orig_prog;
+ 		goto out_addrs;
+ 	}
++>>>>>>> 1c2a088a6626 (bpf: x64: add JIT support for multi-function programs)
  
  	/* Before first pass, make a rough estimation of addrs[]
  	 * each bpf instruction is translated to less than 64 bytes
@@@ -174,7 -1176,8 +231,12 @@@
  		proglen += 64;
  		addrs[i] = proglen;
  	}
++<<<<<<< HEAD
 +	cleanup_addr = proglen; /* epilogue address */
++=======
+ 	ctx.cleanup_addr = proglen;
+ skip_init_addrs:
++>>>>>>> 1c2a088a6626 (bpf: x64: add JIT support for multi-function programs)
  
  	/* JITed image shrinks with every pass and the loop iterates
  	 * until the image stops shrinking. Very large bpf programs
@@@ -738,31 -1214,35 +800,57 @@@ cond_branch:			f_offset = addrs[i + fil
  	}
  
  	if (bpf_jit_enable > 1)
 -		bpf_jit_dump(prog->len, proglen, pass + 1, image);
 +		bpf_jit_dump(flen, proglen, pass, image);
  
  	if (image) {
++<<<<<<< HEAD
 +		bpf_flush_icache(image, image + proglen);
 +		fp->bpf_func = (void *)image;
 +	}
++=======
+ 		bpf_flush_icache(header, image + proglen);
+ 		if (!prog->is_func || extra_pass) {
+ 			bpf_jit_binary_lock_ro(header);
+ 		} else {
+ 			jit_data->addrs = addrs;
+ 			jit_data->ctx = ctx;
+ 			jit_data->proglen = proglen;
+ 			jit_data->image = image;
+ 			jit_data->header = header;
+ 		}
+ 		prog->bpf_func = (void *)image;
+ 		prog->jited = 1;
+ 		prog->jited_len = proglen;
+ 	} else {
+ 		prog = orig_prog;
+ 	}
+ 
+ 	if (!prog->is_func || extra_pass) {
+ out_addrs:
+ 		kfree(addrs);
+ 		kfree(jit_data);
+ 		prog->aux->jit_data = NULL;
+ 	}
++>>>>>>> 1c2a088a6626 (bpf: x64: add JIT support for multi-function programs)
  out:
 -	if (tmp_blinded)
 -		bpf_jit_prog_release_other(prog, prog == orig_prog ?
 -					   tmp : orig_prog);
 -	return prog;
 +	kfree(addrs);
 +	return;
 +}
 +
 +static void jit_free_defer(struct work_struct *arg)
 +{
 +	module_free(NULL, arg);
 +}
 +
 +/* run from softirq, we must use a work_struct to call
 + * module_free() from process context
 + */
 +void bpf_jit_free(struct sk_filter *fp)
 +{
 +	if (fp->bpf_func != sk_run_filter) {
 +		struct work_struct *work = (struct work_struct *)fp->bpf_func;
 +
 +		INIT_WORK(work, jit_free_defer);
 +		schedule_work(work);
 +	}
  }
diff --cc include/linux/bpf.h
index d4c1f9049ad3,da54ef644fcd..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -89,28 -170,428 +89,37 @@@ struct bpf_func_proto 
  struct bpf_verifier_ops {
  	/* return eBPF function prototype for verification */
  	const struct bpf_func_proto *(*get_func_proto)(enum bpf_func_id func_id);
 -
 -	/* return true if 'size' wide access at offset 'off' within bpf_context
 -	 * with 'type' (read or write) is allowed
 -	 */
 -	bool (*is_valid_access)(int off, int size, enum bpf_access_type type,
 -				struct bpf_insn_access_aux *info);
 -	int (*gen_prologue)(struct bpf_insn *insn, bool direct_write,
 -			    const struct bpf_prog *prog);
 -	u32 (*convert_ctx_access)(enum bpf_access_type type,
 -				  const struct bpf_insn *src,
 -				  struct bpf_insn *dst,
 -				  struct bpf_prog *prog, u32 *target_size);
  };
  
 -struct bpf_dev_offload {
 -	struct bpf_prog		*prog;
 -	struct net_device	*netdev;
 -	void			*dev_priv;
 -	struct list_head	offloads;
 -	bool			dev_state;
 -	bool			verifier_running;
 -	wait_queue_head_t	verifier_done;
 +struct bpf_prog_type_list {
 +	struct list_head list_node;
 +	struct bpf_verifier_ops *ops;
 +	enum bpf_prog_type type;
  };
  
 +void bpf_register_prog_type(struct bpf_prog_type_list *tl);
 +
 +struct bpf_prog;
 +
  struct bpf_prog_aux {
  	atomic_t refcnt;
 -	u32 used_map_cnt;
 -	u32 max_ctx_offset;
 -	u32 stack_depth;
 +	bool is_gpl_compatible;
 +	enum bpf_prog_type prog_type;
 +	struct bpf_verifier_ops *ops;
  	u32 id;
++<<<<<<< HEAD
++=======
+ 	u32 func_cnt;
+ 	struct bpf_prog **func;
+ 	void *jit_data; /* JIT specific data. arch dependent */
+ 	struct latch_tree_node ksym_tnode;
+ 	struct list_head ksym_lnode;
+ 	const struct bpf_prog_ops *ops;
++>>>>>>> 1c2a088a6626 (bpf: x64: add JIT support for multi-function programs)
  	struct bpf_map **used_maps;
 +	u32 used_map_cnt;
  	struct bpf_prog *prog;
 -	struct user_struct *user;
 -	u64 load_time; /* ns since boottime */
 -	char name[BPF_OBJ_NAME_LEN];
 -#ifdef CONFIG_SECURITY
 -	void *security;
 -#endif
 -	struct bpf_dev_offload *offload;
 -	union {
 -		struct work_struct work;
 -		struct rcu_head	rcu;
 -	};
 -};
 -
 -struct bpf_array {
 -	struct bpf_map map;
 -	u32 elem_size;
 -	/* 'ownership' of prog_array is claimed by the first program that
 -	 * is going to use this map or by the first program which FD is stored
 -	 * in the map to make sure that all callers and callees have the same
 -	 * prog_type and JITed flag
 -	 */
 -	enum bpf_prog_type owner_prog_type;
 -	bool owner_jited;
 -	union {
 -		char value[0] __aligned(8);
 -		void *ptrs[0] __aligned(8);
 -		void __percpu *pptrs[0] __aligned(8);
 -	};
 -};
 -
 -#define MAX_TAIL_CALL_CNT 32
 -
 -struct bpf_event_entry {
 -	struct perf_event *event;
 -	struct file *perf_file;
 -	struct file *map_file;
 -	struct rcu_head rcu;
 -};
 -
 -bool bpf_prog_array_compatible(struct bpf_array *array, const struct bpf_prog *fp);
 -int bpf_prog_calc_tag(struct bpf_prog *fp);
 -
 -const struct bpf_func_proto *bpf_get_trace_printk_proto(void);
 -
 -typedef unsigned long (*bpf_ctx_copy_t)(void *dst, const void *src,
 -					unsigned long off, unsigned long len);
 -
 -u64 bpf_event_output(struct bpf_map *map, u64 flags, void *meta, u64 meta_size,
 -		     void *ctx, u64 ctx_size, bpf_ctx_copy_t ctx_copy);
 -
 -int bpf_prog_test_run_xdp(struct bpf_prog *prog, const union bpf_attr *kattr,
 -			  union bpf_attr __user *uattr);
 -int bpf_prog_test_run_skb(struct bpf_prog *prog, const union bpf_attr *kattr,
 -			  union bpf_attr __user *uattr);
 -
 -/* an array of programs to be executed under rcu_lock.
 - *
 - * Typical usage:
 - * ret = BPF_PROG_RUN_ARRAY(&bpf_prog_array, ctx, BPF_PROG_RUN);
 - *
 - * the structure returned by bpf_prog_array_alloc() should be populated
 - * with program pointers and the last pointer must be NULL.
 - * The user has to keep refcnt on the program and make sure the program
 - * is removed from the array before bpf_prog_put().
 - * The 'struct bpf_prog_array *' should only be replaced with xchg()
 - * since other cpus are walking the array of pointers in parallel.
 - */
 -struct bpf_prog_array {
 -	struct rcu_head rcu;
 -	struct bpf_prog *progs[0];
 +	struct work_struct work;
  };
  
 -struct bpf_prog_array __rcu *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags);
 -void bpf_prog_array_free(struct bpf_prog_array __rcu *progs);
 -int bpf_prog_array_length(struct bpf_prog_array __rcu *progs);
 -int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *progs,
 -				__u32 __user *prog_ids, u32 cnt);
 -
 -void bpf_prog_array_delete_safe(struct bpf_prog_array __rcu *progs,
 -				struct bpf_prog *old_prog);
 -int bpf_prog_array_copy_info(struct bpf_prog_array __rcu *array,
 -			     __u32 __user *prog_ids, u32 request_cnt,
 -			     __u32 __user *prog_cnt);
 -int bpf_prog_array_copy(struct bpf_prog_array __rcu *old_array,
 -			struct bpf_prog *exclude_prog,
 -			struct bpf_prog *include_prog,
 -			struct bpf_prog_array **new_array);
 -
 -#define __BPF_PROG_RUN_ARRAY(array, ctx, func, check_non_null)	\
 -	({						\
 -		struct bpf_prog **_prog, *__prog;	\
 -		struct bpf_prog_array *_array;		\
 -		u32 _ret = 1;				\
 -		rcu_read_lock();			\
 -		_array = rcu_dereference(array);	\
 -		if (unlikely(check_non_null && !_array))\
 -			goto _out;			\
 -		_prog = _array->progs;			\
 -		while ((__prog = READ_ONCE(*_prog))) {	\
 -			_ret &= func(__prog, ctx);	\
 -			_prog++;			\
 -		}					\
 -_out:							\
 -		rcu_read_unlock();			\
 -		_ret;					\
 -	 })
 -
 -#define BPF_PROG_RUN_ARRAY(array, ctx, func)		\
 -	__BPF_PROG_RUN_ARRAY(array, ctx, func, false)
 -
 -#define BPF_PROG_RUN_ARRAY_CHECK(array, ctx, func)	\
 -	__BPF_PROG_RUN_ARRAY(array, ctx, func, true)
 -
 -#ifdef CONFIG_BPF_SYSCALL
 -DECLARE_PER_CPU(int, bpf_prog_active);
 -
 -extern const struct file_operations bpf_map_fops;
 -extern const struct file_operations bpf_prog_fops;
 -
 -#define BPF_PROG_TYPE(_id, _name) \
 -	extern const struct bpf_prog_ops _name ## _prog_ops; \
 -	extern const struct bpf_verifier_ops _name ## _verifier_ops;
 -#define BPF_MAP_TYPE(_id, _ops) \
 -	extern const struct bpf_map_ops _ops;
 -#include <linux/bpf_types.h>
 -#undef BPF_PROG_TYPE
 -#undef BPF_MAP_TYPE
 -
 -extern const struct bpf_prog_ops bpf_offload_prog_ops;
 -extern const struct bpf_verifier_ops tc_cls_act_analyzer_ops;
 -extern const struct bpf_verifier_ops xdp_analyzer_ops;
 -
 -struct bpf_prog *bpf_prog_get(u32 ufd);
 -struct bpf_prog *bpf_prog_get_type_dev(u32 ufd, enum bpf_prog_type type,
 -				       bool attach_drv);
 -struct bpf_prog * __must_check bpf_prog_add(struct bpf_prog *prog, int i);
 -void bpf_prog_sub(struct bpf_prog *prog, int i);
 -struct bpf_prog * __must_check bpf_prog_inc(struct bpf_prog *prog);
 -struct bpf_prog * __must_check bpf_prog_inc_not_zero(struct bpf_prog *prog);
 -void bpf_prog_put(struct bpf_prog *prog);
 -int __bpf_prog_charge(struct user_struct *user, u32 pages);
 -void __bpf_prog_uncharge(struct user_struct *user, u32 pages);
 -
 -struct bpf_map *bpf_map_get_with_uref(u32 ufd);
 -struct bpf_map *__bpf_map_get(struct fd f);
 -struct bpf_map * __must_check bpf_map_inc(struct bpf_map *map, bool uref);
 -void bpf_map_put_with_uref(struct bpf_map *map);
 -void bpf_map_put(struct bpf_map *map);
 -int bpf_map_precharge_memlock(u32 pages);
 -void *bpf_map_area_alloc(size_t size, int numa_node);
 -void bpf_map_area_free(void *base);
 -
 -extern int sysctl_unprivileged_bpf_disabled;
 -
 -int bpf_map_new_fd(struct bpf_map *map, int flags);
 -int bpf_prog_new_fd(struct bpf_prog *prog);
 -
 -int bpf_obj_pin_user(u32 ufd, const char __user *pathname);
 -int bpf_obj_get_user(const char __user *pathname, int flags);
 -
 -int bpf_percpu_hash_copy(struct bpf_map *map, void *key, void *value);
 -int bpf_percpu_array_copy(struct bpf_map *map, void *key, void *value);
 -int bpf_percpu_hash_update(struct bpf_map *map, void *key, void *value,
 -			   u64 flags);
 -int bpf_percpu_array_update(struct bpf_map *map, void *key, void *value,
 -			    u64 flags);
 -
 -int bpf_stackmap_copy(struct bpf_map *map, void *key, void *value);
 -
 -int bpf_fd_array_map_update_elem(struct bpf_map *map, struct file *map_file,
 -				 void *key, void *value, u64 map_flags);
 -int bpf_fd_array_map_lookup_elem(struct bpf_map *map, void *key, u32 *value);
 -void bpf_fd_array_map_clear(struct bpf_map *map);
 -int bpf_fd_htab_map_update_elem(struct bpf_map *map, struct file *map_file,
 -				void *key, void *value, u64 map_flags);
 -int bpf_fd_htab_map_lookup_elem(struct bpf_map *map, void *key, u32 *value);
 -
 -int bpf_get_file_flag(int flags);
 -
 -/* memcpy that is used with 8-byte aligned pointers, power-of-8 size and
 - * forced to use 'long' read/writes to try to atomically copy long counters.
 - * Best-effort only.  No barriers here, since it _will_ race with concurrent
 - * updates from BPF programs. Called from bpf syscall and mostly used with
 - * size 8 or 16 bytes, so ask compiler to inline it.
 - */
 -static inline void bpf_long_memcpy(void *dst, const void *src, u32 size)
 -{
 -	const long *lsrc = src;
 -	long *ldst = dst;
 -
 -	size /= sizeof(long);
 -	while (size--)
 -		*ldst++ = *lsrc++;
 -}
 -
 -/* verify correctness of eBPF program */
 -int bpf_check(struct bpf_prog **fp, union bpf_attr *attr);
 -void bpf_patch_call_args(struct bpf_insn *insn, u32 stack_depth);
 -
 -/* Map specifics */
 -struct net_device  *__dev_map_lookup_elem(struct bpf_map *map, u32 key);
 -void __dev_map_insert_ctx(struct bpf_map *map, u32 index);
 -void __dev_map_flush(struct bpf_map *map);
 -
 -struct bpf_cpu_map_entry *__cpu_map_lookup_elem(struct bpf_map *map, u32 key);
 -void __cpu_map_insert_ctx(struct bpf_map *map, u32 index);
 -void __cpu_map_flush(struct bpf_map *map);
 -struct xdp_buff;
 -int cpu_map_enqueue(struct bpf_cpu_map_entry *rcpu, struct xdp_buff *xdp,
 -		    struct net_device *dev_rx);
 -
 -/* Return map's numa specified by userspace */
 -static inline int bpf_map_attr_numa_node(const union bpf_attr *attr)
 -{
 -	return (attr->map_flags & BPF_F_NUMA_NODE) ?
 -		attr->numa_node : NUMA_NO_NODE;
 -}
 -
 -#else /* !CONFIG_BPF_SYSCALL */
 -static inline struct bpf_prog *bpf_prog_get(u32 ufd)
 -{
 -	return ERR_PTR(-EOPNOTSUPP);
 -}
 -
 -static inline struct bpf_prog *bpf_prog_get_type_dev(u32 ufd,
 -						     enum bpf_prog_type type,
 -						     bool attach_drv)
 -{
 -	return ERR_PTR(-EOPNOTSUPP);
 -}
 -
 -static inline struct bpf_prog * __must_check bpf_prog_add(struct bpf_prog *prog,
 -							  int i)
 -{
 -	return ERR_PTR(-EOPNOTSUPP);
 -}
 -
 -static inline void bpf_prog_sub(struct bpf_prog *prog, int i)
 -{
 -}
 -
 -static inline void bpf_prog_put(struct bpf_prog *prog)
 -{
 -}
 -
 -static inline struct bpf_prog * __must_check bpf_prog_inc(struct bpf_prog *prog)
 -{
 -	return ERR_PTR(-EOPNOTSUPP);
 -}
 -
 -static inline struct bpf_prog *__must_check
 -bpf_prog_inc_not_zero(struct bpf_prog *prog)
 -{
 -	return ERR_PTR(-EOPNOTSUPP);
 -}
 -
 -static inline int __bpf_prog_charge(struct user_struct *user, u32 pages)
 -{
 -	return 0;
 -}
 -
 -static inline void __bpf_prog_uncharge(struct user_struct *user, u32 pages)
 -{
 -}
 -
 -static inline int bpf_obj_get_user(const char __user *pathname, int flags)
 -{
 -	return -EOPNOTSUPP;
 -}
 -
 -static inline struct net_device  *__dev_map_lookup_elem(struct bpf_map *map,
 -						       u32 key)
 -{
 -	return NULL;
 -}
 -
 -static inline void __dev_map_insert_ctx(struct bpf_map *map, u32 index)
 -{
 -}
 -
 -static inline void __dev_map_flush(struct bpf_map *map)
 -{
 -}
 -
 -static inline
 -struct bpf_cpu_map_entry *__cpu_map_lookup_elem(struct bpf_map *map, u32 key)
 -{
 -	return NULL;
 -}
 -
 -static inline void __cpu_map_insert_ctx(struct bpf_map *map, u32 index)
 -{
 -}
 -
 -static inline void __cpu_map_flush(struct bpf_map *map)
 -{
 -}
 -
 -struct xdp_buff;
 -static inline int cpu_map_enqueue(struct bpf_cpu_map_entry *rcpu,
 -				  struct xdp_buff *xdp,
 -				  struct net_device *dev_rx)
 -{
 -	return 0;
 -}
 -#endif /* CONFIG_BPF_SYSCALL */
 -
 -static inline struct bpf_prog *bpf_prog_get_type(u32 ufd,
 -						 enum bpf_prog_type type)
 -{
 -	return bpf_prog_get_type_dev(ufd, type, false);
 -}
 -
 -int bpf_prog_offload_compile(struct bpf_prog *prog);
 -void bpf_prog_offload_destroy(struct bpf_prog *prog);
 -
 -#if defined(CONFIG_NET) && defined(CONFIG_BPF_SYSCALL)
 -int bpf_prog_offload_init(struct bpf_prog *prog, union bpf_attr *attr);
 -
 -static inline bool bpf_prog_is_dev_bound(struct bpf_prog_aux *aux)
 -{
 -	return aux->offload;
 -}
 -#else
 -static inline int bpf_prog_offload_init(struct bpf_prog *prog,
 -					union bpf_attr *attr)
 -{
 -	return -EOPNOTSUPP;
 -}
 -
 -static inline bool bpf_prog_is_dev_bound(struct bpf_prog_aux *aux)
 -{
 -	return false;
 -}
 -#endif /* CONFIG_NET && CONFIG_BPF_SYSCALL */
 -
 -#if defined(CONFIG_STREAM_PARSER) && defined(CONFIG_BPF_SYSCALL)
 -struct sock  *__sock_map_lookup_elem(struct bpf_map *map, u32 key);
 -int sock_map_prog(struct bpf_map *map, struct bpf_prog *prog, u32 type);
 -#else
 -static inline struct sock  *__sock_map_lookup_elem(struct bpf_map *map, u32 key)
 -{
 -	return NULL;
 -}
 -
 -static inline int sock_map_prog(struct bpf_map *map,
 -				struct bpf_prog *prog,
 -				u32 type)
 -{
 -	return -EOPNOTSUPP;
 -}
 -#endif
 -
 -/* verifier prototypes for helper functions called from eBPF programs */
 -extern const struct bpf_func_proto bpf_map_lookup_elem_proto;
 -extern const struct bpf_func_proto bpf_map_update_elem_proto;
 -extern const struct bpf_func_proto bpf_map_delete_elem_proto;
 -
 -extern const struct bpf_func_proto bpf_get_prandom_u32_proto;
 -extern const struct bpf_func_proto bpf_get_smp_processor_id_proto;
 -extern const struct bpf_func_proto bpf_get_numa_node_id_proto;
 -extern const struct bpf_func_proto bpf_tail_call_proto;
 -extern const struct bpf_func_proto bpf_ktime_get_ns_proto;
 -extern const struct bpf_func_proto bpf_get_current_pid_tgid_proto;
 -extern const struct bpf_func_proto bpf_get_current_uid_gid_proto;
 -extern const struct bpf_func_proto bpf_get_current_comm_proto;
 -extern const struct bpf_func_proto bpf_skb_vlan_push_proto;
 -extern const struct bpf_func_proto bpf_skb_vlan_pop_proto;
 -extern const struct bpf_func_proto bpf_get_stackid_proto;
 -extern const struct bpf_func_proto bpf_sock_map_update_proto;
 -
 -/* Shared helpers among cBPF and eBPF. */
 -void bpf_user_rnd_init_once(void);
 -u64 bpf_user_rnd_u32(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5);
 -
 -#if defined(__KERNEL__) && !defined(__ASSEMBLY__)
 -#ifdef CONFIG_BPF_KPROBE_OVERRIDE
 -#define BPF_ALLOW_ERROR_INJECTION(fname)				\
 -static unsigned long __used						\
 -	__attribute__((__section__("_kprobe_error_inject_list")))	\
 -	_eil_addr_##fname = (unsigned long)fname;
 -#else
 -#define BPF_ALLOW_ERROR_INJECTION(fname)
 -#endif
 -#endif
 -
  #endif /* _LINUX_BPF_H */
diff --cc include/linux/filter.h
index d322ed880333,e872b4ebaa57..000000000000
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@@ -21,23 -445,56 +21,71 @@@ struct compat_sock_fprog 
  };
  #endif
  
 -struct sock_fprog_kern {
 -	u16			len;
 -	struct sock_filter	*filter;
 +struct sk_buff;
 +struct sock;
 +struct bpf_prog_aux;
 +
 +struct bpf_prog
 +{
 +	struct bpf_prog_aux	*aux;	/* Auxiliary fields */
  };
  
++<<<<<<< HEAD
 +struct sk_filter
 +{
 +	atomic_t		refcnt;
 +	unsigned int         	len;	/* Number of filter blocks */
 +	unsigned int		(*bpf_func)(const struct sk_buff *skb,
 +					    const struct sock_filter *filter);
 +	struct rcu_head		rcu;
 +	struct sock_filter     	insns[0];
++=======
+ struct bpf_binary_header {
+ 	unsigned int pages;
+ 	u8 image[];
+ };
+ 
+ struct bpf_prog {
+ 	u16			pages;		/* Number of allocated pages */
+ 	u16			jited:1,	/* Is our filter JIT'ed? */
+ 				jit_requested:1,/* archs need to JIT the prog */
+ 				locked:1,	/* Program image locked? */
+ 				gpl_compatible:1, /* Is filter GPL compatible? */
+ 				cb_access:1,	/* Is control block accessed? */
+ 				dst_needed:1,	/* Do we need dst entry? */
+ 				blinded:1,	/* Was blinded */
+ 				is_func:1,	/* program is a bpf function */
+ 				kprobe_override:1; /* Do we override a kprobe? */
+ 	enum bpf_prog_type	type;		/* Type of BPF program */
+ 	u32			len;		/* Number of filter blocks */
+ 	u32			jited_len;	/* Size of jited insns in bytes */
+ 	u8			tag[BPF_TAG_SIZE];
+ 	struct bpf_prog_aux	*aux;		/* Auxiliary fields */
+ 	struct sock_fprog_kern	*orig_prog;	/* Original BPF program */
+ 	unsigned int		(*bpf_func)(const void *ctx,
+ 					    const struct bpf_insn *insn);
+ 	/* Instructions for interpreter */
+ 	union {
+ 		struct sock_filter	insns[0];
+ 		struct bpf_insn		insnsi[0];
+ 	};
+ };
+ 
+ struct sk_filter {
+ 	refcount_t	refcnt;
+ 	struct rcu_head	rcu;
+ 	struct bpf_prog	*prog;
+ };
+ 
+ #define BPF_PROG_RUN(filter, ctx)  (*(filter)->bpf_func)(ctx, (filter)->insnsi)
+ 
+ #define BPF_SKB_CB_LEN QDISC_CB_PRIV_LEN
+ 
+ struct bpf_skb_data_end {
+ 	struct qdisc_skb_cb qdisc_cb;
+ 	void *data_meta;
+ 	void *data_end;
++>>>>>>> 1c2a088a6626 (bpf: x64: add JIT support for multi-function programs)
  };
  
  struct xdp_buff {
* Unmerged path include/linux/bpf_verifier.h
* Unmerged path kernel/bpf/core.c
* Unmerged path kernel/bpf/syscall.c
* Unmerged path kernel/bpf/verifier.c
* Unmerged path arch/x86/net/bpf_jit_comp.c
* Unmerged path include/linux/bpf.h
* Unmerged path include/linux/bpf_verifier.h
* Unmerged path include/linux/filter.h
* Unmerged path kernel/bpf/core.c
* Unmerged path kernel/bpf/syscall.c
* Unmerged path kernel/bpf/verifier.c
