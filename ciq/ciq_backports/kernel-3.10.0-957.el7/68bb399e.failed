sfc: use flow dissector helpers for aRFS

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Edward Cree <ecree@solarflare.com>
commit 68bb399e656f244d3d173a20a8280c167632fca8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/68bb399e.failed

	Signed-off-by: Edward Cree <ecree@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 68bb399e656f244d3d173a20a8280c167632fca8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/rx.c
diff --cc drivers/net/ethernet/sfc/rx.c
index 90c85f16047f,9d6cc8b92ba0..000000000000
--- a/drivers/net/ethernet/sfc/rx.c
+++ b/drivers/net/ethernet/sfc/rx.c
@@@ -833,33 -842,15 +833,35 @@@ int efx_filter_rfs(struct net_device *n
  	struct efx_nic *efx = netdev_priv(net_dev);
  	struct efx_channel *channel;
  	struct efx_filter_spec spec;
- 	const __be16 *ports;
- 	__be16 ether_type;
- 	int nhoff;
+ 	struct flow_keys fk;
  	int rc;
  
- 	/* The core RPS/RFS code has already parsed and validated
- 	 * VLAN, IP and transport headers.  We assume they are in the
- 	 * header area.
- 	 */
+ 	if (!skb_flow_dissect_flow_keys(skb, &fk, 0))
+ 		return -EPROTONOSUPPORT;
  
++<<<<<<< HEAD
 +	if (skb->protocol == htons(ETH_P_8021Q)) {
 +		const struct vlan_hdr *vh =
 +			(const struct vlan_hdr *)skb->data;
 +
 +		/* We can't filter on the IP 5-tuple and the vlan
 +		 * together, so just strip the vlan header and filter
 +		 * on the IP part.
 +		 */
 +		EFX_WARN_ON_ONCE_PARANOID(skb_headlen(skb) < sizeof(*vh));
 +		ether_type = vh->h_vlan_encapsulated_proto;
 +		nhoff = sizeof(struct vlan_hdr);
 +	} else {
 +		ether_type = skb->protocol;
 +		nhoff = 0;
 +	}
 +
 +	if (ether_type != htons(ETH_P_IP) && ether_type != htons(ETH_P_IPV6))
++=======
+ 	if (fk.basic.n_proto != htons(ETH_P_IP) && fk.basic.n_proto != htons(ETH_P_IPV6))
+ 		return -EPROTONOSUPPORT;
+ 	if (fk.control.flags & FLOW_DIS_IS_FRAGMENT)
++>>>>>>> 68bb399e656f (sfc: use flow dissector helpers for aRFS)
  		return -EPROTONOSUPPORT;
  
  	efx_filter_init_rx(&spec, EFX_FILTER_PRI_HINT,
@@@ -869,34 -860,19 +871,44 @@@
  		EFX_FILTER_MATCH_ETHER_TYPE | EFX_FILTER_MATCH_IP_PROTO |
  		EFX_FILTER_MATCH_LOC_HOST | EFX_FILTER_MATCH_LOC_PORT |
  		EFX_FILTER_MATCH_REM_HOST | EFX_FILTER_MATCH_REM_PORT;
- 	spec.ether_type = ether_type;
+ 	spec.ether_type = fk.basic.n_proto;
+ 	spec.ip_proto = fk.basic.ip_proto;
  
++<<<<<<< HEAD
 +	if (ether_type == htons(ETH_P_IP)) {
 +		const struct iphdr *ip =
 +			(const struct iphdr *)(skb->data + nhoff);
 +
 +		EFX_WARN_ON_ONCE_PARANOID(skb_headlen(skb) < nhoff + sizeof(*ip));
 +		if (ip_is_fragment(ip))
 +			return -EPROTONOSUPPORT;
 +		spec.ip_proto = ip->protocol;
 +		spec.rem_host[0] = ip->saddr;
 +		spec.loc_host[0] = ip->daddr;
 +		EFX_WARN_ON_ONCE_PARANOID(skb_headlen(skb) < nhoff + 4 * ip->ihl + 4);
 +		ports = (const __be16 *)(skb->data + nhoff + 4 * ip->ihl);
 +	} else {
 +		const struct ipv6hdr *ip6 =
 +			(const struct ipv6hdr *)(skb->data + nhoff);
 +
 +		EFX_WARN_ON_ONCE_PARANOID(skb_headlen(skb) <
 +					  nhoff + sizeof(*ip6) + 4);
 +		spec.ip_proto = ip6->nexthdr;
 +		memcpy(spec.rem_host, &ip6->saddr, sizeof(ip6->saddr));
 +		memcpy(spec.loc_host, &ip6->daddr, sizeof(ip6->daddr));
 +		ports = (const __be16 *)(ip6 + 1);
++=======
+ 	if (fk.basic.n_proto == htons(ETH_P_IP)) {
+ 		spec.rem_host[0] = fk.addrs.v4addrs.src;
+ 		spec.loc_host[0] = fk.addrs.v4addrs.dst;
+ 	} else {
+ 		memcpy(spec.rem_host, &fk.addrs.v6addrs.src, sizeof(struct in6_addr));
+ 		memcpy(spec.loc_host, &fk.addrs.v6addrs.dst, sizeof(struct in6_addr));
++>>>>>>> 68bb399e656f (sfc: use flow dissector helpers for aRFS)
  	}
  
- 	spec.rem_port = ports[0];
- 	spec.loc_port = ports[1];
+ 	spec.rem_port = fk.ports.src;
+ 	spec.loc_port = fk.ports.dst;
  
  	rc = efx->type->filter_rfs_insert(efx, &spec);
  	if (rc < 0)
* Unmerged path drivers/net/ethernet/sfc/rx.c
