cachefiles: Fix missing clear of the CACHEFILES_OBJECT_ACTIVE flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Kiran Kumar Modukuri <kiran.modukuri@gmail.com>
commit 5ce83d4bb7d8e11e8c1c687d09f4b5ae67ef3ce3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5ce83d4b.failed

In cachefiles_mark_object_active(), the new object is marked active and
then we try to add it to the active object tree.  If a conflicting object
is already present, we want to wait for that to go away.  After the wait,
we go round again and try to re-mark the object as being active - but it's
already marked active from the first time we went through and a BUG is
issued.

Fix this by clearing the CACHEFILES_OBJECT_ACTIVE flag before we try again.

Analysis from Kiran Kumar Modukuri:

[Impact]
Oops during heavy NFS + FSCache + Cachefiles

CacheFiles: Error: Overlong wait for old active object to go away.

BUG: unable to handle kernel NULL pointer dereference at 0000000000000002

CacheFiles: Error: Object already active kernel BUG at
fs/cachefiles/namei.c:163!

[Cause]
In a heavily loaded system with big files being read and truncated, an
fscache object for a cookie is being dropped and a new object being
looked. The new object being looked for has to wait for the old object
to go away before the new object is moved to active state.

[Fix]
Clear the flag 'CACHEFILES_OBJECT_ACTIVE' for the new object when
retrying the object lookup.

[Testcase]
Have run ~100 hours of NFS stress tests and have not seen this bug recur.

[Regression Potential]
 - Limited to fscache/cachefiles.

Fixes: 9ae326a69004 ("CacheFiles: A cache that backs onto a mounted filesystem")
	Signed-off-by: Kiran Kumar Modukuri <kiran.modukuri@gmail.com>
	Signed-off-by: David Howells <dhowells@redhat.com>
(cherry picked from commit 5ce83d4bb7d8e11e8c1c687d09f4b5ae67ef3ce3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cachefiles/namei.c
diff --cc fs/cachefiles/namei.c
index 295429faa0d6,b5d6dd72dfa0..000000000000
--- a/fs/cachefiles/namei.c
+++ b/fs/cachefiles/namei.c
@@@ -191,6 -185,9 +191,12 @@@ try_again
  	/* an old object from a previous incarnation is hogging the slot - we
  	 * need to wait for it to be destroyed */
  wait_for_old_object:
++<<<<<<< HEAD
++=======
+ 	trace_cachefiles_wait_active(object, dentry, xobject);
+ 	clear_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags);
+ 
++>>>>>>> 5ce83d4bb7d8 (cachefiles: Fix missing clear of the CACHEFILES_OBJECT_ACTIVE flag)
  	if (fscache_object_is_live(&xobject->fscache)) {
  		pr_err("\n");
  		pr_err("Error: Unexpected object collision\n");
@@@ -252,8 -249,7 +258,12 @@@
  	goto try_again;
  
  requeue:
++<<<<<<< HEAD
 +	clear_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags);
 +	cache->cache.ops->put_object(&xobject->fscache);
++=======
+ 	cache->cache.ops->put_object(&xobject->fscache, cachefiles_obj_put_wait_timeo);
++>>>>>>> 5ce83d4bb7d8 (cachefiles: Fix missing clear of the CACHEFILES_OBJECT_ACTIVE flag)
  	_leave(" = -ETIMEDOUT");
  	return -ETIMEDOUT;
  }
* Unmerged path fs/cachefiles/namei.c
