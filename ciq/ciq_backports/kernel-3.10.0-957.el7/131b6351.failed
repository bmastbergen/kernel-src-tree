seccomp: Clean up core dump logic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Kees Cook <keescook@chromium.org>
commit 131b63515932d18a3b1a60db3958f3c0dd5462bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/131b6351.failed

This just cleans up the core dumping logic to avoid the braces around
the RET_KILL case.

	Signed-off-by: Kees Cook <keescook@chromium.org>
(cherry picked from commit 131b63515932d18a3b1a60db3958f3c0dd5462bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/seccomp.c
diff --cc kernel/seccomp.c
index 42e55449c1a5,fce83885b7ef..000000000000
--- a/kernel/seccomp.c
+++ b/kernel/seccomp.c
@@@ -570,70 -574,120 +570,182 @@@ int __secure_computing(int this_syscall
  	 */
  	rmb();
  
++<<<<<<< HEAD
 +	switch (current->seccomp.mode) {
++=======
+ 	filter_ret = seccomp_run_filters(sd);
+ 	data = filter_ret & SECCOMP_RET_DATA;
+ 	action = filter_ret & SECCOMP_RET_ACTION;
+ 
+ 	switch (action) {
+ 	case SECCOMP_RET_ERRNO:
+ 		/* Set low-order bits as an errno, capped at MAX_ERRNO. */
+ 		if (data > MAX_ERRNO)
+ 			data = MAX_ERRNO;
+ 		syscall_set_return_value(current, task_pt_regs(current),
+ 					 -data, 0);
+ 		goto skip;
+ 
+ 	case SECCOMP_RET_TRAP:
+ 		/* Show the handler the original registers. */
+ 		syscall_rollback(current, task_pt_regs(current));
+ 		/* Let the filter pass back 16 bits of data. */
+ 		seccomp_send_sigsys(this_syscall, data);
+ 		goto skip;
+ 
+ 	case SECCOMP_RET_TRACE:
+ 		/* We've been put in this state by the ptracer already. */
+ 		if (recheck_after_trace)
+ 			return 0;
+ 
+ 		/* ENOSYS these calls if there is no tracer attached. */
+ 		if (!ptrace_event_enabled(current, PTRACE_EVENT_SECCOMP)) {
+ 			syscall_set_return_value(current,
+ 						 task_pt_regs(current),
+ 						 -ENOSYS, 0);
+ 			goto skip;
+ 		}
+ 
+ 		/* Allow the BPF to provide the event message */
+ 		ptrace_event(PTRACE_EVENT_SECCOMP, data);
+ 		/*
+ 		 * The delivery of a fatal signal during event
+ 		 * notification may silently skip tracer notification,
+ 		 * which could leave us with a potentially unmodified
+ 		 * syscall that the tracer would have liked to have
+ 		 * changed. Since the process is about to die, we just
+ 		 * force the syscall to be skipped and let the signal
+ 		 * kill the process and correctly handle any tracer exit
+ 		 * notifications.
+ 		 */
+ 		if (fatal_signal_pending(current))
+ 			goto skip;
+ 		/* Check if the tracer forced the syscall to be skipped. */
+ 		this_syscall = syscall_get_nr(current, task_pt_regs(current));
+ 		if (this_syscall < 0)
+ 			goto skip;
+ 
+ 		/*
+ 		 * Recheck the syscall, since it may have changed. This
+ 		 * intentionally uses a NULL struct seccomp_data to force
+ 		 * a reload of all registers. This does not goto skip since
+ 		 * a skip would have already been reported.
+ 		 */
+ 		if (__seccomp_filter(this_syscall, NULL, true))
+ 			return -1;
+ 
+ 		return 0;
+ 
+ 	case SECCOMP_RET_ALLOW:
+ 		return 0;
+ 
+ 	case SECCOMP_RET_KILL:
+ 	default:
+ 		audit_seccomp(this_syscall, SIGSYS, action);
+ 		/* Dump core only if this is the last remaining thread. */
+ 		if (get_nr_threads(current) == 1) {
+ 			siginfo_t info;
+ 
+ 			/* Show the original registers in the dump. */
+ 			syscall_rollback(current, task_pt_regs(current));
+ 			/* Trigger a manual coredump since do_exit skips it. */
+ 			seccomp_init_siginfo(&info, this_syscall, data);
+ 			do_coredump(&info);
+ 		}
+ 		do_exit(SIGSYS);
+ 	}
+ 
+ 	unreachable();
+ 
+ skip:
+ 	audit_seccomp(this_syscall, 0, action);
+ 	return -1;
+ }
+ #else
+ static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,
+ 			    const bool recheck_after_trace)
+ {
+ 	BUG();
+ }
+ #endif
+ 
+ int __secure_computing(const struct seccomp_data *sd)
+ {
+ 	int mode = current->seccomp.mode;
+ 	int this_syscall;
+ 
+ 	if (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&
+ 	    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))
+ 		return 0;
+ 
+ 	this_syscall = sd ? sd->nr :
+ 		syscall_get_nr(current, task_pt_regs(current));
+ 
+ 	switch (mode) {
++>>>>>>> 131b63515932 (seccomp: Clean up core dump logic)
  	case SECCOMP_MODE_STRICT:
 -		__secure_computing_strict(this_syscall);  /* may call do_exit */
 -		return 0;
 -	case SECCOMP_MODE_FILTER:
 -		return __seccomp_filter(this_syscall, sd, false);
 +		syscall = mode1_syscalls;
 +#ifdef CONFIG_COMPAT
 +		if (is_compat_task())
 +			syscall = mode1_syscalls_32;
 +#endif
 +		do {
 +			if (*syscall == this_syscall)
 +				return 0;
 +		} while (*++syscall);
 +		exit_sig = SIGKILL;
 +		ret = SECCOMP_RET_KILL;
 +		break;
 +#ifdef CONFIG_SECCOMP_FILTER
 +	case SECCOMP_MODE_FILTER: {
 +		int data;
 +		struct pt_regs *regs = task_pt_regs(current);
 +		ret = seccomp_run_filters(this_syscall);
 +		data = ret & SECCOMP_RET_DATA;
 +		ret &= SECCOMP_RET_ACTION;
 +		switch (ret) {
 +		case SECCOMP_RET_ERRNO:
 +			/* Set the low-order 16-bits as a errno. */
 +			syscall_set_return_value(current, regs,
 +						 -data, 0);
 +			goto skip;
 +		case SECCOMP_RET_TRAP:
 +			/* Show the handler the original registers. */
 +			syscall_rollback(current, regs);
 +			/* Let the filter pass back 16 bits of data. */
 +			seccomp_send_sigsys(this_syscall, data);
 +			goto skip;
 +		case SECCOMP_RET_TRACE:
 +			/* Skip these calls if there is no tracer. */
 +			if (!ptrace_event_enabled(current, PTRACE_EVENT_SECCOMP)) {
 +				syscall_set_return_value(current, regs,
 +							 -ENOSYS, 0);
 +				goto skip;
 +			}
 +			/* Allow the BPF to provide the event message */
 +			ptrace_event(PTRACE_EVENT_SECCOMP, data);
 +			/*
 +			 * The delivery of a fatal signal during event
 +			 * notification may silently skip tracer notification.
 +			 * Terminating the task now avoids executing a system
 +			 * call that may not be intended.
 +			 */
 +			if (fatal_signal_pending(current))
 +				break;
 +			if (syscall_get_nr(current, regs) < 0)
 +				goto skip;  /* Explicit request to skip. */
 +
 +			return 0;
 +		case SECCOMP_RET_ALLOW:
 +			return 0;
 +		case SECCOMP_RET_KILL:
 +		default:
 +			break;
 +		}
 +		exit_sig = SIGSYS;
 +		break;
 +	}
 +#endif
  	default:
  		BUG();
  	}
* Unmerged path kernel/seccomp.c
