net: ipv6: Do not keep IPv6 addresses when IPv6 is disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] ipv6: Do not keep IPv6 addresses when IPv6 is disabled (Ivan Vecera) [1500871]
Rebuild_FUZZ: 95.58%
commit-author Mike Manning <mmanning@brocade.com>
commit bc561632dddd5af0c4444d919f01cbf6d553aa0a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/bc561632.failed

If IPv6 is disabled when the option is set to keep IPv6
addresses on link down, userspace is unaware of this as
there is no such indication via netlink. The solution is to
remove the IPv6 addresses in this case, which results in
netlink messages indicating removal of addresses in the
usual manner. This fix also makes the behavior consistent
with the case of having IPv6 disabled first, which stops
IPv6 addresses from being added.

Fixes: f1705ec197e7 ("net: ipv6: Make address flushing on ifdown optional")
	Signed-off-by: Mike Manning <mmanning@brocade.com>
	Acked-by: David Ahern <dsa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bc561632dddd5af0c4444d919f01cbf6d553aa0a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/addrconf.c
diff --cc net/ipv6/addrconf.c
index 836f13f8d356,df8425fcbc2c..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -3286,6 -3535,16 +3286,19 @@@ static int addrconf_ifdown(struct net_d
  
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* aggregate the system setting and interface setting */
+ 	_keep_addr = net->ipv6.devconf_all->keep_addr_on_down;
+ 	if (!_keep_addr)
+ 		_keep_addr = idev->cnf.keep_addr_on_down;
+ 
+ 	/* combine the user config with event to determine if permanent
+ 	 * addresses are to be removed from address hash table
+ 	 */
+ 	keep_addr = !(how || _keep_addr <= 0 || idev->cnf.disable_ipv6);
+ 
++>>>>>>> bc561632dddd (net: ipv6: Do not keep IPv6 addresses when IPv6 is disabled)
  	/* Step 2: clear hash table */
  	for (i = 0; i < IN6_ADDR_HSIZE; i++) {
  		struct hlist_head *h = &inet6_addr_lst[i];
@@@ -3330,20 -3596,42 +3343,32 @@@
  		write_lock_bh(&idev->lock);
  	}
  
++<<<<<<< HEAD
 +	while (!list_empty(&idev->addr_list)) {
 +		ifa = list_first_entry(&idev->addr_list,
 +				       struct inet6_ifaddr, if_list);
++=======
+ 	/* re-combine the user config with event to determine if permanent
+ 	 * addresses are to be removed from the interface list
+ 	 */
+ 	keep_addr = (!how && _keep_addr > 0 && !idev->cnf.disable_ipv6);
+ 
+ 	INIT_LIST_HEAD(&del_list);
+ 	list_for_each_entry_safe(ifa, tmp, &idev->addr_list, if_list) {
+ 		struct rt6_info *rt = NULL;
+ 
++>>>>>>> bc561632dddd (net: ipv6: Do not keep IPv6 addresses when IPv6 is disabled)
  		addrconf_del_dad_work(ifa);
  
 -		write_unlock_bh(&idev->lock);
 -		spin_lock_bh(&ifa->lock);
 -
 -		if (keep_addr && (ifa->flags & IFA_F_PERMANENT) &&
 -		    !addr_is_local(&ifa->addr)) {
 -			/* set state to skip the notifier below */
 -			state = INET6_IFADDR_STATE_DEAD;
 -			ifa->state = 0;
 -			if (!(ifa->flags & IFA_F_NODAD))
 -				ifa->flags |= IFA_F_TENTATIVE;
 -
 -			rt = ifa->rt;
 -			ifa->rt = NULL;
 -		} else {
 -			state = ifa->state;
 -			ifa->state = INET6_IFADDR_STATE_DEAD;
 +		list_del(&ifa->if_list);
  
 -			list_move(&ifa->if_list, &del_list);
 -		}
 +		write_unlock_bh(&idev->lock);
  
 +		spin_lock_bh(&ifa->lock);
 +		state = ifa->state;
 +		ifa->state = INET6_IFADDR_STATE_DEAD;
  		spin_unlock_bh(&ifa->lock);
  
 -		if (rt)
 -			ip6_del_rt(rt);
 -
  		if (state != INET6_IFADDR_STATE_DEAD) {
  			__ipv6_ifa_notify(RTM_DELADDR, ifa);
  			inet6addr_notifier_call_chain(NETDEV_DOWN, ifa);
* Unmerged path net/ipv6/addrconf.c
