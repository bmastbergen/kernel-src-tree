net: aquantia: make symbol hw_atl_boards static

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] aquantia: make symbol hw_atl_boards static (David Arcari) [1546765]
Rebuild_FUZZ: 94.38%
commit-author Wei Yongjun <weiyongjun1@huawei.com>
commit e8a22b5f079449f1803d37ce2b5d09acaa68368d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/e8a22b5f.failed

Fixes the following sparse warning:

drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c:50:34: warning:
 symbol 'hw_atl_boards' was not declared. Should it be static?

Fixes: 4948293ff963 ("net: aquantia: Introduce new AQC devices and capabilities")
	Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
	Acked-by: Igor Russkikh <igor.russkikh@aquantia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e8a22b5f079449f1803d37ce2b5d09acaa68368d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
index 667e08a571a5,22889fc158f2..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
@@@ -13,100 -16,109 +13,139 @@@
  #include "aq_nic.h"
  #include "aq_vec.h"
  #include "aq_hw.h"
 -#include "aq_pci_func.h"
 -#include "hw_atl/hw_atl_a0.h"
 -#include "hw_atl/hw_atl_b0.h"
 -
 -static const struct pci_device_id aq_pci_tbl[] = {
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_0001), },
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_D100), },
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_D107), },
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_D108), },
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_D109), },
 -
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC100), },
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC107), },
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC108), },
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC109), },
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC111), },
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC112), },
 -
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC100S), },
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC107S), },
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC108S), },
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC109S), },
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC111S), },
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC112S), },
 -
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC111E), },
 -	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC112E), },
 -
 -	{}
 +#include <linux/interrupt.h>
 +
 +struct aq_pci_func_s {
 +	struct pci_dev *pdev;
 +	struct aq_nic_s *port[AQ_CFG_PCI_FUNC_PORTS];
 +	void __iomem *mmio;
 +	void *aq_vec[AQ_CFG_PCI_FUNC_MSIX_IRQS];
 +	resource_size_t mmio_pa;
 +	unsigned int msix_entry_mask;
 +	unsigned int irq_type;
 +	unsigned int ports;
 +	bool is_pci_enabled;
 +	bool is_regions;
 +	bool is_pci_using_dac;
 +	struct aq_hw_caps_s aq_hw_caps;
 +	struct msix_entry msix_entry[AQ_CFG_PCI_FUNC_MSIX_IRQS];
  };
  
++<<<<<<< HEAD
 +struct aq_pci_func_s *aq_pci_func_alloc(const struct aq_hw_ops *aq_hw_ops,
 +					struct pci_dev *pdev,
 +					const struct net_device_ops *ndev_ops,
 +					const struct ethtool_ops *eth_ops)
++=======
+ static const struct aq_board_revision_s hw_atl_boards[] = {
+ 	{ AQ_DEVICE_ID_0001,	AQ_HWREV_1,	&hw_atl_ops_a0, &hw_atl_a0_caps_aqc107, },
+ 	{ AQ_DEVICE_ID_D100,	AQ_HWREV_1,	&hw_atl_ops_a0, &hw_atl_a0_caps_aqc100, },
+ 	{ AQ_DEVICE_ID_D107,	AQ_HWREV_1,	&hw_atl_ops_a0, &hw_atl_a0_caps_aqc107, },
+ 	{ AQ_DEVICE_ID_D108,	AQ_HWREV_1,	&hw_atl_ops_a0, &hw_atl_a0_caps_aqc108, },
+ 	{ AQ_DEVICE_ID_D109,	AQ_HWREV_1,	&hw_atl_ops_a0, &hw_atl_a0_caps_aqc109, },
+ 
+ 	{ AQ_DEVICE_ID_0001,	AQ_HWREV_2,	&hw_atl_ops_b0, &hw_atl_b0_caps_aqc107, },
+ 	{ AQ_DEVICE_ID_D100,	AQ_HWREV_2,	&hw_atl_ops_b0, &hw_atl_b0_caps_aqc100, },
+ 	{ AQ_DEVICE_ID_D107,	AQ_HWREV_2,	&hw_atl_ops_b0, &hw_atl_b0_caps_aqc107, },
+ 	{ AQ_DEVICE_ID_D108,	AQ_HWREV_2,	&hw_atl_ops_b0, &hw_atl_b0_caps_aqc108, },
+ 	{ AQ_DEVICE_ID_D109,	AQ_HWREV_2,	&hw_atl_ops_b0, &hw_atl_b0_caps_aqc109, },
+ 
+ 	{ AQ_DEVICE_ID_AQC100,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc107, },
+ 	{ AQ_DEVICE_ID_AQC107,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc107, },
+ 	{ AQ_DEVICE_ID_AQC108,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc108, },
+ 	{ AQ_DEVICE_ID_AQC109,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc109, },
+ 	{ AQ_DEVICE_ID_AQC111,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc111, },
+ 	{ AQ_DEVICE_ID_AQC112,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc112, },
+ 
+ 	{ AQ_DEVICE_ID_AQC100S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc100s, },
+ 	{ AQ_DEVICE_ID_AQC107S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc107s, },
+ 	{ AQ_DEVICE_ID_AQC108S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc108s, },
+ 	{ AQ_DEVICE_ID_AQC109S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc109s, },
+ 	{ AQ_DEVICE_ID_AQC111S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc111s, },
+ 	{ AQ_DEVICE_ID_AQC112S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc112s, },
+ 
+ 	{ AQ_DEVICE_ID_AQC111E,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc111e, },
+ 	{ AQ_DEVICE_ID_AQC112E,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc112e, },
+ };
+ 
+ MODULE_DEVICE_TABLE(pci, aq_pci_tbl);
+ 
+ static int aq_pci_probe_get_hw_by_id(struct pci_dev *pdev,
+ 				     const struct aq_hw_ops **ops,
+ 				     const struct aq_hw_caps_s **caps)
++>>>>>>> e8a22b5f0794 (net: aquantia: make symbol hw_atl_boards static)
  {
 -	int i = 0;
 +	struct aq_pci_func_s *self = NULL;
 +	int err = 0;
 +	unsigned int port = 0U;
  
 -	if (pdev->vendor != PCI_VENDOR_ID_AQUANTIA)
 -		return -EINVAL;
 +	if (!aq_hw_ops) {
 +		err = -EFAULT;
 +		goto err_exit;
 +	}
 +	self = kzalloc(sizeof(*self), GFP_KERNEL);
 +	if (!self) {
 +		err = -ENOMEM;
 +		goto err_exit;
 +	}
  
 -	for (i = 0; i < ARRAY_SIZE(hw_atl_boards); i++) {
 -		if (hw_atl_boards[i].devid == pdev->device &&
 -		    (hw_atl_boards[i].revision == AQ_HWREV_ANY ||
 -		     hw_atl_boards[i].revision == pdev->revision)) {
 -			*ops = hw_atl_boards[i].ops;
 -			*caps = hw_atl_boards[i].caps;
 -			break;
 +	pci_set_drvdata(pdev, self);
 +	self->pdev = pdev;
 +
 +	err = aq_hw_ops->get_hw_caps(NULL, &self->aq_hw_caps, pdev->device,
 +				     pdev->subsystem_device);
 +	if (err < 0)
 +		goto err_exit;
 +
 +	self->ports = self->aq_hw_caps.ports;
 +
 +	for (port = 0; port < self->ports; ++port) {
 +		struct aq_nic_s *aq_nic = aq_nic_alloc_cold(ndev_ops, eth_ops,
 +							    pdev, self,
 +							    port, aq_hw_ops);
 +
 +		if (!aq_nic) {
 +			err = -ENOMEM;
 +			goto err_exit;
  		}
 +		self->port[port] = aq_nic;
  	}
  
 -	if (i == ARRAY_SIZE(hw_atl_boards))
 -		return -EINVAL;
 +err_exit:
 +	if (err < 0) {
 +		if (self)
 +			aq_pci_func_free(self);
 +		self = NULL;
 +	}
  
 -	return 0;
 +	(void)err;
 +	return self;
  }
  
 -int aq_pci_func_init(struct pci_dev *pdev)
 +int aq_pci_func_init(struct aq_pci_func_s *self)
  {
  	int err = 0;
 +	unsigned int bar = 0U;
 +	unsigned int port = 0U;
 +	unsigned int i = 0U;
  
 -	err = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));
 -	if (!err) {
 -		err = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));
 +	err = pci_enable_device(self->pdev);
 +	if (err < 0)
 +		goto err_exit;
  
 +	self->is_pci_enabled = true;
 +
 +	err = pci_set_dma_mask(self->pdev, DMA_BIT_MASK(64));
 +	if (!err) {
 +		err = pci_set_consistent_dma_mask(self->pdev, DMA_BIT_MASK(64));
 +		self->is_pci_using_dac = 1;
  	}
  	if (err) {
 -		err = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
 +		err = pci_set_dma_mask(self->pdev, DMA_BIT_MASK(32));
  		if (!err)
 -			err = pci_set_consistent_dma_mask(pdev,
 +			err = pci_set_consistent_dma_mask(self->pdev,
  							  DMA_BIT_MASK(32));
 +		self->is_pci_using_dac = 0;
  	}
  	if (err != 0) {
  		err = -ENOSR;
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
