block: pass in queue to inflight accounting

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [block] pass in queue to inflight accounting (Ming Lei) [1548261]
Rebuild_FUZZ: 91.14%
commit-author Jens Axboe <axboe@kernel.dk>
commit d62e26b3ffd28f16ddae85a1babd0303a1a6dfb6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d62e26b3.failed

No functional change in this patch, just in preparation for
basing the inflight mechanism on the queue in question.

	Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
	Reviewed-by: Omar Sandoval <osandov@fb.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit d62e26b3ffd28f16ddae85a1babd0303a1a6dfb6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/drbd/drbd_req.c
#	drivers/block/rsxx/dev.c
#	drivers/block/zram/zram_drv.c
#	drivers/md/bcache/request.c
#	drivers/md/dm.c
diff --cc drivers/block/drbd/drbd_req.c
index a6f13f7cee8f,8d6b5d137b5e..000000000000
--- a/drivers/block/drbd/drbd_req.c
+++ b/drivers/block/drbd/drbd_req.c
@@@ -31,38 -31,27 +31,52 @@@
  #include "drbd_req.h"
  
  
 -static bool drbd_may_do_local_read(struct drbd_device *device, sector_t sector, int size);
 +static bool drbd_may_do_local_read(struct drbd_conf *mdev, sector_t sector, int size);
  
  /* Update disk stats at start of I/O request */
 -static void _drbd_start_io_acct(struct drbd_device *device, struct drbd_request *req)
 +static void _drbd_start_io_acct(struct drbd_conf *mdev, struct drbd_request *req)
  {
++<<<<<<< HEAD
 +	const int rw = bio_data_dir(req->master_bio);
 +	int cpu;
 +	cpu = part_stat_lock();
 +	part_round_stats(cpu, &mdev->vdisk->part0);
 +	part_stat_inc(cpu, &mdev->vdisk->part0, ios[rw]);
 +	part_stat_add(cpu, &mdev->vdisk->part0, sectors[rw], req->i.size >> 9);
 +	(void) cpu; /* The macro invocations above want the cpu argument, I do not like
 +		       the compiler warning about cpu only assigned but never used... */
 +	part_inc_in_flight(&mdev->vdisk->part0, rw);
 +	part_stat_unlock();
++=======
+ 	struct request_queue *q = device->rq_queue;
+ 
+ 	generic_start_io_acct(q, bio_data_dir(req->master_bio),
+ 				req->i.size >> 9, &device->vdisk->part0);
++>>>>>>> d62e26b3ffd2 (block: pass in queue to inflight accounting)
  }
  
  /* Update disk stats when completing request upwards */
 -static void _drbd_end_io_acct(struct drbd_device *device, struct drbd_request *req)
 +static void _drbd_end_io_acct(struct drbd_conf *mdev, struct drbd_request *req)
  {
++<<<<<<< HEAD
 +	int rw = bio_data_dir(req->master_bio);
 +	unsigned long duration = jiffies - req->start_time;
 +	int cpu;
 +	cpu = part_stat_lock();
 +	part_stat_add(cpu, &mdev->vdisk->part0, ticks[rw], duration);
 +	part_round_stats(cpu, &mdev->vdisk->part0);
 +	part_dec_in_flight(&mdev->vdisk->part0, rw);
 +	part_stat_unlock();
++=======
+ 	struct request_queue *q = device->rq_queue;
+ 
+ 	generic_end_io_acct(q, bio_data_dir(req->master_bio),
+ 			    &device->vdisk->part0, req->start_jif);
++>>>>>>> d62e26b3ffd2 (block: pass in queue to inflight accounting)
  }
  
 -static struct drbd_request *drbd_req_new(struct drbd_device *device, struct bio *bio_src)
 +static struct drbd_request *drbd_req_new(struct drbd_conf *mdev,
 +					       struct bio *bio_src)
  {
  	struct drbd_request *req;
  
diff --cc drivers/block/rsxx/dev.c
index 67dfe37c317e,e397d3ee7308..000000000000
--- a/drivers/block/rsxx/dev.c
+++ b/drivers/block/rsxx/dev.c
@@@ -112,37 -112,16 +112,47 @@@ static const struct block_device_operat
  
  static void disk_stats_start(struct rsxx_cardinfo *card, struct bio *bio)
  {
++<<<<<<< HEAD
 +	struct hd_struct *part0 = &card->gendisk->part0;
 +	int rw = bio_data_dir(bio);
 +	int cpu;
 +
 +	cpu = part_stat_lock();
 +
 +	part_round_stats(cpu, part0);
 +	part_inc_in_flight(part0, rw);
 +
 +	part_stat_unlock();
++=======
+ 	generic_start_io_acct(card->queue, bio_data_dir(bio), bio_sectors(bio),
+ 			     &card->gendisk->part0);
++>>>>>>> d62e26b3ffd2 (block: pass in queue to inflight accounting)
  }
  
  static void disk_stats_complete(struct rsxx_cardinfo *card,
  				struct bio *bio,
  				unsigned long start_time)
  {
++<<<<<<< HEAD
 +	struct hd_struct *part0 = &card->gendisk->part0;
 +	unsigned long duration = jiffies - start_time;
 +	int rw = bio_data_dir(bio);
 +	int cpu;
 +
 +	cpu = part_stat_lock();
 +
 +	part_stat_add(cpu, part0, sectors[rw], bio_sectors(bio));
 +	part_stat_inc(cpu, part0, ios[rw]);
 +	part_stat_add(cpu, part0, ticks[rw], duration);
 +
 +	part_round_stats(cpu, part0);
 +	part_dec_in_flight(part0, rw);
 +
 +	part_stat_unlock();
++=======
+ 	generic_end_io_acct(card->queue, bio_data_dir(bio),
+ 				&card->gendisk->part0, start_time);
++>>>>>>> d62e26b3ffd2 (block: pass in queue to inflight accounting)
  }
  
  static void bio_dma_done_cb(struct rsxx_cardinfo *card,
diff --cc drivers/block/zram/zram_drv.c
index 4987c3f4bb80,1c3383b4a0cf..000000000000
--- a/drivers/block/zram/zram_drv.c
+++ b/drivers/block/zram/zram_drv.c
@@@ -787,20 -809,29 +787,37 @@@ static void zram_bio_discard(struct zra
  }
  
  static int zram_bvec_rw(struct zram *zram, struct bio_vec *bvec, u32 index,
 -			int offset, bool is_write)
 +			int offset, int rw)
  {
++<<<<<<< HEAD
 +	int ret;
 +
 +	if (rw == READ) {
++=======
+ 	unsigned long start_time = jiffies;
+ 	int rw_acct = is_write ? REQ_OP_WRITE : REQ_OP_READ;
+ 	struct request_queue *q = zram->disk->queue;
+ 	int ret;
+ 
+ 	generic_start_io_acct(q, rw_acct, bvec->bv_len >> SECTOR_SHIFT,
+ 			&zram->disk->part0);
+ 
+ 	if (!is_write) {
++>>>>>>> d62e26b3ffd2 (block: pass in queue to inflight accounting)
  		atomic64_inc(&zram->stats.num_reads);
  		ret = zram_bvec_read(zram, bvec, index, offset);
 -		flush_dcache_page(bvec->bv_page);
  	} else {
  		atomic64_inc(&zram->stats.num_writes);
  		ret = zram_bvec_write(zram, bvec, index, offset);
  	}
  
++<<<<<<< HEAD
++=======
+ 	generic_end_io_acct(q, rw_acct, &zram->disk->part0, start_time);
+ 
++>>>>>>> d62e26b3ffd2 (block: pass in queue to inflight accounting)
  	if (unlikely(ret)) {
 -		if (!is_write)
 +		if (rw == READ)
  			atomic64_inc(&zram->stats.failed_reads);
  		else
  			atomic64_inc(&zram->stats.failed_writes);
diff --cc drivers/md/bcache/request.c
index a30a0f8a41c0,72eb97176403..000000000000
--- a/drivers/md/bcache/request.c
+++ b/drivers/md/bcache/request.c
@@@ -668,16 -607,13 +668,22 @@@ void bch_cache_read_endio(struct bio *b
  static void bio_complete(struct search *s)
  {
  	if (s->orig_bio) {
++<<<<<<< HEAD
 +		int cpu, rw = bio_data_dir(s->orig_bio);
 +		unsigned long duration = jiffies - s->start_time;
++=======
+ 		struct request_queue *q = bdev_get_queue(s->orig_bio->bi_bdev);
+ 		generic_end_io_acct(q, bio_data_dir(s->orig_bio),
+ 				    &s->d->disk->part0, s->start_time);
++>>>>>>> d62e26b3ffd2 (block: pass in queue to inflight accounting)
 +
 +		cpu = part_stat_lock();
 +		part_round_stats(cpu, &s->d->disk->part0);
 +		part_stat_add(cpu, &s->d->disk->part0, ticks[rw], duration);
 +		part_stat_unlock();
  
 -		trace_bcache_request_end(s->d, s->orig_bio);
 -		s->orig_bio->bi_status = s->iop.status;
 -		bio_endio(s->orig_bio);
 +		trace_bcache_request_end(s, s->orig_bio);
 +		bio_endio(s->orig_bio, s->error);
  		s->orig_bio = NULL;
  	}
  }
@@@ -1231,15 -958,12 +1237,19 @@@ static void cached_dev_make_request(str
  	struct search *s;
  	struct bcache_device *d = bio->bi_bdev->bd_disk->private_data;
  	struct cached_dev *dc = container_of(d, struct cached_dev, disk);
 -	int rw = bio_data_dir(bio);
 -
 +	int cpu, rw = bio_data_dir(bio);
 +
++<<<<<<< HEAD
 +	cpu = part_stat_lock();
 +	part_stat_inc(cpu, &d->disk->part0, ios[rw]);
 +	part_stat_add(cpu, &d->disk->part0, sectors[rw], bio_sectors(bio));
 +	part_stat_unlock();
++=======
+ 	generic_start_io_acct(q, rw, bio_sectors(bio), &d->disk->part0);
++>>>>>>> d62e26b3ffd2 (block: pass in queue to inflight accounting)
  
  	bio->bi_bdev = dc->bdev;
 -	bio->bi_iter.bi_sector += dc->sb.data_offset;
 +	bio->bi_sector += dc->sb.data_offset;
  
  	if (cached_dev_get(dc)) {
  		s = search_alloc(bio, d);
@@@ -1340,12 -1073,9 +1350,16 @@@ static void flash_dev_make_request(stru
  	struct search *s;
  	struct closure *cl;
  	struct bcache_device *d = bio->bi_bdev->bd_disk->private_data;
 -	int rw = bio_data_dir(bio);
 -
 +	int cpu, rw = bio_data_dir(bio);
 +
++<<<<<<< HEAD
 +	cpu = part_stat_lock();
 +	part_stat_inc(cpu, &d->disk->part0, ios[rw]);
 +	part_stat_add(cpu, &d->disk->part0, sectors[rw], bio_sectors(bio));
 +	part_stat_unlock();
++=======
+ 	generic_start_io_acct(q, rw, bio_sectors(bio), &d->disk->part0);
++>>>>>>> d62e26b3ffd2 (block: pass in queue to inflight accounting)
  
  	s = search_alloc(bio, d);
  	cl = &s->cl;
diff --cc drivers/md/dm.c
index 14d7215727e9,8612a2d1ccd9..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -536,17 -536,15 +536,21 @@@ static void end_io_acct(struct dm_io *i
  	struct mapped_device *md = io->md;
  	struct bio *bio = io->bio;
  	unsigned long duration = jiffies - io->start_time;
 -	int pending;
 +	int pending, cpu;
  	int rw = bio_data_dir(bio);
  
++<<<<<<< HEAD
 +	cpu = part_stat_lock();
 +	part_round_stats(cpu, &dm_disk(md)->part0);
 +	part_stat_add(cpu, &dm_disk(md)->part0, ticks[rw], duration);
 +	part_stat_unlock();
++=======
+ 	generic_end_io_acct(md->queue, rw, &dm_disk(md)->part0, io->start_time);
++>>>>>>> d62e26b3ffd2 (block: pass in queue to inflight accounting)
  
  	if (unlikely(dm_stats_used(&md->stats)))
 -		dm_stats_account_io(&md->stats, bio_data_dir(bio),
 -				    bio->bi_iter.bi_sector, bio_sectors(bio),
 -				    true, duration, &io->stats_aux);
 +		dm_stats_account_io(&md->stats, bio->bi_rw, bio->bi_sector,
 +				    bio_sectors(bio), true, duration, &io->stats_aux);
  
  	/*
  	 * After this is decremented the bio must not be touched if it is
@@@ -1541,10 -1542,7 +1545,14 @@@ static void dm_make_request(struct requ
  
  	map = dm_get_live_table(md, &srcu_idx);
  
++<<<<<<< HEAD
 +	cpu = part_stat_lock();
 +	part_stat_inc(cpu, &dm_disk(md)->part0, ios[rw]);
 +	part_stat_add(cpu, &dm_disk(md)->part0, sectors[rw], bio_sectors(bio));
 +	part_stat_unlock();
++=======
+ 	generic_start_io_acct(q, rw, bio_sectors(bio), &dm_disk(md)->part0);
++>>>>>>> d62e26b3ffd2 (block: pass in queue to inflight accounting)
  
  	/* if we're suspended, we have to queue this io for later */
  	if (unlikely(test_bit(DMF_BLOCK_IO_FOR_SUSPEND, &md->flags))) {
diff --git a/block/blk-core.c b/block/blk-core.c
index cfbd315875ad..32c88449bd57 100644
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -1492,15 +1492,15 @@ static void add_acct_request(struct request_queue *q, struct request *rq,
 	__elv_add_request(q, rq, where);
 }
 
-static void part_round_stats_single(int cpu, struct hd_struct *part,
-				    unsigned long now)
+static void part_round_stats_single(struct request_queue *q, int cpu,
+				    struct hd_struct *part, unsigned long now)
 {
 	int inflight;
 
 	if (now == part->stamp)
 		return;
 
-	inflight = part_in_flight(part);
+	inflight = part_in_flight(q, part);
 	if (inflight) {
 		__part_stat_add(cpu, part, time_in_queue,
 				inflight * (now - part->stamp));
@@ -1511,6 +1511,7 @@ static void part_round_stats_single(int cpu, struct hd_struct *part,
 
 /**
  * part_round_stats() - Round off the performance stats on a struct disk_stats.
+ * @q: target block queue
  * @cpu: cpu number for stats access
  * @part: target partition
  *
@@ -1525,13 +1526,14 @@ static void part_round_stats_single(int cpu, struct hd_struct *part,
  * /proc/diskstats.  This accounts immediately for all queue usage up to
  * the current jiffies and restarts the counters again.
  */
-void part_round_stats(int cpu, struct hd_struct *part)
+void part_round_stats(struct request_queue *q, int cpu, struct hd_struct *part)
 {
 	unsigned long now = jiffies;
 
 	if (part->partno)
-		part_round_stats_single(cpu, &part_to_disk(part)->part0, now);
-	part_round_stats_single(cpu, part, now);
+		part_round_stats_single(q, cpu, &part_to_disk(part)->part0,
+						now);
+	part_round_stats_single(q, cpu, part, now);
 }
 EXPORT_SYMBOL_GPL(part_round_stats);
 
@@ -2428,8 +2430,8 @@ void blk_account_io_done(struct request *req)
 
 		part_stat_inc(cpu, part, ios[rw]);
 		part_stat_add(cpu, part, ticks[rw], duration);
-		part_round_stats(cpu, part);
-		part_dec_in_flight(part, rw);
+		part_round_stats(req->q, cpu, part);
+		part_dec_in_flight(req->q, part, rw);
 
 		hd_struct_put(part);
 		part_stat_unlock();
@@ -2486,8 +2488,8 @@ void blk_account_io_start(struct request *rq, bool new_io)
 			part = &rq->rq_disk->part0;
 			hd_struct_get(part);
 		}
-		part_round_stats(cpu, part);
-		part_inc_in_flight(part, rw);
+		part_round_stats(rq->q, cpu, part);
+		part_inc_in_flight(rq->q, part, rw);
 		rq->part = part;
 	}
 
diff --git a/block/blk-merge.c b/block/blk-merge.c
index 5685db7750c2..d6a7e3aa89f2 100644
--- a/block/blk-merge.c
+++ b/block/blk-merge.c
@@ -419,8 +419,8 @@ static void blk_account_io_merge(struct request *req)
 		cpu = part_stat_lock();
 		part = req->part;
 
-		part_round_stats(cpu, part);
-		part_dec_in_flight(part, rq_data_dir(req));
+		part_round_stats(req->q, cpu, part);
+		part_dec_in_flight(req->q, part, rq_data_dir(req));
 
 		hd_struct_put(part);
 		part_stat_unlock();
diff --git a/block/genhd.c b/block/genhd.c
index efc72b7773e8..281c266015a5 100644
--- a/block/genhd.c
+++ b/block/genhd.c
@@ -1210,7 +1210,7 @@ static int diskstats_show(struct seq_file *seqf, void *v)
 	disk_part_iter_init(&piter, gp, DISK_PITER_INCL_EMPTY_PART0);
 	while ((hd = disk_part_iter_next(&piter))) {
 		cpu = part_stat_lock();
-		part_round_stats(cpu, hd);
+		part_round_stats(gp->queue, cpu, hd);
 		part_stat_unlock();
 		seq_printf(seqf, "%4d %7d %s %lu %lu %lu "
 			   "%u %lu %lu %lu %u %u %u %u\n",
@@ -1224,7 +1224,7 @@ static int diskstats_show(struct seq_file *seqf, void *v)
 			   part_stat_read(hd, merges[WRITE]),
 			   part_stat_read(hd, sectors[WRITE]),
 			   jiffies_to_msecs(part_stat_read(hd, ticks[WRITE])),
-			   part_in_flight(hd),
+			   part_in_flight(gp->queue, hd),
 			   jiffies_to_msecs(part_stat_read(hd, io_ticks)),
 			   jiffies_to_msecs(part_stat_read(hd, time_in_queue))
 			);
diff --git a/block/partition-generic.c b/block/partition-generic.c
index 195b56c1be27..4750c7c41e50 100644
--- a/block/partition-generic.c
+++ b/block/partition-generic.c
@@ -112,10 +112,11 @@ ssize_t part_stat_show(struct device *dev,
 		       struct device_attribute *attr, char *buf)
 {
 	struct hd_struct *p = dev_to_part(dev);
+	struct request_queue *q = dev_to_disk(dev)->queue;
 	int cpu;
 
 	cpu = part_stat_lock();
-	part_round_stats(cpu, p);
+	part_round_stats(q, cpu, p);
 	part_stat_unlock();
 	return sprintf(buf,
 		"%8lu %8lu %8llu %8u "
@@ -130,7 +131,7 @@ ssize_t part_stat_show(struct device *dev,
 		part_stat_read(p, merges[WRITE]),
 		(unsigned long long)part_stat_read(p, sectors[WRITE]),
 		jiffies_to_msecs(part_stat_read(p, ticks[WRITE])),
-		part_in_flight(p),
+		part_in_flight(q, p),
 		jiffies_to_msecs(part_stat_read(p, io_ticks)),
 		jiffies_to_msecs(part_stat_read(p, time_in_queue)));
 }
* Unmerged path drivers/block/drbd/drbd_req.c
* Unmerged path drivers/block/rsxx/dev.c
* Unmerged path drivers/block/zram/zram_drv.c
* Unmerged path drivers/md/bcache/request.c
* Unmerged path drivers/md/dm.c
diff --git a/drivers/nvdimm/nd.h b/drivers/nvdimm/nd.h
index b9ca4d67b0e2..591f8a3612ed 100644
--- a/drivers/nvdimm/nd.h
+++ b/drivers/nvdimm/nd.h
@@ -399,7 +399,7 @@ static inline bool nd_iostat_start(struct bio *bio, unsigned long *start)
 		return false;
 
 	*start = jiffies;
-	generic_start_io_acct(bio_data_dir(bio),
+	generic_start_io_acct(disk->queue, bio_data_dir(bio),
 			      bio_sectors(bio), &disk->part0);
 	return true;
 }
@@ -407,7 +407,8 @@ static inline void nd_iostat_end(struct bio *bio, unsigned long start)
 {
 	struct gendisk *disk = bio->bi_bdev->bd_disk;
 
-	generic_end_io_acct(bio_data_dir(bio), &disk->part0, start);
+	generic_end_io_acct(disk->queue, bio_data_dir(bio), &disk->part0,
+				start);
 }
 static inline bool is_bad_pmem(struct badblocks *bb, sector_t sector,
 		unsigned int len)
diff --git a/fs/bio.c b/fs/bio.c
index c1ee6b70bc1e..2b2ab0e7b375 100644
--- a/fs/bio.c
+++ b/fs/bio.c
@@ -1761,29 +1761,29 @@ void bio_check_pages_dirty(struct bio *bio)
 	}
 }
 
-void generic_start_io_acct(int rw, unsigned long sectors,
-			   struct hd_struct *part)
+void generic_start_io_acct(struct request_queue *q, int rw,
+			   unsigned long sectors, struct hd_struct *part)
 {
 	int cpu = part_stat_lock();
 
-	part_round_stats(cpu, part);
+	part_round_stats(q, cpu, part);
 	part_stat_inc(cpu, part, ios[rw]);
 	part_stat_add(cpu, part, sectors[rw], sectors);
-	part_inc_in_flight(part, rw);
+	part_inc_in_flight(q, part, rw);
 
 	part_stat_unlock();
 }
 EXPORT_SYMBOL(generic_start_io_acct);
 
-void generic_end_io_acct(int rw, struct hd_struct *part,
-			 unsigned long start_time)
+void generic_end_io_acct(struct request_queue *q, int rw,
+			 struct hd_struct *part, unsigned long start_time)
 {
 	unsigned long duration = jiffies - start_time;
 	int cpu = part_stat_lock();
 
 	part_stat_add(cpu, part, ticks[rw], duration);
-	part_round_stats(cpu, part);
-	part_dec_in_flight(part, rw);
+	part_round_stats(q, cpu, part);
+	part_dec_in_flight(q, part, rw);
 
 	part_stat_unlock();
 }
diff --git a/include/linux/bio.h b/include/linux/bio.h
index 34be583f6262..18600752fccb 100644
--- a/include/linux/bio.h
+++ b/include/linux/bio.h
@@ -288,10 +288,11 @@ extern struct bio *bio_copy_kern(struct request_queue *, void *, unsigned int,
 extern void bio_set_pages_dirty(struct bio *bio);
 extern void bio_check_pages_dirty(struct bio *bio);
 
-void generic_start_io_acct(int rw, unsigned long sectors,
-			   struct hd_struct *part);
-void generic_end_io_acct(int rw, struct hd_struct *part,
-			 unsigned long start_time);
+void generic_start_io_acct(struct request_queue *q, int rw,
+				unsigned long sectors, struct hd_struct *part);
+void generic_end_io_acct(struct request_queue *q, int rw,
+				struct hd_struct *part,
+				unsigned long start_time);
 
 #ifndef ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE
 # error	"You should define ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE for your platform"
diff --git a/include/linux/genhd.h b/include/linux/genhd.h
index 4292be9dbdf8..5cb1070efd34 100644
--- a/include/linux/genhd.h
+++ b/include/linux/genhd.h
@@ -382,23 +382,27 @@ static inline void free_part_stats(struct hd_struct *part)
 #define part_stat_sub(cpu, gendiskp, field, subnd)			\
 	part_stat_add(cpu, gendiskp, field, -subnd)
 
-static inline void part_inc_in_flight(struct hd_struct *part, int rw)
+static inline void part_inc_in_flight(struct request_queue *q,
+				      struct hd_struct *part, int rw)
 {
 	atomic_inc(&part->in_flight[rw]);
 	if (part->partno)
 		atomic_inc(&part_to_disk(part)->part0.in_flight[rw]);
 }
 
-static inline void part_dec_in_flight(struct hd_struct *part, int rw)
+static inline void part_dec_in_flight(struct request_queue *q,
+				      struct hd_struct *part, int rw)
 {
 	atomic_dec(&part->in_flight[rw]);
 	if (part->partno)
 		atomic_dec(&part_to_disk(part)->part0.in_flight[rw]);
 }
 
-static inline int part_in_flight(struct hd_struct *part)
+static inline int part_in_flight(struct request_queue *q,
+				 struct hd_struct *part)
 {
-	return atomic_read(&part->in_flight[0]) + atomic_read(&part->in_flight[1]);
+	return atomic_read(&part->in_flight[0]) +
+			atomic_read(&part->in_flight[1]);
 }
 
 static inline struct partition_meta_info *alloc_part_info(struct gendisk *disk)
@@ -415,7 +419,7 @@ static inline void free_part_info(struct hd_struct *part)
 }
 
 /* block/blk-core.c */
-extern void part_round_stats(int cpu, struct hd_struct *part);
+extern void part_round_stats(struct request_queue *q, int cpu, struct hd_struct *part);
 
 /* block/genhd.c */
 extern void add_disk(struct gendisk *disk);
