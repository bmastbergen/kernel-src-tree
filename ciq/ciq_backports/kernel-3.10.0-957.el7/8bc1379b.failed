ext4: avoid running out of journal credits when appending to an inline file

jira LE-1907
cve CVE-2018-10883
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit 8bc1379b82b8e809eef77a9fedbb75c6c297be19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8bc1379b.failed

Use a separate journal transaction if it turns out that we need to
convert an inline file to use an data block.  Otherwise we could end
up failing due to not having journal credits.

This addresses CVE-2018-10883.

https://bugzilla.kernel.org/show_bug.cgi?id=200071

	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: stable@kernel.org
(cherry picked from commit 8bc1379b82b8e809eef77a9fedbb75c6c297be19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/ext4.h
#	fs/ext4/inline.c
#	fs/ext4/xattr.c
diff --cc fs/ext4/ext4.h
index 0e7a16f12d02,859d6433dcc1..000000000000
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@@ -2710,10 -3009,11 +2710,18 @@@ extern struct buffer_head *ext4_get_fir
  extern int ext4_inline_data_fiemap(struct inode *inode,
  				   struct fiemap_extent_info *fieinfo,
  				   int *has_inline, __u64 start, __u64 len);
++<<<<<<< HEAD
 +extern int ext4_try_to_evict_inline_data(handle_t *handle,
 +					 struct inode *inode,
 +					 int needed);
 +extern void ext4_inline_data_truncate(struct inode *inode, int *has_inline);
++=======
+ 
+ struct iomap;
+ extern int ext4_inline_data_iomap(struct inode *inode, struct iomap *iomap);
+ 
+ extern int ext4_inline_data_truncate(struct inode *inode, int *has_inline);
++>>>>>>> 8bc1379b82b8 (ext4: avoid running out of journal credits when appending to an inline file)
  
  extern int ext4_convert_inline_data(struct inode *inode);
  
diff --cc fs/ext4/inline.c
index 2c9cf4c9b5f3,851bc552d849..000000000000
--- a/fs/ext4/inline.c
+++ b/fs/ext4/inline.c
@@@ -1885,46 -1891,10 +1885,50 @@@ out
  	return (error < 0 ? error : 0);
  }
  
++<<<<<<< HEAD
 +/*
 + * Called during xattr set, and if we can sparse space 'needed',
 + * just create the extent tree evict the data to the outer block.
 + *
 + * We use jbd2 instead of page cache to move data to the 1st block
 + * so that the whole transaction can be committed as a whole and
 + * the data isn't lost because of the delayed page cache write.
 + */
 +int ext4_try_to_evict_inline_data(handle_t *handle,
 +				  struct inode *inode,
 +				  int needed)
 +{
 +	int error;
 +	struct ext4_xattr_entry *entry;
 +	struct ext4_inode *raw_inode;
 +	struct ext4_iloc iloc;
 +
 +	error = ext4_get_inode_loc(inode, &iloc);
 +	if (error)
 +		return error;
 +
 +	raw_inode = ext4_raw_inode(&iloc);
 +	entry = (struct ext4_xattr_entry *)((void *)raw_inode +
 +					    EXT4_I(inode)->i_inline_off);
 +	if (EXT4_XATTR_LEN(entry->e_name_len) +
 +	    EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size)) < needed) {
 +		error = -ENOSPC;
 +		goto out;
 +	}
 +
 +	error = ext4_convert_inline_data_nolock(handle, inode, &iloc);
 +out:
 +	brelse(iloc.bh);
 +	return error;
 +}
 +
 +void ext4_inline_data_truncate(struct inode *inode, int *has_inline)
++=======
+ int ext4_inline_data_truncate(struct inode *inode, int *has_inline)
++>>>>>>> 8bc1379b82b8 (ext4: avoid running out of journal credits when appending to an inline file)
  {
  	handle_t *handle;
 -	int inline_size, value_len, needed_blocks, no_expand, err = 0;
 +	int inline_size, value_len, needed_blocks;
  	size_t i_size;
  	void *value = NULL;
  	struct ext4_xattr_ibody_find is = {
diff --cc fs/ext4/xattr.c
index d7ce9e3d8174,723df14f4084..000000000000
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@@ -1011,23 -2211,9 +1011,29 @@@ int ext4_xattr_ibody_inline_set(handle_
  
  	if (EXT4_I(inode)->i_extra_isize == 0)
  		return -ENOSPC;
++<<<<<<< HEAD
 +	error = ext4_xattr_set_entry(i, s);
 +	if (error) {
 +		if (error == -ENOSPC &&
 +		    ext4_has_inline_data(inode)) {
 +			error = ext4_try_to_evict_inline_data(handle, inode,
 +					EXT4_XATTR_LEN(strlen(i->name) +
 +					EXT4_XATTR_SIZE(i->value_len)));
 +			if (error)
 +				return error;
 +			error = ext4_xattr_ibody_find(inode, i, is);
 +			if (error)
 +				return error;
 +			error = ext4_xattr_set_entry(i, s);
 +		}
 +		if (error)
 +			return error;
 +	}
++=======
+ 	error = ext4_xattr_set_entry(i, s, handle, inode, false /* is_block */);
+ 	if (error)
+ 		return error;
++>>>>>>> 8bc1379b82b8 (ext4: avoid running out of journal credits when appending to an inline file)
  	header = IHDR(inode, ext4_raw_inode(&is->iloc));
  	if (!IS_LAST_ENTRY(s->first)) {
  		header->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);
* Unmerged path fs/ext4/ext4.h
* Unmerged path fs/ext4/inline.c
* Unmerged path fs/ext4/xattr.c
