i40e/i40evf: Clean-up of bits related to using q_vector->reg_idx

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Alexander Duyck <alexander.h.duyck@intel.com>
commit 8b99b1179c27958f51ecfc489af5f459f9408d96
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8b99b117.failed

This patch is a further clean-up related to the change over to using
q_vector->reg_idx when accessing the ITR registers. Specifically the code
appears to have several other spots where we were computing the register
offset manually and this resulted in errors in a few spots.

Specifically in the i40evf functions for mapping queues to vectors it
appears we may have had an off by 1 error since (v_idx - 1) for the first
q_vector with an index of 0 would result in us returning -1 if I am not
mistaken.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 8b99b1179c27958f51ecfc489af5f459f9408d96)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_ethtool.c
#	drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index 07d59f1fbd43,8cc9198ac32f..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@@ -2229,30 -2315,30 +2229,41 @@@ static void i40e_set_itr_per_queue(stru
  
  	intrl = i40e_intrl_usec_to_reg(vsi->int_rate_limit);
  
 -	rx_ring->itr_setting = ec->rx_coalesce_usecs;
 -	tx_ring->itr_setting = ec->tx_coalesce_usecs;
 +	rx_ring->rx_itr_setting = ec->rx_coalesce_usecs;
 +	tx_ring->tx_itr_setting = ec->tx_coalesce_usecs;
  
  	if (ec->use_adaptive_rx_coalesce)
 -		rx_ring->itr_setting |= I40E_ITR_DYNAMIC;
 +		rx_ring->rx_itr_setting |= I40E_ITR_DYNAMIC;
  	else
 -		rx_ring->itr_setting &= ~I40E_ITR_DYNAMIC;
 +		rx_ring->rx_itr_setting &= ~I40E_ITR_DYNAMIC;
  
  	if (ec->use_adaptive_tx_coalesce)
 -		tx_ring->itr_setting |= I40E_ITR_DYNAMIC;
 +		tx_ring->tx_itr_setting |= I40E_ITR_DYNAMIC;
  	else
 -		tx_ring->itr_setting &= ~I40E_ITR_DYNAMIC;
 +		tx_ring->tx_itr_setting &= ~I40E_ITR_DYNAMIC;
  
  	q_vector = rx_ring->q_vector;
++<<<<<<< HEAD
 +	q_vector->rx.itr = ITR_TO_REG(rx_ring->rx_itr_setting);
 +	vector = vsi->base_vector + q_vector->v_idx;
 +	wr32(hw, I40E_PFINT_ITRN(I40E_RX_ITR, vector - 1), q_vector->rx.itr);
 +
 +	q_vector = tx_ring->q_vector;
 +	q_vector->tx.itr = ITR_TO_REG(tx_ring->tx_itr_setting);
 +	vector = vsi->base_vector + q_vector->v_idx;
 +	wr32(hw, I40E_PFINT_ITRN(I40E_TX_ITR, vector - 1), q_vector->tx.itr);
++=======
+ 	q_vector->rx.itr = ITR_TO_REG(rx_ring->itr_setting);
+ 	wr32(hw, I40E_PFINT_ITRN(I40E_RX_ITR, q_vector->reg_idx),
+ 	     q_vector->rx.itr);
  
- 	wr32(hw, I40E_PFINT_RATEN(vector - 1), intrl);
+ 	q_vector = tx_ring->q_vector;
+ 	q_vector->tx.itr = ITR_TO_REG(tx_ring->itr_setting);
+ 	wr32(hw, I40E_PFINT_ITRN(I40E_TX_ITR, q_vector->reg_idx),
+ 	     q_vector->tx.itr);
++>>>>>>> 8b99b1179c27 (i40e/i40evf: Clean-up of bits related to using q_vector->reg_idx)
+ 
+ 	wr32(hw, I40E_PFINT_RATEN(q_vector->reg_idx), intrl);
  	i40e_flush(hw);
  }
  
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
index e2d8aa19d205,ed5b8ec4d2a2..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
@@@ -514,31 -514,29 +514,40 @@@ static void i40evf_set_itr_per_queue(st
  {
  	struct i40e_ring *rx_ring = &adapter->rx_rings[queue];
  	struct i40e_ring *tx_ring = &adapter->tx_rings[queue];
- 	struct i40e_vsi *vsi = &adapter->vsi;
  	struct i40e_hw *hw = &adapter->hw;
  	struct i40e_q_vector *q_vector;
- 	u16 vector;
  
 -	rx_ring->itr_setting = ec->rx_coalesce_usecs;
 -	tx_ring->itr_setting = ec->tx_coalesce_usecs;
 +	rx_ring->rx_itr_setting = ec->rx_coalesce_usecs;
 +	tx_ring->tx_itr_setting = ec->tx_coalesce_usecs;
  
 -	rx_ring->itr_setting |= I40E_ITR_DYNAMIC;
 +	rx_ring->rx_itr_setting |= I40E_ITR_DYNAMIC;
  	if (!ec->use_adaptive_rx_coalesce)
 -		rx_ring->itr_setting ^= I40E_ITR_DYNAMIC;
 +		rx_ring->rx_itr_setting ^= I40E_ITR_DYNAMIC;
  
 -	tx_ring->itr_setting |= I40E_ITR_DYNAMIC;
 +	tx_ring->tx_itr_setting |= I40E_ITR_DYNAMIC;
  	if (!ec->use_adaptive_tx_coalesce)
 -		tx_ring->itr_setting ^= I40E_ITR_DYNAMIC;
 +		tx_ring->tx_itr_setting ^= I40E_ITR_DYNAMIC;
  
  	q_vector = rx_ring->q_vector;
++<<<<<<< HEAD
 +	q_vector->rx.itr = ITR_TO_REG(rx_ring->rx_itr_setting);
 +	vector = vsi->base_vector + q_vector->v_idx;
 +	wr32(hw, I40E_VFINT_ITRN1(I40E_RX_ITR, vector - 1), q_vector->rx.itr);
 +
 +	q_vector = tx_ring->q_vector;
 +	q_vector->tx.itr = ITR_TO_REG(tx_ring->tx_itr_setting);
 +	vector = vsi->base_vector + q_vector->v_idx;
 +	wr32(hw, I40E_VFINT_ITRN1(I40E_TX_ITR, vector - 1), q_vector->tx.itr);
++=======
+ 	q_vector->rx.itr = ITR_TO_REG(rx_ring->itr_setting);
+ 	wr32(hw, I40E_VFINT_ITRN1(I40E_RX_ITR, q_vector->reg_idx),
+ 	     q_vector->rx.itr);
+ 
+ 	q_vector = tx_ring->q_vector;
+ 	q_vector->tx.itr = ITR_TO_REG(tx_ring->itr_setting);
+ 	wr32(hw, I40E_VFINT_ITRN1(I40E_TX_ITR, q_vector->reg_idx),
+ 	     q_vector->tx.itr);
++>>>>>>> 8b99b1179c27 (i40e/i40evf: Clean-up of bits related to using q_vector->reg_idx)
  
  	i40e_flush(hw);
  }
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_ethtool.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
diff --git a/drivers/net/ethernet/intel/i40evf/i40evf_main.c b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
index b473966a345a..4a696d373142 100644
--- a/drivers/net/ethernet/intel/i40evf/i40evf_main.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
@@ -357,7 +357,8 @@ i40evf_map_vector_to_rxq(struct i40evf_adapter *adapter, int v_idx, int r_idx)
 	q_vector->rx.itr = ITR_TO_REG(rx_ring->rx_itr_setting);
 	q_vector->ring_mask |= BIT(r_idx);
 	q_vector->itr_countdown = ITR_COUNTDOWN_START;
-	wr32(hw, I40E_VFINT_ITRN1(I40E_RX_ITR, v_idx - 1), q_vector->rx.itr);
+	wr32(hw, I40E_VFINT_ITRN1(I40E_RX_ITR, q_vector->reg_idx),
+	     q_vector->rx.itr);
 }
 
 /**
@@ -382,7 +383,8 @@ i40evf_map_vector_to_txq(struct i40evf_adapter *adapter, int v_idx, int t_idx)
 	q_vector->tx.itr = ITR_TO_REG(tx_ring->tx_itr_setting);
 	q_vector->itr_countdown = ITR_COUNTDOWN_START;
 	q_vector->num_ringpairs++;
-	wr32(hw, I40E_VFINT_ITRN1(I40E_TX_ITR, v_idx - 1), q_vector->tx.itr);
+	wr32(hw, I40E_VFINT_ITRN1(I40E_TX_ITR, q_vector->reg_idx),
+	     q_vector->tx.itr);
 }
 
 /**
