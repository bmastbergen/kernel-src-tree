iommu/iova: Implement Flush-Queue ring buffer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iommu] iova: Implement Flush-Queue ring buffer (Jerry Snitselaar) [1519117]
Rebuild_FUZZ: 92.86%
commit-author Joerg Roedel <jroedel@suse.de>
commit 1928210107edd4fa786199fef6b875d3af3bef88
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/19282101.failed

Add a function to add entries to the Flush-Queue ring
buffer. If the buffer is full, call the flush-callback and
free the entries.

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 1928210107edd4fa786199fef6b875d3af3bef88)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iova.c
#	include/linux/iova.h
diff --cc drivers/iommu/iova.c
index f106fd9782bf,e5c9a7ae6088..000000000000
--- a/drivers/iommu/iova.c
+++ b/drivers/iommu/iova.c
@@@ -53,6 -57,43 +54,46 @@@ init_iova_domain(struct iova_domain *io
  }
  EXPORT_SYMBOL_GPL(init_iova_domain);
  
++<<<<<<< HEAD
++=======
+ static void free_iova_flush_queue(struct iova_domain *iovad)
+ {
+ 	if (!iovad->fq)
+ 		return;
+ 
+ 	fq_destroy_all_entries(iovad);
+ 	free_percpu(iovad->fq);
+ 
+ 	iovad->fq         = NULL;
+ 	iovad->flush_cb   = NULL;
+ 	iovad->entry_dtor = NULL;
+ }
+ 
+ int init_iova_flush_queue(struct iova_domain *iovad,
+ 			  iova_flush_cb flush_cb, iova_entry_dtor entry_dtor)
+ {
+ 	int cpu;
+ 
+ 	iovad->fq = alloc_percpu(struct iova_fq);
+ 	if (!iovad->fq)
+ 		return -ENOMEM;
+ 
+ 	iovad->flush_cb   = flush_cb;
+ 	iovad->entry_dtor = entry_dtor;
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		struct iova_fq *fq;
+ 
+ 		fq = per_cpu_ptr(iovad->fq, cpu);
+ 		fq->head = 0;
+ 		fq->tail = 0;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(init_iova_flush_queue);
+ 
++>>>>>>> 1928210107ed (iommu/iova: Implement Flush-Queue ring buffer)
  static struct rb_node *
  __get_cached_rbnode(struct iova_domain *iovad, unsigned long *limit_pfn)
  {
diff --cc include/linux/iova.h
index f27bb2c62fca,1ae85248ec50..000000000000
--- a/include/linux/iova.h
+++ b/include/linux/iova.h
@@@ -106,5 -144,108 +109,111 @@@ void put_iova_domain(struct iova_domai
  struct iova *split_and_remove_iova(struct iova_domain *iovad,
  	struct iova *iova, unsigned long pfn_lo, unsigned long pfn_hi);
  void free_cpu_cached_iovas(unsigned int cpu, struct iova_domain *iovad);
++<<<<<<< HEAD
++=======
+ #else
+ static inline int iova_cache_get(void)
+ {
+ 	return -ENOTSUPP;
+ }
+ 
+ static inline void iova_cache_put(void)
+ {
+ }
+ 
+ static inline struct iova *alloc_iova_mem(void)
+ {
+ 	return NULL;
+ }
+ 
+ static inline void free_iova_mem(struct iova *iova)
+ {
+ }
+ 
+ static inline void free_iova(struct iova_domain *iovad, unsigned long pfn)
+ {
+ }
+ 
+ static inline void __free_iova(struct iova_domain *iovad, struct iova *iova)
+ {
+ }
+ 
+ static inline struct iova *alloc_iova(struct iova_domain *iovad,
+ 				      unsigned long size,
+ 				      unsigned long limit_pfn,
+ 				      bool size_aligned)
+ {
+ 	return NULL;
+ }
+ 
+ static inline void free_iova_fast(struct iova_domain *iovad,
+ 				  unsigned long pfn,
+ 				  unsigned long size)
+ {
+ }
+ 
+ static inline void queue_iova(struct iova_domain *iovad,
+ 			      unsigned long pfn, unsigned long pages,
+ 			      unsigned long data)
+ {
+ }
+ 
+ static inline unsigned long alloc_iova_fast(struct iova_domain *iovad,
+ 					    unsigned long size,
+ 					    unsigned long limit_pfn)
+ {
+ 	return 0;
+ }
+ 
+ static inline struct iova *reserve_iova(struct iova_domain *iovad,
+ 					unsigned long pfn_lo,
+ 					unsigned long pfn_hi)
+ {
+ 	return NULL;
+ }
+ 
+ static inline void copy_reserved_iova(struct iova_domain *from,
+ 				      struct iova_domain *to)
+ {
+ }
+ 
+ static inline void init_iova_domain(struct iova_domain *iovad,
+ 				    unsigned long granule,
+ 				    unsigned long start_pfn,
+ 				    unsigned long pfn_32bit)
+ {
+ }
+ 
+ static inline int init_iova_flush_queue(struct iova_domain *iovad,
+ 					iova_flush_cb flush_cb,
+ 					iova_entry_dtor entry_dtor)
+ {
+ 	return -ENODEV;
+ }
+ 
+ static inline struct iova *find_iova(struct iova_domain *iovad,
+ 				     unsigned long pfn)
+ {
+ 	return NULL;
+ }
+ 
+ static inline void put_iova_domain(struct iova_domain *iovad)
+ {
+ }
+ 
+ static inline struct iova *split_and_remove_iova(struct iova_domain *iovad,
+ 						 struct iova *iova,
+ 						 unsigned long pfn_lo,
+ 						 unsigned long pfn_hi)
+ {
+ 	return NULL;
+ }
+ 
+ static inline void free_cpu_cached_iovas(unsigned int cpu,
+ 					 struct iova_domain *iovad)
+ {
+ }
+ #endif
++>>>>>>> 1928210107ed (iommu/iova: Implement Flush-Queue ring buffer)
  
  #endif
* Unmerged path drivers/iommu/iova.c
* Unmerged path include/linux/iova.h
