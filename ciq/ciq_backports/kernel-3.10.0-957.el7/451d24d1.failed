perf/core: Fix crash in perf_event_read()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit 451d24d1e5f40bad000fa9abe36ddb16fc9928cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/451d24d1.failed

Alexei had his box explode because doing read() on a package
(rapl/uncore) event that isn't currently scheduled in ends up doing an
out-of-bounds load.

Rework the code to more explicitly deal with event->oncpu being -1.

	Reported-by: Alexei Starovoitov <alexei.starovoitov@gmail.com>
	Tested-by: Alexei Starovoitov <ast@kernel.org>
	Tested-by: David Carrillo-Cisneros <davidcc@google.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: eranian@google.com
Fixes: d6a2f9035bfc ("perf/core: Introduce PMU_EV_CAP_READ_ACTIVE_PKG")
Link: http://lkml.kernel.org/r/20170131102710.GL6515@twins.programming.kicks-ass.net
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 451d24d1e5f40bad000fa9abe36ddb16fc9928cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/core.c
diff --cc kernel/events/core.c
index e490cd411934,e235bb991bdd..000000000000
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@@ -3691,6 -3637,14 +3692,17 @@@ static int perf_event_read(struct perf_
  			.group = group,
  			.ret = 0,
  		};
++<<<<<<< HEAD
++=======
+ 
+ 		event_cpu = READ_ONCE(event->oncpu);
+ 		if ((unsigned)event_cpu >= nr_cpu_ids)
+ 			return 0;
+ 
+ 		preempt_disable();
+ 		event_cpu = __perf_event_read_cpu(event, event_cpu);
+ 
++>>>>>>> 451d24d1e5f4 (perf/core: Fix crash in perf_event_read())
  		/*
  		 * Purposely ignore the smp_call_function_single() return
  		 * value.
@@@ -3701,12 -3655,8 +3713,17 @@@
  		 * Therefore, either way, we'll have an up-to-date event count
  		 * after this.
  		 */
++<<<<<<< HEAD
 +
 +		local_cpu = get_cpu();
 +		cpu_to_read = find_cpu_to_read(event, local_cpu);
 +		put_cpu();
 +
 +		(void)smp_call_function_single(cpu_to_read, __perf_event_read, &data, 1);
++=======
+ 		(void)smp_call_function_single(event_cpu, __perf_event_read, &data, 1);
+ 		preempt_enable();
++>>>>>>> 451d24d1e5f4 (perf/core: Fix crash in perf_event_read())
  		ret = data.ret;
  	} else if (event->state == PERF_EVENT_STATE_INACTIVE) {
  		struct perf_event_context *ctx = event->ctx;
* Unmerged path kernel/events/core.c
