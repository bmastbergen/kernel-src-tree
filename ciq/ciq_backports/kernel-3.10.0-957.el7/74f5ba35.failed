mmc: block: rename mmc_active to areq

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] block: rename mmc_active to areq (Gopal Tiwari) [1549495]
Rebuild_FUZZ: 92.75%
commit-author Linus Walleij <linus.walleij@linaro.org>
commit 74f5ba357c7cd63c664e65fb7a116dbc0538a2ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/74f5ba35.failed

The mmc_active member of struct mmc_queue_req has a very
confusing name: this is certainly not always "active", it is
the asynchronous request associated by the mmc_queue_req
but it is not guaranteed to be "active" in any sense, such
as being running on the host.

Simply rename this member to "areq".

	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 74f5ba357c7cd63c664e65fb7a116dbc0538a2ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/block.c
diff --cc drivers/mmc/core/block.c
index d7cc8dd6684d,2a3e9e678a23..000000000000
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@@ -1586,7 -1587,41 +1586,45 @@@ static int mmc_blk_cmd_err(struct mmc_b
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)
++=======
+ static void mmc_blk_rw_cmd_abort(struct mmc_card *card, struct request *req)
+ {
+ 	int ret = 1;
+ 
+ 	if (mmc_card_removed(card))
+ 		req->rq_flags |= RQF_QUIET;
+ 	while (ret)
+ 		ret = blk_end_request(req, -EIO,
+ 				      blk_rq_cur_bytes(req));
+ }
+ 
+ /**
+  * mmc_blk_rw_try_restart() - tries to restart the current async request
+  * @mq: the queue with the card and host to restart
+  * @req: a new request that want to be started after the current one
+  */
+ static void mmc_blk_rw_try_restart(struct mmc_queue *mq, struct request *req)
+ {
+ 	if (!req)
+ 		return;
+ 
+ 	/*
+ 	 * If the card was removed, just cancel everything and return.
+ 	 */
+ 	if (mmc_card_removed(mq->card)) {
+ 		req->rq_flags |= RQF_QUIET;
+ 		blk_end_request_all(req, -EIO);
+ 		return;
+ 	}
+ 	/* Else proceed and try to restart the current async request */
+ 	mmc_blk_rw_rq_prep(mq->mqrq_cur, mq->card, 0, mq);
+ 	mmc_start_areq(mq->card->host, &mq->mqrq_cur->areq, NULL);
+ }
+ 
+ static void mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *new_req)
++>>>>>>> 74f5ba357c7c (mmc: block: rename mmc_active to areq)
  {
  	struct mmc_blk_data *md = mq->blkdata;
  	struct mmc_card *card = md->queue.card;
@@@ -1636,10 -1671,10 +1674,10 @@@
  		 * An asynchronous request has been completed and we proceed
  		 * to handle the result of it.
  		 */
- 		mq_rq =	container_of(old_areq, struct mmc_queue_req, mmc_active);
+ 		mq_rq =	container_of(old_areq, struct mmc_queue_req, areq);
  		brq = &mq_rq->brq;
 -		old_req = mq_rq->req;
 -		type = rq_data_dir(old_req) == READ ? MMC_BLK_READ : MMC_BLK_WRITE;
 +		req = mq_rq->req;
 +		type = rq_data_dir(req) == READ ? MMC_BLK_READ : MMC_BLK_WRITE;
  		mmc_queue_bounce_post(mq_rq);
  
  		switch (status) {
@@@ -1725,8 -1776,8 +1763,13 @@@
  			 */
  			mmc_blk_rw_rq_prep(mq_rq, card,
  					disable_multi, mq);
++<<<<<<< HEAD
 +			mmc_start_req(card->host,
 +					&mq_rq->mmc_active, NULL);
++=======
+ 			mmc_start_areq(card->host,
+ 					&mq_rq->areq, NULL);
++>>>>>>> 74f5ba357c7c (mmc: block: rename mmc_active to areq)
  			mq_rq->brq.retune_retry_done = retune_retry_done;
  		}
  	} while (ret);
* Unmerged path drivers/mmc/core/block.c
diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index a61f88199573..40a8d7917c1d 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -23,7 +23,7 @@ struct mmc_queue_req {
 	char			*bounce_buf;
 	struct scatterlist	*bounce_sg;
 	unsigned int		bounce_sg_len;
-	struct mmc_async_req	mmc_active;
+	struct mmc_async_req	areq;
 };
 
 struct mmc_queue {
