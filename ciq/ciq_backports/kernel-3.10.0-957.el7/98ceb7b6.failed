mlxsw: spectrum: qdiscs: prio: Delete child qdiscs when removing bands

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Nogah Frankel <nogahf@mellanox.com>
commit 98ceb7b6d64552f995973be1a0ee9af0bf85fb3d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/98ceb7b6.failed

When the number the bands of sch_prio is decreased, child qdiscs on the
deleted bands would get deleted as well.
This change and deletions are being done under sch_tree_lock of the
sch_prio qdisc. Part of the destruction of qdisc is unoffloading it, if
it is offloaded. Un-offloading can't be done inside this lock.
Move the offload command to be done before reducing the number of bands,
so unoffloading of the qdiscs that are about to be deleted could be done
outside of the lock.

	Signed-off-by: Nogah Frankel <nogahf@mellanox.com>
	Reviewed-by: Yuval Mintz <yuvalm@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 98ceb7b6d64552f995973be1a0ee9af0bf85fb3d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
#	net/sched/sch_prio.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
index b5397da94d7f,a2a3ac09c3bc..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
@@@ -275,3 -481,230 +275,233 @@@ int mlxsw_sp_setup_tc_red(struct mlxsw_
  		return -EOPNOTSUPP;
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ static int
+ mlxsw_sp_qdisc_prio_destroy(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			    struct mlxsw_sp_qdisc *mlxsw_sp_qdisc)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+ 		mlxsw_sp_port_prio_tc_set(mlxsw_sp_port, i,
+ 					  MLXSW_SP_PORT_DEFAULT_TCLASS);
+ 		mlxsw_sp_qdisc_destroy(mlxsw_sp_port,
+ 				       &mlxsw_sp_port->tclass_qdiscs[i]);
+ 		mlxsw_sp_port->tclass_qdiscs[i].prio_bitmap = 0;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_prio_check_params(struct mlxsw_sp_port *mlxsw_sp_port,
+ 				 struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 				 void *params)
+ {
+ 	struct tc_prio_qopt_offload_params *p = params;
+ 
+ 	if (p->bands > IEEE_8021QAZ_MAX_TCS)
+ 		return -EOPNOTSUPP;
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_prio_replace(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			    struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			    void *params)
+ {
+ 	struct tc_prio_qopt_offload_params *p = params;
+ 	struct mlxsw_sp_qdisc *child_qdisc;
+ 	int tclass, i, band, backlog;
+ 	u8 old_priomap;
+ 	int err;
+ 
+ 	for (band = 0; band < p->bands; band++) {
+ 		tclass = MLXSW_SP_PRIO_BAND_TO_TCLASS(band);
+ 		child_qdisc = &mlxsw_sp_port->tclass_qdiscs[tclass];
+ 		old_priomap = child_qdisc->prio_bitmap;
+ 		child_qdisc->prio_bitmap = 0;
+ 		for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+ 			if (p->priomap[i] == band) {
+ 				child_qdisc->prio_bitmap |= BIT(i);
+ 				if (BIT(i) & old_priomap)
+ 					continue;
+ 				err = mlxsw_sp_port_prio_tc_set(mlxsw_sp_port,
+ 								i, tclass);
+ 				if (err)
+ 					return err;
+ 			}
+ 		}
+ 		if (old_priomap != child_qdisc->prio_bitmap &&
+ 		    child_qdisc->ops && child_qdisc->ops->clean_stats) {
+ 			backlog = child_qdisc->stats_base.backlog;
+ 			child_qdisc->ops->clean_stats(mlxsw_sp_port,
+ 						      child_qdisc);
+ 			child_qdisc->stats_base.backlog = backlog;
+ 		}
+ 	}
+ 	for (; band < IEEE_8021QAZ_MAX_TCS; band++) {
+ 		tclass = MLXSW_SP_PRIO_BAND_TO_TCLASS(band);
+ 		child_qdisc = &mlxsw_sp_port->tclass_qdiscs[tclass];
+ 		child_qdisc->prio_bitmap = 0;
+ 		mlxsw_sp_qdisc_destroy(mlxsw_sp_port, child_qdisc);
+ 	}
+ 	return 0;
+ }
+ 
+ static void
+ mlxsw_sp_qdisc_prio_unoffload(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			      struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			      void *params)
+ {
+ 	struct tc_prio_qopt_offload_params *p = params;
+ 	u64 backlog;
+ 
+ 	backlog = mlxsw_sp_cells_bytes(mlxsw_sp_port->mlxsw_sp,
+ 				       mlxsw_sp_qdisc->stats_base.backlog);
+ 	p->qstats->backlog -= backlog;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_get_prio_stats(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			      struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			      struct tc_qopt_offload_stats *stats_ptr)
+ {
+ 	u64 tx_bytes, tx_packets, drops = 0, backlog = 0;
+ 	struct mlxsw_sp_qdisc_stats *stats_base;
+ 	struct mlxsw_sp_port_xstats *xstats;
+ 	struct rtnl_link_stats64 *stats;
+ 	int i;
+ 
+ 	xstats = &mlxsw_sp_port->periodic_hw_stats.xstats;
+ 	stats = &mlxsw_sp_port->periodic_hw_stats.stats;
+ 	stats_base = &mlxsw_sp_qdisc->stats_base;
+ 
+ 	tx_bytes = stats->tx_bytes - stats_base->tx_bytes;
+ 	tx_packets = stats->tx_packets - stats_base->tx_packets;
+ 
+ 	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+ 		drops += xstats->tail_drop[i];
+ 		drops += xstats->wred_drop[i];
+ 		backlog += xstats->backlog[i];
+ 	}
+ 	drops = drops - stats_base->drops;
+ 
+ 	_bstats_update(stats_ptr->bstats, tx_bytes, tx_packets);
+ 	stats_ptr->qstats->drops += drops;
+ 	stats_ptr->qstats->backlog +=
+ 				mlxsw_sp_cells_bytes(mlxsw_sp_port->mlxsw_sp,
+ 						     backlog) -
+ 				mlxsw_sp_cells_bytes(mlxsw_sp_port->mlxsw_sp,
+ 						     stats_base->backlog);
+ 	stats_base->backlog = backlog;
+ 	stats_base->drops += drops;
+ 	stats_base->tx_bytes += tx_bytes;
+ 	stats_base->tx_packets += tx_packets;
+ 	return 0;
+ }
+ 
+ static void
+ mlxsw_sp_setup_tc_qdisc_prio_clean_stats(struct mlxsw_sp_port *mlxsw_sp_port,
+ 					 struct mlxsw_sp_qdisc *mlxsw_sp_qdisc)
+ {
+ 	struct mlxsw_sp_qdisc_stats *stats_base;
+ 	struct mlxsw_sp_port_xstats *xstats;
+ 	struct rtnl_link_stats64 *stats;
+ 	int i;
+ 
+ 	xstats = &mlxsw_sp_port->periodic_hw_stats.xstats;
+ 	stats = &mlxsw_sp_port->periodic_hw_stats.stats;
+ 	stats_base = &mlxsw_sp_qdisc->stats_base;
+ 
+ 	stats_base->tx_packets = stats->tx_packets;
+ 	stats_base->tx_bytes = stats->tx_bytes;
+ 
+ 	stats_base->drops = 0;
+ 	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+ 		stats_base->drops += xstats->tail_drop[i];
+ 		stats_base->drops += xstats->wred_drop[i];
+ 	}
+ 
+ 	mlxsw_sp_qdisc->stats_base.backlog = 0;
+ }
+ 
+ static struct mlxsw_sp_qdisc_ops mlxsw_sp_qdisc_ops_prio = {
+ 	.type = MLXSW_SP_QDISC_PRIO,
+ 	.check_params = mlxsw_sp_qdisc_prio_check_params,
+ 	.replace = mlxsw_sp_qdisc_prio_replace,
+ 	.unoffload = mlxsw_sp_qdisc_prio_unoffload,
+ 	.destroy = mlxsw_sp_qdisc_prio_destroy,
+ 	.get_stats = mlxsw_sp_qdisc_get_prio_stats,
+ 	.clean_stats = mlxsw_sp_setup_tc_qdisc_prio_clean_stats,
+ };
+ 
+ int mlxsw_sp_setup_tc_prio(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			   struct tc_prio_qopt_offload *p)
+ {
+ 	struct mlxsw_sp_qdisc *mlxsw_sp_qdisc;
+ 
+ 	mlxsw_sp_qdisc = mlxsw_sp_qdisc_find(mlxsw_sp_port, p->parent, true);
+ 	if (!mlxsw_sp_qdisc)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (p->command == TC_PRIO_REPLACE)
+ 		return mlxsw_sp_qdisc_replace(mlxsw_sp_port, p->handle,
+ 					      mlxsw_sp_qdisc,
+ 					      &mlxsw_sp_qdisc_ops_prio,
+ 					      &p->replace_params);
+ 
+ 	if (!mlxsw_sp_qdisc_compare(mlxsw_sp_qdisc, p->handle,
+ 				    MLXSW_SP_QDISC_PRIO))
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (p->command) {
+ 	case TC_PRIO_DESTROY:
+ 		return mlxsw_sp_qdisc_destroy(mlxsw_sp_port, mlxsw_sp_qdisc);
+ 	case TC_PRIO_STATS:
+ 		return mlxsw_sp_qdisc_get_stats(mlxsw_sp_port, mlxsw_sp_qdisc,
+ 						&p->stats);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ int mlxsw_sp_tc_qdisc_init(struct mlxsw_sp_port *mlxsw_sp_port)
+ {
+ 	struct mlxsw_sp_qdisc *mlxsw_sp_qdisc;
+ 	int i;
+ 
+ 	mlxsw_sp_qdisc = kzalloc(sizeof(*mlxsw_sp_qdisc), GFP_KERNEL);
+ 	if (!mlxsw_sp_qdisc)
+ 		goto err_root_qdisc_init;
+ 
+ 	mlxsw_sp_port->root_qdisc = mlxsw_sp_qdisc;
+ 	mlxsw_sp_port->root_qdisc->prio_bitmap = 0xff;
+ 	mlxsw_sp_port->root_qdisc->tclass_num = MLXSW_SP_PORT_DEFAULT_TCLASS;
+ 
+ 	mlxsw_sp_qdisc = kzalloc(sizeof(*mlxsw_sp_qdisc) * IEEE_8021QAZ_MAX_TCS,
+ 				 GFP_KERNEL);
+ 	if (!mlxsw_sp_qdisc)
+ 		goto err_tclass_qdiscs_init;
+ 
+ 	mlxsw_sp_port->tclass_qdiscs = mlxsw_sp_qdisc;
+ 	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)
+ 		mlxsw_sp_port->tclass_qdiscs[i].tclass_num = i;
+ 
+ 	return 0;
+ 
+ err_tclass_qdiscs_init:
+ 	kfree(mlxsw_sp_port->root_qdisc);
+ err_root_qdisc_init:
+ 	return -ENOMEM;
+ }
+ 
+ void mlxsw_sp_tc_qdisc_fini(struct mlxsw_sp_port *mlxsw_sp_port)
+ {
+ 	kfree(mlxsw_sp_port->tclass_qdiscs);
+ 	kfree(mlxsw_sp_port->root_qdisc);
+ }
++>>>>>>> 98ceb7b6d645 (mlxsw: spectrum: qdiscs: prio: Delete child qdiscs when removing bands)
diff --cc net/sched/sch_prio.c
index 2dd6c68ae91e,ba2d6d17d95a..000000000000
--- a/net/sched/sch_prio.c
+++ b/net/sched/sch_prio.c
@@@ -141,6 -142,30 +141,33 @@@ prio_reset(struct Qdisc *sch
  	sch->q.qlen = 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int prio_offload(struct Qdisc *sch, struct tc_prio_qopt *qopt)
+ {
+ 	struct net_device *dev = qdisc_dev(sch);
+ 	struct tc_prio_qopt_offload opt = {
+ 		.handle = sch->handle,
+ 		.parent = sch->parent,
+ 	};
+ 
+ 	if (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (qopt) {
+ 		opt.command = TC_PRIO_REPLACE;
+ 		opt.replace_params.bands = qopt->bands;
+ 		memcpy(&opt.replace_params.priomap, qopt->priomap,
+ 		       TC_PRIO_MAX + 1);
+ 		opt.replace_params.qstats = &sch->qstats;
+ 	} else {
+ 		opt.command = TC_PRIO_DESTROY;
+ 	}
+ 
+ 	return dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_PRIO, &opt);
+ }
+ 
++>>>>>>> 98ceb7b6d645 (mlxsw: spectrum: qdiscs: prio: Delete child qdiscs when removing bands)
  static void
  prio_destroy(struct Qdisc *sch)
  {
@@@ -148,6 -173,7 +175,10 @@@
  	struct prio_sched_data *q = qdisc_priv(sch);
  
  	tcf_block_put(q->block);
++<<<<<<< HEAD
++=======
+ 	prio_offload(sch, NULL);
++>>>>>>> 98ceb7b6d645 (mlxsw: spectrum: qdiscs: prio: Delete child qdiscs when removing bands)
  	for (prio = 0; prio < q->bands; prio++)
  		qdisc_destroy(q->queues[prio]);
  }
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
* Unmerged path net/sched/sch_prio.c
