Input: synaptics - clear device info before filling in

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [input] synaptics - clear device info before filling in (Benjamin Tissoires) [1554926]
Rebuild_FUZZ: 93.07%
commit-author Eric Biggers <ebiggers@google.com>
commit 2755551188d240f0098cdc6f1a2984f8a1785689
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/27555511.failed

synaptics_query_hardware() was being passed a 'struct synaptics_device_info'
in uninitialized stack memory, then not always initializing all fields.
This caused garbage to show up in certain fields, making the touchpad
unusable.

Fix by zeroing the device info, so all fields default to 0.

Fixes: 6c53694fb222 ("Input: synaptics - split device info into a separate structure")
	Signed-off-by: Eric Biggers <ebiggers@google.com>
	Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
(cherry picked from commit 2755551188d240f0098cdc6f1a2984f8a1785689)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/input/mouse/synaptics.c
diff --cc drivers/input/mouse/synaptics.c
index 5f5887ef5b0a,4f97970abc94..000000000000
--- a/drivers/input/mouse/synaptics.c
+++ b/drivers/input/mouse/synaptics.c
@@@ -196,6 -167,328 +196,331 @@@ static const char * const topbuttonpad_
  	NULL
  };
  
++<<<<<<< HEAD
++=======
+ static const char * const smbus_pnp_ids[] = {
+ 	/* all of the topbuttonpad_pnp_ids are valid, we just add some extras */
+ 	"LEN0048", /* X1 Carbon 3 */
+ 	"LEN0046", /* X250 */
+ 	"LEN004a", /* W541 */
+ 	"LEN200f", /* T450s */
+ 	NULL
+ };
+ 
+ /*
+  * Send a command to the synpatics touchpad by special commands
+  */
+ static int synaptics_send_cmd(struct psmouse *psmouse, u8 cmd, u8 *param)
+ {
+ 	int error;
+ 
+ 	error = psmouse_sliced_command(psmouse, cmd);
+ 	if (error)
+ 		return error;
+ 
+ 	error = ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_GETINFO);
+ 	if (error)
+ 		return error;
+ 
+ 	return 0;
+ }
+ 
+ static int synaptics_query_int(struct psmouse *psmouse, u8 query_cmd, u32 *val)
+ {
+ 	int error;
+ 	union {
+ 		__be32 be_val;
+ 		char buf[4];
+ 	} resp = { 0 };
+ 
+ 	error = synaptics_send_cmd(psmouse, query_cmd, resp.buf + 1);
+ 	if (error)
+ 		return error;
+ 
+ 	*val = be32_to_cpu(resp.be_val);
+ 	return 0;
+ }
+ 
+ /*
+  * Identify Touchpad
+  * See also the SYN_ID_* macros
+  */
+ static int synaptics_identify(struct psmouse *psmouse,
+ 			      struct synaptics_device_info *info)
+ {
+ 	int error;
+ 
+ 	error = synaptics_query_int(psmouse, SYN_QUE_IDENTIFY, &info->identity);
+ 	if (error)
+ 		return error;
+ 
+ 	return SYN_ID_IS_SYNAPTICS(info->identity) ? 0 : -ENXIO;
+ }
+ 
+ /*
+  * Read the model-id bytes from the touchpad
+  * see also SYN_MODEL_* macros
+  */
+ static int synaptics_model_id(struct psmouse *psmouse,
+ 			      struct synaptics_device_info *info)
+ {
+ 	return synaptics_query_int(psmouse, SYN_QUE_MODEL, &info->model_id);
+ }
+ 
+ /*
+  * Read the firmware id from the touchpad
+  */
+ static int synaptics_firmware_id(struct psmouse *psmouse,
+ 				 struct synaptics_device_info *info)
+ {
+ 	return synaptics_query_int(psmouse, SYN_QUE_FIRMWARE_ID,
+ 				   &info->firmware_id);
+ }
+ 
+ /*
+  * Read the board id and the "More Extended Queries" from the touchpad
+  * The board id is encoded in the "QUERY MODES" response
+  */
+ static int synaptics_query_modes(struct psmouse *psmouse,
+ 				 struct synaptics_device_info *info)
+ {
+ 	u8 bid[3];
+ 	int error;
+ 
+ 	/* firmwares prior 7.5 have no board_id encoded */
+ 	if (SYN_ID_FULL(info->identity) < 0x705)
+ 		return 0;
+ 
+ 	error = synaptics_send_cmd(psmouse, SYN_QUE_MODES, bid);
+ 	if (error)
+ 		return error;
+ 
+ 	info->board_id = ((bid[0] & 0xfc) << 6) | bid[1];
+ 
+ 	if (SYN_MEXT_CAP_BIT(bid[0]))
+ 		return synaptics_query_int(psmouse, SYN_QUE_MEXT_CAPAB_10,
+ 					   &info->ext_cap_10);
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Read the capability-bits from the touchpad
+  * see also the SYN_CAP_* macros
+  */
+ static int synaptics_capability(struct psmouse *psmouse,
+ 				struct synaptics_device_info *info)
+ {
+ 	int error;
+ 
+ 	error = synaptics_query_int(psmouse, SYN_QUE_CAPABILITIES,
+ 				    &info->capabilities);
+ 	if (error)
+ 		return error;
+ 
+ 	info->ext_cap = info->ext_cap_0c = 0;
+ 
+ 	/*
+ 	 * Older firmwares had submodel ID fixed to 0x47
+ 	 */
+ 	if (SYN_ID_FULL(info->identity) < 0x705 &&
+ 	    SYN_CAP_SUBMODEL_ID(info->capabilities) != 0x47) {
+ 		return -ENXIO;
+ 	}
+ 
+ 	/*
+ 	 * Unless capExtended is set the rest of the flags should be ignored
+ 	 */
+ 	if (!SYN_CAP_EXTENDED(info->capabilities))
+ 		info->capabilities = 0;
+ 
+ 	if (SYN_EXT_CAP_REQUESTS(info->capabilities) >= 1) {
+ 		error = synaptics_query_int(psmouse, SYN_QUE_EXT_CAPAB,
+ 					    &info->ext_cap);
+ 		if (error) {
+ 			psmouse_warn(psmouse,
+ 				     "device claims to have extended capabilities, but I'm not able to read them.\n");
+ 		} else {
+ 			/*
+ 			 * if nExtBtn is greater than 8 it should be considered
+ 			 * invalid and treated as 0
+ 			 */
+ 			if (SYN_CAP_MULTI_BUTTON_NO(info->ext_cap) > 8)
+ 				info->ext_cap &= ~SYN_CAP_MB_MASK;
+ 		}
+ 	}
+ 
+ 	if (SYN_EXT_CAP_REQUESTS(info->capabilities) >= 4) {
+ 		error = synaptics_query_int(psmouse, SYN_QUE_EXT_CAPAB_0C,
+ 					    &info->ext_cap_0c);
+ 		if (error)
+ 			psmouse_warn(psmouse,
+ 				     "device claims to have extended capability 0x0c, but I'm not able to read it.\n");
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Read touchpad resolution and maximum reported coordinates
+  * Resolution is left zero if touchpad does not support the query
+  */
+ static int synaptics_resolution(struct psmouse *psmouse,
+ 				struct synaptics_device_info *info)
+ {
+ 	u8 resp[3];
+ 	int error;
+ 
+ 	if (SYN_ID_MAJOR(info->identity) < 4)
+ 		return 0;
+ 
+ 	error = synaptics_send_cmd(psmouse, SYN_QUE_RESOLUTION, resp);
+ 	if (!error) {
+ 		if (resp[0] != 0 && (resp[1] & 0x80) && resp[2] != 0) {
+ 			info->x_res = resp[0]; /* x resolution in units/mm */
+ 			info->y_res = resp[2]; /* y resolution in units/mm */
+ 		}
+ 	}
+ 
+ 	if (SYN_EXT_CAP_REQUESTS(info->capabilities) >= 5 &&
+ 	    SYN_CAP_MAX_DIMENSIONS(info->ext_cap_0c)) {
+ 		error = synaptics_send_cmd(psmouse,
+ 					   SYN_QUE_EXT_MAX_COORDS, resp);
+ 		if (error) {
+ 			psmouse_warn(psmouse,
+ 				     "device claims to have max coordinates query, but I'm not able to read it.\n");
+ 		} else {
+ 			info->x_max = (resp[0] << 5) | ((resp[1] & 0x0f) << 1);
+ 			info->y_max = (resp[2] << 5) | ((resp[1] & 0xf0) >> 3);
+ 			psmouse_info(psmouse,
+ 				     "queried max coordinates: x [..%d], y [..%d]\n",
+ 				     info->x_max, info->y_max);
+ 		}
+ 	}
+ 
+ 	if (SYN_CAP_MIN_DIMENSIONS(info->ext_cap_0c) &&
+ 	    (SYN_EXT_CAP_REQUESTS(info->capabilities) >= 7 ||
+ 	     /*
+ 	      * Firmware v8.1 does not report proper number of extended
+ 	      * capabilities, but has been proven to report correct min
+ 	      * coordinates.
+ 	      */
+ 	     SYN_ID_FULL(info->identity) == 0x801)) {
+ 		error = synaptics_send_cmd(psmouse,
+ 					   SYN_QUE_EXT_MIN_COORDS, resp);
+ 		if (error) {
+ 			psmouse_warn(psmouse,
+ 				     "device claims to have min coordinates query, but I'm not able to read it.\n");
+ 		} else {
+ 			info->x_min = (resp[0] << 5) | ((resp[1] & 0x0f) << 1);
+ 			info->y_min = (resp[2] << 5) | ((resp[1] & 0xf0) >> 3);
+ 			psmouse_info(psmouse,
+ 				     "queried min coordinates: x [%d..], y [%d..]\n",
+ 				     info->x_min, info->y_min);
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int synaptics_query_hardware(struct psmouse *psmouse,
+ 				    struct synaptics_device_info *info)
+ {
+ 	int error;
+ 
+ 	memset(info, 0, sizeof(*info));
+ 
+ 	error = synaptics_identify(psmouse, info);
+ 	if (error)
+ 		return error;
+ 
+ 	error = synaptics_model_id(psmouse, info);
+ 	if (error)
+ 		return error;
+ 
+ 	error = synaptics_firmware_id(psmouse, info);
+ 	if (error)
+ 		return error;
+ 
+ 	error = synaptics_query_modes(psmouse, info);
+ 	if (error)
+ 		return error;
+ 
+ 	error = synaptics_capability(psmouse, info);
+ 	if (error)
+ 		return error;
+ 
+ 	error = synaptics_resolution(psmouse, info);
+ 	if (error)
+ 		return error;
+ 
+ 	return 0;
+ }
+ 
+ #endif /* CONFIG_MOUSE_PS2_SYNAPTICS || CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS */
+ 
+ #ifdef CONFIG_MOUSE_PS2_SYNAPTICS
+ 
+ static bool cr48_profile_sensor;
+ 
+ #define ANY_BOARD_ID 0
+ struct min_max_quirk {
+ 	const char * const *pnp_ids;
+ 	struct {
+ 		u32 min, max;
+ 	} board_id;
+ 	u32 x_min, x_max, y_min, y_max;
+ };
+ 
+ static const struct min_max_quirk min_max_pnpid_table[] = {
+ 	{
+ 		(const char * const []){"LEN0033", NULL},
+ 		{ANY_BOARD_ID, ANY_BOARD_ID},
+ 		1024, 5052, 2258, 4832
+ 	},
+ 	{
+ 		(const char * const []){"LEN0042", NULL},
+ 		{ANY_BOARD_ID, ANY_BOARD_ID},
+ 		1232, 5710, 1156, 4696
+ 	},
+ 	{
+ 		(const char * const []){"LEN0034", "LEN0036", "LEN0037",
+ 					"LEN0039", "LEN2002", "LEN2004",
+ 					NULL},
+ 		{ANY_BOARD_ID, 2961},
+ 		1024, 5112, 2024, 4832
+ 	},
+ 	{
+ 		(const char * const []){"LEN2000", NULL},
+ 		{ANY_BOARD_ID, ANY_BOARD_ID},
+ 		1024, 5113, 2021, 4832
+ 	},
+ 	{
+ 		(const char * const []){"LEN2001", NULL},
+ 		{ANY_BOARD_ID, ANY_BOARD_ID},
+ 		1024, 5022, 2508, 4832
+ 	},
+ 	{
+ 		(const char * const []){"LEN2006", NULL},
+ 		{2691, 2691},
+ 		1024, 5045, 2457, 4832
+ 	},
+ 	{
+ 		(const char * const []){"LEN2006", NULL},
+ 		{ANY_BOARD_ID, ANY_BOARD_ID},
+ 		1264, 5675, 1171, 4688
+ 	},
+ 	{ }
+ };
+ 
+ /* This list has been kindly provided by Synaptics. */
+ static const char * const forcepad_pnp_ids[] = {
+ 	"SYN300D",
+ 	"SYN3014",
+ 	NULL
+ };
+ 
++>>>>>>> 2755551188d2 (Input: synaptics - clear device info before filling in)
  /*****************************************************************************
   *	Synaptics communications functions
   ****************************************************************************/
* Unmerged path drivers/input/mouse/synaptics.c
