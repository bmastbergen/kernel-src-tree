treewide: init_timer() -> setup_timer()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Kees Cook <keescook@chromium.org>
commit b9eaf18722221ef8b2bd6a67240ebe668622152a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b9eaf187.failed

This mechanically converts all remaining cases of ancient open-coded timer
setup with the old setup_timer() API, which is the first step in timer
conversions. This has no behavioral changes, since it ultimately just
changes the order of assignment to fields of struct timer_list when
finding variations of:

    init_timer(&t);
    f.function = timer_callback;
    t.data = timer_callback_arg;

to be converted into:

    setup_timer(&t, timer_callback, timer_callback_arg);

The conversion is done with the following Coccinelle script, which
is an improved version of scripts/cocci/api/setup_timer.cocci, in the
following ways:
 - assignments-before-init_timer() cases
 - limit the .data case removal to the specific struct timer_list instance
 - handling calls by dereference (timer->field vs timer.field)

spatch --very-quiet --all-includes --include-headers \
	-I ./arch/x86/include -I ./arch/x86/include/generated \
	-I ./include -I ./arch/x86/include/uapi \
	-I ./arch/x86/include/generated/uapi -I ./include/uapi \
	-I ./include/generated/uapi --include ./include/linux/kconfig.h \
	--dir . \
	--cocci-file ~/src/data/setup_timer.cocci

@fix_address_of@
expression e;
@@

 init_timer(
-&(e)
+&e
 , ...)

// Match the common cases first to avoid Coccinelle parsing loops with
// "... when" clauses.

@match_immediate_function_data_after_init_timer@
expression e, func, da;
@@

-init_timer
+setup_timer
 ( \(&e\|e\)
+, func, da
 );
(
-\(e.function\|e->function\) = func;
-\(e.data\|e->data\) = da;
|
-\(e.data\|e->data\) = da;
-\(e.function\|e->function\) = func;
)

@match_immediate_function_data_before_init_timer@
expression e, func, da;
@@

(
-\(e.function\|e->function\) = func;
-\(e.data\|e->data\) = da;
|
-\(e.data\|e->data\) = da;
-\(e.function\|e->function\) = func;
)
-init_timer
+setup_timer
 ( \(&e\|e\)
+, func, da
 );

@match_function_and_data_after_init_timer@
expression e, e2, e3, e4, e5, func, da;
@@

-init_timer
+setup_timer
 ( \(&e\|e\)
+, func, da
 );
 ... when != func = e2
     when != da = e3
(
-e.function = func;
... when != da = e4
-e.data = da;
|
-e->function = func;
... when != da = e4
-e->data = da;
|
-e.data = da;
... when != func = e5
-e.function = func;
|
-e->data = da;
... when != func = e5
-e->function = func;
)

@match_function_and_data_before_init_timer@
expression e, e2, e3, e4, e5, func, da;
@@
(
-e.function = func;
... when != da = e4
-e.data = da;
|
-e->function = func;
... when != da = e4
-e->data = da;
|
-e.data = da;
... when != func = e5
-e.function = func;
|
-e->data = da;
... when != func = e5
-e->function = func;
)
... when != func = e2
    when != da = e3
-init_timer
+setup_timer
 ( \(&e\|e\)
+, func, da
 );

@r1 exists@
expression t;
identifier f;
position p;
@@

f(...) { ... when any
  init_timer@p(\(&t\|t\))
  ... when any
}

@r2 exists@
expression r1.t;
identifier g != r1.f;
expression e8;
@@

g(...) { ... when any
  \(t.data\|t->data\) = e8
  ... when any
}

// It is dangerous to use setup_timer if data field is initialized
// in another function.
@script:python depends on r2@
p << r1.p;
@@

cocci.include_match(False)

@r3@
expression r1.t, func, e7;
position r1.p;
@@

(
-init_timer@p(&t);
+setup_timer(&t, func, 0UL);
... when != func = e7
-t.function = func;
|
-t.function = func;
... when != func = e7
-init_timer@p(&t);
+setup_timer(&t, func, 0UL);
|
-init_timer@p(t);
+setup_timer(t, func, 0UL);
... when != func = e7
-t->function = func;
|
-t->function = func;
... when != func = e7
-init_timer@p(t);
+setup_timer(t, func, 0UL);
)

	Signed-off-by: Kees Cook <keescook@chromium.org>
(cherry picked from commit b9eaf18722221ef8b2bd6a67240ebe668622152a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/mach-iop32x/n2100.c
#	drivers/media/platform/s5p-mfc/s5p_mfc.c
#	drivers/media/usb/au0828/au0828-dvb.c
#	drivers/nfc/pn533.c
#	drivers/nfc/st-nci/ndlc.c
#	drivers/nfc/st-nci/se.c
#	drivers/nfc/st21nfca/se.c
#	drivers/scsi/arcmsr/arcmsr_hba.c
#	drivers/scsi/esas2r/esas2r_main.c
diff --cc arch/arm/mach-iop32x/n2100.c
index ea0984a7449e,4a64a11ba63c..000000000000
--- a/arch/arm/mach-iop32x/n2100.c
+++ b/arch/arm/mach-iop32x/n2100.c
@@@ -308,6 -316,32 +308,35 @@@ static void power_button_poll(unsigned 
  	add_timer(&power_button_poll_timer);
  }
  
++<<<<<<< HEAD
++=======
+ static int __init n2100_request_gpios(void)
+ {
+ 	int ret;
+ 
+ 	if (!machine_is_n2100())
+ 		return 0;
+ 
+ 	ret = gpio_request(N2100_HARDWARE_RESET, "reset");
+ 	if (ret)
+ 		pr_err("could not request reset GPIO\n");
+ 
+ 	ret = gpio_request(N2100_POWER_BUTTON, "power");
+ 	if (ret)
+ 		pr_err("could not request power GPIO\n");
+ 	else {
+ 		ret = gpio_direction_input(N2100_POWER_BUTTON);
+ 		if (ret)
+ 			pr_err("could not set power GPIO as input\n");
+ 	}
+ 	/* Set up power button poll timer */
+ 	setup_timer(&power_button_poll_timer, power_button_poll, 0UL);
+ 	power_button_poll_timer.expires = jiffies + (HZ / 10);
+ 	add_timer(&power_button_poll_timer);
+ 	return 0;
+ }
+ device_initcall(n2100_request_gpios);
++>>>>>>> b9eaf1872222 (treewide: init_timer() -> setup_timer())
  
  static void __init n2100_init_machine(void)
  {
diff --cc drivers/media/platform/s5p-mfc/s5p_mfc.c
index d12faa691af8,e179b33d3775..000000000000
--- a/drivers/media/platform/s5p-mfc/s5p_mfc.c
+++ b/drivers/media/platform/s5p-mfc/s5p_mfc.c
@@@ -1140,10 -1310,12 +1140,19 @@@ static int s5p_mfc_probe(struct platfor
  	}
  
  	mutex_init(&dev->mfc_mutex);
++<<<<<<< HEAD
 +
 +	ret = s5p_mfc_alloc_firmware(dev);
 +	if (ret)
 +		goto err_alloc_fw;
++=======
+ 	init_waitqueue_head(&dev->queue);
+ 	dev->hw_lock = 0;
+ 	INIT_WORK(&dev->watchdog_work, s5p_mfc_watchdog_worker);
+ 	atomic_set(&dev->watchdog_cnt, 0);
+ 	setup_timer(&dev->watchdog_timer, s5p_mfc_watchdog,
+ 		    (unsigned long)dev);
++>>>>>>> b9eaf1872222 (treewide: init_timer() -> setup_timer())
  
  	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
  	if (ret)
diff --cc drivers/media/usb/au0828/au0828-dvb.c
index 9a6f15613a38,d701c04b3783..000000000000
--- a/drivers/media/usb/au0828/au0828-dvb.c
+++ b/drivers/media/usb/au0828/au0828-dvb.c
@@@ -495,5 -647,49 +495,11 @@@ int au0828_dvb_register(struct au0828_d
  		return ret;
  	}
  
++<<<<<<< HEAD
++=======
+ 	setup_timer(&dev->bulk_timeout, au0828_bulk_timeout,
+ 		    (unsigned long)dev);
+ 
++>>>>>>> b9eaf1872222 (treewide: init_timer() -> setup_timer())
  	return 0;
  }
 -
 -void au0828_dvb_suspend(struct au0828_dev *dev)
 -{
 -	struct au0828_dvb *dvb = &dev->dvb;
 -	int rc;
 -
 -	if (dvb->frontend) {
 -		if (dev->urb_streaming) {
 -			cancel_work_sync(&dev->restart_streaming);
 -			/* Stop transport */
 -			mutex_lock(&dvb->lock);
 -			stop_urb_transfer(dev);
 -			au0828_stop_transport(dev, 1);
 -			mutex_unlock(&dvb->lock);
 -			dev->need_urb_start = true;
 -		}
 -		/* suspend frontend - does tuner and fe to sleep */
 -		rc = dvb_frontend_suspend(dvb->frontend);
 -		pr_info("au0828_dvb_suspend(): Suspending DVB fe %d\n", rc);
 -	}
 -}
 -
 -void au0828_dvb_resume(struct au0828_dev *dev)
 -{
 -	struct au0828_dvb *dvb = &dev->dvb;
 -	int rc;
 -
 -	if (dvb->frontend) {
 -		/* resume frontend - does fe and tuner init */
 -		rc = dvb_frontend_resume(dvb->frontend);
 -		pr_info("au0828_dvb_resume(): Resuming DVB fe %d\n", rc);
 -		if (dev->need_urb_start) {
 -			/* Start transport */
 -			mutex_lock(&dvb->lock);
 -			au0828_start_transport(dev);
 -			start_urb_transfer(dev);
 -			mutex_unlock(&dvb->lock);
 -		}
 -	}
 -}
diff --cc drivers/nfc/pn533.c
index 8f6f2baa930d,2effa5ff7082..000000000000
--- a/drivers/nfc/pn533.c
+++ b/drivers/nfc/pn533.c
@@@ -2663,108 -2565,87 +2663,113 @@@ static int pn533_setup(struct pn533 *de
  	return 0;
  }
  
 -int pn533_finalize_setup(struct pn533 *dev)
 +static int pn533_probe(struct usb_interface *interface,
 +			const struct usb_device_id *id)
  {
 -
  	struct pn533_fw_version fw_ver;
 -	int rc;
 +	struct pn533 *dev;
 +	struct usb_host_interface *iface_desc;
 +	struct usb_endpoint_descriptor *endpoint;
 +	int in_endpoint = 0;
 +	int out_endpoint = 0;
 +	int rc = -ENOMEM;
 +	int i;
 +	u32 protocols;
  
 -	memset(&fw_ver, 0, sizeof(fw_ver));
 +	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 +	if (!dev)
 +		return -ENOMEM;
  
 -	rc = pn533_get_firmware_version(dev, &fw_ver);
 -	if (rc) {
 -		nfc_err(dev->dev, "Unable to get FW version\n");
 -		return rc;
 -	}
 +	dev->udev = usb_get_dev(interface_to_usbdev(interface));
 +	dev->interface = interface;
 +	mutex_init(&dev->cmd_lock);
  
 -	nfc_info(dev->dev, "NXP PN5%02X firmware ver %d.%d now attached\n",
 -		fw_ver.ic, fw_ver.ver, fw_ver.rev);
 +	iface_desc = interface->cur_altsetting;
 +	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
 +		endpoint = &iface_desc->endpoint[i].desc;
  
 -	rc = pn533_setup(dev);
 -	if (rc)
 -		return rc;
 +		if (!in_endpoint && usb_endpoint_is_bulk_in(endpoint))
 +			in_endpoint = endpoint->bEndpointAddress;
  
 -	return 0;
 -}
 -EXPORT_SYMBOL_GPL(pn533_finalize_setup);
 +		if (!out_endpoint && usb_endpoint_is_bulk_out(endpoint))
 +			out_endpoint = endpoint->bEndpointAddress;
 +	}
  
 -struct pn533 *pn533_register_device(u32 device_type,
 -				u32 protocols,
 -				enum pn533_protocol_type protocol_type,
 -				void *phy,
 -				struct pn533_phy_ops *phy_ops,
 -				struct pn533_frame_ops *fops,
 -				struct device *dev,
 -				struct device *parent)
 -{
 -	struct pn533 *priv;
 -	int rc = -ENOMEM;
 +	if (!in_endpoint || !out_endpoint) {
 +		nfc_dev_err(&interface->dev,
 +			    "Could not find bulk-in or bulk-out endpoint");
 +		rc = -ENODEV;
 +		goto error;
 +	}
  
 -	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 -	if (!priv)
 -		return ERR_PTR(-ENOMEM);
 +	dev->in_urb = usb_alloc_urb(0, GFP_KERNEL);
 +	dev->out_urb = usb_alloc_urb(0, GFP_KERNEL);
  
 -	priv->phy = phy;
 -	priv->phy_ops = phy_ops;
 -	priv->dev = dev;
 -	if (fops != NULL)
 -		priv->ops = fops;
 -	else
 -		priv->ops = &pn533_std_frame_ops;
 -
 -	priv->protocol_type = protocol_type;
 -	priv->device_type = device_type;
 -
 -	mutex_init(&priv->cmd_lock);
 -
 -	INIT_WORK(&priv->cmd_work, pn533_wq_cmd);
 -	INIT_WORK(&priv->cmd_complete_work, pn533_wq_cmd_complete);
 -	INIT_WORK(&priv->mi_rx_work, pn533_wq_mi_recv);
 -	INIT_WORK(&priv->mi_tx_work, pn533_wq_mi_send);
 -	INIT_WORK(&priv->tg_work, pn533_wq_tg_get_data);
 -	INIT_WORK(&priv->mi_tm_rx_work, pn533_wq_tm_mi_recv);
 -	INIT_WORK(&priv->mi_tm_tx_work, pn533_wq_tm_mi_send);
 -	INIT_DELAYED_WORK(&priv->poll_work, pn533_wq_poll);
 -	INIT_WORK(&priv->rf_work, pn533_wq_rf);
 -	priv->wq = alloc_ordered_workqueue("pn533", 0);
 -	if (priv->wq == NULL)
 +	if (!dev->in_urb || !dev->out_urb)
  		goto error;
  
++<<<<<<< HEAD:drivers/nfc/pn533.c
 +	usb_fill_bulk_urb(dev->in_urb, dev->udev,
 +			  usb_rcvbulkpipe(dev->udev, in_endpoint),
 +			  NULL, 0, NULL, dev);
 +	usb_fill_bulk_urb(dev->out_urb, dev->udev,
 +			  usb_sndbulkpipe(dev->udev, out_endpoint),
 +			  NULL, 0, pn533_send_complete, dev);
++=======
+ 	setup_timer(&priv->listen_timer, pn533_listen_mode_timer,
+ 		    (unsigned long)priv);
++>>>>>>> b9eaf1872222 (treewide: init_timer() -> setup_timer()):drivers/nfc/pn533/pn533.c
 +
 +	INIT_WORK(&dev->cmd_work, pn533_wq_cmd);
 +	INIT_WORK(&dev->cmd_complete_work, pn533_wq_cmd_complete);
 +	INIT_WORK(&dev->mi_work, pn533_wq_mi_recv);
 +	INIT_WORK(&dev->tg_work, pn533_wq_tg_get_data);
 +	INIT_WORK(&dev->poll_work, pn533_wq_poll);
 +	dev->wq = alloc_ordered_workqueue("pn533", 0);
 +	if (dev->wq == NULL)
 +		goto error;
  
 -	skb_queue_head_init(&priv->resp_q);
 -	skb_queue_head_init(&priv->fragment_skb);
 +	init_timer(&dev->listen_timer);
 +	dev->listen_timer.data = (unsigned long) dev;
 +	dev->listen_timer.function = pn533_listen_mode_timer;
  
 -	INIT_LIST_HEAD(&priv->cmd_queue);
 +	skb_queue_head_init(&dev->resp_q);
  
 -	priv->nfc_dev = nfc_allocate_device(&pn533_nfc_ops, protocols,
 -					   priv->ops->tx_header_len +
 -					   PN533_CMD_DATAEXCH_HEAD_LEN,
 -					   priv->ops->tx_tail_len);
 -	if (!priv->nfc_dev) {
 -		rc = -ENOMEM;
 +	INIT_LIST_HEAD(&dev->cmd_queue);
 +
 +	usb_set_intfdata(interface, dev);
 +
 +	dev->ops = &pn533_std_frame_ops;
 +
 +	dev->protocol_type = PN533_PROTO_REQ_ACK_RESP;
 +	dev->device_type = id->driver_info;
 +	switch (dev->device_type) {
 +	case PN533_DEVICE_STD:
 +		protocols = PN533_ALL_PROTOCOLS;
 +		break;
 +
 +	case PN533_DEVICE_PASORI:
 +		protocols = PN533_NO_TYPE_B_PROTOCOLS;
 +		break;
 +
 +	case PN533_DEVICE_ACR122U:
 +		protocols = PN533_NO_TYPE_B_PROTOCOLS;
 +		dev->ops = &pn533_acr122_frame_ops;
 +		dev->protocol_type = PN533_PROTO_REQ_RESP,
 +
 +		rc = pn533_acr122_poweron_rdr(dev);
 +		if (rc < 0) {
 +			nfc_dev_err(&dev->interface->dev,
 +				    "Couldn't poweron the reader (error %d)",
 +				    rc);
 +			goto destroy_wq;
 +		}
 +		break;
 +
 +	default:
 +		nfc_dev_err(&dev->interface->dev, "Unknown device type %d\n",
 +			    dev->device_type);
 +		rc = -EINVAL;
  		goto destroy_wq;
  	}
  
diff --cc drivers/scsi/arcmsr/arcmsr_hba.c
index 278c9fa62067,a54b6c11b505..000000000000
--- a/drivers/scsi/arcmsr/arcmsr_hba.c
+++ b/drivers/scsi/arcmsr/arcmsr_hba.c
@@@ -710,7 -868,86 +709,90 @@@ pci_disable_dev
  	return -ENODEV;
  }
  
++<<<<<<< HEAD
 +static uint8_t arcmsr_abort_hba_allcmd(struct AdapterControlBlock *acb)
++=======
+ static void arcmsr_free_irq(struct pci_dev *pdev,
+ 		struct AdapterControlBlock *acb)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < acb->vector_count; i++)
+ 		free_irq(pci_irq_vector(pdev, i), acb);
+ 	pci_free_irq_vectors(pdev);
+ }
+ 
+ static int arcmsr_suspend(struct pci_dev *pdev, pm_message_t state)
+ {
+ 	uint32_t intmask_org;
+ 	struct Scsi_Host *host = pci_get_drvdata(pdev);
+ 	struct AdapterControlBlock *acb =
+ 		(struct AdapterControlBlock *)host->hostdata;
+ 
+ 	intmask_org = arcmsr_disable_outbound_ints(acb);
+ 	arcmsr_free_irq(pdev, acb);
+ 	del_timer_sync(&acb->eternal_timer);
+ 	flush_work(&acb->arcmsr_do_message_isr_bh);
+ 	arcmsr_stop_adapter_bgrb(acb);
+ 	arcmsr_flush_adapter_cache(acb);
+ 	pci_set_drvdata(pdev, host);
+ 	pci_save_state(pdev);
+ 	pci_disable_device(pdev);
+ 	pci_set_power_state(pdev, pci_choose_state(pdev, state));
+ 	return 0;
+ }
+ 
+ static int arcmsr_resume(struct pci_dev *pdev)
+ {
+ 	int error;
+ 	struct Scsi_Host *host = pci_get_drvdata(pdev);
+ 	struct AdapterControlBlock *acb =
+ 		(struct AdapterControlBlock *)host->hostdata;
+ 
+ 	pci_set_power_state(pdev, PCI_D0);
+ 	pci_enable_wake(pdev, PCI_D0, 0);
+ 	pci_restore_state(pdev);
+ 	if (pci_enable_device(pdev)) {
+ 		pr_warn("%s: pci_enable_device error\n", __func__);
+ 		return -ENODEV;
+ 	}
+ 	error = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));
+ 	if (error) {
+ 		error = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
+ 		if (error) {
+ 			pr_warn("scsi%d: No suitable DMA mask available\n",
+ 			       host->host_no);
+ 			goto controller_unregister;
+ 		}
+ 	}
+ 	pci_set_master(pdev);
+ 	if (arcmsr_request_irq(pdev, acb) == FAILED)
+ 		goto controller_stop;
+ 	arcmsr_iop_init(acb);
+ 	INIT_WORK(&acb->arcmsr_do_message_isr_bh, arcmsr_message_isr_bh_fn);
+ 	atomic_set(&acb->rq_map_token, 16);
+ 	atomic_set(&acb->ante_token_value, 16);
+ 	acb->fw_flag = FW_NORMAL;
+ 	setup_timer(&acb->eternal_timer, &arcmsr_request_device_map,
+ 		    (unsigned long)acb);
+ 	acb->eternal_timer.expires = jiffies + msecs_to_jiffies(6 * HZ);
+ 	add_timer(&acb->eternal_timer);
+ 	return 0;
+ controller_stop:
+ 	arcmsr_stop_adapter_bgrb(acb);
+ 	arcmsr_flush_adapter_cache(acb);
+ controller_unregister:
+ 	scsi_remove_host(host);
+ 	arcmsr_free_ccb_pool(acb);
+ 	arcmsr_unmap_pciregion(acb);
+ 	pci_release_regions(pdev);
+ 	scsi_host_put(host);
+ 	pci_disable_device(pdev);
+ 	return -ENODEV;
+ }
+ 
+ static uint8_t arcmsr_hbaA_abort_allcmd(struct AdapterControlBlock *acb)
++>>>>>>> b9eaf1872222 (treewide: init_timer() -> setup_timer())
  {
  	struct MessageUnit_A __iomem *reg = acb->pmuA;
  	writel(ARCMSR_INBOUND_MESG0_ABORT_CMD, &reg->inbound_msgaddr0);
* Unmerged path drivers/nfc/st-nci/ndlc.c
* Unmerged path drivers/nfc/st-nci/se.c
* Unmerged path drivers/nfc/st21nfca/se.c
* Unmerged path drivers/scsi/esas2r/esas2r_main.c
* Unmerged path arch/arm/mach-iop32x/n2100.c
diff --git a/arch/blackfin/kernel/nmi.c b/arch/blackfin/kernel/nmi.c
index 9919d29287dc..64dd717574be 100644
--- a/arch/blackfin/kernel/nmi.c
+++ b/arch/blackfin/kernel/nmi.c
@@ -179,8 +179,7 @@ static int __init init_nmi_wdt(void)
 	nmi_wdt_start();
 	nmi_active = true;
 
-	init_timer(&ntimer);
-	ntimer.function = nmi_wdt_timer;
+	setup_timer(&ntimer, nmi_wdt_timer, 0UL);
 	ntimer.expires = jiffies + NMI_CHECK_TIMEOUT;
 	add_timer(&ntimer);
 
diff --git a/arch/sh/drivers/pci/common.c b/arch/sh/drivers/pci/common.c
index dbf138199871..5f4b3a85e80b 100644
--- a/arch/sh/drivers/pci/common.c
+++ b/arch/sh/drivers/pci/common.c
@@ -105,15 +105,13 @@ static void pcibios_enable_serr(unsigned long __data)
 void pcibios_enable_timers(struct pci_channel *hose)
 {
 	if (hose->err_irq) {
-		init_timer(&hose->err_timer);
-		hose->err_timer.data = (unsigned long)hose;
-		hose->err_timer.function = pcibios_enable_err;
+		setup_timer(&hose->err_timer, pcibios_enable_err,
+			    (unsigned long)hose);
 	}
 
 	if (hose->serr_irq) {
-		init_timer(&hose->serr_timer);
-		hose->serr_timer.data = (unsigned long)hose;
-		hose->serr_timer.function = pcibios_enable_serr;
+		setup_timer(&hose->serr_timer, pcibios_enable_serr,
+			    (unsigned long)hose);
 	}
 }
 
diff --git a/arch/sh/drivers/push-switch.c b/arch/sh/drivers/push-switch.c
index 5bfb341cc5c4..2dc791507968 100644
--- a/arch/sh/drivers/push-switch.c
+++ b/arch/sh/drivers/push-switch.c
@@ -78,10 +78,7 @@ static int switch_drv_probe(struct platform_device *pdev)
 	}
 
 	INIT_WORK(&psw->work, switch_work_handler);
-	init_timer(&psw->debounce);
-
-	psw->debounce.function = switch_timer;
-	psw->debounce.data = (unsigned long)psw;
+	setup_timer(&psw->debounce, switch_timer, (unsigned long)psw);
 
 	/* Workqueue API brain-damage */
 	psw->pdev = pdev;
diff --git a/drivers/atm/firestream.c b/drivers/atm/firestream.c
index b41c9481b67b..b5b9b5090396 100644
--- a/drivers/atm/firestream.c
+++ b/drivers/atm/firestream.c
@@ -1881,9 +1881,7 @@ static int fs_init(struct fs_dev *dev)
 	}
 
 #ifdef FS_POLL_FREQ
-	init_timer (&dev->timer);
-	dev->timer.data = (unsigned long) dev;
-	dev->timer.function = fs_poll;
+	setup_timer (&dev->timer, fs_poll, (unsigned long)dev);
 	dev->timer.expires = jiffies + FS_POLL_FREQ;
 	add_timer (&dev->timer);
 #endif
diff --git a/drivers/atm/lanai.c b/drivers/atm/lanai.c
index fa7d701933ba..141e5d177320 100644
--- a/drivers/atm/lanai.c
+++ b/drivers/atm/lanai.c
@@ -1798,10 +1798,8 @@ static void lanai_timed_poll(unsigned long arg)
 
 static inline void lanai_timed_poll_start(struct lanai_dev *lanai)
 {
-	init_timer(&lanai->timer);
+	setup_timer(&lanai->timer, lanai_timed_poll, (unsigned long)lanai);
 	lanai->timer.expires = jiffies + LANAI_POLL_PERIOD;
-	lanai->timer.data = (unsigned long) lanai;
-	lanai->timer.function = lanai_timed_poll;
 	add_timer(&lanai->timer);
 }
 
diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index cce7fac5528d..62573a989857 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -292,10 +292,8 @@ static int __init nicstar_init(void)
 	XPRINTK("nicstar: nicstar_init() returned.\n");
 
 	if (!error) {
-		init_timer(&ns_timer);
+		setup_timer(&ns_timer, ns_poll, 0UL);
 		ns_timer.expires = jiffies + NS_POLL_PERIOD;
-		ns_timer.data = 0UL;
-		ns_timer.function = ns_poll;
 		add_timer(&ns_timer);
 	}
 
diff --git a/drivers/block/DAC960.c b/drivers/block/DAC960.c
index eb3950113e42..cac0011e873b 100644
--- a/drivers/block/DAC960.c
+++ b/drivers/block/DAC960.c
@@ -3076,11 +3076,10 @@ DAC960_InitializeController(DAC960_Controller_T *Controller)
       /*
 	Initialize the Monitoring Timer.
       */
-      init_timer(&Controller->MonitoringTimer);
+      setup_timer(&Controller->MonitoringTimer,
+                  DAC960_MonitoringTimerFunction, (unsigned long)Controller);
       Controller->MonitoringTimer.expires =
 	jiffies + DAC960_MonitoringTimerInterval;
-      Controller->MonitoringTimer.data = (unsigned long) Controller;
-      Controller->MonitoringTimer.function = DAC960_MonitoringTimerFunction;
       add_timer(&Controller->MonitoringTimer);
       Controller->ControllerInitialized = true;
       return true;
diff --git a/drivers/block/umem.c b/drivers/block/umem.c
index ad70868f8a96..011af298a0b4 100644
--- a/drivers/block/umem.c
+++ b/drivers/block/umem.c
@@ -741,8 +741,7 @@ static void check_all_batteries(unsigned long ptr)
 
 static void init_battery_timer(void)
 {
-	init_timer(&battery_timer);
-	battery_timer.function = check_all_batteries;
+	setup_timer(&battery_timer, check_all_batteries, 0UL);
 	battery_timer.expires = jiffies + (HZ * 60);
 	add_timer(&battery_timer);
 }
diff --git a/drivers/infiniband/hw/mthca/mthca_catas.c b/drivers/infiniband/hw/mthca/mthca_catas.c
index f6474c24f193..23cc08d5c24e 100644
--- a/drivers/infiniband/hw/mthca/mthca_catas.c
+++ b/drivers/infiniband/hw/mthca/mthca_catas.c
@@ -149,7 +149,7 @@ void mthca_start_catas_poll(struct mthca_dev *dev)
 {
 	phys_addr_t addr;
 
-	init_timer(&dev->catas_err.timer);
+	setup_timer(&dev->catas_err.timer, poll_catas, (unsigned long)dev);
 	dev->catas_err.map  = NULL;
 
 	addr = pci_resource_start(dev->pdev, 0) +
@@ -164,8 +164,6 @@ void mthca_start_catas_poll(struct mthca_dev *dev)
 		return;
 	}
 
-	dev->catas_err.timer.data     = (unsigned long) dev;
-	dev->catas_err.timer.function = poll_catas;
 	dev->catas_err.timer.expires  = jiffies + MTHCA_CATAS_POLL_INTERVAL;
 	INIT_LIST_HEAD(&dev->catas_err.list);
 	add_timer(&dev->catas_err.timer);
diff --git a/drivers/isdn/i4l/isdn_common.c b/drivers/isdn/i4l/isdn_common.c
index 9bb12ba3191f..8f083ae4b235 100644
--- a/drivers/isdn/i4l/isdn_common.c
+++ b/drivers/isdn/i4l/isdn_common.c
@@ -2308,8 +2308,7 @@ static int __init isdn_init(void)
 		printk(KERN_WARNING "isdn: Could not allocate device-struct.\n");
 		return -EIO;
 	}
-	init_timer(&dev->timer);
-	dev->timer.function = isdn_timer_funct;
+	setup_timer(&dev->timer, isdn_timer_funct, 0UL);
 	spin_lock_init(&dev->lock);
 	spin_lock_init(&dev->timerlock);
 #ifdef MODULE
diff --git a/drivers/isdn/i4l/isdn_net.c b/drivers/isdn/i4l/isdn_net.c
index 04cd70e763c5..90b534ef1bde 100644
--- a/drivers/isdn/i4l/isdn_net.c
+++ b/drivers/isdn/i4l/isdn_net.c
@@ -1615,9 +1615,9 @@ isdn_net_ciscohdlck_connected(isdn_net_local *lp)
 	/* send slarp request because interface/seq.no.s reset */
 	isdn_net_ciscohdlck_slarp_send_request(lp);
 
-	init_timer(&lp->cisco_timer);
-	lp->cisco_timer.data = (unsigned long) lp;
-	lp->cisco_timer.function = isdn_net_ciscohdlck_slarp_send_keepalive;
+	setup_timer(&lp->cisco_timer,
+		    isdn_net_ciscohdlck_slarp_send_keepalive,
+		    (unsigned long)lp);
 	lp->cisco_timer.expires = jiffies + lp->cisco_keepalive_period * HZ;
 	add_timer(&lp->cisco_timer);
 }
* Unmerged path drivers/media/platform/s5p-mfc/s5p_mfc.c
* Unmerged path drivers/media/usb/au0828/au0828-dvb.c
diff --git a/drivers/net/wireless/hostap/hostap_ap.c b/drivers/net/wireless/hostap/hostap_ap.c
index d6033a8e5dea..b958c42b0cb2 100644
--- a/drivers/net/wireless/hostap/hostap_ap.c
+++ b/drivers/net/wireless/hostap/hostap_ap.c
@@ -1190,10 +1190,8 @@ static struct sta_info * ap_add_sta(struct ap_data *ap, u8 *addr)
 	}
 
 #ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT
-	init_timer(&sta->timer);
+	setup_timer(&sta->timer, ap_handle_timer, (unsigned long)sta);
 	sta->timer.expires = jiffies + ap->max_inactivity;
-	sta->timer.data = (unsigned long) sta;
-	sta->timer.function = ap_handle_timer;
 	if (!ap->local->hostapd)
 		add_timer(&sta->timer);
 #endif /* PRISM2_NO_KERNEL_IEEE80211_MGMT */
diff --git a/drivers/net/wireless/hostap/hostap_hw.c b/drivers/net/wireless/hostap/hostap_hw.c
index 6307a4e36c85..2688ed56b1bc 100644
--- a/drivers/net/wireless/hostap/hostap_hw.c
+++ b/drivers/net/wireless/hostap/hostap_hw.c
@@ -3221,13 +3221,10 @@ while (0)
 
 	lib80211_crypt_info_init(&local->crypt_info, dev->name, &local->lock);
 
-	init_timer(&local->passive_scan_timer);
-	local->passive_scan_timer.data = (unsigned long) local;
-	local->passive_scan_timer.function = hostap_passive_scan;
-
-	init_timer(&local->tick_timer);
-	local->tick_timer.data = (unsigned long) local;
-	local->tick_timer.function = hostap_tick_timer;
+	setup_timer(&local->passive_scan_timer, hostap_passive_scan,
+		    (unsigned long)local);
+	setup_timer(&local->tick_timer, hostap_tick_timer,
+		    (unsigned long)local);
 	local->tick_timer.expires = jiffies + 2 * HZ;
 	add_timer(&local->tick_timer);
 
* Unmerged path drivers/nfc/pn533.c
* Unmerged path drivers/nfc/st-nci/ndlc.c
* Unmerged path drivers/nfc/st-nci/se.c
* Unmerged path drivers/nfc/st21nfca/se.c
diff --git a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c
index fed9a313d323..fbf8e45046ec 100644
--- a/drivers/s390/block/dasd.c
+++ b/drivers/s390/block/dasd.c
@@ -119,9 +119,8 @@ struct dasd_device *dasd_alloc_device(void)
 		     (void (*)(unsigned long)) dasd_device_tasklet,
 		     (unsigned long) device);
 	INIT_LIST_HEAD(&device->ccw_queue);
-	init_timer(&device->timer);
-	device->timer.function = dasd_device_timeout;
-	device->timer.data = (unsigned long) device;
+	setup_timer(&device->timer, dasd_device_timeout,
+		    (unsigned long)device);
 	INIT_WORK(&device->kick_work, do_kick_device);
 	INIT_WORK(&device->restore_device, do_restore_device);
 	INIT_WORK(&device->reload_device, do_reload_device);
@@ -164,9 +163,7 @@ struct dasd_block *dasd_alloc_block(void)
 		     (unsigned long) block);
 	INIT_LIST_HEAD(&block->ccw_queue);
 	spin_lock_init(&block->queue_lock);
-	init_timer(&block->timer);
-	block->timer.function = dasd_block_timeout;
-	block->timer.data = (unsigned long) block;
+	setup_timer(&block->timer, dasd_block_timeout, (unsigned long)block);
 	spin_lock_init(&block->profile.lock);
 
 	return block;
diff --git a/drivers/s390/net/fsm.c b/drivers/s390/net/fsm.c
index e5dea67f902e..e9ec0b4f7281 100644
--- a/drivers/s390/net/fsm.c
+++ b/drivers/s390/net/fsm.c
@@ -142,13 +142,11 @@ void
 fsm_settimer(fsm_instance *fi, fsm_timer *this)
 {
 	this->fi = fi;
-	this->tl.function = (void *)fsm_expire_timer;
-	this->tl.data = (long)this;
 #if FSM_TIMER_DEBUG
 	printk(KERN_DEBUG "fsm(%s): Create timer %p\n", fi->name,
 	       this);
 #endif
-	init_timer(&this->tl);
+	setup_timer(&this->tl, (void *)fsm_expire_timer, (long)this);
 }
 
 void
* Unmerged path drivers/scsi/arcmsr/arcmsr_hba.c
diff --git a/drivers/scsi/arm/fas216.c b/drivers/scsi/arm/fas216.c
index 63392e92520f..5aa379ade2e3 100644
--- a/drivers/scsi/arm/fas216.c
+++ b/drivers/scsi/arm/fas216.c
@@ -2844,9 +2844,7 @@ int fas216_init(struct Scsi_Host *host)
 	info->rst_dev_status = -1;
 	info->rst_bus_status = -1;
 	init_waitqueue_head(&info->eh_wait);
-	init_timer(&info->eh_timer);
-	info->eh_timer.data  = (unsigned long)info;
-	info->eh_timer.function = fas216_eh_timer;
+	setup_timer(&info->eh_timer, fas216_eh_timer, (unsigned long)info);
 	
 	spin_lock_init(&info->host_lock);
 
diff --git a/drivers/scsi/bfa/bfad.c b/drivers/scsi/bfa/bfad.c
index 19a75023d025..e677d1dd11e3 100644
--- a/drivers/scsi/bfa/bfad.c
+++ b/drivers/scsi/bfa/bfad.c
@@ -719,9 +719,7 @@ bfad_bfa_tmo(unsigned long data)
 void
 bfad_init_timer(struct bfad_s *bfad)
 {
-	init_timer(&bfad->hal_tmo);
-	bfad->hal_tmo.function = bfad_bfa_tmo;
-	bfad->hal_tmo.data = (unsigned long)bfad;
+	setup_timer(&bfad->hal_tmo, bfad_bfa_tmo, (unsigned long)bfad);
 
 	mod_timer(&bfad->hal_tmo,
 		  jiffies + msecs_to_jiffies(BFA_TIMER_FREQ));
* Unmerged path drivers/scsi/esas2r/esas2r_main.c
diff --git a/drivers/scsi/ncr53c8xx.c b/drivers/scsi/ncr53c8xx.c
index 5982a587babc..ae9f825a73c1 100644
--- a/drivers/scsi/ncr53c8xx.c
+++ b/drivers/scsi/ncr53c8xx.c
@@ -8360,9 +8360,7 @@ struct Scsi_Host * __init ncr_attach(struct scsi_host_template *tpnt,
 	if (!np->scripth0)
 		goto attach_error;
 
-	init_timer(&np->timer);
-	np->timer.data     = (unsigned long) np;
-	np->timer.function = ncr53c8xx_timeout;
+	setup_timer(&np->timer, ncr53c8xx_timeout, (unsigned long)np);
 
 	/* Try to map the controller chip to virtual and physical memory. */
 
diff --git a/drivers/scsi/sym53c8xx_2/sym_glue.c b/drivers/scsi/sym53c8xx_2/sym_glue.c
index 6d3ee1ab6362..6e2be41d5271 100644
--- a/drivers/scsi/sym53c8xx_2/sym_glue.c
+++ b/drivers/scsi/sym53c8xx_2/sym_glue.c
@@ -1353,9 +1353,7 @@ static struct Scsi_Host *sym_attach(struct scsi_host_template *tpnt, int unit,
 	/*
 	 *  Start the timer daemon
 	 */
-	init_timer(&np->s.timer);
-	np->s.timer.data     = (unsigned long) np;
-	np->s.timer.function = sym53c8xx_timer;
+	setup_timer(&np->s.timer, sym53c8xx_timer, (unsigned long)np);
 	np->s.lasttime=0;
 	sym_timer (np);
 
diff --git a/drivers/usb/gadget/omap_udc.c b/drivers/usb/gadget/omap_udc.c
index 91614d068573..557f706ef65e 100644
--- a/drivers/usb/gadget/omap_udc.c
+++ b/drivers/usb/gadget/omap_udc.c
@@ -2550,9 +2550,7 @@ omap_ep_setup(char *name, u8 addr, u8 type,
 		}
 		if (dbuf && addr)
 			epn_rxtx |= UDC_EPN_RX_DB;
-		init_timer(&ep->timer);
-		ep->timer.function = pio_out_timer;
-		ep->timer.data = (unsigned long) ep;
+		setup_timer(&ep->timer, pio_out_timer, (unsigned long)ep);
 	}
 	if (addr)
 		epn_rxtx |= UDC_EPN_RX_VALID;
diff --git a/drivers/video/omap2/dss/dsi.c b/drivers/video/omap2/dss/dsi.c
index a73dedc33101..b061ecff46b0 100644
--- a/drivers/video/omap2/dss/dsi.c
+++ b/drivers/video/omap2/dss/dsi.c
@@ -5498,9 +5498,7 @@ static int omap_dsihw_probe(struct platform_device *dsidev)
 			     dsi_framedone_timeout_work_callback);
 
 #ifdef DSI_CATCH_MISSING_TE
-	init_timer(&dsi->te_timer);
-	dsi->te_timer.function = dsi_te_timeout;
-	dsi->te_timer.data = 0;
+	setup_timer(&dsi->te_timer, dsi_te_timeout, 0);
 #endif
 	dsi_mem = platform_get_resource(dsi->pdev, IORESOURCE_MEM, 0);
 	if (!dsi_mem) {
diff --git a/kernel/time/clocksource.c b/kernel/time/clocksource.c
index 036ef072fc3b..de89144cf3a2 100644
--- a/kernel/time/clocksource.c
+++ b/kernel/time/clocksource.c
@@ -279,8 +279,7 @@ static inline void clocksource_start_watchdog(void)
 {
 	if (watchdog_running || !watchdog || list_empty(&watchdog_list))
 		return;
-	init_timer(&watchdog_timer);
-	watchdog_timer.function = clocksource_watchdog;
+	setup_timer(&watchdog_timer, clocksource_watchdog, 0UL);
 	watchdog_timer.expires = jiffies + WATCHDOG_INTERVAL;
 	add_timer_on(&watchdog_timer, cpumask_first(cpu_online_mask));
 	watchdog_running = 1;
