vmware: set cpu capabilities during platform initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Juergen Gross <jgross@suse.com>
commit d40342a2ac035444897e5952ea72a50440a2a028
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d40342a2.failed

There is no need to set the same capabilities for each cpu
individually. This can be done for all cpus in platform initialization.

	Cc: Alok Kataria <akataria@vmware.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: x86@kernel.org
	Cc: virtualization@lists.linux-foundation.org
	Signed-off-by: Juergen Gross <jgross@suse.com>
	Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Acked-by: Alok Kataria <akataria@vmware.com>
	Signed-off-by: Juergen Gross <jgross@suse.com>
(cherry picked from commit d40342a2ac035444897e5952ea72a50440a2a028)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/vmware.c
diff --cc arch/x86/kernel/cpu/vmware.c
index 66d19c4a4b0a,40ed26852ebd..000000000000
--- a/arch/x86/kernel/cpu/vmware.c
+++ b/arch/x86/kernel/cpu/vmware.c
@@@ -56,27 -63,74 +56,95 @@@ static inline int __vmware_platform(voi
  
  static unsigned long vmware_get_tsc_khz(void)
  {
 -	return vmware_tsc_khz;
 +	uint64_t tsc_hz, lpj;
 +	uint32_t eax, ebx, ecx, edx;
 +
 +	VMWARE_PORT(GETHZ, eax, ebx, ecx, edx);
 +
 +	tsc_hz = eax | (((uint64_t)ebx) << 32);
 +	do_div(tsc_hz, 1000);
 +	BUG_ON(tsc_hz >> 32);
 +	printk(KERN_INFO "TSC freq read from hypervisor : %lu.%03lu MHz\n",
 +			 (unsigned long) tsc_hz / 1000,
 +			 (unsigned long) tsc_hz % 1000);
 +
 +	if (!preset_lpj) {
 +		lpj = ((u64)tsc_hz * 1000);
 +		do_div(lpj, HZ);
 +		preset_lpj = lpj;
 +	}
 +
 +	return tsc_hz;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PARAVIRT
+ static struct cyc2ns_data vmware_cyc2ns __ro_after_init;
+ static int vmw_sched_clock __initdata = 1;
+ 
+ static __init int setup_vmw_sched_clock(char *s)
+ {
+ 	vmw_sched_clock = 0;
+ 	return 0;
+ }
+ early_param("no-vmw-sched-clock", setup_vmw_sched_clock);
+ 
+ static unsigned long long vmware_sched_clock(void)
+ {
+ 	unsigned long long ns;
+ 
+ 	ns = mul_u64_u32_shr(rdtsc(), vmware_cyc2ns.cyc2ns_mul,
+ 			     vmware_cyc2ns.cyc2ns_shift);
+ 	ns -= vmware_cyc2ns.cyc2ns_offset;
+ 	return ns;
+ }
+ 
+ static void __init vmware_sched_clock_setup(void)
+ {
+ 	struct cyc2ns_data *d = &vmware_cyc2ns;
+ 	unsigned long long tsc_now = rdtsc();
+ 
+ 	clocks_calc_mult_shift(&d->cyc2ns_mul, &d->cyc2ns_shift,
+ 			       vmware_tsc_khz, NSEC_PER_MSEC, 0);
+ 	d->cyc2ns_offset = mul_u64_u32_shr(tsc_now, d->cyc2ns_mul,
+ 					   d->cyc2ns_shift);
+ 
+ 	pv_time_ops.sched_clock = vmware_sched_clock;
+ 	pr_info("using sched offset of %llu ns\n", d->cyc2ns_offset);
+ }
+ 
+ static void __init vmware_paravirt_ops_setup(void)
+ {
+ 	pv_info.name = "VMware hypervisor";
+ 	pv_cpu_ops.io_delay = paravirt_nop;
+ 
+ 	if (vmware_tsc_khz && vmw_sched_clock)
+ 		vmware_sched_clock_setup();
+ }
+ #else
+ #define vmware_paravirt_ops_setup() do {} while (0)
+ #endif
+ 
+ /*
+  * VMware hypervisor takes care of exporting a reliable TSC to the guest.
+  * Still, due to timing difference when running on virtual cpus, the TSC can
+  * be marked as unstable in some cases. For example, the TSC sync check at
+  * bootup can fail due to a marginal offset between vcpus' TSCs (though the
+  * TSCs do not drift from each other).  Also, the ACPI PM timer clocksource
+  * is not suitable as a watchdog when running on a hypervisor because the
+  * kernel may miss a wrap of the counter if the vcpu is descheduled for a
+  * long time. To skip these checks at runtime we set these capability bits,
+  * so that the kernel could just trust the hypervisor with providing a
+  * reliable virtual TSC that is suitable for timekeeping.
+  */
+ static void __init vmware_set_capabilities(void)
+ {
+ 	setup_force_cpu_cap(X86_FEATURE_CONSTANT_TSC);
+ 	setup_force_cpu_cap(X86_FEATURE_TSC_RELIABLE);
+ }
+ 
++>>>>>>> d40342a2ac03 (vmware: set cpu capabilities during platform initialization)
  static void __init vmware_platform_setup(void)
  {
  	uint32_t eax, ebx, ecx, edx;
* Unmerged path arch/x86/kernel/cpu/vmware.c
