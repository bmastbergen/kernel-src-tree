scsi: qla2xxx: Fix retry for PRLI RJT with reason of BUSY

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Fix retry for PRLI RJT with reason of BUSY (Himanshu Madhani) [1547714]
Rebuild_FUZZ: 94.44%
commit-author Darren Trapp <darren.trapp@cavium.com>
commit 1cbc0efcd9bee74670d0b637f53e67c47373f544
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1cbc0efc.failed

	Signed-off-by: Darren Trapp <darren.trapp@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 1cbc0efcd9bee74670d0b637f53e67c47373f544)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_dbg.c
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_mbx.c
diff --cc drivers/scsi/qla2xxx/qla_dbg.c
index 9f6f7c8ab0d2,1abc8a9064b3..000000000000
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@@ -61,7 -60,7 +61,11 @@@
   * |                              |                    | 0xb13c-0xb140  |
   * |                              |                    | 0xb149		|
   * | MultiQ                       |       0xc010       |		|
++<<<<<<< HEAD
 + * | Misc                         |       0xd300       | 0xd031-0xd0ff	|
++=======
+  * | Misc                         |       0xd303       | 0xd031-0xd0ff	|
++>>>>>>> 1cbc0efcd9be (scsi: qla2xxx: Fix retry for PRLI RJT with reason of BUSY)
   * |                              |                    | 0xd101-0xd1fe	|
   * |                              |                    | 0xd214-0xd2fe	|
   * | Target Mode		  |	  0xe081       |		|
diff --cc drivers/scsi/qla2xxx/qla_init.c
index f74932ce86ba,15a96dc205d0..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -675,8 -826,103 +675,108 @@@ gpd_error_out
  	sp->free(sp);
  }
  
++<<<<<<< HEAD
 +static int qla24xx_post_gpdb_work(struct scsi_qla_host *vha, fc_port_t *fcport,
 +    u8 opt)
++=======
+ static int qla24xx_post_prli_work(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	struct qla_work_evt *e;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_PRLI);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ static void
+ qla2x00_async_prli_sp_done(void *ptr, int res)
+ {
+ 	srb_t *sp = ptr;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	struct srb_iocb *lio = &sp->u.iocb_cmd;
+ 	struct event_arg ea;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x2129,
+ 	    "%s %8phC res %d \n", __func__,
+ 	    sp->fcport->port_name, res);
+ 
+ 	sp->fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	if (!test_bit(UNLOADING, &vha->dpc_flags)) {
+ 		memset(&ea, 0, sizeof(ea));
+ 		ea.event = FCME_PRLI_DONE;
+ 		ea.fcport = sp->fcport;
+ 		ea.data[0] = lio->u.logio.data[0];
+ 		ea.data[1] = lio->u.logio.data[1];
+ 		ea.iop[0] = lio->u.logio.iop[0];
+ 		ea.iop[1] = lio->u.logio.iop[1];
+ 		ea.sp = sp;
+ 
+ 		qla2x00_fcport_event_handler(vha, &ea);
+ 	}
+ 
+ 	sp->free(sp);
+ }
+ 
+ int
+ qla24xx_async_prli(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	srb_t *sp;
+ 	struct srb_iocb *lio;
+ 	int rval = QLA_FUNCTION_FAILED;
+ 
+ 	if (!vha->flags.online)
+ 		return rval;
+ 
+ 	if (fcport->fw_login_state == DSC_LS_PLOGI_PEND ||
+ 	    fcport->fw_login_state == DSC_LS_PRLI_PEND)
+ 		return rval;
+ 
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		return rval;
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	fcport->logout_completed = 0;
+ 
+ 	sp->type = SRB_PRLI_CMD;
+ 	sp->name = "prli";
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	lio = &sp->u.iocb_cmd;
+ 	lio->timeout = qla2x00_async_iocb_timeout;
+ 	sp->done = qla2x00_async_prli_sp_done;
+ 	lio->u.logio.flags = 0;
+ 
+ 	if  (fcport->fc4f_nvme)
+ 		lio->u.logio.flags |= SRB_LOGIN_NVME_PRLI;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS) {
+ 		fcport->flags |= FCF_LOGIN_NEEDED;
+ 		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 		goto done_free_sp;
+ 	}
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x211b,
+ 	    "Async-prli - %8phC hdl=%x, loopid=%x portid=%06x retries=%d.\n",
+ 	    fcport->port_name, sp->handle, fcport->loop_id,
+ 	    fcport->d_id.b24, fcport->login_retry);
+ 
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	return rval;
+ }
+ 
+ int qla24xx_post_gpdb_work(struct scsi_qla_host *vha, fc_port_t *fcport, u8 opt)
++>>>>>>> 1cbc0efcd9be (scsi: qla2xxx: Fix retry for PRLI RJT with reason of BUSY)
  {
  	struct qla_work_evt *e;
  
@@@ -923,12 -1231,17 +1023,17 @@@ int qla24xx_fcport_handle_login(struct 
  	case DSC_LOGIN_COMPLETE:
  		/* recheck login state */
  		ql_dbg(ql_dbg_disc, vha, 0x20d1,
 -		    "%s %d %8phC post adisc\n",
 +		    "%s %d %8phC post gpdb\n",
  		    __func__, __LINE__, fcport->port_name);
 -		data[0] = data[1] = 0;
 -		qla2x00_post_async_adisc_work(vha, fcport, data);
 +
 +		qla24xx_post_gpdb_work(vha, fcport, PDO_FORCE_ADISC);
  		break;
  
+ 	case DSC_LOGIN_PEND:
+ 		if (fcport->fw_login_state == DSC_LS_PLOGI_COMP)
+ 			qla24xx_post_prli_work(vha, fcport);
+ 		break;
+ 
  	default:
  		break;
  	}
@@@ -1331,6 -1631,42 +1436,45 @@@ qla24xx_async_abort_command(srb_t *sp
  }
  
  static void
++<<<<<<< HEAD
++=======
+ qla24xx_handle_prli_done_event(struct scsi_qla_host *vha, struct event_arg *ea)
+ {
+ 	switch (ea->data[0]) {
+ 	case MBS_COMMAND_COMPLETE:
+ 		ql_dbg(ql_dbg_disc, vha, 0x2118,
+ 		    "%s %d %8phC post gpdb\n",
+ 		    __func__, __LINE__, ea->fcport->port_name);
+ 
+ 		ea->fcport->chip_reset = vha->hw->base_qpair->chip_reset;
+ 		ea->fcport->logout_on_delete = 1;
+ 		qla24xx_post_gpdb_work(vha, ea->fcport, 0);
+ 		break;
+ 	default:
+ 		if ((ea->iop[0] == LSC_SCODE_ELS_REJECT) &&
+ 		    (ea->iop[1] == 0x50000)) {   /* reson 5=busy expl:0x0 */
+ 			set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 			ea->fcport->fw_login_state = DSC_LS_PLOGI_COMP;
+ 			break;
+ 		}
+ 
+ 		if (ea->fcport->n2n_flag) {
+ 			ql_dbg(ql_dbg_disc, vha, 0x2118,
+ 				"%s %d %8phC post fc4 prli\n",
+ 				__func__, __LINE__, ea->fcport->port_name);
+ 			ea->fcport->fc4f_nvme = 0;
+ 			ea->fcport->n2n_flag = 0;
+ 			qla24xx_post_prli_work(vha, ea->fcport);
+ 		}
+ 		ql_dbg(ql_dbg_disc, vha, 0x2119,
+ 		    "%s %d %8phC unhandle event of %x\n",
+ 		    __func__, __LINE__, ea->fcport->port_name, ea->data[0]);
+ 		break;
+ 	}
+ }
+ 
+ static void
++>>>>>>> 1cbc0efcd9be (scsi: qla2xxx: Fix retry for PRLI RJT with reason of BUSY)
  qla24xx_handle_plogi_done_event(struct scsi_qla_host *vha, struct event_arg *ea)
  {
  	port_id_t cid;	/* conflict Nport id */
diff --cc drivers/scsi/qla2xxx/qla_mbx.c
index 5997303a0944,c9a134ae0d2b..000000000000
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@@ -965,6 -1020,17 +965,20 @@@ qla2x00_get_fw_version(scsi_qla_host_t 
  			ql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1191,
  			    "%s: Firmware supports Exchange Offload 0x%x\n",
  			    __func__, ha->fw_attributes_h);
++<<<<<<< HEAD
++=======
+ 
+ 		/*
+ 		 * FW supports nvme and driver load parameter requested nvme.
+ 		 * BIT 26 of fw_attributes indicates NVMe support.
+ 		 */
+ 		if ((ha->fw_attributes_h & 0x400) && ql2xnvmeenable) {
+ 			vha->flags.nvme_enabled = 1;
+ 			ql_log(ql_log_info, vha, 0xd302,
+ 			    "%s: FC-NVMe is Enabled (0x%x)\n",
+ 			     __func__, ha->fw_attributes_h);
+ 		}
++>>>>>>> 1cbc0efcd9be (scsi: qla2xxx: Fix retry for PRLI RJT with reason of BUSY)
  	}
  
  	if (IS_QLA27XX(ha)) {
* Unmerged path drivers/scsi/qla2xxx/qla_dbg.c
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
* Unmerged path drivers/scsi/qla2xxx/qla_mbx.c
