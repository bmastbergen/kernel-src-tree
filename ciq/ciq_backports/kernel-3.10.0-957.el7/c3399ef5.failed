mmc: core: rename mmc_start_req() to *areq()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] core: rename mmc_start_req() to *areq() (Gopal Tiwari) [1549495]
Rebuild_FUZZ: 93.98%
commit-author Linus Walleij <linus.walleij@linaro.org>
commit c3399ef55d8e8295293808eba32e3f7056526324
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c3399ef5.failed

With the coexisting __mmc_start_request(), mmc_start_request()
and __mmc_start_req() it is a bit confusing that mmc_start_req()
actually does not start a normal request, but an asynchronous
request.

Rename it to mmc_start_areq() to make it explicit what the
function is doing, also fix the kerneldoc for this function
while we're at it.

	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit c3399ef55d8e8295293808eba32e3f7056526324)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/block.c
#	include/linux/mmc/core.h
diff --cc drivers/mmc/core/block.c
index d7cc8dd6684d,8e1aa8d80e76..000000000000
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@@ -1586,7 -1587,34 +1586,38 @@@ static int mmc_blk_cmd_err(struct mmc_b
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)
++=======
+ static void mmc_blk_rw_cmd_abort(struct mmc_card *card, struct request *req)
+ {
+ 	int ret = 1;
+ 
+ 	if (mmc_card_removed(card))
+ 		req->rq_flags |= RQF_QUIET;
+ 	while (ret)
+ 		ret = blk_end_request(req, -EIO,
+ 				      blk_rq_cur_bytes(req));
+ }
+ 
+ static void mmc_blk_rw_start_new(struct mmc_queue *mq, struct mmc_card *card,
+ 				 struct request *req)
+ {
+ 	if (!req)
+ 		return;
+ 
+ 	if (mmc_card_removed(card)) {
+ 		req->rq_flags |= RQF_QUIET;
+ 		blk_end_request_all(req, -EIO);
+ 	} else {
+ 		mmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);
+ 		mmc_start_areq(card->host,
+ 			       &mq->mqrq_cur->mmc_active, NULL);
+ 	}
+ }
+ 
+ static void mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *new_req)
++>>>>>>> c3399ef55d8e (mmc: core: rename mmc_start_req() to *areq())
  {
  	struct mmc_blk_data *md = mq->blkdata;
  	struct mmc_card *card = md->queue.card;
diff --cc include/linux/mmc/core.h
index e33cc748dcfe,a0c63ea28796..000000000000
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@@ -159,79 -158,14 +159,88 @@@ struct mmc_request 
  struct mmc_card;
  struct mmc_async_req;
  
++<<<<<<< HEAD
 +extern int mmc_stop_bkops(struct mmc_card *);
 +extern int mmc_read_bkops_status(struct mmc_card *);
 +extern struct mmc_async_req *mmc_start_req(struct mmc_host *,
 +					   struct mmc_async_req *,
 +					   enum mmc_blk_status *);
 +extern int mmc_interrupt_hpi(struct mmc_card *);
 +extern void mmc_wait_for_req(struct mmc_host *, struct mmc_request *);
 +extern void mmc_wait_for_req_done(struct mmc_host *host,
 +				  struct mmc_request *mrq);
 +extern bool mmc_is_req_done(struct mmc_host *host, struct mmc_request *mrq);
 +extern int mmc_wait_for_cmd(struct mmc_host *, struct mmc_command *, int);
 +extern int mmc_app_cmd(struct mmc_host *, struct mmc_card *);
 +extern int mmc_wait_for_app_cmd(struct mmc_host *, struct mmc_card *,
 +	struct mmc_command *, int);
 +extern void mmc_start_bkops(struct mmc_card *card, bool from_exception);
 +extern int mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int);
 +extern int mmc_send_tuning(struct mmc_host *host, u32 opcode, int *cmd_error);
 +extern int mmc_abort_tuning(struct mmc_host *host, u32 opcode);
 +extern int mmc_get_ext_csd(struct mmc_card *card, u8 **new_ext_csd);
++=======
+ struct mmc_async_req *mmc_start_areq(struct mmc_host *host,
+ 				struct mmc_async_req *areq,
+ 				enum mmc_blk_status *ret_stat);
+ void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq);
+ int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd,
+ 		int retries);
 -
 -int mmc_hw_reset(struct mmc_host *host);
 -void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card);
++>>>>>>> c3399ef55d8e (mmc: core: rename mmc_start_req() to *areq())
 +
 +#define MMC_ERASE_ARG		0x00000000
 +#define MMC_SECURE_ERASE_ARG	0x80000000
 +#define MMC_TRIM_ARG		0x00000001
 +#define MMC_DISCARD_ARG		0x00000003
 +#define MMC_SECURE_TRIM1_ARG	0x80000001
 +#define MMC_SECURE_TRIM2_ARG	0x80008000
 +
 +#define MMC_SECURE_ARGS		0x80000000
 +#define MMC_TRIM_ARGS		0x00008001
 +
 +extern int mmc_erase(struct mmc_card *card, unsigned int from, unsigned int nr,
 +		     unsigned int arg);
 +extern int mmc_can_erase(struct mmc_card *card);
 +extern int mmc_can_trim(struct mmc_card *card);
 +extern int mmc_can_discard(struct mmc_card *card);
 +extern int mmc_can_sanitize(struct mmc_card *card);
 +extern int mmc_can_secure_erase_trim(struct mmc_card *card);
 +extern int mmc_erase_group_aligned(struct mmc_card *card, unsigned int from,
 +				   unsigned int nr);
 +extern unsigned int mmc_calc_max_discard(struct mmc_card *card);
 +
 +extern int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen);
 +extern int mmc_set_blockcount(struct mmc_card *card, unsigned int blockcount,
 +			      bool is_rel_write);
 +extern int mmc_hw_reset(struct mmc_host *host);
 +extern int mmc_can_reset(struct mmc_card *card);
 +
 +extern void mmc_set_data_timeout(struct mmc_data *, const struct mmc_card *);
 +extern unsigned int mmc_align_data_size(struct mmc_card *, unsigned int);
 +
 +extern int __mmc_claim_host(struct mmc_host *host, atomic_t *abort);
 +extern void mmc_release_host(struct mmc_host *host);
 +
 +extern void mmc_get_card(struct mmc_card *card);
 +extern void mmc_put_card(struct mmc_card *card);
 +
 +extern int mmc_flush_cache(struct mmc_card *);
 +
 +extern int mmc_detect_card_removed(struct mmc_host *host);
 +
 +/**
 + *	mmc_claim_host - exclusively claim a host
 + *	@host: mmc host to claim
 + *
 + *	Claim a host for a set of operations.
 + */
 +static inline void mmc_claim_host(struct mmc_host *host)
 +{
 +	__mmc_claim_host(host, NULL);
 +}
 +
 +struct device_node;
 +extern u32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max);
 +extern int mmc_of_parse_voltage(struct device_node *np, u32 *mask);
  
  #endif /* LINUX_MMC_CORE_H */
* Unmerged path drivers/mmc/core/block.c
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 2669557edd36..c4d4fc16bfa5 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -629,10 +629,10 @@ static void mmc_post_req(struct mmc_host *host, struct mmc_request *mrq,
 }
 
 /**
- *	mmc_start_req - start a non-blocking request
+ *	mmc_start_areq - start an asynchronous request
  *	@host: MMC host to start command
- *	@areq: async request to start
- *	@error: out parameter returns 0 for success, otherwise non zero
+ *	@areq: asynchronous request to start
+ *	@ret_stat: out parameter for status
  *
  *	Start a new MMC custom command request for a host.
  *	If there is on ongoing async request wait for completion
@@ -644,9 +644,9 @@ static void mmc_post_req(struct mmc_host *host, struct mmc_request *mrq,
  *	return the completed request. If there is no ongoing request, NULL
  *	is returned without waiting. NULL is not an error condition.
  */
-struct mmc_async_req *mmc_start_req(struct mmc_host *host,
-				    struct mmc_async_req *areq,
-				    enum mmc_blk_status *ret_stat)
+struct mmc_async_req *mmc_start_areq(struct mmc_host *host,
+				     struct mmc_async_req *areq,
+				     enum mmc_blk_status *ret_stat)
 {
 	enum mmc_blk_status status = MMC_BLK_SUCCESS;
 	int start_err = 0;
@@ -706,7 +706,7 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 		*ret_stat = status;
 	return data;
 }
-EXPORT_SYMBOL(mmc_start_req);
+EXPORT_SYMBOL(mmc_start_areq);
 
 /**
  *	mmc_wait_for_req - start a request and wait for completion
diff --git a/drivers/mmc/core/mmc_test.c b/drivers/mmc/core/mmc_test.c
index bd8eb9bfc153..6c82574233f1 100644
--- a/drivers/mmc/core/mmc_test.c
+++ b/drivers/mmc/core/mmc_test.c
@@ -850,7 +850,7 @@ static int mmc_test_nonblock_transfer(struct mmc_test_card *test,
 	for (i = 0; i < count; i++) {
 		mmc_test_prepare_mrq(test, cur_areq->mrq, sg, sg_len, dev_addr,
 				     blocks, blksz, write);
-		done_areq = mmc_start_req(test->card->host, cur_areq, &status);
+		done_areq = mmc_start_areq(test->card->host, cur_areq, &status);
 
 		if (status != MMC_BLK_SUCCESS || (!done_areq && i > 0)) {
 			ret = RESULT_FAIL;
@@ -869,7 +869,7 @@ static int mmc_test_nonblock_transfer(struct mmc_test_card *test,
 		dev_addr += blocks;
 	}
 
-	done_areq = mmc_start_req(test->card->host, NULL, &status);
+	done_areq = mmc_start_areq(test->card->host, NULL, &status);
 	if (status != MMC_BLK_SUCCESS)
 		ret = RESULT_FAIL;
 
@@ -2399,7 +2399,7 @@ static int mmc_test_ongoing_transfer(struct mmc_test_card *test,
 
 	/* Start ongoing data request */
 	if (use_areq) {
-		mmc_start_req(host, &test_areq.areq, &blkstat);
+		mmc_start_areq(host, &test_areq.areq, &blkstat);
 		if (blkstat != MMC_BLK_SUCCESS) {
 			ret = RESULT_FAIL;
 			goto out_free;
@@ -2437,7 +2437,7 @@ static int mmc_test_ongoing_transfer(struct mmc_test_card *test,
 
 	/* Wait for data request to complete */
 	if (use_areq) {
-		mmc_start_req(host, NULL, &blkstat);
+		mmc_start_areq(host, NULL, &blkstat);
 		if (blkstat != MMC_BLK_SUCCESS)
 			ret = RESULT_FAIL;
 	} else {
* Unmerged path include/linux/mmc/core.h
