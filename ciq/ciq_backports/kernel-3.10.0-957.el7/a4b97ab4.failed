net/mlx5: E-Switch, Create generic header struct to be used by representors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Create generic header struct to be used by representors (Alaa Hleihel) [1591249]
Rebuild_FUZZ: 97.26%
commit-author Mark Bloch <markb@mellanox.com>
commit a4b97ab4211fd0cf1011623c79fe2204dc023b96
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/a4b97ab4.failed

Now that we don't store type dependent data in struct mlx5_eswitch_rep
we can create a generic interface, and representor type.

struct mlx5_eswitch_rep will store an array of interfaces, each
interface is used by a different representor type.

Once we moved to a more generic interface, rdma driver representors can
be added and utilize the same mechanism as the Ethernet driver
representors use.

	Signed-off-by: Mark Bloch <markb@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit a4b97ab4211fd0cf1011623c79fe2204dc023b96)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 1f6b50ed685e,5b2b673c0b13..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -1092,8 -1084,10 +1092,13 @@@ mlx5e_vport_rep_load(struct mlx5_eswitc
  		return -EINVAL;
  	}
  
 -	rpriv->netdev = netdev;
 +	rep->netdev = netdev;
  	rpriv->rep = rep;
++<<<<<<< HEAD
++=======
+ 	rep->rep_if[REP_ETH].priv = rpriv;
+ 	INIT_LIST_HEAD(&rpriv->vport_sqs_list);
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  
  	err = mlx5e_attach_netdev(netdev_priv(netdev));
  	if (err) {
@@@ -1109,6 -1103,13 +1114,16 @@@
  		goto err_detach_netdev;
  	}
  
++<<<<<<< HEAD
++=======
+ 	uplink_rpriv = mlx5_eswitch_get_uplink_priv(dev->priv.eswitch, REP_ETH);
+ 	upriv = netdev_priv(uplink_rpriv->netdev);
+ 	err = tc_setup_cb_egdev_register(netdev, mlx5e_setup_tc_block_cb,
+ 					 upriv);
+ 	if (err)
+ 		goto err_neigh_cleanup;
+ 
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  	err = register_netdev(netdev);
  	if (err) {
  		pr_warn("Failed to register representor netdev for vport %d\n",
@@@ -1131,15 -1136,21 +1146,24 @@@ err_destroy_netdev
  }
  
  static void
 -mlx5e_vport_rep_unload(struct mlx5_eswitch_rep *rep)
 +mlx5e_vport_rep_unload(struct mlx5_eswitch *esw, struct mlx5_eswitch_rep *rep)
  {
 -	struct mlx5e_rep_priv *rpriv = mlx5e_rep_to_rep_priv(rep);
 -	struct net_device *netdev = rpriv->netdev;
 +	struct net_device *netdev = rep->netdev;
  	struct mlx5e_priv *priv = netdev_priv(netdev);
 -	struct mlx5e_rep_priv *uplink_rpriv;
 +	struct mlx5e_rep_priv *rpriv = priv->ppriv;
  	void *ppriv = priv->ppriv;
 -	struct mlx5e_priv *upriv;
  
++<<<<<<< HEAD
 +	unregister_netdev(rep->netdev);
 +
++=======
+ 	unregister_netdev(netdev);
+ 	uplink_rpriv = mlx5_eswitch_get_uplink_priv(priv->mdev->priv.eswitch,
+ 						    REP_ETH);
+ 	upriv = netdev_priv(uplink_rpriv->netdev);
+ 	tc_setup_cb_egdev_unregister(netdev, mlx5e_setup_tc_block_cb,
+ 				     upriv);
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  	mlx5e_rep_neigh_cleanup(rpriv);
  	mlx5e_detach_netdev(priv);
  	mlx5e_destroy_netdev(priv);
@@@ -1154,11 -1165,11 +1178,15 @@@ static void mlx5e_rep_register_vf_vport
  	int vport;
  
  	for (vport = 1; vport < total_vfs; vport++) {
++<<<<<<< HEAD
 +		struct mlx5_eswitch_rep rep;
++=======
+ 		struct mlx5_eswitch_rep_if rep_if = {};
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  
- 		rep.load = mlx5e_vport_rep_load;
- 		rep.unload = mlx5e_vport_rep_unload;
- 		mlx5_eswitch_register_vport_rep(esw, vport, &rep);
+ 		rep_if.load = mlx5e_vport_rep_load;
+ 		rep_if.unload = mlx5e_vport_rep_unload;
+ 		mlx5_eswitch_register_vport_rep(esw, vport, &rep_if, REP_ETH);
  	}
  }
  
@@@ -1177,12 -1188,17 +1205,26 @@@ void mlx5e_register_vport_reps(struct m
  {
  	struct mlx5_core_dev *mdev = priv->mdev;
  	struct mlx5_eswitch *esw   = mdev->priv.eswitch;
++<<<<<<< HEAD
 +	struct mlx5_eswitch_rep rep;
 +
 +	rep.load = mlx5e_nic_rep_load;
 +	rep.unload = mlx5e_nic_rep_unload;
 +	rep.netdev = priv->netdev;
 +	mlx5_eswitch_register_vport_rep(esw, 0, &rep); /* UPLINK PF vport*/
++=======
+ 	struct mlx5_eswitch_rep_if rep_if;
+ 	struct mlx5e_rep_priv *rpriv;
+ 
+ 	rpriv = priv->ppriv;
+ 	rpriv->netdev = priv->netdev;
+ 
+ 	rep_if.load = mlx5e_nic_rep_load;
+ 	rep_if.unload = mlx5e_nic_rep_unload;
+ 	rep_if.priv = rpriv;
+ 	INIT_LIST_HEAD(&rpriv->vport_sqs_list);
+ 	mlx5_eswitch_register_vport_rep(esw, 0, &rep_if, REP_ETH); /* UPLINK PF vport*/
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  
  	mlx5e_rep_register_vf_vports(priv); /* VFs vports */
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index 5659ed9f51e6,e4473a9ebd50..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@@ -56,8 -56,17 +56,17 @@@ struct mlx5e_neigh_update_table 
  struct mlx5e_rep_priv {
  	struct mlx5_eswitch_rep *rep;
  	struct mlx5e_neigh_update_table neigh_update;
 -	struct net_device      *netdev;
 -	struct mlx5_flow_handle *vport_rx_rule;
 -	struct list_head       vport_sqs_list;
  };
  
++<<<<<<< HEAD
++=======
+ static inline
+ struct mlx5e_rep_priv *mlx5e_rep_to_rep_priv(struct mlx5_eswitch_rep *rep)
+ {
+ 	return (struct mlx5e_rep_priv *)rep->rep_if[REP_ETH].priv;
+ }
+ 
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  struct mlx5e_neigh {
  	struct net_device *dev;
  	union {
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 63cafbf82fe8,259e91e2d09a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -1085,7 -617,8 +1085,12 @@@ static int parse_tunnel_attr(struct mlx
  						  FLOW_DISSECTOR_KEY_ENC_PORTS,
  						  f->mask);
  		struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
++<<<<<<< HEAD
 +		struct net_device *up_dev = mlx5_eswitch_get_uplink_netdev(esw);
++=======
+ 		struct mlx5e_rep_priv *uplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);
+ 		struct net_device *up_dev = uplink_rpriv->netdev;
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  		struct mlx5e_priv *up_priv = netdev_priv(up_dev);
  
  		/* Full udp dst port must be given */
@@@ -2019,9 -1522,10 +2024,13 @@@ static int mlx5e_route_lookup_ipv4(stru
  #else
  	return -EOPNOTSUPP;
  #endif
++<<<<<<< HEAD
++=======
+ 	uplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  	/* if the egress device isn't on the same HW e-switch, we use the uplink */
  	if (!switchdev_port_same_parent_id(priv->netdev, rt->dst.dev))
 -		*out_dev = uplink_rpriv->netdev;
 +		*out_dev = mlx5_eswitch_get_uplink_netdev(esw);
  	else
  		*out_dev = rt->dst.dev;
  
@@@ -2057,9 -1561,10 +2066,13 @@@ static int mlx5e_route_lookup_ipv6(stru
  
  	*out_ttl = ip6_dst_hoplimit(dst);
  
++<<<<<<< HEAD
++=======
+ 	uplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  	/* if the egress device isn't on the same HW e-switch, we use the uplink */
  	if (!switchdev_port_same_parent_id(priv->netdev, dst->dev))
 -		*out_dev = uplink_rpriv->netdev;
 +		*out_dev = mlx5_eswitch_get_uplink_netdev(esw);
  	else
  		*out_dev = dst->dev;
  #else
@@@ -2359,7 -1864,9 +2372,13 @@@ static int mlx5e_attach_encap(struct ml
  			      struct mlx5e_tc_flow *flow)
  {
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
++<<<<<<< HEAD
 +	struct net_device *up_dev = mlx5_eswitch_get_uplink_netdev(esw);
++=======
+ 	struct mlx5e_rep_priv *uplink_rpriv = mlx5_eswitch_get_uplink_priv(esw,
+ 									   REP_ETH);
+ 	struct net_device *up_dev = uplink_rpriv->netdev;
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  	unsigned short family = ip_tunnel_info_af(tun_info);
  	struct mlx5e_priv *up_priv = netdev_priv(up_dev);
  	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 288cff3a0677,91175965df7f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -146,20 -143,21 +151,33 @@@ struct mlx5_esw_sq 
  	struct list_head	 list;
  };
  
++<<<<<<< HEAD
 +struct mlx5_eswitch_rep {
 +	int		       (*load)(struct mlx5_eswitch *esw,
 +				       struct mlx5_eswitch_rep *rep);
 +	void		       (*unload)(struct mlx5_eswitch *esw,
 +					 struct mlx5_eswitch_rep *rep);
++=======
+ struct mlx5_eswitch_rep;
+ struct mlx5_eswitch_rep_if {
+ 	int		       (*load)(struct mlx5_core_dev *dev,
+ 				       struct mlx5_eswitch_rep *rep);
+ 	void		       (*unload)(struct mlx5_eswitch_rep *rep);
+ 	void			*priv;
+ 	bool		       valid;
+ };
+ 
+ struct mlx5_eswitch_rep {
+ 	struct mlx5_eswitch_rep_if rep_if[NUM_REP_TYPES];
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  	u16		       vport;
  	u8		       hw_id[ETH_ALEN];
 +	struct net_device      *netdev;
 +
 +	struct mlx5_flow_handle *vport_rx_rule;
 +	struct list_head       vport_sqs_list;
  	u16		       vlan;
  	u32		       vlan_refcount;
- 	bool		       valid;
  };
  
  struct mlx5_esw_offload {
@@@ -280,10 -278,12 +298,17 @@@ int mlx5_devlink_eswitch_encap_mode_set
  int mlx5_devlink_eswitch_encap_mode_get(struct devlink *devlink, u8 *encap);
  void mlx5_eswitch_register_vport_rep(struct mlx5_eswitch *esw,
  				     int vport_index,
- 				     struct mlx5_eswitch_rep *rep);
+ 				     struct mlx5_eswitch_rep_if *rep_if,
+ 				     u8 rep_type);
  void mlx5_eswitch_unregister_vport_rep(struct mlx5_eswitch *esw,
++<<<<<<< HEAD
 +				       int vport_index);
 +struct net_device *mlx5_eswitch_get_uplink_netdev(struct mlx5_eswitch *esw);
++=======
+ 				       int vport_index,
+ 				       u8 rep_type);
+ void *mlx5_eswitch_get_uplink_priv(struct mlx5_eswitch *esw, u8 rep_type);
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  
  int mlx5_eswitch_add_vlan_action(struct mlx5_eswitch *esw,
  				 struct mlx5_esw_flow_attr *attr);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 50fceb0bde65,99f583a15cc3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -726,10 -727,10 +727,14 @@@ static void esw_offloads_unload_reps_ty
  
  	for (vport = nvports - 1; vport >= 0; vport--) {
  		rep = &esw->offloads.vport_reps[vport];
- 		if (!rep->valid)
+ 		if (!rep->rep_if[rep_type].valid)
  			continue;
  
++<<<<<<< HEAD
 +		rep->unload(esw, rep);
++=======
+ 		rep->rep_if[rep_type].unload(rep);
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  	}
  }
  
@@@ -741,10 -751,10 +755,14 @@@ static int esw_offloads_load_reps_type(
  
  	for (vport = 0; vport < nvports; vport++) {
  		rep = &esw->offloads.vport_reps[vport];
- 		if (!rep->valid)
+ 		if (!rep->rep_if[rep_type].valid)
  			continue;
  
++<<<<<<< HEAD
 +		err = rep->load(esw, rep);
++=======
+ 		err = rep->rep_if[rep_type].load(esw->dev, rep);
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  		if (err)
  			goto err_reps;
  	}
@@@ -1121,19 -1150,19 +1158,28 @@@ int mlx5_devlink_eswitch_encap_mode_get
  
  void mlx5_eswitch_register_vport_rep(struct mlx5_eswitch *esw,
  				     int vport_index,
- 				     struct mlx5_eswitch_rep *__rep)
+ 				     struct mlx5_eswitch_rep_if *__rep_if,
+ 				     u8 rep_type)
  {
  	struct mlx5_esw_offload *offloads = &esw->offloads;
- 	struct mlx5_eswitch_rep *rep;
+ 	struct mlx5_eswitch_rep_if *rep_if;
  
- 	rep = &offloads->vport_reps[vport_index];
+ 	rep_if = &offloads->vport_reps[vport_index].rep_if[rep_type];
  
++<<<<<<< HEAD
 +	rep->load   = __rep->load;
 +	rep->unload = __rep->unload;
 +	rep->netdev = __rep->netdev;
 +
 +	INIT_LIST_HEAD(&rep->vport_sqs_list);
 +	rep->valid = true;
++=======
+ 	rep_if->load   = __rep_if->load;
+ 	rep_if->unload = __rep_if->unload;
+ 	rep_if->priv = __rep_if->priv;
+ 
+ 	rep_if->valid = true;
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  }
  
  void mlx5_eswitch_unregister_vport_rep(struct mlx5_eswitch *esw,
@@@ -1145,17 -1174,17 +1191,29 @@@
  	rep = &offloads->vport_reps[vport_index];
  
  	if (esw->mode == SRIOV_OFFLOADS && esw->vports[vport_index].enabled)
++<<<<<<< HEAD
 +		rep->unload(esw, rep);
++=======
+ 		rep->rep_if[rep_type].unload(rep);
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  
- 	rep->valid = false;
+ 	rep->rep_if[rep_type].valid = false;
  }
  
++<<<<<<< HEAD
 +struct net_device *mlx5_eswitch_get_uplink_netdev(struct mlx5_eswitch *esw)
++=======
+ void *mlx5_eswitch_get_uplink_priv(struct mlx5_eswitch *esw, u8 rep_type)
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  {
  #define UPLINK_REP_INDEX 0
  	struct mlx5_esw_offload *offloads = &esw->offloads;
  	struct mlx5_eswitch_rep *rep;
  
  	rep = &offloads->vport_reps[UPLINK_REP_INDEX];
++<<<<<<< HEAD
 +	return rep->netdev;
++=======
+ 	return rep->rep_if[rep_type].priv;
++>>>>>>> a4b97ab4211f (net/mlx5: E-Switch, Create generic header struct to be used by representors)
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
