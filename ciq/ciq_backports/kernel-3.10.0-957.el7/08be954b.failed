Input: psmouse - move sliced command implementation to libps2

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [input] psmouse - move sliced command implementation to libps2 (Benjamin Tissoires) [1554926]
Rebuild_FUZZ: 93.91%
commit-author Dmitry Torokhov <dmitry.torokhov@gmail.com>
commit 08be954b7a7de6742d3d47e4dc20e3b086410761
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/08be954b.failed

In preparation to adding some debugging statements to PS/2 control
sequences let's move psmouse_sliced_command() into libps2 and rename it
to ps2_sliced_command().

	Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
(cherry picked from commit 08be954b7a7de6742d3d47e4dc20e3b086410761)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/input/mouse/logips2pp.c
#	drivers/input/mouse/psmouse-base.c
#	drivers/input/mouse/synaptics.c
diff --cc drivers/input/mouse/logips2pp.c
index 84de2fc6acc1,3d5637e6fa5f..000000000000
--- a/drivers/input/mouse/logips2pp.c
+++ b/drivers/input/mouse/logips2pp.c
@@@ -111,13 -113,17 +111,23 @@@ static psmouse_ret_t ps2pp_process_byte
   * Ugly.
   */
  
 -static int ps2pp_cmd(struct psmouse *psmouse, u8 *param, u8 command)
 +static int ps2pp_cmd(struct psmouse *psmouse, unsigned char *param, unsigned char command)
  {
 -	int error;
 +	if (psmouse_sliced_command(psmouse, command))
 +		return -1;
  
++<<<<<<< HEAD
 +	if (ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_POLL | 0x0300))
 +		return -1;
++=======
+ 	error = ps2_sliced_command(&psmouse->ps2dev, command);
+ 	if (error)
+ 		return error;
+ 
+ 	error = ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_POLL | 0x0300);
+ 	if (error)
+ 		return error;
++>>>>>>> 08be954b7a7d (Input: psmouse - move sliced command implementation to libps2)
  
  	return 0;
  }
diff --cc drivers/input/mouse/psmouse-base.c
index 11fb31ba0991,4f9f438e2653..000000000000
--- a/drivers/input/mouse/psmouse-base.c
+++ b/drivers/input/mouse/psmouse-base.c
@@@ -411,32 -431,7 +411,35 @@@ static irqreturn_t psmouse_interrupt(st
  	return IRQ_HANDLED;
  }
  
 +
 +/*
++<<<<<<< HEAD
 + * psmouse_sliced_command() sends an extended PS/2 command to the mouse
 + * using sliced syntax, understood by advanced devices, such as Logitech
 + * or Synaptics touchpads. The command is encoded as:
 + * 0xE6 0xE8 rr 0xE8 ss 0xE8 tt 0xE8 uu where (rr*64)+(ss*16)+(tt*4)+uu
 + * is the command.
 + */
 +int psmouse_sliced_command(struct psmouse *psmouse, unsigned char command)
 +{
 +	int i;
 +
 +	if (ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSCALE11))
 +		return -1;
 +
 +	for (i = 6; i >= 0; i -= 2) {
 +		unsigned char d = (command >> i) & 3;
 +		if (ps2_command(&psmouse->ps2dev, &d, PSMOUSE_CMD_SETRES))
 +			return -1;
 +	}
 +
 +	return 0;
 +}
 +
 +
  /*
++=======
++>>>>>>> 08be954b7a7d (Input: psmouse - move sliced command implementation to libps2)
   * psmouse_reset() resets the mouse into power-on state.
   */
  int psmouse_reset(struct psmouse *psmouse)
diff --cc drivers/input/mouse/synaptics.c
index 5f5887ef5b0a,89ab77a211b5..000000000000
--- a/drivers/input/mouse/synaptics.c
+++ b/drivers/input/mouse/synaptics.c
@@@ -74,15 -79,20 +74,24 @@@
  /*
   * Set the synaptics touchpad mode byte by special commands
   */
 -static int synaptics_mode_cmd(struct psmouse *psmouse, u8 mode)
 +static int synaptics_mode_cmd(struct psmouse *psmouse, unsigned char mode)
  {
++<<<<<<< HEAD
 +	unsigned char param[1];
++=======
+ 	u8 param[1];
+ 	int error;
+ 
+ 	error = ps2_sliced_command(&psmouse->ps2dev, mode);
+ 	if (error)
+ 		return error;
++>>>>>>> 08be954b7a7d (Input: psmouse - move sliced command implementation to libps2)
  
 +	if (psmouse_sliced_command(psmouse, mode))
 +		return -1;
  	param[0] = SYN_PS_SET_MODE2;
 -	error = ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_SETRATE);
 -	if (error)
 -		return error;
 -
 +	if (ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_SETRATE))
 +		return -1;
  	return 0;
  }
  
@@@ -196,6 -167,328 +205,331 @@@ static const char * const topbuttonpad_
  	NULL
  };
  
++<<<<<<< HEAD
++=======
+ static const char * const smbus_pnp_ids[] = {
+ 	/* all of the topbuttonpad_pnp_ids are valid, we just add some extras */
+ 	"LEN0048", /* X1 Carbon 3 */
+ 	"LEN0046", /* X250 */
+ 	"LEN004a", /* W541 */
+ 	"LEN200f", /* T450s */
+ 	"LEN2018", /* T460p */
+ 	NULL
+ };
+ 
+ static const char * const forcepad_pnp_ids[] = {
+ 	"SYN300D",
+ 	"SYN3014",
+ 	NULL
+ };
+ 
+ /*
+  * Send a command to the synpatics touchpad by special commands
+  */
+ static int synaptics_send_cmd(struct psmouse *psmouse, u8 cmd, u8 *param)
+ {
+ 	int error;
+ 
+ 	error = ps2_sliced_command(&psmouse->ps2dev, cmd);
+ 	if (error)
+ 		return error;
+ 
+ 	error = ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_GETINFO);
+ 	if (error)
+ 		return error;
+ 
+ 	return 0;
+ }
+ 
+ static int synaptics_query_int(struct psmouse *psmouse, u8 query_cmd, u32 *val)
+ {
+ 	int error;
+ 	union {
+ 		__be32 be_val;
+ 		char buf[4];
+ 	} resp = { 0 };
+ 
+ 	error = synaptics_send_cmd(psmouse, query_cmd, resp.buf + 1);
+ 	if (error)
+ 		return error;
+ 
+ 	*val = be32_to_cpu(resp.be_val);
+ 	return 0;
+ }
+ 
+ /*
+  * Identify Touchpad
+  * See also the SYN_ID_* macros
+  */
+ static int synaptics_identify(struct psmouse *psmouse,
+ 			      struct synaptics_device_info *info)
+ {
+ 	int error;
+ 
+ 	error = synaptics_query_int(psmouse, SYN_QUE_IDENTIFY, &info->identity);
+ 	if (error)
+ 		return error;
+ 
+ 	return SYN_ID_IS_SYNAPTICS(info->identity) ? 0 : -ENXIO;
+ }
+ 
+ /*
+  * Read the model-id bytes from the touchpad
+  * see also SYN_MODEL_* macros
+  */
+ static int synaptics_model_id(struct psmouse *psmouse,
+ 			      struct synaptics_device_info *info)
+ {
+ 	return synaptics_query_int(psmouse, SYN_QUE_MODEL, &info->model_id);
+ }
+ 
+ /*
+  * Read the firmware id from the touchpad
+  */
+ static int synaptics_firmware_id(struct psmouse *psmouse,
+ 				 struct synaptics_device_info *info)
+ {
+ 	return synaptics_query_int(psmouse, SYN_QUE_FIRMWARE_ID,
+ 				   &info->firmware_id);
+ }
+ 
+ /*
+  * Read the board id and the "More Extended Queries" from the touchpad
+  * The board id is encoded in the "QUERY MODES" response
+  */
+ static int synaptics_query_modes(struct psmouse *psmouse,
+ 				 struct synaptics_device_info *info)
+ {
+ 	u8 bid[3];
+ 	int error;
+ 
+ 	/* firmwares prior 7.5 have no board_id encoded */
+ 	if (SYN_ID_FULL(info->identity) < 0x705)
+ 		return 0;
+ 
+ 	error = synaptics_send_cmd(psmouse, SYN_QUE_MODES, bid);
+ 	if (error)
+ 		return error;
+ 
+ 	info->board_id = ((bid[0] & 0xfc) << 6) | bid[1];
+ 
+ 	if (SYN_MEXT_CAP_BIT(bid[0]))
+ 		return synaptics_query_int(psmouse, SYN_QUE_MEXT_CAPAB_10,
+ 					   &info->ext_cap_10);
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Read the capability-bits from the touchpad
+  * see also the SYN_CAP_* macros
+  */
+ static int synaptics_capability(struct psmouse *psmouse,
+ 				struct synaptics_device_info *info)
+ {
+ 	int error;
+ 
+ 	error = synaptics_query_int(psmouse, SYN_QUE_CAPABILITIES,
+ 				    &info->capabilities);
+ 	if (error)
+ 		return error;
+ 
+ 	info->ext_cap = info->ext_cap_0c = 0;
+ 
+ 	/*
+ 	 * Older firmwares had submodel ID fixed to 0x47
+ 	 */
+ 	if (SYN_ID_FULL(info->identity) < 0x705 &&
+ 	    SYN_CAP_SUBMODEL_ID(info->capabilities) != 0x47) {
+ 		return -ENXIO;
+ 	}
+ 
+ 	/*
+ 	 * Unless capExtended is set the rest of the flags should be ignored
+ 	 */
+ 	if (!SYN_CAP_EXTENDED(info->capabilities))
+ 		info->capabilities = 0;
+ 
+ 	if (SYN_EXT_CAP_REQUESTS(info->capabilities) >= 1) {
+ 		error = synaptics_query_int(psmouse, SYN_QUE_EXT_CAPAB,
+ 					    &info->ext_cap);
+ 		if (error) {
+ 			psmouse_warn(psmouse,
+ 				     "device claims to have extended capabilities, but I'm not able to read them.\n");
+ 		} else {
+ 			/*
+ 			 * if nExtBtn is greater than 8 it should be considered
+ 			 * invalid and treated as 0
+ 			 */
+ 			if (SYN_CAP_MULTI_BUTTON_NO(info->ext_cap) > 8)
+ 				info->ext_cap &= ~SYN_CAP_MB_MASK;
+ 		}
+ 	}
+ 
+ 	if (SYN_EXT_CAP_REQUESTS(info->capabilities) >= 4) {
+ 		error = synaptics_query_int(psmouse, SYN_QUE_EXT_CAPAB_0C,
+ 					    &info->ext_cap_0c);
+ 		if (error)
+ 			psmouse_warn(psmouse,
+ 				     "device claims to have extended capability 0x0c, but I'm not able to read it.\n");
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Read touchpad resolution and maximum reported coordinates
+  * Resolution is left zero if touchpad does not support the query
+  */
+ static int synaptics_resolution(struct psmouse *psmouse,
+ 				struct synaptics_device_info *info)
+ {
+ 	u8 resp[3];
+ 	int error;
+ 
+ 	if (SYN_ID_MAJOR(info->identity) < 4)
+ 		return 0;
+ 
+ 	error = synaptics_send_cmd(psmouse, SYN_QUE_RESOLUTION, resp);
+ 	if (!error) {
+ 		if (resp[0] != 0 && (resp[1] & 0x80) && resp[2] != 0) {
+ 			info->x_res = resp[0]; /* x resolution in units/mm */
+ 			info->y_res = resp[2]; /* y resolution in units/mm */
+ 		}
+ 	}
+ 
+ 	if (SYN_EXT_CAP_REQUESTS(info->capabilities) >= 5 &&
+ 	    SYN_CAP_MAX_DIMENSIONS(info->ext_cap_0c)) {
+ 		error = synaptics_send_cmd(psmouse,
+ 					   SYN_QUE_EXT_MAX_COORDS, resp);
+ 		if (error) {
+ 			psmouse_warn(psmouse,
+ 				     "device claims to have max coordinates query, but I'm not able to read it.\n");
+ 		} else {
+ 			info->x_max = (resp[0] << 5) | ((resp[1] & 0x0f) << 1);
+ 			info->y_max = (resp[2] << 5) | ((resp[1] & 0xf0) >> 3);
+ 			psmouse_info(psmouse,
+ 				     "queried max coordinates: x [..%d], y [..%d]\n",
+ 				     info->x_max, info->y_max);
+ 		}
+ 	}
+ 
+ 	if (SYN_CAP_MIN_DIMENSIONS(info->ext_cap_0c) &&
+ 	    (SYN_EXT_CAP_REQUESTS(info->capabilities) >= 7 ||
+ 	     /*
+ 	      * Firmware v8.1 does not report proper number of extended
+ 	      * capabilities, but has been proven to report correct min
+ 	      * coordinates.
+ 	      */
+ 	     SYN_ID_FULL(info->identity) == 0x801)) {
+ 		error = synaptics_send_cmd(psmouse,
+ 					   SYN_QUE_EXT_MIN_COORDS, resp);
+ 		if (error) {
+ 			psmouse_warn(psmouse,
+ 				     "device claims to have min coordinates query, but I'm not able to read it.\n");
+ 		} else {
+ 			info->x_min = (resp[0] << 5) | ((resp[1] & 0x0f) << 1);
+ 			info->y_min = (resp[2] << 5) | ((resp[1] & 0xf0) >> 3);
+ 			psmouse_info(psmouse,
+ 				     "queried min coordinates: x [%d..], y [%d..]\n",
+ 				     info->x_min, info->y_min);
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int synaptics_query_hardware(struct psmouse *psmouse,
+ 				    struct synaptics_device_info *info)
+ {
+ 	int error;
+ 
+ 	memset(info, 0, sizeof(*info));
+ 
+ 	error = synaptics_identify(psmouse, info);
+ 	if (error)
+ 		return error;
+ 
+ 	error = synaptics_model_id(psmouse, info);
+ 	if (error)
+ 		return error;
+ 
+ 	error = synaptics_firmware_id(psmouse, info);
+ 	if (error)
+ 		return error;
+ 
+ 	error = synaptics_query_modes(psmouse, info);
+ 	if (error)
+ 		return error;
+ 
+ 	error = synaptics_capability(psmouse, info);
+ 	if (error)
+ 		return error;
+ 
+ 	error = synaptics_resolution(psmouse, info);
+ 	if (error)
+ 		return error;
+ 
+ 	return 0;
+ }
+ 
+ #endif /* CONFIG_MOUSE_PS2_SYNAPTICS || CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS */
+ 
+ #ifdef CONFIG_MOUSE_PS2_SYNAPTICS
+ 
+ static bool cr48_profile_sensor;
+ 
+ #define ANY_BOARD_ID 0
+ struct min_max_quirk {
+ 	const char * const *pnp_ids;
+ 	struct {
+ 		u32 min, max;
+ 	} board_id;
+ 	u32 x_min, x_max, y_min, y_max;
+ };
+ 
+ static const struct min_max_quirk min_max_pnpid_table[] = {
+ 	{
+ 		(const char * const []){"LEN0033", NULL},
+ 		{ANY_BOARD_ID, ANY_BOARD_ID},
+ 		1024, 5052, 2258, 4832
+ 	},
+ 	{
+ 		(const char * const []){"LEN0042", NULL},
+ 		{ANY_BOARD_ID, ANY_BOARD_ID},
+ 		1232, 5710, 1156, 4696
+ 	},
+ 	{
+ 		(const char * const []){"LEN0034", "LEN0036", "LEN0037",
+ 					"LEN0039", "LEN2002", "LEN2004",
+ 					NULL},
+ 		{ANY_BOARD_ID, 2961},
+ 		1024, 5112, 2024, 4832
+ 	},
+ 	{
+ 		(const char * const []){"LEN2000", NULL},
+ 		{ANY_BOARD_ID, ANY_BOARD_ID},
+ 		1024, 5113, 2021, 4832
+ 	},
+ 	{
+ 		(const char * const []){"LEN2001", NULL},
+ 		{ANY_BOARD_ID, ANY_BOARD_ID},
+ 		1024, 5022, 2508, 4832
+ 	},
+ 	{
+ 		(const char * const []){"LEN2006", NULL},
+ 		{2691, 2691},
+ 		1024, 5045, 2457, 4832
+ 	},
+ 	{
+ 		(const char * const []){"LEN2006", NULL},
+ 		{ANY_BOARD_ID, ANY_BOARD_ID},
+ 		1264, 5675, 1171, 4688
+ 	},
+ 	{ }
+ };
+ 
++>>>>>>> 08be954b7a7d (Input: psmouse - move sliced command implementation to libps2)
  /*****************************************************************************
   *	Synaptics communications functions
   ****************************************************************************/
@@@ -473,21 -544,16 +807,27 @@@ static int synaptics_query_hardware(str
  
  static int synaptics_set_advanced_gesture_mode(struct psmouse *psmouse)
  {
 -	static u8 param = 0xc8;
 -	int error;
 +	static unsigned char param = 0xc8;
 +	struct synaptics_data *priv = psmouse->private;
  
++<<<<<<< HEAD
 +	if (!(SYN_CAP_ADV_GESTURE(priv->ext_cap_0c) ||
 +	      SYN_CAP_IMAGE_SENSOR(priv->ext_cap_0c)))
 +		return 0;
++=======
+ 	error = ps2_sliced_command(&psmouse->ps2dev, SYN_QUE_MODEL);
+ 	if (error)
+ 		return error;
++>>>>>>> 08be954b7a7d (Input: psmouse - move sliced command implementation to libps2)
  
 -	error = ps2_command(&psmouse->ps2dev, &param, PSMOUSE_CMD_SETRATE);
 -	if (error)
 -		return error;
 +	if (psmouse_sliced_command(psmouse, SYN_QUE_MODEL))
 +		return -1;
 +
 +	if (ps2_command(&psmouse->ps2dev, &param, PSMOUSE_CMD_SETRATE))
 +		return -1;
 +
 +	/* Advanced gesture mode also sends multi finger data */
 +	priv->capabilities |= BIT(1);
  
  	return 0;
  }
@@@ -536,15 -608,20 +876,28 @@@ static void synaptics_set_rate(struct p
  /*****************************************************************************
   *	Synaptics pass-through PS/2 port support
   ****************************************************************************/
 -static int synaptics_pt_write(struct serio *serio, u8 c)
 +static int synaptics_pt_write(struct serio *serio, unsigned char c)
  {
  	struct psmouse *parent = serio_get_drvdata(serio->parent);
++<<<<<<< HEAD
 +	char rate_param = SYN_PS_CLIENT_CMD; /* indicates that we want pass-through port */
++=======
+ 	u8 rate_param = SYN_PS_CLIENT_CMD; /* indicates that we want pass-through port */
+ 	int error;
+ 
+ 	error = ps2_sliced_command(&parent->ps2dev, c);
+ 	if (error)
+ 		return error;
+ 
+ 	error = ps2_command(&parent->ps2dev, &rate_param, PSMOUSE_CMD_SETRATE);
+ 	if (error)
+ 		return error;
++>>>>>>> 08be954b7a7d (Input: psmouse - move sliced command implementation to libps2)
  
 +	if (psmouse_sliced_command(parent, c))
 +		return -1;
 +	if (ps2_command(&parent->ps2dev, &rate_param, PSMOUSE_CMD_SETRATE))
 +		return -1;
  	return 0;
  }
  
diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c
index 79363b687195..466280ead879 100644
--- a/drivers/input/mouse/elantech.c
+++ b/drivers/input/mouse/elantech.c
@@ -35,7 +35,7 @@
 static int synaptics_send_cmd(struct psmouse *psmouse, unsigned char c,
 				unsigned char *param)
 {
-	if (psmouse_sliced_command(psmouse, c) ||
+	if (ps2_sliced_command(&psmouse->ps2dev, c) ||
 	    ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_GETINFO)) {
 		psmouse_err(psmouse, "%s query 0x%02x failed.\n", __func__, c);
 		return -1;
@@ -107,8 +107,8 @@ static int elantech_read_reg(struct psmouse *psmouse, unsigned char reg,
 
 	switch (etd->hw_version) {
 	case 1:
-		if (psmouse_sliced_command(psmouse, ETP_REGISTER_READ) ||
-		    psmouse_sliced_command(psmouse, reg) ||
+		if (ps2_sliced_command(&psmouse->ps2dev, ETP_REGISTER_READ) ||
+		    ps2_sliced_command(&psmouse->ps2dev, reg) ||
 		    ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_GETINFO)) {
 			rc = -1;
 		}
@@ -162,9 +162,9 @@ static int elantech_write_reg(struct psmouse *psmouse, unsigned char reg,
 
 	switch (etd->hw_version) {
 	case 1:
-		if (psmouse_sliced_command(psmouse, ETP_REGISTER_WRITE) ||
-		    psmouse_sliced_command(psmouse, reg) ||
-		    psmouse_sliced_command(psmouse, val) ||
+		if (ps2_sliced_command(&psmouse->ps2dev, ETP_REGISTER_WRITE) ||
+		    ps2_sliced_command(&psmouse->ps2dev, reg) ||
+		    ps2_sliced_command(&psmouse->ps2dev, val) ||
 		    ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSCALE11)) {
 			rc = -1;
 		}
* Unmerged path drivers/input/mouse/logips2pp.c
* Unmerged path drivers/input/mouse/psmouse-base.c
diff --git a/drivers/input/mouse/psmouse.h b/drivers/input/mouse/psmouse.h
index c01433fafba8..f29ed6061cd1 100644
--- a/drivers/input/mouse/psmouse.h
+++ b/drivers/input/mouse/psmouse.h
@@ -107,7 +107,6 @@ enum psmouse_type {
 
 void psmouse_queue_work(struct psmouse *psmouse, struct delayed_work *work,
 		unsigned long delay);
-int psmouse_sliced_command(struct psmouse *psmouse, unsigned char command);
 int psmouse_reset(struct psmouse *psmouse);
 void psmouse_set_state(struct psmouse *psmouse, enum psmouse_state new_state);
 void psmouse_set_resolution(struct psmouse *psmouse, unsigned int resolution);
* Unmerged path drivers/input/mouse/synaptics.c
diff --git a/drivers/input/serio/libps2.c b/drivers/input/serio/libps2.c
index c43291c1cca4..3483dde0b5ee 100644
--- a/drivers/input/serio/libps2.c
+++ b/drivers/input/serio/libps2.c
@@ -272,6 +272,38 @@ int ps2_command(struct ps2dev *ps2dev, u8 *param, unsigned int command)
 }
 EXPORT_SYMBOL(ps2_command);
 
+/*
+ * ps2_sliced_command() sends an extended PS/2 command to the mouse
+ * using sliced syntax, understood by advanced devices, such as Logitech
+ * or Synaptics touchpads. The command is encoded as:
+ * 0xE6 0xE8 rr 0xE8 ss 0xE8 tt 0xE8 uu where (rr*64)+(ss*16)+(tt*4)+uu
+ * is the command.
+ */
+
+int ps2_sliced_command(struct ps2dev *ps2dev, u8 command)
+{
+	int i;
+	int retval;
+
+	ps2_begin_command(ps2dev);
+
+	retval = __ps2_command(ps2dev, NULL, PS2_CMD_SETSCALE11);
+	if (retval)
+		goto out;
+
+	for (i = 6; i >= 0; i -= 2) {
+		u8 d = (command >> i) & 3;
+		retval = __ps2_command(ps2dev, &d, PS2_CMD_SETRES);
+		if (retval)
+			break;
+	}
+
+out:
+	ps2_end_command(ps2dev);
+	return retval;
+}
+EXPORT_SYMBOL(ps2_sliced_command);
+
 /*
  * ps2_init() initializes ps2dev structure
  */
diff --git a/include/linux/libps2.h b/include/linux/libps2.h
index 04a5750f1e4e..a45d751e6642 100644
--- a/include/linux/libps2.h
+++ b/include/linux/libps2.h
@@ -14,6 +14,8 @@
 #include <linux/types.h>
 #include <linux/wait.h>
 
+#define PS2_CMD_SETSCALE11	0x00e6
+#define PS2_CMD_SETRES		0x10e8
 #define PS2_CMD_GETID		0x02f2
 #define PS2_CMD_RESET_BAT	0x02ff
 
@@ -51,6 +53,7 @@ void ps2_begin_command(struct ps2dev *ps2dev);
 void ps2_end_command(struct ps2dev *ps2dev);
 int __ps2_command(struct ps2dev *ps2dev, u8 *param, unsigned int command);
 int ps2_command(struct ps2dev *ps2dev, u8 *param, unsigned int command);
+int ps2_sliced_command(struct ps2dev *ps2dev, u8 command);
 bool ps2_handle_ack(struct ps2dev *ps2dev, u8 data);
 bool ps2_handle_response(struct ps2dev *ps2dev, u8 data);
 void ps2_cmd_aborted(struct ps2dev *ps2dev);
