iio: add resource managed triggered buffer init helpers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iio] add resource managed triggered buffer init helpers (Tony Camuso) [1559170]
Rebuild_FUZZ: 95.24%
commit-author Gregor Boirie <gregor.boirie@parrot.com>
commit 70e483487db787b152da756d4be0fef917378142
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/70e48348.failed

Add resource managed devm_iio_triggered_buffer_setup() and
devm_iio_triggered_buffer_cleanup() to automatically clean up triggered
buffers setup by IIO drivers, thus leading to simplified IIO drivers code.

	Signed-off-by: Gregor Boirie <gregor.boirie@parrot.com>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit 70e483487db787b152da756d4be0fef917378142)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/driver-model/devres.txt
#	include/linux/iio/iio.h
diff --cc Documentation/driver-model/devres.txt
index 74e282453485,75bc5b8add2f..000000000000
--- a/Documentation/driver-model/devres.txt
+++ b/Documentation/driver-model/devres.txt
@@@ -233,10 -233,52 +233,59 @@@ certainly invest a bit more effort int
    6. List of managed interfaces
    -----------------------------
  
++<<<<<<< HEAD
 +MEM
 +  devm_kzalloc()
 +  devm_kfree()
 +  devm_kmemdup()
++=======
+ CLOCK
+   devm_clk_get()
+   devm_clk_put()
+   devm_clk_hw_register()
+ 
+ DMA
+   dmam_alloc_coherent()
+   dmam_alloc_noncoherent()
+   dmam_declare_coherent_memory()
+   dmam_free_coherent()
+   dmam_free_noncoherent()
+   dmam_pool_create()
+   dmam_pool_destroy()
+ 
+ GPIO
+   devm_gpiod_get()
+   devm_gpiod_get_index()
+   devm_gpiod_get_index_optional()
+   devm_gpiod_get_optional()
+   devm_gpiod_put()
+   devm_gpiochip_add_data()
+   devm_gpiochip_remove()
+   devm_gpio_request()
+   devm_gpio_request_one()
+   devm_gpio_free()
+ 
+ IIO
+   devm_iio_device_alloc()
+   devm_iio_device_free()
+   devm_iio_device_register()
+   devm_iio_device_unregister()
+   devm_iio_kfifo_allocate()
+   devm_iio_kfifo_free()
+   devm_iio_triggered_buffer_setup()
+   devm_iio_triggered_buffer_cleanup()
+   devm_iio_trigger_alloc()
+   devm_iio_trigger_free()
+   devm_iio_trigger_register()
+   devm_iio_trigger_unregister()
+   devm_iio_channel_get()
+   devm_iio_channel_release()
+   devm_iio_channel_get_all()
+   devm_iio_channel_release_all()
+ 
+ INPUT
+   devm_input_allocate_device()
++>>>>>>> 70e483487db7 (iio: add resource managed triggered buffer init helpers)
  
  IO region
    devm_release_mem_region()
diff --cc include/linux/iio/iio.h
index 95115dd384d0,b4a0679e4a49..000000000000
--- a/include/linux/iio/iio.h
+++ b/include/linux/iio/iio.h
@@@ -590,36 -643,13 +590,40 @@@ static inline struct iio_dev *iio_priv_
  				  ALIGN(sizeof(struct iio_dev), IIO_ALIGN));
  }
  
 +/**
 + * iio_device_free() - free an iio_dev from a driver
 + * @indio_dev: 		the iio_dev associated with the device
 + **/
  void iio_device_free(struct iio_dev *indio_dev);
++<<<<<<< HEAD
 +
 +/**
 + * devm_iio_device_alloc - Resource-managed iio_device_alloc()
 + * @dev: 		Device to allocate iio_dev for
 + * @sizeof_priv: 	Space to allocate for private structure.
 + *
 + * Managed iio_device_alloc.  iio_dev allocated with this function is
 + * automatically freed on driver detach.
 + *
 + * If an iio_dev allocated with this function needs to be freed separately,
 + * devm_iio_device_free() must be used.
 + *
 + * RETURNS:
 + * Pointer to allocated iio_dev on success, NULL on failure.
 + */
++=======
+ int devm_iio_device_match(struct device *dev, void *res, void *data);
++>>>>>>> 70e483487db7 (iio: add resource managed triggered buffer init helpers)
  struct iio_dev *devm_iio_device_alloc(struct device *dev, int sizeof_priv);
 +
 +/**
 + * devm_iio_device_free - Resource-managed iio_device_free()
 + * @dev:		Device this iio_dev belongs to
 + * @indio_dev: 		the iio_dev associated with the device
 + *
 + * Free iio_dev allocated with devm_iio_device_alloc().
 + */
  void devm_iio_device_free(struct device *dev, struct iio_dev *indio_dev);
 -struct iio_trigger *devm_iio_trigger_alloc(struct device *dev,
 -						const char *fmt, ...);
 -void devm_iio_trigger_free(struct device *dev, struct iio_trigger *iio_trig);
  
  /**
   * iio_buffer_enabled() - helper function to test if the buffer is enabled
* Unmerged path Documentation/driver-model/devres.txt
diff --git a/drivers/iio/industrialio-core.c b/drivers/iio/industrialio-core.c
index 87201424abaf..5754ef5b6307 100644
--- a/drivers/iio/industrialio-core.c
+++ b/drivers/iio/industrialio-core.c
@@ -953,7 +953,7 @@ static void devm_iio_device_release(struct device *dev, void *res)
 	iio_device_free(*(struct iio_dev **)res);
 }
 
-static int devm_iio_device_match(struct device *dev, void *res, void *data)
+int devm_iio_device_match(struct device *dev, void *res, void *data)
 {
 	struct iio_dev **r = res;
 	if (!r || !*r) {
@@ -962,6 +962,7 @@ static int devm_iio_device_match(struct device *dev, void *res, void *data)
 	}
 	return *r == data;
 }
+EXPORT_SYMBOL_GPL(devm_iio_device_match);
 
 struct iio_dev *devm_iio_device_alloc(struct device *dev, int sizeof_priv)
 {
diff --git a/drivers/iio/industrialio-triggered-buffer.c b/drivers/iio/industrialio-triggered-buffer.c
index 19eaf7c3b7c0..ff4bf4996984 100644
--- a/drivers/iio/industrialio-triggered-buffer.c
+++ b/drivers/iio/industrialio-triggered-buffer.c
@@ -104,6 +104,48 @@ void iio_triggered_buffer_cleanup(struct iio_dev *indio_dev)
 }
 EXPORT_SYMBOL(iio_triggered_buffer_cleanup);
 
+static void devm_iio_triggered_buffer_clean(struct device *dev, void *res)
+{
+	iio_triggered_buffer_cleanup(*(struct iio_dev **)res);
+}
+
+int devm_iio_triggered_buffer_setup(struct device *dev,
+				    struct iio_dev *indio_dev,
+				    irqreturn_t (*h)(int irq, void *p),
+				    irqreturn_t (*thread)(int irq, void *p),
+				    const struct iio_buffer_setup_ops *ops)
+{
+	struct iio_dev **ptr;
+	int ret;
+
+	ptr = devres_alloc(devm_iio_triggered_buffer_clean, sizeof(*ptr),
+			   GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+
+	*ptr = indio_dev;
+
+	ret = iio_triggered_buffer_setup(indio_dev, h, thread, ops);
+	if (!ret)
+		devres_add(dev, ptr);
+	else
+		devres_free(ptr);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(devm_iio_triggered_buffer_setup);
+
+void devm_iio_triggered_buffer_cleanup(struct device *dev,
+				       struct iio_dev *indio_dev)
+{
+	int rc;
+
+	rc = devres_release(dev, devm_iio_triggered_buffer_clean,
+			    devm_iio_device_match, indio_dev);
+	WARN_ON(rc);
+}
+EXPORT_SYMBOL_GPL(devm_iio_triggered_buffer_cleanup);
+
 MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
 MODULE_DESCRIPTION("IIO helper functions for setting up triggered buffers");
 MODULE_LICENSE("GPL");
* Unmerged path include/linux/iio/iio.h
diff --git a/include/linux/iio/triggered_buffer.h b/include/linux/iio/triggered_buffer.h
index c378ebec605e..73b50126034d 100644
--- a/include/linux/iio/triggered_buffer.h
+++ b/include/linux/iio/triggered_buffer.h
@@ -12,4 +12,12 @@ int iio_triggered_buffer_setup(struct iio_dev *indio_dev,
 	const struct iio_buffer_setup_ops *setup_ops);
 void iio_triggered_buffer_cleanup(struct iio_dev *indio_dev);
 
+int devm_iio_triggered_buffer_setup(struct device *dev,
+				    struct iio_dev *indio_dev,
+				    irqreturn_t (*h)(int irq, void *p),
+				    irqreturn_t (*thread)(int irq, void *p),
+				    const struct iio_buffer_setup_ops *ops);
+void devm_iio_triggered_buffer_cleanup(struct device *dev,
+				       struct iio_dev *indio_dev);
+
 #endif
