mm: replace access_remote_vm() write parameter with gup_flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mm] replace access_remote_vm() write parameter with gup_flags (Oleg Nesterov) [1576338]
Rebuild_FUZZ: 96.61%
commit-author Lorenzo Stoakes <lstoakes@gmail.com>
commit 6347e8d5bcce33fc36e651901efefbe2c93a43ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6347e8d5.failed

This removes the 'write' argument from access_remote_vm() and replaces
it with 'gup_flags' as use of this function previously silently implied
FOLL_FORCE, whereas after this patch callers explicitly pass this flag.

We make this explicit as use of FOLL_FORCE can result in surprising
behaviour (and hence bugs) within the mm subsystem.

	Signed-off-by: Lorenzo Stoakes <lstoakes@gmail.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 6347e8d5bcce33fc36e651901efefbe2c93a43ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory.c
#	mm/nommu.c
diff --cc mm/memory.c
index 41eaf1c61cf6,bac2d994850e..000000000000
--- a/mm/memory.c
+++ b/mm/memory.c
@@@ -3898,9 -3940,9 +3898,13 @@@ static int __access_remote_vm(struct ta
   * The caller must hold a reference on @mm.
   */
  int access_remote_vm(struct mm_struct *mm, unsigned long addr,
- 		void *buf, int len, int write)
+ 		void *buf, int len, unsigned int gup_flags)
  {
++<<<<<<< HEAD
 +	return __access_remote_vm(NULL, mm, addr, buf, len, write);
++=======
+ 	return __access_remote_vm(NULL, mm, addr, buf, len, gup_flags);
++>>>>>>> 6347e8d5bcce (mm: replace access_remote_vm() write parameter with gup_flags)
  }
  
  /*
diff --cc mm/nommu.c
index 636f04e40f81,93d5bb53fc63..000000000000
--- a/mm/nommu.c
+++ b/mm/nommu.c
@@@ -2078,9 -1852,9 +2078,13 @@@ static int __access_remote_vm(struct ta
   * The caller must hold a reference on @mm.
   */
  int access_remote_vm(struct mm_struct *mm, unsigned long addr,
- 		void *buf, int len, int write)
+ 		void *buf, int len, unsigned int gup_flags)
  {
++<<<<<<< HEAD
 +	return __access_remote_vm(NULL, mm, addr, buf, len, write);
++=======
+ 	return __access_remote_vm(NULL, mm, addr, buf, len, gup_flags);
++>>>>>>> 6347e8d5bcce (mm: replace access_remote_vm() write parameter with gup_flags)
  }
  
  /*
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 6b05bce3a573..b16dcaceb1ee 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -251,7 +251,7 @@ static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,
 	 * Inherently racy -- command line shares address space
 	 * with code and data.
 	 */
-	rv = access_remote_vm(mm, arg_end - 1, &c, 1, 0);
+	rv = access_remote_vm(mm, arg_end - 1, &c, 1, FOLL_FORCE);
 	if (rv <= 0)
 		goto out_free_page;
 
@@ -269,7 +269,8 @@ static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,
 			int nr_read;
 
 			_count = min3(count, len, PAGE_SIZE);
-			nr_read = access_remote_vm(mm, p, page, _count, 0);
+			nr_read = access_remote_vm(mm, p, page, _count,
+					FOLL_FORCE);
 			if (nr_read < 0)
 				rv = nr_read;
 			if (nr_read <= 0)
@@ -304,7 +305,8 @@ static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,
 			bool final;
 
 			_count = min3(count, len, PAGE_SIZE);
-			nr_read = access_remote_vm(mm, p, page, _count, 0);
+			nr_read = access_remote_vm(mm, p, page, _count,
+					FOLL_FORCE);
 			if (nr_read < 0)
 			        rv = nr_read;
 			if (nr_read <= 0)
@@ -353,7 +355,8 @@ skip_argv:
 			bool final;
 
 			_count = min3(count, len, PAGE_SIZE);
-			nr_read = access_remote_vm(mm, p, page, _count, 0);
+			nr_read = access_remote_vm(mm, p, page, _count,
+					FOLL_FORCE);
 			if (nr_read < 0)
 			        rv = nr_read;
 			if (nr_read <= 0)
@@ -916,6 +919,7 @@ static ssize_t mem_rw(struct file *file, char __user *buf,
 	unsigned long addr = *ppos;
 	ssize_t copied;
 	char *page;
+	unsigned int flags = FOLL_FORCE;
 
 	if (!mm)
 		return 0;
@@ -928,6 +932,9 @@ static ssize_t mem_rw(struct file *file, char __user *buf,
 	if (!atomic_inc_not_zero(&mm->mm_users))
 		goto free;
 
+	if (write)
+		flags |= FOLL_WRITE;
+
 	while (count > 0) {
 		int this_len = min_t(int, count, PAGE_SIZE);
 
@@ -936,7 +943,7 @@ static ssize_t mem_rw(struct file *file, char __user *buf,
 			break;
 		}
 
-		this_len = access_remote_vm(mm, addr, page, this_len, write);
+		this_len = access_remote_vm(mm, addr, page, this_len, flags);
 		if (!this_len) {
 			if (!copied)
 				copied = -EIO;
@@ -1048,7 +1055,7 @@ static ssize_t environ_read(struct file *file, char __user *buf,
 		this_len = min(max_len, this_len);
 
 		retval = access_remote_vm(mm, (env_start + src),
-			page, this_len, 0);
+			page, this_len, FOLL_FORCE);
 
 		if (retval <= 0) {
 			ret = retval;
diff --git a/include/linux/mm.h b/include/linux/mm.h
index d2f11a68bcdf..905ff4ffc83f 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1369,7 +1369,7 @@ static inline int fixup_user_fault(struct task_struct *tsk,
 
 extern int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len, int write);
 extern int access_remote_vm(struct mm_struct *mm, unsigned long addr,
-		void *buf, int len, int write);
+		void *buf, int len, unsigned int gup_flags);
 
 long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 		      unsigned long start, unsigned long nr_pages,
* Unmerged path mm/memory.c
* Unmerged path mm/nommu.c
