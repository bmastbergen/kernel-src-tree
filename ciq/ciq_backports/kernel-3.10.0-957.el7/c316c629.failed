net: ipmr: remove some pimsm ifdefs and simplify

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] ipmr: remove some pimsm ifdefs and simplify (Ivan Vecera) [1584232]
Rebuild_FUZZ: 94.51%
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit c316c629f12e01e5d7710e456248a1ebef8426ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c316c629.failed

Add the helper pimsm_enabled() which replaces the old CONFIG_IP_PIMSM
define and is used to check if any version of PIM-SM has been enabled.
Use a single if defined(CONFIG_IP_PIMSM_V1) || defined(CONFIG_IP_PIMSM_V2)
for the pim-sm shared code. This is okay w.r.t IGMPMSG_WHOLEPKT because
only a VIFF_REGISTER device can send such packet, and it can't be
created if pimsm_enabled() is false.

	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c316c629f12e01e5d7710e456248a1ebef8426ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ipmr.c
diff --cc net/ipv4/ipmr.c
index cacb0d4bd4b6,e153ab7b17a1..000000000000
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@@ -980,28 -1026,23 +1019,48 @@@ static int ipmr_cache_report(struct mr_
  		ip_hdr(skb)->ihl = sizeof(struct iphdr) >> 2;
  		ip_hdr(skb)->tot_len = htons(ntohs(ip_hdr(pkt)->tot_len) +
  					     sizeof(struct iphdr));
++<<<<<<< HEAD
 +	} else
 +#endif
 +	{
 +
 +	/* Copy the IP header */
 +
 +	skb_set_network_header(skb, skb->len);
 +	skb_put(skb, ihl);
 +	skb_copy_to_linear_data(skb, pkt->data, ihl);
 +	ip_hdr(skb)->protocol = 0;	/* Flag to the kernel this is a route add */
 +	msg = (struct igmpmsg *)skb_network_header(skb);
 +	msg->im_vif = vifi;
 +	skb_dst_set(skb, dst_clone(skb_dst(pkt)));
 +
 +	/* Add our header */
 +
 +	igmp = skb_put(skb, sizeof(struct igmphdr));
 +	igmp->type	=
 +	msg->im_msgtype = assert;
 +	igmp->code	= 0;
 +	ip_hdr(skb)->tot_len = htons(skb->len);		/* Fix the length */
 +	skb->transport_header = skb->network_header;
++=======
+ 	} else {
+ 		/* Copy the IP header */
+ 		skb_set_network_header(skb, skb->len);
+ 		skb_put(skb, ihl);
+ 		skb_copy_to_linear_data(skb, pkt->data, ihl);
+ 		/* Flag to the kernel this is a route add */
+ 		ip_hdr(skb)->protocol = 0;
+ 		msg = (struct igmpmsg *)skb_network_header(skb);
+ 		msg->im_vif = vifi;
+ 		skb_dst_set(skb, dst_clone(skb_dst(pkt)));
+ 		/* Add our header */
+ 		igmp = (struct igmphdr *)skb_put(skb, sizeof(struct igmphdr));
+ 		igmp->type = assert;
+ 		msg->im_msgtype = assert;
+ 		igmp->code = 0;
+ 		ip_hdr(skb)->tot_len = htons(skb->len);	/* Fix the length */
+ 		skb->transport_header = skb->network_header;
++>>>>>>> c316c629f12e (net: ipmr: remove some pimsm ifdefs and simplify)
  	}
  
  	rcu_read_lock();
@@@ -1701,10 -1736,9 +1758,9 @@@ static void ipmr_queue_xmit(struct net 
  	struct flowi4 fl4;
  	int    encap = 0;
  
 -	if (!vif->dev)
 +	if (vif->dev == NULL)
  		goto out_free;
  
- #ifdef CONFIG_IP_PIMSM
  	if (vif->flags & VIFF_REGISTER) {
  		vif->pkt_out++;
  		vif->bytes_out += skb->len;
@@@ -2044,48 -2077,6 +2099,51 @@@ dont_forward
  	return 0;
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_IP_PIMSM
 +/* called with rcu_read_lock() */
 +static int __pim_rcv(struct mr_table *mrt, struct sk_buff *skb,
 +		     unsigned int pimlen)
 +{
 +	struct net_device *reg_dev = NULL;
 +	struct iphdr *encap;
 +
 +	encap = (struct iphdr *)(skb_transport_header(skb) + pimlen);
 +	/*
 +	 * Check that:
 +	 * a. packet is really sent to a multicast group
 +	 * b. packet is not a NULL-REGISTER
 +	 * c. packet is not truncated
 +	 */
 +	if (!ipv4_is_multicast(encap->daddr) ||
 +	    encap->tot_len == 0 ||
 +	    ntohs(encap->tot_len) + pimlen > skb->len)
 +		return 1;
 +
 +	read_lock(&mrt_lock);
 +	if (mrt->mroute_reg_vif_num >= 0)
 +		reg_dev = mrt->vif_table[mrt->mroute_reg_vif_num].dev;
 +	read_unlock(&mrt_lock);
 +
 +	if (reg_dev == NULL)
 +		return 1;
 +
 +	skb->mac_header = skb->network_header;
 +	skb_pull(skb, (u8 *)encap - skb->data);
 +	skb_reset_network_header(skb);
 +	skb->protocol = htons(ETH_P_IP);
 +	skb->ip_summed = CHECKSUM_NONE;
 +
 +	skb_tunnel_rx(skb, reg_dev, dev_net(reg_dev));
 +
 +	netif_rx(skb);
 +
 +	return NET_RX_SUCCESS;
 +}
 +#endif
 +
++=======
++>>>>>>> c316c629f12e (net: ipmr: remove some pimsm ifdefs and simplify)
  #ifdef CONFIG_IP_PIMSM_V1
  /*
   * Handle IGMP messages of PIMv1
* Unmerged path net/ipv4/ipmr.c
