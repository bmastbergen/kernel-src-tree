x86/cpufeatures: Make CPU bugs sticky

jira LE-1907
cve CVE-2018-3639
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] cpufeatures: Make CPU bugs sticky (Waiman Long) [1566905] {CVE-2018-3639}
Rebuild_FUZZ: 94.29%
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 6cbd2171e89b13377261d15e64384df60ecb530e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6cbd2171.failed

There is currently no way to force CPU bug bits like CPU feature bits. That
makes it impossible to set a bug bit once at boot and have it stick for all
upcoming CPUs.

Extend the force set/clear arrays to handle bug bits as well.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Borislav Petkov <bpetkov@suse.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Dave Hansen <dave.hansen@intel.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: David Laight <David.Laight@aculab.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: Eduardo Valentin <eduval@amazon.com>
	Cc: Greg KH <gregkh@linuxfoundation.org>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Juergen Gross <jgross@suse.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: aliguori@amazon.com
	Cc: daniel.gruss@iaik.tugraz.at
	Cc: hughd@google.com
	Cc: keescook@google.com
Link: https://lkml.kernel.org/r/20171204150606.992156574@linutronix.de
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 6cbd2171e89b13377261d15e64384df60ecb530e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/cpufeature.h
#	arch/x86/include/asm/processor.h
#	arch/x86/kernel/cpu/common.c
diff --cc arch/x86/include/asm/cpufeature.h
index d91eff63b98e,ea9a7dde62e5..000000000000
--- a/arch/x86/include/asm/cpufeature.h
+++ b/arch/x86/include/asm/cpufeature.h
@@@ -115,81 -135,52 +115,87 @@@ extern void clear_cpu_cap(struct cpuinf
  	set_bit(bit, (unsigned long *)cpu_caps_set);	\
  } while (0)
  
++<<<<<<< HEAD
 +#define cpu_has_fpu		boot_cpu_has(X86_FEATURE_FPU)
 +#define cpu_has_de		boot_cpu_has(X86_FEATURE_DE)
 +#define cpu_has_pse		boot_cpu_has(X86_FEATURE_PSE)
 +#define cpu_has_tsc		boot_cpu_has(X86_FEATURE_TSC)
 +#define cpu_has_pge		boot_cpu_has(X86_FEATURE_PGE)
 +#define cpu_has_apic		boot_cpu_has(X86_FEATURE_APIC)
 +#define cpu_has_sep		boot_cpu_has(X86_FEATURE_SEP)
 +#define cpu_has_mtrr		boot_cpu_has(X86_FEATURE_MTRR)
 +#define cpu_has_mmx		boot_cpu_has(X86_FEATURE_MMX)
 +#define cpu_has_fxsr		boot_cpu_has(X86_FEATURE_FXSR)
 +#define cpu_has_xmm		boot_cpu_has(X86_FEATURE_XMM)
 +#define cpu_has_xmm2		boot_cpu_has(X86_FEATURE_XMM2)
 +#define cpu_has_xmm3		boot_cpu_has(X86_FEATURE_XMM3)
 +#define cpu_has_ssse3		boot_cpu_has(X86_FEATURE_SSSE3)
 +#define cpu_has_aes		boot_cpu_has(X86_FEATURE_AES)
 +#define cpu_has_avx		boot_cpu_has(X86_FEATURE_AVX)
 +#define cpu_has_avx2		boot_cpu_has(X86_FEATURE_AVX2)
 +#define cpu_has_ht		boot_cpu_has(X86_FEATURE_HT)
 +#define cpu_has_nx		boot_cpu_has(X86_FEATURE_NX)
 +#define cpu_has_xstore		boot_cpu_has(X86_FEATURE_XSTORE)
 +#define cpu_has_xstore_enabled	boot_cpu_has(X86_FEATURE_XSTORE_EN)
 +#define cpu_has_xcrypt		boot_cpu_has(X86_FEATURE_XCRYPT)
 +#define cpu_has_xcrypt_enabled	boot_cpu_has(X86_FEATURE_XCRYPT_EN)
 +#define cpu_has_ace2		boot_cpu_has(X86_FEATURE_ACE2)
 +#define cpu_has_ace2_enabled	boot_cpu_has(X86_FEATURE_ACE2_EN)
 +#define cpu_has_phe		boot_cpu_has(X86_FEATURE_PHE)
 +#define cpu_has_phe_enabled	boot_cpu_has(X86_FEATURE_PHE_EN)
 +#define cpu_has_pmm		boot_cpu_has(X86_FEATURE_PMM)
 +#define cpu_has_pmm_enabled	boot_cpu_has(X86_FEATURE_PMM_EN)
 +#define cpu_has_ds		boot_cpu_has(X86_FEATURE_DS)
 +#define cpu_has_pebs		boot_cpu_has(X86_FEATURE_PEBS)
 +#define cpu_has_clflush		boot_cpu_has(X86_FEATURE_CLFLUSH)
 +#define cpu_has_bts		boot_cpu_has(X86_FEATURE_BTS)
 +#define cpu_has_gbpages		boot_cpu_has(X86_FEATURE_GBPAGES)
 +#define cpu_has_arch_perfmon	boot_cpu_has(X86_FEATURE_ARCH_PERFMON)
 +#define cpu_has_pat		boot_cpu_has(X86_FEATURE_PAT)
 +#define cpu_has_xmm4_1		boot_cpu_has(X86_FEATURE_XMM4_1)
 +#define cpu_has_xmm4_2		boot_cpu_has(X86_FEATURE_XMM4_2)
 +#define cpu_has_x2apic		boot_cpu_has(X86_FEATURE_X2APIC)
 +#define cpu_has_xsave		boot_cpu_has(X86_FEATURE_XSAVE)
 +#define cpu_has_xsaveopt	boot_cpu_has(X86_FEATURE_XSAVEOPT)
 +#define cpu_has_xsaves          boot_cpu_has(X86_FEATURE_XSAVES)
 +#define cpu_has_osxsave		boot_cpu_has(X86_FEATURE_OSXSAVE)
 +#define cpu_has_hypervisor	boot_cpu_has(X86_FEATURE_HYPERVISOR)
 +#define cpu_has_pclmulqdq	boot_cpu_has(X86_FEATURE_PCLMULQDQ)
 +#define cpu_has_perfctr_core	boot_cpu_has(X86_FEATURE_PERFCTR_CORE)
 +#define cpu_has_perfctr_nb	boot_cpu_has(X86_FEATURE_PERFCTR_NB)
 +#define cpu_has_perfctr_l2	boot_cpu_has(X86_FEATURE_PERFCTR_L2)
 +#define cpu_has_cx8		boot_cpu_has(X86_FEATURE_CX8)
 +#define cpu_has_cx16		boot_cpu_has(X86_FEATURE_CX16)
 +#define cpu_has_eager_fpu	boot_cpu_has(X86_FEATURE_EAGER_FPU)
 +#define cpu_has_topoext		boot_cpu_has(X86_FEATURE_TOPOEXT)
 +#define cpu_has_bpext		boot_cpu_has(X86_FEATURE_BPEXT)
 +
 +#if __GNUC__ >= 4
++=======
+ #define setup_force_cpu_bug(bit) setup_force_cpu_cap(bit)
+ 
+ #if defined(CC_HAVE_ASM_GOTO) && defined(CONFIG_X86_FAST_FEATURE_TESTS)
++>>>>>>> 6cbd2171e89b (x86/cpufeatures: Make CPU bugs sticky)
  /*
   * Static testing of CPU features.  Used the same as boot_cpu_has().
 - * These will statically patch the target code for additional
 - * performance.
 + * These are only valid after alternatives have run, but will statically
 + * patch the target code for additional performance.
 + *
   */
 -static __always_inline __pure bool _static_cpu_has(u16 bit)
 +static __always_inline __pure bool __static_cpu_has(u16 bit)
  {
 -		asm_volatile_goto("1: jmp 6f\n"
 +#if __GNUC__ > 4 || __GNUC_MINOR__ >= 5
 +		asm_volatile_goto("1: jmp %l[t_no]\n"
  			 "2:\n"
 -			 ".skip -(((5f-4f) - (2b-1b)) > 0) * "
 -			         "((5f-4f) - (2b-1b)),0x90\n"
 -			 "3:\n"
  			 ".section .altinstructions,\"a\"\n"
 -			 " .long 1b - .\n"		/* src offset */
 -			 " .long 4f - .\n"		/* repl offset */
 -			 " .word %P1\n"			/* always replace */
 -			 " .byte 3b - 1b\n"		/* src len */
 -			 " .byte 5f - 4f\n"		/* repl len */
 -			 " .byte 3b - 2b\n"		/* pad len */
 +			 " .long 1b - .\n"
 +			 " .long 0\n"		/* no replacement */
 +			 " .word %P0\n"		/* feature bit */
 +			 " .byte 2b - 1b\n"	/* source len */
 +			 " .byte 0\n"		/* replacement len */
  			 ".previous\n"
 -			 ".section .altinstr_replacement,\"ax\"\n"
 -			 "4: jmp %l[t_no]\n"
 -			 "5:\n"
 -			 ".previous\n"
 -			 ".section .altinstructions,\"a\"\n"
 -			 " .long 1b - .\n"		/* src offset */
 -			 " .long 0\n"			/* no replacement */
 -			 " .word %P0\n"			/* feature bit */
 -			 " .byte 3b - 1b\n"		/* src len */
 -			 " .byte 0\n"			/* repl len */
 -			 " .byte 0\n"			/* pad len */
 -			 ".previous\n"
 -			 ".section .altinstr_aux,\"ax\"\n"
 -			 "6:\n"
 -			 " testb %[bitnum],%[cap_byte]\n"
 -			 " jnz %l[t_yes]\n"
 -			 " jmp %l[t_no]\n"
 -			 ".previous\n"
 -			 : : "i" (bit), "i" (X86_FEATURE_ALWAYS),
 -			     [bitnum] "i" (1 << (bit & 7)),
 -			     [cap_byte] "m" (((const char *)boot_cpu_data.x86_capability)[bit >> 3])
 -			 : : t_yes, t_no);
 -	t_yes:
 +			 /* skipping size check since replacement size = 0 */
 +			 : : "i" (bit) : : t_no);
  		return true;
  	t_no:
  		return false;
diff --cc arch/x86/include/asm/processor.h
index 40612f380030,da943411d3d8..000000000000
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@@ -168,18 -160,15 +168,24 @@@ enum cpuid_regs_idx 
   * capabilities of CPUs
   */
  extern struct cpuinfo_x86	boot_cpu_data;
 +extern struct rh_cpuinfo_x86	rh_boot_cpu_data;
  extern struct cpuinfo_x86	new_cpu_data;
  
++<<<<<<< HEAD
 +extern struct tss_struct	doublefault_tss;
 +extern __u32			cpu_caps_cleared[NCAPINTS];
 +extern __u32			cpu_caps_set[NCAPINTS];
++=======
+ extern struct x86_hw_tss	doublefault_tss;
+ extern __u32			cpu_caps_cleared[NCAPINTS + NBUGINTS];
+ extern __u32			cpu_caps_set[NCAPINTS + NBUGINTS];
++>>>>>>> 6cbd2171e89b (x86/cpufeatures: Make CPU bugs sticky)
  
  #ifdef CONFIG_SMP
 -DECLARE_PER_CPU_READ_MOSTLY(struct cpuinfo_x86, cpu_info);
 +DECLARE_PER_CPU_SHARED_ALIGNED(struct cpuinfo_x86, cpu_info);
 +DECLARE_PER_CPU_SHARED_ALIGNED(struct rh_cpuinfo_x86, rh_cpu_info);
  #define cpu_data(cpu)		per_cpu(cpu_info, cpu)
 +#define rh_cpu_data(cpu)	per_cpu(rh_cpu_info, cpu)
  #else
  #define cpu_info		boot_cpu_data
  #define cpu_data(cpu)		boot_cpu_data
diff --cc arch/x86/kernel/cpu/common.c
index 49cb90f121df,034900623adf..000000000000
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -708,24 -808,14 +708,32 @@@ void cpu_detect(struct cpuinfo_x86 *c
  	}
  }
  
 -static void apply_forced_caps(struct cpuinfo_x86 *c)
 +static void init_speculation_control(struct cpuinfo_x86 *c)
  {
++<<<<<<< HEAD
 +	/*
 +	 * The Intel SPEC_CTRL CPUID bit implies IBRS and IBPB support,
 +	 * and they also have a different bit for STIBP support. Also,
 +	 * a hypervisor might have set the individual AMD bits even on
 +	 * Intel CPUs, for finer-grained selection of what's available.
 +	 *
 +	 * We use the AMD bits in 0x8000_0008 EBX as the generic hardware
 +	 * features, which are visible in /proc/cpuinfo and used by the
 +	 * kernel. So set those accordingly from the Intel bits.
 +	 */
 +	if (cpu_has(c, X86_FEATURE_SPEC_CTRL)) {
 +		set_cpu_cap(c, X86_FEATURE_IBRS);
 +		set_cpu_cap(c, X86_FEATURE_IBPB);
++=======
+ 	int i;
+ 
+ 	for (i = 0; i < NCAPINTS + NBUGINTS; i++) {
+ 		c->x86_capability[i] &= ~cpu_caps_cleared[i];
+ 		c->x86_capability[i] |= cpu_caps_set[i];
++>>>>>>> 6cbd2171e89b (x86/cpufeatures: Make CPU bugs sticky)
  	}
 +	if (cpu_has(c, X86_FEATURE_INTEL_STIBP))
 +		set_cpu_cap(c, X86_FEATURE_STIBP);
  }
  
  void get_cpu_cap(struct cpuinfo_x86 *c)
* Unmerged path arch/x86/include/asm/cpufeature.h
* Unmerged path arch/x86/include/asm/processor.h
* Unmerged path arch/x86/kernel/cpu/common.c
