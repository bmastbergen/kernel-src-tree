blk-mq-debugfs: Show atomic request flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit c0cb1c6d39060ce04470b10347b7b6f1df77bef5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c0cb1c6d.failed

When analyzing e.g. queue lockups it is important to know whether
or not a request has already been started. Hence also show the
atomic request flags.

	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Reviewed-by: Ming Lei <ming.lei@redhat.com>
	Reviewed-by: Eduardo Valentin <eduval@amazon.com>
	Cc: Omar Sandoval <osandov@fb.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit c0cb1c6d39060ce04470b10347b7b6f1df77bef5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq-debugfs.c
diff --cc block/blk-mq-debugfs.c
index 7e8a5d632d21,d56ddd7a1285..000000000000
--- a/block/blk-mq-debugfs.c
+++ b/block/blk-mq-debugfs.c
@@@ -226,13 -243,61 +226,61 @@@ static const char *const cmd_flag_name[
  };
  #undef CMD_FLAG_NAME
  
++<<<<<<< HEAD
++=======
+ #define RQF_NAME(name) [ilog2((__force u32)RQF_##name)] = #name
+ static const char *const rqf_name[] = {
+ 	RQF_NAME(SORTED),
+ 	RQF_NAME(STARTED),
+ 	RQF_NAME(QUEUED),
+ 	RQF_NAME(SOFTBARRIER),
+ 	RQF_NAME(FLUSH_SEQ),
+ 	RQF_NAME(MIXED_MERGE),
+ 	RQF_NAME(MQ_INFLIGHT),
+ 	RQF_NAME(DONTPREP),
+ 	RQF_NAME(PREEMPT),
+ 	RQF_NAME(COPY_USER),
+ 	RQF_NAME(FAILED),
+ 	RQF_NAME(QUIET),
+ 	RQF_NAME(ELVPRIV),
+ 	RQF_NAME(IO_STAT),
+ 	RQF_NAME(ALLOCED),
+ 	RQF_NAME(PM),
+ 	RQF_NAME(HASHED),
+ 	RQF_NAME(STATS),
+ 	RQF_NAME(SPECIAL_PAYLOAD),
+ };
+ #undef RQF_NAME
+ 
+ #define RQAF_NAME(name) [REQ_ATOM_##name] = #name
+ static const char *const rqaf_name[] = {
+ 	RQAF_NAME(COMPLETE),
+ 	RQAF_NAME(STARTED),
+ 	RQAF_NAME(POLL_SLEPT),
+ };
+ #undef RQAF_NAME
+ 
++>>>>>>> c0cb1c6d3906 (blk-mq-debugfs: Show atomic request flags)
  int __blk_mq_debugfs_rq_show(struct seq_file *m, struct request *rq)
  {
 -	const struct blk_mq_ops *const mq_ops = rq->q->mq_ops;
 -	const unsigned int op = rq->cmd_flags & REQ_OP_MASK;
 -
 -	seq_printf(m, "%p {.op=", rq);
 -	if (op < ARRAY_SIZE(op_name) && op_name[op])
 -		seq_printf(m, "%s", op_name[op]);
 -	else
 -		seq_printf(m, "%d", op);
  	seq_puts(m, ", .cmd_flags=");
 -	blk_flags_show(m, rq->cmd_flags & ~REQ_OP_MASK, cmd_flag_name,
 +	blk_flags_show(m, rq->cmd_flags, cmd_flag_name,
  		       ARRAY_SIZE(cmd_flag_name));
++<<<<<<< HEAD
 +	seq_printf(m, ", .tag=%d, .internal_tag=%d}\n", rq->tag,
 +		   rq_aux(rq)->internal_tag);
++=======
+ 	seq_puts(m, ", .rq_flags=");
+ 	blk_flags_show(m, (__force unsigned int)rq->rq_flags, rqf_name,
+ 		       ARRAY_SIZE(rqf_name));
+ 	seq_puts(m, ", .atomic_flags=");
+ 	blk_flags_show(m, rq->atomic_flags, rqaf_name, ARRAY_SIZE(rqaf_name));
+ 	seq_printf(m, ", .tag=%d, .internal_tag=%d", rq->tag,
+ 		   rq->internal_tag);
+ 	if (mq_ops->show_rq)
+ 		mq_ops->show_rq(m, rq);
+ 	seq_puts(m, "}\n");
++>>>>>>> c0cb1c6d3906 (blk-mq-debugfs: Show atomic request flags)
  	return 0;
  }
  EXPORT_SYMBOL_GPL(__blk_mq_debugfs_rq_show);
* Unmerged path block/blk-mq-debugfs.c
