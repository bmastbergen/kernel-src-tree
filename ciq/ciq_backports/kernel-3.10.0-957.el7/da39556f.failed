x86/KVM/VMX: Expose SPEC_CTRL Bit(2) to the guest

jira LE-1907
cve CVE-2018-3639
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] kvm/vmx: Expose SPEC_CTRL Bit(2) to the guest (Waiman Long) [1566905] {CVE-2018-3639}
Rebuild_FUZZ: 95.74%
commit-author Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
commit da39556f66f5cfe8f9c989206974f1cb16ca5d7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/da39556f.failed

Expose the CPUID.7.EDX[31] bit to the guest, and also guard against various
combinations of SPEC_CTRL MSR values.

The handling of the MSR (to take into account the host value of SPEC_CTRL
Bit(2)) is taken care of in patch:

  KVM/SVM/VMX/x86/spectre_v2: Support the combination of guest and host IBRS

	Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Ingo Molnar <mingo@kernel.org>

(cherry picked from commit da39556f66f5cfe8f9c989206974f1cb16ca5d7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.c
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/cpuid.c
index 7bb663af32bb,376ac9a2a2b9..000000000000
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -383,12 -407,8 +383,17 @@@ static inline int __do_cpuid_ent(struc
  
  	/* cpuid 7.0.edx*/
  	const u32 kvm_cpuid_7_0_edx_x86_features =
++<<<<<<< HEAD
 +		F(AVX512_4VNNIW) | F(AVX512_4FMAPS) |
 +		F(SPEC_CTRL) | F(INTEL_STIBP);
 +
 +	/* cpuid 0x80000008.ebx */
 +	const u32 kvm_cpuid_8000_0008_ebx_x86_features =
 +		F(IBPB) | F(IBRS) | F(STIBP);
++=======
+ 		F(AVX512_4VNNIW) | F(AVX512_4FMAPS) | F(SPEC_CTRL) | F(RDS) |
+ 		F(ARCH_CAPABILITIES);
++>>>>>>> da39556f66f5 (x86/KVM/VMX: Expose SPEC_CTRL Bit(2) to the guest)
  
  	/* all calls to cpuid_count() should be made on the same cpu */
  	get_cpu();
diff --cc arch/x86/kvm/vmx.c
index c3d0093f5126,4197942b6d9b..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -3074,7 -3649,7 +3076,11 @@@ static int vmx_set_msr(struct kvm_vcpu 
  			return 1;
  
  		/* The STIBP bit doesn't fault even if it's not advertised */
++<<<<<<< HEAD
 +		if (data & ~(FEATURE_ENABLE_IBRS | FEATURE_ENABLE_STIBP))
++=======
+ 		if (data & ~(SPEC_CTRL_IBRS | SPEC_CTRL_STIBP | SPEC_CTRL_RDS))
++>>>>>>> da39556f66f5 (x86/KVM/VMX: Expose SPEC_CTRL Bit(2) to the guest)
  			return 1;
  
  		vmx->spec_ctrl = data;
* Unmerged path arch/x86/kvm/cpuid.c
* Unmerged path arch/x86/kvm/vmx.c
