netfilter: ipset: Fix coding styles reported by checkpatch.pl

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit ca0f6a5cd99e0c6ba4bb78dc402817f636370f26
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ca0f6a5c.failed

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit ca0f6a5cd99e0c6ba4bb78dc402817f636370f26)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/ipset/ip_set.h
#	net/netfilter/ipset/ip_set_bitmap_gen.h
#	net/netfilter/ipset/ip_set_bitmap_ipmac.c
#	net/netfilter/ipset/ip_set_core.c
#	net/netfilter/ipset/ip_set_hash_gen.h
#	net/netfilter/ipset/ip_set_hash_mac.c
#	net/netfilter/ipset/ip_set_hash_netiface.c
#	net/netfilter/ipset/ip_set_hash_netnet.c
#	net/netfilter/ipset/ip_set_hash_netportnet.c
#	net/netfilter/ipset/ip_set_list_set.c
#	net/netfilter/xt_set.c
diff --cc include/linux/netfilter/ipset/ip_set.h
index 3e9c90cf5227,48bb01edcf30..000000000000
--- a/include/linux/netfilter/ipset/ip_set.h
+++ b/include/linux/netfilter/ipset/ip_set.h
@@@ -235,6 -330,42 +235,45 @@@ ip_set_update_counter(struct ip_set_cou
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static inline void
+ ip_set_get_skbinfo(struct ip_set_skbinfo *skbinfo,
+ 		      const struct ip_set_ext *ext,
+ 		      struct ip_set_ext *mext, u32 flags)
+ {
+ 		mext->skbmark = skbinfo->skbmark;
+ 		mext->skbmarkmask = skbinfo->skbmarkmask;
+ 		mext->skbprio = skbinfo->skbprio;
+ 		mext->skbqueue = skbinfo->skbqueue;
+ }
+ static inline bool
+ ip_set_put_skbinfo(struct sk_buff *skb, struct ip_set_skbinfo *skbinfo)
+ {
+ 	/* Send nonzero parameters only */
+ 	return ((skbinfo->skbmark || skbinfo->skbmarkmask) &&
+ 		nla_put_net64(skb, IPSET_ATTR_SKBMARK,
+ 			      cpu_to_be64((u64)skbinfo->skbmark << 32 |
+ 					  skbinfo->skbmarkmask))) ||
+ 	       (skbinfo->skbprio &&
+ 		nla_put_net32(skb, IPSET_ATTR_SKBPRIO,
+ 			      cpu_to_be32(skbinfo->skbprio))) ||
+ 	       (skbinfo->skbqueue &&
+ 		nla_put_net16(skb, IPSET_ATTR_SKBQUEUE,
+ 			     cpu_to_be16(skbinfo->skbqueue)));
+ }
+ 
+ static inline void
+ ip_set_init_skbinfo(struct ip_set_skbinfo *skbinfo,
+ 		    const struct ip_set_ext *ext)
+ {
+ 	skbinfo->skbmark = ext->skbmark;
+ 	skbinfo->skbmarkmask = ext->skbmarkmask;
+ 	skbinfo->skbprio = ext->skbprio;
+ 	skbinfo->skbqueue = ext->skbqueue;
+ }
+ 
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  static inline bool
  ip_set_put_counter(struct sk_buff *skb, struct ip_set_counter *counter)
  {
diff --cc net/netfilter/ipset/ip_set_bitmap_gen.h
index 01a340ce9e94,d05e759ed0fa..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_gen.h
+++ b/net/netfilter/ipset/ip_set_bitmap_gen.h
@@@ -44,9 -41,9 +44,9 @@@ mtype_gc_init(struct ip_set *set, void 
  	struct mtype *map = set->data;
  
  	init_timer(&map->gc);
- 	map->gc.data = (unsigned long) set;
+ 	map->gc.data = (unsigned long)set;
  	map->gc.function = gc;
 -	map->gc.expires = jiffies + IPSET_GC_PERIOD(set->timeout) * HZ;
 +	map->gc.expires = jiffies + IPSET_GC_PERIOD(map->timeout) * HZ;
  	add_timer(&map->gc);
  }
  
@@@ -184,35 -223,24 +184,40 @@@ mtype_list(const struct ip_set *set
  		if (!test_bit(id, map->members) ||
  		    (SET_WITH_TIMEOUT(set) &&
  #ifdef IP_SET_BITMAP_STORED_TIMEOUT
- 		     mtype_is_filled((const struct mtype_elem *) x) &&
+ 		     mtype_is_filled((const struct mtype_elem *)x) &&
  #endif
 -		     ip_set_timeout_expired(ext_timeout(x, set))))
 +		     ip_set_timeout_expired(ext_timeout(x, map))))
  			continue;
  		nested = ipset_nest_start(skb, IPSET_ATTR_DATA);
  		if (!nested) {
  			if (id == first) {
  				nla_nest_cancel(skb, adt);
 -				ret = -EMSGSIZE;
 -				goto out;
 -			}
 -
 -			goto nla_put_failure;
 +				return -EMSGSIZE;
 +			} else
 +				goto nla_put_failure;
  		}
 -		if (mtype_do_list(skb, map, id, set->dsize))
 +		if (mtype_do_list(skb, map, id))
  			goto nla_put_failure;
++<<<<<<< HEAD
 +		if (SET_WITH_TIMEOUT(set)) {
 +#ifdef IP_SET_BITMAP_STORED_TIMEOUT
 +			if (nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
 +					  htonl(ip_set_timeout_stored(map, id,
 +							ext_timeout(x, map)))))
 +				goto nla_put_failure;
 +#else
 +			if (nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
 +					  htonl(ip_set_timeout_get(
 +							ext_timeout(x, map)))))
 +				goto nla_put_failure;
 +#endif
 +		}
 +		if (SET_WITH_COUNTER(set) &&
 +		    ip_set_put_counter(skb, ext_counter(x, map)))
++=======
+ 		if (ip_set_put_extensions(skb, set, x,
+ 		    mtype_is_filled((const struct mtype_elem *)x)))
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  			goto nla_put_failure;
  		ipset_nest_end(skb, nested);
  	}
@@@ -236,23 -266,26 +241,29 @@@ nla_put_failure
  static void
  mtype_gc(unsigned long ul_set)
  {
- 	struct ip_set *set = (struct ip_set *) ul_set;
+ 	struct ip_set *set = (struct ip_set *)ul_set;
  	struct mtype *map = set->data;
 -	void *x;
 +	const void *x;
  	u32 id;
  
  	/* We run parallel with other readers (test element)
++<<<<<<< HEAD
 +	 * but adding/deleting new entries is locked out */
 +	read_lock_bh(&set->lock);
++=======
+ 	 * but adding/deleting new entries is locked out
+ 	 */
+ 	spin_lock_bh(&set->lock);
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  	for (id = 0; id < map->elements; id++)
 -		if (mtype_gc_test(id, map, set->dsize)) {
 -			x = get_ext(set, map, id);
 -			if (ip_set_timeout_expired(ext_timeout(x, set))) {
 +		if (mtype_gc_test(id, map)) {
 +			x = get_ext(map, id);
 +			if (ip_set_timeout_expired(ext_timeout(x, map)))
  				clear_bit(id, map->members);
 -				ip_set_ext_destroy(set, x);
 -			}
  		}
 -	spin_unlock_bh(&set->lock);
 +	read_unlock_bh(&set->lock);
  
 -	map->gc.expires = jiffies + IPSET_GC_PERIOD(set->timeout) * HZ;
 +	map->gc.expires = jiffies + IPSET_GC_PERIOD(map->timeout) * HZ;
  	add_timer(&map->gc);
  }
  
diff --cc net/netfilter/ipset/ip_set_bitmap_ipmac.c
index b2a7bea3f7b6,1430535118fb..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_ipmac.c
+++ b/net/netfilter/ipset/ip_set_bitmap_ipmac.c
@@@ -89,9 -88,9 +89,9 @@@ bitmap_ipmac_do_test(const struct bitma
  
  	if (!test_bit(e->id, map->members))
  		return 0;
 -	elem = get_elem(map->extensions, e->id, dsize);
 +	elem = get_elem(map->extensions, e->id, map->dsize);
  	if (elem->filled == MAC_FILLED)
- 		return e->ether == NULL ||
+ 		return !e->ether ||
  		       ether_addr_equal(e->ether, elem->ether);
  	/* Trigger kernel to fill out the ethernet address */
  	return -EAGAIN;
@@@ -147,17 -147,25 +148,34 @@@ bitmap_ipmac_do_add(const struct bitmap
  {
  	struct bitmap_ipmac_elem *elem;
  
 -	elem = get_elem(map->extensions, e->id, dsize);
 -	if (test_bit(e->id, map->members)) {
 +	elem = get_elem(map->extensions, e->id, map->dsize);
 +	if (test_and_set_bit(e->id, map->members)) {
  		if (elem->filled == MAC_FILLED) {
++<<<<<<< HEAD
 +			if (e->ether && (flags & IPSET_FLAG_EXIST))
 +				memcpy(elem->ether, e->ether, ETH_ALEN);
++=======
+ 			if (e->ether &&
+ 			    (flags & IPSET_FLAG_EXIST) &&
+ 			    !ether_addr_equal(e->ether, elem->ether)) {
+ 				/* memcpy isn't atomic */
+ 				clear_bit(e->id, map->members);
+ 				smp_mb__after_atomic();
+ 				ether_addr_copy(elem->ether, e->ether);
+ 			}
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  			return IPSET_ADD_FAILED;
  		} else if (!e->ether)
  			/* Already added without ethernet address */
  			return IPSET_ADD_FAILED;
  		/* Fill the MAC address and trigger the timer activation */
++<<<<<<< HEAD
 +		memcpy(elem->ether, e->ether, ETH_ALEN);
++=======
+ 		clear_bit(e->id, map->members);
+ 		smp_mb__after_atomic();
+ 		ether_addr_copy(elem->ether, e->ether);
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  		elem->filled = MAC_FILLED;
  		return IPSET_ADD_START_STORED_TIMEOUT;
  	} else if (e->ether) {
diff --cc net/netfilter/ipset/ip_set_core.c
index 1b9673fde81c,338b4047776f..000000000000
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@@ -57,11 -58,10 +58,10 @@@ MODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_IP
  /* When the nfnl mutex is held: */
  #define ip_set_dereference(p)		\
  	rcu_dereference_protected(p, 1)
 -#define ip_set(inst, id)		\
 +#define ip_set(inst, id)			\
  	ip_set_dereference((inst)->ip_set_list)[id]
  
- /*
-  * The set types are implemented in modules and registered set types
+ /* The set types are implemented in modules and registered set types
   * can be found in ip_set_type_list. Adding/deleting types is
   * serialized by ip_set_type_mutex.
   */
@@@ -347,8 -443,32 +348,37 @@@ ip_set_get_extensions(struct ip_set *se
  }
  EXPORT_SYMBOL_GPL(ip_set_get_extensions);
  
++<<<<<<< HEAD
 +/*
 + * Creating/destroying/renaming/swapping affect the existence and
++=======
+ int
+ ip_set_put_extensions(struct sk_buff *skb, const struct ip_set *set,
+ 		      const void *e, bool active)
+ {
+ 	if (SET_WITH_TIMEOUT(set)) {
+ 		unsigned long *timeout = ext_timeout(e, set);
+ 
+ 		if (nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
+ 			htonl(active ? ip_set_timeout_get(timeout)
+ 				: *timeout)))
+ 			return -EMSGSIZE;
+ 	}
+ 	if (SET_WITH_COUNTER(set) &&
+ 	    ip_set_put_counter(skb, ext_counter(e, set)))
+ 		return -EMSGSIZE;
+ 	if (SET_WITH_COMMENT(set) &&
+ 	    ip_set_put_comment(skb, ext_comment(e, set)))
+ 		return -EMSGSIZE;
+ 	if (SET_WITH_SKBINFO(set) &&
+ 	    ip_set_put_skbinfo(skb, ext_skbinfo(e, set)))
+ 		return -EMSGSIZE;
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(ip_set_put_extensions);
+ 
+ /* Creating/destroying/renaming/swapping affect the existence and
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
   * the properties of a set. All of these can be executed from userspace
   * only and serialized by the nfnl mutex indirectly from nfnetlink.
   *
@@@ -375,28 -495,7 +405,32 @@@ __ip_set_put(struct ip_set *set
  	write_unlock_bh(&ip_set_ref_lock);
  }
  
++<<<<<<< HEAD
 +/* set->ref can be swapped out by ip_set_swap, netlink events (like dump) need
 + * a separate reference counter
 + */
 +static inline void
 +__ip_set_get_netlink(struct ip_set *set)
 +{
 +	write_lock_bh(&ip_set_ref_lock);
 +	set->ref_netlink++;
 +	write_unlock_bh(&ip_set_ref_lock);
 +}
 +
 +static inline void
 +__ip_set_put_netlink(struct ip_set *set)
 +{
 +	write_lock_bh(&ip_set_ref_lock);
 +	BUG_ON(set->ref_netlink == 0);
 +	set->ref_netlink--;
 +	write_unlock_bh(&ip_set_ref_lock);
 +}
 +
 +/* 
 + * Add, del and test set entries from kernel.
++=======
+ /* Add, del and test set entries from kernel.
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
   *
   * The set behind the index must exist and must be referenced
   * so it can't be destroyed (or changed) under our foot.
@@@ -773,14 -865,13 +800,13 @@@ ip_set_create(struct sock *ctnl, struc
  	pr_debug("setname: %s, typename: %s, family: %s, revision: %u\n",
  		 name, typename, family_name(family), revision);
  
- 	/*
- 	 * First, and without any locks, allocate and initialize
+ 	/* First, and without any locks, allocate and initialize
  	 * a normal base set structure.
  	 */
- 	set = kzalloc(sizeof(struct ip_set), GFP_KERNEL);
+ 	set = kzalloc(sizeof(*set), GFP_KERNEL);
  	if (!set)
  		return -ENOMEM;
 -	spin_lock_init(&set->lock);
 +	rwlock_init(&set->lock);
  	strlcpy(set->name, name, IPSET_MAXNAMELEN);
  	set->family = family;
  	set->revision = revision;
@@@ -918,7 -1004,7 +939,11 @@@ ip_set_destroy(struct sock *ctnl, struc
  	if (!attr[IPSET_ATTR_SETNAME]) {
  		for (i = 0; i < inst->ip_set_max; i++) {
  			s = ip_set(inst, i);
++<<<<<<< HEAD
 +			if (s != NULL && (s->ref || s->ref_netlink)) {
++=======
+ 			if (s && s->ref) {
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  				ret = -IPSET_ERR_BUSY;
  				goto out;
  			}
@@@ -937,10 -1023,10 +962,10 @@@
  	} else {
  		s = find_set_and_id(inst, nla_data(attr[IPSET_ATTR_SETNAME]),
  				    &i);
- 		if (s == NULL) {
+ 		if (!s) {
  			ret = -ENOENT;
  			goto out;
 -		} else if (s->ref) {
 +		} else if (s->ref || s->ref_netlink) {
  			ret = -IPSET_ERR_BUSY;
  			goto out;
  		}
@@@ -1170,15 -1251,18 +1196,22 @@@ dump_init(struct netlink_callback *cb
  			return -ENOENT;
  
  		dump_type = DUMP_ONE;
++<<<<<<< HEAD
 +		cb->args[1] = index;
 +	} else
++=======
+ 		cb->args[IPSET_CB_INDEX] = index;
+ 	} else {
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  		dump_type = DUMP_ALL;
+ 	}
  
  	if (cda[IPSET_ATTR_FLAGS]) {
  		u32 f = ip_set_get_h32(cda[IPSET_ATTR_FLAGS]);
+ 
  		dump_type |= (f << 16);
  	}
 -	cb->args[IPSET_CB_NET] = (unsigned long)inst;
 -	cb->args[IPSET_CB_DUMP] = dump_type;
 +	cb->args[0] = dump_type;
  
  	return 0;
  }
@@@ -1207,17 -1292,18 +1241,24 @@@ ip_set_dump_start(struct sk_buff *skb, 
  		}
  	}
  
 -	if (cb->args[IPSET_CB_INDEX] >= inst->ip_set_max)
 +	if (cb->args[1] >= inst->ip_set_max)
  		goto out;
  
 -	dump_type = DUMP_TYPE(cb->args[IPSET_CB_DUMP]);
 -	dump_flags = DUMP_FLAGS(cb->args[IPSET_CB_DUMP]);
 -	max = dump_type == DUMP_ONE ? cb->args[IPSET_CB_INDEX] + 1
 -				    : inst->ip_set_max;
 +	dump_type = DUMP_TYPE(cb->args[0]);
 +	dump_flags = DUMP_FLAGS(cb->args[0]);
 +	max = dump_type == DUMP_ONE ? cb->args[1] + 1 : inst->ip_set_max;
  dump_last:
++<<<<<<< HEAD
 +	pr_debug("args[0]: %u %u args[1]: %ld\n",
 +		 dump_type, dump_flags, cb->args[1]);
 +	for (; cb->args[1] < max; cb->args[1]++) {
 +		index = (ip_set_id_t) cb->args[1];
++=======
+ 	pr_debug("dump type, flag: %u %u index: %ld\n",
+ 		 dump_type, dump_flags, cb->args[IPSET_CB_INDEX]);
+ 	for (; cb->args[IPSET_CB_INDEX] < max; cb->args[IPSET_CB_INDEX]++) {
+ 		index = (ip_set_id_t)cb->args[IPSET_CB_INDEX];
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  		write_lock_bh(&ip_set_ref_lock);
  		set = ip_set(inst, index);
  		is_destroyed = inst->is_destroyed;
@@@ -1965,28 -2055,25 +2007,35 @@@ static struct pernet_operations ip_set_
  static int __init
  ip_set_init(void)
  {
++<<<<<<< HEAD
 +	int ret = register_pernet_subsys(&ip_set_net_ops);
 +
 +	if (ret) {
 +		pr_err("ip_set: cannot register pernet_subsys.\n");
++=======
+ 	int ret = nfnetlink_subsys_register(&ip_set_netlink_subsys);
+ 
+ 	if (ret != 0) {
+ 		pr_err("ip_set: cannot register with nfnetlink.\n");
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  		return ret;
  	}
 -	ret = nf_register_sockopt(&so_set);
 +
 +	ret = nfnetlink_subsys_register(&ip_set_netlink_subsys);
  	if (ret != 0) {
 -		pr_err("SO_SET registry failed: %d\n", ret);
 -		nfnetlink_subsys_unregister(&ip_set_netlink_subsys);
 +		pr_err("ip_set: cannot register with nfnetlink.\n");
 +		unregister_pernet_subsys(&ip_set_net_ops);
  		return ret;
  	}
 -	ret = register_pernet_subsys(&ip_set_net_ops);
 -	if (ret) {
 -		pr_err("ip_set: cannot register pernet_subsys.\n");
 -		nf_unregister_sockopt(&so_set);
 +
 +	ret = nf_register_sockopt(&so_set);
 +	if (ret != 0) {
 +		pr_err("SO_SET registry failed: %d\n", ret);
  		nfnetlink_subsys_unregister(&ip_set_netlink_subsys);
 +		unregister_pernet_subsys(&ip_set_net_ops);
  		return ret;
  	}
 +
  	pr_info("ip_set: protocol %u\n", IPSET_PROTOCOL);
  	return 0;
  }
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 9ce28af662bf,afe905c208af..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -35,7 -35,9 +35,13 @@@
  /* Number of elements to store in an initial array block */
  #define AHASH_INIT_SIZE			4
  /* Max number of elements to store in an array block */
++<<<<<<< HEAD
 +#define AHASH_MAX_SIZE			(3*AHASH_INIT_SIZE)
++=======
+ #define AHASH_MAX_SIZE			(3 * AHASH_INIT_SIZE)
+ /* Max muber of elements in the array block when tuned */
+ #define AHASH_MAX_TUNED			64
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  
  /* Max number of elements can be tuned */
  #ifdef IP_SET_HASH_WITH_MULTI
@@@ -53,8 -55,9 +59,9 @@@ tune_ahash_max(u8 curr, u32 multi
  	/* Currently, at listing one hash bucket must fit into a message.
  	 * Therefore we have a hard limit here.
  	 */
 -	return n > curr && n <= AHASH_MAX_TUNED ? n : curr;
 +	return n > curr && n <= 64 ? n : curr;
  }
+ 
  #define TUNE_AHASH_MAX(h, multi)	\
  	((h)->ahash_max = tune_ahash_max((h)->ahash_max, multi))
  #else
@@@ -300,13 -299,13 +307,23 @@@ mtype_add_cidr(struct htype *h, u8 cidr
  	int i, j;
  
  	/* Add in increasing prefix order, so larger cidr first */
++<<<<<<< HEAD
 +	for (i = 0, j = -1; i < nets_length && h->nets[i].nets; i++) {
 +		if (j != -1)
 +			continue;
 +		else if (h->nets[i].cidr < cidr)
 +			j = i;
 +		else if (h->nets[i].cidr == cidr) {
 +			h->nets[i].nets++;
++=======
+ 	for (i = 0, j = -1; i < nets_length && h->nets[i].cidr[n]; i++) {
+ 		if (j != -1) {
+ 			continue;
+ 		} else if (h->nets[i].cidr[n] < cidr) {
+ 			j = i;
+ 		} else if (h->nets[i].cidr[n] == cidr) {
+ 			h->nets[cidr - 1].nets[n]++;
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  			return;
  		}
  	}
@@@ -326,19 -323,15 +343,31 @@@ mtype_del_cidr(struct htype *h, u8 cidr
  	u8 i, j, net_end = nets_length - 1;
  
  	for (i = 0; i < nets_length; i++) {
++<<<<<<< HEAD
 +	        if (h->nets[i].cidr != cidr)
 +	                continue;
 +                if (h->nets[i].nets > 1 || i == net_end ||
 +                    h->nets[i + 1].nets == 0) {
 +                        h->nets[i].nets--;
 +                        return;
 +                }
 +                for (j = i; j < net_end && h->nets[j].nets; j++) {
 +		        h->nets[j].cidr = h->nets[j + 1].cidr;
 +		        h->nets[j].nets = h->nets[j + 1].nets;
 +                }
 +                h->nets[j].nets = 0;
 +                return;
++=======
+ 		if (h->nets[i].cidr[n] != cidr)
+ 			continue;
+ 		h->nets[cidr - 1].nets[n]--;
+ 		if (h->nets[cidr - 1].nets[n] > 0)
+ 			return;
+ 		for (j = i; j < net_end && h->nets[j].cidr[n]; j++)
+ 			h->nets[j].cidr[n] = h->nets[j + 1].cidr[n];
+ 		h->nets[j].cidr[n] = 0;
+ 		return;
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  	}
  }
  #endif
@@@ -392,13 -424,11 +421,18 @@@ mtype_destroy(struct ip_set *set
  {
  	struct htype *h = set->data;
  
 -	if (SET_WITH_TIMEOUT(set))
 +	if (set->extensions & IPSET_EXT_TIMEOUT)
  		del_timer_sync(&h->gc);
  
++<<<<<<< HEAD
 +	ahash_destroy(h->table);
 +#ifdef IP_SET_HASH_WITH_RBTREE
 +	rbtree_destroy(&h->rbtree);
 +#endif
++=======
+ 	mtype_ahash_destroy(set,
+ 			    __ipset_dereference_protected(h->table, 1), true);
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  	kfree(h);
  
  	set->data = NULL;
@@@ -410,12 -440,12 +444,12 @@@ mtype_gc_init(struct ip_set *set, void 
  	struct htype *h = set->data;
  
  	init_timer(&h->gc);
- 	h->gc.data = (unsigned long) set;
+ 	h->gc.data = (unsigned long)set;
  	h->gc.function = gc;
 -	h->gc.expires = jiffies + IPSET_GC_PERIOD(set->timeout) * HZ;
 +	h->gc.expires = jiffies + IPSET_GC_PERIOD(h->timeout) * HZ;
  	add_timer(&h->gc);
  	pr_debug("gc initialized, run in every %u\n",
 -		 IPSET_GC_PERIOD(set->timeout));
 +		 IPSET_GC_PERIOD(h->timeout));
  }
  
  static bool
@@@ -787,14 -1002,21 +824,26 @@@ mtype_test(struct ip_set *set, void *va
  	struct mtype_elem *d = value;
  	struct hbucket *n;
  	struct mtype_elem *data;
 -	int i, ret = 0;
 +	int i;
  	u32 key, multi = 0;
  
 -	t = rcu_dereference_bh(h->table);
  #ifdef IP_SET_HASH_WITH_NETS
  	/* If we test an IP address and not a network address,
++<<<<<<< HEAD
 +	 * try all possible network sizes */
 +	if (CIDR(d->cidr) == SET_HOST_MASK(set->family))
 +		return mtype_test_cidrs(set, d, ext, mext, flags);
++=======
+ 	 * try all possible network sizes
+ 	 */
+ 	for (i = 0; i < IPSET_NET_COUNT; i++)
+ 		if (DCIDR_GET(d->cidr, i) != SET_HOST_MASK(set->family))
+ 			break;
+ 	if (i == IPSET_NET_COUNT) {
+ 		ret = mtype_test_cidrs(set, d, ext, mext, flags);
+ 		goto out;
+ 	}
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  #endif
  
  	key = HKEY(d, h->initval, t->htable_bits);
@@@ -866,25 -1125,36 +915,32 @@@ mtype_list(const struct ip_set *set
  	atd = ipset_nest_start(skb, IPSET_ATTR_ADT);
  	if (!atd)
  		return -EMSGSIZE;
 -
  	pr_debug("list hash set %s\n", set->name);
 -	t = (const struct htable *)cb->args[IPSET_CB_PRIVATE];
 -	/* Expire may replace a hbucket with another one */
 -	rcu_read_lock();
 -	for (; cb->args[IPSET_CB_ARG0] < jhash_size(t->htable_bits);
 -	     cb->args[IPSET_CB_ARG0]++) {
 +	for (; cb->args[2] < jhash_size(t->htable_bits); cb->args[2]++) {
  		incomplete = skb_tail_pointer(skb);
 -		n = rcu_dereference(hbucket(t, cb->args[IPSET_CB_ARG0]));
 -		pr_debug("cb->arg bucket: %lu, t %p n %p\n",
 -			 cb->args[IPSET_CB_ARG0], t, n);
 -		if (!n)
 -			continue;
 +		n = hbucket(t, cb->args[2]);
 +		pr_debug("cb->args[2]: %lu, t %p n %p\n", cb->args[2], t, n);
  		for (i = 0; i < n->pos; i++) {
 -			if (!test_bit(i, n->used))
 -				continue;
 -			e = ahash_data(n, i, set->dsize);
 +			e = ahash_data(n, i, h->dsize);
  			if (SET_WITH_TIMEOUT(set) &&
 -			    ip_set_timeout_expired(ext_timeout(e, set)))
 +			    ip_set_timeout_expired(ext_timeout(e, h)))
  				continue;
  			pr_debug("list hash %lu hbucket %p i %u, data %p\n",
 -				 cb->args[IPSET_CB_ARG0], n, i, e);
 +				 cb->args[2], n, i, e);
  			nested = ipset_nest_start(skb, IPSET_ATTR_DATA);
  			if (!nested) {
 -				if (cb->args[IPSET_CB_ARG0] == first) {
 +				if (cb->args[2] == first) {
  					nla_nest_cancel(skb, atd);
++<<<<<<< HEAD
 +					return -EMSGSIZE;
 +				} else
 +					goto nla_put_failure;
++=======
+ 					ret = -EMSGSIZE;
+ 					goto out;
+ 				}
+ 				goto nla_put_failure;
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  			}
  			if (mtype_data_list(skb, e))
  				goto nla_put_failure;
@@@ -907,14 -1171,17 +963,28 @@@
  
  nla_put_failure:
  	nlmsg_trim(skb, incomplete);
++<<<<<<< HEAD
 +	if (unlikely(first == cb->args[2])) {
 +		pr_warning("Can't list set %s: one bucket does not fit into "
 +			   "a message. Please report it!\n", set->name);
 +		cb->args[2] = 0;
 +		return -EMSGSIZE;
 +	}
 +	ipset_nest_end(skb, atd);
 +	return 0;
++=======
+ 	if (unlikely(first == cb->args[IPSET_CB_ARG0])) {
+ 		pr_warn("Can't list set %s: one bucket does not fit into a message. Please report it!\n",
+ 			set->name);
+ 		cb->args[IPSET_CB_ARG0] = 0;
+ 		ret = -EMSGSIZE;
+ 	} else {
+ 		ipset_nest_end(skb, atd);
+ 	}
+ out:
+ 	rcu_read_unlock();
+ 	return ret;
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  }
  
  static int
diff --cc net/netfilter/ipset/ip_set_hash_netiface.c
index aa4929b15a09,43d8c9896fa3..000000000000
--- a/net/netfilter/ipset/ip_set_hash_netiface.c
+++ b/net/netfilter/ipset/ip_set_hash_netiface.c
@@@ -301,30 -177,20 +301,41 @@@ hash_netiface4_kadt(struct ip_set *set
  
  	if (opt->cmdflags & IPSET_FLAG_PHYSDEV) {
  #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
++<<<<<<< HEAD
 +		e.iface = SRCDIR ? get_physindev_name(skb) :
 +				   get_phyoutdev_name(skb);
++=======
+ 		const char *eiface = SRCDIR ? get_physindev_name(skb) :
+ 					      get_physoutdev_name(skb);
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  
 -		if (!eiface)
 +		if (!e.iface)
  			return -EINVAL;
 -		STRLCPY(e.iface, eiface);
  		e.physdev = 1;
 +#else
 +		e.iface = NULL;
  #endif
++<<<<<<< HEAD
 +	} else
 +		e.iface = SRCDIR ? IFACE(in) : IFACE(out);
++=======
+ 	} else {
+ 		STRLCPY(e.iface, SRCDIR ? IFACE(in) : IFACE(out));
+ 	}
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  
 -	if (strlen(e.iface) == 0)
 +	if (!e.iface)
  		return -EINVAL;
 +	ret = iface_test(&h->rbtree, &e.iface);
 +	if (adt == IPSET_ADD) {
 +		if (!ret) {
 +			ret = iface_add(&h->rbtree, &e.iface);
 +			if (ret)
 +				return ret;
 +		}
 +	} else if (!ret)
 +		return ret;
 +
  	return adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);
  }
  
@@@ -565,50 -387,39 +578,65 @@@ hash_netiface6_kadt(struct ip_set *set
  
  	if (opt->cmdflags & IPSET_FLAG_PHYSDEV) {
  #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
++<<<<<<< HEAD
 +		e.iface = SRCDIR ? get_physindev_name(skb) :
 +				   get_phyoutdev_name(skb);
 +		if (!e.iface)
 +			return -EINVAL;
 +
++=======
+ 		const char *eiface = SRCDIR ? get_physindev_name(skb) :
+ 					      get_physoutdev_name(skb);
+ 
+ 		if (!eiface)
+ 			return -EINVAL;
+ 		STRLCPY(e.iface, eiface);
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  		e.physdev = 1;
 +#else
 +		e.iface = NULL;
  #endif
++<<<<<<< HEAD
 +	} else
 +		e.iface = SRCDIR ? IFACE(in) : IFACE(out);
++=======
+ 	} else {
+ 		STRLCPY(e.iface, SRCDIR ? IFACE(in) : IFACE(out));
+ 	}
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  
 -	if (strlen(e.iface) == 0)
 +	if (!e.iface)
  		return -EINVAL;
 +	ret = iface_test(&h->rbtree, &e.iface);
 +	if (adt == IPSET_ADD) {
 +		if (!ret) {
 +			ret = iface_add(&h->rbtree, &e.iface);
 +			if (ret)
 +				return ret;
 +		}
 +	} else if (!ret)
 +		return ret;
  
  	return adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);
  }
  
  static int
  hash_netiface6_uadt(struct ip_set *set, struct nlattr *tb[],
- 		   enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
+ 		    enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
  {
 +	struct hash_netiface *h = set->data;
  	ipset_adtfn adtfn = set->variant->adt[adt];
  	struct hash_netiface6_elem e = { .cidr = HOST_MASK, .elem = 1 };
 -	struct ip_set_ext ext = IP_SET_INIT_UEXT(set);
 +	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
 +	char iface[IFNAMSIZ];
  	int ret;
  
 -	if (tb[IPSET_ATTR_LINENO])
 -		*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);
 -
  	if (unlikely(!tb[IPSET_ATTR_IP] ||
  		     !tb[IPSET_ATTR_IFACE] ||
 -		     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS) ||
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_PACKETS) ||
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_BYTES)))
  		return -IPSET_ERR_PROTOCOL;
  	if (unlikely(tb[IPSET_ATTR_IP_TO]))
  		return -IPSET_ERR_HASH_RANGE_UNSUPPORTED;
diff --cc net/netfilter/ipset/ip_set_list_set.c
index a9a97c07ecb4,a1fe5377a2b3..000000000000
--- a/net/netfilter/ipset/ip_set_list_set.c
+++ b/net/netfilter/ipset/ip_set_list_set.c
@@@ -264,26 -194,27 +264,38 @@@ list_set_utest(struct ip_set *set, voi
  {
  	struct list_set *map = set->data;
  	struct set_adt_elem *d = value;
 -	struct set_elem *e, *next, *prev = NULL;
 +	struct set_elem *e;
 +	u32 i;
  	int ret;
  
 -	list_for_each_entry(e, &map->members, list) {
 -		if (SET_WITH_TIMEOUT(set) &&
 -		    ip_set_timeout_expired(ext_timeout(e, set)))
 +	for (i = 0; i < map->size; i++) {
 +		e = list_set_elem(map, i);
 +		if (e->id == IPSET_INVALID_ID)
 +			return 0;
 +		else if (SET_WITH_TIMEOUT(set) &&
 +			 ip_set_timeout_expired(ext_timeout(e, map)))
  			continue;
 -		else if (e->id != d->id) {
 -			prev = e;
 +		else if (e->id != d->id)
  			continue;
 -		}
  
++<<<<<<< HEAD
 +		if (d->before == 0)
 +			return 1;
 +		else if (d->before > 0)
 +			ret = id_eq(set, i + 1, d->refid);
 +		else
 +			ret = i > 0 && id_eq(set, i - 1, d->refid);
++=======
+ 		if (d->before == 0) {
+ 			ret = 1;
+ 		} else if (d->before > 0) {
+ 			next = list_next_entry(e, list);
+ 			ret = !list_is_last(&e->list, &map->members) &&
+ 			      next->id == d->refid;
+ 		} else {
+ 			ret = prev && prev->id == d->refid;
+ 		}
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  		return ret;
  	}
  	return 0;
@@@ -589,14 -559,14 +601,14 @@@ static const struct ip_set_type_varian
  static void
  list_set_gc(unsigned long ul_set)
  {
- 	struct ip_set *set = (struct ip_set *) ul_set;
+ 	struct ip_set *set = (struct ip_set *)ul_set;
  	struct list_set *map = set->data;
  
 -	spin_lock_bh(&set->lock);
 +	write_lock_bh(&set->lock);
  	set_cleanup_entries(set);
 -	spin_unlock_bh(&set->lock);
 +	write_unlock_bh(&set->lock);
  
 -	map->gc.expires = jiffies + IPSET_GC_PERIOD(set->timeout) * HZ;
 +	map->gc.expires = jiffies + IPSET_GC_PERIOD(map->timeout) * HZ;
  	add_timer(&map->gc);
  }
  
@@@ -606,9 -576,9 +618,9 @@@ list_set_gc_init(struct ip_set *set, vo
  	struct list_set *map = set->data;
  
  	init_timer(&map->gc);
- 	map->gc.data = (unsigned long) set;
+ 	map->gc.data = (unsigned long)set;
  	map->gc.function = gc;
 -	map->gc.expires = jiffies + IPSET_GC_PERIOD(set->timeout) * HZ;
 +	map->gc.expires = jiffies + IPSET_GC_PERIOD(map->timeout) * HZ;
  	add_timer(&map->gc);
  }
  
diff --cc net/netfilter/xt_set.c
index 6cc2d6757ad8,5669e5b453f4..000000000000
--- a/net/netfilter/xt_set.c
+++ b/net/netfilter/xt_set.c
@@@ -85,13 -87,12 +87,18 @@@ set_match_v0_checkentry(const struct xt
  	index = ip_set_nfnl_get_byindex(par->net, info->match_set.index);
  
  	if (index == IPSET_INVALID_ID) {
 -		pr_warn("Cannot find set identified by id %u to match\n",
 -			info->match_set.index);
 +		pr_warning("Cannot find set indentified by id %u to match\n",
 +			   info->match_set.index);
  		return -ENOENT;
  	}
++<<<<<<< HEAD
 +	if (info->match_set.u.flags[IPSET_DIM_MAX-1] != 0) {
 +		pr_warning("Protocol error: set match dimension "
 +			   "is over the limit!\n");
++=======
+ 	if (info->match_set.u.flags[IPSET_DIM_MAX - 1] != 0) {
+ 		pr_warn("Protocol error: set match dimension is over the limit!\n");
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  		ip_set_nfnl_put(par->net, info->match_set.index);
  		return -ERANGE;
  	}
@@@ -293,10 -297,9 +304,16 @@@ set_target_v0_checkentry(const struct x
  			return -ENOENT;
  		}
  	}
++<<<<<<< HEAD
 +	if (info->add_set.u.flags[IPSET_DIM_MAX-1] != 0 ||
 +	    info->del_set.u.flags[IPSET_DIM_MAX-1] != 0) {
 +		pr_warning("Protocol error: SET target dimension "
 +			   "is over the limit!\n");
++=======
+ 	if (info->add_set.u.flags[IPSET_DIM_MAX - 1] != 0 ||
+ 	    info->del_set.u.flags[IPSET_DIM_MAX - 1] != 0) {
+ 		pr_warn("Protocol error: SET target dimension is over the limit!\n");
++>>>>>>> ca0f6a5cd99e (netfilter: ipset: Fix coding styles reported by checkpatch.pl)
  		if (info->add_set.index != IPSET_INVALID_ID)
  			ip_set_nfnl_put(par->net, info->add_set.index);
  		if (info->del_set.index != IPSET_INVALID_ID)
* Unmerged path net/netfilter/ipset/ip_set_hash_mac.c
* Unmerged path net/netfilter/ipset/ip_set_hash_netnet.c
* Unmerged path net/netfilter/ipset/ip_set_hash_netportnet.c
* Unmerged path include/linux/netfilter/ipset/ip_set.h
diff --git a/include/uapi/linux/netfilter/ipset/ip_set.h b/include/uapi/linux/netfilter/ipset/ip_set.h
index cc7b52e72abf..307e275416f4 100644
--- a/include/uapi/linux/netfilter/ipset/ip_set.h
+++ b/include/uapi/linux/netfilter/ipset/ip_set.h
@@ -19,6 +19,9 @@
 /* The max length of strings including NUL: set and type identifiers */
 #define IPSET_MAXNAMELEN	32
 
+/* The maximum permissible comment length we will accept over netlink */
+#define IPSET_MAX_COMMENT_SIZE	255
+
 /* Message types and commands */
 enum ipset_cmd {
 	IPSET_CMD_NONE,
* Unmerged path net/netfilter/ipset/ip_set_bitmap_gen.h
diff --git a/net/netfilter/ipset/ip_set_bitmap_ip.c b/net/netfilter/ipset/ip_set_bitmap_ip.c
index faaca51bf3fa..5a162b62e8e6 100644
--- a/net/netfilter/ipset/ip_set_bitmap_ip.c
+++ b/net/netfilter/ipset/ip_set_bitmap_ip.c
@@ -60,7 +60,7 @@ struct bitmap_ip_adt_elem {
 static inline u32
 ip_to_id(const struct bitmap_ip *m, u32 ip)
 {
-	return ((ip & ip_set_hostmask(m->netmask)) - m->first_ip)/m->hosts;
+	return ((ip & ip_set_hostmask(m->netmask)) - m->first_ip) / m->hosts;
 }
 
 /* Common functions */
@@ -174,8 +174,9 @@ bitmap_ip_uadt(struct ip_set *set, struct nlattr *tb[],
 		if (!cidr || cidr > HOST_MASK)
 			return -IPSET_ERR_INVALID_CIDR;
 		ip_set_mask_from_to(ip, ip_to, cidr);
-	} else
+	} else {
 		ip_to = ip;
+	}
 
 	if (ip_to > map->last_ip)
 		return -IPSET_ERR_BITMAP_RANGE;
@@ -186,8 +187,8 @@ bitmap_ip_uadt(struct ip_set *set, struct nlattr *tb[],
 
 		if (ret && !ip_set_eexist(ret, flags))
 			return ret;
-		else
-			ret = 0;
+
+		ret = 0;
 	}
 	return ret;
 }
@@ -296,8 +297,9 @@ bitmap_ip_create(struct net *net, struct ip_set *set, struct nlattr *tb[],
 		if (cidr >= HOST_MASK)
 			return -IPSET_ERR_INVALID_CIDR;
 		ip_set_mask_from_to(first_ip, last_ip, cidr);
-	} else
+	} else {
 		return -IPSET_ERR_PROTOCOL;
+	}
 
 	if (tb[IPSET_ATTR_NETMASK]) {
 		netmask = nla_get_u8(tb[IPSET_ATTR_NETMASK]);
* Unmerged path net/netfilter/ipset/ip_set_bitmap_ipmac.c
diff --git a/net/netfilter/ipset/ip_set_bitmap_port.c b/net/netfilter/ipset/ip_set_bitmap_port.c
index 3fcb6e11fac3..ea0d61624c76 100644
--- a/net/netfilter/ipset/ip_set_bitmap_port.c
+++ b/net/netfilter/ipset/ip_set_bitmap_port.c
@@ -165,8 +165,9 @@ bitmap_port_uadt(struct ip_set *set, struct nlattr *tb[],
 			if (port < map->first_port)
 				return -IPSET_ERR_BITMAP_RANGE;
 		}
-	} else
+	} else {
 		port_to = port;
+	}
 
 	if (port_to > map->last_port)
 		return -IPSET_ERR_BITMAP_RANGE;
@@ -177,8 +178,8 @@ bitmap_port_uadt(struct ip_set *set, struct nlattr *tb[],
 
 		if (ret && !ip_set_eexist(ret, flags))
 			return ret;
-		else
-			ret = 0;
+
+		ret = 0;
 	}
 	return ret;
 }
* Unmerged path net/netfilter/ipset/ip_set_core.c
diff --git a/net/netfilter/ipset/ip_set_getport.c b/net/netfilter/ipset/ip_set_getport.c
index 1981f021cc60..42c3e3ba1b94 100644
--- a/net/netfilter/ipset/ip_set_getport.c
+++ b/net/netfilter/ipset/ip_set_getport.c
@@ -30,7 +30,7 @@ get_port(const struct sk_buff *skb, int protocol, unsigned int protooff,
 		const struct tcphdr *th;
 
 		th = skb_header_pointer(skb, protooff, sizeof(_tcph), &_tcph);
-		if (th == NULL)
+		if (!th)
 			/* No choice either */
 			return false;
 
@@ -42,7 +42,7 @@ get_port(const struct sk_buff *skb, int protocol, unsigned int protooff,
 		const sctp_sctphdr_t *sh;
 
 		sh = skb_header_pointer(skb, protooff, sizeof(_sh), &_sh);
-		if (sh == NULL)
+		if (!sh)
 			/* No choice either */
 			return false;
 
@@ -55,7 +55,7 @@ get_port(const struct sk_buff *skb, int protocol, unsigned int protooff,
 		const struct udphdr *uh;
 
 		uh = skb_header_pointer(skb, protooff, sizeof(_udph), &_udph);
-		if (uh == NULL)
+		if (!uh)
 			/* No choice either */
 			return false;
 
@@ -67,7 +67,7 @@ get_port(const struct sk_buff *skb, int protocol, unsigned int protooff,
 		const struct icmphdr *ic;
 
 		ic = skb_header_pointer(skb, protooff, sizeof(_ich), &_ich);
-		if (ic == NULL)
+		if (!ic)
 			return false;
 
 		*port = (__force __be16)htons((ic->type << 8) | ic->code);
@@ -78,7 +78,7 @@ get_port(const struct sk_buff *skb, int protocol, unsigned int protooff,
 		const struct icmp6hdr *ic;
 
 		ic = skb_header_pointer(skb, protooff, sizeof(_ich), &_ich);
-		if (ic == NULL)
+		if (!ic)
 			return false;
 
 		*port = (__force __be16)
@@ -116,7 +116,8 @@ ip_set_get_ip4_port(const struct sk_buff *skb, bool src,
 			return false;
 		default:
 			/* Other protocols doesn't have ports,
-			   so we can match fragments */
+			 * so we can match fragments.
+			 */
 			*proto = protocol;
 			return true;
 		}
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
diff --git a/net/netfilter/ipset/ip_set_hash_ip.c b/net/netfilter/ipset/ip_set_hash_ip.c
index 6e3d06eb397b..152239b251d7 100644
--- a/net/netfilter/ipset/ip_set_hash_ip.c
+++ b/net/netfilter/ipset/ip_set_hash_ip.c
@@ -172,8 +172,8 @@ hash_ip4_uadt(struct ip_set *set, struct nlattr *tb[],
 
 		if (ret && !ip_set_eexist(ret, flags))
 			return ret;
-		else
-			ret = 0;
+
+		ret = 0;
 	}
 	return ret;
 }
diff --git a/net/netfilter/ipset/ip_set_hash_ipmark.c b/net/netfilter/ipset/ip_set_hash_ipmark.c
index 50389697a53a..85f0e6fa9b36 100644
--- a/net/netfilter/ipset/ip_set_hash_ipmark.c
+++ b/net/netfilter/ipset/ip_set_hash_ipmark.c
@@ -151,8 +151,8 @@ hash_ipmark4_uadt(struct ip_set *set, struct nlattr *tb[],
 
 		if (ret && !ip_set_eexist(ret, flags))
 			return ret;
-		else
-			ret = 0;
+
+		ret = 0;
 	}
 	return ret;
 }
@@ -204,7 +204,6 @@ hash_ipmark6_data_next(struct hash_ipmark4_elem *next,
 #define	IP_SET_EMIT_CREATE
 #include "ip_set_hash_gen.h"
 
-
 static int
 hash_ipmark6_kadt(struct ip_set *set, const struct sk_buff *skb,
 		  const struct xt_action_param *par,
@@ -256,10 +255,8 @@ hash_ipmark6_uadt(struct ip_set *set, struct nlattr *tb[],
 	ret = adtfn(set, &e, &ext, &ext, flags);
 	if (ret && !ip_set_eexist(ret, flags))
 		return ret;
-	else
-		ret = 0;
 
-	return ret;
+	return 0;
 }
 
 static struct ip_set_type hash_ipmark_type __read_mostly = {
diff --git a/net/netfilter/ipset/ip_set_hash_ipport.c b/net/netfilter/ipset/ip_set_hash_ipport.c
index 5e57c86de14d..747d5b80e733 100644
--- a/net/netfilter/ipset/ip_set_hash_ipport.c
+++ b/net/netfilter/ipset/ip_set_hash_ipport.c
@@ -167,8 +167,9 @@ hash_ipport4_uadt(struct ip_set *set, struct nlattr *tb[],
 
 		if (e.proto == 0)
 			return -IPSET_ERR_INVALID_PROTO;
-	} else
+	} else {
 		return -IPSET_ERR_MISSING_PROTO;
+	}
 
 	if (!(with_ports || e.proto == IPPROTO_ICMP))
 		e.port = 0;
@@ -214,8 +215,8 @@ hash_ipport4_uadt(struct ip_set *set, struct nlattr *tb[],
 
 			if (ret && !ip_set_eexist(ret, flags))
 				return ret;
-			else
-				ret = 0;
+
+			ret = 0;
 		}
 	}
 	return ret;
@@ -357,8 +358,9 @@ hash_ipport6_uadt(struct ip_set *set, struct nlattr *tb[],
 
 		if (e.proto == 0)
 			return -IPSET_ERR_INVALID_PROTO;
-	} else
+	} else {
 		return -IPSET_ERR_MISSING_PROTO;
+	}
 
 	if (!(with_ports || e.proto == IPPROTO_ICMPV6))
 		e.port = 0;
@@ -381,8 +383,8 @@ hash_ipport6_uadt(struct ip_set *set, struct nlattr *tb[],
 
 		if (ret && !ip_set_eexist(ret, flags))
 			return ret;
-		else
-			ret = 0;
+
+		ret = 0;
 	}
 	return ret;
 }
diff --git a/net/netfilter/ipset/ip_set_hash_ipportip.c b/net/netfilter/ipset/ip_set_hash_ipportip.c
index 24b9417eb2c5..837233ea47ac 100644
--- a/net/netfilter/ipset/ip_set_hash_ipportip.c
+++ b/net/netfilter/ipset/ip_set_hash_ipportip.c
@@ -88,7 +88,7 @@ hash_ipportip4_data_equal(const struct hash_ipportip4_elem *ip1,
 
 static bool
 hash_ipportip4_data_list(struct sk_buff *skb,
-		       const struct hash_ipportip4_elem *data)
+			 const struct hash_ipportip4_elem *data)
 {
 	if (nla_put_ipaddr4(skb, IPSET_ATTR_IP, data->ip) ||
 	    nla_put_ipaddr4(skb, IPSET_ATTR_IP2, data->ip2) ||
@@ -177,8 +177,9 @@ hash_ipportip4_uadt(struct ip_set *set, struct nlattr *tb[],
 
 		if (e.proto == 0)
 			return -IPSET_ERR_INVALID_PROTO;
-	} else
+	} else {
 		return -IPSET_ERR_MISSING_PROTO;
+	}
 
 	if (!(with_ports || e.proto == IPPROTO_ICMP))
 		e.port = 0;
@@ -224,8 +225,8 @@ hash_ipportip4_uadt(struct ip_set *set, struct nlattr *tb[],
 
 			if (ret && !ip_set_eexist(ret, flags))
 				return ret;
-			else
-				ret = 0;
+
+			ret = 0;
 		}
 	}
 	return ret;
@@ -378,8 +379,9 @@ hash_ipportip6_uadt(struct ip_set *set, struct nlattr *tb[],
 
 		if (e.proto == 0)
 			return -IPSET_ERR_INVALID_PROTO;
-	} else
+	} else {
 		return -IPSET_ERR_MISSING_PROTO;
+	}
 
 	if (!(with_ports || e.proto == IPPROTO_ICMPV6))
 		e.port = 0;
@@ -402,8 +404,8 @@ hash_ipportip6_uadt(struct ip_set *set, struct nlattr *tb[],
 
 		if (ret && !ip_set_eexist(ret, flags))
 			return ret;
-		else
-			ret = 0;
+
+		ret = 0;
 	}
 	return ret;
 }
diff --git a/net/netfilter/ipset/ip_set_hash_ipportnet.c b/net/netfilter/ipset/ip_set_hash_ipportnet.c
index bb1a8e8f02c9..3baa05fc73e8 100644
--- a/net/netfilter/ipset/ip_set_hash_ipportnet.c
+++ b/net/netfilter/ipset/ip_set_hash_ipportnet.c
@@ -241,14 +241,16 @@ hash_ipportnet4_uadt(struct ip_set *set, struct nlattr *tb[],
 
 		if (e.proto == 0)
 			return -IPSET_ERR_INVALID_PROTO;
-	} else
+	} else {
 		return -IPSET_ERR_MISSING_PROTO;
+	}
 
 	if (!(with_ports || e.proto == IPPROTO_ICMP))
 		e.port = 0;
 
 	if (tb[IPSET_ATTR_CADT_FLAGS]) {
 		u32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
+
 		if (cadt_flags & IPSET_FLAG_NOMATCH)
 			flags |= (IPSET_FLAG_NOMATCH << 16);
 	}
@@ -295,8 +297,9 @@ hash_ipportnet4_uadt(struct ip_set *set, struct nlattr *tb[],
 			swap(ip2_from, ip2_to);
 		if (ip2_from + UINT_MAX == ip2_to)
 			return -IPSET_ERR_HASH_RANGE;
-	} else
+	} else {
 		ip_set_mask_from_to(ip2_from, ip2_to, e.cidr + 1);
+	}
 
 	if (retried)
 		ip = ntohl(h->next.ip);
@@ -319,8 +322,8 @@ hash_ipportnet4_uadt(struct ip_set *set, struct nlattr *tb[],
 
 				if (ret && !ip_set_eexist(ret, flags))
 					return ret;
-				else
-					ret = 0;
+
+				ret = 0;
 				ip2 = ip2_last + 1;
 			}
 		}
@@ -530,14 +533,16 @@ hash_ipportnet6_uadt(struct ip_set *set, struct nlattr *tb[],
 
 		if (e.proto == 0)
 			return -IPSET_ERR_INVALID_PROTO;
-	} else
+	} else {
 		return -IPSET_ERR_MISSING_PROTO;
+	}
 
 	if (!(with_ports || e.proto == IPPROTO_ICMPV6))
 		e.port = 0;
 
 	if (tb[IPSET_ATTR_CADT_FLAGS]) {
 		u32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
+
 		if (cadt_flags & IPSET_FLAG_NOMATCH)
 			flags |= (IPSET_FLAG_NOMATCH << 16);
 	}
@@ -561,8 +566,8 @@ hash_ipportnet6_uadt(struct ip_set *set, struct nlattr *tb[],
 
 		if (ret && !ip_set_eexist(ret, flags))
 			return ret;
-		else
-			ret = 0;
+
+		ret = 0;
 	}
 	return ret;
 }
* Unmerged path net/netfilter/ipset/ip_set_hash_mac.c
diff --git a/net/netfilter/ipset/ip_set_hash_net.c b/net/netfilter/ipset/ip_set_hash_net.c
index 0a64dad156d9..c7aa5bab9863 100644
--- a/net/netfilter/ipset/ip_set_hash_net.c
+++ b/net/netfilter/ipset/ip_set_hash_net.c
@@ -192,6 +192,7 @@ hash_net4_uadt(struct ip_set *set, struct nlattr *tb[],
 
 	if (tb[IPSET_ATTR_CADT_FLAGS]) {
 		u32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
+
 		if (cadt_flags & IPSET_FLAG_NOMATCH)
 			flags |= (IPSET_FLAG_NOMATCH << 16);
 	}
@@ -199,7 +200,7 @@ hash_net4_uadt(struct ip_set *set, struct nlattr *tb[],
 	if (adt == IPSET_TEST || !tb[IPSET_ATTR_IP_TO]) {
 		e.ip = htonl(ip & ip_set_hostmask(e.cidr));
 		ret = adtfn(set, &e, &ext, &ext, flags);
-		return ip_set_enomatch(ret, flags, adt, set) ? -ret:
+		return ip_set_enomatch(ret, flags, adt, set) ? -ret :
 		       ip_set_eexist(ret, flags) ? 0 : ret;
 	}
 
@@ -221,8 +222,8 @@ hash_net4_uadt(struct ip_set *set, struct nlattr *tb[],
 		ret = adtfn(set, &e, &ext, &ext, flags);
 		if (ret && !ip_set_eexist(ret, flags))
 			return ret;
-		else
-			ret = 0;
+
+		ret = 0;
 		ip = last + 1;
 	}
 	return ret;
@@ -390,6 +391,7 @@ hash_net6_uadt(struct ip_set *set, struct nlattr *tb[],
 
 	if (tb[IPSET_ATTR_CADT_FLAGS]) {
 		u32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
+
 		if (cadt_flags & IPSET_FLAG_NOMATCH)
 			flags |= (IPSET_FLAG_NOMATCH << 16);
 	}
* Unmerged path net/netfilter/ipset/ip_set_hash_netiface.c
* Unmerged path net/netfilter/ipset/ip_set_hash_netnet.c
diff --git a/net/netfilter/ipset/ip_set_hash_netport.c b/net/netfilter/ipset/ip_set_hash_netport.c
index d98a685cd916..c2c741316fac 100644
--- a/net/netfilter/ipset/ip_set_hash_netport.c
+++ b/net/netfilter/ipset/ip_set_hash_netport.c
@@ -227,8 +227,9 @@ hash_netport4_uadt(struct ip_set *set, struct nlattr *tb[],
 
 		if (e.proto == 0)
 			return -IPSET_ERR_INVALID_PROTO;
-	} else
+	} else {
 		return -IPSET_ERR_MISSING_PROTO;
+	}
 
 	if (!(with_ports || e.proto == IPPROTO_ICMP))
 		e.port = 0;
@@ -237,6 +238,7 @@ hash_netport4_uadt(struct ip_set *set, struct nlattr *tb[],
 
 	if (tb[IPSET_ATTR_CADT_FLAGS]) {
 		u32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
+
 		if (cadt_flags & IPSET_FLAG_NOMATCH)
 			flags |= (IPSET_FLAG_NOMATCH << 16);
 	}
@@ -262,8 +264,9 @@ hash_netport4_uadt(struct ip_set *set, struct nlattr *tb[],
 			swap(ip, ip_to);
 		if (ip + UINT_MAX == ip_to)
 			return -IPSET_ERR_HASH_RANGE;
-	} else
+	} else {
 		ip_set_mask_from_to(ip, ip_to, e.cidr + 1);
+	}
 
 	if (retried)
 		ip = ntohl(h->next.ip);
@@ -279,8 +282,8 @@ hash_netport4_uadt(struct ip_set *set, struct nlattr *tb[],
 
 			if (ret && !ip_set_eexist(ret, flags))
 				return ret;
-			else
-				ret = 0;
+
+			ret = 0;
 		}
 		ip = last + 1;
 	}
@@ -475,14 +478,16 @@ hash_netport6_uadt(struct ip_set *set, struct nlattr *tb[],
 
 		if (e.proto == 0)
 			return -IPSET_ERR_INVALID_PROTO;
-	} else
+	} else {
 		return -IPSET_ERR_MISSING_PROTO;
+	}
 
 	if (!(with_ports || e.proto == IPPROTO_ICMPV6))
 		e.port = 0;
 
 	if (tb[IPSET_ATTR_CADT_FLAGS]) {
 		u32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
+
 		if (cadt_flags & IPSET_FLAG_NOMATCH)
 			flags |= (IPSET_FLAG_NOMATCH << 16);
 	}
@@ -506,8 +511,8 @@ hash_netport6_uadt(struct ip_set *set, struct nlattr *tb[],
 
 		if (ret && !ip_set_eexist(ret, flags))
 			return ret;
-		else
-			ret = 0;
+
+		ret = 0;
 	}
 	return ret;
 }
* Unmerged path net/netfilter/ipset/ip_set_hash_netportnet.c
* Unmerged path net/netfilter/ipset/ip_set_list_set.c
diff --git a/net/netfilter/ipset/pfxlen.c b/net/netfilter/ipset/pfxlen.c
index 04d15fdc99ee..1c8a42c1056c 100644
--- a/net/netfilter/ipset/pfxlen.c
+++ b/net/netfilter/ipset/pfxlen.c
@@ -1,9 +1,7 @@
 #include <linux/export.h>
 #include <linux/netfilter/ipset/pfxlen.h>
 
-/*
- * Prefixlen maps for fast conversions, by Jan Engelhardt.
- */
+/* Prefixlen maps for fast conversions, by Jan Engelhardt. */
 
 #define E(a, b, c, d) \
 	{.ip6 = { \
@@ -11,8 +9,7 @@
 		htonl(c), htonl(d), \
 	} }
 
-/*
- * This table works for both IPv4 and IPv6;
+/* This table works for both IPv4 and IPv6;
  * just use prefixlen_netmask_map[prefixlength].ip.
  */
 const union nf_inet_addr ip_set_netmask_map[] = {
@@ -149,13 +146,12 @@ const union nf_inet_addr ip_set_netmask_map[] = {
 EXPORT_SYMBOL_GPL(ip_set_netmask_map);
 
 #undef  E
-#define E(a, b, c, d)						\
-	{.ip6 = { (__force __be32) a, (__force __be32) b,	\
-		  (__force __be32) c, (__force __be32) d,	\
+#define E(a, b, c, d)					\
+	{.ip6 = { (__force __be32)a, (__force __be32)b,	\
+		  (__force __be32)c, (__force __be32)d,	\
 	} }
 
-/*
- * This table works for both IPv4 and IPv6;
+/* This table works for both IPv4 and IPv6;
  * just use prefixlen_hostmask_map[prefixlength].ip.
  */
 const union nf_inet_addr ip_set_hostmask_map[] = {
* Unmerged path net/netfilter/xt_set.c
