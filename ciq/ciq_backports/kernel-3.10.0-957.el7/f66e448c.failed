selinux: bpf: Add addtional check for bpf object file receive

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Chenbo Feng <fengc@google.com>
commit f66e448cfda021b0bcd884f26709796fe19c7cc1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f66e448c.failed

Introduce a bpf object related check when sending and receiving files
through unix domain socket as well as binder. It checks if the receiving
process have privilege to read/write the bpf map or use the bpf program.
This check is necessary because the bpf maps and programs are using a
anonymous inode as their shared inode so the normal way of checking the
files and sockets when passing between processes cannot work properly on
eBPF object. This check only works when the BPF_SYSCALL is configured.

	Signed-off-by: Chenbo Feng <fengc@google.com>
	Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
	Reviewed-by: James Morris <james.l.morris@oracle.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f66e448cfda021b0bcd884f26709796fe19c7cc1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	kernel/bpf/syscall.c
#	security/selinux/hooks.c
diff --cc include/linux/bpf.h
index d4c1f9049ad3,1e334b248ff6..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -89,28 -168,349 +89,339 @@@ struct bpf_func_proto 
  struct bpf_verifier_ops {
  	/* return eBPF function prototype for verification */
  	const struct bpf_func_proto *(*get_func_proto)(enum bpf_func_id func_id);
 +};
  
 -	/* return true if 'size' wide access at offset 'off' within bpf_context
 -	 * with 'type' (read or write) is allowed
 -	 */
 -	bool (*is_valid_access)(int off, int size, enum bpf_access_type type,
 -				struct bpf_insn_access_aux *info);
 -	int (*gen_prologue)(struct bpf_insn *insn, bool direct_write,
 -			    const struct bpf_prog *prog);
 -	u32 (*convert_ctx_access)(enum bpf_access_type type,
 -				  const struct bpf_insn *src,
 -				  struct bpf_insn *dst,
 -				  struct bpf_prog *prog, u32 *target_size);
 +struct bpf_prog_type_list {
 +	struct list_head list_node;
 +	struct bpf_verifier_ops *ops;
 +	enum bpf_prog_type type;
  };
  
 +void bpf_register_prog_type(struct bpf_prog_type_list *tl);
 +
 +struct bpf_prog;
 +
  struct bpf_prog_aux {
  	atomic_t refcnt;
 -	u32 used_map_cnt;
 -	u32 max_ctx_offset;
 -	u32 stack_depth;
 +	bool is_gpl_compatible;
 +	enum bpf_prog_type prog_type;
 +	struct bpf_verifier_ops *ops;
  	u32 id;
 -	struct latch_tree_node ksym_tnode;
 -	struct list_head ksym_lnode;
 -	const struct bpf_prog_ops *ops;
  	struct bpf_map **used_maps;
 +	u32 used_map_cnt;
  	struct bpf_prog *prog;
 -	struct user_struct *user;
 -	u64 load_time; /* ns since boottime */
 -	char name[BPF_OBJ_NAME_LEN];
 -#ifdef CONFIG_SECURITY
 -	void *security;
 -#endif
 -	union {
 -		struct work_struct work;
 -		struct rcu_head	rcu;
 -	};
 +	struct work_struct work;
  };
  
++<<<<<<< HEAD
++=======
+ struct bpf_array {
+ 	struct bpf_map map;
+ 	u32 elem_size;
+ 	/* 'ownership' of prog_array is claimed by the first program that
+ 	 * is going to use this map or by the first program which FD is stored
+ 	 * in the map to make sure that all callers and callees have the same
+ 	 * prog_type and JITed flag
+ 	 */
+ 	enum bpf_prog_type owner_prog_type;
+ 	bool owner_jited;
+ 	union {
+ 		char value[0] __aligned(8);
+ 		void *ptrs[0] __aligned(8);
+ 		void __percpu *pptrs[0] __aligned(8);
+ 	};
+ };
+ 
+ #define MAX_TAIL_CALL_CNT 32
+ 
+ struct bpf_event_entry {
+ 	struct perf_event *event;
+ 	struct file *perf_file;
+ 	struct file *map_file;
+ 	struct rcu_head rcu;
+ };
+ 
+ u64 bpf_tail_call(u64 ctx, u64 r2, u64 index, u64 r4, u64 r5);
+ u64 bpf_get_stackid(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5);
+ 
+ bool bpf_prog_array_compatible(struct bpf_array *array, const struct bpf_prog *fp);
+ int bpf_prog_calc_tag(struct bpf_prog *fp);
+ 
+ const struct bpf_func_proto *bpf_get_trace_printk_proto(void);
+ 
+ typedef unsigned long (*bpf_ctx_copy_t)(void *dst, const void *src,
+ 					unsigned long off, unsigned long len);
+ 
+ u64 bpf_event_output(struct bpf_map *map, u64 flags, void *meta, u64 meta_size,
+ 		     void *ctx, u64 ctx_size, bpf_ctx_copy_t ctx_copy);
+ 
+ int bpf_prog_test_run_xdp(struct bpf_prog *prog, const union bpf_attr *kattr,
+ 			  union bpf_attr __user *uattr);
+ int bpf_prog_test_run_skb(struct bpf_prog *prog, const union bpf_attr *kattr,
+ 			  union bpf_attr __user *uattr);
+ 
+ /* an array of programs to be executed under rcu_lock.
+  *
+  * Typical usage:
+  * ret = BPF_PROG_RUN_ARRAY(&bpf_prog_array, ctx, BPF_PROG_RUN);
+  *
+  * the structure returned by bpf_prog_array_alloc() should be populated
+  * with program pointers and the last pointer must be NULL.
+  * The user has to keep refcnt on the program and make sure the program
+  * is removed from the array before bpf_prog_put().
+  * The 'struct bpf_prog_array *' should only be replaced with xchg()
+  * since other cpus are walking the array of pointers in parallel.
+  */
+ struct bpf_prog_array {
+ 	struct rcu_head rcu;
+ 	struct bpf_prog *progs[0];
+ };
+ 
+ struct bpf_prog_array __rcu *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags);
+ void bpf_prog_array_free(struct bpf_prog_array __rcu *progs);
+ int bpf_prog_array_length(struct bpf_prog_array __rcu *progs);
+ int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *progs,
+ 				__u32 __user *prog_ids, u32 cnt);
+ 
+ #define BPF_PROG_RUN_ARRAY(array, ctx, func)		\
+ 	({						\
+ 		struct bpf_prog **_prog;		\
+ 		u32 _ret = 1;				\
+ 		rcu_read_lock();			\
+ 		_prog = rcu_dereference(array)->progs;	\
+ 		for (; *_prog; _prog++)			\
+ 			_ret &= func(*_prog, ctx);	\
+ 		rcu_read_unlock();			\
+ 		_ret;					\
+ 	 })
+ 
+ #ifdef CONFIG_BPF_SYSCALL
+ DECLARE_PER_CPU(int, bpf_prog_active);
+ 
+ extern const struct file_operations bpf_map_fops;
+ extern const struct file_operations bpf_prog_fops;
+ 
+ #define BPF_PROG_TYPE(_id, _name) \
+ 	extern const struct bpf_prog_ops _name ## _prog_ops; \
+ 	extern const struct bpf_verifier_ops _name ## _verifier_ops;
+ #define BPF_MAP_TYPE(_id, _ops) \
+ 	extern const struct bpf_map_ops _ops;
+ #include <linux/bpf_types.h>
+ #undef BPF_PROG_TYPE
+ #undef BPF_MAP_TYPE
+ 
+ extern const struct bpf_verifier_ops tc_cls_act_analyzer_ops;
+ extern const struct bpf_verifier_ops xdp_analyzer_ops;
+ 
+ struct bpf_prog *bpf_prog_get(u32 ufd);
+ struct bpf_prog *bpf_prog_get_type(u32 ufd, enum bpf_prog_type type);
+ struct bpf_prog * __must_check bpf_prog_add(struct bpf_prog *prog, int i);
+ void bpf_prog_sub(struct bpf_prog *prog, int i);
+ struct bpf_prog * __must_check bpf_prog_inc(struct bpf_prog *prog);
+ struct bpf_prog * __must_check bpf_prog_inc_not_zero(struct bpf_prog *prog);
+ void bpf_prog_put(struct bpf_prog *prog);
+ int __bpf_prog_charge(struct user_struct *user, u32 pages);
+ void __bpf_prog_uncharge(struct user_struct *user, u32 pages);
+ 
+ struct bpf_map *bpf_map_get_with_uref(u32 ufd);
+ struct bpf_map *__bpf_map_get(struct fd f);
+ struct bpf_map * __must_check bpf_map_inc(struct bpf_map *map, bool uref);
+ void bpf_map_put_with_uref(struct bpf_map *map);
+ void bpf_map_put(struct bpf_map *map);
+ int bpf_map_precharge_memlock(u32 pages);
+ void *bpf_map_area_alloc(size_t size, int numa_node);
+ void bpf_map_area_free(void *base);
+ 
+ extern int sysctl_unprivileged_bpf_disabled;
+ 
+ int bpf_map_new_fd(struct bpf_map *map, int flags);
+ int bpf_prog_new_fd(struct bpf_prog *prog);
+ 
+ int bpf_obj_pin_user(u32 ufd, const char __user *pathname);
+ int bpf_obj_get_user(const char __user *pathname, int flags);
+ 
+ int bpf_percpu_hash_copy(struct bpf_map *map, void *key, void *value);
+ int bpf_percpu_array_copy(struct bpf_map *map, void *key, void *value);
+ int bpf_percpu_hash_update(struct bpf_map *map, void *key, void *value,
+ 			   u64 flags);
+ int bpf_percpu_array_update(struct bpf_map *map, void *key, void *value,
+ 			    u64 flags);
+ 
+ int bpf_stackmap_copy(struct bpf_map *map, void *key, void *value);
+ 
+ int bpf_fd_array_map_update_elem(struct bpf_map *map, struct file *map_file,
+ 				 void *key, void *value, u64 map_flags);
+ int bpf_fd_array_map_lookup_elem(struct bpf_map *map, void *key, u32 *value);
+ void bpf_fd_array_map_clear(struct bpf_map *map);
+ int bpf_fd_htab_map_update_elem(struct bpf_map *map, struct file *map_file,
+ 				void *key, void *value, u64 map_flags);
+ int bpf_fd_htab_map_lookup_elem(struct bpf_map *map, void *key, u32 *value);
+ 
+ int bpf_get_file_flag(int flags);
+ 
+ /* memcpy that is used with 8-byte aligned pointers, power-of-8 size and
+  * forced to use 'long' read/writes to try to atomically copy long counters.
+  * Best-effort only.  No barriers here, since it _will_ race with concurrent
+  * updates from BPF programs. Called from bpf syscall and mostly used with
+  * size 8 or 16 bytes, so ask compiler to inline it.
+  */
+ static inline void bpf_long_memcpy(void *dst, const void *src, u32 size)
+ {
+ 	const long *lsrc = src;
+ 	long *ldst = dst;
+ 
+ 	size /= sizeof(long);
+ 	while (size--)
+ 		*ldst++ = *lsrc++;
+ }
+ 
+ /* verify correctness of eBPF program */
+ int bpf_check(struct bpf_prog **fp, union bpf_attr *attr);
+ 
+ /* Map specifics */
+ struct net_device  *__dev_map_lookup_elem(struct bpf_map *map, u32 key);
+ void __dev_map_insert_ctx(struct bpf_map *map, u32 index);
+ void __dev_map_flush(struct bpf_map *map);
+ 
+ struct bpf_cpu_map_entry *__cpu_map_lookup_elem(struct bpf_map *map, u32 key);
+ void __cpu_map_insert_ctx(struct bpf_map *map, u32 index);
+ void __cpu_map_flush(struct bpf_map *map);
+ struct xdp_buff;
+ int cpu_map_enqueue(struct bpf_cpu_map_entry *rcpu, struct xdp_buff *xdp,
+ 		    struct net_device *dev_rx);
+ 
+ /* Return map's numa specified by userspace */
+ static inline int bpf_map_attr_numa_node(const union bpf_attr *attr)
+ {
+ 	return (attr->map_flags & BPF_F_NUMA_NODE) ?
+ 		attr->numa_node : NUMA_NO_NODE;
+ }
+ 
+ #else /* !CONFIG_BPF_SYSCALL */
+ static inline struct bpf_prog *bpf_prog_get(u32 ufd)
+ {
+ 	return ERR_PTR(-EOPNOTSUPP);
+ }
+ 
+ static inline struct bpf_prog *bpf_prog_get_type(u32 ufd,
+ 						 enum bpf_prog_type type)
+ {
+ 	return ERR_PTR(-EOPNOTSUPP);
+ }
+ static inline struct bpf_prog * __must_check bpf_prog_add(struct bpf_prog *prog,
+ 							  int i)
+ {
+ 	return ERR_PTR(-EOPNOTSUPP);
+ }
+ 
+ static inline void bpf_prog_sub(struct bpf_prog *prog, int i)
+ {
+ }
+ 
+ static inline void bpf_prog_put(struct bpf_prog *prog)
+ {
+ }
+ 
+ static inline struct bpf_prog * __must_check bpf_prog_inc(struct bpf_prog *prog)
+ {
+ 	return ERR_PTR(-EOPNOTSUPP);
+ }
+ 
+ static inline struct bpf_prog *__must_check
+ bpf_prog_inc_not_zero(struct bpf_prog *prog)
+ {
+ 	return ERR_PTR(-EOPNOTSUPP);
+ }
+ 
+ static inline int __bpf_prog_charge(struct user_struct *user, u32 pages)
+ {
+ 	return 0;
+ }
+ 
+ static inline void __bpf_prog_uncharge(struct user_struct *user, u32 pages)
+ {
+ }
+ 
+ static inline int bpf_obj_get_user(const char __user *pathname, int flags)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline struct net_device  *__dev_map_lookup_elem(struct bpf_map *map,
+ 						       u32 key)
+ {
+ 	return NULL;
+ }
+ 
+ static inline void __dev_map_insert_ctx(struct bpf_map *map, u32 index)
+ {
+ }
+ 
+ static inline void __dev_map_flush(struct bpf_map *map)
+ {
+ }
+ 
+ static inline
+ struct bpf_cpu_map_entry *__cpu_map_lookup_elem(struct bpf_map *map, u32 key)
+ {
+ 	return NULL;
+ }
+ 
+ static inline void __cpu_map_insert_ctx(struct bpf_map *map, u32 index)
+ {
+ }
+ 
+ static inline void __cpu_map_flush(struct bpf_map *map)
+ {
+ }
+ 
+ struct xdp_buff;
+ static inline int cpu_map_enqueue(struct bpf_cpu_map_entry *rcpu,
+ 				  struct xdp_buff *xdp,
+ 				  struct net_device *dev_rx)
+ {
+ 	return 0;
+ }
+ #endif /* CONFIG_BPF_SYSCALL */
+ 
+ #if defined(CONFIG_STREAM_PARSER) && defined(CONFIG_BPF_SYSCALL)
+ struct sock  *__sock_map_lookup_elem(struct bpf_map *map, u32 key);
+ int sock_map_prog(struct bpf_map *map, struct bpf_prog *prog, u32 type);
+ #else
+ static inline struct sock  *__sock_map_lookup_elem(struct bpf_map *map, u32 key)
+ {
+ 	return NULL;
+ }
+ 
+ static inline int sock_map_prog(struct bpf_map *map,
+ 				struct bpf_prog *prog,
+ 				u32 type)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ #endif
+ 
+ /* verifier prototypes for helper functions called from eBPF programs */
+ extern const struct bpf_func_proto bpf_map_lookup_elem_proto;
+ extern const struct bpf_func_proto bpf_map_update_elem_proto;
+ extern const struct bpf_func_proto bpf_map_delete_elem_proto;
+ 
+ extern const struct bpf_func_proto bpf_get_prandom_u32_proto;
+ extern const struct bpf_func_proto bpf_get_smp_processor_id_proto;
+ extern const struct bpf_func_proto bpf_get_numa_node_id_proto;
+ extern const struct bpf_func_proto bpf_tail_call_proto;
+ extern const struct bpf_func_proto bpf_ktime_get_ns_proto;
+ extern const struct bpf_func_proto bpf_get_current_pid_tgid_proto;
+ extern const struct bpf_func_proto bpf_get_current_uid_gid_proto;
+ extern const struct bpf_func_proto bpf_get_current_comm_proto;
+ extern const struct bpf_func_proto bpf_skb_vlan_push_proto;
+ extern const struct bpf_func_proto bpf_skb_vlan_pop_proto;
+ extern const struct bpf_func_proto bpf_get_stackid_proto;
+ extern const struct bpf_func_proto bpf_sock_map_update_proto;
+ 
+ /* Shared helpers among cBPF and eBPF. */
+ void bpf_user_rnd_init_once(void);
+ u64 bpf_user_rnd_u32(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5);
+ 
++>>>>>>> f66e448cfda0 (selinux: bpf: Add addtional check for bpf object file receive)
  #endif /* _LINUX_BPF_H */
diff --cc security/selinux/hooks.c
index fe0d2b1b58b3,2e3a627fc0b1..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -1746,9 -1812,13 +1746,13 @@@ static inline int file_path_has_perm(co
  
  	ad.type = LSM_AUDIT_DATA_FILE;
  	ad.u.file = file;
 -	return inode_has_perm(cred, file_inode(file), av, &ad);
 +	return inode_has_perm(cred, file_inode(file), av, &ad, 0);
  }
  
+ #ifdef CONFIG_BPF_SYSCALL
+ static int bpf_fd_pass(struct file *file, u32 sid);
+ #endif
+ 
  /* Check whether a task can use an open file descriptor to
     access an inode in a given way.  Check access to the
     descriptor itself, and then use dentry_has_perm to
@@@ -2046,6 -2114,81 +2056,84 @@@ static inline u32 open_file_to_av(struc
  
  /* Hook functions begin here. */
  
++<<<<<<< HEAD
++=======
+ static int selinux_binder_set_context_mgr(struct task_struct *mgr)
+ {
+ 	u32 mysid = current_sid();
+ 	u32 mgrsid = task_sid(mgr);
+ 
+ 	return avc_has_perm(mysid, mgrsid, SECCLASS_BINDER,
+ 			    BINDER__SET_CONTEXT_MGR, NULL);
+ }
+ 
+ static int selinux_binder_transaction(struct task_struct *from,
+ 				      struct task_struct *to)
+ {
+ 	u32 mysid = current_sid();
+ 	u32 fromsid = task_sid(from);
+ 	u32 tosid = task_sid(to);
+ 	int rc;
+ 
+ 	if (mysid != fromsid) {
+ 		rc = avc_has_perm(mysid, fromsid, SECCLASS_BINDER,
+ 				  BINDER__IMPERSONATE, NULL);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	return avc_has_perm(fromsid, tosid, SECCLASS_BINDER, BINDER__CALL,
+ 			    NULL);
+ }
+ 
+ static int selinux_binder_transfer_binder(struct task_struct *from,
+ 					  struct task_struct *to)
+ {
+ 	u32 fromsid = task_sid(from);
+ 	u32 tosid = task_sid(to);
+ 
+ 	return avc_has_perm(fromsid, tosid, SECCLASS_BINDER, BINDER__TRANSFER,
+ 			    NULL);
+ }
+ 
+ static int selinux_binder_transfer_file(struct task_struct *from,
+ 					struct task_struct *to,
+ 					struct file *file)
+ {
+ 	u32 sid = task_sid(to);
+ 	struct file_security_struct *fsec = file->f_security;
+ 	struct dentry *dentry = file->f_path.dentry;
+ 	struct inode_security_struct *isec;
+ 	struct common_audit_data ad;
+ 	int rc;
+ 
+ 	ad.type = LSM_AUDIT_DATA_PATH;
+ 	ad.u.path = file->f_path;
+ 
+ 	if (sid != fsec->sid) {
+ 		rc = avc_has_perm(sid, fsec->sid,
+ 				  SECCLASS_FD,
+ 				  FD__USE,
+ 				  &ad);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ #ifdef CONFIG_BPF_SYSCALL
+ 	rc = bpf_fd_pass(file, sid);
+ 	if (rc)
+ 		return rc;
+ #endif
+ 
+ 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
+ 		return 0;
+ 
+ 	isec = backing_inode_security(dentry);
+ 	return avc_has_perm(sid, isec->sid, isec->sclass, file_to_av(file),
+ 			    &ad);
+ }
+ 
++>>>>>>> f66e448cfda0 (selinux: bpf: Add addtional check for bpf object file receive)
  static int selinux_ptrace_access_check(struct task_struct *child,
  				     unsigned int mode)
  {
@@@ -6070,204 -6269,343 +6158,244 @@@ static void selinux_ib_free_security(vo
  }
  #endif
  
 -#ifdef CONFIG_BPF_SYSCALL
 -static int selinux_bpf(int cmd, union bpf_attr *attr,
 -				     unsigned int size)
 -{
 -	u32 sid = current_sid();
 -	int ret;
 -
 -	switch (cmd) {
 -	case BPF_MAP_CREATE:
 -		ret = avc_has_perm(sid, sid, SECCLASS_BPF, BPF__MAP_CREATE,
 -				   NULL);
 -		break;
 -	case BPF_PROG_LOAD:
 -		ret = avc_has_perm(sid, sid, SECCLASS_BPF, BPF__PROG_LOAD,
 -				   NULL);
 -		break;
 -	default:
 -		ret = 0;
 -		break;
 -	}
 -
 -	return ret;
 -}
 -
 -static u32 bpf_map_fmode_to_av(fmode_t fmode)
 -{
 -	u32 av = 0;
 -
 -	if (fmode & FMODE_READ)
 -		av |= BPF__MAP_READ;
 -	if (fmode & FMODE_WRITE)
 -		av |= BPF__MAP_WRITE;
 -	return av;
 -}
 -
 +static struct security_operations selinux_ops = {
 +	.name =				"selinux",
 +
 +	.ptrace_access_check =		selinux_ptrace_access_check,
 +	.ptrace_traceme =		selinux_ptrace_traceme,
 +	.capget =			selinux_capget,
 +	.capset =			selinux_capset,
 +	.capable =			selinux_capable,
 +	.quotactl =			selinux_quotactl,
 +	.quota_on =			selinux_quota_on,
 +	.syslog =			selinux_syslog,
 +	.vm_enough_memory =		selinux_vm_enough_memory,
 +
 +	.netlink_send =			selinux_netlink_send,
 +
 +	.bprm_set_creds =		selinux_bprm_set_creds,
 +	.bprm_committing_creds =	selinux_bprm_committing_creds,
 +	.bprm_committed_creds =		selinux_bprm_committed_creds,
 +	.bprm_secureexec =		selinux_bprm_secureexec,
 +
 +	.sb_alloc_security =		selinux_sb_alloc_security,
 +	.sb_free_security =		selinux_sb_free_security,
 +	.sb_copy_data =			selinux_sb_copy_data,
 +	.sb_remount =			selinux_sb_remount,
 +	.sb_kern_mount =		selinux_sb_kern_mount,
 +	.sb_show_options =		selinux_sb_show_options,
 +	.sb_statfs =			selinux_sb_statfs,
 +	.sb_mount =			selinux_mount,
 +	.sb_umount =			selinux_umount,
 +	.sb_set_mnt_opts =		selinux_set_mnt_opts,
 +	.sb_clone_mnt_opts =		selinux_sb_clone_mnt_opts,
 +	.sb_parse_opts_str = 		selinux_parse_opts_str,
 +
++<<<<<<< HEAD
 +	.dentry_init_security =		selinux_dentry_init_security,
 +	.dentry_create_files_as =	selinux_dentry_create_files_as,
++=======
+ /* This function will check the file pass through unix socket or binder to see
+  * if it is a bpf related object. And apply correspinding checks on the bpf
+  * object based on the type. The bpf maps and programs, not like other files and
+  * socket, are using a shared anonymous inode inside the kernel as their inode.
+  * So checking that inode cannot identify if the process have privilege to
+  * access the bpf object and that's why we have to add this additional check in
+  * selinux_file_receive and selinux_binder_transfer_files.
+  */
+ static int bpf_fd_pass(struct file *file, u32 sid)
+ {
+ 	struct bpf_security_struct *bpfsec;
+ 	struct bpf_prog *prog;
+ 	struct bpf_map *map;
+ 	int ret;
+ 
+ 	if (file->f_op == &bpf_map_fops) {
+ 		map = file->private_data;
+ 		bpfsec = map->security;
+ 		ret = avc_has_perm(sid, bpfsec->sid, SECCLASS_BPF,
+ 				   bpf_map_fmode_to_av(file->f_mode), NULL);
+ 		if (ret)
+ 			return ret;
+ 	} else if (file->f_op == &bpf_prog_fops) {
+ 		prog = file->private_data;
+ 		bpfsec = prog->aux->security;
+ 		ret = avc_has_perm(sid, bpfsec->sid, SECCLASS_BPF,
+ 				   BPF__PROG_RUN, NULL);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 	return 0;
+ }
+ 
+ static int selinux_bpf_map(struct bpf_map *map, fmode_t fmode)
+ {
+ 	u32 sid = current_sid();
+ 	struct bpf_security_struct *bpfsec;
++>>>>>>> f66e448cfda0 (selinux: bpf: Add addtional check for bpf object file receive)
 +
 +	.inode_alloc_security =		selinux_inode_alloc_security,
 +	.inode_free_security =		selinux_inode_free_security,
 +	.inode_init_security =		selinux_inode_init_security,
 +	.inode_create =			selinux_inode_create,
 +	.inode_link =			selinux_inode_link,
 +	.inode_unlink =			selinux_inode_unlink,
 +	.inode_symlink =		selinux_inode_symlink,
 +	.inode_mkdir =			selinux_inode_mkdir,
 +	.inode_rmdir =			selinux_inode_rmdir,
 +	.inode_mknod =			selinux_inode_mknod,
 +	.inode_rename =			selinux_inode_rename,
 +	.inode_readlink =		selinux_inode_readlink,
 +	.inode_follow_link =		selinux_inode_follow_link,
 +	.inode_permission =		selinux_inode_permission,
 +	.inode_setattr =		selinux_inode_setattr,
 +	.inode_getattr =		selinux_inode_getattr,
 +	.inode_setxattr =		selinux_inode_setxattr,
 +	.inode_post_setxattr =		selinux_inode_post_setxattr,
 +	.inode_getxattr =		selinux_inode_getxattr,
 +	.inode_listxattr =		selinux_inode_listxattr,
 +	.inode_removexattr =		selinux_inode_removexattr,
 +	.inode_getsecurity =		selinux_inode_getsecurity,
 +	.inode_setsecurity =		selinux_inode_setsecurity,
 +	.inode_listsecurity =		selinux_inode_listsecurity,
 +	.inode_getsecid =		selinux_inode_getsecid,
 +	.inode_copy_up =		selinux_inode_copy_up,
 +	.inode_copy_up_xattr =		selinux_inode_copy_up_xattr,
 +
 +	.file_permission =		selinux_file_permission,
 +	.file_alloc_security =		selinux_file_alloc_security,
 +	.file_free_security =		selinux_file_free_security,
 +	.file_ioctl =			selinux_file_ioctl,
 +	.mmap_file =			selinux_mmap_file,
 +	.mmap_addr =			selinux_mmap_addr,
 +	.file_mprotect =		selinux_file_mprotect,
 +	.file_lock =			selinux_file_lock,
 +	.file_fcntl =			selinux_file_fcntl,
 +	.file_set_fowner =		selinux_file_set_fowner,
 +	.file_send_sigiotask =		selinux_file_send_sigiotask,
 +	.file_receive =			selinux_file_receive,
 +
 +	.file_open =			selinux_file_open,
 +
 +	.task_create =			selinux_task_create,
 +	.cred_alloc_blank =		selinux_cred_alloc_blank,
 +	.cred_free =			selinux_cred_free,
 +	.cred_prepare =			selinux_cred_prepare,
 +	.cred_transfer =		selinux_cred_transfer,
 +	.kernel_act_as =		selinux_kernel_act_as,
 +	.kernel_create_files_as =	selinux_kernel_create_files_as,
 +	.kernel_module_request =	selinux_kernel_module_request,
 +	.task_setpgid =			selinux_task_setpgid,
 +	.task_getpgid =			selinux_task_getpgid,
 +	.task_getsid =			selinux_task_getsid,
 +	.task_getsecid =		selinux_task_getsecid,
 +	.task_setnice =			selinux_task_setnice,
 +	.task_setioprio =		selinux_task_setioprio,
 +	.task_getioprio =		selinux_task_getioprio,
 +	.task_setrlimit =		selinux_task_setrlimit,
 +	.task_setscheduler =		selinux_task_setscheduler,
 +	.task_getscheduler =		selinux_task_getscheduler,
 +	.task_movememory =		selinux_task_movememory,
 +	.task_kill =			selinux_task_kill,
 +	.task_wait =			selinux_task_wait,
 +	.task_to_inode =		selinux_task_to_inode,
 +
 +	.ipc_permission =		selinux_ipc_permission,
 +	.ipc_getsecid =			selinux_ipc_getsecid,
 +
 +	.msg_msg_alloc_security =	selinux_msg_msg_alloc_security,
 +	.msg_msg_free_security =	selinux_msg_msg_free_security,
 +
 +	.msg_queue_alloc_security =	selinux_msg_queue_alloc_security,
 +	.msg_queue_free_security =	selinux_msg_queue_free_security,
 +	.msg_queue_associate =		selinux_msg_queue_associate,
 +	.msg_queue_msgctl =		selinux_msg_queue_msgctl,
 +	.msg_queue_msgsnd =		selinux_msg_queue_msgsnd,
 +	.msg_queue_msgrcv =		selinux_msg_queue_msgrcv,
 +
 +	.shm_alloc_security =		selinux_shm_alloc_security,
 +	.shm_free_security =		selinux_shm_free_security,
 +	.shm_associate =		selinux_shm_associate,
 +	.shm_shmctl =			selinux_shm_shmctl,
 +	.shm_shmat =			selinux_shm_shmat,
 +
 +	.sem_alloc_security =		selinux_sem_alloc_security,
 +	.sem_free_security =		selinux_sem_free_security,
 +	.sem_associate =		selinux_sem_associate,
 +	.sem_semctl =			selinux_sem_semctl,
 +	.sem_semop =			selinux_sem_semop,
 +
 +	.d_instantiate =		selinux_d_instantiate,
 +
 +	.getprocattr =			selinux_getprocattr,
 +	.setprocattr =			selinux_setprocattr,
 +
 +	.ismaclabel =			selinux_ismaclabel,
 +	.secid_to_secctx =		selinux_secid_to_secctx,
 +	.secctx_to_secid =		selinux_secctx_to_secid,
 +	.release_secctx =		selinux_release_secctx,
 +	.inode_invalidate_secctx =	selinux_inode_invalidate_secctx,
 +	.inode_notifysecctx =		selinux_inode_notifysecctx,
 +	.inode_setsecctx =		selinux_inode_setsecctx,
 +	.inode_getsecctx =		selinux_inode_getsecctx,
 +
 +	.unix_stream_connect =		selinux_socket_unix_stream_connect,
 +	.unix_may_send =		selinux_socket_unix_may_send,
 +
 +	.socket_create =		selinux_socket_create,
 +	.socket_post_create =		selinux_socket_post_create,
 +	.socket_bind =			selinux_socket_bind,
 +	.socket_connect =		selinux_socket_connect,
 +	.socket_listen =		selinux_socket_listen,
 +	.socket_accept =		selinux_socket_accept,
 +	.socket_sendmsg =		selinux_socket_sendmsg,
 +	.socket_recvmsg =		selinux_socket_recvmsg,
 +	.socket_getsockname =		selinux_socket_getsockname,
 +	.socket_getpeername =		selinux_socket_getpeername,
 +	.socket_getsockopt =		selinux_socket_getsockopt,
 +	.socket_setsockopt =		selinux_socket_setsockopt,
 +	.socket_shutdown =		selinux_socket_shutdown,
 +	.socket_sock_rcv_skb =		selinux_socket_sock_rcv_skb,
 +	.socket_getpeersec_stream =	selinux_socket_getpeersec_stream,
 +	.socket_getpeersec_dgram =	selinux_socket_getpeersec_dgram,
 +	.sk_alloc_security =		selinux_sk_alloc_security,
 +	.sk_free_security =		selinux_sk_free_security,
 +	.sk_clone_security =		selinux_sk_clone_security,
 +	.sk_getsecid =			selinux_sk_getsecid,
 +	.sock_graft =			selinux_sock_graft,
 +	.inet_conn_request =		selinux_inet_conn_request,
 +	.inet_csk_clone =		selinux_inet_csk_clone,
 +	.inet_conn_established =	selinux_inet_conn_established,
 +	.secmark_relabel_packet =	selinux_secmark_relabel_packet,
 +	.secmark_refcount_inc =		selinux_secmark_refcount_inc,
 +	.secmark_refcount_dec =		selinux_secmark_refcount_dec,
 +	.req_classify_flow =		selinux_req_classify_flow,
 +	.tun_dev_alloc_security =	selinux_tun_dev_alloc_security,
 +	.tun_dev_free_security =	selinux_tun_dev_free_security,
 +	.tun_dev_create =		selinux_tun_dev_create,
 +	.tun_dev_attach_queue =		selinux_tun_dev_attach_queue,
 +	.tun_dev_attach =		selinux_tun_dev_attach,
 +	.tun_dev_open =			selinux_tun_dev_open,
 +	.skb_owned_by =			selinux_skb_owned_by,
  
 -	bpfsec = map->security;
 -	return avc_has_perm(sid, bpfsec->sid, SECCLASS_BPF,
 -			    bpf_map_fmode_to_av(fmode), NULL);
 -}
 -
 -static int selinux_bpf_prog(struct bpf_prog *prog)
 -{
 -	u32 sid = current_sid();
 -	struct bpf_security_struct *bpfsec;
 -
 -	bpfsec = prog->aux->security;
 -	return avc_has_perm(sid, bpfsec->sid, SECCLASS_BPF,
 -			    BPF__PROG_RUN, NULL);
 -}
 -
 -static int selinux_bpf_map_alloc(struct bpf_map *map)
 -{
 -	struct bpf_security_struct *bpfsec;
 -
 -	bpfsec = kzalloc(sizeof(*bpfsec), GFP_KERNEL);
 -	if (!bpfsec)
 -		return -ENOMEM;
 -
 -	bpfsec->sid = current_sid();
 -	map->security = bpfsec;
 -
 -	return 0;
 -}
 -
 -static void selinux_bpf_map_free(struct bpf_map *map)
 -{
 -	struct bpf_security_struct *bpfsec = map->security;
 -
 -	map->security = NULL;
 -	kfree(bpfsec);
 -}
 -
 -static int selinux_bpf_prog_alloc(struct bpf_prog_aux *aux)
 -{
 -	struct bpf_security_struct *bpfsec;
 -
 -	bpfsec = kzalloc(sizeof(*bpfsec), GFP_KERNEL);
 -	if (!bpfsec)
 -		return -ENOMEM;
 -
 -	bpfsec->sid = current_sid();
 -	aux->security = bpfsec;
 -
 -	return 0;
 -}
 -
 -static void selinux_bpf_prog_free(struct bpf_prog_aux *aux)
 -{
 -	struct bpf_security_struct *bpfsec = aux->security;
 -
 -	aux->security = NULL;
 -	kfree(bpfsec);
 -}
 -#endif
 -
 -static struct security_hook_list selinux_hooks[] __lsm_ro_after_init = {
 -	LSM_HOOK_INIT(binder_set_context_mgr, selinux_binder_set_context_mgr),
 -	LSM_HOOK_INIT(binder_transaction, selinux_binder_transaction),
 -	LSM_HOOK_INIT(binder_transfer_binder, selinux_binder_transfer_binder),
 -	LSM_HOOK_INIT(binder_transfer_file, selinux_binder_transfer_file),
 -
 -	LSM_HOOK_INIT(ptrace_access_check, selinux_ptrace_access_check),
 -	LSM_HOOK_INIT(ptrace_traceme, selinux_ptrace_traceme),
 -	LSM_HOOK_INIT(capget, selinux_capget),
 -	LSM_HOOK_INIT(capset, selinux_capset),
 -	LSM_HOOK_INIT(capable, selinux_capable),
 -	LSM_HOOK_INIT(quotactl, selinux_quotactl),
 -	LSM_HOOK_INIT(quota_on, selinux_quota_on),
 -	LSM_HOOK_INIT(syslog, selinux_syslog),
 -	LSM_HOOK_INIT(vm_enough_memory, selinux_vm_enough_memory),
 -
 -	LSM_HOOK_INIT(netlink_send, selinux_netlink_send),
 -
 -	LSM_HOOK_INIT(bprm_set_creds, selinux_bprm_set_creds),
 -	LSM_HOOK_INIT(bprm_committing_creds, selinux_bprm_committing_creds),
 -	LSM_HOOK_INIT(bprm_committed_creds, selinux_bprm_committed_creds),
 -
 -	LSM_HOOK_INIT(sb_alloc_security, selinux_sb_alloc_security),
 -	LSM_HOOK_INIT(sb_free_security, selinux_sb_free_security),
 -	LSM_HOOK_INIT(sb_copy_data, selinux_sb_copy_data),
 -	LSM_HOOK_INIT(sb_remount, selinux_sb_remount),
 -	LSM_HOOK_INIT(sb_kern_mount, selinux_sb_kern_mount),
 -	LSM_HOOK_INIT(sb_show_options, selinux_sb_show_options),
 -	LSM_HOOK_INIT(sb_statfs, selinux_sb_statfs),
 -	LSM_HOOK_INIT(sb_mount, selinux_mount),
 -	LSM_HOOK_INIT(sb_umount, selinux_umount),
 -	LSM_HOOK_INIT(sb_set_mnt_opts, selinux_set_mnt_opts),
 -	LSM_HOOK_INIT(sb_clone_mnt_opts, selinux_sb_clone_mnt_opts),
 -	LSM_HOOK_INIT(sb_parse_opts_str, selinux_parse_opts_str),
 -
 -	LSM_HOOK_INIT(dentry_init_security, selinux_dentry_init_security),
 -	LSM_HOOK_INIT(dentry_create_files_as, selinux_dentry_create_files_as),
 -
 -	LSM_HOOK_INIT(inode_alloc_security, selinux_inode_alloc_security),
 -	LSM_HOOK_INIT(inode_free_security, selinux_inode_free_security),
 -	LSM_HOOK_INIT(inode_init_security, selinux_inode_init_security),
 -	LSM_HOOK_INIT(inode_create, selinux_inode_create),
 -	LSM_HOOK_INIT(inode_link, selinux_inode_link),
 -	LSM_HOOK_INIT(inode_unlink, selinux_inode_unlink),
 -	LSM_HOOK_INIT(inode_symlink, selinux_inode_symlink),
 -	LSM_HOOK_INIT(inode_mkdir, selinux_inode_mkdir),
 -	LSM_HOOK_INIT(inode_rmdir, selinux_inode_rmdir),
 -	LSM_HOOK_INIT(inode_mknod, selinux_inode_mknod),
 -	LSM_HOOK_INIT(inode_rename, selinux_inode_rename),
 -	LSM_HOOK_INIT(inode_readlink, selinux_inode_readlink),
 -	LSM_HOOK_INIT(inode_follow_link, selinux_inode_follow_link),
 -	LSM_HOOK_INIT(inode_permission, selinux_inode_permission),
 -	LSM_HOOK_INIT(inode_setattr, selinux_inode_setattr),
 -	LSM_HOOK_INIT(inode_getattr, selinux_inode_getattr),
 -	LSM_HOOK_INIT(inode_setxattr, selinux_inode_setxattr),
 -	LSM_HOOK_INIT(inode_post_setxattr, selinux_inode_post_setxattr),
 -	LSM_HOOK_INIT(inode_getxattr, selinux_inode_getxattr),
 -	LSM_HOOK_INIT(inode_listxattr, selinux_inode_listxattr),
 -	LSM_HOOK_INIT(inode_removexattr, selinux_inode_removexattr),
 -	LSM_HOOK_INIT(inode_getsecurity, selinux_inode_getsecurity),
 -	LSM_HOOK_INIT(inode_setsecurity, selinux_inode_setsecurity),
 -	LSM_HOOK_INIT(inode_listsecurity, selinux_inode_listsecurity),
 -	LSM_HOOK_INIT(inode_getsecid, selinux_inode_getsecid),
 -	LSM_HOOK_INIT(inode_copy_up, selinux_inode_copy_up),
 -	LSM_HOOK_INIT(inode_copy_up_xattr, selinux_inode_copy_up_xattr),
 -
 -	LSM_HOOK_INIT(file_permission, selinux_file_permission),
 -	LSM_HOOK_INIT(file_alloc_security, selinux_file_alloc_security),
 -	LSM_HOOK_INIT(file_free_security, selinux_file_free_security),
 -	LSM_HOOK_INIT(file_ioctl, selinux_file_ioctl),
 -	LSM_HOOK_INIT(mmap_file, selinux_mmap_file),
 -	LSM_HOOK_INIT(mmap_addr, selinux_mmap_addr),
 -	LSM_HOOK_INIT(file_mprotect, selinux_file_mprotect),
 -	LSM_HOOK_INIT(file_lock, selinux_file_lock),
 -	LSM_HOOK_INIT(file_fcntl, selinux_file_fcntl),
 -	LSM_HOOK_INIT(file_set_fowner, selinux_file_set_fowner),
 -	LSM_HOOK_INIT(file_send_sigiotask, selinux_file_send_sigiotask),
 -	LSM_HOOK_INIT(file_receive, selinux_file_receive),
 -
 -	LSM_HOOK_INIT(file_open, selinux_file_open),
 -
 -	LSM_HOOK_INIT(task_alloc, selinux_task_alloc),
 -	LSM_HOOK_INIT(cred_alloc_blank, selinux_cred_alloc_blank),
 -	LSM_HOOK_INIT(cred_free, selinux_cred_free),
 -	LSM_HOOK_INIT(cred_prepare, selinux_cred_prepare),
 -	LSM_HOOK_INIT(cred_transfer, selinux_cred_transfer),
 -	LSM_HOOK_INIT(kernel_act_as, selinux_kernel_act_as),
 -	LSM_HOOK_INIT(kernel_create_files_as, selinux_kernel_create_files_as),
 -	LSM_HOOK_INIT(kernel_module_request, selinux_kernel_module_request),
 -	LSM_HOOK_INIT(kernel_read_file, selinux_kernel_read_file),
 -	LSM_HOOK_INIT(task_setpgid, selinux_task_setpgid),
 -	LSM_HOOK_INIT(task_getpgid, selinux_task_getpgid),
 -	LSM_HOOK_INIT(task_getsid, selinux_task_getsid),
 -	LSM_HOOK_INIT(task_getsecid, selinux_task_getsecid),
 -	LSM_HOOK_INIT(task_setnice, selinux_task_setnice),
 -	LSM_HOOK_INIT(task_setioprio, selinux_task_setioprio),
 -	LSM_HOOK_INIT(task_getioprio, selinux_task_getioprio),
 -	LSM_HOOK_INIT(task_prlimit, selinux_task_prlimit),
 -	LSM_HOOK_INIT(task_setrlimit, selinux_task_setrlimit),
 -	LSM_HOOK_INIT(task_setscheduler, selinux_task_setscheduler),
 -	LSM_HOOK_INIT(task_getscheduler, selinux_task_getscheduler),
 -	LSM_HOOK_INIT(task_movememory, selinux_task_movememory),
 -	LSM_HOOK_INIT(task_kill, selinux_task_kill),
 -	LSM_HOOK_INIT(task_to_inode, selinux_task_to_inode),
 -
 -	LSM_HOOK_INIT(ipc_permission, selinux_ipc_permission),
 -	LSM_HOOK_INIT(ipc_getsecid, selinux_ipc_getsecid),
 -
 -	LSM_HOOK_INIT(msg_msg_alloc_security, selinux_msg_msg_alloc_security),
 -	LSM_HOOK_INIT(msg_msg_free_security, selinux_msg_msg_free_security),
 -
 -	LSM_HOOK_INIT(msg_queue_alloc_security,
 -			selinux_msg_queue_alloc_security),
 -	LSM_HOOK_INIT(msg_queue_free_security, selinux_msg_queue_free_security),
 -	LSM_HOOK_INIT(msg_queue_associate, selinux_msg_queue_associate),
 -	LSM_HOOK_INIT(msg_queue_msgctl, selinux_msg_queue_msgctl),
 -	LSM_HOOK_INIT(msg_queue_msgsnd, selinux_msg_queue_msgsnd),
 -	LSM_HOOK_INIT(msg_queue_msgrcv, selinux_msg_queue_msgrcv),
 -
 -	LSM_HOOK_INIT(shm_alloc_security, selinux_shm_alloc_security),
 -	LSM_HOOK_INIT(shm_free_security, selinux_shm_free_security),
 -	LSM_HOOK_INIT(shm_associate, selinux_shm_associate),
 -	LSM_HOOK_INIT(shm_shmctl, selinux_shm_shmctl),
 -	LSM_HOOK_INIT(shm_shmat, selinux_shm_shmat),
 -
 -	LSM_HOOK_INIT(sem_alloc_security, selinux_sem_alloc_security),
 -	LSM_HOOK_INIT(sem_free_security, selinux_sem_free_security),
 -	LSM_HOOK_INIT(sem_associate, selinux_sem_associate),
 -	LSM_HOOK_INIT(sem_semctl, selinux_sem_semctl),
 -	LSM_HOOK_INIT(sem_semop, selinux_sem_semop),
 -
 -	LSM_HOOK_INIT(d_instantiate, selinux_d_instantiate),
 -
 -	LSM_HOOK_INIT(getprocattr, selinux_getprocattr),
 -	LSM_HOOK_INIT(setprocattr, selinux_setprocattr),
 -
 -	LSM_HOOK_INIT(ismaclabel, selinux_ismaclabel),
 -	LSM_HOOK_INIT(secid_to_secctx, selinux_secid_to_secctx),
 -	LSM_HOOK_INIT(secctx_to_secid, selinux_secctx_to_secid),
 -	LSM_HOOK_INIT(release_secctx, selinux_release_secctx),
 -	LSM_HOOK_INIT(inode_invalidate_secctx, selinux_inode_invalidate_secctx),
 -	LSM_HOOK_INIT(inode_notifysecctx, selinux_inode_notifysecctx),
 -	LSM_HOOK_INIT(inode_setsecctx, selinux_inode_setsecctx),
 -	LSM_HOOK_INIT(inode_getsecctx, selinux_inode_getsecctx),
 -
 -	LSM_HOOK_INIT(unix_stream_connect, selinux_socket_unix_stream_connect),
 -	LSM_HOOK_INIT(unix_may_send, selinux_socket_unix_may_send),
 -
 -	LSM_HOOK_INIT(socket_create, selinux_socket_create),
 -	LSM_HOOK_INIT(socket_post_create, selinux_socket_post_create),
 -	LSM_HOOK_INIT(socket_bind, selinux_socket_bind),
 -	LSM_HOOK_INIT(socket_connect, selinux_socket_connect),
 -	LSM_HOOK_INIT(socket_listen, selinux_socket_listen),
 -	LSM_HOOK_INIT(socket_accept, selinux_socket_accept),
 -	LSM_HOOK_INIT(socket_sendmsg, selinux_socket_sendmsg),
 -	LSM_HOOK_INIT(socket_recvmsg, selinux_socket_recvmsg),
 -	LSM_HOOK_INIT(socket_getsockname, selinux_socket_getsockname),
 -	LSM_HOOK_INIT(socket_getpeername, selinux_socket_getpeername),
 -	LSM_HOOK_INIT(socket_getsockopt, selinux_socket_getsockopt),
 -	LSM_HOOK_INIT(socket_setsockopt, selinux_socket_setsockopt),
 -	LSM_HOOK_INIT(socket_shutdown, selinux_socket_shutdown),
 -	LSM_HOOK_INIT(socket_sock_rcv_skb, selinux_socket_sock_rcv_skb),
 -	LSM_HOOK_INIT(socket_getpeersec_stream,
 -			selinux_socket_getpeersec_stream),
 -	LSM_HOOK_INIT(socket_getpeersec_dgram, selinux_socket_getpeersec_dgram),
 -	LSM_HOOK_INIT(sk_alloc_security, selinux_sk_alloc_security),
 -	LSM_HOOK_INIT(sk_free_security, selinux_sk_free_security),
 -	LSM_HOOK_INIT(sk_clone_security, selinux_sk_clone_security),
 -	LSM_HOOK_INIT(sk_getsecid, selinux_sk_getsecid),
 -	LSM_HOOK_INIT(sock_graft, selinux_sock_graft),
 -	LSM_HOOK_INIT(inet_conn_request, selinux_inet_conn_request),
 -	LSM_HOOK_INIT(inet_csk_clone, selinux_inet_csk_clone),
 -	LSM_HOOK_INIT(inet_conn_established, selinux_inet_conn_established),
 -	LSM_HOOK_INIT(secmark_relabel_packet, selinux_secmark_relabel_packet),
 -	LSM_HOOK_INIT(secmark_refcount_inc, selinux_secmark_refcount_inc),
 -	LSM_HOOK_INIT(secmark_refcount_dec, selinux_secmark_refcount_dec),
 -	LSM_HOOK_INIT(req_classify_flow, selinux_req_classify_flow),
 -	LSM_HOOK_INIT(tun_dev_alloc_security, selinux_tun_dev_alloc_security),
 -	LSM_HOOK_INIT(tun_dev_free_security, selinux_tun_dev_free_security),
 -	LSM_HOOK_INIT(tun_dev_create, selinux_tun_dev_create),
 -	LSM_HOOK_INIT(tun_dev_attach_queue, selinux_tun_dev_attach_queue),
 -	LSM_HOOK_INIT(tun_dev_attach, selinux_tun_dev_attach),
 -	LSM_HOOK_INIT(tun_dev_open, selinux_tun_dev_open),
  #ifdef CONFIG_SECURITY_INFINIBAND
 -	LSM_HOOK_INIT(ib_pkey_access, selinux_ib_pkey_access),
 -	LSM_HOOK_INIT(ib_endport_manage_subnet,
 -		      selinux_ib_endport_manage_subnet),
 -	LSM_HOOK_INIT(ib_alloc_security, selinux_ib_alloc_security),
 -	LSM_HOOK_INIT(ib_free_security, selinux_ib_free_security),
 +	.ib_pkey_access =		selinux_ib_pkey_access,
 +	.ib_endport_manage_subnet =	selinux_ib_endport_manage_subnet,
 +	.ib_alloc_security =		selinux_ib_alloc_security,
 +	.ib_free_security =		selinux_ib_free_security,
  #endif
 +
  #ifdef CONFIG_SECURITY_NETWORK_XFRM
 -	LSM_HOOK_INIT(xfrm_policy_alloc_security, selinux_xfrm_policy_alloc),
 -	LSM_HOOK_INIT(xfrm_policy_clone_security, selinux_xfrm_policy_clone),
 -	LSM_HOOK_INIT(xfrm_policy_free_security, selinux_xfrm_policy_free),
 -	LSM_HOOK_INIT(xfrm_policy_delete_security, selinux_xfrm_policy_delete),
 -	LSM_HOOK_INIT(xfrm_state_alloc, selinux_xfrm_state_alloc),
 -	LSM_HOOK_INIT(xfrm_state_alloc_acquire,
 -			selinux_xfrm_state_alloc_acquire),
 -	LSM_HOOK_INIT(xfrm_state_free_security, selinux_xfrm_state_free),
 -	LSM_HOOK_INIT(xfrm_state_delete_security, selinux_xfrm_state_delete),
 -	LSM_HOOK_INIT(xfrm_policy_lookup, selinux_xfrm_policy_lookup),
 -	LSM_HOOK_INIT(xfrm_state_pol_flow_match,
 -			selinux_xfrm_state_pol_flow_match),
 -	LSM_HOOK_INIT(xfrm_decode_session, selinux_xfrm_decode_session),
 +	.xfrm_policy_alloc_security =	selinux_xfrm_policy_alloc,
 +	.xfrm_policy_clone_security =	selinux_xfrm_policy_clone,
 +	.xfrm_policy_free_security =	selinux_xfrm_policy_free,
 +	.xfrm_policy_delete_security =	selinux_xfrm_policy_delete,
 +	.xfrm_state_alloc_security =	selinux_xfrm_state_alloc,
 +	.xfrm_state_free_security =	selinux_xfrm_state_free,
 +	.xfrm_state_delete_security =	selinux_xfrm_state_delete,
 +	.xfrm_policy_lookup =		selinux_xfrm_policy_lookup,
 +	.xfrm_state_pol_flow_match =	selinux_xfrm_state_pol_flow_match,
 +	.xfrm_decode_session =		selinux_xfrm_decode_session,
  #endif
  
  #ifdef CONFIG_KEYS
* Unmerged path kernel/bpf/syscall.c
* Unmerged path include/linux/bpf.h
* Unmerged path kernel/bpf/syscall.c
* Unmerged path security/selinux/hooks.c
