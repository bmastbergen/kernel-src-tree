bpf: Add gpl_compatible flag to struct bpf_prog_info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit b85fab0e67b162014cd328cb4e2a8e8ae382cb8a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b85fab0e.failed

Adding gpl_compatible flag to struct bpf_prog_info
so it can be dumped via bpf_prog_get_info_by_fd and
displayed via bpftool progs dump.

Alexei noticed 4-byte hole in struct bpf_prog_info,
so we put the u32 flags field in there, and we can
keep adding bit fields in there without breaking
user space.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit b85fab0e67b162014cd328cb4e2a8e8ae382cb8a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	kernel/bpf/syscall.c
diff --cc include/uapi/linux/bpf.h
index e369860b690e,da8801860c7d..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -153,16 -1025,235 +153,234 @@@ enum xdp_action 
  struct xdp_md {
  	__u32 data;
  	__u32 data_end;
 -	__u32 data_meta;
 -	/* Below access go through struct xdp_rxq_info */
 -	__u32 ingress_ifindex; /* rxq->dev->ifindex */
 -	__u32 rx_queue_index;  /* rxq->queue_index  */
  };
  
 -enum sk_action {
 -	SK_DROP = 0,
 -	SK_PASS,
 -};
 +#define XDP_PACKET_HEADROOM 256
  
 -/* user accessible metadata for SK_MSG packet hook, new fields must
 - * be added to the end of this structure
 +/* integer value in 'imm' field of BPF_CALL instruction selects which helper
 + * function eBPF program intends to call
   */
++<<<<<<< HEAD
 +enum bpf_func_id {
 +	BPF_FUNC_unspec,
 +	__BPF_FUNC_MAX_ID,
++=======
+ struct sk_msg_md {
+ 	void *data;
+ 	void *data_end;
+ };
+ 
+ #define BPF_TAG_SIZE	8
+ 
+ struct bpf_prog_info {
+ 	__u32 type;
+ 	__u32 id;
+ 	__u8  tag[BPF_TAG_SIZE];
+ 	__u32 jited_prog_len;
+ 	__u32 xlated_prog_len;
+ 	__aligned_u64 jited_prog_insns;
+ 	__aligned_u64 xlated_prog_insns;
+ 	__u64 load_time;	/* ns since boottime */
+ 	__u32 created_by_uid;
+ 	__u32 nr_map_ids;
+ 	__aligned_u64 map_ids;
+ 	char name[BPF_OBJ_NAME_LEN];
+ 	__u32 ifindex;
+ 	__u32 gpl_compatible:1;
+ 	__u64 netns_dev;
+ 	__u64 netns_ino;
+ } __attribute__((aligned(8)));
+ 
+ struct bpf_map_info {
+ 	__u32 type;
+ 	__u32 id;
+ 	__u32 key_size;
+ 	__u32 value_size;
+ 	__u32 max_entries;
+ 	__u32 map_flags;
+ 	char  name[BPF_OBJ_NAME_LEN];
+ 	__u32 ifindex;
+ 	__u64 netns_dev;
+ 	__u64 netns_ino;
+ } __attribute__((aligned(8)));
+ 
+ /* User bpf_sock_addr struct to access socket fields and sockaddr struct passed
+  * by user and intended to be used by socket (e.g. to bind to, depends on
+  * attach attach type).
+  */
+ struct bpf_sock_addr {
+ 	__u32 user_family;	/* Allows 4-byte read, but no write. */
+ 	__u32 user_ip4;		/* Allows 1,2,4-byte read and 4-byte write.
+ 				 * Stored in network byte order.
+ 				 */
+ 	__u32 user_ip6[4];	/* Allows 1,2,4-byte read an 4-byte write.
+ 				 * Stored in network byte order.
+ 				 */
+ 	__u32 user_port;	/* Allows 4-byte read and write.
+ 				 * Stored in network byte order
+ 				 */
+ 	__u32 family;		/* Allows 4-byte read, but no write */
+ 	__u32 type;		/* Allows 4-byte read, but no write */
+ 	__u32 protocol;		/* Allows 4-byte read, but no write */
+ };
+ 
+ /* User bpf_sock_ops struct to access socket values and specify request ops
+  * and their replies.
+  * Some of this fields are in network (bigendian) byte order and may need
+  * to be converted before use (bpf_ntohl() defined in samples/bpf/bpf_endian.h).
+  * New fields can only be added at the end of this structure
+  */
+ struct bpf_sock_ops {
+ 	__u32 op;
+ 	union {
+ 		__u32 args[4];		/* Optionally passed to bpf program */
+ 		__u32 reply;		/* Returned by bpf program	    */
+ 		__u32 replylong[4];	/* Optionally returned by bpf prog  */
+ 	};
+ 	__u32 family;
+ 	__u32 remote_ip4;	/* Stored in network byte order */
+ 	__u32 local_ip4;	/* Stored in network byte order */
+ 	__u32 remote_ip6[4];	/* Stored in network byte order */
+ 	__u32 local_ip6[4];	/* Stored in network byte order */
+ 	__u32 remote_port;	/* Stored in network byte order */
+ 	__u32 local_port;	/* stored in host byte order */
+ 	__u32 is_fullsock;	/* Some TCP fields are only valid if
+ 				 * there is a full socket. If not, the
+ 				 * fields read as zero.
+ 				 */
+ 	__u32 snd_cwnd;
+ 	__u32 srtt_us;		/* Averaged RTT << 3 in usecs */
+ 	__u32 bpf_sock_ops_cb_flags; /* flags defined in uapi/linux/tcp.h */
+ 	__u32 state;
+ 	__u32 rtt_min;
+ 	__u32 snd_ssthresh;
+ 	__u32 rcv_nxt;
+ 	__u32 snd_nxt;
+ 	__u32 snd_una;
+ 	__u32 mss_cache;
+ 	__u32 ecn_flags;
+ 	__u32 rate_delivered;
+ 	__u32 rate_interval_us;
+ 	__u32 packets_out;
+ 	__u32 retrans_out;
+ 	__u32 total_retrans;
+ 	__u32 segs_in;
+ 	__u32 data_segs_in;
+ 	__u32 segs_out;
+ 	__u32 data_segs_out;
+ 	__u32 lost_out;
+ 	__u32 sacked_out;
+ 	__u32 sk_txhash;
+ 	__u64 bytes_received;
+ 	__u64 bytes_acked;
+ };
+ 
+ /* Definitions for bpf_sock_ops_cb_flags */
+ #define BPF_SOCK_OPS_RTO_CB_FLAG	(1<<0)
+ #define BPF_SOCK_OPS_RETRANS_CB_FLAG	(1<<1)
+ #define BPF_SOCK_OPS_STATE_CB_FLAG	(1<<2)
+ #define BPF_SOCK_OPS_ALL_CB_FLAGS       0x7		/* Mask of all currently
+ 							 * supported cb flags
+ 							 */
+ 
+ /* List of known BPF sock_ops operators.
+  * New entries can only be added at the end
+  */
+ enum {
+ 	BPF_SOCK_OPS_VOID,
+ 	BPF_SOCK_OPS_TIMEOUT_INIT,	/* Should return SYN-RTO value to use or
+ 					 * -1 if default value should be used
+ 					 */
+ 	BPF_SOCK_OPS_RWND_INIT,		/* Should return initial advertized
+ 					 * window (in packets) or -1 if default
+ 					 * value should be used
+ 					 */
+ 	BPF_SOCK_OPS_TCP_CONNECT_CB,	/* Calls BPF program right before an
+ 					 * active connection is initialized
+ 					 */
+ 	BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB,	/* Calls BPF program when an
+ 						 * active connection is
+ 						 * established
+ 						 */
+ 	BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB,	/* Calls BPF program when a
+ 						 * passive connection is
+ 						 * established
+ 						 */
+ 	BPF_SOCK_OPS_NEEDS_ECN,		/* If connection's congestion control
+ 					 * needs ECN
+ 					 */
+ 	BPF_SOCK_OPS_BASE_RTT,		/* Get base RTT. The correct value is
+ 					 * based on the path and may be
+ 					 * dependent on the congestion control
+ 					 * algorithm. In general it indicates
+ 					 * a congestion threshold. RTTs above
+ 					 * this indicate congestion
+ 					 */
+ 	BPF_SOCK_OPS_RTO_CB,		/* Called when an RTO has triggered.
+ 					 * Arg1: value of icsk_retransmits
+ 					 * Arg2: value of icsk_rto
+ 					 * Arg3: whether RTO has expired
+ 					 */
+ 	BPF_SOCK_OPS_RETRANS_CB,	/* Called when skb is retransmitted.
+ 					 * Arg1: sequence number of 1st byte
+ 					 * Arg2: # segments
+ 					 * Arg3: return value of
+ 					 *       tcp_transmit_skb (0 => success)
+ 					 */
+ 	BPF_SOCK_OPS_STATE_CB,		/* Called when TCP changes state.
+ 					 * Arg1: old_state
+ 					 * Arg2: new_state
+ 					 */
+ };
+ 
+ /* List of TCP states. There is a build check in net/ipv4/tcp.c to detect
+  * changes between the TCP and BPF versions. Ideally this should never happen.
+  * If it does, we need to add code to convert them before calling
+  * the BPF sock_ops function.
+  */
+ enum {
+ 	BPF_TCP_ESTABLISHED = 1,
+ 	BPF_TCP_SYN_SENT,
+ 	BPF_TCP_SYN_RECV,
+ 	BPF_TCP_FIN_WAIT1,
+ 	BPF_TCP_FIN_WAIT2,
+ 	BPF_TCP_TIME_WAIT,
+ 	BPF_TCP_CLOSE,
+ 	BPF_TCP_CLOSE_WAIT,
+ 	BPF_TCP_LAST_ACK,
+ 	BPF_TCP_LISTEN,
+ 	BPF_TCP_CLOSING,	/* Now a valid state */
+ 	BPF_TCP_NEW_SYN_RECV,
+ 
+ 	BPF_TCP_MAX_STATES	/* Leave at the end! */
+ };
+ 
+ #define TCP_BPF_IW		1001	/* Set TCP initial congestion window */
+ #define TCP_BPF_SNDCWND_CLAMP	1002	/* Set sndcwnd_clamp */
+ 
+ struct bpf_perf_event_value {
+ 	__u64 counter;
+ 	__u64 enabled;
+ 	__u64 running;
+ };
+ 
+ #define BPF_DEVCG_ACC_MKNOD	(1ULL << 0)
+ #define BPF_DEVCG_ACC_READ	(1ULL << 1)
+ #define BPF_DEVCG_ACC_WRITE	(1ULL << 2)
+ 
+ #define BPF_DEVCG_DEV_BLOCK	(1ULL << 0)
+ #define BPF_DEVCG_DEV_CHAR	(1ULL << 1)
+ 
+ struct bpf_cgroup_dev_ctx {
+ 	/* access_type encoded as (BPF_DEVCG_ACC_* << 16) | BPF_DEVCG_DEV_* */
+ 	__u32 access_type;
+ 	__u32 major;
+ 	__u32 minor;
+ };
+ 
+ struct bpf_raw_tracepoint_args {
+ 	__u64 args[0];
++>>>>>>> b85fab0e67b1 (bpf: Add gpl_compatible flag to struct bpf_prog_info)
  };
  
  #endif /* _UAPI__LINUX_BPF_H__ */
* Unmerged path kernel/bpf/syscall.c
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path kernel/bpf/syscall.c
