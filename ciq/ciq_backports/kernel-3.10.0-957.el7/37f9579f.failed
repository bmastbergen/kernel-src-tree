blk-mq: Avoid that submitting a bio concurrently with device removal triggers a crash

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Bart Van Assche <bart.vanassche@wdc.com>
commit 37f9579f4c31a6d698dbf3016d7bf132f9288d30
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/37f9579f.failed

Because blkcg_exit_queue() is now called from inside blk_cleanup_queue()
it is no longer safe to access cgroup information during or after the
blk_cleanup_queue() call. Hence protect the generic_make_request_checks()
call with blk_queue_enter() / blk_queue_exit().

	Reported-by: Ming Lei <ming.lei@redhat.com>
Fixes: a063057d7c73 ("block: Fix a race between request queue removal and the block cgroup controller")
	Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
	Cc: Ming Lei <ming.lei@redhat.com>
	Cc: Joseph Qi <joseph.qi@linux.alibaba.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 37f9579f4c31a6d698dbf3016d7bf132f9288d30)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-core.c
diff --cc block/blk-core.c
index 3c1e8c52cafa,806ce2442819..000000000000
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@@ -2142,9 -2385,22 +2142,25 @@@ void generic_make_request(struct bio *b
  	 * yet.
  	 */
  	struct bio_list bio_list_on_stack[2];
++<<<<<<< HEAD
++=======
+ 	blk_mq_req_flags_t flags = 0;
+ 	struct request_queue *q = bio->bi_disk->queue;
+ 	blk_qc_t ret = BLK_QC_T_NONE;
++>>>>>>> 37f9579f4c31 (blk-mq: Avoid that submitting a bio concurrently with device removal triggers a crash)
+ 
+ 	if (bio->bi_opf & REQ_NOWAIT)
+ 		flags = BLK_MQ_REQ_NOWAIT;
+ 	if (blk_queue_enter(q, flags) < 0) {
+ 		if (!blk_queue_dying(q) && (bio->bi_opf & REQ_NOWAIT))
+ 			bio_wouldblock_error(bio);
+ 		else
+ 			bio_io_error(bio);
+ 		return ret;
+ 	}
  
  	if (!generic_make_request_checks(bio))
 -		goto out;
 +		return;
  
  	/*
  	 * We only want one ->make_request_fn to be active at a time, else
@@@ -2179,18 -2435,29 +2195,35 @@@
  	bio_list_init(&bio_list_on_stack[0]);
  	current->bio_list = bio_list_on_stack;
  	do {
++<<<<<<< HEAD
 +		struct request_queue *q = bdev_get_queue(bio->bi_bdev);
 +
 +		if (likely(blk_queue_enter(q, 0) == 0)) {
++=======
+ 		bool enter_succeeded = true;
+ 
+ 		if (unlikely(q != bio->bi_disk->queue)) {
+ 			if (q)
+ 				blk_queue_exit(q);
+ 			q = bio->bi_disk->queue;
+ 			flags = 0;
+ 			if (bio->bi_opf & REQ_NOWAIT)
+ 				flags = BLK_MQ_REQ_NOWAIT;
+ 			if (blk_queue_enter(q, flags) < 0) {
+ 				enter_succeeded = false;
+ 				q = NULL;
+ 			}
+ 		}
+ 
+ 		if (enter_succeeded) {
++>>>>>>> 37f9579f4c31 (blk-mq: Avoid that submitting a bio concurrently with device removal triggers a crash)
  			struct bio_list lower, same;
  
  			/* Create a fresh bio_list for all subordinate requests */
  			bio_list_on_stack[1] = bio_list_on_stack[0];
  			bio_list_init(&bio_list_on_stack[0]);
 -			ret = q->make_request_fn(q, bio);
 +			q->make_request_fn(q, bio);
  
- 			blk_queue_exit(q);
- 
  			/* sort new bios into those for a lower level
  			 * and those for the same level
  			 */
@@@ -2211,6 -2482,11 +2244,14 @@@
  		bio = bio_list_pop(&bio_list_on_stack[0]);
  	} while (bio);
  	current->bio_list = NULL; /* deactivate */
++<<<<<<< HEAD
++=======
+ 
+ out:
+ 	if (q)
+ 		blk_queue_exit(q);
+ 	return ret;
++>>>>>>> 37f9579f4c31 (blk-mq: Avoid that submitting a bio concurrently with device removal triggers a crash)
  }
  EXPORT_SYMBOL(generic_make_request);
  
* Unmerged path block/blk-core.c
