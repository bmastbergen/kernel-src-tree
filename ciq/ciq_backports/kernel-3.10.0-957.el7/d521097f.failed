drm/nouveau/gr/gv100: initial support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ben Skeggs <bskeggs@redhat.com>
commit d521097f58bdfdc9966b8d10754074c8524133dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d521097f.failed

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit d521097f58bdfdc9966b8d10754074c8524133dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/nvkm/engine/device/base.c
#	drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxgf100.c
#	drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c
#	drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.h
#	drivers/gpu/drm/nouveau/nvkm/falcon/msgqueue.c
#	drivers/gpu/drm/nouveau/nvkm/subdev/secboot/gp108.c
diff --cc drivers/gpu/drm/nouveau/nvkm/engine/device/base.c
index 5bc4274cded1,e294013426ce..000000000000
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/base.c
@@@ -2396,12 -2410,28 +2396,20 @@@ nv140_chipset = 
  	.imem = nv50_instmem_new,
  	.ltc = gp102_ltc_new,
  	.mc = gp100_mc_new,
 -	.mmu = gv100_mmu_new,
  	.pci = gp100_pci_new,
  	.pmu = gp102_pmu_new,
+ 	.secboot = gp108_secboot_new,
  	.therm = gp100_therm_new,
  	.timer = gk20a_timer_new,
  	.top = gk104_top_new,
 -	.disp = gv100_disp_new,
 -	.ce[0] = gv100_ce_new,
 -	.ce[1] = gv100_ce_new,
 -	.ce[2] = gv100_ce_new,
 -	.ce[3] = gv100_ce_new,
 -	.ce[4] = gv100_ce_new,
 -	.ce[5] = gv100_ce_new,
 -	.ce[6] = gv100_ce_new,
 -	.ce[7] = gv100_ce_new,
 -	.ce[8] = gv100_ce_new,
  	.dma = gv100_dma_new,
++<<<<<<< HEAD
++=======
+ 	.fifo = gv100_fifo_new,
+ 	.gr = gv100_gr_new,
+ 	.nvdec = gp102_nvdec_new,
+ 	.sec2 = gp102_sec2_new,
++>>>>>>> d521097f58bd (drm/nouveau/gr/gv100: initial support)
  };
  
  static int
diff --cc drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxgf100.c
index 25207b19a53d,f0f5a518e52a..000000000000
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxgf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxgf100.c
@@@ -1502,7 -1452,64 +1506,68 @@@ gf100_grctx_generate(struct gf100_gr *g
  			break;
  	);
  
++<<<<<<< HEAD
 +	/* setup default state for mmio list construction */
++=======
+ 	if (grctx->unkn88c)
+ 		grctx->unkn88c(gr, true);
+ 
+ 	/* Reset FECS. */
+ 	nvkm_wr32(device, 0x409614, 0x00000070);
+ 	nvkm_usec(device, 10, NVKM_DELAY);
+ 	nvkm_mask(device, 0x409614, 0x00000700, 0x00000700);
+ 	nvkm_usec(device, 10, NVKM_DELAY);
+ 	nvkm_rd32(device, 0x409614);
+ 
+ 	if (grctx->unkn88c)
+ 		grctx->unkn88c(gr, false);
+ 
+ 	/* NV_PGRAPH_FE_PWR_MODE_AUTO. */
+ 	nvkm_wr32(device, 0x404170, 0x00000010);
+ 
+ 	/* Init SCC RAM. */
+ 	nvkm_wr32(device, 0x40802c, 0x00000001);
+ 
+ 	/* Allocate memory to for a "channel", which we'll use to generate
+ 	 * the default context values.
+ 	 */
+ 	ret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST,
+ 			      0x1000, 0x1000, true, &inst);
+ 	if (ret)
+ 		goto done;
+ 
+ 	ret = nvkm_vmm_new(device, 0, 0, NULL, 0, NULL, "grctx", &vmm);
+ 	if (ret)
+ 		goto done;
+ 
+ 	vmm->debug = subdev->debug;
+ 
+ 	ret = nvkm_vmm_join(vmm, inst);
+ 	if (ret)
+ 		goto done;
+ 
+ 	ret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST,
+ 			      CB_RESERVED + gr->size, 0, true, &data);
+ 	if (ret)
+ 		goto done;
+ 
+ 	ret = nvkm_vmm_get(vmm, 0, nvkm_memory_size(data), &ctx);
+ 	if (ret)
+ 		goto done;
+ 
+ 	ret = nvkm_memory_map(data, 0, vmm, ctx, NULL, 0);
+ 	if (ret)
+ 		goto done;
+ 
+ 
+ 	/* Setup context pointer. */
+ 	nvkm_kmap(inst);
+ 	nvkm_wo32(inst, 0x0210, lower_32_bits(ctx->addr + CB_RESERVED) | 4);
+ 	nvkm_wo32(inst, 0x0214, upper_32_bits(ctx->addr + CB_RESERVED));
+ 	nvkm_done(inst);
+ 
+ 	/* Setup default state for mmio list construction. */
++>>>>>>> d521097f58bd (drm/nouveau/gr/gv100: initial support)
  	info.gr = gr;
  	info.data = gr->mmio_data;
  	info.mmio = gr->mmio_list;
diff --cc drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c
index 6ca9a01b8988,8dd4bd71b4fc..000000000000
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c
@@@ -1960,12 -2097,50 +1960,38 @@@ gf100_gr_init(struct gf100_gr *gr
  		nvkm_wr32(device, GPC_UNIT(gpc, 0x0918), magicgpc918);
  	}
  
++<<<<<<< HEAD
 +	if (device->chipset != 0xd7)
 +		nvkm_wr32(device, GPC_BCAST(0x1bd4), magicgpc918);
++=======
+ 	nvkm_wr32(device, GPC_BCAST(0x1bd4), magicgpc918);
+ }
+ 
+ void
+ gf100_gr_init_vsc_stream_master(struct gf100_gr *gr)
+ {
+ 	struct nvkm_device *device = gr->base.engine.subdev.device;
+ 	nvkm_mask(device, TPC_UNIT(0, 0, 0x05c), 0x00000001, 0x00000001);
+ }
+ 
+ int
+ gf100_gr_init(struct gf100_gr *gr)
+ {
+ 	struct nvkm_device *device = gr->base.engine.subdev.device;
+ 	int gpc, tpc, rop;
+ 
+ 	if (gr->func->init_419bd8)
+ 		gr->func->init_419bd8(gr);
+ 
+ 	gr->func->init_gpc_mmu(gr);
+ 
+ 	if (gr->fuc_sw_nonctx)
+ 		gf100_gr_mmio(gr, gr->fuc_sw_nonctx);
++>>>>>>> d521097f58bd (drm/nouveau/gr/gv100: initial support)
  	else
 -		gf100_gr_mmio(gr, gr->func->mmio);
 -
 -	if (gr->func->init_r405a14)
 -		gr->func->init_r405a14(gr);
 +		nvkm_wr32(device, GPC_BCAST(0x3fd4), magicgpc918);
  
 -	if (gr->func->clkgate_pack)
 -		nvkm_therm_clkgate_init(device->therm, gr->func->clkgate_pack);
 -
 -	if (gr->func->init_bios)
 -		gr->func->init_bios(gr);
 -
 -	gr->func->init_vsc_stream_master(gr);
 -	gr->func->init_zcull(gr);
 -	gr->func->init_num_active_ltcs(gr);
 -	if (gr->func->init_rop_active_fbps)
 -		gr->func->init_rop_active_fbps(gr);
 -	if (gr->func->init_bios_2)
 -		gr->func->init_bios_2(gr);
 -	if (gr->func->init_swdx_pes_mask)
 -		gr->func->init_swdx_pes_mask(gr);
 +	nvkm_wr32(device, GPC_BCAST(0x08ac), nvkm_rd32(device, 0x100800));
  
  	nvkm_wr32(device, 0x400500, 0x00010001);
  
@@@ -2020,9 -2211,13 +2046,12 @@@
  	nvkm_wr32(device, 0x40011c, 0xffffffff);
  	nvkm_wr32(device, 0x400134, 0xffffffff);
  
 -	if (gr->func->init_400054)
 -		gr->func->init_400054(gr);
 +	nvkm_wr32(device, 0x400054, 0x34ce3464);
  
  	gf100_gr_zbc_init(gr);
+ 
+ 	if (gr->func->init_4188a4)
+ 		gr->func->init_4188a4(gr);
  
  	return gf100_gr_init_ctxctl(gr);
  }
diff --cc drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.h
index 1031f03e3a1f,dc46cf0131db..000000000000
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.h
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.h
@@@ -121,14 -136,43 +121,24 @@@ int gf100_gr_new_(const struct gf100_gr
  		  int, struct nvkm_gr **);
  void *gf100_gr_dtor(struct nvkm_gr *);
  
 -struct gf100_gr_func_zbc {
 -	void (*clear_color)(struct gf100_gr *, int zbc);
 -	void (*clear_depth)(struct gf100_gr *, int zbc);
 -	int (*stencil_get)(struct gf100_gr *, int format,
 -			   const u32 ds, const u32 l2);
 -	void (*clear_stencil)(struct gf100_gr *, int zbc);
 -};
 -
  struct gf100_gr_func {
  	void (*dtor)(struct gf100_gr *);
 -	void (*oneinit_tiles)(struct gf100_gr *);
 -	void (*oneinit_sm_id)(struct gf100_gr *);
  	int (*init)(struct gf100_gr *);
+ 	void (*init_419bd8)(struct gf100_gr *);
  	void (*init_gpc_mmu)(struct gf100_gr *);
 -	void (*init_r405a14)(struct gf100_gr *);
 -	void (*init_bios)(struct gf100_gr *);
 -	void (*init_vsc_stream_master)(struct gf100_gr *);
 -	void (*init_zcull)(struct gf100_gr *);
 -	void (*init_num_active_ltcs)(struct gf100_gr *);
  	void (*init_rop_active_fbps)(struct gf100_gr *);
 -	void (*init_bios_2)(struct gf100_gr *);
 -	void (*init_swdx_pes_mask)(struct gf100_gr *);
 -	void (*init_fecs_exceptions)(struct gf100_gr *);
 -	void (*init_ds_hww_esr_2)(struct gf100_gr *);
 -	void (*init_40601c)(struct gf100_gr *);
 -	void (*init_sked_hww_esr)(struct gf100_gr *);
 -	void (*init_419cc0)(struct gf100_gr *);
 -	void (*init_419eb4)(struct gf100_gr *);
 -	void (*init_419c9c)(struct gf100_gr *);
  	void (*init_ppc_exceptions)(struct gf100_gr *);
++<<<<<<< HEAD
 +	void (*init_swdx_pes_mask)(struct gf100_gr *);
 +	void (*init_num_active_ltcs)(struct gf100_gr *);
++=======
+ 	void (*init_tex_hww_esr)(struct gf100_gr *, int gpc, int tpc);
+ 	void (*init_504430)(struct gf100_gr *, int gpc, int tpc);
+ 	void (*init_shader_exceptions)(struct gf100_gr *, int gpc, int tpc);
+ 	void (*init_400054)(struct gf100_gr *);
+ 	void (*init_4188a4)(struct gf100_gr *);
+ 	void (*trap_mp)(struct gf100_gr *, int gpc, int tpc);
++>>>>>>> d521097f58bd (drm/nouveau/gr/gv100: initial support)
  	void (*set_hww_esr_report_mask)(struct gf100_gr *);
  	const struct gf100_gr_pack *mmio;
  	struct {
@@@ -258,6 -337,10 +268,13 @@@ extern const struct gf100_gr_init gf100
  extern const struct gf100_gr_init gf100_gr_init_be_0[];
  extern const struct gf100_gr_init gf100_gr_init_fe_1[];
  extern const struct gf100_gr_init gf100_gr_init_pe_1[];
++<<<<<<< HEAD
++=======
+ void gf100_gr_init_gpc_mmu(struct gf100_gr *);
+ void gf100_gr_trap_mp(struct gf100_gr *, int, int);
+ extern const struct nvkm_bitfield gf100_mp_global_error[];
+ extern const struct nvkm_enum gf100_mp_warp_error[];
++>>>>>>> d521097f58bd (drm/nouveau/gr/gv100: initial support)
  
  extern const struct gf100_gr_init gf104_gr_init_ds_0[];
  extern const struct gf100_gr_init gf104_gr_init_tex_0[];
diff --cc drivers/gpu/drm/nouveau/nvkm/falcon/msgqueue.c
index 77273b53672c,771e16a16267..000000000000
--- a/drivers/gpu/drm/nouveau/nvkm/falcon/msgqueue.c
+++ b/drivers/gpu/drm/nouveau/nvkm/falcon/msgqueue.c
@@@ -505,6 -505,8 +505,11 @@@ nvkm_msgqueue_new(u32 version, struct n
  		ret = msgqueue_0137bca5_new(falcon, sb, queue);
  		break;
  	case 0x0148cdec:
++<<<<<<< HEAD
++=======
+ 	case 0x015ccf3e:
+ 	case 0x0167d263:
++>>>>>>> d521097f58bd (drm/nouveau/gr/gv100: initial support)
  		ret = msgqueue_0148cdec_new(falcon, sb, queue);
  		break;
  	default:
* Unmerged path drivers/gpu/drm/nouveau/nvkm/subdev/secboot/gp108.c
diff --git a/drivers/gpu/drm/nouveau/include/nvif/class.h b/drivers/gpu/drm/nouveau/include/nvif/class.h
index d08da82ba7ed..142263d4c602 100644
--- a/drivers/gpu/drm/nouveau/include/nvif/class.h
+++ b/drivers/gpu/drm/nouveau/include/nvif/class.h
@@ -127,6 +127,8 @@
 #define PASCAL_A                                      /* cl9097.h */ 0x0000c097
 #define PASCAL_B                                      /* cl9097.h */ 0x0000c197
 
+#define VOLTA_A                                       /* cl9097.h */ 0x0000c397
+
 #define NV74_BSP                                                     0x000074b0
 
 #define GT212_MSVLD                                                  0x000085b1
@@ -165,6 +167,7 @@
 #define MAXWELL_COMPUTE_B                                            0x0000b1c0
 #define PASCAL_COMPUTE_A                                             0x0000c0c0
 #define PASCAL_COMPUTE_B                                             0x0000c1c0
+#define VOLTA_COMPUTE_A                                              0x0000c3c0
 
 #define NV74_CIPHER                                                  0x000074c1
 #endif
diff --git a/drivers/gpu/drm/nouveau/include/nvkm/engine/gr.h b/drivers/gpu/drm/nouveau/include/nvkm/engine/gr.h
index 9787d38857b8..6b61cbcd00d9 100644
--- a/drivers/gpu/drm/nouveau/include/nvkm/engine/gr.h
+++ b/drivers/gpu/drm/nouveau/include/nvkm/engine/gr.h
@@ -47,4 +47,5 @@ int gp102_gr_new(struct nvkm_device *, int, struct nvkm_gr **);
 int gp104_gr_new(struct nvkm_device *, int, struct nvkm_gr **);
 int gp107_gr_new(struct nvkm_device *, int, struct nvkm_gr **);
 int gp10b_gr_new(struct nvkm_device *, int, struct nvkm_gr **);
+int gv100_gr_new(struct nvkm_device *, int, struct nvkm_gr **);
 #endif
* Unmerged path drivers/gpu/drm/nouveau/nvkm/engine/device/base.c
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/Kbuild b/drivers/gpu/drm/nouveau/nvkm/engine/gr/Kbuild
index 42342b4a9abe..93e3733f54e2 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/Kbuild
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/Kbuild
@@ -36,6 +36,7 @@ nvkm-y += nvkm/engine/gr/gp102.o
 nvkm-y += nvkm/engine/gr/gp104.o
 nvkm-y += nvkm/engine/gr/gp107.o
 nvkm-y += nvkm/engine/gr/gp10b.o
+nvkm-y += nvkm/engine/gr/gv100.o
 
 nvkm-y += nvkm/engine/gr/ctxnv40.o
 nvkm-y += nvkm/engine/gr/ctxnv50.o
@@ -57,3 +58,4 @@ nvkm-y += nvkm/engine/gr/ctxgp100.o
 nvkm-y += nvkm/engine/gr/ctxgp102.o
 nvkm-y += nvkm/engine/gr/ctxgp104.o
 nvkm-y += nvkm/engine/gr/ctxgp107.o
+nvkm-y += nvkm/engine/gr/ctxgv100.o
* Unmerged path drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxgf100.c
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxgf100.h b/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxgf100.h
index e7a563fa7d4b..ddf4443e955c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxgf100.h
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxgf100.h
@@ -20,6 +20,7 @@ void gf100_grctx_mmio_item(struct gf100_grctx *, u32 addr, u32 data, int s, int)
 #define mmio_wr32(a,b,c) mmio_refn((a), (b), (c),  0, -1)
 
 struct gf100_grctx_func {
+	void (*unkn88c)(struct gf100_gr *, bool on);
 	/* main context generation function */
 	void  (*main)(struct gf100_gr *, struct gf100_grctx *);
 	/* context-specific modify-on-first-load list generation function */
@@ -34,6 +35,7 @@ struct gf100_grctx_func {
 	/* indirect context data, generated with icmds/mthds */
 	const struct gf100_gr_pack *icmd;
 	const struct gf100_gr_pack *mthd;
+	const struct gf100_gr_pack *sw_veid_bundle_init;
 	/* bundle circular buffer */
 	void (*bundle)(struct gf100_grctx *);
 	u32 bundle_size;
@@ -64,6 +66,7 @@ struct gf100_grctx_func {
 	void (*tpc_mask)(struct gf100_gr *);
 	void (*smid_config)(struct gf100_gr *);
 	/* misc other things */
+	void (*r400088)(struct gf100_gr *, bool);
 	void (*r419cb8)(struct gf100_gr *);
 	void (*r418800)(struct gf100_gr *);
 	void (*r419eb0)(struct gf100_gr *);
@@ -146,6 +149,8 @@ extern const struct gf100_grctx_func gp104_grctx;
 
 extern const struct gf100_grctx_func gp107_grctx;
 
+extern const struct gf100_grctx_func gv100_grctx;
+
 /* context init value lists */
 
 extern const struct gf100_gr_pack gf100_grctx_pack_icmd[];
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxgv100.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxgv100.c
new file mode 100644
index 000000000000..0990765ef191
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxgv100.c
@@ -0,0 +1,215 @@
+/*
+ * Copyright 2018 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "ctxgf100.h"
+
+/*******************************************************************************
+ * PGRAPH context implementation
+ ******************************************************************************/
+
+static const struct gf100_gr_init
+gv100_grctx_init_sw_veid_bundle_init_0[] = {
+	{ 0x00001000, 64, 0x00100000, 0x00000008 },
+	{ 0x00000941, 64, 0x00100000, 0x00000000 },
+	{ 0x0000097e, 64, 0x00100000, 0x00000000 },
+	{ 0x0000097f, 64, 0x00100000, 0x00000100 },
+	{ 0x0000035c, 64, 0x00100000, 0x00000000 },
+	{ 0x0000035d, 64, 0x00100000, 0x00000000 },
+	{ 0x00000a08, 64, 0x00100000, 0x00000000 },
+	{ 0x00000a09, 64, 0x00100000, 0x00000000 },
+	{ 0x00000a0a, 64, 0x00100000, 0x00000000 },
+	{ 0x00000352, 64, 0x00100000, 0x00000000 },
+	{ 0x00000353, 64, 0x00100000, 0x00000000 },
+	{ 0x00000358, 64, 0x00100000, 0x00000000 },
+	{ 0x00000359, 64, 0x00100000, 0x00000000 },
+	{ 0x00000370, 64, 0x00100000, 0x00000000 },
+	{ 0x00000371, 64, 0x00100000, 0x00000000 },
+	{ 0x00000372, 64, 0x00100000, 0x000fffff },
+	{ 0x00000366, 64, 0x00100000, 0x00000000 },
+	{ 0x00000367, 64, 0x00100000, 0x00000000 },
+	{ 0x00000368, 64, 0x00100000, 0x00000fff },
+	{ 0x00000623, 64, 0x00100000, 0x00000000 },
+	{ 0x00000624, 64, 0x00100000, 0x00000000 },
+	{ 0x0001e100,  1, 0x00000001, 0x02000001 },
+	{}
+};
+
+static const struct gf100_gr_pack
+gv100_grctx_pack_sw_veid_bundle_init[] = {
+	{ gv100_grctx_init_sw_veid_bundle_init_0 },
+	{}
+};
+
+static void
+gv100_grctx_generate_attrib(struct gf100_grctx *info)
+{
+	struct gf100_gr *gr = info->gr;
+	const struct gf100_grctx_func *grctx = gr->func->grctx;
+	const u32  alpha = grctx->alpha_nr;
+	const u32 attrib = grctx->attrib_nr;
+	const u32   gfxp = grctx->gfxp_nr;
+	const int s = 12;
+	const int max_batches = 0xffff;
+	u32 size = grctx->alpha_nr_max * gr->tpc_total;
+	u32 ao = 0;
+	u32 bo = ao + size;
+	int gpc, ppc, b, n = 0;
+
+	size += grctx->gfxp_nr * gr->tpc_total;
+	size = ((size * 0x20) + 128) & ~127;
+	b = mmio_vram(info, size, (1 << s), false);
+
+	mmio_refn(info, 0x418810, 0x80000000, s, b);
+	mmio_refn(info, 0x419848, 0x10000000, s, b);
+	mmio_refn(info, 0x419c2c, 0x10000000, s, b);
+	mmio_refn(info, 0x419e00, 0x00000000, s, b);
+	mmio_wr32(info, 0x419e04, 0x80000000 | size >> 7);
+	mmio_wr32(info, 0x405830, attrib);
+	mmio_wr32(info, 0x40585c, alpha);
+	mmio_wr32(info, 0x4064c4, ((alpha / 4) << 16) | max_batches);
+
+	for (gpc = 0; gpc < gr->gpc_nr; gpc++) {
+		for (ppc = 0; ppc < gr->ppc_nr[gpc]; ppc++, n++) {
+			const u32 as =  alpha * gr->ppc_tpc_nr[gpc][ppc];
+			const u32 bs = attrib * gr->ppc_tpc_nr[gpc][ppc];
+			const u32 gs =   gfxp * gr->ppc_tpc_nr[gpc][ppc];
+			const u32 u = 0x418ea0 + (n * 0x04);
+			const u32 o = PPC_UNIT(gpc, ppc, 0);
+			if (!(gr->ppc_mask[gpc] & (1 << ppc)))
+				continue;
+			mmio_wr32(info, o + 0xc0, gs);
+			mmio_wr32(info, o + 0xf4, bo);
+			mmio_wr32(info, o + 0xf0, bs);
+			bo += gs;
+			mmio_wr32(info, o + 0xe4, as);
+			mmio_wr32(info, o + 0xf8, ao);
+			ao += grctx->alpha_nr_max * gr->ppc_tpc_nr[gpc][ppc];
+			mmio_wr32(info, u, bs);
+		}
+	}
+
+	mmio_wr32(info, 0x4181e4, 0x00000100);
+	mmio_wr32(info, 0x41befc, 0x00000100);
+}
+
+static void
+gv100_grctx_generate_rop_mapping(struct gf100_gr *gr)
+{
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	u32 data;
+	int i, j;
+
+	/* Pack tile map into register format. */
+	nvkm_wr32(device, 0x418bb8, (gr->tpc_total << 8) |
+				     gr->screen_tile_row_offset);
+	for (i = 0; i < 11; i++) {
+		for (data = 0, j = 0; j < 6; j++)
+			data |= (gr->tile[i * 6 + j] & 0x1f) << (j * 5);
+		nvkm_wr32(device, 0x418b08 + (i * 4), data);
+		nvkm_wr32(device, 0x41bf00 + (i * 4), data);
+		nvkm_wr32(device, 0x40780c + (i * 4), data);
+	}
+
+	/* GPC_BROADCAST.TP_BROADCAST */
+	nvkm_wr32(device, 0x41bfd0, (gr->tpc_total << 8) |
+				     gr->screen_tile_row_offset);
+	for (i = 0, j = 1; i < 5; i++, j += 4) {
+		u8 v19 = (1 << (j + 0)) % gr->tpc_total;
+		u8 v20 = (1 << (j + 1)) % gr->tpc_total;
+		u8 v21 = (1 << (j + 2)) % gr->tpc_total;
+		u8 v22 = (1 << (j + 3)) % gr->tpc_total;
+		nvkm_wr32(device, 0x41bfb0 + (i * 4), (v22 << 24) |
+						      (v21 << 16) |
+						      (v20 <<  8) |
+						       v19);
+	}
+
+	/* UNK78xx */
+	nvkm_wr32(device, 0x4078bc, (gr->tpc_total << 8) |
+				     gr->screen_tile_row_offset);
+}
+
+static void
+gv100_grctx_generate_r400088(struct gf100_gr *gr, bool on)
+{
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	nvkm_mask(device, 0x400088, 0x00060000, on ? 0x00060000 : 0x00000000);
+}
+
+static void
+gv100_grctx_generate_sm_id(struct gf100_gr *gr, int gpc, int tpc, int sm)
+{
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	nvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x608), sm);
+	nvkm_wr32(device, GPC_UNIT(gpc, 0x0c10 + tpc * 4), sm);
+	nvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x088), sm);
+}
+
+static void
+gv100_grctx_generate_unkn(struct gf100_gr *gr)
+{
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	nvkm_mask(device, 0x41980c, 0x00000010, 0x00000010);
+	nvkm_mask(device, 0x41be08, 0x00000004, 0x00000004);
+	nvkm_mask(device, 0x4064c0, 0x80000000, 0x80000000);
+	nvkm_mask(device, 0x405800, 0x08000000, 0x08000000);
+	nvkm_mask(device, 0x419c00, 0x00000008, 0x00000008);
+}
+
+static void
+gv100_grctx_unkn88c(struct gf100_gr *gr, bool on)
+{
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	const u32 mask = 0x00000010, data = on ? mask : 0x00000000;
+	nvkm_mask(device, 0x40988c, mask, data);
+	nvkm_rd32(device, 0x40988c);
+	nvkm_mask(device, 0x41a88c, mask, data);
+	nvkm_rd32(device, 0x41a88c);
+	nvkm_mask(device, 0x408a14, mask, data);
+	nvkm_rd32(device, 0x408a14);
+}
+
+const struct gf100_grctx_func
+gv100_grctx = {
+	.unkn88c = gv100_grctx_unkn88c,
+	.main = gf100_grctx_generate_main,
+	.unkn = gv100_grctx_generate_unkn,
+	.sw_veid_bundle_init = gv100_grctx_pack_sw_veid_bundle_init,
+	.bundle = gm107_grctx_generate_bundle,
+	.bundle_size = 0x3000,
+	.bundle_min_gpm_fifo_depth = 0x180,
+	.bundle_token_limit = 0x1680,
+	.pagepool = gp100_grctx_generate_pagepool,
+	.pagepool_size = 0x20000,
+	.attrib = gv100_grctx_generate_attrib,
+	.attrib_nr_max = 0x6c0,
+	.attrib_nr = 0x480,
+	.alpha_nr_max = 0xc00,
+	.alpha_nr = 0x800,
+	.gfxp_nr = 0xd10,
+	.sm_id = gv100_grctx_generate_sm_id,
+	.rop_mapping = gv100_grctx_generate_rop_mapping,
+	.dist_skip_table = gm200_grctx_generate_dist_skip_table,
+	.r406500 = gm200_grctx_generate_r406500,
+	.gpc_tpc_nr = gk104_grctx_generate_gpc_tpc_nr,
+	.smid_config = gp100_grctx_generate_smid_config,
+	.r400088 = gv100_grctx_generate_r400088,
+};
* Unmerged path drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c
* Unmerged path drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.h
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gv100.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gv100.c
new file mode 100644
index 000000000000..19173ea19096
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gv100.c
@@ -0,0 +1,120 @@
+/*
+ * Copyright 2018 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "gf100.h"
+#include "ctxgf100.h"
+
+#include <nvif/class.h>
+
+static void
+gv100_gr_trap_mp(struct gf100_gr *gr, int gpc, int tpc)
+{
+	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
+	u32 werr = nvkm_rd32(device, TPC_UNIT(gpc, tpc, 0x730));
+	u32 gerr = nvkm_rd32(device, TPC_UNIT(gpc, tpc, 0x734));
+	const struct nvkm_enum *warp;
+	char glob[128];
+
+	nvkm_snprintbf(glob, sizeof(glob), gf100_mp_global_error, gerr);
+	warp = nvkm_enum_find(gf100_mp_warp_error, werr & 0xffff);
+
+	nvkm_error(subdev, "GPC%i/TPC%i/MP trap: "
+			   "global %08x [%s] warp %04x [%s]\n",
+		   gpc, tpc, gerr, glob, werr, warp ? warp->name : "");
+
+	nvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x730), 0x00000000);
+	nvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x734), gerr);
+}
+
+static void
+gv100_gr_init_4188a4(struct gf100_gr *gr)
+{
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	nvkm_mask(device, 0x4188a4, 0x03000000, 0x03000000);
+}
+
+static void
+gv100_gr_init_shader_exceptions(struct gf100_gr *gr, int gpc, int tpc)
+{
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	int sm;
+	for (sm = 0; sm < 0x100; sm += 0x80) {
+		nvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x728 + sm), 0x0085eb64);
+		nvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x610), 0x00000001);
+		nvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x72c + sm), 0x00000004);
+	}
+}
+
+static void
+gv100_gr_init_504430(struct gf100_gr *gr, int gpc, int tpc)
+{
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	nvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x430), 0x403f0000);
+}
+
+static void
+gv100_gr_init_419bd8(struct gf100_gr *gr)
+{
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	nvkm_mask(device, 0x419bd8, 0x00000700, 0x00000000);
+}
+
+static const struct gf100_gr_func
+gv100_gr = {
+	.oneinit_tiles = gm200_gr_oneinit_tiles,
+	.oneinit_sm_id = gm200_gr_oneinit_sm_id,
+	.init = gf100_gr_init,
+	.init_419bd8 = gv100_gr_init_419bd8,
+	.init_gpc_mmu = gm200_gr_init_gpc_mmu,
+	.init_vsc_stream_master = gk104_gr_init_vsc_stream_master,
+	.init_zcull = gf117_gr_init_zcull,
+	.init_num_active_ltcs = gm200_gr_init_num_active_ltcs,
+	.init_rop_active_fbps = gp100_gr_init_rop_active_fbps,
+	.init_swdx_pes_mask = gp102_gr_init_swdx_pes_mask,
+	.init_fecs_exceptions = gp100_gr_init_fecs_exceptions,
+	.init_ds_hww_esr_2 = gm200_gr_init_ds_hww_esr_2,
+	.init_sked_hww_esr = gk104_gr_init_sked_hww_esr,
+	.init_ppc_exceptions = gk104_gr_init_ppc_exceptions,
+	.init_504430 = gv100_gr_init_504430,
+	.init_shader_exceptions = gv100_gr_init_shader_exceptions,
+	.init_4188a4 = gv100_gr_init_4188a4,
+	.trap_mp = gv100_gr_trap_mp,
+	.rops = gm200_gr_rops,
+	.gpc_nr = 6,
+	.tpc_nr = 5,
+	.ppc_nr = 3,
+	.grctx = &gv100_grctx,
+	.zbc = &gp102_gr_zbc,
+	.sclass = {
+		{ -1, -1, FERMI_TWOD_A },
+		{ -1, -1, KEPLER_INLINE_TO_MEMORY_B },
+		{ -1, -1, VOLTA_A, &gf100_fermi },
+		{ -1, -1, VOLTA_COMPUTE_A },
+		{}
+	}
+};
+
+int
+gv100_gr_new(struct nvkm_device *device, int index, struct nvkm_gr **pgr)
+{
+	return gm200_gr_new_(&gv100_gr, device, index, pgr);
+}
* Unmerged path drivers/gpu/drm/nouveau/nvkm/falcon/msgqueue.c
* Unmerged path drivers/gpu/drm/nouveau/nvkm/subdev/secboot/gp108.c
