drm/i915/dp: Send DPCD ON for MST before phy_up

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Lyude Paul <lyude@redhat.com>
commit be1c63c8017bb00a4041abace6cc1e9f0bf26aa9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/be1c63c8.failed

When doing a modeset where the sink is transitioning from D3 to D0 , it
would sometimes be possible for the initial power_up_phy() to start
timing out. This would only be observed in the last action before the
sink went into D3 mode was intel_dp_sink_dpms(DRM_MODE_DPMS_OFF). We
originally thought this might be an issue with us accidentally shutting
off the aux block when putting the sink into D3, but since the DP spec
mandates that sinks must wake up within 1ms while we have 100ms to
respond to an ESI irq, this didn't really add up. Turns out that the
problem is more subtle then that:

It turns out that the timeout is from us not enabling DPMS on the MST
hub before actually trying to initiate sideband communications. This
would cause the first sideband communication (power_up_phy()), to start
timing out because the sink wasn't ready to respond. Afterwards, we
would call intel_dp_sink_dpms(DRM_MODE_DPMS_ON) in
intel_ddi_pre_enable_dp(), which would actually result in waking up the
sink so that sideband requests would work again.

Since DPMS is what lets us actually bring the hub up into a state where
sideband communications become functional again, we just need to make
sure to enable DPMS on the display before attempting to perform sideband
communications.

Changes since v1:
- Remove comment above if (!intel_dp->is_mst) - vsryjala
- Move intel_dp_sink_dpms() for MST into intel_dp_post_disable_mst() to
  keep enable/disable paths symmetrical
- Improve commit message - dhnkrn
Changes since v2:
- Only send DPMS off when we're disabling the last sink, and only send
  DPMS on when we're enabling the first sink - dhnkrn
Changes since v3:
- Check against is_mst, not intel_dp->is_mst - dhnkrn/vsyrjala

	Signed-off-by: Lyude Paul <lyude@redhat.com>
	Reviewed-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
	Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
	Tested-by: Laura Abbott <labbott@redhat.com>
	Cc: stable@vger.kernel.org
Fixes: ad260ab32a4d9 ("drm/i915/dp: Write to SET_POWER dpcd to enable MST hub.")
Link: https://patchwork.freedesktop.org/patch/msgid/20180407011053.22437-1-lyude@redhat.com
(cherry picked from commit be1c63c8017bb00a4041abace6cc1e9f0bf26aa9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_ddi.c
#	drivers/gpu/drm/i915/intel_dp_mst.c
diff --cc drivers/gpu/drm/i915/intel_ddi.c
index b21cdcc1d8e7,92cb26b18a9b..000000000000
--- a/drivers/gpu/drm/i915/intel_ddi.c
+++ b/drivers/gpu/drm/i915/intel_ddi.c
@@@ -2163,14 -2317,15 +2163,15 @@@ static void intel_ddi_pre_enable_dp(str
  	intel_display_power_get(dev_priv, dig_port->ddi_io_power_domain);
  
  	if (IS_CANNONLAKE(dev_priv))
 -		cnl_ddi_vswing_sequence(encoder, level, encoder->type);
 +		cnl_ddi_vswing_sequence(encoder, level);
  	else if (IS_GEN9_LP(dev_priv))
 -		bxt_ddi_vswing_sequence(encoder, level, encoder->type);
 +		bxt_ddi_vswing_sequence(dev_priv, level, port, encoder->type);
  	else
 -		intel_prepare_dp_ddi_buffers(encoder, crtc_state);
 +		intel_prepare_dp_ddi_buffers(encoder);
  
  	intel_ddi_init_dp_buf_reg(encoder);
- 	intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_ON);
+ 	if (!is_mst)
+ 		intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_ON);
  	intel_dp_start_link_train(intel_dp);
  	if (port != PORT_A || INTEL_GEN(dev_priv) >= 9)
  		intel_dp_stop_link_train(intel_dp);
@@@ -2266,29 -2414,78 +2267,48 @@@ static void intel_ddi_post_disable(stru
  
  	if (wait)
  		intel_wait_ddi_buf_idle(dev_priv, port);
 -}
  
++<<<<<<< HEAD
 +	if (intel_dp) {
 +		intel_edp_panel_vdd_on(intel_dp);
 +		intel_edp_panel_off(intel_dp);
 +	}
 +
 +	if (dig_port)
 +		intel_display_power_put(dev_priv, dig_port->ddi_io_power_domain);
++=======
+ static void intel_ddi_post_disable_dp(struct intel_encoder *encoder,
+ 				      const struct intel_crtc_state *old_crtc_state,
+ 				      const struct drm_connector_state *old_conn_state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
+ 	struct intel_digital_port *dig_port = enc_to_dig_port(&encoder->base);
+ 	struct intel_dp *intel_dp = &dig_port->dp;
+ 	bool is_mst = intel_crtc_has_type(old_crtc_state,
+ 					  INTEL_OUTPUT_DP_MST);
+ 
+ 	/*
+ 	 * Power down sink before disabling the port, otherwise we end
+ 	 * up getting interrupts from the sink on detecting link loss.
+ 	 */
+ 	if (!is_mst)
+ 		intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_OFF);
++>>>>>>> be1c63c8017b (drm/i915/dp: Send DPCD ON for MST before phy_up)
  
 -	intel_disable_ddi_buf(encoder);
 -
 -	intel_edp_panel_vdd_on(intel_dp);
 -	intel_edp_panel_off(intel_dp);
 -
 -	intel_display_power_put(dev_priv, dig_port->ddi_io_power_domain);
 -
 -	intel_ddi_clk_disable(encoder);
 -}
 -
 -static void intel_ddi_post_disable_hdmi(struct intel_encoder *encoder,
 -					const struct intel_crtc_state *old_crtc_state,
 -					const struct drm_connector_state *old_conn_state)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 -	struct intel_digital_port *dig_port = enc_to_dig_port(&encoder->base);
 -	struct intel_hdmi *intel_hdmi = &dig_port->hdmi;
 -
 -	intel_disable_ddi_buf(encoder);
 -
 -	dig_port->set_infoframes(&encoder->base, false,
 -				 old_crtc_state, old_conn_state);
 -
 -	intel_display_power_put(dev_priv, dig_port->ddi_io_power_domain);
 -
 -	intel_ddi_clk_disable(encoder);
 -
 -	intel_dp_dual_mode_set_tmds_output(intel_hdmi, false);
 -}
 +	if (IS_CANNONLAKE(dev_priv))
 +		I915_WRITE(DPCLKA_CFGCR0, I915_READ(DPCLKA_CFGCR0) |
 +			   DPCLKA_CFGCR0_DDI_CLK_OFF(port));
 +	else if (IS_GEN9_BC(dev_priv))
 +		I915_WRITE(DPLL_CTRL2, (I915_READ(DPLL_CTRL2) |
 +					DPLL_CTRL2_DDI_CLK_OFF(port)));
 +	else if (INTEL_GEN(dev_priv) < 9)
 +		I915_WRITE(PORT_CLK_SEL(port), PORT_CLK_SEL_NONE);
  
 -static void intel_ddi_post_disable(struct intel_encoder *encoder,
 -				   const struct intel_crtc_state *old_crtc_state,
 -				   const struct drm_connector_state *old_conn_state)
 -{
 -	/*
 -	 * When called from DP MST code:
 -	 * - old_conn_state will be NULL
 -	 * - encoder will be the main encoder (ie. mst->primary)
 -	 * - the main connector associated with this port
 -	 *   won't be active or linked to a crtc
 -	 * - old_crtc_state will be the state of the last stream to
 -	 *   be deactivated on this port, and it may not be the same
 -	 *   stream that was activated last, but each stream
 -	 *   should have a state that is identical when it comes to
 -	 *   the DP link parameteres
 -	 */
 +	if (type == INTEL_OUTPUT_HDMI) {
 +		struct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);
  
 -	if (intel_crtc_has_type(old_crtc_state, INTEL_OUTPUT_HDMI))
 -		intel_ddi_post_disable_hdmi(encoder,
 -					    old_crtc_state, old_conn_state);
 -	else
 -		intel_ddi_post_disable_dp(encoder,
 -					  old_crtc_state, old_conn_state);
 +		intel_dp_dual_mode_set_tmds_output(intel_hdmi, false);
 +	}
  }
  
  void intel_ddi_fdi_post_disable(struct intel_encoder *encoder,
diff --cc drivers/gpu/drm/i915/intel_dp_mst.c
index 93fc8ab9bb31,9e6956c08688..000000000000
--- a/drivers/gpu/drm/i915/intel_dp_mst.c
+++ b/drivers/gpu/drm/i915/intel_dp_mst.c
@@@ -168,11 -181,26 +168,18 @@@ static void intel_mst_post_disable_dp(s
  
  	intel_mst->connector = NULL;
  	if (intel_dp->active_mst_links == 0) {
++<<<<<<< HEAD
 +		intel_dig_port->base.post_disable(&intel_dig_port->base,
 +						  NULL, NULL);
++=======
+ 		intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_OFF);
+ 		intel_dig_port->base.post_disable(&intel_dig_port->base,
+ 						  old_crtc_state, NULL);
+ 	}
++>>>>>>> be1c63c8017b (drm/i915/dp: Send DPCD ON for MST before phy_up)
  
 -	DRM_DEBUG_KMS("active links %d\n", intel_dp->active_mst_links);
 -}
 -
 -static void intel_mst_pre_pll_enable_dp(struct intel_encoder *encoder,
 -					const struct intel_crtc_state *pipe_config,
 -					const struct drm_connector_state *conn_state)
 -{
 -	struct intel_dp_mst_encoder *intel_mst = enc_to_mst(&encoder->base);
 -	struct intel_digital_port *intel_dig_port = intel_mst->primary;
 -	struct intel_dp *intel_dp = &intel_dig_port->dp;
 -
 -	if (intel_dp->active_mst_links == 0 &&
 -	    intel_dig_port->base.pre_pll_enable)
 -		intel_dig_port->base.pre_pll_enable(&intel_dig_port->base,
 -						    pipe_config, NULL);
 +		intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_OFF);
 +	}
  }
  
  static void intel_mst_pre_enable_dp(struct intel_encoder *encoder,
@@@ -195,8 -223,13 +202,16 @@@
  	connector->encoder = encoder;
  	intel_mst->connector = connector;
  
 -	DRM_DEBUG_KMS("active links %d\n", intel_dp->active_mst_links);
 +	DRM_DEBUG_KMS("%d\n", intel_dp->active_mst_links);
  
++<<<<<<< HEAD
++=======
+ 	if (intel_dp->active_mst_links == 0)
+ 		intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_ON);
+ 
+ 	drm_dp_send_power_updown_phy(&intel_dp->mst_mgr, connector->port, true);
+ 
++>>>>>>> be1c63c8017b (drm/i915/dp: Send DPCD ON for MST before phy_up)
  	if (intel_dp->active_mst_links == 0)
  		intel_dig_port->base.pre_enable(&intel_dig_port->base,
  						pipe_config, NULL);
* Unmerged path drivers/gpu/drm/i915/intel_ddi.c
* Unmerged path drivers/gpu/drm/i915/intel_dp_mst.c
