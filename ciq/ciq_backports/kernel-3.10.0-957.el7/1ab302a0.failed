ceph: quota: update MDS when max_bytes is approaching

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Luis Henriques <lhenriques@suse.com>
commit 1ab302a0cb1455631646aa66b7fc02afd617ea4f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1ab302a0.failed

When we're reaching the ceph.quota.max_bytes limit, i.e., when writing
more than 1/16th of the space left in a quota realm, update the MDS with
the new file size.

This mirrors the fuse-client approach with commit 122c50315ed1 ("client:
Inform mds file size when approaching quota limit"), in the ceph git tree.

	Signed-off-by: Luis Henriques <lhenriques@suse.com>
	Reviewed-by: "Yan, Zheng" <zyan@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 1ab302a0cb1455631646aa66b7fc02afd617ea4f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/quota.c
#	fs/ceph/super.h
diff --cc fs/ceph/super.h
index 2ea6359d8d08,e4ff485d24c7..000000000000
--- a/fs/ceph/super.h
+++ b/fs/ceph/super.h
@@@ -1022,4 -1073,15 +1022,18 @@@ extern int lock_to_ceph_filelock(struc
  extern int ceph_fs_debugfs_init(struct ceph_fs_client *client);
  extern void ceph_fs_debugfs_cleanup(struct ceph_fs_client *client);
  
++<<<<<<< HEAD
++=======
+ /* quota.c */
+ extern void ceph_handle_quota(struct ceph_mds_client *mdsc,
+ 			      struct ceph_mds_session *session,
+ 			      struct ceph_msg *msg);
+ extern bool ceph_quota_is_max_files_exceeded(struct inode *inode);
+ extern bool ceph_quota_is_same_realm(struct inode *old, struct inode *new);
+ extern bool ceph_quota_is_max_bytes_exceeded(struct inode *inode,
+ 					     loff_t newlen);
+ extern bool ceph_quota_is_max_bytes_approaching(struct inode *inode,
+ 						loff_t newlen);
+ 
++>>>>>>> 1ab302a0cb14 (ceph: quota: update MDS when max_bytes is approaching)
  #endif /* _FS_CEPH_SUPER_H */
* Unmerged path fs/ceph/quota.c
diff --git a/fs/ceph/file.c b/fs/ceph/file.c
index 7fa7d870dbaf..5331215cf33c 100644
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@ -1478,6 +1478,7 @@ retry_snap:
 
 	if (written >= 0) {
 		int dirty;
+
 		spin_lock(&ci->i_ceph_lock);
 		ci->i_inline_version = CEPH_INLINE_NONE;
 		dirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_FILE_WR,
@@ -1485,6 +1486,8 @@ retry_snap:
 		spin_unlock(&ci->i_ceph_lock);
 		if (dirty)
 			__mark_inode_dirty(inode, dirty);
+		if (ceph_quota_is_max_bytes_approaching(inode, iocb->ki_pos))
+			ceph_check_caps(ci, CHECK_CAPS_NODELAY, NULL);
 	}
 
 	dout("aio_write %p %llx.%llx %llu~%u  dropping cap refs on %s\n",
@@ -1777,6 +1780,9 @@ static long ceph_fallocate(struct file *file, int mode,
 		spin_unlock(&ci->i_ceph_lock);
 		if (dirty)
 			__mark_inode_dirty(inode, dirty);
+		if ((endoff > size) &&
+		    ceph_quota_is_max_bytes_approaching(inode, endoff))
+			ceph_check_caps(ci, CHECK_CAPS_NODELAY, NULL);
 	}
 
 	ceph_put_cap_refs(ci, got);
* Unmerged path fs/ceph/quota.c
* Unmerged path fs/ceph/super.h
