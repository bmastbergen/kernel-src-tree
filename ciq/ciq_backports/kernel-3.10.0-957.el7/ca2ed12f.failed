HID: hid-sensor-hub: Processing for duplicate physical ids

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [hid] hid-sensor-hub: Processing for duplicate physical ids (Tony Camuso) [1559170]
Rebuild_FUZZ: 95.50%
commit-author Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
commit ca2ed12f163bf430a425ec725ef76df5254b9f45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ca2ed12f.failed

In HID sensor hub, HID physical ids are used to represent different sensors.
For example physical id of 0x73 in usage page = 0x20, represents an
accelerometer. The HID sensor hub driver uses this physical ids to create
platform devices using MFD. There is 1:1 correspondence between an phy id and a
client driver.

But in some cases these physical ids are reused. There is a phy id 0xe1, which
specifies a custom sensor, which can exist multiple times to represent various
custom sensors. In this case there can be multiple instances of client MFD
drivers, processing specific custom sensor. In this case when client driver
looks for report id or a field index, it should still get the report id
specific to its own type. This is also true for reports, they should be
directed towards correct instance.  This change introduce a way to parse and
tie physical devices to their correct instance.

Summary of changes:
- To get physical ids, use collections. If a collection of type=physical
  exist then use usage id as in the name of platform device name
- As part of the platform data, we assign a hdsev instance, which has
  start and end of collection indexes. Using these indexes attributes
  can be tied to correct MFD client instances
- When a report is received, call callback with correct hsdev instance.
  In this way using its private data stored as part of its registry, it
  can distinguish different sensors even when they have same physical and
  logical ids.

  This patch is co-authored with Archana Patni <archna.patni@intel.com>.

	Reported-by: Archana Patni <archana.patni@intel.com>
	Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Signed-off-by: Archana Patni <archana.patni@intel.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit ca2ed12f163bf430a425ec725ef76df5254b9f45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/hid-sensor-hub.c
diff --cc drivers/hid/hid-sensor-hub.c
index ec7cae7d2cb8,5ab93cb18b88..000000000000
--- a/drivers/hid/hid-sensor-hub.c
+++ b/drivers/hid/hid-sensor-hub.c
@@@ -65,6 -66,8 +65,11 @@@ struct sensor_hub_data 
  	spinlock_t dyn_callback_lock;
  	struct mfd_cell *hid_sensor_hub_client_devs;
  	int hid_sensor_client_cnt;
++<<<<<<< HEAD
++=======
+ 	unsigned long quirks;
+ 	int ref_cnt;
++>>>>>>> ca2ed12f163b (HID: hid-sensor-hub: Processing for duplicate physical ids)
  };
  
  /**
@@@ -95,21 -99,18 +101,26 @@@ static struct hid_report *sensor_hub_re
  	return NULL;
  }
  
- static int sensor_hub_get_physical_device_count(
- 				struct hid_report_enum *report_enum)
+ static int sensor_hub_get_physical_device_count(struct hid_device *hdev)
  {
- 	struct hid_report *report;
- 	struct hid_field *field;
- 	int cnt = 0;
+ 	int i;
+ 	int count = 0;
  
++<<<<<<< HEAD
 +	list_for_each_entry(report, &report_enum->report_list, list) {
 +		field = report->field[0];
 +		if (report->maxfield && field &&
 +					field->physical)
 +			cnt++;
++=======
+ 	for (i = 0; i < hdev->maxcollection; ++i) {
+ 		struct hid_collection *collection = &hdev->collection[i];
+ 		if (collection->type == HID_COLLECTION_PHYSICAL)
+ 			++count;
++>>>>>>> ca2ed12f163b (HID: hid-sensor-hub: Processing for duplicate physical ids)
  	}
  
- 	return cnt;
+ 	return count;
  }
  
  static void sensor_hub_fill_attr_info(
@@@ -355,30 -349,27 +366,46 @@@ int sensor_hub_input_get_attribute_info
  	list_for_each_entry(report, &report_enum->report_list, list) {
  		for (i = 0; i < report->maxfield; ++i) {
  			field = report->field[i];
++<<<<<<< HEAD
 +			if (field->physical == usage_id &&
 +				field->logical == attr_usage_id) {
 +				sensor_hub_fill_attr_info(info, i, report->id,
 +							  field);
 +				ret = 0;
 +			} else {
 +				for (j = 0; j < field->maxusage; ++j) {
 +					if (field->usage[j].hid ==
 +					attr_usage_id &&
 +					field->usage[j].collection_index ==
 +					collection_index)  {
 +						sensor_hub_fill_attr_info(info,
 +							  i, report->id, field);
 +						ret = 0;
 +						break;
 +					}
++=======
+ 			if (field->maxusage) {
+ 				if (field->physical == usage_id &&
+ 					(field->logical == attr_usage_id ||
+ 					field->usage[0].hid ==
+ 							attr_usage_id) &&
+ 					(field->usage[0].collection_index >=
+ 					hsdev->start_collection_index) &&
+ 					(field->usage[0].collection_index <
+ 					hsdev->end_collection_index)) {
+ 
+ 					sensor_hub_fill_attr_info(info, i,
+ 								report->id,
+ 								field);
+ 					ret = 0;
+ 					break;
++>>>>>>> ca2ed12f163b (HID: hid-sensor-hub: Processing for duplicate physical ids)
  				}
  			}
- 			if (ret == 0)
- 				break;
  		}
+ 
  	}
  
- err_ret:
  	return ret;
  }
  EXPORT_SYMBOL_GPL(sensor_hub_input_get_attribute_info);
@@@ -546,15 -573,10 +576,16 @@@ static int sensor_hub_probe(struct hid_
  		hid_err(hdev, "cannot allocate Sensor data\n");
  		return -ENOMEM;
  	}
- 	sd->hsdev = devm_kzalloc(&hdev->dev, sizeof(*sd->hsdev), GFP_KERNEL);
- 	if (!sd->hsdev) {
- 		hid_err(hdev, "cannot allocate hid_sensor_hub_device\n");
- 		return -ENOMEM;
- 	}
+ 
  	hid_set_drvdata(hdev, sd);
++<<<<<<< HEAD
 +	sd->hsdev->hdev = hdev;
 +	sd->hsdev->vendor_id = hdev->vendor;
 +	sd->hsdev->product_id = hdev->product;
++=======
+ 	sd->quirks = id->driver_data;
+ 
++>>>>>>> ca2ed12f163b (HID: hid-sensor-hub: Processing for duplicate physical ids)
  	spin_lock_init(&sd->lock);
  	spin_lock_init(&sd->dyn_callback_lock);
  	mutex_init(&sd->mutex);
@@@ -588,20 -609,35 +618,40 @@@
  			ret = -ENOMEM;
  			goto err_stop_hw;
  	}
- 	list_for_each_entry(report, &report_enum->report_list, list) {
- 		hid_dbg(hdev, "Report id:%x\n", report->id);
- 		field = report->field[0];
- 		if (report->maxfield && field &&
- 					field->physical) {
+ 
+ 	for (i = 0; i < hdev->maxcollection; ++i) {
+ 		struct hid_collection *collection = &hdev->collection[i];
+ 
+ 		if (collection->type == HID_COLLECTION_PHYSICAL) {
+ 
+ 			hsdev = kzalloc(sizeof(*hsdev), GFP_KERNEL);
+ 			if (!hsdev) {
+ 				hid_err(hdev, "cannot allocate hid_sensor_hub_device\n");
+ 				ret = -ENOMEM;
+ 				goto err_no_mem;
+ 			}
+ 			hsdev->hdev = hdev;
+ 			hsdev->vendor_id = hdev->vendor;
+ 			hsdev->product_id = hdev->product;
+ 			hsdev->start_collection_index = i;
+ 			if (last_hsdev)
+ 				last_hsdev->end_collection_index = i;
+ 			last_hsdev = hsdev;
  			name = kasprintf(GFP_KERNEL, "HID-SENSOR-%x",
++<<<<<<< HEAD
 +						field->physical);
 +			if (name  == NULL) {
++=======
+ 					collection->usage);
+ 			if (name == NULL) {
++>>>>>>> ca2ed12f163b (HID: hid-sensor-hub: Processing for duplicate physical ids)
  				hid_err(hdev, "Failed MFD device name\n");
  					ret = -ENOMEM;
- 					goto err_free_names;
+ 					goto err_no_mem;
  			}
  			sd->hid_sensor_hub_client_devs[
- 				sd->hid_sensor_client_cnt].id = PLATFORM_DEVID_AUTO;
+ 				sd->hid_sensor_client_cnt].id =
+ 							PLATFORM_DEVID_AUTO;
  			sd->hid_sensor_hub_client_devs[
  				sd->hid_sensor_client_cnt].name = name;
  			sd->hid_sensor_hub_client_devs[
* Unmerged path drivers/hid/hid-sensor-hub.c
diff --git a/include/linux/hid-sensor-hub.h b/include/linux/hid-sensor-hub.h
index 174b5af950eb..d160f9386051 100644
--- a/include/linux/hid-sensor-hub.h
+++ b/include/linux/hid-sensor-hub.h
@@ -51,13 +51,15 @@ struct hid_sensor_hub_attribute_info {
  * @hdev:		Stores the hid instance.
  * @vendor_id:		Vendor id of hub device.
  * @product_id:		Product id of hub device.
- * @ref_cnt:		Number of MFD clients have opened this device
+ * @start_collection_index: Starting index for a phy type collection
+ * @end_collection_index: Last index for a phy type collection
  */
 struct hid_sensor_hub_device {
 	struct hid_device *hdev;
 	u32 vendor_id;
 	u32 product_id;
-	int ref_cnt;
+	int start_collection_index;
+	int end_collection_index;
 };
 
 /**
