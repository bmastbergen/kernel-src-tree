platform/x86: wmi: Split devices into types and add basic sysfs attributes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [platform] x86: wmi: Split devices into types and add basic sysfs attributes (Jarod Wilson) [1562200]
Rebuild_FUZZ: 93.53%
commit-author Andy Lutomirski <luto@kernel.org>
commit d79b10740210c6c686a9256b801e08f7679e04e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d79b1074.failed

Divide the "data", "method" and "event" types. All devices get
"instance_count" and "expensive" attributes, data and method devices get
"object_id" attributes, and event devices get "notify_id" attributes.

	Signed-off-by: Andy Lutomirski <luto@kernel.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Mario Limonciello <mario_limonciello@dell.com>
	Cc: Pali Roh√°r <pali.rohar@gmail.com>
	Cc: linux-kernel@vger.kernel.org
	Cc: platform-driver-x86@vger.kernel.org
	Cc: linux-acpi@vger.kernel.org
	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>
(cherry picked from commit d79b10740210c6c686a9256b801e08f7679e04e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/platform/x86/wmi.c
diff --cc drivers/platform/x86/wmi.c
index 84dcc7a04b0a,33a3609d54db..000000000000
--- a/drivers/platform/x86/wmi.c
+++ b/drivers/platform/x86/wmi.c
@@@ -643,59 -566,200 +643,159 @@@ static ssize_t modalias_show(struct dev
  }
  static DEVICE_ATTR_RO(modalias);
  
++<<<<<<< HEAD
 +static struct attribute *wmi_attrs[] = {
 +	&dev_attr_modalias.attr,
++=======
+ static ssize_t guid_show(struct device *dev, struct device_attribute *attr,
+ 			 char *buf)
+ {
+ 	struct wmi_block *wblock = dev_to_wblock(dev);
+ 
+ 	return sprintf(buf, "%pUL\n", wblock->gblock.guid);
+ }
+ static DEVICE_ATTR_RO(guid);
+ 
+ static ssize_t instance_count_show(struct device *dev,
+ 				   struct device_attribute *attr, char *buf)
+ {
+ 	struct wmi_block *wblock = dev_to_wblock(dev);
+ 
+ 	return sprintf(buf, "%d\n", (int)wblock->gblock.instance_count);
+ }
+ static DEVICE_ATTR_RO(instance_count);
+ 
+ static ssize_t expensive_show(struct device *dev,
+ 			      struct device_attribute *attr, char *buf)
+ {
+ 	struct wmi_block *wblock = dev_to_wblock(dev);
+ 
+ 	return sprintf(buf, "%d\n",
+ 		       (wblock->gblock.flags & ACPI_WMI_EXPENSIVE) != 0);
+ }
+ static DEVICE_ATTR_RO(expensive);
+ 
+ static struct attribute *wmi_attrs[] = {
+ 	&dev_attr_modalias.attr,
+ 	&dev_attr_guid.attr,
+ 	&dev_attr_instance_count.attr,
+ 	&dev_attr_expensive.attr,
++>>>>>>> d79b10740210 (platform/x86: wmi: Split devices into types and add basic sysfs attributes)
  	NULL,
  };
  ATTRIBUTE_GROUPS(wmi);
  
+ static ssize_t notify_id_show(struct device *dev, struct device_attribute *attr,
+ 			      char *buf)
+ {
+ 	struct wmi_block *wblock = dev_to_wblock(dev);
+ 
+ 	return sprintf(buf, "%02X\n", (unsigned int)wblock->gblock.notify_id);
+ }
+ static DEVICE_ATTR_RO(notify_id);
+ 
+ static struct attribute *wmi_event_attrs[] = {
+ 	&dev_attr_notify_id.attr,
+ 	NULL,
+ };
+ ATTRIBUTE_GROUPS(wmi_event);
+ 
+ static ssize_t object_id_show(struct device *dev, struct device_attribute *attr,
+ 			      char *buf)
+ {
+ 	struct wmi_block *wblock = dev_to_wblock(dev);
+ 
+ 	return sprintf(buf, "%c%c\n", wblock->gblock.object_id[0],
+ 		       wblock->gblock.object_id[1]);
+ }
+ static DEVICE_ATTR_RO(object_id);
+ 
+ static struct attribute *wmi_data_or_method_attrs[] = {
+ 	&dev_attr_object_id.attr,
+ 	NULL,
+ };
+ ATTRIBUTE_GROUPS(wmi_data_or_method);
+ 
  static int wmi_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
  {
 -	struct wmi_block *wblock = dev_to_wblock(dev);
 +	char guid_string[37];
  
 -	if (add_uevent_var(env, "MODALIAS=wmi:%pUL", wblock->gblock.guid))
 -		return -ENOMEM;
 +	struct wmi_block *wblock;
  
 -	if (add_uevent_var(env, "WMI_GUID=%pUL", wblock->gblock.guid))
 +	if (add_uevent_var(env, "MODALIAS="))
  		return -ENOMEM;
  
 -	return 0;
 -}
 -
 -static void wmi_dev_release(struct device *dev)
 -{
 -	struct wmi_block *wblock = dev_to_wblock(dev);
 -
 -	kfree(wblock);
 -}
 -
 -static int wmi_dev_match(struct device *dev, struct device_driver *driver)
 -{
 -	struct wmi_driver *wmi_driver =
 -		container_of(driver, struct wmi_driver, driver);
 -	struct wmi_block *wblock = dev_to_wblock(dev);
 -	const struct wmi_device_id *id = wmi_driver->id_table;
 +	wblock = dev_get_drvdata(dev);
 +	if (!wblock)
 +		return -ENOMEM;
  
 -	while (id->guid_string) {
 -		uuid_le driver_guid;
 +	sprintf(guid_string, "%pUL", wblock->gblock.guid);
  
 -		if (WARN_ON(uuid_le_to_bin(id->guid_string, &driver_guid)))
 -			continue;
 -		if (!memcmp(&driver_guid, wblock->gblock.guid, 16))
 -			return 1;
 -
 -		id++;
 -	}
 +	strcpy(&env->buf[env->buflen - 1], "wmi:");
 +	memcpy(&env->buf[env->buflen - 1 + 4], guid_string, 36);
 +	env->buflen += 40;
  
  	return 0;
  }
  
 -static int wmi_dev_probe(struct device *dev)
 +static void wmi_dev_free(struct device *dev)
  {
 -	struct wmi_block *wblock = dev_to_wblock(dev);
 -	struct wmi_driver *wdriver =
 -		container_of(dev->driver, struct wmi_driver, driver);
 -	int ret = 0;
 +	struct wmi_block *wmi_block = container_of(dev, struct wmi_block, dev);
  
 -	if (ACPI_FAILURE(wmi_method_enable(wblock, 1)))
 -		dev_warn(dev, "failed to enable device -- probing anyway\n");
 -
 -	if (wdriver->probe) {
 -		ret = wdriver->probe(dev_to_wdev(dev));
 -		if (ret != 0 && ACPI_FAILURE(wmi_method_enable(wblock, 0)))
 -			dev_warn(dev, "failed to disable device\n");
 -	}
 -
 -	return ret;
 +	kfree(wmi_block);
  }
  
 -static int wmi_dev_remove(struct device *dev)
 -{
 -	struct wmi_block *wblock = dev_to_wblock(dev);
 -	struct wmi_driver *wdriver =
 -		container_of(dev->driver, struct wmi_driver, driver);
 -	int ret = 0;
 -
 -	if (wdriver->remove)
 -		ret = wdriver->remove(dev_to_wdev(dev));
 -
 -	if (ACPI_FAILURE(wmi_method_enable(wblock, 0)))
 -		dev_warn(dev, "failed to disable device\n");
 -
 -	return ret;
 -}
 -
 -static struct class wmi_bus_class = {
 -	.name = "wmi_bus",
 -};
 -
 -static struct bus_type wmi_bus_type = {
 +static struct class wmi_class = {
  	.name = "wmi",
 +	.dev_release = wmi_dev_free,
 +	.dev_uevent = wmi_dev_uevent,
  	.dev_groups = wmi_groups,
 -	.match = wmi_dev_match,
 -	.uevent = wmi_dev_uevent,
 -	.probe = wmi_dev_probe,
 -	.remove = wmi_dev_remove,
  };
  
++<<<<<<< HEAD
 +static int wmi_create_device(const struct guid_block *gblock,
++=======
+ static struct device_type wmi_type_event = {
+ 	.name = "event",
+ 	.groups = wmi_event_groups,
+ 	.release = wmi_dev_release,
+ };
+ 
+ static struct device_type wmi_type_method = {
+ 	.name = "method",
+ 	.groups = wmi_data_or_method_groups,
+ 	.release = wmi_dev_release,
+ };
+ 
+ static struct device_type wmi_type_data = {
+ 	.name = "data",
+ 	.groups = wmi_data_or_method_groups,
+ 	.release = wmi_dev_release,
+ };
+ 
+ static int wmi_create_device(struct device *wmi_bus_dev,
+ 			     const struct guid_block *gblock,
++>>>>>>> d79b10740210 (platform/x86: wmi: Split devices into types and add basic sysfs attributes)
  			     struct wmi_block *wblock,
  			     struct acpi_device *device)
  {
 -	wblock->dev.dev.bus = &wmi_bus_type;
 -	wblock->dev.dev.parent = wmi_bus_dev;
 +	wblock->dev.class = &wmi_class;
  
 -	dev_set_name(&wblock->dev.dev, "%pUL", gblock->guid);
 +	dev_set_name(&wblock->dev, "%pUL", gblock->guid);
  
++<<<<<<< HEAD
 +	dev_set_drvdata(&wblock->dev, wblock);
++=======
+ 	if (gblock->flags & ACPI_WMI_EVENT) {
+ 		wblock->dev.dev.type = &wmi_type_event;
+ 	} else if (gblock->flags & ACPI_WMI_METHOD) {
+ 		wblock->dev.dev.type = &wmi_type_method;
+ 	} else {
+ 		wblock->dev.dev.type = &wmi_type_data;
+ 	}
++>>>>>>> d79b10740210 (platform/x86: wmi: Split devices into types and add basic sysfs attributes)
  
 -	return device_register(&wblock->dev.dev);
 +	return device_register(&wblock->dev);
  }
  
  static void wmi_free_devices(struct acpi_device *device)
* Unmerged path drivers/platform/x86/wmi.c
