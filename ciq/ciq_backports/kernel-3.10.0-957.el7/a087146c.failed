uio: Request/free irq separate from dev lifecycle

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [uio] Request/free irq separate from dev lifecycle (Xiubo Li) [1560418]
Rebuild_FUZZ: 94.62%
commit-author Brian Russell <brian.russell@brocade.com>
commit a087146c72bad795bcab80e5987c5b80fa225000
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/a087146c.failed

Separate irq request/free from the device lifecycle.
After device unregister the parent module can call pci_disable_msi.
>From the PCI MSI how to:

"Before calling this function, a device driver must always call free_irq()
on any interrupt for which it previously called request_irq().
Failure to do so results in a BUG_ON(), leaving the device with
MSI enabled and thus leaking its vector."

So we need to separately free the irq at unregister to allow the device
to be kept around in the case of it still having open FDs.

	Signed-off-by: Brian Russell <brussell@brocade.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit a087146c72bad795bcab80e5987c5b80fa225000)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/uio/uio.c
diff --cc drivers/uio/uio.c
index 66374682b73b,65bf0676d54a..000000000000
--- a/drivers/uio/uio.c
+++ b/drivers/uio/uio.c
@@@ -839,6 -835,14 +839,17 @@@ int __uio_register_device(struct modul
  	info->uio_dev = idev;
  
  	if (info->irq && (info->irq != UIO_IRQ_CUSTOM)) {
++<<<<<<< HEAD
++=======
+ 		/*
+ 		 * Note that we deliberately don't use devm_request_irq
+ 		 * here. The parent module can unregister the UIO device
+ 		 * and call pci_disable_msi, which requires that this
+ 		 * irq has been freed. However, the device may have open
+ 		 * FDs at the time of unregister and therefore may not be
+ 		 * freed until they are released.
+ 		 */
++>>>>>>> a087146c72ba (uio: Request/free irq separate from dev lifecycle)
  		ret = request_irq(info->irq, uio_interrupt,
  				  info->irq_flags, info->name, idev);
  		if (ret)
@@@ -876,13 -877,11 +887,15 @@@ void uio_unregister_device(struct uio_i
  
  	uio_free_minor(idev);
  
 +	if (info->irq && (info->irq != UIO_IRQ_CUSTOM))
 +		free_irq(info->irq, idev);
 +
  	uio_dev_del_attributes(idev);
  
+ 	free_irq(idev->info->irq, idev);
+ 
  	device_destroy(&uio_class, MKDEV(uio_major, idev->minor));
 +	kfree(idev);
  
  	return;
  }
* Unmerged path drivers/uio/uio.c
