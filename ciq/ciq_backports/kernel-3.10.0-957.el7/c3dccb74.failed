mmc: core: Delete bounce buffer Kconfig option

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] core: Delete bounce buffer Kconfig option (Gopal Tiwari) [1456570]
Rebuild_FUZZ: 94.25%
commit-author Linus Walleij <linus.walleij@linaro.org>
commit c3dccb74be28a345a2ebcc224e41b774529b8b8f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c3dccb74.failed

This option is activated by all multiplatform configs and what
not so we almost always have it turned on, and the memory it
saves is negligible, even more so moving forward. The actual
bounce buffer only gets allocated only when used, the only
thing the ifdefs are saving is a little bit of code.

It is highly improper to have this as a Kconfig option that
get turned on by Kconfig, make this a pure runtime-thing and
let the host decide whether we use bounce buffers. We add a
new property "disable_bounce" to the host struct.

Notice that mmc_queue_calc_bouncesz() already disables the
bounce buffers if host->max_segs != 1, so any arch that has a
maximum number of segments higher than 1 will have bounce
buffers disabled.

The option CONFIG_MMC_BLOCK_BOUNCE is default y so the
majority of platforms in the kernel already have it on, and
it then gets turned off at runtime since most of these have
a host->max_segs > 1. The few exceptions that have
host->max_segs == 1 and still turn off the bounce buffering
are those that disable it in their defconfig.

Those are the following:

arch/arm/configs/colibri_pxa300_defconfig
arch/arm/configs/zeus_defconfig
- Uses MMC_PXA, drivers/mmc/host/pxamci.c
- Sets host->max_segs = NR_SG, which is 1
- This needs its bounce buffer deactivated so we set
  host->disable_bounce to true in the host driver

arch/arm/configs/davinci_all_defconfig
- Uses MMC_DAVINCI, drivers/mmc/host/davinci_mmc.c
- This driver sets host->max_segs to MAX_NR_SG, which is 16
- That means this driver anyways disabled bounce buffers
- No special action needed for this platform

arch/arm/configs/lpc32xx_defconfig
arch/arm/configs/nhk8815_defconfig
arch/arm/configs/u300_defconfig
- Uses MMC_ARMMMCI, drivers/mmc/host/mmci.[c|h]
- This driver by default sets host->max_segs to NR_SG,
  which is 128, unless a DMA engine is used, and in that case
  the number of segments are also > 1
- That means this driver already disables bounce buffers
- No special action needed for these platforms

arch/arm/configs/sama5_defconfig
- Uses MMC_SDHCI, MMC_SDHCI_PLTFM, MMC_SDHCI_OF_AT91, MMC_ATMELMCI
- Uses drivers/mmc/host/sdhci.c
- Normally sets host->max_segs to SDHCI_MAX_SEGS which is 128 and
  thus disables bounce buffers
- Sets host->max_segs to 1 if SDHCI_USE_SDMA is set
- SDHCI_USE_SDMA is only set by SDHCI on PCI adapers
- That means that for this platform bounce buffers are already
  disabled at runtime
- No special action needed for this platform

arch/blackfin/configs/CM-BF533_defconfig
arch/blackfin/configs/CM-BF537E_defconfig
- Uses MMC_SPI (a simple MMC card connected on SPI pins)
- Uses drivers/mmc/host/mmc_spi.c
- Sets host->max_segs to MMC_SPI_BLOCKSATONCE which is 128
- That means this platform already disables bounce buffers at
  runtime
- No special action needed for these platforms

arch/mips/configs/cavium_octeon_defconfig
- Uses MMC_CAVIUM_OCTEON, drivers/mmc/host/cavium.c
- Sets host->max_segs to 16 or 1
- Setting host->disable_bounce to be sure for the 1 case

arch/mips/configs/qi_lb60_defconfig
- Uses MMC_JZ4740, drivers/mmc/host/jz4740_mmc.c
- This sets host->max_segs to 128 so bounce buffers are
  already runtime disabled
- No action needed for this platform

It would be interesting to come up with a list of the platforms
that actually end up using bounce buffers. I have not been
able to infer such a list, but it occurs when
host->max_segs == 1 and the bounce buffering is not explicitly
disabled.

	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit c3dccb74be28a345a2ebcc224e41b774529b8b8f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/queue.c
#	drivers/mmc/host/cavium.c
diff --cc drivers/mmc/core/queue.c
index b0ae9d688e28,70ba7f94c706..000000000000
--- a/drivers/mmc/core/queue.c
+++ b/drivers/mmc/core/queue.c
@@@ -254,8 -195,149 +254,154 @@@ static void mmc_queue_reqs_free_bufs(st
  {
  	int i;
  
++<<<<<<< HEAD
 +	for (i = 0; i < mq->qdepth; i++)
 +		mmc_queue_req_free_bufs(&mq->mqrq[i]);
++=======
+ 	for (i = 0; i < qdepth; i++)
+ 		mmc_queue_req_free_bufs(&mqrq[i]);
+ }
+ 
+ static void mmc_queue_free_mqrqs(struct mmc_queue_req *mqrq, int qdepth)
+ {
+ 	mmc_queue_reqs_free_bufs(mqrq, qdepth);
+ 	kfree(mqrq);
+ }
+ 
+ static struct mmc_queue_req *mmc_queue_alloc_mqrqs(int qdepth)
+ {
+ 	struct mmc_queue_req *mqrq;
+ 	int i;
+ 
+ 	mqrq = kcalloc(qdepth, sizeof(*mqrq), GFP_KERNEL);
+ 	if (mqrq) {
+ 		for (i = 0; i < qdepth; i++)
+ 			mqrq[i].task_id = i;
+ 	}
+ 
+ 	return mqrq;
+ }
+ 
+ static int mmc_queue_alloc_bounce_bufs(struct mmc_queue_req *mqrq, int qdepth,
+ 				       unsigned int bouncesz)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < qdepth; i++) {
+ 		mqrq[i].bounce_buf = kmalloc(bouncesz, GFP_KERNEL);
+ 		if (!mqrq[i].bounce_buf)
+ 			return -ENOMEM;
+ 
+ 		mqrq[i].sg = mmc_alloc_sg(1);
+ 		if (!mqrq[i].sg)
+ 			return -ENOMEM;
+ 
+ 		mqrq[i].bounce_sg = mmc_alloc_sg(bouncesz / 512);
+ 		if (!mqrq[i].bounce_sg)
+ 			return -ENOMEM;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static bool mmc_queue_alloc_bounce(struct mmc_queue_req *mqrq, int qdepth,
+ 				   unsigned int bouncesz)
+ {
+ 	int ret;
+ 
+ 	ret = mmc_queue_alloc_bounce_bufs(mqrq, qdepth, bouncesz);
+ 	if (ret)
+ 		mmc_queue_reqs_free_bufs(mqrq, qdepth);
+ 
+ 	return !ret;
+ }
+ 
+ static unsigned int mmc_queue_calc_bouncesz(struct mmc_host *host)
+ {
+ 	unsigned int bouncesz = MMC_QUEUE_BOUNCESZ;
+ 
+ 	if (host->max_segs != 1 || (host->caps & MMC_CAP_NO_BOUNCE_BUFF))
+ 		return 0;
+ 
+ 	if (bouncesz > host->max_req_size)
+ 		bouncesz = host->max_req_size;
+ 	if (bouncesz > host->max_seg_size)
+ 		bouncesz = host->max_seg_size;
+ 	if (bouncesz > host->max_blk_count * 512)
+ 		bouncesz = host->max_blk_count * 512;
+ 
+ 	if (bouncesz <= 512)
+ 		return 0;
+ 
+ 	return bouncesz;
+ }
+ 
+ static int mmc_queue_alloc_sgs(struct mmc_queue_req *mqrq, int qdepth,
+ 			       int max_segs)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < qdepth; i++) {
+ 		mqrq[i].sg = mmc_alloc_sg(max_segs);
+ 		if (!mqrq[i].sg)
+ 			return -ENOMEM;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void mmc_queue_free_shared_queue(struct mmc_card *card)
+ {
+ 	if (card->mqrq) {
+ 		mmc_queue_free_mqrqs(card->mqrq, card->qdepth);
+ 		card->mqrq = NULL;
+ 	}
+ }
+ 
+ static int __mmc_queue_alloc_shared_queue(struct mmc_card *card, int qdepth)
+ {
+ 	struct mmc_host *host = card->host;
+ 	struct mmc_queue_req *mqrq;
+ 	unsigned int bouncesz;
+ 	int ret = 0;
+ 
+ 	if (card->mqrq)
+ 		return -EINVAL;
+ 
+ 	mqrq = mmc_queue_alloc_mqrqs(qdepth);
+ 	if (!mqrq)
+ 		return -ENOMEM;
+ 
+ 	card->mqrq = mqrq;
+ 	card->qdepth = qdepth;
+ 
+ 	bouncesz = mmc_queue_calc_bouncesz(host);
+ 
+ 	if (bouncesz && !mmc_queue_alloc_bounce(mqrq, qdepth, bouncesz)) {
+ 		bouncesz = 0;
+ 		pr_warn("%s: unable to allocate bounce buffers\n",
+ 			mmc_card_name(card));
+ 	}
+ 
+ 	card->bouncesz = bouncesz;
+ 
+ 	if (!bouncesz) {
+ 		ret = mmc_queue_alloc_sgs(mqrq, qdepth, host->max_segs);
+ 		if (ret)
+ 			goto out_err;
+ 	}
+ 
+ 	return ret;
+ 
+ out_err:
+ 	mmc_queue_free_shared_queue(card);
+ 	return ret;
+ }
+ 
+ int mmc_queue_alloc_shared_queue(struct mmc_card *card)
+ {
+ 	return __mmc_queue_alloc_shared_queue(card, 2);
++>>>>>>> c3dccb74be28 (mmc: core: Delete bounce buffer Kconfig option)
  }
  
  /**
* Unmerged path drivers/mmc/host/cavium.c
diff --git a/drivers/mmc/core/Kconfig b/drivers/mmc/core/Kconfig
index 44cd3a5f62af..0b04acf71f80 100644
--- a/drivers/mmc/core/Kconfig
+++ b/drivers/mmc/core/Kconfig
@@ -29,24 +29,6 @@ config MMC_BLOCK_MINORS
 
 	  If unsure, say 8 here.
 
-config MMC_BLOCK_BOUNCE
-	bool "Use bounce buffer for simple hosts"
-	depends on MMC_BLOCK
-	default y
-	help
-	  SD/MMC is a high latency protocol where it is crucial to
-	  send large requests in order to get high performance. Many
-	  controllers, however, are restricted to continuous memory
-	  (i.e. they can't do scatter-gather), something the kernel
-	  rarely can provide.
-
-	  Say Y here to help these restricted hosts by bouncing
-	  requests back and forth from a large buffer. You will get
-	  a big performance gain at the cost of up to 64 KiB of
-	  physical memory.
-
-	  If unsure, say Y here.
-
 config SDIO_UART
 	tristate "SDIO UART/GPS class support"
 	depends on TTY
* Unmerged path drivers/mmc/core/queue.c
* Unmerged path drivers/mmc/host/cavium.c
diff --git a/drivers/mmc/host/pxamci.c b/drivers/mmc/host/pxamci.c
index 2b2f65ada22e..81a16db45b5a 100644
--- a/drivers/mmc/host/pxamci.c
+++ b/drivers/mmc/host/pxamci.c
@@ -692,7 +692,11 @@ static int pxamci_probe(struct platform_device *pdev)
 
 	pxamci_init_ocr(host);
 
-	mmc->caps = 0;
+	/*
+	 * This architecture used to disable bounce buffers through its
+	 * defconfig, now it is done at runtime as a host property.
+	 */
+	mmc->caps = MMC_CAP_NO_BOUNCE_BUFF;
 	host->cmdat = 0;
 	if (!cpu_is_pxa25x()) {
 		mmc->caps |= MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ;
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index dc8068704c1d..1025cbbc350d 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -272,6 +272,7 @@ struct mmc_host {
 #define MMC_CAP_UHS_SDR50	(1 << 18)	/* Host supports UHS SDR50 mode */
 #define MMC_CAP_UHS_SDR104	(1 << 19)	/* Host supports UHS SDR104 mode */
 #define MMC_CAP_UHS_DDR50	(1 << 20)	/* Host supports UHS DDR50 mode */
+#define MMC_CAP_NO_BOUNCE_BUFF	(1 << 21)	/* Disable bounce buffers on host */
 #define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
 #define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
 #define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */
