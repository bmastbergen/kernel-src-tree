ipv4: Namespaceify ip_default_ttl sysctl knob

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Nikolay Borisov <kernel@kyup.com>
commit fa50d974d104113630d68b7d03233a6686230d0c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/fa50d974.failed

	Signed-off-by: Nikolay Borisov <kernel@kyup.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fa50d974d104113630d68b7d03233a6686230d0c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netns/ipv4.h
#	net/ipv4/ip_output.c
#	net/ipv4/sysctl_net_ipv4.c
diff --cc include/net/netns/ipv4.h
index 79c995f4a025,bc8f7f94abcb..000000000000
--- a/include/net/netns/ipv4.h
+++ b/include/net/netns/ipv4.h
@@@ -70,13 -75,52 +70,51 @@@ struct netns_ipv4 
  	int sysctl_icmp_ratemask;
  	int sysctl_icmp_errors_use_inbound_ifaddr;
  
 -	struct local_ports ip_local_ports;
 -
  	int sysctl_tcp_ecn;
 -	int sysctl_tcp_ecn_fallback;
  
++<<<<<<< HEAD
 +	kgid_t sysctl_ping_group_range[2];
 +	long sysctl_tcp_mem[3];
++=======
+ 	int sysctl_ip_default_ttl;
+ 	int sysctl_ip_no_pmtu_disc;
+ 	int sysctl_ip_fwd_use_pmtu;
+ 	int sysctl_ip_nonlocal_bind;
+ 
+ 	int sysctl_fwmark_reflect;
+ 	int sysctl_tcp_fwmark_accept;
+ #ifdef CONFIG_NET_L3_MASTER_DEV
+ 	int sysctl_tcp_l3mdev_accept;
+ #endif
+ 	int sysctl_tcp_mtu_probing;
+ 	int sysctl_tcp_base_mss;
+ 	int sysctl_tcp_probe_threshold;
+ 	u32 sysctl_tcp_probe_interval;
+ 
+ 	int sysctl_tcp_keepalive_time;
+ 	int sysctl_tcp_keepalive_probes;
+ 	int sysctl_tcp_keepalive_intvl;
+ 
+ 	int sysctl_tcp_syn_retries;
+ 	int sysctl_tcp_synack_retries;
+ 	int sysctl_tcp_syncookies;
+ 	int sysctl_tcp_reordering;
+ 	int sysctl_tcp_retries1;
+ 	int sysctl_tcp_retries2;
+ 	int sysctl_tcp_orphan_retries;
+ 	int sysctl_tcp_fin_timeout;
+ 	unsigned int sysctl_tcp_notsent_lowat;
+ 
+ 	int sysctl_igmp_max_memberships;
+ 	int sysctl_igmp_max_msf;
+ 	int sysctl_igmp_llm_reports;
+ 	int sysctl_igmp_qrv;
+ 
+ 	struct ping_group_range ping_group_range;
++>>>>>>> fa50d974d104 (ipv4: Namespaceify ip_default_ttl sysctl knob)
  
  	atomic_t dev_addr_genid;
 -
 -#ifdef CONFIG_SYSCTL
 -	unsigned long *sysctl_local_reserved_ports;
 -#endif
 +	RH_KABI_FILL_HOLE(unsigned int	fib_seq)	/* protected by rtnl_mutex */
  
  #ifdef CONFIG_IP_MROUTE
  #ifndef CONFIG_IP_MROUTE_MULTIPLE_TABLES
diff --cc net/ipv4/ip_output.c
index c40ea48f42ed,f734c42acdaf..000000000000
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@@ -80,12 -79,10 +80,19 @@@
  #include <linux/netlink.h>
  #include <linux/tcp.h>
  
++<<<<<<< HEAD
 +int sysctl_ip_default_ttl __read_mostly = IPDEFTTL;
 +EXPORT_SYMBOL(sysctl_ip_default_ttl);
 +
 +static int ip_fragment(struct sock *sk, struct sk_buff *skb,
 +		       unsigned int mtu,
 +		       int (*output)(struct sock *, struct sk_buff *));
++=======
+ static int
+ ip_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,
+ 	    unsigned int mtu,
+ 	    int (*output)(struct net *, struct sock *, struct sk_buff *));
++>>>>>>> fa50d974d104 (ipv4: Namespaceify ip_default_ttl sysctl knob)
  
  /* Generate a checksum for an outgoing IP datagram. */
  void ip_send_check(struct iphdr *iph)
diff --cc net/ipv4/sysctl_net_ipv4.c
index 12b498f653f9,a833a9f9e4cd..000000000000
--- a/net/ipv4/sysctl_net_ipv4.c
+++ b/net/ipv4/sysctl_net_ipv4.c
@@@ -328,31 -283,6 +328,34 @@@ static struct ctl_table ipv4_table[] = 
  		.proc_handler	= proc_dointvec
  	},
  	{
++<<<<<<< HEAD
 +		.procname	= "ip_default_ttl",
 +		.data		= &sysctl_ip_default_ttl,
 +		.maxlen		= sizeof(int),
 +		.mode		= 0644,
 +		.proc_handler	= proc_dointvec_minmax,
 +		.extra1		= &ip_ttl_min,
 +		.extra2		= &ip_ttl_max,
 +	},
 +	{
 +		.procname	= "tcp_syn_retries",
 +		.data		= &sysctl_tcp_syn_retries,
 +		.maxlen		= sizeof(int),
 +		.mode		= 0644,
 +		.proc_handler	= proc_dointvec_minmax,
 +		.extra1		= &tcp_syn_retries_min,
 +		.extra2		= &tcp_syn_retries_max
 +	},
 +	{
 +		.procname	= "tcp_synack_retries",
 +		.data		= &sysctl_tcp_synack_retries,
 +		.maxlen		= sizeof(int),
 +		.mode		= 0644,
 +		.proc_handler	= proc_dointvec
 +	},
 +	{
++=======
++>>>>>>> fa50d974d104 (ipv4: Namespaceify ip_default_ttl sysctl knob)
  		.procname	= "tcp_max_orphans",
  		.data		= &sysctl_tcp_max_orphans,
  		.maxlen		= sizeof(int),
@@@ -865,9 -737,25 +868,28 @@@ static struct ctl_table ipv4_net_table[
  		.proc_handler	= proc_dointvec
  	},
  	{
++<<<<<<< HEAD
++=======
+ 		.procname	= "tcp_ecn_fallback",
+ 		.data		= &init_net.ipv4.sysctl_tcp_ecn_fallback,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "ip_default_ttl",
+ 		.data		= &init_net.ipv4.sysctl_ip_default_ttl,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_minmax,
+ 		.extra1		= &ip_ttl_min,
+ 		.extra2		= &ip_ttl_max,
+ 	},
+ 	{
++>>>>>>> fa50d974d104 (ipv4: Namespaceify ip_default_ttl sysctl knob)
  		.procname	= "ip_local_port_range",
 -		.maxlen		= sizeof(init_net.ipv4.ip_local_ports.range),
 -		.data		= &init_net.ipv4.ip_local_ports.range,
 +		.maxlen		= sizeof(init_net.ipv4_sysctl_local_ports.range),
 +		.data		= &init_net.ipv4_sysctl_local_ports.range,
  		.mode		= 0644,
  		.proc_handler	= ipv4_local_port_range,
  	},
@@@ -946,28 -980,20 +968,30 @@@ static __net_init int ipv4_sysctl_init_
  			table[i].data += (void *)net - (void *)&init_net;
  	}
  
 +	/*
 +	 * Sane defaults - nobody may create ping sockets.
 +	 * Boot scripts should set this to distro-specific group.
 +	 */
 +	net->ipv4.sysctl_ping_group_range[0] = make_kgid(&init_user_ns, 1);
 +	net->ipv4.sysctl_ping_group_range[1] = make_kgid(&init_user_ns, 0);
 +
 +	/*
 +	 * Set defaults for local port range
 +	 */
 +	seqlock_init(&net->ipv4_sysctl_local_ports.lock);
 +	net->ipv4_sysctl_local_ports.range[0] =  32768;
 +	net->ipv4_sysctl_local_ports.range[1] =  60999;
 +
 +	tcp_init_mem(net);
 +
  	net->ipv4.ipv4_hdr = register_net_sysctl(net, "net/ipv4", table);
 -	if (!net->ipv4.ipv4_hdr)
 +	if (net->ipv4.ipv4_hdr == NULL)
  		goto err_reg;
  
 -	net->ipv4.sysctl_local_reserved_ports = kzalloc(65536 / 8, GFP_KERNEL);
 -	if (!net->ipv4.sysctl_local_reserved_ports)
 -		goto err_ports;
 -
+ 	net->ipv4.sysctl_ip_default_ttl = IPDEFTTL;
+ 
  	return 0;
  
 -err_ports:
 -	unregister_net_sysctl_table(net->ipv4.ipv4_hdr);
  err_reg:
  	if (!net_eq(net, &init_net))
  		kfree(table);
* Unmerged path include/net/netns/ipv4.h
diff --git a/include/net/route.h b/include/net/route.h
index 79ebe28e40b2..597e477c0444 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -312,14 +312,13 @@ static inline int inet_iif(const struct sk_buff *skb)
 	return skb->skb_iif;
 }
 
-extern int sysctl_ip_default_ttl;
-
 static inline int ip4_dst_hoplimit(const struct dst_entry *dst)
 {
 	int hoplimit = dst_metric_raw(dst, RTAX_HOPLIMIT);
+	struct net *net = dev_net(dst->dev);
 
 	if (hoplimit == 0)
-		hoplimit = sysctl_ip_default_ttl;
+		hoplimit = net->ipv4.sysctl_ip_default_ttl;
 	return hoplimit;
 }
 
diff --git a/net/bridge/netfilter/nft_reject_bridge.c b/net/bridge/netfilter/nft_reject_bridge.c
index 2f6ff3e8b316..8977bf718aa7 100644
--- a/net/bridge/netfilter/nft_reject_bridge.c
+++ b/net/bridge/netfilter/nft_reject_bridge.c
@@ -48,6 +48,7 @@ static void nft_reject_br_send_v4_tcp_reset(struct sk_buff *oldskb,
 	struct iphdr *niph;
 	const struct tcphdr *oth;
 	struct tcphdr _oth;
+	struct net *net = sock_net(oldskb->sk);
 
 	if (!nft_bridge_iphdr_validate(oldskb))
 		return;
@@ -63,9 +64,9 @@ static void nft_reject_br_send_v4_tcp_reset(struct sk_buff *oldskb,
 
 	skb_reserve(nskb, LL_MAX_HEADER);
 	niph = nf_reject_iphdr_put(nskb, oldskb, IPPROTO_TCP,
-				   sysctl_ip_default_ttl);
+				   net->ipv4.sysctl_ip_default_ttl);
 	nf_reject_ip_tcphdr_put(nskb, oldskb, oth);
-	niph->ttl	= sysctl_ip_default_ttl;
+	niph->ttl	= net->ipv4.sysctl_ip_default_ttl;
 	niph->tot_len	= htons(nskb->len);
 	ip_send_check(niph);
 
@@ -85,6 +86,7 @@ static void nft_reject_br_send_v4_unreach(struct sk_buff *oldskb,
 	void *payload;
 	__wsum csum;
 	u8 proto;
+	struct net *net = sock_net(oldskb->sk);
 
 	if (!nft_bridge_iphdr_validate(oldskb))
 		return;
@@ -119,7 +121,7 @@ static void nft_reject_br_send_v4_unreach(struct sk_buff *oldskb,
 
 	skb_reserve(nskb, LL_MAX_HEADER);
 	niph = nf_reject_iphdr_put(nskb, oldskb, IPPROTO_ICMP,
-				   sysctl_ip_default_ttl);
+				   net->ipv4.sysctl_ip_default_ttl);
 
 	skb_reset_transport_header(nskb);
 	icmph = skb_put_zero(nskb, sizeof(struct icmphdr));
* Unmerged path net/ipv4/ip_output.c
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index ac07084c45ef..7b157909249a 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -1271,10 +1271,13 @@ static int do_ip_getsockopt(struct sock *sk, int level, int optname,
 		val = inet->tos;
 		break;
 	case IP_TTL:
+	{
+		struct net *net = sock_net(sk);
 		val = (inet->uc_ttl == -1 ?
-		       sysctl_ip_default_ttl :
+		       net->ipv4.sysctl_ip_default_ttl :
 		       inet->uc_ttl);
 		break;
+	}
 	case IP_HDRINCL:
 		val = inet->hdrincl;
 		break;
diff --git a/net/ipv4/netfilter/ipt_SYNPROXY.c b/net/ipv4/netfilter/ipt_SYNPROXY.c
index 09a118f48a25..159c929b060a 100644
--- a/net/ipv4/netfilter/ipt_SYNPROXY.c
+++ b/net/ipv4/netfilter/ipt_SYNPROXY.c
@@ -21,6 +21,7 @@ static struct iphdr *
 synproxy_build_ip(struct sk_buff *skb, u32 saddr, u32 daddr)
 {
 	struct iphdr *iph;
+	struct net *net = sock_net(skb->sk);
 
 	skb_reset_network_header(skb);
 	iph = skb_put(skb, sizeof(*iph));
@@ -29,7 +30,7 @@ synproxy_build_ip(struct sk_buff *skb, u32 saddr, u32 daddr)
 	iph->tos	= 0;
 	iph->id		= 0;
 	iph->frag_off	= htons(IP_DF);
-	iph->ttl	= sysctl_ip_default_ttl;
+	iph->ttl	= net->ipv4.sysctl_ip_default_ttl;
 	iph->protocol	= IPPROTO_TCP;
 	iph->check	= 0;
 	iph->saddr	= saddr;
diff --git a/net/ipv4/proc.c b/net/ipv4/proc.c
index 87665bea9c35..5880828c0dfc 100644
--- a/net/ipv4/proc.c
+++ b/net/ipv4/proc.c
@@ -384,7 +384,7 @@ static int snmp_seq_show(struct seq_file *seq, void *v)
 
 	seq_printf(seq, "\nIp: %d %d",
 		   IPV4_DEVCONF_ALL(net, FORWARDING) ? 1 : 2,
-		   sysctl_ip_default_ttl);
+		   net->ipv4.sysctl_ip_default_ttl);
 
 	BUILD_BUG_ON(offsetof(struct ipstats_mib, mibs) != 0);
 	for (i = 0; snmp4_ipstats_list[i].name != NULL; i++)
* Unmerged path net/ipv4/sysctl_net_ipv4.c
