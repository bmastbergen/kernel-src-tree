xfs: remove double-underscore integer types

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit c8ce540db5f67d254aafb14b5d76422c62a906df
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c8ce540d.failed

This is a purely mechanical patch that removes the private
__{u,}int{8,16,32,64}_t typedefs in favor of using the system
{u,}int{8,16,32,64}_t typedefs.  This is the sed script used to perform
the transformation and fix the resulting whitespace and indentation
errors:

s/typedef\t__uint8_t/typedef __uint8_t\t/g
s/typedef\t__uint/typedef __uint/g
s/typedef\t__int\([0-9]*\)_t/typedef int\1_t\t/g
s/__uint8_t\t/__uint8_t\t\t/g
s/__uint/uint/g
s/__int\([0-9]*\)_t\t/__int\1_t\t\t/g
s/__int/int/g
/^typedef.*int[0-9]*_t;$/d

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit c8ce540db5f67d254aafb14b5d76422c62a906df)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_alloc_btree.c
#	fs/xfs/libxfs/xfs_btree.c
#	fs/xfs/libxfs/xfs_btree.h
#	fs/xfs/libxfs/xfs_format.h
#	fs/xfs/libxfs/xfs_inode_buf.h
#	fs/xfs/libxfs/xfs_log_format.h
#	fs/xfs/libxfs/xfs_refcount_btree.c
#	fs/xfs/libxfs/xfs_rmap.c
#	fs/xfs/libxfs/xfs_rmap.h
#	fs/xfs/libxfs/xfs_rmap_btree.c
#	fs/xfs/xfs_bmap_util.c
#	fs/xfs/xfs_inode.c
#	fs/xfs/xfs_log_recover.c
#	fs/xfs/xfs_mount.h
#	fs/xfs/xfs_stats.h
#	fs/xfs/xfs_super.c
#	fs/xfs/xfs_trace.h
#	fs/xfs/xfs_trans.h
#	fs/xfs/xfs_trans_rmap.c
diff --cc fs/xfs/libxfs/xfs_alloc_btree.c
index a2ae2e9137f4,5020cbc02db8..000000000000
--- a/fs/xfs/libxfs/xfs_alloc_btree.c
+++ b/fs/xfs/libxfs/xfs_alloc_btree.c
@@@ -235,27 -253,60 +235,77 @@@ xfs_allocbt_init_ptr_from_cur
  	ptr->s = agf->agf_roots[cur->bc_btnum];
  }
  
++<<<<<<< HEAD
 +STATIC __int64_t
 +xfs_allocbt_key_diff(
++=======
+ STATIC int64_t
+ xfs_bnobt_key_diff(
  	struct xfs_btree_cur	*cur,
  	union xfs_btree_key	*key)
  {
  	xfs_alloc_rec_incore_t	*rec = &cur->bc_rec.a;
  	xfs_alloc_key_t		*kp = &key->alloc;
- 	__int64_t		diff;
  
+ 	return (int64_t)be32_to_cpu(kp->ar_startblock) - rec->ar_startblock;
+ }
+ 
+ STATIC int64_t
+ xfs_cntbt_key_diff(
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
+ 	struct xfs_btree_cur	*cur,
+ 	union xfs_btree_key	*key)
+ {
+ 	xfs_alloc_rec_incore_t	*rec = &cur->bc_rec.a;
+ 	xfs_alloc_key_t		*kp = &key->alloc;
+ 	int64_t			diff;
+ 
++<<<<<<< HEAD
 +	if (cur->bc_btnum == XFS_BTNUM_BNO) {
 +		return (__int64_t)be32_to_cpu(kp->ar_startblock) -
 +				rec->ar_startblock;
 +	}
 +
 +	diff = (__int64_t)be32_to_cpu(kp->ar_blockcount) - rec->ar_blockcount;
++=======
+ 	diff = (int64_t)be32_to_cpu(kp->ar_blockcount) - rec->ar_blockcount;
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
+ 	if (diff)
+ 		return diff;
+ 
+ 	return (int64_t)be32_to_cpu(kp->ar_startblock) - rec->ar_startblock;
+ }
+ 
++<<<<<<< HEAD
++=======
+ STATIC int64_t
+ xfs_bnobt_diff_two_keys(
+ 	struct xfs_btree_cur	*cur,
+ 	union xfs_btree_key	*k1,
+ 	union xfs_btree_key	*k2)
+ {
+ 	return (int64_t)be32_to_cpu(k1->alloc.ar_startblock) -
+ 			  be32_to_cpu(k2->alloc.ar_startblock);
+ }
+ 
+ STATIC int64_t
+ xfs_cntbt_diff_two_keys(
+ 	struct xfs_btree_cur	*cur,
+ 	union xfs_btree_key	*k1,
+ 	union xfs_btree_key	*k2)
+ {
+ 	int64_t			diff;
+ 
+ 	diff =  be32_to_cpu(k1->alloc.ar_blockcount) -
+ 		be32_to_cpu(k2->alloc.ar_blockcount);
  	if (diff)
  		return diff;
  
- 	return (__int64_t)be32_to_cpu(kp->ar_startblock) - rec->ar_startblock;
+ 	return  be32_to_cpu(k1->alloc.ar_startblock) -
+ 		be32_to_cpu(k2->alloc.ar_startblock);
  }
  
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  static bool
  xfs_allocbt_verify(
  	struct xfs_buf		*bp)
diff --cc fs/xfs/libxfs/xfs_btree.c
index 2c645cf9ed90,2aac3f499d97..000000000000
--- a/fs/xfs/libxfs/xfs_btree.c
+++ b/fs/xfs/libxfs/xfs_btree.c
@@@ -43,14 -43,15 +43,23 @@@ kmem_zone_t	*xfs_btree_cur_zone
  /*
   * Btree magic numbers.
   */
++<<<<<<< HEAD
 +static const __uint32_t xfs_magics[2][XFS_BTNUM_MAX] = {
 +	{ XFS_ABTB_MAGIC, XFS_ABTC_MAGIC, XFS_BMAP_MAGIC, XFS_IBT_MAGIC,
 +	  XFS_FIBT_MAGIC },
 +	{ XFS_ABTB_CRC_MAGIC, XFS_ABTC_CRC_MAGIC,
 +	  XFS_BMAP_CRC_MAGIC, XFS_IBT_CRC_MAGIC, XFS_FIBT_CRC_MAGIC }
++=======
+ static const uint32_t xfs_magics[2][XFS_BTNUM_MAX] = {
+ 	{ XFS_ABTB_MAGIC, XFS_ABTC_MAGIC, 0, XFS_BMAP_MAGIC, XFS_IBT_MAGIC,
+ 	  XFS_FIBT_MAGIC, 0 },
+ 	{ XFS_ABTB_CRC_MAGIC, XFS_ABTC_CRC_MAGIC, XFS_RMAP_CRC_MAGIC,
+ 	  XFS_BMAP_CRC_MAGIC, XFS_IBT_CRC_MAGIC, XFS_FIBT_CRC_MAGIC,
+ 	  XFS_REFC_CRC_MAGIC }
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  };
  
- __uint32_t
+ uint32_t
  xfs_btree_magic(
  	int			crc,
  	xfs_btnum_t		btnum)
@@@ -4281,6 -4571,295 +4290,298 @@@ xfs_btree_compute_maxlevels
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Query a regular btree for all records overlapping a given interval.
+  * Start with a LE lookup of the key of low_rec and return all records
+  * until we find a record with a key greater than the key of high_rec.
+  */
+ STATIC int
+ xfs_btree_simple_query_range(
+ 	struct xfs_btree_cur		*cur,
+ 	union xfs_btree_key		*low_key,
+ 	union xfs_btree_key		*high_key,
+ 	xfs_btree_query_range_fn	fn,
+ 	void				*priv)
+ {
+ 	union xfs_btree_rec		*recp;
+ 	union xfs_btree_key		rec_key;
+ 	int64_t				diff;
+ 	int				stat;
+ 	bool				firstrec = true;
+ 	int				error;
+ 
+ 	ASSERT(cur->bc_ops->init_high_key_from_rec);
+ 	ASSERT(cur->bc_ops->diff_two_keys);
+ 
+ 	/*
+ 	 * Find the leftmost record.  The btree cursor must be set
+ 	 * to the low record used to generate low_key.
+ 	 */
+ 	stat = 0;
+ 	error = xfs_btree_lookup(cur, XFS_LOOKUP_LE, &stat);
+ 	if (error)
+ 		goto out;
+ 
+ 	/* Nothing?  See if there's anything to the right. */
+ 	if (!stat) {
+ 		error = xfs_btree_increment(cur, 0, &stat);
+ 		if (error)
+ 			goto out;
+ 	}
+ 
+ 	while (stat) {
+ 		/* Find the record. */
+ 		error = xfs_btree_get_rec(cur, &recp, &stat);
+ 		if (error || !stat)
+ 			break;
+ 
+ 		/* Skip if high_key(rec) < low_key. */
+ 		if (firstrec) {
+ 			cur->bc_ops->init_high_key_from_rec(&rec_key, recp);
+ 			firstrec = false;
+ 			diff = cur->bc_ops->diff_two_keys(cur, low_key,
+ 					&rec_key);
+ 			if (diff > 0)
+ 				goto advloop;
+ 		}
+ 
+ 		/* Stop if high_key < low_key(rec). */
+ 		cur->bc_ops->init_key_from_rec(&rec_key, recp);
+ 		diff = cur->bc_ops->diff_two_keys(cur, &rec_key, high_key);
+ 		if (diff > 0)
+ 			break;
+ 
+ 		/* Callback */
+ 		error = fn(cur, recp, priv);
+ 		if (error < 0 || error == XFS_BTREE_QUERY_RANGE_ABORT)
+ 			break;
+ 
+ advloop:
+ 		/* Move on to the next record. */
+ 		error = xfs_btree_increment(cur, 0, &stat);
+ 		if (error)
+ 			break;
+ 	}
+ 
+ out:
+ 	return error;
+ }
+ 
+ /*
+  * Query an overlapped interval btree for all records overlapping a given
+  * interval.  This function roughly follows the algorithm given in
+  * "Interval Trees" of _Introduction to Algorithms_, which is section
+  * 14.3 in the 2nd and 3rd editions.
+  *
+  * First, generate keys for the low and high records passed in.
+  *
+  * For any leaf node, generate the high and low keys for the record.
+  * If the record keys overlap with the query low/high keys, pass the
+  * record to the function iterator.
+  *
+  * For any internal node, compare the low and high keys of each
+  * pointer against the query low/high keys.  If there's an overlap,
+  * follow the pointer.
+  *
+  * As an optimization, we stop scanning a block when we find a low key
+  * that is greater than the query's high key.
+  */
+ STATIC int
+ xfs_btree_overlapped_query_range(
+ 	struct xfs_btree_cur		*cur,
+ 	union xfs_btree_key		*low_key,
+ 	union xfs_btree_key		*high_key,
+ 	xfs_btree_query_range_fn	fn,
+ 	void				*priv)
+ {
+ 	union xfs_btree_ptr		ptr;
+ 	union xfs_btree_ptr		*pp;
+ 	union xfs_btree_key		rec_key;
+ 	union xfs_btree_key		rec_hkey;
+ 	union xfs_btree_key		*lkp;
+ 	union xfs_btree_key		*hkp;
+ 	union xfs_btree_rec		*recp;
+ 	struct xfs_btree_block		*block;
+ 	int64_t				ldiff;
+ 	int64_t				hdiff;
+ 	int				level;
+ 	struct xfs_buf			*bp;
+ 	int				i;
+ 	int				error;
+ 
+ 	/* Load the root of the btree. */
+ 	level = cur->bc_nlevels - 1;
+ 	cur->bc_ops->init_ptr_from_cur(cur, &ptr);
+ 	error = xfs_btree_lookup_get_block(cur, level, &ptr, &block);
+ 	if (error)
+ 		return error;
+ 	xfs_btree_get_block(cur, level, &bp);
+ 	trace_xfs_btree_overlapped_query_range(cur, level, bp);
+ #ifdef DEBUG
+ 	error = xfs_btree_check_block(cur, block, level, bp);
+ 	if (error)
+ 		goto out;
+ #endif
+ 	cur->bc_ptrs[level] = 1;
+ 
+ 	while (level < cur->bc_nlevels) {
+ 		block = xfs_btree_get_block(cur, level, &bp);
+ 
+ 		/* End of node, pop back towards the root. */
+ 		if (cur->bc_ptrs[level] > be16_to_cpu(block->bb_numrecs)) {
+ pop_up:
+ 			if (level < cur->bc_nlevels - 1)
+ 				cur->bc_ptrs[level + 1]++;
+ 			level++;
+ 			continue;
+ 		}
+ 
+ 		if (level == 0) {
+ 			/* Handle a leaf node. */
+ 			recp = xfs_btree_rec_addr(cur, cur->bc_ptrs[0], block);
+ 
+ 			cur->bc_ops->init_high_key_from_rec(&rec_hkey, recp);
+ 			ldiff = cur->bc_ops->diff_two_keys(cur, &rec_hkey,
+ 					low_key);
+ 
+ 			cur->bc_ops->init_key_from_rec(&rec_key, recp);
+ 			hdiff = cur->bc_ops->diff_two_keys(cur, high_key,
+ 					&rec_key);
+ 
+ 			/*
+ 			 * If (record's high key >= query's low key) and
+ 			 *    (query's high key >= record's low key), then
+ 			 * this record overlaps the query range; callback.
+ 			 */
+ 			if (ldiff >= 0 && hdiff >= 0) {
+ 				error = fn(cur, recp, priv);
+ 				if (error < 0 ||
+ 				    error == XFS_BTREE_QUERY_RANGE_ABORT)
+ 					break;
+ 			} else if (hdiff < 0) {
+ 				/* Record is larger than high key; pop. */
+ 				goto pop_up;
+ 			}
+ 			cur->bc_ptrs[level]++;
+ 			continue;
+ 		}
+ 
+ 		/* Handle an internal node. */
+ 		lkp = xfs_btree_key_addr(cur, cur->bc_ptrs[level], block);
+ 		hkp = xfs_btree_high_key_addr(cur, cur->bc_ptrs[level], block);
+ 		pp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[level], block);
+ 
+ 		ldiff = cur->bc_ops->diff_two_keys(cur, hkp, low_key);
+ 		hdiff = cur->bc_ops->diff_two_keys(cur, high_key, lkp);
+ 
+ 		/*
+ 		 * If (pointer's high key >= query's low key) and
+ 		 *    (query's high key >= pointer's low key), then
+ 		 * this record overlaps the query range; follow pointer.
+ 		 */
+ 		if (ldiff >= 0 && hdiff >= 0) {
+ 			level--;
+ 			error = xfs_btree_lookup_get_block(cur, level, pp,
+ 					&block);
+ 			if (error)
+ 				goto out;
+ 			xfs_btree_get_block(cur, level, &bp);
+ 			trace_xfs_btree_overlapped_query_range(cur, level, bp);
+ #ifdef DEBUG
+ 			error = xfs_btree_check_block(cur, block, level, bp);
+ 			if (error)
+ 				goto out;
+ #endif
+ 			cur->bc_ptrs[level] = 1;
+ 			continue;
+ 		} else if (hdiff < 0) {
+ 			/* The low key is larger than the upper range; pop. */
+ 			goto pop_up;
+ 		}
+ 		cur->bc_ptrs[level]++;
+ 	}
+ 
+ out:
+ 	/*
+ 	 * If we don't end this function with the cursor pointing at a record
+ 	 * block, a subsequent non-error cursor deletion will not release
+ 	 * node-level buffers, causing a buffer leak.  This is quite possible
+ 	 * with a zero-results range query, so release the buffers if we
+ 	 * failed to return any results.
+ 	 */
+ 	if (cur->bc_bufs[0] == NULL) {
+ 		for (i = 0; i < cur->bc_nlevels; i++) {
+ 			if (cur->bc_bufs[i]) {
+ 				xfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);
+ 				cur->bc_bufs[i] = NULL;
+ 				cur->bc_ptrs[i] = 0;
+ 				cur->bc_ra[i] = 0;
+ 			}
+ 		}
+ 	}
+ 
+ 	return error;
+ }
+ 
+ /*
+  * Query a btree for all records overlapping a given interval of keys.  The
+  * supplied function will be called with each record found; return one of the
+  * XFS_BTREE_QUERY_RANGE_{CONTINUE,ABORT} values or the usual negative error
+  * code.  This function returns XFS_BTREE_QUERY_RANGE_ABORT, zero, or a
+  * negative error code.
+  */
+ int
+ xfs_btree_query_range(
+ 	struct xfs_btree_cur		*cur,
+ 	union xfs_btree_irec		*low_rec,
+ 	union xfs_btree_irec		*high_rec,
+ 	xfs_btree_query_range_fn	fn,
+ 	void				*priv)
+ {
+ 	union xfs_btree_rec		rec;
+ 	union xfs_btree_key		low_key;
+ 	union xfs_btree_key		high_key;
+ 
+ 	/* Find the keys of both ends of the interval. */
+ 	cur->bc_rec = *high_rec;
+ 	cur->bc_ops->init_rec_from_cur(cur, &rec);
+ 	cur->bc_ops->init_key_from_rec(&high_key, &rec);
+ 
+ 	cur->bc_rec = *low_rec;
+ 	cur->bc_ops->init_rec_from_cur(cur, &rec);
+ 	cur->bc_ops->init_key_from_rec(&low_key, &rec);
+ 
+ 	/* Enforce low key < high key. */
+ 	if (cur->bc_ops->diff_two_keys(cur, &low_key, &high_key) > 0)
+ 		return -EINVAL;
+ 
+ 	if (!(cur->bc_flags & XFS_BTREE_OVERLAPPING))
+ 		return xfs_btree_simple_query_range(cur, &low_key,
+ 				&high_key, fn, priv);
+ 	return xfs_btree_overlapped_query_range(cur, &low_key, &high_key,
+ 			fn, priv);
+ }
+ 
+ /* Query a btree for all records. */
+ int
+ xfs_btree_query_all(
+ 	struct xfs_btree_cur		*cur,
+ 	xfs_btree_query_range_fn	fn,
+ 	void				*priv)
+ {
+ 	union xfs_btree_key		low_key;
+ 	union xfs_btree_key		high_key;
+ 
+ 	memset(&cur->bc_rec, 0, sizeof(cur->bc_rec));
+ 	memset(&low_key, 0, sizeof(low_key));
+ 	memset(&high_key, 0xFF, sizeof(high_key));
+ 
+ 	return xfs_btree_simple_query_range(cur, &low_key, &high_key, fn, priv);
+ }
+ 
+ /*
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
   * Calculate the number of blocks needed to store a given number of records
   * in a short-format (per-AG metadata) btree.
   */
diff --cc fs/xfs/libxfs/xfs_btree.h
index 352598858d21,0a931f644103..000000000000
--- a/fs/xfs/libxfs/xfs_btree.h
+++ b/fs/xfs/libxfs/xfs_btree.h
@@@ -63,8 -73,10 +63,8 @@@ union xfs_btree_rec 
  #define	XFS_BTNUM_BMAP	((xfs_btnum_t)XFS_BTNUM_BMAPi)
  #define	XFS_BTNUM_INO	((xfs_btnum_t)XFS_BTNUM_INOi)
  #define	XFS_BTNUM_FINO	((xfs_btnum_t)XFS_BTNUM_FINOi)
 -#define	XFS_BTNUM_RMAP	((xfs_btnum_t)XFS_BTNUM_RMAPi)
 -#define	XFS_BTNUM_REFC	((xfs_btnum_t)XFS_BTNUM_REFCi)
  
- __uint32_t xfs_btree_magic(int crc, xfs_btnum_t btnum);
+ uint32_t xfs_btree_magic(int crc, xfs_btnum_t btnum);
  
  /*
   * For logging record fields.
@@@ -164,11 -146,21 +164,22 @@@ struct xfs_btree_ops 
  				     union xfs_btree_rec *rec);
  	void	(*init_ptr_from_cur)(struct xfs_btree_cur *cur,
  				     union xfs_btree_ptr *ptr);
 -	void	(*init_high_key_from_rec)(union xfs_btree_key *key,
 -					  union xfs_btree_rec *rec);
  
  	/* difference between key value and cursor value */
- 	__int64_t (*key_diff)(struct xfs_btree_cur *cur,
+ 	int64_t (*key_diff)(struct xfs_btree_cur *cur,
  			      union xfs_btree_key *key);
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Difference between key2 and key1 -- positive if key1 > key2,
+ 	 * negative if key1 < key2, and zero if equal.
+ 	 */
+ 	int64_t (*diff_two_keys)(struct xfs_btree_cur *cur,
+ 				   union xfs_btree_key *key1,
+ 				   union xfs_btree_key *key2);
+ 
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  	const struct xfs_buf_ops	*buf_ops;
  
  #if defined(DEBUG) || defined(XFS_WARN)
@@@ -215,19 -210,16 +226,19 @@@ typedef struct xfs_btree_cu
  	struct xfs_mount	*bc_mp;	/* file system mount struct */
  	const struct xfs_btree_ops *bc_ops;
  	uint			bc_flags; /* btree features - below */
 -	union xfs_btree_irec	bc_rec;	/* current insert/search record value */
 +	union {
 +		xfs_alloc_rec_incore_t	a;
 +		xfs_bmbt_irec_t		b;
 +		xfs_inobt_rec_incore_t	i;
 +	}		bc_rec;		/* current insert/search record value */
  	struct xfs_buf	*bc_bufs[XFS_BTREE_MAXLEVELS];	/* buf ptr per level */
  	int		bc_ptrs[XFS_BTREE_MAXLEVELS];	/* key/record # */
- 	__uint8_t	bc_ra[XFS_BTREE_MAXLEVELS];	/* readahead bits */
+ 	uint8_t		bc_ra[XFS_BTREE_MAXLEVELS];	/* readahead bits */
  #define	XFS_BTCUR_LEFTRA	1	/* left sibling has been read-ahead */
  #define	XFS_BTCUR_RIGHTRA	2	/* right sibling has been read-ahead */
- 	__uint8_t	bc_nlevels;	/* number of levels in the tree */
- 	__uint8_t	bc_blocklog;	/* log2(blocksize) of btree blocks */
+ 	uint8_t		bc_nlevels;	/* number of levels in the tree */
+ 	uint8_t		bc_blocklog;	/* log2(blocksize) of btree blocks */
  	xfs_btnum_t	bc_btnum;	/* identifies which btree type */
 -	int		bc_statoff;	/* offset of btre stats array */
  	union {
  		struct {			/* needed for BNO, CNT, INO */
  			struct xfs_buf	*agbp;	/* agf/agi buffer pointer */
diff --cc fs/xfs/libxfs/xfs_format.h
index 7adfccb0f769,e204a942e5bf..000000000000
--- a/fs/xfs/libxfs/xfs_format.h
+++ b/fs/xfs/libxfs/xfs_format.h
@@@ -1309,11 -1341,116 +1309,120 @@@ typedef __be32 xfs_inobt_ptr_t
  #define	XFS_FIBT_BLOCK(mp)		((xfs_agblock_t)(XFS_IBT_BLOCK(mp) + 1))
  
  /*
 - * Reverse mapping btree format definitions
 - *
 - * There is a btree for the reverse map per allocation group
 + * The first data block of an AG depends on whether the filesystem was formatted
 + * with the finobt feature. If so, account for the finobt reserved root btree
 + * block.
   */
++<<<<<<< HEAD
 +#define XFS_PREALLOC_BLOCKS(mp) \
++=======
+ #define	XFS_RMAP_CRC_MAGIC	0x524d4233	/* 'RMB3' */
+ 
+ /*
+  * Ownership info for an extent.  This is used to create reverse-mapping
+  * entries.
+  */
+ #define XFS_OWNER_INFO_ATTR_FORK	(1 << 0)
+ #define XFS_OWNER_INFO_BMBT_BLOCK	(1 << 1)
+ struct xfs_owner_info {
+ 	uint64_t		oi_owner;
+ 	xfs_fileoff_t		oi_offset;
+ 	unsigned int		oi_flags;
+ };
+ 
+ /*
+  * Special owner types.
+  *
+  * Seeing as we only support up to 8EB, we have the upper bit of the owner field
+  * to tell us we have a special owner value. We use these for static metadata
+  * allocated at mkfs/growfs time, as well as for freespace management metadata.
+  */
+ #define XFS_RMAP_OWN_NULL	(-1ULL)	/* No owner, for growfs */
+ #define XFS_RMAP_OWN_UNKNOWN	(-2ULL)	/* Unknown owner, for EFI recovery */
+ #define XFS_RMAP_OWN_FS		(-3ULL)	/* static fs metadata */
+ #define XFS_RMAP_OWN_LOG	(-4ULL)	/* static fs metadata */
+ #define XFS_RMAP_OWN_AG		(-5ULL)	/* AG freespace btree blocks */
+ #define XFS_RMAP_OWN_INOBT	(-6ULL)	/* Inode btree blocks */
+ #define XFS_RMAP_OWN_INODES	(-7ULL)	/* Inode chunk */
+ #define XFS_RMAP_OWN_REFC	(-8ULL) /* refcount tree */
+ #define XFS_RMAP_OWN_COW	(-9ULL) /* cow allocations */
+ #define XFS_RMAP_OWN_MIN	(-10ULL) /* guard */
+ 
+ #define XFS_RMAP_NON_INODE_OWNER(owner)	(!!((owner) & (1ULL << 63)))
+ 
+ /*
+  * Data record structure
+  */
+ struct xfs_rmap_rec {
+ 	__be32		rm_startblock;	/* extent start block */
+ 	__be32		rm_blockcount;	/* extent length */
+ 	__be64		rm_owner;	/* extent owner */
+ 	__be64		rm_offset;	/* offset within the owner */
+ };
+ 
+ /*
+  * rmap btree record
+  *  rm_offset:63 is the attribute fork flag
+  *  rm_offset:62 is the bmbt block flag
+  *  rm_offset:61 is the unwritten extent flag (same as l0:63 in bmbt)
+  *  rm_offset:54-60 aren't used and should be zero
+  *  rm_offset:0-53 is the block offset within the inode
+  */
+ #define XFS_RMAP_OFF_ATTR_FORK	((uint64_t)1ULL << 63)
+ #define XFS_RMAP_OFF_BMBT_BLOCK	((uint64_t)1ULL << 62)
+ #define XFS_RMAP_OFF_UNWRITTEN	((uint64_t)1ULL << 61)
+ 
+ #define XFS_RMAP_LEN_MAX	((uint32_t)~0U)
+ #define XFS_RMAP_OFF_FLAGS	(XFS_RMAP_OFF_ATTR_FORK | \
+ 				 XFS_RMAP_OFF_BMBT_BLOCK | \
+ 				 XFS_RMAP_OFF_UNWRITTEN)
+ #define XFS_RMAP_OFF_MASK	((uint64_t)0x3FFFFFFFFFFFFFULL)
+ 
+ #define XFS_RMAP_OFF(off)		((off) & XFS_RMAP_OFF_MASK)
+ 
+ #define XFS_RMAP_IS_BMBT_BLOCK(off)	(!!((off) & XFS_RMAP_OFF_BMBT_BLOCK))
+ #define XFS_RMAP_IS_ATTR_FORK(off)	(!!((off) & XFS_RMAP_OFF_ATTR_FORK))
+ #define XFS_RMAP_IS_UNWRITTEN(len)	(!!((off) & XFS_RMAP_OFF_UNWRITTEN))
+ 
+ #define RMAPBT_STARTBLOCK_BITLEN	32
+ #define RMAPBT_BLOCKCOUNT_BITLEN	32
+ #define RMAPBT_OWNER_BITLEN		64
+ #define RMAPBT_ATTRFLAG_BITLEN		1
+ #define RMAPBT_BMBTFLAG_BITLEN		1
+ #define RMAPBT_EXNTFLAG_BITLEN		1
+ #define RMAPBT_UNUSED_OFFSET_BITLEN	7
+ #define RMAPBT_OFFSET_BITLEN		54
+ 
+ #define XFS_RMAP_ATTR_FORK		(1 << 0)
+ #define XFS_RMAP_BMBT_BLOCK		(1 << 1)
+ #define XFS_RMAP_UNWRITTEN		(1 << 2)
+ #define XFS_RMAP_KEY_FLAGS		(XFS_RMAP_ATTR_FORK | \
+ 					 XFS_RMAP_BMBT_BLOCK)
+ #define XFS_RMAP_REC_FLAGS		(XFS_RMAP_UNWRITTEN)
+ struct xfs_rmap_irec {
+ 	xfs_agblock_t	rm_startblock;	/* extent start block */
+ 	xfs_extlen_t	rm_blockcount;	/* extent length */
+ 	uint64_t	rm_owner;	/* extent owner */
+ 	uint64_t	rm_offset;	/* offset within the owner */
+ 	unsigned int	rm_flags;	/* state flags */
+ };
+ 
+ /*
+  * Key structure
+  *
+  * We don't use the length for lookups
+  */
+ struct xfs_rmap_key {
+ 	__be32		rm_startblock;	/* extent start block */
+ 	__be64		rm_owner;	/* extent owner */
+ 	__be64		rm_offset;	/* offset within the owner */
+ } __attribute__((packed));
+ 
+ /* btree pointer type */
+ typedef __be32 xfs_rmap_ptr_t;
+ 
+ #define	XFS_RMAP_BLOCK(mp) \
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  	(xfs_sb_version_hasfinobt(&((mp)->m_sb)) ? \
  	 XFS_FIBT_BLOCK(mp) + 1 : \
  	 XFS_IBT_BLOCK(mp) + 1)
diff --cc fs/xfs/libxfs/xfs_inode_buf.h
index 958c54319b11,0827d7def1ce..000000000000
--- a/fs/xfs/libxfs/xfs_inode_buf.h
+++ b/fs/xfs/libxfs/xfs_inode_buf.h
@@@ -40,13 -40,14 +40,18 @@@ struct xfs_icdinode 
  	xfs_extlen_t	di_extsize;	/* basic/minimum extent size for file */
  	xfs_extnum_t	di_nextents;	/* number of extents in data fork */
  	xfs_aextnum_t	di_anextents;	/* number of extents in attribute fork*/
- 	__uint8_t	di_forkoff;	/* attr fork offs, <<3 for 64b align */
- 	__int8_t	di_aformat;	/* format of attr fork's data */
- 	__uint32_t	di_dmevmask;	/* DMIG event mask */
- 	__uint16_t	di_dmstate;	/* DMIG state info */
- 	__uint16_t	di_flags;	/* random flags, XFS_DIFLAG_... */
+ 	uint8_t		di_forkoff;	/* attr fork offs, <<3 for 64b align */
+ 	int8_t		di_aformat;	/* format of attr fork's data */
+ 	uint32_t	di_dmevmask;	/* DMIG event mask */
+ 	uint16_t	di_dmstate;	/* DMIG state info */
+ 	uint16_t	di_flags;	/* random flags, XFS_DIFLAG_... */
  
++<<<<<<< HEAD
 +	__uint64_t	di_flags2;	/* more random flags */
++=======
+ 	uint64_t	di_flags2;	/* more random flags */
+ 	uint32_t	di_cowextsize;	/* basic cow extent size for file */
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  
  	xfs_ictimestamp_t di_crtime;	/* time created */
  };
diff --cc fs/xfs/libxfs/xfs_log_format.h
index e5baba3c2443,8372e9bcd7b6..000000000000
--- a/fs/xfs/libxfs/xfs_log_format.h
+++ b/fs/xfs/libxfs/xfs_log_format.h
@@@ -401,11 -419,12 +401,17 @@@ struct xfs_log_dinode 
  	xfs_agino_t	di_next_unlinked;/* agi unlinked list ptr */
  
  	/* start of the extended dinode, writable fields */
- 	__uint32_t	di_crc;		/* CRC of the inode */
- 	__uint64_t	di_changecount;	/* number of attribute changes */
+ 	uint32_t	di_crc;		/* CRC of the inode */
+ 	uint64_t	di_changecount;	/* number of attribute changes */
  	xfs_lsn_t	di_lsn;		/* flush sequence */
++<<<<<<< HEAD
 +	__uint64_t	di_flags2;	/* more random flags */
 +	__uint8_t	di_pad2[16];	/* more padding for future expansion */
++=======
+ 	uint64_t	di_flags2;	/* more random flags */
+ 	uint32_t	di_cowextsize;	/* basic cow extent size for file */
+ 	uint8_t		di_pad2[12];	/* more padding for future expansion */
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  
  	/* fields only written to during inode creation */
  	xfs_ictimestamp_t di_crtime;	/* time created */
@@@ -604,6 -623,166 +610,169 @@@ typedef struct xfs_efd_log_format_64 
  } xfs_efd_log_format_64_t;
  
  /*
++<<<<<<< HEAD
++=======
+  * RUI/RUD (reverse mapping) log format definitions
+  */
+ struct xfs_map_extent {
+ 	uint64_t		me_owner;
+ 	uint64_t		me_startblock;
+ 	uint64_t		me_startoff;
+ 	uint32_t		me_len;
+ 	uint32_t		me_flags;
+ };
+ 
+ /* rmap me_flags: upper bits are flags, lower byte is type code */
+ #define XFS_RMAP_EXTENT_MAP		1
+ #define XFS_RMAP_EXTENT_MAP_SHARED	2
+ #define XFS_RMAP_EXTENT_UNMAP		3
+ #define XFS_RMAP_EXTENT_UNMAP_SHARED	4
+ #define XFS_RMAP_EXTENT_CONVERT		5
+ #define XFS_RMAP_EXTENT_CONVERT_SHARED	6
+ #define XFS_RMAP_EXTENT_ALLOC		7
+ #define XFS_RMAP_EXTENT_FREE		8
+ #define XFS_RMAP_EXTENT_TYPE_MASK	0xFF
+ 
+ #define XFS_RMAP_EXTENT_ATTR_FORK	(1U << 31)
+ #define XFS_RMAP_EXTENT_BMBT_BLOCK	(1U << 30)
+ #define XFS_RMAP_EXTENT_UNWRITTEN	(1U << 29)
+ 
+ #define XFS_RMAP_EXTENT_FLAGS		(XFS_RMAP_EXTENT_TYPE_MASK | \
+ 					 XFS_RMAP_EXTENT_ATTR_FORK | \
+ 					 XFS_RMAP_EXTENT_BMBT_BLOCK | \
+ 					 XFS_RMAP_EXTENT_UNWRITTEN)
+ 
+ /*
+  * This is the structure used to lay out an rui log item in the
+  * log.  The rui_extents field is a variable size array whose
+  * size is given by rui_nextents.
+  */
+ struct xfs_rui_log_format {
+ 	uint16_t		rui_type;	/* rui log item type */
+ 	uint16_t		rui_size;	/* size of this item */
+ 	uint32_t		rui_nextents;	/* # extents to free */
+ 	uint64_t		rui_id;		/* rui identifier */
+ 	struct xfs_map_extent	rui_extents[];	/* array of extents to rmap */
+ };
+ 
+ static inline size_t
+ xfs_rui_log_format_sizeof(
+ 	unsigned int		nr)
+ {
+ 	return sizeof(struct xfs_rui_log_format) +
+ 			nr * sizeof(struct xfs_map_extent);
+ }
+ 
+ /*
+  * This is the structure used to lay out an rud log item in the
+  * log.  The rud_extents array is a variable size array whose
+  * size is given by rud_nextents;
+  */
+ struct xfs_rud_log_format {
+ 	uint16_t		rud_type;	/* rud log item type */
+ 	uint16_t		rud_size;	/* size of this item */
+ 	uint32_t		__pad;
+ 	uint64_t		rud_rui_id;	/* id of corresponding rui */
+ };
+ 
+ /*
+  * CUI/CUD (refcount update) log format definitions
+  */
+ struct xfs_phys_extent {
+ 	uint64_t		pe_startblock;
+ 	uint32_t		pe_len;
+ 	uint32_t		pe_flags;
+ };
+ 
+ /* refcount pe_flags: upper bits are flags, lower byte is type code */
+ /* Type codes are taken directly from enum xfs_refcount_intent_type. */
+ #define XFS_REFCOUNT_EXTENT_TYPE_MASK	0xFF
+ 
+ #define XFS_REFCOUNT_EXTENT_FLAGS	(XFS_REFCOUNT_EXTENT_TYPE_MASK)
+ 
+ /*
+  * This is the structure used to lay out a cui log item in the
+  * log.  The cui_extents field is a variable size array whose
+  * size is given by cui_nextents.
+  */
+ struct xfs_cui_log_format {
+ 	uint16_t		cui_type;	/* cui log item type */
+ 	uint16_t		cui_size;	/* size of this item */
+ 	uint32_t		cui_nextents;	/* # extents to free */
+ 	uint64_t		cui_id;		/* cui identifier */
+ 	struct xfs_phys_extent	cui_extents[];	/* array of extents */
+ };
+ 
+ static inline size_t
+ xfs_cui_log_format_sizeof(
+ 	unsigned int		nr)
+ {
+ 	return sizeof(struct xfs_cui_log_format) +
+ 			nr * sizeof(struct xfs_phys_extent);
+ }
+ 
+ /*
+  * This is the structure used to lay out a cud log item in the
+  * log.  The cud_extents array is a variable size array whose
+  * size is given by cud_nextents;
+  */
+ struct xfs_cud_log_format {
+ 	uint16_t		cud_type;	/* cud log item type */
+ 	uint16_t		cud_size;	/* size of this item */
+ 	uint32_t		__pad;
+ 	uint64_t		cud_cui_id;	/* id of corresponding cui */
+ };
+ 
+ /*
+  * BUI/BUD (inode block mapping) log format definitions
+  */
+ 
+ /* bmbt me_flags: upper bits are flags, lower byte is type code */
+ /* Type codes are taken directly from enum xfs_bmap_intent_type. */
+ #define XFS_BMAP_EXTENT_TYPE_MASK	0xFF
+ 
+ #define XFS_BMAP_EXTENT_ATTR_FORK	(1U << 31)
+ #define XFS_BMAP_EXTENT_UNWRITTEN	(1U << 30)
+ 
+ #define XFS_BMAP_EXTENT_FLAGS		(XFS_BMAP_EXTENT_TYPE_MASK | \
+ 					 XFS_BMAP_EXTENT_ATTR_FORK | \
+ 					 XFS_BMAP_EXTENT_UNWRITTEN)
+ 
+ /*
+  * This is the structure used to lay out an bui log item in the
+  * log.  The bui_extents field is a variable size array whose
+  * size is given by bui_nextents.
+  */
+ struct xfs_bui_log_format {
+ 	uint16_t		bui_type;	/* bui log item type */
+ 	uint16_t		bui_size;	/* size of this item */
+ 	uint32_t		bui_nextents;	/* # extents to free */
+ 	uint64_t		bui_id;		/* bui identifier */
+ 	struct xfs_map_extent	bui_extents[];	/* array of extents to bmap */
+ };
+ 
+ static inline size_t
+ xfs_bui_log_format_sizeof(
+ 	unsigned int		nr)
+ {
+ 	return sizeof(struct xfs_bui_log_format) +
+ 			nr * sizeof(struct xfs_map_extent);
+ }
+ 
+ /*
+  * This is the structure used to lay out an bud log item in the
+  * log.  The bud_extents array is a variable size array whose
+  * size is given by bud_nextents;
+  */
+ struct xfs_bud_log_format {
+ 	uint16_t		bud_type;	/* bud log item type */
+ 	uint16_t		bud_size;	/* size of this item */
+ 	uint32_t		__pad;
+ 	uint64_t		bud_bui_id;	/* id of corresponding bui */
+ };
+ 
+ /*
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
   * Dquot Log format definitions.
   *
   * The first two fields must be the type and size fitting into
diff --cc fs/xfs/xfs_bmap_util.c
index 11ad9fb8bc15,0ea70a44c1a7..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -384,10 -388,12 +384,16 @@@ xfs_getbmapx_fix_eof_hole
  	struct getbmapx		*out,		/* output structure */
  	int			prealloced,	/* this is a file with
  						 * preallocated data space */
++<<<<<<< HEAD
 +	__int64_t		end,		/* last block requested */
 +	xfs_fsblock_t		startblock)
++=======
+ 	int64_t			end,		/* last block requested */
+ 	xfs_fsblock_t		startblock,
+ 	bool			moretocome)
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  {
- 	__int64_t		fixlen;
+ 	int64_t			fixlen;
  	xfs_mount_t		*mp;		/* file system mount point */
  	xfs_ifork_t		*ifp;		/* inode fork pointer */
  	xfs_extnum_t		lastx;		/* last extent pointer */
@@@ -1447,6 -1655,130 +1453,133 @@@ xfs_swap_extent_flush
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Move extents from one file to another, when rmap is enabled.
+  */
+ STATIC int
+ xfs_swap_extent_rmap(
+ 	struct xfs_trans		**tpp,
+ 	struct xfs_inode		*ip,
+ 	struct xfs_inode		*tip)
+ {
+ 	struct xfs_bmbt_irec		irec;
+ 	struct xfs_bmbt_irec		uirec;
+ 	struct xfs_bmbt_irec		tirec;
+ 	xfs_fileoff_t			offset_fsb;
+ 	xfs_fileoff_t			end_fsb;
+ 	xfs_filblks_t			count_fsb;
+ 	xfs_fsblock_t			firstfsb;
+ 	struct xfs_defer_ops		dfops;
+ 	int				error;
+ 	xfs_filblks_t			ilen;
+ 	xfs_filblks_t			rlen;
+ 	int				nimaps;
+ 	uint64_t			tip_flags2;
+ 
+ 	/*
+ 	 * If the source file has shared blocks, we must flag the donor
+ 	 * file as having shared blocks so that we get the shared-block
+ 	 * rmap functions when we go to fix up the rmaps.  The flags
+ 	 * will be switch for reals later.
+ 	 */
+ 	tip_flags2 = tip->i_d.di_flags2;
+ 	if (ip->i_d.di_flags2 & XFS_DIFLAG2_REFLINK)
+ 		tip->i_d.di_flags2 |= XFS_DIFLAG2_REFLINK;
+ 
+ 	offset_fsb = 0;
+ 	end_fsb = XFS_B_TO_FSB(ip->i_mount, i_size_read(VFS_I(ip)));
+ 	count_fsb = (xfs_filblks_t)(end_fsb - offset_fsb);
+ 
+ 	while (count_fsb) {
+ 		/* Read extent from the donor file */
+ 		nimaps = 1;
+ 		error = xfs_bmapi_read(tip, offset_fsb, count_fsb, &tirec,
+ 				&nimaps, 0);
+ 		if (error)
+ 			goto out;
+ 		ASSERT(nimaps == 1);
+ 		ASSERT(tirec.br_startblock != DELAYSTARTBLOCK);
+ 
+ 		trace_xfs_swap_extent_rmap_remap(tip, &tirec);
+ 		ilen = tirec.br_blockcount;
+ 
+ 		/* Unmap the old blocks in the source file. */
+ 		while (tirec.br_blockcount) {
+ 			xfs_defer_init(&dfops, &firstfsb);
+ 			trace_xfs_swap_extent_rmap_remap_piece(tip, &tirec);
+ 
+ 			/* Read extent from the source file */
+ 			nimaps = 1;
+ 			error = xfs_bmapi_read(ip, tirec.br_startoff,
+ 					tirec.br_blockcount, &irec,
+ 					&nimaps, 0);
+ 			if (error)
+ 				goto out_defer;
+ 			ASSERT(nimaps == 1);
+ 			ASSERT(tirec.br_startoff == irec.br_startoff);
+ 			trace_xfs_swap_extent_rmap_remap_piece(ip, &irec);
+ 
+ 			/* Trim the extent. */
+ 			uirec = tirec;
+ 			uirec.br_blockcount = rlen = min_t(xfs_filblks_t,
+ 					tirec.br_blockcount,
+ 					irec.br_blockcount);
+ 			trace_xfs_swap_extent_rmap_remap_piece(tip, &uirec);
+ 
+ 			/* Remove the mapping from the donor file. */
+ 			error = xfs_bmap_unmap_extent((*tpp)->t_mountp, &dfops,
+ 					tip, &uirec);
+ 			if (error)
+ 				goto out_defer;
+ 
+ 			/* Remove the mapping from the source file. */
+ 			error = xfs_bmap_unmap_extent((*tpp)->t_mountp, &dfops,
+ 					ip, &irec);
+ 			if (error)
+ 				goto out_defer;
+ 
+ 			/* Map the donor file's blocks into the source file. */
+ 			error = xfs_bmap_map_extent((*tpp)->t_mountp, &dfops,
+ 					ip, &uirec);
+ 			if (error)
+ 				goto out_defer;
+ 
+ 			/* Map the source file's blocks into the donor file. */
+ 			error = xfs_bmap_map_extent((*tpp)->t_mountp, &dfops,
+ 					tip, &irec);
+ 			if (error)
+ 				goto out_defer;
+ 
+ 			error = xfs_defer_finish(tpp, &dfops, ip);
+ 			if (error)
+ 				goto out_defer;
+ 
+ 			tirec.br_startoff += rlen;
+ 			if (tirec.br_startblock != HOLESTARTBLOCK &&
+ 			    tirec.br_startblock != DELAYSTARTBLOCK)
+ 				tirec.br_startblock += rlen;
+ 			tirec.br_blockcount -= rlen;
+ 		}
+ 
+ 		/* Roll on... */
+ 		count_fsb -= ilen;
+ 		offset_fsb += ilen;
+ 	}
+ 
+ 	tip->i_d.di_flags2 = tip_flags2;
+ 	return 0;
+ 
+ out_defer:
+ 	xfs_defer_cancel(&dfops);
+ out:
+ 	trace_xfs_swap_extent_rmap_error(ip, error, _RET_IP_);
+ 	tip->i_d.di_flags2 = tip_flags2;
+ 	return error;
+ }
+ 
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  /* Swap the extents of two files by swapping data forks. */
  STATIC int
  xfs_swap_extent_forks(
@@@ -1460,7 -1791,8 +1593,12 @@@
  	struct xfs_ifork	tempifp, *ifp, *tifp;
  	int			aforkblks = 0;
  	int			taforkblks = 0;
++<<<<<<< HEAD
 +	__uint64_t		tmp;
++=======
+ 	xfs_extnum_t		nextents;
+ 	uint64_t		tmp;
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  	int			error;
  
  	/*
@@@ -1594,6 -1926,9 +1732,12 @@@ xfs_swap_extents
  	int			src_log_flags, target_log_flags;
  	int			error = 0;
  	int			lock_flags;
++<<<<<<< HEAD
++=======
+ 	struct xfs_ifork	*cowfp;
+ 	uint64_t		f;
+ 	int			resblks;
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  
  	/*
  	 * Lock the inodes against other IO, page faults and truncate to
diff --cc fs/xfs/xfs_inode.c
index 71c58a693e70,ffbfe7d8bc6d..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -835,8 -854,9 +835,14 @@@ xfs_ialloc
  	if (ip->i_d.di_version == 3) {
  		inode->i_version = 1;
  		ip->i_d.di_flags2 = 0;
++<<<<<<< HEAD
 +		ip->i_d.di_crtime.t_sec = (__int32_t)tv.tv_sec;
 +		ip->i_d.di_crtime.t_nsec = (__int32_t)tv.tv_nsec;
++=======
+ 		ip->i_d.di_cowextsize = 0;
+ 		ip->i_d.di_crtime.t_sec = (int32_t)tv.tv_sec;
+ 		ip->i_d.di_crtime.t_nsec = (int32_t)tv.tv_nsec;
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  	}
  
  
diff --cc fs/xfs/xfs_log_recover.c
index 87d59329233d,e19b20c87f35..000000000000
--- a/fs/xfs/xfs_log_recover.c
+++ b/fs/xfs/xfs_log_recover.c
@@@ -3447,6 -3464,335 +3447,338 @@@ xlog_recover_efd_pass2
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * This routine is called to create an in-core extent rmap update
+  * item from the rui format structure which was logged on disk.
+  * It allocates an in-core rui, copies the extents from the format
+  * structure into it, and adds the rui to the AIL with the given
+  * LSN.
+  */
+ STATIC int
+ xlog_recover_rui_pass2(
+ 	struct xlog			*log,
+ 	struct xlog_recover_item	*item,
+ 	xfs_lsn_t			lsn)
+ {
+ 	int				error;
+ 	struct xfs_mount		*mp = log->l_mp;
+ 	struct xfs_rui_log_item		*ruip;
+ 	struct xfs_rui_log_format	*rui_formatp;
+ 
+ 	rui_formatp = item->ri_buf[0].i_addr;
+ 
+ 	ruip = xfs_rui_init(mp, rui_formatp->rui_nextents);
+ 	error = xfs_rui_copy_format(&item->ri_buf[0], &ruip->rui_format);
+ 	if (error) {
+ 		xfs_rui_item_free(ruip);
+ 		return error;
+ 	}
+ 	atomic_set(&ruip->rui_next_extent, rui_formatp->rui_nextents);
+ 
+ 	spin_lock(&log->l_ailp->xa_lock);
+ 	/*
+ 	 * The RUI has two references. One for the RUD and one for RUI to ensure
+ 	 * it makes it into the AIL. Insert the RUI into the AIL directly and
+ 	 * drop the RUI reference. Note that xfs_trans_ail_update() drops the
+ 	 * AIL lock.
+ 	 */
+ 	xfs_trans_ail_update(log->l_ailp, &ruip->rui_item, lsn);
+ 	xfs_rui_release(ruip);
+ 	return 0;
+ }
+ 
+ 
+ /*
+  * This routine is called when an RUD format structure is found in a committed
+  * transaction in the log. Its purpose is to cancel the corresponding RUI if it
+  * was still in the log. To do this it searches the AIL for the RUI with an id
+  * equal to that in the RUD format structure. If we find it we drop the RUD
+  * reference, which removes the RUI from the AIL and frees it.
+  */
+ STATIC int
+ xlog_recover_rud_pass2(
+ 	struct xlog			*log,
+ 	struct xlog_recover_item	*item)
+ {
+ 	struct xfs_rud_log_format	*rud_formatp;
+ 	struct xfs_rui_log_item		*ruip = NULL;
+ 	struct xfs_log_item		*lip;
+ 	uint64_t			rui_id;
+ 	struct xfs_ail_cursor		cur;
+ 	struct xfs_ail			*ailp = log->l_ailp;
+ 
+ 	rud_formatp = item->ri_buf[0].i_addr;
+ 	ASSERT(item->ri_buf[0].i_len == sizeof(struct xfs_rud_log_format));
+ 	rui_id = rud_formatp->rud_rui_id;
+ 
+ 	/*
+ 	 * Search for the RUI with the id in the RUD format structure in the
+ 	 * AIL.
+ 	 */
+ 	spin_lock(&ailp->xa_lock);
+ 	lip = xfs_trans_ail_cursor_first(ailp, &cur, 0);
+ 	while (lip != NULL) {
+ 		if (lip->li_type == XFS_LI_RUI) {
+ 			ruip = (struct xfs_rui_log_item *)lip;
+ 			if (ruip->rui_format.rui_id == rui_id) {
+ 				/*
+ 				 * Drop the RUD reference to the RUI. This
+ 				 * removes the RUI from the AIL and frees it.
+ 				 */
+ 				spin_unlock(&ailp->xa_lock);
+ 				xfs_rui_release(ruip);
+ 				spin_lock(&ailp->xa_lock);
+ 				break;
+ 			}
+ 		}
+ 		lip = xfs_trans_ail_cursor_next(ailp, &cur);
+ 	}
+ 
+ 	xfs_trans_ail_cursor_done(&cur);
+ 	spin_unlock(&ailp->xa_lock);
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Copy an CUI format buffer from the given buf, and into the destination
+  * CUI format structure.  The CUI/CUD items were designed not to need any
+  * special alignment handling.
+  */
+ static int
+ xfs_cui_copy_format(
+ 	struct xfs_log_iovec		*buf,
+ 	struct xfs_cui_log_format	*dst_cui_fmt)
+ {
+ 	struct xfs_cui_log_format	*src_cui_fmt;
+ 	uint				len;
+ 
+ 	src_cui_fmt = buf->i_addr;
+ 	len = xfs_cui_log_format_sizeof(src_cui_fmt->cui_nextents);
+ 
+ 	if (buf->i_len == len) {
+ 		memcpy(dst_cui_fmt, src_cui_fmt, len);
+ 		return 0;
+ 	}
+ 	return -EFSCORRUPTED;
+ }
+ 
+ /*
+  * This routine is called to create an in-core extent refcount update
+  * item from the cui format structure which was logged on disk.
+  * It allocates an in-core cui, copies the extents from the format
+  * structure into it, and adds the cui to the AIL with the given
+  * LSN.
+  */
+ STATIC int
+ xlog_recover_cui_pass2(
+ 	struct xlog			*log,
+ 	struct xlog_recover_item	*item,
+ 	xfs_lsn_t			lsn)
+ {
+ 	int				error;
+ 	struct xfs_mount		*mp = log->l_mp;
+ 	struct xfs_cui_log_item		*cuip;
+ 	struct xfs_cui_log_format	*cui_formatp;
+ 
+ 	cui_formatp = item->ri_buf[0].i_addr;
+ 
+ 	cuip = xfs_cui_init(mp, cui_formatp->cui_nextents);
+ 	error = xfs_cui_copy_format(&item->ri_buf[0], &cuip->cui_format);
+ 	if (error) {
+ 		xfs_cui_item_free(cuip);
+ 		return error;
+ 	}
+ 	atomic_set(&cuip->cui_next_extent, cui_formatp->cui_nextents);
+ 
+ 	spin_lock(&log->l_ailp->xa_lock);
+ 	/*
+ 	 * The CUI has two references. One for the CUD and one for CUI to ensure
+ 	 * it makes it into the AIL. Insert the CUI into the AIL directly and
+ 	 * drop the CUI reference. Note that xfs_trans_ail_update() drops the
+ 	 * AIL lock.
+ 	 */
+ 	xfs_trans_ail_update(log->l_ailp, &cuip->cui_item, lsn);
+ 	xfs_cui_release(cuip);
+ 	return 0;
+ }
+ 
+ 
+ /*
+  * This routine is called when an CUD format structure is found in a committed
+  * transaction in the log. Its purpose is to cancel the corresponding CUI if it
+  * was still in the log. To do this it searches the AIL for the CUI with an id
+  * equal to that in the CUD format structure. If we find it we drop the CUD
+  * reference, which removes the CUI from the AIL and frees it.
+  */
+ STATIC int
+ xlog_recover_cud_pass2(
+ 	struct xlog			*log,
+ 	struct xlog_recover_item	*item)
+ {
+ 	struct xfs_cud_log_format	*cud_formatp;
+ 	struct xfs_cui_log_item		*cuip = NULL;
+ 	struct xfs_log_item		*lip;
+ 	uint64_t			cui_id;
+ 	struct xfs_ail_cursor		cur;
+ 	struct xfs_ail			*ailp = log->l_ailp;
+ 
+ 	cud_formatp = item->ri_buf[0].i_addr;
+ 	if (item->ri_buf[0].i_len != sizeof(struct xfs_cud_log_format))
+ 		return -EFSCORRUPTED;
+ 	cui_id = cud_formatp->cud_cui_id;
+ 
+ 	/*
+ 	 * Search for the CUI with the id in the CUD format structure in the
+ 	 * AIL.
+ 	 */
+ 	spin_lock(&ailp->xa_lock);
+ 	lip = xfs_trans_ail_cursor_first(ailp, &cur, 0);
+ 	while (lip != NULL) {
+ 		if (lip->li_type == XFS_LI_CUI) {
+ 			cuip = (struct xfs_cui_log_item *)lip;
+ 			if (cuip->cui_format.cui_id == cui_id) {
+ 				/*
+ 				 * Drop the CUD reference to the CUI. This
+ 				 * removes the CUI from the AIL and frees it.
+ 				 */
+ 				spin_unlock(&ailp->xa_lock);
+ 				xfs_cui_release(cuip);
+ 				spin_lock(&ailp->xa_lock);
+ 				break;
+ 			}
+ 		}
+ 		lip = xfs_trans_ail_cursor_next(ailp, &cur);
+ 	}
+ 
+ 	xfs_trans_ail_cursor_done(&cur);
+ 	spin_unlock(&ailp->xa_lock);
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Copy an BUI format buffer from the given buf, and into the destination
+  * BUI format structure.  The BUI/BUD items were designed not to need any
+  * special alignment handling.
+  */
+ static int
+ xfs_bui_copy_format(
+ 	struct xfs_log_iovec		*buf,
+ 	struct xfs_bui_log_format	*dst_bui_fmt)
+ {
+ 	struct xfs_bui_log_format	*src_bui_fmt;
+ 	uint				len;
+ 
+ 	src_bui_fmt = buf->i_addr;
+ 	len = xfs_bui_log_format_sizeof(src_bui_fmt->bui_nextents);
+ 
+ 	if (buf->i_len == len) {
+ 		memcpy(dst_bui_fmt, src_bui_fmt, len);
+ 		return 0;
+ 	}
+ 	return -EFSCORRUPTED;
+ }
+ 
+ /*
+  * This routine is called to create an in-core extent bmap update
+  * item from the bui format structure which was logged on disk.
+  * It allocates an in-core bui, copies the extents from the format
+  * structure into it, and adds the bui to the AIL with the given
+  * LSN.
+  */
+ STATIC int
+ xlog_recover_bui_pass2(
+ 	struct xlog			*log,
+ 	struct xlog_recover_item	*item,
+ 	xfs_lsn_t			lsn)
+ {
+ 	int				error;
+ 	struct xfs_mount		*mp = log->l_mp;
+ 	struct xfs_bui_log_item		*buip;
+ 	struct xfs_bui_log_format	*bui_formatp;
+ 
+ 	bui_formatp = item->ri_buf[0].i_addr;
+ 
+ 	if (bui_formatp->bui_nextents != XFS_BUI_MAX_FAST_EXTENTS)
+ 		return -EFSCORRUPTED;
+ 	buip = xfs_bui_init(mp);
+ 	error = xfs_bui_copy_format(&item->ri_buf[0], &buip->bui_format);
+ 	if (error) {
+ 		xfs_bui_item_free(buip);
+ 		return error;
+ 	}
+ 	atomic_set(&buip->bui_next_extent, bui_formatp->bui_nextents);
+ 
+ 	spin_lock(&log->l_ailp->xa_lock);
+ 	/*
+ 	 * The RUI has two references. One for the RUD and one for RUI to ensure
+ 	 * it makes it into the AIL. Insert the RUI into the AIL directly and
+ 	 * drop the RUI reference. Note that xfs_trans_ail_update() drops the
+ 	 * AIL lock.
+ 	 */
+ 	xfs_trans_ail_update(log->l_ailp, &buip->bui_item, lsn);
+ 	xfs_bui_release(buip);
+ 	return 0;
+ }
+ 
+ 
+ /*
+  * This routine is called when an BUD format structure is found in a committed
+  * transaction in the log. Its purpose is to cancel the corresponding BUI if it
+  * was still in the log. To do this it searches the AIL for the BUI with an id
+  * equal to that in the BUD format structure. If we find it we drop the BUD
+  * reference, which removes the BUI from the AIL and frees it.
+  */
+ STATIC int
+ xlog_recover_bud_pass2(
+ 	struct xlog			*log,
+ 	struct xlog_recover_item	*item)
+ {
+ 	struct xfs_bud_log_format	*bud_formatp;
+ 	struct xfs_bui_log_item		*buip = NULL;
+ 	struct xfs_log_item		*lip;
+ 	uint64_t			bui_id;
+ 	struct xfs_ail_cursor		cur;
+ 	struct xfs_ail			*ailp = log->l_ailp;
+ 
+ 	bud_formatp = item->ri_buf[0].i_addr;
+ 	if (item->ri_buf[0].i_len != sizeof(struct xfs_bud_log_format))
+ 		return -EFSCORRUPTED;
+ 	bui_id = bud_formatp->bud_bui_id;
+ 
+ 	/*
+ 	 * Search for the BUI with the id in the BUD format structure in the
+ 	 * AIL.
+ 	 */
+ 	spin_lock(&ailp->xa_lock);
+ 	lip = xfs_trans_ail_cursor_first(ailp, &cur, 0);
+ 	while (lip != NULL) {
+ 		if (lip->li_type == XFS_LI_BUI) {
+ 			buip = (struct xfs_bui_log_item *)lip;
+ 			if (buip->bui_format.bui_id == bui_id) {
+ 				/*
+ 				 * Drop the BUD reference to the BUI. This
+ 				 * removes the BUI from the AIL and frees it.
+ 				 */
+ 				spin_unlock(&ailp->xa_lock);
+ 				xfs_bui_release(buip);
+ 				spin_lock(&ailp->xa_lock);
+ 				break;
+ 			}
+ 		}
+ 		lip = xfs_trans_ail_cursor_next(ailp, &cur);
+ 	}
+ 
+ 	xfs_trans_ail_cursor_done(&cur);
+ 	spin_unlock(&ailp->xa_lock);
+ 
+ 	return 0;
+ }
+ 
+ /*
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
   * This routine is called when an inode create format structure is found in a
   * committed transaction in the log.  It's purpose is to initialise the inodes
   * being allocated on disk. This requires us to get inode cluster buffers that
diff --cc fs/xfs/xfs_mount.h
index 364cc3b0b7a2,305d95394e2d..000000000000
--- a/fs/xfs/xfs_mount.h
+++ b/fs/xfs/xfs_mount.h
@@@ -130,7 -139,8 +130,12 @@@ typedef struct xfs_mount 
  	struct mutex		m_growlock;	/* growfs mutex */
  	int			m_fixedfsid[2];	/* unchanged for life of FS */
  	uint			m_dmevmask;	/* DMI events for this FS */
++<<<<<<< HEAD
 +	__uint64_t		m_flags;	/* global mount flags */
++=======
+ 	uint64_t		m_flags;	/* global mount flags */
+ 	bool			m_inotbt_nores; /* no per-AG finobt resv. */
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  	int			m_ialloc_inos;	/* inodes in inode allocation */
  	int			m_ialloc_blks;	/* blocks in inode allocation */
  	int			m_ialloc_min_blks;/* min blocks in sparse inode
@@@ -182,7 -194,8 +187,12 @@@
  	 * ever support shrinks it would have to be persisted in addition
  	 * to various other kinds of pain inflicted on the pNFS server.
  	 */
++<<<<<<< HEAD
 +	__uint32_t		m_generation;
++=======
+ 	uint32_t		m_generation;
+ 
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  	bool			m_fail_unmount;
  #ifdef DEBUG
  	/*
@@@ -373,11 -404,37 +383,22 @@@ typedef struct xfs_perag 
  	/* for rcu-safe freeing */
  	struct rcu_head	rcu_head;
  	int		pagb_count;	/* pagb slots in use */
++<<<<<<< HEAD
++=======
+ 
+ 	/* Blocks reserved for all kinds of metadata. */
+ 	struct xfs_ag_resv	pag_meta_resv;
+ 	/* Blocks reserved for just AGFL-based metadata. */
+ 	struct xfs_ag_resv	pag_agfl_resv;
+ 
+ 	/* reference count */
+ 	uint8_t			pagf_refcount_level;
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  } xfs_perag_t;
  
 -static inline struct xfs_ag_resv *
 -xfs_perag_resv(
 -	struct xfs_perag	*pag,
 -	enum xfs_ag_resv_type	type)
 -{
 -	switch (type) {
 -	case XFS_AG_RESV_METADATA:
 -		return &pag->pag_meta_resv;
 -	case XFS_AG_RESV_AGFL:
 -		return &pag->pag_agfl_resv;
 -	default:
 -		return NULL;
 -	}
 -}
 -
 -int xfs_buf_hash_init(xfs_perag_t *pag);
 -void xfs_buf_hash_destroy(xfs_perag_t *pag);
 -
  extern void	xfs_uuid_table_free(void);
  extern int	xfs_log_sbcount(xfs_mount_t *);
- extern __uint64_t xfs_default_resblks(xfs_mount_t *mp);
+ extern uint64_t xfs_default_resblks(xfs_mount_t *mp);
  extern int	xfs_mountfs(xfs_mount_t *mp);
  extern int	xfs_initialize_perag(xfs_mount_t *mp, xfs_agnumber_t agcount,
  				     xfs_agnumber_t *maxagi);
diff --cc fs/xfs/xfs_stats.h
index 483b0eff1988,f64d0ae345c4..000000000000
--- a/fs/xfs/xfs_stats.h
+++ b/fs/xfs/xfs_stats.h
@@@ -24,195 -24,171 +24,236 @@@
  /*
   * XFS global statistics
   */
 -struct __xfsstats {
 +struct xfsstats {
  # define XFSSTAT_END_EXTENT_ALLOC	4
- 	__uint32_t		xs_allocx;
- 	__uint32_t		xs_allocb;
- 	__uint32_t		xs_freex;
- 	__uint32_t		xs_freeb;
+ 	uint32_t		xs_allocx;
+ 	uint32_t		xs_allocb;
+ 	uint32_t		xs_freex;
+ 	uint32_t		xs_freeb;
  # define XFSSTAT_END_ALLOC_BTREE	(XFSSTAT_END_EXTENT_ALLOC+4)
- 	__uint32_t		xs_abt_lookup;
- 	__uint32_t		xs_abt_compare;
- 	__uint32_t		xs_abt_insrec;
- 	__uint32_t		xs_abt_delrec;
+ 	uint32_t		xs_abt_lookup;
+ 	uint32_t		xs_abt_compare;
+ 	uint32_t		xs_abt_insrec;
+ 	uint32_t		xs_abt_delrec;
  # define XFSSTAT_END_BLOCK_MAPPING	(XFSSTAT_END_ALLOC_BTREE+7)
- 	__uint32_t		xs_blk_mapr;
- 	__uint32_t		xs_blk_mapw;
- 	__uint32_t		xs_blk_unmap;
- 	__uint32_t		xs_add_exlist;
- 	__uint32_t		xs_del_exlist;
- 	__uint32_t		xs_look_exlist;
- 	__uint32_t		xs_cmp_exlist;
+ 	uint32_t		xs_blk_mapr;
+ 	uint32_t		xs_blk_mapw;
+ 	uint32_t		xs_blk_unmap;
+ 	uint32_t		xs_add_exlist;
+ 	uint32_t		xs_del_exlist;
+ 	uint32_t		xs_look_exlist;
+ 	uint32_t		xs_cmp_exlist;
  # define XFSSTAT_END_BLOCK_MAP_BTREE	(XFSSTAT_END_BLOCK_MAPPING+4)
- 	__uint32_t		xs_bmbt_lookup;
- 	__uint32_t		xs_bmbt_compare;
- 	__uint32_t		xs_bmbt_insrec;
- 	__uint32_t		xs_bmbt_delrec;
+ 	uint32_t		xs_bmbt_lookup;
+ 	uint32_t		xs_bmbt_compare;
+ 	uint32_t		xs_bmbt_insrec;
+ 	uint32_t		xs_bmbt_delrec;
  # define XFSSTAT_END_DIRECTORY_OPS	(XFSSTAT_END_BLOCK_MAP_BTREE+4)
- 	__uint32_t		xs_dir_lookup;
- 	__uint32_t		xs_dir_create;
- 	__uint32_t		xs_dir_remove;
- 	__uint32_t		xs_dir_getdents;
+ 	uint32_t		xs_dir_lookup;
+ 	uint32_t		xs_dir_create;
+ 	uint32_t		xs_dir_remove;
+ 	uint32_t		xs_dir_getdents;
  # define XFSSTAT_END_TRANSACTIONS	(XFSSTAT_END_DIRECTORY_OPS+3)
- 	__uint32_t		xs_trans_sync;
- 	__uint32_t		xs_trans_async;
- 	__uint32_t		xs_trans_empty;
+ 	uint32_t		xs_trans_sync;
+ 	uint32_t		xs_trans_async;
+ 	uint32_t		xs_trans_empty;
  # define XFSSTAT_END_INODE_OPS		(XFSSTAT_END_TRANSACTIONS+7)
- 	__uint32_t		xs_ig_attempts;
- 	__uint32_t		xs_ig_found;
- 	__uint32_t		xs_ig_frecycle;
- 	__uint32_t		xs_ig_missed;
- 	__uint32_t		xs_ig_dup;
- 	__uint32_t		xs_ig_reclaims;
- 	__uint32_t		xs_ig_attrchg;
+ 	uint32_t		xs_ig_attempts;
+ 	uint32_t		xs_ig_found;
+ 	uint32_t		xs_ig_frecycle;
+ 	uint32_t		xs_ig_missed;
+ 	uint32_t		xs_ig_dup;
+ 	uint32_t		xs_ig_reclaims;
+ 	uint32_t		xs_ig_attrchg;
  # define XFSSTAT_END_LOG_OPS		(XFSSTAT_END_INODE_OPS+5)
- 	__uint32_t		xs_log_writes;
- 	__uint32_t		xs_log_blocks;
- 	__uint32_t		xs_log_noiclogs;
- 	__uint32_t		xs_log_force;
- 	__uint32_t		xs_log_force_sleep;
+ 	uint32_t		xs_log_writes;
+ 	uint32_t		xs_log_blocks;
+ 	uint32_t		xs_log_noiclogs;
+ 	uint32_t		xs_log_force;
+ 	uint32_t		xs_log_force_sleep;
  # define XFSSTAT_END_TAIL_PUSHING	(XFSSTAT_END_LOG_OPS+10)
- 	__uint32_t		xs_try_logspace;
- 	__uint32_t		xs_sleep_logspace;
- 	__uint32_t		xs_push_ail;
- 	__uint32_t		xs_push_ail_success;
- 	__uint32_t		xs_push_ail_pushbuf;
- 	__uint32_t		xs_push_ail_pinned;
- 	__uint32_t		xs_push_ail_locked;
- 	__uint32_t		xs_push_ail_flushing;
- 	__uint32_t		xs_push_ail_restarts;
- 	__uint32_t		xs_push_ail_flush;
+ 	uint32_t		xs_try_logspace;
+ 	uint32_t		xs_sleep_logspace;
+ 	uint32_t		xs_push_ail;
+ 	uint32_t		xs_push_ail_success;
+ 	uint32_t		xs_push_ail_pushbuf;
+ 	uint32_t		xs_push_ail_pinned;
+ 	uint32_t		xs_push_ail_locked;
+ 	uint32_t		xs_push_ail_flushing;
+ 	uint32_t		xs_push_ail_restarts;
+ 	uint32_t		xs_push_ail_flush;
  # define XFSSTAT_END_WRITE_CONVERT	(XFSSTAT_END_TAIL_PUSHING+2)
- 	__uint32_t		xs_xstrat_quick;
- 	__uint32_t		xs_xstrat_split;
+ 	uint32_t		xs_xstrat_quick;
+ 	uint32_t		xs_xstrat_split;
  # define XFSSTAT_END_READ_WRITE_OPS	(XFSSTAT_END_WRITE_CONVERT+2)
- 	__uint32_t		xs_write_calls;
- 	__uint32_t		xs_read_calls;
+ 	uint32_t		xs_write_calls;
+ 	uint32_t		xs_read_calls;
  # define XFSSTAT_END_ATTRIBUTE_OPS	(XFSSTAT_END_READ_WRITE_OPS+4)
- 	__uint32_t		xs_attr_get;
- 	__uint32_t		xs_attr_set;
- 	__uint32_t		xs_attr_remove;
- 	__uint32_t		xs_attr_list;
+ 	uint32_t		xs_attr_get;
+ 	uint32_t		xs_attr_set;
+ 	uint32_t		xs_attr_remove;
+ 	uint32_t		xs_attr_list;
  # define XFSSTAT_END_INODE_CLUSTER	(XFSSTAT_END_ATTRIBUTE_OPS+3)
- 	__uint32_t		xs_iflush_count;
- 	__uint32_t		xs_icluster_flushcnt;
- 	__uint32_t		xs_icluster_flushinode;
+ 	uint32_t		xs_iflush_count;
+ 	uint32_t		xs_icluster_flushcnt;
+ 	uint32_t		xs_icluster_flushinode;
  # define XFSSTAT_END_VNODE_OPS		(XFSSTAT_END_INODE_CLUSTER+8)
- 	__uint32_t		vn_active;	/* # vnodes not on free lists */
- 	__uint32_t		vn_alloc;	/* # times vn_alloc called */
- 	__uint32_t		vn_get;		/* # times vn_get called */
- 	__uint32_t		vn_hold;	/* # times vn_hold called */
- 	__uint32_t		vn_rele;	/* # times vn_rele called */
- 	__uint32_t		vn_reclaim;	/* # times vn_reclaim called */
- 	__uint32_t		vn_remove;	/* # times vn_remove called */
- 	__uint32_t		vn_free;	/* # times vn_free called */
+ 	uint32_t		vn_active;	/* # vnodes not on free lists */
+ 	uint32_t		vn_alloc;	/* # times vn_alloc called */
+ 	uint32_t		vn_get;		/* # times vn_get called */
+ 	uint32_t		vn_hold;	/* # times vn_hold called */
+ 	uint32_t		vn_rele;	/* # times vn_rele called */
+ 	uint32_t		vn_reclaim;	/* # times vn_reclaim called */
+ 	uint32_t		vn_remove;	/* # times vn_remove called */
+ 	uint32_t		vn_free;	/* # times vn_free called */
  #define XFSSTAT_END_BUF			(XFSSTAT_END_VNODE_OPS+9)
- 	__uint32_t		xb_get;
- 	__uint32_t		xb_create;
- 	__uint32_t		xb_get_locked;
- 	__uint32_t		xb_get_locked_waited;
- 	__uint32_t		xb_busy_locked;
- 	__uint32_t		xb_miss_locked;
- 	__uint32_t		xb_page_retries;
- 	__uint32_t		xb_page_found;
- 	__uint32_t		xb_get_read;
+ 	uint32_t		xb_get;
+ 	uint32_t		xb_create;
+ 	uint32_t		xb_get_locked;
+ 	uint32_t		xb_get_locked_waited;
+ 	uint32_t		xb_busy_locked;
+ 	uint32_t		xb_miss_locked;
+ 	uint32_t		xb_page_retries;
+ 	uint32_t		xb_page_found;
+ 	uint32_t		xb_get_read;
  /* Version 2 btree counters */
++<<<<<<< HEAD
 +#define XFSSTAT_END_ABTB_V2		(XFSSTAT_END_BUF+15)
 +	__uint32_t		xs_abtb_2_lookup;
 +	__uint32_t		xs_abtb_2_compare;
 +	__uint32_t		xs_abtb_2_insrec;
 +	__uint32_t		xs_abtb_2_delrec;
 +	__uint32_t		xs_abtb_2_newroot;
 +	__uint32_t		xs_abtb_2_killroot;
 +	__uint32_t		xs_abtb_2_increment;
 +	__uint32_t		xs_abtb_2_decrement;
 +	__uint32_t		xs_abtb_2_lshift;
 +	__uint32_t		xs_abtb_2_rshift;
 +	__uint32_t		xs_abtb_2_split;
 +	__uint32_t		xs_abtb_2_join;
 +	__uint32_t		xs_abtb_2_alloc;
 +	__uint32_t		xs_abtb_2_free;
 +	__uint32_t		xs_abtb_2_moves;
 +#define XFSSTAT_END_ABTC_V2		(XFSSTAT_END_ABTB_V2+15)
 +	__uint32_t		xs_abtc_2_lookup;
 +	__uint32_t		xs_abtc_2_compare;
 +	__uint32_t		xs_abtc_2_insrec;
 +	__uint32_t		xs_abtc_2_delrec;
 +	__uint32_t		xs_abtc_2_newroot;
 +	__uint32_t		xs_abtc_2_killroot;
 +	__uint32_t		xs_abtc_2_increment;
 +	__uint32_t		xs_abtc_2_decrement;
 +	__uint32_t		xs_abtc_2_lshift;
 +	__uint32_t		xs_abtc_2_rshift;
 +	__uint32_t		xs_abtc_2_split;
 +	__uint32_t		xs_abtc_2_join;
 +	__uint32_t		xs_abtc_2_alloc;
 +	__uint32_t		xs_abtc_2_free;
 +	__uint32_t		xs_abtc_2_moves;
 +#define XFSSTAT_END_BMBT_V2		(XFSSTAT_END_ABTC_V2+15)
 +	__uint32_t		xs_bmbt_2_lookup;
 +	__uint32_t		xs_bmbt_2_compare;
 +	__uint32_t		xs_bmbt_2_insrec;
 +	__uint32_t		xs_bmbt_2_delrec;
 +	__uint32_t		xs_bmbt_2_newroot;
 +	__uint32_t		xs_bmbt_2_killroot;
 +	__uint32_t		xs_bmbt_2_increment;
 +	__uint32_t		xs_bmbt_2_decrement;
 +	__uint32_t		xs_bmbt_2_lshift;
 +	__uint32_t		xs_bmbt_2_rshift;
 +	__uint32_t		xs_bmbt_2_split;
 +	__uint32_t		xs_bmbt_2_join;
 +	__uint32_t		xs_bmbt_2_alloc;
 +	__uint32_t		xs_bmbt_2_free;
 +	__uint32_t		xs_bmbt_2_moves;
 +#define XFSSTAT_END_IBT_V2		(XFSSTAT_END_BMBT_V2+15)
 +	__uint32_t		xs_ibt_2_lookup;
 +	__uint32_t		xs_ibt_2_compare;
 +	__uint32_t		xs_ibt_2_insrec;
 +	__uint32_t		xs_ibt_2_delrec;
 +	__uint32_t		xs_ibt_2_newroot;
 +	__uint32_t		xs_ibt_2_killroot;
 +	__uint32_t		xs_ibt_2_increment;
 +	__uint32_t		xs_ibt_2_decrement;
 +	__uint32_t		xs_ibt_2_lshift;
 +	__uint32_t		xs_ibt_2_rshift;
 +	__uint32_t		xs_ibt_2_split;
 +	__uint32_t		xs_ibt_2_join;
 +	__uint32_t		xs_ibt_2_alloc;
 +	__uint32_t		xs_ibt_2_free;
 +	__uint32_t		xs_ibt_2_moves;
 +#define XFSSTAT_END_FIBT_V2		(XFSSTAT_END_IBT_V2+15)
 +	__uint32_t		xs_fibt_2_lookup;
 +	__uint32_t		xs_fibt_2_compare;
 +	__uint32_t		xs_fibt_2_insrec;
 +	__uint32_t		xs_fibt_2_delrec;
 +	__uint32_t		xs_fibt_2_newroot;
 +	__uint32_t		xs_fibt_2_killroot;
 +	__uint32_t		xs_fibt_2_increment;
 +	__uint32_t		xs_fibt_2_decrement;
 +	__uint32_t		xs_fibt_2_lshift;
 +	__uint32_t		xs_fibt_2_rshift;
 +	__uint32_t		xs_fibt_2_split;
 +	__uint32_t		xs_fibt_2_join;
 +	__uint32_t		xs_fibt_2_alloc;
 +	__uint32_t		xs_fibt_2_free;
 +	__uint32_t		xs_fibt_2_moves;
 +#define XFSSTAT_END_XQMSTAT		(XFSSTAT_END_FIBT_V2+6)
 +	__uint32_t		xs_qm_dqreclaims;
 +	__uint32_t		xs_qm_dqreclaim_misses;
 +	__uint32_t		xs_qm_dquot_dups;
 +	__uint32_t		xs_qm_dqcachemisses;
 +	__uint32_t		xs_qm_dqcachehits;
 +	__uint32_t		xs_qm_dqwants;
++=======
+ #define XFSSTAT_END_ABTB_V2		(XFSSTAT_END_BUF + __XBTS_MAX)
+ 	uint32_t		xs_abtb_2[__XBTS_MAX];
+ #define XFSSTAT_END_ABTC_V2		(XFSSTAT_END_ABTB_V2 + __XBTS_MAX)
+ 	uint32_t		xs_abtc_2[__XBTS_MAX];
+ #define XFSSTAT_END_BMBT_V2		(XFSSTAT_END_ABTC_V2 + __XBTS_MAX)
+ 	uint32_t		xs_bmbt_2[__XBTS_MAX];
+ #define XFSSTAT_END_IBT_V2		(XFSSTAT_END_BMBT_V2 + __XBTS_MAX)
+ 	uint32_t		xs_ibt_2[__XBTS_MAX];
+ #define XFSSTAT_END_FIBT_V2		(XFSSTAT_END_IBT_V2 + __XBTS_MAX)
+ 	uint32_t		xs_fibt_2[__XBTS_MAX];
+ #define XFSSTAT_END_RMAP_V2		(XFSSTAT_END_FIBT_V2 + __XBTS_MAX)
+ 	uint32_t		xs_rmap_2[__XBTS_MAX];
+ #define XFSSTAT_END_REFCOUNT		(XFSSTAT_END_RMAP_V2 + __XBTS_MAX)
+ 	uint32_t		xs_refcbt_2[__XBTS_MAX];
+ #define XFSSTAT_END_XQMSTAT		(XFSSTAT_END_REFCOUNT + 6)
+ 	uint32_t		xs_qm_dqreclaims;
+ 	uint32_t		xs_qm_dqreclaim_misses;
+ 	uint32_t		xs_qm_dquot_dups;
+ 	uint32_t		xs_qm_dqcachemisses;
+ 	uint32_t		xs_qm_dqcachehits;
+ 	uint32_t		xs_qm_dqwants;
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  #define XFSSTAT_END_QM			(XFSSTAT_END_XQMSTAT+2)
- 	__uint32_t		xs_qm_dquot;
- 	__uint32_t		xs_qm_dquot_unused;
+ 	uint32_t		xs_qm_dquot;
+ 	uint32_t		xs_qm_dquot_unused;
  /* Extra precision counters */
- 	__uint64_t		xs_xstrat_bytes;
- 	__uint64_t		xs_write_bytes;
- 	__uint64_t		xs_read_bytes;
+ 	uint64_t		xs_xstrat_bytes;
+ 	uint64_t		xs_write_bytes;
+ 	uint64_t		xs_read_bytes;
  };
  
++<<<<<<< HEAD
++=======
+ struct xfsstats {
+ 	union {
+ 		struct __xfsstats	s;
+ 		uint32_t		a[XFSSTAT_END_XQMSTAT];
+ 	};
+ };
+ 
+ /*
+  * simple wrapper for getting the array index of s struct member offset
+  */
+ #define XFS_STATS_CALC_INDEX(member)	\
+ 	(offsetof(struct __xfsstats, member) / (int)sizeof(uint32_t))
+ 
+ 
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  int xfs_stats_format(struct xfsstats __percpu *stats, char *buf);
  void xfs_stats_clearall(struct xfsstats __percpu *stats);
  extern struct xstats xfsstats;
diff --cc fs/xfs/xfs_super.c
index 675b7328631c,a19aab897c9b..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -1096,13 -1087,13 +1096,21 @@@ xfs_fs_statfs
  {
  	struct xfs_mount	*mp = XFS_M(dentry->d_sb);
  	xfs_sb_t		*sbp = &mp->m_sb;
++<<<<<<< HEAD
 +	struct xfs_inode	*ip = XFS_I(dentry->d_inode);
 +	__uint64_t		fakeinos, id;
 +	__uint64_t		icount;
 +	__uint64_t		ifree;
 +	__uint64_t		fdblocks;
++=======
+ 	struct xfs_inode	*ip = XFS_I(d_inode(dentry));
+ 	uint64_t		fakeinos, id;
+ 	uint64_t		icount;
+ 	uint64_t		ifree;
+ 	uint64_t		fdblocks;
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  	xfs_extlen_t		lsize;
- 	__int64_t		ffree;
+ 	int64_t			ffree;
  
  	statp->f_type = XFS_SB_MAGIC;
  	statp->f_namelen = MAXNAMELEN - 1;
diff --cc fs/xfs/xfs_trace.h
index 9b67d179b1aa,bcc3cdf8e1c5..000000000000
--- a/fs/xfs/xfs_trace.h
+++ b/fs/xfs/xfs_trace.h
@@@ -2395,6 -2423,892 +2395,895 @@@ DEFINE_MAP_EXTENT_DEFERRED_EVENT(xfs_de
  DEFINE_BMAP_FREE_DEFERRED_EVENT(xfs_bmap_free_defer);
  DEFINE_BMAP_FREE_DEFERRED_EVENT(xfs_bmap_free_deferred);
  
++<<<<<<< HEAD
++=======
+ /* rmap tracepoints */
+ DECLARE_EVENT_CLASS(xfs_rmap_class,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno,
+ 		 xfs_agblock_t agbno, xfs_extlen_t len, bool unwritten,
+ 		 struct xfs_owner_info *oinfo),
+ 	TP_ARGS(mp, agno, agbno, len, unwritten, oinfo),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_agblock_t, agbno)
+ 		__field(xfs_extlen_t, len)
+ 		__field(uint64_t, owner)
+ 		__field(uint64_t, offset)
+ 		__field(unsigned long, flags)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->agbno = agbno;
+ 		__entry->len = len;
+ 		__entry->owner = oinfo->oi_owner;
+ 		__entry->offset = oinfo->oi_offset;
+ 		__entry->flags = oinfo->oi_flags;
+ 		if (unwritten)
+ 			__entry->flags |= XFS_RMAP_UNWRITTEN;
+ 	),
+ 	TP_printk("dev %d:%d agno %u agbno %u len %u owner %lld offset %llu flags 0x%lx",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->agbno,
+ 		  __entry->len,
+ 		  __entry->owner,
+ 		  __entry->offset,
+ 		  __entry->flags)
+ );
+ #define DEFINE_RMAP_EVENT(name) \
+ DEFINE_EVENT(xfs_rmap_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, \
+ 		 xfs_agblock_t agbno, xfs_extlen_t len, bool unwritten, \
+ 		 struct xfs_owner_info *oinfo), \
+ 	TP_ARGS(mp, agno, agbno, len, unwritten, oinfo))
+ 
+ /* simple AG-based error/%ip tracepoint class */
+ DECLARE_EVENT_CLASS(xfs_ag_error_class,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, int error,
+ 		 unsigned long caller_ip),
+ 	TP_ARGS(mp, agno, error, caller_ip),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(int, error)
+ 		__field(unsigned long, caller_ip)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->error = error;
+ 		__entry->caller_ip = caller_ip;
+ 	),
+ 	TP_printk("dev %d:%d agno %u error %d caller %ps",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->error,
+ 		  (char *)__entry->caller_ip)
+ );
+ 
+ #define DEFINE_AG_ERROR_EVENT(name) \
+ DEFINE_EVENT(xfs_ag_error_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, int error, \
+ 		 unsigned long caller_ip), \
+ 	TP_ARGS(mp, agno, error, caller_ip))
+ 
+ DEFINE_RMAP_EVENT(xfs_rmap_unmap);
+ DEFINE_RMAP_EVENT(xfs_rmap_unmap_done);
+ DEFINE_AG_ERROR_EVENT(xfs_rmap_unmap_error);
+ DEFINE_RMAP_EVENT(xfs_rmap_map);
+ DEFINE_RMAP_EVENT(xfs_rmap_map_done);
+ DEFINE_AG_ERROR_EVENT(xfs_rmap_map_error);
+ DEFINE_RMAP_EVENT(xfs_rmap_convert);
+ DEFINE_RMAP_EVENT(xfs_rmap_convert_done);
+ DEFINE_AG_ERROR_EVENT(xfs_rmap_convert_error);
+ DEFINE_AG_ERROR_EVENT(xfs_rmap_convert_state);
+ 
+ DECLARE_EVENT_CLASS(xfs_rmapbt_class,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno,
+ 		 xfs_agblock_t agbno, xfs_extlen_t len,
+ 		 uint64_t owner, uint64_t offset, unsigned int flags),
+ 	TP_ARGS(mp, agno, agbno, len, owner, offset, flags),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_agblock_t, agbno)
+ 		__field(xfs_extlen_t, len)
+ 		__field(uint64_t, owner)
+ 		__field(uint64_t, offset)
+ 		__field(unsigned int, flags)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->agbno = agbno;
+ 		__entry->len = len;
+ 		__entry->owner = owner;
+ 		__entry->offset = offset;
+ 		__entry->flags = flags;
+ 	),
+ 	TP_printk("dev %d:%d agno %u agbno %u len %u owner %lld offset %llu flags 0x%x",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->agbno,
+ 		  __entry->len,
+ 		  __entry->owner,
+ 		  __entry->offset,
+ 		  __entry->flags)
+ );
+ #define DEFINE_RMAPBT_EVENT(name) \
+ DEFINE_EVENT(xfs_rmapbt_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, \
+ 		 xfs_agblock_t agbno, xfs_extlen_t len, \
+ 		 uint64_t owner, uint64_t offset, unsigned int flags), \
+ 	TP_ARGS(mp, agno, agbno, len, owner, offset, flags))
+ 
+ #define DEFINE_RMAP_DEFERRED_EVENT DEFINE_MAP_EXTENT_DEFERRED_EVENT
+ DEFINE_RMAP_DEFERRED_EVENT(xfs_rmap_defer);
+ DEFINE_RMAP_DEFERRED_EVENT(xfs_rmap_deferred);
+ 
+ DEFINE_BUSY_EVENT(xfs_rmapbt_alloc_block);
+ DEFINE_BUSY_EVENT(xfs_rmapbt_free_block);
+ DEFINE_RMAPBT_EVENT(xfs_rmap_update);
+ DEFINE_RMAPBT_EVENT(xfs_rmap_insert);
+ DEFINE_RMAPBT_EVENT(xfs_rmap_delete);
+ DEFINE_AG_ERROR_EVENT(xfs_rmap_insert_error);
+ DEFINE_AG_ERROR_EVENT(xfs_rmap_delete_error);
+ DEFINE_AG_ERROR_EVENT(xfs_rmap_update_error);
+ 
+ DEFINE_RMAPBT_EVENT(xfs_rmap_find_left_neighbor_candidate);
+ DEFINE_RMAPBT_EVENT(xfs_rmap_find_left_neighbor_query);
+ DEFINE_RMAPBT_EVENT(xfs_rmap_lookup_le_range_candidate);
+ DEFINE_RMAPBT_EVENT(xfs_rmap_lookup_le_range);
+ DEFINE_RMAPBT_EVENT(xfs_rmap_lookup_le_range_result);
+ DEFINE_RMAPBT_EVENT(xfs_rmap_find_right_neighbor_result);
+ DEFINE_RMAPBT_EVENT(xfs_rmap_find_left_neighbor_result);
+ 
+ /* deferred bmbt updates */
+ #define DEFINE_BMAP_DEFERRED_EVENT	DEFINE_RMAP_DEFERRED_EVENT
+ DEFINE_BMAP_DEFERRED_EVENT(xfs_bmap_defer);
+ DEFINE_BMAP_DEFERRED_EVENT(xfs_bmap_deferred);
+ 
+ /* per-AG reservation */
+ DECLARE_EVENT_CLASS(xfs_ag_resv_class,
+ 	TP_PROTO(struct xfs_perag *pag, enum xfs_ag_resv_type resv,
+ 		 xfs_extlen_t len),
+ 	TP_ARGS(pag, resv, len),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(int, resv)
+ 		__field(xfs_extlen_t, freeblks)
+ 		__field(xfs_extlen_t, flcount)
+ 		__field(xfs_extlen_t, reserved)
+ 		__field(xfs_extlen_t, asked)
+ 		__field(xfs_extlen_t, len)
+ 	),
+ 	TP_fast_assign(
+ 		struct xfs_ag_resv	*r = xfs_perag_resv(pag, resv);
+ 
+ 		__entry->dev = pag->pag_mount->m_super->s_dev;
+ 		__entry->agno = pag->pag_agno;
+ 		__entry->resv = resv;
+ 		__entry->freeblks = pag->pagf_freeblks;
+ 		__entry->flcount = pag->pagf_flcount;
+ 		__entry->reserved = r ? r->ar_reserved : 0;
+ 		__entry->asked = r ? r->ar_asked : 0;
+ 		__entry->len = len;
+ 	),
+ 	TP_printk("dev %d:%d agno %u resv %d freeblks %u flcount %u "
+ 		  "resv %u ask %u len %u",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->resv,
+ 		  __entry->freeblks,
+ 		  __entry->flcount,
+ 		  __entry->reserved,
+ 		  __entry->asked,
+ 		  __entry->len)
+ )
+ #define DEFINE_AG_RESV_EVENT(name) \
+ DEFINE_EVENT(xfs_ag_resv_class, name, \
+ 	TP_PROTO(struct xfs_perag *pag, enum xfs_ag_resv_type type, \
+ 		 xfs_extlen_t len), \
+ 	TP_ARGS(pag, type, len))
+ 
+ /* per-AG reservation tracepoints */
+ DEFINE_AG_RESV_EVENT(xfs_ag_resv_init);
+ DEFINE_AG_RESV_EVENT(xfs_ag_resv_free);
+ DEFINE_AG_RESV_EVENT(xfs_ag_resv_alloc_extent);
+ DEFINE_AG_RESV_EVENT(xfs_ag_resv_free_extent);
+ DEFINE_AG_RESV_EVENT(xfs_ag_resv_critical);
+ DEFINE_AG_RESV_EVENT(xfs_ag_resv_needed);
+ 
+ DEFINE_AG_ERROR_EVENT(xfs_ag_resv_free_error);
+ DEFINE_AG_ERROR_EVENT(xfs_ag_resv_init_error);
+ 
+ /* refcount tracepoint classes */
+ 
+ /* reuse the discard trace class for agbno/aglen-based traces */
+ #define DEFINE_AG_EXTENT_EVENT(name) DEFINE_DISCARD_EVENT(name)
+ 
+ /* ag btree lookup tracepoint class */
+ #define XFS_AG_BTREE_CMP_FORMAT_STR \
+ 	{ XFS_LOOKUP_EQ,	"eq" }, \
+ 	{ XFS_LOOKUP_LE,	"le" }, \
+ 	{ XFS_LOOKUP_GE,	"ge" }
+ DECLARE_EVENT_CLASS(xfs_ag_btree_lookup_class,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno,
+ 		 xfs_agblock_t agbno, xfs_lookup_t dir),
+ 	TP_ARGS(mp, agno, agbno, dir),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_agblock_t, agbno)
+ 		__field(xfs_lookup_t, dir)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->agbno = agbno;
+ 		__entry->dir = dir;
+ 	),
+ 	TP_printk("dev %d:%d agno %u agbno %u cmp %s(%d)",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->agbno,
+ 		  __print_symbolic(__entry->dir, XFS_AG_BTREE_CMP_FORMAT_STR),
+ 		  __entry->dir)
+ )
+ 
+ #define DEFINE_AG_BTREE_LOOKUP_EVENT(name) \
+ DEFINE_EVENT(xfs_ag_btree_lookup_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, \
+ 		 xfs_agblock_t agbno, xfs_lookup_t dir), \
+ 	TP_ARGS(mp, agno, agbno, dir))
+ 
+ /* single-rcext tracepoint class */
+ DECLARE_EVENT_CLASS(xfs_refcount_extent_class,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno,
+ 		 struct xfs_refcount_irec *irec),
+ 	TP_ARGS(mp, agno, irec),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_agblock_t, startblock)
+ 		__field(xfs_extlen_t, blockcount)
+ 		__field(xfs_nlink_t, refcount)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->startblock = irec->rc_startblock;
+ 		__entry->blockcount = irec->rc_blockcount;
+ 		__entry->refcount = irec->rc_refcount;
+ 	),
+ 	TP_printk("dev %d:%d agno %u agbno %u len %u refcount %u",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->startblock,
+ 		  __entry->blockcount,
+ 		  __entry->refcount)
+ )
+ 
+ #define DEFINE_REFCOUNT_EXTENT_EVENT(name) \
+ DEFINE_EVENT(xfs_refcount_extent_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, \
+ 		 struct xfs_refcount_irec *irec), \
+ 	TP_ARGS(mp, agno, irec))
+ 
+ /* single-rcext and an agbno tracepoint class */
+ DECLARE_EVENT_CLASS(xfs_refcount_extent_at_class,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno,
+ 		 struct xfs_refcount_irec *irec, xfs_agblock_t agbno),
+ 	TP_ARGS(mp, agno, irec, agbno),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_agblock_t, startblock)
+ 		__field(xfs_extlen_t, blockcount)
+ 		__field(xfs_nlink_t, refcount)
+ 		__field(xfs_agblock_t, agbno)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->startblock = irec->rc_startblock;
+ 		__entry->blockcount = irec->rc_blockcount;
+ 		__entry->refcount = irec->rc_refcount;
+ 		__entry->agbno = agbno;
+ 	),
+ 	TP_printk("dev %d:%d agno %u agbno %u len %u refcount %u @ agbno %u",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->startblock,
+ 		  __entry->blockcount,
+ 		  __entry->refcount,
+ 		  __entry->agbno)
+ )
+ 
+ #define DEFINE_REFCOUNT_EXTENT_AT_EVENT(name) \
+ DEFINE_EVENT(xfs_refcount_extent_at_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, \
+ 		 struct xfs_refcount_irec *irec, xfs_agblock_t agbno), \
+ 	TP_ARGS(mp, agno, irec, agbno))
+ 
+ /* double-rcext tracepoint class */
+ DECLARE_EVENT_CLASS(xfs_refcount_double_extent_class,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno,
+ 		 struct xfs_refcount_irec *i1, struct xfs_refcount_irec *i2),
+ 	TP_ARGS(mp, agno, i1, i2),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_agblock_t, i1_startblock)
+ 		__field(xfs_extlen_t, i1_blockcount)
+ 		__field(xfs_nlink_t, i1_refcount)
+ 		__field(xfs_agblock_t, i2_startblock)
+ 		__field(xfs_extlen_t, i2_blockcount)
+ 		__field(xfs_nlink_t, i2_refcount)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->i1_startblock = i1->rc_startblock;
+ 		__entry->i1_blockcount = i1->rc_blockcount;
+ 		__entry->i1_refcount = i1->rc_refcount;
+ 		__entry->i2_startblock = i2->rc_startblock;
+ 		__entry->i2_blockcount = i2->rc_blockcount;
+ 		__entry->i2_refcount = i2->rc_refcount;
+ 	),
+ 	TP_printk("dev %d:%d agno %u agbno %u len %u refcount %u -- "
+ 		  "agbno %u len %u refcount %u",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->i1_startblock,
+ 		  __entry->i1_blockcount,
+ 		  __entry->i1_refcount,
+ 		  __entry->i2_startblock,
+ 		  __entry->i2_blockcount,
+ 		  __entry->i2_refcount)
+ )
+ 
+ #define DEFINE_REFCOUNT_DOUBLE_EXTENT_EVENT(name) \
+ DEFINE_EVENT(xfs_refcount_double_extent_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, \
+ 		 struct xfs_refcount_irec *i1, struct xfs_refcount_irec *i2), \
+ 	TP_ARGS(mp, agno, i1, i2))
+ 
+ /* double-rcext and an agbno tracepoint class */
+ DECLARE_EVENT_CLASS(xfs_refcount_double_extent_at_class,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno,
+ 		 struct xfs_refcount_irec *i1, struct xfs_refcount_irec *i2,
+ 		 xfs_agblock_t agbno),
+ 	TP_ARGS(mp, agno, i1, i2, agbno),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_agblock_t, i1_startblock)
+ 		__field(xfs_extlen_t, i1_blockcount)
+ 		__field(xfs_nlink_t, i1_refcount)
+ 		__field(xfs_agblock_t, i2_startblock)
+ 		__field(xfs_extlen_t, i2_blockcount)
+ 		__field(xfs_nlink_t, i2_refcount)
+ 		__field(xfs_agblock_t, agbno)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->i1_startblock = i1->rc_startblock;
+ 		__entry->i1_blockcount = i1->rc_blockcount;
+ 		__entry->i1_refcount = i1->rc_refcount;
+ 		__entry->i2_startblock = i2->rc_startblock;
+ 		__entry->i2_blockcount = i2->rc_blockcount;
+ 		__entry->i2_refcount = i2->rc_refcount;
+ 		__entry->agbno = agbno;
+ 	),
+ 	TP_printk("dev %d:%d agno %u agbno %u len %u refcount %u -- "
+ 		  "agbno %u len %u refcount %u @ agbno %u",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->i1_startblock,
+ 		  __entry->i1_blockcount,
+ 		  __entry->i1_refcount,
+ 		  __entry->i2_startblock,
+ 		  __entry->i2_blockcount,
+ 		  __entry->i2_refcount,
+ 		  __entry->agbno)
+ )
+ 
+ #define DEFINE_REFCOUNT_DOUBLE_EXTENT_AT_EVENT(name) \
+ DEFINE_EVENT(xfs_refcount_double_extent_at_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, \
+ 		 struct xfs_refcount_irec *i1, struct xfs_refcount_irec *i2, \
+ 		 xfs_agblock_t agbno), \
+ 	TP_ARGS(mp, agno, i1, i2, agbno))
+ 
+ /* triple-rcext tracepoint class */
+ DECLARE_EVENT_CLASS(xfs_refcount_triple_extent_class,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno,
+ 		 struct xfs_refcount_irec *i1, struct xfs_refcount_irec *i2,
+ 		 struct xfs_refcount_irec *i3),
+ 	TP_ARGS(mp, agno, i1, i2, i3),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_agblock_t, i1_startblock)
+ 		__field(xfs_extlen_t, i1_blockcount)
+ 		__field(xfs_nlink_t, i1_refcount)
+ 		__field(xfs_agblock_t, i2_startblock)
+ 		__field(xfs_extlen_t, i2_blockcount)
+ 		__field(xfs_nlink_t, i2_refcount)
+ 		__field(xfs_agblock_t, i3_startblock)
+ 		__field(xfs_extlen_t, i3_blockcount)
+ 		__field(xfs_nlink_t, i3_refcount)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->i1_startblock = i1->rc_startblock;
+ 		__entry->i1_blockcount = i1->rc_blockcount;
+ 		__entry->i1_refcount = i1->rc_refcount;
+ 		__entry->i2_startblock = i2->rc_startblock;
+ 		__entry->i2_blockcount = i2->rc_blockcount;
+ 		__entry->i2_refcount = i2->rc_refcount;
+ 		__entry->i3_startblock = i3->rc_startblock;
+ 		__entry->i3_blockcount = i3->rc_blockcount;
+ 		__entry->i3_refcount = i3->rc_refcount;
+ 	),
+ 	TP_printk("dev %d:%d agno %u agbno %u len %u refcount %u -- "
+ 		  "agbno %u len %u refcount %u -- "
+ 		  "agbno %u len %u refcount %u",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->agno,
+ 		  __entry->i1_startblock,
+ 		  __entry->i1_blockcount,
+ 		  __entry->i1_refcount,
+ 		  __entry->i2_startblock,
+ 		  __entry->i2_blockcount,
+ 		  __entry->i2_refcount,
+ 		  __entry->i3_startblock,
+ 		  __entry->i3_blockcount,
+ 		  __entry->i3_refcount)
+ );
+ 
+ #define DEFINE_REFCOUNT_TRIPLE_EXTENT_EVENT(name) \
+ DEFINE_EVENT(xfs_refcount_triple_extent_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno, \
+ 		 struct xfs_refcount_irec *i1, struct xfs_refcount_irec *i2, \
+ 		 struct xfs_refcount_irec *i3), \
+ 	TP_ARGS(mp, agno, i1, i2, i3))
+ 
+ /* refcount btree tracepoints */
+ DEFINE_BUSY_EVENT(xfs_refcountbt_alloc_block);
+ DEFINE_BUSY_EVENT(xfs_refcountbt_free_block);
+ DEFINE_AG_BTREE_LOOKUP_EVENT(xfs_refcount_lookup);
+ DEFINE_REFCOUNT_EXTENT_EVENT(xfs_refcount_get);
+ DEFINE_REFCOUNT_EXTENT_EVENT(xfs_refcount_update);
+ DEFINE_REFCOUNT_EXTENT_EVENT(xfs_refcount_insert);
+ DEFINE_REFCOUNT_EXTENT_EVENT(xfs_refcount_delete);
+ DEFINE_AG_ERROR_EVENT(xfs_refcount_insert_error);
+ DEFINE_AG_ERROR_EVENT(xfs_refcount_delete_error);
+ DEFINE_AG_ERROR_EVENT(xfs_refcount_update_error);
+ 
+ /* refcount adjustment tracepoints */
+ DEFINE_AG_EXTENT_EVENT(xfs_refcount_increase);
+ DEFINE_AG_EXTENT_EVENT(xfs_refcount_decrease);
+ DEFINE_AG_EXTENT_EVENT(xfs_refcount_cow_increase);
+ DEFINE_AG_EXTENT_EVENT(xfs_refcount_cow_decrease);
+ DEFINE_REFCOUNT_TRIPLE_EXTENT_EVENT(xfs_refcount_merge_center_extents);
+ DEFINE_REFCOUNT_EXTENT_EVENT(xfs_refcount_modify_extent);
+ DEFINE_REFCOUNT_EXTENT_EVENT(xfs_refcount_recover_extent);
+ DEFINE_REFCOUNT_EXTENT_AT_EVENT(xfs_refcount_split_extent);
+ DEFINE_REFCOUNT_DOUBLE_EXTENT_EVENT(xfs_refcount_merge_left_extent);
+ DEFINE_REFCOUNT_DOUBLE_EXTENT_EVENT(xfs_refcount_merge_right_extent);
+ DEFINE_REFCOUNT_DOUBLE_EXTENT_AT_EVENT(xfs_refcount_find_left_extent);
+ DEFINE_REFCOUNT_DOUBLE_EXTENT_AT_EVENT(xfs_refcount_find_right_extent);
+ DEFINE_AG_ERROR_EVENT(xfs_refcount_adjust_error);
+ DEFINE_AG_ERROR_EVENT(xfs_refcount_adjust_cow_error);
+ DEFINE_AG_ERROR_EVENT(xfs_refcount_merge_center_extents_error);
+ DEFINE_AG_ERROR_EVENT(xfs_refcount_modify_extent_error);
+ DEFINE_AG_ERROR_EVENT(xfs_refcount_split_extent_error);
+ DEFINE_AG_ERROR_EVENT(xfs_refcount_merge_left_extent_error);
+ DEFINE_AG_ERROR_EVENT(xfs_refcount_merge_right_extent_error);
+ DEFINE_AG_ERROR_EVENT(xfs_refcount_find_left_extent_error);
+ DEFINE_AG_ERROR_EVENT(xfs_refcount_find_right_extent_error);
+ 
+ /* reflink helpers */
+ DEFINE_AG_EXTENT_EVENT(xfs_refcount_find_shared);
+ DEFINE_AG_EXTENT_EVENT(xfs_refcount_find_shared_result);
+ DEFINE_AG_ERROR_EVENT(xfs_refcount_find_shared_error);
+ #define DEFINE_REFCOUNT_DEFERRED_EVENT DEFINE_PHYS_EXTENT_DEFERRED_EVENT
+ DEFINE_REFCOUNT_DEFERRED_EVENT(xfs_refcount_defer);
+ DEFINE_REFCOUNT_DEFERRED_EVENT(xfs_refcount_deferred);
+ 
+ TRACE_EVENT(xfs_refcount_finish_one_leftover,
+ 	TP_PROTO(struct xfs_mount *mp, xfs_agnumber_t agno,
+ 		 int type, xfs_agblock_t agbno, xfs_extlen_t len,
+ 		 xfs_agblock_t new_agbno, xfs_extlen_t new_len),
+ 	TP_ARGS(mp, agno, type, agbno, len, new_agbno, new_len),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(int, type)
+ 		__field(xfs_agblock_t, agbno)
+ 		__field(xfs_extlen_t, len)
+ 		__field(xfs_agblock_t, new_agbno)
+ 		__field(xfs_extlen_t, new_len)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->agno = agno;
+ 		__entry->type = type;
+ 		__entry->agbno = agbno;
+ 		__entry->len = len;
+ 		__entry->new_agbno = new_agbno;
+ 		__entry->new_len = new_len;
+ 	),
+ 	TP_printk("dev %d:%d type %d agno %u agbno %u len %u new_agbno %u new_len %u",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->type,
+ 		  __entry->agno,
+ 		  __entry->agbno,
+ 		  __entry->len,
+ 		  __entry->new_agbno,
+ 		  __entry->new_len)
+ );
+ 
+ /* simple inode-based error/%ip tracepoint class */
+ DECLARE_EVENT_CLASS(xfs_inode_error_class,
+ 	TP_PROTO(struct xfs_inode *ip, int error, unsigned long caller_ip),
+ 	TP_ARGS(ip, error, caller_ip),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_ino_t, ino)
+ 		__field(int, error)
+ 		__field(unsigned long, caller_ip)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = VFS_I(ip)->i_sb->s_dev;
+ 		__entry->ino = ip->i_ino;
+ 		__entry->error = error;
+ 		__entry->caller_ip = caller_ip;
+ 	),
+ 	TP_printk("dev %d:%d ino %llx error %d caller %ps",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->ino,
+ 		  __entry->error,
+ 		  (char *)__entry->caller_ip)
+ );
+ 
+ #define DEFINE_INODE_ERROR_EVENT(name) \
+ DEFINE_EVENT(xfs_inode_error_class, name, \
+ 	TP_PROTO(struct xfs_inode *ip, int error, \
+ 		 unsigned long caller_ip), \
+ 	TP_ARGS(ip, error, caller_ip))
+ 
+ /* reflink tracepoint classes */
+ 
+ /* two-file io tracepoint class */
+ DECLARE_EVENT_CLASS(xfs_double_io_class,
+ 	TP_PROTO(struct xfs_inode *src, xfs_off_t soffset, xfs_off_t len,
+ 		 struct xfs_inode *dest, xfs_off_t doffset),
+ 	TP_ARGS(src, soffset, len, dest, doffset),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_ino_t, src_ino)
+ 		__field(loff_t, src_isize)
+ 		__field(loff_t, src_disize)
+ 		__field(loff_t, src_offset)
+ 		__field(size_t, len)
+ 		__field(xfs_ino_t, dest_ino)
+ 		__field(loff_t, dest_isize)
+ 		__field(loff_t, dest_disize)
+ 		__field(loff_t, dest_offset)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = VFS_I(src)->i_sb->s_dev;
+ 		__entry->src_ino = src->i_ino;
+ 		__entry->src_isize = VFS_I(src)->i_size;
+ 		__entry->src_disize = src->i_d.di_size;
+ 		__entry->src_offset = soffset;
+ 		__entry->len = len;
+ 		__entry->dest_ino = dest->i_ino;
+ 		__entry->dest_isize = VFS_I(dest)->i_size;
+ 		__entry->dest_disize = dest->i_d.di_size;
+ 		__entry->dest_offset = doffset;
+ 	),
+ 	TP_printk("dev %d:%d count %zd "
+ 		  "ino 0x%llx isize 0x%llx disize 0x%llx offset 0x%llx -> "
+ 		  "ino 0x%llx isize 0x%llx disize 0x%llx offset 0x%llx",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->len,
+ 		  __entry->src_ino,
+ 		  __entry->src_isize,
+ 		  __entry->src_disize,
+ 		  __entry->src_offset,
+ 		  __entry->dest_ino,
+ 		  __entry->dest_isize,
+ 		  __entry->dest_disize,
+ 		  __entry->dest_offset)
+ )
+ 
+ #define DEFINE_DOUBLE_IO_EVENT(name)	\
+ DEFINE_EVENT(xfs_double_io_class, name,	\
+ 	TP_PROTO(struct xfs_inode *src, xfs_off_t soffset, xfs_off_t len, \
+ 		 struct xfs_inode *dest, xfs_off_t doffset), \
+ 	TP_ARGS(src, soffset, len, dest, doffset))
+ 
+ /* inode/irec events */
+ DECLARE_EVENT_CLASS(xfs_inode_irec_class,
+ 	TP_PROTO(struct xfs_inode *ip, struct xfs_bmbt_irec *irec),
+ 	TP_ARGS(ip, irec),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_ino_t, ino)
+ 		__field(xfs_fileoff_t, lblk)
+ 		__field(xfs_extlen_t, len)
+ 		__field(xfs_fsblock_t, pblk)
+ 		__field(int, state)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = VFS_I(ip)->i_sb->s_dev;
+ 		__entry->ino = ip->i_ino;
+ 		__entry->lblk = irec->br_startoff;
+ 		__entry->len = irec->br_blockcount;
+ 		__entry->pblk = irec->br_startblock;
+ 		__entry->state = irec->br_state;
+ 	),
+ 	TP_printk("dev %d:%d ino 0x%llx lblk 0x%llx len 0x%x pblk %llu st %d",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->ino,
+ 		  __entry->lblk,
+ 		  __entry->len,
+ 		  __entry->pblk,
+ 		  __entry->state)
+ );
+ #define DEFINE_INODE_IREC_EVENT(name) \
+ DEFINE_EVENT(xfs_inode_irec_class, name, \
+ 	TP_PROTO(struct xfs_inode *ip, struct xfs_bmbt_irec *irec), \
+ 	TP_ARGS(ip, irec))
+ 
+ /* refcount/reflink tracepoint definitions */
+ 
+ /* reflink tracepoints */
+ DEFINE_INODE_EVENT(xfs_reflink_set_inode_flag);
+ DEFINE_INODE_EVENT(xfs_reflink_unset_inode_flag);
+ DEFINE_ITRUNC_EVENT(xfs_reflink_update_inode_size);
+ DEFINE_IOMAP_EVENT(xfs_reflink_remap_imap);
+ TRACE_EVENT(xfs_reflink_remap_blocks_loop,
+ 	TP_PROTO(struct xfs_inode *src, xfs_fileoff_t soffset,
+ 		 xfs_filblks_t len, struct xfs_inode *dest,
+ 		 xfs_fileoff_t doffset),
+ 	TP_ARGS(src, soffset, len, dest, doffset),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_ino_t, src_ino)
+ 		__field(xfs_fileoff_t, src_lblk)
+ 		__field(xfs_filblks_t, len)
+ 		__field(xfs_ino_t, dest_ino)
+ 		__field(xfs_fileoff_t, dest_lblk)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = VFS_I(src)->i_sb->s_dev;
+ 		__entry->src_ino = src->i_ino;
+ 		__entry->src_lblk = soffset;
+ 		__entry->len = len;
+ 		__entry->dest_ino = dest->i_ino;
+ 		__entry->dest_lblk = doffset;
+ 	),
+ 	TP_printk("dev %d:%d len 0x%llx "
+ 		  "ino 0x%llx offset 0x%llx blocks -> "
+ 		  "ino 0x%llx offset 0x%llx blocks",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->len,
+ 		  __entry->src_ino,
+ 		  __entry->src_lblk,
+ 		  __entry->dest_ino,
+ 		  __entry->dest_lblk)
+ );
+ TRACE_EVENT(xfs_reflink_punch_range,
+ 	TP_PROTO(struct xfs_inode *ip, xfs_fileoff_t lblk,
+ 		 xfs_extlen_t len),
+ 	TP_ARGS(ip, lblk, len),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_ino_t, ino)
+ 		__field(xfs_fileoff_t, lblk)
+ 		__field(xfs_extlen_t, len)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = VFS_I(ip)->i_sb->s_dev;
+ 		__entry->ino = ip->i_ino;
+ 		__entry->lblk = lblk;
+ 		__entry->len = len;
+ 	),
+ 	TP_printk("dev %d:%d ino 0x%llx lblk 0x%llx len 0x%x",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->ino,
+ 		  __entry->lblk,
+ 		  __entry->len)
+ );
+ TRACE_EVENT(xfs_reflink_remap,
+ 	TP_PROTO(struct xfs_inode *ip, xfs_fileoff_t lblk,
+ 		 xfs_extlen_t len, xfs_fsblock_t new_pblk),
+ 	TP_ARGS(ip, lblk, len, new_pblk),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_ino_t, ino)
+ 		__field(xfs_fileoff_t, lblk)
+ 		__field(xfs_extlen_t, len)
+ 		__field(xfs_fsblock_t, new_pblk)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = VFS_I(ip)->i_sb->s_dev;
+ 		__entry->ino = ip->i_ino;
+ 		__entry->lblk = lblk;
+ 		__entry->len = len;
+ 		__entry->new_pblk = new_pblk;
+ 	),
+ 	TP_printk("dev %d:%d ino 0x%llx lblk 0x%llx len 0x%x new_pblk %llu",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->ino,
+ 		  __entry->lblk,
+ 		  __entry->len,
+ 		  __entry->new_pblk)
+ );
+ DEFINE_DOUBLE_IO_EVENT(xfs_reflink_remap_range);
+ DEFINE_INODE_ERROR_EVENT(xfs_reflink_remap_range_error);
+ DEFINE_INODE_ERROR_EVENT(xfs_reflink_set_inode_flag_error);
+ DEFINE_INODE_ERROR_EVENT(xfs_reflink_update_inode_size_error);
+ DEFINE_INODE_ERROR_EVENT(xfs_reflink_remap_blocks_error);
+ DEFINE_INODE_ERROR_EVENT(xfs_reflink_remap_extent_error);
+ 
+ /* dedupe tracepoints */
+ DEFINE_DOUBLE_IO_EVENT(xfs_reflink_compare_extents);
+ DEFINE_INODE_ERROR_EVENT(xfs_reflink_compare_extents_error);
+ 
+ /* ioctl tracepoints */
+ TRACE_EVENT(xfs_ioctl_clone,
+ 	TP_PROTO(struct inode *src, struct inode *dest),
+ 	TP_ARGS(src, dest),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(unsigned long, src_ino)
+ 		__field(loff_t, src_isize)
+ 		__field(unsigned long, dest_ino)
+ 		__field(loff_t, dest_isize)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = src->i_sb->s_dev;
+ 		__entry->src_ino = src->i_ino;
+ 		__entry->src_isize = i_size_read(src);
+ 		__entry->dest_ino = dest->i_ino;
+ 		__entry->dest_isize = i_size_read(dest);
+ 	),
+ 	TP_printk("dev %d:%d "
+ 		  "ino 0x%lx isize 0x%llx -> "
+ 		  "ino 0x%lx isize 0x%llx",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->src_ino,
+ 		  __entry->src_isize,
+ 		  __entry->dest_ino,
+ 		  __entry->dest_isize)
+ );
+ 
+ /* unshare tracepoints */
+ DEFINE_SIMPLE_IO_EVENT(xfs_reflink_unshare);
+ DEFINE_INODE_ERROR_EVENT(xfs_reflink_unshare_error);
+ 
+ /* copy on write */
+ DEFINE_INODE_IREC_EVENT(xfs_reflink_trim_around_shared);
+ DEFINE_INODE_IREC_EVENT(xfs_reflink_cow_alloc);
+ DEFINE_INODE_IREC_EVENT(xfs_reflink_cow_found);
+ DEFINE_INODE_IREC_EVENT(xfs_reflink_cow_enospc);
+ DEFINE_INODE_IREC_EVENT(xfs_reflink_convert_cow);
+ 
+ DEFINE_RW_EVENT(xfs_reflink_reserve_cow);
+ 
+ DEFINE_SIMPLE_IO_EVENT(xfs_reflink_bounce_dio_write);
+ DEFINE_IOMAP_EVENT(xfs_reflink_find_cow_mapping);
+ DEFINE_INODE_IREC_EVENT(xfs_reflink_trim_irec);
+ 
+ DEFINE_SIMPLE_IO_EVENT(xfs_reflink_cancel_cow_range);
+ DEFINE_SIMPLE_IO_EVENT(xfs_reflink_end_cow);
+ DEFINE_INODE_IREC_EVENT(xfs_reflink_cow_remap);
+ 
+ DEFINE_INODE_ERROR_EVENT(xfs_reflink_cancel_cow_range_error);
+ DEFINE_INODE_ERROR_EVENT(xfs_reflink_end_cow_error);
+ 
+ 
+ DEFINE_INODE_IREC_EVENT(xfs_reflink_cancel_cow);
+ 
+ /* rmap swapext tracepoints */
+ DEFINE_INODE_IREC_EVENT(xfs_swap_extent_rmap_remap);
+ DEFINE_INODE_IREC_EVENT(xfs_swap_extent_rmap_remap_piece);
+ DEFINE_INODE_ERROR_EVENT(xfs_swap_extent_rmap_error);
+ 
+ /* fsmap traces */
+ DECLARE_EVENT_CLASS(xfs_fsmap_class,
+ 	TP_PROTO(struct xfs_mount *mp, u32 keydev, xfs_agnumber_t agno,
+ 		 struct xfs_rmap_irec *rmap),
+ 	TP_ARGS(mp, keydev, agno, rmap),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(dev_t, keydev)
+ 		__field(xfs_agnumber_t, agno)
+ 		__field(xfs_fsblock_t, bno)
+ 		__field(xfs_filblks_t, len)
+ 		__field(uint64_t, owner)
+ 		__field(uint64_t, offset)
+ 		__field(unsigned int, flags)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->keydev = new_decode_dev(keydev);
+ 		__entry->agno = agno;
+ 		__entry->bno = rmap->rm_startblock;
+ 		__entry->len = rmap->rm_blockcount;
+ 		__entry->owner = rmap->rm_owner;
+ 		__entry->offset = rmap->rm_offset;
+ 		__entry->flags = rmap->rm_flags;
+ 	),
+ 	TP_printk("dev %d:%d keydev %d:%d agno %u bno %llu len %llu owner %lld offset %llu flags 0x%x",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  MAJOR(__entry->keydev), MINOR(__entry->keydev),
+ 		  __entry->agno,
+ 		  __entry->bno,
+ 		  __entry->len,
+ 		  __entry->owner,
+ 		  __entry->offset,
+ 		  __entry->flags)
+ )
+ #define DEFINE_FSMAP_EVENT(name) \
+ DEFINE_EVENT(xfs_fsmap_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, u32 keydev, xfs_agnumber_t agno, \
+ 		 struct xfs_rmap_irec *rmap), \
+ 	TP_ARGS(mp, keydev, agno, rmap))
+ DEFINE_FSMAP_EVENT(xfs_fsmap_low_key);
+ DEFINE_FSMAP_EVENT(xfs_fsmap_high_key);
+ DEFINE_FSMAP_EVENT(xfs_fsmap_mapping);
+ 
+ DECLARE_EVENT_CLASS(xfs_getfsmap_class,
+ 	TP_PROTO(struct xfs_mount *mp, struct xfs_fsmap *fsmap),
+ 	TP_ARGS(mp, fsmap),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(dev_t, keydev)
+ 		__field(xfs_daddr_t, block)
+ 		__field(xfs_daddr_t, len)
+ 		__field(uint64_t, owner)
+ 		__field(uint64_t, offset)
+ 		__field(uint64_t, flags)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = mp->m_super->s_dev;
+ 		__entry->keydev = new_decode_dev(fsmap->fmr_device);
+ 		__entry->block = fsmap->fmr_physical;
+ 		__entry->len = fsmap->fmr_length;
+ 		__entry->owner = fsmap->fmr_owner;
+ 		__entry->offset = fsmap->fmr_offset;
+ 		__entry->flags = fsmap->fmr_flags;
+ 	),
+ 	TP_printk("dev %d:%d keydev %d:%d block %llu len %llu owner %lld offset %llu flags 0x%llx",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  MAJOR(__entry->keydev), MINOR(__entry->keydev),
+ 		  __entry->block,
+ 		  __entry->len,
+ 		  __entry->owner,
+ 		  __entry->offset,
+ 		  __entry->flags)
+ )
+ #define DEFINE_GETFSMAP_EVENT(name) \
+ DEFINE_EVENT(xfs_getfsmap_class, name, \
+ 	TP_PROTO(struct xfs_mount *mp, struct xfs_fsmap *fsmap), \
+ 	TP_ARGS(mp, fsmap))
+ DEFINE_GETFSMAP_EVENT(xfs_getfsmap_low_key);
+ DEFINE_GETFSMAP_EVENT(xfs_getfsmap_high_key);
+ DEFINE_GETFSMAP_EVENT(xfs_getfsmap_mapping);
+ 
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  #endif /* _TRACE_XFS_H */
  
  #undef TRACE_INCLUDE_PATH
diff --cc fs/xfs/xfs_trans.h
index 94ce120d00a6,6bdad6f58934..000000000000
--- a/fs/xfs/xfs_trans.h
+++ b/fs/xfs/xfs_trans.h
@@@ -232,4 -237,40 +232,43 @@@ void		xfs_trans_buf_copy_type(struct xf
  extern kmem_zone_t	*xfs_trans_zone;
  extern kmem_zone_t	*xfs_log_item_desc_zone;
  
++<<<<<<< HEAD
++=======
+ /* rmap updates */
+ enum xfs_rmap_intent_type;
+ 
+ void xfs_rmap_update_init_defer_op(void);
+ struct xfs_rud_log_item *xfs_trans_get_rud(struct xfs_trans *tp,
+ 		struct xfs_rui_log_item *ruip);
+ int xfs_trans_log_finish_rmap_update(struct xfs_trans *tp,
+ 		struct xfs_rud_log_item *rudp, enum xfs_rmap_intent_type type,
+ 		uint64_t owner, int whichfork, xfs_fileoff_t startoff,
+ 		xfs_fsblock_t startblock, xfs_filblks_t blockcount,
+ 		xfs_exntst_t state, struct xfs_btree_cur **pcur);
+ 
+ /* refcount updates */
+ enum xfs_refcount_intent_type;
+ 
+ void xfs_refcount_update_init_defer_op(void);
+ struct xfs_cud_log_item *xfs_trans_get_cud(struct xfs_trans *tp,
+ 		struct xfs_cui_log_item *cuip);
+ int xfs_trans_log_finish_refcount_update(struct xfs_trans *tp,
+ 		struct xfs_cud_log_item *cudp, struct xfs_defer_ops *dfops,
+ 		enum xfs_refcount_intent_type type, xfs_fsblock_t startblock,
+ 		xfs_extlen_t blockcount, xfs_fsblock_t *new_fsb,
+ 		xfs_extlen_t *new_len, struct xfs_btree_cur **pcur);
+ 
+ /* mapping updates */
+ enum xfs_bmap_intent_type;
+ 
+ void xfs_bmap_update_init_defer_op(void);
+ struct xfs_bud_log_item *xfs_trans_get_bud(struct xfs_trans *tp,
+ 		struct xfs_bui_log_item *buip);
+ int xfs_trans_log_finish_bmap_update(struct xfs_trans *tp,
+ 		struct xfs_bud_log_item *rudp, struct xfs_defer_ops *dfops,
+ 		enum xfs_bmap_intent_type type, struct xfs_inode *ip,
+ 		int whichfork, xfs_fileoff_t startoff, xfs_fsblock_t startblock,
+ 		xfs_filblks_t *blockcount, xfs_exntst_t state);
+ 
++>>>>>>> c8ce540db5f6 (xfs: remove double-underscore integer types)
  #endif	/* __XFS_TRANS_H__ */
* Unmerged path fs/xfs/libxfs/xfs_refcount_btree.c
* Unmerged path fs/xfs/libxfs/xfs_rmap.c
* Unmerged path fs/xfs/libxfs/xfs_rmap.h
* Unmerged path fs/xfs/libxfs/xfs_rmap_btree.c
* Unmerged path fs/xfs/xfs_trans_rmap.c
* Unmerged path fs/xfs/libxfs/xfs_alloc_btree.c
diff --git a/fs/xfs/libxfs/xfs_attr_remote.c b/fs/xfs/libxfs/xfs_attr_remote.c
index d52f525f5b2d..da72b16bef8e 100644
--- a/fs/xfs/libxfs/xfs_attr_remote.c
+++ b/fs/xfs/libxfs/xfs_attr_remote.c
@@ -253,7 +253,7 @@ xfs_attr_rmtval_copyout(
 	xfs_ino_t	ino,
 	int		*offset,
 	int		*valuelen,
-	__uint8_t	**dst)
+	uint8_t		**dst)
 {
 	char		*src = bp->b_addr;
 	xfs_daddr_t	bno = bp->b_bn;
@@ -301,7 +301,7 @@ xfs_attr_rmtval_copyin(
 	xfs_ino_t	ino,
 	int		*offset,
 	int		*valuelen,
-	__uint8_t	**src)
+	uint8_t		**src)
 {
 	char		*dst = bp->b_addr;
 	xfs_daddr_t	bno = bp->b_bn;
@@ -355,7 +355,7 @@ xfs_attr_rmtval_get(
 	struct xfs_mount	*mp = args->dp->i_mount;
 	struct xfs_buf		*bp;
 	xfs_dablk_t		lblkno = args->rmtblkno;
-	__uint8_t		*dst = args->value;
+	uint8_t			*dst = args->value;
 	int			valuelen;
 	int			nmap;
 	int			error;
@@ -421,7 +421,7 @@ xfs_attr_rmtval_set(
 	struct xfs_bmbt_irec	map;
 	xfs_dablk_t		lblkno;
 	xfs_fileoff_t		lfileoff = 0;
-	__uint8_t		*src = args->value;
+	uint8_t			*src = args->value;
 	int			blkcnt;
 	int			valuelen;
 	int			nmap;
diff --git a/fs/xfs/libxfs/xfs_attr_sf.h b/fs/xfs/libxfs/xfs_attr_sf.h
index 90928bbe693c..afd684ae3136 100644
--- a/fs/xfs/libxfs/xfs_attr_sf.h
+++ b/fs/xfs/libxfs/xfs_attr_sf.h
@@ -31,10 +31,10 @@ typedef struct xfs_attr_sf_entry xfs_attr_sf_entry_t;
  * We generate this then sort it, attr_list() must return things in hash-order.
  */
 typedef struct xfs_attr_sf_sort {
-	__uint8_t	entno;		/* entry number in original list */
-	__uint8_t	namelen;	/* length of name value (no null) */
-	__uint8_t	valuelen;	/* length of value */
-	__uint8_t	flags;		/* flags bits (see xfs_attr_leaf.h) */
+	uint8_t		entno;		/* entry number in original list */
+	uint8_t		namelen;	/* length of name value (no null) */
+	uint8_t		valuelen;	/* length of value */
+	uint8_t		flags;		/* flags bits (see xfs_attr_leaf.h) */
 	xfs_dahash_t	hash;		/* this entry's hash value */
 	unsigned char	*name;		/* name value, pointer into buffer */
 } xfs_attr_sf_sort_t;
@@ -42,7 +42,7 @@ typedef struct xfs_attr_sf_sort {
 #define XFS_ATTR_SF_ENTSIZE_BYNAME(nlen,vlen)	/* space name/value uses */ \
 	(((int)sizeof(xfs_attr_sf_entry_t)-1 + (nlen)+(vlen)))
 #define XFS_ATTR_SF_ENTSIZE_MAX			/* max space for name&value */ \
-	((1 << (NBBY*(int)sizeof(__uint8_t))) - 1)
+	((1 << (NBBY*(int)sizeof(uint8_t))) - 1)
 #define XFS_ATTR_SF_ENTSIZE(sfep)		/* space an entry uses */ \
 	((int)sizeof(xfs_attr_sf_entry_t)-1 + (sfep)->namelen+(sfep)->valuelen)
 #define XFS_ATTR_SF_NEXTENTRY(sfep)		/* next entry in struct */ \
diff --git a/fs/xfs/libxfs/xfs_bit.h b/fs/xfs/libxfs/xfs_bit.h
index e1649c0d3e02..61c6b2025d0c 100644
--- a/fs/xfs/libxfs/xfs_bit.h
+++ b/fs/xfs/libxfs/xfs_bit.h
@@ -25,47 +25,47 @@
 /*
  * masks with n high/low bits set, 64-bit values
  */
-static inline __uint64_t xfs_mask64hi(int n)
+static inline uint64_t xfs_mask64hi(int n)
 {
-	return (__uint64_t)-1 << (64 - (n));
+	return (uint64_t)-1 << (64 - (n));
 }
-static inline __uint32_t xfs_mask32lo(int n)
+static inline uint32_t xfs_mask32lo(int n)
 {
-	return ((__uint32_t)1 << (n)) - 1;
+	return ((uint32_t)1 << (n)) - 1;
 }
-static inline __uint64_t xfs_mask64lo(int n)
+static inline uint64_t xfs_mask64lo(int n)
 {
-	return ((__uint64_t)1 << (n)) - 1;
+	return ((uint64_t)1 << (n)) - 1;
 }
 
 /* Get high bit set out of 32-bit argument, -1 if none set */
-static inline int xfs_highbit32(__uint32_t v)
+static inline int xfs_highbit32(uint32_t v)
 {
 	return fls(v) - 1;
 }
 
 /* Get high bit set out of 64-bit argument, -1 if none set */
-static inline int xfs_highbit64(__uint64_t v)
+static inline int xfs_highbit64(uint64_t v)
 {
 	return fls64(v) - 1;
 }
 
 /* Get low bit set out of 32-bit argument, -1 if none set */
-static inline int xfs_lowbit32(__uint32_t v)
+static inline int xfs_lowbit32(uint32_t v)
 {
 	return ffs(v) - 1;
 }
 
 /* Get low bit set out of 64-bit argument, -1 if none set */
-static inline int xfs_lowbit64(__uint64_t v)
+static inline int xfs_lowbit64(uint64_t v)
 {
-	__uint32_t	w = (__uint32_t)v;
+	uint32_t	w = (uint32_t)v;
 	int		n = 0;
 
 	if (w) {	/* lower bits */
 		n = ffs(w);
 	} else {	/* upper bits */
-		w = (__uint32_t)(v >> 32);
+		w = (uint32_t)(v >> 32);
 		if (w) {
 			n = ffs(w);
 			if (n)
diff --git a/fs/xfs/libxfs/xfs_bmap_btree.c b/fs/xfs/libxfs/xfs_bmap_btree.c
index 02efded83ebf..892c8ed5c88a 100644
--- a/fs/xfs/libxfs/xfs_bmap_btree.c
+++ b/fs/xfs/libxfs/xfs_bmap_btree.c
@@ -99,8 +99,8 @@ xfs_bmdr_to_bmbt(
  */
 STATIC void
 __xfs_bmbt_get_all(
-		__uint64_t l0,
-		__uint64_t l1,
+		uint64_t l0,
+		uint64_t l1,
 		xfs_bmbt_irec_t *s)
 {
 	int	ext_flag;
@@ -615,12 +615,12 @@ xfs_bmbt_init_ptr_from_cur(
 	ptr->l = 0;
 }
 
-STATIC __int64_t
+STATIC int64_t
 xfs_bmbt_key_diff(
 	struct xfs_btree_cur	*cur,
 	union xfs_btree_key	*key)
 {
-	return (__int64_t)be64_to_cpu(key->bmbt.br_startoff) -
+	return (int64_t)be64_to_cpu(key->bmbt.br_startoff) -
 				      cur->bc_rec.b.br_startoff;
 }
 
* Unmerged path fs/xfs/libxfs/xfs_btree.c
* Unmerged path fs/xfs/libxfs/xfs_btree.h
diff --git a/fs/xfs/libxfs/xfs_cksum.h b/fs/xfs/libxfs/xfs_cksum.h
index a416c7cb23ea..8211f48b98e6 100644
--- a/fs/xfs/libxfs/xfs_cksum.h
+++ b/fs/xfs/libxfs/xfs_cksum.h
@@ -1,7 +1,7 @@
 #ifndef _XFS_CKSUM_H
 #define _XFS_CKSUM_H 1
 
-#define XFS_CRC_SEED	(~(__uint32_t)0)
+#define XFS_CRC_SEED	(~(uint32_t)0)
 
 /*
  * Calculate the intermediate checksum for a buffer that has the CRC field
@@ -9,11 +9,11 @@
  * cksum_offset parameter. We do not modify the buffer during verification,
  * hence we have to split the CRC calculation across the cksum_offset.
  */
-static inline __uint32_t
+static inline uint32_t
 xfs_start_cksum_safe(char *buffer, size_t length, unsigned long cksum_offset)
 {
-	__uint32_t zero = 0;
-	__uint32_t crc;
+	uint32_t zero = 0;
+	uint32_t crc;
 
 	/* Calculate CRC up to the checksum. */
 	crc = crc32c(XFS_CRC_SEED, buffer, cksum_offset);
@@ -30,7 +30,7 @@ xfs_start_cksum_safe(char *buffer, size_t length, unsigned long cksum_offset)
  * Fast CRC method where the buffer is modified. Callers must have exclusive
  * access to the buffer while the calculation takes place.
  */
-static inline __uint32_t
+static inline uint32_t
 xfs_start_cksum_update(char *buffer, size_t length, unsigned long cksum_offset)
 {
 	/* zero the CRC field */
@@ -48,7 +48,7 @@ xfs_start_cksum_update(char *buffer, size_t length, unsigned long cksum_offset)
  * so that it is consistent on disk.
  */
 static inline __le32
-xfs_end_cksum(__uint32_t crc)
+xfs_end_cksum(uint32_t crc)
 {
 	return ~cpu_to_le32(crc);
 }
@@ -62,7 +62,7 @@ xfs_end_cksum(__uint32_t crc)
 static inline void
 xfs_update_cksum(char *buffer, size_t length, unsigned long cksum_offset)
 {
-	__uint32_t crc = xfs_start_cksum_update(buffer, length, cksum_offset);
+	uint32_t crc = xfs_start_cksum_update(buffer, length, cksum_offset);
 
 	*(__le32 *)(buffer + cksum_offset) = xfs_end_cksum(crc);
 }
@@ -73,7 +73,7 @@ xfs_update_cksum(char *buffer, size_t length, unsigned long cksum_offset)
 static inline int
 xfs_verify_cksum(char *buffer, size_t length, unsigned long cksum_offset)
 {
-	__uint32_t crc = xfs_start_cksum_safe(buffer, length, cksum_offset);
+	uint32_t crc = xfs_start_cksum_safe(buffer, length, cksum_offset);
 
 	return *(__le32 *)(buffer + cksum_offset) == xfs_end_cksum(crc);
 }
diff --git a/fs/xfs/libxfs/xfs_da_btree.c b/fs/xfs/libxfs/xfs_da_btree.c
index 1bdf2888295b..48f1136b80bf 100644
--- a/fs/xfs/libxfs/xfs_da_btree.c
+++ b/fs/xfs/libxfs/xfs_da_btree.c
@@ -1952,7 +1952,7 @@ xfs_da3_path_shift(
  * This is implemented with some source-level loop unrolling.
  */
 xfs_dahash_t
-xfs_da_hashname(const __uint8_t *name, int namelen)
+xfs_da_hashname(const uint8_t *name, int namelen)
 {
 	xfs_dahash_t hash;
 
diff --git a/fs/xfs/libxfs/xfs_da_btree.h b/fs/xfs/libxfs/xfs_da_btree.h
index 4e29cb6a3627..ae6de17467f2 100644
--- a/fs/xfs/libxfs/xfs_da_btree.h
+++ b/fs/xfs/libxfs/xfs_da_btree.h
@@ -60,10 +60,10 @@ enum xfs_dacmp {
  */
 typedef struct xfs_da_args {
 	struct xfs_da_geometry *geo;	/* da block geometry */
-	const __uint8_t	*name;		/* string (maybe not NULL terminated) */
+	const uint8_t		*name;		/* string (maybe not NULL terminated) */
 	int		namelen;	/* length of string (maybe no NULL) */
-	__uint8_t	filetype;	/* filetype of inode for directories */
-	__uint8_t	*value;		/* set of bytes (maybe contain NULLs) */
+	uint8_t		filetype;	/* filetype of inode for directories */
+	uint8_t		*value;		/* set of bytes (maybe contain NULLs) */
 	int		valuelen;	/* length of value */
 	int		flags;		/* argument flags (eg: ATTR_NOCREATE) */
 	xfs_dahash_t	hashval;	/* hash value of name */
@@ -207,7 +207,7 @@ int	xfs_da_reada_buf(struct xfs_inode *dp, xfs_dablk_t bno,
 int	xfs_da_shrink_inode(xfs_da_args_t *args, xfs_dablk_t dead_blkno,
 					  struct xfs_buf *dead_buf);
 
-uint xfs_da_hashname(const __uint8_t *name_string, int name_length);
+uint xfs_da_hashname(const uint8_t *name_string, int name_length);
 enum xfs_dacmp xfs_da_compname(struct xfs_da_args *args,
 				const unsigned char *name, int len);
 
diff --git a/fs/xfs/libxfs/xfs_da_format.c b/fs/xfs/libxfs/xfs_da_format.c
index f1e8d4dbb600..6d77d1a8498a 100644
--- a/fs/xfs/libxfs/xfs_da_format.c
+++ b/fs/xfs/libxfs/xfs_da_format.c
@@ -49,7 +49,7 @@ xfs_dir3_sf_entsize(
 	struct xfs_dir2_sf_hdr	*hdr,
 	int			len)
 {
-	return xfs_dir2_sf_entsize(hdr, len) + sizeof(__uint8_t);
+	return xfs_dir2_sf_entsize(hdr, len) + sizeof(uint8_t);
 }
 
 static struct xfs_dir2_sf_entry *
@@ -77,7 +77,7 @@ xfs_dir3_sf_nextentry(
  * not necessary. For non-filetype enable directories, the type is always
  * unknown and we never store the value.
  */
-static __uint8_t
+static uint8_t
 xfs_dir2_sfe_get_ftype(
 	struct xfs_dir2_sf_entry *sfep)
 {
@@ -87,16 +87,16 @@ xfs_dir2_sfe_get_ftype(
 static void
 xfs_dir2_sfe_put_ftype(
 	struct xfs_dir2_sf_entry *sfep,
-	__uint8_t		ftype)
+	uint8_t			ftype)
 {
 	ASSERT(ftype < XFS_DIR3_FT_MAX);
 }
 
-static __uint8_t
+static uint8_t
 xfs_dir3_sfe_get_ftype(
 	struct xfs_dir2_sf_entry *sfep)
 {
-	__uint8_t	ftype;
+	uint8_t		ftype;
 
 	ftype = sfep->name[sfep->namelen];
 	if (ftype >= XFS_DIR3_FT_MAX)
@@ -107,7 +107,7 @@ xfs_dir3_sfe_get_ftype(
 static void
 xfs_dir3_sfe_put_ftype(
 	struct xfs_dir2_sf_entry *sfep,
-	__uint8_t		ftype)
+	uint8_t			ftype)
 {
 	ASSERT(ftype < XFS_DIR3_FT_MAX);
 
@@ -124,7 +124,7 @@ xfs_dir3_sfe_put_ftype(
 static xfs_ino_t
 xfs_dir2_sf_get_ino(
 	struct xfs_dir2_sf_hdr	*hdr,
-	__uint8_t		*from)
+	uint8_t			*from)
 {
 	if (hdr->i8count)
 		return get_unaligned_be64(from) & 0x00ffffffffffffffULL;
@@ -135,7 +135,7 @@ xfs_dir2_sf_get_ino(
 static void
 xfs_dir2_sf_put_ino(
 	struct xfs_dir2_sf_hdr	*hdr,
-	__uint8_t		*to,
+	uint8_t			*to,
 	xfs_ino_t		ino)
 {
 	ASSERT((ino & 0xff00000000000000ULL) == 0);
@@ -225,7 +225,7 @@ xfs_dir3_sfe_put_ino(
 
 #define XFS_DIR3_DATA_ENTSIZE(n)					\
 	round_up((offsetof(struct xfs_dir2_data_entry, name[0]) + (n) +	\
-		 sizeof(xfs_dir2_data_off_t) + sizeof(__uint8_t)),	\
+		 sizeof(xfs_dir2_data_off_t) + sizeof(uint8_t)),	\
 		XFS_DIR2_DATA_ALIGN)
 
 static int
@@ -242,7 +242,7 @@ xfs_dir3_data_entsize(
 	return XFS_DIR3_DATA_ENTSIZE(n);
 }
 
-static __uint8_t
+static uint8_t
 xfs_dir2_data_get_ftype(
 	struct xfs_dir2_data_entry *dep)
 {
@@ -252,16 +252,16 @@ xfs_dir2_data_get_ftype(
 static void
 xfs_dir2_data_put_ftype(
 	struct xfs_dir2_data_entry *dep,
-	__uint8_t		ftype)
+	uint8_t			ftype)
 {
 	ASSERT(ftype < XFS_DIR3_FT_MAX);
 }
 
-static __uint8_t
+static uint8_t
 xfs_dir3_data_get_ftype(
 	struct xfs_dir2_data_entry *dep)
 {
-	__uint8_t	ftype = dep->name[dep->namelen];
+	uint8_t		ftype = dep->name[dep->namelen];
 
 	if (ftype >= XFS_DIR3_FT_MAX)
 		return XFS_DIR3_FT_UNKNOWN;
@@ -271,7 +271,7 @@ xfs_dir3_data_get_ftype(
 static void
 xfs_dir3_data_put_ftype(
 	struct xfs_dir2_data_entry *dep,
-	__uint8_t		type)
+	uint8_t			type)
 {
 	ASSERT(type < XFS_DIR3_FT_MAX);
 	ASSERT(dep->namelen != 0);
diff --git a/fs/xfs/libxfs/xfs_da_format.h b/fs/xfs/libxfs/xfs_da_format.h
index 9a492a9e19bd..3771edcb301d 100644
--- a/fs/xfs/libxfs/xfs_da_format.h
+++ b/fs/xfs/libxfs/xfs_da_format.h
@@ -111,11 +111,11 @@ struct xfs_da3_intnode {
  * appropriate.
  */
 struct xfs_da3_icnode_hdr {
-	__uint32_t	forw;
-	__uint32_t	back;
-	__uint16_t	magic;
-	__uint16_t	count;
-	__uint16_t	level;
+	uint32_t	forw;
+	uint32_t	back;
+	uint16_t	magic;
+	uint16_t	count;
+	uint16_t	level;
 };
 
 /*
@@ -187,14 +187,14 @@ struct xfs_da3_icnode_hdr {
 /*
  * Byte offset in data block and shortform entry.
  */
-typedef	__uint16_t	xfs_dir2_data_off_t;
+typedef uint16_t	xfs_dir2_data_off_t;
 #define	NULLDATAOFF	0xffffU
 typedef uint		xfs_dir2_data_aoff_t;	/* argument form */
 
 /*
  * Offset in data space of a data entry.
  */
-typedef	__uint32_t	xfs_dir2_dataptr_t;
+typedef uint32_t	xfs_dir2_dataptr_t;
 #define	XFS_DIR2_MAX_DATAPTR	((xfs_dir2_dataptr_t)0xffffffff)
 #define	XFS_DIR2_NULL_DATAPTR	((xfs_dir2_dataptr_t)0)
 
@@ -206,7 +206,7 @@ typedef	xfs_off_t	xfs_dir2_off_t;
 /*
  * Directory block number (logical dirblk in file)
  */
-typedef	__uint32_t	xfs_dir2_db_t;
+typedef uint32_t	xfs_dir2_db_t;
 
 #define XFS_INO32_SIZE	4
 #define XFS_INO64_SIZE	8
@@ -226,9 +226,9 @@ typedef	__uint32_t	xfs_dir2_db_t;
  * over them.
  */
 typedef struct xfs_dir2_sf_hdr {
-	__uint8_t		count;		/* count of entries */
-	__uint8_t		i8count;	/* count of 8-byte inode #s */
-	__uint8_t		parent[8];	/* parent dir inode number */
+	uint8_t			count;		/* count of entries */
+	uint8_t			i8count;	/* count of 8-byte inode #s */
+	uint8_t			parent[8];	/* parent dir inode number */
 } __packed xfs_dir2_sf_hdr_t;
 
 typedef struct xfs_dir2_sf_entry {
@@ -447,11 +447,11 @@ struct xfs_dir3_leaf_hdr {
 };
 
 struct xfs_dir3_icleaf_hdr {
-	__uint32_t		forw;
-	__uint32_t		back;
-	__uint16_t		magic;
-	__uint16_t		count;
-	__uint16_t		stale;
+	uint32_t		forw;
+	uint32_t		back;
+	uint16_t		magic;
+	uint16_t		count;
+	uint16_t		stale;
 };
 
 /*
@@ -538,10 +538,10 @@ struct xfs_dir3_free {
  * xfs_dir3_free_hdr_from_disk/xfs_dir3_free_hdr_to_disk.
  */
 struct xfs_dir3_icfree_hdr {
-	__uint32_t	magic;
-	__uint32_t	firstdb;
-	__uint32_t	nvalid;
-	__uint32_t	nused;
+	uint32_t	magic;
+	uint32_t	firstdb;
+	uint32_t	nvalid;
+	uint32_t	nused;
 
 };
 
@@ -632,10 +632,10 @@ typedef struct xfs_attr_shortform {
 		__u8	padding;
 	} hdr;
 	struct xfs_attr_sf_entry {
-		__uint8_t namelen;	/* actual length of name (no NULL) */
-		__uint8_t valuelen;	/* actual length of value (no NULL) */
-		__uint8_t flags;	/* flags bits (see xfs_attr_leaf.h) */
-		__uint8_t nameval[1];	/* name & value bytes concatenated */
+		uint8_t namelen;	/* actual length of name (no NULL) */
+		uint8_t valuelen;	/* actual length of value (no NULL) */
+		uint8_t flags;	/* flags bits (see xfs_attr_leaf.h) */
+		uint8_t nameval[1];	/* name & value bytes concatenated */
 	} list[1];			/* variable sized array */
 } xfs_attr_shortform_t;
 
@@ -725,22 +725,22 @@ struct xfs_attr3_leafblock {
  * incore, neutral version of the attribute leaf header
  */
 struct xfs_attr3_icleaf_hdr {
-	__uint32_t	forw;
-	__uint32_t	back;
-	__uint16_t	magic;
-	__uint16_t	count;
-	__uint16_t	usedbytes;
+	uint32_t	forw;
+	uint32_t	back;
+	uint16_t	magic;
+	uint16_t	count;
+	uint16_t	usedbytes;
 	/*
 	 * firstused is 32-bit here instead of 16-bit like the on-disk variant
 	 * to support maximum fsb size of 64k without overflow issues throughout
 	 * the attr code. Instead, the overflow condition is handled on
 	 * conversion to/from disk.
 	 */
-	__uint32_t	firstused;
+	uint32_t	firstused;
 	__u8		holes;
 	struct {
-		__uint16_t	base;
-		__uint16_t	size;
+		uint16_t	base;
+		uint16_t	size;
 	} freemap[XFS_ATTR_LEAF_MAPSIZE];
 };
 
diff --git a/fs/xfs/libxfs/xfs_dir2.h b/fs/xfs/libxfs/xfs_dir2.h
index d6e6d9d16f6c..21c8f8bf94d5 100644
--- a/fs/xfs/libxfs/xfs_dir2.h
+++ b/fs/xfs/libxfs/xfs_dir2.h
@@ -47,9 +47,9 @@ struct xfs_dir_ops {
 	struct xfs_dir2_sf_entry *
 		(*sf_nextentry)(struct xfs_dir2_sf_hdr *hdr,
 				struct xfs_dir2_sf_entry *sfep);
-	__uint8_t (*sf_get_ftype)(struct xfs_dir2_sf_entry *sfep);
+	uint8_t (*sf_get_ftype)(struct xfs_dir2_sf_entry *sfep);
 	void	(*sf_put_ftype)(struct xfs_dir2_sf_entry *sfep,
-				__uint8_t ftype);
+				uint8_t ftype);
 	xfs_ino_t (*sf_get_ino)(struct xfs_dir2_sf_hdr *hdr,
 				struct xfs_dir2_sf_entry *sfep);
 	void	(*sf_put_ino)(struct xfs_dir2_sf_hdr *hdr,
@@ -60,9 +60,9 @@ struct xfs_dir_ops {
 				     xfs_ino_t ino);
 
 	int	(*data_entsize)(int len);
-	__uint8_t (*data_get_ftype)(struct xfs_dir2_data_entry *dep);
+	uint8_t (*data_get_ftype)(struct xfs_dir2_data_entry *dep);
 	void	(*data_put_ftype)(struct xfs_dir2_data_entry *dep,
-				__uint8_t ftype);
+				uint8_t ftype);
 	__be16 * (*data_entry_tag_p)(struct xfs_dir2_data_entry *dep);
 	struct xfs_dir2_data_free *
 		(*data_bestfree_p)(struct xfs_dir2_data_hdr *hdr);
diff --git a/fs/xfs/libxfs/xfs_dir2_leaf.c b/fs/xfs/libxfs/xfs_dir2_leaf.c
index b887fb2a2bcf..68bf3e860a90 100644
--- a/fs/xfs/libxfs/xfs_dir2_leaf.c
+++ b/fs/xfs/libxfs/xfs_dir2_leaf.c
@@ -145,7 +145,7 @@ xfs_dir3_leaf_check_int(
 static bool
 xfs_dir3_leaf_verify(
 	struct xfs_buf		*bp,
-	__uint16_t		magic)
+	uint16_t		magic)
 {
 	struct xfs_mount	*mp = bp->b_target->bt_mount;
 	struct xfs_dir2_leaf	*leaf = bp->b_addr;
@@ -154,7 +154,7 @@ xfs_dir3_leaf_verify(
 
 	if (xfs_sb_version_hascrc(&mp->m_sb)) {
 		struct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;
-		__uint16_t		magic3;
+		uint16_t		magic3;
 
 		magic3 = (magic == XFS_DIR2_LEAF1_MAGIC) ? XFS_DIR3_LEAF1_MAGIC
 							 : XFS_DIR3_LEAFN_MAGIC;
@@ -178,7 +178,7 @@ xfs_dir3_leaf_verify(
 static void
 __read_verify(
 	struct xfs_buf  *bp,
-	__uint16_t	magic)
+	uint16_t	magic)
 {
 	struct xfs_mount	*mp = bp->b_target->bt_mount;
 
@@ -195,7 +195,7 @@ __read_verify(
 static void
 __write_verify(
 	struct xfs_buf  *bp,
-	__uint16_t	magic)
+	uint16_t	magic)
 {
 	struct xfs_mount	*mp = bp->b_target->bt_mount;
 	struct xfs_buf_log_item	*bip = bp->b_fspriv;
@@ -299,7 +299,7 @@ xfs_dir3_leaf_init(
 	struct xfs_trans	*tp,
 	struct xfs_buf		*bp,
 	xfs_ino_t		owner,
-	__uint16_t		type)
+	uint16_t		type)
 {
 	struct xfs_dir2_leaf	*leaf = bp->b_addr;
 
@@ -343,7 +343,7 @@ xfs_dir3_leaf_get_buf(
 	xfs_da_args_t		*args,
 	xfs_dir2_db_t		bno,
 	struct xfs_buf		**bpp,
-	__uint16_t		magic)
+	uint16_t		magic)
 {
 	struct xfs_inode	*dp = args->dp;
 	struct xfs_trans	*tp = args->trans;
diff --git a/fs/xfs/libxfs/xfs_dir2_priv.h b/fs/xfs/libxfs/xfs_dir2_priv.h
index 6c891badec06..7b0aad4531a8 100644
--- a/fs/xfs/libxfs/xfs_dir2_priv.h
+++ b/fs/xfs/libxfs/xfs_dir2_priv.h
@@ -69,7 +69,7 @@ extern void xfs_dir3_leaf_compact_x1(struct xfs_dir3_icleaf_hdr *leafhdr,
 		struct xfs_dir2_leaf_entry *ents, int *indexp,
 		int *lowstalep, int *highstalep, int *lowlogp, int *highlogp);
 extern int xfs_dir3_leaf_get_buf(struct xfs_da_args *args, xfs_dir2_db_t bno,
-		struct xfs_buf **bpp, __uint16_t magic);
+		struct xfs_buf **bpp, uint16_t magic);
 extern void xfs_dir3_leaf_log_ents(struct xfs_da_args *args,
 		struct xfs_buf *bp, int first, int last);
 extern void xfs_dir3_leaf_log_header(struct xfs_da_args *args,
diff --git a/fs/xfs/libxfs/xfs_dir2_sf.c b/fs/xfs/libxfs/xfs_dir2_sf.c
index e84af093b2ab..be8b9755f66a 100644
--- a/fs/xfs/libxfs/xfs_dir2_sf.c
+++ b/fs/xfs/libxfs/xfs_dir2_sf.c
@@ -647,7 +647,7 @@ xfs_dir2_sf_verify(
 	int				offset;
 	int				size;
 	int				error;
-	__uint8_t			filetype;
+	uint8_t				filetype;
 
 	ASSERT(ip->i_d.di_format == XFS_DINODE_FMT_LOCAL);
 	/*
* Unmerged path fs/xfs/libxfs/xfs_format.h
diff --git a/fs/xfs/libxfs/xfs_fs.h b/fs/xfs/libxfs/xfs_fs.h
index 6a872f3ab9b6..05fad6f381ef 100644
--- a/fs/xfs/libxfs/xfs_fs.h
+++ b/fs/xfs/libxfs/xfs_fs.h
@@ -320,10 +320,10 @@ typedef struct xfs_bstat {
  * and using two 16bit values to hold new 32bit projid was choosen
  * to retain compatibility with "old" filesystems).
  */
-static inline __uint32_t
+static inline uint32_t
 bstat_get_projid(struct xfs_bstat *bs)
 {
-	return (__uint32_t)bs->bs_projid_hi << 16 | bs->bs_projid_lo;
+	return (uint32_t)bs->bs_projid_hi << 16 | bs->bs_projid_lo;
 }
 
 /*
@@ -469,10 +469,10 @@ typedef struct xfs_handle {
  */
 typedef struct xfs_swapext
 {
-	__int64_t	sx_version;	/* version */
+	int64_t		sx_version;	/* version */
 #define XFS_SX_VERSION		0
-	__int64_t	sx_fdtarget;	/* fd of target file */
-	__int64_t	sx_fdtmp;	/* fd of tmp file */
+	int64_t		sx_fdtarget;	/* fd of target file */
+	int64_t		sx_fdtmp;	/* fd of tmp file */
 	xfs_off_t	sx_offset;	/* offset into file */
 	xfs_off_t	sx_length;	/* leng from offset */
 	char		sx_pad[16];	/* pad space, unused */
@@ -559,7 +559,7 @@ typedef struct xfs_swapext
 #define XFS_IOC_ATTRLIST_BY_HANDLE   _IOW ('X', 122, struct xfs_fsop_attrlist_handlereq)
 #define XFS_IOC_ATTRMULTI_BY_HANDLE  _IOW ('X', 123, struct xfs_fsop_attrmulti_handlereq)
 #define XFS_IOC_FSGEOMETRY	     _IOR ('X', 124, struct xfs_fsop_geom)
-#define XFS_IOC_GOINGDOWN	     _IOR ('X', 125, __uint32_t)
+#define XFS_IOC_GOINGDOWN	     _IOR ('X', 125, uint32_t)
 /*	XFS_IOC_GETFSUUID ---------- deprecated 140	 */
 
 
diff --git a/fs/xfs/libxfs/xfs_ialloc.c b/fs/xfs/libxfs/xfs_ialloc.c
index b3f63491d327..0e141ba76ba8 100644
--- a/fs/xfs/libxfs/xfs_ialloc.c
+++ b/fs/xfs/libxfs/xfs_ialloc.c
@@ -139,9 +139,9 @@ xfs_inobt_get_rec(
 STATIC int
 xfs_inobt_insert_rec(
 	struct xfs_btree_cur	*cur,
-	__uint16_t		holemask,
-	__uint8_t		count,
-	__int32_t		freecount,
+	uint16_t		holemask,
+	uint8_t			count,
+	int32_t			freecount,
 	xfs_inofree_t		free,
 	int			*stat)
 {
diff --git a/fs/xfs/libxfs/xfs_ialloc_btree.c b/fs/xfs/libxfs/xfs_ialloc_btree.c
index 1002677e914d..eb7f6d22c083 100644
--- a/fs/xfs/libxfs/xfs_ialloc_btree.c
+++ b/fs/xfs/libxfs/xfs_ialloc_btree.c
@@ -190,12 +190,12 @@ xfs_finobt_init_ptr_from_cur(
 	ptr->s = agi->agi_free_root;
 }
 
-STATIC __int64_t
+STATIC int64_t
 xfs_inobt_key_diff(
 	struct xfs_btree_cur	*cur,
 	union xfs_btree_key	*key)
 {
-	return (__int64_t)be32_to_cpu(key->inobt.ir_startino) -
+	return (int64_t)be32_to_cpu(key->inobt.ir_startino) -
 			  cur->bc_rec.i.ir_startino;
 }
 
diff --git a/fs/xfs/libxfs/xfs_inode_buf.c b/fs/xfs/libxfs/xfs_inode_buf.c
index 5fb249cbd278..fd400bae3bb8 100644
--- a/fs/xfs/libxfs/xfs_inode_buf.c
+++ b/fs/xfs/libxfs/xfs_inode_buf.c
@@ -423,7 +423,7 @@ xfs_dinode_calc_crc(
 	struct xfs_mount	*mp,
 	struct xfs_dinode	*dip)
 {
-	__uint32_t		crc;
+	uint32_t		crc;
 
 	if (dip->di_version < 3)
 		return;
* Unmerged path fs/xfs/libxfs/xfs_inode_buf.h
* Unmerged path fs/xfs/libxfs/xfs_log_format.h
diff --git a/fs/xfs/libxfs/xfs_log_recover.h b/fs/xfs/libxfs/xfs_log_recover.h
index d9f65e2d5cc8..8204f1053f27 100644
--- a/fs/xfs/libxfs/xfs_log_recover.h
+++ b/fs/xfs/libxfs/xfs_log_recover.h
@@ -26,7 +26,7 @@
 #define XLOG_RHASH_SIZE	16
 #define XLOG_RHASH_SHIFT 2
 #define XLOG_RHASH(tid)	\
-	((((__uint32_t)tid)>>XLOG_RHASH_SHIFT) & (XLOG_RHASH_SIZE-1))
+	((((uint32_t)tid)>>XLOG_RHASH_SHIFT) & (XLOG_RHASH_SIZE-1))
 
 #define XLOG_MAX_REGIONS_IN_ITEM   (XFS_MAX_BLOCKSIZE / XFS_BLF_CHUNK / 2 + 1)
 
diff --git a/fs/xfs/libxfs/xfs_quota_defs.h b/fs/xfs/libxfs/xfs_quota_defs.h
index 8eed51275bb3..d69c772271cb 100644
--- a/fs/xfs/libxfs/xfs_quota_defs.h
+++ b/fs/xfs/libxfs/xfs_quota_defs.h
@@ -27,8 +27,8 @@
  * they may need 64-bit accounting. Hence, 64-bit quota-counters,
  * and quota-limits. This is a waste in the common case, but hey ...
  */
-typedef __uint64_t	xfs_qcnt_t;
-typedef __uint16_t	xfs_qwarncnt_t;
+typedef uint64_t	xfs_qcnt_t;
+typedef uint16_t	xfs_qwarncnt_t;
 
 /*
  * flags for q_flags field in the dquot.
* Unmerged path fs/xfs/libxfs/xfs_refcount_btree.c
* Unmerged path fs/xfs/libxfs/xfs_rmap.c
* Unmerged path fs/xfs/libxfs/xfs_rmap.h
* Unmerged path fs/xfs/libxfs/xfs_rmap_btree.c
diff --git a/fs/xfs/libxfs/xfs_rtbitmap.c b/fs/xfs/libxfs/xfs_rtbitmap.c
index ea45584a9913..23e91e7c705c 100644
--- a/fs/xfs/libxfs/xfs_rtbitmap.c
+++ b/fs/xfs/libxfs/xfs_rtbitmap.c
@@ -1011,7 +1011,7 @@ xfs_rtfree_extent(
 	    mp->m_sb.sb_rextents) {
 		if (!(mp->m_rbmip->i_d.di_flags & XFS_DIFLAG_NEWRTBM))
 			mp->m_rbmip->i_d.di_flags |= XFS_DIFLAG_NEWRTBM;
-		*(__uint64_t *)&VFS_I(mp->m_rbmip)->i_atime = 0;
+		*(uint64_t *)&VFS_I(mp->m_rbmip)->i_atime = 0;
 		xfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);
 	}
 	return 0;
diff --git a/fs/xfs/libxfs/xfs_sb.c b/fs/xfs/libxfs/xfs_sb.c
index d70ea7b614eb..f9f4d7c72f46 100644
--- a/fs/xfs/libxfs/xfs_sb.c
+++ b/fs/xfs/libxfs/xfs_sb.c
@@ -445,7 +445,7 @@ xfs_sb_quota_to_disk(
 	struct xfs_dsb	*to,
 	struct xfs_sb	*from)
 {
-	__uint16_t	qflags = from->sb_qflags;
+	uint16_t	qflags = from->sb_qflags;
 
 	to->sb_uquotino = cpu_to_be64(from->sb_uquotino);
 	if (xfs_sb_version_has_pquotino(from)) {
@@ -741,7 +741,7 @@ xfs_sb_mount_common(
 	mp->m_bmap_dmnr[1] = mp->m_bmap_dmxr[1] / 2;
 
 	mp->m_bsize = XFS_FSB_TO_BB(mp, 1);
-	mp->m_ialloc_inos = (int)MAX((__uint16_t)XFS_INODES_PER_CHUNK,
+	mp->m_ialloc_inos = (int)MAX((uint16_t)XFS_INODES_PER_CHUNK,
 					sbp->sb_inopblock);
 	mp->m_ialloc_blks = mp->m_ialloc_inos >> sbp->sb_inopblog;
 
diff --git a/fs/xfs/libxfs/xfs_types.h b/fs/xfs/libxfs/xfs_types.h
index d08ed660b776..10360687fd92 100644
--- a/fs/xfs/libxfs/xfs_types.h
+++ b/fs/xfs/libxfs/xfs_types.h
@@ -18,34 +18,34 @@
 #ifndef __XFS_TYPES_H__
 #define	__XFS_TYPES_H__
 
-typedef __uint32_t	prid_t;		/* project ID */
+typedef uint32_t	prid_t;		/* project ID */
 
-typedef __uint32_t	xfs_agblock_t;	/* blockno in alloc. group */
-typedef	__uint32_t	xfs_agino_t;	/* inode # within allocation grp */
-typedef	__uint32_t	xfs_extlen_t;	/* extent length in blocks */
-typedef	__uint32_t	xfs_agnumber_t;	/* allocation group number */
-typedef __int32_t	xfs_extnum_t;	/* # of extents in a file */
-typedef __int16_t	xfs_aextnum_t;	/* # extents in an attribute fork */
-typedef	__int64_t	xfs_fsize_t;	/* bytes in a file */
-typedef __uint64_t	xfs_ufsize_t;	/* unsigned bytes in a file */
+typedef uint32_t	xfs_agblock_t;	/* blockno in alloc. group */
+typedef uint32_t	xfs_agino_t;	/* inode # within allocation grp */
+typedef uint32_t	xfs_extlen_t;	/* extent length in blocks */
+typedef uint32_t	xfs_agnumber_t;	/* allocation group number */
+typedef int32_t		xfs_extnum_t;	/* # of extents in a file */
+typedef int16_t		xfs_aextnum_t;	/* # extents in an attribute fork */
+typedef int64_t		xfs_fsize_t;	/* bytes in a file */
+typedef uint64_t	xfs_ufsize_t;	/* unsigned bytes in a file */
 
-typedef	__int32_t	xfs_suminfo_t;	/* type of bitmap summary info */
-typedef	__int32_t	xfs_rtword_t;	/* word type for bitmap manipulations */
+typedef int32_t		xfs_suminfo_t;	/* type of bitmap summary info */
+typedef int32_t		xfs_rtword_t;	/* word type for bitmap manipulations */
 
-typedef	__int64_t	xfs_lsn_t;	/* log sequence number */
-typedef	__int32_t	xfs_tid_t;	/* transaction identifier */
+typedef int64_t		xfs_lsn_t;	/* log sequence number */
+typedef int32_t		xfs_tid_t;	/* transaction identifier */
 
-typedef	__uint32_t	xfs_dablk_t;	/* dir/attr block number (in file) */
-typedef	__uint32_t	xfs_dahash_t;	/* dir/attr hash value */
+typedef uint32_t	xfs_dablk_t;	/* dir/attr block number (in file) */
+typedef uint32_t	xfs_dahash_t;	/* dir/attr hash value */
 
-typedef	__uint64_t	xfs_fsblock_t;	/* blockno in filesystem (agno|agbno) */
-typedef __uint64_t	xfs_rfsblock_t;	/* blockno in filesystem (raw) */
-typedef __uint64_t	xfs_rtblock_t;	/* extent (block) in realtime area */
-typedef __uint64_t	xfs_fileoff_t;	/* block number in a file */
-typedef __uint64_t	xfs_filblks_t;	/* number of blocks in a file */
+typedef uint64_t	xfs_fsblock_t;	/* blockno in filesystem (agno|agbno) */
+typedef uint64_t	xfs_rfsblock_t;	/* blockno in filesystem (raw) */
+typedef uint64_t	xfs_rtblock_t;	/* extent (block) in realtime area */
+typedef uint64_t	xfs_fileoff_t;	/* block number in a file */
+typedef uint64_t	xfs_filblks_t;	/* number of blocks in a file */
 
-typedef	__int64_t	xfs_srtblock_t;	/* signed version of xfs_rtblock_t */
-typedef __int64_t	xfs_sfiloff_t;	/* signed block number in a file */
+typedef int64_t		xfs_srtblock_t;	/* signed version of xfs_rtblock_t */
+typedef int64_t		xfs_sfiloff_t;	/* signed block number in a file */
 
 /*
  * Null values for the types.
@@ -124,7 +124,7 @@ struct xfs_name {
  * uid_t and gid_t are hard-coded to 32 bits in the inode.
  * Hence, an 'id' in a dquot is 32 bits..
  */
-typedef __uint32_t	xfs_dqid_t;
+typedef uint32_t	xfs_dqid_t;
 
 /*
  * Constants for bit manipulations.
diff --git a/fs/xfs/xfs_aops.c b/fs/xfs/xfs_aops.c
index 27f979ff685f..5d9cca78124e 100644
--- a/fs/xfs/xfs_aops.c
+++ b/fs/xfs/xfs_aops.c
@@ -776,7 +776,7 @@ xfs_writepage_map(
 	struct inode		*inode,
 	struct page		*page,
 	loff_t			offset,
-	__uint64_t              end_offset)
+	uint64_t              end_offset)
 {
 	LIST_HEAD(submit_list);
 	struct xfs_ioend	*ioend, *next;
@@ -928,7 +928,7 @@ xfs_do_writepage(
 	struct xfs_writepage_ctx *wpc = data;
 	struct inode		*inode = page->mapping->host;
 	loff_t			offset;
-	__uint64_t              end_offset;
+	uint64_t              end_offset;
 	pgoff_t                 end_index;
 
 	trace_xfs_writepage(inode, page, 0, 0);
diff --git a/fs/xfs/xfs_attr_list.c b/fs/xfs/xfs_attr_list.c
index 97c45b6eb91e..9bc1e1217989 100644
--- a/fs/xfs/xfs_attr_list.c
+++ b/fs/xfs/xfs_attr_list.c
@@ -279,7 +279,7 @@ xfs_attr_node_list(xfs_attr_list_context_t *context)
 	if (bp == NULL) {
 		cursor->blkno = 0;
 		for (;;) {
-			__uint16_t magic;
+			uint16_t magic;
 
 			error = xfs_da3_node_read(NULL, dp,
 						      cursor->blkno, -1, &bp,
* Unmerged path fs/xfs/xfs_bmap_util.c
diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c
index 83f56c93d562..d44b6141ceb3 100644
--- a/fs/xfs/xfs_buf.c
+++ b/fs/xfs/xfs_buf.c
@@ -1219,7 +1219,7 @@ xfs_buf_ioerror_alert(
 {
 	xfs_alert(bp->b_target->bt_mount,
 "metadata I/O error: block 0x%llx (\"%s\") error %d numblks %d",
-		(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);
+		(uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);
 }
 
 int
diff --git a/fs/xfs/xfs_dir2_readdir.c b/fs/xfs/xfs_dir2_readdir.c
index dcd58b2d6d72..6e6da4115398 100644
--- a/fs/xfs/xfs_dir2_readdir.c
+++ b/fs/xfs/xfs_dir2_readdir.c
@@ -44,7 +44,7 @@ static unsigned char xfs_dir3_filetype_table[] = {
 static unsigned char
 xfs_dir3_get_dtype(
 	struct xfs_mount	*mp,
-	__uint8_t		filetype)
+	uint8_t			filetype)
 {
 	if (!xfs_sb_version_hasftype(&mp->m_sb))
 		return DT_UNKNOWN;
@@ -121,7 +121,7 @@ xfs_dir2_sf_getdents(
 	 */
 	sfep = xfs_dir2_sf_firstentry(sfp);
 	for (i = 0; i < sfp->count; i++) {
-		__uint8_t filetype;
+		uint8_t filetype;
 
 		off = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,
 				xfs_dir2_sf_get_offset(sfep));
@@ -202,7 +202,7 @@ xfs_dir2_block_getdents(
 	 * Each object is a real entry (dep) or an unused one (dup).
 	 */
 	while (ptr < endptr) {
-		__uint8_t filetype;
+		uint8_t filetype;
 
 		dup = (xfs_dir2_data_unused_t *)ptr;
 		/*
@@ -530,7 +530,7 @@ xfs_dir2_leaf_getdents(
 	 * Get more blocks and readahead as necessary.
 	 */
 	while (curoff < XFS_DIR2_LEAF_OFFSET) {
-		__uint8_t filetype;
+		uint8_t filetype;
 
 		/*
 		 * If we have no buffer, or we're off the end of the
diff --git a/fs/xfs/xfs_discard.c b/fs/xfs/xfs_discard.c
index 30a12ab61546..5a2a4e5a2ba7 100644
--- a/fs/xfs/xfs_discard.c
+++ b/fs/xfs/xfs_discard.c
@@ -39,7 +39,7 @@ xfs_trim_extents(
 	xfs_daddr_t		start,
 	xfs_daddr_t		end,
 	xfs_daddr_t		minlen,
-	__uint64_t		*blocks_trimmed)
+	uint64_t		*blocks_trimmed)
 {
 	struct block_device	*bdev = mp->m_ddev_targp->bt_bdev;
 	struct xfs_btree_cur	*cur;
@@ -166,7 +166,7 @@ xfs_ioc_trim(
 	struct fstrim_range	range;
 	xfs_daddr_t		start, end, minlen;
 	xfs_agnumber_t		start_agno, end_agno, agno;
-	__uint64_t		blocks_trimmed = 0;
+	uint64_t		blocks_trimmed = 0;
 	int			error, last_error = 0;
 
 	if (!capable(CAP_SYS_ADMIN))
diff --git a/fs/xfs/xfs_dquot.c b/fs/xfs/xfs_dquot.c
index 0c3db9a3a60b..e751deb3fa78 100644
--- a/fs/xfs/xfs_dquot.c
+++ b/fs/xfs/xfs_dquot.c
@@ -276,7 +276,7 @@ xfs_qm_init_dquot_blk(
 void
 xfs_dquot_set_prealloc_limits(struct xfs_dquot *dqp)
 {
-	__uint64_t space;
+	uint64_t space;
 
 	dqp->q_prealloc_hi_wmark = be64_to_cpu(dqp->q_core.d_blk_hardlimit);
 	dqp->q_prealloc_lo_wmark = be64_to_cpu(dqp->q_core.d_blk_softlimit);
diff --git a/fs/xfs/xfs_fsops.c b/fs/xfs/xfs_fsops.c
index 4c191d2194e8..dcd87737721c 100644
--- a/fs/xfs/xfs_fsops.c
+++ b/fs/xfs/xfs_fsops.c
@@ -496,7 +496,7 @@ xfs_growfs_data_private(
 	if (nagimax)
 		mp->m_maxagi = nagimax;
 	if (mp->m_sb.sb_imax_pct) {
-		__uint64_t icount = mp->m_sb.sb_dblocks * mp->m_sb.sb_imax_pct;
+		uint64_t icount = mp->m_sb.sb_dblocks * mp->m_sb.sb_imax_pct;
 		do_div(icount, 100);
 		mp->m_maxicount = icount << mp->m_sb.sb_inopblog;
 	} else
@@ -665,17 +665,17 @@ xfs_fs_counts(
 int
 xfs_reserve_blocks(
 	xfs_mount_t             *mp,
-	__uint64_t              *inval,
+	uint64_t              *inval,
 	xfs_fsop_resblks_t      *outval)
 {
-	__int64_t		lcounter, delta;
-	__int64_t		fdblks_delta = 0;
-	__uint64_t		request;
-	__int64_t		free;
+	int64_t			lcounter, delta;
+	int64_t			fdblks_delta = 0;
+	uint64_t		request;
+	int64_t			free;
 	int			error = 0;
 
 	/* If inval is null, report current values and return */
-	if (inval == (__uint64_t *)NULL) {
+	if (inval == (uint64_t *)NULL) {
 		if (!outval)
 			return -EINVAL;
 		outval->resblks = mp->m_resblks;
@@ -776,7 +776,7 @@ out:
 int
 xfs_fs_goingdown(
 	xfs_mount_t	*mp,
-	__uint32_t	inflags)
+	uint32_t	inflags)
 {
 	switch (inflags) {
 	case XFS_FSOP_GOING_FLAGS_DEFAULT: {
diff --git a/fs/xfs/xfs_fsops.h b/fs/xfs/xfs_fsops.h
index f32713f14f9a..79d3e766d109 100644
--- a/fs/xfs/xfs_fsops.h
+++ b/fs/xfs/xfs_fsops.h
@@ -22,8 +22,8 @@ extern int xfs_fs_geometry(xfs_mount_t *mp, xfs_fsop_geom_t *geo, int nversion);
 extern int xfs_growfs_data(xfs_mount_t *mp, xfs_growfs_data_t *in);
 extern int xfs_growfs_log(xfs_mount_t *mp, xfs_growfs_log_t *in);
 extern int xfs_fs_counts(xfs_mount_t *mp, xfs_fsop_counts_t *cnt);
-extern int xfs_reserve_blocks(xfs_mount_t *mp, __uint64_t *inval,
+extern int xfs_reserve_blocks(xfs_mount_t *mp, uint64_t *inval,
 				xfs_fsop_resblks_t *outval);
-extern int xfs_fs_goingdown(xfs_mount_t *mp, __uint32_t inflags);
+extern int xfs_fs_goingdown(xfs_mount_t *mp, uint32_t inflags);
 
 #endif	/* __XFS_FSOPS_H__ */
* Unmerged path fs/xfs/xfs_inode.c
diff --git a/fs/xfs/xfs_inode.h b/fs/xfs/xfs_inode.h
index c5d5738477f2..0926b0267c19 100644
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@ -192,8 +192,8 @@ static inline void
 xfs_set_projid(struct xfs_inode *ip,
 		prid_t projid)
 {
-	ip->i_d.di_projid_hi = (__uint16_t) (projid >> 16);
-	ip->i_d.di_projid_lo = (__uint16_t) (projid & 0xffff);
+	ip->i_d.di_projid_hi = (uint16_t) (projid >> 16);
+	ip->i_d.di_projid_lo = (uint16_t) (projid & 0xffff);
 }
 
 static inline prid_t
diff --git a/fs/xfs/xfs_ioctl.c b/fs/xfs/xfs_ioctl.c
index 473766e615fb..63fad8199144 100644
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@ -479,8 +479,8 @@ xfs_attrmulti_attr_get(
 	struct inode		*inode,
 	unsigned char		*name,
 	unsigned char		__user *ubuf,
-	__uint32_t		*len,
-	__uint32_t		flags)
+	uint32_t		*len,
+	uint32_t		flags)
 {
 	unsigned char		*kbuf;
 	int			error = -EFAULT;
@@ -508,8 +508,8 @@ xfs_attrmulti_attr_set(
 	struct inode		*inode,
 	unsigned char		*name,
 	const unsigned char	__user *ubuf,
-	__uint32_t		len,
-	__uint32_t		flags)
+	uint32_t		len,
+	uint32_t		flags)
 {
 	unsigned char		*kbuf;
 	int			error;
@@ -534,7 +534,7 @@ int
 xfs_attrmulti_attr_remove(
 	struct inode		*inode,
 	unsigned char		*name,
-	__uint32_t		flags)
+	uint32_t		flags)
 {
 	int			error;
 
@@ -912,7 +912,7 @@ xfs_merge_ioc_xflags(
 
 STATIC unsigned int
 xfs_di2lxflags(
-	__uint16_t	di_flags)
+	uint16_t	di_flags)
 {
 	unsigned int	flags = 0;
 
@@ -1263,7 +1263,7 @@ xfs_ioctl_setattr_check_projid(
 	struct fsxattr		*fa)
 {
 	/* Disallow 32bit project ids if projid32bit feature is not enabled. */
-	if (fa->fsx_projid > (__uint16_t)-1 &&
+	if (fa->fsx_projid > (uint16_t)-1 &&
 	    !xfs_sb_version_hasprojid32bit(&ip->i_mount->m_sb))
 		return -EINVAL;
 
@@ -1811,7 +1811,7 @@ xfs_file_ioctl(
 
 	case XFS_IOC_SET_RESBLKS: {
 		xfs_fsop_resblks_t inout;
-		__uint64_t	   in;
+		uint64_t	   in;
 
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
@@ -1897,12 +1897,12 @@ xfs_file_ioctl(
 	}
 
 	case XFS_IOC_GOINGDOWN: {
-		__uint32_t in;
+		uint32_t in;
 
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
 
-		if (get_user(in, (__uint32_t __user *)arg))
+		if (get_user(in, (uint32_t __user *)arg))
 			return -EFAULT;
 
 		return xfs_fs_goingdown(mp, in);
diff --git a/fs/xfs/xfs_ioctl.h b/fs/xfs/xfs_ioctl.h
index 8b52881bfd90..e86c3ea137d2 100644
--- a/fs/xfs/xfs_ioctl.h
+++ b/fs/xfs/xfs_ioctl.h
@@ -48,22 +48,22 @@ xfs_attrmulti_attr_get(
 	struct inode		*inode,
 	unsigned char		*name,
 	unsigned char		__user *ubuf,
-	__uint32_t		*len,
-	__uint32_t		flags);
+	uint32_t		*len,
+	uint32_t		flags);
 
 extern int
 xfs_attrmulti_attr_set(
 	struct inode		*inode,
 	unsigned char		*name,
 	const unsigned char	__user *ubuf,
-	__uint32_t		len,
-	__uint32_t		flags);
+	uint32_t		len,
+	uint32_t		flags);
 
 extern int
 xfs_attrmulti_attr_remove(
 	struct inode		*inode,
 	unsigned char		*name,
-	__uint32_t		flags);
+	uint32_t		flags);
 
 extern struct dentry *
 xfs_handle_to_dentry(
diff --git a/fs/xfs/xfs_ioctl32.h b/fs/xfs/xfs_ioctl32.h
index b1bb45444df8..5492bcf6f442 100644
--- a/fs/xfs/xfs_ioctl32.h
+++ b/fs/xfs/xfs_ioctl32.h
@@ -112,9 +112,9 @@ typedef struct compat_xfs_fsop_handlereq {
 
 /* The bstat field in the swapext struct needs translation */
 typedef struct compat_xfs_swapext {
-	__int64_t		sx_version;	/* version */
-	__int64_t		sx_fdtarget;	/* fd of target file */
-	__int64_t		sx_fdtmp;	/* fd of tmp file */
+	int64_t			sx_version;	/* version */
+	int64_t			sx_fdtarget;	/* fd of target file */
+	int64_t			sx_fdtmp;	/* fd of tmp file */
 	xfs_off_t		sx_offset;	/* offset into file */
 	xfs_off_t		sx_length;	/* leng from offset */
 	char			sx_pad[16];	/* pad space, unused */
diff --git a/fs/xfs/xfs_linux.h b/fs/xfs/xfs_linux.h
index 520fc1e28b55..e1b9fcb3dd49 100644
--- a/fs/xfs/xfs_linux.h
+++ b/fs/xfs/xfs_linux.h
@@ -24,14 +24,6 @@
 /*
  * Kernel specific type declarations for XFS
  */
-typedef signed char		__int8_t;
-typedef unsigned char		__uint8_t;
-typedef signed short int	__int16_t;
-typedef unsigned short int	__uint16_t;
-typedef signed int		__int32_t;
-typedef unsigned int		__uint32_t;
-typedef signed long long int	__int64_t;
-typedef unsigned long long int	__uint64_t;
 
 typedef __s64			xfs_off_t;	/* <file offset> type */
 typedef unsigned long long	xfs_ino_t;	/* <inode> type */
@@ -186,22 +178,22 @@ extern struct xstats xfsstats;
  * are converting to the init_user_ns. The uid is later mapped to a particular
  * user namespace value when crossing the kernel/user boundary.
  */
-static inline __uint32_t xfs_kuid_to_uid(kuid_t uid)
+static inline uint32_t xfs_kuid_to_uid(kuid_t uid)
 {
 	return from_kuid(&init_user_ns, uid);
 }
 
-static inline kuid_t xfs_uid_to_kuid(__uint32_t uid)
+static inline kuid_t xfs_uid_to_kuid(uint32_t uid)
 {
 	return make_kuid(&init_user_ns, uid);
 }
 
-static inline __uint32_t xfs_kgid_to_gid(kgid_t gid)
+static inline uint32_t xfs_kgid_to_gid(kgid_t gid)
 {
 	return from_kgid(&init_user_ns, gid);
 }
 
-static inline kgid_t xfs_gid_to_kgid(__uint32_t gid)
+static inline kgid_t xfs_gid_to_kgid(uint32_t gid)
 {
 	return make_kgid(&init_user_ns, gid);
 }
@@ -231,14 +223,14 @@ static inline __u32 xfs_do_mod(void *a, __u32 b, int n)
 
 #define do_mod(a, b)	xfs_do_mod(&(a), (b), sizeof(a))
 
-static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)
+static inline uint64_t roundup_64(uint64_t x, uint32_t y)
 {
 	x += y - 1;
 	do_div(x, y);
 	return x * y;
 }
 
-static inline __uint64_t howmany_64(__uint64_t x, __uint32_t y)
+static inline uint64_t howmany_64(uint64_t x, uint32_t y)
 {
 	x += y - 1;
 	do_div(x, y);
diff --git a/fs/xfs/xfs_log.c b/fs/xfs/xfs_log.c
index e11a8610e0c3..bd929a702fb6 100644
--- a/fs/xfs/xfs_log.c
+++ b/fs/xfs/xfs_log.c
@@ -434,7 +434,7 @@ xfs_log_reserve(
 	int		 	unit_bytes,
 	int		 	cnt,
 	struct xlog_ticket	**ticp,
-	__uint8_t	 	client,
+	uint8_t		 	client,
 	bool			permanent)
 {
 	struct xlog		*log = mp->m_log;
@@ -847,9 +847,9 @@ xfs_log_unmount_write(xfs_mount_t *mp)
 		if (!error) {
 			/* the data section must be 32 bit size aligned */
 			struct {
-			    __uint16_t magic;
-			    __uint16_t pad1;
-			    __uint32_t pad2; /* may as well make it 64 bits */
+			    uint16_t magic;
+			    uint16_t pad1;
+			    uint32_t pad2; /* may as well make it 64 bits */
 			} magic = {
 				.magic = XLOG_UNMOUNT_TYPE,
 			};
@@ -1687,7 +1687,7 @@ xlog_cksum(
 	char			*dp,
 	int			size)
 {
-	__uint32_t		crc;
+	uint32_t		crc;
 
 	/* first generate the crc for the record header ... */
 	crc = xfs_start_cksum_update((char *)rhead,
@@ -1850,7 +1850,7 @@ xlog_sync(
 		 */
 		dptr = (char *)&iclog->ic_header + count;
 		for (i = 0; i < split; i += BBSIZE) {
-			__uint32_t cycle = be32_to_cpu(*(__be32 *)dptr);
+			uint32_t cycle = be32_to_cpu(*(__be32 *)dptr);
 			if (++cycle == XLOG_HEADER_MAGIC_NUM)
 				cycle++;
 			*(__be32 *)dptr = cpu_to_be32(cycle);
@@ -2436,8 +2436,8 @@ xlog_write(
 			}
 
 			reg = &vecp[index];
-			ASSERT(reg->i_len % sizeof(__int32_t) == 0);
-			ASSERT((unsigned long)ptr % sizeof(__int32_t) == 0);
+			ASSERT(reg->i_len % sizeof(int32_t) == 0);
+			ASSERT((unsigned long)ptr % sizeof(int32_t) == 0);
 
 			start_rec_copy = xlog_write_start_rec(ptr, ticket);
 			if (start_rec_copy) {
@@ -3216,7 +3216,7 @@ xlog_state_switch_iclogs(
 	/* Round up to next log-sunit */
 	if (xfs_sb_version_haslogv2(&log->l_mp->m_sb) &&
 	    log->l_mp->m_sb.sb_logsunit > 1) {
-		__uint32_t sunit_bb = BTOBB(log->l_mp->m_sb.sb_logsunit);
+		uint32_t sunit_bb = BTOBB(log->l_mp->m_sb.sb_logsunit);
 		log->l_curr_block = roundup(log->l_curr_block, sunit_bb);
 	}
 
@@ -3844,7 +3844,7 @@ xlog_verify_iclog(
 	xlog_in_core_2_t	*xhdr;
 	void			*base_ptr, *ptr, *p;
 	ptrdiff_t		field_offset;
-	__uint8_t		clientid;
+	uint8_t			clientid;
 	int			len, i, j, k, op_len;
 	int			idx;
 
diff --git a/fs/xfs/xfs_log.h b/fs/xfs/xfs_log.h
index b5e71072fde5..cd6b6fa599ee 100644
--- a/fs/xfs/xfs_log.h
+++ b/fs/xfs/xfs_log.h
@@ -160,7 +160,7 @@ int	  xfs_log_reserve(struct xfs_mount *mp,
 			  int		   length,
 			  int		   count,
 			  struct xlog_ticket **ticket,
-			  __uint8_t	   clientid,
+			  uint8_t		   clientid,
 			  bool		   permanent);
 int	  xfs_log_regrant(struct xfs_mount *mp, struct xlog_ticket *tic);
 void      xfs_log_unmount(struct xfs_mount *mp);
diff --git a/fs/xfs/xfs_log_priv.h b/fs/xfs/xfs_log_priv.h
index 70855d2973a6..70c870ebbee8 100644
--- a/fs/xfs/xfs_log_priv.h
+++ b/fs/xfs/xfs_log_priv.h
@@ -418,7 +418,7 @@ struct xlog {
 };
 
 #define XLOG_BUF_CANCEL_BUCKET(log, blkno) \
-	((log)->l_buf_cancel_table + ((__uint64_t)blkno % XLOG_BC_TABLE_SIZE))
+	((log)->l_buf_cancel_table + ((uint64_t)blkno % XLOG_BC_TABLE_SIZE))
 
 #define XLOG_FORCED_SHUTDOWN(log)	((log)->l_flags & XLOG_IO_ERROR)
 
* Unmerged path fs/xfs/xfs_log_recover.c
diff --git a/fs/xfs/xfs_mount.c b/fs/xfs/xfs_mount.c
index f2739c163f53..6b26331f98a7 100644
--- a/fs/xfs/xfs_mount.c
+++ b/fs/xfs/xfs_mount.c
@@ -169,7 +169,7 @@ xfs_free_perag(
 int
 xfs_sb_validate_fsb_count(
 	xfs_sb_t	*sbp,
-	__uint64_t	nblocks)
+	uint64_t	nblocks)
 {
 	ASSERT(PAGE_SHIFT >= sbp->sb_blocklog);
 	ASSERT(sbp->sb_blocklog >= BBSHIFT);
@@ -420,7 +420,7 @@ STATIC void
 xfs_set_maxicount(xfs_mount_t *mp)
 {
 	xfs_sb_t	*sbp = &(mp->m_sb);
-	__uint64_t	icount;
+	uint64_t	icount;
 
 	if (sbp->sb_imax_pct) {
 		/*
@@ -486,7 +486,7 @@ xfs_set_low_space_thresholds(
 	int i;
 
 	for (i = 0; i < XFS_LOWSP_MAX; i++) {
-		__uint64_t space = mp->m_sb.sb_dblocks;
+		uint64_t space = mp->m_sb.sb_dblocks;
 
 		do_div(space, 100);
 		mp->m_low_space[i] = space * (i + 1);
@@ -582,10 +582,10 @@ xfs_mount_reset_sbqflags(
 	return xfs_sync_sb(mp, false);
 }
 
-__uint64_t
+uint64_t
 xfs_default_resblks(xfs_mount_t *mp)
 {
-	__uint64_t resblks;
+	uint64_t resblks;
 
 	/*
 	 * We default to 5% or 8192 fsbs of space reserved, whichever is
@@ -596,7 +596,7 @@ xfs_default_resblks(xfs_mount_t *mp)
 	 */
 	resblks = mp->m_sb.sb_dblocks;
 	do_div(resblks, 20);
-	resblks = min_t(__uint64_t, resblks, 8192);
+	resblks = min_t(uint64_t, resblks, 8192);
 	return resblks;
 }
 
@@ -616,7 +616,7 @@ xfs_mountfs(
 {
 	struct xfs_sb		*sbp = &(mp->m_sb);
 	struct xfs_inode	*rip;
-	__uint64_t		resblks;
+	uint64_t		resblks;
 	uint			quotamount = 0;
 	uint			quotaflags = 0;
 	int			error = 0;
@@ -1018,7 +1018,7 @@ void
 xfs_unmountfs(
 	struct xfs_mount	*mp)
 {
-	__uint64_t		resblks;
+	uint64_t		resblks;
 	int			error;
 
 	cancel_delayed_work_sync(&mp->m_eofblocks_work);
* Unmerged path fs/xfs/xfs_mount.h
diff --git a/fs/xfs/xfs_qm_bhv.c b/fs/xfs/xfs_qm_bhv.c
index 3e52d5de7ae1..2be6d2735ca9 100644
--- a/fs/xfs/xfs_qm_bhv.c
+++ b/fs/xfs/xfs_qm_bhv.c
@@ -33,7 +33,7 @@ xfs_fill_statvfs_from_dquot(
 	struct kstatfs		*statp,
 	struct xfs_dquot	*dqp)
 {
-	__uint64_t		limit;
+	uint64_t		limit;
 
 	limit = dqp->q_core.d_blk_softlimit ?
 		be64_to_cpu(dqp->q_core.d_blk_softlimit) :
diff --git a/fs/xfs/xfs_rtalloc.c b/fs/xfs/xfs_rtalloc.c
index c57aa7f18087..91472193643b 100644
--- a/fs/xfs/xfs_rtalloc.c
+++ b/fs/xfs/xfs_rtalloc.c
@@ -1256,13 +1256,13 @@ xfs_rtpick_extent(
 {
 	xfs_rtblock_t	b;		/* result block */
 	int		log2;		/* log of sequence number */
-	__uint64_t	resid;		/* residual after log removed */
-	__uint64_t	seq;		/* sequence number of file creation */
-	__uint64_t	*seqp;		/* pointer to seqno in inode */
+	uint64_t	resid;		/* residual after log removed */
+	uint64_t	seq;		/* sequence number of file creation */
+	uint64_t	*seqp;		/* pointer to seqno in inode */
 
 	ASSERT(xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL));
 
-	seqp = (__uint64_t *)&VFS_I(mp->m_rbmip)->i_atime;
+	seqp = (uint64_t *)&VFS_I(mp->m_rbmip)->i_atime;
 	if (!(mp->m_rbmip->i_d.di_flags & XFS_DIFLAG_NEWRTBM)) {
 		mp->m_rbmip->i_d.di_flags |= XFS_DIFLAG_NEWRTBM;
 		*seqp = 0;
diff --git a/fs/xfs/xfs_stats.c b/fs/xfs/xfs_stats.c
index 8686df6c7609..dec7ba9b4def 100644
--- a/fs/xfs/xfs_stats.c
+++ b/fs/xfs/xfs_stats.c
@@ -33,9 +33,9 @@ int xfs_stats_format(struct xfsstats __percpu *stats, char *buf)
 {
 	int		i, j;
 	int		len = 0;
-	__uint64_t	xs_xstrat_bytes = 0;
-	__uint64_t	xs_write_bytes = 0;
-	__uint64_t	xs_read_bytes = 0;
+	uint64_t	xs_xstrat_bytes = 0;
+	uint64_t	xs_write_bytes = 0;
+	uint64_t	xs_read_bytes = 0;
 
 	static const struct xstats_entry {
 		char	*desc;
@@ -98,7 +98,7 @@ int xfs_stats_format(struct xfsstats __percpu *stats, char *buf)
 void xfs_stats_clearall(struct xfsstats __percpu *stats)
 {
 	int		c;
-	__uint32_t	vn_active;
+	uint32_t	vn_active;
 
 	xfs_notice(NULL, "Clearing xfsstats");
 	for_each_possible_cpu(c) {
* Unmerged path fs/xfs/xfs_stats.h
* Unmerged path fs/xfs/xfs_super.c
* Unmerged path fs/xfs/xfs_trace.h
* Unmerged path fs/xfs/xfs_trans.h
* Unmerged path fs/xfs/xfs_trans_rmap.c
