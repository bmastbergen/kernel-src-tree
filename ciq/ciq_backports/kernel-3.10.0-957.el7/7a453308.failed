ipmi_si: Move hardcode handling to a separate file.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [char] ipmi_si: Move hardcode handling to a separate file (Tony Camuso) [1541533]
Rebuild_FUZZ: 99.01%
commit-author Corey Minyard <cminyard@mvista.com>
commit 7a4533087ccbf736396bcbf816e0e45266c4313b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7a453308.failed

	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit 7a4533087ccbf736396bcbf816e0e45266c4313b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/Makefile
#	drivers/char/ipmi/ipmi_si.h
#	drivers/char/ipmi/ipmi_si_intf.c
diff --cc drivers/char/ipmi/Makefile
index eefb0b301e83,ebd728497b23..000000000000
--- a/drivers/char/ipmi/Makefile
+++ b/drivers/char/ipmi/Makefile
@@@ -2,7 -2,8 +2,12 @@@
  # Makefile for the ipmi drivers.
  #
  
++<<<<<<< HEAD
 +ipmi_si-y := ipmi_si_intf.o ipmi_kcs_sm.o ipmi_smic_sm.o ipmi_bt_sm.o
++=======
+ ipmi_si-y := ipmi_si_intf.o ipmi_kcs_sm.o ipmi_smic_sm.o ipmi_bt_sm.o \
+ 	ipmi_si_hotmod.o ipmi_si_hardcode.o
++>>>>>>> 7a4533087ccb (ipmi_si: Move hardcode handling to a separate file.)
  
  obj-$(CONFIG_IPMI_HANDLER) += ipmi_msghandler.o
  obj-$(CONFIG_IPMI_DEVICE_INTERFACE) += ipmi_devintf.o
diff --cc drivers/char/ipmi/ipmi_si.h
index a4d993b1fe66,1dbd58afc2d7..000000000000
--- a/drivers/char/ipmi/ipmi_si.h
+++ b/drivers/char/ipmi/ipmi_si.h
@@@ -13,6 -14,12 +13,18 @@@
  #define DEFAULT_REGSPACING	1
  #define DEFAULT_REGSIZE		1
  
++<<<<<<< HEAD
 +struct smi_info;
 +
 +int ipmi_si_add_smi(struct smi_info *info);
++=======
+ int ipmi_si_add_smi(struct si_sm_io *io);
+ irqreturn_t ipmi_si_irq_handler(int irq, void *data);
+ void ipmi_irq_start_cleanup(struct si_sm_io *io);
+ int ipmi_std_irq_setup(struct si_sm_io *io);
+ void ipmi_irq_finish_setup(struct si_sm_io *io);
+ int ipmi_si_remove_by_dev(struct device *dev);
+ void ipmi_si_remove_by_data(int addr_space, enum si_type si_type,
+ 			    unsigned long addr);
+ int ipmi_si_hardcode_find_bmc(void);
++>>>>>>> 7a4533087ccb (ipmi_si: Move hardcode handling to a separate file.)
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 72982bfaeaf1,58f0ebbcd342..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -311,21 -291,20 +311,20 @@@ struct smi_info 
  #define smi_get_stat(smi, stat) \
  	((unsigned int) atomic_read(&(smi)->stats[SI_STAT_ ## stat]))
  
- #define SI_MAX_PARMS 4
- 
- static int force_kipmid[SI_MAX_PARMS];
+ #define IPMI_MAX_INTFS 4
+ static int force_kipmid[IPMI_MAX_INTFS];
  static int num_force_kipmid;
  #ifdef CONFIG_PCI
 -static bool pci_registered;
 +static int pci_registered;
  #endif
  #ifdef CONFIG_PARISC
  static bool parisc_registered;
  #endif
  
- static unsigned int kipmid_max_busy_us[SI_MAX_PARMS];
+ static unsigned int kipmid_max_busy_us[IPMI_MAX_INTFS];
  static int num_max_busy_us;
  
 -static bool unload_when_empty = true;
 +static int unload_when_empty = 1;
  
  static int try_smi_init(struct smi_info *smi);
  static void cleanup_one_si(struct smi_info *to_clean);
@@@ -1359,48 -1306,6 +1336,51 @@@ module_param_named(trypci, si_trypci, b
  MODULE_PARM_DESC(trypci, "Setting this to zero will disable the"
  		 " default scan of the interfaces identified via pci");
  #endif
++<<<<<<< HEAD
 +module_param_string(type, si_type_str, MAX_SI_TYPE_STR, 0);
 +MODULE_PARM_DESC(type, "Defines the type of each interface, each"
 +		 " interface separated by commas.  The types are 'kcs',"
 +		 " 'smic', and 'bt'.  For example si_type=kcs,bt will set"
 +		 " the first interface to kcs and the second to bt");
 +module_param_array(addrs, ulong, &num_addrs, 0);
 +MODULE_PARM_DESC(addrs, "Sets the memory address of each interface, the"
 +		 " addresses separated by commas.  Only use if an interface"
 +		 " is in memory.  Otherwise, set it to zero or leave"
 +		 " it blank.");
 +module_param_array(ports, uint, &num_ports, 0);
 +MODULE_PARM_DESC(ports, "Sets the port address of each interface, the"
 +		 " addresses separated by commas.  Only use if an interface"
 +		 " is a port.  Otherwise, set it to zero or leave"
 +		 " it blank.");
 +module_param_array(irqs, int, &num_irqs, 0);
 +MODULE_PARM_DESC(irqs, "Sets the interrupt of each interface, the"
 +		 " addresses separated by commas.  Only use if an interface"
 +		 " has an interrupt.  Otherwise, set it to zero or leave"
 +		 " it blank.");
 +module_param_array(regspacings, int, &num_regspacings, 0);
 +MODULE_PARM_DESC(regspacings, "The number of bytes between the start address"
 +		 " and each successive register used by the interface.  For"
 +		 " instance, if the start address is 0xca2 and the spacing"
 +		 " is 2, then the second address is at 0xca4.  Defaults"
 +		 " to 1.");
 +module_param_array(regsizes, int, &num_regsizes, 0);
 +MODULE_PARM_DESC(regsizes, "The size of the specific IPMI register in bytes."
 +		 " This should generally be 1, 2, 4, or 8 for an 8-bit,"
 +		 " 16-bit, 32-bit, or 64-bit register.  Use this if you"
 +		 " the 8-bit IPMI register has to be read from a larger"
 +		 " register.");
 +module_param_array(regshifts, int, &num_regshifts, 0);
 +MODULE_PARM_DESC(regshifts, "The amount to shift the data read from the."
 +		 " IPMI register, in bits.  For instance, if the data"
 +		 " is read from a 32-bit word and the IPMI data is in"
 +		 " bit 8-15, then the shift would be 8");
 +module_param_array(slave_addrs, int, &num_slave_addrs, 0);
 +MODULE_PARM_DESC(slave_addrs, "Set the default IPMB slave address for"
 +		 " the controller.  Normally this is 0x20, but can be"
 +		 " overridden by this parm.  This is an array indexed"
 +		 " by interface number.");
++=======
++>>>>>>> 7a4533087ccb (ipmi_si: Move hardcode handling to a separate file.)
  module_param_array(force_kipmid, int, &num_force_kipmid, 0);
  MODULE_PARM_DESC(force_kipmid, "Force the kipmi daemon to be enabled (1) or"
  		 " disabled(0).  Normally the IPMI driver auto-detects"
@@@ -1799,252 -1626,6 +1779,255 @@@ static struct smi_info *smi_info_alloc(
  	return info;
  }
  
++<<<<<<< HEAD
 +static int hotmod_handler(const char *val, struct kernel_param *kp)
 +{
 +	char *str = kstrdup(val, GFP_KERNEL);
 +	int  rv;
 +	char *next, *curr, *s, *n, *o;
 +	enum hotmod_op op;
 +	enum si_type si_type;
 +	int  addr_space;
 +	unsigned long addr;
 +	int regspacing;
 +	int regsize;
 +	int regshift;
 +	int irq;
 +	int ipmb;
 +	int ival;
 +	int len;
 +	struct smi_info *info;
 +
 +	if (!str)
 +		return -ENOMEM;
 +
 +	/* Kill any trailing spaces, as we can get a "\n" from echo. */
 +	len = strlen(str);
 +	ival = len - 1;
 +	while ((ival >= 0) && isspace(str[ival])) {
 +		str[ival] = '\0';
 +		ival--;
 +	}
 +
 +	for (curr = str; curr; curr = next) {
 +		regspacing = 1;
 +		regsize = 1;
 +		regshift = 0;
 +		irq = 0;
 +		ipmb = 0; /* Choose the default if not specified */
 +
 +		next = strchr(curr, ':');
 +		if (next) {
 +			*next = '\0';
 +			next++;
 +		}
 +
 +		rv = parse_str(hotmod_ops, &ival, "operation", &curr);
 +		if (rv)
 +			break;
 +		op = ival;
 +
 +		rv = parse_str(hotmod_si, &ival, "interface type", &curr);
 +		if (rv)
 +			break;
 +		si_type = ival;
 +
 +		rv = parse_str(hotmod_as, &addr_space, "address space", &curr);
 +		if (rv)
 +			break;
 +
 +		s = strchr(curr, ',');
 +		if (s) {
 +			*s = '\0';
 +			s++;
 +		}
 +		addr = simple_strtoul(curr, &n, 0);
 +		if ((*n != '\0') || (*curr == '\0')) {
 +			pr_warn(PFX "Invalid hotmod address '%s'\n", curr);
 +			break;
 +		}
 +
 +		while (s) {
 +			curr = s;
 +			s = strchr(curr, ',');
 +			if (s) {
 +				*s = '\0';
 +				s++;
 +			}
 +			o = strchr(curr, '=');
 +			if (o) {
 +				*o = '\0';
 +				o++;
 +			}
 +			rv = check_hotmod_int_op(curr, o, "rsp", &regspacing);
 +			if (rv < 0)
 +				goto out;
 +			else if (rv)
 +				continue;
 +			rv = check_hotmod_int_op(curr, o, "rsi", &regsize);
 +			if (rv < 0)
 +				goto out;
 +			else if (rv)
 +				continue;
 +			rv = check_hotmod_int_op(curr, o, "rsh", &regshift);
 +			if (rv < 0)
 +				goto out;
 +			else if (rv)
 +				continue;
 +			rv = check_hotmod_int_op(curr, o, "irq", &irq);
 +			if (rv < 0)
 +				goto out;
 +			else if (rv)
 +				continue;
 +			rv = check_hotmod_int_op(curr, o, "ipmb", &ipmb);
 +			if (rv < 0)
 +				goto out;
 +			else if (rv)
 +				continue;
 +
 +			rv = -EINVAL;
 +			pr_warn(PFX "Invalid hotmod option '%s'\n", curr);
 +			goto out;
 +		}
 +
 +		if (op == HM_ADD) {
 +			info = smi_info_alloc();
 +			if (!info) {
 +				rv = -ENOMEM;
 +				goto out;
 +			}
 +
 +			info->addr_source = SI_HOTMOD;
 +			info->si_type = si_type;
 +			info->io.addr_data = addr;
 +			info->io.addr_type = addr_space;
 +			if (addr_space == IPMI_MEM_ADDR_SPACE)
 +				info->io_setup = mem_setup;
 +			else
 +				info->io_setup = port_setup;
 +
 +			info->io.addr = NULL;
 +			info->io.regspacing = regspacing;
 +			if (!info->io.regspacing)
 +				info->io.regspacing = DEFAULT_REGSPACING;
 +			info->io.regsize = regsize;
 +			if (!info->io.regsize)
 +				info->io.regsize = DEFAULT_REGSIZE;
 +			info->io.regshift = regshift;
 +			info->irq = irq;
 +			if (info->irq)
 +				info->irq_setup = std_irq_setup;
 +			info->slave_addr = ipmb;
 +
 +			rv = ipmi_si_add_smi(info);
 +			if (rv) {
 +				kfree(info);
 +				goto out;
 +			}
 +			mutex_lock(&smi_infos_lock);
 +			rv = try_smi_init(info);
 +			mutex_unlock(&smi_infos_lock);
 +			if (rv) {
 +				cleanup_one_si(info);
 +				goto out;
 +			}
 +		} else {
 +			/* remove */
 +			struct smi_info *e, *tmp_e;
 +
 +			mutex_lock(&smi_infos_lock);
 +			list_for_each_entry_safe(e, tmp_e, &smi_infos, link) {
 +				if (e->io.addr_type != addr_space)
 +					continue;
 +				if (e->si_type != si_type)
 +					continue;
 +				if (e->io.addr_data == addr)
 +					cleanup_one_si(e);
 +			}
 +			mutex_unlock(&smi_infos_lock);
 +		}
 +	}
 +	rv = len;
 +out:
 +	kfree(str);
 +	return rv;
 +}
 +
 +static int hardcode_find_bmc(void)
 +{
 +	int ret = -ENODEV;
 +	int             i;
 +	struct smi_info *info;
 +
 +	for (i = 0; i < SI_MAX_PARMS; i++) {
 +		if (!ports[i] && !addrs[i])
 +			continue;
 +
 +		info = smi_info_alloc();
 +		if (!info)
 +			return -ENOMEM;
 +
 +		info->addr_source = SI_HARDCODED;
 +		pr_info(PFX "probing via hardcoded address\n");
 +
 +		if (!si_type[i] || strcmp(si_type[i], "kcs") == 0) {
 +			info->si_type = SI_KCS;
 +		} else if (strcmp(si_type[i], "smic") == 0) {
 +			info->si_type = SI_SMIC;
 +		} else if (strcmp(si_type[i], "bt") == 0) {
 +			info->si_type = SI_BT;
 +		} else {
 +			pr_warn(PFX "Interface type specified for interface %d, was invalid: %s\n",
 +				i, si_type[i]);
 +			kfree(info);
 +			continue;
 +		}
 +
 +		if (ports[i]) {
 +			/* An I/O port */
 +			info->io_setup = port_setup;
 +			info->io.addr_data = ports[i];
 +			info->io.addr_type = IPMI_IO_ADDR_SPACE;
 +		} else if (addrs[i]) {
 +			/* A memory port */
 +			info->io_setup = mem_setup;
 +			info->io.addr_data = addrs[i];
 +			info->io.addr_type = IPMI_MEM_ADDR_SPACE;
 +		} else {
 +			pr_warn(PFX "Interface type specified for interface %d, but port and address were not set or set to zero.\n",
 +				i);
 +			kfree(info);
 +			continue;
 +		}
 +
 +		info->io.addr = NULL;
 +		info->io.regspacing = regspacings[i];
 +		if (!info->io.regspacing)
 +			info->io.regspacing = DEFAULT_REGSPACING;
 +		info->io.regsize = regsizes[i];
 +		if (!info->io.regsize)
 +			info->io.regsize = DEFAULT_REGSIZE;
 +		info->io.regshift = regshifts[i];
 +		info->irq = irqs[i];
 +		if (info->irq)
 +			info->irq_setup = std_irq_setup;
 +		info->slave_addr = slave_addrs[i];
 +
 +		if (!ipmi_si_add_smi(info)) {
 +			mutex_lock(&smi_infos_lock);
 +			if (try_smi_init(info))
 +				cleanup_one_si(info);
 +			mutex_unlock(&smi_infos_lock);
 +			ret = 0;
 +		} else {
 +			kfree(info);
 +		}
 +	}
 +	return ret;
 +}
 +
++=======
++>>>>>>> 7a4533087ccb (ipmi_si: Move hardcode handling to a separate file.)
  #ifdef CONFIG_ACPI
  
  /*
* Unmerged path drivers/char/ipmi/Makefile
* Unmerged path drivers/char/ipmi/ipmi_si.h
diff --git a/drivers/char/ipmi/ipmi_si_hardcode.c b/drivers/char/ipmi/ipmi_si_hardcode.c
new file mode 100644
index 000000000000..fa9a4780de36
--- /dev/null
+++ b/drivers/char/ipmi/ipmi_si_hardcode.c
@@ -0,0 +1,146 @@
+
+#include <linux/moduleparam.h>
+#include "ipmi_si.h"
+
+#define PFX "ipmi_hardcode: "
+/*
+ * There can be 4 IO ports passed in (with or without IRQs), 4 addresses,
+ * a default IO port, and 1 ACPI/SPMI address.  That sets SI_MAX_DRIVERS.
+ */
+
+#define SI_MAX_PARMS 4
+
+static char          *si_type[SI_MAX_PARMS];
+#define MAX_SI_TYPE_STR 30
+static char          si_type_str[MAX_SI_TYPE_STR];
+static unsigned long addrs[SI_MAX_PARMS];
+static unsigned int num_addrs;
+static unsigned int  ports[SI_MAX_PARMS];
+static unsigned int num_ports;
+static int           irqs[SI_MAX_PARMS];
+static unsigned int num_irqs;
+static int           regspacings[SI_MAX_PARMS];
+static unsigned int num_regspacings;
+static int           regsizes[SI_MAX_PARMS];
+static unsigned int num_regsizes;
+static int           regshifts[SI_MAX_PARMS];
+static unsigned int num_regshifts;
+static int slave_addrs[SI_MAX_PARMS]; /* Leaving 0 chooses the default value */
+static unsigned int num_slave_addrs;
+
+module_param_string(type, si_type_str, MAX_SI_TYPE_STR, 0);
+MODULE_PARM_DESC(type, "Defines the type of each interface, each"
+		 " interface separated by commas.  The types are 'kcs',"
+		 " 'smic', and 'bt'.  For example si_type=kcs,bt will set"
+		 " the first interface to kcs and the second to bt");
+module_param_hw_array(addrs, ulong, iomem, &num_addrs, 0);
+MODULE_PARM_DESC(addrs, "Sets the memory address of each interface, the"
+		 " addresses separated by commas.  Only use if an interface"
+		 " is in memory.  Otherwise, set it to zero or leave"
+		 " it blank.");
+module_param_hw_array(ports, uint, ioport, &num_ports, 0);
+MODULE_PARM_DESC(ports, "Sets the port address of each interface, the"
+		 " addresses separated by commas.  Only use if an interface"
+		 " is a port.  Otherwise, set it to zero or leave"
+		 " it blank.");
+module_param_hw_array(irqs, int, irq, &num_irqs, 0);
+MODULE_PARM_DESC(irqs, "Sets the interrupt of each interface, the"
+		 " addresses separated by commas.  Only use if an interface"
+		 " has an interrupt.  Otherwise, set it to zero or leave"
+		 " it blank.");
+module_param_hw_array(regspacings, int, other, &num_regspacings, 0);
+MODULE_PARM_DESC(regspacings, "The number of bytes between the start address"
+		 " and each successive register used by the interface.  For"
+		 " instance, if the start address is 0xca2 and the spacing"
+		 " is 2, then the second address is at 0xca4.  Defaults"
+		 " to 1.");
+module_param_hw_array(regsizes, int, other, &num_regsizes, 0);
+MODULE_PARM_DESC(regsizes, "The size of the specific IPMI register in bytes."
+		 " This should generally be 1, 2, 4, or 8 for an 8-bit,"
+		 " 16-bit, 32-bit, or 64-bit register.  Use this if you"
+		 " the 8-bit IPMI register has to be read from a larger"
+		 " register.");
+module_param_hw_array(regshifts, int, other, &num_regshifts, 0);
+MODULE_PARM_DESC(regshifts, "The amount to shift the data read from the."
+		 " IPMI register, in bits.  For instance, if the data"
+		 " is read from a 32-bit word and the IPMI data is in"
+		 " bit 8-15, then the shift would be 8");
+module_param_hw_array(slave_addrs, int, other, &num_slave_addrs, 0);
+MODULE_PARM_DESC(slave_addrs, "Set the default IPMB slave address for"
+		 " the controller.  Normally this is 0x20, but can be"
+		 " overridden by this parm.  This is an array indexed"
+		 " by interface number.");
+
+int ipmi_si_hardcode_find_bmc(void)
+{
+	int ret = -ENODEV;
+	int             i;
+	struct si_sm_io io;
+	char *str;
+
+	/* Parse out the si_type string into its components. */
+	str = si_type_str;
+	if (*str != '\0') {
+		for (i = 0; (i < SI_MAX_PARMS) && (*str != '\0'); i++) {
+			si_type[i] = str;
+			str = strchr(str, ',');
+			if (str) {
+				*str = '\0';
+				str++;
+			} else {
+				break;
+			}
+		}
+	}
+
+	memset(&io, 0, sizeof(io));
+	for (i = 0; i < SI_MAX_PARMS; i++) {
+		if (!ports[i] && !addrs[i])
+			continue;
+
+		io.addr_source = SI_HARDCODED;
+		pr_info(PFX "probing via hardcoded address\n");
+
+		if (!si_type[i] || strcmp(si_type[i], "kcs") == 0) {
+			io.si_type = SI_KCS;
+		} else if (strcmp(si_type[i], "smic") == 0) {
+			io.si_type = SI_SMIC;
+		} else if (strcmp(si_type[i], "bt") == 0) {
+			io.si_type = SI_BT;
+		} else {
+			pr_warn(PFX "Interface type specified for interface %d, was invalid: %s\n",
+				i, si_type[i]);
+			continue;
+		}
+
+		if (ports[i]) {
+			/* An I/O port */
+			io.addr_data = ports[i];
+			io.addr_type = IPMI_IO_ADDR_SPACE;
+		} else if (addrs[i]) {
+			/* A memory port */
+			io.addr_data = addrs[i];
+			io.addr_type = IPMI_MEM_ADDR_SPACE;
+		} else {
+			pr_warn(PFX "Interface type specified for interface %d, but port and address were not set or set to zero.\n",
+				i);
+			continue;
+		}
+
+		io.addr = NULL;
+		io.regspacing = regspacings[i];
+		if (!io.regspacing)
+			io.regspacing = DEFAULT_REGSPACING;
+		io.regsize = regsizes[i];
+		if (!io.regsize)
+			io.regsize = DEFAULT_REGSIZE;
+		io.regshift = regshifts[i];
+		io.irq = irqs[i];
+		if (io.irq)
+			io.irq_setup = ipmi_std_irq_setup;
+		io.slave_addr = slave_addrs[i];
+
+		ret = ipmi_si_add_smi(&io);
+	}
+	return ret;
+}
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
