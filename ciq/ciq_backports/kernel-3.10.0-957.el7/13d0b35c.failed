ipmi_si: Move PCI setup to another file

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Corey Minyard <cminyard@mvista.com>
commit 13d0b35c5c201e8e6ee520b223c88f58d022a37f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/13d0b35c.failed

	Signed-off-by: Corey Minyard <cminyard@mvista.com>

Stephen Rothwell <sfr@canb.auug.org.au> fixed an issue with the
include files

(cherry picked from commit 13d0b35c5c201e8e6ee520b223c88f58d022a37f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/Makefile
#	drivers/char/ipmi/ipmi_si.h
#	drivers/char/ipmi/ipmi_si_intf.c
diff --cc drivers/char/ipmi/Makefile
index eefb0b301e83,55ec4a3d7d07..000000000000
--- a/drivers/char/ipmi/Makefile
+++ b/drivers/char/ipmi/Makefile
@@@ -2,7 -2,11 +2,15 @@@
  # Makefile for the ipmi drivers.
  #
  
++<<<<<<< HEAD
 +ipmi_si-y := ipmi_si_intf.o ipmi_kcs_sm.o ipmi_smic_sm.o ipmi_bt_sm.o
++=======
+ ipmi_si-y := ipmi_si_intf.o ipmi_kcs_sm.o ipmi_smic_sm.o ipmi_bt_sm.o \
+ 	ipmi_si_hotmod.o ipmi_si_hardcode.o ipmi_si_platform.o
+ ifdef CONFIG_PCI
+ ipmi_si-y += ipmi_si_pci.o
+ endif
++>>>>>>> 13d0b35c5c20 (ipmi_si: Move PCI setup to another file)
  
  obj-$(CONFIG_IPMI_HANDLER) += ipmi_msghandler.o
  obj-$(CONFIG_IPMI_DEVICE_INTERFACE) += ipmi_devintf.o
diff --cc drivers/char/ipmi/ipmi_si.h
index a4d993b1fe66,7627e9ada017..000000000000
--- a/drivers/char/ipmi/ipmi_si.h
+++ b/drivers/char/ipmi/ipmi_si.h
@@@ -13,6 -14,26 +13,30 @@@
  #define DEFAULT_REGSPACING	1
  #define DEFAULT_REGSIZE		1
  
 -#define DEVICE_NAME "ipmi_si"
 +struct smi_info;
  
++<<<<<<< HEAD
 +int ipmi_si_add_smi(struct smi_info *info);
++=======
+ int ipmi_si_add_smi(struct si_sm_io *io);
+ irqreturn_t ipmi_si_irq_handler(int irq, void *data);
+ void ipmi_irq_start_cleanup(struct si_sm_io *io);
+ int ipmi_std_irq_setup(struct si_sm_io *io);
+ void ipmi_irq_finish_setup(struct si_sm_io *io);
+ int ipmi_si_remove_by_dev(struct device *dev);
+ void ipmi_si_remove_by_data(int addr_space, enum si_type si_type,
+ 			    unsigned long addr);
+ int ipmi_si_hardcode_find_bmc(void);
+ void ipmi_si_platform_init(void);
+ void ipmi_si_platform_shutdown(void);
+ 
+ extern struct platform_driver ipmi_platform_driver;
+ 
+ #ifdef CONFIG_PCI
+ void ipmi_si_pci_init(void);
+ void ipmi_si_pci_shutdown(void);
+ #else
+ static inline void ipmi_si_pci_init(void) { }
+ static inline void ipmi_si_pci_shutdown(void) { }
+ #endif
++>>>>>>> 13d0b35c5c20 (ipmi_si: Move PCI setup to another file)
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 72982bfaeaf1,a2be633697e8..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -311,13 -279,9 +310,16 @@@ struct smi_info 
  #define smi_get_stat(smi, stat) \
  	((unsigned int) atomic_read(&(smi)->stats[SI_STAT_ ## stat]))
  
 -#define IPMI_MAX_INTFS 4
 -static int force_kipmid[IPMI_MAX_INTFS];
 +#define SI_MAX_PARMS 4
 +
 +static int force_kipmid[SI_MAX_PARMS];
  static int num_force_kipmid;
++<<<<<<< HEAD
 +#ifdef CONFIG_PCI
 +static int pci_registered;
 +#endif
++=======
++>>>>>>> 13d0b35c5c20 (ipmi_si: Move PCI setup to another file)
  #ifdef CONFIG_PARISC
  static bool parisc_registered;
  #endif
@@@ -1303,104 -1259,8 +1305,109 @@@ static LIST_HEAD(smi_infos)
  static DEFINE_MUTEX(smi_infos_lock);
  static int smi_num; /* Used to sequence the SMIs */
  
++<<<<<<< HEAD
 +#ifdef CONFIG_ACPI
 +static bool          si_tryacpi = true;
 +#endif
 +#ifdef CONFIG_DMI
 +static bool          si_trydmi = true;
 +#endif
 +static bool          si_tryplatform = true;
 +#ifdef CONFIG_PCI
 +static bool          si_trypci = true;
 +#endif
 +static char          *si_type[SI_MAX_PARMS];
 +#define MAX_SI_TYPE_STR 30
 +static char          si_type_str[MAX_SI_TYPE_STR];
 +static unsigned long addrs[SI_MAX_PARMS];
 +static unsigned int num_addrs;
 +static unsigned int  ports[SI_MAX_PARMS];
 +static unsigned int num_ports;
 +static int           irqs[SI_MAX_PARMS];
 +static unsigned int num_irqs;
 +static int           regspacings[SI_MAX_PARMS];
 +static unsigned int num_regspacings;
 +static int           regsizes[SI_MAX_PARMS];
 +static unsigned int num_regsizes;
 +static int           regshifts[SI_MAX_PARMS];
 +static unsigned int num_regshifts;
 +static int slave_addrs[SI_MAX_PARMS]; /* Leaving 0 chooses the default value */
 +static unsigned int num_slave_addrs;
 +
  static const char * const addr_space_to_str[] = { "i/o", "mem" };
  
 +static int hotmod_handler(const char *val, struct kernel_param *kp);
 +
 +module_param_call(hotmod, hotmod_handler, NULL, NULL, 0200);
 +MODULE_PARM_DESC(hotmod, "Add and remove interfaces.  See"
 +		 " Documentation/IPMI.txt in the kernel sources for the"
 +		 " gory details.");
 +
 +#ifdef CONFIG_ACPI
 +module_param_named(tryacpi, si_tryacpi, bool, 0);
 +MODULE_PARM_DESC(tryacpi, "Setting this to zero will disable the"
 +		 " default scan of the interfaces identified via ACPI");
 +#endif
 +#ifdef CONFIG_DMI
 +module_param_named(trydmi, si_trydmi, bool, 0);
 +MODULE_PARM_DESC(trydmi, "Setting this to zero will disable the"
 +		 " default scan of the interfaces identified via DMI");
 +#endif
 +module_param_named(tryplatform, si_tryplatform, bool, 0);
 +MODULE_PARM_DESC(tryplatform, "Setting this to zero will disable the"
 +		 " default scan of the interfaces identified via platform"
 +		 " interfaces like openfirmware");
 +#ifdef CONFIG_PCI
 +module_param_named(trypci, si_trypci, bool, 0);
 +MODULE_PARM_DESC(trypci, "Setting this to zero will disable the"
 +		 " default scan of the interfaces identified via pci");
 +#endif
 +module_param_string(type, si_type_str, MAX_SI_TYPE_STR, 0);
 +MODULE_PARM_DESC(type, "Defines the type of each interface, each"
 +		 " interface separated by commas.  The types are 'kcs',"
 +		 " 'smic', and 'bt'.  For example si_type=kcs,bt will set"
 +		 " the first interface to kcs and the second to bt");
 +module_param_array(addrs, ulong, &num_addrs, 0);
 +MODULE_PARM_DESC(addrs, "Sets the memory address of each interface, the"
 +		 " addresses separated by commas.  Only use if an interface"
 +		 " is in memory.  Otherwise, set it to zero or leave"
 +		 " it blank.");
 +module_param_array(ports, uint, &num_ports, 0);
 +MODULE_PARM_DESC(ports, "Sets the port address of each interface, the"
 +		 " addresses separated by commas.  Only use if an interface"
 +		 " is a port.  Otherwise, set it to zero or leave"
 +		 " it blank.");
 +module_param_array(irqs, int, &num_irqs, 0);
 +MODULE_PARM_DESC(irqs, "Sets the interrupt of each interface, the"
 +		 " addresses separated by commas.  Only use if an interface"
 +		 " has an interrupt.  Otherwise, set it to zero or leave"
 +		 " it blank.");
 +module_param_array(regspacings, int, &num_regspacings, 0);
 +MODULE_PARM_DESC(regspacings, "The number of bytes between the start address"
 +		 " and each successive register used by the interface.  For"
 +		 " instance, if the start address is 0xca2 and the spacing"
 +		 " is 2, then the second address is at 0xca4.  Defaults"
 +		 " to 1.");
 +module_param_array(regsizes, int, &num_regsizes, 0);
 +MODULE_PARM_DESC(regsizes, "The size of the specific IPMI register in bytes."
 +		 " This should generally be 1, 2, 4, or 8 for an 8-bit,"
 +		 " 16-bit, 32-bit, or 64-bit register.  Use this if you"
 +		 " the 8-bit IPMI register has to be read from a larger"
 +		 " register.");
 +module_param_array(regshifts, int, &num_regshifts, 0);
 +MODULE_PARM_DESC(regshifts, "The amount to shift the data read from the."
 +		 " IPMI register, in bits.  For instance, if the data"
 +		 " is read from a 32-bit word and the IPMI data is in"
 +		 " bit 8-15, then the shift would be 8");
 +module_param_array(slave_addrs, int, &num_slave_addrs, 0);
 +MODULE_PARM_DESC(slave_addrs, "Set the default IPMB slave address for"
 +		 " the controller.  Normally this is 0x20, but can be"
 +		 " overridden by this parm.  This is an array indexed"
 +		 " by interface number.");
++=======
++static const char * const addr_space_to_str[] = { "i/o", "mem" };
++
++>>>>>>> 13d0b35c5c20 (ipmi_si: Move PCI setup to another file)
  module_param_array(force_kipmid, int, &num_force_kipmid, 0);
  MODULE_PARM_DESC(force_kipmid, "Force the kipmi daemon to be enabled (1) or"
  		 " disabled(0).  Normally the IPMI driver auto-detects"
@@@ -1790,1224 -1642,138 +1797,1227 @@@ static int check_hotmod_int_op(const ch
  	return 0;
  }
  
 -static int try_get_dev_id(struct smi_info *smi_info)
 +static struct smi_info *smi_info_alloc(void)
  {
 -	unsigned char         msg[2];
 -	unsigned char         *resp;
 -	unsigned long         resp_len;
 -	int                   rv = 0;
 +	struct smi_info *info = kzalloc(sizeof(*info), GFP_KERNEL);
  
 -	resp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);
 -	if (!resp)
 +	if (info)
 +		spin_lock_init(&info->si_lock);
 +	return info;
 +}
 +
++<<<<<<< HEAD
 +static int hotmod_handler(const char *val, struct kernel_param *kp)
 +{
 +	char *str = kstrdup(val, GFP_KERNEL);
 +	int  rv;
 +	char *next, *curr, *s, *n, *o;
 +	enum hotmod_op op;
 +	enum si_type si_type;
 +	int  addr_space;
 +	unsigned long addr;
 +	int regspacing;
 +	int regsize;
 +	int regshift;
 +	int irq;
 +	int ipmb;
 +	int ival;
 +	int len;
 +	struct smi_info *info;
 +
 +	if (!str)
  		return -ENOMEM;
  
 -	/*
 -	 * Do a Get Device ID command, since it comes back with some
 -	 * useful info.
 -	 */
 -	msg[0] = IPMI_NETFN_APP_REQUEST << 2;
 -	msg[1] = IPMI_GET_DEVICE_ID_CMD;
 -	smi_info->handlers->start_transaction(smi_info->si_sm, msg, 2);
 +	/* Kill any trailing spaces, as we can get a "\n" from echo. */
 +	len = strlen(str);
 +	ival = len - 1;
 +	while ((ival >= 0) && isspace(str[ival])) {
 +		str[ival] = '\0';
 +		ival--;
 +	}
 +
 +	for (curr = str; curr; curr = next) {
 +		regspacing = 1;
 +		regsize = 1;
 +		regshift = 0;
 +		irq = 0;
 +		ipmb = 0; /* Choose the default if not specified */
 +
 +		next = strchr(curr, ':');
 +		if (next) {
 +			*next = '\0';
 +			next++;
 +		}
  
 -	rv = wait_for_msg_done(smi_info);
 -	if (rv)
 -		goto out;
 +		rv = parse_str(hotmod_ops, &ival, "operation", &curr);
 +		if (rv)
 +			break;
 +		op = ival;
  
 -	resp_len = smi_info->handlers->get_result(smi_info->si_sm,
 -						  resp, IPMI_MAX_MSG_LENGTH);
 +		rv = parse_str(hotmod_si, &ival, "interface type", &curr);
 +		if (rv)
 +			break;
 +		si_type = ival;
  
 -	/* Check and record info from the get device id, in case we need it. */
 -	rv = ipmi_demangle_device_id(resp[0] >> 2, resp[1],
 -			resp + 2, resp_len - 2, &smi_info->device_id);
 +		rv = parse_str(hotmod_as, &addr_space, "address space", &curr);
 +		if (rv)
 +			break;
 +
 +		s = strchr(curr, ',');
 +		if (s) {
 +			*s = '\0';
 +			s++;
 +		}
 +		addr = simple_strtoul(curr, &n, 0);
 +		if ((*n != '\0') || (*curr == '\0')) {
 +			pr_warn(PFX "Invalid hotmod address '%s'\n", curr);
 +			break;
 +		}
  
 +		while (s) {
 +			curr = s;
 +			s = strchr(curr, ',');
 +			if (s) {
 +				*s = '\0';
 +				s++;
 +			}
 +			o = strchr(curr, '=');
 +			if (o) {
 +				*o = '\0';
 +				o++;
 +			}
 +			rv = check_hotmod_int_op(curr, o, "rsp", &regspacing);
 +			if (rv < 0)
 +				goto out;
 +			else if (rv)
 +				continue;
 +			rv = check_hotmod_int_op(curr, o, "rsi", &regsize);
 +			if (rv < 0)
 +				goto out;
 +			else if (rv)
 +				continue;
 +			rv = check_hotmod_int_op(curr, o, "rsh", &regshift);
 +			if (rv < 0)
 +				goto out;
 +			else if (rv)
 +				continue;
 +			rv = check_hotmod_int_op(curr, o, "irq", &irq);
 +			if (rv < 0)
 +				goto out;
 +			else if (rv)
 +				continue;
 +			rv = check_hotmod_int_op(curr, o, "ipmb", &ipmb);
 +			if (rv < 0)
 +				goto out;
 +			else if (rv)
 +				continue;
 +
 +			rv = -EINVAL;
 +			pr_warn(PFX "Invalid hotmod option '%s'\n", curr);
 +			goto out;
 +		}
 +
 +		if (op == HM_ADD) {
 +			info = smi_info_alloc();
 +			if (!info) {
 +				rv = -ENOMEM;
 +				goto out;
 +			}
 +
 +			info->addr_source = SI_HOTMOD;
 +			info->si_type = si_type;
 +			info->io.addr_data = addr;
 +			info->io.addr_type = addr_space;
 +			if (addr_space == IPMI_MEM_ADDR_SPACE)
 +				info->io_setup = mem_setup;
 +			else
 +				info->io_setup = port_setup;
 +
 +			info->io.addr = NULL;
 +			info->io.regspacing = regspacing;
 +			if (!info->io.regspacing)
 +				info->io.regspacing = DEFAULT_REGSPACING;
 +			info->io.regsize = regsize;
 +			if (!info->io.regsize)
 +				info->io.regsize = DEFAULT_REGSIZE;
 +			info->io.regshift = regshift;
 +			info->irq = irq;
 +			if (info->irq)
 +				info->irq_setup = std_irq_setup;
 +			info->slave_addr = ipmb;
 +
 +			rv = ipmi_si_add_smi(info);
 +			if (rv) {
 +				kfree(info);
 +				goto out;
 +			}
 +			mutex_lock(&smi_infos_lock);
 +			rv = try_smi_init(info);
 +			mutex_unlock(&smi_infos_lock);
 +			if (rv) {
 +				cleanup_one_si(info);
 +				goto out;
 +			}
 +		} else {
 +			/* remove */
 +			struct smi_info *e, *tmp_e;
 +
 +			mutex_lock(&smi_infos_lock);
 +			list_for_each_entry_safe(e, tmp_e, &smi_infos, link) {
 +				if (e->io.addr_type != addr_space)
 +					continue;
 +				if (e->si_type != si_type)
 +					continue;
 +				if (e->io.addr_data == addr)
 +					cleanup_one_si(e);
 +			}
 +			mutex_unlock(&smi_infos_lock);
 +		}
 +	}
 +	rv = len;
  out:
 -	kfree(resp);
 +	kfree(str);
  	return rv;
  }
  
 -static int get_global_enables(struct smi_info *smi_info, u8 *enables)
 +static int hardcode_find_bmc(void)
  {
 -	unsigned char         msg[3];
 -	unsigned char         *resp;
 -	unsigned long         resp_len;
 -	int                   rv;
 +	int ret = -ENODEV;
 +	int             i;
 +	struct smi_info *info;
  
 -	resp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);
 -	if (!resp)
 -		return -ENOMEM;
 +	for (i = 0; i < SI_MAX_PARMS; i++) {
 +		if (!ports[i] && !addrs[i])
 +			continue;
  
 -	msg[0] = IPMI_NETFN_APP_REQUEST << 2;
 -	msg[1] = IPMI_GET_BMC_GLOBAL_ENABLES_CMD;
 -	smi_info->handlers->start_transaction(smi_info->si_sm, msg, 2);
 +		info = smi_info_alloc();
 +		if (!info)
 +			return -ENOMEM;
  
 -	rv = wait_for_msg_done(smi_info);
 -	if (rv) {
 -		dev_warn(smi_info->io.dev,
 -			 "Error getting response from get global enables command: %d\n",
 -			 rv);
 -		goto out;
 -	}
 +		info->addr_source = SI_HARDCODED;
 +		pr_info(PFX "probing via hardcoded address\n");
  
 -	resp_len = smi_info->handlers->get_result(smi_info->si_sm,
 -						  resp, IPMI_MAX_MSG_LENGTH);
 +		if (!si_type[i] || strcmp(si_type[i], "kcs") == 0) {
 +			info->si_type = SI_KCS;
 +		} else if (strcmp(si_type[i], "smic") == 0) {
 +			info->si_type = SI_SMIC;
 +		} else if (strcmp(si_type[i], "bt") == 0) {
 +			info->si_type = SI_BT;
 +		} else {
 +			pr_warn(PFX "Interface type specified for interface %d, was invalid: %s\n",
 +				i, si_type[i]);
 +			kfree(info);
 +			continue;
 +		}
  
 -	if (resp_len < 4 ||
 -			resp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2 ||
 -			resp[1] != IPMI_GET_BMC_GLOBAL_ENABLES_CMD   ||
 -			resp[2] != 0) {
 -		dev_warn(smi_info->io.dev,
 -			 "Invalid return from get global enables command: %ld %x %x %x\n",
 -			 resp_len, resp[0], resp[1], resp[2]);
 -		rv = -EINVAL;
 -		goto out;
 -	} else {
 -		*enables = resp[3];
 -	}
 +		if (ports[i]) {
 +			/* An I/O port */
 +			info->io_setup = port_setup;
 +			info->io.addr_data = ports[i];
 +			info->io.addr_type = IPMI_IO_ADDR_SPACE;
 +		} else if (addrs[i]) {
 +			/* A memory port */
 +			info->io_setup = mem_setup;
 +			info->io.addr_data = addrs[i];
 +			info->io.addr_type = IPMI_MEM_ADDR_SPACE;
 +		} else {
 +			pr_warn(PFX "Interface type specified for interface %d, but port and address were not set or set to zero.\n",
 +				i);
 +			kfree(info);
 +			continue;
 +		}
  
 -out:
 -	kfree(resp);
 -	return rv;
 +		info->io.addr = NULL;
 +		info->io.regspacing = regspacings[i];
 +		if (!info->io.regspacing)
 +			info->io.regspacing = DEFAULT_REGSPACING;
 +		info->io.regsize = regsizes[i];
 +		if (!info->io.regsize)
 +			info->io.regsize = DEFAULT_REGSIZE;
 +		info->io.regshift = regshifts[i];
 +		info->irq = irqs[i];
 +		if (info->irq)
 +			info->irq_setup = std_irq_setup;
 +		info->slave_addr = slave_addrs[i];
 +
 +		if (!ipmi_si_add_smi(info)) {
 +			mutex_lock(&smi_infos_lock);
 +			if (try_smi_init(info))
 +				cleanup_one_si(info);
 +			mutex_unlock(&smi_infos_lock);
 +			ret = 0;
 +		} else {
 +			kfree(info);
 +		}
 +	}
 +	return ret;
  }
  
 +#ifdef CONFIG_ACPI
 +
  /*
 - * Returns 1 if it gets an error from the command.
 + * Once we get an ACPI failure, we don't try any more, because we go
 + * through the tables sequentially.  Once we don't find a table, there
 + * are no more.
   */
 -static int set_global_enables(struct smi_info *smi_info, u8 enables)
 -{
 -	unsigned char         msg[3];
 -	unsigned char         *resp;
 -	unsigned long         resp_len;
 -	int                   rv;
 -
 -	resp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);
 -	if (!resp)
 -		return -ENOMEM;
 +static int acpi_failure;
  
 -	msg[0] = IPMI_NETFN_APP_REQUEST << 2;
 -	msg[1] = IPMI_SET_BMC_GLOBAL_ENABLES_CMD;
 -	msg[2] = enables;
 -	smi_info->handlers->start_transaction(smi_info->si_sm, msg, 3);
 +/* For GPE-type interrupts. */
 +static u32 ipmi_acpi_gpe(acpi_handle gpe_device,
 +	u32 gpe_number, void *context)
 +{
 +	struct smi_info *smi_info = context;
 +	unsigned long   flags;
  
 -	rv = wait_for_msg_done(smi_info);
 -	if (rv) {
 -		dev_warn(smi_info->io.dev,
 -			 "Error getting response from set global enables command: %d\n",
 -			 rv);
 -		goto out;
 -	}
 +	spin_lock_irqsave(&(smi_info->si_lock), flags);
  
 -	resp_len = smi_info->handlers->get_result(smi_info->si_sm,
 -						  resp, IPMI_MAX_MSG_LENGTH);
 +	smi_inc_stat(smi_info, interrupts);
  
 -	if (resp_len < 3 ||
 -			resp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2 ||
 -			resp[1] != IPMI_SET_BMC_GLOBAL_ENABLES_CMD) {
 -		dev_warn(smi_info->io.dev,
 -			 "Invalid return from set global enables command: %ld %x %x\n",
 -			 resp_len, resp[0], resp[1]);
 -		rv = -EINVAL;
 -		goto out;
 -	}
 +	debug_timestamp("ACPI_GPE");
  
 -	if (resp[2] != 0)
 -		rv = 1;
 +	smi_event_handler(smi_info, 0);
 +	spin_unlock_irqrestore(&(smi_info->si_lock), flags);
  
 -out:
 -	kfree(resp);
 -	return rv;
 +	return ACPI_INTERRUPT_HANDLED;
 +}
 +
 +static void acpi_gpe_irq_cleanup(struct smi_info *info)
 +{
 +	if (!info->irq)
 +		return;
 +
 +	acpi_remove_gpe_handler(NULL, info->irq, &ipmi_acpi_gpe);
 +}
 +
 +static int acpi_gpe_irq_setup(struct smi_info *info)
 +{
 +	acpi_status status;
 +
 +	if (!info->irq)
 +		return 0;
 +
 +	status = acpi_install_gpe_handler(NULL,
 +					  info->irq,
 +					  ACPI_GPE_LEVEL_TRIGGERED,
 +					  &ipmi_acpi_gpe,
 +					  info);
 +	if (status != AE_OK) {
 +		dev_warn(info->dev, "%s unable to claim ACPI GPE %d,"
 +			 " running polled\n", DEVICE_NAME, info->irq);
 +		info->irq = 0;
 +		return -EINVAL;
 +	} else {
 +		info->irq_cleanup = acpi_gpe_irq_cleanup;
 +		dev_info(info->dev, "Using ACPI GPE %d\n", info->irq);
 +		return 0;
 +	}
 +}
 +
 +/*
 + * Defined at
 + * http://h21007.www2.hp.com/portal/download/files/unprot/hpspmi.pdf
 + */
 +struct SPMITable {
 +	s8	Signature[4];
 +	u32	Length;
 +	u8	Revision;
 +	u8	Checksum;
 +	s8	OEMID[6];
 +	s8	OEMTableID[8];
 +	s8	OEMRevision[4];
 +	s8	CreatorID[4];
 +	s8	CreatorRevision[4];
 +	u8	InterfaceType;
 +	u8	IPMIlegacy;
 +	s16	SpecificationRevision;
 +
 +	/*
 +	 * Bit 0 - SCI interrupt supported
 +	 * Bit 1 - I/O APIC/SAPIC
 +	 */
 +	u8	InterruptType;
 +
 +	/*
 +	 * If bit 0 of InterruptType is set, then this is the SCI
 +	 * interrupt in the GPEx_STS register.
 +	 */
 +	u8	GPE;
 +
 +	s16	Reserved;
 +
 +	/*
 +	 * If bit 1 of InterruptType is set, then this is the I/O
 +	 * APIC/SAPIC interrupt.
 +	 */
 +	u32	GlobalSystemInterrupt;
 +
 +	/* The actual register address. */
 +	struct acpi_generic_address addr;
 +
 +	u8	UID[4];
 +
 +	s8      spmi_id[1]; /* A '\0' terminated array starts here. */
 +};
 +
 +static int try_init_spmi(struct SPMITable *spmi)
 +{
 +	struct smi_info  *info;
 +	int rv;
 +
 +	if (spmi->IPMIlegacy != 1) {
 +		pr_info(PFX "Bad SPMI legacy %d\n", spmi->IPMIlegacy);
 +		return -ENODEV;
 +	}
 +
 +	info = smi_info_alloc();
 +	if (!info) {
 +		pr_err(PFX "Could not allocate SI data (3)\n");
 +		return -ENOMEM;
 +	}
 +
 +	info->addr_source = SI_SPMI;
 +	pr_info(PFX "probing via SPMI\n");
 +
 +	/* Figure out the interface type. */
 +	switch (spmi->InterfaceType) {
 +	case 1:	/* KCS */
 +		info->si_type = SI_KCS;
 +		break;
 +	case 2:	/* SMIC */
 +		info->si_type = SI_SMIC;
 +		break;
 +	case 3:	/* BT */
 +		info->si_type = SI_BT;
 +		break;
 +	case 4: /* SSIF, just ignore */
 +		kfree(info);
 +		return -EIO;
 +	default:
 +		pr_info(PFX "Unknown ACPI/SPMI SI type %d\n",
 +			spmi->InterfaceType);
 +		kfree(info);
 +		return -EIO;
 +	}
 +
 +	if (spmi->InterruptType & 1) {
 +		/* We've got a GPE interrupt. */
 +		info->irq = spmi->GPE;
 +		info->irq_setup = acpi_gpe_irq_setup;
 +	} else if (spmi->InterruptType & 2) {
 +		/* We've got an APIC/SAPIC interrupt. */
 +		info->irq = spmi->GlobalSystemInterrupt;
 +		info->irq_setup = std_irq_setup;
 +	} else {
 +		/* Use the default interrupt setting. */
 +		info->irq = 0;
 +		info->irq_setup = NULL;
 +	}
 +
 +	if (spmi->addr.bit_width) {
 +		/* A (hopefully) properly formed register bit width. */
 +		info->io.regspacing = spmi->addr.bit_width / 8;
 +	} else {
 +		info->io.regspacing = DEFAULT_REGSPACING;
 +	}
 +	info->io.regsize = info->io.regspacing;
 +	info->io.regshift = spmi->addr.bit_offset;
 +
 +	if (spmi->addr.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {
 +		info->io_setup = mem_setup;
 +		info->io.addr_type = IPMI_MEM_ADDR_SPACE;
 +	} else if (spmi->addr.space_id == ACPI_ADR_SPACE_SYSTEM_IO) {
 +		info->io_setup = port_setup;
 +		info->io.addr_type = IPMI_IO_ADDR_SPACE;
 +	} else {
 +		kfree(info);
 +		pr_warn(PFX "Unknown ACPI I/O Address type\n");
 +		return -EIO;
 +	}
 +	info->io.addr_data = spmi->addr.address;
 +
 +	pr_info("ipmi_si: SPMI: %s %#lx regsize %d spacing %d irq %d\n",
 +		(info->io.addr_type == IPMI_IO_ADDR_SPACE) ? "io" : "mem",
 +		info->io.addr_data, info->io.regsize, info->io.regspacing,
 +		info->irq);
 +
 +	rv = ipmi_si_add_smi(info);
 +	if (rv)
 +		kfree(info);
 +
 +	return rv;
 +}
 +
 +static void spmi_find_bmc(void)
 +{
 +	acpi_status      status;
 +	struct SPMITable *spmi;
 +	int              i;
 +
 +	if (acpi_disabled)
 +		return;
 +
 +	if (acpi_failure)
 +		return;
 +
 +	for (i = 0; ; i++) {
 +		status = acpi_get_table(ACPI_SIG_SPMI, i+1,
 +					(struct acpi_table_header **)&spmi);
 +		if (status != AE_OK)
 +			return;
 +
 +		try_init_spmi(spmi);
 +	}
 +}
 +#endif
 +
 +#if defined(CONFIG_DMI) || defined(CONFIG_ACPI)
 +struct resource *ipmi_get_info_from_resources(struct platform_device *pdev,
 +					      struct smi_info *info)
 +{
 +	struct resource *res, *res_second;
 +
 +	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
 +	if (res) {
 +		info->io_setup = port_setup;
 +		info->io.addr_type = IPMI_IO_ADDR_SPACE;
 +	} else {
 +		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 +		if (res) {
 +			info->io_setup = mem_setup;
 +			info->io.addr_type = IPMI_MEM_ADDR_SPACE;
 +		}
 +	}
 +	if (!res) {
 +		dev_err(&pdev->dev, "no I/O or memory address\n");
 +		return NULL;
 +	}
 +	info->io.addr_data = res->start;
 +
 +	info->io.regspacing = DEFAULT_REGSPACING;
 +	res_second = platform_get_resource(pdev,
 +			       (info->io.addr_type == IPMI_IO_ADDR_SPACE) ?
 +					IORESOURCE_IO : IORESOURCE_MEM,
 +			       1);
 +	if (res_second) {
 +		if (res_second->start > info->io.addr_data)
 +			info->io.regspacing =
 +				res_second->start - info->io.addr_data;
 +	}
 +	info->io.regsize = DEFAULT_REGSIZE;
 +	info->io.regshift = 0;
 +
 +	return res;
 +}
 +
 +#endif
 +
 +#ifdef CONFIG_DMI
 +static int dmi_ipmi_probe(struct platform_device *pdev)
 +{
 +	struct smi_info *info;
 +	u8 type, slave_addr;
 +	int rv;
 +
 +	if (!si_trydmi)
 +		return -ENODEV;
 +
 +	rv = device_property_read_u8(&pdev->dev, "ipmi-type", &type);
 +	if (rv)
 +		return -ENODEV;
 +
 +	info = smi_info_alloc();
 +	if (!info) {
 +		pr_err(PFX "Could not allocate SI data\n");
 +		return -ENOMEM;
 +	}
 +
 +	info->addr_source = SI_SMBIOS;
 +	pr_info(PFX "probing via SMBIOS\n");
 +
 +	switch (type) {
 +	case IPMI_DMI_TYPE_KCS:
 +		info->si_type = SI_KCS;
 +		break;
 +	case IPMI_DMI_TYPE_SMIC:
 +		info->si_type = SI_SMIC;
 +		break;
 +	case IPMI_DMI_TYPE_BT:
 +		info->si_type = SI_BT;
 +		break;
 +	default:
 +		kfree(info);
 +		return -EINVAL;
 +	}
 +
 +	if (!ipmi_get_info_from_resources(pdev, info)) {
 +		rv = -EINVAL;
 +		goto err_free;
 +	}
 +
 +	rv = device_property_read_u8(&pdev->dev, "slave-addr", &slave_addr);
 +	if (rv) {
 +		dev_warn(&pdev->dev, "device has no slave-addr property");
 +		info->slave_addr = 0x20;
 +	} else {
 +		info->slave_addr = slave_addr;
 +	}
 +
 +	info->irq = platform_get_irq(pdev, 0);
 +	if (info->irq > 0)
 +		info->irq_setup = std_irq_setup;
 +	else
 +		info->irq = 0;
 +
 +	info->dev = &pdev->dev;
 +
 +	pr_info("ipmi_si: SMBIOS: %s %#lx regsize %d spacing %d irq %d\n",
 +		(info->io.addr_type == IPMI_IO_ADDR_SPACE) ? "io" : "mem",
 +		info->io.addr_data, info->io.regsize, info->io.regspacing,
 +		info->irq);
 +
 +	if (ipmi_si_add_smi(info))
 +		kfree(info);
 +
 +	return 0;
 +
 +err_free:
 +	kfree(info);
 +	return rv;
 +}
 +#else
 +static int dmi_ipmi_probe(struct platform_device *pdev)
 +{
 +	return -ENODEV;
 +}
 +#endif /* CONFIG_DMI */
 +
 +#ifdef CONFIG_PCI
 +
 +#define PCI_ERMC_CLASSCODE		0x0C0700
 +#define PCI_ERMC_CLASSCODE_MASK		0xffffff00
 +#define PCI_ERMC_CLASSCODE_TYPE_MASK	0xff
 +#define PCI_ERMC_CLASSCODE_TYPE_SMIC	0x00
 +#define PCI_ERMC_CLASSCODE_TYPE_KCS	0x01
 +#define PCI_ERMC_CLASSCODE_TYPE_BT	0x02
 +
 +#define PCI_HP_VENDOR_ID    0x103C
 +#define PCI_MMC_DEVICE_ID   0x121A
 +#define PCI_MMC_ADDR_CW     0x10
 +
 +static void ipmi_pci_cleanup(struct smi_info *info)
 +{
 +	struct pci_dev *pdev = info->addr_source_data;
 +
 +	pci_disable_device(pdev);
 +}
 +
 +static int ipmi_pci_probe_regspacing(struct smi_info *info)
 +{
 +	if (info->si_type == SI_KCS) {
 +		unsigned char	status;
 +		int		regspacing;
 +
 +		info->io.regsize = DEFAULT_REGSIZE;
 +		info->io.regshift = 0;
 +		info->io_size = 2;
 +		info->handlers = &kcs_smi_handlers;
 +
 +		/* detect 1, 4, 16byte spacing */
 +		for (regspacing = DEFAULT_REGSPACING; regspacing <= 16;) {
 +			info->io.regspacing = regspacing;
 +			if (info->io_setup(info)) {
 +				dev_err(info->dev,
 +					"Could not setup I/O space\n");
 +				return DEFAULT_REGSPACING;
 +			}
 +			/* write invalid cmd */
 +			info->io.outputb(&info->io, 1, 0x10);
 +			/* read status back */
 +			status = info->io.inputb(&info->io, 1);
 +			info->io_cleanup(info);
 +			if (status)
 +				return regspacing;
 +			regspacing *= 4;
 +		}
 +	}
 +	return DEFAULT_REGSPACING;
 +}
 +
 +static int ipmi_pci_probe(struct pci_dev *pdev,
 +				    const struct pci_device_id *ent)
 +{
 +	int rv;
 +	int class_type = pdev->class & PCI_ERMC_CLASSCODE_TYPE_MASK;
 +	struct smi_info *info;
 +
 +	info = smi_info_alloc();
 +	if (!info)
 +		return -ENOMEM;
 +
 +	info->addr_source = SI_PCI;
 +	dev_info(&pdev->dev, "probing via PCI");
 +
 +	switch (class_type) {
 +	case PCI_ERMC_CLASSCODE_TYPE_SMIC:
 +		info->si_type = SI_SMIC;
 +		break;
 +
 +	case PCI_ERMC_CLASSCODE_TYPE_KCS:
 +		info->si_type = SI_KCS;
 +		break;
 +
 +	case PCI_ERMC_CLASSCODE_TYPE_BT:
 +		info->si_type = SI_BT;
 +		break;
 +
 +	default:
 +		kfree(info);
 +		dev_info(&pdev->dev, "Unknown IPMI type: %d\n", class_type);
 +		return -ENOMEM;
 +	}
 +
 +	rv = pci_enable_device(pdev);
 +	if (rv) {
 +		dev_err(&pdev->dev, "couldn't enable PCI device\n");
 +		kfree(info);
 +		return rv;
 +	}
 +
 +	info->addr_source_cleanup = ipmi_pci_cleanup;
 +	info->addr_source_data = pdev;
 +
 +	if (pci_resource_flags(pdev, 0) & IORESOURCE_IO) {
 +		info->io_setup = port_setup;
 +		info->io.addr_type = IPMI_IO_ADDR_SPACE;
 +	} else {
 +		info->io_setup = mem_setup;
 +		info->io.addr_type = IPMI_MEM_ADDR_SPACE;
 +	}
 +	info->io.addr_data = pci_resource_start(pdev, 0);
 +
 +	info->io.regspacing = ipmi_pci_probe_regspacing(info);
 +	info->io.regsize = DEFAULT_REGSIZE;
 +	info->io.regshift = 0;
 +
 +	info->irq = pdev->irq;
 +	if (info->irq)
 +		info->irq_setup = std_irq_setup;
 +
 +	info->dev = &pdev->dev;
 +	pci_set_drvdata(pdev, info);
 +
 +	dev_info(&pdev->dev, "%pR regsize %d spacing %d irq %d\n",
 +		&pdev->resource[0], info->io.regsize, info->io.regspacing,
 +		info->irq);
 +
 +	rv = ipmi_si_add_smi(info);
 +	if (rv) {
 +		kfree(info);
 +		pci_disable_device(pdev);
 +	}
 +
 +	return rv;
 +}
 +
 +static void ipmi_pci_remove(struct pci_dev *pdev)
 +{
 +	struct smi_info *info = pci_get_drvdata(pdev);
 +	cleanup_one_si(info);
 +}
 +
 +static const struct pci_device_id ipmi_pci_devices[] = {
 +	{ PCI_DEVICE(PCI_HP_VENDOR_ID, PCI_MMC_DEVICE_ID) },
 +	{ PCI_DEVICE_CLASS(PCI_ERMC_CLASSCODE, PCI_ERMC_CLASSCODE_MASK) },
 +	{ 0, }
 +};
 +MODULE_DEVICE_TABLE(pci, ipmi_pci_devices);
 +
 +static struct pci_driver ipmi_pci_driver = {
 +	.name =         DEVICE_NAME,
 +	.id_table =     ipmi_pci_devices,
 +	.probe =        ipmi_pci_probe,
 +	.remove =       ipmi_pci_remove,
 +};
 +#endif /* CONFIG_PCI */
 +
 +#ifdef CONFIG_OF
 +static const struct of_device_id of_ipmi_match[] = {
 +	{ .type = "ipmi", .compatible = "ipmi-kcs",
 +	  .data = (void *)(unsigned long) SI_KCS },
 +	{ .type = "ipmi", .compatible = "ipmi-smic",
 +	  .data = (void *)(unsigned long) SI_SMIC },
 +	{ .type = "ipmi", .compatible = "ipmi-bt",
 +	  .data = (void *)(unsigned long) SI_BT },
 +	{},
 +};
 +
 +static int of_ipmi_probe(struct platform_device *dev)
 +{
 +	const struct of_device_id *match;
 +	struct smi_info *info;
 +	struct resource resource;
 +	const __be32 *regsize, *regspacing, *regshift;
 +	struct device_node *np = dev->dev.of_node;
 +	int ret;
 +	int proplen;
 +
 +	dev_info(&dev->dev, "probing via device tree\n");
 +
 +	match = of_match_device(of_ipmi_match, &dev->dev);
 +	if (!match)
 +		return -ENODEV;
 +
 +	if (!of_device_is_available(np))
 +		return -EINVAL;
 +
 +	ret = of_address_to_resource(np, 0, &resource);
 +	if (ret) {
 +		dev_warn(&dev->dev, PFX "invalid address from OF\n");
 +		return ret;
 +	}
 +
 +	regsize = of_get_property(np, "reg-size", &proplen);
 +	if (regsize && proplen != 4) {
 +		dev_warn(&dev->dev, PFX "invalid regsize from OF\n");
 +		return -EINVAL;
 +	}
 +
 +	regspacing = of_get_property(np, "reg-spacing", &proplen);
 +	if (regspacing && proplen != 4) {
 +		dev_warn(&dev->dev, PFX "invalid regspacing from OF\n");
 +		return -EINVAL;
 +	}
 +
 +	regshift = of_get_property(np, "reg-shift", &proplen);
 +	if (regshift && proplen != 4) {
 +		dev_warn(&dev->dev, PFX "invalid regshift from OF\n");
 +		return -EINVAL;
 +	}
 +
 +	info = smi_info_alloc();
 +
 +	if (!info) {
 +		dev_err(&dev->dev,
 +			"could not allocate memory for OF probe\n");
 +		return -ENOMEM;
 +	}
 +
 +	info->si_type		= (enum si_type) match->data;
 +	info->addr_source	= SI_DEVICETREE;
 +	info->irq_setup		= std_irq_setup;
 +
 +	if (resource.flags & IORESOURCE_IO) {
 +		info->io_setup		= port_setup;
 +		info->io.addr_type	= IPMI_IO_ADDR_SPACE;
 +	} else {
 +		info->io_setup		= mem_setup;
 +		info->io.addr_type	= IPMI_MEM_ADDR_SPACE;
 +	}
 +
 +	info->io.addr_data	= resource.start;
 +
 +	info->io.regsize	= regsize ? be32_to_cpup(regsize) : DEFAULT_REGSIZE;
 +	info->io.regspacing	= regspacing ? be32_to_cpup(regspacing) : DEFAULT_REGSPACING;
 +	info->io.regshift	= regshift ? be32_to_cpup(regshift) : 0;
 +
 +	info->irq		= irq_of_parse_and_map(dev->dev.of_node, 0);
 +	info->dev		= &dev->dev;
 +
 +	dev_dbg(&dev->dev, "addr 0x%lx regsize %d spacing %d irq %d\n",
 +		info->io.addr_data, info->io.regsize, info->io.regspacing,
 +		info->irq);
 +
 +	dev_set_drvdata(&dev->dev, info);
 +
 +	ret = ipmi_si_add_smi(info);
 +	if (ret) {
 +		kfree(info);
 +		return ret;
 +	}
 +	return 0;
 +}
 +#else
 +#define of_ipmi_match NULL
 +static int of_ipmi_probe(struct platform_device *dev)
 +{
 +	return -ENODEV;
 +}
 +#endif
 +
 +#ifdef CONFIG_ACPI
 +static int find_slave_address(struct smi_info *info, int slave_addr)
 +{
 +#ifdef CONFIG_IPMI_DMI_DECODE
 +	if (!slave_addr) {
 +		int type = -1;
 +		u32 flags = IORESOURCE_IO;
 +
 +		switch (info->si_type) {
 +		case SI_KCS:
 +			type = IPMI_DMI_TYPE_KCS;
 +			break;
 +		case SI_BT:
 +			type = IPMI_DMI_TYPE_BT;
 +			break;
 +		case SI_SMIC:
 +			type = IPMI_DMI_TYPE_SMIC;
 +			break;
 +		}
 +
 +		if (info->io.addr_type == IPMI_MEM_ADDR_SPACE)
 +			flags = IORESOURCE_MEM;
 +
 +		slave_addr = ipmi_dmi_get_slave_addr(type, flags,
 +						     info->io.addr_data);
 +	}
 +#endif
 +
 +	return slave_addr;
 +}
 +
 +static int acpi_ipmi_probe(struct platform_device *dev)
 +{
 +	struct smi_info *info;
 +	acpi_handle handle;
 +	acpi_status status;
 +	unsigned long long tmp;
 +	struct resource *res;
 +	int rv = -EINVAL;
 +
 +	if (!si_tryacpi)
 +		return -ENODEV;
 +
 +	handle = ACPI_HANDLE(&dev->dev);
 +	if (!handle)
 +		return -ENODEV;
 +
 +	info = smi_info_alloc();
 +	if (!info)
 +		return -ENOMEM;
 +
 +	info->addr_source = SI_ACPI;
 +	dev_info(&dev->dev, PFX "probing via ACPI\n");
 +
 +	info->addr_info.acpi_info.acpi_handle = handle;
 +
 +	/* _IFT tells us the interface type: KCS, BT, etc */
 +	status = acpi_evaluate_integer(handle, "_IFT", NULL, &tmp);
 +	if (ACPI_FAILURE(status)) {
 +		dev_err(&dev->dev, "Could not find ACPI IPMI interface type\n");
 +		goto err_free;
 +	}
 +
 +	switch (tmp) {
 +	case 1:
 +		info->si_type = SI_KCS;
 +		break;
 +	case 2:
 +		info->si_type = SI_SMIC;
 +		break;
 +	case 3:
 +		info->si_type = SI_BT;
 +		break;
 +	case 4: /* SSIF, just ignore */
 +		rv = -ENODEV;
 +		goto err_free;
 +	default:
 +		dev_info(&dev->dev, "unknown IPMI type %lld\n", tmp);
 +		goto err_free;
 +	}
 +
 +	res = ipmi_get_info_from_resources(dev, info);
 +	if (!res) {
 +		rv = -EINVAL;
 +		goto err_free;
 +	}
 +
 +	/* If _GPE exists, use it; otherwise use standard interrupts */
 +	status = acpi_evaluate_integer(handle, "_GPE", NULL, &tmp);
 +	if (ACPI_SUCCESS(status)) {
 +		info->irq = tmp;
 +		info->irq_setup = acpi_gpe_irq_setup;
 +	} else {
 +		int irq = platform_get_irq(dev, 0);
 +
 +		if (irq > 0) {
 +			info->irq = irq;
 +			info->irq_setup = std_irq_setup;
 +		}
 +	}
 +
 +	info->slave_addr = find_slave_address(info, info->slave_addr);
 +
 +	info->dev = &dev->dev;
 +	platform_set_drvdata(dev, info);
 +
 +	dev_info(info->dev, "%pR regsize %d spacing %d irq %d\n",
 +		 res, info->io.regsize, info->io.regspacing,
 +		 info->irq);
 +
 +	rv = ipmi_si_add_smi(info);
 +	if (rv)
 +		kfree(info);
 +
 +	return rv;
 +
 +err_free:
 +	kfree(info);
 +	return rv;
 +}
 +
 +static const struct acpi_device_id acpi_ipmi_match[] = {
 +	{ "IPI0001", 0 },
 +	{ },
 +};
 +MODULE_DEVICE_TABLE(acpi, acpi_ipmi_match);
 +#else
 +static int acpi_ipmi_probe(struct platform_device *dev)
 +{
 +	return -ENODEV;
 +}
 +#endif
 +
 +static int ipmi_probe(struct platform_device *dev)
 +{
 +	if (dev->dev.of_node && of_ipmi_probe(dev) == 0)
 +		return 0;
 +
 +	if (acpi_ipmi_probe(dev) == 0)
 +		return 0;
 +
 +	return dmi_ipmi_probe(dev);
 +}
 +
 +static int ipmi_remove(struct platform_device *dev)
 +{
 +	struct smi_info *info = dev_get_drvdata(&dev->dev);
 +
 +	cleanup_one_si(info);
 +	return 0;
 +}
 +
 +static struct platform_driver ipmi_driver = {
 +	.driver = {
 +		.name = DEVICE_NAME,
 +		.of_match_table = of_ipmi_match,
 +		.acpi_match_table = ACPI_PTR(acpi_ipmi_match),
 +	},
 +	.probe		= ipmi_probe,
 +	.remove		= ipmi_remove,
 +};
 +
++=======
++>>>>>>> 13d0b35c5c20 (ipmi_si: Move PCI setup to another file)
 +#ifdef CONFIG_PARISC
 +static int ipmi_parisc_probe(struct parisc_device *dev)
 +{
 +	struct smi_info *info;
 +	int rv;
 +
 +	info = smi_info_alloc();
 +
 +	if (!info) {
 +		dev_err(&dev->dev,
 +			"could not allocate memory for PARISC probe\n");
 +		return -ENOMEM;
 +	}
 +
 +	info->si_type		= SI_KCS;
 +	info->addr_source	= SI_DEVICETREE;
 +	info->io_setup		= mem_setup;
 +	info->io.addr_type	= IPMI_MEM_ADDR_SPACE;
 +	info->io.addr_data	= dev->hpa.start;
 +	info->io.regsize	= 1;
 +	info->io.regspacing	= 1;
 +	info->io.regshift	= 0;
 +	info->irq		= 0; /* no interrupt */
 +	info->irq_setup		= NULL;
 +	info->dev		= &dev->dev;
 +
 +	dev_dbg(&dev->dev, "addr 0x%lx\n", info->io.addr_data);
 +
 +	dev_set_drvdata(&dev->dev, info);
 +
 +	rv = ipmi_si_add_smi(info);
 +	if (rv) {
 +		kfree(info);
 +		return rv;
 +	}
 +
 +	return 0;
 +}
 +
 +static int ipmi_parisc_remove(struct parisc_device *dev)
 +{
 +	cleanup_one_si(dev_get_drvdata(&dev->dev));
 +	return 0;
 +}
 +
 +static const struct parisc_device_id ipmi_parisc_tbl[] = {
 +	{ HPHW_MC, HVERSION_REV_ANY_ID, 0x004, 0xC0 },
 +	{ 0, }
 +};
 +
 +static struct parisc_driver ipmi_parisc_driver = {
 +	.name =		"ipmi",
 +	.id_table =	ipmi_parisc_tbl,
 +	.probe =	ipmi_parisc_probe,
 +	.remove =	ipmi_parisc_remove,
 +};
 +#endif /* CONFIG_PARISC */
 +
 +static int wait_for_msg_done(struct smi_info *smi_info)
 +{
 +	enum si_sm_result     smi_result;
 +
 +	smi_result = smi_info->handlers->event(smi_info->si_sm, 0);
 +	for (;;) {
 +		if (smi_result == SI_SM_CALL_WITH_DELAY ||
 +		    smi_result == SI_SM_CALL_WITH_TICK_DELAY) {
 +			schedule_timeout_uninterruptible(1);
 +			smi_result = smi_info->handlers->event(
 +				smi_info->si_sm, jiffies_to_usecs(1));
 +		} else if (smi_result == SI_SM_CALL_WITHOUT_DELAY) {
 +			smi_result = smi_info->handlers->event(
 +				smi_info->si_sm, 0);
 +		} else
 +			break;
 +	}
 +	if (smi_result == SI_SM_HOSED)
 +		/*
 +		 * We couldn't get the state machine to run, so whatever's at
 +		 * the port is probably not an IPMI SMI interface.
 +		 */
 +		return -ENODEV;
 +
 +	return 0;
 +}
 +
 +static int try_get_dev_id(struct smi_info *smi_info)
 +{
 +	unsigned char         msg[2];
 +	unsigned char         *resp;
 +	unsigned long         resp_len;
 +	int                   rv = 0;
 +
 +	resp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);
 +	if (!resp)
 +		return -ENOMEM;
 +
 +	/*
 +	 * Do a Get Device ID command, since it comes back with some
 +	 * useful info.
 +	 */
 +	msg[0] = IPMI_NETFN_APP_REQUEST << 2;
 +	msg[1] = IPMI_GET_DEVICE_ID_CMD;
 +	smi_info->handlers->start_transaction(smi_info->si_sm, msg, 2);
 +
 +	rv = wait_for_msg_done(smi_info);
 +	if (rv)
 +		goto out;
 +
 +	resp_len = smi_info->handlers->get_result(smi_info->si_sm,
 +						  resp, IPMI_MAX_MSG_LENGTH);
 +
 +	/* Check and record info from the get device id, in case we need it. */
 +	rv = ipmi_demangle_device_id(resp[0] >> 2, resp[1],
 +			resp + 2, resp_len - 2, &smi_info->device_id);
 +
 +out:
 +	kfree(resp);
 +	return rv;
 +}
 +
 +static int get_global_enables(struct smi_info *smi_info, u8 *enables)
 +{
 +	unsigned char         msg[3];
 +	unsigned char         *resp;
 +	unsigned long         resp_len;
 +	int                   rv;
 +
 +	resp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);
 +	if (!resp)
 +		return -ENOMEM;
 +
 +	msg[0] = IPMI_NETFN_APP_REQUEST << 2;
 +	msg[1] = IPMI_GET_BMC_GLOBAL_ENABLES_CMD;
 +	smi_info->handlers->start_transaction(smi_info->si_sm, msg, 2);
 +
 +	rv = wait_for_msg_done(smi_info);
 +	if (rv) {
 +		dev_warn(smi_info->dev,
 +			 "Error getting response from get global enables command: %d\n",
 +			 rv);
 +		goto out;
 +	}
 +
 +	resp_len = smi_info->handlers->get_result(smi_info->si_sm,
 +						  resp, IPMI_MAX_MSG_LENGTH);
 +
 +	if (resp_len < 4 ||
 +			resp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2 ||
 +			resp[1] != IPMI_GET_BMC_GLOBAL_ENABLES_CMD   ||
 +			resp[2] != 0) {
 +		dev_warn(smi_info->dev,
 +			 "Invalid return from get global enables command: %ld %x %x %x\n",
 +			 resp_len, resp[0], resp[1], resp[2]);
 +		rv = -EINVAL;
 +		goto out;
 +	} else {
 +		*enables = resp[3];
 +	}
 +
 +out:
 +	kfree(resp);
 +	return rv;
 +}
 +
 +/*
 + * Returns 1 if it gets an error from the command.
 + */
 +static int set_global_enables(struct smi_info *smi_info, u8 enables)
 +{
 +	unsigned char         msg[3];
 +	unsigned char         *resp;
 +	unsigned long         resp_len;
 +	int                   rv;
 +
 +	resp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);
 +	if (!resp)
 +		return -ENOMEM;
 +
 +	msg[0] = IPMI_NETFN_APP_REQUEST << 2;
 +	msg[1] = IPMI_SET_BMC_GLOBAL_ENABLES_CMD;
 +	msg[2] = enables;
 +	smi_info->handlers->start_transaction(smi_info->si_sm, msg, 3);
 +
 +	rv = wait_for_msg_done(smi_info);
 +	if (rv) {
 +		dev_warn(smi_info->dev,
 +			 "Error getting response from set global enables command: %d\n",
 +			 rv);
 +		goto out;
 +	}
 +
 +	resp_len = smi_info->handlers->get_result(smi_info->si_sm,
 +						  resp, IPMI_MAX_MSG_LENGTH);
 +
 +	if (resp_len < 3 ||
 +			resp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2 ||
 +			resp[1] != IPMI_SET_BMC_GLOBAL_ENABLES_CMD) {
 +		dev_warn(smi_info->dev,
 +			 "Invalid return from set global enables command: %ld %x %x\n",
 +			 resp_len, resp[0], resp[1]);
 +		rv = -EINVAL;
 +		goto out;
 +	}
 +
 +	if (resp[2] != 0)
 +		rv = 1;
 +
 +out:
 +	kfree(resp);
 +	return rv;
  }
  
  /*
@@@ -3722,12 -2506,8 +3732,15 @@@ out_err
  
  static int init_ipmi_si(void)
  {
++<<<<<<< HEAD
 +	int  i;
 +	char *str;
 +	int  rv;
++=======
++>>>>>>> 13d0b35c5c20 (ipmi_si: Move PCI setup to another file)
  	struct smi_info *e;
  	enum ipmi_addr_src type = SI_INVALID;
 +	struct ipmi_shadow_smi_handlers *shadow_handlers;
  
  	if (initialized)
  		return 0;
@@@ -3769,23 -2515,12 +3782,27 @@@
  	pr_info("IPMI System Interface driver.\n");
  
  	/* If the user gave us a device, they presumably want us to use it */
 -	if (!ipmi_si_hardcode_find_bmc())
 -		goto do_scan;
 -
 -	ipmi_si_platform_init();
 +	if (!hardcode_find_bmc())
 +		return 0;
  
++<<<<<<< HEAD
 +#ifdef CONFIG_PCI
 +	if (si_trypci) {
 +		rv = pci_register_driver(&ipmi_pci_driver);
 +		if (rv)
 +			pr_err(PFX "Unable to register PCI driver: %d\n", rv);
 +		else
 +			pci_registered = 1;
 +	}
 +#endif
++=======
+ 	ipmi_si_pci_init();
++>>>>>>> 13d0b35c5c20 (ipmi_si: Move PCI setup to another file)
 +
 +#ifdef CONFIG_ACPI
 +	if (si_tryacpi)
 +		spmi_find_bmc();
 +#endif
  
  #ifdef CONFIG_PARISC
  	register_parisc_driver(&ipmi_parisc_driver);
* Unmerged path drivers/char/ipmi/Makefile
* Unmerged path drivers/char/ipmi/ipmi_si.h
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
diff --git a/drivers/char/ipmi/ipmi_si_pci.c b/drivers/char/ipmi/ipmi_si_pci.c
new file mode 100644
index 000000000000..99771f5cad07
--- /dev/null
+++ b/drivers/char/ipmi/ipmi_si_pci.c
@@ -0,0 +1,166 @@
+/*
+ * ipmi_si_pci.c
+ *
+ * Handling for IPMI devices on the PCI bus.
+ */
+#include <linux/module.h>
+#include <linux/pci.h>
+#include "ipmi_si.h"
+
+#define PFX "ipmi_pci: "
+
+static bool pci_registered;
+
+static bool si_trypci = true;
+
+module_param_named(trypci, si_trypci, bool, 0);
+MODULE_PARM_DESC(trypci, "Setting this to zero will disable the"
+		 " default scan of the interfaces identified via pci");
+
+#define PCI_ERMC_CLASSCODE		0x0C0700
+#define PCI_ERMC_CLASSCODE_MASK		0xffffff00
+#define PCI_ERMC_CLASSCODE_TYPE_MASK	0xff
+#define PCI_ERMC_CLASSCODE_TYPE_SMIC	0x00
+#define PCI_ERMC_CLASSCODE_TYPE_KCS	0x01
+#define PCI_ERMC_CLASSCODE_TYPE_BT	0x02
+
+#define PCI_HP_VENDOR_ID    0x103C
+#define PCI_MMC_DEVICE_ID   0x121A
+#define PCI_MMC_ADDR_CW     0x10
+
+static void ipmi_pci_cleanup(struct si_sm_io *io)
+{
+	struct pci_dev *pdev = io->addr_source_data;
+
+	pci_disable_device(pdev);
+}
+
+static int ipmi_pci_probe_regspacing(struct si_sm_io *io)
+{
+	if (io->si_type == SI_KCS) {
+		unsigned char	status;
+		int		regspacing;
+
+		io->regsize = DEFAULT_REGSIZE;
+		io->regshift = 0;
+
+		/* detect 1, 4, 16byte spacing */
+		for (regspacing = DEFAULT_REGSPACING; regspacing <= 16;) {
+			io->regspacing = regspacing;
+			if (io->io_setup(io)) {
+				dev_err(io->dev,
+					"Could not setup I/O space\n");
+				return DEFAULT_REGSPACING;
+			}
+			/* write invalid cmd */
+			io->outputb(io, 1, 0x10);
+			/* read status back */
+			status = io->inputb(io, 1);
+			io->io_cleanup(io);
+			if (status)
+				return regspacing;
+			regspacing *= 4;
+		}
+	}
+	return DEFAULT_REGSPACING;
+}
+
+static int ipmi_pci_probe(struct pci_dev *pdev,
+				    const struct pci_device_id *ent)
+{
+	int rv;
+	int class_type = pdev->class & PCI_ERMC_CLASSCODE_TYPE_MASK;
+	struct si_sm_io io;
+
+	memset(&io, 0, sizeof(io));
+	io.addr_source = SI_PCI;
+	dev_info(&pdev->dev, "probing via PCI");
+
+	switch (class_type) {
+	case PCI_ERMC_CLASSCODE_TYPE_SMIC:
+		io.si_type = SI_SMIC;
+		break;
+
+	case PCI_ERMC_CLASSCODE_TYPE_KCS:
+		io.si_type = SI_KCS;
+		break;
+
+	case PCI_ERMC_CLASSCODE_TYPE_BT:
+		io.si_type = SI_BT;
+		break;
+
+	default:
+		dev_info(&pdev->dev, "Unknown IPMI type: %d\n", class_type);
+		return -ENOMEM;
+	}
+
+	rv = pci_enable_device(pdev);
+	if (rv) {
+		dev_err(&pdev->dev, "couldn't enable PCI device\n");
+		return rv;
+	}
+
+	io.addr_source_cleanup = ipmi_pci_cleanup;
+	io.addr_source_data = pdev;
+
+	if (pci_resource_flags(pdev, 0) & IORESOURCE_IO)
+		io.addr_type = IPMI_IO_ADDR_SPACE;
+	else
+		io.addr_type = IPMI_MEM_ADDR_SPACE;
+	io.addr_data = pci_resource_start(pdev, 0);
+
+	io.regspacing = ipmi_pci_probe_regspacing(&io);
+	io.regsize = DEFAULT_REGSIZE;
+	io.regshift = 0;
+
+	io.irq = pdev->irq;
+	if (io.irq)
+		io.irq_setup = ipmi_std_irq_setup;
+
+	io.dev = &pdev->dev;
+
+	dev_info(&pdev->dev, "%pR regsize %d spacing %d irq %d\n",
+		&pdev->resource[0], io.regsize, io.regspacing, io.irq);
+
+	rv = ipmi_si_add_smi(&io);
+	if (rv)
+		pci_disable_device(pdev);
+
+	return rv;
+}
+
+static void ipmi_pci_remove(struct pci_dev *pdev)
+{
+	ipmi_si_remove_by_dev(&pdev->dev);
+}
+
+static const struct pci_device_id ipmi_pci_devices[] = {
+	{ PCI_DEVICE(PCI_HP_VENDOR_ID, PCI_MMC_DEVICE_ID) },
+	{ PCI_DEVICE_CLASS(PCI_ERMC_CLASSCODE, PCI_ERMC_CLASSCODE_MASK) },
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, ipmi_pci_devices);
+
+static struct pci_driver ipmi_pci_driver = {
+	.name =         DEVICE_NAME,
+	.id_table =     ipmi_pci_devices,
+	.probe =        ipmi_pci_probe,
+	.remove =       ipmi_pci_remove,
+};
+
+void ipmi_si_pci_init(void)
+{
+	if (si_trypci) {
+		int rv = pci_register_driver(&ipmi_pci_driver);
+		if (rv)
+			pr_err(PFX "Unable to register PCI driver: %d\n", rv);
+		else
+			pci_registered = true;
+	}
+}
+
+void ipmi_si_pci_shutdown(void)
+{
+	if (pci_registered)
+		pci_unregister_driver(&ipmi_pci_driver);
+}
