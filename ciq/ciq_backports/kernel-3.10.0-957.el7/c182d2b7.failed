x86/microcode/intel: Check microcode revision before updating sibling threads

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] microcode/intel: Check microcode revision before updating sibling threads (Prarit Bhargava) [1568249]
Rebuild_FUZZ: 97.33%
commit-author Ashok Raj <ashok.raj@intel.com>
commit c182d2b7d0ca48e0d6ff16f7d883161238c447ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c182d2b7.failed

After updating microcode on one of the threads of a core, the other
thread sibling automatically gets the update since the microcode
resources on a hyperthreaded core are shared between the two threads.

Check the microcode revision on the CPU before performing a microcode
update and thus save us the WRMSR 0x79 because it is a particularly
expensive operation.

[ Borislav: Massage changelog and coding style. ]

	Signed-off-by: Ashok Raj <ashok.raj@intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Tested-by: Tom Lendacky <thomas.lendacky@amd.com>
	Tested-by: Ashok Raj <ashok.raj@intel.com>
	Cc: Arjan Van De Ven <arjan.van.de.ven@intel.com>
Link: http://lkml.kernel.org/r/1519352533-15992-2-git-send-email-ashok.raj@intel.com
Link: https://lkml.kernel.org/r/20180228102846.13447-3-bp@alien8.de

(cherry picked from commit c182d2b7d0ca48e0d6ff16f7d883161238c447ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/microcode/intel.c
diff --cc arch/x86/kernel/cpu/microcode/intel.c
index c7e50a8f4783,87bd6dc94081..000000000000
--- a/arch/x86/kernel/cpu/microcode/intel.c
+++ b/arch/x86/kernel/cpu/microcode/intel.c
@@@ -623,23 -589,25 +623,34 @@@ static int apply_microcode_early(struc
  	if (!mc)
  		return 0;
  
+ 	/*
+ 	 * Save us the MSR write below - which is a particular expensive
+ 	 * operation - when the other hyperthread has updated the microcode
+ 	 * already.
+ 	 */
+ 	rev = intel_get_microcode_revision();
+ 	if (rev >= mc->hdr.rev) {
+ 		uci->cpu_sig.rev = rev;
+ 		return UCODE_OK;
+ 	}
+ 
  	/* write microcode via MSR 0x79 */
  	native_wrmsrl(MSR_IA32_UCODE_WRITE, (unsigned long)mc->bits);
 +	native_wrmsrl(MSR_IA32_UCODE_REV, 0);
  
 -	rev = intel_get_microcode_revision();
 -	if (rev != mc->hdr.rev)
 +	/* As documented in the SDM: Do a CPUID 1 here */
 +	sync_core();
 +
 +	/* get the current revision from MSR 0x8B */
 +	native_rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);
 +	if (val[1] != mc->hdr.rev)
  		return -1;
  
 -	uci->cpu_sig.rev = rev;
 +#ifdef CONFIG_X86_64
 +	/* Flush global tlb. This is precaution. */
 +	flush_tlb_early();
 +#endif
 +	uci->cpu_sig.rev = val[1];
  
  	if (early)
  		print_ucode(uci);
@@@ -905,9 -787,9 +916,13 @@@ static int apply_microcode_intel(int cp
  {
  	struct microcode_intel *mc;
  	struct ucode_cpu_info *uci;
++<<<<<<< HEAD
 +	struct cpuinfo_x86 *c;
 +	unsigned int val[2];
++=======
+ 	struct cpuinfo_x86 *c = &cpu_data(cpu);
++>>>>>>> c182d2b7d0ca (x86/microcode/intel: Check microcode revision before updating sibling threads)
  	static int prev_rev;
 -	u32 rev;
  
  	/* We should bind the task to the CPU */
  	if (WARN_ON(raw_smp_processor_id() != cpu))
@@@ -915,48 -797,49 +930,65 @@@
  
  	uci = ucode_cpu_info + cpu;
  	mc = uci->mc;
 -	if (!mc) {
 -		/* Look for a newer patch in our cache: */
 -		mc = find_patch(uci);
 -		if (!mc)
 -			return UCODE_NFOUND;
 -	}
 +	if (!mc)
 +		return 0;
 +
 +	/*
 +	 * Microcode on this CPU could be updated earlier. Only apply the
 +	 * microcode patch in mc when it is newer than the one on this
 +	 * CPU.
 +	 */
 +	if (!get_matching_mc(mc, cpu))
 +		return 0;
  
+ 	/*
+ 	 * Save us the MSR write below - which is a particular expensive
+ 	 * operation - when the other hyperthread has updated the microcode
+ 	 * already.
+ 	 */
+ 	rev = intel_get_microcode_revision();
+ 	if (rev >= mc->hdr.rev) {
+ 		uci->cpu_sig.rev = rev;
+ 		c->microcode = rev;
+ 		return UCODE_OK;
+ 	}
+ 
  	/* write microcode via MSR 0x79 */
  	wrmsrl(MSR_IA32_UCODE_WRITE, (unsigned long)mc->bits);
 +	wrmsrl(MSR_IA32_UCODE_REV, 0);
  
 -	rev = intel_get_microcode_revision();
 +	/* As documented in the SDM: Do a CPUID 1 here */
 +	sync_core();
 +
 +	/* get the current revision from MSR 0x8B */
 +	rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);
  
 -	if (rev != mc->hdr.rev) {
 +	if (val[1] != mc->hdr.rev) {
  		pr_err("CPU%d update to revision 0x%x failed\n",
  		       cpu, mc->hdr.rev);
 -		return UCODE_ERROR;
 +		return -1;
  	}
  
 -	if (rev != prev_rev) {
 +	if (val[1] != prev_rev) {
  		pr_info("updated to revision 0x%x, date = %04x-%02x-%02x\n",
 -			rev,
 +			val[1],
  			mc->hdr.date & 0xffff,
  			mc->hdr.date >> 24,
  			(mc->hdr.date >> 16) & 0xff);
 -		prev_rev = rev;
 +		prev_rev = val[1];
  	}
  
++<<<<<<< HEAD
 +	c = &cpu_data(cpu);
 +
 +	uci->cpu_sig.rev = val[1];
 +	c->microcode = val[1];
++=======
+ 	uci->cpu_sig.rev = rev;
+ 	c->microcode = rev;
++>>>>>>> c182d2b7d0ca (x86/microcode/intel: Check microcode revision before updating sibling threads)
  
 -	return UCODE_UPDATED;
 +	return 0;
  }
  
  static enum ucode_state generic_load_microcode(int cpu, void *data, size_t size,
* Unmerged path arch/x86/kernel/cpu/microcode/intel.c
