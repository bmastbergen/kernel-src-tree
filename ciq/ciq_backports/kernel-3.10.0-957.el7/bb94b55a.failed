vfio: Use get_user_pages_longterm correctly

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [vfio] Use get_user_pages_longterm correctly (Jeff Moyer) [1585133]
Rebuild_FUZZ: 92.50%
commit-author Jason Gunthorpe <jgg@mellanox.com>
commit bb94b55af3461e26b32f0e23d455abeae0cfca5d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/bb94b55a.failed

The patch noted in the fixes below converted get_user_pages_fast() to
get_user_pages_longterm(), however the two calls differ in a few ways.

First _fast() is documented to not require the mmap_sem, while _longterm()
is documented to need it. Hold the mmap sem as required.

Second, _fast accepts an 'int write' while _longterm uses 'unsigned int
gup_flags', so the expression '!!(prot & IOMMU_WRITE)' is only working by
luck as FOLL_WRITE is currently == 0x1. Use the expected FOLL_WRITE
constant instead.

Fixes: 94db151dc892 ("vfio: disable filesystem-dax page pinning")
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Acked-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
(cherry picked from commit bb94b55af3461e26b32f0e23d455abeae0cfca5d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/vfio/vfio_iommu_type1.c
diff --cc drivers/vfio/vfio_iommu_type1.c
index ff96c53dc8fd,3e5b17710a4f..000000000000
--- a/drivers/vfio/vfio_iommu_type1.c
+++ b/drivers/vfio/vfio_iommu_type1.c
@@@ -332,22 -342,32 +332,50 @@@ static int vaddr_get_pfn(struct mm_stru
  {
  	struct page *page[1];
  	struct vm_area_struct *vma;
++<<<<<<< HEAD
++=======
+ 	struct vm_area_struct *vmas[1];
+ 	unsigned int flags = 0;
++>>>>>>> bb94b55af346 (vfio: Use get_user_pages_longterm correctly)
  	int ret;
  
+ 	if (prot & IOMMU_WRITE)
+ 		flags |= FOLL_WRITE;
+ 
+ 	down_read(&mm->mmap_sem);
  	if (mm == current->mm) {
++<<<<<<< HEAD
 +		ret = get_user_pages_fast(vaddr, 1, !!(prot & IOMMU_WRITE),
 +					  page);
 +	} else {
 +		unsigned int flags = 0;
 +
 +		if (prot & IOMMU_WRITE)
 +			flags |= FOLL_WRITE;
 +
 +		down_read(&mm->mmap_sem);
 +		ret = get_user_pages(NULL, mm, vaddr, 1,
 +				     prot & IOMMU_WRITE, 0, page, NULL);
 +		up_read(&mm->mmap_sem);
++=======
+ 		ret = get_user_pages_longterm(vaddr, 1, flags, page, vmas);
+ 	} else {
+ 		ret = get_user_pages_remote(NULL, mm, vaddr, 1, flags, page,
+ 					    vmas, NULL);
+ 		/*
+ 		 * The lifetime of a vaddr_get_pfn() page pin is
+ 		 * userspace-controlled. In the fs-dax case this could
+ 		 * lead to indefinite stalls in filesystem operations.
+ 		 * Disallow attempts to pin fs-dax pages via this
+ 		 * interface.
+ 		 */
+ 		if (ret > 0 && vma_is_fsdax(vmas[0])) {
+ 			ret = -EOPNOTSUPP;
+ 			put_page(page[0]);
+ 		}
++>>>>>>> bb94b55af346 (vfio: Use get_user_pages_longterm correctly)
  	}
+ 	up_read(&mm->mmap_sem);
  
  	if (ret == 1) {
  		*pfn = page_to_pfn(page[0]);
* Unmerged path drivers/vfio/vfio_iommu_type1.c
