xfs: Implement xfs_filemap_pfn_mkwrite() using __xfs_filemap_fault()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jan Kara <jack@suse.cz>
commit 7b565c9f965bac269cc6a1f25c819f77044abf9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7b565c9f.failed

xfs_filemap_pfn_mkwrite() duplicates a lot of __xfs_filemap_fault().
It will also need to handle flushing for synchronous page faults. So
just make that function use __xfs_filemap_fault().

	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 7b565c9f965bac269cc6a1f25c819f77044abf9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_file.c
#	fs/xfs/xfs_trace.h
diff --cc fs/xfs/xfs_file.c
index cea567087acc,4496b45678de..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -1219,27 -1094,7 +1218,31 @@@ xfs_filemap_pfn_mkwrite
  	struct vm_fault		*vmf)
  {
  
++<<<<<<< HEAD
 +	struct inode		*inode = file_inode(vma->vm_file);
 +	struct xfs_inode	*ip = XFS_I(inode);
 +	int			ret = VM_FAULT_NOPAGE;
 +	loff_t			size;
 +
 +	trace_xfs_filemap_pfn_mkwrite(ip);
 +
 +	sb_start_pagefault(inode->i_sb);
 +	file_update_time(vma->vm_file);
 +
 +	/* check if the faulting page hasn't raced with truncate */
 +	xfs_ilock(ip, XFS_MMAPLOCK_SHARED);
 +	size = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;
 +	if (vmf->pgoff >= size)
 +		ret = VM_FAULT_SIGBUS;
 +	else if (IS_DAX(inode))
 +		ret = dax_pfn_mkwrite(vma, vmf);
 +	xfs_iunlock(ip, XFS_MMAPLOCK_SHARED);
 +	sb_end_pagefault(inode->i_sb);
 +	return ret;
 +
++=======
+ 	return __xfs_filemap_fault(vmf, PE_SIZE_PTE, true);
++>>>>>>> 7b565c9f965b (xfs: Implement xfs_filemap_pfn_mkwrite() using __xfs_filemap_fault())
  }
  
  static const struct vm_operations_struct xfs_file_vm_ops = {
diff --cc fs/xfs/xfs_trace.h
index 9b67d179b1aa,6333ad09e0f3..000000000000
--- a/fs/xfs/xfs_trace.h
+++ b/fs/xfs/xfs_trace.h
@@@ -685,11 -684,35 +685,39 @@@ DEFINE_INODE_EVENT(xfs_dquot_dqdetach)
  DEFINE_INODE_EVENT(xfs_inode_set_eofblocks_tag);
  DEFINE_INODE_EVENT(xfs_inode_clear_eofblocks_tag);
  DEFINE_INODE_EVENT(xfs_inode_free_eofblocks_invalid);
 -DEFINE_INODE_EVENT(xfs_inode_set_cowblocks_tag);
 -DEFINE_INODE_EVENT(xfs_inode_clear_cowblocks_tag);
 -DEFINE_INODE_EVENT(xfs_inode_free_cowblocks_invalid);
  
++<<<<<<< HEAD
 +DEFINE_INODE_EVENT(xfs_filemap_fault);
 +DEFINE_INODE_EVENT(xfs_filemap_huge_fault);
 +DEFINE_INODE_EVENT(xfs_filemap_page_mkwrite);
 +DEFINE_INODE_EVENT(xfs_filemap_pfn_mkwrite);
++=======
+ TRACE_EVENT(xfs_filemap_fault,
+ 	TP_PROTO(struct xfs_inode *ip, enum page_entry_size pe_size,
+ 		 bool write_fault),
+ 	TP_ARGS(ip, pe_size, write_fault),
+ 	TP_STRUCT__entry(
+ 		__field(dev_t, dev)
+ 		__field(xfs_ino_t, ino)
+ 		__field(enum page_entry_size, pe_size)
+ 		__field(bool, write_fault)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->dev = VFS_I(ip)->i_sb->s_dev;
+ 		__entry->ino = ip->i_ino;
+ 		__entry->pe_size = pe_size;
+ 		__entry->write_fault = write_fault;
+ 	),
+ 	TP_printk("dev %d:%d ino 0x%llx %s write_fault %d",
+ 		  MAJOR(__entry->dev), MINOR(__entry->dev),
+ 		  __entry->ino,
+ 		  __print_symbolic(__entry->pe_size,
+ 			{ PE_SIZE_PTE,	"PTE" },
+ 			{ PE_SIZE_PMD,	"PMD" },
+ 			{ PE_SIZE_PUD,	"PUD" }),
+ 		  __entry->write_fault)
+ )
++>>>>>>> 7b565c9f965b (xfs: Implement xfs_filemap_pfn_mkwrite() using __xfs_filemap_fault())
  
  DECLARE_EVENT_CLASS(xfs_iref_class,
  	TP_PROTO(struct xfs_inode *ip, unsigned long caller_ip),
* Unmerged path fs/xfs/xfs_file.c
* Unmerged path fs/xfs/xfs_trace.h
