PCI: Add wrappers for dev_printk()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [pci] Add wrappers for dev_printk() (Jarod Wilson) [1495223]
Rebuild_FUZZ: 92.06%
commit-author Frederick Lawler <fred@fredlawl.com>
commit 7506dc7989933235e6fc23f3d0516bdbf0f7d1a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7506dc79.failed

Add PCI-specific dev_printk() wrappers and use them to simplify the code
slightly.  No functional change intended.

	Signed-off-by: Frederick Lawler <fred@fredlawl.com>
[bhelgaas: squash into one patch]
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 7506dc7989933235e6fc23f3d0516bdbf0f7d1a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/pnv_php.c
#	drivers/pci/pci-sysfs.c
#	drivers/pci/pci.c
#	drivers/pci/pcie/aspm.c
#	drivers/pci/pcie/pme.c
#	drivers/pci/pcie/ptm.c
#	drivers/pci/probe.c
#	drivers/pci/quirks.c
#	drivers/pci/setup-bus.c
#	drivers/pci/setup-irq.c
#	drivers/pci/setup-res.c
diff --cc drivers/pci/pci-sysfs.c
index cd5b1bc3eecd,c7941a0512a5..000000000000
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@@ -303,21 -405,24 +303,28 @@@ static ssize_t msi_bus_store(struct dev
  		return -EPERM;
  
  	/*
 -	 * "no_msi" and "bus_flags" only affect what happens when a driver
 -	 * requests MSI or MSI-X.  They don't affect any drivers that have
 -	 * already requested MSI or MSI-X.
 +	 * Maybe devices without subordinate buses shouldn't have this
 +	 * attribute in the first place?
  	 */
++<<<<<<< HEAD
 +	if (!pdev->subordinate)
++=======
+ 	if (!subordinate) {
+ 		pdev->no_msi = !val;
+ 		pci_info(pdev, "MSI/MSI-X %s for future drivers\n",
+ 			 val ? "allowed" : "disallowed");
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  		return count;
 -	}
  
 -	if (val)
 -		subordinate->bus_flags &= ~PCI_BUS_FLAGS_NO_MSI;
 -	else
 -		subordinate->bus_flags |= PCI_BUS_FLAGS_NO_MSI;
 +	/* Is the flag going to change, or keep the value it already had? */
 +	if (!(pdev->subordinate->bus_flags & PCI_BUS_FLAGS_NO_MSI) ^
 +	    !!val) {
 +		pdev->subordinate->bus_flags ^= PCI_BUS_FLAGS_NO_MSI;
 +
 +		dev_warn(&pdev->dev, "forced subordinate bus to%s support MSI, bad things could happen\n",
 +			 val ? "" : " not");
 +	}
  
 -	dev_info(&subordinate->dev, "MSI/MSI-X %s for future drivers of devices on this bus\n",
 -		 val ? "allowed" : "disallowed");
  	return count;
  }
  static DEVICE_ATTR_RW(msi_bus);
@@@ -517,8 -613,9 +524,14 @@@ static ssize_t sriov_numvfs_store(struc
  
  	/* is PF driver loaded w/callback */
  	if (!pdev->driver || !pdev->driver->sriov_configure) {
++<<<<<<< HEAD
 +		dev_info(&pdev->dev, "Driver doesn't support SRIOV configuration via sysfs\n");
 +		return -ENOSYS;
++=======
+ 		pci_info(pdev, "Driver doesn't support SRIOV configuration via sysfs\n");
+ 		ret = -ENOENT;
+ 		goto exit;
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  	}
  
  	if (num_vfs == 0) {
@@@ -531,19 -626,77 +544,19 @@@
  
  	/* enable VFs */
  	if (pdev->sriov->num_VFs) {
- 		dev_warn(&pdev->dev, "%d VFs already enabled. Disable before enabling %d VFs\n",
+ 		pci_warn(pdev, "%d VFs already enabled. Disable before enabling %d VFs\n",
  			 pdev->sriov->num_VFs, num_vfs);
 -		ret = -EBUSY;
 -		goto exit;
 +		return -EBUSY;
  	}
  
  	ret = pdev->driver->sriov_configure(pdev, num_vfs);
  	if (ret < 0)
 -		goto exit;
 +		return ret;
  
  	if (ret != num_vfs)
- 		dev_warn(&pdev->dev, "%d VFs requested; only %d enabled\n",
+ 		pci_warn(pdev, "%d VFs requested; only %d enabled\n",
  			 num_vfs, ret);
  
 -exit:
 -	device_unlock(&pdev->dev);
 -
 -	if (ret < 0)
 -		return ret;
 -
 -	return count;
 -}
 -
 -static ssize_t sriov_offset_show(struct device *dev,
 -				 struct device_attribute *attr,
 -				 char *buf)
 -{
 -	struct pci_dev *pdev = to_pci_dev(dev);
 -
 -	return sprintf(buf, "%u\n", pdev->sriov->offset);
 -}
 -
 -static ssize_t sriov_stride_show(struct device *dev,
 -				 struct device_attribute *attr,
 -				 char *buf)
 -{
 -	struct pci_dev *pdev = to_pci_dev(dev);
 -
 -	return sprintf(buf, "%u\n", pdev->sriov->stride);
 -}
 -
 -static ssize_t sriov_vf_device_show(struct device *dev,
 -				    struct device_attribute *attr,
 -				    char *buf)
 -{
 -	struct pci_dev *pdev = to_pci_dev(dev);
 -
 -	return sprintf(buf, "%x\n", pdev->sriov->vf_device);
 -}
 -
 -static ssize_t sriov_drivers_autoprobe_show(struct device *dev,
 -					    struct device_attribute *attr,
 -					    char *buf)
 -{
 -	struct pci_dev *pdev = to_pci_dev(dev);
 -
 -	return sprintf(buf, "%u\n", pdev->sriov->drivers_autoprobe);
 -}
 -
 -static ssize_t sriov_drivers_autoprobe_store(struct device *dev,
 -					     struct device_attribute *attr,
 -					     const char *buf, size_t count)
 -{
 -	struct pci_dev *pdev = to_pci_dev(dev);
 -	bool drivers_autoprobe;
 -
 -	if (kstrtobool(buf, &drivers_autoprobe) < 0)
 -		return -EINVAL;
 -
 -	pdev->sriov->drivers_autoprobe = drivers_autoprobe;
 -
  	return count;
  }
  
diff --cc drivers/pci/pci.c
index 78e7102016b2,d32dfd646ced..000000000000
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@@ -3520,27 -3916,49 +3516,68 @@@ int pci_wait_for_pending_transaction(st
  }
  EXPORT_SYMBOL(pci_wait_for_pending_transaction);
  
 +/*
 + * We should only need to wait 100ms after FLR, but some devices take longer.
 + * Wait for up to 1000ms for config space to return something other than -1.
 + * Intel IGD requires this when an LCD panel is attached.  We read the 2nd
 + * dword because VFs don't implement the 1st dword.
 + */
  static void pci_flr_wait(struct pci_dev *dev)
  {
 -	int delay = 1, timeout = 60000;
 +	int i = 0;
  	u32 id;
  
++<<<<<<< HEAD
 +	do {
 +		msleep(100);
++=======
+ 	/*
+ 	 * Per PCIe r3.1, sec 6.6.2, a device must complete an FLR within
+ 	 * 100ms, but may silently discard requests while the FLR is in
+ 	 * progress.  Wait 100ms before trying to access the device.
+ 	 */
+ 	msleep(100);
+ 
+ 	/*
+ 	 * After 100ms, the device should not silently discard config
+ 	 * requests, but it may still indicate that it needs more time by
+ 	 * responding to them with CRS completions.  The Root Port will
+ 	 * generally synthesize ~0 data to complete the read (except when
+ 	 * CRS SV is enabled and the read was for the Vendor ID; in that
+ 	 * case it synthesizes 0x0001 data).
+ 	 *
+ 	 * Wait for the device to return a non-CRS completion.  Read the
+ 	 * Command register instead of Vendor ID so we don't have to
+ 	 * contend with the CRS SV value.
+ 	 */
+ 	pci_read_config_dword(dev, PCI_COMMAND, &id);
+ 	while (id == ~0) {
+ 		if (delay > timeout) {
+ 			pci_warn(dev, "not ready %dms after FLR; giving up\n",
+ 				 100 + delay - 1);
+ 			return;
+ 		}
+ 
+ 		if (delay > 1000)
+ 			pci_info(dev, "not ready %dms after FLR; waiting\n",
+ 				 100 + delay - 1);
+ 
+ 		msleep(delay);
+ 		delay *= 2;
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  		pci_read_config_dword(dev, PCI_COMMAND, &id);
 -	}
 -
 +	} while (i++ < 10 && id == ~0);
 +
++<<<<<<< HEAD
 +	if (id == ~0)
 +		dev_warn(&dev->dev, "Failed to return from FLR\n");
 +	else if (i > 1)
 +		dev_info(&dev->dev, "Required additional %dms to return from FLR\n",
 +			 (i - 1) * 100);
++=======
+ 	if (delay > 1000)
+ 		pci_info(dev, "ready %dms after FLR\n", 100 + delay - 1);
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  }
  
  /**
@@@ -4766,15 -5142,16 +4803,28 @@@ int pci_set_vga_state(struct pci_dev *d
   */
  void pci_add_dma_alias(struct pci_dev *dev, u8 devfn)
  {
++<<<<<<< HEAD
 +	if (!dev->pci_dev_rh->dma_alias_mask)
 +		dev->pci_dev_rh->dma_alias_mask = kcalloc(BITS_TO_LONGS(U8_MAX),
 +							  sizeof(long), GFP_KERNEL);
 +	if (!dev->pci_dev_rh->dma_alias_mask) {
 +		dev_warn(&dev->dev, "Unable to allocate DMA alias mask\n");
 +		return;
 +	}
 +	set_bit(devfn, dev->pci_dev_rh->dma_alias_mask);
 +	dev_info(&dev->dev, "Enabling fixed DMA alias to %02x.%d\n",
++=======
+ 	if (!dev->dma_alias_mask)
+ 		dev->dma_alias_mask = kcalloc(BITS_TO_LONGS(U8_MAX),
+ 					      sizeof(long), GFP_KERNEL);
+ 	if (!dev->dma_alias_mask) {
+ 		pci_warn(dev, "Unable to allocate DMA alias mask\n");
+ 		return;
+ 	}
+ 
+ 	set_bit(devfn, dev->dma_alias_mask);
+ 	pci_info(dev, "Enabling fixed DMA alias to %02x.%d\n",
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  		 PCI_SLOT(devfn), PCI_FUNC(devfn));
  }
  
@@@ -4867,6 -5290,68 +4917,71 @@@ static resource_size_t pci_specified_re
  	return align;
  }
  
++<<<<<<< HEAD
++=======
+ static void pci_request_resource_alignment(struct pci_dev *dev, int bar,
+ 					   resource_size_t align, bool resize)
+ {
+ 	struct resource *r = &dev->resource[bar];
+ 	resource_size_t size;
+ 
+ 	if (!(r->flags & IORESOURCE_MEM))
+ 		return;
+ 
+ 	if (r->flags & IORESOURCE_PCI_FIXED) {
+ 		pci_info(dev, "BAR%d %pR: ignoring requested alignment %#llx\n",
+ 			 bar, r, (unsigned long long)align);
+ 		return;
+ 	}
+ 
+ 	size = resource_size(r);
+ 	if (size >= align)
+ 		return;
+ 
+ 	/*
+ 	 * Increase the alignment of the resource.  There are two ways we
+ 	 * can do this:
+ 	 *
+ 	 * 1) Increase the size of the resource.  BARs are aligned on their
+ 	 *    size, so when we reallocate space for this resource, we'll
+ 	 *    allocate it with the larger alignment.  This also prevents
+ 	 *    assignment of any other BARs inside the alignment region, so
+ 	 *    if we're requesting page alignment, this means no other BARs
+ 	 *    will share the page.
+ 	 *
+ 	 *    The disadvantage is that this makes the resource larger than
+ 	 *    the hardware BAR, which may break drivers that compute things
+ 	 *    based on the resource size, e.g., to find registers at a
+ 	 *    fixed offset before the end of the BAR.
+ 	 *
+ 	 * 2) Retain the resource size, but use IORESOURCE_STARTALIGN and
+ 	 *    set r->start to the desired alignment.  By itself this
+ 	 *    doesn't prevent other BARs being put inside the alignment
+ 	 *    region, but if we realign *every* resource of every device in
+ 	 *    the system, none of them will share an alignment region.
+ 	 *
+ 	 * When the user has requested alignment for only some devices via
+ 	 * the "pci=resource_alignment" argument, "resize" is true and we
+ 	 * use the first method.  Otherwise we assume we're aligning all
+ 	 * devices and we use the second.
+ 	 */
+ 
+ 	pci_info(dev, "BAR%d %pR: requesting alignment to %#llx\n",
+ 		 bar, r, (unsigned long long)align);
+ 
+ 	if (resize) {
+ 		r->start = 0;
+ 		r->end = align - 1;
+ 	} else {
+ 		r->flags &= ~IORESOURCE_SIZEALIGN;
+ 		r->flags |= IORESOURCE_STARTALIGN;
+ 		r->start = align;
+ 		r->end = r->start + size - 1;
+ 	}
+ 	r->flags |= IORESOURCE_UNSET;
+ }
+ 
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  /*
   * This function disables memory decoding and releases memory resources
   * of the device specified by kernel's boot parameter 'pci=resource_alignment='.
diff --cc drivers/pci/pcie/aspm.c
index 8b56daddc307,b89843e7c90a..000000000000
--- a/drivers/pci/pcie/aspm.c
+++ b/drivers/pci/pcie/aspm.c
@@@ -278,6 -317,21 +278,24 @@@ static u32 calc_l1_acceptable(u32 encod
  	return (1000 << encoding);
  }
  
++<<<<<<< HEAD
++=======
+ /* Convert L1SS T_pwr encoding to usec */
+ static u32 calc_l1ss_pwron(struct pci_dev *pdev, u32 scale, u32 val)
+ {
+ 	switch (scale) {
+ 	case 0:
+ 		return val * 2;
+ 	case 1:
+ 		return val * 10;
+ 	case 2:
+ 		return val * 100;
+ 	}
+ 	pci_err(pdev, "%s: Invalid T_PwrOn scale: %u\n", __func__, scale);
+ 	return 0;
+ }
+ 
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  struct aspm_register_info {
  	u32 support:2;
  	u32 enabled:2;
diff --cc drivers/pci/pcie/pme.c
index 1ae4c73e7a3c,046d9bf64ef1..000000000000
--- a/drivers/pci/pcie/pme.c
+++ b/drivers/pci/pcie/pme.c
@@@ -365,12 -342,14 +365,20 @@@ static int pcie_pme_probe(struct pcie_d
  	ret = request_irq(srv->irq, pcie_pme_irq, IRQF_SHARED, "PCIe PME", srv);
  	if (ret) {
  		kfree(data);
 -		return ret;
 +	} else {
 +		pcie_pme_mark_devices(port);
 +		pcie_pme_interrupt_enable(port, true);
  	}
  
++<<<<<<< HEAD
 +	return ret;
++=======
+ 	pci_info(port, "Signaling PME with IRQ %d\n", srv->irq);
+ 
+ 	pcie_pme_mark_devices(port);
+ 	pcie_pme_interrupt_enable(port, true);
+ 	return 0;
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  }
  
  static bool pcie_pme_check_wakeup(struct pci_bus *bus)
diff --cc drivers/pci/probe.c
index 60cc4d4c4ea4,d37466233ca0..000000000000
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@@ -1445,8 -1674,16 +1444,21 @@@ static void program_hpp_type0(struct pc
  
  static void program_hpp_type1(struct pci_dev *dev, struct hpp_type1 *hpp)
  {
++<<<<<<< HEAD
 +	if (hpp)
 +		dev_warn(&dev->dev, "PCI-X settings not supported\n");
++=======
+ 	int pos;
+ 
+ 	if (!hpp)
+ 		return;
+ 
+ 	pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
+ 	if (!pos)
+ 		return;
+ 
+ 	pci_warn(dev, "PCI-X settings not supported\n");
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  }
  
  static bool pcie_root_rcb_set(struct pci_dev *dev)
@@@ -1472,8 -1709,11 +1484,8 @@@ static void program_hpp_type2(struct pc
  	if (!hpp)
  		return;
  
 -	if (!pci_is_pcie(dev))
 -		return;
 -
  	if (hpp->revision > 1) {
- 		dev_warn(&dev->dev, "PCIe settings rev %d not supported\n",
+ 		pci_warn(dev, "PCIe settings rev %d not supported\n",
  			 hpp->revision);
  		return;
  	}
@@@ -1541,6 -1786,52 +1553,55 @@@
  	 */
  }
  
++<<<<<<< HEAD
++=======
+ int pci_configure_extended_tags(struct pci_dev *dev, void *ign)
+ {
+ 	struct pci_host_bridge *host;
+ 	u32 cap;
+ 	u16 ctl;
+ 	int ret;
+ 
+ 	if (!pci_is_pcie(dev))
+ 		return 0;
+ 
+ 	ret = pcie_capability_read_dword(dev, PCI_EXP_DEVCAP, &cap);
+ 	if (ret)
+ 		return 0;
+ 
+ 	if (!(cap & PCI_EXP_DEVCAP_EXT_TAG))
+ 		return 0;
+ 
+ 	ret = pcie_capability_read_word(dev, PCI_EXP_DEVCTL, &ctl);
+ 	if (ret)
+ 		return 0;
+ 
+ 	host = pci_find_host_bridge(dev->bus);
+ 	if (!host)
+ 		return 0;
+ 
+ 	/*
+ 	 * If some device in the hierarchy doesn't handle Extended Tags
+ 	 * correctly, make sure they're disabled.
+ 	 */
+ 	if (host->no_ext_tags) {
+ 		if (ctl & PCI_EXP_DEVCTL_EXT_TAG) {
+ 			pci_info(dev, "disabling Extended Tags\n");
+ 			pcie_capability_clear_word(dev, PCI_EXP_DEVCTL,
+ 						   PCI_EXP_DEVCTL_EXT_TAG);
+ 		}
+ 		return 0;
+ 	}
+ 
+ 	if (!(ctl & PCI_EXP_DEVCTL_EXT_TAG)) {
+ 		pci_info(dev, "enabling Extended Tags\n");
+ 		pcie_capability_set_word(dev, PCI_EXP_DEVCTL,
+ 					 PCI_EXP_DEVCTL_EXT_TAG);
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  /**
   * pcie_relaxed_ordering_enabled - Probe for PCIe relaxed ordering enable
   * @dev: PCI device to query
@@@ -2460,3 -2860,38 +2521,41 @@@ void __init pci_sort_breadthfirst(void
  {
  	bus_sort_breadthfirst(&pci_bus_type, &pci_sort_bf_cmp);
  }
++<<<<<<< HEAD
++=======
+ 
+ int pci_hp_add_bridge(struct pci_dev *dev)
+ {
+ 	struct pci_bus *parent = dev->bus;
+ 	int busnr, start = parent->busn_res.start;
+ 	unsigned int available_buses = 0;
+ 	int end = parent->busn_res.end;
+ 
+ 	for (busnr = start; busnr <= end; busnr++) {
+ 		if (!pci_find_bus(pci_domain_nr(parent), busnr))
+ 			break;
+ 	}
+ 	if (busnr-- > end) {
+ 		pci_err(dev, "No bus number available for hot-added bridge\n");
+ 		return -1;
+ 	}
+ 
+ 	/* Scan bridges that are already configured */
+ 	busnr = pci_scan_bridge(parent, dev, busnr, 0);
+ 
+ 	/*
+ 	 * Distribute the available bus numbers between hotplug-capable
+ 	 * bridges to make extending the chain later possible.
+ 	 */
+ 	available_buses = end - busnr;
+ 
+ 	/* Scan bridges that need to be reconfigured */
+ 	pci_scan_bridge_extend(parent, dev, busnr, available_buses, 1);
+ 
+ 	if (!dev->subordinate)
+ 		return -1;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(pci_hp_add_bridge);
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
diff --cc drivers/pci/quirks.c
index be41b3e1d0dc,e5cccc64940c..000000000000
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@@ -428,6 -425,28 +428,31 @@@ static void quirk_ati_exploding_mce(str
  DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI,	PCI_DEVICE_ID_ATI_RS100,   quirk_ati_exploding_mce);
  
  /*
++<<<<<<< HEAD
++=======
+  * In the AMD NL platform, this device ([1022:7912]) has a class code of
+  * PCI_CLASS_SERIAL_USB_XHCI (0x0c0330), which means the xhci driver will
+  * claim it.
+  * But the dwc3 driver is a more specific driver for this device, and we'd
+  * prefer to use it instead of xhci. To prevent xhci from claiming the
+  * device, change the class code to 0x0c03fe, which the PCI r3.0 spec
+  * defines as "USB device (not host controller)". The dwc3 driver can then
+  * claim it based on its Vendor and Device ID.
+  */
+ static void quirk_amd_nl_class(struct pci_dev *pdev)
+ {
+ 	u32 class = pdev->class;
+ 
+ 	/* Use "USB Device (not host controller)" class */
+ 	pdev->class = PCI_CLASS_SERIAL_USB_DEVICE;
+ 	pci_info(pdev, "PCI class overridden (%#08x -> %#08x) so dwc3 driver can claim this instead of xhci\n",
+ 		 class, pdev->class);
+ }
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_NL_USB,
+ 		quirk_amd_nl_class);
+ 
+ /*
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
   * Let's make the southbridge information explicit instead
   * of having to worry about people probing the ACPI areas,
   * for example.. (Yes, it happens, and if you read the wrong
@@@ -1661,7 -1683,43 +1684,23 @@@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_I
  DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	0x260a, quirk_intel_pcie_pm);
  DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	0x260b, quirk_intel_pcie_pm);
  
++<<<<<<< HEAD
++=======
+ static void quirk_radeon_pm(struct pci_dev *dev)
+ {
+ 	if (dev->subsystem_vendor == PCI_VENDOR_ID_APPLE &&
+ 	    dev->subsystem_device == 0x00e2) {
+ 		if (dev->d3_delay < 20) {
+ 			dev->d3_delay = 20;
+ 			pci_info(dev, "extending delay after power-on from D3 to %d msec\n",
+ 				 dev->d3_delay);
+ 		}
+ 	}
+ }
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x6741, quirk_radeon_pm);
+ 
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  #ifdef CONFIG_X86_IO_APIC
 -static int dmi_disable_ioapicreroute(const struct dmi_system_id *d)
 -{
 -	noioapicreroute = 1;
 -	pr_info("%s detected: disable boot interrupt reroute\n", d->ident);
 -
 -	return 0;
 -}
 -
 -static const struct dmi_system_id boot_interrupt_dmi_table[] = {
 -	/*
 -	 * Systems to exclude from boot interrupt reroute quirks
 -	 */
 -	{
 -		.callback = dmi_disable_ioapicreroute,
 -		.ident = "ASUSTek Computer INC. M2N-LR",
 -		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTek Computer INC."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "M2N-LR"),
 -		},
 -	},
 -	{}
 -};
 -
  /*
   * Boot interrupts on some chipsets cannot be turned off. For these chipsets,
   * remap the original interrupt in the linux kernel to the boot interrupt, so
@@@ -2134,7 -2193,7 +2173,11 @@@ static void quirk_blacklist_vpd(struct 
  {
  	if (dev->vpd) {
  		dev->vpd->len = 0;
++<<<<<<< HEAD
 +		dev_warn(&dev->dev, FW_BUG "VPD access disabled\n");
++=======
+ 		pci_warn(dev, FW_BUG "disabling VPD access (can't determine size of non-standard VPD format)\n");
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  	}
  }
  
@@@ -3022,9 -3103,9 +3065,9 @@@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_
  static ktime_t fixup_debug_start(struct pci_dev *dev,
  				 void (*fn)(struct pci_dev *dev))
  {
 -	ktime_t calltime = 0;
 +	ktime_t calltime = ktime_set(0, 0);
  
- 	dev_dbg(&dev->dev, "calling %pF\n", fn);
+ 	pci_dbg(dev, "calling %pF\n", fn);
  	if (initcall_debug) {
  		pr_debug("calling  %pF @ %i for %s\n",
  			 fn, task_pid_nr(current), dev_name(&dev->dev));
@@@ -3405,11 -3515,13 +3448,15 @@@ static void quirk_apple_wait_for_thunde
  	if (!nhi)
  		goto out;
  	if (nhi->vendor != PCI_VENDOR_ID_INTEL
 -		    || (nhi->device != PCI_DEVICE_ID_INTEL_LIGHT_RIDGE &&
 -			nhi->device != PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_4C &&
 -			nhi->device != PCI_DEVICE_ID_INTEL_FALCON_RIDGE_2C_NHI &&
 -			nhi->device != PCI_DEVICE_ID_INTEL_FALCON_RIDGE_4C_NHI)
 -		    || nhi->class != PCI_CLASS_SYSTEM_OTHER << 8)
 +			|| (nhi->device != 0x1547 && nhi->device != 0x156c)
 +			|| nhi->subsystem_vendor != 0x2222
 +			|| nhi->subsystem_device != 0x1111)
  		goto out;
++<<<<<<< HEAD
 +	dev_info(&dev->dev, "quirk: wating for thunderbolt to reestablish pci tunnels...\n");
++=======
+ 	pci_info(dev, "quirk: waiting for thunderbolt to reestablish PCI tunnels...\n");
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  	device_pm_wait_for_dev(&dev->dev, &nhi->dev);
  out:
  	pci_dev_put(nhi);
@@@ -4142,6 -4322,26 +4189,29 @@@ static int pci_quirk_intel_pch_acs(stru
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * These QCOM root ports do provide ACS-like features to disable peer
+  * transactions and validate bus numbers in requests, but do not provide an
+  * actual PCIe ACS capability.  Hardware supports source validation but it
+  * will report the issue as Completer Abort instead of ACS Violation.
+  * Hardware doesn't support peer-to-peer and each root port is a root
+  * complex with unique segment numbers.  It is not possible for one root
+  * port to pass traffic to another root port.  All PCIe transactions are
+  * terminated inside the root port.
+  */
+ static int pci_quirk_qcom_rp_acs(struct pci_dev *dev, u16 acs_flags)
+ {
+ 	u16 flags = (PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_UF | PCI_ACS_SV);
+ 	int ret = acs_flags & ~flags ? 0 : 1;
+ 
+ 	pci_info(dev, "Using QCOM ACS Quirk (%d)\n", ret);
+ 
+ 	return ret;
+ }
+ 
+ /*
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
   * Sunrise Point PCH root ports implement ACS, but unfortunately as shown in
   * the datasheet (Intel 100 Series Chipset Family PCH Datasheet, Vol. 2,
   * 12.1.46, 12.1.47)[1] this chipset uses dwords for the ACS capability and
@@@ -4495,3 -4788,42 +4565,45 @@@ static void quirk_intel_no_flr(struct p
  }
  DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x1502, quirk_intel_no_flr);
  DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x1503, quirk_intel_no_flr);
++<<<<<<< HEAD
++=======
+ 
+ static void quirk_no_ext_tags(struct pci_dev *pdev)
+ {
+ 	struct pci_host_bridge *bridge = pci_find_host_bridge(pdev->bus);
+ 
+ 	if (!bridge)
+ 		return;
+ 
+ 	bridge->no_ext_tags = 1;
+ 	pci_info(pdev, "disabling Extended Tags (this device can't handle them)\n");
+ 
+ 	pci_walk_bus(bridge->bus, pci_configure_extended_tags, NULL);
+ }
+ DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0140, quirk_no_ext_tags);
+ DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0142, quirk_no_ext_tags);
+ DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0144, quirk_no_ext_tags);
+ 
+ #ifdef CONFIG_PCI_ATS
+ /*
+  * Some devices have a broken ATS implementation causing IOMMU stalls.
+  * Don't use ATS for those devices.
+  */
+ static void quirk_no_ats(struct pci_dev *pdev)
+ {
+ 	pci_info(pdev, "disabling ATS (broken on this device)\n");
+ 	pdev->ats_cap = 0;
+ }
+ 
+ /* AMD Stoney platform GPU */
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x98e4, quirk_no_ats);
+ #endif /* CONFIG_PCI_ATS */
+ 
+ /* Freescale PCIe doesn't support MSI in RC mode */
+ static void quirk_fsl_no_msi(struct pci_dev *pdev)
+ {
+ 	if (pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT)
+ 		pdev->no_msi = 1;
+ }
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_FREESCALE, PCI_ANY_ID, quirk_fsl_no_msi);
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
diff --cc drivers/pci/setup-bus.c
index 7dc88ac5554e,b56bfdc18b46..000000000000
--- a/drivers/pci/setup-bus.c
+++ b/drivers/pci/setup-bus.c
@@@ -1502,8 -1568,8 +1502,13 @@@ static void pci_bridge_release_resource
  	 */
  	release_child_resources(r);
  	if (!release_resource(r)) {
++<<<<<<< HEAD
 +		type = old_flags = r->flags & type_mask;
 +		dev_printk(KERN_DEBUG, &dev->dev, "resource %d %pR released\n",
++=======
+ 		type = old_flags = r->flags & PCI_RES_TYPE_MASK;
+ 		pci_printk(KERN_DEBUG, dev, "resource %d %pR released\n",
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  					PCI_BRIDGE_RESOURCES + idx, r);
  		/* keep the old size */
  		r->end = resource_size(r) - 1;
@@@ -2021,6 -2088,104 +2026,107 @@@ enable_all
  }
  EXPORT_SYMBOL_GPL(pci_assign_unassigned_bridge_resources);
  
++<<<<<<< HEAD
++=======
+ int pci_reassign_bridge_resources(struct pci_dev *bridge, unsigned long type)
+ {
+ 	struct pci_dev_resource *dev_res;
+ 	struct pci_dev *next;
+ 	LIST_HEAD(saved);
+ 	LIST_HEAD(added);
+ 	LIST_HEAD(failed);
+ 	unsigned int i;
+ 	int ret;
+ 
+ 	/* Walk to the root hub, releasing bridge BARs when possible */
+ 	next = bridge;
+ 	do {
+ 		bridge = next;
+ 		for (i = PCI_BRIDGE_RESOURCES; i < PCI_BRIDGE_RESOURCE_END;
+ 		     i++) {
+ 			struct resource *res = &bridge->resource[i];
+ 
+ 			if ((res->flags ^ type) & PCI_RES_TYPE_MASK)
+ 				continue;
+ 
+ 			/* Ignore BARs which are still in use */
+ 			if (res->child)
+ 				continue;
+ 
+ 			ret = add_to_list(&saved, bridge, res, 0, 0);
+ 			if (ret)
+ 				goto cleanup;
+ 
+ 			pci_info(bridge, "BAR %d: releasing %pR\n",
+ 				 i, res);
+ 
+ 			if (res->parent)
+ 				release_resource(res);
+ 			res->start = 0;
+ 			res->end = 0;
+ 			break;
+ 		}
+ 		if (i == PCI_BRIDGE_RESOURCE_END)
+ 			break;
+ 
+ 		next = bridge->bus ? bridge->bus->self : NULL;
+ 	} while (next);
+ 
+ 	if (list_empty(&saved))
+ 		return -ENOENT;
+ 
+ 	__pci_bus_size_bridges(bridge->subordinate, &added);
+ 	__pci_bridge_assign_resources(bridge, &added, &failed);
+ 	BUG_ON(!list_empty(&added));
+ 
+ 	if (!list_empty(&failed)) {
+ 		ret = -ENOSPC;
+ 		goto cleanup;
+ 	}
+ 
+ 	list_for_each_entry(dev_res, &saved, list) {
+ 		/* Skip the bridge we just assigned resources for. */
+ 		if (bridge == dev_res->dev)
+ 			continue;
+ 
+ 		bridge = dev_res->dev;
+ 		pci_setup_bridge(bridge->subordinate);
+ 	}
+ 
+ 	free_list(&saved);
+ 	return 0;
+ 
+ cleanup:
+ 	/* restore size and flags */
+ 	list_for_each_entry(dev_res, &failed, list) {
+ 		struct resource *res = dev_res->res;
+ 
+ 		res->start = dev_res->start;
+ 		res->end = dev_res->end;
+ 		res->flags = dev_res->flags;
+ 	}
+ 	free_list(&failed);
+ 
+ 	/* Revert to the old configuration */
+ 	list_for_each_entry(dev_res, &saved, list) {
+ 		struct resource *res = dev_res->res;
+ 
+ 		bridge = dev_res->dev;
+ 		i = res - bridge->resource;
+ 
+ 		res->start = dev_res->start;
+ 		res->end = dev_res->end;
+ 		res->flags = dev_res->flags;
+ 
+ 		pci_claim_resource(bridge, i);
+ 		pci_setup_bridge(bridge->subordinate);
+ 	}
+ 	free_list(&saved);
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  void pci_assign_unassigned_bus_resources(struct pci_bus *bus)
  {
  	struct pci_dev *dev;
diff --cc drivers/pci/setup-irq.c
index 95c225be49d1,774defe2f7e8..000000000000
--- a/drivers/pci/setup-irq.c
+++ b/drivers/pci/setup-irq.c
@@@ -15,19 -15,19 +15,26 @@@
  #include <linux/errno.h>
  #include <linux/ioport.h>
  #include <linux/cache.h>
 -#include "pci.h"
  
 -void pci_assign_irq(struct pci_dev *dev)
 +void __weak pcibios_update_irq(struct pci_dev *dev, int irq)
  {
 -	u8 pin;
 -	u8 slot = -1;
 -	int irq = 0;
 -	struct pci_host_bridge *hbrg = pci_find_host_bridge(dev->bus);
 +	dev_dbg(&dev->dev, "assigning IRQ %02d\n", irq);
 +	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
 +}
  
++<<<<<<< HEAD
 +static void pdev_fixup_irq(struct pci_dev *dev,
 +			   u8 (*swizzle)(struct pci_dev *, u8 *),
 +			   int (*map_irq)(const struct pci_dev *, u8, u8))
 +{
 +	u8 pin, slot;
 +	int irq = 0;
++=======
+ 	if (!(hbrg->map_irq)) {
+ 		pci_dbg(dev, "runtime IRQ mapping not provided by arch\n");
+ 		return;
+ 	}
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  
  	/* If this device is not on the primary bus, we need to figure out
  	   which interrupt pin it will come in on.   We know which slot it
@@@ -50,7 -55,7 +57,11 @@@
  	}
  	dev->irq = irq;
  
++<<<<<<< HEAD
 +	dev_dbg(&dev->dev, "fixup irq: got %d\n", dev->irq);
++=======
+ 	pci_dbg(dev, "assign IRQ: got %d\n", dev->irq);
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  
  	/* Always tell the device, so the driver knows what is
  	   the real IRQ to use; the device does not use it. */
diff --cc drivers/pci/setup-res.c
index 604011e047d6,369d48d6c6f1..000000000000
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@@ -121,9 -142,17 +121,9 @@@ int pci_claim_resource(struct pci_dev *
  		return -EINVAL;
  	}
  
 -	/*
 -	 * If we have a shadow copy in RAM, the PCI device doesn't respond
 -	 * to the shadow range, so we don't need to claim it, and upstream
 -	 * bridges don't need to route the range to the device.
 -	 */
 -	if (res->flags & IORESOURCE_ROM_SHADOW)
 -		return 0;
 -
  	root = pci_find_parent_resource(dev, res);
  	if (!root) {
- 		dev_info(&dev->dev, "can't claim BAR %d %pR: no compatible bridge window\n",
+ 		pci_info(dev, "can't claim BAR %d %pR: no compatible bridge window\n",
  			 resource, res);
  		res->flags |= IORESOURCE_UNSET;
  		return -EINVAL;
@@@ -349,6 -396,64 +348,67 @@@ int pci_reassign_resource(struct pci_de
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ void pci_release_resource(struct pci_dev *dev, int resno)
+ {
+ 	struct resource *res = dev->resource + resno;
+ 
+ 	pci_info(dev, "BAR %d: releasing %pR\n", resno, res);
+ 	release_resource(res);
+ 	res->end = resource_size(res) - 1;
+ 	res->start = 0;
+ 	res->flags |= IORESOURCE_UNSET;
+ }
+ EXPORT_SYMBOL(pci_release_resource);
+ 
+ int pci_resize_resource(struct pci_dev *dev, int resno, int size)
+ {
+ 	struct resource *res = dev->resource + resno;
+ 	int old, ret;
+ 	u32 sizes;
+ 	u16 cmd;
+ 
+ 	/* Make sure the resource isn't assigned before resizing it. */
+ 	if (!(res->flags & IORESOURCE_UNSET))
+ 		return -EBUSY;
+ 
+ 	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+ 	if (cmd & PCI_COMMAND_MEMORY)
+ 		return -EBUSY;
+ 
+ 	sizes = pci_rebar_get_possible_sizes(dev, resno);
+ 	if (!sizes)
+ 		return -ENOTSUPP;
+ 
+ 	if (!(sizes & BIT(size)))
+ 		return -EINVAL;
+ 
+ 	old = pci_rebar_get_current_size(dev, resno);
+ 	if (old < 0)
+ 		return old;
+ 
+ 	ret = pci_rebar_set_size(dev, resno, size);
+ 	if (ret)
+ 		return ret;
+ 
+ 	res->end = res->start + pci_rebar_size_to_bytes(size) - 1;
+ 
+ 	/* Check if the new config works by trying to assign everything. */
+ 	ret = pci_reassign_bridge_resources(dev->bus->self, res->flags);
+ 	if (ret)
+ 		goto error_resize;
+ 
+ 	return 0;
+ 
+ error_resize:
+ 	pci_rebar_set_size(dev, resno, old);
+ 	res->end = res->start + pci_rebar_size_to_bytes(old) - 1;
+ 	return ret;
+ }
+ EXPORT_SYMBOL(pci_resize_resource);
+ 
++>>>>>>> 7506dc798993 (PCI: Add wrappers for dev_printk())
  int pci_enable_resources(struct pci_dev *dev, int mask)
  {
  	u16 cmd, old_cmd;
* Unmerged path drivers/pci/hotplug/pnv_php.c
* Unmerged path drivers/pci/pcie/ptm.c
diff --git a/drivers/pci/access.c b/drivers/pci/access.c
index 7de284e817e7..7aa7ccfb8fff 100644
--- a/drivers/pci/access.c
+++ b/drivers/pci/access.c
@@ -226,8 +226,7 @@ static size_t pci_vpd_size(struct pci_dev *dev, size_t old_size)
 			    (tag == PCI_VPD_LTIN_RW_DATA)) {
 				if (pci_read_vpd(dev, off+1, 2,
 						 &header[1]) != 2) {
-					dev_warn(&dev->dev,
-						 "invalid large VPD tag %02x size at offset %zu",
+					pci_warn(dev, "invalid large VPD tag %02x size at offset %zu",
 						 tag, off + 1);
 					return 0;
 				}
@@ -247,8 +246,7 @@ static size_t pci_vpd_size(struct pci_dev *dev, size_t old_size)
 		if ((tag != PCI_VPD_LTIN_ID_STRING) &&
 		    (tag != PCI_VPD_LTIN_RO_DATA) &&
 		    (tag != PCI_VPD_LTIN_RW_DATA)) {
-			dev_warn(&dev->dev,
-				 "invalid %s VPD tag %02x at offset %zu",
+			pci_warn(dev, "invalid %s VPD tag %02x at offset %zu",
 				 (header[0] & PCI_VPD_LRDT) ? "large" : "short",
 				 tag, off);
 			return 0;
@@ -295,7 +293,7 @@ static int pci_vpd_wait(struct pci_dev *dev)
 			max_sleep *= 2;
 	}
 
-	dev_warn(&dev->dev, "VPD access failed.  This is likely a firmware bug on this device.  Contact the card vendor for a firmware update\n");
+	pci_warn(dev, "VPD access failed.  This is likely a firmware bug on this device.  Contact the card vendor for a firmware update\n");
 	return -ETIMEDOUT;
 }
 
diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 2edd17cd541b..a14fe100bdad 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -260,7 +260,7 @@ bool pci_bus_clip_resource(struct pci_dev *dev, int idx)
 		res->end = end;
 		res->flags &= ~IORESOURCE_UNSET;
 		orig_res.flags &= ~IORESOURCE_UNSET;
-		dev_printk(KERN_DEBUG, &dev->dev, "%pR clipped to %pR\n",
+		pci_printk(KERN_DEBUG, dev, "%pR clipped to %pR\n",
 				 &orig_res, res);
 
 		return true;
@@ -296,7 +296,7 @@ void pci_bus_add_device(struct pci_dev *dev)
 	dev->match_driver = true;
 	retval = device_attach(&dev->dev);
 	if (retval < 0 && retval != -EPROBE_DEFER) {
-		dev_warn(&dev->dev, "device attach failed (%d)\n", retval);
+		pci_warn(dev, "device attach failed (%d)\n", retval);
 		pci_proc_detach_device(dev);
 		pci_remove_sysfs_dev_files(dev);
 		return;
diff --git a/drivers/pci/hotplug/cpqphp_core.c b/drivers/pci/hotplug/cpqphp_core.c
index ec009a7dba20..ef4850b91b0c 100644
--- a/drivers/pci/hotplug/cpqphp_core.c
+++ b/drivers/pci/hotplug/cpqphp_core.c
@@ -836,7 +836,7 @@ static int cpqhpc_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	bus = pdev->subordinate;
 	if (!bus) {
-		dev_notice(&pdev->dev, "the device is not a bridge, skipping\n");
+		pci_notice(pdev, "the device is not a bridge, skipping\n");
 		rc = -ENODEV;
 		goto err_disable_device;
 	}
* Unmerged path drivers/pci/hotplug/pnv_php.c
diff --git a/drivers/pci/hotplug/sgi_hotplug.c b/drivers/pci/hotplug/sgi_hotplug.c
index ca8eb63adf78..2b9abb1e5924 100644
--- a/drivers/pci/hotplug/sgi_hotplug.c
+++ b/drivers/pci/hotplug/sgi_hotplug.c
@@ -245,18 +245,18 @@ static int sn_slot_enable(struct hotplug_slot *bss_hotplug_slot,
 
 
 	if (rc == PCI_SLOT_ALREADY_UP) {
-		dev_dbg(&slot->pci_bus->self->dev, "is already active\n");
+		pci_dbg(slot->pci_bus->self, "is already active\n");
 		return 1; /* return 1 to user */
 	}
 
 	if (rc == PCI_L1_ERR) {
-		dev_dbg(&slot->pci_bus->self->dev, "L1 failure %d with message: %s",
+		pci_dbg(slot->pci_bus->self, "L1 failure %d with message: %s",
 			resp.resp_sub_errno, resp.resp_l1_msg);
 		return -EPERM;
 	}
 
 	if (rc) {
-		dev_dbg(&slot->pci_bus->self->dev, "insert failed with error %d sub-error %d\n",
+		pci_dbg(slot->pci_bus->self, "insert failed with error %d sub-error %d\n",
 			rc, resp.resp_sub_errno);
 		return -EIO;
 	}
@@ -281,23 +281,23 @@ static int sn_slot_disable(struct hotplug_slot *bss_hotplug_slot,
 
 	if ((action == PCI_REQ_SLOT_ELIGIBLE) &&
 	    (rc == PCI_SLOT_ALREADY_DOWN)) {
-		dev_dbg(&slot->pci_bus->self->dev, "Slot %s already inactive\n", slot->physical_path);
+		pci_dbg(slot->pci_bus->self, "Slot %s already inactive\n", slot->physical_path);
 		return 1; /* return 1 to user */
 	}
 
 	if ((action == PCI_REQ_SLOT_ELIGIBLE) && (rc == PCI_EMPTY_33MHZ)) {
-		dev_dbg(&slot->pci_bus->self->dev, "Cannot remove last 33MHz card\n");
+		pci_dbg(slot->pci_bus->self, "Cannot remove last 33MHz card\n");
 		return -EPERM;
 	}
 
 	if ((action == PCI_REQ_SLOT_ELIGIBLE) && (rc == PCI_L1_ERR)) {
-		dev_dbg(&slot->pci_bus->self->dev, "L1 failure %d with message \n%s\n",
+		pci_dbg(slot->pci_bus->self, "L1 failure %d with message \n%s\n",
 			resp.resp_sub_errno, resp.resp_l1_msg);
 		return -EPERM;
 	}
 
 	if ((action == PCI_REQ_SLOT_ELIGIBLE) && rc) {
-		dev_dbg(&slot->pci_bus->self->dev, "remove failed with error %d sub-error %d\n",
+		pci_dbg(slot->pci_bus->self, "remove failed with error %d sub-error %d\n",
 			rc, resp.resp_sub_errno);
 		return -EIO;
 	}
@@ -308,12 +308,12 @@ static int sn_slot_disable(struct hotplug_slot *bss_hotplug_slot,
 	if ((action == PCI_REQ_SLOT_DISABLE) && !rc) {
 		pcibus_info = SN_PCIBUS_BUSSOFT_INFO(slot->pci_bus);
 		pcibus_info->pbi_enabled_devices &= ~(1 << device_num);
-		dev_dbg(&slot->pci_bus->self->dev, "remove successful\n");
+		pci_dbg(slot->pci_bus->self, "remove successful\n");
 		return 0;
 	}
 
 	if ((action == PCI_REQ_SLOT_DISABLE) && rc) {
-		dev_dbg(&slot->pci_bus->self->dev, "remove failed rc = %d\n", rc);
+		pci_dbg(slot->pci_bus->self, "remove failed rc = %d\n", rc);
 	}
 
 	return rc;
@@ -366,7 +366,7 @@ static int enable_slot(struct hotplug_slot *bss_hotplug_slot)
 	num_funcs = pci_scan_slot(slot->pci_bus,
 				  PCI_DEVFN(slot->device_num + 1, 0));
 	if (!num_funcs) {
-		dev_dbg(&slot->pci_bus->self->dev, "no device in slot\n");
+		pci_dbg(slot->pci_bus->self, "no device in slot\n");
 		mutex_unlock(&sn_hotplug_mutex);
 		return -ENODEV;
 	}
@@ -412,7 +412,7 @@ static int enable_slot(struct hotplug_slot *bss_hotplug_slot)
 		phandle = acpi_device_handle(PCI_CONTROLLER(slot->pci_bus)->companion);
 
 		if (acpi_bus_get_device(phandle, &pdevice)) {
-			dev_dbg(&slot->pci_bus->self->dev, "no parent device, assuming NULL\n");
+			pci_dbg(slot->pci_bus->self, "no parent device, assuming NULL\n");
 			pdevice = NULL;
 		}
 
@@ -463,9 +463,9 @@ static int enable_slot(struct hotplug_slot *bss_hotplug_slot)
 	mutex_unlock(&sn_hotplug_mutex);
 
 	if (rc == 0)
-		dev_dbg(&slot->pci_bus->self->dev, "insert operation successful\n");
+		pci_dbg(slot->pci_bus->self, "insert operation successful\n");
 	else
-		dev_dbg(&slot->pci_bus->self->dev, "insert operation failed rc = %d\n", rc);
+		pci_dbg(slot->pci_bus->self, "insert operation failed rc = %d\n", rc);
 
 	return rc;
 }
@@ -642,16 +642,16 @@ static int sn_hotplug_slot_register(struct pci_bus *pci_bus)
 		if (rc)
 			goto register_err;
 	}
-	dev_dbg(&pci_bus->self->dev, "Registered bus with hotplug\n");
+	pci_dbg(pci_bus->self, "Registered bus with hotplug\n");
 	return rc;
 
 register_err:
-	dev_dbg(&pci_bus->self->dev, "bus failed to register with err = %d\n",
+	pci_dbg(pci_bus->self, "bus failed to register with err = %d\n",
 		rc);
 
 alloc_err:
 	if (rc == -ENOMEM)
-		dev_dbg(&pci_bus->self->dev, "Memory allocation error\n");
+		pci_dbg(pci_bus->self, "Memory allocation error\n");
 
 	/* destroy THIS element */
 	if (bss_hotplug_slot)
@@ -684,10 +684,10 @@ static int __init sn_pci_hotplug_init(void)
 
 		rc = sn_pci_bus_valid(pci_bus);
 		if (rc != 1) {
-			dev_dbg(&pci_bus->self->dev, "not a valid hotplug bus\n");
+			pci_dbg(pci_bus->self, "not a valid hotplug bus\n");
 			continue;
 		}
-		dev_dbg(&pci_bus->self->dev, "valid hotplug bus\n");
+		pci_dbg(pci_bus->self, "valid hotplug bus\n");
 
 		rc = sn_hotplug_slot_register(pci_bus);
 		if (!rc) {
diff --git a/drivers/pci/hotplug/shpchp.h b/drivers/pci/hotplug/shpchp.h
index 4da8fc601467..6d70ea3c59ab 100644
--- a/drivers/pci/hotplug/shpchp.h
+++ b/drivers/pci/hotplug/shpchp.h
@@ -62,15 +62,15 @@ do {									\
 #define ctrl_dbg(ctrl, format, arg...)					\
 	do {								\
 		if (shpchp_debug)					\
-			dev_printk(KERN_DEBUG, &ctrl->pci_dev->dev,	\
+			pci_printk(KERN_DEBUG, ctrl->pci_dev,		\
 					format, ## arg);		\
 	} while (0)
 #define ctrl_err(ctrl, format, arg...)					\
-	dev_err(&ctrl->pci_dev->dev, format, ## arg)
+	pci_err(ctrl->pci_dev, format, ## arg)
 #define ctrl_info(ctrl, format, arg...)					\
-	dev_info(&ctrl->pci_dev->dev, format, ## arg)
+	pci_info(ctrl->pci_dev, format, ## arg)
 #define ctrl_warn(ctrl, format, arg...)					\
-	dev_warn(&ctrl->pci_dev->dev, format, ## arg)
+	pci_warn(ctrl->pci_dev, format, ## arg)
 
 
 #define SLOT_NAME_SIZE 10
diff --git a/drivers/pci/iov.c b/drivers/pci/iov.c
index 004f2d03f374..4e1801d38fa0 100644
--- a/drivers/pci/iov.c
+++ b/drivers/pci/iov.c
@@ -271,19 +271,19 @@ static int sriov_enable(struct pci_dev *dev, int nr_virtfn)
 			nres++;
 	}
 	if (nres != iov->nres) {
-		dev_err(&dev->dev, "not enough MMIO resources for SR-IOV\n");
+		pci_err(dev, "not enough MMIO resources for SR-IOV\n");
 		return -ENOMEM;
 	}
 
 	bus = pci_iov_virtfn_bus(dev, nr_virtfn - 1);
 	if (bus > dev->bus->busn_res.end) {
-		dev_err(&dev->dev, "can't enable %d VFs (bus %02x out of range of %pR)\n",
+		pci_err(dev, "can't enable %d VFs (bus %02x out of range of %pR)\n",
 			nr_virtfn, bus, &dev->bus->busn_res);
 		return -ENOMEM;
 	}
 
 	if (pci_enable_resources(dev, bars)) {
-		dev_err(&dev->dev, "SR-IOV: IOV BARS not allocated\n");
+		pci_err(dev, "SR-IOV: IOV BARS not allocated\n");
 		return -ENOMEM;
 	}
 
@@ -317,7 +317,7 @@ static int sriov_enable(struct pci_dev *dev, int nr_virtfn)
 
 	rc = pcibios_sriov_enable(dev, initial);
 	if (rc) {
-		dev_err(&dev->dev, "failure %d from pcibios_sriov_enable()\n", rc);
+		pci_err(dev, "failure %d from pcibios_sriov_enable()\n", rc);
 		goto err_pcibios;
 	}
 
@@ -443,7 +443,7 @@ found:
 		}
 		iov->barsz[i] = resource_size(res);
 		res->end = res->start + resource_size(res) * total - 1;
-		dev_info(&dev->dev, "VF(n) BAR%d space: %pR (contains BAR%d for %d VFs)\n",
+		pci_info(dev, "VF(n) BAR%d space: %pR (contains BAR%d for %d VFs)\n",
 			 i, res, i, total);
 		i += bar64;
 		nres++;
diff --git a/drivers/pci/irq.c b/drivers/pci/irq.c
index f1e46d255c5f..2df8900d4b3b 100644
--- a/drivers/pci/irq.c
+++ b/drivers/pci/irq.c
@@ -15,11 +15,10 @@ static void pci_note_irq_problem(struct pci_dev *pdev, const char *reason)
 {
 	struct pci_dev *parent = to_pci_dev(pdev->dev.parent);
 
-	dev_err(&pdev->dev,
-		"Potentially misrouted IRQ (Bridge %s %04x:%04x)\n",
+	pci_err(pdev, "Potentially misrouted IRQ (Bridge %s %04x:%04x)\n",
 		dev_name(&parent->dev), parent->vendor, parent->device);
-	dev_err(&pdev->dev, "%s\n", reason);
-	dev_err(&pdev->dev, "Please report to linux-kernel@vger.kernel.org\n");
+	pci_err(pdev, "%s\n", reason);
+	pci_err(pdev, "Please report to linux-kernel@vger.kernel.org\n");
 	WARN_ON(1);
 }
 
diff --git a/drivers/pci/msi.c b/drivers/pci/msi.c
index 49ffa5581f51..4fc25fbc7b34 100644
--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@ -619,7 +619,7 @@ static int msi_verify_entries(struct pci_dev *dev)
 	list_for_each_entry(entry, &dev->msi_list, list) {
 		if (!dev->no_64bit_msi || !entry->msg.address_hi)
 			continue;
-		dev_err(&dev->dev, "Device has broken 64-bit MSI but arch"
+		pci_err(dev, "Device has broken 64-bit MSI but arch"
 			" tried to assign one above 4G\n");
 		return -EIO;
 	}
@@ -1050,7 +1050,7 @@ static int __pci_enable_msix(struct pci_dev *dev, struct msix_entry *entries,
 
 	/* Check whether driver already requested for MSI irq */
 	if (dev->msi_enabled) {
-		dev_info(&dev->dev, "can't enable MSI-X (MSI IRQ already assigned)\n");
+		pci_info(dev, "can't enable MSI-X (MSI IRQ already assigned)\n");
 		return -EINVAL;
 	}
 	return msix_capability_init(dev, entries, nvec, affd);
@@ -1141,8 +1141,7 @@ static int __pci_enable_msi_range(struct pci_dev *dev, int minvec, int maxvec,
 
 	/* Check whether driver already requested MSI-X irqs */
 	if (dev->msix_enabled) {
-		dev_info(&dev->dev,
-			 "can't enable MSI (MSI-X already enabled)\n");
+		pci_info(dev, "can't enable MSI (MSI-X already enabled)\n");
 		return -EINVAL;
 	}
 
diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index f8c71f6ccc20..ed95bf0f7c9c 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -470,7 +470,7 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	}
 
 	if (!error)
-		dev_dbg(&dev->dev, "power state changed by ACPI to %s\n",
+		pci_dbg(dev, "power state changed by ACPI to %s\n",
 			 acpi_power_state_string(state_conv[state]));
 
 	return error;
diff --git a/drivers/pci/pci-stub.c b/drivers/pci/pci-stub.c
index 886fb3570278..e51789e2b6c7 100644
--- a/drivers/pci/pci-stub.c
+++ b/drivers/pci/pci-stub.c
@@ -28,7 +28,7 @@ MODULE_PARM_DESC(ids, "Initial PCI IDs to add to the stub driver, format is "
 
 static int pci_stub_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	dev_info(&dev->dev, "claimed by stub\n");
+	pci_info(dev, "claimed by stub\n");
 	return 0;
 }
 
* Unmerged path drivers/pci/pci-sysfs.c
* Unmerged path drivers/pci/pci.c
diff --git a/drivers/pci/pcie/aer/aer_inject.c b/drivers/pci/pcie/aer/aer_inject.c
index 2b6a59266689..b77c01e63673 100644
--- a/drivers/pci/pcie/aer/aer_inject.c
+++ b/drivers/pci/pcie/aer/aer_inject.c
@@ -344,14 +344,14 @@ static int aer_inject(struct aer_error_inj *einj)
 		return -ENODEV;
 	rpdev = pcie_find_root_port(dev);
 	if (!rpdev) {
-		dev_err(&dev->dev, "aer_inject: Root port not found\n");
+		pci_err(dev, "aer_inject: Root port not found\n");
 		ret = -ENODEV;
 		goto out_put;
 	}
 
 	pos_cap_err = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
 	if (!pos_cap_err) {
-		dev_err(&dev->dev, "aer_inject: Device doesn't support AER\n");
+		pci_err(dev, "aer_inject: Device doesn't support AER\n");
 		ret = -EPROTONOSUPPORT;
 		goto out_put;
 	}
@@ -362,8 +362,7 @@ static int aer_inject(struct aer_error_inj *einj)
 
 	rp_pos_cap_err = pci_find_ext_capability(rpdev, PCI_EXT_CAP_ID_ERR);
 	if (!rp_pos_cap_err) {
-		dev_err(&rpdev->dev,
-			"aer_inject: Root port doesn't support AER\n");
+		pci_err(rpdev, "aer_inject: Root port doesn't support AER\n");
 		ret = -EPROTONOSUPPORT;
 		goto out_put;
 	}
@@ -411,16 +410,14 @@ static int aer_inject(struct aer_error_inj *einj)
 	if (!aer_mask_override && einj->cor_status &&
 	    !(einj->cor_status & ~cor_mask)) {
 		ret = -EINVAL;
-		dev_warn(&dev->dev,
-			 "aer_inject: The correctable error(s) is masked by device\n");
+		pci_warn(dev, "aer_inject: The correctable error(s) is masked by device\n");
 		spin_unlock_irqrestore(&inject_lock, flags);
 		goto out_put;
 	}
 	if (!aer_mask_override && einj->uncor_status &&
 	    !(einj->uncor_status & ~uncor_mask)) {
 		ret = -EINVAL;
-		dev_warn(&dev->dev,
-			 "aer_inject: The uncorrectable error(s) is masked by device\n");
+		pci_warn(dev, "aer_inject: The uncorrectable error(s) is masked by device\n");
 		spin_unlock_irqrestore(&inject_lock, flags);
 		goto out_put;
 	}
@@ -483,7 +480,7 @@ static int aer_inject(struct aer_error_inj *einj)
 			 einj->cor_status, einj->uncor_status, pci_name(dev));
 		aer_irq(-1, edev);
 	} else {
-		dev_err(&rpdev->dev, "aer_inject: AER device not found\n");
+		pci_err(rpdev, "aer_inject: AER device not found\n");
 		ret = -ENODEV;
 	}
 out_put:
diff --git a/drivers/pci/pcie/aer/aerdrv.c b/drivers/pci/pcie/aer/aerdrv.c
index 48d21e0edd56..eb779e83a127 100644
--- a/drivers/pci/pcie/aer/aerdrv.c
+++ b/drivers/pci/pcie/aer/aerdrv.c
@@ -351,7 +351,7 @@ static pci_ers_result_t aer_root_reset(struct pci_dev *dev)
 	pci_write_config_dword(dev, pos + PCI_ERR_ROOT_COMMAND, reg32);
 
 	pci_reset_bridge_secondary_bus(dev);
-	dev_printk(KERN_DEBUG, &dev->dev, "Root Port link has been reset\n");
+	pci_printk(KERN_DEBUG, dev, "Root Port link has been reset\n");
 
 	/* Clear Root Error Status */
 	pci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, &reg32);
diff --git a/drivers/pci/pcie/aer/aerdrv_core.c b/drivers/pci/pcie/aer/aerdrv_core.c
index 6b059e2409b5..373feedfda3c 100644
--- a/drivers/pci/pcie/aer/aerdrv_core.c
+++ b/drivers/pci/pcie/aer/aerdrv_core.c
@@ -224,9 +224,8 @@ static bool find_source_device(struct pci_dev *parent,
 	pci_walk_bus(parent->subordinate, find_device_iter, e_info);
 
 	if (!e_info->error_dev_num) {
-		dev_printk(KERN_DEBUG, &parent->dev,
-				"can't find device of ID%04x\n",
-				e_info->id);
+		pci_printk(KERN_DEBUG, parent, "can't find device of ID%04x\n",
+			   e_info->id);
 		return false;
 	}
 	return true;
@@ -254,7 +253,7 @@ static int report_error_detected(struct pci_dev *dev, void *data)
 			 * of a driver for this device is unaware of
 			 * its hw state.
 			 */
-			dev_printk(KERN_DEBUG, &dev->dev, "device has %s\n",
+			pci_printk(KERN_DEBUG, dev, "device has %s\n",
 				   dev->driver ?
 				   "no AER-aware driver" : "no driver");
 		}
@@ -362,7 +361,7 @@ static pci_ers_result_t broadcast_error_message(struct pci_dev *dev,
 {
 	struct aer_broadcast_data result_data;
 
-	dev_printk(KERN_DEBUG, &dev->dev, "broadcast %s message\n", error_mesg);
+	pci_printk(KERN_DEBUG, dev, "broadcast %s message\n", error_mesg);
 	result_data.state = state;
 	if (cb == report_error_detected)
 		result_data.result = PCI_ERS_RESULT_CAN_RECOVER;
@@ -404,7 +403,7 @@ static pci_ers_result_t broadcast_error_message(struct pci_dev *dev,
 static pci_ers_result_t default_reset_link(struct pci_dev *dev)
 {
 	pci_reset_bridge_secondary_bus(dev);
-	dev_printk(KERN_DEBUG, &dev->dev, "downstream link has been reset\n");
+	pci_printk(KERN_DEBUG, dev, "downstream link has been reset\n");
 	return PCI_ERS_RESULT_RECOVERED;
 }
 
@@ -456,15 +455,13 @@ static pci_ers_result_t reset_link(struct pci_dev *dev)
 	} else if (udev->has_secondary_link) {
 		status = default_reset_link(udev);
 	} else {
-		dev_printk(KERN_DEBUG, &dev->dev,
-			"no link-reset support at upstream device %s\n",
+		pci_printk(KERN_DEBUG, dev, "no link-reset support at upstream device %s\n",
 			pci_name(udev));
 		return PCI_ERS_RESULT_DISCONNECT;
 	}
 
 	if (status != PCI_ERS_RESULT_RECOVERED) {
-		dev_printk(KERN_DEBUG, &dev->dev,
-			"link reset at upstream device %s failed\n",
+		pci_printk(KERN_DEBUG, dev, "link reset at upstream device %s failed\n",
 			pci_name(udev));
 		return PCI_ERS_RESULT_DISCONNECT;
 	}
@@ -528,12 +525,12 @@ static void do_recovery(struct pci_dev *dev, int severity)
 				"resume",
 				report_resume);
 
-	dev_info(&dev->dev, "AER: Device recovery successful\n");
+	pci_info(dev, "AER: Device recovery successful\n");
 	return;
 
 failed:
 	/* TODO: Should kernel panic here? */
-	dev_info(&dev->dev, "AER: Device recovery failed\n");
+	pci_info(dev, "AER: Device recovery failed\n");
 }
 
 /**
diff --git a/drivers/pci/pcie/aer/aerdrv_errprint.c b/drivers/pci/pcie/aer/aerdrv_errprint.c
index 167fe411ce2e..1e043a1f38dc 100644
--- a/drivers/pci/pcie/aer/aerdrv_errprint.c
+++ b/drivers/pci/pcie/aer/aerdrv_errprint.c
@@ -132,7 +132,7 @@ static const char *aer_agent_string[] = {
 static void __print_tlp_header(struct pci_dev *dev,
 			       struct aer_header_log_regs *t)
 {
-	dev_err(&dev->dev, "  TLP Header: %08x %08x %08x %08x\n",
+	pci_err(dev, "  TLP Header: %08x %08x %08x %08x\n",
 		t->dw0, t->dw1, t->dw2, t->dw3);
 }
 
@@ -155,10 +155,10 @@ static void __aer_print_error(struct pci_dev *dev,
 				aer_uncorrectable_error_string[i] : NULL;
 
 		if (errmsg)
-			dev_err(&dev->dev, "   [%2d] %-22s%s\n", i, errmsg,
+			pci_err(dev, "   [%2d] %-22s%s\n", i, errmsg,
 				info->first_error == i ? " (First)" : "");
 		else
-			dev_err(&dev->dev, "   [%2d] Unknown Error Bit%s\n",
+			pci_err(dev, "   [%2d] Unknown Error Bit%s\n",
 				i, info->first_error == i ? " (First)" : "");
 	}
 }
@@ -169,7 +169,7 @@ void aer_print_error(struct pci_dev *dev, struct aer_err_info *info)
 	int id = ((dev->bus->number << 8) | dev->devfn);
 
 	if (!info->status) {
-		dev_err(&dev->dev, "PCIe Bus Error: severity=%s, type=Unaccessible, id=%04x(Unregistered Agent ID)\n",
+		pci_err(dev, "PCIe Bus Error: severity=%s, type=Unaccessible, id=%04x(Unregistered Agent ID)\n",
 			aer_error_severity_string[info->severity], id);
 		goto out;
 	}
@@ -177,11 +177,11 @@ void aer_print_error(struct pci_dev *dev, struct aer_err_info *info)
 	layer = AER_GET_LAYER_ERROR(info->severity, info->status);
 	agent = AER_GET_AGENT(info->severity, info->status);
 
-	dev_err(&dev->dev, "PCIe Bus Error: severity=%s, type=%s, id=%04x(%s)\n",
+	pci_err(dev, "PCIe Bus Error: severity=%s, type=%s, id=%04x(%s)\n",
 		aer_error_severity_string[info->severity],
 		aer_error_layer[layer], id, aer_agent_string[agent]);
 
-	dev_err(&dev->dev, "  device [%04x:%04x] error status/mask=%08x/%08x\n",
+	pci_err(dev, "  device [%04x:%04x] error status/mask=%08x/%08x\n",
 		dev->vendor, dev->device,
 		info->status, info->mask);
 
@@ -192,7 +192,7 @@ void aer_print_error(struct pci_dev *dev, struct aer_err_info *info)
 
 out:
 	if (info->id && info->error_dev_num > 1 && info->id == id)
-		dev_err(&dev->dev, "  Error of this Agent(%04x) is reported first\n", id);
+		pci_err(dev, "  Error of this Agent(%04x) is reported first\n", id);
 
 	trace_aer_event(dev_name(&dev->dev), (info->status & ~info->mask),
 			info->severity);
@@ -200,7 +200,7 @@ out:
 
 void aer_print_port_info(struct pci_dev *dev, struct aer_err_info *info)
 {
-	dev_info(&dev->dev, "AER: %s%s error received: id=%04x\n",
+	pci_info(dev, "AER: %s%s error received: id=%04x\n",
 		info->multi_error_valid ? "Multiple " : "",
 		aer_error_severity_string[info->severity], info->id);
 }
@@ -244,13 +244,13 @@ void cper_print_aer(struct pci_dev *dev, int cper_severity,
 	layer = AER_GET_LAYER_ERROR(aer_severity, status);
 	agent = AER_GET_AGENT(aer_severity, status);
 
-	dev_err(&dev->dev, "aer_status: 0x%08x, aer_mask: 0x%08x\n", status, mask);
+	pci_err(dev, "aer_status: 0x%08x, aer_mask: 0x%08x\n", status, mask);
 	cper_print_bits("", status, status_strs, status_strs_size);
-	dev_err(&dev->dev, "aer_layer=%s, aer_agent=%s\n",
+	pci_err(dev, "aer_layer=%s, aer_agent=%s\n",
 		aer_error_layer[layer], aer_agent_string[agent]);
 
 	if (aer_severity != AER_CORRECTABLE)
-		dev_err(&dev->dev, "aer_uncor_severity: 0x%08x\n",
+		pci_err(dev, "aer_uncor_severity: 0x%08x\n",
 			aer->uncor_severity);
 
 	if (tlp_header_valid)
* Unmerged path drivers/pci/pcie/aspm.c
* Unmerged path drivers/pci/pcie/pme.c
* Unmerged path drivers/pci/pcie/ptm.c
* Unmerged path drivers/pci/probe.c
* Unmerged path drivers/pci/quirks.c
diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 9eaca39ef38d..a6586cbd0d01 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -78,14 +78,14 @@ size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)
 		void __iomem *pds;
 		/* Standard PCI ROMs start out with these bytes 55 AA */
 		if (readw(image) != 0xAA55) {
-			dev_err(&pdev->dev, "Invalid PCI ROM header signature: expecting 0xaa55, got %#06x\n",
+			pci_err(pdev, "Invalid PCI ROM header signature: expecting 0xaa55, got %#06x\n",
 				readw(image));
 			break;
 		}
 		/* get the PCI data structure and check its "PCIR" signature */
 		pds = image + readw(image + 24);
 		if (readl(pds) != 0x52494350) {
-			dev_err(&pdev->dev, "Invalid PCI ROM data signature: expecting 0x52494350, got %#010x\n",
+			pci_err(pdev, "Invalid PCI ROM data signature: expecting 0x52494350, got %#010x\n",
 				readl(pds));
 			break;
 		}
* Unmerged path drivers/pci/setup-bus.c
* Unmerged path drivers/pci/setup-irq.c
* Unmerged path drivers/pci/setup-res.c
diff --git a/drivers/pci/vc.c b/drivers/pci/vc.c
index 1fa3a3219c45..881b9861aed4 100644
--- a/drivers/pci/vc.c
+++ b/drivers/pci/vc.c
@@ -57,7 +57,7 @@ static void pci_vc_load_arb_table(struct pci_dev *dev, int pos)
 				 PCI_VC_PORT_STATUS_TABLE))
 		return;
 
-	dev_err(&dev->dev, "VC arbitration table failed to load\n");
+	pci_err(dev, "VC arbitration table failed to load\n");
 }
 
 /**
@@ -85,7 +85,7 @@ static void pci_vc_load_port_arb_table(struct pci_dev *dev, int pos, int res)
 	if (pci_wait_for_pending(dev, status_pos, PCI_VC_RES_STATUS_TABLE))
 		return;
 
-	dev_err(&dev->dev, "VC%d port arbitration table failed to load\n", res);
+	pci_err(dev, "VC%d port arbitration table failed to load\n", res);
 }
 
 /**
@@ -161,11 +161,11 @@ enable:
 	pci_write_config_dword(dev, ctrl_pos, ctrl);
 
 	if (!pci_wait_for_pending(dev, status_pos, PCI_VC_RES_STATUS_NEGO))
-		dev_err(&dev->dev, "VC%d negotiation stuck pending\n", id);
+		pci_err(dev, "VC%d negotiation stuck pending\n", id);
 
 	if (link && !pci_wait_for_pending(link, status_pos2,
 					  PCI_VC_RES_STATUS_NEGO))
-		dev_err(&link->dev, "VC%d negotiation stuck pending\n", id);
+		pci_err(link, "VC%d negotiation stuck pending\n", id);
 }
 
 /**
@@ -195,8 +195,7 @@ static int pci_vc_do_save_buffer(struct pci_dev *dev, int pos,
 	/* Sanity check buffer size for save/restore */
 	if (buf && save_state->cap.size !=
 	    pci_vc_do_save_buffer(dev, pos, NULL, save)) {
-		dev_err(&dev->dev,
-			"VC save buffer size does not match @0x%x\n", pos);
+		pci_err(dev, "VC save buffer size does not match @0x%x\n", pos);
 		return -ENOMEM;
 	}
 
@@ -366,14 +365,14 @@ int pci_save_vc_state(struct pci_dev *dev)
 
 		save_state = pci_find_saved_ext_cap(dev, vc_caps[i].id);
 		if (!save_state) {
-			dev_err(&dev->dev, "%s buffer not found in %s\n",
+			pci_err(dev, "%s buffer not found in %s\n",
 				vc_caps[i].name, __func__);
 			return -ENOMEM;
 		}
 
 		ret = pci_vc_do_save_buffer(dev, pos, save_state, true);
 		if (ret) {
-			dev_err(&dev->dev, "%s save unsuccessful %s\n",
+			pci_err(dev, "%s save unsuccessful %s\n",
 				vc_caps[i].name, __func__);
 			return ret;
 		}
@@ -426,8 +425,7 @@ void pci_allocate_vc_save_buffers(struct pci_dev *dev)
 
 		len = pci_vc_do_save_buffer(dev, pos, NULL, false);
 		if (pci_add_ext_cap_save_buffer(dev, vc_caps[i].id, len))
-			dev_err(&dev->dev,
-				"unable to preallocate %s save buffer\n",
+			pci_err(dev, "unable to preallocate %s save buffer\n",
 				vc_caps[i].name);
 	}
 }
diff --git a/drivers/pci/xen-pcifront.c b/drivers/pci/xen-pcifront.c
index 13022139ac0f..c1b7ecd6c519 100644
--- a/drivers/pci/xen-pcifront.c
+++ b/drivers/pci/xen-pcifront.c
@@ -261,8 +261,8 @@ static int pci_frontend_enable_msix(struct pci_dev *dev,
 	struct msi_desc *entry;
 
 	if (nvec > SH_INFO_MAX_VEC) {
-		dev_err(&dev->dev, "too much vector for pci frontend: %x."
-				   " Increase SH_INFO_MAX_VEC.\n", nvec);
+		pci_err(dev, "too many vectors (0x%x) for PCI frontend:"
+				   " Increase SH_INFO_MAX_VEC\n", nvec);
 		return -EINVAL;
 	}
 
@@ -281,7 +281,7 @@ static int pci_frontend_enable_msix(struct pci_dev *dev,
 			/* we get the result */
 			for (i = 0; i < nvec; i++) {
 				if (op.msix_entries[i].vector <= 0) {
-					dev_warn(&dev->dev, "MSI-X entry %d is invalid: %d!\n",
+					pci_warn(dev, "MSI-X entry %d is invalid: %d!\n",
 						i, op.msix_entries[i].vector);
 					err = -EINVAL;
 					vector[i] = -1;
@@ -295,7 +295,7 @@ static int pci_frontend_enable_msix(struct pci_dev *dev,
 			err = op.value;
 		}
 	} else {
-		dev_err(&dev->dev, "enable msix get err %x\n", err);
+		pci_err(dev, "enable msix get err %x\n", err);
 	}
 	return err;
 }
@@ -316,7 +316,7 @@ static void pci_frontend_disable_msix(struct pci_dev *dev)
 
 	/* What should do for error ? */
 	if (err)
-		dev_err(&dev->dev, "pci_disable_msix get err %x\n", err);
+		pci_err(dev, "pci_disable_msix get err %x\n", err);
 }
 
 static int pci_frontend_enable_msi(struct pci_dev *dev, int vector[])
@@ -335,13 +335,13 @@ static int pci_frontend_enable_msi(struct pci_dev *dev, int vector[])
 	if (likely(!err)) {
 		vector[0] = op.value;
 		if (op.value <= 0) {
-			dev_warn(&dev->dev, "MSI entry is invalid: %d!\n",
+			pci_warn(dev, "MSI entry is invalid: %d!\n",
 				op.value);
 			err = -EINVAL;
 			vector[0] = -1;
 		}
 	} else {
-		dev_err(&dev->dev, "pci frontend enable msi failed for dev "
+		pci_err(dev, "pci frontend enable msi failed for dev "
 				    "%x:%x\n", op.bus, op.devfn);
 		err = -EINVAL;
 	}
@@ -546,7 +546,7 @@ static void free_root_bus_devs(struct pci_bus *bus)
 	while (!list_empty(&bus->devices)) {
 		dev = container_of(bus->devices.next, struct pci_dev,
 				   bus_list);
-		dev_dbg(&dev->dev, "removing device\n");
+		pci_dbg(dev, "removing device\n");
 		pci_stop_and_remove_bus_device(dev);
 	}
 }
@@ -597,8 +597,7 @@ static pci_ers_result_t pcifront_common_process(int cmd,
 
 	if (pdrv) {
 		if (pdrv->err_handler && pdrv->err_handler->error_detected) {
-			dev_dbg(&pcidev->dev,
-				"trying to call AER service\n");
+			pci_dbg(pcidev, "trying to call AER service\n");
 			if (pcidev) {
 				flag = 1;
 				switch (cmd) {
diff --git a/include/linux/pci.h b/include/linux/pci.h
index 2d20a9a169fc..98983252b6e3 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -2124,4 +2124,16 @@ static inline bool pci_is_thunderbolt_attached(struct pci_dev *pdev)
 /* provide the legacy pci_dma_* API */
 #include <linux/pci-dma-compat.h>
 
+#define pci_printk(level, pdev, fmt, arg...) \
+	dev_printk(level, &(pdev)->dev, fmt, ##arg)
+
+#define pci_emerg(pdev, fmt, arg...)	dev_emerg(&(pdev)->dev, fmt, ##arg)
+#define pci_alert(pdev, fmt, arg...)	dev_alert(&(pdev)->dev, fmt, ##arg)
+#define pci_crit(pdev, fmt, arg...)	dev_crit(&(pdev)->dev, fmt, ##arg)
+#define pci_err(pdev, fmt, arg...)	dev_err(&(pdev)->dev, fmt, ##arg)
+#define pci_warn(pdev, fmt, arg...)	dev_warn(&(pdev)->dev, fmt, ##arg)
+#define pci_notice(pdev, fmt, arg...)	dev_notice(&(pdev)->dev, fmt, ##arg)
+#define pci_info(pdev, fmt, arg...)	dev_info(&(pdev)->dev, fmt, ##arg)
+#define pci_dbg(pdev, fmt, arg...)	dev_dbg(&(pdev)->dev, fmt, ##arg)
+
 #endif /* LINUX_PCI_H */
