fs: allow per-device dax status checking for filesystems

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [fs] allow per-device dax status checking for filesystems (Jeff Moyer) [1568240]
Rebuild_FUZZ: 96.30%
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit ba23cba9b3bdc967aabdc6ff1e3e9b11ce05bb4f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ba23cba9.failed

Change bdev_dax_supported so it takes a bdev parameter.  This enables
multi-device filesystems like xfs to check that a dax device can work for
the particular filesystem.  Once that's in place, actually fix all the
parts of XFS where we need to be able to distinguish between datadev and
rtdev.

This patch fixes the problem where we screw up the dax support checking
in xfs if the datadev and rtdev have different dax capabilities.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
[rez: Re-added __bdev_dax_supported() for !CONFIG_FS_DAX cases]
	Signed-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Reviewed-by: Eric Sandeen <sandeen@redhat.com>
(cherry picked from commit ba23cba9b3bdc967aabdc6ff1e3e9b11ce05bb4f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dax/super.c
#	fs/ext2/super.c
#	fs/ext4/super.c
#	fs/xfs/xfs_iops.c
#	fs/xfs/xfs_super.c
diff --cc drivers/dax/super.c
index 41efc362f7f7,3943feb9a090..000000000000
--- a/drivers/dax/super.c
+++ b/drivers/dax/super.c
@@@ -62,9 -62,19 +62,9 @@@ int bdev_dax_pgoff(struct block_device 
  }
  EXPORT_SYMBOL(bdev_dax_pgoff);
  
 -#if IS_ENABLED(CONFIG_FS_DAX)
 -struct dax_device *fs_dax_get_by_bdev(struct block_device *bdev)
 -{
 -	if (!blk_queue_dax(bdev->bd_queue))
 -		return NULL;
 -	return fs_dax_get_by_host(bdev->bd_disk->disk_name);
 -}
 -EXPORT_SYMBOL_GPL(fs_dax_get_by_bdev);
 -#endif
 -
  /**
   * __bdev_dax_supported() - Check if the device supports dax for filesystem
-  * @sb: The superblock of the device
+  * @bdev: block device to check
   * @blocksize: The block size of the device
   *
   * This is a library function for filesystems to check if the block device
@@@ -81,24 -90,25 +80,40 @@@ int __bdev_dax_supported(struct block_d
  	void *kaddr;
  	pfn_t pfn;
  	long len;
+ 	char buf[BDEVNAME_SIZE];
  
  	if (blocksize != PAGE_SIZE) {
++<<<<<<< HEAD
 +		pr_err("VFS (%s): error: unsupported blocksize for dax\n",
 +				sb->s_id);
++=======
+ 		pr_debug("%s: error: unsupported blocksize for dax\n",
+ 				bdevname(bdev, buf));
++>>>>>>> ba23cba9b3bd (fs: allow per-device dax status checking for filesystems)
  		return -EINVAL;
  	}
  
  	err = bdev_dax_pgoff(bdev, 0, PAGE_SIZE, &pgoff);
  	if (err) {
++<<<<<<< HEAD
 +		pr_err("VFS (%s): error: unaligned partition for dax\n",
 +				sb->s_id);
++=======
+ 		pr_debug("%s: error: unaligned partition for dax\n",
+ 				bdevname(bdev, buf));
++>>>>>>> ba23cba9b3bd (fs: allow per-device dax status checking for filesystems)
  		return err;
  	}
  
  	dax_dev = dax_get_by_host(bdev->bd_disk->disk_name);
  	if (!dax_dev) {
++<<<<<<< HEAD
 +		pr_err("VFS (%s): error: device does not support dax\n",
 +				sb->s_id);
++=======
+ 		pr_debug("%s: error: device does not support dax\n",
+ 				bdevname(bdev, buf));
++>>>>>>> ba23cba9b3bd (fs: allow per-device dax status checking for filesystems)
  		return -EOPNOTSUPP;
  	}
  
@@@ -109,17 -119,26 +124,28 @@@
  	put_dax(dax_dev);
  
  	if (len < 1) {
++<<<<<<< HEAD
 +		pr_err("VFS (%s): error: dax access failed (%ld)\n",
 +				sb->s_id, len);
++=======
+ 		pr_debug("%s: error: dax access failed (%ld)\n",
+ 				bdevname(bdev, buf), len);
++>>>>>>> ba23cba9b3bd (fs: allow per-device dax status checking for filesystems)
  		return len < 0 ? len : -EIO;
  	}
  
 -	if (IS_ENABLED(CONFIG_FS_DAX_LIMITED) && pfn_t_special(pfn)) {
 -		/*
 -		 * An arch that has enabled the pmem api should also
 -		 * have its drivers support pfn_t_devmap()
 -		 *
 -		 * This is a developer warning and should not trigger in
 -		 * production. dax_flush() will crash since it depends
 -		 * on being able to do (page_address(pfn_to_page())).
 -		 */
 -		WARN_ON(IS_ENABLED(CONFIG_ARCH_HAS_PMEM_API));
 -	} else if (pfn_t_devmap(pfn)) {
 +	if ((IS_ENABLED(CONFIG_FS_DAX_LIMITED) && pfn_t_special(pfn))
 +			|| pfn_t_devmap(pfn))
  		/* pass */;
++<<<<<<< HEAD
 +	else {
 +		pr_debug("VFS (%s): error: dax support not enabled\n",
 +				sb->s_id);
++=======
+ 	} else {
+ 		pr_debug("%s: error: dax support not enabled\n",
+ 				bdevname(bdev, buf));
++>>>>>>> ba23cba9b3bd (fs: allow per-device dax status checking for filesystems)
  		return -EOPNOTSUPP;
  	}
  
diff --cc fs/ext2/super.c
index 241c03defc77,9627c3054b5c..000000000000
--- a/fs/ext2/super.c
+++ b/fs/ext2/super.c
@@@ -909,15 -961,11 +909,20 @@@ static int ext2_fill_super(struct super
  	blocksize = BLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);
  
  	if (sbi->s_mount_opt & EXT2_MOUNT_DAX) {
++<<<<<<< HEAD
 +		if (blocksize != PAGE_SIZE) {
++=======
+ 		err = bdev_dax_supported(sb->s_bdev, blocksize);
+ 		if (err) {
++>>>>>>> ba23cba9b3bd (fs: allow per-device dax status checking for filesystems)
  			ext2_msg(sb, KERN_ERR,
 -				"DAX unsupported by block device. Turning off DAX.");
 -			sbi->s_mount_opt &= ~EXT2_MOUNT_DAX;
 +					"error: unsupported blocksize for dax");
 +			goto failed_mount;
 +		}
 +		if (!sb->s_bdev->bd_disk->fops->direct_access) {
 +			ext2_msg(sb, KERN_ERR,
 +					"error: device does not support dax");
 +			goto failed_mount;
  		}
  	}
  
diff --cc fs/ext4/super.c
index 0d44f68dead8,089170e99895..000000000000
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@@ -3777,20 -3727,16 +3777,28 @@@ static int ext4_fill_super(struct super
  	}
  
  	if (sbi->s_mount_opt & EXT4_MOUNT_DAX) {
 -		if (ext4_has_feature_inline_data(sb)) {
 +		static bool printed = false;
 +
 +		if (EXT4_HAS_INCOMPAT_FEATURE(sb,
 +					EXT4_FEATURE_INCOMPAT_INLINE_DATA)) {
  			ext4_msg(sb, KERN_ERR, "Cannot use DAX on a filesystem"
  					" that may contain inline data");
 -			sbi->s_mount_opt &= ~EXT4_MOUNT_DAX;
 +			goto failed_mount;
  		}
++<<<<<<< HEAD
 +		err = bdev_dax_supported(sb, blocksize);
 +		if (err)
 +			goto failed_mount;
 +		if (!printed) {
 +			mark_tech_preview("ext4 direct access (dax)", NULL);
 +			printed = true;
++=======
+ 		err = bdev_dax_supported(sb->s_bdev, blocksize);
+ 		if (err) {
+ 			ext4_msg(sb, KERN_ERR,
+ 				"DAX unsupported by block device. Turning off DAX.");
+ 			sbi->s_mount_opt &= ~EXT4_MOUNT_DAX;
++>>>>>>> ba23cba9b3bd (fs: allow per-device dax status checking for filesystems)
  		}
  	}
  
diff --cc fs/xfs/xfs_iops.c
index 8c9150043298,9925d75411bb..000000000000
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@@ -1206,10 -1237,7 +1230,14 @@@ xfs_diflags_to_iflags
  		inode->i_flags |= S_SYNC;
  	if (flags & XFS_DIFLAG_NOATIME)
  		inode->i_flags |= S_NOATIME;
++<<<<<<< HEAD
 +	if (S_ISREG(inode->i_mode) &&
 +	    ip->i_mount->m_sb.sb_blocksize == PAGE_SIZE &&
 +	    (ip->i_mount->m_flags & XFS_MOUNT_DAX ||
 +	     ip->i_d.di_flags2 & XFS_DIFLAG2_DAX))
++=======
+ 	if (xfs_inode_supports_dax(ip))
++>>>>>>> ba23cba9b3bd (fs: allow per-device dax status checking for filesystems)
  		inode->i_flags |= S_DAX;
  }
  
diff --cc fs/xfs/xfs_super.c
index 4f6ef583f948,fed63e0b8f4d..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -1614,10 -1698,10 +1614,14 @@@ xfs_fs_fill_super
  
  	/* version 5 superblocks support inode version counters. */
  	if (XFS_SB_VERSION_NUM(&mp->m_sb) == XFS_SB_VERSION_5)
 -		sb->s_flags |= SB_I_VERSION;
 +		sb->s_flags |= MS_I_VERSION;
  
  	if (mp->m_flags & XFS_MOUNT_DAX) {
++<<<<<<< HEAD
 +		static bool printed = false;
++=======
+ 		int	error2 = 0;
++>>>>>>> ba23cba9b3bd (fs: allow per-device dax status checking for filesystems)
  
  		xfs_warn(mp,
  		"DAX enabled. Warning: EXPERIMENTAL, use at your own risk");
* Unmerged path drivers/dax/super.c
* Unmerged path fs/ext2/super.c
* Unmerged path fs/ext4/super.c
diff --git a/fs/xfs/xfs_ioctl.c b/fs/xfs/xfs_ioctl.c
index 16aae82f734b..221f50713fdc 100644
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@ -1114,7 +1114,8 @@ xfs_ioctl_setattr_dax_invalidate(
 	if (fa->fsx_xflags & XFS_XFLAG_DAX) {
 		if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))
 			return -EINVAL;
-		if (bdev_dax_supported(sb, sb->s_blocksize) < 0)
+		if (bdev_dax_supported(xfs_find_bdev_for_inode(VFS_I(ip)),
+				sb->s_blocksize) < 0)
 			return -EINVAL;
 	}
 
* Unmerged path fs/xfs/xfs_iops.c
* Unmerged path fs/xfs/xfs_super.c
diff --git a/include/linux/dax.h b/include/linux/dax.h
index b7b81d6cc271..8432f725976e 100644
--- a/include/linux/dax.h
+++ b/include/linux/dax.h
@@ -50,13 +50,14 @@ struct dax_operations {
 
 int bdev_dax_pgoff(struct block_device *, sector_t, size_t, pgoff_t *pgoff);
 #if IS_ENABLED(CONFIG_FS_DAX)
-int __bdev_dax_supported(struct super_block *sb, int blocksize);
-static inline int bdev_dax_supported(struct super_block *sb, int blocksize)
+int __bdev_dax_supported(struct block_device *bdev, int blocksize);
+static inline int bdev_dax_supported(struct block_device *bdev, int blocksize)
 {
-	return __bdev_dax_supported(sb, blocksize);
+	return __bdev_dax_supported(bdev, blocksize);
 }
 #else
-static inline int bdev_dax_supported(struct super_block *sb, int blocksize)
+static inline int bdev_dax_supported(struct block_device *bdev,
+		int blocksize)
 {
 	return -EOPNOTSUPP;
 }
