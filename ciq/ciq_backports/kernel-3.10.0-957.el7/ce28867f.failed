s390/qeth: don't clobber buffer on async TX completion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [s390] qeth: don't clobber buffer on async TX completion (Hendrik Brueckner) [1613970]
Rebuild_FUZZ: 95.15%
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit ce28867fd20c23cd769e78b4d619c4755bf71a1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ce28867f.failed

If qeth_qdio_output_handler() detects that a transmit requires async
completion, it replaces the pending buffer's metadata object
(qeth_qdio_out_buffer) so that this queue buffer can be re-used while
the data is pending completion.

Later when the CQ indicates async completion of such a metadata object,
qeth_qdio_cq_handler() tries to free any data associated with this
object (since HW has now completed the transfer). By calling
qeth_clear_output_buffer(), it erronously operates on the queue buffer
that _previously_ belonged to this transfer ... but which has been
potentially re-used several times by now.
This results in double-free's of the buffer's data, and failing
transmits as the buffer descriptor is scrubbed in mid-air.

The correct way of handling this situation is to
1. scrub the queue buffer when it is prepared for re-use, and
2. later obtain the data addresses from the async-completion notifier
   (ie. the AOB), instead of the queue buffer.

All this only affects qeth devices used for af_iucv HiperTransport.

Fixes: 0da9581ddb0f ("qeth: exploit asynchronous delivery of storage blocks")
	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ce28867fd20c23cd769e78b4d619c4755bf71a1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core.h
diff --cc drivers/s390/net/qeth_core.h
index 2c599bc730e4,940fd7b558d3..000000000000
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@@ -851,11 -829,28 +851,34 @@@ struct qeth_trap_id 
  /*some helper functions*/
  #define QETH_CARD_IFNAME(card) (((card)->dev)? (card)->dev->name : "")
  
++<<<<<<< HEAD
 +static inline struct qeth_card *CARD_FROM_CDEV(struct ccw_device *cdev)
++=======
+ static inline void qeth_scrub_qdio_buffer(struct qdio_buffer *buf,
+ 					  unsigned int elements)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < elements; i++)
+ 		memset(&buf->element[i], 0, sizeof(struct qdio_buffer_element));
+ 	buf->element[14].sflags = 0;
+ 	buf->element[15].sflags = 0;
+ }
+ 
+ /**
+  * qeth_get_elements_for_range() -	find number of SBALEs to cover range.
+  * @start:				Start of the address range.
+  * @end:				Address after the end of the range.
+  *
+  * Returns the number of pages, and thus QDIO buffer elements, needed to cover
+  * the specified address range.
+  */
+ static inline int qeth_get_elements_for_range(addr_t start, addr_t end)
++>>>>>>> ce28867fd20c (s390/qeth: don't clobber buffer on async TX completion)
  {
 -	return PFN_UP(end) - PFN_DOWN(start);
 +	struct qeth_card *card = dev_get_drvdata(&((struct ccwgroup_device *)
 +		dev_get_drvdata(&cdev->dev))->dev);
 +	return card;
  }
  
  static inline int qeth_get_micros(void)
* Unmerged path drivers/s390/net/qeth_core.h
diff --git a/drivers/s390/net/qeth_core_main.c b/drivers/s390/net/qeth_core_main.c
index 467355a4d78a..17993189ea53 100644
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -68,9 +68,6 @@ static void qeth_notify_skbs(struct qeth_qdio_out_q *queue,
 		struct qeth_qdio_out_buffer *buf,
 		enum iucv_tx_notify notification);
 static void qeth_release_skbs(struct qeth_qdio_out_buffer *buf);
-static void qeth_clear_output_buffer(struct qeth_qdio_out_q *queue,
-		struct qeth_qdio_out_buffer *buf,
-		enum qeth_qdio_buffer_states newbufstate);
 static int qeth_init_qdio_out_buf(struct qeth_qdio_out_q *, int);
 
 struct workqueue_struct *qeth_wq;
@@ -454,6 +451,7 @@ static inline void qeth_qdio_handle_aob(struct qeth_card *card,
 	struct qaob *aob;
 	struct qeth_qdio_out_buffer *buffer;
 	enum iucv_tx_notify notification;
+	unsigned int i;
 
 	aob = (struct qaob *) phys_to_virt(phys_aob_addr);
 	QETH_CARD_TEXT(card, 5, "haob");
@@ -478,10 +476,18 @@ static inline void qeth_qdio_handle_aob(struct qeth_card *card,
 	qeth_notify_skbs(buffer->q, buffer, notification);
 
 	buffer->aob = NULL;
-	qeth_clear_output_buffer(buffer->q, buffer,
-				 QETH_QDIO_BUF_HANDLED_DELAYED);
+	/* Free dangling allocations. The attached skbs are handled by
+	 * qeth_cleanup_handled_pending().
+	 */
+	for (i = 0;
+	     i < aob->sb_count && i < QETH_MAX_BUFFER_ELEMENTS(card);
+	     i++) {
+		if (aob->sba[i] && buffer->is_header[i])
+			kmem_cache_free(qeth_core_header_cache,
+					(void *) aob->sba[i]);
+	}
+	atomic_set(&buffer->state, QETH_QDIO_BUF_HANDLED_DELAYED);
 
-	/* from here on: do not touch buffer anymore */
 	qdio_release_aob(aob);
 }
 
@@ -3690,6 +3696,10 @@ void qeth_qdio_output_handler(struct ccw_device *ccwdev,
 			QETH_CARD_TEXT(queue->card, 5, "aob");
 			QETH_CARD_TEXT_(queue->card, 5, "%lx",
 					virt_to_phys(buffer->aob));
+
+			/* prepare the queue slot for re-use: */
+			qeth_scrub_qdio_buffer(buffer->buffer,
+					       QETH_MAX_BUFFER_ELEMENTS(card));
 			if (qeth_init_qdio_out_buf(queue, bidx)) {
 				QETH_CARD_TEXT(card, 2, "outofbuf");
 				qeth_schedule_recovery(card);
