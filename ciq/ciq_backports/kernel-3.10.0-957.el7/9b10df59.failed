i40e: use WARN_ONCE to replace the commented BUG_ON size check

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 9b10df596bd4d38f2a58cf87e0780510acc53d8d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9b10df59.failed

We don't really want to use BUG_ON here since that would completely
crash the kernel, thus the reason we commented it out. We *can't* use
BUILD_BUG_ON because at least now (a) the sizes aren't constant (we are
fixing this) and (b) not all compilers are smart enough to understand
that "p - data" is a constant.

Instead, just use a WARN_ONCE so that the first time we end up with an
incorrect size we will dump a stack trace and a message, hopefully
highlighting the issues early in testing.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 9b10df596bd4d38f2a58cf87e0780510acc53d8d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_ethtool.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index 07042090c395,32bcb6a2a590..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@@ -1704,6 -1787,110 +1704,113 @@@ static void i40e_get_ethtool_stats(stru
  		data[i++] = pf->stats.priority_xon_2_xoff[j];
  }
  
++<<<<<<< HEAD
++=======
+ static void i40e_get_stat_strings(struct net_device *netdev, u8 *data)
+ {
+ 	struct i40e_netdev_priv *np = netdev_priv(netdev);
+ 	struct i40e_vsi *vsi = np->vsi;
+ 	struct i40e_pf *pf = vsi->back;
+ 	unsigned int i;
+ 	u8 *p = data;
+ 
+ 	for (i = 0; i < I40E_NETDEV_STATS_LEN; i++) {
+ 		snprintf(p, ETH_GSTRING_LEN, "%s",
+ 			 i40e_gstrings_net_stats[i].stat_string);
+ 		p += ETH_GSTRING_LEN;
+ 	}
+ 	for (i = 0; i < I40E_MISC_STATS_LEN; i++) {
+ 		snprintf(p, ETH_GSTRING_LEN, "%s",
+ 			 i40e_gstrings_misc_stats[i].stat_string);
+ 		p += ETH_GSTRING_LEN;
+ 	}
+ 	for (i = 0; i < I40E_MAX_NUM_QUEUES(netdev); i++) {
+ 		snprintf(p, ETH_GSTRING_LEN, "tx-%u.tx_packets", i);
+ 		p += ETH_GSTRING_LEN;
+ 		snprintf(p, ETH_GSTRING_LEN, "tx-%u.tx_bytes", i);
+ 		p += ETH_GSTRING_LEN;
+ 		snprintf(p, ETH_GSTRING_LEN, "rx-%u.rx_packets", i);
+ 		p += ETH_GSTRING_LEN;
+ 		snprintf(p, ETH_GSTRING_LEN, "rx-%u.rx_bytes", i);
+ 		p += ETH_GSTRING_LEN;
+ 	}
+ 	if (vsi != pf->vsi[pf->lan_vsi] || pf->hw.partition_id != 1)
+ 		return;
+ 
+ 	for (i = 0; i < I40E_VEB_STATS_LEN; i++) {
+ 		snprintf(p, ETH_GSTRING_LEN, "veb.%s",
+ 			 i40e_gstrings_veb_stats[i].stat_string);
+ 		p += ETH_GSTRING_LEN;
+ 	}
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 		snprintf(p, ETH_GSTRING_LEN,
+ 			 "veb.tc_%u_tx_packets", i);
+ 		p += ETH_GSTRING_LEN;
+ 		snprintf(p, ETH_GSTRING_LEN,
+ 			 "veb.tc_%u_tx_bytes", i);
+ 		p += ETH_GSTRING_LEN;
+ 		snprintf(p, ETH_GSTRING_LEN,
+ 			 "veb.tc_%u_rx_packets", i);
+ 		p += ETH_GSTRING_LEN;
+ 		snprintf(p, ETH_GSTRING_LEN,
+ 			 "veb.tc_%u_rx_bytes", i);
+ 		p += ETH_GSTRING_LEN;
+ 	}
+ 
+ 	for (i = 0; i < I40E_GLOBAL_STATS_LEN; i++) {
+ 		snprintf(p, ETH_GSTRING_LEN, "port.%s",
+ 			 i40e_gstrings_stats[i].stat_string);
+ 		p += ETH_GSTRING_LEN;
+ 	}
+ 	for (i = 0; i < I40E_MAX_USER_PRIORITY; i++) {
+ 		snprintf(p, ETH_GSTRING_LEN,
+ 			 "port.tx_priority_%u_xon", i);
+ 		p += ETH_GSTRING_LEN;
+ 		snprintf(p, ETH_GSTRING_LEN,
+ 			 "port.tx_priority_%u_xoff", i);
+ 		p += ETH_GSTRING_LEN;
+ 	}
+ 	for (i = 0; i < I40E_MAX_USER_PRIORITY; i++) {
+ 		snprintf(p, ETH_GSTRING_LEN,
+ 			 "port.rx_priority_%u_xon", i);
+ 		p += ETH_GSTRING_LEN;
+ 		snprintf(p, ETH_GSTRING_LEN,
+ 			 "port.rx_priority_%u_xoff", i);
+ 		p += ETH_GSTRING_LEN;
+ 	}
+ 	for (i = 0; i < I40E_MAX_USER_PRIORITY; i++) {
+ 		snprintf(p, ETH_GSTRING_LEN,
+ 			 "port.rx_priority_%u_xon_2_xoff", i);
+ 		p += ETH_GSTRING_LEN;
+ 	}
+ 
+ 	WARN_ONCE(p - data != i40e_get_stats_count(netdev) * ETH_GSTRING_LEN,
+ 		  "stat strings count mismatch!");
+ }
+ 
+ static void i40e_get_priv_flag_strings(struct net_device *netdev, u8 *data)
+ {
+ 	struct i40e_netdev_priv *np = netdev_priv(netdev);
+ 	struct i40e_vsi *vsi = np->vsi;
+ 	struct i40e_pf *pf = vsi->back;
+ 	char *p = (char *)data;
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < I40E_PRIV_FLAGS_STR_LEN; i++) {
+ 		snprintf(p, ETH_GSTRING_LEN, "%s",
+ 			 i40e_gstrings_priv_flags[i].flag_string);
+ 		p += ETH_GSTRING_LEN;
+ 	}
+ 	if (pf->hw.pf_id != 0)
+ 		return;
+ 	for (i = 0; i < I40E_GL_PRIV_FLAGS_STR_LEN; i++) {
+ 		snprintf(p, ETH_GSTRING_LEN, "%s",
+ 			 i40e_gl_gstrings_priv_flags[i].flag_string);
+ 		p += ETH_GSTRING_LEN;
+ 	}
+ }
+ 
++>>>>>>> 9b10df596bd4 (i40e: use WARN_ONCE to replace the commented BUG_ON size check)
  static void i40e_get_strings(struct net_device *netdev, u32 stringset,
  			     u8 *data)
  {
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_ethtool.c
