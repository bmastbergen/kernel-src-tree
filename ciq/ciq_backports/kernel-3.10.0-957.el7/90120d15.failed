usbip: prevent leaking socket pointer address in messages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Shuah Khan <shuahkh@osg.samsung.com>
commit 90120d15f4c397272aaf41077960a157fc4212bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/90120d15.failed

usbip driver is leaking socket pointer address in messages. Remove
the messages that aren't useful and print sockfd in the ones that
are useful for debugging.

	Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
	Cc: stable <stable@vger.kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 90120d15f4c397272aaf41077960a157fc4212bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/usbip/usbip_common.c
diff --cc drivers/usb/usbip/usbip_common.c
index 25b16084ff97,7b219d9109b4..000000000000
--- a/drivers/usb/usbip/usbip_common.c
+++ b/drivers/usb/usbip/usbip_common.c
@@@ -312,43 -313,27 +312,52 @@@ EXPORT_SYMBOL_GPL(usbip_dump_header)
  int usbip_recv(struct socket *sock, void *buf, int size)
  {
  	int result;
 -	struct kvec iov = {.iov_base = buf, .iov_len = size};
 -	struct msghdr msg = {.msg_flags = MSG_NOSIGNAL};
 +	struct msghdr msg;
 +	struct kvec iov;
  	int total = 0;
  
++<<<<<<< HEAD
 +	/* for blocks of if (usbip_dbg_flag_xmit) */
 +	char *bp = buf;
 +	int osize = size;
++=======
+ 	if (!sock || !buf || !size)
+ 		return -EINVAL;
  
- 	usbip_dbg_xmit("enter\n");
+ 	iov_iter_kvec(&msg.msg_iter, READ|ITER_KVEC, &iov, 1, size);
++>>>>>>> 90120d15f4c3 (usbip: prevent leaking socket pointer address in messages)
  
- 	if (!sock || !buf || !size) {
- 		pr_err("invalid arg, sock %p buff %p size %d\n", sock, buf,
- 		       size);
- 		return -EINVAL;
- 	}
+ 	usbip_dbg_xmit("enter\n");
  
  	do {
++<<<<<<< HEAD
++=======
+ 		msg_data_left(&msg);
++>>>>>>> 90120d15f4c3 (usbip: prevent leaking socket pointer address in messages)
  		sock->sk->sk_allocation = GFP_NOIO;
 -
 +		iov.iov_base    = buf;
 +		iov.iov_len     = size;
 +		msg.msg_name    = NULL;
 +		msg.msg_namelen = 0;
 +		msg.msg_control = NULL;
 +		msg.msg_controllen = 0;
 +		msg.msg_flags      = MSG_NOSIGNAL;
 +
++<<<<<<< HEAD
 +		result = kernel_recvmsg(sock, &msg, &iov, 1, size, MSG_WAITALL);
 +		if (result <= 0) {
 +			pr_debug("receive sock %p buf %p size %u ret %d total %d\n",
 +				 sock, buf, size, result, total);
++=======
+ 		result = sock_recvmsg(sock, &msg, MSG_WAITALL);
+ 		if (result <= 0)
++>>>>>>> 90120d15f4c3 (usbip: prevent leaking socket pointer address in messages)
  			goto err;
- 		}
  
 +		size -= result;
 +		buf += result;
  		total += result;
 -	} while (msg_data_left(&msg));
 +	} while (size > 0);
  
  	if (usbip_dbg_flag_xmit) {
  		if (!in_interrupt())
diff --git a/drivers/usb/usbip/stub_dev.c b/drivers/usb/usbip/stub_dev.c
index 11181bb4b119..fd30c62ca217 100644
--- a/drivers/usb/usbip/stub_dev.c
+++ b/drivers/usb/usbip/stub_dev.c
@@ -148,8 +148,7 @@ static void stub_shutdown_connection(struct usbip_device *ud)
 	 * step 1?
 	 */
 	if (ud->tcp_socket) {
-		dev_dbg(&sdev->udev->dev, "shutdown tcp_socket %p\n",
-			ud->tcp_socket);
+		dev_dbg(&sdev->udev->dev, "shutdown sockfd %d\n", ud->sockfd);
 		kernel_sock_shutdown(ud->tcp_socket, SHUT_RDWR);
 	}
 
* Unmerged path drivers/usb/usbip/usbip_common.c
diff --git a/drivers/usb/usbip/vhci_hcd.c b/drivers/usb/usbip/vhci_hcd.c
index dbe084f98bb7..bf529998bbe2 100644
--- a/drivers/usb/usbip/vhci_hcd.c
+++ b/drivers/usb/usbip/vhci_hcd.c
@@ -830,7 +830,7 @@ static void vhci_shutdown_connection(struct usbip_device *ud)
 
 	/* need this? see stub_dev.c */
 	if (ud->tcp_socket) {
-		pr_debug("shutdown tcp_socket %p\n", ud->tcp_socket);
+		pr_debug("shutdown tcp_socket %d\n", ud->sockfd);
 		kernel_sock_shutdown(ud->tcp_socket, SHUT_RDWR);
 	}
 
