scsi: qla2xxx: Enable ATIO interrupt handshake for ISP27XX

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Enable ATIO interrupt handshake for ISP27XX (Himanshu Madhani) [1547714]
Rebuild_FUZZ: 94.55%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit d2b292c3f6fdef5819a276acd64915bae6384a7f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d2b292c3.failed

Enable ATIO Q interrupt handshake for ISP27XX. This patch
coalesce ATIO's interrupts for Quad port ISP27XX adapter.
Interrupt coalesce allows performance to scale for this
specific case.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit d2b292c3f6fdef5819a276acd64915bae6384a7f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 1c8ec70c5535,db6fd3b747ed..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -6548,6 -6574,9 +6548,12 @@@ voi
  qlt_24xx_config_rings(struct scsi_qla_host *vha)
  {
  	struct qla_hw_data *ha = vha->hw;
++<<<<<<< HEAD
++=======
+ 	struct qla_msix_entry *msix = &ha->msix_entries[2];
+ 	struct init_cb_24xx *icb = (struct init_cb_24xx *)ha->init_cb;
+ 
++>>>>>>> d2b292c3f6fd (scsi: qla2xxx: Enable ATIO interrupt handshake for ISP27XX)
  	if (!QLA_TGT_MODE_ENABLED())
  		return;
  
@@@ -6555,14 -6584,28 +6561,39 @@@
  	WRT_REG_DWORD(ISP_ATIO_Q_OUT(vha), 0);
  	RD_REG_DWORD(ISP_ATIO_Q_OUT(vha));
  
++<<<<<<< HEAD
 +	if (IS_ATIO_MSIX_CAPABLE(ha)) {
 +		struct qla_msix_entry *msix = &ha->msix_entries[2];
 +		struct init_cb_24xx *icb = (struct init_cb_24xx *)ha->init_cb;
 +
 +		icb->msix_atio = cpu_to_le16(msix->entry);
 +		ql_dbg(ql_dbg_init, vha, 0xf072,
 +		    "Registering ICB vector 0x%x for atio que.\n",
 +		    msix->entry);
++=======
+ 	if (ha->flags.msix_enabled) {
+ 		if (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {
+ 			if (IS_QLA2071(ha)) {
+ 				/* 4 ports Baker: Enable Interrupt Handshake */
+ 				icb->msix_atio = 0;
+ 				icb->firmware_options_2 |= BIT_26;
+ 			} else {
+ 				icb->msix_atio = cpu_to_le16(msix->entry);
+ 				icb->firmware_options_2 &= ~BIT_26;
+ 			}
+ 			ql_dbg(ql_dbg_init, vha, 0xf072,
+ 			    "Registering ICB vector 0x%x for atio que.\n",
+ 			    msix->entry);
+ 		}
+ 	} else {
+ 		/* INTx|MSI */
+ 		if (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {
+ 			icb->msix_atio = 0;
+ 			icb->firmware_options_2 |= BIT_26;
+ 			ql_dbg(ql_dbg_init, vha, 0xf072,
+ 			    "%s: Use INTx for ATIOQ.\n", __func__);
+ 		}
++>>>>>>> d2b292c3f6fd (scsi: qla2xxx: Enable ATIO interrupt handshake for ISP27XX)
  	}
  }
  
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
