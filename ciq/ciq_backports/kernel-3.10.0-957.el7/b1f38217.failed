ext4: close race between direct IO and ext4_break_layouts()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ross Zwisler <zwisler@kernel.org>
commit b1f382178d150f256c1cf95b9341fda6eb764459
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b1f38217.failed

If the refcount of a page is lowered between the time that it is returned
by dax_busy_page() and when the refcount is again checked in
ext4_break_layouts() => ___wait_var_event(), the waiting function
ext4_wait_dax_page() will never be called.  This means that
ext4_break_layouts() will still have 'retry' set to false, so we'll stop
looping and never check the refcount of other pages in this inode.

Instead, always continue looping as long as dax_layout_busy_page() gives us
a page which it found with an elevated refcount.

	Signed-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: stable@vger.kernel.org
(cherry picked from commit b1f382178d150f256c1cf95b9341fda6eb764459)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/inode.c
diff --cc fs/ext4/inode.c
index 3f826800ae2f,723058bfe43b..000000000000
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@@ -3744,6 -4195,36 +3744,39 @@@ int ext4_update_disksize_before_punch(s
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void ext4_wait_dax_page(struct ext4_inode_info *ei)
+ {
+ 	up_write(&ei->i_mmap_sem);
+ 	schedule();
+ 	down_write(&ei->i_mmap_sem);
+ }
+ 
+ int ext4_break_layouts(struct inode *inode)
+ {
+ 	struct ext4_inode_info *ei = EXT4_I(inode);
+ 	struct page *page;
+ 	int error;
+ 
+ 	if (WARN_ON_ONCE(!rwsem_is_locked(&ei->i_mmap_sem)))
+ 		return -EINVAL;
+ 
+ 	do {
+ 		page = dax_layout_busy_page(inode->i_mapping);
+ 		if (!page)
+ 			return 0;
+ 
+ 		error = ___wait_var_event(&page->_refcount,
+ 				atomic_read(&page->_refcount) == 1,
+ 				TASK_INTERRUPTIBLE, 0, 0,
+ 				ext4_wait_dax_page(ei));
+ 	} while (error == 0);
+ 
+ 	return error;
+ }
+ 
++>>>>>>> b1f382178d15 (ext4: close race between direct IO and ext4_break_layouts())
  /*
   * ext4_punch_hole: punches a hole in a file by releasing the blocks
   * associated with the given offset and length
* Unmerged path fs/ext4/inode.c
