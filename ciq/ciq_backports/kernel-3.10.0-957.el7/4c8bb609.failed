net: aquantia: Limit number of MSIX irqs to the number of cpus

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] aquantia: Limit number of MSIX irqs to the number of cpus (David Arcari) [1546765]
Rebuild_FUZZ: 95.80%
commit-author Igor Russkikh <igor.russkikh@aquantia.com>
commit 4c8bb609d304df72858aa2e5e74abab5246bd24b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4c8bb609.failed

There is no much practical use from having MSIX vectors more that number
of cpus, thus cap this first with preconfigured limit, then with number
of cpus online.

	Signed-off-by: Pavel Belous <pavel.belous@aquantia.com>
	Signed-off-by: Igor Russkikh <igor.russkikh@aquantia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4c8bb609d304df72858aa2e5e74abab5246bd24b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
index 8d0ab10e2c90,727f0a446ef1..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
@@@ -88,7 -85,7 +88,11 @@@ int aq_pci_func_init(struct aq_pci_func
  	int err = 0;
  	unsigned int bar = 0U;
  	unsigned int port = 0U;
++<<<<<<< HEAD
 +	unsigned int i = 0U;
++=======
+ 	unsigned int numvecs = 0U;
++>>>>>>> 4c8bb609d304 (net: aquantia: Limit number of MSIX irqs to the number of cpus)
  
  	err = pci_enable_device(self->pdev);
  	if (err < 0)
@@@ -146,29 -143,20 +150,38 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	for (i = 0; i < self->aq_hw_caps.msix_irqs; i++)
 +		self->msix_entry[i].entry = i;
++=======
+ 	numvecs = min((u8)AQ_CFG_VECS_DEF, self->aq_hw_caps.msix_irqs);
+ 	numvecs = min(numvecs, num_online_cpus());
+ 
+ 	/* enable interrupts */
+ #if !AQ_CFG_FORCE_LEGACY_INT
+ 	err = pci_alloc_irq_vectors(self->pdev, numvecs, numvecs, PCI_IRQ_MSIX);
++>>>>>>> 4c8bb609d304 (net: aquantia: Limit number of MSIX irqs to the number of cpus)
  
 -	if (err < 0) {
 -		err = pci_alloc_irq_vectors(self->pdev, 1, 1,
 -				PCI_IRQ_MSI | PCI_IRQ_LEGACY);
 -		if (err < 0)
 -			goto err_exit;
 +	/*enable interrupts */
 +#if AQ_CFG_FORCE_LEGACY_INT
 +	self->irq_type = AQ_HW_IRQ_LEGACY;
 +#else
 +	err = pci_enable_msix(self->pdev, self->msix_entry,
 +			      self->aq_hw_caps.msix_irqs);
 +
 +	if (err >= 0) {
 +		self->irq_type = AQ_HW_IRQ_MSIX;
 +	} else {
 +		err = pci_enable_msi(self->pdev);
 +
 +		if (err >= 0) {
 +			self->irq_type = AQ_HW_IRQ_MSI;
 +		} else {
 +			self->irq_type = AQ_HW_IRQ_LEGACY;
 +			err = 0;
 +		}
  	}
- #endif
+ #endif /* AQ_CFG_FORCE_LEGACY_INT */
  
  	/* net device init */
  	for (port = 0; port < self->ports; ++port) {
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
