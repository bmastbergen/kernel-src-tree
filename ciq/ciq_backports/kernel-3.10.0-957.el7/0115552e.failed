nfp: remove false positive offloads in flower vxlan

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author John Hurley <john.hurley@netronome.com>
commit 0115552eac14a2d6db66da5f26bd67d0f2a5d79b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0115552e.failed

Pass information to the match offload on whether or not the repr is the
ingress or egress dev. Only accept tunnel matches if repr is the egress
dev.

This means rules such as the following are successfully offloaded:
tc .. add dev vxlan0 .. enc_dst_port 4789 .. action redirect dev nfp_p0

While rules such as the following are rejected:
tc .. add dev nfp_p0 .. enc_dst_port 4789 .. action redirect dev vxlan0

Also reject non tunnel flows that are offloaded to an egress dev.
Non tunnel matches assume that the offload dev is the ingress port and
offload a match accordingly.

Fixes: 611aec101ab7 ("nfp: compile flower vxlan tunnel metadata match fields")
	Signed-off-by: John Hurley <john.hurley@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0115552eac14a2d6db66da5f26bd67d0f2a5d79b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/flower/offload.c
diff --cc drivers/net/ethernet/netronome/nfp/flower/offload.c
index 0e039508dc42,f5d73b83dcc2..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/offload.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/offload.c
@@@ -449,11 -454,15 +456,11 @@@ nfp_flower_get_stats(struct nfp_app *ap
  
  static int
  nfp_flower_repr_offload(struct nfp_app *app, struct net_device *netdev,
- 			struct tc_cls_flower_offload *flower)
+ 			struct tc_cls_flower_offload *flower, bool egress)
  {
 -	if (!eth_proto_is_802_3(flower->common.protocol) ||
 -	    flower->common.chain_index)
 -		return -EOPNOTSUPP;
 -
  	switch (flower->command) {
  	case TC_CLSFLOWER_REPLACE:
- 		return nfp_flower_add_offload(app, netdev, flower);
+ 		return nfp_flower_add_offload(app, netdev, flower, egress);
  	case TC_CLSFLOWER_DESTROY:
  		return nfp_flower_del_offload(app, netdev, flower);
  	case TC_CLSFLOWER_STATS:
@@@ -463,6 -472,63 +470,66 @@@
  	return -EOPNOTSUPP;
  }
  
++<<<<<<< HEAD
++=======
+ int nfp_flower_setup_tc_egress_cb(enum tc_setup_type type, void *type_data,
+ 				  void *cb_priv)
+ {
+ 	struct nfp_repr *repr = cb_priv;
+ 
+ 	if (!tc_can_offload(repr->netdev))
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (type) {
+ 	case TC_SETUP_CLSFLOWER:
+ 		return nfp_flower_repr_offload(repr->app, repr->netdev,
+ 					       type_data, true);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int nfp_flower_setup_tc_block_cb(enum tc_setup_type type,
+ 					void *type_data, void *cb_priv)
+ {
+ 	struct nfp_repr *repr = cb_priv;
+ 
+ 	if (!tc_can_offload(repr->netdev))
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (type) {
+ 	case TC_SETUP_CLSFLOWER:
+ 		return nfp_flower_repr_offload(repr->app, repr->netdev,
+ 					       type_data, false);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int nfp_flower_setup_tc_block(struct net_device *netdev,
+ 				     struct tc_block_offload *f)
+ {
+ 	struct nfp_repr *repr = netdev_priv(netdev);
+ 
+ 	if (f->binder_type != TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (f->command) {
+ 	case TC_BLOCK_BIND:
+ 		return tcf_block_cb_register(f->block,
+ 					     nfp_flower_setup_tc_block_cb,
+ 					     repr, repr);
+ 	case TC_BLOCK_UNBIND:
+ 		tcf_block_cb_unregister(f->block,
+ 					nfp_flower_setup_tc_block_cb,
+ 					repr);
+ 		return 0;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
++>>>>>>> 0115552eac14 (nfp: remove false positive offloads in flower vxlan)
  int nfp_flower_setup_tc(struct nfp_app *app, struct net_device *netdev,
  			enum tc_setup_type type, void *type_data)
  {
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/offload.c
