net: aquantia: Cleanup pci functions module

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] aquantia: Cleanup pci functions module (David Arcari) [1546765]
Rebuild_FUZZ: 93.83%
commit-author Igor Russkikh <igor.russkikh@aquantia.com>
commit 23ee07ad3c2fd5adf6e9ef21afb9aec489dc3b4e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/23ee07ad.failed

Driver contained a dead code of maintaining multiple pci port instances.
That will never be used since for each pci function a separate NIC
instance is created.
Simplify this, making pci module only responsible for pci resource
management.
NIC initialization is also simplified accordingly.

	Signed-off-by: Igor Russkikh <igor.russkikh@aquantia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 23ee07ad3c2fd5adf6e9ef21afb9aec489dc3b4e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_nic.c
#	drivers/net/ethernet/aquantia/atlantic/aq_nic.h
#	drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
#	drivers/net/ethernet/aquantia/atlantic/aq_pci_func.h
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_nic.c
index 30b3edb5d728,c5450b9887ac..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
@@@ -14,7 -14,6 +14,10 @@@
  #include "aq_vec.h"
  #include "aq_hw.h"
  #include "aq_pci_func.h"
++<<<<<<< HEAD
 +#include "aq_nic_internal.h"
++=======
++>>>>>>> 23ee07ad3c2f (net: aquantia: Cleanup pci functions module)
  
  #include <linux/moduleparam.h>
  #include <linux/netdevice.h>
@@@ -66,14 -65,8 +69,14 @@@ void aq_nic_cfg_start(struct aq_nic_s *
  {
  	struct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;
  
++<<<<<<< HEAD
 +	cfg->aq_hw_caps = &self->aq_hw_caps;
 +
 +	cfg->vecs = AQ_CFG_VECS_DEF;
++=======
++>>>>>>> 23ee07ad3c2f (net: aquantia: Cleanup pci functions module)
  	cfg->tcs = AQ_CFG_TCS_DEF;
  
- 	cfg->rxds = AQ_CFG_RXDS_DEF;
- 	cfg->txds = AQ_CFG_TXDS_DEF;
- 
  	cfg->is_polling = AQ_CFG_IS_POLLING_DEF;
  
  	cfg->itr = aq_itr;
@@@ -120,18 -107,17 +117,23 @@@
  
  	cfg->num_rss_queues = min(cfg->vecs, AQ_CFG_NUM_RSS_QUEUES_DEF);
  
- 	cfg->irq_type = aq_pci_func_get_irq_type(self->aq_pci_func);
+ 	cfg->irq_type = aq_pci_func_get_irq_type(self);
  
  	if ((cfg->irq_type == AQ_HW_IRQ_LEGACY) ||
 -	    (cfg->aq_hw_caps->vecs == 1U) ||
 +	    (self->aq_hw_caps.vecs == 1U) ||
  	    (cfg->vecs == 1U)) {
  		cfg->is_rss = 0U;
  		cfg->vecs = 1U;
  	}
  
++<<<<<<< HEAD
 +	cfg->link_speed_msk &= self->aq_hw_caps.link_speed_msk;
 +	cfg->hw_features = self->aq_hw_caps.hw_features;
 +	return 0;
++=======
+ 	cfg->link_speed_msk &= cfg->aq_hw_caps->link_speed_msk;
+ 	cfg->hw_features = cfg->aq_hw_caps->hw_features;
++>>>>>>> 23ee07ad3c2f (net: aquantia: Cleanup pci functions module)
  }
  
  static int aq_nic_update_link_status(struct aq_nic_s *self)
@@@ -205,61 -191,6 +207,64 @@@ static void aq_nic_polling_timer_cb(uns
  		AQ_CFG_POLLING_TIMER_INTERVAL);
  }
  
++<<<<<<< HEAD
 +static struct net_device *aq_nic_ndev_alloc(void)
 +{
 +	return alloc_etherdev_mq(sizeof(struct aq_nic_s), AQ_CFG_VECS_MAX);
 +}
 +
 +struct aq_nic_s *aq_nic_alloc_cold(const struct net_device_ops *ndev_ops,
 +				   const struct ethtool_ops *et_ops,
 +				   struct pci_dev *pdev,
 +				   struct aq_pci_func_s *aq_pci_func,
 +				   unsigned int port,
 +				   const struct aq_hw_ops *aq_hw_ops)
 +{
 +	struct net_device *ndev = NULL;
 +	struct aq_nic_s *self = NULL;
 +	int err = 0;
 +
 +	ndev = aq_nic_ndev_alloc();
 +	if (!ndev) {
 +		err = -ENOMEM;
 +		goto err_exit;
 +	}
 +
 +	self = netdev_priv(ndev);
 +
 +	ndev->netdev_ops = ndev_ops;
 +	ndev->ethtool_ops = et_ops;
 +
 +	SET_NETDEV_DEV(ndev, &pdev->dev);
 +
 +	ndev->if_port = port;
 +	self->ndev = ndev;
 +
 +	self->aq_pci_func = aq_pci_func;
 +
 +	self->aq_hw_ops = *aq_hw_ops;
 +	self->port = (u8)port;
 +
 +	self->aq_hw = self->aq_hw_ops.create(aq_pci_func, self->port);
 +	self->aq_hw->aq_nic_cfg = &self->aq_nic_cfg;
 +
 +	err = self->aq_hw_ops.get_hw_caps(self->aq_hw, &self->aq_hw_caps,
 +					  pdev->device, pdev->subsystem_device);
 +	if (err < 0)
 +		goto err_exit;
 +
 +	aq_nic_cfg_init_defaults(self);
 +
 +err_exit:
 +	if (err < 0) {
 +		aq_nic_free_hot_resources(self);
 +		self = NULL;
 +	}
 +	return self;
 +}
 +
++=======
++>>>>>>> 23ee07ad3c2f (net: aquantia: Cleanup pci functions module)
  int aq_nic_ndev_register(struct aq_nic_s *self)
  {
  	int err = 0;
@@@ -268,9 -199,10 +273,14 @@@
  		err = -EINVAL;
  		goto err_exit;
  	}
++<<<<<<< HEAD
 +	err = self->aq_hw_ops.hw_get_mac_permanent(self->aq_hw,
++=======
+ 
+ 	err = self->aq_hw_ops->hw_get_mac_permanent(self->aq_hw,
++>>>>>>> 23ee07ad3c2f (net: aquantia: Cleanup pci functions module)
  			    self->ndev->dev_addr);
- 	if (err < 0)
+ 	if (err)
  		goto err_exit;
  
  #if defined(AQ_CFG_MAC_ADDR_PERMANENT)
@@@ -302,63 -244,8 +322,66 @@@ void aq_nic_ndev_init(struct aq_nic_s *
  	self->ndev->features = aq_hw_caps->hw_features;
  	self->ndev->priv_flags = aq_hw_caps->hw_priv_flags;
  	self->ndev->mtu = aq_nic_cfg->mtu - ETH_HLEN;
 -	self->ndev->max_mtu = aq_hw_caps->mtu - ETH_FCS_LEN - ETH_HLEN;
 +	self->ndev->extended->max_mtu = self->aq_hw_caps.mtu - ETH_FCS_LEN -
 +		ETH_HLEN;
 +
++<<<<<<< HEAD
 +	return 0;
 +}
 +
 +void aq_nic_ndev_free(struct aq_nic_s *self)
 +{
 +	if (!self->ndev)
 +		goto err_exit;
 +
 +	if (self->ndev->reg_state == NETREG_REGISTERED)
 +		unregister_netdev(self->ndev);
 +
 +	if (self->aq_hw)
 +		self->aq_hw_ops.destroy(self->aq_hw);
 +
 +	free_netdev(self->ndev);
  
 +err_exit:;
 +}
 +
 +struct aq_nic_s *aq_nic_alloc_hot(struct net_device *ndev)
 +{
 +	struct aq_nic_s *self = NULL;
 +	int err = 0;
 +
 +	if (!ndev) {
 +		err = -EINVAL;
 +		goto err_exit;
 +	}
 +	self = netdev_priv(ndev);
 +
 +	if (!self) {
 +		err = -EINVAL;
 +		goto err_exit;
 +	}
 +	if (netif_running(ndev))
 +		netif_tx_disable(ndev);
 +	netif_carrier_off(self->ndev);
 +
 +	for (self->aq_vecs = 0; self->aq_vecs < self->aq_nic_cfg.vecs;
 +		self->aq_vecs++) {
 +		self->aq_vec[self->aq_vecs] =
 +		    aq_vec_alloc(self, self->aq_vecs, &self->aq_nic_cfg);
 +		if (!self->aq_vec[self->aq_vecs]) {
 +			err = -ENOMEM;
 +			goto err_exit;
 +		}
 +	}
 +
 +err_exit:
 +	if (err < 0) {
 +		aq_nic_free_hot_resources(self);
 +		self = NULL;
 +	}
 +	return self;
++=======
++>>>>>>> 23ee07ad3c2f (net: aquantia: Cleanup pci functions module)
  }
  
  void aq_nic_set_tx_ring(struct aq_nic_s *self, unsigned int idx,
@@@ -388,15 -270,17 +411,22 @@@ int aq_nic_init(struct aq_nic_s *self
  	if (err < 0)
  		goto err_exit;
  
++<<<<<<< HEAD
 +	err = self->aq_hw_ops.hw_init(self->aq_hw,
 +			    aq_nic_get_ndev(self)->dev_addr);
++=======
+ 	err = self->aq_hw_ops->hw_init(self->aq_hw,
+ 				       aq_nic_get_ndev(self)->dev_addr);
++>>>>>>> 23ee07ad3c2f (net: aquantia: Cleanup pci functions module)
  	if (err < 0)
  		goto err_exit;
  
  	for (i = 0U, aq_vec = self->aq_vec[0];
  		self->aq_vecs > i; ++i, aq_vec = self->aq_vec[i])
 -		aq_vec_init(aq_vec, self->aq_hw_ops, self->aq_hw);
 +		aq_vec_init(aq_vec, &self->aq_hw_ops, self->aq_hw);
  
+ 	netif_carrier_off(self->ndev);
+ 
  err_exit:
  	return err;
  }
@@@ -637,9 -519,8 +667,14 @@@ int aq_nic_xmit(struct aq_nic_s *self, 
  	frags = aq_nic_map_skb(self, skb, ring);
  
  	if (likely(frags)) {
++<<<<<<< HEAD
 +		err = self->aq_hw_ops.hw_ring_tx_xmit(self->aq_hw,
 +						      ring,
 +						      frags);
++=======
+ 		err = self->aq_hw_ops->hw_ring_tx_xmit(self->aq_hw,
+ 						       ring, frags);
++>>>>>>> 23ee07ad3c2f (net: aquantia: Cleanup pci functions module)
  		if (err >= 0) {
  			++ring->stats.tx.packets;
  			ring->stats.tx.bytes += skb->len;
@@@ -693,11 -574,11 +728,17 @@@ int aq_nic_set_multicast_list(struct aq
  		 * multicast mask
  		 */
  		self->packet_filter |= IFF_ALLMULTI;
++<<<<<<< HEAD
 +		self->aq_hw->aq_nic_cfg->mc_list_count = 0;
 +		return self->aq_hw_ops.hw_packet_filter_set(self->aq_hw,
 +							self->packet_filter);
++=======
+ 		self->aq_nic_cfg.mc_list_count = 0;
+ 		return self->aq_hw_ops->hw_packet_filter_set(self->aq_hw,
+ 							     self->packet_filter);
++>>>>>>> 23ee07ad3c2f (net: aquantia: Cleanup pci functions module)
  	} else {
 -		return self->aq_hw_ops->hw_multicast_list_set(self->aq_hw,
 +		return self->aq_hw_ops.hw_multicast_list_set(self->aq_hw,
  						    self->mc_list.ar,
  						    self->mc_list.count);
  	}
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_nic.h
index 715b53c689ef,a85b08a34ed4..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
@@@ -17,21 -17,9 +17,20 @@@
  #include "aq_hw.h"
  
  struct aq_ring_s;
- struct aq_pci_func_s;
  struct aq_hw_ops;
 -struct aq_fw_s;
 -struct aq_vec_s;
 +
 +#define AQ_NIC_FC_OFF    0U
 +#define AQ_NIC_FC_TX     1U
 +#define AQ_NIC_FC_RX     2U
 +#define AQ_NIC_FC_FULL   3U
 +#define AQ_NIC_FC_AUTO   4U
 +
 +#define AQ_NIC_RATE_10G        BIT(0)
 +#define AQ_NIC_RATE_5G         BIT(1)
 +#define AQ_NIC_RATE_5GSR       BIT(2)
 +#define AQ_NIC_RATE_2GS        BIT(3)
 +#define AQ_NIC_RATE_1G         BIT(4)
 +#define AQ_NIC_RATE_100M       BIT(5)
  
  struct aq_nic_cfg_s {
  	const struct aq_hw_caps_s *aq_hw_caps;
@@@ -70,13 -57,36 +69,46 @@@
  #define AQ_NIC_TCVEC2RING(_NIC_, _TC_, _VEC_) \
  	((_TC_) * AQ_CFG_TCS_MAX + (_VEC_))
  
++<<<<<<< HEAD
 +struct aq_nic_s *aq_nic_alloc_cold(const struct net_device_ops *ndev_ops,
 +				   const struct ethtool_ops *et_ops,
 +				   struct pci_dev *pdev,
 +				   struct aq_pci_func_s *aq_pci_func,
 +				   unsigned int port,
 +				   const struct aq_hw_ops *aq_hw_ops);
 +int aq_nic_ndev_init(struct aq_nic_s *self);
++=======
+ struct aq_nic_s {
+ 	atomic_t flags;
+ 	struct aq_vec_s *aq_vec[AQ_CFG_VECS_MAX];
+ 	struct aq_ring_s *aq_ring_tx[AQ_CFG_VECS_MAX * AQ_CFG_TCS_MAX];
+ 	struct aq_hw_s *aq_hw;
+ 	struct net_device *ndev;
+ 	unsigned int aq_vecs;
+ 	unsigned int packet_filter;
+ 	unsigned int power_state;
+ 	u8 port;
+ 	const struct aq_hw_ops *aq_hw_ops;
+ 	struct aq_nic_cfg_s aq_nic_cfg;
+ 	struct timer_list service_timer;
+ 	struct timer_list polling_timer;
+ 	struct aq_hw_link_status_s link_status;
+ 	struct {
+ 		u32 count;
+ 		u8 ar[AQ_CFG_MULTICAST_ADDRESS_MAX][ETH_ALEN];
+ 	} mc_list;
+ 
+ 	struct pci_dev *pdev;
+ 	unsigned int msix_entry_mask;
+ };
+ 
+ static inline struct device *aq_nic_get_dev(struct aq_nic_s *self)
+ {
+ 	return self->ndev->dev.parent;
+ }
+ 
+ void aq_nic_ndev_init(struct aq_nic_s *self);
++>>>>>>> 23ee07ad3c2f (net: aquantia: Cleanup pci functions module)
  struct aq_nic_s *aq_nic_alloc_hot(struct net_device *ndev);
  void aq_nic_set_tx_ring(struct aq_nic_s *self, unsigned int idx,
  			struct aq_ring_s *ring);
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
index 667e08a571a5,f5dd5f75a40f..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
@@@ -9,104 -9,116 +9,199 @@@
  
  /* File aq_pci_func.c: Definition of PCI functions. */
  
++<<<<<<< HEAD
 +#include "aq_pci_func.h"
 +#include "aq_nic.h"
 +#include "aq_vec.h"
 +#include "aq_hw.h"
 +#include <linux/interrupt.h>
 +
 +struct aq_pci_func_s {
 +	struct pci_dev *pdev;
 +	struct aq_nic_s *port[AQ_CFG_PCI_FUNC_PORTS];
 +	void __iomem *mmio;
 +	void *aq_vec[AQ_CFG_PCI_FUNC_MSIX_IRQS];
 +	resource_size_t mmio_pa;
 +	unsigned int msix_entry_mask;
 +	unsigned int irq_type;
 +	unsigned int ports;
 +	bool is_pci_enabled;
 +	bool is_regions;
 +	bool is_pci_using_dac;
 +	struct aq_hw_caps_s aq_hw_caps;
 +	struct msix_entry msix_entry[AQ_CFG_PCI_FUNC_MSIX_IRQS];
 +};
 +
 +struct aq_pci_func_s *aq_pci_func_alloc(const struct aq_hw_ops *aq_hw_ops,
 +					struct pci_dev *pdev,
 +					const struct net_device_ops *ndev_ops,
 +					const struct ethtool_ops *eth_ops)
 +{
 +	struct aq_pci_func_s *self = NULL;
 +	int err = 0;
 +	unsigned int port = 0U;
 +
 +	if (!aq_hw_ops) {
 +		err = -EFAULT;
 +		goto err_exit;
 +	}
 +	self = kzalloc(sizeof(*self), GFP_KERNEL);
 +	if (!self) {
 +		err = -ENOMEM;
 +		goto err_exit;
 +	}
 +
 +	pci_set_drvdata(pdev, self);
 +	self->pdev = pdev;
 +
 +	err = aq_hw_ops->get_hw_caps(NULL, &self->aq_hw_caps, pdev->device,
 +				     pdev->subsystem_device);
 +	if (err < 0)
 +		goto err_exit;
 +
 +	self->ports = self->aq_hw_caps.ports;
 +
 +	for (port = 0; port < self->ports; ++port) {
 +		struct aq_nic_s *aq_nic = aq_nic_alloc_cold(ndev_ops, eth_ops,
 +							    pdev, self,
 +							    port, aq_hw_ops);
 +
 +		if (!aq_nic) {
 +			err = -ENOMEM;
 +			goto err_exit;
 +		}
 +		self->port[port] = aq_nic;
 +	}
 +
 +err_exit:
 +	if (err < 0) {
 +		if (self)
 +			aq_pci_func_free(self);
 +		self = NULL;
 +	}
 +
 +	(void)err;
 +	return self;
 +}
 +
 +int aq_pci_func_init(struct aq_pci_func_s *self)
 +{
 +	int err = 0;
 +	unsigned int bar = 0U;
 +	unsigned int port = 0U;
 +	unsigned int i = 0U;
++=======
+ #include <linux/interrupt.h>
+ #include <linux/module.h>
  
- 	err = pci_enable_device(self->pdev);
- 	if (err < 0)
- 		goto err_exit;
+ #include "aq_main.h"
+ #include "aq_nic.h"
+ #include "aq_vec.h"
+ #include "aq_hw.h"
+ #include "aq_pci_func.h"
+ #include "hw_atl/hw_atl_a0.h"
+ #include "hw_atl/hw_atl_b0.h"
+ 
+ static const struct pci_device_id aq_pci_tbl[] = {
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_0001), },
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_D100), },
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_D107), },
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_D108), },
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_D109), },
+ 
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC100), },
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC107), },
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC108), },
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC109), },
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC111), },
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC112), },
+ 
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC100S), },
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC107S), },
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC108S), },
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC109S), },
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC111S), },
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC112S), },
+ 
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC111E), },
+ 	{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC112E), },
+ 
+ 	{}
+ };
+ 
+ const struct aq_board_revision_s hw_atl_boards[] = {
+ 	{ AQ_DEVICE_ID_0001,	AQ_HWREV_1,	&hw_atl_ops_a0, &hw_atl_a0_caps_aqc107, },
+ 	{ AQ_DEVICE_ID_D100,	AQ_HWREV_1,	&hw_atl_ops_a0, &hw_atl_a0_caps_aqc100, },
+ 	{ AQ_DEVICE_ID_D107,	AQ_HWREV_1,	&hw_atl_ops_a0, &hw_atl_a0_caps_aqc107, },
+ 	{ AQ_DEVICE_ID_D108,	AQ_HWREV_1,	&hw_atl_ops_a0, &hw_atl_a0_caps_aqc108, },
+ 	{ AQ_DEVICE_ID_D109,	AQ_HWREV_1,	&hw_atl_ops_a0, &hw_atl_a0_caps_aqc109, },
+ 
+ 	{ AQ_DEVICE_ID_0001,	AQ_HWREV_2,	&hw_atl_ops_b0, &hw_atl_b0_caps_aqc107, },
+ 	{ AQ_DEVICE_ID_D100,	AQ_HWREV_2,	&hw_atl_ops_b0, &hw_atl_b0_caps_aqc100, },
+ 	{ AQ_DEVICE_ID_D107,	AQ_HWREV_2,	&hw_atl_ops_b0, &hw_atl_b0_caps_aqc107, },
+ 	{ AQ_DEVICE_ID_D108,	AQ_HWREV_2,	&hw_atl_ops_b0, &hw_atl_b0_caps_aqc108, },
+ 	{ AQ_DEVICE_ID_D109,	AQ_HWREV_2,	&hw_atl_ops_b0, &hw_atl_b0_caps_aqc109, },
+ 
+ 	{ AQ_DEVICE_ID_AQC100,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc107, },
+ 	{ AQ_DEVICE_ID_AQC107,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc107, },
+ 	{ AQ_DEVICE_ID_AQC108,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc108, },
+ 	{ AQ_DEVICE_ID_AQC109,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc109, },
+ 	{ AQ_DEVICE_ID_AQC111,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc111, },
+ 	{ AQ_DEVICE_ID_AQC112,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc112, },
+ 
+ 	{ AQ_DEVICE_ID_AQC100S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc100s, },
+ 	{ AQ_DEVICE_ID_AQC107S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc107s, },
+ 	{ AQ_DEVICE_ID_AQC108S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc108s, },
+ 	{ AQ_DEVICE_ID_AQC109S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc109s, },
+ 	{ AQ_DEVICE_ID_AQC111S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc111s, },
+ 	{ AQ_DEVICE_ID_AQC112S,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc112s, },
+ 
+ 	{ AQ_DEVICE_ID_AQC111E,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc111e, },
+ 	{ AQ_DEVICE_ID_AQC112E,	AQ_HWREV_ANY,	&hw_atl_ops_b1, &hw_atl_b0_caps_aqc112e, },
+ };
+ 
+ MODULE_DEVICE_TABLE(pci, aq_pci_tbl);
  
- 	self->is_pci_enabled = true;
+ static int aq_pci_probe_get_hw_by_id(struct pci_dev *pdev,
+ 				     const struct aq_hw_ops **ops,
+ 				     const struct aq_hw_caps_s **caps)
+ {
+ 	int i = 0;
+ 
+ 	if (pdev->vendor != PCI_VENDOR_ID_AQUANTIA)
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(hw_atl_boards); i++) {
+ 		if (hw_atl_boards[i].devid == pdev->device &&
+ 		    (hw_atl_boards[i].revision == AQ_HWREV_ANY ||
+ 		     hw_atl_boards[i].revision == pdev->revision)) {
+ 			*ops = hw_atl_boards[i].ops;
+ 			*caps = hw_atl_boards[i].caps;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (i == ARRAY_SIZE(hw_atl_boards))
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ int aq_pci_func_init(struct pci_dev *pdev)
+ {
+ 	int err = 0;
++>>>>>>> 23ee07ad3c2f (net: aquantia: Cleanup pci functions module)
  
- 	err = pci_set_dma_mask(self->pdev, DMA_BIT_MASK(64));
+ 	err = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));
  	if (!err) {
- 		err = pci_set_consistent_dma_mask(self->pdev, DMA_BIT_MASK(64));
- 		self->is_pci_using_dac = 1;
+ 		err = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));
+ 
  	}
  	if (err) {
- 		err = pci_set_dma_mask(self->pdev, DMA_BIT_MASK(32));
+ 		err = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
  		if (!err)
- 			err = pci_set_consistent_dma_mask(self->pdev,
+ 			err = pci_set_consistent_dma_mask(pdev,
  							  DMA_BIT_MASK(32));
- 		self->is_pci_using_dac = 0;
  	}
  	if (err != 0) {
  		err = -ENOSR;
@@@ -117,122 -129,41 +212,123 @@@
  	if (err < 0)
  		goto err_exit;
  
- 	self->is_regions = true;
+ 	pci_set_master(pdev);
  
++<<<<<<< HEAD
 +	pci_set_master(self->pdev);
 +
 +	for (bar = 0; bar < 4; ++bar) {
 +		if (IORESOURCE_MEM & pci_resource_flags(self->pdev, bar)) {
 +			resource_size_t reg_sz;
 +
 +			self->mmio_pa = pci_resource_start(self->pdev, bar);
 +			if (self->mmio_pa == 0U) {
 +				err = -EIO;
 +				goto err_exit;
 +			}
 +
 +			reg_sz = pci_resource_len(self->pdev, bar);
 +			if ((reg_sz <= 24 /*ATL_REGS_SIZE*/)) {
 +				err = -EIO;
 +				goto err_exit;
 +			}
 +
 +			self->mmio = ioremap_nocache(self->mmio_pa, reg_sz);
 +			if (!self->mmio) {
 +				err = -EIO;
 +				goto err_exit;
 +			}
 +			break;
 +		}
 +	}
 +
 +	for (i = 0; i < self->aq_hw_caps.msix_irqs; i++)
 +		self->msix_entry[i].entry = i;
 +
 +	/*enable interrupts */
 +#if AQ_CFG_FORCE_LEGACY_INT
 +	self->irq_type = AQ_HW_IRQ_LEGACY;
 +#else
 +	err = pci_enable_msix(self->pdev, self->msix_entry,
 +			      self->aq_hw_caps.msix_irqs);
 +
 +	if (err >= 0) {
 +		self->irq_type = AQ_HW_IRQ_MSIX;
 +	} else {
 +		err = pci_enable_msi(self->pdev);
 +
 +		if (err >= 0) {
 +			self->irq_type = AQ_HW_IRQ_MSI;
 +		} else {
 +			self->irq_type = AQ_HW_IRQ_LEGACY;
 +			err = 0;
 +		}
 +	}
 +#endif
 +
 +	/* net device init */
 +	for (port = 0; port < self->ports; ++port) {
 +		if (!self->port[port])
 +			continue;
 +
 +		err = aq_nic_cfg_start(self->port[port]);
 +		if (err < 0)
 +			goto err_exit;
 +
 +		err = aq_nic_ndev_init(self->port[port]);
 +		if (err < 0)
 +			goto err_exit;
 +
 +		err = aq_nic_ndev_register(self->port[port]);
 +		if (err < 0)
 +			goto err_exit;
 +	}
++=======
+ 	return 0;
++>>>>>>> 23ee07ad3c2f (net: aquantia: Cleanup pci functions module)
  
  err_exit:
- 	if (err < 0)
- 		aq_pci_func_deinit(self);
  	return err;
  }
  
- int aq_pci_func_alloc_irq(struct aq_pci_func_s *self, unsigned int i,
+ int aq_pci_func_alloc_irq(struct aq_nic_s *self, unsigned int i,
  			  char *name, void *aq_vec, cpumask_t *affinity_mask)
  {
 -	struct pci_dev *pdev = self->pdev;
  	int err = 0;
  
 -	if (pdev->msix_enabled || pdev->msi_enabled)
 -		err = request_irq(pci_irq_vector(pdev, i), aq_vec_isr, 0,
 +	switch (self->irq_type) {
 +	case AQ_HW_IRQ_MSIX:
 +		err = request_irq(self->msix_entry[i].vector, aq_vec_isr, 0,
  				  name, aq_vec);
 -	else
 -		err = request_irq(pci_irq_vector(pdev, i), aq_vec_isr_legacy,
 +		break;
 +
 +	case AQ_HW_IRQ_MSI:
 +		err = request_irq(self->pdev->irq, aq_vec_isr, 0, name, aq_vec);
 +		break;
 +
 +	case AQ_HW_IRQ_LEGACY:
 +		err = request_irq(self->pdev->irq, aq_vec_isr_legacy,
  				  IRQF_SHARED, name, aq_vec);
 +		break;
 +
 +	default:
 +		err = -EFAULT;
 +		break;
 +	}
  
  	if (err >= 0) {
  		self->msix_entry_mask |= (1 << i);
  		self->aq_vec[i] = aq_vec;
  
 -		if (pdev->msix_enabled)
 -			irq_set_affinity_hint(pci_irq_vector(pdev, i),
 +		if (self->irq_type == AQ_HW_IRQ_MSIX)
 +			irq_set_affinity_hint(self->msix_entry[i].vector,
  					      affinity_mask);
  	}
- 
  	return err;
  }
  
- void aq_pci_func_free_irqs(struct aq_pci_func_s *self)
+ void aq_pci_func_free_irqs(struct aq_nic_s *self)
  {
 -	struct pci_dev *pdev = self->pdev;
  	unsigned int i = 0U;
  
  	for (i = 32U; i--;) {
@@@ -261,87 -177,166 +357,237 @@@
  	}
  }
  
- void __iomem *aq_pci_func_get_mmio(struct aq_pci_func_s *self)
- {
- 	return self->mmio;
- }
- 
- unsigned int aq_pci_func_get_irq_type(struct aq_pci_func_s *self)
+ unsigned int aq_pci_func_get_irq_type(struct aq_nic_s *self)
  {
 -	if (self->pdev->msix_enabled)
 -		return AQ_HW_IRQ_MSIX;
 -	if (self->pdev->msi_enabled)
 -		return AQ_HW_IRQ_MSIX;
 -	return AQ_HW_IRQ_LEGACY;
 +	return self->irq_type;
  }
  
- void aq_pci_func_deinit(struct aq_pci_func_s *self)
+ static void aq_pci_free_irq_vectors(struct aq_nic_s *self)
  {
++<<<<<<< HEAD
 +	if (!self)
 +		goto err_exit;
 +
 +	aq_pci_func_free_irqs(self);
 +
 +	switch (self->irq_type) {
 +	case AQ_HW_IRQ_MSI:
 +		pci_disable_msi(self->pdev);
 +		break;
 +
 +	case AQ_HW_IRQ_MSIX:
 +		pci_disable_msix(self->pdev);
 +		break;
 +
 +	case AQ_HW_IRQ_LEGACY:
 +		break;
 +
 +	default:
 +		break;
 +	}
 +
 +	if (self->is_regions)
 +		pci_release_regions(self->pdev);
 +
 +	if (self->is_pci_enabled)
 +		pci_disable_device(self->pdev);
 +
 +err_exit:;
 +}
 +
 +void aq_pci_func_free(struct aq_pci_func_s *self)
 +{
 +	unsigned int port = 0U;
 +
 +	if (!self)
 +		goto err_exit;
 +
 +	for (port = 0; port < self->ports; ++port) {
 +		if (!self->port[port])
 +			continue;
 +
 +		aq_nic_ndev_free(self->port[port]);
 +	}
 +
 +	if (self->mmio)
 +		iounmap(self->mmio);
 +
 +	kfree(self);
 +
 +err_exit:;
 +}
 +
 +int aq_pci_func_change_pm_state(struct aq_pci_func_s *self,
 +				pm_message_t *pm_msg)
 +{
 +	int err = 0;
 +	unsigned int port = 0U;
 +
 +	if (!self) {
 +		err = -EFAULT;
 +		goto err_exit;
 +	}
 +	for (port = 0; port < self->ports; ++port) {
 +		if (!self->port[port])
 +			continue;
 +
 +		(void)aq_nic_change_pm_state(self->port[port], pm_msg);
 +	}
 +
 +err_exit:
 +	return err;
 +}
++=======
+ 	pci_free_irq_vectors(self->pdev);
+ }
+ 
+ static int aq_pci_probe(struct pci_dev *pdev,
+ 			const struct pci_device_id *pci_id)
+ {
+ 	struct aq_nic_s *self = NULL;
+ 	int err = 0;
+ 	struct net_device *ndev;
+ 	resource_size_t mmio_pa;
+ 	u32 bar;
+ 	u32 numvecs;
+ 
+ 	err = pci_enable_device(pdev);
+ 	if (err)
+ 		return err;
+ 
+ 	err = aq_pci_func_init(pdev);
+ 	if (err)
+ 		goto err_pci_func;
+ 
+ 	ndev = aq_ndev_alloc();
+ 	if (!ndev)
+ 		goto err_ndev;
+ 
+ 	self = netdev_priv(ndev);
+ 	self->pdev = pdev;
+ 	SET_NETDEV_DEV(ndev, &pdev->dev);
+ 	pci_set_drvdata(pdev, self);
+ 
+ 	err = aq_pci_probe_get_hw_by_id(pdev, &self->aq_hw_ops,
+ 					&aq_nic_get_cfg(self)->aq_hw_caps);
+ 	if (err)
+ 		goto err_ioremap;
+ 
+ 	self->aq_hw = kzalloc(sizeof(*self->aq_hw), GFP_KERNEL);
+ 	self->aq_hw->aq_nic_cfg = aq_nic_get_cfg(self);
+ 
+ 	for (bar = 0; bar < 4; ++bar) {
+ 		if (IORESOURCE_MEM & pci_resource_flags(pdev, bar)) {
+ 			resource_size_t reg_sz;
+ 
+ 			mmio_pa = pci_resource_start(pdev, bar);
+ 			if (mmio_pa == 0U) {
+ 				err = -EIO;
+ 				goto err_ioremap;
+ 			}
+ 
+ 			reg_sz = pci_resource_len(pdev, bar);
+ 			if ((reg_sz <= 24 /*ATL_REGS_SIZE*/)) {
+ 				err = -EIO;
+ 				goto err_ioremap;
+ 			}
+ 
+ 			self->aq_hw->mmio = ioremap_nocache(mmio_pa, reg_sz);
+ 			if (!self->aq_hw->mmio) {
+ 				err = -EIO;
+ 				goto err_ioremap;
+ 			}
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (bar == 4) {
+ 		err = -EIO;
+ 		goto err_ioremap;
+ 	}
+ 
+ 	numvecs = min((u8)AQ_CFG_VECS_DEF,
+ 		      aq_nic_get_cfg(self)->aq_hw_caps->msix_irqs);
+ 	numvecs = min(numvecs, num_online_cpus());
+ 	/*enable interrupts */
+ #if !AQ_CFG_FORCE_LEGACY_INT
+ 	err = pci_alloc_irq_vectors(self->pdev, numvecs, numvecs,
+ 				    PCI_IRQ_MSIX);
+ 
+ 	if (err < 0) {
+ 		err = pci_alloc_irq_vectors(self->pdev, 1, 1,
+ 					    PCI_IRQ_MSI | PCI_IRQ_LEGACY);
+ 		if (err < 0)
+ 			goto err_hwinit;
+ 	}
+ #endif
+ 
+ 	/* net device init */
+ 	aq_nic_cfg_start(self);
+ 
+ 	aq_nic_ndev_init(self);
+ 
+ 	err = aq_nic_ndev_register(self);
+ 	if (err < 0)
+ 		goto err_register;
+ 
+ 	return 0;
+ 
+ err_register:
+ 	aq_nic_free_vectors(self);
+ 	aq_pci_free_irq_vectors(self);
+ err_hwinit:
+ 	iounmap(self->aq_hw->mmio);
+ err_ioremap:
+ 	free_netdev(ndev);
+ err_pci_func:
+ 	pci_release_regions(pdev);
+ err_ndev:
+ 	pci_disable_device(pdev);
+ 	return err;
+ }
+ 
+ static void aq_pci_remove(struct pci_dev *pdev)
+ {
+ 	struct aq_nic_s *self = pci_get_drvdata(pdev);
+ 
+ 	if (self->ndev) {
+ 		if (self->ndev->reg_state == NETREG_REGISTERED)
+ 			unregister_netdev(self->ndev);
+ 		aq_nic_free_vectors(self);
+ 		aq_pci_free_irq_vectors(self);
+ 		iounmap(self->aq_hw->mmio);
+ 		kfree(self->aq_hw);
+ 		pci_release_regions(pdev);
+ 		free_netdev(self->ndev);
+ 	}
+ 
+ 	pci_disable_device(pdev);
+ }
+ 
+ static int aq_pci_suspend(struct pci_dev *pdev, pm_message_t pm_msg)
+ {
+ 	struct aq_nic_s *self = pci_get_drvdata(pdev);
+ 
+ 	return aq_nic_change_pm_state(self, &pm_msg);
+ }
+ 
+ static int aq_pci_resume(struct pci_dev *pdev)
+ {
+ 	struct aq_nic_s *self = pci_get_drvdata(pdev);
+ 	pm_message_t pm_msg = PMSG_RESTORE;
+ 
+ 	return aq_nic_change_pm_state(self, &pm_msg);
+ }
+ 
+ static struct pci_driver aq_pci_ops = {
+ 	.name = AQ_CFG_DRV_NAME,
+ 	.id_table = aq_pci_tbl,
+ 	.probe = aq_pci_probe,
+ 	.remove = aq_pci_remove,
+ 	.suspend = aq_pci_suspend,
+ 	.resume = aq_pci_resume,
+ };
+ 
+ module_pci_driver(aq_pci_ops);
++>>>>>>> 23ee07ad3c2f (net: aquantia: Cleanup pci functions module)
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_pci_func.h
index 84465220b36b,aeee67bf69fa..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.h
@@@ -15,21 -15,18 +15,27 @@@
  #include "aq_common.h"
  #include "aq_nic.h"
  
++<<<<<<< HEAD
 +struct aq_pci_func_s *aq_pci_func_alloc(const struct aq_hw_ops *hw_ops,
 +					struct pci_dev *pdev,
 +					const struct net_device_ops *ndev_ops,
 +					const struct ethtool_ops *eth_ops);
 +int aq_pci_func_init(struct aq_pci_func_s *self);
 +int aq_pci_func_alloc_irq(struct aq_pci_func_s *self, unsigned int i,
++=======
+ struct aq_board_revision_s {
+ 	unsigned short devid;
+ 	unsigned short revision;
+ 	const struct aq_hw_ops *ops;
+ 	const struct aq_hw_caps_s *caps;
+ };
+ 
+ int aq_pci_func_init(struct pci_dev *pdev);
+ int aq_pci_func_alloc_irq(struct aq_nic_s *self, unsigned int i,
++>>>>>>> 23ee07ad3c2f (net: aquantia: Cleanup pci functions module)
  			  char *name, void *aq_vec,
  			  cpumask_t *affinity_mask);
- void aq_pci_func_free_irqs(struct aq_pci_func_s *self);
- int aq_pci_func_start(struct aq_pci_func_s *self);
- void __iomem *aq_pci_func_get_mmio(struct aq_pci_func_s *self);
- unsigned int aq_pci_func_get_irq_type(struct aq_pci_func_s *self);
- void aq_pci_func_deinit(struct aq_pci_func_s *self);
- void aq_pci_func_free(struct aq_pci_func_s *self);
- int aq_pci_func_change_pm_state(struct aq_pci_func_s *self,
- 				pm_message_t *pm_msg);
+ void aq_pci_func_free_irqs(struct aq_nic_s *self);
+ unsigned int aq_pci_func_get_irq_type(struct aq_nic_s *self);
  
  #endif /* AQ_PCI_FUNC_H */
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
index cdd1acd417c2..6eb2d03284bc 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
@@ -29,7 +29,6 @@ struct aq_hw_caps_s {
 	u32 vecs;
 	u32 mtu;
 	u32 mac_regs_count;
-	u8 ports;
 	u8 msix_irqs;
 	u8 tcs;
 	u8 rxd_alignment;
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_main.c b/drivers/net/ethernet/aquantia/atlantic/aq_main.c
index 3bd408178d19..6de2405d84d4 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_main.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_main.c
@@ -48,14 +48,9 @@ static const struct aq_hw_ops *aq_pci_probe_get_hw_ops_by_id(struct pci_dev *pde
 
 static int aq_ndev_open(struct net_device *ndev)
 {
-	struct aq_nic_s *aq_nic = NULL;
 	int err = 0;
+	struct aq_nic_s *aq_nic = netdev_priv(ndev);
 
-	aq_nic = aq_nic_alloc_hot(ndev);
-	if (!aq_nic) {
-		err = -ENOMEM;
-		goto err_exit;
-	}
 	err = aq_nic_init(aq_nic);
 	if (err < 0)
 		goto err_exit;
@@ -78,7 +73,6 @@ static int aq_ndev_close(struct net_device *ndev)
 	if (err < 0)
 		goto err_exit;
 	aq_nic_deinit(aq_nic);
-	aq_nic_free_hot_resources(aq_nic);
 
 err_exit:
 	return err;
@@ -150,15 +144,13 @@ static void aq_ndev_set_multicast_settings(struct net_device *ndev)
 
 	err = aq_nic_set_packet_filter(aq_nic, ndev->flags);
 	if (err < 0)
-		goto err_exit;
+		return;
 
 	if (netdev_mc_count(ndev)) {
 		err = aq_nic_set_multicast_list(aq_nic, ndev);
 		if (err < 0)
-			goto err_exit;
+			return;
 	}
-
-err_exit:;
 }
 
 static const struct net_device_ops aq_ndev_ops = {
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_nic.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_nic.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_pci_func.h
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
index 9c7e9161b4db..f4418c7da9dc 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
@@ -369,8 +369,6 @@ int hw_atl_utils_get_mac_permanent(struct aq_hw_s *self,
 	u32 l = 0U;
 	u32 mac_addr[2];
 
-	self->mmio = aq_pci_func_get_mmio(self->aq_pci_func);
-
 	hw_atl_utils_hw_chip_features_init(self,
 					   &self->chip_features);
 
