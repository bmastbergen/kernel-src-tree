ipmi_si: Move platform device handling to another file

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Corey Minyard <cminyard@mvista.com>
commit 9d70029edbbf23474e022ac77700269807d64b0d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9d70029e.failed

	Signed-off-by: Corey Minyard <cminyard@mvista.com>

Stephen Rothwell <sfr@canb.auug.org.au> fixed an issue with the
include files

(cherry picked from commit 9d70029edbbf23474e022ac77700269807d64b0d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/Makefile
#	drivers/char/ipmi/ipmi_si.h
#	drivers/char/ipmi/ipmi_si_intf.c
diff --cc drivers/char/ipmi/Makefile
index eefb0b301e83,fa3858f472ac..000000000000
--- a/drivers/char/ipmi/Makefile
+++ b/drivers/char/ipmi/Makefile
@@@ -2,7 -2,8 +2,12 @@@
  # Makefile for the ipmi drivers.
  #
  
++<<<<<<< HEAD
 +ipmi_si-y := ipmi_si_intf.o ipmi_kcs_sm.o ipmi_smic_sm.o ipmi_bt_sm.o
++=======
+ ipmi_si-y := ipmi_si_intf.o ipmi_kcs_sm.o ipmi_smic_sm.o ipmi_bt_sm.o \
+ 	ipmi_si_hotmod.o ipmi_si_hardcode.o ipmi_si_platform.o
++>>>>>>> 9d70029edbbf (ipmi_si: Move platform device handling to another file)
  
  obj-$(CONFIG_IPMI_HANDLER) += ipmi_msghandler.o
  obj-$(CONFIG_IPMI_DEVICE_INTERFACE) += ipmi_devintf.o
diff --cc drivers/char/ipmi/ipmi_si.h
index a4d993b1fe66,ff9a30a1ead5..000000000000
--- a/drivers/char/ipmi/ipmi_si.h
+++ b/drivers/char/ipmi/ipmi_si.h
@@@ -13,6 -14,18 +13,24 @@@
  #define DEFAULT_REGSPACING	1
  #define DEFAULT_REGSIZE		1
  
++<<<<<<< HEAD
 +struct smi_info;
 +
 +int ipmi_si_add_smi(struct smi_info *info);
++=======
+ #define DEVICE_NAME "ipmi_si"
+ 
+ int ipmi_si_add_smi(struct si_sm_io *io);
+ irqreturn_t ipmi_si_irq_handler(int irq, void *data);
+ void ipmi_irq_start_cleanup(struct si_sm_io *io);
+ int ipmi_std_irq_setup(struct si_sm_io *io);
+ void ipmi_irq_finish_setup(struct si_sm_io *io);
+ int ipmi_si_remove_by_dev(struct device *dev);
+ void ipmi_si_remove_by_data(int addr_space, enum si_type si_type,
+ 			    unsigned long addr);
+ int ipmi_si_hardcode_find_bmc(void);
+ void ipmi_si_platform_init(void);
+ void ipmi_si_platform_shutdown(void);
+ 
+ extern struct platform_driver ipmi_platform_driver;
++>>>>>>> 9d70029edbbf (ipmi_si: Move platform device handling to another file)
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 72982bfaeaf1,bfc052bdbdd7..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -61,16 -61,14 +61,9 @@@
  #include <linux/ipmi_smi.h>
  #include <asm/io.h>
  #include "ipmi_si.h"
- #include "ipmi_dmi.h"
- #include <linux/dmi.h>
  #include <linux/string.h>
  #include <linux/ctype.h>
- #include <linux/of_device.h>
- #include <linux/of_platform.h>
- #include <linux/of_address.h>
- #include <linux/of_irq.h>
- #include <linux/acpi.h>
  
 -#ifdef CONFIG_PARISC
 -#include <asm/hardware.h>	/* for register_parisc_driver() stuff */
 -#include <asm/parisc-device.h>
 -#endif
 -
  #define PFX "ipmi_si: "
  
  /* Measure times between events in the driver. */
@@@ -99,15 -97,9 +92,19 @@@ enum si_intf_state 
  #define IPMI_BT_INTMASK_CLEAR_IRQ_BIT	2
  #define IPMI_BT_INTMASK_ENABLE_IRQ_BIT	1
  
 +enum si_type {
 +	SI_KCS, SI_SMIC, SI_BT
 +};
 +
  static const char * const si_to_str[] = { "kcs", "smic", "bt" };
  
++<<<<<<< HEAD
 +#define DEVICE_NAME "ipmi_si"
 +
 +static struct platform_driver ipmi_driver;
++=======
+ static int initialized;
++>>>>>>> 9d70029edbbf (ipmi_si: Move platform device handling to another file)
  
  /*
   * Indexes into stats[] in smi_info below.
@@@ -1333,27 -1269,6 +1323,30 @@@ static unsigned int num_slave_addrs
  
  static const char * const addr_space_to_str[] = { "i/o", "mem" };
  
++<<<<<<< HEAD
 +static int hotmod_handler(const char *val, struct kernel_param *kp);
 +
 +module_param_call(hotmod, hotmod_handler, NULL, NULL, 0200);
 +MODULE_PARM_DESC(hotmod, "Add and remove interfaces.  See"
 +		 " Documentation/IPMI.txt in the kernel sources for the"
 +		 " gory details.");
 +
 +#ifdef CONFIG_ACPI
 +module_param_named(tryacpi, si_tryacpi, bool, 0);
 +MODULE_PARM_DESC(tryacpi, "Setting this to zero will disable the"
 +		 " default scan of the interfaces identified via ACPI");
 +#endif
 +#ifdef CONFIG_DMI
 +module_param_named(trydmi, si_trydmi, bool, 0);
 +MODULE_PARM_DESC(trydmi, "Setting this to zero will disable the"
 +		 " default scan of the interfaces identified via DMI");
 +#endif
 +module_param_named(tryplatform, si_tryplatform, bool, 0);
 +MODULE_PARM_DESC(tryplatform, "Setting this to zero will disable the"
 +		 " default scan of the interfaces identified via platform"
 +		 " interfaces like openfirmware");
++=======
++>>>>>>> 9d70029edbbf (ipmi_si: Move platform device handling to another file)
  #ifdef CONFIG_PCI
  module_param_named(trypci, si_trypci, bool, 0);
  MODULE_PARM_DESC(trypci, "Setting this to zero will disable the"
@@@ -1799,590 -1594,6 +1792,593 @@@ static struct smi_info *smi_info_alloc(
  	return info;
  }
  
++<<<<<<< HEAD
 +static int hotmod_handler(const char *val, struct kernel_param *kp)
 +{
 +	char *str = kstrdup(val, GFP_KERNEL);
 +	int  rv;
 +	char *next, *curr, *s, *n, *o;
 +	enum hotmod_op op;
 +	enum si_type si_type;
 +	int  addr_space;
 +	unsigned long addr;
 +	int regspacing;
 +	int regsize;
 +	int regshift;
 +	int irq;
 +	int ipmb;
 +	int ival;
 +	int len;
 +	struct smi_info *info;
 +
 +	if (!str)
 +		return -ENOMEM;
 +
 +	/* Kill any trailing spaces, as we can get a "\n" from echo. */
 +	len = strlen(str);
 +	ival = len - 1;
 +	while ((ival >= 0) && isspace(str[ival])) {
 +		str[ival] = '\0';
 +		ival--;
 +	}
 +
 +	for (curr = str; curr; curr = next) {
 +		regspacing = 1;
 +		regsize = 1;
 +		regshift = 0;
 +		irq = 0;
 +		ipmb = 0; /* Choose the default if not specified */
 +
 +		next = strchr(curr, ':');
 +		if (next) {
 +			*next = '\0';
 +			next++;
 +		}
 +
 +		rv = parse_str(hotmod_ops, &ival, "operation", &curr);
 +		if (rv)
 +			break;
 +		op = ival;
 +
 +		rv = parse_str(hotmod_si, &ival, "interface type", &curr);
 +		if (rv)
 +			break;
 +		si_type = ival;
 +
 +		rv = parse_str(hotmod_as, &addr_space, "address space", &curr);
 +		if (rv)
 +			break;
 +
 +		s = strchr(curr, ',');
 +		if (s) {
 +			*s = '\0';
 +			s++;
 +		}
 +		addr = simple_strtoul(curr, &n, 0);
 +		if ((*n != '\0') || (*curr == '\0')) {
 +			pr_warn(PFX "Invalid hotmod address '%s'\n", curr);
 +			break;
 +		}
 +
 +		while (s) {
 +			curr = s;
 +			s = strchr(curr, ',');
 +			if (s) {
 +				*s = '\0';
 +				s++;
 +			}
 +			o = strchr(curr, '=');
 +			if (o) {
 +				*o = '\0';
 +				o++;
 +			}
 +			rv = check_hotmod_int_op(curr, o, "rsp", &regspacing);
 +			if (rv < 0)
 +				goto out;
 +			else if (rv)
 +				continue;
 +			rv = check_hotmod_int_op(curr, o, "rsi", &regsize);
 +			if (rv < 0)
 +				goto out;
 +			else if (rv)
 +				continue;
 +			rv = check_hotmod_int_op(curr, o, "rsh", &regshift);
 +			if (rv < 0)
 +				goto out;
 +			else if (rv)
 +				continue;
 +			rv = check_hotmod_int_op(curr, o, "irq", &irq);
 +			if (rv < 0)
 +				goto out;
 +			else if (rv)
 +				continue;
 +			rv = check_hotmod_int_op(curr, o, "ipmb", &ipmb);
 +			if (rv < 0)
 +				goto out;
 +			else if (rv)
 +				continue;
 +
 +			rv = -EINVAL;
 +			pr_warn(PFX "Invalid hotmod option '%s'\n", curr);
 +			goto out;
 +		}
 +
 +		if (op == HM_ADD) {
 +			info = smi_info_alloc();
 +			if (!info) {
 +				rv = -ENOMEM;
 +				goto out;
 +			}
 +
 +			info->addr_source = SI_HOTMOD;
 +			info->si_type = si_type;
 +			info->io.addr_data = addr;
 +			info->io.addr_type = addr_space;
 +			if (addr_space == IPMI_MEM_ADDR_SPACE)
 +				info->io_setup = mem_setup;
 +			else
 +				info->io_setup = port_setup;
 +
 +			info->io.addr = NULL;
 +			info->io.regspacing = regspacing;
 +			if (!info->io.regspacing)
 +				info->io.regspacing = DEFAULT_REGSPACING;
 +			info->io.regsize = regsize;
 +			if (!info->io.regsize)
 +				info->io.regsize = DEFAULT_REGSIZE;
 +			info->io.regshift = regshift;
 +			info->irq = irq;
 +			if (info->irq)
 +				info->irq_setup = std_irq_setup;
 +			info->slave_addr = ipmb;
 +
 +			rv = ipmi_si_add_smi(info);
 +			if (rv) {
 +				kfree(info);
 +				goto out;
 +			}
 +			mutex_lock(&smi_infos_lock);
 +			rv = try_smi_init(info);
 +			mutex_unlock(&smi_infos_lock);
 +			if (rv) {
 +				cleanup_one_si(info);
 +				goto out;
 +			}
 +		} else {
 +			/* remove */
 +			struct smi_info *e, *tmp_e;
 +
 +			mutex_lock(&smi_infos_lock);
 +			list_for_each_entry_safe(e, tmp_e, &smi_infos, link) {
 +				if (e->io.addr_type != addr_space)
 +					continue;
 +				if (e->si_type != si_type)
 +					continue;
 +				if (e->io.addr_data == addr)
 +					cleanup_one_si(e);
 +			}
 +			mutex_unlock(&smi_infos_lock);
 +		}
 +	}
 +	rv = len;
 +out:
 +	kfree(str);
 +	return rv;
 +}
 +
 +static int hardcode_find_bmc(void)
 +{
 +	int ret = -ENODEV;
 +	int             i;
 +	struct smi_info *info;
 +
 +	for (i = 0; i < SI_MAX_PARMS; i++) {
 +		if (!ports[i] && !addrs[i])
 +			continue;
 +
 +		info = smi_info_alloc();
 +		if (!info)
 +			return -ENOMEM;
 +
 +		info->addr_source = SI_HARDCODED;
 +		pr_info(PFX "probing via hardcoded address\n");
 +
 +		if (!si_type[i] || strcmp(si_type[i], "kcs") == 0) {
 +			info->si_type = SI_KCS;
 +		} else if (strcmp(si_type[i], "smic") == 0) {
 +			info->si_type = SI_SMIC;
 +		} else if (strcmp(si_type[i], "bt") == 0) {
 +			info->si_type = SI_BT;
 +		} else {
 +			pr_warn(PFX "Interface type specified for interface %d, was invalid: %s\n",
 +				i, si_type[i]);
 +			kfree(info);
 +			continue;
 +		}
 +
 +		if (ports[i]) {
 +			/* An I/O port */
 +			info->io_setup = port_setup;
 +			info->io.addr_data = ports[i];
 +			info->io.addr_type = IPMI_IO_ADDR_SPACE;
 +		} else if (addrs[i]) {
 +			/* A memory port */
 +			info->io_setup = mem_setup;
 +			info->io.addr_data = addrs[i];
 +			info->io.addr_type = IPMI_MEM_ADDR_SPACE;
 +		} else {
 +			pr_warn(PFX "Interface type specified for interface %d, but port and address were not set or set to zero.\n",
 +				i);
 +			kfree(info);
 +			continue;
 +		}
 +
 +		info->io.addr = NULL;
 +		info->io.regspacing = regspacings[i];
 +		if (!info->io.regspacing)
 +			info->io.regspacing = DEFAULT_REGSPACING;
 +		info->io.regsize = regsizes[i];
 +		if (!info->io.regsize)
 +			info->io.regsize = DEFAULT_REGSIZE;
 +		info->io.regshift = regshifts[i];
 +		info->irq = irqs[i];
 +		if (info->irq)
 +			info->irq_setup = std_irq_setup;
 +		info->slave_addr = slave_addrs[i];
 +
 +		if (!ipmi_si_add_smi(info)) {
 +			mutex_lock(&smi_infos_lock);
 +			if (try_smi_init(info))
 +				cleanup_one_si(info);
 +			mutex_unlock(&smi_infos_lock);
 +			ret = 0;
 +		} else {
 +			kfree(info);
 +		}
 +	}
 +	return ret;
 +}
 +
 +#ifdef CONFIG_ACPI
 +
 +/*
 + * Once we get an ACPI failure, we don't try any more, because we go
 + * through the tables sequentially.  Once we don't find a table, there
 + * are no more.
 + */
 +static int acpi_failure;
 +
 +/* For GPE-type interrupts. */
 +static u32 ipmi_acpi_gpe(acpi_handle gpe_device,
 +	u32 gpe_number, void *context)
 +{
 +	struct smi_info *smi_info = context;
 +	unsigned long   flags;
 +
 +	spin_lock_irqsave(&(smi_info->si_lock), flags);
 +
 +	smi_inc_stat(smi_info, interrupts);
 +
 +	debug_timestamp("ACPI_GPE");
 +
 +	smi_event_handler(smi_info, 0);
 +	spin_unlock_irqrestore(&(smi_info->si_lock), flags);
 +
 +	return ACPI_INTERRUPT_HANDLED;
 +}
 +
 +static void acpi_gpe_irq_cleanup(struct smi_info *info)
 +{
 +	if (!info->irq)
 +		return;
 +
 +	acpi_remove_gpe_handler(NULL, info->irq, &ipmi_acpi_gpe);
 +}
 +
 +static int acpi_gpe_irq_setup(struct smi_info *info)
 +{
 +	acpi_status status;
 +
 +	if (!info->irq)
 +		return 0;
 +
 +	status = acpi_install_gpe_handler(NULL,
 +					  info->irq,
 +					  ACPI_GPE_LEVEL_TRIGGERED,
 +					  &ipmi_acpi_gpe,
 +					  info);
 +	if (status != AE_OK) {
 +		dev_warn(info->dev, "%s unable to claim ACPI GPE %d,"
 +			 " running polled\n", DEVICE_NAME, info->irq);
 +		info->irq = 0;
 +		return -EINVAL;
 +	} else {
 +		info->irq_cleanup = acpi_gpe_irq_cleanup;
 +		dev_info(info->dev, "Using ACPI GPE %d\n", info->irq);
 +		return 0;
 +	}
 +}
 +
 +/*
 + * Defined at
 + * http://h21007.www2.hp.com/portal/download/files/unprot/hpspmi.pdf
 + */
 +struct SPMITable {
 +	s8	Signature[4];
 +	u32	Length;
 +	u8	Revision;
 +	u8	Checksum;
 +	s8	OEMID[6];
 +	s8	OEMTableID[8];
 +	s8	OEMRevision[4];
 +	s8	CreatorID[4];
 +	s8	CreatorRevision[4];
 +	u8	InterfaceType;
 +	u8	IPMIlegacy;
 +	s16	SpecificationRevision;
 +
 +	/*
 +	 * Bit 0 - SCI interrupt supported
 +	 * Bit 1 - I/O APIC/SAPIC
 +	 */
 +	u8	InterruptType;
 +
 +	/*
 +	 * If bit 0 of InterruptType is set, then this is the SCI
 +	 * interrupt in the GPEx_STS register.
 +	 */
 +	u8	GPE;
 +
 +	s16	Reserved;
 +
 +	/*
 +	 * If bit 1 of InterruptType is set, then this is the I/O
 +	 * APIC/SAPIC interrupt.
 +	 */
 +	u32	GlobalSystemInterrupt;
 +
 +	/* The actual register address. */
 +	struct acpi_generic_address addr;
 +
 +	u8	UID[4];
 +
 +	s8      spmi_id[1]; /* A '\0' terminated array starts here. */
 +};
 +
 +static int try_init_spmi(struct SPMITable *spmi)
 +{
 +	struct smi_info  *info;
 +	int rv;
 +
 +	if (spmi->IPMIlegacy != 1) {
 +		pr_info(PFX "Bad SPMI legacy %d\n", spmi->IPMIlegacy);
 +		return -ENODEV;
 +	}
 +
 +	info = smi_info_alloc();
 +	if (!info) {
 +		pr_err(PFX "Could not allocate SI data (3)\n");
 +		return -ENOMEM;
 +	}
 +
 +	info->addr_source = SI_SPMI;
 +	pr_info(PFX "probing via SPMI\n");
 +
 +	/* Figure out the interface type. */
 +	switch (spmi->InterfaceType) {
 +	case 1:	/* KCS */
 +		info->si_type = SI_KCS;
 +		break;
 +	case 2:	/* SMIC */
 +		info->si_type = SI_SMIC;
 +		break;
 +	case 3:	/* BT */
 +		info->si_type = SI_BT;
 +		break;
 +	case 4: /* SSIF, just ignore */
 +		kfree(info);
 +		return -EIO;
 +	default:
 +		pr_info(PFX "Unknown ACPI/SPMI SI type %d\n",
 +			spmi->InterfaceType);
 +		kfree(info);
 +		return -EIO;
 +	}
 +
 +	if (spmi->InterruptType & 1) {
 +		/* We've got a GPE interrupt. */
 +		info->irq = spmi->GPE;
 +		info->irq_setup = acpi_gpe_irq_setup;
 +	} else if (spmi->InterruptType & 2) {
 +		/* We've got an APIC/SAPIC interrupt. */
 +		info->irq = spmi->GlobalSystemInterrupt;
 +		info->irq_setup = std_irq_setup;
 +	} else {
 +		/* Use the default interrupt setting. */
 +		info->irq = 0;
 +		info->irq_setup = NULL;
 +	}
 +
 +	if (spmi->addr.bit_width) {
 +		/* A (hopefully) properly formed register bit width. */
 +		info->io.regspacing = spmi->addr.bit_width / 8;
 +	} else {
 +		info->io.regspacing = DEFAULT_REGSPACING;
 +	}
 +	info->io.regsize = info->io.regspacing;
 +	info->io.regshift = spmi->addr.bit_offset;
 +
 +	if (spmi->addr.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {
 +		info->io_setup = mem_setup;
 +		info->io.addr_type = IPMI_MEM_ADDR_SPACE;
 +	} else if (spmi->addr.space_id == ACPI_ADR_SPACE_SYSTEM_IO) {
 +		info->io_setup = port_setup;
 +		info->io.addr_type = IPMI_IO_ADDR_SPACE;
 +	} else {
 +		kfree(info);
 +		pr_warn(PFX "Unknown ACPI I/O Address type\n");
 +		return -EIO;
 +	}
 +	info->io.addr_data = spmi->addr.address;
 +
 +	pr_info("ipmi_si: SPMI: %s %#lx regsize %d spacing %d irq %d\n",
 +		(info->io.addr_type == IPMI_IO_ADDR_SPACE) ? "io" : "mem",
 +		info->io.addr_data, info->io.regsize, info->io.regspacing,
 +		info->irq);
 +
 +	rv = ipmi_si_add_smi(info);
 +	if (rv)
 +		kfree(info);
 +
 +	return rv;
 +}
 +
 +static void spmi_find_bmc(void)
 +{
 +	acpi_status      status;
 +	struct SPMITable *spmi;
 +	int              i;
 +
 +	if (acpi_disabled)
 +		return;
 +
 +	if (acpi_failure)
 +		return;
 +
 +	for (i = 0; ; i++) {
 +		status = acpi_get_table(ACPI_SIG_SPMI, i+1,
 +					(struct acpi_table_header **)&spmi);
 +		if (status != AE_OK)
 +			return;
 +
 +		try_init_spmi(spmi);
 +	}
 +}
 +#endif
 +
 +#if defined(CONFIG_DMI) || defined(CONFIG_ACPI)
 +struct resource *ipmi_get_info_from_resources(struct platform_device *pdev,
 +					      struct smi_info *info)
 +{
 +	struct resource *res, *res_second;
 +
 +	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
 +	if (res) {
 +		info->io_setup = port_setup;
 +		info->io.addr_type = IPMI_IO_ADDR_SPACE;
 +	} else {
 +		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 +		if (res) {
 +			info->io_setup = mem_setup;
 +			info->io.addr_type = IPMI_MEM_ADDR_SPACE;
 +		}
 +	}
 +	if (!res) {
 +		dev_err(&pdev->dev, "no I/O or memory address\n");
 +		return NULL;
 +	}
 +	info->io.addr_data = res->start;
 +
 +	info->io.regspacing = DEFAULT_REGSPACING;
 +	res_second = platform_get_resource(pdev,
 +			       (info->io.addr_type == IPMI_IO_ADDR_SPACE) ?
 +					IORESOURCE_IO : IORESOURCE_MEM,
 +			       1);
 +	if (res_second) {
 +		if (res_second->start > info->io.addr_data)
 +			info->io.regspacing =
 +				res_second->start - info->io.addr_data;
 +	}
 +	info->io.regsize = DEFAULT_REGSIZE;
 +	info->io.regshift = 0;
 +
 +	return res;
 +}
 +
 +#endif
 +
 +#ifdef CONFIG_DMI
 +static int dmi_ipmi_probe(struct platform_device *pdev)
 +{
 +	struct smi_info *info;
 +	u8 type, slave_addr;
 +	int rv;
 +
 +	if (!si_trydmi)
 +		return -ENODEV;
 +
 +	rv = device_property_read_u8(&pdev->dev, "ipmi-type", &type);
 +	if (rv)
 +		return -ENODEV;
 +
 +	info = smi_info_alloc();
 +	if (!info) {
 +		pr_err(PFX "Could not allocate SI data\n");
 +		return -ENOMEM;
 +	}
 +
 +	info->addr_source = SI_SMBIOS;
 +	pr_info(PFX "probing via SMBIOS\n");
 +
 +	switch (type) {
 +	case IPMI_DMI_TYPE_KCS:
 +		info->si_type = SI_KCS;
 +		break;
 +	case IPMI_DMI_TYPE_SMIC:
 +		info->si_type = SI_SMIC;
 +		break;
 +	case IPMI_DMI_TYPE_BT:
 +		info->si_type = SI_BT;
 +		break;
 +	default:
 +		kfree(info);
 +		return -EINVAL;
 +	}
 +
 +	if (!ipmi_get_info_from_resources(pdev, info)) {
 +		rv = -EINVAL;
 +		goto err_free;
 +	}
 +
 +	rv = device_property_read_u8(&pdev->dev, "slave-addr", &slave_addr);
 +	if (rv) {
 +		dev_warn(&pdev->dev, "device has no slave-addr property");
 +		info->slave_addr = 0x20;
 +	} else {
 +		info->slave_addr = slave_addr;
 +	}
 +
 +	info->irq = platform_get_irq(pdev, 0);
 +	if (info->irq > 0)
 +		info->irq_setup = std_irq_setup;
 +	else
 +		info->irq = 0;
 +
 +	info->dev = &pdev->dev;
 +
 +	pr_info("ipmi_si: SMBIOS: %s %#lx regsize %d spacing %d irq %d\n",
 +		(info->io.addr_type == IPMI_IO_ADDR_SPACE) ? "io" : "mem",
 +		info->io.addr_data, info->io.regsize, info->io.regspacing,
 +		info->irq);
 +
 +	if (ipmi_si_add_smi(info))
 +		kfree(info);
 +
 +	return 0;
 +
 +err_free:
 +	kfree(info);
 +	return rv;
 +}
 +#else
 +static int dmi_ipmi_probe(struct platform_device *pdev)
 +{
 +	return -ENODEV;
 +}
 +#endif /* CONFIG_DMI */
 +
++=======
++>>>>>>> 9d70029edbbf (ipmi_si: Move platform device handling to another file)
  #ifdef CONFIG_PCI
  
  #define PCI_ERMC_CLASSCODE		0x0C0700
@@@ -2532,318 -1728,33 +2528,321 @@@ static struct pci_driver ipmi_pci_drive
  };
  #endif /* CONFIG_PCI */
  
++<<<<<<< HEAD
 +#ifdef CONFIG_OF
 +static const struct of_device_id of_ipmi_match[] = {
 +	{ .type = "ipmi", .compatible = "ipmi-kcs",
 +	  .data = (void *)(unsigned long) SI_KCS },
 +	{ .type = "ipmi", .compatible = "ipmi-smic",
 +	  .data = (void *)(unsigned long) SI_SMIC },
 +	{ .type = "ipmi", .compatible = "ipmi-bt",
 +	  .data = (void *)(unsigned long) SI_BT },
 +	{},
 +};
 +
 +static int of_ipmi_probe(struct platform_device *dev)
 +{
 +	const struct of_device_id *match;
 +	struct smi_info *info;
 +	struct resource resource;
 +	const __be32 *regsize, *regspacing, *regshift;
 +	struct device_node *np = dev->dev.of_node;
 +	int ret;
 +	int proplen;
 +
 +	dev_info(&dev->dev, "probing via device tree\n");
 +
 +	match = of_match_device(of_ipmi_match, &dev->dev);
 +	if (!match)
 +		return -ENODEV;
 +
 +	if (!of_device_is_available(np))
 +		return -EINVAL;
 +
 +	ret = of_address_to_resource(np, 0, &resource);
 +	if (ret) {
 +		dev_warn(&dev->dev, PFX "invalid address from OF\n");
 +		return ret;
 +	}
 +
 +	regsize = of_get_property(np, "reg-size", &proplen);
 +	if (regsize && proplen != 4) {
 +		dev_warn(&dev->dev, PFX "invalid regsize from OF\n");
 +		return -EINVAL;
 +	}
 +
 +	regspacing = of_get_property(np, "reg-spacing", &proplen);
 +	if (regspacing && proplen != 4) {
 +		dev_warn(&dev->dev, PFX "invalid regspacing from OF\n");
 +		return -EINVAL;
 +	}
 +
 +	regshift = of_get_property(np, "reg-shift", &proplen);
 +	if (regshift && proplen != 4) {
 +		dev_warn(&dev->dev, PFX "invalid regshift from OF\n");
 +		return -EINVAL;
 +	}
 +
 +	info = smi_info_alloc();
 +
 +	if (!info) {
 +		dev_err(&dev->dev,
 +			"could not allocate memory for OF probe\n");
 +		return -ENOMEM;
 +	}
 +
 +	info->si_type		= (enum si_type) match->data;
 +	info->addr_source	= SI_DEVICETREE;
 +	info->irq_setup		= std_irq_setup;
 +
 +	if (resource.flags & IORESOURCE_IO) {
 +		info->io_setup		= port_setup;
 +		info->io.addr_type	= IPMI_IO_ADDR_SPACE;
 +	} else {
 +		info->io_setup		= mem_setup;
 +		info->io.addr_type	= IPMI_MEM_ADDR_SPACE;
 +	}
 +
 +	info->io.addr_data	= resource.start;
 +
 +	info->io.regsize	= regsize ? be32_to_cpup(regsize) : DEFAULT_REGSIZE;
 +	info->io.regspacing	= regspacing ? be32_to_cpup(regspacing) : DEFAULT_REGSPACING;
 +	info->io.regshift	= regshift ? be32_to_cpup(regshift) : 0;
 +
 +	info->irq		= irq_of_parse_and_map(dev->dev.of_node, 0);
 +	info->dev		= &dev->dev;
 +
 +	dev_dbg(&dev->dev, "addr 0x%lx regsize %d spacing %d irq %d\n",
 +		info->io.addr_data, info->io.regsize, info->io.regspacing,
 +		info->irq);
 +
 +	dev_set_drvdata(&dev->dev, info);
 +
 +	ret = ipmi_si_add_smi(info);
 +	if (ret) {
 +		kfree(info);
 +		return ret;
 +	}
 +	return 0;
 +}
 +#else
 +#define of_ipmi_match NULL
 +static int of_ipmi_probe(struct platform_device *dev)
 +{
 +	return -ENODEV;
 +}
 +#endif
 +
 +#ifdef CONFIG_ACPI
 +static int find_slave_address(struct smi_info *info, int slave_addr)
 +{
 +#ifdef CONFIG_IPMI_DMI_DECODE
 +	if (!slave_addr) {
 +		int type = -1;
 +		u32 flags = IORESOURCE_IO;
 +
 +		switch (info->si_type) {
 +		case SI_KCS:
 +			type = IPMI_DMI_TYPE_KCS;
 +			break;
 +		case SI_BT:
 +			type = IPMI_DMI_TYPE_BT;
 +			break;
 +		case SI_SMIC:
 +			type = IPMI_DMI_TYPE_SMIC;
 +			break;
 +		}
 +
 +		if (info->io.addr_type == IPMI_MEM_ADDR_SPACE)
 +			flags = IORESOURCE_MEM;
 +
 +		slave_addr = ipmi_dmi_get_slave_addr(type, flags,
 +						     info->io.addr_data);
 +	}
 +#endif
 +
 +	return slave_addr;
 +}
 +
 +static int acpi_ipmi_probe(struct platform_device *dev)
 +{
 +	struct smi_info *info;
 +	acpi_handle handle;
 +	acpi_status status;
 +	unsigned long long tmp;
 +	struct resource *res;
 +	int rv = -EINVAL;
 +
 +	if (!si_tryacpi)
 +		return -ENODEV;
 +
 +	handle = ACPI_HANDLE(&dev->dev);
 +	if (!handle)
 +		return -ENODEV;
 +
 +	info = smi_info_alloc();
 +	if (!info)
 +		return -ENOMEM;
 +
 +	info->addr_source = SI_ACPI;
 +	dev_info(&dev->dev, PFX "probing via ACPI\n");
 +
 +	info->addr_info.acpi_info.acpi_handle = handle;
 +
 +	/* _IFT tells us the interface type: KCS, BT, etc */
 +	status = acpi_evaluate_integer(handle, "_IFT", NULL, &tmp);
 +	if (ACPI_FAILURE(status)) {
 +		dev_err(&dev->dev, "Could not find ACPI IPMI interface type\n");
 +		goto err_free;
 +	}
 +
 +	switch (tmp) {
 +	case 1:
 +		info->si_type = SI_KCS;
 +		break;
 +	case 2:
 +		info->si_type = SI_SMIC;
 +		break;
 +	case 3:
 +		info->si_type = SI_BT;
 +		break;
 +	case 4: /* SSIF, just ignore */
 +		rv = -ENODEV;
 +		goto err_free;
 +	default:
 +		dev_info(&dev->dev, "unknown IPMI type %lld\n", tmp);
 +		goto err_free;
 +	}
 +
 +	res = ipmi_get_info_from_resources(dev, info);
 +	if (!res) {
 +		rv = -EINVAL;
 +		goto err_free;
 +	}
 +
 +	/* If _GPE exists, use it; otherwise use standard interrupts */
 +	status = acpi_evaluate_integer(handle, "_GPE", NULL, &tmp);
 +	if (ACPI_SUCCESS(status)) {
 +		info->irq = tmp;
 +		info->irq_setup = acpi_gpe_irq_setup;
 +	} else {
 +		int irq = platform_get_irq(dev, 0);
 +
 +		if (irq > 0) {
 +			info->irq = irq;
 +			info->irq_setup = std_irq_setup;
 +		}
 +	}
 +
 +	info->slave_addr = find_slave_address(info, info->slave_addr);
 +
 +	info->dev = &dev->dev;
 +	platform_set_drvdata(dev, info);
 +
 +	dev_info(info->dev, "%pR regsize %d spacing %d irq %d\n",
 +		 res, info->io.regsize, info->io.regspacing,
 +		 info->irq);
 +
 +	rv = ipmi_si_add_smi(info);
 +	if (rv)
 +		kfree(info);
 +
 +	return rv;
 +
 +err_free:
 +	kfree(info);
 +	return rv;
 +}
 +
 +static const struct acpi_device_id acpi_ipmi_match[] = {
 +	{ "IPI0001", 0 },
 +	{ },
 +};
 +MODULE_DEVICE_TABLE(acpi, acpi_ipmi_match);
 +#else
 +static int acpi_ipmi_probe(struct platform_device *dev)
 +{
 +	return -ENODEV;
 +}
 +#endif
 +
 +static int ipmi_probe(struct platform_device *dev)
 +{
 +	if (dev->dev.of_node && of_ipmi_probe(dev) == 0)
 +		return 0;
 +
 +	if (acpi_ipmi_probe(dev) == 0)
 +		return 0;
 +
 +	return dmi_ipmi_probe(dev);
 +}
 +
 +static int ipmi_remove(struct platform_device *dev)
 +{
 +	struct smi_info *info = dev_get_drvdata(&dev->dev);
 +
 +	cleanup_one_si(info);
 +	return 0;
 +}
 +
 +static struct platform_driver ipmi_driver = {
 +	.driver = {
 +		.name = DEVICE_NAME,
 +		.of_match_table = of_ipmi_match,
 +		.acpi_match_table = ACPI_PTR(acpi_ipmi_match),
 +	},
 +	.probe		= ipmi_probe,
 +	.remove		= ipmi_remove,
 +};
 +
++=======
++>>>>>>> 9d70029edbbf (ipmi_si: Move platform device handling to another file)
  #ifdef CONFIG_PARISC
 -static int __init ipmi_parisc_probe(struct parisc_device *dev)
 +static int ipmi_parisc_probe(struct parisc_device *dev)
  {
 -	struct si_sm_io io;
 +	struct smi_info *info;
 +	int rv;
  
 -	io.si_type	= SI_KCS;
 -	io.addr_source	= SI_DEVICETREE;
 -	io.addr_type	= IPMI_MEM_ADDR_SPACE;
 -	io.addr_data	= dev->hpa.start;
 -	io.regsize	= 1;
 -	io.regspacing	= 1;
 -	io.regshift	= 0;
 -	io.irq		= 0; /* no interrupt */
 -	io.irq_setup	= NULL;
 -	io.dev		= &dev->dev;
 +	info = smi_info_alloc();
  
 -	dev_dbg(&dev->dev, "addr 0x%lx\n", io.addr_data);
 +	if (!info) {
 +		dev_err(&dev->dev,
 +			"could not allocate memory for PARISC probe\n");
 +		return -ENOMEM;
 +	}
 +
 +	info->si_type		= SI_KCS;
 +	info->addr_source	= SI_DEVICETREE;
 +	info->io_setup		= mem_setup;
 +	info->io.addr_type	= IPMI_MEM_ADDR_SPACE;
 +	info->io.addr_data	= dev->hpa.start;
 +	info->io.regsize	= 1;
 +	info->io.regspacing	= 1;
 +	info->io.regshift	= 0;
 +	info->irq		= 0; /* no interrupt */
 +	info->irq_setup		= NULL;
 +	info->dev		= &dev->dev;
 +
 +	dev_dbg(&dev->dev, "addr 0x%lx\n", info->io.addr_data);
  
 -	return ipmi_si_add_smi(&io);
 +	dev_set_drvdata(&dev->dev, info);
 +
 +	rv = ipmi_si_add_smi(info);
 +	if (rv) {
 +		kfree(info);
 +		return rv;
 +	}
 +
 +	return 0;
  }
  
 -static int __exit ipmi_parisc_remove(struct parisc_device *dev)
 +static int ipmi_parisc_remove(struct parisc_device *dev)
  {
 -	return ipmi_si_remove_by_dev(&pdev->dev);
 +	cleanup_one_si(dev_get_drvdata(&dev->dev));
 +	return 0;
  }
  
 -static const struct parisc_device_id ipmi_parisc_tbl[] __initconst = {
 +static const struct parisc_device_id ipmi_parisc_tbl[] = {
  	{ HPHW_MC, HVERSION_REV_ANY_ID, 0x004, 0xC0 },
  	{ 0, }
  };
@@@ -3528,10 -2464,10 +3527,15 @@@ static int try_smi_init(struct smi_inf
  			pr_err(PFX "Unable to allocate platform device\n");
  			goto out_err;
  		}
++<<<<<<< HEAD
 +		new_smi->dev = &new_smi->pdev->dev;
 +		new_smi->dev->driver = &ipmi_driver.driver;
++=======
+ 		new_smi->io.dev = &new_smi->pdev->dev;
+ 		new_smi->io.dev->driver = &ipmi_platform_driver.driver;
++>>>>>>> 9d70029edbbf (ipmi_si: Move platform device handling to another file)
  		/* Nulled by device_add() */
 -		new_smi->io.dev->init_name = init_name;
 +		new_smi->dev->init_name = init_name;
  	}
  
  	/* Allocate the state machine's data and initialize it. */
@@@ -3731,47 -2659,15 +3735,52 @@@ static int init_ipmi_si(void
  
  	if (initialized)
  		return 0;
 +	initialized = 1;
  
 +	/* RHEL7-only - Init ipmi_shadow_smi_handlers
 +	 * The instance of struct ipmi_shadow_smi_handlers is located in
 +	 * ipmi_msghandler.c. Locating it in this file would cause a
 +	 * module dependency loop, because ipmi_msghandler would then
 +	 * depend on ipmi_si, which already depends on ipmi_msghandler.
 +	 */
 +	shadow_handlers = ipmi_get_shadow_smi_handlers();
 +	shadow_handlers->handlers = &handlers;
 +	shadow_handlers->set_need_watch = set_need_watch;
 +
++<<<<<<< HEAD
 +	if (si_tryplatform) {
 +		rv = platform_driver_register(&ipmi_driver);
 +		if (rv) {
 +			pr_err(PFX "Unable to register driver: %d\n", rv);
 +			return rv;
 +		}
 +	}
 +
 +	/* Parse out the si_type string into its components. */
 +	str = si_type_str;
 +	if (*str != '\0') {
 +		for (i = 0; (i < SI_MAX_PARMS) && (*str != '\0'); i++) {
 +			si_type[i] = str;
 +			str = strchr(str, ',');
 +			if (str) {
 +				*str = '\0';
 +				str++;
 +			} else {
 +				break;
 +			}
 +		}
 +	}
 +
++=======
++>>>>>>> 9d70029edbbf (ipmi_si: Move platform device handling to another file)
  	pr_info("IPMI System Interface driver.\n");
  
  	/* If the user gave us a device, they presumably want us to use it */
 -	if (!ipmi_si_hardcode_find_bmc())
 -		goto do_scan;
 +	if (!hardcode_find_bmc())
 +		return 0;
  
+ 	ipmi_si_platform_init();
+ 
  #ifdef CONFIG_PCI
  	if (si_trypci) {
  		rv = pci_register_driver(&ipmi_pci_driver);
* Unmerged path drivers/char/ipmi/Makefile
* Unmerged path drivers/char/ipmi/ipmi_si.h
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
diff --git a/drivers/char/ipmi/ipmi_si_platform.c b/drivers/char/ipmi/ipmi_si_platform.c
new file mode 100644
index 000000000000..cf5c3e5e72e2
--- /dev/null
+++ b/drivers/char/ipmi/ipmi_si_platform.c
@@ -0,0 +1,602 @@
+/*
+ * ipmi_si_platform.c
+ *
+ * Handling for platform devices in IPMI (ACPI, OF, and things
+ * coming from the platform.
+ */
+#include <linux/types.h>
+#include <linux/module.h>
+#include "ipmi_dmi.h"
+#include <linux/dmi.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/acpi.h>
+#include "ipmi_si.h"
+
+#define PFX "ipmi_platform: "
+
+static bool si_tryplatform = true;
+#ifdef CONFIG_ACPI
+static bool          si_tryacpi = true;
+#endif
+#ifdef CONFIG_DMI
+static bool          si_trydmi = true;
+#endif
+
+module_param_named(tryplatform, si_tryplatform, bool, 0);
+MODULE_PARM_DESC(tryplatform, "Setting this to zero will disable the"
+		 " default scan of the interfaces identified via platform"
+		 " interfaces like openfirmware");
+#ifdef CONFIG_ACPI
+module_param_named(tryacpi, si_tryacpi, bool, 0);
+MODULE_PARM_DESC(tryacpi, "Setting this to zero will disable the"
+		 " default scan of the interfaces identified via ACPI");
+#endif
+#ifdef CONFIG_DMI
+module_param_named(trydmi, si_trydmi, bool, 0);
+MODULE_PARM_DESC(trydmi, "Setting this to zero will disable the"
+		 " default scan of the interfaces identified via DMI");
+#endif
+
+#ifdef CONFIG_ACPI
+
+/*
+ * Once we get an ACPI failure, we don't try any more, because we go
+ * through the tables sequentially.  Once we don't find a table, there
+ * are no more.
+ */
+static int acpi_failure;
+
+/* For GPE-type interrupts. */
+static u32 ipmi_acpi_gpe(acpi_handle gpe_device,
+	u32 gpe_number, void *context)
+{
+	struct si_sm_io *io = context;
+
+	ipmi_si_irq_handler(io->irq, io->irq_handler_data);
+	return ACPI_INTERRUPT_HANDLED;
+}
+
+static void acpi_gpe_irq_cleanup(struct si_sm_io *io)
+{
+	if (!io->irq)
+		return;
+
+	ipmi_irq_start_cleanup(io);
+	acpi_remove_gpe_handler(NULL, io->irq, &ipmi_acpi_gpe);
+}
+
+static int acpi_gpe_irq_setup(struct si_sm_io *io)
+{
+	acpi_status status;
+
+	if (!io->irq)
+		return 0;
+
+	status = acpi_install_gpe_handler(NULL,
+					  io->irq,
+					  ACPI_GPE_LEVEL_TRIGGERED,
+					  &ipmi_acpi_gpe,
+					  io);
+	if (status != AE_OK) {
+		dev_warn(io->dev,
+			 "Unable to claim ACPI GPE %d, running polled\n",
+			 io->irq);
+		io->irq = 0;
+		return -EINVAL;
+	} else {
+		io->irq_cleanup = acpi_gpe_irq_cleanup;
+		ipmi_irq_finish_setup(io);
+		dev_info(io->dev, "Using ACPI GPE %d\n", io->irq);
+		return 0;
+	}
+}
+
+/*
+ * Defined at
+ * http://h21007.www2.hp.com/portal/download/files/unprot/hpspmi.pdf
+ */
+struct SPMITable {
+	s8	Signature[4];
+	u32	Length;
+	u8	Revision;
+	u8	Checksum;
+	s8	OEMID[6];
+	s8	OEMTableID[8];
+	s8	OEMRevision[4];
+	s8	CreatorID[4];
+	s8	CreatorRevision[4];
+	u8	InterfaceType;
+	u8	IPMIlegacy;
+	s16	SpecificationRevision;
+
+	/*
+	 * Bit 0 - SCI interrupt supported
+	 * Bit 1 - I/O APIC/SAPIC
+	 */
+	u8	InterruptType;
+
+	/*
+	 * If bit 0 of InterruptType is set, then this is the SCI
+	 * interrupt in the GPEx_STS register.
+	 */
+	u8	GPE;
+
+	s16	Reserved;
+
+	/*
+	 * If bit 1 of InterruptType is set, then this is the I/O
+	 * APIC/SAPIC interrupt.
+	 */
+	u32	GlobalSystemInterrupt;
+
+	/* The actual register address. */
+	struct acpi_generic_address addr;
+
+	u8	UID[4];
+
+	s8      spmi_id[1]; /* A '\0' terminated array starts here. */
+};
+
+static int try_init_spmi(struct SPMITable *spmi)
+{
+	struct si_sm_io io;
+
+	if (spmi->IPMIlegacy != 1) {
+		pr_info(PFX "Bad SPMI legacy %d\n", spmi->IPMIlegacy);
+		return -ENODEV;
+	}
+
+	memset(&io, 0, sizeof(io));
+	io.addr_source = SI_SPMI;
+	pr_info(PFX "probing via SPMI\n");
+
+	/* Figure out the interface type. */
+	switch (spmi->InterfaceType) {
+	case 1:	/* KCS */
+		io.si_type = SI_KCS;
+		break;
+	case 2:	/* SMIC */
+		io.si_type = SI_SMIC;
+		break;
+	case 3:	/* BT */
+		io.si_type = SI_BT;
+		break;
+	case 4: /* SSIF, just ignore */
+		return -EIO;
+	default:
+		pr_info(PFX "Unknown ACPI/SPMI SI type %d\n",
+			spmi->InterfaceType);
+		return -EIO;
+	}
+
+	if (spmi->InterruptType & 1) {
+		/* We've got a GPE interrupt. */
+		io.irq = spmi->GPE;
+		io.irq_setup = acpi_gpe_irq_setup;
+	} else if (spmi->InterruptType & 2) {
+		/* We've got an APIC/SAPIC interrupt. */
+		io.irq = spmi->GlobalSystemInterrupt;
+		io.irq_setup = ipmi_std_irq_setup;
+	} else {
+		/* Use the default interrupt setting. */
+		io.irq = 0;
+		io.irq_setup = NULL;
+	}
+
+	if (spmi->addr.bit_width) {
+		/* A (hopefully) properly formed register bit width. */
+		io.regspacing = spmi->addr.bit_width / 8;
+	} else {
+		io.regspacing = DEFAULT_REGSPACING;
+	}
+	io.regsize = io.regspacing;
+	io.regshift = spmi->addr.bit_offset;
+
+	if (spmi->addr.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {
+		io.addr_type = IPMI_MEM_ADDR_SPACE;
+	} else if (spmi->addr.space_id == ACPI_ADR_SPACE_SYSTEM_IO) {
+		io.addr_type = IPMI_IO_ADDR_SPACE;
+	} else {
+		pr_warn(PFX "Unknown ACPI I/O Address type\n");
+		return -EIO;
+	}
+	io.addr_data = spmi->addr.address;
+
+	pr_info("ipmi_si: SPMI: %s %#lx regsize %d spacing %d irq %d\n",
+		(io.addr_type == IPMI_IO_ADDR_SPACE) ? "io" : "mem",
+		io.addr_data, io.regsize, io.regspacing, io.irq);
+
+	return ipmi_si_add_smi(&io);
+}
+
+static void spmi_find_bmc(void)
+{
+	acpi_status      status;
+	struct SPMITable *spmi;
+	int              i;
+
+	if (acpi_disabled)
+		return;
+
+	if (acpi_failure)
+		return;
+
+	for (i = 0; ; i++) {
+		status = acpi_get_table(ACPI_SIG_SPMI, i+1,
+					(struct acpi_table_header **)&spmi);
+		if (status != AE_OK)
+			return;
+
+		try_init_spmi(spmi);
+	}
+}
+#endif
+
+#if defined(CONFIG_DMI) || defined(CONFIG_ACPI)
+static struct resource *
+ipmi_get_info_from_resources(struct platform_device *pdev,
+			     struct si_sm_io *io)
+{
+	struct resource *res, *res_second;
+
+	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+	if (res) {
+		io->addr_type = IPMI_IO_ADDR_SPACE;
+	} else {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (res)
+			io->addr_type = IPMI_MEM_ADDR_SPACE;
+	}
+	if (!res) {
+		dev_err(&pdev->dev, "no I/O or memory address\n");
+		return NULL;
+	}
+	io->addr_data = res->start;
+
+	io->regspacing = DEFAULT_REGSPACING;
+	res_second = platform_get_resource(pdev,
+			       (io->addr_type == IPMI_IO_ADDR_SPACE) ?
+					IORESOURCE_IO : IORESOURCE_MEM,
+			       1);
+	if (res_second) {
+		if (res_second->start > io->addr_data)
+			io->regspacing = res_second->start - io->addr_data;
+	}
+	io->regsize = DEFAULT_REGSIZE;
+	io->regshift = 0;
+
+	return res;
+}
+
+#endif
+
+#ifdef CONFIG_DMI
+static int dmi_ipmi_probe(struct platform_device *pdev)
+{
+	struct si_sm_io io;
+	u8 type, slave_addr;
+	int rv;
+
+	if (!si_trydmi)
+		return -ENODEV;
+
+	rv = device_property_read_u8(&pdev->dev, "ipmi-type", &type);
+	if (rv)
+		return -ENODEV;
+
+	memset(&io, 0, sizeof(io));
+	io.addr_source = SI_SMBIOS;
+	pr_info(PFX "probing via SMBIOS\n");
+
+	switch (type) {
+	case IPMI_DMI_TYPE_KCS:
+		io.si_type = SI_KCS;
+		break;
+	case IPMI_DMI_TYPE_SMIC:
+		io.si_type = SI_SMIC;
+		break;
+	case IPMI_DMI_TYPE_BT:
+		io.si_type = SI_BT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (!ipmi_get_info_from_resources(pdev, &io)) {
+		rv = -EINVAL;
+		goto err_free;
+	}
+
+	rv = device_property_read_u8(&pdev->dev, "slave-addr", &slave_addr);
+	if (rv) {
+		dev_warn(&pdev->dev, "device has no slave-addr property");
+		io.slave_addr = 0x20;
+	} else {
+		io.slave_addr = slave_addr;
+	}
+
+	io.irq = platform_get_irq(pdev, 0);
+	if (io.irq > 0)
+		io.irq_setup = ipmi_std_irq_setup;
+	else
+		io.irq = 0;
+
+	io.dev = &pdev->dev;
+
+	pr_info("ipmi_si: SMBIOS: %s %#lx regsize %d spacing %d irq %d\n",
+		(io.addr_type == IPMI_IO_ADDR_SPACE) ? "io" : "mem",
+		io.addr_data, io.regsize, io.regspacing, io.irq);
+
+	ipmi_si_add_smi(&io);
+
+	return 0;
+
+err_free:
+	return rv;
+}
+#else
+static int dmi_ipmi_probe(struct platform_device *pdev)
+{
+	return -ENODEV;
+}
+#endif /* CONFIG_DMI */
+
+#ifdef CONFIG_OF
+static const struct of_device_id of_ipmi_match[] = {
+	{ .type = "ipmi", .compatible = "ipmi-kcs",
+	  .data = (void *)(unsigned long) SI_KCS },
+	{ .type = "ipmi", .compatible = "ipmi-smic",
+	  .data = (void *)(unsigned long) SI_SMIC },
+	{ .type = "ipmi", .compatible = "ipmi-bt",
+	  .data = (void *)(unsigned long) SI_BT },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_ipmi_match);
+
+static int of_ipmi_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *match;
+	struct si_sm_io io;
+	struct resource resource;
+	const __be32 *regsize, *regspacing, *regshift;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+	int proplen;
+
+	dev_info(&pdev->dev, "probing via device tree\n");
+
+	match = of_match_device(of_ipmi_match, &pdev->dev);
+	if (!match)
+		return -ENODEV;
+
+	if (!of_device_is_available(np))
+		return -EINVAL;
+
+	ret = of_address_to_resource(np, 0, &resource);
+	if (ret) {
+		dev_warn(&pdev->dev, PFX "invalid address from OF\n");
+		return ret;
+	}
+
+	regsize = of_get_property(np, "reg-size", &proplen);
+	if (regsize && proplen != 4) {
+		dev_warn(&pdev->dev, PFX "invalid regsize from OF\n");
+		return -EINVAL;
+	}
+
+	regspacing = of_get_property(np, "reg-spacing", &proplen);
+	if (regspacing && proplen != 4) {
+		dev_warn(&pdev->dev, PFX "invalid regspacing from OF\n");
+		return -EINVAL;
+	}
+
+	regshift = of_get_property(np, "reg-shift", &proplen);
+	if (regshift && proplen != 4) {
+		dev_warn(&pdev->dev, PFX "invalid regshift from OF\n");
+		return -EINVAL;
+	}
+
+	memset(&io, 0, sizeof(io));
+	io.si_type	= (enum si_type) match->data;
+	io.addr_source	= SI_DEVICETREE;
+	io.irq_setup	= ipmi_std_irq_setup;
+
+	if (resource.flags & IORESOURCE_IO)
+		io.addr_type = IPMI_IO_ADDR_SPACE;
+	else
+		io.addr_type = IPMI_MEM_ADDR_SPACE;
+
+	io.addr_data	= resource.start;
+
+	io.regsize	= regsize ? be32_to_cpup(regsize) : DEFAULT_REGSIZE;
+	io.regspacing	= regspacing ? be32_to_cpup(regspacing) : DEFAULT_REGSPACING;
+	io.regshift	= regshift ? be32_to_cpup(regshift) : 0;
+
+	io.irq		= irq_of_parse_and_map(pdev->dev.of_node, 0);
+	io.dev		= &pdev->dev;
+
+	dev_dbg(&pdev->dev, "addr 0x%lx regsize %d spacing %d irq %d\n",
+		io.addr_data, io.regsize, io.regspacing, io.irq);
+
+	return ipmi_si_add_smi(&io);
+}
+#else
+#define of_ipmi_match NULL
+static int of_ipmi_probe(struct platform_device *dev)
+{
+	return -ENODEV;
+}
+#endif
+
+#ifdef CONFIG_ACPI
+static int find_slave_address(struct si_sm_io *io, int slave_addr)
+{
+#ifdef CONFIG_IPMI_DMI_DECODE
+	if (!slave_addr) {
+		int type = -1;
+		u32 flags = IORESOURCE_IO;
+
+		switch (io->si_type) {
+		case SI_KCS:
+			type = IPMI_DMI_TYPE_KCS;
+			break;
+		case SI_BT:
+			type = IPMI_DMI_TYPE_BT;
+			break;
+		case SI_SMIC:
+			type = IPMI_DMI_TYPE_SMIC;
+			break;
+		}
+
+		if (io->addr_type == IPMI_MEM_ADDR_SPACE)
+			flags = IORESOURCE_MEM;
+
+		slave_addr = ipmi_dmi_get_slave_addr(type, flags,
+						     io->addr_data);
+	}
+#endif
+
+	return slave_addr;
+}
+
+static int acpi_ipmi_probe(struct platform_device *pdev)
+{
+	struct si_sm_io io;
+	acpi_handle handle;
+	acpi_status status;
+	unsigned long long tmp;
+	struct resource *res;
+	int rv = -EINVAL;
+
+	if (!si_tryacpi)
+		return -ENODEV;
+
+	handle = ACPI_HANDLE(&pdev->dev);
+	if (!handle)
+		return -ENODEV;
+
+	memset(&io, 0, sizeof(io));
+	io.addr_source = SI_ACPI;
+	dev_info(&pdev->dev, PFX "probing via ACPI\n");
+
+	io.addr_info.acpi_info.acpi_handle = handle;
+
+	/* _IFT tells us the interface type: KCS, BT, etc */
+	status = acpi_evaluate_integer(handle, "_IFT", NULL, &tmp);
+	if (ACPI_FAILURE(status)) {
+		dev_err(&pdev->dev,
+			"Could not find ACPI IPMI interface type\n");
+		goto err_free;
+	}
+
+	switch (tmp) {
+	case 1:
+		io.si_type = SI_KCS;
+		break;
+	case 2:
+		io.si_type = SI_SMIC;
+		break;
+	case 3:
+		io.si_type = SI_BT;
+		break;
+	case 4: /* SSIF, just ignore */
+		rv = -ENODEV;
+		goto err_free;
+	default:
+		dev_info(&pdev->dev, "unknown IPMI type %lld\n", tmp);
+		goto err_free;
+	}
+
+	res = ipmi_get_info_from_resources(pdev, &io);
+	if (!res) {
+		rv = -EINVAL;
+		goto err_free;
+	}
+
+	/* If _GPE exists, use it; otherwise use standard interrupts */
+	status = acpi_evaluate_integer(handle, "_GPE", NULL, &tmp);
+	if (ACPI_SUCCESS(status)) {
+		io.irq = tmp;
+		io.irq_setup = acpi_gpe_irq_setup;
+	} else {
+		int irq = platform_get_irq(pdev, 0);
+
+		if (irq > 0) {
+			io.irq = irq;
+			io.irq_setup = ipmi_std_irq_setup;
+		}
+	}
+
+	io.slave_addr = find_slave_address(&io, io.slave_addr);
+
+	io.dev = &pdev->dev;
+
+	dev_info(io.dev, "%pR regsize %d spacing %d irq %d\n",
+		 res, io.regsize, io.regspacing, io.irq);
+
+	return ipmi_si_add_smi(&io);
+
+err_free:
+	return rv;
+}
+
+static const struct acpi_device_id acpi_ipmi_match[] = {
+	{ "IPI0001", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, acpi_ipmi_match);
+#else
+static int acpi_ipmi_probe(struct platform_device *dev)
+{
+	return -ENODEV;
+}
+#endif
+
+static int ipmi_probe(struct platform_device *pdev)
+{
+	if (pdev->dev.of_node && of_ipmi_probe(pdev) == 0)
+		return 0;
+
+	if (acpi_ipmi_probe(pdev) == 0)
+		return 0;
+
+	return dmi_ipmi_probe(pdev);
+}
+
+static int ipmi_remove(struct platform_device *pdev)
+{
+	return ipmi_si_remove_by_dev(&pdev->dev);
+}
+
+struct platform_driver ipmi_platform_driver = {
+	.driver = {
+		.name = DEVICE_NAME,
+		.of_match_table = of_ipmi_match,
+		.acpi_match_table = ACPI_PTR(acpi_ipmi_match),
+	},
+	.probe		= ipmi_probe,
+	.remove		= ipmi_remove,
+};
+
+void ipmi_si_platform_init(void)
+{
+	if (si_tryplatform) {
+		int rv = platform_driver_register(&ipmi_platform_driver);
+		if (rv)
+			pr_err(PFX "Unable to register driver: %d\n", rv);
+	}
+
+#ifdef CONFIG_ACPI
+	if (si_tryacpi)
+		spmi_find_bmc();
+#endif
+
+}
+
+void ipmi_si_platform_shutdown(void)
+{
+	platform_driver_unregister(&ipmi_platform_driver);
+}
