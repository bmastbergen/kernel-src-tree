netfilter: ipset: Support extensions which need a per data destroy function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 40cd63bf33b21ef4d43776b1d49c605f876fe32c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/40cd63bf.failed

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 40cd63bf33b21ef4d43776b1d49c605f876fe32c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/ipset/ip_set.h
#	net/netfilter/ipset/ip_set_bitmap_gen.h
#	net/netfilter/ipset/ip_set_hash_gen.h
#	net/netfilter/ipset/ip_set_list_set.c
diff --cc include/linux/netfilter/ipset/ip_set.h
index 1309bde24e27,6372ee224fe8..000000000000
--- a/include/linux/netfilter/ipset/ip_set.h
+++ b/include/linux/netfilter/ipset/ip_set.h
@@@ -66,14 -68,45 +68,53 @@@ enum ip_set_ext_id 
  	IPSET_EXT_ID_MAX,
  };
  
++<<<<<<< HEAD
++=======
+ /* Extension type */
+ struct ip_set_ext_type {
+ 	/* Destroy extension private data (can be NULL) */
+ 	void (*destroy)(void *ext);
+ 	enum ip_set_extension type;
+ 	enum ipset_cadt_flags flag;
+ 	/* Size and minimal alignment */
+ 	u8 len;
+ 	u8 align;
+ };
+ 
+ extern const struct ip_set_ext_type ip_set_extensions[];
+ 
++>>>>>>> 40cd63bf33b2 (netfilter: ipset: Support extensions which need a per data destroy function)
  struct ip_set_ext {
  	u64 packets;
  	u64 bytes;
  	u32 timeout;
  };
  
++<<<<<<< HEAD
 +struct ip_set;
 +
++=======
+ struct ip_set_counter {
+ 	atomic64_t bytes;
+ 	atomic64_t packets;
+ };
+ 
+ struct ip_set;
+ 
+ static inline void
+ ip_set_ext_destroy(struct ip_set *set, void *data)
+ {
+ 	/* Check that the extension is enabled for the set and
+ 	 * call it's destroy function for its extension part in data.
+ 	 */
+ }
+ 
+ #define ext_timeout(e, s)	\
+ (unsigned long *)(((void *)(e)) + (s)->offset[IPSET_EXT_ID_TIMEOUT])
+ #define ext_counter(e, s)	\
+ (struct ip_set_counter *)(((void *)(e)) + (s)->offset[IPSET_EXT_ID_COUNTER])
+ 
++>>>>>>> 40cd63bf33b2 (netfilter: ipset: Support extensions which need a per data destroy function)
  typedef int (*ipset_adtfn)(struct ip_set *set, void *value,
  			   const struct ip_set_ext *ext,
  			   struct ip_set_ext *mext, u32 cmdflags);
diff --cc net/netfilter/ipset/ip_set_bitmap_gen.h
index 01a340ce9e94,4515fe8b83dd..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_gen.h
+++ b/net/netfilter/ipset/ip_set_bitmap_gen.h
@@@ -59,8 -67,11 +71,15 @@@ mtype_destroy(struct ip_set *set
  		del_timer_sync(&map->gc);
  
  	ip_set_free(map->members);
++<<<<<<< HEAD
 +	if (map->dsize)
++=======
+ 	if (set->dsize) {
+ 		if (set->extensions & IPSET_EXT_DESTROY)
+ 			mtype_ext_cleanup(set);
++>>>>>>> 40cd63bf33b2 (netfilter: ipset: Support extensions which need a per data destroy function)
  		ip_set_free(map->extensions);
+ 	}
  	kfree(map);
  
  	set->data = NULL;
@@@ -156,11 -171,14 +179,22 @@@ mtype_del(struct ip_set *set, void *val
  {
  	struct mtype *map = set->data;
  	const struct mtype_adt_elem *e = value;
++<<<<<<< HEAD
 +	const void *x = get_ext(map, e->id);
 +
 +	if (mtype_do_del(e, map) ||
 +	    (SET_WITH_TIMEOUT(set) &&
 +	     ip_set_timeout_expired(ext_timeout(x, map))))
++=======
+ 	void *x = get_ext(set, map, e->id);
+ 
+ 	if (mtype_do_del(e, map))
+ 		return -IPSET_ERR_EXIST;
+ 
+ 	ip_set_ext_destroy(set, x);
+ 	if (SET_WITH_TIMEOUT(set) &&
+ 	    ip_set_timeout_expired(ext_timeout(x, set)))
++>>>>>>> 40cd63bf33b2 (netfilter: ipset: Support extensions which need a per data destroy function)
  		return -IPSET_ERR_EXIST;
  
  	return 0;
@@@ -245,10 -264,12 +279,18 @@@ mtype_gc(unsigned long ul_set
  	 * but adding/deleting new entries is locked out */
  	read_lock_bh(&set->lock);
  	for (id = 0; id < map->elements; id++)
++<<<<<<< HEAD
 +		if (mtype_gc_test(id, map)) {
 +			x = get_ext(map, id);
 +			if (ip_set_timeout_expired(ext_timeout(x, map)))
++=======
+ 		if (mtype_gc_test(id, map, set->dsize)) {
+ 			x = get_ext(set, map, id);
+ 			if (ip_set_timeout_expired(ext_timeout(x, set))) {
++>>>>>>> 40cd63bf33b2 (netfilter: ipset: Support extensions which need a per data destroy function)
  				clear_bit(id, map->members);
+ 				ip_set_ext_destroy(set, x);
+ 			}
  		}
  	read_unlock_bh(&set->lock);
  
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index acd02e6a3233,3c26e5b946f5..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -396,7 -414,7 +418,11 @@@ mtype_destroy(struct ip_set *set
  	if (set->extensions & IPSET_EXT_TIMEOUT)
  		del_timer_sync(&h->gc);
  
++<<<<<<< HEAD
 +	ahash_destroy(h->table);
++=======
+ 	mtype_ahash_destroy(set, rcu_dereference_bh_nfnl(h->table));
++>>>>>>> 40cd63bf33b2 (netfilter: ipset: Support extensions which need a per data destroy function)
  #ifdef IP_SET_HASH_WITH_RBTREE
  	rbtree_destroy(&h->rbtree);
  #endif
@@@ -434,15 -452,11 +460,11 @@@ mtype_same_set(const struct ip_set *a, 
  	       a->extensions == b->extensions;
  }
  
- /* Get the ith element from the array block n */
- #define ahash_data(n, i, dsize)	\
- 	((struct mtype_elem *)((n)->value + ((i) * (dsize))))
- 
  /* Delete expired elements from the hashtable */
  static void
 -mtype_expire(struct ip_set *set, struct htype *h, u8 nets_length, size_t dsize)
 +mtype_expire(struct htype *h, u8 nets_length, size_t dsize)
  {
 -	struct htable *t;
 +	struct htable *t = h->table;
  	struct hbucket *n;
  	struct mtype_elem *data;
  	u32 i;
@@@ -456,8 -472,9 +478,9 @@@
  				pr_debug("expired %u/%u\n", i, j);
  #ifdef IP_SET_HASH_WITH_NETS
  				mtype_del_cidr(h, CIDR(data->cidr),
 -					       nets_length, 0);
 +					       nets_length);
  #endif
+ 				ip_set_ext_destroy(set, data);
  				if (j != n->pos - 1)
  					/* Not last one */
  					memcpy(data,
@@@ -639,11 -656,12 +662,12 @@@ mtype_add(struct ip_set *set, void *val
  reuse_slot:
  	if (j != AHASH_MAX(h) + 1) {
  		/* Fill out reused slot */
 -		data = ahash_data(n, j, set->dsize);
 +		data = ahash_data(n, j, h->dsize);
  #ifdef IP_SET_HASH_WITH_NETS
 -		mtype_del_cidr(h, CIDR(data->cidr), NLEN(set->family), 0);
 -		mtype_add_cidr(h, CIDR(d->cidr), NLEN(set->family), 0);
 +		mtype_del_cidr(h, CIDR(data->cidr), NETS_LENGTH(set->family));
 +		mtype_add_cidr(h, CIDR(d->cidr), NETS_LENGTH(set->family));
  #endif
+ 		ip_set_ext_destroy(set, data);
  	} else {
  		/* Use/create a new slot */
  		TUNE_AHASH_MAX(h, multi);
@@@ -705,16 -725,19 +729,17 @@@ mtype_del(struct ip_set *set, void *val
  		n->pos--;
  		h->elements--;
  #ifdef IP_SET_HASH_WITH_NETS
 -		mtype_del_cidr(h, CIDR(d->cidr), NLEN(set->family), 0);
 +		mtype_del_cidr(h, CIDR(d->cidr), NETS_LENGTH(set->family));
  #endif
+ 		ip_set_ext_destroy(set, data);
  		if (n->pos + AHASH_INIT_SIZE < n->size) {
  			void *tmp = kzalloc((n->size - AHASH_INIT_SIZE)
 -					    * set->dsize,
 +					    * h->dsize,
  					    GFP_ATOMIC);
 -			if (!tmp) {
 -				ret = 0;
 -				goto out;
 -			}
 +			if (!tmp)
 +				return 0;
  			n->size -= AHASH_INIT_SIZE;
 -			memcpy(tmp, n->value, n->size * set->dsize);
 +			memcpy(tmp, n->value, n->size * h->dsize);
  			kfree(n->value);
  			n->value = tmp;
  		}
@@@ -1017,91 -1050,27 +1042,95 @@@ IPSET_TOKEN(HTYPE, _create)(struct net 
  		kfree(h);
  		return -ENOMEM;
  	}
 -	t->htable_bits = hbits;
 -	rcu_assign_pointer(h->table, t);
 +	h->table->htable_bits = hbits;
  
  	set->data = h;
++<<<<<<< HEAD
 +	if (set->family ==  NFPROTO_IPV4)
++=======
+ 	if (set->family == NFPROTO_IPV4) {
++>>>>>>> 40cd63bf33b2 (netfilter: ipset: Support extensions which need a per data destroy function)
  		set->variant = &IPSET_TOKEN(HTYPE, 4_variant);
 -		set->dsize = ip_set_elem_len(set, tb,
 -				sizeof(struct IPSET_TOKEN(HTYPE, 4_elem)));
 -	} else {
 +	else
  		set->variant = &IPSET_TOKEN(HTYPE, 6_variant);
 -		set->dsize = ip_set_elem_len(set, tb,
 -				sizeof(struct IPSET_TOKEN(HTYPE, 6_elem)));
 -	}
 -	if (tb[IPSET_ATTR_TIMEOUT]) {
 -		set->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 -		if (set->family == NFPROTO_IPV4)
 +
 +	if (tb[IPSET_ATTR_CADT_FLAGS])
 +		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
 +	if (cadt_flags & IPSET_FLAG_WITH_COUNTERS) {
 +		set->extensions |= IPSET_EXT_COUNTER;
 +		if (tb[IPSET_ATTR_TIMEOUT]) {
 +			h->timeout =
 +				ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 +			set->extensions |= IPSET_EXT_TIMEOUT;
 +			if (set->family == NFPROTO_IPV4) {
 +				h->dsize = sizeof(struct
 +					IPSET_TOKEN(HTYPE, 4ct_elem));
 +				h->offset[IPSET_EXT_ID_TIMEOUT] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 4ct_elem),
 +						timeout);
 +				h->offset[IPSET_EXT_ID_COUNTER] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 4ct_elem),
 +						counter);
 +				IPSET_TOKEN(HTYPE, 4_gc_init)(set,
 +					IPSET_TOKEN(HTYPE, 4_gc));
 +			} else {
 +				h->dsize = sizeof(struct
 +					IPSET_TOKEN(HTYPE, 6ct_elem));
 +				h->offset[IPSET_EXT_ID_TIMEOUT] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 6ct_elem),
 +						timeout);
 +				h->offset[IPSET_EXT_ID_COUNTER] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 6ct_elem),
 +						counter);
 +				IPSET_TOKEN(HTYPE, 6_gc_init)(set,
 +					IPSET_TOKEN(HTYPE, 6_gc));
 +			}
 +		} else {
 +			if (set->family == NFPROTO_IPV4) {
 +				h->dsize =
 +					sizeof(struct
 +						IPSET_TOKEN(HTYPE, 4c_elem));
 +				h->offset[IPSET_EXT_ID_COUNTER] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 4c_elem),
 +						counter);
 +			} else {
 +				h->dsize =
 +					sizeof(struct
 +						IPSET_TOKEN(HTYPE, 6c_elem));
 +				h->offset[IPSET_EXT_ID_COUNTER] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 6c_elem),
 +						counter);
 +			}
 +		}
 +	} else if (tb[IPSET_ATTR_TIMEOUT]) {
 +		h->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 +		set->extensions |= IPSET_EXT_TIMEOUT;
 +		if (set->family == NFPROTO_IPV4) {
 +			h->dsize = sizeof(struct IPSET_TOKEN(HTYPE, 4t_elem));
 +			h->offset[IPSET_EXT_ID_TIMEOUT] =
 +				offsetof(struct IPSET_TOKEN(HTYPE, 4t_elem),
 +					 timeout);
  			IPSET_TOKEN(HTYPE, 4_gc_init)(set,
  				IPSET_TOKEN(HTYPE, 4_gc));
 -		else
 +		} else {
 +			h->dsize = sizeof(struct IPSET_TOKEN(HTYPE, 6t_elem));
 +			h->offset[IPSET_EXT_ID_TIMEOUT] =
 +				offsetof(struct IPSET_TOKEN(HTYPE, 6t_elem),
 +					 timeout);
  			IPSET_TOKEN(HTYPE, 6_gc_init)(set,
  				IPSET_TOKEN(HTYPE, 6_gc));
 +		}
 +	} else {
 +		if (set->family == NFPROTO_IPV4)
 +			h->dsize = sizeof(struct IPSET_TOKEN(HTYPE, 4_elem));
 +		else
 +			h->dsize = sizeof(struct IPSET_TOKEN(HTYPE, 6_elem));
  	}
  
  	pr_debug("create %s hashsize %u (%u) maxelem %u: %p(%p)\n",
diff --cc net/netfilter/ipset/ip_set_list_set.c
index a9a97c07ecb4,e44986af1fc2..000000000000
--- a/net/netfilter/ipset/ip_set_list_set.c
+++ b/net/netfilter/ipset/ip_set_list_set.c
@@@ -200,20 -165,24 +200,36 @@@ list_set_add(struct ip_set *set, u32 i
  	     const struct ip_set_ext *ext)
  {
  	struct list_set *map = set->data;
 -	struct set_elem *e = list_set_elem(set, map, i);
 +	struct set_elem *e = list_set_elem(map, i);
  
  	if (e->id != IPSET_INVALID_ID) {
- 		if (i == map->size - 1)
+ 		if (i == map->size - 1) {
  			/* Last element replaced: e.g. add new,before,last */
++<<<<<<< HEAD
 +			ip_set_put_byindex(map->net, e->id);
 +		else {
 +			struct set_elem *x = list_set_elem(map, map->size - 1);
 +
 +			/* Last element pushed off */
 +			if (x->id != IPSET_INVALID_ID)
 +				ip_set_put_byindex(map->net, x->id);
 +			memmove(list_set_elem(map, i + 1), e,
 +				map->dsize * (map->size - (i + 1)));
++=======
+ 			ip_set_put_byindex(e->id);
+ 			ip_set_ext_destroy(set, e);
+ 		} else {
+ 			struct set_elem *x = list_set_elem(set, map,
+ 							   map->size - 1);
+ 
+ 			/* Last element pushed off */
+ 			if (x->id != IPSET_INVALID_ID) {
+ 				ip_set_put_byindex(x->id);
+ 				ip_set_ext_destroy(set, x);
+ 			}
+ 			memmove(list_set_elem(set, map, i + 1), e,
+ 				set->dsize * (map->size - (i + 1)));
++>>>>>>> 40cd63bf33b2 (netfilter: ipset: Support extensions which need a per data destroy function)
  		}
  	}
  
@@@ -229,16 -198,17 +245,21 @@@ static in
  list_set_del(struct ip_set *set, u32 i)
  {
  	struct list_set *map = set->data;
 -	struct set_elem *e = list_set_elem(set, map, i);
 +	struct set_elem *e = list_set_elem(map, i);
  
++<<<<<<< HEAD
 +	ip_set_put_byindex(map->net, e->id);
++=======
+ 	ip_set_put_byindex(e->id);
+ 	ip_set_ext_destroy(set, e);
++>>>>>>> 40cd63bf33b2 (netfilter: ipset: Support extensions which need a per data destroy function)
  
  	if (i < map->size - 1)
 -		memmove(e, list_set_elem(set, map, i + 1),
 -			set->dsize * (map->size - (i + 1)));
 +		memmove(e, list_set_elem(map, i + 1),
 +			map->dsize * (map->size - (i + 1)));
  
  	/* Last element */
 -	e = list_set_elem(set, map, map->size - 1);
 +	e = list_set_elem(map, map->size - 1);
  	e->id = IPSET_INVALID_ID;
  	return 0;
  }
@@@ -300,14 -270,14 +321,20 @@@ list_set_uadd(struct ip_set *set, void 
  	bool flag_exist = flags & IPSET_FLAG_EXIST;
  	u32 i, ret = 0;
  
+ 	if (SET_WITH_TIMEOUT(set))
+ 		set_cleanup_entries(set);
+ 
  	/* Check already added element */
  	for (i = 0; i < map->size; i++) {
 -		e = list_set_elem(set, map, i);
 +		e = list_set_elem(map, i);
  		if (e->id == IPSET_INVALID_ID)
  			goto insert;
++<<<<<<< HEAD
 +		else if (SET_WITH_TIMEOUT(set) &&
 +			 ip_set_timeout_expired(ext_timeout(e, map)))
 +			continue;
++=======
++>>>>>>> 40cd63bf33b2 (netfilter: ipset: Support extensions which need a per data destroy function)
  		else if (e->id != d->id)
  			continue;
  
@@@ -320,12 -290,14 +347,14 @@@
  			/* Can't re-add */
  			return -IPSET_ERR_EXIST;
  		/* Update extensions */
+ 		ip_set_ext_destroy(set, e);
+ 
  		if (SET_WITH_TIMEOUT(set))
 -			ip_set_timeout_set(ext_timeout(e, set), ext->timeout);
 +			ip_set_timeout_set(ext_timeout(e, map), ext->timeout);
  		if (SET_WITH_COUNTER(set))
 -			ip_set_init_counter(ext_counter(e, set), ext);
 +			ip_set_init_counter(ext_counter(e, map), ext);
  		/* Set is already added to the list */
 -		ip_set_put_byindex(d->id);
 +		ip_set_put_byindex(map->net, d->id);
  		return 0;
  	}
  insert:
@@@ -456,9 -426,10 +485,14 @@@ list_set_flush(struct ip_set *set
  	u32 i;
  
  	for (i = 0; i < map->size; i++) {
 -		e = list_set_elem(set, map, i);
 +		e = list_set_elem(map, i);
  		if (e->id != IPSET_INVALID_ID) {
++<<<<<<< HEAD
 +			ip_set_put_byindex(map->net, e->id);
++=======
+ 			ip_set_put_byindex(e->id);
+ 			ip_set_ext_destroy(set, e);
++>>>>>>> 40cd63bf33b2 (netfilter: ipset: Support extensions which need a per data destroy function)
  			e->id = IPSET_INVALID_ID;
  		}
  	}
* Unmerged path include/linux/netfilter/ipset/ip_set.h
* Unmerged path net/netfilter/ipset/ip_set_bitmap_gen.h
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
* Unmerged path net/netfilter/ipset/ip_set_list_set.c
