RDMA/bnxt_re: Avoid system hang during device un-reg

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [infiniband] rdma/bnxt_re: Avoid system hang during device (Selvin Xavier) [1547353]
Rebuild_FUZZ: 92.78%
commit-author Selvin Xavier <selvin.xavier@broadcom.com>
commit 7374fbd9e167ddc4f380d056ca74518be5d45518
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7374fbd9.failed

BNXT_RE_FLAG_TASK_IN_PROG doesn't handle multiple work
requests posted together. Track schedule of multiple
workqueue items by maintaining a per device counter
and proceed with IB dereg only if this counter is zero.
flush_workqueue is no longer required from
NETDEV_UNREGISTER path.

	Signed-off-by: Selvin Xavier <selvin.xavier@broadcom.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 7374fbd9e167ddc4f380d056ca74518be5d45518)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/bnxt_re/bnxt_re.h
diff --cc drivers/infiniband/hw/bnxt_re/bnxt_re.h
index ecbac91b2e14,3eb7a8387116..000000000000
--- a/drivers/infiniband/hw/bnxt_re/bnxt_re.h
+++ b/drivers/infiniband/hw/bnxt_re/bnxt_re.h
@@@ -99,7 -120,7 +99,11 @@@ struct bnxt_re_dev 
  #define BNXT_RE_FLAG_HAVE_L2_REF		3
  #define BNXT_RE_FLAG_RCFW_CHANNEL_EN		4
  #define BNXT_RE_FLAG_QOS_WORK_REG		5
++<<<<<<< HEAD
 +#define BNXT_RE_FLAG_TASK_IN_PROG		6
++=======
+ #define BNXT_RE_FLAG_ISSUE_ROCE_STATS          29
++>>>>>>> 7374fbd9e167 (RDMA/bnxt_re: Avoid system hang during device un-reg)
  	struct net_device		*netdev;
  	unsigned int			version, major, minor;
  	struct bnxt_en_dev		*en_dev;
* Unmerged path drivers/infiniband/hw/bnxt_re/bnxt_re.h
diff --git a/drivers/infiniband/hw/bnxt_re/main.c b/drivers/infiniband/hw/bnxt_re/main.c
index d2198af6a38d..a3abc0a92b50 100644
--- a/drivers/infiniband/hw/bnxt_re/main.c
+++ b/drivers/infiniband/hw/bnxt_re/main.c
@@ -556,7 +556,6 @@ static void bnxt_re_dev_remove(struct bnxt_re_dev *rdev)
 	mutex_unlock(&bnxt_re_dev_lock);
 
 	synchronize_rcu();
-	flush_workqueue(bnxt_re_wq);
 
 	ib_dealloc_device(&rdev->ibdev);
 	/* rdev is gone */
@@ -1255,7 +1254,7 @@ static void bnxt_re_task(struct work_struct *work)
 		break;
 	}
 	smp_mb__before_atomic();
-	clear_bit(BNXT_RE_FLAG_TASK_IN_PROG, &rdev->flags);
+	atomic_dec(&rdev->sched_count);
 	kfree(re_work);
 }
 
@@ -1317,7 +1316,7 @@ static int bnxt_re_netdev_event(struct notifier_block *notifier,
 		/* netdev notifier will call NETDEV_UNREGISTER again later since
 		 * we are still holding the reference to the netdev
 		 */
-		if (test_bit(BNXT_RE_FLAG_TASK_IN_PROG, &rdev->flags))
+		if (atomic_read(&rdev->sched_count) > 0)
 			goto exit;
 		bnxt_re_ib_unreg(rdev, false);
 		bnxt_re_remove_one(rdev);
@@ -1337,7 +1336,7 @@ static int bnxt_re_netdev_event(struct notifier_block *notifier,
 			re_work->vlan_dev = (real_dev == netdev ?
 					     NULL : netdev);
 			INIT_WORK(&re_work->work, bnxt_re_task);
-			set_bit(BNXT_RE_FLAG_TASK_IN_PROG, &rdev->flags);
+			atomic_inc(&rdev->sched_count);
 			queue_work(bnxt_re_wq, &re_work->work);
 		}
 	}
