mmc: block: blk-mq: Stop using legacy recovery

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] block: blk-mq: Stop using legacy recovery (Gopal Tiwari) [1456570]
Rebuild_FUZZ: 94.25%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 7eb43d537166c7d767af450901acd0ecbf94625c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7eb43d53.failed

There are only a few things the recovery needs to do. Primarily, it just
needs to:
	Determine the number of bytes transferred
	Get the card back to transfer state
	Determine whether to retry

There are also a couple of additional features:
	Reset the card before the last retry
	Read one sector at a time

The legacy code spent much effort analyzing command errors, but commands
fail fast, so it is simpler just to give all command errors the same number
of retries.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Acked-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Tested-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 7eb43d537166c7d767af450901acd0ecbf94625c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/block.c
diff --cc drivers/mmc/core/block.c
index f1d3365980df,bd7ead343500..000000000000
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@@ -1373,9 -1561,9 +1373,13 @@@ static enum mmc_blk_status mmc_blk_err_
  					     struct mmc_async_req *areq)
  {
  	struct mmc_queue_req *mq_mrq = container_of(areq, struct mmc_queue_req,
++<<<<<<< HEAD
 +						    mmc_active);
++=======
+ 						    areq);
++>>>>>>> 7eb43d537166 (mmc: block: blk-mq: Stop using legacy recovery)
  	struct mmc_blk_request *brq = &mq_mrq->brq;
 -	struct request *req = mmc_queue_req_to_req(mq_mrq);
 +	struct request *req = mq_mrq->req;
  	int need_retune = card->host->need_retune;
  	bool ecc_err = false;
  	bool gen_err = false;
@@@ -1479,16 -1667,15 +1483,25 @@@
  	return MMC_BLK_SUCCESS;
  }
  
++<<<<<<< HEAD
 +static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 +			       struct mmc_card *card,
 +			       int disable_multi,
 +			       struct mmc_queue *mq)
 +{
 +	u32 readcmd, writecmd;
++=======
+ static void mmc_blk_data_prep(struct mmc_queue *mq, struct mmc_queue_req *mqrq,
+ 			      int disable_multi, bool *do_rel_wr_p,
+ 			      bool *do_data_tag_p)
+ {
+ 	struct mmc_blk_data *md = mq->blkdata;
+ 	struct mmc_card *card = md->queue.card;
++>>>>>>> 7eb43d537166 (mmc: block: blk-mq: Stop using legacy recovery)
  	struct mmc_blk_request *brq = &mqrq->brq;
 -	struct request *req = mmc_queue_req_to_req(mqrq);
 -	bool do_rel_wr, do_data_tag;
 +	struct request *req = mqrq->req;
 +	struct mmc_blk_data *md = mq->blkdata;
 +	bool do_data_tag;
  
  	/*
  	 * Reliable writes are used to implement Forced Unit Access and
@@@ -1611,6 -1760,6 +1624,7 @@@
  
  	mmc_set_data_timeout(&brq->data, card);
  
++<<<<<<< HEAD
  	brq->data.sg = mqrq->sg;
  	brq->data.sg_len = mmc_queue_map_sg(mq, mqrq);
  
@@@ -1631,20 -1780,853 +1645,282 @@@
  			}
  		}
  		brq->data.sg_len = i;
 -	}
 -
 -	mqrq->areq.mrq = &brq->mrq;
++=======
++#define MMC_MAX_RETRIES		5
++#define MMC_DATA_RETRIES	2
++#define MMC_NO_RETRIES		(MMC_MAX_RETRIES + 1)
+ 
 -	if (do_rel_wr_p)
 -		*do_rel_wr_p = do_rel_wr;
++static int mmc_blk_send_stop(struct mmc_card *card, unsigned int timeout)
++{
++	struct mmc_command cmd = {
++		.opcode = MMC_STOP_TRANSMISSION,
++		.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC,
++		/* Some hosts wait for busy anyway, so provide a busy timeout */
++		.busy_timeout = timeout,
++	};
+ 
 -	if (do_data_tag_p)
 -		*do_data_tag_p = do_data_tag;
++	return mmc_wait_for_cmd(card->host, &cmd, 5);
+ }
+ 
 -#define MMC_CQE_RETRIES 2
 -
 -static void mmc_blk_cqe_complete_rq(struct mmc_queue *mq, struct request *req)
++static int mmc_blk_fix_state(struct mmc_card *card, struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_request *mrq = &mqrq->brq.mrq;
 -	struct request_queue *q = req->q;
 -	struct mmc_host *host = mq->card->host;
 -	unsigned long flags;
 -	bool put_card;
++	struct mmc_blk_request *brq = &mqrq->brq;
++	unsigned int timeout = mmc_blk_data_timeout_ms(card->host, &brq->data);
+ 	int err;
+ 
 -	mmc_cqe_post_req(host, mrq);
 -
 -	if (mrq->cmd && mrq->cmd->error)
 -		err = mrq->cmd->error;
 -	else if (mrq->data && mrq->data->error)
 -		err = mrq->data->error;
 -	else
 -		err = 0;
 -
 -	if (err) {
 -		if (mqrq->retries++ < MMC_CQE_RETRIES)
 -			blk_mq_requeue_request(req, true);
 -		else
 -			blk_mq_end_request(req, BLK_STS_IOERR);
 -	} else if (mrq->data) {
 -		if (blk_update_request(req, BLK_STS_OK, mrq->data->bytes_xfered))
 -			blk_mq_requeue_request(req, true);
 -		else
 -			__blk_mq_end_request(req, BLK_STS_OK);
 -	} else {
 -		blk_mq_end_request(req, BLK_STS_OK);
 -	}
 -
 -	spin_lock_irqsave(q->queue_lock, flags);
 -
 -	mq->in_flight[mmc_issue_type(mq, req)] -= 1;
 -
 -	put_card = (mmc_tot_in_flight(mq) == 0);
++	mmc_retune_hold_now(card->host);
+ 
 -	mmc_cqe_check_busy(mq);
++	mmc_blk_send_stop(card, timeout);
+ 
 -	spin_unlock_irqrestore(q->queue_lock, flags);
++	err = card_busy_detect(card, timeout, false, req, NULL);
+ 
 -	if (!mq->cqe_busy)
 -		blk_mq_run_hw_queues(q, true);
++	mmc_retune_release(card->host);
+ 
 -	if (put_card)
 -		mmc_put_card(mq->card, &mq->ctx);
++	return err;
+ }
+ 
 -void mmc_blk_cqe_recovery(struct mmc_queue *mq)
++#define MMC_READ_SINGLE_RETRIES	2
++
++/* Single sector read during recovery */
++static void mmc_blk_read_single(struct mmc_queue *mq, struct request *req)
+ {
++	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
++	struct mmc_request *mrq = &mqrq->brq.mrq;
+ 	struct mmc_card *card = mq->card;
+ 	struct mmc_host *host = card->host;
 -	int err;
++	blk_status_t error = BLK_STS_OK;
++	int retries = 0;
+ 
 -	pr_debug("%s: CQE recovery start\n", mmc_hostname(host));
++	do {
++		u32 status;
++		int err;
+ 
 -	err = mmc_cqe_recovery(host);
 -	if (err)
 -		mmc_blk_reset(mq->blkdata, host, MMC_BLK_CQE_RECOVERY);
 -	else
 -		mmc_blk_reset_success(mq->blkdata, MMC_BLK_CQE_RECOVERY);
++		mmc_blk_rw_rq_prep(mqrq, card, 1, mq);
+ 
 -	pr_debug("%s: CQE recovery done\n", mmc_hostname(host));
 -}
++		mmc_wait_for_req(host, mrq);
+ 
 -static void mmc_blk_cqe_req_done(struct mmc_request *mrq)
 -{
 -	struct mmc_queue_req *mqrq = container_of(mrq, struct mmc_queue_req,
 -						  brq.mrq);
 -	struct request *req = mmc_queue_req_to_req(mqrq);
 -	struct request_queue *q = req->q;
 -	struct mmc_queue *mq = q->queuedata;
 -
 -	/*
 -	 * Block layer timeouts race with completions which means the normal
 -	 * completion path cannot be used during recovery.
 -	 */
 -	if (mq->in_recovery)
 -		mmc_blk_cqe_complete_rq(mq, req);
 -	else
 -		blk_mq_complete_request(req);
 -}
 -
 -static int mmc_blk_cqe_start_req(struct mmc_host *host, struct mmc_request *mrq)
 -{
 -	mrq->done		= mmc_blk_cqe_req_done;
 -	mrq->recovery_notifier	= mmc_cqe_recovery_notifier;
 -
 -	return mmc_cqe_start_req(host, mrq);
 -}
 -
 -static struct mmc_request *mmc_blk_cqe_prep_dcmd(struct mmc_queue_req *mqrq,
 -						 struct request *req)
 -{
 -	struct mmc_blk_request *brq = &mqrq->brq;
 -
 -	memset(brq, 0, sizeof(*brq));
 -
 -	brq->mrq.cmd = &brq->cmd;
 -	brq->mrq.tag = req->tag;
 -
 -	return &brq->mrq;
 -}
 -
 -static int mmc_blk_cqe_issue_flush(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_request *mrq = mmc_blk_cqe_prep_dcmd(mqrq, req);
 -
 -	mrq->cmd->opcode = MMC_SWITCH;
 -	mrq->cmd->arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
 -			(EXT_CSD_FLUSH_CACHE << 16) |
 -			(1 << 8) |
 -			EXT_CSD_CMD_SET_NORMAL;
 -	mrq->cmd->flags = MMC_CMD_AC | MMC_RSP_R1B;
 -
 -	return mmc_blk_cqe_start_req(mq->card->host, mrq);
 -}
 -
 -static int mmc_blk_cqe_issue_rw_rq(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -
 -	mmc_blk_data_prep(mq, mqrq, 0, NULL, NULL);
 -
 -	return mmc_blk_cqe_start_req(mq->card->host, &mqrq->brq.mrq);
 -}
 -
 -static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 -			       struct mmc_card *card,
 -			       int disable_multi,
 -			       struct mmc_queue *mq)
 -{
 -	u32 readcmd, writecmd;
 -	struct mmc_blk_request *brq = &mqrq->brq;
 -	struct request *req = mmc_queue_req_to_req(mqrq);
 -	struct mmc_blk_data *md = mq->blkdata;
 -	bool do_rel_wr, do_data_tag;
 -
 -	mmc_blk_data_prep(mq, mqrq, disable_multi, &do_rel_wr, &do_data_tag);
 -
 -	brq->mrq.cmd = &brq->cmd;
 -
 -	brq->cmd.arg = blk_rq_pos(req);
 -	if (!mmc_card_blockaddr(card))
 -		brq->cmd.arg <<= 9;
 -	brq->cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
 -
 -	if (brq->data.blocks > 1 || do_rel_wr) {
 -		/* SPI multiblock writes terminate using a special
 -		 * token, not a STOP_TRANSMISSION request.
 -		 */
 -		if (!mmc_host_is_spi(card->host) ||
 -		    rq_data_dir(req) == READ)
 -			brq->mrq.stop = &brq->stop;
 -		readcmd = MMC_READ_MULTIPLE_BLOCK;
 -		writecmd = MMC_WRITE_MULTIPLE_BLOCK;
 -	} else {
 -		brq->mrq.stop = NULL;
 -		readcmd = MMC_READ_SINGLE_BLOCK;
 -		writecmd = MMC_WRITE_BLOCK;
 -	}
 -	brq->cmd.opcode = rq_data_dir(req) == READ ? readcmd : writecmd;
 -
 -	/*
 -	 * Pre-defined multi-block transfers are preferable to
 -	 * open ended-ones (and necessary for reliable writes).
 -	 * However, it is not sufficient to just send CMD23,
 -	 * and avoid the final CMD12, as on an error condition
 -	 * CMD12 (stop) needs to be sent anyway. This, coupled
 -	 * with Auto-CMD23 enhancements provided by some
 -	 * hosts, means that the complexity of dealing
 -	 * with this is best left to the host. If CMD23 is
 -	 * supported by card and host, we'll fill sbc in and let
 -	 * the host deal with handling it correctly. This means
 -	 * that for hosts that don't expose MMC_CAP_CMD23, no
 -	 * change of behavior will be observed.
 -	 *
 -	 * N.B: Some MMC cards experience perf degradation.
 -	 * We'll avoid using CMD23-bounded multiblock writes for
 -	 * these, while retaining features like reliable writes.
 -	 */
 -	if ((md->flags & MMC_BLK_CMD23) && mmc_op_multi(brq->cmd.opcode) &&
 -	    (do_rel_wr || !(card->quirks & MMC_QUIRK_BLK_NO_CMD23) ||
 -	     do_data_tag)) {
 -		brq->sbc.opcode = MMC_SET_BLOCK_COUNT;
 -		brq->sbc.arg = brq->data.blocks |
 -			(do_rel_wr ? (1 << 31) : 0) |
 -			(do_data_tag ? (1 << 29) : 0);
 -		brq->sbc.flags = MMC_RSP_R1 | MMC_CMD_AC;
 -		brq->mrq.sbc = &brq->sbc;
 -	}
 -
 -	mqrq->areq.err_check = mmc_blk_err_check;
 -}
 -
 -#define MMC_MAX_RETRIES		5
 -#define MMC_DATA_RETRIES	2
 -#define MMC_NO_RETRIES		(MMC_MAX_RETRIES + 1)
 -
 -static int mmc_blk_send_stop(struct mmc_card *card, unsigned int timeout)
 -{
 -	struct mmc_command cmd = {
 -		.opcode = MMC_STOP_TRANSMISSION,
 -		.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC,
 -		/* Some hosts wait for busy anyway, so provide a busy timeout */
 -		.busy_timeout = timeout,
 -	};
 -
 -	return mmc_wait_for_cmd(card->host, &cmd, 5);
 -}
 -
 -static int mmc_blk_fix_state(struct mmc_card *card, struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_blk_request *brq = &mqrq->brq;
 -	unsigned int timeout = mmc_blk_data_timeout_ms(card->host, &brq->data);
 -	int err;
 -
 -	mmc_retune_hold_now(card->host);
 -
 -	mmc_blk_send_stop(card, timeout);
 -
 -	err = card_busy_detect(card, timeout, false, req, NULL);
 -
 -	mmc_retune_release(card->host);
 -
 -	return err;
 -}
 -
 -#define MMC_READ_SINGLE_RETRIES	2
 -
 -/* Single sector read during recovery */
 -static void mmc_blk_read_single(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_request *mrq = &mqrq->brq.mrq;
 -	struct mmc_card *card = mq->card;
 -	struct mmc_host *host = card->host;
 -	blk_status_t error = BLK_STS_OK;
 -	int retries = 0;
 -
 -	do {
 -		u32 status;
 -		int err;
 -
 -		mmc_blk_rw_rq_prep(mqrq, card, 1, mq);
 -
 -		mmc_wait_for_req(host, mrq);
 -
 -		err = mmc_send_status(card, &status);
 -		if (err)
 -			goto error_exit;
++		err = mmc_send_status(card, &status);
++		if (err)
++			goto error_exit;
+ 
+ 		if (!mmc_host_is_spi(host) &&
+ 		    !mmc_blk_in_tran_state(status)) {
+ 			err = mmc_blk_fix_state(card, req);
+ 			if (err)
+ 				goto error_exit;
+ 		}
+ 
+ 		if (mrq->cmd->error && retries++ < MMC_READ_SINGLE_RETRIES)
+ 			continue;
+ 
+ 		retries = 0;
+ 
+ 		if (mrq->cmd->error ||
+ 		    mrq->data->error ||
+ 		    (!mmc_host_is_spi(host) &&
+ 		     (mrq->cmd->resp[0] & CMD_ERRORS || status & CMD_ERRORS)))
+ 			error = BLK_STS_IOERR;
+ 		else
+ 			error = BLK_STS_OK;
+ 
+ 	} while (blk_update_request(req, error, 512));
+ 
+ 	return;
+ 
+ error_exit:
+ 	mrq->data->bytes_xfered = 0;
+ 	blk_update_request(req, BLK_STS_IOERR, 512);
+ 	/* Let it try the remaining request again */
+ 	if (mqrq->retries > MMC_MAX_RETRIES - 1)
+ 		mqrq->retries = MMC_MAX_RETRIES - 1;
+ }
+ 
+ static inline bool mmc_blk_oor_valid(struct mmc_blk_request *brq)
+ {
+ 	return !!brq->mrq.sbc;
+ }
+ 
+ static inline u32 mmc_blk_stop_err_bits(struct mmc_blk_request *brq)
+ {
+ 	return mmc_blk_oor_valid(brq) ? CMD_ERRORS : CMD_ERRORS_EXCL_OOR;
+ }
+ 
+ /*
+  * Check for errors the host controller driver might not have seen such as
+  * response mode errors or invalid card state.
+  */
+ static bool mmc_blk_status_error(struct request *req, u32 status)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	struct mmc_blk_request *brq = &mqrq->brq;
+ 	struct mmc_queue *mq = req->q->queuedata;
+ 	u32 stop_err_bits;
+ 
+ 	if (mmc_host_is_spi(mq->card->host))
+ 		return 0;
+ 
+ 	stop_err_bits = mmc_blk_stop_err_bits(brq);
+ 
+ 	return brq->cmd.resp[0]  & CMD_ERRORS    ||
+ 	       brq->stop.resp[0] & stop_err_bits ||
+ 	       status            & stop_err_bits ||
+ 	       (rq_data_dir(req) == WRITE && !mmc_blk_in_tran_state(status));
+ }
+ 
+ static inline bool mmc_blk_cmd_started(struct mmc_blk_request *brq)
+ {
+ 	return !brq->sbc.error && !brq->cmd.error &&
+ 	       !(brq->cmd.resp[0] & CMD_ERRORS);
+ }
+ 
+ /*
+  * Requests are completed by mmc_blk_mq_complete_rq() which sets simple
+  * policy:
+  * 1. A request that has transferred at least some data is considered
+  * successful and will be requeued if there is remaining data to
+  * transfer.
+  * 2. Otherwise the number of retries is incremented and the request
+  * will be requeued if there are remaining retries.
+  * 3. Otherwise the request will be errored out.
+  * That means mmc_blk_mq_complete_rq() is controlled by bytes_xfered and
+  * mqrq->retries. So there are only 4 possible actions here:
+  *	1. do not accept the bytes_xfered value i.e. set it to zero
+  *	2. change mqrq->retries to determine the number of retries
+  *	3. try to reset the card
+  *	4. read one sector at a time
+  */
+ static void mmc_blk_mq_rw_recovery(struct mmc_queue *mq, struct request *req)
+ {
+ 	int type = rq_data_dir(req) == READ ? MMC_BLK_READ : MMC_BLK_WRITE;
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	struct mmc_blk_request *brq = &mqrq->brq;
+ 	struct mmc_blk_data *md = mq->blkdata;
+ 	struct mmc_card *card = mq->card;
+ 	u32 status;
+ 	u32 blocks;
+ 	int err;
+ 
+ 	/*
+ 	 * Some errors the host driver might not have seen. Set the number of
+ 	 * bytes transferred to zero in that case.
+ 	 */
+ 	err = __mmc_send_status(card, &status, 0);
+ 	if (err || mmc_blk_status_error(req, status))
+ 		brq->data.bytes_xfered = 0;
+ 
+ 	mmc_retune_release(card->host);
+ 
+ 	/*
+ 	 * Try again to get the status. This also provides an opportunity for
+ 	 * re-tuning.
+ 	 */
+ 	if (err)
+ 		err = __mmc_send_status(card, &status, 0);
+ 
+ 	/*
+ 	 * Nothing more to do after the number of bytes transferred has been
+ 	 * updated and there is no card.
+ 	 */
+ 	if (err && mmc_detect_card_removed(card->host))
+ 		return;
+ 
+ 	/* Try to get back to "tran" state */
+ 	if (!mmc_host_is_spi(mq->card->host) &&
+ 	    (err || !mmc_blk_in_tran_state(status)))
+ 		err = mmc_blk_fix_state(mq->card, req);
+ 
+ 	/*
+ 	 * Special case for SD cards where the card might record the number of
+ 	 * blocks written.
+ 	 */
+ 	if (!err && mmc_blk_cmd_started(brq) && mmc_card_sd(card) &&
+ 	    rq_data_dir(req) == WRITE) {
+ 		if (mmc_sd_num_wr_blocks(card, &blocks))
+ 			brq->data.bytes_xfered = 0;
+ 		else
+ 			brq->data.bytes_xfered = blocks << 9;
+ 	}
+ 
+ 	/* Reset if the card is in a bad state */
+ 	if (!mmc_host_is_spi(mq->card->host) &&
+ 	    err && mmc_blk_reset(md, card->host, type)) {
+ 		pr_err("%s: recovery failed!\n", req->rq_disk->disk_name);
+ 		mqrq->retries = MMC_NO_RETRIES;
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * If anything was done, just return and if there is anything remaining
+ 	 * on the request it will get requeued.
+ 	 */
+ 	if (brq->data.bytes_xfered)
+ 		return;
+ 
+ 	/* Reset before last retry */
+ 	if (mqrq->retries + 1 == MMC_MAX_RETRIES)
+ 		mmc_blk_reset(md, card->host, type);
+ 
+ 	/* Command errors fail fast, so use all MMC_MAX_RETRIES */
+ 	if (brq->sbc.error || brq->cmd.error)
+ 		return;
+ 
+ 	/* Reduce the remaining retries for data errors */
+ 	if (mqrq->retries < MMC_MAX_RETRIES - MMC_DATA_RETRIES) {
+ 		mqrq->retries = MMC_MAX_RETRIES - MMC_DATA_RETRIES;
+ 		return;
+ 	}
+ 
+ 	/* FIXME: Missing single sector read for large sector size */
+ 	if (!mmc_large_sector(card) && rq_data_dir(req) == READ &&
+ 	    brq->data.blocks > 1) {
+ 		/* Read one sector at a time */
+ 		mmc_blk_read_single(mq, req);
+ 		return;
+ 	}
+ }
+ 
+ static inline bool mmc_blk_rq_error(struct mmc_blk_request *brq)
+ {
+ 	mmc_blk_eval_resp_error(brq);
+ 
+ 	return brq->sbc.error || brq->cmd.error || brq->stop.error ||
+ 	       brq->data.error || brq->cmd.resp[0] & CMD_ERRORS;
+ }
+ 
+ static int mmc_blk_card_busy(struct mmc_card *card, struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	u32 status = 0;
 -	int err;
 -
 -	if (mmc_host_is_spi(card->host) || rq_data_dir(req) == READ)
 -		return 0;
 -
 -	err = card_busy_detect(card, MMC_BLK_TIMEOUT_MS, false, req, &status);
 -
 -	/*
 -	 * Do not assume data transferred correctly if there are any error bits
 -	 * set.
 -	 */
 -	if (status & mmc_blk_stop_err_bits(&mqrq->brq)) {
 -		mqrq->brq.data.bytes_xfered = 0;
 -		err = err ? err : -EIO;
 -	}
 -
 -	/* Copy the exception bit so it will be seen later on */
 -	if (mmc_card_mmc(card) && status & R1_EXCEPTION_EVENT)
 -		mqrq->brq.cmd.resp[0] |= R1_EXCEPTION_EVENT;
 -
 -	return err;
 -}
 -
 -static inline void mmc_blk_rw_reset_success(struct mmc_queue *mq,
 -					    struct request *req)
 -{
 -	int type = rq_data_dir(req) == READ ? MMC_BLK_READ : MMC_BLK_WRITE;
 -
 -	mmc_blk_reset_success(mq->blkdata, type);
 -}
 -
 -static void mmc_blk_mq_complete_rq(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	unsigned int nr_bytes = mqrq->brq.data.bytes_xfered;
 -
 -	if (nr_bytes) {
 -		if (blk_update_request(req, BLK_STS_OK, nr_bytes))
 -			blk_mq_requeue_request(req, true);
 -		else
 -			__blk_mq_end_request(req, BLK_STS_OK);
 -	} else if (!blk_rq_bytes(req)) {
 -		__blk_mq_end_request(req, BLK_STS_IOERR);
 -	} else if (mqrq->retries++ < MMC_MAX_RETRIES) {
 -		blk_mq_requeue_request(req, true);
 -	} else {
 -		if (mmc_card_removed(mq->card))
 -			req->rq_flags |= RQF_QUIET;
 -		blk_mq_end_request(req, BLK_STS_IOERR);
 -	}
 -}
 -
 -static bool mmc_blk_urgent_bkops_needed(struct mmc_queue *mq,
 -					struct mmc_queue_req *mqrq)
 -{
 -	return mmc_card_mmc(mq->card) && !mmc_host_is_spi(mq->card->host) &&
 -	       (mqrq->brq.cmd.resp[0] & R1_EXCEPTION_EVENT ||
 -		mqrq->brq.stop.resp[0] & R1_EXCEPTION_EVENT);
 -}
 -
 -static void mmc_blk_urgent_bkops(struct mmc_queue *mq,
 -				 struct mmc_queue_req *mqrq)
 -{
 -	if (mmc_blk_urgent_bkops_needed(mq, mqrq))
 -		mmc_start_bkops(mq->card, true);
 -}
 -
 -void mmc_blk_mq_complete(struct request *req)
 -{
 -	struct mmc_queue *mq = req->q->queuedata;
 -
 -	if (mq->use_cqe)
 -		mmc_blk_cqe_complete_rq(mq, req);
 -	else
 -		mmc_blk_mq_complete_rq(mq, req);
 -}
 -
 -static void mmc_blk_mq_poll_completion(struct mmc_queue *mq,
 -				       struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_host *host = mq->card->host;
 -
 -	if (mmc_blk_rq_error(&mqrq->brq) ||
 -	    mmc_blk_card_busy(mq->card, req)) {
 -		mmc_blk_mq_rw_recovery(mq, req);
 -	} else {
 -		mmc_blk_rw_reset_success(mq, req);
 -		mmc_retune_release(host);
 -	}
 -
 -	mmc_blk_urgent_bkops(mq, mqrq);
 -}
 -
 -static void mmc_blk_mq_dec_in_flight(struct mmc_queue *mq, struct request *req)
 -{
 -	struct request_queue *q = req->q;
 -	unsigned long flags;
 -	bool put_card;
 -
 -	spin_lock_irqsave(q->queue_lock, flags);
 -
 -	mq->in_flight[mmc_issue_type(mq, req)] -= 1;
 -
 -	put_card = (mmc_tot_in_flight(mq) == 0);
 -
 -	spin_unlock_irqrestore(q->queue_lock, flags);
 -
 -	if (put_card)
 -		mmc_put_card(mq->card, &mq->ctx);
 -}
 -
 -static void mmc_blk_mq_post_req(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_request *mrq = &mqrq->brq.mrq;
 -	struct mmc_host *host = mq->card->host;
 -
 -	mmc_post_req(host, mrq, 0);
 -
 -	/*
 -	 * Block layer timeouts race with completions which means the normal
 -	 * completion path cannot be used during recovery.
 -	 */
 -	if (mq->in_recovery)
 -		mmc_blk_mq_complete_rq(mq, req);
 -	else
 -		blk_mq_complete_request(req);
 -
 -	mmc_blk_mq_dec_in_flight(mq, req);
 -}
 -
 -void mmc_blk_mq_recovery(struct mmc_queue *mq)
 -{
 -	struct request *req = mq->recovery_req;
 -	struct mmc_host *host = mq->card->host;
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -
 -	mq->recovery_req = NULL;
 -	mq->rw_wait = false;
 -
 -	if (mmc_blk_rq_error(&mqrq->brq)) {
 -		mmc_retune_hold_now(host);
 -		mmc_blk_mq_rw_recovery(mq, req);
 -	}
 -
 -	mmc_blk_urgent_bkops(mq, mqrq);
 -
 -	mmc_blk_mq_post_req(mq, req);
 -}
 -
 -static void mmc_blk_mq_complete_prev_req(struct mmc_queue *mq,
 -					 struct request **prev_req)
 -{
 -	if (mmc_host_done_complete(mq->card->host))
 -		return;
 -
 -	mutex_lock(&mq->complete_lock);
 -
 -	if (!mq->complete_req)
 -		goto out_unlock;
 -
 -	mmc_blk_mq_poll_completion(mq, mq->complete_req);
 -
 -	if (prev_req)
 -		*prev_req = mq->complete_req;
 -	else
 -		mmc_blk_mq_post_req(mq, mq->complete_req);
 -
 -	mq->complete_req = NULL;
 -
 -out_unlock:
 -	mutex_unlock(&mq->complete_lock);
 -}
 -
 -void mmc_blk_mq_complete_work(struct work_struct *work)
 -{
 -	struct mmc_queue *mq = container_of(work, struct mmc_queue,
 -					    complete_work);
 -
 -	mmc_blk_mq_complete_prev_req(mq, NULL);
 -}
 -
 -static void mmc_blk_mq_req_done(struct mmc_request *mrq)
 -{
 -	struct mmc_queue_req *mqrq = container_of(mrq, struct mmc_queue_req,
 -						  brq.mrq);
 -	struct request *req = mmc_queue_req_to_req(mqrq);
 -	struct request_queue *q = req->q;
 -	struct mmc_queue *mq = q->queuedata;
 -	struct mmc_host *host = mq->card->host;
 -	unsigned long flags;
 -
 -	if (!mmc_host_done_complete(host)) {
 -		bool waiting;
 -
 -		/*
 -		 * We cannot complete the request in this context, so record
 -		 * that there is a request to complete, and that a following
 -		 * request does not need to wait (although it does need to
 -		 * complete complete_req first).
 -		 */
 -		spin_lock_irqsave(q->queue_lock, flags);
 -		mq->complete_req = req;
 -		mq->rw_wait = false;
 -		waiting = mq->waiting;
 -		spin_unlock_irqrestore(q->queue_lock, flags);
 -
 -		/*
 -		 * If 'waiting' then the waiting task will complete this
 -		 * request, otherwise queue a work to do it. Note that
 -		 * complete_work may still race with the dispatch of a following
 -		 * request.
 -		 */
 -		if (waiting)
 -			wake_up(&mq->wait);
 -		else
 -			kblockd_schedule_work(&mq->complete_work);
 -
 -		return;
 -	}
 -
 -	/* Take the recovery path for errors or urgent background operations */
 -	if (mmc_blk_rq_error(&mqrq->brq) ||
 -	    mmc_blk_urgent_bkops_needed(mq, mqrq)) {
 -		spin_lock_irqsave(q->queue_lock, flags);
 -		mq->recovery_needed = true;
 -		mq->recovery_req = req;
 -		spin_unlock_irqrestore(q->queue_lock, flags);
 -		wake_up(&mq->wait);
 -		schedule_work(&mq->recovery_work);
 -		return;
 -	}
 -
 -	mmc_blk_rw_reset_success(mq, req);
 -
 -	mq->rw_wait = false;
 -	wake_up(&mq->wait);
 -
 -	mmc_blk_mq_post_req(mq, req);
 -}
 -
 -static bool mmc_blk_rw_wait_cond(struct mmc_queue *mq, int *err)
 -{
 -	struct request_queue *q = mq->queue;
 -	unsigned long flags;
 -	bool done;
 -
 -	/*
 -	 * Wait while there is another request in progress, but not if recovery
 -	 * is needed. Also indicate whether there is a request waiting to start.
 -	 */
 -	spin_lock_irqsave(q->queue_lock, flags);
 -	if (mq->recovery_needed) {
 -		*err = -EBUSY;
 -		done = true;
 -	} else {
 -		done = !mq->rw_wait;
 -	}
 -	mq->waiting = !done;
 -	spin_unlock_irqrestore(q->queue_lock, flags);
 -
 -	return done;
 -}
 -
 -static int mmc_blk_rw_wait(struct mmc_queue *mq, struct request **prev_req)
 -{
 -	int err = 0;
 -
 -	wait_event(mq->wait, mmc_blk_rw_wait_cond(mq, &err));
 -
 -	/* Always complete the previous request if there is one */
 -	mmc_blk_mq_complete_prev_req(mq, prev_req);
 -
 -	return err;
 -}
 -
 -static int mmc_blk_mq_issue_rw_rq(struct mmc_queue *mq,
 -				  struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_host *host = mq->card->host;
 -	struct request *prev_req = NULL;
 -	int err = 0;
 -
 -	mmc_blk_rw_rq_prep(mqrq, mq->card, 0, mq);
 -
 -	mqrq->brq.mrq.done = mmc_blk_mq_req_done;
 -
 -	mmc_pre_req(host, &mqrq->brq.mrq);
 -
 -	err = mmc_blk_rw_wait(mq, &prev_req);
 -	if (err)
 -		goto out_post_req;
 -
 -	mq->rw_wait = true;
 -
 -	err = mmc_start_request(host, &mqrq->brq.mrq);
 -
 -	if (prev_req)
 -		mmc_blk_mq_post_req(mq, prev_req);
 -
 -	if (err)
 -		mq->rw_wait = false;
 -
 -	/* Release re-tuning here where there is no synchronization required */
 -	if (err || mmc_host_done_complete(host))
 -		mmc_retune_release(host);
 -
 -out_post_req:
 -	if (err)
 -		mmc_post_req(host, &mqrq->brq.mrq, err);
 -
 -	return err;
 -}
 -
 -static int mmc_blk_wait_for_idle(struct mmc_queue *mq, struct mmc_host *host)
 -{
 -	if (mq->use_cqe)
 -		return host->cqe_ops->cqe_wait_for_idle(host);
 -
 -	return mmc_blk_rw_wait(mq, NULL);
 -}
 -
 -enum mmc_issued mmc_blk_mq_issue_rq(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_blk_data *md = mq->blkdata;
 -	struct mmc_card *card = md->queue.card;
 -	struct mmc_host *host = card->host;
 -	int ret;
++	u32 status = 0;
++	int err;
+ 
 -	ret = mmc_blk_part_switch(card, md->part_type);
 -	if (ret)
 -		return MMC_REQ_FAILED_TO_START;
++	if (mmc_host_is_spi(card->host) || rq_data_dir(req) == READ)
++		return 0;
+ 
 -	switch (mmc_issue_type(mq, req)) {
 -	case MMC_ISSUE_SYNC:
 -		ret = mmc_blk_wait_for_idle(mq, host);
 -		if (ret)
 -			return MMC_REQ_BUSY;
 -		switch (req_op(req)) {
 -		case REQ_OP_DRV_IN:
 -		case REQ_OP_DRV_OUT:
 -			mmc_blk_issue_drv_op(mq, req);
 -			break;
 -		case REQ_OP_DISCARD:
 -			mmc_blk_issue_discard_rq(mq, req);
 -			break;
 -		case REQ_OP_SECURE_ERASE:
 -			mmc_blk_issue_secdiscard_rq(mq, req);
 -			break;
 -		case REQ_OP_FLUSH:
 -			mmc_blk_issue_flush(mq, req);
 -			break;
 -		default:
 -			WARN_ON_ONCE(1);
 -			return MMC_REQ_FAILED_TO_START;
 -		}
 -		return MMC_REQ_FINISHED;
 -	case MMC_ISSUE_DCMD:
 -	case MMC_ISSUE_ASYNC:
 -		switch (req_op(req)) {
 -		case REQ_OP_FLUSH:
 -			ret = mmc_blk_cqe_issue_flush(mq, req);
 -			break;
 -		case REQ_OP_READ:
 -		case REQ_OP_WRITE:
 -			if (mq->use_cqe)
 -				ret = mmc_blk_cqe_issue_rw_rq(mq, req);
 -			else
 -				ret = mmc_blk_mq_issue_rw_rq(mq, req);
 -			break;
 -		default:
 -			WARN_ON_ONCE(1);
 -			ret = -EINVAL;
 -		}
 -		if (!ret)
 -			return MMC_REQ_STARTED;
 -		return ret == -EBUSY ? MMC_REQ_BUSY : MMC_REQ_FAILED_TO_START;
 -	default:
 -		WARN_ON_ONCE(1);
 -		return MMC_REQ_FAILED_TO_START;
++	err = card_busy_detect(card, MMC_BLK_TIMEOUT_MS, false, req, &status);
++
++	/*
++	 * Do not assume data transferred correctly if there are any error bits
++	 * set.
++	 */
++	if (status & mmc_blk_stop_err_bits(&mqrq->brq)) {
++		mqrq->brq.data.bytes_xfered = 0;
++		err = err ? err : -EIO;
++>>>>>>> 7eb43d537166 (mmc: block: blk-mq: Stop using legacy recovery)
  	}
 +
 +	mqrq->mmc_active.mrq = &brq->mrq;
 +	mqrq->mmc_active.err_check = mmc_blk_err_check;
 +
 +	mmc_queue_bounce_pre(mqrq);
  }
  
 -static bool mmc_blk_rw_cmd_err(struct mmc_blk_data *md, struct mmc_card *card,
 -			       struct mmc_blk_request *brq, struct request *req,
 -			       bool old_req_pending)
 +static int mmc_blk_cmd_err(struct mmc_blk_data *md, struct mmc_card *card,
 +			   struct mmc_blk_request *brq, struct request *req,
 +			   int ret)
  {
 -	bool req_pending;
 +	struct mmc_queue_req *mq_rq;
 +	mq_rq = container_of(brq, struct mmc_queue_req, brq);
  
  	/*
  	 * If this is an SD card and we're writing, we can first
* Unmerged path drivers/mmc/core/block.c
