watchdog: Fix potential kref imbalance when opening watchdog

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [watchdog] Fix potential kref imbalance when opening watchdog (David Arcari) [1576173]
Rebuild_FUZZ: 90.91%
commit-author Guenter Roeck <linux@roeck-us.net>
commit 4bcd615fad6adddc68b058d498b30a9e0e0db77a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4bcd615f.failed

If a watchdog driver's open function sets WDOG_HW_RUNNING with the
expectation that the watchdog can not be stopped, but then stops the
watchdog anyway in its stop function, kref_get() wil not be called in
watchdog_open(). If the watchdog then stops on close, WDOG_HW_RUNNING
will be cleared and kref_put() will be called, causing a kref imbalance.
As result the character device data structure will be released, which in
turn will cause the system to crash on the next call to watchdog_open().

Fixes: ee142889e32f5 ("watchdog: Introduce WDOG_HW_RUNNING flag")
	Signed-off-by: Guenter Roeck <linux@roeck-us.net>
	Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
(cherry picked from commit 4bcd615fad6adddc68b058d498b30a9e0e0db77a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/watchdog/watchdog_dev.c
diff --cc drivers/watchdog/watchdog_dev.c
index f06fbcf0bea2,12fe47d8237b..000000000000
--- a/drivers/watchdog/watchdog_dev.c
+++ b/drivers/watchdog/watchdog_dev.c
@@@ -526,8 -767,10 +526,13 @@@ static long watchdog_ioctl(struct file 
  
  static int watchdog_open(struct inode *inode, struct file *file)
  {
 -	struct watchdog_core_data *wd_data;
 +	int err = -EBUSY;
  	struct watchdog_device *wdd;
++<<<<<<< HEAD
++=======
+ 	bool hw_running;
+ 	int err;
++>>>>>>> 4bcd615fad6a (watchdog: Fix potential kref imbalance when opening watchdog)
  
  	/* Get the corresponding watchdog device */
  	if (imajor(inode) == MISC_MAJOR)
@@@ -543,17 -789,20 +548,30 @@@
  	 * If the /dev/watchdog device is open, we don't want the module
  	 * to be unloaded.
  	 */
++<<<<<<< HEAD
 +	if (!try_module_get(wdd->ops->owner))
 +		goto out;
++=======
+ 	hw_running = watchdog_hw_running(wdd);
+ 	if (!hw_running && !try_module_get(wdd->ops->owner)) {
+ 		err = -EBUSY;
+ 		goto out_clear;
+ 	}
++>>>>>>> 4bcd615fad6a (watchdog: Fix potential kref imbalance when opening watchdog)
  
  	err = watchdog_start(wdd);
  	if (err < 0)
  		goto out_mod;
  
 -	file->private_data = wd_data;
 +	file->private_data = wdd;
  
++<<<<<<< HEAD
 +	if (wdd->ops->ref)
 +		wdd->ops->ref(wdd);
++=======
+ 	if (!hw_running)
+ 		kref_get(&wd_data->kref);
++>>>>>>> 4bcd615fad6a (watchdog: Fix potential kref imbalance when opening watchdog)
  
  	/* dev/watchdog is a virtual (and thus non-seekable) filesystem */
  	return nonseekable_open(inode, file);
* Unmerged path drivers/watchdog/watchdog_dev.c
