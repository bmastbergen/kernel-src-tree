Input: MT - add support for balanced slot assignment

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [input] MT - add support for balanced slot assignment (Benjamin Tissoires) [1554926]
Rebuild_FUZZ: 92.78%
commit-author Henrik Rydberg <rydberg@bitmath.org>
commit 448c7f3830ca283e485aa943279acea6bde8b270
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/448c7f38.failed

Some devices are not fast enough to differentiate between a fast-moving
contact and a new contact. This problem cannot be fully resolved because
information is truly missing, but it is possible to safe-guard against
obvious mistakes by restricting movement with a maximum displacement.

The new problem formulation for dmax > 0 cannot benefit from the speedup
for positive definite matrices, but since the convergence is faster, the
result is about the same. For a handful of contacts, the latency difference
is truly negligible.

	Suggested-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Tested-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Henrik Rydberg <rydberg@bitmath.org>
	Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
(cherry picked from commit 448c7f3830ca283e485aa943279acea6bde8b270)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/input/mouse/synaptics.c
#	drivers/input/touchscreen/pixcir_i2c_ts.c
diff --cc drivers/input/mouse/synaptics.c
index 550042022186,a3692e3b7cab..000000000000
--- a/drivers/input/mouse/synaptics.c
+++ b/drivers/input/mouse/synaptics.c
@@@ -886,75 -798,29 +886,90 @@@ static void synaptics_report_mt_data(st
  {
  	struct input_dev *dev = psmouse->dev;
  	struct synaptics_data *priv = psmouse->private;
 -	const struct synaptics_hw_state *hw[2] = { sgm, &priv->agm };
 -	struct input_mt_pos pos[2];
 -	int slot[2], nsemi, i;
 +	struct synaptics_hw_state *agm = &priv->agm;
 +	struct synaptics_mt_state *old = &priv->mt_state;
  
 -	nsemi = clamp_val(num_fingers, 0, 2);
 +	switch (mt_state->count) {
 +	case 0:
 +		synaptics_report_slot(dev, 0, NULL);
 +		synaptics_report_slot(dev, 1, NULL);
 +		break;
 +	case 1:
 +		if (mt_state->sgm == -1) {
 +			synaptics_report_slot(dev, 0, NULL);
 +			synaptics_report_slot(dev, 1, NULL);
 +		} else if (mt_state->sgm == 0) {
 +			synaptics_report_slot(dev, 0, sgm);
 +			synaptics_report_slot(dev, 1, NULL);
 +		} else {
 +			synaptics_report_slot(dev, 0, NULL);
 +			synaptics_report_slot(dev, 1, sgm);
 +		}
 +		break;
 +	default:
 +		/*
 +		 * If the finger slot contained in SGM is valid, and either
 +		 * hasn't changed, or is new, or the old SGM has now moved to
 +		 * AGM, then report SGM in MTB slot 0.
 +		 * Otherwise, empty MTB slot 0.
 +		 */
 +		if (mt_state->sgm != -1 &&
 +		    (mt_state->sgm == old->sgm ||
 +		     old->sgm == -1 || mt_state->agm == old->sgm))
 +			synaptics_report_slot(dev, 0, sgm);
 +		else
 +			synaptics_report_slot(dev, 0, NULL);
  
 -	for (i = 0; i < nsemi; i++) {
 -		pos[i].x = hw[i]->x;
 -		pos[i].y = synaptics_invert_y(hw[i]->y);
 +		/*
 +		 * If the finger slot contained in AGM is valid, and either
 +		 * hasn't changed, or is new, then report AGM in MTB slot 1.
 +		 * Otherwise, empty MTB slot 1.
 +		 *
 +		 * However, in the case where the AGM is new, make sure that
 +		 * that it is either the same as the old SGM, or there was no
 +		 * SGM.
 +		 *
 +		 * Otherwise, if the SGM was just 1, and the new AGM is 2, then
 +		 * the new AGM will keep the old SGM's tracking ID, which can
 +		 * cause apparent drumroll.  This happens if in the following
 +		 * valid finger sequence:
 +		 *
 +		 *  Action                 SGM  AGM (MTB slot:Contact)
 +		 *  1. Touch contact 0    (0:0)
 +		 *  2. Touch contact 1    (0:0, 1:1)
 +		 *  3. Lift  contact 0    (1:1)
 +		 *  4. Touch contacts 2,3 (0:2, 1:3)
 +		 *
 +		 * In step 4, contact 3, in AGM must not be given the same
 +		 * tracking ID as contact 1 had in step 3.  To avoid this,
 +		 * the first agm with contact 3 is dropped and slot 1 is
 +		 * invalidated (tracking ID = -1).
 +		 */
 +		if (mt_state->agm != -1 &&
 +		    (mt_state->agm == old->agm ||
 +		     (old->agm == -1 &&
 +		      (old->sgm == -1 || mt_state->agm == old->sgm))))
 +			synaptics_report_slot(dev, 1, agm);
 +		else
 +			synaptics_report_slot(dev, 1, NULL);
 +		break;
  	}
  
++<<<<<<< HEAD
++=======
+ 	input_mt_assign_slots(dev, slot, pos, nsemi, 0);
+ 
+ 	for (i = 0; i < nsemi; i++) {
+ 		input_mt_slot(dev, slot[i]);
+ 		input_mt_report_slot_state(dev, MT_TOOL_FINGER, true);
+ 		input_report_abs(dev, ABS_MT_POSITION_X, pos[i].x);
+ 		input_report_abs(dev, ABS_MT_POSITION_Y, pos[i].y);
+ 		input_report_abs(dev, ABS_MT_PRESSURE, hw[i]->z);
+ 	}
+ 
+ 	input_mt_drop_unused(dev);
+ 
++>>>>>>> 448c7f3830ca (Input: MT - add support for balanced slot assignment)
  	/* Don't use active slot count to generate BTN_TOOL events. */
  	input_mt_report_pointer_emulation(dev, false);
  
diff --cc drivers/input/touchscreen/pixcir_i2c_ts.c
index 6cc6b36663ff,2c2107147319..000000000000
--- a/drivers/input/touchscreen/pixcir_i2c_ts.c
+++ b/drivers/input/touchscreen/pixcir_i2c_ts.c
@@@ -55,33 -85,77 +55,61 @@@ static void pixcir_ts_poscheck(struct p
  		return;
  	}
  
 -	touch = rdbuf[0] & 0x7;
 -	if (touch > tsdata->max_fingers)
 -		touch = tsdata->max_fingers;
 -
 -	report->num_touches = touch;
 -	bufptr = &rdbuf[2];
 -
 -	for (i = 0; i < touch; i++) {
 -		report->touches[i].x = (bufptr[1] << 8) | bufptr[0];
 -		report->touches[i].y = (bufptr[3] << 8) | bufptr[2];
 -
 -		if (chip->has_hw_ids) {
 -			report->touches[i].id = bufptr[4];
 -			bufptr = bufptr + 5;
 -		} else {
 -			bufptr = bufptr + 4;
 +	touch = rdbuf[0];
 +	if (touch) {
 +		u16 posx1 = (rdbuf[3] << 8) | rdbuf[2];
 +		u16 posy1 = (rdbuf[5] << 8) | rdbuf[4];
 +		u16 posx2 = (rdbuf[7] << 8) | rdbuf[6];
 +		u16 posy2 = (rdbuf[9] << 8) | rdbuf[8];
 +
 +		input_report_key(tsdata->input, BTN_TOUCH, 1);
 +		input_report_abs(tsdata->input, ABS_X, posx1);
 +		input_report_abs(tsdata->input, ABS_Y, posy1);
 +
 +		input_report_abs(tsdata->input, ABS_MT_POSITION_X, posx1);
 +		input_report_abs(tsdata->input, ABS_MT_POSITION_Y, posy1);
 +		input_mt_sync(tsdata->input);
 +
 +		if (touch == 2) {
 +			input_report_abs(tsdata->input,
 +					 ABS_MT_POSITION_X, posx2);
 +			input_report_abs(tsdata->input,
 +					 ABS_MT_POSITION_Y, posy2);
 +			input_mt_sync(tsdata->input);
  		}
++<<<<<<< HEAD
 +	} else {
 +		input_report_key(tsdata->input, BTN_TOUCH, 0);
++=======
+ 	}
+ }
+ 
+ static void pixcir_ts_report(struct pixcir_i2c_ts_data *ts,
+ 			     struct pixcir_report_data *report)
+ {
+ 	struct input_mt_pos pos[PIXCIR_MAX_SLOTS];
+ 	int slots[PIXCIR_MAX_SLOTS];
+ 	struct pixcir_touch *touch;
+ 	int n, i, slot;
+ 	struct device *dev = &ts->client->dev;
+ 	const struct pixcir_i2c_chip_data *chip = &ts->pdata->chip;
+ 
+ 	n = report->num_touches;
+ 	if (n > PIXCIR_MAX_SLOTS)
+ 		n = PIXCIR_MAX_SLOTS;
+ 
+ 	if (!chip->has_hw_ids) {
+ 		for (i = 0; i < n; i++) {
+ 			touch = &report->touches[i];
+ 			pos[i].x = touch->x;
+ 			pos[i].y = touch->y;
+ 		}
+ 
+ 		input_mt_assign_slots(ts->input, slots, pos, n, 0);
++>>>>>>> 448c7f3830ca (Input: MT - add support for balanced slot assignment)
  	}
  
 -	for (i = 0; i < n; i++) {
 -		touch = &report->touches[i];
 -
 -		if (chip->has_hw_ids) {
 -			slot = input_mt_get_slot_by_key(ts->input, touch->id);
 -			if (slot < 0) {
 -				dev_dbg(dev, "no free slot for id 0x%x\n",
 -					touch->id);
 -				continue;
 -			}
 -		} else {
 -			slot = slots[i];
 -		}
 -
 -		input_mt_slot(ts->input, slot);
 -		input_mt_report_slot_state(ts->input,
 -					   MT_TOOL_FINGER, true);
 -
 -		input_event(ts->input, EV_ABS, ABS_MT_POSITION_X, touch->x);
 -		input_event(ts->input, EV_ABS, ABS_MT_POSITION_Y, touch->y);
 -
 -		dev_dbg(dev, "%d: slot %d, x %d, y %d\n",
 -			i, slot, touch->x, touch->y);
 -	}
 -
 -	input_mt_sync_frame(ts->input);
 -	input_sync(ts->input);
 +	input_sync(tsdata->input);
  }
  
  static irqreturn_t pixcir_ts_isr(int irq, void *dev_id)
diff --git a/drivers/input/input-mt.c b/drivers/input/input-mt.c
index d398f1321f14..72e807e2f18e 100644
--- a/drivers/input/input-mt.c
+++ b/drivers/input/input-mt.c
@@ -271,7 +271,7 @@ void input_mt_sync_frame(struct input_dev *dev)
 }
 EXPORT_SYMBOL(input_mt_sync_frame);
 
-static int adjust_dual(int *begin, int step, int *end, int eq)
+static int adjust_dual(int *begin, int step, int *end, int eq, int mu)
 {
 	int f, *p, s, c;
 
@@ -289,9 +289,10 @@ static int adjust_dual(int *begin, int step, int *end, int eq)
 			s = *p;
 
 	c = (f + s + 1) / 2;
-	if (c == 0 || (c > 0 && !eq))
+	if (c == 0 || (c > mu && (!eq || mu > 0)))
 		return 0;
-	if (s < 0)
+	/* Improve convergence for positive matrices by penalizing overcovers */
+	if (s < 0 && mu <= 0)
 		c *= 2;
 
 	for (p = begin; p != end; p += step)
@@ -300,23 +301,24 @@ static int adjust_dual(int *begin, int step, int *end, int eq)
 	return (c < s && s <= 0) || (f >= 0 && f < c);
 }
 
-static void find_reduced_matrix(int *w, int nr, int nc, int nrc)
+static void find_reduced_matrix(int *w, int nr, int nc, int nrc, int mu)
 {
 	int i, k, sum;
 
 	for (k = 0; k < nrc; k++) {
 		for (i = 0; i < nr; i++)
-			adjust_dual(w + i, nr, w + i + nrc, nr <= nc);
+			adjust_dual(w + i, nr, w + i + nrc, nr <= nc, mu);
 		sum = 0;
 		for (i = 0; i < nrc; i += nr)
-			sum += adjust_dual(w + i, 1, w + i + nr, nc <= nr);
+			sum += adjust_dual(w + i, 1, w + i + nr, nc <= nr, mu);
 		if (!sum)
 			break;
 	}
 }
 
 static int input_mt_set_matrix(struct input_mt *mt,
-			       const struct input_mt_pos *pos, int num_pos)
+			       const struct input_mt_pos *pos, int num_pos,
+			       int mu)
 {
 	const struct input_mt_pos *p;
 	struct input_mt_slot *s;
@@ -330,7 +332,7 @@ static int input_mt_set_matrix(struct input_mt *mt,
 		y = input_mt_get_value(s, ABS_MT_POSITION_Y);
 		for (p = pos; p != pos + num_pos; p++) {
 			int dx = x - p->x, dy = y - p->y;
-			*w++ = dx * dx + dy * dy;
+			*w++ = dx * dx + dy * dy - mu;
 		}
 	}
 
@@ -371,17 +373,24 @@ static void input_mt_set_slots(struct input_mt *mt,
  * @slots: the slot assignment to be filled
  * @pos: the position array to match
  * @num_pos: number of positions
+ * @dmax: maximum ABS_MT_POSITION displacement (zero for infinite)
  *
  * Performs a best match against the current contacts and returns
  * the slot assignment list. New contacts are assigned to unused
  * slots.
  *
+ * The assignments are balanced so that all coordinate displacements are
+ * below the euclidian distance dmax. If no such assignment can be found,
+ * some contacts are assigned to unused slots.
+ *
  * Returns zero on success, or negative error in case of failure.
  */
 int input_mt_assign_slots(struct input_dev *dev, int *slots,
-			  const struct input_mt_pos *pos, int num_pos)
+			  const struct input_mt_pos *pos, int num_pos,
+			  int dmax)
 {
 	struct input_mt *mt = dev->mt;
+	int mu = 2 * dmax * dmax;
 	int nrc;
 
 	if (!mt || !mt->red)
@@ -391,8 +400,8 @@ int input_mt_assign_slots(struct input_dev *dev, int *slots,
 	if (num_pos < 1)
 		return 0;
 
-	nrc = input_mt_set_matrix(mt, pos, num_pos);
-	find_reduced_matrix(mt->red, num_pos, nrc / num_pos, nrc);
+	nrc = input_mt_set_matrix(mt, pos, num_pos, mu);
+	find_reduced_matrix(mt->red, num_pos, nrc / num_pos, nrc, mu);
 	input_mt_set_slots(mt, slots, num_pos);
 
 	return 0;
diff --git a/drivers/input/mouse/alps.c b/drivers/input/mouse/alps.c
index b6a7a123c52d..eac706742c4a 100644
--- a/drivers/input/mouse/alps.c
+++ b/drivers/input/mouse/alps.c
@@ -435,7 +435,7 @@ static void alps_report_mt_data(struct psmouse *psmouse, int n)
 	struct alps_fields *f = &priv->f;
 	int i, slot[MAX_TOUCHES];
 
-	input_mt_assign_slots(dev, slot, f->mt, n);
+	input_mt_assign_slots(dev, slot, f->mt, n, 0);
 	for (i = 0; i < n; i++)
 		alps_set_slot(dev, slot[i], f->mt[i].x, f->mt[i].y);
 
diff --git a/drivers/input/mouse/bcm5974.c b/drivers/input/mouse/bcm5974.c
index a73f9618b0ad..22937b14ba14 100644
--- a/drivers/input/mouse/bcm5974.c
+++ b/drivers/input/mouse/bcm5974.c
@@ -565,7 +565,7 @@ static int report_tp_state(struct bcm5974 *dev, int size)
 		dev->index[n++] = &f[i];
 	}
 
-	input_mt_assign_slots(input, dev->slots, dev->pos, n);
+	input_mt_assign_slots(input, dev->slots, dev->pos, n, 0);
 
 	for (i = 0; i < n; i++)
 		report_finger_data(input, dev->slots[i],
diff --git a/drivers/input/mouse/cypress_ps2.c b/drivers/input/mouse/cypress_ps2.c
index 888a81a7ea3d..4f0e20de716a 100644
--- a/drivers/input/mouse/cypress_ps2.c
+++ b/drivers/input/mouse/cypress_ps2.c
@@ -540,7 +540,7 @@ static void cypress_process_packet(struct psmouse *psmouse, bool zero_pkt)
 		pos[i].y = contact->y;
 	}
 
-	input_mt_assign_slots(input, slots, pos, n);
+	input_mt_assign_slots(input, slots, pos, n, 0);
 
 	for (i = 0; i < n; i++) {
 		contact = &report_data.contacts[i];
* Unmerged path drivers/input/mouse/synaptics.c
* Unmerged path drivers/input/touchscreen/pixcir_i2c_ts.c
diff --git a/include/linux/input/mt.h b/include/linux/input/mt.h
index 1b1dfa80d9ff..8cdce45e6f2b 100644
--- a/include/linux/input/mt.h
+++ b/include/linux/input/mt.h
@@ -118,7 +118,8 @@ struct input_mt_pos {
 };
 
 int input_mt_assign_slots(struct input_dev *dev, int *slots,
-			  const struct input_mt_pos *pos, int num_pos);
+			  const struct input_mt_pos *pos, int num_pos,
+			  int dmax);
 
 int input_mt_get_slot_by_key(struct input_dev *dev, int key);
 
