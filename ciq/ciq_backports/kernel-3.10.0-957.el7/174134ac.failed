ipmi_si: Fix error handling of platform device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Corey Minyard <cminyard@mvista.com>
commit 174134ac760275457bb0d1560a0dbe6cf8a12ad6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/174134ac.failed

Cleanup of platform devices created by the IPMI driver was not
being done correctly and could result in a memory leak.  So
create a local boolean to know how to clean up those platform
devices.

	Reported-by: David Binderman <dcb314@hotmail.com>
	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit 174134ac760275457bb0d1560a0dbe6cf8a12ad6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_si_intf.c
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 709742a62b66,7499b0cd8326..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -3483,17 -2044,17 +3483,18 @@@ static int try_smi_init(struct smi_inf
  {
  	int rv = 0;
  	int i;
 +	struct ipmi_shadow_smi_handlers *shadow_handlers;
  	char *init_name = NULL;
+ 	bool platform_device_registered = false;
  
  	pr_info(PFX "Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\n",
 -		ipmi_addr_src_to_str(new_smi->io.addr_source),
 -		si_to_str[new_smi->io.si_type],
 +		ipmi_addr_src_to_str(new_smi->addr_source),
 +		si_to_str[new_smi->si_type],
  		addr_space_to_str[new_smi->io.addr_type],
  		new_smi->io.addr_data,
 -		new_smi->io.slave_addr, new_smi->io.irq);
 +		new_smi->slave_addr, new_smi->irq);
  
 -	switch (new_smi->io.si_type) {
 +	switch (new_smi->si_type) {
  	case SI_KCS:
  		new_smi->handlers = &kcs_smi_handlers;
  		break;
@@@ -3611,7 -2174,16 +3612,20 @@@
  				rv);
  			goto out_err;
  		}
++<<<<<<< HEAD
 +		new_smi->dev_registered = 1;
++=======
+ 		platform_device_registered = true;
+ 	}
+ 
+ 	dev_set_drvdata(new_smi->io.dev, new_smi);
+ 	rv = device_add_group(new_smi->io.dev, &ipmi_si_dev_attr_group);
+ 	if (rv) {
+ 		dev_err(new_smi->io.dev,
+ 			"Unable to add device attributes: error %d\n",
+ 			rv);
+ 		goto out_err_stop_timer;
++>>>>>>> 174134ac7602 (ipmi_si: Fix error handling of platform device)
  	}
  
  	rv = ipmi_register_smi(&handlers,
@@@ -3697,22 -2271,21 +3711,31 @@@ out_err
  		kfree(new_smi->si_sm);
  		new_smi->si_sm = NULL;
  	}
 -	if (new_smi->io.addr_source_cleanup) {
 -		new_smi->io.addr_source_cleanup(&new_smi->io);
 -		new_smi->io.addr_source_cleanup = NULL;
 +	if (new_smi->addr_source_cleanup) {
 +		new_smi->addr_source_cleanup(new_smi);
 +		new_smi->addr_source_cleanup = NULL;
  	}
 -	if (new_smi->io.io_cleanup) {
 -		new_smi->io.io_cleanup(&new_smi->io);
 -		new_smi->io.io_cleanup = NULL;
 +	if (new_smi->io_cleanup) {
 +		new_smi->io_cleanup(new_smi);
 +		new_smi->io_cleanup = NULL;
  	}
  
++<<<<<<< HEAD
 +	if (new_smi->dev_registered) {
 +		platform_device_unregister(new_smi->pdev);
 +		new_smi->dev_registered = 0;
 +		new_smi->pdev = NULL;
 +	} else if (new_smi->pdev) {
 +		platform_device_put(new_smi->pdev);
 +		new_smi->pdev = NULL;
++=======
+ 	if (new_smi->pdev) {
+ 		if (platform_device_registered)
+ 			platform_device_unregister(new_smi->pdev);
+ 		else
+ 			platform_device_put(new_smi->pdev);
+ 		new_smi->pdev = NULL;
++>>>>>>> 174134ac7602 (ipmi_si: Fix error handling of platform device)
  	}
  
  	kfree(init_name);
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
