perf trace beauty: Beautify pkey_{alloc,free,mprotect} arguments

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [tools] perf trace beauty: Beautify pkey_(alloc, free, mprotect) arguments (Jiri Olsa) [1540862]
Rebuild_FUZZ: 95.38%
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 83bc9c371eaf21466f43b12d942b66c3f0d60ae5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/83bc9c37.failed

Reuse 'mprotect' beautifiers for 'pkey_mprotect'.

System wide tracing pkey_alloc, pkey_free and pkey_mprotect calls, with
backtraces:

  # perf trace -e pkey_alloc,pkey_mprotect,pkey_free --max-stack=5
     0.000 ( 0.011 ms): pkey/7818 pkey_alloc(init_val: DISABLE_ACCESS|DISABLE_WRITE) = -1 EINVAL Invalid argument
                                       syscall (/usr/lib64/libc-2.25.so)
                                       pkey_alloc (/home/acme/c/pkey)
     0.022 ( 0.003 ms): pkey/7818 pkey_mprotect(start: 0x7f28c3890000, len: 4096, prot: READ|WRITE, pkey: -1) = 0
                                       syscall (/usr/lib64/libc-2.25.so)
                                       pkey_mprotect (/home/acme/c/pkey)
     0.030 ( 0.002 ms): pkey/7818 pkey_free(pkey: -1                               ) = -1 EINVAL Invalid argument
                                       syscall (/usr/lib64/libc-2.25.so)
                                       pkey_free (/home/acme/c/pkey)

The tools/include/uapi/asm-generic/mman-common.h file is used to find
the access rights defines for the pkey_alloc syscall second argument.

Since we have the detector of changes for the tools/include header files
versus its kernel origin (include/uapi/asm-generic/mman-common.h), we'll
get whatever new flag appears for that argument automatically.

This method should be used in other cases where it is easy to generate
those flags tables because the header has properly namespaced defines
like PKEY_DISABLE_ACCESS and PKEY_DISABLE_WRITE.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/n/tip-3xq5312qlks7wtfzv2sk3nct@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 83bc9c371eaf21466f43b12d942b66c3f0d60ae5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Makefile.perf
#	tools/perf/builtin-trace.c
#	tools/perf/trace/beauty/Build
#	tools/perf/trace/beauty/beauty.h
diff --cc tools/perf/Makefile.perf
index bb39fa32cfd3,91ef44bfaf3e..000000000000
--- a/tools/perf/Makefile.perf
+++ b/tools/perf/Makefile.perf
@@@ -377,6 -387,60 +377,63 @@@ export INSTALL SHELL_PAT
  
  SHELL = $(SHELL_PATH)
  
++<<<<<<< HEAD
++=======
+ beauty_outdir := $(OUTPUT)trace/beauty/generated
+ beauty_ioctl_outdir := $(beauty_outdir)/ioctl
+ drm_ioctl_array := $(beauty_ioctl_outdir)/drm_ioctl_array.c
+ drm_hdr_dir := $(srctree)/tools/include/uapi/drm
+ drm_ioctl_tbl := $(srctree)/tools/perf/trace/beauty/drm_ioctl.sh
+ 
+ # Create output directory if not already present
+ _dummy := $(shell [ -d '$(beauty_ioctl_outdir)' ] || mkdir -p '$(beauty_ioctl_outdir)')
+ 
+ $(drm_ioctl_array): $(drm_hdr_dir)/drm.h $(drm_hdr_dir)/i915_drm.h $(drm_ioctl_tbl)
+ 	$(Q)$(SHELL) '$(drm_ioctl_tbl)' $(drm_hdr_dir) > $@
+ 
+ pkey_alloc_access_rights_array := $(beauty_outdir)/pkey_alloc_access_rights_array.c
+ asm_generic_hdr_dir := $(srctree)/tools/include/uapi/asm-generic/
+ pkey_alloc_access_rights_tbl := $(srctree)/tools/perf/trace/beauty/pkey_alloc_access_rights.sh
+ 
+ $(pkey_alloc_access_rights_array): $(asm_generic_hdr_dir)/mman-common.h $(pkey_alloc_access_rights_tbl)
+ 	$(Q)$(SHELL) '$(pkey_alloc_access_rights_tbl)' $(asm_generic_hdr_dir) > $@
+ 
+ sndrv_ctl_ioctl_array := $(beauty_ioctl_outdir)/sndrv_ctl_ioctl_array.c
+ sndrv_ctl_hdr_dir := $(srctree)/tools/include/uapi/sound
+ sndrv_ctl_ioctl_tbl := $(srctree)/tools/perf/trace/beauty/sndrv_ctl_ioctl.sh
+ 
+ $(sndrv_ctl_ioctl_array): $(sndrv_ctl_hdr_dir)/asound.h $(sndrv_ctl_ioctl_tbl)
+ 	$(Q)$(SHELL) '$(sndrv_ctl_ioctl_tbl)' $(sndrv_ctl_hdr_dir) > $@
+ 
+ sndrv_pcm_ioctl_array := $(beauty_ioctl_outdir)/sndrv_pcm_ioctl_array.c
+ sndrv_pcm_hdr_dir := $(srctree)/tools/include/uapi/sound
+ sndrv_pcm_ioctl_tbl := $(srctree)/tools/perf/trace/beauty/sndrv_pcm_ioctl.sh
+ 
+ $(sndrv_pcm_ioctl_array): $(sndrv_pcm_hdr_dir)/asound.h $(sndrv_pcm_ioctl_tbl)
+ 	$(Q)$(SHELL) '$(sndrv_pcm_ioctl_tbl)' $(sndrv_pcm_hdr_dir) > $@
+ 
+ kvm_ioctl_array := $(beauty_ioctl_outdir)/kvm_ioctl_array.c
+ kvm_hdr_dir := $(srctree)/tools/include/uapi/linux
+ kvm_ioctl_tbl := $(srctree)/tools/perf/trace/beauty/kvm_ioctl.sh
+ 
+ $(kvm_ioctl_array): $(kvm_hdr_dir)/kvm.h $(kvm_ioctl_tbl)
+ 	$(Q)$(SHELL) '$(kvm_ioctl_tbl)' $(kvm_hdr_dir) > $@
+ 
+ vhost_virtio_ioctl_array := $(beauty_ioctl_outdir)/vhost_virtio_ioctl_array.c
+ vhost_virtio_hdr_dir := $(srctree)/tools/include/uapi/linux
+ vhost_virtio_ioctl_tbl := $(srctree)/tools/perf/trace/beauty/vhost_virtio_ioctl.sh
+ 
+ $(vhost_virtio_ioctl_array): $(vhost_virtio_hdr_dir)/vhost.h $(vhost_virtio_ioctl_tbl)
+ 	$(Q)$(SHELL) '$(vhost_virtio_ioctl_tbl)' $(vhost_virtio_hdr_dir) > $@
+ 
+ perf_ioctl_array := $(beauty_ioctl_outdir)/perf_ioctl_array.c
+ perf_hdr_dir := $(srctree)/tools/include/uapi/linux
+ perf_ioctl_tbl := $(srctree)/tools/perf/trace/beauty/perf_ioctl.sh
+ 
+ $(perf_ioctl_array): $(perf_hdr_dir)/perf_event.h $(perf_ioctl_tbl)
+ 	$(Q)$(SHELL) '$(perf_ioctl_tbl)' $(perf_hdr_dir) > $@
+ 
++>>>>>>> 83bc9c371eaf (perf trace beauty: Beautify pkey_{alloc,free,mprotect} arguments)
  all: shell_compatibility_test $(ALL_PROGRAMS) $(LANG_BINDINGS) $(OTHER_PROGRAMS)
  
  $(OUTPUT)python/perf.so: $(PYTHON_EXT_SRCS) $(PYTHON_EXT_DEPS) $(LIBTRACEEVENT_DYNAMIC_LIST)
@@@ -486,7 -535,13 +543,17 @@@ endi
  __build-dir = $(subst $(OUTPUT),,$(dir $@))
  build-dir   = $(if $(__build-dir),$(__build-dir),.)
  
++<<<<<<< HEAD
 +prepare: $(OUTPUT)PERF-VERSION-FILE $(OUTPUT)common-cmds.h archheaders
++=======
+ prepare: $(OUTPUT)PERF-VERSION-FILE $(OUTPUT)common-cmds.h archheaders $(drm_ioctl_array) \
+ 	$(pkey_alloc_access_rights_array) \
+ 	$(sndrv_pcm_ioctl_array) \
+ 	$(sndrv_ctl_ioctl_array) \
+ 	$(kvm_ioctl_array) \
+ 	$(vhost_virtio_ioctl_array) \
+ 	$(perf_ioctl_array)
++>>>>>>> 83bc9c371eaf (perf trace beauty: Beautify pkey_{alloc,free,mprotect} arguments)
  
  $(OUTPUT)%.o: %.c prepare FORCE
  	$(Q)$(MAKE) -f $(srctree)/tools/build/Makefile.build dir=$(build-dir) $@
@@@ -747,8 -809,15 +814,20 @@@ clean:: $(LIBTRACEEVENT)-clean $(LIBAPI
  	$(call QUIET_CLEAN, core-progs) $(RM) $(ALL_PROGRAMS) perf perf-read-vdso32 perf-read-vdsox32 $(OUTPUT)pmu-events/jevents $(OUTPUT)$(LIBJVMTI).so
  	$(call QUIET_CLEAN, core-gen)   $(RM)  *.spec *.pyc *.pyo */*.pyc */*.pyo $(OUTPUT)common-cmds.h TAGS tags cscope* $(OUTPUT)PERF-VERSION-FILE $(OUTPUT)FEATURE-DUMP $(OUTPUT)util/*-bison* $(OUTPUT)util/*-flex* \
  		$(OUTPUT)util/intel-pt-decoder/inat-tables.c \
++<<<<<<< HEAD
 +		$(OUTPUT)tests/llvm-src-{base,kbuild,prologue}.c \
 +		$(OUTPUT)pmu-events/pmu-events.c
++=======
+ 		$(OUTPUT)tests/llvm-src-{base,kbuild,prologue,relocation}.c \
+ 		$(OUTPUT)pmu-events/pmu-events.c \
+ 		$(OUTPUT)$(drm_ioctl_array) \
+ 		$(OUTPUT)$(pkey_alloc_access_rights_array) \
+ 		$(OUTPUT)$(sndrv_ctl_ioctl_array) \
+ 		$(OUTPUT)$(sndrv_pcm_ioctl_array) \
+ 		$(OUTPUT)$(kvm_ioctl_array) \
+ 		$(OUTPUT)$(vhost_virtio_ioctl_array) \
+ 		$(OUTPUT)$(perf_ioctl_array)
++>>>>>>> 83bc9c371eaf (perf trace beauty: Beautify pkey_{alloc,free,mprotect} arguments)
  	$(QUIET_SUBDIR0)Documentation $(QUIET_SUBDIR1) clean
  	$(python-clean)
  
diff --cc tools/perf/builtin-trace.c
index 956c6a4028b7,d59cdadf3a79..000000000000
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@@ -712,132 -659,120 +712,205 @@@ static struct syscall_fmt 
  #if defined(__s390x__)
  	.alias = "old_mmap",
  #endif
 -	  .arg = { [0] = { .scnprintf = SCA_HEX,	/* addr */ },
 -		   [2] = { .scnprintf = SCA_MMAP_PROT,	/* prot */ },
 -		   [3] = { .scnprintf = SCA_MMAP_FLAGS,	/* flags */ }, }, },
 -	{ .name	    = "mprotect",
 -	  .arg = { [0] = { .scnprintf = SCA_HEX,	/* start */ },
 -		   [2] = { .scnprintf = SCA_MMAP_PROT,	/* prot */ }, }, },
 -	{ .name	    = "mq_unlink",
 -	  .arg = { [0] = { .scnprintf = SCA_FILENAME, /* u_name */ }, }, },
 +	  .arg_scnprintf = { [0] = SCA_HEX,	  /* addr */
 +			     [2] = SCA_MMAP_PROT, /* prot */
 +			     [3] = SCA_MMAP_FLAGS, /* flags */ }, },
 +	{ .name	    = "mprotect",   .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_HEX, /* start */
 +			     [2] = SCA_MMAP_PROT, /* prot */ }, },
 +	{ .name	    = "mq_unlink", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FILENAME, /* u_name */ }, },
  	{ .name	    = "mremap",	    .hexret = true,
++<<<<<<< HEAD
 +	  .arg_scnprintf = { [0] = SCA_HEX, /* addr */
 +			     [3] = SCA_MREMAP_FLAGS, /* flags */
 +			     [4] = SCA_HEX, /* new_addr */ }, },
 +	{ .name	    = "munlock",    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_HEX, /* addr */ }, },
 +	{ .name	    = "munmap",	    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_HEX, /* addr */ }, },
 +	{ .name	    = "name_to_handle_at", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dfd */ }, },
 +	{ .name	    = "newfstatat", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dfd */ }, },
 +	{ .name	    = "open",	    .errmsg = true,
 +	  .arg_scnprintf = { [1] = SCA_OPEN_FLAGS, /* flags */ }, },
 +	{ .name	    = "open_by_handle_at", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dfd */
 +			     [2] = SCA_OPEN_FLAGS, /* flags */ }, },
 +	{ .name	    = "openat",	    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dfd */
 +			     [2] = SCA_OPEN_FLAGS, /* flags */ }, },
 +	{ .name	    = "perf_event_open", .errmsg = true,
 +	  .arg_scnprintf = { [2] = SCA_INT, /* cpu */
 +			     [3] = SCA_FD,  /* group_fd */
 +			     [4] = SCA_PERF_FLAGS,  /* flags */ }, },
 +	{ .name	    = "pipe2",	    .errmsg = true,
 +	  .arg_scnprintf = { [1] = SCA_PIPE_FLAGS, /* flags */ }, },
 +	{ .name	    = "poll",	    .errmsg = true, .timeout = true, },
 +	{ .name	    = "ppoll",	    .errmsg = true, .timeout = true, },
 +	{ .name	    = "pread",	    .errmsg = true, .alias = "pread64", },
 +	{ .name	    = "preadv",	    .errmsg = true, .alias = "pread", },
 +	{ .name	    = "prlimit64",  .errmsg = true, STRARRAY(1, resource, rlimit_resources), },
 +	{ .name	    = "pwrite",	    .errmsg = true, .alias = "pwrite64", },
 +	{ .name	    = "pwritev",    .errmsg = true, },
 +	{ .name	    = "read",	    .errmsg = true, },
 +	{ .name	    = "readlink",   .errmsg = true, },
 +	{ .name	    = "readlinkat", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dfd */ }, },
 +	{ .name	    = "readv",	    .errmsg = true, },
 +	{ .name	    = "recvfrom",   .errmsg = true,
 +	  .arg_scnprintf = { [3] = SCA_MSG_FLAGS, /* flags */ }, },
 +	{ .name	    = "recvmmsg",   .errmsg = true,
 +	  .arg_scnprintf = { [3] = SCA_MSG_FLAGS, /* flags */ }, },
 +	{ .name	    = "recvmsg",    .errmsg = true,
 +	  .arg_scnprintf = { [2] = SCA_MSG_FLAGS, /* flags */ }, },
 +	{ .name	    = "removexattr", .errmsg = true, },
 +	{ .name	    = "renameat",   .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dfd */ }, },
 +	{ .name	    = "rmdir",    .errmsg = true, },
 +	{ .name	    = "rt_sigaction", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_SIGNUM, /* sig */ }, },
 +	{ .name	    = "rt_sigprocmask",  .errmsg = true, STRARRAY(0, how, sighow), },
 +	{ .name	    = "rt_sigqueueinfo", .errmsg = true,
 +	  .arg_scnprintf = { [1] = SCA_SIGNUM, /* sig */ }, },
 +	{ .name	    = "rt_tgsigqueueinfo", .errmsg = true,
 +	  .arg_scnprintf = { [2] = SCA_SIGNUM, /* sig */ }, },
 +	{ .name	    = "sched_getattr",	      .errmsg = true, },
 +	{ .name	    = "sched_setattr",	      .errmsg = true, },
 +	{ .name	    = "sched_setscheduler",   .errmsg = true,
 +	  .arg_scnprintf = { [1] = SCA_SCHED_POLICY, /* policy */ }, },
 +	{ .name	    = "seccomp", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_SECCOMP_OP, /* op */
 +			     [1] = SCA_SECCOMP_FLAGS, /* flags */ }, },
 +	{ .name	    = "select",	    .errmsg = true, .timeout = true, },
 +	{ .name	    = "sendmmsg",    .errmsg = true,
 +	  .arg_scnprintf = { [3] = SCA_MSG_FLAGS, /* flags */ }, },
 +	{ .name	    = "sendmsg",    .errmsg = true,
 +	  .arg_scnprintf = { [2] = SCA_MSG_FLAGS, /* flags */ }, },
 +	{ .name	    = "sendto",	    .errmsg = true,
 +	  .arg_scnprintf = { [3] = SCA_MSG_FLAGS, /* flags */ }, },
++=======
+ 	  .arg = { [0] = { .scnprintf = SCA_HEX,	  /* addr */ },
+ 		   [3] = { .scnprintf = SCA_MREMAP_FLAGS, /* flags */ },
+ 		   [4] = { .scnprintf = SCA_HEX,	  /* new_addr */ }, }, },
+ 	{ .name	    = "munlock",
+ 	  .arg = { [0] = { .scnprintf = SCA_HEX, /* addr */ }, }, },
+ 	{ .name	    = "munmap",
+ 	  .arg = { [0] = { .scnprintf = SCA_HEX, /* addr */ }, }, },
+ 	{ .name	    = "name_to_handle_at",
+ 	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* dfd */ }, }, },
+ 	{ .name	    = "newfstatat",
+ 	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* dfd */ }, }, },
+ 	{ .name	    = "open",
+ 	  .arg = { [1] = { .scnprintf = SCA_OPEN_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "open_by_handle_at",
+ 	  .arg = { [0] = { .scnprintf = SCA_FDAT,	/* dfd */ },
+ 		   [2] = { .scnprintf = SCA_OPEN_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "openat",
+ 	  .arg = { [0] = { .scnprintf = SCA_FDAT,	/* dfd */ },
+ 		   [2] = { .scnprintf = SCA_OPEN_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "perf_event_open",
+ 	  .arg = { [2] = { .scnprintf = SCA_INT,	/* cpu */ },
+ 		   [3] = { .scnprintf = SCA_FD,		/* group_fd */ },
+ 		   [4] = { .scnprintf = SCA_PERF_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "pipe2",
+ 	  .arg = { [1] = { .scnprintf = SCA_PIPE_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "pkey_alloc",
+ 	  .arg = { [1] = { .scnprintf = SCA_PKEY_ALLOC_ACCESS_RIGHTS,	/* access_rights */ }, }, },
+ 	{ .name	    = "pkey_free",
+ 	  .arg = { [0] = { .scnprintf = SCA_INT,	/* key */ }, }, },
+ 	{ .name	    = "pkey_mprotect",
+ 	  .arg = { [0] = { .scnprintf = SCA_HEX,	/* start */ },
+ 		   [2] = { .scnprintf = SCA_MMAP_PROT,	/* prot */ },
+ 		   [3] = { .scnprintf = SCA_INT,	/* pkey */ }, }, },
+ 	{ .name	    = "poll", .timeout = true, },
+ 	{ .name	    = "ppoll", .timeout = true, },
+ 	{ .name	    = "pread", .alias = "pread64", },
+ 	{ .name	    = "preadv", .alias = "pread", },
+ 	{ .name	    = "prlimit64",
+ 	  .arg = { [1] = STRARRAY(resource, rlimit_resources), }, },
+ 	{ .name	    = "pwrite", .alias = "pwrite64", },
+ 	{ .name	    = "readlinkat",
+ 	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* dfd */ }, }, },
+ 	{ .name	    = "recvfrom",
+ 	  .arg = { [3] = { .scnprintf = SCA_MSG_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "recvmmsg",
+ 	  .arg = { [3] = { .scnprintf = SCA_MSG_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "recvmsg",
+ 	  .arg = { [2] = { .scnprintf = SCA_MSG_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "renameat",
+ 	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* dfd */ }, }, },
+ 	{ .name	    = "rt_sigaction",
+ 	  .arg = { [0] = { .scnprintf = SCA_SIGNUM, /* sig */ }, }, },
+ 	{ .name	    = "rt_sigprocmask",
+ 	  .arg = { [0] = STRARRAY(how, sighow), }, },
+ 	{ .name	    = "rt_sigqueueinfo",
+ 	  .arg = { [1] = { .scnprintf = SCA_SIGNUM, /* sig */ }, }, },
+ 	{ .name	    = "rt_tgsigqueueinfo",
+ 	  .arg = { [2] = { .scnprintf = SCA_SIGNUM, /* sig */ }, }, },
+ 	{ .name	    = "sched_setscheduler",
+ 	  .arg = { [1] = { .scnprintf = SCA_SCHED_POLICY, /* policy */ }, }, },
+ 	{ .name	    = "seccomp",
+ 	  .arg = { [0] = { .scnprintf = SCA_SECCOMP_OP,	   /* op */ },
+ 		   [1] = { .scnprintf = SCA_SECCOMP_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "select", .timeout = true, },
+ 	{ .name	    = "sendmmsg",
+ 	  .arg = { [3] = { .scnprintf = SCA_MSG_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "sendmsg",
+ 	  .arg = { [2] = { .scnprintf = SCA_MSG_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "sendto",
+ 	  .arg = { [3] = { .scnprintf = SCA_MSG_FLAGS, /* flags */ }, }, },
++>>>>>>> 83bc9c371eaf (perf trace beauty: Beautify pkey_{alloc,free,mprotect} arguments)
  	{ .name	    = "set_tid_address", .errpid = true, },
 -	{ .name	    = "setitimer",
 -	  .arg = { [0] = STRARRAY(which, itimers), }, },
 -	{ .name	    = "setrlimit",
 -	  .arg = { [0] = STRARRAY(resource, rlimit_resources), }, },
 -	{ .name	    = "socket",
 -	  .arg = { [0] = STRARRAY(family, socket_families),
 -		   [1] = { .scnprintf = SCA_SK_TYPE, /* type */ }, }, },
 -	{ .name	    = "socketpair",
 -	  .arg = { [0] = STRARRAY(family, socket_families),
 -		   [1] = { .scnprintf = SCA_SK_TYPE, /* type */ }, }, },
 -	{ .name	    = "stat", .alias = "newstat", },
 -	{ .name	    = "statx",
 -	  .arg = { [0] = { .scnprintf = SCA_FDAT,	 /* fdat */ },
 -		   [2] = { .scnprintf = SCA_STATX_FLAGS, /* flags */ } ,
 -		   [3] = { .scnprintf = SCA_STATX_MASK,	 /* mask */ }, }, },
 -	{ .name	    = "swapoff",
 -	  .arg = { [0] = { .scnprintf = SCA_FILENAME, /* specialfile */ }, }, },
 -	{ .name	    = "swapon",
 -	  .arg = { [0] = { .scnprintf = SCA_FILENAME, /* specialfile */ }, }, },
 -	{ .name	    = "symlinkat",
 -	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* dfd */ }, }, },
 -	{ .name	    = "tgkill",
 -	  .arg = { [2] = { .scnprintf = SCA_SIGNUM, /* sig */ }, }, },
 -	{ .name	    = "tkill",
 -	  .arg = { [1] = { .scnprintf = SCA_SIGNUM, /* sig */ }, }, },
 -	{ .name	    = "uname", .alias = "newuname", },
 -	{ .name	    = "unlinkat",
 -	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* dfd */ }, }, },
 -	{ .name	    = "utimensat",
 -	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* dirfd */ }, }, },
 +	{ .name	    = "setitimer",  .errmsg = true, STRARRAY(0, which, itimers), },
 +	{ .name	    = "setpgid",    .errmsg = true, },
 +	{ .name	    = "setrlimit",  .errmsg = true, STRARRAY(0, resource, rlimit_resources), },
 +	{ .name     = "setxattr",   .errmsg = true, },
 +	{ .name     = "shutdown",   .errmsg = true, },
 +	{ .name	    = "socket",	    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_STRARRAY, /* family */
 +			     [1] = SCA_SK_TYPE, /* type */ },
 +	  .arg_parm	 = { [0] = &strarray__socket_families, /* family */ }, },
 +	{ .name	    = "socketpair", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_STRARRAY, /* family */
 +			     [1] = SCA_SK_TYPE, /* type */ },
 +	  .arg_parm	 = { [0] = &strarray__socket_families, /* family */ }, },
 +	{ .name	    = "stat",	    .errmsg = true, .alias = "newstat", },
 +	{ .name	    = "statfs",	    .errmsg = true, },
 +#if 0
 +	XXX there is no statx syscall in RHEL7
 +
 +	{ .name	    = "statx",	    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* flags */
 +			     [2] = SCA_STATX_FLAGS, /* flags */
 +			     [3] = SCA_STATX_MASK, /* mask */ }, },
 +#endif
 +	{ .name	    = "swapoff",    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FILENAME, /* specialfile */ }, },
 +	{ .name	    = "swapon",	    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FILENAME, /* specialfile */ }, },
 +	{ .name	    = "symlinkat",  .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dfd */ }, },
 +	{ .name	    = "tgkill",	    .errmsg = true,
 +	  .arg_scnprintf = { [2] = SCA_SIGNUM, /* sig */ }, },
 +	{ .name	    = "tkill",	    .errmsg = true,
 +	  .arg_scnprintf = { [1] = SCA_SIGNUM, /* sig */ }, },
 +	{ .name	    = "truncate",   .errmsg = true, },
 +	{ .name	    = "uname",	    .errmsg = true, .alias = "newuname", },
 +	{ .name	    = "unlinkat",   .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dfd */ }, },
 +	{ .name	    = "utime",  .errmsg = true, },
 +	{ .name	    = "utimensat",  .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dirfd */ }, },
 +	{ .name	    = "utimes",  .errmsg = true, },
 +	{ .name	    = "vmsplice",  .errmsg = true, },
  	{ .name	    = "wait4",	    .errpid = true,
 -	  .arg = { [2] = { .scnprintf = SCA_WAITID_OPTIONS, /* options */ }, }, },
 +	  .arg_scnprintf = { [2] = SCA_WAITID_OPTIONS, /* options */ }, },
  	{ .name	    = "waitid",	    .errpid = true,
 -	  .arg = { [3] = { .scnprintf = SCA_WAITID_OPTIONS, /* options */ }, }, },
 +	  .arg_scnprintf = { [3] = SCA_WAITID_OPTIONS, /* options */ }, },
 +	{ .name	    = "write",	    .errmsg = true, },
 +	{ .name	    = "writev",	    .errmsg = true, },
  };
  
  static int syscall_fmt__cmp(const void *name, const void *fmtp)
diff --cc tools/perf/trace/beauty/Build
index 55f4f086ea37,175d633c6b49..000000000000
--- a/tools/perf/trace/beauty/Build
+++ b/tools/perf/trace/beauty/Build
@@@ -1,2 -1,7 +1,12 @@@
++<<<<<<< HEAD
 +# XXX there's no statx syscall in RHEL7
 +#libperf-y += statx.o
++=======
+ libperf-y += clone.o
+ libperf-y += fcntl.o
+ ifeq ($(SRCARCH),$(filter $(SRCARCH),x86))
+ libperf-y += ioctl.o
+ endif
+ libperf-y += pkey_alloc.o
+ libperf-y += statx.o
++>>>>>>> 83bc9c371eaf (perf trace beauty: Beautify pkey_{alloc,free,mprotect} arguments)
diff --cc tools/perf/trace/beauty/beauty.h
index d493f9e76cf1,4b58581a6053..000000000000
--- a/tools/perf/trace/beauty/beauty.h
+++ b/tools/perf/trace/beauty/beauty.h
@@@ -51,6 -51,39 +51,42 @@@ unsigned long syscall_arg__val(struct s
  size_t syscall_arg__scnprintf_strarrays(char *bf, size_t size, struct syscall_arg *arg);
  #define SCA_STRARRAYS syscall_arg__scnprintf_strarrays
  
++<<<<<<< HEAD
++=======
+ size_t syscall_arg__scnprintf_fd(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_FD syscall_arg__scnprintf_fd
+ 
+ size_t syscall_arg__scnprintf_hex(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_HEX syscall_arg__scnprintf_hex
+ 
+ size_t syscall_arg__scnprintf_int(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_INT syscall_arg__scnprintf_int
+ 
+ size_t syscall_arg__scnprintf_long(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_LONG syscall_arg__scnprintf_long
+ 
+ size_t syscall_arg__scnprintf_pid(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_PID syscall_arg__scnprintf_pid
+ 
+ size_t syscall_arg__scnprintf_clone_flags(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_CLONE_FLAGS syscall_arg__scnprintf_clone_flags
+ 
+ size_t syscall_arg__scnprintf_fcntl_cmd(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_FCNTL_CMD syscall_arg__scnprintf_fcntl_cmd
+ 
+ size_t syscall_arg__scnprintf_fcntl_arg(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_FCNTL_ARG syscall_arg__scnprintf_fcntl_arg
+ 
+ size_t syscall_arg__scnprintf_ioctl_cmd(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_IOCTL_CMD syscall_arg__scnprintf_ioctl_cmd
+ 
+ size_t syscall_arg__scnprintf_pkey_alloc_access_rights(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_PKEY_ALLOC_ACCESS_RIGHTS syscall_arg__scnprintf_pkey_alloc_access_rights
+ 
+ size_t syscall_arg__scnprintf_open_flags(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_OPEN_FLAGS syscall_arg__scnprintf_open_flags
+ 
++>>>>>>> 83bc9c371eaf (perf trace beauty: Beautify pkey_{alloc,free,mprotect} arguments)
  size_t syscall_arg__scnprintf_statx_flags(char *bf, size_t size, struct syscall_arg *arg);
  #define SCA_STATX_FLAGS syscall_arg__scnprintf_statx_flags
  
* Unmerged path tools/perf/Makefile.perf
* Unmerged path tools/perf/builtin-trace.c
* Unmerged path tools/perf/trace/beauty/Build
* Unmerged path tools/perf/trace/beauty/beauty.h
diff --git a/tools/perf/trace/beauty/pkey_alloc.c b/tools/perf/trace/beauty/pkey_alloc.c
new file mode 100644
index 000000000000..2ba784a3734a
--- /dev/null
+++ b/tools/perf/trace/beauty/pkey_alloc.c
@@ -0,0 +1,50 @@
+/*
+ * trace/beauty/pkey_alloc.c
+ *
+ *  Copyright (C) 2017, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
+ *
+ * Released under the GPL v2. (and only v2, not any later version)
+ */
+
+#include "trace/beauty/beauty.h"
+#include <linux/kernel.h>
+#include <linux/log2.h>
+
+static size_t pkey_alloc__scnprintf_access_rights(int access_rights, char *bf, size_t size)
+{
+	int i, printed = 0;
+
+#include "trace/beauty/generated/pkey_alloc_access_rights_array.c"
+	static DEFINE_STRARRAY(pkey_alloc_access_rights);
+
+	if (access_rights == 0) {
+		const char *s = strarray__pkey_alloc_access_rights.entries[0];
+		if (s)
+			return scnprintf(bf, size, "%s", s);
+		return scnprintf(bf, size, "%d", 0);
+	}
+
+	for (i = 1; i < strarray__pkey_alloc_access_rights.nr_entries; ++i) {
+		int bit = 1 << (i - 1);
+
+		if (!(access_rights & bit))
+			continue;
+
+		if (printed != 0)
+			printed += scnprintf(bf + printed, size - printed, "|");
+
+		if (strarray__pkey_alloc_access_rights.entries[i] != NULL)
+			printed += scnprintf(bf + printed, size - printed, "%s", strarray__pkey_alloc_access_rights.entries[i]);
+		else
+			printed += scnprintf(bf + printed, size - printed, "0x%#", bit);
+	}
+
+	return printed;
+}
+
+size_t syscall_arg__scnprintf_pkey_alloc_access_rights(char *bf, size_t size, struct syscall_arg *arg)
+{
+	unsigned long cmd = arg->val;
+
+	return pkey_alloc__scnprintf_access_rights(cmd, bf, size);
+}
diff --git a/tools/perf/trace/beauty/pkey_alloc_access_rights.sh b/tools/perf/trace/beauty/pkey_alloc_access_rights.sh
new file mode 100755
index 000000000000..62e51a02b839
--- /dev/null
+++ b/tools/perf/trace/beauty/pkey_alloc_access_rights.sh
@@ -0,0 +1,10 @@
+#!/bin/sh
+
+header_dir=$1
+
+printf "static const char *pkey_alloc_access_rights[] = {\n"
+regex='^[[:space:]]*#[[:space:]]*define[[:space:]]+PKEY_([[:alnum:]_]+)[[:space:]]+(0x[[:xdigit:]]+)[[:space:]]*'
+egrep $regex ${header_dir}/mman-common.h	| \
+	sed -r "s/$regex/\2 \2 \1/g"	| \
+	sort | xargs printf "\t[%s ? (ilog2(%s) + 1) : 0] = \"%s\",\n"
+printf "};\n"
