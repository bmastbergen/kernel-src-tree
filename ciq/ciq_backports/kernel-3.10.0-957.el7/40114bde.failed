scsi: mpt3sas: Do not use 32-bit atomic request descriptor for Ventura controllers.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] mpt3sas: Do not use 32-bit atomic request descriptor for Ventura controllers (Tomas Henzl) [1545041]
Rebuild_FUZZ: 95.60%
commit-author Suganath Prabu S <suganath-prabu.subramani@broadcom.com>
commit 40114bde9773ccaf9ad77233ac2cc9039f0f2941
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/40114bde.failed

Sending I/O through 32 bit descriptors to Ventura series of controller
results in IO timeout on certain conditions. This error only occurs on
systems with high I/O activity.

Changes in this patch will prevent driver from using 32 bit descriptor
and use 64 bit Descriptors

	Signed-off-by: Suganath Prabu S <suganath-prabu.subramani@broadcom.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 40114bde9773ccaf9ad77233ac2cc9039f0f2941)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpt3sas/mpt3sas_base.c
#	drivers/scsi/mpt3sas/mpt3sas_base.h
#	drivers/scsi/mpt3sas/mpt3sas_ctl.c
#	drivers/scsi/mpt3sas/mpt3sas_scsih.c
diff --cc drivers/scsi/mpt3sas/mpt3sas_base.c
index f97efb01b7c5,84a79ea9caa2..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_base.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c
@@@ -2549,6 -3480,35 +2549,38 @@@ mpt3sas_base_put_smid_hi_priority(struc
  	descriptor.HighPriority.SMID = cpu_to_le16(smid);
  	descriptor.HighPriority.LMID = 0;
  	descriptor.HighPriority.Reserved1 = 0;
++<<<<<<< HEAD
++=======
+ 	if (ioc->is_mcpu_endpoint)
+ 		_base_mpi_ep_writeq(*request,
+ 				&ioc->chip->RequestDescriptorPostLow,
+ 				&ioc->scsi_lookup_lock);
+ 	else
+ 		_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
+ 		    &ioc->scsi_lookup_lock);
+ }
+ 
+ /**
+  * mpt3sas_base_put_smid_nvme_encap - send NVMe encapsulated request to
+  *  firmware
+  * @ioc: per adapter object
+  * @smid: system request message index
+  *
+  * Return nothing.
+  */
+ void
+ mpt3sas_base_put_smid_nvme_encap(struct MPT3SAS_ADAPTER *ioc, u16 smid)
+ {
+ 	Mpi2RequestDescriptorUnion_t descriptor;
+ 	u64 *request = (u64 *)&descriptor;
+ 
+ 	descriptor.Default.RequestFlags =
+ 		MPI26_REQ_DESCRIPT_FLAGS_PCIE_ENCAPSULATED;
+ 	descriptor.Default.MSIxIndex =  _base_get_msix_index(ioc);
+ 	descriptor.Default.SMID = cpu_to_le16(smid);
+ 	descriptor.Default.LMID = 0;
+ 	descriptor.Default.DescriptorTypeDependent = 0;
++>>>>>>> 40114bde9773 (scsi: mpt3sas: Do not use 32-bit atomic request descriptor for Ventura controllers.)
  	_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
  	    &ioc->scsi_lookup_lock);
  }
@@@ -2560,111 -3520,42 +2592,114 @@@
   *
   * Return nothing.
   */
- static void
- _base_put_smid_default(struct MPT3SAS_ADAPTER *ioc, u16 smid)
+ void
+ mpt3sas_base_put_smid_default(struct MPT3SAS_ADAPTER *ioc, u16 smid)
  {
  	Mpi2RequestDescriptorUnion_t descriptor;
 -	void *mpi_req_iomem;
 -	u64 *request;
 -	MPI2RequestHeader_t *request_hdr;
 -
 -	if (ioc->is_mcpu_endpoint) {
 -		__le32 *mfp = (__le32 *)mpt3sas_base_get_msg_frame(ioc, smid);
 -
 -		request_hdr = (MPI2RequestHeader_t *)mfp;
 +	u64 *request = (u64 *)&descriptor;
  
 -		_clone_sg_entries(ioc, (void *) mfp, smid);
 -		/* TBD 256 is offset within sys register */
 -		mpi_req_iomem = (void *)ioc->chip +
 -			MPI_FRAME_START_OFFSET + (smid * ioc->request_sz);
 -		_base_clone_mpi_to_sys_mem(mpi_req_iomem, (void *)mfp,
 -							ioc->request_sz);
 -	}
 -	request = (u64 *)&descriptor;
  	descriptor.Default.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE;
  	descriptor.Default.MSIxIndex =  _base_get_msix_index(ioc);
  	descriptor.Default.SMID = cpu_to_le16(smid);
  	descriptor.Default.LMID = 0;
  	descriptor.Default.DescriptorTypeDependent = 0;
 -	if (ioc->is_mcpu_endpoint)
 -		_base_mpi_ep_writeq(*request,
 -				&ioc->chip->RequestDescriptorPostLow,
 -				&ioc->scsi_lookup_lock);
 -	else
 -		_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
 -				&ioc->scsi_lookup_lock);
 +	_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
 +	    &ioc->scsi_lookup_lock);
 +}
 +
 +/**
++<<<<<<< HEAD
 +* _base_put_smid_scsi_io_atomic - send SCSI_IO request to firmware using
 +*   Atomic Request Descriptor
 +* @ioc: per adapter object
 +* @smid: system request message index
 +* @handle: device handle, unused in this function, for function type match
 +*
 +* Return nothing.
 +*/
 +static void
 +_base_put_smid_scsi_io_atomic(struct MPT3SAS_ADAPTER *ioc, u16 smid,
 +	u16 handle)
 +{
 +	Mpi26AtomicRequestDescriptor_t descriptor;
 +	u32 *request = (u32 *)&descriptor;
 +
 +	descriptor.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO;
 +	descriptor.MSIxIndex = _base_get_msix_index(ioc);
 +	descriptor.SMID = cpu_to_le16(smid);
 +
 +	writel(cpu_to_le32(*request), &ioc->chip->AtomicRequestDescriptorPost);
 +}
 +
 +/**
 + * _base_put_smid_fast_path_atomic - send fast path request to firmware
 + * using Atomic Request Descriptor
 + * @ioc: per adapter object
 + * @smid: system request message index
 + * @handle: device handle, unused in this function, for function type match
 + * Return nothing
 + */
 +static void
 +_base_put_smid_fast_path_atomic(struct MPT3SAS_ADAPTER *ioc, u16 smid,
 +	u16 handle)
 +{
 +	Mpi26AtomicRequestDescriptor_t descriptor;
 +	u32 *request = (u32 *)&descriptor;
 +
 +	descriptor.RequestFlags = MPI25_REQ_DESCRIPT_FLAGS_FAST_PATH_SCSI_IO;
 +	descriptor.MSIxIndex = _base_get_msix_index(ioc);
 +	descriptor.SMID = cpu_to_le16(smid);
 +
 +	writel(cpu_to_le32(*request), &ioc->chip->AtomicRequestDescriptorPost);
 +}
 +
 +/**
 + * _base_put_smid_hi_priority_atomic - send Task Management request to
 + * firmware using Atomic Request Descriptor
 + * @ioc: per adapter object
 + * @smid: system request message index
 + * @msix_task: msix_task will be same as msix of IO incase of task abort else 0
 + *
 + * Return nothing.
 + */
 +static void
 +_base_put_smid_hi_priority_atomic(struct MPT3SAS_ADAPTER *ioc, u16 smid,
 +	u16 msix_task)
 +{
 +	Mpi26AtomicRequestDescriptor_t descriptor;
 +	u32 *request = (u32 *)&descriptor;
 +
 +	descriptor.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY;
 +	descriptor.MSIxIndex = msix_task;
 +	descriptor.SMID = cpu_to_le16(smid);
 +
 +	writel(cpu_to_le32(*request), &ioc->chip->AtomicRequestDescriptorPost);
 +}
 +
 +/**
 + * _base_put_smid_default - Default, primarily used for config pages
 + * use Atomic Request Descriptor
 + * @ioc: per adapter object
 + * @smid: system request message index
 + *
 + * Return nothing.
 + */
 +static void
 +_base_put_smid_default_atomic(struct MPT3SAS_ADAPTER *ioc, u16 smid)
 +{
 +	Mpi26AtomicRequestDescriptor_t descriptor;
 +	u32 *request = (u32 *)&descriptor;
 +
 +	descriptor.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE;
 +	descriptor.MSIxIndex = _base_get_msix_index(ioc);
 +	descriptor.SMID = cpu_to_le16(smid);
 +
 +	writel(cpu_to_le32(*request), &ioc->chip->AtomicRequestDescriptorPost);
  }
  
  /**
++=======
++>>>>>>> 40114bde9773 (scsi: mpt3sas: Do not use 32-bit atomic request descriptor for Ventura controllers.)
   * _base_display_OEMs_branding - Display branding string
   * @ioc: per adapter object
   *
@@@ -5398,18 -6355,10 +5431,25 @@@ mpt3sas_base_attach(struct MPT3SAS_ADAP
  		break;
  	}
  
++<<<<<<< HEAD
 +	if (ioc->atomic_desc_capable) {
 +		ioc->put_smid_default = &_base_put_smid_default_atomic;
 +		ioc->put_smid_scsi_io = &_base_put_smid_scsi_io_atomic;
 +		ioc->put_smid_fast_path = &_base_put_smid_fast_path_atomic;
 +		ioc->put_smid_hi_priority = &_base_put_smid_hi_priority_atomic;
 +	} else {
 +		ioc->put_smid_default = &_base_put_smid_default;
 +		ioc->put_smid_scsi_io = &_base_put_smid_scsi_io;
 +		ioc->put_smid_fast_path = &_base_put_smid_fast_path;
 +		ioc->put_smid_hi_priority = &_base_put_smid_hi_priority;
 +	}
 +
++=======
+ 	if (ioc->is_mcpu_endpoint)
+ 		ioc->put_smid_scsi_io = &_base_put_smid_mpi_ep_scsi_io;
+ 	else
+ 		ioc->put_smid_scsi_io = &_base_put_smid_scsi_io;
++>>>>>>> 40114bde9773 (scsi: mpt3sas: Do not use 32-bit atomic request descriptor for Ventura controllers.)
  
  	/*
  	 * These function pointers for other requests that don't
diff --cc drivers/scsi/mpt3sas/mpt3sas_base.h
index 6ebe9024685a,68bffaebe900..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_base.h
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.h
@@@ -1217,11 -1354,7 +1217,13 @@@ struct MPT3SAS_ADAPTER 
  	void		*device_remove_in_progress;
  	u16		device_remove_in_progress_sz;
  	u8		is_gen35_ioc;
- 	u8		atomic_desc_capable;
  	PUT_SMID_IO_FP_HIP put_smid_scsi_io;
++<<<<<<< HEAD
 +	PUT_SMID_IO_FP_HIP put_smid_fast_path;
 +	PUT_SMID_IO_FP_HIP put_smid_hi_priority;
 +	PUT_SMID_DEFAULT put_smid_default;
++=======
++>>>>>>> 40114bde9773 (scsi: mpt3sas: Do not use 32-bit atomic request descriptor for Ventura controllers.)
  
  };
  
@@@ -1258,9 -1391,16 +1260,15 @@@ void *mpt3sas_base_get_msg_frame(struc
  void *mpt3sas_base_get_sense_buffer(struct MPT3SAS_ADAPTER *ioc, u16 smid);
  __le32 mpt3sas_base_get_sense_buffer_dma(struct MPT3SAS_ADAPTER *ioc,
  	u16 smid);
 -void *mpt3sas_base_get_pcie_sgl(struct MPT3SAS_ADAPTER *ioc, u16 smid);
 -dma_addr_t mpt3sas_base_get_pcie_sgl_dma(struct MPT3SAS_ADAPTER *ioc, u16 smid);
 +
  void mpt3sas_base_sync_reply_irqs(struct MPT3SAS_ADAPTER *ioc);
  
+ void mpt3sas_base_put_smid_fast_path(struct MPT3SAS_ADAPTER *ioc, u16 smid,
+ 	u16 handle);
+ void mpt3sas_base_put_smid_hi_priority(struct MPT3SAS_ADAPTER *ioc, u16 smid,
+ 	u16 msix_task);
+ void mpt3sas_base_put_smid_nvme_encap(struct MPT3SAS_ADAPTER *ioc, u16 smid);
+ void mpt3sas_base_put_smid_default(struct MPT3SAS_ADAPTER *ioc, u16 smid);
  /* hi-priority queue */
  u16 mpt3sas_base_get_smid_hpr(struct MPT3SAS_ADAPTER *ioc, u8 cb_idx);
  u16 mpt3sas_base_get_smid_scsiio(struct MPT3SAS_ADAPTER *ioc, u8 cb_idx,
diff --cc drivers/scsi/mpt3sas/mpt3sas_ctl.c
index 245be161e5d8,d3cb387ba9f4..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_ctl.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_ctl.c
@@@ -792,6 -791,38 +792,41 @@@ _ctl_do_mpt_command(struct MPT3SAS_ADAP
  
  	init_completion(&ioc->ctl_cmds.done);
  	switch (mpi_request->Function) {
++<<<<<<< HEAD
++=======
+ 	case MPI2_FUNCTION_NVME_ENCAPSULATED:
+ 	{
+ 		nvme_encap_request = (Mpi26NVMeEncapsulatedRequest_t *)request;
+ 		/*
+ 		 * Get the Physical Address of the sense buffer.
+ 		 * Use Error Response buffer address field to hold the sense
+ 		 * buffer address.
+ 		 * Clear the internal sense buffer, which will potentially hold
+ 		 * the Completion Queue Entry on return, or 0 if no Entry.
+ 		 * Build the PRPs and set direction bits.
+ 		 * Send the request.
+ 		 */
+ 		nvme_encap_request->ErrorResponseBaseAddress = ioc->sense_dma &
+ 		    0xFFFFFFFF00000000;
+ 		nvme_encap_request->ErrorResponseBaseAddress |=
+ 		    (U64)mpt3sas_base_get_sense_buffer_dma(ioc, smid);
+ 		nvme_encap_request->ErrorResponseAllocationLength =
+ 						NVME_ERROR_RESPONSE_SIZE;
+ 		memset(ioc->ctl_cmds.sense, 0, NVME_ERROR_RESPONSE_SIZE);
+ 		ioc->build_nvme_prp(ioc, smid, nvme_encap_request,
+ 		    data_out_dma, data_out_sz, data_in_dma, data_in_sz);
+ 		if (test_bit(device_handle, ioc->device_remove_in_progress)) {
+ 			dtmprintk(ioc, pr_info(MPT3SAS_FMT "handle(0x%04x) :"
+ 			    "ioctl failed due to device removal in progress\n",
+ 			    ioc->name, device_handle));
+ 			mpt3sas_base_free_smid(ioc, smid);
+ 			ret = -EINVAL;
+ 			goto out;
+ 		}
+ 		mpt3sas_base_put_smid_nvme_encap(ioc, smid);
+ 		break;
+ 	}
++>>>>>>> 40114bde9773 (scsi: mpt3sas: Do not use 32-bit atomic request descriptor for Ventura controllers.)
  	case MPI2_FUNCTION_SCSI_IO_REQUEST:
  	case MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH:
  	{
diff --cc drivers/scsi/mpt3sas/mpt3sas_scsih.c
index 7078c97a875b,50efccd73cb1..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c
@@@ -2372,12 -2679,7 +2372,16 @@@ mpt3sas_scsih_issue_tm(struct MPT3SAS_A
  	int_to_scsilun(lun, (struct scsi_lun *)mpi_request->LUN);
  	mpt3sas_scsih_set_tm_flag(ioc, handle);
  	init_completion(&ioc->tm_cmds.done);
++<<<<<<< HEAD
 +	if ((type == MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK) &&
 +			(scsi_lookup->msix_io < ioc->reply_queue_count))
 +		msix_task = scsi_lookup->msix_io;
 +	else
 +		msix_task = 0;
 +	ioc->put_smid_hi_priority(ioc, smid, msix_task);
++=======
+ 	mpt3sas_base_put_smid_hi_priority(ioc, smid, msix_task);
++>>>>>>> 40114bde9773 (scsi: mpt3sas: Do not use 32-bit atomic request descriptor for Ventura controllers.)
  	wait_for_completion_timeout(&ioc->tm_cmds.done, timeout*HZ);
  	if (!(ioc->tm_cmds.status & MPT3_CMD_COMPLETE)) {
  		pr_err(MPT3SAS_FMT "%s: timeout\n",
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_base.c
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_base.h
diff --git a/drivers/scsi/mpt3sas/mpt3sas_config.c b/drivers/scsi/mpt3sas/mpt3sas_config.c
index dd6270125614..cebfd734fd76 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_config.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_config.c
@@ -384,7 +384,7 @@ _config_request(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigRequest_t
 	memcpy(config_request, mpi_request, sizeof(Mpi2ConfigRequest_t));
 	_config_display_some_debug(ioc, smid, "config_request", NULL);
 	init_completion(&ioc->config_cmds.done);
-	ioc->put_smid_default(ioc, smid);
+	mpt3sas_base_put_smid_default(ioc, smid);
 	wait_for_completion_timeout(&ioc->config_cmds.done, timeout*HZ);
 	if (!(ioc->config_cmds.status & MPT3_CMD_COMPLETE)) {
 		pr_err(MPT3SAS_FMT "%s: timeout\n",
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_ctl.c
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_scsih.c
diff --git a/drivers/scsi/mpt3sas/mpt3sas_transport.c b/drivers/scsi/mpt3sas/mpt3sas_transport.c
index e2ae0f6e89c1..93c002329d33 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_transport.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_transport.c
@@ -392,7 +392,7 @@ _transport_expander_report_manufacture(struct MPT3SAS_ADAPTER *ioc,
 		"report_manufacture - send to sas_addr(0x%016llx)\n",
 		ioc->name, (unsigned long long)sas_address));
 	init_completion(&ioc->transport_cmds.done);
-	ioc->put_smid_default(ioc, smid);
+	mpt3sas_base_put_smid_default(ioc, smid);
 	wait_for_completion_timeout(&ioc->transport_cmds.done, 10*HZ);
 
 	if (!(ioc->transport_cmds.status & MPT3_CMD_COMPLETE)) {
@@ -1198,7 +1198,7 @@ _transport_get_expander_phy_error_log(struct MPT3SAS_ADAPTER *ioc,
 		ioc->name, (unsigned long long)phy->identify.sas_address,
 		phy->number));
 	init_completion(&ioc->transport_cmds.done);
-	ioc->put_smid_default(ioc, smid);
+	mpt3sas_base_put_smid_default(ioc, smid);
 	wait_for_completion_timeout(&ioc->transport_cmds.done, 10*HZ);
 
 	if (!(ioc->transport_cmds.status & MPT3_CMD_COMPLETE)) {
@@ -1514,7 +1514,7 @@ _transport_expander_phy_control(struct MPT3SAS_ADAPTER *ioc,
 		ioc->name, (unsigned long long)phy->identify.sas_address,
 		phy->number, phy_operation));
 	init_completion(&ioc->transport_cmds.done);
-	ioc->put_smid_default(ioc, smid);
+	mpt3sas_base_put_smid_default(ioc, smid);
 	wait_for_completion_timeout(&ioc->transport_cmds.done, 10*HZ);
 
 	if (!(ioc->transport_cmds.status & MPT3_CMD_COMPLETE)) {
@@ -2031,7 +2031,7 @@ _transport_smp_handler(struct Scsi_Host *shost, struct sas_rphy *rphy,
 		"%s - sending smp request\n", ioc->name, __func__));
 
 	init_completion(&ioc->transport_cmds.done);
-	ioc->put_smid_default(ioc, smid);
+	mpt3sas_base_put_smid_default(ioc, smid);
 	wait_for_completion_timeout(&ioc->transport_cmds.done, 10*HZ);
 
 	if (!(ioc->transport_cmds.status & MPT3_CMD_COMPLETE)) {
