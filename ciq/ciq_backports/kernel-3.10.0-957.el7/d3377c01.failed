mmc: block: Use local variables in mmc_blk_data_prep()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] block: Use local variables in mmc_blk_data_prep() (Gopal Tiwari) [1456570]
Rebuild_FUZZ: 95.15%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit d3377c012f4d7a0a822e289f1effba997da3e295
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d3377c01.failed

Use local variables in mmc_blk_data_prep() in preparation for adding CQE
support which doesn't use the output variables.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit d3377c012f4d7a0a822e289f1effba997da3e295)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/block.c
diff --cc drivers/mmc/core/block.c
index bf17147e2808,bb5f70ec8015..000000000000
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@@ -1462,36 -1574,40 +1462,53 @@@ static enum mmc_blk_status mmc_blk_err_
  	return MMC_BLK_SUCCESS;
  }
  
++<<<<<<< HEAD
 +static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 +			       struct mmc_card *card,
 +			       int disable_multi,
 +			       struct mmc_queue *mq)
++=======
+ static void mmc_blk_data_prep(struct mmc_queue *mq, struct mmc_queue_req *mqrq,
+ 			      int disable_multi, bool *do_rel_wr_p,
+ 			      bool *do_data_tag_p)
++>>>>>>> d3377c012f4d (mmc: block: Use local variables in mmc_blk_data_prep())
  {
 -	struct mmc_blk_data *md = mq->blkdata;
 -	struct mmc_card *card = md->queue.card;
 +	u32 readcmd, writecmd;
  	struct mmc_blk_request *brq = &mqrq->brq;
++<<<<<<< HEAD
 +	struct request *req = mqrq->req;
 +	struct mmc_blk_data *md = mq->blkdata;
 +	bool do_data_tag;
++=======
+ 	struct request *req = mmc_queue_req_to_req(mqrq);
+ 	bool do_rel_wr, do_data_tag;
++>>>>>>> d3377c012f4d (mmc: block: Use local variables in mmc_blk_data_prep())
  
  	/*
  	 * Reliable writes are used to implement Forced Unit Access and
  	 * are supported only on MMCs.
  	 */
++<<<<<<< HEAD
 +	bool do_rel_wr = (req->cmd_flags & REQ_FUA) &&
 +		(rq_data_dir(req) == WRITE) &&
 +		(md->flags & MMC_BLK_REL_WR);
++=======
+ 	do_rel_wr = (req->cmd_flags & REQ_FUA) &&
+ 		    rq_data_dir(req) == WRITE &&
+ 		    (md->flags & MMC_BLK_REL_WR);
++>>>>>>> d3377c012f4d (mmc: block: Use local variables in mmc_blk_data_prep())
  
  	memset(brq, 0, sizeof(struct mmc_blk_request));
 -
 +	brq->mrq.cmd = &brq->cmd;
  	brq->mrq.data = &brq->data;
  
 +	brq->cmd.arg = blk_rq_pos(req);
 +	if (!mmc_card_blockaddr(card))
 +		brq->cmd.arg <<= 9;
 +	brq->cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
 +	brq->data.blksz = 512;
  	brq->stop.opcode = MMC_STOP_TRANSMISSION;
  	brq->stop.arg = 0;
 -
 -	if (rq_data_dir(req) == READ) {
 -		brq->data.flags = MMC_DATA_READ;
 -		brq->stop.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
 -	} else {
 -		brq->data.flags = MMC_DATA_WRITE;
 -		brq->stop.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
 -	}
 -
 -	brq->data.blksz = 512;
  	brq->data.blocks = blk_rq_sectors(req);
  
  	/*
@@@ -1522,6 -1638,72 +1539,75 @@@
  						brq->data.blocks);
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (do_rel_wr)
+ 		mmc_apply_rel_rw(brq, card, req);
+ 
+ 	/*
+ 	 * Data tag is used only during writing meta data to speed
+ 	 * up write and any subsequent read of this meta data
+ 	 */
+ 	do_data_tag = card->ext_csd.data_tag_unit_size &&
+ 		      (req->cmd_flags & REQ_META) &&
+ 		      (rq_data_dir(req) == WRITE) &&
+ 		      ((brq->data.blocks * brq->data.blksz) >=
+ 		       card->ext_csd.data_tag_unit_size);
+ 
+ 	mmc_set_data_timeout(&brq->data, card);
+ 
+ 	brq->data.sg = mqrq->sg;
+ 	brq->data.sg_len = mmc_queue_map_sg(mq, mqrq);
+ 
+ 	/*
+ 	 * Adjust the sg list so it is the same size as the
+ 	 * request.
+ 	 */
+ 	if (brq->data.blocks != blk_rq_sectors(req)) {
+ 		int i, data_size = brq->data.blocks << 9;
+ 		struct scatterlist *sg;
+ 
+ 		for_each_sg(brq->data.sg, sg, brq->data.sg_len, i) {
+ 			data_size -= sg->length;
+ 			if (data_size <= 0) {
+ 				sg->length += data_size;
+ 				i++;
+ 				break;
+ 			}
+ 		}
+ 		brq->data.sg_len = i;
+ 	}
+ 
+ 	mqrq->areq.mrq = &brq->mrq;
+ 
+ 	if (do_rel_wr_p)
+ 		*do_rel_wr_p = do_rel_wr;
+ 
+ 	if (do_data_tag_p)
+ 		*do_data_tag_p = do_data_tag;
+ }
+ 
+ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
+ 			       struct mmc_card *card,
+ 			       int disable_multi,
+ 			       struct mmc_queue *mq)
+ {
+ 	u32 readcmd, writecmd;
+ 	struct mmc_blk_request *brq = &mqrq->brq;
+ 	struct request *req = mmc_queue_req_to_req(mqrq);
+ 	struct mmc_blk_data *md = mq->blkdata;
+ 	bool do_rel_wr, do_data_tag;
+ 
+ 	mmc_blk_data_prep(mq, mqrq, disable_multi, &do_rel_wr, &do_data_tag);
+ 
+ 	brq->mrq.cmd = &brq->cmd;
+ 
+ 	brq->cmd.arg = blk_rq_pos(req);
+ 	if (!mmc_card_blockaddr(card))
+ 		brq->cmd.arg <<= 9;
+ 	brq->cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
+ 
++>>>>>>> d3377c012f4d (mmc: block: Use local variables in mmc_blk_data_prep())
  	if (brq->data.blocks > 1 || do_rel_wr) {
  		/* SPI multiblock writes terminate using a special
  		 * token, not a STOP_TRANSMISSION request.
* Unmerged path drivers/mmc/core/block.c
