dax: Simplify arguments of dax_insert_mapping()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jan Kara <jack@suse.cz>
commit 31a6f1a6e5a4a26040b67d8fa4256539b36f5893
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/31a6f1a6.failed

dax_insert_mapping() has lots of arguments and a lot of them is actuall
duplicated by passing vm_fault structure as well. Change the function to
take the same arguments as dax_pmd_insert_mapping().

	Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 31a6f1a6e5a4a26040b67d8fa4256539b36f5893)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
diff --cc fs/dax.c
index 679214f8898b,0bc42ac294ca..000000000000
--- a/fs/dax.c
+++ b/fs/dax.c
@@@ -896,13 -820,18 +896,28 @@@ out
  }
  EXPORT_SYMBOL_GPL(dax_writeback_mapping_range);
  
++<<<<<<< HEAD
 +static int dax_insert_mapping(struct address_space *mapping,
 +		struct block_device *bdev, struct dax_device *dax_dev,
 +		sector_t sector, size_t size, void **entryp,
 +		struct vm_area_struct *vma, struct vm_fault *vmf)
 +{
 +	unsigned long vaddr = (unsigned long)vmf->virtual_address;
 +	void *entry = *entryp;
++=======
+ static sector_t dax_iomap_sector(struct iomap *iomap, loff_t pos)
+ {
+ 	return iomap->blkno + (((pos & PAGE_MASK) - iomap->offset) >> 9);
+ }
+ 
+ static int dax_insert_mapping(struct vm_fault *vmf, struct iomap *iomap,
+ 			      loff_t pos, void *entry)
+ {
+ 	const sector_t sector = dax_iomap_sector(iomap, pos);
+ 	struct vm_area_struct *vma = vmf->vma;
+ 	struct address_space *mapping = vma->vm_file->f_mapping;
+ 	unsigned long vaddr = vmf->address;
++>>>>>>> 31a6f1a6e5a4 (dax: Simplify arguments of dax_insert_mapping())
  	void *ret, *kaddr;
  	pgoff_t pgoff;
  	int id, rc;
@@@ -1013,13 -943,8 +1029,16 @@@ int __dax_zero_page_range(struct block_
  }
  EXPORT_SYMBOL_GPL(__dax_zero_page_range);
  
++<<<<<<< HEAD
 +static sector_t dax_iomap_sector(struct iomap *iomap, loff_t pos)
 +{
 +	return (iomap->addr + (pos & PAGE_MASK) - iomap->offset) >> 9;
 +}
 +
++=======
++>>>>>>> 31a6f1a6e5a4 (dax: Simplify arguments of dax_insert_mapping())
  static loff_t
 -dax_iomap_actor(struct inode *inode, loff_t pos, loff_t length, void *data,
 +dax_iomap_actor(int rw, struct inode *inode, loff_t pos, loff_t length, void *data,
  		struct iomap *iomap)
  {
  	struct block_device *bdev = iomap->bdev;
@@@ -1183,9 -1087,8 +1202,8 @@@ static int dax_iomap_pte_fault(struct v
  {
  	struct address_space *mapping = vmf->vma->vm_file->f_mapping;
  	struct inode *inode = mapping->host;
 -	unsigned long vaddr = vmf->address;
 +	unsigned long vaddr = (unsigned long)vmf->virtual_address;
  	loff_t pos = (loff_t)vmf->pgoff << PAGE_SHIFT;
- 	sector_t sector;
  	struct iomap iomap = { 0 };
  	unsigned flags = IOMAP_FAULT;
  	int error, major = 0;
@@@ -1270,12 -1173,10 +1288,16 @@@
  	case IOMAP_MAPPED:
  		if (iomap.flags & IOMAP_F_NEW) {
  			count_vm_event(PGMAJFAULT);
 -			count_memcg_event_mm(vmf->vma->vm_mm, PGMAJFAULT);
 +			mem_cgroup_count_vm_event(vmf->vma->vm_mm,
 +					PGMAJFAULT);
  			major = VM_FAULT_MAJOR;
  		}
++<<<<<<< HEAD
 +		error = dax_insert_mapping(mapping, iomap.bdev, iomap.dax_dev,
 +				sector, PAGE_SIZE, &entry, vmf->vma, vmf);
++=======
+ 		error = dax_insert_mapping(vmf, &iomap, pos, entry);
++>>>>>>> 31a6f1a6e5a4 (dax: Simplify arguments of dax_insert_mapping())
  		/* -EBUSY is fine, somebody else faulted on the same PTE */
  		if (error == -EBUSY)
  			error = 0;
* Unmerged path fs/dax.c
