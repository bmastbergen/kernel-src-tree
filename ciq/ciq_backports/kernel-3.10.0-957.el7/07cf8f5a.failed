netfilter: ipset: add forceadd kernel support for hash set types

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Josh Hunt <johunt@akamai.com>
commit 07cf8f5ae2657ac495b906c68ff3441ff8ba80ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/07cf8f5a.failed

Adds a new property for hash set types, where if a set is created
with the 'forceadd' option and the set becomes full the next addition
to the set may succeed and evict a random entry from the set.

To keep overhead low eviction is done very simply. It checks to see
which bucket the new entry would be added. If the bucket's pos value
is non-zero (meaning there's at least one entry in the bucket) it
replaces the first entry in the bucket. If pos is zero, then it continues
down the normal add process.

This property is useful if you have a set for 'ban' lists where it may
not matter if you release some entries from the set early.

	Signed-off-by: Josh Hunt <johunt@akamai.com>
	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 07cf8f5ae2657ac495b906c68ff3441ff8ba80ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/ipset/ip_set.h
#	include/uapi/linux/netfilter/ipset/ip_set.h
#	net/netfilter/ipset/ip_set_core.c
#	net/netfilter/ipset/ip_set_hash_ip.c
#	net/netfilter/ipset/ip_set_hash_ipport.c
#	net/netfilter/ipset/ip_set_hash_ipportip.c
#	net/netfilter/ipset/ip_set_hash_ipportnet.c
#	net/netfilter/ipset/ip_set_hash_net.c
#	net/netfilter/ipset/ip_set_hash_netiface.c
#	net/netfilter/ipset/ip_set_hash_netnet.c
#	net/netfilter/ipset/ip_set_hash_netport.c
#	net/netfilter/ipset/ip_set_hash_netportnet.c
diff --cc include/linux/netfilter/ipset/ip_set.h
index 3e9c90cf5227,96afc29184be..000000000000
--- a/include/linux/netfilter/ipset/ip_set.h
+++ b/include/linux/netfilter/ipset/ip_set.h
@@@ -60,6 -64,8 +60,11 @@@ enum ip_set_extension 
  
  #define SET_WITH_TIMEOUT(s)	((s)->extensions & IPSET_EXT_TIMEOUT)
  #define SET_WITH_COUNTER(s)	((s)->extensions & IPSET_EXT_COUNTER)
++<<<<<<< HEAD
++=======
+ #define SET_WITH_COMMENT(s)	((s)->extensions & IPSET_EXT_COMMENT)
+ #define SET_WITH_FORCEADD(s)	((s)->flags & IPSET_CREATE_FLAG_FORCEADD)
++>>>>>>> 07cf8f5ae265 (netfilter: ipset: add forceadd kernel support for hash set types)
  
  /* Extension id, in size order */
  enum ip_set_ext_id {
@@@ -190,10 -232,37 +195,44 @@@ struct ip_set 
  	void *data;
  };
  
++<<<<<<< HEAD
 +struct ip_set_counter {
 +	atomic64_t bytes;
 +	atomic64_t packets;
 +};
++=======
+ static inline void
+ ip_set_ext_destroy(struct ip_set *set, void *data)
+ {
+ 	/* Check that the extension is enabled for the set and
+ 	 * call it's destroy function for its extension part in data.
+ 	 */
+ 	if (SET_WITH_COMMENT(set))
+ 		ip_set_extensions[IPSET_EXT_ID_COMMENT].destroy(
+ 			ext_comment(data, set));
+ }
+ 
+ static inline int
+ ip_set_put_flags(struct sk_buff *skb, struct ip_set *set)
+ {
+ 	u32 cadt_flags = 0;
+ 
+ 	if (SET_WITH_TIMEOUT(set))
+ 		if (unlikely(nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
+ 					   htonl(set->timeout))))
+ 			return -EMSGSIZE;
+ 	if (SET_WITH_COUNTER(set))
+ 		cadt_flags |= IPSET_FLAG_WITH_COUNTERS;
+ 	if (SET_WITH_COMMENT(set))
+ 		cadt_flags |= IPSET_FLAG_WITH_COMMENT;
+ 	if (SET_WITH_FORCEADD(set))
+ 		cadt_flags |= IPSET_FLAG_WITH_FORCEADD;
+ 
+ 	if (!cadt_flags)
+ 		return 0;
+ 	return nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(cadt_flags));
+ }
++>>>>>>> 07cf8f5ae265 (netfilter: ipset: add forceadd kernel support for hash set types)
  
  static inline void
  ip_set_add_bytes(u64 bytes, struct ip_set_counter *counter)
diff --cc include/uapi/linux/netfilter/ipset/ip_set.h
index 7f7d72410118,78c2f2e79920..000000000000
--- a/include/uapi/linux/netfilter/ipset/ip_set.h
+++ b/include/uapi/linux/netfilter/ipset/ip_set.h
@@@ -182,9 -183,20 +182,26 @@@ enum ipset_cadt_flags 
  	IPSET_FLAG_NOMATCH	= (1 << IPSET_FLAG_BIT_NOMATCH),
  	IPSET_FLAG_BIT_WITH_COUNTERS = 3,
  	IPSET_FLAG_WITH_COUNTERS = (1 << IPSET_FLAG_BIT_WITH_COUNTERS),
++<<<<<<< HEAD
 +	IPSET_FLAG_CADT_MAX	= 15,
 +};
 +
++=======
+ 	IPSET_FLAG_BIT_WITH_COMMENT = 4,
+ 	IPSET_FLAG_WITH_COMMENT = (1 << IPSET_FLAG_BIT_WITH_COMMENT),
+ 	IPSET_FLAG_BIT_WITH_FORCEADD = 5,
+ 	IPSET_FLAG_WITH_FORCEADD = (1 << IPSET_FLAG_BIT_WITH_FORCEADD),
+ 	IPSET_FLAG_CADT_MAX	= 15,
+ };
+ 
+ /* The flag bits which correspond to the non-extension create flags */
+ enum ipset_create_flags {
+ 	IPSET_CREATE_FLAG_BIT_FORCEADD = 0,
+ 	IPSET_CREATE_FLAG_FORCEADD = (1 << IPSET_CREATE_FLAG_BIT_FORCEADD),
+ 	IPSET_CREATE_FLAG_BIT_MAX = 7,
+ };
+ 
++>>>>>>> 07cf8f5ae265 (netfilter: ipset: add forceadd kernel support for hash set types)
  /* Commands with settype-specific attributes */
  enum ipset_adt {
  	IPSET_ADD,
diff --cc net/netfilter/ipset/ip_set_core.c
index d17e4090573d,117208321f16..000000000000
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@@ -324,6 -326,62 +324,65 @@@ ip_set_get_ipaddr6(struct nlattr *nla, 
  }
  EXPORT_SYMBOL_GPL(ip_set_get_ipaddr6);
  
++<<<<<<< HEAD
++=======
+ typedef void (*destroyer)(void *);
+ /* ipset data extension types, in size order */
+ 
+ const struct ip_set_ext_type ip_set_extensions[] = {
+ 	[IPSET_EXT_ID_COUNTER] = {
+ 		.type	= IPSET_EXT_COUNTER,
+ 		.flag	= IPSET_FLAG_WITH_COUNTERS,
+ 		.len	= sizeof(struct ip_set_counter),
+ 		.align	= __alignof__(struct ip_set_counter),
+ 	},
+ 	[IPSET_EXT_ID_TIMEOUT] = {
+ 		.type	= IPSET_EXT_TIMEOUT,
+ 		.len	= sizeof(unsigned long),
+ 		.align	= __alignof__(unsigned long),
+ 	},
+ 	[IPSET_EXT_ID_COMMENT] = {
+ 		.type	 = IPSET_EXT_COMMENT | IPSET_EXT_DESTROY,
+ 		.flag	 = IPSET_FLAG_WITH_COMMENT,
+ 		.len	 = sizeof(struct ip_set_comment),
+ 		.align	 = __alignof__(struct ip_set_comment),
+ 		.destroy = (destroyer) ip_set_comment_free,
+ 	},
+ };
+ EXPORT_SYMBOL_GPL(ip_set_extensions);
+ 
+ static inline bool
+ add_extension(enum ip_set_ext_id id, u32 flags, struct nlattr *tb[])
+ {
+ 	return ip_set_extensions[id].flag ?
+ 		(flags & ip_set_extensions[id].flag) :
+ 		!!tb[IPSET_ATTR_TIMEOUT];
+ }
+ 
+ size_t
+ ip_set_elem_len(struct ip_set *set, struct nlattr *tb[], size_t len)
+ {
+ 	enum ip_set_ext_id id;
+ 	size_t offset = 0;
+ 	u32 cadt_flags = 0;
+ 
+ 	if (tb[IPSET_ATTR_CADT_FLAGS])
+ 		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
+ 	if (cadt_flags & IPSET_FLAG_WITH_FORCEADD)
+ 		set->flags |= IPSET_CREATE_FLAG_FORCEADD;
+ 	for (id = 0; id < IPSET_EXT_ID_MAX; id++) {
+ 		if (!add_extension(id, cadt_flags, tb))
+ 			continue;
+ 		offset += ALIGN(len + offset, ip_set_extensions[id].align);
+ 		set->offset[id] = offset;
+ 		set->extensions |= ip_set_extensions[id].type;
+ 		offset += ip_set_extensions[id].len;
+ 	}
+ 	return len + offset;
+ }
+ EXPORT_SYMBOL_GPL(ip_set_elem_len);
+ 
++>>>>>>> 07cf8f5ae265 (netfilter: ipset: add forceadd kernel support for hash set types)
  int
  ip_set_get_extensions(struct ip_set *set, struct nlattr *tb[],
  		      struct ip_set_ext *ext)
diff --cc net/netfilter/ipset/ip_set_hash_ip.c
index 260c9a80d8a5,dd40607f878e..000000000000
--- a/net/netfilter/ipset/ip_set_hash_ip.c
+++ b/net/netfilter/ipset/ip_set_hash_ip.c
@@@ -24,7 -24,9 +24,13 @@@
  #include <linux/netfilter/ipset/ip_set_hash.h>
  
  #define IPSET_TYPE_REV_MIN	0
++<<<<<<< HEAD
 +#define IPSET_TYPE_REV_MAX	1	/* Counters support */
++=======
+ /*				1	   Counters support */
+ /*				2	   Comments support */
+ #define IPSET_TYPE_REV_MAX	3	/* Forceadd support */
++>>>>>>> 07cf8f5ae265 (netfilter: ipset: add forceadd kernel support for hash set types)
  
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
diff --cc net/netfilter/ipset/ip_set_hash_ipport.c
index 64caad35a391,7597b82a8b03..000000000000
--- a/net/netfilter/ipset/ip_set_hash_ipport.c
+++ b/net/netfilter/ipset/ip_set_hash_ipport.c
@@@ -26,7 -26,9 +26,13 @@@
  
  #define IPSET_TYPE_REV_MIN	0
  /*				1    SCTP and UDPLITE support added */
++<<<<<<< HEAD
 +#define IPSET_TYPE_REV_MAX	2 /* Counters support added */
++=======
+ /*				2    Counters support added */
+ /*				3    Comments support added */
+ #define IPSET_TYPE_REV_MAX	4 /* Forceadd support added */
++>>>>>>> 07cf8f5ae265 (netfilter: ipset: add forceadd kernel support for hash set types)
  
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
diff --cc net/netfilter/ipset/ip_set_hash_ipportip.c
index 2873bbc20d7a,672655ffd573..000000000000
--- a/net/netfilter/ipset/ip_set_hash_ipportip.c
+++ b/net/netfilter/ipset/ip_set_hash_ipportip.c
@@@ -26,7 -26,9 +26,13 @@@
  
  #define IPSET_TYPE_REV_MIN	0
  /*				1    SCTP and UDPLITE support added */
++<<<<<<< HEAD
 +#define IPSET_TYPE_REV_MAX	2 /* Counters support added */
++=======
+ /*				2    Counters support added */
+ /*				3    Comments support added */
+ #define IPSET_TYPE_REV_MAX	4 /* Forceadd support added */
++>>>>>>> 07cf8f5ae265 (netfilter: ipset: add forceadd kernel support for hash set types)
  
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
diff --cc net/netfilter/ipset/ip_set_hash_ipportnet.c
index f111558c4597,7308d84f9277..000000000000
--- a/net/netfilter/ipset/ip_set_hash_ipportnet.c
+++ b/net/netfilter/ipset/ip_set_hash_ipportnet.c
@@@ -28,7 -28,9 +28,13 @@@
  /*				1    SCTP and UDPLITE support added */
  /*				2    Range as input support for IPv4 added */
  /*				3    nomatch flag support added */
++<<<<<<< HEAD
 +#define IPSET_TYPE_REV_MAX	4 /* Counters support added */
++=======
+ /*				4    Counters support added */
+ /*				5    Comments support added */
+ #define IPSET_TYPE_REV_MAX	6 /* Forceadd support added */
++>>>>>>> 07cf8f5ae265 (netfilter: ipset: add forceadd kernel support for hash set types)
  
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
diff --cc net/netfilter/ipset/ip_set_hash_net.c
index 0a64dad156d9,4c7d495783a3..000000000000
--- a/net/netfilter/ipset/ip_set_hash_net.c
+++ b/net/netfilter/ipset/ip_set_hash_net.c
@@@ -25,7 -25,9 +25,13 @@@
  #define IPSET_TYPE_REV_MIN	0
  /*				1    Range as input support for IPv4 added */
  /*				2    nomatch flag support added */
++<<<<<<< HEAD
 +#define IPSET_TYPE_REV_MAX	3 /* Counters support added */
++=======
+ /*				3    Counters support added */
+ /*				4    Comments support added */
+ #define IPSET_TYPE_REV_MAX	5 /* Forceadd support added */
++>>>>>>> 07cf8f5ae265 (netfilter: ipset: add forceadd kernel support for hash set types)
  
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
diff --cc net/netfilter/ipset/ip_set_hash_netiface.c
index 8bdeb0791689,db2606805b35..000000000000
--- a/net/netfilter/ipset/ip_set_hash_netiface.c
+++ b/net/netfilter/ipset/ip_set_hash_netiface.c
@@@ -27,7 -26,9 +27,13 @@@
  #define IPSET_TYPE_REV_MIN	0
  /*				1    nomatch flag support added */
  /*				2    /0 support added */
++<<<<<<< HEAD
 +#define IPSET_TYPE_REV_MAX	3 /* Counters support added */
++=======
+ /*				3    Counters support added */
+ /*				4    Comments support added */
+ #define IPSET_TYPE_REV_MAX	5 /* Forceadd support added */
++>>>>>>> 07cf8f5ae265 (netfilter: ipset: add forceadd kernel support for hash set types)
  
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
diff --cc net/netfilter/ipset/ip_set_hash_netport.c
index d98a685cd916,1c645fbd09c7..000000000000
--- a/net/netfilter/ipset/ip_set_hash_netport.c
+++ b/net/netfilter/ipset/ip_set_hash_netport.c
@@@ -27,7 -27,9 +27,13 @@@
  /*				1    SCTP and UDPLITE support added */
  /*				2    Range as input support for IPv4 added */
  /*				3    nomatch flag support added */
++<<<<<<< HEAD
 +#define IPSET_TYPE_REV_MAX	4 /* Counters support added */
++=======
+ /*				4    Counters support added */
+ /*				5    Comments support added */
+ #define IPSET_TYPE_REV_MAX	6 /* Forceadd support added */
++>>>>>>> 07cf8f5ae265 (netfilter: ipset: add forceadd kernel support for hash set types)
  
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR("Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>");
* Unmerged path net/netfilter/ipset/ip_set_hash_netnet.c
* Unmerged path net/netfilter/ipset/ip_set_hash_netportnet.c
* Unmerged path include/linux/netfilter/ipset/ip_set.h
* Unmerged path include/uapi/linux/netfilter/ipset/ip_set.h
* Unmerged path net/netfilter/ipset/ip_set_core.c
diff --git a/net/netfilter/ipset/ip_set_hash_gen.h b/net/netfilter/ipset/ip_set_hash_gen.h
index 72686abe715e..253e7498d937 100644
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@ -600,6 +600,18 @@ mtype_add(struct ip_set *set, void *value, const struct ip_set_ext *ext,
 	bool flag_exist = flags & IPSET_FLAG_EXIST;
 	u32 key, multi = 0;
 
+	if (h->elements >= h->maxelem && SET_WITH_FORCEADD(set)) {
+		rcu_read_lock_bh();
+		t = rcu_dereference_bh(h->table);
+		key = HKEY(value, h->initval, t->htable_bits);
+		n = hbucket(t,key);
+		if (n->pos) {
+			/* Choosing the first entry in the array to replace */
+			j = 0;
+			goto reuse_slot;
+		}
+		rcu_read_unlock_bh();
+	}
 	if (SET_WITH_TIMEOUT(set) && h->elements >= h->maxelem)
 		/* FIXME: when set is full, we slow down here */
 		mtype_expire(h, NETS_LENGTH(set->family), h->dsize);
* Unmerged path net/netfilter/ipset/ip_set_hash_ip.c
diff --git a/net/netfilter/ipset/ip_set_hash_ipmark.c b/net/netfilter/ipset/ip_set_hash_ipmark.c
index e56c0d916fac..c3dc6c5cb5b7 100644
--- a/net/netfilter/ipset/ip_set_hash_ipmark.c
+++ b/net/netfilter/ipset/ip_set_hash_ipmark.c
@@ -25,7 +25,7 @@
 #include <linux/netfilter/ipset/ip_set_hash.h>
 
 #define IPSET_TYPE_REV_MIN	0
-#define IPSET_TYPE_REV_MAX	0
+#define IPSET_TYPE_REV_MAX	1	/* Forceadd support */
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Vytas Dauksa <vytas.dauksa@smoothwall.net>");
* Unmerged path net/netfilter/ipset/ip_set_hash_ipport.c
* Unmerged path net/netfilter/ipset/ip_set_hash_ipportip.c
* Unmerged path net/netfilter/ipset/ip_set_hash_ipportnet.c
* Unmerged path net/netfilter/ipset/ip_set_hash_net.c
* Unmerged path net/netfilter/ipset/ip_set_hash_netiface.c
* Unmerged path net/netfilter/ipset/ip_set_hash_netnet.c
* Unmerged path net/netfilter/ipset/ip_set_hash_netport.c
* Unmerged path net/netfilter/ipset/ip_set_hash_netportnet.c
