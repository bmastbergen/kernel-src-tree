net: aquantia: Fix error return code in aq_pci_probe()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] aquantia: Fix error return code in aq_pci_probe() (David Arcari) [1546765]
Rebuild_FUZZ: 95.15%
commit-author Wei Yongjun <weiyongjun1@huawei.com>
commit f03e4f8aadc84deb8f3dddcbf0032bac75051e7a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f03e4f8a.failed

Fix to return error code -ENOMEM from the aq_ndev_alloc() error
handling case instead of 0, as done elsewhere in this function.

Fixes: 23ee07ad3c2f ("net: aquantia: Cleanup pci functions module")
	Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
	Acked-by: Igor Russkikh <igor.russkikh@aquantia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f03e4f8aadc84deb8f3dddcbf0032bac75051e7a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
index 667e08a571a5,5cf3542a7e86..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
@@@ -261,87 -177,168 +261,136 @@@ void aq_pci_func_free_irqs(struct aq_pc
  	}
  }
  
 -unsigned int aq_pci_func_get_irq_type(struct aq_nic_s *self)
 +void __iomem *aq_pci_func_get_mmio(struct aq_pci_func_s *self)
  {
 -	if (self->pdev->msix_enabled)
 -		return AQ_HW_IRQ_MSIX;
 -	if (self->pdev->msi_enabled)
 -		return AQ_HW_IRQ_MSIX;
 -	return AQ_HW_IRQ_LEGACY;
 +	return self->mmio;
 +}
 +
 +unsigned int aq_pci_func_get_irq_type(struct aq_pci_func_s *self)
 +{
 +	return self->irq_type;
 +}
 +
 +void aq_pci_func_deinit(struct aq_pci_func_s *self)
 +{
 +	if (!self)
 +		goto err_exit;
 +
 +	aq_pci_func_free_irqs(self);
 +
 +	switch (self->irq_type) {
 +	case AQ_HW_IRQ_MSI:
 +		pci_disable_msi(self->pdev);
 +		break;
 +
 +	case AQ_HW_IRQ_MSIX:
 +		pci_disable_msix(self->pdev);
 +		break;
 +
 +	case AQ_HW_IRQ_LEGACY:
 +		break;
 +
 +	default:
 +		break;
 +	}
 +
 +	if (self->is_regions)
 +		pci_release_regions(self->pdev);
 +
 +	if (self->is_pci_enabled)
 +		pci_disable_device(self->pdev);
 +
 +err_exit:;
  }
  
 -static void aq_pci_free_irq_vectors(struct aq_nic_s *self)
 +void aq_pci_func_free(struct aq_pci_func_s *self)
  {
 -	pci_free_irq_vectors(self->pdev);
 +	unsigned int port = 0U;
 +
 +	if (!self)
 +		goto err_exit;
 +
 +	for (port = 0; port < self->ports; ++port) {
 +		if (!self->port[port])
 +			continue;
 +
 +		aq_nic_ndev_free(self->port[port]);
 +	}
 +
 +	if (self->mmio)
 +		iounmap(self->mmio);
 +
 +	kfree(self);
 +
 +err_exit:;
  }
  
 -static int aq_pci_probe(struct pci_dev *pdev,
 -			const struct pci_device_id *pci_id)
 +int aq_pci_func_change_pm_state(struct aq_pci_func_s *self,
 +				pm_message_t *pm_msg)
  {
 -	struct aq_nic_s *self = NULL;
  	int err = 0;
 -	struct net_device *ndev;
 -	resource_size_t mmio_pa;
 -	u32 bar;
 -	u32 numvecs;
 +	unsigned int port = 0U;
  
 -	err = pci_enable_device(pdev);
 -	if (err)
 -		return err;
 +	if (!self) {
 +		err = -EFAULT;
 +		goto err_exit;
 +	}
 +	for (port = 0; port < self->ports; ++port) {
 +		if (!self->port[port])
 +			continue;
  
++<<<<<<< HEAD
 +		(void)aq_nic_change_pm_state(self->port[port], pm_msg);
++=======
+ 	err = aq_pci_func_init(pdev);
+ 	if (err)
+ 		goto err_pci_func;
+ 
+ 	ndev = aq_ndev_alloc();
+ 	if (!ndev) {
+ 		err = -ENOMEM;
+ 		goto err_ndev;
+ 	}
+ 
+ 	self = netdev_priv(ndev);
+ 	self->pdev = pdev;
+ 	SET_NETDEV_DEV(ndev, &pdev->dev);
+ 	pci_set_drvdata(pdev, self);
+ 
+ 	err = aq_pci_probe_get_hw_by_id(pdev, &self->aq_hw_ops,
+ 					&aq_nic_get_cfg(self)->aq_hw_caps);
+ 	if (err)
+ 		goto err_ioremap;
+ 
+ 	self->aq_hw = kzalloc(sizeof(*self->aq_hw), GFP_KERNEL);
+ 	self->aq_hw->aq_nic_cfg = aq_nic_get_cfg(self);
+ 
+ 	for (bar = 0; bar < 4; ++bar) {
+ 		if (IORESOURCE_MEM & pci_resource_flags(pdev, bar)) {
+ 			resource_size_t reg_sz;
+ 
+ 			mmio_pa = pci_resource_start(pdev, bar);
+ 			if (mmio_pa == 0U) {
+ 				err = -EIO;
+ 				goto err_ioremap;
+ 			}
+ 
+ 			reg_sz = pci_resource_len(pdev, bar);
+ 			if ((reg_sz <= 24 /*ATL_REGS_SIZE*/)) {
+ 				err = -EIO;
+ 				goto err_ioremap;
+ 			}
+ 
+ 			self->aq_hw->mmio = ioremap_nocache(mmio_pa, reg_sz);
+ 			if (!self->aq_hw->mmio) {
+ 				err = -EIO;
+ 				goto err_ioremap;
+ 			}
+ 			break;
+ 		}
++>>>>>>> f03e4f8aadc8 (net: aquantia: Fix error return code in aq_pci_probe())
  	}
  
 -	if (bar == 4) {
 -		err = -EIO;
 -		goto err_ioremap;
 -	}
 -
 -	numvecs = min((u8)AQ_CFG_VECS_DEF,
 -		      aq_nic_get_cfg(self)->aq_hw_caps->msix_irqs);
 -	numvecs = min(numvecs, num_online_cpus());
 -	/*enable interrupts */
 -#if !AQ_CFG_FORCE_LEGACY_INT
 -	err = pci_alloc_irq_vectors(self->pdev, numvecs, numvecs,
 -				    PCI_IRQ_MSIX);
 -
 -	if (err < 0) {
 -		err = pci_alloc_irq_vectors(self->pdev, 1, 1,
 -					    PCI_IRQ_MSI | PCI_IRQ_LEGACY);
 -		if (err < 0)
 -			goto err_hwinit;
 -	}
 -#endif
 -
 -	/* net device init */
 -	aq_nic_cfg_start(self);
 -
 -	aq_nic_ndev_init(self);
 -
 -	err = aq_nic_ndev_register(self);
 -	if (err < 0)
 -		goto err_register;
 -
 -	return 0;
 -
 -err_register:
 -	aq_nic_free_vectors(self);
 -	aq_pci_free_irq_vectors(self);
 -err_hwinit:
 -	iounmap(self->aq_hw->mmio);
 -err_ioremap:
 -	free_netdev(ndev);
 -err_pci_func:
 -	pci_release_regions(pdev);
 -err_ndev:
 -	pci_disable_device(pdev);
 +err_exit:
  	return err;
  }
 -
 -static void aq_pci_remove(struct pci_dev *pdev)
 -{
 -	struct aq_nic_s *self = pci_get_drvdata(pdev);
 -
 -	if (self->ndev) {
 -		if (self->ndev->reg_state == NETREG_REGISTERED)
 -			unregister_netdev(self->ndev);
 -		aq_nic_free_vectors(self);
 -		aq_pci_free_irq_vectors(self);
 -		iounmap(self->aq_hw->mmio);
 -		kfree(self->aq_hw);
 -		pci_release_regions(pdev);
 -		free_netdev(self->ndev);
 -	}
 -
 -	pci_disable_device(pdev);
 -}
 -
 -static int aq_pci_suspend(struct pci_dev *pdev, pm_message_t pm_msg)
 -{
 -	struct aq_nic_s *self = pci_get_drvdata(pdev);
 -
 -	return aq_nic_change_pm_state(self, &pm_msg);
 -}
 -
 -static int aq_pci_resume(struct pci_dev *pdev)
 -{
 -	struct aq_nic_s *self = pci_get_drvdata(pdev);
 -	pm_message_t pm_msg = PMSG_RESTORE;
 -
 -	return aq_nic_change_pm_state(self, &pm_msg);
 -}
 -
 -static struct pci_driver aq_pci_ops = {
 -	.name = AQ_CFG_DRV_NAME,
 -	.id_table = aq_pci_tbl,
 -	.probe = aq_pci_probe,
 -	.remove = aq_pci_remove,
 -	.suspend = aq_pci_suspend,
 -	.resume = aq_pci_resume,
 -};
 -
 -module_pci_driver(aq_pci_ops);
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
