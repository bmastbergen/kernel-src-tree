ACPI / LPIT: Add Low Power Idle Table (LPIT) support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [acpi] lpit: Add Low Power Idle Table (LPIT) support (Scott Wood) [1445478]
Rebuild_FUZZ: 92.78%
commit-author Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
commit eeb2d80d502af28e5660ff4bbe00f90ceb82c2db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/eeb2d80d.failed

Add functionality to read LPIT table, which provides:

 - Sysfs interface to read residency counters via
   /sys/devices/system/cpu/cpuidle/low_power_idle_cpu_residency_us
   /sys/devices/system/cpu/cpuidle/low_power_idle_system_residency_us

Here the count "low_power_idle_cpu_residency_us" shows the time spent
by CPU package in low power state.  This is read via MSR interface,
which points to MSR for PKG C10.

Here the count "low_power_idle_system_residency_us" show the count the
system was in low power state. This is read via MMIO interface. This
is mapped to SLP_S0 residency on modern Intel systems. This residency
is achieved only when CPU is in PKG C10 and all functional blocks are
in low power state.

It is possible that none of the above counters present or anyone of the
counter present or all counters present.

For example: On my Kabylake system both of the above counters present.
After suspend to idle these counts updated and prints:

 6916179
 6998564

This counter can be read by tools like turbostat to display. Or it can
be used to debug, if modern systems are reaching desired low power state.

 - Provides an interface to read residency counter memory address

   This address can be used to get the base address of PMC memory
   mapped IO.  This is utilized by intel_pmc_core driver to print
   more debug information.

In addition, to avoid code duplication to read iomem, removed the read of
iomem from acpi_os_read_memory() in osl.c and made a common function
acpi_os_read_iomem(). This new function is used for reading iomem in
in both osl.c and acpi_lpit.c.

Link: http://www.uefi.org/sites/default/files/resources/Intel_ACPI_Low_Power_S0_Idle.pdf
	Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit eeb2d80d502af28e5660ff4bbe00f90ceb82c2db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/Kconfig
#	drivers/acpi/Makefile
#	drivers/acpi/internal.h
#	drivers/acpi/osl.c
#	drivers/acpi/scan.c
diff --cc drivers/acpi/Kconfig
index 613e9261e789,4bfef0f78cde..000000000000
--- a/drivers/acpi/Kconfig
+++ b/drivers/acpi/Kconfig
@@@ -38,6 -41,50 +38,52 @@@ menuconfig ACP
  
  if ACPI
  
++<<<<<<< HEAD
++=======
+ config ACPI_LEGACY_TABLES_LOOKUP
+ 	bool
+ 
+ config ARCH_MIGHT_HAVE_ACPI_PDC
+ 	bool
+ 
+ config ACPI_GENERIC_GSI
+ 	bool
+ 
+ config ACPI_SYSTEM_POWER_STATES_SUPPORT
+ 	bool
+ 
+ config ACPI_CCA_REQUIRED
+ 	bool
+ 
+ config ACPI_DEBUGGER
+ 	bool "AML debugger interface"
+ 	select ACPI_DEBUG
+ 	help
+ 	  Enable in-kernel debugging of AML facilities: statistics,
+ 	  internal object dump, single step control method execution.
+ 	  This is still under development, currently enabling this only
+ 	  results in the compilation of the ACPICA debugger files.
+ 
+ if ACPI_DEBUGGER
+ 
+ config ACPI_DEBUGGER_USER
+ 	tristate "Userspace debugger accessiblity"
+ 	depends on DEBUG_FS
+ 	help
+ 	  Export /sys/kernel/debug/acpi/acpidbg for userspace utilities
+ 	  to access the debugger functionalities.
+ 
+ endif
+ 
+ config ACPI_SPCR_TABLE
+ 	bool
+ 
+ config ACPI_LPIT
+ 	bool
+ 	depends on X86_64
+ 	default y
+ 
++>>>>>>> eeb2d80d502a (ACPI / LPIT: Add Low Power Idle Table (LPIT) support)
  config ACPI_SLEEP
  	bool
  	depends on SUSPEND || HIBERNATION
diff --cc drivers/acpi/Makefile
index 00fc20e602b6,6a19bd7aba21..000000000000
--- a/drivers/acpi/Makefile
+++ b/drivers/acpi/Makefile
@@@ -50,10 -53,12 +50,17 @@@ acpi-$(CONFIG_X86)		+= acpi_cmos_rtc.
  acpi-$(CONFIG_DEBUG_FS)		+= debugfs.o
  acpi-$(CONFIG_ACPI_NUMA)	+= numa.o
  acpi-$(CONFIG_ACPI_PROCFS_POWER) += cm_sbs.o
++<<<<<<< HEAD
 +ifdef CONFIG_ACPI_VIDEO
 +acpi-y				+= video_detect.o
 +endif
 +obj-y				+= dptf/
++=======
+ acpi-y				+= acpi_lpat.o
+ acpi-$(CONFIG_ACPI_LPIT)	+= acpi_lpit.o
+ acpi-$(CONFIG_ACPI_GENERIC_GSI) += irq.o
+ acpi-$(CONFIG_ACPI_WATCHDOG)	+= acpi_watchdog.o
++>>>>>>> eeb2d80d502a (ACPI / LPIT: Add Low Power Idle Table (LPIT) support)
  
  # These are (potentially) separate modules
  
diff --cc drivers/acpi/internal.h
index 475933ff032f,fc8c43e76707..000000000000
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@@ -211,4 -232,26 +211,29 @@@ bool acpi_osi_is_win8(void)
  void acpi_init_properties(struct acpi_device *adev);
  void acpi_free_properties(struct acpi_device *adev);
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_X86
+ void acpi_extract_apple_properties(struct acpi_device *adev);
+ #else
+ static inline void acpi_extract_apple_properties(struct acpi_device *adev) {}
+ #endif
+ 
+ /*--------------------------------------------------------------------------
+ 				Watchdog
+   -------------------------------------------------------------------------- */
+ 
+ #ifdef CONFIG_ACPI_WATCHDOG
+ void acpi_watchdog_init(void);
+ #else
+ static inline void acpi_watchdog_init(void) {}
+ #endif
+ 
+ #ifdef CONFIG_ACPI_LPIT
+ void acpi_init_lpit(void);
+ #else
+ static inline void acpi_init_lpit(void) { }
+ #endif
+ 
++>>>>>>> eeb2d80d502a (ACPI / LPIT: Add Low Power Idle Table (LPIT) support)
  #endif /* _ACPI_INTERNAL_H_ */
diff --cc drivers/acpi/osl.c
index 5b65fc58d86c,3bb46cb24a99..000000000000
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@@ -834,21 -663,29 +834,49 @@@ acpi_status acpi_os_write_port(acpi_io_
  
  EXPORT_SYMBOL(acpi_os_write_port);
  
++<<<<<<< HEAD
 +#ifdef readq
 +static inline u64 read64(const volatile void __iomem *addr)
 +{
 +	return readq(addr);
 +}
 +#else
 +static inline u64 read64(const volatile void __iomem *addr)
 +{
 +	u64 l, h;
 +	l = readl(addr);
 +	h = readl(addr+4);
 +	return l | (h << 32);
 +}
 +#endif
 +
++acpi_status
++acpi_os_read_memory(acpi_physical_address phys_addr, u64 *value, u32 width)
++=======
+ int acpi_os_read_iomem(void __iomem *virt_addr, u64 *value, u32 width)
++>>>>>>> eeb2d80d502a (ACPI / LPIT: Add Low Power Idle Table (LPIT) support)
+ {
+ 
+ 	switch (width) {
+ 	case 8:
+ 		*(u8 *) value = readb(virt_addr);
+ 		break;
+ 	case 16:
+ 		*(u16 *) value = readw(virt_addr);
+ 		break;
+ 	case 32:
+ 		*(u32 *) value = readl(virt_addr);
+ 		break;
+ 	case 64:
 -		*(u64 *) value = readq(virt_addr);
++		*(u64 *) value = read64(virt_addr);
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
  acpi_status
  acpi_os_read_memory(acpi_physical_address phys_addr, u64 *value, u32 width)
  {
diff --cc drivers/acpi/scan.c
index e466e1416fc9,81367edc8a10..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -2009,6 -2120,25 +2009,28 @@@ int __init acpi_scan_init(void
  	acpi_memory_hotplug_init();
  	acpi_pnp_init();
  	acpi_int340x_thermal_init();
++<<<<<<< HEAD
++=======
+ 	acpi_amba_init();
+ 	acpi_watchdog_init();
+ 	acpi_init_lpit();
+ 
+ 	acpi_scan_add_handler(&generic_device_handler);
+ 
+ 	/*
+ 	 * If there is STAO table, check whether it needs to ignore the UART
+ 	 * device in SPCR table.
+ 	 */
+ 	status = acpi_get_table(ACPI_SIG_STAO, 0,
+ 				(struct acpi_table_header **)&stao_ptr);
+ 	if (ACPI_SUCCESS(status)) {
+ 		if (stao_ptr->header.length > sizeof(struct acpi_table_stao))
+ 			printk(KERN_INFO PREFIX "STAO Name List not yet supported.");
+ 
+ 		if (stao_ptr->ignore_uart)
+ 			acpi_get_spcr_uart_addr();
+ 	}
++>>>>>>> eeb2d80d502a (ACPI / LPIT: Add Low Power Idle Table (LPIT) support)
  
  	acpi_gpe_apply_masked_gpes();
  	acpi_update_all_gpes();
diff --git a/Documentation/acpi/lpit.txt b/Documentation/acpi/lpit.txt
new file mode 100644
index 000000000000..b426398d2e97
--- /dev/null
+++ b/Documentation/acpi/lpit.txt
@@ -0,0 +1,25 @@
+To enumerate platform Low Power Idle states, Intel platforms are using
+“Low Power Idle Table” (LPIT). More details about this table can be
+downloaded from:
+http://www.uefi.org/sites/default/files/resources/Intel_ACPI_Low_Power_S0_Idle.pdf
+
+Residencies for each low power state can be read via FFH
+(Function fixed hardware) or a memory mapped interface.
+
+On platforms supporting S0ix sleep states, there can be two types of
+residencies:
+- CPU PKG C10 (Read via FFH interface)
+- Platform Controller Hub (PCH) SLP_S0 (Read via memory mapped interface)
+
+The following attributes are added dynamically to the cpuidle
+sysfs attribute group:
+	/sys/devices/system/cpu/cpuidle/low_power_idle_cpu_residency_us
+	/sys/devices/system/cpu/cpuidle/low_power_idle_system_residency_us
+
+The "low_power_idle_cpu_residency_us" attribute shows time spent
+by the CPU package in PKG C10
+
+The "low_power_idle_system_residency_us" attribute shows SLP_S0
+residency, or system time spent with the SLP_S0# signal asserted.
+This is the lowest possible system power state, achieved only when CPU is in
+PKG C10 and all functional blocks in PCH are in a low power state.
* Unmerged path drivers/acpi/Kconfig
* Unmerged path drivers/acpi/Makefile
diff --git a/drivers/acpi/acpi_lpit.c b/drivers/acpi/acpi_lpit.c
new file mode 100644
index 000000000000..e94e478dd18b
--- /dev/null
+++ b/drivers/acpi/acpi_lpit.c
@@ -0,0 +1,162 @@
+
+/*
+ * acpi_lpit.c - LPIT table processing functions
+ *
+ * Copyright (C) 2017 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/cpu.h>
+#include <linux/acpi.h>
+#include <asm/msr.h>
+#include <asm/tsc.h>
+
+struct lpit_residency_info {
+	struct acpi_generic_address gaddr;
+	u64 frequency;
+	void __iomem *iomem_addr;
+};
+
+/* Storage for an memory mapped and FFH based entries */
+static struct lpit_residency_info residency_info_mem;
+static struct lpit_residency_info residency_info_ffh;
+
+static int lpit_read_residency_counter_us(u64 *counter, bool io_mem)
+{
+	int err;
+
+	if (io_mem) {
+		u64 count = 0;
+		int error;
+
+		error = acpi_os_read_iomem(residency_info_mem.iomem_addr, &count,
+					   residency_info_mem.gaddr.bit_width);
+		if (error)
+			return error;
+
+		*counter = div64_u64(count * 1000000ULL, residency_info_mem.frequency);
+		return 0;
+	}
+
+	err = rdmsrl_safe(residency_info_ffh.gaddr.address, counter);
+	if (!err) {
+		u64 mask = GENMASK_ULL(residency_info_ffh.gaddr.bit_offset +
+				       residency_info_ffh.gaddr. bit_width - 1,
+				       residency_info_ffh.gaddr.bit_offset);
+
+		*counter &= mask;
+		*counter >>= residency_info_ffh.gaddr.bit_offset;
+		*counter = div64_u64(*counter * 1000000ULL, residency_info_ffh.frequency);
+		return 0;
+	}
+
+	return -ENODATA;
+}
+
+static ssize_t low_power_idle_system_residency_us_show(struct device *dev,
+						       struct device_attribute *attr,
+						       char *buf)
+{
+	u64 counter;
+	int ret;
+
+	ret = lpit_read_residency_counter_us(&counter, true);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "%llu\n", counter);
+}
+static DEVICE_ATTR_RO(low_power_idle_system_residency_us);
+
+static ssize_t low_power_idle_cpu_residency_us_show(struct device *dev,
+						    struct device_attribute *attr,
+						    char *buf)
+{
+	u64 counter;
+	int ret;
+
+	ret = lpit_read_residency_counter_us(&counter, false);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "%llu\n", counter);
+}
+static DEVICE_ATTR_RO(low_power_idle_cpu_residency_us);
+
+int lpit_read_residency_count_address(u64 *address)
+{
+	if (!residency_info_mem.gaddr.address)
+		return -EINVAL;
+
+	*address = residency_info_mem.gaddr.address;
+
+	return 0;
+}
+
+static void lpit_update_residency(struct lpit_residency_info *info,
+				 struct acpi_lpit_native *lpit_native)
+{
+	info->frequency = lpit_native->counter_frequency ?
+				lpit_native->counter_frequency : tsc_khz * 1000;
+	if (!info->frequency)
+		info->frequency = 1;
+
+	info->gaddr = lpit_native->residency_counter;
+	if (info->gaddr.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {
+		info->iomem_addr = ioremap_nocache(info->gaddr.address,
+						   info->gaddr.bit_width / 8);
+		if (!info->iomem_addr)
+			return;
+
+		/* Silently fail, if cpuidle attribute group is not present */
+		sysfs_add_file_to_group(&cpu_subsys.dev_root->kobj,
+					&dev_attr_low_power_idle_system_residency_us.attr,
+					"cpuidle");
+	} else if (info->gaddr.space_id == ACPI_ADR_SPACE_FIXED_HARDWARE) {
+		/* Silently fail, if cpuidle attribute group is not present */
+		sysfs_add_file_to_group(&cpu_subsys.dev_root->kobj,
+					&dev_attr_low_power_idle_cpu_residency_us.attr,
+					"cpuidle");
+	}
+}
+
+static void lpit_process(u64 begin, u64 end)
+{
+	while (begin + sizeof(struct acpi_lpit_native) < end) {
+		struct acpi_lpit_native *lpit_native = (struct acpi_lpit_native *)begin;
+
+		if (!lpit_native->header.type && !lpit_native->header.flags) {
+			if (lpit_native->residency_counter.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY &&
+			    !residency_info_mem.gaddr.address) {
+				lpit_update_residency(&residency_info_mem, lpit_native);
+			} else if (lpit_native->residency_counter.space_id == ACPI_ADR_SPACE_FIXED_HARDWARE &&
+				   !residency_info_ffh.gaddr.address) {
+				lpit_update_residency(&residency_info_ffh, lpit_native);
+			}
+		}
+		begin += lpit_native->header.length;
+	}
+}
+
+void acpi_init_lpit(void)
+{
+	acpi_status status;
+	u64 lpit_begin;
+	struct acpi_table_lpit *lpit;
+
+	status = acpi_get_table(ACPI_SIG_LPIT, 0, (struct acpi_table_header **)&lpit);
+
+	if (ACPI_FAILURE(status))
+		return;
+
+	lpit_begin = (u64)lpit + sizeof(*lpit);
+	lpit_process(lpit_begin, lpit_begin + lpit->header.length);
+}
* Unmerged path drivers/acpi/internal.h
* Unmerged path drivers/acpi/osl.c
* Unmerged path drivers/acpi/scan.c
diff --git a/include/acpi/acpiosxf.h b/include/acpi/acpiosxf.h
index 78459a23ece1..63ae9d0cfa0b 100644
--- a/include/acpi/acpiosxf.h
+++ b/include/acpi/acpiosxf.h
@@ -293,6 +293,8 @@ acpi_status acpi_os_write_port(acpi_io_address address, u32 value, u32 width);
 /*
  * Platform and hardware-independent physical memory interfaces
  */
+int acpi_os_read_iomem(void __iomem *virt_addr, u64 *value, u32 width);
+
 #ifndef ACPI_USE_ALTERNATE_PROTOTYPE_acpi_os_read_memory
 acpi_status
 acpi_os_read_memory(acpi_physical_address address, u64 *value, u32 width);
diff --git a/include/linux/acpi.h b/include/linux/acpi.h
index 5a388eacbcb3..1843c3825d74 100644
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@ -897,4 +897,13 @@ static inline struct fwnode_handle *acpi_get_next_subnode(struct device *dev,
 }
 #endif
 
+#ifdef CONFIG_ACPI_LPIT
+int lpit_read_residency_count_address(u64 *address);
+#else
+static inline int lpit_read_residency_count_address(u64 *address)
+{
+	return -EINVAL;
+}
+#endif
+
 #endif	/*_LINUX_ACPI_H*/
