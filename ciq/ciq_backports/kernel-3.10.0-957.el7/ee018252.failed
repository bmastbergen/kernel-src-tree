tcmu: Make dev_config configurable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Bryant G. Ly <bryantly@linux.vnet.ibm.com>
commit ee01825220f01c0befea25f08325962fa9374ee2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ee018252.failed

This allows for userspace to change the device path after
it has been created. Thus giving the user the ability to change
the path. The use case for this is to allow for virtual optical
to have media change.

	Signed-off-by: Bryant G. Ly <bryantly@linux.vnet.ibm.com>
Reviewed-By: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit ee01825220f01c0befea25f08325962fa9374ee2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_user.c
diff --cc drivers/target/target_core_user.c
index 955a6ec44625,7c6475731895..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -1540,41 -1548,45 +1540,80 @@@ static ssize_t tcmu_cmd_time_out_store(
  }
  CONFIGFS_ATTR(tcmu_, cmd_time_out);
  
++<<<<<<< HEAD
 +static ssize_t tcmu_qfull_time_out_show(struct config_item *item, char *page)
++=======
+ static ssize_t tcmu_dev_path_show(struct config_item *item, char *page)
++>>>>>>> ee01825220f0 (tcmu: Make dev_config configurable)
  {
  	struct se_dev_attrib *da = container_of(to_config_group(item),
  						struct se_dev_attrib, da_group);
  	struct tcmu_dev *udev = TCMU_DEV(da->da_dev);
  
++<<<<<<< HEAD
 +	return snprintf(page, PAGE_SIZE, "%ld\n", udev->qfull_time_out <= 0 ?
 +			udev->qfull_time_out :
 +			udev->qfull_time_out / MSEC_PER_SEC);
 +}
 +
 +static ssize_t tcmu_qfull_time_out_store(struct config_item *item,
 +					 const char *page, size_t count)
++=======
+ 	return snprintf(page, PAGE_SIZE, "%s\n", udev->dev_config);
+ }
+ 
+ static ssize_t tcmu_dev_path_store(struct config_item *item, const char *page,
+ 				   size_t count)
++>>>>>>> ee01825220f0 (tcmu: Make dev_config configurable)
  {
  	struct se_dev_attrib *da = container_of(to_config_group(item),
  						struct se_dev_attrib, da_group);
  	struct tcmu_dev *udev = TCMU_DEV(da->da_dev);
++<<<<<<< HEAD
 +	s32 val;
 +	int ret;
 +
 +	ret = kstrtos32(page, 0, &val);
 +	if (ret < 0)
 +		return ret;
 +
 +	if (val >= 0) {
 +		udev->qfull_time_out = val * MSEC_PER_SEC;
 +	} else if (val == -1) {
 +		udev->qfull_time_out = val;
 +	} else {
 +		printk(KERN_ERR "Invalid qfull timeout value %d\n", val);
 +		return -EINVAL;
 +	}
 +	return count;
 +}
 +CONFIGFS_ATTR(tcmu_, qfull_time_out);
++=======
+ 	char *copy = NULL;
+ 	int ret;
+ 
+ 	copy = kstrdup(page, GFP_KERNEL);
+ 	if (!copy) {
+ 		kfree(copy);
+ 		return -EINVAL;
+ 	}
+ 	strlcpy(udev->dev_config, copy, TCMU_CONFIG_LEN);
+ 
+ 	/* Check if device has been configured before */
+ 	if (tcmu_dev_configured(udev)) {
+ 		ret = tcmu_netlink_event(TCMU_CMD_RECONFIG_DEVICE,
+ 					 udev->uio_info.name,
+ 					 udev->uio_info.uio_dev->minor);
+ 		if (ret) {
+ 			pr_err("Unable to reconfigure device\n");
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	return count;
+ }
+ CONFIGFS_ATTR(tcmu_, dev_path);
++>>>>>>> ee01825220f0 (tcmu: Make dev_config configurable)
  
  static ssize_t tcmu_dev_size_show(struct config_item *item, char *page)
  {
@@@ -1626,9 -1666,9 +1665,13 @@@ CONFIGFS_ATTR_RO(tcmu_, max_data_area_m
  
  struct configfs_attribute *tcmu_attrib_attrs[] = {
  	&tcmu_attr_cmd_time_out,
++<<<<<<< HEAD
 +	&tcmu_attr_qfull_time_out,
 +	&tcmu_attr_max_data_area_mb,
++=======
+ 	&tcmu_attr_dev_path,
++>>>>>>> ee01825220f0 (tcmu: Make dev_config configurable)
  	&tcmu_attr_dev_size,
 -	&tcmu_attr_emulate_write_cache,
  	NULL,
  };
  
* Unmerged path drivers/target/target_core_user.c
