powerpc/pseries: Use the security flags in pseries_setup_rfi_flush()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [powerpc] pseries: Use the security flags in pseries_setup_rfi_flush() (Mauricio Oliveira) [1561787]
Rebuild_FUZZ: 93.75%
commit-author Michael Ellerman <mpe@ellerman.id.au>
commit 2e4a16161fcd324b1f9bf6cb6856529f7eaf0689
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/2e4a1616.failed

Now that we have the security flags we can simplify the code in
pseries_setup_rfi_flush() because the security flags have pessimistic
defaults.

	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 2e4a16161fcd324b1f9bf6cb6856529f7eaf0689)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/pseries/setup.c
diff --cc arch/powerpc/platforms/pseries/setup.c
index 16f5e74be2ee,1f122359cd8f..000000000000
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@@ -501,55 -457,70 +501,78 @@@ static void __init find_and_init_phbs(v
  	 * PCI_PROBE_ONLY and PCI_REASSIGN_ALL_BUS can be set via properties
  	 * in chosen.
  	 */
 -	of_pci_check_probe_only();
 +	if (of_chosen) {
 +		const int *prop;
 +
 +		prop = of_get_property(of_chosen,
 +				"linux,pci-probe-only", NULL);
 +		if (prop) {
 +			if (*prop)
 +				pci_add_flags(PCI_PROBE_ONLY);
 +			else
 +				pci_clear_flags(PCI_PROBE_ONLY);
 +		}
 +
 +#ifdef CONFIG_PPC32 /* Will be made generic soon */
 +		prop = of_get_property(of_chosen,
 +				"linux,pci-assign-all-buses", NULL);
 +		if (prop && *prop)
 +			pci_add_flags(PCI_REASSIGN_ALL_BUS);
 +#endif /* CONFIG_PPC32 */
 +	}
  }
  
 -static void init_cpu_char_feature_flags(struct h_cpu_char_result *result)
 +static void pSeries_setup_rfi_flush(void)
  {
 -	if (result->character & H_CPU_CHAR_SPEC_BAR_ORI31)
 -		security_ftr_set(SEC_FTR_SPEC_BAR_ORI31);
 -
 -	if (result->character & H_CPU_CHAR_BCCTRL_SERIALISED)
 -		security_ftr_set(SEC_FTR_BCCTRL_SERIALISED);
 -
 -	if (result->character & H_CPU_CHAR_L1D_FLUSH_ORI30)
 -		security_ftr_set(SEC_FTR_L1D_FLUSH_ORI30);
 -
 -	if (result->character & H_CPU_CHAR_L1D_FLUSH_TRIG2)
 -		security_ftr_set(SEC_FTR_L1D_FLUSH_TRIG2);
 -
 -	if (result->character & H_CPU_CHAR_L1D_THREAD_PRIV)
 -		security_ftr_set(SEC_FTR_L1D_THREAD_PRIV);
 +	unsigned long character, behaviour, rc;
 +	enum l1d_flush_type types;
 +	bool enable;
  
 -	if (result->character & H_CPU_CHAR_COUNT_CACHE_DISABLED)
 -		security_ftr_set(SEC_FTR_COUNT_CACHE_DISABLED);
++<<<<<<< HEAD
 +	/* Enable by default */
 +	enable = true;
  
 -	/*
 -	 * The features below are enabled by default, so we instead look to see
 -	 * if firmware has *disabled* them, and clear them if so.
 -	 */
 -	if (!(result->character & H_CPU_BEHAV_FAVOUR_SECURITY))
 -		security_ftr_clear(SEC_FTR_FAVOUR_SECURITY);
 +	rc = plpar_get_cpu_characteristics(&character, &behaviour);
 +	if (rc == H_SUCCESS) {
 +		types = L1D_FLUSH_NONE;
  
 -	if (!(result->character & H_CPU_BEHAV_L1D_FLUSH_PR))
 -		security_ftr_clear(SEC_FTR_L1D_FLUSH_PR);
 +		if (character & H_GET_CPU_CHAR_CHAR_MTTRIG2_L1_FLUSH)
 +			types |= L1D_FLUSH_MTTRIG;
 +		if (character & H_GET_CPU_CHAR_CHAR_ORI30_L1_FLUSH)
 +			types |= L1D_FLUSH_ORI;
  
 -	if (!(result->character & H_CPU_BEHAV_BNDS_CHK_SPEC_BAR))
 -		security_ftr_clear(SEC_FTR_BNDS_CHK_SPEC_BAR);
 -}
 -
 -void pseries_setup_rfi_flush(void)
 -{
 -	struct h_cpu_char_result result;
 -	enum l1d_flush_type types;
 -	bool enable;
 -	long rc;
 +		/* Use fallback if nothing set in hcall */
 +		if (types == L1D_FLUSH_NONE)
 +			types = L1D_FLUSH_FALLBACK;
  
 +		if (!(behaviour & H_GET_CPU_CHAR_BEHAV_L1_FLUSH_LOW_PRIV))
 +			enable = false;
 +	} else {
 +		/* Default to fallback if case hcall is not available */
 +		types = L1D_FLUSH_FALLBACK;
 +	}
++=======
+ 	rc = plpar_get_cpu_characteristics(&result);
+ 	if (rc == H_SUCCESS)
+ 		init_cpu_char_feature_flags(&result);
+ 
+ 	/*
+ 	 * We're the guest so this doesn't apply to us, clear it to simplify
+ 	 * handling of it elsewhere.
+ 	 */
+ 	security_ftr_clear(SEC_FTR_L1D_FLUSH_HV);
++>>>>>>> 2e4a16161fcd (powerpc/pseries: Use the security flags in pseries_setup_rfi_flush())
+ 
+ 	types = L1D_FLUSH_FALLBACK;
+ 
+ 	if (security_ftr_enabled(SEC_FTR_L1D_FLUSH_TRIG2))
+ 		types |= L1D_FLUSH_MTTRIG;
+ 
+ 	if (security_ftr_enabled(SEC_FTR_L1D_FLUSH_ORI30))
+ 		types |= L1D_FLUSH_ORI;
+ 
+ 	enable = security_ftr_enabled(SEC_FTR_FAVOUR_SECURITY) && \
+ 		 security_ftr_enabled(SEC_FTR_L1D_FLUSH_PR);
  
  	setup_rfi_flush(types, enable);
  }
* Unmerged path arch/powerpc/platforms/pseries/setup.c
