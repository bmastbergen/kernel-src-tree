nvme_fc: rework sqsize handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author James Smart <jsmart2021@gmail.com>
commit d157e5343cb360a525e6b3e7924612a9a90df3b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d157e534.failed

Corrected four outstanding issues in the transport around sqsize.

1: Create Connection LS is sending the 1's-based sqsize, should be
sending the 0's-based value.

2: allocation of hw queue is using the 0's-base size. It should be
using the 1's-based value.

3: normalization of ctrl.sqsize by MQES is using MQES+1 (1's-based
value). It should be MQES (0's-based value).

4: Missing clause to ensure queue_count not larger than ctrl->sqsize.

Corrected by:
Clean up routines that pass queue size around. The queue size value is
the actual count (1's-based) value and determined from ctrl->sqsize + 1.

Routines that send 0's-based value adapt from queue size.

Sset ctrl->sqsize properly for MQES.

Added clause to nsure queue_count not larger than ctrl->sqsize + 1.

	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Keith Busch <keith.busch@intel.com>
(cherry picked from commit d157e5343cb360a525e6b3e7924612a9a90df3b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/fc.c
diff --cc drivers/nvme/host/fc.c
index 6e7bb75ba7ba,1dc1387b7134..000000000000
--- a/drivers/nvme/host/fc.c
+++ b/drivers/nvme/host/fc.c
@@@ -1221,11 -1206,10 +1221,11 @@@ nvme_fc_connect_admin_queue(struct nvme
  				sizeof(struct fcnvme_lsdesc_cr_assoc_cmd));
  
  	assoc_rqst->assoc_cmd.ersp_ratio = cpu_to_be16(ersp_ratio);
- 	assoc_rqst->assoc_cmd.sqsize = cpu_to_be16(qsize);
+ 	assoc_rqst->assoc_cmd.sqsize = cpu_to_be16(qsize - 1);
  	/* Linux supports only Dynamic controllers */
  	assoc_rqst->assoc_cmd.cntlid = cpu_to_be16(0xffff);
 -	uuid_copy(&assoc_rqst->assoc_cmd.hostid, &ctrl->ctrl.opts->host->id);
 +	memcpy(&assoc_rqst->assoc_cmd.hostid, &ctrl->ctrl.opts->host->id,
 +		min_t(size_t, FCNVME_ASSOC_HOSTID_LEN, sizeof(uuid_be)));
  	strncpy(assoc_rqst->assoc_cmd.hostnqn, ctrl->ctrl.opts->host->nqn,
  		min(FCNVME_ASSOC_HOSTNQN_LEN, NVMF_NQN_SIZE));
  	strncpy(assoc_rqst->assoc_cmd.subnqn, ctrl->ctrl.opts->subsysnqn,
@@@ -2707,16 -2629,15 +2707,24 @@@ nvme_fc_create_association(struct nvme_
  	 * Create the admin queue
  	 */
  
 -	nvme_fc_init_queue(ctrl, 0);
 +	nvme_fc_init_queue(ctrl, 0, NVME_FC_AQ_BLKMQ_DEPTH);
  
  	ret = __nvme_fc_create_hw_queue(ctrl, &ctrl->queues[0], 0,
++<<<<<<< HEAD
 +				NVME_FC_AQ_BLKMQ_DEPTH);
++=======
+ 				NVME_AQ_DEPTH);
++>>>>>>> d157e5343cb3 (nvme_fc: rework sqsize handling)
  	if (ret)
  		goto out_free_queue;
  
  	ret = nvme_fc_connect_admin_queue(ctrl, &ctrl->queues[0],
++<<<<<<< HEAD
 +				NVME_FC_AQ_BLKMQ_DEPTH,
 +				(NVME_FC_AQ_BLKMQ_DEPTH / 4));
++=======
+ 				NVME_AQ_DEPTH, (NVME_AQ_DEPTH / 4));
++>>>>>>> d157e5343cb3 (nvme_fc: rework sqsize handling)
  	if (ret)
  		goto out_delete_hw_queue;
  
* Unmerged path drivers/nvme/host/fc.c
