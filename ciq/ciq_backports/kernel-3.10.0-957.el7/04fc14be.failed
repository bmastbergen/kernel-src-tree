drm/nouveau/kms/nv50-: decouple window state changes, and update method submisssion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ben Skeggs <bskeggs@redhat.com>
commit 04fc14be7726edbb34404f69297e74061a8a9563
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/04fc14be.failed

This will be required to support Volta.

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit 04fc14be7726edbb34404f69297e74061a8a9563)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/dispnv50/disp.c
#	drivers/gpu/drm/nouveau/dispnv50/wndw.c
diff --cc drivers/gpu/drm/nouveau/dispnv50/disp.c
index a2ea42f947c7,0f2020010aab..000000000000
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.c
@@@ -3972,11 -1688,18 +3972,24 @@@ nv50_disp_atomic_commit_tail(struct drm
  	}
  
  	/* Flush disable. */
 -	if (interlock[NV50_DISP_INTERLOCK_CORE]) {
 +	if (interlock_core) {
  		if (atom->flush_disable) {
++<<<<<<< HEAD
 +			nv50_disp_atomic_commit_core(drm, interlock_chan);
 +			interlock_core = 0;
 +			interlock_chan = 0;
++=======
+ 			for_each_new_plane_in_state(state, plane, new_plane_state, i) {
+ 				struct nv50_wndw *wndw = nv50_wndw(plane);
+ 				if (interlock[wndw->interlock.type] & wndw->interlock.data) {
+ 					if (wndw->func->update)
+ 						wndw->func->update(wndw, interlock);
+ 				}
+ 			}
+ 
+ 			nv50_disp_atomic_commit_core(drm, interlock);
+ 			memset(interlock, 0x00, sizeof(interlock));
++>>>>>>> 04fc14be7726 (drm/nouveau/kms/nv50-: decouple window state changes, and update method submisssion)
  		}
  	}
  
@@@ -4036,17 -1759,20 +4049,34 @@@
  	}
  
  	/* Flush update. */
++<<<<<<< HEAD
 +	if (interlock_core) {
 +		if (!interlock_chan && atom->state.legacy_cursor_update) {
 +			u32 *push = evo_wait(&disp->mast, 2);
 +			if (push) {
 +				evo_mthd(push, 0x0080, 1);
 +				evo_data(push, 0x00000000);
 +				evo_kick(push, &disp->mast);
 +			}
 +		} else {
 +			nv50_disp_atomic_commit_core(drm, interlock_chan);
 +		}
++=======
+ 	for_each_new_plane_in_state(state, plane, new_plane_state, i) {
+ 		struct nv50_wndw *wndw = nv50_wndw(plane);
+ 		if (interlock[wndw->interlock.type] & wndw->interlock.data) {
+ 			if (wndw->func->update)
+ 				wndw->func->update(wndw, interlock);
+ 		}
+ 	}
+ 
+ 	if (interlock[NV50_DISP_INTERLOCK_CORE]) {
+ 		if (interlock[NV50_DISP_INTERLOCK_BASE] ||
+ 		    !atom->state.legacy_cursor_update)
+ 			nv50_disp_atomic_commit_core(drm, interlock);
+ 		else
+ 			disp->core->func->update(disp->core, interlock, false);
++>>>>>>> 04fc14be7726 (drm/nouveau/kms/nv50-: decouple window state changes, and update method submisssion)
  	}
  
  	if (atom->lock_core)
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/wndw.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/disp.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/wndw.c
