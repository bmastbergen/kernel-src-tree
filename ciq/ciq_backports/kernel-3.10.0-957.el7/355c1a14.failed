iio: kfifo_buf: Implement data_available() callback

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iio] kfifo_buf: Implement data_available() callback (Tony Camuso) [1559170]
Rebuild_FUZZ: 94.85%
commit-author Lars-Peter Clausen <lars@metafoo.de>
commit 355c1a14d4009a43e4d1f9cb42a382f0a94d01c4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/355c1a14.failed

This patch implements the data_available() callback for the kfifo buffer instead
of using the stufftoread flag. The kfifo used by the buffer already knows
whether it is empty or not based on the position of its read and write pointer.
Using this makes it a lot easier to tell whether data is available or not and it
is not necessary to take special measures to ensure that no race conditions
between reading and writing from the buffer occur.

Note, that we still have to take the buffers lock to protect against concurrent
resizeing of the kfifo.

	Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit 355c1a14d4009a43e4d1f9cb42a382f0a94d01c4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iio/kfifo_buf.c
diff --cc drivers/iio/kfifo_buf.c
index 1bea41bcbdc6,7134e8ada09a..000000000000
--- a/drivers/iio/kfifo_buf.c
+++ b/drivers/iio/kfifo_buf.c
@@@ -32,13 -33,17 +32,22 @@@ static int iio_request_update_kfifo(str
  	int ret = 0;
  	struct iio_kfifo *buf = iio_to_kfifo(r);
  
 -	mutex_lock(&buf->user_lock);
 -	if (buf->update_needed) {
 -		kfifo_free(&buf->kf);
 -		ret = __iio_allocate_kfifo(buf, buf->buffer.bytes_per_datum,
 +	if (!buf->update_needed)
 +		goto error_ret;
 +	kfifo_free(&buf->kf);
 +	ret = __iio_allocate_kfifo(buf, buf->buffer.bytes_per_datum,
  				   buf->buffer.length);
++<<<<<<< HEAD
 +	r->stufftoread = false;
 +error_ret:
++=======
+ 		buf->update_needed = false;
+ 	} else {
+ 		kfifo_reset_out(&buf->kf);
+ 	}
+ 	mutex_unlock(&buf->user_lock);
+ 
++>>>>>>> 355c1a14d400 (iio: kfifo_buf: Implement data_available() callback)
  	return ret;
  }
  
@@@ -114,22 -119,41 +123,57 @@@ static int iio_read_first_n_kfifo(struc
  	int ret, copied;
  	struct iio_kfifo *kf = iio_to_kfifo(r);
  
 -	if (mutex_lock_interruptible(&kf->user_lock))
 -		return -ERESTARTSYS;
 +	if (n < r->bytes_per_datum || r->bytes_per_datum == 0)
 +		return -EINVAL;
 +
++<<<<<<< HEAD
 +	ret = kfifo_to_user(&kf->kf, buf, n, &copied);
 +	if (ret < 0)
 +		return ret;
 +
 +	if (kfifo_is_empty(&kf->kf))
 +		r->stufftoread = false;
 +	/* verify it is still empty to avoid race */
 +	if (!kfifo_is_empty(&kf->kf))
 +		r->stufftoread = true;
 +
 +	return copied;
 +}
  
++=======
+ 	if (!kfifo_initialized(&kf->kf) || n < kfifo_esize(&kf->kf))
+ 		ret = -EINVAL;
+ 	else
+ 		ret = kfifo_to_user(&kf->kf, buf, n, &copied);
+ 	mutex_unlock(&kf->user_lock);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return copied;
+ }
+ 
+ static bool iio_kfifo_buf_data_available(struct iio_buffer *r)
+ {
+ 	struct iio_kfifo *kf = iio_to_kfifo(r);
+ 	bool empty;
+ 
+ 	mutex_lock(&kf->user_lock);
+ 	empty = kfifo_is_empty(&kf->kf);
+ 	mutex_unlock(&kf->user_lock);
+ 
+ 	return !empty;
+ }
+ 
+ static void iio_kfifo_buffer_release(struct iio_buffer *buffer)
+ {
+ 	struct iio_kfifo *kf = iio_to_kfifo(buffer);
+ 
+ 	mutex_destroy(&kf->user_lock);
+ 	kfifo_free(&kf->kf);
+ 	kfree(kf);
+ }
+ 
++>>>>>>> 355c1a14d400 (iio: kfifo_buf: Implement data_available() callback)
  static const struct iio_buffer_access_funcs kfifo_access_funcs = {
  	.store_to = &iio_store_to_kfifo,
  	.read_first_n = &iio_read_first_n_kfifo,
* Unmerged path drivers/iio/kfifo_buf.c
