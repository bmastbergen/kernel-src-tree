sfc: use a semaphore to lock farch filters too

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Edward Cree <ecree@solarflare.com>
commit fc7a6c287ff395eb64745292b4d398e64152cfb6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/fc7a6c28.failed

With this change, the spinlock efx->filter_lock is no longer used and is
 thus removed.

	Signed-off-by: Edward Cree <ecree@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fc7a6c287ff395eb64745292b4d398e64152cfb6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/farch.c
#	drivers/net/ethernet/sfc/net_driver.h
diff --cc drivers/net/ethernet/sfc/farch.c
index 1f1b062a8d89,4a19c7efdf8d..000000000000
--- a/drivers/net/ethernet/sfc/farch.c
+++ b/drivers/net/ethernet/sfc/farch.c
@@@ -2921,18 -2904,21 +2920,28 @@@ bool efx_farch_filter_rfs_expire_one(st
  				     unsigned int index)
  {
  	struct efx_farch_filter_state *state = efx->filter_state;
 -	struct efx_farch_filter_table *table;
 -	bool ret = false;
 +	struct efx_farch_filter_table *table =
 +		&state->table[EFX_FARCH_FILTER_TABLE_RX_IP];
  
++<<<<<<< HEAD
++=======
+ 	down_write(&state->lock);
+ 	table = &state->table[EFX_FARCH_FILTER_TABLE_RX_IP];
++>>>>>>> fc7a6c287ff3 (sfc: use a semaphore to lock farch filters too)
  	if (test_bit(index, table->used_bitmap) &&
  	    table->spec[index].priority == EFX_FILTER_PRI_HINT &&
  	    rps_may_expire_flow(efx->net_dev, table->spec[index].dmaq_id,
  				flow_id, index)) {
  		efx_farch_filter_table_clear_entry(efx, table, index);
 -		ret = true;
 +		return true;
  	}
  
++<<<<<<< HEAD
 +	return false;
++=======
+ 	up_write(&state->lock);
+ 	return ret;
++>>>>>>> fc7a6c287ff3 (sfc: use a semaphore to lock farch filters too)
  }
  
  #endif /* CONFIG_RFS_ACCEL */
diff --cc drivers/net/ethernet/sfc/net_driver.h
index d3b503c79fbe,92ee55d84b7d..000000000000
--- a/drivers/net/ethernet/sfc/net_driver.h
+++ b/drivers/net/ethernet/sfc/net_driver.h
@@@ -821,12 -843,12 +821,16 @@@ struct efx_rss_context 
   * @loopback_mode: Loopback status
   * @loopback_modes: Supported loopback mode bitmask
   * @loopback_selftest: Offline self-test private state
++<<<<<<< HEAD
 + * @filter_sem: Filter table rw_semaphore, for freeing the table
 + * @filter_lock: Filter table lock, for mere content changes
++=======
+  * @filter_sem: Filter table rw_semaphore, protects existence of @filter_state
++>>>>>>> fc7a6c287ff3 (sfc: use a semaphore to lock farch filters too)
   * @filter_state: Architecture-dependent filter table state
 - * @rps_mutex: Protects RPS state of all channels
 - * @rps_expire_channel: Next channel to check for expiry
 - * @rps_expire_index: Next index to check for expiry in
 - *	@rps_expire_channel's @rps_flow_id
 + * @rps_flow_id: Flow IDs of filters allocated for accelerated RFS,
 + *	indexed by filter ID
 + * @rps_expire_index: Next index to check for expiry in @rps_flow_id
   * @active_queues: Count of RX and TX queues that haven't been flushed and drained.
   * @rxq_flush_pending: Count of number of receive queues that need to be flushed.
   *	Decremented when the efx_flush_rx_queue() is called.
@@@ -974,10 -997,10 +978,9 @@@ struct efx_nic 
  	void *loopback_selftest;
  
  	struct rw_semaphore filter_sem;
- 	spinlock_t filter_lock;
  	void *filter_state;
  #ifdef CONFIG_RFS_ACCEL
 -	struct mutex rps_mutex;
 -	unsigned int rps_expire_channel;
 +	u32 *rps_flow_id;
  	unsigned int rps_expire_index;
  #endif
  
* Unmerged path drivers/net/ethernet/sfc/farch.c
* Unmerged path drivers/net/ethernet/sfc/net_driver.h
