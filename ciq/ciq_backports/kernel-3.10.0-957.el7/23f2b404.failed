mlxsw: spectrum: Update sch_prio stats to include sch_red related drops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Nogah Frankel <nogahf@mellanox.com>
commit 23f2b4048cc49d786c452f681dd5d8920ca095a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/23f2b404.failed

sch_prio as root qdisc should count all the drops its children have. Since
it is possible for it to have sch_red children, it needs to count RED early
drops.

	Signed-off-by: Nogah Frankel <nogahf@mellanox.com>
	Reviewed-by: Yuval Mintz <yuvalm@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 23f2b4048cc49d786c452f681dd5d8920ca095a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
index b5397da94d7f,bed7495d35d6..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
@@@ -275,3 -481,225 +275,228 @@@ int mlxsw_sp_setup_tc_red(struct mlxsw_
  		return -EOPNOTSUPP;
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ static int
+ mlxsw_sp_qdisc_prio_destroy(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			    struct mlxsw_sp_qdisc *mlxsw_sp_qdisc)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+ 		mlxsw_sp_port_prio_tc_set(mlxsw_sp_port, i,
+ 					  MLXSW_SP_PORT_DEFAULT_TCLASS);
+ 		mlxsw_sp_qdisc_destroy(mlxsw_sp_port,
+ 				       &mlxsw_sp_port->tclass_qdiscs[i]);
+ 		mlxsw_sp_port->tclass_qdiscs[i].prio_bitmap = 0;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_prio_check_params(struct mlxsw_sp_port *mlxsw_sp_port,
+ 				 struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 				 void *params)
+ {
+ 	struct tc_prio_qopt_offload_params *p = params;
+ 
+ 	if (p->bands > IEEE_8021QAZ_MAX_TCS)
+ 		return -EOPNOTSUPP;
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_prio_replace(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			    struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			    void *params)
+ {
+ 	struct tc_prio_qopt_offload_params *p = params;
+ 	struct mlxsw_sp_qdisc *child_qdisc;
+ 	int tclass, i, band, backlog;
+ 	u8 old_priomap;
+ 	int err;
+ 
+ 	for (band = 0; band < p->bands; band++) {
+ 		tclass = MLXSW_SP_PRIO_BAND_TO_TCLASS(band);
+ 		child_qdisc = &mlxsw_sp_port->tclass_qdiscs[tclass];
+ 		old_priomap = child_qdisc->prio_bitmap;
+ 		child_qdisc->prio_bitmap = 0;
+ 		for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+ 			if (p->priomap[i] == band) {
+ 				child_qdisc->prio_bitmap |= BIT(i);
+ 				if (BIT(i) & old_priomap)
+ 					continue;
+ 				err = mlxsw_sp_port_prio_tc_set(mlxsw_sp_port,
+ 								i, tclass);
+ 				if (err)
+ 					return err;
+ 			}
+ 		}
+ 		if (old_priomap != child_qdisc->prio_bitmap &&
+ 		    child_qdisc->ops && child_qdisc->ops->clean_stats) {
+ 			backlog = child_qdisc->stats_base.backlog;
+ 			child_qdisc->ops->clean_stats(mlxsw_sp_port,
+ 						      child_qdisc);
+ 			child_qdisc->stats_base.backlog = backlog;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void
+ mlxsw_sp_qdisc_prio_unoffload(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			      struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			      void *params)
+ {
+ 	struct tc_prio_qopt_offload_params *p = params;
+ 	u64 backlog;
+ 
+ 	backlog = mlxsw_sp_cells_bytes(mlxsw_sp_port->mlxsw_sp,
+ 				       mlxsw_sp_qdisc->stats_base.backlog);
+ 	p->qstats->backlog -= backlog;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_get_prio_stats(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			      struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			      struct tc_qopt_offload_stats *stats_ptr)
+ {
+ 	u64 tx_bytes, tx_packets, drops = 0, backlog = 0;
+ 	struct mlxsw_sp_qdisc_stats *stats_base;
+ 	struct mlxsw_sp_port_xstats *xstats;
+ 	struct rtnl_link_stats64 *stats;
+ 	int i;
+ 
+ 	xstats = &mlxsw_sp_port->periodic_hw_stats.xstats;
+ 	stats = &mlxsw_sp_port->periodic_hw_stats.stats;
+ 	stats_base = &mlxsw_sp_qdisc->stats_base;
+ 
+ 	tx_bytes = stats->tx_bytes - stats_base->tx_bytes;
+ 	tx_packets = stats->tx_packets - stats_base->tx_packets;
+ 
+ 	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+ 		drops += xstats->tail_drop[i];
+ 		drops += xstats->wred_drop[i];
+ 		backlog += xstats->backlog[i];
+ 	}
+ 	drops = drops - stats_base->drops;
+ 
+ 	_bstats_update(stats_ptr->bstats, tx_bytes, tx_packets);
+ 	stats_ptr->qstats->drops += drops;
+ 	stats_ptr->qstats->backlog +=
+ 				mlxsw_sp_cells_bytes(mlxsw_sp_port->mlxsw_sp,
+ 						     backlog) -
+ 				mlxsw_sp_cells_bytes(mlxsw_sp_port->mlxsw_sp,
+ 						     stats_base->backlog);
+ 	stats_base->backlog = backlog;
+ 	stats_base->drops += drops;
+ 	stats_base->tx_bytes += tx_bytes;
+ 	stats_base->tx_packets += tx_packets;
+ 	return 0;
+ }
+ 
+ static void
+ mlxsw_sp_setup_tc_qdisc_prio_clean_stats(struct mlxsw_sp_port *mlxsw_sp_port,
+ 					 struct mlxsw_sp_qdisc *mlxsw_sp_qdisc)
+ {
+ 	struct mlxsw_sp_qdisc_stats *stats_base;
+ 	struct mlxsw_sp_port_xstats *xstats;
+ 	struct rtnl_link_stats64 *stats;
+ 	int i;
+ 
+ 	xstats = &mlxsw_sp_port->periodic_hw_stats.xstats;
+ 	stats = &mlxsw_sp_port->periodic_hw_stats.stats;
+ 	stats_base = &mlxsw_sp_qdisc->stats_base;
+ 
+ 	stats_base->tx_packets = stats->tx_packets;
+ 	stats_base->tx_bytes = stats->tx_bytes;
+ 
+ 	stats_base->drops = 0;
+ 	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+ 		stats_base->drops += xstats->tail_drop[i];
+ 		stats_base->drops += xstats->wred_drop[i];
+ 	}
+ 
+ 	mlxsw_sp_qdisc->stats_base.backlog = 0;
+ }
+ 
+ static struct mlxsw_sp_qdisc_ops mlxsw_sp_qdisc_ops_prio = {
+ 	.type = MLXSW_SP_QDISC_PRIO,
+ 	.check_params = mlxsw_sp_qdisc_prio_check_params,
+ 	.replace = mlxsw_sp_qdisc_prio_replace,
+ 	.unoffload = mlxsw_sp_qdisc_prio_unoffload,
+ 	.destroy = mlxsw_sp_qdisc_prio_destroy,
+ 	.get_stats = mlxsw_sp_qdisc_get_prio_stats,
+ 	.clean_stats = mlxsw_sp_setup_tc_qdisc_prio_clean_stats,
+ };
+ 
+ int mlxsw_sp_setup_tc_prio(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			   struct tc_prio_qopt_offload *p)
+ {
+ 	struct mlxsw_sp_qdisc *mlxsw_sp_qdisc;
+ 
+ 	mlxsw_sp_qdisc = mlxsw_sp_qdisc_find(mlxsw_sp_port, p->parent, true);
+ 	if (!mlxsw_sp_qdisc)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (p->command == TC_PRIO_REPLACE)
+ 		return mlxsw_sp_qdisc_replace(mlxsw_sp_port, p->handle,
+ 					      mlxsw_sp_qdisc,
+ 					      &mlxsw_sp_qdisc_ops_prio,
+ 					      &p->replace_params);
+ 
+ 	if (!mlxsw_sp_qdisc_compare(mlxsw_sp_qdisc, p->handle,
+ 				    MLXSW_SP_QDISC_PRIO))
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (p->command) {
+ 	case TC_PRIO_DESTROY:
+ 		return mlxsw_sp_qdisc_destroy(mlxsw_sp_port, mlxsw_sp_qdisc);
+ 	case TC_PRIO_STATS:
+ 		return mlxsw_sp_qdisc_get_stats(mlxsw_sp_port, mlxsw_sp_qdisc,
+ 						&p->stats);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ int mlxsw_sp_tc_qdisc_init(struct mlxsw_sp_port *mlxsw_sp_port)
+ {
+ 	struct mlxsw_sp_qdisc *mlxsw_sp_qdisc;
+ 	int i;
+ 
+ 	mlxsw_sp_qdisc = kzalloc(sizeof(*mlxsw_sp_qdisc), GFP_KERNEL);
+ 	if (!mlxsw_sp_qdisc)
+ 		goto err_root_qdisc_init;
+ 
+ 	mlxsw_sp_port->root_qdisc = mlxsw_sp_qdisc;
+ 	mlxsw_sp_port->root_qdisc->prio_bitmap = 0xff;
+ 	mlxsw_sp_port->root_qdisc->tclass_num = MLXSW_SP_PORT_DEFAULT_TCLASS;
+ 
+ 	mlxsw_sp_qdisc = kzalloc(sizeof(*mlxsw_sp_qdisc) * IEEE_8021QAZ_MAX_TCS,
+ 				 GFP_KERNEL);
+ 	if (!mlxsw_sp_qdisc)
+ 		goto err_tclass_qdiscs_init;
+ 
+ 	mlxsw_sp_port->tclass_qdiscs = mlxsw_sp_qdisc;
+ 	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)
+ 		mlxsw_sp_port->tclass_qdiscs[i].tclass_num = i;
+ 
+ 	return 0;
+ 
+ err_tclass_qdiscs_init:
+ 	kfree(mlxsw_sp_port->root_qdisc);
+ err_root_qdisc_init:
+ 	return -ENOMEM;
+ }
+ 
+ void mlxsw_sp_tc_qdisc_fini(struct mlxsw_sp_port *mlxsw_sp_port)
+ {
+ 	kfree(mlxsw_sp_port->tclass_qdiscs);
+ 	kfree(mlxsw_sp_port->root_qdisc);
+ }
++>>>>>>> 23f2b4048cc4 (mlxsw: spectrum: Update sch_prio stats to include sch_red related drops)
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
