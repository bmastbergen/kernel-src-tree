scsi: megaraid_sas: Avoid firing DCMDs while OCR is in progress

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] megaraid_sas: Avoid firing DCMDs while OCR is in progress (Tomas Henzl) [1513838]
Rebuild_FUZZ: 95.00%
commit-author Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
commit 149c5751e672ca0a4892c1e5fd6b87535e81268d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/149c5751.failed

Driver needs to avoid PCI writes while OCR is in progress.  Use
reset_mutex to synchronize between firing DCMDs MR_DCMD_PD_GET_INFO and
MR_DCMD_DRV_GET_TARGET_PROP while OCR is triggered.  Without this fix,
if Device/VD add/creation is in progress and at the same time MR
Firmware is going through OCR, user may see OCR never completed and it
may need system reboot.  This scenario is rare to occur. Fix is provided
as part of review.

	Signed-off-by: Sumit Saxena <sumit.saxena@broadcom.com>
	Signed-off-by: Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 149c5751e672ca0a4892c1e5fd6b87535e81268d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas_base.c
diff --cc drivers/scsi/megaraid/megaraid_sas_base.c
index 8a636b558a1d,5ab343d386f9..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@@ -6225,6 -6319,58 +6225,61 @@@ void megasas_free_ctrl_dma_buffers(stru
  				    instance->crash_dump_h);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * megasas_init_ctrl_params -		Initialize controller's instance
+  *					parameters before FW init
+  * @instance -				Adapter soft instance
+  * @return -				void
+  */
+ static inline void megasas_init_ctrl_params(struct megasas_instance *instance)
+ {
+ 	instance->fw_crash_state = UNAVAILABLE;
+ 
+ 	megasas_poll_wait_aen = 0;
+ 	instance->issuepend_done = 1;
+ 	atomic_set(&instance->adprecovery, MEGASAS_HBA_OPERATIONAL);
+ 
+ 	/*
+ 	 * Initialize locks and queues
+ 	 */
+ 	INIT_LIST_HEAD(&instance->cmd_pool);
+ 	INIT_LIST_HEAD(&instance->internal_reset_pending_q);
+ 
+ 	atomic_set(&instance->fw_outstanding, 0);
+ 
+ 	init_waitqueue_head(&instance->int_cmd_wait_q);
+ 	init_waitqueue_head(&instance->abort_cmd_wait_q);
+ 
+ 	spin_lock_init(&instance->crashdump_lock);
+ 	spin_lock_init(&instance->mfi_pool_lock);
+ 	spin_lock_init(&instance->hba_lock);
+ 	spin_lock_init(&instance->stream_lock);
+ 	spin_lock_init(&instance->completion_lock);
+ 
+ 	mutex_init(&instance->reset_mutex);
+ 
+ 	if ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||
+ 	    (instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY))
+ 		instance->flag_ieee = 1;
+ 
+ 	megasas_dbg_lvl = 0;
+ 	instance->flag = 0;
+ 	instance->unload = 1;
+ 	instance->last_time = 0;
+ 	instance->disableOnlineCtrlReset = 1;
+ 	instance->UnevenSpanSupport = 0;
+ 
+ 	if (instance->adapter_type != MFI_SERIES) {
+ 		INIT_WORK(&instance->work_init, megasas_fusion_ocr_wq);
+ 		INIT_WORK(&instance->crash_init, megasas_fusion_crash_dump_wq);
+ 	} else {
+ 		INIT_WORK(&instance->work_init, process_fw_state_change_wq);
+ 	}
+ }
+ 
++>>>>>>> 149c5751e672 (scsi: megaraid_sas: Avoid firing DCMDs while OCR is in progress)
  /**
   * megasas_probe_one -	PCI hotplug entry point
   * @pdev:		PCI device structure
diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h
index d6b224965501..5cdccb36748b 100644
--- a/drivers/scsi/megaraid/megaraid_sas.h
+++ b/drivers/scsi/megaraid/megaraid_sas.h
@@ -2171,7 +2171,6 @@ struct megasas_instance {
 	struct megasas_evt_detail *evt_detail;
 	dma_addr_t evt_detail_h;
 	struct megasas_cmd *aen_cmd;
-	struct mutex hba_mutex;
 	struct semaphore ioctl_sem;
 
 	struct Scsi_Host *host;
* Unmerged path drivers/scsi/megaraid/megaraid_sas_base.c
