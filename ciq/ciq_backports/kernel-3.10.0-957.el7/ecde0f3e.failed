mm, memory_hotplug: remove timeout from __offline_memory

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mm] revert "memory_hotplug: remove timeout from __offline_memory" (Baoquan He) [1625143]
Rebuild_FUZZ: 90.60%
commit-author Michal Hocko <mhocko@suse.com>
commit ecde0f3e7f9edf8629f56b2354385dc8d0a6a24d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ecde0f3e.failed

We have a hardcoded 120s timeout after which the memory offline fails
basically since the hot remove has been introduced.  This is essentially
a policy implemented in the kernel.  Moreover there is no way to adjust
the timeout and so we are sometimes facing memory offline failures if
the system is under a heavy memory pressure or very intensive CPU
workload on large machines.

It is not very clear what purpose the timeout actually serves.  The
offline operation is interruptible by a signal so if userspace wants
some timeout based termination this can be done trivially by sending a
signal.

If there is a strong usecase to do this from the kernel then we should
do it properly and have a it tunable from the userspace with the timeout
disabled by default along with the explanation who uses it and for what
purporse.

Link: http://lkml.kernel.org/r/20170918070834.13083-3-mhocko@kernel.org
	Signed-off-by: Michal Hocko <mhocko@suse.com>
	Acked-by: Vlastimil Babka <vbabka@suse.cz>
	Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
	Cc: Reza Arbab <arbab@linux.vnet.ibm.com>
	Cc: Yasuaki Ishimatsu <yasu.isimatu@gmail.com>
	Cc: Xishi Qiu <qiuxishi@huawei.com>
	Cc: Igor Mammedov <imammedo@redhat.com>
	Cc: Vitaly Kuznetsov <vkuznets@redhat.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ecde0f3e7f9edf8629f56b2354385dc8d0a6a24d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory_hotplug.c
diff --cc mm/memory_hotplug.c
index fc0a08f4187f,fab51a6af962..000000000000
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@@ -1743,11 -1590,13 +1743,11 @@@ static void node_states_clear_node(int 
  }
  
  static int __ref __offline_pages(unsigned long start_pfn,
- 		  unsigned long end_pfn, unsigned long timeout)
+ 		  unsigned long end_pfn)
  {
- 	unsigned long pfn, nr_pages, expire;
+ 	unsigned long pfn, nr_pages;
  	long offlined_pages;
 -	int ret, node;
 -	unsigned long flags;
 -	unsigned long valid_start, valid_end;
 +	int ret, drain, retry_max, node;
  	struct zone *zone;
  	struct memory_notify arg;
  
@@@ -1785,14 -1630,8 +1785,19 @@@
  		goto failed_removal;
  
  	pfn = start_pfn;
++<<<<<<< HEAD
 +	expire = jiffies + timeout;
 +	drain = 0;
 +	retry_max = 5;
  repeat:
  	/* start memory hot removal */
 +	ret = -EAGAIN;
 +	if (time_after(jiffies, expire))
 +		goto failed_removal;
++=======
++repeat:
++	/* start memory hot removal */
++>>>>>>> ecde0f3e7f9e (mm, memory_hotplug: remove timeout from __offline_memory)
  	ret = -EINTR;
  	if (signal_pending(current))
  		goto failed_removal;
@@@ -1877,10 -1701,10 +1882,10 @@@ failed_removal
  	return ret;
  }
  
 -/* Must be protected by mem_hotplug_begin() or a device_lock */
 +/* Must be protected by mem_hotplug_begin() */
  int offline_pages(unsigned long start_pfn, unsigned long nr_pages)
  {
- 	return __offline_pages(start_pfn, start_pfn + nr_pages, 120 * HZ);
+ 	return __offline_pages(start_pfn, start_pfn + nr_pages);
  }
  #endif /* CONFIG_MEMORY_HOTREMOVE */
  
* Unmerged path mm/memory_hotplug.c
