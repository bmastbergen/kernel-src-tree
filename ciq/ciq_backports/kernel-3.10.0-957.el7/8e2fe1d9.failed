bpf: add new arg_type that allows for 0 sized stack buffer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit 8e2fe1d9f1a20924f98ea46931a1d7fb092aa876
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8e2fe1d9.failed

Currently, when we pass a buffer from the eBPF stack into a helper
function, the function proto indicates argument types as ARG_PTR_TO_STACK
and ARG_CONST_STACK_SIZE pair. If R<X> contains the former, then R<X+1>
must be of the latter type. Then, verifier checks whether the buffer
points into eBPF stack, is initialized, etc. The verifier also guarantees
that the constant value passed in R<X+1> is greater than 0, so helper
functions don't need to test for it and can always assume a non-NULL
initialized buffer as well as non-0 buffer size.

This patch adds a new argument types ARG_CONST_STACK_SIZE_OR_ZERO that
allows to also pass NULL as R<X> and 0 as R<X+1> into the helper function.
Such helper functions, of course, need to be able to handle these cases
internally then. Verifier guarantees that either R<X> == NULL && R<X+1> == 0
or R<X> != NULL && R<X+1> != 0 (like the case of ARG_CONST_STACK_SIZE), any
other combinations are not possible to load.

I went through various options of extending the verifier, and introducing
the type ARG_CONST_STACK_SIZE_OR_ZERO seems to have most minimal changes
needed to the verifier.

	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8e2fe1d9f1a20924f98ea46931a1d7fb092aa876)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	kernel/bpf/verifier.c
diff --cc include/linux/bpf.h
index d4c1f9049ad3,51e498e5470e..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -42,40 -49,34 +42,49 @@@ struct bpf_map_type_list 
  	enum bpf_map_type type;
  };
  
 -/* function argument constraints */
 -enum bpf_arg_type {
 -	ARG_DONTCARE = 0,	/* unused argument in helper function */
 +void bpf_register_map_type(struct bpf_map_type_list *tl);
  
 -	/* the following constraints used to prototype
 -	 * bpf_map_lookup/update/delete_elem() functions
 -	 */
 -	ARG_CONST_MAP_PTR,	/* const argument used as pointer to bpf_map */
 -	ARG_PTR_TO_MAP_KEY,	/* pointer to stack used as map key */
 -	ARG_PTR_TO_MAP_VALUE,	/* pointer to stack used as map value */
 +static inline struct bpf_prog *bpf_prog_get(u32 ufd)
 +{
 +	return NULL;
 +}
  
++<<<<<<< HEAD
 +static inline struct bpf_prog *bpf_prog_get_type(u32 ufd, enum bpf_prog_type type)
 +{
 +	return NULL;
 +}
++=======
+ 	/* the following constraints used to prototype bpf_memcmp() and other
+ 	 * functions that access data on eBPF program stack
+ 	 */
+ 	ARG_PTR_TO_STACK,	/* any pointer to eBPF program stack */
+ 	ARG_CONST_STACK_SIZE,	/* number of bytes accessed from stack */
+ 	ARG_CONST_STACK_SIZE_OR_ZERO, /* number of bytes accessed from stack or 0 */
++>>>>>>> 8e2fe1d9f1a2 (bpf: add new arg_type that allows for 0 sized stack buffer)
  
 -	ARG_PTR_TO_CTX,		/* pointer to context */
 -	ARG_ANYTHING,		/* any (initialized) argument is ok */
 -};
 +static inline struct bpf_prog *bpf_prog_add(struct bpf_prog *prog, int i)
 +{
 +	return NULL;
 +}
 +
 +static inline struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog)
 +{
 +	return prog;
 +}
 +
 +static inline void bpf_prog_put(struct bpf_prog *prog)
 +{
 +	return;
 +}
  
 -/* type of values returned from helper functions */
 -enum bpf_return_type {
 -	RET_INTEGER,			/* function returns integer */
 -	RET_VOID,			/* function doesn't return anything */
 -	RET_PTR_TO_MAP_VALUE_OR_NULL,	/* returns a pointer to map elem value or NULL */
 -};
 +
 +struct bpf_map *bpf_map_get_with_uref(u32 ufd);
 +struct bpf_map *__bpf_map_get(struct fd f);
 +struct bpf_map *bpf_map_inc(struct bpf_map *map, bool uref);
 +void bpf_map_put_with_uref(struct bpf_map *map);
 +void bpf_map_put(struct bpf_map *map);
 +struct bpf_map *bpf_map_get(struct fd f);
  
  /* eBPF function prototype used by verifier to allow BPF_CALLs from eBPF programs
   * to in-kernel helper functions and for adjusting imm32 field in BPF_CALL
* Unmerged path kernel/bpf/verifier.c
* Unmerged path include/linux/bpf.h
* Unmerged path kernel/bpf/verifier.c
