timer: Don't initialize 'tvec_base' on hotplug

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 8def906044c02edcedac79aa3d6310ab4d90c4d8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8def9060.failed

There is no need to call init_timers_cpu() on every CPU hotplug event,
there is not much we need to reset.

 - Timer-lists are already empty at the end of migrate_timers().
 - timer_jiffies will be refreshed while adding a new timer, after the
   CPU is online again.
 - active_timers and all_timers can be reset from migrate_timers().

	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/54a1c30ea7b805af55beb220cadf5a07a21b0a4d.1427814611.git.viresh.kumar@linaro.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 8def906044c02edcedac79aa3d6310ab4d90c4d8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/timer.c
diff --cc kernel/timer.c
index da449ea19b18,1feb9c7035c0..000000000000
--- a/kernel/timer.c
+++ b/kernel/timer.c
@@@ -1523,65 -1543,6 +1523,68 @@@ signed long __sched schedule_timeout_un
  }
  EXPORT_SYMBOL(schedule_timeout_uninterruptible);
  
++<<<<<<< HEAD:kernel/timer.c
 +static int init_timers_cpu(int cpu)
 +{
 +	int j;
 +	struct tvec_base *base;
 +	static char tvec_base_done[NR_CPUS];
 +
 +	if (!tvec_base_done[cpu]) {
 +		static char boot_done;
 +
 +		if (boot_done) {
 +			/*
 +			 * The APs use this path later in boot
 +			 */
 +			base = kmalloc_node(sizeof(*base),
 +						GFP_KERNEL | __GFP_ZERO,
 +						cpu_to_node(cpu));
 +			if (!base)
 +				return -ENOMEM;
 +
 +			/* Make sure that tvec_base is 2 byte aligned */
 +			if (tbase_get_deferrable(base)) {
 +				WARN_ON(1);
 +				kfree(base);
 +				return -ENOMEM;
 +			}
 +			per_cpu(tvec_bases, cpu) = base;
 +		} else {
 +			/*
 +			 * This is for the boot CPU - we use compile-time
 +			 * static initialisation because per-cpu memory isn't
 +			 * ready yet and because the memory allocators are not
 +			 * initialised either.
 +			 */
 +			boot_done = 1;
 +			base = &boot_tvec_bases;
 +		}
 +		spin_lock_init(&base->lock);
 +		tvec_base_done[cpu] = 1;
 +	} else {
 +		base = per_cpu(tvec_bases, cpu);
 +	}
 +
 +
 +	for (j = 0; j < TVN_SIZE; j++) {
 +		INIT_LIST_HEAD(base->tv5.vec + j);
 +		INIT_LIST_HEAD(base->tv4.vec + j);
 +		INIT_LIST_HEAD(base->tv3.vec + j);
 +		INIT_LIST_HEAD(base->tv2.vec + j);
 +	}
 +	for (j = 0; j < TVR_SIZE; j++)
 +		INIT_LIST_HEAD(base->tv1.vec + j);
 +
 +	base->timer_jiffies = jiffies;
 +	base->next_timer = base->timer_jiffies;
 +	base->active_timers = 0;
 +	base->all_timers = 0;
 +	return 0;
 +}
 +
++=======
++>>>>>>> 8def906044c0 (timer: Don't initialize 'tvec_base' on hotplug):kernel/time/timer.c
  #ifdef CONFIG_HOTPLUG_CPU
  static void migrate_timer_list(struct tvec_base *new_base, struct list_head *head)
  {
@@@ -1666,11 -1655,8 +1697,15 @@@ void __init init_timers(void
  	/* ensure there are enough low bits for flags in timer->base pointer */
  	BUILD_BUG_ON(__alignof__(struct tvec_base) & TIMER_FLAG_MASK);
  
++<<<<<<< HEAD:kernel/timer.c
 +	err = timer_cpu_notify(&timers_nb, (unsigned long)CPU_UP_PREPARE,
 +			       (void *)(long)smp_processor_id());
++=======
+ 	init_timer_cpus();
++>>>>>>> 8def906044c0 (timer: Don't initialize 'tvec_base' on hotplug):kernel/time/timer.c
  	init_timer_stats();
 +
 +	BUG_ON(err != NOTIFY_OK);
  	register_cpu_notifier(&timers_nb);
  	open_softirq(TIMER_SOFTIRQ, run_timer_softirq);
  }
* Unmerged path kernel/timer.c
