scsi: qla2xxx: Fix FC-NVMe IO abort during driver reset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Fix FC-NVMe IO abort during driver reset (Himanshu Madhani) [1547714]
Rebuild_FUZZ: 94.23%
commit-author Darren Trapp <darren.trapp@cavium.com>
commit 623ee824e579d234b9f68c7b28ff5ab43f7c78e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/623ee824.failed

	Signed-off-by: Darren Trapp <darren.trapp@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 623ee824e579d234b9f68c7b28ff5ab43f7c78e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_nvme.c
#	drivers/scsi/qla2xxx/qla_nvme.h
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 20a870bdd02c,54f93f9cba48..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -1701,69 -1722,70 +1701,92 @@@ qla2x00_abort_all_cmds(scsi_qla_host_t 
  	struct qla_tgt_cmd *cmd;
  	uint8_t trace = 0;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	for (que = 0; que < ha->max_req_queues; que++) {
 +		req = ha->req_q_map[que];
 +		if (!req)
 +			continue;
 +		if (!req->outstanding_cmds)
 +			continue;
 +		for (cnt = 1; cnt < req->num_outstanding_cmds; cnt++) {
 +			sp = req->outstanding_cmds[cnt];
 +			if (sp) {
 +				req->outstanding_cmds[cnt] = NULL;
 +				if (sp->cmd_type == TYPE_SRB) {
++=======
+ 	spin_lock_irqsave(qp->qp_lock_ptr, flags);
+ 	req = qp->req;
+ 	for (cnt = 1; cnt < req->num_outstanding_cmds; cnt++) {
+ 		sp = req->outstanding_cmds[cnt];
+ 		if (sp) {
+ 			req->outstanding_cmds[cnt] = NULL;
+ 			if (sp->cmd_type == TYPE_SRB) {
+ 				if (sp->type == SRB_NVME_CMD ||
+ 				    sp->type == SRB_NVME_LS) {
+ 					sp_get(sp);
+ 					spin_unlock_irqrestore(qp->qp_lock_ptr,
+ 					    flags);
+ 					qla_nvme_abort(ha, sp, res);
+ 					spin_lock_irqsave(qp->qp_lock_ptr,
+ 					    flags);
+ 				} else if (GET_CMD_SP(sp) &&
+ 				    !ha->flags.eeh_busy &&
+ 				    (!test_bit(ABORT_ISP_ACTIVE,
+ 					&vha->dpc_flags)) &&
+ 				    (sp->type == SRB_SCSI_CMD)) {
++>>>>>>> 623ee824e579 (scsi: qla2xxx: Fix FC-NVMe IO abort during driver reset)
  					/*
 -					 * Don't abort commands in
 -					 * adapter during EEH
 -					 * recovery as it's not
 +					 * Don't abort commands in adapter
 +					 * during EEH recovery as it's not
  					 * accessible/responding.
 -					 *
 -					 * Get a reference to the sp
 -					 * and drop the lock. The
 -					 * reference ensures this
 -					 * sp->done() call and not the
 -					 * call in qla2xxx_eh_abort()
 -					 * ends the SCSI command (with
 -					 * result 'res').
  					 */
 -					sp_get(sp);
 -					spin_unlock_irqrestore(qp->qp_lock_ptr,
 -					    flags);
 -					status = qla2xxx_eh_abort(
 -					    GET_CMD_SP(sp));
 -					spin_lock_irqsave(qp->qp_lock_ptr,
 -					    flags);
 -					/*
 -					 * Get rid of extra reference
 -					 * if immediate exit from
 -					 * ql2xxx_eh_abort
 -					 */
 -					if (status == FAILED &&
 -					    (qla2x00_isp_reg_stat(ha)))
 -						atomic_dec(
 -						    &sp->ref_count);
 -				}
 -				sp->done(sp, res);
 -			} else {
 -				if (!vha->hw->tgt.tgt_ops || !tgt ||
 -				    qla_ini_mode_enabled(vha)) {
 -					if (!trace)
 -						ql_dbg(ql_dbg_tgt_mgt,
 -						    vha, 0xf003,
 -						    "HOST-ABORT-HNDLR: dpc_flags=%lx. Target mode disabled\n",
 -						    vha->dpc_flags);
 -					continue;
 +					if (GET_CMD_SP(sp) &&
 +					    !ha->flags.eeh_busy &&
 +					    (!test_bit(ABORT_ISP_ACTIVE,
 +						&vha->dpc_flags)) &&
 +					    (sp->type == SRB_SCSI_CMD)) {
 +						/*
 +						 * Get a reference to the sp
 +						 * and drop the lock. The
 +						 * reference ensures this
 +						 * sp->done() call and not the
 +						 * call in qla2xxx_eh_abort()
 +						 * ends the SCSI command (with
 +						 * result 'res').
 +						 */
 +						sp_get(sp);
 +						spin_unlock_irqrestore(
 +						    &ha->hardware_lock, flags);
 +						status = qla2xxx_eh_abort(
 +						    GET_CMD_SP(sp));
 +						spin_lock_irqsave(
 +						    &ha->hardware_lock, flags);
 +						/*
 +						 * Get rid of extra reference
 +						 * if immediate exit from
 +						 * ql2xxx_eh_abort
 +						 */
 +						if (status == FAILED &&
 +						    (qla2x00_isp_reg_stat(ha)))
 +							atomic_dec(
 +							    &sp->ref_count);
 +					}
 +					sp->done(sp, res);
 +				} else {
 +					if (!vha->hw->tgt.tgt_ops || !tgt ||
 +					    qla_ini_mode_enabled(vha)) {
 +						if (!trace)
 +							ql_dbg(ql_dbg_tgt_mgt,
 +							    vha, 0xf003,
 +							    "HOST-ABORT-HNDLR: dpc_flags=%lx. Target mode disabled\n",
 +							    vha->dpc_flags);
 +						continue;
 +					}
 +					cmd = (struct qla_tgt_cmd *)sp;
 +					qlt_abort_cmd_on_host_reset(cmd->vha,
 +					    cmd);
  				}
 -				cmd = (struct qla_tgt_cmd *)sp;
 -				qlt_abort_cmd_on_host_reset(cmd->vha, cmd);
  			}
  		}
  	}
* Unmerged path drivers/scsi/qla2xxx/qla_nvme.c
* Unmerged path drivers/scsi/qla2xxx/qla_nvme.h
* Unmerged path drivers/scsi/qla2xxx/qla_nvme.c
* Unmerged path drivers/scsi/qla2xxx/qla_nvme.h
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
