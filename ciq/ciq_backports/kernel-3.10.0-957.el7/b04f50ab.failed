blk-mq: only attempt to merge bio if there is rq in sw queue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ming Lei <ming.lei@redhat.com>
commit b04f50ab8a74129b3041a2836c33c916be3c6667
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b04f50ab.failed

Only attempt to merge bio iff the ctx->rq_list isn't empty, because:

1) for high-performance SSD, most of times dispatch may succeed, then
there may be nothing left in ctx->rq_list, so don't try to merge over
sw queue if it is empty, then we can save one acquiring of ctx->lock

2) we can't expect good merge performance on per-cpu sw queue, and missing
one merge on sw queue won't be a big deal since tasks can be scheduled from
one CPU to another.

	Cc: Laurence Oberman <loberman@redhat.com>
	Cc: Omar Sandoval <osandov@fb.com>
	Cc: Bart Van Assche <bart.vanassche@wdc.com>
	Tested-by: Kashyap Desai <kashyap.desai@broadcom.com>
	Reported-by: Kashyap Desai <kashyap.desai@broadcom.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit b04f50ab8a74129b3041a2836c33c916be3c6667)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq-sched.c
diff --cc block/blk-mq-sched.c
index e1ac9f3d0935,f3b4b5ceb4d1..000000000000
--- a/block/blk-mq-sched.c
+++ b/block/blk-mq-sched.c
@@@ -368,16 -317,25 +368,29 @@@ EXPORT_SYMBOL_GPL(blk_mq_sched_try_merg
  bool __blk_mq_sched_bio_merge(struct request_queue *q, struct bio *bio)
  {
  	struct elevator_queue *e = q->elevator;
 -	struct blk_mq_ctx *ctx = blk_mq_get_ctx(q);
 -	struct blk_mq_hw_ctx *hctx = blk_mq_map_queue(q, ctx->cpu);
 -	bool ret = false;
  
 -	if (e && e->type->ops.mq.bio_merge) {
 +	if (e->aux->ops.mq.bio_merge) {
 +		struct blk_mq_ctx *ctx = blk_mq_get_ctx(q);
 +		struct blk_mq_hw_ctx *hctx = blk_mq_map_queue(q, ctx->cpu);
 +
  		blk_mq_put_ctx(ctx);
 -		return e->type->ops.mq.bio_merge(hctx, bio);
 +		return e->aux->ops.mq.bio_merge(hctx, bio);
  	}
  
++<<<<<<< HEAD
 +	return false;
++=======
+ 	if ((hctx->flags & BLK_MQ_F_SHOULD_MERGE) &&
+ 			!list_empty_careful(&ctx->rq_list)) {
+ 		/* default per sw-queue merge */
+ 		spin_lock(&ctx->lock);
+ 		ret = blk_mq_attempt_merge(q, ctx, bio);
+ 		spin_unlock(&ctx->lock);
+ 	}
+ 
+ 	blk_mq_put_ctx(ctx);
+ 	return ret;
++>>>>>>> b04f50ab8a74 (blk-mq: only attempt to merge bio if there is rq in sw queue)
  }
  
  bool blk_mq_sched_try_insert_merge(struct request_queue *q, struct request *rq)
* Unmerged path block/blk-mq-sched.c
