netfilter: Remove unnecessary cast on void pointer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author simran singhal <singhalsimran0@gmail.com>
commit 68ad546aefddb4dacdb78074df9dddb51424c427
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/68ad546a.failed

The following Coccinelle script was used to detect this:
@r@
expression x;
void* e;
type T;
identifier f;
@@
(
  *((T *)e)
|
  ((T *)x)[...]
|
  ((T*)x)->f
|

- (T*)
  e
)

Unnecessary parantheses are also remove.

	Signed-off-by: simran singhal <singhalsimran0@gmail.com>
	Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 68ad546aefddb4dacdb78074df9dddb51424c427)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/netfilter/arp_tables.c
#	net/ipv4/netfilter/ip_tables.c
#	net/ipv6/netfilter/ip6_tables.c
#	net/netfilter/ipset/ip_set_bitmap_gen.h
#	net/netfilter/ipset/ip_set_core.c
#	net/netfilter/nft_set_hash.c
#	net/netfilter/xt_hashlimit.c
diff --cc net/ipv4/netfilter/arp_tables.c
index db08227b5640,0bc3c3d73e61..000000000000
--- a/net/ipv4/netfilter/arp_tables.c
+++ b/net/ipv4/netfilter/arp_tables.c
@@@ -828,7 -676,11 +823,15 @@@ static int copy_entries_to_user(unsigne
  	for (off = 0, num = 0; off < total_size; off += e->next_offset, num++){
  		const struct xt_entry_target *t;
  
++<<<<<<< HEAD
 +		e = (struct arpt_entry *)(loc_cpu_entry + off);
++=======
+ 		e = loc_cpu_entry + off;
+ 		if (copy_to_user(userptr + off, e, sizeof(*e))) {
+ 			ret = -EFAULT;
+ 			goto free_counters;
+ 		}
++>>>>>>> 68ad546aefdd (netfilter: Remove unnecessary cast on void pointer)
  		if (copy_to_user(userptr + off
  				 + offsetof(struct arpt_entry, counters),
  				 &counters[num],
diff --cc net/ipv4/netfilter/ip_tables.c
index 8ba1995799c8,2a55a40211cb..000000000000
--- a/net/ipv4/netfilter/ip_tables.c
+++ b/net/ipv4/netfilter/ip_tables.c
@@@ -987,7 -830,11 +983,15 @@@ copy_entries_to_user(unsigned int total
  		const struct xt_entry_match *m;
  		const struct xt_entry_target *t;
  
++<<<<<<< HEAD
 +		e = (struct ipt_entry *)(loc_cpu_entry + off);
++=======
+ 		e = loc_cpu_entry + off;
+ 		if (copy_to_user(userptr + off, e, sizeof(*e))) {
+ 			ret = -EFAULT;
+ 			goto free_counters;
+ 		}
++>>>>>>> 68ad546aefdd (netfilter: Remove unnecessary cast on void pointer)
  		if (copy_to_user(userptr + off
  				 + offsetof(struct ipt_entry, counters),
  				 &counters[num],
diff --cc net/ipv6/netfilter/ip6_tables.c
index 8d0065d4cef6,d862e3471935..000000000000
--- a/net/ipv6/netfilter/ip6_tables.c
+++ b/net/ipv6/netfilter/ip6_tables.c
@@@ -995,7 -859,11 +991,15 @@@ copy_entries_to_user(unsigned int total
  		const struct xt_entry_match *m;
  		const struct xt_entry_target *t;
  
++<<<<<<< HEAD
 +		e = (struct ip6t_entry *)(loc_cpu_entry + off);
++=======
+ 		e = loc_cpu_entry + off;
+ 		if (copy_to_user(userptr + off, e, sizeof(*e))) {
+ 			ret = -EFAULT;
+ 			goto free_counters;
+ 		}
++>>>>>>> 68ad546aefdd (netfilter: Remove unnecessary cast on void pointer)
  		if (copy_to_user(userptr + off
  				 + offsetof(struct ip6t_entry, counters),
  				 &counters[num],
diff --cc net/netfilter/ipset/ip_set_bitmap_gen.h
index 01a340ce9e94,8ad2b52a0b32..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_gen.h
+++ b/net/netfilter/ipset/ip_set_bitmap_gen.h
@@@ -184,35 -232,23 +184,43 @@@ mtype_list(const struct ip_set *set
  		if (!test_bit(id, map->members) ||
  		    (SET_WITH_TIMEOUT(set) &&
  #ifdef IP_SET_BITMAP_STORED_TIMEOUT
++<<<<<<< HEAD
 +		     mtype_is_filled((const struct mtype_elem *) x) &&
++=======
+ 		     mtype_is_filled(x) &&
++>>>>>>> 68ad546aefdd (netfilter: Remove unnecessary cast on void pointer)
  #endif
 -		     ip_set_timeout_expired(ext_timeout(x, set))))
 +		     ip_set_timeout_expired(ext_timeout(x, map))))
  			continue;
  		nested = ipset_nest_start(skb, IPSET_ATTR_DATA);
  		if (!nested) {
  			if (id == first) {
  				nla_nest_cancel(skb, adt);
 -				ret = -EMSGSIZE;
 -				goto out;
 -			}
 -
 -			goto nla_put_failure;
 +				return -EMSGSIZE;
 +			} else
 +				goto nla_put_failure;
  		}
 -		if (mtype_do_list(skb, map, id, set->dsize))
 +		if (mtype_do_list(skb, map, id))
  			goto nla_put_failure;
++<<<<<<< HEAD
 +		if (SET_WITH_TIMEOUT(set)) {
 +#ifdef IP_SET_BITMAP_STORED_TIMEOUT
 +			if (nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
 +					  htonl(ip_set_timeout_stored(map, id,
 +							ext_timeout(x, map)))))
 +				goto nla_put_failure;
 +#else
 +			if (nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
 +					  htonl(ip_set_timeout_get(
 +							ext_timeout(x, map)))))
 +				goto nla_put_failure;
 +#endif
 +		}
 +		if (SET_WITH_COUNTER(set) &&
 +		    ip_set_put_counter(skb, ext_counter(x, map)))
++=======
+ 		if (ip_set_put_extensions(skb, set, x, mtype_is_filled(x)))
++>>>>>>> 68ad546aefdd (netfilter: Remove unnecessary cast on void pointer)
  			goto nla_put_failure;
  		ipset_nest_end(skb, nested);
  	}
diff --cc net/netfilter/ipset/ip_set_core.c
index 1b9673fde81c,c637710d861c..000000000000
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@@ -1813,7 -1915,7 +1813,11 @@@ ip_set_sockfn_get(struct sock *sk, int 
  		ret = -EFAULT;
  		goto done;
  	}
++<<<<<<< HEAD
 +	op = (unsigned int *) data;
++=======
+ 	op = data;
++>>>>>>> 68ad546aefdd (netfilter: Remove unnecessary cast on void pointer)
  
  	if (*op < IP_SET_OP_VERSION) {
  		/* Check the version at the beginning of operations */
diff --cc net/netfilter/xt_hashlimit.c
index 91945c2ac9d2,762e1874f28b..000000000000
--- a/net/netfilter/xt_hashlimit.c
+++ b/net/netfilter/xt_hashlimit.c
@@@ -114,6 -115,30 +114,33 @@@ struct xt_hashlimit_htable 
  	struct hlist_head hash[0];	/* hashtable itself */
  };
  
++<<<<<<< HEAD
++=======
+ static int
+ cfg_copy(struct hashlimit_cfg2 *to, void *from, int revision)
+ {
+ 	if (revision == 1) {
+ 		struct hashlimit_cfg1 *cfg = from;
+ 
+ 		to->mode = cfg->mode;
+ 		to->avg = cfg->avg;
+ 		to->burst = cfg->burst;
+ 		to->size = cfg->size;
+ 		to->max = cfg->max;
+ 		to->gc_interval = cfg->gc_interval;
+ 		to->expire = cfg->expire;
+ 		to->srcmask = cfg->srcmask;
+ 		to->dstmask = cfg->dstmask;
+ 	} else if (revision == 2) {
+ 		memcpy(to, from, sizeof(struct hashlimit_cfg2));
+ 	} else {
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 68ad546aefdd (netfilter: Remove unnecessary cast on void pointer)
  static DEFINE_MUTEX(hashlimit_mutex);	/* protects htables list */
  static struct kmem_cache *hashlimit_cachep __read_mostly;
  
@@@ -817,10 -944,51 +844,43 @@@ static int dl_seq_real_show(struct dsth
  #endif
  	default:
  		BUG();
 +		res = 0;
  	}
 -}
 -
 -static int dl_seq_real_show_v1(struct dsthash_ent *ent, u_int8_t family,
 -			       struct seq_file *s)
 -{
 -	const struct xt_hashlimit_htable *ht = s->private;
 -
 -	spin_lock(&ent->lock);
 -	/* recalculate to show accurate numbers */
 -	rateinfo_recalc(ent, jiffies, ht->cfg.mode, 1);
 -
 -	dl_seq_print(ent, family, s);
 -
  	spin_unlock(&ent->lock);
++<<<<<<< HEAD
 +	return res;
++=======
+ 	return seq_has_overflowed(s);
+ }
+ 
+ static int dl_seq_real_show(struct dsthash_ent *ent, u_int8_t family,
+ 			    struct seq_file *s)
+ {
+ 	const struct xt_hashlimit_htable *ht = s->private;
+ 
+ 	spin_lock(&ent->lock);
+ 	/* recalculate to show accurate numbers */
+ 	rateinfo_recalc(ent, jiffies, ht->cfg.mode, 2);
+ 
+ 	dl_seq_print(ent, family, s);
+ 
+ 	spin_unlock(&ent->lock);
+ 	return seq_has_overflowed(s);
+ }
+ 
+ static int dl_seq_show_v1(struct seq_file *s, void *v)
+ {
+ 	struct xt_hashlimit_htable *htable = s->private;
+ 	unsigned int *bucket = v;
+ 	struct dsthash_ent *ent;
+ 
+ 	if (!hlist_empty(&htable->hash[*bucket])) {
+ 		hlist_for_each_entry(ent, &htable->hash[*bucket], node)
+ 			if (dl_seq_real_show_v1(ent, htable->family, s))
+ 				return -1;
+ 	}
+ 	return 0;
++>>>>>>> 68ad546aefdd (netfilter: Remove unnecessary cast on void pointer)
  }
  
  static int dl_seq_show(struct seq_file *s, void *v)
* Unmerged path net/netfilter/nft_set_hash.c
diff --git a/net/bridge/netfilter/ebtables.c b/net/bridge/netfilter/ebtables.c
index 71f90ec4f774..09840d5e32e3 100644
--- a/net/bridge/netfilter/ebtables.c
+++ b/net/bridge/netfilter/ebtables.c
@@ -1702,7 +1702,7 @@ static int compat_copy_entry_to_user(struct ebt_entry *e, void __user **dstptr,
 	if (*size < sizeof(*ce))
 		return -EINVAL;
 
-	ce = (struct ebt_entry __user *)*dstptr;
+	ce = *dstptr;
 	if (copy_to_user(ce, e, sizeof(*ce)))
 		return -EFAULT;
 
* Unmerged path net/ipv4/netfilter/arp_tables.c
* Unmerged path net/ipv4/netfilter/ip_tables.c
* Unmerged path net/ipv6/netfilter/ip6_tables.c
* Unmerged path net/netfilter/ipset/ip_set_bitmap_gen.h
* Unmerged path net/netfilter/ipset/ip_set_core.c
diff --git a/net/netfilter/nf_conntrack_proto.c b/net/netfilter/nf_conntrack_proto.c
index d69e2d12b0c3..67d04ac9a59a 100644
--- a/net/netfilter/nf_conntrack_proto.c
+++ b/net/netfilter/nf_conntrack_proto.c
@@ -160,7 +160,7 @@ static int kill_l3proto(struct nf_conn *i, void *data)
 static int kill_l4proto(struct nf_conn *i, void *data)
 {
 	struct nf_conntrack_l4proto *l4proto;
-	l4proto = (struct nf_conntrack_l4proto *)data;
+	l4proto = data;
 	return nf_ct_protonum(i) == l4proto->l4proto &&
 	       nf_ct_l3num(i) == l4proto->l3proto;
 }
* Unmerged path net/netfilter/nft_set_hash.c
* Unmerged path net/netfilter/xt_hashlimit.c
