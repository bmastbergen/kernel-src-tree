ALSA: hda - Fix yet remaining issue with vmaster 0dB initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit d6c0615f510bc1ee26cfb2b9a3343ac99b9c46fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d6c0615f.failed

The previous fix for addressing the breakage in vmaster slave
initialization, commit a91d66129fb9 ("ALSA: hda - Fix incorrect TLV
callback check introduced during set_fs() removal"), introduced a new
helper to process over each slave kctl.  However, this helper passes
only the original kctl, not the virtual slave kctl.  As a result,
HD-audio driver (which is the only user so far) couldn't initialize
the slave correctly because it's trying to update the value directly
with the original kctl, not with the mapped kctl.

This patch fixes the situation again by passing both the mapped slaved
and original slave kctls to the function.  Luckily there is a single
caller as of now, so changing the call signature is no big matter.

Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=197959
Fixes: a91d66129fb9 ("ALSA: hda - Fix incorrect TLV callback check introduced during set_fs() removal")
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit d6c0615f510bc1ee26cfb2b9a3343ac99b9c46fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/control.h
#	sound/core/vmaster.c
#	sound/pci/hda/hda_codec.c
diff --cc include/sound/control.h
index 21d047f229a1,ca13a44ae9d4..000000000000
--- a/include/sound/control.h
+++ b/include/sound/control.h
@@@ -247,6 -248,11 +247,14 @@@ int snd_ctl_add_vmaster_hook(struct snd
  			     void *private_data);
  void snd_ctl_sync_vmaster(struct snd_kcontrol *kctl, bool hook_only);
  #define snd_ctl_sync_vmaster_hook(kctl)	snd_ctl_sync_vmaster(kctl, true)
++<<<<<<< HEAD
++=======
+ int snd_ctl_apply_vmaster_slaves(struct snd_kcontrol *kctl,
+ 				 int (*func)(struct snd_kcontrol *vslave,
+ 					     struct snd_kcontrol *slave,
+ 					     void *arg),
+ 				 void *arg);
++>>>>>>> d6c0615f510b (ALSA: hda - Fix yet remaining issue with vmaster 0dB initialization)
  
  /*
   * Helper functions for jack-detection controls
diff --cc sound/core/vmaster.c
index 6c58e6f73a01,8632301489fa..000000000000
--- a/sound/core/vmaster.c
+++ b/sound/core/vmaster.c
@@@ -484,3 -484,36 +484,39 @@@ void snd_ctl_sync_vmaster(struct snd_kc
  		master->hook(master->hook_private_data, master->val);
  }
  EXPORT_SYMBOL_GPL(snd_ctl_sync_vmaster);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * snd_ctl_apply_vmaster_slaves - Apply function to each vmaster slave
+  * @kctl: vmaster kctl element
+  * @func: function to apply
+  * @arg: optional function argument
+  *
+  * Apply the function @func to each slave kctl of the given vmaster kctl.
+  * Returns 0 if successful, or a negative error code.
+  */
+ int snd_ctl_apply_vmaster_slaves(struct snd_kcontrol *kctl,
+ 				 int (*func)(struct snd_kcontrol *vslave,
+ 					     struct snd_kcontrol *slave,
+ 					     void *arg),
+ 				 void *arg)
+ {
+ 	struct link_master *master;
+ 	struct link_slave *slave;
+ 	int err;
+ 
+ 	master = snd_kcontrol_chip(kctl);
+ 	err = master_init(master);
+ 	if (err < 0)
+ 		return err;
+ 	list_for_each_entry(slave, &master->slaves, list) {
+ 		err = func(slave->kctl, &slave->slave, arg);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(snd_ctl_apply_vmaster_slaves);
++>>>>>>> d6c0615f510b (ALSA: hda - Fix yet remaining issue with vmaster 0dB initialization)
diff --cc sound/pci/hda/hda_codec.c
index bb086665c3e0,e018ecbf78a8..000000000000
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@@ -1847,19 -1817,62 +1847,78 @@@ static int put_kctl_with_value(struct s
  	return 0;
  }
  
++<<<<<<< HEAD
 +/* initialize the slave volume with 0dB */
 +static int init_slave_0dB(struct hda_codec *codec,
 +			  void *data, struct snd_kcontrol *slave)
 +{
 +	int offset = get_kctl_0dB_offset(codec, slave, data);
 +	if (offset > 0)
 +		put_kctl_with_value(slave, offset);
 +	return 0;
 +}
 +
 +/* unmute the slave */
 +static int init_slave_unmute(struct hda_codec *codec,
 +			     void *data, struct snd_kcontrol *slave)
++=======
+ struct slave_init_arg {
+ 	struct hda_codec *codec;
+ 	int step;
+ };
+ 
+ /* initialize the slave volume with 0dB via snd_ctl_apply_vmaster_slaves() */
+ static int init_slave_0dB(struct snd_kcontrol *slave,
+ 			  struct snd_kcontrol *kctl,
+ 			  void *_arg)
+ {
+ 	struct slave_init_arg *arg = _arg;
+ 	int _tlv[4];
+ 	const int *tlv = NULL;
+ 	int step;
+ 	int val;
+ 
+ 	if (kctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {
+ 		if (kctl->tlv.c != snd_hda_mixer_amp_tlv) {
+ 			codec_err(arg->codec,
+ 				  "Unexpected TLV callback for slave %s:%d\n",
+ 				  kctl->id.name, kctl->id.index);
+ 			return 0; /* ignore */
+ 		}
+ 		get_ctl_amp_tlv(kctl, _tlv);
+ 		tlv = _tlv;
+ 	} else if (kctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_TLV_READ)
+ 		tlv = kctl->tlv.p;
+ 
+ 	if (!tlv || tlv[0] != SNDRV_CTL_TLVT_DB_SCALE)
+ 		return 0;
+ 
+ 	step = tlv[3];
+ 	step &= ~TLV_DB_SCALE_MUTE;
+ 	if (!step)
+ 		return 0;
+ 	if (arg->step && arg->step != step) {
+ 		codec_err(arg->codec,
+ 			  "Mismatching dB step for vmaster slave (%d!=%d)\n",
+ 			  arg->step, step);
+ 		return 0;
+ 	}
+ 
+ 	arg->step = step;
+ 	val = -tlv[2] / step;
+ 	if (val > 0) {
+ 		put_kctl_with_value(slave, val);
+ 		return val;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /* unmute the slave via snd_ctl_apply_vmaster_slaves() */
+ static int init_slave_unmute(struct snd_kcontrol *slave,
+ 			     struct snd_kcontrol *kctl,
+ 			     void *_arg)
++>>>>>>> d6c0615f510b (ALSA: hda - Fix yet remaining issue with vmaster 0dB initialization)
  {
  	return put_kctl_with_value(slave, 1);
  }
* Unmerged path include/sound/control.h
* Unmerged path sound/core/vmaster.c
* Unmerged path sound/pci/hda/hda_codec.c
