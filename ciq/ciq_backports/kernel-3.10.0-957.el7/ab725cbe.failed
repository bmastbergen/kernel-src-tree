usb: xhci: allow imod-interval to be configurable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [usb] xhci: allow imod-interval to be configurable (Torez Smith) [1540721]
Rebuild_FUZZ: 94.62%
commit-author Adam Wallis <awallis@codeaurora.org>
commit ab725cbec3e83dc29cc00b733bd26063b588fa98
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ab725cbe.failed

The xHCI driver currently has the IMOD set to 160, which
translates to an IMOD interval of 40,000ns (160 * 250)ns

Commit 0cbd4b34cda9 ("xhci: mediatek: support MTK xHCI host controller")
introduced a QUIRK for the MTK platform to adjust this interval to 20,
which translates to an IMOD interval of 5,000ns (20 * 250)ns. This is
due to the fact that the MTK controller IMOD interval is 8 times
as much as defined in xHCI spec.

Instead of adding more quirk bits for additional platforms, this patch
introduces the ability for vendors to set the IMOD_INTERVAL as is
optimal for their platform. By using device_property_read_u32() on
"imod-interval-ns", the IMOD INTERVAL can be specified in nano seconds.
If no interval is specified, the default of 40,000ns (IMOD=160) will be
used.

No bounds checking has been implemented due to the fact that a vendor
may have violated the spec and would need to specify a value outside of
the max 8,000 IRQs/second limit specified in the xHCI spec.

	Tested-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
	Reviewed-by: Rob Herring <robh@kernel.org>
	Signed-off-by: Adam Wallis <awallis@codeaurora.org>
	Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit ab725cbec3e83dc29cc00b733bd26063b588fa98)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/devicetree/bindings/usb/mediatek,mtk-xhci.txt
#	Documentation/devicetree/bindings/usb/usb-xhci.txt
#	drivers/usb/host/xhci-plat.c
diff --cc Documentation/devicetree/bindings/usb/usb-xhci.txt
index a603bca6d729,e2ea59bbca93..000000000000
--- a/Documentation/devicetree/bindings/usb/usb-xhci.txt
+++ b/Documentation/devicetree/bindings/usb/usb-xhci.txt
@@@ -10,7 -28,10 +10,12 @@@ Required properties
  
  Optional properties:
    - clocks: reference to a clock
 -  - usb2-lpm-disable: indicate if we don't want to enable USB2 HW LPM
    - usb3-lpm-capable: determines if platform is USB3 LPM capable
++<<<<<<< HEAD
++=======
+   - quirk-broken-port-ped: set if the controller has broken port disable mechanism
+   - imod-interval-ns: default interrupt moderation interval is 5000ns
++>>>>>>> ab725cbec3e8 (usb: xhci: allow imod-interval to be configurable)
  
  Example:
  	usb@f0931000 {
diff --cc drivers/usb/host/xhci-plat.c
index 6a4cb93efaf5,6f038306c14d..000000000000
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@@ -114,22 -257,24 +114,31 @@@ static int xhci_plat_probe(struct platf
  			dev_name(&pdev->dev), hcd);
  	if (!xhci->shared_hcd) {
  		ret = -ENOMEM;
 -		goto disable_clk;
 +		goto dealloc_usb2_hcd;
  	}
  
 -	if (device_property_read_bool(sysdev, "usb2-lpm-disable"))
 -		xhci->quirks |= XHCI_HW_LPM_DISABLE;
 -
 -	if (device_property_read_bool(sysdev, "usb3-lpm-capable"))
 +	if ((node && of_property_read_bool(node, "usb3-lpm-capable")) ||
 +			(pdata && pdata->usb3_lpm_capable))
  		xhci->quirks |= XHCI_LPM_SUPPORT;
 +	/*
 +	 * Set the xHCI pointer before xhci_plat_setup() (aka hcd_driver.reset)
 +	 * is called by usb_add_hcd().
 +	 */
 +	*((struct xhci_hcd **) xhci->shared_hcd->hcd_priv) = xhci;
  
 -	if (device_property_read_bool(&pdev->dev, "quirk-broken-port-ped"))
 -		xhci->quirks |= XHCI_BROKEN_PORT_PED;
 +	if (HCC_MAX_PSA(xhci->hcc_params) >= 4)
 +		xhci->shared_hcd->can_do_streams = 1;
  
++<<<<<<< HEAD
 +	hcd->usb_phy = devm_usb_get_phy_by_phandle(&pdev->dev, "usb-phy", 0);
++=======
+ 	/* imod_interval is the interrupt moderation value in nanoseconds. */
+ 	xhci->imod_interval = 40000;
+ 	device_property_read_u32(sysdev, "imod-interval-ns",
+ 				 &xhci->imod_interval);
+ 
+ 	hcd->usb_phy = devm_usb_get_phy_by_phandle(sysdev, "usb-phy", 0);
++>>>>>>> ab725cbec3e8 (usb: xhci: allow imod-interval to be configurable)
  	if (IS_ERR(hcd->usb_phy)) {
  		ret = PTR_ERR(hcd->usb_phy);
  		if (ret == -EPROBE_DEFER)
* Unmerged path Documentation/devicetree/bindings/usb/mediatek,mtk-xhci.txt
* Unmerged path Documentation/devicetree/bindings/usb/mediatek,mtk-xhci.txt
* Unmerged path Documentation/devicetree/bindings/usb/usb-xhci.txt
diff --git a/drivers/usb/host/xhci-mtk.c b/drivers/usb/host/xhci-mtk.c
index 19d27ce31fdc..73da596f8d8e 100644
--- a/drivers/usb/host/xhci-mtk.c
+++ b/drivers/usb/host/xhci-mtk.c
@@ -683,6 +683,15 @@ static int xhci_mtk_probe(struct platform_device *pdev)
 
 	xhci = hcd_to_xhci(hcd);
 	xhci->main_hcd = hcd;
+
+	/*
+	 * imod_interval is the interrupt moderation value in nanoseconds.
+	 * The increment interval is 8 times as much as that defined in
+	 * the xHCI spec on MTK's controller.
+	 */
+	xhci->imod_interval = 5000;
+	device_property_read_u32(dev, "imod-interval-ns", &xhci->imod_interval);
+
 	xhci->shared_hcd = usb_create_shared_hcd(driver, dev,
 			dev_name(dev), hcd);
 	if (!xhci->shared_hcd) {
diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 18c60c57b808..d39b4df153fb 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -240,6 +240,9 @@ static int xhci_pci_setup(struct usb_hcd *hcd)
 	if (!xhci->sbrn)
 		pci_read_config_byte(pdev, XHCI_SBRN_OFFSET, &xhci->sbrn);
 
+	/* imod_interval is the interrupt moderation value in nanoseconds. */
+	xhci->imod_interval = 40000;
+
 	retval = xhci_gen_setup(hcd, xhci_pci_quirks);
 	if (retval)
 		return retval;
* Unmerged path drivers/usb/host/xhci-plat.c
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index d1f092581531..a66666f5114c 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -636,11 +636,7 @@ int xhci_run(struct usb_hcd *hcd)
 			"// Set the interrupt modulation register");
 	temp = readl(&xhci->ir_set->irq_control);
 	temp &= ~ER_IRQ_INTERVAL_MASK;
-	/*
-	 * the increment interval is 8 times as much as that defined
-	 * in xHCI spec on MTK's controller
-	 */
-	temp |= (u32) ((xhci->quirks & XHCI_MTK_HOST) ? 20 : 160);
+	temp |= (xhci->imod_interval / 250) & ER_IRQ_INTERVAL_MASK;
 	writel(temp, &xhci->ir_set->irq_control);
 
 	/* Set the HCD state before we enable the irqs */
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index bdd32f37d88c..42f7894a09a2 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1730,6 +1730,8 @@ struct xhci_hcd {
 	u8		max_interrupters;
 	u8		max_ports;
 	u8		isoc_threshold;
+	/* imod_interval in ns (I * 250ns) */
+	u32		imod_interval;
 	int		event_ring_max;
 	/* 4KB min, 128MB max */
 	int		page_size;
