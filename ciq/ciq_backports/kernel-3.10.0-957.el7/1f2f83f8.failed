e1000: call ndo_stop() instead of dev_close() when running offline selftest

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Stefan Assmann <sassmann@kpanic.de>
commit 1f2f83f838489d386ecad9d0c77c3d6ec983102c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1f2f83f8.failed

Calling dev_close() causes IFF_UP to be cleared which will remove the
interfaces routes and some addresses. That's probably not what the user
intended when running the offline selftest. Besides this does not happen
if the interface is brought down before the test, so the current
behaviour is inconsistent.
Instead call the net_device_ops ndo_stop function directly and avoid
touching IFF_UP at all.

	Signed-off-by: Stefan Assmann <sassmann@kpanic.de>
	Tested-by: Aaron Brown <aaron.f.brown@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 1f2f83f838489d386ecad9d0c77c3d6ec983102c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/e1000/e1000.h
diff --cc drivers/net/ethernet/intel/e1000/e1000.h
index 9d0a9f237cc7,d7bdea79e9fa..000000000000
--- a/drivers/net/ethernet/intel/e1000/e1000.h
+++ b/drivers/net/ethernet/intel/e1000/e1000.h
@@@ -358,20 -358,22 +358,40 @@@ extern struct net_device *e1000_get_hw_
  extern char e1000_driver_name[];
  extern const char e1000_driver_version[];
  
++<<<<<<< HEAD
 +extern int e1000_up(struct e1000_adapter *adapter);
 +extern void e1000_down(struct e1000_adapter *adapter);
 +extern void e1000_reinit_locked(struct e1000_adapter *adapter);
 +extern void e1000_reset(struct e1000_adapter *adapter);
 +extern int e1000_set_spd_dplx(struct e1000_adapter *adapter, u32 spd, u8 dplx);
 +extern int e1000_setup_all_rx_resources(struct e1000_adapter *adapter);
 +extern int e1000_setup_all_tx_resources(struct e1000_adapter *adapter);
 +extern void e1000_free_all_rx_resources(struct e1000_adapter *adapter);
 +extern void e1000_free_all_tx_resources(struct e1000_adapter *adapter);
 +extern void e1000_update_stats(struct e1000_adapter *adapter);
 +extern bool e1000_has_link(struct e1000_adapter *adapter);
 +extern void e1000_power_up_phy(struct e1000_adapter *);
 +extern void e1000_set_ethtool_ops(struct net_device *netdev);
 +extern void e1000_check_options(struct e1000_adapter *adapter);
 +extern char *e1000_get_hw_dev_name(struct e1000_hw *hw);
++=======
+ int e1000_open(struct net_device *netdev);
+ int e1000_close(struct net_device *netdev);
+ int e1000_up(struct e1000_adapter *adapter);
+ void e1000_down(struct e1000_adapter *adapter);
+ void e1000_reinit_locked(struct e1000_adapter *adapter);
+ void e1000_reset(struct e1000_adapter *adapter);
+ int e1000_set_spd_dplx(struct e1000_adapter *adapter, u32 spd, u8 dplx);
+ int e1000_setup_all_rx_resources(struct e1000_adapter *adapter);
+ int e1000_setup_all_tx_resources(struct e1000_adapter *adapter);
+ void e1000_free_all_rx_resources(struct e1000_adapter *adapter);
+ void e1000_free_all_tx_resources(struct e1000_adapter *adapter);
+ void e1000_update_stats(struct e1000_adapter *adapter);
+ bool e1000_has_link(struct e1000_adapter *adapter);
+ void e1000_power_up_phy(struct e1000_adapter *);
+ void e1000_set_ethtool_ops(struct net_device *netdev);
+ void e1000_check_options(struct e1000_adapter *adapter);
+ char *e1000_get_hw_dev_name(struct e1000_hw *hw);
++>>>>>>> 1f2f83f83848 (e1000: call ndo_stop() instead of dev_close() when running offline selftest)
  
  #endif /* _E1000_H_ */
* Unmerged path drivers/net/ethernet/intel/e1000/e1000.h
diff --git a/drivers/net/ethernet/intel/e1000/e1000_ethtool.c b/drivers/net/ethernet/intel/e1000/e1000_ethtool.c
index 075ec79f50fa..44bf93d7271d 100644
--- a/drivers/net/ethernet/intel/e1000/e1000_ethtool.c
+++ b/drivers/net/ethernet/intel/e1000/e1000_ethtool.c
@@ -1553,7 +1553,7 @@ static void e1000_diag_test(struct net_device *netdev,
 
 		if (if_running)
 			/* indicate we're in test mode */
-			dev_close(netdev);
+			e1000_close(netdev);
 		else
 			e1000_reset(adapter);
 
@@ -1582,7 +1582,7 @@ static void e1000_diag_test(struct net_device *netdev,
 		e1000_reset(adapter);
 		clear_bit(__E1000_TESTING, &adapter->flags);
 		if (if_running)
-			dev_open(netdev);
+			e1000_open(netdev);
 	} else {
 		e_info(hw, "online testing starting\n");
 		/* Online tests */
diff --git a/drivers/net/ethernet/intel/e1000/e1000_main.c b/drivers/net/ethernet/intel/e1000/e1000_main.c
index b54dc27f72d4..0838d1847941 100644
--- a/drivers/net/ethernet/intel/e1000/e1000_main.c
+++ b/drivers/net/ethernet/intel/e1000/e1000_main.c
@@ -114,8 +114,8 @@ static int e1000_probe(struct pci_dev *pdev, const struct pci_device_id *ent);
 static void e1000_remove(struct pci_dev *pdev);
 static int e1000_alloc_queues(struct e1000_adapter *adapter);
 static int e1000_sw_init(struct e1000_adapter *adapter);
-static int e1000_open(struct net_device *netdev);
-static int e1000_close(struct net_device *netdev);
+int e1000_open(struct net_device *netdev);
+int e1000_close(struct net_device *netdev);
 static void e1000_configure_tx(struct e1000_adapter *adapter);
 static void e1000_configure_rx(struct e1000_adapter *adapter);
 static void e1000_setup_rctl(struct e1000_adapter *adapter);
@@ -1365,7 +1365,7 @@ static int e1000_alloc_queues(struct e1000_adapter *adapter)
  * handler is registered with the OS, the watchdog task is started,
  * and the stack is notified that the interface is ready.
  **/
-static int e1000_open(struct net_device *netdev)
+int e1000_open(struct net_device *netdev)
 {
 	struct e1000_adapter *adapter = netdev_priv(netdev);
 	struct e1000_hw *hw = &adapter->hw;
@@ -1442,7 +1442,7 @@ err_setup_tx:
  * needs to be disabled.  A global MAC reset is issued to stop the
  * hardware, and all transmit and receive resources are freed.
  **/
-static int e1000_close(struct net_device *netdev)
+int e1000_close(struct net_device *netdev)
 {
 	struct e1000_adapter *adapter = netdev_priv(netdev);
 	struct e1000_hw *hw = &adapter->hw;
