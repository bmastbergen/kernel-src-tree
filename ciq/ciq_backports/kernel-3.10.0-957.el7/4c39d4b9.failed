usb: xhci: use bus->sysdev for DMA configuration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [usb] xhci: use bus->sysdev for DMA configuration (Torez Smith) [1540721]
Rebuild_FUZZ: 94.51%
commit-author Arnd Bergmann <arnd@arndb.de>
commit 4c39d4b949d36faffbc726525b469886cf311d1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4c39d4b9.failed

For xhci-hcd platform device, all the DMA parameters are not
configured properly, notably dma ops for dwc3 devices. So, set
the dma for xhci from sysdev. sysdev is pointing to device that
is known to the system firmware or hardware.

	Cc: Baolin Wang <baolin.wang@linaro.org>

	Tested-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
	Tested-by: Vivek Gautam <vivek.gautam@codeaurora.org>
	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
	Signed-off-by: Sriram Dash <sriram.dash@nxp.com>
	Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
	Signed-off-by: Peter Chen <peter.chen@nxp.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 4c39d4b949d36faffbc726525b469886cf311d1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/host/xhci-plat.c
diff --cc drivers/usb/host/xhci-plat.c
index 6a4cb93efaf5,fa97826d0058..000000000000
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@@ -45,11 -83,73 +46,12 @@@ static int xhci_plat_start(struct usb_h
  	return xhci_run(hcd);
  }
  
 -#ifdef CONFIG_OF
 -static const struct xhci_plat_priv xhci_plat_marvell_armada = {
 -	.init_quirk = xhci_mvebu_mbus_init_quirk,
 -};
 -
 -static const struct xhci_plat_priv xhci_plat_renesas_rcar_gen2 = {
 -	.firmware_name = XHCI_RCAR_FIRMWARE_NAME_V1,
 -	.init_quirk = xhci_rcar_init_quirk,
 -	.plat_start = xhci_rcar_start,
 -};
 -
 -static const struct xhci_plat_priv xhci_plat_renesas_rcar_gen3 = {
 -	.firmware_name = XHCI_RCAR_FIRMWARE_NAME_V2,
 -	.init_quirk = xhci_rcar_init_quirk,
 -	.plat_start = xhci_rcar_start,
 -};
 -
 -static const struct xhci_plat_priv xhci_plat_renesas_rcar_r8a7796 = {
 -	.firmware_name = XHCI_RCAR_FIRMWARE_NAME_V3,
 -	.init_quirk = xhci_rcar_init_quirk,
 -	.plat_start = xhci_rcar_start,
 -};
 -
 -static const struct of_device_id usb_xhci_of_match[] = {
 -	{
 -		.compatible = "generic-xhci",
 -	}, {
 -		.compatible = "xhci-platform",
 -	}, {
 -		.compatible = "marvell,armada-375-xhci",
 -		.data = &xhci_plat_marvell_armada,
 -	}, {
 -		.compatible = "marvell,armada-380-xhci",
 -		.data = &xhci_plat_marvell_armada,
 -	}, {
 -		.compatible = "renesas,xhci-r8a7790",
 -		.data = &xhci_plat_renesas_rcar_gen2,
 -	}, {
 -		.compatible = "renesas,xhci-r8a7791",
 -		.data = &xhci_plat_renesas_rcar_gen2,
 -	}, {
 -		.compatible = "renesas,xhci-r8a7793",
 -		.data = &xhci_plat_renesas_rcar_gen2,
 -	}, {
 -		.compatible = "renesas,xhci-r8a7795",
 -		.data = &xhci_plat_renesas_rcar_gen3,
 -	}, {
 -		.compatible = "renesas,xhci-r8a7796",
 -		.data = &xhci_plat_renesas_rcar_r8a7796,
 -	}, {
 -		.compatible = "renesas,rcar-gen2-xhci",
 -		.data = &xhci_plat_renesas_rcar_gen2,
 -	}, {
 -		.compatible = "renesas,rcar-gen3-xhci",
 -		.data = &xhci_plat_renesas_rcar_gen3,
 -	},
 -	{},
 -};
 -MODULE_DEVICE_TABLE(of, usb_xhci_of_match);
 -#endif
 -
  static int xhci_plat_probe(struct platform_device *pdev)
  {
 -	const struct of_device_id *match;
 +	struct device_node	*node = pdev->dev.of_node;
 +	struct usb_xhci_pdata	*pdata = dev_get_platdata(&pdev->dev);
  	const struct hc_driver	*driver;
+ 	struct device		*sysdev;
  	struct xhci_hcd		*xhci;
  	struct resource         *res;
  	struct usb_hcd		*hcd;
@@@ -66,17 -166,39 +68,51 @@@
  	if (irq < 0)
  		return -ENODEV;
  
++<<<<<<< HEAD
 +
 +	/* Initialize dma_mask and coherent_dma_mask to 32-bits */
 +	ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
 +	if (ret)
 +		return ret;
 +	if (!pdev->dev.dma_mask)
 +		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
 +	else
 +		dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
++=======
+ 	/*
+ 	 * sysdev must point to a device that is known to the system firmware
+ 	 * or PCI hardware. We handle these three cases here:
+ 	 * 1. xhci_plat comes from firmware
+ 	 * 2. xhci_plat is child of a device from firmware (dwc3-plat)
+ 	 * 3. xhci_plat is grandchild of a pci device (dwc3-pci)
+ 	 */
+ 	sysdev = &pdev->dev;
+ 	if (sysdev->parent && !sysdev->of_node && sysdev->parent->of_node)
+ 		sysdev = sysdev->parent;
+ #ifdef CONFIG_PCI
+ 	else if (sysdev->parent && sysdev->parent->parent &&
+ 		 sysdev->parent->parent->bus == &pci_bus_type)
+ 		sysdev = sysdev->parent->parent;
+ #endif
+ 
+ 	/* Try to set 64-bit DMA first */
+ 	if (WARN_ON(!sysdev->dma_mask))
+ 		/* Platform did not initialize dma_mask */
+ 		ret = dma_coerce_mask_and_coherent(sysdev,
+ 						   DMA_BIT_MASK(64));
+ 	else
+ 		ret = dma_set_mask_and_coherent(sysdev, DMA_BIT_MASK(64));
+ 
+ 	/* If seting 64-bit DMA mask fails, fall back to 32-bit DMA mask */
+ 	if (ret) {
+ 		ret = dma_set_mask_and_coherent(sysdev, DMA_BIT_MASK(32));
+ 		if (ret)
+ 			return ret;
+ 	}
++>>>>>>> 4c39d4b949d3 (usb: xhci: use bus->sysdev for DMA configuration)
  
- 	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
+ 	hcd = __usb_create_hcd(driver, sysdev, &pdev->dev,
+ 			       dev_name(&pdev->dev), NULL);
  	if (!hcd)
  		return -ENOMEM;
  
@@@ -99,37 -221,40 +135,46 @@@
  		ret = clk_prepare_enable(clk);
  		if (ret)
  			goto put_hcd;
 -	} else if (PTR_ERR(clk) == -EPROBE_DEFER) {
 -		ret = -EPROBE_DEFER;
 -		goto put_hcd;
  	}
  
 -	xhci = hcd_to_xhci(hcd);
 -	match = of_match_node(usb_xhci_of_match, pdev->dev.of_node);
 -	if (match) {
 -		const struct xhci_plat_priv *priv_match = match->data;
 -		struct xhci_plat_priv *priv = hcd_to_xhci_priv(hcd);
 -
 -		/* Just copy data for now */
 -		if (priv_match)
 -			*priv = *priv_match;
 -	}
 +	ret = usb_add_hcd(hcd, irq, IRQF_SHARED);
 +	if (ret)
 +		goto disable_clk;
  
 -	device_wakeup_enable(hcd->self.controller);
  
 +	/* USB 2.0 roothub is stored in the platform_device now. */
 +	hcd = dev_get_drvdata(&pdev->dev);
 +	xhci = hcd_to_xhci(hcd);
  	xhci->clk = clk;
++<<<<<<< HEAD
 +	xhci->shared_hcd = usb_create_shared_hcd(driver, &pdev->dev,
++=======
+ 	xhci->main_hcd = hcd;
+ 	xhci->shared_hcd = __usb_create_hcd(driver, sysdev, &pdev->dev,
++>>>>>>> 4c39d4b949d3 (usb: xhci: use bus->sysdev for DMA configuration)
  			dev_name(&pdev->dev), hcd);
  	if (!xhci->shared_hcd) {
  		ret = -ENOMEM;
 -		goto disable_clk;
 +		goto dealloc_usb2_hcd;
  	}
  
++<<<<<<< HEAD
 +	if ((node && of_property_read_bool(node, "usb3-lpm-capable")) ||
 +			(pdata && pdata->usb3_lpm_capable))
++=======
+ 	if (device_property_read_bool(sysdev, "usb3-lpm-capable"))
++>>>>>>> 4c39d4b949d3 (usb: xhci: use bus->sysdev for DMA configuration)
  		xhci->quirks |= XHCI_LPM_SUPPORT;
 +	/*
 +	 * Set the xHCI pointer before xhci_plat_setup() (aka hcd_driver.reset)
 +	 * is called by usb_add_hcd().
 +	 */
 +	*((struct xhci_hcd **) xhci->shared_hcd->hcd_priv) = xhci;
  
 -	if (device_property_read_bool(&pdev->dev, "quirk-broken-port-ped"))
 -		xhci->quirks |= XHCI_BROKEN_PORT_PED;
 +	if (HCC_MAX_PSA(xhci->hcc_params) >= 4)
 +		xhci->shared_hcd->can_do_streams = 1;
  
- 	hcd->usb_phy = devm_usb_get_phy_by_phandle(&pdev->dev, "usb-phy", 0);
+ 	hcd->usb_phy = devm_usb_get_phy_by_phandle(sysdev, "usb-phy", 0);
  	if (IS_ERR(hcd->usb_phy)) {
  		ret = PTR_ERR(hcd->usb_phy);
  		if (ret == -EPROBE_DEFER)
diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index ba1853f4e407..032a7020a6b0 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -586,7 +586,7 @@ static void xhci_free_stream_ctx(struct xhci_hcd *xhci,
 		unsigned int num_stream_ctxs,
 		struct xhci_stream_ctx *stream_ctx, dma_addr_t dma)
 {
-	struct device *dev = xhci_to_hcd(xhci)->self.controller;
+	struct device *dev = xhci_to_hcd(xhci)->self.sysdev;
 	size_t size = sizeof(struct xhci_stream_ctx) * num_stream_ctxs;
 
 	if (size > MEDIUM_STREAM_ARRAY_SIZE)
@@ -614,7 +614,7 @@ static struct xhci_stream_ctx *xhci_alloc_stream_ctx(struct xhci_hcd *xhci,
 		unsigned int num_stream_ctxs, dma_addr_t *dma,
 		gfp_t mem_flags)
 {
-	struct device *dev = xhci_to_hcd(xhci)->self.controller;
+	struct device *dev = xhci_to_hcd(xhci)->self.sysdev;
 	size_t size = sizeof(struct xhci_stream_ctx) * num_stream_ctxs;
 
 	if (size > MEDIUM_STREAM_ARRAY_SIZE)
@@ -1686,7 +1686,7 @@ void xhci_slot_copy(struct xhci_hcd *xhci,
 static int scratchpad_alloc(struct xhci_hcd *xhci, gfp_t flags)
 {
 	int i;
-	struct device *dev = xhci_to_hcd(xhci)->self.controller;
+	struct device *dev = xhci_to_hcd(xhci)->self.sysdev;
 	int num_sp = HCS_MAX_SCRATCHPAD(xhci->hcs_params2);
 
 	xhci_dbg_trace(xhci, trace_xhci_dbg_init,
@@ -1758,7 +1758,7 @@ static void scratchpad_free(struct xhci_hcd *xhci)
 {
 	int num_sp;
 	int i;
-	struct device *dev = xhci_to_hcd(xhci)->self.controller;
+	struct device *dev = xhci_to_hcd(xhci)->self.sysdev;
 
 	if (!xhci->scratchpad)
 		return;
@@ -1831,7 +1831,7 @@ void xhci_free_command(struct xhci_hcd *xhci,
 
 void xhci_mem_cleanup(struct xhci_hcd *xhci)
 {
-	struct device	*dev = xhci_to_hcd(xhci)->self.controller;
+	struct device	*dev = xhci_to_hcd(xhci)->self.sysdev;
 	int size;
 	int i, j, num_ports;
 
@@ -2373,7 +2373,7 @@ static int xhci_setup_port_arrays(struct xhci_hcd *xhci, gfp_t flags)
 int xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags)
 {
 	dma_addr_t	dma;
-	struct device	*dev = xhci_to_hcd(xhci)->self.controller;
+	struct device	*dev = xhci_to_hcd(xhci)->self.sysdev;
 	unsigned int	val, val2;
 	u64		val_64;
 	struct xhci_segment	*seg;
* Unmerged path drivers/usb/host/xhci-plat.c
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index c81fab8c4000..6ab048ce6a02 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -240,6 +240,9 @@ static int xhci_free_msi(struct xhci_hcd *xhci)
 static int xhci_setup_msi(struct xhci_hcd *xhci)
 {
 	int ret;
+	/*
+	 * TODO:Check with MSI Soc for sysdev
+	 */
 	struct pci_dev  *pdev = to_pci_dev(xhci_to_hcd(xhci)->self.controller);
 
 	ret = pci_enable_msi(pdev);
@@ -266,7 +269,7 @@ static int xhci_setup_msi(struct xhci_hcd *xhci)
  */
 static void xhci_free_irq(struct xhci_hcd *xhci)
 {
-	struct pci_dev *pdev = to_pci_dev(xhci_to_hcd(xhci)->self.controller);
+	struct pci_dev *pdev = to_pci_dev(xhci_to_hcd(xhci)->self.sysdev);
 	int ret;
 
 	/* return if using legacy interrupt */
@@ -753,7 +756,7 @@ void xhci_shutdown(struct usb_hcd *hcd)
 	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
 
 	if (xhci->quirks & XHCI_SPURIOUS_REBOOT)
-		usb_disable_xhci_ports(to_pci_dev(hcd->self.controller));
+		usb_disable_xhci_ports(to_pci_dev(hcd->self.sysdev));
 
 	spin_lock_irq(&xhci->lock);
 	xhci_halt(xhci);
@@ -770,7 +773,7 @@ void xhci_shutdown(struct usb_hcd *hcd)
 
 	/* Yet another workaround for spurious wakeups at shutdown with HSW */
 	if (xhci->quirks & XHCI_SPURIOUS_WAKEUP)
-		pci_set_power_state(to_pci_dev(hcd->self.controller), PCI_D3hot);
+		pci_set_power_state(to_pci_dev(hcd->self.sysdev), PCI_D3hot);
 }
 
 #ifdef CONFIG_PM
@@ -4816,7 +4819,11 @@ int xhci_get_frame(struct usb_hcd *hcd)
 int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks)
 {
 	struct xhci_hcd		*xhci;
-	struct device		*dev = hcd->self.controller;
+	/*
+	 * TODO: Check with DWC3 clients for sysdev according to
+	 * quirks
+	 */
+	struct device		*dev = hcd->self.sysdev;
 	int			retval;
 
 	/* Accept arbitrarily long scatter-gather lists */
