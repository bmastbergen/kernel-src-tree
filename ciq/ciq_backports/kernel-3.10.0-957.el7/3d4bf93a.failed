tcp: detect malicious patterns in tcp_collapse_ofo_queue()

jira LE-1907
cve CVE-2018-5390
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 3d4bf93ac12003f9b8e1e2de37fe27983deebdcf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3d4bf93a.failed

In case an attacker feeds tiny packets completely out of order,
tcp_collapse_ofo_queue() might scan the whole rb-tree, performing
expensive copies, but not changing socket memory usage at all.

1) Do not attempt to collapse tiny skbs.
2) Add logic to exit early when too many tiny skbs are detected.

We prefer not doing aggressive collapsing (which copies packets)
for pathological flows, and revert to tcp_prune_ofo_queue() which
will be less expensive.

In the future, we might add the possibility of terminating flows
that are proven to be malicious.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Acked-by: Soheil Hassas Yeganeh <soheil@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3d4bf93ac12003f9b8e1e2de37fe27983deebdcf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_input.c
diff --cc net/ipv4/tcp_input.c
index f78fd9207b7a,78068b902e7b..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -4707,43 -4902,47 +4707,70 @@@ restart
  static void tcp_collapse_ofo_queue(struct sock *sk)
  {
  	struct tcp_sock *tp = tcp_sk(sk);
++<<<<<<< HEAD
 +	struct sk_buff *skb = skb_peek(&tp->out_of_order_queue);
 +	struct sk_buff *head;
++=======
+ 	u32 range_truesize, sum_tiny = 0;
+ 	struct sk_buff *skb, *head;
++>>>>>>> 3d4bf93ac120 (tcp: detect malicious patterns in tcp_collapse_ofo_queue())
  	u32 start, end;
  
 -	skb = skb_rb_first(&tp->out_of_order_queue);
 -new_range:
 -	if (!skb) {
 -		tp->ooo_last_skb = skb_rb_last(&tp->out_of_order_queue);
 +	if (skb == NULL)
  		return;
 -	}
 +
  	start = TCP_SKB_CB(skb)->seq;
  	end = TCP_SKB_CB(skb)->end_seq;
++<<<<<<< HEAD
 +	head = skb;
++=======
+ 	range_truesize = skb->truesize;
++>>>>>>> 3d4bf93ac120 (tcp: detect malicious patterns in tcp_collapse_ofo_queue())
  
 -	for (head = skb;;) {
 -		skb = skb_rb_next(skb);
 +	for (;;) {
 +		struct sk_buff *next = NULL;
  
 -		/* Range is terminated when we see a gap or when
 -		 * we are at the queue end.
 -		 */
 +		if (!skb_queue_is_last(&tp->out_of_order_queue, skb))
 +			next = skb_queue_next(&tp->out_of_order_queue, skb);
 +		skb = next;
 +
 +		/* Segment is terminated when we see gap or when
 +		 * we are at the end of all the queue. */
  		if (!skb ||
  		    after(TCP_SKB_CB(skb)->seq, end) ||
  		    before(TCP_SKB_CB(skb)->end_seq, start)) {
++<<<<<<< HEAD
 +			tcp_collapse(sk, &tp->out_of_order_queue,
 +				     head, skb, start, end);
 +			head = skb;
 +			if (!skb)
 +				break;
 +			/* Start new segment */
++=======
+ 			/* Do not attempt collapsing tiny skbs */
+ 			if (range_truesize != head->truesize ||
+ 			    end - start >= SKB_WITH_OVERHEAD(SK_MEM_QUANTUM)) {
+ 				tcp_collapse(sk, NULL, &tp->out_of_order_queue,
+ 					     head, skb, start, end);
+ 			} else {
+ 				sum_tiny += range_truesize;
+ 				if (sum_tiny > sk->sk_rcvbuf >> 3)
+ 					return;
+ 			}
+ 			goto new_range;
+ 		}
+ 
+ 		range_truesize += skb->truesize;
+ 		if (unlikely(before(TCP_SKB_CB(skb)->seq, start)))
++>>>>>>> 3d4bf93ac120 (tcp: detect malicious patterns in tcp_collapse_ofo_queue())
  			start = TCP_SKB_CB(skb)->seq;
 -		if (after(TCP_SKB_CB(skb)->end_seq, end))
  			end = TCP_SKB_CB(skb)->end_seq;
 +		} else {
 +			if (before(TCP_SKB_CB(skb)->seq, start))
 +				start = TCP_SKB_CB(skb)->seq;
 +			if (after(TCP_SKB_CB(skb)->end_seq, end))
 +				end = TCP_SKB_CB(skb)->end_seq;
 +		}
  	}
  }
  
* Unmerged path net/ipv4/tcp_input.c
