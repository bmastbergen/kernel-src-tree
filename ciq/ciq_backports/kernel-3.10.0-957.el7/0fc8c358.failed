tracing/kprobe: Release kprobe print_fmt properly

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 0fc8c3581dd42bc8f530314ca86db2d861485731
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0fc8c358.failed

We don't release tk->tp.call.print_fmt when destroying
local uprobe. Also there's missing print_fmt kfree in
create_local_trace_kprobe error path.

Link: http://lkml.kernel.org/r/20180709141906.2390-1-jolsa@kernel.org

	Cc: stable@vger.kernel.org
Fixes: e12f03d7031a ("perf/core: Implement the 'perf_kprobe' PMU")
	Acked-by: Song Liu <songliubraving@fb.com>
	Acked-by: Masami Hiramatsu <mhiramat@kernel.org>
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit 0fc8c3581dd42bc8f530314ca86db2d861485731)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace_kprobe.c
diff --cc kernel/trace/trace_kprobe.c
index 0a5b1d7d9b73,21f718472942..000000000000
--- a/kernel/trace/trace_kprobe.c
+++ b/kernel/trace/trace_kprobe.c
@@@ -1447,7 -1445,71 +1447,75 @@@ static int unregister_probe_event(struc
  	return ret;
  }
  
++<<<<<<< HEAD
 +/* Make a debugfs interface for controlling probe points */
++=======
+ #ifdef CONFIG_PERF_EVENTS
+ /* create a trace_kprobe, but don't add it to global lists */
+ struct trace_event_call *
+ create_local_trace_kprobe(char *func, void *addr, unsigned long offs,
+ 			  bool is_return)
+ {
+ 	struct trace_kprobe *tk;
+ 	int ret;
+ 	char *event;
+ 
+ 	/*
+ 	 * local trace_kprobes are not added to probe_list, so they are never
+ 	 * searched in find_trace_kprobe(). Therefore, there is no concern of
+ 	 * duplicated name here.
+ 	 */
+ 	event = func ? func : "DUMMY_EVENT";
+ 
+ 	tk = alloc_trace_kprobe(KPROBE_EVENT_SYSTEM, event, (void *)addr, func,
+ 				offs, 0 /* maxactive */, 0 /* nargs */,
+ 				is_return);
+ 
+ 	if (IS_ERR(tk)) {
+ 		pr_info("Failed to allocate trace_probe.(%d)\n",
+ 			(int)PTR_ERR(tk));
+ 		return ERR_CAST(tk);
+ 	}
+ 
+ 	init_trace_event_call(tk, &tk->tp.call);
+ 
+ 	if (set_print_fmt(&tk->tp, trace_kprobe_is_return(tk)) < 0) {
+ 		ret = -ENOMEM;
+ 		goto error;
+ 	}
+ 
+ 	ret = __register_trace_kprobe(tk);
+ 	if (ret < 0) {
+ 		kfree(tk->tp.call.print_fmt);
+ 		goto error;
+ 	}
+ 
+ 	return &tk->tp.call;
+ error:
+ 	free_trace_kprobe(tk);
+ 	return ERR_PTR(ret);
+ }
+ 
+ void destroy_local_trace_kprobe(struct trace_event_call *event_call)
+ {
+ 	struct trace_kprobe *tk;
+ 
+ 	tk = container_of(event_call, struct trace_kprobe, tp.call);
+ 
+ 	if (trace_probe_is_enabled(&tk->tp)) {
+ 		WARN_ON(1);
+ 		return;
+ 	}
+ 
+ 	__unregister_trace_kprobe(tk);
+ 
+ 	kfree(tk->tp.call.print_fmt);
+ 	free_trace_kprobe(tk);
+ }
+ #endif /* CONFIG_PERF_EVENTS */
+ 
+ /* Make a tracefs interface for controlling probe points */
++>>>>>>> 0fc8c3581dd4 (tracing/kprobe: Release kprobe print_fmt properly)
  static __init int init_kprobe_trace(void)
  {
  	struct dentry *d_tracer;
* Unmerged path kernel/trace/trace_kprobe.c
