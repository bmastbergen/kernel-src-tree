tracing/uprobes: Convert to struct trace_probe

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Namhyung Kim <namhyung.kim@lge.com>
commit 14577c39927f86e3dba967f9b511f4a876b7f8bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/14577c39.failed

Convert struct trace_uprobe to make use of the common trace_probe
structure.

	Reviewed-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
	Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
	Acked-by: Oleg Nesterov <oleg@redhat.com>
	Cc: zhangwei(Jovi) <jovi.zhangwei@huawei.com>
	Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
(cherry picked from commit 14577c39927f86e3dba967f9b511f4a876b7f8bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace_uprobe.c
diff --cc kernel/trace/trace_uprobe.c
index 84f228258d8e,afda3726f288..000000000000
--- a/kernel/trace/trace_uprobe.c
+++ b/kernel/trace/trace_uprobe.c
@@@ -277,6 -123,7 +272,10 @@@ alloc_trace_uprobe(const char *group, c
  	if (is_ret)
  		tu->consumer.ret_handler = uretprobe_dispatcher;
  	init_trace_uprobe_filter(&tu->filter);
++<<<<<<< HEAD
++=======
+ 	tu->tp.call.flags |= TRACE_EVENT_FL_USE_CALL_FILTER;
++>>>>>>> 14577c39927f (tracing/uprobes: Convert to struct trace_probe)
  	return tu;
  
  error:
@@@ -543,7 -392,8 +544,12 @@@ static int create_trace_uprobe(int argc
  		}
  
  		/* Parse fetch argument */
++<<<<<<< HEAD
 +		ret = traceprobe_parse_probe_arg(arg, &tu->size, &tu->args[i], is_return, false);
++=======
+ 		ret = traceprobe_parse_probe_arg(arg, &tu->tp.size, parg,
+ 						 false, false);
++>>>>>>> 14577c39927f (tracing/uprobes: Convert to struct trace_probe)
  		if (ret) {
  			pr_info("Parse error at argument[%d]. (%d)\n", i, ret);
  			goto error;
@@@ -707,10 -557,12 +713,12 @@@ static void uprobe_trace_print(struct t
  		data = DATAOF_TRACE_ENTRY(entry, false);
  	}
  
- 	for (i = 0; i < tu->nr_args; i++)
- 		call_fetch(&tu->args[i].fetch, regs, data + tu->args[i].offset);
+ 	for (i = 0; i < tu->tp.nr_args; i++) {
+ 		call_fetch(&tu->tp.args[i].fetch, regs,
+ 			   data + tu->tp.args[i].offset);
+ 	}
  
 -	if (!call_filter_check_discard(call, entry, buffer, event))
 +	if (!filter_current_check_discard(buffer, call, entry, event))
  		trace_buffer_unlock_commit(buffer, event, 0, 0);
  }
  
@@@ -986,9 -834,7 +990,13 @@@ static void uprobe_perf_print(struct tr
  	int size, rctx, i;
  
  	size = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));
++<<<<<<< HEAD
 +	size = ALIGN(size + tu->size + sizeof(u32), sizeof(u64)) - sizeof(u32);
 +	if (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, "profile buffer not large enough"))
 +		return;
++=======
+ 	size = ALIGN(size + tu->tp.size + sizeof(u32), sizeof(u64)) - sizeof(u32);
++>>>>>>> 14577c39927f (tracing/uprobes: Convert to struct trace_probe)
  
  	preempt_disable();
  	head = this_cpu_ptr(call->perf_events);
@@@ -1077,12 -925,7 +1088,16 @@@ static int uprobe_dispatcher(struct upr
  	tu = container_of(con, struct trace_uprobe, consumer);
  	tu->nhit++;
  
++<<<<<<< HEAD
 +	udd.tu = tu;
 +	udd.bp_addr = instruction_pointer(regs);
 +
 +	current->utask->vaddr = (unsigned long) &udd;
 +
 +	if (tu->flags & TP_FLAG_TRACE)
++=======
+ 	if (tu->tp.flags & TP_FLAG_TRACE)
++>>>>>>> 14577c39927f (tracing/uprobes: Convert to struct trace_probe)
  		ret |= uprobe_trace_func(tu, regs);
  
  #ifdef CONFIG_PERF_EVENTS
@@@ -1100,12 -942,7 +1115,16 @@@ static int uretprobe_dispatcher(struct 
  
  	tu = container_of(con, struct trace_uprobe, consumer);
  
++<<<<<<< HEAD
 +	udd.tu = tu;
 +	udd.bp_addr = func;
 +
 +	current->utask->vaddr = (unsigned long) &udd;
 +
 +	if (tu->flags & TP_FLAG_TRACE)
++=======
+ 	if (tu->tp.flags & TP_FLAG_TRACE)
++>>>>>>> 14577c39927f (tracing/uprobes: Convert to struct trace_probe)
  		uretprobe_trace_func(tu, func, regs);
  
  #ifdef CONFIG_PERF_EVENTS
* Unmerged path kernel/trace/trace_uprobe.c
