ipmr: Send FIB notifications on MFC and VIF entries

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Yotam Gigi <yotamg@mellanox.com>
commit b362053a7cc0fcc09b92642ba5dd1ca7fddc9004
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b362053a.failed

Use the newly introduced notification chain to send events upon VIF and MFC
addition and deletion. The MFC notifications are sent only on resolved MFC
entries, as unresolved cannot be offloaded.

	Signed-off-by: Yotam Gigi <yotamg@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b362053a7cc0fcc09b92642ba5dd1ca7fddc9004)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ipmr.c
diff --cc net/ipv4/ipmr.c
index 2741c7ea1966,ba71bc402336..000000000000
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@@ -536,8 -561,128 +536,87 @@@ failure
  	unregister_netdevice(dev);
  	return NULL;
  }
 -
 -/* called with rcu_read_lock() */
 -static int __pim_rcv(struct mr_table *mrt, struct sk_buff *skb,
 -		     unsigned int pimlen)
 -{
 -	struct net_device *reg_dev = NULL;
 -	struct iphdr *encap;
 -
 -	encap = (struct iphdr *)(skb_transport_header(skb) + pimlen);
 -	/* Check that:
 -	 * a. packet is really sent to a multicast group
 -	 * b. packet is not a NULL-REGISTER
 -	 * c. packet is not truncated
 -	 */
 -	if (!ipv4_is_multicast(encap->daddr) ||
 -	    encap->tot_len == 0 ||
 -	    ntohs(encap->tot_len) + pimlen > skb->len)
 -		return 1;
 -
 -	read_lock(&mrt_lock);
 -	if (mrt->mroute_reg_vif_num >= 0)
 -		reg_dev = mrt->vif_table[mrt->mroute_reg_vif_num].dev;
 -	read_unlock(&mrt_lock);
 -
 -	if (!reg_dev)
 -		return 1;
 -
 -	skb->mac_header = skb->network_header;
 -	skb_pull(skb, (u8 *)encap - skb->data);
 -	skb_reset_network_header(skb);
 -	skb->protocol = htons(ETH_P_IP);
 -	skb->ip_summed = CHECKSUM_NONE;
 -
 -	skb_tunnel_rx(skb, reg_dev, dev_net(reg_dev));
 -
 -	netif_rx(skb);
 -
 -	return NET_RX_SUCCESS;
 -}
 -#else
 -static struct net_device *ipmr_reg_vif(struct net *net, struct mr_table *mrt)
 -{
 -	return NULL;
 -}
  #endif
  
++<<<<<<< HEAD
++=======
+ static int call_ipmr_vif_entry_notifier(struct notifier_block *nb,
+ 					struct net *net,
+ 					enum fib_event_type event_type,
+ 					struct vif_device *vif,
+ 					vifi_t vif_index, u32 tb_id)
+ {
+ 	struct vif_entry_notifier_info info = {
+ 		.info = {
+ 			.family = RTNL_FAMILY_IPMR,
+ 			.net = net,
+ 		},
+ 		.dev = vif->dev,
+ 		.vif_index = vif_index,
+ 		.vif_flags = vif->flags,
+ 		.tb_id = tb_id,
+ 	};
+ 
+ 	return call_fib_notifier(nb, net, event_type, &info.info);
+ }
+ 
+ static int call_ipmr_vif_entry_notifiers(struct net *net,
+ 					 enum fib_event_type event_type,
+ 					 struct vif_device *vif,
+ 					 vifi_t vif_index, u32 tb_id)
+ {
+ 	struct vif_entry_notifier_info info = {
+ 		.info = {
+ 			.family = RTNL_FAMILY_IPMR,
+ 			.net = net,
+ 		},
+ 		.dev = vif->dev,
+ 		.vif_index = vif_index,
+ 		.vif_flags = vif->flags,
+ 		.tb_id = tb_id,
+ 	};
+ 
+ 	ASSERT_RTNL();
+ 	net->ipv4.ipmr_seq++;
+ 	return call_fib_notifiers(net, event_type, &info.info);
+ }
+ 
+ static int call_ipmr_mfc_entry_notifier(struct notifier_block *nb,
+ 					struct net *net,
+ 					enum fib_event_type event_type,
+ 					struct mfc_cache *mfc, u32 tb_id)
+ {
+ 	struct mfc_entry_notifier_info info = {
+ 		.info = {
+ 			.family = RTNL_FAMILY_IPMR,
+ 			.net = net,
+ 		},
+ 		.mfc = mfc,
+ 		.tb_id = tb_id
+ 	};
+ 
+ 	return call_fib_notifier(nb, net, event_type, &info.info);
+ }
+ 
+ static int call_ipmr_mfc_entry_notifiers(struct net *net,
+ 					 enum fib_event_type event_type,
+ 					 struct mfc_cache *mfc, u32 tb_id)
+ {
+ 	struct mfc_entry_notifier_info info = {
+ 		.info = {
+ 			.family = RTNL_FAMILY_IPMR,
+ 			.net = net,
+ 		},
+ 		.mfc = mfc,
+ 		.tb_id = tb_id
+ 	};
+ 
+ 	ASSERT_RTNL();
+ 	net->ipv4.ipmr_seq++;
+ 	return call_fib_notifiers(net, event_type, &info.info);
+ }
+ 
++>>>>>>> b362053a7cc0 (ipmr: Send FIB notifications on MFC and VIF entries)
  /**
   *	vif_delete - Delete a VIF entry
   *	@notify: Set to 1, if the caller is a notifier_call
@@@ -1100,22 -1254,23 +1185,40 @@@ ipmr_cache_unresolved(struct mr_table *
  
  static int ipmr_mfc_delete(struct mr_table *mrt, struct mfcctl *mfc, int parent)
  {
++<<<<<<< HEAD
 +	int line;
 +	struct mfc_cache *c, *next;
 +
 +	line = MFC_HASH(mfc->mfcc_mcastgrp.s_addr, mfc->mfcc_origin.s_addr);
++=======
+ 	struct net *net = read_pnet(&mrt->net);
+ 	struct mfc_cache *c;
+ 
+ 	/* The entries are added/deleted only under RTNL */
+ 	rcu_read_lock();
+ 	c = ipmr_cache_find_parent(mrt, mfc->mfcc_origin.s_addr,
+ 				   mfc->mfcc_mcastgrp.s_addr, parent);
+ 	rcu_read_unlock();
+ 	if (!c)
+ 		return -ENOENT;
+ 	rhltable_remove(&mrt->mfc_hash, &c->mnode, ipmr_rht_params);
+ 	list_del_rcu(&c->list);
+ 	call_ipmr_mfc_entry_notifiers(net, FIB_EVENT_ENTRY_DEL, c, mrt->id);
+ 	mroute_netlink_event(mrt, c, RTM_DELROUTE);
+ 	ipmr_cache_put(c);
++>>>>>>> b362053a7cc0 (ipmr: Send FIB notifications on MFC and VIF entries)
  
 -	return 0;
 +	list_for_each_entry_safe(c, next, &mrt->mfc_cache_array[line], list) {
 +		if (c->mfc_origin == mfc->mfcc_origin.s_addr &&
 +		    c->mfc_mcastgrp == mfc->mfcc_mcastgrp.s_addr &&
 +		    (parent == -1 || parent == c->mfc_parent)) {
 +			list_del_rcu(&c->list);
 +			mroute_netlink_event(mrt, c, RTM_DELROUTE);
 +			ipmr_cache_free(c);
 +			return 0;
 +		}
 +	}
 +	return -ENOENT;
  }
  
  static int ipmr_mfc_add(struct net *net, struct mr_table *mrt,
@@@ -1194,18 -1351,15 +1300,24 @@@
  	return 0;
  }
  
 -/* Close the multicast socket, and clear the vif tables etc */
 +/*
 + *	Close the multicast socket, and clear the vif tables etc
 + */
 +
  static void mroute_clean_tables(struct mr_table *mrt, bool all)
  {
++<<<<<<< HEAD
++=======
+ 	struct net *net = read_pnet(&mrt->net);
+ 	struct mfc_cache *c, *tmp;
+ 	LIST_HEAD(list);
++>>>>>>> b362053a7cc0 (ipmr: Send FIB notifications on MFC and VIF entries)
  	int i;
 +	LIST_HEAD(list);
 +	struct mfc_cache *c, *next;
  
  	/* Shut down all active vif entries */
 +
  	for (i = 0; i < mrt->maxvif; i++) {
  		if (!all && (mrt->vif_table[i].flags & VIFF_STATIC))
  			continue;
@@@ -1214,15 -1368,15 +1326,27 @@@
  	unregister_netdevice_many(&list);
  
  	/* Wipe the cache */
++<<<<<<< HEAD
 +
 +	for (i = 0; i < MFC_LINES; i++) {
 +		list_for_each_entry_safe(c, next, &mrt->mfc_cache_array[i], list) {
 +			if (!all && (c->mfc_flags & MFC_STATIC))
 +				continue;
 +			list_del_rcu(&c->list);
 +			mroute_netlink_event(mrt, c, RTM_DELROUTE);
 +			ipmr_cache_free(c);
 +		}
++=======
+ 	list_for_each_entry_safe(c, tmp, &mrt->mfc_cache_list, list) {
+ 		if (!all && (c->mfc_flags & MFC_STATIC))
+ 			continue;
+ 		rhltable_remove(&mrt->mfc_hash, &c->mnode, ipmr_rht_params);
+ 		list_del_rcu(&c->list);
+ 		call_ipmr_mfc_entry_notifiers(net, FIB_EVENT_ENTRY_DEL, c,
+ 					      mrt->id);
+ 		mroute_netlink_event(mrt, c, RTM_DELROUTE);
+ 		ipmr_cache_put(c);
++>>>>>>> b362053a7cc0 (ipmr: Send FIB notifications on MFC and VIF entries)
  	}
  
  	if (atomic_read(&mrt->cache_resolve_queue_len) != 0) {
* Unmerged path net/ipv4/ipmr.c
