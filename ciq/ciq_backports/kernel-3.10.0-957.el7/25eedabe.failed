vm: fix incorrect unlock error path in madvise_free_huge_pmd

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mm] fix incorrect unlock error path in madvise_free_huge_pmd (Rafael Aquini) [1562137]
Rebuild_FUZZ: 96.55%
commit-author Linus Torvalds <torvalds@linux-foundation.org>
commit 25eedabe019851bc513abd601ed514df524cb482
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/25eedabe.failed

Commit b8d3c4c3009d ("mm/huge_memory.c: don't split THP page when
MADV_FREE syscall is called") introduced this new function, but got the
error handling for when pmd_trans_huge_lock() fails wrong.  In the
failure case, the lock has not been taken, and we should not unlock on
the way out.

	Cc: Minchan Kim <minchan@kernel.org>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 25eedabe019851bc513abd601ed514df524cb482)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/huge_memory.c
diff --cc mm/huge_memory.c
index 075f651aabed,50342eff7960..000000000000
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@@ -1750,6 -1550,77 +1750,80 @@@ out
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ int madvise_free_huge_pmd(struct mmu_gather *tlb, struct vm_area_struct *vma,
+ 		pmd_t *pmd, unsigned long addr, unsigned long next)
+ 
+ {
+ 	spinlock_t *ptl;
+ 	pmd_t orig_pmd;
+ 	struct page *page;
+ 	struct mm_struct *mm = tlb->mm;
+ 	int ret = 0;
+ 
+ 	if (!pmd_trans_huge_lock(pmd, vma, &ptl))
+ 		goto out_unlocked;
+ 
+ 	orig_pmd = *pmd;
+ 	if (is_huge_zero_pmd(orig_pmd)) {
+ 		ret = 1;
+ 		goto out;
+ 	}
+ 
+ 	page = pmd_page(orig_pmd);
+ 	/*
+ 	 * If other processes are mapping this page, we couldn't discard
+ 	 * the page unless they all do MADV_FREE so let's skip the page.
+ 	 */
+ 	if (page_mapcount(page) != 1)
+ 		goto out;
+ 
+ 	if (!trylock_page(page))
+ 		goto out;
+ 
+ 	/*
+ 	 * If user want to discard part-pages of THP, split it so MADV_FREE
+ 	 * will deactivate only them.
+ 	 */
+ 	if (next - addr != HPAGE_PMD_SIZE) {
+ 		get_page(page);
+ 		spin_unlock(ptl);
+ 		if (split_huge_page(page)) {
+ 			put_page(page);
+ 			unlock_page(page);
+ 			goto out_unlocked;
+ 		}
+ 		put_page(page);
+ 		unlock_page(page);
+ 		ret = 1;
+ 		goto out_unlocked;
+ 	}
+ 
+ 	if (PageDirty(page))
+ 		ClearPageDirty(page);
+ 	unlock_page(page);
+ 
+ 	if (PageActive(page))
+ 		deactivate_page(page);
+ 
+ 	if (pmd_young(orig_pmd) || pmd_dirty(orig_pmd)) {
+ 		orig_pmd = pmdp_huge_get_and_clear_full(tlb->mm, addr, pmd,
+ 			tlb->fullmm);
+ 		orig_pmd = pmd_mkold(orig_pmd);
+ 		orig_pmd = pmd_mkclean(orig_pmd);
+ 
+ 		set_pmd_at(mm, addr, pmd, orig_pmd);
+ 		tlb_remove_pmd_tlb_entry(tlb, pmd, addr);
+ 	}
+ 	ret = 1;
+ out:
+ 	spin_unlock(ptl);
+ out_unlocked:
+ 	return ret;
+ }
+ 
++>>>>>>> 25eedabe0198 (vm: fix incorrect unlock error path in madvise_free_huge_pmd)
  int zap_huge_pmd(struct mmu_gather *tlb, struct vm_area_struct *vma,
  		 pmd_t *pmd, unsigned long addr)
  {
* Unmerged path mm/huge_memory.c
