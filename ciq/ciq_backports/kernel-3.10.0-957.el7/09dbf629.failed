mlxsw: spectrum_router: Update nexthop RIF on update

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Petr Machata <petrm@mellanox.com>
commit 09dbf6297fa8bb4433d9293623b464750d874685
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/09dbf629.failed

The function mlxsw_sp_nexthop_rif_update() walks the list of nexthops
associated with a RIF, and updates the corresponding entries in the
switch. It is used in particular when a tunnel underlay netdevice moves
to a different VRF, and all the nexthops are migrated over to a new RIF.
The problem is that each nexthop holds a reference to its RIF, and that
is not updated. So after the old RIF is gone, further activity on these
nexthops (such as downing the underlay netdevice) dereferences a
dangling pointer.

Fix the issue by updating rif of impacted nexthops before calling
mlxsw_sp_nexthop_rif_update().

Fixes: 0c5f1cd5ba8c ("mlxsw: spectrum_router: Generalize __mlxsw_sp_ipip_entry_update_tunnel()")
	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 09dbf6297fa8bb4433d9293623b464750d874685)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index edab76a34b3f,72ef4f8025f0..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -1348,22 -1370,60 +1348,70 @@@ static void mlxsw_sp_netdevice_ipip_ol_
  		mlxsw_sp_ipip_entry_ol_down_event(mlxsw_sp, ipip_entry);
  }
  
++<<<<<<< HEAD
 +static int mlxsw_sp_netdevice_ipip_ol_vrf_event(struct mlxsw_sp *mlxsw_sp,
 +						struct net_device *ol_dev)
++=======
+ static void mlxsw_sp_nexthop_rif_migrate(struct mlxsw_sp *mlxsw_sp,
+ 					 struct mlxsw_sp_rif *old_rif,
+ 					 struct mlxsw_sp_rif *new_rif);
+ static int
+ mlxsw_sp_ipip_entry_ol_lb_update(struct mlxsw_sp *mlxsw_sp,
+ 				 struct mlxsw_sp_ipip_entry *ipip_entry,
+ 				 bool keep_encap,
+ 				 struct netlink_ext_ack *extack)
++>>>>>>> 09dbf6297fa8 (mlxsw: spectrum_router: Update nexthop RIF on update)
  {
 -	struct mlxsw_sp_rif_ipip_lb *old_lb_rif = ipip_entry->ol_lb;
 -	struct mlxsw_sp_rif_ipip_lb *new_lb_rif;
 +	struct mlxsw_sp_fib_entry *decap_fib_entry;
 +	struct mlxsw_sp_ipip_entry *ipip_entry;
 +	struct mlxsw_sp_rif_ipip_lb *lb_rif;
  
 -	new_lb_rif = mlxsw_sp_ipip_ol_ipip_lb_create(mlxsw_sp,
 -						     ipip_entry->ipipt,
 -						     ipip_entry->ol_dev,
 -						     extack);
 -	if (IS_ERR(new_lb_rif))
 -		return PTR_ERR(new_lb_rif);
 -	ipip_entry->ol_lb = new_lb_rif;
 +	ipip_entry = mlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, ol_dev);
 +	if (!ipip_entry)
 +		return 0;
  
++<<<<<<< HEAD
 +	/* When a tunneling device is moved to a different VRF, we need to
 +	 * update the backing loopback. Since RIFs can't be edited, we need to
 +	 * destroy and recreate it. That might create a window of opportunity
 +	 * where RALUE and RATR registers end up referencing a RIF that's
 +	 * already gone. RATRs are handled by the RIF destroy, and to take care
++=======
+ 	if (keep_encap)
+ 		mlxsw_sp_nexthop_rif_migrate(mlxsw_sp, &old_lb_rif->common,
+ 					     &new_lb_rif->common);
+ 
+ 	mlxsw_sp_rif_destroy(&old_lb_rif->common);
+ 
+ 	return 0;
+ }
+ 
+ static void mlxsw_sp_nexthop_rif_update(struct mlxsw_sp *mlxsw_sp,
+ 					struct mlxsw_sp_rif *rif);
+ 
+ /**
+  * Update the offload related to an IPIP entry. This always updates decap, and
+  * in addition to that it also:
+  * @recreate_loopback: recreates the associated loopback RIF
+  * @keep_encap: updates next hops that use the tunnel netdevice. This is only
+  *              relevant when recreate_loopback is true.
+  * @update_nexthops: updates next hops, keeping the current loopback RIF. This
+  *                   is only relevant when recreate_loopback is false.
+  */
+ int __mlxsw_sp_ipip_entry_update_tunnel(struct mlxsw_sp *mlxsw_sp,
+ 					struct mlxsw_sp_ipip_entry *ipip_entry,
+ 					bool recreate_loopback,
+ 					bool keep_encap,
+ 					bool update_nexthops,
+ 					struct netlink_ext_ack *extack)
+ {
+ 	int err;
+ 
+ 	/* RIFs can't be edited, so to update loopback, we need to destroy and
+ 	 * recreate it. That creates a window of opportunity where RALUE and
+ 	 * RATR registers end up referencing a RIF that's already gone. RATRs
+ 	 * are handled in mlxsw_sp_ipip_entry_ol_lb_update(), and to take care
++>>>>>>> 09dbf6297fa8 (mlxsw: spectrum_router: Update nexthop RIF on update)
  	 * of RALUE, demote the decap route back.
  	 */
  	if (ipip_entry->decap_fib_entry)
@@@ -3265,6 -3538,42 +3313,45 @@@ static void mlxsw_sp_nexthop4_event(str
  	mlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh->nh_grp);
  }
  
++<<<<<<< HEAD
++=======
+ static void mlxsw_sp_nexthop_rif_update(struct mlxsw_sp *mlxsw_sp,
+ 					struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp_nexthop *nh;
+ 	bool removing;
+ 
+ 	list_for_each_entry(nh, &rif->nexthop_list, rif_list_node) {
+ 		switch (nh->type) {
+ 		case MLXSW_SP_NEXTHOP_TYPE_ETH:
+ 			removing = false;
+ 			break;
+ 		case MLXSW_SP_NEXTHOP_TYPE_IPIP:
+ 			removing = !mlxsw_sp_ipip_netdev_ul_up(rif->dev);
+ 			break;
+ 		default:
+ 			WARN_ON(1);
+ 			continue;
+ 		}
+ 
+ 		__mlxsw_sp_nexthop_neigh_update(nh, removing);
+ 		mlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh->nh_grp);
+ 	}
+ }
+ 
+ static void mlxsw_sp_nexthop_rif_migrate(struct mlxsw_sp *mlxsw_sp,
+ 					 struct mlxsw_sp_rif *old_rif,
+ 					 struct mlxsw_sp_rif *new_rif)
+ {
+ 	struct mlxsw_sp_nexthop *nh;
+ 
+ 	list_splice_init(&old_rif->nexthop_list, &new_rif->nexthop_list);
+ 	list_for_each_entry(nh, &new_rif->nexthop_list, rif_list_node)
+ 		nh->rif = new_rif;
+ 	mlxsw_sp_nexthop_rif_update(mlxsw_sp, new_rif);
+ }
+ 
++>>>>>>> 09dbf6297fa8 (mlxsw: spectrum_router: Update nexthop RIF on update)
  static void mlxsw_sp_nexthop_rif_gone_sync(struct mlxsw_sp *mlxsw_sp,
  					   struct mlxsw_sp_rif *rif)
  {
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
