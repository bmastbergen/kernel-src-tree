scsi: tcmu: Don't pass KERN_ERR to pr_err

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Mike Christie <mchristi@redhat.com>
commit 0c218e16a8501cfda30f498217b434976cb62fc5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0c218e16.failed

Fix warning:

smatch warnings:
drivers/target/target_core_user.c:301 tcmu_genl_cmd_done() warn: KERN_*
level not at start of string

	Signed-off-by: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 0c218e16a8501cfda30f498217b434976cb62fc5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_user.c
diff --cc drivers/target/target_core_user.c
index 5534ef1b341c,847707a700cf..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -193,33 -374,37 +193,46 @@@ static int tcmu_genl_cmd_done(struct ge
  	dev_id = nla_get_u32(info->attrs[TCMU_ATTR_DEVICE_ID]);
  	rc = nla_get_s32(info->attrs[TCMU_ATTR_CMD_STATUS]);
  
++<<<<<<< HEAD
 +	mutex_lock(&device_mutex);
 +	dev = idr_find(&devices_idr, dev_id);
 +	mutex_unlock(&device_mutex);
 +	if (!dev) {
 +		printk(KERN_ERR "tcmu nl cmd %u/%u completion could not find device with dev id %u.\n",
++=======
+ 	mutex_lock(&tcmu_nl_cmd_mutex);
+ 	list_for_each_entry(nl_cmd, &tcmu_nl_cmd_list, nl_list) {
+ 		if (nl_cmd->udev->se_dev.dev_index == dev_id) {
+ 			udev = nl_cmd->udev;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (!udev) {
+ 		pr_err("tcmu nl cmd %u/%d completion could not find device with dev id %u.\n",
++>>>>>>> 0c218e16a850 (scsi: tcmu: Don't pass KERN_ERR to pr_err)
  		       completed_cmd, rc, dev_id);
 -		ret = -ENODEV;
 -		goto unlock;
 +		return -ENODEV;
  	}
 -	list_del(&nl_cmd->nl_list);
 +	udev = TCMU_DEV(dev);
  
 -	pr_debug("%s genl cmd done got id %d curr %d done %d rc %d stat %d\n",
 -		 udev->name, dev_id, nl_cmd->cmd, completed_cmd, rc,
 -		 nl_cmd->status);
 +	spin_lock(&udev->nl_cmd_lock);
 +	nl_cmd = &udev->curr_nl_cmd;
 +
 +	pr_debug("genl cmd done got id %d curr %d done %d rc %d\n", dev_id,
 +		 nl_cmd->cmd, completed_cmd, rc);
  
  	if (nl_cmd->cmd != completed_cmd) {
 -		pr_err("Mismatched commands on %s (Expecting reply for %d. Current %d).\n",
 -		       udev->name, completed_cmd, nl_cmd->cmd);
 +		printk(KERN_ERR "Mismatched commands (Expecting reply for %d. Current %d).\n",
 +		       completed_cmd, nl_cmd->cmd);
  		ret = -EINVAL;
 -		goto unlock;
 +	} else {
 +		nl_cmd->status = rc;
  	}
  
 -	nl_cmd->status = rc;
 -	complete(&nl_cmd->complete);
 -unlock:
 -	mutex_unlock(&tcmu_nl_cmd_mutex);
 +	spin_unlock(&udev->nl_cmd_lock);
 +	if (!ret)
 +		complete(&nl_cmd->complete);
  	return ret;
  }
  
* Unmerged path drivers/target/target_core_user.c
