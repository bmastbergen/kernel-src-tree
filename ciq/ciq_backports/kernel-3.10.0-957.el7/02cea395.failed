genirq: Provide disable_hardirq()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit 02cea3958664723a5d2236f0f0058de97c7e4693
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/02cea395.failed

For things like netpoll there is a need to disable an interrupt from
atomic context. Currently netpoll uses disable_irq() which will
sleep-wait on threaded handlers and thus forced_irqthreads breaks
things.

Provide disable_hardirq(), which uses synchronize_hardirq() to only wait
for active hardirq handlers; also change synchronize_hardirq() to
return the status of threaded handlers.

This will allow one to try-disable an interrupt from atomic context, or
in case of request_threaded_irq() to only wait for the hardirq part.

	Suggested-by: Sabrina Dubroca <sd@queasysnail.net>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: David Miller <davem@davemloft.net>
	Cc: Eyal Perry <eyalpe@mellanox.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Cc: Quentin Lambert <lambert.quentin@gmail.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Russell King <linux@arm.linux.org.uk>
Link: http://lkml.kernel.org/r/20150205130623.GH5029@twins.programming.kicks-ass.net
[ Fixed typos and such. ]
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 02cea3958664723a5d2236f0f0058de97c7e4693)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/hardirq.h
#	kernel/irq/manage.c
diff --cc include/linux/hardirq.h
index 39e166d63b50,f4af03404b97..000000000000
--- a/include/linux/hardirq.h
+++ b/include/linux/hardirq.h
@@@ -8,15 -8,10 +8,19 @@@
  #include <asm/hardirq.h>
  
  
 +#if defined(CONFIG_SMP) || defined(CONFIG_GENERIC_HARDIRQS)
  extern void synchronize_irq(unsigned int irq);
++<<<<<<< HEAD
 +extern void synchronize_hardirq(unsigned int irq);
 +#else
 +# define synchronize_irq(irq)	barrier()
 +# define synchronize_hardirq(irq)	barrier()
 +#endif
++=======
+ extern bool synchronize_hardirq(unsigned int irq);
++>>>>>>> 02cea3958664 (genirq: Provide disable_hardirq())
  
 -#if defined(CONFIG_TINY_RCU)
 +#if defined(CONFIG_TINY_RCU) || defined(CONFIG_TINY_PREEMPT_RCU)
  
  static inline void rcu_nmi_enter(void)
  {
diff --cc kernel/irq/manage.c
index e63914538bda,03329c2287eb..000000000000
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@@ -460,20 -446,34 +466,50 @@@ void disable_irq(unsigned int irq
  }
  EXPORT_SYMBOL(disable_irq);
  
++<<<<<<< HEAD
 +void __enable_irq(struct irq_desc *desc, unsigned int irq, bool resume)
++=======
+ /**
+  *	disable_hardirq - disables an irq and waits for hardirq completion
+  *	@irq: Interrupt to disable
+  *
+  *	Disable the selected interrupt line.  Enables and Disables are
+  *	nested.
+  *	This function waits for any pending hard IRQ handlers for this
+  *	interrupt to complete before returning. If you use this function while
+  *	holding a resource the hard IRQ handler may need you will deadlock.
+  *
+  *	When used to optimistically disable an interrupt from atomic context
+  *	the return value must be checked.
+  *
+  *	Returns: false if a threaded handler is active.
+  *
+  *	This function may be called - with care - from IRQ context.
+  */
+ bool disable_hardirq(unsigned int irq)
+ {
+ 	if (!__disable_irq_nosync(irq))
+ 		return synchronize_hardirq(irq);
+ 
+ 	return false;
+ }
+ EXPORT_SYMBOL_GPL(disable_hardirq);
+ 
+ void __enable_irq(struct irq_desc *desc, unsigned int irq)
++>>>>>>> 02cea3958664 (genirq: Provide disable_hardirq())
  {
 +	if (resume) {
 +		if (!(desc->istate & IRQS_SUSPENDED)) {
 +			if (!desc->action)
 +				return;
 +			if (!(desc->action->flags & IRQF_FORCE_RESUME))
 +				return;
 +			/* Pretend that it got disabled ! */
 +			desc->depth++;
 +		}
 +		desc->istate &= ~IRQS_SUSPENDED;
 +	}
 +
  	switch (desc->depth) {
  	case 0:
   err_out:
* Unmerged path include/linux/hardirq.h
diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index fbb4431af145..90d28bf99653 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -213,6 +213,7 @@ extern void devm_free_irq(struct device *dev, unsigned int irq, void *dev_id);
 #endif
 
 extern void disable_irq_nosync(unsigned int irq);
+extern bool disable_hardirq(unsigned int irq);
 extern void disable_irq(unsigned int irq);
 extern void disable_percpu_irq(unsigned int irq);
 extern void enable_irq(unsigned int irq);
* Unmerged path kernel/irq/manage.c
