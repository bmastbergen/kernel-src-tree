vfs, fdtable: Prevent bounds-check bypass via speculative execution

jira LE-1907
cve CVE-2018-3693
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit 56c30ba7b348b90484969054d561f711ba196507
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/56c30ba7.failed

'fd' is a user controlled value that is used as a data dependency to
read from the 'fdt->fd' array.  In order to avoid potential leaks of
kernel memory values, block speculative execution of the instruction
stream that could issue reads based on an invalid 'file *' returned from
__fcheck_files.

Co-developed-by: Elena Reshetova <elena.reshetova@intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-arch@vger.kernel.org
	Cc: kernel-hardening@lists.openwall.com
	Cc: gregkh@linuxfoundation.org
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: torvalds@linux-foundation.org
	Cc: alan@linux.intel.com
Link: https://lkml.kernel.org/r/151727418500.33451.17392199002892248656.stgit@dwillia2-desk3.amr.corp.intel.com

(cherry picked from commit 56c30ba7b348b90484969054d561f711ba196507)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/fdtable.h
diff --cc include/linux/fdtable.h
index 9cea6f8e746d,41615f38bcff..000000000000
--- a/include/linux/fdtable.h
+++ b/include/linux/fdtable.h
@@@ -61,37 -59,43 +62,52 @@@ struct files_struct 
     * written part on a separate cache line in SMP
     */
  	spinlock_t file_lock ____cacheline_aligned_in_smp;
 -	unsigned int next_fd;
 +	int next_fd;
  	unsigned long close_on_exec_init[1];
  	unsigned long open_fds_init[1];
 -	unsigned long full_fds_bits_init[1];
  	struct file __rcu * fd_array[NR_OPEN_DEFAULT];
 +	RH_KABI_EXTEND(unsigned long full_fds_bits_init[1])
 +	RH_KABI_EXTEND(wait_queue_head_t resize_wait)
  };
  
 -struct file_operations;
 -struct vfsmount;
 -struct dentry;
 -
  #define rcu_dereference_check_fdtable(files, fdtfd) \
 -	rcu_dereference_check((fdtfd), lockdep_is_held(&(files)->file_lock))
 +	(rcu_dereference_check((fdtfd), \
 +			       lockdep_is_held(&(files)->file_lock) || \
 +			       atomic_read(&(files)->count) == 1 || \
 +			       rcu_my_thread_group_empty()))
  
  #define files_fdtable(files) \
 -	rcu_dereference_check_fdtable((files), (files)->fdt)
 +		(rcu_dereference_check_fdtable((files), (files)->fdt))
  
 -/*
 - * The caller must ensure that fd table isn't shared or hold rcu or file lock
 - */
 -static inline struct file *__fcheck_files(struct files_struct *files, unsigned int fd)
 +struct file_operations;
 +struct vfsmount;
 +struct dentry;
 +
 +static inline struct file * fcheck_files(struct files_struct *files, unsigned int fd)
  {
 -	struct fdtable *fdt = rcu_dereference_raw(files->fdt);
 +	struct file * file = NULL;
 +	struct fdtable *fdt = files_fdtable(files);
  
  	if (fd < fdt->max_fds) {
++<<<<<<< HEAD
 +		gmb();
 +		file = rcu_dereference_check_fdtable(files, fdt->fd[fd]);
 +	}
 +	return file;
++=======
+ 		fd = array_index_nospec(fd, fdt->max_fds);
+ 		return rcu_dereference_raw(fdt->fd[fd]);
+ 	}
+ 	return NULL;
+ }
+ 
+ static inline struct file *fcheck_files(struct files_struct *files, unsigned int fd)
+ {
+ 	RCU_LOCKDEP_WARN(!rcu_read_lock_held() &&
+ 			   !lockdep_is_held(&files->file_lock),
+ 			   "suspicious rcu_dereference_check() usage");
+ 	return __fcheck_files(files, fd);
++>>>>>>> 56c30ba7b348 (vfs, fdtable: Prevent bounds-check bypass via speculative execution)
  }
  
  /*
* Unmerged path include/linux/fdtable.h
