scsi: qla2xxx: Utilize pci_alloc_irq_vectors/pci_free_irq_vectors calls.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Utilize pci_alloc_irq_vectors/pci_free_irq_vectors calls (Himanshu Madhani) [1547714]
Rebuild_FUZZ: 94.89%
commit-author Michael Hernandez <michael.hernandez@cavium.com>
commit 4fa183455988adaa7f6565ca06bceecafb527820
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4fa18345.failed

Replaces the old pci_enable_msi[x]* and pci_disable_msi[x] calls.

	Signed-off-by: Michael Hernandez <michael.hernandez@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 4fa183455988adaa7f6565ca06bceecafb527820)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_isr.c
#	drivers/scsi/qla2xxx/qla_mid.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 70dffc916a3d,d38c205ae22c..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -3035,10 -2745,8 +3035,13 @@@ struct scsi_qla_host
  
  struct qla_msix_entry {
  	int have_irq;
 +	int in_use;
  	uint32_t vector;
  	uint16_t entry;
++<<<<<<< HEAD
 +	char name[30];
++=======
++>>>>>>> 4fa183455988 (scsi: qla2xxx: Utilize pci_alloc_irq_vectors/pci_free_irq_vectors calls.)
  	void *handle;
  	struct irq_affinity_notify irq_notify;
  	int cpuid;
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index 5b62f352b08f,ad5304caf1ff..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -3202,35 -3019,18 +3202,42 @@@ static const struct qla_init_msix_entr
  	{ "qla2xxx (rsp_q)", qla82xx_msix_rsp_q },
  };
  
++<<<<<<< HEAD
 +static void
 +qla24xx_disable_msix(struct qla_hw_data *ha)
 +{
 +	int i;
 +	struct qla_msix_entry *qentry;
 +	scsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);
 +
 +	for (i = 0; i < ha->msix_count; i++) {
 +		qentry = &ha->msix_entries[i];
 +		if (qentry->have_irq) {
 +			/* un-register irq cpu affinity notification */
 +			irq_set_affinity_notifier(qentry->vector, NULL);
 +			free_irq(qentry->vector, qentry->handle);
 +		}
 +	}
 +	pci_disable_msix(ha->pdev);
 +	kfree(ha->msix_entries);
 +	ha->msix_entries = NULL;
 +	ha->flags.msix_enabled = 0;
 +	ql_dbg(ql_dbg_init, vha, 0x0042,
 +	    "Disabled the MSI.\n");
 +}
++=======
+ static struct qla_init_msix_entry qla83xx_msix_entries[3] = {
+ 	{ "qla2xxx (default)", qla24xx_msix_default },
+ 	{ "qla2xxx (rsp_q)", qla24xx_msix_rsp_q },
+ 	{ "qla2xxx (atio_q)", qla83xx_msix_atio_q },
+ };
++>>>>>>> 4fa183455988 (scsi: qla2xxx: Utilize pci_alloc_irq_vectors/pci_free_irq_vectors calls.)
  
  static int
  qla24xx_enable_msix(struct qla_hw_data *ha, struct rsp_que *rsp)
  {
  #define MIN_MSIX_COUNT	2
 -#define ATIO_VECTOR	2
  	int i, ret;
- 	struct msix_entry *entries;
  	struct qla_msix_entry *qentry;
  	scsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);
  
@@@ -3287,10 -3062,9 +3283,13 @@@
  
  	for (i = 0; i < ha->msix_count; i++) {
  		qentry = &ha->msix_entries[i];
- 		qentry->vector = entries[i].vector;
- 		qentry->entry = entries[i].entry;
+ 		qentry->vector = pci_irq_vector(ha->pdev, i);
+ 		qentry->entry = i;
  		qentry->have_irq = 0;
++<<<<<<< HEAD
 +		qentry->in_use = 0;
++=======
++>>>>>>> 4fa183455988 (scsi: qla2xxx: Utilize pci_alloc_irq_vectors/pci_free_irq_vectors calls.)
  		qentry->handle = NULL;
  		qentry->irq_notify.notify  = qla_irq_affinity_notify;
  		qentry->irq_notify.release = qla_irq_affinity_release;
@@@ -3348,6 -3101,20 +3347,23 @@@
  		schedule_work(&qentry->irq_notify.work);
  	}
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * If target mode is enable, also request the vector for the ATIO
+ 	 * queue.
+ 	 */
+ 	if (QLA_TGT_MODE_ENABLED() && IS_ATIO_MSIX_CAPABLE(ha)) {
+ 		qentry = &ha->msix_entries[ATIO_VECTOR];
+ 		qentry->handle = rsp;
+ 		rsp->msix = qentry;
+ 		ret = request_irq(qentry->vector,
+ 			qla83xx_msix_entries[ATIO_VECTOR].handler,
+ 			0, qla83xx_msix_entries[ATIO_VECTOR].name, rsp);
+ 		qentry->have_irq = 1;
+ 	}
+ 
++>>>>>>> 4fa183455988 (scsi: qla2xxx: Utilize pci_alloc_irq_vectors/pci_free_irq_vectors calls.)
  msix_register_fail:
  	if (ret) {
  		ql_log(ql_log_fatal, vha, 0x00cb,
@@@ -3484,19 -3250,32 +3501,30 @@@ qla2x00_free_irqs(scsi_qla_host_t *vha
  		return;
  	rsp = ha->rsp_q_map[0];
  
- 	if (ha->flags.msix_enabled)
- 		qla24xx_disable_msix(ha);
- 	else if (ha->flags.msi_enabled) {
- 		free_irq(ha->pdev->irq, rsp);
- 		pci_disable_msi(ha->pdev);
- 	} else
- 		free_irq(ha->pdev->irq, rsp);
+ 	if (ha->flags.msix_enabled) {
+ 		for (i = 0; i < ha->msix_count; i++) {
+ 			qentry = &ha->msix_entries[i];
+ 			if (qentry->have_irq) {
+ 				irq_set_affinity_notifier(qentry->vector, NULL);
+ 				free_irq(pci_irq_vector(ha->pdev, i), qentry->handle);
+ 			}
+ 		}
+ 		kfree(ha->msix_entries);
+ 		ha->msix_entries = NULL;
+ 		ha->flags.msix_enabled = 0;
+ 		ql_dbg(ql_dbg_init, vha, 0x0042,
+ 			"Disabled MSI-X.\n");
+ 	} else {
+ 		free_irq(pci_irq_vector(ha->pdev, 0), rsp);
+ 	}
+ 
+ 	pci_free_irq_vectors(ha->pdev);
  }
  
 -
 -int qla25xx_request_irq(struct rsp_que *rsp)
 +int qla25xx_request_irq(struct qla_hw_data *ha, struct qla_qpair *qpair,
 +	struct qla_msix_entry *msix, int vector_type)
  {
 -	struct qla_hw_data *ha = rsp->hw;
 -	struct qla_init_msix_entry *intr = &msix_entries[2];
 -	struct qla_msix_entry *msix = rsp->msix;
 +	const struct qla_init_msix_entry *intr = &msix_entries[vector_type];
  	scsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);
  	int ret;
  
@@@ -3510,7 -3287,7 +3538,11 @@@
  		return ret;
  	}
  	msix->have_irq = 1;
++<<<<<<< HEAD
 +	msix->handle = qpair;
++=======
+ 	msix->handle = rsp;
++>>>>>>> 4fa183455988 (scsi: qla2xxx: Utilize pci_alloc_irq_vectors/pci_free_irq_vectors calls.)
  	return ret;
  }
  
@@@ -3523,14 -3300,12 +3555,22 @@@ static void qla_irq_affinity_notify(str
  		container_of(notify, struct qla_msix_entry, irq_notify);
  	struct qla_hw_data *ha;
  	struct scsi_qla_host *base_vha;
++<<<<<<< HEAD
 +	struct rsp_que *rsp;
++=======
+ 	struct rsp_que *rsp = e->handle;
++>>>>>>> 4fa183455988 (scsi: qla2xxx: Utilize pci_alloc_irq_vectors/pci_free_irq_vectors calls.)
  
  	/* user is recommended to set mask to just 1 cpu */
  	e->cpuid = cpumask_first(mask);
  
++<<<<<<< HEAD
 +	rsp = (struct rsp_que *)e->handle;
 +	ha = rsp->hw;
 +
++=======
+ 	ha = rsp->hw;
++>>>>>>> 4fa183455988 (scsi: qla2xxx: Utilize pci_alloc_irq_vectors/pci_free_irq_vectors calls.)
  	base_vha = pci_get_drvdata(ha->pdev);
  
  	ql_dbg(ql_dbg_init, base_vha, 0xffff,
@@@ -3554,7 -3329,7 +3594,11 @@@ static void qla_irq_affinity_release(st
  		container_of(ref, struct irq_affinity_notify, kref);
  	struct qla_msix_entry *e =
  		container_of(notify, struct qla_msix_entry, irq_notify);
++<<<<<<< HEAD
 +	struct rsp_que *rsp = (struct rsp_que *)e->handle;
++=======
+ 	struct rsp_que *rsp = e->handle;
++>>>>>>> 4fa183455988 (scsi: qla2xxx: Utilize pci_alloc_irq_vectors/pci_free_irq_vectors calls.)
  	struct scsi_qla_host *base_vha = pci_get_drvdata(rsp->hw->pdev);
  
  	ql_dbg(ql_dbg_init, base_vha, 0xffff,
diff --cc drivers/scsi/qla2xxx/qla_mid.c
index 9cb8a27774c4,8e406fc35db4..000000000000
--- a/drivers/scsi/qla2xxx/qla_mid.c
+++ b/drivers/scsi/qla2xxx/qla_mid.c
@@@ -547,9 -540,8 +547,12 @@@ qla25xx_free_rsp_que(struct scsi_qla_ho
  	uint16_t que_id = rsp->id;
  
  	if (rsp->msix && rsp->msix->have_irq) {
 -		free_irq(rsp->msix->vector, rsp);
 +		free_irq(rsp->msix->vector, rsp->msix->handle);
  		rsp->msix->have_irq = 0;
++<<<<<<< HEAD
 +		rsp->msix->in_use = 0;
++=======
++>>>>>>> 4fa183455988 (scsi: qla2xxx: Utilize pci_alloc_irq_vectors/pci_free_irq_vectors calls.)
  		rsp->msix->handle = NULL;
  	}
  	dma_free_coherent(&ha->pdev->dev, (rsp->length + 1) *
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
* Unmerged path drivers/scsi/qla2xxx/qla_mid.c
