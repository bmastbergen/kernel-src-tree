scsi: export 'wwid' to sysfs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] export 'wwid' to sysfs (Eda Zhou) [1577281]
Rebuild_FUZZ: 88.00%
commit-author Hannes Reinecke <hare@suse.de>
commit 248d4fe95f232010846bc648ce92e40b07544c5d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/248d4fe9.failed

Use scsi_vpd_lun_id() to export the world-wide unique id (wwid) to
sysfs.  Note that this is the 'best' wwid according to the rules in
scsi_vpd_lun_id(), not every possible wwid presented by the drive.

	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 248d4fe95f232010846bc648ce92e40b07544c5d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_sysfs.c
diff --cc drivers/scsi/scsi_sysfs.c
index 2773113cafc8,ef360533790d..000000000000
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@@ -967,6 -905,76 +967,79 @@@ sdev_show_function(queue_depth, "%d\n")
  static DEVICE_ATTR(queue_depth, S_IRUGO | S_IWUSR, sdev_show_queue_depth,
  		   sdev_store_queue_depth);
  
++<<<<<<< HEAD
++=======
+ static ssize_t
+ sdev_show_wwid(struct device *dev, struct device_attribute *attr,
+ 		    char *buf)
+ {
+ 	struct scsi_device *sdev = to_scsi_device(dev);
+ 	ssize_t count;
+ 
+ 	count = scsi_vpd_lun_id(sdev, buf, PAGE_SIZE);
+ 	if (count > 0) {
+ 		buf[count] = '\n';
+ 		count++;
+ 	}
+ 	return count;
+ }
+ static DEVICE_ATTR(wwid, S_IRUGO, sdev_show_wwid, NULL);
+ 
+ #ifdef CONFIG_SCSI_DH
+ static ssize_t
+ sdev_show_dh_state(struct device *dev, struct device_attribute *attr,
+ 		   char *buf)
+ {
+ 	struct scsi_device *sdev = to_scsi_device(dev);
+ 
+ 	if (!sdev->handler)
+ 		return snprintf(buf, 20, "detached\n");
+ 
+ 	return snprintf(buf, 20, "%s\n", sdev->handler->name);
+ }
+ 
+ static ssize_t
+ sdev_store_dh_state(struct device *dev, struct device_attribute *attr,
+ 		    const char *buf, size_t count)
+ {
+ 	struct scsi_device *sdev = to_scsi_device(dev);
+ 	int err = -EINVAL;
+ 
+ 	if (sdev->sdev_state == SDEV_CANCEL ||
+ 	    sdev->sdev_state == SDEV_DEL)
+ 		return -ENODEV;
+ 
+ 	if (!sdev->handler) {
+ 		/*
+ 		 * Attach to a device handler
+ 		 */
+ 		err = scsi_dh_attach(sdev->request_queue, buf);
+ 	} else if (!strncmp(buf, "activate", 8)) {
+ 		/*
+ 		 * Activate a device handler
+ 		 */
+ 		if (sdev->handler->activate)
+ 			err = sdev->handler->activate(sdev, NULL, NULL);
+ 		else
+ 			err = 0;
+ 	} else if (!strncmp(buf, "detach", 6)) {
+ 		/*
+ 		 * Detach from a device handler
+ 		 */
+ 		sdev_printk(KERN_WARNING, sdev,
+ 			    "can't detach handler %s.\n",
+ 			    sdev->handler->name);
+ 		err = -EINVAL;
+ 	}
+ 
+ 	return err < 0 ? err : count;
+ }
+ 
+ static DEVICE_ATTR(dh_state, S_IRUGO | S_IWUSR, sdev_show_dh_state,
+ 		   sdev_store_dh_state);
+ #endif
+ 
++>>>>>>> 248d4fe95f23 (scsi: export 'wwid' to sysfs)
  static ssize_t
  sdev_show_queue_ramp_up_period(struct device *dev,
  			       struct device_attribute *attr,
@@@ -1041,6 -1044,10 +1114,13 @@@ static struct attribute *scsi_sdev_attr
  	&dev_attr_modalias.attr,
  	&dev_attr_queue_depth.attr,
  	&dev_attr_queue_type.attr,
++<<<<<<< HEAD
++=======
+ 	&dev_attr_wwid.attr,
+ #ifdef CONFIG_SCSI_DH
+ 	&dev_attr_dh_state.attr,
+ #endif
++>>>>>>> 248d4fe95f23 (scsi: export 'wwid' to sysfs)
  	&dev_attr_queue_ramp_up_period.attr,
  	REF_EVT(media_change),
  	REF_EVT(inquiry_change_reported),
* Unmerged path drivers/scsi/scsi_sysfs.c
