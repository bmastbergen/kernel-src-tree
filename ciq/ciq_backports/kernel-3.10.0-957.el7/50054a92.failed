Fix bug: sometimes valid entries in hash:* types of sets were evicted

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] netfilter: sometimes valid entries in hash:* types of sets were evicted (Stefano Brivio) [1557599]
Rebuild_FUZZ: 91.43%
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 50054a9223aaf79985c55ef7dd090ced15581567
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/50054a92.failed

Wrong index was used and therefore when shrinking a hash bucket at
deleting an entry, valid entries could be evicted as well.
Thanks to Eric Ewanco for the thorough bugreport.

Fixes netfilter bugzilla #1119

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 50054a9223aaf79985c55ef7dd090ced15581567)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_hash_gen.h
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 9ce28af662bf,f236c0bc7b3f..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -694,33 -861,55 +694,50 @@@ mtype_del(struct ip_set *set, void *val
  		if (!mtype_data_equal(data, d, &multi))
  			continue;
  		if (SET_WITH_TIMEOUT(set) &&
 -		    ip_set_timeout_expired(ext_timeout(data, set)))
 -			goto out;
 +		    ip_set_timeout_expired(ext_timeout(data, h)))
 +			return -IPSET_ERR_EXIST;
 +		if (i != n->pos - 1)
 +			/* Not last one */
 +			memcpy(data, ahash_data(n, n->pos - 1, h->dsize),
 +			       h->dsize);
  
 -		ret = 0;
 -		clear_bit(i, n->used);
 -		smp_mb__after_atomic();
 -		if (i + 1 == n->pos)
 -			n->pos--;
 -		set->elements--;
 +		n->pos--;
 +		h->elements--;
  #ifdef IP_SET_HASH_WITH_NETS
 -		for (j = 0; j < IPSET_NET_COUNT; j++)
 -			mtype_del_cidr(h, NCIDR_PUT(DCIDR_GET(d->cidr, j)),
 -				       j);
 +		mtype_del_cidr(h, CIDR(d->cidr), NETS_LENGTH(set->family));
  #endif
 -		ip_set_ext_destroy(set, data);
 -
 -		for (; i < n->pos; i++) {
 -			if (!test_bit(i, n->used))
 -				k++;
 -		}
 -		if (n->pos == 0 && k == 0) {
 -			set->ext_size -= ext_size(n->size, dsize);
 -			rcu_assign_pointer(hbucket(t, key), NULL);
 -			kfree_rcu(n, rcu);
 -		} else if (k >= AHASH_INIT_SIZE) {
 -			struct hbucket *tmp = kzalloc(sizeof(*tmp) +
 -					(n->size - AHASH_INIT_SIZE) * dsize,
 -					GFP_ATOMIC);
 +		if (n->pos + AHASH_INIT_SIZE < n->size) {
 +			void *tmp = kzalloc((n->size - AHASH_INIT_SIZE)
 +					    * h->dsize,
 +					    GFP_ATOMIC);
  			if (!tmp)
++<<<<<<< HEAD
 +				return 0;
 +			n->size -= AHASH_INIT_SIZE;
 +			memcpy(tmp, n->value, n->size * h->dsize);
 +			kfree(n->value);
 +			n->value = tmp;
++=======
+ 				goto out;
+ 			tmp->size = n->size - AHASH_INIT_SIZE;
+ 			for (j = 0, k = 0; j < n->pos; j++) {
+ 				if (!test_bit(j, n->used))
+ 					continue;
+ 				data = ahash_data(n, j, dsize);
+ 				memcpy(tmp->value + k * dsize, data, dsize);
+ 				set_bit(k, tmp->used);
+ 				k++;
+ 			}
+ 			tmp->pos = k;
+ 			set->ext_size -= ext_size(AHASH_INIT_SIZE, dsize);
+ 			rcu_assign_pointer(hbucket(t, key), tmp);
+ 			kfree_rcu(n, rcu);
++>>>>>>> 50054a9223aa (Fix bug: sometimes valid entries in hash:* types of sets were evicted)
  		}
 -		goto out;
 +		return 0;
  	}
  
 -out:
 -	return ret;
 +	return -IPSET_ERR_EXIST;
  }
  
  static inline int
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
