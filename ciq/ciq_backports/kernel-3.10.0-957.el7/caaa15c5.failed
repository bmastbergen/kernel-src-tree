nvme: fix identify namespace logging

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [nvme] fix identify namespace logging (David Milburn) [1519689]
Rebuild_FUZZ: 90.91%
commit-author Sagi Grimberg <sagi@grimberg.me>
commit caaa15c5097d58545075a8bbdf208078b87d5f28
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/caaa15c5.failed

Use ctrl->device and lose the func name.

	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit caaa15c5097d58545075a8bbdf208078b87d5f28)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index 59cc4fd27db0,b2daeafbeadd..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -1043,36 -1144,35 +1043,41 @@@ static void nvme_config_discard(struct 
  	struct nvme_ctrl *ctrl = ns->ctrl;
  	u32 logical_block_size = queue_logical_block_size(ns->queue);
  
 -	BUILD_BUG_ON(PAGE_SIZE / sizeof(struct nvme_dsm_range) <
 -			NVME_DSM_MAX_RANGES);
 -
 -	if (ctrl->nr_streams && ns->sws && ns->sgs) {
 -		unsigned int sz = logical_block_size * ns->sws * ns->sgs;
 +	if (ctrl->quirks & NVME_QUIRK_DISCARD_ZEROES)
 +		ns->queue->limits.discard_zeroes_data = 1;
 +	else
 +		ns->queue->limits.discard_zeroes_data = 0;
  
 -		ns->queue->limits.discard_alignment = sz;
 -		ns->queue->limits.discard_granularity = sz;
 -	} else {
 -		ns->queue->limits.discard_alignment = logical_block_size;
 -		ns->queue->limits.discard_granularity = logical_block_size;
 -	}
 -	blk_queue_max_discard_sectors(ns->queue, UINT_MAX);
 -	blk_queue_max_discard_segments(ns->queue, NVME_DSM_MAX_RANGES);
 +	ns->queue->limits.discard_alignment = logical_block_size;
 +	ns->queue->limits.discard_granularity = logical_block_size;
 +	ns->queue->limits.max_discard_sectors = 0xffffffff;
  	queue_flag_set_unlocked(QUEUE_FLAG_DISCARD, ns->queue);
 -
 -	if (ctrl->quirks & NVME_QUIRK_DEALLOCATE_ZEROES)
 -		blk_queue_max_write_zeroes_sectors(ns->queue, UINT_MAX);
  }
  
 -static int nvme_revalidate_ns(struct nvme_ns *ns, struct nvme_id_ns **id)
 +static int nvme_revalidate_disk(struct gendisk *disk)
  {
++<<<<<<< HEAD
 +	struct nvme_ns *ns = disk->private_data;
 +	struct nvme_id_ns *id;
 +	u8 lbaf;
 +	u16 old_ms;
 +	unsigned short bs;
 +
 +	if (test_bit(NVME_NS_DEAD, &ns->flags)) {
 +		set_capacity(disk, 0);
++=======
+ 	if (nvme_identify_ns(ns->ctrl, ns->ns_id, id)) {
+ 		dev_warn(ns->ctrl->device, "Identify namespace failed\n");
++>>>>>>> caaa15c5097d (nvme: fix identify namespace logging)
  		return -ENODEV;
  	}
 -
 -	if ((*id)->ncap == 0) {
 -		kfree(*id);
 +	if (nvme_identify_ns(ns->ctrl, ns->ns_id, &id)) {
 +		dev_warn(disk_to_dev(ns->disk), "%s: Identify failure\n",
 +				__func__);
 +		return -ENODEV;
 +	}
 +	if (id->ncap == 0) {
 +		kfree(id);
  		return -ENODEV;
  	}
  
* Unmerged path drivers/nvme/host/core.c
