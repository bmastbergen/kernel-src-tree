mm: page migration fix PageMlocked on migrated pages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mm] page migration fix PageMlocked on migrated pages (Rafael Aquini) [1562137]
Rebuild_FUZZ: 96.00%
commit-author Hugh Dickins <hughd@google.com>
commit 51afb12ba809db664682a31154c11e720e2c363c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/51afb12b.failed

Commit e6c509f85455 ("mm: use clear_page_mlock() in page_remove_rmap()")
in v3.7 inadvertently made mlock_migrate_page() impotent: page migration
unmaps the page from userspace before migrating, and that commit clears
PageMlocked on the final unmap, leaving mlock_migrate_page() with
nothing to do.  Not a serious bug, the next attempt at reclaiming the
page would fix it up; but a betrayal of page migration's intent - the
new page ought to emerge as PageMlocked.

I don't see how to fix it for mlock_migrate_page() itself; but easily
fixed in remove_migration_pte(), by calling mlock_vma_page() when the vma
is VM_LOCKED - under pte lock as in try_to_unmap_one().

Delete mlock_migrate_page()?  Not quite, it does still serve a purpose for
migrate_misplaced_transhuge_page(): where we could replace it by a test,
clear_page_mlock(), mlock_vma_page() sequence; but would that be an
improvement?  mlock_migrate_page() is fairly lean, and let's make it
leaner by skipping the irq save/restore now clearly not needed.

	Signed-off-by: Hugh Dickins <hughd@google.com>
	Cc: Christoph Lameter <cl@linux.com>
	Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
	Cc: Rik van Riel <riel@redhat.com>
	Acked-by: Vlastimil Babka <vbabka@suse.cz>
	Cc: Davidlohr Bueso <dave@stgolabs.net>
	Cc: Oleg Nesterov <oleg@redhat.com>
	Cc: Sasha Levin <sasha.levin@oracle.com>
	Cc: Dmitry Vyukov <dvyukov@google.com>
	Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 51afb12ba809db664682a31154c11e720e2c363c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/migrate.c
diff --cc mm/migrate.c
index 50c754f07cf8,ed72c499df8a..000000000000
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@@ -1884,14 -1830,11 +1885,20 @@@ fail_putback
  		goto fail_putback;
  	}
  
++<<<<<<< HEAD
++=======
+ 	mlock_migrate_page(new_page, page);
+ 	mem_cgroup_migrate(page, new_page, false);
+ 
++>>>>>>> 51afb12ba809 (mm: page migration fix PageMlocked on migrated pages)
  	page_remove_rmap(page);
  
 +	/*
 +	 * Finish the charge transaction under the page table lock to
 +	 * prevent split_huge_page() from dividing up the charge
 +	 * before it's fully transferred to the new page.
 +	 */
 +	mem_cgroup_end_migration(memcg, page, new_page, true);
  	spin_unlock(ptl);
  	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
  
diff --git a/mm/internal.h b/mm/internal.h
index 362e1a30bdaf..a510f85ebb16 100644
--- a/mm/internal.h
+++ b/mm/internal.h
@@ -211,20 +211,19 @@ extern unsigned int munlock_vma_page(struct page *page);
 extern void clear_page_mlock(struct page *page);
 
 /*
- * mlock_migrate_page - called only from migrate_page_copy() to
- * migrate the Mlocked page flag; update statistics.
+ * mlock_migrate_page - called only from migrate_misplaced_transhuge_page()
+ * (because that does not go through the full procedure of migration ptes):
+ * to migrate the Mlocked page flag; update statistics.
  */
 static inline void mlock_migrate_page(struct page *newpage, struct page *page)
 {
 	if (TestClearPageMlocked(page)) {
-		unsigned long flags;
 		int nr_pages = hpage_nr_pages(page);
 
-		local_irq_save(flags);
+		/* Holding pmd lock, no change in irq context: __mod is safe */
 		__mod_zone_page_state(page_zone(page), NR_MLOCK, -nr_pages);
 		SetPageMlocked(newpage);
 		__mod_zone_page_state(page_zone(newpage), NR_MLOCK, nr_pages);
-		local_irq_restore(flags);
 	}
 }
 
* Unmerged path mm/migrate.c
