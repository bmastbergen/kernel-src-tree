mlxsw: spectrum: qdiscs: Support PRIO qdisc offload

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Nogah Frankel <nogahf@mellanox.com>
commit 46a3615be43631fc804b179cbfeabded8c3a7a5d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/46a3615b.failed

Add support for offloading PRIO qdisc as root qdisc.
The support is for up to 8 bands.
Routed packets priority is determined by the DSCP field with the default
translations. Bridged packets priority is determined by the PCP field, if
exist, otherwise it is set to 0.
Since both options have only priorities 0-7, higher priorities mapping are
being ignored.

	Signed-off-by: Nogah Frankel <nogahf@mellanox.com>
	Reviewed-by: Yuval Mintz <yuvalm@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 46a3615be43631fc804b179cbfeabded8c3a7a5d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
index b5397da94d7f,4dd20540fe5e..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
@@@ -41,6 -41,141 +41,144 @@@
  #include "spectrum.h"
  #include "reg.h"
  
++<<<<<<< HEAD
++=======
+ #define MLXSW_SP_PRIO_BAND_TO_TCLASS(band) (IEEE_8021QAZ_MAX_TCS - band - 1)
+ 
+ enum mlxsw_sp_qdisc_type {
+ 	MLXSW_SP_QDISC_NO_QDISC,
+ 	MLXSW_SP_QDISC_RED,
+ 	MLXSW_SP_QDISC_PRIO,
+ };
+ 
+ struct mlxsw_sp_qdisc_ops {
+ 	enum mlxsw_sp_qdisc_type type;
+ 	int (*check_params)(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			    struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			    void *params);
+ 	int (*replace)(struct mlxsw_sp_port *mlxsw_sp_port,
+ 		       struct mlxsw_sp_qdisc *mlxsw_sp_qdisc, void *params);
+ 	int (*destroy)(struct mlxsw_sp_port *mlxsw_sp_port,
+ 		       struct mlxsw_sp_qdisc *mlxsw_sp_qdisc);
+ 	int (*get_stats)(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			 struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			 struct tc_qopt_offload_stats *stats_ptr);
+ 	int (*get_xstats)(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			  struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			  void *xstats_ptr);
+ 	void (*clean_stats)(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			    struct mlxsw_sp_qdisc *mlxsw_sp_qdisc);
+ };
+ 
+ struct mlxsw_sp_qdisc {
+ 	u32 handle;
+ 	u8 tclass_num;
+ 	union {
+ 		struct red_stats red;
+ 	} xstats_base;
+ 	struct mlxsw_sp_qdisc_stats {
+ 		u64 tx_bytes;
+ 		u64 tx_packets;
+ 		u64 drops;
+ 		u64 overlimits;
+ 	} stats_base;
+ 
+ 	struct mlxsw_sp_qdisc_ops *ops;
+ };
+ 
+ static bool
+ mlxsw_sp_qdisc_compare(struct mlxsw_sp_qdisc *mlxsw_sp_qdisc, u32 handle,
+ 		       enum mlxsw_sp_qdisc_type type)
+ {
+ 	return mlxsw_sp_qdisc && mlxsw_sp_qdisc->ops &&
+ 	       mlxsw_sp_qdisc->ops->type == type &&
+ 	       mlxsw_sp_qdisc->handle == handle;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_destroy(struct mlxsw_sp_port *mlxsw_sp_port,
+ 		       struct mlxsw_sp_qdisc *mlxsw_sp_qdisc)
+ {
+ 	int err = 0;
+ 
+ 	if (!mlxsw_sp_qdisc)
+ 		return 0;
+ 
+ 	if (mlxsw_sp_qdisc->ops && mlxsw_sp_qdisc->ops->destroy)
+ 		err = mlxsw_sp_qdisc->ops->destroy(mlxsw_sp_port,
+ 						   mlxsw_sp_qdisc);
+ 
+ 	mlxsw_sp_qdisc->handle = TC_H_UNSPEC;
+ 	mlxsw_sp_qdisc->ops = NULL;
+ 	return err;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_replace(struct mlxsw_sp_port *mlxsw_sp_port, u32 handle,
+ 		       struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 		       struct mlxsw_sp_qdisc_ops *ops, void *params)
+ {
+ 	int err;
+ 
+ 	if (mlxsw_sp_qdisc->ops && mlxsw_sp_qdisc->ops->type != ops->type)
+ 		/* In case this location contained a different qdisc of the
+ 		 * same type we can override the old qdisc configuration.
+ 		 * Otherwise, we need to remove the old qdisc before setting the
+ 		 * new one.
+ 		 */
+ 		mlxsw_sp_qdisc_destroy(mlxsw_sp_port, mlxsw_sp_qdisc);
+ 	err = ops->check_params(mlxsw_sp_port, mlxsw_sp_qdisc, params);
+ 	if (err)
+ 		goto err_bad_param;
+ 
+ 	err = ops->replace(mlxsw_sp_port, mlxsw_sp_qdisc, params);
+ 	if (err)
+ 		goto err_config;
+ 
+ 	if (mlxsw_sp_qdisc->handle != handle) {
+ 		mlxsw_sp_qdisc->ops = ops;
+ 		if (ops->clean_stats)
+ 			ops->clean_stats(mlxsw_sp_port, mlxsw_sp_qdisc);
+ 	}
+ 
+ 	mlxsw_sp_qdisc->handle = handle;
+ 	return 0;
+ 
+ err_bad_param:
+ err_config:
+ 	mlxsw_sp_qdisc_destroy(mlxsw_sp_port, mlxsw_sp_qdisc);
+ 	return err;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_get_stats(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			 struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			 struct tc_qopt_offload_stats *stats_ptr)
+ {
+ 	if (mlxsw_sp_qdisc && mlxsw_sp_qdisc->ops &&
+ 	    mlxsw_sp_qdisc->ops->get_stats)
+ 		return mlxsw_sp_qdisc->ops->get_stats(mlxsw_sp_port,
+ 						      mlxsw_sp_qdisc,
+ 						      stats_ptr);
+ 
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_get_xstats(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			  struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			  void *xstats_ptr)
+ {
+ 	if (mlxsw_sp_qdisc && mlxsw_sp_qdisc->ops &&
+ 	    mlxsw_sp_qdisc->ops->get_xstats)
+ 		return mlxsw_sp_qdisc->ops->get_xstats(mlxsw_sp_port,
+ 						      mlxsw_sp_qdisc,
+ 						      xstats_ptr);
+ 
+ 	return -EOPNOTSUPP;
+ }
+ 
++>>>>>>> 46a3615be436 (mlxsw: spectrum: qdiscs: Support PRIO qdisc offload)
  static int
  mlxsw_sp_tclass_congestion_enable(struct mlxsw_sp_port *mlxsw_sp_port,
  				  int tclass_num, u32 min, u32 max,
@@@ -275,3 -405,99 +413,102 @@@ int mlxsw_sp_setup_tc_red(struct mlxsw_
  		return -EOPNOTSUPP;
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ static int
+ mlxsw_sp_qdisc_prio_destroy(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			    struct mlxsw_sp_qdisc *mlxsw_sp_qdisc)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)
+ 		mlxsw_sp_port_prio_tc_set(mlxsw_sp_port, i,
+ 					  MLXSW_SP_PORT_DEFAULT_TCLASS);
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_prio_check_params(struct mlxsw_sp_port *mlxsw_sp_port,
+ 				 struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 				 void *params)
+ {
+ 	struct tc_prio_qopt_offload_params *p = params;
+ 
+ 	if (p->bands > IEEE_8021QAZ_MAX_TCS)
+ 		return -EOPNOTSUPP;
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_prio_replace(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			    struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			    void *params)
+ {
+ 	struct tc_prio_qopt_offload_params *p = params;
+ 	int tclass, i;
+ 	int err;
+ 
+ 	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+ 		tclass = MLXSW_SP_PRIO_BAND_TO_TCLASS(p->priomap[i]);
+ 		err = mlxsw_sp_port_prio_tc_set(mlxsw_sp_port, i, tclass);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static struct mlxsw_sp_qdisc_ops mlxsw_sp_qdisc_ops_prio = {
+ 	.type = MLXSW_SP_QDISC_PRIO,
+ 	.check_params = mlxsw_sp_qdisc_prio_check_params,
+ 	.replace = mlxsw_sp_qdisc_prio_replace,
+ 	.destroy = mlxsw_sp_qdisc_prio_destroy,
+ };
+ 
+ int mlxsw_sp_setup_tc_prio(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			   struct tc_prio_qopt_offload *p)
+ {
+ 	struct mlxsw_sp_qdisc *mlxsw_sp_qdisc;
+ 
+ 	if (p->parent != TC_H_ROOT)
+ 		return -EOPNOTSUPP;
+ 
+ 	mlxsw_sp_qdisc = mlxsw_sp_port->root_qdisc;
+ 	if (p->command == TC_PRIO_REPLACE)
+ 		return mlxsw_sp_qdisc_replace(mlxsw_sp_port, p->handle,
+ 					      mlxsw_sp_qdisc,
+ 					      &mlxsw_sp_qdisc_ops_prio,
+ 					      &p->replace_params);
+ 
+ 	if (!mlxsw_sp_qdisc_compare(mlxsw_sp_qdisc, p->handle,
+ 				    MLXSW_SP_QDISC_PRIO))
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (p->command) {
+ 	case TC_PRIO_DESTROY:
+ 		return mlxsw_sp_qdisc_destroy(mlxsw_sp_port, mlxsw_sp_qdisc);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ int mlxsw_sp_tc_qdisc_init(struct mlxsw_sp_port *mlxsw_sp_port)
+ {
+ 	mlxsw_sp_port->root_qdisc = kzalloc(sizeof(*mlxsw_sp_port->root_qdisc),
+ 					    GFP_KERNEL);
+ 	if (!mlxsw_sp_port->root_qdisc)
+ 		return -ENOMEM;
+ 
+ 	mlxsw_sp_port->root_qdisc->tclass_num = MLXSW_SP_PORT_DEFAULT_TCLASS;
+ 
+ 	return 0;
+ }
+ 
+ void mlxsw_sp_tc_qdisc_fini(struct mlxsw_sp_port *mlxsw_sp_port)
+ {
+ 	kfree(mlxsw_sp_port->root_qdisc);
+ }
++>>>>>>> 46a3615be436 (mlxsw: spectrum: qdiscs: Support PRIO qdisc offload)
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
index 927ce93af842..1ccf1d52eecb 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
@@ -1834,6 +1834,8 @@ static int mlxsw_sp_setup_tc(struct net_device *dev, enum tc_setup_type type,
 		return mlxsw_sp_setup_tc_block(mlxsw_sp_port, type_data);
 	case TC_SETUP_QDISC_RED:
 		return mlxsw_sp_setup_tc_red(mlxsw_sp_port, type_data);
+	case TC_SETUP_QDISC_PRIO:
+		return mlxsw_sp_setup_tc_prio(mlxsw_sp_port, type_data);
 	default:
 		return -EOPNOTSUPP;
 	}
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
index e8dbdc53d070..57883ae4ad4e 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
@@ -570,6 +570,8 @@ int mlxsw_sp_flower_stats(struct mlxsw_sp_port *mlxsw_sp_port, bool ingress,
 /* spectrum_qdisc.c */
 int mlxsw_sp_setup_tc_red(struct mlxsw_sp_port *mlxsw_sp_port,
 			  struct tc_red_qopt_offload *p);
+int mlxsw_sp_setup_tc_prio(struct mlxsw_sp_port *mlxsw_sp_port,
+			   struct tc_prio_qopt_offload *p);
 
 /* spectrum_fid.c */
 int mlxsw_sp_fid_flood_set(struct mlxsw_sp_fid *fid,
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
