cxgb4: enable inner header checksum calculation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ganesh Goudar <ganeshgr@chelsio.com>
commit c50ae55e41ee226b96cf204cd1409bc0057b484e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c50ae55e.failed

set cntrl bits to indicate whether inner header checksum
needs to be calculated whenever the packet is an encapsulated
packet and enable supported encap features.

Fixes: d0a1299c6bf7 ("cxgb4: add support for vxlan segmentation offload")
	Signed-off-by: Ganesh Goudar <ganeshgr@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c50ae55e41ee226b96cf204cd1409bc0057b484e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
#	drivers/net/ethernet/chelsio/cxgb4/sge.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index df3df86da091,1e31b9dfffee..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -5298,6 -5625,17 +5298,20 @@@ static int init_one(struct pci_dev *pde
  			NETIF_F_RXCSUM | NETIF_F_RXHASH |
  			NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX |
  			NETIF_F_HW_TC;
++<<<<<<< HEAD
++=======
+ 
+ 		if (CHELSIO_CHIP_VERSION(chip) > CHELSIO_T5) {
+ 			netdev->hw_enc_features |= NETIF_F_IP_CSUM |
+ 						   NETIF_F_IPV6_CSUM |
+ 						   NETIF_F_RXCSUM |
+ 						   NETIF_F_GSO_UDP_TUNNEL |
+ 						   NETIF_F_TSO | NETIF_F_TSO6;
+ 
+ 			netdev->hw_features |= NETIF_F_GSO_UDP_TUNNEL;
+ 		}
+ 
++>>>>>>> c50ae55e41ee (cxgb4: enable inner header checksum calculation)
  		if (highdma)
  			netdev->hw_features |= NETIF_F_HIGHDMA;
  		netdev->features |= netdev->hw_features;
diff --cc drivers/net/ethernet/chelsio/cxgb4/sge.c
index a64f3863f5c9,0f87e973a158..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/sge.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/sge.c
@@@ -1222,33 -1416,71 +1247,59 @@@ out_free:	dev_kfree_skb_any(skb)
  		bool v6 = (ssi->gso_type & SKB_GSO_TCPV6) != 0;
  		int l3hdr_len = skb_network_header_len(skb);
  		int eth_xtra_len = skb_network_offset(skb) - ETH_HLEN;
 -		struct cpl_tx_tnl_lso *tnl_lso = (void *)(wr + 1);
 -
 -		if (tnl_type)
 -			len += sizeof(*tnl_lso);
 -		else
 -			len += sizeof(*lso);
  
 +		len += sizeof(*lso);
  		wr->op_immdlen = htonl(FW_WR_OP_V(FW_ETH_TX_PKT_WR) |
  				       FW_WR_IMMDLEN_V(len));
 -		if (tnl_type) {
 -			struct iphdr *iph = ip_hdr(skb);
 +		lso->c.lso_ctrl = htonl(LSO_OPCODE_V(CPL_TX_PKT_LSO) |
 +					LSO_FIRST_SLICE_F | LSO_LAST_SLICE_F |
 +					LSO_IPV6_V(v6) |
 +					LSO_ETHHDR_LEN_V(eth_xtra_len / 4) |
 +					LSO_IPHDR_LEN_V(l3hdr_len / 4) |
 +					LSO_TCPHDR_LEN_V(tcp_hdr(skb)->doff));
 +		lso->c.ipid_ofst = htons(0);
 +		lso->c.mss = htons(ssi->gso_size);
 +		lso->c.seqno_offset = htonl(0);
 +		if (is_t4(adap->params.chip))
 +			lso->c.len = htonl(skb->len);
 +		else
 +			lso->c.len = htonl(LSO_T5_XFER_SIZE_V(skb->len));
 +		cpl = (void *)(lso + 1);
  
 -			t6_fill_tnl_lso(skb, tnl_lso, tnl_type);
 -			cpl = (void *)(tnl_lso + 1);
 -			/* Driver is expected to compute partial checksum that
 -			 * does not include the IP Total Length.
 -			 */
 -			if (iph->version == 4) {
 -				iph->check = 0;
 -				iph->tot_len = 0;
 -				iph->check = (u16)(~ip_fast_csum((u8 *)iph,
 -								 iph->ihl));
 -			}
 -			if (skb->ip_summed == CHECKSUM_PARTIAL)
 -				cntrl = hwcsum(adap->params.chip, skb);
 -		} else {
 -			lso->c.lso_ctrl = htonl(LSO_OPCODE_V(CPL_TX_PKT_LSO) |
 -					  LSO_FIRST_SLICE_F | LSO_LAST_SLICE_F |
 -					  LSO_IPV6_V(v6) |
 -					  LSO_ETHHDR_LEN_V(eth_xtra_len / 4) |
 -					  LSO_IPHDR_LEN_V(l3hdr_len / 4) |
 -					  LSO_TCPHDR_LEN_V(tcp_hdr(skb)->doff));
 -			lso->c.ipid_ofst = htons(0);
 -			lso->c.mss = htons(ssi->gso_size);
 -			lso->c.seqno_offset = htonl(0);
 -			if (is_t4(adap->params.chip))
 -				lso->c.len = htonl(skb->len);
 -			else
 -				lso->c.len =
 -					htonl(LSO_T5_XFER_SIZE_V(skb->len));
 -			cpl = (void *)(lso + 1);
 +		if (CHELSIO_CHIP_VERSION(adap->params.chip) <= CHELSIO_T5)
 +			cntrl =	TXPKT_ETHHDR_LEN_V(eth_xtra_len);
 +		else
 +			cntrl = T6_TXPKT_ETHHDR_LEN_V(eth_xtra_len);
  
++<<<<<<< HEAD
 +		cntrl |= TXPKT_CSUM_TYPE_V(v6 ?
 +					   TX_CSUM_TCPIP6 : TX_CSUM_TCPIP) |
 +			 TXPKT_IPHDR_LEN_V(l3hdr_len);
++=======
+ 			if (CHELSIO_CHIP_VERSION(adap->params.chip)
+ 			    <= CHELSIO_T5)
+ 				cntrl =	TXPKT_ETHHDR_LEN_V(eth_xtra_len);
+ 			else
+ 				cntrl = T6_TXPKT_ETHHDR_LEN_V(eth_xtra_len);
+ 
+ 			cntrl |= TXPKT_CSUM_TYPE_V(v6 ?
+ 				 TX_CSUM_TCPIP6 : TX_CSUM_TCPIP) |
+ 				 TXPKT_IPHDR_LEN_V(l3hdr_len);
+ 		}
+ 		sgl = (u64 *)(cpl + 1); /* sgl start here */
+ 		if (unlikely((u8 *)sgl >= (u8 *)q->q.stat)) {
+ 			/* If current position is already at the end of the
+ 			 * txq, reset the current to point to start of the queue
+ 			 * and update the end ptr as well.
+ 			 */
+ 			if (sgl == (u64 *)q->q.stat) {
+ 				int left = (u8 *)end - (u8 *)q->q.stat;
+ 
+ 				end = (void *)q->q.desc + left;
+ 				sgl = (void *)q->q.desc;
+ 			}
+ 		}
++>>>>>>> c50ae55e41ee (cxgb4: enable inner header checksum calculation)
  		q->tso++;
  		q->tx_cso += ssi->gso_segs;
  	} else {
@@@ -1289,13 -1526,12 +1341,22 @@@
  	cpl->ctrl1 = cpu_to_be64(cntrl);
  
  	if (immediate) {
++<<<<<<< HEAD
 +		inline_tx_skb(skb, &q->q, cpl + 1);
 +		consume_skb(skb);
 +	} else {
 +		int last_desc;
 +
 +		write_sgl(skb, &q->q, (struct ulptx_sgl *)(cpl + 1), end, 0,
 +			  addr);
++=======
+ 		cxgb4_inline_tx_skb(skb, &q->q, sgl);
+ 		dev_consume_skb_any(skb);
+ 	} else {
+ 		int last_desc;
+ 
+ 		cxgb4_write_sgl(skb, &q->q, (void *)sgl, end, 0, addr);
++>>>>>>> c50ae55e41ee (cxgb4: enable inner header checksum calculation)
  		skb_orphan(skb);
  
  		last_desc = q->q.pidx + ndesc - 1;
@@@ -2172,11 -2514,37 +2238,17 @@@ int t4_ethrx_handler(struct sge_rspq *q
  		} else if (pkt->l2info & htonl(RXF_IP_F)) {
  			__sum16 c = (__force __sum16)pkt->csum;
  			skb->csum = csum_unfold(c);
- 			skb->ip_summed = CHECKSUM_COMPLETE;
+ 
+ 			if (tnl_hdr_len) {
+ 				skb->ip_summed = CHECKSUM_UNNECESSARY;
+ 				skb->csum_level = 1;
+ 			} else {
+ 				skb->ip_summed = CHECKSUM_COMPLETE;
+ 			}
  			rxq->stats.rx_cso++;
  		}
 -	} else {
 +	} else
  		skb_checksum_none_assert(skb);
 -#ifdef CONFIG_CHELSIO_T4_FCOE
 -#define CPL_RX_PKT_FLAGS (RXF_PSH_F | RXF_SYN_F | RXF_UDP_F | \
 -			  RXF_TCP_F | RXF_IP_F | RXF_IP6_F | RXF_LRO_F)
 -
 -		if (!(pkt->l2info & cpu_to_be32(CPL_RX_PKT_FLAGS))) {
 -			if ((pkt->l2info & cpu_to_be32(RXF_FCOE_F)) &&
 -			    (pi->fcoe.flags & CXGB_FCOE_ENABLED)) {
 -				if (q->adap->params.tp.rx_pkt_encap)
 -					csum_ok = err_vec &
 -						  T6_COMPR_RXERR_SUM_F;
 -				else
 -					csum_ok = err_vec & RXERR_CSUM_F;
 -				if (!csum_ok)
 -					skb->ip_summed = CHECKSUM_UNNECESSARY;
 -			}
 -		}
 -
 -#undef CPL_RX_PKT_FLAGS
 -#endif /* CONFIG_CHELSIO_T4_FCOE */
 -	}
  
  	if (unlikely(pkt->vlan_ex)) {
  		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), ntohs(pkt->vlan));
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/sge.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4_msg.h b/drivers/net/ethernet/chelsio/cxgb4/t4_msg.h
index 283286a6c3e3..91de4115d2d4 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_msg.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_msg.h
@@ -1205,6 +1205,11 @@ struct cpl_rx_pkt {
 #define T6_COMPR_RXERR_SUM_V(x) ((x) << T6_COMPR_RXERR_SUM_S)
 #define T6_COMPR_RXERR_SUM_F    T6_COMPR_RXERR_SUM_V(1U)
 
+#define T6_RX_TNLHDR_LEN_S    8
+#define T6_RX_TNLHDR_LEN_M    0xFF
+#define T6_RX_TNLHDR_LEN_V(x) ((x) << T6_RX_TNLHDR_LEN_S)
+#define T6_RX_TNLHDR_LEN_G(x) (((x) >> T6_RX_TNLHDR_LEN_S) & T6_RX_TNLHDR_LEN_M)
+
 struct cpl_trace_pkt {
 	u8 opcode;
 	u8 intf;
