bpf: add BPF_J{LT,LE,SLT,SLE} instructions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [kernel] bpf: add BPF_J(LT, LE, SLT, SLE) instructions (Jiri Olsa) [1311586]
Rebuild_FUZZ: 91.95%
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit 92b31a9af73b3a3fc801899335d6c47966351830
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/92b31a9a.failed

Currently, eBPF only understands BPF_JGT (>), BPF_JGE (>=),
BPF_JSGT (s>), BPF_JSGE (s>=) instructions, this means that
particularly *JLT/*JLE counterparts involving immediates need
to be rewritten from e.g. X < [IMM] by swapping arguments into
[IMM] > X, meaning the immediate first is required to be loaded
into a register Y := [IMM], such that then we can compare with
Y > X. Note that the destination operand is always required to
be a register.

This has the downside of having unnecessarily increased register
pressure, meaning complex program would need to spill other
registers temporarily to stack in order to obtain an unused
register for the [IMM]. Loading to registers will thus also
affect state pruning since we need to account for that register
use and potentially those registers that had to be spilled/filled
again. As a consequence slightly more stack space might have
been used due to spilling, and BPF programs are a bit longer
due to extra code involving the register load and potentially
required spill/fills.

Thus, add BPF_JLT (<), BPF_JLE (<=), BPF_JSLT (s<), BPF_JSLE (s<=)
counterparts to the eBPF instruction set. Modifying LLVM to
remove the NegateCC() workaround in a PoC patch at [1] and
allowing it to also emit the new instructions resulted in
cilium's BPF programs that are injected into the fast-path to
have a reduced program length in the range of 2-3% (e.g.
accumulated main and tail call sections from one of the object
file reduced from 4864 to 4729 insns), reduced complexity in
the range of 10-30% (e.g. accumulated sections reduced in one
of the cases from 116432 to 88428 insns), and reduced stack
usage in the range of 1-5% (e.g. accumulated sections from one
of the object files reduced from 824 to 784b).

The modification for LLVM will be incorporated in a backwards
compatible way. Plan is for LLVM to have i) a target specific
option to offer a possibility to explicitly enable the extension
by the user (as we have with -m target specific extensions today
for various CPU insns), and ii) have the kernel checked for
presence of the extensions and enable them transparently when
the user is selecting more aggressive options such as -march=native
in a bpf target context. (Other frontends generating BPF byte
code, e.g. ply can probe the kernel directly for its code
generation.)

  [1] https://github.com/borkmann/llvm/tree/bpf-insns

	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 92b31a9af73b3a3fc801899335d6c47966351830)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/networking/filter.txt
#	kernel/bpf/core.c
#	lib/test_bpf.c
#	net/core/filter.c
#	tools/include/uapi/linux/bpf.h
diff --cc Documentation/networking/filter.txt
index e6c366bcefcd,6a0df8df6c43..000000000000
--- a/Documentation/networking/filter.txt
+++ b/Documentation/networking/filter.txt
@@@ -546,6 -560,895 +546,898 @@@ ffffffffa0069c8f + <x>
  For BPF JIT developers, bpf_jit_disasm, bpf_asm and bpf_dbg provides a useful
  toolchain for developing and testing the kernel's JIT compiler.
  
++<<<<<<< HEAD
++=======
+ BPF kernel internals
+ --------------------
+ Internally, for the kernel interpreter, a different instruction set
+ format with similar underlying principles from BPF described in previous
+ paragraphs is being used. However, the instruction set format is modelled
+ closer to the underlying architecture to mimic native instruction sets, so
+ that a better performance can be achieved (more details later). This new
+ ISA is called 'eBPF' or 'internal BPF' interchangeably. (Note: eBPF which
+ originates from [e]xtended BPF is not the same as BPF extensions! While
+ eBPF is an ISA, BPF extensions date back to classic BPF's 'overloading'
+ of BPF_LD | BPF_{B,H,W} | BPF_ABS instruction.)
+ 
+ It is designed to be JITed with one to one mapping, which can also open up
+ the possibility for GCC/LLVM compilers to generate optimized eBPF code through
+ an eBPF backend that performs almost as fast as natively compiled code.
+ 
+ The new instruction set was originally designed with the possible goal in
+ mind to write programs in "restricted C" and compile into eBPF with a optional
+ GCC/LLVM backend, so that it can just-in-time map to modern 64-bit CPUs with
+ minimal performance overhead over two steps, that is, C -> eBPF -> native code.
+ 
+ Currently, the new format is being used for running user BPF programs, which
+ includes seccomp BPF, classic socket filters, cls_bpf traffic classifier,
+ team driver's classifier for its load-balancing mode, netfilter's xt_bpf
+ extension, PTP dissector/classifier, and much more. They are all internally
+ converted by the kernel into the new instruction set representation and run
+ in the eBPF interpreter. For in-kernel handlers, this all works transparently
+ by using bpf_prog_create() for setting up the filter, resp.
+ bpf_prog_destroy() for destroying it. The macro
+ BPF_PROG_RUN(filter, ctx) transparently invokes eBPF interpreter or JITed
+ code to run the filter. 'filter' is a pointer to struct bpf_prog that we
+ got from bpf_prog_create(), and 'ctx' the given context (e.g.
+ skb pointer). All constraints and restrictions from bpf_check_classic() apply
+ before a conversion to the new layout is being done behind the scenes!
+ 
+ Currently, the classic BPF format is being used for JITing on most 32-bit
+ architectures, whereas x86-64, aarch64, s390x, powerpc64, sparc64 perform JIT
+ compilation from eBPF instruction set.
+ 
+ Some core changes of the new internal format:
+ 
+ - Number of registers increase from 2 to 10:
+ 
+   The old format had two registers A and X, and a hidden frame pointer. The
+   new layout extends this to be 10 internal registers and a read-only frame
+   pointer. Since 64-bit CPUs are passing arguments to functions via registers
+   the number of args from eBPF program to in-kernel function is restricted
+   to 5 and one register is used to accept return value from an in-kernel
+   function. Natively, x86_64 passes first 6 arguments in registers, aarch64/
+   sparcv9/mips64 have 7 - 8 registers for arguments; x86_64 has 6 callee saved
+   registers, and aarch64/sparcv9/mips64 have 11 or more callee saved registers.
+ 
+   Therefore, eBPF calling convention is defined as:
+ 
+     * R0	- return value from in-kernel function, and exit value for eBPF program
+     * R1 - R5	- arguments from eBPF program to in-kernel function
+     * R6 - R9	- callee saved registers that in-kernel function will preserve
+     * R10	- read-only frame pointer to access stack
+ 
+   Thus, all eBPF registers map one to one to HW registers on x86_64, aarch64,
+   etc, and eBPF calling convention maps directly to ABIs used by the kernel on
+   64-bit architectures.
+ 
+   On 32-bit architectures JIT may map programs that use only 32-bit arithmetic
+   and may let more complex programs to be interpreted.
+ 
+   R0 - R5 are scratch registers and eBPF program needs spill/fill them if
+   necessary across calls. Note that there is only one eBPF program (== one
+   eBPF main routine) and it cannot call other eBPF functions, it can only
+   call predefined in-kernel functions, though.
+ 
+ - Register width increases from 32-bit to 64-bit:
+ 
+   Still, the semantics of the original 32-bit ALU operations are preserved
+   via 32-bit subregisters. All eBPF registers are 64-bit with 32-bit lower
+   subregisters that zero-extend into 64-bit if they are being written to.
+   That behavior maps directly to x86_64 and arm64 subregister definition, but
+   makes other JITs more difficult.
+ 
+   32-bit architectures run 64-bit internal BPF programs via interpreter.
+   Their JITs may convert BPF programs that only use 32-bit subregisters into
+   native instruction set and let the rest being interpreted.
+ 
+   Operation is 64-bit, because on 64-bit architectures, pointers are also
+   64-bit wide, and we want to pass 64-bit values in/out of kernel functions,
+   so 32-bit eBPF registers would otherwise require to define register-pair
+   ABI, thus, there won't be able to use a direct eBPF register to HW register
+   mapping and JIT would need to do combine/split/move operations for every
+   register in and out of the function, which is complex, bug prone and slow.
+   Another reason is the use of atomic 64-bit counters.
+ 
+ - Conditional jt/jf targets replaced with jt/fall-through:
+ 
+   While the original design has constructs such as "if (cond) jump_true;
+   else jump_false;", they are being replaced into alternative constructs like
+   "if (cond) jump_true; /* else fall-through */".
+ 
+ - Introduces bpf_call insn and register passing convention for zero overhead
+   calls from/to other kernel functions:
+ 
+   Before an in-kernel function call, the internal BPF program needs to
+   place function arguments into R1 to R5 registers to satisfy calling
+   convention, then the interpreter will take them from registers and pass
+   to in-kernel function. If R1 - R5 registers are mapped to CPU registers
+   that are used for argument passing on given architecture, the JIT compiler
+   doesn't need to emit extra moves. Function arguments will be in the correct
+   registers and BPF_CALL instruction will be JITed as single 'call' HW
+   instruction. This calling convention was picked to cover common call
+   situations without performance penalty.
+ 
+   After an in-kernel function call, R1 - R5 are reset to unreadable and R0 has
+   a return value of the function. Since R6 - R9 are callee saved, their state
+   is preserved across the call.
+ 
+   For example, consider three C functions:
+ 
+   u64 f1() { return (*_f2)(1); }
+   u64 f2(u64 a) { return f3(a + 1, a); }
+   u64 f3(u64 a, u64 b) { return a - b; }
+ 
+   GCC can compile f1, f3 into x86_64:
+ 
+   f1:
+     movl $1, %edi
+     movq _f2(%rip), %rax
+     jmp  *%rax
+   f3:
+     movq %rdi, %rax
+     subq %rsi, %rax
+     ret
+ 
+   Function f2 in eBPF may look like:
+ 
+   f2:
+     bpf_mov R2, R1
+     bpf_add R1, 1
+     bpf_call f3
+     bpf_exit
+ 
+   If f2 is JITed and the pointer stored to '_f2'. The calls f1 -> f2 -> f3 and
+   returns will be seamless. Without JIT, __bpf_prog_run() interpreter needs to
+   be used to call into f2.
+ 
+   For practical reasons all eBPF programs have only one argument 'ctx' which is
+   already placed into R1 (e.g. on __bpf_prog_run() startup) and the programs
+   can call kernel functions with up to 5 arguments. Calls with 6 or more arguments
+   are currently not supported, but these restrictions can be lifted if necessary
+   in the future.
+ 
+   On 64-bit architectures all register map to HW registers one to one. For
+   example, x86_64 JIT compiler can map them as ...
+ 
+     R0 - rax
+     R1 - rdi
+     R2 - rsi
+     R3 - rdx
+     R4 - rcx
+     R5 - r8
+     R6 - rbx
+     R7 - r13
+     R8 - r14
+     R9 - r15
+     R10 - rbp
+ 
+   ... since x86_64 ABI mandates rdi, rsi, rdx, rcx, r8, r9 for argument passing
+   and rbx, r12 - r15 are callee saved.
+ 
+   Then the following internal BPF pseudo-program:
+ 
+     bpf_mov R6, R1 /* save ctx */
+     bpf_mov R2, 2
+     bpf_mov R3, 3
+     bpf_mov R4, 4
+     bpf_mov R5, 5
+     bpf_call foo
+     bpf_mov R7, R0 /* save foo() return value */
+     bpf_mov R1, R6 /* restore ctx for next call */
+     bpf_mov R2, 6
+     bpf_mov R3, 7
+     bpf_mov R4, 8
+     bpf_mov R5, 9
+     bpf_call bar
+     bpf_add R0, R7
+     bpf_exit
+ 
+   After JIT to x86_64 may look like:
+ 
+     push %rbp
+     mov %rsp,%rbp
+     sub $0x228,%rsp
+     mov %rbx,-0x228(%rbp)
+     mov %r13,-0x220(%rbp)
+     mov %rdi,%rbx
+     mov $0x2,%esi
+     mov $0x3,%edx
+     mov $0x4,%ecx
+     mov $0x5,%r8d
+     callq foo
+     mov %rax,%r13
+     mov %rbx,%rdi
+     mov $0x2,%esi
+     mov $0x3,%edx
+     mov $0x4,%ecx
+     mov $0x5,%r8d
+     callq bar
+     add %r13,%rax
+     mov -0x228(%rbp),%rbx
+     mov -0x220(%rbp),%r13
+     leaveq
+     retq
+ 
+   Which is in this example equivalent in C to:
+ 
+     u64 bpf_filter(u64 ctx)
+     {
+         return foo(ctx, 2, 3, 4, 5) + bar(ctx, 6, 7, 8, 9);
+     }
+ 
+   In-kernel functions foo() and bar() with prototype: u64 (*)(u64 arg1, u64
+   arg2, u64 arg3, u64 arg4, u64 arg5); will receive arguments in proper
+   registers and place their return value into '%rax' which is R0 in eBPF.
+   Prologue and epilogue are emitted by JIT and are implicit in the
+   interpreter. R0-R5 are scratch registers, so eBPF program needs to preserve
+   them across the calls as defined by calling convention.
+ 
+   For example the following program is invalid:
+ 
+     bpf_mov R1, 1
+     bpf_call foo
+     bpf_mov R0, R1
+     bpf_exit
+ 
+   After the call the registers R1-R5 contain junk values and cannot be read.
+   An in-kernel eBPF verifier is used to validate internal BPF programs.
+ 
+ Also in the new design, eBPF is limited to 4096 insns, which means that any
+ program will terminate quickly and will only call a fixed number of kernel
+ functions. Original BPF and the new format are two operand instructions,
+ which helps to do one-to-one mapping between eBPF insn and x86 insn during JIT.
+ 
+ The input context pointer for invoking the interpreter function is generic,
+ its content is defined by a specific use case. For seccomp register R1 points
+ to seccomp_data, for converted BPF filters R1 points to a skb.
+ 
+ A program, that is translated internally consists of the following elements:
+ 
+   op:16, jt:8, jf:8, k:32    ==>    op:8, dst_reg:4, src_reg:4, off:16, imm:32
+ 
+ So far 87 internal BPF instructions were implemented. 8-bit 'op' opcode field
+ has room for new instructions. Some of them may use 16/24/32 byte encoding. New
+ instructions must be multiple of 8 bytes to preserve backward compatibility.
+ 
+ Internal BPF is a general purpose RISC instruction set. Not every register and
+ every instruction are used during translation from original BPF to new format.
+ For example, socket filters are not using 'exclusive add' instruction, but
+ tracing filters may do to maintain counters of events, for example. Register R9
+ is not used by socket filters either, but more complex filters may be running
+ out of registers and would have to resort to spill/fill to stack.
+ 
+ Internal BPF can used as generic assembler for last step performance
+ optimizations, socket filters and seccomp are using it as assembler. Tracing
+ filters may use it as assembler to generate code from kernel. In kernel usage
+ may not be bounded by security considerations, since generated internal BPF code
+ may be optimizing internal code path and not being exposed to the user space.
+ Safety of internal BPF can come from a verifier (TBD). In such use cases as
+ described, it may be used as safe instruction set.
+ 
+ Just like the original BPF, the new format runs within a controlled environment,
+ is deterministic and the kernel can easily prove that. The safety of the program
+ can be determined in two steps: first step does depth-first-search to disallow
+ loops and other CFG validation; second step starts from the first insn and
+ descends all possible paths. It simulates execution of every insn and observes
+ the state change of registers and stack.
+ 
+ eBPF opcode encoding
+ --------------------
+ 
+ eBPF is reusing most of the opcode encoding from classic to simplify conversion
+ of classic BPF to eBPF. For arithmetic and jump instructions the 8-bit 'code'
+ field is divided into three parts:
+ 
+   +----------------+--------+--------------------+
+   |   4 bits       |  1 bit |   3 bits           |
+   | operation code | source | instruction class  |
+   +----------------+--------+--------------------+
+   (MSB)                                      (LSB)
+ 
+ Three LSB bits store instruction class which is one of:
+ 
+   Classic BPF classes:    eBPF classes:
+ 
+   BPF_LD    0x00          BPF_LD    0x00
+   BPF_LDX   0x01          BPF_LDX   0x01
+   BPF_ST    0x02          BPF_ST    0x02
+   BPF_STX   0x03          BPF_STX   0x03
+   BPF_ALU   0x04          BPF_ALU   0x04
+   BPF_JMP   0x05          BPF_JMP   0x05
+   BPF_RET   0x06          [ class 6 unused, for future if needed ]
+   BPF_MISC  0x07          BPF_ALU64 0x07
+ 
+ When BPF_CLASS(code) == BPF_ALU or BPF_JMP, 4th bit encodes source operand ...
+ 
+   BPF_K     0x00
+   BPF_X     0x08
+ 
+  * in classic BPF, this means:
+ 
+   BPF_SRC(code) == BPF_X - use register X as source operand
+   BPF_SRC(code) == BPF_K - use 32-bit immediate as source operand
+ 
+  * in eBPF, this means:
+ 
+   BPF_SRC(code) == BPF_X - use 'src_reg' register as source operand
+   BPF_SRC(code) == BPF_K - use 32-bit immediate as source operand
+ 
+ ... and four MSB bits store operation code.
+ 
+ If BPF_CLASS(code) == BPF_ALU or BPF_ALU64 [ in eBPF ], BPF_OP(code) is one of:
+ 
+   BPF_ADD   0x00
+   BPF_SUB   0x10
+   BPF_MUL   0x20
+   BPF_DIV   0x30
+   BPF_OR    0x40
+   BPF_AND   0x50
+   BPF_LSH   0x60
+   BPF_RSH   0x70
+   BPF_NEG   0x80
+   BPF_MOD   0x90
+   BPF_XOR   0xa0
+   BPF_MOV   0xb0  /* eBPF only: mov reg to reg */
+   BPF_ARSH  0xc0  /* eBPF only: sign extending shift right */
+   BPF_END   0xd0  /* eBPF only: endianness conversion */
+ 
+ If BPF_CLASS(code) == BPF_JMP, BPF_OP(code) is one of:
+ 
+   BPF_JA    0x00
+   BPF_JEQ   0x10
+   BPF_JGT   0x20
+   BPF_JGE   0x30
+   BPF_JSET  0x40
+   BPF_JNE   0x50  /* eBPF only: jump != */
+   BPF_JSGT  0x60  /* eBPF only: signed '>' */
+   BPF_JSGE  0x70  /* eBPF only: signed '>=' */
+   BPF_CALL  0x80  /* eBPF only: function call */
+   BPF_EXIT  0x90  /* eBPF only: function return */
+   BPF_JLT   0xa0  /* eBPF only: unsigned '<' */
+   BPF_JLE   0xb0  /* eBPF only: unsigned '<=' */
+   BPF_JSLT  0xc0  /* eBPF only: signed '<' */
+   BPF_JSLE  0xd0  /* eBPF only: signed '<=' */
+ 
+ So BPF_ADD | BPF_X | BPF_ALU means 32-bit addition in both classic BPF
+ and eBPF. There are only two registers in classic BPF, so it means A += X.
+ In eBPF it means dst_reg = (u32) dst_reg + (u32) src_reg; similarly,
+ BPF_XOR | BPF_K | BPF_ALU means A ^= imm32 in classic BPF and analogous
+ src_reg = (u32) src_reg ^ (u32) imm32 in eBPF.
+ 
+ Classic BPF is using BPF_MISC class to represent A = X and X = A moves.
+ eBPF is using BPF_MOV | BPF_X | BPF_ALU code instead. Since there are no
+ BPF_MISC operations in eBPF, the class 7 is used as BPF_ALU64 to mean
+ exactly the same operations as BPF_ALU, but with 64-bit wide operands
+ instead. So BPF_ADD | BPF_X | BPF_ALU64 means 64-bit addition, i.e.:
+ dst_reg = dst_reg + src_reg
+ 
+ Classic BPF wastes the whole BPF_RET class to represent a single 'ret'
+ operation. Classic BPF_RET | BPF_K means copy imm32 into return register
+ and perform function exit. eBPF is modeled to match CPU, so BPF_JMP | BPF_EXIT
+ in eBPF means function exit only. The eBPF program needs to store return
+ value into register R0 before doing a BPF_EXIT. Class 6 in eBPF is currently
+ unused and reserved for future use.
+ 
+ For load and store instructions the 8-bit 'code' field is divided as:
+ 
+   +--------+--------+-------------------+
+   | 3 bits | 2 bits |   3 bits          |
+   |  mode  |  size  | instruction class |
+   +--------+--------+-------------------+
+   (MSB)                             (LSB)
+ 
+ Size modifier is one of ...
+ 
+   BPF_W   0x00    /* word */
+   BPF_H   0x08    /* half word */
+   BPF_B   0x10    /* byte */
+   BPF_DW  0x18    /* eBPF only, double word */
+ 
+ ... which encodes size of load/store operation:
+ 
+  B  - 1 byte
+  H  - 2 byte
+  W  - 4 byte
+  DW - 8 byte (eBPF only)
+ 
+ Mode modifier is one of:
+ 
+   BPF_IMM  0x00  /* used for 32-bit mov in classic BPF and 64-bit in eBPF */
+   BPF_ABS  0x20
+   BPF_IND  0x40
+   BPF_MEM  0x60
+   BPF_LEN  0x80  /* classic BPF only, reserved in eBPF */
+   BPF_MSH  0xa0  /* classic BPF only, reserved in eBPF */
+   BPF_XADD 0xc0  /* eBPF only, exclusive add */
+ 
+ eBPF has two non-generic instructions: (BPF_ABS | <size> | BPF_LD) and
+ (BPF_IND | <size> | BPF_LD) which are used to access packet data.
+ 
+ They had to be carried over from classic to have strong performance of
+ socket filters running in eBPF interpreter. These instructions can only
+ be used when interpreter context is a pointer to 'struct sk_buff' and
+ have seven implicit operands. Register R6 is an implicit input that must
+ contain pointer to sk_buff. Register R0 is an implicit output which contains
+ the data fetched from the packet. Registers R1-R5 are scratch registers
+ and must not be used to store the data across BPF_ABS | BPF_LD or
+ BPF_IND | BPF_LD instructions.
+ 
+ These instructions have implicit program exit condition as well. When
+ eBPF program is trying to access the data beyond the packet boundary,
+ the interpreter will abort the execution of the program. JIT compilers
+ therefore must preserve this property. src_reg and imm32 fields are
+ explicit inputs to these instructions.
+ 
+ For example:
+ 
+   BPF_IND | BPF_W | BPF_LD means:
+ 
+     R0 = ntohl(*(u32 *) (((struct sk_buff *) R6)->data + src_reg + imm32))
+     and R1 - R5 were scratched.
+ 
+ Unlike classic BPF instruction set, eBPF has generic load/store operations:
+ 
+ BPF_MEM | <size> | BPF_STX:  *(size *) (dst_reg + off) = src_reg
+ BPF_MEM | <size> | BPF_ST:   *(size *) (dst_reg + off) = imm32
+ BPF_MEM | <size> | BPF_LDX:  dst_reg = *(size *) (src_reg + off)
+ BPF_XADD | BPF_W  | BPF_STX: lock xadd *(u32 *)(dst_reg + off16) += src_reg
+ BPF_XADD | BPF_DW | BPF_STX: lock xadd *(u64 *)(dst_reg + off16) += src_reg
+ 
+ Where size is one of: BPF_B or BPF_H or BPF_W or BPF_DW. Note that 1 and
+ 2 byte atomic increments are not supported.
+ 
+ eBPF has one 16-byte instruction: BPF_LD | BPF_DW | BPF_IMM which consists
+ of two consecutive 'struct bpf_insn' 8-byte blocks and interpreted as single
+ instruction that loads 64-bit immediate value into a dst_reg.
+ Classic BPF has similar instruction: BPF_LD | BPF_W | BPF_IMM which loads
+ 32-bit immediate value into a register.
+ 
+ eBPF verifier
+ -------------
+ The safety of the eBPF program is determined in two steps.
+ 
+ First step does DAG check to disallow loops and other CFG validation.
+ In particular it will detect programs that have unreachable instructions.
+ (though classic BPF checker allows them)
+ 
+ Second step starts from the first insn and descends all possible paths.
+ It simulates execution of every insn and observes the state change of
+ registers and stack.
+ 
+ At the start of the program the register R1 contains a pointer to context
+ and has type PTR_TO_CTX.
+ If verifier sees an insn that does R2=R1, then R2 has now type
+ PTR_TO_CTX as well and can be used on the right hand side of expression.
+ If R1=PTR_TO_CTX and insn is R2=R1+R1, then R2=SCALAR_VALUE,
+ since addition of two valid pointers makes invalid pointer.
+ (In 'secure' mode verifier will reject any type of pointer arithmetic to make
+ sure that kernel addresses don't leak to unprivileged users)
+ 
+ If register was never written to, it's not readable:
+   bpf_mov R0 = R2
+   bpf_exit
+ will be rejected, since R2 is unreadable at the start of the program.
+ 
+ After kernel function call, R1-R5 are reset to unreadable and
+ R0 has a return type of the function.
+ 
+ Since R6-R9 are callee saved, their state is preserved across the call.
+   bpf_mov R6 = 1
+   bpf_call foo
+   bpf_mov R0 = R6
+   bpf_exit
+ is a correct program. If there was R1 instead of R6, it would have
+ been rejected.
+ 
+ load/store instructions are allowed only with registers of valid types, which
+ are PTR_TO_CTX, PTR_TO_MAP, PTR_TO_STACK. They are bounds and alignment checked.
+ For example:
+  bpf_mov R1 = 1
+  bpf_mov R2 = 2
+  bpf_xadd *(u32 *)(R1 + 3) += R2
+  bpf_exit
+ will be rejected, since R1 doesn't have a valid pointer type at the time of
+ execution of instruction bpf_xadd.
+ 
+ At the start R1 type is PTR_TO_CTX (a pointer to generic 'struct bpf_context')
+ A callback is used to customize verifier to restrict eBPF program access to only
+ certain fields within ctx structure with specified size and alignment.
+ 
+ For example, the following insn:
+   bpf_ld R0 = *(u32 *)(R6 + 8)
+ intends to load a word from address R6 + 8 and store it into R0
+ If R6=PTR_TO_CTX, via is_valid_access() callback the verifier will know
+ that offset 8 of size 4 bytes can be accessed for reading, otherwise
+ the verifier will reject the program.
+ If R6=PTR_TO_STACK, then access should be aligned and be within
+ stack bounds, which are [-MAX_BPF_STACK, 0). In this example offset is 8,
+ so it will fail verification, since it's out of bounds.
+ 
+ The verifier will allow eBPF program to read data from stack only after
+ it wrote into it.
+ Classic BPF verifier does similar check with M[0-15] memory slots.
+ For example:
+   bpf_ld R0 = *(u32 *)(R10 - 4)
+   bpf_exit
+ is invalid program.
+ Though R10 is correct read-only register and has type PTR_TO_STACK
+ and R10 - 4 is within stack bounds, there were no stores into that location.
+ 
+ Pointer register spill/fill is tracked as well, since four (R6-R9)
+ callee saved registers may not be enough for some programs.
+ 
+ Allowed function calls are customized with bpf_verifier_ops->get_func_proto()
+ The eBPF verifier will check that registers match argument constraints.
+ After the call register R0 will be set to return type of the function.
+ 
+ Function calls is a main mechanism to extend functionality of eBPF programs.
+ Socket filters may let programs to call one set of functions, whereas tracing
+ filters may allow completely different set.
+ 
+ If a function made accessible to eBPF program, it needs to be thought through
+ from safety point of view. The verifier will guarantee that the function is
+ called with valid arguments.
+ 
+ seccomp vs socket filters have different security restrictions for classic BPF.
+ Seccomp solves this by two stage verifier: classic BPF verifier is followed
+ by seccomp verifier. In case of eBPF one configurable verifier is shared for
+ all use cases.
+ 
+ See details of eBPF verifier in kernel/bpf/verifier.c
+ 
+ Register value tracking
+ -----------------------
+ In order to determine the safety of an eBPF program, the verifier must track
+ the range of possible values in each register and also in each stack slot.
+ This is done with 'struct bpf_reg_state', defined in include/linux/
+ bpf_verifier.h, which unifies tracking of scalar and pointer values.  Each
+ register state has a type, which is either NOT_INIT (the register has not been
+ written to), SCALAR_VALUE (some value which is not usable as a pointer), or a
+ pointer type.  The types of pointers describe their base, as follows:
+     PTR_TO_CTX          Pointer to bpf_context.
+     CONST_PTR_TO_MAP    Pointer to struct bpf_map.  "Const" because arithmetic
+                         on these pointers is forbidden.
+     PTR_TO_MAP_VALUE    Pointer to the value stored in a map element.
+     PTR_TO_MAP_VALUE_OR_NULL
+                         Either a pointer to a map value, or NULL; map accesses
+                         (see section 'eBPF maps', below) return this type,
+                         which becomes a PTR_TO_MAP_VALUE when checked != NULL.
+                         Arithmetic on these pointers is forbidden.
+     PTR_TO_STACK        Frame pointer.
+     PTR_TO_PACKET       skb->data.
+     PTR_TO_PACKET_END   skb->data + headlen; arithmetic forbidden.
+ However, a pointer may be offset from this base (as a result of pointer
+ arithmetic), and this is tracked in two parts: the 'fixed offset' and 'variable
+ offset'.  The former is used when an exactly-known value (e.g. an immediate
+ operand) is added to a pointer, while the latter is used for values which are
+ not exactly known.  The variable offset is also used in SCALAR_VALUEs, to track
+ the range of possible values in the register.
+ The verifier's knowledge about the variable offset consists of:
+ * minimum and maximum values as unsigned
+ * minimum and maximum values as signed
+ * knowledge of the values of individual bits, in the form of a 'tnum': a u64
+ 'mask' and a u64 'value'.  1s in the mask represent bits whose value is unknown;
+ 1s in the value represent bits known to be 1.  Bits known to be 0 have 0 in both
+ mask and value; no bit should ever be 1 in both.  For example, if a byte is read
+ into a register from memory, the register's top 56 bits are known zero, while
+ the low 8 are unknown - which is represented as the tnum (0x0; 0xff).  If we
+ then OR this with 0x40, we get (0x40; 0xcf), then if we add 1 we get (0x0;
+ 0x1ff), because of potential carries.
+ Besides arithmetic, the register state can also be updated by conditional
+ branches.  For instance, if a SCALAR_VALUE is compared > 8, in the 'true' branch
+ it will have a umin_value (unsigned minimum value) of 9, whereas in the 'false'
+ branch it will have a umax_value of 8.  A signed compare (with BPF_JSGT or
+ BPF_JSGE) would instead update the signed minimum/maximum values.  Information
+ from the signed and unsigned bounds can be combined; for instance if a value is
+ first tested < 8 and then tested s> 4, the verifier will conclude that the value
+ is also > 4 and s< 8, since the bounds prevent crossing the sign boundary.
+ PTR_TO_PACKETs with a variable offset part have an 'id', which is common to all
+ pointers sharing that same variable offset.  This is important for packet range
+ checks: after adding some variable to a packet pointer, if you then copy it to
+ another register and (say) add a constant 4, both registers will share the same
+ 'id' but one will have a fixed offset of +4.  Then if it is bounds-checked and
+ found to be less than a PTR_TO_PACKET_END, the other register is now known to
+ have a safe range of at least 4 bytes.  See 'Direct packet access', below, for
+ more on PTR_TO_PACKET ranges.
+ The 'id' field is also used on PTR_TO_MAP_VALUE_OR_NULL, common to all copies of
+ the pointer returned from a map lookup.  This means that when one copy is
+ checked and found to be non-NULL, all copies can become PTR_TO_MAP_VALUEs.
+ As well as range-checking, the tracked information is also used for enforcing
+ alignment of pointer accesses.  For instance, on most systems the packet pointer
+ is 2 bytes after a 4-byte alignment.  If a program adds 14 bytes to that to jump
+ over the Ethernet header, then reads IHL and addes (IHL * 4), the resulting
+ pointer will have a variable offset known to be 4n+2 for some n, so adding the 2
+ bytes (NET_IP_ALIGN) gives a 4-byte alignment and so word-sized accesses through
+ that pointer are safe.
+ 
+ Direct packet access
+ --------------------
+ In cls_bpf and act_bpf programs the verifier allows direct access to the packet
+ data via skb->data and skb->data_end pointers.
+ Ex:
+ 1:  r4 = *(u32 *)(r1 +80)  /* load skb->data_end */
+ 2:  r3 = *(u32 *)(r1 +76)  /* load skb->data */
+ 3:  r5 = r3
+ 4:  r5 += 14
+ 5:  if r5 > r4 goto pc+16
+ R1=ctx R3=pkt(id=0,off=0,r=14) R4=pkt_end R5=pkt(id=0,off=14,r=14) R10=fp
+ 6:  r0 = *(u16 *)(r3 +12) /* access 12 and 13 bytes of the packet */
+ 
+ this 2byte load from the packet is safe to do, since the program author
+ did check 'if (skb->data + 14 > skb->data_end) goto err' at insn #5 which
+ means that in the fall-through case the register R3 (which points to skb->data)
+ has at least 14 directly accessible bytes. The verifier marks it
+ as R3=pkt(id=0,off=0,r=14).
+ id=0 means that no additional variables were added to the register.
+ off=0 means that no additional constants were added.
+ r=14 is the range of safe access which means that bytes [R3, R3 + 14) are ok.
+ Note that R5 is marked as R5=pkt(id=0,off=14,r=14). It also points
+ to the packet data, but constant 14 was added to the register, so
+ it now points to 'skb->data + 14' and accessible range is [R5, R5 + 14 - 14)
+ which is zero bytes.
+ 
+ More complex packet access may look like:
+  R0=inv1 R1=ctx R3=pkt(id=0,off=0,r=14) R4=pkt_end R5=pkt(id=0,off=14,r=14) R10=fp
+  6:  r0 = *(u8 *)(r3 +7) /* load 7th byte from the packet */
+  7:  r4 = *(u8 *)(r3 +12)
+  8:  r4 *= 14
+  9:  r3 = *(u32 *)(r1 +76) /* load skb->data */
+ 10:  r3 += r4
+ 11:  r2 = r1
+ 12:  r2 <<= 48
+ 13:  r2 >>= 48
+ 14:  r3 += r2
+ 15:  r2 = r3
+ 16:  r2 += 8
+ 17:  r1 = *(u32 *)(r1 +80) /* load skb->data_end */
+ 18:  if r2 > r1 goto pc+2
+  R0=inv(id=0,umax_value=255,var_off=(0x0; 0xff)) R1=pkt_end R2=pkt(id=2,off=8,r=8) R3=pkt(id=2,off=0,r=8) R4=inv(id=0,umax_value=3570,var_off=(0x0; 0xfffe)) R5=pkt(id=0,off=14,r=14) R10=fp
+ 19:  r1 = *(u8 *)(r3 +4)
+ The state of the register R3 is R3=pkt(id=2,off=0,r=8)
+ id=2 means that two 'r3 += rX' instructions were seen, so r3 points to some
+ offset within a packet and since the program author did
+ 'if (r3 + 8 > r1) goto err' at insn #18, the safe range is [R3, R3 + 8).
+ The verifier only allows 'add'/'sub' operations on packet registers. Any other
+ operation will set the register state to 'SCALAR_VALUE' and it won't be
+ available for direct packet access.
+ Operation 'r3 += rX' may overflow and become less than original skb->data,
+ therefore the verifier has to prevent that.  So when it sees 'r3 += rX'
+ instruction and rX is more than 16-bit value, any subsequent bounds-check of r3
+ against skb->data_end will not give us 'range' information, so attempts to read
+ through the pointer will give "invalid access to packet" error.
+ Ex. after insn 'r4 = *(u8 *)(r3 +12)' (insn #7 above) the state of r4 is
+ R4=inv(id=0,umax_value=255,var_off=(0x0; 0xff)) which means that upper 56 bits
+ of the register are guaranteed to be zero, and nothing is known about the lower
+ 8 bits. After insn 'r4 *= 14' the state becomes
+ R4=inv(id=0,umax_value=3570,var_off=(0x0; 0xfffe)), since multiplying an 8-bit
+ value by constant 14 will keep upper 52 bits as zero, also the least significant
+ bit will be zero as 14 is even.  Similarly 'r2 >>= 48' will make
+ R2=inv(id=0,umax_value=65535,var_off=(0x0; 0xffff)), since the shift is not sign
+ extending.  This logic is implemented in adjust_reg_min_max_vals() function,
+ which calls adjust_ptr_min_max_vals() for adding pointer to scalar (or vice
+ versa) and adjust_scalar_min_max_vals() for operations on two scalars.
+ 
+ The end result is that bpf program author can access packet directly
+ using normal C code as:
+   void *data = (void *)(long)skb->data;
+   void *data_end = (void *)(long)skb->data_end;
+   struct eth_hdr *eth = data;
+   struct iphdr *iph = data + sizeof(*eth);
+   struct udphdr *udp = data + sizeof(*eth) + sizeof(*iph);
+ 
+   if (data + sizeof(*eth) + sizeof(*iph) + sizeof(*udp) > data_end)
+           return 0;
+   if (eth->h_proto != htons(ETH_P_IP))
+           return 0;
+   if (iph->protocol != IPPROTO_UDP || iph->ihl != 5)
+           return 0;
+   if (udp->dest == 53 || udp->source == 9)
+           ...;
+ which makes such programs easier to write comparing to LD_ABS insn
+ and significantly faster.
+ 
+ eBPF maps
+ ---------
+ 'maps' is a generic storage of different types for sharing data between kernel
+ and userspace.
+ 
+ The maps are accessed from user space via BPF syscall, which has commands:
+ - create a map with given type and attributes
+   map_fd = bpf(BPF_MAP_CREATE, union bpf_attr *attr, u32 size)
+   using attr->map_type, attr->key_size, attr->value_size, attr->max_entries
+   returns process-local file descriptor or negative error
+ 
+ - lookup key in a given map
+   err = bpf(BPF_MAP_LOOKUP_ELEM, union bpf_attr *attr, u32 size)
+   using attr->map_fd, attr->key, attr->value
+   returns zero and stores found elem into value or negative error
+ 
+ - create or update key/value pair in a given map
+   err = bpf(BPF_MAP_UPDATE_ELEM, union bpf_attr *attr, u32 size)
+   using attr->map_fd, attr->key, attr->value
+   returns zero or negative error
+ 
+ - find and delete element by key in a given map
+   err = bpf(BPF_MAP_DELETE_ELEM, union bpf_attr *attr, u32 size)
+   using attr->map_fd, attr->key
+ 
+ - to delete map: close(fd)
+   Exiting process will delete maps automatically
+ 
+ userspace programs use this syscall to create/access maps that eBPF programs
+ are concurrently updating.
+ 
+ maps can have different types: hash, array, bloom filter, radix-tree, etc.
+ 
+ The map is defined by:
+   . type
+   . max number of elements
+   . key size in bytes
+   . value size in bytes
+ 
+ Pruning
+ -------
+ The verifier does not actually walk all possible paths through the program.  For
+ each new branch to analyse, the verifier looks at all the states it's previously
+ been in when at this instruction.  If any of them contain the current state as a
+ subset, the branch is 'pruned' - that is, the fact that the previous state was
+ accepted implies the current state would be as well.  For instance, if in the
+ previous state, r1 held a packet-pointer, and in the current state, r1 holds a
+ packet-pointer with a range as long or longer and at least as strict an
+ alignment, then r1 is safe.  Similarly, if r2 was NOT_INIT before then it can't
+ have been used by any path from that point, so any value in r2 (including
+ another NOT_INIT) is safe.  The implementation is in the function regsafe().
+ Pruning considers not only the registers but also the stack (and any spilled
+ registers it may hold).  They must all be safe for the branch to be pruned.
+ This is implemented in states_equal().
+ 
+ Understanding eBPF verifier messages
+ ------------------------------------
+ 
+ The following are few examples of invalid eBPF programs and verifier error
+ messages as seen in the log:
+ 
+ Program with unreachable instructions:
+ static struct bpf_insn prog[] = {
+   BPF_EXIT_INSN(),
+   BPF_EXIT_INSN(),
+ };
+ Error:
+   unreachable insn 1
+ 
+ Program that reads uninitialized register:
+   BPF_MOV64_REG(BPF_REG_0, BPF_REG_2),
+   BPF_EXIT_INSN(),
+ Error:
+   0: (bf) r0 = r2
+   R2 !read_ok
+ 
+ Program that doesn't initialize R0 before exiting:
+   BPF_MOV64_REG(BPF_REG_2, BPF_REG_1),
+   BPF_EXIT_INSN(),
+ Error:
+   0: (bf) r2 = r1
+   1: (95) exit
+   R0 !read_ok
+ 
+ Program that accesses stack out of bounds:
+   BPF_ST_MEM(BPF_DW, BPF_REG_10, 8, 0),
+   BPF_EXIT_INSN(),
+ Error:
+   0: (7a) *(u64 *)(r10 +8) = 0
+   invalid stack off=8 size=8
+ 
+ Program that doesn't initialize stack before passing its address into function:
+   BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
+   BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),
+   BPF_LD_MAP_FD(BPF_REG_1, 0),
+   BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
+   BPF_EXIT_INSN(),
+ Error:
+   0: (bf) r2 = r10
+   1: (07) r2 += -8
+   2: (b7) r1 = 0x0
+   3: (85) call 1
+   invalid indirect read from stack off -8+0 size 8
+ 
+ Program that uses invalid map_fd=0 while calling to map_lookup_elem() function:
+   BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),
+   BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
+   BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),
+   BPF_LD_MAP_FD(BPF_REG_1, 0),
+   BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
+   BPF_EXIT_INSN(),
+ Error:
+   0: (7a) *(u64 *)(r10 -8) = 0
+   1: (bf) r2 = r10
+   2: (07) r2 += -8
+   3: (b7) r1 = 0x0
+   4: (85) call 1
+   fd 0 is not pointing to valid bpf_map
+ 
+ Program that doesn't check return value of map_lookup_elem() before accessing
+ map element:
+   BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),
+   BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
+   BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),
+   BPF_LD_MAP_FD(BPF_REG_1, 0),
+   BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
+   BPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 0),
+   BPF_EXIT_INSN(),
+ Error:
+   0: (7a) *(u64 *)(r10 -8) = 0
+   1: (bf) r2 = r10
+   2: (07) r2 += -8
+   3: (b7) r1 = 0x0
+   4: (85) call 1
+   5: (7a) *(u64 *)(r0 +0) = 0
+   R0 invalid mem access 'map_value_or_null'
+ 
+ Program that correctly checks map_lookup_elem() returned value for NULL, but
+ accesses the memory with incorrect alignment:
+   BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),
+   BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
+   BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),
+   BPF_LD_MAP_FD(BPF_REG_1, 0),
+   BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
+   BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 1),
+   BPF_ST_MEM(BPF_DW, BPF_REG_0, 4, 0),
+   BPF_EXIT_INSN(),
+ Error:
+   0: (7a) *(u64 *)(r10 -8) = 0
+   1: (bf) r2 = r10
+   2: (07) r2 += -8
+   3: (b7) r1 = 1
+   4: (85) call 1
+   5: (15) if r0 == 0x0 goto pc+1
+    R0=map_ptr R10=fp
+   6: (7a) *(u64 *)(r0 +4) = 0
+   misaligned access off 4 size 8
+ 
+ Program that correctly checks map_lookup_elem() returned value for NULL and
+ accesses memory with correct alignment in one side of 'if' branch, but fails
+ to do so in the other side of 'if' branch:
+   BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),
+   BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
+   BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),
+   BPF_LD_MAP_FD(BPF_REG_1, 0),
+   BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
+   BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),
+   BPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 0),
+   BPF_EXIT_INSN(),
+   BPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 1),
+   BPF_EXIT_INSN(),
+ Error:
+   0: (7a) *(u64 *)(r10 -8) = 0
+   1: (bf) r2 = r10
+   2: (07) r2 += -8
+   3: (b7) r1 = 1
+   4: (85) call 1
+   5: (15) if r0 == 0x0 goto pc+2
+    R0=map_ptr R10=fp
+   6: (7a) *(u64 *)(r0 +0) = 0
+   7: (95) exit
+ 
+   from 5 to 8: R0=imm0 R10=fp
+   8: (7a) *(u64 *)(r0 +0) = 1
+   R0 invalid mem access 'imm'
+ 
+ Testing
+ -------
+ 
+ Next to the BPF toolchain, the kernel also ships a test module that contains
+ various test cases for classic and internal BPF that can be executed against
+ the BPF interpreter and JIT compiler. It can be found in lib/test_bpf.c and
+ enabled via Kconfig:
+ 
+   CONFIG_TEST_BPF=m
+ 
+ After the module has been built and installed, the test suite can be executed
+ via insmod or modprobe against 'test_bpf' module. Results of the test cases
+ including timings in nsec can be found in the kernel log (dmesg).
+ 
++>>>>>>> 92b31a9af73b (bpf: add BPF_J{LT,LE,SLT,SLE} instructions)
  Misc
  ----
  
diff --cc net/core/filter.c
index 060ed5f86613,5afe3ac191ec..000000000000
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@@ -110,314 -109,563 +110,344 @@@ int sk_filter_trim_cap(struct sock *sk
  }
  EXPORT_SYMBOL(sk_filter_trim_cap);
  
 -BPF_CALL_1(__skb_get_pay_offset, struct sk_buff *, skb)
 -{
 -	return skb_get_poff(skb);
 -}
 -
 -BPF_CALL_3(__skb_get_nlattr, struct sk_buff *, skb, u32, a, u32, x)
 -{
 -	struct nlattr *nla;
 -
 -	if (skb_is_nonlinear(skb))
 -		return 0;
 -
 -	if (skb->len < sizeof(struct nlattr))
 -		return 0;
 -
 -	if (a > skb->len - sizeof(struct nlattr))
 -		return 0;
 -
 -	nla = nla_find((struct nlattr *) &skb->data[a], skb->len - a, x);
 -	if (nla)
 -		return (void *) nla - (void *) skb->data;
 -
 -	return 0;
 -}
 -
 -BPF_CALL_3(__skb_get_nlattr_nest, struct sk_buff *, skb, u32, a, u32, x)
 -{
 -	struct nlattr *nla;
 -
 -	if (skb_is_nonlinear(skb))
 -		return 0;
 -
 -	if (skb->len < sizeof(struct nlattr))
 -		return 0;
 -
 -	if (a > skb->len - sizeof(struct nlattr))
 -		return 0;
 -
 -	nla = (struct nlattr *) &skb->data[a];
 -	if (nla->nla_len > skb->len - a)
 -		return 0;
 -
 -	nla = nla_find_nested(nla, x);
 -	if (nla)
 -		return (void *) nla - (void *) skb->data;
 -
 -	return 0;
 -}
 -
 -BPF_CALL_0(__get_raw_cpu_id)
 -{
 -	return raw_smp_processor_id();
 -}
 -
 -static const struct bpf_func_proto bpf_get_raw_smp_processor_id_proto = {
 -	.func		= __get_raw_cpu_id,
 -	.gpl_only	= false,
 -	.ret_type	= RET_INTEGER,
 -};
 -
 -static u32 convert_skb_access(int skb_field, int dst_reg, int src_reg,
 -			      struct bpf_insn *insn_buf)
 -{
 -	struct bpf_insn *insn = insn_buf;
 -
 -	switch (skb_field) {
 -	case SKF_AD_MARK:
 -		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);
 -
 -		*insn++ = BPF_LDX_MEM(BPF_W, dst_reg, src_reg,
 -				      offsetof(struct sk_buff, mark));
 -		break;
 -
 -	case SKF_AD_PKTTYPE:
 -		*insn++ = BPF_LDX_MEM(BPF_B, dst_reg, src_reg, PKT_TYPE_OFFSET());
 -		*insn++ = BPF_ALU32_IMM(BPF_AND, dst_reg, PKT_TYPE_MAX);
 -#ifdef __BIG_ENDIAN_BITFIELD
 -		*insn++ = BPF_ALU32_IMM(BPF_RSH, dst_reg, 5);
 -#endif
 -		break;
 -
 -	case SKF_AD_QUEUE:
 -		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);
 -
 -		*insn++ = BPF_LDX_MEM(BPF_H, dst_reg, src_reg,
 -				      offsetof(struct sk_buff, queue_mapping));
 -		break;
 -
 -	case SKF_AD_VLAN_TAG:
 -	case SKF_AD_VLAN_TAG_PRESENT:
 -		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, vlan_tci) != 2);
 -		BUILD_BUG_ON(VLAN_TAG_PRESENT != 0x1000);
 -
 -		/* dst_reg = *(u16 *) (src_reg + offsetof(vlan_tci)) */
 -		*insn++ = BPF_LDX_MEM(BPF_H, dst_reg, src_reg,
 -				      offsetof(struct sk_buff, vlan_tci));
 -		if (skb_field == SKF_AD_VLAN_TAG) {
 -			*insn++ = BPF_ALU32_IMM(BPF_AND, dst_reg,
 -						~VLAN_TAG_PRESENT);
 -		} else {
 -			/* dst_reg >>= 12 */
 -			*insn++ = BPF_ALU32_IMM(BPF_RSH, dst_reg, 12);
 -			/* dst_reg &= 1 */
 -			*insn++ = BPF_ALU32_IMM(BPF_AND, dst_reg, 1);
 -		}
 -		break;
 -	}
 -
 -	return insn - insn_buf;
 -}
 -
 -static bool convert_bpf_extensions(struct sock_filter *fp,
 -				   struct bpf_insn **insnp)
 -{
 -	struct bpf_insn *insn = *insnp;
 -	u32 cnt;
 -
 -	switch (fp->k) {
 -	case SKF_AD_OFF + SKF_AD_PROTOCOL:
 -		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);
 -
 -		/* A = *(u16 *) (CTX + offsetof(protocol)) */
 -		*insn++ = BPF_LDX_MEM(BPF_H, BPF_REG_A, BPF_REG_CTX,
 -				      offsetof(struct sk_buff, protocol));
 -		/* A = ntohs(A) [emitting a nop or swap16] */
 -		*insn = BPF_ENDIAN(BPF_FROM_BE, BPF_REG_A, 16);
 -		break;
 -
 -	case SKF_AD_OFF + SKF_AD_PKTTYPE:
 -		cnt = convert_skb_access(SKF_AD_PKTTYPE, BPF_REG_A, BPF_REG_CTX, insn);
 -		insn += cnt - 1;
 -		break;
 -
 -	case SKF_AD_OFF + SKF_AD_IFINDEX:
 -	case SKF_AD_OFF + SKF_AD_HATYPE:
 -		BUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);
 -		BUILD_BUG_ON(FIELD_SIZEOF(struct net_device, type) != 2);
 -
 -		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_buff, dev),
 -				      BPF_REG_TMP, BPF_REG_CTX,
 -				      offsetof(struct sk_buff, dev));
 -		/* if (tmp != 0) goto pc + 1 */
 -		*insn++ = BPF_JMP_IMM(BPF_JNE, BPF_REG_TMP, 0, 1);
 -		*insn++ = BPF_EXIT_INSN();
 -		if (fp->k == SKF_AD_OFF + SKF_AD_IFINDEX)
 -			*insn = BPF_LDX_MEM(BPF_W, BPF_REG_A, BPF_REG_TMP,
 -					    offsetof(struct net_device, ifindex));
 -		else
 -			*insn = BPF_LDX_MEM(BPF_H, BPF_REG_A, BPF_REG_TMP,
 -					    offsetof(struct net_device, type));
 -		break;
 -
 -	case SKF_AD_OFF + SKF_AD_MARK:
 -		cnt = convert_skb_access(SKF_AD_MARK, BPF_REG_A, BPF_REG_CTX, insn);
 -		insn += cnt - 1;
 -		break;
 -
 -	case SKF_AD_OFF + SKF_AD_RXHASH:
 -		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, hash) != 4);
 -
 -		*insn = BPF_LDX_MEM(BPF_W, BPF_REG_A, BPF_REG_CTX,
 -				    offsetof(struct sk_buff, hash));
 -		break;
 -
 -	case SKF_AD_OFF + SKF_AD_QUEUE:
 -		cnt = convert_skb_access(SKF_AD_QUEUE, BPF_REG_A, BPF_REG_CTX, insn);
 -		insn += cnt - 1;
 -		break;
 -
 -	case SKF_AD_OFF + SKF_AD_VLAN_TAG:
 -		cnt = convert_skb_access(SKF_AD_VLAN_TAG,
 -					 BPF_REG_A, BPF_REG_CTX, insn);
 -		insn += cnt - 1;
 -		break;
 -
 -	case SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT:
 -		cnt = convert_skb_access(SKF_AD_VLAN_TAG_PRESENT,
 -					 BPF_REG_A, BPF_REG_CTX, insn);
 -		insn += cnt - 1;
 -		break;
 -
 -	case SKF_AD_OFF + SKF_AD_VLAN_TPID:
 -		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, vlan_proto) != 2);
 -
 -		/* A = *(u16 *) (CTX + offsetof(vlan_proto)) */
 -		*insn++ = BPF_LDX_MEM(BPF_H, BPF_REG_A, BPF_REG_CTX,
 -				      offsetof(struct sk_buff, vlan_proto));
 -		/* A = ntohs(A) [emitting a nop or swap16] */
 -		*insn = BPF_ENDIAN(BPF_FROM_BE, BPF_REG_A, 16);
 -		break;
 -
 -	case SKF_AD_OFF + SKF_AD_PAY_OFFSET:
 -	case SKF_AD_OFF + SKF_AD_NLATTR:
 -	case SKF_AD_OFF + SKF_AD_NLATTR_NEST:
 -	case SKF_AD_OFF + SKF_AD_CPU:
 -	case SKF_AD_OFF + SKF_AD_RANDOM:
 -		/* arg1 = CTX */
 -		*insn++ = BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_CTX);
 -		/* arg2 = A */
 -		*insn++ = BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_A);
 -		/* arg3 = X */
 -		*insn++ = BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_X);
 -		/* Emit call(arg1=CTX, arg2=A, arg3=X) */
 -		switch (fp->k) {
 -		case SKF_AD_OFF + SKF_AD_PAY_OFFSET:
 -			*insn = BPF_EMIT_CALL(__skb_get_pay_offset);
 -			break;
 -		case SKF_AD_OFF + SKF_AD_NLATTR:
 -			*insn = BPF_EMIT_CALL(__skb_get_nlattr);
 -			break;
 -		case SKF_AD_OFF + SKF_AD_NLATTR_NEST:
 -			*insn = BPF_EMIT_CALL(__skb_get_nlattr_nest);
 -			break;
 -		case SKF_AD_OFF + SKF_AD_CPU:
 -			*insn = BPF_EMIT_CALL(__get_raw_cpu_id);
 -			break;
 -		case SKF_AD_OFF + SKF_AD_RANDOM:
 -			*insn = BPF_EMIT_CALL(bpf_user_rnd_u32);
 -			bpf_user_rnd_init_once();
 -			break;
 -		}
 -		break;
 -
 -	case SKF_AD_OFF + SKF_AD_ALU_XOR_X:
 -		/* A ^= X */
 -		*insn = BPF_ALU32_REG(BPF_XOR, BPF_REG_A, BPF_REG_X);
 -		break;
 -
 -	default:
 -		/* This is just a dummy call to avoid letting the compiler
 -		 * evict __bpf_call_base() as an optimization. Placed here
 -		 * where no-one bothers.
 -		 */
 -		BUG_ON(__bpf_call_base(0, 0, 0, 0, 0) != 0);
 -		return false;
 -	}
 -
 -	*insnp = insn;
 -	return true;
 -}
 -
  /**
 - *	bpf_convert_filter - convert filter program
 - *	@prog: the user passed filter program
 - *	@len: the length of the user passed filter program
 - *	@new_prog: allocated 'struct bpf_prog' or NULL
 - *	@new_len: pointer to store length of converted program
 - *
 - * Remap 'sock_filter' style classic BPF (cBPF) instruction set to 'bpf_insn'
 - * style extended BPF (eBPF).
 - * Conversion workflow:
 - *
 - * 1) First pass for calculating the new program length:
 - *   bpf_convert_filter(old_prog, old_len, NULL, &new_len)
 + *	sk_run_filter - run a filter on a socket
 + *	@skb: buffer to run the filter on
 + *	@fentry: filter to apply
   *
 - * 2) 2nd pass to remap in two passes: 1st pass finds new
 - *    jump offsets, 2nd pass remapping:
 - *   bpf_convert_filter(old_prog, old_len, new_prog, &new_len);
 + * Decode and apply filter instructions to the skb->data.
 + * Return length to keep, 0 for none. @skb is the data we are
 + * filtering, @filter is the array of filter instructions.
 + * Because all jumps are guaranteed to be before last instruction,
 + * and last instruction guaranteed to be a RET, we dont need to check
 + * flen. (We used to pass to this function the length of filter)
   */
 -static int bpf_convert_filter(struct sock_filter *prog, int len,
 -			      struct bpf_prog *new_prog, int *new_len)
 +unsigned int sk_run_filter(const struct sk_buff *skb,
 +			   const struct sock_filter *fentry)
  {
 -	int new_flen = 0, pass = 0, target, i, stack_off;
 -	struct bpf_insn *new_insn, *first_insn = NULL;
 -	struct sock_filter *fp;
 -	int *addrs = NULL;
 -	u8 bpf_src;
 -
 -	BUILD_BUG_ON(BPF_MEMWORDS * sizeof(u32) > MAX_BPF_STACK);
 -	BUILD_BUG_ON(BPF_REG_FP + 1 != MAX_BPF_REG);
 -
 -	if (len <= 0 || len > BPF_MAXINSNS)
 -		return -EINVAL;
 -
 -	if (new_prog) {
 -		first_insn = new_prog->insnsi;
 -		addrs = kcalloc(len, sizeof(*addrs),
 -				GFP_KERNEL | __GFP_NOWARN);
 -		if (!addrs)
 -			return -ENOMEM;
 -	}
 -
 -do_pass:
 -	new_insn = first_insn;
 -	fp = prog;
 -
 -	/* Classic BPF related prologue emission. */
 -	if (new_prog) {
 -		/* Classic BPF expects A and X to be reset first. These need
 -		 * to be guaranteed to be the first two instructions.
 -		 */
 -		*new_insn++ = BPF_ALU64_REG(BPF_XOR, BPF_REG_A, BPF_REG_A);
 -		*new_insn++ = BPF_ALU64_REG(BPF_XOR, BPF_REG_X, BPF_REG_X);
 -
 -		/* All programs must keep CTX in callee saved BPF_REG_CTX.
 -		 * In eBPF case it's done by the compiler, here we need to
 -		 * do this ourself. Initial CTX is present in BPF_REG_ARG1.
 -		 */
 -		*new_insn++ = BPF_MOV64_REG(BPF_REG_CTX, BPF_REG_ARG1);
 -	} else {
 -		new_insn += 3;
 -	}
 -
 -	for (i = 0; i < len; fp++, i++) {
 -		struct bpf_insn tmp_insns[6] = { };
 -		struct bpf_insn *insn = tmp_insns;
 -
 -		if (addrs)
 -			addrs[i] = new_insn - first_insn;
 -
 -		switch (fp->code) {
 -		/* All arithmetic insns and skb loads map as-is. */
 -		case BPF_ALU | BPF_ADD | BPF_X:
 -		case BPF_ALU | BPF_ADD | BPF_K:
 -		case BPF_ALU | BPF_SUB | BPF_X:
 -		case BPF_ALU | BPF_SUB | BPF_K:
 -		case BPF_ALU | BPF_AND | BPF_X:
 -		case BPF_ALU | BPF_AND | BPF_K:
 -		case BPF_ALU | BPF_OR | BPF_X:
 -		case BPF_ALU | BPF_OR | BPF_K:
 -		case BPF_ALU | BPF_LSH | BPF_X:
 -		case BPF_ALU | BPF_LSH | BPF_K:
 -		case BPF_ALU | BPF_RSH | BPF_X:
 -		case BPF_ALU | BPF_RSH | BPF_K:
 -		case BPF_ALU | BPF_XOR | BPF_X:
 -		case BPF_ALU | BPF_XOR | BPF_K:
 -		case BPF_ALU | BPF_MUL | BPF_X:
 -		case BPF_ALU | BPF_MUL | BPF_K:
 -		case BPF_ALU | BPF_DIV | BPF_X:
 -		case BPF_ALU | BPF_DIV | BPF_K:
 -		case BPF_ALU | BPF_MOD | BPF_X:
 -		case BPF_ALU | BPF_MOD | BPF_K:
 -		case BPF_ALU | BPF_NEG:
 -		case BPF_LD | BPF_ABS | BPF_W:
 -		case BPF_LD | BPF_ABS | BPF_H:
 -		case BPF_LD | BPF_ABS | BPF_B:
 -		case BPF_LD | BPF_IND | BPF_W:
 -		case BPF_LD | BPF_IND | BPF_H:
 -		case BPF_LD | BPF_IND | BPF_B:
 -			/* Check for overloaded BPF extension and
 -			 * directly convert it if found, otherwise
 -			 * just move on with mapping.
 -			 */
 -			if (BPF_CLASS(fp->code) == BPF_LD &&
 -			    BPF_MODE(fp->code) == BPF_ABS &&
 -			    convert_bpf_extensions(fp, &insn))
 -				break;
 -
 -			*insn = BPF_RAW_INSN(fp->code, BPF_REG_A, BPF_REG_X, 0, fp->k);
 -			break;
 +	void *ptr;
 +	u32 A = 0;			/* Accumulator */
 +	u32 X = 0;			/* Index Register */
 +	u32 mem[BPF_MEMWORDS];		/* Scratch Memory Store */
 +	u32 tmp;
 +	int k;
  
 -		/* Jump transformation cannot use BPF block macros
 -		 * everywhere as offset calculation and target updates
 -		 * require a bit more work than the rest, i.e. jump
 -		 * opcodes map as-is, but offsets need adjustment.
 -		 */
 -
 -#define BPF_EMIT_JMP							\
 -	do {								\
 -		if (target >= len || target < 0)			\
 -			goto err;					\
 -		insn->off = addrs ? addrs[target] - addrs[i] - 1 : 0;	\
 -		/* Adjust pc relative offset for 2nd or 3rd insn. */	\
 -		insn->off -= insn - tmp_insns;				\
 -	} while (0)
 -
 -		case BPF_JMP | BPF_JA:
 -			target = i + fp->k + 1;
 -			insn->code = fp->code;
 -			BPF_EMIT_JMP;
 -			break;
 +	/*
 +	 * Process array of filter instructions.
 +	 */
 +	for (;; fentry++) {
 +#if defined(CONFIG_X86_32)
 +#define	K (fentry->k)
 +#else
 +		const u32 K = fentry->k;
 +#endif
  
 -		case BPF_JMP | BPF_JEQ | BPF_K:
 -		case BPF_JMP | BPF_JEQ | BPF_X:
 -		case BPF_JMP | BPF_JSET | BPF_K:
 -		case BPF_JMP | BPF_JSET | BPF_X:
 -		case BPF_JMP | BPF_JGT | BPF_K:
 -		case BPF_JMP | BPF_JGT | BPF_X:
 -		case BPF_JMP | BPF_JGE | BPF_K:
 -		case BPF_JMP | BPF_JGE | BPF_X:
 -			if (BPF_SRC(fp->code) == BPF_K && (int) fp->k < 0) {
 -				/* BPF immediates are signed, zero extend
 -				 * immediate into tmp register and use it
 -				 * in compare insn.
 -				 */
 -				*insn++ = BPF_MOV32_IMM(BPF_REG_TMP, fp->k);
 -
 -				insn->dst_reg = BPF_REG_A;
 -				insn->src_reg = BPF_REG_TMP;
 -				bpf_src = BPF_X;
 -			} else {
 -				insn->dst_reg = BPF_REG_A;
 -				insn->imm = fp->k;
 -				bpf_src = BPF_SRC(fp->code);
 -				insn->src_reg = bpf_src == BPF_X ? BPF_REG_X : 0;
 +		switch (fentry->code) {
 +		case BPF_S_ALU_ADD_X:
 +			A += X;
 +			continue;
 +		case BPF_S_ALU_ADD_K:
 +			A += K;
 +			continue;
 +		case BPF_S_ALU_SUB_X:
 +			A -= X;
 +			continue;
 +		case BPF_S_ALU_SUB_K:
 +			A -= K;
 +			continue;
 +		case BPF_S_ALU_MUL_X:
 +			A *= X;
 +			continue;
 +		case BPF_S_ALU_MUL_K:
 +			A *= K;
 +			continue;
 +		case BPF_S_ALU_DIV_X:
 +			if (X == 0)
 +				return 0;
 +			A /= X;
 +			continue;
 +		case BPF_S_ALU_DIV_K:
 +			A /= K;
 +			continue;
 +		case BPF_S_ALU_MOD_X:
 +			if (X == 0)
 +				return 0;
 +			A %= X;
 +			continue;
 +		case BPF_S_ALU_MOD_K:
 +			A %= K;
 +			continue;
 +		case BPF_S_ALU_AND_X:
 +			A &= X;
 +			continue;
 +		case BPF_S_ALU_AND_K:
 +			A &= K;
 +			continue;
 +		case BPF_S_ALU_OR_X:
 +			A |= X;
 +			continue;
 +		case BPF_S_ALU_OR_K:
 +			A |= K;
 +			continue;
 +		case BPF_S_ANC_ALU_XOR_X:
 +		case BPF_S_ALU_XOR_X:
 +			A ^= X;
 +			continue;
 +		case BPF_S_ALU_XOR_K:
 +			A ^= K;
 +			continue;
 +		case BPF_S_ALU_LSH_X:
 +			A <<= X;
 +			continue;
 +		case BPF_S_ALU_LSH_K:
 +			A <<= K;
 +			continue;
 +		case BPF_S_ALU_RSH_X:
 +			A >>= X;
 +			continue;
 +		case BPF_S_ALU_RSH_K:
 +			A >>= K;
 +			continue;
 +		case BPF_S_ALU_NEG:
 +			A = -A;
 +			continue;
 +		case BPF_S_JMP_JA:
 +			fentry += K;
 +			continue;
 +		case BPF_S_JMP_JGT_K:
 +			fentry += (A > K) ? fentry->jt : fentry->jf;
 +			continue;
 +		case BPF_S_JMP_JGE_K:
 +			fentry += (A >= K) ? fentry->jt : fentry->jf;
 +			continue;
 +		case BPF_S_JMP_JEQ_K:
 +			fentry += (A == K) ? fentry->jt : fentry->jf;
 +			continue;
 +		case BPF_S_JMP_JSET_K:
 +			fentry += (A & K) ? fentry->jt : fentry->jf;
 +			continue;
 +		case BPF_S_JMP_JGT_X:
 +			fentry += (A > X) ? fentry->jt : fentry->jf;
 +			continue;
 +		case BPF_S_JMP_JGE_X:
 +			fentry += (A >= X) ? fentry->jt : fentry->jf;
 +			continue;
 +		case BPF_S_JMP_JEQ_X:
 +			fentry += (A == X) ? fentry->jt : fentry->jf;
 +			continue;
 +		case BPF_S_JMP_JSET_X:
 +			fentry += (A & X) ? fentry->jt : fentry->jf;
 +			continue;
 +		case BPF_S_LD_W_ABS:
 +			k = K;
 +load_w:
 +			ptr = load_pointer(skb, k, 4, &tmp);
 +			if (ptr != NULL) {
 +				A = get_unaligned_be32(ptr);
 +				continue;
  			}
 -
 -			/* Common case where 'jump_false' is next insn. */
 -			if (fp->jf == 0) {
 -				insn->code = BPF_JMP | BPF_OP(fp->code) | bpf_src;
 -				target = i + fp->jt + 1;
 -				BPF_EMIT_JMP;
 -				break;
 +			return 0;
 +		case BPF_S_LD_H_ABS:
 +			k = K;
 +load_h:
 +			ptr = load_pointer(skb, k, 2, &tmp);
 +			if (ptr != NULL) {
 +				A = get_unaligned_be16(ptr);
 +				continue;
 +			}
++<<<<<<< HEAD
 +			return 0;
 +		case BPF_S_LD_B_ABS:
 +			k = K;
 +load_b:
 +			ptr = load_pointer(skb, k, 1, &tmp);
 +			if (ptr != NULL) {
 +				A = *(u8 *)ptr;
 +				continue;
 +			}
 +			return 0;
 +		case BPF_S_LD_W_LEN:
 +			A = skb->len;
 +			continue;
 +		case BPF_S_LDX_W_LEN:
 +			X = skb->len;
 +			continue;
 +		case BPF_S_LD_W_IND:
 +			k = X + K;
 +			goto load_w;
 +		case BPF_S_LD_H_IND:
 +			k = X + K;
 +			goto load_h;
 +		case BPF_S_LD_B_IND:
 +			k = X + K;
 +			goto load_b;
 +		case BPF_S_LDX_B_MSH:
 +			ptr = load_pointer(skb, K, 1, &tmp);
 +			if (ptr != NULL) {
 +				X = (*(u8 *)ptr & 0xf) << 2;
 +				continue;
  			}
 +			return 0;
 +		case BPF_S_LD_IMM:
 +			A = K;
 +			continue;
 +		case BPF_S_LDX_IMM:
 +			X = K;
 +			continue;
 +		case BPF_S_LD_MEM:
 +			A = mem[K];
 +			continue;
 +		case BPF_S_LDX_MEM:
 +			X = mem[K];
 +			continue;
 +		case BPF_S_MISC_TAX:
 +			X = A;
 +			continue;
 +		case BPF_S_MISC_TXA:
 +			A = X;
 +			continue;
 +		case BPF_S_RET_K:
 +			return K;
 +		case BPF_S_RET_A:
 +			return A;
 +		case BPF_S_ST:
 +			mem[K] = A;
 +			continue;
 +		case BPF_S_STX:
 +			mem[K] = X;
 +			continue;
 +		case BPF_S_ANC_PROTOCOL:
 +			A = ntohs(skb->protocol);
 +			continue;
 +		case BPF_S_ANC_PKTTYPE:
 +			A = skb->pkt_type;
 +			continue;
 +		case BPF_S_ANC_IFINDEX:
 +			if (!skb->dev)
 +				return 0;
 +			A = skb->dev->ifindex;
 +			continue;
 +		case BPF_S_ANC_MARK:
 +			A = skb->mark;
 +			continue;
 +		case BPF_S_ANC_QUEUE:
 +			A = skb->queue_mapping;
 +			continue;
 +		case BPF_S_ANC_HATYPE:
 +			if (!skb->dev)
 +				return 0;
 +			A = skb->dev->type;
 +			continue;
 +		case BPF_S_ANC_RXHASH:
 +			A = skb->hash;
 +			continue;
 +		case BPF_S_ANC_CPU:
 +			A = raw_smp_processor_id();
 +			continue;
 +		case BPF_S_ANC_VLAN_TAG:
 +			A = skb_vlan_tag_get(skb);
 +			continue;
 +		case BPF_S_ANC_VLAN_TAG_PRESENT:
 +			A = !!skb_vlan_tag_present(skb);
 +			continue;
 +		case BPF_S_ANC_PAY_OFFSET:
 +			A = skb_get_poff(skb);
 +			continue;
 +		case BPF_S_ANC_NLATTR: {
 +			struct nlattr *nla;
 +
 +			if (skb_is_nonlinear(skb))
 +				return 0;
++=======
+ 
+ 			/* Convert some jumps when 'jump_true' is next insn. */
+ 			if (fp->jt == 0) {
+ 				switch (BPF_OP(fp->code)) {
+ 				case BPF_JEQ:
+ 					insn->code = BPF_JMP | BPF_JNE | bpf_src;
+ 					break;
+ 				case BPF_JGT:
+ 					insn->code = BPF_JMP | BPF_JLE | bpf_src;
+ 					break;
+ 				case BPF_JGE:
+ 					insn->code = BPF_JMP | BPF_JLT | bpf_src;
+ 					break;
+ 				default:
+ 					goto jmp_rest;
+ 				}
+ 
+ 				target = i + fp->jf + 1;
+ 				BPF_EMIT_JMP;
+ 				break;
+ 			}
+ jmp_rest:
+ 			/* Other jumps are mapped into two insns: Jxx and JA. */
+ 			target = i + fp->jt + 1;
+ 			insn->code = BPF_JMP | BPF_OP(fp->code) | bpf_src;
+ 			BPF_EMIT_JMP;
+ 			insn++;
++>>>>>>> 92b31a9af73b (bpf: add BPF_J{LT,LE,SLT,SLE} instructions)
  
 -			insn->code = BPF_JMP | BPF_JA;
 -			target = i + fp->jf + 1;
 -			BPF_EMIT_JMP;
 -			break;
 -
 -		/* ldxb 4 * ([14] & 0xf) is remaped into 6 insns. */
 -		case BPF_LDX | BPF_MSH | BPF_B:
 -			/* tmp = A */
 -			*insn++ = BPF_MOV64_REG(BPF_REG_TMP, BPF_REG_A);
 -			/* A = BPF_R0 = *(u8 *) (skb->data + K) */
 -			*insn++ = BPF_LD_ABS(BPF_B, fp->k);
 -			/* A &= 0xf */
 -			*insn++ = BPF_ALU32_IMM(BPF_AND, BPF_REG_A, 0xf);
 -			/* A <<= 2 */
 -			*insn++ = BPF_ALU32_IMM(BPF_LSH, BPF_REG_A, 2);
 -			/* X = A */
 -			*insn++ = BPF_MOV64_REG(BPF_REG_X, BPF_REG_A);
 -			/* A = tmp */
 -			*insn = BPF_MOV64_REG(BPF_REG_A, BPF_REG_TMP);
 -			break;
 -
 -		/* RET_K is remaped into 2 insns. RET_A case doesn't need an
 -		 * extra mov as BPF_REG_0 is already mapped into BPF_REG_A.
 -		 */
 -		case BPF_RET | BPF_A:
 -		case BPF_RET | BPF_K:
 -			if (BPF_RVAL(fp->code) == BPF_K)
 -				*insn++ = BPF_MOV32_RAW(BPF_K, BPF_REG_0,
 -							0, fp->k);
 -			*insn = BPF_EXIT_INSN();
 -			break;
 -
 -		/* Store to stack. */
 -		case BPF_ST:
 -		case BPF_STX:
 -			stack_off = fp->k * 4  + 4;
 -			*insn = BPF_STX_MEM(BPF_W, BPF_REG_FP, BPF_CLASS(fp->code) ==
 -					    BPF_ST ? BPF_REG_A : BPF_REG_X,
 -					    -stack_off);
 -			/* check_load_and_stores() verifies that classic BPF can
 -			 * load from stack only after write, so tracking
 -			 * stack_depth for ST|STX insns is enough
 -			 */
 -			if (new_prog && new_prog->aux->stack_depth < stack_off)
 -				new_prog->aux->stack_depth = stack_off;
 -			break;
 +			if (skb->len < sizeof(struct nlattr))
 +				return 0;
  
 -		/* Load from stack. */
 -		case BPF_LD | BPF_MEM:
 -		case BPF_LDX | BPF_MEM:
 -			stack_off = fp->k * 4  + 4;
 -			*insn = BPF_LDX_MEM(BPF_W, BPF_CLASS(fp->code) == BPF_LD  ?
 -					    BPF_REG_A : BPF_REG_X, BPF_REG_FP,
 -					    -stack_off);
 -			break;
 +			if (A > skb->len - sizeof(struct nlattr))
 +				return 0;
  
 -		/* A = K or X = K */
 -		case BPF_LD | BPF_IMM:
 -		case BPF_LDX | BPF_IMM:
 -			*insn = BPF_MOV32_IMM(BPF_CLASS(fp->code) == BPF_LD ?
 -					      BPF_REG_A : BPF_REG_X, fp->k);
 -			break;
 +			nla = nla_find((struct nlattr *)&skb->data[A],
 +				       skb->len - A, X);
 +			if (nla)
 +				A = (void *)nla - (void *)skb->data;
 +			else
 +				A = 0;
 +			continue;
 +		}
 +		case BPF_S_ANC_NLATTR_NEST: {
 +			struct nlattr *nla;
  
 -		/* X = A */
 -		case BPF_MISC | BPF_TAX:
 -			*insn = BPF_MOV64_REG(BPF_REG_X, BPF_REG_A);
 -			break;
 +			if (skb_is_nonlinear(skb))
 +				return 0;
  
 -		/* A = X */
 -		case BPF_MISC | BPF_TXA:
 -			*insn = BPF_MOV64_REG(BPF_REG_A, BPF_REG_X);
 -			break;
 +			if (skb->len < sizeof(struct nlattr))
 +				return 0;
  
 -		/* A = skb->len or X = skb->len */
 -		case BPF_LD | BPF_W | BPF_LEN:
 -		case BPF_LDX | BPF_W | BPF_LEN:
 -			*insn = BPF_LDX_MEM(BPF_W, BPF_CLASS(fp->code) == BPF_LD ?
 -					    BPF_REG_A : BPF_REG_X, BPF_REG_CTX,
 -					    offsetof(struct sk_buff, len));
 -			break;
 +			if (A > skb->len - sizeof(struct nlattr))
 +				return 0;
  
 -		/* Access seccomp_data fields. */
 -		case BPF_LDX | BPF_ABS | BPF_W:
 -			/* A = *(u32 *) (ctx + K) */
 -			*insn = BPF_LDX_MEM(BPF_W, BPF_REG_A, BPF_REG_CTX, fp->k);
 -			break;
 +			nla = (struct nlattr *)&skb->data[A];
 +			if (nla->nla_len > skb->len - A)
 +				return 0;
  
 -		/* Unknown instruction. */
 +			nla = nla_find_nested(nla, X);
 +			if (nla)
 +				A = (void *)nla - (void *)skb->data;
 +			else
 +				A = 0;
 +			continue;
 +		}
 +#ifdef CONFIG_SECCOMP_FILTER
 +		case BPF_S_ANC_SECCOMP_LD_W:
 +			A = seccomp_bpf_load(fentry->k);
 +			continue;
 +#endif
  		default:
 -			goto err;
 +			WARN_RATELIMIT(1, "Unknown code:%u jt:%u tf:%u k:%u\n",
 +				       fentry->code, fentry->jt,
 +				       fentry->jf, fentry->k);
 +			return 0;
  		}
 -
 -		insn++;
 -		if (new_prog)
 -			memcpy(new_insn, tmp_insns,
 -			       sizeof(*insn) * (insn - tmp_insns));
 -		new_insn += insn - tmp_insns;
 -	}
 -
 -	if (!new_prog) {
 -		/* Only calculating new length. */
 -		*new_len = new_insn - first_insn;
 -		return 0;
 -	}
 -
 -	pass++;
 -	if (new_flen != new_insn - first_insn) {
 -		new_flen = new_insn - first_insn;
 -		if (pass > 2)
 -			goto err;
 -		goto do_pass;
  	}
  
 -	kfree(addrs);
 -	BUG_ON(*new_len != new_flen);
  	return 0;
 -err:
 -	kfree(addrs);
 -	return -EINVAL;
  }
 +EXPORT_SYMBOL(sk_run_filter);
  
 -/* Security:
 - *
 +/*
 + * Security :
 + * A BPF program is able to use 16 cells of memory to store intermediate
 + * values (check u32 mem[BPF_MEMWORDS] in sk_run_filter())
   * As we dont want to clear mem[] array for each packet going through
 - * __bpf_prog_run(), we check that filter loaded by user never try to read
 + * sk_run_filter(), we check that filter loaded by user never try to read
   * a cell if not previously written, and we check all branches to be sure
   * a malicious user doesn't try to abuse us.
   */
* Unmerged path kernel/bpf/core.c
* Unmerged path lib/test_bpf.c
* Unmerged path tools/include/uapi/linux/bpf.h
* Unmerged path Documentation/networking/filter.txt
diff --git a/include/uapi/linux/bpf.h b/include/uapi/linux/bpf.h
index e369860b690e..eea4f258353d 100644
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@ -29,9 +29,14 @@
 #define BPF_FROM_LE	BPF_TO_LE
 #define BPF_FROM_BE	BPF_TO_BE
 
+/* jmp encodings */
 #define BPF_JNE		0x50	/* jump != */
+#define BPF_JLT		0xa0	/* LT is unsigned, '<' */
+#define BPF_JLE		0xb0	/* LE is unsigned, '<=' */
 #define BPF_JSGT	0x60	/* SGT is signed '>', GT in x86 */
 #define BPF_JSGE	0x70	/* SGE is signed '>=', GE in x86 */
+#define BPF_JSLT	0xc0	/* SLT is signed, '<' */
+#define BPF_JSLE	0xd0	/* SLE is signed, '<=' */
 #define BPF_CALL	0x80	/* function call */
 #define BPF_EXIT	0x90	/* function return */
 
* Unmerged path kernel/bpf/core.c
* Unmerged path lib/test_bpf.c
* Unmerged path net/core/filter.c
* Unmerged path tools/include/uapi/linux/bpf.h
