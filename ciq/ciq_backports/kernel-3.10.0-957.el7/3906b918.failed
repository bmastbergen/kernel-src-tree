PCI: vmd: Use SRCU as a local RCU to prevent delaying global RCU

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jon Derrick <jonathan.derrick@intel.com>
commit 3906b91844d603153c094f636205ec9aa5454b2f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3906b918.failed

SRCU lets synchronize_srcu() depend on VMD-local RCU primitives, preventing
long delays from locking up RCU in other systems.  VMD performs a
synchronize when removing a device, but will hit all IRQ lists if the
device uses all VMD vectors.  This patch will not help VMD's RCU
synchronization, but will isolate the read side delays to the VMD
subsystem.  Additionally, the use of SRCU in VMD's ISR will keep it
isolated from any other RCU waiters in the rest of the system.

Tested using concurrent FIO and NVMe resets:

  [global]
  rw=read
  bs=4k
  direct=1
  ioengine=libaio
  iodepth=32
  norandommap
  timeout=300
  runtime=1000000000

  [nvme0]
  cpus_allowed=0-63
  numjobs=8
  filename=/dev/nvme0n1

  [nvme1]
  cpus_allowed=0-63
  numjobs=8
  filename=/dev/nvme1n1

  while (true) do
    for i in /sys/class/nvme/nvme*; do
      echo "Resetting ${i##*/}"
      echo 1 > $i/reset_controller;
      sleep 5
    done;
  done

	Signed-off-by: Jon Derrick <jonathan.derrick@intel.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Keith Busch <keith.busch@intel.com>
(cherry picked from commit 3906b91844d603153c094f636205ec9aa5454b2f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/pci/vmd.c
#	drivers/pci/host/Kconfig
diff --cc arch/x86/pci/vmd.c
index dbf4ff6cc584,6c5b7fd9f0c5..000000000000
--- a/arch/x86/pci/vmd.c
+++ b/arch/x86/pci/vmd.c
@@@ -56,16 -57,13 +55,24 @@@ struct vmd_irq 
  /**
   * struct vmd_irq_list - list of driver requested IRQs mapping to a VMD vector
   * @irq_list:	the list of irq's the VMD one demuxes to.
++<<<<<<< HEAD:arch/x86/pci/vmd.c
 + * @vmd_vector:	the h/w IRQ assigned to the VMD.
 + * @index:	index into the VMD MSI-X table; used for message routing.
++=======
+  * @srcu:	SRCU struct for local synchronization.
++>>>>>>> 3906b91844d6 (PCI: vmd: Use SRCU as a local RCU to prevent delaying global RCU):drivers/pci/host/vmd.c
   * @count:	number of child IRQs assigned to this vector; used to track
   *		sharing.
   */
  struct vmd_irq_list {
  	struct list_head	irq_list;
++<<<<<<< HEAD:arch/x86/pci/vmd.c
 +	struct vmd_dev		*vmd;
 +	unsigned int		vmd_vector;
 +	unsigned int		index;
++=======
+ 	struct srcu_struct	srcu;
++>>>>>>> 3906b91844d6 (PCI: vmd: Use SRCU as a local RCU to prevent delaying global RCU):drivers/pci/host/vmd.c
  	unsigned int		count;
  };
  
@@@ -221,23 -219,53 +228,23 @@@ static int vmd_setup_msi_irqs(struct pc
  	return 0;
  }
  
 -static void vmd_msi_free(struct irq_domain *domain,
 -			struct msi_domain_info *info, unsigned int virq)
 +static void vmd_teardown_msi_irq(unsigned int irq)
  {
 -	struct vmd_irq *vmdirq = irq_get_chip_data(virq);
 +	struct vmd_irq *vmdirq = irq_get_handler_data(irq);
  	unsigned long flags;
  
- 	synchronize_rcu();
+ 	synchronize_srcu(&vmdirq->irq->srcu);
  
 -	/* XXX: Potential optimization to rebalance */
  	raw_spin_lock_irqsave(&list_lock, flags);
  	vmdirq->irq->count--;
  	raw_spin_unlock_irqrestore(&list_lock, flags);
  
- 	kfree_rcu(vmdirq, rcu);
+ 	kfree(vmdirq);
  }
  
 -static int vmd_msi_prepare(struct irq_domain *domain, struct device *dev,
 -			   int nvec, msi_alloc_info_t *arg)
 -{
 -	struct pci_dev *pdev = to_pci_dev(dev);
 -	struct vmd_dev *vmd = vmd_from_bus(pdev->bus);
 -
 -	if (nvec > vmd->msix_count)
 -		return vmd->msix_count;
 -
 -	memset(arg, 0, sizeof(*arg));
 -	return 0;
 -}
 -
 -static void vmd_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc)
 -{
 -	arg->desc = desc;
 -}
 -
 -static struct msi_domain_ops vmd_msi_domain_ops = {
 -	.get_hwirq	= vmd_get_hwirq,
 -	.msi_init	= vmd_msi_init,
 -	.msi_free	= vmd_msi_free,
 -	.msi_prepare	= vmd_msi_prepare,
 -	.set_desc	= vmd_set_desc,
 -};
 -
 -static struct msi_domain_info vmd_msi_domain_info = {
 -	.flags		= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |
 -			  MSI_FLAG_PCI_MSIX,
 -	.ops		= &vmd_msi_domain_ops,
 -	.chip		= &vmd_msi_controller,
 +static struct x86_msi_ops vmd_msi = {
 +	.setup_msi_irqs		= vmd_setup_msi_irqs,
 +	.teardown_msi_irq	= vmd_teardown_msi_irq,
  };
  
  #ifdef CONFIG_X86_DEV_DMA_OPS
@@@ -664,11 -698,12 +672,15 @@@ static int vmd_probe(struct pci_dev *de
  		return -ENOMEM;
  
  	for (i = 0; i < vmd->msix_count; i++) {
+ 		err = init_srcu_struct(&vmd->irqs[i].srcu);
+ 		if (err)
+ 			return err;
+ 
  		INIT_LIST_HEAD(&vmd->irqs[i].irq_list);
 -		err = devm_request_irq(&dev->dev, pci_irq_vector(dev, i),
 +		vmd->irqs[i].vmd_vector = pci_irq_vector(dev, i);
 +		vmd->irqs[i].index = i;
 +
 +		err = devm_request_irq(&dev->dev, vmd->irqs[i].vmd_vector,
  				       vmd_irq, 0, "vmd", &vmd->irqs[i]);
  		if (err)
  			return err;
* Unmerged path drivers/pci/host/Kconfig
* Unmerged path arch/x86/pci/vmd.c
* Unmerged path drivers/pci/host/Kconfig
