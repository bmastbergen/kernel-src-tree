x86/efi-bgrt: Switch all pr_err() to pr_notice() for invalid BGRT

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] efi-bgrt: Switch all pr_err() to pr_notice() for invalid BGRT (Lenny Szubowicz) [1464241]
Rebuild_FUZZ: 96.83%
commit-author Josh Boyer <jwboyer@fedoraproject.org>
commit 7f9b474c92713067237c8188f32791cc4007b5da
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7f9b474c.failed

The promise of pretty boot splashes from firmware via BGRT was at
best only that; a promise.  The kernel diligently checks to make
sure the BGRT data firmware gives it is valid, and dutifully warns
the user when it isn't.  However, it does so via the pr_err log
level which seems unnecessary.  The user cannot do anything about
this and there really isn't an error on the part of Linux to
correct.

This lowers the log level by using pr_notice instead.  Users will
no longer have their boot process uglified by the kernel reminding
us that firmware can and often is broken when the 'quiet' kernel
parameter is specified.  Ironic, considering BGRT is supposed to
make boot pretty to begin with.

	Signed-off-by: Josh Boyer <jwboyer@fedoraproject.org>
	Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
	Reviewed-by: Josh Triplett <josh@joshtriplett.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: MÃ´she van der Sterre <me@moshe.nl>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-efi@vger.kernel.org
Link: http://lkml.kernel.org/r/1462303781-8686-4-git-send-email-matt@codeblueprint.co.uk
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 7f9b474c92713067237c8188f32791cc4007b5da)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/platform/efi/efi-bgrt.c
diff --cc arch/x86/platform/efi/efi-bgrt.c
index e376723efd84,6a2f5691b1ab..000000000000
--- a/arch/x86/platform/efi/efi-bgrt.c
+++ b/arch/x86/platform/efi/efi-bgrt.c
@@@ -42,30 -42,56 +42,72 @@@ void __init efi_bgrt_init(void
  	if (ACPI_FAILURE(status))
  		return;
  
++<<<<<<< HEAD
 +	if (bgrt_tab->header.length < sizeof(*bgrt_tab))
 +		return;
 +	if (bgrt_tab->version != 1 || bgrt_tab->status != 1)
 +		return;
 +	if (bgrt_tab->image_type != 0 || !bgrt_tab->image_address)
 +		return;
++=======
+ 	if (bgrt_tab->header.length < sizeof(*bgrt_tab)) {
+ 		pr_notice("Ignoring BGRT: invalid length %u (expected %zu)\n",
+ 		       bgrt_tab->header.length, sizeof(*bgrt_tab));
+ 		return;
+ 	}
+ 	if (bgrt_tab->version != 1) {
+ 		pr_notice("Ignoring BGRT: invalid version %u (expected 1)\n",
+ 		       bgrt_tab->version);
+ 		return;
+ 	}
+ 	if (bgrt_tab->status & 0xfe) {
+ 		pr_notice("Ignoring BGRT: reserved status bits are non-zero %u\n",
+ 		       bgrt_tab->status);
+ 		return;
+ 	}
+ 	if (bgrt_tab->image_type != 0) {
+ 		pr_notice("Ignoring BGRT: invalid image type %u (expected 0)\n",
+ 		       bgrt_tab->image_type);
+ 		return;
+ 	}
+ 	if (!bgrt_tab->image_address) {
+ 		pr_notice("Ignoring BGRT: null image address\n");
+ 		return;
+ 	}
++>>>>>>> 7f9b474c9271 (x86/efi-bgrt: Switch all pr_err() to pr_notice() for invalid BGRT)
  
 -	image = memremap(bgrt_tab->image_address, sizeof(bmp_header), MEMREMAP_WB);
 +	image = ioremap(bgrt_tab->image_address, sizeof(bmp_header));
  	if (!image) {
- 		pr_err("Ignoring BGRT: failed to map image header memory\n");
+ 		pr_notice("Ignoring BGRT: failed to map image header memory\n");
  		return;
  	}
  
  	memcpy(&bmp_header, image, sizeof(bmp_header));
++<<<<<<< HEAD
 +	iounmap(image);
 +	bgrt_image_size = bmp_header.size;
 +
 +	bgrt_image = kmalloc(bgrt_image_size, GFP_KERNEL);
 +	if (!bgrt_image)
++=======
+ 	memunmap(image);
+ 	if (bmp_header.id != 0x4d42) {
+ 		pr_notice("Ignoring BGRT: Incorrect BMP magic number 0x%x (expected 0x4d42)\n",
+ 			bmp_header.id);
+ 		return;
+ 	}
+ 	bgrt_image_size = bmp_header.size;
+ 
+ 	bgrt_image = kmalloc(bgrt_image_size, GFP_KERNEL | __GFP_NOWARN);
+ 	if (!bgrt_image) {
+ 		pr_notice("Ignoring BGRT: failed to allocate memory for image (wanted %zu bytes)\n",
+ 		       bgrt_image_size);
++>>>>>>> 7f9b474c9271 (x86/efi-bgrt: Switch all pr_err() to pr_notice() for invalid BGRT)
  		return;
 -	}
  
 -	image = memremap(bgrt_tab->image_address, bmp_header.size, MEMREMAP_WB);
 +	image = ioremap(bgrt_tab->image_address, bmp_header.size);
  	if (!image) {
- 		pr_err("Ignoring BGRT: failed to map image memory\n");
+ 		pr_notice("Ignoring BGRT: failed to map image memory\n");
  		kfree(bgrt_image);
  		bgrt_image = NULL;
  		return;
* Unmerged path arch/x86/platform/efi/efi-bgrt.c
