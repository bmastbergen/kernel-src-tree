sctp: abandon the whole msg if one part of a fragmented message is abandoned

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit e5f612969c6f965e3bd1158598e0a3b1c4f389b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/e5f61296.failed

As rfc3758#section-3.1 demands:

   A3) When a TSN is "abandoned", if it is part of a fragmented message,
       all other TSN's within that fragmented message MUST be abandoned
       at the same time.

Besides, if it couldn't handle this, the rest frags would never get
assembled in peer side.

This patch supports it by adding abandoned flag in sctp_datamsg, when
one chunk is being abandoned, set chunk->msg->abandoned as well. Next
time when checking for abandoned, go checking chunk->msg->abandoned
first.

	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e5f612969c6f965e3bd1158598e0a3b1c4f389b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/chunk.c
#	net/sctp/outqueue.c
diff --cc net/sctp/chunk.c
index b2433e21ed45,9213805b558d..000000000000
--- a/net/sctp/chunk.c
+++ b/net/sctp/chunk.c
@@@ -354,16 -305,31 +355,30 @@@ int sctp_chunk_abandoned(struct sctp_ch
  	if (!chunk->asoc->peer.prsctp_capable)
  		return 0;
  
+ 	if (chunk->msg->abandoned)
+ 		return 1;
+ 
  	if (SCTP_PR_TTL_ENABLED(chunk->sinfo.sinfo_flags) &&
  	    time_after(jiffies, chunk->msg->expires_at)) {
 -		struct sctp_stream_out *streamout =
 -			&chunk->asoc->stream.out[chunk->sinfo.sinfo_stream];
 -
 -		if (chunk->sent_count) {
 +		if (chunk->sent_count)
  			chunk->asoc->abandoned_sent[SCTP_PR_INDEX(TTL)]++;
 -			streamout->ext->abandoned_sent[SCTP_PR_INDEX(TTL)]++;
 -		} else {
 +		else
  			chunk->asoc->abandoned_unsent[SCTP_PR_INDEX(TTL)]++;
++<<<<<<< HEAD
++=======
+ 			streamout->ext->abandoned_unsent[SCTP_PR_INDEX(TTL)]++;
+ 		}
+ 		chunk->msg->abandoned = 1;
++>>>>>>> e5f612969c6f (sctp: abandon the whole msg if one part of a fragmented message is abandoned)
  		return 1;
  	} else if (SCTP_PR_RTX_ENABLED(chunk->sinfo.sinfo_flags) &&
  		   chunk->sent_count > chunk->sinfo.sinfo_timetolive) {
 -		struct sctp_stream_out *streamout =
 -			&chunk->asoc->stream.out[chunk->sinfo.sinfo_stream];
 -
  		chunk->asoc->abandoned_sent[SCTP_PR_INDEX(RTX)]++;
++<<<<<<< HEAD
++=======
+ 		streamout->ext->abandoned_sent[SCTP_PR_INDEX(RTX)]++;
+ 		chunk->msg->abandoned = 1;
++>>>>>>> e5f612969c6f (sctp: abandon the whole msg if one part of a fragmented message is abandoned)
  		return 1;
  	} else if (!SCTP_PR_POLICY(chunk->sinfo.sinfo_flags) &&
  		   chunk->msg->expires_at &&
diff --cc net/sctp/outqueue.c
index 4dc8a54e8836,4ab164b5aad0..000000000000
--- a/net/sctp/outqueue.c
+++ b/net/sctp/outqueue.c
@@@ -360,10 -362,14 +360,19 @@@ static int sctp_prsctp_prune_sent(struc
  	struct sctp_chunk *chk, *temp;
  
  	list_for_each_entry_safe(chk, temp, queue, transmitted_list) {
++<<<<<<< HEAD
 +		if (!SCTP_PR_PRIO_ENABLED(chk->sinfo.sinfo_flags) ||
 +		    chk->sinfo.sinfo_timetolive <= sinfo->sinfo_timetolive)
++=======
+ 		struct sctp_stream_out *streamout;
+ 
+ 		if (!chk->msg->abandoned &&
+ 		    (!SCTP_PR_PRIO_ENABLED(chk->sinfo.sinfo_flags) ||
+ 		     chk->sinfo.sinfo_timetolive <= sinfo->sinfo_timetolive))
++>>>>>>> e5f612969c6f (sctp: abandon the whole msg if one part of a fragmented message is abandoned)
  			continue;
  
+ 		chk->msg->abandoned = 1;
  		list_del_init(&chk->transmitted_list);
  		sctp_insert_list(&asoc->outqueue.abandoned,
  				 &chk->transmitted_list);
@@@ -395,15 -403,24 +404,21 @@@ static int sctp_prsctp_prune_unsent(str
  	struct sctp_outq *q = &asoc->outqueue;
  	struct sctp_chunk *chk, *temp;
  
 -	q->sched->unsched_all(&asoc->stream);
 -
  	list_for_each_entry_safe(chk, temp, &q->out_chunk_list, list) {
- 		if (!SCTP_PR_PRIO_ENABLED(chk->sinfo.sinfo_flags) ||
- 		    chk->sinfo.sinfo_timetolive <= sinfo->sinfo_timetolive)
+ 		if (!chk->msg->abandoned &&
+ 		    (!SCTP_PR_PRIO_ENABLED(chk->sinfo.sinfo_flags) ||
+ 		     chk->sinfo.sinfo_timetolive <= sinfo->sinfo_timetolive))
  			continue;
  
++<<<<<<< HEAD
 +		list_del_init(&chk->list);
 +		q->out_qlen -= chk->skb->len;
++=======
+ 		chk->msg->abandoned = 1;
+ 		sctp_sched_dequeue_common(q, chk);
++>>>>>>> e5f612969c6f (sctp: abandon the whole msg if one part of a fragmented message is abandoned)
  		asoc->sent_cnt_removable--;
  		asoc->abandoned_unsent[SCTP_PR_INDEX(PRIO)]++;
 -		if (chk->sinfo.sinfo_stream < asoc->stream.outcnt) {
 -			struct sctp_stream_out *streamout =
 -				&asoc->stream.out[chk->sinfo.sinfo_stream];
 -
 -			streamout->ext->abandoned_unsent[SCTP_PR_INDEX(PRIO)]++;
 -		}
  
  		msg_len -= SCTP_DATA_SNDSIZE(chk) +
  			   sizeof(struct sk_buff) +
diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 6bcd9d18b751..3fe27ba1b4ac 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -537,7 +537,8 @@ struct sctp_datamsg {
 	/* Did the messenge fail to send? */
 	int send_error;
 	u8 send_failed:1,
-	   can_delay;	    /* should this message be Nagle delayed */
+	   can_delay:1,	/* should this message be Nagle delayed */
+	   abandoned:1;	/* should this message be abandoned */
 };
 
 struct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *,
* Unmerged path net/sctp/chunk.c
* Unmerged path net/sctp/outqueue.c
