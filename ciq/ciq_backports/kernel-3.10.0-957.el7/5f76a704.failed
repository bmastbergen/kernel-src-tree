i40e: move client flags into state bits

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 5f76a704b8df9b4da898a230ac40d143eaca9cd8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5f76a704.failed

The iWarp client flags are all potentially changed when the RTNL lock is
not held, so they should not be part of the pf->flags variable. Instead,
move them into the state field so that we can use atomic bit operations.

This is part of a larger effort to remove cmpxchg64 in
i40e_set_priv_flags()

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 5f76a704b8df9b4da898a230ac40d143eaca9cd8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e.h
diff --cc drivers/net/ethernet/intel/i40e/i40e.h
index 1d5305235e57,67518013ca4d..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@@ -159,6 -162,14 +159,15 @@@ enum i40e_state_t 
  	__I40E_RESET_FAILED,
  	__I40E_PORT_SUSPENDED,
  	__I40E_VF_DISABLE,
++<<<<<<< HEAD
++=======
+ 	__I40E_MACVLAN_SYNC_PENDING,
+ 	__I40E_UDP_FILTER_SYNC_PENDING,
+ 	__I40E_TEMP_LINK_POLLING,
+ 	__I40E_CLIENT_SERVICE_REQUESTED,
+ 	__I40E_CLIENT_L2_CHANGE,
+ 	__I40E_CLIENT_RESET,
++>>>>>>> 5f76a704b8df (i40e: move client flags into state bits)
  	/* This must be last as it determines the size of the BITMAP */
  	__I40E_STATE_SIZE__,
  };
@@@ -461,37 -518,37 +470,71 @@@ struct i40e_pf 
  #define I40E_HW_RESTART_AUTONEG			BIT(18)
  #define I40E_HW_STOPPABLE_FW_LLDP		BIT(19)
  
++<<<<<<< HEAD
 +	u32 flags;
 +#define I40E_FLAG_RX_CSUM_ENABLED		BIT(0)
 +#define I40E_FLAG_MSI_ENABLED			BIT(1)
 +#define I40E_FLAG_MSIX_ENABLED			BIT(2)
 +#define I40E_FLAG_RSS_ENABLED			BIT(3)
 +#define I40E_FLAG_VMDQ_ENABLED			BIT(4)
 +#define I40E_FLAG_FILTER_SYNC			BIT(5)
 +#define I40E_FLAG_SRIOV_ENABLED			BIT(6)
 +#define I40E_FLAG_DCB_CAPABLE			BIT(7)
 +#define I40E_FLAG_DCB_ENABLED			BIT(8)
 +#define I40E_FLAG_FD_SB_ENABLED			BIT(9)
 +#define I40E_FLAG_FD_ATR_ENABLED		BIT(10)
 +#define I40E_FLAG_FD_SB_AUTO_DISABLED		BIT(11)
 +#define I40E_FLAG_FD_ATR_AUTO_DISABLED		BIT(12)
 +#define I40E_FLAG_MFP_ENABLED			BIT(13)
 +#define I40E_FLAG_UDP_FILTER_SYNC		BIT(14)
 +#define I40E_FLAG_HW_ATR_EVICT_ENABLED		BIT(15)
 +#define I40E_FLAG_VEB_MODE_ENABLED		BIT(16)
 +#define I40E_FLAG_VEB_STATS_ENABLED		BIT(17)
 +#define I40E_FLAG_LINK_POLLING_ENABLED		BIT(18)
 +#define I40E_FLAG_TRUE_PROMISC_SUPPORT		BIT(19)
 +#define I40E_FLAG_TEMP_LINK_POLLING		BIT(20)
 +#define I40E_FLAG_LEGACY_RX			BIT(21)
 +#define I40E_FLAG_PTP				BIT(22)
 +#define I40E_FLAG_IWARP_ENABLED			BIT(23)
 +#define I40E_FLAG_SERVICE_CLIENT_REQUESTED	BIT(24)
 +#define I40E_FLAG_CLIENT_L2_CHANGE		BIT(25)
 +#define I40E_FLAG_CLIENT_RESET			BIT(26)
 +#define I40E_FLAG_LINK_DOWN_ON_CLOSE_ENABLED	BIT(27)
 +#define I40E_FLAG_SOURCE_PRUNING_DISABLED	BIT(28)
 +#define I40E_FLAG_TC_MQPRIO			BIT(29)
++=======
+ 	u64 flags;
+ #define I40E_FLAG_RX_CSUM_ENABLED		BIT_ULL(0)
+ #define I40E_FLAG_MSI_ENABLED			BIT_ULL(1)
+ #define I40E_FLAG_MSIX_ENABLED			BIT_ULL(2)
+ #define I40E_FLAG_RSS_ENABLED			BIT_ULL(3)
+ #define I40E_FLAG_VMDQ_ENABLED			BIT_ULL(4)
+ /* Gap for BIT_ULL(5) */
+ #define I40E_FLAG_SRIOV_ENABLED			BIT_ULL(6)
+ #define I40E_FLAG_DCB_CAPABLE			BIT_ULL(7)
+ #define I40E_FLAG_DCB_ENABLED			BIT_ULL(8)
+ #define I40E_FLAG_FD_SB_ENABLED			BIT_ULL(9)
+ #define I40E_FLAG_FD_ATR_ENABLED		BIT_ULL(10)
+ /* Gap for BIT_ULL(11) and BIT_ULL(12) */
+ #define I40E_FLAG_MFP_ENABLED			BIT_ULL(13)
+ /* Gap for BIT_ULL(14) */
+ #define I40E_FLAG_HW_ATR_EVICT_ENABLED		BIT_ULL(15)
+ #define I40E_FLAG_VEB_MODE_ENABLED		BIT_ULL(16)
+ #define I40E_FLAG_VEB_STATS_ENABLED		BIT_ULL(17)
+ #define I40E_FLAG_LINK_POLLING_ENABLED		BIT_ULL(18)
+ #define I40E_FLAG_TRUE_PROMISC_SUPPORT		BIT_ULL(19)
+ /* Gap for BIT_ULL(20) */
+ #define I40E_FLAG_LEGACY_RX			BIT_ULL(21)
+ #define I40E_FLAG_PTP				BIT_ULL(22)
+ #define I40E_FLAG_IWARP_ENABLED			BIT_ULL(23)
+ /* Gap for BIT_ULL(24) through BIT_ULL(26) */
+ #define I40E_FLAG_LINK_DOWN_ON_CLOSE_ENABLED	BIT_ULL(27)
+ #define I40E_FLAG_SOURCE_PRUNING_DISABLED	BIT_ULL(28)
+ #define I40E_FLAG_TC_MQPRIO			BIT_ULL(29)
+ #define I40E_FLAG_FD_SB_INACTIVE		BIT_ULL(30)
+ #define I40E_FLAG_FD_SB_TO_CLOUD_FILTER		BIT_ULL(31)
+ #define I40E_FLAG_DISABLE_FW_LLDP		BIT_ULL(32)
++>>>>>>> 5f76a704b8df (i40e: move client flags into state bits)
  
  	struct i40e_client_instance *cinst;
  	bool stat_offsets_loaded;
* Unmerged path drivers/net/ethernet/intel/i40e/i40e.h
diff --git a/drivers/net/ethernet/intel/i40e/i40e_client.c b/drivers/net/ethernet/intel/i40e/i40e_client.c
index 704695a61645..feb71ff2ddf0 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_client.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_client.c
@@ -375,9 +375,8 @@ void i40e_client_subtask(struct i40e_pf *pf)
 	struct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];
 	int ret = 0;
 
-	if (!(pf->flags & I40E_FLAG_SERVICE_CLIENT_REQUESTED))
+	if (!test_and_clear_bit(__I40E_CLIENT_SERVICE_REQUESTED, pf->state))
 		return;
-	pf->flags &= ~I40E_FLAG_SERVICE_CLIENT_REQUESTED;
 	cdev = pf->cinst;
 
 	/* If we're down or resetting, just bail */
@@ -458,7 +457,7 @@ int i40e_lan_add_device(struct i40e_pf *pf)
 	 * added, we can schedule a subtask to go initiate the clients if
 	 * they can be launched at probe time.
 	 */
-	pf->flags |= I40E_FLAG_SERVICE_CLIENT_REQUESTED;
+	set_bit(__I40E_CLIENT_SERVICE_REQUESTED, pf->state);
 	i40e_service_event_schedule(pf);
 
 out:
@@ -553,7 +552,7 @@ static void i40e_client_prepare(struct i40e_client *client)
 		pf = ldev->pf;
 		i40e_client_add_instance(pf);
 		/* Start the client subtask */
-		pf->flags |= I40E_FLAG_SERVICE_CLIENT_REQUESTED;
+		set_bit(__I40E_CLIENT_SERVICE_REQUESTED, pf->state);
 		i40e_service_event_schedule(pf);
 	}
 	mutex_unlock(&i40e_device_mutex);
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index 9299aa15ffea..a4ff7f39ad57 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -2611,8 +2611,8 @@ static int i40e_change_mtu(struct net_device *netdev, int new_mtu)
 	netdev->mtu = new_mtu;
 	if (netif_running(netdev))
 		i40e_vsi_reinit_locked(vsi);
-	pf->flags |= (I40E_FLAG_SERVICE_CLIENT_REQUESTED |
-		      I40E_FLAG_CLIENT_L2_CHANGE);
+	set_bit(__I40E_CLIENT_SERVICE_REQUESTED, pf->state);
+	set_bit(__I40E_CLIENT_L2_CHANGE, pf->state);
 	return 0;
 }
 
@@ -4607,9 +4607,9 @@ static void i40e_vsi_close(struct i40e_vsi *vsi)
 	i40e_vsi_free_tx_resources(vsi);
 	i40e_vsi_free_rx_resources(vsi);
 	vsi->current_netdev_flags = 0;
-	pf->flags |= I40E_FLAG_SERVICE_CLIENT_REQUESTED;
+	set_bit(__I40E_CLIENT_SERVICE_REQUESTED, pf->state);
 	if (test_bit(__I40E_RESET_RECOVERY_PENDING, pf->state))
-		pf->flags |=  I40E_FLAG_CLIENT_RESET;
+		set_bit(__I40E_CLIENT_RESET, pf->state);
 }
 
 /**
@@ -6380,7 +6380,7 @@ static int i40e_up_complete(struct i40e_vsi *vsi)
 	/* On the next run of the service_task, notify any clients of the new
 	 * opened netdev
 	 */
-	pf->flags |= I40E_FLAG_SERVICE_CLIENT_REQUESTED;
+	set_bit(__I40E_CLIENT_SERVICE_REQUESTED, pf->state);
 	i40e_service_event_schedule(pf);
 
 	return 0;
@@ -7207,8 +7207,8 @@ static int i40e_handle_lldp_event(struct i40e_pf *pf,
 		i40e_service_event_schedule(pf);
 	} else {
 		i40e_pf_unquiesce_all_vsi(pf);
-	pf->flags |= (I40E_FLAG_SERVICE_CLIENT_REQUESTED |
-		      I40E_FLAG_CLIENT_L2_CHANGE);
+	set_bit(__I40E_CLIENT_SERVICE_REQUESTED, pf->state);
+	set_bit(__I40E_CLIENT_L2_CHANGE, pf->state);
 	}
 
 exit:
@@ -8892,17 +8892,15 @@ static void i40e_service_task(struct work_struct *work)
 	i40e_vc_process_vflr_event(pf);
 	i40e_watchdog_subtask(pf);
 	i40e_fdir_reinit_subtask(pf);
-	if (pf->flags & I40E_FLAG_CLIENT_RESET) {
+	if (test_and_clear_bit(__I40E_CLIENT_RESET, pf->state)) {
 		/* Client subtask will reopen next time through. */
 		i40e_notify_client_of_netdev_close(pf->vsi[pf->lan_vsi], true);
-		pf->flags &= ~I40E_FLAG_CLIENT_RESET;
 	} else {
 		i40e_client_subtask(pf);
-		if (pf->flags & I40E_FLAG_CLIENT_L2_CHANGE) {
+		if (test_and_clear_bit(__I40E_CLIENT_L2_CHANGE,
+				       pf->state))
 			i40e_notify_client_of_l2_param_changes(
 							pf->vsi[pf->lan_vsi]);
-			pf->flags &= ~I40E_FLAG_CLIENT_L2_CHANGE;
-		}
 	}
 	i40e_sync_filters_subtask(pf);
 	i40e_sync_udp_filters_subtask(pf);
