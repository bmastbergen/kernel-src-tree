md: be cautious about using ->curr_resync_completed for ->recovery_offset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [md] be cautious about using ->curr_resync_completed for ->recovery_offset (Nigel Croxon) [1494474]
Rebuild_FUZZ: 97.18%
commit-author NeilBrown <neilb@suse.com>
commit db0505d320660b6ad92418847e7eca6b61b246ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/db0505d3.failed

The ->recovery_offset shows how much of a non-InSync device is actually
in sync - how much has been recoveryed.

When performing a recovery, ->curr_resync and ->curr_resync_completed
follow the device address being recovered and so can be used to update
->recovery_offset.

When performing a reshape, ->curr_resync* might follow the device
addresses (raid5) or might follow array addresses (raid10), so cannot
in general be used to set ->recovery_offset.  When reshaping backwards,
->curre_resync* measures from the *end* of the array-or-device, so is
particularly unhelpful.

So change the common code in md.c to only use ->curr_resync_complete
for the simple recovery case, and add code to raid5.c to update
->recovery_offset during a forwards reshape.

	Signed-off-by: NeilBrown <neilb@suse.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit db0505d320660b6ad92418847e7eca6b61b246ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
diff --cc drivers/md/md.c
index 23c14e0358c0,15e4668f594c..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -2406,8 -2435,31 +2406,34 @@@ void md_update_sb(struct mddev *mddev, 
  			set_bit(MD_SB_CHANGE_DEVS, &mddev->sb_flags);
  		return;
  	}
 -
  repeat:
++<<<<<<< HEAD
 +	/* First make sure individual recovery_offsets are correct */
++=======
+ 	if (mddev_is_clustered(mddev)) {
+ 		if (test_and_clear_bit(MD_SB_CHANGE_DEVS, &mddev->sb_flags))
+ 			force_change = 1;
+ 		if (test_and_clear_bit(MD_SB_CHANGE_CLEAN, &mddev->sb_flags))
+ 			nospares = 1;
+ 		ret = md_cluster_ops->metadata_update_start(mddev);
+ 		/* Has someone else has updated the sb */
+ 		if (!does_sb_need_changing(mddev)) {
+ 			if (ret == 0)
+ 				md_cluster_ops->metadata_update_cancel(mddev);
+ 			bit_clear_unless(&mddev->sb_flags, BIT(MD_SB_CHANGE_PENDING),
+ 							 BIT(MD_SB_CHANGE_DEVS) |
+ 							 BIT(MD_SB_CHANGE_CLEAN));
+ 			return;
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * First make sure individual recovery_offsets are correct
+ 	 * curr_resync_completed can only be used during recovery.
+ 	 * During reshape/resync it might use array-addresses rather
+ 	 * that device addresses.
+ 	 */
++>>>>>>> db0505d32066 (md: be cautious about using ->curr_resync_completed for ->recovery_offset)
  	rdev_for_each(rdev, mddev) {
  		if (rdev->raid_disk >= 0 &&
  		    mddev->delta_disks >= 0 &&
* Unmerged path drivers/md/md.c
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index dcf6af70c0ff..c7dd2415e998 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -5668,6 +5668,7 @@ static sector_t reshape_request(struct mddev *mddev, sector_t sector_nr, int *sk
 	 */
 	struct r5conf *conf = mddev->private;
 	struct stripe_head *sh;
+	struct md_rdev *rdev;
 	sector_t first_sector, last_sector;
 	int raid_disks = conf->previous_raid_disks;
 	int data_disks = raid_disks - conf->max_degraded;
@@ -5790,6 +5791,15 @@ static sector_t reshape_request(struct mddev *mddev, sector_t sector_nr, int *sk
 			return 0;
 		mddev->reshape_position = conf->reshape_progress;
 		mddev->curr_resync_completed = sector_nr;
+		if (!mddev->reshape_backwards)
+			/* Can update recovery_offset */
+			rdev_for_each(rdev, mddev)
+				if (rdev->raid_disk >= 0 &&
+				    !test_bit(Journal, &rdev->flags) &&
+				    !test_bit(In_sync, &rdev->flags) &&
+				    rdev->recovery_offset < sector_nr)
+					rdev->recovery_offset = sector_nr;
+
 		conf->reshape_checkpoint = jiffies;
 		set_bit(MD_SB_CHANGE_DEVS, &mddev->sb_flags);
 		md_wakeup_thread(mddev->thread);
@@ -5888,6 +5898,14 @@ finish:
 			goto ret;
 		mddev->reshape_position = conf->reshape_progress;
 		mddev->curr_resync_completed = sector_nr;
+		if (!mddev->reshape_backwards)
+			/* Can update recovery_offset */
+			rdev_for_each(rdev, mddev)
+				if (rdev->raid_disk >= 0 &&
+				    !test_bit(Journal, &rdev->flags) &&
+				    !test_bit(In_sync, &rdev->flags) &&
+				    rdev->recovery_offset < sector_nr)
+					rdev->recovery_offset = sector_nr;
 		conf->reshape_checkpoint = jiffies;
 		set_bit(MD_SB_CHANGE_DEVS, &mddev->sb_flags);
 		md_wakeup_thread(mddev->thread);
@@ -7901,6 +7919,7 @@ static void end_reshape(struct r5conf *conf)
 {
 
 	if (!test_bit(MD_RECOVERY_INTR, &conf->mddev->recovery)) {
+		struct md_rdev *rdev;
 
 		spin_lock_irq(&conf->device_lock);
 		conf->previous_raid_disks = conf->raid_disks;
@@ -7908,6 +7927,11 @@ static void end_reshape(struct r5conf *conf)
 		smp_wmb();
 		conf->reshape_progress = MaxSector;
 		conf->mddev->reshape_position = MaxSector;
+		rdev_for_each(rdev, conf->mddev)
+			if (rdev->raid_disk >= 0 &&
+			    !test_bit(Journal, &rdev->flags) &&
+			    !test_bit(In_sync, &rdev->flags))
+				rdev->recovery_offset = MaxSector;
 		spin_unlock_irq(&conf->device_lock);
 		wake_up(&conf->wait_for_overlap);
 
