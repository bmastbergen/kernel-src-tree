scsi: qla2xxx: Fix Firmware dump size for Extended login and Exchange Offload

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Fix Firmware dump size for Extended login and Exchange Offload (Himanshu Madhani) [1547714]
Rebuild_FUZZ: 95.95%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit ad0a0b01f088f676d4e1f511a18d2f1469420635
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ad0a0b01.failed

This patch adjusts and reallocates fw_dump memory for target mode
to save for extended login and exchange offload buffers into
dump captured.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit ad0a0b01f088f676d4e1f511a18d2f1469420635)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 83ad7d90d14e,fc307752b2f5..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -2469,71 -2729,13 +2542,44 @@@ qla2x00_alloc_fw_dump(scsi_qla_host_t *
  		    !IS_QLA27XX(ha))
  			goto try_eft;
  
++<<<<<<< HEAD
 +try_fce:
 +		if (ha->fce)
 +			dma_free_coherent(&ha->pdev->dev,
 +			    FCE_SIZE, ha->fce, ha->fce_dma);
 +
 +		/* Allocate memory for Fibre Channel Event Buffer. */
 +		tc = dma_zalloc_coherent(&ha->pdev->dev, FCE_SIZE, &tc_dma,
 +					GFP_KERNEL);
 +		if (!tc) {
 +			ql_log(ql_log_warn, vha, 0x00be,
 +			    "Unable to allocate (%d KB) for FCE.\n",
 +			    FCE_SIZE / 1024);
 +			goto try_eft;
 +		}
 +
 +		rval = qla2x00_enable_fce_trace(vha, tc_dma, FCE_NUM_BUFFERS,
 +		    ha->fce_mb, &ha->fce_bufs);
 +		if (rval) {
 +			ql_log(ql_log_warn, vha, 0x00bf,
 +			    "Unable to initialize FCE (%d).\n", rval);
 +			dma_free_coherent(&ha->pdev->dev, FCE_SIZE, tc,
 +			    tc_dma);
 +			ha->flags.fce_enabled = 0;
 +			goto try_eft;
 +		}
 +		ql_dbg(ql_dbg_init, vha, 0x00c0,
 +		    "Allocate (%d KB) for FCE...\n", FCE_SIZE / 1024);
 +
++=======
++>>>>>>> ad0a0b01f088 (scsi: qla2xxx: Fix Firmware dump size for Extended login and Exchange Offload)
  		fce_size = sizeof(struct qla2xxx_fce_chain) + FCE_SIZE;
- 		ha->flags.fce_enabled = 1;
- 		ha->fce_dma = tc_dma;
- 		ha->fce = tc;
- 
  try_eft:
- 		if (ha->eft)
- 			dma_free_coherent(&ha->pdev->dev,
- 			    EFT_SIZE, ha->eft, ha->eft_dma);
- 
- 		/* Allocate memory for Extended Trace Buffer. */
- 		tc = dma_zalloc_coherent(&ha->pdev->dev, EFT_SIZE, &tc_dma,
- 					 GFP_KERNEL);
- 		if (!tc) {
- 			ql_log(ql_log_warn, vha, 0x00c1,
- 			    "Unable to allocate (%d KB) for EFT.\n",
- 			    EFT_SIZE / 1024);
- 			goto cont_alloc;
- 		}
- 
- 		rval = qla2x00_enable_eft_trace(vha, tc_dma, EFT_NUM_BUFFERS);
- 		if (rval) {
- 			ql_log(ql_log_warn, vha, 0x00c2,
- 			    "Unable to initialize EFT (%d).\n", rval);
- 			dma_free_coherent(&ha->pdev->dev, EFT_SIZE, tc,
- 			    tc_dma);
- 			goto cont_alloc;
- 		}
  		ql_dbg(ql_dbg_init, vha, 0x00c3,
  		    "Allocated (%d KB) EFT ...\n", EFT_SIZE / 1024);
- 
  		eft_size = EFT_SIZE;
- 		ha->eft_dma = tc_dma;
- 		ha->eft = tc;
  	}
  
- cont_alloc:
  	if (IS_QLA27XX(ha)) {
  		if (!ha->fw_dump_template) {
  			ql_log(ql_log_warn, vha, 0x00ba,
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_tmpl.c b/drivers/scsi/qla2xxx/qla_tmpl.c
index 118ec68b6b41..2000a972786c 100644
--- a/drivers/scsi/qla2xxx/qla_tmpl.c
+++ b/drivers/scsi/qla2xxx/qla_tmpl.c
@@ -526,7 +526,8 @@ qla27xx_fwdt_entry_t268(struct scsi_qla_host *vha,
 {
 	ql_dbg(ql_dbg_misc, vha, 0xd20c,
 	    "%s: gethb(%x) [%lx]\n", __func__, ent->t268.buf_type, *len);
-	if (ent->t268.buf_type == T268_BUF_TYPE_EXTD_TRACE) {
+	switch (ent->t268.buf_type) {
+	case T268_BUF_TYPE_EXTD_TRACE:
 		if (vha->hw->eft) {
 			if (buf) {
 				ent->t268.buf_size = EFT_SIZE;
@@ -538,10 +539,43 @@ qla27xx_fwdt_entry_t268(struct scsi_qla_host *vha,
 			    "%s: missing eft\n", __func__);
 			qla27xx_skip_entry(ent, buf);
 		}
-	} else {
-		ql_dbg(ql_dbg_misc, vha, 0xd02b,
+		break;
+	case T268_BUF_TYPE_EXCH_BUFOFF:
+		if (vha->hw->exchoffld_buf) {
+			if (buf) {
+				ent->t268.buf_size = vha->hw->exchoffld_size;
+				ent->t268.start_addr =
+					vha->hw->exchoffld_buf_dma;
+			}
+			qla27xx_insertbuf(vha->hw->exchoffld_buf,
+			    vha->hw->exchoffld_size, buf, len);
+		} else {
+			ql_dbg(ql_dbg_misc, vha, 0xd028,
+			    "%s: missing exch offld\n", __func__);
+			qla27xx_skip_entry(ent, buf);
+		}
+		break;
+	case T268_BUF_TYPE_EXTD_LOGIN:
+		if (vha->hw->exlogin_buf) {
+			if (buf) {
+				ent->t268.buf_size = vha->hw->exlogin_size;
+				ent->t268.start_addr =
+					vha->hw->exlogin_buf_dma;
+			}
+			qla27xx_insertbuf(vha->hw->exlogin_buf,
+			    vha->hw->exlogin_size, buf, len);
+		} else {
+			ql_dbg(ql_dbg_misc, vha, 0xd028,
+			    "%s: missing ext login\n", __func__);
+			qla27xx_skip_entry(ent, buf);
+		}
+		break;
+
+	default:
+		ql_dbg(ql_dbg_async, vha, 0xd02b,
 		    "%s: unknown buffer %x\n", __func__, ent->t268.buf_type);
 		qla27xx_skip_entry(ent, buf);
+		break;
 	}
 
 	return false;
