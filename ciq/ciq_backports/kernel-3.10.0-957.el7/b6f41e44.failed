xfs: remove boilerplate around xfs_btree_init_block

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Eric Sandeen <sandeen@sandeen.net>
commit b6f41e448277ff080fea734b93121e6cd7513f0c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b6f41e44.failed

Now that xfs_btree_init_block_int is able to determine crc
status from the passed-in mp, we can determine the proper
magic as well if we are given a btree number, rather than
an explicit magic value.

Change xfs_btree_init_block[_int] callers to pass in the
btree number, and let xfs_btree_init_block_int use the
xfs_magics array via the xfs_btree_magic macro to determine
which magic value is needed.  This makes all of the
if (crc) / else stanzas identical, and the if/else can be
removed, leading to a single, common init_block call.

	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit b6f41e448277ff080fea734b93121e6cd7513f0c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/libxfs/xfs_bmap_btree.c
#	fs/xfs/libxfs/xfs_btree.c
#	fs/xfs/xfs_fsops.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 9518d7cd5523,d3da53e6a927..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -709,15 -740,9 +709,21 @@@ xfs_bmap_extents_to_btree
  	 * Fill in the root.
  	 */
  	block = ifp->if_broot;
++<<<<<<< HEAD
 +	if (xfs_sb_version_hascrc(&mp->m_sb))
 +		xfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,
 +				 XFS_BMAP_CRC_MAGIC, 1, 1, ip->i_ino,
 +				 XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);
 +	else
 +		xfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,
 +				 XFS_BMAP_MAGIC, 1, 1, ip->i_ino,
 +				 XFS_BTREE_LONG_PTRS);
 +
++=======
+ 	xfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,
+ 				 XFS_BTNUM_BMAP, 1, 1, ip->i_ino,
+ 				 XFS_BTREE_LONG_PTRS);
++>>>>>>> b6f41e448277 (xfs: remove boilerplate around xfs_btree_init_block)
  	/*
  	 * Need a cursor.  Can't allocate until bb_level is filled in.
  	 */
@@@ -769,13 -811,8 +775,18 @@@
  	 */
  	abp->b_ops = &xfs_bmbt_buf_ops;
  	ablock = XFS_BUF_TO_BLOCK(abp);
++<<<<<<< HEAD
 +	if (xfs_sb_version_hascrc(&mp->m_sb))
 +		xfs_btree_init_block_int(mp, ablock, abp->b_bn,
 +				XFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,
 +				XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);
 +	else
 +		xfs_btree_init_block_int(mp, ablock, abp->b_bn,
 +				XFS_BMAP_MAGIC, 0, 0, ip->i_ino,
++=======
+ 	xfs_btree_init_block_int(mp, ablock, abp->b_bn,
+ 				XFS_BTNUM_BMAP, 0, 0, ip->i_ino,
++>>>>>>> b6f41e448277 (xfs: remove boilerplate around xfs_btree_init_block)
  				XFS_BTREE_LONG_PTRS);
  
  	arp = XFS_BMBT_REC_ADDR(mp, ablock, 1);
diff --cc fs/xfs/libxfs/xfs_bmap_btree.c
index 02efded83ebf,f93072b58a58..000000000000
--- a/fs/xfs/libxfs/xfs_bmap_btree.c
+++ b/fs/xfs/libxfs/xfs_bmap_btree.c
@@@ -70,15 -71,9 +70,21 @@@ xfs_bmdr_to_bmbt
  	xfs_bmbt_key_t		*tkp;
  	__be64			*tpp;
  
++<<<<<<< HEAD
 +	if (xfs_sb_version_hascrc(&mp->m_sb))
 +		xfs_btree_init_block_int(mp, rblock, XFS_BUF_DADDR_NULL,
 +				 XFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,
 +				 XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);
 +	else
 +		xfs_btree_init_block_int(mp, rblock, XFS_BUF_DADDR_NULL,
 +				 XFS_BMAP_MAGIC, 0, 0, ip->i_ino,
 +				 XFS_BTREE_LONG_PTRS);
 +
++=======
+ 	xfs_btree_init_block_int(mp, rblock, XFS_BUF_DADDR_NULL,
+ 				 XFS_BTNUM_BMAP, 0, 0, ip->i_ino,
+ 				 XFS_BTREE_LONG_PTRS);
++>>>>>>> b6f41e448277 (xfs: remove boilerplate around xfs_btree_init_block)
  	rblock->bb_level = dblock->bb_level;
  	ASSERT(be16_to_cpu(rblock->bb_level) > 0);
  	rblock->bb_numrecs = dblock->bb_numrecs;
diff --cc fs/xfs/libxfs/xfs_btree.c
index 604608bcd791,421efa0ef778..000000000000
--- a/fs/xfs/libxfs/xfs_btree.c
+++ b/fs/xfs/libxfs/xfs_btree.c
@@@ -1037,6 -1106,9 +1037,12 @@@ xfs_btree_init_block_int
  	__u64			owner,
  	unsigned int		flags)
  {
++<<<<<<< HEAD
++=======
+ 	int			crc = xfs_sb_version_hascrc(&mp->m_sb);
+ 	__u32			magic = xfs_btree_magic(crc, btnum);
+ 
++>>>>>>> b6f41e448277 (xfs: remove boilerplate around xfs_btree_init_block)
  	buf->bb_magic = cpu_to_be32(magic);
  	buf->bb_level = cpu_to_be16(level);
  	buf->bb_numrecs = cpu_to_be16(numrecs);
diff --cc fs/xfs/xfs_fsops.c
index 4c191d2194e8,6ccaae9eb0ee..000000000000
--- a/fs/xfs/xfs_fsops.c
+++ b/fs/xfs/xfs_fsops.c
@@@ -332,15 -352,10 +332,19 @@@ xfs_growfs_data_private
  			goto error0;
  		}
  
++<<<<<<< HEAD
 +		if (xfs_sb_version_hascrc(&mp->m_sb))
 +			xfs_btree_init_block(mp, bp, XFS_ABTB_CRC_MAGIC, 0, 1,
 +						agno, XFS_BTREE_CRC_BLOCKS);
 +		else
 +			xfs_btree_init_block(mp, bp, XFS_ABTB_MAGIC, 0, 1,
 +						agno, 0);
++=======
+ 		xfs_btree_init_block(mp, bp, XFS_BTNUM_BNO, 0, 1, agno, 0);
++>>>>>>> b6f41e448277 (xfs: remove boilerplate around xfs_btree_init_block)
  
  		arec = XFS_ALLOC_REC_ADDR(mp, XFS_BUF_TO_BLOCK(bp), 1);
 -		arec->ar_startblock = cpu_to_be32(mp->m_ag_prealloc_blocks);
 +		arec->ar_startblock = cpu_to_be32(XFS_PREALLOC_BLOCKS(mp));
  		arec->ar_blockcount = cpu_to_be32(
  			agsize - be32_to_cpu(arec->ar_startblock));
  
@@@ -361,15 -376,10 +365,19 @@@
  			goto error0;
  		}
  
++<<<<<<< HEAD
 +		if (xfs_sb_version_hascrc(&mp->m_sb))
 +			xfs_btree_init_block(mp, bp, XFS_ABTC_CRC_MAGIC, 0, 1,
 +						agno, XFS_BTREE_CRC_BLOCKS);
 +		else
 +			xfs_btree_init_block(mp, bp, XFS_ABTC_MAGIC, 0, 1,
 +						agno, 0);
++=======
+ 		xfs_btree_init_block(mp, bp, XFS_BTNUM_CNT, 0, 1, agno, 0);
++>>>>>>> b6f41e448277 (xfs: remove boilerplate around xfs_btree_init_block)
  
  		arec = XFS_ALLOC_REC_ADDR(mp, XFS_BUF_TO_BLOCK(bp), 1);
 -		arec->ar_startblock = cpu_to_be32(mp->m_ag_prealloc_blocks);
 +		arec->ar_startblock = cpu_to_be32(XFS_PREALLOC_BLOCKS(mp));
  		arec->ar_blockcount = cpu_to_be32(
  			agsize - be32_to_cpu(arec->ar_startblock));
  		nfree += be32_to_cpu(arec->ar_blockcount);
@@@ -379,6 -389,83 +387,86 @@@
  		if (error)
  			goto error0;
  
++<<<<<<< HEAD
++=======
+ 		/* RMAP btree root block */
+ 		if (xfs_sb_version_hasrmapbt(&mp->m_sb)) {
+ 			struct xfs_rmap_rec	*rrec;
+ 			struct xfs_btree_block	*block;
+ 
+ 			bp = xfs_growfs_get_hdr_buf(mp,
+ 				XFS_AGB_TO_DADDR(mp, agno, XFS_RMAP_BLOCK(mp)),
+ 				BTOBB(mp->m_sb.sb_blocksize), 0,
+ 				&xfs_rmapbt_buf_ops);
+ 			if (!bp) {
+ 				error = -ENOMEM;
+ 				goto error0;
+ 			}
+ 
+ 			xfs_btree_init_block(mp, bp, XFS_BTNUM_RMAP, 0, 0,
+ 						agno, 0);
+ 			block = XFS_BUF_TO_BLOCK(bp);
+ 
+ 
+ 			/*
+ 			 * mark the AG header regions as static metadata The BNO
+ 			 * btree block is the first block after the headers, so
+ 			 * it's location defines the size of region the static
+ 			 * metadata consumes.
+ 			 *
+ 			 * Note: unlike mkfs, we never have to account for log
+ 			 * space when growing the data regions
+ 			 */
+ 			rrec = XFS_RMAP_REC_ADDR(block, 1);
+ 			rrec->rm_startblock = 0;
+ 			rrec->rm_blockcount = cpu_to_be32(XFS_BNO_BLOCK(mp));
+ 			rrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_FS);
+ 			rrec->rm_offset = 0;
+ 			be16_add_cpu(&block->bb_numrecs, 1);
+ 
+ 			/* account freespace btree root blocks */
+ 			rrec = XFS_RMAP_REC_ADDR(block, 2);
+ 			rrec->rm_startblock = cpu_to_be32(XFS_BNO_BLOCK(mp));
+ 			rrec->rm_blockcount = cpu_to_be32(2);
+ 			rrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_AG);
+ 			rrec->rm_offset = 0;
+ 			be16_add_cpu(&block->bb_numrecs, 1);
+ 
+ 			/* account inode btree root blocks */
+ 			rrec = XFS_RMAP_REC_ADDR(block, 3);
+ 			rrec->rm_startblock = cpu_to_be32(XFS_IBT_BLOCK(mp));
+ 			rrec->rm_blockcount = cpu_to_be32(XFS_RMAP_BLOCK(mp) -
+ 							XFS_IBT_BLOCK(mp));
+ 			rrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_INOBT);
+ 			rrec->rm_offset = 0;
+ 			be16_add_cpu(&block->bb_numrecs, 1);
+ 
+ 			/* account for rmap btree root */
+ 			rrec = XFS_RMAP_REC_ADDR(block, 4);
+ 			rrec->rm_startblock = cpu_to_be32(XFS_RMAP_BLOCK(mp));
+ 			rrec->rm_blockcount = cpu_to_be32(1);
+ 			rrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_AG);
+ 			rrec->rm_offset = 0;
+ 			be16_add_cpu(&block->bb_numrecs, 1);
+ 
+ 			/* account for refc btree root */
+ 			if (xfs_sb_version_hasreflink(&mp->m_sb)) {
+ 				rrec = XFS_RMAP_REC_ADDR(block, 5);
+ 				rrec->rm_startblock = cpu_to_be32(
+ 						xfs_refc_block(mp));
+ 				rrec->rm_blockcount = cpu_to_be32(1);
+ 				rrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_REFC);
+ 				rrec->rm_offset = 0;
+ 				be16_add_cpu(&block->bb_numrecs, 1);
+ 			}
+ 
+ 			error = xfs_bwrite(bp);
+ 			xfs_buf_relse(bp);
+ 			if (error)
+ 				goto error0;
+ 		}
+ 
++>>>>>>> b6f41e448277 (xfs: remove boilerplate around xfs_btree_init_block)
  		/*
  		 * INO btree root block
  		 */
@@@ -391,12 -478,7 +479,16 @@@
  			goto error0;
  		}
  
++<<<<<<< HEAD
 +		if (xfs_sb_version_hascrc(&mp->m_sb))
 +			xfs_btree_init_block(mp, bp, XFS_IBT_CRC_MAGIC, 0, 0,
 +						agno, XFS_BTREE_CRC_BLOCKS);
 +		else
 +			xfs_btree_init_block(mp, bp, XFS_IBT_MAGIC, 0, 0,
 +						agno, 0);
++=======
+ 		xfs_btree_init_block(mp, bp, XFS_BTNUM_INO , 0, 0, agno, 0);
++>>>>>>> b6f41e448277 (xfs: remove boilerplate around xfs_btree_init_block)
  
  		error = xfs_bwrite(bp);
  		xfs_buf_relse(bp);
@@@ -416,13 -498,8 +508,18 @@@
  				goto error0;
  			}
  
++<<<<<<< HEAD
 +			if (xfs_sb_version_hascrc(&mp->m_sb))
 +				xfs_btree_init_block(mp, bp, XFS_FIBT_CRC_MAGIC,
 +						     0, 0, agno,
 +						     XFS_BTREE_CRC_BLOCKS);
 +			else
 +				xfs_btree_init_block(mp, bp, XFS_FIBT_MAGIC, 0,
 +						     0, agno, 0);
++=======
+ 			xfs_btree_init_block(mp, bp, XFS_BTNUM_FINO,
+ 						     0, 0, agno, 0);
++>>>>>>> b6f41e448277 (xfs: remove boilerplate around xfs_btree_init_block)
  
  			error = xfs_bwrite(bp);
  			xfs_buf_relse(bp);
@@@ -430,6 -507,27 +527,30 @@@
  				goto error0;
  		}
  
++<<<<<<< HEAD
++=======
+ 		/*
+ 		 * refcount btree root block
+ 		 */
+ 		if (xfs_sb_version_hasreflink(&mp->m_sb)) {
+ 			bp = xfs_growfs_get_hdr_buf(mp,
+ 				XFS_AGB_TO_DADDR(mp, agno, xfs_refc_block(mp)),
+ 				BTOBB(mp->m_sb.sb_blocksize), 0,
+ 				&xfs_refcountbt_buf_ops);
+ 			if (!bp) {
+ 				error = -ENOMEM;
+ 				goto error0;
+ 			}
+ 
+ 			xfs_btree_init_block(mp, bp, XFS_BTNUM_REFC,
+ 					     0, 0, agno, 0);
+ 
+ 			error = xfs_bwrite(bp);
+ 			xfs_buf_relse(bp);
+ 			if (error)
+ 				goto error0;
+ 		}
++>>>>>>> b6f41e448277 (xfs: remove boilerplate around xfs_btree_init_block)
  	}
  	xfs_trans_agblocks_delta(tp, nfree);
  	/*
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
* Unmerged path fs/xfs/libxfs/xfs_bmap_btree.c
* Unmerged path fs/xfs/libxfs/xfs_btree.c
diff --git a/fs/xfs/libxfs/xfs_btree.h b/fs/xfs/libxfs/xfs_btree.h
index e45e21c30a23..88f2e6537e1a 100644
--- a/fs/xfs/libxfs/xfs_btree.h
+++ b/fs/xfs/libxfs/xfs_btree.h
@@ -386,7 +386,7 @@ void
 xfs_btree_init_block(
 	struct xfs_mount *mp,
 	struct xfs_buf	*bp,
-	__u32		magic,
+	xfs_btnum_t	btnum,
 	__u16		level,
 	__u16		numrecs,
 	__u64		owner,
@@ -397,7 +397,7 @@ xfs_btree_init_block_int(
 	struct xfs_mount	*mp,
 	struct xfs_btree_block	*buf,
 	xfs_daddr_t		blkno,
-	__u32			magic,
+	xfs_btnum_t		btnum,
 	__u16			level,
 	__u16			numrecs,
 	__u64			owner,
* Unmerged path fs/xfs/xfs_fsops.c
