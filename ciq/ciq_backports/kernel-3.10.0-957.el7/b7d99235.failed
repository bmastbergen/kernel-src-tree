nfp: bpf: fix immed relocation for larger offsets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit b7d99235473ad3a550f8eb05bd4469edadf1c8e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b7d99235.failed

Immed relocation is missing a shift which means for larger
offsets the lower and higher part of the address would be
ORed together.

Fixes: ce4ebfd859c3 ("nfp: bpf: add helpers for updating immediate instructions")
	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Jiong Wang <jiong.wang@netronome.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit b7d99235473ad3a550f8eb05bd4469edadf1c8e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_asm.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_asm.c
index 1fbe2c4bc84e,1e597600c693..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_asm.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_asm.c
@@@ -49,6 -50,94 +49,97 @@@ const struct cmd_tgt_act cmd_tgt_act[__
  	[CMD_TGT_READ_SWAP_LE] =	{ 0x03, 0x40 },
  };
  
++<<<<<<< HEAD
++=======
+ static bool unreg_is_imm(u16 reg)
+ {
+ 	return (reg & UR_REG_IMM) == UR_REG_IMM;
+ }
+ 
+ u16 br_get_offset(u64 instr)
+ {
+ 	u16 addr_lo, addr_hi;
+ 
+ 	addr_lo = FIELD_GET(OP_BR_ADDR_LO, instr);
+ 	addr_hi = FIELD_GET(OP_BR_ADDR_HI, instr);
+ 
+ 	return (addr_hi * ((OP_BR_ADDR_LO >> __bf_shf(OP_BR_ADDR_LO)) + 1)) |
+ 		addr_lo;
+ }
+ 
+ void br_set_offset(u64 *instr, u16 offset)
+ {
+ 	u16 addr_lo, addr_hi;
+ 
+ 	addr_lo = offset & (OP_BR_ADDR_LO >> __bf_shf(OP_BR_ADDR_LO));
+ 	addr_hi = offset != addr_lo;
+ 	*instr &= ~(OP_BR_ADDR_HI | OP_BR_ADDR_LO);
+ 	*instr |= FIELD_PREP(OP_BR_ADDR_HI, addr_hi);
+ 	*instr |= FIELD_PREP(OP_BR_ADDR_LO, addr_lo);
+ }
+ 
+ void br_add_offset(u64 *instr, u16 offset)
+ {
+ 	u16 addr;
+ 
+ 	addr = br_get_offset(*instr);
+ 	br_set_offset(instr, addr + offset);
+ }
+ 
+ static bool immed_can_modify(u64 instr)
+ {
+ 	if (FIELD_GET(OP_IMMED_INV, instr) ||
+ 	    FIELD_GET(OP_IMMED_SHIFT, instr) ||
+ 	    FIELD_GET(OP_IMMED_WIDTH, instr) != IMMED_WIDTH_ALL) {
+ 		pr_err("Can't decode/encode immed!\n");
+ 		return false;
+ 	}
+ 	return true;
+ }
+ 
+ u16 immed_get_value(u64 instr)
+ {
+ 	u16 reg;
+ 
+ 	if (!immed_can_modify(instr))
+ 		return 0;
+ 
+ 	reg = FIELD_GET(OP_IMMED_A_SRC, instr);
+ 	if (!unreg_is_imm(reg))
+ 		reg = FIELD_GET(OP_IMMED_B_SRC, instr);
+ 
+ 	return (reg & 0xff) | FIELD_GET(OP_IMMED_IMM, instr) << 8;
+ }
+ 
+ void immed_set_value(u64 *instr, u16 immed)
+ {
+ 	if (!immed_can_modify(*instr))
+ 		return;
+ 
+ 	if (unreg_is_imm(FIELD_GET(OP_IMMED_A_SRC, *instr))) {
+ 		*instr &= ~FIELD_PREP(OP_IMMED_A_SRC, 0xff);
+ 		*instr |= FIELD_PREP(OP_IMMED_A_SRC, immed & 0xff);
+ 	} else {
+ 		*instr &= ~FIELD_PREP(OP_IMMED_B_SRC, 0xff);
+ 		*instr |= FIELD_PREP(OP_IMMED_B_SRC, immed & 0xff);
+ 	}
+ 
+ 	*instr &= ~OP_IMMED_IMM;
+ 	*instr |= FIELD_PREP(OP_IMMED_IMM, immed >> 8);
+ }
+ 
+ void immed_add_value(u64 *instr, u16 offset)
+ {
+ 	u16 val;
+ 
+ 	if (!immed_can_modify(*instr))
+ 		return;
+ 
+ 	val = immed_get_value(*instr);
+ 	immed_set_value(instr, val + offset);
+ }
+ 
++>>>>>>> b7d99235473a (nfp: bpf: fix immed relocation for larger offsets)
  static u16 nfp_swreg_to_unreg(swreg reg, bool is_dst)
  {
  	bool lm_id, lm_dec = false;
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_asm.c
