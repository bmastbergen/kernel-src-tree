s390: hypfs: Move diag implementation and data definitions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [s390] hypfs: Move diag implementation and data definitions (Hendrik Brueckner) [1519343]
Rebuild_FUZZ: 94.55%
commit-author Janosch Frank <frankja@linux.vnet.ibm.com>
commit e65f30e0cb29694c4241bd9c96ea9413938fcec5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/e65f30e0.failed

Diag 204 data and function definitions currently live in the hypfs
files. As KVM will be a consumer of this data, we need to make it
publicly available and move it to the appropriate diag.{c,h} files.

__attribute__ ((packed)) occurences were replaced with __packed for
all moved structs.

	Signed-off-by: Janosch Frank <frankja@linux.vnet.ibm.com>
	Reviewed-by: David Hildenbrand <dahi@linux.vnet.ibm.com>
	Acked-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
	Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
(cherry picked from commit e65f30e0cb29694c4241bd9c96ea9413938fcec5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/hypfs/hypfs_diag.c
#	arch/s390/include/asm/diag.h
diff --cc arch/s390/hypfs/hypfs_diag.c
index 7fd3690b6760,1e28414d7275..000000000000
--- a/arch/s390/hypfs/hypfs_diag.c
+++ b/arch/s390/hypfs/hypfs_diag.c
@@@ -335,22 -210,6 +209,25 @@@ static inline __u64 phys_cpu__ctidx(enu
  }
  
  /* Diagnose 204 functions */
++<<<<<<< HEAD
 +
 +static int diag204(unsigned long subcode, unsigned long size, void *addr)
 +{
 +	register unsigned long _subcode asm("0") = subcode;
 +	register unsigned long _size asm("1") = size;
 +
 +	asm volatile(
 +		"	diag	%2,%0,0x204\n"
 +		"0:\n"
 +		EX_TABLE(0b,0b)
 +		: "+d" (_subcode), "+d" (_size) : "d" (addr) : "memory");
 +	if (_subcode)
 +		return -1;
 +	return _size;
 +}
 +
++=======
++>>>>>>> e65f30e0cb29 (s390: hypfs: Move diag implementation and data definitions)
  /*
   * For the old diag subcode 4 with simple data format we have to use real
   * memory. If we use subcode 6 or 7 with extended data format, we can (and
@@@ -642,8 -501,8 +519,13 @@@ static int hypfs_create_cpu_files(struc
  			      cpu_info__lp_time(diag204_info_type, cpu_info));
  	if (IS_ERR(rc))
  		return PTR_ERR(rc);
++<<<<<<< HEAD
 +	if (diag204_info_type == INFO_EXT) {
 +		rc = hypfs_create_u64(sb, cpu_dir, "onlinetime",
++=======
+ 	if (diag204_info_type == DIAG204_INFO_EXT) {
+ 		rc = hypfs_create_u64(cpu_dir, "onlinetime",
++>>>>>>> e65f30e0cb29 (s390: hypfs: Move diag implementation and data definitions)
  				      cpu_info__online_time(diag204_info_type,
  							    cpu_info));
  		if (IS_ERR(rc))
@@@ -666,11 -522,11 +548,16 @@@ static void *hypfs_create_lpar_files(st
  	int i;
  
  	part_hdr__part_name(diag204_info_type, part_hdr, lpar_name);
++<<<<<<< HEAD
 +	lpar_name[LPAR_NAME_LEN] = 0;
 +	lpar_dir = hypfs_mkdir(sb, systems_dir, lpar_name);
++=======
+ 	lpar_name[DIAG204_LPAR_NAME_LEN] = 0;
+ 	lpar_dir = hypfs_mkdir(systems_dir, lpar_name);
++>>>>>>> e65f30e0cb29 (s390: hypfs: Move diag implementation and data definitions)
  	if (IS_ERR(lpar_dir))
  		return lpar_dir;
 -	cpus_dir = hypfs_mkdir(lpar_dir, "cpus");
 +	cpus_dir = hypfs_mkdir(sb, lpar_dir, "cpus");
  	if (IS_ERR(cpus_dir))
  		return cpus_dir;
  	cpu_info = part_hdr + part_hdr__size(diag204_info_type);
@@@ -753,8 -605,9 +640,14 @@@ int hypfs_diag_create_files(struct supe
  			goto err_out;
  		}
  	}
++<<<<<<< HEAD
 +	if (info_blk_hdr__flags(diag204_info_type, time_hdr) & LPAR_PHYS_FLG) {
 +		ptr = hypfs_create_phys_files(sb, root, part_hdr);
++=======
+ 	if (info_blk_hdr__flags(diag204_info_type, time_hdr) &
+ 	    DIAG204_LPAR_PHYS_FLG) {
+ 		ptr = hypfs_create_phys_files(root, part_hdr);
++>>>>>>> e65f30e0cb29 (s390: hypfs: Move diag implementation and data definitions)
  		if (IS_ERR(ptr)) {
  			rc = PTR_ERR(ptr);
  			goto err_out;
diff --cc arch/s390/include/asm/diag.h
index 244335e704b3,f72744f14e31..000000000000
--- a/arch/s390/include/asm/diag.h
+++ b/arch/s390/include/asm/diag.h
@@@ -51,29 -78,131 +51,159 @@@ struct diag210 
  
  extern int diag210(struct diag210 *addr);
  
++<<<<<<< HEAD
 +enum diag26c_sc {
 +	DIAG26C_MAC_SERVICES = 0x00000030
 +};
 +
 +enum diag26c_version {
 +	DIAG26C_VERSION2 = 0x00000002	/* z/VM 5.4.0 */
 +};
 +
 +#define DIAG26C_GET_MAC	0x0000
 +struct diag26c_mac_req {
 +	u32	resp_buf_len;
 +	u32	resp_version;
 +	u16	op_code;
 +	u16	devno;
 +	u8	res[4];
 +};
 +
 +struct diag26c_mac_resp {
 +	u32	version;
 +	u8	mac[ETH_ALEN];
 +	u8	res[2];
 +} __aligned(8);
 +
 +int diag26c(void *req, void *resp, enum diag26c_sc subcode);
 +
++=======
+ /* bit is set in flags, when physical cpu info is included in diag 204 data */
+ #define DIAG204_LPAR_PHYS_FLG 0x80
+ #define DIAG204_LPAR_NAME_LEN 8		/* lpar name len in diag 204 data */
+ #define DIAG204_CPU_NAME_LEN 16		/* type name len of cpus in diag224 name table */
+ 
+ /* diag 204 subcodes */
+ enum diag204_sc {
+ 	DIAG204_SUBC_STIB4 = 4,
+ 	DIAG204_SUBC_RSI = 5,
+ 	DIAG204_SUBC_STIB6 = 6,
+ 	DIAG204_SUBC_STIB7 = 7
+ };
+ 
+ /* The two available diag 204 data formats */
+ enum diag204_format {
+ 	DIAG204_INFO_SIMPLE = 0,
+ 	DIAG204_INFO_EXT = 0x00010000
+ };
+ 
+ struct diag204_info_blk_hdr {
+ 	__u8  npar;
+ 	__u8  flags;
+ 	__u16 tslice;
+ 	__u16 phys_cpus;
+ 	__u16 this_part;
+ 	__u64 curtod;
+ } __packed;
+ 
+ struct diag204_x_info_blk_hdr {
+ 	__u8  npar;
+ 	__u8  flags;
+ 	__u16 tslice;
+ 	__u16 phys_cpus;
+ 	__u16 this_part;
+ 	__u64 curtod1;
+ 	__u64 curtod2;
+ 	char reserved[40];
+ } __packed;
+ 
+ struct diag204_part_hdr {
+ 	__u8 pn;
+ 	__u8 cpus;
+ 	char reserved[6];
+ 	char part_name[DIAG204_LPAR_NAME_LEN];
+ } __packed;
+ 
+ struct diag204_x_part_hdr {
+ 	__u8  pn;
+ 	__u8  cpus;
+ 	__u8  rcpus;
+ 	__u8  pflag;
+ 	__u32 mlu;
+ 	char  part_name[DIAG204_LPAR_NAME_LEN];
+ 	char  lpc_name[8];
+ 	char  os_name[8];
+ 	__u64 online_cs;
+ 	__u64 online_es;
+ 	__u8  upid;
+ 	char  reserved1[3];
+ 	__u32 group_mlu;
+ 	char  group_name[8];
+ 	char  reserved2[32];
+ } __packed;
+ 
+ struct diag204_cpu_info {
+ 	__u16 cpu_addr;
+ 	char  reserved1[2];
+ 	__u8  ctidx;
+ 	__u8  cflag;
+ 	__u16 weight;
+ 	__u64 acc_time;
+ 	__u64 lp_time;
+ } __packed;
+ 
+ struct diag204_x_cpu_info {
+ 	__u16 cpu_addr;
+ 	char  reserved1[2];
+ 	__u8  ctidx;
+ 	__u8  cflag;
+ 	__u16 weight;
+ 	__u64 acc_time;
+ 	__u64 lp_time;
+ 	__u16 min_weight;
+ 	__u16 cur_weight;
+ 	__u16 max_weight;
+ 	char  reseved2[2];
+ 	__u64 online_time;
+ 	__u64 wait_time;
+ 	__u32 pma_weight;
+ 	__u32 polar_weight;
+ 	char  reserved3[40];
+ } __packed;
+ 
+ struct diag204_phys_hdr {
+ 	char reserved1[1];
+ 	__u8 cpus;
+ 	char reserved2[6];
+ 	char mgm_name[8];
+ } __packed;
+ 
+ struct diag204_x_phys_hdr {
+ 	char reserved1[1];
+ 	__u8 cpus;
+ 	char reserved2[6];
+ 	char mgm_name[8];
+ 	char reserved3[80];
+ } __packed;
+ 
+ struct diag204_phys_cpu {
+ 	__u16 cpu_addr;
+ 	char  reserved1[2];
+ 	__u8  ctidx;
+ 	char  reserved2[3];
+ 	__u64 mgm_time;
+ 	char  reserved3[8];
+ } __packed;
+ 
+ struct diag204_x_phys_cpu {
+ 	__u16 cpu_addr;
+ 	char  reserved1[2];
+ 	__u8  ctidx;
+ 	char  reserved2[3];
+ 	__u64 mgm_time;
+ 	char  reserved3[80];
+ } __packed;
+ 
+ int diag204(unsigned long subcode, unsigned long size, void *addr);
++>>>>>>> e65f30e0cb29 (s390: hypfs: Move diag implementation and data definitions)
  #endif /* _ASM_S390_DIAG_H */
* Unmerged path arch/s390/hypfs/hypfs_diag.c
* Unmerged path arch/s390/include/asm/diag.h
diff --git a/arch/s390/kernel/diag.c b/arch/s390/kernel/diag.c
index 06f939d5dbc5..785326432a28 100644
--- a/arch/s390/kernel/diag.c
+++ b/arch/s390/kernel/diag.c
@@ -35,6 +35,28 @@ int diag14(unsigned long rx, unsigned long ry1, unsigned long subcode)
 }
 EXPORT_SYMBOL(diag14);
 
+static inline int __diag204(unsigned long subcode, unsigned long size, void *addr)
+{
+	register unsigned long _subcode asm("0") = subcode;
+	register unsigned long _size asm("1") = size;
+
+	asm volatile(
+		"	diag	%2,%0,0x204\n"
+		"0:\n"
+		EX_TABLE(0b,0b)
+		: "+d" (_subcode), "+d" (_size) : "d" (addr) : "memory");
+	if (_subcode)
+		return -1;
+	return _size;
+}
+
+int diag204(unsigned long subcode, unsigned long size, void *addr)
+{
+	diag_stat_inc(DIAG_STAT_X204);
+	return __diag204(subcode, size, addr);
+}
+EXPORT_SYMBOL(diag204);
+
 /*
  * Diagnose 210: Get information about a virtual device
  */
