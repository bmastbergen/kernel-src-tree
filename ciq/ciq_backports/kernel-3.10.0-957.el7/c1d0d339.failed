sfc: MAC TX timestamp handling on the 8000 series

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Martin Habets <mhabets@solarflare.com>
commit c1d0d33946725775be1c68515c07d0ff8237d222
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c1d0d339.failed

TX timestamps on 8000 series are supplied from the MAC. This timestamp is
 only 48 bits long. The high order bits from the last time sync event are
 used for the top 16 bits.

	Signed-off-by: Martin Habets <mhabets@solarflare.com>
	Signed-off-by: Edward Cree <ecree@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c1d0d33946725775be1c68515c07d0ff8237d222)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/ptp.c
diff --cc drivers/net/ethernet/sfc/ptp.c
index 6d90793c008f,0d0160f15c35..000000000000
--- a/drivers/net/ethernet/sfc/ptp.c
+++ b/drivers/net/ethernet/sfc/ptp.c
@@@ -473,6 -483,60 +473,63 @@@ static ktime_t efx_ptp_s27_to_ktime_cor
  	return efx_ptp_s27_to_ktime(nic_major, nic_minor);
  }
  
++<<<<<<< HEAD
++=======
+ struct efx_channel *efx_ptp_channel(struct efx_nic *efx)
+ {
+ 	return efx->ptp_data ? efx->ptp_data->channel : NULL;
+ }
+ 
+ static u32 last_sync_timestamp_major(struct efx_nic *efx)
+ {
+ 	struct efx_channel *channel = efx_ptp_channel(efx);
+ 	u32 major = 0;
+ 
+ 	if (channel)
+ 		major = channel->sync_timestamp_major;
+ 	return major;
+ }
+ 
+ /* The 8000 series and later can provide the time from the MAC, which is only
+  * 48 bits long and provides meta-information in the top 2 bits.
+  */
+ static ktime_t
+ efx_ptp_mac_s27_to_ktime_correction(struct efx_nic *efx,
+ 				    u32 nic_major, u32 nic_minor,
+ 				    s32 correction)
+ {
+ 	ktime_t kt = { 0 };
+ 
+ 	if (!(nic_major & 0x80000000)) {
+ 		WARN_ON_ONCE(nic_major >> 16);
+ 		/* Use the top bits from the latest sync event. */
+ 		nic_major &= 0xffff;
+ 		nic_major |= (last_sync_timestamp_major(efx) & 0xffff0000);
+ 
+ 		kt = efx_ptp_s27_to_ktime_correction(nic_major, nic_minor,
+ 						     correction);
+ 	}
+ 	return kt;
+ }
+ 
+ ktime_t efx_ptp_nic_to_kernel_time(struct efx_tx_queue *tx_queue)
+ {
+ 	struct efx_nic *efx = tx_queue->efx;
+ 	struct efx_ptp_data *ptp = efx->ptp_data;
+ 	ktime_t kt;
+ 
+ 	if (efx_ptp_use_mac_tx_timestamps(efx))
+ 		kt = efx_ptp_mac_s27_to_ktime_correction(efx,
+ 				tx_queue->completed_timestamp_major,
+ 				tx_queue->completed_timestamp_minor, 0);
+ 	else
+ 		kt = ptp->nic_to_kernel_time(
+ 				tx_queue->completed_timestamp_major,
+ 				tx_queue->completed_timestamp_minor, 0);
+ 	return kt;
+ }
+ 
++>>>>>>> c1d0d3394672 (sfc: MAC TX timestamp handling on the 8000 series)
  /* Get PTP attributes and set up time conversions */
  static int efx_ptp_get_attributes(struct efx_nic *efx)
  {
diff --git a/drivers/net/ethernet/sfc/nic.h b/drivers/net/ethernet/sfc/nic.h
index 2ec4a3784bf4..3b944211d60a 100644
--- a/drivers/net/ethernet/sfc/nic.h
+++ b/drivers/net/ethernet/sfc/nic.h
@@ -449,6 +449,7 @@ void efx_fini_sriov(void);
 struct ethtool_ts_info;
 int efx_ptp_probe(struct efx_nic *efx, struct efx_channel *channel);
 void efx_ptp_defer_probe_with_channel(struct efx_nic *efx);
+struct efx_channel *efx_ptp_channel(struct efx_nic *efx);
 void efx_ptp_remove(struct efx_nic *efx);
 int efx_ptp_set_ts_config(struct efx_nic *efx, struct ifreq *ifr);
 int efx_ptp_get_ts_config(struct efx_nic *efx, struct ifreq *ifr);
* Unmerged path drivers/net/ethernet/sfc/ptp.c
