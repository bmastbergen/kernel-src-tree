x86/microcode: Propagate return value from updating functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] microcode: Propagate return value from updating functions (Prarit Bhargava) [1568249]
Rebuild_FUZZ: 96.61%
commit-author Borislav Petkov <bp@suse.de>
commit 3f1f576a195aa266813cbd4ca70291deb61e0129
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3f1f576a.failed

... so that callers can know when microcode was updated and act
accordingly.

	Tested-by: Ashok Raj <ashok.raj@intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Ashok Raj <ashok.raj@intel.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Arjan van de Ven <arjan@linux.intel.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: David Woodhouse <dwmw2@infradead.org>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/20180216112640.11554-2-bp@alien8.de
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 3f1f576a195aa266813cbd4ca70291deb61e0129)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/microcode/amd.c
#	arch/x86/kernel/cpu/microcode/core.c
#	arch/x86/kernel/cpu/microcode/intel.c
diff --cc arch/x86/kernel/cpu/microcode/amd.c
index 0d1af0efc84a,a998e1a7d46f..000000000000
--- a/arch/x86/kernel/cpu/microcode/amd.c
+++ b/arch/x86/kernel/cpu/microcode/amd.c
@@@ -621,68 -498,7 +621,72 @@@ static unsigned int verify_patch_size(u
  	return patch_size;
  }
  
++<<<<<<< HEAD
 +/*
 + * Those patch levels cannot be updated to newer ones and thus should be final.
 + */
 +static u32 final_levels[] = {
 +	0x01000098,
 +	0x0100009f,
 +	0x010000af,
 +	0, /* T-101 terminator */
 +};
 +
 +/*
 + * Check the current patch level on this CPU.
 + *
 + * @rev: Use it to return the patch level. It is set to 0 in the case of
 + * error.
 + *
 + * Returns:
 + *  - true: if update should stop
 + *  - false: otherwise
 + */
 +bool check_current_patch_level(u32 *rev, bool early)
 +{
 +	u32 lvl, dummy, i;
 +	bool ret = false;
 +	u32 *levels;
 +
 +	native_rdmsr(MSR_AMD64_PATCH_LEVEL, lvl, dummy);
 +
 +	if (IS_ENABLED(CONFIG_X86_32) && early)
 +		levels = (u32 *)__pa_nodebug(&final_levels);
 +	else
 +		levels = final_levels;
 +
 +	for (i = 0; levels[i]; i++) {
 +		if (lvl == levels[i]) {
 +			lvl = 0;
 +			ret = true;
 +			break;
 +		}
 +	}
 +
 +	if (rev)
 +		*rev = lvl;
 +
 +	return ret;
 +}
 +
 +int __apply_microcode_amd(struct microcode_amd *mc_amd)
 +{
 +	u32 rev, dummy;
 +
 +	native_wrmsrl(MSR_AMD64_PATCH_LOADER, (u64)(long)&mc_amd->hdr.data_code);
 +
 +	/* verify patch application was successful */
 +	native_rdmsr(MSR_AMD64_PATCH_LEVEL, rev, dummy);
 +	if (rev != mc_amd->hdr.patch_id)
 +		return -1;
 +
 +	return 0;
 +}
 +
 +int apply_microcode_amd(int cpu)
++=======
+ static enum ucode_state apply_microcode_amd(int cpu)
++>>>>>>> 3f1f576a195a (x86/microcode: Propagate return value from updating functions)
  {
  	struct cpuinfo_x86 *c = &cpu_data(cpu);
  	struct microcode_amd *mc_amd;
diff --cc arch/x86/kernel/cpu/microcode/core.c
index 1b81185d9250,6fdaf7cf3182..000000000000
--- a/arch/x86/kernel/cpu/microcode/core.c
+++ b/arch/x86/kernel/cpu/microcode/core.c
@@@ -406,17 -524,18 +404,25 @@@ static ssize_t reload_store(struct devi
  	mutex_lock(&microcode_mutex);
  	for_each_online_cpu(cpu) {
  		tmp_ret = reload_for_cpu(cpu);
- 		if (tmp_ret != 0)
+ 		if (tmp_ret > UCODE_NFOUND) {
  			pr_warn("Error reloading microcode on CPU %d\n", cpu);
  
- 		/* save retval of the first encountered reload error */
- 		if (!ret)
- 			ret = tmp_ret;
+ 			/* set retval for the first encountered reload error */
+ 			if (!ret)
+ 				ret = -EINVAL;
+ 		}
  	}
++<<<<<<< HEAD
 +	if (!ret) {
 +		perf_check_microcode();
 +		spec_ctrl_rescan_cpuid();
 +	}
++=======
+ 
+ 	if (!ret && tmp_ret == UCODE_UPDATED)
+ 		perf_check_microcode();
+ 
++>>>>>>> 3f1f576a195a (x86/microcode: Propagate return value from updating functions)
  	mutex_unlock(&microcode_mutex);
  	put_online_cpus();
  
diff --cc arch/x86/kernel/cpu/microcode/intel.c
index c7e50a8f4783,923054a6b760..000000000000
--- a/arch/x86/kernel/cpu/microcode/intel.c
+++ b/arch/x86/kernel/cpu/microcode/intel.c
@@@ -883,25 -772,7 +883,29 @@@ static int collect_cpu_info(int cpu_num
  	return 0;
  }
  
++<<<<<<< HEAD
 +/*
 + * return 0 - no update found
 + * return 1 - found update
 + */
 +static int get_matching_mc(struct microcode_intel *mc, int cpu)
 +{
 +	struct cpu_signature cpu_sig;
 +	unsigned int csig, cpf, crev;
 +
 +	collect_cpu_info(cpu, &cpu_sig);
 +
 +	csig = cpu_sig.sig;
 +	cpf = cpu_sig.pf;
 +	crev = cpu_sig.rev;
 +
 +	return has_newer_microcode(mc, csig, cpf, crev);
 +}
 +
 +static int apply_microcode_intel(int cpu)
++=======
+ static enum ucode_state apply_microcode_intel(int cpu)
++>>>>>>> 3f1f576a195a (x86/microcode: Propagate return value from updating functions)
  {
  	struct microcode_intel *mc;
  	struct ucode_cpu_info *uci;
@@@ -915,36 -786,27 +919,45 @@@
  
  	uci = ucode_cpu_info + cpu;
  	mc = uci->mc;
++<<<<<<< HEAD
 +	if (!mc)
 +		return 0;
 +
 +	/*
 +	 * Microcode on this CPU could be updated earlier. Only apply the
 +	 * microcode patch in mc when it is newer than the one on this
 +	 * CPU.
 +	 */
 +	if (!get_matching_mc(mc, cpu))
 +		return 0;
++=======
+ 	if (!mc) {
+ 		/* Look for a newer patch in our cache: */
+ 		mc = find_patch(uci);
+ 		if (!mc)
+ 			return UCODE_NFOUND;
+ 	}
++>>>>>>> 3f1f576a195a (x86/microcode: Propagate return value from updating functions)
  
  	/* write microcode via MSR 0x79 */
  	wrmsrl(MSR_IA32_UCODE_WRITE, (unsigned long)mc->bits);
 +	wrmsrl(MSR_IA32_UCODE_REV, 0);
  
 -	rev = intel_get_microcode_revision();
 +	/* As documented in the SDM: Do a CPUID 1 here */
 +	sync_core();
  
 -	if (rev != mc->hdr.rev) {
 +	/* get the current revision from MSR 0x8B */
 +	rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);
 +
 +	if (val[1] != mc->hdr.rev) {
  		pr_err("CPU%d update to revision 0x%x failed\n",
  		       cpu, mc->hdr.rev);
- 		return -1;
+ 		return UCODE_ERROR;
  	}
  
 -	if (rev != prev_rev) {
 +	if (val[1] != prev_rev) {
  		pr_info("updated to revision 0x%x, date = %04x-%02x-%02x\n",
 -			rev,
 +			val[1],
  			mc->hdr.date & 0xffff,
  			mc->hdr.date >> 24,
  			(mc->hdr.date >> 16) & 0xff);
@@@ -953,10 -815,10 +966,10 @@@
  
  	c = &cpu_data(cpu);
  
 -	uci->cpu_sig.rev = rev;
 -	c->microcode = rev;
 +	uci->cpu_sig.rev = val[1];
 +	c->microcode = val[1];
  
- 	return 0;
+ 	return UCODE_UPDATED;
  }
  
  static enum ucode_state generic_load_microcode(int cpu, void *data, size_t size,
diff --git a/arch/x86/include/asm/microcode.h b/arch/x86/include/asm/microcode.h
index ca2af7ed6cbf..ff66485b1f5b 100644
--- a/arch/x86/include/asm/microcode.h
+++ b/arch/x86/include/asm/microcode.h
@@ -28,7 +28,12 @@ struct cpu_signature {
 
 struct device;
 
-enum ucode_state { UCODE_ERROR, UCODE_OK, UCODE_NFOUND };
+enum ucode_state {
+	UCODE_OK	= 0,
+	UCODE_UPDATED,
+	UCODE_NFOUND,
+	UCODE_ERROR,
+};
 
 struct microcode_ops {
 	enum ucode_state (*request_microcode_user) (int cpu,
@@ -45,7 +50,7 @@ struct microcode_ops {
 	 * are being called.
 	 * See also the "Synchronization" section in microcode_core.c.
 	 */
-	int (*apply_microcode) (int cpu);
+	enum ucode_state (*apply_microcode) (int cpu);
 	int (*collect_cpu_info) (int cpu, struct cpu_signature *csig);
 };
 
* Unmerged path arch/x86/kernel/cpu/microcode/amd.c
* Unmerged path arch/x86/kernel/cpu/microcode/core.c
* Unmerged path arch/x86/kernel/cpu/microcode/intel.c
