netfilter: Convert pr_warning to pr_warn

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Joe Perches <joe@perches.com>
commit b167a37c7bbc6f7589f439ba7d9a49af5ad37ff5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b167a37c.failed

Use the more common pr_warn.

Other miscellanea:

o Coalesce formats
o Realign arguments

	Signed-off-by: Joe Perches <joe@perches.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b167a37c7bbc6f7589f439ba7d9a49af5ad37ff5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_hash_gen.h
#	net/netfilter/xt_set.c
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 72686abe715e,80f49dfba555..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -907,10 -997,10 +907,17 @@@ mtype_list(const struct ip_set *set
  
  nla_put_failure:
  	nlmsg_trim(skb, incomplete);
++<<<<<<< HEAD
 +	if (unlikely(first == cb->args[2])) {
 +		pr_warning("Can't list set %s: one bucket does not fit into "
 +			   "a message. Please report it!\n", set->name);
 +		cb->args[2] = 0;
++=======
+ 	if (unlikely(first == cb->args[IPSET_CB_ARG0])) {
+ 		pr_warn("Can't list set %s: one bucket does not fit into a message. Please report it!\n",
+ 			set->name);
+ 		cb->args[IPSET_CB_ARG0] = 0;
++>>>>>>> b167a37c7bbc (netfilter: Convert pr_warning to pr_warn)
  		return -EMSGSIZE;
  	}
  	ipset_nest_end(skb, atd);
diff --cc net/netfilter/xt_set.c
index e7c4e0e01ff5,cb70f6ec5695..000000000000
--- a/net/netfilter/xt_set.c
+++ b/net/netfilter/xt_set.c
@@@ -84,8 -84,8 +84,13 @@@ set_match_v0_checkentry(const struct xt
  	index = ip_set_nfnl_get_byindex(par->net, info->match_set.index);
  
  	if (index == IPSET_INVALID_ID) {
++<<<<<<< HEAD
 +		pr_warning("Cannot find set indentified by id %u to match\n",
 +			   info->match_set.index);
++=======
+ 		pr_warn("Cannot find set identified by id %u to match\n",
+ 			info->match_set.index);
++>>>>>>> b167a37c7bbc (netfilter: Convert pr_warning to pr_warn)
  		return -ENOENT;
  	}
  	if (info->match_set.u.flags[IPSET_DIM_MAX-1] != 0) {
@@@ -134,8 -133,8 +138,13 @@@ set_match_v1_checkentry(const struct xt
  	index = ip_set_nfnl_get_byindex(par->net, info->match_set.index);
  
  	if (index == IPSET_INVALID_ID) {
++<<<<<<< HEAD
 +		pr_warning("Cannot find set indentified by id %u to match\n",
 +			   info->match_set.index);
++=======
+ 		pr_warn("Cannot find set identified by id %u to match\n",
+ 			info->match_set.index);
++>>>>>>> b167a37c7bbc (netfilter: Convert pr_warning to pr_warn)
  		return -ENOENT;
  	}
  	if (info->match_set.dim > IPSET_DIM_MAX) {
diff --git a/net/netfilter/ipset/ip_set_core.c b/net/netfilter/ipset/ip_set_core.c
index d17e4090573d..a6f3b2ccb51b 100644
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@ -102,7 +102,7 @@ load_settype(const char *name)
 	nfnl_unlock(NFNL_SUBSYS_IPSET);
 	pr_debug("try to load ip_set_%s\n", name);
 	if (request_module("ip_set_%s", name) < 0) {
-		pr_warning("Can't find ip_set type %s\n", name);
+		pr_warn("Can't find ip_set type %s\n", name);
 		nfnl_lock(NFNL_SUBSYS_IPSET);
 		return false;
 	}
@@ -196,20 +196,19 @@ ip_set_type_register(struct ip_set_type *type)
 	int ret = 0;
 
 	if (type->protocol != IPSET_PROTOCOL) {
-		pr_warning("ip_set type %s, family %s, revision %u:%u uses "
-			   "wrong protocol version %u (want %u)\n",
-			   type->name, family_name(type->family),
-			   type->revision_min, type->revision_max,
-			   type->protocol, IPSET_PROTOCOL);
+		pr_warn("ip_set type %s, family %s, revision %u:%u uses wrong protocol version %u (want %u)\n",
+			type->name, family_name(type->family),
+			type->revision_min, type->revision_max,
+			type->protocol, IPSET_PROTOCOL);
 		return -EINVAL;
 	}
 
 	ip_set_type_lock();
 	if (find_set_type(type->name, type->family, type->revision_min)) {
 		/* Duplicate! */
-		pr_warning("ip_set type %s, family %s with revision min %u "
-			   "already registered!\n", type->name,
-			   family_name(type->family), type->revision_min);
+		pr_warn("ip_set type %s, family %s with revision min %u already registered!\n",
+			type->name, family_name(type->family),
+			type->revision_min);
 		ret = -EINVAL;
 		goto unlock;
 	}
@@ -229,9 +228,9 @@ ip_set_type_unregister(struct ip_set_type *type)
 {
 	ip_set_type_lock();
 	if (!find_set_type(type->name, type->family, type->revision_min)) {
-		pr_warning("ip_set type %s, family %s with revision min %u "
-			   "not registered\n", type->name,
-			   family_name(type->family), type->revision_min);
+		pr_warn("ip_set type %s, family %s with revision min %u not registered\n",
+			type->name, family_name(type->family),
+			type->revision_min);
 		goto unlock;
 	}
 	list_del_rcu(&type->list);
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
diff --git a/net/netfilter/xt_connbytes.c b/net/netfilter/xt_connbytes.c
index e595e07a759b..81da779797d4 100644
--- a/net/netfilter/xt_connbytes.c
+++ b/net/netfilter/xt_connbytes.c
@@ -118,7 +118,7 @@ static int connbytes_mt_check(const struct xt_mtchk_param *par)
 	 * accounting is enabled, so complain in the hope that someone notices.
 	 */
 	if (!nf_ct_acct_enabled(par->net)) {
-		pr_warning("Forcing CT accounting to be enabled\n");
+		pr_warn("Forcing CT accounting to be enabled\n");
 		nf_ct_set_acct(par->net, true);
 	}
 
diff --git a/net/netfilter/xt_hashlimit.c b/net/netfilter/xt_hashlimit.c
index 91945c2ac9d2..7996bd063ab3 100644
--- a/net/netfilter/xt_hashlimit.c
+++ b/net/netfilter/xt_hashlimit.c
@@ -945,7 +945,7 @@ static int __init hashlimit_mt_init(void)
 					    sizeof(struct dsthash_ent), 0, 0,
 					    NULL);
 	if (!hashlimit_cachep) {
-		pr_warning("unable to create slab cache\n");
+		pr_warn("unable to create slab cache\n");
 		goto err2;
 	}
 	return 0;
* Unmerged path net/netfilter/xt_set.c
