[media] au0828: Add timer to restart TS stream if no data arrives on bulk endpoint

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [usb] au0828: Add timer to restart TS stream if no data arrives on bulk endpoint (Torez Smith) [1540721]
Rebuild_FUZZ: 94.87%
commit-author Devin Heitmueller <dheitmueller@kernellabs.com>
commit 53460c53b7619c14e8564a3ba2c60fc27f303f6b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/53460c53.failed

For reasons unclear, we intermittently see a case where the tune
is successful but the bulk stream fails to deliver any packets.

Add a timer to automatically stop/start the data pump if we
encounter such a case.

	Signed-off-by: Devin Heitmueller <dheitmueller@kernellabs.com>
	Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
	Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
(cherry picked from commit 53460c53b7619c14e8564a3ba2c60fc27f303f6b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/usb/au0828/au0828-dvb.c
diff --cc drivers/media/usb/au0828/au0828-dvb.c
index 9a6f15613a38,34dc7e062471..000000000000
--- a/drivers/media/usb/au0828/au0828-dvb.c
+++ b/drivers/media/usb/au0828/au0828-dvb.c
@@@ -151,11 -173,23 +167,23 @@@ static int stop_urb_transfer(struct au0
  
  	dprintk(2, "%s()\n", __func__);
  
++<<<<<<< HEAD
 +	dev->urb_streaming = 0;
++=======
+ 	if (!dev->urb_streaming)
+ 		return 0;
+ 
+ 	if (dev->bulk_timeout_running == 1) {
+ 		dev->bulk_timeout_running = 0;
+ 		del_timer(&dev->bulk_timeout);
+ 	}
+ 
+ 	dev->urb_streaming = false;
++>>>>>>> 53460c53b761 ([media] au0828: Add timer to restart TS stream if no data arrives on bulk endpoint)
  	for (i = 0; i < URB_COUNT; i++) {
 -		if (dev->urbs[i]) {
 -			usb_kill_urb(dev->urbs[i]);
 -			if (!preallocate_big_buffers)
 -				kfree(dev->urbs[i]->transfer_buffer);
 -
 -			usb_free_urb(dev->urbs[i]);
 -		}
 +		usb_kill_urb(dev->urbs[i]);
 +		kfree(dev->urbs[i]->transfer_buffer);
 +		usb_free_urb(dev->urbs[i]);
  	}
  
  	return 0;
@@@ -210,11 -252,32 +238,22 @@@ static int start_urb_transfer(struct au
  		}
  	}
  
++<<<<<<< HEAD
 +	dev->urb_streaming = 1;
 +	ret = 0;
++=======
+ 	dev->urb_streaming = true;
+ 
+ 	/* If we don't valid data within 1 second, restart stream */
+ 	mod_timer(&dev->bulk_timeout, jiffies + (HZ));
+ 	dev->bulk_timeout_running = 1;
+ 
+ 	return 0;
+ }
++>>>>>>> 53460c53b761 ([media] au0828: Add timer to restart TS stream if no data arrives on bulk endpoint)
  
 -static void au0828_start_transport(struct au0828_dev *dev)
 -{
 -	au0828_write(dev, 0x608, 0x90);
 -	au0828_write(dev, 0x609, 0x72);
 -	au0828_write(dev, 0x60a, 0x71);
 -	au0828_write(dev, 0x60b, 0x01);
 -
 -}
 -
 -static void au0828_stop_transport(struct au0828_dev *dev, int full_stop)
 -{
 -	if (full_stop) {
 -		au0828_write(dev, 0x608, 0x00);
 -		au0828_write(dev, 0x609, 0x00);
 -		au0828_write(dev, 0x60a, 0x00);
 -	}
 -	au0828_write(dev, 0x60b, 0x00);
 +err:
 +	return ret;
  }
  
  static int au0828_dvb_start_feed(struct dvb_demux_feed *feed)
@@@ -495,5 -647,50 +534,9 @@@ int au0828_dvb_register(struct au0828_d
  		return ret;
  	}
  
+ 	dev->bulk_timeout.function = au0828_bulk_timeout;
+ 	dev->bulk_timeout.data = (unsigned long) dev;
+ 	init_timer(&dev->bulk_timeout);
+ 
  	return 0;
  }
 -
 -void au0828_dvb_suspend(struct au0828_dev *dev)
 -{
 -	struct au0828_dvb *dvb = &dev->dvb;
 -	int rc;
 -
 -	if (dvb->frontend) {
 -		if (dev->urb_streaming) {
 -			cancel_work_sync(&dev->restart_streaming);
 -			/* Stop transport */
 -			mutex_lock(&dvb->lock);
 -			stop_urb_transfer(dev);
 -			au0828_stop_transport(dev, 1);
 -			mutex_unlock(&dvb->lock);
 -			dev->need_urb_start = true;
 -		}
 -		/* suspend frontend - does tuner and fe to sleep */
 -		rc = dvb_frontend_suspend(dvb->frontend);
 -		pr_info("au0828_dvb_suspend(): Suspending DVB fe %d\n", rc);
 -	}
 -}
 -
 -void au0828_dvb_resume(struct au0828_dev *dev)
 -{
 -	struct au0828_dvb *dvb = &dev->dvb;
 -	int rc;
 -
 -	if (dvb->frontend) {
 -		/* resume frontend - does fe and tuner init */
 -		rc = dvb_frontend_resume(dvb->frontend);
 -		pr_info("au0828_dvb_resume(): Resuming DVB fe %d\n", rc);
 -		if (dev->need_urb_start) {
 -			/* Start transport */
 -			mutex_lock(&dvb->lock);
 -			au0828_start_transport(dev);
 -			start_urb_transfer(dev);
 -			mutex_unlock(&dvb->lock);
 -		}
 -	}
 -}
* Unmerged path drivers/media/usb/au0828/au0828-dvb.c
diff --git a/drivers/media/usb/au0828/au0828.h b/drivers/media/usb/au0828/au0828.h
index ef1f57f22be7..c60f4f89f49e 100644
--- a/drivers/media/usb/au0828/au0828.h
+++ b/drivers/media/usb/au0828/au0828.h
@@ -203,6 +203,8 @@ struct au0828_dev {
 	/* Digital */
 	struct au0828_dvb		dvb;
 	struct work_struct              restart_streaming;
+	struct timer_list               bulk_timeout;
+	int                             bulk_timeout_running;
 
 #ifdef CONFIG_VIDEO_AU0828_V4L2
 	/* Analog */
