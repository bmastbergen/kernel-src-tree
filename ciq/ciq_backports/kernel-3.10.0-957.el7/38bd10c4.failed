net: ipv6: Delete host routes on an ifdown

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] ipv6: Delete host routes on an ifdown (Ivan Vecera) [1500871]
Rebuild_FUZZ: 93.67%
commit-author David Ahern <dsa@cumulusnetworks.com>
commit 38bd10c447f8e8980753149a8a65108159871df5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/38bd10c4.failed

It was a simple idea -- save IPv6 configured addresses on a link down
so that IPv6 behaves similar to IPv4. As always the devil is in the
details and the IPv6 stack as too many behavioral differences from IPv4
making the simple idea more complicated than it needs to be.

The current implementation for keeping IPv6 addresses can panic or spit
out a warning in one of many paths:

1. IPv6 route gets an IPv4 route as its 'next' which causes a panic in
   rt6_fill_node while handling a route dump request.

2. rt->dst.obsolete is set to DST_OBSOLETE_DEAD hitting the WARN_ON in
   fib6_del

3. Panic in fib6_purge_rt because rt6i_ref count is not 1.

The root cause of all these is references related to the host route for
an address that is retained.

So, this patch deletes the host route every time the ifdown loop runs.
Since the host route is deleted and will be re-generated an up there is
no longer a need for the l3mdev fix up. On the 'admin up' side move
addrconf_permanent_addr into the NETDEV_UP event handling so that it
runs only once versus on UP and CHANGE events.

All of the current panics and warnings appear to be related to
addresses on the loopback device, but given the catastrophic nature when
a bug is triggered this patch takes the conservative approach and evicts
all host routes rather than trying to determine when it can be re-used
and when it can not. That can be a later optimizaton if desired.

	Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 38bd10c447f8e8980753149a8a65108159871df5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/addrconf.c
diff --cc net/ipv6/addrconf.c
index e92da293a901,8ec4b3089e20..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -3071,6 -3176,55 +3071,58 @@@ static void addrconf_gre_config(struct 
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ static int fixup_permanent_addr(struct inet6_dev *idev,
+ 				struct inet6_ifaddr *ifp)
+ {
+ 	if (!ifp->rt) {
+ 		struct rt6_info *rt;
+ 
+ 		rt = addrconf_dst_alloc(idev, &ifp->addr, false);
+ 		if (unlikely(IS_ERR(rt)))
+ 			return PTR_ERR(rt);
+ 
+ 		ifp->rt = rt;
+ 	}
+ 
+ 	if (!(ifp->flags & IFA_F_NOPREFIXROUTE)) {
+ 		addrconf_prefix_route(&ifp->addr, ifp->prefix_len,
+ 				      idev->dev, 0, 0);
+ 	}
+ 
+ 	addrconf_dad_start(ifp);
+ 
+ 	return 0;
+ }
+ 
+ static void addrconf_permanent_addr(struct net_device *dev)
+ {
+ 	struct inet6_ifaddr *ifp, *tmp;
+ 	struct inet6_dev *idev;
+ 
+ 	idev = __in6_dev_get(dev);
+ 	if (!idev)
+ 		return;
+ 
+ 	write_lock_bh(&idev->lock);
+ 
+ 	list_for_each_entry_safe(ifp, tmp, &idev->addr_list, if_list) {
+ 		if ((ifp->flags & IFA_F_PERMANENT) &&
+ 		    fixup_permanent_addr(idev, ifp) < 0) {
+ 			write_unlock_bh(&idev->lock);
+ 			ipv6_del_addr(ifp);
+ 			write_lock_bh(&idev->lock);
+ 
+ 			net_info_ratelimited("%s: Failed to add prefix route for address %pI6c; dropping\n",
+ 					     idev->dev->name, &ifp->addr);
+ 		}
+ 	}
+ 
+ 	write_unlock_bh(&idev->lock);
+ }
+ 
++>>>>>>> 38bd10c447f8 (net: ipv6: Delete host routes on an ifdown)
  static int addrconf_notify(struct notifier_block *this, unsigned long event,
  			   void *ptr)
  {
@@@ -3120,7 -3274,13 +3172,10 @@@
  		if (dev->flags & IFF_SLAVE)
  			break;
  
 -		if (idev && idev->cnf.disable_ipv6)
 -			break;
 -
  		if (event == NETDEV_UP) {
+ 			/* restore routes for permanent addresses */
+ 			addrconf_permanent_addr(dev);
+ 
  			if (!addrconf_qdisc_ok(dev)) {
  				/* device is not ready yet. */
  				pr_info("ADDRCONF(NETDEV_UP): %s: link is not ready\n",
@@@ -3330,20 -3523,43 +3385,57 @@@ static int addrconf_ifdown(struct net_d
  		write_lock_bh(&idev->lock);
  	}
  
++<<<<<<< HEAD
 +	while (!list_empty(&idev->addr_list)) {
 +		ifa = list_first_entry(&idev->addr_list,
 +				       struct inet6_ifaddr, if_list);
++=======
+ 	/* re-combine the user config with event to determine if permanent
+ 	 * addresses are to be removed from the interface list
+ 	 */
+ 	keep_addr = (!how && _keep_addr > 0);
+ 
+ 	INIT_LIST_HEAD(&del_list);
+ 	list_for_each_entry_safe(ifa, tmp, &idev->addr_list, if_list) {
+ 		struct rt6_info *rt = NULL;
+ 
++>>>>>>> 38bd10c447f8 (net: ipv6: Delete host routes on an ifdown)
  		addrconf_del_dad_work(ifa);
  
 +		list_del(&ifa->if_list);
 +
  		write_unlock_bh(&idev->lock);
 +
  		spin_lock_bh(&ifa->lock);
++<<<<<<< HEAD
 +		state = ifa->state;
 +		ifa->state = INET6_IFADDR_STATE_DEAD;
++=======
+ 
+ 		if (keep_addr && (ifa->flags & IFA_F_PERMANENT) &&
+ 		    !addr_is_local(&ifa->addr)) {
+ 			/* set state to skip the notifier below */
+ 			state = INET6_IFADDR_STATE_DEAD;
+ 			ifa->state = 0;
+ 			if (!(ifa->flags & IFA_F_NODAD))
+ 				ifa->flags |= IFA_F_TENTATIVE;
+ 
+ 			rt = ifa->rt;
+ 			ifa->rt = NULL;
+ 		} else {
+ 			state = ifa->state;
+ 			ifa->state = INET6_IFADDR_STATE_DEAD;
+ 
+ 			list_del(&ifa->if_list);
+ 			list_add(&ifa->if_list, &del_list);
+ 		}
+ 
++>>>>>>> 38bd10c447f8 (net: ipv6: Delete host routes on an ifdown)
  		spin_unlock_bh(&ifa->lock);
  
+ 		if (rt)
+ 			ip6_del_rt(rt);
+ 
  		if (state != INET6_IFADDR_STATE_DEAD) {
  			__ipv6_ifa_notify(RTM_DELADDR, ifa);
  			inet6addr_notifier_call_chain(NETDEV_DOWN, ifa);
* Unmerged path net/ipv6/addrconf.c
