ceph: properly get capsnap's size in get_oldest_context()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Yan, Zheng <zyan@redhat.com>
commit 1f934b00e907527cddb83984d0783cc4a029952a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1f934b00.failed

capsnap's size is set by __ceph_finish_cap_snap(). If capsnap is under
writing, its size is zero. In this case, get_oldest_context() should
read i_size. Besides, ceph_writepages_start() should re-check capsnap's
size after dirty pages get locked.

	Signed-off-by: "Yan, Zheng" <zyan@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 1f934b00e907527cddb83984d0783cc4a029952a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/addr.c
diff --cc fs/ceph/addr.c
index 2c8328a70fdb,03a1ee27b33c..000000000000
--- a/fs/ceph/addr.c
+++ b/fs/ceph/addr.c
@@@ -488,14 -555,11 +528,17 @@@ static int writepage_nounlock(struct pa
  	struct inode *inode;
  	struct ceph_inode_info *ci;
  	struct ceph_fs_client *fsc;
- 	struct ceph_osd_client *osdc;
  	struct ceph_snap_context *snapc, *oldest;
  	loff_t page_off = page_offset(page);
- 	loff_t snap_size = -1;
  	long writeback_stat;
++<<<<<<< HEAD
 +	u64 truncate_size;
 +	u32 truncate_seq;
 +	int err, len = PAGE_CACHE_SIZE;
++=======
+ 	int err, len = PAGE_SIZE;
+ 	struct ceph_writeback_ctl ceph_wbc;
++>>>>>>> 1f934b00e907 (ceph: properly get capsnap's size in get_oldest_context())
  
  	dout("writepage %p idx %lu\n", page, page->index);
  
@@@ -541,13 -600,13 +579,13 @@@
  	writeback_stat = atomic_long_inc_return(&fsc->writeback_count);
  	if (writeback_stat >
  	    CONGESTION_ON_THRESH(fsc->mount_options->congestion_kb))
 -		set_bdi_congested(inode_to_bdi(inode), BLK_RW_ASYNC);
 +		set_bdi_congested(&fsc->backing_dev_info, BLK_RW_ASYNC);
  
  	set_page_writeback(page);
- 	err = ceph_osdc_writepages(osdc, ceph_vino(inode),
- 				   &ci->i_layout, snapc,
- 				   page_off, len,
- 				   truncate_seq, truncate_size,
+ 	err = ceph_osdc_writepages(&fsc->client->osdc, ceph_vino(inode),
+ 				   &ci->i_layout, snapc, page_off, len,
+ 				   ceph_wbc.truncate_seq,
+ 				   ceph_wbc.truncate_size,
  				   &inode->i_mtime, &page, 1);
  	if (err < 0) {
  		struct writeback_control tmp_wbc;
@@@ -718,11 -775,9 +756,9 @@@ static int ceph_writepages_start(struc
  	struct pagevec pvec;
  	int done = 0;
  	int rc = 0;
 -	unsigned int wsize = i_blocksize(inode);
 +	unsigned wsize = 1 << inode->i_blkbits;
  	struct ceph_osd_request *req = NULL;
- 	loff_t snap_size, i_size;
- 	u64 truncate_size;
- 	u32 truncate_seq;
+ 	struct ceph_writeback_ctl ceph_wbc;
  
  	dout("writepages_start %p (mode=%s)\n", inode,
  	     wbc->sync_mode == WB_SYNC_NONE ? "NONE" :
@@@ -1018,17 -1067,18 +1048,23 @@@ new_request
  			}
  
  			set_page_writeback(pages[i]);
 -			len += PAGE_SIZE;
 +			len += PAGE_CACHE_SIZE;
  		}
  
- 		if (snap_size != -1) {
- 			len = min(len, snap_size - offset);
+ 		if (ceph_wbc.size_stable) {
+ 			len = min(len, ceph_wbc.i_size - offset);
  		} else if (i == locked_pages) {
  			/* writepages_finish() clears writeback pages
  			 * according to the data length, so make sure
  			 * data length covers all locked pages */
++<<<<<<< HEAD
 +			u64 min_len = len + 1 - PAGE_CACHE_SIZE;
 +			len = min(len, (u64)i_size_read(inode) - offset);
++=======
+ 			u64 min_len = len + 1 - PAGE_SIZE;
+ 			len = get_writepages_data_length(inode, pages[i - 1],
+ 							 offset);
++>>>>>>> 1f934b00e907 (ceph: properly get capsnap's size in get_oldest_context())
  			len = max(len, min_len);
  		}
  		dout("writepages got pages at %llu~%llu\n", offset, len);
* Unmerged path fs/ceph/addr.c
