dax: change bdev_dax_supported() to support boolean returns

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [dax] change bdev_dax_supported() to support boolean returns (Jeff Moyer) [1568240]
Rebuild_FUZZ: 95.58%
commit-author Dave Jiang <dave.jiang@intel.com>
commit 80660f20252d6f76c9f203874ad7c7a4a8508cf8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/80660f20.failed

The function return values are confusing with the way the function is
named. We expect a true or false return value but it actually returns
0/-errno.  This makes the code very confusing. Changing the return values
to return a bool where if DAX is supported then return true and no DAX
support returns false.

	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
	Signed-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 80660f20252d6f76c9f203874ad7c7a4a8508cf8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dax/super.c
#	fs/ext2/super.c
#	fs/ext4/super.c
#	fs/xfs/xfs_ioctl.c
#	fs/xfs/xfs_super.c
#	include/linux/dax.h
diff --cc drivers/dax/super.c
index 41efc362f7f7,1d7bd96511f0..000000000000
--- a/drivers/dax/super.c
+++ b/drivers/dax/super.c
@@@ -70,36 -80,36 +70,58 @@@ EXPORT_SYMBOL(bdev_dax_pgoff)
   * This is a library function for filesystems to check if the block device
   * can be mounted with dax option.
   *
-  * Return: negative errno if unsupported, 0 if supported.
+  * Return: true if supported, false if unsupported
   */
++<<<<<<< HEAD
 +int __bdev_dax_supported(struct super_block *sb, int blocksize)
++=======
+ bool __bdev_dax_supported(struct block_device *bdev, int blocksize)
++>>>>>>> 80660f20252d (dax: change bdev_dax_supported() to support boolean returns)
  {
 +	struct block_device *bdev = sb->s_bdev;
  	struct dax_device *dax_dev;
  	pgoff_t pgoff;
  	int err, id;
  	void *kaddr;
  	pfn_t pfn;
  	long len;
 -	char buf[BDEVNAME_SIZE];
  
  	if (blocksize != PAGE_SIZE) {
++<<<<<<< HEAD
 +		pr_err("VFS (%s): error: unsupported blocksize for dax\n",
 +				sb->s_id);
 +		return -EINVAL;
++=======
+ 		pr_debug("%s: error: unsupported blocksize for dax\n",
+ 				bdevname(bdev, buf));
+ 		return false;
++>>>>>>> 80660f20252d (dax: change bdev_dax_supported() to support boolean returns)
  	}
  
  	err = bdev_dax_pgoff(bdev, 0, PAGE_SIZE, &pgoff);
  	if (err) {
++<<<<<<< HEAD
 +		pr_err("VFS (%s): error: unaligned partition for dax\n",
 +				sb->s_id);
 +		return err;
++=======
+ 		pr_debug("%s: error: unaligned partition for dax\n",
+ 				bdevname(bdev, buf));
+ 		return false;
++>>>>>>> 80660f20252d (dax: change bdev_dax_supported() to support boolean returns)
  	}
  
  	dax_dev = dax_get_by_host(bdev->bd_disk->disk_name);
  	if (!dax_dev) {
++<<<<<<< HEAD
 +		pr_err("VFS (%s): error: device does not support dax\n",
 +				sb->s_id);
 +		return -EOPNOTSUPP;
++=======
+ 		pr_debug("%s: error: device does not support dax\n",
+ 				bdevname(bdev, buf));
+ 		return false;
++>>>>>>> 80660f20252d (dax: change bdev_dax_supported() to support boolean returns)
  	}
  
  	id = dax_read_lock();
@@@ -109,21 -119,30 +131,34 @@@
  	put_dax(dax_dev);
  
  	if (len < 1) {
++<<<<<<< HEAD
 +		pr_err("VFS (%s): error: dax access failed (%ld)\n",
 +				sb->s_id, len);
 +		return len < 0 ? len : -EIO;
++=======
+ 		pr_debug("%s: error: dax access failed (%ld)\n",
+ 				bdevname(bdev, buf), len);
+ 		return false;
++>>>>>>> 80660f20252d (dax: change bdev_dax_supported() to support boolean returns)
  	}
  
 -	if (IS_ENABLED(CONFIG_FS_DAX_LIMITED) && pfn_t_special(pfn)) {
 -		/*
 -		 * An arch that has enabled the pmem api should also
 -		 * have its drivers support pfn_t_devmap()
 -		 *
 -		 * This is a developer warning and should not trigger in
 -		 * production. dax_flush() will crash since it depends
 -		 * on being able to do (page_address(pfn_to_page())).
 -		 */
 -		WARN_ON(IS_ENABLED(CONFIG_ARCH_HAS_PMEM_API));
 -	} else if (pfn_t_devmap(pfn)) {
 +	if ((IS_ENABLED(CONFIG_FS_DAX_LIMITED) && pfn_t_special(pfn))
 +			|| pfn_t_devmap(pfn))
  		/* pass */;
++<<<<<<< HEAD
 +	else {
 +		pr_debug("VFS (%s): error: dax support not enabled\n",
 +				sb->s_id);
 +		return -EOPNOTSUPP;
++=======
+ 	} else {
+ 		pr_debug("%s: error: dax support not enabled\n",
+ 				bdevname(bdev, buf));
+ 		return false;
++>>>>>>> 80660f20252d (dax: change bdev_dax_supported() to support boolean returns)
  	}
  
- 	return 0;
+ 	return true;
  }
  EXPORT_SYMBOL_GPL(__bdev_dax_supported);
  #endif
diff --cc fs/ext2/super.c
index 241c03defc77,c09289a42dc5..000000000000
--- a/fs/ext2/super.c
+++ b/fs/ext2/super.c
@@@ -909,15 -961,10 +909,19 @@@ static int ext2_fill_super(struct super
  	blocksize = BLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);
  
  	if (sbi->s_mount_opt & EXT2_MOUNT_DAX) {
++<<<<<<< HEAD
 +		if (blocksize != PAGE_SIZE) {
++=======
+ 		if (!bdev_dax_supported(sb->s_bdev, blocksize)) {
++>>>>>>> 80660f20252d (dax: change bdev_dax_supported() to support boolean returns)
  			ext2_msg(sb, KERN_ERR,
 -				"DAX unsupported by block device. Turning off DAX.");
 -			sbi->s_mount_opt &= ~EXT2_MOUNT_DAX;
 +					"error: unsupported blocksize for dax");
 +			goto failed_mount;
 +		}
 +		if (!sb->s_bdev->bd_disk->fops->direct_access) {
 +			ext2_msg(sb, KERN_ERR,
 +					"error: device does not support dax");
 +			goto failed_mount;
  		}
  	}
  
diff --cc fs/ext4/super.c
index 0d44f68dead8,2e1622907f4a..000000000000
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@@ -3777,20 -3727,15 +3777,27 @@@ static int ext4_fill_super(struct super
  	}
  
  	if (sbi->s_mount_opt & EXT4_MOUNT_DAX) {
 -		if (ext4_has_feature_inline_data(sb)) {
 +		static bool printed = false;
 +
 +		if (EXT4_HAS_INCOMPAT_FEATURE(sb,
 +					EXT4_FEATURE_INCOMPAT_INLINE_DATA)) {
  			ext4_msg(sb, KERN_ERR, "Cannot use DAX on a filesystem"
  					" that may contain inline data");
 -			sbi->s_mount_opt &= ~EXT4_MOUNT_DAX;
 +			goto failed_mount;
  		}
++<<<<<<< HEAD
 +		err = bdev_dax_supported(sb, blocksize);
 +		if (err)
 +			goto failed_mount;
 +		if (!printed) {
 +			mark_tech_preview("ext4 direct access (dax)", NULL);
 +			printed = true;
++=======
+ 		if (!bdev_dax_supported(sb->s_bdev, blocksize)) {
+ 			ext4_msg(sb, KERN_ERR,
+ 				"DAX unsupported by block device. Turning off DAX.");
+ 			sbi->s_mount_opt &= ~EXT4_MOUNT_DAX;
++>>>>>>> 80660f20252d (dax: change bdev_dax_supported() to support boolean returns)
  		}
  	}
  
diff --cc fs/xfs/xfs_ioctl.c
index 16aae82f734b,5dd9e22b4a4c..000000000000
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@@ -1111,10 -1100,11 +1111,15 @@@ xfs_ioctl_setattr_dax_invalidate
  	 * directories on filesystems where the block size is equal to the page
  	 * size. On directories it serves as an inherit hint.
  	 */
 -	if (fa->fsx_xflags & FS_XFLAG_DAX) {
 +	if (fa->fsx_xflags & XFS_XFLAG_DAX) {
  		if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))
  			return -EINVAL;
++<<<<<<< HEAD
 +		if (bdev_dax_supported(sb, sb->s_blocksize) < 0)
++=======
+ 		if (!bdev_dax_supported(xfs_find_bdev_for_inode(VFS_I(ip)),
+ 				sb->s_blocksize))
++>>>>>>> 80660f20252d (dax: change bdev_dax_supported() to support boolean returns)
  			return -EINVAL;
  	}
  
diff --cc fs/xfs/xfs_super.c
index 4f6ef583f948,4e66e61865fb..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -1614,16 -1698,20 +1614,29 @@@ xfs_fs_fill_super
  
  	/* version 5 superblocks support inode version counters. */
  	if (XFS_SB_VERSION_NUM(&mp->m_sb) == XFS_SB_VERSION_5)
 -		sb->s_flags |= SB_I_VERSION;
 +		sb->s_flags |= MS_I_VERSION;
  
  	if (mp->m_flags & XFS_MOUNT_DAX) {
++<<<<<<< HEAD
 +		static bool printed = false;
++=======
+ 		bool rtdev_is_dax = false, datadev_is_dax;
++>>>>>>> 80660f20252d (dax: change bdev_dax_supported() to support boolean returns)
  
  		xfs_warn(mp,
  		"DAX enabled. Warning: EXPERIMENTAL, use at your own risk");
  
++<<<<<<< HEAD
 +		error = bdev_dax_supported(sb, sb->s_blocksize);
 +		if (error) {
++=======
+ 		datadev_is_dax = bdev_dax_supported(mp->m_ddev_targp->bt_bdev,
+ 			sb->s_blocksize);
+ 		if (mp->m_rtdev_targp)
+ 			rtdev_is_dax = bdev_dax_supported(
+ 				mp->m_rtdev_targp->bt_bdev, sb->s_blocksize);
+ 		if (!rtdev_is_dax && !datadev_is_dax) {
++>>>>>>> 80660f20252d (dax: change bdev_dax_supported() to support boolean returns)
  			xfs_alert(mp,
  			"DAX unsupported by block device. Turning off DAX.");
  			mp->m_flags &= ~XFS_MOUNT_DAX;
diff --cc include/linux/dax.h
index b7b81d6cc271,c99692ddd4b5..000000000000
--- a/include/linux/dax.h
+++ b/include/linux/dax.h
@@@ -74,6 -49,66 +74,69 @@@ static inline struct dax_device *dax_ge
  static inline void put_dax(struct dax_device *dax_dev)
  {
  }
++<<<<<<< HEAD
++=======
+ static inline void kill_dax(struct dax_device *dax_dev)
+ {
+ }
+ static inline void dax_write_cache(struct dax_device *dax_dev, bool wc)
+ {
+ }
+ static inline bool dax_write_cache_enabled(struct dax_device *dax_dev)
+ {
+ 	return false;
+ }
+ #endif
+ 
+ struct writeback_control;
+ int bdev_dax_pgoff(struct block_device *, sector_t, size_t, pgoff_t *pgoff);
+ #if IS_ENABLED(CONFIG_FS_DAX)
+ bool __bdev_dax_supported(struct block_device *bdev, int blocksize);
+ static inline bool bdev_dax_supported(struct block_device *bdev, int blocksize)
+ {
+ 	return __bdev_dax_supported(bdev, blocksize);
+ }
+ 
+ static inline struct dax_device *fs_dax_get_by_host(const char *host)
+ {
+ 	return dax_get_by_host(host);
+ }
+ 
+ static inline void fs_put_dax(struct dax_device *dax_dev)
+ {
+ 	put_dax(dax_dev);
+ }
+ 
+ struct dax_device *fs_dax_get_by_bdev(struct block_device *bdev);
+ int dax_writeback_mapping_range(struct address_space *mapping,
+ 		struct block_device *bdev, struct writeback_control *wbc);
+ #else
+ static inline bool bdev_dax_supported(struct block_device *bdev,
+ 		int blocksize)
+ {
+ 	return false;
+ }
+ 
+ static inline struct dax_device *fs_dax_get_by_host(const char *host)
+ {
+ 	return NULL;
+ }
+ 
+ static inline void fs_put_dax(struct dax_device *dax_dev)
+ {
+ }
+ 
+ static inline struct dax_device *fs_dax_get_by_bdev(struct block_device *bdev)
+ {
+ 	return NULL;
+ }
+ 
+ static inline int dax_writeback_mapping_range(struct address_space *mapping,
+ 		struct block_device *bdev, struct writeback_control *wbc)
+ {
+ 	return -EOPNOTSUPP;
+ }
++>>>>>>> 80660f20252d (dax: change bdev_dax_supported() to support boolean returns)
  #endif
  
  int dax_read_lock(void);
* Unmerged path drivers/dax/super.c
* Unmerged path fs/ext2/super.c
* Unmerged path fs/ext4/super.c
* Unmerged path fs/xfs/xfs_ioctl.c
* Unmerged path fs/xfs/xfs_super.c
* Unmerged path include/linux/dax.h
