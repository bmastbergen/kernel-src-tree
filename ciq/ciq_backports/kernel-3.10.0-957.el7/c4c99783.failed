netfilter: ipset: Fix parallel resizing and listing of the same set

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit c4c997839cf92cb1037e43a85cdb4cbf44ed39a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c4c99783.failed

When elements added to a hash:* type of set and resizing triggered,
parallel listing could start to list the original set (before resizing)
and "continue" with listing the new set. Fix it by references and
using the original hash table for listing. Therefore the destroying of
the original hash table may happen from the resizing or listing functions.

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit c4c997839cf92cb1037e43a85cdb4cbf44ed39a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/ipset/ip_set.h
#	net/netfilter/ipset/ip_set_core.c
#	net/netfilter/ipset/ip_set_hash_gen.h
diff --cc include/linux/netfilter/ipset/ip_set.h
index 3e9c90cf5227,5674b6ac6646..000000000000
--- a/include/linux/netfilter/ipset/ip_set.h
+++ b/include/linux/netfilter/ipset/ip_set.h
@@@ -256,6 -381,16 +259,19 @@@ ip_set_init_counter(struct ip_set_count
  		atomic64_set(&(counter)->packets, (long long)(ext->packets));
  }
  
++<<<<<<< HEAD
++=======
+ /* Netlink CB args */
+ enum {
+ 	IPSET_CB_NET = 0,	/* net namespace */
+ 	IPSET_CB_DUMP,		/* dump single set/all sets */
+ 	IPSET_CB_INDEX,		/* set index */
+ 	IPSET_CB_PRIVATE,	/* set private data */
+ 	IPSET_CB_ARG0,		/* type specific */
+ 	IPSET_CB_ARG1,
+ };
+ 
++>>>>>>> c4c997839cf9 (netfilter: ipset: Fix parallel resizing and listing of the same set)
  /* register and unregister set references */
  extern ip_set_id_t ip_set_get_byname(struct net *net,
  				     const char *name, struct ip_set **set);
diff --cc net/netfilter/ipset/ip_set_core.c
index 1b9673fde81c,777cac6fd64d..000000000000
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@@ -1121,10 -1211,16 +1121,23 @@@ ip_set_swap(struct sock *ctnl, struct s
  static int
  ip_set_dump_done(struct netlink_callback *cb)
  {
++<<<<<<< HEAD
 +	struct ip_set_net *inst = (struct ip_set_net *)cb->data;
 +	if (cb->args[2]) {
 +		pr_debug("release set %s\n", ip_set(inst, cb->args[1])->name);
 +		__ip_set_put_netlink(ip_set(inst, (ip_set_id_t)cb->args[1]));
++=======
+ 	if (cb->args[IPSET_CB_ARG0]) {
+ 		struct ip_set_net *inst =
+ 			(struct ip_set_net *)cb->args[IPSET_CB_NET];
+ 		ip_set_id_t index = (ip_set_id_t)cb->args[IPSET_CB_INDEX];
+ 		struct ip_set *set = ip_set(inst, index);
+ 
+ 		if (set->variant->uref)
+ 			set->variant->uref(set, cb, false);
+ 		pr_debug("release set %s\n", set->name);
+ 		__ip_set_put_byindex(inst, index);
++>>>>>>> c4c997839cf9 (netfilter: ipset: Fix parallel resizing and listing of the same set)
  	}
  	return 0;
  }
@@@ -1156,11 -1251,6 +1169,14 @@@ dump_init(struct netlink_callback *cb
  	nla_parse(cda, IPSET_ATTR_CMD_MAX,
  		  attr, nlh->nlmsg_len - min_len, ip_set_setname_policy);
  
++<<<<<<< HEAD
 +	/* cb->args[0] : dump single set/all sets
 +	 *         [1] : set index
 +	 *         [..]: type specific
 +	 */
 +
++=======
++>>>>>>> c4c997839cf9 (netfilter: ipset: Fix parallel resizing and listing of the same set)
  	if (cda[IPSET_ATTR_SETNAME]) {
  		struct ip_set *set;
  
@@@ -1291,8 -1373,10 +1309,15 @@@ dump_last
  	/* If we dump all sets, continue with dumping last ones */
  	if (dump_type == DUMP_ALL) {
  		dump_type = DUMP_LAST;
++<<<<<<< HEAD
 +		cb->args[0] = dump_type | (dump_flags << 16);
 +		cb->args[1] = 0;
++=======
+ 		cb->args[IPSET_CB_DUMP] = dump_type | (dump_flags << 16);
+ 		cb->args[IPSET_CB_INDEX] = 0;
+ 		if (set && set->variant->uref)
+ 			set->variant->uref(set, cb, false);
++>>>>>>> c4c997839cf9 (netfilter: ipset: Fix parallel resizing and listing of the same set)
  		goto dump_last;
  	}
  	goto out;
@@@ -1301,15 -1385,18 +1326,25 @@@ nla_put_failure
  	ret = -EFAULT;
  next_set:
  	if (dump_type == DUMP_ONE)
 -		cb->args[IPSET_CB_INDEX] = IPSET_INVALID_ID;
 +		cb->args[1] = IPSET_INVALID_ID;
  	else
 -		cb->args[IPSET_CB_INDEX]++;
 +		cb->args[1]++;
  release_refcount:
  	/* If there was an error or set is done, release set */
++<<<<<<< HEAD
 +	if (ret || !cb->args[2]) {
 +		pr_debug("release set %s\n", ip_set(inst, index)->name);
 +		__ip_set_put_netlink(ip_set(inst, index));
 +		cb->args[2] = 0;
++=======
+ 	if (ret || !cb->args[IPSET_CB_ARG0]) {
+ 		set = ip_set(inst, index);
+ 		if (set->variant->uref)
+ 			set->variant->uref(set, cb, false);
+ 		pr_debug("release set %s\n", set->name);
+ 		__ip_set_put_byindex(inst, index);
+ 		cb->args[IPSET_CB_ARG0] = 0;
++>>>>>>> c4c997839cf9 (netfilter: ipset: Fix parallel resizing and listing of the same set)
  	}
  out:
  	if (nlh) {
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 9ce28af662bf,5fcf70b0ebc2..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -557,8 -616,10 +564,10 @@@ retry
  #ifdef IP_SET_HASH_WITH_NETS
  				mtype_data_reset_flags(data, &flags);
  #endif
+ 				atomic_set(&orig->ref, 0);
+ 				atomic_dec(&orig->uref);
  				read_unlock_bh(&set->lock);
 -				mtype_ahash_destroy(set, t, false);
 +				ahash_destroy(t);
  				if (ret == -EAGAIN)
  					goto retry;
  				return ret;
@@@ -579,7 -640,11 +588,15 @@@
  
  	pr_debug("set %s resized from %u (%p) to %u (%p)\n", set->name,
  		 orig->htable_bits, orig, t->htable_bits, t);
++<<<<<<< HEAD
 +	ahash_destroy(orig);
++=======
+ 	/* If there's nobody else dumping the table, destroy it */
+ 	if (atomic_dec_and_test(&orig->uref)) {
+ 		pr_debug("Table destroy by resize %p\n", orig);
+ 		mtype_ahash_destroy(set, orig, false);
+ 	}
++>>>>>>> c4c997839cf9 (netfilter: ipset: Fix parallel resizing and listing of the same set)
  
  	return 0;
  }
@@@ -853,8 -1003,7 +894,12 @@@ static in
  mtype_list(const struct ip_set *set,
  	   struct sk_buff *skb, struct netlink_callback *cb)
  {
++<<<<<<< HEAD
 +	const struct htype *h = set->data;
 +	const struct htable *t = h->table;
++=======
+ 	const struct htable *t;
++>>>>>>> c4c997839cf9 (netfilter: ipset: Fix parallel resizing and listing of the same set)
  	struct nlattr *atd, *nested;
  	const struct hbucket *n;
  	const struct mtype_elem *e;
@@@ -867,20 -1016,23 +912,26 @@@
  	if (!atd)
  		return -EMSGSIZE;
  	pr_debug("list hash set %s\n", set->name);
++<<<<<<< HEAD
 +	for (; cb->args[2] < jhash_size(t->htable_bits); cb->args[2]++) {
++=======
+ 	t = (const struct htable *)cb->args[IPSET_CB_PRIVATE];
+ 	for (; cb->args[IPSET_CB_ARG0] < jhash_size(t->htable_bits);
+ 	     cb->args[IPSET_CB_ARG0]++) {
++>>>>>>> c4c997839cf9 (netfilter: ipset: Fix parallel resizing and listing of the same set)
  		incomplete = skb_tail_pointer(skb);
 -		n = hbucket(t, cb->args[IPSET_CB_ARG0]);
 -		pr_debug("cb->arg bucket: %lu, t %p n %p\n",
 -			 cb->args[IPSET_CB_ARG0], t, n);
 +		n = hbucket(t, cb->args[2]);
 +		pr_debug("cb->args[2]: %lu, t %p n %p\n", cb->args[2], t, n);
  		for (i = 0; i < n->pos; i++) {
 -			e = ahash_data(n, i, set->dsize);
 +			e = ahash_data(n, i, h->dsize);
  			if (SET_WITH_TIMEOUT(set) &&
 -			    ip_set_timeout_expired(ext_timeout(e, set)))
 +			    ip_set_timeout_expired(ext_timeout(e, h)))
  				continue;
  			pr_debug("list hash %lu hbucket %p i %u, data %p\n",
 -				 cb->args[IPSET_CB_ARG0], n, i, e);
 +				 cb->args[2], n, i, e);
  			nested = ipset_nest_start(skb, IPSET_ATTR_DATA);
  			if (!nested) {
 -				if (cb->args[IPSET_CB_ARG0] == first) {
 +				if (cb->args[2] == first) {
  					nla_nest_cancel(skb, atd);
  					return -EMSGSIZE;
  				} else
* Unmerged path include/linux/netfilter/ipset/ip_set.h
* Unmerged path net/netfilter/ipset/ip_set_core.c
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
