atomic_open(): fix the handling of create_error

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 10c64cea04d3c75c306b3f990586ffb343b63287
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/10c64cea.failed

* if we have a hashed negative dentry and either CREAT|EXCL on
r/o filesystem, or CREAT|TRUNC on r/o filesystem, or CREAT|EXCL
with failing may_o_create(), we should fail with EROFS or the
error may_o_create() has returned, but not ENOENT.  Which is what
the current code ends up returning.

* if we have CREAT|TRUNC hitting a regular file on a read-only
filesystem, we can't fail with EROFS here.  At the very least,
not until we'd done follow_managed() - we might have a writable
file (or a device, for that matter) bound on top of that one.
Moreover, the code downstream will see that O_TRUNC and attempt
to grab the write access (*after* following possible mount), so
if we really should fail with EROFS, it will happen.  No need
to do that inside atomic_open().

The real logics is much simpler than what the current code is
trying to do - if we decided to go for simple lookup, ended
up with a negative dentry *and* had create_error set, fail with
create_error.  No matter whether we'd got that negative dentry
from lookup_real() or had found it in dcache.

	Cc: stable@vger.kernel.org # v3.6+
	Acked-by: Miklos Szeredi <mszeredi@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 10c64cea04d3c75c306b3f990586ffb343b63287)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namei.c
diff --cc fs/namei.c
index 8c7468b2431b,b4589922c0de..000000000000
--- a/fs/namei.c
+++ b/fs/namei.c
@@@ -2916,22 -2942,10 +2916,29 @@@ no_open
  		dentry = lookup_real(dir, dentry, nd->flags);
  		if (IS_ERR(dentry))
  			return PTR_ERR(dentry);
++<<<<<<< HEAD
 +
 +		if (create_error) {
 +			int open_flag = op->open_flag;
 +
 +			error = create_error;
 +			if ((open_flag & O_EXCL)) {
 +				if (!dentry->d_inode)
 +					goto out;
 +			} else if (!dentry->d_inode) {
 +				goto out;
 +			} else if ((open_flag & O_TRUNC) &&
 +				   S_ISREG(dentry->d_inode->i_mode)) {
 +				goto out;
 +			}
 +			/* will fail later, go on to get the right error */
 +		}
++=======
+ 	}
+ 	if (create_error && !dentry->d_inode) {
+ 		error = create_error;
+ 		goto out;
++>>>>>>> 10c64cea04d3 (atomic_open(): fix the handling of create_error)
  	}
  looked_up:
  	path->dentry = dentry;
* Unmerged path fs/namei.c
