net/mlx5e: Support configurable MTU for vport representors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Support configurable MTU for vport representors (Erez Alfasi) [1625195]
Rebuild_FUZZ: 96.43%
commit-author Adi Nissim <adin@mellanox.com>
commit 250a42b6a764a7954a7a7a137bc71883f05657cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/250a42b6.failed

The representor MTU was hard coded to 1500 bytes.
Allow setting arbitrary MTU values up to the max supported by the FW.

	Signed-off-by: Adi Nissim <adin@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 250a42b6a764a7954a7a7a137bc71883f05657cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index a42a2f9547cb,ab7b2a4e6edc..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -3199,7 -3476,27 +3199,31 @@@ static int mlx5e_set_features(struct ne
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int mlx5e_change_mtu(struct net_device *netdev, int new_mtu)
++=======
+ static netdev_features_t mlx5e_fix_features(struct net_device *netdev,
+ 					    netdev_features_t features)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	mutex_lock(&priv->state_lock);
+ 	if (!bitmap_empty(priv->fs.vlan.active_svlans, VLAN_N_VID)) {
+ 		/* HW strips the outer C-tag header, this is a problem
+ 		 * for S-tag traffic.
+ 		 */
+ 		features &= ~NETIF_F_HW_VLAN_CTAG_RX;
+ 		if (!priv->channels.params.vlan_strip_disable)
+ 			netdev_warn(netdev, "Dropping C-tag vlan stripping offload due to S-tag vlan\n");
+ 	}
+ 	mutex_unlock(&priv->state_lock);
+ 
+ 	return features;
+ }
+ 
+ int mlx5e_change_mtu(struct net_device *netdev, int new_mtu,
+ 		     change_hw_mtu_cb set_mtu_cb)
++>>>>>>> 250a42b6a764 (net/mlx5e: Support configurable MTU for vport representors)
  {
  	struct mlx5e_priv *priv = netdev_priv(netdev);
  	struct mlx5e_channels new_channels = {};
@@@ -3209,28 -3506,34 +3233,39 @@@
  
  	mutex_lock(&priv->state_lock);
  
 -	params = &priv->channels.params;
 +	reset = !priv->channels.params.lro_en &&
 +		(priv->channels.params.rq_wq_type !=
 +		 MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ);
  
 -	reset = !params->lro_en;
  	reset = reset && test_bit(MLX5E_STATE_OPENED, &priv->state);
  
 -	new_channels.params = *params;
 -	new_channels.params.sw_mtu = new_mtu;
 -
 -	if (params->rq_wq_type != MLX5_WQ_TYPE_LINKED_LIST) {
 -		u8 ppw_old = mlx5e_mpwqe_log_pkts_per_wqe(params);
 -		u8 ppw_new = mlx5e_mpwqe_log_pkts_per_wqe(&new_channels.params);
 -
 -		reset = reset && (ppw_old != ppw_new);
 -	}
 +	curr_mtu    = netdev->mtu;
 +	netdev->mtu = new_mtu;
  
  	if (!reset) {
++<<<<<<< HEAD
 +		mlx5e_set_dev_port_mtu(priv);
++=======
+ 		params->sw_mtu = new_mtu;
+ 		set_mtu_cb(priv);
+ 		netdev->mtu = params->sw_mtu;
++>>>>>>> 250a42b6a764 (net/mlx5e: Support configurable MTU for vport representors)
  		goto out;
  	}
  
 +	new_channels.params = priv->channels.params;
  	err = mlx5e_open_channels(priv, &new_channels);
 -	if (err)
 +	if (err) {
 +		netdev->mtu = curr_mtu;
  		goto out;
 +	}
  
++<<<<<<< HEAD
 +	mlx5e_switch_priv_channels(priv, &new_channels, mlx5e_set_dev_port_mtu);
++=======
+ 	mlx5e_switch_priv_channels(priv, &new_channels, set_mtu_cb);
+ 	netdev->mtu = new_channels.params.sw_mtu;
++>>>>>>> 250a42b6a764 (net/mlx5e: Support configurable MTU for vport representors)
  
  out:
  	mutex_unlock(&priv->state_lock);
@@@ -3604,11 -4038,12 +3644,16 @@@ static const struct net_device_ops mlx5
  	.ndo_vlan_rx_add_vid     = mlx5e_vlan_rx_add_vid,
  	.ndo_vlan_rx_kill_vid    = mlx5e_vlan_rx_kill_vid,
  	.ndo_set_features        = mlx5e_set_features,
++<<<<<<< HEAD
 +	.extended.ndo_change_mtu     = mlx5e_change_mtu,
++=======
+ 	.ndo_fix_features        = mlx5e_fix_features,
+ 	.ndo_change_mtu          = mlx5e_change_nic_mtu,
++>>>>>>> 250a42b6a764 (net/mlx5e: Support configurable MTU for vport representors)
  	.ndo_do_ioctl            = mlx5e_ioctl,
 -	.ndo_set_tx_maxrate      = mlx5e_set_tx_maxrate,
 -	.ndo_udp_tunnel_add      = mlx5e_add_vxlan_port,
 -	.ndo_udp_tunnel_del      = mlx5e_del_vxlan_port,
 +	.extended.ndo_set_tx_maxrate      = mlx5e_set_tx_maxrate,
 +	.extended.ndo_udp_tunnel_add      = mlx5e_add_vxlan_port,
 +	.extended.ndo_udp_tunnel_del      = mlx5e_del_vxlan_port,
  	.ndo_features_check      = mlx5e_features_check,
  #ifdef CONFIG_RFS_ACCEL
  	.ndo_rx_flow_steer	 = mlx5e_rx_flow_steer,
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 21475fbee7ea,8ab4c96b7f7c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -874,16 -900,21 +874,27 @@@ static const struct switchdev_ops mlx5e
  	.switchdev_port_attr_get	= mlx5e_attr_get,
  };
  
+ int mlx5e_change_rep_mtu(struct net_device *netdev, int new_mtu)
+ {
+ 	return mlx5e_change_mtu(netdev, new_mtu, NULL);
+ }
+ 
  static const struct net_device_ops mlx5e_netdev_ops_rep = {
 +	.ndo_size                = sizeof(struct net_device_ops),
  	.ndo_open                = mlx5e_rep_open,
  	.ndo_stop                = mlx5e_rep_close,
  	.ndo_start_xmit          = mlx5e_xmit,
 -	.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
 -	.ndo_setup_tc            = mlx5e_rep_setup_tc,
 +	.extended.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
 +	.extended.ndo_setup_tc_rh = mlx5e_rep_setup_tc,
  	.ndo_get_stats64         = mlx5e_rep_get_stats,
++<<<<<<< HEAD
 +	.extended.ndo_has_offload_stats	 = mlx5e_has_offload_stats,
 +	.extended.ndo_get_offload_stats	 = mlx5e_get_offload_stats,
++=======
+ 	.ndo_has_offload_stats	 = mlx5e_has_offload_stats,
+ 	.ndo_get_offload_stats	 = mlx5e_get_offload_stats,
+ 	.ndo_change_mtu          = mlx5e_change_rep_mtu,
++>>>>>>> 250a42b6a764 (net/mlx5e: Support configurable MTU for vport representors)
  };
  
  static void mlx5e_build_rep_params(struct mlx5_core_dev *mdev,
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index 9dc25f7ba1d2..3852ee5d268e 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -1004,6 +1004,10 @@ u32 mlx5e_choose_lro_timeout(struct mlx5_core_dev *mdev, u32 wanted_timeout);
 
 int mlx5e_bits_invert(unsigned long a, int size);
 
+typedef int (*change_hw_mtu_cb)(struct mlx5e_priv *priv);
+int mlx5e_change_mtu(struct net_device *netdev, int new_mtu,
+		     change_hw_mtu_cb set_mtu_cb);
+
 /* ethtool helpers */
 void mlx5e_ethtool_get_drvinfo(struct mlx5e_priv *priv,
 			       struct ethtool_drvinfo *drvinfo);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
