mmc: core: move some code in mmc_start_areq()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] core: move some code in mmc_start_areq() (Gopal Tiwari) [1549495]
Rebuild_FUZZ: 94.12%
commit-author Linus Walleij <linus.walleij@linaro.org>
commit 5744d50d2d9e7efdae4b5d13cd71f49256ada6ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5744d50d.failed

"previous" is a better name for the variable storing the previous
asynchronous request, better than the opaque name "data" atleast.
We see that we assign the return status to the returned variable
on all code paths, so we might as well just do that immediately
after calling mmc_finalize_areq().

	Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 5744d50d2d9e7efdae4b5d13cd71f49256ada6ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/core.c
diff --cc drivers/mmc/core/core.c
index 6fb0618a3362,4c3e23f310f8..000000000000
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@@ -665,49 -698,28 +665,60 @@@ static void mmc_post_req(struct mmc_hos
   *	return the completed request. If there is no ongoing request, NULL
   *	is returned without waiting. NULL is not an error condition.
   */
 -struct mmc_async_req *mmc_start_areq(struct mmc_host *host,
 -				     struct mmc_async_req *areq,
 -				     enum mmc_blk_status *ret_stat)
 +struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 +				    struct mmc_async_req *areq,
 +				    enum mmc_blk_status *ret_stat)
  {
 -	enum mmc_blk_status status;
 +	enum mmc_blk_status status = MMC_BLK_SUCCESS;
  	int start_err = 0;
- 	struct mmc_async_req *data = host->areq;
+ 	struct mmc_async_req *previous = host->areq;
  
  	/* Prepare a new request */
  	if (areq)
  		mmc_pre_req(host, areq->mrq);
  
++<<<<<<< HEAD
 +	if (host->areq) {
 +		status = mmc_wait_for_data_req_done(host, host->areq->mrq);
 +		if (status == MMC_BLK_NEW_REQUEST) {
 +			if (ret_stat)
 +				*ret_stat = status;
 +			/*
 +			 * The previous request was not completed,
 +			 * nothing to return
 +			 */
 +			return NULL;
 +		}
 +		/*
 +		 * Check BKOPS urgency for each R1 response
 +		 */
 +		if (host->card && mmc_card_mmc(host->card) &&
 +		    ((mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1) ||
 +		     (mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1B)) &&
 +		    (host->areq->mrq->cmd->resp[0] & R1_EXCEPTION_EVENT)) {
 +
 +			/* Cancel the prepared request */
 +			if (areq)
 +				mmc_post_req(host, areq->mrq, -EINVAL);
 +
 +			mmc_start_bkops(host->card, true);
 +
 +			/* prepare the request again */
 +			if (areq)
 +				mmc_pre_req(host, areq->mrq);
 +		}
 +	}
++=======
+ 	/* Finalize previous request */
+ 	status = mmc_finalize_areq(host);
+ 	if (ret_stat)
+ 		*ret_stat = status;
+ 
+ 	/* The previous request is still going on... */
+ 	if (status == MMC_BLK_NEW_REQUEST)
+ 		return NULL;
++>>>>>>> 5744d50d2d9e (mmc: core: move some code in mmc_start_areq())
  
 -	/* Fine so far, start the new request! */
  	if (status == MMC_BLK_SUCCESS && areq)
  		start_err = __mmc_start_data_req(host, areq->mrq);
  
@@@ -723,11 -736,9 +734,9 @@@
  	else
  		host->areq = areq;
  
- 	if (ret_stat)
- 		*ret_stat = status;
- 	return data;
+ 	return previous;
  }
 -EXPORT_SYMBOL(mmc_start_areq);
 +EXPORT_SYMBOL(mmc_start_req);
  
  /**
   *	mmc_wait_for_req - start a request and wait for completion
* Unmerged path drivers/mmc/core/core.c
