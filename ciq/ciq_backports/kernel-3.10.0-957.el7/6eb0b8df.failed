xfs: rename MAXPATHLEN to XFS_SYMLINK_MAXLEN

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 6eb0b8df9f74f33d1a69100117630a7a87a9cc96
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6eb0b8df.failed

XFS has a maximum symlink target length of 1024 bytes; this is a
holdover from the Irix days.  Unfortunately, the constant establishing
this is 'MAXPATHLEN' and is /not/ the same as the Linux MAXPATHLEN,
which is 4096.

The kernel enforces its 1024 byte MAXPATHLEN on symlink targets, but
xfsprogs picks up the (Linux) system 4096 byte MAXPATHLEN, which means
that xfs_repair doesn't complain about oversized symlinks.

Since this is an on-disk format constraint, put the define in the XFS
namespace and move everything over to use the new name.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
(cherry picked from commit 6eb0b8df9f74f33d1a69100117630a7a87a9cc96)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_trans_resv.c
#	fs/xfs/xfs_iops.c
diff --cc fs/xfs/libxfs/xfs_trans_resv.c
index e5704a160ca6,6bd916bd35e2..000000000000
--- a/fs/xfs/libxfs/xfs_trans_resv.c
+++ b/fs/xfs/libxfs/xfs_trans_resv.c
@@@ -443,8 -483,8 +443,13 @@@ STATIC uin
  xfs_calc_symlink_reservation(
  	struct xfs_mount	*mp)
  {
++<<<<<<< HEAD
 +	return xfs_calc_icreate_reservation(mp) +
 +	       xfs_calc_buf_res(1, MAXPATHLEN);
++=======
+ 	return xfs_calc_create_reservation(mp) +
+ 	       xfs_calc_buf_res(1, XFS_SYMLINK_MAXLEN);
++>>>>>>> 6eb0b8df9f74 (xfs: rename MAXPATHLEN to XFS_SYMLINK_MAXLEN)
  }
  
  /*
diff --cc fs/xfs/xfs_iops.c
index 8c9150043298,469c9fa4c178..000000000000
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@@ -462,7 -457,10 +462,14 @@@ xfs_vn_follow_link
  	char			*link;
  	int			error = -ENOMEM;
  
++<<<<<<< HEAD
 +	link = kmalloc(MAXPATHLEN+1, GFP_KERNEL);
++=======
+ 	if (!dentry)
+ 		return ERR_PTR(-ECHILD);
+ 
+ 	link = kmalloc(XFS_SYMLINK_MAXLEN+1, GFP_KERNEL);
++>>>>>>> 6eb0b8df9f74 (xfs: rename MAXPATHLEN to XFS_SYMLINK_MAXLEN)
  	if (!link)
  		goto out_err;
  
diff --git a/fs/xfs/libxfs/xfs_format.h b/fs/xfs/libxfs/xfs_format.h
index 7adfccb0f769..924194dae437 100644
--- a/fs/xfs/libxfs/xfs_format.h
+++ b/fs/xfs/libxfs/xfs_format.h
@@ -1179,6 +1179,7 @@ struct xfs_dsymlink_hdr {
 
 #define XFS_SYMLINK_CRC_OFF	offsetof(struct xfs_dsymlink_hdr, sl_crc)
 
+#define XFS_SYMLINK_MAXLEN	1024
 /*
  * The maximum pathlen is 1024 bytes. Since the minimum file system
  * blocksize is 512 bytes, we can get a max of 3 extents back from
diff --git a/fs/xfs/libxfs/xfs_symlink_remote.c b/fs/xfs/libxfs/xfs_symlink_remote.c
index 2e2c6716b623..c484877129a0 100644
--- a/fs/xfs/libxfs/xfs_symlink_remote.c
+++ b/fs/xfs/libxfs/xfs_symlink_remote.c
@@ -114,7 +114,7 @@ xfs_symlink_verify(
 	if (bp->b_bn != be64_to_cpu(dsl->sl_blkno))
 		return false;
 	if (be32_to_cpu(dsl->sl_offset) +
-				be32_to_cpu(dsl->sl_bytes) >= MAXPATHLEN)
+				be32_to_cpu(dsl->sl_bytes) >= XFS_SYMLINK_MAXLEN)
 		return false;
 	if (dsl->sl_owner == 0)
 		return false;
* Unmerged path fs/xfs/libxfs/xfs_trans_resv.c
* Unmerged path fs/xfs/xfs_iops.c
diff --git a/fs/xfs/xfs_linux.h b/fs/xfs/xfs_linux.h
index 520fc1e28b55..dfec2f7e28a3 100644
--- a/fs/xfs/xfs_linux.h
+++ b/fs/xfs/xfs_linux.h
@@ -151,7 +151,6 @@ typedef uuid_be			uuid_t;
 #define __return_address __builtin_return_address(0)
 
 #define XFS_PROJID_DEFAULT	0
-#define MAXPATHLEN	1024
 
 #define MIN(a,b)	(min(a,b))
 #define MAX(a,b)	(max(a,b))
diff --git a/fs/xfs/xfs_symlink.c b/fs/xfs/xfs_symlink.c
index a0d9a7837984..54da9161aa15 100644
--- a/fs/xfs/xfs_symlink.c
+++ b/fs/xfs/xfs_symlink.c
@@ -141,7 +141,7 @@ xfs_readlink(
 	if (!pathlen)
 		goto out;
 
-	if (pathlen < 0 || pathlen > MAXPATHLEN) {
+	if (pathlen < 0 || pathlen > XFS_SYMLINK_MAXLEN) {
 		xfs_alert(mp, "%s: inode (%llu) bad symlink length (%lld)",
 			 __func__, (unsigned long long) ip->i_ino,
 			 (long long) pathlen);
@@ -205,7 +205,7 @@ xfs_symlink(
 	 * Check component lengths of the target path name.
 	 */
 	pathlen = strlen(target_path);
-	if (pathlen >= MAXPATHLEN)      /* total string too long */
+	if (pathlen >= XFS_SYMLINK_MAXLEN)      /* total string too long */
 		return -ENAMETOOLONG;
 
 	udqp = gdqp = NULL;
@@ -563,7 +563,7 @@ xfs_inactive_symlink(
 		return 0;
 	}
 
-	if (pathlen < 0 || pathlen > MAXPATHLEN) {
+	if (pathlen < 0 || pathlen > XFS_SYMLINK_MAXLEN) {
 		xfs_alert(mp, "%s: inode (0x%llx) bad symlink length (%d)",
 			 __func__, (unsigned long long)ip->i_ino, pathlen);
 		xfs_iunlock(ip, XFS_ILOCK_EXCL);
