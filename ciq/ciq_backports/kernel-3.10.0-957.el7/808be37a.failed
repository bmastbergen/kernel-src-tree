mlxsw: spectrum_acl: Adapt ACL configuration to new firmware versions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit 808be37ae323ed5585a3e6257ccb5b435bd1a4b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/808be37a.failed

The driver currently creates empty ACL groups, binds them to the
requested port and then fills them with actual ACLs that point to TCAM
regions.

However, empty ACL groups are considered invalid and upcoming firmware
versions are going to forbid their binding.

Work around this limitation by only performing the binding after the
first ACL was added to the group.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 808be37ae323ed5585a3e6257ccb5b435bd1a4b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_acl.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_acl.c
index e95d86616644,1c1601a43978..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl.c
@@@ -118,22 -133,187 +118,63 @@@ struct mlxsw_sp_fid *mlxsw_sp_acl_dummy
  	return mlxsw_sp->acl->dummy_fid;
  }
  
 -struct mlxsw_sp *mlxsw_sp_acl_block_mlxsw_sp(struct mlxsw_sp_acl_block *block)
 +static int mlxsw_sp_acl_ruleset_bind(struct mlxsw_sp *mlxsw_sp,
 +				     struct mlxsw_sp_acl_ruleset *ruleset,
 +				     struct net_device *dev, bool ingress)
  {
++<<<<<<< HEAD
++=======
+ 	return block->mlxsw_sp;
+ }
+ 
+ unsigned int mlxsw_sp_acl_block_rule_count(struct mlxsw_sp_acl_block *block)
+ {
+ 	return block ? block->rule_count : 0;
+ }
+ 
+ void mlxsw_sp_acl_block_disable_inc(struct mlxsw_sp_acl_block *block)
+ {
+ 	if (block)
+ 		block->disable_count++;
+ }
+ 
+ void mlxsw_sp_acl_block_disable_dec(struct mlxsw_sp_acl_block *block)
+ {
+ 	if (block)
+ 		block->disable_count--;
+ }
+ 
+ bool mlxsw_sp_acl_block_disabled(struct mlxsw_sp_acl_block *block)
+ {
+ 	return block->disable_count;
+ }
+ 
+ static bool
+ mlxsw_sp_acl_ruleset_is_singular(const struct mlxsw_sp_acl_ruleset *ruleset)
+ {
+ 	/* We hold a reference on ruleset ourselves */
+ 	return ruleset->ref_count == 2;
+ }
+ 
+ static int
+ mlxsw_sp_acl_ruleset_bind(struct mlxsw_sp *mlxsw_sp,
+ 			  struct mlxsw_sp_acl_block *block,
+ 			  struct mlxsw_sp_acl_block_binding *binding)
+ {
+ 	struct mlxsw_sp_acl_ruleset *ruleset = block->ruleset_zero;
++>>>>>>> 808be37ae323 (mlxsw: spectrum_acl: Adapt ACL configuration to new firmware versions)
  	const struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;
  
 -	return ops->ruleset_bind(mlxsw_sp, ruleset->priv,
 -				 binding->mlxsw_sp_port, binding->ingress);
 +	return ops->ruleset_bind(mlxsw_sp, ruleset->priv, dev, ingress);
  }
  
 -static void
 -mlxsw_sp_acl_ruleset_unbind(struct mlxsw_sp *mlxsw_sp,
 -			    struct mlxsw_sp_acl_block *block,
 -			    struct mlxsw_sp_acl_block_binding *binding)
 +static void mlxsw_sp_acl_ruleset_unbind(struct mlxsw_sp *mlxsw_sp,
 +					struct mlxsw_sp_acl_ruleset *ruleset,
 +					struct net_device *dev, bool ingress)
  {
 -	struct mlxsw_sp_acl_ruleset *ruleset = block->ruleset_zero;
  	const struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;
  
 -	ops->ruleset_unbind(mlxsw_sp, ruleset->priv,
 -			    binding->mlxsw_sp_port, binding->ingress);
 -}
 -
 -static bool mlxsw_sp_acl_ruleset_block_bound(struct mlxsw_sp_acl_block *block)
 -{
 -	return block->ruleset_zero;
 -}
 -
 -static int
 -mlxsw_sp_acl_ruleset_block_bind(struct mlxsw_sp *mlxsw_sp,
 -				struct mlxsw_sp_acl_ruleset *ruleset,
 -				struct mlxsw_sp_acl_block *block)
 -{
 -	struct mlxsw_sp_acl_block_binding *binding;
 -	int err;
 -
 -	block->ruleset_zero = ruleset;
 -	list_for_each_entry(binding, &block->binding_list, list) {
 -		err = mlxsw_sp_acl_ruleset_bind(mlxsw_sp, block, binding);
 -		if (err)
 -			goto rollback;
 -	}
 -	return 0;
 -
 -rollback:
 -	list_for_each_entry_continue_reverse(binding, &block->binding_list,
 -					     list)
 -		mlxsw_sp_acl_ruleset_unbind(mlxsw_sp, block, binding);
 -	block->ruleset_zero = NULL;
 -
 -	return err;
 -}
 -
 -static void
 -mlxsw_sp_acl_ruleset_block_unbind(struct mlxsw_sp *mlxsw_sp,
 -				  struct mlxsw_sp_acl_ruleset *ruleset,
 -				  struct mlxsw_sp_acl_block *block)
 -{
 -	struct mlxsw_sp_acl_block_binding *binding;
 -
 -	list_for_each_entry(binding, &block->binding_list, list)
 -		mlxsw_sp_acl_ruleset_unbind(mlxsw_sp, block, binding);
 -	block->ruleset_zero = NULL;
 -}
 -
 -struct mlxsw_sp_acl_block *mlxsw_sp_acl_block_create(struct mlxsw_sp *mlxsw_sp,
 -						     struct net *net)
 -{
 -	struct mlxsw_sp_acl_block *block;
 -
 -	block = kzalloc(sizeof(*block), GFP_KERNEL);
 -	if (!block)
 -		return NULL;
 -	INIT_LIST_HEAD(&block->binding_list);
 -	block->mlxsw_sp = mlxsw_sp;
 -	return block;
 -}
 -
 -void mlxsw_sp_acl_block_destroy(struct mlxsw_sp_acl_block *block)
 -{
 -	WARN_ON(!list_empty(&block->binding_list));
 -	kfree(block);
 -}
 -
 -static struct mlxsw_sp_acl_block_binding *
 -mlxsw_sp_acl_block_lookup(struct mlxsw_sp_acl_block *block,
 -			  struct mlxsw_sp_port *mlxsw_sp_port, bool ingress)
 -{
 -	struct mlxsw_sp_acl_block_binding *binding;
 -
 -	list_for_each_entry(binding, &block->binding_list, list)
 -		if (binding->mlxsw_sp_port == mlxsw_sp_port &&
 -		    binding->ingress == ingress)
 -			return binding;
 -	return NULL;
 -}
 -
 -int mlxsw_sp_acl_block_bind(struct mlxsw_sp *mlxsw_sp,
 -			    struct mlxsw_sp_acl_block *block,
 -			    struct mlxsw_sp_port *mlxsw_sp_port,
 -			    bool ingress)
 -{
 -	struct mlxsw_sp_acl_block_binding *binding;
 -	int err;
 -
 -	if (WARN_ON(mlxsw_sp_acl_block_lookup(block, mlxsw_sp_port, ingress)))
 -		return -EEXIST;
 -
 -	binding = kzalloc(sizeof(*binding), GFP_KERNEL);
 -	if (!binding)
 -		return -ENOMEM;
 -	binding->mlxsw_sp_port = mlxsw_sp_port;
 -	binding->ingress = ingress;
 -
 -	if (mlxsw_sp_acl_ruleset_block_bound(block)) {
 -		err = mlxsw_sp_acl_ruleset_bind(mlxsw_sp, block, binding);
 -		if (err)
 -			goto err_ruleset_bind;
 -	}
 -
 -	list_add(&binding->list, &block->binding_list);
 -	return 0;
 -
 -err_ruleset_bind:
 -	kfree(binding);
 -	return err;
 -}
 -
 -int mlxsw_sp_acl_block_unbind(struct mlxsw_sp *mlxsw_sp,
 -			      struct mlxsw_sp_acl_block *block,
 -			      struct mlxsw_sp_port *mlxsw_sp_port,
 -			      bool ingress)
 -{
 -	struct mlxsw_sp_acl_block_binding *binding;
 -
 -	binding = mlxsw_sp_acl_block_lookup(block, mlxsw_sp_port, ingress);
 -	if (!binding)
 -		return -ENOENT;
 -
 -	list_del(&binding->list);
 -
 -	if (mlxsw_sp_acl_ruleset_block_bound(block))
 -		mlxsw_sp_acl_ruleset_unbind(mlxsw_sp, block, binding);
 -
 -	kfree(binding);
 -	return 0;
 +	ops->ruleset_unbind(mlxsw_sp, ruleset->priv, dev, ingress);
  }
  
  static struct mlxsw_sp_acl_ruleset *
@@@ -169,22 -348,8 +210,22 @@@ mlxsw_sp_acl_ruleset_create(struct mlxs
  	if (err)
  		goto err_ht_insert;
  
++<<<<<<< HEAD
 +	if (!chain_index) {
 +		/* We only need ruleset with chain index 0, the implicit one,
 +		 * to be directly bound to device. The rest of the rulesets
 +		 * are bound by "Goto action set".
 +		 */
 +		err = mlxsw_sp_acl_ruleset_bind(mlxsw_sp, ruleset,
 +						dev, ingress);
 +		if (err)
 +			goto err_ruleset_bind;
 +	}
 +
++=======
++>>>>>>> 808be37ae323 (mlxsw: spectrum_acl: Adapt ACL configuration to new firmware versions)
  	return ruleset;
  
- err_ruleset_bind:
- 	rhashtable_remove_fast(&acl->ruleset_ht, &ruleset->ht_node,
- 			       mlxsw_sp_acl_ruleset_ht_params);
  err_ht_insert:
  	ops->ruleset_del(mlxsw_sp, ruleset->priv);
  err_ops_ruleset_add:
@@@ -200,10 -365,6 +241,13 @@@ static void mlxsw_sp_acl_ruleset_destro
  	const struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;
  	struct mlxsw_sp_acl *acl = mlxsw_sp->acl;
  
++<<<<<<< HEAD
 +	if (!ruleset->ht_key.chain_index)
 +		mlxsw_sp_acl_ruleset_unbind(mlxsw_sp, ruleset,
 +					    ruleset->ht_key.dev,
 +					    ruleset->ht_key.ingress);
++=======
++>>>>>>> 808be37ae323 (mlxsw: spectrum_acl: Adapt ACL configuration to new firmware versions)
  	rhashtable_remove_fast(&acl->ruleset_ht, &ruleset->ht_node,
  			       mlxsw_sp_acl_ruleset_ht_params);
  	ops->ruleset_del(mlxsw_sp, ruleset->priv);
@@@ -533,9 -678,25 +577,24 @@@ int mlxsw_sp_acl_rule_add(struct mlxsw_
  	if (err)
  		goto err_rhashtable_insert;
  
+ 	if (!ruleset->ht_key.chain_index &&
+ 	    mlxsw_sp_acl_ruleset_is_singular(ruleset)) {
+ 		/* We only need ruleset with chain index 0, the implicit
+ 		 * one, to be directly bound to device. The rest of the
+ 		 * rulesets are bound by "Goto action set".
+ 		 */
+ 		err = mlxsw_sp_acl_ruleset_block_bind(mlxsw_sp, ruleset,
+ 						      ruleset->ht_key.block);
+ 		if (err)
+ 			goto err_ruleset_block_bind;
+ 	}
+ 
  	list_add_tail(&rule->list, &mlxsw_sp->acl->rules);
 -	ruleset->ht_key.block->rule_count++;
  	return 0;
  
+ err_ruleset_block_bind:
+ 	rhashtable_remove_fast(&ruleset->rule_ht, &rule->ht_node,
+ 			       mlxsw_sp_acl_rule_ht_params);
  err_rhashtable_insert:
  	ops->rule_del(mlxsw_sp, rule->priv);
  	return err;
@@@ -547,7 -708,12 +606,11 @@@ void mlxsw_sp_acl_rule_del(struct mlxsw
  	struct mlxsw_sp_acl_ruleset *ruleset = rule->ruleset;
  	const struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;
  
 -	ruleset->ht_key.block->rule_count--;
  	list_del(&rule->list);
+ 	if (!ruleset->ht_key.chain_index &&
+ 	    mlxsw_sp_acl_ruleset_is_singular(ruleset))
+ 		mlxsw_sp_acl_ruleset_block_unbind(mlxsw_sp, ruleset,
+ 						  ruleset->ht_key.block);
  	rhashtable_remove_fast(&ruleset->rule_ht, &rule->ht_node,
  			       mlxsw_sp_acl_rule_ht_params);
  	ops->rule_del(mlxsw_sp, rule->priv);
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_acl.c
