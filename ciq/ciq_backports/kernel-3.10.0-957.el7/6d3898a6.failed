mmc: block: Add error-handling comments

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] block: Add error-handling comments (Gopal Tiwari) [1456570]
Rebuild_FUZZ: 93.15%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 6d3898a6a517d0effa1d1e337c03b16bafb6fc96
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6d3898a6.failed

Add error-handling comments to explain what would also be done for blk-mq
if it used the legacy error-handling.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Acked-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Tested-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 6d3898a6a517d0effa1d1e337c03b16bafb6fc96)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/block.c
diff --cc drivers/mmc/core/block.c
index bf17147e2808,7dcd5d5b203b..000000000000
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@@ -1732,21 -1935,49 +1736,55 @@@ static int mmc_blk_issue_rw_rq(struct m
  			}
  			break;
  		case MMC_BLK_CMD_ERR:
++<<<<<<< HEAD
 +			ret = mmc_blk_cmd_err(md, card, brq, req, ret);
 +			if (mmc_blk_reset(md, card->host, type))
 +				goto cmd_abort;
 +			if (!ret)
 +				goto start_new_req;
++=======
+ 			/*
+ 			 * For SD cards, get bytes written, but do not accept
+ 			 * bytes_xfered if that fails. For MMC cards accept
+ 			 * bytes_xfered. Then try to reset. If reset fails then
+ 			 * error out the remaining request, otherwise retry
+ 			 * once (N.B mmc_blk_reset() will not succeed twice in a
+ 			 * row).
+ 			 */
+ 			req_pending = mmc_blk_rw_cmd_err(md, card, brq, old_req, req_pending);
+ 			if (mmc_blk_reset(md, card->host, type)) {
+ 				if (req_pending)
+ 					mmc_blk_rw_cmd_abort(mq, card, old_req, mq_rq);
+ 				else
+ 					mq->qcnt--;
+ 				mmc_blk_rw_try_restart(mq, new_req, mqrq_cur);
+ 				return;
+ 			}
+ 			if (!req_pending) {
+ 				mq->qcnt--;
+ 				mmc_blk_rw_try_restart(mq, new_req, mqrq_cur);
+ 				return;
+ 			}
++>>>>>>> 6d3898a6a517 (mmc: block: Add error-handling comments)
  			break;
  		case MMC_BLK_RETRY:
+ 			/*
+ 			 * Do not accept bytes_xfered, but retry up to 5 times,
+ 			 * otherwise same as abort.
+ 			 */
  			retune_retry_done = brq->retune_retry_done;
  			if (retry++ < 5)
  				break;
  			/* Fall through */
  		case MMC_BLK_ABORT:
+ 			/*
+ 			 * Do not accept bytes_xfered, but try to reset. If
+ 			 * reset succeeds, try once more, otherwise error out
+ 			 * the request.
+ 			 */
  			if (!mmc_blk_reset(md, card->host, type))
  				break;
 -			mmc_blk_rw_cmd_abort(mq, card, old_req, mq_rq);
 -			mmc_blk_rw_try_restart(mq, new_req, mqrq_cur);
 -			return;
 +			goto cmd_abort;
  		case MMC_BLK_DATA_ERR: {
  			int err;
  
@@@ -1770,20 -2015,29 +1819,28 @@@
  			 * time, so we only reach here after trying to
  			 * read a single sector.
  			 */
 -			req_pending = blk_end_request(old_req, BLK_STS_IOERR,
 -						      brq->data.blksz);
 -			if (!req_pending) {
 -				mq->qcnt--;
 -				mmc_blk_rw_try_restart(mq, new_req, mqrq_cur);
 -				return;
 -			}
 +			ret = blk_end_request(req, -EIO,
 +						brq->data.blksz);
 +			if (!ret)
 +				goto start_new_req;
  			break;
  		case MMC_BLK_NOMEDIUM:
++<<<<<<< HEAD
 +			goto cmd_abort;
++=======
+ 			/* Do not accept bytes_xfered. Error out the request */
+ 			mmc_blk_rw_cmd_abort(mq, card, old_req, mq_rq);
+ 			mmc_blk_rw_try_restart(mq, new_req, mqrq_cur);
+ 			return;
++>>>>>>> 6d3898a6a517 (mmc: block: Add error-handling comments)
  		default:
+ 			/* Do not accept bytes_xfered. Error out the request */
  			pr_err("%s: Unhandled return value (%d)",
 -					old_req->rq_disk->disk_name, status);
 -			mmc_blk_rw_cmd_abort(mq, card, old_req, mq_rq);
 -			mmc_blk_rw_try_restart(mq, new_req, mqrq_cur);
 -			return;
 +					req->rq_disk->disk_name, status);
 +			goto cmd_abort;
  		}
  
 -		if (req_pending) {
 +		if (ret) {
  			/*
  			 * In case of a incomplete request
  			 * prepare it again and resend.
* Unmerged path drivers/mmc/core/block.c
