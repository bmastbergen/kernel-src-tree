gfs2: clear journal live bit in	gfs2_log_flush

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [fs] gfs2: clear journal live bit in gfs2_log_flush (Robert S Peterson) [1541698]
Rebuild_FUZZ: 96.77%
commit-author Benjamin Marzinski <bmarzins@redhat.com>
commit 400ac52e805bb6852e743817bc05a136e85042a9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/400ac52e.failed

When gfs2 was unmounting filesystems or changing them to read-only it
was clearing the SDF_JOURNAL_LIVE bit before the final log flush.  This
caused a race.  If an inode glock got demoted in the gap between
clearing the bit and the shutdown flush, it would be unable to reserve
log space to clear out the active items list in inode_go_sync, causing an
error in inode_go_inval because the glock was still dirty.

To solve this, the SDF_JOURNAL_LIVE bit is now cleared inside the
shutdown log flush.  This means that, because of the locking on the log
blocks, either inode_go_sync will be able to reserve space to clean the
glock before the shutdown flush, or the shutdown flush will clean the
glock itself, before inode_go_sync fails to reserve the space. Either
way, the glock will be clean before inode_go_inval.

	Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 400ac52e805bb6852e743817bc05a136e85042a9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/log.c
#	fs/gfs2/super.c
diff --cc fs/gfs2/log.c
index cc3f7d1693aa,0ff028c15199..000000000000
--- a/fs/gfs2/log.c
+++ b/fs/gfs2/log.c
@@@ -682,6 -716,11 +682,14 @@@ void gfs2_log_flush(struct gfs2_sbd *sd
  	}
  	trace_gfs2_log_flush(sdp, 1);
  
++<<<<<<< HEAD
++=======
+ 	if (type == SHUTDOWN_FLUSH)
+ 		clear_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags);
+ 
+ 	sdp->sd_log_flush_head = sdp->sd_log_head;
+ 	sdp->sd_log_flush_wrapped = 0;
++>>>>>>> 400ac52e805b (gfs2: clear journal live bit in	gfs2_log_flush)
  	tr = sdp->sd_log_tr;
  	if (tr) {
  		sdp->sd_log_tr = NULL;
diff --cc fs/gfs2/super.c
index 6d7fb5403e30,1e7da3886254..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -851,18 -851,12 +851,27 @@@ static int gfs2_make_fs_ro(struct gfs2_
  	gfs2_quota_sync(sdp->sd_vfs, 0);
  	gfs2_statfs_sync(sdp->sd_vfs, 0);
  
++<<<<<<< HEAD
 +	error = gfs2_glock_nq_init(sdp->sd_trans_gl, LM_ST_SHARED, GL_NOCACHE,
 +				   &t_gh);
 +	if (error && !test_bit(SDF_SHUTDOWN, &sdp->sd_flags))
 +		return error;
 +
 +	gfs2_meta_syncfs(sdp);
 +	gfs2_log_shutdown(sdp);
 +
 +	clear_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags);
 +
 +	if (gfs2_holder_initialized(&t_gh))
 +		gfs2_glock_dq_uninit(&t_gh);
++=======
+ 	gfs2_log_flush(sdp, NULL, SHUTDOWN_FLUSH);
+ 	wait_event(sdp->sd_reserving_log_wait, atomic_read(&sdp->sd_reserving_log) == 0);
+ 	gfs2_assert_warn(sdp, atomic_read(&sdp->sd_log_blks_free) == sdp->sd_jdesc->jd_blocks);
+ 
+ 	if (freeze_gh.gh_gl)
+ 		gfs2_glock_dq_uninit(&freeze_gh);
++>>>>>>> 400ac52e805b (gfs2: clear journal live bit in	gfs2_log_flush)
  
  	gfs2_quota_cleanup(sdp);
  
* Unmerged path fs/gfs2/log.c
* Unmerged path fs/gfs2/super.c
