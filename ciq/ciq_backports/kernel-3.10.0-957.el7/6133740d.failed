netfilter: nf_tables: reject hook configuration updates on existing chains

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 6133740d6e80d969ff7d41098a9db1091d0f9c94
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6133740d.failed

Currently, if you add a base chain whose name clashes with an existing
non-base chain, nf_tables doesn't complain about this. Similarly, if you
update the chain type, the hook number and priority.

With this patch, nf_tables bails out in case any of this unsupported
operations occur by returning EBUSY.

 # nft add table x
 # nft add chain x y
 # nft add chain x y { type nat hook input priority 0\; }
 <cmdline>:1:1-49: Error: Could not process rule: Device or resource busy
 add chain x y { type nat hook input priority 0; }
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 6133740d6e80d969ff7d41098a9db1091d0f9c94)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index 3611175e1d49,221d27f09623..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -1278,9 -1348,46 +1278,52 @@@ static int nf_tables_newchain(struct ne
  		if (nlh->nlmsg_flags & NLM_F_REPLACE)
  			return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +		if (nla[NFTA_CHAIN_HANDLE] && name &&
 +		    !IS_ERR(nf_tables_chain_lookup(table, nla[NFTA_CHAIN_NAME])))
 +			return -EEXIST;
++=======
+ 		if (nla[NFTA_CHAIN_HOOK]) {
+ 			struct nft_base_chain *basechain;
+ 			struct nft_chain_hook hook;
+ 			struct nf_hook_ops *ops;
+ 
+ 			if (!(chain->flags & NFT_BASE_CHAIN))
+ 				return -EBUSY;
+ 
+ 			err = nft_chain_parse_hook(net, nla, afi, &hook,
+ 						   create);
+ 			if (err < 0)
+ 				return err;
+ 
+ 			basechain = nft_base_chain(chain);
+ 			if (basechain->type != hook.type) {
+ 				nft_chain_release_hook(&hook);
+ 				return -EBUSY;
+ 			}
+ 
+ 			for (i = 0; i < afi->nops; i++) {
+ 				ops = &basechain->ops[i];
+ 				if (ops->hooknum != hook.num ||
+ 				    ops->priority != hook.priority ||
+ 				    ops->dev != hook.dev) {
+ 					nft_chain_release_hook(&hook);
+ 					return -EBUSY;
+ 				}
+ 			}
+ 			nft_chain_release_hook(&hook);
+ 		}
+ 
+ 		if (nla[NFTA_CHAIN_HANDLE] && name) {
+ 			struct nft_chain *chain2;
+ 
+ 			chain2 = nf_tables_chain_lookup(table,
+ 							nla[NFTA_CHAIN_NAME],
+ 							genmask);
+ 			if (IS_ERR(chain2))
+ 				return PTR_ERR(chain2);
+ 		}
++>>>>>>> 6133740d6e80 (netfilter: nf_tables: reject hook configuration updates on existing chains)
  
  		if (nla[NFTA_CHAIN_COUNTERS]) {
  			if (!(chain->flags & NFT_BASE_CHAIN))
* Unmerged path net/netfilter/nf_tables_api.c
