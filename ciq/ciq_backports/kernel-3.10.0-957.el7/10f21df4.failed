mmc: block: blk-mq: Add support for direct completion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] block: blk-mq: Add support for direct completion (Gopal Tiwari) [1456570]
Rebuild_FUZZ: 95.05%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 10f21df4a23540b5da8e88d1030ff8c37818e04f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/10f21df4.failed

For blk-mq, add support for completing requests directly in the ->done
callback. That means that error handling and urgent background operations
must be handled by recovery_work in that case.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Acked-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Tested-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 10f21df4a23540b5da8e88d1030ff8c37818e04f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/block.c
#	drivers/mmc/core/block.h
#	drivers/mmc/core/host.h
#	drivers/mmc/core/queue.c
#	drivers/mmc/core/queue.h
diff --cc drivers/mmc/core/block.c
index bf17147e2808,a710a6e95307..000000000000
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@@ -1613,21 -1719,786 +1613,389 @@@ static void mmc_blk_rw_rq_prep(struct m
  				break;
  			}
  		}
++<<<<<<< HEAD
  		brq->data.sg_len = i;
  	}
 -
 -	mqrq->areq.mrq = &brq->mrq;
 -
 -	if (do_rel_wr_p)
 -		*do_rel_wr_p = do_rel_wr;
 -
 -	if (do_data_tag_p)
 -		*do_data_tag_p = do_data_tag;
 -}
 -
 -#define MMC_CQE_RETRIES 2
 -
 -static void mmc_blk_cqe_complete_rq(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_request *mrq = &mqrq->brq.mrq;
 -	struct request_queue *q = req->q;
 -	struct mmc_host *host = mq->card->host;
 -	unsigned long flags;
 -	bool put_card;
 -	int err;
 -
 -	mmc_cqe_post_req(host, mrq);
 -
 -	if (mrq->cmd && mrq->cmd->error)
 -		err = mrq->cmd->error;
 -	else if (mrq->data && mrq->data->error)
 -		err = mrq->data->error;
 -	else
 -		err = 0;
 -
 -	if (err) {
 -		if (mqrq->retries++ < MMC_CQE_RETRIES)
 -			blk_mq_requeue_request(req, true);
++=======
++		if (mmc_blk_reset(md, card->host, type))
++			mqrq->retries = MMC_NO_RETRIES;
+ 		else
 -			blk_mq_end_request(req, BLK_STS_IOERR);
 -	} else if (mrq->data) {
 -		if (blk_update_request(req, BLK_STS_OK, mrq->data->bytes_xfered))
 -			blk_mq_requeue_request(req, true);
++			mqrq->retries = MMC_MAX_RETRIES - 1;
++		break;
++	case MMC_BLK_RETRY:
++		/*
++		 * Do not accept bytes_xfered, but retry up to 5 times,
++		 * otherwise same as abort.
++		 */
++		brq->data.bytes_xfered = 0;
++		if (mqrq->retries < MMC_MAX_RETRIES)
++			break;
++		/* Fall through */
++	case MMC_BLK_ABORT:
++		/*
++		 * Do not accept bytes_xfered, but try to reset. If
++		 * reset succeeds, try once more, otherwise error out
++		 * the request.
++		 */
++		brq->data.bytes_xfered = 0;
++		if (mmc_blk_reset(md, card->host, type))
++			mqrq->retries = MMC_NO_RETRIES;
+ 		else
 -			__blk_mq_end_request(req, BLK_STS_OK);
 -	} else {
 -		blk_mq_end_request(req, BLK_STS_OK);
 -	}
 -
 -	spin_lock_irqsave(q->queue_lock, flags);
 -
 -	mq->in_flight[mmc_issue_type(mq, req)] -= 1;
 -
 -	put_card = (mmc_tot_in_flight(mq) == 0);
 -
 -	mmc_cqe_check_busy(mq);
 -
 -	spin_unlock_irqrestore(q->queue_lock, flags);
 -
 -	if (!mq->cqe_busy)
 -		blk_mq_run_hw_queues(q, true);
 -
 -	if (put_card)
 -		mmc_put_card(mq->card, &mq->ctx);
 -}
 -
 -void mmc_blk_cqe_recovery(struct mmc_queue *mq)
 -{
 -	struct mmc_card *card = mq->card;
 -	struct mmc_host *host = card->host;
 -	int err;
 -
 -	pr_debug("%s: CQE recovery start\n", mmc_hostname(host));
 -
 -	err = mmc_cqe_recovery(host);
 -	if (err)
 -		mmc_blk_reset(mq->blkdata, host, MMC_BLK_CQE_RECOVERY);
 -	else
 -		mmc_blk_reset_success(mq->blkdata, MMC_BLK_CQE_RECOVERY);
 -
 -	pr_debug("%s: CQE recovery done\n", mmc_hostname(host));
 -}
 -
 -static void mmc_blk_cqe_req_done(struct mmc_request *mrq)
 -{
 -	struct mmc_queue_req *mqrq = container_of(mrq, struct mmc_queue_req,
 -						  brq.mrq);
 -	struct request *req = mmc_queue_req_to_req(mqrq);
 -	struct request_queue *q = req->q;
 -	struct mmc_queue *mq = q->queuedata;
 -
 -	/*
 -	 * Block layer timeouts race with completions which means the normal
 -	 * completion path cannot be used during recovery.
 -	 */
 -	if (mq->in_recovery)
 -		mmc_blk_cqe_complete_rq(mq, req);
 -	else
 -		blk_mq_complete_request(req);
 -}
 -
 -static int mmc_blk_cqe_start_req(struct mmc_host *host, struct mmc_request *mrq)
 -{
 -	mrq->done		= mmc_blk_cqe_req_done;
 -	mrq->recovery_notifier	= mmc_cqe_recovery_notifier;
 -
 -	return mmc_cqe_start_req(host, mrq);
 -}
 -
 -static struct mmc_request *mmc_blk_cqe_prep_dcmd(struct mmc_queue_req *mqrq,
 -						 struct request *req)
 -{
 -	struct mmc_blk_request *brq = &mqrq->brq;
 -
 -	memset(brq, 0, sizeof(*brq));
 -
 -	brq->mrq.cmd = &brq->cmd;
 -	brq->mrq.tag = req->tag;
 -
 -	return &brq->mrq;
 -}
 -
 -static int mmc_blk_cqe_issue_flush(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_request *mrq = mmc_blk_cqe_prep_dcmd(mqrq, req);
 -
 -	mrq->cmd->opcode = MMC_SWITCH;
 -	mrq->cmd->arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
 -			(EXT_CSD_FLUSH_CACHE << 16) |
 -			(1 << 8) |
 -			EXT_CSD_CMD_SET_NORMAL;
 -	mrq->cmd->flags = MMC_CMD_AC | MMC_RSP_R1B;
 -
 -	return mmc_blk_cqe_start_req(mq->card->host, mrq);
 -}
 -
 -static int mmc_blk_cqe_issue_rw_rq(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -
 -	mmc_blk_data_prep(mq, mqrq, 0, NULL, NULL);
 -
 -	return mmc_blk_cqe_start_req(mq->card->host, &mqrq->brq.mrq);
 -}
 -
 -static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 -			       struct mmc_card *card,
 -			       int disable_multi,
 -			       struct mmc_queue *mq)
 -{
 -	u32 readcmd, writecmd;
 -	struct mmc_blk_request *brq = &mqrq->brq;
 -	struct request *req = mmc_queue_req_to_req(mqrq);
 -	struct mmc_blk_data *md = mq->blkdata;
 -	bool do_rel_wr, do_data_tag;
 -
 -	mmc_blk_data_prep(mq, mqrq, disable_multi, &do_rel_wr, &do_data_tag);
 -
 -	brq->mrq.cmd = &brq->cmd;
 -
 -	brq->cmd.arg = blk_rq_pos(req);
 -	if (!mmc_card_blockaddr(card))
 -		brq->cmd.arg <<= 9;
 -	brq->cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
 -
 -	if (brq->data.blocks > 1 || do_rel_wr) {
 -		/* SPI multiblock writes terminate using a special
 -		 * token, not a STOP_TRANSMISSION request.
 -		 */
 -		if (!mmc_host_is_spi(card->host) ||
 -		    rq_data_dir(req) == READ)
 -			brq->mrq.stop = &brq->stop;
 -		readcmd = MMC_READ_MULTIPLE_BLOCK;
 -		writecmd = MMC_WRITE_MULTIPLE_BLOCK;
 -	} else {
 -		brq->mrq.stop = NULL;
 -		readcmd = MMC_READ_SINGLE_BLOCK;
 -		writecmd = MMC_WRITE_BLOCK;
 -	}
 -	brq->cmd.opcode = rq_data_dir(req) == READ ? readcmd : writecmd;
 -
 -	/*
 -	 * Pre-defined multi-block transfers are preferable to
 -	 * open ended-ones (and necessary for reliable writes).
 -	 * However, it is not sufficient to just send CMD23,
 -	 * and avoid the final CMD12, as on an error condition
 -	 * CMD12 (stop) needs to be sent anyway. This, coupled
 -	 * with Auto-CMD23 enhancements provided by some
 -	 * hosts, means that the complexity of dealing
 -	 * with this is best left to the host. If CMD23 is
 -	 * supported by card and host, we'll fill sbc in and let
 -	 * the host deal with handling it correctly. This means
 -	 * that for hosts that don't expose MMC_CAP_CMD23, no
 -	 * change of behavior will be observed.
 -	 *
 -	 * N.B: Some MMC cards experience perf degradation.
 -	 * We'll avoid using CMD23-bounded multiblock writes for
 -	 * these, while retaining features like reliable writes.
 -	 */
 -	if ((md->flags & MMC_BLK_CMD23) && mmc_op_multi(brq->cmd.opcode) &&
 -	    (do_rel_wr || !(card->quirks & MMC_QUIRK_BLK_NO_CMD23) ||
 -	     do_data_tag)) {
 -		brq->sbc.opcode = MMC_SET_BLOCK_COUNT;
 -		brq->sbc.arg = brq->data.blocks |
 -			(do_rel_wr ? (1 << 31) : 0) |
 -			(do_data_tag ? (1 << 29) : 0);
 -		brq->sbc.flags = MMC_RSP_R1 | MMC_CMD_AC;
 -		brq->mrq.sbc = &brq->sbc;
 -	}
 -
 -	mqrq->areq.err_check = mmc_blk_err_check;
 -}
 -
 -#define MMC_MAX_RETRIES		5
 -#define MMC_NO_RETRIES		(MMC_MAX_RETRIES + 1)
 -
 -#define MMC_READ_SINGLE_RETRIES	2
 -
 -/* Single sector read during recovery */
 -static void mmc_blk_read_single(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_request *mrq = &mqrq->brq.mrq;
 -	struct mmc_card *card = mq->card;
 -	struct mmc_host *host = card->host;
 -	blk_status_t error = BLK_STS_OK;
 -	int retries = 0;
 -
 -	do {
 -		u32 status;
 -		int err;
 -
 -		mmc_blk_rw_rq_prep(mqrq, card, 1, mq);
 -
 -		mmc_wait_for_req(host, mrq);
 -
 -		err = mmc_send_status(card, &status);
 -		if (err)
 -			goto error_exit;
 -
 -		if (!mmc_host_is_spi(host) &&
 -		    R1_CURRENT_STATE(status) != R1_STATE_TRAN) {
 -			u32 stop_status = 0;
 -			bool gen_err = false;
 -
 -			err = send_stop(card,
 -					DIV_ROUND_UP(mrq->data->timeout_ns,
 -						     1000000),
 -					req, &gen_err, &stop_status);
 -			if (err)
 -				goto error_exit;
 -		}
 -
 -		if (mrq->cmd->error && retries++ < MMC_READ_SINGLE_RETRIES)
 -			continue;
 -
 -		retries = 0;
 -
 -		if (mrq->cmd->error ||
 -		    mrq->data->error ||
 -		    (!mmc_host_is_spi(host) &&
 -		     (mrq->cmd->resp[0] & CMD_ERRORS || status & CMD_ERRORS)))
 -			error = BLK_STS_IOERR;
 -		else
 -			error = BLK_STS_OK;
 -
 -	} while (blk_update_request(req, error, 512));
 -
 -	return;
 -
 -error_exit:
 -	mrq->data->bytes_xfered = 0;
 -	blk_update_request(req, BLK_STS_IOERR, 512);
 -	/* Let it try the remaining request again */
 -	if (mqrq->retries > MMC_MAX_RETRIES - 1)
 -		mqrq->retries = MMC_MAX_RETRIES - 1;
 -}
 -
 -static void mmc_blk_mq_rw_recovery(struct mmc_queue *mq, struct request *req)
 -{
 -	int type = rq_data_dir(req) == READ ? MMC_BLK_READ : MMC_BLK_WRITE;
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_blk_request *brq = &mqrq->brq;
 -	struct mmc_blk_data *md = mq->blkdata;
 -	struct mmc_card *card = mq->card;
 -	static enum mmc_blk_status status;
 -
 -	brq->retune_retry_done = mqrq->retries;
 -
 -	status = __mmc_blk_err_check(card, mqrq);
 -
 -	mmc_retune_release(card->host);
 -
 -	/*
 -	 * Requests are completed by mmc_blk_mq_complete_rq() which sets simple
 -	 * policy:
 -	 * 1. A request that has transferred at least some data is considered
 -	 * successful and will be requeued if there is remaining data to
 -	 * transfer.
 -	 * 2. Otherwise the number of retries is incremented and the request
 -	 * will be requeued if there are remaining retries.
 -	 * 3. Otherwise the request will be errored out.
 -	 * That means mmc_blk_mq_complete_rq() is controlled by bytes_xfered and
 -	 * mqrq->retries. So there are only 4 possible actions here:
 -	 *	1. do not accept the bytes_xfered value i.e. set it to zero
 -	 *	2. change mqrq->retries to determine the number of retries
 -	 *	3. try to reset the card
 -	 *	4. read one sector at a time
 -	 */
 -	switch (status) {
 -	case MMC_BLK_SUCCESS:
 -	case MMC_BLK_PARTIAL:
 -		/* Reset success, and accept bytes_xfered */
 -		mmc_blk_reset_success(md, type);
 -		break;
 -	case MMC_BLK_CMD_ERR:
 -		/*
 -		 * For SD cards, get bytes written, but do not accept
 -		 * bytes_xfered if that fails. For MMC cards accept
 -		 * bytes_xfered. Then try to reset. If reset fails then
 -		 * error out the remaining request, otherwise retry
 -		 * once (N.B mmc_blk_reset() will not succeed twice in a
 -		 * row).
 -		 */
 -		if (mmc_card_sd(card)) {
 -			u32 blocks;
 -			int err;
 -
 -			err = mmc_sd_num_wr_blocks(card, &blocks);
 -			if (err)
 -				brq->data.bytes_xfered = 0;
 -			else
 -				brq->data.bytes_xfered = blocks << 9;
 -		}
 -		if (mmc_blk_reset(md, card->host, type))
 -			mqrq->retries = MMC_NO_RETRIES;
 -		else
 -			mqrq->retries = MMC_MAX_RETRIES - 1;
 -		break;
 -	case MMC_BLK_RETRY:
 -		/*
 -		 * Do not accept bytes_xfered, but retry up to 5 times,
 -		 * otherwise same as abort.
 -		 */
 -		brq->data.bytes_xfered = 0;
 -		if (mqrq->retries < MMC_MAX_RETRIES)
 -			break;
 -		/* Fall through */
 -	case MMC_BLK_ABORT:
 -		/*
 -		 * Do not accept bytes_xfered, but try to reset. If
 -		 * reset succeeds, try once more, otherwise error out
 -		 * the request.
 -		 */
 -		brq->data.bytes_xfered = 0;
 -		if (mmc_blk_reset(md, card->host, type))
 -			mqrq->retries = MMC_NO_RETRIES;
 -		else
 -			mqrq->retries = MMC_MAX_RETRIES - 1;
 -		break;
 -	case MMC_BLK_DATA_ERR: {
 -		int err;
++			mqrq->retries = MMC_MAX_RETRIES - 1;
++		break;
++	case MMC_BLK_DATA_ERR: {
++		int err;
+ 
+ 		/*
+ 		 * Do not accept bytes_xfered, but try to reset. If
+ 		 * reset succeeds, try once more. If reset fails with
+ 		 * ENODEV which means the partition is wrong, then error
+ 		 * out the request. Otherwise attempt to read one sector
+ 		 * at a time.
+ 		 */
+ 		brq->data.bytes_xfered = 0;
+ 		err = mmc_blk_reset(md, card->host, type);
+ 		if (!err) {
+ 			mqrq->retries = MMC_MAX_RETRIES - 1;
+ 			break;
+ 		}
+ 		if (err == -ENODEV) {
+ 			mqrq->retries = MMC_NO_RETRIES;
+ 			break;
+ 		}
+ 		/* Fall through */
+ 	}
+ 	case MMC_BLK_ECC_ERR:
+ 		/*
+ 		 * Do not accept bytes_xfered. If reading more than one
+ 		 * sector, try reading one sector at a time.
+ 		 */
+ 		brq->data.bytes_xfered = 0;
+ 		/* FIXME: Missing single sector read for large sector size */
+ 		if (brq->data.blocks > 1 && !mmc_large_sector(card)) {
+ 			/* Redo read one sector at a time */
+ 			pr_warn("%s: retrying using single block read\n",
+ 				req->rq_disk->disk_name);
+ 			mmc_blk_read_single(mq, req);
+ 		} else {
+ 			mqrq->retries = MMC_NO_RETRIES;
+ 		}
+ 		break;
+ 	case MMC_BLK_NOMEDIUM:
+ 		/* Do not accept bytes_xfered. Error out the request */
+ 		brq->data.bytes_xfered = 0;
+ 		mqrq->retries = MMC_NO_RETRIES;
+ 		break;
+ 	default:
+ 		/* Do not accept bytes_xfered. Error out the request */
+ 		brq->data.bytes_xfered = 0;
+ 		mqrq->retries = MMC_NO_RETRIES;
+ 		pr_err("%s: Unhandled return value (%d)",
+ 		       req->rq_disk->disk_name, status);
+ 		break;
+ 	}
+ }
+ 
+ static inline bool mmc_blk_rq_error(struct mmc_blk_request *brq)
+ {
+ 	mmc_blk_eval_resp_error(brq);
+ 
+ 	return brq->sbc.error || brq->cmd.error || brq->stop.error ||
+ 	       brq->data.error || brq->cmd.resp[0] & CMD_ERRORS;
+ }
+ 
+ static inline void mmc_blk_rw_reset_success(struct mmc_queue *mq,
+ 					    struct request *req)
+ {
+ 	int type = rq_data_dir(req) == READ ? MMC_BLK_READ : MMC_BLK_WRITE;
+ 
+ 	mmc_blk_reset_success(mq->blkdata, type);
+ }
+ 
+ static void mmc_blk_mq_complete_rq(struct mmc_queue *mq, struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	unsigned int nr_bytes = mqrq->brq.data.bytes_xfered;
+ 
+ 	if (nr_bytes) {
+ 		if (blk_update_request(req, BLK_STS_OK, nr_bytes))
+ 			blk_mq_requeue_request(req, true);
+ 		else
+ 			__blk_mq_end_request(req, BLK_STS_OK);
+ 	} else if (!blk_rq_bytes(req)) {
+ 		__blk_mq_end_request(req, BLK_STS_IOERR);
+ 	} else if (mqrq->retries++ < MMC_MAX_RETRIES) {
+ 		blk_mq_requeue_request(req, true);
+ 	} else {
+ 		if (mmc_card_removed(mq->card))
+ 			req->rq_flags |= RQF_QUIET;
+ 		blk_mq_end_request(req, BLK_STS_IOERR);
+ 	}
+ }
+ 
+ static bool mmc_blk_urgent_bkops_needed(struct mmc_queue *mq,
+ 					struct mmc_queue_req *mqrq)
+ {
+ 	return mmc_card_mmc(mq->card) && !mmc_host_is_spi(mq->card->host) &&
+ 	       (mqrq->brq.cmd.resp[0] & R1_EXCEPTION_EVENT ||
+ 		mqrq->brq.stop.resp[0] & R1_EXCEPTION_EVENT);
+ }
+ 
+ static void mmc_blk_urgent_bkops(struct mmc_queue *mq,
+ 				 struct mmc_queue_req *mqrq)
+ {
+ 	if (mmc_blk_urgent_bkops_needed(mq, mqrq))
+ 		mmc_start_bkops(mq->card, true);
+ }
+ 
+ void mmc_blk_mq_complete(struct request *req)
+ {
+ 	struct mmc_queue *mq = req->q->queuedata;
+ 
+ 	if (mq->use_cqe)
+ 		mmc_blk_cqe_complete_rq(mq, req);
+ 	else
+ 		mmc_blk_mq_complete_rq(mq, req);
+ }
+ 
+ static void mmc_blk_mq_poll_completion(struct mmc_queue *mq,
+ 				       struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 
+ 	mmc_blk_mq_rw_recovery(mq, req);
+ 
+ 	mmc_blk_urgent_bkops(mq, mqrq);
+ }
+ 
+ static void mmc_blk_mq_dec_in_flight(struct mmc_queue *mq, struct request *req)
+ {
+ 	struct request_queue *q = req->q;
+ 	unsigned long flags;
+ 	bool put_card;
+ 
+ 	spin_lock_irqsave(q->queue_lock, flags);
+ 
+ 	mq->in_flight[mmc_issue_type(mq, req)] -= 1;
+ 
+ 	put_card = (mmc_tot_in_flight(mq) == 0);
+ 
+ 	spin_unlock_irqrestore(q->queue_lock, flags);
+ 
+ 	if (put_card)
+ 		mmc_put_card(mq->card, &mq->ctx);
+ }
+ 
+ static void mmc_blk_mq_post_req(struct mmc_queue *mq, struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	struct mmc_request *mrq = &mqrq->brq.mrq;
+ 	struct mmc_host *host = mq->card->host;
+ 
+ 	mmc_post_req(host, mrq, 0);
+ 
+ 	/*
+ 	 * Block layer timeouts race with completions which means the normal
+ 	 * completion path cannot be used during recovery.
+ 	 */
+ 	if (mq->in_recovery)
+ 		mmc_blk_mq_complete_rq(mq, req);
+ 	else
+ 		blk_mq_complete_request(req);
+ 
+ 	mmc_blk_mq_dec_in_flight(mq, req);
+ }
+ 
+ void mmc_blk_mq_recovery(struct mmc_queue *mq)
+ {
+ 	struct request *req = mq->recovery_req;
+ 	struct mmc_host *host = mq->card->host;
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 
+ 	mq->recovery_req = NULL;
+ 	mq->rw_wait = false;
+ 
+ 	if (mmc_blk_rq_error(&mqrq->brq)) {
+ 		mmc_retune_hold_now(host);
+ 		mmc_blk_mq_rw_recovery(mq, req);
+ 	}
+ 
+ 	mmc_blk_urgent_bkops(mq, mqrq);
+ 
+ 	mmc_blk_mq_post_req(mq, req);
+ }
+ 
+ static void mmc_blk_mq_complete_prev_req(struct mmc_queue *mq,
+ 					 struct request **prev_req)
+ {
+ 	if (mmc_host_done_complete(mq->card->host))
+ 		return;
+ 
+ 	mutex_lock(&mq->complete_lock);
+ 
+ 	if (!mq->complete_req)
+ 		goto out_unlock;
+ 
+ 	mmc_blk_mq_poll_completion(mq, mq->complete_req);
+ 
+ 	if (prev_req)
+ 		*prev_req = mq->complete_req;
+ 	else
+ 		mmc_blk_mq_post_req(mq, mq->complete_req);
+ 
+ 	mq->complete_req = NULL;
+ 
+ out_unlock:
+ 	mutex_unlock(&mq->complete_lock);
+ }
+ 
+ void mmc_blk_mq_complete_work(struct work_struct *work)
+ {
+ 	struct mmc_queue *mq = container_of(work, struct mmc_queue,
+ 					    complete_work);
+ 
+ 	mmc_blk_mq_complete_prev_req(mq, NULL);
+ }
+ 
+ static void mmc_blk_mq_req_done(struct mmc_request *mrq)
+ {
+ 	struct mmc_queue_req *mqrq = container_of(mrq, struct mmc_queue_req,
+ 						  brq.mrq);
+ 	struct request *req = mmc_queue_req_to_req(mqrq);
+ 	struct request_queue *q = req->q;
+ 	struct mmc_queue *mq = q->queuedata;
+ 	struct mmc_host *host = mq->card->host;
+ 	unsigned long flags;
+ 
+ 	if (!mmc_host_done_complete(host)) {
+ 		bool waiting;
+ 
+ 		/*
+ 		 * We cannot complete the request in this context, so record
+ 		 * that there is a request to complete, and that a following
+ 		 * request does not need to wait (although it does need to
+ 		 * complete complete_req first).
+ 		 */
+ 		spin_lock_irqsave(q->queue_lock, flags);
+ 		mq->complete_req = req;
+ 		mq->rw_wait = false;
+ 		waiting = mq->waiting;
+ 		spin_unlock_irqrestore(q->queue_lock, flags);
+ 
+ 		/*
+ 		 * If 'waiting' then the waiting task will complete this
+ 		 * request, otherwise queue a work to do it. Note that
+ 		 * complete_work may still race with the dispatch of a following
+ 		 * request.
+ 		 */
+ 		if (waiting)
+ 			wake_up(&mq->wait);
+ 		else
+ 			kblockd_schedule_work(&mq->complete_work);
+ 
+ 		return;
+ 	}
+ 
+ 	/* Take the recovery path for errors or urgent background operations */
+ 	if (mmc_blk_rq_error(&mqrq->brq) ||
+ 	    mmc_blk_urgent_bkops_needed(mq, mqrq)) {
+ 		spin_lock_irqsave(q->queue_lock, flags);
+ 		mq->recovery_needed = true;
+ 		mq->recovery_req = req;
+ 		spin_unlock_irqrestore(q->queue_lock, flags);
+ 		wake_up(&mq->wait);
+ 		schedule_work(&mq->recovery_work);
+ 		return;
+ 	}
+ 
+ 	mmc_blk_rw_reset_success(mq, req);
+ 
+ 	mq->rw_wait = false;
+ 	wake_up(&mq->wait);
+ 
+ 	mmc_blk_mq_post_req(mq, req);
+ }
+ 
+ static bool mmc_blk_rw_wait_cond(struct mmc_queue *mq, int *err)
+ {
+ 	struct request_queue *q = mq->queue;
+ 	unsigned long flags;
+ 	bool done;
+ 
+ 	/*
+ 	 * Wait while there is another request in progress, but not if recovery
+ 	 * is needed. Also indicate whether there is a request waiting to start.
+ 	 */
+ 	spin_lock_irqsave(q->queue_lock, flags);
+ 	if (mq->recovery_needed) {
+ 		*err = -EBUSY;
+ 		done = true;
+ 	} else {
+ 		done = !mq->rw_wait;
+ 	}
+ 	mq->waiting = !done;
+ 	spin_unlock_irqrestore(q->queue_lock, flags);
+ 
+ 	return done;
+ }
+ 
+ static int mmc_blk_rw_wait(struct mmc_queue *mq, struct request **prev_req)
+ {
+ 	int err = 0;
+ 
+ 	wait_event(mq->wait, mmc_blk_rw_wait_cond(mq, &err));
+ 
+ 	/* Always complete the previous request if there is one */
+ 	mmc_blk_mq_complete_prev_req(mq, prev_req);
+ 
+ 	return err;
+ }
+ 
+ static int mmc_blk_mq_issue_rw_rq(struct mmc_queue *mq,
+ 				  struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	struct mmc_host *host = mq->card->host;
+ 	struct request *prev_req = NULL;
+ 	int err = 0;
+ 
+ 	mmc_blk_rw_rq_prep(mqrq, mq->card, 0, mq);
+ 
+ 	mqrq->brq.mrq.done = mmc_blk_mq_req_done;
+ 
+ 	mmc_pre_req(host, &mqrq->brq.mrq);
+ 
+ 	err = mmc_blk_rw_wait(mq, &prev_req);
+ 	if (err)
+ 		goto out_post_req;
+ 
+ 	mq->rw_wait = true;
+ 
+ 	err = mmc_start_request(host, &mqrq->brq.mrq);
+ 
+ 	if (prev_req)
+ 		mmc_blk_mq_post_req(mq, prev_req);
+ 
+ 	if (err)
+ 		mq->rw_wait = false;
+ 
+ 	/* Release re-tuning here where there is no synchronization required */
+ 	if (err || mmc_host_done_complete(host))
+ 		mmc_retune_release(host);
++>>>>>>> 10f21df4a235 (mmc: block: blk-mq: Add support for direct completion)
  
 -out_post_req:
 -	if (err)
 -		mmc_post_req(host, &mqrq->brq.mrq, err);
 -
 -	return err;
 -}
 -
 -static int mmc_blk_wait_for_idle(struct mmc_queue *mq, struct mmc_host *host)
 -{
 -	if (mq->use_cqe)
 -		return host->cqe_ops->cqe_wait_for_idle(host);
 -
 -	return mmc_blk_rw_wait(mq, NULL);
 -}
 -
 -enum mmc_issued mmc_blk_mq_issue_rq(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_blk_data *md = mq->blkdata;
 -	struct mmc_card *card = md->queue.card;
 -	struct mmc_host *host = card->host;
 -	int ret;
 -
 -	ret = mmc_blk_part_switch(card, md->part_type);
 -	if (ret)
 -		return MMC_REQ_FAILED_TO_START;
 +	mqrq->mmc_active.mrq = &brq->mrq;
 +	mqrq->mmc_active.err_check = mmc_blk_err_check;
  
 -	switch (mmc_issue_type(mq, req)) {
 -	case MMC_ISSUE_SYNC:
 -		ret = mmc_blk_wait_for_idle(mq, host);
 -		if (ret)
 -			return MMC_REQ_BUSY;
 -		switch (req_op(req)) {
 -		case REQ_OP_DRV_IN:
 -		case REQ_OP_DRV_OUT:
 -			mmc_blk_issue_drv_op(mq, req);
 -			break;
 -		case REQ_OP_DISCARD:
 -			mmc_blk_issue_discard_rq(mq, req);
 -			break;
 -		case REQ_OP_SECURE_ERASE:
 -			mmc_blk_issue_secdiscard_rq(mq, req);
 -			break;
 -		case REQ_OP_FLUSH:
 -			mmc_blk_issue_flush(mq, req);
 -			break;
 -		default:
 -			WARN_ON_ONCE(1);
 -			return MMC_REQ_FAILED_TO_START;
 -		}
 -		return MMC_REQ_FINISHED;
 -	case MMC_ISSUE_DCMD:
 -	case MMC_ISSUE_ASYNC:
 -		switch (req_op(req)) {
 -		case REQ_OP_FLUSH:
 -			ret = mmc_blk_cqe_issue_flush(mq, req);
 -			break;
 -		case REQ_OP_READ:
 -		case REQ_OP_WRITE:
 -			if (mq->use_cqe)
 -				ret = mmc_blk_cqe_issue_rw_rq(mq, req);
 -			else
 -				ret = mmc_blk_mq_issue_rw_rq(mq, req);
 -			break;
 -		default:
 -			WARN_ON_ONCE(1);
 -			ret = -EINVAL;
 -		}
 -		if (!ret)
 -			return MMC_REQ_STARTED;
 -		return ret == -EBUSY ? MMC_REQ_BUSY : MMC_REQ_FAILED_TO_START;
 -	default:
 -		WARN_ON_ONCE(1);
 -		return MMC_REQ_FAILED_TO_START;
 -	}
 +	mmc_queue_bounce_pre(mqrq);
  }
  
 -static bool mmc_blk_rw_cmd_err(struct mmc_blk_data *md, struct mmc_card *card,
 -			       struct mmc_blk_request *brq, struct request *req,
 -			       bool old_req_pending)
 +static int mmc_blk_cmd_err(struct mmc_blk_data *md, struct mmc_card *card,
 +			   struct mmc_blk_request *brq, struct request *req,
 +			   int ret)
  {
 -	bool req_pending;
 +	struct mmc_queue_req *mq_rq;
 +	mq_rq = container_of(brq, struct mmc_queue_req, brq);
  
  	/*
  	 * If this is an SD card and we're writing, we can first
diff --cc drivers/mmc/core/block.h
index cdabb2ee74be,b126418fd163..000000000000
--- a/drivers/mmc/core/block.h
+++ b/drivers/mmc/core/block.h
@@@ -1,1 -1,22 +1,26 @@@
++<<<<<<< HEAD
 +int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req);
++=======
+ /* SPDX-License-Identifier: GPL-2.0 */
+ #ifndef _MMC_CORE_BLOCK_H
+ #define _MMC_CORE_BLOCK_H
+ 
+ struct mmc_queue;
+ struct request;
+ 
+ void mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req);
+ 
+ void mmc_blk_cqe_recovery(struct mmc_queue *mq);
+ 
+ enum mmc_issued;
+ 
+ enum mmc_issued mmc_blk_mq_issue_rq(struct mmc_queue *mq, struct request *req);
+ void mmc_blk_mq_complete(struct request *req);
+ void mmc_blk_mq_recovery(struct mmc_queue *mq);
+ 
+ struct work_struct;
+ 
+ void mmc_blk_mq_complete_work(struct work_struct *work);
+ 
+ #endif
++>>>>>>> 10f21df4a235 (mmc: block: blk-mq: Add support for direct completion)
diff --cc drivers/mmc/core/host.h
index 5e9a1293091b,8ca284e079e3..000000000000
--- a/drivers/mmc/core/host.h
+++ b/drivers/mmc/core/host.h
@@@ -18,9 -19,70 +18,74 @@@ void mmc_unregister_host_class(void)
  void mmc_retune_enable(struct mmc_host *host);
  void mmc_retune_disable(struct mmc_host *host);
  void mmc_retune_hold(struct mmc_host *host);
 +void mmc_retune_hold_now(struct mmc_host *host);
  void mmc_retune_release(struct mmc_host *host);
  int mmc_retune(struct mmc_host *host);
++<<<<<<< HEAD
++=======
+ void mmc_retune_pause(struct mmc_host *host);
+ void mmc_retune_unpause(struct mmc_host *host);
+ 
+ static inline void mmc_retune_hold_now(struct mmc_host *host)
+ {
+ 	host->retune_now = 0;
+ 	host->hold_retune += 1;
+ }
+ 
+ static inline void mmc_retune_recheck(struct mmc_host *host)
+ {
+ 	if (host->hold_retune <= 1)
+ 		host->retune_now = 1;
+ }
+ 
+ static inline int mmc_host_cmd23(struct mmc_host *host)
+ {
+ 	return host->caps & MMC_CAP_CMD23;
+ }
+ 
+ static inline bool mmc_host_done_complete(struct mmc_host *host)
+ {
+ 	return host->caps & MMC_CAP_DONE_COMPLETE;
+ }
+ 
+ static inline int mmc_boot_partition_access(struct mmc_host *host)
+ {
+ 	return !(host->caps2 & MMC_CAP2_BOOTPART_NOACC);
+ }
+ 
+ static inline int mmc_host_uhs(struct mmc_host *host)
+ {
+ 	return host->caps &
+ 		(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
+ 		 MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 |
+ 		 MMC_CAP_UHS_DDR50);
+ }
+ 
+ static inline bool mmc_card_hs200(struct mmc_card *card)
+ {
+ 	return card->host->ios.timing == MMC_TIMING_MMC_HS200;
+ }
+ 
+ static inline bool mmc_card_ddr52(struct mmc_card *card)
+ {
+ 	return card->host->ios.timing == MMC_TIMING_MMC_DDR52;
+ }
+ 
+ static inline bool mmc_card_hs400(struct mmc_card *card)
+ {
+ 	return card->host->ios.timing == MMC_TIMING_MMC_HS400;
+ }
+ 
+ static inline bool mmc_card_hs400es(struct mmc_card *card)
+ {
+ 	return card->host->ios.enhanced_strobe;
+ }
+ 
+ static inline bool mmc_host_use_blk_mq(struct mmc_host *host)
+ {
+ 	return host->use_blk_mq;
+ }
++>>>>>>> 10f21df4a235 (mmc: block: blk-mq: Add support for direct completion)
  
  #endif
  
diff --cc drivers/mmc/core/queue.c
index 8704591ee805,d8394007bc99..000000000000
--- a/drivers/mmc/core/queue.c
+++ b/drivers/mmc/core/queue.c
@@@ -47,6 -40,147 +47,150 @@@ static int mmc_prep_request(struct requ
  	return BLKPREP_OK;
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool mmc_cqe_dcmd_busy(struct mmc_queue *mq)
+ {
+ 	/* Allow only 1 DCMD at a time */
+ 	return mq->in_flight[MMC_ISSUE_DCMD];
+ }
+ 
+ void mmc_cqe_check_busy(struct mmc_queue *mq)
+ {
+ 	if ((mq->cqe_busy & MMC_CQE_DCMD_BUSY) && !mmc_cqe_dcmd_busy(mq))
+ 		mq->cqe_busy &= ~MMC_CQE_DCMD_BUSY;
+ 
+ 	mq->cqe_busy &= ~MMC_CQE_QUEUE_FULL;
+ }
+ 
+ static inline bool mmc_cqe_can_dcmd(struct mmc_host *host)
+ {
+ 	return host->caps2 & MMC_CAP2_CQE_DCMD;
+ }
+ 
+ enum mmc_issue_type mmc_cqe_issue_type(struct mmc_host *host,
+ 				       struct request *req)
+ {
+ 	switch (req_op(req)) {
+ 	case REQ_OP_DRV_IN:
+ 	case REQ_OP_DRV_OUT:
+ 	case REQ_OP_DISCARD:
+ 	case REQ_OP_SECURE_ERASE:
+ 		return MMC_ISSUE_SYNC;
+ 	case REQ_OP_FLUSH:
+ 		return mmc_cqe_can_dcmd(host) ? MMC_ISSUE_DCMD : MMC_ISSUE_SYNC;
+ 	default:
+ 		return MMC_ISSUE_ASYNC;
+ 	}
+ }
+ 
+ enum mmc_issue_type mmc_issue_type(struct mmc_queue *mq, struct request *req)
+ {
+ 	struct mmc_host *host = mq->card->host;
+ 
+ 	if (mq->use_cqe)
+ 		return mmc_cqe_issue_type(host, req);
+ 
+ 	if (req_op(req) == REQ_OP_READ || req_op(req) == REQ_OP_WRITE)
+ 		return MMC_ISSUE_ASYNC;
+ 
+ 	return MMC_ISSUE_SYNC;
+ }
+ 
+ static void __mmc_cqe_recovery_notifier(struct mmc_queue *mq)
+ {
+ 	if (!mq->recovery_needed) {
+ 		mq->recovery_needed = true;
+ 		schedule_work(&mq->recovery_work);
+ 	}
+ }
+ 
+ void mmc_cqe_recovery_notifier(struct mmc_request *mrq)
+ {
+ 	struct mmc_queue_req *mqrq = container_of(mrq, struct mmc_queue_req,
+ 						  brq.mrq);
+ 	struct request *req = mmc_queue_req_to_req(mqrq);
+ 	struct request_queue *q = req->q;
+ 	struct mmc_queue *mq = q->queuedata;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(q->queue_lock, flags);
+ 	__mmc_cqe_recovery_notifier(mq);
+ 	spin_unlock_irqrestore(q->queue_lock, flags);
+ }
+ 
+ static enum blk_eh_timer_return mmc_cqe_timed_out(struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	struct mmc_request *mrq = &mqrq->brq.mrq;
+ 	struct mmc_queue *mq = req->q->queuedata;
+ 	struct mmc_host *host = mq->card->host;
+ 	enum mmc_issue_type issue_type = mmc_issue_type(mq, req);
+ 	bool recovery_needed = false;
+ 
+ 	switch (issue_type) {
+ 	case MMC_ISSUE_ASYNC:
+ 	case MMC_ISSUE_DCMD:
+ 		if (host->cqe_ops->cqe_timeout(host, mrq, &recovery_needed)) {
+ 			if (recovery_needed)
+ 				__mmc_cqe_recovery_notifier(mq);
+ 			return BLK_EH_RESET_TIMER;
+ 		}
+ 		/* No timeout */
+ 		return BLK_EH_HANDLED;
+ 	default:
+ 		/* Timeout is handled by mmc core */
+ 		return BLK_EH_RESET_TIMER;
+ 	}
+ }
+ 
+ static enum blk_eh_timer_return mmc_mq_timed_out(struct request *req,
+ 						 bool reserved)
+ {
+ 	struct request_queue *q = req->q;
+ 	struct mmc_queue *mq = q->queuedata;
+ 	unsigned long flags;
+ 	int ret;
+ 
+ 	spin_lock_irqsave(q->queue_lock, flags);
+ 
+ 	if (mq->recovery_needed || !mq->use_cqe)
+ 		ret = BLK_EH_RESET_TIMER;
+ 	else
+ 		ret = mmc_cqe_timed_out(req);
+ 
+ 	spin_unlock_irqrestore(q->queue_lock, flags);
+ 
+ 	return ret;
+ }
+ 
+ static void mmc_mq_recovery_handler(struct work_struct *work)
+ {
+ 	struct mmc_queue *mq = container_of(work, struct mmc_queue,
+ 					    recovery_work);
+ 	struct request_queue *q = mq->queue;
+ 
+ 	mmc_get_card(mq->card, &mq->ctx);
+ 
+ 	mq->in_recovery = true;
+ 
+ 	if (mq->use_cqe)
+ 		mmc_blk_cqe_recovery(mq);
+ 	else
+ 		mmc_blk_mq_recovery(mq);
+ 
+ 	mq->in_recovery = false;
+ 
+ 	spin_lock_irq(q->queue_lock);
+ 	mq->recovery_needed = false;
+ 	spin_unlock_irq(q->queue_lock);
+ 
+ 	mmc_put_card(mq->card, &mq->ctx);
+ 
+ 	blk_mq_run_hw_queues(q, true);
+ }
+ 
++>>>>>>> 10f21df4a235 (mmc: block: blk-mq: Add support for direct completion)
  static int mmc_queue_thread(void *d)
  {
  	struct mmc_queue *mq = d;
diff --cc drivers/mmc/core/queue.h
index a61f88199573,34f601c6dd39..000000000000
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@@ -36,10 -84,29 +36,36 @@@ struct mmc_queue 
  	bool			asleep;
  	struct mmc_blk_data	*blkdata;
  	struct request_queue	*queue;
++<<<<<<< HEAD
 +	struct mmc_queue_req	*mqrq;
 +	struct mmc_queue_req	*mqrq_cur;
 +	struct mmc_queue_req	*mqrq_prev;
 +	int			qdepth;
++=======
+ 	/*
+ 	 * FIXME: this counter is not a very reliable way of keeping
+ 	 * track of how many requests that are ongoing. Switch to just
+ 	 * letting the block core keep track of requests and per-request
+ 	 * associated mmc_queue_req data.
+ 	 */
+ 	int			qcnt;
+ 
+ 	int			in_flight[MMC_ISSUE_MAX];
+ 	unsigned int		cqe_busy;
+ #define MMC_CQE_DCMD_BUSY	BIT(0)
+ #define MMC_CQE_QUEUE_FULL	BIT(1)
+ 	bool			use_cqe;
+ 	bool			recovery_needed;
+ 	bool			in_recovery;
+ 	bool			rw_wait;
+ 	bool			waiting;
+ 	struct work_struct	recovery_work;
+ 	wait_queue_head_t	wait;
+ 	struct request		*recovery_req;
+ 	struct request		*complete_req;
+ 	struct mutex		complete_lock;
+ 	struct work_struct	complete_work;
++>>>>>>> 10f21df4a235 (mmc: block: blk-mq: Add support for direct completion)
  };
  
  extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *,
* Unmerged path drivers/mmc/core/block.c
* Unmerged path drivers/mmc/core/block.h
* Unmerged path drivers/mmc/core/host.h
* Unmerged path drivers/mmc/core/queue.c
* Unmerged path drivers/mmc/core/queue.h
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 3d6f7a820ea1..f88bdf96570a 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -276,6 +276,7 @@ struct mmc_host {
 #define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
 #define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
 #define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */
+#define MMC_CAP_DONE_COMPLETE	(1 << 27)	/* RW reqs can be completed within mmc_request_done() */
 #define MMC_CAP_CD_WAKE		(1 << 28)	/* Enable card detect wake */
 #define MMC_CAP_CMD_DURING_TFR	(1 << 29)	/* Commands during data transfer */
 #define MMC_CAP_CMD23		(1 << 30)	/* CMD23 supported. */
