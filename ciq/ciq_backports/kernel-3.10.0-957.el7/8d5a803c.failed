ext4: check for allocation block validity with block group locked

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit 8d5a803c6a6ce4ec258e31f76059ea5153ba46ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8d5a803c.failed

With commit 044e6e3d74a3: "ext4: don't update checksum of new
initialized bitmaps" the buffer valid bit will get set without
actually setting up the checksum for the allocation bitmap, since the
checksum will get calculated once we actually allocate an inode or
block.

If we are doing this, then we need to (re-)check the verified bit
after we take the block group lock.  Otherwise, we could race with
another process reading and verifying the bitmap, which would then
complain about the checksum being invalid.

https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1780137

	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: stable@kernel.org
(cherry picked from commit 8d5a803c6a6ce4ec258e31f76059ea5153ba46ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/balloc.c
#	fs/ext4/ialloc.c
diff --cc fs/ext4/balloc.c
index 37d0ffa33e0e,aa52d87985aa..000000000000
--- a/fs/ext4/balloc.c
+++ b/fs/ext4/balloc.c
@@@ -377,35 -361,36 +377,49 @@@ static void ext4_validate_block_bitmap(
  {
  	ext4_fsblk_t	blk;
  	struct ext4_group_info *grp = ext4_get_group_info(sb, block_group);
 +	struct ext4_sb_info *sbi = EXT4_SB(sb);
  
 -	if (buffer_verified(bh))
 -		return 0;
 -	if (EXT4_MB_GRP_BBITMAP_CORRUPT(grp))
 -		return -EFSCORRUPTED;
 +	if (buffer_verified(bh) || EXT4_MB_GRP_BBITMAP_CORRUPT(grp))
 +		return;
  
  	ext4_lock_group(sb, block_group);
++<<<<<<< HEAD
++=======
+ 	if (buffer_verified(bh))
+ 		goto verified;
+ 	if (unlikely(!ext4_block_bitmap_csum_verify(sb, block_group,
+ 			desc, bh))) {
+ 		ext4_unlock_group(sb, block_group);
+ 		ext4_error(sb, "bg %u: bad block bitmap checksum", block_group);
+ 		ext4_mark_group_bitmap_corrupted(sb, block_group,
+ 					EXT4_GROUP_INFO_BBITMAP_CORRUPT);
+ 		return -EFSBADCRC;
+ 	}
++>>>>>>> 8d5a803c6a6c (ext4: check for allocation block validity with block group locked)
  	blk = ext4_valid_block_bitmap(sb, desc, block_group, bh);
  	if (unlikely(blk != 0)) {
  		ext4_unlock_group(sb, block_group);
  		ext4_error(sb, "bg %u: block %llu: invalid block bitmap",
  			   block_group, blk);
 -		ext4_mark_group_bitmap_corrupted(sb, block_group,
 -					EXT4_GROUP_INFO_BBITMAP_CORRUPT);
 -		return -EFSCORRUPTED;
 +		if (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))
 +			percpu_counter_sub(&sbi->s_freeclusters_counter,
 +					   grp->bb_free);
 +		set_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);
 +		return;
 +	}
 +	if (unlikely(!ext4_block_bitmap_csum_verify(sb, block_group,
 +			desc, bh))) {
 +		ext4_unlock_group(sb, block_group);
 +		ext4_error(sb, "bg %u: bad block bitmap checksum", block_group);
 +		if (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))
 +			percpu_counter_sub(&sbi->s_freeclusters_counter,
 +					   grp->bb_free);
 +		set_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);
 +		return;
  	}
  	set_buffer_verified(bh);
+ verified:
  	ext4_unlock_group(sb, block_group);
 -	return 0;
  }
  
  /**
diff --cc fs/ext4/ialloc.c
index 801dc9a570e9,e9d8e2667ab5..000000000000
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@@ -113,6 -76,38 +113,41 @@@ void ext4_end_bitmap_read(struct buffer
  	put_bh(bh);
  }
  
++<<<<<<< HEAD
++=======
+ static int ext4_validate_inode_bitmap(struct super_block *sb,
+ 				      struct ext4_group_desc *desc,
+ 				      ext4_group_t block_group,
+ 				      struct buffer_head *bh)
+ {
+ 	ext4_fsblk_t	blk;
+ 	struct ext4_group_info *grp = ext4_get_group_info(sb, block_group);
+ 
+ 	if (buffer_verified(bh))
+ 		return 0;
+ 	if (EXT4_MB_GRP_IBITMAP_CORRUPT(grp))
+ 		return -EFSCORRUPTED;
+ 
+ 	ext4_lock_group(sb, block_group);
+ 	if (buffer_verified(bh))
+ 		goto verified;
+ 	blk = ext4_inode_bitmap(sb, desc);
+ 	if (!ext4_inode_bitmap_csum_verify(sb, block_group, desc, bh,
+ 					   EXT4_INODES_PER_GROUP(sb) / 8)) {
+ 		ext4_unlock_group(sb, block_group);
+ 		ext4_error(sb, "Corrupt inode bitmap - block_group = %u, "
+ 			   "inode_bitmap = %llu", block_group, blk);
+ 		ext4_mark_group_bitmap_corrupted(sb, block_group,
+ 					EXT4_GROUP_INFO_IBITMAP_CORRUPT);
+ 		return -EFSBADCRC;
+ 	}
+ 	set_buffer_verified(bh);
+ verified:
+ 	ext4_unlock_group(sb, block_group);
+ 	return 0;
+ }
+ 
++>>>>>>> 8d5a803c6a6c (ext4: check for allocation block validity with block group locked)
  /*
   * Read the inode allocation bitmap for a given block_group, reading
   * into the specified slot in the superblock's bitmap cache.
* Unmerged path fs/ext4/balloc.c
* Unmerged path fs/ext4/ialloc.c
