net: aquantia: Regression on reset with 1.x firmware

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] aquantia: Regression on reset with 1.x firmware (David Arcari) [1570787]
Rebuild_FUZZ: 94.95%
commit-author Igor Russkikh <igor.russkikh@aquantia.com>
commit cce96d1883dae4b79f44890e5118243d806da286
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/cce96d18.failed

On ASUS XG-C100C with 1.5.44 firmware a special mode called "dirty wake"
is active. With this mode when motherboard gets powered (but no poweron
happens yet), NIC automatically enables powersave link and watches
for WOL packet.
This normally allows to powerup the PC after AC power failures.

Not all motherboards or bios settings gives power to PCI slots,
so this mode is not enabled on all the hardware.

4.16 linux driver introduced full hardware reset sequence
This is required since before that we had no NIC hardware
reset implemented and there were side effects of "not clean start".

But this full reset is incompatible with "dirty wake" WOL feature
it keeps the PHY link in a special mode forever. As a consequence,
driver sees no link and no traffic.

To fix this we forcibly change FW state to idle state before doing
the full reset. This makes FW to restore link state.

Fixes: c8c82eb net: aquantia: Introduce global AQC hardware reset sequence
	Signed-off-by: Igor Russkikh <igor.russkikh@aquantia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cce96d1883dae4b79f44890e5118243d806da286)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
index 87f36ca5f431,e652d86b87d4..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
@@@ -31,11 -32,245 +31,250 @@@
  
  #define HW_ATL_MPI_STATE_MSK    0x00FFU
  #define HW_ATL_MPI_STATE_SHIFT  0U
 -#define HW_ATL_MPI_SPEED_MSK    0xFFFF0000U
 +#define HW_ATL_MPI_SPEED_MSK    0xFFFFU
  #define HW_ATL_MPI_SPEED_SHIFT  16U
  
++<<<<<<< HEAD
 +static int hw_atl_utils_fw_downld_dwords(struct aq_hw_s *self, u32 a,
 +					 u32 *p, u32 cnt)
++=======
+ #define HW_ATL_MPI_DAISY_CHAIN_STATUS	0x704
+ #define HW_ATL_MPI_BOOT_EXIT_CODE	0x388
+ 
+ #define HW_ATL_MAC_PHY_CONTROL	0x4000
+ #define HW_ATL_MAC_PHY_MPI_RESET_BIT 0x1D
+ 
+ #define HW_ATL_FW_VER_1X 0x01050006U
+ #define HW_ATL_FW_VER_2X 0x02000000U
+ #define HW_ATL_FW_VER_3X 0x03000000U
+ 
+ #define FORCE_FLASHLESS 0
+ 
+ static int hw_atl_utils_ver_match(u32 ver_expected, u32 ver_actual);
+ static int hw_atl_utils_mpi_set_state(struct aq_hw_s *self,
+ 				      enum hal_atl_utils_fw_state_e state);
+ 
+ int hw_atl_utils_initfw(struct aq_hw_s *self, const struct aq_fw_ops **fw_ops)
+ {
+ 	int err = 0;
+ 
+ 	err = hw_atl_utils_soft_reset(self);
+ 	if (err)
+ 		return err;
+ 
+ 	hw_atl_utils_hw_chip_features_init(self,
+ 					   &self->chip_features);
+ 
+ 	hw_atl_utils_get_fw_version(self, &self->fw_ver_actual);
+ 
+ 	if (hw_atl_utils_ver_match(HW_ATL_FW_VER_1X,
+ 				   self->fw_ver_actual) == 0) {
+ 		*fw_ops = &aq_fw_1x_ops;
+ 	} else if (hw_atl_utils_ver_match(HW_ATL_FW_VER_2X,
+ 					self->fw_ver_actual) == 0) {
+ 		*fw_ops = &aq_fw_2x_ops;
+ 	} else if (hw_atl_utils_ver_match(HW_ATL_FW_VER_3X,
+ 					self->fw_ver_actual) == 0) {
+ 		*fw_ops = &aq_fw_2x_ops;
+ 	} else {
+ 		aq_pr_err("Bad FW version detected: %x\n",
+ 			  self->fw_ver_actual);
+ 		return -EOPNOTSUPP;
+ 	}
+ 	self->aq_fw_ops = *fw_ops;
+ 	err = self->aq_fw_ops->init(self);
+ 	return err;
+ }
+ 
+ static int hw_atl_utils_soft_reset_flb(struct aq_hw_s *self)
+ {
+ 	u32 gsr, val;
+ 	int k = 0;
+ 
+ 	aq_hw_write_reg(self, 0x404, 0x40e1);
+ 	AQ_HW_SLEEP(50);
+ 
+ 	/* Cleanup SPI */
+ 	val = aq_hw_read_reg(self, 0x53C);
+ 	aq_hw_write_reg(self, 0x53C, val | 0x10);
+ 
+ 	gsr = aq_hw_read_reg(self, HW_ATL_GLB_SOFT_RES_ADR);
+ 	aq_hw_write_reg(self, HW_ATL_GLB_SOFT_RES_ADR, (gsr & 0xBFFF) | 0x8000);
+ 
+ 	/* Kickstart MAC */
+ 	aq_hw_write_reg(self, 0x404, 0x80e0);
+ 	aq_hw_write_reg(self, 0x32a8, 0x0);
+ 	aq_hw_write_reg(self, 0x520, 0x1);
+ 
+ 	/* Reset SPI again because of possible interrupted SPI burst */
+ 	val = aq_hw_read_reg(self, 0x53C);
+ 	aq_hw_write_reg(self, 0x53C, val | 0x10);
+ 	AQ_HW_SLEEP(10);
+ 	/* Clear SPI reset state */
+ 	aq_hw_write_reg(self, 0x53C, val & ~0x10);
+ 
+ 	aq_hw_write_reg(self, 0x404, 0x180e0);
+ 
+ 	for (k = 0; k < 1000; k++) {
+ 		u32 flb_status = aq_hw_read_reg(self,
+ 						HW_ATL_MPI_DAISY_CHAIN_STATUS);
+ 
+ 		flb_status = flb_status & 0x10;
+ 		if (flb_status)
+ 			break;
+ 		AQ_HW_SLEEP(10);
+ 	}
+ 	if (k == 1000) {
+ 		aq_pr_err("MAC kickstart failed\n");
+ 		return -EIO;
+ 	}
+ 
+ 	/* FW reset */
+ 	aq_hw_write_reg(self, 0x404, 0x80e0);
+ 	AQ_HW_SLEEP(50);
+ 	aq_hw_write_reg(self, 0x3a0, 0x1);
+ 
+ 	/* Kickstart PHY - skipped */
+ 
+ 	/* Global software reset*/
+ 	hw_atl_rx_rx_reg_res_dis_set(self, 0U);
+ 	hw_atl_tx_tx_reg_res_dis_set(self, 0U);
+ 	aq_hw_write_reg_bit(self, HW_ATL_MAC_PHY_CONTROL,
+ 			    BIT(HW_ATL_MAC_PHY_MPI_RESET_BIT),
+ 			    HW_ATL_MAC_PHY_MPI_RESET_BIT, 0x0);
+ 	gsr = aq_hw_read_reg(self, HW_ATL_GLB_SOFT_RES_ADR);
+ 	aq_hw_write_reg(self, HW_ATL_GLB_SOFT_RES_ADR, (gsr & 0xBFFF) | 0x8000);
+ 
+ 	for (k = 0; k < 1000; k++) {
+ 		u32 fw_state = aq_hw_read_reg(self, HW_ATL_MPI_FW_VERSION);
+ 
+ 		if (fw_state)
+ 			break;
+ 		AQ_HW_SLEEP(10);
+ 	}
+ 	if (k == 1000) {
+ 		aq_pr_err("FW kickstart failed\n");
+ 		return -EIO;
+ 	}
+ 	/* Old FW requires fixed delay after init */
+ 	AQ_HW_SLEEP(15);
+ 
+ 	return 0;
+ }
+ 
+ static int hw_atl_utils_soft_reset_rbl(struct aq_hw_s *self)
+ {
+ 	u32 gsr, val, rbl_status;
+ 	int k;
+ 
+ 	aq_hw_write_reg(self, 0x404, 0x40e1);
+ 	aq_hw_write_reg(self, 0x3a0, 0x1);
+ 	aq_hw_write_reg(self, 0x32a8, 0x0);
+ 
+ 	/* Alter RBL status */
+ 	aq_hw_write_reg(self, 0x388, 0xDEAD);
+ 
+ 	/* Cleanup SPI */
+ 	val = aq_hw_read_reg(self, 0x53C);
+ 	aq_hw_write_reg(self, 0x53C, val | 0x10);
+ 
+ 	/* Global software reset*/
+ 	hw_atl_rx_rx_reg_res_dis_set(self, 0U);
+ 	hw_atl_tx_tx_reg_res_dis_set(self, 0U);
+ 	aq_hw_write_reg_bit(self, HW_ATL_MAC_PHY_CONTROL,
+ 			    BIT(HW_ATL_MAC_PHY_MPI_RESET_BIT),
+ 			    HW_ATL_MAC_PHY_MPI_RESET_BIT, 0x0);
+ 	gsr = aq_hw_read_reg(self, HW_ATL_GLB_SOFT_RES_ADR);
+ 	aq_hw_write_reg(self, HW_ATL_GLB_SOFT_RES_ADR,
+ 			(gsr & 0xFFFFBFFF) | 0x8000);
+ 
+ 	if (FORCE_FLASHLESS)
+ 		aq_hw_write_reg(self, 0x534, 0x0);
+ 
+ 	aq_hw_write_reg(self, 0x404, 0x40e0);
+ 
+ 	/* Wait for RBL boot */
+ 	for (k = 0; k < 1000; k++) {
+ 		rbl_status = aq_hw_read_reg(self, 0x388) & 0xFFFF;
+ 		if (rbl_status && rbl_status != 0xDEAD)
+ 			break;
+ 		AQ_HW_SLEEP(10);
+ 	}
+ 	if (!rbl_status || rbl_status == 0xDEAD) {
+ 		aq_pr_err("RBL Restart failed");
+ 		return -EIO;
+ 	}
+ 
+ 	/* Restore NVR */
+ 	if (FORCE_FLASHLESS)
+ 		aq_hw_write_reg(self, 0x534, 0xA0);
+ 
+ 	if (rbl_status == 0xF1A7) {
+ 		aq_pr_err("No FW detected. Dynamic FW load not implemented\n");
+ 		return -ENOTSUPP;
+ 	}
+ 
+ 	for (k = 0; k < 1000; k++) {
+ 		u32 fw_state = aq_hw_read_reg(self, HW_ATL_MPI_FW_VERSION);
+ 
+ 		if (fw_state)
+ 			break;
+ 		AQ_HW_SLEEP(10);
+ 	}
+ 	if (k == 1000) {
+ 		aq_pr_err("FW kickstart failed\n");
+ 		return -EIO;
+ 	}
+ 	/* Old FW requires fixed delay after init */
+ 	AQ_HW_SLEEP(15);
+ 
+ 	return 0;
+ }
+ 
+ int hw_atl_utils_soft_reset(struct aq_hw_s *self)
+ {
+ 	int k;
+ 	u32 boot_exit_code = 0;
+ 
+ 	for (k = 0; k < 1000; ++k) {
+ 		u32 flb_status = aq_hw_read_reg(self,
+ 						HW_ATL_MPI_DAISY_CHAIN_STATUS);
+ 		boot_exit_code = aq_hw_read_reg(self,
+ 						HW_ATL_MPI_BOOT_EXIT_CODE);
+ 		if (flb_status != 0x06000000 || boot_exit_code != 0)
+ 			break;
+ 	}
+ 
+ 	if (k == 1000) {
+ 		aq_pr_err("Neither RBL nor FLB firmware started\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	self->rbl_enabled = (boot_exit_code != 0);
+ 
+ 	/* FW 1.x may bootup in an invalid POWER state (WOL feature).
+ 	 * We should work around this by forcing its state back to DEINIT
+ 	 */
+ 	if (!hw_atl_utils_ver_match(HW_ATL_FW_VER_1X,
+ 				    aq_hw_read_reg(self,
+ 						   HW_ATL_MPI_FW_VERSION))) {
+ 		int err = 0;
+ 
+ 		hw_atl_utils_mpi_set_state(self, MPI_DEINIT);
+ 		AQ_HW_WAIT_FOR((aq_hw_read_reg(self, HW_ATL_MPI_STATE_ADR) &
+ 			       HW_ATL_MPI_STATE_MSK) == MPI_DEINIT,
+ 			       10, 1000U);
+ 	}
+ 
+ 	if (self->rbl_enabled)
+ 		return hw_atl_utils_soft_reset_rbl(self);
+ 	else
+ 		return hw_atl_utils_soft_reset_flb(self);
+ }
+ 
+ int hw_atl_utils_fw_downld_dwords(struct aq_hw_s *self, u32 a,
+ 				  u32 *p, u32 cnt)
++>>>>>>> cce96d1883da (net: aquantia: Regression on reset with 1.x firmware)
  {
  	int err = 0;
  
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
