netfilter: ipset: Introduce RCU locking in list type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 00590fdd5be0d763631ef10e6a3e2ce8fc2d9ec3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/00590fdd.failed

Standard rculist is used.

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 00590fdd5be0d763631ef10e6a3e2ce8fc2d9ec3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_list_set.c
diff --cc net/netfilter/ipset/ip_set_list_set.c
index a9a97c07ecb4,9f624ee9a41e..000000000000
--- a/net/netfilter/ipset/ip_set_list_set.c
+++ b/net/netfilter/ipset/ip_set_list_set.c
@@@ -58,26 -41,12 +61,29 @@@ struct set_adt_elem 
  
  /* Type structure */
  struct list_set {
 +	size_t dsize;		/* element size */
 +	size_t offset[IPSET_EXT_ID_MAX]; /* Offsets to extensions */
  	u32 size;		/* size of set list array */
 +	u32 timeout;		/* timeout value */
  	struct timer_list gc;	/* garbage collection */
  	struct net *net;	/* namespace */
- 	struct set_elem members[0]; /* the set members */
+ 	struct list_head members; /* the set members */
  };
  
++<<<<<<< HEAD
 +static inline struct set_elem *
 +list_set_elem(const struct list_set *map, u32 id)
 +{
 +	return (struct set_elem *)((void *)map->members + id * map->dsize);
 +}
 +
 +#define ext_timeout(e, m)	\
 +(unsigned long *)((void *)(e) + (m)->offset[IPSET_EXT_ID_TIMEOUT])
 +#define ext_counter(e, m)	\
 +(struct ip_set_counter *)((void *)(e) + (m)->offset[IPSET_EXT_ID_COUNTER])
 +
++=======
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  static int
  list_set_ktest(struct ip_set *set, const struct sk_buff *skb,
  	       const struct xt_action_param *par,
@@@ -92,12 -61,9 +98,16 @@@
  	opt->cmdflags &= ~IPSET_FLAG_MATCH_COUNTERS;
  	if (opt->cmdflags & IPSET_FLAG_SKIP_SUBCOUNTER_UPDATE)
  		opt->cmdflags &= ~IPSET_FLAG_SKIP_COUNTER_UPDATE;
++<<<<<<< HEAD
 +	for (i = 0; i < map->size; i++) {
 +		e = list_set_elem(map, i);
 +		if (e->id == IPSET_INVALID_ID)
 +			return 0;
++=======
+ 	list_for_each_entry_rcu(e, &map->members, list) {
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  		if (SET_WITH_TIMEOUT(set) &&
 -		    ip_set_timeout_expired(ext_timeout(e, set)))
 +		    ip_set_timeout_expired(ext_timeout(e, map)))
  			continue;
  		ret = ip_set_test(e->id, skb, par, opt);
  		if (ret > 0) {
@@@ -118,15 -88,11 +128,18 @@@ list_set_kadd(struct ip_set *set, cons
  {
  	struct list_set *map = set->data;
  	struct set_elem *e;
- 	u32 i;
  	int ret;
  
++<<<<<<< HEAD
 +	for (i = 0; i < map->size; i++) {
 +		e = list_set_elem(map, i);
 +		if (e->id == IPSET_INVALID_ID)
 +			return 0;
++=======
+ 	list_for_each_entry(e, &map->members, list) {
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  		if (SET_WITH_TIMEOUT(set) &&
 -		    ip_set_timeout_expired(ext_timeout(e, set)))
 +		    ip_set_timeout_expired(ext_timeout(e, map)))
  			continue;
  		ret = ip_set_add(e->id, skb, par, opt);
  		if (ret == 0)
@@@ -142,15 -108,11 +155,18 @@@ list_set_kdel(struct ip_set *set, cons
  {
  	struct list_set *map = set->data;
  	struct set_elem *e;
- 	u32 i;
  	int ret;
  
++<<<<<<< HEAD
 +	for (i = 0; i < map->size; i++) {
 +		e = list_set_elem(map, i);
 +		if (e->id == IPSET_INVALID_ID)
 +			return 0;
++=======
+ 	list_for_each_entry(e, &map->members, list) {
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  		if (SET_WITH_TIMEOUT(set) &&
 -		    ip_set_timeout_expired(ext_timeout(e, set)))
 +		    ip_set_timeout_expired(ext_timeout(e, map)))
  			continue;
  		ret = ip_set_del(e->id, skb, par, opt);
  		if (ret == 0)
@@@ -164,98 -126,66 +180,141 @@@ list_set_kadt(struct ip_set *set, cons
  	      const struct xt_action_param *par,
  	      enum ipset_adt adt, struct ip_set_adt_opt *opt)
  {
++<<<<<<< HEAD
 +	struct list_set *map = set->data;
 +	struct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, map);
++=======
+ 	struct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);
+ 	int ret = -EINVAL;
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  
+ 	rcu_read_lock();
  	switch (adt) {
  	case IPSET_TEST:
- 		return list_set_ktest(set, skb, par, opt, &ext);
+ 		ret = list_set_ktest(set, skb, par, opt, &ext);
+ 		break;
  	case IPSET_ADD:
- 		return list_set_kadd(set, skb, par, opt, &ext);
+ 		ret = list_set_kadd(set, skb, par, opt, &ext);
+ 		break;
  	case IPSET_DEL:
- 		return list_set_kdel(set, skb, par, opt, &ext);
+ 		ret = list_set_kdel(set, skb, par, opt, &ext);
+ 		break;
  	default:
  		break;
  	}
- 	return -EINVAL;
+ 	rcu_read_unlock();
+ 
+ 	return ret;
  }
  
- static bool
- id_eq(const struct ip_set *set, u32 i, ip_set_id_t id)
- {
- 	const struct list_set *map = set->data;
- 	const struct set_elem *e;
+ /* Userspace interfaces: we are protected by the nfnl mutex */
  
++<<<<<<< HEAD
 +	if (i >= map->size)
 +		return 0;
 +
 +	e = list_set_elem(map, i);
 +	return !!(e->id == id &&
 +		 !(SET_WITH_TIMEOUT(set) &&
 +		   ip_set_timeout_expired(ext_timeout(e, map))));
 +}
 +
 +static int
 +list_set_add(struct ip_set *set, u32 i, struct set_adt_elem *d,
 +	     const struct ip_set_ext *ext)
 +{
 +	struct list_set *map = set->data;
 +	struct set_elem *e = list_set_elem(map, i);
 +
 +	if (e->id != IPSET_INVALID_ID) {
 +		if (i == map->size - 1)
 +			/* Last element replaced: e.g. add new,before,last */
 +			ip_set_put_byindex(map->net, e->id);
 +		else {
 +			struct set_elem *x = list_set_elem(map, map->size - 1);
 +
 +			/* Last element pushed off */
 +			if (x->id != IPSET_INVALID_ID)
 +				ip_set_put_byindex(map->net, x->id);
 +			memmove(list_set_elem(map, i + 1), e,
 +				map->dsize * (map->size - (i + 1)));
 +		}
 +	}
 +
 +	e->id = d->id;
 +	if (SET_WITH_TIMEOUT(set))
 +		ip_set_timeout_set(ext_timeout(e, map), ext->timeout);
 +	if (SET_WITH_COUNTER(set))
 +		ip_set_init_counter(ext_counter(e, map), ext);
 +	return 0;
 +}
 +
 +static int
 +list_set_del(struct ip_set *set, u32 i)
 +{
 +	struct list_set *map = set->data;
 +	struct set_elem *e = list_set_elem(map, i);
 +
 +	ip_set_put_byindex(map->net, e->id);
 +
 +	if (i < map->size - 1)
 +		memmove(e, list_set_elem(map, i + 1),
 +			map->dsize * (map->size - (i + 1)));
 +
 +	/* Last element */
 +	e = list_set_elem(map, map->size - 1);
 +	e->id = IPSET_INVALID_ID;
 +	return 0;
++=======
+ static void
+ __list_set_del(struct ip_set *set, struct set_elem *e)
+ {
+ 	struct list_set *map = set->data;
+ 
+ 	ip_set_put_byindex(map->net, e->id);
+ 	/* We may call it, because we don't have a to be destroyed
+ 	 * extension which is used by the kernel.
+ 	 */
+ 	ip_set_ext_destroy(set, e);
+ 	kfree_rcu(e, rcu);
+ }
+ 
+ static inline void
+ list_set_del(struct ip_set *set, struct set_elem *e)
+ {
+ 	list_del_rcu(&e->list);
+ 	__list_set_del(set, e);
+ }
+ 
+ static inline void
+ list_set_replace(struct ip_set *set, struct set_elem *e, struct set_elem *old)
+ {
+ 	list_replace_rcu(&old->list, &e->list);
+ 	__list_set_del(set, old);
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  }
  
  static void
  set_cleanup_entries(struct ip_set *set)
  {
  	struct list_set *map = set->data;
++<<<<<<< HEAD
 +	struct set_elem *e;
 +	u32 i;
 +
 +	for (i = 0; i < map->size; i++) {
 +		e = list_set_elem(map, i);
 +		if (e->id != IPSET_INVALID_ID &&
 +		    ip_set_timeout_expired(ext_timeout(e, map)))
 +			list_set_del(set, i);
 +	}
++=======
+ 	struct set_elem *e, *n;
+ 
+ 	list_for_each_entry_safe(e, n, &map->members, list)
+ 		if (ip_set_timeout_expired(ext_timeout(e, set)))
+ 			list_set_del(set, e);
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  }
  
  static int
@@@ -264,26 -194,26 +323,35 @@@ list_set_utest(struct ip_set *set, voi
  {
  	struct list_set *map = set->data;
  	struct set_adt_elem *d = value;
- 	struct set_elem *e;
- 	u32 i;
+ 	struct set_elem *e, *next, *prev = NULL;
  	int ret;
  
++<<<<<<< HEAD
 +	for (i = 0; i < map->size; i++) {
 +		e = list_set_elem(map, i);
 +		if (e->id == IPSET_INVALID_ID)
 +			return 0;
 +		else if (SET_WITH_TIMEOUT(set) &&
 +			 ip_set_timeout_expired(ext_timeout(e, map)))
++=======
+ 	list_for_each_entry(e, &map->members, list) {
+ 		if (SET_WITH_TIMEOUT(set) &&
+ 		    ip_set_timeout_expired(ext_timeout(e, set)))
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  			continue;
- 		else if (e->id != d->id)
+ 		else if (e->id != d->id) {
+ 			prev = e;
  			continue;
+ 		}
  
  		if (d->before == 0)
- 			return 1;
- 		else if (d->before > 0)
- 			ret = id_eq(set, i + 1, d->refid);
- 		else
- 			ret = i > 0 && id_eq(set, i - 1, d->refid);
+ 			ret = 1;
+ 		else if (d->before > 0) {
+ 			next = list_next_entry(e, list);
+ 			ret = !list_is_last(&e->list, &map->members) &&
+ 			      next->id == d->refid;
+ 		} else
+ 			ret = prev && prev->id == d->refid;
  		return ret;
  	}
  	return 0;
@@@ -296,54 -240,78 +378,113 @@@ list_set_uadd(struct ip_set *set, void 
  {
  	struct list_set *map = set->data;
  	struct set_adt_elem *d = value;
- 	struct set_elem *e;
+ 	struct set_elem *e, *n, *prev, *next;
  	bool flag_exist = flags & IPSET_FLAG_EXIST;
- 	u32 i, ret = 0;
  
++<<<<<<< HEAD
 +	/* Check already added element */
 +	for (i = 0; i < map->size; i++) {
 +		e = list_set_elem(map, i);
 +		if (e->id == IPSET_INVALID_ID)
 +			goto insert;
 +		else if (SET_WITH_TIMEOUT(set) &&
 +			 ip_set_timeout_expired(ext_timeout(e, map)))
 +			continue;
 +		else if (e->id != d->id)
- 			continue;
++=======
+ 	if (SET_WITH_TIMEOUT(set))
+ 		set_cleanup_entries(set);
  
- 		if ((d->before > 1 && !id_eq(set, i + 1, d->refid)) ||
- 		    (d->before < 0 &&
- 		     (i == 0 || !id_eq(set, i - 1, d->refid))))
- 			/* Before/after doesn't match */
+ 	/* Find where to add the new entry */
+ 	n = prev = next = NULL;
+ 	list_for_each_entry(e, &map->members, list) {
+ 		if (SET_WITH_TIMEOUT(set) &&
+ 		    ip_set_timeout_expired(ext_timeout(e, set)))
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
+ 			continue;
+ 		else if (d->id == e->id)
+ 			n = e;
+ 		else if (d->before == 0 || e->id != d->refid)
+ 			continue;
+ 		else if (d->before > 0)
+ 			next = e;
+ 		else
+ 			prev = e;
+ 	}
+ 	/* Re-add already existing element */
+ 	if (n) {
+ 		if ((d->before > 0 && !next) ||
+ 		    (d->before < 0 && !prev))
  			return -IPSET_ERR_REF_EXIST;
  		if (!flag_exist)
- 			/* Can't re-add */
  			return -IPSET_ERR_EXIST;
  		/* Update extensions */
++<<<<<<< HEAD
 +		if (SET_WITH_TIMEOUT(set))
 +			ip_set_timeout_set(ext_timeout(e, map), ext->timeout);
 +		if (SET_WITH_COUNTER(set))
 +			ip_set_init_counter(ext_counter(e, map), ext);
++=======
+ 		ip_set_ext_destroy(set, n);
+ 		list_set_init_extensions(set, ext, n);
+ 
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  		/* Set is already added to the list */
  		ip_set_put_byindex(map->net, d->id);
  		return 0;
  	}
++<<<<<<< HEAD
 +insert:
 +	ret = -IPSET_ERR_LIST_FULL;
 +	for (i = 0; i < map->size && ret == -IPSET_ERR_LIST_FULL; i++) {
 +		e = list_set_elem(map, i);
 +		if (e->id == IPSET_INVALID_ID)
 +			ret = d->before != 0 ? -IPSET_ERR_REF_EXIST
 +				: list_set_add(set, i, d, ext);
 +		else if (e->id != d->refid)
 +			continue;
 +		else if (d->before > 0)
 +			ret = list_set_add(set, i, d, ext);
 +		else if (i + 1 < map->size)
 +			ret = list_set_add(set, i + 1, d, ext);
++=======
+ 	/* Add new entry */
+ 	if (d->before == 0) {
+ 		/* Append  */
+ 		n = list_empty(&map->members) ? NULL :
+ 		    list_last_entry(&map->members, struct set_elem, list);
+ 	} else if (d->before > 0) {
+ 		/* Insert after next element */
+ 		if (!list_is_last(&next->list, &map->members))
+ 			n = list_next_entry(next, list);
+ 	} else {
+ 		/* Insert before prev element */
+ 		if (prev->list.prev != &map->members)
+ 			n = list_prev_entry(prev, list);
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  	}
+ 	/* Can we replace a timed out entry? */
+ 	if (n &&
+ 	    !(SET_WITH_TIMEOUT(set) &&
+ 	      ip_set_timeout_expired(ext_timeout(n, set))))
+ 		n =  NULL;
+ 
+ 	e = kzalloc(set->dsize, GFP_KERNEL);
+ 	if (!e)
+ 		return -ENOMEM;
+ 	e->id = d->id;
+ 	INIT_LIST_HEAD(&e->list);
+ 	list_set_init_extensions(set, ext, e);
+ 	if (n)
+ 		list_set_replace(set, e, n);
+ 	else if (next)
+ 		list_add_tail_rcu(&e->list, &next->list);
+ 	else if (prev)
+ 		list_add_rcu(&e->list, &prev->list);
+ 	else
+ 		list_add_tail_rcu(&e->list, &map->members);
  
- 	return ret;
+ 	return 0;
  }
  
  static int
@@@ -352,32 -320,30 +493,40 @@@ list_set_udel(struct ip_set *set, void 
  {
  	struct list_set *map = set->data;
  	struct set_adt_elem *d = value;
- 	struct set_elem *e;
- 	u32 i;
+ 	struct set_elem *e, *next, *prev = NULL;
  
++<<<<<<< HEAD
 +	for (i = 0; i < map->size; i++) {
 +		e = list_set_elem(map, i);
 +		if (e->id == IPSET_INVALID_ID)
 +			return d->before != 0 ? -IPSET_ERR_REF_EXIST
 +					      : -IPSET_ERR_EXIST;
 +		else if (SET_WITH_TIMEOUT(set) &&
 +			 ip_set_timeout_expired(ext_timeout(e, map)))
++=======
+ 	list_for_each_entry(e, &map->members, list) {
+ 		if (SET_WITH_TIMEOUT(set) &&
+ 		    ip_set_timeout_expired(ext_timeout(e, set)))
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  			continue;
- 		else if (e->id != d->id)
+ 		else if (e->id != d->id) {
+ 			prev = e;
  			continue;
+ 		}
  
- 		if (d->before == 0)
- 			return list_set_del(set, i);
- 		else if (d->before > 0) {
- 			if (!id_eq(set, i + 1, d->refid))
+ 		if (d->before > 0) {
+ 			next = list_next_entry(e, list);
+ 			if (list_is_last(&e->list, &map->members) ||
+ 			    next->id != d->refid)
  				return -IPSET_ERR_REF_EXIST;
- 			return list_set_del(set, i);
- 		} else if (i == 0 || !id_eq(set, i - 1, d->refid))
- 			return -IPSET_ERR_REF_EXIST;
- 		else
- 			return list_set_del(set, i);
+ 		} else if (d->before < 0) {
+ 			if (!prev || prev->id != d->refid)
+ 				return -IPSET_ERR_REF_EXIST;
+ 		}
+ 		list_set_del(set, e);
+ 		return 0;
  	}
- 	return -IPSET_ERR_EXIST;
+ 	return d->before != 0 ? -IPSET_ERR_REF_EXIST : -IPSET_ERR_EXIST;
  }
  
  static int
@@@ -452,16 -416,10 +602,20 @@@ static voi
  list_set_flush(struct ip_set *set)
  {
  	struct list_set *map = set->data;
- 	struct set_elem *e;
- 	u32 i;
+ 	struct set_elem *e, *n;
  
++<<<<<<< HEAD
 +	for (i = 0; i < map->size; i++) {
 +		e = list_set_elem(map, i);
 +		if (e->id != IPSET_INVALID_ID) {
 +			ip_set_put_byindex(map->net, e->id);
 +			e->id = IPSET_INVALID_ID;
 +		}
 +	}
++=======
+ 	list_for_each_entry_safe(e, n, &map->members, list)
+ 		list_set_del(set, e);
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  }
  
  static void
@@@ -487,14 -456,11 +652,20 @@@ list_set_head(struct ip_set *set, struc
  	if (!nested)
  		goto nla_put_failure;
  	if (nla_put_net32(skb, IPSET_ATTR_SIZE, htonl(map->size)) ||
 -	    nla_put_net32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref - 1)) ||
 +	    (SET_WITH_TIMEOUT(set) &&
 +	     nla_put_net32(skb, IPSET_ATTR_TIMEOUT, htonl(map->timeout))) ||
 +	    (SET_WITH_COUNTER(set) &&
 +	     nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS,
 +			   htonl(IPSET_FLAG_WITH_COUNTERS))) ||
 +	    nla_put_net32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref)) ||
  	    nla_put_net32(skb, IPSET_ATTR_MEMSIZE,
++<<<<<<< HEAD
 +			  htonl(sizeof(*map) + map->size * map->dsize)))
++=======
+ 			  htonl(sizeof(*map) + n * set->dsize)))
+ 		goto nla_put_failure;
+ 	if (unlikely(ip_set_put_flags(skb, set)))
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  		goto nla_put_failure;
  	ipset_nest_end(skb, nested);
  
@@@ -509,19 -475,24 +680,37 @@@ list_set_list(const struct ip_set *set
  {
  	const struct list_set *map = set->data;
  	struct nlattr *atd, *nested;
++<<<<<<< HEAD
 +	u32 i, first = cb->args[2];
 +	const struct set_elem *e;
++=======
+ 	u32 i = 0, first = cb->args[IPSET_CB_ARG0];
+ 	struct set_elem *e;
+ 	int ret = 0;
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  
  	atd = ipset_nest_start(skb, IPSET_ATTR_ADT);
  	if (!atd)
  		return -EMSGSIZE;
++<<<<<<< HEAD
 +	for (; cb->args[2] < map->size; cb->args[2]++) {
 +		i = cb->args[2];
 +		e = list_set_elem(map, i);
 +		if (e->id == IPSET_INVALID_ID)
 +			goto finish;
++=======
+ 	list_for_each_entry(e, &map->members, list) {
+ 		if (i == first)
+ 			break;
+ 		i++;
+ 	}
+ 
+ 	rcu_read_lock();
+ 	list_for_each_entry_from(e, &map->members, list) {
+ 		i++;
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  		if (SET_WITH_TIMEOUT(set) &&
 -		    ip_set_timeout_expired(ext_timeout(e, set)))
 +		    ip_set_timeout_expired(ext_timeout(e, map)))
  			continue;
  		nested = ipset_nest_start(skb, IPSET_ATTR_DATA);
  		if (!nested) {
@@@ -544,20 -510,23 +734,33 @@@
  			goto nla_put_failure;
  		ipset_nest_end(skb, nested);
  	}
- finish:
+ 
  	ipset_nest_end(skb, atd);
  	/* Set listing finished */
++<<<<<<< HEAD
 +	cb->args[2] = 0;
 +	return 0;
++=======
+ 	cb->args[IPSET_CB_ARG0] = 0;
+ 	goto out;
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  
  nla_put_failure:
  	nla_nest_cancel(skb, nested);
  	if (unlikely(i == first)) {
++<<<<<<< HEAD
 +		cb->args[2] = 0;
 +		return -EMSGSIZE;
++=======
+ 		cb->args[IPSET_CB_ARG0] = 0;
+ 		ret = -EMSGSIZE;
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  	}
+ 	cb->args[IPSET_CB_ARG0] = i - 1;
  	ipset_nest_end(skb, atd);
- 	return 0;
+ out:
+ 	rcu_read_unlock();
+ 	return ret;
  }
  
  static bool
@@@ -592,11 -561,11 +795,11 @@@ list_set_gc(unsigned long ul_set
  	struct ip_set *set = (struct ip_set *) ul_set;
  	struct list_set *map = set->data;
  
- 	write_lock_bh(&set->lock);
+ 	spin_lock_bh(&set->lock);
  	set_cleanup_entries(set);
- 	write_unlock_bh(&set->lock);
+ 	spin_unlock_bh(&set->lock);
  
 -	map->gc.expires = jiffies + IPSET_GC_PERIOD(set->timeout) * HZ;
 +	map->gc.expires = jiffies + IPSET_GC_PERIOD(map->timeout) * HZ;
  	add_timer(&map->gc);
  }
  
@@@ -614,30 -583,21 +817,37 @@@ list_set_gc_init(struct ip_set *set, vo
  
  /* Create list:set type of sets */
  
 -static bool
 -init_list_set(struct net *net, struct ip_set *set, u32 size)
 +static struct list_set *
 +init_list_set(struct net *net, struct ip_set *set, u32 size, size_t dsize,
 +	      unsigned long timeout)
  {
  	struct list_set *map;
- 	struct set_elem *e;
- 	u32 i;
  
++<<<<<<< HEAD
 +	map = kzalloc(sizeof(*map) + size * dsize, GFP_KERNEL);
++=======
+ 	map = kzalloc(sizeof(*map), GFP_KERNEL);
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  	if (!map)
 -		return false;
 +		return NULL;
  
  	map->size = size;
 +	map->dsize = dsize;
 +	map->timeout = timeout;
  	map->net = net;
+ 	INIT_LIST_HEAD(&map->members);
  	set->data = map;
  
++<<<<<<< HEAD
 +	for (i = 0; i < size; i++) {
 +		e = list_set_elem(map, i);
 +		e->id = IPSET_INVALID_ID;
 +	}
 +
 +	return map;
++=======
+ 	return true;
++>>>>>>> 00590fdd5be0 (netfilter: ipset: Introduce RCU locking in list type)
  }
  
  static int
* Unmerged path net/netfilter/ipset/ip_set_list_set.c
