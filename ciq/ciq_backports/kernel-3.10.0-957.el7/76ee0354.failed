NFS: Check if the slot table is draining from nfs4_setup_sequence()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Anna Schumaker <Anna.Schumaker@Netapp.com>
commit 76ee03540f316948c3bc89fc76ded86c88e887a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/76ee0354.failed

	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 76ee03540f316948c3bc89fc76ded86c88e887a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4proc.c
diff --cc fs/nfs/nfs4proc.c
index 0a1efaa4e649,a74e1a4e3264..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -626,14 -629,6 +626,17 @@@ int nfs40_setup_sequence(struct nfs4_sl
  {
  	struct nfs4_slot *slot;
  
++<<<<<<< HEAD
 +	/* slot already allocated? */
 +	if (res->sr_slot != NULL)
 +		goto out_start;
 +
 +	spin_lock(&tbl->slot_tbl_lock);
 +	if (nfs4_slot_tbl_draining(tbl) && !args->sa_privileged)
 +		goto out_sleep;
 +
++=======
++>>>>>>> 76ee03540f31 (NFS: Check if the slot table is draining from nfs4_setup_sequence())
  	slot = nfs4_alloc_slot(tbl);
  	if (IS_ERR(slot)) {
  		if (slot == ERR_PTR(-ENOMEM))
@@@ -884,22 -869,8 +887,25 @@@ int nfs41_setup_sequence(struct nfs4_se
  	struct nfs4_slot_table *tbl;
  
  	dprintk("--> %s\n", __func__);
 +	/* slot already allocated? */
 +	if (res->sr_slot != NULL)
 +		goto out_success;
 +
  	tbl = &session->fc_slot_table;
  
++<<<<<<< HEAD
 +	task->tk_timeout = 0;
 +
 +	spin_lock(&tbl->slot_tbl_lock);
 +	if (test_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state) &&
 +	    !args->sa_privileged) {
 +		/* The state manager will wait until the slot table is empty */
 +		dprintk("%s session is draining\n", __func__);
 +		goto out_sleep;
 +	}
 +
++=======
++>>>>>>> 76ee03540f31 (NFS: Check if the slot table is draining from nfs4_setup_sequence())
  	slot = nfs4_alloc_slot(tbl);
  	if (IS_ERR(slot)) {
  		/* If out of memory, try again in 1/4 second */
@@@ -1015,6 -942,55 +1021,58 @@@ EXPORT_SYMBOL_GPL(nfs4_sequence_done)
  
  #endif	/* !CONFIG_NFS_V4_1 */
  
++<<<<<<< HEAD
++=======
+ int nfs4_setup_sequence(const struct nfs_client *client,
+ 			struct nfs4_sequence_args *args,
+ 			struct nfs4_sequence_res *res,
+ 			struct rpc_task *task)
+ {
+ 	struct nfs4_session *session = nfs4_get_session(client);
+ 	struct nfs4_slot_table *tbl  = client->cl_slot_tbl;
+ 	int ret;
+ 
+ 	/* slot already allocated? */
+ 	if (res->sr_slot != NULL)
+ 		goto out_start;
+ 
+ 	if (session) {
+ 		tbl = &session->fc_slot_table;
+ 		task->tk_timeout = 0;
+ 	}
+ 
+ 	spin_lock(&tbl->slot_tbl_lock);
+ 	/* The state manager will wait until the slot table is empty */
+ 	if (nfs4_slot_tbl_draining(tbl) && !args->sa_privileged)
+ 		goto out_sleep;
+ 
+ #if defined(CONFIG_NFS_V4_1)
+ 	if (session)
+ 		ret = nfs41_setup_sequence(session, args, res, task);
+ 	else
+ #endif /* CONFIG_NFS_V4_1 */
+ 		ret = nfs40_setup_sequence(client->cl_slot_tbl, args, res, task);
+ 
+ 	if (ret == -EAGAIN)
+ 		goto out_sleep;
+ 	spin_unlock(&tbl->slot_tbl_lock);
+ 
+ out_start:
+ 	rpc_call_start(task);
+ 	return 0;
+ 
+ out_sleep:
+ 	if (args->sa_privileged)
+ 		rpc_sleep_on_priority(&tbl->slot_tbl_waitq, task,
+ 				NULL, RPC_PRIORITY_PRIVILEGED);
+ 	else
+ 		rpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);
+ 	spin_unlock(&tbl->slot_tbl_lock);
+ 	return -EAGAIN;
+ }
+ EXPORT_SYMBOL_GPL(nfs4_setup_sequence);
+ 
++>>>>>>> 76ee03540f31 (NFS: Check if the slot table is draining from nfs4_setup_sequence())
  static void nfs40_call_sync_prepare(struct rpc_task *task, void *calldata)
  {
  	struct nfs4_call_sync_data *data = calldata;
* Unmerged path fs/nfs/nfs4proc.c
