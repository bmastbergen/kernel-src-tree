netfilter: ipset: Add element count to all set types header

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 702b71e7c666a1c9be9d49e8cd173f0d4d1e859f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/702b71e7.failed

It is better to list the set elements for all set types, thus the
header information is uniform. Element counts are therefore added
to the bitmap and list types.

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 702b71e7c666a1c9be9d49e8cd173f0d4d1e859f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/ipset/ip_set.h
#	net/netfilter/ipset/ip_set_bitmap_gen.h
#	net/netfilter/ipset/ip_set_hash_gen.h
#	net/netfilter/ipset/ip_set_list_set.c
diff --cc include/linux/netfilter/ipset/ip_set.h
index 3e9c90cf5227,4671d740610f..000000000000
--- a/include/linux/netfilter/ipset/ip_set.h
+++ b/include/linux/netfilter/ipset/ip_set.h
@@@ -186,6 -246,16 +186,19 @@@ struct ip_set 
  	u8 revision;
  	/* Extensions */
  	u8 extensions;
++<<<<<<< HEAD
++=======
+ 	/* Create flags */
+ 	u8 flags;
+ 	/* Default timeout value, if enabled */
+ 	u32 timeout;
+ 	/* Number of elements (vs timeout) */
+ 	u32 elements;
+ 	/* Element data size */
+ 	size_t dsize;
+ 	/* Offsets to extensions in elements */
+ 	size_t offset[IPSET_EXT_ID_MAX];
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  	/* The type specific data */
  	void *data;
  };
diff --cc net/netfilter/ipset/ip_set_bitmap_gen.h
index 01a340ce9e94,1810d1c06e3d..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_gen.h
+++ b/net/netfilter/ipset/ip_set_bitmap_gen.h
@@@ -71,9 -80,20 +71,10 @@@ mtype_flush(struct ip_set *set
  {
  	struct mtype *map = set->data;
  
 -	if (set->extensions & IPSET_EXT_DESTROY)
 -		mtype_ext_cleanup(set);
  	memset(map->members, 0, map->memsize);
+ 	set->elements = 0;
  }
  
 -/* Calculate the actual memory size of the set data */
 -static size_t
 -mtype_memsize(const struct mtype *map, size_t dsize)
 -{
 -	return sizeof(*map) + map->memsize +
 -	       map->elements * dsize;
 -}
 -
  static int
  mtype_head(struct ip_set *set, struct sk_buff *skb)
  {
@@@ -85,15 -106,10 +86,22 @@@
  		goto nla_put_failure;
  	if (mtype_do_head(skb, map) ||
  	    nla_put_net32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref)) ||
++<<<<<<< HEAD
 +	    nla_put_net32(skb, IPSET_ATTR_MEMSIZE,
 +			  htonl(sizeof(*map) +
 +				map->memsize +
 +				map->dsize * map->elements)) ||
 +	    (SET_WITH_TIMEOUT(set) &&
 +	     nla_put_net32(skb, IPSET_ATTR_TIMEOUT, htonl(map->timeout))) ||
 +	    (SET_WITH_COUNTER(set) &&
 +	     nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS,
 +			   htonl(IPSET_FLAG_WITH_COUNTERS))))
++=======
+ 	    nla_put_net32(skb, IPSET_ATTR_MEMSIZE, htonl(memsize)) ||
+ 	    nla_put_net32(skb, IPSET_ATTR_ELEMENTS, htonl(set->elements)))
+ 		goto nla_put_failure;
+ 	if (unlikely(ip_set_put_flags(skb, set)))
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  		goto nla_put_failure;
  	ipset_nest_end(skb, nested);
  
@@@ -132,11 -150,18 +140,18 @@@ mtype_add(struct ip_set *set, void *val
  
  	if (ret == IPSET_ADD_FAILED) {
  		if (SET_WITH_TIMEOUT(set) &&
++<<<<<<< HEAD
 +		    ip_set_timeout_expired(ext_timeout(x, map)))
++=======
+ 		    ip_set_timeout_expired(ext_timeout(x, set))) {
+ 			set->elements--;
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  			ret = 0;
 -		} else if (!(flags & IPSET_FLAG_EXIST)) {
 -			set_bit(e->id, map->members);
 +		else if (!(flags & IPSET_FLAG_EXIST))
  			return -IPSET_ERR_EXIST;
 -		}
 -		/* Element is re-added, cleanup extensions */
 -		ip_set_ext_destroy(set, x);
  	}
+ 	if (ret > 0)
+ 		set->elements--;
  
  	if (SET_WITH_TIMEOUT(set))
  #ifdef IP_SET_BITMAP_STORED_TIMEOUT
@@@ -146,7 -171,16 +161,20 @@@
  #endif
  
  	if (SET_WITH_COUNTER(set))
++<<<<<<< HEAD
 +		ip_set_init_counter(ext_counter(x, map), ext);
++=======
+ 		ip_set_init_counter(ext_counter(x, set), ext);
+ 	if (SET_WITH_COMMENT(set))
+ 		ip_set_init_comment(ext_comment(x, set), ext);
+ 	if (SET_WITH_SKBINFO(set))
+ 		ip_set_init_skbinfo(ext_skbinfo(x, set), ext);
+ 
+ 	/* Activate element */
+ 	set_bit(e->id, map->members);
+ 	set->elements++;
+ 
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  	return 0;
  }
  
@@@ -156,11 -190,15 +184,21 @@@ mtype_del(struct ip_set *set, void *val
  {
  	struct mtype *map = set->data;
  	const struct mtype_adt_elem *e = value;
 -	void *x = get_ext(set, map, e->id);
 +	const void *x = get_ext(map, e->id);
  
++<<<<<<< HEAD
 +	if (mtype_do_del(e, map) ||
 +	    (SET_WITH_TIMEOUT(set) &&
 +	     ip_set_timeout_expired(ext_timeout(x, map))))
++=======
+ 	if (mtype_do_del(e, map))
+ 		return -IPSET_ERR_EXIST;
+ 
+ 	ip_set_ext_destroy(set, x);
+ 	set->elements--;
+ 	if (SET_WITH_TIMEOUT(set) &&
+ 	    ip_set_timeout_expired(ext_timeout(x, set)))
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  		return -IPSET_ERR_EXIST;
  
  	return 0;
@@@ -242,17 -283,21 +280,23 @@@ mtype_gc(unsigned long ul_set
  	u32 id;
  
  	/* We run parallel with other readers (test element)
 -	 * but adding/deleting new entries is locked out
 -	 */
 -	spin_lock_bh(&set->lock);
 +	 * but adding/deleting new entries is locked out */
 +	read_lock_bh(&set->lock);
  	for (id = 0; id < map->elements; id++)
 -		if (mtype_gc_test(id, map, set->dsize)) {
 -			x = get_ext(set, map, id);
 -			if (ip_set_timeout_expired(ext_timeout(x, set))) {
 +		if (mtype_gc_test(id, map)) {
 +			x = get_ext(map, id);
 +			if (ip_set_timeout_expired(ext_timeout(x, map)))
  				clear_bit(id, map->members);
++<<<<<<< HEAD
++=======
+ 				ip_set_ext_destroy(set, x);
+ 				set->elements--;
+ 			}
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  		}
 -	spin_unlock_bh(&set->lock);
 +	read_unlock_bh(&set->lock);
  
 -	map->gc.expires = jiffies + IPSET_GC_PERIOD(set->timeout) * HZ;
 +	map->gc.expires = jiffies + IPSET_GC_PERIOD(map->timeout) * HZ;
  	add_timer(&map->gc);
  }
  
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 9ce28af662bf,6e967f198d1e..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -267,13 -273,12 +267,12 @@@ hbucket_elem_add(struct hbucket *n, u8 
  
  /* The generic hash structure */
  struct htype {
 -	struct htable __rcu *table; /* the hash table */
 +	struct htable *table;	/* the hash table */
  	u32 maxelem;		/* max elements in the hash */
- 	u32 elements;		/* current element (vs timeout) */
  	u32 initval;		/* random jhash init value */
 -#ifdef IP_SET_HASH_WITH_MARKMASK
 -	u32 markmask;		/* markmask value for mark mask to store */
 -#endif
 +	u32 timeout;		/* timeout value, if enabled */
 +	size_t dsize;		/* data struct size */
 +	size_t offset[IPSET_EXT_ID_MAX]; /* Offsets to extensions */
  	struct timer_list gc;	/* garbage collection when timeout enabled */
  	struct mtype_elem next; /* temporary storage for uadd */
  #ifdef IP_SET_HASH_WITH_MULTI
@@@ -371,21 -385,43 +370,21 @@@ mtype_flush(struct ip_set *set
  	struct hbucket *n;
  	u32 i;
  
 -	t = ipset_dereference_protected(h->table, set);
  	for (i = 0; i < jhash_size(t->htable_bits); i++) {
 -		n = __ipset_dereference_protected(hbucket(t, i), 1);
 -		if (!n)
 -			continue;
 -		if (set->extensions & IPSET_EXT_DESTROY)
 -			mtype_ext_cleanup(set, n);
 -		/* FIXME: use slab cache */
 -		rcu_assign_pointer(hbucket(t, i), NULL);
 -		kfree_rcu(n, rcu);
 +		n = hbucket(t, i);
 +		if (n->size) {
 +			n->size = n->pos = 0;
 +			/* FIXME: use slab cache */
 +			kfree(n->value);
 +		}
  	}
  #ifdef IP_SET_HASH_WITH_NETS
 -	memset(h->nets, 0, sizeof(struct net_prefixes) * NLEN(set->family));
 +	memset(h->nets, 0, sizeof(struct net_prefixes)
 +			   * NETS_LENGTH(set->family));
  #endif
- 	h->elements = 0;
+ 	set->elements = 0;
  }
  
 -/* Destroy the hashtable part of the set */
 -static void
 -mtype_ahash_destroy(struct ip_set *set, struct htable *t, bool ext_destroy)
 -{
 -	struct hbucket *n;
 -	u32 i;
 -
 -	for (i = 0; i < jhash_size(t->htable_bits); i++) {
 -		n = __ipset_dereference_protected(hbucket(t, i), 1);
 -		if (!n)
 -			continue;
 -		if (set->extensions & IPSET_EXT_DESTROY && ext_destroy)
 -			mtype_ext_cleanup(set, n);
 -		/* FIXME: use slab cache */
 -		kfree(n);
 -	}
 -
 -	ip_set_free(t);
 -}
 -
  /* Destroy a hash type of set */
  static void
  mtype_destroy(struct ip_set *set)
@@@ -433,43 -470,54 +432,49 @@@ mtype_same_set(const struct ip_set *a, 
  	       a->extensions == b->extensions;
  }
  
 +/* Get the ith element from the array block n */
 +#define ahash_data(n, i, dsize)	\
 +	((struct mtype_elem *)((n)->value + ((i) * (dsize))))
 +
  /* Delete expired elements from the hashtable */
  static void
 -mtype_expire(struct ip_set *set, struct htype *h, u8 nets_length, size_t dsize)
 +mtype_expire(struct htype *h, u8 nets_length, size_t dsize)
  {
 -	struct htable *t;
 -	struct hbucket *n, *tmp;
 +	struct htable *t = h->table;
 +	struct hbucket *n;
  	struct mtype_elem *data;
 -	u32 i, j, d;
 -#ifdef IP_SET_HASH_WITH_NETS
 -	u8 k;
 -#endif
 +	u32 i;
 +	int j;
  
 -	t = ipset_dereference_protected(h->table, set);
  	for (i = 0; i < jhash_size(t->htable_bits); i++) {
 -		n = __ipset_dereference_protected(hbucket(t, i), 1);
 -		if (!n)
 -			continue;
 -		for (j = 0, d = 0; j < n->pos; j++) {
 -			if (!test_bit(j, n->used)) {
 -				d++;
 -				continue;
 -			}
 +		n = hbucket(t, i);
 +		for (j = 0; j < n->pos; j++) {
  			data = ahash_data(n, j, dsize);
 -			if (ip_set_timeout_expired(ext_timeout(data, set))) {
 +			if (ip_set_timeout_expired(ext_timeout(data, h))) {
  				pr_debug("expired %u/%u\n", i, j);
 -				clear_bit(j, n->used);
 -				smp_mb__after_atomic();
  #ifdef IP_SET_HASH_WITH_NETS
 -				for (k = 0; k < IPSET_NET_COUNT; k++)
 -					mtype_del_cidr(h,
 -						NCIDR_PUT(DCIDR_GET(data->cidr,
 -								    k)),
 -						nets_length, k);
 +				mtype_del_cidr(h, CIDR(data->cidr),
 +					       nets_length);
  #endif
++<<<<<<< HEAD
 +				if (j != n->pos - 1)
 +					/* Not last one */
 +					memcpy(data,
 +					       ahash_data(n, n->pos - 1, dsize),
 +					       dsize);
 +				n->pos--;
 +				h->elements--;
++=======
+ 				ip_set_ext_destroy(set, data);
+ 				set->elements--;
+ 				d++;
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  			}
  		}
 -		if (d >= AHASH_INIT_SIZE) {
 -			if (d >= n->size) {
 -				rcu_assign_pointer(hbucket(t, i), NULL);
 -				kfree_rcu(n, rcu);
 -				continue;
 -			}
 -			tmp = kzalloc(sizeof(*tmp) +
 -				      (n->size - AHASH_INIT_SIZE) * dsize,
 -				      GFP_ATOMIC);
 +		if (n->pos + AHASH_INIT_SIZE < n->size) {
 +			void *tmp = kzalloc((n->size - AHASH_INIT_SIZE)
 +					    * dsize,
 +					    GFP_ATOMIC);
  			if (!tmp)
  				/* Still try to delete expired elements */
  				continue;
@@@ -594,29 -708,50 +599,59 @@@ mtype_add(struct ip_set *set, void *val
  	struct htable *t;
  	const struct mtype_elem *d = value;
  	struct mtype_elem *data;
 -	struct hbucket *n, *old = ERR_PTR(-ENOENT);
 -	int i, j = -1;
 +	struct hbucket *n;
 +	int i, ret = 0;
 +	int j = AHASH_MAX(h) + 1;
  	bool flag_exist = flags & IPSET_FLAG_EXIST;
 -	bool deleted = false, forceadd = false, reuse = false;
  	u32 key, multi = 0;
  
++<<<<<<< HEAD
 +	if (SET_WITH_TIMEOUT(set) && h->elements >= h->maxelem)
 +		/* FIXME: when set is full, we slow down here */
 +		mtype_expire(h, NETS_LENGTH(set->family), h->dsize);
 +
 +	if (h->elements >= h->maxelem) {
 +		if (net_ratelimit())
 +			pr_warning("Set %s is full, maxelem %u reached\n",
 +				   set->name, h->maxelem);
 +		return -IPSET_ERR_HASH_FULL;
++=======
+ 	if (set->elements >= h->maxelem) {
+ 		if (SET_WITH_TIMEOUT(set))
+ 			/* FIXME: when set is full, we slow down here */
+ 			mtype_expire(set, h, NLEN(set->family), set->dsize);
+ 		if (set->elements >= h->maxelem && SET_WITH_FORCEADD(set))
+ 			forceadd = true;
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  	}
  
 -	t = ipset_dereference_protected(h->table, set);
 +	rcu_read_lock_bh();
 +	t = rcu_dereference_bh(h->table);
  	key = HKEY(value, h->initval, t->htable_bits);
++<<<<<<< HEAD
 +	n = hbucket(t, key);
++=======
+ 	n = __ipset_dereference_protected(hbucket(t, key), 1);
+ 	if (!n) {
+ 		if (forceadd) {
+ 			if (net_ratelimit())
+ 				pr_warn("Set %s is full, maxelem %u reached\n",
+ 					set->name, h->maxelem);
+ 			return -IPSET_ERR_HASH_FULL;
+ 		} else if (set->elements >= h->maxelem) {
+ 			goto set_full;
+ 		}
+ 		old = NULL;
+ 		n = kzalloc(sizeof(*n) + AHASH_INIT_SIZE * set->dsize,
+ 			    GFP_ATOMIC);
+ 		if (!n)
+ 			return -ENOMEM;
+ 		n->size = AHASH_INIT_SIZE;
+ 		goto copy_elem;
+ 	}
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  	for (i = 0; i < n->pos; i++) {
 -		if (!test_bit(i, n->used)) {
 -			/* Reuse first deleted entry */
 -			if (j == -1) {
 -				deleted = reuse = true;
 -				j = i;
 -			}
 -			continue;
 -		}
 -		data = ahash_data(n, i, set->dsize);
 +		data = ahash_data(n, i, h->dsize);
  		if (mtype_data_equal(data, d, &multi)) {
  			if (flag_exist ||
  			    (SET_WITH_TIMEOUT(set) &&
@@@ -631,34 -763,60 +666,65 @@@
  		}
  		/* Reuse first timed out entry */
  		if (SET_WITH_TIMEOUT(set) &&
 -		    ip_set_timeout_expired(ext_timeout(data, set)) &&
 -		    j == -1) {
 +		    ip_set_timeout_expired(ext_timeout(data, h)) &&
 +		    j != AHASH_MAX(h) + 1)
  			j = i;
 -			reuse = true;
 -		}
  	}
 -	if (reuse || forceadd) {
 -		data = ahash_data(n, j, set->dsize);
 -		if (!deleted) {
 +reuse_slot:
 +	if (j != AHASH_MAX(h) + 1) {
 +		/* Fill out reused slot */
 +		data = ahash_data(n, j, h->dsize);
  #ifdef IP_SET_HASH_WITH_NETS
 -			for (i = 0; i < IPSET_NET_COUNT; i++)
 -				mtype_del_cidr(h,
 -					NCIDR_PUT(DCIDR_GET(data->cidr, i)),
 -					NLEN(set->family), i);
 +		mtype_del_cidr(h, CIDR(data->cidr), NETS_LENGTH(set->family));
 +		mtype_add_cidr(h, CIDR(d->cidr), NETS_LENGTH(set->family));
  #endif
++<<<<<<< HEAD
 +	} else {
 +		/* Use/create a new slot */
++=======
+ 			ip_set_ext_destroy(set, data);
+ 			set->elements--;
+ 		}
+ 		goto copy_data;
+ 	}
+ 	if (set->elements >= h->maxelem)
+ 		goto set_full;
+ 	/* Create a new slot */
+ 	if (n->pos >= n->size) {
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  		TUNE_AHASH_MAX(h, multi);
 -		if (n->size >= AHASH_MAX(h)) {
 -			/* Trigger rehashing */
 -			mtype_data_next(&h->next, d);
 -			return -EAGAIN;
 +		ret = hbucket_elem_add(n, AHASH_MAX(h), h->dsize);
 +		if (ret != 0) {
 +			if (ret == -EAGAIN)
 +				mtype_data_next(&h->next, d);
 +			goto out;
  		}
++<<<<<<< HEAD
 +		data = ahash_data(n, n->pos++, h->dsize);
++=======
+ 		old = n;
+ 		n = kzalloc(sizeof(*n) +
+ 			    (old->size + AHASH_INIT_SIZE) * set->dsize,
+ 			    GFP_ATOMIC);
+ 		if (!n)
+ 			return -ENOMEM;
+ 		memcpy(n, old, sizeof(struct hbucket) +
+ 		       old->size * set->dsize);
+ 		n->size = old->size + AHASH_INIT_SIZE;
+ 	}
+ 
+ copy_elem:
+ 	j = n->pos++;
+ 	data = ahash_data(n, j, set->dsize);
+ copy_data:
+ 	set->elements++;
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  #ifdef IP_SET_HASH_WITH_NETS
 -	for (i = 0; i < IPSET_NET_COUNT; i++)
 -		mtype_add_cidr(h, NCIDR_PUT(DCIDR_GET(d->cidr, i)),
 -			       NLEN(set->family), i);
 +		mtype_add_cidr(h, CIDR(d->cidr), NETS_LENGTH(set->family));
  #endif
 +		h->elements++;
 +	}
  	memcpy(data, d, sizeof(struct mtype_elem));
 -overwrite_extensions:
  #ifdef IP_SET_HASH_WITH_NETS
  	mtype_data_set_flags(data, flags);
  #endif
@@@ -694,33 -874,53 +760,42 @@@ mtype_del(struct ip_set *set, void *val
  		if (!mtype_data_equal(data, d, &multi))
  			continue;
  		if (SET_WITH_TIMEOUT(set) &&
 -		    ip_set_timeout_expired(ext_timeout(data, set)))
 -			goto out;
 -
 +		    ip_set_timeout_expired(ext_timeout(data, h)))
 +			return -IPSET_ERR_EXIST;
 +		if (i != n->pos - 1)
 +			/* Not last one */
 +			memcpy(data, ahash_data(n, n->pos - 1, h->dsize),
 +			       h->dsize);
 +
++<<<<<<< HEAD
 +		n->pos--;
 +		h->elements--;
++=======
+ 		ret = 0;
+ 		clear_bit(i, n->used);
+ 		smp_mb__after_atomic();
+ 		if (i + 1 == n->pos)
+ 			n->pos--;
+ 		set->elements--;
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  #ifdef IP_SET_HASH_WITH_NETS
 -		for (j = 0; j < IPSET_NET_COUNT; j++)
 -			mtype_del_cidr(h, NCIDR_PUT(DCIDR_GET(d->cidr, j)),
 -				       NLEN(set->family), j);
 +		mtype_del_cidr(h, CIDR(d->cidr), NETS_LENGTH(set->family));
  #endif
 -		ip_set_ext_destroy(set, data);
 -
 -		for (; i < n->pos; i++) {
 -			if (!test_bit(i, n->used))
 -				k++;
 -		}
 -		if (n->pos == 0 && k == 0) {
 -			rcu_assign_pointer(hbucket(t, key), NULL);
 -			kfree_rcu(n, rcu);
 -		} else if (k >= AHASH_INIT_SIZE) {
 -			struct hbucket *tmp = kzalloc(sizeof(*tmp) +
 -					(n->size - AHASH_INIT_SIZE) * dsize,
 -					GFP_ATOMIC);
 +		if (n->pos + AHASH_INIT_SIZE < n->size) {
 +			void *tmp = kzalloc((n->size - AHASH_INIT_SIZE)
 +					    * h->dsize,
 +					    GFP_ATOMIC);
  			if (!tmp)
 -				goto out;
 -			tmp->size = n->size - AHASH_INIT_SIZE;
 -			for (j = 0, k = 0; j < n->pos; j++) {
 -				if (!test_bit(j, n->used))
 -					continue;
 -				data = ahash_data(n, j, dsize);
 -				memcpy(tmp->value + k * dsize, data, dsize);
 -				set_bit(j, tmp->used);
 -				k++;
 -			}
 -			tmp->pos = k;
 -			rcu_assign_pointer(hbucket(t, key), tmp);
 -			kfree_rcu(n, rcu);
 +				return 0;
 +			n->size -= AHASH_INIT_SIZE;
 +			memcpy(tmp, n->value, n->size * h->dsize);
 +			kfree(n->value);
 +			n->value = tmp;
  		}
 -		goto out;
 +		return 0;
  	}
  
 -out:
 -	return ret;
 +	return -IPSET_ERR_EXIST;
  }
  
  static inline int
@@@ -835,11 -1079,13 +910,17 @@@ mtype_head(struct ip_set *set, struct s
  #endif
  	if (nla_put_net32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref)) ||
  	    nla_put_net32(skb, IPSET_ATTR_MEMSIZE, htonl(memsize)) ||
++<<<<<<< HEAD
 +	    ((set->extensions & IPSET_EXT_TIMEOUT) &&
 +	     nla_put_net32(skb, IPSET_ATTR_TIMEOUT, htonl(h->timeout))) ||
 +	    ((set->extensions & IPSET_EXT_COUNTER) &&
 +	     nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS,
 +			   htonl(IPSET_FLAG_WITH_COUNTERS))))
++=======
+ 	    nla_put_net32(skb, IPSET_ATTR_ELEMENTS, htonl(set->elements)))
+ 		goto nla_put_failure;
+ 	if (unlikely(ip_set_put_flags(skb, set)))
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  		goto nla_put_failure;
  	ipset_nest_end(skb, nested);
  
diff --cc net/netfilter/ipset/ip_set_list_set.c
index a9a97c07ecb4,c45516695934..000000000000
--- a/net/netfilter/ipset/ip_set_list_set.c
+++ b/net/netfilter/ipset/ip_set_list_set.c
@@@ -177,70 -144,38 +177,80 @@@ list_set_kadt(struct ip_set *set, cons
  	default:
  		break;
  	}
 -	rcu_read_unlock();
 +	return -EINVAL;
 +}
  
 -	return ret;
 +static bool
 +id_eq(const struct ip_set *set, u32 i, ip_set_id_t id)
 +{
 +	const struct list_set *map = set->data;
 +	const struct set_elem *e;
 +
 +	if (i >= map->size)
 +		return 0;
 +
 +	e = list_set_elem(map, i);
 +	return !!(e->id == id &&
 +		 !(SET_WITH_TIMEOUT(set) &&
 +		   ip_set_timeout_expired(ext_timeout(e, map))));
  }
  
 -/* Userspace interfaces: we are protected by the nfnl mutex */
 +static int
 +list_set_add(struct ip_set *set, u32 i, struct set_adt_elem *d,
 +	     const struct ip_set_ext *ext)
 +{
 +	struct list_set *map = set->data;
 +	struct set_elem *e = list_set_elem(map, i);
 +
 +	if (e->id != IPSET_INVALID_ID) {
 +		if (i == map->size - 1)
 +			/* Last element replaced: e.g. add new,before,last */
 +			ip_set_put_byindex(map->net, e->id);
 +		else {
 +			struct set_elem *x = list_set_elem(map, map->size - 1);
 +
 +			/* Last element pushed off */
 +			if (x->id != IPSET_INVALID_ID)
 +				ip_set_put_byindex(map->net, x->id);
 +			memmove(list_set_elem(map, i + 1), e,
 +				map->dsize * (map->size - (i + 1)));
 +		}
 +	}
  
 -static void
 -__list_set_del_rcu(struct rcu_head * rcu)
 +	e->id = d->id;
 +	if (SET_WITH_TIMEOUT(set))
 +		ip_set_timeout_set(ext_timeout(e, map), ext->timeout);
 +	if (SET_WITH_COUNTER(set))
 +		ip_set_init_counter(ext_counter(e, map), ext);
 +	return 0;
 +}
 +
 +static int
 +list_set_del(struct ip_set *set, u32 i)
  {
 -	struct set_elem *e = container_of(rcu, struct set_elem, rcu);
 -	struct ip_set *set = e->set;
  	struct list_set *map = set->data;
 +	struct set_elem *e = list_set_elem(map, i);
  
  	ip_set_put_byindex(map->net, e->id);
 -	ip_set_ext_destroy(set, e);
 -	kfree(e);
 -}
  
++<<<<<<< HEAD
 +	if (i < map->size - 1)
 +		memmove(e, list_set_elem(map, i + 1),
 +			map->dsize * (map->size - (i + 1)));
++=======
+ static inline void
+ list_set_del(struct ip_set *set, struct set_elem *e)
+ {
+ 	set->elements--;
+ 	list_del_rcu(&e->list);
+ 	call_rcu(&e->rcu, __list_set_del_rcu);
+ }
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  
 -static inline void
 -list_set_replace(struct set_elem *e, struct set_elem *old)
 -{
 -	list_replace_rcu(&old->list, &e->list);
 -	call_rcu(&old->rcu, __list_set_del_rcu);
 +	/* Last element */
 +	e = list_set_elem(map, map->size - 1);
 +	e->id = IPSET_INVALID_ID;
 +	return 0;
  }
  
  static void
@@@ -328,22 -275,44 +338,43 @@@ list_set_uadd(struct ip_set *set, void 
  		ip_set_put_byindex(map->net, d->id);
  		return 0;
  	}
 -	/* Add new entry */
 -	if (d->before == 0) {
 -		/* Append  */
 -		n = list_empty(&map->members) ? NULL :
 -		    list_last_entry(&map->members, struct set_elem, list);
 -	} else if (d->before > 0) {
 -		/* Insert after next element */
 -		if (!list_is_last(&next->list, &map->members))
 -			n = list_next_entry(next, list);
 -	} else {
 -		/* Insert before prev element */
 -		if (prev->list.prev != &map->members)
 -			n = list_prev_entry(prev, list);
 +insert:
 +	ret = -IPSET_ERR_LIST_FULL;
 +	for (i = 0; i < map->size && ret == -IPSET_ERR_LIST_FULL; i++) {
 +		e = list_set_elem(map, i);
 +		if (e->id == IPSET_INVALID_ID)
 +			ret = d->before != 0 ? -IPSET_ERR_REF_EXIST
 +				: list_set_add(set, i, d, ext);
 +		else if (e->id != d->refid)
 +			continue;
 +		else if (d->before > 0)
 +			ret = list_set_add(set, i, d, ext);
 +		else if (i + 1 < map->size)
 +			ret = list_set_add(set, i + 1, d, ext);
  	}
 -	/* Can we replace a timed out entry? */
 -	if (n &&
 -	    !(SET_WITH_TIMEOUT(set) &&
 -	      ip_set_timeout_expired(ext_timeout(n, set))))
 -		n =  NULL;
  
++<<<<<<< HEAD
 +	return ret;
++=======
+ 	e = kzalloc(set->dsize, GFP_ATOMIC);
+ 	if (!e)
+ 		return -ENOMEM;
+ 	e->id = d->id;
+ 	e->set = set;
+ 	INIT_LIST_HEAD(&e->list);
+ 	list_set_init_extensions(set, ext, e);
+ 	if (n)
+ 		list_set_replace(e, n);
+ 	else if (next)
+ 		list_add_tail_rcu(&e->list, &next->list);
+ 	else if (prev)
+ 		list_add_rcu(&e->list, &prev->list);
+ 	else
+ 		list_add_tail_rcu(&e->list, &map->members);
+ 	set->elements++;
+ 
+ 	return 0;
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  }
  
  static int
@@@ -452,16 -417,11 +483,22 @@@ static voi
  list_set_flush(struct ip_set *set)
  {
  	struct list_set *map = set->data;
 -	struct set_elem *e, *n;
 -
 +	struct set_elem *e;
 +	u32 i;
 +
++<<<<<<< HEAD
 +	for (i = 0; i < map->size; i++) {
 +		e = list_set_elem(map, i);
 +		if (e->id != IPSET_INVALID_ID) {
 +			ip_set_put_byindex(map->net, e->id);
 +			e->id = IPSET_INVALID_ID;
 +		}
 +	}
++=======
+ 	list_for_each_entry_safe(e, n, &map->members, list)
+ 		list_set_del(set, e);
+ 	set->elements = 0;
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  }
  
  static void
@@@ -487,14 -473,11 +524,21 @@@ list_set_head(struct ip_set *set, struc
  	if (!nested)
  		goto nla_put_failure;
  	if (nla_put_net32(skb, IPSET_ATTR_SIZE, htonl(map->size)) ||
 +	    (SET_WITH_TIMEOUT(set) &&
 +	     nla_put_net32(skb, IPSET_ATTR_TIMEOUT, htonl(map->timeout))) ||
 +	    (SET_WITH_COUNTER(set) &&
 +	     nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS,
 +			   htonl(IPSET_FLAG_WITH_COUNTERS))) ||
  	    nla_put_net32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref)) ||
++<<<<<<< HEAD
 +	    nla_put_net32(skb, IPSET_ATTR_MEMSIZE,
 +			  htonl(sizeof(*map) + map->size * map->dsize)))
++=======
+ 	    nla_put_net32(skb, IPSET_ATTR_MEMSIZE, htonl(memsize)) ||
+ 	    nla_put_net32(skb, IPSET_ATTR_ELEMENTS, htonl(set->elements)))
+ 		goto nla_put_failure;
+ 	if (unlikely(ip_set_put_flags(skb, set)))
++>>>>>>> 702b71e7c666 (netfilter: ipset: Add element count to all set types header)
  		goto nla_put_failure;
  	ipset_nest_end(skb, nested);
  
* Unmerged path include/linux/netfilter/ipset/ip_set.h
diff --git a/include/linux/netfilter/ipset/ip_set_bitmap.h b/include/linux/netfilter/ipset/ip_set_bitmap.h
index 5e4662a71e01..366d6c0ea04f 100644
--- a/include/linux/netfilter/ipset/ip_set_bitmap.h
+++ b/include/linux/netfilter/ipset/ip_set_bitmap.h
@@ -6,8 +6,8 @@
 #define IPSET_BITMAP_MAX_RANGE	0x0000FFFF
 
 enum {
+	IPSET_ADD_STORE_PLAIN_TIMEOUT = -1,
 	IPSET_ADD_FAILED = 1,
-	IPSET_ADD_STORE_PLAIN_TIMEOUT,
 	IPSET_ADD_START_STORED_TIMEOUT,
 };
 
* Unmerged path net/netfilter/ipset/ip_set_bitmap_gen.h
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
* Unmerged path net/netfilter/ipset/ip_set_list_set.c
