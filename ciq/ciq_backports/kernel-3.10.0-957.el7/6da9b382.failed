iio: buffer: refactor buffer attributes setup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iio] buffer: refactor buffer attributes setup (Tony Camuso) [1559170]
Rebuild_FUZZ: 94.12%
commit-author Octavian Purdila <octavian.purdila@intel.com>
commit 6da9b382bd2b6e1b910d7e3512a8a115c8c5f113
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6da9b382.failed

Move all core (non-custom) buffer attributes to a vector to make it
easier to add more of them in the future.

	Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit 6da9b382bd2b6e1b910d7e3512a8a115c8c5f113)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iio/industrialio-buffer.c
diff --cc drivers/iio/industrialio-buffer.c
index ed6b8aa675ce,c2d5440aa226..000000000000
--- a/drivers/iio/industrialio-buffer.c
+++ b/drivers/iio/industrialio-buffer.c
@@@ -837,7 -751,137 +837,141 @@@ done
  	mutex_unlock(&indio_dev->mlock);
  	return (ret < 0) ? ret : len;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(iio_buffer_store_enable);
++=======
+ 
+ static const char * const iio_scan_elements_group_name = "scan_elements";
+ 
+ static DEVICE_ATTR(length, S_IRUGO | S_IWUSR, iio_buffer_read_length,
+ 		   iio_buffer_write_length);
+ static struct device_attribute dev_attr_length_ro = __ATTR(length,
+ 	S_IRUGO, iio_buffer_read_length, NULL);
+ static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR,
+ 		   iio_buffer_show_enable, iio_buffer_store_enable);
+ 
+ static struct attribute *iio_buffer_attrs[] = {
+ 	&dev_attr_length.attr,
+ 	&dev_attr_enable.attr,
+ };
+ 
+ int iio_buffer_alloc_sysfs_and_mask(struct iio_dev *indio_dev)
+ {
+ 	struct iio_dev_attr *p;
+ 	struct attribute **attr;
+ 	struct iio_buffer *buffer = indio_dev->buffer;
+ 	int ret, i, attrn, attrcount, attrcount_orig = 0;
+ 	const struct iio_chan_spec *channels;
+ 
+ 	if (!buffer)
+ 		return 0;
+ 
+ 	attrcount = 0;
+ 	if (buffer->attrs) {
+ 		while (buffer->attrs[attrcount] != NULL)
+ 			attrcount++;
+ 	}
+ 
+ 	attr = kcalloc(attrcount + ARRAY_SIZE(iio_buffer_attrs) + 1,
+ 		       sizeof(struct attribute *), GFP_KERNEL);
+ 	if (!attr)
+ 		return -ENOMEM;
+ 
+ 	memcpy(attr, iio_buffer_attrs, sizeof(iio_buffer_attrs));
+ 	if (!buffer->access->set_length)
+ 		attr[0] = &dev_attr_length_ro.attr;
+ 
+ 	if (buffer->attrs)
+ 		memcpy(&attr[ARRAY_SIZE(iio_buffer_attrs)], buffer->attrs,
+ 		       sizeof(struct attribute *) * attrcount);
+ 
+ 	attr[attrcount + ARRAY_SIZE(iio_buffer_attrs)] = NULL;
+ 
+ 	buffer->buffer_group.name = "buffer";
+ 	buffer->buffer_group.attrs = attr;
+ 
+ 	indio_dev->groups[indio_dev->groupcounter++] = &buffer->buffer_group;
+ 
+ 	if (buffer->scan_el_attrs != NULL) {
+ 		attr = buffer->scan_el_attrs->attrs;
+ 		while (*attr++ != NULL)
+ 			attrcount_orig++;
+ 	}
+ 	attrcount = attrcount_orig;
+ 	INIT_LIST_HEAD(&buffer->scan_el_dev_attr_list);
+ 	channels = indio_dev->channels;
+ 	if (channels) {
+ 		/* new magic */
+ 		for (i = 0; i < indio_dev->num_channels; i++) {
+ 			if (channels[i].scan_index < 0)
+ 				continue;
+ 
+ 			/* Establish necessary mask length */
+ 			if (channels[i].scan_index >
+ 			    (int)indio_dev->masklength - 1)
+ 				indio_dev->masklength
+ 					= channels[i].scan_index + 1;
+ 
+ 			ret = iio_buffer_add_channel_sysfs(indio_dev,
+ 							 &channels[i]);
+ 			if (ret < 0)
+ 				goto error_cleanup_dynamic;
+ 			attrcount += ret;
+ 			if (channels[i].type == IIO_TIMESTAMP)
+ 				indio_dev->scan_index_timestamp =
+ 					channels[i].scan_index;
+ 		}
+ 		if (indio_dev->masklength && buffer->scan_mask == NULL) {
+ 			buffer->scan_mask = kcalloc(BITS_TO_LONGS(indio_dev->masklength),
+ 						    sizeof(*buffer->scan_mask),
+ 						    GFP_KERNEL);
+ 			if (buffer->scan_mask == NULL) {
+ 				ret = -ENOMEM;
+ 				goto error_cleanup_dynamic;
+ 			}
+ 		}
+ 	}
+ 
+ 	buffer->scan_el_group.name = iio_scan_elements_group_name;
+ 
+ 	buffer->scan_el_group.attrs = kcalloc(attrcount + 1,
+ 					      sizeof(buffer->scan_el_group.attrs[0]),
+ 					      GFP_KERNEL);
+ 	if (buffer->scan_el_group.attrs == NULL) {
+ 		ret = -ENOMEM;
+ 		goto error_free_scan_mask;
+ 	}
+ 	if (buffer->scan_el_attrs)
+ 		memcpy(buffer->scan_el_group.attrs, buffer->scan_el_attrs,
+ 		       sizeof(buffer->scan_el_group.attrs[0])*attrcount_orig);
+ 	attrn = attrcount_orig;
+ 
+ 	list_for_each_entry(p, &buffer->scan_el_dev_attr_list, l)
+ 		buffer->scan_el_group.attrs[attrn++] = &p->dev_attr.attr;
+ 	indio_dev->groups[indio_dev->groupcounter++] = &buffer->scan_el_group;
+ 
+ 	return 0;
+ 
+ error_free_scan_mask:
+ 	kfree(buffer->scan_mask);
+ error_cleanup_dynamic:
+ 	iio_free_chan_devattr_list(&buffer->scan_el_dev_attr_list);
+ 	kfree(indio_dev->buffer->buffer_group.attrs);
+ 
+ 	return ret;
+ }
+ 
+ void iio_buffer_free_sysfs_and_mask(struct iio_dev *indio_dev)
+ {
+ 	if (!indio_dev->buffer)
+ 		return;
+ 
+ 	kfree(indio_dev->buffer->scan_mask);
+ 	kfree(indio_dev->buffer->buffer_group.attrs);
+ 	kfree(indio_dev->buffer->scan_el_group.attrs);
+ 	iio_free_chan_devattr_list(&indio_dev->buffer->scan_el_dev_attr_list);
+ }
++>>>>>>> 6da9b382bd2b (iio: buffer: refactor buffer attributes setup)
  
  /**
   * iio_validate_scan_mask_onehot() - Validates that exactly one channel is selected
* Unmerged path drivers/iio/industrialio-buffer.c
