mmc: host: Add CQE interface

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] host: Add CQE interface (Gopal Tiwari) [1456570]
Rebuild_FUZZ: 90.20%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit d3bf68ae04c7e29ed3c30b7f4b1f0c6a4a11c7f1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d3bf68ae.failed

Add CQE host operations, capabilities, and host members.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit d3bf68ae04c7e29ed3c30b7f4b1f0c6a4a11c7f1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mmc/host.h
diff --cc include/linux/mmc/host.h
index 3d6f7a820ea1,f3f2d07feb2a..000000000000
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@@ -162,8 -162,49 +162,54 @@@ struct mmc_host_ops 
  				  unsigned int direction, int blk_size);
  };
  
++<<<<<<< HEAD
 +struct mmc_card;
 +struct device;
++=======
+ struct mmc_cqe_ops {
+ 	/* Allocate resources, and make the CQE operational */
+ 	int	(*cqe_enable)(struct mmc_host *host, struct mmc_card *card);
+ 	/* Free resources, and make the CQE non-operational */
+ 	void	(*cqe_disable)(struct mmc_host *host);
+ 	/*
+ 	 * Issue a read, write or DCMD request to the CQE. Also deal with the
+ 	 * effect of ->cqe_off().
+ 	 */
+ 	int	(*cqe_request)(struct mmc_host *host, struct mmc_request *mrq);
+ 	/* Free resources (e.g. DMA mapping) associated with the request */
+ 	void	(*cqe_post_req)(struct mmc_host *host, struct mmc_request *mrq);
+ 	/*
+ 	 * Prepare the CQE and host controller to accept non-CQ commands. There
+ 	 * is no corresponding ->cqe_on(), instead ->cqe_request() is required
+ 	 * to deal with that.
+ 	 */
+ 	void	(*cqe_off)(struct mmc_host *host);
+ 	/*
+ 	 * Wait for all CQE tasks to complete. Return an error if recovery
+ 	 * becomes necessary.
+ 	 */
+ 	int	(*cqe_wait_for_idle)(struct mmc_host *host);
+ 	/*
+ 	 * Notify CQE that a request has timed out. Return false if the request
+ 	 * completed or true if a timeout happened in which case indicate if
+ 	 * recovery is needed.
+ 	 */
+ 	bool	(*cqe_timeout)(struct mmc_host *host, struct mmc_request *mrq,
+ 			       bool *recovery_needed);
+ 	/*
+ 	 * Stop all CQE activity and prepare the CQE and host controller to
+ 	 * accept recovery commands.
+ 	 */
+ 	void	(*cqe_recovery_start)(struct mmc_host *host);
+ 	/*
+ 	 * Clear the queue and call mmc_cqe_request_done() on all requests.
+ 	 * Requests that errored will have the error set on the mmc_request
+ 	 * (data->error or cmd->error for DCMD).  Requests that did not error
+ 	 * will have zero data bytes transferred.
+ 	 */
+ 	void	(*cqe_recovery_finish)(struct mmc_host *host);
+ };
++>>>>>>> d3bf68ae04c7 (mmc: host: Add CQE interface)
  
  struct mmc_async_req {
  	/* active mmc request */
diff --git a/include/linux/mmc/core.h b/include/linux/mmc/core.h
index e33cc748dcfe..5980b871356b 100644
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@ -150,6 +150,12 @@ struct mmc_request {
 	struct completion	completion;
 	struct completion	cmd_completion;
 	void			(*done)(struct mmc_request *);/* completion function */
+	/*
+	 * Notify uppers layers (e.g. mmc block driver) that recovery is needed
+	 * due to an error associated with the mmc_request. Currently used only
+	 * by CQE.
+	 */
+	void			(*recovery_notifier)(struct mmc_request *);
 	struct mmc_host		*host;
 
 	/* Allow other commands during this ongoing data transfer or busy wait */
* Unmerged path include/linux/mmc/host.h
