mlxsw: spectrum_router: Extract __mlxsw_sp_ipip_entry_update_tunnel()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Petr Machata <petrm@mellanox.com>
commit 65a6121b30a65bb4b61322c895bf835fedd6e315
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/65a6121b.failed

The work that's done by mlxsw_sp_netdevice_ipip_ol_vrf_event() is a good
basis for a more versatile function that would take care of all sorts of
tunnel updates requests: __mlxsw_sp_ipip_entry_update_tunnel(). Extract
that function. Factor out a helper mlxsw_sp_ipip_entry_ol_lb_update() as
well.

	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 65a6121b30a65bb4b61322c895bf835fedd6e315)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 366876570ba2,e2795b889068..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -1348,51 -1355,72 +1348,91 @@@ static void mlxsw_sp_netdevice_ipip_ol_
  		mlxsw_sp_ipip_entry_ol_down_event(mlxsw_sp, ipip_entry);
  }
  
++<<<<<<< HEAD
 +static int mlxsw_sp_netdevice_ipip_ol_vrf_event(struct mlxsw_sp *mlxsw_sp,
 +						struct net_device *ol_dev)
- {
- 	struct mlxsw_sp_fib_entry *decap_fib_entry;
- 	struct mlxsw_sp_ipip_entry *ipip_entry;
- 	struct mlxsw_sp_rif_ipip_lb *lb_rif;
++=======
+ static int
+ mlxsw_sp_ipip_entry_ol_lb_update(struct mlxsw_sp *mlxsw_sp,
+ 				 struct mlxsw_sp_ipip_entry *ipip_entry,
+ 				 struct netlink_ext_ack *extack)
++>>>>>>> 65a6121b30a6 (mlxsw: spectrum_router: Extract __mlxsw_sp_ipip_entry_update_tunnel())
+ {
+ 	struct mlxsw_sp_rif_ipip_lb *old_lb_rif = ipip_entry->ol_lb;
+ 	struct mlxsw_sp_rif_ipip_lb *new_lb_rif;
+ 
+ 	new_lb_rif = mlxsw_sp_ipip_ol_ipip_lb_create(mlxsw_sp,
+ 						     ipip_entry->ipipt,
+ 						     ipip_entry->ol_dev,
+ 						     extack);
+ 	if (IS_ERR(new_lb_rif))
+ 		return PTR_ERR(new_lb_rif);
+ 	ipip_entry->ol_lb = new_lb_rif;
+ 	mlxsw_sp_rif_destroy(&old_lb_rif->common);
  
- 	ipip_entry = mlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, ol_dev);
- 	if (!ipip_entry)
- 		return 0;
+ 	return 0;
+ }
+ 
+ int __mlxsw_sp_ipip_entry_update_tunnel(struct mlxsw_sp *mlxsw_sp,
+ 					struct mlxsw_sp_ipip_entry *ipip_entry,
+ 					struct netlink_ext_ack *extack)
+ {
+ 	int err;
  
- 	/* When a tunneling device is moved to a different VRF, we need to
- 	 * update the backing loopback. Since RIFs can't be edited, we need to
- 	 * destroy and recreate it. That might create a window of opportunity
- 	 * where RALUE and RATR registers end up referencing a RIF that's
- 	 * already gone. RATRs are handled by the RIF destroy, and to take care
+ 	/* RIFs can't be edited, so to update loopback, we need to destroy and
+ 	 * recreate it. That creates a window of opportunity where RALUE and
+ 	 * RATR registers end up referencing a RIF that's already gone. RATRs
+ 	 * are handled in mlxsw_sp_ipip_entry_ol_lb_update(), and to take care
  	 * of RALUE, demote the decap route back.
  	 */
  	if (ipip_entry->decap_fib_entry)
  		mlxsw_sp_ipip_entry_demote_decap(mlxsw_sp, ipip_entry);
  
++<<<<<<< HEAD
 +	lb_rif = mlxsw_sp_ipip_ol_ipip_lb_create(mlxsw_sp, ipip_entry->ipipt,
 +						 ol_dev);
 +	if (IS_ERR(lb_rif))
 +		return PTR_ERR(lb_rif);
 +	mlxsw_sp_rif_destroy(&ipip_entry->ol_lb->common);
 +	ipip_entry->ol_lb = lb_rif;
++=======
+ 	err = mlxsw_sp_ipip_entry_ol_lb_update(mlxsw_sp, ipip_entry, extack);
+ 	if (err)
+ 		return err;
++>>>>>>> 65a6121b30a6 (mlxsw: spectrum_router: Extract __mlxsw_sp_ipip_entry_update_tunnel())
  
- 	if (ol_dev->flags & IFF_UP) {
- 		decap_fib_entry = mlxsw_sp_ipip_entry_find_decap(mlxsw_sp,
- 								 ipip_entry);
- 		if (decap_fib_entry)
- 			mlxsw_sp_ipip_entry_promote_decap(mlxsw_sp, ipip_entry,
- 							  decap_fib_entry);
- 	}
+ 	if (ipip_entry->ol_dev->flags & IFF_UP)
+ 		mlxsw_sp_ipip_entry_ol_up_event(mlxsw_sp, ipip_entry);
  
  	return 0;
  }
  
++<<<<<<< HEAD
 +int
 +mlxsw_sp_netdevice_ipip_ol_event(struct mlxsw_sp *mlxsw_sp,
 +				 struct net_device *ol_dev,
 +				 unsigned long event,
 +				 struct netdev_notifier_changeupper_info *info)
++=======
+ static int mlxsw_sp_netdevice_ipip_ol_vrf_event(struct mlxsw_sp *mlxsw_sp,
+ 						struct net_device *ol_dev,
+ 						struct netlink_ext_ack *extack)
+ {
+ 	struct mlxsw_sp_ipip_entry *ipip_entry =
+ 		mlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, ol_dev);
+ 
+ 	if (!ipip_entry)
+ 		return 0;
+ 	return __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,
+ 						   extack);
+ }
+ 
+ int mlxsw_sp_netdevice_ipip_ol_event(struct mlxsw_sp *mlxsw_sp,
+ 				     struct net_device *ol_dev,
+ 				     unsigned long event,
+ 				     struct netdev_notifier_info *info)
++>>>>>>> 65a6121b30a6 (mlxsw: spectrum_router: Extract __mlxsw_sp_ipip_entry_update_tunnel())
  {
 -	struct netdev_notifier_changeupper_info *chup;
 -	struct netlink_ext_ack *extack;
 -
  	switch (event) {
  	case NETDEV_REGISTER:
  		return mlxsw_sp_netdevice_ipip_ol_reg_event(mlxsw_sp, ol_dev);
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
