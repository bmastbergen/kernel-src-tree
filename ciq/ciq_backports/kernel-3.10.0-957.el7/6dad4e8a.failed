chcr: Add support for Inline IPSec

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Atul Gupta <atul.gupta@chelsio.com>
commit 6dad4e8ab3ec65c3b948ad79e83751cf0f04cbdf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6dad4e8a.failed

register xfrmdev_ops callbacks, Send IPsec tunneled data
to HW for inline processing.
The driver use hardware crypto accelerator to encrypt and
generate ICV for the transmitted packet in Inline mode.

	Signed-off-by: Atul Gupta <atul.gupta@chelsio.com>
	Signed-off-by: Harsh Jain <harsh@chelsio.com>
	Signed-off-by: Ganesh Goudar <ganeshgr@chelsio.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 6dad4e8ab3ec65c3b948ad79e83751cf0f04cbdf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/chelsio/chcr_algo.c
#	drivers/crypto/chelsio/chcr_algo.h
#	drivers/crypto/chelsio/chcr_core.h
#	drivers/crypto/chelsio/chcr_crypto.h
diff --cc drivers/crypto/chelsio/chcr_algo.c
index 32747a50ffb7,e61ec8a46340..000000000000
--- a/drivers/crypto/chelsio/chcr_algo.c
+++ b/drivers/crypto/chelsio/chcr_algo.c
@@@ -69,6 -71,27 +69,30 @@@
  #include "chcr_algo.h"
  #include "chcr_crypto.h"
  
++<<<<<<< HEAD
++=======
+ #define IV AES_BLOCK_SIZE
+ 
+ unsigned int sgl_ent_len[] = {0, 0, 16, 24, 40, 48, 64, 72, 88,
+ 				96, 112, 120, 136, 144, 160, 168, 184,
+ 				192, 208, 216, 232, 240, 256, 264, 280,
+ 				288, 304, 312, 328, 336, 352, 360, 376};
+ 
+ unsigned int dsgl_ent_len[] = {0, 32, 32, 48, 48, 64, 64, 80, 80,
+ 				112, 112, 128, 128, 144, 144, 160, 160,
+ 				192, 192, 208, 208, 224, 224, 240, 240,
+ 				272, 272, 288, 288, 304, 304, 320, 320};
+ 
+ static u32 round_constant[11] = {
+ 	0x01000000, 0x02000000, 0x04000000, 0x08000000,
+ 	0x10000000, 0x20000000, 0x40000000, 0x80000000,
+ 	0x1B000000, 0x36000000, 0x6C000000
+ };
+ 
+ static int chcr_handle_cipher_resp(struct ablkcipher_request *req,
+ 				   unsigned char *input, int err);
+ 
++>>>>>>> 6dad4e8ab3ec (chcr: Add support for Inline IPSec)
  static inline  struct chcr_aead_ctx *AEAD_CTX(struct chcr_context *ctx)
  {
  	return ctx->crypto_ctx->aeadctx;
@@@ -101,22 -124,82 +125,98 @@@ static inline struct uld_ctx *ULD_CTX(s
  
  static inline int is_ofld_imm(const struct sk_buff *skb)
  {
 -	return (skb->len <= SGE_MAX_WR_LEN);
 +	return (skb->len <= CRYPTO_MAX_IMM_TX_PKT_LEN);
  }
  
++<<<<<<< HEAD
 +/*
 + *	sgl_len - calculates the size of an SGL of the given capacity
 + *	@n: the number of SGL entries
 + *	Calculates the number of flits needed for a scatter/gather list that
 + *	can hold the given number of entries.
 + */
 +static inline unsigned int sgl_len(unsigned int n)
 +{
 +	n--;
 +	return (3 * n) / 2 + (n & 1) + 2;
 +}
 +
 +static void chcr_verify_tag(struct aead_request *req, u8 *input, int *err)
++=======
+ static int sg_nents_xlen(struct scatterlist *sg, unsigned int reqlen,
+ 			 unsigned int entlen,
+ 			 unsigned int skip)
+ {
+ 	int nents = 0;
+ 	unsigned int less;
+ 	unsigned int skip_len = 0;
+ 
+ 	while (sg && skip) {
+ 		if (sg_dma_len(sg) <= skip) {
+ 			skip -= sg_dma_len(sg);
+ 			skip_len = 0;
+ 			sg = sg_next(sg);
+ 		} else {
+ 			skip_len = skip;
+ 			skip = 0;
+ 		}
+ 	}
+ 
+ 	while (sg && reqlen) {
+ 		less = min(reqlen, sg_dma_len(sg) - skip_len);
+ 		nents += DIV_ROUND_UP(less, entlen);
+ 		reqlen -= less;
+ 		skip_len = 0;
+ 		sg = sg_next(sg);
+ 	}
+ 	return nents;
+ }
+ 
+ static inline void chcr_handle_ahash_resp(struct ahash_request *req,
+ 					  unsigned char *input,
+ 					  int err)
+ {
+ 	struct chcr_ahash_req_ctx *reqctx = ahash_request_ctx(req);
+ 	int digestsize, updated_digestsize;
+ 	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
+ 	struct uld_ctx *u_ctx = ULD_CTX(h_ctx(tfm));
+ 
+ 	if (input == NULL)
+ 		goto out;
+ 	digestsize = crypto_ahash_digestsize(crypto_ahash_reqtfm(req));
+ 	if (reqctx->is_sg_map)
+ 		chcr_hash_dma_unmap(&u_ctx->lldi.pdev->dev, req);
+ 	if (reqctx->dma_addr)
+ 		dma_unmap_single(&u_ctx->lldi.pdev->dev, reqctx->dma_addr,
+ 				 reqctx->dma_len, DMA_TO_DEVICE);
+ 	reqctx->dma_addr = 0;
+ 	updated_digestsize = digestsize;
+ 	if (digestsize == SHA224_DIGEST_SIZE)
+ 		updated_digestsize = SHA256_DIGEST_SIZE;
+ 	else if (digestsize == SHA384_DIGEST_SIZE)
+ 		updated_digestsize = SHA512_DIGEST_SIZE;
+ 	if (reqctx->result == 1) {
+ 		reqctx->result = 0;
+ 		memcpy(req->result, input + sizeof(struct cpl_fw6_pld),
+ 		       digestsize);
+ 	} else {
+ 		memcpy(reqctx->partial_hash, input + sizeof(struct cpl_fw6_pld),
+ 		       updated_digestsize);
+ 	}
+ out:
+ 	req->base.complete(&req->base, err);
+ }
+ 
+ static inline int get_aead_subtype(struct crypto_aead *aead)
+ {
+ 	struct aead_alg *alg = crypto_aead_alg(aead);
+ 	struct chcr_alg_template *chcr_crypto_alg =
+ 		container_of(alg, struct chcr_alg_template, alg.aead);
+ 	return chcr_crypto_alg->type & CRYPTO_ALG_SUB_TYPE_MASK;
+ }
+ 
+ void chcr_verify_tag(struct aead_request *req, u8 *input, int *err)
++>>>>>>> 6dad4e8ab3ec (chcr: Add support for Inline IPSec)
  {
  	u8 temp[SHA512_DIGEST_SIZE];
  	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
@@@ -396,49 -440,173 +515,52 @@@ static void write_phys_cpl(struct cpl_r
  		      CPL_RX_PHYS_DSGL_PCITPHNTENB_V(0) |
  		      CPL_RX_PHYS_DSGL_PCITPHNT_V(0) |
  		      CPL_RX_PHYS_DSGL_DCAID_V(0) |
 -		      CPL_RX_PHYS_DSGL_NOOFSGENTR_V(walk->nents));
 +		      CPL_RX_PHYS_DSGL_NOOFSGENTR_V(nents));
  	phys_cpl->rss_hdr_int.opcode = CPL_RX_PHYS_ADDR;
 -	phys_cpl->rss_hdr_int.qid = htons(qid);
 +	phys_cpl->rss_hdr_int.qid = htons(sg_param->qid);
  	phys_cpl->rss_hdr_int.hash_val = 0;
 -}
 -
 -static inline void dsgl_walk_add_page(struct dsgl_walk *walk,
 -					size_t size,
 -					dma_addr_t *addr)
 -{
 -	int j;
 -
 -	if (!size)
 -		return;
 -	j = walk->nents;
 -	walk->to->len[j % 8] = htons(size);
 -	walk->to->addr[j % 8] = cpu_to_be64(*addr);
 -	j++;
 -	if ((j % 8) == 0)
 -		walk->to++;
 -	walk->nents = j;
 -}
 -
 -static void  dsgl_walk_add_sg(struct dsgl_walk *walk,
 -			   struct scatterlist *sg,
 -			      unsigned int slen,
 -			      unsigned int skip)
 -{
 -	int skip_len = 0;
 -	unsigned int left_size = slen, len = 0;
 -	unsigned int j = walk->nents;
 -	int offset, ent_len;
 -
 -	if (!slen)
 -		return;
 -	while (sg && skip) {
 -		if (sg_dma_len(sg) <= skip) {
 -			skip -= sg_dma_len(sg);
 -			skip_len = 0;
 +	to = (struct phys_sge_pairs *)((unsigned char *)phys_cpl +
 +				       sizeof(struct cpl_rx_phys_dsgl));
 +	for (i = 0; nents && left_size; to++) {
 +		for (j = 0; j < 8 && nents && left_size; j++, nents--) {
 +			len = min(left_size, sg_dma_len(sg));
 +			to->len[j] = htons(len);
 +			to->addr[j] = cpu_to_be64(sg_dma_address(sg));
 +			left_size -= len;
  			sg = sg_next(sg);
 -		} else {
 -			skip_len = skip;
 -			skip = 0;
 -		}
 -	}
 -
 -	while (left_size && sg) {
 -		len = min_t(u32, left_size, sg_dma_len(sg) - skip_len);
 -		offset = 0;
 -		while (len) {
 -			ent_len =  min_t(u32, len, CHCR_DST_SG_SIZE);
 -			walk->to->len[j % 8] = htons(ent_len);
 -			walk->to->addr[j % 8] = cpu_to_be64(sg_dma_address(sg) +
 -						      offset + skip_len);
 -			offset += ent_len;
 -			len -= ent_len;
 -			j++;
 -			if ((j % 8) == 0)
 -				walk->to++;
  		}
 -		walk->last_sg = sg;
 -		walk->last_sg_len = min_t(u32, left_size, sg_dma_len(sg) -
 -					  skip_len) + skip_len;
 -		left_size -= min_t(u32, left_size, sg_dma_len(sg) - skip_len);
 -		skip_len = 0;
 -		sg = sg_next(sg);
  	}
 -	walk->nents = j;
 -}
 -
 -static inline void ulptx_walk_init(struct ulptx_walk *walk,
 -				   struct ulptx_sgl *ulp)
 -{
 -	walk->sgl = ulp;
 -	walk->nents = 0;
 -	walk->pair_idx = 0;
 -	walk->pair = ulp->sge;
 -	walk->last_sg = NULL;
 -	walk->last_sg_len = 0;
 -}
 -
 -static inline void ulptx_walk_end(struct ulptx_walk *walk)
 -{
 -	walk->sgl->cmd_nsge = htonl(ULPTX_CMD_V(ULP_TX_SC_DSGL) |
 -			      ULPTX_NSGE_V(walk->nents));
  }
  
 -
 -static inline void ulptx_walk_add_page(struct ulptx_walk *walk,
 -					size_t size,
 -					dma_addr_t *addr)
 +static inline int map_writesg_phys_cpl(struct device *dev,
 +					struct cpl_rx_phys_dsgl *phys_cpl,
 +					struct scatterlist *sg,
 +					struct phys_sge_parm *sg_param)
  {
 -	if (!size)
 -		return;
 +	if (!sg || !sg_param->nents)
 +		return -EINVAL;
  
 -	if (walk->nents == 0) {
 -		walk->sgl->len0 = cpu_to_be32(size);
 -		walk->sgl->addr0 = cpu_to_be64(*addr);
 -	} else {
 -		walk->pair->addr[walk->pair_idx] = cpu_to_be64(*addr);
 -		walk->pair->len[walk->pair_idx] = cpu_to_be32(size);
 -		walk->pair_idx = !walk->pair_idx;
 -		if (!walk->pair_idx)
 -			walk->pair++;
 +	sg_param->nents = dma_map_sg(dev, sg, sg_param->nents, DMA_FROM_DEVICE);
 +	if (sg_param->nents == 0) {
 +		pr_err("CHCR : DMA mapping failed\n");
 +		return -EINVAL;
  	}
 -	walk->nents++;
 +	write_phys_cpl(phys_cpl, sg, sg_param);
 +	return 0;
  }
  
 -static void  ulptx_walk_add_sg(struct ulptx_walk *walk,
 -					struct scatterlist *sg,
 -			       unsigned int len,
 -			       unsigned int skip)
++<<<<<<< HEAD
 +static inline int get_aead_subtype(struct crypto_aead *aead)
  {
 -	int small;
 -	int skip_len = 0;
 -	unsigned int sgmin;
 -
 -	if (!len)
 -		return;
 -
 -	while (sg && skip) {
 -		if (sg_dma_len(sg) <= skip) {
 -			skip -= sg_dma_len(sg);
 -			skip_len = 0;
 -			sg = sg_next(sg);
 -		} else {
 -			skip_len = skip;
 -			skip = 0;
 -		}
 -	}
 -	if (walk->nents == 0) {
 -		small = min_t(unsigned int, sg_dma_len(sg) - skip_len, len);
 -		sgmin = min_t(unsigned int, small, CHCR_SRC_SG_SIZE);
 -		walk->sgl->len0 = cpu_to_be32(sgmin);
 -		walk->sgl->addr0 = cpu_to_be64(sg_dma_address(sg) + skip_len);
 -		walk->nents++;
 -		len -= sgmin;
 -		walk->last_sg = sg;
 -		walk->last_sg_len = sgmin + skip_len;
 -		skip_len += sgmin;
 -		if (sg_dma_len(sg) == skip_len) {
 -			sg = sg_next(sg);
 -			skip_len = 0;
 -		}
 -	}
 -
 -	while (sg && len) {
 -		small = min(sg_dma_len(sg) - skip_len, len);
 -		sgmin = min_t(unsigned int, small, CHCR_SRC_SG_SIZE);
 -		walk->pair->len[walk->pair_idx] = cpu_to_be32(sgmin);
 -		walk->pair->addr[walk->pair_idx] =
 -			cpu_to_be64(sg_dma_address(sg) + skip_len);
 -		walk->pair_idx = !walk->pair_idx;
 -		walk->nents++;
 -		if (!walk->pair_idx)
 -			walk->pair++;
 -		len -= sgmin;
 -		skip_len += sgmin;
 -		walk->last_sg = sg;
 -		walk->last_sg_len = skip_len;
 -		if (sg_dma_len(sg) == skip_len) {
 -			sg = sg_next(sg);
 -			skip_len = 0;
 -		}
 -	}
 +	struct crypto_tfm *tfm = crypto_aead_tfm(aead);
 +	struct crypto_alg *alg = tfm->__crt_alg;
 +	struct chcr_alg_template *chcr_crypto_alg =
 +		container_of(alg, struct chcr_alg_template, alg.crypto);
 +	return chcr_crypto_alg->type & CRYPTO_ALG_SUB_TYPE_MASK;
  }
  
++=======
++>>>>>>> 6dad4e8ab3ec (chcr: Add support for Inline IPSec)
  static inline int get_cryptoalg_subtype(struct crypto_tfm *tfm)
  {
  	struct crypto_alg *alg = tfm->__crt_alg;
@@@ -2076,6 -2202,290 +2197,293 @@@ err
  	return ERR_PTR(error);
  }
  
++<<<<<<< HEAD
++=======
+ int chcr_aead_dma_map(struct device *dev,
+ 		      struct aead_request *req,
+ 		      unsigned short op_type)
+ {
+ 	int error;
+ 	struct chcr_aead_reqctx  *reqctx = aead_request_ctx(req);
+ 	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
+ 	unsigned int authsize = crypto_aead_authsize(tfm);
+ 	int dst_size;
+ 
+ 	dst_size = req->assoclen + req->cryptlen + (op_type ?
+ 				-authsize : authsize);
+ 	if (!req->cryptlen || !dst_size)
+ 		return 0;
+ 	reqctx->iv_dma = dma_map_single(dev, reqctx->iv, IV,
+ 					DMA_BIDIRECTIONAL);
+ 	if (dma_mapping_error(dev, reqctx->iv_dma))
+ 		return -ENOMEM;
+ 
+ 	if (req->src == req->dst) {
+ 		error = dma_map_sg(dev, req->src, sg_nents(req->src),
+ 				   DMA_BIDIRECTIONAL);
+ 		if (!error)
+ 			goto err;
+ 	} else {
+ 		error = dma_map_sg(dev, req->src, sg_nents(req->src),
+ 				   DMA_TO_DEVICE);
+ 		if (!error)
+ 			goto err;
+ 		error = dma_map_sg(dev, req->dst, sg_nents(req->dst),
+ 				   DMA_FROM_DEVICE);
+ 		if (!error) {
+ 			dma_unmap_sg(dev, req->src, sg_nents(req->src),
+ 				   DMA_TO_DEVICE);
+ 			goto err;
+ 		}
+ 	}
+ 
+ 	return 0;
+ err:
+ 	dma_unmap_single(dev, reqctx->iv_dma, IV, DMA_BIDIRECTIONAL);
+ 	return -ENOMEM;
+ }
+ 
+ void chcr_aead_dma_unmap(struct device *dev,
+ 			 struct aead_request *req,
+ 			 unsigned short op_type)
+ {
+ 	struct chcr_aead_reqctx  *reqctx = aead_request_ctx(req);
+ 	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
+ 	unsigned int authsize = crypto_aead_authsize(tfm);
+ 	int dst_size;
+ 
+ 	dst_size = req->assoclen + req->cryptlen + (op_type ?
+ 					-authsize : authsize);
+ 	if (!req->cryptlen || !dst_size)
+ 		return;
+ 
+ 	dma_unmap_single(dev, reqctx->iv_dma, IV,
+ 					DMA_BIDIRECTIONAL);
+ 	if (req->src == req->dst) {
+ 		dma_unmap_sg(dev, req->src, sg_nents(req->src),
+ 				   DMA_BIDIRECTIONAL);
+ 	} else {
+ 		dma_unmap_sg(dev, req->src, sg_nents(req->src),
+ 				   DMA_TO_DEVICE);
+ 		dma_unmap_sg(dev, req->dst, sg_nents(req->dst),
+ 				   DMA_FROM_DEVICE);
+ 	}
+ }
+ 
+ void chcr_add_aead_src_ent(struct aead_request *req,
+ 			   struct ulptx_sgl *ulptx,
+ 			   unsigned int assoclen,
+ 			   unsigned short op_type)
+ {
+ 	struct ulptx_walk ulp_walk;
+ 	struct chcr_aead_reqctx  *reqctx = aead_request_ctx(req);
+ 
+ 	if (reqctx->imm) {
+ 		u8 *buf = (u8 *)ulptx;
+ 
+ 		if (reqctx->b0_dma) {
+ 			memcpy(buf, reqctx->scratch_pad, reqctx->b0_len);
+ 			buf += reqctx->b0_len;
+ 		}
+ 		sg_pcopy_to_buffer(req->src, sg_nents(req->src),
+ 				   buf, assoclen, 0);
+ 		buf += assoclen;
+ 		memcpy(buf, reqctx->iv, IV);
+ 		buf += IV;
+ 		sg_pcopy_to_buffer(req->src, sg_nents(req->src),
+ 				   buf, req->cryptlen, req->assoclen);
+ 	} else {
+ 		ulptx_walk_init(&ulp_walk, ulptx);
+ 		if (reqctx->b0_dma)
+ 			ulptx_walk_add_page(&ulp_walk, reqctx->b0_len,
+ 					    &reqctx->b0_dma);
+ 		ulptx_walk_add_sg(&ulp_walk, req->src, assoclen, 0);
+ 		ulptx_walk_add_page(&ulp_walk, IV, &reqctx->iv_dma);
+ 		ulptx_walk_add_sg(&ulp_walk, req->src, req->cryptlen,
+ 				  req->assoclen);
+ 		ulptx_walk_end(&ulp_walk);
+ 	}
+ }
+ 
+ void chcr_add_aead_dst_ent(struct aead_request *req,
+ 			   struct cpl_rx_phys_dsgl *phys_cpl,
+ 			   unsigned int assoclen,
+ 			   unsigned short op_type,
+ 			   unsigned short qid)
+ {
+ 	struct chcr_aead_reqctx  *reqctx = aead_request_ctx(req);
+ 	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
+ 	struct dsgl_walk dsgl_walk;
+ 	unsigned int authsize = crypto_aead_authsize(tfm);
+ 	u32 temp;
+ 
+ 	dsgl_walk_init(&dsgl_walk, phys_cpl);
+ 	if (reqctx->b0_dma)
+ 		dsgl_walk_add_page(&dsgl_walk, reqctx->b0_len, &reqctx->b0_dma);
+ 	dsgl_walk_add_sg(&dsgl_walk, req->dst, assoclen, 0);
+ 	dsgl_walk_add_page(&dsgl_walk, IV, &reqctx->iv_dma);
+ 	temp = req->cryptlen + (op_type ? -authsize : authsize);
+ 	dsgl_walk_add_sg(&dsgl_walk, req->dst, temp, req->assoclen);
+ 	dsgl_walk_end(&dsgl_walk, qid);
+ }
+ 
+ void chcr_add_cipher_src_ent(struct ablkcipher_request *req,
+ 			     struct ulptx_sgl *ulptx,
+ 			     struct  cipher_wr_param *wrparam)
+ {
+ 	struct ulptx_walk ulp_walk;
+ 	struct chcr_blkcipher_req_ctx *reqctx = ablkcipher_request_ctx(req);
+ 
+ 	if (reqctx->imm) {
+ 		u8 *buf = (u8 *)ulptx;
+ 
+ 		memcpy(buf, reqctx->iv, IV);
+ 		buf += IV;
+ 		sg_pcopy_to_buffer(req->src, sg_nents(req->src),
+ 				   buf, wrparam->bytes, reqctx->processed);
+ 	} else {
+ 		ulptx_walk_init(&ulp_walk, ulptx);
+ 		ulptx_walk_add_page(&ulp_walk, IV, &reqctx->iv_dma);
+ 		ulptx_walk_add_sg(&ulp_walk, reqctx->srcsg, wrparam->bytes,
+ 				  reqctx->src_ofst);
+ 		reqctx->srcsg = ulp_walk.last_sg;
+ 		reqctx->src_ofst = ulp_walk.last_sg_len;
+ 		ulptx_walk_end(&ulp_walk);
+ 	}
+ }
+ 
+ void chcr_add_cipher_dst_ent(struct ablkcipher_request *req,
+ 			     struct cpl_rx_phys_dsgl *phys_cpl,
+ 			     struct  cipher_wr_param *wrparam,
+ 			     unsigned short qid)
+ {
+ 	struct chcr_blkcipher_req_ctx *reqctx = ablkcipher_request_ctx(req);
+ 	struct dsgl_walk dsgl_walk;
+ 
+ 	dsgl_walk_init(&dsgl_walk, phys_cpl);
+ 	dsgl_walk_add_page(&dsgl_walk, IV, &reqctx->iv_dma);
+ 	dsgl_walk_add_sg(&dsgl_walk, reqctx->dstsg, wrparam->bytes,
+ 			 reqctx->dst_ofst);
+ 	reqctx->dstsg = dsgl_walk.last_sg;
+ 	reqctx->dst_ofst = dsgl_walk.last_sg_len;
+ 
+ 	dsgl_walk_end(&dsgl_walk, qid);
+ }
+ 
+ void chcr_add_hash_src_ent(struct ahash_request *req,
+ 			   struct ulptx_sgl *ulptx,
+ 			   struct hash_wr_param *param)
+ {
+ 	struct ulptx_walk ulp_walk;
+ 	struct chcr_ahash_req_ctx *reqctx = ahash_request_ctx(req);
+ 
+ 	if (reqctx->imm) {
+ 		u8 *buf = (u8 *)ulptx;
+ 
+ 		if (param->bfr_len) {
+ 			memcpy(buf, reqctx->reqbfr, param->bfr_len);
+ 			buf += param->bfr_len;
+ 		}
+ 		sg_pcopy_to_buffer(req->src, sg_nents(req->src),
+ 				   buf, param->sg_len, 0);
+ 	} else {
+ 		ulptx_walk_init(&ulp_walk, ulptx);
+ 		if (param->bfr_len)
+ 			ulptx_walk_add_page(&ulp_walk, param->bfr_len,
+ 					    &reqctx->dma_addr);
+ 		ulptx_walk_add_sg(&ulp_walk, req->src, param->sg_len,
+ 					  0);
+ //	       reqctx->srcsg = ulp_walk.last_sg;
+ //	       reqctx->src_ofst = ulp_walk.last_sg_len;
+ 			ulptx_walk_end(&ulp_walk);
+ 	}
+ }
+ 
+ int chcr_hash_dma_map(struct device *dev,
+ 		      struct ahash_request *req)
+ {
+ 	struct chcr_ahash_req_ctx *req_ctx = ahash_request_ctx(req);
+ 	int error = 0;
+ 
+ 	if (!req->nbytes)
+ 		return 0;
+ 	error = dma_map_sg(dev, req->src, sg_nents(req->src),
+ 			   DMA_TO_DEVICE);
+ 	if (!error)
+ 		return -ENOMEM;
+ 	req_ctx->is_sg_map = 1;
+ 	return 0;
+ }
+ 
+ void chcr_hash_dma_unmap(struct device *dev,
+ 			 struct ahash_request *req)
+ {
+ 	struct chcr_ahash_req_ctx *req_ctx = ahash_request_ctx(req);
+ 
+ 	if (!req->nbytes)
+ 		return;
+ 
+ 	dma_unmap_sg(dev, req->src, sg_nents(req->src),
+ 			   DMA_TO_DEVICE);
+ 	req_ctx->is_sg_map = 0;
+ 
+ }
+ 
+ int chcr_cipher_dma_map(struct device *dev,
+ 			struct ablkcipher_request *req)
+ {
+ 	int error;
+ 	struct chcr_blkcipher_req_ctx *reqctx = ablkcipher_request_ctx(req);
+ 
+ 	reqctx->iv_dma = dma_map_single(dev, reqctx->iv, IV,
+ 					DMA_BIDIRECTIONAL);
+ 	if (dma_mapping_error(dev, reqctx->iv_dma))
+ 		return -ENOMEM;
+ 
+ 	if (req->src == req->dst) {
+ 		error = dma_map_sg(dev, req->src, sg_nents(req->src),
+ 				   DMA_BIDIRECTIONAL);
+ 		if (!error)
+ 			goto err;
+ 	} else {
+ 		error = dma_map_sg(dev, req->src, sg_nents(req->src),
+ 				   DMA_TO_DEVICE);
+ 		if (!error)
+ 			goto err;
+ 		error = dma_map_sg(dev, req->dst, sg_nents(req->dst),
+ 				   DMA_FROM_DEVICE);
+ 		if (!error) {
+ 			dma_unmap_sg(dev, req->src, sg_nents(req->src),
+ 				   DMA_TO_DEVICE);
+ 			goto err;
+ 		}
+ 	}
+ 
+ 	return 0;
+ err:
+ 	dma_unmap_single(dev, reqctx->iv_dma, IV, DMA_BIDIRECTIONAL);
+ 	return -ENOMEM;
+ }
+ 
+ void chcr_cipher_dma_unmap(struct device *dev,
+ 			   struct ablkcipher_request *req)
+ {
+ 	struct chcr_blkcipher_req_ctx *reqctx = ablkcipher_request_ctx(req);
+ 
+ 	dma_unmap_single(dev, reqctx->iv_dma, IV,
+ 					DMA_BIDIRECTIONAL);
+ 	if (req->src == req->dst) {
+ 		dma_unmap_sg(dev, req->src, sg_nents(req->src),
+ 				   DMA_BIDIRECTIONAL);
+ 	} else {
+ 		dma_unmap_sg(dev, req->src, sg_nents(req->src),
+ 				   DMA_TO_DEVICE);
+ 		dma_unmap_sg(dev, req->dst, sg_nents(req->dst),
+ 				   DMA_FROM_DEVICE);
+ 	}
+ }
+ 
++>>>>>>> 6dad4e8ab3ec (chcr: Add support for Inline IPSec)
  static int set_msg_len(u8 *block, unsigned int msglen, int csize)
  {
  	__be32 data;
@@@ -3063,39 -3460,6 +3505,42 @@@ static int chcr_aead_decrypt(struct aea
  	}
  }
  
++<<<<<<< HEAD
 +static int chcr_aead_op(struct aead_request *req,
 +			  unsigned short op_type,
 +			  int size,
 +			  create_wr_t create_wr_fn)
 +{
 +	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
 +	struct chcr_context *ctx = crypto_aead_ctx(tfm);
 +	struct uld_ctx *u_ctx;
 +	struct sk_buff *skb;
 +
 +	if (!ctx->dev) {
 +		pr_err("chcr : %s : No crypto device.\n", __func__);
 +		return -ENXIO;
 +	}
 +	u_ctx = ULD_CTX(ctx);
 +	if (cxgb4_is_crypto_q_full(u_ctx->lldi.ports[0],
 +				   ctx->tx_qidx)) {
 +		if (!(req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG))
 +			return -EBUSY;
 +	}
 +
 +	/* Form a WR from req */
 +	skb = create_wr_fn(req, u_ctx->lldi.rxq_ids[ctx->rx_qidx], size,
 +			   op_type);
 +
 +	if (IS_ERR(skb) || !skb)
 +		return PTR_ERR(skb);
 +
 +	skb->dev = u_ctx->lldi.ports[0];
 +	set_wr_txq(skb, CPL_PRIORITY_DATA, ctx->tx_qidx);
 +	chcr_send_wr(skb);
 +	return -EINPROGRESS;
 +}
++=======
++>>>>>>> 6dad4e8ab3ec (chcr: Add support for Inline IPSec)
  static struct chcr_alg_template driver_algs[] = {
  	/* AES-CBC */
  	{
diff --cc drivers/crypto/chelsio/chcr_algo.h
index 583008de51a3,d1673a5d4bf5..000000000000
--- a/drivers/crypto/chelsio/chcr_algo.h
+++ b/drivers/crypto/chelsio/chcr_algo.h
@@@ -214,32 -214,18 +214,35 @@@
  					   calc_tx_flits_ofld(skb) * 8), 16)))
  
  #define FILL_CMD_MORE(immdatalen) htonl(ULPTX_CMD_V(ULP_TX_SC_IMM) |\
 -					ULP_TX_SC_MORE_V((immdatalen)))
 +					ULP_TX_SC_MORE_V((immdatalen) ? 0 : 1))
 +
  #define MAX_NK 8
 +#define CRYPTO_MAX_IMM_TX_PKT_LEN 256
 +#define MAX_WR_SIZE			512
  #define ROUND_16(bytes)		((bytes) & 0xFFFFFFF0)
  #define MAX_DSGL_ENT			32
 +#define MAX_DIGEST_SKB_SGE	(MAX_SKB_FRAGS - 2)
  #define MIN_CIPHER_SG			1 /* IV */
 -#define MIN_AUTH_SG			1 /* IV */
 -#define MIN_GCM_SG			1 /* IV */
 +#define MIN_AUTH_SG			2 /*IV + AAD*/
 +#define MIN_GCM_SG			2 /* IV + AAD*/
  #define MIN_DIGEST_SG			1 /*Partial Buffer*/
 -#define MIN_CCM_SG			2 /*IV+B0*/
 +#define MIN_CCM_SG			3 /*IV+AAD+B0*/
  #define SPACE_LEFT(len) \
 -	((SGE_MAX_WR_LEN - WR_MIN_LEN - (len)))
 -
 +	((MAX_WR_SIZE - WR_MIN_LEN - (len)))
 +
++<<<<<<< HEAD
 +unsigned int sgl_ent_len[] = {0, 0, 16, 24, 40,
 +				48, 64, 72, 88,
 +				96, 112, 120, 136,
 +				144, 160, 168, 184,
 +				192};
 +unsigned int dsgl_ent_len[] = {0, 32, 32, 48, 48, 64, 64, 80, 80,
 +				112, 112, 128, 128, 144, 144, 160, 160,
 +				192, 192, 208, 208, 224, 224, 240, 240,
 +				272, 272, 288, 288, 304, 304, 320, 320};
 +
++=======
++>>>>>>> 6dad4e8ab3ec (chcr: Add support for Inline IPSec)
  struct algo_param {
  	unsigned int auth_mode;
  	unsigned int mk_size;
diff --cc drivers/crypto/chelsio/chcr_core.h
index c9a19b2a1e9f,3c29ee09b8b5..000000000000
--- a/drivers/crypto/chelsio/chcr_core.h
+++ b/drivers/crypto/chelsio/chcr_core.h
@@@ -89,7 -90,41 +90,45 @@@ struct uld_ctx 
  	struct chcr_dev *dev;
  };
  
++<<<<<<< HEAD
 +struct uld_ctx * assign_chcr_device(void);
++=======
+ struct chcr_ipsec_req {
+ 	struct ulp_txpkt ulptx;
+ 	struct ulptx_idata sc_imm;
+ 	struct cpl_tx_sec_pdu sec_cpl;
+ 	struct _key_ctx key_ctx;
+ };
+ 
+ struct chcr_ipsec_wr {
+ 	struct fw_ulptx_wr wreq;
+ 	struct chcr_ipsec_req req;
+ };
+ 
+ struct ipsec_sa_entry {
+ 	int hmac_ctrl;
+ 	unsigned int enckey_len;
+ 	unsigned int kctx_len;
+ 	unsigned int authsize;
+ 	__be32 key_ctx_hdr;
+ 	char salt[MAX_SALT];
+ 	char key[2 * AES_MAX_KEY_SIZE];
+ };
+ 
+ /*
+  *      sgl_len - calculates the size of an SGL of the given capacity
+  *      @n: the number of SGL entries
+  *      Calculates the number of flits needed for a scatter/gather list that
+  *      can hold the given number of entries.
+  */
+ static inline unsigned int sgl_len(unsigned int n)
+ {
+ 	n--;
+ 	return (3 * n) / 2 + (n & 1) + 2;
+ }
+ 
+ struct uld_ctx *assign_chcr_device(void);
++>>>>>>> 6dad4e8ab3ec (chcr: Add support for Inline IPSec)
  int chcr_send_wr(struct sk_buff *skb);
  int start_crypto(void);
  int stop_crypto(void);
diff --cc drivers/crypto/chelsio/chcr_crypto.h
index ee637a7f2f30,ea2c578805e6..000000000000
--- a/drivers/crypto/chelsio/chcr_crypto.h
+++ b/drivers/crypto/chelsio/chcr_crypto.h
@@@ -173,6 -192,24 +173,27 @@@ struct chcr_aead_reqctx 
  	unsigned char scratch_pad[MAX_SCRATCH_PAD_SIZE];
  };
  
++<<<<<<< HEAD
++=======
+ struct ulptx_walk {
+ 	struct ulptx_sgl *sgl;
+ 	unsigned int nents;
+ 	unsigned int pair_idx;
+ 	unsigned int last_sg_len;
+ 	struct scatterlist *last_sg;
+ 	struct ulptx_sge_pair *pair;
+ 
+ };
+ 
+ struct dsgl_walk {
+ 	unsigned int nents;
+ 	unsigned int last_sg_len;
+ 	struct scatterlist *last_sg;
+ 	struct cpl_rx_phys_dsgl *dsgl;
+ 	struct phys_sge_pairs *to;
+ };
+ 
++>>>>>>> 6dad4e8ab3ec (chcr: Add support for Inline IPSec)
  struct chcr_gcm_ctx {
  	u8 ghash_h[AEAD_H_SIZE];
  };
@@@ -283,15 -301,29 +300,43 @@@ typedef struct sk_buff *(*create_wr_t)(
  				       int size,
  				       unsigned short op_type);
  
++<<<<<<< HEAD
 +static int chcr_aead_op(struct aead_request *req_base,
 +			  unsigned short op_type,
 +			  int size,
 +			  create_wr_t create_wr_fn);
 +static inline int get_aead_subtype(struct crypto_aead *aead);
 +static int is_newsg(struct scatterlist *sgl, unsigned int *newents);
 +static struct scatterlist *alloc_new_sg(struct scatterlist *sgl,
 +					unsigned int nents);
 +static inline void free_new_sg(struct scatterlist *sgl);
 +static int chcr_handle_cipher_resp(struct ablkcipher_request *req,
 +				   unsigned char *input, int err);
++=======
+ void chcr_verify_tag(struct aead_request *req, u8 *input, int *err);
+ int chcr_aead_dma_map(struct device *dev, struct aead_request *req,
+ 		      unsigned short op_type);
+ void chcr_aead_dma_unmap(struct device *dev, struct aead_request *req,
+ 			 unsigned short op_type);
+ void chcr_add_aead_dst_ent(struct aead_request *req,
+ 			   struct cpl_rx_phys_dsgl *phys_cpl,
+ 			   unsigned int assoclen, unsigned short op_type,
+ 			   unsigned short qid);
+ void chcr_add_aead_src_ent(struct aead_request *req, struct ulptx_sgl *ulptx,
+ 			   unsigned int assoclen, unsigned short op_type);
+ void chcr_add_cipher_src_ent(struct ablkcipher_request *req,
+ 			     struct ulptx_sgl *ulptx,
+ 			     struct  cipher_wr_param *wrparam);
+ int chcr_cipher_dma_map(struct device *dev, struct ablkcipher_request *req);
+ void chcr_cipher_dma_unmap(struct device *dev, struct ablkcipher_request *req);
+ void chcr_add_cipher_dst_ent(struct ablkcipher_request *req,
+ 			     struct cpl_rx_phys_dsgl *phys_cpl,
+ 			     struct  cipher_wr_param *wrparam,
+ 			     unsigned short qid);
+ int sg_nents_len_skip(struct scatterlist *sg, u64 len, u64 skip);
+ void chcr_add_hash_src_ent(struct ahash_request *req, struct ulptx_sgl *ulptx,
+ 			   struct hash_wr_param *param);
+ int chcr_hash_dma_map(struct device *dev, struct ahash_request *req);
+ void chcr_hash_dma_unmap(struct device *dev, struct ahash_request *req);
++>>>>>>> 6dad4e8ab3ec (chcr: Add support for Inline IPSec)
  #endif /* __CHCR_CRYPTO_H__ */
diff --git a/drivers/crypto/chelsio/Kconfig b/drivers/crypto/chelsio/Kconfig
index 12f62ef405cb..b58810a63349 100644
--- a/drivers/crypto/chelsio/Kconfig
+++ b/drivers/crypto/chelsio/Kconfig
@@ -19,3 +19,13 @@ config CRYPTO_DEV_CHELSIO
 
 	  To compile this driver as a module, choose M here: the module
 	  will be called chcr.
+
+config CHELSIO_IPSEC_INLINE
+        bool "Chelsio IPSec XFRM Tx crypto offload"
+        depends on CHELSIO_T4
+	depends on CRYPTO_DEV_CHELSIO
+        depends on XFRM_OFFLOAD
+        depends on INET_ESP_OFFLOAD || INET6_ESP_OFFLOAD
+        default n
+        ---help---
+          Enable support for IPSec Tx Inline.
diff --git a/drivers/crypto/chelsio/Makefile b/drivers/crypto/chelsio/Makefile
index bebdf06687ad..eaecaf1ebcf3 100644
--- a/drivers/crypto/chelsio/Makefile
+++ b/drivers/crypto/chelsio/Makefile
@@ -2,3 +2,4 @@ ccflags-y := -Idrivers/net/ethernet/chelsio/cxgb4
 
 obj-$(CONFIG_CRYPTO_DEV_CHELSIO) += chcr.o
 chcr-objs :=  chcr_core.o chcr_algo.o
+chcr-$(CONFIG_CHELSIO_IPSEC_INLINE) += chcr_ipsec.o
* Unmerged path drivers/crypto/chelsio/chcr_algo.c
* Unmerged path drivers/crypto/chelsio/chcr_algo.h
diff --git a/drivers/crypto/chelsio/chcr_core.c b/drivers/crypto/chelsio/chcr_core.c
index f5a2624081dc..04f277cade7c 100644
--- a/drivers/crypto/chelsio/chcr_core.c
+++ b/drivers/crypto/chelsio/chcr_core.c
@@ -48,6 +48,9 @@ static struct cxgb4_uld_info chcr_uld_info = {
 	.add = chcr_uld_add,
 	.state_change = chcr_uld_state_change,
 	.rx_handler = chcr_uld_rx_handler,
+#ifdef CONFIG_CHELSIO_IPSEC_INLINE
+	.tx_handler = chcr_uld_tx_handler,
+#endif /* CONFIG_CHELSIO_IPSEC_INLINE */
 };
 
 struct uld_ctx *assign_chcr_device(void)
@@ -164,6 +167,10 @@ static void *chcr_uld_add(const struct cxgb4_lld_info *lld)
 		goto out;
 	}
 	u_ctx->lldi = *lld;
+#ifdef CONFIG_CHELSIO_IPSEC_INLINE
+	if (lld->crypto & ULP_CRYPTO_IPSEC_INLINE)
+		chcr_add_xfrmops(lld);
+#endif /* CONFIG_CHELSIO_IPSEC_INLINE */
 out:
 	return u_ctx;
 }
@@ -187,6 +194,13 @@ int chcr_uld_rx_handler(void *handle, const __be64 *rsp,
 	return 0;
 }
 
+#ifdef CONFIG_CHELSIO_IPSEC_INLINE
+int chcr_uld_tx_handler(struct sk_buff *skb, struct net_device *dev)
+{
+	return chcr_ipsec_xmit(skb, dev);
+}
+#endif /* CONFIG_CHELSIO_IPSEC_INLINE */
+
 static int chcr_uld_state_change(void *handle, enum cxgb4_state state)
 {
 	struct uld_ctx *u_ctx = handle;
* Unmerged path drivers/crypto/chelsio/chcr_core.h
* Unmerged path drivers/crypto/chelsio/chcr_crypto.h
diff --git a/drivers/crypto/chelsio/chcr_ipsec.c b/drivers/crypto/chelsio/chcr_ipsec.c
new file mode 100644
index 000000000000..f90f991c133f
--- /dev/null
+++ b/drivers/crypto/chelsio/chcr_ipsec.c
@@ -0,0 +1,660 @@
+/*
+ * This file is part of the Chelsio T6 Crypto driver for Linux.
+ *
+ * Copyright (c) 2003-2017 Chelsio Communications, Inc. All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Written and Maintained by:
+ *	Atul Gupta (atul.gupta@chelsio.com)
+ */
+
+#define pr_fmt(fmt) "chcr:" fmt
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/crypto.h>
+#include <linux/cryptohash.h>
+#include <linux/skbuff.h>
+#include <linux/rtnetlink.h>
+#include <linux/highmem.h>
+#include <linux/if_vlan.h>
+#include <linux/ip.h>
+#include <linux/netdevice.h>
+#include <net/esp.h>
+#include <net/xfrm.h>
+#include <crypto/aes.h>
+#include <crypto/algapi.h>
+#include <crypto/hash.h>
+#include <crypto/sha.h>
+#include <crypto/authenc.h>
+#include <crypto/internal/aead.h>
+#include <crypto/null.h>
+#include <crypto/internal/skcipher.h>
+#include <crypto/aead.h>
+#include <crypto/scatterwalk.h>
+#include <crypto/internal/hash.h>
+
+#include "chcr_core.h"
+#include "chcr_algo.h"
+#include "chcr_crypto.h"
+
+/*
+ * Max Tx descriptor space we allow for an Ethernet packet to be inlined
+ * into a WR.
+ */
+#define MAX_IMM_TX_PKT_LEN 256
+#define GCM_ESP_IV_SIZE     8
+
+static int chcr_xfrm_add_state(struct xfrm_state *x);
+static void chcr_xfrm_del_state(struct xfrm_state *x);
+static void chcr_xfrm_free_state(struct xfrm_state *x);
+static bool chcr_ipsec_offload_ok(struct sk_buff *skb, struct xfrm_state *x);
+
+static const struct xfrmdev_ops chcr_xfrmdev_ops = {
+	.xdo_dev_state_add      = chcr_xfrm_add_state,
+	.xdo_dev_state_delete   = chcr_xfrm_del_state,
+	.xdo_dev_state_free     = chcr_xfrm_free_state,
+	.xdo_dev_offload_ok     = chcr_ipsec_offload_ok,
+};
+
+/* Add offload xfrms to Chelsio Interface */
+void chcr_add_xfrmops(const struct cxgb4_lld_info *lld)
+{
+	struct net_device *netdev = NULL;
+	int i;
+
+	for (i = 0; i < lld->nports; i++) {
+		netdev = lld->ports[i];
+		if (!netdev)
+			continue;
+		netdev->xfrmdev_ops = &chcr_xfrmdev_ops;
+		netdev->hw_enc_features |= NETIF_F_HW_ESP;
+		netdev->features |= NETIF_F_HW_ESP;
+		rtnl_lock();
+		netdev_change_features(netdev);
+		rtnl_unlock();
+	}
+}
+
+static inline int chcr_ipsec_setauthsize(struct xfrm_state *x,
+					 struct ipsec_sa_entry *sa_entry)
+{
+	int hmac_ctrl;
+	int authsize = x->aead->alg_icv_len / 8;
+
+	sa_entry->authsize = authsize;
+
+	switch (authsize) {
+	case ICV_8:
+		hmac_ctrl = CHCR_SCMD_HMAC_CTRL_DIV2;
+		break;
+	case ICV_12:
+		hmac_ctrl = CHCR_SCMD_HMAC_CTRL_IPSEC_96BIT;
+		break;
+	case ICV_16:
+		hmac_ctrl = CHCR_SCMD_HMAC_CTRL_NO_TRUNC;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return hmac_ctrl;
+}
+
+static inline int chcr_ipsec_setkey(struct xfrm_state *x,
+				    struct ipsec_sa_entry *sa_entry)
+{
+	struct crypto_cipher *cipher;
+	int keylen = (x->aead->alg_key_len + 7) / 8;
+	unsigned char *key = x->aead->alg_key;
+	int ck_size, key_ctx_size = 0;
+	unsigned char ghash_h[AEAD_H_SIZE];
+	int ret = 0;
+
+	if (keylen > 3) {
+		keylen -= 4;  /* nonce/salt is present in the last 4 bytes */
+		memcpy(sa_entry->salt, key + keylen, 4);
+	}
+
+	if (keylen == AES_KEYSIZE_128) {
+		ck_size = CHCR_KEYCTX_CIPHER_KEY_SIZE_128;
+	} else if (keylen == AES_KEYSIZE_192) {
+		ck_size = CHCR_KEYCTX_CIPHER_KEY_SIZE_192;
+	} else if (keylen == AES_KEYSIZE_256) {
+		ck_size = CHCR_KEYCTX_CIPHER_KEY_SIZE_256;
+	} else {
+		pr_err("GCM: Invalid key length %d\n", keylen);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	memcpy(sa_entry->key, key, keylen);
+	sa_entry->enckey_len = keylen;
+	key_ctx_size = sizeof(struct _key_ctx) +
+			      ((DIV_ROUND_UP(keylen, 16)) << 4) +
+			      AEAD_H_SIZE;
+
+	sa_entry->key_ctx_hdr = FILL_KEY_CTX_HDR(ck_size,
+						 CHCR_KEYCTX_MAC_KEY_SIZE_128,
+						 0, 0,
+						 key_ctx_size >> 4);
+
+	/* Calculate the H = CIPH(K, 0 repeated 16 times).
+	 * It will go in key context
+	 */
+	cipher = crypto_alloc_cipher("aes-generic", 0, 0);
+	if (IS_ERR(cipher)) {
+		sa_entry->enckey_len = 0;
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = crypto_cipher_setkey(cipher, key, keylen);
+	if (ret) {
+		sa_entry->enckey_len = 0;
+		goto out1;
+	}
+	memset(ghash_h, 0, AEAD_H_SIZE);
+	crypto_cipher_encrypt_one(cipher, ghash_h, ghash_h);
+	memcpy(sa_entry->key + (DIV_ROUND_UP(sa_entry->enckey_len, 16) *
+	       16), ghash_h, AEAD_H_SIZE);
+	sa_entry->kctx_len = ((DIV_ROUND_UP(sa_entry->enckey_len, 16)) << 4) +
+			      AEAD_H_SIZE;
+out1:
+	crypto_free_cipher(cipher);
+out:
+	return ret;
+}
+
+/*
+ * chcr_xfrm_add_state
+ * returns 0 on success, negative error if failed to send message to FPGA
+ * positive error if FPGA returned a bad response
+ */
+static int chcr_xfrm_add_state(struct xfrm_state *x)
+{
+	struct net_device *netdev = x->xso.dev;
+	struct port_info *pi  = netdev_priv(netdev);
+	struct ipsec_sa_entry *sa_entry;
+	struct adapter *adap;
+	int res = 0;
+
+	adap = pi->adapter;
+
+	if (x->props.aalgo != SADB_AALG_NONE) {
+		pr_debug("CHCR: Cannot offload authenticated xfrm states\n");
+		return -EINVAL;
+	}
+	if (x->props.calgo != SADB_X_CALG_NONE) {
+		pr_debug("CHCR: Cannot offload compressed xfrm states\n");
+		return -EINVAL;
+	}
+	if (x->props.flags & XFRM_STATE_ESN) {
+		pr_debug("CHCR: Cannot offload ESN xfrm states\n");
+		return -EINVAL;
+	}
+	if (x->props.family != AF_INET &&
+	    x->props.family != AF_INET6) {
+		pr_debug("CHCR: Only IPv4/6 xfrm state offloaded\n");
+		return -EINVAL;
+	}
+	if (x->props.mode != XFRM_MODE_TRANSPORT &&
+	    x->props.mode != XFRM_MODE_TUNNEL) {
+		pr_debug("CHCR: Only transport and tunnel xfrm offload\n");
+		return -EINVAL;
+	}
+	if (x->id.proto != IPPROTO_ESP) {
+		pr_debug("CHCR: Only ESP xfrm state offloaded\n");
+		return -EINVAL;
+	}
+	if (x->encap) {
+		pr_debug("CHCR: Encapsulated xfrm state not offloaded\n");
+		return -EINVAL;
+	}
+	if (!x->aead) {
+		pr_debug("CHCR: Cannot offload xfrm states without aead\n");
+		return -EINVAL;
+	}
+	if (x->aead->alg_icv_len != 128 &&
+	    x->aead->alg_icv_len != 96) {
+		pr_debug("CHCR: Cannot offload xfrm states with AEAD ICV length other than 96b & 128b\n");
+	return -EINVAL;
+	}
+	if ((x->aead->alg_key_len != 128 + 32) &&
+	    (x->aead->alg_key_len != 256 + 32)) {
+		pr_debug("CHCR: Cannot offload xfrm states with AEAD key length other than 128/256 bit\n");
+		return -EINVAL;
+	}
+	if (x->tfcpad) {
+		pr_debug("CHCR: Cannot offload xfrm states with tfc padding\n");
+		return -EINVAL;
+	}
+	if (!x->geniv) {
+		pr_debug("CHCR: Cannot offload xfrm states without geniv\n");
+		return -EINVAL;
+	}
+	if (strcmp(x->geniv, "seqiv")) {
+		pr_debug("CHCR: Cannot offload xfrm states with geniv other than seqiv\n");
+		return -EINVAL;
+	}
+
+	sa_entry = kzalloc(sizeof(*sa_entry), GFP_KERNEL);
+	if (!sa_entry) {
+		res = -ENOMEM;
+		goto out;
+	}
+
+	sa_entry->hmac_ctrl = chcr_ipsec_setauthsize(x, sa_entry);
+	chcr_ipsec_setkey(x, sa_entry);
+	x->xso.offload_handle = (unsigned long)sa_entry;
+	try_module_get(THIS_MODULE);
+out:
+	return res;
+}
+
+static void chcr_xfrm_del_state(struct xfrm_state *x)
+{
+	/* do nothing */
+	if (!x->xso.offload_handle)
+		return;
+}
+
+static void chcr_xfrm_free_state(struct xfrm_state *x)
+{
+	struct ipsec_sa_entry *sa_entry;
+
+	if (!x->xso.offload_handle)
+		return;
+
+	sa_entry = (struct ipsec_sa_entry *)x->xso.offload_handle;
+	kfree(sa_entry);
+	module_put(THIS_MODULE);
+}
+
+static bool chcr_ipsec_offload_ok(struct sk_buff *skb, struct xfrm_state *x)
+{
+	/* Offload with IP options is not supported yet */
+	if (ip_hdr(skb)->ihl > 5)
+		return false;
+
+	return true;
+}
+
+static inline int is_eth_imm(const struct sk_buff *skb, unsigned int kctx_len)
+{
+	int hdrlen = sizeof(struct chcr_ipsec_req) + kctx_len;
+
+	hdrlen += sizeof(struct cpl_tx_pkt);
+	if (skb->len <= MAX_IMM_TX_PKT_LEN - hdrlen)
+		return hdrlen;
+	return 0;
+}
+
+static inline unsigned int calc_tx_sec_flits(const struct sk_buff *skb,
+					     unsigned int kctx_len)
+{
+	unsigned int flits;
+	int hdrlen = is_eth_imm(skb, kctx_len);
+
+	/* If the skb is small enough, we can pump it out as a work request
+	 * with only immediate data.  In that case we just have to have the
+	 * TX Packet header plus the skb data in the Work Request.
+	 */
+
+	if (hdrlen)
+		return DIV_ROUND_UP(skb->len + hdrlen, sizeof(__be64));
+
+	flits = sgl_len(skb_shinfo(skb)->nr_frags + 1);
+
+	/* Otherwise, we're going to have to construct a Scatter gather list
+	 * of the skb body and fragments.  We also include the flits necessary
+	 * for the TX Packet Work Request and CPL.  We always have a firmware
+	 * Write Header (incorporated as part of the cpl_tx_pkt_lso and
+	 * cpl_tx_pkt structures), followed by either a TX Packet Write CPL
+	 * message or, if we're doing a Large Send Offload, an LSO CPL message
+	 * with an embedded TX Packet Write CPL message.
+	 */
+	flits += (sizeof(struct fw_ulptx_wr) +
+		  sizeof(struct chcr_ipsec_req) +
+		  kctx_len +
+		  sizeof(struct cpl_tx_pkt_core)) / sizeof(__be64);
+	return flits;
+}
+
+inline void *copy_cpltx_pktxt(struct sk_buff *skb,
+				struct net_device *dev,
+				void *pos)
+{
+	struct adapter *adap;
+	struct port_info *pi;
+	struct sge_eth_txq *q;
+	struct cpl_tx_pkt_core *cpl;
+	u64 cntrl;
+	u32 ctrl0, qidx;
+
+	pi = netdev_priv(dev);
+	adap = pi->adapter;
+	qidx = skb->queue_mapping;
+	q = &adap->sge.ethtxq[qidx + pi->first_qset];
+
+	cpl = (struct cpl_tx_pkt_core *)pos;
+
+	if (skb->ip_summed == CHECKSUM_PARTIAL)
+		cntrl = TXPKT_L4CSUM_DIS_F | TXPKT_IPCSUM_DIS_F;
+	ctrl0 = TXPKT_OPCODE_V(CPL_TX_PKT_XT) | TXPKT_INTF_V(pi->tx_chan) |
+			       TXPKT_PF_V(adap->pf);
+	if (skb_vlan_tag_present(skb)) {
+		q->vlan_ins++;
+		cntrl |= TXPKT_VLAN_VLD_F | TXPKT_VLAN_V(skb_vlan_tag_get(skb));
+	}
+
+	cpl->ctrl0 = htonl(ctrl0);
+	cpl->pack = htons(0);
+	cpl->len = htons(skb->len);
+	cpl->ctrl1 = cpu_to_be64(cntrl);
+
+	pos += sizeof(struct cpl_tx_pkt_core);
+	return pos;
+}
+
+inline void *copy_key_cpltx_pktxt(struct sk_buff *skb,
+				struct net_device *dev,
+				void *pos,
+				struct ipsec_sa_entry *sa_entry)
+{
+	struct adapter *adap;
+	struct port_info *pi;
+	struct sge_eth_txq *q;
+	unsigned int len, qidx;
+	struct _key_ctx *key_ctx;
+	int left, eoq, key_len;
+
+	pi = netdev_priv(dev);
+	adap = pi->adapter;
+	qidx = skb->queue_mapping;
+	q = &adap->sge.ethtxq[qidx + pi->first_qset];
+	len = sa_entry->enckey_len + sizeof(struct cpl_tx_pkt_core);
+	key_len = sa_entry->kctx_len;
+
+	/* end of queue, reset pos to start of queue */
+	eoq = (void *)q->q.stat - pos;
+	left = eoq;
+	if (!eoq) {
+		pos = q->q.desc;
+		left = 64 * q->q.size;
+	}
+
+	/* Copy the Key context header */
+	key_ctx = (struct _key_ctx *)pos;
+	key_ctx->ctx_hdr = sa_entry->key_ctx_hdr;
+	memcpy(key_ctx->salt, sa_entry->salt, MAX_SALT);
+	pos += sizeof(struct _key_ctx);
+	left -= sizeof(struct _key_ctx);
+
+	if (likely(len <= left)) {
+		memcpy(key_ctx->key, sa_entry->key, key_len);
+		pos += key_len;
+	} else {
+		if (key_len <= left) {
+			memcpy(pos, sa_entry->key, key_len);
+			pos += key_len;
+		} else {
+			memcpy(pos, sa_entry->key, left);
+			memcpy(q->q.desc, sa_entry->key + left,
+			       key_len - left);
+			pos = q->q.desc + (key_len - left);
+		}
+	}
+	/* Copy CPL TX PKT XT */
+	pos = copy_cpltx_pktxt(skb, dev, pos);
+
+	return pos;
+}
+
+inline void *chcr_crypto_wreq(struct sk_buff *skb,
+			       struct net_device *dev,
+			       void *pos,
+			       int credits,
+			       struct ipsec_sa_entry *sa_entry)
+{
+	struct port_info *pi = netdev_priv(dev);
+	struct adapter *adap = pi->adapter;
+	unsigned int immdatalen = 0;
+	unsigned int ivsize = GCM_ESP_IV_SIZE;
+	struct chcr_ipsec_wr *wr;
+	unsigned int flits;
+	u32 wr_mid;
+	int qidx = skb_get_queue_mapping(skb);
+	struct sge_eth_txq *q = &adap->sge.ethtxq[qidx + pi->first_qset];
+	unsigned int kctx_len = sa_entry->kctx_len;
+	int qid = q->q.cntxt_id;
+
+	atomic_inc(&adap->chcr_stats.ipsec_cnt);
+
+	flits = calc_tx_sec_flits(skb, kctx_len);
+
+	if (is_eth_imm(skb, kctx_len))
+		immdatalen = skb->len;
+
+	/* WR Header */
+	wr = (struct chcr_ipsec_wr *)pos;
+	wr->wreq.op_to_compl = htonl(FW_WR_OP_V(FW_ULPTX_WR));
+	wr_mid = FW_CRYPTO_LOOKASIDE_WR_LEN16_V(DIV_ROUND_UP(flits, 2));
+
+	if (unlikely(credits < ETHTXQ_STOP_THRES)) {
+		netif_tx_stop_queue(q->txq);
+		q->q.stops++;
+		wr_mid |= FW_WR_EQUEQ_F | FW_WR_EQUIQ_F;
+	}
+	wr_mid |= FW_ULPTX_WR_DATA_F;
+	wr->wreq.flowid_len16 = htonl(wr_mid);
+
+	/* ULPTX */
+	wr->req.ulptx.cmd_dest = FILL_ULPTX_CMD_DEST(pi->port_id, qid);
+	wr->req.ulptx.len = htonl(DIV_ROUND_UP(flits, 2)  - 1);
+
+	/* Sub-command */
+	wr->req.sc_imm.cmd_more = FILL_CMD_MORE(immdatalen);
+	wr->req.sc_imm.len = cpu_to_be32(sizeof(struct cpl_tx_sec_pdu) +
+					 sizeof(wr->req.key_ctx) +
+					 kctx_len +
+					 sizeof(struct cpl_tx_pkt_core) +
+					 immdatalen);
+
+	/* CPL_SEC_PDU */
+	wr->req.sec_cpl.op_ivinsrtofst = htonl(
+				CPL_TX_SEC_PDU_OPCODE_V(CPL_TX_SEC_PDU) |
+				CPL_TX_SEC_PDU_CPLLEN_V(2) |
+				CPL_TX_SEC_PDU_PLACEHOLDER_V(1) |
+				CPL_TX_SEC_PDU_IVINSRTOFST_V(
+				(skb_transport_offset(skb) +
+				sizeof(struct ip_esp_hdr) + 1)));
+
+	wr->req.sec_cpl.pldlen = htonl(skb->len);
+
+	wr->req.sec_cpl.aadstart_cipherstop_hi = FILL_SEC_CPL_CIPHERSTOP_HI(
+				(skb_transport_offset(skb) + 1),
+				(skb_transport_offset(skb) +
+				 sizeof(struct ip_esp_hdr)),
+				(skb_transport_offset(skb) +
+				 sizeof(struct ip_esp_hdr) +
+				 GCM_ESP_IV_SIZE + 1), 0);
+
+	wr->req.sec_cpl.cipherstop_lo_authinsert =
+		FILL_SEC_CPL_AUTHINSERT(0, skb_transport_offset(skb) +
+					   sizeof(struct ip_esp_hdr) +
+					   GCM_ESP_IV_SIZE + 1,
+					   sa_entry->authsize,
+					   sa_entry->authsize);
+	wr->req.sec_cpl.seqno_numivs =
+		FILL_SEC_CPL_SCMD0_SEQNO(CHCR_ENCRYPT_OP, 1,
+					 CHCR_SCMD_CIPHER_MODE_AES_GCM,
+					 CHCR_SCMD_AUTH_MODE_GHASH,
+					 sa_entry->hmac_ctrl,
+					 ivsize >> 1);
+	wr->req.sec_cpl.ivgen_hdrlen =  FILL_SEC_CPL_IVGEN_HDRLEN(0, 0, 1,
+								  0, 0, 0);
+
+	pos += sizeof(struct fw_ulptx_wr) +
+	       sizeof(struct ulp_txpkt) +
+	       sizeof(struct ulptx_idata) +
+	       sizeof(struct cpl_tx_sec_pdu);
+
+	pos = copy_key_cpltx_pktxt(skb, dev, pos, sa_entry);
+
+	return pos;
+}
+
+/**
+ *      flits_to_desc - returns the num of Tx descriptors for the given flits
+ *      @n: the number of flits
+ *
+ *      Returns the number of Tx descriptors needed for the supplied number
+ *      of flits.
+ */
+static inline unsigned int flits_to_desc(unsigned int n)
+{
+	WARN_ON(n > SGE_MAX_WR_LEN / 8);
+	return DIV_ROUND_UP(n, 8);
+}
+
+static inline unsigned int txq_avail(const struct sge_txq *q)
+{
+	return q->size - 1 - q->in_use;
+}
+
+static void eth_txq_stop(struct sge_eth_txq *q)
+{
+	netif_tx_stop_queue(q->txq);
+	q->q.stops++;
+}
+
+static inline void txq_advance(struct sge_txq *q, unsigned int n)
+{
+	q->in_use += n;
+	q->pidx += n;
+	if (q->pidx >= q->size)
+		q->pidx -= q->size;
+}
+
+/*
+ *      chcr_ipsec_xmit called from ULD Tx handler
+ */
+int chcr_ipsec_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct xfrm_state *x = xfrm_input_state(skb);
+	struct ipsec_sa_entry *sa_entry;
+	u64 *pos, *end, *before, cntrl, *sgl;
+	int qidx, left, credits;
+	unsigned int flits = 0, ndesc, kctx_len;
+	struct adapter *adap;
+	struct sge_eth_txq *q;
+	struct port_info *pi;
+	dma_addr_t addr[MAX_SKB_FRAGS + 1];
+	bool immediate = false;
+
+	if (!x->xso.offload_handle)
+		return NETDEV_TX_BUSY;
+
+	sa_entry = (struct ipsec_sa_entry *)x->xso.offload_handle;
+	kctx_len = sa_entry->kctx_len;
+
+	if (skb->sp->len != 1) {
+out_free:       dev_kfree_skb_any(skb);
+		return NETDEV_TX_OK;
+	}
+
+	pi = netdev_priv(dev);
+	adap = pi->adapter;
+	qidx = skb->queue_mapping;
+	q = &adap->sge.ethtxq[qidx + pi->first_qset];
+
+	cxgb4_reclaim_completed_tx(adap, &q->q, true);
+	cntrl = TXPKT_L4CSUM_DIS_F | TXPKT_IPCSUM_DIS_F;
+
+	flits = calc_tx_sec_flits(skb, sa_entry->kctx_len);
+	ndesc = flits_to_desc(flits);
+	credits = txq_avail(&q->q) - ndesc;
+
+	if (unlikely(credits < 0)) {
+		eth_txq_stop(q);
+		dev_err(adap->pdev_dev,
+			"%s: Tx ring %u full while queue awake! cred:%d %d %d flits:%d\n",
+			dev->name, qidx, credits, ndesc, txq_avail(&q->q),
+			flits);
+		return NETDEV_TX_BUSY;
+	}
+
+	if (is_eth_imm(skb, kctx_len))
+		immediate = true;
+
+	if (!immediate &&
+	    unlikely(cxgb4_map_skb(adap->pdev_dev, skb, addr) < 0)) {
+		q->mapping_err++;
+		goto out_free;
+	}
+
+	pos = (u64 *)&q->q.desc[q->q.pidx];
+	before = (u64 *)pos;
+	end = (u64 *)pos + flits;
+	/* Setup IPSec CPL */
+	pos = (void *)chcr_crypto_wreq(skb, dev, (void *)pos,
+				       credits, sa_entry);
+	if (before > (u64 *)pos) {
+		left = (u8 *)end - (u8 *)q->q.stat;
+		end = (void *)q->q.desc + left;
+	}
+	if (pos == (u64 *)q->q.stat) {
+		left = (u8 *)end - (u8 *)q->q.stat;
+		end = (void *)q->q.desc + left;
+		pos = (void *)q->q.desc;
+	}
+
+	sgl = (void *)pos;
+	if (immediate) {
+		cxgb4_inline_tx_skb(skb, &q->q, sgl);
+		dev_consume_skb_any(skb);
+	} else {
+		int last_desc;
+
+		cxgb4_write_sgl(skb, &q->q, (void *)sgl, end,
+				0, addr);
+		skb_orphan(skb);
+
+		last_desc = q->q.pidx + ndesc - 1;
+		if (last_desc >= q->q.size)
+			last_desc -= q->q.size;
+		q->q.sdesc[last_desc].skb = skb;
+		q->q.sdesc[last_desc].sgl = (struct ulptx_sgl *)sgl;
+	}
+	txq_advance(&q->q, ndesc);
+
+	cxgb4_ring_tx_db(adap, &q->q, ndesc);
+	return NETDEV_TX_OK;
+}
