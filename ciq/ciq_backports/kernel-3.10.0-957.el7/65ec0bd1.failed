vmxnet3: fix incorrect dereference when rxvlan is disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ronak Doshi <doshir@vmware.com>
commit 65ec0bd1c7c14522670a5294de35710fb577a7fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/65ec0bd1.failed

vmxnet3_get_hdr_len() is used to calculate the header length which in
turn is used to calculate the gso_size for skb. When rxvlan offload is
disabled, vlan tag is present in the header and the function references
ip header from sizeof(ethhdr) and leads to incorrect pointer reference.

This patch fixes this issue by taking sizeof(vlan_ethhdr) into account
if vlan tag is present and correctly references the ip hdr.

	Signed-off-by: Ronak Doshi <doshir@vmware.com>
	Acked-by: Guolin Yang <gyang@vmware.com>
	Acked-by: Louis Luo <llouis@vmware.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 65ec0bd1c7c14522670a5294de35710fb577a7fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vmxnet3/vmxnet3_int.h
diff --cc drivers/net/vmxnet3/vmxnet3_int.h
index 280bdc39a696,a3326463b71f..000000000000
--- a/drivers/net/vmxnet3/vmxnet3_int.h
+++ b/drivers/net/vmxnet3/vmxnet3_int.h
@@@ -69,10 -69,10 +69,17 @@@
  /*
   * Version numbers
   */
++<<<<<<< HEAD
 +#define VMXNET3_DRIVER_VERSION_STRING   "1.4.8.0-k"
 +
 +/* a 32-bit int, each byte encode a verion number in VMXNET3_DRIVER_VERSION */
 +#define VMXNET3_DRIVER_VERSION_NUM      0x01040800
++=======
+ #define VMXNET3_DRIVER_VERSION_STRING   "1.4.14.0-k"
+ 
+ /* a 32-bit int, each byte encode a verion number in VMXNET3_DRIVER_VERSION */
+ #define VMXNET3_DRIVER_VERSION_NUM      0x01040e00
++>>>>>>> 65ec0bd1c7c1 (vmxnet3: fix incorrect dereference when rxvlan is disabled)
  
  #if defined(CONFIG_PCI_MSI)
  	/* RSS only makes sense if MSI-X is supported. */
diff --git a/drivers/net/vmxnet3/vmxnet3_drv.c b/drivers/net/vmxnet3/vmxnet3_drv.c
index dc2836e614d9..164a7abf63d2 100644
--- a/drivers/net/vmxnet3/vmxnet3_drv.c
+++ b/drivers/net/vmxnet3/vmxnet3_drv.c
@@ -1212,6 +1212,7 @@ vmxnet3_get_hdr_len(struct vmxnet3_adapter *adapter, struct sk_buff *skb,
 	union {
 		void *ptr;
 		struct ethhdr *eth;
+		struct vlan_ethhdr *veth;
 		struct iphdr *ipv4;
 		struct ipv6hdr *ipv6;
 		struct tcphdr *tcp;
@@ -1222,16 +1223,24 @@ vmxnet3_get_hdr_len(struct vmxnet3_adapter *adapter, struct sk_buff *skb,
 	if (unlikely(sizeof(struct iphdr) + sizeof(struct tcphdr) > maplen))
 		return 0;
 
+	if (skb->protocol == cpu_to_be16(ETH_P_8021Q) ||
+	    skb->protocol == cpu_to_be16(ETH_P_8021AD))
+		hlen = sizeof(struct vlan_ethhdr);
+	else
+		hlen = sizeof(struct ethhdr);
+
 	hdr.eth = eth_hdr(skb);
 	if (gdesc->rcd.v4) {
-		BUG_ON(hdr.eth->h_proto != htons(ETH_P_IP));
-		hdr.ptr += sizeof(struct ethhdr);
+		BUG_ON(hdr.eth->h_proto != htons(ETH_P_IP) &&
+		       hdr.veth->h_vlan_encapsulated_proto != htons(ETH_P_IP));
+		hdr.ptr += hlen;
 		BUG_ON(hdr.ipv4->protocol != IPPROTO_TCP);
 		hlen = hdr.ipv4->ihl << 2;
 		hdr.ptr += hdr.ipv4->ihl << 2;
 	} else if (gdesc->rcd.v6) {
-		BUG_ON(hdr.eth->h_proto != htons(ETH_P_IPV6));
-		hdr.ptr += sizeof(struct ethhdr);
+		BUG_ON(hdr.eth->h_proto != htons(ETH_P_IPV6) &&
+		       hdr.veth->h_vlan_encapsulated_proto != htons(ETH_P_IPV6));
+		hdr.ptr += hlen;
 		/* Use an estimated value, since we also need to handle
 		 * TSO case.
 		 */
* Unmerged path drivers/net/vmxnet3/vmxnet3_int.h
