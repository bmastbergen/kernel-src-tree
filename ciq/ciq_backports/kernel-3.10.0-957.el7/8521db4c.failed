net_sch: cbs: Change TC_SETUP_CBS to TC_SETUP_QDISC_CBS

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] sched: cbs: Change TC_SETUP_CBS to TC_SETUP_QDISC_CBS (Ivan Vecera) [1557250]
Rebuild_FUZZ: 94.44%
commit-author Nogah Frankel <nogahf@mellanox.com>
commit 8521db4c7e155d12fb280686c0552e47f77e9110
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8521db4c.failed

Change TC_SETUP_CBS to TC_SETUP_QDISC_CBS to match the new convention..

	Signed-off-by: Nogah Frankel <nogahf@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Acked-by: Vinicius Costa Gomes <vinicius.gomes@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8521db4c7e155d12fb280686c0552e47f77e9110)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	net/sched/sch_cbs.c
diff --cc include/linux/netdevice.h
index dbc794e21d64,30f0f2928808..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -814,176 -775,15 +814,182 @@@ enum tc_setup_type 
  	TC_SETUP_CLSFLOWER,
  	TC_SETUP_CLSMATCHALL,
  	TC_SETUP_CLSBPF,
++<<<<<<< HEAD
++=======
+ 	TC_SETUP_BLOCK,
+ 	TC_SETUP_QDISC_CBS,
+ 	TC_SETUP_QDISC_RED,
++>>>>>>> 8521db4c7e15 (net_sch: cbs: Change TC_SETUP_CBS to TC_SETUP_QDISC_CBS)
  };
  
 -/* These structures hold the attributes of bpf state that are being passed
 - * to the netdevice through the bpf op.
 +/* Forward declaration of tc_to_netdev structure used by __rh_call_ndo_setup_tc
 + * wrapper for out-of-tree drivers compiled against RHEL7.4.
   */
 -enum bpf_netdev_command {
 +struct tc_to_netdev_rh74;
 +
 +struct tc_cls_u32_offload;
 +
 +struct tc_to_netdev {
 +	unsigned int type;
 +	union {
 +		u8 tc;
 +		struct tc_cls_u32_offload *cls_u32;
 +		struct tc_cls_flower_offload *cls_flower;
 +		struct tc_cls_matchall_offload *cls_mall;
 +		struct tc_cls_bpf_offload *cls_bpf;
 +	};
 +	bool egress_dev;
 +};
 +
 +/* This structure defines the management hooks for network devices.
 + * It is an extension of net_device_ops. Drivers that want to use any of the
 + * fields defined here must initialize net_device_ops->ndo_size to
 + * sizeof(struct net_device_ops).
 + *
 + * void* (*ndo_dfwd_add_station)(struct net_device *pdev,
 + *				 struct net_device *dev)
 + *	Called by upper layer devices to accelerate switching or other
 + *	station functionality into hardware. 'pdev is the lowerdev
 + *	to use for the offload and 'dev' is the net device that will
 + *	back the offload. Returns a pointer to the private structure
 + *	the upper layer will maintain.
 + * void (*ndo_dfwd_del_station)(struct net_device *pdev, void *priv)
 + *	Called by upper layer device to delete the station created
 + *	by 'ndo_dfwd_add_station'. 'pdev' is the net device backing
 + *	the station and priv is the structure returned by the add
 + *	operation.
 + * int (*ndo_set_tx_maxrate)(struct net_device *dev,
 + *			     int queue_index, u32 maxrate);
 + *	Called when a user wants to set a max-rate limitation of specific
 + *	TX queue.
 + * void (*ndo_set_rx_headroom)(struct net_device *dev, int needed_headroom);
 + *	This function is used to specify the headroom that the skb must
 + *	consider when allocation skb during packet reception. Setting
 + *	appropriate rx headroom value allows avoiding skb head copy on
 + *	forward. Setting a negative value reset the rx headroom to the
 + *	default value.
 + * int (*ndo_fdb_dump)(struct sk_buff *skb, struct netlink_callback *cb,
 + *		       struct net_device *dev, struct net_device *filter_dev,
 + *		       int *idx)
 + *	Used to add FDB entries to dump requests. Implementers should add
 + *	entries to skb and update idx with the number of entries.
 + * void (*ndo_change_proto_down)(struct net_device *dev,
 + *				 bool proto_down);
 + *	This function is used to pass protocol port error state information
 + *	to the switch driver. The switch driver can react to the proto_down
 + *      by doing a phys down on the associated switch port.
 + * void (*ndo_udp_tunnel_add)(struct net_device *dev,
 + *			      struct udp_tunnel_info *ti);
 + *	Called by UDP tunnel to notify a driver about the UDP port and socket
 + *	address family that a UDP tunnel is listnening to. It is called only
 + *	when a new port starts listening. The operation is protected by the
 + *	RTNL.
 + *
 + * void (*ndo_udp_tunnel_del)(struct net_device *dev,
 + *			      struct udp_tunnel_info *ti);
 + *	Called by UDP tunnel to notify the driver about a UDP port and socket
 + *	address family that the UDP tunnel is not listening to anymore. The
 + *	operation is protected by the RTNL.
 + *
 + * int (*ndo_set_vf_vlan)(struct net_device *dev, int vf, u16 vlan,
 + *			  u8 qos, __be16 proto);
 + *
 + * bool (*ndo_has_offload_stats)(const struct net_device *dev, int attr_id)
 + *	Return true if this device supports offload stats of this attr_id.
 + *
 + * int (*ndo_get_offload_stats)(int attr_id, const struct net_device *dev,
 + *	void *attr_data)
 + *	Get statistics for offload operations by attr_id. Write it into the
 + *	attr_data pointer.
 + *
 + * int (*ndo_change_mtu)(struct net_device *dev, int new_mtu);
 + *	Called when a user wants to change the Maximum Transfer Unit
 + *	of a device.
 + *	RHEL: This is an entry point for network device drivers that
 + *	      use central MTU range checking provided by network core.
 + *
 + * int (*ndo_setup_tc)(struct net_device *dev, enum tc_setup_type type,
 + *		       void *type_data);
 + *	Called to setup any 'tc' scheduler, classifier or action on @dev.
 + *	This is always called from the stack with the rtnl lock held and netif
 + *	tx queues stopped. This allows the netdevice to perform queue
 + *	management safely.
 + *	RHEL: Note that this callback is not part of kABI and its prototype
 + *	and semantic can be changed across releases.
 + * int (*ndo_xdp)(struct net_device *dev, struct netdev_xdp *xdp);
 + *	This function is used to set or query state related to XDP on the
 + *	netdevice. See definition of enum xdp_netdev_command for details.
 + * int (*ndo_xdp_xmit)(struct net_device *dev, struct xdp_buff *xdp);
 + *	This function is used to submit a XDP packet for transmit on a
 + *	netdevice.
 + * void (*ndo_xdp_flush)(struct net_device *dev);
 + *	This function is used to inform the driver to flush a paticular
 + *	xpd tx queue. Must be called on same CPU as xdp_xmit.
 + */
 +struct net_device_ops_extended {
 +	int			(*ndo_set_vf_trust)(struct net_device *dev,
 +						    int vf, bool setting);
 +	void*			(*ndo_dfwd_add_station)(struct net_device *pdev,
 +							struct net_device *dev);
 +	void			(*ndo_dfwd_del_station)(struct net_device *pdev,
 +							void *priv);
 +	int			(*ndo_set_tx_maxrate)(struct net_device *dev,
 +						      int queue_index,
 +						      u32 maxrate);
 +	void			(*ndo_set_rx_headroom)(struct net_device *dev,
 +						       int needed_headroom);
 +	int			(*ndo_set_vf_guid)(struct net_device *dev,
 +						   int vf, u64 guid,
 +						   int guid_type);
 +	int			(*ndo_fdb_dump_rh73)(struct sk_buff *skb,
 +						struct netlink_callback *cb,
 +						struct net_device *dev,
 +						struct net_device *filter_dev,
 +						int idx);
 +	int			(*ndo_get_phys_port_name)(struct net_device *dev,
 +							  char *name, size_t len);
 +	int			(*ndo_change_proto_down)(struct net_device *dev,
 +							 bool proto_down);
 +	void			(*ndo_udp_tunnel_add)(struct net_device *dev,
 +						      struct udp_tunnel_info *ti);
 +	void			(*ndo_udp_tunnel_del)(struct net_device *dev,
 +						      struct udp_tunnel_info *ti);
 +	int			(*ndo_neigh_construct)(struct net_device *dev,
 +						       struct neighbour *n);
 +	void			(*ndo_neigh_destroy)(struct net_device *dev,
 +						     struct neighbour *n);
 +	int			(*ndo_set_vf_vlan)(struct net_device *dev,
 +						   int vf, u16 vlan, u8 qos,
 +						   __be16 proto);
 +	int			(*ndo_fdb_dump)(struct sk_buff *skb,
 +						struct netlink_callback *cb,
 +						struct net_device *dev,
 +						struct net_device *filter_dev,
 +						int *idx);
 +	bool			(*ndo_has_offload_stats)(const struct net_device *dev, int attr_id);
 +	int			(*ndo_get_offload_stats)(int attr_id,
 +							 const struct net_device *dev,
 +							 void *attr_data);
 +	int			(*ndo_change_mtu)(struct net_device *dev,
 +						  int new_mtu);
 +	/*
 +	 * RHEL: Note that this callback is not part of kABI and its prototype
 +	 * and semantic can be changed across releases.
 +	 */
 +	int			(*ndo_setup_tc_rh)(struct net_device *dev,
 +						   enum tc_setup_type type,
 +						   void *type_data);
 +	int			(*ndo_xdp)(struct net_device *dev,
 +						  struct netdev_xdp *xdp);
 +	int                     (*ndo_xdp_xmit)(struct net_device *dev,
 +						struct xdp_buff *xdp);
 +	void                    (*ndo_xdp_flush)(struct net_device *dev);
 +};
 +
 +/* These structures hold the attributes of xdp state that are being passed
 + * to the netdevice through the xdp op.
 + */
 +enum xdp_netdev_command {
  	/* Set or clear a bpf program used in the earliest stages of packet
  	 * rx. The prog will have been loaded as BPF_PROG_TYPE_XDP. The callee
  	 * is responsible for calling bpf_prog_put on any old progs that are
diff --cc net/sched/sch_cbs.c
index 0e85133c5653,7a72980c1509..000000000000
--- a/net/sched/sch_cbs.c
+++ b/net/sched/sch_cbs.c
@@@ -180,6 -192,60 +180,63 @@@ static const struct nla_policy cbs_poli
  	[TCA_CBS_PARMS]	= { .len = sizeof(struct tc_cbs_qopt) },
  };
  
++<<<<<<< HEAD
++=======
+ static void cbs_disable_offload(struct net_device *dev,
+ 				struct cbs_sched_data *q)
+ {
+ 	struct tc_cbs_qopt_offload cbs = { };
+ 	const struct net_device_ops *ops;
+ 	int err;
+ 
+ 	if (!q->offload)
+ 		return;
+ 
+ 	q->enqueue = cbs_enqueue_soft;
+ 	q->dequeue = cbs_dequeue_soft;
+ 
+ 	ops = dev->netdev_ops;
+ 	if (!ops->ndo_setup_tc)
+ 		return;
+ 
+ 	cbs.queue = q->queue;
+ 	cbs.enable = 0;
+ 
+ 	err = ops->ndo_setup_tc(dev, TC_SETUP_QDISC_CBS, &cbs);
+ 	if (err < 0)
+ 		pr_warn("Couldn't disable CBS offload for queue %d\n",
+ 			cbs.queue);
+ }
+ 
+ static int cbs_enable_offload(struct net_device *dev, struct cbs_sched_data *q,
+ 			      const struct tc_cbs_qopt *opt)
+ {
+ 	const struct net_device_ops *ops = dev->netdev_ops;
+ 	struct tc_cbs_qopt_offload cbs = { };
+ 	int err;
+ 
+ 	if (!ops->ndo_setup_tc)
+ 		return -EOPNOTSUPP;
+ 
+ 	cbs.queue = q->queue;
+ 
+ 	cbs.enable = 1;
+ 	cbs.hicredit = opt->hicredit;
+ 	cbs.locredit = opt->locredit;
+ 	cbs.idleslope = opt->idleslope;
+ 	cbs.sendslope = opt->sendslope;
+ 
+ 	err = ops->ndo_setup_tc(dev, TC_SETUP_QDISC_CBS, &cbs);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	q->enqueue = cbs_enqueue_offload;
+ 	q->dequeue = cbs_dequeue_offload;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 8521db4c7e15 (net_sch: cbs: Change TC_SETUP_CBS to TC_SETUP_QDISC_CBS)
  static int cbs_change(struct Qdisc *sch, struct nlattr *opt)
  {
  	struct cbs_sched_data *q = qdisc_priv(sch);
diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c
index df2cf937d8e9..260065be8ea8 100644
--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@ -2490,7 +2490,7 @@ static int igb_setup_tc(struct net_device *dev, enum tc_setup_type type,
 	struct igb_adapter *adapter = netdev_priv(dev);
 
 	switch (type) {
-	case TC_SETUP_CBS:
+	case TC_SETUP_QDISC_CBS:
 		return igb_offload_cbs(adapter, type_data);
 
 	default:
* Unmerged path include/linux/netdevice.h
* Unmerged path net/sched/sch_cbs.c
