mmc: block: Fix bug when removing RPMB chardev

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] block: Fix bug when removing RPMB chardev (Gopal Tiwari) [1456570]
Rebuild_FUZZ: 94.25%
commit-author Linus Walleij <linus.walleij@linaro.org>
commit 1c87f73578497a6c3cc77bcbfd2e5bf15fe753c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1c87f735.failed

I forgot to account for the fact that the device core holds a
reference to a device added with device_initialize() that need
to be released with a corresponding put_device() to reach a 0
refcount at the end of the lifecycle.

This led to a NULL pointer reference when freeing the device
when e.g. unbidning the host device in sysfs.

Fix this and use the device .release() callback to free the
IDA and free:ing the memory used by the RPMB device.

Before this patch:

/sys/bus/amba/drivers/mmci-pl18x$ echo 80114000.sdi4_per2 > unbind
[   29.797332] mmc3: card 0001 removed
[   29.810791] Unable to handle kernel NULL pointer dereference at
               virtual address 00000050
[   29.818878] pgd = de70c000
[   29.821624] [00000050] *pgd=1e70a831, *pte=00000000, *ppte=00000000
[   29.827911] Internal error: Oops: 17 [#1] PREEMPT SMP ARM
[   29.833282] Modules linked in:
[   29.836334] CPU: 1 PID: 154 Comm: sh Not tainted
               4.14.0-rc3-00039-g83318e309566-dirty #736
[   29.844604] Hardware name: ST-Ericsson Ux5x0 platform (Device Tree Support)
[   29.851562] task: de572700 task.stack: de742000
[   29.856079] PC is at kernfs_find_ns+0x8/0x100
[   29.860443] LR is at kernfs_find_and_get_ns+0x30/0x48

After this patch:

/sys/bus/amba/drivers/mmci-pl18x$ echo 80005000.sdi4_per2 > unbind
[   20.623382] mmc3: card 0001 removed

Fixes: 97548575bef3 ("mmc: block: Convert RPMB to a character device")
	Reported-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
	Acked-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 1c87f73578497a6c3cc77bcbfd2e5bf15fe753c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/block.c
diff --cc drivers/mmc/core/block.c
index bf17147e2808,f11537a66a60..000000000000
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@@ -2043,6 -2228,158 +2043,161 @@@ static int mmc_blk_alloc_part(struct mm
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * mmc_rpmb_ioctl() - ioctl handler for the RPMB chardev
+  * @filp: the character device file
+  * @cmd: the ioctl() command
+  * @arg: the argument from userspace
+  *
+  * This will essentially just redirect the ioctl()s coming in over to
+  * the main block device spawning the RPMB character device.
+  */
+ static long mmc_rpmb_ioctl(struct file *filp, unsigned int cmd,
+ 			   unsigned long arg)
+ {
+ 	struct mmc_rpmb_data *rpmb = filp->private_data;
+ 	int ret;
+ 
+ 	switch (cmd) {
+ 	case MMC_IOC_CMD:
+ 		ret = mmc_blk_ioctl_cmd(rpmb->md,
+ 					(struct mmc_ioc_cmd __user *)arg,
+ 					rpmb);
+ 		break;
+ 	case MMC_IOC_MULTI_CMD:
+ 		ret = mmc_blk_ioctl_multi_cmd(rpmb->md,
+ 					(struct mmc_ioc_multi_cmd __user *)arg,
+ 					rpmb);
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_COMPAT
+ static long mmc_rpmb_ioctl_compat(struct file *filp, unsigned int cmd,
+ 			      unsigned long arg)
+ {
+ 	return mmc_rpmb_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));
+ }
+ #endif
+ 
+ static int mmc_rpmb_chrdev_open(struct inode *inode, struct file *filp)
+ {
+ 	struct mmc_rpmb_data *rpmb = container_of(inode->i_cdev,
+ 						  struct mmc_rpmb_data, chrdev);
+ 
+ 	get_device(&rpmb->dev);
+ 	filp->private_data = rpmb;
+ 	mmc_blk_get(rpmb->md->disk);
+ 
+ 	return nonseekable_open(inode, filp);
+ }
+ 
+ static int mmc_rpmb_chrdev_release(struct inode *inode, struct file *filp)
+ {
+ 	struct mmc_rpmb_data *rpmb = container_of(inode->i_cdev,
+ 						  struct mmc_rpmb_data, chrdev);
+ 
+ 	put_device(&rpmb->dev);
+ 	mmc_blk_put(rpmb->md);
+ 
+ 	return 0;
+ }
+ 
+ static const struct file_operations mmc_rpmb_fileops = {
+ 	.release = mmc_rpmb_chrdev_release,
+ 	.open = mmc_rpmb_chrdev_open,
+ 	.owner = THIS_MODULE,
+ 	.llseek = no_llseek,
+ 	.unlocked_ioctl = mmc_rpmb_ioctl,
+ #ifdef CONFIG_COMPAT
+ 	.compat_ioctl = mmc_rpmb_ioctl_compat,
+ #endif
+ };
+ 
+ static void mmc_blk_rpmb_device_release(struct device *dev)
+ {
+ 	struct mmc_rpmb_data *rpmb = dev_get_drvdata(dev);
+ 
+ 	ida_simple_remove(&mmc_rpmb_ida, rpmb->id);
+ 	kfree(rpmb);
+ }
+ 
+ static int mmc_blk_alloc_rpmb_part(struct mmc_card *card,
+ 				   struct mmc_blk_data *md,
+ 				   unsigned int part_index,
+ 				   sector_t size,
+ 				   const char *subname)
+ {
+ 	int devidx, ret;
+ 	char rpmb_name[DISK_NAME_LEN];
+ 	char cap_str[10];
+ 	struct mmc_rpmb_data *rpmb;
+ 
+ 	/* This creates the minor number for the RPMB char device */
+ 	devidx = ida_simple_get(&mmc_rpmb_ida, 0, max_devices, GFP_KERNEL);
+ 	if (devidx < 0)
+ 		return devidx;
+ 
+ 	rpmb = kzalloc(sizeof(*rpmb), GFP_KERNEL);
+ 	if (!rpmb) {
+ 		ida_simple_remove(&mmc_rpmb_ida, devidx);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	snprintf(rpmb_name, sizeof(rpmb_name),
+ 		 "mmcblk%u%s", card->host->index, subname ? subname : "");
+ 
+ 	rpmb->id = devidx;
+ 	rpmb->part_index = part_index;
+ 	rpmb->dev.init_name = rpmb_name;
+ 	rpmb->dev.bus = &mmc_rpmb_bus_type;
+ 	rpmb->dev.devt = MKDEV(MAJOR(mmc_rpmb_devt), rpmb->id);
+ 	rpmb->dev.parent = &card->dev;
+ 	rpmb->dev.release = mmc_blk_rpmb_device_release;
+ 	device_initialize(&rpmb->dev);
+ 	dev_set_drvdata(&rpmb->dev, rpmb);
+ 	rpmb->md = md;
+ 
+ 	cdev_init(&rpmb->chrdev, &mmc_rpmb_fileops);
+ 	rpmb->chrdev.owner = THIS_MODULE;
+ 	ret = cdev_device_add(&rpmb->chrdev, &rpmb->dev);
+ 	if (ret) {
+ 		pr_err("%s: could not add character device\n", rpmb_name);
+ 		goto out_put_device;
+ 	}
+ 
+ 	list_add(&rpmb->node, &md->rpmbs);
+ 
+ 	string_get_size((u64)size, 512, STRING_UNITS_2,
+ 			cap_str, sizeof(cap_str));
+ 
+ 	pr_info("%s: %s %s partition %u %s, chardev (%d:%d)\n",
+ 		rpmb_name, mmc_card_id(card),
+ 		mmc_card_name(card), EXT_CSD_PART_CONFIG_ACC_RPMB, cap_str,
+ 		MAJOR(mmc_rpmb_devt), rpmb->id);
+ 
+ 	return 0;
+ 
+ out_put_device:
+ 	put_device(&rpmb->dev);
+ 	return ret;
+ }
+ 
+ static void mmc_blk_remove_rpmb_part(struct mmc_rpmb_data *rpmb)
+ 
+ {
+ 	cdev_device_del(&rpmb->chrdev, &rpmb->dev);
+ 	put_device(&rpmb->dev);
+ }
+ 
++>>>>>>> 1c87f7357849 (mmc: block: Fix bug when removing RPMB chardev)
  /* MMC Physical partitions consist of two boot partitions and
   * up to four general purpose partitions.
   * For each partition enabled in EXT_CSD a block device will be allocatedi
* Unmerged path drivers/mmc/core/block.c
