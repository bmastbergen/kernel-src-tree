watchdog: introduce watchdog_worker_should_ping helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [watchdog] introduce watchdog_worker_should_ping helper (David Arcari) [1576173]
Rebuild_FUZZ: 89.80%
commit-author Rasmus Villemoes <rasmus.villemoes@prevas.dk>
commit c013b65ad8a1e132f733404809afc72f7d00e768
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c013b65a.failed

This will be useful when the condition becomes slightly more
complicated in the next patch.

	Signed-off-by: Rasmus Villemoes <rasmus.villemoes@prevas.dk>
	Reviewed-by: Esben Haabendal <esben@haabendal.dk>
	Reviewed-by: Guenter Roeck <linux@roeck-us.net>
	Signed-off-by: Guenter Roeck <linux@roeck-us.net>
	Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
(cherry picked from commit c013b65ad8a1e132f733404809afc72f7d00e768)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/watchdog/watchdog_dev.c
diff --cc drivers/watchdog/watchdog_dev.c
index f06fbcf0bea2,0826e663bd5a..000000000000
--- a/drivers/watchdog/watchdog_dev.c
+++ b/drivers/watchdog/watchdog_dev.c
@@@ -61,26 -184,35 +61,47 @@@ static struct watchdog_device *old_wdd
  
  static int watchdog_ping(struct watchdog_device *wdd)
  {
 -	struct watchdog_core_data *wd_data = wdd->wd_data;
 +	int err = 0;
  
 -	if (!watchdog_active(wdd) && !watchdog_hw_running(wdd))
 -		return 0;
 +	mutex_lock(&wdd->lock);
  
 -	set_bit(_WDOG_KEEPALIVE, &wd_data->status);
 +	if (test_bit(WDOG_UNREGISTERED, &wdd->status)) {
 +		err = -ENODEV;
 +		goto out_ping;
 +	}
  
 -	wd_data->last_keepalive = jiffies;
 -	return __watchdog_ping(wdd);
 -}
 +	if (!watchdog_active(wdd))
 +		goto out_ping;
  
++<<<<<<< HEAD
 +	if (wdd->ops->ping)
 +		err = wdd->ops->ping(wdd);	/* ping the watchdog */
 +	else
 +		err = wdd->ops->start(wdd);	/* restart watchdog */
 +
 +out_ping:
 +	mutex_unlock(&wdd->lock);
 +	return err;
++=======
+ static bool watchdog_worker_should_ping(struct watchdog_core_data *wd_data)
+ {
+ 	struct watchdog_device *wdd = wd_data->wdd;
+ 
+ 	return wdd && (watchdog_active(wdd) || watchdog_hw_running(wdd));
+ }
+ 
+ static void watchdog_ping_work(struct work_struct *work)
+ {
+ 	struct watchdog_core_data *wd_data;
+ 
+ 	wd_data = container_of(to_delayed_work(work), struct watchdog_core_data,
+ 			       work);
+ 
+ 	mutex_lock(&wd_data->lock);
+ 	if (watchdog_worker_should_ping(wd_data))
+ 		__watchdog_ping(wd_data->wdd);
+ 	mutex_unlock(&wd_data->lock);
++>>>>>>> c013b65ad8a1 (watchdog: introduce watchdog_worker_should_ping helper)
  }
  
  /*
* Unmerged path drivers/watchdog/watchdog_dev.c
