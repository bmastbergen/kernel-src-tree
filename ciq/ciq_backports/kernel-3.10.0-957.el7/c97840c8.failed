scsi: tcmu: do not set max_blocks if data_bitmap has been setup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Mike Christie <mchristi@redhat.com>
commit c97840c84f5a4362a596a2751e9245a979377a16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c97840c8.failed

This patch prevents a bug where data_bitmap is allocated in
tcmu_configure_device, userspace changes the max_blocks setting, the device
is mapped to a LUN, then we try to access the data_bitmap based on the new
max_blocks limit which may now be out of range.

To prevent this, we just check if data_bitmap has been setup. If it has
then we fail the max_blocks update operation.

	Signed-off-by: Mike Christie <mchristi@redhat.com>
	Reviewed-by: Xiubo Li <xiubli@redhat.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit c97840c84f5a4362a596a2751e9245a979377a16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_user.c
diff --cc drivers/target/target_core_user.c
index 5534ef1b341c,969ccbaaccba..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -1214,8 -1795,27 +1214,32 @@@ static int tcmu_configure_device(struc
  	kfree(info->name);
  	info->name = str;
  
++<<<<<<< HEAD
 +	udev->data_bitmap = kzalloc(BITS_TO_LONGS(udev->max_blocks) *
 +				    sizeof(unsigned long), GFP_KERNEL);
++=======
+ 	return 0;
+ }
+ 
+ static int tcmu_configure_device(struct se_device *dev)
+ {
+ 	struct tcmu_dev *udev = TCMU_DEV(dev);
+ 	struct uio_info *info;
+ 	struct tcmu_mailbox *mb;
+ 	int ret = 0;
+ 
+ 	ret = tcmu_update_uio_info(udev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	info = &udev->uio_info;
+ 
+ 	mutex_lock(&udev->cmdr_lock);
+ 	udev->data_bitmap = kcalloc(BITS_TO_LONGS(udev->max_blocks),
+ 				    sizeof(unsigned long),
+ 				    GFP_KERNEL);
+ 	mutex_unlock(&udev->cmdr_lock);
++>>>>>>> c97840c84f5a (scsi: tcmu: do not set max_blocks if data_bitmap has been setup)
  	if (!udev->data_bitmap) {
  		ret = -ENOMEM;
  		goto err_bitmap_alloc;
@@@ -1363,7 -2019,8 +1387,12 @@@ static match_table_t tokens = 
  	{Opt_dev_size, "dev_size=%u"},
  	{Opt_hw_block_size, "hw_block_size=%u"},
  	{Opt_hw_max_sectors, "hw_max_sectors=%u"},
++<<<<<<< HEAD
 +	{Opt_max_data_area_mb, "max_data_area_mb=%u"},
++=======
+ 	{Opt_nl_reply_supported, "nl_reply_supported=%d"},
+ 	{Opt_max_data_area_mb, "max_data_area_mb=%d"},
++>>>>>>> c97840c84f5a (scsi: tcmu: do not set max_blocks if data_bitmap has been setup)
  	{Opt_err, NULL}
  };
  
@@@ -1438,38 -2130,19 +1502,42 @@@ static ssize_t tcmu_set_configfs_dev_pa
  			ret = tcmu_set_dev_attrib(&args[0],
  					&(dev->dev_attrib.hw_max_sectors));
  			break;
 -		case Opt_nl_reply_supported:
 +		case Opt_max_data_area_mb:
++<<<<<<< HEAD
 +			if (dev->export_count) {
 +				pr_err("Unable to set max_data_area_mb while exports exist\n");
 +				ret = -EINVAL;
 +				break;
 +			}
 +
  			arg_p = match_strdup(&args[0]);
  			if (!arg_p) {
  				ret = -ENOMEM;
  				break;
  			}
 -			ret = kstrtoint(arg_p, 0, &udev->nl_reply_supported);
 +			ret = kstrtoint(arg_p, 0, &tmpval);
  			kfree(arg_p);
 -			if (ret < 0)
 -				pr_err("kstrtoint() failed for nl_reply_supported=\n");
 -			break;
 -		case Opt_max_data_area_mb:
 +			if (ret < 0) {
 +				pr_err("kstrtoint() failed for max_data_area_mb=\n");
 +				break;
 +			}
 +
 +			if (tmpval <= 0) {
 +				pr_err("Invalid max_data_area %d\n", tmpval);
 +				ret = -EINVAL;
 +				break;
 +			}
 +
 +			udev->max_blocks = TCMU_MBS_TO_BLOCKS(tmpval);
 +			if (udev->max_blocks > DATA_BLOCKS_BITS_MAX) {
 +				pr_err("%d is too large. Adjusting max_data_area_mb to global limit of %u\n",
 +				       tmpval,
 +				       TCMU_BLOCKS_TO_MBS(DATA_BLOCKS_BITS_MAX));
 +				udev->max_blocks = DATA_BLOCKS_BITS_MAX;
 +			}
++=======
+ 			ret = tcmu_set_max_blocks_param(udev, &args[0]);
++>>>>>>> c97840c84f5a (scsi: tcmu: do not set max_blocks if data_bitmap has been setup)
  			break;
  		default:
  			break;
* Unmerged path drivers/target/target_core_user.c
