ASoC: da7219: make structure da7219_dai_clks_ops static

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [sound] alsa: asoc: da7219: make structure da7219_dai_clks_ops static (Jaroslav Kysela) [1535427]
Rebuild_FUZZ: 94.83%
commit-author Colin Ian King <colin.king@canonical.com>
commit 1d37ce929c71f430389db3042a8b23536cede1e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1d37ce92.failed

structure da7219_dai_clks_ops is local to the source and does not need
to be in global scope, so make it static.

Cleans up sparse warning:
sound/soc/codecs/da7219.c:1777:22: warning: symbol 'da7219_dai_clks_ops'
was not declared. Should it be static?

	Signed-off-by: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 1d37ce929c71f430389db3042a8b23536cede1e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/codecs/da7219.c
diff --cc sound/soc/codecs/da7219.c
index 82f52140d836,980a6a8bf56d..000000000000
--- a/sound/soc/codecs/da7219.c
+++ b/sound/soc/codecs/da7219.c
@@@ -1712,9 -1738,91 +1712,94 @@@ static int da7219_handle_supplies(struc
  	return 0;
  }
  
 -#ifdef CONFIG_COMMON_CLK
 -static int da7219_dai_clks_prepare(struct clk_hw *hw)
 +static void da7219_handle_pdata(struct snd_soc_codec *codec)
  {
++<<<<<<< HEAD
 +	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
++=======
+ 	struct da7219_priv *da7219 =
+ 		container_of(hw, struct da7219_priv, dai_clks_hw);
+ 	struct snd_soc_component *component = da7219->aad->component;
+ 
+ 	snd_soc_component_update_bits(component, DA7219_DAI_CLK_MODE,
+ 				      DA7219_DAI_CLK_EN_MASK,
+ 				      DA7219_DAI_CLK_EN_MASK);
+ 
+ 	return 0;
+ }
+ 
+ static void da7219_dai_clks_unprepare(struct clk_hw *hw)
+ {
+ 	struct da7219_priv *da7219 =
+ 		container_of(hw, struct da7219_priv, dai_clks_hw);
+ 	struct snd_soc_component *component = da7219->aad->component;
+ 
+ 	snd_soc_component_update_bits(component, DA7219_DAI_CLK_MODE,
+ 				      DA7219_DAI_CLK_EN_MASK, 0);
+ }
+ 
+ static int da7219_dai_clks_is_prepared(struct clk_hw *hw)
+ {
+ 	struct da7219_priv *da7219 =
+ 		container_of(hw, struct da7219_priv, dai_clks_hw);
+ 	struct snd_soc_component *component = da7219->aad->component;
+ 	u8 clk_reg;
+ 
+ 	clk_reg = snd_soc_component_read32(component, DA7219_DAI_CLK_MODE);
+ 
+ 	return !!(clk_reg & DA7219_DAI_CLK_EN_MASK);
+ }
+ 
+ static const struct clk_ops da7219_dai_clks_ops = {
+ 	.prepare = da7219_dai_clks_prepare,
+ 	.unprepare = da7219_dai_clks_unprepare,
+ 	.is_prepared = da7219_dai_clks_is_prepared,
+ };
+ 
+ static void da7219_register_dai_clks(struct snd_soc_component *component)
+ {
+ 	struct device *dev = component->dev;
+ 	struct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);
+ 	struct da7219_pdata *pdata = da7219->pdata;
+ 	struct clk_init_data init = {};
+ 	struct clk *dai_clks;
+ 	struct clk_lookup *dai_clks_lookup;
+ 
+ 	init.parent_names = NULL;
+ 	init.num_parents = 0;
+ 	init.name = pdata->dai_clks_name;
+ 	init.ops = &da7219_dai_clks_ops;
+ 	da7219->dai_clks_hw.init = &init;
+ 
+ 	dai_clks = devm_clk_register(dev, &da7219->dai_clks_hw);
+ 	if (IS_ERR(dai_clks)) {
+ 		dev_warn(dev, "Failed to register DAI clocks: %ld\n",
+ 			 PTR_ERR(dai_clks));
+ 		return;
+ 	}
+ 	da7219->dai_clks = dai_clks;
+ 
+ 	/* If we're using DT, then register as provider accordingly */
+ 	if (dev->of_node) {
+ 		devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,
+ 					    &da7219->dai_clks_hw);
+ 	} else {
+ 		dai_clks_lookup = clkdev_create(dai_clks, pdata->dai_clks_name,
+ 						"%s", dev_name(dev));
+ 		if (!dai_clks_lookup)
+ 			dev_warn(dev, "Failed to create DAI clkdev");
+ 		else
+ 			da7219->dai_clks_lookup = dai_clks_lookup;
+ 	}
+ }
+ #else
+ static inline void da7219_register_dai_clks(struct snd_soc_component *component) {}
+ #endif /* CONFIG_COMMON_CLK */
+ 
+ static void da7219_handle_pdata(struct snd_soc_component *component)
+ {
+ 	struct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);
++>>>>>>> 1d37ce929c71 (ASoC: da7219: make structure da7219_dai_clks_ops static)
  	struct da7219_pdata *pdata = da7219->pdata;
  
  	if (pdata) {
* Unmerged path sound/soc/codecs/da7219.c
