nvme-fabrics: allow internal passthrough command on deleting controllers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Christoph Hellwig <hch@lst.de>
commit cc456b65b739e17e8b1e6b61cc2f014f225ba466
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/cc456b65.failed

Without this we can't cleanly shut down.

Based on analysis an an earlier patch from Hannes Reinecke.

Fixes: bb06ec31452f ("nvme: expand nvmf_check_if_ready checks")
	Reported-by: Hannes Reinecke <hare@suse.de>
	Tested-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Reviewed-by: James Smart <james.smart@broadcom.com>
(cherry picked from commit cc456b65b739e17e8b1e6b61cc2f014f225ba466)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/fabrics.c
diff --cc drivers/nvme/host/fabrics.c
index a4c054fbefbd,5f5f7067c41d..000000000000
--- a/drivers/nvme/host/fabrics.c
+++ b/drivers/nvme/host/fabrics.c
@@@ -536,6 -536,68 +536,71 @@@ static struct nvmf_transport_ops *nvmf_
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ blk_status_t nvmf_check_if_ready(struct nvme_ctrl *ctrl, struct request *rq,
+ 		bool queue_live, bool is_connected)
+ {
+ 	struct nvme_command *cmd = nvme_req(rq)->cmd;
+ 
+ 	if (likely(ctrl->state == NVME_CTRL_LIVE && is_connected))
+ 		return BLK_STS_OK;
+ 
+ 	switch (ctrl->state) {
+ 	case NVME_CTRL_NEW:
+ 	case NVME_CTRL_CONNECTING:
+ 	case NVME_CTRL_DELETING:
+ 		/*
+ 		 * This is the case of starting a new or deleting an association
+ 		 * but connectivity was lost before it was fully created or torn
+ 		 * down. We need to error the commands used to initialize the
+ 		 * controller so the reconnect can go into a retry attempt.  The
+ 		 * commands should all be marked REQ_FAILFAST_DRIVER, which will
+ 		 * hit the reject path below. Anything else will be queued while
+ 		 * the state settles.
+ 		 */
+ 		if (!is_connected)
+ 			break;
+ 
+ 		/*
+ 		 * If queue is live, allow only commands that are internally
+ 		 * generated pass through.  These are commands on the admin
+ 		 * queue to initialize the controller. This will reject any
+ 		 * ioctl admin cmds received while initializing.
+ 		 */
+ 		if (queue_live && !(nvme_req(rq)->flags & NVME_REQ_USERCMD))
+ 			return BLK_STS_OK;
+ 
+ 		/*
+ 		 * If the queue is not live, allow only a connect command.  This
+ 		 * will reject any ioctl admin cmd as well as initialization
+ 		 * commands if the controller reverted the queue to non-live.
+ 		 */
+ 		if (!queue_live && blk_rq_is_passthrough(rq) &&
+ 		     cmd->common.opcode == nvme_fabrics_command &&
+ 		     cmd->fabrics.fctype == nvme_fabrics_type_connect)
+ 			return BLK_STS_OK;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	/*
+ 	 * Any other new io is something we're not in a state to send to the
+ 	 * device.  Default action is to busy it and retry it after the
+ 	 * controller state is recovered. However, anything marked for failfast
+ 	 * or nvme multipath is immediately failed.  Note: commands used to
+ 	 * initialize the controller will be marked for failfast.
+ 	 * Note: nvme cli/ioctl commands are marked for failfast.
+ 	 */
+ 	if (!blk_noretry_request(rq) && !(rq->cmd_flags & REQ_NVME_MPATH))
+ 		return BLK_STS_RESOURCE;
+ 	nvme_req(rq)->status = NVME_SC_ABORT_REQ;
+ 	return BLK_STS_IOERR;
+ }
+ EXPORT_SYMBOL_GPL(nvmf_check_if_ready);
+ 
++>>>>>>> cc456b65b739 (nvme-fabrics: allow internal passthrough command on deleting controllers)
  static const match_table_t opt_tokens = {
  	{ NVMF_OPT_TRANSPORT,		"transport=%s"		},
  	{ NVMF_OPT_TRADDR,		"traddr=%s"		},
* Unmerged path drivers/nvme/host/fabrics.c
