md: fix several trivial typos in comments

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [md] fix several trivial typos in comments (Nigel Croxon) [1494474]
Rebuild_FUZZ: 94.87%
commit-author Zhilong Liu <zlliu@suse.com>
commit 3560741e316b3ea52cfb27901ae284921445180f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3560741e.failed

	Signed-off-by: Zhilong Liu <zlliu@suse.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit 3560741e316b3ea52cfb27901ae284921445180f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/bitmap.c
diff --cc drivers/md/bitmap.c
index 97cf684b8f8e,bf7419a56454..000000000000
--- a/drivers/md/bitmap.c
+++ b/drivers/md/bitmap.c
@@@ -645,9 -692,25 +645,26 @@@ static int bitmap_read_sb(struct bitma
  	if (le32_to_cpu(sb->version) == BITMAP_MAJOR_HOSTENDIAN)
  		set_bit(BITMAP_HOSTENDIAN, &bitmap->flags);
  	bitmap->events_cleared = le64_to_cpu(sb->events_cleared);
 -	strlcpy(bitmap->mddev->bitmap_info.cluster_name, sb->cluster_name, 64);
  	err = 0;
 -
  out:
  	kunmap_atomic(sb);
++<<<<<<< HEAD
++=======
+ 	/* Assigning chunksize is required for "re_read" */
+ 	bitmap->mddev->bitmap_info.chunksize = chunksize;
+ 	if (err == 0 && nodes && (bitmap->cluster_slot < 0)) {
+ 		err = md_setup_cluster(bitmap->mddev, nodes);
+ 		if (err) {
+ 			pr_warn("%s: Could not setup cluster service (%d)\n",
+ 				bmname(bitmap), err);
+ 			goto out_no_sb;
+ 		}
+ 		bitmap->cluster_slot = md_cluster_ops->slot_number(bitmap->mddev);
+ 		goto re_read;
+ 	}
+ 
+ 
++>>>>>>> 3560741e316b (md: fix several trivial typos in comments)
  out_no_sb:
  	if (test_bit(BITMAP_STALE, &bitmap->flags))
  		bitmap->events_cleared = bitmap->mddev->events;
* Unmerged path drivers/md/bitmap.c
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index 23a0d32eb95d..c310d6e7deab 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -2216,7 +2216,7 @@ static int resize_stripes(struct r5conf *conf, int newsize)
 	 *    pages have been transferred over, and the old kmem_cache is
 	 *    freed when all stripes are done.
 	 * 3/ reallocate conf->disks to be suitable bigger.  If this fails,
-	 *    we simple return a failre status - no need to clean anything up.
+	 *    we simple return a failure status - no need to clean anything up.
 	 * 4/ allocate new pages for the new slots in the new stripe_heads.
 	 *    If this fails, we don't bother trying the shrink the
 	 *    stripe_heads down again, we just leave them as they are.
@@ -3483,7 +3483,7 @@ static int need_this_block(struct stripe_head *sh, struct stripe_head_state *s,
 	    !test_bit(STRIPE_PREREAD_ACTIVE, &sh->state))
 		/* Pre-reads at not permitted until after short delay
 		 * to gather multiple requests.  However if this
-		 * device is no Insync, the block could only be be computed
+		 * device is no Insync, the block could only be computed
 		 * and there is no need to delay that.
 		 */
 		return 0;
@@ -3502,7 +3502,7 @@ static int need_this_block(struct stripe_head *sh, struct stripe_head_state *s,
 
 	/* If we are forced to do a reconstruct-write, either because
 	 * the current RAID6 implementation only supports that, or
-	 * or because parity cannot be trusted and we are currently
+	 * because parity cannot be trusted and we are currently
 	 * recovering it, there is extra need to be careful.
 	 * If one of the devices that we would need to read, because
 	 * it is not being overwritten (and maybe not written at all)
