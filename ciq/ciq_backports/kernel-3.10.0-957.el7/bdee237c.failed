x86: mm: Use 2GB memory block size on large-memory x86-64 systems

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] revert "mm: Use 2GB memory block size on large-memory x86-64 systems" (Baoquan He) [1625143]
Rebuild_FUZZ: 91.04%
commit-author Daniel J Blueman <daniel@numascale.com>
commit bdee237c0343a5d1a6cf72c7ea68e88338b26e08
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/bdee237c.failed

On large-memory x86-64 systems of 64GB or more with memory hot-plug
enabled, use a 2GB memory block size. Eg with 64GB memory, this reduces
the number of directories in /sys/devices/system/memory from 512 to 32,
making it more manageable, and reducing the creation time accordingly.

This caveat is that the memory can't be offlined (for hotplug or
otherwise) with the finer default 128MB granularity, but this is
unimportant due to the high memory densities generally used with such
large-memory systems, where eg a single DIMM is the order of 16GB.

	Signed-off-by: Daniel J Blueman <daniel@numascale.com>
	Cc: Steffen Persvold <sp@numascale.com>
	Cc: Bjorn Helgaas <bhelgaas@google.com>
Link: http://lkml.kernel.org/r/1415089784-28779-4-git-send-email-daniel@numascale.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit bdee237c0343a5d1a6cf72c7ea68e88338b26e08)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/init_64.c
diff --cc arch/x86/mm/init_64.c
index 25c65b6af83e,ebca30f10708..000000000000
--- a/arch/x86/mm/init_64.c
+++ b/arch/x86/mm/init_64.c
@@@ -1210,28 -1238,43 +1209,35 @@@ int in_gate_area(struct mm_struct *mm, 
   */
  int in_gate_area_no_mm(unsigned long addr)
  {
 -	return (addr & PAGE_MASK) == VSYSCALL_ADDR;
 +	return (addr >= VSYSCALL_START) && (addr < VSYSCALL_END);
  }
  
 -static unsigned long probe_memory_block_size(void)
 +const char *arch_vma_name(struct vm_area_struct *vma)
  {
 -	/* start from 2g */
 -	unsigned long bz = 1UL<<31;
 -
 -	if (totalram_pages >= (64ULL << (30 - PAGE_SHIFT))) {
 -		pr_info("Using 2GB memory block size for large-memory system\n");
 -		return 2UL * 1024 * 1024 * 1024;
 -	}
 -
 -	/* less than 64g installed */
 -	if ((max_pfn << PAGE_SHIFT) < (16UL << 32))
 -		return MIN_MEMORY_BLOCK_SIZE;
 -
 -	/* get the tail size */
 -	while (bz > MIN_MEMORY_BLOCK_SIZE) {
 -		if (!((max_pfn << PAGE_SHIFT) & (bz - 1)))
 -			break;
 -		bz >>= 1;
 -	}
 -
 -	printk(KERN_DEBUG "memory block size : %ldMB\n", bz >> 20);
 -
 -	return bz;
 +	if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso)
 +		return "[vdso]";
 +	if (vma == &gate_vma)
 +		return "[vsyscall]";
 +	return NULL;
  }
  
 -static unsigned long memory_block_size_probed;
++<<<<<<< HEAD
 +#ifdef CONFIG_X86_UV
  unsigned long memory_block_size_bytes(void)
  {
 -	if (!memory_block_size_probed)
 -		memory_block_size_probed = probe_memory_block_size();
 -
 -	return memory_block_size_probed;
 +	if (is_uv_system()) {
 +		printk(KERN_INFO "UV: memory block size 2GB\n");
 +		return 2UL * 1024 * 1024 * 1024;
 +	}
 +	return MIN_MEMORY_BLOCK_SIZE;
  }
 +#endif
++=======
++	if (totalram_pages >= (64ULL << (30 - PAGE_SHIFT))) {
++		pr_info("Using 2GB memory block size for large-memory system\n");
++		return 2UL * 1024 * 1024 * 1024;
++	}
++>>>>>>> bdee237c0343 (x86: mm: Use 2GB memory block size on large-memory x86-64 systems)
  
  #ifdef CONFIG_SPARSEMEM_VMEMMAP
  /*
* Unmerged path arch/x86/mm/init_64.c
