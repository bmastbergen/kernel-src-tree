net: ipv6: send NS for DAD when link operationally up

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] ipv6: send NS for DAD when link operationally up (Jarod Wilson) [1608002]
Rebuild_FUZZ: 95.05%
commit-author Mike Manning <mmanning@brocade.com>
commit 1f372c7bfb23286d2bf4ce0423ab488e86b74bb2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1f372c7b.failed

The NS for DAD are sent on admin up as long as a valid qdisc is found.
A race condition exists by which these packets will not egress the
interface if the operational state of the lower device is not yet up.
The solution is to delay DAD until the link is operationally up
according to RFC2863. Rather than only doing this, follow the existing
code checks by deferring IPv6 device initialization altogether. The fix
allows DAD on devices like tunnels that are controlled by userspace
control plane. The fix has no impact on regular deployments, but means
that there is no IPv6 connectivity until the port has been opened in
the case of port-based network access control, which should be
desirable.

	Signed-off-by: Mike Manning <mmanning@brocade.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1f372c7bfb23286d2bf4ce0423ab488e86b74bb2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/addrconf.c
diff --cc net/ipv6/addrconf.c
index 3ade2404db91,f553f72d0bee..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -247,12 -289,24 +247,12 @@@ static struct ipv6_devconf ipv6_devconf
  	.stable_secret		= {
  		.initialized = false,
  	},
 -	.use_oif_addrs_only	= 0,
 -	.ignore_routes_with_linkdown = 0,
 -	.keep_addr_on_down	= 0,
 -	.seg6_enabled		= 0,
 -#ifdef CONFIG_IPV6_SEG6_HMAC
 -	.seg6_require_hmac	= 0,
 -#endif
 -	.enhanced_dad           = 1,
 -	.addr_gen_mode		= IN6_ADDR_GEN_MODE_EUI64,
 -	.disable_policy		= 0,
  };
  
- /* Check if a valid qdisc is available */
- static inline bool addrconf_qdisc_ok(const struct net_device *dev)
+ /* Check if link is ready: is it up and is a valid qdisc available */
+ static inline bool addrconf_link_ready(const struct net_device *dev)
  {
- 	return !qdisc_tx_is_noop(dev);
+ 	return netif_oper_up(dev) && !qdisc_tx_is_noop(dev);
  }
  
  static void addrconf_del_rs_timer(struct inet6_dev *idev)
@@@ -3123,8 -3396,14 +3123,15 @@@ static int addrconf_notify(struct notif
  		if (dev->flags & IFF_SLAVE)
  			break;
  
 -		if (idev && idev->cnf.disable_ipv6)
 -			break;
 -
  		if (event == NETDEV_UP) {
++<<<<<<< HEAD
 +			if (!addrconf_qdisc_ok(dev)) {
++=======
+ 			/* restore routes for permanent addresses */
+ 			addrconf_permanent_addr(dev);
+ 
+ 			if (!addrconf_link_ready(dev)) {
++>>>>>>> 1f372c7bfb23 (net: ipv6: send NS for DAD when link operationally up)
  				/* device is not ready yet. */
  				pr_info("ADDRCONF(NETDEV_UP): %s: link is not ready\n",
  					dev->name);
* Unmerged path net/ipv6/addrconf.c
