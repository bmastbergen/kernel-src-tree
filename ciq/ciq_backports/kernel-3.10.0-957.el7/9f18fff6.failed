s390: remove indirect branch from do_softirq_own_stack

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [s390] remove indirect branch from do_softirq_own_stack (Hendrik Brueckner) [1583564]
Rebuild_FUZZ: 94.12%
commit-author Martin Schwidefsky <schwidefsky@de.ibm.com>
commit 9f18fff63cfd6f559daa1eaae60640372c65f84b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9f18fff6.failed

The inline assembly to call __do_softirq on the irq stack uses
an indirect branch. This can be replaced with a normal relative
branch.

	Cc: stable@vger.kernel.org # 4.16
Fixes: f19fbd5ed6 ("s390: introduce execute-trampolines for branches")
	Reviewed-by: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 9f18fff63cfd6f559daa1eaae60640372c65f84b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kernel/irq.c
diff --cc arch/s390/kernel/irq.c
index 391a448f0bfc,3d17c41074ca..000000000000
--- a/arch/s390/kernel/irq.c
+++ b/arch/s390/kernel/irq.c
@@@ -130,48 -159,33 +130,67 @@@ skip_arch_irqs
  /*
   * Switch to the asynchronous interrupt stack for softirq execution.
   */
 -void do_softirq_own_stack(void)
 +asmlinkage void do_softirq(void)
  {
 -	unsigned long old, new;
 -
 +	unsigned long flags, old, new;
 +
++<<<<<<< HEAD
 +	if (in_interrupt())
 +		return;
 +
 +	local_irq_save(flags);
 +
 +	if (local_softirq_pending()) {
 +		/* Get current stack pointer. */
 +		asm volatile("la %0,0(15)" : "=a" (old));
 +		/* Check against async. stack address range. */
 +		new = S390_lowcore.async_stack;
 +		if (((new - old) >> (PAGE_SHIFT + THREAD_ORDER)) != 0) {
 +			/* Need to switch to the async. stack. */
 +			new -= STACK_FRAME_OVERHEAD;
 +			((struct stack_frame *) new)->back_chain = old;
 +
 +			asm volatile("   la    15,0(%0)\n"
 +				     "   basr  14,%2\n"
 +				     "   la    15,0(%1)\n"
 +				     : : "a" (new), "a" (old),
 +				         "a" (__do_softirq)
 +				     : "0", "1", "2", "3", "4", "5", "14",
 +				       "cc", "memory" );
 +		} else {
 +			/* We are already on the async stack. */
 +			__do_softirq();
 +		}
++=======
+ 	old = current_stack_pointer();
+ 	/* Check against async. stack address range. */
+ 	new = S390_lowcore.async_stack;
+ 	if (((new - old) >> (PAGE_SHIFT + THREAD_SIZE_ORDER)) != 0) {
+ 		/* Need to switch to the async. stack. */
+ 		new -= STACK_FRAME_OVERHEAD;
+ 		((struct stack_frame *) new)->back_chain = old;
+ 		asm volatile("   la    15,0(%0)\n"
+ 			     "   brasl 14,__do_softirq\n"
+ 			     "   la    15,0(%1)\n"
+ 			     : : "a" (new), "a" (old)
+ 			     : "0", "1", "2", "3", "4", "5", "14",
+ 			       "cc", "memory" );
+ 	} else {
+ 		/* We are already on the async stack. */
+ 		__do_softirq();
++>>>>>>> 9f18fff63cfd (s390: remove indirect branch from do_softirq_own_stack)
  	}
 +
 +	local_irq_restore(flags);
 +}
 +
 +#ifdef CONFIG_PROC_FS
 +void init_irq_proc(void)
 +{
 +	if (proc_mkdir("irq", NULL))
 +		create_prof_cpu_mask();
  }
 +#endif
  
  /*
   * ext_int_hash[index] is the list head for all external interrupts that hash
* Unmerged path arch/s390/kernel/irq.c
