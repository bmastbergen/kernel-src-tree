drm/nouveau/kms/nv50: abstract OR interfaces so the code can be split

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ben Skeggs <bskeggs@redhat.com>
commit 0a3687716bb0a53a363b63cb5ba2bddc14c3bd2a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0a368771.failed

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit 0a3687716bb0a53a363b63cb5ba2bddc14c3bd2a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/dispnv50/disp.c
diff --cc drivers/gpu/drm/nouveau/dispnv50/disp.c
index a2ea42f947c7,995109ee5762..000000000000
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.c
@@@ -685,7 -484,50 +685,54 @@@ nv50_disp(struct drm_device *dev
  	return nouveau_display(dev)->priv;
  }
  
++<<<<<<< HEAD
 +#define nv50_mast(d) (&nv50_disp(d)->mast)
++=======
+ /******************************************************************************
+  * Core
+  *****************************************************************************/
+ 
+ struct nv50_core {
+ 	const struct nv50_core_func *func;
+ 	struct nv50_dmac chan;
+ };
+ 
+ struct nv50_core_func {
+ 	const struct nv50_head_func *head;
+ 	const struct nv50_outp_func *dac;
+ 	const struct nv50_outp_func *sor;
+ 	const struct nv50_outp_func *pior;
+ };
+ 
+ struct nv50_outp_func {
+ 	void (*ctrl)(struct nv50_core *, int or, u32 ctrl,
+ 		     struct nv50_head_atom *);
+ };
+ 
+ static int
+ core507d_new_(const struct nv50_core_func *func, struct nouveau_drm *drm,
+ 	      s32 oclass, struct nv50_core **pcore)
+ {
+ 	struct nv50_disp_core_channel_dma_v0 args = {};
+ 	struct nv50_disp *disp = nv50_disp(drm->dev);
+ 	struct nv50_core *core;
+ 	int ret;
+ 
+ 	if (!(core = *pcore = kzalloc(sizeof(*core), GFP_KERNEL)))
+ 		return -ENOMEM;
+ 	core->func = func;
+ 
+ 	ret = nv50_dmac_create(&drm->client.device, &disp->disp->object,
+ 			       &oclass, 0, &args, sizeof(args),
+ 			       disp->sync->bo.offset, &core->chan);
+ 	if (ret) {
+ 		NV_ERROR(drm, "core%04x allocation failed: %d\n", oclass, ret);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
++>>>>>>> 0a3687716bb0 (drm/nouveau/kms/nv50: abstract OR interfaces so the code can be split)
  
  /******************************************************************************
   * EVO channel helpers
@@@ -1548,9 -1644,26 +1595,29 @@@ nv50_base_new(struct nouveau_drm *drm, 
   * Head
   *****************************************************************************/
  static void
++<<<<<<< HEAD
++=======
+ head907d_or(struct nv50_head *head, struct nv50_head_atom *asyh)
+ {
+ 	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+ 	u32 *push;
+ 	if (core->base.user.oclass >= GF110_DISP_CORE_CHANNEL_DMA &&
+ 	    (push = evo_wait(core, 3))) {
+ 		evo_mthd(push, 0x0404 + (head->base.index * 0x300), 2);
+ 		evo_data(push, 0x00000001 | (asyh->or.depth  << 6) |
+ 					    (asyh->or.nvsync << 4) |
+ 					    (asyh->or.nhsync << 3));
+ 		evo_data(push, 0x31ec6000 | (head->base.index << 25) |
+ 					     asyh->mode.interlace);
+ 		evo_kick(push, core);
+ 	}
+ }
+ 
+ static void
++>>>>>>> 0a3687716bb0 (drm/nouveau/kms/nv50: abstract OR interfaces so the code can be split)
  nv50_head_procamp(struct nv50_head *head, struct nv50_head_atom *asyh)
  {
 -	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
 +	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->mast.base;
  	u32 *push;
  	if ((push = evo_wait(core, 2))) {
  		if (core->base.user.oclass < GF110_DISP_CORE_CHANNEL_DMA)
@@@ -2385,6 -2554,68 +2452,71 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static const struct nv50_outp_func dac507d;
+ static const struct nv50_outp_func sor507d;
+ static const struct nv50_outp_func pior507d;
+ static const struct nv50_core_func
+ core507d = {
+ 	.head = &head507d,
+ 	.dac = &dac507d,
+ 	.sor = &sor507d,
+ 	.pior = &pior507d,
+ };
+ 
+ static int
+ core507d_new(struct nouveau_drm *drm, s32 oclass, struct nv50_core **pcore)
+ {
+ 	return core507d_new_(&core507d, drm, oclass, pcore);
+ }
+ 
+ static void
+ nv50_core_del(struct nv50_core **pcore)
+ {
+ 	struct nv50_core *core = *pcore;
+ 	if (core) {
+ 		nv50_dmac_destroy(&core->chan);
+ 		kfree(*pcore);
+ 		*pcore = NULL;
+ 	}
+ }
+ 
+ static int
+ nv50_core_new(struct nouveau_drm *drm, struct nv50_core **pcore)
+ {
+ 	struct {
+ 		s32 oclass;
+ 		int version;
+ 		int (*new)(struct nouveau_drm *, s32, struct nv50_core **);
+ 	} cores[] = {
+ 		{ GP102_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GP100_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GM200_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GM107_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GK110_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GK104_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GF110_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GT214_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GT206_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GT200_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{   G82_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{  NV50_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{}
+ 	};
+ 	struct nv50_disp *disp = nv50_disp(drm->dev);
+ 	int cid;
+ 
+ 	cid = nvif_mclass(&disp->disp->object, cores);
+ 	if (cid < 0) {
+ 		NV_ERROR(drm, "No supported core channel class\n");
+ 		return cid;
+ 	}
+ 
+ 	return cores[cid].new(drm, cores[cid].oclass, pcore);
+ }
+ 
++>>>>>>> 0a3687716bb0 (drm/nouveau/kms/nv50: abstract OR interfaces so the code can be split)
  /******************************************************************************
   * Output path helpers
   *****************************************************************************/
@@@ -2493,24 -2751,9 +2652,30 @@@ static voi
  nv50_dac_disable(struct drm_encoder *encoder)
  {
  	struct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);
++<<<<<<< HEAD
 +	struct nv50_mast *mast = nv50_mast(encoder->dev);
 +	const int or = nv_encoder->or;
 +	u32 *push;
 +
 +	if (nv_encoder->crtc) {
 +		push = evo_wait(mast, 4);
 +		if (push) {
 +			if (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {
 +				evo_mthd(push, 0x0400 + (or * 0x080), 1);
 +				evo_data(push, 0x00000000);
 +			} else {
 +				evo_mthd(push, 0x0180 + (or * 0x020), 1);
 +				evo_data(push, 0x00000000);
 +			}
 +			evo_kick(push, mast);
 +		}
 +	}
 +
++=======
+ 	struct nv50_core *core = nv50_disp(encoder->dev)->core;
+ 	if (nv_encoder->crtc)
+ 		core->func->dac->ctrl(core, nv_encoder->or, 0x00000000, NULL);
++>>>>>>> 0a3687716bb0 (drm/nouveau/kms/nv50: abstract OR interfaces so the code can be split)
  	nv_encoder->crtc = NULL;
  	nv50_outp_release(nv_encoder);
  }
@@@ -2518,48 -2761,15 +2683,60 @@@
  static void
  nv50_dac_enable(struct drm_encoder *encoder)
  {
++<<<<<<< HEAD
 +	struct nv50_mast *mast = nv50_mast(encoder->dev);
 +	struct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);
 +	struct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);
 +	struct drm_display_mode *mode = &nv_crtc->base.state->adjusted_mode;
 +	u32 *push;
 +
 +	nv50_outp_acquire(nv_encoder);
 +
 +	push = evo_wait(mast, 8);
 +	if (push) {
 +		if (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {
 +			u32 syncs = 0x00000000;
 +
 +			if (mode->flags & DRM_MODE_FLAG_NHSYNC)
 +				syncs |= 0x00000001;
 +			if (mode->flags & DRM_MODE_FLAG_NVSYNC)
 +				syncs |= 0x00000002;
 +
 +			evo_mthd(push, 0x0400 + (nv_encoder->or * 0x080), 2);
 +			evo_data(push, 1 << nv_crtc->index);
 +			evo_data(push, syncs);
 +		} else {
 +			u32 magic = 0x31ec6000 | (nv_crtc->index << 25);
 +			u32 syncs = 0x00000001;
 +
 +			if (mode->flags & DRM_MODE_FLAG_NHSYNC)
 +				syncs |= 0x00000008;
 +			if (mode->flags & DRM_MODE_FLAG_NVSYNC)
 +				syncs |= 0x00000010;
 +
 +			if (mode->flags & DRM_MODE_FLAG_INTERLACE)
 +				magic |= 0x00000001;
 +
 +			evo_mthd(push, 0x0404 + (nv_crtc->index * 0x300), 2);
 +			evo_data(push, syncs);
 +			evo_data(push, magic);
 +			evo_mthd(push, 0x0180 + (nv_encoder->or * 0x020), 1);
 +			evo_data(push, 1 << nv_crtc->index);
 +		}
 +
 +		evo_kick(push, mast);
 +	}
++=======
+ 	struct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);
+ 	struct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);
+ 	struct nv50_head_atom *asyh = nv50_head_atom(nv_crtc->base.state);
+ 	struct nv50_core *core = nv50_disp(encoder->dev)->core;
+ 
+ 	nv50_outp_acquire(nv_encoder);
+ 
+ 	core->func->dac->ctrl(core, nv_encoder->or, 1 << nv_crtc->index, asyh);
+ 	asyh->or.depth = 0;
++>>>>>>> 0a3687716bb0 (drm/nouveau/kms/nv50: abstract OR interfaces so the code can be split)
  
  	nv_encoder->crtc = encoder->crtc;
  }
@@@ -3426,52 -3634,50 +3603,87 @@@ nv50_mstm_new(struct nouveau_encoder *o
  /******************************************************************************
   * SOR
   *****************************************************************************/
+ static void
+ sor507d_ctrl(struct nv50_core *core, int or, u32 ctrl,
+ 	     struct nv50_head_atom *asyh)
+ {
+ 	u32 *push;
+ 	if ((push = evo_wait(&core->chan, 6))) {
+ 		if (core->chan.base.user.oclass < GF110_DISP_CORE_CHANNEL_DMA) {
+ 			if (asyh) {
+ 				ctrl |= asyh->or.depth  << 16;
+ 				ctrl |= asyh->or.nvsync << 13;
+ 				ctrl |= asyh->or.nhsync << 12;
+ 			}
+ 			evo_mthd(push, 0x0600 + (or * 0x40), 1);
+ 		} else {
+ 			evo_mthd(push, 0x0200 + (or * 0x20), 1);
+ 		}
+ 		evo_data(push, ctrl);
+ 		evo_kick(push, &core->chan);
+ 	}
+ }
+ 
+ static const struct nv50_outp_func
+ sor507d = {
+ 	.ctrl = sor507d_ctrl,
+ };
+ 
  static void
  nv50_sor_update(struct nouveau_encoder *nv_encoder, u8 head,
 -		struct nv50_head_atom *asyh, u8 proto, u8 depth)
 +		struct drm_display_mode *mode, u8 proto, u8 depth)
  {
++<<<<<<< HEAD
 +	struct nv50_dmac *core = &nv50_mast(nv_encoder->base.base.dev)->base;
 +	u32 *push;
++=======
+ 	struct nv50_disp *disp = nv50_disp(nv_encoder->base.base.dev);
+ 	struct nv50_core *core = disp->core;
++>>>>>>> 0a3687716bb0 (drm/nouveau/kms/nv50: abstract OR interfaces so the code can be split)
  
 -	if (!asyh) {
 +	if (!mode) {
  		nv_encoder->ctrl &= ~BIT(head);
  		if (!(nv_encoder->ctrl & 0x0000000f))
  			nv_encoder->ctrl = 0;
  	} else {
  		nv_encoder->ctrl |= proto << 8;
  		nv_encoder->ctrl |= BIT(head);
 -		asyh->or.depth = depth;
  	}
  
++<<<<<<< HEAD
 +	if ((push = evo_wait(core, 6))) {
 +		if (core->base.user.oclass < GF110_DISP_CORE_CHANNEL_DMA) {
 +			if (mode) {
 +				if (mode->flags & DRM_MODE_FLAG_NHSYNC)
 +					nv_encoder->ctrl |= 0x00001000;
 +				if (mode->flags & DRM_MODE_FLAG_NVSYNC)
 +					nv_encoder->ctrl |= 0x00002000;
 +				nv_encoder->ctrl |= depth << 16;
 +			}
 +			evo_mthd(push, 0x0600 + (nv_encoder->or * 0x40), 1);
 +		} else {
 +			if (mode) {
 +				u32 magic = 0x31ec6000 | (head << 25);
 +				u32 syncs = 0x00000001;
 +				if (mode->flags & DRM_MODE_FLAG_NHSYNC)
 +					syncs |= 0x00000008;
 +				if (mode->flags & DRM_MODE_FLAG_NVSYNC)
 +					syncs |= 0x00000010;
 +				if (mode->flags & DRM_MODE_FLAG_INTERLACE)
 +					magic |= 0x00000001;
 +
 +				evo_mthd(push, 0x0404 + (head * 0x300), 2);
 +				evo_data(push, syncs | (depth << 6));
 +				evo_data(push, magic);
 +			}
 +			evo_mthd(push, 0x0200 + (nv_encoder->or * 0x20), 1);
 +		}
 +		evo_data(push, nv_encoder->ctrl);
 +		evo_kick(push, core);
 +	}
++=======
+ 	core->func->sor->ctrl(core, nv_encoder->or, nv_encoder->ctrl, asyh);
++>>>>>>> 0a3687716bb0 (drm/nouveau/kms/nv50: abstract OR interfaces so the code can be split)
  }
  
  static void
@@@ -3713,21 -3944,9 +3949,27 @@@ static voi
  nv50_pior_disable(struct drm_encoder *encoder)
  {
  	struct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);
++<<<<<<< HEAD
 +	struct nv50_mast *mast = nv50_mast(encoder->dev);
 +	const int or = nv_encoder->or;
 +	u32 *push;
 +
 +	if (nv_encoder->crtc) {
 +		push = evo_wait(mast, 4);
 +		if (push) {
 +			if (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {
 +				evo_mthd(push, 0x0700 + (or * 0x040), 1);
 +				evo_data(push, 0x00000000);
 +			}
 +			evo_kick(push, mast);
 +		}
 +	}
 +
++=======
+ 	struct nv50_core *core = nv50_disp(encoder->dev)->core;
+ 	if (nv_encoder->crtc)
+ 		core->func->pior->ctrl(core, nv_encoder->or, 0x00000000, NULL);
++>>>>>>> 0a3687716bb0 (drm/nouveau/kms/nv50: abstract OR interfaces so the code can be split)
  	nv_encoder->crtc = NULL;
  	nv50_outp_release(nv_encoder);
  }
@@@ -3735,14 -3954,13 +3977,24 @@@
  static void
  nv50_pior_enable(struct drm_encoder *encoder)
  {
++<<<<<<< HEAD
 +	struct nv50_mast *mast = nv50_mast(encoder->dev);
 +	struct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);
 +	struct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);
 +	struct nouveau_connector *nv_connector;
 +	struct drm_display_mode *mode = &nv_crtc->base.state->adjusted_mode;
 +	u8 owner = 1 << nv_crtc->index;
 +	u8 proto, depth;
 +	u32 *push;
++=======
+ 	struct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);
+ 	struct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);
+ 	struct nouveau_connector *nv_connector;
+ 	struct nv50_head_atom *asyh = nv50_head_atom(nv_crtc->base.state);
+ 	struct nv50_core *core = nv50_disp(encoder->dev)->core;
+ 	u8 owner = 1 << nv_crtc->index;
+ 	u8 proto;
++>>>>>>> 0a3687716bb0 (drm/nouveau/kms/nv50: abstract OR interfaces so the code can be split)
  
  	nv50_outp_acquire(nv_encoder);
  
@@@ -3764,21 -3982,7 +4016,25 @@@
  		break;
  	}
  
++<<<<<<< HEAD
 +	push = evo_wait(mast, 8);
 +	if (push) {
 +		if (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {
 +			u32 ctrl = (depth << 16) | (proto << 8) | owner;
 +			if (mode->flags & DRM_MODE_FLAG_NHSYNC)
 +				ctrl |= 0x00001000;
 +			if (mode->flags & DRM_MODE_FLAG_NVSYNC)
 +				ctrl |= 0x00002000;
 +			evo_mthd(push, 0x0700 + (nv_encoder->or * 0x040), 1);
 +			evo_data(push, ctrl);
 +		}
 +
 +		evo_kick(push, mast);
 +	}
 +
++=======
+ 	core->func->pior->ctrl(core, nv_encoder->or, (proto << 8) | owner, asyh);
++>>>>>>> 0a3687716bb0 (drm/nouveau/kms/nv50: abstract OR interfaces so the code can be split)
  	nv_encoder->crtc = encoder->crtc;
  }
  
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/disp.c
