usb: add CONFIG_USB_PCI for system have both PCI HW and non-PCI based USB HW

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [usb] add CONFIG_USB_PCI for system have both PCI HW and non-PCI based USB HW (Torez Smith) [1540721]
Rebuild_FUZZ: 96.60%
commit-author yuan linyu <Linyu.Yuan@alcatel-sbell.com.cn>
commit 2c93e790e8253552227bf9b46a8d49dca3f71b06
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/2c93e790.failed

a lot of embeded system SOC (e.g. freescale T2080) have both
PCI and USB modules. But USB module is controlled by registers directly,
it have no relationship with PCI module.

when say N here it will not build PCI related code in USB driver.

	Signed-off-by: yuan linyu <Linyu.Yuan@alcatel-sbell.com.cn>
	Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 2c93e790e8253552227bf9b46a8d49dca3f71b06)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/chipidea/Kconfig
#	drivers/usb/dwc2/Kconfig
#	drivers/usb/dwc3/Kconfig
#	drivers/usb/gadget/udc/Kconfig
#	drivers/usb/gadget/udc/bdc/Kconfig
#	drivers/usb/isp1760/isp1760-if.c
diff --cc drivers/usb/chipidea/Kconfig
index b2df442eb3e5,51f4157bbecf..000000000000
--- a/drivers/usb/chipidea/Kconfig
+++ b/drivers/usb/chipidea/Kconfig
@@@ -10,9 -13,20 +10,23 @@@ config USB_CHIPIDE
  
  if USB_CHIPIDEA
  
++<<<<<<< HEAD
++=======
+ config USB_CHIPIDEA_OF
+ 	tristate
+ 	depends on OF
+ 	default USB_CHIPIDEA
+ 
+ config USB_CHIPIDEA_PCI
+ 	tristate
+ 	depends on USB_PCI
+ 	depends on NOP_USB_XCEIV
+ 	default USB_CHIPIDEA
+ 
++>>>>>>> 2c93e790e825 (usb: add CONFIG_USB_PCI for system have both PCI HW and non-PCI based USB HW)
  config USB_CHIPIDEA_UDC
  	bool "ChipIdea device controller"
 -	depends on USB_GADGET
 +	depends on USB_GADGET=y || USB_GADGET=USB_CHIPIDEA
  	help
  	  Say Y here to enable device controller functionality of the
  	  ChipIdea driver.
diff --cc drivers/usb/dwc3/Kconfig
index 757aa18027d0,4c9e56d8776a..000000000000
--- a/drivers/usb/dwc3/Kconfig
+++ b/drivers/usb/dwc3/Kconfig
@@@ -40,15 -47,62 +40,57 @@@ config USB_DWC3_DUAL_ROL
  
  endchoice
  
 -comment "Platform Glue Driver Support"
 -
 -config USB_DWC3_OMAP
 -	tristate "Texas Instruments OMAP5 and similar Platforms"
 -	depends on EXTCON && (ARCH_OMAP2PLUS || COMPILE_TEST)
 -	depends on OF
 -	default USB_DWC3
 +config USB_DWC3_DEBUG
 +	bool "Enable Debugging Messages"
  	help
 -	  Some platforms from Texas Instruments like OMAP5, DRA7xxx and
 -	  AM437x use this IP for USB2/3 functionality.
 +	  Say Y here to enable debugging messages on DWC3 Driver.
  
 -	  Say 'Y' or 'M' here if you have one such device
 -
 -config USB_DWC3_EXYNOS
 -	tristate "Samsung Exynos Platform"
 -	depends on (ARCH_EXYNOS || COMPILE_TEST) && OF
 -	default USB_DWC3
 +config USB_DWC3_VERBOSE
 +	bool "Enable Verbose Debugging Messages"
 +	depends on USB_DWC3_DEBUG
  	help
++<<<<<<< HEAD
 +	  Say Y here to enable verbose debugging messages on DWC3 Driver.
++=======
+ 	  Recent Exynos5 SoCs ship with one DesignWare Core USB3 IP inside,
+ 	  say 'Y' or 'M' if you have one such device.
+ 
+ config USB_DWC3_PCI
+ 	tristate "PCIe-based Platforms"
+ 	depends on USB_PCI && ACPI
+ 	default USB_DWC3
+ 	help
+ 	  If you're using the DesignWare Core IP with a PCIe, please say
+ 	  'Y' or 'M' here.
+ 
+ 	  One such PCIe-based platform is Synopsys' PCIe HAPS model of
+ 	  this IP.
+ 
+ config USB_DWC3_KEYSTONE
+ 	tristate "Texas Instruments Keystone2 Platforms"
+ 	depends on ARCH_KEYSTONE || COMPILE_TEST
+ 	default USB_DWC3
+ 	help
+ 	  Support of USB2/3 functionality in TI Keystone2 platforms.
+ 	  Say 'Y' or 'M' here if you have one such device
+ 
+ config USB_DWC3_OF_SIMPLE
+        tristate "Generic OF Simple Glue Layer"
+        depends on OF && COMMON_CLK
+        default USB_DWC3
+        help
+          Support USB2/3 functionality in simple SoC integrations.
+ 	 Currently supports Xilinx and Qualcomm DWC USB3 IP.
+ 	 Say 'Y' or 'M' if you have one such device.
+ 
+ config USB_DWC3_ST
+ 	tristate "STMicroelectronics Platforms"
+ 	depends on (ARCH_STI || COMPILE_TEST) && OF
+ 	default USB_DWC3
+ 	help
+ 	  STMicroelectronics SoCs with one DesignWare Core USB3 IP
+ 	  inside (i.e. STiH407).
+ 	  Say 'Y' or 'M' if you have one such device.
++>>>>>>> 2c93e790e825 (usb: add CONFIG_USB_PCI for system have both PCI HW and non-PCI based USB HW)
  
  endif
* Unmerged path drivers/usb/dwc2/Kconfig
* Unmerged path drivers/usb/gadget/udc/Kconfig
* Unmerged path drivers/usb/gadget/udc/bdc/Kconfig
* Unmerged path drivers/usb/isp1760/isp1760-if.c
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 07f631bbafd3..f32f298e95f7 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -35,7 +35,6 @@ config USB_COMMON
 config USB_ARCH_HAS_HCD
 	def_bool y
 
-# ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
 config USB
 	tristate "Support for Host-side USB"
 	depends on USB_ARCH_HAS_HCD
@@ -73,6 +72,17 @@ config USB
 	  To compile this driver as a module, choose M here: the
 	  module will be called usbcore.
 
+config USB_PCI
+	bool "PCI based USB host interface"
+	depends on PCI
+	default y
+	---help---
+	  A lot of embeded system SOC (e.g. freescale T2080) have both
+	  PCI and USB modules. But USB module is controlled by registers
+	  directly, it have no relationship with PCI module.
+
+	  When say N here it will not build PCI related code in USB driver.
+
 if USB
 
 source "drivers/usb/core/Kconfig"
diff --git a/drivers/usb/Makefile b/drivers/usb/Makefile
index 6a66bfd9ff81..0bd1773aa990 100644
--- a/drivers/usb/Makefile
+++ b/drivers/usb/Makefile
@@ -11,7 +11,7 @@ obj-$(CONFIG_USB_DWC3)		+= dwc3/
 
 obj-$(CONFIG_USB_MON)		+= mon/
 
-obj-$(CONFIG_PCI)		+= host/
+obj-$(CONFIG_USB_PCI)		+= host/
 obj-$(CONFIG_USB_EHCI_HCD)	+= host/
 obj-$(CONFIG_USB_ISP116X_HCD)	+= host/
 obj-$(CONFIG_USB_OHCI_HCD)	+= host/
* Unmerged path drivers/usb/chipidea/Kconfig
diff --git a/drivers/usb/core/Makefile b/drivers/usb/core/Makefile
index b99b871c4b9d..250ec1d662d9 100644
--- a/drivers/usb/core/Makefile
+++ b/drivers/usb/core/Makefile
@@ -8,7 +8,7 @@ usbcore-y += devio.o notify.o generic.o quirks.o devices.o
 usbcore-y += port.o
 
 usbcore-$(CONFIG_OF)		+= of.o
-usbcore-$(CONFIG_PCI)		+= hcd-pci.o
+usbcore-$(CONFIG_USB_PCI)		+= hcd-pci.o
 usbcore-$(CONFIG_ACPI)		+= usb-acpi.o
 
 obj-$(CONFIG_USB)		+= usbcore.o
* Unmerged path drivers/usb/dwc2/Kconfig
* Unmerged path drivers/usb/dwc3/Kconfig
diff --git a/drivers/usb/gadget/net2272.c b/drivers/usb/gadget/net2272.c
index f1e50a3e322d..16b47674e54f 100644
--- a/drivers/usb/gadget/net2272.c
+++ b/drivers/usb/gadget/net2272.c
@@ -657,7 +657,7 @@ net2272_request_dma(struct net2272 *dev, unsigned ep, u32 buf,
 	dev->dma_busy = 1;
 
 	/* initialize platform's dma */
-#ifdef CONFIG_PCI
+#ifdef CONFIG_USB_PCI
 	/* NET2272 addr, buffer addr, length, etc. */
 	switch (dev->dev_id) {
 	case PCI_DEVICE_ID_RDK1:
@@ -705,7 +705,7 @@ static void
 net2272_start_dma(struct net2272 *dev)
 {
 	/* start platform's dma controller */
-#ifdef CONFIG_PCI
+#ifdef CONFIG_USB_PCI
 	switch (dev->dev_id) {
 	case PCI_DEVICE_ID_RDK1:
 		writeb((1 << CHANNEL_ENABLE) | (1 << CHANNEL_START),
@@ -801,7 +801,7 @@ net2272_kick_dma(struct net2272_ep *ep, struct net2272_request *req)
 
 static void net2272_cancel_dma(struct net2272 *dev)
 {
-#ifdef CONFIG_PCI
+#ifdef CONFIG_USB_PCI
 	switch (dev->dev_id) {
 	case PCI_DEVICE_ID_RDK1:
 		writeb(0, dev->rdk1.plx9054_base_addr + DMACSR0);
@@ -2292,7 +2292,7 @@ err_add_udc:
 	return ret;
 }
 
-#ifdef CONFIG_PCI
+#ifdef CONFIG_USB_PCI
 
 /*
  * wrap this driver around the specified device, but
diff --git a/drivers/usb/gadget/net2272.h b/drivers/usb/gadget/net2272.h
index e59505789359..9221313807f7 100644
--- a/drivers/usb/gadget/net2272.h
+++ b/drivers/usb/gadget/net2272.h
@@ -473,7 +473,7 @@ struct net2272 {
 	unsigned int base_shift;
 	u16 __iomem *base_addr;
 	union {
-#ifdef CONFIG_PCI
+#ifdef CONFIG_USB_PCI
 		struct {
 			void __iomem *plx9054_base_addr;
 			void __iomem *epld_base_addr;
* Unmerged path drivers/usb/gadget/udc/Kconfig
* Unmerged path drivers/usb/gadget/udc/bdc/Kconfig
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 22dcbbff8588..14e54ef9fd99 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -30,7 +30,7 @@ if USB_XHCI_HCD
 
 config USB_XHCI_PCI
        tristate
-       depends on PCI
+       depends on USB_PCI
        default y
 
 config USB_XHCI_PLATFORM
@@ -139,7 +139,7 @@ if USB_EHCI_HCD
 
 config USB_EHCI_PCI
 	tristate
-	depends on PCI
+	depends on USB_PCI
 	default y
 
 config USB_EHCI_HCD_PMC_MSP
@@ -537,7 +537,7 @@ config USB_OHCI_HCD_PPC_OF
 
 config USB_OHCI_HCD_PCI
 	tristate "OHCI support for PCI-bus USB controllers"
-	depends on PCI
+	depends on USB_PCI
 	default y
 	select USB_OHCI_LITTLE_ENDIAN
 	---help---
@@ -618,7 +618,7 @@ endif # USB_OHCI_HCD
 
 config USB_UHCI_HCD
 	tristate "UHCI HCD (most Intel and VIA) support"
-	depends on PCI || USB_UHCI_SUPPORT_NON_PCI_HC
+	depends on USB_PCI || USB_UHCI_SUPPORT_NON_PCI_HC
 	---help---
 	  The Universal Host Controller Interface is a standard by Intel for
 	  accessing the USB hardware in the PC (which is also called the USB
@@ -751,7 +751,7 @@ config USB_RENESAS_USBHS_HCD
 
 config USB_WHCI_HCD
 	tristate "Wireless USB Host Controller Interface (WHCI) driver"
-	depends on PCI && USB && UWB
+	depends on USB_PCI && USB && UWB
 	select USB_WUSB
 	select UWB_WHCI
 	help
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index f7d71ade4ab9..ef7dc6c87231 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -30,9 +30,7 @@ endif
 
 obj-$(CONFIG_USB_WHCI_HCD)	+= whci/
 
-ifneq ($(CONFIG_USB), )
-	obj-$(CONFIG_PCI)	+= pci-quirks.o
-endif
+obj-$(CONFIG_USB_PCI)	+= pci-quirks.o
 
 obj-$(CONFIG_USB_EHCI_HCD)	+= ehci-hcd.o
 obj-$(CONFIG_USB_EHCI_PCI)	+= ehci-pci.o
diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 1a2614aae42c..cbb9b8e12c3c 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -803,7 +803,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 	size -= temp;
 	next += temp;
 
-#ifdef	CONFIG_PCI
+#ifdef	CONFIG_USB_PCI
 	/* EHCI 0.96 and later may have "extended capabilities" */
 	if (dev_is_pci(hcd->self.controller)) {
 		struct pci_dev	*pdev;
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 3e871afb85b3..ce8b0831cee4 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -996,7 +996,7 @@ static void ohci_stop (struct usb_hcd *hcd)
 
 /*-------------------------------------------------------------------------*/
 
-#if defined(CONFIG_PM) || defined(CONFIG_PCI)
+#if defined(CONFIG_PM) || defined(CONFIG_USB_PCI)
 
 /* must not be called from interrupt context */
 int ohci_restart(struct ohci_hcd *ohci)
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index a51b189bdbd8..12742d002d2d 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -439,7 +439,7 @@ struct ohci_hcd {
 
 };
 
-#ifdef CONFIG_PCI
+#ifdef CONFIG_USB_PCI
 static inline int quirk_nec(struct ohci_hcd *ohci)
 {
 	return ohci->flags & OHCI_QUIRK_NEC;
diff --git a/drivers/usb/host/pci-quirks.h b/drivers/usb/host/pci-quirks.h
index 6463fdb403c2..655994480198 100644
--- a/drivers/usb/host/pci-quirks.h
+++ b/drivers/usb/host/pci-quirks.h
@@ -1,7 +1,7 @@
 #ifndef __LINUX_USB_PCI_QUIRKS_H
 #define __LINUX_USB_PCI_QUIRKS_H
 
-#ifdef CONFIG_PCI
+#ifdef CONFIG_USB_PCI
 void uhci_reset_hc(struct pci_dev *pdev, unsigned long base);
 int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base);
 int usb_amd_find_chipset_info(void);
@@ -23,6 +23,6 @@ static inline void usb_asmedia_modifyflowcontrol(struct pci_dev *pdev) {}
 static inline void usb_amd_dev_put(void) {}
 static inline void usb_disable_xhci_ports(struct pci_dev *xhci_pdev) {}
 static inline void sb800_prefetch(struct device *dev, int on) {}
-#endif  /* CONFIG_PCI */
+#endif  /* CONFIG_USB_PCI */
 
 #endif  /*  __LINUX_USB_PCI_QUIRKS_H  */
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 683098afa93e..94b150196d4f 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -837,7 +837,7 @@ static int uhci_count_ports(struct usb_hcd *hcd)
 
 static const char hcd_name[] = "uhci_hcd";
 
-#ifdef CONFIG_PCI
+#ifdef CONFIG_USB_PCI
 #include "uhci-pci.c"
 #define	PCI_DRIVER		uhci_pci_driver
 #endif
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 6f986d82472d..7fa318a3091d 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -530,7 +530,7 @@ static inline void uhci_writeb(const struct uhci_hcd *uhci, u8 val, int reg)
 
 #else
 /* Support non-PCI host controllers */
-#ifdef CONFIG_PCI
+#ifdef CONFIG_USB_PCI
 /* Support PCI and non-PCI host controllers */
 #define uhci_has_pci_registers(u)	((u)->io_addr != 0)
 #else
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index c81fab8c4000..4b701bb537d8 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -219,7 +219,7 @@ int xhci_reset(struct xhci_hcd *xhci)
 	return ret;
 }
 
-#ifdef CONFIG_PCI
+#ifdef CONFIG_USB_PCI
 static int xhci_free_msi(struct xhci_hcd *xhci)
 {
 	int i;
* Unmerged path drivers/usb/isp1760/isp1760-if.c
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 40edf6a8533e..dff130151235 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -453,7 +453,7 @@ extern int usb_hcd_find_raw_port_number(struct usb_hcd *hcd, int port1);
 struct platform_device;
 extern void usb_hcd_platform_shutdown(struct platform_device *dev);
 
-#ifdef CONFIG_PCI
+#ifdef CONFIG_USB_PCI
 struct pci_dev;
 struct pci_device_id;
 extern int usb_hcd_pci_probe(struct pci_dev *dev,
@@ -466,7 +466,7 @@ extern int usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *dev);
 #ifdef CONFIG_PM
 extern const struct dev_pm_ops usb_hcd_pci_pm_ops;
 #endif
-#endif /* CONFIG_PCI */
+#endif /* CONFIG_USB_PCI */
 
 /* pci-ish (pdev null is ok) buffer alloc/mapping support */
 void usb_init_pool_max(void);
