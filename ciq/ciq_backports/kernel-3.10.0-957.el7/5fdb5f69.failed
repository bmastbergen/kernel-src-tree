netfilter: ipset: Remove redundant mtype_expire() arguments

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 5fdb5f6938cf241d574f0ff5504d753c801dc4ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5fdb5f69.failed

Remove redundant parameters nets_length and dsize, because
they can be get from other parameters.

Ported from a patch proposed by Sergey Popovich <popovich_sergei@mail.ua>.

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 5fdb5f6938cf241d574f0ff5504d753c801dc4ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_hash_gen.h
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 9ce28af662bf,c4877b6de74f..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -433,43 -463,55 +433,55 @@@ mtype_same_set(const struct ip_set *a, 
  	       a->extensions == b->extensions;
  }
  
 +/* Get the ith element from the array block n */
 +#define ahash_data(n, i, dsize)	\
 +	((struct mtype_elem *)((n)->value + ((i) * (dsize))))
 +
  /* Delete expired elements from the hashtable */
  static void
++<<<<<<< HEAD
 +mtype_expire(struct htype *h, u8 nets_length, size_t dsize)
++=======
+ mtype_expire(struct ip_set *set, struct htype *h)
++>>>>>>> 5fdb5f6938cf (netfilter: ipset: Remove redundant mtype_expire() arguments)
  {
 -	struct htable *t;
 -	struct hbucket *n, *tmp;
 +	struct htable *t = h->table;
 +	struct hbucket *n;
  	struct mtype_elem *data;
++<<<<<<< HEAD
 +	u32 i;
 +	int j;
++=======
+ 	u32 i, j, d;
+ 	size_t dsize = set->dsize;
+ #ifdef IP_SET_HASH_WITH_NETS
+ 	u8 k, nets_length = NLEN(set->family);
+ #endif
++>>>>>>> 5fdb5f6938cf (netfilter: ipset: Remove redundant mtype_expire() arguments)
  
 -	t = ipset_dereference_protected(h->table, set);
  	for (i = 0; i < jhash_size(t->htable_bits); i++) {
 -		n = __ipset_dereference_protected(hbucket(t, i), 1);
 -		if (!n)
 -			continue;
 -		for (j = 0, d = 0; j < n->pos; j++) {
 -			if (!test_bit(j, n->used)) {
 -				d++;
 -				continue;
 -			}
 +		n = hbucket(t, i);
 +		for (j = 0; j < n->pos; j++) {
  			data = ahash_data(n, j, dsize);
 -			if (ip_set_timeout_expired(ext_timeout(data, set))) {
 +			if (ip_set_timeout_expired(ext_timeout(data, h))) {
  				pr_debug("expired %u/%u\n", i, j);
 -				clear_bit(j, n->used);
 -				smp_mb__after_atomic();
  #ifdef IP_SET_HASH_WITH_NETS
 -				for (k = 0; k < IPSET_NET_COUNT; k++)
 -					mtype_del_cidr(h,
 -						NCIDR_PUT(DCIDR_GET(data->cidr,
 -								    k)),
 -						nets_length, k);
 +				mtype_del_cidr(h, CIDR(data->cidr),
 +					       nets_length);
  #endif
 -				ip_set_ext_destroy(set, data);
 -				set->elements--;
 -				d++;
 +				if (j != n->pos - 1)
 +					/* Not last one */
 +					memcpy(data,
 +					       ahash_data(n, n->pos - 1, dsize),
 +					       dsize);
 +				n->pos--;
 +				h->elements--;
  			}
  		}
 -		if (d >= AHASH_INIT_SIZE) {
 -			if (d >= n->size) {
 -				rcu_assign_pointer(hbucket(t, i), NULL);
 -				kfree_rcu(n, rcu);
 -				continue;
 -			}
 -			tmp = kzalloc(sizeof(*tmp) +
 -				      (n->size - AHASH_INIT_SIZE) * dsize,
 -				      GFP_ATOMIC);
 +		if (n->pos + AHASH_INIT_SIZE < n->size) {
 +			void *tmp = kzalloc((n->size - AHASH_INIT_SIZE)
 +					    * dsize,
 +					    GFP_ATOMIC);
  			if (!tmp)
  				/* Still try to delete expired elements */
  				continue;
@@@ -488,11 -539,11 +500,17 @@@ mtype_gc(unsigned long ul_set
  	struct htype *h = set->data;
  
  	pr_debug("called\n");
++<<<<<<< HEAD
 +	write_lock_bh(&set->lock);
 +	mtype_expire(h, NETS_LENGTH(set->family), h->dsize);
 +	write_unlock_bh(&set->lock);
++=======
+ 	spin_lock_bh(&set->lock);
+ 	mtype_expire(set, h);
+ 	spin_unlock_bh(&set->lock);
++>>>>>>> 5fdb5f6938cf (netfilter: ipset: Remove redundant mtype_expire() arguments)
  
 -	h->gc.expires = jiffies + IPSET_GC_PERIOD(set->timeout) * HZ;
 +	h->gc.expires = jiffies + IPSET_GC_PERIOD(h->timeout) * HZ;
  	add_timer(&h->gc);
  }
  
@@@ -594,29 -707,51 +612,38 @@@ mtype_add(struct ip_set *set, void *val
  	struct htable *t;
  	const struct mtype_elem *d = value;
  	struct mtype_elem *data;
 -	struct hbucket *n, *old = ERR_PTR(-ENOENT);
 -	int i, j = -1;
 +	struct hbucket *n;
 +	int i, ret = 0;
 +	int j = AHASH_MAX(h) + 1;
  	bool flag_exist = flags & IPSET_FLAG_EXIST;
 -	bool deleted = false, forceadd = false, reuse = false;
  	u32 key, multi = 0;
  
++<<<<<<< HEAD
 +	if (SET_WITH_TIMEOUT(set) && h->elements >= h->maxelem)
 +		/* FIXME: when set is full, we slow down here */
 +		mtype_expire(h, NETS_LENGTH(set->family), h->dsize);
 +
 +	if (h->elements >= h->maxelem) {
 +		if (net_ratelimit())
 +			pr_warning("Set %s is full, maxelem %u reached\n",
 +				   set->name, h->maxelem);
 +		return -IPSET_ERR_HASH_FULL;
++=======
+ 	if (set->elements >= h->maxelem) {
+ 		if (SET_WITH_TIMEOUT(set))
+ 			/* FIXME: when set is full, we slow down here */
+ 			mtype_expire(set, h);
+ 		if (set->elements >= h->maxelem && SET_WITH_FORCEADD(set))
+ 			forceadd = true;
++>>>>>>> 5fdb5f6938cf (netfilter: ipset: Remove redundant mtype_expire() arguments)
  	}
  
 -	t = ipset_dereference_protected(h->table, set);
 +	rcu_read_lock_bh();
 +	t = rcu_dereference_bh(h->table);
  	key = HKEY(value, h->initval, t->htable_bits);
 -	n = __ipset_dereference_protected(hbucket(t, key), 1);
 -	if (!n) {
 -		if (forceadd) {
 -			if (net_ratelimit())
 -				pr_warn("Set %s is full, maxelem %u reached\n",
 -					set->name, h->maxelem);
 -			return -IPSET_ERR_HASH_FULL;
 -		} else if (set->elements >= h->maxelem) {
 -			goto set_full;
 -		}
 -		old = NULL;
 -		n = kzalloc(sizeof(*n) + AHASH_INIT_SIZE * set->dsize,
 -			    GFP_ATOMIC);
 -		if (!n)
 -			return -ENOMEM;
 -		n->size = AHASH_INIT_SIZE;
 -		set->ext_size += sizeof(*n) + AHASH_INIT_SIZE * set->dsize;
 -		goto copy_elem;
 -	}
 +	n = hbucket(t, key);
  	for (i = 0; i < n->pos; i++) {
 -		if (!test_bit(i, n->used)) {
 -			/* Reuse first deleted entry */
 -			if (j == -1) {
 -				deleted = reuse = true;
 -				j = i;
 -			}
 -			continue;
 -		}
 -		data = ahash_data(n, i, set->dsize);
 +		data = ahash_data(n, i, h->dsize);
  		if (mtype_data_equal(data, d, &multi)) {
  			if (flag_exist ||
  			    (SET_WITH_TIMEOUT(set) &&
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
