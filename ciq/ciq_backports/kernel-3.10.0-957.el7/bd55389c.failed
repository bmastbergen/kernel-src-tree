netfilter:ipset Remove rbtree from hash:net,iface

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] netfilter: ipset Remove rbtree from hash:net, iface (Stefano Brivio) [1557599]
Rebuild_FUZZ: 98.00%
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit bd55389cc34b75948c2876c821175a976bbac5b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/bd55389c.failed

Remove rbtree in order to introduce RCU instead of rwlock in ipset

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit bd55389cc34b75948c2876c821175a976bbac5b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_hash_netiface.c
diff --cc net/netfilter/ipset/ip_set_hash_netiface.c
index aa4929b15a09,3258189a296f..000000000000
--- a/net/netfilter/ipset/ip_set_hash_netiface.c
+++ b/net/netfilter/ipset/ip_set_hash_netiface.c
@@@ -34,108 -36,15 +33,110 @@@ MODULE_AUTHOR("Jozsef Kadlecsik <kadlec
  IP_SET_MODULE_DESC("hash:net,iface", IPSET_TYPE_REV_MIN, IPSET_TYPE_REV_MAX);
  MODULE_ALIAS("ip_set_hash:net,iface");
  
++<<<<<<< HEAD
 +/* Interface name rbtree */
 +
 +struct iface_node {
 +	struct rb_node node;
 +	char iface[IFNAMSIZ];
 +};
 +
 +#define iface_data(n)	(rb_entry(n, struct iface_node, node)->iface)
 +
 +static void
 +rbtree_destroy(struct rb_root *root)
 +{
 +	struct rb_node *p, *n = root->rb_node;
 +	struct iface_node *node;
 +
 +	/* Non-recursive destroy, like in ext3 */
 +	while (n) {
 +		if (n->rb_left) {
 +			n = n->rb_left;
 +			continue;
 +		}
 +		if (n->rb_right) {
 +			n = n->rb_right;
 +			continue;
 +		}
 +		p = rb_parent(n);
 +		node = rb_entry(n, struct iface_node, node);
 +		if (!p)
 +			*root = RB_ROOT;
 +		else if (p->rb_left == n)
 +			p->rb_left = NULL;
 +		else if (p->rb_right == n)
 +			p->rb_right = NULL;
 +
 +		kfree(node);
 +		n = p;
 +	}
 +}
 +
 +static int
 +iface_test(struct rb_root *root, const char **iface)
 +{
 +	struct rb_node *n = root->rb_node;
 +
 +	while (n) {
 +		const char *d = iface_data(n);
 +		int res = strcmp(*iface, d);
 +
 +		if (res < 0)
 +			n = n->rb_left;
 +		else if (res > 0)
 +			n = n->rb_right;
 +		else {
 +			*iface = d;
 +			return 1;
 +		}
 +	}
 +	return 0;
 +}
 +
 +static int
 +iface_add(struct rb_root *root, const char **iface)
 +{
 +	struct rb_node **n = &(root->rb_node), *p = NULL;
 +	struct iface_node *d;
 +
 +	while (*n) {
 +		char *ifname = iface_data(*n);
 +		int res = strcmp(*iface, ifname);
 +
 +		p = *n;
 +		if (res < 0)
 +			n = &((*n)->rb_left);
 +		else if (res > 0)
 +			n = &((*n)->rb_right);
 +		else {
 +			*iface = ifname;
 +			return 0;
 +		}
 +	}
 +
 +	d = kzalloc(sizeof(*d), GFP_ATOMIC);
 +	if (!d)
 +		return -ENOMEM;
 +	strcpy(d->iface, *iface);
 +
 +	rb_link_node(&d->node, p, n);
 +	rb_insert_color(&d->node, root);
 +
 +	*iface = d->iface;
 +	return 0;
 +}
 +
++=======
++>>>>>>> bd55389cc34b (netfilter:ipset Remove rbtree from hash:net,iface)
  /* Type specific function prefix */
  #define HTYPE		hash_netiface
  #define IP_SET_HASH_WITH_NETS
- #define IP_SET_HASH_WITH_RBTREE
  #define IP_SET_HASH_WITH_MULTI
 -#define IP_SET_HASH_WITH_NET0
  
- #define STREQ(a, b)	(strcmp(a, b) == 0)
+ #define STRLCPY(a, b)	strlcpy(a, b, IFNAMSIZ)
  
 -/* IPv4 variant */
 +/* IPv4 variants */
  
  struct hash_netiface4_elem_hashed {
  	__be32 ip;
@@@ -152,40 -61,9 +153,40 @@@ struct hash_netiface4_elem 
  	u8 cidr;
  	u8 nomatch;
  	u8 elem;
- 	const char *iface;
+ 	char iface[IFNAMSIZ];
  };
  
 +struct hash_netiface4t_elem {
 +	__be32 ip;
 +	u8 physdev;
 +	u8 cidr;
 +	u8 nomatch;
 +	u8 elem;
 +	const char *iface;
 +	unsigned long timeout;
 +};
 +
 +struct hash_netiface4c_elem {
 +	__be32 ip;
 +	u8 physdev;
 +	u8 cidr;
 +	u8 nomatch;
 +	u8 elem;
 +	const char *iface;
 +	struct ip_set_counter counter;
 +};
 +
 +struct hash_netiface4ct_elem {
 +	__be32 ip;
 +	u8 physdev;
 +	u8 cidr;
 +	u8 nomatch;
 +	u8 elem;
 +	const char *iface;
 +	struct ip_set_counter counter;
 +	unsigned long timeout;
 +};
 +
  /* Common functions */
  
  static inline bool
@@@ -282,11 -159,10 +283,15 @@@ hash_netiface4_kadt(struct ip_set *set
  	struct hash_netiface *h = set->data;
  	ipset_adtfn adtfn = set->variant->adt[adt];
  	struct hash_netiface4_elem e = {
 -		.cidr = INIT_CIDR(h->nets[0].cidr[0], HOST_MASK),
 +		.cidr = h->nets[0].cidr ? h->nets[0].cidr : HOST_MASK,
  		.elem = 1,
  	};
++<<<<<<< HEAD
 +	struct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, h);
 +	int ret;
++=======
+ 	struct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);
++>>>>>>> bd55389cc34b (netfilter:ipset Remove rbtree from hash:net,iface)
  
  	if (e.cidr == 0)
  		return -EINVAL;
@@@ -335,24 -200,23 +329,23 @@@ hash_netiface4_uadt(struct ip_set *set
  	struct hash_netiface *h = set->data;
  	ipset_adtfn adtfn = set->variant->adt[adt];
  	struct hash_netiface4_elem e = { .cidr = HOST_MASK, .elem = 1 };
 -	struct ip_set_ext ext = IP_SET_INIT_UEXT(set);
 +	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
  	u32 ip = 0, ip_to = 0, last;
- 	char iface[IFNAMSIZ];
  	int ret;
  
 -	if (tb[IPSET_ATTR_LINENO])
 -		*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);
 -
  	if (unlikely(!tb[IPSET_ATTR_IP] ||
  		     !tb[IPSET_ATTR_IFACE] ||
 -		     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS) ||
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_PACKETS) ||
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_BYTES)))
  		return -IPSET_ERR_PROTOCOL;
  
 -	ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip);
 -	if (ret)
 -		return ret;
 +	if (tb[IPSET_ATTR_LINENO])
 +		*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);
  
 -	ret = ip_set_get_extensions(set, tb, &ext);
 +	ret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip) ||
 +	      ip_set_get_extensions(set, tb, &ext);
  	if (ret)
  		return ret;
  
@@@ -431,40 -284,9 +413,40 @@@ struct hash_netiface6_elem 
  	u8 cidr;
  	u8 nomatch;
  	u8 elem;
- 	const char *iface;
+ 	char iface[IFNAMSIZ];
  };
  
 +struct hash_netiface6t_elem {
 +	union nf_inet_addr ip;
 +	u8 physdev;
 +	u8 cidr;
 +	u8 nomatch;
 +	u8 elem;
 +	const char *iface;
 +	unsigned long timeout;
 +};
 +
 +struct hash_netiface6c_elem {
 +	union nf_inet_addr ip;
 +	u8 physdev;
 +	u8 cidr;
 +	u8 nomatch;
 +	u8 elem;
 +	const char *iface;
 +	struct ip_set_counter counter;
 +};
 +
 +struct hash_netiface6ct_elem {
 +	union nf_inet_addr ip;
 +	u8 physdev;
 +	u8 cidr;
 +	u8 nomatch;
 +	u8 elem;
 +	const char *iface;
 +	struct ip_set_counter counter;
 +	unsigned long timeout;
 +};
 +
  /* Common functions */
  
  static inline bool
@@@ -549,11 -369,10 +531,15 @@@ hash_netiface6_kadt(struct ip_set *set
  	struct hash_netiface *h = set->data;
  	ipset_adtfn adtfn = set->variant->adt[adt];
  	struct hash_netiface6_elem e = {
 -		.cidr = INIT_CIDR(h->nets[0].cidr[0], HOST_MASK),
 +		.cidr = h->nets[0].cidr ? h->nets[0].cidr : HOST_MASK,
  		.elem = 1,
  	};
++<<<<<<< HEAD
 +	struct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, h);
 +	int ret;
++=======
+ 	struct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);
++>>>>>>> bd55389cc34b (netfilter:ipset Remove rbtree from hash:net,iface)
  
  	if (e.cidr == 0)
  		return -EINVAL;
@@@ -596,19 -405,17 +572,22 @@@ static in
  hash_netiface6_uadt(struct ip_set *set, struct nlattr *tb[],
  		   enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
  {
- 	struct hash_netiface *h = set->data;
  	ipset_adtfn adtfn = set->variant->adt[adt];
  	struct hash_netiface6_elem e = { .cidr = HOST_MASK, .elem = 1 };
++<<<<<<< HEAD
 +	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
 +	char iface[IFNAMSIZ];
++=======
+ 	struct ip_set_ext ext = IP_SET_INIT_UEXT(set);
++>>>>>>> bd55389cc34b (netfilter:ipset Remove rbtree from hash:net,iface)
  	int ret;
  
 -	if (tb[IPSET_ATTR_LINENO])
 -		*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);
 -
  	if (unlikely(!tb[IPSET_ATTR_IP] ||
  		     !tb[IPSET_ATTR_IFACE] ||
 -		     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS) ||
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_PACKETS) ||
 +		     !ip_set_optattr_netorder(tb, IPSET_ATTR_BYTES)))
  		return -IPSET_ERR_PROTOCOL;
  	if (unlikely(tb[IPSET_ATTR_IP_TO]))
  		return -IPSET_ERR_HASH_RANGE_UNSUPPORTED;
@@@ -621,23 -428,15 +600,13 @@@
  	if (ret)
  		return ret;
  
 -	if (tb[IPSET_ATTR_CIDR]) {
 +	if (tb[IPSET_ATTR_CIDR])
  		e.cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);
 -		if (e.cidr > HOST_MASK)
 -			return -IPSET_ERR_INVALID_CIDR;
 -	}
 -
 +	if (e.cidr > HOST_MASK)
 +		return -IPSET_ERR_INVALID_CIDR;
  	ip6_netmask(&e.ip, e.cidr);
  
- 	strcpy(iface, nla_data(tb[IPSET_ATTR_IFACE]));
- 	e.iface = iface;
- 	ret = iface_test(&h->rbtree, &e.iface);
- 	if (adt == IPSET_ADD) {
- 		if (!ret) {
- 			ret = iface_add(&h->rbtree, &e.iface);
- 			if (ret)
- 				return ret;
- 		}
- 	} else if (!ret)
- 		return ret;
+ 	nla_strlcpy(e.iface, tb[IPSET_ATTR_IFACE], IFNAMSIZ);
  
  	if (tb[IPSET_ATTR_CADT_FLAGS]) {
  		u32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
* Unmerged path net/netfilter/ipset/ip_set_hash_netiface.c
