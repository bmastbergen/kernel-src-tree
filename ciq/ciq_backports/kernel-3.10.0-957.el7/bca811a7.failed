nfit, address-range-scrub: add module option to skip initial ars

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit bca811a7fd5a5c1c0644926161c2843322ab74b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/bca811a7.failed

After attempting to quickly retrieve known errors the kernel proceeds to
kick off a long running ARS. Add a module option to disable this
behavior at initialization time, or at new region discovery time.
Otherwise, ARS can be started manually regardless of the state of this
setting.

Co-developed-by: Dave Jiang <dave.jiang@intel.com>
	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit bca811a7fd5a5c1c0644926161c2843322ab74b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/nfit/core.c
diff --cc drivers/acpi/nfit/core.c
index b51217b6f576,7f3c70fde9a8..000000000000
--- a/drivers/acpi/nfit/core.c
+++ b/drivers/acpi/nfit/core.c
@@@ -2742,84 -2815,107 +2746,142 @@@ static int acpi_nfit_query_poison(struc
  	return 0;
  }
  
 -static int ars_register(struct acpi_nfit_desc *acpi_desc, struct nfit_spa *nfit_spa,
 -		int *query_rc)
 +static void acpi_nfit_async_scrub(struct acpi_nfit_desc *acpi_desc,
 +		struct nfit_spa *nfit_spa)
  {
++<<<<<<< HEAD
 +	struct acpi_nfit_system_address *spa = nfit_spa->spa;
 +	unsigned int overflow_retry = scrub_overflow_abort;
 +	u64 init_ars_start = 0, init_ars_len = 0;
++=======
+ 	int rc = *query_rc;
+ 
+ 	if (no_init_ars)
+ 		return acpi_nfit_register_region(acpi_desc, nfit_spa);
+ 
+ 	set_bit(ARS_REQ, &nfit_spa->ars_state);
+ 	set_bit(ARS_SHORT, &nfit_spa->ars_state);
+ 
+ 	switch (rc) {
+ 	case 0:
+ 	case -EAGAIN:
+ 		rc = ars_start(acpi_desc, nfit_spa);
+ 		if (rc == -EBUSY) {
+ 			*query_rc = rc;
+ 			break;
+ 		} else if (rc == 0) {
+ 			rc = acpi_nfit_query_poison(acpi_desc);
+ 		} else {
+ 			set_bit(ARS_FAILED, &nfit_spa->ars_state);
+ 			break;
+ 		}
+ 		if (rc == -EAGAIN)
+ 			clear_bit(ARS_SHORT, &nfit_spa->ars_state);
+ 		else if (rc == 0)
+ 			ars_complete(acpi_desc, nfit_spa);
+ 		break;
+ 	case -EBUSY:
+ 	case -ENOSPC:
+ 		break;
+ 	default:
+ 		set_bit(ARS_FAILED, &nfit_spa->ars_state);
+ 		break;
+ 	}
+ 
+ 	if (test_and_clear_bit(ARS_DONE, &nfit_spa->ars_state))
+ 		set_bit(ARS_REQ, &nfit_spa->ars_state);
+ 
+ 	return acpi_nfit_register_region(acpi_desc, nfit_spa);
+ }
+ 
+ static void ars_complete_all(struct acpi_nfit_desc *acpi_desc)
+ {
+ 	struct nfit_spa *nfit_spa;
+ 
+ 	list_for_each_entry(nfit_spa, &acpi_desc->spas, list) {
+ 		if (test_bit(ARS_FAILED, &nfit_spa->ars_state))
+ 			continue;
+ 		ars_complete(acpi_desc, nfit_spa);
+ 	}
+ }
+ 
+ static unsigned int __acpi_nfit_scrub(struct acpi_nfit_desc *acpi_desc,
+ 		int query_rc)
+ {
+ 	unsigned int tmo = acpi_desc->scrub_tmo;
++>>>>>>> bca811a7fd5a (nfit, address-range-scrub: add module option to skip initial ars)
  	struct device *dev = acpi_desc->dev;
 -	struct nfit_spa *nfit_spa;
 +	unsigned int tmo = scrub_timeout;
 +	int rc;
  
 -	if (acpi_desc->cancel)
 -		return 0;
 +	if (!test_bit(ARS_REQ, &nfit_spa->ars_state) || !nfit_spa->nd_region)
 +		return;
  
 -	if (query_rc == -EBUSY) {
 -		dev_dbg(dev, "ARS: ARS busy\n");
 -		return min(30U * 60U, tmo * 2);
 -	}
 -	if (query_rc == -ENOSPC) {
 -		dev_dbg(dev, "ARS: ARS continue\n");
 -		ars_continue(acpi_desc);
 -		return 1;
 -	}
 -	if (query_rc && query_rc != -EAGAIN) {
 -		unsigned long long addr, end;
 +	rc = ars_start(acpi_desc, nfit_spa);
 +	/*
 +	 * If we timed out the initial scan we'll still be busy here,
 +	 * and will wait another timeout before giving up permanently.
 +	 */
 +	if (rc < 0 && rc != -EBUSY)
 +		return;
  
 -		addr = acpi_desc->ars_status->address;
 -		end = addr + acpi_desc->ars_status->length;
 -		dev_dbg(dev, "ARS: %llx-%llx failed (%d)\n", addr, end,
 -				query_rc);
 -	}
 +	do {
 +		u64 ars_start, ars_len;
  
 -	ars_complete_all(acpi_desc);
 -	list_for_each_entry(nfit_spa, &acpi_desc->spas, list) {
 -		if (test_bit(ARS_FAILED, &nfit_spa->ars_state))
 +		if (acpi_desc->cancel)
 +			break;
 +		rc = acpi_nfit_query_poison(acpi_desc);
 +		if (rc == -ENOTTY)
 +			break;
 +		if (rc == -EBUSY && !tmo) {
 +			dev_warn(dev, "range %d ars timeout, aborting\n",
 +					spa->range_index);
 +			break;
 +		}
 +
 +		if (rc == -EBUSY) {
 +			/*
 +			 * Note, entries may be appended to the list
 +			 * while the lock is dropped, but the workqueue
 +			 * being active prevents entries being deleted /
 +			 * freed.
 +			 */
 +			mutex_unlock(&acpi_desc->init_mutex);
 +			ssleep(1);
 +			tmo--;
 +			mutex_lock(&acpi_desc->init_mutex);
  			continue;
 -		if (test_bit(ARS_REQ, &nfit_spa->ars_state)) {
 -			int rc = ars_start(acpi_desc, nfit_spa);
 -
 -			clear_bit(ARS_DONE, &nfit_spa->ars_state);
 -			dev = nd_region_dev(nfit_spa->nd_region);
 -			dev_dbg(dev, "ARS: range %d ARS start (%d)\n",
 -					nfit_spa->spa->range_index, rc);
 -			if (rc == 0 || rc == -EBUSY)
 -				return 1;
 -			dev_err(dev, "ARS: range %d ARS failed (%d)\n",
 -					nfit_spa->spa->range_index, rc);
 -			set_bit(ARS_FAILED, &nfit_spa->ars_state);
  		}
 -	}
 -	return 0;
 +
 +		/* we got some results, but there are more pending... */
 +		if (rc == -ENOSPC && overflow_retry--) {
 +			if (!init_ars_len) {
 +				init_ars_len = acpi_desc->ars_status->length;
 +				init_ars_start = acpi_desc->ars_status->address;
 +			}
 +			rc = ars_continue(acpi_desc);
 +		}
 +
 +		if (rc < 0) {
 +			dev_warn(dev, "range %d ars continuation failed\n",
 +					spa->range_index);
 +			break;
 +		}
 +
 +		if (init_ars_len) {
 +			ars_start = init_ars_start;
 +			ars_len = init_ars_len;
 +		} else {
 +			ars_start = acpi_desc->ars_status->address;
 +			ars_len = acpi_desc->ars_status->length;
 +		}
 +		dev_dbg(dev, "spa range: %d ars from %#llx + %#llx complete\n",
 +				spa->range_index, ars_start, ars_len);
 +		/* notify the region about new poison entries */
 +		nvdimm_region_notify(nfit_spa->nd_region,
 +				NVDIMM_REVALIDATE_POISON);
 +		break;
 +	} while (1);
  }
  
  static void acpi_nfit_scrub(struct work_struct *work)
* Unmerged path drivers/acpi/nfit/core.c
