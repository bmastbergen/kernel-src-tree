drm/nouveau/disp/nv50-: pass nvkm_memory objects for channel push buffers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ben Skeggs <bskeggs@redhat.com>
commit f5650478ab07c0921127a6a0735253b64073e978
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f5650478.failed

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit f5650478ab07c0921127a6a0735253b64073e978)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/include/nvif/mem.h
#	drivers/gpu/drm/nouveau/include/nvif/mmu.h
#	drivers/gpu/drm/nouveau/nv50_display.c
#	drivers/gpu/drm/nouveau/nvif/mem.c
#	drivers/gpu/drm/nouveau/nvif/mmu.c
#	drivers/gpu/drm/nouveau/nvkm/engine/disp/channv50.c
#	drivers/gpu/drm/nouveau/nvkm/engine/disp/channv50.h
#	drivers/gpu/drm/nouveau/nvkm/engine/disp/dmacnv50.c
diff --cc drivers/gpu/drm/nouveau/nv50_display.c
index b4bd2b5f0988,e90330e4e8c5..000000000000
--- a/drivers/gpu/drm/nouveau/nv50_display.c
+++ b/drivers/gpu/drm/nouveau/nv50_display.c
@@@ -509,20 -511,10 +509,9 @@@ nv50_dmac_create(struct nvif_device *de
  	int ret;
  
  	mutex_init(&dmac->lock);
 -	INIT_LIST_HEAD(&dmac->ctxdma);
  
- 	dmac->ptr = dma_alloc_coherent(nvxx_device(device)->dev, PAGE_SIZE,
- 				       &dmac->handle, GFP_KERNEL);
- 	if (!dmac->ptr)
- 		return -ENOMEM;
- 
- 	ret = nvif_object_init(&device->object, 0, NV_DMA_FROM_MEMORY,
- 			       &(struct nv_dma_v0) {
- 					.target = NV_DMA_V0_TARGET_PCI_US,
- 					.access = NV_DMA_V0_ACCESS_RD,
- 					.start = dmac->handle + 0x0000,
- 					.limit = dmac->handle + 0x0fff,
- 			       }, sizeof(struct nv_dma_v0), &pushbuf);
+ 	ret = nvif_mem_init_map(&cli->mmu, NVIF_MEM_COHERENT, 0x1000,
+ 				&dmac->push);
  	if (ret)
  		return ret;
  
@@@ -2294,17 -2339,14 +2279,20 @@@ nv50_head_reset(struct drm_crtc *crtc
  static void
  nv50_head_destroy(struct drm_crtc *crtc)
  {
++<<<<<<< HEAD
 +	struct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);
 +	struct nv50_disp *disp = nv50_disp(crtc->dev);
++=======
++>>>>>>> f5650478ab07 (drm/nouveau/disp/nv50-: pass nvkm_memory objects for channel push buffers)
  	struct nv50_head *head = nv50_head(crtc);
 -	int i;
  
- 	nv50_dmac_destroy(&head->ovly.base, disp->disp);
+ 	nv50_dmac_destroy(&head->ovly.base);
  	nv50_pioc_destroy(&head->oimm.base);
  
 -	for (i = 0; i < ARRAY_SIZE(head->lut.nvbo); i++)
 -		nouveau_bo_unmap_unpin_unref(&head->lut.nvbo[i]);
 +	nouveau_bo_unmap(nv_crtc->lut.nvbo);
 +	if (nv_crtc->lut.nvbo)
 +		nouveau_bo_unpin(nv_crtc->lut.nvbo);
 +	nouveau_bo_ref(NULL, &nv_crtc->lut.nvbo);
  
  	drm_crtc_cleanup(crtc);
  	kfree(crtc);
diff --cc drivers/gpu/drm/nouveau/nvkm/engine/disp/channv50.c
index badbd62b90c7,57719f675eec..000000000000
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/channv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/channv50.c
@@@ -246,7 -316,8 +246,12 @@@ nv50_disp_chan_dtor(struct nvkm_object 
  	struct nv50_disp *disp = chan->disp;
  	if (chan->chid.user >= 0)
  		disp->chan[chan->chid.user] = NULL;
++<<<<<<< HEAD
 +	return chan->func->dtor ? chan->func->dtor(chan) : chan;
++=======
+ 	nvkm_memory_unref(&chan->memory);
+ 	return chan;
++>>>>>>> f5650478ab07 (drm/nouveau/disp/nv50-: pass nvkm_memory objects for channel push buffers)
  }
  
  static const struct nvkm_object_func
diff --cc drivers/gpu/drm/nouveau/nvkm/engine/disp/channv50.h
index 57ef0de1c7e7,391b007a6824..000000000000
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/channv50.h
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/channv50.h
@@@ -17,6 -18,9 +17,12 @@@ struct nv50_disp_chan 
  	int head;
  
  	struct nvkm_object object;
++<<<<<<< HEAD
++=======
+ 
+ 	struct nvkm_memory *memory;
+ 	u64 push;
++>>>>>>> f5650478ab07 (drm/nouveau/disp/nv50-: pass nvkm_memory objects for channel push buffers)
  };
  
  struct nv50_disp_chan_func {
diff --cc drivers/gpu/drm/nouveau/nvkm/engine/disp/dmacnv50.c
index d081947d0689,9e8a9d7a9b68..000000000000
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dmacnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dmacnv50.c
@@@ -21,13 -21,12 +21,14 @@@
   *
   * Authors: Ben Skeggs
   */
 -#include "channv50.h"
 +#include "dmacnv50.h"
 +#include "rootnv50.h"
  
  #include <core/client.h>
 +#include <core/oproxy.h>
  #include <core/ramht.h>
  #include <subdev/fb.h>
+ #include <subdev/mmu.h>
  #include <subdev/timer.h>
  #include <engine/dma.h>
  
@@@ -138,17 -38,12 +139,21 @@@ nv50_disp_dmac_new_(const struct nv50_d
  		    struct nvkm_object **pobject)
  {
  	struct nvkm_client *client = oclass->client;
++<<<<<<< HEAD
 +	struct nvkm_dmaobj *dmaobj;
 +	struct nv50_disp_dmac *chan;
++=======
+ 	struct nv50_disp_chan *chan;
++>>>>>>> f5650478ab07 (drm/nouveau/disp/nv50-: pass nvkm_memory objects for channel push buffers)
  	int ret;
  
 -	ret = nv50_disp_chan_new_(func, mthd, disp, chid, chid, head, oclass,
 -				  pobject);
 -	chan = nv50_disp_chan(*pobject);
 +	if (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))
 +		return -ENOMEM;
 +	*pobject = &chan->base.object;
 +	chan->func = func;
 +
 +	ret = nv50_disp_chan_ctor(&nv50_disp_dmac_func_, mthd, disp,
 +				  chid, chid, head, oclass, &chan->base);
  	if (ret)
  		return ret;
  
* Unmerged path drivers/gpu/drm/nouveau/include/nvif/mem.h
* Unmerged path drivers/gpu/drm/nouveau/include/nvif/mmu.h
* Unmerged path drivers/gpu/drm/nouveau/nvif/mem.c
* Unmerged path drivers/gpu/drm/nouveau/nvif/mmu.c
* Unmerged path drivers/gpu/drm/nouveau/include/nvif/mem.h
* Unmerged path drivers/gpu/drm/nouveau/include/nvif/mmu.h
* Unmerged path drivers/gpu/drm/nouveau/nv50_display.c
* Unmerged path drivers/gpu/drm/nouveau/nvif/mem.c
* Unmerged path drivers/gpu/drm/nouveau/nvif/mmu.c
* Unmerged path drivers/gpu/drm/nouveau/nvkm/engine/disp/channv50.c
* Unmerged path drivers/gpu/drm/nouveau/nvkm/engine/disp/channv50.h
* Unmerged path drivers/gpu/drm/nouveau/nvkm/engine/disp/dmacnv50.c
