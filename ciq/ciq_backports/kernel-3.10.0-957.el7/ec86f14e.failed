bnxt_en: Add ULP calls to stop and restart IRQs.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] bnxt_en: Add ULP calls to stop and restart IRQs (Jonathan Toppins) [1526120]
Rebuild_FUZZ: 98.95%
commit-author Michael Chan <michael.chan@broadcom.com>
commit ec86f14ea5064e36ee111297bdb376dda4cba264
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ec86f14e.failed

When the driver needs to re-initailize the IRQ vectors, we make the
new ulp_irq_stop() call to tell the RDMA driver to disable and free
the IRQ vectors.  After IRQ vectors have been re-initailized, we
make the ulp_irq_restart() call to tell the RDMA driver that
IRQs can be restarted.

	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ec86f14ea5064e36ee111297bdb376dda4cba264)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index ce115696763b,1991f0c7bc0e..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -5934,9 -6062,12 +5934,16 @@@ static int bnxt_reserve_rings(struct bn
  		netdev_err(bp->dev, "ring reservation failure rc: %d\n", rc);
  		return rc;
  	}
++<<<<<<< HEAD
 +	if ((bp->flags & BNXT_FLAG_NEW_RM) && bp->cp_nr_rings > orig_cp) {
++=======
+ 	if ((bp->flags & BNXT_FLAG_NEW_RM) &&
+ 	    (bnxt_get_num_msix(bp) != bp->total_irqs)) {
+ 		bnxt_ulp_irq_stop(bp);
++>>>>>>> ec86f14ea506 (bnxt_en: Add ULP calls to stop and restart IRQs.)
  		bnxt_clear_int_mode(bp);
  		rc = bnxt_init_int_mode(bp);
+ 		bnxt_ulp_irq_restart(bp, rc);
  		if (rc)
  			return rc;
  	}
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c
index 62636cd44331,347e4f946eb2..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c
@@@ -107,7 -121,8 +121,12 @@@ static int bnxt_req_msix_vecs(struct bn
  	struct net_device *dev = edev->net;
  	struct bnxt *bp = netdev_priv(dev);
  	int max_idx, max_cp_rings;
++<<<<<<< HEAD
 +	int avail_msix, i, idx;
++=======
+ 	int avail_msix, idx;
+ 	int rc = 0;
++>>>>>>> ec86f14ea506 (bnxt_en: Add ULP calls to stop and restart IRQs.)
  
  	ASSERT_RTNL();
  	if (ulp_id != BNXT_ROCE_ULP)
@@@ -127,19 -141,37 +146,46 @@@
  	if (avail_msix > num_msix)
  		avail_msix = num_msix;
  
 -	if (bp->flags & BNXT_FLAG_NEW_RM) {
 +	if (bp->flags & BNXT_FLAG_NEW_RM)
  		idx = bp->cp_nr_rings;
 -	} else {
 -		max_idx = min_t(int, bp->total_irqs, max_cp_rings);
 +	else
  		idx = max_idx - avail_msix;
 -	}
  	edev->ulp_tbl[ulp_id].msix_base = idx;
++<<<<<<< HEAD
 +	for (i = 0; i < avail_msix; i++) {
 +		ent[i].vector = bp->irq_tbl[idx + i].vector;
 +		ent[i].ring_idx = idx + i;
 +		ent[i].db_offset = (idx + i) * 0x80;
 +	}
 +	bnxt_set_max_func_irqs(bp, max_idx - avail_msix);
 +	bnxt_set_max_func_cp_rings(bp, max_cp_rings - avail_msix);
 +	edev->ulp_tbl[ulp_id].msix_requested = avail_msix;
++=======
+ 	edev->ulp_tbl[ulp_id].msix_requested = avail_msix;
+ 	if (bp->total_irqs < (idx + avail_msix)) {
+ 		if (netif_running(dev)) {
+ 			bnxt_close_nic(bp, true, false);
+ 			rc = bnxt_open_nic(bp, true, false);
+ 		} else {
+ 			rc = bnxt_reserve_rings(bp);
+ 		}
+ 	}
+ 	if (rc) {
+ 		edev->ulp_tbl[ulp_id].msix_requested = 0;
+ 		return -EAGAIN;
+ 	}
+ 
+ 	if (bp->flags & BNXT_FLAG_NEW_RM) {
+ 		struct bnxt_hw_resc *hw_resc = &bp->hw_resc;
+ 
+ 		avail_msix = hw_resc->resv_cp_rings - bp->cp_nr_rings;
+ 		edev->ulp_tbl[ulp_id].msix_requested = avail_msix;
+ 	}
+ 	bnxt_fill_msix_vecs(bp, ent);
+ 	bnxt_set_max_func_irqs(bp, bnxt_get_max_func_irqs(bp) - avail_msix);
+ 	bnxt_set_max_func_cp_rings(bp, max_cp_rings - avail_msix);
+ 	edev->flags |= BNXT_EN_FLAG_MSIX_REQUESTED;
++>>>>>>> ec86f14ea506 (bnxt_en: Add ULP calls to stop and restart IRQs.)
  	return avail_msix;
  }
  
@@@ -157,7 -192,12 +206,16 @@@ static int bnxt_free_msix_vecs(struct b
  	msix_requested = edev->ulp_tbl[ulp_id].msix_requested;
  	bnxt_set_max_func_cp_rings(bp, max_cp_rings + msix_requested);
  	edev->ulp_tbl[ulp_id].msix_requested = 0;
++<<<<<<< HEAD
 +	bnxt_set_max_func_irqs(bp, bp->total_irqs);
++=======
+ 	bnxt_set_max_func_irqs(bp, bnxt_get_max_func_irqs(bp) + msix_requested);
+ 	edev->flags &= ~BNXT_EN_FLAG_MSIX_REQUESTED;
+ 	if (netif_running(dev)) {
+ 		bnxt_close_nic(bp, true, false);
+ 		bnxt_open_nic(bp, true, false);
+ 	}
++>>>>>>> ec86f14ea506 (bnxt_en: Add ULP calls to stop and restart IRQs.)
  	return 0;
  }
  
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.c
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.h b/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.h
index c9fa7eb56a08..df48ac71729f 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ulp.h
@@ -1,6 +1,6 @@
 /* Broadcom NetXtreme-C/E network driver.
  *
- * Copyright (c) 2016 Broadcom Limited
+ * Copyright (c) 2016-2018 Broadcom Limited
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,6 +20,12 @@
 struct hwrm_async_event_cmpl;
 struct bnxt;
 
+struct bnxt_msix_entry {
+	u32	vector;
+	u32	ring_idx;
+	u32	db_offset;
+};
+
 struct bnxt_ulp_ops {
 	/* async_notifier() cannot sleep (in BH context) */
 	void (*ulp_async_notifier)(void *, struct hwrm_async_event_cmpl *);
@@ -27,12 +33,8 @@ struct bnxt_ulp_ops {
 	void (*ulp_start)(void *);
 	void (*ulp_sriov_config)(void *, int);
 	void (*ulp_shutdown)(void *);
-};
-
-struct bnxt_msix_entry {
-	u32	vector;
-	u32	ring_idx;
-	u32	db_offset;
+	void (*ulp_irq_stop)(void *);
+	void (*ulp_irq_restart)(void *, struct bnxt_msix_entry *);
 };
 
 struct bnxt_fw_msg {
@@ -61,6 +63,7 @@ struct bnxt_en_dev {
 	#define BNXT_EN_FLAG_ROCEV2_CAP		0x2
 	#define BNXT_EN_FLAG_ROCE_CAP		(BNXT_EN_FLAG_ROCEV1_CAP | \
 						 BNXT_EN_FLAG_ROCEV2_CAP)
+	#define BNXT_EN_FLAG_MSIX_REQUESTED	0x4
 	const struct bnxt_en_ops	*en_ops;
 	struct bnxt_ulp			ulp_tbl[BNXT_MAX_ULP];
 };
@@ -92,6 +95,8 @@ void bnxt_ulp_stop(struct bnxt *bp);
 void bnxt_ulp_start(struct bnxt *bp);
 void bnxt_ulp_sriov_cfg(struct bnxt *bp, int num_vfs);
 void bnxt_ulp_shutdown(struct bnxt *bp);
+void bnxt_ulp_irq_stop(struct bnxt *bp);
+void bnxt_ulp_irq_restart(struct bnxt *bp, int err);
 void bnxt_ulp_async_events(struct bnxt *bp, struct hwrm_async_event_cmpl *cmpl);
 struct bnxt_en_dev *bnxt_ulp_probe(struct net_device *dev);
 
