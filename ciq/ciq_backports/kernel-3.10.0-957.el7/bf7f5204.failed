iio: hid-sensors: typo leads to potential forever loop

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iio] hid-sensors: typo leads to potential forever loop (Tony Camuso) [1559170]
Rebuild_FUZZ: 95.15%
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit bf7f5204abdba94032ff7cae1c9c8c9e7671d246
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/bf7f5204.failed

The "i < " was missing in this condition.

Fixes: 5d02edfc3957 ('iio: hid-sensors: Convert units and exponent')
	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit bf7f5204abdba94032ff7cae1c9c8c9e7671d246)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iio/common/hid-sensors/hid-sensor-attributes.c
diff --cc drivers/iio/common/hid-sensors/hid-sensor-attributes.c
index b707afcb94b0,3052eb150099..000000000000
--- a/drivers/iio/common/hid-sensors/hid-sensor-attributes.c
+++ b/drivers/iio/common/hid-sensors/hid-sensor-attributes.c
@@@ -246,65 -263,85 +246,84 @@@ int hid_sensor_write_raw_hyst_value(str
  }
  EXPORT_SYMBOL(hid_sensor_write_raw_hyst_value);
  
 -/*
 - * This fuction applies the unit exponent to the scale.
 - * For example:
 - * 9.806650 ->exp:2-> val0[980]val1[665000]
 - * 9.000806 ->exp:2-> val0[900]val1[80600]
 - * 0.174535 ->exp:2-> val0[17]val1[453500]
 - * 1.001745 ->exp:0-> val0[1]val1[1745]
 - * 1.001745 ->exp:2-> val0[100]val1[174500]
 - * 1.001745 ->exp:4-> val0[10017]val1[450000]
 - * 9.806650 ->exp:-2-> val0[0]val1[98066]
 - */
 -static void adjust_exponent_micro(int *val0, int *val1, int scale0,
 -				  int scale1, int exp)
 +int hid_sensor_get_reporting_interval(struct hid_sensor_hub_device *hsdev,
 +					u32 usage_id,
 +					struct hid_sensor_common *st)
  {
 -	int i;
 -	int x;
 -	int res;
 -	int rem;
 +	sensor_hub_input_get_attribute_info(hsdev,
 +					HID_FEATURE_REPORT, usage_id,
 +					HID_USAGE_SENSOR_PROP_REPORT_INTERVAL,
 +					&st->poll);
 +	/* Default unit of measure is milliseconds */
 +	if (st->poll.units == 0)
 +		st->poll.units = HID_USAGE_SENSOR_UNITS_MILLISECOND;
 +
 +	st->poll_interval = -1;
 +
 +	return 0;
  
 -	if (exp > 0) {
 -		*val0 = scale0 * pow_10(exp);
 -		res = 0;
 -		if (exp > 6) {
 -			*val1 = 0;
 -			return;
 -		}
 -		for (i = 0; i < exp; ++i) {
 -			x = scale1 / pow_10(5 - i);
 -			res += (pow_10(exp - 1 - i) * x);
 -			scale1 = scale1 % pow_10(5 - i);
 -		}
 -		*val0 += res;
 -			*val1 = scale1 * pow_10(exp);
 -	} else if (exp < 0) {
 -		exp = abs(exp);
 -		if (exp > 6) {
 -			*val0 = *val1 = 0;
 -			return;
 -		}
 -		*val0 = scale0 / pow_10(exp);
 -		rem = scale0 % pow_10(exp);
 -		res = 0;
 -		for (i = 0; i < (6 - exp); ++i) {
 -			x = scale1 / pow_10(5 - i);
 -			res += (pow_10(5 - exp - i) * x);
 -			scale1 = scale1 % pow_10(5 - i);
 -		}
 -		*val1 = rem * pow_10(6 - exp) + res;
 -	} else {
 -		*val0 = scale0;
 -		*val1 = scale1;
 -	}
  }
  
 -int hid_sensor_format_scale(u32 usage_id,
 -			struct hid_sensor_hub_attribute_info *attr_info,
 -			int *val0, int *val1)
 +static void hid_sensor_get_report_latency_info(struct hid_sensor_hub_device *hsdev,
 +					       u32 usage_id,
 +					       struct hid_sensor_common *st)
  {
 -	int i;
 -	int exp;
 -
 +	sensor_hub_input_get_attribute_info(hsdev, HID_FEATURE_REPORT,
 +					    usage_id,
 +					    HID_USAGE_SENSOR_PROP_REPORT_LATENCY,
 +					    &st->report_latency);
 +
++<<<<<<< HEAD
 +	hid_dbg(hsdev->hdev, "Report latency attributes: %x:%x\n",
 +		st->report_latency.index, st->report_latency.report_id);
++=======
+ 	*val0 = 1;
+ 	*val1 = 0;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(unit_conversion); ++i) {
+ 		if (unit_conversion[i].usage_id == usage_id &&
+ 			unit_conversion[i].unit == attr_info->units) {
+ 			exp  = hid_sensor_convert_exponent(
+ 						attr_info->unit_expo);
+ 			adjust_exponent_micro(val0, val1,
+ 					unit_conversion[i].scale_val0,
+ 					unit_conversion[i].scale_val1, exp);
+ 			break;
+ 		}
+ 	}
+ 
+ 	return IIO_VAL_INT_PLUS_MICRO;
++>>>>>>> bf7f5204abdb (iio: hid-sensors: typo leads to potential forever loop)
  }
 -EXPORT_SYMBOL(hid_sensor_format_scale);
 +
 +int hid_sensor_get_report_latency(struct hid_sensor_common *st)
 +{
 +	int ret;
 +	int value;
 +
 +	ret = sensor_hub_get_feature(st->hsdev, st->report_latency.report_id,
 +				     st->report_latency.index, sizeof(value),
 +				     &value);
 +	if (ret < 0)
 +		return ret;
 +
 +	return value;
 +}
 +EXPORT_SYMBOL(hid_sensor_get_report_latency);
 +
 +int hid_sensor_set_report_latency(struct hid_sensor_common *st, int latency_ms)
 +{
 +	return sensor_hub_set_feature(st->hsdev, st->report_latency.report_id,
 +				      st->report_latency.index,
 +				      sizeof(latency_ms), &latency_ms);
 +}
 +EXPORT_SYMBOL(hid_sensor_set_report_latency);
 +
 +bool hid_sensor_batch_mode_supported(struct hid_sensor_common *st)
 +{
 +	return st->report_latency.index > 0 && st->report_latency.report_id > 0;
 +}
 +EXPORT_SYMBOL(hid_sensor_batch_mode_supported);
  
  int hid_sensor_parse_common_attributes(struct hid_sensor_hub_device *hsdev,
  					u32 usage_id,
* Unmerged path drivers/iio/common/hid-sensors/hid-sensor-attributes.c
