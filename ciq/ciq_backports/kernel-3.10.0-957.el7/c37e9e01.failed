ext4: add more inode number paranoia checks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit c37e9e013469521d9adb932d17a1795c139b36db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c37e9e01.failed

If there is a directory entry pointing to a system inode (such as a
journal inode), complain and declare the file system to be corrupted.

Also, if the superblock's first inode number field is too small,
refuse to mount the file system.

This addresses CVE-2018-10882.

https://bugzilla.kernel.org/show_bug.cgi?id=200069

	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: stable@kernel.org
(cherry picked from commit c37e9e013469521d9adb932d17a1795c139b36db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/inode.c
diff --cc fs/ext4/inode.c
index 3f826800ae2f,7d6c10017bdf..000000000000
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@@ -4057,8 -4506,9 +4057,14 @@@ static int __ext4_get_inode_loc(struct 
  	int			inodes_per_block, inode_offset;
  
  	iloc->bh = NULL;
++<<<<<<< HEAD
 +	if (!ext4_valid_inum(sb, inode->i_ino))
 +		return -EIO;
++=======
+ 	if (inode->i_ino < EXT4_ROOT_INO ||
+ 	    inode->i_ino > le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count))
+ 		return -EFSCORRUPTED;
++>>>>>>> c37e9e013469 (ext4: add more inode number paranoia checks)
  
  	iloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);
  	gdp = ext4_get_group_desc(sb, iloc->block_group, NULL);
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 0e7a16f12d02..f2b158643bb7 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1419,11 +1419,6 @@ static inline struct timespec ext4_current_time(struct inode *inode)
 static inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)
 {
 	return ino == EXT4_ROOT_INO ||
-		ino == EXT4_USR_QUOTA_INO ||
-		ino == EXT4_GRP_QUOTA_INO ||
-		ino == EXT4_BOOT_LOADER_INO ||
-		ino == EXT4_JOURNAL_INO ||
-		ino == EXT4_RESIZE_INO ||
 		(ino >= EXT4_FIRST_INO(sb) &&
 		 ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));
 }
* Unmerged path fs/ext4/inode.c
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 525b8da0cba2..696532b30a88 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -3857,6 +3857,11 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	} else {
 		sbi->s_inode_size = le16_to_cpu(es->s_inode_size);
 		sbi->s_first_ino = le32_to_cpu(es->s_first_ino);
+		if (sbi->s_first_ino < EXT4_GOOD_OLD_FIRST_INO) {
+			ext4_msg(sb, KERN_ERR, "invalid first ino: %u",
+				 sbi->s_first_ino);
+			goto failed_mount;
+		}
 		if ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||
 		    (!is_power_of_2(sbi->s_inode_size)) ||
 		    (sbi->s_inode_size > blocksize)) {
