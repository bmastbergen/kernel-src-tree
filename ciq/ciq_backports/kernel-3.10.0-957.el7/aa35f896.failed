x86/umip: Enable User-Mode Instruction Prevention at runtime

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] umip: Enable User-Mode Instruction Prevention at runtime (Gopal Tiwari) [1456572]
Rebuild_FUZZ: 96.55%
commit-author Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
commit aa35f896979d9610bb11df485cf7bb6ca241febb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/aa35f896.failed

User-Mode Instruction Prevention (UMIP) is enabled by setting/clearing a
bit in %cr4.

It makes sense to enable UMIP at some point while booting, before user
spaces come up. Like SMAP and SMEP, is not critical to have it enabled
very early during boot. This is because UMIP is relevant only when there is
a user space to be protected from. Given these similarities, UMIP can be
enabled along with SMAP and SMEP.

At the moment, UMIP is disabled by default at build time. It can be enabled
at build time by selecting CONFIG_X86_INTEL_UMIP. If enabled at build time,
it can be disabled at run time by adding clearcpuid=514 to the kernel
parameters.

	Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Borislav Petkov <bp@suse.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Chen Yucong <slaoub@gmail.com>
	Cc: Chris Metcalf <cmetcalf@mellanox.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: Fenghua Yu <fenghua.yu@intel.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Huang Rui <ray.huang@amd.com>
	Cc: Jiri Slaby <jslaby@suse.cz>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Masami Hiramatsu <mhiramat@kernel.org>
	Cc: Michael S. Tsirkin <mst@redhat.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Ravi V. Shankar <ravi.v.shankar@intel.com>
	Cc: Shuah Khan <shuah@kernel.org>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: ricardo.neri@intel.com
Link: http://lkml.kernel.org/r/1509935277-22138-10-git-send-email-ricardo.neri-calderon@linux.intel.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit aa35f896979d9610bb11df485cf7bb6ca241febb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/Kconfig
diff --cc arch/x86/Kconfig
index 48ae09959d87,e19fa9f7079a..000000000000
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@@ -1725,6 -1802,60 +1725,63 @@@ config X86_SMA
  
  	  If unsure, say Y.
  
++<<<<<<< HEAD
++=======
+ config X86_INTEL_UMIP
+ 	def_bool n
+ 	depends on CPU_SUP_INTEL
+ 	prompt "Intel User Mode Instruction Prevention" if EXPERT
+ 	---help---
+ 	  The User Mode Instruction Prevention (UMIP) is a security
+ 	  feature in newer Intel processors. If enabled, a general
+ 	  protection fault is issued if the instructions SGDT, SLDT,
+ 	  SIDT, SMSW and STR are executed in user mode.
+ 
+ config X86_INTEL_MPX
+ 	prompt "Intel MPX (Memory Protection Extensions)"
+ 	def_bool n
+ 	# Note: only available in 64-bit mode due to VMA flags shortage
+ 	depends on CPU_SUP_INTEL && X86_64
+ 	select ARCH_USES_HIGH_VMA_FLAGS
+ 	---help---
+ 	  MPX provides hardware features that can be used in
+ 	  conjunction with compiler-instrumented code to check
+ 	  memory references.  It is designed to detect buffer
+ 	  overflow or underflow bugs.
+ 
+ 	  This option enables running applications which are
+ 	  instrumented or otherwise use MPX.  It does not use MPX
+ 	  itself inside the kernel or to protect the kernel
+ 	  against bad memory references.
+ 
+ 	  Enabling this option will make the kernel larger:
+ 	  ~8k of kernel text and 36 bytes of data on a 64-bit
+ 	  defconfig.  It adds a long to the 'mm_struct' which
+ 	  will increase the kernel memory overhead of each
+ 	  process and adds some branches to paths used during
+ 	  exec() and munmap().
+ 
+ 	  For details, see Documentation/x86/intel_mpx.txt
+ 
+ 	  If unsure, say N.
+ 
+ config X86_INTEL_MEMORY_PROTECTION_KEYS
+ 	prompt "Intel Memory Protection Keys"
+ 	def_bool y
+ 	# Note: only available in 64-bit mode
+ 	depends on CPU_SUP_INTEL && X86_64
+ 	select ARCH_USES_HIGH_VMA_FLAGS
+ 	select ARCH_HAS_PKEYS
+ 	---help---
+ 	  Memory Protection Keys provides a mechanism for enforcing
+ 	  page-based protections, but without requiring modification of the
+ 	  page tables when an application changes protection domains.
+ 
+ 	  For details, see Documentation/x86/protection-keys.txt
+ 
+ 	  If unsure, say y.
+ 
++>>>>>>> aa35f896979d (x86/umip: Enable User-Mode Instruction Prevention at runtime)
  config EFI
  	bool "EFI runtime service support"
  	depends on ACPI
* Unmerged path arch/x86/Kconfig
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index 49cb90f121df..99cf9caa330d 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -350,6 +350,28 @@ static __always_inline void setup_smap(struct cpuinfo_x86 *c)
 		set_in_cr4(X86_CR4_SMAP);
 }
 
+static __always_inline void setup_umip(struct cpuinfo_x86 *c)
+{
+	/* Check the boot processor, plus build option for UMIP. */
+	if (!cpu_feature_enabled(X86_FEATURE_UMIP))
+		goto out;
+
+	/* Check the current processor's cpuid bits. */
+	if (!cpu_has(c, X86_FEATURE_UMIP))
+		goto out;
+
+	cr4_set_bits(X86_CR4_UMIP);
+
+	return;
+
+out:
+	/*
+	 * Make sure UMIP is disabled in case it was enabled in a
+	 * previous boot (e.g., via kexec).
+	 */
+	cr4_clear_bits(X86_CR4_UMIP);
+}
+
 /*
  * Protection Keys are not available in 32-bit mode.
  */
@@ -1084,9 +1106,10 @@ static void identify_cpu(struct cpuinfo_x86 *c)
 	/* Disable the PN if appropriate */
 	squash_the_stupid_serial_number(c);
 
-	/* Set up SMEP/SMAP */
+	/* Set up SMEP/SMAP/UMIP */
 	setup_smep(c);
 	setup_smap(c);
+	setup_umip(c);
 
 	/*
 	 * The vendor-specific functions might have changed features.
