dax: pass detailed error code from dax_iomap_fault()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jan Kara <jack@suse.cz>
commit c0b24625979284dd212423320fe1c84fe244ed7f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c0b24625.failed

Ext4 needs to pass through error from its iomap handler to the page
fault handler so that it can properly detect ENOSPC and force
transaction commit and retry the fault (and block allocation). Add
argument to dax_iomap_fault() for passing such error.

	Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit c0b24625979284dd212423320fe1c84fe244ed7f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
#	fs/ext2/file.c
#	fs/ext4/file.c
#	fs/xfs/xfs_file.c
#	include/linux/dax.h
diff --cc fs/dax.c
index 1af3371a28ee,f3afa1d6156c..000000000000
--- a/fs/dax.c
+++ b/fs/dax.c
@@@ -1181,14 -1084,25 +1181,26 @@@ static int dax_fault_return(int error
  	return VM_FAULT_SIGBUS;
  }
  
 -/*
 - * MAP_SYNC on a dax mapping guarantees dirty metadata is
 - * flushed on write-faults (non-cow), but not read-faults.
 - */
 -static bool dax_fault_is_synchronous(unsigned long flags,
 -		struct vm_area_struct *vma, struct iomap *iomap)
 +static int dax_iomap_pte_fault(struct vm_fault *vmf,
 +			const struct iomap_ops *ops)
  {
++<<<<<<< HEAD
 +	struct address_space *mapping = vmf->vma->vm_file->f_mapping;
++=======
+ 	return (flags & IOMAP_WRITE) && (vma->vm_flags & VM_SYNC)
+ 		&& (iomap->flags & IOMAP_F_DIRTY);
+ }
+ 
+ static int dax_iomap_pte_fault(struct vm_fault *vmf, pfn_t *pfnp,
+ 			       int *iomap_errp, const struct iomap_ops *ops)
+ {
+ 	struct vm_area_struct *vma = vmf->vma;
+ 	struct address_space *mapping = vma->vm_file->f_mapping;
++>>>>>>> c0b246259792 (dax: pass detailed error code from dax_iomap_fault())
  	struct inode *inode = mapping->host;
 -	unsigned long vaddr = vmf->address;
 +	unsigned long vaddr = (unsigned long)vmf->virtual_address;
  	loff_t pos = (loff_t)vmf->pgoff << PAGE_SHIFT;
 +	sector_t sector;
  	struct iomap iomap = { 0 };
  	unsigned flags = IOMAP_FAULT;
  	int error, major = 0;
@@@ -1555,6 -1489,8 +1569,11 @@@ static int dax_iomap_pmd_fault(struct v
   * dax_iomap_fault - handle a page fault on a DAX file
   * @vmf: The description of the fault
   * @pe_size: Size of the page to fault in
++<<<<<<< HEAD
++=======
+  * @pfnp: PFN to insert for synchronous faults if fsync is required
+  * @iomap_errp: Storage for detailed error code in case of error
++>>>>>>> c0b246259792 (dax: pass detailed error code from dax_iomap_fault())
   * @ops: Iomap ops passed from the file system
   *
   * When a page fault occurs, filesystems may call this helper in
@@@ -1563,13 -1499,13 +1582,21 @@@
   * successfully.
   */
  int dax_iomap_fault(struct vm_fault *vmf, enum page_entry_size pe_size,
++<<<<<<< HEAD
 +		const struct iomap_ops *ops)
 +{
 +	switch (pe_size) {
 +	case PE_SIZE_PTE:
 +		return dax_iomap_pte_fault(vmf, ops);
++=======
+ 		    pfn_t *pfnp, int *iomap_errp, const struct iomap_ops *ops)
+ {
+ 	switch (pe_size) {
+ 	case PE_SIZE_PTE:
+ 		return dax_iomap_pte_fault(vmf, pfnp, iomap_errp, ops);
++>>>>>>> c0b246259792 (dax: pass detailed error code from dax_iomap_fault())
  	case PE_SIZE_PMD:
 -		return dax_iomap_pmd_fault(vmf, pfnp, ops);
 +		return dax_iomap_pmd_fault(vmf, ops);
  	default:
  		return VM_FAULT_FALLBACK;
  	}
diff --cc fs/ext2/file.c
index 4d0447eb265d,09640220fda8..000000000000
--- a/fs/ext2/file.c
+++ b/fs/ext2/file.c
@@@ -51,7 -100,7 +51,11 @@@ static int ext2_dax_fault(struct vm_are
  	}
  	down_read(&ei->dax_sem);
  
++<<<<<<< HEAD
 +	ret = dax_fault(vma, vmf, ext2_get_block);
++=======
+ 	ret = dax_iomap_fault(vmf, PE_SIZE_PTE, NULL, NULL, &ext2_iomap_ops);
++>>>>>>> c0b246259792 (dax: pass detailed error code from dax_iomap_fault())
  
  	up_read(&ei->dax_sem);
  	if (vmf->flags & FAULT_FLAG_WRITE)
diff --cc fs/ext4/file.c
index feb7f54458b2,1c7cd882d998..000000000000
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@@ -300,13 -309,17 +300,17 @@@ static int ext4_dax_huge_fault(struct v
  	} else {
  		down_read(&EXT4_I(inode)->i_mmap_sem);
  	}
++<<<<<<< HEAD
 +	if (!IS_ERR(handle))
 +		result = dax_iomap_fault(vmf, pe_size, &ext4_iomap_ops);
 +	else
 +		result = VM_FAULT_SIGBUS;
++=======
+ 	result = dax_iomap_fault(vmf, pe_size, &pfn, NULL, &ext4_iomap_ops);
++>>>>>>> c0b246259792 (dax: pass detailed error code from dax_iomap_fault())
  	if (write) {
 -		ext4_journal_stop(handle);
 -		/* Handling synchronous page fault? */
 -		if (result & VM_FAULT_NEEDDSYNC)
 -			result = dax_finish_sync_fault(vmf, pe_size, pfn);
 +		if (!IS_ERR(handle))
 +			ext4_journal_stop(handle);
  		up_read(&EXT4_I(inode)->i_mmap_sem);
  		sb_end_pagefault(sb);
  	} else {
diff --cc fs/xfs/xfs_file.c
index cea567087acc,9ea08326f876..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -1198,13 -1045,53 +1198,28 @@@ xfs_filemap_huge_fault
  	}
  
  	xfs_ilock(XFS_I(inode), XFS_MMAPLOCK_SHARED);
++<<<<<<< HEAD
 +	ret = dax_iomap_fault(vmf, pe_size, &xfs_iomap_ops);
++=======
+ 	if (IS_DAX(inode)) {
+ 		pfn_t pfn;
+ 
+ 		ret = dax_iomap_fault(vmf, pe_size, &pfn, NULL, &xfs_iomap_ops);
+ 		if (ret & VM_FAULT_NEEDDSYNC)
+ 			ret = dax_finish_sync_fault(vmf, pe_size, pfn);
+ 	} else {
+ 		if (write_fault)
+ 			ret = iomap_page_mkwrite(vmf, &xfs_iomap_ops);
+ 		else
+ 			ret = filemap_fault(vmf);
+ 	}
++>>>>>>> c0b246259792 (dax: pass detailed error code from dax_iomap_fault())
  	xfs_iunlock(XFS_I(inode), XFS_MMAPLOCK_SHARED);
  
 -	if (write_fault)
 +	if (vmf->flags & FAULT_FLAG_WRITE)
  		sb_end_pagefault(inode->i_sb);
 -	return ret;
 -}
 -
 -static int
 -xfs_filemap_fault(
 -	struct vm_fault		*vmf)
 -{
 -	/* DAX can shortcut the normal fault path on write faults! */
 -	return __xfs_filemap_fault(vmf, PE_SIZE_PTE,
 -			IS_DAX(file_inode(vmf->vma->vm_file)) &&
 -			(vmf->flags & FAULT_FLAG_WRITE));
 -}
 -
 -static int
 -xfs_filemap_huge_fault(
 -	struct vm_fault		*vmf,
 -	enum page_entry_size	pe_size)
 -{
 -	if (!IS_DAX(file_inode(vmf->vma->vm_file)))
 -		return VM_FAULT_FALLBACK;
  
 -	/* DAX can shortcut the normal fault path on write faults! */
 -	return __xfs_filemap_fault(vmf, pe_size,
 -			(vmf->flags & FAULT_FLAG_WRITE));
 -}
 -
 -static int
 -xfs_filemap_page_mkwrite(
 -	struct vm_fault		*vmf)
 -{
 -	return __xfs_filemap_fault(vmf, PE_SIZE_PTE, true);
 +	return ret;
  }
  
  /*
diff --cc include/linux/dax.h
index b7b81d6cc271,0185ecdae135..000000000000
--- a/include/linux/dax.h
+++ b/include/linux/dax.h
@@@ -85,13 -87,18 +85,19 @@@ void kill_dax(struct dax_device *dax_de
  void *dax_get_private(struct dax_device *dax_dev);
  long dax_direct_access(struct dax_device *dax_dev, pgoff_t pgoff, long nr_pages,
  		void **kaddr, pfn_t *pfn);
 -size_t dax_copy_from_iter(struct dax_device *dax_dev, pgoff_t pgoff, void *addr,
 -		size_t bytes, struct iov_iter *i);
 -void dax_flush(struct dax_device *dax_dev, void *addr, size_t size);
 -void dax_write_cache(struct dax_device *dax_dev, bool wc);
 -bool dax_write_cache_enabled(struct dax_device *dax_dev);
  
 -ssize_t dax_iomap_rw(struct kiocb *iocb, struct iov_iter *iter,
 -		const struct iomap_ops *ops);
 +ssize_t dax_iomap_rw(int rw, struct kiocb *iocb, const struct iovec *iov,
 +		unsigned long nr_segs, loff_t pos,
 +		size_t count, const struct iomap_ops *ops);
  int dax_iomap_fault(struct vm_fault *vmf, enum page_entry_size pe_size,
++<<<<<<< HEAD
 +		const struct iomap_ops *ops);
 +int dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t);
++=======
+ 		    pfn_t *pfnp, int *errp, const struct iomap_ops *ops);
+ int dax_finish_sync_fault(struct vm_fault *vmf, enum page_entry_size pe_size,
+ 			  pfn_t pfn);
++>>>>>>> c0b246259792 (dax: pass detailed error code from dax_iomap_fault())
  int dax_delete_mapping_entry(struct address_space *mapping, pgoff_t index);
  int dax_invalidate_mapping_entry_sync(struct address_space *mapping,
  				      pgoff_t index);
* Unmerged path fs/dax.c
* Unmerged path fs/ext2/file.c
* Unmerged path fs/ext4/file.c
* Unmerged path fs/xfs/xfs_file.c
* Unmerged path include/linux/dax.h
