sctp: add a ceiling to optlen in some sockopts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
commit 5960cefab9df76600a1a7d4ff592c59e14616e88
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5960cefa.failed

Hangbin Liu reported that some sockopt calls could cause the kernel to log
a warning on memory allocation failure if the user supplied a large optlen
value. That is because some of them called memdup_user() without a ceiling
on optlen, allowing it to try to allocate really large buffers.

This patch adds a ceiling by limiting optlen to the maximum allowed that
would still make sense for these sockopt.

	Reported-by: Hangbin Liu <haliu@redhat.com>
	Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5960cefab9df76600a1a7d4ff592c59e14616e88)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/socket.c
diff --cc net/sctp/socket.c
index cc6900575f60,022b94f11fd8..000000000000
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@@ -3815,6 -3821,218 +3822,221 @@@ out
  	return retval;
  }
  
++<<<<<<< HEAD
++=======
+ static int sctp_setsockopt_reconfig_supported(struct sock *sk,
+ 					      char __user *optval,
+ 					      unsigned int optlen)
+ {
+ 	struct sctp_assoc_value params;
+ 	struct sctp_association *asoc;
+ 	int retval = -EINVAL;
+ 
+ 	if (optlen != sizeof(params))
+ 		goto out;
+ 
+ 	if (copy_from_user(&params, optval, optlen)) {
+ 		retval = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	asoc = sctp_id2assoc(sk, params.assoc_id);
+ 	if (asoc) {
+ 		asoc->reconf_enable = !!params.assoc_value;
+ 	} else if (!params.assoc_id) {
+ 		struct sctp_sock *sp = sctp_sk(sk);
+ 
+ 		sp->ep->reconf_enable = !!params.assoc_value;
+ 	} else {
+ 		goto out;
+ 	}
+ 
+ 	retval = 0;
+ 
+ out:
+ 	return retval;
+ }
+ 
+ static int sctp_setsockopt_enable_strreset(struct sock *sk,
+ 					   char __user *optval,
+ 					   unsigned int optlen)
+ {
+ 	struct sctp_assoc_value params;
+ 	struct sctp_association *asoc;
+ 	int retval = -EINVAL;
+ 
+ 	if (optlen != sizeof(params))
+ 		goto out;
+ 
+ 	if (copy_from_user(&params, optval, optlen)) {
+ 		retval = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	if (params.assoc_value & (~SCTP_ENABLE_STRRESET_MASK))
+ 		goto out;
+ 
+ 	asoc = sctp_id2assoc(sk, params.assoc_id);
+ 	if (asoc) {
+ 		asoc->strreset_enable = params.assoc_value;
+ 	} else if (!params.assoc_id) {
+ 		struct sctp_sock *sp = sctp_sk(sk);
+ 
+ 		sp->ep->strreset_enable = params.assoc_value;
+ 	} else {
+ 		goto out;
+ 	}
+ 
+ 	retval = 0;
+ 
+ out:
+ 	return retval;
+ }
+ 
+ static int sctp_setsockopt_reset_streams(struct sock *sk,
+ 					 char __user *optval,
+ 					 unsigned int optlen)
+ {
+ 	struct sctp_reset_streams *params;
+ 	struct sctp_association *asoc;
+ 	int retval = -EINVAL;
+ 
+ 	if (optlen < sizeof(*params))
+ 		return -EINVAL;
+ 	/* srs_number_streams is u16, so optlen can't be bigger than this. */
+ 	optlen = min_t(unsigned int, optlen, USHRT_MAX +
+ 					     sizeof(__u16) * sizeof(*params));
+ 
+ 	params = memdup_user(optval, optlen);
+ 	if (IS_ERR(params))
+ 		return PTR_ERR(params);
+ 
+ 	if (params->srs_number_streams * sizeof(__u16) >
+ 	    optlen - sizeof(*params))
+ 		goto out;
+ 
+ 	asoc = sctp_id2assoc(sk, params->srs_assoc_id);
+ 	if (!asoc)
+ 		goto out;
+ 
+ 	retval = sctp_send_reset_streams(asoc, params);
+ 
+ out:
+ 	kfree(params);
+ 	return retval;
+ }
+ 
+ static int sctp_setsockopt_reset_assoc(struct sock *sk,
+ 				       char __user *optval,
+ 				       unsigned int optlen)
+ {
+ 	struct sctp_association *asoc;
+ 	sctp_assoc_t associd;
+ 	int retval = -EINVAL;
+ 
+ 	if (optlen != sizeof(associd))
+ 		goto out;
+ 
+ 	if (copy_from_user(&associd, optval, optlen)) {
+ 		retval = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	asoc = sctp_id2assoc(sk, associd);
+ 	if (!asoc)
+ 		goto out;
+ 
+ 	retval = sctp_send_reset_assoc(asoc);
+ 
+ out:
+ 	return retval;
+ }
+ 
+ static int sctp_setsockopt_add_streams(struct sock *sk,
+ 				       char __user *optval,
+ 				       unsigned int optlen)
+ {
+ 	struct sctp_association *asoc;
+ 	struct sctp_add_streams params;
+ 	int retval = -EINVAL;
+ 
+ 	if (optlen != sizeof(params))
+ 		goto out;
+ 
+ 	if (copy_from_user(&params, optval, optlen)) {
+ 		retval = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	asoc = sctp_id2assoc(sk, params.sas_assoc_id);
+ 	if (!asoc)
+ 		goto out;
+ 
+ 	retval = sctp_send_add_streams(asoc, &params);
+ 
+ out:
+ 	return retval;
+ }
+ 
+ static int sctp_setsockopt_scheduler(struct sock *sk,
+ 				     char __user *optval,
+ 				     unsigned int optlen)
+ {
+ 	struct sctp_association *asoc;
+ 	struct sctp_assoc_value params;
+ 	int retval = -EINVAL;
+ 
+ 	if (optlen < sizeof(params))
+ 		goto out;
+ 
+ 	optlen = sizeof(params);
+ 	if (copy_from_user(&params, optval, optlen)) {
+ 		retval = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	if (params.assoc_value > SCTP_SS_MAX)
+ 		goto out;
+ 
+ 	asoc = sctp_id2assoc(sk, params.assoc_id);
+ 	if (!asoc)
+ 		goto out;
+ 
+ 	retval = sctp_sched_set_sched(asoc, params.assoc_value);
+ 
+ out:
+ 	return retval;
+ }
+ 
+ static int sctp_setsockopt_scheduler_value(struct sock *sk,
+ 					   char __user *optval,
+ 					   unsigned int optlen)
+ {
+ 	struct sctp_association *asoc;
+ 	struct sctp_stream_value params;
+ 	int retval = -EINVAL;
+ 
+ 	if (optlen < sizeof(params))
+ 		goto out;
+ 
+ 	optlen = sizeof(params);
+ 	if (copy_from_user(&params, optval, optlen)) {
+ 		retval = -EFAULT;
+ 		goto out;
+ 	}
+ 
+ 	asoc = sctp_id2assoc(sk, params.assoc_id);
+ 	if (!asoc)
+ 		goto out;
+ 
+ 	retval = sctp_sched_set_value(asoc, params.stream_id,
+ 				      params.stream_value, GFP_KERNEL);
+ 
+ out:
+ 	return retval;
+ }
+ 
++>>>>>>> 5960cefab9df (sctp: add a ceiling to optlen in some sockopts)
  /* API 6.2 setsockopt(), getsockopt()
   *
   * Applications use setsockopt() and getsockopt() to set or retrieve
* Unmerged path net/sctp/socket.c
