Input: libps2 - relax command byte ACK handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [input] libps2 - relax command byte ACK handling (Benjamin Tissoires) [1554926]
Rebuild_FUZZ: 91.95%
commit-author Dmitry Torokhov <dmitry.torokhov@gmail.com>
commit 29acc42e8e10a4721757af9ed8aec569d30ce39b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/29acc42e.failed

When we probe PS/2 devices we first issue "Get ID" command and only if we
receive what we consider a valid keyboard or mouse ID we disable the device
and continue with protocol detection. That means that the device may be
transmitting motion or keystroke data, while we expect ACK response.

Instead of signaling failure if we see anything but ACK/NAK let's ignore
"garbage" response until we see ACK for the command byte (first byte). The
checks for subsequent ACKs of command parameters will continue be strict.

	Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
(cherry picked from commit 29acc42e8e10a4721757af9ed8aec569d30ce39b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/input/serio/libps2.c
diff --cc drivers/input/serio/libps2.c
index c43291c1cca4,e6a07e68d1ff..000000000000
--- a/drivers/input/serio/libps2.c
+++ b/drivers/input/serio/libps2.c
@@@ -206,25 -255,31 +206,44 @@@ int __ps2_command(struct ps2dev *ps2dev
  	if (receive && param)
  		for (i = 0; i < receive; i++)
  			ps2dev->cmdbuf[(receive - 1) - i] = param[i];
 +	serio_continue_rx(ps2dev->serio);
  
+ 	/* Signal that we are sending the command byte */
+ 	ps2dev->flags |= PS2_FLAG_ACK_CMD;
+ 
  	/*
  	 * Some devices (Synaptics) peform the reset before
  	 * ACKing the reset command, and so it can take a long
  	 * time before the ACK arrives.
  	 */
++<<<<<<< HEAD
 +	if (ps2_sendbyte(ps2dev, command & 0xff,
 +			 command == PS2_CMD_RESET_BAT ? 1000 : 200)) {
 +		serio_pause_rx(ps2dev->serio);
 +		goto out_reset_flags;
++=======
+ 	timeout = command == PS2_CMD_RESET_BAT ? 1000 : 200;
+ 
+ 	rc = ps2_do_sendbyte(ps2dev, command & 0xff, timeout, 2);
+ 	if (rc)
+ 		goto out_reset_flags;
+ 
+ 	/* Now we are sending command parameters, if any */
+ 	ps2dev->flags &= ~PS2_FLAG_ACK_CMD;
+ 
+ 	for (i = 0; i < send; i++) {
+ 		rc = ps2_do_sendbyte(ps2dev, param[i], 200, 2);
+ 		if (rc)
+ 			goto out_reset_flags;
++>>>>>>> 29acc42e8e10 (Input: libps2 - relax command byte ACK handling)
  	}
  
 -	serio_continue_rx(ps2dev->serio);
 +	for (i = 0; i < send; i++) {
 +		if (ps2_sendbyte(ps2dev, param[i], 200)) {
 +			serio_pause_rx(ps2dev->serio);
 +			goto out_reset_flags;
 +		}
 +	}
  
  	/*
  	 * The reset command takes a long time to execute.
* Unmerged path drivers/input/serio/libps2.c
diff --git a/include/linux/libps2.h b/include/linux/libps2.h
index 646b581fea56..12dd7347955c 100644
--- a/include/linux/libps2.h
+++ b/include/linux/libps2.h
@@ -29,6 +29,7 @@
 #define PS2_FLAG_CMD1		BIT(2)	/* Waiting for the first byte of command response */
 #define PS2_FLAG_WAITID		BIT(3)	/* Command executing is GET ID */
 #define PS2_FLAG_NAK		BIT(4)	/* Last transmission was NAKed */
+#define PS2_FLAG_ACK_CMD	BIT(5)	/* Waiting to ACK the command (first) byte */
 
 struct ps2dev {
 	struct serio *serio;
