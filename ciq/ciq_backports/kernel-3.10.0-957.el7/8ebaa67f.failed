scsi: aacraid: Use hotplug handling function in place of scsi_scan_host

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] aacraid: Use hotplug handling function in place of scsi_scan_host (Raghava Aditya Renukunta) [1519664]
Rebuild_FUZZ: 95.59%
commit-author Raghava Aditya Renukunta <RaghavaAditya.Renukunta@microsemi.com>
commit 8ebaa67fc23a09bcf2b285ae4130508256b31923
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8ebaa67f.failed

Driver uses scsi_scan_host to add new devices in the driver init path,
which adds all the fw exposed devices. The drivers resorts to queue
command checks to block out commands to _hidden_ devices.

Use the hotplug handler code to add new devices during driver init and
other areas, this is only for safw. For ARC scsi_scan_host will still
apply.

	Signed-off-by: Raghava Aditya Renukunta <RaghavaAditya.Renukunta@microsemi.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 8ebaa67fc23a09bcf2b285ae4130508256b31923)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/aacraid/aacraid.h
diff --cc drivers/scsi/aacraid/aacraid.h
index 1d7423b9d800,ba84d9985ce7..000000000000
--- a/drivers/scsi/aacraid/aacraid.h
+++ b/drivers/scsi/aacraid/aacraid.h
@@@ -2705,6 -2702,24 +2705,27 @@@ int aac_probe_container(struct aac_dev 
  int _aac_rx_init(struct aac_dev *dev);
  int aac_rx_select_comm(struct aac_dev *dev, int comm);
  int aac_rx_deliver_producer(struct fib * fib);
++<<<<<<< HEAD
++=======
+ 
+ static inline int aac_is_src(struct aac_dev *dev)
+ {
+ 	u16 device = dev->pdev->device;
+ 
+ 	if (device == PMC_DEVICE_S6 ||
+ 		device == PMC_DEVICE_S7 ||
+ 		device == PMC_DEVICE_S8)
+ 		return 1;
+ 	return 0;
+ }
+ 
+ static inline int aac_supports_2T(struct aac_dev *dev)
+ {
+ 	return (dev->adapter_info.options & AAC_OPT_NEW_COMM_64);
+ }
+ 
+ int aac_scan_host(struct aac_dev *dev, int rescan);
++>>>>>>> 8ebaa67fc23a (scsi: aacraid: Use hotplug handling function in place of scsi_scan_host)
  char * get_container_type(unsigned type);
  extern int numacb;
  extern char aac_driver_version[];
diff --git a/drivers/scsi/aacraid/aachba.c b/drivers/scsi/aacraid/aachba.c
index 55940121bab1..77552adf4b65 100644
--- a/drivers/scsi/aacraid/aachba.c
+++ b/drivers/scsi/aacraid/aachba.c
@@ -2150,10 +2150,6 @@ int aac_get_adapter_info(struct aac_dev* dev)
 		dev->maximum_num_channels = le32_to_cpu(bus_info->BusCount);
 	}
 
-	if (!dev->sync_mode && dev->sa_firmware &&
-		dev->supplement_adapter_info.virt_device_bus != 0xffff)
-		rcode = aac_setup_safw_adapter(dev, AAC_INIT);
-
 	if (!dev->in_reset) {
 		char buffer[16];
 		tmp = le32_to_cpu(dev->adapter_info.kernelrev);
* Unmerged path drivers/scsi/aacraid/aacraid.h
diff --git a/drivers/scsi/aacraid/commsup.c b/drivers/scsi/aacraid/commsup.c
index 4be1a279f46f..9fc0cb7c5191 100644
--- a/drivers/scsi/aacraid/commsup.c
+++ b/drivers/scsi/aacraid/commsup.c
@@ -1935,6 +1935,19 @@ out:
 	return rcode;
 }
 
+int aac_scan_host(struct aac_dev *dev, int rescan)
+{
+	int rcode = 0;
+
+	mutex_lock(&dev->scan_mutex);
+	if (dev->sa_firmware)
+		rcode = aac_update_safw_host_devices(dev, rescan);
+	else
+		scsi_scan_host(dev->scsi_host_ptr);
+	mutex_unlock(&dev->scan_mutex);
+	return rcode;
+}
+
 /**
  *	aac_handle_sa_aif	Handle a message from the firmware
  *	@dev: Which adapter this fib is from
@@ -1968,9 +1981,8 @@ static void aac_handle_sa_aif(struct aac_dev *dev, struct fib *fibptr)
 	case SA_AIF_LDEV_CHANGE:
 	case SA_AIF_BPCFG_CHANGE:
 
-		mutex_lock(&dev->scan_mutex);
-		aac_update_safw_host_devices(dev, AAC_RESCAN);
-		mutex_unlock(&dev->scan_mutex);
+		aac_scan_host(dev, AAC_RESCAN);
+
 		break;
 
 	case SA_AIF_BPSTAT_CHANGE:
diff --git a/drivers/scsi/aacraid/linit.c b/drivers/scsi/aacraid/linit.c
index 5870838688ad..7addf0fc848e 100644
--- a/drivers/scsi/aacraid/linit.c
+++ b/drivers/scsi/aacraid/linit.c
@@ -1898,7 +1898,8 @@ static int aac_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	error = scsi_add_host(shost, &pdev->dev);
 	if (error)
 		goto out_deinit;
-	scsi_scan_host(shost);
+
+	aac_scan_host(aac, AAC_INIT);
 
 	pci_enable_pcie_error_reporting(pdev);
 	pci_save_state(pdev);
@@ -2184,7 +2185,7 @@ static void aac_pci_resume(struct pci_dev *pdev)
 		if (sdev->sdev_state == SDEV_OFFLINE)
 			sdev->sdev_state = SDEV_RUNNING;
 	scsi_unblock_requests(aac->scsi_host_ptr);
-	scsi_scan_host(aac->scsi_host_ptr);
+	aac_scan_host(aac, AAC_RESCAN);
 	pci_save_state(pdev);
 
 	dev_err(&pdev->dev, "aacraid: PCI error - resume\n");
