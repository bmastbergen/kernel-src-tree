ceph: fix "range cyclic" mode writepages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Yan, Zheng <zyan@redhat.com>
commit 590e9d9861f5f21fbbb0266e40e6a17bc5084dd0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/590e9d98.failed

In range cyclic mode, writepages() should first write dirty pages
in range [writeback_index, (pgoff_t)-1], then write pages in range
[0, writeback_index -1]. Besides, if writepages() encounters a page
that beyond EOF, it should restart from the beginning.

	Signed-off-by: "Yan, Zheng" <zyan@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 590e9d9861f5f21fbbb0266e40e6a17bc5084dd0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/addr.c
diff --cc fs/ceph/addr.c
index 2c8328a70fdb,4a54f7369f51..000000000000
--- a/fs/ceph/addr.c
+++ b/fs/ceph/addr.c
@@@ -710,19 -781,15 +710,28 @@@ static int ceph_writepages_start(struc
  	struct ceph_inode_info *ci = ceph_inode(inode);
  	struct ceph_fs_client *fsc = ceph_inode_to_client(inode);
  	struct ceph_vino vino = ceph_vino(inode);
++<<<<<<< HEAD
 +	pgoff_t index, start, end;
 +	int range_whole = 0;
 +	int should_loop = 1;
 +	pgoff_t max_pages = 0, max_pages_ever = 0;
++=======
+ 	pgoff_t index, start_index, end;
++>>>>>>> 590e9d9861f5 (ceph: fix "range cyclic" mode writepages)
  	struct ceph_snap_context *snapc = NULL, *last_snapc = NULL, *pgsnapc;
  	struct pagevec pvec;
- 	int done = 0;
  	int rc = 0;
 -	unsigned int wsize = i_blocksize(inode);
 +	unsigned wsize = 1 << inode->i_blkbits;
  	struct ceph_osd_request *req = NULL;
++<<<<<<< HEAD
 +	loff_t snap_size, i_size;
 +	u64 truncate_size;
 +	u32 truncate_seq;
++=======
+ 	struct ceph_writeback_ctl ceph_wbc;
+ 	bool should_loop, range_whole = false;
+ 	bool stop, done = false;
++>>>>>>> 590e9d9861f5 (ceph: fix "range cyclic" mode writepages)
  
  	dout("writepages_start %p (mode=%s)\n", inode,
  	     wbc->sync_mode == WB_SYNC_NONE ? "NONE" :
@@@ -743,20 -809,22 +752,27 @@@
  
  	pagevec_init(&pvec, 0);
  
+ 	start_index = wbc->range_cyclic ? mapping->writeback_index : 0;
+ 
  	/* where to start/end? */
  	if (wbc->range_cyclic) {
- 		start = mapping->writeback_index; /* Start from prev offset */
+ 		index = start_index;
  		end = -1;
- 		dout(" cyclic, start at %lu\n", start);
+ 		should_loop = (index > 0);
+ 		dout(" cyclic, start at %lu\n", index);
  	} else {
++<<<<<<< HEAD
 +		start = wbc->range_start >> PAGE_CACHE_SHIFT;
 +		end = wbc->range_end >> PAGE_CACHE_SHIFT;
++=======
+ 		index = wbc->range_start >> PAGE_SHIFT;
+ 		end = wbc->range_end >> PAGE_SHIFT;
++>>>>>>> 590e9d9861f5 (ceph: fix "range cyclic" mode writepages)
  		if (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)
- 			range_whole = 1;
- 		should_loop = 0;
- 		dout(" not cyclic, %lu to %lu\n", start, end);
+ 			range_whole = true;
+ 		should_loop = false;
+ 		dout(" not cyclic, %lu to %lu\n", index, end);
  	}
- 	index = start;
  
  retry:
  	/* find oldest snap context with dirty data */
@@@ -784,12 -848,10 +800,17 @@@
  	}
  	last_snapc = snapc;
  
++<<<<<<< HEAD
 +	while (!done && index <= end) {
 +		unsigned i;
 +		int first;
 +		pgoff_t strip_unit_end = 0;
++=======
+ 	stop = false;
+ 	while (!stop && index <= end) {
++>>>>>>> 590e9d9861f5 (ceph: fix "range cyclic" mode writepages)
  		int num_ops = 0, op_idx;
 -		unsigned i, pvec_pages, max_pages, locked_pages = 0;
 +		int pvec_pages, locked_pages = 0;
  		struct page **pages = NULL, **data_pages;
  		mempool_t *pool = NULL;	/* Becomes non-null if mempool used */
  		struct page *page;
@@@ -823,11 -885,13 +844,13 @@@ get_more_pages
  			    unlikely(page->mapping != mapping)) {
  				dout("!dirty or !mapping %p\n", page);
  				unlock_page(page);
 -				continue;
 +				break;
  			}
- 			if (!wbc->range_cyclic && page->index > end) {
+ 			if (page->index > end) {
  				dout("end of range %p\n", page);
- 				done = 1;
+ 				/* can't be range_cyclic (1st pass) because
+ 				 * end == -1 in that case. */
+ 				stop = done = true;
  				unlock_page(page);
  				break;
  			}
@@@ -836,15 -900,11 +859,23 @@@
  				unlock_page(page);
  				break;
  			}
++<<<<<<< HEAD
 +			if (wbc->sync_mode != WB_SYNC_NONE) {
 +				dout("waiting on writeback %p\n", page);
 +				wait_on_page_writeback(page);
 +			}
 +			if (page_offset(page) >=
 +			    (snap_size == -1 ? i_size : snap_size)) {
 +				dout("%p page eof %llu\n", page,
 +				     (snap_size == -1 ? i_size : snap_size));
 +				done = 1;
++=======
+ 			if (page_offset(page) >= ceph_wbc.i_size) {
+ 				dout("%p page eof %llu\n",
+ 				     page, ceph_wbc.i_size);
+ 				/* not done if range_cyclic */
+ 				stop = true;
++>>>>>>> 590e9d9861f5 (ceph: fix "range cyclic" mode writepages)
  				unlock_page(page);
  				break;
  			}
* Unmerged path fs/ceph/addr.c
