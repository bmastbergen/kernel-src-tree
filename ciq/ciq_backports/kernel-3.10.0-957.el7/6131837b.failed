blk-mq: count allocated but not started requests in iostats inflight

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Omar Sandoval <osandov@fb.com>
commit 6131837b1de66116459ef4413e26fdbc70d066dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6131837b.failed

In the legacy block case, we increment the counter right after we
allocate the request, not when the driver handles it. In both the legacy
and blk-mq cases, part_inc_in_flight() is called from
blk_account_io_start() right after we've allocated the request. blk-mq
only considers requests started requests as inflight, but this is
inconsistent with the legacy definition and the intention in the code.
This removes the started condition and instead counts all allocated
requests.

Fixes: f299b7c7a9de ("blk-mq: provide internal in-flight variant")
	Signed-off-by: Omar Sandoval <osandov@fb.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 6131837b1de66116459ef4413e26fdbc70d066dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index a8e551c0c631,5450cbc61f8d..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -65,6 -84,37 +65,40 @@@ static void blk_mq_hctx_clear_pending(s
  	sbitmap_clear_bit(&hctx->ctx_map, ctx->index_hw);
  }
  
++<<<<<<< HEAD
++=======
+ struct mq_inflight {
+ 	struct hd_struct *part;
+ 	unsigned int *inflight;
+ };
+ 
+ static void blk_mq_check_inflight(struct blk_mq_hw_ctx *hctx,
+ 				  struct request *rq, void *priv,
+ 				  bool reserved)
+ {
+ 	struct mq_inflight *mi = priv;
+ 
+ 	/*
+ 	 * index[0] counts the specific partition that was asked for. index[1]
+ 	 * counts the ones that are active on the whole device, so increment
+ 	 * that if mi->part is indeed a partition, and not a whole device.
+ 	 */
+ 	if (rq->part == mi->part)
+ 		mi->inflight[0]++;
+ 	if (mi->part->partno)
+ 		mi->inflight[1]++;
+ }
+ 
+ void blk_mq_in_flight(struct request_queue *q, struct hd_struct *part,
+ 		      unsigned int inflight[2])
+ {
+ 	struct mq_inflight mi = { .part = part, .inflight = inflight, };
+ 
+ 	inflight[0] = inflight[1] = 0;
+ 	blk_mq_queue_tag_busy_iter(q, blk_mq_check_inflight, &mi);
+ }
+ 
++>>>>>>> 6131837b1de6 (blk-mq: count allocated but not started requests in iostats inflight)
  void blk_freeze_queue_start(struct request_queue *q)
  {
  	int freeze_depth;
* Unmerged path block/blk-mq.c
