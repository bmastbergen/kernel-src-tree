netfilter: ipset: Collapse same condition body to a single one

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 9be37d2acdc4fa452a9e250341cbb77668ab94e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9be37d2a.failed

The set full case (with net_ratelimit()-ed pr_warn()) is already
handled, simply jump there.

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 9be37d2acdc4fa452a9e250341cbb77668ab94e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_hash_gen.h
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 9ce28af662bf,1c9b84e53dcc..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -594,29 -701,45 +594,45 @@@ mtype_add(struct ip_set *set, void *val
  	struct htable *t;
  	const struct mtype_elem *d = value;
  	struct mtype_elem *data;
 -	struct hbucket *n, *old = ERR_PTR(-ENOENT);
 -	int i, j = -1;
 +	struct hbucket *n;
 +	int i, ret = 0;
 +	int j = AHASH_MAX(h) + 1;
  	bool flag_exist = flags & IPSET_FLAG_EXIST;
 -	bool deleted = false, forceadd = false, reuse = false;
  	u32 key, multi = 0;
  
 -	if (set->elements >= h->maxelem) {
 -		if (SET_WITH_TIMEOUT(set))
 -			/* FIXME: when set is full, we slow down here */
 -			mtype_expire(set, h);
 -		if (set->elements >= h->maxelem && SET_WITH_FORCEADD(set))
 -			forceadd = true;
 +	if (SET_WITH_TIMEOUT(set) && h->elements >= h->maxelem)
 +		/* FIXME: when set is full, we slow down here */
 +		mtype_expire(h, NETS_LENGTH(set->family), h->dsize);
 +
 +	if (h->elements >= h->maxelem) {
 +		if (net_ratelimit())
 +			pr_warning("Set %s is full, maxelem %u reached\n",
 +				   set->name, h->maxelem);
 +		return -IPSET_ERR_HASH_FULL;
  	}
  
 -	t = ipset_dereference_protected(h->table, set);
 +	rcu_read_lock_bh();
 +	t = rcu_dereference_bh(h->table);
  	key = HKEY(value, h->initval, t->htable_bits);
++<<<<<<< HEAD
 +	n = hbucket(t, key);
++=======
+ 	n = __ipset_dereference_protected(hbucket(t, key), 1);
+ 	if (!n) {
+ 		if (forceadd || set->elements >= h->maxelem)
+ 			goto set_full;
+ 		old = NULL;
+ 		n = kzalloc(sizeof(*n) + AHASH_INIT_SIZE * set->dsize,
+ 			    GFP_ATOMIC);
+ 		if (!n)
+ 			return -ENOMEM;
+ 		n->size = AHASH_INIT_SIZE;
+ 		set->ext_size += sizeof(*n) + AHASH_INIT_SIZE * set->dsize;
+ 		goto copy_elem;
+ 	}
++>>>>>>> 9be37d2acdc4 (netfilter: ipset: Collapse same condition body to a single one)
  	for (i = 0; i < n->pos; i++) {
 -		if (!test_bit(i, n->used)) {
 -			/* Reuse first deleted entry */
 -			if (j == -1) {
 -				deleted = reuse = true;
 -				j = i;
 -			}
 -			continue;
 -		}
 -		data = ahash_data(n, i, set->dsize);
 +		data = ahash_data(n, i, h->dsize);
  		if (mtype_data_equal(data, d, &multi)) {
  			if (flag_exist ||
  			    (SET_WITH_TIMEOUT(set) &&
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
