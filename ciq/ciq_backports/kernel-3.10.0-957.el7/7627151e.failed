libceph: define new ceph_file_layout structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Yan, Zheng <zyan@redhat.com>
commit 7627151ea30bce2051e3cb27d7bb2c30083f86a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7627151e.failed

Define new ceph_file_layout structure and rename old ceph_file_layout
to ceph_file_layout_legacy. This is preparation for adding namespace
to ceph_file_layout structure.

	Signed-off-by: Yan, Zheng <zyan@redhat.com>
(cherry picked from commit 7627151ea30bce2051e3cb27d7bb2c30083f86a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/rbd.c
#	fs/ceph/ioctl.c
diff --cc drivers/block/rbd.c
index 62ccb08ae668,cc272ed46cfd..000000000000
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@@ -2002,9 -1921,35 +2002,41 @@@ static struct ceph_osd_request *rbd_osd
  
  	rbd_assert(num_ops == 1 || ((op_type == OBJ_OP_WRITE) && num_ops == 2));
  
++<<<<<<< HEAD
 +	return __rbd_osd_req_create(rbd_dev, snapc, num_ops,
 +	    (op_type == OBJ_OP_WRITE || op_type == OBJ_OP_DISCARD) ?
 +	    CEPH_OSD_FLAG_WRITE : CEPH_OSD_FLAG_READ, obj_request);
++=======
+ 	/* Allocate and initialize the request, for the num_ops ops */
+ 
+ 	osdc = &rbd_dev->rbd_client->client->osdc;
+ 	osd_req = ceph_osdc_alloc_request(osdc, snapc, num_ops, false,
+ 					  GFP_NOIO);
+ 	if (!osd_req)
+ 		goto fail;
+ 
+ 	if (op_type == OBJ_OP_WRITE || op_type == OBJ_OP_DISCARD)
+ 		osd_req->r_flags = CEPH_OSD_FLAG_WRITE | CEPH_OSD_FLAG_ONDISK;
+ 	else
+ 		osd_req->r_flags = CEPH_OSD_FLAG_READ;
+ 
+ 	osd_req->r_callback = rbd_osd_req_callback;
+ 	osd_req->r_priv = obj_request;
+ 
+ 	osd_req->r_base_oloc.pool = rbd_dev->layout.pool_id;
+ 	if (ceph_oid_aprintf(&osd_req->r_base_oid, GFP_NOIO, "%s",
+ 			     obj_request->object_name))
+ 		goto fail;
+ 
+ 	if (ceph_osdc_alloc_messages(osd_req, GFP_NOIO))
+ 		goto fail;
+ 
+ 	return osd_req;
+ 
+ fail:
+ 	ceph_osdc_put_request(osd_req);
+ 	return NULL;
++>>>>>>> 7627151ea30b (libceph: define new ceph_file_layout structure)
  }
  
  /*
@@@ -2028,11 -1977,36 +2060,41 @@@ rbd_osd_req_create_copyup(struct rbd_ob
  	if (img_request_discard_test(img_request))
  		num_osd_ops = 2;
  
++<<<<<<< HEAD
 +	return __rbd_osd_req_create(img_request->rbd_dev,
 +				    img_request->snapc, num_osd_ops,
 +				    CEPH_OSD_FLAG_WRITE, obj_request);
++=======
+ 	/* Allocate and initialize the request, for all the ops */
+ 
+ 	snapc = img_request->snapc;
+ 	rbd_dev = img_request->rbd_dev;
+ 	osdc = &rbd_dev->rbd_client->client->osdc;
+ 	osd_req = ceph_osdc_alloc_request(osdc, snapc, num_osd_ops,
+ 						false, GFP_NOIO);
+ 	if (!osd_req)
+ 		goto fail;
+ 
+ 	osd_req->r_flags = CEPH_OSD_FLAG_WRITE | CEPH_OSD_FLAG_ONDISK;
+ 	osd_req->r_callback = rbd_osd_req_callback;
+ 	osd_req->r_priv = obj_request;
+ 
+ 	osd_req->r_base_oloc.pool = rbd_dev->layout.pool_id;
+ 	if (ceph_oid_aprintf(&osd_req->r_base_oid, GFP_NOIO, "%s",
+ 			     obj_request->object_name))
+ 		goto fail;
+ 
+ 	if (ceph_osdc_alloc_messages(osd_req, GFP_NOIO))
+ 		goto fail;
+ 
+ 	return osd_req;
+ 
+ fail:
+ 	ceph_osdc_put_request(osd_req);
+ 	return NULL;
++>>>>>>> 7627151ea30b (libceph: define new ceph_file_layout structure)
  }
  
 -
  static void rbd_osd_req_destroy(struct ceph_osd_request *osd_req)
  {
  	ceph_osdc_put_request(osd_req);
@@@ -4850,49 -3991,24 +4912,68 @@@ static struct rbd_device *__rbd_dev_cre
  
  	rbd_dev->rbd_client = rbdc;
  	rbd_dev->spec = spec;
++<<<<<<< HEAD
++=======
+ 	rbd_dev->opts = opts;
+ 
+ 	/* Initialize the layout used for all rbd requests */
+ 
+ 	rbd_dev->layout.stripe_unit = 1 << RBD_MAX_OBJ_ORDER;
+ 	rbd_dev->layout.stripe_count = 1;
+ 	rbd_dev->layout.object_size = 1 << RBD_MAX_OBJ_ORDER;
+ 	rbd_dev->layout.pool_id = spec->pool_id;
+ 
+ 	/*
+ 	 * If this is a mapping rbd_dev (as opposed to a parent one),
+ 	 * pin our module.  We have a ref from do_rbd_add(), so use
+ 	 * __module_get().
+ 	 */
+ 	if (rbd_dev->opts)
+ 		__module_get(THIS_MODULE);
++>>>>>>> 7627151ea30b (libceph: define new ceph_file_layout structure)
 +
 +	return rbd_dev;
 +}
 +
 +/*
 + * Create a mapping rbd_dev.
 + */
 +static struct rbd_device *rbd_dev_create(struct rbd_client *rbdc,
 +					 struct rbd_spec *spec,
 +					 struct rbd_options *opts)
 +{
 +	struct rbd_device *rbd_dev;
 +
 +	rbd_dev = __rbd_dev_create(rbdc, spec);
 +	if (!rbd_dev)
 +		return NULL;
 +
 +	rbd_dev->opts = opts;
  
 +	/* get an id and fill in device name */
 +	rbd_dev->dev_id = ida_simple_get(&rbd_dev_id_ida, 0,
 +					 minor_to_rbd_dev_id(1 << MINORBITS),
 +					 GFP_KERNEL);
 +	if (rbd_dev->dev_id < 0)
 +		goto fail_rbd_dev;
 +
 +	sprintf(rbd_dev->name, RBD_DRV_NAME "%d", rbd_dev->dev_id);
 +	rbd_dev->task_wq = alloc_ordered_workqueue("%s-tasks", WQ_MEM_RECLAIM,
 +						   rbd_dev->name);
 +	if (!rbd_dev->task_wq)
 +		goto fail_dev_id;
 +
 +	/* we have a ref from do_rbd_add() */
 +	__module_get(THIS_MODULE);
 +
 +	dout("%s rbd_dev %p dev_id %d\n", __func__, rbd_dev, rbd_dev->dev_id);
  	return rbd_dev;
 +
 +fail_dev_id:
 +	ida_simple_remove(&rbd_dev_id_ida, rbd_dev->dev_id);
 +fail_rbd_dev:
 +	rbd_dev_free(rbd_dev);
 +	return NULL;
  }
  
  static void rbd_dev_destroy(struct rbd_device *rbd_dev)
@@@ -6069,6 -5186,8 +6150,11 @@@ static int rbd_dev_header_name(struct r
  	/* Record the header object name for this rbd image. */
  
  	rbd_assert(rbd_image_format_valid(rbd_dev->image_format));
++<<<<<<< HEAD
++=======
+ 
+ 	rbd_dev->header_oloc.pool = rbd_dev->layout.pool_id;
++>>>>>>> 7627151ea30b (libceph: define new ceph_file_layout structure)
  	if (rbd_dev->image_format == 1)
  		ret = ceph_oid_aprintf(&rbd_dev->header_oid, GFP_KERNEL, "%s%s",
  				       spec->image_name, RBD_SUFFIX);
diff --cc fs/ceph/ioctl.c
index c4904b66320d,843dd31a02cd..000000000000
--- a/fs/ceph/ioctl.c
+++ b/fs/ceph/ioctl.c
@@@ -21,11 -21,11 +21,19 @@@ static long ceph_ioctl_get_layout(struc
  
  	err = ceph_do_getattr(file_inode(file), CEPH_STAT_CAP_LAYOUT, false);
  	if (!err) {
++<<<<<<< HEAD
 +		l.stripe_unit = ceph_file_layout_su(ci->i_layout);
 +		l.stripe_count = ceph_file_layout_stripe_count(ci->i_layout);
 +		l.object_size = ceph_file_layout_object_size(ci->i_layout);
 +		l.data_pool = le32_to_cpu(ci->i_layout.fl_pg_pool);
 +		l.preferred_osd = -1;
++=======
+ 		l.stripe_unit = ci->i_layout.stripe_unit;
+ 		l.stripe_count = ci->i_layout.stripe_count;
+ 		l.object_size = ci->i_layout.object_size;
+ 		l.data_pool = ci->i_layout.pool_id;
+ 		l.preferred_osd = (s32)-1;
++>>>>>>> 7627151ea30b (libceph: define new ceph_file_layout structure)
  		if (copy_to_user(arg, &l, sizeof(l)))
  			return -EFAULT;
  	}
@@@ -94,10 -94,10 +102,10 @@@ static long ceph_ioctl_set_layout(struc
  	if (l.data_pool)
  		nl.data_pool = l.data_pool;
  	else
- 		nl.data_pool = ceph_file_layout_pg_pool(ci->i_layout);
+ 		nl.data_pool = ci->i_layout.pool_id;
  
  	/* this is obsolete, and always -1 */
 -	nl.preferred_osd = le64_to_cpu(-1);
 +	nl.preferred_osd = -1;
  
  	err = __validate_layout(mdsc, &nl);
  	if (err)
* Unmerged path drivers/block/rbd.c
diff --git a/fs/ceph/addr.c b/fs/ceph/addr.c
index adf7d1009bc0..8121da08e4da 100644
--- a/fs/ceph/addr.c
+++ b/fs/ceph/addr.c
@@ -1721,7 +1721,7 @@ enum {
 	POOL_WRITE	= 2,
 };
 
-static int __ceph_pool_perm_get(struct ceph_inode_info *ci, u32 pool)
+static int __ceph_pool_perm_get(struct ceph_inode_info *ci, s64 pool)
 {
 	struct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);
 	struct ceph_mds_client *mdsc = fsc->mdsc;
@@ -1748,7 +1748,7 @@ static int __ceph_pool_perm_get(struct ceph_inode_info *ci, u32 pool)
 	if (*p)
 		goto out;
 
-	dout("__ceph_pool_perm_get pool %u no perm cached\n", pool);
+	dout("__ceph_pool_perm_get pool %lld no perm cached\n", pool);
 
 	down_write(&mdsc->pool_perm_rwsem);
 	parent = NULL;
@@ -1852,13 +1852,13 @@ out_unlock:
 out:
 	if (!err)
 		err = have;
-	dout("__ceph_pool_perm_get pool %u result = %d\n", pool, err);
+	dout("__ceph_pool_perm_get pool %lld result = %d\n", pool, err);
 	return err;
 }
 
 int ceph_pool_perm_check(struct ceph_inode_info *ci, int need)
 {
-	u32 pool;
+	s64 pool;
 	int ret, flags;
 
 	/* does not support pool namespace yet */
@@ -1880,17 +1880,17 @@ int ceph_pool_perm_check(struct ceph_inode_info *ci, int need)
 
 	spin_lock(&ci->i_ceph_lock);
 	flags = ci->i_ceph_flags;
-	pool = ceph_file_layout_pg_pool(ci->i_layout);
+	pool = ci->i_layout.pool_id;
 	spin_unlock(&ci->i_ceph_lock);
 check:
 	if (flags & CEPH_I_POOL_PERM) {
 		if ((need & CEPH_CAP_FILE_RD) && !(flags & CEPH_I_POOL_RD)) {
-			dout("ceph_pool_perm_check pool %u no read perm\n",
+			dout("ceph_pool_perm_check pool %lld no read perm\n",
 			     pool);
 			return -EPERM;
 		}
 		if ((need & CEPH_CAP_FILE_WR) && !(flags & CEPH_I_POOL_WR)) {
-			dout("ceph_pool_perm_check pool %u no write perm\n",
+			dout("ceph_pool_perm_check pool %lld no write perm\n",
 			     pool);
 			return -EPERM;
 		}
@@ -1908,10 +1908,10 @@ check:
 		flags |= CEPH_I_POOL_WR;
 
 	spin_lock(&ci->i_ceph_lock);
-	if (pool == ceph_file_layout_pg_pool(ci->i_layout)) {
+	if (pool == ci->i_layout.pool_id) {
 		ci->i_ceph_flags = flags;
         } else {
-		pool = ceph_file_layout_pg_pool(ci->i_layout);
+		pool = ci->i_layout.pool_id;
 		flags = ci->i_ceph_flags;
 	}
 	spin_unlock(&ci->i_ceph_lock);
diff --git a/fs/ceph/caps.c b/fs/ceph/caps.c
index bef5bb710814..4dc715fc5a03 100644
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@ -3071,8 +3071,11 @@ static void handle_cap_grant(struct ceph_mds_client *mdsc,
 
 	if (newcaps & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR)) {
 		/* file layout may have changed */
-		ci->i_layout = grant->layout;
+		s64 old_pool = ci->i_layout.pool_id;
+		ceph_file_layout_from_legacy(&ci->i_layout, &grant->layout);
 		ci->i_pool_ns_len = pool_ns_len;
+		if (ci->i_layout.pool_id != old_pool)
+			ci->i_ceph_flags &= ~CEPH_I_POOL_PERM;
 
 		/* size/truncate_seq? */
 		queue_trunc = ceph_fill_file_size(inode, issued,
diff --git a/fs/ceph/file.c b/fs/ceph/file.c
index 4be6ff2c3e9e..90e960faf911 100644
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@ -1653,9 +1653,9 @@ static int ceph_zero_objects(struct inode *inode, loff_t offset, loff_t length)
 {
 	int ret = 0;
 	struct ceph_inode_info *ci = ceph_inode(inode);
-	s32 stripe_unit = ceph_file_layout_su(ci->i_layout);
-	s32 stripe_count = ceph_file_layout_stripe_count(ci->i_layout);
-	s32 object_size = ceph_file_layout_object_size(ci->i_layout);
+	s32 stripe_unit = ci->i_layout.stripe_unit;
+	s32 stripe_count = ci->i_layout.stripe_count;
+	s32 object_size = ci->i_layout.object_size;
 	u64 object_set_size = object_size * stripe_count;
 	u64 nearly, t;
 
diff --git a/fs/ceph/inode.c b/fs/ceph/inode.c
index 89fde4d86e99..4b3b6c340d36 100644
--- a/fs/ceph/inode.c
+++ b/fs/ceph/inode.c
@@ -800,10 +800,11 @@ static int fill_inode(struct inode *inode, struct page *locked_page,
 
 	if (new_version ||
 	    (new_issued & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR))) {
-		if (ci->i_layout.fl_pg_pool != info->layout.fl_pg_pool)
-			ci->i_ceph_flags &= ~CEPH_I_POOL_PERM;
-		ci->i_layout = info->layout;
+		s64 old_pool = ci->i_layout.pool_id;
+		ceph_file_layout_from_legacy(&ci->i_layout, &info->layout);
 		ci->i_pool_ns_len = iinfo->pool_ns_len;
+		if (ci->i_layout.pool_id != old_pool)
+			ci->i_ceph_flags &= ~CEPH_I_POOL_PERM;
 
 		queue_trunc = ceph_fill_file_size(inode, issued,
 					le32_to_cpu(info->truncate_seq),
* Unmerged path fs/ceph/ioctl.c
diff --git a/fs/ceph/mds_client.h b/fs/ceph/mds_client.h
index 3c0db49cd37e..dc4e4d4d048e 100644
--- a/fs/ceph/mds_client.h
+++ b/fs/ceph/mds_client.h
@@ -285,8 +285,8 @@ struct ceph_mds_request {
 
 struct ceph_pool_perm {
 	struct rb_node node;
-	u32 pool;
 	int perm;
+	s64 pool;
 };
 
 /*
diff --git a/fs/ceph/xattr.c b/fs/ceph/xattr.c
index 4a72e8322a31..95f12b2d407b 100644
--- a/fs/ceph/xattr.c
+++ b/fs/ceph/xattr.c
@@ -69,7 +69,7 @@ static size_t ceph_vxattrcb_layout(struct ceph_inode_info *ci, char *val,
 	int ret;
 	struct ceph_fs_client *fsc = ceph_sb_to_client(ci->vfs_inode.i_sb);
 	struct ceph_osd_client *osdc = &fsc->client->osdc;
-	s64 pool = ceph_file_layout_pg_pool(ci->i_layout);
+	s64 pool = ci->i_layout.pool_id;
 	const char *pool_name;
 	char buf[128];
 
@@ -79,10 +79,9 @@ static size_t ceph_vxattrcb_layout(struct ceph_inode_info *ci, char *val,
 	if (pool_name) {
 		size_t len = strlen(pool_name);
 		ret = snprintf(buf, sizeof(buf),
-		"stripe_unit=%lld stripe_count=%lld object_size=%lld pool=",
-		(unsigned long long)ceph_file_layout_su(ci->i_layout),
-		(unsigned long long)ceph_file_layout_stripe_count(ci->i_layout),
-	        (unsigned long long)ceph_file_layout_object_size(ci->i_layout));
+		"stripe_unit=%u stripe_count=%u object_size=%u pool=",
+		ci->i_layout.stripe_unit, ci->i_layout.stripe_count,
+	        ci->i_layout.object_size);
 		if (!size) {
 			ret += len;
 		} else if (ret + len > size) {
@@ -94,11 +93,9 @@ static size_t ceph_vxattrcb_layout(struct ceph_inode_info *ci, char *val,
 		}
 	} else {
 		ret = snprintf(buf, sizeof(buf),
-		"stripe_unit=%lld stripe_count=%lld object_size=%lld pool=%lld",
-		(unsigned long long)ceph_file_layout_su(ci->i_layout),
-		(unsigned long long)ceph_file_layout_stripe_count(ci->i_layout),
-	        (unsigned long long)ceph_file_layout_object_size(ci->i_layout),
-		(unsigned long long)pool);
+		"stripe_unit=%u stripe_count=%u object_size=%u pool=%lld",
+		ci->i_layout.stripe_unit, ci->i_layout.stripe_count,
+	        ci->i_layout.object_size, (unsigned long long)pool);
 		if (size) {
 			if (ret <= size)
 				memcpy(val, buf, ret);
@@ -113,22 +110,19 @@ static size_t ceph_vxattrcb_layout(struct ceph_inode_info *ci, char *val,
 static size_t ceph_vxattrcb_layout_stripe_unit(struct ceph_inode_info *ci,
 					       char *val, size_t size)
 {
-	return snprintf(val, size, "%lld",
-			(unsigned long long)ceph_file_layout_su(ci->i_layout));
+	return snprintf(val, size, "%u", ci->i_layout.stripe_unit);
 }
 
 static size_t ceph_vxattrcb_layout_stripe_count(struct ceph_inode_info *ci,
 						char *val, size_t size)
 {
-	return snprintf(val, size, "%lld",
-	       (unsigned long long)ceph_file_layout_stripe_count(ci->i_layout));
+	return snprintf(val, size, "%u", ci->i_layout.stripe_count);
 }
 
 static size_t ceph_vxattrcb_layout_object_size(struct ceph_inode_info *ci,
 					       char *val, size_t size)
 {
-	return snprintf(val, size, "%lld",
-	       (unsigned long long)ceph_file_layout_object_size(ci->i_layout));
+	return snprintf(val, size, "%u", ci->i_layout.object_size);
 }
 
 static size_t ceph_vxattrcb_layout_pool(struct ceph_inode_info *ci,
@@ -137,7 +131,7 @@ static size_t ceph_vxattrcb_layout_pool(struct ceph_inode_info *ci,
 	int ret;
 	struct ceph_fs_client *fsc = ceph_sb_to_client(ci->vfs_inode.i_sb);
 	struct ceph_osd_client *osdc = &fsc->client->osdc;
-	s64 pool = ceph_file_layout_pg_pool(ci->i_layout);
+	s64 pool = ci->i_layout.pool_id;
 	const char *pool_name;
 
 	down_read(&osdc->lock);
diff --git a/include/linux/ceph/ceph_fs.h b/include/linux/ceph/ceph_fs.h
index 45fc5ba3262d..59345b0c02cf 100644
--- a/include/linux/ceph/ceph_fs.h
+++ b/include/linux/ceph/ceph_fs.h
@@ -34,9 +34,9 @@
 #define CEPH_MAX_MON   31
 
 /*
- * ceph_file_layout - describe data layout for a file/inode
+ * legacy ceph_file_layoute
  */
-struct ceph_file_layout {
+struct ceph_file_layout_legacy {
 	/* file -> object mapping */
 	__le32 fl_stripe_unit;     /* stripe unit, in bytes.  must be multiple
 				      of page size. */
@@ -53,33 +53,25 @@ struct ceph_file_layout {
 	__le32 fl_pg_pool;      /* namespace, crush ruleset, rep level */
 } __attribute__ ((packed));
 
-#define ceph_file_layout_su(l) ((__s32)le32_to_cpu((l).fl_stripe_unit))
-#define ceph_file_layout_stripe_count(l) \
-	((__s32)le32_to_cpu((l).fl_stripe_count))
-#define ceph_file_layout_object_size(l) ((__s32)le32_to_cpu((l).fl_object_size))
-#define ceph_file_layout_cas_hash(l) ((__s32)le32_to_cpu((l).fl_cas_hash))
-#define ceph_file_layout_object_su(l) \
-	((__s32)le32_to_cpu((l).fl_object_stripe_unit))
-#define ceph_file_layout_pg_pool(l) \
-	((__s32)le32_to_cpu((l).fl_pg_pool))
-
-static inline unsigned ceph_file_layout_stripe_width(struct ceph_file_layout *l)
-{
-	return le32_to_cpu(l->fl_stripe_unit) *
-		le32_to_cpu(l->fl_stripe_count);
-}
-
-/* "period" == bytes before i start on a new set of objects */
-static inline unsigned ceph_file_layout_period(struct ceph_file_layout *l)
-{
-	return le32_to_cpu(l->fl_object_size) *
-		le32_to_cpu(l->fl_stripe_count);
-}
+/*
+ * ceph_file_layout - describe data layout for a file/inode
+ */
+struct ceph_file_layout {
+	/* file -> object mapping */
+	u32 stripe_unit;   /* stripe unit, in bytes */
+	u32 stripe_count;  /* over this many objects */
+	u32 object_size;   /* until objects are this big */
+	s64 pool_id;        /* rados pool id */
+};
+
+extern int ceph_file_layout_is_valid(const struct ceph_file_layout *layout);
+extern void ceph_file_layout_from_legacy(struct ceph_file_layout *fl,
+				struct ceph_file_layout_legacy *legacy);
+extern void ceph_file_layout_to_legacy(struct ceph_file_layout *fl,
+				struct ceph_file_layout_legacy *legacy);
 
 #define CEPH_MIN_STRIPE_UNIT 65536
 
-int ceph_file_layout_is_valid(const struct ceph_file_layout *layout);
-
 struct ceph_dir_layout {
 	__u8   dl_dir_hash;   /* see ceph_hash.h for ids */
 	__u8   dl_unused1;
@@ -429,7 +421,7 @@ union ceph_mds_request_args {
 		__le32 flags;
 	} __attribute__ ((packed)) setxattr;
 	struct {
-		struct ceph_file_layout layout;
+		struct ceph_file_layout_legacy layout;
 	} __attribute__ ((packed)) setlayout;
 	struct {
 		__u8 rule; /* currently fcntl or flock */
@@ -508,7 +500,7 @@ struct ceph_mds_reply_inode {
 	__le64 version;                /* inode version */
 	__le64 xattr_version;          /* version for xattr blob */
 	struct ceph_mds_reply_cap cap; /* caps issued for this inode */
-	struct ceph_file_layout layout;
+	struct ceph_file_layout_legacy layout;
 	struct ceph_timespec ctime, mtime, atime;
 	__le32 time_warp_seq;
 	__le64 size, max_size, truncate_size;
@@ -708,7 +700,7 @@ struct ceph_mds_caps {
 	__le64 size, max_size, truncate_size;
 	__le32 truncate_seq;
 	struct ceph_timespec mtime, atime, ctime;
-	struct ceph_file_layout layout;
+	struct ceph_file_layout_legacy layout;
 	__le32 time_warp_seq;
 } __attribute__ ((packed));
 
diff --git a/net/ceph/ceph_fs.c b/net/ceph/ceph_fs.c
index 41466ccb972a..7d54e944de5e 100644
--- a/net/ceph/ceph_fs.c
+++ b/net/ceph/ceph_fs.c
@@ -9,9 +9,9 @@
  */
 int ceph_file_layout_is_valid(const struct ceph_file_layout *layout)
 {
-	__u32 su = le32_to_cpu(layout->fl_stripe_unit);
-	__u32 sc = le32_to_cpu(layout->fl_stripe_count);
-	__u32 os = le32_to_cpu(layout->fl_object_size);
+	__u32 su = layout->stripe_unit;
+	__u32 sc = layout->stripe_count;
+	__u32 os = layout->object_size;
 
 	/* stripe unit, object size must be non-zero, 64k increment */
 	if (!su || (su & (CEPH_MIN_STRIPE_UNIT-1)))
@@ -27,6 +27,30 @@ int ceph_file_layout_is_valid(const struct ceph_file_layout *layout)
 	return 1;
 }
 
+void ceph_file_layout_from_legacy(struct ceph_file_layout *fl,
+				  struct ceph_file_layout_legacy *legacy)
+{
+	fl->stripe_unit = le32_to_cpu(legacy->fl_stripe_unit);
+	fl->stripe_count = le32_to_cpu(legacy->fl_stripe_count);
+	fl->object_size = le32_to_cpu(legacy->fl_object_size);
+	fl->pool_id = le32_to_cpu(legacy->fl_pg_pool);
+	if (fl->pool_id == 0)
+		fl->pool_id = -1;
+}
+EXPORT_SYMBOL(ceph_file_layout_from_legacy);
+
+void ceph_file_layout_to_legacy(struct ceph_file_layout *fl,
+				struct ceph_file_layout_legacy *legacy)
+{
+	legacy->fl_stripe_unit = cpu_to_le32(fl->stripe_unit);
+	legacy->fl_stripe_count = cpu_to_le32(fl->stripe_count);
+	legacy->fl_object_size = cpu_to_le32(fl->object_size);
+	if (fl->pool_id >= 0)
+		legacy->fl_pg_pool = cpu_to_le32(fl->pool_id);
+	else
+		legacy->fl_pg_pool = 0;
+}
+EXPORT_SYMBOL(ceph_file_layout_to_legacy);
 
 int ceph_flags_to_mode(int flags)
 {
diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c
index 105036300de0..5ce892d7bc7a 100644
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@ -948,7 +948,7 @@ struct ceph_osd_request *ceph_osdc_new_request(struct ceph_osd_client *osdc,
 	if (opcode == CEPH_OSD_OP_CREATE || opcode == CEPH_OSD_OP_DELETE) {
 		osd_req_op_init(req, which, opcode, 0);
 	} else {
-		u32 object_size = le32_to_cpu(layout->fl_object_size);
+		u32 object_size = layout->object_size;
 		u32 object_base = off - objoff;
 		if (!(truncate_seq == 1 && truncate_size == -1ULL)) {
 			if (truncate_size <= object_base) {
@@ -965,7 +965,7 @@ struct ceph_osd_request *ceph_osdc_new_request(struct ceph_osd_client *osdc,
 
 	req->r_abort_on_full = true;
 	req->r_flags = flags;
-	req->r_base_oloc.pool = ceph_file_layout_pg_pool(*layout);
+	req->r_base_oloc.pool = layout->pool_id;
 	ceph_oid_printf(&req->r_base_oid, "%llx.%08llx", vino.ino, objnum);
 
 	req->r_snapid = vino.snap;
diff --git a/net/ceph/osdmap.c b/net/ceph/osdmap.c
index f24224ba4cf0..ae9f82df5d47 100644
--- a/net/ceph/osdmap.c
+++ b/net/ceph/osdmap.c
@@ -2133,9 +2133,9 @@ int ceph_calc_file_object_mapping(struct ceph_file_layout *layout,
 				   u64 *ono,
 				   u64 *oxoff, u64 *oxlen)
 {
-	u32 osize = le32_to_cpu(layout->fl_object_size);
-	u32 su = le32_to_cpu(layout->fl_stripe_unit);
-	u32 sc = le32_to_cpu(layout->fl_stripe_count);
+	u32 osize = layout->object_size;
+	u32 su = layout->stripe_unit;
+	u32 sc = layout->stripe_count;
 	u32 bl, stripeno, stripepos, objsetno;
 	u32 su_per_object;
 	u64 t, su_offset;
