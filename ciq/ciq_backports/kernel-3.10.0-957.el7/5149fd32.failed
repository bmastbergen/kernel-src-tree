xfs: bump up reserved blocks in xfs_alloc_set_aside

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 5149fd327f16e393c1d04fa5325ab072c32472bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5149fd32.failed

Setting aside 4 blocks globally for bmbt splits isn't all that useful,
as different threads can allocate space in parallel.  Bump it to 4
blocks per AG to allow each thread that is currently doing an
allocation to dip into it separately.  Without that we may no have
enough reserved blocks if there are enough parallel transactions
in an almost out space file system that all run into bmap btree
splits.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 5149fd327f16e393c1d04fa5325ab072c32472bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_alloc.c
diff --cc fs/xfs/libxfs/xfs_alloc.c
index aacd02eca34b,0a46f8488b8d..000000000000
--- a/fs/xfs/libxfs/xfs_alloc.c
+++ b/fs/xfs/libxfs/xfs_alloc.c
@@@ -50,6 -52,85 +50,88 @@@ STATIC int xfs_alloc_ag_vextent_size(xf
  STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,
  		xfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);
  
++<<<<<<< HEAD
++=======
+ unsigned int
+ xfs_refc_block(
+ 	struct xfs_mount	*mp)
+ {
+ 	if (xfs_sb_version_hasrmapbt(&mp->m_sb))
+ 		return XFS_RMAP_BLOCK(mp) + 1;
+ 	if (xfs_sb_version_hasfinobt(&mp->m_sb))
+ 		return XFS_FIBT_BLOCK(mp) + 1;
+ 	return XFS_IBT_BLOCK(mp) + 1;
+ }
+ 
+ xfs_extlen_t
+ xfs_prealloc_blocks(
+ 	struct xfs_mount	*mp)
+ {
+ 	if (xfs_sb_version_hasreflink(&mp->m_sb))
+ 		return xfs_refc_block(mp) + 1;
+ 	if (xfs_sb_version_hasrmapbt(&mp->m_sb))
+ 		return XFS_RMAP_BLOCK(mp) + 1;
+ 	if (xfs_sb_version_hasfinobt(&mp->m_sb))
+ 		return XFS_FIBT_BLOCK(mp) + 1;
+ 	return XFS_IBT_BLOCK(mp) + 1;
+ }
+ 
+ /*
+  * In order to avoid ENOSPC-related deadlock caused by out-of-order locking of
+  * AGF buffer (PV 947395), we place constraints on the relationship among
+  * actual allocations for data blocks, freelist blocks, and potential file data
+  * bmap btree blocks. However, these restrictions may result in no actual space
+  * allocated for a delayed extent, for example, a data block in a certain AG is
+  * allocated but there is no additional block for the additional bmap btree
+  * block due to a split of the bmap btree of the file. The result of this may
+  * lead to an infinite loop when the file gets flushed to disk and all delayed
+  * extents need to be actually allocated. To get around this, we explicitly set
+  * aside a few blocks which will not be reserved in delayed allocation.
+  *
+  * We need to reserve 4 fsbs _per AG_ for the freelist and 4 more to handle a
+  * potential split of the file's bmap btree.
+  */
+ unsigned int
+ xfs_alloc_set_aside(
+ 	struct xfs_mount	*mp)
+ {
+ 	return mp->m_sb.sb_agcount * (XFS_ALLOC_AGFL_RESERVE + 4);
+ }
+ 
+ /*
+  * When deciding how much space to allocate out of an AG, we limit the
+  * allocation maximum size to the size the AG. However, we cannot use all the
+  * blocks in the AG - some are permanently used by metadata. These
+  * blocks are generally:
+  *	- the AG superblock, AGF, AGI and AGFL
+  *	- the AGF (bno and cnt) and AGI btree root blocks, and optionally
+  *	  the AGI free inode and rmap btree root blocks.
+  *	- blocks on the AGFL according to xfs_alloc_set_aside() limits
+  *	- the rmapbt root block
+  *
+  * The AG headers are sector sized, so the amount of space they take up is
+  * dependent on filesystem geometry. The others are all single blocks.
+  */
+ unsigned int
+ xfs_alloc_ag_max_usable(
+ 	struct xfs_mount	*mp)
+ {
+ 	unsigned int		blocks;
+ 
+ 	blocks = XFS_BB_TO_FSB(mp, XFS_FSS_TO_BB(mp, 4)); /* ag headers */
+ 	blocks += XFS_ALLOC_AGFL_RESERVE;
+ 	blocks += 3;			/* AGF, AGI btree root blocks */
+ 	if (xfs_sb_version_hasfinobt(&mp->m_sb))
+ 		blocks++;		/* finobt root block */
+ 	if (xfs_sb_version_hasrmapbt(&mp->m_sb))
+ 		blocks++; 		/* rmap root block */
+ 	if (xfs_sb_version_hasreflink(&mp->m_sb))
+ 		blocks++;		/* refcount root block */
+ 
+ 	return mp->m_sb.sb_agblocks - blocks;
+ }
+ 
++>>>>>>> 5149fd327f16 (xfs: bump up reserved blocks in xfs_alloc_set_aside)
  /*
   * Lookup the record equal to [bno, len] in the btree given by cur.
   */
* Unmerged path fs/xfs/libxfs/xfs_alloc.c
