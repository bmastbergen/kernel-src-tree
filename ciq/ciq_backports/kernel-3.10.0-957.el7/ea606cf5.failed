mm: move max_map_count bits into mm.h

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mm] move max_map_count bits into mm.h (Rafael Aquini) [1562137]
Rebuild_FUZZ: 94.29%
commit-author Andrey Ryabinin <aryabinin@virtuozzo.com>
commit ea606cf5d8df370e7932460dfd960b21f20e7c6d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ea606cf5.failed

max_map_count sysctl unrelated to scheduler. Move its bits from
include/linux/sched/sysctl.h to include/linux/mm.h.

	Signed-off-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ea606cf5d8df370e7932460dfd960b21f20e7c6d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mm.h
#	include/linux/sched/sysctl.h
#	mm/nommu.c
diff --cc include/linux/mm.h
index d2f11a68bcdf,6922adf41938..000000000000
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@@ -66,6 -71,38 +66,41 @@@ extern int mmap_rnd_compat_bits __read_
  #define __pa_symbol(x)  __pa(RELOC_HIDE((unsigned long)(x), 0))
  #endif
  
++<<<<<<< HEAD
++=======
+ /*
+  * To prevent common memory management code establishing
+  * a zero page mapping on a read fault.
+  * This macro should be defined within <asm/pgtable.h>.
+  * s390 does this to prevent multiplexing of hardware bits
+  * related to the physical page in case of virtualization.
+  */
+ #ifndef mm_forbids_zeropage
+ #define mm_forbids_zeropage(X)	(0)
+ #endif
+ 
+ /*
+  * Default maximum number of active map areas, this limits the number of vmas
+  * per mm struct. Users can overwrite this number by sysctl but there is a
+  * problem.
+  *
+  * When a program's coredump is generated as ELF format, a section is created
+  * per a vma. In ELF, the number of sections is represented in unsigned short.
+  * This means the number of sections should be smaller than 65535 at coredump.
+  * Because the kernel adds some informative sections to a image of program at
+  * generating coredump, we need some margin. The number of extra sections is
+  * 1-3 now and depends on arch. We use "5" as safe margin, here.
+  *
+  * ELF extended numbering allows more than 65535 sections, so 16-bit bound is
+  * not a hard limit any more. Although some userspace tools can be surprised by
+  * that.
+  */
+ #define MAPCOUNT_ELF_CORE_MARGIN	(5)
+ #define DEFAULT_MAX_MAP_COUNT	(USHRT_MAX - MAPCOUNT_ELF_CORE_MARGIN)
+ 
+ extern int sysctl_max_map_count;
+ 
++>>>>>>> ea606cf5d8df (mm: move max_map_count bits into mm.h)
  extern unsigned long sysctl_user_reserve_kbytes;
  extern unsigned long sysctl_admin_reserve_kbytes;
  
diff --cc include/linux/sched/sysctl.h
index 48954842f052,22db1e63707e..000000000000
--- a/include/linux/sched/sysctl.h
+++ b/include/linux/sched/sysctl.h
@@@ -14,23 -14,6 +14,26 @@@ extern int proc_dohung_task_timeout_sec
  enum { sysctl_hung_task_timeout_secs = 0 };
  #endif
  
++<<<<<<< HEAD
 +/*
 + * Default maximum number of active map areas, this limits the number of vmas
 + * per mm struct. Users can overwrite this number by sysctl but there is a
 + * problem.
 + *
 + * When a program's coredump is generated as ELF format, a section is created
 + * per a vma. In ELF, the number of sections is represented in unsigned short.
 + * This means the number of sections should be smaller than 65535 at coredump.
 + * Because the kernel adds some informative sections to a image of program at
 + * generating coredump, we need some margin. The number of extra sections is
 + * 1-3 now and depends on arch. We use "5" as safe margin, here.
 + */
 +#define MAPCOUNT_ELF_CORE_MARGIN	(5)
 +#define DEFAULT_MAX_MAP_COUNT	(USHRT_MAX - MAPCOUNT_ELF_CORE_MARGIN)
 +
 +extern int sysctl_max_map_count;
 +
++=======
++>>>>>>> ea606cf5d8df (mm: move max_map_count bits into mm.h)
  extern unsigned int sysctl_sched_latency;
  extern unsigned int sysctl_sched_min_granularity;
  extern unsigned int sysctl_sched_wakeup_granularity;
diff --cc mm/nommu.c
index 636f04e40f81,9bdf8b119078..000000000000
--- a/mm/nommu.c
+++ b/mm/nommu.c
@@@ -29,7 -33,7 +29,11 @@@
  #include <linux/security.h>
  #include <linux/syscalls.h>
  #include <linux/audit.h>
++<<<<<<< HEAD
 +#include <linux/sched/sysctl.h>
++=======
+ #include <linux/printk.h>
++>>>>>>> ea606cf5d8df (mm: move max_map_count bits into mm.h)
  
  #include <asm/uaccess.h>
  #include <asm/tlb.h>
* Unmerged path include/linux/mm.h
* Unmerged path include/linux/sched/sysctl.h
diff --git a/mm/mmap.c b/mm/mmap.c
index 774cc98b230c..156dceb2e550 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -33,7 +33,6 @@
 #include <linux/khugepaged.h>
 #include <linux/uprobes.h>
 #include <linux/rbtree_augmented.h>
-#include <linux/sched/sysctl.h>
 #include <linux/notifier.h>
 #include <linux/memory.h>
 #include <linux/userfaultfd_k.h>
diff --git a/mm/mremap.c b/mm/mremap.c
index 075feac0d8ea..ce826e24a7ee 100644
--- a/mm/mremap.c
+++ b/mm/mremap.c
@@ -20,7 +20,6 @@
 #include <linux/security.h>
 #include <linux/syscalls.h>
 #include <linux/mmu_notifier.h>
-#include <linux/sched/sysctl.h>
 #include <linux/uaccess.h>
 #include <linux/mm-arch-hooks.h>
 #include <linux/userfaultfd_k.h>
* Unmerged path mm/nommu.c
