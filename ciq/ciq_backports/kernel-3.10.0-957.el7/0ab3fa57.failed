Input: psmouse - implement fast reconnect option

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [input] psmouse - implement fast reconnect option (Benjamin Tissoires) [1554926]
Rebuild_FUZZ: 92.13%
commit-author Dmitry Torokhov <dmitry.torokhov@gmail.com>
commit 0ab3fa57425023f42e8822a293d9b87a3ad4e2b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0ab3fa57.failed

Make use of serio's fast reconnect option and allow psmouse protocol
handler's to implement fast reconnect handlers that will be called during
system resume.

	Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
(cherry picked from commit 0ab3fa57425023f42e8822a293d9b87a3ad4e2b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/input/mouse/psmouse-base.c
diff --cc drivers/input/mouse/psmouse-base.c
index 689f85d37ffb,47fd2976da7f..000000000000
--- a/drivers/input/mouse/psmouse-base.c
+++ b/drivers/input/mouse/psmouse-base.c
@@@ -1132,6 -934,274 +1132,277 @@@ static const struct psmouse_protocol *p
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Apply default settings to the psmouse structure. Most of them will
+  * be overridden by individual protocol initialization routines.
+  */
+ static void psmouse_apply_defaults(struct psmouse *psmouse)
+ {
+ 	struct input_dev *input_dev = psmouse->dev;
+ 
+ 	memset(input_dev->evbit, 0, sizeof(input_dev->evbit));
+ 	memset(input_dev->keybit, 0, sizeof(input_dev->keybit));
+ 	memset(input_dev->relbit, 0, sizeof(input_dev->relbit));
+ 	memset(input_dev->absbit, 0, sizeof(input_dev->absbit));
+ 	memset(input_dev->mscbit, 0, sizeof(input_dev->mscbit));
+ 
+ 	__set_bit(EV_KEY, input_dev->evbit);
+ 	__set_bit(EV_REL, input_dev->evbit);
+ 
+ 	__set_bit(BTN_LEFT, input_dev->keybit);
+ 	__set_bit(BTN_RIGHT, input_dev->keybit);
+ 
+ 	__set_bit(REL_X, input_dev->relbit);
+ 	__set_bit(REL_Y, input_dev->relbit);
+ 
+ 	__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 	psmouse->set_rate = psmouse_set_rate;
+ 	psmouse->set_resolution = psmouse_set_resolution;
+ 	psmouse->set_scale = psmouse_set_scale;
+ 	psmouse->poll = psmouse_poll;
+ 	psmouse->protocol_handler = psmouse_process_byte;
+ 	psmouse->pktsize = 3;
+ 	psmouse->reconnect = NULL;
+ 	psmouse->fast_reconnect = NULL;
+ 	psmouse->disconnect = NULL;
+ 	psmouse->cleanup = NULL;
+ 	psmouse->pt_activate = NULL;
+ 	psmouse->pt_deactivate = NULL;
+ }
+ 
+ static bool psmouse_try_protocol(struct psmouse *psmouse,
+ 				 enum psmouse_type type,
+ 				 unsigned int *max_proto,
+ 				 bool set_properties, bool init_allowed)
+ {
+ 	const struct psmouse_protocol *proto;
+ 
+ 	proto = __psmouse_protocol_by_type(type);
+ 	if (!proto)
+ 		return false;
+ 
+ 	if (psmouse->ps2dev.serio->id.type == SERIO_PS_PSTHRU &&
+ 	    !proto->try_passthru) {
+ 		return false;
+ 	}
+ 
+ 	if (set_properties)
+ 		psmouse_apply_defaults(psmouse);
+ 
+ 	if (proto->detect(psmouse, set_properties) != 0)
+ 		return false;
+ 
+ 	if (set_properties && proto->init && init_allowed) {
+ 		if (proto->init(psmouse) != 0) {
+ 			/*
+ 			 * We detected device, but init failed. Adjust
+ 			 * max_proto so we only try standard protocols.
+ 			 */
+ 			if (*max_proto > PSMOUSE_IMEX)
+ 				*max_proto = PSMOUSE_IMEX;
+ 
+ 			return false;
+ 		}
+ 	}
+ 
+ 	return true;
+ }
+ 
+ /*
+  * psmouse_extensions() probes for any extensions to the basic PS/2 protocol
+  * the mouse may have.
+  */
+ static int psmouse_extensions(struct psmouse *psmouse,
+ 			      unsigned int max_proto, bool set_properties)
+ {
+ 	bool synaptics_hardware = false;
+ 
+ 	/*
+ 	 * Always check for focaltech, this is safe as it uses pnp-id
+ 	 * matching.
+ 	 */
+ 	if (psmouse_try_protocol(psmouse, PSMOUSE_FOCALTECH,
+ 				 &max_proto, set_properties, false)) {
+ 		if (max_proto > PSMOUSE_IMEX &&
+ 		    IS_ENABLED(CONFIG_MOUSE_PS2_FOCALTECH) &&
+ 		    (!set_properties || focaltech_init(psmouse) == 0)) {
+ 			return PSMOUSE_FOCALTECH;
+ 		}
+ 		/*
+ 		 * Restrict psmouse_max_proto so that psmouse_initialize()
+ 		 * does not try to reset rate and resolution, because even
+ 		 * that upsets the device.
+ 		 * This also causes us to basically fall through to basic
+ 		 * protocol detection, where we fully reset the mouse,
+ 		 * and set it up as bare PS/2 protocol device.
+ 		 */
+ 		psmouse_max_proto = max_proto = PSMOUSE_PS2;
+ 	}
+ 
+ 	/*
+ 	 * We always check for LifeBook because it does not disturb mouse
+ 	 * (it only checks DMI information).
+ 	 */
+ 	if (psmouse_try_protocol(psmouse, PSMOUSE_LIFEBOOK, &max_proto,
+ 				 set_properties, max_proto > PSMOUSE_IMEX))
+ 		return PSMOUSE_LIFEBOOK;
+ 
+ 	if (psmouse_try_protocol(psmouse, PSMOUSE_VMMOUSE, &max_proto,
+ 				 set_properties, max_proto > PSMOUSE_IMEX))
+ 		return PSMOUSE_VMMOUSE;
+ 
+ 	/*
+ 	 * Try Kensington ThinkingMouse (we try first, because Synaptics
+ 	 * probe upsets the ThinkingMouse).
+ 	 */
+ 	if (max_proto > PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_THINKPS, &max_proto,
+ 				 set_properties, true)) {
+ 		return PSMOUSE_THINKPS;
+ 	}
+ 
+ 	/*
+ 	 * Try Synaptics TouchPad. Note that probing is done even if
+ 	 * Synaptics protocol support is disabled in config - we need to
+ 	 * know if it is Synaptics so we can reset it properly after
+ 	 * probing for IntelliMouse.
+ 	 */
+ 	if (max_proto > PSMOUSE_PS2 &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_SYNAPTICS, &max_proto,
+ 				 set_properties, false)) {
+ 		synaptics_hardware = true;
+ 
+ 		if (max_proto > PSMOUSE_IMEX) {
+ 			/*
+ 			 * Try activating protocol, but check if support is
+ 			 * enabled first, since we try detecting Synaptics
+ 			 * even when protocol is disabled.
+ 			 */
+ 			if (IS_ENABLED(CONFIG_MOUSE_PS2_SYNAPTICS) &&
+ 			    (!set_properties || synaptics_init(psmouse) == 0)) {
+ 				return PSMOUSE_SYNAPTICS;
+ 			}
+ 
+ 			/*
+ 			 * Some Synaptics touchpads can emulate extended
+ 			 * protocols (like IMPS/2).  Unfortunately
+ 			 * Logitech/Genius probes confuse some firmware
+ 			 * versions so we'll have to skip them.
+ 			 */
+ 			max_proto = PSMOUSE_IMEX;
+ 		}
+ 
+ 		/*
+ 		 * Make sure that touchpad is in relative mode, gestures
+ 		 * (taps) are enabled.
+ 		 */
+ 		synaptics_reset(psmouse);
+ 	}
+ 
+ 	/*
+ 	 * Try Cypress Trackpad. We must try it before Finger Sensing Pad
+ 	 * because Finger Sensing Pad probe upsets some modules of Cypress
+ 	 * Trackpads.
+ 	 */
+ 	if (max_proto > PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_CYPRESS, &max_proto,
+ 				 set_properties, true)) {
+ 		return PSMOUSE_CYPRESS;
+ 	}
+ 
+ 	/* Try ALPS TouchPad */
+ 	if (max_proto > PSMOUSE_IMEX) {
+ 		ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);
+ 		if (psmouse_try_protocol(psmouse, PSMOUSE_ALPS,
+ 					 &max_proto, set_properties, true))
+ 			return PSMOUSE_ALPS;
+ 	}
+ 
+ 	/* Try OLPC HGPK touchpad */
+ 	if (max_proto > PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_HGPK, &max_proto,
+ 				 set_properties, true)) {
+ 		return PSMOUSE_HGPK;
+ 	}
+ 
+ 	/* Try Elantech touchpad */
+ 	if (max_proto > PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_ELANTECH,
+ 				 &max_proto, set_properties, true)) {
+ 		return PSMOUSE_ELANTECH;
+ 	}
+ 
+ 	if (max_proto > PSMOUSE_IMEX) {
+ 		if (psmouse_try_protocol(psmouse, PSMOUSE_GENPS,
+ 					 &max_proto, set_properties, true))
+ 			return PSMOUSE_GENPS;
+ 
+ 		if (psmouse_try_protocol(psmouse, PSMOUSE_PS2PP,
+ 					 &max_proto, set_properties, true))
+ 			return PSMOUSE_PS2PP;
+ 
+ 		if (psmouse_try_protocol(psmouse, PSMOUSE_TRACKPOINT,
+ 					 &max_proto, set_properties, true))
+ 			return PSMOUSE_TRACKPOINT;
+ 
+ 		if (psmouse_try_protocol(psmouse, PSMOUSE_TOUCHKIT_PS2,
+ 					 &max_proto, set_properties, true))
+ 			return PSMOUSE_TOUCHKIT_PS2;
+ 	}
+ 
+ 	/*
+ 	 * Try Finger Sensing Pad. We do it here because its probe upsets
+ 	 * Trackpoint devices (causing TP_READ_ID command to time out).
+ 	 */
+ 	if (max_proto > PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_FSP,
+ 				 &max_proto, set_properties, true)) {
+ 		return PSMOUSE_FSP;
+ 	}
+ 
+ 	/*
+ 	 * Reset to defaults in case the device got confused by extended
+ 	 * protocol probes. Note that we follow up with full reset because
+ 	 * some mice put themselves to sleep when they see PSMOUSE_RESET_DIS.
+ 	 */
+ 	ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);
+ 	psmouse_reset(psmouse);
+ 
+ 	if (max_proto >= PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_IMEX,
+ 				 &max_proto, set_properties, true)) {
+ 		return PSMOUSE_IMEX;
+ 	}
+ 
+ 	if (max_proto >= PSMOUSE_IMPS &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_IMPS,
+ 				 &max_proto, set_properties, true)) {
+ 		return PSMOUSE_IMPS;
+ 	}
+ 
+ 	/*
+ 	 * Okay, all failed, we have a standard mouse here. The number of
+ 	 * the buttons is still a question, though. We assume 3.
+ 	 */
+ 	psmouse_try_protocol(psmouse, PSMOUSE_PS2,
+ 			     &max_proto, set_properties, true);
+ 
+ 	if (synaptics_hardware) {
+ 		/*
+ 		 * We detected Synaptics hardware but it did not respond to
+ 		 * IMPS/2 probes.  We need to reset the touchpad because if
+ 		 * there is a track point on the pass through port it could
+ 		 * get disabled while probing for protocol extensions.
+ 		 */
+ 		psmouse_reset(psmouse);
+ 	}
+ 
+ 	return PSMOUSE_PS2;
+ }
++>>>>>>> 0ab3fa574250 (Input: psmouse - implement fast reconnect option)
  
  /*
   * psmouse_probe() probes for a PS/2 mouse.
@@@ -1564,23 -1629,26 +1835,41 @@@ static int psmouse_connect(struct seri
  	goto out;
  }
  
++<<<<<<< HEAD
 +
 +static int psmouse_reconnect(struct serio *serio)
 +{
 +	struct psmouse *psmouse = serio_get_drvdata(serio);
 +	struct psmouse *parent = NULL;
 +	struct serio_driver *drv = serio->drv;
++=======
+ static int __psmouse_reconnect(struct serio *serio, bool fast_reconnect)
+ {
+ 	struct psmouse *psmouse = serio_get_drvdata(serio);
+ 	struct psmouse *parent = NULL;
+ 	int (*reconnect_handler)(struct psmouse *);
++>>>>>>> 0ab3fa574250 (Input: psmouse - implement fast reconnect option)
  	unsigned char type;
  	int rc = -1;
  
 +	if (!drv || !psmouse) {
 +		psmouse_dbg(psmouse,
 +			    "reconnect request, but serio is disconnected, ignoring...\n");
 +		return -1;
 +	}
 +
  	mutex_lock(&psmouse_mutex);
  
+ 	if (fast_reconnect) {
+ 		reconnect_handler = psmouse->fast_reconnect;
+ 		if (!reconnect_handler) {
+ 			rc = -ENOENT;
+ 			goto out_unlock;
+ 		}
+ 	} else {
+ 		reconnect_handler = psmouse->reconnect;
+ 	}
+ 
  	if (serio->parent && serio->id.type == SERIO_PS_PSTHRU) {
  		parent = serio_get_drvdata(serio->parent);
  		psmouse_deactivate(parent);
* Unmerged path drivers/input/mouse/psmouse-base.c
diff --git a/drivers/input/mouse/psmouse.h b/drivers/input/mouse/psmouse.h
index c01433fafba8..cac2289b40f1 100644
--- a/drivers/input/mouse/psmouse.h
+++ b/drivers/input/mouse/psmouse.h
@@ -74,6 +74,7 @@ struct psmouse {
 	void (*set_resolution)(struct psmouse *psmouse, unsigned int resolution);
 
 	int (*reconnect)(struct psmouse *psmouse);
+	int (*fast_reconnect)(struct psmouse *psmouse);
 	void (*disconnect)(struct psmouse *psmouse);
 	void (*cleanup)(struct psmouse *psmouse);
 	int (*poll)(struct psmouse *psmouse);
