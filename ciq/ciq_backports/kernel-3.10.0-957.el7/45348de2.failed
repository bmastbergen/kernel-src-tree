scsi: aacraid: Fix controller initialization failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] aacraid: Fix controller initialization failure (Raghava Aditya Renukunta) [1519664]
Rebuild_FUZZ: 93.88%
commit-author Raghava Aditya Renukunta <RaghavaAditya.Renukunta@microsemi.com>
commit 45348de2c8a7a1e64c5be27b22c9786b4152dd41
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/45348de2.failed

This is a fix to an issue where the driver sends its periodic WELLNESS
command to the controller after the driver shut it down.This causes the
controller to crash. The window where this can happen is small, but it
can be hit at around 4 hours of constant resets.

	Cc: <stable@vger.kernel.org>
Fixes: fbd185986eba (aacraid: Fix AIF triggered IOP_RESET)
	Signed-off-by: Raghava Aditya Renukunta <RaghavaAditya.Renukunta@microsemi.com>
	Reviewed-by: Dave Carroll <david.carroll@microsemi.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 45348de2c8a7a1e64c5be27b22c9786b4152dd41)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/aacraid/linit.c
diff --cc drivers/scsi/aacraid/linit.c
index 75cdeb69a748,c9252b138c1f..000000000000
--- a/drivers/scsi/aacraid/linit.c
+++ b/drivers/scsi/aacraid/linit.c
@@@ -1642,10 -1550,10 +1642,11 @@@ static struct scsi_host_template aac_dr
  static void __aac_shutdown(struct aac_dev * aac)
  {
  	int i;
 +	int cpu;
  
+ 	mutex_lock(&aac->ioctl_mutex);
  	aac->adapter_shutdown = 1;
- 	aac_send_shutdown(aac);
+ 	mutex_unlock(&aac->ioctl_mutex);
  
  	if (aac->aif_thread) {
  		int i;
@@@ -1658,25 -1566,15 +1659,33 @@@
  		}
  		kthread_stop(aac->thread);
  	}
+ 
+ 	aac_send_shutdown(aac);
+ 
  	aac_adapter_disable_int(aac);
++<<<<<<< HEAD
 +	cpu = cpumask_first(cpu_online_mask);
 +	if (aac->pdev->device == PMC_DEVICE_S6 ||
 +	    aac->pdev->device == PMC_DEVICE_S7 ||
 +	    aac->pdev->device == PMC_DEVICE_S8 ||
 +	    aac->pdev->device == PMC_DEVICE_S9) {
++=======
+ 
+ 	if (aac_is_src(aac)) {
++>>>>>>> 45348de2c8a7 (scsi: aacraid: Fix controller initialization failure)
  		if (aac->max_msix > 1) {
  			for (i = 0; i < aac->max_msix; i++) {
 -				free_irq(pci_irq_vector(aac->pdev, i),
 +				if (irq_set_affinity_hint(
 +				    aac->msixentry[i].vector,
 +				    NULL)) {
 +					printk(KERN_ERR "%s%d: Failed to reset IRQ affinity for cpu %d\n",
 +						aac->name,
 +						aac->id,
 +						cpu);
 +				}
 +				cpu = cpumask_next(cpu,
 +						cpu_online_mask);
 +				free_irq(aac->msixentry[i].vector,
  					 &(aac->aac_msix[i]));
  			}
  		} else {
diff --git a/drivers/scsi/aacraid/comminit.c b/drivers/scsi/aacraid/comminit.c
index d0dfeac04814..f4e1f3b40e6e 100644
--- a/drivers/scsi/aacraid/comminit.c
+++ b/drivers/scsi/aacraid/comminit.c
@@ -305,9 +305,11 @@ int aac_send_shutdown(struct aac_dev * dev)
 		return -ENOMEM;
 	aac_fib_init(fibctx);
 
-	mutex_lock(&dev->ioctl_mutex);
-	dev->adapter_shutdown = 1;
-	mutex_unlock(&dev->ioctl_mutex);
+	if (!dev->adapter_shutdown) {
+		mutex_lock(&dev->ioctl_mutex);
+		dev->adapter_shutdown = 1;
+		mutex_unlock(&dev->ioctl_mutex);
+	}
 
 	cmd = (struct aac_close *) fib_data(fibctx);
 	cmd->command = cpu_to_le32(VM_CloseAll);
* Unmerged path drivers/scsi/aacraid/linit.c
