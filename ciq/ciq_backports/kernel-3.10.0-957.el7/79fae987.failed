thunderbolt: Handle connecting device in place of host properly

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [thunderbolt] Handle connecting device in place of host properly (Jarod Wilson) [1495229]
Rebuild_FUZZ: 88.50%
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 79fae987518a3aa6c3c7b2e3ad5fe1e4080c12bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/79fae987.failed

If the system is suspended and user disconnects cable to another host
and connects it to a Thunderbolt device instead we get a warning from
driver core about adding duplicate sysfs attribute and adding the new
device fails.

Handle this properly so that we first remove the existing XDomain
connection before adding new devices.

Fixes: d1ff70241a27 ("thunderbolt: Add support for XDomain discovery protocol")
	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
	Cc: stable@vger.kernel.org
(cherry picked from commit 79fae987518a3aa6c3c7b2e3ad5fe1e4080c12bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/thunderbolt/icm.c
diff --cc drivers/thunderbolt/icm.c
index d17ce097807d,182226023acb..000000000000
--- a/drivers/thunderbolt/icm.c
+++ b/drivers/thunderbolt/icm.c
@@@ -480,6 -546,132 +497,135 @@@ icm_fr_device_disconnected(struct tb *t
  	tb_switch_put(sw);
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ icm_fr_xdomain_connected(struct tb *tb, const struct icm_pkg_header *hdr)
+ {
+ 	const struct icm_fr_event_xdomain_connected *pkg =
+ 		(const struct icm_fr_event_xdomain_connected *)hdr;
+ 	struct tb_xdomain *xd;
+ 	struct tb_switch *sw;
+ 	u8 link, depth;
+ 	bool approved;
+ 	u64 route;
+ 
+ 	/*
+ 	 * After NVM upgrade adding root switch device fails because we
+ 	 * initiated reset. During that time ICM might still send
+ 	 * XDomain connected message which we ignore here.
+ 	 */
+ 	if (!tb->root_switch)
+ 		return;
+ 
+ 	link = pkg->link_info & ICM_LINK_INFO_LINK_MASK;
+ 	depth = (pkg->link_info & ICM_LINK_INFO_DEPTH_MASK) >>
+ 		ICM_LINK_INFO_DEPTH_SHIFT;
+ 	approved = pkg->link_info & ICM_LINK_INFO_APPROVED;
+ 
+ 	if (link > ICM_MAX_LINK || depth > ICM_MAX_DEPTH) {
+ 		tb_warn(tb, "invalid topology %u.%u, ignoring\n", link, depth);
+ 		return;
+ 	}
+ 
+ 	route = get_route(pkg->local_route_hi, pkg->local_route_lo);
+ 
+ 	xd = tb_xdomain_find_by_uuid(tb, &pkg->remote_uuid);
+ 	if (xd) {
+ 		u8 xd_phy_port, phy_port;
+ 
+ 		xd_phy_port = phy_port_from_route(xd->route, xd->depth);
+ 		phy_port = phy_port_from_route(route, depth);
+ 
+ 		if (xd->depth == depth && xd_phy_port == phy_port) {
+ 			xd->link = link;
+ 			xd->route = route;
+ 			xd->is_unplugged = false;
+ 			tb_xdomain_put(xd);
+ 			return;
+ 		}
+ 
+ 		/*
+ 		 * If we find an existing XDomain connection remove it
+ 		 * now. We need to go through login handshake and
+ 		 * everything anyway to be able to re-establish the
+ 		 * connection.
+ 		 */
+ 		remove_xdomain(xd);
+ 		tb_xdomain_put(xd);
+ 	}
+ 
+ 	/*
+ 	 * Look if there already exists an XDomain in the same place
+ 	 * than the new one and in that case remove it because it is
+ 	 * most likely another host that got disconnected.
+ 	 */
+ 	xd = tb_xdomain_find_by_link_depth(tb, link, depth);
+ 	if (!xd) {
+ 		u8 dual_link;
+ 
+ 		dual_link = dual_link_from_link(link);
+ 		if (dual_link)
+ 			xd = tb_xdomain_find_by_link_depth(tb, dual_link,
+ 							   depth);
+ 	}
+ 	if (xd) {
+ 		remove_xdomain(xd);
+ 		tb_xdomain_put(xd);
+ 	}
+ 
+ 	/*
+ 	 * If the user disconnected a switch during suspend and
+ 	 * connected another host to the same port, remove the switch
+ 	 * first.
+ 	 */
+ 	sw = get_switch_at_route(tb->root_switch, route);
+ 	if (sw)
+ 		remove_switch(sw);
+ 
+ 	sw = tb_switch_find_by_link_depth(tb, link, depth);
+ 	if (!sw) {
+ 		tb_warn(tb, "no switch exists at %u.%u, ignoring\n", link,
+ 			depth);
+ 		return;
+ 	}
+ 
+ 	xd = tb_xdomain_alloc(sw->tb, &sw->dev, route,
+ 			      &pkg->local_uuid, &pkg->remote_uuid);
+ 	if (!xd) {
+ 		tb_switch_put(sw);
+ 		return;
+ 	}
+ 
+ 	xd->link = link;
+ 	xd->depth = depth;
+ 
+ 	tb_port_at(route, sw)->xdomain = xd;
+ 
+ 	tb_xdomain_add(xd);
+ 	tb_switch_put(sw);
+ }
+ 
+ static void
+ icm_fr_xdomain_disconnected(struct tb *tb, const struct icm_pkg_header *hdr)
+ {
+ 	const struct icm_fr_event_xdomain_disconnected *pkg =
+ 		(const struct icm_fr_event_xdomain_disconnected *)hdr;
+ 	struct tb_xdomain *xd;
+ 
+ 	/*
+ 	 * If the connection is through one or multiple devices, the
+ 	 * XDomain device is removed along with them so it is fine if we
+ 	 * cannot find it here.
+ 	 */
+ 	xd = tb_xdomain_find_by_uuid(tb, &pkg->remote_uuid);
+ 	if (xd) {
+ 		remove_xdomain(xd);
+ 		tb_xdomain_put(xd);
+ 	}
+ }
+ 
++>>>>>>> 79fae987518a (thunderbolt: Handle connecting device in place of host properly)
  static struct pci_dev *get_upstream_port(struct pci_dev *pdev)
  {
  	struct pci_dev *parent;
* Unmerged path drivers/thunderbolt/icm.c
