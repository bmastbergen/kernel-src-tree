md: raid1: use bio helper in process_checks()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [md] raid1: use bio helper in process_checks() (Nigel Croxon) [1494474]
Rebuild_FUZZ: 95.35%
commit-author Ming Lei <tom.leiming@gmail.com>
commit 60928a91b0b3beca4a1cf2739118f967c783f79a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/60928a91.failed

Avoid to direct access to bvec table.

	Signed-off-by: Ming Lei <tom.leiming@gmail.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit 60928a91b0b3beca4a1cf2739118f967c783f79a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid1.c
diff --cc drivers/md/raid1.c
index adeb56feeb3d,d27b84666884..000000000000
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@@ -2046,27 -2110,27 +2046,37 @@@ static void process_checks(struct r1bi
  	for (i = 0; i < conf->raid_disks * 2; i++) {
  		int j;
  		int size;
++<<<<<<< HEAD
 +		int uptodate;
++=======
+ 		int error;
+ 		struct bio_vec *bi;
++>>>>>>> 60928a91b0b3 (md: raid1: use bio helper in process_checks())
  		struct bio *b = r1_bio->bios[i];
 -		struct resync_pages *rp = get_resync_pages(b);
  		if (b->bi_end_io != end_sync_read)
  			continue;
 -		/* fixup the bio for reuse, but preserve errno */
 -		error = b->bi_error;
 +		/* fixup the bio for reuse, but preserve BIO_UPTODATE */
 +		uptodate = test_bit(BIO_UPTODATE, &b->bi_flags);
  		bio_reset(b);
 -		b->bi_error = error;
 +		if (!uptodate)
 +			clear_bit(BIO_UPTODATE, &b->bi_flags);
  		b->bi_vcnt = vcnt;
 -		b->bi_iter.bi_size = r1_bio->sectors << 9;
 -		b->bi_iter.bi_sector = r1_bio->sector +
 +		b->bi_size = r1_bio->sectors << 9;
 +		b->bi_sector = r1_bio->sector +
  			conf->mirrors[i].rdev->data_offset;
  		b->bi_bdev = conf->mirrors[i].rdev->bdev;
  		b->bi_end_io = end_sync_read;
 -		rp->raid_bio = r1_bio;
 -		b->bi_private = rp;
 -
 +		b->bi_private = r1_bio;
 +
++<<<<<<< HEAD
 +		size = b->bi_size;
 +		for (j = 0; j < vcnt ; j++) {
 +			struct bio_vec *bi;
 +			bi = &b->bi_io_vec[j];
++=======
+ 		size = b->bi_iter.bi_size;
+ 		bio_for_each_segment_all(bi, b, j) {
++>>>>>>> 60928a91b0b3 (md: raid1: use bio helper in process_checks())
  			bi->bv_offset = 0;
  			if (size > PAGE_SIZE)
  				bi->bv_len = PAGE_SIZE;
@@@ -2087,21 -2151,25 +2097,40 @@@
  		int j;
  		struct bio *pbio = r1_bio->bios[primary];
  		struct bio *sbio = r1_bio->bios[i];
++<<<<<<< HEAD
 +		int uptodate = test_bit(BIO_UPTODATE, &sbio->bi_flags);
++=======
+ 		int error = sbio->bi_error;
+ 		struct page **ppages = get_resync_pages(pbio)->pages;
+ 		struct page **spages = get_resync_pages(sbio)->pages;
+ 		struct bio_vec *bi;
+ 		int page_len[RESYNC_PAGES];
++>>>>>>> 60928a91b0b3 (md: raid1: use bio helper in process_checks())
  
  		if (sbio->bi_end_io != end_sync_read)
  			continue;
 -		/* Now we can 'fixup' the error value */
 -		sbio->bi_error = 0;
 +		/* Now we can 'fixup' the BIO_UPTODATE flag */
 +		set_bit(BIO_UPTODATE, &sbio->bi_flags);
  
++<<<<<<< HEAD
 +		if (uptodate) {
 +			for (j = vcnt; j-- ; ) {
 +				struct page *p, *s;
 +				p = pbio->bi_io_vec[j].bv_page;
 +				s = sbio->bi_io_vec[j].bv_page;
 +				if (memcmp(page_address(p),
 +					   page_address(s),
 +					   sbio->bi_io_vec[j].bv_len))
++=======
+ 		bio_for_each_segment_all(bi, sbio, j)
+ 			page_len[j] = bi->bv_len;
+ 
+ 		if (!error) {
+ 			for (j = vcnt; j-- ; ) {
+ 				if (memcmp(page_address(ppages[j]),
+ 					   page_address(spages[j]),
+ 					   page_len[j]))
++>>>>>>> 60928a91b0b3 (md: raid1: use bio helper in process_checks())
  					break;
  			}
  		} else
* Unmerged path drivers/md/raid1.c
