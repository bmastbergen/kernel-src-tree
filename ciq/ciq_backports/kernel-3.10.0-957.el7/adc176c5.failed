ipv6 addrconf: Implemented enhanced DAD (RFC7527)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] ipv6: addrconf: Implemented enhanced DAD (RFC7527) (Jarod Wilson) [1608002]
Rebuild_FUZZ: 98.99%
commit-author Erik Nordmark <nordmark@arista.com>
commit adc176c5472214971d77c1a61c83db9b01e9cdc7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/adc176c5.failed

Implemented RFC7527 Enhanced DAD.
IPv6 duplicate address detection can fail if there is some temporary
loopback of Ethernet frames. RFC7527 solves this by including a random
nonce in the NS messages used for DAD, and if an NS is received with the
same nonce it is assumed to be a looped back DAD probe and is ignored.
RFC7527 is enabled by default. Can be disabled by setting both of
conf/{all,interface}/enhanced_dad to zero.

	Signed-off-by: Erik Nordmark <nordmark@arista.com>
	Signed-off-by: Bob Gilligan <gilligan@arista.com>
	Reviewed-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit adc176c5472214971d77c1a61c83db9b01e9cdc7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/networking/ip-sysctl.txt
#	include/linux/ipv6.h
#	include/net/ndisc.h
#	include/uapi/linux/ipv6.h
#	net/ipv6/addrconf.c
#	net/ipv6/ndisc.c
#	net/ipv6/route.c
diff --cc Documentation/networking/ip-sysctl.txt
index 1755c9b2d05f,7dd65c9cf707..000000000000
--- a/Documentation/networking/ip-sysctl.txt
+++ b/Documentation/networking/ip-sysctl.txt
@@@ -1512,6 -1721,28 +1512,31 @@@ stable_secret - IPv6 addres
  
  	By default the stable secret is unset.
  
++<<<<<<< HEAD
++=======
+ drop_unicast_in_l2_multicast - BOOLEAN
+ 	Drop any unicast IPv6 packets that are received in link-layer
+ 	multicast (or broadcast) frames.
+ 
+ 	By default this is turned off.
+ 
+ drop_unsolicited_na - BOOLEAN
+ 	Drop all unsolicited neighbor advertisements, for example if there's
+ 	a known good NA proxy on the network and such frames need not be used
+ 	(or in the case of 802.11, must not be used to prevent attacks.)
+ 
+ 	By default this is turned off.
+ 
+ enhanced_dad - BOOLEAN
+ 	Include a nonce option in the IPv6 neighbor solicitation messages used for
+ 	duplicate address detection per RFC7527. A received DAD NS will only signal
+ 	a duplicate address if the nonce is different. This avoids any false
+ 	detection of duplicates due to loopback of the NS messages that we send.
+ 	The nonce option will be sent on an interface unless both of
+ 	conf/{all,interface}/enhanced_dad are set to FALSE.
+ 	Default: TRUE
+ 
++>>>>>>> adc176c54722 (ipv6 addrconf: Implemented enhanced DAD (RFC7527))
  icmp/*:
  ratelimit - INTEGER
  	Limit the maximal rates for sending ICMPv6 packets.
diff --cc include/linux/ipv6.h
index 2372ba381596,671d014e6429..000000000000
--- a/include/linux/ipv6.h
+++ b/include/linux/ipv6.h
@@@ -54,11 -62,15 +54,17 @@@ struct ipv6_devconf 
  		bool initialized;
  		struct in6_addr secret;
  	} stable_secret;
 -	__s32		use_oif_addrs_only;
 -	__s32		keep_addr_on_down;
 -	__s32		seg6_enabled;
 -#ifdef CONFIG_IPV6_SEG6_HMAC
 -	__s32		seg6_require_hmac;
 +#ifdef CONFIG_IPV6_OPTIMISTIC_DAD
 +	__s32		use_optimistic;
  #endif
++<<<<<<< HEAD
 +#endif
 +	void		*sysctl;
++=======
+ 	__u32		enhanced_dad;
+ 
+ 	struct ctl_table_header *sysctl_header;
++>>>>>>> adc176c54722 (ipv6 addrconf: Implemented enhanced DAD (RFC7527))
  };
  
  struct ipv6_params {
diff --cc include/net/ndisc.h
index aa68cb2d8eeb,d562a2fe4860..000000000000
--- a/include/net/ndisc.h
+++ b/include/net/ndisc.h
@@@ -406,51 -391,28 +408,57 @@@ static inline struct neighbour *__ipv6_
  	return n;
  }
  
 -int ndisc_init(void);
 -int ndisc_late_init(void);
 +static inline void __ipv6_confirm_neigh(struct net_device *dev,
 +					const void *pkey)
 +{
 +	struct neighbour *n;
  
 -void ndisc_late_cleanup(void);
 -void ndisc_cleanup(void);
 +	rcu_read_lock_bh();
 +	n = __ipv6_neigh_lookup_noref(dev, pkey);
 +	if (n) {
 +		unsigned long now = jiffies;
  
 -int ndisc_rcv(struct sk_buff *skb);
 +		/* avoid dirtying neighbour */
 +		if (n->confirmed != now)
 +			n->confirmed = now;
 +	}
 +	rcu_read_unlock_bh();
 +}
  
++<<<<<<< HEAD
 +extern int			ndisc_init(void);
 +extern int			ndisc_late_init(void);
++=======
+ void ndisc_send_ns(struct net_device *dev, const struct in6_addr *solicit,
+ 		   const struct in6_addr *daddr, const struct in6_addr *saddr,
+ 		   u64 nonce);
++>>>>>>> adc176c54722 (ipv6 addrconf: Implemented enhanced DAD (RFC7527))
 +
 +extern void			ndisc_late_cleanup(void);
 +extern void			ndisc_cleanup(void);
 +
 +extern int			ndisc_rcv(struct sk_buff *skb);
 +
 +extern void			ndisc_send_ns(struct net_device *dev,
 +					      struct neighbour *neigh,
 +					      const struct in6_addr *solicit,
 +					      const struct in6_addr *daddr,
 +					      const struct in6_addr *saddr);
  
 -void ndisc_send_rs(struct net_device *dev,
 -		   const struct in6_addr *saddr, const struct in6_addr *daddr);
 -void ndisc_send_na(struct net_device *dev, const struct in6_addr *daddr,
 -		   const struct in6_addr *solicited_addr,
 -		   bool router, bool solicited, bool override, bool inc_opt);
 +extern void			ndisc_send_rs(struct net_device *dev,
 +					      const struct in6_addr *saddr,
 +					      const struct in6_addr *daddr);
 +extern void			ndisc_send_na(struct net_device *dev, struct neighbour *neigh,
 +					      const struct in6_addr *daddr,
 +					      const struct in6_addr *solicited_addr,
 +					      bool router, bool solicited, bool override,
 +					      bool inc_opt);
  
 -void ndisc_send_redirect(struct sk_buff *skb, const struct in6_addr *target);
 +extern void			ndisc_send_redirect(struct sk_buff *skb,
 +						    const struct in6_addr *target);
  
 -int ndisc_mc_map(const struct in6_addr *addr, char *buf, struct net_device *dev,
 -		 int dir);
 +extern int			ndisc_mc_map(const struct in6_addr *addr, char *buf,
 +					     struct net_device *dev, int dir);
  
  void ndisc_update(const struct net_device *dev, struct neighbour *neigh,
  		  const u8 *lladdr, u8 new, u32 flags, u8 icmp6_type,
diff --cc include/uapi/linux/ipv6.h
index 9ab97f0308fa,eaf65dc82e22..000000000000
--- a/include/uapi/linux/ipv6.h
+++ b/include/uapi/linux/ipv6.h
@@@ -167,6 -172,16 +167,19 @@@ enum 
  	DEVCONF_USE_OPTIMISTIC,
  	DEVCONF_ACCEPT_RA_MTU,
  	DEVCONF_STABLE_SECRET,
++<<<<<<< HEAD
++=======
+ 	DEVCONF_USE_OIF_ADDRS_ONLY,
+ 	DEVCONF_ACCEPT_RA_MIN_HOP_LIMIT,
+ 	DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN,
+ 	DEVCONF_DROP_UNICAST_IN_L2_MULTICAST,
+ 	DEVCONF_DROP_UNSOLICITED_NA,
+ 	DEVCONF_KEEP_ADDR_ON_DOWN,
+ 	DEVCONF_RTR_SOLICIT_MAX_INTERVAL,
+ 	DEVCONF_SEG6_ENABLED,
+ 	DEVCONF_SEG6_REQUIRE_HMAC,
+ 	DEVCONF_ENHANCED_DAD,
++>>>>>>> adc176c54722 (ipv6 addrconf: Implemented enhanced DAD (RFC7527))
  	DEVCONF_MAX
  };
  
diff --cc net/ipv6/addrconf.c
index 2a341b82af6d,c1e124bc8e1e..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -205,10 -229,20 +205,22 @@@ static struct ipv6_devconf ipv6_devcon
  	.proxy_ndp		= 0,
  	.accept_source_route	= 0,	/* we do not accept RH0 by default. */
  	.disable_ipv6		= 0,
 -	.accept_dad		= 1,
 -	.suppress_frag_ndisc	= 1,
 -	.accept_ra_mtu		= 1,
 +	.accept_dad		= 0,
  	.stable_secret		= {
  		.initialized = false,
++<<<<<<< HEAD
 +	}
++=======
+ 	},
+ 	.use_oif_addrs_only	= 0,
+ 	.ignore_routes_with_linkdown = 0,
+ 	.keep_addr_on_down	= 0,
+ 	.seg6_enabled		= 0,
+ #ifdef CONFIG_IPV6_SEG6_HMAC
+ 	.seg6_require_hmac	= 0,
+ #endif
+ 	.enhanced_dad           = 1,
++>>>>>>> adc176c54722 (ipv6 addrconf: Implemented enhanced DAD (RFC7527))
  };
  
  static struct ipv6_devconf ipv6_devconf_dflt __read_mostly = {
@@@ -247,6 -284,16 +259,17 @@@
  	.stable_secret		= {
  		.initialized = false,
  	},
++<<<<<<< HEAD
++=======
+ 	.use_oif_addrs_only	= 0,
+ 	.ignore_routes_with_linkdown = 0,
+ 	.keep_addr_on_down	= 0,
+ 	.seg6_enabled		= 0,
+ #ifdef CONFIG_IPV6_SEG6_HMAC
+ 	.seg6_require_hmac	= 0,
+ #endif
+ 	.enhanced_dad           = 1,
++>>>>>>> adc176c54722 (ipv6 addrconf: Implemented enhanced DAD (RFC7527))
  };
  
  /* Check if a valid qdisc is available */
@@@ -3593,7 -3929,8 +3625,12 @@@ static void addrconf_dad_work(struct wo
  
  	/* send a neighbour solicitation for our addr */
  	addrconf_addr_solict_mult(&ifp->addr, &mcaddr);
++<<<<<<< HEAD
 +	ndisc_send_ns(ifp->idev->dev, NULL, &ifp->addr, &mcaddr, &in6addr_any);
++=======
+ 	ndisc_send_ns(ifp->idev->dev, &ifp->addr, &mcaddr, &in6addr_any,
+ 		      ifp->dad_nonce);
++>>>>>>> adc176c54722 (ipv6 addrconf: Implemented enhanced DAD (RFC7527))
  out:
  	in6_ifa_put(ifp);
  	rtnl_unlock();
@@@ -4618,7 -4961,20 +4655,19 @@@ static inline void ipv6_store_devconf(s
  	array[DEVCONF_ACCEPT_DAD] = cnf->accept_dad;
  	array[DEVCONF_FORCE_TLLAO] = cnf->force_tllao;
  	array[DEVCONF_NDISC_NOTIFY] = cnf->ndisc_notify;
 -	array[DEVCONF_SUPPRESS_FRAG_NDISC] = cnf->suppress_frag_ndisc;
 -	array[DEVCONF_ACCEPT_RA_FROM_LOCAL] = cnf->accept_ra_from_local;
 -	array[DEVCONF_ACCEPT_RA_MTU] = cnf->accept_ra_mtu;
 -	array[DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN] = cnf->ignore_routes_with_linkdown;
  	/* we omit DEVCONF_STABLE_SECRET for now */
++<<<<<<< HEAD
++=======
+ 	array[DEVCONF_USE_OIF_ADDRS_ONLY] = cnf->use_oif_addrs_only;
+ 	array[DEVCONF_DROP_UNICAST_IN_L2_MULTICAST] = cnf->drop_unicast_in_l2_multicast;
+ 	array[DEVCONF_DROP_UNSOLICITED_NA] = cnf->drop_unsolicited_na;
+ 	array[DEVCONF_KEEP_ADDR_ON_DOWN] = cnf->keep_addr_on_down;
+ 	array[DEVCONF_SEG6_ENABLED] = cnf->seg6_enabled;
+ #ifdef CONFIG_IPV6_SEG6_HMAC
+ 	array[DEVCONF_SEG6_REQUIRE_HMAC] = cnf->seg6_require_hmac;
+ #endif
+ 	array[DEVCONF_ENHANCED_DAD] = cnf->enhanced_dad;
++>>>>>>> adc176c54722 (ipv6 addrconf: Implemented enhanced DAD (RFC7527))
  }
  
  static inline size_t inet6_ifla6_size(void)
@@@ -5297,267 -5711,387 +5346,381 @@@ out
  	return err;
  }
  
 -static
 -int addrconf_sysctl_ignore_routes_with_linkdown(struct ctl_table *ctl,
 -						int write,
 -						void __user *buffer,
 -						size_t *lenp,
 -						loff_t *ppos)
 -{
 -	int *valp = ctl->data;
 -	int val = *valp;
 -	loff_t pos = *ppos;
 -	struct ctl_table lctl;
 -	int ret;
 -
 -	/* ctl->data points to idev->cnf.ignore_routes_when_linkdown
 -	 * we should not modify it until we get the rtnl lock.
 -	 */
 -	lctl = *ctl;
 -	lctl.data = &val;
 -
 -	ret = proc_dointvec(&lctl, write, buffer, lenp, ppos);
 -
 -	if (write)
 -		ret = addrconf_fixup_linkdown(ctl, valp, val);
 -	if (ret)
 -		*ppos = pos;
 -	return ret;
 -}
 -
 -static int minus_one = -1;
 -static const int one = 1;
 -static const int two_five_five = 255;
 -
 -static const struct ctl_table addrconf_sysctl[] = {
 -	{
 -		.procname	= "forwarding",
 -		.data		= &ipv6_devconf.forwarding,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= addrconf_sysctl_forward,
 -	},
 -	{
 -		.procname	= "hop_limit",
 -		.data		= &ipv6_devconf.hop_limit,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= (void *)&one,
 -		.extra2		= (void *)&two_five_five,
 -	},
 -	{
 -		.procname	= "mtu",
 -		.data		= &ipv6_devconf.mtu6,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= addrconf_sysctl_mtu,
 -	},
 -	{
 -		.procname	= "accept_ra",
 -		.data		= &ipv6_devconf.accept_ra,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "accept_redirects",
 -		.data		= &ipv6_devconf.accept_redirects,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "autoconf",
 -		.data		= &ipv6_devconf.autoconf,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "dad_transmits",
 -		.data		= &ipv6_devconf.dad_transmits,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "router_solicitations",
 -		.data		= &ipv6_devconf.rtr_solicits,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &minus_one,
 -	},
 -	{
 -		.procname	= "router_solicitation_interval",
 -		.data		= &ipv6_devconf.rtr_solicit_interval,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_jiffies,
 -	},
 -	{
 -		.procname	= "router_solicitation_max_interval",
 -		.data		= &ipv6_devconf.rtr_solicit_max_interval,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_jiffies,
 -	},
 -	{
 -		.procname	= "router_solicitation_delay",
 -		.data		= &ipv6_devconf.rtr_solicit_delay,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_jiffies,
 -	},
 -	{
 -		.procname	= "force_mld_version",
 -		.data		= &ipv6_devconf.force_mld_version,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "mldv1_unsolicited_report_interval",
 -		.data		=
 -			&ipv6_devconf.mldv1_unsolicited_report_interval,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_ms_jiffies,
 -	},
 -	{
 -		.procname	= "mldv2_unsolicited_report_interval",
 -		.data		=
 -			&ipv6_devconf.mldv2_unsolicited_report_interval,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_ms_jiffies,
 -	},
 -	{
 -		.procname	= "use_tempaddr",
 -		.data		= &ipv6_devconf.use_tempaddr,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "temp_valid_lft",
 -		.data		= &ipv6_devconf.temp_valid_lft,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "temp_prefered_lft",
 -		.data		= &ipv6_devconf.temp_prefered_lft,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "regen_max_retry",
 -		.data		= &ipv6_devconf.regen_max_retry,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "max_desync_factor",
 -		.data		= &ipv6_devconf.max_desync_factor,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "max_addresses",
 -		.data		= &ipv6_devconf.max_addresses,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "accept_ra_defrtr",
 -		.data		= &ipv6_devconf.accept_ra_defrtr,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "accept_ra_min_hop_limit",
 -		.data		= &ipv6_devconf.accept_ra_min_hop_limit,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "accept_ra_pinfo",
 -		.data		= &ipv6_devconf.accept_ra_pinfo,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 +static struct addrconf_sysctl_table
 +{
 +	struct ctl_table_header *sysctl_header;
 +	struct ctl_table addrconf_vars[DEVCONF_MAX+1];
 +} addrconf_sysctl __read_mostly = {
 +	.sysctl_header = NULL,
 +	.addrconf_vars = {
 +		{
 +			.procname	= "forwarding",
 +			.data		= &ipv6_devconf.forwarding,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= addrconf_sysctl_forward,
 +		},
 +		{
 +			.procname	= "hop_limit",
 +			.data		= &ipv6_devconf.hop_limit,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= addrconf_sysctl_hop_limit,
 +		},
 +		{
 +			.procname	= "mtu",
 +			.data		= &ipv6_devconf.mtu6,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= addrconf_sysctl_mtu,
 +		},
 +		{
 +			.procname	= "accept_ra",
 +			.data		= &ipv6_devconf.accept_ra,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
 +		{
 +			.procname	= "accept_redirects",
 +			.data		= &ipv6_devconf.accept_redirects,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
 +		{
 +			.procname	= "autoconf",
 +			.data		= &ipv6_devconf.autoconf,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
 +		{
 +			.procname	= "dad_transmits",
 +			.data		= &ipv6_devconf.dad_transmits,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
 +		{
 +			.procname	= "router_solicitations",
 +			.data		= &ipv6_devconf.rtr_solicits,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
 +		{
 +			.procname	= "router_solicitation_interval",
 +			.data		= &ipv6_devconf.rtr_solicit_interval,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec_jiffies,
 +		},
 +		{
 +			.procname	= "router_solicitation_delay",
 +			.data		= &ipv6_devconf.rtr_solicit_delay,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec_jiffies,
 +		},
 +		{
 +			.procname	= "force_mld_version",
 +			.data		= &ipv6_devconf.force_mld_version,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
 +		{
 +			.procname	= "mldv1_unsolicited_report_interval",
 +			.data		=
 +				&ipv6_devconf.mldv1_unsolicited_report_interval,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec_ms_jiffies,
 +		},
 +		{
 +			.procname	= "mldv2_unsolicited_report_interval",
 +			.data		=
 +				&ipv6_devconf.mldv2_unsolicited_report_interval,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec_ms_jiffies,
 +		},
 +		{
 +			.procname	= "use_tempaddr",
 +			.data		= &ipv6_devconf.use_tempaddr,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
 +		{
 +			.procname	= "temp_valid_lft",
 +			.data		= &ipv6_devconf.temp_valid_lft,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
 +		{
 +			.procname	= "temp_prefered_lft",
 +			.data		= &ipv6_devconf.temp_prefered_lft,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
 +		{
 +			.procname	= "regen_max_retry",
 +			.data		= &ipv6_devconf.regen_max_retry,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
 +		{
 +			.procname	= "max_desync_factor",
 +			.data		= &ipv6_devconf.max_desync_factor,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
 +		{
 +			.procname	= "max_addresses",
 +			.data		= &ipv6_devconf.max_addresses,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
 +		{
 +			.procname	= "accept_ra_defrtr",
 +			.data		= &ipv6_devconf.accept_ra_defrtr,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
 +		{
 +			.procname	= "accept_ra_pinfo",
 +			.data		= &ipv6_devconf.accept_ra_pinfo,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
  #ifdef CONFIG_IPV6_ROUTER_PREF
 -	{
 -		.procname	= "accept_ra_rtr_pref",
 -		.data		= &ipv6_devconf.accept_ra_rtr_pref,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 -	{
 -		.procname	= "router_probe_interval",
 -		.data		= &ipv6_devconf.rtr_probe_interval,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_jiffies,
 -	},
 +		{
 +			.procname	= "accept_ra_rtr_pref",
 +			.data		= &ipv6_devconf.accept_ra_rtr_pref,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
 +		{
 +			.procname	= "router_probe_interval",
 +			.data		= &ipv6_devconf.rtr_probe_interval,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec_jiffies,
 +		},
  #ifdef CONFIG_IPV6_ROUTE_INFO
 -	{
 -		.procname	= "accept_ra_rt_info_max_plen",
 -		.data		= &ipv6_devconf.accept_ra_rt_info_max_plen,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 +		{
 +			.procname	= "accept_ra_rt_info_max_plen",
 +			.data		= &ipv6_devconf.accept_ra_rt_info_max_plen,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
  #endif
  #endif
 -	{
 -		.procname	= "proxy_ndp",
 -		.data		= &ipv6_devconf.proxy_ndp,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= addrconf_sysctl_proxy_ndp,
 -	},
 -	{
 -		.procname	= "accept_source_route",
 -		.data		= &ipv6_devconf.accept_source_route,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 +		{
 +			.procname	= "proxy_ndp",
 +			.data		= &ipv6_devconf.proxy_ndp,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
 +		{
 +			.procname	= "accept_source_route",
 +			.data		= &ipv6_devconf.accept_source_route,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
  #ifdef CONFIG_IPV6_OPTIMISTIC_DAD
 -	{
 -		.procname	= "optimistic_dad",
 -		.data		= &ipv6_devconf.optimistic_dad,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler   = proc_dointvec,
 -	},
 -	{
 -		.procname	= "use_optimistic",
 -		.data		= &ipv6_devconf.use_optimistic,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= proc_dointvec,
 -	},
 +		{
 +			.procname       = "optimistic_dad",
 +			.data           = &ipv6_devconf.optimistic_dad,
 +			.maxlen         = sizeof(int),
 +			.mode           = 0644,
 +			.proc_handler   = proc_dointvec,
 +
 +		},
 +		{
 +			.procname       = "use_optimistic",
 +			.data           = &ipv6_devconf.use_optimistic,
 +			.maxlen         = sizeof(int),
 +			.mode           = 0644,
 +			.proc_handler   = proc_dointvec,
 +
 +		},
  #endif
  #ifdef CONFIG_IPV6_MROUTE
 -	{
 -		.procname	= "mc_forwarding",
 -		.data		= &ipv6_devconf.mc_forwarding,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0444,
 -		.proc_handler	= proc_dointvec,
 -	},
 +		{
 +			.procname	= "mc_forwarding",
 +			.data		= &ipv6_devconf.mc_forwarding,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0444,
 +			.proc_handler	= proc_dointvec,
 +		},
  #endif
 -	{
 -		.procname	= "disable_ipv6",
 -		.data		= &ipv6_devconf.disable_ipv6,
 -		.maxlen		= sizeof(int),
 -		.mode		= 0644,
 -		.proc_handler	= addrconf_sysctl_disable,
 +		{
 +			.procname	= "disable_ipv6",
 +			.data		= &ipv6_devconf.disable_ipv6,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= addrconf_sysctl_disable,
 +		},
 +		{
 +			.procname	= "accept_dad",
 +			.data		= &ipv6_devconf.accept_dad,
 +			.maxlen		= sizeof(int),
 +			.mode		= 0644,
 +			.proc_handler	= proc_dointvec,
 +		},
 +		{
 +			.procname       = "force_tllao",
 +			.data           = &ipv6_devconf.force_tllao,
 +			.maxlen         = sizeof(int),
 +			.mode           = 0644,
 +			.proc_handler   = proc_dointvec
 +		},
 +		{
 +			.procname       = "ndisc_notify",
 +			.data           = &ipv6_devconf.ndisc_notify,
 +			.maxlen         = sizeof(int),
 +			.mode           = 0644,
 +			.proc_handler   = proc_dointvec
 +		},
 +		{
 +			.procname	= "stable_secret",
 +			.data		= &ipv6_devconf.stable_secret,
 +			.maxlen		= IPV6_MAX_STRLEN,
 +			.mode		= 0600,
 +			.proc_handler	= addrconf_sysctl_stable_secret,
 +		},
 +		{
 +			/* sentinel */
 +		}
  	},
++<<<<<<< HEAD
++=======
+ 	{
+ 		.procname	= "accept_dad",
+ 		.data		= &ipv6_devconf.accept_dad,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec,
+ 	},
+ 	{
+ 		.procname	= "force_tllao",
+ 		.data		= &ipv6_devconf.force_tllao,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "ndisc_notify",
+ 		.data		= &ipv6_devconf.ndisc_notify,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "suppress_frag_ndisc",
+ 		.data		= &ipv6_devconf.suppress_frag_ndisc,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec
+ 	},
+ 	{
+ 		.procname	= "accept_ra_from_local",
+ 		.data		= &ipv6_devconf.accept_ra_from_local,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec,
+ 	},
+ 	{
+ 		.procname	= "accept_ra_mtu",
+ 		.data		= &ipv6_devconf.accept_ra_mtu,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec,
+ 	},
+ 	{
+ 		.procname	= "stable_secret",
+ 		.data		= &ipv6_devconf.stable_secret,
+ 		.maxlen		= IPV6_MAX_STRLEN,
+ 		.mode		= 0600,
+ 		.proc_handler	= addrconf_sysctl_stable_secret,
+ 	},
+ 	{
+ 		.procname	= "use_oif_addrs_only",
+ 		.data		= &ipv6_devconf.use_oif_addrs_only,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec,
+ 	},
+ 	{
+ 		.procname	= "ignore_routes_with_linkdown",
+ 		.data		= &ipv6_devconf.ignore_routes_with_linkdown,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= addrconf_sysctl_ignore_routes_with_linkdown,
+ 	},
+ 	{
+ 		.procname	= "drop_unicast_in_l2_multicast",
+ 		.data		= &ipv6_devconf.drop_unicast_in_l2_multicast,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec,
+ 	},
+ 	{
+ 		.procname	= "drop_unsolicited_na",
+ 		.data		= &ipv6_devconf.drop_unsolicited_na,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec,
+ 	},
+ 	{
+ 		.procname	= "keep_addr_on_down",
+ 		.data		= &ipv6_devconf.keep_addr_on_down,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec,
+ 
+ 	},
+ 	{
+ 		.procname	= "seg6_enabled",
+ 		.data		= &ipv6_devconf.seg6_enabled,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec,
+ 	},
+ #ifdef CONFIG_IPV6_SEG6_HMAC
+ 	{
+ 		.procname	= "seg6_require_hmac",
+ 		.data		= &ipv6_devconf.seg6_require_hmac,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec,
+ 	},
+ #endif
+ 	{
+ 		.procname       = "enhanced_dad",
+ 		.data           = &ipv6_devconf.enhanced_dad,
+ 		.maxlen         = sizeof(int),
+ 		.mode           = 0644,
+ 		.proc_handler   = proc_dointvec,
+ 	},
+ 	{
+ 		/* sentinel */
+ 	}
++>>>>>>> adc176c54722 (ipv6 addrconf: Implemented enhanced DAD (RFC7527))
  };
  
  static int __addrconf_sysctl_register(struct net *net, char *dev_name,
diff --cc net/ipv6/ndisc.c
index 1cbdbfa69380,7ebac630d3c6..000000000000
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@@ -560,9 -568,9 +561,15 @@@ static void ndisc_send_unsol_na(struct 
  	in6_dev_put(idev);
  }
  
++<<<<<<< HEAD
 +void ndisc_send_ns(struct net_device *dev, struct neighbour *neigh,
 +		   const struct in6_addr *solicit,
 +		   const struct in6_addr *daddr, const struct in6_addr *saddr)
++=======
+ void ndisc_send_ns(struct net_device *dev, const struct in6_addr *solicit,
+ 		   const struct in6_addr *daddr, const struct in6_addr *saddr,
+ 		   u64 nonce)
++>>>>>>> adc176c54722 (ipv6 addrconf: Implemented enhanced DAD (RFC7527))
  {
  	struct sk_buff *skb;
  	struct in6_addr addr_buf;
@@@ -687,12 -704,12 +703,20 @@@ static void ndisc_solicit(struct neighb
  				  "%s: trying to ucast probe in NUD_INVALID: %pI6\n",
  				  __func__, target);
  		}
++<<<<<<< HEAD
 +		ndisc_send_ns(dev, neigh, target, target, saddr);
++=======
+ 		ndisc_send_ns(dev, target, target, saddr, 0);
++>>>>>>> adc176c54722 (ipv6 addrconf: Implemented enhanced DAD (RFC7527))
  	} else if ((probes -= NEIGH_VAR(neigh->parms, APP_PROBES)) < 0) {
  		neigh_app_ns(neigh);
  	} else {
  		addrconf_addr_solict_mult(target, &mcaddr);
++<<<<<<< HEAD
 +		ndisc_send_ns(dev, NULL, target, &mcaddr, saddr);
++=======
+ 		ndisc_send_ns(dev, target, &mcaddr, saddr, 0);
++>>>>>>> adc176c54722 (ipv6 addrconf: Implemented enhanced DAD (RFC7527))
  	}
  }
  
@@@ -785,9 -805,18 +812,18 @@@ static void ndisc_recv_ns(struct sk_buf
  
  	ifp = ipv6_get_ifaddr(dev_net(dev), &msg->target, dev, 1);
  	if (ifp) {
 -have_ifp:
 +
  		if (ifp->flags & (IFA_F_TENTATIVE|IFA_F_OPTIMISTIC)) {
  			if (dad) {
+ 				if (nonce != 0 && ifp->dad_nonce == nonce) {
+ 					u8 *np = (u8 *)&nonce;
+ 					/* Matching nonce if looped back */
+ 					ND_PRINTK(2, notice,
+ 						  "%s: IPv6 DAD loopback for address %pI6c nonce %pM ignored\n",
+ 						  ifp->idev->dev->name,
+ 						  &ifp->addr, np);
+ 					goto out;
+ 				}
  				/*
  				 * We are colliding with another node
  				 * who is doing DAD
diff --cc net/ipv6/route.c
index 1dd07652351d,aac7818e2e0f..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -569,9 -527,9 +569,13 @@@ static void rt6_probe_deferred(struct w
  		container_of(w, struct __rt6_probe_work, work);
  
  	addrconf_addr_solict_mult(&work->target, &mcaddr);
++<<<<<<< HEAD
 +	ndisc_send_ns(work->dev, NULL, &work->target, &mcaddr, NULL);
++=======
+ 	ndisc_send_ns(work->dev, &work->target, &mcaddr, NULL, 0);
++>>>>>>> adc176c54722 (ipv6 addrconf: Implemented enhanced DAD (RFC7527))
  	dev_put(work->dev);
 -	kfree(work);
 +	kfree(w);
  }
  
  static void rt6_probe(struct rt6_info *rt)
* Unmerged path Documentation/networking/ip-sysctl.txt
* Unmerged path include/linux/ipv6.h
diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index fc6afb14cb10..94f524a3c118 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -58,6 +58,7 @@ struct inet6_ifaddr {
 	__u8			stable_privacy_retry;
 
 	__u16			scope;
+	__u64			dad_nonce;
 
 	unsigned long		cstamp;	/* created timestamp */
 	unsigned long		tstamp; /* updated timestamp */
* Unmerged path include/net/ndisc.h
* Unmerged path include/uapi/linux/ipv6.h
* Unmerged path net/ipv6/addrconf.c
* Unmerged path net/ipv6/ndisc.c
* Unmerged path net/ipv6/route.c
