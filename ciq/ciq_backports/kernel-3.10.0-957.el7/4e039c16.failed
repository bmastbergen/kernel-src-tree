ixgbe: Fix limitations on macvlan so we can support up to 63 offloaded devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Alexander Duyck <alexander.h.duyck@intel.com>
commit 4e039c1675d4ecfb8ef25a20ac686b38490b36fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4e039c16.failed

This change is a fix of the macvlan offload so that we correctly handle
macvlan offloaded devices. Specifically we were configuring our limits based
on the assumption that we were going to max out the RSS indices for every
mode. As a result when we went to 15 or more macvlan interfaces we were
forced into the 2 queue RSS mode on VFs even though they could have still
supported 4.

This change splits the logic up so that we limit either the total number of
macvlan instances if DCB is enabled, or limit the number of RSS queues used
per macvlan (instead of per pool) if SR-IOV is enabled. By doing this we
can make best use of the part.

In addition I have increased the maximum number of supported interfaces to
63 with one queue per offloaded interface as this more closely reflects the
actual values supported by the interface.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 4e039c1675d4ecfb8ef25a20ac686b38490b36fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 6af8bd8690a7,144674c6c293..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -9554,6 -9801,8 +9548,11 @@@ static void *ixgbe_fwd_add(struct net_d
  	struct ixgbe_fwd_adapter *fwd_adapter = NULL;
  	struct ixgbe_adapter *adapter = netdev_priv(pdev);
  	int used_pools = adapter->num_vfs + adapter->num_rx_pools;
++<<<<<<< HEAD
++=======
+ 	int tcs = netdev_get_num_tc(pdev) ? : 1;
+ 	unsigned int limit;
++>>>>>>> 4e039c1675d4 (ixgbe: Fix limitations on macvlan so we can support up to 63 offloaded devices)
  	int pool, err;
  
  	/* Hardware has a limited number of available pools. Each VF, and the
@@@ -9582,9 -9837,9 +9581,15 @@@
  	if (!fwd_adapter)
  		return ERR_PTR(-ENOMEM);
  
++<<<<<<< HEAD
 +	pool = find_first_zero_bit(&adapter->fwd_bitmask, 32);
 +	adapter->num_rx_pools++;
 +	set_bit(pool, &adapter->fwd_bitmask);
++=======
+ 	pool = find_first_zero_bit(adapter->fwd_bitmask, adapter->num_rx_pools);
+ 	set_bit(pool, adapter->fwd_bitmask);
+ 	limit = find_last_bit(adapter->fwd_bitmask, adapter->num_rx_pools + 1);
++>>>>>>> 4e039c1675d4 (ixgbe: Fix limitations on macvlan so we can support up to 63 offloaded devices)
  
  	/* Enable VMDq flag so device will be set in VM mode */
  	adapter->flags |= IXGBE_FLAG_VMDQ_ENABLED | IXGBE_FLAG_SRIOV_ENABLED;
@@@ -9610,8 -9865,7 +9615,12 @@@ fwd_add_err
  	/* unwind counter and free adapter struct */
  	netdev_info(pdev,
  		    "%s: dfwd hardware acceleration failed\n", vdev->name);
++<<<<<<< HEAD
 +	clear_bit(pool, &adapter->fwd_bitmask);
 +	adapter->num_rx_pools--;
++=======
+ 	clear_bit(pool, adapter->fwd_bitmask);
++>>>>>>> 4e039c1675d4 (ixgbe: Fix limitations on macvlan so we can support up to 63 offloaded devices)
  	kfree(fwd_adapter);
  	return ERR_PTR(err);
  }
@@@ -9620,11 -9874,12 +9629,18 @@@ static void ixgbe_fwd_del(struct net_de
  {
  	struct ixgbe_fwd_adapter *fwd_adapter = priv;
  	struct ixgbe_adapter *adapter = fwd_adapter->real_adapter;
 -	unsigned int limit;
  
++<<<<<<< HEAD
 +	clear_bit(fwd_adapter->pool, &adapter->fwd_bitmask);
 +	adapter->num_rx_pools--;
 +
 +	adapter->ring_feature[RING_F_VMDQ].limit = adapter->num_rx_pools;
++=======
+ 	clear_bit(fwd_adapter->pool, adapter->fwd_bitmask);
+ 
+ 	limit = find_last_bit(adapter->fwd_bitmask, adapter->num_rx_pools);
+ 	adapter->ring_feature[RING_F_VMDQ].limit = limit + 1;
++>>>>>>> 4e039c1675d4 (ixgbe: Fix limitations on macvlan so we can support up to 63 offloaded devices)
  	ixgbe_fwd_ring_down(fwd_adapter->netdev, fwd_adapter);
  
  	/* go back to full RSS if we're done with our VMQs */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe.h b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
index 02c23434b3b1..cd66dcd27b80 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
@@ -382,8 +382,7 @@ enum ixgbe_ring_f_enum {
 #define MAX_TX_QUEUES			(IXGBE_MAX_FDIR_INDICES + 1)
 #define IXGBE_MAX_L2A_QUEUES		4
 #define IXGBE_BAD_L2A_QUEUE		3
-#define IXGBE_MAX_MACVLANS		31
-#define IXGBE_MAX_DCBMACVLANS		8
+#define IXGBE_MAX_MACVLANS		63
 
 struct ixgbe_ring_feature {
 	u16 limit;	/* upper limit on feature indices */
@@ -747,7 +746,8 @@ struct ixgbe_adapter {
 #endif /*CONFIG_DEBUG_FS*/
 
 	u8 default_up;
-	unsigned long fwd_bitmask; /* Bitmask indicating in use pools */
+	/* Bitmask indicating in use pools */
+	DECLARE_BITMAP(fwd_bitmask, IXGBE_MAX_MACVLANS + 1);
 
 #define IXGBE_MAX_LINK_HANDLE 10
 	struct ixgbe_jump_table *jump_tables[IXGBE_MAX_LINK_HANDLE];
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c
index 35c1fe8a4430..69addff10ac1 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c
@@ -343,6 +343,9 @@ static bool ixgbe_set_dcb_sriov_queues(struct ixgbe_adapter *adapter)
 	if (!(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))
 		return false;
 
+	/* limit VMDq instances on the PF by number of Tx queues */
+	vmdq_i = min_t(u16, vmdq_i, MAX_TX_QUEUES / tcs);
+
 	/* Add starting offset to total pool count */
 	vmdq_i += adapter->ring_feature[RING_F_VMDQ].offset;
 
@@ -503,12 +506,14 @@ static bool ixgbe_set_sriov_queues(struct ixgbe_adapter *adapter)
 #ifdef IXGBE_FCOE
 	u16 fcoe_i = 0;
 #endif
-	bool pools = (find_first_zero_bit(&adapter->fwd_bitmask, 32) > 1);
 
 	/* only proceed if SR-IOV is enabled */
 	if (!(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))
 		return false;
 
+	/* limit l2fwd RSS based on total Tx queue limit */
+	rss_i = min_t(u16, rss_i, MAX_TX_QUEUES / vmdq_i);
+
 	/* Add starting offset to total pool count */
 	vmdq_i += adapter->ring_feature[RING_F_VMDQ].offset;
 
@@ -516,7 +521,7 @@ static bool ixgbe_set_sriov_queues(struct ixgbe_adapter *adapter)
 	vmdq_i = min_t(u16, IXGBE_MAX_VMDQ_INDICES, vmdq_i);
 
 	/* 64 pool mode with 2 queues per pool */
-	if ((vmdq_i > 32) || (vmdq_i > 16 && pools)) {
+	if (vmdq_i > 32) {
 		vmdq_m = IXGBE_82599_VMDQ_2Q_MASK;
 		rss_m = IXGBE_RSS_2Q_MASK;
 		rss_i = min_t(u16, rss_i, 2);
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
index 6dab89fbd778..3cc15de9a5f0 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
@@ -293,10 +293,9 @@ static int ixgbe_pci_sriov_enable(struct pci_dev *dev, int num_vfs)
 {
 #ifdef CONFIG_PCI_IOV
 	struct ixgbe_adapter *adapter = pci_get_drvdata(dev);
-	int err = 0;
-	u8 num_tc;
-	int i;
 	int pre_existing_vfs = pci_num_vf(dev);
+	int err = 0, num_rx_pools, i, limit;
+	u8 num_tc;
 
 	if (pre_existing_vfs && pre_existing_vfs != num_vfs)
 		err = ixgbe_disable_sriov(adapter);
@@ -319,22 +318,14 @@ static int ixgbe_pci_sriov_enable(struct pci_dev *dev, int num_vfs)
 	 * other values out of range.
 	 */
 	num_tc = netdev_get_num_tc(adapter->netdev);
+	num_rx_pools = adapter->num_rx_pools;
+	limit = (num_tc > 4) ? IXGBE_MAX_VFS_8TC :
+		(num_tc > 1) ? IXGBE_MAX_VFS_4TC : IXGBE_MAX_VFS_1TC;
 
-	if (num_tc > 4) {
-		if ((num_vfs + adapter->num_rx_pools) > IXGBE_MAX_VFS_8TC) {
-			e_dev_err("Currently the device is configured with %d TCs, Creating more than %d VFs is not allowed\n", num_tc, IXGBE_MAX_VFS_8TC);
-			return -EPERM;
-		}
-	} else if ((num_tc > 1) && (num_tc <= 4)) {
-		if ((num_vfs + adapter->num_rx_pools) > IXGBE_MAX_VFS_4TC) {
-			e_dev_err("Currently the device is configured with %d TCs, Creating more than %d VFs is not allowed\n", num_tc, IXGBE_MAX_VFS_4TC);
-			return -EPERM;
-		}
-	} else {
-		if ((num_vfs + adapter->num_rx_pools) > IXGBE_MAX_VFS_1TC) {
-			e_dev_err("Currently the device is configured with %d TCs, Creating more than %d VFs is not allowed\n", num_tc, IXGBE_MAX_VFS_1TC);
-			return -EPERM;
-		}
+	if (num_vfs > (limit - num_rx_pools)) {
+		e_dev_err("Currently configured with %d TCs, and %d offloaded macvlans. Creating more than %d VFs is not allowed\n",
+			  num_tc, num_rx_pools - 1, limit - num_rx_pools);
+		return -EPERM;
 	}
 
 	err = __ixgbe_enable_sriov(adapter, num_vfs);
