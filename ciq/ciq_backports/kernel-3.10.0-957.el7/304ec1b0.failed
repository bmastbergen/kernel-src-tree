x86/uaccess: Use __uaccess_begin_nospec() and uaccess_try_nospec

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] uaccess: Use __uaccess_begin_nospec() and uaccess_try_nospec (Josh Poimboeuf) [1572653]
Rebuild_FUZZ: 96.77%
commit-author Dan Williams <dan.j.williams@intel.com>
commit 304ec1b050310548db33063e567123fae8fd0301
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/304ec1b0.failed

Quoting Linus:

    I do think that it would be a good idea to very expressly document
    the fact that it's not that the user access itself is unsafe. I do
    agree that things like "get_user()" want to be protected, but not
    because of any direct bugs or problems with get_user() and friends,
    but simply because get_user() is an excellent source of a pointer
    that is obviously controlled from a potentially attacking user
    space. So it's a prime candidate for then finding _subsequent_
    accesses that can then be used to perturb the cache.

__uaccess_begin_nospec() covers __get_user() and copy_from_iter() where the
limit check is far away from the user pointer de-reference. In those cases
a barrier_nospec() prevents speculation with a potential pointer to
privileged memory. uaccess_try_nospec covers get_user_try.

	Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
	Suggested-by: Andi Kleen <ak@linux.intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-arch@vger.kernel.org
	Cc: Kees Cook <keescook@chromium.org>
	Cc: kernel-hardening@lists.openwall.com
	Cc: gregkh@linuxfoundation.org
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: alan@linux.intel.com
Link: https://lkml.kernel.org/r/151727416953.33451.10508284228526170604.stgit@dwillia2-desk3.amr.corp.intel.com

(cherry picked from commit 304ec1b050310548db33063e567123fae8fd0301)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/uaccess.h
#	arch/x86/include/asm/uaccess_32.h
#	arch/x86/include/asm/uaccess_64.h
diff --cc arch/x86/include/asm/uaccess.h
index 46d1d9482490,aae77eb8491c..000000000000
--- a/arch/x86/include/asm/uaccess.h
+++ b/arch/x86/include/asm/uaccess.h
@@@ -404,10 -449,12 +404,15 @@@ do {									
  #define __get_user_nocheck(x, ptr, size)				\
  ({									\
  	int __gu_err;							\
++<<<<<<< HEAD
 +	unsigned long __gu_val;						\
++=======
+ 	__inttype(*(ptr)) __gu_val;					\
+ 	__uaccess_begin_nospec();					\
++>>>>>>> 304ec1b05031 (x86/uaccess: Use __uaccess_begin_nospec() and uaccess_try_nospec)
  	__get_user_size(__gu_val, (ptr), (size), __gu_err, -EFAULT);	\
 -	__uaccess_end();						\
  	(x) = (__force __typeof__(*(ptr)))__gu_val;			\
 -	__builtin_expect(__gu_err, 0);					\
 +	__gu_err;							\
  })
  
  /* FIXME: this hack is definitely wrong -AK */
@@@ -542,6 -591,7 +547,10 @@@ extern void __cmpxchg_wrong_size(void
  	__typeof__(ptr) __uval = (uval);				\
  	__typeof__(*(ptr)) __old = (old);				\
  	__typeof__(*(ptr)) __new = (new);				\
++<<<<<<< HEAD
++=======
+ 	__uaccess_begin_nospec();					\
++>>>>>>> 304ec1b05031 (x86/uaccess: Use __uaccess_begin_nospec() and uaccess_try_nospec)
  	switch (size) {							\
  	case 1:								\
  	{								\
diff --cc arch/x86/include/asm/uaccess_32.h
index 7f760a9f1f61,ba2dc1930630..000000000000
--- a/arch/x86/include/asm/uaccess_32.h
+++ b/arch/x86/include/asm/uaccess_32.h
@@@ -48,107 -28,25 +48,129 @@@ __copy_to_user_inatomic(void __user *to
  
  		switch (n) {
  		case 1:
++<<<<<<< HEAD
 +			__put_user_size(*(u8 *)from, (u8 __user *)to,
 +					1, ret, 1);
 +			return ret;
 +		case 2:
 +			__put_user_size(*(u16 *)from, (u16 __user *)to,
 +					2, ret, 2);
 +			return ret;
 +		case 4:
 +			__put_user_size(*(u32 *)from, (u32 __user *)to,
 +					4, ret, 4);
++=======
+ 			ret = 0;
+ 			__uaccess_begin_nospec();
+ 			__get_user_asm_nozero(*(u8 *)to, from, ret,
+ 					      "b", "b", "=q", 1);
+ 			__uaccess_end();
+ 			return ret;
+ 		case 2:
+ 			ret = 0;
+ 			__uaccess_begin_nospec();
+ 			__get_user_asm_nozero(*(u16 *)to, from, ret,
+ 					      "w", "w", "=r", 2);
+ 			__uaccess_end();
+ 			return ret;
+ 		case 4:
+ 			ret = 0;
+ 			__uaccess_begin_nospec();
+ 			__get_user_asm_nozero(*(u32 *)to, from, ret,
+ 					      "l", "k", "=r", 4);
+ 			__uaccess_end();
++>>>>>>> 304ec1b05031 (x86/uaccess: Use __uaccess_begin_nospec() and uaccess_try_nospec)
 +			return ret;
 +		}
 +	}
 +	return __copy_to_user_ll(to, from, n);
 +}
 +
 +/**
 + * __copy_to_user: - Copy a block of data into user space, with less checking.
 + * @to:   Destination address, in user space.
 + * @from: Source address, in kernel space.
 + * @n:    Number of bytes to copy.
 + *
 + * Context: User context only.  This function may sleep.
 + *
 + * Copy data from kernel space to user space.  Caller must check
 + * the specified block with access_ok() before calling this function.
 + *
 + * Returns number of bytes that could not be copied.
 + * On success, this will be zero.
 + */
 +static __always_inline unsigned long __must_check
 +__copy_to_user(void __user *to, const void *from, unsigned long n)
 +{
 +	might_fault();
 +	return __copy_to_user_inatomic(to, from, n);
 +}
 +
 +static __always_inline unsigned long
 +__copy_from_user_inatomic(void *to, const void __user *from, unsigned long n)
 +{
 +	/* Avoid zeroing the tail if the copy fails..
 +	 * If 'n' is constant and 1, 2, or 4, we do still zero on a failure,
 +	 * but as the zeroing behaviour is only significant when n is not
 +	 * constant, that shouldn't be a problem.
 +	 */
 +	if (__builtin_constant_p(n)) {
 +		unsigned long ret;
 +
 +		switch (n) {
 +		case 1:
 +			__get_user_size(*(u8 *)to, from, 1, ret, 1);
 +			return ret;
 +		case 2:
 +			__get_user_size(*(u16 *)to, from, 2, ret, 2);
 +			return ret;
 +		case 4:
 +			__get_user_size(*(u32 *)to, from, 4, ret, 4);
 +			return ret;
 +		}
 +	}
 +	return __copy_from_user_ll_nozero(to, from, n);
 +}
 +
 +/**
 + * __copy_from_user: - Copy a block of data from user space, with less checking.
 + * @to:   Destination address, in kernel space.
 + * @from: Source address, in user space.
 + * @n:    Number of bytes to copy.
 + *
 + * Context: User context only.  This function may sleep.
 + *
 + * Copy data from user space to kernel space.  Caller must check
 + * the specified block with access_ok() before calling this function.
 + *
 + * Returns number of bytes that could not be copied.
 + * On success, this will be zero.
 + *
 + * If some data could not be copied, this function will pad the copied
 + * data to the requested size using zero bytes.
 + *
 + * An alternate version - __copy_from_user_inatomic() - may be called from
 + * atomic context and will fail rather than sleep.  In this case the
 + * uncopied bytes will *NOT* be padded with zeros.  See fs/filemap.h
 + * for explanation of why this is needed.
 + */
 +static __always_inline unsigned long
 +__copy_from_user(void *to, const void __user *from, unsigned long n)
 +{
 +	might_fault();
 +	if (__builtin_constant_p(n)) {
 +		unsigned long ret;
 +
 +		switch (n) {
 +		case 1:
 +			__get_user_size(*(u8 *)to, from, 1, ret, 1);
 +			return ret;
 +		case 2:
 +			__get_user_size(*(u16 *)to, from, 2, ret, 2);
 +			return ret;
 +		case 4:
 +			__get_user_size(*(u32 *)to, from, 4, ret, 4);
  			return ret;
  		}
  	}
diff --cc arch/x86/include/asm/uaccess_64.h
index 109207779f98,62546b3a398e..000000000000
--- a/arch/x86/include/asm/uaccess_64.h
+++ b/arch/x86/include/asm/uaccess_64.h
@@@ -85,35 -54,49 +85,69 @@@ int __copy_from_user(void *dst, const v
  	if (!__builtin_constant_p(size))
  		return copy_user_generic(dst, (__force void *)src, size);
  	switch (size) {
++<<<<<<< HEAD
 +	case 1:__get_user_asm(*(u8 *)dst, (u8 __user *)src,
++=======
+ 	case 1:
+ 		__uaccess_begin_nospec();
+ 		__get_user_asm_nozero(*(u8 *)dst, (u8 __user *)src,
++>>>>>>> 304ec1b05031 (x86/uaccess: Use __uaccess_begin_nospec() and uaccess_try_nospec)
  			      ret, "b", "b", "=q", 1);
 -		__uaccess_end();
  		return ret;
++<<<<<<< HEAD
 +	case 2:__get_user_asm(*(u16 *)dst, (u16 __user *)src,
++=======
+ 	case 2:
+ 		__uaccess_begin_nospec();
+ 		__get_user_asm_nozero(*(u16 *)dst, (u16 __user *)src,
++>>>>>>> 304ec1b05031 (x86/uaccess: Use __uaccess_begin_nospec() and uaccess_try_nospec)
  			      ret, "w", "w", "=r", 2);
 -		__uaccess_end();
  		return ret;
++<<<<<<< HEAD
 +	case 4:__get_user_asm(*(u32 *)dst, (u32 __user *)src,
++=======
+ 	case 4:
+ 		__uaccess_begin_nospec();
+ 		__get_user_asm_nozero(*(u32 *)dst, (u32 __user *)src,
++>>>>>>> 304ec1b05031 (x86/uaccess: Use __uaccess_begin_nospec() and uaccess_try_nospec)
  			      ret, "l", "k", "=r", 4);
 -		__uaccess_end();
  		return ret;
++<<<<<<< HEAD
 +	case 8:__get_user_asm(*(u64 *)dst, (u64 __user *)src,
++=======
+ 	case 8:
+ 		__uaccess_begin_nospec();
+ 		__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,
++>>>>>>> 304ec1b05031 (x86/uaccess: Use __uaccess_begin_nospec() and uaccess_try_nospec)
  			      ret, "q", "", "=r", 8);
 -		__uaccess_end();
  		return ret;
  	case 10:
++<<<<<<< HEAD
 +		__get_user_asm(*(u64 *)dst, (u64 __user *)src,
++=======
+ 		__uaccess_begin_nospec();
+ 		__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,
++>>>>>>> 304ec1b05031 (x86/uaccess: Use __uaccess_begin_nospec() and uaccess_try_nospec)
  			       ret, "q", "", "=r", 10);
 -		if (likely(!ret))
 -			__get_user_asm_nozero(*(u16 *)(8 + (char *)dst),
 -				       (u16 __user *)(8 + (char __user *)src),
 -				       ret, "w", "w", "=r", 2);
 -		__uaccess_end();
 +		if (unlikely(ret))
 +			return ret;
 +		__get_user_asm(*(u16 *)(8 + (char *)dst),
 +			       (u16 __user *)(8 + (char __user *)src),
 +			       ret, "w", "w", "=r", 2);
  		return ret;
  	case 16:
++<<<<<<< HEAD
 +		__get_user_asm(*(u64 *)dst, (u64 __user *)src,
++=======
+ 		__uaccess_begin_nospec();
+ 		__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,
++>>>>>>> 304ec1b05031 (x86/uaccess: Use __uaccess_begin_nospec() and uaccess_try_nospec)
  			       ret, "q", "", "=r", 16);
 -		if (likely(!ret))
 -			__get_user_asm_nozero(*(u64 *)(8 + (char *)dst),
 -				       (u64 __user *)(8 + (char __user *)src),
 -				       ret, "q", "", "=r", 8);
 -		__uaccess_end();
 +		if (unlikely(ret))
 +			return ret;
 +		__get_user_asm(*(u64 *)(8 + (char *)dst),
 +			       (u64 __user *)(8 + (char __user *)src),
 +			       ret, "q", "", "=r", 8);
  		return ret;
  	default:
  		return copy_user_generic(dst, (__force void *)src, size);
* Unmerged path arch/x86/include/asm/uaccess.h
* Unmerged path arch/x86/include/asm/uaccess_32.h
* Unmerged path arch/x86/include/asm/uaccess_64.h
diff --git a/arch/x86/lib/usercopy_32.c b/arch/x86/lib/usercopy_32.c
index d43e31533941..cc4d9d39541a 100644
--- a/arch/x86/lib/usercopy_32.c
+++ b/arch/x86/lib/usercopy_32.c
@@ -570,7 +570,7 @@ do {									\
 unsigned long __copy_to_user_ll(void __user *to, const void *from,
 				unsigned long n)
 {
-	__uaccess_begin();
+	__uaccess_begin_nospec();
 	if (movsl_is_ok(to, from, n))
 		__copy_user(to, from, n);
 	else
@@ -627,7 +627,7 @@ EXPORT_SYMBOL(__copy_from_user_ll_nocache);
 unsigned long __copy_from_user_ll_nocache_nozero(void *to, const void __user *from,
 					unsigned long n)
 {
-	__uaccess_begin();
+	__uaccess_begin_nospec();
 #ifdef CONFIG_X86_INTEL_USERCOPY
 	if (n > 64 && cpu_has_xmm2)
 		n = __copy_user_intel_nocache(to, from, n);
