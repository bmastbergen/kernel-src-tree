mmc: block: Delete mmc_access_rpmb()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] block: Delete mmc_access_rpmb() (Gopal Tiwari) [1456570]
Rebuild_FUZZ: 92.54%
commit-author Linus Walleij <linus.walleij@linaro.org>
commit 14f4ca7e4d2825f9f71e22905ae177b899959f1d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/14f4ca7e.failed

This function is used by the block layer queue to bail out of
requests if the current request is towards an RPMB
"block device".

This was done to avoid boot time scanning of this "block
device" which was never really a block device, thus duct-taping
over the fact that it was badly engineered.

This problem is now gone as we removed the offending RPMB block
device in another patch and replaced it with a character
device.

	Cc: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 14f4ca7e4d2825f9f71e22905ae177b899959f1d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/block.c
#	drivers/mmc/core/queue.c
diff --cc drivers/mmc/core/block.c
index bf17147e2808,ab9c780df750..000000000000
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@@ -1142,19 -1203,71 +1142,87 @@@ static inline void mmc_blk_reset_succes
  	md->reset_done &= ~type;
  }
  
++<<<<<<< HEAD
 +int mmc_access_rpmb(struct mmc_queue *mq)
 +{
 +	struct mmc_blk_data *md = mq->blkdata;
 +	/*
 +	 * If this is a RPMB partition access, return ture
 +	 */
 +	if (md && md->part_type == EXT_CSD_PART_CONFIG_ACC_RPMB)
 +		return true;
 +
 +	return false;
 +}
 +
 +static int mmc_blk_issue_discard_rq(struct mmc_queue *mq, struct request *req)
++=======
+ /*
+  * The non-block commands come back from the block layer after it queued it and
+  * processed it with all other requests and then they get issued in this
+  * function.
+  */
+ static void mmc_blk_issue_drv_op(struct mmc_queue *mq, struct request *req)
+ {
+ 	struct mmc_queue_req *mq_rq;
+ 	struct mmc_card *card = mq->card;
+ 	struct mmc_blk_data *md = mq->blkdata;
+ 	struct mmc_blk_ioc_data **idata;
+ 	bool rpmb_ioctl;
+ 	u8 **ext_csd;
+ 	u32 status;
+ 	int ret;
+ 	int i;
+ 
+ 	mq_rq = req_to_mmc_queue_req(req);
+ 	rpmb_ioctl = (mq_rq->drv_op == MMC_DRV_OP_IOCTL_RPMB);
+ 
+ 	switch (mq_rq->drv_op) {
+ 	case MMC_DRV_OP_IOCTL:
+ 	case MMC_DRV_OP_IOCTL_RPMB:
+ 		idata = mq_rq->drv_op_data;
+ 		for (i = 0, ret = 0; i < mq_rq->ioc_count; i++) {
+ 			ret = __mmc_blk_ioctl_cmd(card, md, idata[i]);
+ 			if (ret)
+ 				break;
+ 		}
+ 		/* Always switch back to main area after RPMB access */
+ 		if (rpmb_ioctl)
+ 			mmc_blk_part_switch(card, 0);
+ 		break;
+ 	case MMC_DRV_OP_BOOT_WP:
+ 		ret = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_BOOT_WP,
+ 				 card->ext_csd.boot_ro_lock |
+ 				 EXT_CSD_BOOT_WP_B_PWR_WP_EN,
+ 				 card->ext_csd.part_time);
+ 		if (ret)
+ 			pr_err("%s: Locking boot partition ro until next power on failed: %d\n",
+ 			       md->disk->disk_name, ret);
+ 		else
+ 			card->ext_csd.boot_ro_lock |=
+ 				EXT_CSD_BOOT_WP_B_PWR_WP_EN;
+ 		break;
+ 	case MMC_DRV_OP_GET_CARD_STATUS:
+ 		ret = mmc_send_status(card, &status);
+ 		if (!ret)
+ 			ret = status;
+ 		break;
+ 	case MMC_DRV_OP_GET_EXT_CSD:
+ 		ext_csd = mq_rq->drv_op_data;
+ 		ret = mmc_get_ext_csd(card, ext_csd);
+ 		break;
+ 	default:
+ 		pr_err("%s: unknown driver specific operation\n",
+ 		       md->disk->disk_name);
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 	mq_rq->drv_op_result = ret;
+ 	blk_end_request_all(req, ret ? BLK_STS_IOERR : BLK_STS_OK);
+ }
+ 
+ static void mmc_blk_issue_discard_rq(struct mmc_queue *mq, struct request *req)
++>>>>>>> 14f4ca7e4d28 (mmc: block: Delete mmc_access_rpmb())
  {
  	struct mmc_blk_data *md = mq->blkdata;
  	struct mmc_card *card = md->queue.card;
diff --cc drivers/mmc/core/queue.c
index b0ae9d688e28,f74f9ef460cc..000000000000
--- a/drivers/mmc/core/queue.c
+++ b/drivers/mmc/core/queue.c
@@@ -31,18 -30,10 +31,22 @@@ static int mmc_prep_request(struct requ
  {
  	struct mmc_queue *mq = q->queuedata;
  
++<<<<<<< HEAD
 +	/*
 +	 * We only like normal block requests and discards.
 +	 */
 +	if (req->cmd_type != REQ_TYPE_FS && !(req->cmd_flags & REQ_DISCARD)) {
 +		blk_dump_rq_flags(req, "MMC bad request");
 +		return BLKPREP_KILL;
 +	}
 +
 +	if (mq && (mmc_card_removed(mq->card) || mmc_access_rpmb(mq)))
++=======
+ 	if (mq && mmc_card_removed(mq->card))
++>>>>>>> 14f4ca7e4d28 (mmc: block: Delete mmc_access_rpmb())
  		return BLKPREP_KILL;
  
 -	req->rq_flags |= RQF_DONTPREP;
 +	req->cmd_flags |= REQ_DONTPREP;
  
  	return BLKPREP_OK;
  }
* Unmerged path drivers/mmc/core/block.c
* Unmerged path drivers/mmc/core/queue.c
diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index a61f88199573..8a81a729d3fa 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -53,6 +53,4 @@ extern unsigned int mmc_queue_map_sg(struct mmc_queue *,
 extern void mmc_queue_bounce_pre(struct mmc_queue_req *);
 extern void mmc_queue_bounce_post(struct mmc_queue_req *);
 
-extern int mmc_access_rpmb(struct mmc_queue *);
-
 #endif
