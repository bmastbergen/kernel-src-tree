scsi: qla2xxx: Fix crashes in qla2x00_probe_one on probe failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Fix crashes in qla2x00_probe_one on probe failure (Himanshu Madhani) [1547714]
Rebuild_FUZZ: 95.08%
commit-author Bill Kuzeja <William.Kuzeja@stratus.com>
commit 6a2cf8d3663e13e19af636c2a8d92e766261dc45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6a2cf8d3.failed

Because of the shifting around of code in qla2x00_probe_one recently,
failures during adapter initialization can lead to problems, i.e. NULL
pointer crashes and doubly freed data structures which cause eventual
panics.

This V2 version makes the relevant memory free routines idempotent, so
repeat calls won't cause any harm. I also removed the problematic
probe_init_failed exit point as it is not needed.

Fixes: d64d6c5671db ("scsi: qla2xxx: Fix NULL pointer crash due to probe failure")
	Signed-off-by: Bill Kuzeja <william.kuzeja@stratus.com>
	Acked-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 6a2cf8d3663e13e19af636c2a8d92e766261dc45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 20a870bdd02c,5c5dcca4d1da..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -1701,69 -1730,72 +1708,94 @@@ qla2x00_abort_all_cmds(scsi_qla_host_t 
  	struct qla_tgt_cmd *cmd;
  	uint8_t trace = 0;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&ha->hardware_lock, flags);
 +	for (que = 0; que < ha->max_req_queues; que++) {
 +		req = ha->req_q_map[que];
 +		if (!req)
 +			continue;
 +		if (!req->outstanding_cmds)
 +			continue;
 +		for (cnt = 1; cnt < req->num_outstanding_cmds; cnt++) {
 +			sp = req->outstanding_cmds[cnt];
 +			if (sp) {
 +				req->outstanding_cmds[cnt] = NULL;
 +				if (sp->cmd_type == TYPE_SRB) {
++=======
+ 	if (!ha->req_q_map)
+ 		return;
+ 	spin_lock_irqsave(qp->qp_lock_ptr, flags);
+ 	req = qp->req;
+ 	for (cnt = 1; cnt < req->num_outstanding_cmds; cnt++) {
+ 		sp = req->outstanding_cmds[cnt];
+ 		if (sp) {
+ 			req->outstanding_cmds[cnt] = NULL;
+ 			if (sp->cmd_type == TYPE_SRB) {
+ 				if (sp->type == SRB_NVME_CMD ||
+ 				    sp->type == SRB_NVME_LS) {
+ 					sp_get(sp);
+ 					spin_unlock_irqrestore(qp->qp_lock_ptr,
+ 					    flags);
+ 					qla_nvme_abort(ha, sp);
+ 					spin_lock_irqsave(qp->qp_lock_ptr,
+ 					    flags);
+ 				} else if (GET_CMD_SP(sp) &&
+ 				    !ha->flags.eeh_busy &&
+ 				    (!test_bit(ABORT_ISP_ACTIVE,
+ 					&vha->dpc_flags)) &&
+ 				    (sp->type == SRB_SCSI_CMD)) {
++>>>>>>> 6a2cf8d3663e (scsi: qla2xxx: Fix crashes in qla2x00_probe_one on probe failure)
  					/*
 -					 * Don't abort commands in
 -					 * adapter during EEH
 -					 * recovery as it's not
 +					 * Don't abort commands in adapter
 +					 * during EEH recovery as it's not
  					 * accessible/responding.
 -					 *
 -					 * Get a reference to the sp
 -					 * and drop the lock. The
 -					 * reference ensures this
 -					 * sp->done() call and not the
 -					 * call in qla2xxx_eh_abort()
 -					 * ends the SCSI command (with
 -					 * result 'res').
  					 */
 -					sp_get(sp);
 -					spin_unlock_irqrestore(qp->qp_lock_ptr,
 -					    flags);
 -					status = qla2xxx_eh_abort(
 -					    GET_CMD_SP(sp));
 -					spin_lock_irqsave(qp->qp_lock_ptr,
 -					    flags);
 -					/*
 -					 * Get rid of extra reference
 -					 * if immediate exit from
 -					 * ql2xxx_eh_abort
 -					 */
 -					if (status == FAILED &&
 -					    (qla2x00_isp_reg_stat(ha)))
 -						atomic_dec(
 -						    &sp->ref_count);
 -				}
 -				sp->done(sp, res);
 -			} else {
 -				if (!vha->hw->tgt.tgt_ops || !tgt ||
 -				    qla_ini_mode_enabled(vha)) {
 -					if (!trace)
 -						ql_dbg(ql_dbg_tgt_mgt,
 -						    vha, 0xf003,
 -						    "HOST-ABORT-HNDLR: dpc_flags=%lx. Target mode disabled\n",
 -						    vha->dpc_flags);
 -					continue;
 +					if (GET_CMD_SP(sp) &&
 +					    !ha->flags.eeh_busy &&
 +					    (!test_bit(ABORT_ISP_ACTIVE,
 +						&vha->dpc_flags)) &&
 +					    (sp->type == SRB_SCSI_CMD)) {
 +						/*
 +						 * Get a reference to the sp
 +						 * and drop the lock. The
 +						 * reference ensures this
 +						 * sp->done() call and not the
 +						 * call in qla2xxx_eh_abort()
 +						 * ends the SCSI command (with
 +						 * result 'res').
 +						 */
 +						sp_get(sp);
 +						spin_unlock_irqrestore(
 +						    &ha->hardware_lock, flags);
 +						status = qla2xxx_eh_abort(
 +						    GET_CMD_SP(sp));
 +						spin_lock_irqsave(
 +						    &ha->hardware_lock, flags);
 +						/*
 +						 * Get rid of extra reference
 +						 * if immediate exit from
 +						 * ql2xxx_eh_abort
 +						 */
 +						if (status == FAILED &&
 +						    (qla2x00_isp_reg_stat(ha)))
 +							atomic_dec(
 +							    &sp->ref_count);
 +					}
 +					sp->done(sp, res);
 +				} else {
 +					if (!vha->hw->tgt.tgt_ops || !tgt ||
 +					    qla_ini_mode_enabled(vha)) {
 +						if (!trace)
 +							ql_dbg(ql_dbg_tgt_mgt,
 +							    vha, 0xf003,
 +							    "HOST-ABORT-HNDLR: dpc_flags=%lx. Target mode disabled\n",
 +							    vha->dpc_flags);
 +						continue;
 +					}
 +					cmd = (struct qla_tgt_cmd *)sp;
 +					qlt_abort_cmd_on_host_reset(cmd->vha,
 +					    cmd);
  				}
 -				cmd = (struct qla_tgt_cmd *)sp;
 -				qlt_abort_cmd_on_host_reset(cmd->vha, cmd);
  			}
  		}
  	}
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
