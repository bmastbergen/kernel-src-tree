fw_cfg: handle fw_cfg_read_blob() error

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Marc-André Lureau <marcandre.lureau@redhat.com>
commit b1cc4097d15c29725060f86ecec20a1e635a541f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b1cc4097.failed

fw_cfg_read_blob() may fail, but does not return error. This may lead
to surprising behaviours, like populating zero file entries (in
register_file() or during read). Return an error if ACPI locking
failed. Also, the following DMA read/write extension will add more
error paths that should be handled appropriately.

	Signed-off-by: Marc-André Lureau <marcandre.lureau@redhat.com>
	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
(cherry picked from commit b1cc4097d15c29725060f86ecec20a1e635a541f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/qemu_fw_cfg.c
diff --cc drivers/firmware/qemu_fw_cfg.c
index 0d0d7a831ec8,45bfc389b226..000000000000
--- a/drivers/firmware/qemu_fw_cfg.c
+++ b/drivers/firmware/qemu_fw_cfg.c
@@@ -175,8 -78,7 +175,12 @@@ end
  
  /* read chunk of given fw_cfg blob (caller responsible for sanity-check) */
  static ssize_t fw_cfg_read_blob(u16 key,
++<<<<<<< HEAD
 +				void *buf, loff_t pos, size_t count,
 +				bool dma)
++=======
+ 				void *buf, loff_t pos, size_t count)
++>>>>>>> b1cc4097d15c (fw_cfg: handle fw_cfg_read_blob() error)
  {
  	u32 glk = -1U;
  	acpi_status status;
@@@ -218,51 -102,8 +222,55 @@@ end
  	mutex_unlock(&fw_cfg_dev_lock);
  
  	acpi_release_global_lock(glk);
++<<<<<<< HEAD
 +
 +	return ret;
++=======
+ 	return count;
++>>>>>>> b1cc4097d15c (fw_cfg: handle fw_cfg_read_blob() error)
 +}
 +
 +#ifdef CONFIG_CRASH_CORE
 +/* write chunk of given fw_cfg blob (caller responsible for sanity-check) */
 +static ssize_t fw_cfg_write_blob(u16 key,
 +				 void *buf, loff_t pos, size_t count)
 +{
 +	u32 glk = -1U;
 +	acpi_status status;
 +	ssize_t ret = count;
 +
 +	/* If we have ACPI, ensure mutual exclusion against any potential
 +	 * device access by the firmware, e.g. via AML methods:
 +	 */
 +	status = acpi_acquire_global_lock(ACPI_WAIT_FOREVER, &glk);
 +	if (ACPI_FAILURE(status) && status != AE_NOT_CONFIGURED) {
 +		/* Should never get here */
 +		WARN(1, "%s: Failed to lock ACPI!\n", __func__);
 +		memset(buf, 0, count);
 +		return -EINVAL;
 +	}
 +
 +	mutex_lock(&fw_cfg_dev_lock);
 +	if (pos == 0) {
 +		ret = fw_cfg_dma_transfer(buf, count, key << 16
 +					  | FW_CFG_DMA_CTL_SELECT
 +					  | FW_CFG_DMA_CTL_WRITE);
 +	} else {
 +		iowrite16(fw_cfg_sel_endianness(key), fw_cfg_reg_ctrl);
 +		ret = fw_cfg_dma_transfer(NULL, pos, FW_CFG_DMA_CTL_SKIP);
 +		if (ret < 0)
 +			goto end;
 +		ret = fw_cfg_dma_transfer(buf, count, FW_CFG_DMA_CTL_WRITE);
 +	}
 +
 +end:
 +	mutex_unlock(&fw_cfg_dev_lock);
 +
 +	acpi_release_global_lock(glk);
 +
 +	return ret;
  }
 +#endif /* CONFIG_CRASH_CORE */
  
  /* clean up fw_cfg device i/o */
  static void fw_cfg_io_cleanup(void)
@@@ -345,16 -183,10 +353,22 @@@ static int fw_cfg_do_platform_probe(str
  		fw_cfg_reg_data = fw_cfg_dev_base + FW_CFG_DATA_OFF;
  	}
  
 +	if (dma)
 +		fw_cfg_reg_dma = fw_cfg_dev_base + dma->start;
 +#ifdef FW_CFG_DMA_OFF
 +	else
 +		fw_cfg_reg_dma = fw_cfg_dev_base + FW_CFG_DMA_OFF;
 +#endif
 +
  	/* verify fw_cfg device signature */
++<<<<<<< HEAD
 +	fw_cfg_read_blob(FW_CFG_SIGNATURE, sig, 0, FW_CFG_SIG_SIZE, false);
 +	if (memcmp(sig, "QEMU", FW_CFG_SIG_SIZE) != 0) {
++=======
+ 	if (fw_cfg_read_blob(FW_CFG_SIGNATURE, sig,
+ 				0, FW_CFG_SIG_SIZE) < 0 ||
+ 		memcmp(sig, "QEMU", FW_CFG_SIG_SIZE) != 0) {
++>>>>>>> b1cc4097d15c (fw_cfg: handle fw_cfg_read_blob() error)
  		fw_cfg_io_cleanup();
  		return -ENODEV;
  	}
@@@ -529,13 -340,13 +543,17 @@@ static ssize_t fw_cfg_sysfs_read_raw(st
  {
  	struct fw_cfg_sysfs_entry *entry = to_entry(kobj);
  
 -	if (pos > entry->size)
 +	if (pos > entry->f.size)
  		return -EINVAL;
  
 -	if (count > entry->size - pos)
 -		count = entry->size - pos;
 +	if (count > entry->f.size - pos)
 +		count = entry->f.size - pos;
  
++<<<<<<< HEAD
 +	return fw_cfg_read_blob(entry->f.select, buf, pos, count, true);
++=======
+ 	return fw_cfg_read_blob(entry->select, buf, pos, count);
++>>>>>>> b1cc4097d15c (fw_cfg: handle fw_cfg_read_blob() error)
  }
  
  static struct bin_attribute fw_cfg_sysfs_attr_raw = {
@@@ -695,19 -502,24 +713,35 @@@ static int fw_cfg_register_dir_entries(
  	struct fw_cfg_file *dir;
  	size_t dir_size;
  
++<<<<<<< HEAD
 +	fw_cfg_read_blob(FW_CFG_FILE_DIR, &count, 0, sizeof(count), false);
 +	count = be32_to_cpu(count);
++=======
+ 	ret = fw_cfg_read_blob(FW_CFG_FILE_DIR, &files_count,
+ 			0, sizeof(files_count));
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	count = be32_to_cpu(files_count);
++>>>>>>> b1cc4097d15c (fw_cfg: handle fw_cfg_read_blob() error)
  	dir_size = count * sizeof(struct fw_cfg_file);
  
  	dir = kmalloc(dir_size, GFP_KERNEL);
  	if (!dir)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	fw_cfg_read_blob(FW_CFG_FILE_DIR, dir, sizeof(count), dir_size, true);
++=======
+ 	ret = fw_cfg_read_blob(FW_CFG_FILE_DIR, dir,
+ 			sizeof(files_count), dir_size);
+ 	if (ret < 0)
+ 		goto end;
++>>>>>>> b1cc4097d15c (fw_cfg: handle fw_cfg_read_blob() error)
  
  	for (i = 0; i < count; i++) {
 +		dir[i].size = be32_to_cpu(dir[i].size);
 +		dir[i].select = be16_to_cpu(dir[i].select);
  		ret = fw_cfg_register_file(&dir[i]);
  		if (ret)
  			break;
@@@ -753,8 -566,11 +788,16 @@@ static int fw_cfg_sysfs_probe(struct pl
  		goto err_probe;
  
  	/* get revision number, add matching top-level attribute */
++<<<<<<< HEAD
 +	fw_cfg_read_blob(FW_CFG_ID, &fw_cfg_rev, 0, sizeof(fw_cfg_rev), false);
 +	fw_cfg_rev = le32_to_cpu(fw_cfg_rev);
++=======
+ 	err = fw_cfg_read_blob(FW_CFG_ID, &rev, 0, sizeof(rev));
+ 	if (err < 0)
+ 		goto err_probe;
+ 
+ 	fw_cfg_rev = le32_to_cpu(rev);
++>>>>>>> b1cc4097d15c (fw_cfg: handle fw_cfg_read_blob() error)
  	err = sysfs_create_file(fw_cfg_top_ko, &fw_cfg_rev_attr.attr);
  	if (err)
  		goto err_rev;
* Unmerged path drivers/firmware/qemu_fw_cfg.c
