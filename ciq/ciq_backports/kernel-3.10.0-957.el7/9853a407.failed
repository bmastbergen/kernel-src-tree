mm/rmap: use rmap_walk() in page_mkclean()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mm] rmap: use rmap_walk() in page_mkclean() (Rafael Aquini) [1562137]
Rebuild_FUZZ: 96.30%
commit-author Joonsoo Kim <iamjoonsoo.kim@lge.com>
commit 9853a407b97d8d066b5a865173a4859a3e69fd8a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9853a407.failed

Now, we have an infrastructure in rmap_walk() to handle difference from
   variants of rmap traversing functions.

So, just use it in page_mkclean().

In this patch, I change following things.

1. remove some variants of rmap traversing functions.
    cf> page_mkclean_file
2. mechanical change to use rmap_walk() in page_mkclean().

	Signed-off-by: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Reviewed-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Cc: Mel Gorman <mgorman@suse.de>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Hillf Danton <dhillf@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9853a407b97d8d066b5a865173a4859a3e69fd8a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/rmap.c
diff --cc mm/rmap.c
index 794c49685fc7,962e2a1e13a0..000000000000
--- a/mm/rmap.c
+++ b/mm/rmap.c
@@@ -1064,29 -837,20 +1065,26 @@@ static int page_mkclean_one(struct pag
  
  	pte_unmap_unlock(pte, ptl);
  
- 	if (ret)
+ 	if (ret) {
  		mmu_notifier_invalidate_page(mm, address);
+ 		(*cleaned)++;
+ 	}
  out:
- 	return ret;
+ 	return SWAP_AGAIN;
  }
  
- static int page_mkclean_file(struct address_space *mapping, struct page *page)
+ static bool invalid_mkclean_vma(struct vm_area_struct *vma, void *arg)
  {
++<<<<<<< HEAD
 +	pgoff_t pgoff = page_to_pgoff(page);
 +	struct vm_area_struct *vma;
 +	int ret = 0;
++=======
+ 	if (vma->vm_flags & VM_SHARED)
+ 		return 0;
++>>>>>>> 9853a407b97d (mm/rmap: use rmap_walk() in page_mkclean())
  
- 	BUG_ON(PageAnon(page));
- 
- 	mutex_lock(&mapping->i_mmap_mutex);
- 	vma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {
- 		if (vma->vm_flags & VM_SHARED) {
- 			unsigned long address = vma_address(page, vma);
- 			ret += page_mkclean_one(page, vma, address);
- 		}
- 	}
- 	mutex_unlock(&mapping->i_mmap_mutex);
- 	return ret;
+ 	return 1;
  }
  
  int page_mkclean(struct page *page)
* Unmerged path mm/rmap.c
