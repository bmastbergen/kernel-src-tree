mmc: block: break out mmc_blk_rw_start_new()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] block: break out mmc_blk_rw_start_new() (Gopal Tiwari) [1549495]
Rebuild_FUZZ: 93.98%
commit-author Linus Walleij <linus.walleij@linaro.org>
commit efb5a05e70dfa79fe26133be9a239cbca8ea08c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/efb5a05e.failed

As a step toward breaking apart the very complex function
mmc_blk_issue_rw_rq() we break out the code to start a new
request.

	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit efb5a05e70dfa79fe26133be9a239cbca8ea08c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/block.c
diff --cc drivers/mmc/core/block.c
index 485b42441ab6,b60d1fb3a07a..000000000000
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@@ -1591,6 -1598,33 +1591,36 @@@ static int mmc_blk_cmd_err(struct mmc_b
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static void mmc_blk_rw_cmd_abort(struct mmc_card *card, struct request *req)
+ {
+ 	int ret = 1;
+ 
+ 	if (mmc_card_removed(card))
+ 		req->rq_flags |= RQF_QUIET;
+ 	while (ret)
+ 		ret = blk_end_request(req, -EIO,
+ 				      blk_rq_cur_bytes(req));
+ }
+ 
+ static void mmc_blk_rw_start_new(struct mmc_queue *mq, struct mmc_card *card,
+ 				 struct request *req)
+ {
+ 	if (!req)
+ 		return;
+ 
+ 	if (mmc_card_removed(card)) {
+ 		req->rq_flags |= RQF_QUIET;
+ 		blk_end_request_all(req, -EIO);
+ 	} else {
+ 		mmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);
+ 		mmc_start_req(card->host,
+ 			      &mq->mqrq_cur->mmc_active, NULL);
+ 	}
+ }
+ 
++>>>>>>> efb5a05e70df (mmc: block: break out mmc_blk_rw_start_new())
  static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)
  {
  	struct mmc_blk_data *md = mq->blkdata;
@@@ -1730,23 -1764,10 +1760,27 @@@
  	return 1;
  
   cmd_abort:
 -	mmc_blk_rw_cmd_abort(card, req);
 +	if (mmc_card_removed(card))
 +		req->cmd_flags |= REQ_QUIET;
 +	while (ret)
 +		ret = blk_end_request(req, -EIO,
 +				blk_rq_cur_bytes(req));
  
   start_new_req:
++<<<<<<< HEAD
 +	if (rqc) {
 +		if (mmc_card_removed(card)) {
 +			rqc->cmd_flags |= REQ_QUIET;
 +			blk_end_request_all(rqc, -EIO);
 +		} else {
 +			mmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);
 +			mmc_start_req(card->host,
 +				      &mq->mqrq_cur->mmc_active, NULL);
 +		}
 +	}
++=======
+ 	mmc_blk_rw_start_new(mq, card, rqc);
++>>>>>>> efb5a05e70df (mmc: block: break out mmc_blk_rw_start_new())
  
  	return 0;
  }
* Unmerged path drivers/mmc/core/block.c
