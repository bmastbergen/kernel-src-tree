x86/entry/64: Don't use IST entry for #BP stack

jira LE-1907
cve CVE-2018-8897
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] entry/64: Don't use IST entry for #BP stack (Paolo Bonzini) [1567074] {CVE-2018-8897}
Rebuild_FUZZ: 95.56%
commit-author Andy Lutomirski <luto@kernel.org>
commit d8ba61ba58c88d5207c1ba2f7d9a2280e7d03be9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d8ba61ba.failed

There's nothing IST-worthy about #BP/int3.  We don't allow kprobes
in the small handful of places in the kernel that run at CPL0 with
an invalid stack, and 32-bit kernels have used normal interrupt
gates for #BP forever.

Furthermore, we don't allow kprobes in places that have usergs while
in kernel mode, so "paranoid" is also unnecessary.

	Signed-off-by: Andy Lutomirski <luto@kernel.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: stable@vger.kernel.org
(cherry picked from commit d8ba61ba58c88d5207c1ba2f7d9a2280e7d03be9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/entry/entry_64.S
#	arch/x86/kernel/idt.c
#	arch/x86/kernel/traps.c
diff --cc arch/x86/kernel/traps.c
index 72b09235868b,03f3d7695dac..000000000000
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@@ -374,16 -573,12 +374,20 @@@ do_general_protection(struct pt_regs *r
  		pr_cont("\n");
  	}
  
 -	force_sig_info(SIGSEGV, SEND_SIG_PRIV, tsk);
 +	force_sig(SIGSEGV, tsk);
 +exit:
 +	exception_exit(prev_state);
  }
 -NOKPROBE_SYMBOL(do_general_protection);
  
++<<<<<<< HEAD
 +/* May run on IST stack. */
 +dotraplinkage void __kprobes notrace do_int3(struct pt_regs *regs, long error_code)
++=======
+ dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)
++>>>>>>> d8ba61ba58c8 (x86/entry/64: Don't use IST entry for #BP stack)
  {
 +	enum ctx_state prev_state;
 +
  #ifdef CONFIG_DYNAMIC_FTRACE
  	/*
  	 * ftrace must be first, everything else may cause a recursive crash.
@@@ -396,7 -591,15 +400,19 @@@
  	if (poke_int3_handler(regs))
  		return;
  
++<<<<<<< HEAD
 +	prev_state = exception_enter();
++=======
+ 	/*
+ 	 * Use ist_enter despite the fact that we don't use an IST stack.
+ 	 * We can be called from a kprobe in non-CONTEXT_KERNEL kernel
+ 	 * mode or even during context tracking state changes.
+ 	 *
+ 	 * This means that we can't schedule.  That's okay.
+ 	 */
+ 	ist_enter(regs);
+ 	RCU_LOCKDEP_WARN(!rcu_is_watching(), "entry code didn't wake RCU");
++>>>>>>> d8ba61ba58c8 (x86/entry/64: Don't use IST entry for #BP stack)
  #ifdef CONFIG_KGDB_LOW_LEVEL_TRAP
  	if (kgdb_ll_trap(DIE_INT3, "int3", regs, error_code, X86_TRAP_BP,
  				SIGTRAP) == NOTIFY_STOP)
@@@ -407,18 -615,14 +423,25 @@@
  			SIGTRAP) == NOTIFY_STOP)
  		goto exit;
  
++<<<<<<< HEAD
 +	/*
 +	 * Let others (NMI) know that the debug stack is in use
 +	 * as we may switch to the interrupt stack.
 +	 */
 +	debug_stack_usage_inc();
 +	preempt_conditional_sti(regs);
 +	do_trap(X86_TRAP_BP, SIGTRAP, "int3", regs, error_code, NULL);
 +	preempt_conditional_cli(regs);
 +	debug_stack_usage_dec();
++=======
+ 	cond_local_irq_enable(regs);
+ 	do_trap(X86_TRAP_BP, SIGTRAP, "int3", regs, error_code, NULL);
+ 	cond_local_irq_disable(regs);
+ 
++>>>>>>> d8ba61ba58c8 (x86/entry/64: Don't use IST entry for #BP stack)
  exit:
 -	ist_exit(regs);
 +	exception_exit(prev_state);
  }
 -NOKPROBE_SYMBOL(do_int3);
  
  #ifdef CONFIG_X86_64
  /*
* Unmerged path arch/x86/entry/entry_64.S
* Unmerged path arch/x86/kernel/idt.c
* Unmerged path arch/x86/entry/entry_64.S
* Unmerged path arch/x86/kernel/idt.c
* Unmerged path arch/x86/kernel/traps.c
