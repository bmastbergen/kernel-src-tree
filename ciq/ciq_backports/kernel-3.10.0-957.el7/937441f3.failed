libceph, ceph: avoid memory leak when specifying same option several times

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Chengguang Xu <cgxu519@icloud.com>
commit 937441f3a3158d5510ca8cc78a82453f57a96365
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/937441f3.failed

When parsing string option, in order to avoid memory leak we need to
carefully free it first in case of specifying same option several times.

	Signed-off-by: Chengguang Xu <cgxu519@icloud.com>
	Reviewed-by: Ilya Dryomov <idryomov@gmail.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 937441f3a3158d5510ca8cc78a82453f57a96365)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/super.c
diff --cc fs/ceph/super.c
index 6fbf63b32bdd,bfc85b22a190..000000000000
--- a/fs/ceph/super.c
+++ b/fs/ceph/super.c
@@@ -235,6 -232,15 +236,18 @@@ static int parse_fsopt_token(char *c, v
  		if (!fsopt->mds_namespace)
  			return -ENOMEM;
  		break;
++<<<<<<< HEAD
++=======
+ 	case Opt_fscache_uniq:
+ 		kfree(fsopt->fscache_uniq);
+ 		fsopt->fscache_uniq = kstrndup(argstr[0].from,
+ 					       argstr[0].to-argstr[0].from,
+ 					       GFP_KERNEL);
+ 		if (!fsopt->fscache_uniq)
+ 			return -ENOMEM;
+ 		fsopt->flags |= CEPH_MOUNT_OPT_FSCACHE;
+ 		break;
++>>>>>>> 937441f3a315 (libceph, ceph: avoid memory leak when specifying same option several times)
  		/* misc */
  	case Opt_wsize:
  		if (intval < PAGE_SIZE || intval > CEPH_MAX_WRITE_SIZE)
* Unmerged path fs/ceph/super.c
diff --git a/net/ceph/ceph_common.c b/net/ceph/ceph_common.c
index f36a80f8646f..656ed7c34f31 100644
--- a/net/ceph/ceph_common.c
+++ b/net/ceph/ceph_common.c
@@ -418,6 +418,7 @@ ceph_parse_options(char *options, const char *dev_name,
 				opt->flags |= CEPH_OPT_FSID;
 			break;
 		case Opt_name:
+			kfree(opt->name);
 			opt->name = kstrndup(argstr[0].from,
 					      argstr[0].to-argstr[0].from,
 					      GFP_KERNEL);
@@ -427,6 +428,9 @@ ceph_parse_options(char *options, const char *dev_name,
 			}
 			break;
 		case Opt_secret:
+			ceph_crypto_key_destroy(opt->key);
+			kfree(opt->key);
+
 		        opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 			if (!opt->key) {
 				err = -ENOMEM;
@@ -437,6 +441,9 @@ ceph_parse_options(char *options, const char *dev_name,
 				goto out;
 			break;
 		case Opt_key:
+			ceph_crypto_key_destroy(opt->key);
+			kfree(opt->key);
+
 		        opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 			if (!opt->key) {
 				err = -ENOMEM;
