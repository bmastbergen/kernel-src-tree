x86/unwind: Ensure stack grows down

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] unwind: Ensure stack grows down (Josh Poimboeuf) [1609717]
Rebuild_FUZZ: 93.94%
commit-author Josh Poimboeuf <jpoimboe@redhat.com>
commit 24d86f59093b0bcb3756cdf47f2db10ff4e90dbb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/24d86f59.failed

Add a sanity check to ensure the stack only grows down, and print a
warning if the check fails.

	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/20161027131058.tpdffwlqipv7pcd6@treble
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 24d86f59093b0bcb3756cdf47f2db10ff4e90dbb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/unwind_frame.c
diff --cc arch/x86/kernel/unwind_frame.c
index e74cb1cceda2,ea7b7f9a3b9e..000000000000
--- a/arch/x86/kernel/unwind_frame.c
+++ b/arch/x86/kernel/unwind_frame.c
@@@ -15,20 -32,50 +15,56 @@@ unsigned long unwind_get_return_address
  }
  EXPORT_SYMBOL_GPL(unwind_get_return_address);
  
++<<<<<<< HEAD
 +static bool update_stack_state(struct unwind_state *state,
 +			       unsigned long *next_bp)
++=======
+ static size_t regs_size(struct pt_regs *regs)
+ {
+ 	/* x86_32 regs from kernel mode are two words shorter: */
+ 	if (IS_ENABLED(CONFIG_X86_32) && !user_mode(regs))
+ 		return sizeof(*regs) - 2*sizeof(long);
+ 
+ 	return sizeof(*regs);
+ }
+ 
+ static bool is_last_task_frame(struct unwind_state *state)
+ {
+ 	unsigned long bp = (unsigned long)state->bp;
+ 	unsigned long regs = (unsigned long)task_pt_regs(state->task);
+ 
+ 	return bp == regs - FRAME_HEADER_SIZE;
+ }
+ 
+ /*
+  * This determines if the frame pointer actually contains an encoded pointer to
+  * pt_regs on the stack.  See ENCODE_FRAME_POINTER.
+  */
+ static struct pt_regs *decode_frame_pointer(unsigned long *bp)
+ {
+ 	unsigned long regs = (unsigned long)bp;
+ 
+ 	if (!(regs & 0x1))
+ 		return NULL;
+ 
+ 	return (struct pt_regs *)(regs & ~0x1);
+ }
+ 
+ static bool update_stack_state(struct unwind_state *state, void *addr,
+ 			       size_t len)
++>>>>>>> 24d86f59093b (x86/unwind: Ensure stack grows down)
  {
  	struct stack_info *info = &state->stack_info;
 +	unsigned long *addr_p, addr;
  
  	/*
 -	 * If addr isn't on the current stack, switch to the next one.
 +	 * If the next bp isn't on the current stack, switch to the next one.
  	 *
  	 * We may have to traverse multiple stacks to deal with the possibility
 -	 * that 'info->next_sp' could point to an empty stack and 'addr' could
 -	 * be on a subsequent stack.
 +	 * that info->next_sp could point to an empty stack and the next bp
 +	 * could be on a subsequent stack.
  	 */
 -	while (!on_stack(info, addr, len))
 +	while (!on_stack(info, next_bp, FRAME_HEADER_SIZE))
  		if (get_stack_info(info->next_sp, state->task, info,
  				   &state->stack_mask))
  			return false;
@@@ -43,71 -83,107 +79,102 @@@
  	return true;
  }
  
 +extern const unsigned long __start___unwind_unsafe_stack[],
 +			   __stop___unwind_unsafe_stack[];
 +
 +static bool unwind_unsafe(struct unwind_state *state)
 +{
 +	const unsigned long *addr;
 +
 +	for (addr = __start___unwind_unsafe_stack;
 +	     addr < __stop___unwind_unsafe_stack; addr++)
 +		if (*addr == state->ip)
 +			return true;
 +
 +	return false;
 +}
 +extern const unsigned long __start___unwind_end_of_stack[],
 +			   __stop___unwind_end_of_stack[],
 +			   ret_from_fork_nospec_begin[],
 +			   ret_from_fork_nospec_end[];
 +
 +static bool unwind_end(struct unwind_state *state)
 +{
 +	const unsigned long *addr;
 +
 +	for (addr = __start___unwind_end_of_stack;
 +	     addr < __stop___unwind_end_of_stack; addr++)
 +		if (*addr == state->ip)
 +			return true;
 +
 +	/*
 +	 * The UNWIND_END_OF_STACK macro doesn't work after CALL_NOSPEC in all
 +	 * cases (non-retpoline and AMD retpoline), so we need to manually
 +	 * check the end of stack location in ret_from_fork().
 +	 */
 +	if (state->ip > (unsigned long)ret_from_fork_nospec_begin &&
 +	    state->ip <= (unsigned long)ret_from_fork_nospec_end)
 +		return true;
 +
 +	return false;
 +}
 +
  bool unwind_next_frame(struct unwind_state *state)
  {
++<<<<<<< HEAD
 +	unsigned long *next_bp;
++=======
+ 	struct pt_regs *regs;
+ 	unsigned long *next_bp, *next_frame;
+ 	size_t next_len;
+ 	enum stack_type prev_type = state->stack_info.type;
++>>>>>>> 24d86f59093b (x86/unwind: Ensure stack grows down)
  
  	if (unwind_done(state))
  		return false;
  
 -	/* have we reached the end? */
 -	if (state->regs && user_mode(state->regs))
 +	if (unwind_unsafe(state))
 +		state->error = true;
 +
 +	if (unwind_end(state))
  		goto the_end;
  
 -	if (is_last_task_frame(state)) {
 -		regs = task_pt_regs(state->task);
 -
 -		/*
 -		 * kthreads (other than the boot CPU's idle thread) have some
 -		 * partial regs at the end of their stack which were placed
 -		 * there by copy_thread_tls().  But the regs don't have any
 -		 * useful information, so we can skip them.
 -		 *
 -		 * This user_mode() check is slightly broader than a PF_KTHREAD
 -		 * check because it also catches the awkward situation where a
 -		 * newly forked kthread transitions into a user task by calling
 -		 * do_execve(), which eventually clears PF_KTHREAD.
 -		 */
 -		if (!user_mode(regs))
 -			goto the_end;
 -
 -		/*
 -		 * We're almost at the end, but not quite: there's still the
 -		 * syscall regs frame.  Entry code doesn't encode the regs
 -		 * pointer for syscalls, so we have to set it manually.
 -		 */
 -		state->regs = regs;
 -		state->bp = NULL;
 -		return true;
 -	}
 -
 -	/* get the next frame pointer */
 -	if (state->regs)
 -		next_bp = (unsigned long *)state->regs->bp;
 -	else
 -		next_bp = (unsigned long *)*state->bp;
 -
 -	/* is the next frame pointer an encoded pointer to pt_regs? */
 -	regs = decode_frame_pointer(next_bp);
 -	if (regs) {
 -		next_frame = (unsigned long *)regs;
 -		next_len = sizeof(*regs);
 -	} else {
 -		next_frame = next_bp;
 -		next_len = FRAME_HEADER_SIZE;
 -	}
 +	next_bp = (unsigned long *)READ_ONCE(*state->bp);
  
  	/* make sure the next frame's data is accessible */
 -	if (!update_stack_state(state, next_frame, next_len)) {
 -		/*
 -		 * Don't warn on bad regs->bp.  An interrupt in entry code
 -		 * might cause a false positive warning.
 -		 */
 -		if (state->regs)
 -			goto the_end;
 -
 -		goto bad_address;
 +	if (!update_stack_state(state, next_bp)) {
 +		state->error = true;
 +		goto the_end;
  	}
  
+ 	/* Make sure it only unwinds up and doesn't overlap the last frame: */
+ 	if (state->stack_info.type == prev_type) {
+ 		if (state->regs && (void *)next_frame < (void *)state->regs + regs_size(state->regs))
+ 			goto bad_address;
+ 
+ 		if (state->bp && (void *)next_frame < (void *)state->bp + FRAME_HEADER_SIZE)
+ 			goto bad_address;
+ 	}
+ 
  	/* move to the next frame */
 -	if (regs) {
 -		state->regs = regs;
 -		state->bp = NULL;
 -	} else {
 -		state->bp = next_bp;
 -		state->regs = NULL;
 -	}
 -
 +	state->bp = next_bp;
  	return true;
  
++<<<<<<< HEAD
++=======
+ bad_address:
+ 	if (state->regs) {
+ 		printk_deferred_once(KERN_WARNING
+ 			"WARNING: kernel stack regs at %p in %s:%d has bad 'bp' value %p\n",
+ 			state->regs, state->task->comm,
+ 			state->task->pid, next_frame);
+ 	} else {
+ 		printk_deferred_once(KERN_WARNING
+ 			"WARNING: kernel stack frame pointer at %p in %s:%d has bad value %p\n",
+ 			state->bp, state->task->comm,
+ 			state->task->pid, next_frame);
+ 	}
++>>>>>>> 24d86f59093b (x86/unwind: Ensure stack grows down)
  the_end:
  	state->stack_info.type = STACK_TYPE_UNKNOWN;
  	return false;
* Unmerged path arch/x86/kernel/unwind_frame.c
