s390/dasd: remove casts to dasd_*_private

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [s390] dasd: remove casts to dasd_*_private (Hendrik Brueckner) [1519353]
Rebuild_FUZZ: 93.51%
commit-author Sebastian Ott <sebott@linux.vnet.ibm.com>
commit 543691a4e1e040300ce6598a6ce6527d3144e5db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/543691a4.failed

Convert dasd_device.private to be a void pointer to get
rid of a lot of explicit casts.

	Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
	Reviewed-by: Stefan Haberland <sth@linux.vnet.ibm.com>
	Acked-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 543691a4e1e040300ce6598a6ce6527d3144e5db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/block/dasd_eckd.c
#	drivers/s390/block/dasd_int.h
diff --cc drivers/s390/block/dasd_eckd.c
index 92c5aa965aec,75c032dcf173..000000000000
--- a/drivers/s390/block/dasd_eckd.c
+++ b/drivers/s390/block/dasd_eckd.c
@@@ -1069,14 -1043,13 +1058,19 @@@ static int dasd_eckd_read_conf(struct d
  	int rc, path_err, pos;
  	__u8 lpm, opm;
  	struct dasd_eckd_private *private, path_private;
 -	struct dasd_path *path_data;
  	struct dasd_uid *uid;
  	char print_path_uid[60], print_device_uid[60];
 +	struct channel_path_desc *chp_desc;
 +	struct subchannel_id sch_id;
  
++<<<<<<< HEAD
 +	private = (struct dasd_eckd_private *) device->private;
++=======
+ 	private = device->private;
+ 	path_data = &device->path_data;
++>>>>>>> 543691a4e1e0 (s390/dasd: remove casts to dasd_*_private)
  	opm = ccw_device_get_path_mask(device->cdev);
 +	ccw_device_get_schid(device->cdev, &sch_id);
  	conf_data_saved = 0;
  	path_err = 0;
  	/* get configuration data per operational path */
@@@ -1208,41 -1178,9 +1202,41 @@@
  	return path_err;
  }
  
 +static u32 get_fcx_max_data(struct dasd_device *device)
 +{
 +#if defined(CONFIG_64BIT)
 +	struct dasd_eckd_private *private;
 +	int fcx_in_css, fcx_in_gneq, fcx_in_features;
 +	int tpm, mdc;
 +
 +	if (dasd_nofcx)
 +		return 0;
 +
 +	private = (struct dasd_eckd_private *) device->private;
 +	/* is transport mode supported? */
 +	fcx_in_css = css_general_characteristics.fcx;
 +	fcx_in_gneq = private->gneq->reserved2[7] & 0x04;
 +	fcx_in_features = private->features.feature[40] & 0x80;
 +	tpm = fcx_in_css && fcx_in_gneq && fcx_in_features;
 +
 +	if (!tpm)
 +		return 0;
 +
 +	mdc = ccw_device_get_mdc(device->cdev, 0);
 +	if (mdc < 0) {
 +		dev_warn(&device->cdev->dev, "Detecting the maximum supported data size for zHPF requests failed\n");
 +		return 0;
 +	} else {
 +		return (u32)mdc * FCX_MAX_DATA_FACTOR;
 +	}
 +#else
 +	return 0;
 +#endif
 +}
 +
  static int verify_fcx_max_data(struct dasd_device *device, __u8 lpm)
  {
- 	struct dasd_eckd_private *private;
+ 	struct dasd_eckd_private *private = device->private;
  	int mdc;
  	u32 fcx_max_data;
  
@@@ -1272,13 -1209,10 +1265,20 @@@
  static int rebuild_device_uid(struct dasd_device *device,
  			      struct path_verification_work_data *data)
  {
++<<<<<<< HEAD
 +	struct dasd_eckd_private *private;
 +	__u8 lpm, opm = dasd_path_get_opm(device);
 +	int rc;
 +
 +	rc = -ENODEV;
 +	private = (struct dasd_eckd_private *) device->private;
 +
++=======
+ 	struct dasd_eckd_private *private = device->private;
+ 	struct dasd_path *path_data = &device->path_data;
+ 	__u8 lpm, opm = path_data->opm;
+ 	int rc = -ENODEV;
++>>>>>>> 543691a4e1e0 (s390/dasd: remove casts to dasd_*_private)
  
  	for (lpm = 0x80; lpm; lpm >>= 1) {
  		if (!(lpm & opm))
@@@ -1500,22 -1444,9 +1500,23 @@@ static int dasd_eckd_verify_path(struc
  	return 0;
  }
  
 +static void dasd_eckd_reset_path(struct dasd_device *device, __u8 pm)
 +{
 +	struct dasd_eckd_private *private;
 +	unsigned long flags;
 +
 +        private = (struct dasd_eckd_private *) device->private;
 +	if (!private->fcx_max_data)
 +		private->fcx_max_data = get_fcx_max_data(device);
 +	spin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);
 +	dasd_path_set_tbvpm(device, pm ? : dasd_path_get_notoperpm(device));
 +	dasd_schedule_device_bh(device);
 +	spin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);
 +}
 +
  static int dasd_eckd_read_features(struct dasd_device *device)
  {
+ 	struct dasd_eckd_private *private = device->private;
  	struct dasd_psf_prssd_data *prssdp;
  	struct dasd_rssd_features *features;
  	struct dasd_ccw_req *cqr;
@@@ -1713,6 -1640,32 +1710,35 @@@ static void dasd_eckd_kick_validate_ser
  		dasd_put_device(device);
  }
  
++<<<<<<< HEAD
++=======
+ static u32 get_fcx_max_data(struct dasd_device *device)
+ {
+ 	struct dasd_eckd_private *private = device->private;
+ 	int fcx_in_css, fcx_in_gneq, fcx_in_features;
+ 	int tpm, mdc;
+ 
+ 	if (dasd_nofcx)
+ 		return 0;
+ 	/* is transport mode supported? */
+ 	fcx_in_css = css_general_characteristics.fcx;
+ 	fcx_in_gneq = private->gneq->reserved2[7] & 0x04;
+ 	fcx_in_features = private->features.feature[40] & 0x80;
+ 	tpm = fcx_in_css && fcx_in_gneq && fcx_in_features;
+ 
+ 	if (!tpm)
+ 		return 0;
+ 
+ 	mdc = ccw_device_get_mdc(device->cdev, 0);
+ 	if (mdc < 0) {
+ 		dev_warn(&device->cdev->dev, "Detecting the maximum supported"
+ 			 " data size for zHPF requests failed\n");
+ 		return 0;
+ 	} else
+ 		return mdc * FCX_MAX_DATA_FACTOR;
+ }
+ 
++>>>>>>> 543691a4e1e0 (s390/dasd: remove casts to dasd_*_private)
  /*
   * Check device characteristics.
   * If the device is accessible using ECKD discipline, the device is enabled.
@@@ -2734,18 -2466,8 +2748,22 @@@ out_err
  		list_for_each_entry_safe(cqr, n, &format_queue, blocklist) {
  			device = cqr->startdev;
  			private = device->private;
++<<<<<<< HEAD
 +
 +			if (cqr->status == DASD_CQR_FAILED) {
 +				/*
 +				 * Only get sense data if called by format
 +				 * check
 +				 */
 +				if (fmt_buffer && irb) {
 +					sense = dasd_get_sense(&cqr->irb);
 +					memcpy(irb, &cqr->irb, sizeof(*irb));
 +				}
++=======
+ 			if (cqr->status == DASD_CQR_FAILED)
++>>>>>>> 543691a4e1e0 (s390/dasd: remove casts to dasd_*_private)
  				rc = -EIO;
 +			}
  			list_del_init(&cqr->blocklist);
  			dasd_sfree_request(cqr, device);
  			private->count--;
@@@ -5410,6 -4669,7 +5418,10 @@@ static struct dasd_conf_data *dasd_eckd
  						     __u8 lpum,
  						     struct dasd_cuir_message *cuir)
  {
++<<<<<<< HEAD
++=======
+ 	struct dasd_eckd_private *private = device->private;
++>>>>>>> 543691a4e1e0 (s390/dasd: remove casts to dasd_*_private)
  	struct dasd_conf_data *conf_data;
  	int path, pos;
  
@@@ -5541,10 -4807,11 +5554,10 @@@ static int dasd_eckd_cuir_remove_path(s
   * notify the already set offline devices again
   */
  static int dasd_eckd_cuir_quiesce(struct dasd_device *device, __u8 lpum,
 -				  struct subchannel_id sch_id,
  				  struct dasd_cuir_message *cuir)
  {
+ 	struct dasd_eckd_private *private = device->private;
  	struct alias_pav_group *pavgroup, *tempgroup;
- 	struct dasd_eckd_private *private;
  	struct dasd_device *dev, *n;
  	unsigned long paths = 0;
  	unsigned long flags;
@@@ -5603,10 -4869,11 +5615,10 @@@ out_err
  }
  
  static int dasd_eckd_cuir_resume(struct dasd_device *device, __u8 lpum,
 -				 struct subchannel_id sch_id,
  				 struct dasd_cuir_message *cuir)
  {
+ 	struct dasd_eckd_private *private = device->private;
  	struct alias_pav_group *pavgroup, *tempgroup;
- 	struct dasd_eckd_private *private;
  	struct dasd_device *dev, *n;
  	unsigned long paths = 0;
  	int tbcpm;
diff --cc drivers/s390/block/dasd_int.h
index 01860349ef32,8de29be32a56..000000000000
--- a/drivers/s390/block/dasd_int.h
+++ b/drivers/s390/block/dasd_int.h
@@@ -475,8 -446,7 +475,12 @@@ struct dasd_device 
  	struct dasd_discipline *discipline;
  	struct dasd_discipline *base_discipline;
  	void *private;
++<<<<<<< HEAD
 +	struct dasd_path path[8];
 +	__u8 opm;
++=======
+ 	struct dasd_path path_data;
++>>>>>>> 543691a4e1e0 (s390/dasd: remove casts to dasd_*_private)
  
  	/* Device state and target state. */
  	int state, target;
diff --git a/drivers/s390/block/dasd_alias.c b/drivers/s390/block/dasd_alias.c
index 4c017a1dc0b1..f66df1cfec4a 100644
--- a/drivers/s390/block/dasd_alias.c
+++ b/drivers/s390/block/dasd_alias.c
@@ -185,14 +185,12 @@ static void _free_lcu(struct alias_lcu *lcu)
  */
 int dasd_alias_make_device_known_to_lcu(struct dasd_device *device)
 {
-	struct dasd_eckd_private *private;
+	struct dasd_eckd_private *private = device->private;
 	unsigned long flags;
 	struct alias_server *server, *newserver;
 	struct alias_lcu *lcu, *newlcu;
 	struct dasd_uid uid;
 
-	private = (struct dasd_eckd_private *) device->private;
-
 	device->discipline->get_uid(device, &uid);
 	spin_lock_irqsave(&aliastree.lock, flags);
 	server = _find_server(&uid);
@@ -244,14 +242,13 @@ int dasd_alias_make_device_known_to_lcu(struct dasd_device *device)
  */
 void dasd_alias_disconnect_device_from_lcu(struct dasd_device *device)
 {
-	struct dasd_eckd_private *private;
+	struct dasd_eckd_private *private = device->private;
 	unsigned long flags;
 	struct alias_lcu *lcu;
 	struct alias_server *server;
 	int was_pending;
 	struct dasd_uid uid;
 
-	private = (struct dasd_eckd_private *) device->private;
 	lcu = private->lcu;
 	/* nothing to do if already disconnected */
 	if (!lcu)
@@ -312,12 +309,10 @@ static int _add_device_to_lcu(struct alias_lcu *lcu,
 			      struct dasd_device *pos)
 {
 
-	struct dasd_eckd_private *private;
+	struct dasd_eckd_private *private = device->private;
 	struct alias_pav_group *group;
 	struct dasd_uid uid;
 
-	private = (struct dasd_eckd_private *) device->private;
-
 	private->uid.type = lcu->uac->unit[private->uid.real_unit_addr].ua_type;
 	private->uid.base_unit_addr =
 		lcu->uac->unit[private->uid.real_unit_addr].base_ua;
@@ -358,10 +353,9 @@ static int _add_device_to_lcu(struct alias_lcu *lcu,
 static void _remove_device_from_lcu(struct alias_lcu *lcu,
 				    struct dasd_device *device)
 {
-	struct dasd_eckd_private *private;
+	struct dasd_eckd_private *private = device->private;
 	struct alias_pav_group *group;
 
-	private = (struct dasd_eckd_private *) device->private;
 	list_move(&device->alias_list, &lcu->inactive_devices);
 	group = private->pavgroup;
 	if (!group)
@@ -599,13 +593,13 @@ static int _lcu_update(struct dasd_device *refdev, struct alias_lcu *lcu)
 		list_for_each_entry_safe(device, tempdev, &pavgroup->baselist,
 					 alias_list) {
 			list_move(&device->alias_list, &lcu->active_devices);
-			private = (struct dasd_eckd_private *) device->private;
+			private = device->private;
 			private->pavgroup = NULL;
 		}
 		list_for_each_entry_safe(device, tempdev, &pavgroup->aliaslist,
 					 alias_list) {
 			list_move(&device->alias_list, &lcu->active_devices);
-			private = (struct dasd_eckd_private *) device->private;
+			private = device->private;
 			private->pavgroup = NULL;
 		}
 		list_del(&pavgroup->group);
@@ -713,12 +707,11 @@ static int _schedule_lcu_update(struct alias_lcu *lcu,
 
 int dasd_alias_add_device(struct dasd_device *device)
 {
-	struct dasd_eckd_private *private;
+	struct dasd_eckd_private *private = device->private;
 	struct alias_lcu *lcu;
 	unsigned long flags;
 	int rc;
 
-	private = (struct dasd_eckd_private *) device->private;
 	lcu = private->lcu;
 	rc = 0;
 	spin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);
@@ -739,20 +732,18 @@ int dasd_alias_add_device(struct dasd_device *device)
 
 int dasd_alias_update_add_device(struct dasd_device *device)
 {
-	struct dasd_eckd_private *private;
-	private = (struct dasd_eckd_private *) device->private;
+	struct dasd_eckd_private *private = device->private;
+
 	private->lcu->flags |= UPDATE_PENDING;
 	return dasd_alias_add_device(device);
 }
 
 int dasd_alias_remove_device(struct dasd_device *device)
 {
-	struct dasd_eckd_private *private;
-	struct alias_lcu *lcu;
+	struct dasd_eckd_private *private = device->private;
+	struct alias_lcu *lcu = private->lcu;
 	unsigned long flags;
 
-	private = (struct dasd_eckd_private *) device->private;
-	lcu = private->lcu;
 	/* nothing to do if already removed */
 	if (!lcu)
 		return 0;
@@ -764,16 +755,12 @@ int dasd_alias_remove_device(struct dasd_device *device)
 
 struct dasd_device *dasd_alias_get_start_dev(struct dasd_device *base_device)
 {
-
+	struct dasd_eckd_private *alias_priv, *private = base_device->private;
+	struct alias_pav_group *group = private->pavgroup;
+	struct alias_lcu *lcu = private->lcu;
 	struct dasd_device *alias_device;
-	struct alias_pav_group *group;
-	struct alias_lcu *lcu;
-	struct dasd_eckd_private *private, *alias_priv;
 	unsigned long flags;
 
-	private = (struct dasd_eckd_private *) base_device->private;
-	group = private->pavgroup;
-	lcu = private->lcu;
 	if (!group || !lcu)
 		return NULL;
 	if (lcu->pav == NO_PAV ||
@@ -809,7 +796,7 @@ struct dasd_device *dasd_alias_get_start_dev(struct dasd_device *base_device)
 		group->next = list_first_entry(&alias_device->alias_list,
 					       struct dasd_device, alias_list);
 	spin_unlock_irqrestore(&lcu->lock, flags);
-	alias_priv = (struct dasd_eckd_private *) alias_device->private;
+	alias_priv = alias_device->private;
 	if ((alias_priv->count < private->count) && !alias_device->stopped &&
 	    !test_bit(DASD_FLAG_OFFLINE, &alias_device->flags))
 		return alias_device;
@@ -860,14 +847,14 @@ static void _restart_all_base_devices_on_lcu(struct alias_lcu *lcu)
 
 	/* active and inactive list can contain alias as well as base devices */
 	list_for_each_entry(device, &lcu->active_devices, alias_list) {
-		private = (struct dasd_eckd_private *) device->private;
+		private = device->private;
 		if (private->uid.type != UA_BASE_DEVICE)
 			continue;
 		dasd_schedule_block_bh(device->block);
 		dasd_schedule_device_bh(device);
 	}
 	list_for_each_entry(device, &lcu->inactive_devices, alias_list) {
-		private = (struct dasd_eckd_private *) device->private;
+		private = device->private;
 		if (private->uid.type != UA_BASE_DEVICE)
 			continue;
 		dasd_schedule_block_bh(device->block);
@@ -904,7 +891,7 @@ static void flush_all_alias_devices_on_lcu(struct alias_lcu *lcu)
 	spin_lock_irqsave(&lcu->lock, flags);
 	list_for_each_entry_safe(device, temp, &lcu->active_devices,
 				 alias_list) {
-		private = (struct dasd_eckd_private *) device->private;
+		private = device->private;
 		if (private->uid.type == UA_BASE_DEVICE)
 			continue;
 		list_move(&device->alias_list, &active);
@@ -926,7 +913,7 @@ static void flush_all_alias_devices_on_lcu(struct alias_lcu *lcu)
 		if (device == list_first_entry(&active,
 					       struct dasd_device, alias_list)) {
 			list_move(&device->alias_list, &lcu->active_devices);
-			private = (struct dasd_eckd_private *) device->private;
+			private = device->private;
 			private->pavgroup = NULL;
 		}
 	}
@@ -1005,13 +992,11 @@ static void summary_unit_check_handling_work(struct work_struct *work)
 void dasd_alias_handle_summary_unit_check(struct dasd_device *device,
 					  struct irb *irb)
 {
+	struct dasd_eckd_private *private = device->private;
 	struct alias_lcu *lcu;
 	char reason;
-	struct dasd_eckd_private *private;
 	char *sense;
 
-	private = (struct dasd_eckd_private *) device->private;
-
 	sense = dasd_get_sense(irb);
 	if (sense) {
 		reason = sense[8];
diff --git a/drivers/s390/block/dasd_diag.c b/drivers/s390/block/dasd_diag.c
index 01f39b41195b..62f8ed2793b5 100644
--- a/drivers/s390/block/dasd_diag.c
+++ b/drivers/s390/block/dasd_diag.c
@@ -97,12 +97,10 @@ static inline int
 mdsk_init_io(struct dasd_device *device, unsigned int blocksize,
 	     blocknum_t offset, blocknum_t *end_block)
 {
-	struct dasd_diag_private *private;
-	struct dasd_diag_init_io *iib;
+	struct dasd_diag_private *private = device->private;
+	struct dasd_diag_init_io *iib = &private->iib;
 	int rc;
 
-	private = (struct dasd_diag_private *) device->private;
-	iib = &private->iib;
 	memset(iib, 0, sizeof (struct dasd_diag_init_io));
 
 	iib->dev_nr = private->dev_id.devno;
@@ -123,12 +121,10 @@ mdsk_init_io(struct dasd_device *device, unsigned int blocksize,
 static inline int
 mdsk_term_io(struct dasd_device * device)
 {
-	struct dasd_diag_private *private;
-	struct dasd_diag_init_io *iib;
+	struct dasd_diag_private *private = device->private;
+	struct dasd_diag_init_io *iib = &private->iib;
 	int rc;
 
-	private = (struct dasd_diag_private *) device->private;
-	iib = &private->iib;
 	memset(iib, 0, sizeof (struct dasd_diag_init_io));
 	iib->dev_nr = private->dev_id.devno;
 	rc = dia250(iib, TERM_BIO);
@@ -173,8 +169,8 @@ dasd_start_diag(struct dasd_ccw_req * cqr)
 		cqr->status = DASD_CQR_ERROR;
 		return -EIO;
 	}
-	private = (struct dasd_diag_private *) device->private;
-	dreq = (struct dasd_diag_req *) cqr->data;
+	private = device->private;
+	dreq = cqr->data;
 
 	private->iob.dev_nr = private->dev_id.devno;
 	private->iob.key = 0;
@@ -313,18 +309,17 @@ static void dasd_ext_handler(struct ext_code ext_code,
 static int
 dasd_diag_check_device(struct dasd_device *device)
 {
-	struct dasd_block *block;
-	struct dasd_diag_private *private;
+	struct dasd_diag_private *private = device->private;
 	struct dasd_diag_characteristics *rdc_data;
-	struct dasd_diag_bio bio;
 	struct vtoc_cms_label *label;
-	blocknum_t end_block;
+	struct dasd_block *block;
+	struct dasd_diag_bio bio;
 	unsigned int sb, bsize;
+	blocknum_t end_block;
 	int rc;
 
-	private = (struct dasd_diag_private *) device->private;
 	if (private == NULL) {
-		private = kzalloc(sizeof(struct dasd_diag_private),GFP_KERNEL);
+		private = kzalloc(sizeof(*private), GFP_KERNEL);
 		if (private == NULL) {
 			DBF_DEV_EVENT(DBF_WARNING, device, "%s",
 				"Allocating memory for private DASD data "
@@ -332,7 +327,7 @@ dasd_diag_check_device(struct dasd_device *device)
 			return -ENOMEM;
 		}
 		ccw_device_get_id(device->cdev, &private->dev_id);
-		device->private = (void *) private;
+		device->private = private;
 	}
 	block = dasd_alloc_block();
 	if (IS_ERR(block)) {
@@ -346,7 +341,7 @@ dasd_diag_check_device(struct dasd_device *device)
 	block->base = device;
 
 	/* Read Device Characteristics */
-	rdc_data = (void *) &(private->rdc_data);
+	rdc_data = &private->rdc_data;
 	rdc_data->dev_nr = private->dev_id.devno;
 	rdc_data->rdc_len = sizeof (struct dasd_diag_characteristics);
 
@@ -590,16 +585,14 @@ static int
 dasd_diag_fill_info(struct dasd_device * device,
 		    struct dasd_information2_t * info)
 {
-	struct dasd_diag_private *private;
+	struct dasd_diag_private *private = device->private;
 
-	private = (struct dasd_diag_private *) device->private;
 	info->label_block = (unsigned int) private->pt_block;
 	info->FBA_layout = 1;
 	info->format = DASD_FORMAT_LDL;
-	info->characteristics_size = sizeof (struct dasd_diag_characteristics);
-	memcpy(info->characteristics,
-	       &((struct dasd_diag_private *) device->private)->rdc_data,
-	       sizeof (struct dasd_diag_characteristics));
+	info->characteristics_size = sizeof(private->rdc_data);
+	memcpy(info->characteristics, &private->rdc_data,
+	       sizeof(private->rdc_data));
 	info->confdata_size = 0;
 	return 0;
 }
* Unmerged path drivers/s390/block/dasd_eckd.c
diff --git a/drivers/s390/block/dasd_fba.c b/drivers/s390/block/dasd_fba.c
index 130cd792ba6c..c0d17d578090 100644
--- a/drivers/s390/block/dasd_fba.c
+++ b/drivers/s390/block/dasd_fba.c
@@ -123,13 +123,11 @@ locate_record(struct ccw1 * ccw, struct LO_fba_data *data, int rw,
 static int
 dasd_fba_check_characteristics(struct dasd_device *device)
 {
-	struct dasd_block *block;
-	struct dasd_fba_private *private;
+	struct dasd_fba_private *private = device->private;
 	struct ccw_device *cdev = device->cdev;
-	int rc;
-	int readonly;
+	struct dasd_block *block;
+	int readonly, rc;
 
-	private = (struct dasd_fba_private *) device->private;
 	if (!private) {
 		private = kzalloc(sizeof(*private), GFP_KERNEL | GFP_DMA);
 		if (!private) {
@@ -138,7 +136,7 @@ dasd_fba_check_characteristics(struct dasd_device *device)
 				 "data failed\n");
 			return -ENOMEM;
 		}
-		device->private = (void *) private;
+		device->private = private;
 	} else {
 		memset(private, 0, sizeof(*private));
 	}
@@ -189,10 +187,9 @@ dasd_fba_check_characteristics(struct dasd_device *device)
 
 static int dasd_fba_do_analysis(struct dasd_block *block)
 {
-	struct dasd_fba_private *private;
+	struct dasd_fba_private *private = block->base->private;
 	int sb, rc;
 
-	private = (struct dasd_fba_private *) block->base->private;
 	rc = dasd_check_blocksize(private->rdc_data.blk_size);
 	if (rc) {
 		DBF_DEV_EVENT(DBF_WARNING, block->base, "unknown blocksize %d",
@@ -251,7 +248,7 @@ static struct dasd_ccw_req *dasd_fba_build_cp(struct dasd_device * memdev,
 					      struct dasd_block *block,
 					      struct request *req)
 {
-	struct dasd_fba_private *private;
+	struct dasd_fba_private *private = block->base->private;
 	unsigned long *idaws;
 	struct LO_fba_data *LO_data;
 	struct dasd_ccw_req *cqr;
@@ -264,7 +261,6 @@ static struct dasd_ccw_req *dasd_fba_build_cp(struct dasd_device * memdev,
 	unsigned int blksize, off;
 	unsigned char cmd;
 
-	private = (struct dasd_fba_private *) block->base->private;
 	if (rq_data_dir(req) == READ) {
 		cmd = DASD_FBA_CCW_READ;
 	} else if (rq_data_dir(req) == WRITE) {
@@ -378,7 +374,7 @@ static struct dasd_ccw_req *dasd_fba_build_cp(struct dasd_device * memdev,
 static int
 dasd_fba_free_cp(struct dasd_ccw_req *cqr, struct request *req)
 {
-	struct dasd_fba_private *private;
+	struct dasd_fba_private *private = cqr->block->base->private;
 	struct ccw1 *ccw;
 	struct req_iterator iter;
 	struct bio_vec *bv;
@@ -388,7 +384,6 @@ dasd_fba_free_cp(struct dasd_ccw_req *cqr, struct request *req)
 
 	if (!dasd_page_cache)
 		goto out;
-	private = (struct dasd_fba_private *) cqr->block->base->private;
 	blksize = cqr->block->bp_block;
 	ccw = cqr->cpaddr;
 	/* Skip over define extent & locate record. */
@@ -432,13 +427,14 @@ static int
 dasd_fba_fill_info(struct dasd_device * device,
 		   struct dasd_information2_t * info)
 {
+	struct dasd_fba_private *private = device->private;
+
 	info->label_block = 1;
 	info->FBA_layout = 1;
 	info->format = DASD_FORMAT_LDL;
-	info->characteristics_size = sizeof(struct dasd_fba_characteristics);
-	memcpy(info->characteristics,
-	       &((struct dasd_fba_private *) device->private)->rdc_data,
-	       sizeof (struct dasd_fba_characteristics));
+	info->characteristics_size = sizeof(private->rdc_data);
+	memcpy(info->characteristics, &private->rdc_data,
+	       sizeof(private->rdc_data));
 	info->confdata_size = 0;
 	return 0;
 }
* Unmerged path drivers/s390/block/dasd_int.h
