net: sched: Move to new offload indication in RED

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] sched: Move to new offload indication in RED (Ivan Vecera) [1583702]
Rebuild_FUZZ: 94.62%
commit-author Yuval Mintz <yuvalm@mellanox.com>
commit 428a68af3a7c3a3380ff1f750a24d213f370f89f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/428a68af.failed

Let RED utilize the new internal flag, TCQ_F_OFFLOADED,
to mark a given qdisc as offloaded instead of using a dedicated
indication.

Also, change internal logic into looking at said flag when possible.

Fixes: 602f3baf2218 ("net_sch: red: Add offload ability to RED qdisc")
	Signed-off-by: Yuval Mintz <yuvalm@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 428a68af3a7c3a3380ff1f750a24d213f370f89f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_red.c
diff --cc net/sched/sch_red.c
index ffa7875f9b91,f0747eb87dc4..000000000000
--- a/net/sched/sch_red.c
+++ b/net/sched/sch_red.c
@@@ -147,6 -149,39 +147,42 @@@ static void red_reset(struct Qdisc *sch
  	red_restart(&q->vars);
  }
  
++<<<<<<< HEAD
++=======
+ static int red_offload(struct Qdisc *sch, bool enable)
+ {
+ 	struct red_sched_data *q = qdisc_priv(sch);
+ 	struct net_device *dev = qdisc_dev(sch);
+ 	struct tc_red_qopt_offload opt = {
+ 		.handle = sch->handle,
+ 		.parent = sch->parent,
+ 	};
+ 	int err;
+ 
+ 	if (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (enable) {
+ 		opt.command = TC_RED_REPLACE;
+ 		opt.set.min = q->parms.qth_min >> q->parms.Wlog;
+ 		opt.set.max = q->parms.qth_max >> q->parms.Wlog;
+ 		opt.set.probability = q->parms.max_P;
+ 		opt.set.is_ecn = red_use_ecn(q);
+ 	} else {
+ 		opt.command = TC_RED_DESTROY;
+ 	}
+ 
+ 	err = dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_RED, &opt);
+ 
+ 	if (!err && enable)
+ 		sch->flags |= TCQ_F_OFFLOADED;
+ 	else
+ 		sch->flags &= ~TCQ_F_OFFLOADED;
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 428a68af3a7c (net: sched: Move to new offload indication in RED)
  static void red_destroy(struct Qdisc *sch)
  {
  	struct red_sched_data *q = qdisc_priv(sch);
@@@ -242,6 -282,26 +278,29 @@@ static int red_init(struct Qdisc *sch, 
  	return red_change(sch, opt);
  }
  
++<<<<<<< HEAD
++=======
+ static int red_dump_offload_stats(struct Qdisc *sch, struct tc_red_qopt *opt)
+ {
+ 	struct net_device *dev = qdisc_dev(sch);
+ 	struct tc_red_qopt_offload hw_stats = {
+ 		.command = TC_RED_STATS,
+ 		.handle = sch->handle,
+ 		.parent = sch->parent,
+ 		{
+ 			.stats.bstats = &sch->bstats,
+ 			.stats.qstats = &sch->qstats,
+ 		},
+ 	};
+ 
+ 	if (!(sch->flags & TCQ_F_OFFLOADED))
+ 		return 0;
+ 
+ 	return dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_RED,
+ 					     &hw_stats);
+ }
+ 
++>>>>>>> 428a68af3a7c (net: sched: Move to new offload indication in RED)
  static int red_dump(struct Qdisc *sch, struct sk_buff *skb)
  {
  	struct red_sched_data *q = qdisc_priv(sch);
@@@ -255,8 -315,13 +314,15 @@@
  		.Plog		= q->parms.Plog,
  		.Scell_log	= q->parms.Scell_log,
  	};
 -	int err;
  
  	sch->qstats.backlog = q->qdisc->qstats.backlog;
++<<<<<<< HEAD
++=======
+ 	err = red_dump_offload_stats(sch, &opt);
+ 	if (err)
+ 		goto nla_put_failure;
+ 
++>>>>>>> 428a68af3a7c (net: sched: Move to new offload indication in RED)
  	opts = nla_nest_start(skb, TCA_OPTIONS);
  	if (opts == NULL)
  		goto nla_put_failure;
@@@ -280,6 -346,26 +346,29 @@@ static int red_dump_stats(struct Qdisc 
  		.marked	= q->stats.prob_mark + q->stats.forced_mark,
  	};
  
++<<<<<<< HEAD
++=======
+ 	if (sch->flags & TCQ_F_OFFLOADED) {
+ 		struct red_stats hw_stats = {0};
+ 		struct tc_red_qopt_offload hw_stats_request = {
+ 			.command = TC_RED_XSTATS,
+ 			.handle = sch->handle,
+ 			.parent = sch->parent,
+ 			{
+ 				.xstats = &hw_stats,
+ 			},
+ 		};
+ 		if (!dev->netdev_ops->ndo_setup_tc(dev,
+ 						   TC_SETUP_QDISC_RED,
+ 						   &hw_stats_request)) {
+ 			st.early += hw_stats.prob_drop + hw_stats.forced_drop;
+ 			st.pdrop += hw_stats.pdrop;
+ 			st.other += hw_stats.other;
+ 			st.marked += hw_stats.prob_mark + hw_stats.forced_mark;
+ 		}
+ 	}
+ 
++>>>>>>> 428a68af3a7c (net: sched: Move to new offload indication in RED)
  	return gnet_stats_copy_app(d, &st, sizeof(st));
  }
  
* Unmerged path net/sched/sch_red.c
