bpf: Add BPF_OBJ_GET_INFO_BY_FD

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Martin KaFai Lau <kafai@fb.com>
commit 1e270976908686ec25fb91b8a34145be54137976
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1e270976.failed

A single BPF_OBJ_GET_INFO_BY_FD cmd is used to obtain the info
for both bpf_prog and bpf_map.  The kernel can figure out the
fd is associated with a bpf_prog or bpf_map.

The suggested struct bpf_prog_info and struct bpf_map_info are
not meant to be a complete list and it is not the goal of this patch.
New fields can be added in the future patch.

The focus of this patch is to create the interface,
BPF_OBJ_GET_INFO_BY_FD cmd for exposing the bpf_prog's and
bpf_map's info.

The obj's info, which will be extended (and get bigger) over time, is
separated from the bpf_attr to avoid bloating the bpf_attr.

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Acked-by: Alexei Starovoitov <ast@fb.com>
	Acked-by: Daniel Borkmann <daniel@iogearbox.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1e270976908686ec25fb91b8a34145be54137976)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/filter.h
#	include/uapi/linux/bpf.h
#	kernel/bpf/syscall.c
diff --cc include/linux/filter.h
index d322ed880333,1fa26dc562ce..000000000000
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@@ -23,21 -28,434 +23,405 @@@ struct compat_sock_fprog 
  
  struct sk_buff;
  struct sock;
 -struct seccomp_data;
  struct bpf_prog_aux;
  
++<<<<<<< HEAD
 +struct bpf_prog
 +{
 +	struct bpf_prog_aux	*aux;	/* Auxiliary fields */
++=======
+ /* ArgX, context and stack frame pointer register positions. Note,
+  * Arg1, Arg2, Arg3, etc are used as argument mappings of function
+  * calls in BPF_CALL instruction.
+  */
+ #define BPF_REG_ARG1	BPF_REG_1
+ #define BPF_REG_ARG2	BPF_REG_2
+ #define BPF_REG_ARG3	BPF_REG_3
+ #define BPF_REG_ARG4	BPF_REG_4
+ #define BPF_REG_ARG5	BPF_REG_5
+ #define BPF_REG_CTX	BPF_REG_6
+ #define BPF_REG_FP	BPF_REG_10
+ 
+ /* Additional register mappings for converted user programs. */
+ #define BPF_REG_A	BPF_REG_0
+ #define BPF_REG_X	BPF_REG_7
+ #define BPF_REG_TMP	BPF_REG_8
+ 
+ /* Kernel hidden auxiliary/helper register for hardening step.
+  * Only used by eBPF JITs. It's nothing more than a temporary
+  * register that JITs use internally, only that here it's part
+  * of eBPF instructions that have been rewritten for blinding
+  * constants. See JIT pre-step in bpf_jit_blind_constants().
+  */
+ #define BPF_REG_AX		MAX_BPF_REG
+ #define MAX_BPF_JIT_REG		(MAX_BPF_REG + 1)
+ 
+ /* unused opcode to mark special call to bpf_tail_call() helper */
+ #define BPF_TAIL_CALL	0xf0
+ 
+ /* As per nm, we expose JITed images as text (code) section for
+  * kallsyms. That way, tools like perf can find it to match
+  * addresses.
+  */
+ #define BPF_SYM_ELF_TYPE	't'
+ 
+ /* BPF program can access up to 512 bytes of stack space. */
+ #define MAX_BPF_STACK	512
+ 
+ /* Helper macros for filter block array initializers. */
+ 
+ /* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */
+ 
+ #define BPF_ALU64_REG(OP, DST, SRC)				\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_ALU64 | BPF_OP(OP) | BPF_X,	\
+ 		.dst_reg = DST,					\
+ 		.src_reg = SRC,					\
+ 		.off   = 0,					\
+ 		.imm   = 0 })
+ 
+ #define BPF_ALU32_REG(OP, DST, SRC)				\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_ALU | BPF_OP(OP) | BPF_X,		\
+ 		.dst_reg = DST,					\
+ 		.src_reg = SRC,					\
+ 		.off   = 0,					\
+ 		.imm   = 0 })
+ 
+ /* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */
+ 
+ #define BPF_ALU64_IMM(OP, DST, IMM)				\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_ALU64 | BPF_OP(OP) | BPF_K,	\
+ 		.dst_reg = DST,					\
+ 		.src_reg = 0,					\
+ 		.off   = 0,					\
+ 		.imm   = IMM })
+ 
+ #define BPF_ALU32_IMM(OP, DST, IMM)				\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_ALU | BPF_OP(OP) | BPF_K,		\
+ 		.dst_reg = DST,					\
+ 		.src_reg = 0,					\
+ 		.off   = 0,					\
+ 		.imm   = IMM })
+ 
+ /* Endianess conversion, cpu_to_{l,b}e(), {l,b}e_to_cpu() */
+ 
+ #define BPF_ENDIAN(TYPE, DST, LEN)				\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_ALU | BPF_END | BPF_SRC(TYPE),	\
+ 		.dst_reg = DST,					\
+ 		.src_reg = 0,					\
+ 		.off   = 0,					\
+ 		.imm   = LEN })
+ 
+ /* Short form of mov, dst_reg = src_reg */
+ 
+ #define BPF_MOV64_REG(DST, SRC)					\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_ALU64 | BPF_MOV | BPF_X,		\
+ 		.dst_reg = DST,					\
+ 		.src_reg = SRC,					\
+ 		.off   = 0,					\
+ 		.imm   = 0 })
+ 
+ #define BPF_MOV32_REG(DST, SRC)					\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_ALU | BPF_MOV | BPF_X,		\
+ 		.dst_reg = DST,					\
+ 		.src_reg = SRC,					\
+ 		.off   = 0,					\
+ 		.imm   = 0 })
+ 
+ /* Short form of mov, dst_reg = imm32 */
+ 
+ #define BPF_MOV64_IMM(DST, IMM)					\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_ALU64 | BPF_MOV | BPF_K,		\
+ 		.dst_reg = DST,					\
+ 		.src_reg = 0,					\
+ 		.off   = 0,					\
+ 		.imm   = IMM })
+ 
+ #define BPF_MOV32_IMM(DST, IMM)					\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_ALU | BPF_MOV | BPF_K,		\
+ 		.dst_reg = DST,					\
+ 		.src_reg = 0,					\
+ 		.off   = 0,					\
+ 		.imm   = IMM })
+ 
+ /* BPF_LD_IMM64 macro encodes single 'load 64-bit immediate' insn */
+ #define BPF_LD_IMM64(DST, IMM)					\
+ 	BPF_LD_IMM64_RAW(DST, 0, IMM)
+ 
+ #define BPF_LD_IMM64_RAW(DST, SRC, IMM)				\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_LD | BPF_DW | BPF_IMM,		\
+ 		.dst_reg = DST,					\
+ 		.src_reg = SRC,					\
+ 		.off   = 0,					\
+ 		.imm   = (__u32) (IMM) }),			\
+ 	((struct bpf_insn) {					\
+ 		.code  = 0, /* zero is reserved opcode */	\
+ 		.dst_reg = 0,					\
+ 		.src_reg = 0,					\
+ 		.off   = 0,					\
+ 		.imm   = ((__u64) (IMM)) >> 32 })
+ 
+ /* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */
+ #define BPF_LD_MAP_FD(DST, MAP_FD)				\
+ 	BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)
+ 
+ /* Short form of mov based on type, BPF_X: dst_reg = src_reg, BPF_K: dst_reg = imm32 */
+ 
+ #define BPF_MOV64_RAW(TYPE, DST, SRC, IMM)			\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_ALU64 | BPF_MOV | BPF_SRC(TYPE),	\
+ 		.dst_reg = DST,					\
+ 		.src_reg = SRC,					\
+ 		.off   = 0,					\
+ 		.imm   = IMM })
+ 
+ #define BPF_MOV32_RAW(TYPE, DST, SRC, IMM)			\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_ALU | BPF_MOV | BPF_SRC(TYPE),	\
+ 		.dst_reg = DST,					\
+ 		.src_reg = SRC,					\
+ 		.off   = 0,					\
+ 		.imm   = IMM })
+ 
+ /* Direct packet access, R0 = *(uint *) (skb->data + imm32) */
+ 
+ #define BPF_LD_ABS(SIZE, IMM)					\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_LD | BPF_SIZE(SIZE) | BPF_ABS,	\
+ 		.dst_reg = 0,					\
+ 		.src_reg = 0,					\
+ 		.off   = 0,					\
+ 		.imm   = IMM })
+ 
+ /* Indirect packet access, R0 = *(uint *) (skb->data + src_reg + imm32) */
+ 
+ #define BPF_LD_IND(SIZE, SRC, IMM)				\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_LD | BPF_SIZE(SIZE) | BPF_IND,	\
+ 		.dst_reg = 0,					\
+ 		.src_reg = SRC,					\
+ 		.off   = 0,					\
+ 		.imm   = IMM })
+ 
+ /* Memory load, dst_reg = *(uint *) (src_reg + off16) */
+ 
+ #define BPF_LDX_MEM(SIZE, DST, SRC, OFF)			\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM,	\
+ 		.dst_reg = DST,					\
+ 		.src_reg = SRC,					\
+ 		.off   = OFF,					\
+ 		.imm   = 0 })
+ 
+ /* Memory store, *(uint *) (dst_reg + off16) = src_reg */
+ 
+ #define BPF_STX_MEM(SIZE, DST, SRC, OFF)			\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM,	\
+ 		.dst_reg = DST,					\
+ 		.src_reg = SRC,					\
+ 		.off   = OFF,					\
+ 		.imm   = 0 })
+ 
+ /* Atomic memory add, *(uint *)(dst_reg + off16) += src_reg */
+ 
+ #define BPF_STX_XADD(SIZE, DST, SRC, OFF)			\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_STX | BPF_SIZE(SIZE) | BPF_XADD,	\
+ 		.dst_reg = DST,					\
+ 		.src_reg = SRC,					\
+ 		.off   = OFF,					\
+ 		.imm   = 0 })
+ 
+ /* Memory store, *(uint *) (dst_reg + off16) = imm32 */
+ 
+ #define BPF_ST_MEM(SIZE, DST, OFF, IMM)				\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_ST | BPF_SIZE(SIZE) | BPF_MEM,	\
+ 		.dst_reg = DST,					\
+ 		.src_reg = 0,					\
+ 		.off   = OFF,					\
+ 		.imm   = IMM })
+ 
+ /* Conditional jumps against registers, if (dst_reg 'op' src_reg) goto pc + off16 */
+ 
+ #define BPF_JMP_REG(OP, DST, SRC, OFF)				\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_JMP | BPF_OP(OP) | BPF_X,		\
+ 		.dst_reg = DST,					\
+ 		.src_reg = SRC,					\
+ 		.off   = OFF,					\
+ 		.imm   = 0 })
+ 
+ /* Conditional jumps against immediates, if (dst_reg 'op' imm32) goto pc + off16 */
+ 
+ #define BPF_JMP_IMM(OP, DST, IMM, OFF)				\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_JMP | BPF_OP(OP) | BPF_K,		\
+ 		.dst_reg = DST,					\
+ 		.src_reg = 0,					\
+ 		.off   = OFF,					\
+ 		.imm   = IMM })
+ 
+ /* Unconditional jumps, goto pc + off16 */
+ 
+ #define BPF_JMP_A(OFF)						\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_JMP | BPF_JA,			\
+ 		.dst_reg = 0,					\
+ 		.src_reg = 0,					\
+ 		.off   = OFF,					\
+ 		.imm   = 0 })
+ 
+ /* Function call */
+ 
+ #define BPF_EMIT_CALL(FUNC)					\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_JMP | BPF_CALL,			\
+ 		.dst_reg = 0,					\
+ 		.src_reg = 0,					\
+ 		.off   = 0,					\
+ 		.imm   = ((FUNC) - __bpf_call_base) })
+ 
+ /* Raw code statement block */
+ 
+ #define BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)			\
+ 	((struct bpf_insn) {					\
+ 		.code  = CODE,					\
+ 		.dst_reg = DST,					\
+ 		.src_reg = SRC,					\
+ 		.off   = OFF,					\
+ 		.imm   = IMM })
+ 
+ /* Program exit */
+ 
+ #define BPF_EXIT_INSN()						\
+ 	((struct bpf_insn) {					\
+ 		.code  = BPF_JMP | BPF_EXIT,			\
+ 		.dst_reg = 0,					\
+ 		.src_reg = 0,					\
+ 		.off   = 0,					\
+ 		.imm   = 0 })
+ 
+ /* Internal classic blocks for direct assignment */
+ 
+ #define __BPF_STMT(CODE, K)					\
+ 	((struct sock_filter) BPF_STMT(CODE, K))
+ 
+ #define __BPF_JUMP(CODE, K, JT, JF)				\
+ 	((struct sock_filter) BPF_JUMP(CODE, K, JT, JF))
+ 
+ #define bytes_to_bpf_size(bytes)				\
+ ({								\
+ 	int bpf_size = -EINVAL;					\
+ 								\
+ 	if (bytes == sizeof(u8))				\
+ 		bpf_size = BPF_B;				\
+ 	else if (bytes == sizeof(u16))				\
+ 		bpf_size = BPF_H;				\
+ 	else if (bytes == sizeof(u32))				\
+ 		bpf_size = BPF_W;				\
+ 	else if (bytes == sizeof(u64))				\
+ 		bpf_size = BPF_DW;				\
+ 								\
+ 	bpf_size;						\
+ })
+ 
+ #define BPF_SIZEOF(type)					\
+ 	({							\
+ 		const int __size = bytes_to_bpf_size(sizeof(type)); \
+ 		BUILD_BUG_ON(__size < 0);			\
+ 		__size;						\
+ 	})
+ 
+ #define BPF_FIELD_SIZEOF(type, field)				\
+ 	({							\
+ 		const int __size = bytes_to_bpf_size(FIELD_SIZEOF(type, field)); \
+ 		BUILD_BUG_ON(__size < 0);			\
+ 		__size;						\
+ 	})
+ 
+ #define __BPF_MAP_0(m, v, ...) v
+ #define __BPF_MAP_1(m, v, t, a, ...) m(t, a)
+ #define __BPF_MAP_2(m, v, t, a, ...) m(t, a), __BPF_MAP_1(m, v, __VA_ARGS__)
+ #define __BPF_MAP_3(m, v, t, a, ...) m(t, a), __BPF_MAP_2(m, v, __VA_ARGS__)
+ #define __BPF_MAP_4(m, v, t, a, ...) m(t, a), __BPF_MAP_3(m, v, __VA_ARGS__)
+ #define __BPF_MAP_5(m, v, t, a, ...) m(t, a), __BPF_MAP_4(m, v, __VA_ARGS__)
+ 
+ #define __BPF_REG_0(...) __BPF_PAD(5)
+ #define __BPF_REG_1(...) __BPF_MAP(1, __VA_ARGS__), __BPF_PAD(4)
+ #define __BPF_REG_2(...) __BPF_MAP(2, __VA_ARGS__), __BPF_PAD(3)
+ #define __BPF_REG_3(...) __BPF_MAP(3, __VA_ARGS__), __BPF_PAD(2)
+ #define __BPF_REG_4(...) __BPF_MAP(4, __VA_ARGS__), __BPF_PAD(1)
+ #define __BPF_REG_5(...) __BPF_MAP(5, __VA_ARGS__)
+ 
+ #define __BPF_MAP(n, ...) __BPF_MAP_##n(__VA_ARGS__)
+ #define __BPF_REG(n, ...) __BPF_REG_##n(__VA_ARGS__)
+ 
+ #define __BPF_CAST(t, a)						       \
+ 	(__force t)							       \
+ 	(__force							       \
+ 	 typeof(__builtin_choose_expr(sizeof(t) == sizeof(unsigned long),      \
+ 				      (unsigned long)0, (t)0))) a
+ #define __BPF_V void
+ #define __BPF_N
+ 
+ #define __BPF_DECL_ARGS(t, a) t   a
+ #define __BPF_DECL_REGS(t, a) u64 a
+ 
+ #define __BPF_PAD(n)							       \
+ 	__BPF_MAP(n, __BPF_DECL_ARGS, __BPF_N, u64, __ur_1, u64, __ur_2,       \
+ 		  u64, __ur_3, u64, __ur_4, u64, __ur_5)
+ 
+ #define BPF_CALL_x(x, name, ...)					       \
+ 	static __always_inline						       \
+ 	u64 ____##name(__BPF_MAP(x, __BPF_DECL_ARGS, __BPF_V, __VA_ARGS__));   \
+ 	u64 name(__BPF_REG(x, __BPF_DECL_REGS, __BPF_N, __VA_ARGS__));	       \
+ 	u64 name(__BPF_REG(x, __BPF_DECL_REGS, __BPF_N, __VA_ARGS__))	       \
+ 	{								       \
+ 		return ____##name(__BPF_MAP(x,__BPF_CAST,__BPF_N,__VA_ARGS__));\
+ 	}								       \
+ 	static __always_inline						       \
+ 	u64 ____##name(__BPF_MAP(x, __BPF_DECL_ARGS, __BPF_V, __VA_ARGS__))
+ 
+ #define BPF_CALL_0(name, ...)	BPF_CALL_x(0, name, __VA_ARGS__)
+ #define BPF_CALL_1(name, ...)	BPF_CALL_x(1, name, __VA_ARGS__)
+ #define BPF_CALL_2(name, ...)	BPF_CALL_x(2, name, __VA_ARGS__)
+ #define BPF_CALL_3(name, ...)	BPF_CALL_x(3, name, __VA_ARGS__)
+ #define BPF_CALL_4(name, ...)	BPF_CALL_x(4, name, __VA_ARGS__)
+ #define BPF_CALL_5(name, ...)	BPF_CALL_x(5, name, __VA_ARGS__)
+ 
+ #ifdef CONFIG_COMPAT
+ /* A struct sock_filter is architecture independent. */
+ struct compat_sock_fprog {
+ 	u16		len;
+ 	compat_uptr_t	filter;	/* struct sock_filter * */
+ };
+ #endif
+ 
+ struct sock_fprog_kern {
+ 	u16			len;
+ 	struct sock_filter	*filter;
++>>>>>>> 1e2709769086 (bpf: Add BPF_OBJ_GET_INFO_BY_FD)
  };
  
 -struct bpf_binary_header {
 -	unsigned int pages;
 -	u8 image[];
 -};
 -
 -struct bpf_prog {
 -	u16			pages;		/* Number of allocated pages */
 -	kmemcheck_bitfield_begin(meta);
 -	u16			jited:1,	/* Is our filter JIT'ed? */
 -				locked:1,	/* Program image locked? */
 -				gpl_compatible:1, /* Is filter GPL compatible? */
 -				cb_access:1,	/* Is control block accessed? */
 -				dst_needed:1;	/* Do we need dst entry? */
 -	kmemcheck_bitfield_end(meta);
 -	enum bpf_prog_type	type;		/* Type of BPF program */
 -	u32			len;		/* Number of filter blocks */
 -	u32			jited_len;	/* Size of jited insns in bytes */
 -	u8			tag[BPF_TAG_SIZE];
 -	struct bpf_prog_aux	*aux;		/* Auxiliary fields */
 -	struct sock_fprog_kern	*orig_prog;	/* Original BPF program */
 -	unsigned int		(*bpf_func)(const void *ctx,
 -					    const struct bpf_insn *insn);
 -	/* Instructions for interpreter */
 -	union {
 -		struct sock_filter	insns[0];
 -		struct bpf_insn		insnsi[0];
 -	};
 -};
 -
 -struct sk_filter {
 -	refcount_t	refcnt;
 -	struct rcu_head	rcu;
 -	struct bpf_prog	*prog;
 -};
 -
 -#define BPF_PROG_RUN(filter, ctx)  (*filter->bpf_func)(ctx, filter->insnsi)
 -
 -#define BPF_SKB_CB_LEN QDISC_CB_PRIV_LEN
 -
 -struct bpf_skb_data_end {
 -	struct qdisc_skb_cb qdisc_cb;
 -	void *data_end;
 +struct sk_filter
 +{
 +	atomic_t		refcnt;
 +	unsigned int         	len;	/* Number of filter blocks */
 +	unsigned int		(*bpf_func)(const struct sk_buff *skb,
 +					    const struct sock_filter *filter);
 +	struct rcu_head		rcu;
 +	struct sock_filter     	insns[0];
  };
  
  struct xdp_buff {
diff --cc include/uapi/linux/bpf.h
index e369860b690e,9b2c10b45733..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -62,50 -63,30 +62,63 @@@ struct bpf_insn 
  	__s32	imm;		/* signed immediate constant */
  };
  
 -/* Key of an a BPF_MAP_TYPE_LPM_TRIE entry */
 -struct bpf_lpm_trie_key {
 -	__u32	prefixlen;	/* up to 32 for AF_INET, 128 for AF_INET6 */
 -	__u8	data[0];	/* Arbitrary size */
 -};
 -
 -/* BPF syscall commands, see bpf(2) man-page for details. */
 +/* BPF syscall commands */
  enum bpf_cmd {
 +	/* create a map with given type and attributes
 +	 * fd = bpf(BPF_MAP_CREATE, union bpf_attr *, u32 size)
 +	 * returns fd or negative error
 +	 * map is deleted when fd is closed
 +	 */
  	BPF_MAP_CREATE,
 +
 +	/* verify and load eBPF program
 +	 * prog_fd = bpf(BPF_PROG_LOAD, union bpf_attr *attr, u32 size)
 +	 * Using attr->prog_type, attr->insns, attr->license
 +	 * returns fd or negative error
 +	 */
 +	BPF_PROG_LOAD,
++<<<<<<< HEAD
 +
 +	/* lookup key in a given map
 +	 * err = bpf(BPF_MAP_LOOKUP_ELEM, union bpf_attr *attr, u32 size)
 +	 * Using attr->map_fd, attr->key, attr->value
 +	 * returns zero and stores found elem into value
 +	 * or negative error
 +	 */
  	BPF_MAP_LOOKUP_ELEM,
 +
 +	/* create or update key/value pair in a given map
 +	 * err = bpf(BPF_MAP_UPDATE_ELEM, union bpf_attr *attr, u32 size)
 +	 * Using attr->map_fd, attr->key, attr->value
 +	 * returns zero or negative error
 +	 */
  	BPF_MAP_UPDATE_ELEM,
 +
 +	/* find and delete elem by key in a given map
 +	 * err = bpf(BPF_MAP_DELETE_ELEM, union bpf_attr *attr, u32 size)
 +	 * Using attr->map_fd, attr->key
 +	 * returns zero or negative error
 +	 */
  	BPF_MAP_DELETE_ELEM,
 +
 +	/* lookup key in a given map and return next key
 +	 * err = bpf(BPF_MAP_GET_NEXT_KEY, union bpf_attr *attr, u32 size)
 +	 * Using attr->map_fd, attr->key, attr->next_key
 +	 * returns zero and stores next key or negative error
 +	 */
  	BPF_MAP_GET_NEXT_KEY,
 -	BPF_PROG_LOAD,
++=======
+ 	BPF_OBJ_PIN,
+ 	BPF_OBJ_GET,
+ 	BPF_PROG_ATTACH,
+ 	BPF_PROG_DETACH,
+ 	BPF_PROG_TEST_RUN,
+ 	BPF_PROG_GET_NEXT_ID,
+ 	BPF_MAP_GET_NEXT_ID,
+ 	BPF_PROG_GET_FD_BY_ID,
+ 	BPF_MAP_GET_FD_BY_ID,
+ 	BPF_OBJ_GET_INFO_BY_FD,
++>>>>>>> 1e2709769086 (bpf: Add BPF_OBJ_GET_INFO_BY_FD)
  };
  
  enum bpf_map_type {
@@@ -132,9 -177,502 +145,15 @@@ union bpf_attr 
  			__aligned_u64 value;
  			__aligned_u64 next_key;
  		};
 -		__u64		flags;
 -	};
 -
 -	struct { /* anonymous struct used by BPF_PROG_LOAD command */
 -		__u32		prog_type;	/* one of enum bpf_prog_type */
 -		__u32		insn_cnt;
 -		__aligned_u64	insns;
 -		__aligned_u64	license;
 -		__u32		log_level;	/* verbosity level of verifier */
 -		__u32		log_size;	/* size of user buffer */
 -		__aligned_u64	log_buf;	/* user supplied buffer */
 -		__u32		kern_version;	/* checked when prog_type=kprobe */
 -		__u32		prog_flags;
 -	};
 -
 -	struct { /* anonymous struct used by BPF_OBJ_* commands */
 -		__aligned_u64	pathname;
 -		__u32		bpf_fd;
 -	};
 -
 -	struct { /* anonymous struct used by BPF_PROG_ATTACH/DETACH commands */
 -		__u32		target_fd;	/* container object to attach to */
 -		__u32		attach_bpf_fd;	/* eBPF program to attach */
 -		__u32		attach_type;
 -		__u32		attach_flags;
 -	};
 -
 -	struct { /* anonymous struct used by BPF_PROG_TEST_RUN command */
 -		__u32		prog_fd;
 -		__u32		retval;
 -		__u32		data_size_in;
 -		__u32		data_size_out;
 -		__aligned_u64	data_in;
 -		__aligned_u64	data_out;
 -		__u32		repeat;
 -		__u32		duration;
 -	} test;
 -
 -	struct { /* anonymous struct used by BPF_*_GET_*_ID */
 -		union {
 -			__u32		start_id;
 -			__u32		prog_id;
 -			__u32		map_id;
 -		};
 -		__u32		next_id;
  	};
+ 
+ 	struct { /* anonymous struct used by BPF_OBJ_GET_INFO_BY_FD */
+ 		__u32		bpf_fd;
+ 		__u32		info_len;
+ 		__aligned_u64	info;
+ 	} info;
  } __attribute__((aligned(8)));
  
 -/* BPF helper function descriptions:
 - *
 - * void *bpf_map_lookup_elem(&map, &key)
 - *     Return: Map value or NULL
 - *
 - * int bpf_map_update_elem(&map, &key, &value, flags)
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_map_delete_elem(&map, &key)
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_probe_read(void *dst, int size, void *src)
 - *     Return: 0 on success or negative error
 - *
 - * u64 bpf_ktime_get_ns(void)
 - *     Return: current ktime
 - *
 - * int bpf_trace_printk(const char *fmt, int fmt_size, ...)
 - *     Return: length of buffer written or negative error
 - *
 - * u32 bpf_prandom_u32(void)
 - *     Return: random value
 - *
 - * u32 bpf_raw_smp_processor_id(void)
 - *     Return: SMP processor ID
 - *
 - * int bpf_skb_store_bytes(skb, offset, from, len, flags)
 - *     store bytes into packet
 - *     @skb: pointer to skb
 - *     @offset: offset within packet from skb->mac_header
 - *     @from: pointer where to copy bytes from
 - *     @len: number of bytes to store into packet
 - *     @flags: bit 0 - if true, recompute skb->csum
 - *             other bits - reserved
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_l3_csum_replace(skb, offset, from, to, flags)
 - *     recompute IP checksum
 - *     @skb: pointer to skb
 - *     @offset: offset within packet where IP checksum is located
 - *     @from: old value of header field
 - *     @to: new value of header field
 - *     @flags: bits 0-3 - size of header field
 - *             other bits - reserved
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_l4_csum_replace(skb, offset, from, to, flags)
 - *     recompute TCP/UDP checksum
 - *     @skb: pointer to skb
 - *     @offset: offset within packet where TCP/UDP checksum is located
 - *     @from: old value of header field
 - *     @to: new value of header field
 - *     @flags: bits 0-3 - size of header field
 - *             bit 4 - is pseudo header
 - *             other bits - reserved
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_tail_call(ctx, prog_array_map, index)
 - *     jump into another BPF program
 - *     @ctx: context pointer passed to next program
 - *     @prog_array_map: pointer to map which type is BPF_MAP_TYPE_PROG_ARRAY
 - *     @index: index inside array that selects specific program to run
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_clone_redirect(skb, ifindex, flags)
 - *     redirect to another netdev
 - *     @skb: pointer to skb
 - *     @ifindex: ifindex of the net device
 - *     @flags: bit 0 - if set, redirect to ingress instead of egress
 - *             other bits - reserved
 - *     Return: 0 on success or negative error
 - *
 - * u64 bpf_get_current_pid_tgid(void)
 - *     Return: current->tgid << 32 | current->pid
 - *
 - * u64 bpf_get_current_uid_gid(void)
 - *     Return: current_gid << 32 | current_uid
 - *
 - * int bpf_get_current_comm(char *buf, int size_of_buf)
 - *     stores current->comm into buf
 - *     Return: 0 on success or negative error
 - *
 - * u32 bpf_get_cgroup_classid(skb)
 - *     retrieve a proc's classid
 - *     @skb: pointer to skb
 - *     Return: classid if != 0
 - *
 - * int bpf_skb_vlan_push(skb, vlan_proto, vlan_tci)
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_skb_vlan_pop(skb)
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_skb_get_tunnel_key(skb, key, size, flags)
 - * int bpf_skb_set_tunnel_key(skb, key, size, flags)
 - *     retrieve or populate tunnel metadata
 - *     @skb: pointer to skb
 - *     @key: pointer to 'struct bpf_tunnel_key'
 - *     @size: size of 'struct bpf_tunnel_key'
 - *     @flags: room for future extensions
 - *     Return: 0 on success or negative error
 - *
 - * u64 bpf_perf_event_read(map, flags)
 - *     read perf event counter value
 - *     @map: pointer to perf_event_array map
 - *     @flags: index of event in the map or bitmask flags
 - *     Return: value of perf event counter read or error code
 - *
 - * int bpf_redirect(ifindex, flags)
 - *     redirect to another netdev
 - *     @ifindex: ifindex of the net device
 - *     @flags: bit 0 - if set, redirect to ingress instead of egress
 - *             other bits - reserved
 - *     Return: TC_ACT_REDIRECT
 - *
 - * u32 bpf_get_route_realm(skb)
 - *     retrieve a dst's tclassid
 - *     @skb: pointer to skb
 - *     Return: realm if != 0
 - *
 - * int bpf_perf_event_output(ctx, map, flags, data, size)
 - *     output perf raw sample
 - *     @ctx: struct pt_regs*
 - *     @map: pointer to perf_event_array map
 - *     @flags: index of event in the map or bitmask flags
 - *     @data: data on stack to be output as raw data
 - *     @size: size of data
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_get_stackid(ctx, map, flags)
 - *     walk user or kernel stack and return id
 - *     @ctx: struct pt_regs*
 - *     @map: pointer to stack_trace map
 - *     @flags: bits 0-7 - numer of stack frames to skip
 - *             bit 8 - collect user stack instead of kernel
 - *             bit 9 - compare stacks by hash only
 - *             bit 10 - if two different stacks hash into the same stackid
 - *                      discard old
 - *             other bits - reserved
 - *     Return: >= 0 stackid on success or negative error
 - *
 - * s64 bpf_csum_diff(from, from_size, to, to_size, seed)
 - *     calculate csum diff
 - *     @from: raw from buffer
 - *     @from_size: length of from buffer
 - *     @to: raw to buffer
 - *     @to_size: length of to buffer
 - *     @seed: optional seed
 - *     Return: csum result or negative error code
 - *
 - * int bpf_skb_get_tunnel_opt(skb, opt, size)
 - *     retrieve tunnel options metadata
 - *     @skb: pointer to skb
 - *     @opt: pointer to raw tunnel option data
 - *     @size: size of @opt
 - *     Return: option size
 - *
 - * int bpf_skb_set_tunnel_opt(skb, opt, size)
 - *     populate tunnel options metadata
 - *     @skb: pointer to skb
 - *     @opt: pointer to raw tunnel option data
 - *     @size: size of @opt
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_skb_change_proto(skb, proto, flags)
 - *     Change protocol of the skb. Currently supported is v4 -> v6,
 - *     v6 -> v4 transitions. The helper will also resize the skb. eBPF
 - *     program is expected to fill the new headers via skb_store_bytes
 - *     and lX_csum_replace.
 - *     @skb: pointer to skb
 - *     @proto: new skb->protocol type
 - *     @flags: reserved
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_skb_change_type(skb, type)
 - *     Change packet type of skb.
 - *     @skb: pointer to skb
 - *     @type: new skb->pkt_type type
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_skb_under_cgroup(skb, map, index)
 - *     Check cgroup2 membership of skb
 - *     @skb: pointer to skb
 - *     @map: pointer to bpf_map in BPF_MAP_TYPE_CGROUP_ARRAY type
 - *     @index: index of the cgroup in the bpf_map
 - *     Return:
 - *       == 0 skb failed the cgroup2 descendant test
 - *       == 1 skb succeeded the cgroup2 descendant test
 - *        < 0 error
 - *
 - * u32 bpf_get_hash_recalc(skb)
 - *     Retrieve and possibly recalculate skb->hash.
 - *     @skb: pointer to skb
 - *     Return: hash
 - *
 - * u64 bpf_get_current_task(void)
 - *     Returns current task_struct
 - *     Return: current
 - *
 - * int bpf_probe_write_user(void *dst, void *src, int len)
 - *     safely attempt to write to a location
 - *     @dst: destination address in userspace
 - *     @src: source address on stack
 - *     @len: number of bytes to copy
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_current_task_under_cgroup(map, index)
 - *     Check cgroup2 membership of current task
 - *     @map: pointer to bpf_map in BPF_MAP_TYPE_CGROUP_ARRAY type
 - *     @index: index of the cgroup in the bpf_map
 - *     Return:
 - *       == 0 current failed the cgroup2 descendant test
 - *       == 1 current succeeded the cgroup2 descendant test
 - *        < 0 error
 - *
 - * int bpf_skb_change_tail(skb, len, flags)
 - *     The helper will resize the skb to the given new size, to be used f.e.
 - *     with control messages.
 - *     @skb: pointer to skb
 - *     @len: new skb length
 - *     @flags: reserved
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_skb_pull_data(skb, len)
 - *     The helper will pull in non-linear data in case the skb is non-linear
 - *     and not all of len are part of the linear section. Only needed for
 - *     read/write with direct packet access.
 - *     @skb: pointer to skb
 - *     @len: len to make read/writeable
 - *     Return: 0 on success or negative error
 - *
 - * s64 bpf_csum_update(skb, csum)
 - *     Adds csum into skb->csum in case of CHECKSUM_COMPLETE.
 - *     @skb: pointer to skb
 - *     @csum: csum to add
 - *     Return: csum on success or negative error
 - *
 - * void bpf_set_hash_invalid(skb)
 - *     Invalidate current skb->hash.
 - *     @skb: pointer to skb
 - *
 - * int bpf_get_numa_node_id()
 - *     Return: Id of current NUMA node.
 - *
 - * int bpf_skb_change_head()
 - *     Grows headroom of skb and adjusts MAC header offset accordingly.
 - *     Will extends/reallocae as required automatically.
 - *     May change skb data pointer and will thus invalidate any check
 - *     performed for direct packet access.
 - *     @skb: pointer to skb
 - *     @len: length of header to be pushed in front
 - *     @flags: Flags (unused for now)
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_xdp_adjust_head(xdp_md, delta)
 - *     Adjust the xdp_md.data by delta
 - *     @xdp_md: pointer to xdp_md
 - *     @delta: An positive/negative integer to be added to xdp_md.data
 - *     Return: 0 on success or negative on error
 - *
 - * int bpf_probe_read_str(void *dst, int size, const void *unsafe_ptr)
 - *     Copy a NUL terminated string from unsafe address. In case the string
 - *     length is smaller than size, the target is not padded with further NUL
 - *     bytes. In case the string length is larger than size, just count-1
 - *     bytes are copied and the last byte is set to NUL.
 - *     @dst: destination address
 - *     @size: maximum number of bytes to copy, including the trailing NUL
 - *     @unsafe_ptr: unsafe address
 - *     Return:
 - *       > 0 length of the string including the trailing NUL on success
 - *       < 0 error
 - *
 - * u64 bpf_get_socket_cookie(skb)
 - *     Get the cookie for the socket stored inside sk_buff.
 - *     @skb: pointer to skb
 - *     Return: 8 Bytes non-decreasing number on success or 0 if the socket
 - *     field is missing inside sk_buff
 - *
 - * u32 bpf_get_socket_uid(skb)
 - *     Get the owner uid of the socket stored inside sk_buff.
 - *     @skb: pointer to skb
 - *     Return: uid of the socket owner on success or overflowuid if failed.
 - */
 -#define __BPF_FUNC_MAPPER(FN)		\
 -	FN(unspec),			\
 -	FN(map_lookup_elem),		\
 -	FN(map_update_elem),		\
 -	FN(map_delete_elem),		\
 -	FN(probe_read),			\
 -	FN(ktime_get_ns),		\
 -	FN(trace_printk),		\
 -	FN(get_prandom_u32),		\
 -	FN(get_smp_processor_id),	\
 -	FN(skb_store_bytes),		\
 -	FN(l3_csum_replace),		\
 -	FN(l4_csum_replace),		\
 -	FN(tail_call),			\
 -	FN(clone_redirect),		\
 -	FN(get_current_pid_tgid),	\
 -	FN(get_current_uid_gid),	\
 -	FN(get_current_comm),		\
 -	FN(get_cgroup_classid),		\
 -	FN(skb_vlan_push),		\
 -	FN(skb_vlan_pop),		\
 -	FN(skb_get_tunnel_key),		\
 -	FN(skb_set_tunnel_key),		\
 -	FN(perf_event_read),		\
 -	FN(redirect),			\
 -	FN(get_route_realm),		\
 -	FN(perf_event_output),		\
 -	FN(skb_load_bytes),		\
 -	FN(get_stackid),		\
 -	FN(csum_diff),			\
 -	FN(skb_get_tunnel_opt),		\
 -	FN(skb_set_tunnel_opt),		\
 -	FN(skb_change_proto),		\
 -	FN(skb_change_type),		\
 -	FN(skb_under_cgroup),		\
 -	FN(get_hash_recalc),		\
 -	FN(get_current_task),		\
 -	FN(probe_write_user),		\
 -	FN(current_task_under_cgroup),	\
 -	FN(skb_change_tail),		\
 -	FN(skb_pull_data),		\
 -	FN(csum_update),		\
 -	FN(set_hash_invalid),		\
 -	FN(get_numa_node_id),		\
 -	FN(skb_change_head),		\
 -	FN(xdp_adjust_head),		\
 -	FN(probe_read_str),		\
 -	FN(get_socket_cookie),		\
 -	FN(get_socket_uid),
 -
 -/* integer value in 'imm' field of BPF_CALL instruction selects which helper
 - * function eBPF program intends to call
 - */
 -#define __BPF_ENUM_FN(x) BPF_FUNC_ ## x
 -enum bpf_func_id {
 -	__BPF_FUNC_MAPPER(__BPF_ENUM_FN)
 -	__BPF_FUNC_MAX_ID,
 -};
 -#undef __BPF_ENUM_FN
 -
 -/* All flags used by eBPF helper functions, placed here. */
 -
 -/* BPF_FUNC_skb_store_bytes flags. */
 -#define BPF_F_RECOMPUTE_CSUM		(1ULL << 0)
 -#define BPF_F_INVALIDATE_HASH		(1ULL << 1)
 -
 -/* BPF_FUNC_l3_csum_replace and BPF_FUNC_l4_csum_replace flags.
 - * First 4 bits are for passing the header field size.
 - */
 -#define BPF_F_HDR_FIELD_MASK		0xfULL
 -
 -/* BPF_FUNC_l4_csum_replace flags. */
 -#define BPF_F_PSEUDO_HDR		(1ULL << 4)
 -#define BPF_F_MARK_MANGLED_0		(1ULL << 5)
 -#define BPF_F_MARK_ENFORCE		(1ULL << 6)
 -
 -/* BPF_FUNC_clone_redirect and BPF_FUNC_redirect flags. */
 -#define BPF_F_INGRESS			(1ULL << 0)
 -
 -/* BPF_FUNC_skb_set_tunnel_key and BPF_FUNC_skb_get_tunnel_key flags. */
 -#define BPF_F_TUNINFO_IPV6		(1ULL << 0)
 -
 -/* BPF_FUNC_get_stackid flags. */
 -#define BPF_F_SKIP_FIELD_MASK		0xffULL
 -#define BPF_F_USER_STACK		(1ULL << 8)
 -#define BPF_F_FAST_STACK_CMP		(1ULL << 9)
 -#define BPF_F_REUSE_STACKID		(1ULL << 10)
 -
 -/* BPF_FUNC_skb_set_tunnel_key flags. */
 -#define BPF_F_ZERO_CSUM_TX		(1ULL << 1)
 -#define BPF_F_DONT_FRAGMENT		(1ULL << 2)
 -
 -/* BPF_FUNC_perf_event_output and BPF_FUNC_perf_event_read flags. */
 -#define BPF_F_INDEX_MASK		0xffffffffULL
 -#define BPF_F_CURRENT_CPU		BPF_F_INDEX_MASK
 -/* BPF_FUNC_perf_event_output for sk_buff input context. */
 -#define BPF_F_CTXLEN_MASK		(0xfffffULL << 32)
 -
 -/* user accessible mirror of in-kernel sk_buff.
 - * new fields can only be added to the end of this structure
 - */
 -struct __sk_buff {
 -	__u32 len;
 -	__u32 pkt_type;
 -	__u32 mark;
 -	__u32 queue_mapping;
 -	__u32 protocol;
 -	__u32 vlan_present;
 -	__u32 vlan_tci;
 -	__u32 vlan_proto;
 -	__u32 priority;
 -	__u32 ingress_ifindex;
 -	__u32 ifindex;
 -	__u32 tc_index;
 -	__u32 cb[5];
 -	__u32 hash;
 -	__u32 tc_classid;
 -	__u32 data;
 -	__u32 data_end;
 -	__u32 napi_id;
 -};
 -
 -struct bpf_tunnel_key {
 -	__u32 tunnel_id;
 -	union {
 -		__u32 remote_ipv4;
 -		__u32 remote_ipv6[4];
 -	};
 -	__u8 tunnel_tos;
 -	__u8 tunnel_ttl;
 -	__u16 tunnel_ext;
 -	__u32 tunnel_label;
 -};
 -
 -/* Generic BPF return codes which all BPF program types may support.
 - * The values are binary compatible with their TC_ACT_* counter-part to
 - * provide backwards compatibility with existing SCHED_CLS and SCHED_ACT
 - * programs.
 - *
 - * XDP is handled seprately, see XDP_*.
 - */
 -enum bpf_ret_code {
 -	BPF_OK = 0,
 -	/* 1 reserved */
 -	BPF_DROP = 2,
 -	/* 3-6 reserved */
 -	BPF_REDIRECT = 7,
 -	/* >127 are reserved for prog type specific return codes */
 -};
 -
 -struct bpf_sock {
 -	__u32 bound_dev_if;
 -	__u32 family;
 -	__u32 type;
 -	__u32 protocol;
 -};
 -
 -#define XDP_PACKET_HEADROOM 256
 -
  /* User return codes for XDP prog type.
   * A valid XDP program must return one of these defined values. All other
   * return codes are reserved for future use. Unknown return codes will result
@@@ -155,14 -693,25 +174,37 @@@ struct xdp_md 
  	__u32 data_end;
  };
  
++<<<<<<< HEAD
 +#define XDP_PACKET_HEADROOM 256
 +
 +/* integer value in 'imm' field of BPF_CALL instruction selects which helper
 + * function eBPF program intends to call
 + */
 +enum bpf_func_id {
 +	BPF_FUNC_unspec,
 +	__BPF_FUNC_MAX_ID,
 +};
++=======
+ #define BPF_TAG_SIZE	8
+ 
+ struct bpf_prog_info {
+ 	__u32 type;
+ 	__u32 id;
+ 	__u8  tag[BPF_TAG_SIZE];
+ 	__u32 jited_prog_len;
+ 	__u32 xlated_prog_len;
+ 	__aligned_u64 jited_prog_insns;
+ 	__aligned_u64 xlated_prog_insns;
+ } __attribute__((aligned(8)));
+ 
+ struct bpf_map_info {
+ 	__u32 type;
+ 	__u32 id;
+ 	__u32 key_size;
+ 	__u32 value_size;
+ 	__u32 max_entries;
+ 	__u32 map_flags;
+ } __attribute__((aligned(8)));
++>>>>>>> 1e2709769086 (bpf: Add BPF_OBJ_GET_INFO_BY_FD)
  
  #endif /* _UAPI__LINUX_BPF_H__ */
* Unmerged path kernel/bpf/syscall.c
* Unmerged path include/linux/filter.h
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path kernel/bpf/syscall.c
