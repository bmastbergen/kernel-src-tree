iio:core: add a callback to allow drivers to provide _available attributes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iio] core: add a callback to allow drivers to provide _available attributes (Tony Camuso) [1559170]
Rebuild_FUZZ: 97.22%
commit-author Jonathan Cameron <jic23@kernel.org>
commit 51239600074bc9979b0a0e83b72c726d7dcc3132
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/51239600.failed

A large number of attributes can only take a limited range of values.
Currently in IIO this is handled by directly registering additional
*_available attributes thus providing this information to userspace.

It is desirable to provide this information via the core for much the same
reason this was done for the actual channel information attributes in the
first place.  If it isn't there, then it can only really be accessed from
userspace.  Other in kernel IIO consumers have no access to what valid
parameters are.

Two forms are currently supported:
* list of values in one particular IIO_VAL_* format.
	e.g. 1.300000 1.500000 1.730000
* range specification with a step size:
	e.g. [1.000000 0.500000 2.500000]
	equivalent to 1.000000 1.5000000 2.000000 2.500000

An addition set of masks are used to allow different sharing rules for the
*_available attributes generated.

This allows for example:

in_accel_x_offset
in_accel_y_offset
in_accel_offset_available.

We could have gone with having a specification for each and every
info_mask element but that would have meant changing the existing userspace
ABI.  This approach does not.

	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
[forward ported, added some docs and fixed buffer overflows /peda]
	Acked-by: Daniel Baluta <daniel.baluta@intel.com>
	Signed-off-by: Peter Rosin <peda@axentia.se>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit 51239600074bc9979b0a0e83b72c726d7dcc3132)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iio/industrialio-core.c
#	include/linux/iio/iio.h
diff --cc drivers/iio/industrialio-core.c
index 87201424abaf,aaca42862389..000000000000
--- a/drivers/iio/industrialio-core.c
+++ b/drivers/iio/industrialio-core.c
@@@ -383,49 -495,163 +383,206 @@@ ssize_t iio_enum_write(struct iio_dev *
  }
  EXPORT_SYMBOL_GPL(iio_enum_write);
  
++<<<<<<< HEAD
 +/**
 + * iio_format_value() - Formats a IIO value into its string representation
 + * @buf: The buffer to which the formated value gets written
 + * @type: One of the IIO_VAL_... constants. This decides how the val and val2
 + *        parameters are formatted.
 + * @val: First part of the value, exact meaning depends on the type parameter.
 + * @val2: Second part of the value, exact meaning depends on the type parameter.
++=======
+ static const struct iio_mount_matrix iio_mount_idmatrix = {
+ 	.rotation = {
+ 		"1", "0", "0",
+ 		"0", "1", "0",
+ 		"0", "0", "1"
+ 	}
+ };
+ 
+ static int iio_setup_mount_idmatrix(const struct device *dev,
+ 				    struct iio_mount_matrix *matrix)
+ {
+ 	*matrix = iio_mount_idmatrix;
+ 	dev_info(dev, "mounting matrix not found: using identity...\n");
+ 	return 0;
+ }
+ 
+ ssize_t iio_show_mount_matrix(struct iio_dev *indio_dev, uintptr_t priv,
+ 			      const struct iio_chan_spec *chan, char *buf)
+ {
+ 	const struct iio_mount_matrix *mtx = ((iio_get_mount_matrix_t *)
+ 					      priv)(indio_dev, chan);
+ 
+ 	if (IS_ERR(mtx))
+ 		return PTR_ERR(mtx);
+ 
+ 	if (!mtx)
+ 		mtx = &iio_mount_idmatrix;
+ 
+ 	return snprintf(buf, PAGE_SIZE, "%s, %s, %s; %s, %s, %s; %s, %s, %s\n",
+ 			mtx->rotation[0], mtx->rotation[1], mtx->rotation[2],
+ 			mtx->rotation[3], mtx->rotation[4], mtx->rotation[5],
+ 			mtx->rotation[6], mtx->rotation[7], mtx->rotation[8]);
+ }
+ EXPORT_SYMBOL_GPL(iio_show_mount_matrix);
+ 
+ /**
+  * of_iio_read_mount_matrix() - retrieve iio device mounting matrix from
+  *                              device-tree "mount-matrix" property
+  * @dev:	device the mounting matrix property is assigned to
+  * @propname:	device specific mounting matrix property name
+  * @matrix:	where to store retrieved matrix
+  *
+  * If device is assigned no mounting matrix property, a default 3x3 identity
+  * matrix will be filled in.
+  *
+  * Return: 0 if success, or a negative error code on failure.
   */
- ssize_t iio_format_value(char *buf, unsigned int type, int val, int val2)
+ #ifdef CONFIG_OF
+ int of_iio_read_mount_matrix(const struct device *dev,
+ 			     const char *propname,
+ 			     struct iio_mount_matrix *matrix)
+ {
+ 	if (dev->of_node) {
+ 		int err = of_property_read_string_array(dev->of_node,
+ 				propname, matrix->rotation,
+ 				ARRAY_SIZE(iio_mount_idmatrix.rotation));
+ 
+ 		if (err == ARRAY_SIZE(iio_mount_idmatrix.rotation))
+ 			return 0;
+ 
+ 		if (err >= 0)
+ 			/* Invalid number of matrix entries. */
+ 			return -EINVAL;
+ 
+ 		if (err != -EINVAL)
+ 			/* Invalid matrix declaration format. */
+ 			return err;
+ 	}
+ 
+ 	/* Matrix was not declared at all: fallback to identity. */
+ 	return iio_setup_mount_idmatrix(dev, matrix);
+ }
+ #else
+ int of_iio_read_mount_matrix(const struct device *dev,
+ 			     const char *propname,
+ 			     struct iio_mount_matrix *matrix)
+ {
+ 	return iio_setup_mount_idmatrix(dev, matrix);
+ }
+ #endif
+ EXPORT_SYMBOL(of_iio_read_mount_matrix);
+ 
+ static ssize_t __iio_format_value(char *buf, size_t len, unsigned int type,
+ 				  int size, const int *vals)
  {
  	unsigned long long tmp;
+ 	int tmp0, tmp1;
  	bool scale_db = false;
  
+ 	switch (type) {
+ 	case IIO_VAL_INT:
+ 		return snprintf(buf, len, "%d", vals[0]);
+ 	case IIO_VAL_INT_PLUS_MICRO_DB:
+ 		scale_db = true;
+ 	case IIO_VAL_INT_PLUS_MICRO:
+ 		if (vals[1] < 0)
+ 			return snprintf(buf, len, "-%d.%06u%s", abs(vals[0]),
+ 					-vals[1], scale_db ? " dB" : "");
+ 		else
+ 			return snprintf(buf, len, "%d.%06u%s", vals[0], vals[1],
+ 					scale_db ? " dB" : "");
+ 	case IIO_VAL_INT_PLUS_NANO:
+ 		if (vals[1] < 0)
+ 			return snprintf(buf, len, "-%d.%09u", abs(vals[0]),
+ 					-vals[1]);
+ 		else
+ 			return snprintf(buf, len, "%d.%09u", vals[0], vals[1]);
+ 	case IIO_VAL_FRACTIONAL:
+ 		tmp = div_s64((s64)vals[0] * 1000000000LL, vals[1]);
+ 		tmp1 = vals[1];
+ 		tmp0 = (int)div_s64_rem(tmp, 1000000000, &tmp1);
+ 		return snprintf(buf, len, "%d.%09u", tmp0, abs(tmp1));
+ 	case IIO_VAL_FRACTIONAL_LOG2:
+ 		tmp = (s64)vals[0] * 1000000000LL >> vals[1];
+ 		tmp1 = do_div(tmp, 1000000000LL);
+ 		tmp0 = tmp;
+ 		return snprintf(buf, len, "%d.%09u", tmp0, tmp1);
+ 	case IIO_VAL_INT_MULTIPLE:
+ 	{
+ 		int i;
+ 		int l = 0;
+ 
+ 		for (i = 0; i < size; ++i) {
+ 			l += snprintf(&buf[l], len - l, "%d ", vals[i]);
+ 			if (l >= len)
+ 				break;
+ 		}
+ 		return l;
+ 	}
+ 	default:
+ 		return 0;
+ 	}
+ }
+ 
+ /**
+  * iio_format_value() - Formats a IIO value into its string representation
+  * @buf:	The buffer to which the formatted value gets written
+  *		which is assumed to be big enough (i.e. PAGE_SIZE).
+  * @type:	One of the IIO_VAL_... constants. This decides how the val
+  *		and val2 parameters are formatted.
+  * @size:	Number of IIO value entries contained in vals
+  * @vals:	Pointer to the values, exact meaning depends on the
+  *		type parameter.
+  *
+  * Return: 0 by default, a negative number on failure or the
+  *	   total number of characters written for a type that belongs
+  *	   to the IIO_VAL_... constant.
++>>>>>>> 51239600074b (iio:core: add a callback to allow drivers to provide _available attributes)
+  */
 -ssize_t iio_format_value(char *buf, unsigned int type, int size, int *vals)
++ssize_t iio_format_value(char *buf, unsigned int type, int val, int val2)
+ {
+ 	ssize_t len;
+ 
++<<<<<<< HEAD
 +	switch (type) {
 +	case IIO_VAL_INT:
 +		return sprintf(buf, "%d\n", val);
 +	case IIO_VAL_INT_PLUS_MICRO_DB:
 +		scale_db = true;
 +	case IIO_VAL_INT_PLUS_MICRO:
 +		if (val2 < 0)
 +			return sprintf(buf, "-%ld.%06u%s\n", abs(val), -val2,
 +				scale_db ? " dB" : "");
 +		else
 +			return sprintf(buf, "%d.%06u%s\n", val, val2,
 +				scale_db ? " dB" : "");
 +	case IIO_VAL_INT_PLUS_NANO:
 +		if (val2 < 0)
 +			return sprintf(buf, "-%ld.%09u\n", abs(val), -val2);
 +		else
 +			return sprintf(buf, "%d.%09u\n", val, val2);
 +	case IIO_VAL_FRACTIONAL:
 +		tmp = div_s64((s64)val * 1000000000LL, val2);
 +		val2 = do_div(tmp, 1000000000LL);
 +		val = tmp;
 +		return sprintf(buf, "%d.%09u\n", val, val2);
 +	case IIO_VAL_FRACTIONAL_LOG2:
 +		tmp = (s64)val * 1000000000LL >> val2;
 +		val2 = do_div(tmp, 1000000000LL);
 +		val = tmp;
 +		return sprintf(buf, "%d.%09u\n", val, val2);
 +	default:
 +		return 0;
 +	}
++=======
+ 	len = __iio_format_value(buf, PAGE_SIZE, type, size, vals);
+ 	if (len >= PAGE_SIZE - 1)
+ 		return -EFBIG;
+ 
+ 	return len + sprintf(buf + len, "\n");
++>>>>>>> 51239600074b (iio:core: add a callback to allow drivers to provide _available attributes)
  }
  EXPORT_SYMBOL_GPL(iio_format_value);
  
@@@ -442,9 -677,122 +599,122 @@@ static ssize_t iio_read_channel_info(st
  	if (ret < 0)
  		return ret;
  
 -	return iio_format_value(buf, ret, val_len, vals);
 +	return iio_format_value(buf, ret, val, val2);
  }
  
+ static ssize_t iio_format_avail_list(char *buf, const int *vals,
+ 				     int type, int length)
+ {
+ 	int i;
+ 	ssize_t len = 0;
+ 
+ 	switch (type) {
+ 	case IIO_VAL_INT:
+ 		for (i = 0; i < length; i++) {
+ 			len += __iio_format_value(buf + len, PAGE_SIZE - len,
+ 						  type, 1, &vals[i]);
+ 			if (len >= PAGE_SIZE)
+ 				return -EFBIG;
+ 			if (i < length - 1)
+ 				len += snprintf(buf + len, PAGE_SIZE - len,
+ 						" ");
+ 			else
+ 				len += snprintf(buf + len, PAGE_SIZE - len,
+ 						"\n");
+ 			if (len >= PAGE_SIZE)
+ 				return -EFBIG;
+ 		}
+ 		break;
+ 	default:
+ 		for (i = 0; i < length / 2; i++) {
+ 			len += __iio_format_value(buf + len, PAGE_SIZE - len,
+ 						  type, 2, &vals[i * 2]);
+ 			if (len >= PAGE_SIZE)
+ 				return -EFBIG;
+ 			if (i < length / 2 - 1)
+ 				len += snprintf(buf + len, PAGE_SIZE - len,
+ 						" ");
+ 			else
+ 				len += snprintf(buf + len, PAGE_SIZE - len,
+ 						"\n");
+ 			if (len >= PAGE_SIZE)
+ 				return -EFBIG;
+ 		}
+ 	}
+ 
+ 	return len;
+ }
+ 
+ static ssize_t iio_format_avail_range(char *buf, const int *vals, int type)
+ {
+ 	int i;
+ 	ssize_t len;
+ 
+ 	len = snprintf(buf, PAGE_SIZE, "[");
+ 	switch (type) {
+ 	case IIO_VAL_INT:
+ 		for (i = 0; i < 3; i++) {
+ 			len += __iio_format_value(buf + len, PAGE_SIZE - len,
+ 						  type, 1, &vals[i]);
+ 			if (len >= PAGE_SIZE)
+ 				return -EFBIG;
+ 			if (i < 2)
+ 				len += snprintf(buf + len, PAGE_SIZE - len,
+ 						" ");
+ 			else
+ 				len += snprintf(buf + len, PAGE_SIZE - len,
+ 						"]\n");
+ 			if (len >= PAGE_SIZE)
+ 				return -EFBIG;
+ 		}
+ 		break;
+ 	default:
+ 		for (i = 0; i < 3; i++) {
+ 			len += __iio_format_value(buf + len, PAGE_SIZE - len,
+ 						  type, 2, &vals[i * 2]);
+ 			if (len >= PAGE_SIZE)
+ 				return -EFBIG;
+ 			if (i < 2)
+ 				len += snprintf(buf + len, PAGE_SIZE - len,
+ 						" ");
+ 			else
+ 				len += snprintf(buf + len, PAGE_SIZE - len,
+ 						"]\n");
+ 			if (len >= PAGE_SIZE)
+ 				return -EFBIG;
+ 		}
+ 	}
+ 
+ 	return len;
+ }
+ 
+ static ssize_t iio_read_channel_info_avail(struct device *dev,
+ 					   struct device_attribute *attr,
+ 					   char *buf)
+ {
+ 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+ 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+ 	const int *vals;
+ 	int ret;
+ 	int length;
+ 	int type;
+ 
+ 	ret = indio_dev->info->read_avail(indio_dev, this_attr->c,
+ 					  &vals, &type, &length,
+ 					  this_attr->address);
+ 
+ 	if (ret < 0)
+ 		return ret;
+ 	switch (ret) {
+ 	case IIO_AVAIL_LIST:
+ 		return iio_format_avail_list(buf, vals, type, length);
+ 	case IIO_AVAIL_RANGE:
+ 		return iio_format_avail_range(buf, vals, type);
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
  /**
   * iio_str_to_fixpoint() - Parse a fixed-point number from a string
   * @str: The string to parse
@@@ -719,6 -1081,68 +989,71 @@@ error_ret
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int iio_device_add_info_mask_type(struct iio_dev *indio_dev,
+ 					 struct iio_chan_spec const *chan,
+ 					 enum iio_shared_by shared_by,
+ 					 const long *infomask)
+ {
+ 	int i, ret, attrcount = 0;
+ 
+ 	for_each_set_bit(i, infomask, sizeof(infomask)*8) {
+ 		if (i >= ARRAY_SIZE(iio_chan_info_postfix))
+ 			return -EINVAL;
+ 		ret = __iio_add_chan_devattr(iio_chan_info_postfix[i],
+ 					     chan,
+ 					     &iio_read_channel_info,
+ 					     &iio_write_channel_info,
+ 					     i,
+ 					     shared_by,
+ 					     &indio_dev->dev,
+ 					     &indio_dev->channel_attr_list);
+ 		if ((ret == -EBUSY) && (shared_by != IIO_SEPARATE))
+ 			continue;
+ 		else if (ret < 0)
+ 			return ret;
+ 		attrcount++;
+ 	}
+ 
+ 	return attrcount;
+ }
+ 
+ static int iio_device_add_info_mask_type_avail(struct iio_dev *indio_dev,
+ 					       struct iio_chan_spec const *chan,
+ 					       enum iio_shared_by shared_by,
+ 					       const long *infomask)
+ {
+ 	int i, ret, attrcount = 0;
+ 	char *avail_postfix;
+ 
+ 	for_each_set_bit(i, infomask, sizeof(infomask) * 8) {
+ 		avail_postfix = kasprintf(GFP_KERNEL,
+ 					  "%s_available",
+ 					  iio_chan_info_postfix[i]);
+ 		if (!avail_postfix)
+ 			return -ENOMEM;
+ 
+ 		ret = __iio_add_chan_devattr(avail_postfix,
+ 					     chan,
+ 					     &iio_read_channel_info_avail,
+ 					     NULL,
+ 					     i,
+ 					     shared_by,
+ 					     &indio_dev->dev,
+ 					     &indio_dev->channel_attr_list);
+ 		kfree(avail_postfix);
+ 		if ((ret == -EBUSY) && (shared_by != IIO_SEPARATE))
+ 			continue;
+ 		else if (ret < 0)
+ 			return ret;
+ 		attrcount++;
+ 	}
+ 
+ 	return attrcount;
+ }
+ 
++>>>>>>> 51239600074b (iio:core: add a callback to allow drivers to provide _available attributes)
  static int iio_device_add_channel_sysfs(struct iio_dev *indio_dev,
  					struct iio_chan_spec const *chan)
  {
@@@ -728,36 -1151,63 +1063,96 @@@
  
  	if (chan->channel < 0)
  		return 0;
++<<<<<<< HEAD
 +	for_each_set_bit(i, &chan->info_mask_separate, sizeof(long)*8) {
 +		ret = __iio_add_chan_devattr(iio_chan_info_postfix[i],
 +					     chan,
 +					     &iio_read_channel_info,
 +					     &iio_write_channel_info,
 +					     i,
 +					     0,
 +					     &indio_dev->dev,
 +					     &indio_dev->channel_attr_list);
 +		if (ret < 0)
 +			goto error_ret;
 +		attrcount++;
 +	}
 +	for_each_set_bit(i, &chan->info_mask_shared_by_type, sizeof(long)*8) {
 +		ret = __iio_add_chan_devattr(iio_chan_info_postfix[i],
 +					     chan,
 +					     &iio_read_channel_info,
 +					     &iio_write_channel_info,
 +					     i,
 +					     1,
 +					     &indio_dev->dev,
 +					     &indio_dev->channel_attr_list);
 +		if (ret == -EBUSY) {
 +			ret = 0;
 +			continue;
 +		} else if (ret < 0) {
 +			goto error_ret;
 +		}
 +		attrcount++;
 +	}
++=======
+ 	ret = iio_device_add_info_mask_type(indio_dev, chan,
+ 					    IIO_SEPARATE,
+ 					    &chan->info_mask_separate);
+ 	if (ret < 0)
+ 		return ret;
+ 	attrcount += ret;
+ 
+ 	ret = iio_device_add_info_mask_type_avail(indio_dev, chan,
+ 						  IIO_SEPARATE,
+ 						  &chan->
+ 						  info_mask_separate_available);
+ 	if (ret < 0)
+ 		return ret;
+ 	attrcount += ret;
+ 
+ 	ret = iio_device_add_info_mask_type(indio_dev, chan,
+ 					    IIO_SHARED_BY_TYPE,
+ 					    &chan->info_mask_shared_by_type);
+ 	if (ret < 0)
+ 		return ret;
+ 	attrcount += ret;
+ 
+ 	ret = iio_device_add_info_mask_type_avail(indio_dev, chan,
+ 						  IIO_SHARED_BY_TYPE,
+ 						  &chan->
+ 						  info_mask_shared_by_type_available);
+ 	if (ret < 0)
+ 		return ret;
+ 	attrcount += ret;
+ 
+ 	ret = iio_device_add_info_mask_type(indio_dev, chan,
+ 					    IIO_SHARED_BY_DIR,
+ 					    &chan->info_mask_shared_by_dir);
+ 	if (ret < 0)
+ 		return ret;
+ 	attrcount += ret;
+ 
+ 	ret = iio_device_add_info_mask_type_avail(indio_dev, chan,
+ 						  IIO_SHARED_BY_DIR,
+ 						  &chan->info_mask_shared_by_dir_available);
+ 	if (ret < 0)
+ 		return ret;
+ 	attrcount += ret;
+ 
+ 	ret = iio_device_add_info_mask_type(indio_dev, chan,
+ 					    IIO_SHARED_BY_ALL,
+ 					    &chan->info_mask_shared_by_all);
+ 	if (ret < 0)
+ 		return ret;
+ 	attrcount += ret;
++>>>>>>> 51239600074b (iio:core: add a callback to allow drivers to provide _available attributes)
+ 
+ 	ret = iio_device_add_info_mask_type_avail(indio_dev, chan,
+ 						  IIO_SHARED_BY_ALL,
+ 						  &chan->info_mask_shared_by_all_available);
+ 	if (ret < 0)
+ 		return ret;
+ 	attrcount += ret;
  
  	if (chan->ext_info) {
  		unsigned int i = 0;
diff --cc include/linux/iio/iio.h
index aa2b11757b7e,849d524645e8..000000000000
--- a/include/linux/iio/iio.h
+++ b/include/linux/iio/iio.h
@@@ -179,9 -225,22 +179,26 @@@ struct iio_event_spec 
   *			endianness:	little or big endian
   * @info_mask_separate: What information is to be exported that is specific to
   *			this channel.
+  * @info_mask_separate_available: What availability information is to be
+  *			exported that is specific to this channel.
   * @info_mask_shared_by_type: What information is to be exported that is shared
   *			by all channels of the same type.
++<<<<<<< HEAD
 + * @event_mask:		What events can this channel produce.
++=======
+  * @info_mask_shared_by_type_available: What availability information is to be
+  *			exported that is shared by all channels of the same
+  *			type.
+  * @info_mask_shared_by_dir: What information is to be exported that is shared
+  *			by all channels of the same direction.
+  * @info_mask_shared_by_dir_available: What availability information is to be
+  *			exported that is shared by all channels of the same
+  *			direction.
+  * @info_mask_shared_by_all: What information is to be exported that is shared
+  *			by all channels.
+  * @info_mask_shared_by_all_available: What availability information is to be
+  *			exported that is shared by all channels.
++>>>>>>> 51239600074b (iio:core: add a callback to allow drivers to provide _available attributes)
   * @event_spec:		Array of events which should be registered for this
   *			channel.
   * @num_event_specs:	Size of the event_spec array.
@@@ -220,8 -279,13 +237,17 @@@ struct iio_chan_spec 
  		enum iio_endian endianness;
  	} scan_type;
  	long			info_mask_separate;
+ 	long			info_mask_separate_available;
  	long			info_mask_shared_by_type;
++<<<<<<< HEAD
 +	long			event_mask;
++=======
+ 	long			info_mask_shared_by_type_available;
+ 	long			info_mask_shared_by_dir;
+ 	long			info_mask_shared_by_dir_available;
+ 	long			info_mask_shared_by_all;
+ 	long			info_mask_shared_by_all_available;
++>>>>>>> 51239600074b (iio:core: add a callback to allow drivers to provide _available attributes)
  	const struct iio_event_spec *event_spec;
  	unsigned int		num_event_specs;
  	const struct iio_chan_spec_ext_info *ext_info;
@@@ -291,6 -355,22 +317,25 @@@ struct iio_dev
   *			the channel in question.  Return value will specify the
   *			type of value returned by the device. val and val2 will
   *			contain the elements making up the returned value.
++<<<<<<< HEAD
++=======
+  * @read_raw_multi:	function to return values from the device.
+  *			mask specifies which value. Note 0 means a reading of
+  *			the channel in question.  Return value will specify the
+  *			type of value returned by the device. vals pointer
+  *			contain the elements making up the returned value.
+  *			max_len specifies maximum number of elements
+  *			vals pointer can contain. val_len is used to return
+  *			length of valid elements in vals.
+  * @read_avail:		function to return the available values from the device.
+  *			mask specifies which value. Note 0 means the available
+  *			values for the channel in question.  Return value
+  *			specifies if a IIO_AVAIL_LIST or a IIO_AVAIL_RANGE is
+  *			returned in vals. The type of the vals are returned in
+  *			type and the number of vals is returned in length. For
+  *			ranges, there are always three vals returned; min, step
+  *			and max. For lists, all possible values are enumerated.
++>>>>>>> 51239600074b (iio:core: add a callback to allow drivers to provide _available attributes)
   * @write_raw:		function to write a value to the device.
   *			Parameters are the same as for read_raw.
   * @write_raw_get_fmt:	callback function to query the expected
@@@ -330,6 -412,20 +375,23 @@@ struct iio_info 
  			int *val2,
  			long mask);
  
++<<<<<<< HEAD
++=======
+ 	int (*read_raw_multi)(struct iio_dev *indio_dev,
+ 			struct iio_chan_spec const *chan,
+ 			int max_len,
+ 			int *vals,
+ 			int *val_len,
+ 			long mask);
+ 
+ 	int (*read_avail)(struct iio_dev *indio_dev,
+ 			  struct iio_chan_spec const *chan,
+ 			  const int **vals,
+ 			  int *type,
+ 			  int *length,
+ 			  long mask);
+ 
++>>>>>>> 51239600074b (iio:core: add a callback to allow drivers to provide _available attributes)
  	int (*write_raw)(struct iio_dev *indio_dev,
  			 struct iio_chan_spec const *chan,
  			 int val,
* Unmerged path drivers/iio/industrialio-core.c
* Unmerged path include/linux/iio/iio.h
diff --git a/include/linux/iio/types.h b/include/linux/iio/types.h
index 6c2c23e8851f..abea578aa70e 100644
--- a/include/linux/iio/types.h
+++ b/include/linux/iio/types.h
@@ -97,4 +97,9 @@ enum iio_event_direction {
 #define IIO_VAL_FRACTIONAL 10
 #define IIO_VAL_FRACTIONAL_LOG2 11
 
+enum iio_available_type {
+	IIO_AVAIL_LIST,
+	IIO_AVAIL_RANGE,
+};
+
 #endif /* _IIO_TYPES_H_ */
