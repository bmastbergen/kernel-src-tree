i40e/i40evf: Clean up logic for adaptive ITR

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Alexander Duyck <alexander.h.duyck@intel.com>
commit 71dc371993625b4b1ae26214af74427765bfa3a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/71dc3719.failed

The logic for dynamic ITR update is confusing at best as there were odd
paths chosen for how to find the rings associated with a given queue based
on the vector index and other inconsistencies throughout the code.

This patch is an attempt to clean up the logic so that we can more easily
understand what is going on. Specifically if there is a Rx or Tx ring that
is enabled in dynamic mode on the q_vector it is allowed to override the
other side of the interrupt moderation. While it isn't correct all this
patch is doing is cleaning up the logic for now so that when we come
through and fix it we can more easily identify that this is wrong.

The other big change made here is that we replace references to:
	vsi->rx_rings[q_vector->v_idx]->itr_setting
with:
	q_vector->rx.ring->itr_setting

The general idea is we can avoid the long pointer chase since just
accessing q_vector->rx.ring is a single pointer access versus having to
chase down vsi->rx_rings, and then finding the pointer in the array, and
finally chasing down the itr_setting from there.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 71dc371993625b4b1ae26214af74427765bfa3a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_txrx.c
#	drivers/net/ethernet/intel/i40evf/i40e_txrx.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 3da88b6829fe,6b3fe5d26dc1..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@@ -2227,15 -2291,6 +2230,18 @@@ static u32 i40e_buildreg_itr(const int 
  
  /* a small macro to shorten up some long lines */
  #define INTREG I40E_PFINT_DYN_CTLN
++<<<<<<< HEAD
 +static inline int get_rx_itr(struct i40e_vsi *vsi, int idx)
 +{
 +	return vsi->rx_rings[idx]->rx_itr_setting;
 +}
 +
 +static inline int get_tx_itr(struct i40e_vsi *vsi, int idx)
 +{
 +	return vsi->tx_rings[idx]->tx_itr_setting;
 +}
++=======
++>>>>>>> 71dc37199362 (i40e/i40evf: Clean up logic for adaptive ITR)
  
  /**
   * i40e_update_enable_itr - Update itr and re-enable MSIX interrupt
@@@ -2258,29 -2311,15 +2262,22 @@@ static inline void i40e_update_enable_i
  		return;
  	}
  
++<<<<<<< HEAD
 +	/* avoid dynamic calculation if in countdown mode OR if
 +	 * all dynamic is disabled
 +	 */
 +	rxval = txval = i40e_buildreg_itr(I40E_ITR_NONE, 0);
++=======
+ 	txval = i40e_buildreg_itr(I40E_ITR_NONE, 0);
++>>>>>>> 71dc37199362 (i40e/i40evf: Clean up logic for adaptive ITR)
  
- 	rx_itr_setting = get_rx_itr(vsi, idx);
- 	tx_itr_setting = get_tx_itr(vsi, idx);
- 
- 	if (q_vector->itr_countdown > 0 ||
- 	    (!ITR_IS_DYNAMIC(rx_itr_setting) &&
- 	     !ITR_IS_DYNAMIC(tx_itr_setting))) {
+ 	/* avoid dynamic calculation if in countdown mode */
+ 	if (q_vector->itr_countdown > 0)
  		goto enable_int;
- 	}
  
- 	if (ITR_IS_DYNAMIC(rx_itr_setting)) {
- 		rx = i40e_set_new_dynamic_itr(&q_vector->rx);
- 		rxval = i40e_buildreg_itr(I40E_RX_ITR, q_vector->rx.itr);
- 	}
- 
- 	if (ITR_IS_DYNAMIC(tx_itr_setting)) {
- 		tx = i40e_set_new_dynamic_itr(&q_vector->tx);
- 		txval = i40e_buildreg_itr(I40E_TX_ITR, q_vector->tx.itr);
- 	}
+ 	/* these will return false if dynamic mode is disabled */
+ 	rx = i40e_set_new_dynamic_itr(&q_vector->rx);
+ 	tx = i40e_set_new_dynamic_itr(&q_vector->tx);
  
  	if (rx || tx) {
  		/* get the higher of the two ITR adjustments and
diff --cc drivers/net/ethernet/intel/i40evf/i40e_txrx.c
index 7e68e20923c6,3fd7e9731f49..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
@@@ -1481,19 -1474,6 +1484,22 @@@ static u32 i40e_buildreg_itr(const int 
  
  /* a small macro to shorten up some long lines */
  #define INTREG I40E_VFINT_DYN_CTLN1
++<<<<<<< HEAD
 +static inline int get_rx_itr(struct i40e_vsi *vsi, int idx)
 +{
 +	struct i40evf_adapter *adapter = vsi->back;
 +
 +	return adapter->rx_rings[idx].rx_itr_setting;
 +}
 +
 +static inline int get_tx_itr(struct i40e_vsi *vsi, int idx)
 +{
 +	struct i40evf_adapter *adapter = vsi->back;
 +
 +	return adapter->tx_rings[idx].tx_itr_setting;
 +}
++=======
++>>>>>>> 71dc37199362 (i40e/i40evf: Clean up logic for adaptive ITR)
  
  /**
   * i40e_update_enable_itr - Update itr and re-enable MSIX interrupt
@@@ -1506,33 -1486,17 +1512,24 @@@ static inline void i40e_update_enable_i
  {
  	struct i40e_hw *hw = &vsi->back->hw;
  	bool rx = false, tx = false;
- 	u32 rxval, txval;
- 	int idx = q_vector->v_idx;
- 	int rx_itr_setting, tx_itr_setting;
+ 	u32 txval;
  
++<<<<<<< HEAD
 +	/* avoid dynamic calculation if in countdown mode OR if
 +	 * all dynamic is disabled
 +	 */
 +	rxval = txval = i40e_buildreg_itr(I40E_ITR_NONE, 0);
++=======
+ 	txval = i40e_buildreg_itr(I40E_ITR_NONE, 0);
++>>>>>>> 71dc37199362 (i40e/i40evf: Clean up logic for adaptive ITR)
  
- 	rx_itr_setting = get_rx_itr(vsi, idx);
- 	tx_itr_setting = get_tx_itr(vsi, idx);
- 
- 	if (q_vector->itr_countdown > 0 ||
- 	    (!ITR_IS_DYNAMIC(rx_itr_setting) &&
- 	     !ITR_IS_DYNAMIC(tx_itr_setting))) {
+ 	/* avoid dynamic calculation if in countdown mode */
+ 	if (q_vector->itr_countdown > 0)
  		goto enable_int;
- 	}
  
- 	if (ITR_IS_DYNAMIC(rx_itr_setting)) {
- 		rx = i40e_set_new_dynamic_itr(&q_vector->rx);
- 		rxval = i40e_buildreg_itr(I40E_RX_ITR, q_vector->rx.itr);
- 	}
- 
- 	if (ITR_IS_DYNAMIC(tx_itr_setting)) {
- 		tx = i40e_set_new_dynamic_itr(&q_vector->tx);
- 		txval = i40e_buildreg_itr(I40E_TX_ITR, q_vector->tx.itr);
- 	}
+ 	/* these will return false if dynamic mode is disabled */
+ 	rx = i40e_set_new_dynamic_itr(&q_vector->rx);
+ 	tx = i40e_set_new_dynamic_itr(&q_vector->tx);
  
  	if (rx || tx) {
  		/* get the higher of the two ITR adjustments and
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_txrx.c
