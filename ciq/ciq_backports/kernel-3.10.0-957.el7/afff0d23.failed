scsi: lpfc: Add Buffer overflow check, when nvme_info larger than PAGE_SIZE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] lpfc: Add Buffer overflow check, when nvme_info larger than PAGE_SIZE (Dick Kennedy) [1595381]
Rebuild_FUZZ: 95.83%
commit-author James Smart <jsmart2021@gmail.com>
commit afff0d2321ea2beb6f4dcd029d4667acf73dec25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/afff0d23.failed

Kernel crashes during fill_read_buffer when nvme_info sysfs file read.

With multiple NVME targets, approx 40, nvme_info may grow larger than
PAGE_SIZE bytes.  snprintf(buf + len, PAGE_SIZE - len, ...) logic is flawed
as PAGE_SIZE - len can be < 0 and is accepted by snprintf.  This results in
buffer overflow, and is detected with check from dev_attr_show and
fill_read_buffer.

Change to use scnprintf to a tmp array, before calling strlcat to ensure no
buffer overflow over PAGE_SIZE bytes.

Message "6314" created as a new message indicating when there is more nvme
info, but is truncated to fit within PAGE_SIZE bytes.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit afff0d2321ea2beb6f4dcd029d4667acf73dec25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_attr.c
diff --cc drivers/scsi/lpfc/lpfc_attr.c
index c25b234268e1,c06593e5aa32..000000000000
--- a/drivers/scsi/lpfc/lpfc_attr.c
+++ b/drivers/scsi/lpfc/lpfc_attr.c
@@@ -224,45 -246,65 +246,68 @@@ lpfc_nvme_info_show(struct device *dev
  
  		if (atomic_read(&tgtp->rcv_fcp_cmd_in) !=
  		    atomic_read(&tgtp->rcv_fcp_cmd_out)) {
- 			len += snprintf(buf+len, PAGE_SIZE-len,
- 					"Rcv FCP: in %08x != out %08x\n",
- 					atomic_read(&tgtp->rcv_fcp_cmd_in),
- 					atomic_read(&tgtp->rcv_fcp_cmd_out));
+ 			scnprintf(tmp, sizeof(tmp),
+ 				  "Rcv FCP: in %08x != out %08x\n",
+ 				  atomic_read(&tgtp->rcv_fcp_cmd_in),
+ 				  atomic_read(&tgtp->rcv_fcp_cmd_out));
+ 			if (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)
+ 				goto buffer_done;
  		}
  
- 		len += snprintf(buf+len, PAGE_SIZE-len,
- 				"FCP Rsp: RD %08x rsp %08x WR %08x rsp %08x "
- 				"drop %08x\n",
- 				atomic_read(&tgtp->xmt_fcp_read),
- 				atomic_read(&tgtp->xmt_fcp_read_rsp),
- 				atomic_read(&tgtp->xmt_fcp_write),
- 				atomic_read(&tgtp->xmt_fcp_rsp),
- 				atomic_read(&tgtp->xmt_fcp_drop));
- 
- 		len += snprintf(buf+len, PAGE_SIZE-len,
- 				"FCP Rsp Cmpl: %08x err %08x drop %08x\n",
- 				atomic_read(&tgtp->xmt_fcp_rsp_cmpl),
- 				atomic_read(&tgtp->xmt_fcp_rsp_error),
- 				atomic_read(&tgtp->xmt_fcp_rsp_drop));
- 
- 		len += snprintf(buf+len, PAGE_SIZE-len,
- 				"FCP Rsp Abort: %08x xb %08x xricqe  %08x\n",
- 				atomic_read(&tgtp->xmt_fcp_rsp_aborted),
- 				atomic_read(&tgtp->xmt_fcp_rsp_xb_set),
- 				atomic_read(&tgtp->xmt_fcp_xri_abort_cqe));
- 
- 		len += snprintf(buf + len, PAGE_SIZE - len,
- 				"ABORT: Xmt %08x Cmpl %08x\n",
- 				atomic_read(&tgtp->xmt_fcp_abort),
- 				atomic_read(&tgtp->xmt_fcp_abort_cmpl));
- 
- 		len += snprintf(buf + len, PAGE_SIZE - len,
- 				"ABORT: Sol %08x  Usol %08x Err %08x Cmpl %08x",
- 				atomic_read(&tgtp->xmt_abort_sol),
- 				atomic_read(&tgtp->xmt_abort_unsol),
- 				atomic_read(&tgtp->xmt_abort_rsp),
- 				atomic_read(&tgtp->xmt_abort_rsp_error));
- 
+ 		scnprintf(tmp, sizeof(tmp),
+ 			  "FCP Rsp: RD %08x rsp %08x WR %08x rsp %08x "
+ 			  "drop %08x\n",
+ 			  atomic_read(&tgtp->xmt_fcp_read),
+ 			  atomic_read(&tgtp->xmt_fcp_read_rsp),
+ 			  atomic_read(&tgtp->xmt_fcp_write),
+ 			  atomic_read(&tgtp->xmt_fcp_rsp),
+ 			  atomic_read(&tgtp->xmt_fcp_drop));
+ 		if (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)
+ 			goto buffer_done;
+ 
+ 		scnprintf(tmp, sizeof(tmp),
+ 			  "FCP Rsp Cmpl: %08x err %08x drop %08x\n",
+ 			  atomic_read(&tgtp->xmt_fcp_rsp_cmpl),
+ 			  atomic_read(&tgtp->xmt_fcp_rsp_error),
+ 			  atomic_read(&tgtp->xmt_fcp_rsp_drop));
+ 		if (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)
+ 			goto buffer_done;
+ 
+ 		scnprintf(tmp, sizeof(tmp),
+ 			  "FCP Rsp Abort: %08x xb %08x xricqe  %08x\n",
+ 			  atomic_read(&tgtp->xmt_fcp_rsp_aborted),
+ 			  atomic_read(&tgtp->xmt_fcp_rsp_xb_set),
+ 			  atomic_read(&tgtp->xmt_fcp_xri_abort_cqe));
+ 		if (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)
+ 			goto buffer_done;
+ 
+ 		scnprintf(tmp, sizeof(tmp),
+ 			  "ABORT: Xmt %08x Cmpl %08x\n",
+ 			  atomic_read(&tgtp->xmt_fcp_abort),
+ 			  atomic_read(&tgtp->xmt_fcp_abort_cmpl));
+ 		if (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)
+ 			goto buffer_done;
+ 
+ 		scnprintf(tmp, sizeof(tmp),
+ 			  "ABORT: Sol %08x  Usol %08x Err %08x Cmpl %08x\n",
+ 			  atomic_read(&tgtp->xmt_abort_sol),
+ 			  atomic_read(&tgtp->xmt_abort_unsol),
+ 			  atomic_read(&tgtp->xmt_abort_rsp),
+ 			  atomic_read(&tgtp->xmt_abort_rsp_error));
+ 		if (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)
+ 			goto buffer_done;
+ 
++<<<<<<< HEAD
++=======
+ 		scnprintf(tmp, sizeof(tmp),
+ 			  "DELAY: ctx %08x  fod %08x wqfull %08x\n",
+ 			  atomic_read(&tgtp->defer_ctx),
+ 			  atomic_read(&tgtp->defer_fod),
+ 			  atomic_read(&tgtp->defer_wqfull));
+ 		if (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)
+ 			goto buffer_done;
+ 
++>>>>>>> afff0d2321ea (scsi: lpfc: Add Buffer overflow check, when nvme_info larger than PAGE_SIZE)
  		/* Calculate outstanding IOs */
  		tot = atomic_read(&tgtp->rcv_fcp_cmd_drop);
  		tot += atomic_read(&tgtp->xmt_fcp_release);
* Unmerged path drivers/scsi/lpfc/lpfc_attr.c
