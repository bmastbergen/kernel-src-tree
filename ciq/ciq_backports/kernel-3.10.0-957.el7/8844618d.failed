ext4: only look at the bg_flags field if it is valid

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit 8844618d8aa7a9973e7b527d038a2a589665002c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8844618d.failed

The bg_flags field in the block group descripts is only valid if the
uninit_bg or metadata_csum feature is enabled.  We were not
consistently looking at this field; fix this.

Also block group #0 must never have uninitialized allocation bitmaps,
or need to be zeroed, since that's where the root inode, and other
special inodes are set up.  Check for these conditions and mark the
file system as corrupted if they are detected.

This addresses CVE-2018-10876.

https://bugzilla.kernel.org/show_bug.cgi?id=199403

	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: stable@kernel.org
(cherry picked from commit 8844618d8aa7a9973e7b527d038a2a589665002c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/balloc.c
#	fs/ext4/ialloc.c
diff --cc fs/ext4/balloc.c
index c2b7a4cd09cb,e68cefe08261..000000000000
--- a/fs/ext4/balloc.c
+++ b/fs/ext4/balloc.c
@@@ -452,9 -438,16 +452,22 @@@ ext4_read_block_bitmap_nowait(struct su
  		goto verify;
  	}
  	ext4_lock_group(sb, block_group);
++<<<<<<< HEAD
 +	if (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {
 +		int err;
 +
++=======
+ 	if (ext4_has_group_desc_csum(sb) &&
+ 	    (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {
+ 		if (block_group == 0) {
+ 			ext4_unlock_group(sb, block_group);
+ 			unlock_buffer(bh);
+ 			ext4_error(sb, "Block bitmap for bg 0 marked "
+ 				   "uninitialized");
+ 			err = -EFSCORRUPTED;
+ 			goto out;
+ 		}
++>>>>>>> 8844618d8aa7 (ext4: only look at the bg_flags field if it is valid)
  		err = ext4_init_block_bitmap(sb, bh, block_group, desc);
  		set_bitmap_uptodate(bh);
  		set_buffer_uptodate(bh);
diff --cc fs/ext4/ialloc.c
index f21709f3c045,da6c10c1e37a..000000000000
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@@ -157,8 -150,19 +157,24 @@@ ext4_read_inode_bitmap(struct super_blo
  	}
  
  	ext4_lock_group(sb, block_group);
++<<<<<<< HEAD
 +	if (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {
 +		ext4_init_inode_bitmap(sb, bh, block_group, desc);
++=======
+ 	if (ext4_has_group_desc_csum(sb) &&
+ 	    (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT))) {
+ 		if (block_group == 0) {
+ 			ext4_unlock_group(sb, block_group);
+ 			unlock_buffer(bh);
+ 			ext4_error(sb, "Inode bitmap for bg 0 marked "
+ 				   "uninitialized");
+ 			err = -EFSCORRUPTED;
+ 			goto out;
+ 		}
+ 		memset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);
+ 		ext4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),
+ 				     sb->s_blocksize * 8, bh->b_data);
++>>>>>>> 8844618d8aa7 (ext4: only look at the bg_flags field if it is valid)
  		set_bitmap_uptodate(bh);
  		set_buffer_uptodate(bh);
  		set_buffer_verified(bh);
* Unmerged path fs/ext4/balloc.c
* Unmerged path fs/ext4/ialloc.c
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index 2b1d8068d2d1..c307b4ddd7a7 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -2411,7 +2411,8 @@ int ext4_mb_add_groupinfo(struct super_block *sb, ext4_group_t group,
 	 * initialize bb_free to be able to skip
 	 * empty groups without initialization
 	 */
-	if (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {
+	if (ext4_has_group_desc_csum(sb) &&
+	    (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {
 		meta_group_info[i]->bb_free =
 			ext4_free_clusters_after_init(sb, group, desc);
 	} else {
@@ -2937,7 +2938,8 @@ ext4_mb_mark_diskspace_used(struct ext4_allocation_context *ac,
 #endif
 	ext4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,
 		      ac->ac_b_ex.fe_len);
-	if (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {
+	if (ext4_has_group_desc_csum(sb) &&
+	    (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {
 		gdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);
 		ext4_free_group_clusters_set(sb, gdp,
 					     ext4_free_clusters_after_init(sb,
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 525b8da0cba2..a5f7caf4a5d5 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -3175,13 +3175,22 @@ static ext4_group_t ext4_has_uninit_itable(struct super_block *sb)
 	ext4_group_t group, ngroups = EXT4_SB(sb)->s_groups_count;
 	struct ext4_group_desc *gdp = NULL;
 
+	if (!ext4_has_group_desc_csum(sb))
+		return ngroups;
+
 	for (group = 0; group < ngroups; group++) {
 		gdp = ext4_get_group_desc(sb, group, NULL);
 		if (!gdp)
 			continue;
 
-		if (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))
+		if (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED))
+			continue;
+		if (group != 0)
 			break;
+		ext4_error(sb, "Inode table for bg 0 marked as "
+			   "needing zeroing");
+		if (sb_rdonly(sb))
+			return ngroups;
 	}
 
 	return group;
