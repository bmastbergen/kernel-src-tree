of: fix memory leak related to safe_name()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [of] fix memory leak related to safe_name() (Prarit Bhargava) [1564602]
Rebuild_FUZZ: 95.00%
commit-author Frank Rowand <frank.rowand@am.sony.com>
commit d9fc880723321dbf16b2981e3f3e916b73942210
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d9fc8807.failed

Fix a memory leak resulting from memory allocation in safe_name().
This patch fixes all call sites of safe_name().

Mathieu Malaterre reported the memory leak on boot:

On my PowerMac device-tree would generate a duplicate name:

[    0.023043] device-tree: Duplicate name in PowerPC,G4@0, renamed to "l2-cache#1"

in this case a newly allocated name is generated by `safe_name`. However
in this case it is never deallocated.

The bug was found using kmemleak reported as:

unreferenced object 0xdf532e60 (size 32):
  comm "swapper", pid 1, jiffies 4294892300 (age 1993.532s)
  hex dump (first 32 bytes):
    6c 32 2d 63 61 63 68 65 23 31 00 dd e4 dd 1e c2  l2-cache#1......
    ec d4 ba ce 04 ec cc de 8e 85 e9 ca c4 ec cc 9e  ................
  backtrace:
    [<c02d3350>] kvasprintf+0x64/0xc8
    [<c02d3400>] kasprintf+0x4c/0x5c
    [<c0453814>] safe_name.isra.1+0x80/0xc4
    [<c04545d8>] __of_attach_node_sysfs+0x6c/0x11c
    [<c075f21c>] of_core_init+0x8c/0xf8
    [<c0729594>] kernel_init_freeable+0xd4/0x208
    [<c00047e8>] kernel_init+0x24/0x11c
    [<c00158ec>] ret_from_kernel_thread+0x5c/0x64

Link: https://bugzilla.kernel.org/show_bug.cgi?id=120331

	Signed-off-by: Frank Rowand <frank.rowand@am.sony.com>
	Reported-by: mathieu.malaterre@gmail.com
	Tested-by: Mathieu Malaterre <mathieu.malaterre@gmail.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: Rob Herring <robh@kernel.org>
(cherry picked from commit d9fc880723321dbf16b2981e3f3e916b73942210)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/of/base.c
#	drivers/of/dynamic.c
#	drivers/of/of_private.h
diff --cc drivers/of/base.c
index 69390e35dae8,8bb3d1adf1b0..000000000000
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@@ -216,23 -160,32 +220,30 @@@ static int __of_add_property_sysfs(stru
  	return rc;
  }
  
 -int __of_attach_node_sysfs(struct device_node *np)
 +static int __of_node_add(struct device_node *np)
  {
  	const char *name;
+ 	struct kobject *parent;
  	struct property *pp;
  	int rc;
  
  	np->kobj.kset = of_kset;
  	if (!np->parent) {
  		/* Nodes without parents are new top level trees */
++<<<<<<< HEAD
 +		rc = kobject_add(&np->kobj, NULL, safe_name(&of_kset->kobj, "base"));
++=======
+ 		name = safe_name(&of_kset->kobj, "base");
+ 		parent = NULL;
++>>>>>>> d9fc88072332 (of: fix memory leak related to safe_name())
  	} else {
  		name = safe_name(&np->parent->kobj, kbasename(np->full_name));
- 		if (!name || !name[0])
- 			return -EINVAL;
- 
- 		rc = kobject_add(&np->kobj, &np->parent->kobj, "%s", name);
+ 		parent = &np->parent->kobj;
  	}
+ 	if (!name)
+ 		return -ENOMEM;
+ 	rc = kobject_add(&np->kobj, parent, "%s", name);
+ 	kfree(name);
  	if (rc)
  		return rc;
  
@@@ -1541,6 -1821,22 +1552,25 @@@ int of_add_property(struct device_node 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ void __of_sysfs_remove_bin_file(struct device_node *np, struct property *prop)
+ {
+ 	sysfs_remove_bin_file(&np->kobj, &prop->attr);
+ 	kfree(prop->attr.attr.name);
+ }
+ 
+ void __of_remove_property_sysfs(struct device_node *np, struct property *prop)
+ {
+ 	if (!IS_ENABLED(CONFIG_SYSFS))
+ 		return;
+ 
+ 	/* at early boot, bail here and defer setup to of_init() */
+ 	if (of_kset && of_node_is_attached(np))
+ 		__of_sysfs_remove_bin_file(np, prop);
+ }
+ 
++>>>>>>> d9fc88072332 (of: fix memory leak related to safe_name())
  /**
   * of_remove_property - Remove a property from a node.
   *
@@@ -1593,6 -1896,21 +1623,24 @@@ int of_remove_property(struct device_no
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ void __of_update_property_sysfs(struct device_node *np, struct property *newprop,
+ 		struct property *oldprop)
+ {
+ 	if (!IS_ENABLED(CONFIG_SYSFS))
+ 		return;
+ 
+ 	/* At early boot, bail out and defer setup to of_init() */
+ 	if (!of_kset)
+ 		return;
+ 
+ 	if (oldprop)
+ 		__of_sysfs_remove_bin_file(np, oldprop);
+ 	__of_add_property_sysfs(np, newprop);
+ }
+ 
++>>>>>>> d9fc88072332 (of: fix memory leak related to safe_name())
  /*
   * of_update_property - Update a property in a node, if the property does
   * not exist, add it.
diff --cc drivers/of/of_private.h
index ff350c8fa7ac,18bbb4517e25..000000000000
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@@ -31,6 -31,68 +31,71 @@@ struct alias_prop 
  	char stem[0];
  };
  
 -extern struct mutex of_mutex;
 +extern struct mutex of_aliases_mutex;
  extern struct list_head aliases_lookup;
++<<<<<<< HEAD
++=======
+ extern struct kset *of_kset;
+ 
+ 
+ static inline struct device_node *kobj_to_device_node(struct kobject *kobj)
+ {
+ 	return container_of(kobj, struct device_node, kobj);
+ }
+ 
+ #if defined(CONFIG_OF_DYNAMIC)
+ extern int of_property_notify(int action, struct device_node *np,
+ 			      struct property *prop, struct property *old_prop);
+ extern void of_node_release(struct kobject *kobj);
+ extern int __of_changeset_apply(struct of_changeset *ocs);
+ extern int __of_changeset_revert(struct of_changeset *ocs);
+ #else /* CONFIG_OF_DYNAMIC */
+ static inline int of_property_notify(int action, struct device_node *np,
+ 				     struct property *prop, struct property *old_prop)
+ {
+ 	return 0;
+ }
+ #endif /* CONFIG_OF_DYNAMIC */
+ 
+ /**
+  * General utilities for working with live trees.
+  *
+  * All functions with two leading underscores operate
+  * without taking node references, so you either have to
+  * own the devtree lock or work on detached trees only.
+  */
+ struct property *__of_prop_dup(const struct property *prop, gfp_t allocflags);
+ __printf(2, 3) struct device_node *__of_node_dup(const struct device_node *np, const char *fmt, ...);
+ 
+ extern const void *__of_get_property(const struct device_node *np,
+ 				     const char *name, int *lenp);
+ extern int __of_add_property(struct device_node *np, struct property *prop);
+ extern int __of_add_property_sysfs(struct device_node *np,
+ 		struct property *prop);
+ extern int __of_remove_property(struct device_node *np, struct property *prop);
+ extern void __of_remove_property_sysfs(struct device_node *np,
+ 		struct property *prop);
+ extern int __of_update_property(struct device_node *np,
+ 		struct property *newprop, struct property **oldprop);
+ extern void __of_update_property_sysfs(struct device_node *np,
+ 		struct property *newprop, struct property *oldprop);
+ 
+ extern void __of_attach_node(struct device_node *np);
+ extern int __of_attach_node_sysfs(struct device_node *np);
+ extern void __of_detach_node(struct device_node *np);
+ extern void __of_detach_node_sysfs(struct device_node *np);
+ 
+ extern void __of_sysfs_remove_bin_file(struct device_node *np,
+ 				       struct property *prop);
+ 
+ /* iterators for transactions, used for overlays */
+ /* forward iterator */
+ #define for_each_transaction_entry(_oft, _te) \
+ 	list_for_each_entry(_te, &(_oft)->te_list, node)
+ 
+ /* reverse iterator */
+ #define for_each_transaction_entry_reverse(_oft, _te) \
+ 	list_for_each_entry_reverse(_te, &(_oft)->te_list, node)
+ 
++>>>>>>> d9fc88072332 (of: fix memory leak related to safe_name())
  #endif /* _LINUX_OF_PRIVATE_H */
* Unmerged path drivers/of/dynamic.c
* Unmerged path drivers/of/base.c
* Unmerged path drivers/of/dynamic.c
* Unmerged path drivers/of/of_private.h
