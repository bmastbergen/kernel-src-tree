mlxsw: spectrum_router: Handle down of tunnel underlay

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Petr Machata <petrm@mellanox.com>
commit 44b0fff1d8a461a5cd66cfc3a15ff05959d77df5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/44b0fff1.failed

When the bound device of a tunnel device is down, encapsulated packets
are not egressed anymore, but tunnel decap still works. Extend
mlxsw_sp_nexthop_rif_update() to take IFF_UP into consideration when
deciding whether a given next hop should be offloaded.

Because the new logic was added to mlxsw_sp_nexthop_rif_update(), this
fixes the case where a newly-added tunnel has a down bound device, which
would previously be fully offloaded. Now the down state of the bound
device is noted and next hops forwarding to such tunnel are not
offloaded.

In addition to that, notice NETDEV_UP and NETDEV_DOWN of a bound device
to force refresh of tunnel encap route offloads.

	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 44b0fff1d8a461a5cd66cfc3a15ff05959d77df5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 782f252be995,e9187841d82a..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -1387,12 -1443,141 +1387,146 @@@ static int mlxsw_sp_netdevice_ipip_ol_v
  	return 0;
  }
  
 -static int mlxsw_sp_netdevice_ipip_ol_vrf_event(struct mlxsw_sp *mlxsw_sp,
 -						struct net_device *ol_dev,
 -						struct netlink_ext_ack *extack)
 +int
 +mlxsw_sp_netdevice_ipip_ol_event(struct mlxsw_sp *mlxsw_sp,
 +				 struct net_device *ol_dev,
 +				 unsigned long event,
 +				 struct netdev_notifier_changeupper_info *info)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlxsw_sp_ipip_entry *ipip_entry =
+ 		mlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, ol_dev);
+ 
+ 	if (!ipip_entry)
+ 		return 0;
+ 	return __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,
+ 						   true, false, false, extack);
+ }
+ 
+ static int
+ mlxsw_sp_netdevice_ipip_ul_vrf_event(struct mlxsw_sp *mlxsw_sp,
+ 				     struct mlxsw_sp_ipip_entry *ipip_entry,
+ 				     struct net_device *ul_dev,
+ 				     struct netlink_ext_ack *extack)
+ {
+ 	return __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,
+ 						   true, true, false, extack);
+ }
+ 
+ static int
+ mlxsw_sp_netdevice_ipip_ul_up_event(struct mlxsw_sp *mlxsw_sp,
+ 				    struct mlxsw_sp_ipip_entry *ipip_entry,
+ 				    struct net_device *ul_dev)
+ {
+ 	return __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,
+ 						   false, false, true, NULL);
+ }
+ 
+ static int
+ mlxsw_sp_netdevice_ipip_ul_down_event(struct mlxsw_sp *mlxsw_sp,
+ 				      struct mlxsw_sp_ipip_entry *ipip_entry,
+ 				      struct net_device *ul_dev)
+ {
+ 	/* A down underlay device causes encapsulated packets to not be
+ 	 * forwarded, but decap still works. So refresh next hops without
+ 	 * touching anything else.
+ 	 */
+ 	return __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,
+ 						   false, false, true, NULL);
+ }
+ 
+ static int
+ mlxsw_sp_netdevice_ipip_ol_change_event(struct mlxsw_sp *mlxsw_sp,
+ 					struct net_device *ol_dev,
+ 					struct netlink_ext_ack *extack)
+ {
+ 	const struct mlxsw_sp_ipip_ops *ipip_ops;
+ 	struct mlxsw_sp_ipip_entry *ipip_entry;
+ 	int err;
+ 
+ 	ipip_entry = mlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, ol_dev);
+ 	if (!ipip_entry)
+ 		/* A change might make a tunnel eligible for offloading, but
+ 		 * that is currently not implemented. What falls to slow path
+ 		 * stays there.
+ 		 */
+ 		return 0;
+ 
+ 	/* A change might make a tunnel not eligible for offloading. */
+ 	if (!mlxsw_sp_netdevice_ipip_can_offload(mlxsw_sp, ol_dev,
+ 						 ipip_entry->ipipt)) {
+ 		mlxsw_sp_ipip_entry_demote_tunnel(mlxsw_sp, ipip_entry);
+ 		return 0;
+ 	}
+ 
+ 	ipip_ops = mlxsw_sp->router->ipip_ops_arr[ipip_entry->ipipt];
+ 	err = ipip_ops->ol_netdev_change(mlxsw_sp, ipip_entry, extack);
+ 	return err;
+ }
+ 
+ void mlxsw_sp_ipip_entry_demote_tunnel(struct mlxsw_sp *mlxsw_sp,
+ 				       struct mlxsw_sp_ipip_entry *ipip_entry)
+ {
+ 	struct net_device *ol_dev = ipip_entry->ol_dev;
+ 
+ 	if (ol_dev->flags & IFF_UP)
+ 		mlxsw_sp_ipip_entry_ol_down_event(mlxsw_sp, ipip_entry);
+ 	mlxsw_sp_ipip_entry_destroy(mlxsw_sp, ipip_entry);
+ }
+ 
+ /* The configuration where several tunnels have the same local address in the
+  * same underlay table needs special treatment in the HW. That is currently not
+  * implemented in the driver. This function finds and demotes the first tunnel
+  * with a given source address, except the one passed in in the argument
+  * `except'.
+  */
+ bool
+ mlxsw_sp_ipip_demote_tunnel_by_saddr(struct mlxsw_sp *mlxsw_sp,
+ 				     enum mlxsw_sp_l3proto ul_proto,
+ 				     union mlxsw_sp_l3addr saddr,
+ 				     u32 ul_tb_id,
+ 				     const struct mlxsw_sp_ipip_entry *except)
+ {
+ 	struct mlxsw_sp_ipip_entry *ipip_entry, *tmp;
+ 
+ 	list_for_each_entry_safe(ipip_entry, tmp, &mlxsw_sp->router->ipip_list,
+ 				 ipip_list_node) {
+ 		if (ipip_entry != except &&
+ 		    mlxsw_sp_ipip_entry_saddr_matches(mlxsw_sp, ul_proto, saddr,
+ 						      ul_tb_id, ipip_entry)) {
+ 			mlxsw_sp_ipip_entry_demote_tunnel(mlxsw_sp, ipip_entry);
+ 			return true;
+ 		}
+ 	}
+ 
+ 	return false;
+ }
+ 
+ static void mlxsw_sp_ipip_demote_tunnel_by_ul_netdev(struct mlxsw_sp *mlxsw_sp,
+ 						     struct net_device *ul_dev)
+ {
+ 	struct mlxsw_sp_ipip_entry *ipip_entry, *tmp;
+ 
+ 	list_for_each_entry_safe(ipip_entry, tmp, &mlxsw_sp->router->ipip_list,
+ 				 ipip_list_node) {
+ 		struct net_device *ipip_ul_dev =
+ 			__mlxsw_sp_ipip_netdev_ul_dev_get(ipip_entry->ol_dev);
+ 
+ 		if (ipip_ul_dev == ul_dev)
+ 			mlxsw_sp_ipip_entry_demote_tunnel(mlxsw_sp, ipip_entry);
+ 	}
+ }
+ 
+ int mlxsw_sp_netdevice_ipip_ol_event(struct mlxsw_sp *mlxsw_sp,
+ 				     struct net_device *ol_dev,
+ 				     unsigned long event,
+ 				     struct netdev_notifier_info *info)
+ {
+ 	struct netdev_notifier_changeupper_info *chup;
+ 	struct netlink_ext_ack *extack;
+ 
++>>>>>>> 44b0fff1d8a4 (mlxsw: spectrum_router: Handle down of tunnel underlay)
  	switch (event) {
  	case NETDEV_REGISTER:
  		return mlxsw_sp_netdevice_ipip_ol_reg_event(mlxsw_sp, ol_dev);
@@@ -1414,6 -1606,62 +1548,65 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ __mlxsw_sp_netdevice_ipip_ul_event(struct mlxsw_sp *mlxsw_sp,
+ 				   struct mlxsw_sp_ipip_entry *ipip_entry,
+ 				   struct net_device *ul_dev,
+ 				   unsigned long event,
+ 				   struct netdev_notifier_info *info)
+ {
+ 	struct netdev_notifier_changeupper_info *chup;
+ 	struct netlink_ext_ack *extack;
+ 
+ 	switch (event) {
+ 	case NETDEV_CHANGEUPPER:
+ 		chup = container_of(info, typeof(*chup), info);
+ 		extack = info->extack;
+ 		if (netif_is_l3_master(chup->upper_dev))
+ 			return mlxsw_sp_netdevice_ipip_ul_vrf_event(mlxsw_sp,
+ 								    ipip_entry,
+ 								    ul_dev,
+ 								    extack);
+ 		break;
+ 
+ 	case NETDEV_UP:
+ 		return mlxsw_sp_netdevice_ipip_ul_up_event(mlxsw_sp, ipip_entry,
+ 							   ul_dev);
+ 	case NETDEV_DOWN:
+ 		return mlxsw_sp_netdevice_ipip_ul_down_event(mlxsw_sp,
+ 							     ipip_entry,
+ 							     ul_dev);
+ 	}
+ 	return 0;
+ }
+ 
+ int
+ mlxsw_sp_netdevice_ipip_ul_event(struct mlxsw_sp *mlxsw_sp,
+ 				 struct net_device *ul_dev,
+ 				 unsigned long event,
+ 				 struct netdev_notifier_info *info)
+ {
+ 	struct mlxsw_sp_ipip_entry *ipip_entry = NULL;
+ 	int err;
+ 
+ 	while ((ipip_entry = mlxsw_sp_ipip_entry_find_by_ul_dev(mlxsw_sp,
+ 								ul_dev,
+ 								ipip_entry))) {
+ 		err = __mlxsw_sp_netdevice_ipip_ul_event(mlxsw_sp, ipip_entry,
+ 							 ul_dev, event, info);
+ 		if (err) {
+ 			mlxsw_sp_ipip_demote_tunnel_by_ul_netdev(mlxsw_sp,
+ 								 ul_dev);
+ 			return err;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 44b0fff1d8a4 (mlxsw: spectrum_router: Handle down of tunnel underlay)
  struct mlxsw_sp_neigh_key {
  	struct neighbour *n;
  };
@@@ -3256,6 -3512,30 +3459,33 @@@ static void mlxsw_sp_nexthop4_event(str
  	mlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh->nh_grp);
  }
  
++<<<<<<< HEAD
++=======
+ static void mlxsw_sp_nexthop_rif_update(struct mlxsw_sp *mlxsw_sp,
+ 					struct mlxsw_sp_rif *rif)
+ {
+ 	struct mlxsw_sp_nexthop *nh;
+ 	bool removing;
+ 
+ 	list_for_each_entry(nh, &rif->nexthop_list, rif_list_node) {
+ 		switch (nh->type) {
+ 		case MLXSW_SP_NEXTHOP_TYPE_ETH:
+ 			removing = false;
+ 			break;
+ 		case MLXSW_SP_NEXTHOP_TYPE_IPIP:
+ 			removing = !mlxsw_sp_ipip_netdev_ul_up(rif->dev);
+ 			break;
+ 		default:
+ 			WARN_ON(1);
+ 			continue;
+ 		}
+ 
+ 		__mlxsw_sp_nexthop_neigh_update(nh, removing);
+ 		mlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh->nh_grp);
+ 	}
+ }
+ 
++>>>>>>> 44b0fff1d8a4 (mlxsw: spectrum_router: Handle down of tunnel underlay)
  static void mlxsw_sp_nexthop_rif_gone_sync(struct mlxsw_sp *mlxsw_sp,
  					   struct mlxsw_sp_rif *rif)
  {
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
