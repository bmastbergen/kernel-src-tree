iio:trigger: add resource managed (un)register

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iio] trigger: add resource managed (un)register (Tony Camuso) [1559170]
Rebuild_FUZZ: 95.45%
commit-author Gregor Boirie <gregor.boirie@parrot.com>
commit 9083325f1197a6956db17809d74dbe3578dc1005
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9083325f.failed

Add resource managed devm_iio_trigger_register() and
devm_iio_triger_unregister() to automatically clean up registered triggers
allocated by IIO drivers, thus leading to simplified IIO drivers code.

	Signed-off-by: Gregor Boirie <gregor.boirie@parrot.com>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit 9083325f1197a6956db17809d74dbe3578dc1005)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/driver-model/devres.txt
#	drivers/iio/industrialio-trigger.c
diff --cc Documentation/driver-model/devres.txt
index 74e282453485,6a2138a7c3ff..000000000000
--- a/Documentation/driver-model/devres.txt
+++ b/Documentation/driver-model/devres.txt
@@@ -233,10 -233,50 +233,57 @@@ certainly invest a bit more effort int
    6. List of managed interfaces
    -----------------------------
  
++<<<<<<< HEAD
 +MEM
 +  devm_kzalloc()
 +  devm_kfree()
 +  devm_kmemdup()
++=======
+ CLOCK
+   devm_clk_get()
+   devm_clk_put()
+   devm_clk_hw_register()
+ 
+ DMA
+   dmam_alloc_coherent()
+   dmam_alloc_noncoherent()
+   dmam_declare_coherent_memory()
+   dmam_free_coherent()
+   dmam_free_noncoherent()
+   dmam_pool_create()
+   dmam_pool_destroy()
+ 
+ GPIO
+   devm_gpiod_get()
+   devm_gpiod_get_index()
+   devm_gpiod_get_index_optional()
+   devm_gpiod_get_optional()
+   devm_gpiod_put()
+   devm_gpiochip_add_data()
+   devm_gpiochip_remove()
+   devm_gpio_request()
+   devm_gpio_request_one()
+   devm_gpio_free()
+ 
+ IIO
+   devm_iio_device_alloc()
+   devm_iio_device_free()
+   devm_iio_device_register()
+   devm_iio_device_unregister()
+   devm_iio_kfifo_allocate()
+   devm_iio_kfifo_free()
+   devm_iio_trigger_alloc()
+   devm_iio_trigger_free()
+   devm_iio_trigger_register()
+   devm_iio_trigger_unregister()
+   devm_iio_channel_get()
+   devm_iio_channel_release()
+   devm_iio_channel_get_all()
+   devm_iio_channel_release_all()
+ 
+ INPUT
+   devm_input_allocate_device()
++>>>>>>> 9083325f1197 (iio:trigger: add resource managed (un)register)
  
  IO region
    devm_release_mem_region()
diff --cc drivers/iio/industrialio-trigger.c
index 27ac10a0a23f,ba584b5e71f4..000000000000
--- a/drivers/iio/industrialio-trigger.c
+++ b/drivers/iio/industrialio-trigger.c
@@@ -516,6 -565,142 +516,145 @@@ void iio_trigger_free(struct iio_trigge
  }
  EXPORT_SYMBOL(iio_trigger_free);
  
++<<<<<<< HEAD
++=======
+ static void devm_iio_trigger_release(struct device *dev, void *res)
+ {
+ 	iio_trigger_free(*(struct iio_trigger **)res);
+ }
+ 
+ static int devm_iio_trigger_match(struct device *dev, void *res, void *data)
+ {
+ 	struct iio_trigger **r = res;
+ 
+ 	if (!r || !*r) {
+ 		WARN_ON(!r || !*r);
+ 		return 0;
+ 	}
+ 
+ 	return *r == data;
+ }
+ 
+ /**
+  * devm_iio_trigger_alloc - Resource-managed iio_trigger_alloc()
+  * @dev:		Device to allocate iio_trigger for
+  * @fmt:		trigger name format. If it includes format
+  *			specifiers, the additional arguments following
+  *			format are formatted and inserted in the resulting
+  *			string replacing their respective specifiers.
+  *
+  * Managed iio_trigger_alloc.  iio_trigger allocated with this function is
+  * automatically freed on driver detach.
+  *
+  * If an iio_trigger allocated with this function needs to be freed separately,
+  * devm_iio_trigger_free() must be used.
+  *
+  * RETURNS:
+  * Pointer to allocated iio_trigger on success, NULL on failure.
+  */
+ struct iio_trigger *devm_iio_trigger_alloc(struct device *dev,
+ 						const char *fmt, ...)
+ {
+ 	struct iio_trigger **ptr, *trig;
+ 	va_list vargs;
+ 
+ 	ptr = devres_alloc(devm_iio_trigger_release, sizeof(*ptr),
+ 			   GFP_KERNEL);
+ 	if (!ptr)
+ 		return NULL;
+ 
+ 	/* use raw alloc_dr for kmalloc caller tracing */
+ 	va_start(vargs, fmt);
+ 	trig = viio_trigger_alloc(fmt, vargs);
+ 	va_end(vargs);
+ 	if (trig) {
+ 		*ptr = trig;
+ 		devres_add(dev, ptr);
+ 	} else {
+ 		devres_free(ptr);
+ 	}
+ 
+ 	return trig;
+ }
+ EXPORT_SYMBOL_GPL(devm_iio_trigger_alloc);
+ 
+ /**
+  * devm_iio_trigger_free - Resource-managed iio_trigger_free()
+  * @dev:		Device this iio_dev belongs to
+  * @iio_trig:		the iio_trigger associated with the device
+  *
+  * Free iio_trigger allocated with devm_iio_trigger_alloc().
+  */
+ void devm_iio_trigger_free(struct device *dev, struct iio_trigger *iio_trig)
+ {
+ 	int rc;
+ 
+ 	rc = devres_release(dev, devm_iio_trigger_release,
+ 			    devm_iio_trigger_match, iio_trig);
+ 	WARN_ON(rc);
+ }
+ EXPORT_SYMBOL_GPL(devm_iio_trigger_free);
+ 
+ static void devm_iio_trigger_unreg(struct device *dev, void *res)
+ {
+ 	iio_trigger_unregister(*(struct iio_trigger **)res);
+ }
+ 
+ /**
+  * devm_iio_trigger_register - Resource-managed iio_trigger_register()
+  * @dev:	device this trigger was allocated for
+  * @trig_info:	trigger to register
+  *
+  * Managed iio_trigger_register().  The IIO trigger registered with this
+  * function is automatically unregistered on driver detach. This function
+  * calls iio_trigger_register() internally. Refer to that function for more
+  * information.
+  *
+  * If an iio_trigger registered with this function needs to be unregistered
+  * separately, devm_iio_trigger_unregister() must be used.
+  *
+  * RETURNS:
+  * 0 on success, negative error number on failure.
+  */
+ int devm_iio_trigger_register(struct device *dev, struct iio_trigger *trig_info)
+ {
+ 	struct iio_trigger **ptr;
+ 	int ret;
+ 
+ 	ptr = devres_alloc(devm_iio_trigger_unreg, sizeof(*ptr), GFP_KERNEL);
+ 	if (!ptr)
+ 		return -ENOMEM;
+ 
+ 	*ptr = trig_info;
+ 	ret = iio_trigger_register(trig_info);
+ 	if (!ret)
+ 		devres_add(dev, ptr);
+ 	else
+ 		devres_free(ptr);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(devm_iio_trigger_register);
+ 
+ /**
+  * devm_iio_trigger_unregister - Resource-managed iio_trigger_unregister()
+  * @dev:	device this iio_trigger belongs to
+  * @trig_info:	the trigger associated with the device
+  *
+  * Unregister trigger registered with devm_iio_trigger_register().
+  */
+ void devm_iio_trigger_unregister(struct device *dev,
+ 				 struct iio_trigger *trig_info)
+ {
+ 	int rc;
+ 
+ 	rc = devres_release(dev, devm_iio_trigger_unreg, devm_iio_trigger_match,
+ 			    trig_info);
+ 	WARN_ON(rc);
+ }
+ EXPORT_SYMBOL_GPL(devm_iio_trigger_unregister);
+ 
++>>>>>>> 9083325f1197 (iio:trigger: add resource managed (un)register)
  void iio_device_register_trigger_consumer(struct iio_dev *indio_dev)
  {
  	indio_dev->groups[indio_dev->groupcounter++] =
* Unmerged path Documentation/driver-model/devres.txt
* Unmerged path drivers/iio/industrialio-trigger.c
diff --git a/include/linux/iio/trigger.h b/include/linux/iio/trigger.h
index 1fa26d849585..9a8a74f2e3e1 100644
--- a/include/linux/iio/trigger.h
+++ b/include/linux/iio/trigger.h
@@ -125,12 +125,18 @@ static inline void *iio_trigger_get_drvdata(struct iio_trigger *trig)
  **/
 int iio_trigger_register(struct iio_trigger *trig_info);
 
+int devm_iio_trigger_register(struct device *dev,
+			      struct iio_trigger *trig_info);
+
 /**
  * iio_trigger_unregister() - unregister a trigger from the core
  * @trig_info:	trigger to be unregistered
  **/
 void iio_trigger_unregister(struct iio_trigger *trig_info);
 
+void devm_iio_trigger_unregister(struct device *dev,
+				 struct iio_trigger *trig_info);
+
 /**
  * iio_trigger_poll() - called on a trigger occurring
  * @trig:	trigger which occurred
