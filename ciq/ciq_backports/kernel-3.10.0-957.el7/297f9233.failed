kprobes: Propagate error from disarm_kprobe_ftrace()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jessica Yu <jeyu@kernel.org>
commit 297f9233b53a08fd457815e19f1d6f2c3389857b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/297f9233.failed

Improve error handling when disarming ftrace-based kprobes. Like with
arm_kprobe_ftrace(), propagate any errors from disarm_kprobe_ftrace() so
that we do not disable/unregister kprobes that are still armed. In other
words, unregister_kprobe() and disable_kprobe() should not report success
if the kprobe could not be disarmed.

disarm_all_kprobes() keeps its current behavior and attempts to
disarm all kprobes. It returns the last encountered error and gives a
warning if not all probes could be disarmed.

This patch is based on Petr Mladek's original patchset (patches 2 and 3)
back in 2015, which improved kprobes error handling, found here:

   https://lkml.org/lkml/2015/2/26/452

However, further work on this had been paused since then and the patches
were not upstreamed.

Based-on-patches-by: Petr Mladek <pmladek@suse.com>
	Signed-off-by: Jessica Yu <jeyu@kernel.org>
	Acked-by: Masami Hiramatsu <mhiramat@kernel.org>
	Cc: Ananth N Mavinakayanahalli <ananth@linux.vnet.ibm.com>
	Cc: Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
	Cc: David S . Miller <davem@davemloft.net>
	Cc: Jiri Kosina <jikos@kernel.org>
	Cc: Joe Lawrence <joe.lawrence@redhat.com>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Miroslav Benes <mbenes@suse.cz>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Petr Mladek <pmladek@suse.com>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: live-patching@vger.kernel.org
Link: http://lkml.kernel.org/r/20180109235124.30886-3-jeyu@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 297f9233b53a08fd457815e19f1d6f2c3389857b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/kprobes.c
diff --cc kernel/kprobes.c
index a0d8f0f341d9,102160ff5c66..000000000000
--- a/kernel/kprobes.c
+++ b/kernel/kprobes.c
@@@ -956,15 -999,30 +956,22 @@@ static void __kprobes arm_kprobe_ftrace
  }
  
  /* Caller must lock kprobe_mutex */
++<<<<<<< HEAD
 +static void __kprobes disarm_kprobe_ftrace(struct kprobe *p)
++=======
+ static int disarm_kprobe_ftrace(struct kprobe *p)
++>>>>>>> 297f9233b53a (kprobes: Propagate error from disarm_kprobe_ftrace())
  {
- 	int ret;
+ 	int ret = 0;
  
- 	kprobe_ftrace_enabled--;
- 	if (kprobe_ftrace_enabled == 0) {
+ 	if (kprobe_ftrace_enabled == 1) {
  		ret = unregister_ftrace_function(&kprobe_ftrace_ops);
- 		WARN(ret < 0, "Failed to init kprobe-ftrace (%d)\n", ret);
+ 		if (WARN(ret < 0, "Failed to unregister kprobe-ftrace (%d)\n", ret))
+ 			return ret;
  	}
+ 
+ 	kprobe_ftrace_enabled--;
+ 
  	ret = ftrace_set_filter_ip(&kprobe_ftrace_ops,
  			   (unsigned long)p->addr, 1, 0);
  	WARN(ret < 0, "Failed to disarm kprobe-ftrace at %p (%d)\n", p->addr, ret);
@@@ -971,8 -1030,8 +979,13 @@@
  }
  #else	/* !CONFIG_KPROBES_ON_FTRACE */
  #define prepare_kprobe(p)	arch_prepare_kprobe(p)
++<<<<<<< HEAD
 +#define arm_kprobe_ftrace(p)	do {} while (0)
 +#define disarm_kprobe_ftrace(p)	do {} while (0)
++=======
+ #define arm_kprobe_ftrace(p)	(-ENODEV)
+ #define disarm_kprobe_ftrace(p)	(-ENODEV)
++>>>>>>> 297f9233b53a (kprobes: Propagate error from disarm_kprobe_ftrace())
  #endif
  
  /* Arm a kprobe with text_mutex */
@@@ -993,16 -1047,21 +1006,31 @@@ static void __kprobes arm_kprobe(struc
  }
  
  /* Disarm a kprobe with text_mutex */
++<<<<<<< HEAD
 +static void __kprobes disarm_kprobe(struct kprobe *kp, bool reopt)
 +{
 +	if (unlikely(kprobe_ftrace(kp))) {
 +		disarm_kprobe_ftrace(kp);
 +		return;
 +	}
 +	/* Ditto */
 +	mutex_lock(&text_mutex);
 +	__disarm_kprobe(kp, reopt);
 +	mutex_unlock(&text_mutex);
++=======
+ static int disarm_kprobe(struct kprobe *kp, bool reopt)
+ {
+ 	if (unlikely(kprobe_ftrace(kp)))
+ 		return disarm_kprobe_ftrace(kp);
+ 
+ 	cpus_read_lock();
+ 	mutex_lock(&text_mutex);
+ 	__disarm_kprobe(kp, reopt);
+ 	mutex_unlock(&text_mutex);
+ 	cpus_read_unlock();
+ 
+ 	return 0;
++>>>>>>> 297f9233b53a (kprobes: Propagate error from disarm_kprobe_ftrace())
  }
  
  /*
@@@ -1548,9 -1640,10 +1576,10 @@@ static int __kprobes aggr_kprobe_disabl
  }
  
  /* Disable one kprobe: Make sure called under kprobe_mutex is locked */
 -static struct kprobe *__disable_kprobe(struct kprobe *p)
 +static struct kprobe *__kprobes __disable_kprobe(struct kprobe *p)
  {
  	struct kprobe *orig_p;
+ 	int ret;
  
  	/* Get an original kprobe for return */
  	orig_p = __get_valid_kprobe(p);
@@@ -1970,9 -2116,10 +2004,10 @@@ static void __kprobes kill_kprobe(struc
  }
  
  /* Disable one kprobe */
 -int disable_kprobe(struct kprobe *kp)
 +int __kprobes disable_kprobe(struct kprobe *kp)
  {
  	int ret = 0;
+ 	struct kprobe *p;
  
  	mutex_lock(&kprobe_mutex);
  
@@@ -2265,10 -2495,10 +2301,14 @@@ static void __kprobes arm_all_kprobes(v
  
  already_enabled:
  	mutex_unlock(&kprobe_mutex);
 -	return ret;
 +	return;
  }
  
++<<<<<<< HEAD
 +static void __kprobes disarm_all_kprobes(void)
++=======
+ static int disarm_all_kprobes(void)
++>>>>>>> 297f9233b53a (kprobes: Propagate error from disarm_kprobe_ftrace())
  {
  	struct hlist_head *head;
  	struct kprobe *p;
@@@ -2336,10 -2584,15 +2392,10 @@@ static ssize_t write_enabled_file_bool(
  	case 'n':
  	case 'N':
  	case '0':
- 		disarm_all_kprobes();
+ 		ret = disarm_all_kprobes();
  		break;
 -	default:
 -		return -EINVAL;
  	}
  
 -	if (ret)
 -		return ret;
 -
  	return count;
  }
  
* Unmerged path kernel/kprobes.c
