ceph: disable cached readdir after dropping positive dentry

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Yan, Zheng <zyan@redhat.com>
commit 933ad2c9c8bbb1623c2d3c5753ad340152e15d9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/933ad2c9.failed

Ideally CEPH_CAP_FILE_SHARED should have been revoked before
postive dentry get dropped. But if something goes wrong, later
cached readdir may dereference the dropped dentry.

	Signed-off-by: "Yan, Zheng" <zyan@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 933ad2c9c8bbb1623c2d3c5753ad340152e15d9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/inode.c
diff --cc fs/ceph/inode.c
index 4471f0927dd2,16d8b9dac649..000000000000
--- a/fs/ceph/inode.c
+++ b/fs/ceph/inode.c
@@@ -1165,17 -1180,13 +1165,22 @@@ retry_lookup
  					err = -ENOMEM;
  					goto done;
  				}
 -				err = 0;
 -			} else if (d_really_is_positive(dn) &&
 -				   (ceph_ino(d_inode(dn)) != tvino.ino ||
 -				    ceph_snap(d_inode(dn)) != tvino.snap)) {
 +				err = ceph_init_dentry(dn);
 +				if (err < 0) {
 +					dput(dn);
 +					dput(parent);
 +					goto done;
 +				}
 +			} else if (dn->d_inode &&
 +				   (ceph_ino(dn->d_inode) != tvino.ino ||
 +				    ceph_snap(dn->d_inode) != tvino.snap)) {
  				dout(" dn %p points to wrong inode %p\n",
++<<<<<<< HEAD
 +				     dn, dn->d_inode);
++=======
+ 				     dn, d_inode(dn));
+ 				ceph_dir_clear_ordered(dir);
++>>>>>>> 933ad2c9c8bb (ceph: disable cached readdir after dropping positive dentry)
  				d_delete(dn);
  				dput(dn);
  				goto retry_lookup;
@@@ -1309,10 -1320,11 +1314,11 @@@
  				goto done;
  			}
  			req->r_dentry = dn;  /* may have spliced */
 -		} else if (d_really_is_positive(dn) && d_inode(dn) != in) {
 +		} else if (dn->d_inode && dn->d_inode != in) {
  			dout(" %p links to %p %llx.%llx, not %llx.%llx\n",
 -			     dn, d_inode(dn), ceph_vinop(d_inode(dn)),
 +			     dn, dn->d_inode, ceph_vinop(dn->d_inode),
  			     ceph_vinop(in));
+ 			ceph_dir_clear_ordered(dir);
  			d_invalidate(dn);
  			have_lease = false;
  		}
@@@ -1556,17 -1571,12 +1562,22 @@@ retry_lookup
  				err = -ENOMEM;
  				goto out;
  			}
 -		} else if (d_really_is_positive(dn) &&
 -			   (ceph_ino(d_inode(dn)) != tvino.ino ||
 -			    ceph_snap(d_inode(dn)) != tvino.snap)) {
 +			ret = ceph_init_dentry(dn);
 +			if (ret < 0) {
 +				dput(dn);
 +				err = ret;
 +				goto out;
 +			}
 +		} else if (dn->d_inode &&
 +			   (ceph_ino(dn->d_inode) != tvino.ino ||
 +			    ceph_snap(dn->d_inode) != tvino.snap)) {
  			dout(" dn %p points to wrong inode %p\n",
++<<<<<<< HEAD
 +			     dn, dn->d_inode);
++=======
+ 			     dn, d_inode(dn));
+ 			__ceph_dir_clear_ordered(ci);
++>>>>>>> 933ad2c9c8bb (ceph: disable cached readdir after dropping positive dentry)
  			d_delete(dn);
  			dput(dn);
  			goto retry_lookup;
@@@ -1591,7 -1601,9 +1602,13 @@@
  				 &req->r_caps_reservation);
  		if (ret < 0) {
  			pr_err("fill_inode badness on %p\n", in);
++<<<<<<< HEAD
 +			if (!dn->d_inode)
++=======
+ 			if (d_really_is_positive(dn))
+ 				__ceph_dir_clear_ordered(ci);
+ 			else
++>>>>>>> 933ad2c9c8bb (ceph: disable cached readdir after dropping positive dentry)
  				iput(in);
  			d_drop(dn);
  			err = ret;
* Unmerged path fs/ceph/inode.c
