nvme-fc: check if queue is ready in queue_rq

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [nvme-loop] check if queue is ready in queue_rq (Ewan Milne) [1549232]
Rebuild_FUZZ: 88.61%
commit-author Sagi Grimberg <sagi@grimberg.me>
commit 9e0ed16ab9a9aaf670b81c9cd05b5e50defed654
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9e0ed16a.failed

In case the queue is not LIVE (fully functional and connected at the nvmf
level), we cannot allow any commands other than connect to pass through.

Add a new queue state flag NVME_FC_Q_LIVE which is set after nvmf connect
and cleared in queue teardown.

	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Reviewed-by: James Smart <james.smart@broadcom.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 9e0ed16ab9a9aaf670b81c9cd05b5e50defed654)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/fc.c
diff --cc drivers/nvme/host/fc.c
index 015099e3c78a,e0577bf33f45..000000000000
--- a/drivers/nvme/host/fc.c
+++ b/drivers/nvme/host/fc.c
@@@ -30,17 -30,9 +30,18 @@@
  /* *************************** Data Structures/Defines ****************** */
  
  
 +/*
 + * We handle AEN commands ourselves and don't even let the
 + * block layer know about them.
 + */
 +#define NVME_FC_NR_AEN_COMMANDS	1
 +#define NVME_FC_AQ_BLKMQ_DEPTH	\
 +	(NVME_AQ_DEPTH - NVME_FC_NR_AEN_COMMANDS)
 +#define AEN_CMDID_BASE		(NVME_FC_AQ_BLKMQ_DEPTH + 1)
 +
  enum nvme_fc_queue_flags {
  	NVME_FC_Q_CONNECTED = (1 << 0),
+ 	NVME_FC_Q_LIVE = (1 << 1),
  };
  
  #define NVMEFC_QUEUE_DELAY	3		/* ms units */
@@@ -2343,10 -2320,18 +2346,22 @@@ busy
  	if (!(op->flags & FCOP_FLAGS_AEN) && queue->hctx)
  		blk_mq_delay_run_hw_queue(queue->hctx, NVMEFC_QUEUE_DELAY);
  
 -	return BLK_STS_RESOURCE;
 +	return BLK_MQ_RQ_QUEUE_BUSY;
  }
  
++<<<<<<< HEAD
 +static int
++=======
+ static inline blk_status_t nvme_fc_is_ready(struct nvme_fc_queue *queue,
+ 		struct request *rq)
+ {
+ 	if (unlikely(!test_bit(NVME_FC_Q_LIVE, &queue->flags)))
+ 		return nvmf_check_init_req(&queue->ctrl->ctrl, rq);
+ 	return BLK_STS_OK;
+ }
+ 
+ static blk_status_t
++>>>>>>> 9e0ed16ab9a9 (nvme-fc: check if queue is ready in queue_rq)
  nvme_fc_queue_rq(struct blk_mq_hw_ctx *hctx,
  			const struct blk_mq_queue_data *bd)
  {
@@@ -2359,8 -2344,12 +2374,12 @@@
  	struct nvme_command *sqe = &cmdiu->sqe;
  	enum nvmefc_fcp_datadir	io_dir;
  	u32 data_len;
 -	blk_status_t ret;
 +	int ret;
  
+ 	ret = nvme_fc_is_ready(queue, rq);
+ 	if (unlikely(ret))
+ 		return ret;
+ 
  	ret = nvme_setup_cmd(ns, rq, sqe);
  	if (ret)
  		return ret;
* Unmerged path drivers/nvme/host/fc.c
