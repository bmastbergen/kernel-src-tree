x86,mpx: make mpx depend on x86-64 to free up VMA flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] mpx: make mpx depend on x86-64 to free up VMA flag (Rafael Aquini) [1476297]
Rebuild_FUZZ: 96.15%
commit-author Rik van Riel <riel@redhat.com>
commit df3735c5b40fad8d0d28eb8ab065fe955b3347ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/df3735c5.failed

Patch series "mm,fork,security: introduce MADV_WIPEONFORK", v4.

If a child process accesses memory that was MADV_WIPEONFORK, it will get
zeroes.  The address ranges are still valid, they are just empty.

If a child process accesses memory that was MADV_DONTFORK, it will get a
segmentation fault, since those address ranges are no longer valid in
the child after fork.

Since MADV_DONTFORK also seems to be used to allow very large programs
to fork in systems with strict memory overcommit restrictions, changing
the semantics of MADV_DONTFORK might break existing programs.

The use case is libraries that store or cache information, and want to
know that they need to regenerate it in the child process after fork.

Examples of this would be:
 - systemd/pulseaudio API checks (fail after fork) (replacing a getpid
   check, which is too slow without a PID cache)
 - PKCS#11 API reinitialization check (mandated by specification)
 - glibc's upcoming PRNG (reseed after fork)
 - OpenSSL PRNG (reseed after fork)

The security benefits of a forking server having a re-inialized PRNG in
every child process are pretty obvious.  However, due to libraries
having all kinds of internal state, and programs getting compiled with
many different versions of each library, it is unreasonable to expect
calling programs to re-initialize everything manually after fork.

A further complication is the proliferation of clone flags, programs
bypassing glibc's functions to call clone directly, and programs calling
unshare, causing the glibc pthread_atfork hook to not get called.

It would be better to have the kernel take care of this automatically.

The patchset also adds MADV_KEEPONFORK, to undo the effects of a prior
MADV_WIPEONFORK.

This is similar to the OpenBSD minherit syscall with MAP_INHERIT_ZERO:

    https://man.openbsd.org/minherit.2

This patch (of 2):

MPX only seems to be available on 64 bit CPUs, starting with Skylake and
Goldmont.  Move VM_MPX into the 64 bit only portion of vma->vm_flags, in
order to free up a VMA flag.

Link: http://lkml.kernel.org/r/20170811212829.29186-2-riel@redhat.com
	Signed-off-by: Rik van Riel <riel@redhat.com>
	Acked-by: Dave Hansen <dave.hansen@intel.com>
	Cc: Mike Kravetz <mike.kravetz@oracle.com>
	Cc: Florian Weimer <fweimer@redhat.com>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Will Drewry <wad@chromium.org>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: "Kirill A. Shutemov" <kirill@shutemov.name>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Colm MacCÃ¡rtaigh <colm@allcosts.net>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit df3735c5b40fad8d0d28eb8ab065fe955b3347ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/Kconfig
diff --cc arch/x86/Kconfig
index 48ae09959d87,4b278a33ccbb..000000000000
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@@ -1725,6 -1803,50 +1725,53 @@@ config X86_SMA
  
  	  If unsure, say Y.
  
++<<<<<<< HEAD
++=======
+ config X86_INTEL_MPX
+ 	prompt "Intel MPX (Memory Protection Extensions)"
+ 	def_bool n
+ 	# Note: only available in 64-bit mode due to VMA flags shortage
+ 	depends on CPU_SUP_INTEL && X86_64
+ 	select ARCH_USES_HIGH_VMA_FLAGS
+ 	---help---
+ 	  MPX provides hardware features that can be used in
+ 	  conjunction with compiler-instrumented code to check
+ 	  memory references.  It is designed to detect buffer
+ 	  overflow or underflow bugs.
+ 
+ 	  This option enables running applications which are
+ 	  instrumented or otherwise use MPX.  It does not use MPX
+ 	  itself inside the kernel or to protect the kernel
+ 	  against bad memory references.
+ 
+ 	  Enabling this option will make the kernel larger:
+ 	  ~8k of kernel text and 36 bytes of data on a 64-bit
+ 	  defconfig.  It adds a long to the 'mm_struct' which
+ 	  will increase the kernel memory overhead of each
+ 	  process and adds some branches to paths used during
+ 	  exec() and munmap().
+ 
+ 	  For details, see Documentation/x86/intel_mpx.txt
+ 
+ 	  If unsure, say N.
+ 
+ config X86_INTEL_MEMORY_PROTECTION_KEYS
+ 	prompt "Intel Memory Protection Keys"
+ 	def_bool y
+ 	# Note: only available in 64-bit mode
+ 	depends on CPU_SUP_INTEL && X86_64
+ 	select ARCH_USES_HIGH_VMA_FLAGS
+ 	select ARCH_HAS_PKEYS
+ 	---help---
+ 	  Memory Protection Keys provides a mechanism for enforcing
+ 	  page-based protections, but without requiring modification of the
+ 	  page tables when an application changes protection domains.
+ 
+ 	  For details, see Documentation/x86/protection-keys.txt
+ 
+ 	  If unsure, say y.
+ 
++>>>>>>> df3735c5b40f (x86,mpx: make mpx depend on x86-64 to free up VMA flag)
  config EFI
  	bool "EFI runtime service support"
  	depends on ACPI
* Unmerged path arch/x86/Kconfig
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 329d8a2b3e80..afd168eebbac 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -161,10 +161,12 @@ extern unsigned int kobjsize(const void *objp);
 #define VM_HIGH_ARCH_BIT_1	33	/* bit only usable on 64-bit architectures */
 #define VM_HIGH_ARCH_BIT_2	34	/* bit only usable on 64-bit architectures */
 #define VM_HIGH_ARCH_BIT_3	35	/* bit only usable on 64-bit architectures */
+#define VM_HIGH_ARCH_BIT_4	36	/* bit only usable on 64-bit architectures */
 #define VM_HIGH_ARCH_0	BIT(VM_HIGH_ARCH_BIT_0)
 #define VM_HIGH_ARCH_1	BIT(VM_HIGH_ARCH_BIT_1)
 #define VM_HIGH_ARCH_2	BIT(VM_HIGH_ARCH_BIT_2)
 #define VM_HIGH_ARCH_3	BIT(VM_HIGH_ARCH_BIT_3)
+#define VM_HIGH_ARCH_4	BIT(VM_HIGH_ARCH_BIT_4)
 #endif /* CONFIG_ARCH_USES_HIGH_VMA_FLAGS */
 
 /*
@@ -195,9 +197,11 @@ extern unsigned int kobjsize(const void *objp);
 # define VM_MAPPED_COPY	VM_ARCH_1	/* T if mapped copy of data (nommu mmap) */
 #endif
 
-#if defined(CONFIG_X86)
+#if defined(CONFIG_X86_INTEL_MPX)
 /* MPX specific bounds table or bounds directory */
-# define VM_MPX		VM_ARCH_2
+# define VM_MPX		VM_HIGH_ARCH_BIT_4
+#else
+# define VM_MPX		VM_NONE
 #endif
 
 #ifndef VM_GROWSUP
