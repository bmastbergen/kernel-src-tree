net: GRE: Add is_gretap_dev, is_ip6gretap_dev

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] gre: Add is_gretap_dev, is_ip6gretap_dev (Ivan Vecera) [1585256]
Rebuild_FUZZ: 94.12%
commit-author Petr Machata <petrm@mellanox.com>
commit d1b2a6c4bed99fc7e8a11e7abcff19293d1974f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d1b2a6c4.failed

Determining whether a device is a GRE device is easily done by
inspecting struct net_device.type. However, for the tap variants, the
type is just ARPHRD_ETHER.

Therefore introduce two predicate functions that use netdev_ops to tell
the tap devices.

	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d1b2a6c4bed99fc7e8a11e7abcff19293d1974f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_gre.c
diff --cc net/ipv6/ip6_gre.c
index 36b8677323aa,4f150a394387..000000000000
--- a/net/ipv6/ip6_gre.c
+++ b/net/ipv6/ip6_gre.c
@@@ -1291,8 -1785,48 +1291,50 @@@ static void ip6gre_tap_setup(struct net
  	netif_keep_dst(dev);
  }
  
++<<<<<<< HEAD
++=======
+ bool is_ip6gretap_dev(const struct net_device *dev)
+ {
+ 	return dev->netdev_ops == &ip6gre_tap_netdev_ops;
+ }
+ EXPORT_SYMBOL_GPL(is_ip6gretap_dev);
+ 
+ static bool ip6gre_netlink_encap_parms(struct nlattr *data[],
+ 				       struct ip_tunnel_encap *ipencap)
+ {
+ 	bool ret = false;
+ 
+ 	memset(ipencap, 0, sizeof(*ipencap));
+ 
+ 	if (!data)
+ 		return ret;
+ 
+ 	if (data[IFLA_GRE_ENCAP_TYPE]) {
+ 		ret = true;
+ 		ipencap->type = nla_get_u16(data[IFLA_GRE_ENCAP_TYPE]);
+ 	}
+ 
+ 	if (data[IFLA_GRE_ENCAP_FLAGS]) {
+ 		ret = true;
+ 		ipencap->flags = nla_get_u16(data[IFLA_GRE_ENCAP_FLAGS]);
+ 	}
+ 
+ 	if (data[IFLA_GRE_ENCAP_SPORT]) {
+ 		ret = true;
+ 		ipencap->sport = nla_get_be16(data[IFLA_GRE_ENCAP_SPORT]);
+ 	}
+ 
+ 	if (data[IFLA_GRE_ENCAP_DPORT]) {
+ 		ret = true;
+ 		ipencap->dport = nla_get_be16(data[IFLA_GRE_ENCAP_DPORT]);
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> d1b2a6c4bed9 (net: GRE: Add is_gretap_dev, is_ip6gretap_dev)
  static int ip6gre_newlink(struct net *src_net, struct net_device *dev,
 -			  struct nlattr *tb[], struct nlattr *data[],
 -			  struct netlink_ext_ack *extack)
 +	struct nlattr *tb[], struct nlattr *data[])
  {
  	struct ip6_tnl *nt;
  	struct net *net = dev_net(dev);
diff --git a/include/net/gre.h b/include/net/gre.h
index 03e366557bbf..67403a1f566c 100644
--- a/include/net/gre.h
+++ b/include/net/gre.h
@@ -35,6 +35,9 @@ struct net_device *gretap_fb_dev_create(struct net *net, const char *name);
 int gre_parse_header(struct sk_buff *skb, struct tnl_ptk_info *tpi,
 		     bool *csum_err, __be16 proto, int nhs);
 
+bool is_gretap_dev(const struct net_device *dev);
+bool is_ip6gretap_dev(const struct net_device *dev);
+
 static inline int gre_calc_hlen(__be16 o_flags)
 {
 	int addend = 4;
diff --git a/net/ipv4/ip_gre.c b/net/ipv4/ip_gre.c
index 35872faba784..36d100f15d2b 100644
--- a/net/ipv4/ip_gre.c
+++ b/net/ipv4/ip_gre.c
@@ -951,6 +951,12 @@ static void ipgre_tap_setup(struct net_device *dev)
 	ip_tunnel_setup(dev, gre_tap_net_id);
 }
 
+bool is_gretap_dev(const struct net_device *dev)
+{
+	return dev->netdev_ops == &gre_tap_netdev_ops;
+}
+EXPORT_SYMBOL_GPL(is_gretap_dev);
+
 static int ipgre_newlink(struct net *src_net, struct net_device *dev,
 			 struct nlattr *tb[], struct nlattr *data[])
 {
* Unmerged path net/ipv6/ip6_gre.c
