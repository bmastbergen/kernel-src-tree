mmc/block: remove a call to blk_queue_bounce_limit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] block: remove a call to blk_queue_bounce_limit (Gopal Tiwari) [1456570]
Rebuild_FUZZ: 95.83%
commit-author Christoph Hellwig <hch@lst.de>
commit 8298912bb6de7e3c9f86ad19d6488ac88cd0e940
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8298912b.failed

BLK_BOUNCE_ANY is the defauly now, so the call is superflous.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 8298912bb6de7e3c9f86ad19d6488ac88cd0e940)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/queue.c
diff --cc drivers/mmc/core/queue.c
index b0ae9d688e28,b659a28c8018..000000000000
--- a/drivers/mmc/core/queue.c
+++ b/drivers/mmc/core/queue.c
@@@ -298,35 -387,11 +298,43 @@@ int mmc_init_queue(struct mmc_queue *mq
  	if (mmc_can_erase(card))
  		mmc_queue_setup_discard(mq->queue, card);
  
++<<<<<<< HEAD
 +#ifdef CONFIG_MMC_BLOCK_BOUNCE
 +	if (host->max_segs == 1) {
 +		unsigned int bouncesz;
 +
 +		bouncesz = MMC_QUEUE_BOUNCESZ;
 +
 +		if (bouncesz > host->max_req_size)
 +			bouncesz = host->max_req_size;
 +		if (bouncesz > host->max_seg_size)
 +			bouncesz = host->max_seg_size;
 +		if (bouncesz > (host->max_blk_count * 512))
 +			bouncesz = host->max_blk_count * 512;
 +
 +		if (bouncesz > 512 &&
 +		    mmc_queue_alloc_bounce_bufs(mq, bouncesz)) {
 +			blk_queue_bounce_limit(mq->queue, BLK_BOUNCE_ANY);
 +			blk_queue_max_hw_sectors(mq->queue, bouncesz / 512);
 +			blk_queue_max_segments(mq->queue, bouncesz / 512);
 +			blk_queue_max_segment_size(mq->queue, bouncesz);
 +
 +			ret = mmc_queue_alloc_bounce_sgs(mq, bouncesz);
 +			if (ret)
 +				goto cleanup_queue;
 +			bounce = true;
 +		}
 +	}
 +#endif
 +
 +	if (!bounce) {
++=======
+ 	if (card->bouncesz) {
+ 		blk_queue_max_hw_sectors(mq->queue, card->bouncesz / 512);
+ 		blk_queue_max_segments(mq->queue, card->bouncesz / 512);
+ 		blk_queue_max_segment_size(mq->queue, card->bouncesz);
+ 	} else {
++>>>>>>> 8298912bb6de (mmc/block: remove a call to blk_queue_bounce_limit)
  		blk_queue_bounce_limit(mq->queue, limit);
  		blk_queue_max_hw_sectors(mq->queue,
  			min(host->max_blk_count, host->max_req_size / 512));
* Unmerged path drivers/mmc/core/queue.c
