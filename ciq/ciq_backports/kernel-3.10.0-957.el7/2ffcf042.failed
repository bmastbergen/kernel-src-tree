IB/srpt: Move the code for parsing struct ib_cm_req_event_param

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Bart Van Assche <bart.vanassche@wdc.com>
commit 2ffcf04263832557dc55d5a7339d8f29428b679a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/2ffcf042.failed

This patch does not change any functionality but makes srpt_cm_req_recv()
independent of the IB/CM and hence simplifies the patch that introduces
RDMA/CM support.

	Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 2ffcf04263832557dc55d5a7339d8f29428b679a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/srpt/ib_srpt.c
diff --cc drivers/infiniband/ulp/srpt/ib_srpt.c
index 22badbe26bbc,bf37816a1b12..000000000000
--- a/drivers/infiniband/ulp/srpt/ib_srpt.c
+++ b/drivers/infiniband/ulp/srpt/ib_srpt.c
@@@ -1976,33 -2037,40 +1978,45 @@@ static void srpt_release_channel_work(s
   * functions returns zero. Otherwise the caller remains the owner of cm_id.
   */
  static int srpt_cm_req_recv(struct ib_cm_id *cm_id,
- 			    struct ib_cm_req_event_param *param,
- 			    void *private_data)
+ 			    u8 port_num, __be16 pkey,
+ 			    const struct srp_login_req *req,
+ 			    const char *src_addr)
  {
  	struct srpt_device *sdev = cm_id->context;
++<<<<<<< HEAD
 +	struct srpt_port *sport = &sdev->port[param->port - 1];
 +	struct srp_login_req *req;
 +	struct srp_login_rsp *rsp;
 +	struct srp_login_rej *rej;
 +	struct ib_cm_rep_param *rep_param;
 +	struct srpt_rdma_ch *ch, *tmp_ch;
++=======
+ 	struct srpt_port *sport = &sdev->port[port_num - 1];
+ 	struct srpt_nexus *nexus;
+ 	struct srp_login_rsp *rsp = NULL;
+ 	struct srp_login_rej *rej = NULL;
+ 	struct ib_cm_rep_param *rep_param = NULL;
+ 	struct srpt_rdma_ch *ch;
++>>>>>>> 2ffcf0426383 (IB/srpt: Move the code for parsing struct ib_cm_req_event_param)
  	char i_port_id[36];
  	u32 it_iu_len;
 -	int i, ret;
 +	int i, ret = 0;
  
  	WARN_ON_ONCE(irqs_disabled());
  
- 	if (WARN_ON(!sdev || !private_data))
+ 	if (WARN_ON(!sdev || !req))
  		return -EINVAL;
  
- 	req = (struct srp_login_req *)private_data;
- 
  	it_iu_len = be32_to_cpu(req->req_it_iu_len);
  
 -	pr_info("Received SRP_LOGIN_REQ with i_port_id %pI6, t_port_id %pI6 and it_iu_len %d on port %d (guid=%pI6); pkey %#04x\n",
 +	pr_info("Received SRP_LOGIN_REQ with i_port_id %pI6, t_port_id %pI6 and it_iu_len %d on port %d (guid=%pI6)\n",
  		req->initiator_port_id, req->target_port_id, it_iu_len,
++<<<<<<< HEAD
 +		param->port, &sport->gid);
++=======
+ 		port_num, &sport->gid, be16_to_cpu(pkey));
++>>>>>>> 2ffcf0426383 (IB/srpt: Move the code for parsing struct ib_cm_req_event_param)
  
 -	nexus = srpt_get_nexus(sport, req->initiator_port_id,
 -			       req->target_port_id);
 -	if (IS_ERR(nexus)) {
 -		ret = PTR_ERR(nexus);
 -		goto out;
 -	}
 -
 -	ret = -ENOMEM;
  	rsp = kzalloc(sizeof(*rsp), GFP_KERNEL);
  	rej = kzalloc(sizeof(*rej), GFP_KERNEL);
  	rep_param = kzalloc(sizeof(*rep_param), GFP_KERNEL);
@@@ -2023,11 -2087,9 +2037,17 @@@
  	}
  
  	if (!sport->enabled) {
++<<<<<<< HEAD
 +		rej->reason = cpu_to_be32(
 +			      SRP_LOGIN_REJ_INSUFFICIENT_RESOURCES);
 +		ret = -EINVAL;
 +		pr_err("rejected SRP_LOGIN_REQ because the target port"
 +		       " has not yet been enabled\n");
++=======
+ 		rej->reason = cpu_to_be32(SRP_LOGIN_REJ_INSUFFICIENT_RESOURCES);
+ 		pr_info("rejected SRP_LOGIN_REQ because target port %s_%d has not yet been enabled\n",
+ 			sport->sdev->device->name, port_num);
++>>>>>>> 2ffcf0426383 (IB/srpt: Move the code for parsing struct ib_cm_req_event_param)
  		goto reject;
  	}
  
@@@ -2078,12 -2112,12 +2098,21 @@@
  
  	init_rcu_head(&ch->rcu);
  	kref_init(&ch->kref);
++<<<<<<< HEAD
 +	ch->zw_cqe.done = srpt_zerolength_write_done;
 +	INIT_WORK(&ch->release_work, srpt_release_channel_work);
 +	memcpy(ch->i_port_id, req->initiator_port_id, 16);
 +	memcpy(ch->t_port_id, req->target_port_id, 16);
 +	ch->sport = &sdev->port[param->port - 1];
 +	ch->cm_id = cm_id;
++=======
+ 	ch->pkey = be16_to_cpu(pkey);
+ 	ch->nexus = nexus;
+ 	ch->zw_cqe.done = srpt_zerolength_write_done;
+ 	INIT_WORK(&ch->release_work, srpt_release_channel_work);
+ 	ch->sport = sport;
+ 	ch->ib_cm.cm_id = cm_id;
++>>>>>>> 2ffcf0426383 (IB/srpt: Move the code for parsing struct ib_cm_req_event_param)
  	cm_id->context = ch;
  	/*
  	 * ch->rq_size should be at least as large as the initiator queue
@@@ -2131,19 -2168,10 +2160,23 @@@
  		goto free_recv_ring;
  	}
  
++<<<<<<< HEAD
 +	ret = srpt_ch_qp_rtr(ch, ch->qp);
 +	if (ret) {
 +		rej->reason = cpu_to_be32(SRP_LOGIN_REJ_INSUFFICIENT_RESOURCES);
 +		pr_err("rejected SRP_LOGIN_REQ because enabling"
 +		       " RTR failed (error code = %d)\n", ret);
 +		goto destroy_ib;
 +	}
 +
 +	srpt_format_guid(ch->sess_name, sizeof(ch->sess_name),
 +			 &param->primary_path->dgid.global.interface_id);
++=======
+ 	strlcpy(ch->sess_name, src_addr, sizeof(ch->sess_name));
++>>>>>>> 2ffcf0426383 (IB/srpt: Move the code for parsing struct ib_cm_req_event_param)
  	snprintf(i_port_id, sizeof(i_port_id), "0x%016llx%016llx",
 -			be64_to_cpu(*(__be64 *)nexus->i_port_id),
 -			be64_to_cpu(*(__be64 *)(nexus->i_port_id + 8)));
 +			be64_to_cpu(*(__be64 *)ch->i_port_id),
 +			be64_to_cpu(*(__be64 *)(ch->i_port_id + 8)));
  
  	pr_debug("registering session %s\n", ch->sess_name);
  
@@@ -2161,11 -2189,51 +2194,53 @@@
  						TARGET_PROT_NORMAL,
  						i_port_id + 2, ch, NULL);
  	if (IS_ERR_OR_NULL(ch->sess)) {
 -		ret = PTR_ERR(ch->sess);
 -		pr_info("Rejected login for initiator %s: ret = %d.\n",
 -			ch->sess_name, ret);
 -		rej->reason = cpu_to_be32(ret == -ENOMEM ?
 +		pr_info("Rejected login because no ACL has been configured yet for initiator %s.\n",
 +			ch->sess_name);
 +		rej->reason = cpu_to_be32((PTR_ERR(ch->sess) == -ENOMEM) ?
  				SRP_LOGIN_REJ_INSUFFICIENT_RESOURCES :
  				SRP_LOGIN_REJ_CHANNEL_LIMIT_REACHED);
++<<<<<<< HEAD
++=======
+ 		goto reject;
+ 	}
+ 
+ 	mutex_lock(&sport->mutex);
+ 
+ 	if ((req->req_flags & SRP_MTCH_ACTION) == SRP_MULTICHAN_SINGLE) {
+ 		struct srpt_rdma_ch *ch2;
+ 
+ 		rsp->rsp_flags = SRP_LOGIN_RSP_MULTICHAN_NO_CHAN;
+ 
+ 		list_for_each_entry(ch2, &nexus->ch_list, list) {
+ 			if (srpt_disconnect_ch(ch2) < 0)
+ 				continue;
+ 			pr_info("Relogin - closed existing channel %s\n",
+ 				ch2->sess_name);
+ 			rsp->rsp_flags = SRP_LOGIN_RSP_MULTICHAN_TERMINATED;
+ 		}
+ 	} else {
+ 		rsp->rsp_flags = SRP_LOGIN_RSP_MULTICHAN_MAINTAINED;
+ 	}
+ 
+ 	list_add_tail_rcu(&ch->list, &nexus->ch_list);
+ 
+ 	if (!sport->enabled) {
+ 		rej->reason = cpu_to_be32(
+ 				SRP_LOGIN_REJ_INSUFFICIENT_RESOURCES);
+ 		pr_info("rejected SRP_LOGIN_REQ because target %s_%d is not enabled\n",
+ 			sdev->device->name, port_num);
+ 		mutex_unlock(&sport->mutex);
+ 		goto reject;
+ 	}
+ 
+ 	mutex_unlock(&sport->mutex);
+ 
+ 	ret = srpt_ch_qp_rtr(ch, ch->qp);
+ 	if (ret) {
+ 		rej->reason = cpu_to_be32(SRP_LOGIN_REJ_INSUFFICIENT_RESOURCES);
+ 		pr_err("rejected SRP_LOGIN_REQ because enabling RTR failed (error code = %d)\n",
+ 		       ret);
++>>>>>>> 2ffcf0426383 (IB/srpt: Move the code for parsing struct ib_cm_req_event_param)
  		goto destroy_ib;
  	}
  
* Unmerged path drivers/infiniband/ulp/srpt/ib_srpt.c
