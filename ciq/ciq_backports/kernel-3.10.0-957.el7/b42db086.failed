xfs: enhance dinode verifier

jira LE-1907
cve CVE-2018-10322
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Eric Sandeen <sandeen@sandeen.net>
commit b42db0860e13067fcc7cbfba3966c9e652668bbc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b42db086.failed

Add several more validations to xfs_dinode_verify:

- For LOCAL data fork formats, di_nextents must be 0.
- For LOCAL attr fork formats, di_anextents must be 0.
- For inodes with no attr fork offset,
  - format must be XFS_DINODE_FMT_EXTENTS if set at all
  - di_anextents must be 0.

Thanks to dchinner for pointing out a couple related checks I had
forgotten to add.

	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=199377
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit b42db0860e13067fcc7cbfba3966c9e652668bbc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_inode_buf.c
diff --cc fs/xfs/libxfs/xfs_inode_buf.c
index 5fb249cbd278,1201107eabc6..000000000000
--- a/fs/xfs/libxfs/xfs_inode_buf.c
+++ b/fs/xfs/libxfs/xfs_inode_buf.c
@@@ -396,11 -425,93 +396,98 @@@ xfs_dinode_verify
  
  	mode = be16_to_cpu(dip->di_mode);
  	if (mode && xfs_mode_to_ftype(mode) == XFS_DIR3_FT_UNKNOWN)
 -		return __this_address;
 +		return false;
  
  	/* No zero-length symlinks/dirs. */
++<<<<<<< HEAD
 +	if ((S_ISLNK(mode) || S_ISDIR(mode)) && dip->di_size == 0)
 +		return false;
++=======
+ 	if ((S_ISLNK(mode) || S_ISDIR(mode)) && di_size == 0)
+ 		return __this_address;
+ 
+ 	/* Fork checks carried over from xfs_iformat_fork */
+ 	if (mode &&
+ 	    be32_to_cpu(dip->di_nextents) + be16_to_cpu(dip->di_anextents) >
+ 			be64_to_cpu(dip->di_nblocks))
+ 		return __this_address;
+ 
+ 	if (mode && XFS_DFORK_BOFF(dip) > mp->m_sb.sb_inodesize)
+ 		return __this_address;
+ 
+ 	flags = be16_to_cpu(dip->di_flags);
+ 
+ 	if (mode && (flags & XFS_DIFLAG_REALTIME) && !mp->m_rtdev_targp)
+ 		return __this_address;
+ 
+ 	/* Do we have appropriate data fork formats for the mode? */
+ 	switch (mode & S_IFMT) {
+ 	case S_IFIFO:
+ 	case S_IFCHR:
+ 	case S_IFBLK:
+ 	case S_IFSOCK:
+ 		if (dip->di_format != XFS_DINODE_FMT_DEV)
+ 			return __this_address;
+ 		break;
+ 	case S_IFREG:
+ 	case S_IFLNK:
+ 	case S_IFDIR:
+ 		switch (dip->di_format) {
+ 		case XFS_DINODE_FMT_LOCAL:
+ 			/*
+ 			 * no local regular files yet
+ 			 */
+ 			if (S_ISREG(mode))
+ 				return __this_address;
+ 			if (di_size > XFS_DFORK_DSIZE(dip, mp))
+ 				return __this_address;
+ 			if (dip->di_nextents)
+ 				return __this_address;
+ 			/* fall through */
+ 		case XFS_DINODE_FMT_EXTENTS:
+ 		case XFS_DINODE_FMT_BTREE:
+ 			break;
+ 		default:
+ 			return __this_address;
+ 		}
+ 		break;
+ 	case 0:
+ 		/* Uninitialized inode ok. */
+ 		break;
+ 	default:
+ 		return __this_address;
+ 	}
+ 
+ 	if (XFS_DFORK_Q(dip)) {
+ 		switch (dip->di_aformat) {
+ 		case XFS_DINODE_FMT_LOCAL:
+ 			if (dip->di_anextents)
+ 				return __this_address;
+ 		/* fall through */
+ 		case XFS_DINODE_FMT_EXTENTS:
+ 		case XFS_DINODE_FMT_BTREE:
+ 			break;
+ 		default:
+ 			return __this_address;
+ 		}
+ 	} else {
+ 		/*
+ 		 * If there is no fork offset, this may be a freshly-made inode
+ 		 * in a new disk cluster, in which case di_aformat is zeroed.
+ 		 * Otherwise, such an inode must be in EXTENTS format; this goes
+ 		 * for freed inodes as well.
+ 		 */
+ 		switch (dip->di_aformat) {
+ 		case 0:
+ 		case XFS_DINODE_FMT_EXTENTS:
+ 			break;
+ 		default:
+ 			return __this_address;
+ 		}
+ 		if (dip->di_anextents)
+ 			return __this_address;
+ 	}
++>>>>>>> b42db0860e13 (xfs: enhance dinode verifier)
  
  	/* only version 3 or greater inodes are extensively verified here */
  	if (dip->di_version < 3)
* Unmerged path fs/xfs/libxfs/xfs_inode_buf.c
