i40e: fix condition of WARN_ONCE for stat strings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 07f3701387dcab3a4fb0166098fb2754a1b927e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/07f37013.failed

Commit 9b10df596bd4 ("i40e: use WARN_ONCE to replace the commented
BUG_ON size check") introduced a warning check to make sure
that the size of the stat strings was always the expected value. This
code accidentally inverted the check of the data pointer. Fix this so
that we accurately count the size of the stats we copied in.

This fixes an erroneous WARN kernel splat that occurs when requesting
ethtool statistics.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Tested-by: Mauro S M Rodrigues <maurosr@linux.vnet.ibm.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 07f3701387dcab3a4fb0166098fb2754a1b927e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_ethtool.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index 2d9dad78b122,5ff6caa83948..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@@ -1672,46 -1903,121 +1672,59 @@@ static void i40e_get_ethtool_stats(stru
  	}
  	rcu_read_unlock();
  	if (vsi != pf->vsi[pf->lan_vsi] || pf->hw.partition_id != 1)
 -		goto check_data_pointer;
 -
 -	veb_stats = ((pf->lan_veb != I40E_NO_VEB) &&
 -		     (pf->flags & I40E_FLAG_VEB_STATS_ENABLED));
 -
 -	/* If veb stats aren't enabled, pass NULL instead of the veb so that
 -	 * we initialize stats to zero and update the data pointer
 -	 * intelligently
 -	 */
 -	i40e_add_ethtool_stats(&data, veb_stats ? veb : NULL,
 -			       i40e_gstrings_veb_stats);
 -
 -	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)
 -		i40e_add_ethtool_stats(&data, veb_stats ? veb : NULL,
 -				       i40e_gstrings_veb_tc_stats);
 -
 -	i40e_add_ethtool_stats(&data, pf, i40e_gstrings_stats);
 +		return;
  
 -	for (i = 0; i < I40E_MAX_USER_PRIORITY; i++) {
 -		struct i40e_pfc_stats pfc = i40e_get_pfc_stats(pf, i);
 +	if ((pf->lan_veb != I40E_NO_VEB) &&
 +	    (pf->flags & I40E_FLAG_VEB_STATS_ENABLED)) {
 +		struct i40e_veb *veb = pf->veb[pf->lan_veb];
  
 -		i40e_add_ethtool_stats(&data, &pfc, i40e_gstrings_pfc_stats);
++<<<<<<< HEAD
 +		for (j = 0; j < I40E_VEB_STATS_LEN; j++) {
 +			p = (char *)veb;
 +			p += i40e_gstrings_veb_stats[j].stat_offset;
 +			data[i++] = (i40e_gstrings_veb_stats[j].sizeof_stat ==
 +				     sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
 +		}
 +		for (j = 0; j < I40E_MAX_TRAFFIC_CLASS; j++) {
 +			data[i++] = veb->tc_stats.tc_tx_packets[j];
 +			data[i++] = veb->tc_stats.tc_tx_bytes[j];
 +			data[i++] = veb->tc_stats.tc_rx_packets[j];
 +			data[i++] = veb->tc_stats.tc_rx_bytes[j];
 +		}
 +	} else {
 +		i += I40E_VEB_STATS_TOTAL;
  	}
 -
 -check_data_pointer:
 -	WARN_ONCE(data - p != i40e_get_stats_count(netdev),
 -		  "ethtool stats count mismatch!");
 -}
 -
 -/**
 - * __i40e_add_stat_strings - copy stat strings into ethtool buffer
 - * @p: ethtool supplied buffer
 - * @stats: stat definitions array
 - * @size: size of the stats array
 - *
 - * Format and copy the strings described by stats into the buffer pointed at
 - * by p.
 - **/
 -static void __i40e_add_stat_strings(u8 **p, const struct i40e_stats stats[],
 -				    const unsigned int size, ...)
 -{
 -	unsigned int i;
 -
 -	for (i = 0; i < size; i++) {
 -		va_list args;
 -
 -		va_start(args, size);
 -		vsnprintf(*p, ETH_GSTRING_LEN, stats[i].stat_string, args);
 -		*p += ETH_GSTRING_LEN;
 -		va_end(args);
 +	for (j = 0; j < I40E_GLOBAL_STATS_LEN; j++) {
 +		p = (char *)pf + i40e_gstrings_stats[j].stat_offset;
 +		data[i++] = (i40e_gstrings_stats[j].sizeof_stat ==
 +			     sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
  	}
 -}
 -
 -/**
 - * 40e_add_stat_strings - copy stat strings into ethtool buffer
 - * @p: ethtool supplied buffer
 - * @stats: stat definitions array
 - *
 - * Format and copy the strings described by the const static stats value into
 - * the buffer pointed at by p. Assumes that stats can have ARRAY_SIZE called
 - * for it.
 - **/
 -#define i40e_add_stat_strings(p, stats, ...) \
 -	__i40e_add_stat_strings(p, stats, ARRAY_SIZE(stats), ## __VA_ARGS__)
 -
 -/**
 - * i40e_get_stat_strings - copy stat strings into supplied buffer
 - * @netdev: the netdev to collect strings for
 - * @data: supplied buffer to copy strings into
 - *
 - * Copy the strings related to stats for this netdev. Expects data to be
 - * pre-allocated with the size reported by i40e_get_stats_count. Note that the
 - * strings must be copied in a static order and the total count must not
 - * change for a given netdev. See i40e_get_stats_count for more details.
 - **/
 -static void i40e_get_stat_strings(struct net_device *netdev, u8 *data)
 -{
 -	struct i40e_netdev_priv *np = netdev_priv(netdev);
 -	struct i40e_vsi *vsi = np->vsi;
 -	struct i40e_pf *pf = vsi->back;
 -	unsigned int i;
 -	u8 *p = data;
 -
 -	i40e_add_stat_strings(&data, i40e_gstrings_net_stats);
 -
 -	i40e_add_stat_strings(&data, i40e_gstrings_misc_stats);
 -
 -	for (i = 0; i < I40E_MAX_NUM_QUEUES(netdev); i++) {
 -		snprintf(data, ETH_GSTRING_LEN, "tx-%u.tx_packets", i);
 -		data += ETH_GSTRING_LEN;
 -		snprintf(data, ETH_GSTRING_LEN, "tx-%u.tx_bytes", i);
 -		data += ETH_GSTRING_LEN;
 -		snprintf(data, ETH_GSTRING_LEN, "rx-%u.rx_packets", i);
 -		data += ETH_GSTRING_LEN;
 -		snprintf(data, ETH_GSTRING_LEN, "rx-%u.rx_bytes", i);
 -		data += ETH_GSTRING_LEN;
 +	for (j = 0; j < I40E_MAX_USER_PRIORITY; j++) {
 +		data[i++] = pf->stats.priority_xon_tx[j];
 +		data[i++] = pf->stats.priority_xoff_tx[j];
  	}
 -	if (vsi != pf->vsi[pf->lan_vsi] || pf->hw.partition_id != 1)
 -		return;
 -
 -	i40e_add_stat_strings(&data, i40e_gstrings_veb_stats);
 -
 +	for (j = 0; j < I40E_MAX_USER_PRIORITY; j++) {
 +		data[i++] = pf->stats.priority_xon_rx[j];
 +		data[i++] = pf->stats.priority_xoff_rx[j];
 +	}
 +	for (j = 0; j < I40E_MAX_USER_PRIORITY; j++)
 +		data[i++] = pf->stats.priority_xon_2_xoff[j];
++=======
+ 	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)
+ 		i40e_add_stat_strings(&data, i40e_gstrings_veb_tc_stats, i);
+ 
+ 	i40e_add_stat_strings(&data, i40e_gstrings_stats);
+ 
+ 	for (i = 0; i < I40E_MAX_USER_PRIORITY; i++)
+ 		i40e_add_stat_strings(&data, i40e_gstrings_pfc_stats, i);
+ 
+ 	WARN_ONCE(data - p != i40e_get_stats_count(netdev) * ETH_GSTRING_LEN,
+ 		  "stat strings count mismatch!");
++>>>>>>> 07f3701387dc (i40e: fix condition of WARN_ONCE for stat strings)
  }
  
 -static void i40e_get_priv_flag_strings(struct net_device *netdev, u8 *data)
 +static void i40e_get_strings(struct net_device *netdev, u32 stringset,
 +			     u8 *data)
  {
  	struct i40e_netdev_priv *np = netdev_priv(netdev);
  	struct i40e_vsi *vsi = np->vsi;
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_ethtool.c
