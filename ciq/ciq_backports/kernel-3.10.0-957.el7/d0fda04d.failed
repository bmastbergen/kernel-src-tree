i40e/i40evf: take into account queue map from vf when handling queues

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Harshitha Ramamurthy <harshitha.ramamurthy@intel.com>
commit d0fda04d7e31e52f19ad7a21fb8d6700db55a6e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d0fda04d.failed

The expectation of the ops VIRTCHNL_OP_ENABLE_QUEUES and
VIRTCHNL_OP_DISABLE_QUEUES is that the queue map sent by
the VF is taken into account when enabling/disabling
queues in the VF VSI. This patch makes sure that happens.

By breaking out the individual queue set up functions so
that they can be called directly from the i40e_virtchnl_pf.c
file, only the queues as specified by the queue bit map that
accompanies the enable/disable queues ops will be handled.

	Signed-off-by: Harshitha Ramamurthy <harshitha.ramamurthy@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit d0fda04d7e31e52f19ad7a21fb8d6700db55a6e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 3db54f062cec,b500bbf6c43f..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -4164,6 -4228,33 +4164,36 @@@ static void i40e_control_tx_q(struct i4
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * i40e_control_wait_tx_q - Start/stop Tx queue and wait for completion
+  * @seid: VSI SEID
+  * @pf: the PF structure
+  * @pf_q: the PF queue to configure
+  * @is_xdp: true if the queue is used for XDP
+  * @enable: start or stop the queue
+  **/
+ int i40e_control_wait_tx_q(int seid, struct i40e_pf *pf, int pf_q,
+ 			   bool is_xdp, bool enable)
+ {
+ 	int ret;
+ 
+ 	i40e_control_tx_q(pf, pf_q, enable);
+ 
+ 	/* wait for the change to finish */
+ 	ret = i40e_pf_txq_wait(pf, pf_q, enable);
+ 	if (ret) {
+ 		dev_info(&pf->pdev->dev,
+ 			 "VSI seid %d %sTx ring %d %sable timeout\n",
+ 			 seid, (is_xdp ? "XDP " : ""), pf_q,
+ 			 (enable ? "en" : "dis"));
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ /**
++>>>>>>> d0fda04d7e31 (i40e/i40evf: take into account queue map from vf when handling queues)
   * i40e_vsi_control_tx - Start or stop a VSI's rings
   * @vsi: the VSI being configured
   * @enable: start or stop the rings
@@@ -4175,18 -4266,21 +4205,17 @@@ static int i40e_vsi_control_tx(struct i
  
  	pf_q = vsi->base_queue;
  	for (i = 0; i < vsi->num_queue_pairs; i++, pf_q++) {
 -		ret = i40e_control_wait_tx_q(vsi->seid, pf,
 -					     pf_q,
 -					     false /*is xdp*/, enable);
 -		if (ret)
 -			break;
 -
 -		if (!i40e_enabled_xdp_vsi(vsi))
 -			continue;
 +		i40e_control_tx_q(pf, pf_q, enable);
  
 -		ret = i40e_control_wait_tx_q(vsi->seid, pf,
 -					     pf_q + vsi->alloc_queue_pairs,
 -					     true /*is xdp*/, enable);
 -		if (ret)
 +		/* wait for the change to finish */
 +		ret = i40e_pf_txq_wait(pf, pf_q, enable);
 +		if (ret) {
 +			dev_info(&pf->pdev->dev,
 +				 "VSI seid %d Tx ring %d %sable timeout\n",
 +				 vsi->seid, pf_q, (enable ? "en" : "dis"));
  			break;
 +		}
  	}
- 
  	return ret;
  }
  
diff --git a/drivers/net/ethernet/intel/i40e/i40e.h b/drivers/net/ethernet/intel/i40e/i40e.h
index 1d5305235e57..cdf42a2b444b 100644
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@ -955,6 +955,9 @@ void i40e_service_event_schedule(struct i40e_pf *pf);
 void i40e_notify_client_of_vf_msg(struct i40e_vsi *vsi, u32 vf_id,
 				  u8 *msg, u16 len);
 
+int i40e_control_wait_tx_q(int seid, struct i40e_pf *pf, int pf_q, bool is_xdp,
+			   bool enable);
+int i40e_control_wait_rx_q(struct i40e_pf *pf, int pf_q, bool enable);
 int i40e_vsi_start_rings(struct i40e_vsi *vsi);
 void i40e_vsi_stop_rings(struct i40e_vsi *vsi);
 void i40e_vsi_stop_rings_no_wait(struct  i40e_vsi *vsi);
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index 56512968f9a5..5f31cb657cc3 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@ -2178,6 +2178,51 @@ error_param:
 				       aq_ret);
 }
 
+/**
+ * i40e_ctrl_vf_tx_rings
+ * @vsi: the SRIOV VSI being configured
+ * @q_map: bit map of the queues to be enabled
+ * @enable: start or stop the queue
+ **/
+static int i40e_ctrl_vf_tx_rings(struct i40e_vsi *vsi, unsigned long q_map,
+				 bool enable)
+{
+	struct i40e_pf *pf = vsi->back;
+	int ret = 0;
+	u16 q_id;
+
+	for_each_set_bit(q_id, &q_map, I40E_MAX_VF_QUEUES) {
+		ret = i40e_control_wait_tx_q(vsi->seid, pf,
+					     vsi->base_queue + q_id,
+					     false /*is xdp*/, enable);
+		if (ret)
+			break;
+	}
+	return ret;
+}
+
+/**
+ * i40e_ctrl_vf_rx_rings
+ * @vsi: the SRIOV VSI being configured
+ * @q_map: bit map of the queues to be enabled
+ * @enable: start or stop the queue
+ **/
+static int i40e_ctrl_vf_rx_rings(struct i40e_vsi *vsi, unsigned long q_map,
+				 bool enable)
+{
+	struct i40e_pf *pf = vsi->back;
+	int ret = 0;
+	u16 q_id;
+
+	for_each_set_bit(q_id, &q_map, I40E_MAX_VF_QUEUES) {
+		ret = i40e_control_wait_rx_q(pf, vsi->base_queue + q_id,
+					     enable);
+		if (ret)
+			break;
+	}
+	return ret;
+}
+
 /**
  * i40e_vc_enable_queues_msg
  * @vf: pointer to the VF info
@@ -2210,8 +2255,17 @@ static int i40e_vc_enable_queues_msg(struct i40e_vf *vf, u8 *msg, u16 msglen)
 		goto error_param;
 	}
 
-	if (i40e_vsi_start_rings(pf->vsi[vf->lan_vsi_idx]))
+	/* Use the queue bit map sent by the VF */
+	if (i40e_ctrl_vf_rx_rings(pf->vsi[vf->lan_vsi_idx], vqs->rx_queues,
+				  true)) {
+		aq_ret = I40E_ERR_TIMEOUT;
+		goto error_param;
+	}
+	if (i40e_ctrl_vf_tx_rings(pf->vsi[vf->lan_vsi_idx], vqs->tx_queues,
+				  true)) {
 		aq_ret = I40E_ERR_TIMEOUT;
+		goto error_param;
+	}
 
 	/* need to start the rings for additional ADq VSI's as well */
 	if (vf->adq_enabled) {
@@ -2259,8 +2313,17 @@ static int i40e_vc_disable_queues_msg(struct i40e_vf *vf, u8 *msg, u16 msglen)
 		goto error_param;
 	}
 
-	i40e_vsi_stop_rings(pf->vsi[vf->lan_vsi_idx]);
-
+	/* Use the queue bit map sent by the VF */
+	if (i40e_ctrl_vf_tx_rings(pf->vsi[vf->lan_vsi_idx], vqs->tx_queues,
+				  false)) {
+		aq_ret = I40E_ERR_TIMEOUT;
+		goto error_param;
+	}
+	if (i40e_ctrl_vf_rx_rings(pf->vsi[vf->lan_vsi_idx], vqs->rx_queues,
+				  false)) {
+		aq_ret = I40E_ERR_TIMEOUT;
+		goto error_param;
+	}
 error_param:
 	/* send the response to the VF */
 	return i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_DISABLE_QUEUES,
