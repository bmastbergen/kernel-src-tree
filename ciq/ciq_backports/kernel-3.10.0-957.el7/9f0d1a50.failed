sched/deadline: Base GRUB reclaiming on the inactive utilization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Luca Abeni <luca.abeni@santannapisa.it>
commit 9f0d1a5077399143aad7e1244bb031e29116074e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9f0d1a50.failed

Instead of decreasing the runtime as "dq = -Uact dt" (eventually
divided by the maximum utilization available for deadline tasks),
decrease it as "dq = -max{u, (1 - Uinact)} dt", where u is the task
utilization and Uinact is the "inactive utilization".
In this way, the maximum fraction of CPU time that can be reclaimed
is given by the total utilization of deadline tasks.
This approach solves a fairness issue with "traditional" global GRUB
reclaiming: using the traditional GRUB algorithm, if tasks are
allocated to the various cores in a non-uniform way, the
reclaiming mechanism allows some tasks to reclaim more time than
others. This issue is visible starting 11 time-consuming tasks with
runtime 10ms and period 30ms (total utilization 3.666) on a 4-cores
system: some tasks will receive much more than the reserved runtime
(thanks to the reclaiming mechanism), while other tasks will receive
less than the reserved runtime.

	Tested-by: Daniel Bristot de Oliveira <bristot@redhat.com>
	Signed-off-by: Luca Abeni <luca.abeni@santannapisa.it>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Claudio Scordino <claudio@evidence.eu.com>
	Cc: Joel Fernandes <joelaf@google.com>
	Cc: Juri Lelli <juri.lelli@arm.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
	Cc: Mike Galbraith <efault@gmx.de>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Tommaso Cucinotta <tommaso.cucinotta@sssup.it>
Link: http://lkml.kernel.org/r/1495138417-6203-9-git-send-email-luca.abeni@santannapisa.it
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 9f0d1a5077399143aad7e1244bb031e29116074e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/deadline.c
diff --cc kernel/sched/deadline.c
index fc0d2f428765,7d2f05778060..000000000000
--- a/kernel/sched/deadline.c
+++ b/kernel/sched/deadline.c
@@@ -802,17 -955,30 +802,42 @@@ extern bool sched_rt_bandwidth_account(
  /*
   * This function implements the GRUB accounting rule:
   * according to the GRUB reclaiming algorithm, the runtime is
++<<<<<<< HEAD
 + * not decreased as "dq = -dt", but as "dq = -Uact dt", where
 + * Uact is the (per-runqueue) active utilization.
 + * Since rq->dl.running_bw contains Uact * 2^BW_SHIFT, the result
 + * has to be shifted right by BW_SHIFT.
++=======
+  * not decreased as "dq = -dt", but as "dq = -max{u, (1 - Uinact)} dt",
+  * where u is the utilization of the task and Uinact is the
+  * (per-runqueue) inactive utilization, computed as the difference
+  * between the "total runqueue utilization" and the runqueue
+  * active utilization.
+  * Since rq->dl.running_bw and rq->dl.this_bw contain utilizations
+  * multiplied by 2^BW_SHIFT, the result has to be shifted right by BW_SHIFT.
++>>>>>>> 9f0d1a507739 (sched/deadline: Base GRUB reclaiming on the inactive utilization)
   */
- u64 grub_reclaim(u64 delta, struct rq *rq)
+ u64 grub_reclaim(u64 delta, struct rq *rq, struct sched_dl_entity *dl_se)
  {
++<<<<<<< HEAD
 +	delta *= rq->dl.running_bw;
 +	delta >>= BW_SHIFT;
++=======
+ 	u64 u_inact = rq->dl.this_bw - rq->dl.running_bw; /* Utot - Uact */
+ 	u64 u_act;
++>>>>>>> 9f0d1a507739 (sched/deadline: Base GRUB reclaiming on the inactive utilization)
  
- 	return delta;
+ 	/*
+ 	 * Instead of computing max{u, (1 - u_inact)}, we compare
+ 	 * u_inact with 1 - u, because u_inact can be larger than 1
+ 	 * (so, 1 - u_inact would be negative leading to wrong results)
+ 	 */
+ 	if (u_inact > BW_UNIT - dl_se->dl_bw)
+ 		u_act = dl_se->dl_bw;
+ 	else
+ 		u_act = BW_UNIT - u_inact;
+ 
+ 	return (delta * u_act) >> BW_SHIFT;
  }
  
  /*
* Unmerged path kernel/sched/deadline.c
