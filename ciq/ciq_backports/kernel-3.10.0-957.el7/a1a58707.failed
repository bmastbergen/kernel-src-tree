perf script: Use fprintf like printing uniformly

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit a1a587073ccdc6ffae414259f65d0a94cadd0a72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/a1a58707.failed

We've been mixing print() with fprintf() style printing for a while, but
now we need to use fprintf() like syntax uniformly as a preparatory
patch for supporting printing to different files, one per event.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
	Cc: yuzhoujian <yuzhoujian@didichuxing.com>
Link: http://lkml.kernel.org/n/tip-kv5z3v8ptfghbarv3a9usvin@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit a1a587073ccdc6ffae414259f65d0a94cadd0a72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-script.c
diff --cc tools/perf/builtin-script.c
index 5d6697e4eb08,3e83f4735b21..000000000000
--- a/tools/perf/builtin-script.c
+++ b/tools/perf/builtin-script.c
@@@ -490,13 -513,36 +491,42 @@@ static int perf_sample__fprintf_iregs(s
  
  	for_each_set_bit(r, (unsigned long *) &mask, sizeof(mask) * 8) {
  		u64 val = regs->regs[i++];
- 		printf("%5s:0x%"PRIx64" ", perf_reg_name(r), val);
+ 		printed += fprintf(fp, "%5s:0x%"PRIx64" ", perf_reg_name(r), val);
  	}
+ 
+ 	return printed;
  }
  
++<<<<<<< HEAD
 +static void print_sample_start(struct perf_sample *sample,
 +			       struct thread *thread,
 +			       struct perf_evsel *evsel)
++=======
+ static int perf_sample__fprintf_uregs(struct perf_sample *sample,
+ 				      struct perf_event_attr *attr, FILE *fp)
+ {
+ 	struct regs_dump *regs = &sample->user_regs;
+ 	uint64_t mask = attr->sample_regs_user;
+ 	unsigned i = 0, r;
+ 	int printed = 0;
+ 
+ 	if (!regs || !regs->regs)
+ 		return 0;
+ 
+ 	printed += fprintf(fp, " ABI:%" PRIu64 " ", regs->abi);
+ 
+ 	for_each_set_bit(r, (unsigned long *) &mask, sizeof(mask) * 8) {
+ 		u64 val = regs->regs[i++];
+ 		printed += fprintf(fp, "%5s:0x%"PRIx64" ", perf_reg_name(r), val);
+ 	}
+ 
+ 	return printed;
+ }
+ 
+ static int perf_sample__fprintf_start(struct perf_sample *sample,
+ 				      struct thread *thread,
+ 				      struct perf_evsel *evsel, FILE *fp)
++>>>>>>> a1a587073ccd (perf script: Use fprintf like printing uniformly)
  {
  	struct perf_event_attr *attr = &evsel->attr;
  	unsigned long secs;
@@@ -549,27 -598,56 +582,74 @@@ mispred_str(struct branch_entry *br
  	return br->flags.predicted ? 'P' : 'M';
  }
  
++<<<<<<< HEAD
 +static void print_sample_brstack(struct perf_sample *sample)
 +{
 +	struct branch_stack *br = sample->branch_stack;
 +	u64 i;
++=======
+ static int perf_sample__fprintf_brstack(struct perf_sample *sample,
+ 					struct thread *thread,
+ 					struct perf_event_attr *attr, FILE *fp)
+ {
+ 	struct branch_stack *br = sample->branch_stack;
+ 	struct addr_location alf, alt;
+ 	u64 i, from, to;
+ 	int printed = 0;
++>>>>>>> a1a587073ccd (perf script: Use fprintf like printing uniformly)
  
  	if (!(br && br->nr))
- 		return;
+ 		return 0;
  
  	for (i = 0; i < br->nr; i++) {
++<<<<<<< HEAD
 +		printf(" 0x%"PRIx64"/0x%"PRIx64"/%c/%c/%c/%d ",
 +			br->entries[i].from,
 +			br->entries[i].to,
++=======
+ 		from = br->entries[i].from;
+ 		to   = br->entries[i].to;
+ 
+ 		if (PRINT_FIELD(DSO)) {
+ 			memset(&alf, 0, sizeof(alf));
+ 			memset(&alt, 0, sizeof(alt));
+ 			thread__find_addr_map(thread, sample->cpumode, MAP__FUNCTION, from, &alf);
+ 			thread__find_addr_map(thread, sample->cpumode, MAP__FUNCTION, to, &alt);
+ 		}
+ 
+ 		printed += fprintf(fp, " 0x%"PRIx64, from);
+ 		if (PRINT_FIELD(DSO)) {
+ 			printed += fprintf(fp, "(");
+ 			printed += map__fprintf_dsoname(alf.map, fp);
+ 			printed += fprintf(fp, ")");
+ 		}
+ 
+ 		printed += fprintf(fp, "/0x%"PRIx64, to);
+ 		if (PRINT_FIELD(DSO)) {
+ 			printed += fprintf(fp, "(");
+ 			printed += map__fprintf_dsoname(alt.map, fp);
+ 			printed += fprintf(fp, ")");
+ 		}
+ 
+ 		printed += fprintf(fp, "/%c/%c/%c/%d ",
++>>>>>>> a1a587073ccd (perf script: Use fprintf like printing uniformly)
  			mispred_str( br->entries + i),
  			br->entries[i].flags.in_tx? 'X' : '-',
  			br->entries[i].flags.abort? 'A' : '-',
  			br->entries[i].flags.cycles);
  	}
+ 
+ 	return printed;
  }
  
++<<<<<<< HEAD
 +static void print_sample_brstacksym(struct perf_sample *sample,
 +				    struct thread *thread)
++=======
+ static int perf_sample__fprintf_brstacksym(struct perf_sample *sample,
+ 					   struct thread *thread,
+ 					   struct perf_event_attr *attr, FILE *fp)
++>>>>>>> a1a587073ccd (perf script: Use fprintf like printing uniformly)
  {
  	struct branch_stack *br = sample->branch_stack;
  	struct addr_location alf, alt;
@@@ -593,17 -672,77 +674,87 @@@
  		if (alt.map)
  			alt.sym = map__find_symbol(alt.map, alt.addr);
  
++<<<<<<< HEAD
 +		symbol__fprintf_symname_offs(alf.sym, &alf, stdout);
 +		putchar('/');
 +		symbol__fprintf_symname_offs(alt.sym, &alt, stdout);
 +		printf("/%c/%c/%c/%d ",
++=======
+ 		printed += symbol__fprintf_symname_offs(alf.sym, &alf, fp);
+ 		if (PRINT_FIELD(DSO)) {
+ 			printed += fprintf(fp, "(");
+ 			printed += map__fprintf_dsoname(alf.map, fp);
+ 			printed += fprintf(fp, ")");
+ 		}
+ 		printed += fprintf(fp, "%c", '/');
+ 		printed += symbol__fprintf_symname_offs(alt.sym, &alt, fp);
+ 		if (PRINT_FIELD(DSO)) {
+ 			printed += fprintf(fp, "(");
+ 			printed += map__fprintf_dsoname(alt.map, fp);
+ 			printed += fprintf(fp, ")");
+ 		}
+ 		printed += fprintf(fp, "/%c/%c/%c/%d ",
++>>>>>>> a1a587073ccd (perf script: Use fprintf like printing uniformly)
  			mispred_str( br->entries + i),
  			br->entries[i].flags.in_tx? 'X' : '-',
  			br->entries[i].flags.abort? 'A' : '-',
  			br->entries[i].flags.cycles);
  	}
+ 
+ 	return printed;
  }
  
++<<<<<<< HEAD
++=======
+ static int perf_sample__fprintf_brstackoff(struct perf_sample *sample,
+ 					   struct thread *thread,
+ 					   struct perf_event_attr *attr, FILE *fp)
+ {
+ 	struct branch_stack *br = sample->branch_stack;
+ 	struct addr_location alf, alt;
+ 	u64 i, from, to;
+ 	int printed = 0;
+ 
+ 	if (!(br && br->nr))
+ 		return 0;
+ 
+ 	for (i = 0; i < br->nr; i++) {
+ 
+ 		memset(&alf, 0, sizeof(alf));
+ 		memset(&alt, 0, sizeof(alt));
+ 		from = br->entries[i].from;
+ 		to   = br->entries[i].to;
+ 
+ 		thread__find_addr_map(thread, sample->cpumode, MAP__FUNCTION, from, &alf);
+ 		if (alf.map && !alf.map->dso->adjust_symbols)
+ 			from = map__map_ip(alf.map, from);
+ 
+ 		thread__find_addr_map(thread, sample->cpumode, MAP__FUNCTION, to, &alt);
+ 		if (alt.map && !alt.map->dso->adjust_symbols)
+ 			to = map__map_ip(alt.map, to);
+ 
+ 		printed += fprintf(fp, " 0x%"PRIx64, from);
+ 		if (PRINT_FIELD(DSO)) {
+ 			printed += fprintf(fp, "(");
+ 			printed += map__fprintf_dsoname(alf.map, fp);
+ 			printed += fprintf(fp, ")");
+ 		}
+ 		printed += fprintf(fp, "/0x%"PRIx64, to);
+ 		if (PRINT_FIELD(DSO)) {
+ 			printed += fprintf(fp, "(");
+ 			printed += map__fprintf_dsoname(alt.map, fp);
+ 			printed += fprintf(fp, ")");
+ 		}
+ 		printed += fprintf(fp, "/%c/%c/%c/%d ",
+ 			mispred_str(br->entries + i),
+ 			br->entries[i].flags.in_tx ? 'X' : '-',
+ 			br->entries[i].flags.abort ? 'A' : '-',
+ 			br->entries[i].flags.cycles);
+ 	}
+ 
+ 	return printed;
+ }
++>>>>>>> a1a587073ccd (perf script: Use fprintf like printing uniformly)
  #define MAXBB 16384UL
  
  static int grab_bb(u8 *buffer, u64 start, u64 end,
@@@ -1032,11 -1181,210 +1193,213 @@@ static int perf_sample__fprintf_flags(u
  	str[pos] = 0;
  
  	if (name)
- 		printf("  %-7s%4s ", name, in_tx ? "(x)" : "");
- 	else
- 		printf("  %-11s ", str);
+ 		return fprintf(fp, "  %-7s%4s ", name, in_tx ? "(x)" : "");
+ 
+ 	return fprintf(fp, "  %-11s ", str);
  }
  
++<<<<<<< HEAD
++=======
+ struct printer_data {
+ 	int line_no;
+ 	bool hit_nul;
+ 	bool is_printable;
+ };
+ 
+ static int sample__fprintf_bpf_output(enum binary_printer_ops op,
+ 				      unsigned int val,
+ 				      void *extra, FILE *fp)
+ {
+ 	unsigned char ch = (unsigned char)val;
+ 	struct printer_data *printer_data = extra;
+ 	int printed = 0;
+ 
+ 	switch (op) {
+ 	case BINARY_PRINT_DATA_BEGIN:
+ 		printed += fprintf(fp, "\n");
+ 		break;
+ 	case BINARY_PRINT_LINE_BEGIN:
+ 		printed += fprintf(fp, "%17s", !printer_data->line_no ? "BPF output:" :
+ 						        "           ");
+ 		break;
+ 	case BINARY_PRINT_ADDR:
+ 		printed += fprintf(fp, " %04x:", val);
+ 		break;
+ 	case BINARY_PRINT_NUM_DATA:
+ 		printed += fprintf(fp, " %02x", val);
+ 		break;
+ 	case BINARY_PRINT_NUM_PAD:
+ 		printed += fprintf(fp, "   ");
+ 		break;
+ 	case BINARY_PRINT_SEP:
+ 		printed += fprintf(fp, "  ");
+ 		break;
+ 	case BINARY_PRINT_CHAR_DATA:
+ 		if (printer_data->hit_nul && ch)
+ 			printer_data->is_printable = false;
+ 
+ 		if (!isprint(ch)) {
+ 			printed += fprintf(fp, "%c", '.');
+ 
+ 			if (!printer_data->is_printable)
+ 				break;
+ 
+ 			if (ch == '\0')
+ 				printer_data->hit_nul = true;
+ 			else
+ 				printer_data->is_printable = false;
+ 		} else {
+ 			printed += fprintf(fp, "%c", ch);
+ 		}
+ 		break;
+ 	case BINARY_PRINT_CHAR_PAD:
+ 		printed += fprintf(fp, " ");
+ 		break;
+ 	case BINARY_PRINT_LINE_END:
+ 		printed += fprintf(fp, "\n");
+ 		printer_data->line_no++;
+ 		break;
+ 	case BINARY_PRINT_DATA_END:
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return printed;
+ }
+ 
+ static int perf_sample__fprintf_bpf_output(struct perf_sample *sample, FILE *fp)
+ {
+ 	unsigned int nr_bytes = sample->raw_size;
+ 	struct printer_data printer_data = {0, false, true};
+ 	int printed = binary__fprintf(sample->raw_data, nr_bytes, 8,
+ 				      sample__fprintf_bpf_output, &printer_data, fp);
+ 
+ 	if (printer_data.is_printable && printer_data.hit_nul)
+ 		printed += fprintf(fp, "%17s \"%s\"\n", "BPF string:", (char *)(sample->raw_data));
+ 
+ 	return printed;
+ }
+ 
+ static int perf_sample__fprintf_spacing(int len, int spacing, FILE *fp)
+ {
+ 	if (len > 0 && len < spacing)
+ 		return fprintf(fp, "%*s", spacing - len, "");
+ 
+ 	return 0;
+ }
+ 
+ static int perf_sample__fprintf_pt_spacing(int len, FILE *fp)
+ {
+ 	return perf_sample__fprintf_spacing(len, 34, fp);
+ }
+ 
+ static int perf_sample__fprintf_synth_ptwrite(struct perf_sample *sample, FILE *fp)
+ {
+ 	struct perf_synth_intel_ptwrite *data = perf_sample__synth_ptr(sample);
+ 	int len;
+ 
+ 	if (perf_sample__bad_synth_size(sample, *data))
+ 		return 0;
+ 
+ 	len = fprintf(fp, " IP: %u payload: %#" PRIx64 " ",
+ 		     data->ip, le64_to_cpu(data->payload));
+ 	return len + perf_sample__fprintf_pt_spacing(len, fp);
+ }
+ 
+ static int perf_sample__fprintf_synth_mwait(struct perf_sample *sample, FILE *fp)
+ {
+ 	struct perf_synth_intel_mwait *data = perf_sample__synth_ptr(sample);
+ 	int len;
+ 
+ 	if (perf_sample__bad_synth_size(sample, *data))
+ 		return 0;
+ 
+ 	len = fprintf(fp, " hints: %#x extensions: %#x ",
+ 		      data->hints, data->extensions);
+ 	return len + perf_sample__fprintf_pt_spacing(len, fp);
+ }
+ 
+ static int perf_sample__fprintf_synth_pwre(struct perf_sample *sample, FILE *fp)
+ {
+ 	struct perf_synth_intel_pwre *data = perf_sample__synth_ptr(sample);
+ 	int len;
+ 
+ 	if (perf_sample__bad_synth_size(sample, *data))
+ 		return 0;
+ 
+ 	len = fprintf(fp, " hw: %u cstate: %u sub-cstate: %u ",
+ 		      data->hw, data->cstate, data->subcstate);
+ 	return len + perf_sample__fprintf_pt_spacing(len, fp);
+ }
+ 
+ static int perf_sample__fprintf_synth_exstop(struct perf_sample *sample, FILE *fp)
+ {
+ 	struct perf_synth_intel_exstop *data = perf_sample__synth_ptr(sample);
+ 	int len;
+ 
+ 	if (perf_sample__bad_synth_size(sample, *data))
+ 		return 0;
+ 
+ 	len = fprintf(fp, " IP: %u ", data->ip);
+ 	return len + perf_sample__fprintf_pt_spacing(len, fp);
+ }
+ 
+ static int perf_sample__fprintf_synth_pwrx(struct perf_sample *sample, FILE *fp)
+ {
+ 	struct perf_synth_intel_pwrx *data = perf_sample__synth_ptr(sample);
+ 	int len;
+ 
+ 	if (perf_sample__bad_synth_size(sample, *data))
+ 		return 0;
+ 
+ 	len = fprintf(fp, " deepest cstate: %u last cstate: %u wake reason: %#x ",
+ 		     data->deepest_cstate, data->last_cstate,
+ 		     data->wake_reason);
+ 	return len + perf_sample__fprintf_pt_spacing(len, fp);
+ }
+ 
+ static int perf_sample__fprintf_synth_cbr(struct perf_sample *sample, FILE *fp)
+ {
+ 	struct perf_synth_intel_cbr *data = perf_sample__synth_ptr(sample);
+ 	unsigned int percent, freq;
+ 	int len;
+ 
+ 	if (perf_sample__bad_synth_size(sample, *data))
+ 		return 0;
+ 
+ 	freq = (le32_to_cpu(data->freq) + 500) / 1000;
+ 	len = fprintf(fp, " cbr: %2u freq: %4u MHz ", data->cbr, freq);
+ 	if (data->max_nonturbo) {
+ 		percent = (5 + (1000 * data->cbr) / data->max_nonturbo) / 10;
+ 		len += fprintf(fp, "(%3u%%) ", percent);
+ 	}
+ 	return len + perf_sample__fprintf_pt_spacing(len, fp);
+ }
+ 
+ static int perf_sample__fprintf_synth(struct perf_sample *sample,
+ 				      struct perf_evsel *evsel, FILE *fp)
+ {
+ 	switch (evsel->attr.config) {
+ 	case PERF_SYNTH_INTEL_PTWRITE:
+ 		return perf_sample__fprintf_synth_ptwrite(sample, fp);
+ 	case PERF_SYNTH_INTEL_MWAIT:
+ 		return perf_sample__fprintf_synth_mwait(sample, fp);
+ 	case PERF_SYNTH_INTEL_PWRE:
+ 		return perf_sample__fprintf_synth_pwre(sample, fp);
+ 	case PERF_SYNTH_INTEL_EXSTOP:
+ 		return perf_sample__fprintf_synth_exstop(sample, fp);
+ 	case PERF_SYNTH_INTEL_PWRX:
+ 		return perf_sample__fprintf_synth_pwrx(sample, fp);
+ 	case PERF_SYNTH_INTEL_CBR:
+ 		return perf_sample__fprintf_synth_cbr(sample, fp);
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> a1a587073ccd (perf script: Use fprintf like printing uniformly)
  struct perf_script {
  	struct perf_tool	tool;
  	struct perf_session	*session;
@@@ -1120,14 -1470,18 +1484,21 @@@ static void process_event(struct perf_s
  	if (PRINT_FIELD(TRACE))
  		event_format__print(evsel->tp_format, sample->cpu,
  				    sample->raw_data, sample->raw_size);
++<<<<<<< HEAD
++=======
+ 
+ 	if (attr->type == PERF_TYPE_SYNTH && PRINT_FIELD(SYNTH))
+ 		perf_sample__fprintf_synth(sample, evsel, fp);
+ 
++>>>>>>> a1a587073ccd (perf script: Use fprintf like printing uniformly)
  	if (PRINT_FIELD(ADDR))
- 		print_sample_addr(sample, thread, attr);
+ 		perf_sample__fprintf_addr(sample, thread, attr, fp);
  
  	if (PRINT_FIELD(DATA_SRC))
- 		data_src__printf(sample->data_src);
+ 		data_src__fprintf(sample->data_src, fp);
  
  	if (PRINT_FIELD(WEIGHT))
- 		printf("%16" PRIu64, sample->weight);
+ 		fprintf(fp, "%16" PRIu64, sample->weight);
  
  	if (PRINT_FIELD(IP)) {
  		struct callchain_cursor *cursor = NULL;
@@@ -1142,13 -1496,24 +1513,32 @@@
  	}
  
  	if (PRINT_FIELD(IREGS))
- 		print_sample_iregs(sample, attr);
+ 		perf_sample__fprintf_iregs(sample, attr, fp);
  
++<<<<<<< HEAD
 +	if (PRINT_FIELD(BRSTACK))
 +		print_sample_brstack(sample);
 +	else if (PRINT_FIELD(BRSTACKSYM))
 +		print_sample_brstacksym(sample, thread);
 +	print_insn(sample, attr, thread, machine);
++=======
+ 	if (PRINT_FIELD(UREGS))
+ 		perf_sample__fprintf_uregs(sample, attr, fp);
+ 
+ 	if (PRINT_FIELD(BRSTACK))
+ 		perf_sample__fprintf_brstack(sample, thread, attr, fp);
+ 	else if (PRINT_FIELD(BRSTACKSYM))
+ 		perf_sample__fprintf_brstacksym(sample, thread, attr, fp);
+ 	else if (PRINT_FIELD(BRSTACKOFF))
+ 		perf_sample__fprintf_brstackoff(sample, thread, attr, fp);
+ 
+ 	if (perf_evsel__is_bpf_output(evsel) && PRINT_FIELD(BPF_OUTPUT))
+ 		perf_sample__fprintf_bpf_output(sample, fp);
+ 	perf_sample__fprintf_insn(sample, attr, thread, machine, fp);
+ 
+ 	if (PRINT_FIELD(PHYS_ADDR))
+ 		printf("%16" PRIx64, sample->phys_addr);
++>>>>>>> a1a587073ccd (perf script: Use fprintf like printing uniformly)
  	printf("\n");
  }
  
@@@ -1323,7 -1688,42 +1713,44 @@@ static int process_comm_event(struct pe
  		sample->tid = event->comm.tid;
  		sample->pid = event->comm.pid;
  	}
- 	print_sample_start(sample, thread, evsel);
+ 	perf_sample__fprintf_start(sample, thread, evsel, stdout);
+ 	perf_event__fprintf(event, stdout);
+ 	ret = 0;
+ out:
+ 	thread__put(thread);
+ 	return ret;
+ }
+ 
++<<<<<<< HEAD
++=======
+ static int process_namespaces_event(struct perf_tool *tool,
+ 				    union perf_event *event,
+ 				    struct perf_sample *sample,
+ 				    struct machine *machine)
+ {
+ 	struct thread *thread;
+ 	struct perf_script *script = container_of(tool, struct perf_script, tool);
+ 	struct perf_session *session = script->session;
+ 	struct perf_evsel *evsel = perf_evlist__id2evsel(session->evlist, sample->id);
+ 	int ret = -1;
+ 
+ 	thread = machine__findnew_thread(machine, event->namespaces.pid,
+ 					 event->namespaces.tid);
+ 	if (thread == NULL) {
+ 		pr_debug("problem processing NAMESPACES event, skipping it.\n");
+ 		return -1;
+ 	}
+ 
+ 	if (perf_event__process_namespaces(tool, event, sample, machine) < 0)
+ 		goto out;
+ 
+ 	if (!evsel->attr.sample_id_all) {
+ 		sample->cpu = 0;
+ 		sample->time = 0;
+ 		sample->tid = event->namespaces.tid;
+ 		sample->pid = event->namespaces.pid;
+ 	}
+ 	perf_sample__fprintf_start(sample, thread, evsel, stdout);
  	perf_event__fprintf(event, stdout);
  	ret = 0;
  out:
@@@ -1331,6 -1731,6 +1758,7 @@@
  	return ret;
  }
  
++>>>>>>> a1a587073ccd (perf script: Use fprintf like printing uniformly)
  static int process_fork_event(struct perf_tool *tool,
  			      union perf_event *event,
  			      struct perf_sample *sample,
* Unmerged path tools/perf/builtin-script.c
