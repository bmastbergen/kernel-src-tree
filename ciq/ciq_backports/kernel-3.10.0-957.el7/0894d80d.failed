iio:kfifo: Protect against concurrent access from userspace

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iio] kfifo: Protect against concurrent access from userspace (Tony Camuso) [1559170]
Rebuild_FUZZ: 96.49%
commit-author Lars-Peter Clausen <lars@metafoo.de>
commit 0894d80dfddaeb9f95904ceab623460c1bfdab06
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0894d80d.failed

It is possible for userspace to concurrently access the buffer from multiple
threads or processes. To avoid corruption of the internal state of the buffer we
need to add proper locking. It is possible for multiple processes to try to read
from the buffer concurrently and it is also possible that one process causes a
buffer re-allocation while a different process still access the buffer. Both can
be fixed by protecting the calls to kfifo_to_user() and kfifo_alloc() by the
same mutex. In iio_read_first_n_kfifo() we also use kfifo_recsize() instead of
the buffers bytes_per_datum to avoid a race that can happen if bytes_per_datum
has been changed, but the buffer has not been reallocated yet.

Note that all access to the buffer from within the kernel is already properly
synchronized, so there is no need for extra locking in iio_store_to_kfifo().

	Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit 0894d80dfddaeb9f95904ceab623460c1bfdab06)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iio/kfifo_buf.c
diff --cc drivers/iio/kfifo_buf.c
index 1bea41bcbdc6,c95b61f60919..000000000000
--- a/drivers/iio/kfifo_buf.c
+++ b/drivers/iio/kfifo_buf.c
@@@ -130,6 -138,15 +138,18 @@@ static int iio_read_first_n_kfifo(struc
  	return copied;
  }
  
++<<<<<<< HEAD
++=======
+ static void iio_kfifo_buffer_release(struct iio_buffer *buffer)
+ {
+ 	struct iio_kfifo *kf = iio_to_kfifo(buffer);
+ 
+ 	mutex_destroy(&kf->user_lock);
+ 	kfifo_free(&kf->kf);
+ 	kfree(kf);
+ }
+ 
++>>>>>>> 0894d80dfdda (iio:kfifo: Protect against concurrent access from userspace)
  static const struct iio_buffer_access_funcs kfifo_access_funcs = {
  	.store_to = &iio_store_to_kfifo,
  	.read_first_n = &iio_read_first_n_kfifo,
* Unmerged path drivers/iio/kfifo_buf.c
