watchdog: add watchdog pretimeout governor framework

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [watchdog] add watchdog pretimeout governor framework (David Arcari) [1576173]
Rebuild_FUZZ: 89.36%
commit-author Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
commit ff84136cb6a4943f489ad037fe93f43be0573c23
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ff84136c.failed

The change adds a simple watchdog pretimeout framework infrastructure,
its purpose is to allow users to select a desired handling of watchdog
pretimeout events, which may be generated by some watchdog devices.

A user selects a default watchdog pretimeout governor during
compilation stage.

Watchdogs with WDIOF_PRETIMEOUT capability now have one more device
attribute in sysfs, pretimeout_governor attribute is intended to display
the selected watchdog pretimeout governor.

The framework has no impact at runtime on watchdog devices with no
WDIOF_PRETIMEOUT capability set.

	Signed-off-by: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
	Reviewed-by: Guenter Roeck <linux@roeck-us.net>
	Reviewed-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
	Tested-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
	Signed-off-by: Guenter Roeck <linux@roeck-us.net>
	Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
(cherry picked from commit ff84136cb6a4943f489ad037fe93f43be0573c23)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/watchdog/watchdog-kernel-api.txt
#	drivers/watchdog/watchdog_dev.c
#	include/linux/watchdog.h
diff --cc Documentation/watchdog/watchdog-kernel-api.txt
index d8b0d3367706,ea277478982f..000000000000
--- a/Documentation/watchdog/watchdog-kernel-api.txt
+++ b/Documentation/watchdog/watchdog-kernel-api.txt
@@@ -44,17 -44,22 +44,18 @@@ The watchdog device structure looks lik
  
  struct watchdog_device {
  	int id;
 +	struct cdev cdev;
 +	struct device *dev;
  	struct device *parent;
 -	const struct attribute_group **groups;
  	const struct watchdog_info *info;
  	const struct watchdog_ops *ops;
+ 	const struct watchdog_governor *gov;
  	unsigned int bootstatus;
  	unsigned int timeout;
 -	unsigned int pretimeout;
  	unsigned int min_timeout;
  	unsigned int max_timeout;
 -	unsigned int min_hw_heartbeat_ms;
 -	unsigned int max_hw_heartbeat_ms;
 -	struct notifier_block reboot_nb;
 -	struct notifier_block restart_nb;
  	void *driver_data;
 -	struct watchdog_core_data *wd_data;
 +	struct mutex lock;
  	unsigned long status;
  	struct list_head deferred;
  };
@@@ -72,9 -74,34 +73,10 @@@ It contains following fields
  * info: a pointer to a watchdog_info structure. This structure gives some
    additional information about the watchdog timer itself. (Like it's unique name)
  * ops: a pointer to the list of watchdog operations that the watchdog supports.
+ * gov: a pointer to the assigned watchdog device pretimeout governor or NULL.
  * timeout: the watchdog timer's timeout value (in seconds).
 -  This is the time after which the system will reboot if user space does
 -  not send a heartbeat request if WDOG_ACTIVE is set.
 -* pretimeout: the watchdog timer's pretimeout value (in seconds).
  * min_timeout: the watchdog timer's minimum timeout value (in seconds).
 -  If set, the minimum configurable value for 'timeout'.
 -* max_timeout: the watchdog timer's maximum timeout value (in seconds),
 -  as seen from userspace. If set, the maximum configurable value for
 -  'timeout'. Not used if max_hw_heartbeat_ms is non-zero.
 -* min_hw_heartbeat_ms: Hardware limit for minimum time between heartbeats,
 -  in milli-seconds. This value is normally 0; it should only be provided
 -  if the hardware can not tolerate lower intervals between heartbeats.
 -* max_hw_heartbeat_ms: Maximum hardware heartbeat, in milli-seconds.
 -  If set, the infrastructure will send heartbeats to the watchdog driver
 -  if 'timeout' is larger than max_hw_heartbeat_ms, unless WDOG_ACTIVE
 -  is set and userspace failed to send a heartbeat for at least 'timeout'
 -  seconds. max_hw_heartbeat_ms must be set if a driver does not implement
 -  the stop function.
 -* reboot_nb: notifier block that is registered for reboot notifications, for
 -  internal use only. If the driver calls watchdog_stop_on_reboot, watchdog core
 -  will stop the watchdog on such notifications.
 -* restart_nb: notifier block that is registered for machine restart, for
 -  internal use only. If a watchdog is capable of restarting the machine, it
 -  should define ops->restart. Priority can be changed through
 -  watchdog_set_restart_priority.
 +* max_timeout: the watchdog timer's maximum timeout value (in seconds).
  * bootstatus: status of the device after booting (reported with watchdog
    WDIOF_* status bits).
  * driver_data: a pointer to the drivers private data of a watchdog device.
@@@ -231,3 -275,29 +233,32 @@@ the device tree (if the module timeout 
  to set the default timeout value as timeout value in the watchdog_device and
  then use this function to set the user "preferred" timeout value.
  This routine returns zero on success and a negative errno code for failure.
++<<<<<<< HEAD
++=======
+ 
+ To disable the watchdog on reboot, the user must call the following helper:
+ 
+ static inline void watchdog_stop_on_reboot(struct watchdog_device *wdd);
+ 
+ To change the priority of the restart handler the following helper should be
+ used:
+ 
+ void watchdog_set_restart_priority(struct watchdog_device *wdd, int priority);
+ 
+ User should follow the following guidelines for setting the priority:
+ * 0: should be called in last resort, has limited restart capabilities
+ * 128: default restart handler, use if no other handler is expected to be
+   available, and/or if restart is sufficient to restart the entire system
+ * 255: highest priority, will preempt all other restart handlers
+ 
+ To raise a pretimeout notification, the following function should be used:
+ 
+ void watchdog_notify_pretimeout(struct watchdog_device *wdd)
+ 
+ The function can be called in the interrupt context. If watchdog pretimeout
+ governor framework (kbuild CONFIG_WATCHDOG_PRETIMEOUT_GOV symbol) is enabled,
+ an action is taken by a preconfigured pretimeout governor preassigned to
+ the watchdog device. If watchdog pretimeout governor framework is not
+ enabled, watchdog_notify_pretimeout() prints a notification message to
+ the kernel log buffer.
++>>>>>>> ff84136cb6a4 (watchdog: add watchdog pretimeout governor framework)
diff --cc drivers/watchdog/watchdog_dev.c
index f06fbcf0bea2,d2d0b5e37a35..000000000000
--- a/drivers/watchdog/watchdog_dev.c
+++ b/drivers/watchdog/watchdog_dev.c
@@@ -43,11 -49,123 +43,12 @@@
  #include <linux/uaccess.h>	/* For copy_to_user/put_user/... */
  
  #include "watchdog_core.h"
+ #include "watchdog_pretimeout.h"
  
 -/*
 - * struct watchdog_core_data - watchdog core internal data
 - * @kref:	Reference count.
 - * @cdev:	The watchdog's Character device.
 - * @wdd:	Pointer to watchdog device.
 - * @lock:	Lock for watchdog core.
 - * @status:	Watchdog core internal status bits.
 - */
 -struct watchdog_core_data {
 -	struct kref kref;
 -	struct cdev cdev;
 -	struct watchdog_device *wdd;
 -	struct mutex lock;
 -	unsigned long last_keepalive;
 -	unsigned long last_hw_keepalive;
 -	struct delayed_work work;
 -	unsigned long status;		/* Internal status bits */
 -#define _WDOG_DEV_OPEN		0	/* Opened ? */
 -#define _WDOG_ALLOW_RELEASE	1	/* Did we receive the magic char ? */
 -#define _WDOG_KEEPALIVE		2	/* Did we receive a keepalive ? */
 -};
 -
  /* the dev_t structure to store the dynamically allocated watchdog devices */
  static dev_t watchdog_devt;
 -/* Reference to watchdog device behind /dev/watchdog */
 -static struct watchdog_core_data *old_wd_data;
 -
 -static struct workqueue_struct *watchdog_wq;
 -
 -static inline bool watchdog_need_worker(struct watchdog_device *wdd)
 -{
 -	/* All variables in milli-seconds */
 -	unsigned int hm = wdd->max_hw_heartbeat_ms;
 -	unsigned int t = wdd->timeout * 1000;
 -
 -	/*
 -	 * A worker to generate heartbeat requests is needed if all of the
 -	 * following conditions are true.
 -	 * - Userspace activated the watchdog.
 -	 * - The driver provided a value for the maximum hardware timeout, and
 -	 *   thus is aware that the framework supports generating heartbeat
 -	 *   requests.
 -	 * - Userspace requests a longer timeout than the hardware can handle.
 -	 *
 -	 * Alternatively, if userspace has not opened the watchdog
 -	 * device, we take care of feeding the watchdog if it is
 -	 * running.
 -	 */
 -	return (hm && watchdog_active(wdd) && t > hm) ||
 -		(t && !watchdog_active(wdd) && watchdog_hw_running(wdd));
 -}
 -
 -static long watchdog_next_keepalive(struct watchdog_device *wdd)
 -{
 -	struct watchdog_core_data *wd_data = wdd->wd_data;
 -	unsigned int timeout_ms = wdd->timeout * 1000;
 -	unsigned long keepalive_interval;
 -	unsigned long last_heartbeat;
 -	unsigned long virt_timeout;
 -	unsigned int hw_heartbeat_ms;
 -
 -	virt_timeout = wd_data->last_keepalive + msecs_to_jiffies(timeout_ms);
 -	hw_heartbeat_ms = min_not_zero(timeout_ms, wdd->max_hw_heartbeat_ms);
 -	keepalive_interval = msecs_to_jiffies(hw_heartbeat_ms / 2);
 -
 -	if (!watchdog_active(wdd))
 -		return keepalive_interval;
 -
 -	/*
 -	 * To ensure that the watchdog times out wdd->timeout seconds
 -	 * after the most recent ping from userspace, the last
 -	 * worker ping has to come in hw_heartbeat_ms before this timeout.
 -	 */
 -	last_heartbeat = virt_timeout - msecs_to_jiffies(hw_heartbeat_ms);
 -	return min_t(long, last_heartbeat - jiffies, keepalive_interval);
 -}
 -
 -static inline void watchdog_update_worker(struct watchdog_device *wdd)
 -{
 -	struct watchdog_core_data *wd_data = wdd->wd_data;
 -
 -	if (watchdog_need_worker(wdd)) {
 -		long t = watchdog_next_keepalive(wdd);
 -
 -		if (t > 0)
 -			mod_delayed_work(watchdog_wq, &wd_data->work, t);
 -	} else {
 -		cancel_delayed_work(&wd_data->work);
 -	}
 -}
 -
 -static int __watchdog_ping(struct watchdog_device *wdd)
 -{
 -	struct watchdog_core_data *wd_data = wdd->wd_data;
 -	unsigned long earliest_keepalive = wd_data->last_hw_keepalive +
 -				msecs_to_jiffies(wdd->min_hw_heartbeat_ms);
 -	int err;
 -
 -	if (time_is_after_jiffies(earliest_keepalive)) {
 -		mod_delayed_work(watchdog_wq, &wd_data->work,
 -				 earliest_keepalive - jiffies);
 -		return 0;
 -	}
 -
 -	wd_data->last_hw_keepalive = jiffies;
 -
 -	if (wdd->ops->ping)
 -		err = wdd->ops->ping(wdd);  /* ping the watchdog */
 -	else
 -		err = wdd->ops->start(wdd); /* restart watchdog */
 -
 -	watchdog_update_worker(wdd);
 -
 -	return err;
 -}
 +/* the watchdog device behind /dev/watchdog */
 +static struct watchdog_device *old_wdd;
  
  /*
   *	watchdog_ping: ping the watchdog.
@@@ -333,10 -506,15 +344,14 @@@ static umode_t wdt_is_visible(struct ko
  	struct watchdog_device *wdd = dev_get_drvdata(dev);
  	umode_t mode = attr->mode;
  
 -	if (attr == &dev_attr_timeleft.attr && !wdd->ops->get_timeleft)
 +	if (attr == &dev_attr_status.attr && !wdd->ops->status)
  		mode = 0;
 -	else if (attr == &dev_attr_pretimeout.attr &&
 -		 !(wdd->info->options & WDIOF_PRETIMEOUT))
 +	else if (attr == &dev_attr_timeleft.attr && !wdd->ops->get_timeleft)
  		mode = 0;
+ 	else if (attr == &dev_attr_pretimeout_governor.attr &&
+ 		 (!(wdd->info->options & WDIOF_PRETIMEOUT) ||
+ 		  !IS_ENABLED(CONFIG_WATCHDOG_PRETIMEOUT_GOV)))
+ 		mode = 0;
  
  	return mode;
  }
@@@ -655,43 -909,65 +671,59 @@@ int watchdog_dev_register(struct watchd
  		}
  	}
  
++<<<<<<< HEAD
  	/* Fill in the data structures */
 -	cdev_init(&wd_data->cdev, &watchdog_fops);
 -	wd_data->cdev.owner = wdd->ops->owner;
 +	devno = MKDEV(MAJOR(watchdog_devt), wdd->id);
 +	cdev_init(&wdd->cdev, &watchdog_fops);
 +	wdd->cdev.owner = wdd->ops->owner;
  
  	/* Add the device */
 -	err = cdev_add(&wd_data->cdev, devno, 1);
 +	err  = cdev_add(&wdd->cdev, devno, 1);
  	if (err) {
  		pr_err("watchdog%d unable to add device %d:%d\n",
  			wdd->id,  MAJOR(watchdog_devt), wdd->id);
  		if (wdd->id == 0) {
  			misc_deregister(&watchdog_miscdev);
 -			old_wd_data = NULL;
 -			kref_put(&wd_data->kref, watchdog_core_data_release);
 +			old_wdd = NULL;
  		}
 -		return err;
  	}
 -
 -	/* Record time of most recent heartbeat as 'just before now'. */
 -	wd_data->last_hw_keepalive = jiffies - 1;
 -
 -	/*
 -	 * If the watchdog is running, prevent its driver from being unloaded,
 -	 * and schedule an immediate ping.
 -	 */
 -	if (watchdog_hw_running(wdd)) {
 -		__module_get(wdd->ops->owner);
 -		kref_get(&wd_data->kref);
 -		queue_delayed_work(watchdog_wq, &wd_data->work, 0);
 +	return err;
++=======
++	ret = watchdog_register_pretimeout(wdd);
++	if (ret) {
++		device_destroy(&watchdog_class, devno);
++		watchdog_cdev_unregister(wdd);
+ 	}
+ 
 -	return 0;
++	return ret;
++>>>>>>> ff84136cb6a4 (watchdog: add watchdog pretimeout governor framework)
  }
  
  /*
 - *	watchdog_cdev_unregister: unregister watchdog character device
 + *	watchdog_dev_unregister: unregister a watchdog device
   *	@watchdog: watchdog device
   *
 - *	Unregister watchdog character device and if needed the legacy
 - *	/dev/watchdog device.
 + *	Unregister the watchdog and if needed the legacy /dev/watchdog device.
   */
  
 -static void watchdog_cdev_unregister(struct watchdog_device *wdd)
 +int watchdog_dev_unregister(struct watchdog_device *wdd)
  {
 -	struct watchdog_core_data *wd_data = wdd->wd_data;
++<<<<<<< HEAD
 +	mutex_lock(&wdd->lock);
 +	set_bit(WDOG_UNREGISTERED, &wdd->status);
 +	mutex_unlock(&wdd->lock);
  
 -	cdev_del(&wd_data->cdev);
 +	cdev_del(&wdd->cdev);
  	if (wdd->id == 0) {
  		misc_deregister(&watchdog_miscdev);
 -		old_wd_data = NULL;
 +		old_wdd = NULL;
  	}
 -
 -	mutex_lock(&wd_data->lock);
 -	wd_data->wdd = NULL;
 -	wdd->wd_data = NULL;
 -	mutex_unlock(&wd_data->lock);
 -
 -	cancel_delayed_work_sync(&wd_data->work);
 -
 -	kref_put(&wd_data->kref, watchdog_core_data_release);
 +	return 0;
++=======
++	watchdog_unregister_pretimeout(wdd);
++	device_destroy(&watchdog_class, wdd->wd_data->cdev.dev);
++	watchdog_cdev_unregister(wdd);
++>>>>>>> ff84136cb6a4 (watchdog: add watchdog pretimeout governor framework)
  }
  
  static struct class watchdog_class = {
diff --cc include/linux/watchdog.h
index e90e3ea5ebeb,35a4d8185b51..000000000000
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@@ -16,6 -18,8 +16,11 @@@
  
  struct watchdog_ops;
  struct watchdog_device;
++<<<<<<< HEAD
++=======
+ struct watchdog_core_data;
+ struct watchdog_governor;
++>>>>>>> ff84136cb6a4 (watchdog: add watchdog pretimeout governor framework)
  
  /** struct watchdog_ops - The watchdog-devices operations
   *
@@@ -53,20 -57,32 +58,21 @@@ struct watchdog_ops 
  /** struct watchdog_device - The structure that defines a watchdog device
   *
   * @id:		The watchdog's ID. (Allocated by watchdog_register_device)
 + * @cdev:	The watchdog's Character device.
 + * @dev:	The device for our watchdog
   * @parent:	The parent bus device
 - * @groups:	List of sysfs attribute groups to create when creating the
 - *		watchdog device.
   * @info:	Pointer to a watchdog_info structure.
   * @ops:	Pointer to the list of watchdog operations.
+  * @gov:	Pointer to watchdog pretimeout governor.
   * @bootstatus:	Status of the watchdog device at boot.
 - * @timeout:	The watchdog devices timeout value (in seconds).
 - * @pretimeout: The watchdog devices pre_timeout value.
 - * @min_timeout:The watchdog devices minimum timeout value (in seconds).
 - * @max_timeout:The watchdog devices maximum timeout value (in seconds)
 - *		as configurable from user space. Only relevant if
 - *		max_hw_heartbeat_ms is not provided.
 - * @min_hw_heartbeat_ms:
 - *		Hardware limit for minimum time between heartbeats,
 - *		in milli-seconds.
 - * @max_hw_heartbeat_ms:
 - *		Hardware limit for maximum timeout, in milli-seconds.
 - *		Replaces max_timeout if specified.
 - * @reboot_nb:	The notifier block to stop watchdog on reboot.
 - * @restart_nb:	The notifier block to register a restart function.
 - * @driver_data:Pointer to the drivers private data.
 - * @wd_data:	Pointer to watchdog core internal data.
 + * @timeout:	The watchdog devices timeout value.
 + * @min_timeout:The watchdog devices minimum timeout value.
 + * @max_timeout:The watchdog devices maximum timeout value.
 + * @driver-data:Pointer to the drivers private data.
 + * @lock:	Lock for watchdog core internal use only.
   * @status:	Field that contains the devices internal status bits.
 - * @deferred:	Entry in wtd_deferred_reg_list which is used to
 - *		register early initialized watchdogs.
 + * @deferred: entry in wtd_deferred_reg_list which is used to
 + *			   register early initialized watchdogs.
   *
   * The watchdog_device structure contains all information about a
   * watchdog timer device.
@@@ -79,17 -95,22 +85,18 @@@
   */
  struct watchdog_device {
  	int id;
 +	struct cdev cdev;
 +	struct device *dev;
  	struct device *parent;
 -	const struct attribute_group **groups;
  	const struct watchdog_info *info;
  	const struct watchdog_ops *ops;
+ 	const struct watchdog_governor *gov;
  	unsigned int bootstatus;
  	unsigned int timeout;
 -	unsigned int pretimeout;
  	unsigned int min_timeout;
  	unsigned int max_timeout;
 -	unsigned int min_hw_heartbeat_ms;
 -	unsigned int max_hw_heartbeat_ms;
 -	struct notifier_block reboot_nb;
 -	struct notifier_block restart_nb;
  	void *driver_data;
 -	struct watchdog_core_data *wd_data;
 +	struct mutex lock;
  	unsigned long status;
  /* Bit numbers for status flags */
  #define WDOG_ACTIVE		0	/* Is the watchdog running/active */
@@@ -141,7 -188,18 +148,17 @@@ static inline void *watchdog_get_drvdat
  	return wdd->driver_data;
  }
  
+ /* Use the following functions to report watchdog pretimeout event */
+ #if IS_ENABLED(CONFIG_WATCHDOG_PRETIMEOUT_GOV)
+ void watchdog_notify_pretimeout(struct watchdog_device *wdd);
+ #else
+ static inline void watchdog_notify_pretimeout(struct watchdog_device *wdd)
+ {
+ 	pr_alert("watchdog%d: pretimeout event\n", wdd->id);
+ }
+ #endif
+ 
  /* drivers/watchdog/watchdog_core.c */
 -void watchdog_set_restart_priority(struct watchdog_device *wdd, int priority);
  extern int watchdog_init_timeout(struct watchdog_device *wdd,
  				  unsigned int timeout_parm, struct device *dev);
  extern int watchdog_register_device(struct watchdog_device *);
* Unmerged path Documentation/watchdog/watchdog-kernel-api.txt
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index d321bee25827..fa5b141fe492 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -1394,4 +1394,11 @@ config USBPCWATCHDOG
 
 	  Most people will say N.
 
+comment "Watchdog Pretimeout Governors"
+
+config WATCHDOG_PRETIMEOUT_GOV
+	bool "Enable watchdog pretimeout governors"
+	help
+	  The option allows to select watchdog pretimeout governors.
+
 endif # WATCHDOG
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index 31a6f885f852..1d5bd96980c2 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -3,9 +3,12 @@
 #
 
 # The WatchDog Timer Driver Core.
-watchdog-objs	+= watchdog_core.o watchdog_dev.o
 obj-$(CONFIG_WATCHDOG_CORE)	+= watchdog.o
 
+watchdog-objs	+= watchdog_core.o watchdog_dev.o
+
+watchdog-$(CONFIG_WATCHDOG_PRETIMEOUT_GOV)	+= watchdog_pretimeout.o
+
 # Only one watchdog can succeed. We probe the ISA/PCI/USB based
 # watchdog-cards first, then the architecture specific watchdog
 # drivers and then the architecture independent "softdog" driver.
* Unmerged path drivers/watchdog/watchdog_dev.c
diff --git a/drivers/watchdog/watchdog_pretimeout.c b/drivers/watchdog/watchdog_pretimeout.c
new file mode 100644
index 000000000000..72612255fb55
--- /dev/null
+++ b/drivers/watchdog/watchdog_pretimeout.c
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2015-2016 Mentor Graphics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/watchdog.h>
+
+#include "watchdog_pretimeout.h"
+
+/* Default watchdog pretimeout governor */
+static struct watchdog_governor *default_gov;
+
+/* The spinlock protects default_gov, wdd->gov and pretimeout_list */
+static DEFINE_SPINLOCK(pretimeout_lock);
+
+/* List of watchdog devices, which can generate a pretimeout event */
+static LIST_HEAD(pretimeout_list);
+
+struct watchdog_pretimeout {
+	struct watchdog_device		*wdd;
+	struct list_head		entry;
+};
+
+int watchdog_pretimeout_governor_get(struct watchdog_device *wdd, char *buf)
+{
+	int count = 0;
+
+	spin_lock_irq(&pretimeout_lock);
+	if (wdd->gov)
+		count = sprintf(buf, "%s\n", wdd->gov->name);
+	spin_unlock_irq(&pretimeout_lock);
+
+	return count;
+}
+
+void watchdog_notify_pretimeout(struct watchdog_device *wdd)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&pretimeout_lock, flags);
+	if (!wdd->gov) {
+		spin_unlock_irqrestore(&pretimeout_lock, flags);
+		return;
+	}
+
+	wdd->gov->pretimeout(wdd);
+	spin_unlock_irqrestore(&pretimeout_lock, flags);
+}
+EXPORT_SYMBOL_GPL(watchdog_notify_pretimeout);
+
+int watchdog_register_governor(struct watchdog_governor *gov)
+{
+	struct watchdog_pretimeout *p;
+
+	if (!default_gov) {
+		spin_lock_irq(&pretimeout_lock);
+		default_gov = gov;
+
+		list_for_each_entry(p, &pretimeout_list, entry)
+			if (!p->wdd->gov)
+				p->wdd->gov = default_gov;
+		spin_unlock_irq(&pretimeout_lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(watchdog_register_governor);
+
+void watchdog_unregister_governor(struct watchdog_governor *gov)
+{
+	struct watchdog_pretimeout *p;
+
+	spin_lock_irq(&pretimeout_lock);
+	if (gov == default_gov)
+		default_gov = NULL;
+
+	list_for_each_entry(p, &pretimeout_list, entry)
+		if (p->wdd->gov == gov)
+			p->wdd->gov = default_gov;
+	spin_unlock_irq(&pretimeout_lock);
+}
+EXPORT_SYMBOL(watchdog_unregister_governor);
+
+int watchdog_register_pretimeout(struct watchdog_device *wdd)
+{
+	struct watchdog_pretimeout *p;
+
+	if (!(wdd->info->options & WDIOF_PRETIMEOUT))
+		return 0;
+
+	p = kzalloc(sizeof(*p), GFP_KERNEL);
+	if (!p)
+		return -ENOMEM;
+
+	spin_lock_irq(&pretimeout_lock);
+	list_add(&p->entry, &pretimeout_list);
+	p->wdd = wdd;
+	wdd->gov = default_gov;
+	spin_unlock_irq(&pretimeout_lock);
+
+	return 0;
+}
+
+void watchdog_unregister_pretimeout(struct watchdog_device *wdd)
+{
+	struct watchdog_pretimeout *p, *t;
+
+	if (!(wdd->info->options & WDIOF_PRETIMEOUT))
+		return;
+
+	spin_lock_irq(&pretimeout_lock);
+	wdd->gov = NULL;
+
+	list_for_each_entry_safe(p, t, &pretimeout_list, entry) {
+		if (p->wdd == wdd) {
+			list_del(&p->entry);
+			break;
+		}
+	}
+	spin_unlock_irq(&pretimeout_lock);
+
+	kfree(p);
+}
diff --git a/drivers/watchdog/watchdog_pretimeout.h b/drivers/watchdog/watchdog_pretimeout.h
new file mode 100644
index 000000000000..c6cd9f80adb2
--- /dev/null
+++ b/drivers/watchdog/watchdog_pretimeout.h
@@ -0,0 +1,40 @@
+#ifndef __WATCHDOG_PRETIMEOUT_H
+#define __WATCHDOG_PRETIMEOUT_H
+
+#define WATCHDOG_GOV_NAME_MAXLEN	20
+
+struct watchdog_device;
+
+struct watchdog_governor {
+	const char	name[WATCHDOG_GOV_NAME_MAXLEN];
+	void		(*pretimeout)(struct watchdog_device *wdd);
+};
+
+#if IS_ENABLED(CONFIG_WATCHDOG_PRETIMEOUT_GOV)
+/* Interfaces to watchdog pretimeout governors */
+int watchdog_register_governor(struct watchdog_governor *gov);
+void watchdog_unregister_governor(struct watchdog_governor *gov);
+
+/* Interfaces to watchdog_dev.c */
+int watchdog_register_pretimeout(struct watchdog_device *wdd);
+void watchdog_unregister_pretimeout(struct watchdog_device *wdd);
+int watchdog_pretimeout_governor_get(struct watchdog_device *wdd, char *buf);
+
+#else
+static inline int watchdog_register_pretimeout(struct watchdog_device *wdd)
+{
+	return 0;
+}
+
+static inline void watchdog_unregister_pretimeout(struct watchdog_device *wdd)
+{
+}
+
+static inline int watchdog_pretimeout_governor_get(struct watchdog_device *wdd,
+						   char *buf)
+{
+	return -EINVAL;
+}
+#endif
+
+#endif
* Unmerged path include/linux/watchdog.h
