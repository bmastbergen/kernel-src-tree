netfilter: ipset: Use a common function at listing the extensions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 3fd986b3d99e3847f1cce6fc36043d0f16508e1d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3fd986b3.failed

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 3fd986b3d99e3847f1cce6fc36043d0f16508e1d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/ipset/ip_set.h
#	net/netfilter/ipset/ip_set_bitmap_gen.h
#	net/netfilter/ipset/ip_set_bitmap_ipmac.c
#	net/netfilter/ipset/ip_set_hash_gen.h
#	net/netfilter/ipset/ip_set_list_set.c
diff --cc include/linux/netfilter/ipset/ip_set.h
index 1309bde24e27,da2a45acf74c..000000000000
--- a/include/linux/netfilter/ipset/ip_set.h
+++ b/include/linux/netfilter/ipset/ip_set.h
@@@ -395,14 -459,38 +395,39 @@@ bitmap_bytes(u32 a, u32 b
  }
  
  #include <linux/netfilter/ipset/ip_set_timeout.h>
 -#include <linux/netfilter/ipset/ip_set_comment.h>
  
++<<<<<<< HEAD
 +#define IP_SET_INIT_KEXT(skb, opt, map)			\
++=======
+ static inline int
+ ip_set_put_extensions(struct sk_buff *skb, const struct ip_set *set,
+ 		      const void *e, bool active)
+ {
+ 	if (SET_WITH_TIMEOUT(set)) {
+ 		unsigned long *timeout = ext_timeout(e, set);
+ 
+ 		if (nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
+ 			htonl(active ? ip_set_timeout_get(timeout)
+ 				: *timeout)))
+ 			return -EMSGSIZE;
+ 	}
+ 	if (SET_WITH_COUNTER(set) &&
+ 	    ip_set_put_counter(skb, ext_counter(e, set)))
+ 		return -EMSGSIZE;
+ 	if (SET_WITH_COMMENT(set) &&
+ 	    ip_set_put_comment(skb, ext_comment(e, set)))
+ 		return -EMSGSIZE;
+ 	return 0;
+ }
+ 
+ #define IP_SET_INIT_KEXT(skb, opt, set)			\
++>>>>>>> 3fd986b3d99e (netfilter: ipset: Use a common function at listing the extensions)
  	{ .bytes = (skb)->len, .packets = 1,		\
 -	  .timeout = ip_set_adt_opt_timeout(opt, set) }
 +	  .timeout = ip_set_adt_opt_timeout(opt, map) }
  
 -#define IP_SET_INIT_UEXT(set)				\
 +#define IP_SET_INIT_UEXT(map)				\
  	{ .bytes = ULLONG_MAX, .packets = ULLONG_MAX,	\
 -	  .timeout = (set)->timeout }
 -
 -#define IP_SET_INIT_CIDR(a, b) ((a) ? (a) : (b))
 +	  .timeout = (map)->timeout }
  
  #define IPSET_CONCAT(a, b)		a##b
  #define IPSET_TOKEN(a, b)		IPSET_CONCAT(a, b)
diff --cc net/netfilter/ipset/ip_set_bitmap_gen.h
index 01a340ce9e94,a13e15be7911..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_gen.h
+++ b/net/netfilter/ipset/ip_set_bitmap_gen.h
@@@ -196,23 -221,10 +204,28 @@@ mtype_list(const struct ip_set *set
  			} else
  				goto nla_put_failure;
  		}
 -		if (mtype_do_list(skb, map, id, set->dsize))
 +		if (mtype_do_list(skb, map, id))
  			goto nla_put_failure;
++<<<<<<< HEAD
 +		if (SET_WITH_TIMEOUT(set)) {
 +#ifdef IP_SET_BITMAP_STORED_TIMEOUT
 +			if (nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
 +					  htonl(ip_set_timeout_stored(map, id,
 +							ext_timeout(x, map)))))
 +				goto nla_put_failure;
 +#else
 +			if (nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
 +					  htonl(ip_set_timeout_get(
 +							ext_timeout(x, map)))))
 +				goto nla_put_failure;
 +#endif
 +		}
 +		if (SET_WITH_COUNTER(set) &&
 +		    ip_set_put_counter(skb, ext_counter(x, map)))
++=======
+ 		if (ip_set_put_extensions(skb, set, x,
+ 		    mtype_is_filled((const struct mtype_elem *) x)))
++>>>>>>> 3fd986b3d99e (netfilter: ipset: Use a common function at listing the extensions)
  			goto nla_put_failure;
  		ipset_nest_end(skb, nested);
  	}
diff --cc net/netfilter/ipset/ip_set_bitmap_ipmac.c
index a041a2f15eb0,87a218f8ab5f..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_ipmac.c
+++ b/net/netfilter/ipset/ip_set_bitmap_ipmac.c
@@@ -178,22 -176,12 +178,25 @@@ bitmap_ipmac_do_del(const struct bitmap
  	return !test_and_clear_bit(e->id, map->members);
  }
  
++<<<<<<< HEAD
 +static inline unsigned long
 +ip_set_timeout_stored(struct bitmap_ipmac *map, u32 id, unsigned long *timeout)
 +{
 +	const struct bitmap_ipmac_elem *elem =
 +		get_elem(map->extensions, id, map->dsize);
 +
 +	return elem->filled == MAC_FILLED ? ip_set_timeout_get(timeout) :
 +					    *timeout;
 +}
 +
++=======
++>>>>>>> 3fd986b3d99e (netfilter: ipset: Use a common function at listing the extensions)
  static inline int
  bitmap_ipmac_do_list(struct sk_buff *skb, const struct bitmap_ipmac *map,
 -		     u32 id, size_t dsize)
 +		     u32 id)
  {
  	const struct bitmap_ipmac_elem *elem =
 -		get_elem(map->extensions, id, dsize);
 +		get_elem(map->extensions, id, map->dsize);
  
  	return nla_put_ipaddr4(skb, IPSET_ATTR_IP,
  			       htonl(map->first_ip + id)) ||
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index acd02e6a3233,b4add206c603..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -889,13 -961,7 +889,17 @@@ mtype_list(const struct ip_set *set
  			}
  			if (mtype_data_list(skb, e))
  				goto nla_put_failure;
++<<<<<<< HEAD
 +			if (SET_WITH_TIMEOUT(set) &&
 +			    nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
 +					  htonl(ip_set_timeout_get(
 +						ext_timeout(e, h)))))
 +				goto nla_put_failure;
 +			if (SET_WITH_COUNTER(set) &&
 +			    ip_set_put_counter(skb, ext_counter(e, h)))
++=======
+ 			if (ip_set_put_extensions(skb, set, e, true))
++>>>>>>> 3fd986b3d99e (netfilter: ipset: Use a common function at listing the extensions)
  				goto nla_put_failure;
  			ipset_nest_end(skb, nested);
  		}
diff --cc net/netfilter/ipset/ip_set_list_set.c
index a9a97c07ecb4,ba4232e451f4..000000000000
--- a/net/netfilter/ipset/ip_set_list_set.c
+++ b/net/netfilter/ipset/ip_set_list_set.c
@@@ -532,15 -510,9 +532,19 @@@ list_set_list(const struct ip_set *set
  				goto nla_put_failure;
  		}
  		if (nla_put_string(skb, IPSET_ATTR_NAME,
 -				   ip_set_name_byindex(e->id)))
 +				   ip_set_name_byindex(map->net, e->id)))
 +			goto nla_put_failure;
++<<<<<<< HEAD
 +		if (SET_WITH_TIMEOUT(set) &&
 +		    nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
 +				  htonl(ip_set_timeout_get(
 +						ext_timeout(e, map)))))
  			goto nla_put_failure;
 +		if (SET_WITH_COUNTER(set) &&
 +		    ip_set_put_counter(skb, ext_counter(e, map)))
++=======
+ 		if (ip_set_put_extensions(skb, set, e, true))
++>>>>>>> 3fd986b3d99e (netfilter: ipset: Use a common function at listing the extensions)
  			goto nla_put_failure;
  		ipset_nest_end(skb, nested);
  	}
* Unmerged path include/linux/netfilter/ipset/ip_set.h
* Unmerged path net/netfilter/ipset/ip_set_bitmap_gen.h
* Unmerged path net/netfilter/ipset/ip_set_bitmap_ipmac.c
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
* Unmerged path net/netfilter/ipset/ip_set_list_set.c
