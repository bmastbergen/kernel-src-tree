nfp: bpf: move program prepare and free into offload.c

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit c1c88eae8a8155c55dbbc7363f1f127c43e1b5d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c1c88eae.failed

Most of offload/translation prepare logic will be moved to
offload.c.  To help git generate more reasonable diffs
move nfp_prog_prepare() and nfp_prog_free() functions
there as a first step.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c1c88eae8a8155c55dbbc7363f1f127c43e1b5d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/bpf/main.h
#	drivers/net/ethernet/netronome/nfp/bpf/offload.c
diff --cc drivers/net/ethernet/netronome/nfp/bpf/main.h
index cc2a5beba757,b77231a134b9..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/main.h
+++ b/drivers/net/ethernet/netronome/nfp/bpf/main.h
@@@ -187,7 -174,12 +187,16 @@@ struct nfp_bpf_result 
  };
  
  int
++<<<<<<< HEAD
 +nfp_bpf_jit(struct bpf_prog *filter, void *prog, enum nfp_bpf_action_type act,
++=======
+ nfp_prog_prepare(struct nfp_prog *nfp_prog, const struct bpf_insn *prog,
+ 		 unsigned int cnt);
+ void nfp_prog_free(struct nfp_prog *nfp_prog);
+ 
+ int
+ nfp_bpf_jit(struct bpf_prog *filter, void *prog,
++>>>>>>> c1c88eae8a81 (nfp: bpf: move program prepare and free into offload.c)
  	    unsigned int prog_start, unsigned int prog_done,
  	    unsigned int prog_sz, struct nfp_bpf_result *res);
  
diff --cc drivers/net/ethernet/netronome/nfp/bpf/offload.c
index de79faf0874b,3eeee200051e..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/offload.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/offload.c
@@@ -51,40 -51,37 +51,74 @@@
  #include "../nfp_net_ctrl.h"
  #include "../nfp_net.h"
  
++<<<<<<< HEAD
 +void nfp_net_filter_stats_timer(unsigned long data)
 +{
 +	struct nfp_net *nn = (void *)data;
 +	struct nfp_net_bpf_priv *priv;
 +	struct nfp_stat_pair latest;
 +
 +	priv = nn->app_priv;
 +
 +	spin_lock_bh(&priv->rx_filter_lock);
 +
 +	if (nn->dp.ctrl & NFP_NET_CFG_CTRL_BPF)
 +		mod_timer(&priv->rx_filter_stats_timer,
 +			  jiffies + NFP_NET_STAT_POLL_IVL);
 +
 +	spin_unlock_bh(&priv->rx_filter_lock);
 +
 +	latest.pkts = nn_readq(nn, NFP_NET_CFG_STATS_APP1_FRAMES);
 +	latest.bytes = nn_readq(nn, NFP_NET_CFG_STATS_APP1_BYTES);
 +
 +	if (latest.pkts != priv->rx_filter.pkts)
 +		priv->rx_filter_change = jiffies;
 +
 +	priv->rx_filter = latest;
 +}
 +
 +#if 0 /* Not in RHEL7 */
 +static void nfp_net_bpf_stats_reset(struct nfp_net *nn)
 +{
 +	struct nfp_net_bpf_priv *priv = nn->app_priv;
 +
 +	priv->rx_filter.pkts = nn_readq(nn, NFP_NET_CFG_STATS_APP1_FRAMES);
 +	priv->rx_filter.bytes = nn_readq(nn, NFP_NET_CFG_STATS_APP1_BYTES);
 +	priv->rx_filter_prev = priv->rx_filter;
 +	priv->rx_filter_change = jiffies;
++=======
+ int
+ nfp_prog_prepare(struct nfp_prog *nfp_prog, const struct bpf_insn *prog,
+ 		 unsigned int cnt)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < cnt; i++) {
+ 		struct nfp_insn_meta *meta;
+ 
+ 		meta = kzalloc(sizeof(*meta), GFP_KERNEL);
+ 		if (!meta)
+ 			return -ENOMEM;
+ 
+ 		meta->insn = prog[i];
+ 		meta->n = i;
+ 
+ 		list_add_tail(&meta->l, &nfp_prog->insns);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void nfp_prog_free(struct nfp_prog *nfp_prog)
+ {
+ 	struct nfp_insn_meta *meta, *tmp;
+ 
+ 	list_for_each_entry_safe(meta, tmp, &nfp_prog->insns, l) {
+ 		list_del(&meta->l);
+ 		kfree(meta);
+ 	}
+ 	kfree(nfp_prog);
++>>>>>>> c1c88eae8a81 (nfp: bpf: move program prepare and free into offload.c)
  }
  
  static int
diff --git a/drivers/net/ethernet/netronome/nfp/bpf/jit.c b/drivers/net/ethernet/netronome/nfp/bpf/jit.c
index a86508b776ac..8e501b1c7692 100644
--- a/drivers/net/ethernet/netronome/nfp/bpf/jit.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/jit.c
@@ -77,17 +77,6 @@ nfp_meta_has_prev(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)
 	return meta->l.prev != &nfp_prog->insns;
 }
 
-static void nfp_prog_free(struct nfp_prog *nfp_prog)
-{
-	struct nfp_insn_meta *meta, *tmp;
-
-	list_for_each_entry_safe(meta, tmp, &nfp_prog->insns, l) {
-		list_del(&meta->l);
-		kfree(meta);
-	}
-	kfree(nfp_prog);
-}
-
 static void nfp_prog_push(struct nfp_prog *nfp_prog, u64 insn)
 {
 	if (nfp_prog->__prog_alloc_len == nfp_prog->prog_len) {
@@ -2051,28 +2040,6 @@ static int nfp_translate(struct nfp_prog *nfp_prog)
 	return nfp_fixup_branches(nfp_prog);
 }
 
-static int
-nfp_prog_prepare(struct nfp_prog *nfp_prog, const struct bpf_insn *prog,
-		 unsigned int cnt)
-{
-	unsigned int i;
-
-	for (i = 0; i < cnt; i++) {
-		struct nfp_insn_meta *meta;
-
-		meta = kzalloc(sizeof(*meta), GFP_KERNEL);
-		if (!meta)
-			return -ENOMEM;
-
-		meta->insn = prog[i];
-		meta->n = i;
-
-		list_add_tail(&meta->l, &nfp_prog->insns);
-	}
-
-	return 0;
-}
-
 /* --- Optimizations --- */
 static void nfp_bpf_opt_reg_init(struct nfp_prog *nfp_prog)
 {
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/main.h
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/offload.c
