tcmu: simplify scatter_data_area error handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Mike Christie <mchristi@redhat.com>
commit 1a1fc0b88e9019cb3b2f291bdcb2d03d38614690
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1a1fc0b8.failed

scatter_data_area always returns 0, so stop checking
for errors.

	Signed-off-by: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 1a1fc0b88e9019cb3b2f291bdcb2d03d38614690)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_user.c
diff --cc drivers/target/target_core_user.c
index 2ac4515b6a67,965f462eaa22..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -428,16 -520,17 +428,23 @@@ static inline size_t iov_tail(struct tc
  	return (size_t)iov->iov_base + iov->iov_len;
  }
  
++<<<<<<< HEAD
 +static void alloc_and_scatter_data_area(struct tcmu_dev *udev,
 +	unsigned long *cmd_bitmap, struct scatterlist *data_sg,
 +	unsigned int data_nents, struct iovec **iov, int *iov_cnt,
 +	bool copy_data)
++=======
+ static void scatter_data_area(struct tcmu_dev *udev,
+ 	struct tcmu_cmd *tcmu_cmd, struct scatterlist *data_sg,
+ 	unsigned int data_nents, struct iovec **iov,
+ 	int *iov_cnt, bool copy_data)
++>>>>>>> 1a1fc0b88e90 (tcmu: simplify scatter_data_area error handling)
  {
 -	int i, dbi;
 +	int i, block;
  	int block_remaining = 0;
 -	void *from, *to = NULL;
 -	size_t copy_bytes, to_offset, offset;
 +	void *from, *to;
 +	size_t copy_bytes, to_offset;
  	struct scatterlist *sg;
 -	struct page *page;
  
  	for_each_sg(data_sg, sg, data_nents, i) {
  		int sg_remaining = sg->length;
@@@ -473,22 -571,40 +480,27 @@@
  		}
  		kunmap_atomic(from - sg->offset);
  	}
++<<<<<<< HEAD
++=======
+ 	if (to)
+ 		kunmap_atomic(to);
++>>>>>>> 1a1fc0b88e90 (tcmu: simplify scatter_data_area error handling)
  }
  
 -static void gather_data_area(struct tcmu_dev *udev, struct tcmu_cmd *cmd,
 -			     bool bidi)
 +static void free_data_area(struct tcmu_dev *udev, struct tcmu_cmd *cmd)
  {
 -	struct se_cmd *se_cmd = cmd->se_cmd;
 -	int i, dbi;
 -	int block_remaining = 0;
 -	void *from = NULL, *to;
 -	size_t copy_bytes, offset;
 -	struct scatterlist *sg, *data_sg;
 -	struct page *page;
 -	unsigned int data_nents;
 -	uint32_t count = 0;
 -
 -	if (!bidi) {
 -		data_sg = se_cmd->t_data_sg;
 -		data_nents = se_cmd->t_data_nents;
 -	} else {
 -
 -		/*
 -		 * For bidi case, the first count blocks are for Data-Out
 -		 * buffer blocks, and before gathering the Data-In buffer
 -		 * the Data-Out buffer blocks should be discarded.
 -		 */
 -		count = DIV_ROUND_UP(se_cmd->data_length, DATA_BLOCK_SIZE);
 -
 -		data_sg = se_cmd->t_bidi_data_sg;
 -		data_nents = se_cmd->t_bidi_data_nents;
 -	}
 +	bitmap_xor(udev->data_bitmap, udev->data_bitmap, cmd->data_bitmap,
 +		   udev->max_blocks);
 +}
  
 -	tcmu_cmd_set_dbi_cur(cmd, count);
 +static void gather_data_area(struct tcmu_dev *udev, unsigned long *cmd_bitmap,
 +		struct scatterlist *data_sg, unsigned int data_nents)
 +{
 +	int i, block;
 +	int block_remaining = 0;
 +	void *from, *to;
 +	size_t copy_bytes, from_offset;
 +	struct scatterlist *sg;
  
  	for_each_sg(data_sg, sg, data_nents, i) {
  		int sg_remaining = sg->length;
@@@ -705,19 -862,29 +717,34 @@@ tcmu_queue_cmd_ring(struct tcmu_cmd *tc
  	iov_cnt = 0;
  	copy_to_data_area = (se_cmd->data_direction == DMA_TO_DEVICE
  		|| se_cmd->se_cmd_flags & SCF_BIDI);
++<<<<<<< HEAD
 +	alloc_and_scatter_data_area(udev, tcmu_cmd->data_bitmap,
 +		se_cmd->t_data_sg, se_cmd->t_data_nents, &iov, &iov_cnt,
 +		copy_to_data_area);
++=======
+ 	scatter_data_area(udev, tcmu_cmd, se_cmd->t_data_sg,
+ 			  se_cmd->t_data_nents, &iov, &iov_cnt,
+ 			  copy_to_data_area);
++>>>>>>> 1a1fc0b88e90 (tcmu: simplify scatter_data_area error handling)
  	entry->req.iov_cnt = iov_cnt;
 +	entry->req.iov_dif_cnt = 0;
  
  	/* Handle BIDI commands */
  	iov_cnt = 0;
++<<<<<<< HEAD
 +	alloc_and_scatter_data_area(udev, tcmu_cmd->data_bitmap,
 +		se_cmd->t_bidi_data_sg, se_cmd->t_bidi_data_nents, &iov,
 +		&iov_cnt, false);
++=======
+ 	if (se_cmd->se_cmd_flags & SCF_BIDI) {
+ 		iov++;
+ 		scatter_data_area(udev, tcmu_cmd, se_cmd->t_bidi_data_sg,
+ 				  se_cmd->t_bidi_data_nents, &iov, &iov_cnt,
+ 				  false);
+ 	}
++>>>>>>> 1a1fc0b88e90 (tcmu: simplify scatter_data_area error handling)
  	entry->req.iov_bidi_cnt = iov_cnt;
  
 -	ret = tcmu_setup_cmd_timer(tcmu_cmd);
 -	if (ret) {
 -		tcmu_cmd_free_data(tcmu_cmd, tcmu_cmd->dbi_cnt);
 -		mutex_unlock(&udev->cmdr_lock);
 -		return TCM_OUT_OF_RESOURCES;
 -	}
 -	entry->hdr.cmd_id = tcmu_cmd->cmd_id;
 -
  	/*
  	 * Recalaulate the command's base size and size according
  	 * to the actual needs
* Unmerged path drivers/target/target_core_user.c
