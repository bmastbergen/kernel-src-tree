perf evsel: Adopt find_process()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 2157f6ee18ce5224eea2b27582368b60d940bef6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/2157f6ee.failed

And make it static, nobody else uses it, if we ever need it in more
places we can carve a new source file for process related methods,
for now lets reduce util.{c,h} a tad more.

Link: http://lkml.kernel.org/n/tip-zgb28rllvypjibw52aaz9p15@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 2157f6ee18ce5224eea2b27582368b60d940bef6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/util.c
#	tools/perf/util/util.h
diff --cc tools/perf/util/util.c
index 29241c5d6ab8,3cd42995ac6f..000000000000
--- a/tools/perf/util/util.c
+++ b/tools/perf/util/util.c
@@@ -341,41 -343,84 +341,122 @@@ int perf_event_paranoid(void
  
  	return value;
  }
++<<<<<<< HEAD
 +
 +bool find_process(const char *name)
 +{
 +	size_t len = strlen(name);
 +	DIR *dir;
 +	struct dirent *d;
 +	int ret = -1;
 +
 +	dir = opendir(procfs__mountpoint());
 +	if (!dir)
 +		return false;
 +
 +	/* Walk through the directory. */
 +	while (ret && (d = readdir(dir)) != NULL) {
 +		char path[PATH_MAX];
 +		char *data;
 +		size_t size;
 +
 +		if ((d->d_type != DT_DIR) ||
 +		     !strcmp(".", d->d_name) ||
 +		     !strcmp("..", d->d_name))
 +			continue;
 +
 +		scnprintf(path, sizeof(path), "%s/%s/comm",
 +			  procfs__mountpoint(), d->d_name);
 +
 +		if (filename__read_str(path, &data, &size))
 +			continue;
 +
 +		ret = strncmp(name, data, len);
 +		free(data);
 +	}
 +
 +	closedir(dir);
 +	return ret ? false : true;
++=======
+ static int
+ fetch_ubuntu_kernel_version(unsigned int *puint)
+ {
+ 	ssize_t len;
+ 	size_t line_len = 0;
+ 	char *ptr, *line = NULL;
+ 	int version, patchlevel, sublevel, err;
+ 	FILE *vsig = fopen("/proc/version_signature", "r");
+ 
+ 	if (!vsig) {
+ 		pr_debug("Open /proc/version_signature failed: %s\n",
+ 			 strerror(errno));
+ 		return -1;
+ 	}
+ 
+ 	len = getline(&line, &line_len, vsig);
+ 	fclose(vsig);
+ 	err = -1;
+ 	if (len <= 0) {
+ 		pr_debug("Reading from /proc/version_signature failed: %s\n",
+ 			 strerror(errno));
+ 		goto errout;
+ 	}
+ 
+ 	ptr = strrchr(line, ' ');
+ 	if (!ptr) {
+ 		pr_debug("Parsing /proc/version_signature failed: %s\n", line);
+ 		goto errout;
+ 	}
+ 
+ 	err = sscanf(ptr + 1, "%d.%d.%d",
+ 		     &version, &patchlevel, &sublevel);
+ 	if (err != 3) {
+ 		pr_debug("Unable to get kernel version from /proc/version_signature '%s'\n",
+ 			 line);
+ 		goto errout;
+ 	}
+ 
+ 	if (puint)
+ 		*puint = (version << 16) + (patchlevel << 8) + sublevel;
+ 	err = 0;
+ errout:
+ 	free(line);
+ 	return err;
+ }
+ 
+ int
+ fetch_kernel_version(unsigned int *puint, char *str,
+ 		     size_t str_size)
+ {
+ 	struct utsname utsname;
+ 	int version, patchlevel, sublevel, err;
+ 	bool int_ver_ready = false;
+ 
+ 	if (access("/proc/version_signature", R_OK) == 0)
+ 		if (!fetch_ubuntu_kernel_version(puint))
+ 			int_ver_ready = true;
+ 
+ 	if (uname(&utsname))
+ 		return -1;
+ 
+ 	if (str && str_size) {
+ 		strncpy(str, utsname.release, str_size);
+ 		str[str_size - 1] = '\0';
+ 	}
+ 
+ 	err = sscanf(utsname.release, "%d.%d.%d",
+ 		     &version, &patchlevel, &sublevel);
+ 
+ 	if (err != 3) {
+ 		pr_debug("Unable to get kernel version from uname '%s'\n",
+ 			 utsname.release);
+ 		return -1;
+ 	}
+ 
+ 	if (puint && !int_ver_ready)
+ 		*puint = (version << 16) + (patchlevel << 8) + sublevel;
+ 	return 0;
++>>>>>>> 2157f6ee18ce (perf evsel: Adopt find_process())
  }
  
  const char *perf_tip(const char *dirpath)
diff --cc tools/perf/util/util.h
index 888bc1d56538,9ae7e6e35f9a..000000000000
--- a/tools/perf/util/util.h
+++ b/tools/perf/util/util.h
@@@ -55,7 -49,13 +55,17 @@@ int hex2u64(const char *ptr, u64 *val)
  extern unsigned int page_size;
  extern int cacheline_size;
  
++<<<<<<< HEAD
 +bool find_process(const char *name);
++=======
+ int fetch_kernel_version(unsigned int *puint,
+ 			 char *str, size_t str_sz);
+ #define KVER_VERSION(x)		(((x) >> 16) & 0xff)
+ #define KVER_PATCHLEVEL(x)	(((x) >> 8) & 0xff)
+ #define KVER_SUBLEVEL(x)	((x) & 0xff)
+ #define KVER_FMT	"%d.%d.%d"
+ #define KVER_PARAM(x)	KVER_VERSION(x), KVER_PATCHLEVEL(x), KVER_SUBLEVEL(x)
++>>>>>>> 2157f6ee18ce (perf evsel: Adopt find_process())
  
  const char *perf_tip(const char *dirpath);
  
diff --git a/tools/perf/util/evsel.c b/tools/perf/util/evsel.c
index 7b49778f1439..61c2334374d2 100644
--- a/tools/perf/util/evsel.c
+++ b/tools/perf/util/evsel.c
@@ -11,6 +11,7 @@
 #include <errno.h>
 #include <inttypes.h>
 #include <linux/bitops.h>
+#include <api/fs/fs.h>
 #include <api/fs/tracing_path.h>
 #include <traceevent/event-parse.h>
 #include <linux/hw_breakpoint.h>
@@ -19,6 +20,8 @@
 #include <linux/err.h>
 #include <sys/ioctl.h>
 #include <sys/resource.h>
+#include <sys/types.h>
+#include <dirent.h>
 #include "asm/bug.h"
 #include "callchain.h"
 #include "cgroup.h"
@@ -2439,6 +2442,42 @@ bool perf_evsel__fallback(struct perf_evsel *evsel, int err,
 	return false;
 }
 
+static bool find_process(const char *name)
+{
+	size_t len = strlen(name);
+	DIR *dir;
+	struct dirent *d;
+	int ret = -1;
+
+	dir = opendir(procfs__mountpoint());
+	if (!dir)
+		return false;
+
+	/* Walk through the directory. */
+	while (ret && (d = readdir(dir)) != NULL) {
+		char path[PATH_MAX];
+		char *data;
+		size_t size;
+
+		if ((d->d_type != DT_DIR) ||
+		     !strcmp(".", d->d_name) ||
+		     !strcmp("..", d->d_name))
+			continue;
+
+		scnprintf(path, sizeof(path), "%s/%s/comm",
+			  procfs__mountpoint(), d->d_name);
+
+		if (filename__read_str(path, &data, &size))
+			continue;
+
+		ret = strncmp(name, data, len);
+		free(data);
+	}
+
+	closedir(dir);
+	return ret ? false : true;
+}
+
 int perf_evsel__open_strerror(struct perf_evsel *evsel, struct target *target,
 			      int err, char *msg, size_t size)
 {
* Unmerged path tools/perf/util/util.c
* Unmerged path tools/perf/util/util.h
