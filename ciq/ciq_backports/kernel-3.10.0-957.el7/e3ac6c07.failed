nfp: bpf: require ETH table

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit e3ac6c0737e2b17bf11210e3fd66565e9b818b87
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/e3ac6c07.failed

Upcoming changes will require all netdevs supporting TC offloads
to have a full struct nfp_port.  Require those for BPF offload.
The operation without management FW reporting information about
Ethernet ports is something we only support for very old and very
basic NIC firmwares anyway.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Tested-by: Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e3ac6c0737e2b17bf11210e3fd66565e9b818b87)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/bpf/main.c
diff --cc drivers/net/ethernet/netronome/nfp/bpf/main.c
index 60a7af297852,61898dda11cf..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/main.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/main.c
@@@ -34,6 -34,8 +34,11 @@@
  #include <net/pkt_cls.h>
  
  #include "../nfpcore/nfp_cpp.h"
++<<<<<<< HEAD
++=======
+ #include "../nfpcore/nfp_nffw.h"
+ #include "../nfpcore/nfp_nsp.h"
++>>>>>>> e3ac6c0737e2 (nfp: bpf: require ETH table)
  #include "../nfp_app.h"
  #include "../nfp_main.h"
  #include "../nfp_net.h"
@@@ -88,23 -88,36 +93,42 @@@ static const char *nfp_bpf_extra_cap(st
  static int
  nfp_bpf_vnic_alloc(struct nfp_app *app, struct nfp_net *nn, unsigned int id)
  {
++<<<<<<< HEAD
 +	struct nfp_net_bpf_priv *priv;
 +	int ret;
 +
 +	priv = kmalloc(sizeof(*priv), GFP_KERNEL);
 +	if (!priv)
++=======
+ 	struct nfp_pf *pf = app->pf;
+ 	struct nfp_bpf_vnic *bv;
+ 	int err;
+ 
+ 	if (!pf->eth_tbl) {
+ 		nfp_err(pf->cpp, "No ETH table\n");
+ 		return -EINVAL;
+ 	}
+ 	if (pf->max_data_vnics != pf->eth_tbl->count) {
+ 		nfp_err(pf->cpp, "ETH entries don't match vNICs (%d vs %d)\n",
+ 			pf->max_data_vnics, pf->eth_tbl->count);
+ 		return -EINVAL;
+ 	}
+ 
+ 	bv = kzalloc(sizeof(*bv), GFP_KERNEL);
+ 	if (!bv)
++>>>>>>> e3ac6c0737e2 (nfp: bpf: require ETH table)
  		return -ENOMEM;
 -	nn->app_priv = bv;
  
 -	err = nfp_app_nic_vnic_alloc(app, nn, id);
 -	if (err)
 -		goto err_free_priv;
 +	nn->app_priv = priv;
 +	spin_lock_init(&priv->rx_filter_lock);
 +	setup_timer(&priv->rx_filter_stats_timer,
 +		    nfp_net_filter_stats_timer, (unsigned long)nn);
  
 -	bv->start_off = nn_readw(nn, NFP_NET_CFG_BPF_START);
 -	bv->tgt_done = nn_readw(nn, NFP_NET_CFG_BPF_DONE);
 +	ret = nfp_app_nic_vnic_alloc(app, nn, id);
 +	if (ret)
 +		kfree(priv);
  
 -	return 0;
 -err_free_priv:
 -	kfree(nn->app_priv);
 -	return err;
 +	return ret;
  }
  
  static void nfp_bpf_vnic_free(struct nfp_app *app, struct nfp_net *nn)
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/main.c
