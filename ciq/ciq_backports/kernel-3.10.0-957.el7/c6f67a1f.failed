iio: allow userspace to flush the hwfifo with non-blocking reads

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iio] allow userspace to flush the hwfifo with non-blocking reads (Tony Camuso) [1559170]
Rebuild_FUZZ: 95.93%
commit-author Octavian Purdila <octavian.purdila@intel.com>
commit c6f67a1f55a7f8a8373068ca07553bd2b2731949
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c6f67a1f.failed

This patch changes the semantics of non-blocking reads so that a
hardware fifo flush is triggered if the available data in the device
buffer is less then the requested size.

This allows userspace to accurately generate hardware fifo flushes, by
doing a non-blocking read with a size greater then the sum of the
device buffer and hardware fifo size.

	Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
	Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit c6f67a1f55a7f8a8373068ca07553bd2b2731949)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iio/industrialio-buffer.c
diff --cc drivers/iio/industrialio-buffer.c
index ed6b8aa675ce,f72be48e650c..000000000000
--- a/drivers/iio/industrialio-buffer.c
+++ b/drivers/iio/industrialio-buffer.c
@@@ -37,12 -37,56 +37,60 @@@ static bool iio_buffer_is_active(struc
  	return !list_empty(&buf->buffer_list);
  }
  
 -static size_t iio_buffer_data_available(struct iio_buffer *buf)
 +static bool iio_buffer_data_available(struct iio_buffer *buf)
  {
 -	return buf->access->data_available(buf);
 -}
 +	if (buf->access->data_available)
 +		return buf->access->data_available(buf);
  
++<<<<<<< HEAD
 +	return buf->stufftoread;
++=======
+ static int iio_buffer_flush_hwfifo(struct iio_dev *indio_dev,
+ 				   struct iio_buffer *buf, size_t required)
+ {
+ 	if (!indio_dev->info->hwfifo_flush_to_buffer)
+ 		return -ENODEV;
+ 
+ 	return indio_dev->info->hwfifo_flush_to_buffer(indio_dev, required);
+ }
+ 
+ static bool iio_buffer_ready(struct iio_dev *indio_dev, struct iio_buffer *buf,
+ 			     size_t to_wait, int to_flush)
+ {
+ 	size_t avail;
+ 	int flushed = 0;
+ 
+ 	/* wakeup if the device was unregistered */
+ 	if (!indio_dev->info)
+ 		return true;
+ 
+ 	/* drain the buffer if it was disabled */
+ 	if (!iio_buffer_is_active(buf)) {
+ 		to_wait = min_t(size_t, to_wait, 1);
+ 		to_flush = 0;
+ 	}
+ 
+ 	avail = iio_buffer_data_available(buf);
+ 
+ 	if (avail >= to_wait) {
+ 		/* force a flush for non-blocking reads */
+ 		if (!to_wait && avail < to_flush)
+ 			iio_buffer_flush_hwfifo(indio_dev, buf,
+ 						to_flush - avail);
+ 		return true;
+ 	}
+ 
+ 	if (to_flush)
+ 		flushed = iio_buffer_flush_hwfifo(indio_dev, buf,
+ 						  to_wait - avail);
+ 	if (flushed <= 0)
+ 		return false;
+ 
+ 	if (avail + flushed >= to_wait)
+ 		return true;
+ 
+ 	return false;
++>>>>>>> c6f67a1f55a7 (iio: allow userspace to flush the hwfifo with non-blocking reads)
  }
  
  /**
@@@ -56,6 -100,8 +104,11 @@@ ssize_t iio_buffer_read_first_n_outer(s
  {
  	struct iio_dev *indio_dev = filp->private_data;
  	struct iio_buffer *rb = indio_dev->buffer;
++<<<<<<< HEAD
++=======
+ 	size_t datum_size;
+ 	size_t to_wait;
++>>>>>>> c6f67a1f55a7 (iio: allow userspace to flush the hwfifo with non-blocking reads)
  	int ret;
  
  	if (!indio_dev->info)
@@@ -64,19 -110,28 +117,41 @@@
  	if (!rb || !rb->access->read_first_n)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	do {
 +		if (!iio_buffer_data_available(rb)) {
 +			if (filp->f_flags & O_NONBLOCK)
 +				return -EAGAIN;
++=======
+ 	datum_size = rb->bytes_per_datum;
+ 
+ 	/*
+ 	 * If datum_size is 0 there will never be anything to read from the
+ 	 * buffer, so signal end of file now.
+ 	 */
+ 	if (!datum_size)
+ 		return 0;
+ 
+ 	if (filp->f_flags & O_NONBLOCK)
+ 		to_wait = 0;
+ 	else
+ 		to_wait = min_t(size_t, n / datum_size, rb->watermark);
+ 
+ 	do {
+ 		ret = wait_event_interruptible(rb->pollq,
+ 		      iio_buffer_ready(indio_dev, rb, to_wait, n / datum_size));
+ 		if (ret)
+ 			return ret;
 -
 -		if (!indio_dev->info)
 -			return -ENODEV;
++>>>>>>> c6f67a1f55a7 (iio: allow userspace to flush the hwfifo with non-blocking reads)
 +
 +			ret = wait_event_interruptible(rb->pollq,
 +					iio_buffer_data_available(rb) ||
 +					indio_dev->info == NULL);
 +			if (ret)
 +				return ret;
 +			if (indio_dev->info == NULL)
 +				return -ENODEV;
 +		}
  
  		ret = rb->access->read_first_n(rb, n, buf);
  		if (ret == 0 && (filp->f_flags & O_NONBLOCK))
* Unmerged path drivers/iio/industrialio-buffer.c
