perf trace beauty ioctl: Improve 'cmd' beautifier

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 1cc47f2d46206d67285aea0ca7e8450af571da13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1cc47f2d.failed

By using the _IOC_(DIR,NR,TYPE,SIZE) macros to lookup a 'type' keyed
table that then gets indexed by 'nr', falling back to a notation similar
to the one used by 'strace', only more compact, i.e.:

   474.356 ( 0.007 ms): gnome-shell/22401 ioctl(fd: 8</dev/dri/card0>, cmd: (READ|WRITE, 0x64, 0xae, 0x1c), arg: 0x7ffc934f7880) = 0
   474.369 ( 0.053 ms): gnome-shell/22401 ioctl(fd: 8</dev/dri/card0>, cmd: (READ|WRITE, 0x64, 0xb0, 0x18), arg: 0x7ffc934f77d0) = 0
   505.055 ( 0.014 ms): gnome-shell/22401 ioctl(fd: 8</dev/dri/card0>, cmd: (READ|WRITE, 0x64, 0xaf, 0x4), arg: 0x7ffc934f741c) = 0

This also moves it out of builtin-trace.c and into trace/beauty/ioctl.c
to better compartimentalize all these formatters.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/n/tip-s3enursdxsvnhdomh6qlte4g@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 1cc47f2d46206d67285aea0ca7e8450af571da13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-trace.c
#	tools/perf/trace/beauty/Build
#	tools/perf/trace/beauty/beauty.h
diff --cc tools/perf/builtin-trace.c
index 242f8876b02a,de02413a25d3..000000000000
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@@ -336,25 -338,6 +336,28 @@@ size_t syscall_arg__scnprintf_strarrays
  	return scnprintf(bf, size, "%d", arg->val);
  }
  
++<<<<<<< HEAD
 +#if defined(__i386__) || defined(__x86_64__)
 +/*
 + * FIXME: Make this available to all arches as soon as the ioctl beautifier
 + * 	  gets rewritten to support all arches.
 + */
 +static size_t syscall_arg__scnprintf_strhexarray(char *bf, size_t size,
 +						 struct syscall_arg *arg)
 +{
 +	return __syscall_arg__scnprintf_strarray(bf, size, "%#x", arg);
 +}
 +
 +#define SCA_STRHEXARRAY syscall_arg__scnprintf_strhexarray
 +#endif /* defined(__i386__) || defined(__x86_64__) */
 +
 +static size_t syscall_arg__scnprintf_fd(char *bf, size_t size,
 +					struct syscall_arg *arg);
 +
 +#define SCA_FD syscall_arg__scnprintf_fd
 +
++=======
++>>>>>>> 1cc47f2d4620 (perf trace beauty ioctl: Improve 'cmd' beautifier)
  #ifndef AT_FDCWD
  #define AT_FDCWD	-100
  #endif
@@@ -672,41 -629,31 +648,46 @@@ static struct syscall_fmt 
  /*
   * FIXME: Make this available to all arches.
   */
++<<<<<<< HEAD
 +			     [1] = SCA_STRHEXARRAY, /* cmd */
 +			     [2] = SCA_HEX, /* arg */ },
 +	  .arg_parm	 = { [1] = &strarray__tioctls, /* cmd */ }, },
++=======
+ 		   [1] = { .scnprintf = SCA_IOCTL_CMD, /* cmd */ },
+ 		   [2] = { .scnprintf = SCA_HEX, /* arg */ }, }, },
++>>>>>>> 1cc47f2d4620 (perf trace beauty ioctl: Improve 'cmd' beautifier)
  #else
 -		   [2] = { .scnprintf = SCA_HEX, /* arg */ }, }, },
 +			     [2] = SCA_HEX, /* arg */ }, },
  #endif
 -	{ .name	    = "keyctl",
 -	  .arg = { [0] = STRARRAY(option, keyctl_options), }, },
 -	{ .name	    = "kill",
 -	  .arg = { [1] = { .scnprintf = SCA_SIGNUM, /* sig */ }, }, },
 -	{ .name	    = "linkat",
 -	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* fd */ }, }, },
 -	{ .name	    = "lseek",
 -	  .arg = { [2] = STRARRAY(whence, whences), }, },
 -	{ .name	    = "lstat", .alias = "newlstat", },
 -	{ .name     = "madvise",
 -	  .arg = { [0] = { .scnprintf = SCA_HEX,      /* start */ },
 -		   [2] = { .scnprintf = SCA_MADV_BHV, /* behavior */ }, }, },
 -	{ .name	    = "mkdirat",
 -	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* fd */ }, }, },
 -	{ .name	    = "mknodat",
 -	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* fd */ }, }, },
 -	{ .name	    = "mlock",
 -	  .arg = { [0] = { .scnprintf = SCA_HEX, /* addr */ }, }, },
 -	{ .name	    = "mlockall",
 -	  .arg = { [0] = { .scnprintf = SCA_HEX, /* addr */ }, }, },
 +	{ .name	    = "keyctl",	    .errmsg = true, STRARRAY(0, option, keyctl_options), },
 +	{ .name	    = "kill",	    .errmsg = true,
 +	  .arg_scnprintf = { [1] = SCA_SIGNUM, /* sig */ }, },
 +	{ .name	    = "lchown",    .errmsg = true, },
 +	{ .name	    = "lgetxattr",  .errmsg = true, },
 +	{ .name	    = "linkat",	    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* fd */ }, },
 +	{ .name	    = "listxattr",  .errmsg = true, },
 +	{ .name	    = "llistxattr", .errmsg = true, },
 +	{ .name	    = "lremovexattr",  .errmsg = true, },
 +	{ .name	    = "lseek",	    .errmsg = true,
 +	  .arg_scnprintf = { [2] = SCA_STRARRAY, /* whence */ },
 +	  .arg_parm	 = { [2] = &strarray__whences, /* whence */ }, },
 +	{ .name	    = "lsetxattr",  .errmsg = true, },
 +	{ .name	    = "lstat",	    .errmsg = true, .alias = "newlstat", },
 +	{ .name	    = "lsxattr",    .errmsg = true, },
 +	{ .name     = "madvise",    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_HEX,	 /* start */
 +			     [2] = SCA_MADV_BHV, /* behavior */ }, },
 +	{ .name	    = "mkdir",    .errmsg = true, },
 +	{ .name	    = "mkdirat",    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* fd */ }, },
 +	{ .name	    = "mknod",      .errmsg = true, },
 +	{ .name	    = "mknodat",    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* fd */ }, },
 +	{ .name	    = "mlock",	    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_HEX, /* addr */ }, },
 +	{ .name	    = "mlockall",   .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_HEX, /* addr */ }, },
  	{ .name	    = "mmap",	    .hexret = true,
  /* The standard mmap maps to old_mmap on s390x */
  #if defined(__s390x__)
diff --cc tools/perf/trace/beauty/Build
index 55f4f086ea37,6f3f159f97e0..000000000000
--- a/tools/perf/trace/beauty/Build
+++ b/tools/perf/trace/beauty/Build
@@@ -1,2 -1,6 +1,11 @@@
++<<<<<<< HEAD
 +# XXX there's no statx syscall in RHEL7
 +#libperf-y += statx.o
++=======
+ libperf-y += clone.o
+ libperf-y += fcntl.o
+ ifeq ($(SRCARCH),$(filter $(SRCARCH),x86))
+ libperf-y += ioctl.o
+ endif
+ libperf-y += statx.o
++>>>>>>> 1cc47f2d4620 (perf trace beauty ioctl: Improve 'cmd' beautifier)
diff --cc tools/perf/trace/beauty/beauty.h
index d493f9e76cf1,47a36a8eb842..000000000000
--- a/tools/perf/trace/beauty/beauty.h
+++ b/tools/perf/trace/beauty/beauty.h
@@@ -51,6 -51,36 +51,39 @@@ unsigned long syscall_arg__val(struct s
  size_t syscall_arg__scnprintf_strarrays(char *bf, size_t size, struct syscall_arg *arg);
  #define SCA_STRARRAYS syscall_arg__scnprintf_strarrays
  
++<<<<<<< HEAD
++=======
+ size_t syscall_arg__scnprintf_fd(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_FD syscall_arg__scnprintf_fd
+ 
+ size_t syscall_arg__scnprintf_hex(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_HEX syscall_arg__scnprintf_hex
+ 
+ size_t syscall_arg__scnprintf_int(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_INT syscall_arg__scnprintf_int
+ 
+ size_t syscall_arg__scnprintf_long(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_LONG syscall_arg__scnprintf_long
+ 
+ size_t syscall_arg__scnprintf_pid(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_PID syscall_arg__scnprintf_pid
+ 
+ size_t syscall_arg__scnprintf_clone_flags(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_CLONE_FLAGS syscall_arg__scnprintf_clone_flags
+ 
+ size_t syscall_arg__scnprintf_fcntl_cmd(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_FCNTL_CMD syscall_arg__scnprintf_fcntl_cmd
+ 
+ size_t syscall_arg__scnprintf_fcntl_arg(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_FCNTL_ARG syscall_arg__scnprintf_fcntl_arg
+ 
+ size_t syscall_arg__scnprintf_ioctl_cmd(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_IOCTL_CMD syscall_arg__scnprintf_ioctl_cmd
+ 
+ size_t syscall_arg__scnprintf_open_flags(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_OPEN_FLAGS syscall_arg__scnprintf_open_flags
+ 
++>>>>>>> 1cc47f2d4620 (perf trace beauty ioctl: Improve 'cmd' beautifier)
  size_t syscall_arg__scnprintf_statx_flags(char *bf, size_t size, struct syscall_arg *arg);
  #define SCA_STATX_FLAGS syscall_arg__scnprintf_statx_flags
  
* Unmerged path tools/perf/builtin-trace.c
* Unmerged path tools/perf/trace/beauty/Build
* Unmerged path tools/perf/trace/beauty/beauty.h
diff --git a/tools/perf/trace/beauty/ioctl.c b/tools/perf/trace/beauty/ioctl.c
new file mode 100644
index 000000000000..5f0dba8aaa88
--- /dev/null
+++ b/tools/perf/trace/beauty/ioctl.c
@@ -0,0 +1,88 @@
+/*
+ * trace/beauty/ioctl.c
+ *
+ *  Copyright (C) 2017, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
+ *
+ * Released under the GPL v2. (and only v2, not any later version)
+ */
+
+#include "trace/beauty/beauty.h"
+#include <linux/kernel.h>
+
+/*
+ * FIXME: to support all arches we have to improve this, for
+ * now, to build on older systems without things like TIOCGEXCL,
+ * get it directly from our copy.
+ *
+ * Right now only x86 is being supported for beautifying ioctl args
+ * in 'perf trace', see tools/perf/trace/beauty/Build and builtin-trace.c
+ */
+#include <uapi/asm-generic/ioctls.h>
+
+static size_t ioctl__scnprintf_tty_cmd(int nr, char *bf, size_t size)
+{
+	static const char *ioctl_tty_cmd[] = {
+	"TCGETS", "TCSETS", "TCSETSW", "TCSETSF", "TCGETA", "TCSETA", "TCSETAW",
+	"TCSETAF", "TCSBRK", "TCXONC", "TCFLSH", "TIOCEXCL", "TIOCNXCL", "TIOCSCTTY",
+	"TIOCGPGRP", "TIOCSPGRP", "TIOCOUTQ", "TIOCSTI", "TIOCGWINSZ", "TIOCSWINSZ",
+	"TIOCMGET", "TIOCMBIS", "TIOCMBIC", "TIOCMSET", "TIOCGSOFTCAR", "TIOCSSOFTCAR",
+	"FIONREAD", "TIOCLINUX", "TIOCCONS", "TIOCGSERIAL", "TIOCSSERIAL", "TIOCPKT",
+	"FIONBIO", "TIOCNOTTY", "TIOCSETD", "TIOCGETD", "TCSBRKP",
+	[_IOC_NR(TIOCSBRK)] = "TIOCSBRK", "TIOCCBRK", "TIOCGSID", "TCGETS2", "TCSETS2",
+	"TCSETSW2", "TCSETSF2", "TIOCGRS48", "TIOCSRS485", "TIOCGPTN", "TIOCSPTLCK",
+	"TIOCGDEV", "TCSETX", "TCSETXF", "TCSETXW", "TIOCSIG", "TIOCVHANGUP", "TIOCGPKT",
+	"TIOCGPTLCK", [_IOC_NR(TIOCGEXCL)] = "TIOCGEXCL", "TIOCGPTPEER",
+	[_IOC_NR(FIONCLEX)] = "FIONCLEX", "FIOCLEX", "FIOASYNC", "TIOCSERCONFIG",
+	"TIOCSERGWILD", "TIOCSERSWILD", "TIOCGLCKTRMIOS", "TIOCSLCKTRMIOS",
+	"TIOCSERGSTRUCT", "TIOCSERGETLSR", "TIOCSERGETMULTI", "TIOCSERSETMULTI",
+	"TIOCMIWAIT", "TIOCGICOUNT", };
+	static DEFINE_STRARRAY(ioctl_tty_cmd);
+
+	if (nr < strarray__ioctl_tty_cmd.nr_entries && strarray__ioctl_tty_cmd.entries[nr] != NULL)
+		return scnprintf(bf, size, "%s", strarray__ioctl_tty_cmd.entries[nr]);
+
+	return scnprintf(bf, size, "(%#x, %#x)", 'T', nr);
+}
+
+static size_t ioctl__scnprintf_cmd(unsigned long cmd, char *bf, size_t size)
+{
+	int dir	 = _IOC_DIR(cmd),
+	    type = _IOC_TYPE(cmd),
+	    nr	 = _IOC_NR(cmd),
+	    sz	 = _IOC_SIZE(cmd);
+	int printed = 0;
+	static const struct ioctl_type {
+		int	type;
+		size_t	(*scnprintf)(int nr, char *bf, size_t size);
+	} ioctl_types[] = { /* Must be ordered by type */
+		{ .type	= 'T', .scnprintf = ioctl__scnprintf_tty_cmd, }
+	};
+	const int nr_types = ARRAY_SIZE(ioctl_types);
+
+	if (type >= ioctl_types[0].type && type <= ioctl_types[nr_types - 1].type) {
+		const int index = type - ioctl_types[0].type;
+
+		if (ioctl_types[index].scnprintf != NULL)
+			return ioctl_types[index].scnprintf(nr, bf, size);
+	}
+
+	printed += scnprintf(bf + printed, size - printed, "%c", '(');
+
+	if (dir == _IOC_NONE) {
+		printed += scnprintf(bf + printed, size - printed, "%s", "NONE");
+	} else {
+		if (dir & _IOC_READ)
+			printed += scnprintf(bf + printed, size - printed, "%s", "READ");
+		if (dir & _IOC_WRITE)
+			printed += scnprintf(bf + printed, size - printed, "%s%s", dir & _IOC_READ ? "|" : "", "WRITE");
+	}
+
+	return printed + scnprintf(bf + printed, size - printed, ", %#x, %#x, %#x)", type, nr, sz);
+}
+
+size_t syscall_arg__scnprintf_ioctl_cmd(char *bf, size_t size, struct syscall_arg *arg)
+{
+	unsigned long cmd = arg->val;
+
+	return ioctl__scnprintf_cmd(cmd, bf, size);
+}
