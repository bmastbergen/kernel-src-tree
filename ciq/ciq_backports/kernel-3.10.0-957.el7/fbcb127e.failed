net/mlx5e: Support DSCP trust state to Ethernet's IP packet on SQ

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Support DSCP trust state to Ethernet's IP packet on SQ (Alaa Hleihel) [1520297 1460717]
Rebuild_FUZZ: 96.83%
commit-author Huy Nguyen <huyn@mellanox.com>
commit fbcb127e89ba8a4ccbec609a27f8d110474044c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/fbcb127e.failed

If the port is in DSCP trust state, packets are placed in the right
priority queue based on the dscp value. This is done by selecting
the transmit queue based on the dscp of the skb.

Until now select_queue honors priority only from the vlan header.
However that is not sufficient in cases where port trust state is DSCP
mode as packet might not even contain vlan header. Therefore if the port
is in dscp trust state and vport's min inline mode is not NONE,
copy the IP header to the eseg's inline header if the skb has it.
This is done by changing the transmit queue sq's min inline mode to L3.
Note that the min inline mode of sqs that belong to other features such
as xdpsq, icosq are not modified.

	Signed-off-by: Huy Nguyen <huyn@mellanox.com>
	Reviewed-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit fbcb127e89ba8a4ccbec609a27f8d110474044c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index b8372399d956,fae7b62d173f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -1028,5 -1083,5 +1028,9 @@@ void mlx5e_destroy_netdev(struct mlx5e_
  void mlx5e_build_nic_params(struct mlx5_core_dev *mdev,
  			    struct mlx5e_params *params,
  			    u16 max_channels);
++<<<<<<< HEAD
 +
++=======
+ u8 mlx5e_params_calculate_tx_min_inline(struct mlx5_core_dev *mdev);
++>>>>>>> fbcb127e89ba (net/mlx5e: Support DSCP trust state to Ethernet's IP packet on SQ)
  #endif /* __MLX5_EN_H__ */
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
index 9d64d0759ee9,b402d69a701b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
@@@ -805,6 -917,129 +805,132 @@@ static void mlx5e_ets_init(struct mlx5e
  	mlx5e_dcbnl_ieee_setets_core(priv, &ets);
  }
  
++<<<<<<< HEAD
++=======
+ enum {
+ 	INIT,
+ 	DELETE,
+ };
+ 
+ static void mlx5e_dcbnl_dscp_app(struct mlx5e_priv *priv, int action)
+ {
+ 	struct dcb_app temp;
+ 	int i;
+ 
+ 	if (!MLX5_CAP_GEN(priv->mdev, vport_group_manager))
+ 		return;
+ 
+ 	if (!MLX5_DSCP_SUPPORTED(priv->mdev))
+ 		return;
+ 
+ 	/* No SEL_DSCP entry in non DSCP state */
+ 	if (priv->dcbx_dp.trust_state != MLX5_QPTS_TRUST_DSCP)
+ 		return;
+ 
+ 	temp.selector = IEEE_8021QAZ_APP_SEL_DSCP;
+ 	for (i = 0; i < MLX5E_MAX_DSCP; i++) {
+ 		temp.protocol = i;
+ 		temp.priority = priv->dcbx_dp.dscp2prio[i];
+ 		if (action == INIT)
+ 			dcb_ieee_setapp(priv->netdev, &temp);
+ 		else
+ 			dcb_ieee_delapp(priv->netdev, &temp);
+ 	}
+ 
+ 	priv->dcbx.dscp_app_cnt = (action == INIT) ? MLX5E_MAX_DSCP : 0;
+ }
+ 
+ void mlx5e_dcbnl_init_app(struct mlx5e_priv *priv)
+ {
+ 	mlx5e_dcbnl_dscp_app(priv, INIT);
+ }
+ 
+ void mlx5e_dcbnl_delete_app(struct mlx5e_priv *priv)
+ {
+ 	mlx5e_dcbnl_dscp_app(priv, DELETE);
+ }
+ 
+ static void mlx5e_trust_update_tx_min_inline_mode(struct mlx5e_priv *priv,
+ 						  struct mlx5e_params *params)
+ {
+ 	params->tx_min_inline_mode = mlx5e_params_calculate_tx_min_inline(priv->mdev);
+ 	if (priv->dcbx_dp.trust_state == MLX5_QPTS_TRUST_DSCP &&
+ 	    params->tx_min_inline_mode == MLX5_INLINE_MODE_L2)
+ 		params->tx_min_inline_mode = MLX5_INLINE_MODE_IP;
+ }
+ 
+ static void mlx5e_trust_update_sq_inline_mode(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_channels new_channels = {};
+ 
+ 	mutex_lock(&priv->state_lock);
+ 
+ 	if (!test_bit(MLX5E_STATE_OPENED, &priv->state))
+ 		goto out;
+ 
+ 	new_channels.params = priv->channels.params;
+ 	mlx5e_trust_update_tx_min_inline_mode(priv, &new_channels.params);
+ 
+ 	/* Skip if tx_min_inline is the same */
+ 	if (new_channels.params.tx_min_inline_mode ==
+ 	    priv->channels.params.tx_min_inline_mode)
+ 		goto out;
+ 
+ 	if (mlx5e_open_channels(priv, &new_channels))
+ 		goto out;
+ 	mlx5e_switch_priv_channels(priv, &new_channels, NULL);
+ 
+ out:
+ 	mutex_unlock(&priv->state_lock);
+ }
+ 
+ static int mlx5e_set_trust_state(struct mlx5e_priv *priv, u8 trust_state)
+ {
+ 	int err;
+ 
+ 	err =  mlx5_set_trust_state(priv->mdev, trust_state);
+ 	if (err)
+ 		return err;
+ 	priv->dcbx_dp.trust_state = trust_state;
+ 	mlx5e_trust_update_sq_inline_mode(priv);
+ 
+ 	return err;
+ }
+ 
+ static int mlx5e_set_dscp2prio(struct mlx5e_priv *priv, u8 dscp, u8 prio)
+ {
+ 	int err;
+ 
+ 	err = mlx5_set_dscp2prio(priv->mdev, dscp, prio);
+ 	if (err)
+ 		return err;
+ 
+ 	priv->dcbx_dp.dscp2prio[dscp] = prio;
+ 	return err;
+ }
+ 
+ static int mlx5e_trust_initialize(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	int err;
+ 
+ 	if (!MLX5_DSCP_SUPPORTED(mdev))
+ 		return 0;
+ 
+ 	err = mlx5_query_trust_state(priv->mdev, &priv->dcbx_dp.trust_state);
+ 	if (err)
+ 		return err;
+ 
+ 	mlx5e_trust_update_tx_min_inline_mode(priv, &priv->channels.params);
+ 
+ 	err = mlx5_query_dscp2prio(priv->mdev, priv->dcbx_dp.dscp2prio);
+ 	if (err)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> fbcb127e89ba (net/mlx5e: Support DSCP trust state to Ethernet's IP packet on SQ)
  void mlx5e_dcbnl_initialize(struct mlx5e_priv *priv)
  {
  	struct mlx5e_dcbx *dcbx = &priv->dcbx;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_common.c b/drivers/net/ethernet/mellanox/mlx5/core/en_common.c
index 157d02917237..784e282803db 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_common.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_common.c
@@ -171,3 +171,15 @@ out:
 
 	return err;
 }
+
+u8 mlx5e_params_calculate_tx_min_inline(struct mlx5_core_dev *mdev)
+{
+	u8 min_inline_mode;
+
+	mlx5_query_min_inline(mdev, &min_inline_mode);
+	if (min_inline_mode == MLX5_INLINE_MODE_NONE &&
+	    !MLX5_CAP_ETH(mdev, wqe_vlan_insert))
+		min_inline_mode = MLX5_INLINE_MODE_L2;
+
+	return min_inline_mode;
+}
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 661319054465..ff64aaa91337 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -3755,10 +3755,7 @@ void mlx5e_build_nic_params(struct mlx5_core_dev *mdev,
 
 	/* TX inline */
 	params->tx_max_inline = mlx5e_get_max_inline_cap(mdev);
-	mlx5_query_min_inline(mdev, &params->tx_min_inline_mode);
-	if (params->tx_min_inline_mode == MLX5_INLINE_MODE_NONE &&
-	    !MLX5_CAP_ETH(mdev, wqe_vlan_insert))
-		params->tx_min_inline_mode = MLX5_INLINE_MODE_L2;
+	params->tx_min_inline_mode = mlx5e_params_calculate_tx_min_inline(mdev);
 
 	/* RSS */
 	params->rss_hfunc = ETH_RSS_HASH_XOR;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tx.c b/drivers/net/ethernet/mellanox/mlx5/core/en_tx.c
index a7c208a1ad83..de651de35c9b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tx.c
@@ -32,6 +32,7 @@
 
 #include <linux/tcp.h>
 #include <linux/if_vlan.h>
+#include <net/dsfield.h>
 #include "en.h"
 #include "ipoib/ipoib.h"
 #include "en_accel/ipsec_rxtx.h"
@@ -86,6 +87,20 @@ static void mlx5e_dma_unmap_wqe_err(struct mlx5e_txqsq *sq, u8 num_dma)
 	}
 }
 
+#ifdef CONFIG_MLX5_CORE_EN_DCB
+static inline int mlx5e_get_dscp_up(struct mlx5e_priv *priv, struct sk_buff *skb)
+{
+	int dscp_cp = 0;
+
+	if (skb->protocol == htons(ETH_P_IP))
+		dscp_cp = ipv4_get_dsfield(ip_hdr(skb)) >> 2;
+	else if (skb->protocol == htons(ETH_P_IPV6))
+		dscp_cp = ipv6_get_dsfield(ipv6_hdr(skb)) >> 2;
+
+	return priv->dcbx_dp.dscp2prio[dscp_cp];
+}
+#endif
+
 u16 mlx5e_select_queue(struct net_device *dev, struct sk_buff *skb,
 		       void *accel_priv, select_queue_fallback_t fallback)
 {
@@ -97,8 +112,13 @@ u16 mlx5e_select_queue(struct net_device *dev, struct sk_buff *skb,
 	if (!netdev_get_num_tc(dev))
 		return channel_ix;
 
-	if (skb_vlan_tag_present(skb))
-		up = skb->vlan_tci >> VLAN_PRIO_SHIFT;
+#ifdef CONFIG_MLX5_CORE_EN_DCB
+	if (priv->dcbx_dp.trust_state == MLX5_QPTS_TRUST_DSCP)
+		up = mlx5e_get_dscp_up(priv, skb);
+	else
+#endif
+		if (skb_vlan_tag_present(skb))
+			up = skb->vlan_tci >> VLAN_PRIO_SHIFT;
 
 	/* channel_ix can be larger than num_channels since
 	 * dev->num_real_tx_queues = num_channels * num_tc
