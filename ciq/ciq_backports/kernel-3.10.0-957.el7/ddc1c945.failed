s390/dasd: configurable IFCC handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [s390] dasd: configurable IFCC handling (Hendrik Brueckner) [1548504]
Rebuild_FUZZ: 92.75%
commit-author Stefan Haberland <sth@linux.vnet.ibm.com>
commit ddc1c9453550eabd6284021b167f708982df3ca9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ddc1c945.failed

Make the behavior in case of constant IFCC/CCC errors configurable.
Add a sysfs attribute to switch between path disabled after threshold
exceeded (default) and message only.

	Reviewed-by: Jan Hoeppner <hoeppner@linux.vnet.ibm.com>
	Reviewed-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
	Signed-off-by: Stefan Haberland <sth@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit ddc1c9453550eabd6284021b167f708982df3ca9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/uapi/asm/dasd.h
diff --cc arch/s390/include/uapi/asm/dasd.h
index 1aefa1d4ea99,832be5c2584f..000000000000
--- a/arch/s390/include/uapi/asm/dasd.h
+++ b/arch/s390/include/uapi/asm/dasd.h
@@@ -67,21 -68,27 +67,45 @@@ typedef struct dasd_information2_t 
  #define DASD_FORMAT_CDL  2
  /*
   * values to be used for dasd_information_t.features
++<<<<<<< HEAD
 + * 0x00: default features
 + * 0x01: readonly (ro)
 + * 0x02: use diag discipline (diag)
 + * 0x04: set the device initially online (internal use only)
 + * 0x08: enable ERP related logging
 + * 0x20: give access to raw eckd data
 + */
 +#define DASD_FEATURE_DEFAULT	     0x00
 +#define DASD_FEATURE_READONLY	     0x01
 +#define DASD_FEATURE_USEDIAG	     0x02
 +#define DASD_FEATURE_INITIAL_ONLINE  0x04
 +#define DASD_FEATURE_ERPLOG	     0x08
 +#define DASD_FEATURE_FAILFAST	     0x10
 +#define DASD_FEATURE_FAILONSLCK      0x20
 +#define DASD_FEATURE_USERAW	     0x40
++=======
+  * 0x100: default features
+  * 0x001: readonly (ro)
+  * 0x002: use diag discipline (diag)
+  * 0x004: set the device initially online (internal use only)
+  * 0x008: enable ERP related logging
+  * 0x010: allow I/O to fail on lost paths
+  * 0x020: allow I/O to fail when a lock was stolen
+  * 0x040: give access to raw eckd data
+  * 0x080: enable discard support
+  * 0x100: enable autodisable for IFCC errors (default)
+  */
+ #define DASD_FEATURE_READONLY	      0x001
+ #define DASD_FEATURE_USEDIAG	      0x002
+ #define DASD_FEATURE_INITIAL_ONLINE   0x004
+ #define DASD_FEATURE_ERPLOG	      0x008
+ #define DASD_FEATURE_FAILFAST	      0x010
+ #define DASD_FEATURE_FAILONSLCK       0x020
+ #define DASD_FEATURE_USERAW	      0x040
+ #define DASD_FEATURE_DISCARD	      0x080
+ #define DASD_FEATURE_PATH_AUTODISABLE 0x100
+ #define DASD_FEATURE_DEFAULT	      DASD_FEATURE_PATH_AUTODISABLE
++>>>>>>> ddc1c9453550 (s390/dasd: configurable IFCC handling)
  
  #define DASD_PARTN_BITS 2
  
* Unmerged path arch/s390/include/uapi/asm/dasd.h
diff --git a/drivers/s390/block/dasd_3990_erp.c b/drivers/s390/block/dasd_3990_erp.c
index f59a4a1d5a0d..a632a5ae6027 100644
--- a/drivers/s390/block/dasd_3990_erp.c
+++ b/drivers/s390/block/dasd_3990_erp.c
@@ -2213,15 +2213,28 @@ static void dasd_3990_erp_disable_path(struct dasd_device *device, __u8 lpum)
 {
 	int pos = pathmask_to_pos(lpum);
 
+	if (!(device->features & DASD_FEATURE_PATH_AUTODISABLE)) {
+		dev_err(&device->cdev->dev,
+			"Path %x.%02x (pathmask %02x) is operational despite excessive IFCCs\n",
+			device->path[pos].cssid, device->path[pos].chpid, lpum);
+		goto out;
+	}
+
 	/* no remaining path, cannot disable */
-	if (!(dasd_path_get_opm(device) & ~lpum))
-		return;
+	if (!(dasd_path_get_opm(device) & ~lpum)) {
+		dev_err(&device->cdev->dev,
+			"Last path %x.%02x (pathmask %02x) is operational despite excessive IFCCs\n",
+			device->path[pos].cssid, device->path[pos].chpid, lpum);
+		goto out;
+	}
 
 	dev_err(&device->cdev->dev,
 		"Path %x.%02x (pathmask %02x) is disabled - IFCC threshold exceeded\n",
 		device->path[pos].cssid, device->path[pos].chpid, lpum);
 	dasd_path_remove_opm(device, lpum);
 	dasd_path_add_ifccpm(device, lpum);
+
+out:
 	device->path[pos].errorclk = 0;
 	atomic_set(&device->path[pos].error_count, 0);
 }
diff --git a/drivers/s390/block/dasd_devmap.c b/drivers/s390/block/dasd_devmap.c
index 459fbc1a800b..20f2b83b5813 100644
--- a/drivers/s390/block/dasd_devmap.c
+++ b/drivers/s390/block/dasd_devmap.c
@@ -1473,9 +1473,49 @@ dasd_path_threshold_store(struct device *dev, struct device_attribute *attr,
 	dasd_put_device(device);
 	return count;
 }
-
 static DEVICE_ATTR(path_threshold, 0644, dasd_path_threshold_show,
 		   dasd_path_threshold_store);
+
+/*
+ * configure if path is disabled after IFCC/CCC error threshold is
+ * exceeded
+ */
+static ssize_t
+dasd_path_autodisable_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct dasd_devmap *devmap;
+	int flag;
+
+	devmap = dasd_find_busid(dev_name(dev));
+	if (!IS_ERR(devmap))
+		flag = (devmap->features & DASD_FEATURE_PATH_AUTODISABLE) != 0;
+	else
+		flag = (DASD_FEATURE_DEFAULT &
+			DASD_FEATURE_PATH_AUTODISABLE) != 0;
+	return snprintf(buf, PAGE_SIZE, flag ? "1\n" : "0\n");
+}
+
+static ssize_t
+dasd_path_autodisable_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	unsigned int val;
+	int rc;
+
+	if (kstrtouint(buf, 0, &val) || val > 1)
+		return -EINVAL;
+
+	rc = dasd_set_feature(to_ccwdev(dev),
+			      DASD_FEATURE_PATH_AUTODISABLE, val);
+
+	return rc ? : count;
+}
+
+static DEVICE_ATTR(path_autodisable, 0644,
+		   dasd_path_autodisable_show,
+		   dasd_path_autodisable_store);
 /*
  * interval for IFCC/CCC checks
  * meaning time with no IFCC/CCC error before the error counter
@@ -1544,6 +1584,7 @@ static struct attribute * dasd_attrs[] = {
 	&dev_attr_host_access_count.attr,
 	&dev_attr_path_masks.attr,
 	&dev_attr_path_threshold.attr,
+	&dev_attr_path_autodisable.attr,
 	&dev_attr_path_interval.attr,
 	&dev_attr_path_reset.attr,
 	&dev_attr_hpf.attr,
