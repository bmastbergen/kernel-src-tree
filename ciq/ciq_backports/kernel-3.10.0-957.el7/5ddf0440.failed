md/r5cache: handle sync with data in write back cache

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [md] r5cache: handle sync with data in write back cache (Nigel Croxon) [1494474]
Rebuild_FUZZ: 97.09%
commit-author Song Liu <songliubraving@fb.com>
commit 5ddf0440a1a28f00f69ed2e093476bab3b60c2c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5ddf0440.failed

Currently, sync of raid456 array cannot make progress when hitting
data in writeback r5cache.

This patch fixes this issue by flushing cached data of the stripe
before processing the sync request. This is achived by:

1. In handle_stripe(), do not set STRIPE_SYNCING if the stripe is
   in write back cache;
2. In r5c_try_caching_write(), handle the stripe in sync with write
   through;
3. In do_release_stripe(), make stripe in sync write out and send
   it to the state machine.

Shaohua: explictly set STRIPE_HANDLE after write out completed

	Signed-off-by: Song Liu <songliubraving@fb.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit 5ddf0440a1a28f00f69ed2e093476bab3b60c2c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid5-cache.c
diff --cc drivers/md/raid5-cache.c
index a6628b7c2270,4c00bc248287..000000000000
--- a/drivers/md/raid5-cache.c
+++ b/drivers/md/raid5-cache.c
@@@ -2422,17 -2803,53 +2425,60 @@@ void r5c_finish_stripe_write_out(struc
  	if (do_wakeup)
  		wake_up(&conf->wait_for_overlap);
  
 -	spin_lock_irq(&log->stripe_in_journal_lock);
 +	spin_lock_irq(&conf->log->stripe_in_journal_lock);
  	list_del_init(&sh->r5c);
 -	spin_unlock_irq(&log->stripe_in_journal_lock);
 +	spin_unlock_irq(&conf->log->stripe_in_journal_lock);
  	sh->log_start = MaxSector;
++<<<<<<< HEAD
 +	atomic_dec(&conf->log->stripe_in_journal_count);
 +	r5c_update_log_state(conf->log);
++=======
+ 
+ 	atomic_dec(&log->stripe_in_journal_count);
+ 	r5c_update_log_state(log);
+ 
+ 	/* stop counting this stripe in big_stripe_tree */
+ 	if (test_bit(STRIPE_R5C_PARTIAL_STRIPE, &sh->state) ||
+ 	    test_bit(STRIPE_R5C_FULL_STRIPE, &sh->state)) {
+ 		tree_index = r5c_tree_index(conf, sh->sector);
+ 		spin_lock(&log->tree_lock);
+ 		pslot = radix_tree_lookup_slot(&log->big_stripe_tree,
+ 					       tree_index);
+ 		BUG_ON(pslot == NULL);
+ 		refcount = (uintptr_t)radix_tree_deref_slot_protected(
+ 			pslot, &log->tree_lock) >>
+ 			R5C_RADIX_COUNT_SHIFT;
+ 		if (refcount == 1)
+ 			radix_tree_delete(&log->big_stripe_tree, tree_index);
+ 		else
+ 			radix_tree_replace_slot(
+ 				&log->big_stripe_tree, pslot,
+ 				(void *)((refcount - 1) << R5C_RADIX_COUNT_SHIFT));
+ 		spin_unlock(&log->tree_lock);
+ 	}
+ 
+ 	if (test_and_clear_bit(STRIPE_R5C_PARTIAL_STRIPE, &sh->state)) {
+ 		BUG_ON(atomic_read(&conf->r5c_cached_partial_stripes) == 0);
+ 		atomic_dec(&conf->r5c_flushing_partial_stripes);
+ 		atomic_dec(&conf->r5c_cached_partial_stripes);
+ 	}
+ 
+ 	if (test_and_clear_bit(STRIPE_R5C_FULL_STRIPE, &sh->state)) {
+ 		BUG_ON(atomic_read(&conf->r5c_cached_full_stripes) == 0);
+ 		atomic_dec(&conf->r5c_flushing_full_stripes);
+ 		atomic_dec(&conf->r5c_cached_full_stripes);
+ 	}
+ 
+ 	r5l_append_flush_payload(log, sh->sector);
+ 	/* stripe is flused to raid disks, we can do resync now */
+ 	if (test_bit(STRIPE_SYNC_REQUESTED, &sh->state))
+ 		set_bit(STRIPE_HANDLE, &sh->state);
++>>>>>>> 5ddf0440a1a2 (md/r5cache: handle sync with data in write back cache)
  }
  
 -int r5c_cache_data(struct r5l_log *log, struct stripe_head *sh)
 +int
 +r5c_cache_data(struct r5l_log *log, struct stripe_head *sh,
 +	       struct stripe_head_state *s)
  {
  	struct r5conf *conf = sh->raid_conf;
  	int pages = 0;
* Unmerged path drivers/md/raid5-cache.c
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index 1b3c1d5171eb..4c1b1d47aec0 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -241,11 +241,15 @@ static void do_release_stripe(struct r5conf *conf, struct stripe_head *sh,
 			if (test_bit(R5_InJournal, &sh->dev[i].flags))
 				injournal++;
 	/*
-	 * When quiesce in r5c write back, set STRIPE_HANDLE for stripes with
-	 * data in journal, so they are not released to cached lists
+	 * In the following cases, the stripe cannot be released to cached
+	 * lists. Therefore, we make the stripe write out and set
+	 * STRIPE_HANDLE:
+	 *   1. when quiesce in r5c write back;
+	 *   2. when resync is requested fot the stripe.
 	 */
-	if (conf->quiesce && r5c_is_writeback(conf->log) &&
-	    !test_bit(STRIPE_HANDLE, &sh->state) && injournal != 0) {
+	if (test_bit(STRIPE_SYNC_REQUESTED, &sh->state) ||
+	    (conf->quiesce && r5c_is_writeback(conf->log) &&
+	     !test_bit(STRIPE_HANDLE, &sh->state) && injournal != 0)) {
 		if (test_bit(STRIPE_R5C_CACHING, &sh->state))
 			r5c_make_stripe_write_out(sh);
 		set_bit(STRIPE_HANDLE, &sh->state);
@@ -4578,8 +4582,13 @@ static void handle_stripe(struct stripe_head *sh)
 
 	if (test_bit(STRIPE_SYNC_REQUESTED, &sh->state) && !sh->batch_head) {
 		spin_lock(&sh->stripe_lock);
-		/* Cannot process 'sync' concurrently with 'discard' */
-		if (!test_bit(STRIPE_DISCARD, &sh->state) &&
+		/*
+		 * Cannot process 'sync' concurrently with 'discard'.
+		 * Flush data in r5cache before 'sync'.
+		 */
+		if (!test_bit(STRIPE_R5C_PARTIAL_STRIPE, &sh->state) &&
+		    !test_bit(STRIPE_R5C_FULL_STRIPE, &sh->state) &&
+		    !test_bit(STRIPE_DISCARD, &sh->state) &&
 		    test_and_clear_bit(STRIPE_SYNC_REQUESTED, &sh->state)) {
 			set_bit(STRIPE_SYNCING, &sh->state);
 			clear_bit(STRIPE_INSYNC, &sh->state);
