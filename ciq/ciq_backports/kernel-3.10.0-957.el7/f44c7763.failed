fs, dax: prepare for dax-specific address_space_operations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit f44c77630d26ca2c2a60b20c47dd9ce07c4361b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f44c7763.failed

In preparation for the dax implementation to start associating dax pages
to inodes via page->mapping, we need to provide a 'struct
address_space_operations' instance for dax. Define some generic VFS aops
helpers for dax. These noop implementations are there in the dax case to
prevent the VFS from falling back to operations with page-cache
assumptions, dax_writeback_mapping_range() may not be referenced in the
FS_DAX=n case.

	Cc: Jeff Moyer <jmoyer@redhat.com>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Suggested-by: Matthew Wilcox <mawilcox@microsoft.com>
	Suggested-by: Jan Kara <jack@suse.cz>
	Suggested-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Suggested-by: Dave Chinner <david@fromorbit.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit f44c77630d26ca2c2a60b20c47dd9ce07c4361b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/libfs.c
#	include/linux/dax.h
diff --cc fs/libfs.c
index 19ee56594b1f,0fb590d79f30..000000000000
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@@ -1014,14 -1060,51 +1014,58 @@@ int noop_fsync(struct file *file, loff_
  }
  EXPORT_SYMBOL(noop_fsync);
  
++<<<<<<< HEAD
 +void kfree_put_link(struct dentry *dentry, struct nameidata *nd,
 +				void *cookie)
++=======
+ int noop_set_page_dirty(struct page *page)
+ {
+ 	/*
+ 	 * Unlike __set_page_dirty_no_writeback that handles dirty page
+ 	 * tracking in the page object, dax does all dirty tracking in
+ 	 * the inode address_space in response to mkwrite faults. In the
+ 	 * dax case we only need to worry about potentially dirty CPU
+ 	 * caches, not dirty page cache pages to write back.
+ 	 *
+ 	 * This callback is defined to prevent fallback to
+ 	 * __set_page_dirty_buffers() in set_page_dirty().
+ 	 */
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(noop_set_page_dirty);
+ 
+ void noop_invalidatepage(struct page *page, unsigned int offset,
+ 		unsigned int length)
+ {
+ 	/*
+ 	 * There is no page cache to invalidate in the dax case, however
+ 	 * we need this callback defined to prevent falling back to
+ 	 * block_invalidatepage() in do_invalidatepage().
+ 	 */
+ }
+ EXPORT_SYMBOL_GPL(noop_invalidatepage);
+ 
+ ssize_t noop_direct_IO(struct kiocb *iocb, struct iov_iter *iter)
+ {
+ 	/*
+ 	 * iomap based filesystems support direct I/O without need for
+ 	 * this callback. However, it still needs to be set in
+ 	 * inode->a_ops so that open/fcntl know that direct I/O is
+ 	 * generally supported.
+ 	 */
+ 	return -EINVAL;
+ }
+ EXPORT_SYMBOL_GPL(noop_direct_IO);
+ 
+ /* Because kfree isn't assignment-compatible with void(void*) ;-/ */
+ void kfree_link(void *p)
++>>>>>>> f44c77630d26 (fs, dax: prepare for dax-specific address_space_operations)
  {
 -	kfree(p);
 +	char *s = nd_get_link(nd);
 +	if (!IS_ERR(s))
 +		kfree(s);
  }
 -EXPORT_SYMBOL(kfree_link);
 +EXPORT_SYMBOL(kfree_put_link);
  
  /*
   * nop .set_page_dirty method so that people can use .page_mkwrite on
diff --cc include/linux/dax.h
index b7b81d6cc271,ae27a7efe7ab..000000000000
--- a/include/linux/dax.h
+++ b/include/linux/dax.h
@@@ -76,6 -38,55 +76,58 @@@ static inline void put_dax(struct dax_d
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ struct writeback_control;
+ int bdev_dax_pgoff(struct block_device *, sector_t, size_t, pgoff_t *pgoff);
+ #if IS_ENABLED(CONFIG_FS_DAX)
+ int __bdev_dax_supported(struct super_block *sb, int blocksize);
+ static inline int bdev_dax_supported(struct super_block *sb, int blocksize)
+ {
+ 	return __bdev_dax_supported(sb, blocksize);
+ }
+ 
+ static inline struct dax_device *fs_dax_get_by_host(const char *host)
+ {
+ 	return dax_get_by_host(host);
+ }
+ 
+ static inline void fs_put_dax(struct dax_device *dax_dev)
+ {
+ 	put_dax(dax_dev);
+ }
+ 
+ struct dax_device *fs_dax_get_by_bdev(struct block_device *bdev);
+ int dax_writeback_mapping_range(struct address_space *mapping,
+ 		struct block_device *bdev, struct writeback_control *wbc);
+ #else
+ static inline int bdev_dax_supported(struct super_block *sb, int blocksize)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline struct dax_device *fs_dax_get_by_host(const char *host)
+ {
+ 	return NULL;
+ }
+ 
+ static inline void fs_put_dax(struct dax_device *dax_dev)
+ {
+ }
+ 
+ static inline struct dax_device *fs_dax_get_by_bdev(struct block_device *bdev)
+ {
+ 	return NULL;
+ }
+ 
+ static inline int dax_writeback_mapping_range(struct address_space *mapping,
+ 		struct block_device *bdev, struct writeback_control *wbc)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ #endif
+ 
++>>>>>>> f44c77630d26 (fs, dax: prepare for dax-specific address_space_operations)
  int dax_read_lock(void);
  void dax_read_unlock(int id);
  struct dax_device *alloc_dax(void *private, const char *host,
* Unmerged path fs/libfs.c
* Unmerged path include/linux/dax.h
diff --git a/include/linux/fs.h b/include/linux/fs.h
index e3bcdb55c057..42210abf646e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3131,6 +3131,10 @@ extern int simple_unlink(struct inode *, struct dentry *);
 extern int simple_rmdir(struct inode *, struct dentry *);
 extern int simple_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
 extern int noop_fsync(struct file *, loff_t, loff_t, int);
+extern int noop_set_page_dirty(struct page *page);
+extern void noop_invalidatepage(struct page *page, unsigned int offset,
+		unsigned int length);
+extern ssize_t noop_direct_IO(struct kiocb *iocb, struct iov_iter *iter);
 extern int simple_empty(struct dentry *);
 extern int simple_readpage(struct file *file, struct page *page);
 extern int simple_write_begin(struct file *file, struct address_space *mapping,
