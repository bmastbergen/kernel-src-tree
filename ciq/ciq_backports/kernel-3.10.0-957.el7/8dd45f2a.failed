vmbus: refactor hv_signal_on_read

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Stephen Hemminger <stephen@networkplumber.org>
commit 8dd45f2ab005a1f3301296059b23b03ec3dbf79b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8dd45f2a.failed

The function hv_signal_on_read was defined in hyperv.h and
only used in one place in ring_buffer code. Clearer to just
move it inline there.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 8dd45f2ab005a1f3301296059b23b03ec3dbf79b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/ring_buffer.c
#	include/linux/hyperv.h
diff --cc drivers/hv/ring_buffer.c
index 480f1a09972c,a9021f13379f..000000000000
--- a/drivers/hv/ring_buffer.c
+++ b/drivers/hv/ring_buffer.c
@@@ -464,8 -358,8 +465,13 @@@ struct vmpacket_descriptor *hv_pkt_iter
  {
  	struct hv_ring_buffer_info *rbi = &channel->inbound;
  
++<<<<<<< HEAD
 +	/* set state for later hv_signal_on_read() */
 +	init_cached_read_index(rbi);
++=======
+ 	/* set state for later hv_pkt_iter_close */
+ 	rbi->cached_read_index = rbi->ring_buffer->read_index;
++>>>>>>> 8dd45f2ab005 (vmbus: refactor hv_signal_on_read)
  
  	if (hv_pkt_iter_avail(rbi) < sizeof(struct vmpacket_descriptor))
  		return NULL;
diff --cc include/linux/hyperv.h
index 24e1840de3ae,308e1f9706bb..000000000000
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@@ -1431,55 -1472,6 +1431,58 @@@ hv_get_ring_buffer(const struct hv_ring
  }
  
  /*
++<<<<<<< HEAD
 + * To optimize the flow management on the send-side,
 + * when the sender is blocked because of lack of
 + * sufficient space in the ring buffer, potential the
 + * consumer of the ring buffer can signal the producer.
 + * This is controlled by the following parameters:
 + *
 + * 1. pending_send_sz: This is the size in bytes that the
 + *    producer is trying to send.
 + * 2. The feature bit feat_pending_send_sz set to indicate if
 + *    the consumer of the ring will signal when the ring
 + *    state transitions from being full to a state where
 + *    there is room for the producer to send the pending packet.
 + */
 +
 +static inline  void hv_signal_on_read(struct vmbus_channel *channel)
 +{
 +	u32 cur_write_sz, cached_write_sz;
 +	u32 pending_sz;
 +	struct hv_ring_buffer_info *rbi = &channel->inbound;
 +
 +	/*
 +	 * Issue a full memory barrier before making the signaling decision.
 +	 * Here is the reason for having this barrier:
 +	 * If the reading of the pend_sz (in this function)
 +	 * were to be reordered and read before we commit the new read
 +	 * index (in the calling function)  we could
 +	 * have a problem. If the host were to set the pending_sz after we
 +	 * have sampled pending_sz and go to sleep before we commit the
 +	 * read index, we could miss sending the interrupt. Issue a full
 +	 * memory barrier to address this.
 +	 */
 +	mb();
 +
 +	pending_sz = READ_ONCE(rbi->ring_buffer->pending_send_sz);
 +	/* If the other end is not blocked on write don't bother. */
 +	if (pending_sz == 0)
 +		return;
 +
 +	cur_write_sz = hv_get_bytes_to_write(rbi);
 +
 +	if (cur_write_sz < pending_sz)
 +		return;
 +
 +	cached_write_sz = hv_get_cached_bytes_to_write(rbi);
 +	if (cached_write_sz < pending_sz)
 +		vmbus_setevent(channel);
 +}
 +
 +/*
++=======
++>>>>>>> 8dd45f2ab005 (vmbus: refactor hv_signal_on_read)
   * Mask off host interrupt callback notifications
   */
  static inline void hv_begin_read(struct hv_ring_buffer_info *rbi)
* Unmerged path drivers/hv/ring_buffer.c
* Unmerged path include/linux/hyperv.h
