netfilter: ipset: add markmask for hash:ip,mark data type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] netfilter: ipset: add markmask for hash:ip, mark data type (Stefano Brivio) [1557599]
Rebuild_FUZZ: 99.13%
commit-author Vytas Dauksa <vytas.dauksa@smoothwall.net>
commit 4d0e5c076d01d3fb4767a502a9517923fb9a080e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4d0e5c07.failed

Introduce packet mark mask for hash:ip,mark data type. This allows to
set mark bit filter for the ip set.

Change-Id: Id8dd9ca7e64477c4f7b022a1d9c1a5b187f1c96e

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 4d0e5c076d01d3fb4767a502a9517923fb9a080e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_hash_gen.h
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 72686abe715e,b1eed81e24c5..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -271,9 -263,9 +271,15 @@@ struct htype 
  	u32 maxelem;		/* max elements in the hash */
  	u32 elements;		/* current element (vs timeout) */
  	u32 initval;		/* random jhash init value */
++<<<<<<< HEAD
 +	u32 timeout;		/* timeout value, if enabled */
 +	size_t dsize;		/* data struct size */
 +	size_t offset[IPSET_EXT_ID_MAX]; /* Offsets to extensions */
++=======
+ #ifdef IP_SET_HASH_WITH_MARKMASK
+ 	u32 markmask;		/* markmask value for mark mask to store */
+ #endif
++>>>>>>> 4d0e5c076d01 (netfilter: ipset: add markmask for hash:ip,mark data type)
  	struct timer_list gc;	/* garbage collection when timeout enabled */
  	struct mtype_elem next; /* temporary storage for uadd */
  #ifdef IP_SET_HASH_WITH_MULTI
@@@ -426,9 -453,12 +432,12 @@@ mtype_same_set(const struct ip_set *a, 
  
  	/* Resizing changes htable_bits, so we ignore it */
  	return x->maxelem == y->maxelem &&
 -	       a->timeout == b->timeout &&
 +	       x->timeout == y->timeout &&
  #ifdef IP_SET_HASH_WITH_NETMASK
  	       x->netmask == y->netmask &&
+ #endif
+ #ifdef IP_SET_HASH_WITH_MARKMASK
+ 	       x->markmask == y->markmask &&
  #endif
  	       a->extensions == b->extensions;
  }
@@@ -833,13 -914,14 +842,24 @@@ mtype_head(struct ip_set *set, struct s
  	    nla_put_u8(skb, IPSET_ATTR_NETMASK, h->netmask))
  		goto nla_put_failure;
  #endif
++<<<<<<< HEAD
 +	if (nla_put_net32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref)) ||
 +	    nla_put_net32(skb, IPSET_ATTR_MEMSIZE, htonl(memsize)) ||
 +	    ((set->extensions & IPSET_EXT_TIMEOUT) &&
 +	     nla_put_net32(skb, IPSET_ATTR_TIMEOUT, htonl(h->timeout))) ||
 +	    ((set->extensions & IPSET_EXT_COUNTER) &&
 +	     nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS,
 +			   htonl(IPSET_FLAG_WITH_COUNTERS))))
++=======
+ #ifdef IP_SET_HASH_WITH_MARKMASK
+ 	if (nla_put_u32(skb, IPSET_ATTR_MARKMASK, h->markmask))
+ 		goto nla_put_failure;
+ #endif
+ 	if (nla_put_net32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref - 1)) ||
+ 	    nla_put_net32(skb, IPSET_ATTR_MEMSIZE, htonl(memsize)))
+ 		goto nla_put_failure;
+ 	if (unlikely(ip_set_put_flags(skb, set)))
++>>>>>>> 4d0e5c076d01 (netfilter: ipset: add markmask for hash:ip,mark data type)
  		goto nla_put_failure;
  	ipset_nest_end(skb, nested);
  
@@@ -948,7 -1026,9 +968,13 @@@ IPSET_TOKEN(HTYPE, _create)(struct net 
  			    struct nlattr *tb[], u32 flags)
  {
  	u32 hashsize = IPSET_DEFAULT_HASHSIZE, maxelem = IPSET_DEFAULT_MAXELEM;
++<<<<<<< HEAD
 +	u32 cadt_flags = 0;
++=======
+ #ifdef IP_SET_HASH_WITH_MARKMASK
+ 	u32 markmask;
+ #endif
++>>>>>>> 4d0e5c076d01 (netfilter: ipset: add markmask for hash:ip,mark data type)
  	u8 hbits;
  #ifdef IP_SET_HASH_WITH_NETMASK
  	u8 netmask;
@@@ -1001,9 -1098,12 +1042,12 @@@
  	h->maxelem = maxelem;
  #ifdef IP_SET_HASH_WITH_NETMASK
  	h->netmask = netmask;
+ #endif
+ #ifdef IP_SET_HASH_WITH_MARKMASK
+ 	h->markmask = markmask;
  #endif
  	get_random_bytes(&h->initval, sizeof(h->initval));
 -	set->timeout = IPSET_NO_TIMEOUT;
 +	h->timeout = IPSET_NO_TIMEOUT;
  
  	hbits = htable_bits(hashsize);
  	hsize = htable_size(hbits);
diff --git a/include/uapi/linux/netfilter/ipset/ip_set.h b/include/uapi/linux/netfilter/ipset/ip_set.h
index 7f7d72410118..17c1fb65b913 100644
--- a/include/uapi/linux/netfilter/ipset/ip_set.h
+++ b/include/uapi/linux/netfilter/ipset/ip_set.h
@@ -87,6 +87,7 @@ enum {
 	IPSET_ATTR_GC,
 	IPSET_ATTR_HASHSIZE,
 	IPSET_ATTR_MAXELEM,
+	IPSET_ATTR_MARKMASK,
 	IPSET_ATTR_NETMASK,
 	IPSET_ATTR_PROBES,
 	IPSET_ATTR_RESIZE,
@@ -140,6 +141,7 @@ enum ipset_errno {
 	IPSET_ERR_EXIST,
 	IPSET_ERR_INVALID_CIDR,
 	IPSET_ERR_INVALID_NETMASK,
+	IPSET_ERR_INVALID_MARKMASK,
 	IPSET_ERR_INVALID_FAMILY,
 	IPSET_ERR_TIMEOUT,
 	IPSET_ERR_REFERENCED,
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
diff --git a/net/netfilter/ipset/ip_set_hash_ipmark.c b/net/netfilter/ipset/ip_set_hash_ipmark.c
index e56c0d916fac..1bf8e8524218 100644
--- a/net/netfilter/ipset/ip_set_hash_ipmark.c
+++ b/net/netfilter/ipset/ip_set_hash_ipmark.c
@@ -34,6 +34,7 @@ MODULE_ALIAS("ip_set_hash:ip,mark");
 
 /* Type specific function prefix */
 #define HTYPE		hash_ipmark
+#define IP_SET_HASH_WITH_MARKMASK
 
 /* IPv4 variant */
 
@@ -85,11 +86,13 @@ hash_ipmark4_kadt(struct ip_set *set, const struct sk_buff *skb,
 		  const struct xt_action_param *par,
 		  enum ipset_adt adt, struct ip_set_adt_opt *opt)
 {
+	const struct hash_ipmark *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_ipmark4_elem e = { };
 	struct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);
 
 	e.mark = skb->mark;
+	e.mark &= h->markmask;
 
 	ip4addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip);
 	return adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);
@@ -122,6 +125,7 @@ hash_ipmark4_uadt(struct ip_set *set, struct nlattr *tb[],
 		return ret;
 
 	e.mark = ntohl(nla_get_u32(tb[IPSET_ATTR_MARK]));
+	e.mark &= h->markmask;
 
 	if (adt == IPSET_TEST ||
 	    !(tb[IPSET_ATTR_IP_TO] || tb[IPSET_ATTR_CIDR])) {
@@ -213,11 +217,13 @@ hash_ipmark6_kadt(struct ip_set *set, const struct sk_buff *skb,
 		  const struct xt_action_param *par,
 		  enum ipset_adt adt, struct ip_set_adt_opt *opt)
 {
+	const struct hash_ipmark *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_ipmark6_elem e = { };
 	struct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);
 
 	e.mark = skb->mark;
+	e.mark &= h->markmask;
 
 	ip6addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip.in6);
 	return adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);
@@ -227,6 +233,7 @@ static int
 hash_ipmark6_uadt(struct ip_set *set, struct nlattr *tb[],
 		  enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
 {
+	const struct hash_ipmark *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_ipmark6_elem e = { };
 	struct ip_set_ext ext = IP_SET_INIT_UEXT(set);
@@ -250,6 +257,7 @@ hash_ipmark6_uadt(struct ip_set *set, struct nlattr *tb[],
 		return ret;
 
 	e.mark = ntohl(nla_get_u32(tb[IPSET_ATTR_MARK]));
+	e.mark &= h->markmask;
 
 	if (adt == IPSET_TEST) {
 		ret = adtfn(set, &e, &ext, &ext, flags);
@@ -275,6 +283,7 @@ static struct ip_set_type hash_ipmark_type __read_mostly = {
 	.revision_max	= IPSET_TYPE_REV_MAX,
 	.create		= hash_ipmark_create,
 	.create_policy	= {
+		[IPSET_ATTR_MARKMASK]	= { .type = NLA_U32 },
 		[IPSET_ATTR_HASHSIZE]	= { .type = NLA_U32 },
 		[IPSET_ATTR_MAXELEM]	= { .type = NLA_U32 },
 		[IPSET_ATTR_PROBES]	= { .type = NLA_U8 },
