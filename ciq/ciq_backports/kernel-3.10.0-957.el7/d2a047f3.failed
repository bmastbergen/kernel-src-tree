xfs: forbid AG btrees with level == 0

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit d2a047f31e86941fa896e0e3271536d50aba415e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d2a047f3.failed

There is no such thing as a zero-level AG btree since even a single-node
zero-records btree has one level.  Btree cursor constructors read
cur_nlevels straight from disk and then access things like
cur_bufs[cur_nlevels - 1] which is /really/ bad if cur_nlevels is zero!
Therefore, strengthen the verifiers to prevent this possibility.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit d2a047f31e86941fa896e0e3271536d50aba415e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_alloc.c
diff --cc fs/xfs/libxfs/xfs_alloc.c
index aacd02eca34b,5050056a0b06..000000000000
--- a/fs/xfs/libxfs/xfs_alloc.c
+++ b/fs/xfs/libxfs/xfs_alloc.c
@@@ -2275,6 -2461,11 +2277,14 @@@ xfs_agf_verify
  	    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) > XFS_BTREE_MAXLEVELS)
  		return false;
  
++<<<<<<< HEAD
++=======
+ 	if (xfs_sb_version_hasrmapbt(&mp->m_sb) &&
+ 	    (be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) < 1 ||
+ 	     be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) > XFS_BTREE_MAXLEVELS))
+ 		return false;
+ 
++>>>>>>> d2a047f31e86 (xfs: forbid AG btrees with level == 0)
  	/*
  	 * during growfs operations, the perag is not fully initialised,
  	 * so we can't use it for any useful checking. growfs ensures we can't
@@@ -2288,6 -2479,11 +2298,14 @@@
  	    be32_to_cpu(agf->agf_btreeblks) > be32_to_cpu(agf->agf_length))
  		return false;
  
++<<<<<<< HEAD
++=======
+ 	if (xfs_sb_version_hasreflink(&mp->m_sb) &&
+ 	    (be32_to_cpu(agf->agf_refcount_level) < 1 ||
+ 	     be32_to_cpu(agf->agf_refcount_level) > XFS_BTREE_MAXLEVELS))
+ 		return false;
+ 
++>>>>>>> d2a047f31e86 (xfs: forbid AG btrees with level == 0)
  	return true;;
  
  }
* Unmerged path fs/xfs/libxfs/xfs_alloc.c
diff --git a/fs/xfs/libxfs/xfs_ialloc.c b/fs/xfs/libxfs/xfs_ialloc.c
index ee0bf34bbf7e..8be17531b7c7 100644
--- a/fs/xfs/libxfs/xfs_ialloc.c
+++ b/fs/xfs/libxfs/xfs_ialloc.c
@@ -2506,8 +2506,15 @@ xfs_agi_verify(
 	if (!XFS_AGI_GOOD_VERSION(be32_to_cpu(agi->agi_versionnum)))
 		return false;
 
-	if (be32_to_cpu(agi->agi_level) > XFS_BTREE_MAXLEVELS)
+	if (be32_to_cpu(agi->agi_level) < 1 ||
+	    be32_to_cpu(agi->agi_level) > XFS_BTREE_MAXLEVELS)
 		return false;
+
+	if (xfs_sb_version_hasfinobt(&mp->m_sb) &&
+	    (be32_to_cpu(agi->agi_free_level) < 1 ||
+	     be32_to_cpu(agi->agi_free_level) > XFS_BTREE_MAXLEVELS))
+		return false;
+
 	/*
 	 * during growfs operations, the perag is not fully initialised,
 	 * so we can't use it for any useful checking. growfs ensures we can't
