i40e: move AUTO_DISABLED flags into the state field

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 134201aeadf3109ac9982ea81a79ec68442a07d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/134201ae.failed

The two Flow Directory auto disable flags are used at run time to mark
when the flow director features needed to be disabled. Thus the flags
could change even when the RTNL lock is not held.

They also have some code constructions which really should be
test_and_set or test_and_clear using atomic bit operations.

Create new state fields to mark this, and stop including them in
pf->flags.

This is part of a larger effort to remove the need for cmpxchg64 in
i40e_set_priv_flags().

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 134201aeadf3109ac9982ea81a79ec68442a07d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e.h
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e.h
index 1d5305235e57,38633563dacd..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@@ -461,37 -514,39 +463,73 @@@ struct i40e_pf 
  #define I40E_HW_RESTART_AUTONEG			BIT(18)
  #define I40E_HW_STOPPABLE_FW_LLDP		BIT(19)
  
++<<<<<<< HEAD
 +	u32 flags;
 +#define I40E_FLAG_RX_CSUM_ENABLED		BIT(0)
 +#define I40E_FLAG_MSI_ENABLED			BIT(1)
 +#define I40E_FLAG_MSIX_ENABLED			BIT(2)
 +#define I40E_FLAG_RSS_ENABLED			BIT(3)
 +#define I40E_FLAG_VMDQ_ENABLED			BIT(4)
 +#define I40E_FLAG_FILTER_SYNC			BIT(5)
 +#define I40E_FLAG_SRIOV_ENABLED			BIT(6)
 +#define I40E_FLAG_DCB_CAPABLE			BIT(7)
 +#define I40E_FLAG_DCB_ENABLED			BIT(8)
 +#define I40E_FLAG_FD_SB_ENABLED			BIT(9)
 +#define I40E_FLAG_FD_ATR_ENABLED		BIT(10)
 +#define I40E_FLAG_FD_SB_AUTO_DISABLED		BIT(11)
 +#define I40E_FLAG_FD_ATR_AUTO_DISABLED		BIT(12)
 +#define I40E_FLAG_MFP_ENABLED			BIT(13)
 +#define I40E_FLAG_UDP_FILTER_SYNC		BIT(14)
 +#define I40E_FLAG_HW_ATR_EVICT_ENABLED		BIT(15)
 +#define I40E_FLAG_VEB_MODE_ENABLED		BIT(16)
 +#define I40E_FLAG_VEB_STATS_ENABLED		BIT(17)
 +#define I40E_FLAG_LINK_POLLING_ENABLED		BIT(18)
 +#define I40E_FLAG_TRUE_PROMISC_SUPPORT		BIT(19)
 +#define I40E_FLAG_TEMP_LINK_POLLING		BIT(20)
 +#define I40E_FLAG_LEGACY_RX			BIT(21)
 +#define I40E_FLAG_PTP				BIT(22)
 +#define I40E_FLAG_IWARP_ENABLED			BIT(23)
 +#define I40E_FLAG_SERVICE_CLIENT_REQUESTED	BIT(24)
 +#define I40E_FLAG_CLIENT_L2_CHANGE		BIT(25)
 +#define I40E_FLAG_CLIENT_RESET			BIT(26)
 +#define I40E_FLAG_LINK_DOWN_ON_CLOSE_ENABLED	BIT(27)
 +#define I40E_FLAG_SOURCE_PRUNING_DISABLED	BIT(28)
 +#define I40E_FLAG_TC_MQPRIO			BIT(29)
++=======
+ 	u64 flags;
+ #define I40E_FLAG_RX_CSUM_ENABLED		BIT_ULL(0)
+ #define I40E_FLAG_MSI_ENABLED			BIT_ULL(1)
+ #define I40E_FLAG_MSIX_ENABLED			BIT_ULL(2)
+ #define I40E_FLAG_RSS_ENABLED			BIT_ULL(3)
+ #define I40E_FLAG_VMDQ_ENABLED			BIT_ULL(4)
+ /* Gap for BIT_ULL(5) */
+ #define I40E_FLAG_SRIOV_ENABLED			BIT_ULL(6)
+ #define I40E_FLAG_DCB_CAPABLE			BIT_ULL(7)
+ #define I40E_FLAG_DCB_ENABLED			BIT_ULL(8)
+ #define I40E_FLAG_FD_SB_ENABLED			BIT_ULL(9)
+ #define I40E_FLAG_FD_ATR_ENABLED		BIT_ULL(10)
+ /* Gap for BIT_ULL(11) and BIT_ULL(12) */
+ #define I40E_FLAG_MFP_ENABLED			BIT_ULL(13)
+ /* Gap for BIT_ULL(14) */
+ #define I40E_FLAG_HW_ATR_EVICT_ENABLED		BIT_ULL(15)
+ #define I40E_FLAG_VEB_MODE_ENABLED		BIT_ULL(16)
+ #define I40E_FLAG_VEB_STATS_ENABLED		BIT_ULL(17)
+ #define I40E_FLAG_LINK_POLLING_ENABLED		BIT_ULL(18)
+ #define I40E_FLAG_TRUE_PROMISC_SUPPORT		BIT_ULL(19)
+ #define I40E_FLAG_TEMP_LINK_POLLING		BIT_ULL(20)
+ #define I40E_FLAG_LEGACY_RX			BIT_ULL(21)
+ #define I40E_FLAG_PTP				BIT_ULL(22)
+ #define I40E_FLAG_IWARP_ENABLED			BIT_ULL(23)
+ #define I40E_FLAG_SERVICE_CLIENT_REQUESTED	BIT_ULL(24)
+ #define I40E_FLAG_CLIENT_L2_CHANGE		BIT_ULL(25)
+ #define I40E_FLAG_CLIENT_RESET			BIT_ULL(26)
+ #define I40E_FLAG_LINK_DOWN_ON_CLOSE_ENABLED	BIT_ULL(27)
+ #define I40E_FLAG_SOURCE_PRUNING_DISABLED	BIT_ULL(28)
+ #define I40E_FLAG_TC_MQPRIO			BIT_ULL(29)
+ #define I40E_FLAG_FD_SB_INACTIVE		BIT_ULL(30)
+ #define I40E_FLAG_FD_SB_TO_CLOUD_FILTER		BIT_ULL(31)
+ #define I40E_FLAG_DISABLE_FW_LLDP		BIT_ULL(32)
++>>>>>>> 134201aeadf3 (i40e: move AUTO_DISABLED flags into the state field)
  
  	struct i40e_client_instance *cinst;
  	bool stat_offsets_loaded;
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 9299aa15ffea,a478153818bc..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -10363,8 -11288,10 +10360,15 @@@ bool i40e_set_ntuple(struct i40e_pf *pf
  			need_reset = true;
  			i40e_fdir_filter_exit(pf);
  		}
++<<<<<<< HEAD
 +		pf->flags &= ~(I40E_FLAG_FD_SB_ENABLED |
 +			       I40E_FLAG_FD_SB_AUTO_DISABLED);
++=======
+ 		pf->flags &= ~I40E_FLAG_FD_SB_ENABLED;
+ 		clear_bit(__I40E_FD_SB_AUTO_DISABLED, pf->state);
+ 		pf->flags |= I40E_FLAG_FD_SB_INACTIVE;
+ 
++>>>>>>> 134201aeadf3 (i40e: move AUTO_DISABLED flags into the state field)
  		/* reset fd counters */
  		pf->fd_add_err = 0;
  		pf->fd_atr_cnt = 0;
* Unmerged path drivers/net/ethernet/intel/i40e/i40e.h
diff --git a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index d1640cbf01f3..bc5d82ff620e 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@ -3856,7 +3856,7 @@ static int i40e_add_fdir_ethtool(struct i40e_vsi *vsi,
 	if (!(pf->flags & I40E_FLAG_FD_SB_ENABLED))
 		return -EOPNOTSUPP;
 
-	if (pf->flags & I40E_FLAG_FD_SB_AUTO_DISABLED)
+	if (test_bit(__I40E_FD_SB_AUTO_DISABLED, pf->state))
 		return -ENOSPC;
 
 	if (test_bit(__I40E_RESET_RECOVERY_PENDING, pf->state) ||
@@ -4365,7 +4365,7 @@ flags_complete:
 	/* Flush current ATR settings if ATR was disabled */
 	if ((changed_flags & I40E_FLAG_FD_ATR_ENABLED) &&
 	    !(pf->flags & I40E_FLAG_FD_ATR_ENABLED)) {
-		pf->flags |= I40E_FLAG_FD_ATR_AUTO_DISABLED;
+		set_bit(__I40E_FD_ATR_AUTO_DISABLED, pf->state);
 		set_bit(__I40E_FD_FLUSH_REQUESTED, pf->state);
 	}
 
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_txrx.c b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
index d6a622ef9c0e..a34e2c37e6fb 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@ -334,7 +334,7 @@ static int i40e_add_del_fdir_tcpv4(struct i40e_vsi *vsi,
 		if ((pf->flags & I40E_FLAG_FD_ATR_ENABLED) &&
 		    I40E_DEBUG_FD & pf->hw.debug_mask)
 			dev_info(&pf->pdev->dev, "Forcing ATR off, sideband rules for TCP/IPv4 flow being applied\n");
-		pf->flags |= I40E_FLAG_FD_ATR_AUTO_DISABLED;
+		set_bit(__I40E_FD_ATR_AUTO_DISABLED, pf->state);
 	} else {
 		pf->fd_tcp4_filter_cnt--;
 	}
@@ -592,8 +592,14 @@ static void i40e_fd_handle_status(struct i40e_ring *rx_ring,
 		pf->fd_atr_cnt = i40e_get_current_atr_cnt(pf);
 
 		if ((rx_desc->wb.qword0.hi_dword.fd_id == 0) &&
-		    pf->flags & I40E_FLAG_FD_SB_AUTO_DISABLED) {
-			pf->flags |= I40E_FLAG_FD_ATR_AUTO_DISABLED;
+		    test_bit(__I40E_FD_SB_AUTO_DISABLED, pf->state)) {
+			/* These set_bit() calls aren't atomic with the
+			 * test_bit() here, but worse case we potentially
+			 * disable ATR and queue a flush right after SB
+			 * support is re-enabled. That shouldn't cause an
+			 * issue in practice
+			 */
+			set_bit(__I40E_FD_ATR_AUTO_DISABLED, pf->state);
 			set_bit(__I40E_FD_FLUSH_REQUESTED, pf->state);
 		}
 
@@ -606,11 +612,10 @@ static void i40e_fd_handle_status(struct i40e_ring *rx_ring,
 		 */
 		if (fcnt_prog >= (fcnt_avail - I40E_FDIR_BUFFER_FULL_MARGIN)) {
 			if ((pf->flags & I40E_FLAG_FD_SB_ENABLED) &&
-			    !(pf->flags & I40E_FLAG_FD_SB_AUTO_DISABLED)) {
-				pf->flags |= I40E_FLAG_FD_SB_AUTO_DISABLED;
+			    !test_and_set_bit(__I40E_FD_SB_AUTO_DISABLED,
+					      pf->state))
 				if (I40E_DEBUG_FD & pf->hw.debug_mask)
 					dev_warn(&pdev->dev, "FD filter space full, new ntuple rules will not be added\n");
-			}
 		}
 	} else if (error == BIT(I40E_RX_PROG_STATUS_DESC_NO_FD_ENTRY_SHIFT)) {
 		if (I40E_DEBUG_FD & pf->hw.debug_mask)
@@ -2391,7 +2396,7 @@ static void i40e_atr(struct i40e_ring *tx_ring, struct sk_buff *skb,
 	if (!(pf->flags & I40E_FLAG_FD_ATR_ENABLED))
 		return;
 
-	if (pf->flags & I40E_FLAG_FD_ATR_AUTO_DISABLED)
+	if (test_bit(__I40E_FD_ATR_AUTO_DISABLED, pf->state))
 		return;
 
 	/* if sampling is disabled do nothing */
@@ -2431,7 +2436,7 @@ static void i40e_atr(struct i40e_ring *tx_ring, struct sk_buff *skb,
 	th = (struct tcphdr *)(hdr.network + hlen);
 
 	/* Due to lack of space, no more new filters can be programmed */
-	if (th->syn && (pf->flags & I40E_FLAG_FD_ATR_AUTO_DISABLED))
+	if (th->syn && test_bit(__I40E_FD_ATR_AUTO_DISABLED, pf->state))
 		return;
 	if (pf->flags & I40E_FLAG_HW_ATR_EVICT_ENABLED) {
 		/* HW ATR eviction will take care of removing filters on FIN
