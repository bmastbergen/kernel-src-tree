dax: fix vma_is_fsdax() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit 230f5a8969d8345fc9bbe3683f068246cf1be4b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/230f5a89.failed

Gerd reports that ->i_mode may contain other bits besides S_IFCHR. Use
S_ISCHR() instead. Otherwise, get_user_pages_longterm() may fail on
device-dax instances when those are meant to be explicitly allowed.

Fixes: 2bb6d2837083 ("mm: introduce get_user_pages_longterm")
	Cc: <stable@vger.kernel.org>
	Reported-by: Gerd Rausch <gerd.rausch@oracle.com>
	Acked-by: Jane Chu <jane.chu@oracle.com>
	Reported-by: Haozhong Zhang <haozhong.zhang@intel.com>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 230f5a8969d8345fc9bbe3683f068246cf1be4b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/fs.h
diff --cc include/linux/fs.h
index e3bcdb55c057,79c413985305..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -3192,6 -3189,55 +3192,58 @@@ static inline bool vma_is_dax(struct vm
  	return vma->vm_file && IS_DAX(vma->vm_file->f_mapping->host);
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool vma_is_fsdax(struct vm_area_struct *vma)
+ {
+ 	struct inode *inode;
+ 
+ 	if (!vma->vm_file)
+ 		return false;
+ 	if (!vma_is_dax(vma))
+ 		return false;
+ 	inode = file_inode(vma->vm_file);
+ 	if (S_ISCHR(inode->i_mode))
+ 		return false; /* device-dax */
+ 	return true;
+ }
+ 
+ static inline int iocb_flags(struct file *file)
+ {
+ 	int res = 0;
+ 	if (file->f_flags & O_APPEND)
+ 		res |= IOCB_APPEND;
+ 	if (io_is_direct(file))
+ 		res |= IOCB_DIRECT;
+ 	if ((file->f_flags & O_DSYNC) || IS_SYNC(file->f_mapping->host))
+ 		res |= IOCB_DSYNC;
+ 	if (file->f_flags & __O_SYNC)
+ 		res |= IOCB_SYNC;
+ 	return res;
+ }
+ 
+ static inline int kiocb_set_rw_flags(struct kiocb *ki, rwf_t flags)
+ {
+ 	if (unlikely(flags & ~RWF_SUPPORTED))
+ 		return -EOPNOTSUPP;
+ 
+ 	if (flags & RWF_NOWAIT) {
+ 		if (!(ki->ki_filp->f_mode & FMODE_NOWAIT))
+ 			return -EOPNOTSUPP;
+ 		ki->ki_flags |= IOCB_NOWAIT;
+ 	}
+ 	if (flags & RWF_HIPRI)
+ 		ki->ki_flags |= IOCB_HIPRI;
+ 	if (flags & RWF_DSYNC)
+ 		ki->ki_flags |= IOCB_DSYNC;
+ 	if (flags & RWF_SYNC)
+ 		ki->ki_flags |= (IOCB_DSYNC | IOCB_SYNC);
+ 	if (flags & RWF_APPEND)
+ 		ki->ki_flags |= IOCB_APPEND;
+ 	return 0;
+ }
+ 
++>>>>>>> 230f5a8969d8 (dax: fix vma_is_fsdax() helper)
  static inline ino_t parent_ino(struct dentry *dentry)
  {
  	ino_t res;
* Unmerged path include/linux/fs.h
