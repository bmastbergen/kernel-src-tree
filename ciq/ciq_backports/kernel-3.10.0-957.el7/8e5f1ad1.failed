seccomp: Sysctl to display available actions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Tyler Hicks <tyhicks@canonical.com>
commit 8e5f1ad116df6b0de65eac458d5e7c318d1c05af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8e5f1ad1.failed

This patch creates a read-only sysctl containing an ordered list of
seccomp actions that the kernel supports. The ordering, from left to
right, is the lowest action value (kill) to the highest action value
(allow). Currently, a read of the sysctl file would return "kill trap
errno trace allow". The contents of this sysctl file can be useful for
userspace code as well as the system administrator.

The path to the sysctl is:

  /proc/sys/kernel/seccomp/actions_avail

libseccomp and other userspace code can easily determine which actions
the current kernel supports. The set of actions supported by the current
kernel may be different than the set of action macros found in kernel
headers that were installed where the userspace code was built.

In addition, this sysctl will allow system administrators to know which
actions are supported by the kernel and make it easier to configure
exactly what seccomp logs through the audit subsystem. Support for this
level of logging configuration will come in a future patch.

	Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
	Signed-off-by: Kees Cook <keescook@chromium.org>
(cherry picked from commit 8e5f1ad116df6b0de65eac458d5e7c318d1c05af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/seccomp.c
diff --cc kernel/seccomp.c
index 42e55449c1a5,5f19f41e4e50..000000000000
--- a/kernel/seccomp.c
+++ b/kernel/seccomp.c
@@@ -13,18 -13,23 +13,24 @@@
   *        of Berkeley Packet Filters/Linux Socket Filters.
   */
  
 -#include <linux/refcount.h>
 +#include <linux/atomic.h>
  #include <linux/audit.h>
  #include <linux/compat.h>
++<<<<<<< HEAD
++=======
+ #include <linux/coredump.h>
+ #include <linux/kmemleak.h>
++>>>>>>> 8e5f1ad116df (seccomp: Sysctl to display available actions)
  #include <linux/sched.h>
 -#include <linux/sched/task_stack.h>
  #include <linux/seccomp.h>
  #include <linux/slab.h>
  #include <linux/syscalls.h>
+ #include <linux/sysctl.h>
  
 -#ifdef CONFIG_HAVE_ARCH_SECCOMP_FILTER
 -#include <asm/syscall.h>
 -#endif
 +/* #define SECCOMP_DEBUG 1 */
  
  #ifdef CONFIG_SECCOMP_FILTER
 +#include <asm/syscall.h>
  #include <linux/filter.h>
  #include <linux/pid.h>
  #include <linux/ptrace.h>
@@@ -805,3 -863,125 +811,128 @@@ long prctl_set_seccomp(unsigned long se
  	/* prctl interface doesn't have flags, so they are always zero. */
  	return do_seccomp(op, 0, uargs);
  }
++<<<<<<< HEAD
++=======
+ 
+ #if defined(CONFIG_SECCOMP_FILTER) && defined(CONFIG_CHECKPOINT_RESTORE)
+ long seccomp_get_filter(struct task_struct *task, unsigned long filter_off,
+ 			void __user *data)
+ {
+ 	struct seccomp_filter *filter;
+ 	struct sock_fprog_kern *fprog;
+ 	long ret;
+ 	unsigned long count = 0;
+ 
+ 	if (!capable(CAP_SYS_ADMIN) ||
+ 	    current->seccomp.mode != SECCOMP_MODE_DISABLED) {
+ 		return -EACCES;
+ 	}
+ 
+ 	spin_lock_irq(&task->sighand->siglock);
+ 	if (task->seccomp.mode != SECCOMP_MODE_FILTER) {
+ 		ret = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	filter = task->seccomp.filter;
+ 	while (filter) {
+ 		filter = filter->prev;
+ 		count++;
+ 	}
+ 
+ 	if (filter_off >= count) {
+ 		ret = -ENOENT;
+ 		goto out;
+ 	}
+ 	count -= filter_off;
+ 
+ 	filter = task->seccomp.filter;
+ 	while (filter && count > 1) {
+ 		filter = filter->prev;
+ 		count--;
+ 	}
+ 
+ 	if (WARN_ON(count != 1 || !filter)) {
+ 		/* The filter tree shouldn't shrink while we're using it. */
+ 		ret = -ENOENT;
+ 		goto out;
+ 	}
+ 
+ 	fprog = filter->prog->orig_prog;
+ 	if (!fprog) {
+ 		/* This must be a new non-cBPF filter, since we save
+ 		 * every cBPF filter's orig_prog above when
+ 		 * CONFIG_CHECKPOINT_RESTORE is enabled.
+ 		 */
+ 		ret = -EMEDIUMTYPE;
+ 		goto out;
+ 	}
+ 
+ 	ret = fprog->len;
+ 	if (!data)
+ 		goto out;
+ 
+ 	get_seccomp_filter(task);
+ 	spin_unlock_irq(&task->sighand->siglock);
+ 
+ 	if (copy_to_user(data, fprog->filter, bpf_classic_proglen(fprog)))
+ 		ret = -EFAULT;
+ 
+ 	put_seccomp_filter(task);
+ 	return ret;
+ 
+ out:
+ 	spin_unlock_irq(&task->sighand->siglock);
+ 	return ret;
+ }
+ #endif
+ 
+ #ifdef CONFIG_SYSCTL
+ 
+ /* Human readable action names for friendly sysctl interaction */
+ #define SECCOMP_RET_KILL_NAME		"kill"
+ #define SECCOMP_RET_TRAP_NAME		"trap"
+ #define SECCOMP_RET_ERRNO_NAME		"errno"
+ #define SECCOMP_RET_TRACE_NAME		"trace"
+ #define SECCOMP_RET_ALLOW_NAME		"allow"
+ 
+ static const char seccomp_actions_avail[] = SECCOMP_RET_KILL_NAME	" "
+ 					    SECCOMP_RET_TRAP_NAME	" "
+ 					    SECCOMP_RET_ERRNO_NAME	" "
+ 					    SECCOMP_RET_TRACE_NAME	" "
+ 					    SECCOMP_RET_ALLOW_NAME;
+ 
+ static struct ctl_path seccomp_sysctl_path[] = {
+ 	{ .procname = "kernel", },
+ 	{ .procname = "seccomp", },
+ 	{ }
+ };
+ 
+ static struct ctl_table seccomp_sysctl_table[] = {
+ 	{
+ 		.procname	= "actions_avail",
+ 		.data		= (void *) &seccomp_actions_avail,
+ 		.maxlen		= sizeof(seccomp_actions_avail),
+ 		.mode		= 0444,
+ 		.proc_handler	= proc_dostring,
+ 	},
+ 	{ }
+ };
+ 
+ static int __init seccomp_sysctl_init(void)
+ {
+ 	struct ctl_table_header *hdr;
+ 
+ 	hdr = register_sysctl_paths(seccomp_sysctl_path, seccomp_sysctl_table);
+ 	if (!hdr)
+ 		pr_warn("seccomp: sysctl registration failed\n");
+ 	else
+ 		kmemleak_not_leak(hdr);
+ 
+ 	return 0;
+ }
+ 
+ device_initcall(seccomp_sysctl_init)
+ 
+ #endif /* CONFIG_SYSCTL */
++>>>>>>> 8e5f1ad116df (seccomp: Sysctl to display available actions)
diff --git a/Documentation/prctl/seccomp_filter.txt b/Documentation/prctl/seccomp_filter.txt
index 1e469ef75778..d42bc07bd5d0 100644
--- a/Documentation/prctl/seccomp_filter.txt
+++ b/Documentation/prctl/seccomp_filter.txt
@@ -166,7 +166,23 @@ The samples/seccomp/ directory contains both an x86-specific example
 and a more generic example of a higher level macro interface for BPF
 program generation.
 
-
+Sysctls
+=======
+
+Seccomp's sysctl files can be found in the ``/proc/sys/kernel/seccomp/``
+directory. Here's a description of each file in that directory:
+
+``actions_avail``:
+	A read-only ordered list of seccomp return values (refer to the
+	``SECCOMP_RET_*`` macros above) in string form. The ordering, from
+	left-to-right, is the least permissive return value to the most
+	permissive return value.
+
+	The list represents the set of seccomp return values supported
+	by the kernel. A userspace program may use this list to
+	determine if the actions found in the ``seccomp.h``, when the
+	program was built, differs from the set of actions actually
+	supported in the current running kernel.
 
 Adding architecture support
 -----------------------
diff --git a/Documentation/sysctl/kernel.txt b/Documentation/sysctl/kernel.txt
index 425b3fd3f24b..11b47c95843c 100644
--- a/Documentation/sysctl/kernel.txt
+++ b/Documentation/sysctl/kernel.txt
@@ -71,6 +71,7 @@ show up in /proc/sys/kernel:
 - reboot-cmd                  [ SPARC only ]
 - rtsig-max
 - rtsig-nr
+- seccomp/                    ==> Documentation/userspace-api/seccomp_filter.rst
 - sem
 - sem_next_id		      [ sysv ipc ]
 - sg-big-buff                 [ generic SCSI device (sg) ]
* Unmerged path kernel/seccomp.c
