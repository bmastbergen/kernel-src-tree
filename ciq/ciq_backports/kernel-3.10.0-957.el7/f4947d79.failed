Input: synaptics - keep PS/2 around when RMI4_SMB is not enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [input] synaptics - keep PS/2 around when RMI4_SMB is not enabled (Benjamin Tissoires) [1554926]
Rebuild_FUZZ: 94.21%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit f4947d79a7080b25829997eeee38d4d65137c161
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f4947d79.failed

Or the user might have the touchpad unbound from PS/2 but never picked
up by rmi-smbus.ko

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
(cherry picked from commit f4947d79a7080b25829997eeee38d4d65137c161)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/input/mouse/synaptics.c
diff --cc drivers/input/mouse/synaptics.c
index 5f5887ef5b0a,9b27a6c710b2..000000000000
--- a/drivers/input/mouse/synaptics.c
+++ b/drivers/input/mouse/synaptics.c
@@@ -1819,9 -1674,167 +1819,175 @@@ int synaptics_init(struct psmouse *psmo
  	return -ENOSYS;
  }
  
 +bool synaptics_supported(void)
 +{
 +	return false;
 +}
 +
  #endif /* CONFIG_MOUSE_PS2_SYNAPTICS */
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS
+ 
+ /*
+  * The newest Synaptics device can use a secondary bus (called InterTouch) which
+  * provides a better bandwidth and allow a better control of the touchpads.
+  * This is used to decide if we need to use this bus or not.
+  */
+ enum {
+ 	SYNAPTICS_INTERTOUCH_NOT_SET = -1,
+ 	SYNAPTICS_INTERTOUCH_OFF,
+ 	SYNAPTICS_INTERTOUCH_ON,
+ };
+ 
+ static int synaptics_intertouch = IS_ENABLED(CONFIG_RMI4_SMB) ?
+ 		SYNAPTICS_INTERTOUCH_NOT_SET : SYNAPTICS_INTERTOUCH_OFF;
+ module_param_named(synaptics_intertouch, synaptics_intertouch, int, 0644);
+ MODULE_PARM_DESC(synaptics_intertouch, "Use a secondary bus for the Synaptics device.");
+ 
+ static int synaptics_create_intertouch(struct psmouse *psmouse,
+ 				       struct synaptics_device_info *info,
+ 				       bool leave_breadcrumbs)
+ {
+ 	bool topbuttonpad =
+ 		psmouse_matches_pnp_id(psmouse, topbuttonpad_pnp_ids) &&
+ 		!SYN_CAP_EXT_BUTTONS_STICK(info->ext_cap_10);
+ 	const struct rmi_device_platform_data pdata = {
+ 		.sensor_pdata = {
+ 			.sensor_type = rmi_sensor_touchpad,
+ 			.axis_align.flip_y = true,
+ 			/* to prevent cursors jumps: */
+ 			.kernel_tracking = true,
+ 			.topbuttonpad = topbuttonpad,
+ 		},
+ 		.f30_data = {
+ 			.buttonpad = SYN_CAP_CLICKPAD(info->ext_cap_0c),
+ 			.trackstick_buttons =
+ 				!!SYN_CAP_EXT_BUTTONS_STICK(info->ext_cap_10),
+ 		},
+ 	};
+ 	const struct i2c_board_info intertouch_board = {
+ 		I2C_BOARD_INFO("rmi4_smbus", 0x2c),
+ 		.flags = I2C_CLIENT_HOST_NOTIFY,
+ 	};
+ 
+ 	return psmouse_smbus_init(psmouse, &intertouch_board,
+ 				  &pdata, sizeof(pdata),
+ 				  leave_breadcrumbs);
+ }
+ 
+ /**
+  * synaptics_setup_intertouch - called once the PS/2 devices are enumerated
+  * and decides to instantiate a SMBus InterTouch device.
+  */
+ static int synaptics_setup_intertouch(struct psmouse *psmouse,
+ 				      struct synaptics_device_info *info,
+ 				      bool leave_breadcrumbs)
+ {
+ 	int error;
+ 
+ 	if (synaptics_intertouch == SYNAPTICS_INTERTOUCH_OFF)
+ 		return -ENXIO;
+ 
+ 	if (synaptics_intertouch == SYNAPTICS_INTERTOUCH_NOT_SET) {
+ 		if (!psmouse_matches_pnp_id(psmouse, topbuttonpad_pnp_ids) &&
+ 		    !psmouse_matches_pnp_id(psmouse, smbus_pnp_ids))
+ 			return -ENXIO;
+ 	}
+ 
+ 	psmouse_info(psmouse, "Trying to set up SMBus access\n");
+ 
+ 	error = synaptics_create_intertouch(psmouse, info, leave_breadcrumbs);
+ 	if (error) {
+ 		if (error == -EAGAIN)
+ 			psmouse_info(psmouse, "SMbus companion is not ready yet\n");
+ 		else
+ 			psmouse_err(psmouse, "unable to create intertouch device\n");
+ 
+ 		return error;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int synaptics_init_smbus(struct psmouse *psmouse)
+ {
+ 	struct synaptics_device_info info;
+ 	int error;
+ 
+ 	psmouse_reset(psmouse);
+ 
+ 	error = synaptics_query_hardware(psmouse, &info);
+ 	if (error) {
+ 		psmouse_err(psmouse, "Unable to query device: %d\n", error);
+ 		return error;
+ 	}
+ 
+ 	if (!SYN_CAP_INTERTOUCH(info.ext_cap_0c))
+ 		return -ENXIO;
+ 
+ 	return synaptics_create_intertouch(psmouse, &info, false);
+ }
+ 
+ #else /* CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS */
+ 
+ static int __maybe_unused
+ synaptics_setup_intertouch(struct psmouse *psmouse,
+ 			   struct synaptics_device_info *info,
+ 			   bool leave_breadcrumbs)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int synaptics_init_smbus(struct psmouse *psmouse)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ #endif /* CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS */
+ 
+ #if defined(CONFIG_MOUSE_PS2_SYNAPTICS) || \
+     defined(CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS)
+ 
+ int synaptics_init(struct psmouse *psmouse)
+ {
+ 	struct synaptics_device_info info;
+ 	int error;
+ 	int retval;
+ 
+ 	psmouse_reset(psmouse);
+ 
+ 	error = synaptics_query_hardware(psmouse, &info);
+ 	if (error) {
+ 		psmouse_err(psmouse, "Unable to query device: %d\n", error);
+ 		return error;
+ 	}
+ 
+ 	if (SYN_CAP_INTERTOUCH(info.ext_cap_0c)) {
+ 		error = synaptics_setup_intertouch(psmouse, &info, true);
+ 		if (!error)
+ 			return PSMOUSE_SYNAPTICS_SMBUS;
+ 	}
+ 
+ 	retval = synaptics_setup_ps2(psmouse, &info);
+ 	if (retval < 0) {
+ 		/*
+ 		 * Not using any flavor of Synaptics support, so clean up
+ 		 * SMbus breadcrumbs, if any.
+ 		 */
+ 		psmouse_smbus_cleanup(psmouse);
+ 	}
+ 
+ 	return retval;
+ }
+ 
+ #else /* CONFIG_MOUSE_PS2_SYNAPTICS || CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS */
+ 
+ int synaptics_init(struct psmouse *psmouse)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ #endif /* CONFIG_MOUSE_PS2_SYNAPTICS || CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS */
++>>>>>>> f4947d79a708 (Input: synaptics - keep PS/2 around when RMI4_SMB is not enabled)
* Unmerged path drivers/input/mouse/synaptics.c
