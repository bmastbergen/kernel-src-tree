ipmi_si: Move irq setup handling into the io struct

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Corey Minyard <cminyard@mvista.com>
commit 4f3e8199c34dda46b6554191fe7a444dd6fa911f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4f3e8199.failed

So the platform code can do it without having to access the
smi info, getting ready for pulling the platform handling
section to their own files.

	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit 4f3e8199c34dda46b6554191fe7a444dd6fa911f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_si_intf.c
#	drivers/char/ipmi/ipmi_si_sm.h
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 72982bfaeaf1,4b832b96d02b..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -175,12 -175,7 +175,10 @@@ struct smi_info 
  	struct si_sm_io io;
  	int (*io_setup)(struct smi_info *info);
  	void (*io_cleanup)(struct smi_info *info);
- 	int (*irq_setup)(struct smi_info *info);
- 	void (*irq_cleanup)(struct smi_info *info);
  	unsigned int io_size;
 +	enum ipmi_addr_src addr_source; /* ACPI, PCI, SMBIOS, hardcode, etc. */
 +	void (*addr_source_cleanup)(struct smi_info *info);
 +	void *addr_source_data;
  
  	/*
  	 * Per-OEM handler, called from handle_flags().  Returns 1
@@@ -1415,46 -1396,48 +1411,85 @@@ MODULE_PARM_DESC(kipmid_max_busy_us
  		 " sleeping. 0 (default) means to wait forever. Set to 100-500"
  		 " if kipmid is using up a lot of CPU time.");
  
- 
- static void std_irq_cleanup(struct smi_info *info)
+ void ipmi_irq_finish_setup(struct si_sm_io *io)
  {
++<<<<<<< HEAD
 +	if (info->si_type == SI_BT)
 +		/* Disable the interrupt in the BT interface. */
 +		info->io.outputb(&info->io, IPMI_BT_INTMASK_REG, 0);
 +	free_irq(info->irq, info);
++=======
+ 	if (io->si_type == SI_BT)
+ 		/* Enable the interrupt in the BT interface. */
+ 		io->outputb(io, IPMI_BT_INTMASK_REG,
+ 			    IPMI_BT_INTMASK_ENABLE_IRQ_BIT);
++>>>>>>> 4f3e8199c34d (ipmi_si: Move irq setup handling into the io struct)
+ }
+ 
+ void ipmi_irq_start_cleanup(struct si_sm_io *io)
+ {
+ 	if (io->si_type == SI_BT)
+ 		/* Disable the interrupt in the BT interface. */
+ 		io->outputb(io, IPMI_BT_INTMASK_REG, 0);
+ }
+ 
+ static void std_irq_cleanup(struct si_sm_io *io)
+ {
+ 	ipmi_irq_start_cleanup(io);
+ 	free_irq(io->irq, io->irq_handler_data);
  }
  
- static int std_irq_setup(struct smi_info *info)
+ int ipmi_std_irq_setup(struct si_sm_io *io)
  {
  	int rv;
  
++<<<<<<< HEAD
 +	if (!info->irq)
 +		return 0;
 +
 +	if (info->si_type == SI_BT) {
 +		rv = request_irq(info->irq,
 +				 si_bt_irq_handler,
 +				 IRQF_SHARED,
 +				 DEVICE_NAME,
 +				 info);
 +		if (!rv)
 +			/* Enable the interrupt in the BT interface. */
 +			info->io.outputb(&info->io, IPMI_BT_INTMASK_REG,
 +					 IPMI_BT_INTMASK_ENABLE_IRQ_BIT);
 +	} else
 +		rv = request_irq(info->irq,
 +				 si_irq_handler,
 +				 IRQF_SHARED,
 +				 DEVICE_NAME,
 +				 info);
 +	if (rv) {
 +		dev_warn(info->dev, "%s unable to claim interrupt %d,"
 +			 " running polled\n",
 +			 DEVICE_NAME, info->irq);
 +		info->irq = 0;
 +	} else {
 +		info->irq_cleanup = std_irq_cleanup;
 +		dev_info(info->dev, "Using irq %d\n", info->irq);
++=======
+ 	if (!io->irq)
+ 		return 0;
+ 
+ 	rv = request_irq(io->irq,
+ 			 ipmi_si_irq_handler,
+ 			 IRQF_SHARED,
+ 			 DEVICE_NAME,
+ 			 io->irq_handler_data);
+ 	if (rv) {
+ 		dev_warn(io->dev, "%s unable to claim interrupt %d,"
+ 			 " running polled\n",
+ 			 DEVICE_NAME, io->irq);
+ 		io->irq = 0;
+ 	} else {
+ 		io->irq_cleanup = std_irq_cleanup;
+ 		ipmi_irq_finish_setup(io);
+ 		dev_info(io->dev, "Using irq %d\n", io->irq);
++>>>>>>> 4f3e8199c34d (ipmi_si: Move irq setup handling into the io struct)
  	}
  
  	return rv;
@@@ -1933,10 -1916,10 +1968,17 @@@ static int hotmod_handler(const char *v
  			if (!info->io.regsize)
  				info->io.regsize = DEFAULT_REGSIZE;
  			info->io.regshift = regshift;
++<<<<<<< HEAD
 +			info->irq = irq;
 +			if (info->irq)
 +				info->irq_setup = std_irq_setup;
 +			info->slave_addr = ipmb;
++=======
+ 			info->io.irq = irq;
+ 			if (info->io.irq)
+ 				info->io.irq_setup = ipmi_std_irq_setup;
+ 			info->io.slave_addr = ipmb;
++>>>>>>> 4f3e8199c34d (ipmi_si: Move irq setup handling into the io struct)
  
  			rv = ipmi_si_add_smi(info);
  			if (rv) {
@@@ -2027,10 -2010,10 +2069,17 @@@ static int hardcode_find_bmc(void
  		if (!info->io.regsize)
  			info->io.regsize = DEFAULT_REGSIZE;
  		info->io.regshift = regshifts[i];
++<<<<<<< HEAD
 +		info->irq = irqs[i];
 +		if (info->irq)
 +			info->irq_setup = std_irq_setup;
 +		info->slave_addr = slave_addrs[i];
++=======
+ 		info->io.irq = irqs[i];
+ 		if (info->io.irq)
+ 			info->io.irq_setup = ipmi_std_irq_setup;
+ 		info->io.slave_addr = slave_addrs[i];
++>>>>>>> 4f3e8199c34d (ipmi_si: Move irq setup handling into the io struct)
  
  		if (!ipmi_si_add_smi(info)) {
  			mutex_lock(&smi_infos_lock);
@@@ -2073,34 -2047,37 +2113,62 @@@ static u32 ipmi_acpi_gpe(acpi_handle gp
  	return ACPI_INTERRUPT_HANDLED;
  }
  
- static void acpi_gpe_irq_cleanup(struct smi_info *info)
+ static void acpi_gpe_irq_cleanup(struct si_sm_io *io)
  {
++<<<<<<< HEAD
 +	if (!info->irq)
 +		return;
 +
 +	acpi_remove_gpe_handler(NULL, info->irq, &ipmi_acpi_gpe);
++=======
+ 	if (!io->irq)
+ 		return;
+ 
+ 	ipmi_irq_start_cleanup(io);
+ 	acpi_remove_gpe_handler(NULL, io->irq, &ipmi_acpi_gpe);
++>>>>>>> 4f3e8199c34d (ipmi_si: Move irq setup handling into the io struct)
  }
  
- static int acpi_gpe_irq_setup(struct smi_info *info)
+ static int acpi_gpe_irq_setup(struct si_sm_io *io)
  {
  	acpi_status status;
  
++<<<<<<< HEAD
 +	if (!info->irq)
 +		return 0;
 +
 +	status = acpi_install_gpe_handler(NULL,
 +					  info->irq,
++=======
+ 	if (!io->irq)
+ 		return 0;
+ 
+ 	status = acpi_install_gpe_handler(NULL,
+ 					  io->irq,
++>>>>>>> 4f3e8199c34d (ipmi_si: Move irq setup handling into the io struct)
  					  ACPI_GPE_LEVEL_TRIGGERED,
  					  &ipmi_acpi_gpe,
- 					  info);
+ 					  io);
  	if (status != AE_OK) {
++<<<<<<< HEAD
 +		dev_warn(info->dev, "%s unable to claim ACPI GPE %d,"
 +			 " running polled\n", DEVICE_NAME, info->irq);
 +		info->irq = 0;
 +		return -EINVAL;
 +	} else {
 +		info->irq_cleanup = acpi_gpe_irq_cleanup;
 +		dev_info(info->dev, "Using ACPI GPE %d\n", info->irq);
++=======
+ 		dev_warn(io->dev,
+ 			 "Unable to claim ACPI GPE %d, running polled\n",
+ 			 io->irq);
+ 		io->irq = 0;
+ 		return -EINVAL;
+ 	} else {
+ 		io->irq_cleanup = acpi_gpe_irq_cleanup;
+ 		ipmi_irq_finish_setup(io);
+ 		dev_info(io->dev, "Using ACPI GPE %d\n", io->irq);
++>>>>>>> 4f3e8199c34d (ipmi_si: Move irq setup handling into the io struct)
  		return 0;
  	}
  }
@@@ -2193,16 -2170,16 +2261,29 @@@ static int try_init_spmi(struct SPMITab
  
  	if (spmi->InterruptType & 1) {
  		/* We've got a GPE interrupt. */
++<<<<<<< HEAD
 +		info->irq = spmi->GPE;
 +		info->irq_setup = acpi_gpe_irq_setup;
 +	} else if (spmi->InterruptType & 2) {
 +		/* We've got an APIC/SAPIC interrupt. */
 +		info->irq = spmi->GlobalSystemInterrupt;
 +		info->irq_setup = std_irq_setup;
 +	} else {
 +		/* Use the default interrupt setting. */
 +		info->irq = 0;
 +		info->irq_setup = NULL;
++=======
+ 		info->io.irq = spmi->GPE;
+ 		info->io.irq_setup = acpi_gpe_irq_setup;
+ 	} else if (spmi->InterruptType & 2) {
+ 		/* We've got an APIC/SAPIC interrupt. */
+ 		info->io.irq = spmi->GlobalSystemInterrupt;
+ 		info->io.irq_setup = ipmi_std_irq_setup;
+ 	} else {
+ 		/* Use the default interrupt setting. */
+ 		info->io.irq = 0;
+ 		info->io.irq_setup = NULL;
++>>>>>>> 4f3e8199c34d (ipmi_si: Move irq setup handling into the io struct)
  	}
  
  	if (spmi->addr.bit_width) {
@@@ -2349,18 -2327,18 +2430,24 @@@ static int dmi_ipmi_probe(struct platfo
  	rv = device_property_read_u8(&pdev->dev, "slave-addr", &slave_addr);
  	if (rv) {
  		dev_warn(&pdev->dev, "device has no slave-addr property");
 -		info->io.slave_addr = 0x20;
 +		info->slave_addr = 0x20;
  	} else {
 -		info->io.slave_addr = slave_addr;
 +		info->slave_addr = slave_addr;
  	}
  
++<<<<<<< HEAD
 +	info->irq = platform_get_irq(pdev, 0);
 +	if (info->irq > 0)
 +		info->irq_setup = std_irq_setup;
++=======
+ 	info->io.irq = platform_get_irq(pdev, 0);
+ 	if (info->io.irq > 0)
+ 		info->io.irq_setup = ipmi_std_irq_setup;
++>>>>>>> 4f3e8199c34d (ipmi_si: Move irq setup handling into the io struct)
  	else
 -		info->io.irq = 0;
 +		info->irq = 0;
  
 -	info->io.dev = &pdev->dev;
 +	info->dev = &pdev->dev;
  
  	pr_info("ipmi_si: SMBIOS: %s %#lx regsize %d spacing %d irq %d\n",
  		(info->io.addr_type == IPMI_IO_ADDR_SPACE) ? "io" : "mem",
@@@ -2491,11 -2469,11 +2578,17 @@@ static int ipmi_pci_probe(struct pci_de
  	info->io.regsize = DEFAULT_REGSIZE;
  	info->io.regshift = 0;
  
++<<<<<<< HEAD
 +	info->irq = pdev->irq;
 +	if (info->irq)
 +		info->irq_setup = std_irq_setup;
++=======
+ 	info->io.irq = pdev->irq;
+ 	if (info->io.irq)
+ 		info->io.irq_setup = ipmi_std_irq_setup;
++>>>>>>> 4f3e8199c34d (ipmi_si: Move irq setup handling into the io struct)
  
 -	info->io.dev = &pdev->dev;
 +	info->dev = &pdev->dev;
  	pci_set_drvdata(pdev, info);
  
  	dev_info(&pdev->dev, "%pR regsize %d spacing %d irq %d\n",
@@@ -2594,9 -2573,9 +2687,15 @@@ static int of_ipmi_probe(struct platfor
  		return -ENOMEM;
  	}
  
++<<<<<<< HEAD
 +	info->si_type		= (enum si_type) match->data;
 +	info->addr_source	= SI_DEVICETREE;
 +	info->irq_setup		= std_irq_setup;
++=======
+ 	info->io.si_type	= (enum si_type) match->data;
+ 	info->io.addr_source	= SI_DEVICETREE;
+ 	info->io.irq_setup	= ipmi_std_irq_setup;
++>>>>>>> 4f3e8199c34d (ipmi_si: Move irq setup handling into the io struct)
  
  	if (resource.flags & IORESOURCE_IO) {
  		info->io_setup		= port_setup;
@@@ -2726,14 -2706,14 +2825,24 @@@ static int acpi_ipmi_probe(struct platf
  	/* If _GPE exists, use it; otherwise use standard interrupts */
  	status = acpi_evaluate_integer(handle, "_GPE", NULL, &tmp);
  	if (ACPI_SUCCESS(status)) {
++<<<<<<< HEAD
 +		info->irq = tmp;
 +		info->irq_setup = acpi_gpe_irq_setup;
++=======
+ 		info->io.irq = tmp;
+ 		info->io.irq_setup = acpi_gpe_irq_setup;
++>>>>>>> 4f3e8199c34d (ipmi_si: Move irq setup handling into the io struct)
  	} else {
 -		int irq = platform_get_irq(pdev, 0);
 +		int irq = platform_get_irq(dev, 0);
  
  		if (irq > 0) {
++<<<<<<< HEAD
 +			info->irq = irq;
 +			info->irq_setup = std_irq_setup;
++=======
+ 			info->io.irq = irq;
+ 			info->io.irq_setup = ipmi_std_irq_setup;
++>>>>>>> 4f3e8199c34d (ipmi_si: Move irq setup handling into the io struct)
  		}
  	}
  
@@@ -2820,9 -2800,9 +2929,15 @@@ static int ipmi_parisc_probe(struct par
  	info->io.regsize	= 1;
  	info->io.regspacing	= 1;
  	info->io.regshift	= 0;
++<<<<<<< HEAD
 +	info->irq		= 0; /* no interrupt */
 +	info->irq_setup		= NULL;
 +	info->dev		= &dev->dev;
++=======
+ 	info->io.irq		= 0; /* no interrupt */
+ 	info->io.irq_setup	= NULL;
+ 	info->io.dev		= &dev->dev;
++>>>>>>> 4f3e8199c34d (ipmi_si: Move irq setup handling into the io struct)
  
  	dev_dbg(&dev->dev, "addr 0x%lx\n", info->io.addr_data);
  
diff --cc drivers/char/ipmi/ipmi_si_sm.h
index a705027c0493,bf3f50cede44..000000000000
--- a/drivers/char/ipmi/ipmi_si_sm.h
+++ b/drivers/char/ipmi/ipmi_si_sm.h
@@@ -61,6 -67,18 +61,21 @@@ struct si_sm_io 
  	int  regshift;
  	int addr_type;
  	long addr_data;
++<<<<<<< HEAD
++=======
+ 	enum ipmi_addr_src addr_source; /* ACPI, PCI, SMBIOS, hardcode, etc. */
+ 	void (*addr_source_cleanup)(struct si_sm_io *io);
+ 	void *addr_source_data;
+ 
+ 	int irq;
+ 	int (*irq_setup)(struct si_sm_io *io);
+ 	void *irq_handler_data;
+ 	void (*irq_cleanup)(struct si_sm_io *io);
+ 
+ 	u8 slave_addr;
+ 	enum si_type si_type;
+ 	struct device *dev;
++>>>>>>> 4f3e8199c34d (ipmi_si: Move irq setup handling into the io struct)
  };
  
  /* Results of SMI events. */
diff --git a/drivers/char/ipmi/ipmi_si.h b/drivers/char/ipmi/ipmi_si.h
index a4d993b1fe66..e84651acd772 100644
--- a/drivers/char/ipmi/ipmi_si.h
+++ b/drivers/char/ipmi/ipmi_si.h
@@ -5,6 +5,7 @@
  * etc) to the base ipmi system interface code.
  */
 
+#include <linux/interrupt.h>
 #include "ipmi_si_sm.h"
 
 #define IPMI_IO_ADDR_SPACE  0
@@ -16,3 +17,7 @@
 struct smi_info;
 
 int ipmi_si_add_smi(struct smi_info *info);
+irqreturn_t ipmi_si_irq_handler(int irq, void *data);
+void ipmi_irq_start_cleanup(struct si_sm_io *io);
+int ipmi_std_irq_setup(struct si_sm_io *io);
+void ipmi_irq_finish_setup(struct si_sm_io *io);
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
* Unmerged path drivers/char/ipmi/ipmi_si_sm.h
