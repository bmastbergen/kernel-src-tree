netfilter: ipset: Add skbinfo extension kernel support in the ipset core.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] netfilter: ipset: Add skbinfo extension kernel support in the ipset core (Stefano Brivio) [1557599]
Rebuild_FUZZ: 99.31%
commit-author Anton Danilov <littlesmilingcloud@gmail.com>
commit 0e9871e3f79fd17c691b50a9669220c54ff084a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0e9871e3.failed

Skbinfo extension provides mapping of metainformation with lookup in the ipset tables.
This patch defines the flags, the constants, the functions and the structures
for the data type independent support of the extension.
Note the firewall mark stores in the kernel structures as two 32bit values,
but transfered through netlink as one 64bit value.

	Signed-off-by: Anton Danilov <littlesmilingcloud@gmail.com>
	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 0e9871e3f79fd17c691b50a9669220c54ff084a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/ipset/ip_set.h
#	include/uapi/linux/netfilter/ipset/ip_set.h
#	net/netfilter/ipset/ip_set_core.c
diff --cc include/linux/netfilter/ipset/ip_set.h
index 3e9c90cf5227,b97aac5142ed..000000000000
--- a/include/linux/netfilter/ipset/ip_set.h
+++ b/include/linux/netfilter/ipset/ip_set.h
@@@ -51,20 -51,31 +51,41 @@@ enum ip_set_feature 
  
  /* Set extensions */
  enum ip_set_extension {
 -	IPSET_EXT_BIT_TIMEOUT = 0,
 +	IPSET_EXT_NONE = 0,
 +	IPSET_EXT_BIT_TIMEOUT = 1,
  	IPSET_EXT_TIMEOUT = (1 << IPSET_EXT_BIT_TIMEOUT),
 -	IPSET_EXT_BIT_COUNTER = 1,
 +	IPSET_EXT_BIT_COUNTER = 2,
  	IPSET_EXT_COUNTER = (1 << IPSET_EXT_BIT_COUNTER),
++<<<<<<< HEAD
++=======
+ 	IPSET_EXT_BIT_COMMENT = 2,
+ 	IPSET_EXT_COMMENT = (1 << IPSET_EXT_BIT_COMMENT),
+ 	IPSET_EXT_BIT_SKBINFO = 3,
+ 	IPSET_EXT_SKBINFO = (1 << IPSET_EXT_BIT_SKBINFO),
+ 	/* Mark set with an extension which needs to call destroy */
+ 	IPSET_EXT_BIT_DESTROY = 7,
+ 	IPSET_EXT_DESTROY = (1 << IPSET_EXT_BIT_DESTROY),
++>>>>>>> 0e9871e3f79f (netfilter: ipset: Add skbinfo extension kernel support in the ipset core.)
  };
  
  #define SET_WITH_TIMEOUT(s)	((s)->extensions & IPSET_EXT_TIMEOUT)
  #define SET_WITH_COUNTER(s)	((s)->extensions & IPSET_EXT_COUNTER)
++<<<<<<< HEAD
++=======
+ #define SET_WITH_COMMENT(s)	((s)->extensions & IPSET_EXT_COMMENT)
+ #define SET_WITH_SKBINFO(s)	((s)->extensions & IPSET_EXT_SKBINFO)
+ #define SET_WITH_FORCEADD(s)	((s)->flags & IPSET_CREATE_FLAG_FORCEADD)
++>>>>>>> 0e9871e3f79f (netfilter: ipset: Add skbinfo extension kernel support in the ipset core.)
  
  /* Extension id, in size order */
  enum ip_set_ext_id {
  	IPSET_EXT_ID_COUNTER = 0,
  	IPSET_EXT_ID_TIMEOUT,
++<<<<<<< HEAD
++=======
+ 	IPSET_EXT_ID_SKBINFO,
+ 	IPSET_EXT_ID_COMMENT,
++>>>>>>> 0e9871e3f79f (netfilter: ipset: Add skbinfo extension kernel support in the ipset core.)
  	IPSET_EXT_ID_MAX,
  };
  
@@@ -72,10 -96,40 +93,46 @@@ struct ip_set_ext 
  	u64 packets;
  	u64 bytes;
  	u32 timeout;
++<<<<<<< HEAD
++=======
+ 	u32 skbmark;
+ 	u32 skbmarkmask;
+ 	u32 skbprio;
+ 	u16 skbqueue;
+ 	char *comment;
+ };
+ 
+ struct ip_set_counter {
+ 	atomic64_t bytes;
+ 	atomic64_t packets;
+ };
+ 
+ struct ip_set_comment {
+ 	char *str;
++>>>>>>> 0e9871e3f79f (netfilter: ipset: Add skbinfo extension kernel support in the ipset core.)
+ };
+ 
+ struct ip_set_skbinfo {
+ 	u32 skbmark;
+ 	u32 skbmarkmask;
+ 	u32 skbprio;
+ 	u16 skbqueue;
  };
  
  struct ip_set;
  
++<<<<<<< HEAD
++=======
+ #define ext_timeout(e, s)	\
+ (unsigned long *)(((void *)(e)) + (s)->offset[IPSET_EXT_ID_TIMEOUT])
+ #define ext_counter(e, s)	\
+ (struct ip_set_counter *)(((void *)(e)) + (s)->offset[IPSET_EXT_ID_COUNTER])
+ #define ext_comment(e, s)	\
+ (struct ip_set_comment *)(((void *)(e)) + (s)->offset[IPSET_EXT_ID_COMMENT])
+ #define ext_skbinfo(e, s)	\
+ (struct ip_set_skbinfo *)(((void *)(e)) + (s)->offset[IPSET_EXT_ID_SKBINFO])
+ 
++>>>>>>> 0e9871e3f79f (netfilter: ipset: Add skbinfo extension kernel support in the ipset core.)
  typedef int (*ipset_adtfn)(struct ip_set *set, void *value,
  			   const struct ip_set_ext *ext,
  			   struct ip_set_ext *mext, u32 cmdflags);
@@@ -190,10 -248,39 +247,46 @@@ struct ip_set 
  	void *data;
  };
  
++<<<<<<< HEAD
 +struct ip_set_counter {
 +	atomic64_t bytes;
 +	atomic64_t packets;
 +};
++=======
+ static inline void
+ ip_set_ext_destroy(struct ip_set *set, void *data)
+ {
+ 	/* Check that the extension is enabled for the set and
+ 	 * call it's destroy function for its extension part in data.
+ 	 */
+ 	if (SET_WITH_COMMENT(set))
+ 		ip_set_extensions[IPSET_EXT_ID_COMMENT].destroy(
+ 			ext_comment(data, set));
+ }
+ 
+ static inline int
+ ip_set_put_flags(struct sk_buff *skb, struct ip_set *set)
+ {
+ 	u32 cadt_flags = 0;
+ 
+ 	if (SET_WITH_TIMEOUT(set))
+ 		if (unlikely(nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
+ 					   htonl(set->timeout))))
+ 			return -EMSGSIZE;
+ 	if (SET_WITH_COUNTER(set))
+ 		cadt_flags |= IPSET_FLAG_WITH_COUNTERS;
+ 	if (SET_WITH_COMMENT(set))
+ 		cadt_flags |= IPSET_FLAG_WITH_COMMENT;
+ 	if (SET_WITH_SKBINFO(set))
+ 		cadt_flags |= IPSET_FLAG_WITH_SKBINFO;
+ 	if (SET_WITH_FORCEADD(set))
+ 		cadt_flags |= IPSET_FLAG_WITH_FORCEADD;
+ 
+ 	if (!cadt_flags)
+ 		return 0;
+ 	return nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(cadt_flags));
+ }
++>>>>>>> 0e9871e3f79f (netfilter: ipset: Add skbinfo extension kernel support in the ipset core.)
  
  static inline void
  ip_set_add_bytes(u64 bytes, struct ip_set_counter *counter)
@@@ -397,14 -528,41 +523,42 @@@ bitmap_bytes(u32 a, u32 b
  }
  
  #include <linux/netfilter/ipset/ip_set_timeout.h>
 -#include <linux/netfilter/ipset/ip_set_comment.h>
  
++<<<<<<< HEAD
 +#define IP_SET_INIT_KEXT(skb, opt, map)			\
++=======
+ static inline int
+ ip_set_put_extensions(struct sk_buff *skb, const struct ip_set *set,
+ 		      const void *e, bool active)
+ {
+ 	if (SET_WITH_TIMEOUT(set)) {
+ 		unsigned long *timeout = ext_timeout(e, set);
+ 
+ 		if (nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
+ 			htonl(active ? ip_set_timeout_get(timeout)
+ 				: *timeout)))
+ 			return -EMSGSIZE;
+ 	}
+ 	if (SET_WITH_COUNTER(set) &&
+ 	    ip_set_put_counter(skb, ext_counter(e, set)))
+ 		return -EMSGSIZE;
+ 	if (SET_WITH_COMMENT(set) &&
+ 	    ip_set_put_comment(skb, ext_comment(e, set)))
+ 		return -EMSGSIZE;
+ 	if (SET_WITH_SKBINFO(set) &&
+ 	    ip_set_put_skbinfo(skb, ext_skbinfo(e, set)))
+ 		return -EMSGSIZE;
+ 	return 0;
+ }
+ 
+ #define IP_SET_INIT_KEXT(skb, opt, set)			\
++>>>>>>> 0e9871e3f79f (netfilter: ipset: Add skbinfo extension kernel support in the ipset core.)
  	{ .bytes = (skb)->len, .packets = 1,		\
 -	  .timeout = ip_set_adt_opt_timeout(opt, set) }
 +	  .timeout = ip_set_adt_opt_timeout(opt, map) }
  
 -#define IP_SET_INIT_UEXT(set)				\
 +#define IP_SET_INIT_UEXT(map)				\
  	{ .bytes = ULLONG_MAX, .packets = ULLONG_MAX,	\
 -	  .timeout = (set)->timeout }
 -
 -#define IP_SET_INIT_CIDR(a, b) ((a) ? (a) : (b))
 +	  .timeout = (map)->timeout }
  
  #define IPSET_CONCAT(a, b)		a##b
  #define IPSET_TOKEN(a, b)		IPSET_CONCAT(a, b)
diff --cc include/uapi/linux/netfilter/ipset/ip_set.h
index 7f7d72410118,ca03119111a2..000000000000
--- a/include/uapi/linux/netfilter/ipset/ip_set.h
+++ b/include/uapi/linux/netfilter/ipset/ip_set.h
@@@ -111,11 -114,10 +111,18 @@@ enum 
  	IPSET_ATTR_IFACE,
  	IPSET_ATTR_BYTES,
  	IPSET_ATTR_PACKETS,
++<<<<<<< HEAD
 +	__RH_RESERVED_IPSET_ATTR_COMMENT,
 +	__RH_RESERVED_IPSET_ATTR_SKBMARK,
 +	__RH_RESERVED_IPSET_ATTR_SKBPRIO,
 +	__RH_RESERVED_IPSET_ATTR_SKBQUEUE,
 +	IPSET_ATTR_PAD,
++=======
+ 	IPSET_ATTR_COMMENT,
+ 	IPSET_ATTR_SKBMARK,
+ 	IPSET_ATTR_SKBPRIO,
+ 	IPSET_ATTR_SKBQUEUE,
++>>>>>>> 0e9871e3f79f (netfilter: ipset: Add skbinfo extension kernel support in the ipset core.)
  	__IPSET_ATTR_ADT_MAX,
  };
  #define IPSET_ATTR_ADT_MAX	(__IPSET_ATTR_ADT_MAX - 1)
@@@ -146,6 -148,9 +153,12 @@@ enum ipset_errno 
  	IPSET_ERR_IPADDR_IPV4,
  	IPSET_ERR_IPADDR_IPV6,
  	IPSET_ERR_COUNTER,
++<<<<<<< HEAD
++=======
+ 	IPSET_ERR_COMMENT,
+ 	IPSET_ERR_INVALID_MARKMASK,
+ 	IPSET_ERR_SKBINFO,
++>>>>>>> 0e9871e3f79f (netfilter: ipset: Add skbinfo extension kernel support in the ipset core.)
  
  	/* Type specific error codes */
  	IPSET_ERR_TYPE_SPECIFIC = 4352,
@@@ -182,6 -193,12 +201,15 @@@ enum ipset_cadt_flags 
  	IPSET_FLAG_NOMATCH	= (1 << IPSET_FLAG_BIT_NOMATCH),
  	IPSET_FLAG_BIT_WITH_COUNTERS = 3,
  	IPSET_FLAG_WITH_COUNTERS = (1 << IPSET_FLAG_BIT_WITH_COUNTERS),
++<<<<<<< HEAD
++=======
+ 	IPSET_FLAG_BIT_WITH_COMMENT = 4,
+ 	IPSET_FLAG_WITH_COMMENT = (1 << IPSET_FLAG_BIT_WITH_COMMENT),
+ 	IPSET_FLAG_BIT_WITH_FORCEADD = 5,
+ 	IPSET_FLAG_WITH_FORCEADD = (1 << IPSET_FLAG_BIT_WITH_FORCEADD),
+ 	IPSET_FLAG_BIT_WITH_SKBINFO = 6,
+ 	IPSET_FLAG_WITH_SKBINFO = (1 << IPSET_FLAG_BIT_WITH_SKBINFO),
++>>>>>>> 0e9871e3f79f (netfilter: ipset: Add skbinfo extension kernel support in the ipset core.)
  	IPSET_FLAG_CADT_MAX	= 15,
  };
  
diff --cc net/netfilter/ipset/ip_set_core.c
index 0c25367a9554,26c795e6b57f..000000000000
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@@ -324,6 -322,68 +324,71 @@@ ip_set_get_ipaddr6(struct nlattr *nla, 
  }
  EXPORT_SYMBOL_GPL(ip_set_get_ipaddr6);
  
++<<<<<<< HEAD
++=======
+ typedef void (*destroyer)(void *);
+ /* ipset data extension types, in size order */
+ 
+ const struct ip_set_ext_type ip_set_extensions[] = {
+ 	[IPSET_EXT_ID_COUNTER] = {
+ 		.type	= IPSET_EXT_COUNTER,
+ 		.flag	= IPSET_FLAG_WITH_COUNTERS,
+ 		.len	= sizeof(struct ip_set_counter),
+ 		.align	= __alignof__(struct ip_set_counter),
+ 	},
+ 	[IPSET_EXT_ID_TIMEOUT] = {
+ 		.type	= IPSET_EXT_TIMEOUT,
+ 		.len	= sizeof(unsigned long),
+ 		.align	= __alignof__(unsigned long),
+ 	},
+ 	[IPSET_EXT_ID_SKBINFO] = {
+ 		.type	= IPSET_EXT_SKBINFO,
+ 		.flag	= IPSET_FLAG_WITH_SKBINFO,
+ 		.len	= sizeof(struct ip_set_skbinfo),
+ 		.align	= __alignof__(struct ip_set_skbinfo),
+ 	},
+ 	[IPSET_EXT_ID_COMMENT] = {
+ 		.type	 = IPSET_EXT_COMMENT | IPSET_EXT_DESTROY,
+ 		.flag	 = IPSET_FLAG_WITH_COMMENT,
+ 		.len	 = sizeof(struct ip_set_comment),
+ 		.align	 = __alignof__(struct ip_set_comment),
+ 		.destroy = (destroyer) ip_set_comment_free,
+ 	},
+ };
+ EXPORT_SYMBOL_GPL(ip_set_extensions);
+ 
+ static inline bool
+ add_extension(enum ip_set_ext_id id, u32 flags, struct nlattr *tb[])
+ {
+ 	return ip_set_extensions[id].flag ?
+ 		(flags & ip_set_extensions[id].flag) :
+ 		!!tb[IPSET_ATTR_TIMEOUT];
+ }
+ 
+ size_t
+ ip_set_elem_len(struct ip_set *set, struct nlattr *tb[], size_t len)
+ {
+ 	enum ip_set_ext_id id;
+ 	size_t offset = 0;
+ 	u32 cadt_flags = 0;
+ 
+ 	if (tb[IPSET_ATTR_CADT_FLAGS])
+ 		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
+ 	if (cadt_flags & IPSET_FLAG_WITH_FORCEADD)
+ 		set->flags |= IPSET_CREATE_FLAG_FORCEADD;
+ 	for (id = 0; id < IPSET_EXT_ID_MAX; id++) {
+ 		if (!add_extension(id, cadt_flags, tb))
+ 			continue;
+ 		offset += ALIGN(len + offset, ip_set_extensions[id].align);
+ 		set->offset[id] = offset;
+ 		set->extensions |= ip_set_extensions[id].type;
+ 		offset += ip_set_extensions[id].len;
+ 	}
+ 	return len + offset;
+ }
+ EXPORT_SYMBOL_GPL(ip_set_elem_len);
+ 
++>>>>>>> 0e9871e3f79f (netfilter: ipset: Add skbinfo extension kernel support in the ipset core.)
  int
  ip_set_get_extensions(struct ip_set *set, struct nlattr *tb[],
  		      struct ip_set_ext *ext)
@@@ -343,6 -404,30 +409,33 @@@
  			ext->packets = be64_to_cpu(nla_get_be64(
  						   tb[IPSET_ATTR_PACKETS]));
  	}
++<<<<<<< HEAD
++=======
+ 	if (tb[IPSET_ATTR_COMMENT]) {
+ 		if (!(set->extensions & IPSET_EXT_COMMENT))
+ 			return -IPSET_ERR_COMMENT;
+ 		ext->comment = ip_set_comment_uget(tb[IPSET_ATTR_COMMENT]);
+ 	}
+ 	if (tb[IPSET_ATTR_SKBMARK]) {
+ 		if (!(set->extensions & IPSET_EXT_SKBINFO))
+ 			return -IPSET_ERR_SKBINFO;
+ 		fullmark = be64_to_cpu(nla_get_be64(tb[IPSET_ATTR_SKBMARK]));
+ 		ext->skbmark = fullmark >> 32;
+ 		ext->skbmarkmask = fullmark & 0xffffffff;
+ 	}
+ 	if (tb[IPSET_ATTR_SKBPRIO]) {
+ 		if (!(set->extensions & IPSET_EXT_SKBINFO))
+ 			return -IPSET_ERR_SKBINFO;
+ 		ext->skbprio = be32_to_cpu(nla_get_be32(
+ 					    tb[IPSET_ATTR_SKBPRIO]));
+ 	}
+ 	if (tb[IPSET_ATTR_SKBQUEUE]) {
+ 		if (!(set->extensions & IPSET_EXT_SKBINFO))
+ 			return -IPSET_ERR_SKBINFO;
+ 		ext->skbqueue = be16_to_cpu(nla_get_be16(
+ 					    tb[IPSET_ATTR_SKBQUEUE]));
+ 	}
++>>>>>>> 0e9871e3f79f (netfilter: ipset: Add skbinfo extension kernel support in the ipset core.)
  	return 0;
  }
  EXPORT_SYMBOL_GPL(ip_set_get_extensions);
* Unmerged path include/linux/netfilter/ipset/ip_set.h
* Unmerged path include/uapi/linux/netfilter/ipset/ip_set.h
* Unmerged path net/netfilter/ipset/ip_set_core.c
