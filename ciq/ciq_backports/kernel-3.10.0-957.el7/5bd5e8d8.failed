dm: remove fmode_t argument from .prepare_ioctl hook

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Mike Snitzer <snitzer@redhat.com>
commit 5bd5e8d891c1fd2d966a7e2c26f0452d22410683
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5bd5e8d8.failed

Use the fmode_t that is passed to dm_blk_ioctl() rather than
inconsistently (varies across targets) drop it on the floor by
overriding it with the fmode_t stored in 'struct dm_dev'.

All the persistent reservation functions weren't using the fmode_t they
got back from .prepare_ioctl so remove them.

	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 5bd5e8d891c1fd2d966a7e2c26f0452d22410683)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-log-writes.c
#	drivers/md/dm-zoned-target.c
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index 14d7215727e9,3af590e0d78c..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -411,11 -458,9 +411,17 @@@ static int dm_blk_getgeo(struct block_d
  	return dm_get_geometry(md, geo);
  }
  
++<<<<<<< HEAD
 +static char *_dm_claim_ptr = "I belong to device-mapper";
 +
 +static int dm_get_bdev_for_ioctl(struct mapped_device *md,
 +				 struct block_device **bdev,
 +				 fmode_t *mode)
++=======
+ static int dm_prepare_ioctl(struct mapped_device *md, int *srcu_idx,
+ 			    struct block_device **bdev)
+ 	__acquires(md->io_barrier)
++>>>>>>> 5bd5e8d891c1 (dm: remove fmode_t argument from .prepare_ioctl hook)
  {
  	struct dm_target *tgt;
  	struct dm_table *map;
@@@ -433,30 -478,14 +439,34 @@@ retry
  
  	tgt = dm_table_get_target(map, 0);
  	if (!tgt->type->prepare_ioctl)
 -		return r;
 +		goto out;
  
 -	if (dm_suspended_md(md))
 -		return -EAGAIN;
 +	if (dm_suspended_md(md)) {
 +		r = -EAGAIN;
 +		goto out;
 +	}
 +
++<<<<<<< HEAD
 +	r = tgt->type->prepare_ioctl(tgt, bdev, mode);
 +	if (r < 0)
 +		goto out;
 +
 +	bdgrab(*bdev);
 +	r2 = blkdev_get(*bdev, *mode, _dm_claim_ptr);
 +	if (r2 < 0) {
 +		r = r2;
 +		goto out;
 +	}
  
 +	dm_put_live_table(md, srcu_idx);
 +	return r;
 +
 +out:
 +	dm_put_live_table(md, srcu_idx);
++=======
+ 	r = tgt->type->prepare_ioctl(tgt, bdev);
++>>>>>>> 5bd5e8d891c1 (dm: remove fmode_t argument from .prepare_ioctl hook)
  	if (r == -ENOTCONN && !fatal_signal_pending(current)) {
 -		dm_put_live_table(md, *srcu_idx);
  		msleep(10);
  		goto retry;
  	}
@@@ -467,11 -503,11 +477,15 @@@ static int dm_blk_ioctl(struct block_de
  			unsigned int cmd, unsigned long arg)
  {
  	struct mapped_device *md = bdev->bd_disk->private_data;
 -	int r, srcu_idx;
 +	int r;
  
++<<<<<<< HEAD
 +	r = dm_get_bdev_for_ioctl(md, &bdev, &mode);
++=======
+ 	r = dm_prepare_ioctl(md, &srcu_idx, &bdev);
++>>>>>>> 5bd5e8d891c1 (dm: remove fmode_t argument from .prepare_ioctl hook)
  	if (r < 0)
 -		goto out;
 +		return r;
  
  	if (r > 0) {
  		/*
@@@ -2993,12 -3034,11 +3007,18 @@@ static int dm_pr_reserve(struct block_d
  {
  	struct mapped_device *md = bdev->bd_disk->private_data;
  	const struct pr_ops *ops;
++<<<<<<< HEAD
 +	fmode_t mode;
 +	int r;
 +
 +	r = dm_get_bdev_for_ioctl(md, &bdev, &mode);
++=======
+ 	int r, srcu_idx;
+ 
+ 	r = dm_prepare_ioctl(md, &srcu_idx, &bdev);
++>>>>>>> 5bd5e8d891c1 (dm: remove fmode_t argument from .prepare_ioctl hook)
  	if (r < 0)
 -		goto out;
 +		return r;
  
  	ops = bdev->bd_disk->fops->pr_ops;
  	if (ops && ops->pr_reserve)
@@@ -3014,12 -3054,11 +3034,18 @@@ static int dm_pr_release(struct block_d
  {
  	struct mapped_device *md = bdev->bd_disk->private_data;
  	const struct pr_ops *ops;
++<<<<<<< HEAD
 +	fmode_t mode;
 +	int r;
 +
 +	r = dm_get_bdev_for_ioctl(md, &bdev, &mode);
++=======
+ 	int r, srcu_idx;
+ 
+ 	r = dm_prepare_ioctl(md, &srcu_idx, &bdev);
++>>>>>>> 5bd5e8d891c1 (dm: remove fmode_t argument from .prepare_ioctl hook)
  	if (r < 0)
 -		goto out;
 +		return r;
  
  	ops = bdev->bd_disk->fops->pr_ops;
  	if (ops && ops->pr_release)
@@@ -3036,12 -3075,11 +3062,18 @@@ static int dm_pr_preempt(struct block_d
  {
  	struct mapped_device *md = bdev->bd_disk->private_data;
  	const struct pr_ops *ops;
++<<<<<<< HEAD
 +	fmode_t mode;
 +	int r;
 +
 +	r = dm_get_bdev_for_ioctl(md, &bdev, &mode);
++=======
+ 	int r, srcu_idx;
+ 
+ 	r = dm_prepare_ioctl(md, &srcu_idx, &bdev);
++>>>>>>> 5bd5e8d891c1 (dm: remove fmode_t argument from .prepare_ioctl hook)
  	if (r < 0)
 -		goto out;
 +		return r;
  
  	ops = bdev->bd_disk->fops->pr_ops;
  	if (ops && ops->pr_preempt)
@@@ -3057,12 -3095,11 +3089,18 @@@ static int dm_pr_clear(struct block_dev
  {
  	struct mapped_device *md = bdev->bd_disk->private_data;
  	const struct pr_ops *ops;
++<<<<<<< HEAD
 +	fmode_t mode;
 +	int r;
 +
 +	r = dm_get_bdev_for_ioctl(md, &bdev, &mode);
++=======
+ 	int r, srcu_idx;
+ 
+ 	r = dm_prepare_ioctl(md, &srcu_idx, &bdev);
++>>>>>>> 5bd5e8d891c1 (dm: remove fmode_t argument from .prepare_ioctl hook)
  	if (r < 0)
 -		goto out;
 +		return r;
  
  	ops = bdev->bd_disk->fops->pr_ops;
  	if (ops && ops->pr_clear)
* Unmerged path drivers/md/dm-log-writes.c
* Unmerged path drivers/md/dm-zoned-target.c
diff --git a/drivers/md/dm-flakey.c b/drivers/md/dm-flakey.c
index c390c7f426ff..777ea7f824b4 100644
--- a/drivers/md/dm-flakey.c
+++ b/drivers/md/dm-flakey.c
@@ -419,8 +419,7 @@ static void flakey_status(struct dm_target *ti, status_type_t type,
 	}
 }
 
-static int flakey_prepare_ioctl(struct dm_target *ti,
-		struct block_device **bdev, fmode_t *mode)
+static int flakey_prepare_ioctl(struct dm_target *ti, struct block_device **bdev)
 {
 	struct flakey_c *fc = ti->private;
 
diff --git a/drivers/md/dm-linear.c b/drivers/md/dm-linear.c
index d40e867fe4c7..10e4fc2132e5 100644
--- a/drivers/md/dm-linear.c
+++ b/drivers/md/dm-linear.c
@@ -116,8 +116,7 @@ static void linear_status(struct dm_target *ti, status_type_t type,
 	}
 }
 
-static int linear_prepare_ioctl(struct dm_target *ti,
-		struct block_device **bdev, fmode_t *mode)
+static int linear_prepare_ioctl(struct dm_target *ti, struct block_device **bdev)
 {
 	struct linear_c *lc = (struct linear_c *) ti->private;
 	struct dm_dev *dev = lc->dev;
* Unmerged path drivers/md/dm-log-writes.c
diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c
index 4a7e516191fb..35f7a9de1d86 100644
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@ -1886,7 +1886,7 @@ out:
 }
 
 static int multipath_prepare_ioctl(struct dm_target *ti,
-		struct block_device **bdev, fmode_t *mode)
+				   struct block_device **bdev)
 {
 	struct multipath *m = ti->private;
 	struct pgpath *current_pgpath;
@@ -1899,7 +1899,6 @@ static int multipath_prepare_ioctl(struct dm_target *ti,
 	if (current_pgpath) {
 		if (!test_bit(MPATHF_QUEUE_IO, &m->flags)) {
 			*bdev = current_pgpath->path.dev->bdev;
-			*mode = current_pgpath->path.dev->mode;
 			r = 0;
 		} else {
 			/* pg_init has not started or completed */
diff --git a/drivers/md/dm-switch.c b/drivers/md/dm-switch.c
index be7dda9e4e22..5d25f8347758 100644
--- a/drivers/md/dm-switch.c
+++ b/drivers/md/dm-switch.c
@@ -511,8 +511,7 @@ static void switch_status(struct dm_target *ti, status_type_t type,
  *
  * Passthrough all ioctls to the path for sector 0
  */
-static int switch_prepare_ioctl(struct dm_target *ti,
-		struct block_device **bdev, fmode_t *mode)
+static int switch_prepare_ioctl(struct dm_target *ti, struct block_device **bdev)
 {
 	struct switch_ctx *sctx = ti->private;
 	unsigned path_nr;
@@ -520,7 +519,6 @@ static int switch_prepare_ioctl(struct dm_target *ti,
 	path_nr = switch_get_path_nr(sctx, 0);
 
 	*bdev = sctx->path_list[path_nr].dmdev->bdev;
-	*mode = sctx->path_list[path_nr].dmdev->mode;
 
 	/*
 	 * Only pass ioctls through if the device sizes match exactly.
diff --git a/drivers/md/dm-verity-target.c b/drivers/md/dm-verity-target.c
index 0bdd44a761ab..33042d341b14 100644
--- a/drivers/md/dm-verity-target.c
+++ b/drivers/md/dm-verity-target.c
@@ -594,8 +594,7 @@ static void verity_status(struct dm_target *ti, status_type_t type,
 	}
 }
 
-static int verity_prepare_ioctl(struct dm_target *ti,
-		struct block_device **bdev, fmode_t *mode)
+static int verity_prepare_ioctl(struct dm_target *ti, struct block_device **bdev)
 {
 	struct dm_verity *v = ti->private;
 
* Unmerged path drivers/md/dm-zoned-target.c
* Unmerged path drivers/md/dm.c
diff --git a/include/linux/device-mapper.h b/include/linux/device-mapper.h
index eca858277b1d..cdbe6d3956fb 100644
--- a/include/linux/device-mapper.h
+++ b/include/linux/device-mapper.h
@@ -90,8 +90,7 @@ typedef void (*dm_status_fn) (struct dm_target *ti, status_type_t status_type,
 
 typedef int (*dm_message_fn) (struct dm_target *ti, unsigned argc, char **argv);
 
-typedef int (*dm_prepare_ioctl_fn) (struct dm_target *ti,
-			    struct block_device **bdev, fmode_t *mode);
+typedef int (*dm_prepare_ioctl_fn) (struct dm_target *ti, struct block_device **bdev);
 
 typedef int (*dm_merge_fn) (struct dm_target *ti, struct bvec_merge_data *bvm,
 			    struct bio_vec *biovec, int max_size);
