networking: add and use skb_put_u8()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Johannes Berg <johannes.berg@intel.com>
commit 634fef61076d644b989b86abc2f560d81a089a31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/634fef61.failed

Joe and Bjørn suggested that it'd be nicer to not have the
cast in the fairly common case of doing
	*(u8 *)skb_put(skb, 1) = c;

Add skb_put_u8() for this case, and use it across the code,
using the following spatch:

    @@
    expression SKB, C, S;
    typedef u8;
    identifier fn = {skb_put};
    fresh identifier fn2 = fn ## "_u8";
    @@
    - *(u8 *)fn(SKB, S) = C;
    + fn2(SKB, C);

Note that due to the "S", the spatch isn't perfect, it should
have checked that S is 1, but there's also places that use a
sizeof expression like sizeof(var) or sizeof(u8) etc. Turns
out that nobody ever did something like
	*(u8 *)skb_put(skb, 2) = c;

which would be wrong anyway since the second byte wouldn't be
initialized.

	Suggested-by: Joe Perches <joe@perches.com>
	Suggested-by: Bjørn Mork <bjorn@mork.no>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 634fef61076d644b989b86abc2f560d81a089a31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/bluecard_cs.c
#	drivers/bluetooth/bt3c_cs.c
#	drivers/bluetooth/btuart_cs.c
#	drivers/bluetooth/dtl1_cs.c
#	drivers/bluetooth/hci_bcm.c
#	drivers/bluetooth/hci_intel.c
#	drivers/bluetooth/hci_nokia.c
#	drivers/bluetooth/hci_qca.c
#	drivers/isdn/i4l/isdn_bsdcomp.c
#	drivers/isdn/i4l/isdn_x25iface.c
#	drivers/net/hamradio/scc.c
#	drivers/net/usb/cdc_ncm.c
#	drivers/nfc/fdp/i2c.c
#	drivers/nfc/microread/i2c.c
#	drivers/nfc/microread/microread.c
#	drivers/nfc/nfcmrvl/fw_dnld.c
#	drivers/nfc/pn533.c
#	drivers/nfc/pn544/i2c.c
#	drivers/nfc/port100.c
#	drivers/nfc/st21nfca/i2c.c
#	drivers/nfc/st95hf/core.c
#	include/linux/skbuff.h
#	net/bluetooth/hci_sock.c
#	net/decnet/dn_nsp_out.c
#	net/nfc/digital_core.c
#	net/nfc/digital_dep.c
#	net/nfc/digital_technology.c
#	net/nfc/hci/core.c
#	net/nfc/hci/llc_shdlc.c
#	net/nfc/nci/hci.c
#	net/nfc/nci/spi.c
#	net/nfc/nci/uart.c
diff --cc drivers/bluetooth/bluecard_cs.c
index 007c0a45f31b,d4b0b655dde6..000000000000
--- a/drivers/bluetooth/bluecard_cs.c
+++ b/drivers/bluetooth/bluecard_cs.c
@@@ -448,7 -448,7 +448,11 @@@ static void bluecard_receive(struct blu
  
  		} else {
  
++<<<<<<< HEAD
 +			*skb_put(info->rx_skb, 1) = buf[i];
++=======
+ 			skb_put_u8(info->rx_skb, buf[i]);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  			info->rx_count--;
  
  			if (info->rx_count == 0) {
diff --cc drivers/bluetooth/bt3c_cs.c
index 8165ef2fe877,32dcac017395..000000000000
--- a/drivers/bluetooth/bt3c_cs.c
+++ b/drivers/bluetooth/bt3c_cs.c
@@@ -282,7 -282,7 +282,11 @@@ static void bt3c_receive(struct bt3c_in
  
  			__u8 x = inb(iobase + DATA_L);
  
++<<<<<<< HEAD
 +			*skb_put(info->rx_skb, 1) = x;
++=======
+ 			skb_put_u8(info->rx_skb, x);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  			inb(iobase + DATA_H);
  			info->rx_count--;
  
diff --cc drivers/bluetooth/btuart_cs.c
index 9624b29f8349,7df79bb12350..000000000000
--- a/drivers/bluetooth/btuart_cs.c
+++ b/drivers/bluetooth/btuart_cs.c
@@@ -233,7 -233,7 +233,11 @@@ static void btuart_receive(struct btuar
  
  		} else {
  
++<<<<<<< HEAD
 +			*skb_put(info->rx_skb, 1) = inb(iobase + UART_RX);
++=======
+ 			skb_put_u8(info->rx_skb, inb(iobase + UART_RX));
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  			info->rx_count--;
  
  			if (info->rx_count == 0) {
diff --cc drivers/bluetooth/dtl1_cs.c
index 6317c6f323bf,2adfe4fade76..000000000000
--- a/drivers/bluetooth/dtl1_cs.c
+++ b/drivers/bluetooth/dtl1_cs.c
@@@ -226,7 -226,7 +226,11 @@@ static void dtl1_receive(struct dtl1_in
  			}
  		}
  
++<<<<<<< HEAD
 +		*skb_put(info->rx_skb, 1) = inb(iobase + UART_RX);
++=======
+ 		skb_put_u8(info->rx_skb, inb(iobase + UART_RX));
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  		nsh = (struct nsh *)info->rx_skb->data;
  
  		info->rx_count--;
@@@ -414,7 -414,7 +418,11 @@@ static int dtl1_hci_send_frame(struct h
  	skb_reserve(s, NSHL);
  	skb_copy_from_linear_data(skb, skb_put(s, skb->len), skb->len);
  	if (skb->len & 0x0001)
++<<<<<<< HEAD
 +		*skb_put(s, 1) = 0;	/* PAD */
++=======
+ 		skb_put_u8(s, 0);	/* PAD */
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  
  	/* Prepend skb with Nokia frame header and queue */
  	memcpy(skb_push(s, NSHL), &nsh, NSHL);
diff --cc drivers/bluetooth/hci_bcm.c
index f87bfdfee4ff,d2e9e2d1b014..000000000000
--- a/drivers/bluetooth/hci_bcm.c
+++ b/drivers/bluetooth/hci_bcm.c
@@@ -262,9 -262,9 +262,15 @@@ static int bcm_set_diag(struct hci_dev 
  	if (!skb)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	*skb_put(skb, 1) = BCM_LM_DIAG_PKT;
 +	*skb_put(skb, 1) = 0xf0;
 +	*skb_put(skb, 1) = enable;
++=======
+ 	skb_put_u8(skb, BCM_LM_DIAG_PKT);
+ 	skb_put_u8(skb, 0xf0);
+ 	skb_put_u8(skb, enable);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  
  	skb_queue_tail(&bcm->txq, skb);
  	hci_uart_tx_wakeup(hu);
diff --cc drivers/bluetooth/hci_intel.c
index fa5099986f1b,aad07e40ea4f..000000000000
--- a/drivers/bluetooth/hci_intel.c
+++ b/drivers/bluetooth/hci_intel.c
@@@ -471,7 -470,7 +471,11 @@@ static int inject_cmd_complete(struct h
  	evt->ncmd = 0x01;
  	evt->opcode = cpu_to_le16(opcode);
  
++<<<<<<< HEAD
 +	*skb_put(skb, 1) = 0x00;
++=======
+ 	skb_put_u8(skb, 0x00);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  
  	hci_skb_pkt_type(skb) = HCI_EVENT_PKT;
  
diff --cc drivers/bluetooth/hci_qca.c
index 3d5afe150112,392f412b4575..000000000000
--- a/drivers/bluetooth/hci_qca.c
+++ b/drivers/bluetooth/hci_qca.c
@@@ -215,7 -215,7 +215,11 @@@ static int send_hci_ibs_cmd(u8 cmd, str
  	}
  
  	/* Assign HCI_IBS type */
++<<<<<<< HEAD
 +	*skb_put(skb, 1) = cmd;
++=======
+ 	skb_put_u8(skb, cmd);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  
  	skb_queue_tail(&qca->txq, skb);
  
diff --cc drivers/isdn/i4l/isdn_bsdcomp.c
index 8837ac5a492d,3035210a6119..000000000000
--- a/drivers/isdn/i4l/isdn_bsdcomp.c
+++ b/drivers/isdn/i4l/isdn_bsdcomp.c
@@@ -602,7 -602,8 +602,12 @@@ static int bsd_compress(void *state, st
  	 * Do not emit a completely useless byte of ones.
  	 */
  	if (bitno < 32 && skb_out && skb_tailroom(skb_out) > 0)
++<<<<<<< HEAD
 +		*(skb_put(skb_out, 1)) = (unsigned char)((accm | (0xff << (bitno - 8))) >> 24);
++=======
+ 		skb_put_u8(skb_out,
+ 			   (unsigned char)((accm | (0xff << (bitno - 8))) >> 24));
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  
  	/*
  	 * Increase code size if we would have without the packet
@@@ -698,7 -699,7 +703,11 @@@ static int bsd_decompress(void *state, 
  	db->bytes_out += ilen;
  
  	if (skb_tailroom(skb_out) > 0)
++<<<<<<< HEAD
 +		*(skb_put(skb_out, 1)) = 0;
++=======
+ 		skb_put_u8(skb_out, 0);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  	else
  		return DECOMP_ERR_NOMEM;
  
@@@ -816,7 -817,7 +825,11 @@@
  #endif
  
  		if (extra)		/* the KwKwK case again */
++<<<<<<< HEAD
 +			*(skb_put(skb_out, 1)) = finchar;
++=======
+ 			skb_put_u8(skb_out, finchar);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  
  		/*
  		 * If not first code in a packet, and
diff --cc drivers/isdn/i4l/isdn_x25iface.c
index 0c5d8de41b23,48bfbcb4a09d..000000000000
--- a/drivers/isdn/i4l/isdn_x25iface.c
+++ b/drivers/isdn/i4l/isdn_x25iface.c
@@@ -224,7 -224,7 +224,11 @@@ static int isdn_x25iface_connect_ind(st
  
  	skb = dev_alloc_skb(1);
  	if (skb) {
++<<<<<<< HEAD
 +		*(skb_put(skb, 1)) = X25_IFACE_CONNECT;
++=======
+ 		skb_put_u8(skb, X25_IFACE_CONNECT);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  		skb->protocol = x25_type_trans(skb, cprot->net_dev);
  		netif_rx(skb);
  		return 0;
@@@ -253,7 -253,7 +257,11 @@@ static int isdn_x25iface_disconn_ind(st
  	*state_p = WAN_DISCONNECTED;
  	skb = dev_alloc_skb(1);
  	if (skb) {
++<<<<<<< HEAD
 +		*(skb_put(skb, 1)) = X25_IFACE_DISCONNECT;
++=======
+ 		skb_put_u8(skb, X25_IFACE_DISCONNECT);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  		skb->protocol = x25_type_trans(skb, cprot->net_dev);
  		netif_rx(skb);
  		return 0;
diff --cc drivers/net/hamradio/scc.c
index 52c1dd327fe2,295f267b73ea..000000000000
--- a/drivers/net/hamradio/scc.c
+++ b/drivers/net/hamradio/scc.c
@@@ -540,7 -540,7 +540,11 @@@ static inline void scc_rxint(struct scc
  		}
  		
  		scc->rx_buff = skb;
++<<<<<<< HEAD
 +		*(skb_put(skb, 1)) = 0;	/* KISS data */
++=======
+ 		skb_put_u8(skb, 0);	/* KISS data */
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  	}
  	
  	if (skb->len >= scc->stat.bufsize)
@@@ -555,7 -555,7 +559,11 @@@
  		return;
  	}
  
++<<<<<<< HEAD
 +	*(skb_put(skb, 1)) = Inb(scc->data);
++=======
+ 	skb_put_u8(skb, Inb(scc->data));
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  }
  
  
diff --cc drivers/net/usb/cdc_ncm.c
index 3e582e83ebb5,bcb974707118..000000000000
--- a/drivers/net/usb/cdc_ncm.c
+++ b/drivers/net/usb/cdc_ncm.c
@@@ -1246,11 -1245,13 +1246,21 @@@ cdc_ncm_fill_tx_frame(struct usbnet *de
  	 * a ZLP after full sized NTBs.
  	 */
  	if (!(dev->driver_info->flags & FLAG_SEND_ZLP) &&
++<<<<<<< HEAD
 +	    skb_out->len > ctx->min_tx_pkt)
 +		memset(skb_put(skb_out, ctx->tx_max - skb_out->len), 0,
 +		       ctx->tx_max - skb_out->len);
 +	else if (skb_out->len < ctx->tx_max && (skb_out->len % dev->maxpacket) == 0)
 +		*(u8 *)skb_put(skb_out, 1) = 0;	/* force short packet */
++=======
+ 	    skb_out->len > ctx->min_tx_pkt) {
+ 		padding_count = ctx->tx_max - skb_out->len;
+ 		skb_put_zero(skb_out, padding_count);
+ 	} else if (skb_out->len < ctx->tx_max &&
+ 		   (skb_out->len % dev->maxpacket) == 0) {
+ 		skb_put_u8(skb_out, 0);	/* force short packet */
+ 	}
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  
  	/* set final frame length */
  	nth16 = (struct usb_cdc_ncm_nth16 *)skb_out->data;
diff --cc drivers/nfc/microread/i2c.c
index 101089495bf8,b668b7b9a61e..000000000000
--- a/drivers/nfc/microread/i2c.c
+++ b/drivers/nfc/microread/i2c.c
@@@ -77,7 -75,7 +77,11 @@@ static void microread_i2c_add_len_crc(s
  	for (i = 0; i < skb->len; i++)
  		crc = crc ^ skb->data[i];
  
++<<<<<<< HEAD
 +	*skb_put(skb, 1) = crc;
++=======
+ 	skb_put_u8(skb, crc);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  }
  
  static void microread_i2c_remove_len_crc(struct sk_buff *skb)
@@@ -182,7 -173,7 +186,11 @@@ static int microread_i2c_read(struct mi
  		goto flush;
  	}
  
++<<<<<<< HEAD
 +	*skb_put(*skb, 1) = len;
++=======
+ 	skb_put_u8(*skb, len);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  
  	r = i2c_master_recv(client, skb_put(*skb, len), len);
  	if (r != len) {
diff --cc drivers/nfc/microread/microread.c
index 3420d833db17,e5d5d2d97409..000000000000
--- a/drivers/nfc/microread/microread.c
+++ b/drivers/nfc/microread/microread.c
@@@ -441,8 -441,8 +441,13 @@@ static int microread_im_transceive(stru
  
  		crc = crc_ccitt(0xffff, skb->data, skb->len);
  		crc = ~crc;
++<<<<<<< HEAD
 +		*skb_put(skb, 1) = crc & 0xff;
 +		*skb_put(skb, 1) = crc >> 8;
++=======
+ 		skb_put_u8(skb, crc & 0xff);
+ 		skb_put_u8(skb, crc >> 8);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  		break;
  	case MICROREAD_GATE_ID_MREAD_NFC_T3:
  		control_bits = 0xDB;
diff --cc drivers/nfc/pn533.c
index 8f6f2baa930d,c8a8f5badb5b..000000000000
--- a/drivers/nfc/pn533.c
+++ b/drivers/nfc/pn533.c
@@@ -1528,14 -1032,13 +1528,18 @@@ static struct sk_buff *pn533_alloc_poll
  		return NULL;
  
  	/* DEP support only */
++<<<<<<< HEAD:drivers/nfc/pn533.c
 +	*skb_put(skb, 1) = PN533_INIT_TARGET_DEP;
++=======
+ 	skb_put_u8(skb, PN533_INIT_TARGET_DEP);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8()):drivers/nfc/pn533/pn533.c
  
  	/* MIFARE params */
 -	skb_put_data(skb, mifare_params, 6);
 +	memcpy(skb_put(skb, 6), mifare_params, 6);
  
  	/* Felica params */
 -	felica = skb_put_data(skb, felica_params, 18);
 +	felica = skb_put(skb, 18);
 +	memcpy(felica, felica_params, 18);
  	get_random_bytes(felica + 2, 6);
  
  	/* NFCID3 */
@@@ -1544,13 -1046,12 +1548,21 @@@
  	memcpy(nfcid3, felica, 8);
  
  	/* General bytes */
++<<<<<<< HEAD:drivers/nfc/pn533.c
 +	*skb_put(skb, 1) = gbytes_len;
++=======
+ 	skb_put_u8(skb, gbytes_len);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8()):drivers/nfc/pn533/pn533.c
  
 -	gb = skb_put_data(skb, gbytes, gbytes_len);
 +	gb = skb_put(skb, gbytes_len);
 +	memcpy(gb, gbytes, gbytes_len);
  
  	/* Len Tk */
++<<<<<<< HEAD:drivers/nfc/pn533.c
 +	*skb_put(skb, 1) = 0;
++=======
+ 	skb_put_u8(skb, 0);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8()):drivers/nfc/pn533/pn533.c
  
  	return skb;
  }
@@@ -1654,7 -1242,163 +1666,167 @@@ static void pn533_listen_mode_timer(uns
  
  	pn533_poll_next_mod(dev);
  
++<<<<<<< HEAD:drivers/nfc/pn533.c
 +	queue_work(dev->wq, &dev->poll_work);
++=======
+ 	queue_delayed_work(dev->wq, &dev->poll_work,
+ 			   msecs_to_jiffies(PN533_POLL_INTERVAL));
+ }
+ 
+ static int pn533_rf_complete(struct pn533 *dev, void *arg,
+ 			     struct sk_buff *resp)
+ {
+ 	int rc = 0;
+ 
+ 	dev_dbg(dev->dev, "%s\n", __func__);
+ 
+ 	if (IS_ERR(resp)) {
+ 		rc = PTR_ERR(resp);
+ 
+ 		nfc_err(dev->dev, "RF setting error %d\n", rc);
+ 
+ 		return rc;
+ 	}
+ 
+ 	queue_delayed_work(dev->wq, &dev->poll_work,
+ 			   msecs_to_jiffies(PN533_POLL_INTERVAL));
+ 
+ 	dev_kfree_skb(resp);
+ 	return rc;
+ }
+ 
+ static void pn533_wq_rf(struct work_struct *work)
+ {
+ 	struct pn533 *dev = container_of(work, struct pn533, rf_work);
+ 	struct sk_buff *skb;
+ 	int rc;
+ 
+ 	dev_dbg(dev->dev, "%s\n", __func__);
+ 
+ 	skb = pn533_alloc_skb(dev, 2);
+ 	if (!skb)
+ 		return;
+ 
+ 	skb_put_u8(skb, PN533_CFGITEM_RF_FIELD);
+ 	skb_put_u8(skb, PN533_CFGITEM_RF_FIELD_AUTO_RFCA);
+ 
+ 	rc = pn533_send_cmd_async(dev, PN533_CMD_RF_CONFIGURATION, skb,
+ 				  pn533_rf_complete, NULL);
+ 	if (rc < 0) {
+ 		dev_kfree_skb(skb);
+ 		nfc_err(dev->dev, "RF setting error %d\n", rc);
+ 	}
+ }
+ 
+ static int pn533_poll_dep_complete(struct pn533 *dev, void *arg,
+ 				   struct sk_buff *resp)
+ {
+ 	struct pn533_cmd_jump_dep_response *rsp;
+ 	struct nfc_target nfc_target;
+ 	u8 target_gt_len;
+ 	int rc;
+ 
+ 	if (IS_ERR(resp))
+ 		return PTR_ERR(resp);
+ 
+ 	rsp = (struct pn533_cmd_jump_dep_response *)resp->data;
+ 
+ 	rc = rsp->status & PN533_CMD_RET_MASK;
+ 	if (rc != PN533_CMD_RET_SUCCESS) {
+ 		/* Not target found, turn radio off */
+ 		queue_work(dev->wq, &dev->rf_work);
+ 
+ 		dev_kfree_skb(resp);
+ 		return 0;
+ 	}
+ 
+ 	dev_dbg(dev->dev, "Creating new target");
+ 
+ 	nfc_target.supported_protocols = NFC_PROTO_NFC_DEP_MASK;
+ 	nfc_target.nfcid1_len = 10;
+ 	memcpy(nfc_target.nfcid1, rsp->nfcid3t, nfc_target.nfcid1_len);
+ 	rc = nfc_targets_found(dev->nfc_dev, &nfc_target, 1);
+ 	if (rc)
+ 		goto error;
+ 
+ 	dev->tgt_available_prots = 0;
+ 	dev->tgt_active_prot = NFC_PROTO_NFC_DEP;
+ 
+ 	/* ATR_RES general bytes are located at offset 17 */
+ 	target_gt_len = resp->len - 17;
+ 	rc = nfc_set_remote_general_bytes(dev->nfc_dev,
+ 					  rsp->gt, target_gt_len);
+ 	if (!rc) {
+ 		rc = nfc_dep_link_is_up(dev->nfc_dev,
+ 					dev->nfc_dev->targets[0].idx,
+ 					0, NFC_RF_INITIATOR);
+ 
+ 		if (!rc)
+ 			pn533_poll_reset_mod_list(dev);
+ 	}
+ error:
+ 	dev_kfree_skb(resp);
+ 	return rc;
+ }
+ 
+ #define PASSIVE_DATA_LEN 5
+ static int pn533_poll_dep(struct nfc_dev *nfc_dev)
+ {
+ 	struct pn533 *dev = nfc_get_drvdata(nfc_dev);
+ 	struct sk_buff *skb;
+ 	int rc, skb_len;
+ 	u8 *next, nfcid3[NFC_NFCID3_MAXSIZE];
+ 	u8 passive_data[PASSIVE_DATA_LEN] = {0x00, 0xff, 0xff, 0x00, 0x3};
+ 
+ 	dev_dbg(dev->dev, "%s", __func__);
+ 
+ 	if (!dev->gb) {
+ 		dev->gb = nfc_get_local_general_bytes(nfc_dev, &dev->gb_len);
+ 
+ 		if (!dev->gb || !dev->gb_len) {
+ 			dev->poll_dep = 0;
+ 			queue_work(dev->wq, &dev->rf_work);
+ 		}
+ 	}
+ 
+ 	skb_len = 3 + dev->gb_len; /* ActPass + BR + Next */
+ 	skb_len += PASSIVE_DATA_LEN;
+ 
+ 	/* NFCID3 */
+ 	skb_len += NFC_NFCID3_MAXSIZE;
+ 	nfcid3[0] = 0x1;
+ 	nfcid3[1] = 0xfe;
+ 	get_random_bytes(nfcid3 + 2, 6);
+ 
+ 	skb = pn533_alloc_skb(dev, skb_len);
+ 	if (!skb)
+ 		return -ENOMEM;
+ 
+ 	skb_put_u8(skb, 0x01);  /* Active */
+ 	skb_put_u8(skb, 0x02);  /* 424 kbps */
+ 
+ 	next = skb_put(skb, 1);  /* Next */
+ 	*next = 0;
+ 
+ 	/* Copy passive data */
+ 	skb_put_data(skb, passive_data, PASSIVE_DATA_LEN);
+ 	*next |= 1;
+ 
+ 	/* Copy NFCID3 (which is NFCID2 from SENSF_RES) */
+ 	skb_put_data(skb, nfcid3, NFC_NFCID3_MAXSIZE);
+ 	*next |= 2;
+ 
+ 	skb_put_data(skb, dev->gb, dev->gb_len);
+ 	*next |= 4; /* We have some Gi */
+ 
+ 	rc = pn533_send_cmd_async(dev, PN533_CMD_IN_JUMP_FOR_DEP, skb,
+ 				  pn533_poll_dep_complete, NULL);
+ 
+ 	if (rc < 0)
+ 		dev_kfree_skb(skb);
+ 
+ 	return rc;
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8()):drivers/nfc/pn533/pn533.c
  }
  
  static int pn533_poll_complete(struct pn533 *dev, void *arg,
@@@ -1860,8 -1620,8 +2032,13 @@@ static int pn533_activate_target_nfcdep
  	if (!skb)
  		return -ENOMEM;
  
++<<<<<<< HEAD:drivers/nfc/pn533.c
 +	*skb_put(skb, sizeof(u8)) = 1; /* TG */
 +	*skb_put(skb, sizeof(u8)) = 0; /* Next */
++=======
+ 	skb_put_u8(skb, 1); /* TG */
+ 	skb_put_u8(skb, 0); /* Next */
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8()):drivers/nfc/pn533/pn533.c
  
  	resp = pn533_send_cmd_sync(dev, PN533_CMD_IN_ATR, skb);
  	if (IS_ERR(resp))
@@@ -1957,19 -1737,14 +2134,23 @@@ static void pn533_deactivate_target(str
  	if (!skb)
  		return;
  
++<<<<<<< HEAD:drivers/nfc/pn533.c
 +	*skb_put(skb, 1) = 1; /* TG*/
++=======
+ 	skb_put_u8(skb, 1); /* TG*/
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8()):drivers/nfc/pn533/pn533.c
 +
 +	resp = pn533_send_cmd_sync(dev, PN533_CMD_IN_RELEASE, skb);
 +	if (IS_ERR(resp))
 +		return;
 +
 +	rc = resp->data[0] & PN533_CMD_RET_MASK;
 +	if (rc != PN533_CMD_RET_SUCCESS)
 +		nfc_dev_err(&dev->interface->dev,
 +			    "Error 0x%x when releasing the target", rc);
  
 -	rc = pn533_send_cmd_async(dev, PN533_CMD_IN_RELEASE, skb,
 -				  pn533_deactivate_target_complete, NULL);
 -	if (rc < 0) {
 -		dev_kfree_skb(skb);
 -		nfc_err(dev->dev, "Target release error %d\n", rc);
 -	}
 +	dev_kfree_skb(resp);
 +	return;
  }
  
  
@@@ -2088,8 -1848,8 +2269,13 @@@ static int pn533_dep_link_up(struct nfc
  	if (!skb)
  		return -ENOMEM;
  
++<<<<<<< HEAD:drivers/nfc/pn533.c
 +	*skb_put(skb, 1) = !comm_mode;  /* ActPass */
 +	*skb_put(skb, 1) = baud;  /* Baud rate */
++=======
+ 	skb_put_u8(skb, !comm_mode);  /* ActPass */
+ 	skb_put_u8(skb, 0x02);  /* 424 kbps */
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8()):drivers/nfc/pn533/pn533.c
  
  	next = skb_put(skb, 1);  /* Next */
  	*next = 0;
@@@ -2381,7 -2274,7 +2567,11 @@@ static void pn533_wq_mi_recv(struct wor
  			break;
  		}
  	default:
++<<<<<<< HEAD:drivers/nfc/pn533.c
 +		*skb_put(skb, sizeof(u8)) =  1; /*TG*/
++=======
+ 		skb_put_u8(skb, 1); /*TG*/
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8()):drivers/nfc/pn533/pn533.c
  
  		rc = pn533_send_cmd_direct_async(dev,
  						 PN533_CMD_IN_DATA_EXCHANGE,
@@@ -2422,8 -2370,8 +2612,13 @@@ static int pn533_set_configuration(stru
  	if (!skb)
  		return -ENOMEM;
  
++<<<<<<< HEAD:drivers/nfc/pn533.c
 +	*skb_put(skb, sizeof(cfgitem)) = cfgitem;
 +	memcpy(skb_put(skb, cfgdata_len), cfgdata, cfgdata_len);
++=======
+ 	skb_put_u8(skb, cfgitem);
+ 	skb_put_data(skb, cfgdata, cfgdata_len);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8()):drivers/nfc/pn533/pn533.c
  
  	resp = pn533_send_cmd_sync(dev, PN533_CMD_RF_CONFIGURATION, skb);
  	if (IS_ERR(resp))
@@@ -2467,7 -2415,7 +2662,11 @@@ static int pn533_pasori_fw_reset(struc
  	if (!skb)
  		return -ENOMEM;
  
++<<<<<<< HEAD:drivers/nfc/pn533.c
 +	*skb_put(skb, sizeof(u8)) = 0x1;
++=======
+ 	skb_put_u8(skb, 0x1);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8()):drivers/nfc/pn533/pn533.c
  
  	resp = pn533_send_cmd_sync(dev, 0x18, skb);
  	if (IS_ERR(resp))
@@@ -2561,8 -2444,37 +2760,40 @@@ static int pn533_rf_field(struct nfc_de
  	return rc;
  }
  
 -static int pn532_sam_configuration(struct nfc_dev *nfc_dev)
 +int pn533_dev_up(struct nfc_dev *nfc_dev)
  {
++<<<<<<< HEAD:drivers/nfc/pn533.c
++=======
+ 	struct pn533 *dev = nfc_get_drvdata(nfc_dev);
+ 	struct sk_buff *skb;
+ 	struct sk_buff *resp;
+ 
+ 	skb = pn533_alloc_skb(dev, 1);
+ 	if (!skb)
+ 		return -ENOMEM;
+ 
+ 	skb_put_u8(skb, 0x01);
+ 
+ 	resp = pn533_send_cmd_sync(dev, PN533_CMD_SAM_CONFIGURATION, skb);
+ 	if (IS_ERR(resp))
+ 		return PTR_ERR(resp);
+ 
+ 	dev_kfree_skb(resp);
+ 	return 0;
+ }
+ 
+ static int pn533_dev_up(struct nfc_dev *nfc_dev)
+ {
+ 	struct pn533 *dev = nfc_get_drvdata(nfc_dev);
+ 
+ 	if (dev->device_type == PN533_DEVICE_PN532) {
+ 		int rc = pn532_sam_configuration(nfc_dev);
+ 
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8()):drivers/nfc/pn533/pn533.c
  	return pn533_rf_field(nfc_dev, 1);
  }
  
diff --cc drivers/nfc/pn544/i2c.c
index 8cf64c19f022,fedde9d46ab6..000000000000
--- a/drivers/nfc/pn544/i2c.c
+++ b/drivers/nfc/pn544/i2c.c
@@@ -166,8 -287,8 +166,13 @@@ static void pn544_hci_i2c_add_len_crc(s
  
  	crc = crc_ccitt(0xffff, skb->data, skb->len);
  	crc = ~crc;
++<<<<<<< HEAD
 +	*skb_put(skb, 1) = crc & 0xff;
 +	*skb_put(skb, 1) = crc >> 8;
++=======
+ 	skb_put_u8(skb, crc & 0xff);
+ 	skb_put_u8(skb, crc >> 8);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  }
  
  static void pn544_hci_i2c_remove_len_crc(struct sk_buff *skb)
@@@ -272,7 -391,7 +277,11 @@@ static int pn544_hci_i2c_read(struct pn
  		goto flush;
  	}
  
++<<<<<<< HEAD
 +	*skb_put(*skb, 1) = len;
++=======
+ 	skb_put_u8(*skb, len);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  
  	r = i2c_master_recv(client, skb_put(*skb, len), len);
  	if (r != len) {
diff --cc include/linux/skbuff.h
index dee52dfc1c40,852feacf4bbf..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -2014,10 -1928,7 +2014,14 @@@ static inline void skb_put_u8(struct sk
  	*(u8 *)skb_put(skb, 1) = val;
  }
  
++<<<<<<< HEAD
 +RH_KABI_REPLACE_UNSAFE(
 +	unsigned char *skb_push(struct sk_buff *skb, unsigned int len),
 +	void *skb_push(struct sk_buff *skb, unsigned int len)
 +)
++=======
+ void *skb_push(struct sk_buff *skb, unsigned int len);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  static inline void *__skb_push(struct sk_buff *skb, unsigned int len)
  {
  	skb->data -= len;
diff --cc net/bluetooth/hci_sock.c
index 03a6c436b668,65d734c165bd..000000000000
--- a/net/bluetooth/hci_sock.c
+++ b/net/bluetooth/hci_sock.c
@@@ -515,10 -515,10 +515,15 @@@ static struct sk_buff *create_monitor_c
  
  	put_unaligned_le32(hci_pi(sk)->cookie, skb_put(skb, 4));
  	put_unaligned_le16(format, skb_put(skb, 2));
 -	skb_put_data(skb, ver, sizeof(ver));
 +	memcpy(skb_put(skb, sizeof(ver)), ver, sizeof(ver));
  	put_unaligned_le32(flags, skb_put(skb, 4));
++<<<<<<< HEAD
 +	*(u8 *)skb_put(skb, 1) = TASK_COMM_LEN;
 +	memcpy(skb_put(skb, TASK_COMM_LEN), hci_pi(sk)->comm, TASK_COMM_LEN);
++=======
+ 	skb_put_u8(skb, TASK_COMM_LEN);
+ 	skb_put_data(skb, hci_pi(sk)->comm, TASK_COMM_LEN);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  
  	__net_timestamp(skb);
  
diff --cc net/decnet/dn_nsp_out.c
index 1aaa51ebbda6,66f035e476ea..000000000000
--- a/net/decnet/dn_nsp_out.c
+++ b/net/decnet/dn_nsp_out.c
@@@ -530,10 -530,10 +530,14 @@@ void dn_send_conn_conf(struct sock *sk
  	msg->info = scp->info_loc;
  	msg->segsize = cpu_to_le16(scp->segsize_loc);
  
++<<<<<<< HEAD
 +	*skb_put(skb,1) = len;
++=======
+ 	skb_put_u8(skb, len);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  
  	if (len > 0)
 -		skb_put_data(skb, scp->conndata_out.opt_data, len);
 +		memcpy(skb_put(skb, len), scp->conndata_out.opt_data, len);
  
  
  	dn_nsp_send(skb);
@@@ -686,27 -686,27 +690,46 @@@ void dn_nsp_send_conninit(struct sock *
  	if (scp->peer.sdn_flags & SDF_UICPROXY)
  		menuver |= DN_MENUVER_UIC;
  
++<<<<<<< HEAD
 +	*skb_put(skb, 1) = menuver;	/* Menu Version		*/
 +
 +	aux = scp->accessdata.acc_userl;
 +	*skb_put(skb, 1) = aux;
++=======
+ 	skb_put_u8(skb, menuver);	/* Menu Version		*/
+ 
+ 	aux = scp->accessdata.acc_userl;
+ 	skb_put_u8(skb, aux);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  	if (aux > 0)
 -		skb_put_data(skb, scp->accessdata.acc_user, aux);
 +		memcpy(skb_put(skb, aux), scp->accessdata.acc_user, aux);
  
  	aux = scp->accessdata.acc_passl;
++<<<<<<< HEAD
 +	*skb_put(skb, 1) = aux;
++=======
+ 	skb_put_u8(skb, aux);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  	if (aux > 0)
 -		skb_put_data(skb, scp->accessdata.acc_pass, aux);
 +		memcpy(skb_put(skb, aux), scp->accessdata.acc_pass, aux);
  
  	aux = scp->accessdata.acc_accl;
++<<<<<<< HEAD
 +	*skb_put(skb, 1) = aux;
++=======
+ 	skb_put_u8(skb, aux);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  	if (aux > 0)
 -		skb_put_data(skb, scp->accessdata.acc_acc, aux);
 +		memcpy(skb_put(skb, aux), scp->accessdata.acc_acc, aux);
  
  	aux = (__u8)le16_to_cpu(scp->conndata_out.opt_optl);
++<<<<<<< HEAD
 +	*skb_put(skb, 1) = aux;
++=======
+ 	skb_put_u8(skb, aux);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  	if (aux > 0)
 -		skb_put_data(skb, scp->conndata_out.opt_data, aux);
 +		memcpy(skb_put(skb, aux), scp->conndata_out.opt_data, aux);
  
  	scp->persist = dn_nsp_persist(sk);
  	scp->persist_fxn = dn_nsp_retrans_conninit;
diff --cc net/nfc/hci/core.c
index 91020b210d87,b740fef0acc5..000000000000
--- a/net/nfc/hci/core.c
+++ b/net/nfc/hci/core.c
@@@ -746,7 -874,7 +746,11 @@@ static void nfc_hci_recv_from_llc(struc
  			return;
  		}
  
++<<<<<<< HEAD
 +		*skb_put(hcp_skb, NFC_HCI_HCP_PACKET_HEADER_LEN) = pipe;
++=======
+ 		skb_put_u8(hcp_skb, pipe);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  
  		skb_queue_walk(&hdev->rx_hcp_frags, frag_skb) {
  			msg_len = frag_skb->len - NFC_HCI_HCP_PACKET_HEADER_LEN;
diff --cc net/nfc/hci/llc_shdlc.c
index 27b313befc35,17e59a009ce6..000000000000
--- a/net/nfc/hci/llc_shdlc.c
+++ b/net/nfc/hci/llc_shdlc.c
@@@ -384,8 -382,8 +384,13 @@@ static int llc_shdlc_connect_initiate(s
  	if (skb == NULL)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	*skb_put(skb, 1) = SHDLC_MAX_WINDOW;
 +	*skb_put(skb, 1) = SHDLC_SREJ_SUPPORT ? 1 : 0;
++=======
+ 	skb_put_u8(skb, SHDLC_MAX_WINDOW);
+ 	skb_put_u8(skb, SHDLC_SREJ_SUPPORT ? 1 : 0);
++>>>>>>> 634fef61076d (networking: add and use skb_put_u8())
  
  	return llc_shdlc_send_u_frame(shdlc, skb, U_FRAME_RSET);
  }
* Unmerged path drivers/bluetooth/hci_nokia.c
* Unmerged path drivers/nfc/fdp/i2c.c
* Unmerged path drivers/nfc/nfcmrvl/fw_dnld.c
* Unmerged path drivers/nfc/port100.c
* Unmerged path drivers/nfc/st21nfca/i2c.c
* Unmerged path drivers/nfc/st95hf/core.c
* Unmerged path net/nfc/digital_core.c
* Unmerged path net/nfc/digital_dep.c
* Unmerged path net/nfc/digital_technology.c
* Unmerged path net/nfc/nci/hci.c
* Unmerged path net/nfc/nci/spi.c
* Unmerged path net/nfc/nci/uart.c
* Unmerged path drivers/bluetooth/bluecard_cs.c
* Unmerged path drivers/bluetooth/bt3c_cs.c
* Unmerged path drivers/bluetooth/btuart_cs.c
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 7d3fe5357eb2..e7863b0ccd32 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -1837,7 +1837,7 @@ static int inject_cmd_complete(struct hci_dev *hdev, __u16 opcode)
 	evt->ncmd = 0x01;
 	evt->opcode = cpu_to_le16(opcode);
 
-	*(u8 *)skb_put(skb, 1) = 0x00;
+	skb_put_u8(skb, 0x00);
 
 	hci_skb_pkt_type(skb) = HCI_EVENT_PKT;
 
@@ -2756,8 +2756,8 @@ static struct urb *alloc_diag_urb(struct hci_dev *hdev, bool enable)
 		return ERR_PTR(-ENOMEM);
 	}
 
-	*(u8 *)skb_put(skb, 1) = 0xf0;
-	*(u8 *)skb_put(skb, 1) = enable;
+	skb_put_u8(skb, 0xf0);
+	skb_put_u8(skb, enable);
 
 	pipe = usb_sndbulkpipe(data->udev, data->diag_tx_ep->bEndpointAddress);
 
* Unmerged path drivers/bluetooth/dtl1_cs.c
* Unmerged path drivers/bluetooth/hci_bcm.c
* Unmerged path drivers/bluetooth/hci_intel.c
* Unmerged path drivers/bluetooth/hci_nokia.c
* Unmerged path drivers/bluetooth/hci_qca.c
diff --git a/drivers/bluetooth/hci_vhci.c b/drivers/bluetooth/hci_vhci.c
index 817fb6a4da24..cf0ad20f5d03 100644
--- a/drivers/bluetooth/hci_vhci.c
+++ b/drivers/bluetooth/hci_vhci.c
@@ -146,8 +146,8 @@ static int __vhci_create_device(struct vhci_data *data, __u8 opcode)
 
 	hci_skb_pkt_type(skb) = HCI_VENDOR_PKT;
 
-	*(u8 *)skb_put(skb, 1) = 0xff;
-	*(u8 *)skb_put(skb, 1) = opcode;
+	skb_put_u8(skb, 0xff);
+	skb_put_u8(skb, opcode);
 	put_unaligned_le16(hdev->id, skb_put(skb, 2));
 	skb_queue_tail(&data->readq, skb);
 
diff --git a/drivers/isdn/capi/capi.c b/drivers/isdn/capi/capi.c
index 7ebdd9466f94..3ffdec2763de 100644
--- a/drivers/isdn/capi/capi.c
+++ b/drivers/isdn/capi/capi.c
@@ -1082,7 +1082,7 @@ static int capinc_tty_put_char(struct tty_struct *tty, unsigned char ch)
 	skb = mp->outskb;
 	if (skb) {
 		if (skb_tailroom(skb) > 0) {
-			*(u8 *)skb_put(skb, 1) = ch;
+			skb_put_u8(skb, ch);
 			goto unlock_out;
 		}
 		mp->outskb = NULL;
@@ -1094,7 +1094,7 @@ static int capinc_tty_put_char(struct tty_struct *tty, unsigned char ch)
 	skb = alloc_skb(CAPI_DATA_B3_REQ_LEN + CAPI_MAX_BLKSIZE, GFP_ATOMIC);
 	if (skb) {
 		skb_reserve(skb, CAPI_DATA_B3_REQ_LEN);
-		*(u8 *)skb_put(skb, 1) = ch;
+		skb_put_u8(skb, ch);
 		mp->outskb = skb;
 	} else {
 		printk(KERN_ERR "capinc_put_char: char %u lost\n", ch);
diff --git a/drivers/isdn/gigaset/asyncdata.c b/drivers/isdn/gigaset/asyncdata.c
index 03ac9fbfe318..4caecdcc6f29 100644
--- a/drivers/isdn/gigaset/asyncdata.c
+++ b/drivers/isdn/gigaset/asyncdata.c
@@ -492,33 +492,33 @@ static struct sk_buff *HDLC_Encode(struct sk_buff *skb)
 	hdlc_skb->mac_len = skb->mac_len;
 
 	/* Add flag sequence in front of everything.. */
-	*(u8 *)skb_put(hdlc_skb, 1) = PPP_FLAG;
+	skb_put_u8(hdlc_skb, PPP_FLAG);
 
 	/* Perform byte stuffing while copying data. */
 	while (skb->len--) {
 		if (muststuff(*skb->data)) {
-			*(u8 *)skb_put(hdlc_skb, 1) = PPP_ESCAPE;
-			*(u8 *)skb_put(hdlc_skb, 1) = (*skb->data++) ^ PPP_TRANS;
+			skb_put_u8(hdlc_skb, PPP_ESCAPE);
+			skb_put_u8(hdlc_skb, (*skb->data++) ^ PPP_TRANS);
 		} else
-			*(u8 *)skb_put(hdlc_skb, 1) = *skb->data++;
+			skb_put_u8(hdlc_skb, *skb->data++);
 	}
 
 	/* Finally add FCS (byte stuffed) and flag sequence */
 	c = (fcs & 0x00ff);	/* least significant byte first */
 	if (muststuff(c)) {
-		*(u8 *)skb_put(hdlc_skb, 1) = PPP_ESCAPE;
+		skb_put_u8(hdlc_skb, PPP_ESCAPE);
 		c ^= PPP_TRANS;
 	}
-	*(u8 *)skb_put(hdlc_skb, 1) = c;
+	skb_put_u8(hdlc_skb, c);
 
 	c = ((fcs >> 8) & 0x00ff);
 	if (muststuff(c)) {
-		*(u8 *)skb_put(hdlc_skb, 1) = PPP_ESCAPE;
+		skb_put_u8(hdlc_skb, PPP_ESCAPE);
 		c ^= PPP_TRANS;
 	}
-	*(u8 *)skb_put(hdlc_skb, 1) = c;
+	skb_put_u8(hdlc_skb, c);
 
-	*(u8 *)skb_put(hdlc_skb, 1) = PPP_FLAG;
+	skb_put_u8(hdlc_skb, PPP_FLAG);
 
 	dev_kfree_skb_any(skb);
 	return hdlc_skb;
@@ -561,8 +561,8 @@ static struct sk_buff *iraw_encode(struct sk_buff *skb)
 	while (len--) {
 		c = bitrev8(*cp++);
 		if (c == DLE_FLAG)
-			*(u8 *)skb_put(iraw_skb, 1) = c;
-		*(u8 *)skb_put(iraw_skb, 1) = c;
+			skb_put_u8(iraw_skb, c);
+		skb_put_u8(iraw_skb, c);
 	}
 	dev_kfree_skb_any(skb);
 	return iraw_skb;
* Unmerged path drivers/isdn/i4l/isdn_bsdcomp.c
* Unmerged path drivers/isdn/i4l/isdn_x25iface.c
* Unmerged path drivers/net/hamradio/scc.c
* Unmerged path drivers/net/usb/cdc_ncm.c
diff --git a/drivers/net/usb/net1080.c b/drivers/net/usb/net1080.c
index 861ff45f0b09..c6d113ef6bab 100644
--- a/drivers/net/usb/net1080.c
+++ b/drivers/net/usb/net1080.c
@@ -473,7 +473,7 @@ encapsulate:
 
 	/* maybe pad; then trailer */
 	if (!((skb->len + sizeof *trailer) & 0x01))
-		*(u8 *)skb_put(skb, 1) = PAD_BYTE;
+		skb_put_u8(skb, PAD_BYTE);
 	trailer = skb_put(skb, sizeof *trailer);
 	put_unaligned(header->packet_id, &trailer->packet_id);
 #if 0
diff --git a/drivers/net/usb/zaurus.c b/drivers/net/usb/zaurus.c
index dc3cd03763af..9c2196c3fd11 100644
--- a/drivers/net/usb/zaurus.c
+++ b/drivers/net/usb/zaurus.c
@@ -74,10 +74,10 @@ done:
 		fcs = crc32_le(~0, skb->data, skb->len);
 		fcs = ~fcs;
 
-		*(u8 *)skb_put(skb, 1) = fcs       & 0xff;
-		*(u8 *)skb_put(skb, 1) = (fcs>> 8) & 0xff;
-		*(u8 *)skb_put(skb, 1) = (fcs>>16) & 0xff;
-		*(u8 *)skb_put(skb, 1) = (fcs>>24) & 0xff;
+		skb_put_u8(skb, fcs & 0xff);
+		skb_put_u8(skb, (fcs >> 8) & 0xff);
+		skb_put_u8(skb, (fcs >> 16) & 0xff);
+		skb_put_u8(skb, (fcs >> 24) & 0xff);
 	}
 	return skb;
 }
* Unmerged path drivers/nfc/fdp/i2c.c
* Unmerged path drivers/nfc/microread/i2c.c
* Unmerged path drivers/nfc/microread/microread.c
* Unmerged path drivers/nfc/nfcmrvl/fw_dnld.c
* Unmerged path drivers/nfc/pn533.c
* Unmerged path drivers/nfc/pn544/i2c.c
* Unmerged path drivers/nfc/port100.c
* Unmerged path drivers/nfc/st21nfca/i2c.c
* Unmerged path drivers/nfc/st95hf/core.c
* Unmerged path include/linux/skbuff.h
* Unmerged path net/bluetooth/hci_sock.c
diff --git a/net/bluetooth/hidp/core.c b/net/bluetooth/hidp/core.c
index bb065657543d..fb525afa5c0d 100644
--- a/net/bluetooth/hidp/core.c
+++ b/net/bluetooth/hidp/core.c
@@ -112,7 +112,7 @@ static int hidp_send_message(struct hidp_session *session, struct socket *sock,
 		return -ENOMEM;
 	}
 
-	*(u8 *)skb_put(skb, 1) = hdr;
+	skb_put_u8(skb, hdr);
 	if (data && size > 0)
 		memcpy(skb_put(skb, size), data, size);
 
* Unmerged path net/decnet/dn_nsp_out.c
* Unmerged path net/nfc/digital_core.c
* Unmerged path net/nfc/digital_dep.c
* Unmerged path net/nfc/digital_technology.c
* Unmerged path net/nfc/hci/core.c
* Unmerged path net/nfc/hci/llc_shdlc.c
* Unmerged path net/nfc/nci/hci.c
* Unmerged path net/nfc/nci/spi.c
* Unmerged path net/nfc/nci/uart.c
