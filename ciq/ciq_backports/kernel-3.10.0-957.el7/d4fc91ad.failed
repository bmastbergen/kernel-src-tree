platform/x86: wmi: Probe data objects for read and write capabilities

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [platform] x86: wmi: Probe data objects for read and write capabilities (Jarod Wilson) [1562200]
Rebuild_FUZZ: 93.02%
commit-author Andy Lutomirski <luto@kernel.org>
commit d4fc91adfde11c41295d1cf001bdbec5d6879016
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d4fc91ad.failed

The Dell XPS 13 9350 has one RW data object, one RO data object, and one
totally inaccessible data object. Check for the existence of the
accessor methods and report in sysfs.

The docs also permit WQxx getters for single-instance objects to
take no parameters. Probe for that as well to avoid ACPICA warnings
about mismatched signatures.

	Signed-off-by: Andy Lutomirski <luto@kernel.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Mario Limonciello <mario_limonciello@dell.com>
	Cc: Pali Roh√°r <pali.rohar@gmail.com>
	Cc: linux-kernel@vger.kernel.org
	Cc: platform-driver-x86@vger.kernel.org
	Cc: linux-acpi@vger.kernel.org
	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>
(cherry picked from commit d4fc91adfde11c41295d1cf001bdbec5d6879016)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/platform/x86/wmi.c
#	include/linux/wmi.h
diff --cc drivers/platform/x86/wmi.c
index 84dcc7a04b0a,651693a5e0ea..000000000000
--- a/drivers/platform/x86/wmi.c
+++ b/drivers/platform/x86/wmi.c
@@@ -68,7 -67,8 +68,12 @@@ struct wmi_block 
  	struct acpi_device *acpi_device;
  	wmi_notify_handler handler;
  	void *handler_data;
++<<<<<<< HEAD
 +	struct device dev;
++=======
+ 
+ 	bool read_takes_no_args;	/* only defined if readable */
++>>>>>>> d4fc91adfde1 (platform/x86: wmi: Probe data objects for read and write capabilities)
  };
  
  
@@@ -210,15 -131,39 +215,39 @@@ static bool find_guid(const char *guid_
  		wblock = list_entry(p, struct wmi_block, list);
  		block = &wblock->gblock;
  
 -		if (memcmp(block->guid, &guid_input, 16) == 0) {
 +		if (memcmp(block->guid, guid_input, 16) == 0) {
  			if (out)
  				*out = wblock;
 -			return true;
 +			return 1;
  		}
  	}
 -	return false;
 +	return 0;
  }
  
+ static int get_subobj_info(acpi_handle handle, const char *pathname,
+ 			   struct acpi_device_info **info)
+ {
+ 	struct acpi_device_info *dummy_info, **info_ptr;
+ 	acpi_handle subobj_handle;
+ 	acpi_status status;
+ 
+ 	status = acpi_get_handle(handle, (char *)pathname, &subobj_handle);
+ 	if (status == AE_NOT_FOUND)
+ 		return -ENOENT;
+ 	else if (ACPI_FAILURE(status))
+ 		return -EIO;
+ 
+ 	info_ptr = info ? info : &dummy_info;
+ 	status = acpi_get_object_info(subobj_handle, info_ptr);
+ 	if (ACPI_FAILURE(status))
+ 		return -EIO;
+ 
+ 	if (!info)
+ 		kfree(dummy_info);
+ 
+ 	return 0;
+ }
+ 
  static acpi_status wmi_method_enable(struct wmi_block *wblock, int enable)
  {
  	struct guid_block *block = NULL;
@@@ -649,53 -632,227 +681,184 @@@ static struct attribute *wmi_attrs[] = 
  };
  ATTRIBUTE_GROUPS(wmi);
  
++<<<<<<< HEAD
++=======
+ static ssize_t notify_id_show(struct device *dev, struct device_attribute *attr,
+ 			      char *buf)
+ {
+ 	struct wmi_block *wblock = dev_to_wblock(dev);
+ 
+ 	return sprintf(buf, "%02X\n", (unsigned int)wblock->gblock.notify_id);
+ }
+ static DEVICE_ATTR_RO(notify_id);
+ 
+ static struct attribute *wmi_event_attrs[] = {
+ 	&dev_attr_notify_id.attr,
+ 	NULL,
+ };
+ ATTRIBUTE_GROUPS(wmi_event);
+ 
+ static ssize_t object_id_show(struct device *dev, struct device_attribute *attr,
+ 			      char *buf)
+ {
+ 	struct wmi_block *wblock = dev_to_wblock(dev);
+ 
+ 	return sprintf(buf, "%c%c\n", wblock->gblock.object_id[0],
+ 		       wblock->gblock.object_id[1]);
+ }
+ static DEVICE_ATTR_RO(object_id);
+ 
+ static ssize_t readable_show(struct device *dev, struct device_attribute *attr,
+ 			     char *buf)
+ {
+ 	struct wmi_device *wdev = dev_to_wdev(dev);
+ 
+ 	return sprintf(buf, "%d\n", (int)wdev->readable);
+ }
+ static DEVICE_ATTR_RO(readable);
+ 
+ static ssize_t writeable_show(struct device *dev, struct device_attribute *attr,
+ 			      char *buf)
+ {
+ 	struct wmi_device *wdev = dev_to_wdev(dev);
+ 
+ 	return sprintf(buf, "%d\n", (int)wdev->writeable);
+ }
+ static DEVICE_ATTR_RO(writeable);
+ 
+ static struct attribute *wmi_data_attrs[] = {
+ 	&dev_attr_object_id.attr,
+ 	&dev_attr_readable.attr,
+ 	&dev_attr_writeable.attr,
+ 	NULL,
+ };
+ ATTRIBUTE_GROUPS(wmi_data);
+ 
+ static struct attribute *wmi_method_attrs[] = {
+ 	&dev_attr_object_id.attr,
+ 	NULL,
+ };
+ ATTRIBUTE_GROUPS(wmi_method);
+ 
++>>>>>>> d4fc91adfde1 (platform/x86: wmi: Probe data objects for read and write capabilities)
  static int wmi_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
  {
 -	struct wmi_block *wblock = dev_to_wblock(dev);
 +	char guid_string[37];
  
 -	if (add_uevent_var(env, "MODALIAS=wmi:%pUL", wblock->gblock.guid))
 -		return -ENOMEM;
 +	struct wmi_block *wblock;
  
 -	if (add_uevent_var(env, "WMI_GUID=%pUL", wblock->gblock.guid))
 +	if (add_uevent_var(env, "MODALIAS="))
  		return -ENOMEM;
  
 -	return 0;
 -}
 -
 -static void wmi_dev_release(struct device *dev)
 -{
 -	struct wmi_block *wblock = dev_to_wblock(dev);
 -
 -	kfree(wblock);
 -}
 -
 -static int wmi_dev_match(struct device *dev, struct device_driver *driver)
 -{
 -	struct wmi_driver *wmi_driver =
 -		container_of(driver, struct wmi_driver, driver);
 -	struct wmi_block *wblock = dev_to_wblock(dev);
 -	const struct wmi_device_id *id = wmi_driver->id_table;
 -
 -	while (id->guid_string) {
 -		uuid_le driver_guid;
 +	wblock = dev_get_drvdata(dev);
 +	if (!wblock)
 +		return -ENOMEM;
  
 -		if (WARN_ON(uuid_le_to_bin(id->guid_string, &driver_guid)))
 -			continue;
 -		if (!memcmp(&driver_guid, wblock->gblock.guid, 16))
 -			return 1;
 +	sprintf(guid_string, "%pUL", wblock->gblock.guid);
  
 -		id++;
 -	}
 +	strcpy(&env->buf[env->buflen - 1], "wmi:");
 +	memcpy(&env->buf[env->buflen - 1 + 4], guid_string, 36);
 +	env->buflen += 40;
  
  	return 0;
  }
  
 -static int wmi_dev_probe(struct device *dev)
 +static void wmi_dev_free(struct device *dev)
  {
 -	struct wmi_block *wblock = dev_to_wblock(dev);
 -	struct wmi_driver *wdriver =
 -		container_of(dev->driver, struct wmi_driver, driver);
 -	int ret = 0;
 -
 -	if (ACPI_FAILURE(wmi_method_enable(wblock, 1)))
 -		dev_warn(dev, "failed to enable device -- probing anyway\n");
 +	struct wmi_block *wmi_block = container_of(dev, struct wmi_block, dev);
  
 -	if (wdriver->probe) {
 -		ret = wdriver->probe(dev_to_wdev(dev));
 -		if (ret != 0 && ACPI_FAILURE(wmi_method_enable(wblock, 0)))
 -			dev_warn(dev, "failed to disable device\n");
 -	}
 -
 -	return ret;
 +	kfree(wmi_block);
  }
  
 -static int wmi_dev_remove(struct device *dev)
 -{
 -	struct wmi_block *wblock = dev_to_wblock(dev);
 -	struct wmi_driver *wdriver =
 -		container_of(dev->driver, struct wmi_driver, driver);
 -	int ret = 0;
 -
 -	if (wdriver->remove)
 -		ret = wdriver->remove(dev_to_wdev(dev));
 -
 -	if (ACPI_FAILURE(wmi_method_enable(wblock, 0)))
 -		dev_warn(dev, "failed to disable device\n");
 -
 -	return ret;
 -}
 -
 -static struct class wmi_bus_class = {
 -	.name = "wmi_bus",
 -};
 -
 -static struct bus_type wmi_bus_type = {
 +static struct class wmi_class = {
  	.name = "wmi",
 +	.dev_release = wmi_dev_free,
 +	.dev_uevent = wmi_dev_uevent,
  	.dev_groups = wmi_groups,
 -	.match = wmi_dev_match,
 -	.uevent = wmi_dev_uevent,
 -	.probe = wmi_dev_probe,
 -	.remove = wmi_dev_remove,
  };
  
++<<<<<<< HEAD
 +static int wmi_create_device(const struct guid_block *gblock,
++=======
+ static struct device_type wmi_type_event = {
+ 	.name = "event",
+ 	.groups = wmi_event_groups,
+ 	.release = wmi_dev_release,
+ };
+ 
+ static struct device_type wmi_type_method = {
+ 	.name = "method",
+ 	.groups = wmi_method_groups,
+ 	.release = wmi_dev_release,
+ };
+ 
+ static struct device_type wmi_type_data = {
+ 	.name = "data",
+ 	.groups = wmi_data_groups,
+ 	.release = wmi_dev_release,
+ };
+ 
+ static int wmi_create_device(struct device *wmi_bus_dev,
+ 			     const struct guid_block *gblock,
++>>>>>>> d4fc91adfde1 (platform/x86: wmi: Probe data objects for read and write capabilities)
  			     struct wmi_block *wblock,
  			     struct acpi_device *device)
  {
 -	wblock->dev.dev.bus = &wmi_bus_type;
 -	wblock->dev.dev.parent = wmi_bus_dev;
 +	wblock->dev.class = &wmi_class;
  
 -	dev_set_name(&wblock->dev.dev, "%pUL", gblock->guid);
 +	dev_set_name(&wblock->dev, "%pUL", gblock->guid);
  
++<<<<<<< HEAD
 +	dev_set_drvdata(&wblock->dev, wblock);
++=======
+ 	if (gblock->flags & ACPI_WMI_EVENT) {
+ 		wblock->dev.dev.type = &wmi_type_event;
+ 	} else if (gblock->flags & ACPI_WMI_METHOD) {
+ 		wblock->dev.dev.type = &wmi_type_method;
+ 	} else {
+ 		struct acpi_device_info *info;
+ 		char method[5];
+ 		int result;
+ 
+ 		wblock->dev.dev.type = &wmi_type_data;
+ 
+ 		strcpy(method, "WQ");
+ 		strncat(method, wblock->gblock.object_id, 2);
+ 		result = get_subobj_info(device->handle, method, &info);
+ 
+ 		if (result == 0) {
+ 			wblock->dev.readable = true;
+ 
+ 			/*
+ 			 * The Microsoft documentation specifically states:
+ 			 *
+ 			 *   Data blocks registered with only a single instance
+ 			 *   can ignore the parameter.
+ 			 *
+ 			 * ACPICA will get mad at us if we call the method
+ 			 * with the wrong number of arguments, so check what
+ 			 * our method expects.  (On some Dell laptops, WQxx
+ 			 * may not be a method at all.)
+ 			 */
+ 			if (info->type != ACPI_TYPE_METHOD ||
+ 			    info->param_count == 0)
+ 				wblock->read_takes_no_args = true;
+ 
+ 			kfree(info);
+ 		}
+ 
+ 		strcpy(method, "WS");
+ 		strncat(method, wblock->gblock.object_id, 2);
+ 		result = get_subobj_info(device->handle, method, NULL);
+ 
+ 		if (result == 0) {
+ 			wblock->dev.writeable = true;
+ 		}
+ 
+ 	}
++>>>>>>> d4fc91adfde1 (platform/x86: wmi: Probe data objects for read and write capabilities)
  
 -	return device_register(&wblock->dev.dev);
 +	return device_register(&wblock->dev);
  }
  
  static void wmi_free_devices(struct acpi_device *device)
* Unmerged path include/linux/wmi.h
* Unmerged path drivers/platform/x86/wmi.c
* Unmerged path include/linux/wmi.h
