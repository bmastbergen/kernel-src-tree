netfilter: ipset: Null pointer exception in ipset list:set

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Vishwanath Pai <vpai@akamai.com>
commit 40b446a1d8af17274746ff7079aa0a618dffbac3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/40b446a1.failed

If we use before/after to add an element to an empty list it will cause
a kernel panic.

$> cat crash.restore
create a hash:ip
create b hash:ip
create test list:set timeout 5 size 4
add test b before a

$> ipset -R < crash.restore

Executing the above will crash the kernel.

	Signed-off-by: Vishwanath Pai <vpai@akamai.com>
	Reviewed-by: Josh Hunt <johunt@akamai.com>
	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 40b446a1d8af17274746ff7079aa0a618dffbac3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_list_set.c
diff --cc net/netfilter/ipset/ip_set_list_set.c
index a9a97c07ecb4,178d4eba013b..000000000000
--- a/net/netfilter/ipset/ip_set_list_set.c
+++ b/net/netfilter/ipset/ip_set_list_set.c
@@@ -296,34 -242,38 +296,50 @@@ list_set_uadd(struct ip_set *set, void 
  {
  	struct list_set *map = set->data;
  	struct set_adt_elem *d = value;
 -	struct set_elem *e, *n, *prev, *next;
 +	struct set_elem *e;
  	bool flag_exist = flags & IPSET_FLAG_EXIST;
 -
 -	/* Find where to add the new entry */
 -	n = prev = next = NULL;
 -	list_for_each_entry(e, &map->members, list) {
 -		if (SET_WITH_TIMEOUT(set) &&
 -		    ip_set_timeout_expired(ext_timeout(e, set)))
 +	u32 i, ret = 0;
 +
 +	/* Check already added element */
 +	for (i = 0; i < map->size; i++) {
 +		e = list_set_elem(map, i);
 +		if (e->id == IPSET_INVALID_ID)
 +			goto insert;
 +		else if (SET_WITH_TIMEOUT(set) &&
 +			 ip_set_timeout_expired(ext_timeout(e, map)))
  			continue;
 -		else if (d->id == e->id)
 -			n = e;
 -		else if (d->before == 0 || e->id != d->refid)
 +		else if (e->id != d->id)
  			continue;
++<<<<<<< HEAD
 +
 +		if ((d->before > 1 && !id_eq(set, i + 1, d->refid)) ||
 +		    (d->before < 0 &&
 +		     (i == 0 || !id_eq(set, i - 1, d->refid))))
 +			/* Before/after doesn't match */
 +			return -IPSET_ERR_REF_EXIST;
++=======
+ 		else if (d->before > 0)
+ 			next = e;
+ 		else
+ 			prev = e;
+ 	}
+ 
+ 	/* If before/after is used on an empty set */
+ 	if ((d->before > 0 && !next) ||
+ 	    (d->before < 0 && !prev))
+ 		return -IPSET_ERR_REF_EXIST;
+ 
+ 	/* Re-add already existing element */
+ 	if (n) {
++>>>>>>> 40b446a1d8af (netfilter: ipset: Null pointer exception in ipset list:set)
  		if (!flag_exist)
 +			/* Can't re-add */
  			return -IPSET_ERR_EXIST;
  		/* Update extensions */
 -		ip_set_ext_destroy(set, n);
 -		list_set_init_extensions(set, ext, n);
 -
 +		if (SET_WITH_TIMEOUT(set))
 +			ip_set_timeout_set(ext_timeout(e, map), ext->timeout);
 +		if (SET_WITH_COUNTER(set))
 +			ip_set_init_counter(ext_counter(e, map), ext);
  		/* Set is already added to the list */
  		ip_set_put_byindex(map->net, d->id);
  		return 0;
* Unmerged path net/netfilter/ipset/ip_set_list_set.c
