perf events parse: Rename parsing state struct to clearer name

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 5d369a75eda5855d64981668a1d60cfac00d52e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5d369a75.failed

Rename it from 'parse_events_evlist' to 'parse_events_state' to better
state that this is parsing state that has to be passed around.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/n/tip-dursqtg2h2w98ztaa297u43x@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 5d369a75eda5855d64981668a1d60cfac00d52e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/tests/bpf.c
#	tools/perf/util/parse-events.c
#	tools/perf/util/parse-events.h
#	tools/perf/util/parse-events.y
diff --cc tools/perf/util/parse-events.c
index eb476984ddca,272eab7f5ac8..000000000000
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@@ -583,6 -588,227 +583,230 @@@ static int add_tracepoint_multi_sys(str
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ struct __add_bpf_event_param {
+ 	struct parse_events_state *data;
+ 	struct list_head *list;
+ 	struct list_head *head_config;
+ };
+ 
+ static int add_bpf_event(const char *group, const char *event, int fd,
+ 			 void *_param)
+ {
+ 	LIST_HEAD(new_evsels);
+ 	struct __add_bpf_event_param *param = _param;
+ 	struct parse_events_state *parse_state = param->data;
+ 	struct list_head *list = param->list;
+ 	struct perf_evsel *pos;
+ 	int err;
+ 
+ 	pr_debug("add bpf event %s:%s and attach bpf program %d\n",
+ 		 group, event, fd);
+ 
+ 	err = parse_events_add_tracepoint(&new_evsels, &parse_state->idx, group,
+ 					  event, parse_state->error,
+ 					  param->head_config);
+ 	if (err) {
+ 		struct perf_evsel *evsel, *tmp;
+ 
+ 		pr_debug("Failed to add BPF event %s:%s\n",
+ 			 group, event);
+ 		list_for_each_entry_safe(evsel, tmp, &new_evsels, node) {
+ 			list_del(&evsel->node);
+ 			perf_evsel__delete(evsel);
+ 		}
+ 		return err;
+ 	}
+ 	pr_debug("adding %s:%s\n", group, event);
+ 
+ 	list_for_each_entry(pos, &new_evsels, node) {
+ 		pr_debug("adding %s:%s to %p\n",
+ 			 group, event, pos);
+ 		pos->bpf_fd = fd;
+ 	}
+ 	list_splice(&new_evsels, list);
+ 	return 0;
+ }
+ 
+ int parse_events_load_bpf_obj(struct parse_events_state *data,
+ 			      struct list_head *list,
+ 			      struct bpf_object *obj,
+ 			      struct list_head *head_config)
+ {
+ 	int err;
+ 	char errbuf[BUFSIZ];
+ 	struct __add_bpf_event_param param = {data, list, head_config};
+ 	static bool registered_unprobe_atexit = false;
+ 
+ 	if (IS_ERR(obj) || !obj) {
+ 		snprintf(errbuf, sizeof(errbuf),
+ 			 "Internal error: load bpf obj with NULL");
+ 		err = -EINVAL;
+ 		goto errout;
+ 	}
+ 
+ 	/*
+ 	 * Register atexit handler before calling bpf__probe() so
+ 	 * bpf__probe() don't need to unprobe probe points its already
+ 	 * created when failure.
+ 	 */
+ 	if (!registered_unprobe_atexit) {
+ 		atexit(bpf__clear);
+ 		registered_unprobe_atexit = true;
+ 	}
+ 
+ 	err = bpf__probe(obj);
+ 	if (err) {
+ 		bpf__strerror_probe(obj, err, errbuf, sizeof(errbuf));
+ 		goto errout;
+ 	}
+ 
+ 	err = bpf__load(obj);
+ 	if (err) {
+ 		bpf__strerror_load(obj, err, errbuf, sizeof(errbuf));
+ 		goto errout;
+ 	}
+ 
+ 	err = bpf__foreach_event(obj, add_bpf_event, &param);
+ 	if (err) {
+ 		snprintf(errbuf, sizeof(errbuf),
+ 			 "Attach events in BPF object failed");
+ 		goto errout;
+ 	}
+ 
+ 	return 0;
+ errout:
+ 	data->error->help = strdup("(add -v to see detail)");
+ 	data->error->str = strdup(errbuf);
+ 	return err;
+ }
+ 
+ static int
+ parse_events_config_bpf(struct parse_events_state *data,
+ 			struct bpf_object *obj,
+ 			struct list_head *head_config)
+ {
+ 	struct parse_events_term *term;
+ 	int error_pos;
+ 
+ 	if (!head_config || list_empty(head_config))
+ 		return 0;
+ 
+ 	list_for_each_entry(term, head_config, list) {
+ 		char errbuf[BUFSIZ];
+ 		int err;
+ 
+ 		if (term->type_term != PARSE_EVENTS__TERM_TYPE_USER) {
+ 			snprintf(errbuf, sizeof(errbuf),
+ 				 "Invalid config term for BPF object");
+ 			errbuf[BUFSIZ - 1] = '\0';
+ 
+ 			data->error->idx = term->err_term;
+ 			data->error->str = strdup(errbuf);
+ 			return -EINVAL;
+ 		}
+ 
+ 		err = bpf__config_obj(obj, term, data->evlist, &error_pos);
+ 		if (err) {
+ 			bpf__strerror_config_obj(obj, term, data->evlist,
+ 						 &error_pos, err, errbuf,
+ 						 sizeof(errbuf));
+ 			data->error->help = strdup(
+ "Hint:\tValid config terms:\n"
+ "     \tmap:[<arraymap>].value<indices>=[value]\n"
+ "     \tmap:[<eventmap>].event<indices>=[event]\n"
+ "\n"
+ "     \twhere <indices> is something like [0,3...5] or [all]\n"
+ "     \t(add -v to see detail)");
+ 			data->error->str = strdup(errbuf);
+ 			if (err == -BPF_LOADER_ERRNO__OBJCONF_MAP_VALUE)
+ 				data->error->idx = term->err_val;
+ 			else
+ 				data->error->idx = term->err_term + error_pos;
+ 			return err;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * Split config terms:
+  * perf record -e bpf.c/call-graph=fp,map:array.value[0]=1/ ...
+  *  'call-graph=fp' is 'evt config', should be applied to each
+  *  events in bpf.c.
+  * 'map:array.value[0]=1' is 'obj config', should be processed
+  * with parse_events_config_bpf.
+  *
+  * Move object config terms from the first list to obj_head_config.
+  */
+ static void
+ split_bpf_config_terms(struct list_head *evt_head_config,
+ 		       struct list_head *obj_head_config)
+ {
+ 	struct parse_events_term *term, *temp;
+ 
+ 	/*
+ 	 * Currectly, all possible user config term
+ 	 * belong to bpf object. parse_events__is_hardcoded_term()
+ 	 * happends to be a good flag.
+ 	 *
+ 	 * See parse_events_config_bpf() and
+ 	 * config_term_tracepoint().
+ 	 */
+ 	list_for_each_entry_safe(term, temp, evt_head_config, list)
+ 		if (!parse_events__is_hardcoded_term(term))
+ 			list_move_tail(&term->list, obj_head_config);
+ }
+ 
+ int parse_events_load_bpf(struct parse_events_state *data,
+ 			  struct list_head *list,
+ 			  char *bpf_file_name,
+ 			  bool source,
+ 			  struct list_head *head_config)
+ {
+ 	int err;
+ 	struct bpf_object *obj;
+ 	LIST_HEAD(obj_head_config);
+ 
+ 	if (head_config)
+ 		split_bpf_config_terms(head_config, &obj_head_config);
+ 
+ 	obj = bpf__prepare_load(bpf_file_name, source);
+ 	if (IS_ERR(obj)) {
+ 		char errbuf[BUFSIZ];
+ 
+ 		err = PTR_ERR(obj);
+ 
+ 		if (err == -ENOTSUP)
+ 			snprintf(errbuf, sizeof(errbuf),
+ 				 "BPF support is not compiled");
+ 		else
+ 			bpf__strerror_prepare_load(bpf_file_name,
+ 						   source,
+ 						   -err, errbuf,
+ 						   sizeof(errbuf));
+ 
+ 		data->error->help = strdup("(add -v to see detail)");
+ 		data->error->str = strdup(errbuf);
+ 		return err;
+ 	}
+ 
+ 	err = parse_events_load_bpf_obj(data, list, obj, head_config);
+ 	if (err)
+ 		return err;
+ 	err = parse_events_config_bpf(data, obj, &obj_head_config);
+ 
+ 	/*
+ 	 * Caller doesn't know anything about obj_head_config,
+ 	 * so combine them together again before returnning.
+ 	 */
+ 	if (head_config)
+ 		list_splice_tail(&obj_head_config, head_config);
+ 	return err;
+ }
+ 
++>>>>>>> 5d369a75eda5 (perf events parse: Rename parsing state struct to clearer name)
  static int
  parse_breakpoint_type(const char *type, struct perf_event_attr *attr)
  {
@@@ -1441,10 -1675,11 +1665,18 @@@ int parse_events_terms(struct list_hea
  int parse_events(struct perf_evlist *evlist, const char *str,
  		 struct parse_events_error *err)
  {
++<<<<<<< HEAD
 +	struct parse_events_evlist data = {
 +		.list  = LIST_HEAD_INIT(data.list),
 +		.idx   = evlist->nr_entries,
 +		.error = err,
++=======
+ 	struct parse_events_state data = {
+ 		.list   = LIST_HEAD_INIT(data.list),
+ 		.idx    = evlist->nr_entries,
+ 		.error  = err,
+ 		.evlist = evlist,
++>>>>>>> 5d369a75eda5 (perf events parse: Rename parsing state struct to clearer name)
  	};
  	int ret;
  
@@@ -2278,7 -2515,12 +2510,16 @@@ void parse_events_terms__delete(struct 
  	free(terms);
  }
  
++<<<<<<< HEAD
 +void parse_events_evlist_error(struct parse_events_evlist *data,
++=======
+ void parse_events__clear_array(struct parse_events_array *a)
+ {
+ 	zfree(&a->ranges);
+ }
+ 
+ void parse_events_evlist_error(struct parse_events_state *data,
++>>>>>>> 5d369a75eda5 (perf events parse: Rename parsing state struct to clearer name)
  			       int idx, const char *str)
  {
  	struct parse_events_error *err = data->error;
diff --cc tools/perf/util/parse-events.h
index 43b505fd3102,8fff8423469b..000000000000
--- a/tools/perf/util/parse-events.h
+++ b/tools/perf/util/parse-events.h
@@@ -131,7 -143,18 +131,22 @@@ int parse_events_add_tracepoint(struct 
  				const char *sys, const char *event,
  				struct parse_events_error *error,
  				struct list_head *head_config);
++<<<<<<< HEAD
 +int parse_events_add_numeric(struct parse_events_evlist *data,
++=======
+ int parse_events_load_bpf(struct parse_events_state *data,
+ 			  struct list_head *list,
+ 			  char *bpf_file_name,
+ 			  bool source,
+ 			  struct list_head *head_config);
+ /* Provide this function for perf test */
+ struct bpf_object;
+ int parse_events_load_bpf_obj(struct parse_events_state *data,
+ 			      struct list_head *list,
+ 			      struct bpf_object *obj,
+ 			      struct list_head *head_config);
+ int parse_events_add_numeric(struct parse_events_state *data,
++>>>>>>> 5d369a75eda5 (perf events parse: Rename parsing state struct to clearer name)
  			     struct list_head *list,
  			     u32 type, u64 config,
  			     struct list_head *head_config);
diff --cc tools/perf/util/parse-events.y
index 945e22e508d8,403a221266b8..000000000000
--- a/tools/perf/util/parse-events.y
+++ b/tools/perf/util/parse-events.y
@@@ -434,7 -440,19 +434,23 @@@ PE_VALUE ':' PE_VALUE opt_event_confi
  event_legacy_raw:
  PE_RAW opt_event_config
  {
++<<<<<<< HEAD
 +	struct parse_events_evlist *data = _data;
++=======
+ 	struct list_head *list;
+ 
+ 	ALLOC_LIST(list);
+ 	ABORT_ON(parse_events_add_numeric(_data, list, PERF_TYPE_RAW, $1, $2));
+ 	parse_events_terms__delete($2);
+ 	$$ = list;
+ }
+ 
+ event_bpf_file:
+ PE_BPF_OBJECT opt_event_config
+ {
+ 	struct parse_events_state *data = _data;
+ 	struct parse_events_error *error = data->error;
++>>>>>>> 5d369a75eda5 (perf events parse: Rename parsing state struct to clearer name)
  	struct list_head *list;
  
  	ALLOC_LIST(list);
* Unmerged path tools/perf/tests/bpf.c
* Unmerged path tools/perf/tests/bpf.c
* Unmerged path tools/perf/util/parse-events.c
* Unmerged path tools/perf/util/parse-events.h
* Unmerged path tools/perf/util/parse-events.y
