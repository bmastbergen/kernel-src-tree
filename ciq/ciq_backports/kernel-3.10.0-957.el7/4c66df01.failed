net/mlx5: E-Switch, Simplify representor load/unload callback API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Simplify representor load/unload callback API (Alaa Hleihel) [1591249]
Rebuild_FUZZ: 96.83%
commit-author Mark Bloch <markb@mellanox.com>
commit 4c66df01f5a46b191df0d036fc76cc9350280bc3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4c66df01.failed

In the load() callback for loading representors we don't really need
struct mlx5_eswitch but struct mlx5_core_dev, pass it directly.

In the unload() callback for unloading representors we don't need the
struct mlx5_eswitch argument, remove it.

	Signed-off-by: Mark Bloch <markb@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 4c66df01f5a46b191df0d036fc76cc9350280bc3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 1f6b50ed685e,6d2219f3acf6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -1109,6 -1044,12 +1109,15 @@@ mlx5e_vport_rep_load(struct mlx5_core_d
  		goto err_detach_netdev;
  	}
  
++<<<<<<< HEAD
++=======
+ 	upriv = netdev_priv(mlx5_eswitch_get_uplink_netdev(dev->priv.eswitch));
+ 	err = tc_setup_cb_egdev_register(netdev, mlx5e_setup_tc_block_cb,
+ 					 upriv);
+ 	if (err)
+ 		goto err_neigh_cleanup;
+ 
++>>>>>>> 4c66df01f5a4 (net/mlx5: E-Switch, Simplify representor load/unload callback API)
  	err = register_netdev(netdev);
  	if (err) {
  		pr_warn("Failed to register representor netdev for vport %d\n",
@@@ -1137,9 -1082,12 +1146,15 @@@ mlx5e_vport_rep_unload(struct mlx5_eswi
  	struct mlx5e_priv *priv = netdev_priv(netdev);
  	struct mlx5e_rep_priv *rpriv = priv->ppriv;
  	void *ppriv = priv->ppriv;
 -	struct mlx5e_priv *upriv;
  
  	unregister_netdev(rep->netdev);
++<<<<<<< HEAD
 +
++=======
+ 	upriv = netdev_priv(mlx5_eswitch_get_uplink_netdev(priv->mdev->priv.eswitch));
+ 	tc_setup_cb_egdev_unregister(netdev, mlx5e_setup_tc_block_cb,
+ 				     upriv);
++>>>>>>> 4c66df01f5a4 (net/mlx5: E-Switch, Simplify representor load/unload callback API)
  	mlx5e_rep_neigh_cleanup(rpriv);
  	mlx5e_detach_netdev(priv);
  	mlx5e_destroy_netdev(priv);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 288cff3a0677..6f20c9f966ad 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@ -147,10 +147,9 @@ struct mlx5_esw_sq {
 };
 
 struct mlx5_eswitch_rep {
-	int		       (*load)(struct mlx5_eswitch *esw,
+	int		       (*load)(struct mlx5_core_dev *dev,
 				       struct mlx5_eswitch_rep *rep);
-	void		       (*unload)(struct mlx5_eswitch *esw,
-					 struct mlx5_eswitch_rep *rep);
+	void		       (*unload)(struct mlx5_eswitch_rep *rep);
 	u16		       vport;
 	u8		       hw_id[ETH_ALEN];
 	struct net_device      *netdev;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 50fceb0bde65..121609b823c6 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@ -729,7 +729,7 @@ static void esw_offloads_unload_reps(struct mlx5_eswitch *esw, int nvports)
 		if (!rep->valid)
 			continue;
 
-		rep->unload(esw, rep);
+		rep->unload(rep);
 	}
 }
 
@@ -744,7 +744,7 @@ static int esw_offloads_load_reps(struct mlx5_eswitch *esw, int nvports)
 		if (!rep->valid)
 			continue;
 
-		err = rep->load(esw, rep);
+		err = rep->load(esw->dev, rep);
 		if (err)
 			goto err_reps;
 	}
@@ -1145,7 +1145,7 @@ void mlx5_eswitch_unregister_vport_rep(struct mlx5_eswitch *esw,
 	rep = &offloads->vport_reps[vport_index];
 
 	if (esw->mode == SRIOV_OFFLOADS && esw->vports[vport_index].enabled)
-		rep->unload(esw, rep);
+		rep->unload(rep);
 
 	rep->valid = false;
 }
