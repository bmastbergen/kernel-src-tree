vmbus: simplify hv_ringbuffer_read

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Stephen Hemminger <stephen@networkplumber.org>
commit 4226ff69a3dff78bead7d9a270423cd21f8d40b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4226ff69.failed

With new iterator functions (and the double mapping) the ring buffer
read function can be greatly simplified.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 4226ff69a3dff78bead7d9a270423cd21f8d40b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/ring_buffer.c
diff --cc drivers/hv/ring_buffer.c
index 480f1a09972c,f29981764653..000000000000
--- a/drivers/hv/ring_buffer.c
+++ b/drivers/hv/ring_buffer.c
@@@ -391,48 -310,22 +333,41 @@@ int hv_ringbuffer_read(struct vmbus_cha
  		return 0;
  	}
  
- 	init_cached_read_index(inring_info);
- 
- 	next_read_location = hv_get_next_read_location(inring_info);
- 	next_read_location = hv_copyfrom_ringbuffer(inring_info, &desc,
- 						    sizeof(desc),
- 						    next_read_location);
- 
- 	offset = raw ? 0 : (desc.offset8 << 3);
- 	packetlen = (desc.len8 << 3) - offset;
+ 	offset = raw ? 0 : (desc->offset8 << 3);
+ 	packetlen = (desc->len8 << 3) - offset;
  	*buffer_actual_len = packetlen;
- 	*requestid = desc.trans_id;
+ 	*requestid = desc->trans_id;
  
- 	if (bytes_avail_toread < packetlen + offset)
- 		return -EAGAIN;
- 
- 	if (packetlen > buflen)
+ 	if (unlikely(packetlen > buflen))
  		return -ENOBUFS;
  
- 	next_read_location =
- 		hv_get_next_readlocation_withoffset(inring_info, offset);
+ 	/* since ring is double mapped, only one copy is necessary */
+ 	memcpy(buffer, (const char *)desc + offset, packetlen);
  
- 	next_read_location = hv_copyfrom_ringbuffer(inring_info,
- 						buffer,
- 						packetlen,
- 						next_read_location);
+ 	/* Advance ring index to next packet descriptor */
+ 	__hv_pkt_iter_next(channel, desc);
  
++<<<<<<< HEAD
 +	next_read_location = hv_copyfrom_ringbuffer(inring_info,
 +						&prev_indices,
 +						sizeof(u64),
 +						next_read_location);
 +
 +	/*
 +	 * Make sure all reads are done before we update the read index since
 +	 * the writer may start writing to the read area once the read index
 +	 * is updated.
 +	 */
 +	mb();
 +
 +	/* Update the read index */
 +	hv_set_next_read_location(inring_info, next_read_location);
 +
 +	hv_signal_on_read(channel);
++=======
+ 	/* Notify host of update */
+ 	hv_pkt_iter_close(channel);
++>>>>>>> 4226ff69a3df (vmbus: simplify hv_ringbuffer_read)
  
  	return 0;
  }
* Unmerged path drivers/hv/ring_buffer.c
