scsi: qla2xxx: Add switch command to simplify fabric discovery

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Add switch command to simplify fabric discovery (Himanshu Madhani) [1547714]
Rebuild_FUZZ: 94.92%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit a4239945b8ad112fb914d0605c8f6c5fd3330f61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/a4239945.failed

- add "async" gpn_ft, gnn_ft, gfpn_id, gnn_id switch commands.
- For 8G and newer adapters, use async commands when it comes to
fabric scan to reduce bottle neck.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit a4239945b8ad112fb914d0605c8f6c5fd3330f61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_gbl.h
#	drivers/scsi/qla2xxx/qla_gs.c
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_mbx.c
#	drivers/scsi/qla2xxx/qla_os.c
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index a31b989dbee0,240767c862e6..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -2251,7 -2305,10 +2253,14 @@@ enum fcport_mgt_event 
  	FCME_GPSC_DONE,
  	FCME_GPDB_DONE,
  	FCME_GPNID_DONE,
++<<<<<<< HEAD
 +	FCME_DELETE_DONE,
++=======
+ 	FCME_GFFID_DONE,
+ 	FCME_ADISC_DONE,
+ 	FCME_GNNID_DONE,
+ 	FCME_GFPNID_DONE,
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  };
  
  enum rscn_addr_format {
@@@ -2283,6 -2340,18 +2292,21 @@@ typedef struct fc_port 
  	unsigned int send_els_logo:1;
  	unsigned int login_pause:1;
  	unsigned int login_succ:1;
++<<<<<<< HEAD
++=======
+ 	unsigned int query:1;
+ 	unsigned int id_changed:1;
+ 
+ 	struct work_struct nvme_del_work;
+ 	struct completion nvme_del_done;
+ 	uint32_t nvme_prli_service_param;
+ #define NVME_PRLI_SP_CONF       BIT_7
+ #define NVME_PRLI_SP_INITIATOR  BIT_5
+ #define NVME_PRLI_SP_TARGET     BIT_4
+ #define NVME_PRLI_SP_DISCOVERY  BIT_3
+ 	uint8_t nvme_flag;
+ #define NVME_FLAG_REGISTERED 4
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  
  	struct fc_port *conflict;
  	unsigned char logout_completed;
@@@ -3066,6 -3195,14 +3141,17 @@@ enum qla_work_type 
  	QLA_EVT_UPD_FCPORT,
  	QLA_EVT_GNL,
  	QLA_EVT_NACK,
++<<<<<<< HEAD
++=======
+ 	QLA_EVT_RELOGIN,
+ 	QLA_EVT_ASYNC_PRLO,
+ 	QLA_EVT_ASYNC_PRLO_DONE,
+ 	QLA_EVT_GPNFT,
+ 	QLA_EVT_GPNFT_DONE,
+ 	QLA_EVT_GNNFT_DONE,
+ 	QLA_EVT_GNNID,
+ 	QLA_EVT_GFPNID,
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  };
  
  
@@@ -4166,6 -4333,12 +4259,15 @@@ typedef struct scsi_qla_host 
  	int fcport_count;
  	wait_queue_head_t fcport_waitQ;
  	wait_queue_head_t vref_waitq;
++<<<<<<< HEAD
++=======
+ 	uint8_t min_link_speed_feat;
+ 	uint8_t n2n_node_name[WWN_SIZE];
+ 	uint8_t n2n_port_name[WWN_SIZE];
+ 	uint16_t	n2n_id;
+ 	struct list_head gpnid_list;
+ 	struct fab_scan scan;
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  } scsi_qla_host_t;
  
  struct qla27xx_image_status {
diff --cc drivers/scsi/qla2xxx/qla_gbl.h
index 547baeb17bb1,4e504e5e7586..000000000000
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@@ -99,12 -102,20 +99,12 @@@ extern struct qla_qpair *qla2xxx_create
  extern int qla2xxx_delete_qpair(struct scsi_qla_host *, struct qla_qpair *);
  void qla2x00_fcport_event_handler(scsi_qla_host_t *, struct event_arg *);
  int qla24xx_async_gpdb(struct scsi_qla_host *, fc_port_t *, u8);
 -int qla24xx_async_prli(struct scsi_qla_host *, fc_port_t *);
  int qla24xx_async_notify_ack(scsi_qla_host_t *, fc_port_t *,
  	struct imm_ntfy_from_isp *, int);
- int qla24xx_post_newsess_work(struct scsi_qla_host *, port_id_t *, u8 *,
-     void *);
+ int qla24xx_post_newsess_work(struct scsi_qla_host *, port_id_t *, u8 *, u8*,
+     void *, u8);
  int qla24xx_fcport_handle_login(struct scsi_qla_host *, fc_port_t *);
  int qla24xx_detect_sfp(scsi_qla_host_t *vha);
 -int qla24xx_post_gpdb_work(struct scsi_qla_host *, fc_port_t *, u8);
 -void qla2x00_async_prlo_done(struct scsi_qla_host *, fc_port_t *,
 -    uint16_t *);
 -extern int qla2x00_post_async_prlo_work(struct scsi_qla_host *, fc_port_t *,
 -    uint16_t *);
 -extern int qla2x00_post_async_prlo_done_work(struct scsi_qla_host *,
 -    fc_port_t *, uint16_t *);
  
  /*
   * Global Data in qla_os.c source file.
@@@ -634,7 -655,19 +634,22 @@@ void qla24xx_handle_gpnid_event(scsi_ql
  
  int qla24xx_post_gpsc_work(struct scsi_qla_host *, fc_port_t *);
  int qla24xx_async_gpsc(scsi_qla_host_t *, fc_port_t *);
+ void qla24xx_handle_gpsc_event(scsi_qla_host_t *, struct event_arg *);
  int qla2x00_mgmt_svr_login(scsi_qla_host_t *);
++<<<<<<< HEAD
++=======
+ void qla24xx_handle_gffid_event(scsi_qla_host_t *vha, struct event_arg *ea);
+ int qla24xx_async_gffid(scsi_qla_host_t *vha, fc_port_t *fcport);
+ int qla24xx_async_gpnft(scsi_qla_host_t *, u8);
+ void qla24xx_async_gpnft_done(scsi_qla_host_t *, srb_t *);
+ void qla24xx_async_gnnft_done(scsi_qla_host_t *, srb_t *);
+ int qla24xx_async_gnnid(scsi_qla_host_t *, fc_port_t *);
+ void qla24xx_handle_gnnid_event(scsi_qla_host_t *, struct event_arg *);
+ int qla24xx_post_gnnid_work(struct scsi_qla_host *, fc_port_t *);
+ int qla24xx_post_gfpnid_work(struct scsi_qla_host *, fc_port_t *);
+ int qla24xx_async_gfpnid(scsi_qla_host_t *, fc_port_t *);
+ void qla24xx_handle_gfpnid_event(scsi_qla_host_t *, struct event_arg *);
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  
  /*
   * Global Function Prototypes in qla_attr.c source file.
diff --cc drivers/scsi/qla2xxx/qla_gs.c
index 0dfd63fae4b1,2132c7ad8044..000000000000
--- a/drivers/scsi/qla2xxx/qla_gs.c
+++ b/drivers/scsi/qla2xxx/qla_gs.c
@@@ -2808,7 -2857,8 +2825,12 @@@ void qla24xx_handle_gidpn_event(scsi_ql
  				}
  			} else { /* fcport->d_id.b24 != ea->id.b24 */
  				fcport->d_id.b24 = ea->id.b24;
++<<<<<<< HEAD
 +				if (fcport->deleted == QLA_SESS_DELETED) {
++=======
+ 				fcport->id_changed = 1;
+ 				if (fcport->deleted != QLA_SESS_DELETED) {
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  					ql_dbg(ql_dbg_disc, vha, 0x2021,
  					    "%s %d %8phC post del sess\n",
  					    __func__, __LINE__, fcport->port_name);
@@@ -3143,43 -3226,138 +3198,133 @@@ void qla24xx_async_gpnid_done(scsi_qla_
  
  void qla24xx_handle_gpnid_event(scsi_qla_host_t *vha, struct event_arg *ea)
  {
 -	fc_port_t *fcport, *conflict, *t;
 -	u16 data[2];
 +	fc_port_t *fcport;
 +	unsigned long flags;
  
 -	ql_dbg(ql_dbg_disc, vha, 0xffff,
 -	    "%s %d port_id: %06x\n",
 -	    __func__, __LINE__, ea->id.b24);
 +	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
 +	fcport = qla2x00_find_fcport_by_wwpn(vha, ea->port_name, 1);
 +	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
  
 -	if (ea->rc) {
 -		/* cable is disconnected */
 -		list_for_each_entry_safe(fcport, t, &vha->vp_fcports, list) {
 -			if (fcport->d_id.b24 == ea->id.b24) {
 -				ql_dbg(ql_dbg_disc, vha, 0xffff,
 -				    "%s %d %8phC DS %d\n",
 -				    __func__, __LINE__,
 -				    fcport->port_name,
 -				    fcport->disc_state);
 -				fcport->scan_state = QLA_FCPORT_SCAN;
 -				switch (fcport->disc_state) {
 -				case DSC_DELETED:
 -				case DSC_DELETE_PEND:
 -					break;
 -				default:
 -					ql_dbg(ql_dbg_disc, vha, 0xffff,
 -					    "%s %d %8phC post del sess\n",
 -					    __func__, __LINE__,
 -					    fcport->port_name);
 -					qlt_schedule_sess_for_deletion_lock
 -						(fcport);
 -					break;
 -				}
 -			}
 +	if (fcport) {
 +		/* cable moved. just plugged in */
 +		fcport->rscn_gen++;
 +		fcport->d_id = ea->id;
 +		fcport->scan_state = QLA_FCPORT_FOUND;
 +		fcport->flags |= FCF_FABRIC_DEVICE;
 +
 +		switch (fcport->disc_state) {
 +		case DSC_DELETED:
 +			ql_dbg(ql_dbg_disc, vha, 0x210d,
 +			    "%s %d %8phC login\n", __func__, __LINE__,
 +			    fcport->port_name);
 +			qla24xx_fcport_handle_login(vha, fcport);
 +			break;
 +		case DSC_DELETE_PEND:
 +			break;
 +		default:
 +			ql_dbg(ql_dbg_disc, vha, 0x2064,
 +			    "%s %d %8phC post del sess\n",
 +			    __func__, __LINE__, fcport->port_name);
 +			qlt_schedule_sess_for_deletion_lock(fcport);
 +			break;
  		}
  	} else {
 -		/* cable is connected */
 -		fcport = qla2x00_find_fcport_by_wwpn(vha, ea->port_name, 1);
 -		if (fcport) {
 -			list_for_each_entry_safe(conflict, t, &vha->vp_fcports,
 -			    list) {
 -				if ((conflict->d_id.b24 == ea->id.b24) &&
 -				    (fcport != conflict)) {
 -					/* 2 fcports with conflict Nport ID or
 -					 * an existing fcport is having nport ID
 -					 * conflict with new fcport.
 -					 */
 -
 +		/* create new fcport */
 +		ql_dbg(ql_dbg_disc, vha, 0x2065,
 +		    "%s %d %8phC post new sess\n",
 +		    __func__, __LINE__, ea->port_name);
 +
++<<<<<<< HEAD
 +		qla24xx_post_newsess_work(vha, &ea->id, ea->port_name, NULL);
++=======
+ 					ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 					    "%s %d %8phC DS %d\n",
+ 					    __func__, __LINE__,
+ 					    conflict->port_name,
+ 					    conflict->disc_state);
+ 					conflict->scan_state = QLA_FCPORT_SCAN;
+ 					switch (conflict->disc_state) {
+ 					case DSC_DELETED:
+ 					case DSC_DELETE_PEND:
+ 						break;
+ 					default:
+ 						ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 						    "%s %d %8phC post del sess\n",
+ 						    __func__, __LINE__,
+ 						    conflict->port_name);
+ 						qlt_schedule_sess_for_deletion_lock
+ 							(conflict);
+ 						break;
+ 					}
+ 				}
+ 			}
+ 
+ 			fcport->rscn_gen++;
+ 			fcport->scan_state = QLA_FCPORT_FOUND;
+ 			fcport->flags |= FCF_FABRIC_DEVICE;
+ 			switch (fcport->disc_state) {
+ 			case DSC_LOGIN_COMPLETE:
+ 				/* recheck session is still intact. */
+ 				ql_dbg(ql_dbg_disc, vha, 0x210d,
+ 				    "%s %d %8phC revalidate session with ADISC\n",
+ 				    __func__, __LINE__, fcport->port_name);
+ 				data[0] = data[1] = 0;
+ 				qla2x00_post_async_adisc_work(vha, fcport,
+ 				    data);
+ 				break;
+ 			case DSC_DELETED:
+ 				ql_dbg(ql_dbg_disc, vha, 0x210d,
+ 				    "%s %d %8phC login\n", __func__, __LINE__,
+ 				    fcport->port_name);
+ 				fcport->d_id = ea->id;
+ 				qla24xx_fcport_handle_login(vha, fcport);
+ 				break;
+ 			case DSC_DELETE_PEND:
+ 				fcport->d_id = ea->id;
+ 				break;
+ 			default:
+ 				fcport->d_id = ea->id;
+ 				break;
+ 			}
+ 		} else {
+ 			list_for_each_entry_safe(conflict, t, &vha->vp_fcports,
+ 			    list) {
+ 				if (conflict->d_id.b24 == ea->id.b24) {
+ 					/* 2 fcports with conflict Nport ID or
+ 					 * an existing fcport is having nport ID
+ 					 * conflict with new fcport.
+ 					 */
+ 					ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 					    "%s %d %8phC DS %d\n",
+ 					    __func__, __LINE__,
+ 					    conflict->port_name,
+ 					    conflict->disc_state);
+ 
+ 					conflict->scan_state = QLA_FCPORT_SCAN;
+ 					switch (conflict->disc_state) {
+ 					case DSC_DELETED:
+ 					case DSC_DELETE_PEND:
+ 						break;
+ 					default:
+ 						ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 						    "%s %d %8phC post del sess\n",
+ 						    __func__, __LINE__,
+ 						    conflict->port_name);
+ 						qlt_schedule_sess_for_deletion_lock
+ 							(conflict);
+ 						break;
+ 					}
+ 				}
+ 			}
+ 
+ 			/* create new fcport */
+ 			ql_dbg(ql_dbg_disc, vha, 0x2065,
+ 			    "%s %d %8phC post new sess\n",
+ 			    __func__, __LINE__, ea->port_name);
+ 			qla24xx_post_newsess_work(vha, &ea->id,
+ 			    ea->port_name, NULL, NULL, FC4_TYPE_UNKNOWN);
+ 		}
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  	}
  }
  
@@@ -3328,3 -3538,767 +3473,770 @@@ done_free_sp
  done:
  	return rval;
  }
++<<<<<<< HEAD
++=======
+ 
+ void qla24xx_handle_gffid_event(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+        fc_port_t *fcport = ea->fcport;
+ 
+        qla24xx_post_gnl_work(vha, fcport);
+ }
+ 
+ void qla24xx_async_gffid_sp_done(void *s, int res)
+ {
+        struct srb *sp = s;
+        struct scsi_qla_host *vha = sp->vha;
+        fc_port_t *fcport = sp->fcport;
+        struct ct_sns_rsp *ct_rsp;
+        struct event_arg ea;
+ 
+        ql_dbg(ql_dbg_disc, vha, 0x2133,
+ 	   "Async done-%s res %x ID %x. %8phC\n",
+ 	   sp->name, res, fcport->d_id.b24, fcport->port_name);
+ 
+        fcport->flags &= ~FCF_ASYNC_SENT;
+        ct_rsp = &fcport->ct_desc.ct_sns->p.rsp;
+        /*
+ 	* FC-GS-7, 5.2.3.12 FC-4 Features - format
+ 	* The format of the FC-4 Features object, as defined by the FC-4,
+ 	* Shall be an array of 4-bit values, one for each type code value
+ 	*/
+        if (!res) {
+ 	       if (ct_rsp->rsp.gff_id.fc4_features[GFF_FCP_SCSI_OFFSET] & 0xf) {
+ 		       /* w1 b00:03 */
+ 		       fcport->fc4_type =
+ 			   ct_rsp->rsp.gff_id.fc4_features[GFF_FCP_SCSI_OFFSET];
+ 		       fcport->fc4_type &= 0xf;
+ 	       }
+ 
+ 	       if (ct_rsp->rsp.gff_id.fc4_features[GFF_NVME_OFFSET] & 0xf) {
+ 		       /* w5 [00:03]/28h */
+ 		       fcport->fc4f_nvme =
+ 			   ct_rsp->rsp.gff_id.fc4_features[GFF_NVME_OFFSET];
+ 		       fcport->fc4f_nvme &= 0xf;
+ 	       }
+        }
+ 
+        memset(&ea, 0, sizeof(ea));
+        ea.sp = sp;
+        ea.fcport = sp->fcport;
+        ea.rc = res;
+        ea.event = FCME_GFFID_DONE;
+ 
+        qla2x00_fcport_event_handler(vha, &ea);
+        sp->free(sp);
+ }
+ 
+ /* Get FC4 Feature with Nport ID. */
+ int qla24xx_async_gffid(scsi_qla_host_t *vha, fc_port_t *fcport)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	struct ct_sns_req       *ct_req;
+ 	srb_t *sp;
+ 
+ 	if (!vha->flags.online)
+ 		return rval;
+ 
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		return rval;
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	sp->type = SRB_CT_PTHRU_CMD;
+ 	sp->name = "gffid";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	/* CT_IU preamble  */
+ 	ct_req = qla2x00_prep_ct_req(fcport->ct_desc.ct_sns, GFF_ID_CMD,
+ 	    GFF_ID_RSP_SIZE);
+ 
+ 	ct_req->req.gff_id.port_id[0] = fcport->d_id.b.domain;
+ 	ct_req->req.gff_id.port_id[1] = fcport->d_id.b.area;
+ 	ct_req->req.gff_id.port_id[2] = fcport->d_id.b.al_pa;
+ 
+ 	sp->u.iocb_cmd.u.ctarg.req = fcport->ct_desc.ct_sns;
+ 	sp->u.iocb_cmd.u.ctarg.req_dma = fcport->ct_desc.ct_sns_dma;
+ 	sp->u.iocb_cmd.u.ctarg.rsp = fcport->ct_desc.ct_sns;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_dma = fcport->ct_desc.ct_sns_dma;
+ 	sp->u.iocb_cmd.u.ctarg.req_size = GFF_ID_REQ_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_size = GFF_ID_RSP_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;
+ 
+ 	sp->u.iocb_cmd.timeout = qla2x00_async_iocb_timeout;
+ 	sp->done = qla24xx_async_gffid_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x2132,
+ 	    "Async-%s hdl=%x  %8phC.\n", sp->name,
+ 	    sp->handle, fcport->port_name);
+ 
+ 	return rval;
+ done_free_sp:
+ 	sp->free(sp);
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	return rval;
+ }
+ 
+ /* GPN_FT + GNN_FT*/
+ static int qla2x00_is_a_vp(scsi_qla_host_t *vha, u64 wwn)
+ {
+ 	struct qla_hw_data *ha = vha->hw;
+ 	scsi_qla_host_t *vp;
+ 	unsigned long flags;
+ 	u64 twwn;
+ 	int rc = 0;
+ 
+ 	if (!ha->num_vhosts)
+ 		return 0;
+ 
+ 	spin_lock_irqsave(&ha->vport_slock, flags);
+ 	list_for_each_entry(vp, &ha->vp_list, list) {
+ 		twwn = wwn_to_u64(vp->port_name);
+ 		if (wwn == twwn) {
+ 			rc = 1;
+ 			break;
+ 		}
+ 	}
+ 	spin_unlock_irqrestore(&ha->vport_slock, flags);
+ 
+ 	return rc;
+ }
+ 
+ void qla24xx_async_gnnft_done(scsi_qla_host_t *vha, srb_t *sp)
+ {
+ 	fc_port_t *fcport;
+ 	u32 i, rc;
+ 	bool found;
+ 	u8 fc4type = sp->gen2;
+ 	struct fab_scan_rp *rp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "%s enter\n", __func__);
+ 
+ 	if (sp->gen1 != vha->hw->base_qpair->chip_reset) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		    "%s scan stop due to chip reset %x/%x\n",
+ 		    sp->name, sp->gen1, vha->hw->base_qpair->chip_reset);
+ 		goto out;
+ 	}
+ 
+ 	rc = sp->rc;
+ 	if (rc) {
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		    "GPNFT failed. FC4type %x. Rescanning.\n",
+ 		    fc4type);
+ 		set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
+ 		goto out;
+ 	}
+ 
+ 	list_for_each_entry(fcport, &vha->vp_fcports, list)
+ 		fcport->scan_state = QLA_FCPORT_SCAN;
+ 
+ 	for (i = 0; i < vha->hw->max_fibre_devices; i++) {
+ 		u64 wwn;
+ 
+ 		rp = &vha->scan.l[i];
+ 		found = false;
+ 
+ 		wwn = wwn_to_u64(rp->port_name);
+ 		if (wwn == 0)
+ 			continue;
+ 
+ 		if (!memcmp(rp->port_name, vha->port_name, WWN_SIZE))
+ 			continue;
+ 
+ 		/* Bypass reserved domain fields. */
+ 		if ((rp->id.b.domain & 0xf0) == 0xf0)
+ 			continue;
+ 
+ 		/* Bypass virtual ports of the same host. */
+ 		if (qla2x00_is_a_vp(vha, wwn))
+ 			continue;
+ 
+ 		list_for_each_entry(fcport, &vha->vp_fcports, list) {
+ 			if (memcmp(rp->port_name, fcport->port_name, WWN_SIZE))
+ 				continue;
+ 			fcport->scan_state = QLA_FCPORT_FOUND;
+ 			fcport->d_id.b24 = rp->id.b24;
+ 			found = true;
+ 			/*
+ 			 * If device was not a fabric device before.
+ 			 */
+ 			if ((fcport->flags & FCF_FABRIC_DEVICE) == 0) {
+ 				qla2x00_clear_loop_id(fcport);
+ 				fcport->flags |= FCF_FABRIC_DEVICE;
+ 			}
+ 			break;
+ 		}
+ 
+ 		if (!found) {
+ 			ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 			    "%s %d %8phC post new sess\n",
+ 			    __func__, __LINE__, rp->port_name);
+ 			qla24xx_post_newsess_work(vha, &rp->id, rp->port_name,
+ 			    rp->node_name, NULL, fc4type);
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Logout all previous fabric dev marked lost, except FCP2 devices.
+ 	 */
+ 	list_for_each_entry(fcport, &vha->vp_fcports, list) {
+ 		if ((fcport->flags & FCF_FABRIC_DEVICE) == 0)
+ 			continue;
+ 
+ 		if (fcport->scan_state == QLA_FCPORT_SCAN) {
+ 			if ((qla_dual_mode_enabled(vha) ||
+ 				qla_ini_mode_enabled(vha)) &&
+ 			    atomic_read(&fcport->state) == FCS_ONLINE) {
+ 				qla2x00_mark_device_lost(vha, fcport,
+ 				    ql2xplogiabsentdevice, 0);
+ 				if (fcport->loop_id != FC_NO_LOOP_ID &&
+ 				    (fcport->flags & FCF_FCP2_DEVICE) == 0 &&
+ 				    fcport->port_type != FCT_INITIATOR &&
+ 				    fcport->port_type != FCT_BROADCAST) {
+ 					ql_dbg(ql_dbg_disc, vha, 0x20f0,
+ 					    "%s %d %8phC post del sess\n",
+ 					    __func__, __LINE__,
+ 					    fcport->port_name);
+ 
+ 					qlt_schedule_sess_for_deletion_lock
+ 						(fcport);
+ 					continue;
+ 				}
+ 			}
+ 		}
+ 
+ 		if (fcport->scan_state == QLA_FCPORT_FOUND)
+ 			qla24xx_fcport_handle_login(vha, fcport);
+ 	}
+ 
+ out:
+ 	/* re-use gpnid_done to free resource */
+ 	qla24xx_async_gpnid_done(vha, sp);
+ }
+ 
+ static void qla2x00_async_gpnft_gnnft_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	struct qla_work_evt *e;
+ 	struct ct_sns_req *ct_req =
+ 		(struct ct_sns_req *)sp->u.iocb_cmd.u.ctarg.req;
+ 	struct ct_sns_gpnft_rsp *ct_rsp =
+ 		(struct ct_sns_gpnft_rsp *)sp->u.iocb_cmd.u.ctarg.rsp;
+ 	struct ct_sns_gpn_ft_data *d = &ct_rsp->entries[0];
+ 	struct fab_scan_rp *rp;
+ 	int i, j, k;
+ 	u16 cmd = be16_to_cpu(ct_req->command);
+ 
+ 	/* gen2 field is holding the fc4type */
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async done-%s res %x FC4Type %x\n",
+ 	    sp->name, res, sp->gen2);
+ 
+ 	if (!res) {
+ 		port_id_t id;
+ 		u64 wwn;
+ 
+ 		j = 0;
+ 		for (i = 0; i < vha->hw->max_fibre_devices; i++) {
+ 			d  = &ct_rsp->entries[i];
+ 
+ 			id.b.rsvd_1 = 0;
+ 			id.b.domain = d->port_id[0];
+ 			id.b.area   = d->port_id[1];
+ 			id.b.al_pa  = d->port_id[2];
+ 			wwn = wwn_to_u64(d->port_name);
+ 
+ 			if (id.b24 == 0 || wwn == 0)
+ 				continue;
+ 
+ 			if (cmd == GPN_FT_CMD) {
+ 				rp = &vha->scan.l[j];
+ 				rp->id = id;
+ 				memcpy(rp->port_name, d->port_name, 8);
+ 				j++;
+ 			} else {/* GNN_FT_CMD */
+ 				for (k = 0; k < vha->hw->max_fibre_devices;
+ 				    k++) {
+ 					rp = &vha->scan.l[k];
+ 					if (id.b24 == rp->id.b24) {
+ 						memcpy(rp->node_name,
+ 						    d->port_name, 8);
+ 						break;
+ 					}
+ 				}
+ 			}
+ 		}
+ 	}
+ 
+ 	if (cmd == GPN_FT_CMD)
+ 		e = qla2x00_alloc_work(vha, QLA_EVT_GPNFT_DONE);
+ 	else
+ 		e = qla2x00_alloc_work(vha, QLA_EVT_GNNFT_DONE);
+ 	if (!e) {
+ 		/* please ignore kernel warning. Otherwise, we have mem leak. */
+ 		if (sp->u.iocb_cmd.u.ctarg.req) {
+ 			dma_free_coherent(&vha->hw->pdev->dev,
+ 			    sizeof(struct ct_sns_pkt),
+ 			    sp->u.iocb_cmd.u.ctarg.req,
+ 			    sp->u.iocb_cmd.u.ctarg.req_dma);
+ 			sp->u.iocb_cmd.u.ctarg.req = NULL;
+ 		}
+ 		if (sp->u.iocb_cmd.u.ctarg.rsp) {
+ 			dma_free_coherent(&vha->hw->pdev->dev,
+ 			    sizeof(struct ct_sns_pkt),
+ 			    sp->u.iocb_cmd.u.ctarg.rsp,
+ 			    sp->u.iocb_cmd.u.ctarg.rsp_dma);
+ 			sp->u.iocb_cmd.u.ctarg.rsp = NULL;
+ 		}
+ 
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		    "Async done-%s unable to alloc work element\n",
+ 		    sp->name);
+ 		sp->free(sp);
+ 		set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
+ 		return;
+ 	}
+ 
+ 	sp->rc = res;
+ 	e->u.iosb.sp = sp;
+ 
+ 	qla2x00_post_work(vha, e);
+ }
+ 
+ /*
+  * Get WWNN list for fc4_type
+  *
+  * It is assumed the same SRB is re-used from GPNFT to avoid
+  * mem free & re-alloc
+  */
+ static int qla24xx_async_gnnft(scsi_qla_host_t *vha, struct srb *sp,
+     u8 fc4_type)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	struct ct_sns_req *ct_req;
+ 	struct ct_sns_pkt *ct_sns;
+ 
+ 	if (!vha->flags.online)
+ 		goto done_free_sp;
+ 
+ 	if (!sp->u.iocb_cmd.u.ctarg.req || !sp->u.iocb_cmd.u.ctarg.rsp) {
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "%s: req %p rsp %p are not setup\n",
+ 		    __func__, sp->u.iocb_cmd.u.ctarg.req,
+ 		    sp->u.iocb_cmd.u.ctarg.rsp);
+ 		WARN_ON(1);
+ 		goto done_free_sp;
+ 	}
+ 	sp->type = SRB_CT_PTHRU_CMD;
+ 	sp->name = "gnnft";
+ 	sp->gen1 = vha->hw->base_qpair->chip_reset;
+ 	sp->gen2 = fc4_type;
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	memset(sp->u.iocb_cmd.u.ctarg.rsp, 0, sp->u.iocb_cmd.u.ctarg.rsp_size);
+ 	memset(sp->u.iocb_cmd.u.ctarg.req, 0, sp->u.iocb_cmd.u.ctarg.req_size);
+ 
+ 	ct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.req;
+ 	/* CT_IU preamble  */
+ 	ct_req = qla2x00_prep_ct_req(ct_sns, GNN_FT_CMD,
+ 	    sp->u.iocb_cmd.u.ctarg.rsp_size);
+ 
+ 	/* GPN_FT req */
+ 	ct_req->req.gpn_ft.port_type = fc4_type;
+ 
+ 	sp->u.iocb_cmd.u.ctarg.req_size = GNN_FT_REQ_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;
+ 
+ 	sp->u.iocb_cmd.timeout = qla2x00_async_iocb_timeout;
+ 	sp->done = qla2x00_async_gpnft_gnnft_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async-%s hdl=%x FC4Type %x.\n", sp->name,
+ 	    sp->handle, ct_req->req.gpn_ft.port_type);
+ 	return rval;
+ 
+ done_free_sp:
+ 	if (sp->u.iocb_cmd.u.ctarg.req) {
+ 		dma_free_coherent(&vha->hw->pdev->dev,
+ 		    sizeof(struct ct_sns_pkt),
+ 		    sp->u.iocb_cmd.u.ctarg.req,
+ 		    sp->u.iocb_cmd.u.ctarg.req_dma);
+ 		sp->u.iocb_cmd.u.ctarg.req = NULL;
+ 	}
+ 	if (sp->u.iocb_cmd.u.ctarg.rsp) {
+ 		dma_free_coherent(&vha->hw->pdev->dev,
+ 		    sizeof(struct ct_sns_pkt),
+ 		    sp->u.iocb_cmd.u.ctarg.rsp,
+ 		    sp->u.iocb_cmd.u.ctarg.rsp_dma);
+ 		sp->u.iocb_cmd.u.ctarg.rsp = NULL;
+ 	}
+ 
+ 	sp->free(sp);
+ 
+ 	return rval;
+ } /* GNNFT */
+ 
+ void qla24xx_async_gpnft_done(scsi_qla_host_t *vha, srb_t *sp)
+ {
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "%s enter\n", __func__);
+ 	del_timer(&sp->u.iocb_cmd.timer);
+ 	qla24xx_async_gnnft(vha, sp, sp->gen2);
+ }
+ 
+ /* Get WWPN list for certain fc4_type */
+ int qla24xx_async_gpnft(scsi_qla_host_t *vha, u8 fc4_type)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	struct ct_sns_req       *ct_req;
+ 	srb_t *sp;
+ 	struct ct_sns_pkt *ct_sns;
+ 	u32 rspsz;
+ 
+ 	if (!vha->flags.online)
+ 		return rval;
+ 
+ 	sp = qla2x00_get_sp(vha, NULL, GFP_KERNEL);
+ 	if (!sp)
+ 		return rval;
+ 
+ 
+ 	sp->type = SRB_CT_PTHRU_CMD;
+ 	sp->name = "gpnft";
+ 	sp->gen1 = vha->hw->base_qpair->chip_reset;
+ 	sp->gen2 = fc4_type;
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	sp->u.iocb_cmd.u.ctarg.req = dma_zalloc_coherent(&vha->hw->pdev->dev,
+ 	    sizeof(struct ct_sns_pkt), &sp->u.iocb_cmd.u.ctarg.req_dma,
+ 	    GFP_KERNEL);
+ 	if (!sp->u.iocb_cmd.u.ctarg.req) {
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Failed to allocate ct_sns request.\n");
+ 		goto done_free_sp;
+ 	}
+ 
+ 	rspsz = sizeof(struct ct_sns_gpnft_rsp) +
+ 		((vha->hw->max_fibre_devices - 1) *
+ 		    sizeof(struct ct_sns_gpn_ft_data));
+ 
+ 	sp->u.iocb_cmd.u.ctarg.rsp = dma_zalloc_coherent(&vha->hw->pdev->dev,
+ 	    rspsz, &sp->u.iocb_cmd.u.ctarg.rsp_dma, GFP_KERNEL);
+ 	if (!sp->u.iocb_cmd.u.ctarg.rsp) {
+ 		ql_log(ql_log_warn, vha, 0xffff,
+ 		    "Failed to allocate ct_sns request.\n");
+ 		goto done_free_sp;
+ 	}
+ 
+ 	memset(vha->scan.l, 0, vha->scan.size);
+ 
+ 	ct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.req;
+ 	/* CT_IU preamble  */
+ 	ct_req = qla2x00_prep_ct_req(ct_sns, GPN_FT_CMD, rspsz);
+ 
+ 	/* GPN_FT req */
+ 	ct_req->req.gpn_ft.port_type = fc4_type;
+ 
+ 	sp->u.iocb_cmd.u.ctarg.req_size = GPN_FT_REQ_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_size = rspsz;
+ 	sp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;
+ 
+ 	sp->u.iocb_cmd.timeout = qla2x00_async_iocb_timeout;
+ 	sp->done = qla2x00_async_gpnft_gnnft_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async-%s hdl=%x FC4Type %x.\n", sp->name,
+ 	    sp->handle, ct_req->req.gpn_ft.port_type);
+ 	return rval;
+ 
+ done_free_sp:
+ 	if (sp->u.iocb_cmd.u.ctarg.req) {
+ 		dma_free_coherent(&vha->hw->pdev->dev,
+ 		    sizeof(struct ct_sns_pkt),
+ 		    sp->u.iocb_cmd.u.ctarg.req,
+ 		    sp->u.iocb_cmd.u.ctarg.req_dma);
+ 		sp->u.iocb_cmd.u.ctarg.req = NULL;
+ 	}
+ 	if (sp->u.iocb_cmd.u.ctarg.rsp) {
+ 		dma_free_coherent(&vha->hw->pdev->dev,
+ 		    sizeof(struct ct_sns_pkt),
+ 		    sp->u.iocb_cmd.u.ctarg.rsp,
+ 		    sp->u.iocb_cmd.u.ctarg.rsp_dma);
+ 		sp->u.iocb_cmd.u.ctarg.rsp = NULL;
+ 	}
+ 
+ 	sp->free(sp);
+ 
+ 	return rval;
+ }
+ 
+ /* GNN_ID */
+ void qla24xx_handle_gnnid_event(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	qla24xx_post_gnl_work(vha, ea->fcport);
+ }
+ 
+ static void qla2x00_async_gnnid_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	fc_port_t *fcport = sp->fcport;
+ 	u8 *node_name = fcport->ct_desc.ct_sns->p.rsp.rsp.gnn_id.node_name;
+ 	struct event_arg ea;
+ 	u64 wwnn;
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	wwnn = wwn_to_u64(node_name);
+ 	if (wwnn)
+ 		memcpy(fcport->node_name, node_name, WWN_SIZE);
+ 
+ 	memset(&ea, 0, sizeof(ea));
+ 	ea.fcport = fcport;
+ 	ea.sp = sp;
+ 	ea.rc = res;
+ 	ea.event = FCME_GNNID_DONE;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x204f,
+ 	    "Async done-%s res %x, WWPN %8phC %8phC\n",
+ 	    sp->name, res, fcport->port_name, fcport->node_name);
+ 
+ 	qla2x00_fcport_event_handler(vha, &ea);
+ 
+ 	sp->free(sp);
+ }
+ 
+ int qla24xx_async_gnnid(scsi_qla_host_t *vha, fc_port_t *fcport)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	struct ct_sns_req       *ct_req;
+ 	srb_t *sp;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	fcport->disc_state = DSC_GNN_ID;
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_ATOMIC);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	sp->type = SRB_CT_PTHRU_CMD;
+ 	sp->name = "gnnid";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	/* CT_IU preamble  */
+ 	ct_req = qla2x00_prep_ct_req(fcport->ct_desc.ct_sns, GNN_ID_CMD,
+ 	    GNN_ID_RSP_SIZE);
+ 
+ 	/* GNN_ID req */
+ 	ct_req->req.port_id.port_id[0] = fcport->d_id.b.domain;
+ 	ct_req->req.port_id.port_id[1] = fcport->d_id.b.area;
+ 	ct_req->req.port_id.port_id[2] = fcport->d_id.b.al_pa;
+ 
+ 
+ 	/* req & rsp use the same buffer */
+ 	sp->u.iocb_cmd.u.ctarg.req = fcport->ct_desc.ct_sns;
+ 	sp->u.iocb_cmd.u.ctarg.req_dma = fcport->ct_desc.ct_sns_dma;
+ 	sp->u.iocb_cmd.u.ctarg.rsp = fcport->ct_desc.ct_sns;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_dma = fcport->ct_desc.ct_sns_dma;
+ 	sp->u.iocb_cmd.u.ctarg.req_size = GNN_ID_REQ_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_size = GNN_ID_RSP_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;
+ 
+ 	sp->u.iocb_cmd.timeout = qla2x00_async_iocb_timeout;
+ 	sp->done = qla2x00_async_gnnid_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async-%s - %8phC hdl=%x loopid=%x portid %06x.\n",
+ 	    sp->name, fcport->port_name,
+ 	    sp->handle, fcport->loop_id, fcport->d_id.b24);
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	return rval;
+ }
+ 
+ int qla24xx_post_gnnid_work(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	struct qla_work_evt *e;
+ 	int ls;
+ 
+ 	ls = atomic_read(&vha->loop_state);
+ 	if (((ls != LOOP_READY) && (ls != LOOP_UP)) ||
+ 		test_bit(UNLOADING, &vha->dpc_flags))
+ 		return 0;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GNNID);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	return qla2x00_post_work(vha, e);
+ }
+ 
+ /* GPFN_ID */
+ void qla24xx_handle_gfpnid_event(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	fc_port_t *fcport = ea->fcport;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "%s %d %8phC post gpsc fcp_cnt %d\n",
+ 	    __func__, __LINE__, fcport->port_name,
+ 	    vha->fcport_count);
+ 
+ 	if (fcport->disc_state == DSC_DELETE_PEND)
+ 		return;
+ 
+ 	if (ea->sp->gen2 != fcport->login_gen) {
+ 		/* target side must have changed it. */
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d3,
+ 		    "%s %8phC generation changed rscn %d|%d login %d|%d\n",
+ 		    __func__, fcport->port_name, fcport->last_rscn_gen,
+ 		    fcport->rscn_gen, fcport->last_login_gen,
+ 		    fcport->login_gen);
+ 		return;
+ 	} else if (ea->sp->gen1 != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d4, "%s %d %8phC post gidpn\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		return;
+ 	}
+ 
+ 	qla24xx_post_gpsc_work(vha, fcport);
+ }
+ 
+ static void qla2x00_async_gfpnid_sp_done(void *s, int res)
+ {
+ 	struct srb *sp = s;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 	fc_port_t *fcport = sp->fcport;
+ 	u8 *fpn = fcport->ct_desc.ct_sns->p.rsp.rsp.gfpn_id.port_name;
+ 	struct event_arg ea;
+ 	u64 wwn;
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	wwn = wwn_to_u64(fpn);
+ 	if (wwn)
+ 		memcpy(fcport->fabric_port_name, fpn, WWN_SIZE);
+ 
+ 	memset(&ea, 0, sizeof(ea));
+ 	ea.fcport = fcport;
+ 	ea.sp = sp;
+ 	ea.rc = res;
+ 	ea.event = FCME_GFPNID_DONE;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x204f,
+ 	    "Async done-%s res %x, WWPN %8phC %8phC\n",
+ 	    sp->name, res, fcport->port_name, fcport->fabric_port_name);
+ 
+ 	qla2x00_fcport_event_handler(vha, &ea);
+ 
+ 	sp->free(sp);
+ }
+ 
+ int qla24xx_async_gfpnid(scsi_qla_host_t *vha, fc_port_t *fcport)
+ {
+ 	int rval = QLA_FUNCTION_FAILED;
+ 	struct ct_sns_req       *ct_req;
+ 	srb_t *sp;
+ 
+ 	if (!vha->flags.online)
+ 		goto done;
+ 
+ 	fcport->flags |= FCF_ASYNC_SENT;
+ 	fcport->disc_state = DSC_GFPN_ID;
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_ATOMIC);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	sp->type = SRB_CT_PTHRU_CMD;
+ 	sp->name = "gfpnid";
+ 	sp->gen1 = fcport->rscn_gen;
+ 	sp->gen2 = fcport->login_gen;
+ 
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	/* CT_IU preamble  */
+ 	ct_req = qla2x00_prep_ct_req(fcport->ct_desc.ct_sns, GFPN_ID_CMD,
+ 	    GFPN_ID_RSP_SIZE);
+ 
+ 	/* GFPN_ID req */
+ 	ct_req->req.port_id.port_id[0] = fcport->d_id.b.domain;
+ 	ct_req->req.port_id.port_id[1] = fcport->d_id.b.area;
+ 	ct_req->req.port_id.port_id[2] = fcport->d_id.b.al_pa;
+ 
+ 
+ 	/* req & rsp use the same buffer */
+ 	sp->u.iocb_cmd.u.ctarg.req = fcport->ct_desc.ct_sns;
+ 	sp->u.iocb_cmd.u.ctarg.req_dma = fcport->ct_desc.ct_sns_dma;
+ 	sp->u.iocb_cmd.u.ctarg.rsp = fcport->ct_desc.ct_sns;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_dma = fcport->ct_desc.ct_sns_dma;
+ 	sp->u.iocb_cmd.u.ctarg.req_size = GFPN_ID_REQ_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.rsp_size = GFPN_ID_RSP_SIZE;
+ 	sp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;
+ 
+ 	sp->u.iocb_cmd.timeout = qla2x00_async_iocb_timeout;
+ 	sp->done = qla2x00_async_gfpnid_sp_done;
+ 
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 	    "Async-%s - %8phC hdl=%x loopid=%x portid %06x.\n",
+ 	    sp->name, fcport->port_name,
+ 	    sp->handle, fcport->loop_id, fcport->d_id.b24);
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ done:
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 	return rval;
+ }
+ 
+ int qla24xx_post_gfpnid_work(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	struct qla_work_evt *e;
+ 	int ls;
+ 
+ 	ls = atomic_read(&vha->loop_state);
+ 	if (((ls != LOOP_READY) && (ls != LOOP_UP)) ||
+ 		test_bit(UNLOADING, &vha->dpc_flags))
+ 		return 0;
+ 
+ 	e = qla2x00_alloc_work(vha, QLA_EVT_GFPNID);
+ 	if (!e)
+ 		return QLA_FUNCTION_FAILED;
+ 
+ 	e->u.fcport.fcport = fcport;
+ 	return qla2x00_post_work(vha, e);
+ }
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 320a3c9ed887,f26acb7ce315..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -36,9 -36,12 +36,15 @@@ static int qla2x00_restart_isp(scsi_qla
  static struct qla_chip_state_84xx *qla84xx_get_chip(struct scsi_qla_host *);
  static int qla84xx_init_chip(scsi_qla_host_t *);
  static int qla25xx_init_queues(struct qla_hw_data *);
 -static int qla24xx_post_prli_work(struct scsi_qla_host*, fc_port_t *);
 +static int qla24xx_post_gpdb_work(struct scsi_qla_host *, fc_port_t *, u8);
  static void qla24xx_handle_plogi_done_event(struct scsi_qla_host *,
      struct event_arg *);
++<<<<<<< HEAD
++=======
+ static void qla24xx_handle_prli_done_event(struct scsi_qla_host *,
+     struct event_arg *);
+ static void __qla24xx_handle_gpdb_event(scsi_qla_host_t *, struct event_arg *);
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  
  /* SRB Extensions ---------------------------------------------------------- */
  
@@@ -272,6 -278,99 +281,102 @@@ done
  	return rval;
  }
  
++<<<<<<< HEAD
++=======
+ void
+ qla2x00_async_prlo_done(struct scsi_qla_host *vha, fc_port_t *fcport,
+     uint16_t *data)
+ {
+ 	/* Don't re-login in target mode */
+ 	if (!fcport->tgt_session)
+ 		qla2x00_mark_device_lost(vha, fcport, 1, 0);
+ 	qlt_logo_completion_handler(fcport, data[0]);
+ }
+ 
+ static void
+ qla2x00_async_prlo_sp_done(void *s, int res)
+ {
+ 	srb_t *sp = (srb_t *)s;
+ 	struct srb_iocb *lio = &sp->u.iocb_cmd;
+ 	struct scsi_qla_host *vha = sp->vha;
+ 
+ 	if (!test_bit(UNLOADING, &vha->dpc_flags))
+ 		qla2x00_post_async_prlo_done_work(sp->fcport->vha, sp->fcport,
+ 		    lio->u.logio.data);
+ 	sp->free(sp);
+ }
+ 
+ int
+ qla2x00_async_prlo(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	srb_t *sp;
+ 	struct srb_iocb *lio;
+ 	int rval;
+ 
+ 	rval = QLA_FUNCTION_FAILED;
+ 	sp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);
+ 	if (!sp)
+ 		goto done;
+ 
+ 	sp->type = SRB_PRLO_CMD;
+ 	sp->name = "prlo";
+ 	qla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);
+ 
+ 	lio = &sp->u.iocb_cmd;
+ 	lio->timeout = qla2x00_async_iocb_timeout;
+ 	sp->done = qla2x00_async_prlo_sp_done;
+ 	rval = qla2x00_start_sp(sp);
+ 	if (rval != QLA_SUCCESS)
+ 		goto done_free_sp;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x2070,
+ 	    "Async-prlo - hdl=%x loop-id=%x portid=%02x%02x%02x.\n",
+ 	    sp->handle, fcport->loop_id, fcport->d_id.b.domain,
+ 	    fcport->d_id.b.area, fcport->d_id.b.al_pa);
+ 	return rval;
+ 
+ done_free_sp:
+ 	sp->free(sp);
+ done:
+ 	return rval;
+ }
+ 
+ static
+ void qla24xx_handle_adisc_event(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	if (ea->rc) {
+ 		ql_dbg(ql_dbg_disc, vha, 0x2066,
+ 		    "%s %8phC: adisc fail: post delete\n",
+ 		    __func__, ea->fcport->port_name);
+ 		qlt_schedule_sess_for_deletion(ea->fcport, 1);
+ 		return;
+ 	}
+ 	ql_dbg(ql_dbg_disc, vha, 0x20d2,
+ 	    "%s %8phC DS %d LS %d\n", __func__, ea->fcport->port_name,
+ 	    ea->fcport->disc_state, ea->fcport->fw_login_state);
+ 
+ 	if (ea->fcport->disc_state == DSC_DELETE_PEND)
+ 		return;
+ 
+ 	if (ea->sp->gen2 != ea->fcport->login_gen) {
+ 		/* target side must have changed it. */
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d3,
+ 		    "%s %8phC generation changed rscn %d|%d login %d|%d\n",
+ 		    __func__, ea->fcport->port_name, ea->fcport->last_rscn_gen,
+ 		    ea->fcport->rscn_gen, ea->fcport->last_login_gen,
+ 		    ea->fcport->login_gen);
+ 		return;
+ 	} else if (ea->sp->gen1 != ea->fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d4, "%s %d %8phC post gidpn\n",
+ 		    __func__, __LINE__, ea->fcport->port_name);
+ 		qla24xx_post_gidpn_work(vha, ea->fcport);
+ 		return;
+ 	}
+ 
+ 	__qla24xx_handle_gpdb_event(vha, ea);
+ }
+ 
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  static void
  qla2x00_async_adisc_sp_done(void *ptr, int res)
  {
@@@ -333,7 -441,8 +438,12 @@@ static void qla24xx_handle_gnl_done_eve
  	u16 i, n, found = 0, loop_id;
  	port_id_t id;
  	u64 wwn;
++<<<<<<< HEAD
 +	u8 opt = 0;
++=======
+ 	u16 data[2];
+ 	u8 current_login_state;
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  
  	fcport = ea->fcport;
  
@@@ -425,10 -542,15 +538,16 @@@
  			ql_dbg(ql_dbg_disc, vha, 0x20e4,
  			    "%s %d %8phC post gpdb\n",
  			    __func__, __LINE__, fcport->port_name);
- 			opt = PDO_FORCE_ADISC;
- 			qla24xx_post_gpdb_work(vha, fcport, opt);
+ 
+ 			if ((e->prli_svc_param_word_3[0] & BIT_4) == 0)
+ 				fcport->port_type = FCT_INITIATOR;
+ 			else
+ 				fcport->port_type = FCT_TARGET;
+ 
+ 			data[0] = data[1] = 0;
+ 			qla2x00_post_async_adisc_work(vha, fcport, data);
  			break;
 +
  		case DSC_LS_PORT_UNAVAIL:
  		default:
  			if (fcport->loop_id == FC_NO_LOOP_ID) {
@@@ -757,44 -996,12 +896,45 @@@ done
  }
  
  static
- void qla24xx_handle_gpdb_event(scsi_qla_host_t *vha, struct event_arg *ea)
+ void __qla24xx_handle_gpdb_event(scsi_qla_host_t *vha, struct event_arg *ea)
  {
- 	int rval = ea->rc;
- 	fc_port_t *fcport = ea->fcport;
  	unsigned long flags;
 +	u16 opt = ea->sp->u.iocb_cmd.u.mbx.out_mb[10];
 +
++<<<<<<< HEAD
 +	fcport->flags &= ~FCF_ASYNC_SENT;
  
 +	ql_dbg(ql_dbg_disc, vha, 0x20d2,
 +	    "%s %8phC DS %d LS %d rval %d\n", __func__, fcport->port_name,
 +	    fcport->disc_state, fcport->fw_login_state, rval);
 +
 +	if (ea->sp->gen2 != fcport->login_gen) {
 +		/* target side must have changed it. */
 +		ql_dbg(ql_dbg_disc, vha, 0x20d3,
 +		    "%s %8phC generation changed rscn %d|%d login %d|%d \n",
 +		    __func__, fcport->port_name, fcport->last_rscn_gen,
 +		    fcport->rscn_gen, fcport->last_login_gen,
 +		    fcport->login_gen);
 +		return;
 +	} else if (ea->sp->gen1 != fcport->rscn_gen) {
 +		ql_dbg(ql_dbg_disc, vha, 0x20d4, "%s %d %8phC post gidpn\n",
 +		    __func__, __LINE__, fcport->port_name);
 +		qla24xx_post_gidpn_work(vha, fcport);
 +		return;
 +	}
 +
 +	if (rval != QLA_SUCCESS) {
 +		ql_dbg(ql_dbg_disc, vha, 0x20d5, "%s %d %8phC post del sess\n",
 +		    __func__, __LINE__, fcport->port_name);
 +		qlt_schedule_sess_for_deletion_lock(fcport);
 +		return;
 +	}
 +
++=======
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
 -	ea->fcport->login_gen++;
 +	if (opt != PDO_FORCE_ADISC)
 +		ea->fcport->login_gen++;
  	ea->fcport->deleted = 0;
  	ea->fcport->logout_on_delete = 1;
  
@@@ -822,30 -1037,112 +970,121 @@@
  		/*
  		 * We have an existing session. A late RSCN delivery
  		 * must have triggered the session to be re-validate.
- 		 * session is still valid.
+ 		 * Session is still valid.
  		 */
++<<<<<<< HEAD
 +		fcport->disc_state = DSC_LOGIN_COMPLETE;
++=======
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d6,
+ 		    "%s %d %8phC session revalidate success\n",
+ 		    __func__, __LINE__, ea->fcport->port_name);
+ 		 ea->fcport->disc_state = DSC_LOGIN_COMPLETE;
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  	}
  	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
- } /* gpdb event */
+ }
  
++<<<<<<< HEAD
 +int qla24xx_fcport_handle_login(struct scsi_qla_host *vha, fc_port_t *fcport)
 +{
- 	if (fcport->login_retry == 0)
- 		return 0;
++=======
+ static
+ void qla24xx_handle_gpdb_event(scsi_qla_host_t *vha, struct event_arg *ea)
+ {
+ 	int rval = ea->rc;
+ 	fc_port_t *fcport = ea->fcport;
+ 	struct port_database_24xx *pd;
+ 	struct srb *sp = ea->sp;
  
- 	if (fcport->scan_state != QLA_FCPORT_FOUND)
- 		return 0;
+ 	pd = (struct port_database_24xx *)sp->u.iocb_cmd.u.mbx.in;
+ 
+ 	fcport->flags &= ~FCF_ASYNC_SENT;
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x20d2,
+ 	    "%s %8phC DS %d LS %d rval %d\n", __func__, fcport->port_name,
+ 	    fcport->disc_state, pd->current_login_state, rval);
+ 
+ 	if (fcport->disc_state == DSC_DELETE_PEND)
+ 		return;
+ 
+ 	switch (pd->current_login_state) {
+ 	case PDS_PRLI_COMPLETE:
+ 		__qla24xx_parse_gpdb(vha, fcport, pd);
+ 		break;
+ 	case PDS_PLOGI_PENDING:
+ 	case PDS_PLOGI_COMPLETE:
+ 	case PDS_PRLI_PENDING:
+ 	case PDS_PRLI2_PENDING:
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d5, "%s %d %8phC relogin needed\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
+ 		return;
+ 	case PDS_LOGO_PENDING:
+ 	case PDS_PORT_UNAVAILABLE:
+ 	default:
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d5, "%s %d %8phC post del sess\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		qlt_schedule_sess_for_deletion_lock(fcport);
+ 		return;
+ 	}
+ 	__qla24xx_handle_gpdb_event(vha, ea);
+ } /* gpdb event */
+ 
+ static void qla_chk_n2n_b4_login(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	u8 login = 0;
+ 
+ 	if (qla_tgt_mode_enabled(vha))
+ 		return;
+ 
+ 	if (qla_dual_mode_enabled(vha)) {
+ 		if (N2N_TOPO(vha->hw)) {
+ 			u64 mywwn, wwn;
+ 
+ 			mywwn = wwn_to_u64(vha->port_name);
+ 			wwn = wwn_to_u64(fcport->port_name);
+ 			if (mywwn > wwn)
+ 				login = 1;
+ 			else if ((fcport->fw_login_state == DSC_LS_PLOGI_COMP)
+ 			    && time_after_eq(jiffies,
+ 				    fcport->plogi_nack_done_deadline))
+ 				login = 1;
+ 		} else {
+ 			login = 1;
+ 		}
+ 	} else {
+ 		/* initiator mode */
+ 		login = 1;
+ 	}
+ 
+ 	if (login) {
+ 		ql_dbg(ql_dbg_disc, vha, 0x20bf,
+ 		    "%s %d %8phC post login\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		fcport->disc_state = DSC_LOGIN_PEND;
+ 		qla2x00_post_async_login_work(vha, fcport, NULL);
+ 	}
+ }
+ 
+ int qla24xx_fcport_handle_login(struct scsi_qla_host *vha, fc_port_t *fcport)
+ {
+ 	u16 data[2];
+ 	u64 wwn;
  
  	ql_dbg(ql_dbg_disc, vha, 0x20d8,
- 	    "%s %8phC DS %d LS %d P %d fl %x confl %p rscn %d|%d login %d|%d retry %d lid %d\n",
+ 	    "%s %8phC DS %d LS %d P %d fl %x confl %p rscn %d|%d login %d|%d retry %d lid %d scan %d\n",
  	    __func__, fcport->port_name, fcport->disc_state,
  	    fcport->fw_login_state, fcport->login_pause, fcport->flags,
  	    fcport->conflict, fcport->last_rscn_gen, fcport->rscn_gen,
  	    fcport->last_login_gen, fcport->login_gen, fcport->login_retry,
- 	    fcport->loop_id);
+ 	    fcport->loop_id, fcport->scan_state);
  
- 	fcport->login_retry--;
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
+ 	if (fcport->login_retry == 0)
+ 		return 0;
+ 
+ 	if (fcport->scan_state != QLA_FCPORT_FOUND)
+ 		return 0;
  
  	if ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||
  	    (fcport->fw_login_state == DSC_LS_PRLI_PEND))
@@@ -1146,8 -1418,17 +1372,22 @@@ void qla2x00_fcport_event_handler(scsi_
  	case FCME_GPNID_DONE:
  		qla24xx_handle_gpnid_event(vha, ea);
  		break;
++<<<<<<< HEAD
 +	case FCME_DELETE_DONE:
 +		qla24xx_handle_delete_done_event(vha, ea);
++=======
+ 	case FCME_GFFID_DONE:
+ 		qla24xx_handle_gffid_event(vha, ea);
+ 		break;
+ 	case FCME_ADISC_DONE:
+ 		qla24xx_handle_adisc_event(vha, ea);
+ 		break;
+ 	case FCME_GNNID_DONE:
+ 		qla24xx_handle_gnnid_event(vha, ea);
+ 		break;
+ 	case FCME_GFPNID_DONE:
+ 		qla24xx_handle_gfpnid_event(vha, ea);
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  		break;
  	default:
  		BUG_ON(1);
@@@ -1326,6 -1635,36 +1566,39 @@@ static voi
  qla24xx_handle_plogi_done_event(struct scsi_qla_host *vha, struct event_arg *ea)
  {
  	port_id_t cid;	/* conflict Nport id */
++<<<<<<< HEAD
++=======
+ 	u16 lid;
+ 	struct fc_port *conflict_fcport;
+ 	unsigned long flags;
+ 	struct fc_port *fcport = ea->fcport;
+ 
+ 	if ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||
+ 	    (fcport->fw_login_state == DSC_LS_PRLI_PEND)) {
+ 		ql_dbg(ql_dbg_disc, vha, 0x20ea,
+ 		    "%s %d %8phC Remote is trying to login\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		return;
+ 	}
+ 
+ 	if (fcport->disc_state == DSC_DELETE_PEND)
+ 		return;
+ 
+ 	if (ea->sp->gen2 != fcport->login_gen) {
+ 		/* target side must have changed it. */
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d3,
+ 		    "%s %8phC generation changed rscn %d|%d login %d|%d\n",
+ 		    __func__, fcport->port_name, fcport->last_rscn_gen,
+ 		    fcport->rscn_gen, fcport->last_login_gen,
+ 		    fcport->login_gen);
+ 		return;
+ 	} else if (ea->sp->gen1 != fcport->rscn_gen) {
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d4, "%s %d %8phC post gidpn\n",
+ 		    __func__, __LINE__, fcport->port_name);
+ 		qla24xx_post_gidpn_work(vha, fcport);
+ 		return;
+ 	}
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  
  	switch (ea->data[0]) {
  	case MBS_COMMAND_COMPLETE:
diff --cc drivers/scsi/qla2xxx/qla_mbx.c
index 4649e83dd88d,8455058cd724..000000000000
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@@ -3749,6 -3875,40 +3749,43 @@@ qla24xx_report_id_acquisition(scsi_qla_
  		spin_lock_irqsave(&ha->vport_slock, flags);
  		qlt_update_vp_map(vha, SET_AL_PA);
  		spin_unlock_irqrestore(&ha->vport_slock, flags);
++<<<<<<< HEAD
++=======
+ 
+ 		list_for_each_entry(fcport, &vha->vp_fcports, list) {
+ 			fcport->scan_state = QLA_FCPORT_SCAN;
+ 		}
+ 
+ 		fcport = qla2x00_find_fcport_by_wwpn(vha,
+ 		    rptid_entry->u.f2.port_name, 1);
+ 
+ 		if (fcport) {
+ 			fcport->plogi_nack_done_deadline = jiffies + HZ;
+ 			fcport->scan_state = QLA_FCPORT_FOUND;
+ 			switch (fcport->disc_state) {
+ 			case DSC_DELETED:
+ 				ql_dbg(ql_dbg_disc, vha, 0x210d,
+ 				    "%s %d %8phC login\n",
+ 				    __func__, __LINE__, fcport->port_name);
+ 				qla24xx_fcport_handle_login(vha, fcport);
+ 				break;
+ 			case DSC_DELETE_PEND:
+ 				break;
+ 			default:
+ 				qlt_schedule_sess_for_deletion_lock(fcport);
+ 				break;
+ 			}
+ 		} else {
+ 			id.b.al_pa  = rptid_entry->u.f2.remote_nport_id[0];
+ 			id.b.area   = rptid_entry->u.f2.remote_nport_id[1];
+ 			id.b.domain = rptid_entry->u.f2.remote_nport_id[2];
+ 			qla24xx_post_newsess_work(vha, &id,
+ 			    rptid_entry->u.f2.port_name,
+ 			    rptid_entry->u.f2.node_name,
+ 			    NULL,
+ 			    FC4_TYPE_UNKNOWN);
+ 		}
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  	}
  }
  
diff --cc drivers/scsi/qla2xxx/qla_os.c
index d767db87e0ef,5d909f4ab6c2..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -4741,7 -4774,12 +4755,8 @@@ void qla24xx_create_new_sess(struct scs
  	struct qlt_plogi_ack_t *pla =
  	    (struct qlt_plogi_ack_t *)e->u.new_sess.pla;
  	uint8_t free_fcport = 0;
+ 	u64 wwn;
  
 -	ql_dbg(ql_dbg_disc, vha, 0xffff,
 -	    "%s %d %8phC enter\n",
 -	    __func__, __LINE__, e->u.new_sess.port_name);
 -
  	spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
  	fcport = qla2x00_find_fcport_by_wwpn(vha, e->u.new_sess.port_name, 1);
  	if (fcport) {
@@@ -4800,10 -4842,73 +4816,80 @@@
  	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
  
  	if (fcport) {
++<<<<<<< HEAD
 +		if (pla)
 +			qlt_plogi_ack_unref(vha, pla);
 +		else
 +			qla24xx_async_gnl(vha, fcport);
++=======
+ 		if (N2N_TOPO(vha->hw))
+ 			fcport->flags &= ~FCF_FABRIC_DEVICE;
+ 
+ 		fcport->id_changed = 1;
+ 		fcport->scan_state = QLA_FCPORT_FOUND;
+ 		memcpy(fcport->node_name, e->u.new_sess.node_name, WWN_SIZE);
+ 
+ 		if (pla) {
+ 			if (pla->iocb.u.isp24.status_subcode == ELS_PRLI) {
+ 				u16 wd3_lo;
+ 
+ 				fcport->fw_login_state = DSC_LS_PRLI_PEND;
+ 				fcport->local = 0;
+ 				fcport->loop_id =
+ 					le16_to_cpu(
+ 					    pla->iocb.u.isp24.nport_handle);
+ 				fcport->fw_login_state = DSC_LS_PRLI_PEND;
+ 				wd3_lo =
+ 				    le16_to_cpu(
+ 					pla->iocb.u.isp24.u.prli.wd3_lo);
+ 
+ 				if (wd3_lo & BIT_7)
+ 					fcport->conf_compl_supported = 1;
+ 
+ 				if ((wd3_lo & BIT_4) == 0)
+ 					fcport->port_type = FCT_INITIATOR;
+ 				else
+ 					fcport->port_type = FCT_TARGET;
+ 			}
+ 			qlt_plogi_ack_unref(vha, pla);
+ 		} else {
+ 			spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 			tfcp = qla2x00_find_fcport_by_nportid(vha,
+ 			    &e->u.new_sess.id, 1);
+ 			if (tfcp && (tfcp != fcport)) {
+ 				/*
+ 				 * We have a conflict fcport with same NportID.
+ 				 */
+ 				ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 				    "%s %8phC found conflict b4 add. DS %d LS %d\n",
+ 				    __func__, tfcp->port_name, tfcp->disc_state,
+ 				    tfcp->fw_login_state);
+ 
+ 				switch (tfcp->disc_state) {
+ 				case DSC_DELETED:
+ 					break;
+ 				case DSC_DELETE_PEND:
+ 					fcport->login_pause = 1;
+ 					tfcp->conflict = fcport;
+ 					break;
+ 				default:
+ 					fcport->login_pause = 1;
+ 					tfcp->conflict = fcport;
+ 					qlt_schedule_sess_for_deletion_lock
+ 						(tfcp);
+ 					break;
+ 				}
+ 			}
+ 			spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 
+ 			wwn = wwn_to_u64(fcport->node_name);
+ 
+ 			if (!wwn)
+ 				qla24xx_async_gnnid(vha, fcport);
+ 			else
+ 				qla24xx_async_gnl(vha, fcport);
+ 		}
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  	}
  
  	if (free_fcport) {
@@@ -4888,6 -4999,28 +4974,31 @@@ qla2x00_do_work(struct scsi_qla_host *v
  		case QLA_EVT_NACK:
  			qla24xx_do_nack_work(vha, e);
  			break;
++<<<<<<< HEAD
++=======
+ 		case QLA_EVT_ASYNC_PRLO:
+ 			qla2x00_async_prlo(vha, e->u.logio.fcport);
+ 			break;
+ 		case QLA_EVT_ASYNC_PRLO_DONE:
+ 			qla2x00_async_prlo_done(vha, e->u.logio.fcport,
+ 			    e->u.logio.data);
+ 			break;
+ 		case QLA_EVT_GPNFT:
+ 			qla24xx_async_gpnft(vha, e->u.gpnft.fc4_type);
+ 			break;
+ 		case QLA_EVT_GPNFT_DONE:
+ 			qla24xx_async_gpnft_done(vha, e->u.iosb.sp);
+ 			break;
+ 		case QLA_EVT_GNNFT_DONE:
+ 			qla24xx_async_gnnft_done(vha, e->u.iosb.sp);
+ 			break;
+ 		case QLA_EVT_GNNID:
+ 			qla24xx_async_gnnid(vha, e->u.fcport.fcport);
+ 			break;
+ 		case QLA_EVT_GFPNID:
+ 			qla24xx_async_gfpnid(vha, e->u.fcport.fcport);
+ 			break;
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  		}
  		if (e->flags & QLA_EVT_FLAG_FREE)
  			kfree(e);
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 1c8ec70c5535,d4ead404100c..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -948,8 -969,9 +948,7 @@@ static void qlt_free_session_done(struc
  	struct qla_hw_data *ha = vha->hw;
  	unsigned long flags;
  	bool logout_started = false;
- 	struct event_arg ea;
  	scsi_qla_host_t *base_vha;
 -	struct qlt_plogi_ack_t *own =
 -		sess->plogi_link[QLT_PLOGI_LINK_SAME_WWN];
  
  	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf084,
  		"%s: se_sess %p / sess %p from port %8phC loop_id %#04x"
@@@ -4286,11 -4332,16 +4293,21 @@@ static int qlt_handle_cmd_for_atio(stru
  		return -EFAULT;
  	}
  
++<<<<<<< HEAD
 +	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,
 +	    atio->u.isp24.fcp_hdr.s_id);
++=======
+ 	id.b.al_pa = atio->u.isp24.fcp_hdr.s_id[2];
+ 	id.b.area = atio->u.isp24.fcp_hdr.s_id[1];
+ 	id.b.domain = atio->u.isp24.fcp_hdr.s_id[0];
+ 	if (IS_SW_RESV_ADDR(id))
+ 		return -EBUSY;
+ 
+ 	sess = ha->tgt.tgt_ops->find_sess_by_s_id(vha, atio->u.isp24.fcp_hdr.s_id);
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  	if (unlikely(!sess)) {
 -		struct qla_tgt_sess_op *op = kzalloc(sizeof(struct qla_tgt_sess_op),
 -						     GFP_ATOMIC);
 +		struct qla_tgt_sess_op *op =
 +		    kzalloc(sizeof(struct qla_tgt_sess_op), GFP_ATOMIC);
  		if (!op)
  			return -ENOMEM;
  
@@@ -4652,6 -4700,138 +4669,141 @@@ static int abort_cmds_for_s_id(struct s
  	return count;
  }
  
++<<<<<<< HEAD
++=======
+ static int qlt_handle_login(struct scsi_qla_host *vha,
+     struct imm_ntfy_from_isp *iocb)
+ {
+ 	struct fc_port *sess = NULL, *conflict_sess = NULL;
+ 	uint64_t wwn;
+ 	port_id_t port_id;
+ 	uint16_t loop_id, wd3_lo;
+ 	int res = 0;
+ 	struct qlt_plogi_ack_t *pla;
+ 	unsigned long flags;
+ 
+ 	wwn = wwn_to_u64(iocb->u.isp24.port_name);
+ 
+ 	port_id.b.domain = iocb->u.isp24.port_id[2];
+ 	port_id.b.area   = iocb->u.isp24.port_id[1];
+ 	port_id.b.al_pa  = iocb->u.isp24.port_id[0];
+ 	port_id.b.rsvd_1 = 0;
+ 
+ 	loop_id = le16_to_cpu(iocb->u.isp24.nport_handle);
+ 
+ 	/* Mark all stale commands sitting in qla_tgt_wq for deletion */
+ 	abort_cmds_for_s_id(vha, &port_id);
+ 
+ 	if (wwn) {
+ 		spin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);
+ 		sess = qlt_find_sess_invalidate_other(vha, wwn,
+ 		    port_id, loop_id, &conflict_sess);
+ 		spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
+ 	}
+ 
+ 	if (IS_SW_RESV_ADDR(port_id)) {
+ 		res = 1;
+ 		goto out;
+ 	}
+ 
+ 	pla = qlt_plogi_ack_find_add(vha, &port_id, iocb);
+ 	if (!pla) {
+ 		qlt_send_term_imm_notif(vha, iocb, 1);
+ 		goto out;
+ 	}
+ 
+ 	if (conflict_sess) {
+ 		conflict_sess->login_gen++;
+ 		qlt_plogi_ack_link(vha, pla, conflict_sess,
+ 		    QLT_PLOGI_LINK_CONFLICT);
+ 	}
+ 
+ 	if (!sess) {
+ 		pla->ref_count++;
+ 		ql_dbg(ql_dbg_disc, vha, 0xffff,
+ 		    "%s %d %8phC post new sess\n",
+ 		    __func__, __LINE__, iocb->u.isp24.port_name);
+ 		if (iocb->u.isp24.status_subcode == ELS_PLOGI)
+ 			qla24xx_post_newsess_work(vha, &port_id,
+ 			    iocb->u.isp24.port_name,
+ 			    iocb->u.isp24.u.plogi.node_name,
+ 			    pla, FC4_TYPE_UNKNOWN);
+ 		else
+ 			qla24xx_post_newsess_work(vha, &port_id,
+ 			    iocb->u.isp24.port_name, NULL,
+ 			    pla, FC4_TYPE_UNKNOWN);
+ 
+ 		goto out;
+ 	}
+ 
+ 	qlt_plogi_ack_link(vha, pla, sess, QLT_PLOGI_LINK_SAME_WWN);
+ 	sess->d_id = port_id;
+ 	sess->login_gen++;
+ 
+ 	if (iocb->u.isp24.status_subcode == ELS_PRLI) {
+ 		sess->fw_login_state = DSC_LS_PRLI_PEND;
+ 		sess->local = 0;
+ 		sess->loop_id = loop_id;
+ 		sess->d_id = port_id;
+ 		sess->fw_login_state = DSC_LS_PRLI_PEND;
+ 		wd3_lo = le16_to_cpu(iocb->u.isp24.u.prli.wd3_lo);
+ 
+ 		if (wd3_lo & BIT_7)
+ 			sess->conf_compl_supported = 1;
+ 
+ 		if ((wd3_lo & BIT_4) == 0)
+ 			sess->port_type = FCT_INITIATOR;
+ 		else
+ 			sess->port_type = FCT_TARGET;
+ 
+ 	} else
+ 		sess->fw_login_state = DSC_LS_PLOGI_PEND;
+ 
+ 
+ 	ql_dbg(ql_dbg_disc, vha, 0x20f9,
+ 	    "%s %d %8phC  DS %d\n",
+ 	    __func__, __LINE__, sess->port_name, sess->disc_state);
+ 
+ 	switch (sess->disc_state) {
+ 	case DSC_DELETED:
+ 		qlt_plogi_ack_unref(vha, pla);
+ 		break;
+ 
+ 	default:
+ 		/*
+ 		 * Under normal circumstances we want to release nport handle
+ 		 * during LOGO process to avoid nport handle leaks inside FW.
+ 		 * The exception is when LOGO is done while another PLOGI with
+ 		 * the same nport handle is waiting as might be the case here.
+ 		 * Note: there is always a possibily of a race where session
+ 		 * deletion has already started for other reasons (e.g. ACL
+ 		 * removal) and now PLOGI arrives:
+ 		 * 1. if PLOGI arrived in FW after nport handle has been freed,
+ 		 *    FW must have assigned this PLOGI a new/same handle and we
+ 		 *    can proceed ACK'ing it as usual when session deletion
+ 		 *    completes.
+ 		 * 2. if PLOGI arrived in FW before LOGO with LCF_FREE_NPORT
+ 		 *    bit reached it, the handle has now been released. We'll
+ 		 *    get an error when we ACK this PLOGI. Nothing will be sent
+ 		 *    back to initiator. Initiator should eventually retry
+ 		 *    PLOGI and situation will correct itself.
+ 		 */
+ 		sess->keep_nport_handle = ((sess->loop_id == loop_id) &&
+ 		    (sess->d_id.b24 == port_id.b24));
+ 
+ 		ql_dbg(ql_dbg_disc, vha, 0x20f9,
+ 		    "%s %d %8phC post del sess\n",
+ 		    __func__, __LINE__, sess->port_name);
+ 
+ 
+ 		qlt_schedule_sess_for_deletion_lock(sess);
+ 		break;
+ 	}
+ out:
+ 	return res;
+ }
+ 
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  /*
   * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire
   */
@@@ -4690,88 -4869,32 +4842,96 @@@ static int qlt_24xx_handle_els(struct s
  	 */
  	switch (iocb->u.isp24.status_subcode) {
  	case ELS_PLOGI:
 -		res = qlt_handle_login(vha, iocb);
 -		break;
  
 -	case ELS_PRLI:
 -		if (N2N_TOPO(ha)) {
 -			sess = qla2x00_find_fcport_by_wwpn(vha,
 -			    iocb->u.isp24.port_name, 1);
 +		/* Mark all stale commands in qla_tgt_wq for deletion */
 +		abort_cmds_for_s_id(vha, &port_id);
  
 -			if (sess && sess->plogi_link[QLT_PLOGI_LINK_SAME_WWN]) {
 -				ql_dbg(ql_dbg_disc, vha, 0xffff,
 -				    "%s %d %8phC Term PRLI due to PLOGI ACK not completed\n",
 -				    __func__, __LINE__,
 -				    iocb->u.isp24.port_name);
 -				qlt_send_term_imm_notif(vha, iocb, 1);
 -				break;
 -			}
 +		if (wwn) {
 +			spin_lock_irqsave(&tgt->ha->tgt.sess_lock, flags);
 +			sess = qlt_find_sess_invalidate_other(vha, wwn,
 +				port_id, loop_id, &conflict_sess);
 +			spin_unlock_irqrestore(&tgt->ha->tgt.sess_lock, flags);
 +		}
 +
 +		if (IS_SW_RESV_ADDR(port_id)) {
 +			res = 1;
 +			break;
 +		}
 +
++<<<<<<< HEAD
 +		pla = qlt_plogi_ack_find_add(vha, &port_id, iocb);
 +		if (!pla) {
 +			qlt_send_term_imm_notif(vha, iocb, 1);
 +			break;
 +		}
 +
 +		res = 0;
 +
 +		if (conflict_sess) {
 +			conflict_sess->login_gen++;
 +			qlt_plogi_ack_link(vha, pla, conflict_sess,
 +				QLT_PLOGI_LINK_CONFLICT);
 +		}
  
 -			res = qlt_handle_login(vha, iocb);
 +		if (!sess) {
 +			pla->ref_count++;
 +			qla24xx_post_newsess_work(vha, &port_id,
 +				iocb->u.isp24.port_name, pla);
 +			res = 0;
  			break;
  		}
  
 +		qlt_plogi_ack_link(vha, pla, sess, QLT_PLOGI_LINK_SAME_WWN);
 +		sess->fw_login_state = DSC_LS_PLOGI_PEND;
 +		sess->d_id = port_id;
 +		sess->login_gen++;
 +
 +		switch (sess->disc_state) {
 +		case DSC_DELETED:
 +			qlt_plogi_ack_unref(vha, pla);
 +			break;
 +
 +		default:
 +			/*
 +			 * Under normal circumstances we want to release nport handle
 +			 * during LOGO process to avoid nport handle leaks inside FW.
 +			 * The exception is when LOGO is done while another PLOGI with
 +			 * the same nport handle is waiting as might be the case here.
 +			 * Note: there is always a possibily of a race where session
 +			 * deletion has already started for other reasons (e.g. ACL
 +			 * removal) and now PLOGI arrives:
 +			 * 1. if PLOGI arrived in FW after nport handle has been freed,
 +			 *    FW must have assigned this PLOGI a new/same handle and we
 +			 *    can proceed ACK'ing it as usual when session deletion
 +			 *    completes.
 +			 * 2. if PLOGI arrived in FW before LOGO with LCF_FREE_NPORT
 +			 *    bit reached it, the handle has now been released. We'll
 +			 *    get an error when we ACK this PLOGI. Nothing will be sent
 +			 *    back to initiator. Initiator should eventually retry
 +			 *    PLOGI and situation will correct itself.
 +			 */
 +			sess->keep_nport_handle = ((sess->loop_id == loop_id) &&
 +			   (sess->d_id.b24 == port_id.b24));
 +
 +			ql_dbg(ql_dbg_disc, vha, 0x20f9,
 +			    "%s %d %8phC post del sess\n",
 +			    __func__, __LINE__, sess->port_name);
 +
 +
 +			qlt_schedule_sess_for_deletion_lock(sess);
 +			break;
 +		}
 +
 +		break;
 +
 +	case ELS_PRLI:
++=======
+ 		if (IS_SW_RESV_ADDR(port_id)) {
+ 			res = 1;
+ 			break;
+ 		}
+ 
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  		wd3_lo = le16_to_cpu(iocb->u.isp24.u.prli.wd3_lo);
  
  		if (wwn) {
@@@ -4791,8 -4922,34 +4951,39 @@@
  		}
  
  		if (sess != NULL) {
++<<<<<<< HEAD
 +			if (sess->fw_login_state != DSC_LS_PLOGI_PEND &&
 +			    sess->fw_login_state != DSC_LS_PLOGI_COMP) {
++=======
+ 			bool delete = false;
+ 			spin_lock_irqsave(&tgt->ha->tgt.sess_lock, flags);
+ 			switch (sess->fw_login_state) {
+ 			case DSC_LS_PLOGI_PEND:
+ 			case DSC_LS_PLOGI_COMP:
+ 			case DSC_LS_PRLI_COMP:
+ 				break;
+ 			default:
+ 				delete = true;
+ 				break;
+ 			}
+ 
+ 			switch (sess->disc_state) {
+ 			case DSC_LOGIN_PEND:
+ 			case DSC_GPDB:
+ 			case DSC_GPSC:
+ 			case DSC_UPD_FCPORT:
+ 			case DSC_LOGIN_COMPLETE:
+ 			case DSC_ADISC:
+ 				delete = false;
+ 				break;
+ 			default:
+ 				break;
+ 			}
+ 
+ 			if (delete) {
+ 				spin_unlock_irqrestore(&tgt->ha->tgt.sess_lock,
+ 				    flags);
++>>>>>>> a4239945b8ad (scsi: qla2xxx: Add switch command to simplify fabric discovery)
  				/*
  				 * Impatient initiator sent PRLI before last
  				 * PLOGI could finish. Will force him to re-try,
diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c
index dad0be0fa058..c1568ce6cf4a 100644
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@ -2135,6 +2135,8 @@ qla24xx_vport_delete(struct fc_vport *fc_vport)
 	dma_free_coherent(&ha->pdev->dev, vha->gnl.size, vha->gnl.l,
 	    vha->gnl.ldma);
 
+	vfree(vha->scan.l);
+
 	if (vha->qpair && vha->qpair->vp_idx == vha->vp_idx) {
 		if (qla2xxx_delete_qpair(vha, vha->qpair) != QLA_SUCCESS)
 			ql_log(ql_log_warn, vha, 0x7087,
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_gbl.h
* Unmerged path drivers/scsi/qla2xxx/qla_gs.c
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
* Unmerged path drivers/scsi/qla2xxx/qla_mbx.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
diff --git a/drivers/scsi/qla2xxx/qla_target.h b/drivers/scsi/qla2xxx/qla_target.h
index b93b39992329..fda965003108 100644
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@ -994,7 +994,7 @@ struct qla_tgt_prm {
 
 /* Check for Switch reserved address */
 #define IS_SW_RESV_ADDR(_s_id) \
-	((_s_id.b.domain == 0xff) && (_s_id.b.area == 0xfc))
+	((_s_id.b.domain == 0xff) && ((_s_id.b.area & 0xf0) == 0xf0))
 
 #define QLA_TGT_XMIT_DATA		1
 #define QLA_TGT_XMIT_STATUS		2
