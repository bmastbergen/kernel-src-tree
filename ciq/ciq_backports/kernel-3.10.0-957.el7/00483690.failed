tcp: Add mark for TIMEWAIT sockets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jon Maxwell <jmaxwell37@gmail.com>
commit 00483690552c5fb6aa30bf3acb75b0ee89b4c0fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/00483690.failed

This version has some suggestions by Eric Dumazet:

- Use a local variable for the mark in IPv6 instead of ctl_sk to avoid SMP
races.
- Use the more elegant "IP4_REPLY_MARK(net, skb->mark) ?: sk->sk_mark"
statement.
- Factorize code as sk_fullsock() check is not necessary.

Aidan McGurn from Openwave Mobility systems reported the following bug:

"Marked routing is broken on customer deployment. Its effects are large
increase in Uplink retransmissions caused by the client never receiving
the final ACK to their FINACK - this ACK misses the mark and routes out
of the incorrect route."

Currently marks are added to sk_buffs for replies when the "fwmark_reflect"
sysctl is enabled. But not for TW sockets that had sk->sk_mark set via
setsockopt(SO_MARK..).

Fix this in IPv4/v6 by adding tw->tw_mark for TIME_WAIT sockets. Copy the the
original sk->sk_mark in __inet_twsk_hashdance() to the new tw->tw_mark location.
Then progate this so that the skb gets sent with the correct mark. Do the same
for resets. Give the "fwmark_reflect" sysctl precedence over sk->sk_mark so that
netfilter rules are still honored.

	Signed-off-by: Jon Maxwell <jmaxwell37@gmail.com>
	Reviewed-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 00483690552c5fb6aa30bf3acb75b0ee89b4c0fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ip_output.c
#	net/ipv4/tcp_ipv4.c
#	net/ipv6/tcp_ipv6.c
diff --cc net/ipv4/ip_output.c
index 32464a1343b0,b5e21eb198d8..000000000000
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@@ -1576,8 -1556,12 +1576,17 @@@ void ip_send_unicast_reply(struct sock 
  			daddr = replyopts.opt.opt.faddr;
  	}
  
++<<<<<<< HEAD
 +	flowi4_init_output(&fl4, arg->bound_dev_if,
 +			   IP4_REPLY_MARK(net, skb->mark),
++=======
+ 	oif = arg->bound_dev_if;
+ 	if (!oif && netif_index_is_l3_master(net, skb->skb_iif))
+ 		oif = skb->skb_iif;
+ 
+ 	flowi4_init_output(&fl4, oif,
+ 			   IP4_REPLY_MARK(net, skb->mark) ?: sk->sk_mark,
++>>>>>>> 00483690552c (tcp: Add mark for TIMEWAIT sockets)
  			   RT_TOS(arg->tos),
  			   RT_SCOPE_UNIVERSE, ip_hdr(skb)->protocol,
  			   ip_reply_arg_flowi_flags(arg),
diff --cc net/ipv4/tcp_ipv4.c
index b635ea161b80,caf23de88f8a..000000000000
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@@ -687,20 -722,25 +688,37 @@@ static void tcp_v4_send_reset(struct so
  		     offsetof(struct inet_timewait_sock, tw_bound_dev_if));
  
  	arg.tos = ip_hdr(skb)->tos;
++<<<<<<< HEAD
 +	ip_send_unicast_reply(*this_cpu_ptr(net->ipv4_tcp_sk),
++=======
+ 	arg.uid = sock_net_uid(net, sk && sk_fullsock(sk) ? sk : NULL);
+ 	local_bh_disable();
+ 	ctl_sk = *this_cpu_ptr(net->ipv4.tcp_sk);
+ 	if (sk)
+ 		ctl_sk->sk_mark = (sk->sk_state == TCP_TIME_WAIT) ?
+ 				   inet_twsk(sk)->tw_mark : sk->sk_mark;
+ 	ip_send_unicast_reply(ctl_sk,
++>>>>>>> 00483690552c (tcp: Add mark for TIMEWAIT sockets)
  			      skb, &TCP_SKB_CB(skb)->header.h4.opt,
  			      ip_hdr(skb)->saddr, ip_hdr(skb)->daddr,
  			      &arg, arg.iov[0].iov_len);
  
++<<<<<<< HEAD
 +	TCP_INC_STATS_BH(net, TCP_MIB_OUTSEGS);
 +	TCP_INC_STATS_BH(net, TCP_MIB_OUTRSTS);
++=======
+ 	ctl_sk->sk_mark = 0;
+ 	__TCP_INC_STATS(net, TCP_MIB_OUTSEGS);
+ 	__TCP_INC_STATS(net, TCP_MIB_OUTRSTS);
+ 	local_bh_enable();
++>>>>>>> 00483690552c (tcp: Add mark for TIMEWAIT sockets)
  
  #ifdef CONFIG_TCP_MD5SIG
 -out:
 -	rcu_read_unlock();
 +release_sk1:
 +	if (sk1) {
 +		rcu_read_unlock();
 +		sock_put(sk1);
 +	}
  #endif
  }
  
@@@ -722,8 -763,9 +740,12 @@@ static void tcp_v4_send_ack(struct sk_b
  #endif
  			];
  	} rep;
 -	struct net *net = sock_net(sk);
  	struct ip_reply_arg arg;
++<<<<<<< HEAD
 +	struct net *net = dev_net(skb_dst(skb)->dev);
++=======
+ 	struct sock *ctl_sk;
++>>>>>>> 00483690552c (tcp: Add mark for TIMEWAIT sockets)
  
  	memset(&rep.th, 0, sizeof(struct tcphdr));
  	memset(&arg, 0, sizeof(arg));
@@@ -772,12 -814,20 +794,28 @@@
  	if (oif)
  		arg.bound_dev_if = oif;
  	arg.tos = tos;
++<<<<<<< HEAD
 +	ip_send_unicast_reply(*this_cpu_ptr(net->ipv4_tcp_sk),
++=======
+ 	arg.uid = sock_net_uid(net, sk_fullsock(sk) ? sk : NULL);
+ 	local_bh_disable();
+ 	ctl_sk = *this_cpu_ptr(net->ipv4.tcp_sk);
+ 	if (sk)
+ 		ctl_sk->sk_mark = (sk->sk_state == TCP_TIME_WAIT) ?
+ 				   inet_twsk(sk)->tw_mark : sk->sk_mark;
+ 	ip_send_unicast_reply(ctl_sk,
++>>>>>>> 00483690552c (tcp: Add mark for TIMEWAIT sockets)
  			      skb, &TCP_SKB_CB(skb)->header.h4.opt,
  			      ip_hdr(skb)->saddr, ip_hdr(skb)->daddr,
  			      &arg, arg.iov[0].iov_len);
  
++<<<<<<< HEAD
 +	TCP_INC_STATS_BH(net, TCP_MIB_OUTSEGS);
++=======
+ 	ctl_sk->sk_mark = 0;
+ 	__TCP_INC_STATS(net, TCP_MIB_OUTSEGS);
+ 	local_bh_enable();
++>>>>>>> 00483690552c (tcp: Add mark for TIMEWAIT sockets)
  }
  
  static void tcp_v4_timewait_ack(struct sock *sk, struct sk_buff *skb)
diff --cc net/ipv6/tcp_ipv6.c
index 90cee4fdd27b,7d47c2b550a9..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -861,12 -864,21 +862,21 @@@ static void tcp_v6_send_response(struc
  
  	fl6.flowi6_proto = IPPROTO_TCP;
  	if (rt6_need_strict(&fl6.daddr) && !oif)
 -		fl6.flowi6_oif = tcp_v6_iif(skb);
 -	else {
 -		if (!oif && netif_index_is_l3_master(net, skb->skb_iif))
 -			oif = skb->skb_iif;
 -
 +		fl6.flowi6_oif = inet6_iif(skb);
 +	else
  		fl6.flowi6_oif = oif;
++<<<<<<< HEAD
 +	fl6.flowi6_mark = IP6_REPLY_MARK(net, skb->mark);
++=======
+ 	}
+ 
+ 	if (sk)
+ 		mark = (sk->sk_state == TCP_TIME_WAIT) ?
+ 			inet_twsk(sk)->tw_mark : sk->sk_mark;
+ 	fl6.flowi6_mark = IP6_REPLY_MARK(net, skb->mark) ?: mark;
++>>>>>>> 00483690552c (tcp: Add mark for TIMEWAIT sockets)
  	fl6.fl6_dport = t1->dest;
  	fl6.fl6_sport = t1->source;
 -	fl6.flowi6_uid = sock_net_uid(net, sk && sk_fullsock(sk) ? sk : NULL);
  	security_skb_classify_flow(skb, flowi6_to_flowi(&fl6));
  
  	/* Pass a socket to ip6_dst_lookup either it is for RST
diff --git a/include/net/inet_timewait_sock.h b/include/net/inet_timewait_sock.h
index 61474ea02152..326d3a218a2d 100644
--- a/include/net/inet_timewait_sock.h
+++ b/include/net/inet_timewait_sock.h
@@ -123,6 +123,7 @@ struct inet_timewait_sock {
 #define tw_num			__tw_common.skc_num
 
 	int			tw_timeout;
+	__u32			tw_mark;
 	volatile unsigned char	tw_substate;
 	unsigned char		tw_rcv_wscale;
 
* Unmerged path net/ipv4/ip_output.c
* Unmerged path net/ipv4/tcp_ipv4.c
diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
index 83a25e106ff7..582c88d0d6a2 100644
--- a/net/ipv4/tcp_minisocks.c
+++ b/net/ipv4/tcp_minisocks.c
@@ -296,6 +296,7 @@ void tcp_time_wait(struct sock *sk, int state, int timeo)
 		struct inet_sock *inet = inet_sk(sk);
 
 		tw->tw_transparent	= inet->transparent;
+		tw->tw_mark		= sk->sk_mark;
 		tw->tw_rcv_wscale	= tp->rx_opt.rcv_wscale;
 		tcptw->tw_rcv_nxt	= tp->rcv_nxt;
 		tcptw->tw_snd_nxt	= tp->snd_nxt;
* Unmerged path net/ipv6/tcp_ipv6.c
