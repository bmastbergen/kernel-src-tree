dm: set QUEUE_FLAG_DAX accordingly in dm_table_set_restrictions()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Mike Snitzer <snitzer@redhat.com>
commit ad3793fc3945173f64d82d05d3ecde41f6c0435c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ad3793fc.failed

Rather than having DAX support be unique by setting it based on table
type in dm_setup_md_queue().

	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit ad3793fc3945173f64d82d05d3ecde41f6c0435c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-table.c
#	drivers/md/dm.c
diff --cc drivers/md/dm-table.c
index d9f3215786ed,504e79bc3a55..000000000000
--- a/drivers/md/dm-table.c
+++ b/drivers/md/dm-table.c
@@@ -1607,15 -1816,17 +1607,22 @@@ void dm_table_set_restrictions(struct d
  	} else
  		queue_flag_set_unlocked(QUEUE_FLAG_DISCARD, q);
  
 -	if (dm_table_supports_flush(t, (1UL << QUEUE_FLAG_WC))) {
 -		wc = true;
 -		if (dm_table_supports_flush(t, (1UL << QUEUE_FLAG_FUA)))
 -			fua = true;
 +	if (dm_table_supports_flush(t, REQ_FLUSH)) {
 +		flush |= REQ_FLUSH;
 +		if (dm_table_supports_flush(t, REQ_FUA))
 +			flush |= REQ_FUA;
  	}
 -	blk_queue_write_cache(q, wc, fua);
 +	blk_queue_flush(q, flush);
  
++<<<<<<< HEAD
 +	if (!dm_table_discard_zeroes_data(t))
 +		q->limits.discard_zeroes_data = 0;
++=======
+ 	if (dm_table_supports_dax(t))
+ 		queue_flag_set_unlocked(QUEUE_FLAG_DAX, q);
+ 	if (dm_table_supports_dax_write_cache(t))
+ 		dax_write_cache(t->md->dax_dev, true);
++>>>>>>> ad3793fc3945 (dm: set QUEUE_FLAG_DAX accordingly in dm_table_set_restrictions())
  
  	/* Ensure that all underlying devices are non-rotational. */
  	if (dm_table_all_devices_attribute(t, device_is_nonrot))
diff --cc drivers/md/dm.c
index 14d7215727e9,308d178fff73..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -2135,10 -2034,6 +2135,13 @@@ int dm_setup_md_queue(struct mapped_dev
  	case DM_TYPE_DAX_BIO_BASED:
  		dm_init_normal_md_queue(md);
  		blk_queue_make_request(md->queue, dm_make_request);
++<<<<<<< HEAD
 +		blk_queue_merge_bvec(md->queue, dm_merge_bvec);
 +
 +		if (type == DM_TYPE_DAX_BIO_BASED)
 +			queue_flag_set_unlocked(QUEUE_FLAG_DAX, md->queue);
++=======
++>>>>>>> ad3793fc3945 (dm: set QUEUE_FLAG_DAX accordingly in dm_table_set_restrictions())
  		break;
  	case DM_TYPE_NONE:
  		WARN_ON_ONCE(true);
* Unmerged path drivers/md/dm-table.c
* Unmerged path drivers/md/dm.c
