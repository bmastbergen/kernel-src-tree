ipmi: Make the IPMI proc interface configurable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Corey Minyard <cminyard@mvista.com>
commit 55f91cb6f1dfc873359674f35a8ffb1e78429d22
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/55f91cb6.failed

So we can remove it later.

	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit 55f91cb6f1dfc873359674f35a8ffb1e78429d22)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_msghandler.c
#	drivers/char/ipmi/ipmi_si_intf.c
diff --cc drivers/char/ipmi/ipmi_msghandler.c
index 23529b23ec40,fd3ac6b50412..000000000000
--- a/drivers/char/ipmi/ipmi_msghandler.c
+++ b/drivers/char/ipmi/ipmi_msghandler.c
@@@ -432,10 -446,10 +432,10 @@@ struct ipmi_smi 
  	 * an umpreemptible region to use this.  You must fetch the
  	 * value into a local variable and make sure it is not NULL.
  	 */
 -	const struct ipmi_smi_handlers *handlers;
 +	struct ipmi_smi_handlers *handlers;
  	void                     *send_info;
  
- #ifdef CONFIG_PROC_FS
+ #ifdef CONFIG_IPMI_PROC_INTERFACE
  	/* A list of proc entries for this interface. */
  	struct mutex           proc_entry_lock;
  	struct ipmi_proc_entry *proc_entries;
@@@ -522,13 -539,12 +525,9 @@@
  	int curr_channel;
  
  	/* Channel information */
 -	struct ipmi_channel_set *channel_list;
 -	unsigned int curr_working_cset; /* First index into the following. */
 -	struct ipmi_channel_set wchannels[2];
 +	struct ipmi_channel channels[IPMI_MAX_CHANNELS];
  	struct ipmi_my_addrinfo addrinfo[IPMI_MAX_CHANNELS];
 -	bool channels_ready;
  
- 	/* Proc FS stuff. */
- 	struct proc_dir_entry *proc_dir;
- 	char                  proc_dir_name[10];
- 
  	atomic_t stats[IPMI_NUM_STATS];
  
  	/*
@@@ -2281,7 -2355,14 +2280,18 @@@ out
  	return rv;
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_PROC_FS
++=======
+ static int bmc_get_device_id(ipmi_smi_t intf, struct bmc_device *bmc,
+ 			     struct ipmi_device_id *id,
+ 			     bool *guid_set, guid_t *guid)
+ {
+ 	return __bmc_get_device_id(intf, bmc, id, guid_set, guid, -1);
+ }
+ 
+ #ifdef CONFIG_IPMI_PROC_INTERFACE
++>>>>>>> 55f91cb6f1df (ipmi: Make the IPMI proc interface configurable)
  static int smi_ipmb_proc_show(struct seq_file *m, void *v)
  {
  	ipmi_smi_t intf = m->private;
@@@ -3291,31 -3474,9 +3297,36 @@@ int ipmi_register_smi(struct ipmi_smi_h
  	if (rv)
  		goto out;
  
++<<<<<<< HEAD
 +	if (ipmi_version_major(&id) > 1
 +			|| (ipmi_version_major(&id) == 1
 +			    && ipmi_version_minor(&id) >= 5)) {
 +		/*
 +		 * Start scanning the channels to see what is
 +		 * available.
 +		 */
 +		intf->null_user_handler = channel_handler;
 +		intf->curr_channel = 0;
 +		rv = send_channel_info_cmd(intf, 0);
 +		if (rv)
 +			goto out;
 +
 +		/* Wait for the channel info to be read. */
 +		wait_event(intf->waitq,
 +			   intf->curr_channel >= IPMI_MAX_CHANNELS);
 +		intf->null_user_handler = NULL;
 +	} else {
 +		/* Assume a single IPMB channel at zero. */
 +		intf->channels[0].medium = IPMI_CHANNEL_MEDIUM_IPMB;
 +		intf->channels[0].protocol = IPMI_CHANNEL_PROTOCOL_IPMB;
 +		intf->curr_channel = IPMI_MAX_CHANNELS;
 +	}
 +
++=======
+ #ifdef CONFIG_IPMI_PROC_INTERFACE
++>>>>>>> 55f91cb6f1df (ipmi: Make the IPMI proc interface configurable)
  	rv = add_proc_entries(intf, i);
+ #endif
  
   out:
  	if (rv) {
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 72982bfaeaf1,efc8ee9b5071..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -3252,7 -1699,94 +3253,8 @@@ static const struct file_operations smi
  	.llseek		= seq_lseek,
  	.release	= single_release,
  };
+ #endif
  
 -#define IPMI_SI_ATTR(name) \
 -static ssize_t ipmi_##name##_show(struct device *dev,			\
 -				  struct device_attribute *attr,	\
 -				  char *buf)				\
 -{									\
 -	struct smi_info *smi_info = dev_get_drvdata(dev);		\
 -									\
 -	return snprintf(buf, 10, "%u\n", smi_get_stat(smi_info, name));	\
 -}									\
 -static DEVICE_ATTR(name, S_IRUGO, ipmi_##name##_show, NULL)
 -
 -static ssize_t ipmi_type_show(struct device *dev,
 -			      struct device_attribute *attr,
 -			      char *buf)
 -{
 -	struct smi_info *smi_info = dev_get_drvdata(dev);
 -
 -	return snprintf(buf, 10, "%s\n", si_to_str[smi_info->io.si_type]);
 -}
 -static DEVICE_ATTR(type, S_IRUGO, ipmi_type_show, NULL);
 -
 -static ssize_t ipmi_interrupts_enabled_show(struct device *dev,
 -					    struct device_attribute *attr,
 -					    char *buf)
 -{
 -	struct smi_info *smi_info = dev_get_drvdata(dev);
 -	int enabled = smi_info->io.irq && !smi_info->interrupt_disabled;
 -
 -	return snprintf(buf, 10, "%d\n", enabled);
 -}
 -static DEVICE_ATTR(interrupts_enabled, S_IRUGO,
 -		   ipmi_interrupts_enabled_show, NULL);
 -
 -IPMI_SI_ATTR(short_timeouts);
 -IPMI_SI_ATTR(long_timeouts);
 -IPMI_SI_ATTR(idles);
 -IPMI_SI_ATTR(interrupts);
 -IPMI_SI_ATTR(attentions);
 -IPMI_SI_ATTR(flag_fetches);
 -IPMI_SI_ATTR(hosed_count);
 -IPMI_SI_ATTR(complete_transactions);
 -IPMI_SI_ATTR(events);
 -IPMI_SI_ATTR(watchdog_pretimeouts);
 -IPMI_SI_ATTR(incoming_messages);
 -
 -static ssize_t ipmi_params_show(struct device *dev,
 -				struct device_attribute *attr,
 -				char *buf)
 -{
 -	struct smi_info *smi_info = dev_get_drvdata(dev);
 -
 -	return snprintf(buf, 200,
 -			"%s,%s,0x%lx,rsp=%d,rsi=%d,rsh=%d,irq=%d,ipmb=%d\n",
 -			si_to_str[smi_info->io.si_type],
 -			addr_space_to_str[smi_info->io.addr_type],
 -			smi_info->io.addr_data,
 -			smi_info->io.regspacing,
 -			smi_info->io.regsize,
 -			smi_info->io.regshift,
 -			smi_info->io.irq,
 -			smi_info->io.slave_addr);
 -}
 -static DEVICE_ATTR(params, S_IRUGO, ipmi_params_show, NULL);
 -
 -static struct attribute *ipmi_si_dev_attrs[] = {
 -	&dev_attr_type.attr,
 -	&dev_attr_interrupts_enabled.attr,
 -	&dev_attr_short_timeouts.attr,
 -	&dev_attr_long_timeouts.attr,
 -	&dev_attr_idles.attr,
 -	&dev_attr_interrupts.attr,
 -	&dev_attr_attentions.attr,
 -	&dev_attr_flag_fetches.attr,
 -	&dev_attr_hosed_count.attr,
 -	&dev_attr_complete_transactions.attr,
 -	&dev_attr_events.attr,
 -	&dev_attr_watchdog_pretimeouts.attr,
 -	&dev_attr_incoming_messages.attr,
 -	&dev_attr_params.attr,
 -	NULL
 -};
 -
 -static const struct attribute_group ipmi_si_dev_attr_group = {
 -	.attrs		= ipmi_si_dev_attrs,
 -};
 -
  /*
   * oem_data_avail_to_receive_msg_avail
   * @info - smi_info structure with msg_flags set
@@@ -3616,22 -2184,16 +3618,26 @@@ static int try_smi_init(struct smi_inf
  
  	rv = ipmi_register_smi(&handlers,
  			       new_smi,
 -			       new_smi->io.dev,
 -			       new_smi->io.slave_addr);
 +			       &new_smi->device_id,
 +			       new_smi->dev,
 +			       "bmc",
 +			       new_smi->slave_addr);
  	if (rv) {
 -		dev_err(new_smi->io.dev,
 -			"Unable to register device: error %d\n",
 +		dev_err(new_smi->dev, "Unable to register device: error %d\n",
  			rv);
 -		goto out_err_remove_attrs;
 +		goto out_err_stop_timer;
  	}
  
++<<<<<<< HEAD
 +	/* RHEL7-only - Init ipmi_shadow_smi_handlers
 +	 */
 +	shadow_handlers = ipmi_get_shadow_smi_handlers();
 +	shadow_handlers->set_need_watch = set_need_watch;
 +	shadow_handlers->flush_messages = flush_messages;
 +
++=======
+ #ifdef CONFIG_IPMI_PROC_INTERFACE
++>>>>>>> 55f91cb6f1df (ipmi: Make the IPMI proc interface configurable)
  	rv = ipmi_smi_add_proc_entry(new_smi->intf, "type",
  				     &smi_type_proc_ops,
  				     new_smi);
@@@ -3652,9 -2216,11 +3658,10 @@@
  				     &smi_params_proc_ops,
  				     new_smi);
  	if (rv) {
 -		dev_err(new_smi->io.dev,
 -			"Unable to create proc entry: %d\n", rv);
 +		dev_err(new_smi->dev, "Unable to create proc entry: %d\n", rv);
  		goto out_err_stop_timer;
  	}
+ #endif
  
  	/* Don't increment till we know we have succeeded. */
  	smi_num++;
diff --git a/drivers/char/ipmi/Kconfig b/drivers/char/ipmi/Kconfig
index 4ee9a90bdf15..19e106e9a626 100644
--- a/drivers/char/ipmi/Kconfig
+++ b/drivers/char/ipmi/Kconfig
@@ -22,6 +22,14 @@ config IPMI_DMI_DECODE
 
 if IPMI_HANDLER
 
+config IPMI_PROC_INTERFACE
+       bool 'Provide an interface for IPMI stats in /proc (deprecated)'
+       depends on PROC_FS
+       default y
+       help
+         Do not use this any more, use sysfs for this info.  It will be
+	 removed in future kernel versions.
+
 config IPMI_PANIC_EVENT
        bool 'Generate a panic event to all BMCs on a panic'
        help
* Unmerged path drivers/char/ipmi/ipmi_msghandler.c
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
diff --git a/drivers/char/ipmi/ipmi_ssif.c b/drivers/char/ipmi/ipmi_ssif.c
index dbbf7ba6446f..3d741c52984c 100644
--- a/drivers/char/ipmi/ipmi_ssif.c
+++ b/drivers/char/ipmi/ipmi_ssif.c
@@ -1348,6 +1348,7 @@ static int ssif_detect(struct i2c_client *client, struct i2c_board_info *info)
 	return rv;
 }
 
+#ifdef CONFIG_IPMI_PROC_INTERFACE
 static int smi_type_proc_show(struct seq_file *m, void *v)
 {
 	seq_puts(m, "ssif\n");
@@ -1411,6 +1412,7 @@ static const struct file_operations smi_stats_proc_ops = {
 	.llseek		= seq_lseek,
 	.release	= single_release,
 };
+#endif
 
 static int strcmp_nospace(char *s1, char *s2)
 {
@@ -1763,6 +1765,7 @@ static int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		goto out_remove_attr;
 	}
 
+#ifdef CONFIG_IPMI_PROC_INTERFACE
 	rv = ipmi_smi_add_proc_entry(ssif_info->intf, "type",
 				     &smi_type_proc_ops,
 				     ssif_info);
@@ -1778,6 +1781,7 @@ static int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		pr_err(PFX "Unable to create proc entry: %d\n", rv);
 		goto out_err_unreg;
 	}
+#endif
 
  out:
 	if (rv) {
@@ -1796,8 +1800,10 @@ static int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	kfree(resp);
 	return rv;
 
+#ifdef CONFIG_IPMI_PROC_INTERFACE
 out_err_unreg:
 	ipmi_unregister_smi(ssif_info->intf);
+#endif
 
 out_remove_attr:
 	device_remove_group(&ssif_info->client->dev, &ipmi_ssif_dev_attr_group);
diff --git a/include/linux/ipmi_smi.h b/include/linux/ipmi_smi.h
index fbfa05156b04..adcc0a5d022d 100644
--- a/include/linux/ipmi_smi.h
+++ b/include/linux/ipmi_smi.h
@@ -263,11 +263,13 @@ static inline void ipmi_free_smi_msg(struct ipmi_smi_msg *msg)
 	msg->done(msg);
 }
 
+#ifdef CONFIG_IPMI_PROC_INTERFACE
 /* Allow the lower layer to add things to the proc filesystem
    directory for this interface.  Note that the entry will
    automatically be dstroyed when the interface is destroyed. */
 int ipmi_smi_add_proc_entry(ipmi_smi_t smi, char *name,
 			    const struct file_operations *proc_ops,
 			    void *data);
+#endif
 
 #endif /* __LINUX_IPMI_SMI_H */
