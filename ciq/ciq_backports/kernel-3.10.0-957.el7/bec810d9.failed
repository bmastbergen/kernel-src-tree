netfilter: ipset: Improve skbinfo get/init helpers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit bec810d973003b30bc477146904af6bd93fd2df8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/bec810d9.failed

Use struct ip_set_skbinfo in struct ip_set_ext instead of open
coded fields and assign structure members in get/init helpers
instead of copying members one by one. Explicitly note that
struct ip_set_skbinfo must be padded to prevent non-aligned
access in the extension blob.

Ported from a patch proposed by Sergey Popovich <popovich_sergei@mail.ua>.

	Suggested-by: Sergey Popovich <popovich_sergei@mail.ua>
	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit bec810d973003b30bc477146904af6bd93fd2df8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/ipset/ip_set.h
#	net/netfilter/ipset/ip_set_core.c
diff --cc include/linux/netfilter/ipset/ip_set.h
index 3e9c90cf5227,780262124632..000000000000
--- a/include/linux/netfilter/ipset/ip_set.h
+++ b/include/linux/netfilter/ipset/ip_set.h
@@@ -68,9 -77,48 +68,52 @@@ enum ip_set_ext_id 
  	IPSET_EXT_ID_MAX,
  };
  
++<<<<<<< HEAD
 +struct ip_set_ext {
 +	u64 packets;
 +	u64 bytes;
++=======
+ /* Extension type */
+ struct ip_set_ext_type {
+ 	/* Destroy extension private data (can be NULL) */
+ 	void (*destroy)(void *ext);
+ 	enum ip_set_extension type;
+ 	enum ipset_cadt_flags flag;
+ 	/* Size and minimal alignment */
+ 	u8 len;
+ 	u8 align;
+ };
+ 
+ extern const struct ip_set_ext_type ip_set_extensions[];
+ 
+ struct ip_set_counter {
+ 	atomic64_t bytes;
+ 	atomic64_t packets;
+ };
+ 
+ struct ip_set_comment_rcu {
+ 	struct rcu_head rcu;
+ 	char str[0];
+ };
+ 
+ struct ip_set_comment {
+ 	struct ip_set_comment_rcu __rcu *c;
+ };
+ 
+ struct ip_set_skbinfo {
+ 	u32 skbmark;
+ 	u32 skbmarkmask;
+ 	u32 skbprio;
+ 	u16 skbqueue;
+ 	u16 __pad;
+ };
+ 
+ struct ip_set_ext {
+ 	struct ip_set_skbinfo skbinfo;
+ 	u64 packets;
+ 	u64 bytes;
+ 	char *comment;
++>>>>>>> bec810d97300 (netfilter: ipset: Improve skbinfo get/init helpers)
  	u32 timeout;
  };
  
@@@ -256,6 -353,48 +299,51 @@@ ip_set_init_counter(struct ip_set_count
  		atomic64_set(&(counter)->packets, (long long)(ext->packets));
  }
  
++<<<<<<< HEAD
++=======
+ static inline void
+ ip_set_get_skbinfo(struct ip_set_skbinfo *skbinfo,
+ 		   const struct ip_set_ext *ext,
+ 		   struct ip_set_ext *mext, u32 flags)
+ {
+ 	mext->skbinfo = *skbinfo;
+ }
+ 
+ static inline bool
+ ip_set_put_skbinfo(struct sk_buff *skb, const struct ip_set_skbinfo *skbinfo)
+ {
+ 	/* Send nonzero parameters only */
+ 	return ((skbinfo->skbmark || skbinfo->skbmarkmask) &&
+ 		nla_put_net64(skb, IPSET_ATTR_SKBMARK,
+ 			      cpu_to_be64((u64)skbinfo->skbmark << 32 |
+ 					  skbinfo->skbmarkmask),
+ 			      IPSET_ATTR_PAD)) ||
+ 	       (skbinfo->skbprio &&
+ 		nla_put_net32(skb, IPSET_ATTR_SKBPRIO,
+ 			      cpu_to_be32(skbinfo->skbprio))) ||
+ 	       (skbinfo->skbqueue &&
+ 		nla_put_net16(skb, IPSET_ATTR_SKBQUEUE,
+ 			     cpu_to_be16(skbinfo->skbqueue)));
+ }
+ 
+ static inline void
+ ip_set_init_skbinfo(struct ip_set_skbinfo *skbinfo,
+ 		    const struct ip_set_ext *ext)
+ {
+ 	*skbinfo = ext->skbinfo;
+ }
+ 
+ /* Netlink CB args */
+ enum {
+ 	IPSET_CB_NET = 0,	/* net namespace */
+ 	IPSET_CB_DUMP,		/* dump single set/all sets */
+ 	IPSET_CB_INDEX,		/* set index */
+ 	IPSET_CB_PRIVATE,	/* set private data */
+ 	IPSET_CB_ARG0,		/* type specific */
+ 	IPSET_CB_ARG1,
+ };
+ 
++>>>>>>> bec810d97300 (netfilter: ipset: Improve skbinfo get/init helpers)
  /* register and unregister set references */
  extern ip_set_id_t ip_set_get_byname(struct net *net,
  				     const char *name, struct ip_set **set);
diff --cc net/netfilter/ipset/ip_set_core.c
index 1b9673fde81c,bfacccff7196..000000000000
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@@ -343,6 -417,30 +343,33 @@@ ip_set_get_extensions(struct ip_set *se
  			ext->packets = be64_to_cpu(nla_get_be64(
  						   tb[IPSET_ATTR_PACKETS]));
  	}
++<<<<<<< HEAD
++=======
+ 	if (tb[IPSET_ATTR_COMMENT]) {
+ 		if (!SET_WITH_COMMENT(set))
+ 			return -IPSET_ERR_COMMENT;
+ 		ext->comment = ip_set_comment_uget(tb[IPSET_ATTR_COMMENT]);
+ 	}
+ 	if (tb[IPSET_ATTR_SKBMARK]) {
+ 		if (!SET_WITH_SKBINFO(set))
+ 			return -IPSET_ERR_SKBINFO;
+ 		fullmark = be64_to_cpu(nla_get_be64(tb[IPSET_ATTR_SKBMARK]));
+ 		ext->skbinfo.skbmark = fullmark >> 32;
+ 		ext->skbinfo.skbmarkmask = fullmark & 0xffffffff;
+ 	}
+ 	if (tb[IPSET_ATTR_SKBPRIO]) {
+ 		if (!SET_WITH_SKBINFO(set))
+ 			return -IPSET_ERR_SKBINFO;
+ 		ext->skbinfo.skbprio =
+ 			be32_to_cpu(nla_get_be32(tb[IPSET_ATTR_SKBPRIO]));
+ 	}
+ 	if (tb[IPSET_ATTR_SKBQUEUE]) {
+ 		if (!SET_WITH_SKBINFO(set))
+ 			return -IPSET_ERR_SKBINFO;
+ 		ext->skbinfo.skbqueue =
+ 			be16_to_cpu(nla_get_be16(tb[IPSET_ATTR_SKBQUEUE]));
+ 	}
++>>>>>>> bec810d97300 (netfilter: ipset: Improve skbinfo get/init helpers)
  	return 0;
  }
  EXPORT_SYMBOL_GPL(ip_set_get_extensions);
* Unmerged path include/linux/netfilter/ipset/ip_set.h
* Unmerged path net/netfilter/ipset/ip_set_core.c
diff --git a/net/netfilter/xt_set.c b/net/netfilter/xt_set.c
index 6cc2d6757ad8..6c574aaf4cda 100644
--- a/net/netfilter/xt_set.c
+++ b/net/netfilter/xt_set.c
@@ -419,6 +419,8 @@ set_target_v2(struct sk_buff *skb, const struct xt_action_param *par)
 
 /* Revision 3 target */
 
+#define MOPT(opt, member)	((opt).ext.skbinfo.member)
+
 static unsigned int
 set_target_v3(struct sk_buff *skb, const struct xt_action_param *par)
 {
@@ -449,14 +451,14 @@ set_target_v3(struct sk_buff *skb, const struct xt_action_param *par)
 		if (!ret)
 			return XT_CONTINUE;
 		if (map_opt.cmdflags & IPSET_FLAG_MAP_SKBMARK)
-			skb->mark = (skb->mark & ~(map_opt.ext.skbmarkmask))
-				    ^ (map_opt.ext.skbmark);
+			skb->mark = (skb->mark & ~MOPT(map_opt,skbmarkmask))
+				    ^ MOPT(map_opt, skbmark);
 		if (map_opt.cmdflags & IPSET_FLAG_MAP_SKBPRIO)
-			skb->priority = map_opt.ext.skbprio;
+			skb->priority = MOPT(map_opt, skbprio);
 		if ((map_opt.cmdflags & IPSET_FLAG_MAP_SKBQUEUE) &&
 		    skb->dev &&
-		    skb->dev->real_num_tx_queues > map_opt.ext.skbqueue)
-			skb_set_queue_mapping(skb, map_opt.ext.skbqueue);
+		    skb->dev->real_num_tx_queues > MOPT(map_opt, skbqueue))
+			skb_set_queue_mapping(skb, MOPT(map_opt, skbqueue));
 	}
 	return XT_CONTINUE;
 }
