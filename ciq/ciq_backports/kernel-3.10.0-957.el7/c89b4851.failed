mmc: block: Make card_busy_detect() accumulate all response error bits

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] block: Make card_busy_detect() accumulate all response error bits (Gopal Tiwari) [1456570]
Rebuild_FUZZ: 96.30%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit c89b4851c67fb7354862850ae181de883269487d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c89b4851.failed

Make card_busy_detect() accumulate all response error bits. Later patches
will make use of this.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Acked-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Tested-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit c89b4851c67fb7354862850ae181de883269487d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/block.c
diff --cc drivers/mmc/core/block.c
index bf17147e2808,30fc012353ae..000000000000
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@@ -1613,21 -1737,814 +1631,127 @@@ static void mmc_blk_rw_rq_prep(struct m
  				break;
  			}
  		}
++<<<<<<< HEAD
  		brq->data.sg_len = i;
 -	}
 -
 -	mqrq->areq.mrq = &brq->mrq;
 -
 -	if (do_rel_wr_p)
 -		*do_rel_wr_p = do_rel_wr;
 -
 -	if (do_data_tag_p)
 -		*do_data_tag_p = do_data_tag;
 -}
 -
 -#define MMC_CQE_RETRIES 2
 -
 -static void mmc_blk_cqe_complete_rq(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_request *mrq = &mqrq->brq.mrq;
 -	struct request_queue *q = req->q;
 -	struct mmc_host *host = mq->card->host;
 -	unsigned long flags;
 -	bool put_card;
 -	int err;
 -
 -	mmc_cqe_post_req(host, mrq);
 -
 -	if (mrq->cmd && mrq->cmd->error)
 -		err = mrq->cmd->error;
 -	else if (mrq->data && mrq->data->error)
 -		err = mrq->data->error;
 -	else
 -		err = 0;
 -
 -	if (err) {
 -		if (mqrq->retries++ < MMC_CQE_RETRIES)
 -			blk_mq_requeue_request(req, true);
++=======
++		if (mmc_blk_reset(md, card->host, type))
++			mqrq->retries = MMC_NO_RETRIES;
+ 		else
 -			blk_mq_end_request(req, BLK_STS_IOERR);
 -	} else if (mrq->data) {
 -		if (blk_update_request(req, BLK_STS_OK, mrq->data->bytes_xfered))
 -			blk_mq_requeue_request(req, true);
++			mqrq->retries = MMC_MAX_RETRIES - 1;
++		break;
++	case MMC_BLK_RETRY:
++		/*
++		 * Do not accept bytes_xfered, but retry up to 5 times,
++		 * otherwise same as abort.
++		 */
++		brq->data.bytes_xfered = 0;
++		if (mqrq->retries < MMC_MAX_RETRIES)
++			break;
++		/* Fall through */
++	case MMC_BLK_ABORT:
++		/*
++		 * Do not accept bytes_xfered, but try to reset. If
++		 * reset succeeds, try once more, otherwise error out
++		 * the request.
++		 */
++		brq->data.bytes_xfered = 0;
++		if (mmc_blk_reset(md, card->host, type))
++			mqrq->retries = MMC_NO_RETRIES;
+ 		else
 -			__blk_mq_end_request(req, BLK_STS_OK);
 -	} else {
 -		blk_mq_end_request(req, BLK_STS_OK);
 -	}
 -
 -	spin_lock_irqsave(q->queue_lock, flags);
 -
 -	mq->in_flight[mmc_issue_type(mq, req)] -= 1;
 -
 -	put_card = (mmc_tot_in_flight(mq) == 0);
 -
 -	mmc_cqe_check_busy(mq);
 -
 -	spin_unlock_irqrestore(q->queue_lock, flags);
 -
 -	if (!mq->cqe_busy)
 -		blk_mq_run_hw_queues(q, true);
 -
 -	if (put_card)
 -		mmc_put_card(mq->card, &mq->ctx);
 -}
 -
 -void mmc_blk_cqe_recovery(struct mmc_queue *mq)
 -{
 -	struct mmc_card *card = mq->card;
 -	struct mmc_host *host = card->host;
 -	int err;
 -
 -	pr_debug("%s: CQE recovery start\n", mmc_hostname(host));
 -
 -	err = mmc_cqe_recovery(host);
 -	if (err)
 -		mmc_blk_reset(mq->blkdata, host, MMC_BLK_CQE_RECOVERY);
 -	else
 -		mmc_blk_reset_success(mq->blkdata, MMC_BLK_CQE_RECOVERY);
 -
 -	pr_debug("%s: CQE recovery done\n", mmc_hostname(host));
 -}
 -
 -static void mmc_blk_cqe_req_done(struct mmc_request *mrq)
 -{
 -	struct mmc_queue_req *mqrq = container_of(mrq, struct mmc_queue_req,
 -						  brq.mrq);
 -	struct request *req = mmc_queue_req_to_req(mqrq);
 -	struct request_queue *q = req->q;
 -	struct mmc_queue *mq = q->queuedata;
 -
 -	/*
 -	 * Block layer timeouts race with completions which means the normal
 -	 * completion path cannot be used during recovery.
 -	 */
 -	if (mq->in_recovery)
 -		mmc_blk_cqe_complete_rq(mq, req);
 -	else
 -		blk_mq_complete_request(req);
 -}
 -
 -static int mmc_blk_cqe_start_req(struct mmc_host *host, struct mmc_request *mrq)
 -{
 -	mrq->done		= mmc_blk_cqe_req_done;
 -	mrq->recovery_notifier	= mmc_cqe_recovery_notifier;
 -
 -	return mmc_cqe_start_req(host, mrq);
 -}
 -
 -static struct mmc_request *mmc_blk_cqe_prep_dcmd(struct mmc_queue_req *mqrq,
 -						 struct request *req)
 -{
 -	struct mmc_blk_request *brq = &mqrq->brq;
 -
 -	memset(brq, 0, sizeof(*brq));
 -
 -	brq->mrq.cmd = &brq->cmd;
 -	brq->mrq.tag = req->tag;
 -
 -	return &brq->mrq;
 -}
 -
 -static int mmc_blk_cqe_issue_flush(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_request *mrq = mmc_blk_cqe_prep_dcmd(mqrq, req);
 -
 -	mrq->cmd->opcode = MMC_SWITCH;
 -	mrq->cmd->arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
 -			(EXT_CSD_FLUSH_CACHE << 16) |
 -			(1 << 8) |
 -			EXT_CSD_CMD_SET_NORMAL;
 -	mrq->cmd->flags = MMC_CMD_AC | MMC_RSP_R1B;
 -
 -	return mmc_blk_cqe_start_req(mq->card->host, mrq);
 -}
 -
 -static int mmc_blk_cqe_issue_rw_rq(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -
 -	mmc_blk_data_prep(mq, mqrq, 0, NULL, NULL);
 -
 -	return mmc_blk_cqe_start_req(mq->card->host, &mqrq->brq.mrq);
 -}
 -
 -static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 -			       struct mmc_card *card,
 -			       int disable_multi,
 -			       struct mmc_queue *mq)
 -{
 -	u32 readcmd, writecmd;
 -	struct mmc_blk_request *brq = &mqrq->brq;
 -	struct request *req = mmc_queue_req_to_req(mqrq);
 -	struct mmc_blk_data *md = mq->blkdata;
 -	bool do_rel_wr, do_data_tag;
 -
 -	mmc_blk_data_prep(mq, mqrq, disable_multi, &do_rel_wr, &do_data_tag);
 -
 -	brq->mrq.cmd = &brq->cmd;
 -
 -	brq->cmd.arg = blk_rq_pos(req);
 -	if (!mmc_card_blockaddr(card))
 -		brq->cmd.arg <<= 9;
 -	brq->cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
 -
 -	if (brq->data.blocks > 1 || do_rel_wr) {
 -		/* SPI multiblock writes terminate using a special
 -		 * token, not a STOP_TRANSMISSION request.
 -		 */
 -		if (!mmc_host_is_spi(card->host) ||
 -		    rq_data_dir(req) == READ)
 -			brq->mrq.stop = &brq->stop;
 -		readcmd = MMC_READ_MULTIPLE_BLOCK;
 -		writecmd = MMC_WRITE_MULTIPLE_BLOCK;
 -	} else {
 -		brq->mrq.stop = NULL;
 -		readcmd = MMC_READ_SINGLE_BLOCK;
 -		writecmd = MMC_WRITE_BLOCK;
 -	}
 -	brq->cmd.opcode = rq_data_dir(req) == READ ? readcmd : writecmd;
 -
 -	/*
 -	 * Pre-defined multi-block transfers are preferable to
 -	 * open ended-ones (and necessary for reliable writes).
 -	 * However, it is not sufficient to just send CMD23,
 -	 * and avoid the final CMD12, as on an error condition
 -	 * CMD12 (stop) needs to be sent anyway. This, coupled
 -	 * with Auto-CMD23 enhancements provided by some
 -	 * hosts, means that the complexity of dealing
 -	 * with this is best left to the host. If CMD23 is
 -	 * supported by card and host, we'll fill sbc in and let
 -	 * the host deal with handling it correctly. This means
 -	 * that for hosts that don't expose MMC_CAP_CMD23, no
 -	 * change of behavior will be observed.
 -	 *
 -	 * N.B: Some MMC cards experience perf degradation.
 -	 * We'll avoid using CMD23-bounded multiblock writes for
 -	 * these, while retaining features like reliable writes.
 -	 */
 -	if ((md->flags & MMC_BLK_CMD23) && mmc_op_multi(brq->cmd.opcode) &&
 -	    (do_rel_wr || !(card->quirks & MMC_QUIRK_BLK_NO_CMD23) ||
 -	     do_data_tag)) {
 -		brq->sbc.opcode = MMC_SET_BLOCK_COUNT;
 -		brq->sbc.arg = brq->data.blocks |
 -			(do_rel_wr ? (1 << 31) : 0) |
 -			(do_data_tag ? (1 << 29) : 0);
 -		brq->sbc.flags = MMC_RSP_R1 | MMC_CMD_AC;
 -		brq->mrq.sbc = &brq->sbc;
 -	}
 -
 -	mqrq->areq.err_check = mmc_blk_err_check;
 -}
 -
 -#define MMC_MAX_RETRIES		5
 -#define MMC_NO_RETRIES		(MMC_MAX_RETRIES + 1)
 -
 -#define MMC_READ_SINGLE_RETRIES	2
 -
 -/* Single sector read during recovery */
 -static void mmc_blk_read_single(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_request *mrq = &mqrq->brq.mrq;
 -	struct mmc_card *card = mq->card;
 -	struct mmc_host *host = card->host;
 -	blk_status_t error = BLK_STS_OK;
 -	int retries = 0;
 -
 -	do {
 -		u32 status;
 -		int err;
 -
 -		mmc_blk_rw_rq_prep(mqrq, card, 1, mq);
 -
 -		mmc_wait_for_req(host, mrq);
 -
 -		err = mmc_send_status(card, &status);
 -		if (err)
 -			goto error_exit;
 -
 -		if (!mmc_host_is_spi(host) &&
 -		    R1_CURRENT_STATE(status) != R1_STATE_TRAN) {
 -			u32 stop_status = 0;
 -			bool gen_err = false;
 -
 -			err = send_stop(card,
 -					DIV_ROUND_UP(mrq->data->timeout_ns,
 -						     1000000),
 -					req, &gen_err, &stop_status);
 -			if (err)
 -				goto error_exit;
 -		}
 -
 -		if (mrq->cmd->error && retries++ < MMC_READ_SINGLE_RETRIES)
 -			continue;
 -
 -		retries = 0;
 -
 -		if (mrq->cmd->error ||
 -		    mrq->data->error ||
 -		    (!mmc_host_is_spi(host) &&
 -		     (mrq->cmd->resp[0] & CMD_ERRORS || status & CMD_ERRORS)))
 -			error = BLK_STS_IOERR;
 -		else
 -			error = BLK_STS_OK;
 -
 -	} while (blk_update_request(req, error, 512));
 -
 -	return;
 -
 -error_exit:
 -	mrq->data->bytes_xfered = 0;
 -	blk_update_request(req, BLK_STS_IOERR, 512);
 -	/* Let it try the remaining request again */
 -	if (mqrq->retries > MMC_MAX_RETRIES - 1)
 -		mqrq->retries = MMC_MAX_RETRIES - 1;
 -}
 -
 -static void mmc_blk_mq_rw_recovery(struct mmc_queue *mq, struct request *req)
 -{
 -	int type = rq_data_dir(req) == READ ? MMC_BLK_READ : MMC_BLK_WRITE;
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_blk_request *brq = &mqrq->brq;
 -	struct mmc_blk_data *md = mq->blkdata;
 -	struct mmc_card *card = mq->card;
 -	static enum mmc_blk_status status;
 -
 -	brq->retune_retry_done = mqrq->retries;
 -
 -	status = __mmc_blk_err_check(card, mqrq);
 -
 -	mmc_retune_release(card->host);
 -
 -	/*
 -	 * Requests are completed by mmc_blk_mq_complete_rq() which sets simple
 -	 * policy:
 -	 * 1. A request that has transferred at least some data is considered
 -	 * successful and will be requeued if there is remaining data to
 -	 * transfer.
 -	 * 2. Otherwise the number of retries is incremented and the request
 -	 * will be requeued if there are remaining retries.
 -	 * 3. Otherwise the request will be errored out.
 -	 * That means mmc_blk_mq_complete_rq() is controlled by bytes_xfered and
 -	 * mqrq->retries. So there are only 4 possible actions here:
 -	 *	1. do not accept the bytes_xfered value i.e. set it to zero
 -	 *	2. change mqrq->retries to determine the number of retries
 -	 *	3. try to reset the card
 -	 *	4. read one sector at a time
 -	 */
 -	switch (status) {
 -	case MMC_BLK_SUCCESS:
 -	case MMC_BLK_PARTIAL:
 -		/* Reset success, and accept bytes_xfered */
 -		mmc_blk_reset_success(md, type);
 -		break;
 -	case MMC_BLK_CMD_ERR:
 -		/*
 -		 * For SD cards, get bytes written, but do not accept
 -		 * bytes_xfered if that fails. For MMC cards accept
 -		 * bytes_xfered. Then try to reset. If reset fails then
 -		 * error out the remaining request, otherwise retry
 -		 * once (N.B mmc_blk_reset() will not succeed twice in a
 -		 * row).
 -		 */
 -		if (mmc_card_sd(card)) {
 -			u32 blocks;
 -			int err;
 -
 -			err = mmc_sd_num_wr_blocks(card, &blocks);
 -			if (err)
 -				brq->data.bytes_xfered = 0;
 -			else
 -				brq->data.bytes_xfered = blocks << 9;
 -		}
 -		if (mmc_blk_reset(md, card->host, type))
 -			mqrq->retries = MMC_NO_RETRIES;
 -		else
 -			mqrq->retries = MMC_MAX_RETRIES - 1;
 -		break;
 -	case MMC_BLK_RETRY:
 -		/*
 -		 * Do not accept bytes_xfered, but retry up to 5 times,
 -		 * otherwise same as abort.
 -		 */
 -		brq->data.bytes_xfered = 0;
 -		if (mqrq->retries < MMC_MAX_RETRIES)
 -			break;
 -		/* Fall through */
 -	case MMC_BLK_ABORT:
 -		/*
 -		 * Do not accept bytes_xfered, but try to reset. If
 -		 * reset succeeds, try once more, otherwise error out
 -		 * the request.
 -		 */
 -		brq->data.bytes_xfered = 0;
 -		if (mmc_blk_reset(md, card->host, type))
 -			mqrq->retries = MMC_NO_RETRIES;
 -		else
 -			mqrq->retries = MMC_MAX_RETRIES - 1;
 -		break;
 -	case MMC_BLK_DATA_ERR: {
 -		int err;
++			mqrq->retries = MMC_MAX_RETRIES - 1;
++		break;
++	case MMC_BLK_DATA_ERR: {
++		int err;
+ 
+ 		/*
+ 		 * Do not accept bytes_xfered, but try to reset. If
+ 		 * reset succeeds, try once more. If reset fails with
+ 		 * ENODEV which means the partition is wrong, then error
+ 		 * out the request. Otherwise attempt to read one sector
+ 		 * at a time.
+ 		 */
+ 		brq->data.bytes_xfered = 0;
+ 		err = mmc_blk_reset(md, card->host, type);
+ 		if (!err) {
+ 			mqrq->retries = MMC_MAX_RETRIES - 1;
+ 			break;
+ 		}
+ 		if (err == -ENODEV) {
+ 			mqrq->retries = MMC_NO_RETRIES;
+ 			break;
+ 		}
+ 		/* Fall through */
+ 	}
+ 	case MMC_BLK_ECC_ERR:
+ 		/*
+ 		 * Do not accept bytes_xfered. If reading more than one
+ 		 * sector, try reading one sector at a time.
+ 		 */
+ 		brq->data.bytes_xfered = 0;
+ 		/* FIXME: Missing single sector read for large sector size */
+ 		if (brq->data.blocks > 1 && !mmc_large_sector(card)) {
+ 			/* Redo read one sector at a time */
+ 			pr_warn("%s: retrying using single block read\n",
+ 				req->rq_disk->disk_name);
+ 			mmc_blk_read_single(mq, req);
+ 		} else {
+ 			mqrq->retries = MMC_NO_RETRIES;
+ 		}
+ 		break;
+ 	case MMC_BLK_NOMEDIUM:
+ 		/* Do not accept bytes_xfered. Error out the request */
+ 		brq->data.bytes_xfered = 0;
+ 		mqrq->retries = MMC_NO_RETRIES;
+ 		break;
+ 	default:
+ 		/* Do not accept bytes_xfered. Error out the request */
+ 		brq->data.bytes_xfered = 0;
+ 		mqrq->retries = MMC_NO_RETRIES;
+ 		pr_err("%s: Unhandled return value (%d)",
+ 		       req->rq_disk->disk_name, status);
+ 		break;
+ 	}
+ }
+ 
+ static inline bool mmc_blk_rq_error(struct mmc_blk_request *brq)
+ {
+ 	mmc_blk_eval_resp_error(brq);
+ 
+ 	return brq->sbc.error || brq->cmd.error || brq->stop.error ||
+ 	       brq->data.error || brq->cmd.resp[0] & CMD_ERRORS;
+ }
+ 
+ static int mmc_blk_card_busy(struct mmc_card *card, struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	bool gen_err = false;
 -	int err;
 -
 -	if (mmc_host_is_spi(card->host) || rq_data_dir(req) == READ)
 -		return 0;
 -
 -	err = card_busy_detect_err(card, MMC_BLK_TIMEOUT_MS, false, req,
 -				   &gen_err);
 -
 -	/* Copy the general error bit so it will be seen later on */
 -	if (gen_err) {
 -		mqrq->brq.stop.resp[0] |= R1_ERROR;
 -		err = err ? err : -EIO;
 -	}
 -
 -	return err;
 -}
 -
 -static inline void mmc_blk_rw_reset_success(struct mmc_queue *mq,
 -					    struct request *req)
 -{
 -	int type = rq_data_dir(req) == READ ? MMC_BLK_READ : MMC_BLK_WRITE;
 -
 -	mmc_blk_reset_success(mq->blkdata, type);
 -}
 -
 -static void mmc_blk_mq_complete_rq(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	unsigned int nr_bytes = mqrq->brq.data.bytes_xfered;
 -
 -	if (nr_bytes) {
 -		if (blk_update_request(req, BLK_STS_OK, nr_bytes))
 -			blk_mq_requeue_request(req, true);
 -		else
 -			__blk_mq_end_request(req, BLK_STS_OK);
 -	} else if (!blk_rq_bytes(req)) {
 -		__blk_mq_end_request(req, BLK_STS_IOERR);
 -	} else if (mqrq->retries++ < MMC_MAX_RETRIES) {
 -		blk_mq_requeue_request(req, true);
 -	} else {
 -		if (mmc_card_removed(mq->card))
 -			req->rq_flags |= RQF_QUIET;
 -		blk_mq_end_request(req, BLK_STS_IOERR);
 -	}
 -}
 -
 -static bool mmc_blk_urgent_bkops_needed(struct mmc_queue *mq,
 -					struct mmc_queue_req *mqrq)
 -{
 -	return mmc_card_mmc(mq->card) && !mmc_host_is_spi(mq->card->host) &&
 -	       (mqrq->brq.cmd.resp[0] & R1_EXCEPTION_EVENT ||
 -		mqrq->brq.stop.resp[0] & R1_EXCEPTION_EVENT);
 -}
 -
 -static void mmc_blk_urgent_bkops(struct mmc_queue *mq,
 -				 struct mmc_queue_req *mqrq)
 -{
 -	if (mmc_blk_urgent_bkops_needed(mq, mqrq))
 -		mmc_start_bkops(mq->card, true);
 -}
 -
 -void mmc_blk_mq_complete(struct request *req)
 -{
 -	struct mmc_queue *mq = req->q->queuedata;
 -
 -	if (mq->use_cqe)
 -		mmc_blk_cqe_complete_rq(mq, req);
 -	else
 -		mmc_blk_mq_complete_rq(mq, req);
 -}
 -
 -static void mmc_blk_mq_poll_completion(struct mmc_queue *mq,
 -				       struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_host *host = mq->card->host;
 -
 -	if (mmc_blk_rq_error(&mqrq->brq) ||
 -	    mmc_blk_card_busy(mq->card, req)) {
 -		mmc_blk_mq_rw_recovery(mq, req);
 -	} else {
 -		mmc_blk_rw_reset_success(mq, req);
 -		mmc_retune_release(host);
 -	}
 -
 -	mmc_blk_urgent_bkops(mq, mqrq);
 -}
 -
 -static void mmc_blk_mq_dec_in_flight(struct mmc_queue *mq, struct request *req)
 -{
 -	struct request_queue *q = req->q;
 -	unsigned long flags;
 -	bool put_card;
 -
 -	spin_lock_irqsave(q->queue_lock, flags);
 -
 -	mq->in_flight[mmc_issue_type(mq, req)] -= 1;
 -
 -	put_card = (mmc_tot_in_flight(mq) == 0);
 -
 -	spin_unlock_irqrestore(q->queue_lock, flags);
 -
 -	if (put_card)
 -		mmc_put_card(mq->card, &mq->ctx);
 -}
 -
 -static void mmc_blk_mq_post_req(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_request *mrq = &mqrq->brq.mrq;
 -	struct mmc_host *host = mq->card->host;
 -
 -	mmc_post_req(host, mrq, 0);
 -
 -	/*
 -	 * Block layer timeouts race with completions which means the normal
 -	 * completion path cannot be used during recovery.
 -	 */
 -	if (mq->in_recovery)
 -		mmc_blk_mq_complete_rq(mq, req);
 -	else
 -		blk_mq_complete_request(req);
 -
 -	mmc_blk_mq_dec_in_flight(mq, req);
 -}
 -
 -void mmc_blk_mq_recovery(struct mmc_queue *mq)
 -{
 -	struct request *req = mq->recovery_req;
 -	struct mmc_host *host = mq->card->host;
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -
 -	mq->recovery_req = NULL;
 -	mq->rw_wait = false;
 -
 -	if (mmc_blk_rq_error(&mqrq->brq)) {
 -		mmc_retune_hold_now(host);
 -		mmc_blk_mq_rw_recovery(mq, req);
 -	}
 -
 -	mmc_blk_urgent_bkops(mq, mqrq);
 -
 -	mmc_blk_mq_post_req(mq, req);
 -}
 -
 -static void mmc_blk_mq_complete_prev_req(struct mmc_queue *mq,
 -					 struct request **prev_req)
 -{
 -	if (mmc_host_done_complete(mq->card->host))
 -		return;
 -
 -	mutex_lock(&mq->complete_lock);
 -
 -	if (!mq->complete_req)
 -		goto out_unlock;
 -
 -	mmc_blk_mq_poll_completion(mq, mq->complete_req);
 -
 -	if (prev_req)
 -		*prev_req = mq->complete_req;
 -	else
 -		mmc_blk_mq_post_req(mq, mq->complete_req);
 -
 -	mq->complete_req = NULL;
 -
 -out_unlock:
 -	mutex_unlock(&mq->complete_lock);
 -}
 -
 -void mmc_blk_mq_complete_work(struct work_struct *work)
 -{
 -	struct mmc_queue *mq = container_of(work, struct mmc_queue,
 -					    complete_work);
 -
 -	mmc_blk_mq_complete_prev_req(mq, NULL);
 -}
 -
 -static void mmc_blk_mq_req_done(struct mmc_request *mrq)
 -{
 -	struct mmc_queue_req *mqrq = container_of(mrq, struct mmc_queue_req,
 -						  brq.mrq);
 -	struct request *req = mmc_queue_req_to_req(mqrq);
 -	struct request_queue *q = req->q;
 -	struct mmc_queue *mq = q->queuedata;
 -	struct mmc_host *host = mq->card->host;
 -	unsigned long flags;
 -
 -	if (!mmc_host_done_complete(host)) {
 -		bool waiting;
 -
 -		/*
 -		 * We cannot complete the request in this context, so record
 -		 * that there is a request to complete, and that a following
 -		 * request does not need to wait (although it does need to
 -		 * complete complete_req first).
 -		 */
 -		spin_lock_irqsave(q->queue_lock, flags);
 -		mq->complete_req = req;
 -		mq->rw_wait = false;
 -		waiting = mq->waiting;
 -		spin_unlock_irqrestore(q->queue_lock, flags);
 -
 -		/*
 -		 * If 'waiting' then the waiting task will complete this
 -		 * request, otherwise queue a work to do it. Note that
 -		 * complete_work may still race with the dispatch of a following
 -		 * request.
 -		 */
 -		if (waiting)
 -			wake_up(&mq->wait);
 -		else
 -			kblockd_schedule_work(&mq->complete_work);
 -
 -		return;
 -	}
 -
 -	/* Take the recovery path for errors or urgent background operations */
 -	if (mmc_blk_rq_error(&mqrq->brq) ||
 -	    mmc_blk_urgent_bkops_needed(mq, mqrq)) {
 -		spin_lock_irqsave(q->queue_lock, flags);
 -		mq->recovery_needed = true;
 -		mq->recovery_req = req;
 -		spin_unlock_irqrestore(q->queue_lock, flags);
 -		wake_up(&mq->wait);
 -		schedule_work(&mq->recovery_work);
 -		return;
 -	}
 -
 -	mmc_blk_rw_reset_success(mq, req);
 -
 -	mq->rw_wait = false;
 -	wake_up(&mq->wait);
 -
 -	mmc_blk_mq_post_req(mq, req);
 -}
 -
 -static bool mmc_blk_rw_wait_cond(struct mmc_queue *mq, int *err)
 -{
 -	struct request_queue *q = mq->queue;
 -	unsigned long flags;
 -	bool done;
 -
 -	/*
 -	 * Wait while there is another request in progress, but not if recovery
 -	 * is needed. Also indicate whether there is a request waiting to start.
 -	 */
 -	spin_lock_irqsave(q->queue_lock, flags);
 -	if (mq->recovery_needed) {
 -		*err = -EBUSY;
 -		done = true;
 -	} else {
 -		done = !mq->rw_wait;
 -	}
 -	mq->waiting = !done;
 -	spin_unlock_irqrestore(q->queue_lock, flags);
 -
 -	return done;
 -}
 -
 -static int mmc_blk_rw_wait(struct mmc_queue *mq, struct request **prev_req)
 -{
 -	int err = 0;
 -
 -	wait_event(mq->wait, mmc_blk_rw_wait_cond(mq, &err));
 -
 -	/* Always complete the previous request if there is one */
 -	mmc_blk_mq_complete_prev_req(mq, prev_req);
 -
 -	return err;
 -}
 -
 -static int mmc_blk_mq_issue_rw_rq(struct mmc_queue *mq,
 -				  struct request *req)
 -{
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_host *host = mq->card->host;
 -	struct request *prev_req = NULL;
 -	int err = 0;
 -
 -	mmc_blk_rw_rq_prep(mqrq, mq->card, 0, mq);
 -
 -	mqrq->brq.mrq.done = mmc_blk_mq_req_done;
 -
 -	mmc_pre_req(host, &mqrq->brq.mrq);
 -
 -	err = mmc_blk_rw_wait(mq, &prev_req);
 -	if (err)
 -		goto out_post_req;
 -
 -	mq->rw_wait = true;
 -
 -	err = mmc_start_request(host, &mqrq->brq.mrq);
 -
 -	if (prev_req)
 -		mmc_blk_mq_post_req(mq, prev_req);
 -
 -	if (err)
 -		mq->rw_wait = false;
 -
 -	/* Release re-tuning here where there is no synchronization required */
 -	if (err || mmc_host_done_complete(host))
 -		mmc_retune_release(host);
 -
 -out_post_req:
 -	if (err)
 -		mmc_post_req(host, &mqrq->brq.mrq, err);
 -
 -	return err;
 -}
 -
 -static int mmc_blk_wait_for_idle(struct mmc_queue *mq, struct mmc_host *host)
 -{
 -	if (mq->use_cqe)
 -		return host->cqe_ops->cqe_wait_for_idle(host);
 -
 -	return mmc_blk_rw_wait(mq, NULL);
 -}
++	int err;
+ 
 -enum mmc_issued mmc_blk_mq_issue_rq(struct mmc_queue *mq, struct request *req)
 -{
 -	struct mmc_blk_data *md = mq->blkdata;
 -	struct mmc_card *card = md->queue.card;
 -	struct mmc_host *host = card->host;
 -	int ret;
++	if (mmc_host_is_spi(card->host) || rq_data_dir(req) == READ)
++		return 0;
+ 
 -	ret = mmc_blk_part_switch(card, md->part_type);
 -	if (ret)
 -		return MMC_REQ_FAILED_TO_START;
++	err = card_busy_detect_err(card, MMC_BLK_TIMEOUT_MS, false, req,
++				   &gen_err);
+ 
 -	switch (mmc_issue_type(mq, req)) {
 -	case MMC_ISSUE_SYNC:
 -		ret = mmc_blk_wait_for_idle(mq, host);
 -		if (ret)
 -			return MMC_REQ_BUSY;
 -		switch (req_op(req)) {
 -		case REQ_OP_DRV_IN:
 -		case REQ_OP_DRV_OUT:
 -			mmc_blk_issue_drv_op(mq, req);
 -			break;
 -		case REQ_OP_DISCARD:
 -			mmc_blk_issue_discard_rq(mq, req);
 -			break;
 -		case REQ_OP_SECURE_ERASE:
 -			mmc_blk_issue_secdiscard_rq(mq, req);
 -			break;
 -		case REQ_OP_FLUSH:
 -			mmc_blk_issue_flush(mq, req);
 -			break;
 -		default:
 -			WARN_ON_ONCE(1);
 -			return MMC_REQ_FAILED_TO_START;
 -		}
 -		return MMC_REQ_FINISHED;
 -	case MMC_ISSUE_DCMD:
 -	case MMC_ISSUE_ASYNC:
 -		switch (req_op(req)) {
 -		case REQ_OP_FLUSH:
 -			ret = mmc_blk_cqe_issue_flush(mq, req);
 -			break;
 -		case REQ_OP_READ:
 -		case REQ_OP_WRITE:
 -			if (mq->use_cqe)
 -				ret = mmc_blk_cqe_issue_rw_rq(mq, req);
 -			else
 -				ret = mmc_blk_mq_issue_rw_rq(mq, req);
 -			break;
 -		default:
 -			WARN_ON_ONCE(1);
 -			ret = -EINVAL;
 -		}
 -		if (!ret)
 -			return MMC_REQ_STARTED;
 -		return ret == -EBUSY ? MMC_REQ_BUSY : MMC_REQ_FAILED_TO_START;
 -	default:
 -		WARN_ON_ONCE(1);
 -		return MMC_REQ_FAILED_TO_START;
++	/* Copy the general error bit so it will be seen later on */
++	if (gen_err) {
++		mqrq->brq.stop.resp[0] |= R1_ERROR;
++		err = err ? err : -EIO;
++>>>>>>> c89b4851c67f (mmc: block: Make card_busy_detect() accumulate all response error bits)
  	}
 +
 +	mqrq->mmc_active.mrq = &brq->mrq;
 +	mqrq->mmc_active.err_check = mmc_blk_err_check;
 +
 +	mmc_queue_bounce_pre(mqrq);
  }
  
 -static bool mmc_blk_rw_cmd_err(struct mmc_blk_data *md, struct mmc_card *card,
 -			       struct mmc_blk_request *brq, struct request *req,
 -			       bool old_req_pending)
 +static int mmc_blk_cmd_err(struct mmc_blk_data *md, struct mmc_card *card,
 +			   struct mmc_blk_request *brq, struct request *req,
 +			   int ret)
  {
 -	bool req_pending;
 +	struct mmc_queue_req *mq_rq;
 +	mq_rq = container_of(brq, struct mmc_queue_req, brq);
  
  	/*
  	 * If this is an SD card and we're writing, we can first
* Unmerged path drivers/mmc/core/block.c
