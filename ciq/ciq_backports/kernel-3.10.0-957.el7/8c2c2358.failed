net: tcp_memcontrol: properly detect ancestor socket pressure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] tcp_memcontrol: properly detect ancestor socket pressure (Davide Caratti) [1554191]
Rebuild_FUZZ: 95.73%
commit-author Johannes Weiner <hannes@cmpxchg.org>
commit 8c2c2358b236530bc2c79b4c2a447cbdbc3d96d7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8c2c2358.failed

When charging socket memory, the code currently checks only the local
page counter for excess to determine whether the memcg is under socket
pressure.  But even if the local counter is fine, one of the ancestors
could have breached its limit, which should also force this child to
enter socket pressure.  This currently doesn't happen.

Fix this by using page_counter_try_charge() first.  If that fails, it
means that either the local counter or one of the ancestors are in
excess of their limit, and the child should enter socket pressure.

Fixes: 3e32cb2e0a12 ("mm: memcontrol: lockless page counters")
	Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
	Acked-by: David S. Miller <davem@davemloft.net>
	Reviewed-by: Vladimir Davydov <vdavydov@virtuozzo.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8c2c2358b236530bc2c79b4c2a447cbdbc3d96d7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/sock.h
diff --cc include/net/sock.h
index 91144cd664b8,9ef3d7c984b4..000000000000
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@@ -1264,11 -1193,13 +1264,21 @@@ static inline void memcg_memory_allocat
  					      unsigned long amt,
  					      int *parent_status)
  {
++<<<<<<< HEAD
 +	page_counter_charge(prot->memory_allocated, amt);
 +
 +	if (page_counter_read(prot->memory_allocated) >
 +	    prot->memory_allocated->limit)
 +		*parent_status = OVER_LIMIT;
++=======
+ 	struct page_counter *counter;
+ 
+ 	if (page_counter_try_charge(&prot->memory_allocated, amt, &counter))
+ 		return;
+ 
+ 	page_counter_charge(&prot->memory_allocated, amt);
+ 	*parent_status = OVER_LIMIT;
++>>>>>>> 8c2c2358b236 (net: tcp_memcontrol: properly detect ancestor socket pressure)
  }
  
  static inline void memcg_memory_allocated_sub(struct cg_proto *prot,
* Unmerged path include/net/sock.h
