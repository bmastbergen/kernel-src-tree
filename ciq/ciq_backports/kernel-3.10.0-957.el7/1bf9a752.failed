net: aquantia: Fix hardware reset when SPI may rarely hangup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] aquantia: Fix hardware reset when SPI may rarely hangup (David Arcari) [1546765]
Rebuild_FUZZ: 95.65%
commit-author Igor Russkikh <igor.russkikh@aquantia.com>
commit 1bf9a7520fadaebfb8891284b046dd3fa6a2dc32
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1bf9a752.failed

Under some circumstances (notably using thunderbolt interface) SPI
on chip reset may be in active transaction.
Here we forcibly cleanup SPI to prevent possible hangups.

	Signed-off-by: Igor Russkikh <igor.russkikh@aquantia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1bf9a7520fadaebfb8891284b046dd3fa6a2dc32)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
index 9c7e9161b4db,fcb3279ff9c7..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
@@@ -27,11 -28,225 +27,230 @@@
  
  #define HW_ATL_MPI_STATE_MSK    0x00FFU
  #define HW_ATL_MPI_STATE_SHIFT  0U
 -#define HW_ATL_MPI_SPEED_MSK    0xFFFF0000U
 +#define HW_ATL_MPI_SPEED_MSK    0xFFFFU
  #define HW_ATL_MPI_SPEED_SHIFT  16U
  
++<<<<<<< HEAD
 +static int hw_atl_utils_fw_downld_dwords(struct aq_hw_s *self, u32 a,
 +					 u32 *p, u32 cnt)
++=======
+ #define HW_ATL_MPI_DAISY_CHAIN_STATUS	0x704
+ #define HW_ATL_MPI_BOOT_EXIT_CODE	0x388
+ 
+ #define HW_ATL_MAC_PHY_CONTROL	0x4000
+ #define HW_ATL_MAC_PHY_MPI_RESET_BIT 0x1D
+ 
+ #define HW_ATL_FW_VER_1X 0x01050006U
+ #define HW_ATL_FW_VER_2X 0x02000000U
+ #define HW_ATL_FW_VER_3X 0x03000000U
+ 
+ #define FORCE_FLASHLESS 0
+ 
+ static int hw_atl_utils_ver_match(u32 ver_expected, u32 ver_actual);
+ 
+ int hw_atl_utils_initfw(struct aq_hw_s *self, const struct aq_fw_ops **fw_ops)
+ {
+ 	int err = 0;
+ 
+ 	err = hw_atl_utils_soft_reset(self);
+ 	if (err)
+ 		return err;
+ 
+ 	hw_atl_utils_hw_chip_features_init(self,
+ 					   &self->chip_features);
+ 
+ 	hw_atl_utils_get_fw_version(self, &self->fw_ver_actual);
+ 
+ 	if (hw_atl_utils_ver_match(HW_ATL_FW_VER_1X,
+ 				   self->fw_ver_actual) == 0) {
+ 		*fw_ops = &aq_fw_1x_ops;
+ 	} else if (hw_atl_utils_ver_match(HW_ATL_FW_VER_2X,
+ 					self->fw_ver_actual) == 0) {
+ 		*fw_ops = &aq_fw_2x_ops;
+ 	} else if (hw_atl_utils_ver_match(HW_ATL_FW_VER_3X,
+ 					self->fw_ver_actual) == 0) {
+ 		*fw_ops = &aq_fw_2x_ops;
+ 	} else {
+ 		aq_pr_err("Bad FW version detected: %x\n",
+ 			  self->fw_ver_actual);
+ 		return -EOPNOTSUPP;
+ 	}
+ 	self->aq_fw_ops = *fw_ops;
+ 	err = self->aq_fw_ops->init(self);
+ 	return err;
+ }
+ 
+ static int hw_atl_utils_soft_reset_flb(struct aq_hw_s *self)
+ {
+ 	u32 gsr, val;
+ 	int k = 0;
+ 
+ 	aq_hw_write_reg(self, 0x404, 0x40e1);
+ 	AQ_HW_SLEEP(50);
+ 
+ 	/* Cleanup SPI */
+ 	val = aq_hw_read_reg(self, 0x53C);
+ 	aq_hw_write_reg(self, 0x53C, val | 0x10);
+ 
+ 	gsr = aq_hw_read_reg(self, HW_ATL_GLB_SOFT_RES_ADR);
+ 	aq_hw_write_reg(self, HW_ATL_GLB_SOFT_RES_ADR, (gsr & 0xBFFF) | 0x8000);
+ 
+ 	/* Kickstart MAC */
+ 	aq_hw_write_reg(self, 0x404, 0x80e0);
+ 	aq_hw_write_reg(self, 0x32a8, 0x0);
+ 	aq_hw_write_reg(self, 0x520, 0x1);
+ 
+ 	/* Reset SPI again because of possible interrupted SPI burst */
+ 	val = aq_hw_read_reg(self, 0x53C);
+ 	aq_hw_write_reg(self, 0x53C, val | 0x10);
+ 	AQ_HW_SLEEP(10);
+ 	/* Clear SPI reset state */
+ 	aq_hw_write_reg(self, 0x53C, val & ~0x10);
+ 
+ 	aq_hw_write_reg(self, 0x404, 0x180e0);
+ 
+ 	for (k = 0; k < 1000; k++) {
+ 		u32 flb_status = aq_hw_read_reg(self,
+ 						HW_ATL_MPI_DAISY_CHAIN_STATUS);
+ 
+ 		flb_status = flb_status & 0x10;
+ 		if (flb_status)
+ 			break;
+ 		AQ_HW_SLEEP(10);
+ 	}
+ 	if (k == 1000) {
+ 		aq_pr_err("MAC kickstart failed\n");
+ 		return -EIO;
+ 	}
+ 
+ 	/* FW reset */
+ 	aq_hw_write_reg(self, 0x404, 0x80e0);
+ 	AQ_HW_SLEEP(50);
+ 	aq_hw_write_reg(self, 0x3a0, 0x1);
+ 
+ 	/* Kickstart PHY - skipped */
+ 
+ 	/* Global software reset*/
+ 	hw_atl_rx_rx_reg_res_dis_set(self, 0U);
+ 	hw_atl_tx_tx_reg_res_dis_set(self, 0U);
+ 	aq_hw_write_reg_bit(self, HW_ATL_MAC_PHY_CONTROL,
+ 			    BIT(HW_ATL_MAC_PHY_MPI_RESET_BIT),
+ 			    HW_ATL_MAC_PHY_MPI_RESET_BIT, 0x0);
+ 	gsr = aq_hw_read_reg(self, HW_ATL_GLB_SOFT_RES_ADR);
+ 	aq_hw_write_reg(self, HW_ATL_GLB_SOFT_RES_ADR, (gsr & 0xBFFF) | 0x8000);
+ 
+ 	for (k = 0; k < 1000; k++) {
+ 		u32 fw_state = aq_hw_read_reg(self, HW_ATL_MPI_FW_VERSION);
+ 
+ 		if (fw_state)
+ 			break;
+ 		AQ_HW_SLEEP(10);
+ 	}
+ 	if (k == 1000) {
+ 		aq_pr_err("FW kickstart failed\n");
+ 		return -EIO;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int hw_atl_utils_soft_reset_rbl(struct aq_hw_s *self)
+ {
+ 	u32 gsr, val, rbl_status;
+ 	int k;
+ 
+ 	aq_hw_write_reg(self, 0x404, 0x40e1);
+ 	aq_hw_write_reg(self, 0x3a0, 0x1);
+ 	aq_hw_write_reg(self, 0x32a8, 0x0);
+ 
+ 	/* Alter RBL status */
+ 	aq_hw_write_reg(self, 0x388, 0xDEAD);
+ 
+ 	/* Cleanup SPI */
+ 	val = aq_hw_read_reg(self, 0x53C);
+ 	aq_hw_write_reg(self, 0x53C, val | 0x10);
+ 
+ 	/* Global software reset*/
+ 	hw_atl_rx_rx_reg_res_dis_set(self, 0U);
+ 	hw_atl_tx_tx_reg_res_dis_set(self, 0U);
+ 	aq_hw_write_reg_bit(self, HW_ATL_MAC_PHY_CONTROL,
+ 			    BIT(HW_ATL_MAC_PHY_MPI_RESET_BIT),
+ 			    HW_ATL_MAC_PHY_MPI_RESET_BIT, 0x0);
+ 	gsr = aq_hw_read_reg(self, HW_ATL_GLB_SOFT_RES_ADR);
+ 	aq_hw_write_reg(self, HW_ATL_GLB_SOFT_RES_ADR,
+ 			(gsr & 0xFFFFBFFF) | 0x8000);
+ 
+ 	if (FORCE_FLASHLESS)
+ 		aq_hw_write_reg(self, 0x534, 0x0);
+ 
+ 	aq_hw_write_reg(self, 0x404, 0x40e0);
+ 
+ 	/* Wait for RBL boot */
+ 	for (k = 0; k < 1000; k++) {
+ 		rbl_status = aq_hw_read_reg(self, 0x388) & 0xFFFF;
+ 		if (rbl_status && rbl_status != 0xDEAD)
+ 			break;
+ 		AQ_HW_SLEEP(10);
+ 	}
+ 	if (!rbl_status || rbl_status == 0xDEAD) {
+ 		aq_pr_err("RBL Restart failed");
+ 		return -EIO;
+ 	}
+ 
+ 	/* Restore NVR */
+ 	if (FORCE_FLASHLESS)
+ 		aq_hw_write_reg(self, 0x534, 0xA0);
+ 
+ 	if (rbl_status == 0xF1A7) {
+ 		aq_pr_err("No FW detected. Dynamic FW load not implemented\n");
+ 		return -ENOTSUPP;
+ 	}
+ 
+ 	for (k = 0; k < 1000; k++) {
+ 		u32 fw_state = aq_hw_read_reg(self, HW_ATL_MPI_FW_VERSION);
+ 
+ 		if (fw_state)
+ 			break;
+ 		AQ_HW_SLEEP(10);
+ 	}
+ 	if (k == 1000) {
+ 		aq_pr_err("FW kickstart failed\n");
+ 		return -EIO;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int hw_atl_utils_soft_reset(struct aq_hw_s *self)
+ {
+ 	int k;
+ 	u32 boot_exit_code = 0;
+ 
+ 	for (k = 0; k < 1000; ++k) {
+ 		u32 flb_status = aq_hw_read_reg(self,
+ 						HW_ATL_MPI_DAISY_CHAIN_STATUS);
+ 		boot_exit_code = aq_hw_read_reg(self,
+ 						HW_ATL_MPI_BOOT_EXIT_CODE);
+ 		if (flb_status != 0x06000000 || boot_exit_code != 0)
+ 			break;
+ 	}
+ 
+ 	if (k == 1000) {
+ 		aq_pr_err("Neither RBL nor FLB firmware started\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	self->rbl_enabled = (boot_exit_code != 0);
+ 
+ 	if (self->rbl_enabled)
+ 		return hw_atl_utils_soft_reset_rbl(self);
+ 	else
+ 		return hw_atl_utils_soft_reset_flb(self);
+ }
+ 
+ int hw_atl_utils_fw_downld_dwords(struct aq_hw_s *self, u32 a,
+ 				  u32 *p, u32 cnt)
++>>>>>>> 1bf9a7520fad (net: aquantia: Fix hardware reset when SPI may rarely hangup)
  {
  	int err = 0;
  
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
