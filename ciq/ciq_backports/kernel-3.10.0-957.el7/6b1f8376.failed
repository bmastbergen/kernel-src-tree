scsi: netvsc: Use the vmbus function to calculate ring buffer percentage

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] netvsc: Use the vmbus function to calculate ring buffer percentage (Cathy Avery) [1568513]
Rebuild_FUZZ: 95.65%
commit-author Long Li <longli@microsoft.com>
commit 6b1f8376dc34fb3b728672ed6e06751f26b3b225
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6b1f8376.failed

In Vmbus, we have defined a function to calculate available ring buffer
percentage to write.

Use that function and remove netvsc's private version.

[mkp: typo]

	Signed-off-by: Long Li <longli@microsoft.com>
	Acked-by: David S. Miller <davem@davemloft.net>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 6b1f8376dc34fb3b728672ed6e06751f26b3b225)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc.c
diff --cc drivers/net/hyperv/netvsc.c
index 1741fecf234a,96bf712ddd31..000000000000
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@@ -680,14 -677,18 +668,23 @@@ static void netvsc_send_tx_complete(str
  	queue_sends =
  		atomic_dec_return(&net_device->chan_table[q_idx].queue_sends);
  
 -	if (unlikely(net_device->destroy)) {
 -		if (queue_sends == 0)
 -			wake_up(&net_device->wait_drain);
 -	} else {
 -		struct netdev_queue *txq = netdev_get_tx_queue(ndev, q_idx);
 +	if (net_device->destroy && queue_sends == 0)
 +		wake_up(&net_device->wait_drain);
  
++<<<<<<< HEAD
 +	if (netif_tx_queue_stopped(netdev_get_tx_queue(ndev, q_idx)) &&
 +	    (hv_ringbuf_avail_percent(&channel->outbound) > RING_AVAIL_PERCENT_HIWATER ||
 +	     queue_sends < 1)) {
 +		netif_tx_wake_queue(netdev_get_tx_queue(ndev, q_idx));
 +		ndev_ctx->eth_stats.wake_queue++;
++=======
+ 		if (netif_tx_queue_stopped(txq) &&
+ 		    (hv_get_avail_to_write_percent(&channel->outbound) >
+ 		     RING_AVAIL_PERCENT_HIWATER || queue_sends < 1)) {
+ 			netif_tx_wake_queue(txq);
+ 			ndev_ctx->eth_stats.wake_queue++;
+ 		}
++>>>>>>> 6b1f8376dc34 (scsi: netvsc: Use the vmbus function to calculate ring buffer percentage)
  	}
  }
  
diff --git a/drivers/net/hyperv/hyperv_net.h b/drivers/net/hyperv/hyperv_net.h
index b2bc53d51990..7c5004ecc9c9 100644
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@ -190,7 +190,6 @@ struct netvsc_device;
 struct net_device_context;
 
 extern u32 netvsc_ring_bytes;
-extern struct reciprocal_value netvsc_ring_reciprocal;
 
 struct netvsc_device *netvsc_device_add(struct hv_device *device,
 					const struct netvsc_device_info *info);
* Unmerged path drivers/net/hyperv/netvsc.c
diff --git a/drivers/net/hyperv/netvsc_drv.c b/drivers/net/hyperv/netvsc_drv.c
index 65d3ecac72a0..7fa36a169b57 100644
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@ -36,7 +36,6 @@
 #include <linux/slab.h>
 #include <linux/rtnetlink.h>
 #include <linux/netpoll.h>
-#include <linux/reciprocal_div.h>
 
 #include <net/arp.h>
 #include <net/route.h>
@@ -56,7 +55,6 @@ static unsigned int ring_size __ro_after_init = 128;
 module_param(ring_size, uint, S_IRUGO);
 MODULE_PARM_DESC(ring_size, "Ring buffer size (# of pages)");
 unsigned int netvsc_ring_bytes __ro_after_init;
-struct reciprocal_value netvsc_ring_reciprocal __ro_after_init;
 
 static const u32 default_msg = NETIF_MSG_DRV | NETIF_MSG_PROBE |
 				NETIF_MSG_LINK | NETIF_MSG_IFUP |
@@ -2149,7 +2147,6 @@ static int __init netvsc_drv_init(void)
 			ring_size);
 	}
 	netvsc_ring_bytes = ring_size * PAGE_SIZE;
-	netvsc_ring_reciprocal = reciprocal_value(netvsc_ring_bytes);
 
 	ret = vmbus_driver_register(&netvsc_drv);
 	if (ret)
