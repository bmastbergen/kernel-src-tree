xfrm: Don't use sk_family for socket policy lookups

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Steffen Klassert <steffen.klassert@secunet.com>
commit 4c86d77743a54fb2d8a4d18a037a074c892bb3be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4c86d777.failed

On IPv4-mapped IPv6 addresses sk_family is AF_INET6,
but the flow informations are created based on AF_INET.
So the routing set up 'struct flowi4' but we try to
access 'struct flowi6' what leads to an out of bounds
access. Fix this by using the family we get with the
dst_entry, like we do it for the standard policy lookup.

	Reported-by: Dmitry Vyukov <dvyukov@google.com>
	Tested-by: Dmitry Vyukov <dvyukov@google.com>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 4c86d77743a54fb2d8a4d18a037a074c892bb3be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xfrm/xfrm_policy.c
diff --cc net/xfrm/xfrm_policy.c
index 82411ade823d,a9af17f0fce6..000000000000
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@@ -1214,16 -1247,16 +1214,29 @@@ static inline int policy_to_flow_dir(in
  	}
  }
  
++<<<<<<< HEAD
 +static struct xfrm_policy *xfrm_sk_policy_lookup(struct sock *sk, int dir,
 +						 const struct flowi *fl)
++=======
+ static struct xfrm_policy *xfrm_sk_policy_lookup(const struct sock *sk, int dir,
+ 						 const struct flowi *fl, u16 family)
++>>>>>>> 4c86d77743a5 (xfrm: Don't use sk_family for socket policy lookups)
  {
  	struct xfrm_policy *pol;
 -
 +	struct net *net = sock_net(sk);
 +
++<<<<<<< HEAD
 +	read_lock_bh(&net->xfrm_policy_lock);
 +	if ((pol = sk->sk_policy[dir]) != NULL) {
 +		bool match = xfrm_selector_match(&pol->selector, fl,
 +						 sk->sk_family);
++=======
+ 	rcu_read_lock();
+  again:
+ 	pol = rcu_dereference(sk->sk_policy[dir]);
+ 	if (pol != NULL) {
+ 		bool match = xfrm_selector_match(&pol->selector, fl, family);
++>>>>>>> 4c86d77743a5 (xfrm: Don't use sk_family for socket policy lookups)
  		int err = 0;
  
  		if (match) {
@@@ -2147,9 -2249,10 +2160,9 @@@ struct dst_entry *xfrm_lookup(struct ne
  	xdst = NULL;
  	route = NULL;
  
 -	sk = sk_const_to_full_sk(sk);
  	if (sk && sk->sk_policy[XFRM_POLICY_OUT]) {
  		num_pols = 1;
- 		pols[0] = xfrm_sk_policy_lookup(sk, XFRM_POLICY_OUT, fl);
+ 		pols[0] = xfrm_sk_policy_lookup(sk, XFRM_POLICY_OUT, fl, family);
  		err = xfrm_expand_policies(fl, family, pols,
  					   &num_pols, &num_xfrms);
  		if (err < 0)
@@@ -2426,8 -2529,9 +2439,8 @@@ int __xfrm_policy_check(struct sock *sk
  	}
  
  	pol = NULL;
 -	sk = sk_to_full_sk(sk);
  	if (sk && sk->sk_policy[dir]) {
- 		pol = xfrm_sk_policy_lookup(sk, dir, &fl);
+ 		pol = xfrm_sk_policy_lookup(sk, dir, &fl, family);
  		if (IS_ERR(pol)) {
  			XFRM_INC_STATS(net, LINUX_MIB_XFRMINPOLERROR);
  			return 0;
* Unmerged path net/xfrm/xfrm_policy.c
