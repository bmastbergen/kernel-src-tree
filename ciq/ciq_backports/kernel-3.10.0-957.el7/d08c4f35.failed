net: Refactor rtable initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] route: Refactor rtable initialization (Sabrina Dubroca) [1508392]
Rebuild_FUZZ: 91.67%
commit-author David Ahern <dsa@cumulusnetworks.com>
commit d08c4f355403840fad98d9918db51a7113f38ee8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d08c4f35.failed

All callers to rt_dst_alloc have nearly the same initialization following
a successful allocation. Consolidate it into rt_dst_alloc.

	Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d08c4f355403840fad98d9918db51a7113f38ee8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/route.c
diff --cc net/ipv4/route.c
index c617c77403d2,eaefeadce07c..000000000000
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@@ -1463,10 -1468,13 +1484,17 @@@ static struct rtable *rt_dst_alloc(stru
  }
  
  /* called in rcu_read_lock() section */
 -static int ip_route_input_mc(struct sk_buff *skb, __be32 daddr, __be32 saddr,
 -				u8 tos, struct net_device *dev, int our)
 +int ip_mc_validate_source(struct sk_buff *skb, __be32 daddr, __be32 saddr,
 +			  u8 tos, struct net_device *dev,
 +			  struct in_device *in_dev, u32 *itag)
  {
++<<<<<<< HEAD
++=======
+ 	struct rtable *rth;
+ 	struct in_device *in_dev = __in_dev_get_rcu(dev);
+ 	unsigned int flags = RTCF_MULTICAST;
+ 	u32 itag = 0;
++>>>>>>> d08c4f355403 (net: Refactor rtable initialization)
  	int err;
  
  	/* Primary sanity checks. */
@@@ -1483,33 -1492,20 +1511,40 @@@
  
  	if (ipv4_is_zeronet(saddr)) {
  		if (!ipv4_is_local_multicast(daddr))
 -			goto e_inval;
 +			return -EINVAL;
  	} else {
  		err = fib_validate_source(skb, saddr, 0, tos, 0, dev,
 -					  in_dev, &itag);
 +					  in_dev, itag);
  		if (err < 0)
 -			goto e_err;
 +			return err;
  	}
++<<<<<<< HEAD
 +	return 0;
 +}
 +
 +/* called in rcu_read_lock() section */
 +static int ip_route_input_mc(struct sk_buff *skb, __be32 daddr, __be32 saddr,
 +			     u8 tos, struct net_device *dev, int our)
 +{
 +	struct in_device *in_dev = __in_dev_get_rcu(dev);
 +	struct rtable *rth;
 +	u32 itag = 0;
 +	int err;
 +
 +	err = ip_mc_validate_source(skb, daddr, saddr, tos, dev, in_dev, &itag);
 +	if (err)
 +		return err;
 +
 +	rth = rt_dst_alloc(dev_net(dev)->loopback_dev,
++=======
+ 	if (our)
+ 		flags |= RTCF_LOCAL;
+ 
+ 	rth = rt_dst_alloc(dev_net(dev)->loopback_dev, flags, RTN_MULTICAST,
++>>>>>>> d08c4f355403 (net: Refactor rtable initialization)
  			   IN_DEV_CONF_GET(in_dev, NOPOLICY), false, false);
  	if (!rth)
 -		goto e_nobufs;
 +		return -ENOBUFS;
  
  #ifdef CONFIG_IP_ROUTE_CLASSID
  	rth->dst.tclassid = itag;
@@@ -1677,18 -1628,10 +1699,18 @@@ rt_cache
  		goto cleanup;
  	}
  
- 	rth->rt_genid = rt_genid_ipv4(dev_net(rth->dst.dev));
- 	rth->rt_flags = 0;
- 	rth->rt_type = res->type;
  	rth->rt_is_input = 1;
++<<<<<<< HEAD
 +	rth->rt_iif 	= 0;
 +	rth->rt_pmtu	= 0;
 +	rth->rt_gateway	= 0;
 +	rth->rt_uses_gateway = 0;
 +	INIT_LIST_HEAD(&rth->rt_uncached);
++=======
+ 	RT_CACHE_STAT_INC(in_slow_tot);
++>>>>>>> d08c4f355403 (net: Refactor rtable initialization)
  
  	rth->dst.input = ip_forward;
- 	rth->dst.output = ip_output;
  
  	rt_set_nexthop(rth, daddr, res, fnhe, res->fi, res->type, itag);
  	if (lwtunnel_output_redirect(rth->dst.lwtstate)) {
@@@ -1912,17 -1807,9 +1933,8 @@@ local_input
  #ifdef CONFIG_IP_ROUTE_CLASSID
  	rth->dst.tclassid = itag;
  #endif
- 
- 	rth->rt_genid = rt_genid_ipv4(net);
- 	rth->rt_flags 	= flags|RTCF_LOCAL;
- 	rth->rt_type	= res.type;
  	rth->rt_is_input = 1;
- 	rth->rt_iif	= 0;
- 	rth->rt_pmtu	= 0;
- 	rth->rt_gateway	= 0;
- 	rth->rt_uses_gateway = 0;
- 	INIT_LIST_HEAD(&rth->rt_uncached);
  
 -	RT_CACHE_STAT_INC(in_slow_tot);
  	if (res.type == RTN_UNREACHABLE) {
  		rth->dst.input= ip_error;
  		rth->dst.error= -err;
* Unmerged path net/ipv4/route.c
