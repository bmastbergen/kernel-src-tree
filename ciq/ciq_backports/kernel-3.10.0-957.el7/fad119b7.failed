scsi: megaraid_sas: switch to pci_alloc_irq_vectors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] megaraid_sas: switch to pci_alloc_irq_vectors (Tomas Henzl) [1513838]
Rebuild_FUZZ: 93.75%
commit-author Hannes Reinecke <hare@suse.de>
commit fad119b707f8cc01b259b8585af4f9688e57c9a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/fad119b7.failed

[mkp: fixed bad indentation]

	Signed-off-by: Hannes Reinecke <hare@suse.com>
	Acked-by: Sumit Saxena <sumit.saxena@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit fad119b707f8cc01b259b8585af4f9688e57c9a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas_base.c
diff --cc drivers/scsi/megaraid/megaraid_sas_base.c
index c999b3ce3835,6484c382f670..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@@ -5331,19 -5125,9 +5319,25 @@@ static int megasas_init_fw(struct megas
  		else
  			instance->msix_vectors = 0;
  	}
++<<<<<<< HEAD
 +	/*
 +	 * MSI-X host index 0 is common for all adapter.
 +	 * It is used for all MPT based Adapters.
 +	 */
 +	if (instance->msix_combined) {
 +		instance->reply_post_host_index_addr[0] =
 +				(u32 *)((u8 *)instance->reg_set +
 +				MPI2_SUP_REPLY_POST_HOST_INDEX_OFFSET);
 +	} else {
 +		instance->reply_post_host_index_addr[0] =
 +			(u32 *)((u8 *)instance->reg_set +
 +			MPI2_REPLY_POST_HOST_INDEX_OFFSET);
 +	}
++=======
+ 	i = pci_alloc_irq_vectors(instance->pdev, 1, 1, PCI_IRQ_LEGACY);
+ 	if (i < 0)
+ 		goto fail_setup_irqs;
++>>>>>>> fad119b707f8 (scsi: megaraid_sas: switch to pci_alloc_irq_vectors)
  
  	dev_info(&instance->pdev->dev,
  		"firmware supports msix\t: (%d)", fw_msix_count);
@@@ -5555,12 -5296,13 +5549,13 @@@
  
  	return 0;
  
 -fail_get_pd_list:
 +fail_get_ld_pd_list:
  	instance->instancet->disable_intr(instance);
- 	megasas_destroy_irqs(instance);
  fail_init_adapter:
+ 	megasas_destroy_irqs(instance);
+ fail_setup_irqs:
  	if (instance->msix_vectors)
- 		pci_disable_msix(instance->pdev);
+ 		pci_free_irq_vectors(instance->pdev);
  	instance->msix_vectors = 0;
  fail_ready_state:
  	kfree(instance->ctrl_info);
@@@ -6447,11 -5933,24 +6441,11 @@@ fail_io_attach
  	else
  		megasas_release_mfi(instance);
  	if (instance->msix_vectors)
- 		pci_disable_msix(instance->pdev);
+ 		pci_free_irq_vectors(instance->pdev);
  fail_init_mfi:
  fail_alloc_dma_buf:
 -	if (instance->evt_detail)
 -		pci_free_consistent(pdev, sizeof(struct megasas_evt_detail),
 -				    instance->evt_detail,
 -				    instance->evt_detail_h);
 -
 -	if (instance->pd_info)
 -		pci_free_consistent(pdev, sizeof(struct MR_PD_INFO),
 -					instance->pd_info,
 -					instance->pd_info_h);
 -	if (instance->producer)
 -		pci_free_consistent(pdev, sizeof(u32), instance->producer,
 -				    instance->producer_h);
 -	if (instance->consumer)
 -		pci_free_consistent(pdev, sizeof(u32), instance->consumer,
 -				    instance->consumer_h);
 +	megasas_free_ctrl_dma_buffers(instance);
 +	megasas_free_ctrl_mem(instance);
  	scsi_host_put(host);
  
  fail_alloc_instance:
@@@ -6648,12 -6147,18 +6643,18 @@@ megasas_resume(struct pci_dev *pdev
  		goto fail_ready_state;
  
  	/* Now re-enable MSI-X */
- 	if (instance->msix_vectors &&
- 	    pci_enable_msix_exact(instance->pdev, instance->msixentry,
- 				  instance->msix_vectors))
+ 	if (instance->msix_vectors) {
+ 		irq_flags = PCI_IRQ_MSIX;
+ 		if (smp_affinity_enable)
+ 			irq_flags |= PCI_IRQ_AFFINITY;
+ 	}
+ 	rval = pci_alloc_irq_vectors(instance->pdev, 1,
+ 				     instance->msix_vectors ?
+ 				     instance->msix_vectors : 1, irq_flags);
+ 	if (rval < 0)
  		goto fail_reenable_msix;
  
 -	if (instance->ctrl_context) {
 +	if (instance->adapter_type != MFI_SERIES) {
  		megasas_reset_reply_desc(instance);
  		if (megasas_ioc_init_fusion(instance)) {
  			megasas_free_cmds(instance);
@@@ -6810,17 -6328,9 +6811,17 @@@ skip_firing_dcmds
  	megasas_destroy_irqs(instance);
  
  	if (instance->msix_vectors)
- 		pci_disable_msix(instance->pdev);
+ 		pci_free_irq_vectors(instance->pdev);
  
 -	if (instance->ctrl_context) {
 +	if (instance->adapter_type == VENTURA_SERIES) {
 +		for (i = 0; i < MAX_LOGICAL_DRIVES_EXT; ++i)
 +			kfree(fusion->stream_detect_by_ld[i]);
 +		kfree(fusion->stream_detect_by_ld);
 +		fusion->stream_detect_by_ld = NULL;
 +	}
 +
 +
 +	if (instance->adapter_type != MFI_SERIES) {
  		megasas_release_fusion(instance);
  			pd_seq_map_sz = sizeof(struct MR_PD_CFG_SEQ_NUM_SYNC) +
  				(sizeof(struct MR_PD_CFG_SEQ) *
diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h
index 4851bc47e3cd..f0349e394d5b 100644
--- a/drivers/scsi/megaraid/megaraid_sas.h
+++ b/drivers/scsi/megaraid/megaraid_sas.h
@@ -2223,7 +2223,6 @@ struct megasas_instance {
 	void *ctrl_context;
 	struct megasas_ctrl_info *ctrl_info;
 	unsigned int msix_vectors;
-	struct msix_entry msixentry[MEGASAS_MAX_MSIX_QUEUES];
 	struct megasas_irq_context irq_context[MEGASAS_MAX_MSIX_QUEUES];
 	u64 map_id;
 	u64 pd_seq_map_id;
* Unmerged path drivers/scsi/megaraid/megaraid_sas_base.c
