powerpc/powernv/pci: Work around races in PCI bridge enabling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [powerpc] powernv/pci: Work around races in PCI bridge enabling (Gustavo Duarte) [1620041]
Rebuild_FUZZ: 92.98%
commit-author Benjamin Herrenschmidt <benh@kernel.crashing.org>
commit db2173198b9513f7add8009f225afa1f1c79bcc6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/db217319.failed

The generic code is racy when multiple children of a PCI bridge try to
enable it simultaneously.

This leads to drivers trying to access a device through a
not-yet-enabled bridge, and this EEH errors under various
circumstances when using parallel driver probing.

There is work going on to fix that properly in the PCI core but it
will take some time.

x86 gets away with it because (outside of hotplug), the BIOS enables
all the bridges at boot time.

This patch does the same thing on powernv by enabling all bridges that
have child devices at boot time, thus avoiding subsequent races. It's
suitable for backporting to stable and distros, while the proper PCI
fix will probably be significantly more invasive.

	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: stable@vger.kernel.org
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit db2173198b9513f7add8009f225afa1f1c79bcc6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/powernv/pci-ioda.c
diff --cc arch/powerpc/platforms/powernv/pci-ioda.c
index cbcae2797ce6,463308786b8a..000000000000
--- a/arch/powerpc/platforms/powernv/pci-ioda.c
+++ b/arch/powerpc/platforms/powernv/pci-ioda.c
@@@ -3203,42 -3227,52 +3203,80 @@@ static void pnv_pci_ioda_create_dbgfs(v
  #endif /* CONFIG_DEBUG_FS */
  }
  
++<<<<<<< HEAD
 +static void pnv_npu_ioda_fixup(void)
 +{
 +	bool enable_bypass;
 +	struct pci_controller *hose, *tmp;
 +	struct pnv_phb *phb;
 +	struct pnv_ioda_pe *pe;
 +
 +	list_for_each_entry_safe(hose, tmp, &hose_list, list_node) {
 +		phb = hose->private_data;
 +		if (phb->type != PNV_PHB_NPU)
 +			continue;
 +
 +		list_for_each_entry(pe, &phb->ioda.pe_dma_list, dma_link) {
 +			enable_bypass = dma_get_mask(&pe->pdev->dev) ==
 +				DMA_BIT_MASK(64);
 +			pnv_npu_init_dma_pe(pe);
 +			pnv_npu_dma_set_bypass(pe, enable_bypass);
 +		}
 +	}
++=======
+ static void pnv_pci_enable_bridge(struct pci_bus *bus)
+ {
+ 	struct pci_dev *dev = bus->self;
+ 	struct pci_bus *child;
+ 
+ 	/* Empty bus ? bail */
+ 	if (list_empty(&bus->devices))
+ 		return;
+ 
+ 	/*
+ 	 * If there's a bridge associated with that bus enable it. This works
+ 	 * around races in the generic code if the enabling is done during
+ 	 * parallel probing. This can be removed once those races have been
+ 	 * fixed.
+ 	 */
+ 	if (dev) {
+ 		int rc = pci_enable_device(dev);
+ 		if (rc)
+ 			pci_err(dev, "Error enabling bridge (%d)\n", rc);
+ 		pci_set_master(dev);
+ 	}
+ 
+ 	/* Perform the same to child busses */
+ 	list_for_each_entry(child, &bus->children, node)
+ 		pnv_pci_enable_bridge(child);
+ }
+ 
+ static void pnv_pci_enable_bridges(void)
+ {
+ 	struct pci_controller *hose;
+ 
+ 	list_for_each_entry(hose, &hose_list, list_node)
+ 		pnv_pci_enable_bridge(hose->bus);
++>>>>>>> db2173198b95 (powerpc/powernv/pci: Work around races in PCI bridge enabling)
  }
  
  static void pnv_pci_ioda_fixup(void)
  {
  	pnv_pci_ioda_setup_PEs();
 -	pnv_pci_ioda_setup_iommu_api();
 +	pnv_pci_ioda_setup_seg();
 +	pnv_pci_ioda_setup_DMA();
 +
  	pnv_pci_ioda_create_dbgfs();
  
+ 	pnv_pci_enable_bridges();
+ 
  #ifdef CONFIG_EEH
 -	pnv_eeh_post_init();
 +	eeh_init();
 +	eeh_addr_cache_build();
  #endif
 +
 +	/* Link NPU IODA tables to their PCI devices. */
 +	pnv_npu_ioda_fixup();
  }
  
  /*
* Unmerged path arch/powerpc/platforms/powernv/pci-ioda.c
