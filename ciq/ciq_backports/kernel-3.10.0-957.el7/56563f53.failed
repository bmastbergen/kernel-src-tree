x86/bugs: Move the l1tf function and define pr_fmt properly

jira LE-1907
cve CVE-2018-3620
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] bugs: move the l1tf function and define pr_fmt properly (Christoph von Recklinghausen) [1593384] {CVE-2018-3620}
Rebuild_FUZZ: 96.49%
commit-author Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
commit 56563f53d3066afa9e63d6c997bf67e76a8b05c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/56563f53.failed

The pr_warn in l1tf_select_mitigation would have used the prior pr_fmt
which was defined as "Spectre V2 : ".

Move the function to be past SSBD and also define the pr_fmt.

Fixes: 17dbca119312 ("x86/speculation/l1tf: Add sysfs reporting for l1tf")
	Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 56563f53d3066afa9e63d6c997bf67e76a8b05c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/bugs.c
diff --cc arch/x86/kernel/cpu/bugs.c
index 29b8876b1f95,50500cea6eba..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -104,6 -138,115 +104,118 @@@ enum spectre_v2_mitigation_cmd spectre_
  #undef pr_fmt
  #define pr_fmt(fmt)     "Spectre V2 : " fmt
  
++<<<<<<< HEAD
++=======
+ static enum spectre_v2_mitigation spectre_v2_enabled __ro_after_init =
+ 	SPECTRE_V2_NONE;
+ 
+ void
+ x86_virt_spec_ctrl(u64 guest_spec_ctrl, u64 guest_virt_spec_ctrl, bool setguest)
+ {
+ 	u64 msrval, guestval, hostval = x86_spec_ctrl_base;
+ 	struct thread_info *ti = current_thread_info();
+ 
+ 	/* Is MSR_SPEC_CTRL implemented ? */
+ 	if (static_cpu_has(X86_FEATURE_MSR_SPEC_CTRL)) {
+ 		/*
+ 		 * Restrict guest_spec_ctrl to supported values. Clear the
+ 		 * modifiable bits in the host base value and or the
+ 		 * modifiable bits from the guest value.
+ 		 */
+ 		guestval = hostval & ~x86_spec_ctrl_mask;
+ 		guestval |= guest_spec_ctrl & x86_spec_ctrl_mask;
+ 
+ 		/* SSBD controlled in MSR_SPEC_CTRL */
+ 		if (static_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD))
+ 			hostval |= ssbd_tif_to_spec_ctrl(ti->flags);
+ 
+ 		if (hostval != guestval) {
+ 			msrval = setguest ? guestval : hostval;
+ 			wrmsrl(MSR_IA32_SPEC_CTRL, msrval);
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * If SSBD is not handled in MSR_SPEC_CTRL on AMD, update
+ 	 * MSR_AMD64_L2_CFG or MSR_VIRT_SPEC_CTRL if supported.
+ 	 */
+ 	if (!static_cpu_has(X86_FEATURE_LS_CFG_SSBD) &&
+ 	    !static_cpu_has(X86_FEATURE_VIRT_SSBD))
+ 		return;
+ 
+ 	/*
+ 	 * If the host has SSBD mitigation enabled, force it in the host's
+ 	 * virtual MSR value. If its not permanently enabled, evaluate
+ 	 * current's TIF_SSBD thread flag.
+ 	 */
+ 	if (static_cpu_has(X86_FEATURE_SPEC_STORE_BYPASS_DISABLE))
+ 		hostval = SPEC_CTRL_SSBD;
+ 	else
+ 		hostval = ssbd_tif_to_spec_ctrl(ti->flags);
+ 
+ 	/* Sanitize the guest value */
+ 	guestval = guest_virt_spec_ctrl & SPEC_CTRL_SSBD;
+ 
+ 	if (hostval != guestval) {
+ 		unsigned long tif;
+ 
+ 		tif = setguest ? ssbd_spec_ctrl_to_tif(guestval) :
+ 				 ssbd_spec_ctrl_to_tif(hostval);
+ 
+ 		speculative_store_bypass_update(tif);
+ 	}
+ }
+ EXPORT_SYMBOL_GPL(x86_virt_spec_ctrl);
+ 
+ static void x86_amd_ssb_disable(void)
+ {
+ 	u64 msrval = x86_amd_ls_cfg_base | x86_amd_ls_cfg_ssbd_mask;
+ 
+ 	if (boot_cpu_has(X86_FEATURE_VIRT_SSBD))
+ 		wrmsrl(MSR_AMD64_VIRT_SPEC_CTRL, SPEC_CTRL_SSBD);
+ 	else if (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD))
+ 		wrmsrl(MSR_AMD64_LS_CFG, msrval);
+ }
+ 
+ #ifdef RETPOLINE
+ static bool spectre_v2_bad_module;
+ 
+ bool retpoline_module_ok(bool has_retpoline)
+ {
+ 	if (spectre_v2_enabled == SPECTRE_V2_NONE || has_retpoline)
+ 		return true;
+ 
+ 	pr_err("System may be vulnerable to spectre v2\n");
+ 	spectre_v2_bad_module = true;
+ 	return false;
+ }
+ 
+ static inline const char *spectre_v2_module_string(void)
+ {
+ 	return spectre_v2_bad_module ? " - vulnerable module loaded" : "";
+ }
+ #else
+ static inline const char *spectre_v2_module_string(void) { return ""; }
+ #endif
+ 
+ static void __init spec2_print_if_insecure(const char *reason)
+ {
+ 	if (boot_cpu_has_bug(X86_BUG_SPECTRE_V2))
+ 		pr_info("%s selected on command line.\n", reason);
+ }
+ 
+ static void __init spec2_print_if_secure(const char *reason)
+ {
+ 	if (!boot_cpu_has_bug(X86_BUG_SPECTRE_V2))
+ 		pr_info("%s selected on command line.\n", reason);
+ }
+ 
+ static inline bool retp_compiler(void)
+ {
+ 	return __is_defined(RETPOLINE);
+ }
+ 
++>>>>>>> 56563f53d306 (x86/bugs: Move the l1tf function and define pr_fmt properly)
  static inline bool match_option(const char *arg, int arglen, const char *opt)
  {
  	int len = strlen(opt);
@@@ -153,61 -351,375 +265,90 @@@ void __spectre_v2_select_mitigation(voi
  
  	case SPECTRE_V2_CMD_FORCE:
  	case SPECTRE_V2_CMD_AUTO:
 -		if (IS_ENABLED(CONFIG_RETPOLINE))
 -			goto retpoline_auto;
 -		break;
 -	case SPECTRE_V2_CMD_RETPOLINE_AMD:
 -		if (IS_ENABLED(CONFIG_RETPOLINE))
 -			goto retpoline_amd;
 -		break;
 -	case SPECTRE_V2_CMD_RETPOLINE_GENERIC:
 -		if (IS_ENABLED(CONFIG_RETPOLINE))
 -			goto retpoline_generic;
 -		break;
 -	case SPECTRE_V2_CMD_RETPOLINE:
 -		if (IS_ENABLED(CONFIG_RETPOLINE))
 -			goto retpoline_auto;
  		break;
 -	}
 -	pr_err("Spectre mitigation: kernel not compiled with retpoline; no mitigation available!");
 -	return;
 -
 -retpoline_auto:
 -	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) {
 -	retpoline_amd:
 -		if (!boot_cpu_has(X86_FEATURE_LFENCE_RDTSC)) {
 -			pr_err("Spectre mitigation: LFENCE not serializing, switching to generic retpoline\n");
 -			goto retpoline_generic;
 -		}
 -		mode = retp_compiler() ? SPECTRE_V2_RETPOLINE_AMD :
 -					 SPECTRE_V2_RETPOLINE_MINIMAL_AMD;
 -		setup_force_cpu_cap(X86_FEATURE_RETPOLINE_AMD);
 -		setup_force_cpu_cap(X86_FEATURE_RETPOLINE);
 -	} else {
 -	retpoline_generic:
 -		mode = retp_compiler() ? SPECTRE_V2_RETPOLINE_GENERIC :
 -					 SPECTRE_V2_RETPOLINE_MINIMAL;
 -		setup_force_cpu_cap(X86_FEATURE_RETPOLINE);
 -	}
 -
 -	spectre_v2_enabled = mode;
 -	pr_info("%s\n", spectre_v2_strings[mode]);
 -
 -	/*
 -	 * If neither SMEP nor PTI are available, there is a risk of
 -	 * hitting userspace addresses in the RSB after a context switch
 -	 * from a shallow call stack to a deeper one. To prevent this fill
 -	 * the entire RSB, even when using IBRS.
 -	 *
 -	 * Skylake era CPUs have a separate issue with *underflow* of the
 -	 * RSB, when they will predict 'ret' targets from the generic BTB.
 -	 * The proper mitigation for this is IBRS. If IBRS is not supported
 -	 * or deactivated in favour of retpolines the RSB fill on context
 -	 * switch is required.
 -	 */
 -	if ((!boot_cpu_has(X86_FEATURE_PTI) &&
 -	     !boot_cpu_has(X86_FEATURE_SMEP)) || is_skylake_era()) {
 -		setup_force_cpu_cap(X86_FEATURE_RSB_CTXSW);
 -		pr_info("Spectre v2 mitigation: Filling RSB on context switch\n");
 -	}
 -
 -	/* Initialize Indirect Branch Prediction Barrier if supported */
 -	if (boot_cpu_has(X86_FEATURE_IBPB)) {
 -		setup_force_cpu_cap(X86_FEATURE_USE_IBPB);
 -		pr_info("Spectre v2 mitigation: Enabling Indirect Branch Prediction Barrier\n");
 -	}
 -
 -	/*
 -	 * Retpoline means the kernel is safe because it has no indirect
 -	 * branches. But firmware isn't, so use IBRS to protect that.
 -	 */
 -	if (boot_cpu_has(X86_FEATURE_IBRS)) {
 -		setup_force_cpu_cap(X86_FEATURE_USE_IBRS_FW);
 -		pr_info("Enabling Restricted Speculation for firmware calls\n");
 -	}
 -}
 -
 -#undef pr_fmt
 -#define pr_fmt(fmt)	"Speculative Store Bypass: " fmt
 -
 -static enum ssb_mitigation ssb_mode __ro_after_init = SPEC_STORE_BYPASS_NONE;
 -
 -/* The kernel command line selection */
 -enum ssb_mitigation_cmd {
 -	SPEC_STORE_BYPASS_CMD_NONE,
 -	SPEC_STORE_BYPASS_CMD_AUTO,
 -	SPEC_STORE_BYPASS_CMD_ON,
 -	SPEC_STORE_BYPASS_CMD_PRCTL,
 -	SPEC_STORE_BYPASS_CMD_SECCOMP,
 -};
 -
 -static const char *ssb_strings[] = {
 -	[SPEC_STORE_BYPASS_NONE]	= "Vulnerable",
 -	[SPEC_STORE_BYPASS_DISABLE]	= "Mitigation: Speculative Store Bypass disabled",
 -	[SPEC_STORE_BYPASS_PRCTL]	= "Mitigation: Speculative Store Bypass disabled via prctl",
 -	[SPEC_STORE_BYPASS_SECCOMP]	= "Mitigation: Speculative Store Bypass disabled via prctl and seccomp",
 -};
 -
 -static const struct {
 -	const char *option;
 -	enum ssb_mitigation_cmd cmd;
 -} ssb_mitigation_options[] = {
 -	{ "auto",	SPEC_STORE_BYPASS_CMD_AUTO },    /* Platform decides */
 -	{ "on",		SPEC_STORE_BYPASS_CMD_ON },      /* Disable Speculative Store Bypass */
 -	{ "off",	SPEC_STORE_BYPASS_CMD_NONE },    /* Don't touch Speculative Store Bypass */
 -	{ "prctl",	SPEC_STORE_BYPASS_CMD_PRCTL },   /* Disable Speculative Store Bypass via prctl */
 -	{ "seccomp",	SPEC_STORE_BYPASS_CMD_SECCOMP }, /* Disable Speculative Store Bypass via prctl and seccomp */
 -};
  
 -static enum ssb_mitigation_cmd __init ssb_parse_cmdline(void)
 -{
 -	enum ssb_mitigation_cmd cmd = SPEC_STORE_BYPASS_CMD_AUTO;
 -	char arg[20];
 -	int ret, i;
 -
 -	if (cmdline_find_option_bool(boot_command_line, "nospec_store_bypass_disable")) {
 -		return SPEC_STORE_BYPASS_CMD_NONE;
 -	} else {
 -		ret = cmdline_find_option(boot_command_line, "spec_store_bypass_disable",
 -					  arg, sizeof(arg));
 -		if (ret < 0)
 -			return SPEC_STORE_BYPASS_CMD_AUTO;
 -
 -		for (i = 0; i < ARRAY_SIZE(ssb_mitigation_options); i++) {
 -			if (!match_option(arg, ret, ssb_mitigation_options[i].option))
 -				continue;
 -
 -			cmd = ssb_mitigation_options[i].cmd;
 -			break;
 -		}
 -
 -		if (i >= ARRAY_SIZE(ssb_mitigation_options)) {
 -			pr_err("unknown option (%s). Switching to AUTO select\n", arg);
 -			return SPEC_STORE_BYPASS_CMD_AUTO;
 -		}
 -	}
 -
 -	return cmd;
 -}
 -
 -static enum ssb_mitigation __init __ssb_select_mitigation(void)
 -{
 -	enum ssb_mitigation mode = SPEC_STORE_BYPASS_NONE;
 -	enum ssb_mitigation_cmd cmd;
 -
 -	if (!boot_cpu_has(X86_FEATURE_SSBD))
 -		return mode;
 -
 -	cmd = ssb_parse_cmdline();
 -	if (!boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS) &&
 -	    (cmd == SPEC_STORE_BYPASS_CMD_NONE ||
 -	     cmd == SPEC_STORE_BYPASS_CMD_AUTO))
 -		return mode;
 +	case SPECTRE_V2_CMD_RETPOLINE:
 +		spec_ctrl_enable_retpoline();
 +		return;
  
 -	switch (cmd) {
 -	case SPEC_STORE_BYPASS_CMD_AUTO:
 -	case SPEC_STORE_BYPASS_CMD_SECCOMP:
 -		/*
 -		 * Choose prctl+seccomp as the default mode if seccomp is
 -		 * enabled.
 -		 */
 -		if (IS_ENABLED(CONFIG_SECCOMP))
 -			mode = SPEC_STORE_BYPASS_SECCOMP;
 -		else
 -			mode = SPEC_STORE_BYPASS_PRCTL;
 -		break;
 -	case SPEC_STORE_BYPASS_CMD_ON:
 -		mode = SPEC_STORE_BYPASS_DISABLE;
 -		break;
 -	case SPEC_STORE_BYPASS_CMD_PRCTL:
 -		mode = SPEC_STORE_BYPASS_PRCTL;
 -		break;
 -	case SPEC_STORE_BYPASS_CMD_NONE:
 +	case SPECTRE_V2_CMD_IBRS:
 +		if (spec_ctrl_force_enable_ibrs())
 +			return;
  		break;
 -	}
 -
 -	/*
 -	 * We have three CPU feature flags that are in play here:
 -	 *  - X86_BUG_SPEC_STORE_BYPASS - CPU is susceptible.
 -	 *  - X86_FEATURE_SSBD - CPU is able to turn off speculative store bypass
 -	 *  - X86_FEATURE_SPEC_STORE_BYPASS_DISABLE - engage the mitigation
 -	 */
 -	if (mode == SPEC_STORE_BYPASS_DISABLE) {
 -		setup_force_cpu_cap(X86_FEATURE_SPEC_STORE_BYPASS_DISABLE);
 -		/*
 -		 * Intel uses the SPEC CTRL MSR Bit(2) for this, while AMD may
 -		 * use a completely different MSR and bit dependent on family.
 -		 */
 -		if (!static_cpu_has(X86_FEATURE_MSR_SPEC_CTRL))
 -			x86_amd_ssb_disable();
 -		else {
 -			x86_spec_ctrl_base |= SPEC_CTRL_SSBD;
 -			x86_spec_ctrl_mask |= SPEC_CTRL_SSBD;
 -			wrmsrl(MSR_IA32_SPEC_CTRL, x86_spec_ctrl_base);
 -		}
 -	}
 -
 -	return mode;
 -}
  
 -static void ssb_select_mitigation(void)
 -{
 -	ssb_mode = __ssb_select_mitigation();
 -
 -	if (boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS))
 -		pr_info("%s\n", ssb_strings[ssb_mode]);
 -}
 -
 -#undef pr_fmt
 -#define pr_fmt(fmt)     "Speculation prctl: " fmt
 -
 -static int ssb_prctl_set(struct task_struct *task, unsigned long ctrl)
 -{
 -	bool update;
 -
 -	if (ssb_mode != SPEC_STORE_BYPASS_PRCTL &&
 -	    ssb_mode != SPEC_STORE_BYPASS_SECCOMP)
 -		return -ENXIO;
 -
 -	switch (ctrl) {
 -	case PR_SPEC_ENABLE:
 -		/* If speculation is force disabled, enable is not allowed */
 -		if (task_spec_ssb_force_disable(task))
 -			return -EPERM;
 -		task_clear_spec_ssb_disable(task);
 -		update = test_and_clear_tsk_thread_flag(task, TIF_SSBD);
 +	case SPECTRE_V2_CMD_IBRS_ALWAYS:
 +		if (spec_ctrl_enable_ibrs_always() ||
 +		    spec_ctrl_force_enable_ibp_disabled())
 +			return;
  		break;
 -	case PR_SPEC_DISABLE:
 -		task_set_spec_ssb_disable(task);
 -		update = !test_and_set_tsk_thread_flag(task, TIF_SSBD);
 -		break;
 -	case PR_SPEC_FORCE_DISABLE:
 -		task_set_spec_ssb_disable(task);
 -		task_set_spec_ssb_force_disable(task);
 -		update = !test_and_set_tsk_thread_flag(task, TIF_SSBD);
 +
 +	case SPECTRE_V2_CMD_RETPOLINE_IBRS_USER:
 +		if (spec_ctrl_enable_retpoline_ibrs_user())
 +			return;
  		break;
 -	default:
 -		return -ERANGE;
  	}
  
 -	/*
 -	 * If being set on non-current task, delay setting the CPU
 -	 * mitigation until it is next scheduled.
 -	 */
 -	if (task == current && update)
 -		speculative_store_bypass_update_current();
 +	if (spec_ctrl_cond_enable_ibrs(full_retpoline))
 +		return;
  
 -	return 0;
 -}
 +	if (spec_ctrl_cond_enable_ibp_disabled())
 +		return;
  
 -int arch_prctl_spec_ctrl_set(struct task_struct *task, unsigned long which,
 -			     unsigned long ctrl)
 -{
 -	switch (which) {
 -	case PR_SPEC_STORE_BYPASS:
 -		return ssb_prctl_set(task, ctrl);
 -	default:
 -		return -ENODEV;
 -	}
 +	spec_ctrl_enable_retpoline();
  }
  
 -#ifdef CONFIG_SECCOMP
 -void arch_seccomp_spec_mitigate(struct task_struct *task)
 +void spectre_v2_print_mitigation(void)
  {
 -	if (ssb_mode == SPEC_STORE_BYPASS_SECCOMP)
 -		ssb_prctl_set(task, PR_SPEC_FORCE_DISABLE);
 -}
 -#endif
  
 -static int ssb_prctl_get(struct task_struct *task)
 -{
 -	switch (ssb_mode) {
 -	case SPEC_STORE_BYPASS_DISABLE:
 -		return PR_SPEC_DISABLE;
 -	case SPEC_STORE_BYPASS_SECCOMP:
 -	case SPEC_STORE_BYPASS_PRCTL:
 -		if (task_spec_ssb_force_disable(task))
 -			return PR_SPEC_PRCTL | PR_SPEC_FORCE_DISABLE;
 -		if (task_spec_ssb_disable(task))
 -			return PR_SPEC_PRCTL | PR_SPEC_DISABLE;
 -		return PR_SPEC_PRCTL | PR_SPEC_ENABLE;
 -	default:
 -		if (boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS))
 -			return PR_SPEC_ENABLE;
 -		return PR_SPEC_NOT_AFFECTED;
 -	}
 +	pr_info("%s\n", spectre_v2_strings[spec_ctrl_get_mitigation()]);
  }
  
 -int arch_prctl_spec_ctrl_get(struct task_struct *task, unsigned long which)
 +static void __init spectre_v2_select_mitigation(void)
  {
 -	switch (which) {
 -	case PR_SPEC_STORE_BYPASS:
 -		return ssb_prctl_get(task);
 -	default:
 -		return -ENODEV;
 -	}
 +	spectre_v2_cmd = spectre_v2_parse_cmdline();
 +	__spectre_v2_select_mitigation();
 +	spectre_v2_print_mitigation();
  }
  
 -void x86_spec_ctrl_setup_ap(void)
 -{
 -	if (boot_cpu_has(X86_FEATURE_MSR_SPEC_CTRL))
 -		wrmsrl(MSR_IA32_SPEC_CTRL, x86_spec_ctrl_base);
 -
 -	if (ssb_mode == SPEC_STORE_BYPASS_DISABLE)
 -		x86_amd_ssb_disable();
 -}
 +#undef pr_fmt
  
+ #undef pr_fmt
+ #define pr_fmt(fmt)	"L1TF: " fmt
+ static void __init l1tf_select_mitigation(void)
+ {
+ 	u64 half_pa;
+ 
+ 	if (!boot_cpu_has_bug(X86_BUG_L1TF))
+ 		return;
+ 
+ #if CONFIG_PGTABLE_LEVELS == 2
+ 	pr_warn("Kernel not compiled for PAE. No mitigation for L1TF\n");
+ 	return;
+ #endif
+ 
+ 	/*
+ 	 * This is extremely unlikely to happen because almost all
+ 	 * systems have far more MAX_PA/2 than RAM can be fit into
+ 	 * DIMM slots.
+ 	 */
+ 	half_pa = (u64)l1tf_pfn_limit() << PAGE_SHIFT;
+ 	if (e820__mapped_any(half_pa, ULLONG_MAX - half_pa, E820_TYPE_RAM)) {
+ 		pr_warn("System has more than MAX_PA/2 memory. L1TF mitigation not effective.\n");
+ 		return;
+ 	}
+ 
+ 	setup_force_cpu_cap(X86_FEATURE_L1TF_PTEINV);
+ }
+ #undef pr_fmt
+ 
  #ifdef CONFIG_SYSFS
 -
 -static ssize_t cpu_show_common(struct device *dev, struct device_attribute *attr,
 -			       char *buf, unsigned int bug)
 +ssize_t cpu_show_meltdown(struct device *dev,
 +			  struct device_attribute *attr, char *buf)
  {
 -	if (!boot_cpu_has_bug(bug))
 +	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD)
  		return sprintf(buf, "Not affected\n");
 -
 -	switch (bug) {
 -	case X86_BUG_CPU_MELTDOWN:
 -		if (boot_cpu_has(X86_FEATURE_PTI))
 -			return sprintf(buf, "Mitigation: PTI\n");
 -
 -		break;
 -
 -	case X86_BUG_SPECTRE_V1:
 -		return sprintf(buf, "Mitigation: __user pointer sanitization\n");
 -
 -	case X86_BUG_SPECTRE_V2:
 -		return sprintf(buf, "%s%s%s%s\n", spectre_v2_strings[spectre_v2_enabled],
 -			       boot_cpu_has(X86_FEATURE_USE_IBPB) ? ", IBPB" : "",
 -			       boot_cpu_has(X86_FEATURE_USE_IBRS_FW) ? ", IBRS_FW" : "",
 -			       spectre_v2_module_string());
 -
 -	case X86_BUG_SPEC_STORE_BYPASS:
 -		return sprintf(buf, "%s\n", ssb_strings[ssb_mode]);
 -
 -	case X86_BUG_L1TF:
 -		if (boot_cpu_has(X86_FEATURE_L1TF_PTEINV))
 -			return sprintf(buf, "Mitigation: Page Table Inversion\n");
 -		break;
 -
 -	default:
 -		break;
 -	}
 -
 +	if (kaiser_enabled)
 +		return sprintf(buf, "Mitigation: PTI\n");
  	return sprintf(buf, "Vulnerable\n");
  }
  
* Unmerged path arch/x86/kernel/cpu/bugs.c
