nfp: flower: remove headroom from max MTU calculation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
commit df13c59b54a9f8d3e20a2fb565d54eee8dac8768
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/df13c59b.failed

Since commit 29a5dcae2790 ("nfp: flower: offload phys port MTU change") we
take encapsulation headroom into account when calculating the max allowed
MTU.  This is unnecessary as the max MTU advertised by firmware should have
already accounted for encap headroom.

Subtracting headroom twice brings the max MTU below what's necessary for
some deployments.

Fixes: 29a5dcae2790 ("nfp: flower: offload phys port MTU change")
	Signed-off-by: Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
	Reviewed-by: John Hurley <john.hurley@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit df13c59b54a9f8d3e20a2fb565d54eee8dac8768)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/flower/main.c
diff --cc drivers/net/ethernet/netronome/nfp/flower/main.c
index 8fa0cccc6c1f,84e3b9f5abb1..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/main.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/main.c
@@@ -436,6 -557,65 +436,68 @@@ static void nfp_flower_clean(struct nfp
  	app->priv = NULL;
  }
  
++<<<<<<< HEAD
++=======
+ static bool nfp_flower_check_ack(struct nfp_flower_priv *app_priv)
+ {
+ 	bool ret;
+ 
+ 	spin_lock_bh(&app_priv->mtu_conf.lock);
+ 	ret = app_priv->mtu_conf.ack;
+ 	spin_unlock_bh(&app_priv->mtu_conf.lock);
+ 
+ 	return ret;
+ }
+ 
+ static int
+ nfp_flower_repr_change_mtu(struct nfp_app *app, struct net_device *netdev,
+ 			   int new_mtu)
+ {
+ 	struct nfp_flower_priv *app_priv = app->priv;
+ 	struct nfp_repr *repr = netdev_priv(netdev);
+ 	int err, ack;
+ 
+ 	/* Only need to config FW for physical port MTU change. */
+ 	if (repr->port->type != NFP_PORT_PHYS_PORT)
+ 		return 0;
+ 
+ 	if (!(app_priv->flower_ext_feats & NFP_FL_NBI_MTU_SETTING)) {
+ 		nfp_err(app->cpp, "Physical port MTU setting not supported\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	spin_lock_bh(&app_priv->mtu_conf.lock);
+ 	app_priv->mtu_conf.ack = false;
+ 	app_priv->mtu_conf.requested_val = new_mtu;
+ 	app_priv->mtu_conf.portnum = repr->dst->u.port_info.port_id;
+ 	spin_unlock_bh(&app_priv->mtu_conf.lock);
+ 
+ 	err = nfp_flower_cmsg_portmod(repr, netif_carrier_ok(netdev), new_mtu,
+ 				      true);
+ 	if (err) {
+ 		spin_lock_bh(&app_priv->mtu_conf.lock);
+ 		app_priv->mtu_conf.requested_val = 0;
+ 		spin_unlock_bh(&app_priv->mtu_conf.lock);
+ 		return err;
+ 	}
+ 
+ 	/* Wait for fw to ack the change. */
+ 	ack = wait_event_timeout(app_priv->mtu_conf.wait_q,
+ 				 nfp_flower_check_ack(app_priv),
+ 				 msecs_to_jiffies(10));
+ 
+ 	if (!ack) {
+ 		spin_lock_bh(&app_priv->mtu_conf.lock);
+ 		app_priv->mtu_conf.requested_val = 0;
+ 		spin_unlock_bh(&app_priv->mtu_conf.lock);
+ 		nfp_warn(app->cpp, "MTU change not verified with fw\n");
+ 		return -EIO;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> df13c59b54a9 (nfp: flower: remove headroom from max MTU calculation)
  static int nfp_flower_start(struct nfp_app *app)
  {
  	return nfp_tunnel_config_start(app);
@@@ -456,6 -638,8 +518,11 @@@ const struct nfp_app_type app_flower = 
  	.init		= nfp_flower_init,
  	.clean		= nfp_flower_clean,
  
++<<<<<<< HEAD
++=======
+ 	.repr_change_mtu  = nfp_flower_repr_change_mtu,
+ 
++>>>>>>> df13c59b54a9 (nfp: flower: remove headroom from max MTU calculation)
  	.vnic_alloc	= nfp_flower_vnic_alloc,
  	.vnic_init	= nfp_flower_vnic_init,
  	.vnic_clean	= nfp_flower_vnic_clean,
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/main.c
