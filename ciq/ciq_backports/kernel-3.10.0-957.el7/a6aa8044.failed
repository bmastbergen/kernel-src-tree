ip6_tunnel: fix IFLA_MTU ignored on NEWLINK

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit a6aa80446234ec0ad38eecdb8efc59e91daae565
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/a6aa8044.failed

Commit 128bb975dc3c ("ip6_gre: init dev->mtu and dev->hard_header_len
correctly") fixed IFLA_MTU ignored on NEWLINK for ip6_gre. The same
mtu fix is also needed for ip6_tunnel.

Note that dev->hard_header_len setting for ip6_tunnel works fine,
no need to fix it.

	Reported-by: Jianlin Shi <jishi@redhat.com>
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a6aa80446234ec0ad38eecdb8efc59e91daae565)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_tunnel.c
diff --cc net/ipv6/ip6_tunnel.c
index a12e6c346803,6e0f21eed88a..000000000000
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@@ -1758,19 -1938,78 +1758,39 @@@ static void ip6_tnl_netlink_parms(struc
  }
  
  static int ip6_tnl_newlink(struct net *src_net, struct net_device *dev,
 -			   struct nlattr *tb[], struct nlattr *data[],
 -			   struct netlink_ext_ack *extack)
 +			   struct nlattr *tb[], struct nlattr *data[])
  {
  	struct net *net = dev_net(dev);
++<<<<<<< HEAD
 +	struct ip6_tnl *nt, *t;
 +
 +	nt = netdev_priv(dev);
++=======
+ 	struct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);
+ 	struct ip_tunnel_encap ipencap;
+ 	struct ip6_tnl *nt, *t;
+ 	int err;
+ 
+ 	nt = netdev_priv(dev);
+ 
+ 	if (ip6_tnl_netlink_encap_parms(data, &ipencap)) {
+ 		err = ip6_tnl_encap_setup(nt, &ipencap);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
++>>>>>>> a6aa80446234 (ip6_tunnel: fix IFLA_MTU ignored on NEWLINK)
  	ip6_tnl_netlink_parms(data, &nt->parms);
  
 -	if (nt->parms.collect_md) {
 -		if (rtnl_dereference(ip6n->collect_md_tun))
 -			return -EEXIST;
 -	} else {
 -		t = ip6_tnl_locate(net, &nt->parms, 0);
 -		if (!IS_ERR(t))
 -			return -EEXIST;
 -	}
 +	t = ip6_tnl_locate(net, &nt->parms, 0);
 +	if (!IS_ERR(t))
 +		return -EEXIST;
  
- 	return ip6_tnl_create2(dev);
+ 	err = ip6_tnl_create2(dev);
+ 	if (!err && tb[IFLA_MTU])
+ 		ip6_tnl_change_mtu(dev, nla_get_u32(tb[IFLA_MTU]));
+ 
+ 	return err;
  }
  
  static int ip6_tnl_changelink(struct net_device *dev, struct nlattr *tb[],
* Unmerged path net/ipv6/ip6_tunnel.c
