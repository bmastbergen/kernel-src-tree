s390/sthyi: reorganize sthyi implementation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [s390] sthyi: reorganize sthyi implementation (Hendrik Brueckner) [1519343]
Rebuild_FUZZ: 93.83%
commit-author QingFeng Hao <haoqf@linux.vnet.ibm.com>
commit b7c92f1a4e131e459bcf53a570e7265e5ce64455
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b7c92f1a.failed

As we need to support sthyi instruction on LPAR too, move the common code
to kernel part and kvm related code to intercept.c for better reuse.

	Signed-off-by: QingFeng Hao <haoqf@linux.vnet.ibm.com>
	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit b7c92f1a4e131e459bcf53a570e7265e5ce64455)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kernel/Makefile
#	arch/s390/kernel/sthyi.c
#	arch/s390/kvm/Makefile
#	arch/s390/kvm/intercept.c
#	arch/s390/kvm/kvm-s390.h
diff --cc arch/s390/kernel/Makefile
index 597a10a12dc4,1fefb7f9216f..000000000000
--- a/arch/s390/kernel/Makefile
+++ b/arch/s390/kernel/Makefile
@@@ -26,35 -51,27 +26,40 @@@ CFLAGS_dumpstack.o	+= -fno-optimize-sib
  #
  CFLAGS_ptrace.o		+= -DUTS_MACHINE='"$(UTS_MACHINE)"'
  
 -obj-y	:= traps.o time.o process.o base.o early.o setup.o idle.o vtime.o
 +CFLAGS_sysinfo.o += -Iinclude/math-emu -Iarch/s390/math-emu -w
 +
 +obj-y	:= bitmap.o traps.o time.o process.o base.o early.o setup.o vtime.o
  obj-y	+= processor.o sys_s390.o ptrace.o signal.o cpcmd.o ebcdic.o nmi.o
 -obj-y	+= debug.o irq.o ipl.o dis.o diag.o vdso.o als.o
 +obj-y	+= debug.o irq.o ipl.o dis.o diag.o sclp.o vdso.o
  obj-y	+= sysinfo.o jump_label.o lgr.o os_info.o machine_kexec.o pgm_check.o
++<<<<<<< HEAD
 +obj-y	+= dumpstack.o guarded_storage.o alternative.o
++=======
+ obj-y	+= runtime_instr.o cache.o fpu.o dumpstack.o guarded_storage.o sthyi.o
+ obj-y	+= entry.o reipl.o relocate_kernel.o kdebugfs.o
++>>>>>>> b7c92f1a4e13 (s390/sthyi: reorganize sthyi implementation)
 +
 +obj-y	+= $(if $(CONFIG_64BIT),entry64.o,entry.o)
 +obj-y	+= $(if $(CONFIG_64BIT),reipl64.o,reipl.o)
 +obj-y	+= $(if $(CONFIG_64BIT),relocate_kernel64.o,relocate_kernel.o)
  
 -extra-y				+= head.o head64.o vmlinux.lds
 +extra-y				+= head.o vmlinux.lds
 +extra-y				+= $(if $(CONFIG_64BIT),head64.o,head31.o)
  
 -obj-$(CONFIG_MODULES)		+= module.o
 +obj-$(CONFIG_MODULES)		+= s390_ksyms.o module.o
  obj-$(CONFIG_SMP)		+= smp.o
 -obj-$(CONFIG_SCHED_TOPOLOGY)	+= topology.o
 -obj-$(CONFIG_HIBERNATION)	+= suspend.o swsusp.o
 +obj-$(CONFIG_SCHED_BOOK)	+= topology.o
 +obj-$(CONFIG_HIBERNATION)	+= suspend.o swsusp_asm64.o
  obj-$(CONFIG_AUDIT)		+= audit.o
  compat-obj-$(CONFIG_AUDIT)	+= compat_audit.o
 -obj-$(CONFIG_COMPAT)		+= compat_linux.o compat_signal.o
 -obj-$(CONFIG_COMPAT)		+= compat_wrapper.o $(compat-obj-y)
 -obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
 +obj-$(CONFIG_COMPAT)		+= compat_linux.o compat_signal.o \
 +					compat_wrapper.o compat_exec_domain.o \
 +					$(compat-obj-y)
 +
  obj-$(CONFIG_STACKTRACE)	+= stacktrace.o
  obj-$(CONFIG_KPROBES)		+= kprobes.o
 -obj-$(CONFIG_FUNCTION_TRACER)	+= mcount.o ftrace.o
 +obj-$(CONFIG_FUNCTION_TRACER)	+= $(if $(CONFIG_64BIT),mcount64.o,mcount.o)
 +obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o
  obj-$(CONFIG_CRASH_DUMP)	+= crash_dump.o
  obj-$(CONFIG_UPROBES)		+= uprobes.o
  
diff --cc arch/s390/kvm/Makefile
index 40b4c6470f88,6048b1c6e580..000000000000
--- a/arch/s390/kvm/Makefile
+++ b/arch/s390/kvm/Makefile
@@@ -11,5 -11,7 +11,11 @@@ common-objs = $(KVM)/kvm_main.o $(KVM)/
  
  ccflags-y := -Ivirt/kvm -Iarch/s390/kvm
  
++<<<<<<< HEAD
 +kvm-objs := $(common-objs) kvm-s390.o intercept.o interrupt.o priv.o sigp.o diag.o
++=======
+ kvm-objs := $(common-objs) kvm-s390.o intercept.o interrupt.o priv.o sigp.o
+ kvm-objs += diag.o gaccess.o guestdbg.o vsie.o
+ 
++>>>>>>> b7c92f1a4e13 (s390/sthyi: reorganize sthyi implementation)
  obj-$(CONFIG_KVM) += kvm.o
diff --cc arch/s390/kvm/intercept.c
index 5ee56e5acc23,46adda5e2b2c..000000000000
--- a/arch/s390/kvm/intercept.c
+++ b/arch/s390/kvm/intercept.c
@@@ -16,6 -16,9 +16,12 @@@
  #include <linux/pagemap.h>
  
  #include <asm/kvm_host.h>
++<<<<<<< HEAD
++=======
+ #include <asm/asm-offsets.h>
+ #include <asm/irq.h>
+ #include <asm/sysinfo.h>
++>>>>>>> b7c92f1a4e13 (s390/sthyi: reorganize sthyi implementation)
  
  #include "kvm-s390.h"
  #include "gaccess.h"
@@@ -115,40 -144,323 +121,193 @@@ static int handle_instruction(struct kv
  	return -EOPNOTSUPP;
  }
  
 -static int inject_prog_on_prog_intercept(struct kvm_vcpu *vcpu)
 -{
 -	struct kvm_s390_pgm_info pgm_info = {
 -		.code = vcpu->arch.sie_block->iprcc,
 -		/* the PSW has already been rewound */
 -		.flags = KVM_S390_PGM_FLAGS_NO_REWIND,
 -	};
 -
 -	switch (vcpu->arch.sie_block->iprcc & ~PGM_PER) {
 -	case PGM_AFX_TRANSLATION:
 -	case PGM_ASX_TRANSLATION:
 -	case PGM_EX_TRANSLATION:
 -	case PGM_LFX_TRANSLATION:
 -	case PGM_LSTE_SEQUENCE:
 -	case PGM_LSX_TRANSLATION:
 -	case PGM_LX_TRANSLATION:
 -	case PGM_PRIMARY_AUTHORITY:
 -	case PGM_SECONDARY_AUTHORITY:
 -	case PGM_SPACE_SWITCH:
 -		pgm_info.trans_exc_code = vcpu->arch.sie_block->tecmc;
 -		break;
 -	case PGM_ALEN_TRANSLATION:
 -	case PGM_ALE_SEQUENCE:
 -	case PGM_ASTE_INSTANCE:
 -	case PGM_ASTE_SEQUENCE:
 -	case PGM_ASTE_VALIDITY:
 -	case PGM_EXTENDED_AUTHORITY:
 -		pgm_info.exc_access_id = vcpu->arch.sie_block->eai;
 -		break;
 -	case PGM_ASCE_TYPE:
 -	case PGM_PAGE_TRANSLATION:
 -	case PGM_REGION_FIRST_TRANS:
 -	case PGM_REGION_SECOND_TRANS:
 -	case PGM_REGION_THIRD_TRANS:
 -	case PGM_SEGMENT_TRANSLATION:
 -		pgm_info.trans_exc_code = vcpu->arch.sie_block->tecmc;
 -		pgm_info.exc_access_id  = vcpu->arch.sie_block->eai;
 -		pgm_info.op_access_id  = vcpu->arch.sie_block->oai;
 -		break;
 -	case PGM_MONITOR:
 -		pgm_info.mon_class_nr = vcpu->arch.sie_block->mcn;
 -		pgm_info.mon_code = vcpu->arch.sie_block->tecmc;
 -		break;
 -	case PGM_VECTOR_PROCESSING:
 -	case PGM_DATA:
 -		pgm_info.data_exc_code = vcpu->arch.sie_block->dxc;
 -		break;
 -	case PGM_PROTECTION:
 -		pgm_info.trans_exc_code = vcpu->arch.sie_block->tecmc;
 -		pgm_info.exc_access_id  = vcpu->arch.sie_block->eai;
 -		break;
 -	default:
 -		break;
 -	}
 -
 -	if (vcpu->arch.sie_block->iprcc & PGM_PER) {
 -		pgm_info.per_code = vcpu->arch.sie_block->perc;
 -		pgm_info.per_atmid = vcpu->arch.sie_block->peratmid;
 -		pgm_info.per_address = vcpu->arch.sie_block->peraddr;
 -		pgm_info.per_access_id = vcpu->arch.sie_block->peraid;
 -	}
 -	return kvm_s390_inject_prog_irq(vcpu, &pgm_info);
 -}
 -
 -/*
 - * restore ITDB to program-interruption TDB in guest lowcore
 - * and set TX abort indication if required
 -*/
 -static int handle_itdb(struct kvm_vcpu *vcpu)
 -{
 -	struct kvm_s390_itdb *itdb;
 -	int rc;
 -
 -	if (!IS_TE_ENABLED(vcpu) || !IS_ITDB_VALID(vcpu))
 -		return 0;
 -	if (current->thread.per_flags & PER_FLAG_NO_TE)
 -		return 0;
 -	itdb = (struct kvm_s390_itdb *)vcpu->arch.sie_block->itdba;
 -	rc = write_guest_lc(vcpu, __LC_PGM_TDB, itdb, sizeof(*itdb));
 -	if (rc)
 -		return rc;
 -	memset(itdb, 0, sizeof(*itdb));
 -
 -	return 0;
 -}
 -
 -#define per_event(vcpu) (vcpu->arch.sie_block->iprcc & PGM_PER)
 -
  static int handle_prog(struct kvm_vcpu *vcpu)
  {
 -	psw_t psw;
 -	int rc;
 -
  	vcpu->stat.exit_program_interruption++;
 -
 -	if (guestdbg_enabled(vcpu) && per_event(vcpu)) {
 -		rc = kvm_s390_handle_per_event(vcpu);
 -		if (rc)
 -			return rc;
 -		/* the interrupt might have been filtered out completely */
 -		if (vcpu->arch.sie_block->iprcc == 0)
 -			return 0;
 -	}
 -
  	trace_kvm_s390_intercept_prog(vcpu, vcpu->arch.sie_block->iprcc);
 -	if (vcpu->arch.sie_block->iprcc == PGM_SPECIFICATION) {
 -		rc = read_guest_lc(vcpu, __LC_PGM_NEW_PSW, &psw, sizeof(psw_t));
 -		if (rc)
 -			return rc;
 -		/* Avoid endless loops of specification exceptions */
 -		if (!is_valid_psw(&psw))
 -			return -EOPNOTSUPP;
 -	}
 -	rc = handle_itdb(vcpu);
 -	if (rc)
 -		return rc;
 -
 -	return inject_prog_on_prog_intercept(vcpu);
 +	return kvm_s390_inject_program_int(vcpu, vcpu->arch.sie_block->iprcc);
  }
  
 -/**
 - * handle_external_interrupt - used for external interruption interceptions
 - *
 - * This interception only occurs if the CPUSTAT_EXT_INT bit was set, or if
 - * the new PSW does not have external interrupts disabled. In the first case,
 - * we've got to deliver the interrupt manually, and in the second case, we
 - * drop to userspace to handle the situation there.
 - */
 -static int handle_external_interrupt(struct kvm_vcpu *vcpu)
 +static int handle_instruction_and_prog(struct kvm_vcpu *vcpu)
  {
 -	u16 eic = vcpu->arch.sie_block->eic;
 -	struct kvm_s390_irq irq;
 -	psw_t newpsw;
 -	int rc;
 +	int rc, rc2;
  
 -	vcpu->stat.exit_external_interrupt++;
 +	vcpu->stat.exit_instr_and_program++;
 +	rc = handle_instruction(vcpu);
 +	rc2 = handle_prog(vcpu);
  
 -	rc = read_guest_lc(vcpu, __LC_EXT_NEW_PSW, &newpsw, sizeof(psw_t));
 +	if (rc == -EOPNOTSUPP)
 +		vcpu->arch.sie_block->icptcode = 0x04;
  	if (rc)
  		return rc;
 -	/* We can not handle clock comparator or timer interrupt with bad PSW */
 -	if ((eic == EXT_IRQ_CLK_COMP || eic == EXT_IRQ_CPU_TIMER) &&
 -	    (newpsw.mask & PSW_MASK_EXT))
 -		return -EOPNOTSUPP;
 -
 -	switch (eic) {
 -	case EXT_IRQ_CLK_COMP:
 -		irq.type = KVM_S390_INT_CLOCK_COMP;
 -		break;
 -	case EXT_IRQ_CPU_TIMER:
 -		irq.type = KVM_S390_INT_CPU_TIMER;
 -		break;
 -	case EXT_IRQ_EXTERNAL_CALL:
 -		irq.type = KVM_S390_INT_EXTERNAL_CALL;
 -		irq.u.extcall.code = vcpu->arch.sie_block->extcpuaddr;
 -		rc = kvm_s390_inject_vcpu(vcpu, &irq);
 -		/* ignore if another external call is already pending */
 -		if (rc == -EBUSY)
 -			return 0;
 -		return rc;
 -	default:
 -		return -EOPNOTSUPP;
 -	}
 -
 -	return kvm_s390_inject_vcpu(vcpu, &irq);
 +	return rc2;
  }
  
++<<<<<<< HEAD
 +static const intercept_handler_t intercept_funcs[] = {
 +	[0x00 >> 2] = handle_noop,
 +	[0x04 >> 2] = handle_instruction,
 +	[0x08 >> 2] = handle_prog,
 +	[0x0C >> 2] = handle_instruction_and_prog,
 +	[0x10 >> 2] = handle_noop,
 +	[0x14 >> 2] = handle_noop,
 +	[0x18 >> 2] = handle_noop,
 +	[0x1C >> 2] = kvm_s390_handle_wait,
 +	[0x20 >> 2] = handle_validity,
 +	[0x28 >> 2] = handle_stop,
 +};
++=======
+ /**
+  * Handle MOVE PAGE partial execution interception.
+  *
+  * This interception can only happen for guests with DAT disabled and
+  * addresses that are currently not mapped in the host. Thus we try to
+  * set up the mappings for the corresponding user pages here (or throw
+  * addressing exceptions in case of illegal guest addresses).
+  */
+ static int handle_mvpg_pei(struct kvm_vcpu *vcpu)
+ {
+ 	unsigned long srcaddr, dstaddr;
+ 	int reg1, reg2, rc;
+ 
+ 	kvm_s390_get_regs_rre(vcpu, &reg1, &reg2);
+ 
+ 	/* Make sure that the source is paged-in */
+ 	rc = guest_translate_address(vcpu, vcpu->run->s.regs.gprs[reg2],
+ 				     reg2, &srcaddr, GACC_FETCH);
+ 	if (rc)
+ 		return kvm_s390_inject_prog_cond(vcpu, rc);
+ 	rc = kvm_arch_fault_in_page(vcpu, srcaddr, 0);
+ 	if (rc != 0)
+ 		return rc;
+ 
+ 	/* Make sure that the destination is paged-in */
+ 	rc = guest_translate_address(vcpu, vcpu->run->s.regs.gprs[reg1],
+ 				     reg1, &dstaddr, GACC_STORE);
+ 	if (rc)
+ 		return kvm_s390_inject_prog_cond(vcpu, rc);
+ 	rc = kvm_arch_fault_in_page(vcpu, dstaddr, 1);
+ 	if (rc != 0)
+ 		return rc;
+ 
+ 	kvm_s390_retry_instr(vcpu);
+ 
+ 	return 0;
+ }
+ 
+ static int handle_partial_execution(struct kvm_vcpu *vcpu)
+ {
+ 	vcpu->stat.exit_pei++;
+ 
+ 	if (vcpu->arch.sie_block->ipa == 0xb254)	/* MVPG */
+ 		return handle_mvpg_pei(vcpu);
+ 	if (vcpu->arch.sie_block->ipa >> 8 == 0xae)	/* SIGP */
+ 		return kvm_s390_handle_sigp_pei(vcpu);
+ 
+ 	return -EOPNOTSUPP;
+ }
+ 
+ /*
+  * Handle the sthyi instruction that provides the guest with system
+  * information, like current CPU resources available at each level of
+  * the machine.
+  */
+ int handle_sthyi(struct kvm_vcpu *vcpu)
+ {
+ 	int reg1, reg2, r = 0;
+ 	u64 code, addr, cc = 0, rc = 0;
+ 	struct sthyi_sctns *sctns = NULL;
+ 
+ 	if (!test_kvm_facility(vcpu->kvm, 74))
+ 		return kvm_s390_inject_program_int(vcpu, PGM_OPERATION);
+ 
+ 	/*
+ 	 * STHYI requires extensive locking in the higher hypervisors
+ 	 * and is very computational/memory expensive. Therefore we
+ 	 * ratelimit the executions per VM.
+ 	 */
+ 	if (!__ratelimit(&vcpu->kvm->arch.sthyi_limit)) {
+ 		kvm_s390_retry_instr(vcpu);
+ 		return 0;
+ 	}
+ 
+ 	kvm_s390_get_regs_rre(vcpu, &reg1, &reg2);
+ 	code = vcpu->run->s.regs.gprs[reg1];
+ 	addr = vcpu->run->s.regs.gprs[reg2];
+ 
+ 	vcpu->stat.instruction_sthyi++;
+ 	VCPU_EVENT(vcpu, 3, "STHYI: fc: %llu addr: 0x%016llx", code, addr);
+ 	trace_kvm_s390_handle_sthyi(vcpu, code, addr);
+ 
+ 	if (reg1 == reg2 || reg1 & 1 || reg2 & 1)
+ 		return kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);
+ 
+ 	if (code & 0xffff) {
+ 		cc = 3;
+ 		rc = 4;
+ 		goto out;
+ 	}
+ 
+ 	if (addr & ~PAGE_MASK)
+ 		return kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);
+ 
+ 	sctns = (void *)get_zeroed_page(GFP_KERNEL);
+ 	if (!sctns)
+ 		return -ENOMEM;
+ 
+ 	cc = sthyi_fill(sctns, &rc);
+ 
+ out:
+ 	if (!cc) {
+ 		r = write_guest(vcpu, addr, reg2, sctns, PAGE_SIZE);
+ 		if (r) {
+ 			free_page((unsigned long)sctns);
+ 			return kvm_s390_inject_prog_cond(vcpu, r);
+ 		}
+ 	}
+ 
+ 	free_page((unsigned long)sctns);
+ 	vcpu->run->s.regs.gprs[reg2 + 1] = rc;
+ 	kvm_s390_set_psw_cc(vcpu, cc);
+ 	return r;
+ }
+ 
+ static int handle_operexc(struct kvm_vcpu *vcpu)
+ {
+ 	psw_t oldpsw, newpsw;
+ 	int rc;
+ 
+ 	vcpu->stat.exit_operation_exception++;
+ 	trace_kvm_s390_handle_operexc(vcpu, vcpu->arch.sie_block->ipa,
+ 				      vcpu->arch.sie_block->ipb);
+ 
+ 	if (vcpu->arch.sie_block->ipa == 0xb256)
+ 		return handle_sthyi(vcpu);
+ 
+ 	if (vcpu->arch.sie_block->ipa == 0 && vcpu->kvm->arch.user_instr0)
+ 		return -EOPNOTSUPP;
+ 	rc = read_guest_lc(vcpu, __LC_PGM_NEW_PSW, &newpsw, sizeof(psw_t));
+ 	if (rc)
+ 		return rc;
+ 	/*
+ 	 * Avoid endless loops of operation exceptions, if the pgm new
+ 	 * PSW will cause a new operation exception.
+ 	 * The heuristic checks if the pgm new psw is within 6 bytes before
+ 	 * the faulting psw address (with same DAT, AS settings) and the
+ 	 * new psw is not a wait psw and the fault was not triggered by
+ 	 * problem state.
+ 	 */
+ 	oldpsw = vcpu->arch.sie_block->gpsw;
+ 	if (oldpsw.addr - newpsw.addr <= 6 &&
+ 	    !(newpsw.mask & PSW_MASK_WAIT) &&
+ 	    !(oldpsw.mask & PSW_MASK_PSTATE) &&
+ 	    (newpsw.mask & PSW_MASK_ASC) == (oldpsw.mask & PSW_MASK_ASC) &&
+ 	    (newpsw.mask & PSW_MASK_DAT) == (oldpsw.mask & PSW_MASK_DAT))
+ 		return -EOPNOTSUPP;
+ 
+ 	return kvm_s390_inject_program_int(vcpu, PGM_OPERATION);
+ }
++>>>>>>> b7c92f1a4e13 (s390/sthyi: reorganize sthyi implementation)
  
  int kvm_handle_sie_intercept(struct kvm_vcpu *vcpu)
  {
diff --cc arch/s390/kvm/kvm-s390.h
index dc99f1ca4267,10d65dfbc306..000000000000
--- a/arch/s390/kvm/kvm-s390.h
+++ b/arch/s390/kvm/kvm-s390.h
@@@ -130,14 -196,59 +130,16 @@@ void kvm_s390_deliver_pending_machine_c
  int __must_check kvm_s390_inject_vm(struct kvm *kvm,
  				    struct kvm_s390_interrupt *s390int);
  int __must_check kvm_s390_inject_vcpu(struct kvm_vcpu *vcpu,
 -				      struct kvm_s390_irq *irq);
 -static inline int kvm_s390_inject_prog_irq(struct kvm_vcpu *vcpu,
 -					   struct kvm_s390_pgm_info *pgm_info)
 -{
 -	struct kvm_s390_irq irq = {
 -		.type = KVM_S390_PROGRAM_INT,
 -		.u.pgm = *pgm_info,
 -	};
 -
 -	return kvm_s390_inject_vcpu(vcpu, &irq);
 -}
 -static inline int kvm_s390_inject_program_int(struct kvm_vcpu *vcpu, u16 code)
 -{
 -	struct kvm_s390_irq irq = {
 -		.type = KVM_S390_PROGRAM_INT,
 -		.u.pgm.code = code,
 -	};
 -
 -	return kvm_s390_inject_vcpu(vcpu, &irq);
 -}
 +				      struct kvm_s390_interrupt *s390int);
 +int __must_check kvm_s390_inject_program_int(struct kvm_vcpu *vcpu, u16 code);
 +int __must_check kvm_s390_inject_sigp_stop(struct kvm_vcpu *vcpu, int action);
  struct kvm_s390_interrupt_info *kvm_s390_get_io_int(struct kvm *kvm,
 -						    u64 isc_mask, u32 schid);
 -int kvm_s390_reinject_io_int(struct kvm *kvm,
 -			     struct kvm_s390_interrupt_info *inti);
 -int kvm_s390_mask_adapter(struct kvm *kvm, unsigned int id, bool masked);
 -
 -/* implemented in intercept.c */
 -u8 kvm_s390_get_ilen(struct kvm_vcpu *vcpu);
 -int kvm_handle_sie_intercept(struct kvm_vcpu *vcpu);
 -static inline void kvm_s390_rewind_psw(struct kvm_vcpu *vcpu, int ilen)
 -{
 -	struct kvm_s390_sie_block *sie_block = vcpu->arch.sie_block;
 -
 -	sie_block->gpsw.addr = __rewind_psw(sie_block->gpsw, ilen);
 -}
 -static inline void kvm_s390_forward_psw(struct kvm_vcpu *vcpu, int ilen)
 -{
 -	kvm_s390_rewind_psw(vcpu, -ilen);
 -}
 -static inline void kvm_s390_retry_instr(struct kvm_vcpu *vcpu)
 -{
 -	/* don't inject PER events if we re-execute the instruction */
 -	vcpu->arch.sie_block->icptstatus &= ~0x02;
 -	kvm_s390_rewind_psw(vcpu, kvm_s390_get_ilen(vcpu));
 -}
 +						    u64 cr6, u64 schid);
  
+ int handle_sthyi(struct kvm_vcpu *vcpu);
+ 
  /* implemented in priv.c */
 -int is_valid_psw(psw_t *psw);
 -int kvm_s390_handle_aa(struct kvm_vcpu *vcpu);
  int kvm_s390_handle_b2(struct kvm_vcpu *vcpu);
 -int kvm_s390_handle_e3(struct kvm_vcpu *vcpu);
  int kvm_s390_handle_e5(struct kvm_vcpu *vcpu);
  int kvm_s390_handle_01(struct kvm_vcpu *vcpu);
  int kvm_s390_handle_b9(struct kvm_vcpu *vcpu);
@@@ -147,14 -259,37 +149,18 @@@ int kvm_s390_handle_eb(struct kvm_vcpu 
  
  /* implemented in sigp.c */
  int kvm_s390_handle_sigp(struct kvm_vcpu *vcpu);
++<<<<<<< HEAD
++=======
+ int kvm_s390_handle_sigp_pei(struct kvm_vcpu *vcpu);
++>>>>>>> b7c92f1a4e13 (s390/sthyi: reorganize sthyi implementation)
  
  /* implemented in kvm-s390.c */
 -void kvm_s390_set_tod_clock_ext(struct kvm *kvm,
 -				 const struct kvm_s390_vm_tod_clock *gtod);
 -void kvm_s390_set_tod_clock(struct kvm *kvm, u64 tod);
 -long kvm_arch_fault_in_page(struct kvm_vcpu *vcpu, gpa_t gpa, int writable);
 -int kvm_s390_store_status_unloaded(struct kvm_vcpu *vcpu, unsigned long addr);
 -int kvm_s390_vcpu_store_status(struct kvm_vcpu *vcpu, unsigned long addr);
 -void kvm_s390_vcpu_start(struct kvm_vcpu *vcpu);
 -void kvm_s390_vcpu_stop(struct kvm_vcpu *vcpu);
 -void kvm_s390_vcpu_block(struct kvm_vcpu *vcpu);
 -void kvm_s390_vcpu_unblock(struct kvm_vcpu *vcpu);
 +int kvm_s390_vcpu_store_status(struct kvm_vcpu *vcpu,
 +				 unsigned long addr);
 +void s390_vcpu_block(struct kvm_vcpu *vcpu);
 +void s390_vcpu_unblock(struct kvm_vcpu *vcpu);
  void exit_sie(struct kvm_vcpu *vcpu);
 -void kvm_s390_sync_request(int req, struct kvm_vcpu *vcpu);
 -int kvm_s390_vcpu_setup_cmma(struct kvm_vcpu *vcpu);
 -void kvm_s390_vcpu_unsetup_cmma(struct kvm_vcpu *vcpu);
 -unsigned long kvm_s390_fac_list_mask_size(void);
 -extern unsigned long kvm_s390_fac_list_mask[];
 -void kvm_s390_set_cpu_timer(struct kvm_vcpu *vcpu, __u64 cputm);
 -__u64 kvm_s390_get_cpu_timer(struct kvm_vcpu *vcpu);
 -
 +void exit_sie_sync(struct kvm_vcpu *vcpu);
  /* implemented in diag.c */
  int kvm_s390_handle_diag(struct kvm_vcpu *vcpu);
  
* Unmerged path arch/s390/kernel/sthyi.c
diff --git a/arch/s390/include/asm/sysinfo.h b/arch/s390/include/asm/sysinfo.h
index 52608d46b7e5..5da54ea95213 100644
--- a/arch/s390/include/asm/sysinfo.h
+++ b/arch/s390/include/asm/sysinfo.h
@@ -181,4 +181,5 @@ struct service_level {
 int register_service_level(struct service_level *);
 int unregister_service_level(struct service_level *);
 
+int sthyi_fill(void *dst, u64 *rc);
 #endif /* __ASM_S390_SYSINFO_H */
* Unmerged path arch/s390/kernel/Makefile
* Unmerged path arch/s390/kernel/sthyi.c
* Unmerged path arch/s390/kvm/Makefile
* Unmerged path arch/s390/kvm/intercept.c
* Unmerged path arch/s390/kvm/kvm-s390.h
