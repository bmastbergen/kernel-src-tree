net: manual clean code which call skb_put_[data:zero]

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [usb] manual clean code which call skb_put_(data:zero) (Torez Smith) [1540721]
Rebuild_FUZZ: 91.09%
commit-author yuan linyu <Linyu.Yuan@alcatel-sbell.com.cn>
commit b952f4dff2751252db073c27c0f8a16a416a2ddc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b952f4df.failed

	Signed-off-by: yuan linyu <Linyu.Yuan@alcatel-sbell.com.cn>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b952f4dff2751252db073c27c0f8a16a416a2ddc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/isdn/hysdn/hycapi.c
#	drivers/isdn/i4l/isdn_bsdcomp.c
#	drivers/isdn/i4l/isdn_ppp.c
#	drivers/net/bonding/bond_alb.c
#	drivers/net/caif/caif_hsi.c
#	drivers/net/caif/caif_serial.c
#	drivers/net/caif/caif_spi.c
#	drivers/net/ethernet/nxp/lpc_eth.c
#	drivers/net/ppp/ppp_synctty.c
#	drivers/net/usb/asix_common.c
#	drivers/net/usb/hso.c
#	drivers/net/wireless/libertas/if_sdio.c
#	drivers/net/wireless/quantenna/qtnfmac/qlink_util.h
#	drivers/net/wireless/rsi/rsi_91x_mgmt.c
#	drivers/net/wireless/ti/wlcore/rx.c
#	drivers/nfc/pn533.c
#	drivers/staging/rtl8188eu/core/rtw_recv.c
#	drivers/staging/rtl8192e/rtllib_rx.c
#	drivers/staging/rtl8192e/rtllib_softmac.c
#	drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c
#	drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
#	drivers/staging/rtl8192u/r819xU_cmdpkt.c
#	drivers/staging/rtl8712/rtl8712_recv.c
#	drivers/staging/rtl8723bs/os_dep/recv_linux.c
#	drivers/staging/wlan-ng/hfa384x_usb.c
#	drivers/usb/gadget/f_ncm.c
#	lib/nlattr.c
#	net/hsr/hsr_device.c
#	net/irda/irlap_frame.c
#	net/vmw_vsock/virtio_transport_common.c
#	net/x25/x25_subr.c
diff --cc drivers/isdn/hysdn/hycapi.c
index 00aad10507d8,eac0f51a0f60..000000000000
--- a/drivers/isdn/hysdn/hycapi.c
+++ b/drivers/isdn/hysdn/hycapi.c
@@@ -171,16 -171,16 +171,29 @@@ hycapi_register_internal(struct capi_ct
  		       card->myid);
  		return;
  	}
++<<<<<<< HEAD
 +	memcpy(skb_put(skb, sizeof(__u16)), &len, sizeof(__u16));
 +	memcpy(skb_put(skb, sizeof(__u16)), &appl, sizeof(__u16));
 +	memcpy(skb_put(skb, sizeof(__u8)), &_command, sizeof(_command));
 +	memcpy(skb_put(skb, sizeof(__u8)), &_subcommand, sizeof(_subcommand));
 +	memcpy(skb_put(skb, sizeof(__u16)), &MessageNumber, sizeof(__u16));
 +	memcpy(skb_put(skb, sizeof(__u16)), &MessageBufferSize, sizeof(__u16));
 +	memcpy(skb_put(skb, sizeof(__u16)), &(rp->level3cnt), sizeof(__u16));
 +	memcpy(skb_put(skb, sizeof(__u16)), &(rp->datablkcnt), sizeof(__u16));
 +	memcpy(skb_put(skb, sizeof(__u16)), &(rp->datablklen), sizeof(__u16));
 +	memcpy(skb_put(skb, slen), ExtFeatureDefaults, slen);
++=======
+ 	skb_put_data(skb, &len, sizeof(__u16));
+ 	skb_put_data(skb, &appl, sizeof(__u16));
+ 	skb_put_data(skb, &_command, sizeof(__u8));
+ 	skb_put_data(skb, &_subcommand, sizeof(__u8));
+ 	skb_put_data(skb, &MessageNumber, sizeof(__u16));
+ 	skb_put_data(skb, &MessageBufferSize, sizeof(__u16));
+ 	skb_put_data(skb, &(rp->level3cnt), sizeof(__u16));
+ 	skb_put_data(skb, &(rp->datablkcnt), sizeof(__u16));
+ 	skb_put_data(skb, &(rp->datablklen), sizeof(__u16));
+ 	skb_put_data(skb, ExtFeatureDefaults, slen);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  	hycapi_applications[appl - 1].ctrl_mask |= (1 << (ctrl->cnr - 1));
  	hycapi_send_message(ctrl, skb);
  }
@@@ -279,11 -279,11 +292,19 @@@ static void hycapi_release_internal(str
  		       card->myid);
  		return;
  	}
++<<<<<<< HEAD
 +	memcpy(skb_put(skb, sizeof(__u16)), &len, sizeof(__u16));
 +	memcpy(skb_put(skb, sizeof(__u16)), &appl, sizeof(__u16));
 +	memcpy(skb_put(skb, sizeof(__u8)), &_command, sizeof(_command));
 +	memcpy(skb_put(skb, sizeof(__u8)), &_subcommand, sizeof(_subcommand));
 +	memcpy(skb_put(skb, sizeof(__u16)), &MessageNumber, sizeof(__u16));
++=======
+ 	skb_put_data(skb, &len, sizeof(__u16));
+ 	skb_put_data(skb, &appl, sizeof(__u16));
+ 	skb_put_data(skb, &_command, sizeof(__u8));
+ 	skb_put_data(skb, &_subcommand, sizeof(__u8));
+ 	skb_put_data(skb, &MessageNumber, sizeof(__u16));
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  	hycapi_send_message(ctrl, skb);
  	hycapi_applications[appl - 1].ctrl_mask &= ~(1 << (ctrl->cnr - 1));
  }
diff --cc drivers/isdn/i4l/isdn_bsdcomp.c
index 8837ac5a492d,5b64a1389a7c..000000000000
--- a/drivers/isdn/i4l/isdn_bsdcomp.c
+++ b/drivers/isdn/i4l/isdn_bsdcomp.c
@@@ -472,7 -472,7 +472,11 @@@ static int bsd_compress(void *state, st
  		accm |= ((ent) << bitno);				\
  		do	{						\
  			if (skb_out && skb_tailroom(skb_out) > 0)	\
++<<<<<<< HEAD
 +				*(skb_put(skb_out, 1)) = (unsigned char)(accm >> 24); \
++=======
+ 				skb_put(skb_out, (u8)(accm >> 24));	\
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  			accm <<= 8;					\
  			bitno += 8;					\
  		} while (bitno <= 24);					\
diff --cc drivers/isdn/i4l/isdn_ppp.c
index 8d2de72b972c,88e5a025cea7..000000000000
--- a/drivers/isdn/i4l/isdn_ppp.c
+++ b/drivers/isdn/i4l/isdn_ppp.c
@@@ -2229,8 -2258,7 +2229,12 @@@ static void isdn_ppp_ccp_xmit_reset(str
  
  	/* Now stuff remaining bytes */
  	if (len) {
++<<<<<<< HEAD
 +		p = skb_put(skb, len);
 +		memcpy(p, data, len);
++=======
+ 		skb_put_data(skb, data, len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  	}
  
  	/* skb is now ready for xmit */
diff --cc drivers/net/bonding/bond_alb.c
index dff0f9d536d9,c02cc817a490..000000000000
--- a/drivers/net/bonding/bond_alb.c
+++ b/drivers/net/bonding/bond_alb.c
@@@ -935,8 -935,7 +934,12 @@@ static void alb_send_lp_vid(struct slav
  	if (!skb)
  		return;
  
++<<<<<<< HEAD
 +	data = skb_put(skb, size);
 +	memcpy(data, &pkt, size);
++=======
+ 	skb_put_data(skb, &pkt, size);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  
  	skb_reset_mac_header(skb);
  	skb->network_header = skb->mac_header + ETH_HLEN;
diff --cc drivers/net/caif/caif_hsi.c
index 5e40a8b68cbe,11ba6e3eea22..000000000000
--- a/drivers/net/caif/caif_hsi.c
+++ b/drivers/net/caif/caif_hsi.c
@@@ -454,8 -453,7 +453,12 @@@ static int cfhsi_rx_desc(struct cfhsi_d
  		}
  		caif_assert(skb != NULL);
  
++<<<<<<< HEAD
 +		dst = skb_put(skb, len);
 +		memcpy(dst, pfrm, len);
++=======
+ 		skb_put_data(skb, pfrm, len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  
  		skb->protocol = htons(ETH_P_CAIF);
  		skb_reset_mac_header(skb);
@@@ -585,8 -582,7 +587,12 @@@ static int cfhsi_rx_pld(struct cfhsi_de
  		}
  		caif_assert(skb != NULL);
  
++<<<<<<< HEAD
 +		dst = skb_put(skb, len);
 +		memcpy(dst, pcffrm, len);
++=======
+ 		skb_put_data(skb, pcffrm, len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  
  		skb->protocol = htons(ETH_P_CAIF);
  		skb_reset_mac_header(skb);
diff --cc drivers/net/caif/caif_serial.c
index 77be3cb0b5fe,709838e4c062..000000000000
--- a/drivers/net/caif/caif_serial.c
+++ b/drivers/net/caif/caif_serial.c
@@@ -198,8 -197,7 +197,12 @@@ static void ldisc_receive(struct tty_st
  	skb = netdev_alloc_skb(ser->dev, count+1);
  	if (skb == NULL)
  		return;
++<<<<<<< HEAD
 +	p = skb_put(skb, count);
 +	memcpy(p, data, count);
++=======
+ 	skb_put_data(skb, data, count);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  
  	skb->protocol = htons(ETH_P_CAIF);
  	skb_reset_mac_header(skb);
diff --cc drivers/net/caif/caif_spi.c
index 155db68e13ba,207cb8423de0..000000000000
--- a/drivers/net/caif/caif_spi.c
+++ b/drivers/net/caif/caif_spi.c
@@@ -548,8 -547,7 +547,12 @@@ int cfspi_rxfrm(struct cfspi *cfspi, u
  		skb = netdev_alloc_skb(cfspi->ndev, pkt_len + 1);
  		caif_assert(skb != NULL);
  
++<<<<<<< HEAD
 +		dst = skb_put(skb, pkt_len);
 +		memcpy(dst, src, pkt_len);
++=======
+ 		skb_put_data(skb, src, pkt_len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  		src += pkt_len;
  
  		skb->protocol = htons(ETH_P_CAIF);
diff --cc drivers/net/ethernet/nxp/lpc_eth.c
index 55a5548d6add,08381ef8bdb4..000000000000
--- a/drivers/net/ethernet/nxp/lpc_eth.c
+++ b/drivers/net/ethernet/nxp/lpc_eth.c
@@@ -984,11 -958,10 +983,17 @@@ static int __lpc_handle_recv(struct net
  			if (!skb) {
  				ndev->stats.rx_dropped++;
  			} else {
 +				prdbuf = skb_put(skb, len);
 +
  				/* Copy packet from buffer */
++<<<<<<< HEAD
 +				memcpy(prdbuf, pldat->rx_buff_v +
 +					rxconsidx * ENET_MAXF_SIZE, len);
++=======
+ 				skb_put_data(skb,
+ 					     pldat->rx_buff_v + rxconsidx * ENET_MAXF_SIZE,
+ 					     len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  
  				/* Pass to upper layer */
  				skb->protocol = eth_type_trans(skb, ndev);
diff --cc drivers/net/ppp/ppp_synctty.c
index 0741ba835986,7868c29071d4..000000000000
--- a/drivers/net/ppp/ppp_synctty.c
+++ b/drivers/net/ppp/ppp_synctty.c
@@@ -697,8 -697,7 +697,12 @@@ ppp_sync_input(struct syncppp *ap, cons
  		goto err;
  	}
  
++<<<<<<< HEAD
 +	p = skb_put(skb, count);
 +	memcpy(p, buf, count);
++=======
+ 	skb_put_data(skb, buf, count);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  
  	/* strip address/control field if present */
  	p = skb->data;
diff --cc drivers/net/usb/asix_common.c
index 85e1cd85e99d,7847436c441e..000000000000
--- a/drivers/net/usb/asix_common.c
+++ b/drivers/net/usb/asix_common.c
@@@ -180,8 -166,8 +179,13 @@@ int asix_rx_fixup_internal(struct usbne
  		}
  
  		if (rx->ax_skb) {
++<<<<<<< HEAD
 +			data = skb_put(rx->ax_skb, copy_length);
 +			memcpy(data, skb->data + offset, copy_length);
++=======
+ 			skb_put_data(rx->ax_skb, skb->data + offset,
+ 				     copy_length);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  			if (!rx->remaining)
  				usbnet_skb_return(dev, rx->ax_skb);
  		}
diff --cc drivers/net/usb/hso.c
index ec5c62f43a33,d7a3379ea668..000000000000
--- a/drivers/net/usb/hso.c
+++ b/drivers/net/usb/hso.c
@@@ -910,11 -910,9 +909,17 @@@ static void packetizeRx(struct hso_net 
  
  				/* Copy what we got so far. make room for iphdr
  				 * after tail. */
++<<<<<<< HEAD
 +				tmp_rx_buf =
 +				    skb_put(odev->skb_rx_buf,
 +					    sizeof(struct iphdr));
 +				memcpy(tmp_rx_buf, (char *)&(odev->rx_ip_hdr),
 +				       sizeof(struct iphdr));
++=======
+ 				skb_put_data(odev->skb_rx_buf,
+ 					     (char *)&(odev->rx_ip_hdr),
+ 					     sizeof(struct iphdr));
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  
  				/* ETH_HLEN */
  				odev->rx_buf_size = sizeof(struct iphdr);
@@@ -933,8 -931,9 +938,14 @@@
  			/* Copy the rest of the bytes that are left in the
  			 * buffer into the waiting sk_buf. */
  			/* Make room for temp_bytes after tail. */
++<<<<<<< HEAD
 +			tmp_rx_buf = skb_put(odev->skb_rx_buf, temp_bytes);
 +			memcpy(tmp_rx_buf, ip_pkt + buffer_offset, temp_bytes);
++=======
+ 			skb_put_data(odev->skb_rx_buf,
+ 				     ip_pkt + buffer_offset,
+ 				     temp_bytes);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  
  			odev->rx_buf_missing -= temp_bytes;
  			count -= temp_bytes;
diff --cc drivers/net/wireless/libertas/if_sdio.c
index 45578335e420,2300e796c6ab..000000000000
--- a/drivers/net/wireless/libertas/if_sdio.c
+++ b/drivers/net/wireless/libertas/if_sdio.c
@@@ -242,10 -239,7 +242,9 @@@ static int if_sdio_handle_data(struct i
  {
  	int ret;
  	struct sk_buff *skb;
- 	char *data;
  
 +	lbs_deb_enter(LBS_DEB_SDIO);
 +
  	if (size > MRVDRV_ETH_RX_PACKET_BUFFER_SIZE) {
  		lbs_deb_sdio("response packet too large (%d bytes)\n",
  			(int)size);
@@@ -261,9 -255,7 +260,13 @@@
  
  	skb_reserve(skb, NET_IP_ALIGN);
  
++<<<<<<< HEAD:drivers/net/wireless/libertas/if_sdio.c
 +	data = skb_put(skb, size);
 +
 +	memcpy(data, buffer, size);
++=======
+ 	skb_put_data(skb, buffer, size);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero]):drivers/net/wireless/marvell/libertas/if_sdio.c
  
  	lbs_process_rxed_packet(card->priv, skb);
  
diff --cc drivers/net/wireless/ti/wlcore/rx.c
index 6791a1a6afba,0f15696195f8..000000000000
--- a/drivers/net/wireless/ti/wlcore/rx.c
+++ b/drivers/net/wireless/ti/wlcore/rx.c
@@@ -176,7 -179,7 +175,11 @@@ static int wl1271_rx_handle_data(struc
  	 * packets copy the packets in offset of 2 bytes guarantee IP header
  	 * payload aligned to 4 bytes.
  	 */
++<<<<<<< HEAD
 +	memcpy(buf, data + sizeof(*desc), pkt_data_len);
++=======
+ 	skb_put_data(skb, data + sizeof(*desc), pkt_data_len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  	if (rx_align == WLCORE_RX_BUF_PADDED)
  		skb_pull(skb, RX_BUF_ALIGN);
  
diff --cc drivers/nfc/pn533.c
index 8f6f2baa930d,c05cb637ba92..000000000000
--- a/drivers/nfc/pn533.c
+++ b/drivers/nfc/pn533.c
@@@ -1544,13 -1046,12 +1544,17 @@@ static struct sk_buff *pn533_alloc_poll
  	memcpy(nfcid3, felica, 8);
  
  	/* General bytes */
 -	skb_put_u8(skb, gbytes_len);
 +	*skb_put(skb, 1) = gbytes_len;
  
++<<<<<<< HEAD:drivers/nfc/pn533.c
 +	gb = skb_put(skb, gbytes_len);
 +	memcpy(gb, gbytes, gbytes_len);
++=======
+ 	skb_put_data(skb, gbytes, gbytes_len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero]):drivers/nfc/pn533/pn533.c
  
  	/* Len Tk */
 -	skb_put_u8(skb, 0);
 +	*skb_put(skb, 1) = 0;
  
  	return skb;
  }
diff --cc drivers/staging/rtl8192e/rtllib_rx.c
index a8425d885efb,03a81ba136b2..000000000000
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@@ -777,9 -813,10 +776,13 @@@ static u8 parse_subframe(struct rtllib_
  
  		/* Allocate new skb for releasing to upper layer */
  		sub_skb = dev_alloc_skb(RTLLIB_SKBBUFFER_SIZE);
 -		if (!sub_skb)
 -			return 0;
  		skb_reserve(sub_skb, 12);
++<<<<<<< HEAD
 +		data_ptr = (u8 *)skb_put(sub_skb, skb->len);
 +		memcpy(data_ptr, skb->data, skb->len);
++=======
+ 		skb_put_data(sub_skb, skb->data, skb->len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  		sub_skb->dev = ieee->dev;
  
  		rxb->subframes[0] = sub_skb;
@@@ -788,71 -825,74 +791,133 @@@
  		memcpy(rxb->dst, dst, ETH_ALEN);
  		rxb->subframes[0]->dev = ieee->dev;
  		return 1;
 -	}
 -
 +	} else {
 +		rxb->nr_subframes = 0;
 +		memcpy(rxb->src, src, ETH_ALEN);
 +		memcpy(rxb->dst, dst, ETH_ALEN);
 +		while (skb->len > ETHERNET_HEADER_SIZE) {
 +			/* Offset 12 denote 2 mac address */
 +			nSubframe_Length = *((u16 *)(skb->data + 12));
 +			nSubframe_Length = (nSubframe_Length >> 8) +
 +					   (nSubframe_Length << 8);
 +
++<<<<<<< HEAD
 +			if (skb->len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {
 +				printk(KERN_INFO "%s: A-MSDU parse error!! "
 +				       "pRfd->nTotalSubframe : %d\n",\
 +				       __func__, rxb->nr_subframes);
 +				printk(KERN_INFO "%s: A-MSDU parse error!! "
 +				       "Subframe Length: %d\n", __func__,
 +				       nSubframe_Length);
 +				printk(KERN_INFO "nRemain_Length is %d and "
 +				       "nSubframe_Length is : %d\n", skb->len,
 +				       nSubframe_Length);
 +				printk(KERN_INFO "The Packet SeqNum is %d\n", SeqNum);
++=======
+ 	rxb->nr_subframes = 0;
+ 	memcpy(rxb->src, src, ETH_ALEN);
+ 	memcpy(rxb->dst, dst, ETH_ALEN);
+ 	while (skb->len > ETHERNET_HEADER_SIZE) {
+ 		/* Offset 12 denote 2 mac address */
+ 		nSubframe_Length = *((u16 *)(skb->data + 12));
+ 		nSubframe_Length = (nSubframe_Length >> 8) +
+ 				   (nSubframe_Length << 8);
+ 
+ 		if (skb->len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {
+ 			netdev_info(ieee->dev,
+ 				    "%s: A-MSDU parse error!! pRfd->nTotalSubframe : %d\n",
+ 				    __func__, rxb->nr_subframes);
+ 			netdev_info(ieee->dev,
+ 				    "%s: A-MSDU parse error!! Subframe Length: %d\n",
+ 				    __func__, nSubframe_Length);
+ 			netdev_info(ieee->dev,
+ 				    "nRemain_Length is %d and nSubframe_Length is : %d\n",
+ 				    skb->len, nSubframe_Length);
+ 			netdev_info(ieee->dev,
+ 				    "The Packet SeqNum is %d\n",
+ 				    SeqNum);
+ 			return 0;
+ 		}
+ 
+ 		/* move the data point to data content */
+ 		skb_pull(skb, ETHERNET_HEADER_SIZE);
+ 
+ 		/* altered by clark 3/30/2010
+ 		 * The struct buffer size of the skb indicated to upper layer
+ 		 * must be less than 5000, or the defraged IP datagram
+ 		 * in the IP layer will exceed "ipfrag_high_tresh" and be
+ 		 * discarded. so there must not use the function
+ 		 * "skb_copy" and "skb_clone" for "skb".
+ 		 */
+ 
+ 		/* Allocate new skb for releasing to upper layer */
+ 		sub_skb = dev_alloc_skb(nSubframe_Length + 12);
+ 		if (!sub_skb)
+ 			return 0;
+ 		skb_reserve(sub_skb, 12);
+ 		skb_put_data(sub_skb, skb->data, nSubframe_Length);
+ 
+ 		sub_skb->dev = ieee->dev;
+ 		rxb->subframes[rxb->nr_subframes++] = sub_skb;
+ 		if (rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {
+ 			netdev_dbg(ieee->dev,
+ 				   "ParseSubframe(): Too many Subframes! Packets dropped!\n");
+ 			break;
+ 		}
+ 		skb_pull(skb, nSubframe_Length);
+ 
+ 		if (skb->len != 0) {
+ 			nPadding_Length = 4 - ((nSubframe_Length +
+ 					  ETHERNET_HEADER_SIZE) % 4);
+ 			if (nPadding_Length == 4)
+ 				nPadding_Length = 0;
+ 
+ 			if (skb->len < nPadding_Length)
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  				return 0;
 +			}
 +
 +			/* move the data point to data content */
 +			skb_pull(skb, ETHERNET_HEADER_SIZE);
  
 -			skb_pull(skb, nPadding_Length);
 +			/* altered by clark 3/30/2010
 +			 * The struct buffer size of the skb indicated to upper layer
 +			 * must be less than 5000, or the defraged IP datagram
 +			 * in the IP layer will exceed "ipfrag_high_tresh" and be
 +			 * discarded. so there must not use the function
 +			 * "skb_copy" and "skb_clone" for "skb".
 +			 */
 +
 +			/* Allocate new skb for releasing to upper layer */
 +			sub_skb = dev_alloc_skb(nSubframe_Length + 12);
 +			skb_reserve(sub_skb, 12);
 +			data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
 +			memcpy(data_ptr, skb->data, nSubframe_Length);
 +
 +			sub_skb->dev = ieee->dev;
 +			rxb->subframes[rxb->nr_subframes++] = sub_skb;
 +			if (rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {
 +				RTLLIB_DEBUG_RX("ParseSubframe(): Too many "
 +						"Subframes! Packets dropped!\n");
 +				break;
 +			}
 +			skb_pull(skb, nSubframe_Length);
 +
 +			if (skb->len != 0) {
 +				nPadding_Length = 4 - ((nSubframe_Length +
 +						  ETHERNET_HEADER_SIZE) % 4);
 +				if (nPadding_Length == 4)
 +					nPadding_Length = 0;
 +
 +				if (skb->len < nPadding_Length)
 +					return 0;
 +
 +				skb_pull(skb, nPadding_Length);
 +			}
  		}
 -	}
  
 -	return rxb->nr_subframes;
 +		return rxb->nr_subframes;
 +	}
  }
  
  
diff --cc drivers/staging/rtl8192e/rtllib_softmac.c
index fb67ec36689c,09d2c8649171..000000000000
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@@ -1284,8 -1264,7 +1284,12 @@@ inline struct sk_buff *rtllib_associati
  	hdr->info_element[0].id = MFIE_TYPE_SSID;
  
  	hdr->info_element[0].len = beacon->ssid_len;
++<<<<<<< HEAD
 +	tag = skb_put(skb, beacon->ssid_len);
 +	memcpy(tag, beacon->ssid, beacon->ssid_len);
++=======
+ 	skb_put_data(skb, beacon->ssid, beacon->ssid_len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  
  	tag = skb_put(skb, rate_len);
  
@@@ -1359,8 -1340,7 +1363,12 @@@
  	}
  
  	if (wpa_ie_len) {
++<<<<<<< HEAD
 +		tag = skb_put(skb, ieee->wpa_ie_len);
 +		memcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);
++=======
+ 		skb_put_data(skb, ieee->wpa_ie, ieee->wpa_ie_len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  
  		if (PMKCacheIdx >= 0) {
  			tag = skb_put(skb, 18);
@@@ -1376,13 -1356,13 +1384,18 @@@
  	}
  
  	if (wps_ie_len && ieee->wps_ie) {
++<<<<<<< HEAD
 +		tag = skb_put(skb, wps_ie_len);
 +		memcpy(tag, ieee->wps_ie, wps_ie_len);
++=======
+ 		skb_put_data(skb, ieee->wps_ie, wps_ie_len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  	}
  
- 	tag = skb_put(skb, turbo_info_len);
- 	if (turbo_info_len)
+ 	if (turbo_info_len) {
+ 		tag = skb_put(skb, turbo_info_len);
  		rtllib_TURBO_Info(ieee, &tag);
+ 	}
  
  	if (ieee->pHTInfo->bCurrentHTSupport && ieee->pHTInfo->bEnableHT) {
  		if (ieee->pHTInfo->ePeerHTSpecVer == HT_SPEC_VER_EWC) {
diff --cc drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c
index efcaf2007a93,a4aedb489e92..000000000000
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c
@@@ -854,12 -844,13 +853,16 @@@ u8 parse_subframe(struct sk_buff *skb
  #else
  			/* Allocate new skb for releasing to upper layer */
  			sub_skb = dev_alloc_skb(nSubframe_Length + 12);
 -			if (!sub_skb)
 -				return 0;
  			skb_reserve(sub_skb, 12);
++<<<<<<< HEAD
 +			data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
 +			memcpy(data_ptr,skb->data,nSubframe_Length);
++=======
+ 			skb_put_data(sub_skb, skb->data, nSubframe_Length);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  #endif
  			rxb->subframes[rxb->nr_subframes++] = sub_skb;
 -			if (rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {
 +			if(rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {
  				IEEE80211_DEBUG_RX("ParseSubframe(): Too many Subframes! Packets dropped!\n");
  				break;
  			}
diff --cc drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
index 5ff6803c9763,fe6f38b7ec35..000000000000
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
@@@ -1107,8 -1112,7 +1107,12 @@@ inline struct sk_buff *ieee80211_associ
  	hdr->info_element[0].id = MFIE_TYPE_SSID;
  
  	hdr->info_element[0].len = beacon->ssid_len;
++<<<<<<< HEAD
 +	tag = skb_put(skb, beacon->ssid_len);
 +	memcpy(tag, beacon->ssid, beacon->ssid_len);
++=======
+ 	skb_put_data(skb, beacon->ssid, beacon->ssid_len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  
  	tag = skb_put(skb, rate_len);
  
@@@ -1182,18 -1184,17 +1186,32 @@@
  
  
  	//choose what wpa_supplicant gives to associate.
++<<<<<<< HEAD
 +	tag = skb_put(skb, wpa_ie_len);
 +	if (wpa_ie_len){
 +		memcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);
 +	}
 +
 +	tag = skb_put(skb,wmm_info_len);
 +	if(wmm_info_len) {
 +	  ieee80211_WMM_Info(ieee, &tag);
 +	}
 +#ifdef THOMAS_TURBO
 +	tag = skb_put(skb,turbo_info_len);
 +	if(turbo_info_len) {
++=======
+ 	if (wpa_ie_len) {
+ 		skb_put_data(skb, ieee->wpa_ie, wpa_ie_len);
+ 	}
+ 
+ 	if (wmm_info_len) {
+ 		tag = skb_put(skb, wmm_info_len);
+ 		ieee80211_WMM_Info(ieee, &tag);
+ 	}
+ #ifdef THOMAS_TURBO
+ 	if (turbo_info_len) {
+ 		tag = skb_put(skb, turbo_info_len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  		ieee80211_TURBO_Info(ieee, &tag);
  	}
  #endif
diff --cc drivers/staging/rtl8192u/r819xU_cmdpkt.c
index b755eb46341f,87ab3ba760fc..000000000000
--- a/drivers/staging/rtl8192u/r819xU_cmdpkt.c
+++ b/drivers/staging/rtl8192u/r819xU_cmdpkt.c
@@@ -1,188 -1,64 +1,197 @@@
  /******************************************************************************
 - *
 - *  (c) Copyright 2008, RealTEK Technologies Inc. All Rights Reserved.
 - *
 - *  Module:	r819xusb_cmdpkt.c
 - *		(RTL8190 TX/RX command packet handler Source C File)
 - *
 - *  Note:	The module is responsible for handling TX and RX command packet.
 - *		1. TX : Send set and query configuration command packet.
 - *		2. RX : Receive tx feedback, beacon state, query configuration
 - *			command packet.
 - *
 - *  Function:
 - *
 - *  Export:
 - *
 - *  Abbrev:
 - *
 - *  History:
 - *
 - *	Date		Who		Remark
 - *	05/06/2008	amy		Create initial version porting from
 - *					windows driver.
 - *
 - ******************************************************************************/
 +
 +     (c) Copyright 2008, RealTEK Technologies Inc. All Rights Reserved.
 +
 + Module:	r819xusb_cmdpkt.c	(RTL8190 TX/RX command packet handler Source C File)
 +
 + Note:      The module is responsible for handling TX and RX command packet.
 +			1. TX : Send set and query configuration command packet.
 +			2. RX : Receive tx feedback, beacon state, query configuration
 +				command packet.
 +
 + Function:
 +
 + Export:
 +
 + Abbrev:
 +
 + History:
 +	Data		Who		Remark
 +
 +	05/06/2008  amy		Create initial version porting from windows driver.
 +
 +******************************************************************************/
  #include "r8192U.h"
  #include "r819xU_cmdpkt.h"
 -
 -rt_status SendTxCommandPacket(struct net_device *dev, void *pData, u32 DataLen)
 +/*---------------------------Define Local Constant---------------------------*/
 +/* Debug constant*/
 +#define		CMPK_DEBOUNCE_CNT			1
 +/* 2007/10/24 MH Add for printing a range of data. */
 +#define		CMPK_PRINT(Address)\
 +{\
 +	unsigned char	i;\
 +	u32	temp[10];\
 +	\
 +	memcpy(temp, Address, 40);\
 +	for (i = 0; i <40; i+=4)\
 +		printk("\r\n %08x", temp[i]);\
 +}\
 +/*---------------------------Define functions---------------------------------*/
 +
 +rt_status
 +SendTxCommandPacket(
 +	struct net_device *dev,
 +	void*			pData,
 +	u32				DataLen
 +	)
  {
 +	rt_status	rtStatus = RT_STATUS_SUCCESS;
  	struct r8192_priv   *priv = ieee80211_priv(dev);
  	struct sk_buff	    *skb;
++<<<<<<< HEAD
 +	cb_desc		    *tcb_desc;
 +	unsigned char	    *ptr_buf;
 +	//bool	bLastInitPacket = false;
++=======
+ 	struct cb_desc	    *tcb_desc;
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
 +
 +	//PlatformAcquireSpinLock(Adapter, RT_TX_SPINLOCK);
  
 -	/* Get TCB and local buffer from common pool.
 -	 * (It is shared by CmdQ, MgntQ, and USB coalesce DataQ)
 -	 */
 +	//Get TCB and local buffer from common pool. (It is shared by CmdQ, MgntQ, and USB coalesce DataQ)
  	skb  = dev_alloc_skb(USB_HWDESC_HEADER_LEN + DataLen + 4);
 -	if (!skb)
 -		return RT_STATUS_FAILURE;
 -	memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
 -	tcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
 +	memcpy((unsigned char *)(skb->cb),&dev,sizeof(dev));
 +	tcb_desc = (cb_desc*)(skb->cb + MAX_DEV_ADDR_SIZE);
  	tcb_desc->queue_index = TXCMD_QUEUE;
  	tcb_desc->bCmdOrInit = DESC_PACKET_TYPE_NORMAL;
  	tcb_desc->bLastIniPkt = 0;
  	skb_reserve(skb, USB_HWDESC_HEADER_LEN);
++<<<<<<< HEAD
 +	ptr_buf = skb_put(skb, DataLen);
 +	memcpy(ptr_buf,pData,DataLen);
 +	tcb_desc->txbuf_size= (u16)DataLen;
++=======
+ 	skb_put_data(skb, pData, DataLen);
+ 	tcb_desc->txbuf_size = (u16)DataLen;
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  
 -	if (!priv->ieee80211->check_nic_enough_desc(dev, tcb_desc->queue_index) ||
 -	    (!skb_queue_empty(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index])) ||
 -	    (priv->ieee80211->queue_stop)) {
 -		RT_TRACE(COMP_FIRMWARE, "=== NULL packet ======> tx full!\n");
 -		skb_queue_tail(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index], skb);
 -	} else {
 -		priv->ieee80211->softmac_hard_start_xmit(skb, dev);
 -	}
 +	if(!priv->ieee80211->check_nic_enough_desc(dev,tcb_desc->queue_index)||
 +			(!skb_queue_empty(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index]))||\
 +			(priv->ieee80211->queue_stop) ) {
 +			RT_TRACE(COMP_FIRMWARE,"===================NULL packet==================================> tx full!\n");
 +			skb_queue_tail(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index], skb);
 +		} else {
 +			priv->ieee80211->softmac_hard_start_xmit(skb,dev);
 +		}
  
 -	return RT_STATUS_SUCCESS;
 +	//PlatformReleaseSpinLock(Adapter, RT_TX_SPINLOCK);
 +	return rtStatus;
  }
  
 +/*-----------------------------------------------------------------------------
 + * Function:	cmpk_message_handle_tx()
 + *
 + * Overview:	Driver internal module can call the API to send message to
 + *				firmware side. For example, you can send a debug command packet.
 + *				Or you can send a request for FW to modify RLX4181 LBUS HW bank.
 + *				Otherwise, you can change MAC/PHT/RF register by firmware at
 + *				run time. We do not support message more than one segment now.
 + *
 + * Input:		NONE
 + *
 + * Output:		NONE
 + *
 + * Return:		NONE
 + *
 + * Revised History:
 + *	When		Who		Remark
 + *	05/06/2008	amy		porting from windows code.
 + *
 + *---------------------------------------------------------------------------*/
 + extern	rt_status	cmpk_message_handle_tx(
 +	struct net_device *dev,
 +	u8*	codevirtualaddress,
 +	u32	packettype,
 +	u32	buffer_len)
 +{
 +
 +	bool	    rt_status = true;
 +#ifdef RTL8192U
 +	return rt_status;
 +#else
 +	struct r8192_priv   *priv = ieee80211_priv(dev);
 +	u16		    frag_threshold;
 +	u16		    frag_length, frag_offset = 0;
 +	//u16		    total_size;
 +	//int		    i;
 +
 +	rt_firmware	    *pfirmware = priv->pFirmware;
 +	struct sk_buff	    *skb;
 +	unsigned char	    *seg_ptr;
 +	cb_desc		    *tcb_desc;
 +	u8                  bLastIniPkt;
 +
 +	firmware_init_param(dev);
 +	//Fragmentation might be required
 +	frag_threshold = pfirmware->cmdpacket_frag_thresold;
 +	do {
 +		if((buffer_len - frag_offset) > frag_threshold) {
 +			frag_length = frag_threshold ;
 +			bLastIniPkt = 0;
 +
 +		} else {
 +			frag_length = buffer_len - frag_offset;
 +			bLastIniPkt = 1;
 +
 +		}
 +
 +		/* Allocate skb buffer to contain firmware info and tx descriptor info
 +		 * add 4 to avoid packet appending overflow.
 +		 * */
 +		#ifdef RTL8192U
 +		skb  = dev_alloc_skb(USB_HWDESC_HEADER_LEN + frag_length + 4);
 +		#else
 +		skb  = dev_alloc_skb(frag_length + 4);
 +		#endif
 +		memcpy((unsigned char *)(skb->cb),&dev,sizeof(dev));
 +		tcb_desc = (cb_desc*)(skb->cb + MAX_DEV_ADDR_SIZE);
 +		tcb_desc->queue_index = TXCMD_QUEUE;
 +		tcb_desc->bCmdOrInit = packettype;
 +		tcb_desc->bLastIniPkt = bLastIniPkt;
 +
 +		#ifdef RTL8192U
 +		skb_reserve(skb, USB_HWDESC_HEADER_LEN);
 +		#endif
 +
 +		seg_ptr = skb_put(skb, buffer_len);
 +		/*
 +		 * Transform from little endian to big endian
 +		 * and pending zero
 +		 */
 +		memcpy(seg_ptr,codevirtualaddress,buffer_len);
 +		tcb_desc->txbuf_size= (u16)buffer_len;
 +
 +
 +		if(!priv->ieee80211->check_nic_enough_desc(dev,tcb_desc->queue_index)||
 +			(!skb_queue_empty(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index]))||\
 +			(priv->ieee80211->queue_stop) ) {
 +			RT_TRACE(COMP_FIRMWARE,"=====================================================> tx full!\n");
 +			skb_queue_tail(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index], skb);
 +		} else {
 +			priv->ieee80211->softmac_hard_start_xmit(skb,dev);
 +		}
 +
 +		codevirtualaddress += frag_length;
 +		frag_offset += frag_length;
 +
 +	}while(frag_offset < buffer_len);
 +
 +	return rt_status;
 +
 +
 +#endif
 +}	/* CMPK_Message_Handle_Tx */
 +
  /*-----------------------------------------------------------------------------
   * Function:    cmpk_counttxstatistic()
   *
diff --cc drivers/staging/rtl8712/rtl8712_recv.c
index d59a74aa3048,ea3eb94b28b3..000000000000
--- a/drivers/staging/rtl8712/rtl8712_recv.c
+++ b/drivers/staging/rtl8712/rtl8712_recv.c
@@@ -376,8 -372,7 +376,12 @@@ static int amsdu_to_msdu(struct _adapte
  		if (!sub_skb)
  			break;
  		skb_reserve(sub_skb, 12);
++<<<<<<< HEAD
 +		data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
 +		memcpy(data_ptr, pdata, nSubframe_Length);
++=======
+ 		skb_put_data(sub_skb, pdata, nSubframe_Length);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  		subframes[nr_subframes++] = sub_skb;
  		if (nr_subframes >= MAX_SUBFRAME_COUNT) {
  			netdev_warn(padapter->pnetdev, "r8712u: ParseSubframe(): Too many Subframes! Packets dropped!\n");
diff --cc drivers/staging/wlan-ng/hfa384x_usb.c
index 2cf3c894bbb0,83ea8ab4f2f4..000000000000
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@@ -3626,9 -3528,9 +3626,15 @@@ static void hfa384x_int_rxmonitor(wland
  	}
  
  	/* Copy the 802.11 header to the skb
++<<<<<<< HEAD
 +	   (ctl frames may be less than a full header) */
 +	datap = skb_put(skb, hdrlen);
 +	memcpy(datap, &(rxdesc->frame_control), hdrlen);
++=======
+ 	 * (ctl frames may be less than a full header)
+ 	 */
+ 	skb_put_data(skb, &rxdesc->frame_control, hdrlen);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  
  	/* If any, copy the data from the card to the skb */
  	if (datalen > 0) {
diff --cc drivers/usb/gadget/f_ncm.c
index ee19bc8d0040,24e34cfcb4bd..000000000000
--- a/drivers/usb/gadget/f_ncm.c
+++ b/drivers/usb/gadget/f_ncm.c
@@@ -859,98 -957,237 +859,203 @@@ static int ncm_get_alt(struct usb_funct
  
  	if (intf == ncm->ctrl_id)
  		return 0;
++<<<<<<< HEAD:drivers/usb/gadget/f_ncm.c
 +	return ncm->port.in_ep->driver_data ? 1 : 0;
++=======
+ 	return ncm->port.in_ep->enabled ? 1 : 0;
+ }
+ 
+ static struct sk_buff *package_for_tx(struct f_ncm *ncm)
+ {
+ 	__le16		*ntb_iter;
+ 	struct sk_buff	*skb2 = NULL;
+ 	unsigned	ndp_pad;
+ 	unsigned	ndp_index;
+ 	unsigned	new_len;
+ 
+ 	const struct ndp_parser_opts *opts = ncm->parser_opts;
+ 	const int ndp_align = le16_to_cpu(ntb_parameters.wNdpInAlignment);
+ 	const int dgram_idx_len = 2 * 2 * opts->dgram_item_len;
+ 
+ 	/* Stop the timer */
+ 	hrtimer_try_to_cancel(&ncm->task_timer);
+ 
+ 	ndp_pad = ALIGN(ncm->skb_tx_data->len, ndp_align) -
+ 			ncm->skb_tx_data->len;
+ 	ndp_index = ncm->skb_tx_data->len + ndp_pad;
+ 	new_len = ndp_index + dgram_idx_len + ncm->skb_tx_ndp->len;
+ 
+ 	/* Set the final BlockLength and wNdpIndex */
+ 	ntb_iter = (void *) ncm->skb_tx_data->data;
+ 	/* Increment pointer to BlockLength */
+ 	ntb_iter += 2 + 1 + 1;
+ 	put_ncm(&ntb_iter, opts->block_length, new_len);
+ 	put_ncm(&ntb_iter, opts->ndp_index, ndp_index);
+ 
+ 	/* Set the final NDP wLength */
+ 	new_len = opts->ndp_size +
+ 			(ncm->ndp_dgram_count * dgram_idx_len);
+ 	ncm->ndp_dgram_count = 0;
+ 	/* Increment from start to wLength */
+ 	ntb_iter = (void *) ncm->skb_tx_ndp->data;
+ 	ntb_iter += 2;
+ 	put_unaligned_le16(new_len, ntb_iter);
+ 
+ 	/* Merge the skbs */
+ 	swap(skb2, ncm->skb_tx_data);
+ 	if (ncm->skb_tx_data) {
+ 		dev_consume_skb_any(ncm->skb_tx_data);
+ 		ncm->skb_tx_data = NULL;
+ 	}
+ 
+ 	/* Insert NDP alignment. */
+ 	skb_put_zero(skb2, ndp_pad);
+ 
+ 	/* Copy NTB across. */
+ 	skb_put_data(skb2, ncm->skb_tx_ndp->data, ncm->skb_tx_ndp->len);
+ 	dev_consume_skb_any(ncm->skb_tx_ndp);
+ 	ncm->skb_tx_ndp = NULL;
+ 
+ 	/* Insert zero'd datagram. */
+ 	skb_put_zero(skb2, dgram_idx_len);
+ 
+ 	return skb2;
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero]):drivers/usb/gadget/function/f_ncm.c
  }
  
  static struct sk_buff *ncm_wrap_ntb(struct gether *port,
  				    struct sk_buff *skb)
  {
  	struct f_ncm	*ncm = func_to_ncm(&port->func);
 -	struct sk_buff	*skb2 = NULL;
 +	struct sk_buff	*skb2;
  	int		ncb_len = 0;
 -	__le16		*ntb_data;
 -	__le16		*ntb_ndp;
 -	int		dgram_pad;
 -
 +	__le16		*tmp;
 +	int		div;
 +	int		rem;
 +	int		pad;
 +	int		ndp_align;
 +	int		ndp_pad;
  	unsigned	max_size = ncm->port.fixed_in_len;
  	const struct ndp_parser_opts *opts = ncm->parser_opts;
 -	const int ndp_align = le16_to_cpu(ntb_parameters.wNdpInAlignment);
 -	const int div = le16_to_cpu(ntb_parameters.wNdpInDivisor);
 -	const int rem = le16_to_cpu(ntb_parameters.wNdpInPayloadRemainder);
 -	const int dgram_idx_len = 2 * 2 * opts->dgram_item_len;
 +	unsigned	crc_len = ncm->is_crc ? sizeof(uint32_t) : 0;
 +
 +	div = le16_to_cpu(ntb_parameters.wNdpInDivisor);
 +	rem = le16_to_cpu(ntb_parameters.wNdpInPayloadRemainder);
 +	ndp_align = le16_to_cpu(ntb_parameters.wNdpInAlignment);
  
 -	if (!skb && !ncm->skb_tx_data)
 +	ncb_len += opts->nth_size;
 +	ndp_pad = ALIGN(ncb_len, ndp_align) - ncb_len;
 +	ncb_len += ndp_pad;
 +	ncb_len += opts->ndp_size;
 +	ncb_len += 2 * 2 * opts->dgram_item_len; /* Datagram entry */
 +	ncb_len += 2 * 2 * opts->dgram_item_len; /* Zero datagram entry */
 +	pad = ALIGN(ncb_len, div) + rem - ncb_len;
 +	ncb_len += pad;
 +
 +	if (ncb_len + skb->len + crc_len > max_size) {
 +		dev_kfree_skb_any(skb);
  		return NULL;
 +	}
  
 -	if (skb) {
 -		/* Add the CRC if required up front */
 -		if (ncm->is_crc) {
 -			uint32_t	crc;
 -			__le16		*crc_pos;
 -
 -			crc = ~crc32_le(~0,
 -					skb->data,
 -					skb->len);
 -			crc_pos = skb_put(skb, sizeof(uint32_t));
 -			put_unaligned_le32(crc, crc_pos);
 -		}
 +	skb2 = skb_copy_expand(skb, ncb_len,
 +			       max_size - skb->len - ncb_len - crc_len,
 +			       GFP_ATOMIC);
 +	dev_kfree_skb_any(skb);
 +	if (!skb2)
 +		return NULL;
  
 -		/* If the new skb is too big for the current NCM NTB then
 -		 * set the current stored skb to be sent now and clear it
 -		 * ready for new data.
 -		 * NOTE: Assume maximum align for speed of calculation.
 -		 */
 -		if (ncm->skb_tx_data
 -		    && (ncm->ndp_dgram_count >= TX_MAX_NUM_DPE
 -		    || (ncm->skb_tx_data->len +
 -		    div + rem + skb->len +
 -		    ncm->skb_tx_ndp->len + ndp_align + (2 * dgram_idx_len))
 -		    > max_size)) {
 -			skb2 = package_for_tx(ncm);
 -			if (!skb2)
 -				goto err;
 -		}
 +	skb = skb2;
  
 -		if (!ncm->skb_tx_data) {
 -			ncb_len = opts->nth_size;
 -			dgram_pad = ALIGN(ncb_len, div) + rem - ncb_len;
 -			ncb_len += dgram_pad;
 +	tmp = (void *) skb_push(skb, ncb_len);
 +	memset(tmp, 0, ncb_len);
  
 -			/* Create a new skb for the NTH and datagrams. */
 -			ncm->skb_tx_data = alloc_skb(max_size, GFP_ATOMIC);
 -			if (!ncm->skb_tx_data)
 -				goto err;
 +	put_unaligned_le32(opts->nth_sign, tmp); /* dwSignature */
 +	tmp += 2;
 +	/* wHeaderLength */
 +	put_unaligned_le16(opts->nth_size, tmp++);
 +	tmp++; /* skip wSequence */
 +	put_ncm(&tmp, opts->block_length, skb->len); /* (d)wBlockLength */
 +	/* (d)wFpIndex */
 +	/* the first pointer is right after the NTH + align */
 +	put_ncm(&tmp, opts->fp_index, opts->nth_size + ndp_pad);
  
 -			ncm->skb_tx_data->dev = ncm->netdev;
 -			ntb_data = skb_put_zero(ncm->skb_tx_data, ncb_len);
 -			/* dwSignature */
 -			put_unaligned_le32(opts->nth_sign, ntb_data);
 -			ntb_data += 2;
 -			/* wHeaderLength */
 -			put_unaligned_le16(opts->nth_size, ntb_data++);
 -
 -			/* Allocate an skb for storing the NDP,
 -			 * TX_MAX_NUM_DPE should easily suffice for a
 -			 * 16k packet.
 -			 */
 -			ncm->skb_tx_ndp = alloc_skb((int)(opts->ndp_size
 -						    + opts->dpe_size
 -						    * TX_MAX_NUM_DPE),
 -						    GFP_ATOMIC);
 -			if (!ncm->skb_tx_ndp)
 -				goto err;
 +	tmp = (void *)tmp + ndp_pad;
  
 +	/* NDP */
 +	put_unaligned_le32(ncm->ndp_sign, tmp); /* dwSignature */
 +	tmp += 2;
 +	/* wLength */
 +	put_unaligned_le16(ncb_len - opts->nth_size - pad, tmp++);
 +
 +	tmp += opts->reserved1;
 +	tmp += opts->next_fp_index; /* skip reserved (d)wNextFpIndex */
 +	tmp += opts->reserved2;
 +
 +	if (ncm->is_crc) {
 +		uint32_t crc;
 +
++<<<<<<< HEAD:drivers/usb/gadget/f_ncm.c
 +		crc = ~crc32_le(~0,
 +				skb->data + ncb_len,
 +				skb->len - ncb_len);
 +		put_unaligned_le32(crc, skb->data + skb->len);
 +		skb_put(skb, crc_len);
++=======
+ 			ncm->skb_tx_ndp->dev = ncm->netdev;
+ 			ntb_ndp = skb_put(ncm->skb_tx_ndp, opts->ndp_size);
+ 			memset(ntb_ndp, 0, ncb_len);
+ 			/* dwSignature */
+ 			put_unaligned_le32(ncm->ndp_sign, ntb_ndp);
+ 			ntb_ndp += 2;
+ 
+ 			/* There is always a zeroed entry */
+ 			ncm->ndp_dgram_count = 1;
+ 
+ 			/* Note: we skip opts->next_ndp_index */
+ 		}
+ 
+ 		/* Delay the timer. */
+ 		hrtimer_start(&ncm->task_timer, TX_TIMEOUT_NSECS,
+ 			      HRTIMER_MODE_REL);
+ 
+ 		/* Add the datagram position entries */
+ 		ntb_ndp = skb_put_zero(ncm->skb_tx_ndp, dgram_idx_len);
+ 
+ 		ncb_len = ncm->skb_tx_data->len;
+ 		dgram_pad = ALIGN(ncb_len, div) + rem - ncb_len;
+ 		ncb_len += dgram_pad;
+ 
+ 		/* (d)wDatagramIndex */
+ 		put_ncm(&ntb_ndp, opts->dgram_item_len, ncb_len);
+ 		/* (d)wDatagramLength */
+ 		put_ncm(&ntb_ndp, opts->dgram_item_len, skb->len);
+ 		ncm->ndp_dgram_count++;
+ 
+ 		/* Add the new data to the skb */
+ 		skb_put_zero(ncm->skb_tx_data, dgram_pad);
+ 		skb_put_data(ncm->skb_tx_data, skb->data, skb->len);
+ 		dev_consume_skb_any(skb);
+ 		skb = NULL;
+ 
+ 	} else if (ncm->skb_tx_data && ncm->timer_force_tx) {
+ 		/* If the tx was requested because of a timeout then send */
+ 		skb2 = package_for_tx(ncm);
+ 		if (!skb2)
+ 			goto err;
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero]):drivers/usb/gadget/function/f_ncm.c
  	}
  
 -	return skb2;
 -
 -err:
 -	ncm->netdev->stats.tx_dropped++;
 -
 -	if (skb)
 -		dev_kfree_skb_any(skb);
 -	if (ncm->skb_tx_data)
 -		dev_kfree_skb_any(ncm->skb_tx_data);
 -	if (ncm->skb_tx_ndp)
 -		dev_kfree_skb_any(ncm->skb_tx_ndp);
 -
 -	return NULL;
 -}
 -
 -/*
 - * This transmits the NTB if there are frames waiting.
 - */
 -static void ncm_tx_tasklet(unsigned long data)
 -{
 -	struct f_ncm	*ncm = (void *)data;
 -
 -	if (ncm->timer_stopping)
 -		return;
 -
 -	/* Only send if data is available. */
 -	if (ncm->skb_tx_data) {
 -		ncm->timer_force_tx = true;
 -
 -		/* XXX This allowance of a NULL skb argument to ndo_start_xmit
 -		 * XXX is not sane.  The gadget layer should be redesigned so
 -		 * XXX that the dev->wrap() invocations to build SKBs is transparent
 -		 * XXX and performed in some way outside of the ndo_start_xmit
 -		 * XXX interface.
 -		 */
 -		ncm->netdev->netdev_ops->ndo_start_xmit(NULL, ncm->netdev);
 +	/* (d)wDatagramIndex[0] */
 +	put_ncm(&tmp, opts->dgram_item_len, ncb_len);
 +	/* (d)wDatagramLength[0] */
 +	put_ncm(&tmp, opts->dgram_item_len, skb->len - ncb_len);
 +	/* (d)wDatagramIndex[1] and  (d)wDatagramLength[1] already zeroed */
  
 -		ncm->timer_force_tx = false;
 -	}
 -}
 +	if (skb->len > MAX_TX_NONFIXED)
 +		memset(skb_put(skb, max_size - skb->len),
 +		       0, max_size - skb->len);
  
 -/*
 - * The transmit should only be run if no skb data has been sent
 - * for a certain duration.
 - */
 -static enum hrtimer_restart ncm_tx_timeout(struct hrtimer *data)
 -{
 -	struct f_ncm *ncm = container_of(data, struct f_ncm, task_timer);
 -	tasklet_schedule(&ncm->tx_tasklet);
 -	return HRTIMER_NORESTART;
 +	return skb;
  }
  
  static int ncm_unwrap_ntb(struct gether *port,
diff --cc lib/nlattr.c
index d8994472aae1,fb52435be42d..000000000000
--- a/lib/nlattr.c
+++ b/lib/nlattr.c
@@@ -405,12 -398,7 +405,16 @@@ EXPORT_SYMBOL(__nla_reserve_64bit)
   */
  void *__nla_reserve_nohdr(struct sk_buff *skb, int attrlen)
  {
++<<<<<<< HEAD
 +	void *start;
 +
 +	start = skb_put(skb, NLA_ALIGN(attrlen));
 +	memset(start, 0, NLA_ALIGN(attrlen));
 +
 +	return start;
++=======
+ 	return skb_put_zero(skb, NLA_ALIGN(attrlen));
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  }
  EXPORT_SYMBOL(__nla_reserve_nohdr);
  
diff --cc net/irda/irlap_frame.c
index 9ea0c933b9ff,debda3de4726..000000000000
--- a/net/irda/irlap_frame.c
+++ b/net/irda/irlap_frame.c
@@@ -394,8 -392,7 +394,12 @@@ void irlap_send_discovery_xid_frame(str
  		info[0] = discovery->data.charset;
  
  		len = IRDA_MIN(discovery->name_len, skb_tailroom(tx_skb));
++<<<<<<< HEAD
 +		info = skb_put(tx_skb, len);
 +		memcpy(info, discovery->data.info, len);
++=======
+ 		skb_put_data(tx_skb, discovery->data.info, len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  	}
  	irlap_queue_xmit(self, tx_skb);
  }
@@@ -1237,8 -1213,7 +1240,12 @@@ void irlap_send_test_frame(struct irlap
  	frame->control = TEST_RSP | PF_BIT;
  
  	/* Copy info */
++<<<<<<< HEAD
 +	info = skb_put(tx_skb, cmd->len);
 +	memcpy(info, cmd->data, cmd->len);
++=======
+ 	skb_put_data(tx_skb, cmd->data, cmd->len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  
  	/* Return to sender */
  	irlap_wait_min_turn_around(self, &self->qos_tx);
diff --cc net/vmw_vsock/virtio_transport_common.c
index b1d963c14d24,edba7ab97563..000000000000
--- a/net/vmw_vsock/virtio_transport_common.c
+++ b/net/vmw_vsock/virtio_transport_common.c
@@@ -130,12 -131,10 +129,19 @@@ static struct sk_buff *virtio_transport
  		break;
  	}
  
++<<<<<<< HEAD
 +	t_hdr = skb_put(skb, sizeof(pkt->hdr));
 +	memcpy(t_hdr, &pkt->hdr, sizeof(pkt->hdr));
 +
 +	if (pkt->len) {
 +		payload = skb_put(skb, pkt->len);
 +		memcpy(payload, pkt->buf, pkt->len);
++=======
+ 	skb_put_data(skb, &pkt->hdr, sizeof(pkt->hdr));
+ 
+ 	if (pkt->len) {
+ 		skb_put_data(skb, pkt->buf, pkt->len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  	}
  
  	return skb;
diff --cc net/x25/x25_subr.c
index 5170d52bfd96,db0b1315d577..000000000000
--- a/net/x25/x25_subr.c
+++ b/net/x25/x25_subr.c
@@@ -186,17 -188,14 +186,27 @@@ void x25_write_internal(struct sock *sk
  			*dptr++ = X25_CALL_REQUEST;
  			len     = x25_addr_aton(addresses, &x25->dest_addr,
  						&x25->source_addr);
++<<<<<<< HEAD
 +			dptr    = skb_put(skb, len);
 +			memcpy(dptr, addresses, len);
++=======
+ 			skb_put_data(skb, addresses, len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  			len     = x25_create_facilities(facilities,
  					&x25->facilities,
  					&x25->dte_facilities,
  					x25->neighbour->global_facil_mask);
++<<<<<<< HEAD
 +			dptr    = skb_put(skb, len);
 +			memcpy(dptr, facilities, len);
 +			dptr = skb_put(skb, x25->calluserdata.cudlength);
 +			memcpy(dptr, x25->calluserdata.cuddata,
 +			       x25->calluserdata.cudlength);
++=======
+ 			skb_put_data(skb, facilities, len);
+ 			skb_put_data(skb, x25->calluserdata.cuddata,
+ 				     x25->calluserdata.cudlength);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  			x25->calluserdata.cudlength = 0;
  			break;
  
@@@ -208,17 -207,15 +218,27 @@@
  							&x25->facilities,
  							&x25->dte_facilities,
  							x25->vc_facil_mask);
++<<<<<<< HEAD
 +			dptr    = skb_put(skb, len);
 +			memcpy(dptr, facilities, len);
++=======
+ 			skb_put_data(skb, facilities, len);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  
  			/* fast select with no restriction on response
  				allows call user data. Userland must
  				ensure it is ours and not theirs */
  			if(x25->facilities.reverse & 0x80) {
++<<<<<<< HEAD
 +				dptr = skb_put(skb,
 +					x25->calluserdata.cudlength);
 +				memcpy(dptr, x25->calluserdata.cuddata,
 +				       x25->calluserdata.cudlength);
++=======
+ 				skb_put_data(skb,
+ 					     x25->calluserdata.cuddata,
+ 					     x25->calluserdata.cudlength);
++>>>>>>> b952f4dff275 (net: manual clean code which call skb_put_[data:zero])
  			}
  			x25->calluserdata.cudlength = 0;
  			break;
* Unmerged path drivers/net/wireless/quantenna/qtnfmac/qlink_util.h
* Unmerged path drivers/net/wireless/rsi/rsi_91x_mgmt.c
* Unmerged path drivers/staging/rtl8188eu/core/rtw_recv.c
* Unmerged path drivers/staging/rtl8723bs/os_dep/recv_linux.c
* Unmerged path net/hsr/hsr_device.c
* Unmerged path drivers/isdn/hysdn/hycapi.c
* Unmerged path drivers/isdn/i4l/isdn_bsdcomp.c
* Unmerged path drivers/isdn/i4l/isdn_ppp.c
* Unmerged path drivers/net/bonding/bond_alb.c
* Unmerged path drivers/net/caif/caif_hsi.c
* Unmerged path drivers/net/caif/caif_serial.c
* Unmerged path drivers/net/caif/caif_spi.c
* Unmerged path drivers/net/ethernet/nxp/lpc_eth.c
diff --git a/drivers/net/ethernet/packetengines/hamachi.c b/drivers/net/ethernet/packetengines/hamachi.c
index ccf9923056ed..9d4879f220a4 100644
--- a/drivers/net/ethernet/packetengines/hamachi.c
+++ b/drivers/net/ethernet/packetengines/hamachi.c
@@ -1498,8 +1498,8 @@ static int hamachi_rx(struct net_device *dev)
 					hmp->rx_skbuff[entry]->data, pkt_len);
 				skb_put(skb, pkt_len);
 #else
-				memcpy(skb_put(skb, pkt_len), hmp->rx_ring_dma
-					+ entry*sizeof(*desc), pkt_len);
+				skb_put_data(skb, hmp->rx_ring_dma
+					     + entry*sizeof(*desc), pkt_len);
 #endif
 				pci_dma_sync_single_for_device(hmp->pci_dev,
 							       leXX_to_cpu(hmp->rx_ring[entry].addr),
* Unmerged path drivers/net/ppp/ppp_synctty.c
* Unmerged path drivers/net/usb/asix_common.c
* Unmerged path drivers/net/usb/hso.c
* Unmerged path drivers/net/wireless/libertas/if_sdio.c
* Unmerged path drivers/net/wireless/quantenna/qtnfmac/qlink_util.h
* Unmerged path drivers/net/wireless/rsi/rsi_91x_mgmt.c
* Unmerged path drivers/net/wireless/ti/wlcore/rx.c
* Unmerged path drivers/nfc/pn533.c
* Unmerged path drivers/staging/rtl8188eu/core/rtw_recv.c
* Unmerged path drivers/staging/rtl8192e/rtllib_rx.c
* Unmerged path drivers/staging/rtl8192e/rtllib_softmac.c
* Unmerged path drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c
* Unmerged path drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
* Unmerged path drivers/staging/rtl8192u/r819xU_cmdpkt.c
* Unmerged path drivers/staging/rtl8712/rtl8712_recv.c
* Unmerged path drivers/staging/rtl8723bs/os_dep/recv_linux.c
* Unmerged path drivers/staging/wlan-ng/hfa384x_usb.c
* Unmerged path drivers/usb/gadget/f_ncm.c
* Unmerged path lib/nlattr.c
diff --git a/net/bridge/netfilter/nft_reject_bridge.c b/net/bridge/netfilter/nft_reject_bridge.c
index 2f6ff3e8b316..71cf9c76727b 100644
--- a/net/bridge/netfilter/nft_reject_bridge.c
+++ b/net/bridge/netfilter/nft_reject_bridge.c
@@ -82,7 +82,6 @@ static void nft_reject_br_send_v4_unreach(struct sk_buff *oldskb,
 	struct iphdr *niph;
 	struct icmphdr *icmph;
 	unsigned int len;
-	void *payload;
 	__wsum csum;
 	u8 proto;
 
@@ -126,7 +125,7 @@ static void nft_reject_br_send_v4_unreach(struct sk_buff *oldskb,
 	icmph->type     = ICMP_DEST_UNREACH;
 	icmph->code	= code;
 
-	payload = skb_put_data(nskb, skb_network_header(oldskb), len);
+	skb_put_data(nskb, skb_network_header(oldskb), len);
 
 	csum = csum_partial((void *)icmph, len + sizeof(struct icmphdr), 0);
 	icmph->checksum = csum_fold(csum);
@@ -203,7 +202,6 @@ static void nft_reject_br_send_v6_unreach(struct net *net,
 	struct ipv6hdr *nip6h;
 	struct icmp6hdr *icmp6h;
 	unsigned int len;
-	void *payload;
 
 	if (!nft_bridge_ip6hdr_validate(oldskb))
 		return;
@@ -233,7 +231,7 @@ static void nft_reject_br_send_v6_unreach(struct net *net,
 	icmp6h->icmp6_type = ICMPV6_DEST_UNREACH;
 	icmp6h->icmp6_code = code;
 
-	payload = skb_put_data(nskb, skb_network_header(oldskb), len);
+	skb_put_data(nskb, skb_network_header(oldskb), len);
 	nip6h->payload_len = htons(nskb->len - sizeof(struct ipv6hdr));
 
 	icmp6h->icmp6_cksum =
diff --git a/net/dsa/tag_trailer.c b/net/dsa/tag_trailer.c
index 5fe9444842c5..108cfc7fbb01 100644
--- a/net/dsa/tag_trailer.c
+++ b/net/dsa/tag_trailer.c
@@ -48,8 +48,7 @@ static netdev_tx_t trailer_xmit(struct sk_buff *skb, struct net_device *dev)
 	kfree_skb(skb);
 
 	if (padlen) {
-		u8 *pad = skb_put(nskb, padlen);
-		memset(pad, 0, padlen);
+		skb_put_zero(nskb, padlen);
 	}
 
 	trailer = skb_put(nskb, 4);
* Unmerged path net/hsr/hsr_device.c
* Unmerged path net/irda/irlap_frame.c
diff --git a/net/sctp/sm_make_chunk.c b/net/sctp/sm_make_chunk.c
index 28fbcbab3e6f..11209760211a 100644
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@ -1488,11 +1488,10 @@ void sctp_chunk_put(struct sctp_chunk *ch)
 void *sctp_addto_chunk(struct sctp_chunk *chunk, int len, const void *data)
 {
 	void *target;
-	void *padding;
 	int chunklen = ntohs(chunk->chunk_hdr->length);
 	int padlen = SCTP_PAD4(chunklen) - chunklen;
 
-	padding = skb_put_zero(chunk->skb, padlen);
+	skb_put_zero(chunk->skb, padlen);
 	target = skb_put_data(chunk->skb, data, len);
 
 	/* Adjust the chunk length field.  */
* Unmerged path net/vmw_vsock/virtio_transport_common.c
* Unmerged path net/x25/x25_subr.c
