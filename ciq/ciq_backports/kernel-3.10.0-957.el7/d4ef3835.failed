netfilter: Remove exceptional & on function name

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Arushi Singhal <arushisinghal19971997@gmail.com>
commit d4ef38354120d873f5db14ca6e13d051ef4ab068
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d4ef3835.failed

Remove & from function pointers to conform to the style found elsewhere
in the file. Done using the following semantic patch

// <smpl>
@r@
identifier f;
@@

f(...) { ... }
@@
identifier r.f;
@@

- &f
+ f
// </smpl>

	Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit d4ef38354120d873f5db14ca6e13d051ef4ab068)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/netfilter/nft_fib_ipv4.c
#	net/ipv6/netfilter/nft_fib_ipv6.c
#	net/netfilter/nfnetlink.c
#	net/netfilter/nfnetlink_queue_core.c
#	net/netfilter/nft_exthdr.c
#	net/netfilter/nft_hash.c
#	net/netfilter/nft_numgen.c
#	net/netfilter/nft_queue.c
diff --cc net/netfilter/nfnetlink.c
index 03b05eca74dd,185f9786a5a4..000000000000
--- a/net/netfilter/nfnetlink.c
+++ b/net/netfilter/nfnetlink.c
@@@ -447,28 -497,10 +447,35 @@@ static void nfnetlink_rcv(struct sk_buf
  		return;
  	}
  
++<<<<<<< HEAD
 +	if (nlh->nlmsg_type == NFNL_MSG_BATCH_BEGIN) {
 +		struct nfgenmsg *nfgenmsg;
 +
 +		msglen = NLMSG_ALIGN(nlh->nlmsg_len);
 +		if (msglen > skb->len)
 +			msglen = skb->len;
 +
 +		if (nlh->nlmsg_len < NLMSG_HDRLEN ||
 +		    skb->len < NLMSG_HDRLEN + sizeof(struct nfgenmsg))
 +			return;
 +
 +		nfgenmsg = nlmsg_data(nlh);
 +		skb_pull(skb, msglen);
 +		/* Work around old nft using host byte order */
 +		if (nfgenmsg->res_id == NFNL_SUBSYS_NFTABLES)
 +			res_id = NFNL_SUBSYS_NFTABLES;
 +		else
 +			res_id = ntohs(nfgenmsg->res_id);
 +		nfnetlink_rcv_batch(skb, nlh, res_id);
 +	} else {
 +		netlink_rcv_skb(skb, &nfnetlink_rcv_msg);
 +	}
++=======
+ 	if (nlh->nlmsg_type == NFNL_MSG_BATCH_BEGIN)
+ 		nfnetlink_rcv_skb_batch(skb, nlh);
+ 	else
+ 		netlink_rcv_skb(skb, nfnetlink_rcv_msg);
++>>>>>>> d4ef38354120 (netfilter: Remove exceptional & on function name)
  }
  
  #ifdef CONFIG_MODULES
diff --cc net/netfilter/nfnetlink_queue_core.c
index 619721bf09a3,d09ab49e102a..000000000000
--- a/net/netfilter/nfnetlink_queue_core.c
+++ b/net/netfilter/nfnetlink_queue_core.c
@@@ -994,13 -1213,13 +994,18 @@@ static const struct nla_policy nfqa_cfg
  };
  
  static const struct nf_queue_handler nfqh = {
++<<<<<<< HEAD:net/netfilter/nfnetlink_queue_core.c
 +	.outfn	= &nfqnl_enqueue_packet,
++=======
+ 	.outfn		= nfqnl_enqueue_packet,
+ 	.nf_hook_drop	= nfqnl_nf_hook_drop,
++>>>>>>> d4ef38354120 (netfilter: Remove exceptional & on function name):net/netfilter/nfnetlink_queue.c
  };
  
 -static int nfqnl_recv_config(struct net *net, struct sock *ctnl,
 -			     struct sk_buff *skb, const struct nlmsghdr *nlh,
 -			     const struct nlattr * const nfqa[])
 +static int
 +nfqnl_recv_config(struct sock *ctnl, struct sk_buff *skb,
 +		  const struct nlmsghdr *nlh,
 +		  const struct nlattr * const nfqa[])
  {
  	struct nfgenmsg *nfmsg = nlmsg_data(nlh);
  	u_int16_t queue_num = ntohs(nfmsg->res_id);
diff --cc net/netfilter/nft_exthdr.c
index 47beb3abcc9d,1ec49fe5845f..000000000000
--- a/net/netfilter/nft_exthdr.c
+++ b/net/netfilter/nft_exthdr.c
@@@ -112,9 -210,29 +112,13 @@@ static const struct nft_expr_ops nft_ex
  	.dump		= nft_exthdr_dump,
  };
  
 -static const struct nft_expr_ops *
 -nft_exthdr_select_ops(const struct nft_ctx *ctx,
 -		      const struct nlattr * const tb[])
 -{
 -	u32 op;
 -
 -	if (!tb[NFTA_EXTHDR_OP])
 -		return &nft_exthdr_ipv6_ops;
 -
 -	op = ntohl(nla_get_u32(tb[NFTA_EXTHDR_OP]));
 -	switch (op) {
 -	case NFT_EXTHDR_OP_TCPOPT:
 -		return &nft_exthdr_tcp_ops;
 -	case NFT_EXTHDR_OP_IPV6:
 -		return &nft_exthdr_ipv6_ops;
 -	}
 -
 -	return ERR_PTR(-EOPNOTSUPP);
 -}
 -
  static struct nft_expr_type nft_exthdr_type __read_mostly = {
  	.name		= "exthdr",
++<<<<<<< HEAD
 +	.ops		= &nft_exthdr_ops,
++=======
+ 	.select_ops	= nft_exthdr_select_ops,
++>>>>>>> d4ef38354120 (netfilter: Remove exceptional & on function name)
  	.policy		= nft_exthdr_policy,
  	.maxattr	= NFTA_EXTHDR_MAX,
  	.owner		= THIS_MODULE,
diff --cc net/netfilter/nft_hash.c
index 6fa016564f90,4cfe524d8729..000000000000
--- a/net/netfilter/nft_hash.c
+++ b/net/netfilter/nft_hash.c
@@@ -20,359 -14,219 +20,367 @@@
  #include <linux/netfilter.h>
  #include <linux/netfilter/nf_tables.h>
  #include <net/netfilter/nf_tables.h>
 -#include <net/netfilter/nf_tables_core.h>
 -#include <linux/jhash.h>
  
 -struct nft_jhash {
 -	enum nft_registers      sreg:8;
 -	enum nft_registers      dreg:8;
 -	u8			len;
 -	u32			modulus;
 -	u32			seed;
 -	u32			offset;
 -};
 +/* We target a hash table size of 4, element hint is 75% of final size */
 +#define NFT_HASH_ELEMENT_HINT 3
  
 -static void nft_jhash_eval(const struct nft_expr *expr,
 -			   struct nft_regs *regs,
 -			   const struct nft_pktinfo *pkt)
 -{
 -	struct nft_jhash *priv = nft_expr_priv(expr);
 -	const void *data = &regs->data[priv->sreg];
 -	u32 h;
 +struct nft_hash {
 +	struct rhashtable		ht;
 +	struct delayed_work		gc_work;
 +};
  
 -	h = reciprocal_scale(jhash(data, priv->len, priv->seed), priv->modulus);
 -	regs->data[priv->dreg] = h + priv->offset;
 -}
 +struct nft_hash_elem {
 +	struct rhash_head		node;
 +	struct nft_set_ext		ext;
 +};
  
 -struct nft_symhash {
 -	enum nft_registers      dreg:8;
 -	u32			modulus;
 -	u32			offset;
 +struct nft_hash_cmp_arg {
 +	const struct nft_set		*set;
 +	const u32			*key;
 +	u8				genmask;
  };
  
 -static void nft_symhash_eval(const struct nft_expr *expr,
 -			     struct nft_regs *regs,
 -			     const struct nft_pktinfo *pkt)
 -{
 -	struct nft_symhash *priv = nft_expr_priv(expr);
 -	struct sk_buff *skb = pkt->skb;
 -	u32 h;
 +static const struct rhashtable_params nft_hash_params;
  
 -	h = reciprocal_scale(__skb_get_hash_symmetric(skb), priv->modulus);
 +static inline u32 nft_hash_key(const void *data, u32 len, u32 seed)
 +{
 +	const struct nft_hash_cmp_arg *arg = data;
  
 -	regs->data[priv->dreg] = h + priv->offset;
 +	return jhash(arg->key, len, seed);
  }
  
 -static const struct nla_policy nft_hash_policy[NFTA_HASH_MAX + 1] = {
 -	[NFTA_HASH_SREG]	= { .type = NLA_U32 },
 -	[NFTA_HASH_DREG]	= { .type = NLA_U32 },
 -	[NFTA_HASH_LEN]		= { .type = NLA_U32 },
 -	[NFTA_HASH_MODULUS]	= { .type = NLA_U32 },
 -	[NFTA_HASH_SEED]	= { .type = NLA_U32 },
 -	[NFTA_HASH_OFFSET]	= { .type = NLA_U32 },
 -	[NFTA_HASH_TYPE]	= { .type = NLA_U32 },
 -};
 +static inline u32 nft_hash_obj(const void *data, u32 len, u32 seed)
 +{
 +	const struct nft_hash_elem *he = data;
  
 -static int nft_jhash_init(const struct nft_ctx *ctx,
 -			  const struct nft_expr *expr,
 -			  const struct nlattr * const tb[])
 +	return jhash(nft_set_ext_key(&he->ext), len, seed);
 +}
 +
 +static inline int nft_hash_cmp(struct rhashtable_compare_arg *arg,
 +			       const void *ptr)
  {
 -	struct nft_jhash *priv = nft_expr_priv(expr);
 -	u32 len;
 -	int err;
 +	const struct nft_hash_cmp_arg *x = arg->key;
 +	const struct nft_hash_elem *he = ptr;
 +
 +	if (memcmp(nft_set_ext_key(&he->ext), x->key, x->set->klen))
 +		return 1;
 +	if (nft_set_elem_expired(&he->ext))
 +		return 1;
 +	if (!nft_set_elem_active(&he->ext, x->genmask))
 +		return 1;
 +	return 0;
 +}
  
 -	if (!tb[NFTA_HASH_SREG] ||
 -	    !tb[NFTA_HASH_DREG] ||
 -	    !tb[NFTA_HASH_LEN]  ||
 -	    !tb[NFTA_HASH_MODULUS])
 -		return -EINVAL;
 +static bool nft_hash_lookup(const struct nft_set *set, const u32 *key,
 +			    const struct nft_set_ext **ext)
 +{
 +	struct nft_hash *priv = nft_set_priv(set);
 +	const struct nft_hash_elem *he;
 +	struct nft_hash_cmp_arg arg = {
 +		.genmask = nft_genmask_cur(read_pnet(&set->pnet)),
 +		.set	 = set,
 +		.key	 = key,
 +	};
 +
 +	he = rhashtable_lookup_fast(&priv->ht, &arg, nft_hash_params);
 +	if (he != NULL)
 +		*ext = &he->ext;
 +
 +	return !!he;
 +}
  
 -	if (tb[NFTA_HASH_OFFSET])
 -		priv->offset = ntohl(nla_get_be32(tb[NFTA_HASH_OFFSET]));
 +static bool nft_hash_update(struct nft_set *set, const u32 *key,
 +			    void *(*new)(struct nft_set *,
 +					 const struct nft_expr *,
 +					 struct nft_regs *regs),
 +			    const struct nft_expr *expr,
 +			    struct nft_regs *regs,
 +			    const struct nft_set_ext **ext)
 +{
 +	struct nft_hash *priv = nft_set_priv(set);
 +	struct nft_hash_elem *he;
 +	struct nft_hash_cmp_arg arg = {
 +		.genmask = NFT_GENMASK_ANY,
 +		.set	 = set,
 +		.key	 = key,
 +	};
 +
 +	he = rhashtable_lookup_fast(&priv->ht, &arg, nft_hash_params);
 +	if (he != NULL)
 +		goto out;
 +
 +	he = new(set, expr, regs);
 +	if (he == NULL)
 +		goto err1;
 +	if (rhashtable_lookup_insert_key(&priv->ht, &arg, &he->node,
 +					 nft_hash_params))
 +		goto err2;
 +out:
 +	*ext = &he->ext;
 +	return true;
 +
 +err2:
 +	nft_set_elem_destroy(set, he);
 +err1:
 +	return false;
 +}
  
 -	priv->sreg = nft_parse_register(tb[NFTA_HASH_SREG]);
 -	priv->dreg = nft_parse_register(tb[NFTA_HASH_DREG]);
 +static int nft_hash_insert(const struct nft_set *set,
 +			   const struct nft_set_elem *elem)
 +{
 +	struct nft_hash *priv = nft_set_priv(set);
 +	struct nft_hash_elem *he = elem->priv;
 +	struct nft_hash_cmp_arg arg = {
 +		.genmask = nft_genmask_next(read_pnet(&set->pnet)),
 +		.set	 = set,
 +		.key	 = elem->key.val.data,
 +	};
 +
 +	return rhashtable_lookup_insert_key(&priv->ht, &arg, &he->node,
 +					    nft_hash_params);
 +}
  
 -	err = nft_parse_u32_check(tb[NFTA_HASH_LEN], U8_MAX, &len);
 -	if (err < 0)
 -		return err;
 -	if (len == 0)
 -		return -ERANGE;
 +static void nft_hash_activate(const struct nft_set *set,
 +			      const struct nft_set_elem *elem)
 +{
 +	struct nft_hash_elem *he = elem->priv;
  
 -	priv->len = len;
 +	nft_set_elem_change_active(set, &he->ext);
 +	nft_set_elem_clear_busy(&he->ext);
 +}
  
 -	priv->modulus = ntohl(nla_get_be32(tb[NFTA_HASH_MODULUS]));
 -	if (priv->modulus <= 1)
 -		return -ERANGE;
 +static void *nft_hash_deactivate(const struct nft_set *set,
 +				 const struct nft_set_elem *elem)
 +{
 +	struct nft_hash *priv = nft_set_priv(set);
 +	struct nft_hash_elem *he;
 +	struct nft_hash_cmp_arg arg = {
 +		.genmask = nft_genmask_next(read_pnet(&set->pnet)),
 +		.set	 = set,
 +		.key	 = elem->key.val.data,
 +	};
 +
 +	rcu_read_lock();
 +	he = rhashtable_lookup_fast(&priv->ht, &arg, nft_hash_params);
 +	if (he != NULL) {
 +		if (!nft_set_elem_mark_busy(&he->ext))
 +			nft_set_elem_change_active(set, &he->ext);
 +		else
 +			he = NULL;
 +	}
 +	rcu_read_unlock();
  
 -	if (priv->offset + priv->modulus - 1 < priv->offset)
 -		return -EOVERFLOW;
 +	return he;
 +}
  
 -	if (tb[NFTA_HASH_SEED])
 -		priv->seed = ntohl(nla_get_be32(tb[NFTA_HASH_SEED]));
 -	else
 -		get_random_bytes(&priv->seed, sizeof(priv->seed));
 +static void nft_hash_remove(const struct nft_set *set,
 +			    const struct nft_set_elem *elem)
 +{
 +	struct nft_hash *priv = nft_set_priv(set);
 +	struct nft_hash_elem *he = elem->priv;
  
 -	return nft_validate_register_load(priv->sreg, len) &&
 -	       nft_validate_register_store(ctx, priv->dreg, NULL,
 -					   NFT_DATA_VALUE, sizeof(u32));
 +	rhashtable_remove_fast(&priv->ht, &he->node, nft_hash_params);
  }
  
 -static int nft_symhash_init(const struct nft_ctx *ctx,
 -			    const struct nft_expr *expr,
 -			    const struct nlattr * const tb[])
 +static void nft_hash_walk(const struct nft_ctx *ctx, const struct nft_set *set,
 +			  struct nft_set_iter *iter)
  {
 -	struct nft_symhash *priv = nft_expr_priv(expr);
 +	struct nft_hash *priv = nft_set_priv(set);
 +	struct nft_hash_elem *he;
 +	struct rhashtable_iter hti;
 +	struct nft_set_elem elem;
 +	u8 genmask = nft_genmask_cur(read_pnet(&set->pnet));
 +	int err;
  
 -	if (!tb[NFTA_HASH_DREG]    ||
 -	    !tb[NFTA_HASH_MODULUS])
 -		return -EINVAL;
 +	err = rhashtable_walk_init(&priv->ht, &hti, GFP_KERNEL);
 +	iter->err = err;
 +	if (err)
 +		return;
  
 -	if (tb[NFTA_HASH_OFFSET])
 -		priv->offset = ntohl(nla_get_be32(tb[NFTA_HASH_OFFSET]));
 +	err = rhashtable_walk_start(&hti);
 +	if (err && err != -EAGAIN) {
 +		iter->err = err;
 +		goto out;
 +	}
 +
 +	while ((he = rhashtable_walk_next(&hti))) {
 +		if (IS_ERR(he)) {
 +			err = PTR_ERR(he);
 +			if (err != -EAGAIN) {
 +				iter->err = err;
 +				goto out;
 +			}
  
 -	priv->dreg = nft_parse_register(tb[NFTA_HASH_DREG]);
 +			continue;
 +		}
  
 -	priv->modulus = ntohl(nla_get_be32(tb[NFTA_HASH_MODULUS]));
 -	if (priv->modulus <= 1)
 -		return -ERANGE;
 +		if (iter->count < iter->skip)
 +			goto cont;
 +		if (nft_set_elem_expired(&he->ext))
 +			goto cont;
 +		if (!nft_set_elem_active(&he->ext, genmask))
 +			goto cont;
  
 -	if (priv->offset + priv->modulus - 1 < priv->offset)
 -		return -EOVERFLOW;
 +		elem.priv = he;
  
 -	return nft_validate_register_store(ctx, priv->dreg, NULL,
 -					   NFT_DATA_VALUE, sizeof(u32));
 +		iter->err = iter->fn(ctx, set, iter, &elem);
 +		if (iter->err < 0)
 +			goto out;
 +
 +cont:
 +		iter->count++;
 +	}
 +
 +out:
 +	rhashtable_walk_stop(&hti);
 +	rhashtable_walk_exit(&hti);
  }
  
 -static int nft_jhash_dump(struct sk_buff *skb,
 -			  const struct nft_expr *expr)
 +static void nft_hash_gc(struct work_struct *work)
  {
 -	const struct nft_jhash *priv = nft_expr_priv(expr);
 +	struct nft_set *set;
 +	struct nft_hash_elem *he;
 +	struct nft_hash *priv;
 +	struct nft_set_gc_batch *gcb = NULL;
 +	struct rhashtable_iter hti;
 +	int err;
  
 -	if (nft_dump_register(skb, NFTA_HASH_SREG, priv->sreg))
 -		goto nla_put_failure;
 -	if (nft_dump_register(skb, NFTA_HASH_DREG, priv->dreg))
 -		goto nla_put_failure;
 -	if (nla_put_be32(skb, NFTA_HASH_LEN, htonl(priv->len)))
 -		goto nla_put_failure;
 -	if (nla_put_be32(skb, NFTA_HASH_MODULUS, htonl(priv->modulus)))
 -		goto nla_put_failure;
 -	if (nla_put_be32(skb, NFTA_HASH_SEED, htonl(priv->seed)))
 -		goto nla_put_failure;
 -	if (priv->offset != 0)
 -		if (nla_put_be32(skb, NFTA_HASH_OFFSET, htonl(priv->offset)))
 -			goto nla_put_failure;
 -	if (nla_put_be32(skb, NFTA_HASH_TYPE, htonl(NFT_HASH_JENKINS)))
 -		goto nla_put_failure;
 -	return 0;
 +	priv = container_of(work, struct nft_hash, gc_work.work);
 +	set  = nft_set_container_of(priv);
 +
 +	err = rhashtable_walk_init(&priv->ht, &hti, GFP_KERNEL);
 +	if (err)
 +		goto schedule;
 +
 +	err = rhashtable_walk_start(&hti);
 +	if (err && err != -EAGAIN)
 +		goto out;
 +
 +	while ((he = rhashtable_walk_next(&hti))) {
 +		if (IS_ERR(he)) {
 +			if (PTR_ERR(he) != -EAGAIN)
 +				goto out;
 +			continue;
 +		}
 +
 +		if (!nft_set_elem_expired(&he->ext))
 +			continue;
 +		if (nft_set_elem_mark_busy(&he->ext))
 +			continue;
 +
 +		gcb = nft_set_gc_batch_check(set, gcb, GFP_ATOMIC);
 +		if (gcb == NULL)
 +			goto out;
 +		rhashtable_remove_fast(&priv->ht, &he->node, nft_hash_params);
 +		atomic_dec(&set->nelems);
 +		nft_set_gc_batch_add(gcb, he);
 +	}
 +out:
 +	rhashtable_walk_stop(&hti);
 +	rhashtable_walk_exit(&hti);
 +
 +	nft_set_gc_batch_complete(gcb);
 +schedule:
 +	queue_delayed_work(system_power_efficient_wq, &priv->gc_work,
 +			   nft_set_gc_interval(set));
 +}
  
 -nla_put_failure:
 -	return -1;
 +static unsigned int nft_hash_privsize(const struct nlattr * const nla[])
 +{
 +	return sizeof(struct nft_hash);
  }
  
 -static int nft_symhash_dump(struct sk_buff *skb,
 -			    const struct nft_expr *expr)
 +static const struct rhashtable_params nft_hash_params = {
 +	.head_offset		= offsetof(struct nft_hash_elem, node),
 +	.hashfn			= nft_hash_key,
 +	.obj_hashfn		= nft_hash_obj,
 +	.obj_cmpfn		= nft_hash_cmp,
 +	.automatic_shrinking	= true,
 +};
 +
 +static int nft_hash_init(const struct nft_set *set,
 +			 const struct nft_set_desc *desc,
 +			 const struct nlattr * const tb[])
  {
 -	const struct nft_symhash *priv = nft_expr_priv(expr);
 +	struct nft_hash *priv = nft_set_priv(set);
 +	struct rhashtable_params params = nft_hash_params;
 +	int err;
  
 -	if (nft_dump_register(skb, NFTA_HASH_DREG, priv->dreg))
 -		goto nla_put_failure;
 -	if (nla_put_be32(skb, NFTA_HASH_MODULUS, htonl(priv->modulus)))
 -		goto nla_put_failure;
 -	if (priv->offset != 0)
 -		if (nla_put_be32(skb, NFTA_HASH_OFFSET, htonl(priv->offset)))
 -			goto nla_put_failure;
 -	if (nla_put_be32(skb, NFTA_HASH_TYPE, htonl(NFT_HASH_SYM)))
 -		goto nla_put_failure;
 +	params.nelem_hint = desc->size ?: NFT_HASH_ELEMENT_HINT;
 +	params.key_len	  = set->klen;
 +
 +	err = rhashtable_init(&priv->ht, &params);
 +	if (err < 0)
 +		return err;
 +
 +	INIT_DEFERRABLE_WORK(&priv->gc_work, nft_hash_gc);
 +	if (set->flags & NFT_SET_TIMEOUT)
 +		queue_delayed_work(system_power_efficient_wq, &priv->gc_work,
 +				   nft_set_gc_interval(set));
  	return 0;
 +}
  
 -nla_put_failure:
 -	return -1;
 +static void nft_hash_elem_destroy(void *ptr, void *arg)
 +{
 +	nft_set_elem_destroy((const struct nft_set *)arg, ptr);
  }
  
 -static struct nft_expr_type nft_hash_type;
 -static const struct nft_expr_ops nft_jhash_ops = {
 -	.type		= &nft_hash_type,
 -	.size		= NFT_EXPR_SIZE(sizeof(struct nft_jhash)),
 -	.eval		= nft_jhash_eval,
 -	.init		= nft_jhash_init,
 -	.dump		= nft_jhash_dump,
 -};
 +static void nft_hash_destroy(const struct nft_set *set)
 +{
 +	struct nft_hash *priv = nft_set_priv(set);
  
 -static const struct nft_expr_ops nft_symhash_ops = {
 -	.type		= &nft_hash_type,
 -	.size		= NFT_EXPR_SIZE(sizeof(struct nft_symhash)),
 -	.eval		= nft_symhash_eval,
 -	.init		= nft_symhash_init,
 -	.dump		= nft_symhash_dump,
 -};
 +	cancel_delayed_work_sync(&priv->gc_work);
 +	rhashtable_free_and_destroy(&priv->ht, nft_hash_elem_destroy,
 +				    (void *)set);
 +}
  
 -static const struct nft_expr_ops *
 -nft_hash_select_ops(const struct nft_ctx *ctx,
 -		    const struct nlattr * const tb[])
 +static bool nft_hash_estimate(const struct nft_set_desc *desc, u32 features,
 +			      struct nft_set_estimate *est)
  {
 -	u32 type;
 +	unsigned int esize;
 +
 +	esize = sizeof(struct nft_hash_elem);
 +	if (desc->size) {
 +		est->size = sizeof(struct nft_hash) +
 +			    roundup_pow_of_two(desc->size * 4 / 3) *
 +			    sizeof(struct nft_hash_elem *) +
 +			    desc->size * esize;
 +	} else {
 +		/* Resizing happens when the load drops below 30% or goes
 +		 * above 75%. The average of 52.5% load (approximated by 50%)
 +		 * is used for the size estimation of the hash buckets,
 +		 * meaning we calculate two buckets per element.
 +		 */
 +		est->size = esize + 2 * sizeof(struct nft_hash_elem *);
 +	}
  
 -	if (!tb[NFTA_HASH_TYPE])
 -		return &nft_jhash_ops;
 +	est->class = NFT_SET_CLASS_O_1;
  
 -	type = ntohl(nla_get_be32(tb[NFTA_HASH_TYPE]));
 -	switch (type) {
 -	case NFT_HASH_SYM:
 -		return &nft_symhash_ops;
 -	case NFT_HASH_JENKINS:
 -		return &nft_jhash_ops;
 -	default:
 -		break;
 -	}
 -	return ERR_PTR(-EOPNOTSUPP);
 +	return true;
  }
  
++<<<<<<< HEAD
 +static struct nft_set_ops nft_hash_ops __read_mostly = {
 +	.privsize       = nft_hash_privsize,
 +	.elemsize	= offsetof(struct nft_hash_elem, ext),
 +	.estimate	= nft_hash_estimate,
 +	.init		= nft_hash_init,
 +	.destroy	= nft_hash_destroy,
 +	.insert		= nft_hash_insert,
 +	.activate	= nft_hash_activate,
 +	.deactivate	= nft_hash_deactivate,
 +	.remove		= nft_hash_remove,
 +	.lookup		= nft_hash_lookup,
 +	.update		= nft_hash_update,
 +	.walk		= nft_hash_walk,
 +	.features	= NFT_SET_MAP | NFT_SET_TIMEOUT,
++=======
+ static struct nft_expr_type nft_hash_type __read_mostly = {
+ 	.name		= "hash",
+ 	.select_ops	= nft_hash_select_ops,
+ 	.policy		= nft_hash_policy,
+ 	.maxattr	= NFTA_HASH_MAX,
++>>>>>>> d4ef38354120 (netfilter: Remove exceptional & on function name)
  	.owner		= THIS_MODULE,
  };
  
diff --cc net/netfilter/nft_queue.c
index 61d216eb7917,98613658d4ac..000000000000
--- a/net/netfilter/nft_queue.c
+++ b/net/netfilter/nft_queue.c
@@@ -106,9 -169,35 +106,13 @@@ static const struct nft_expr_ops nft_qu
  	.dump		= nft_queue_dump,
  };
  
 -static const struct nft_expr_ops nft_queue_sreg_ops = {
 -	.type		= &nft_queue_type,
 -	.size		= NFT_EXPR_SIZE(sizeof(struct nft_queue)),
 -	.eval		= nft_queue_sreg_eval,
 -	.init		= nft_queue_sreg_init,
 -	.dump		= nft_queue_sreg_dump,
 -};
 -
 -static const struct nft_expr_ops *
 -nft_queue_select_ops(const struct nft_ctx *ctx,
 -		     const struct nlattr * const tb[])
 -{
 -	if (tb[NFTA_QUEUE_NUM] && tb[NFTA_QUEUE_SREG_QNUM])
 -		return ERR_PTR(-EINVAL);
 -
 -	init_hashrandom(&jhash_initval);
 -
 -	if (tb[NFTA_QUEUE_NUM])
 -		return &nft_queue_ops;
 -
 -	if (tb[NFTA_QUEUE_SREG_QNUM])
 -		return &nft_queue_sreg_ops;
 -
 -	return ERR_PTR(-EINVAL);
 -}
 -
  static struct nft_expr_type nft_queue_type __read_mostly = {
  	.name		= "queue",
++<<<<<<< HEAD
 +	.ops		= &nft_queue_ops,
++=======
+ 	.select_ops	= nft_queue_select_ops,
++>>>>>>> d4ef38354120 (netfilter: Remove exceptional & on function name)
  	.policy		= nft_queue_policy,
  	.maxattr	= NFTA_QUEUE_MAX,
  	.owner		= THIS_MODULE,
* Unmerged path net/ipv4/netfilter/nft_fib_ipv4.c
* Unmerged path net/ipv6/netfilter/nft_fib_ipv6.c
* Unmerged path net/netfilter/nft_numgen.c
diff --git a/net/bridge/netfilter/nft_meta_bridge.c b/net/bridge/netfilter/nft_meta_bridge.c
index 4b901d9f2e7c..c4cf12623f90 100644
--- a/net/bridge/netfilter/nft_meta_bridge.c
+++ b/net/bridge/netfilter/nft_meta_bridge.c
@@ -110,7 +110,7 @@ nft_meta_bridge_select_ops(const struct nft_ctx *ctx,
 static struct nft_expr_type nft_meta_bridge_type __read_mostly = {
 	.family         = NFPROTO_BRIDGE,
 	.name           = "meta",
-	.select_ops     = &nft_meta_bridge_select_ops,
+	.select_ops     = nft_meta_bridge_select_ops,
 	.policy         = nft_meta_policy,
 	.maxattr        = NFTA_META_MAX,
 	.owner          = THIS_MODULE,
* Unmerged path net/ipv4/netfilter/nft_fib_ipv4.c
* Unmerged path net/ipv6/netfilter/nft_fib_ipv6.c
diff --git a/net/netfilter/ipset/ip_set_core.c b/net/netfilter/ipset/ip_set_core.c
index 1b9673fde81c..b42a03988333 100644
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@ -1911,7 +1911,7 @@ static struct nf_sockopt_ops so_set __read_mostly = {
 	.pf		= PF_INET,
 	.get_optmin	= SO_IP_SET,
 	.get_optmax	= SO_IP_SET + 1,
-	.get		= &ip_set_sockfn_get,
+	.get		= ip_set_sockfn_get,
 	.owner		= THIS_MODULE,
 };
 
diff --git a/net/netfilter/ipvs/ip_vs_ctl.c b/net/netfilter/ipvs/ip_vs_ctl.c
index 02409f3ce382..4b6033e3baae 100644
--- a/net/netfilter/ipvs/ip_vs_ctl.c
+++ b/net/netfilter/ipvs/ip_vs_ctl.c
@@ -1763,13 +1763,13 @@ static struct ctl_table vs_vars[] = {
 		.procname	= "sync_version",
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
-		.proc_handler	= &proc_do_sync_mode,
+		.proc_handler	= proc_do_sync_mode,
 	},
 	{
 		.procname	= "sync_ports",
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
-		.proc_handler	= &proc_do_sync_ports,
+		.proc_handler	= proc_do_sync_ports,
 	},
 	{
 		.procname	= "sync_qlen_max",
* Unmerged path net/netfilter/nfnetlink.c
diff --git a/net/netfilter/nfnetlink_log.c b/net/netfilter/nfnetlink_log.c
index 3a3478438bf1..f4b70fa3cd49 100644
--- a/net/netfilter/nfnetlink_log.c
+++ b/net/netfilter/nfnetlink_log.c
@@ -781,7 +781,7 @@ nfulnl_recv_unsupp(struct sock *ctnl, struct sk_buff *skb,
 static struct nf_logger nfulnl_logger __read_mostly = {
 	.name	= "nfnetlink_log",
 	.type	= NF_LOG_TYPE_ULOG,
-	.logfn	= &nfulnl_log_packet,
+	.logfn	= nfulnl_log_packet,
 	.me	= THIS_MODULE,
 };
 
* Unmerged path net/netfilter/nfnetlink_queue_core.c
diff --git a/net/netfilter/nft_ct.c b/net/netfilter/nft_ct.c
index 5fdf4daaefb3..c85c1b35d50d 100644
--- a/net/netfilter/nft_ct.c
+++ b/net/netfilter/nft_ct.c
@@ -465,7 +465,7 @@ nft_ct_select_ops(const struct nft_ctx *ctx,
 
 static struct nft_expr_type nft_ct_type __read_mostly = {
 	.name		= "ct",
-	.select_ops	= &nft_ct_select_ops,
+	.select_ops	= nft_ct_select_ops,
 	.policy		= nft_ct_policy,
 	.maxattr	= NFTA_CT_MAX,
 	.owner		= THIS_MODULE,
* Unmerged path net/netfilter/nft_exthdr.c
* Unmerged path net/netfilter/nft_hash.c
diff --git a/net/netfilter/nft_meta.c b/net/netfilter/nft_meta.c
index 6de814bef12b..3e044a6b4ca4 100644
--- a/net/netfilter/nft_meta.c
+++ b/net/netfilter/nft_meta.c
@@ -410,7 +410,7 @@ nft_meta_select_ops(const struct nft_ctx *ctx,
 
 static struct nft_expr_type nft_meta_type __read_mostly = {
 	.name		= "meta",
-	.select_ops	= &nft_meta_select_ops,
+	.select_ops	= nft_meta_select_ops,
 	.policy		= nft_meta_policy,
 	.maxattr	= NFTA_META_MAX,
 	.owner		= THIS_MODULE,
* Unmerged path net/netfilter/nft_numgen.c
* Unmerged path net/netfilter/nft_queue.c
