xfs, dax: introduce xfs_break_dax_layouts()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit d6dc57e251a43c428a9ee3adb7665543a1a584f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d6dc57e2.failed

xfs_break_dax_layouts(), similar to xfs_break_leased_layouts(), scans
for busy / pinned dax pages and waits for those pages to go idle before
any potential extent unmap operation.

dax_layout_busy_page() handles synchronizing against new page-busy
events (get_user_pages). It invalidates all mappings to trigger the
get_user_pages slow path which will eventually block on the xfs inode
lock held in XFS_MMAPLOCK_EXCL mode. If dax_layout_busy_page() finds a
busy page it returns it for xfs to wait for the page-idle event that
will fire when the page reference count reaches 1 (recall ZONE_DEVICE
pages are idle at count 1, see generic_dax_pagefree()).

While waiting, the XFS_MMAPLOCK_EXCL lock is dropped in order to not
deadlock the process that might be trying to elevate the page count of
more pages before arranging for any of them to go idle. I.e. the typical
case of submitting I/O is that iov_iter_get_pages() elevates the
reference count of all pages in the I/O before starting I/O on the first
page. The process of elevating the reference count of all pages involved
in an I/O may cause faults that need to take XFS_MMAPLOCK_EXCL.

Although XFS_MMAPLOCK_EXCL is dropped while waiting, XFS_IOLOCK_EXCL is
held while sleeping. We need this to prevent starvation of the truncate
path as continuous submission of direct-I/O could starve the truncate
path indefinitely if the lock is dropped.

	Cc: Dave Chinner <david@fromorbit.com>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Reported-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Acked-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit d6dc57e251a43c428a9ee3adb7665543a1a584f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_file.c
diff --cc fs/xfs/xfs_file.c
index cea567087acc,f5695dc314f1..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -902,6 -718,74 +902,77 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ xfs_wait_dax_page(
+ 	struct inode		*inode,
+ 	bool			*did_unlock)
+ {
+ 	struct xfs_inode        *ip = XFS_I(inode);
+ 
+ 	*did_unlock = true;
+ 	xfs_iunlock(ip, XFS_MMAPLOCK_EXCL);
+ 	schedule();
+ 	xfs_ilock(ip, XFS_MMAPLOCK_EXCL);
+ }
+ 
+ static int
+ xfs_break_dax_layouts(
+ 	struct inode		*inode,
+ 	uint			iolock,
+ 	bool			*did_unlock)
+ {
+ 	struct page		*page;
+ 
+ 	ASSERT(xfs_isilocked(XFS_I(inode), XFS_MMAPLOCK_EXCL));
+ 
+ 	page = dax_layout_busy_page(inode->i_mapping);
+ 	if (!page)
+ 		return 0;
+ 
+ 	return ___wait_var_event(&page->_refcount,
+ 			atomic_read(&page->_refcount) == 1, TASK_INTERRUPTIBLE,
+ 			0, 0, xfs_wait_dax_page(inode, did_unlock));
+ }
+ 
+ int
+ xfs_break_layouts(
+ 	struct inode		*inode,
+ 	uint			*iolock,
+ 	enum layout_break_reason reason)
+ {
+ 	bool			retry;
+ 	int			error;
+ 
+ 	ASSERT(xfs_isilocked(XFS_I(inode), XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL));
+ 
+ 	do {
+ 		retry = false;
+ 		switch (reason) {
+ 		case BREAK_UNMAP:
+ 			error = xfs_break_dax_layouts(inode, *iolock, &retry);
+ 			if (error || retry)
+ 				break;
+ 			/* fall through */
+ 		case BREAK_WRITE:
+ 			error = xfs_break_leased_layouts(inode, iolock, &retry);
+ 			break;
+ 		default:
+ 			WARN_ON_ONCE(1);
+ 			error = -EINVAL;
+ 		}
+ 	} while (error == 0 && retry);
+ 
+ 	return error;
+ }
+ 
+ #define	XFS_FALLOC_FL_SUPPORTED						\
+ 		(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |		\
+ 		 FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE |	\
+ 		 FALLOC_FL_INSERT_RANGE | FALLOC_FL_UNSHARE_RANGE)
+ 
++>>>>>>> d6dc57e251a4 (xfs, dax: introduce xfs_break_dax_layouts())
  STATIC long
  xfs_file_fallocate(
  	struct file		*file,
* Unmerged path fs/xfs/xfs_file.c
