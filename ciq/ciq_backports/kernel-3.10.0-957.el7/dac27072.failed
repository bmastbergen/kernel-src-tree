nfsd: make nfsd4_scsi_identify_device retry with a larger buffer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Scott Mayhew <smayhew@redhat.com>
commit dac2707227bf35c19f7771e5f19b61bc334b6cd1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/dac27072.failed

nfsd4_scsi_identify_device() performs a single IDENTIFY command for the
device identification VPD page using a small buffer.  If the reply is
too large to fit in this buffer then the GETDEVICEINFO reply will not
contain any info for the SCSI volume aside from the registration key.
This can happen for example if the device has descriptors using long
SCSI name strings.

When the initial reply from the device indicates a larger buffer is
needed, retry once using the page length from that reply.

	Signed-off-by: Scott Mayhew <smayhew@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit dac2707227bf35c19f7771e5f19b61bc334b6cd1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/blocklayout.c
diff --cc fs/nfsd/blocklayout.c
index 8a36fe0a87c5,a0661349e7cf..000000000000
--- a/fs/nfsd/blocklayout.c
+++ b/fs/nfsd/blocklayout.c
@@@ -211,10 -215,22 +211,29 @@@ static int nfsd4_scsi_identify_device(s
  {
  	struct request_queue *q = bdev->bd_disk->queue;
  	struct request *rq;
++<<<<<<< HEAD
 +	size_t bufflen = 252, len, id_len;
++=======
+ 	struct scsi_request *req;
+ 	/*
+ 	 * The allocation length (passed in bytes 3 and 4 of the INQUIRY
+ 	 * command descriptor block) specifies the number of bytes that have
+ 	 * been allocated for the data-in buffer.
+ 	 * 252 is the highest one-byte value that is a multiple of 4.
+ 	 * 65532 is the highest two-byte value that is a multiple of 4.
+ 	 */
+ 	size_t bufflen = 252, maxlen = 65532, len, id_len;
++>>>>>>> dac2707227bf (nfsd: make nfsd4_scsi_identify_device retry with a larger buffer)
  	u8 *buf, *d, type, assoc;
- 	int error;
+ 	int retries = 1, error;
  
++<<<<<<< HEAD
++=======
+ 	if (WARN_ON_ONCE(!blk_queue_scsi_passthrough(q)))
+ 		return -EINVAL;
+ 
+ again:
++>>>>>>> dac2707227bf (nfsd: make nfsd4_scsi_identify_device retry with a larger buffer)
  	buf = kzalloc(bufflen, GFP_KERNEL);
  	if (!buf)
  		return -ENOMEM;
* Unmerged path fs/nfsd/blocklayout.c
