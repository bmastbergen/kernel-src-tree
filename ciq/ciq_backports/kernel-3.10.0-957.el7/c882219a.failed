net: ipv6: use list_move instead of list_del/list_add

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] ipv6: use list_move instead of list_del/list_add (Ivan Vecera) [1500871]
Rebuild_FUZZ: 95.05%
commit-author Wei Yongjun <weiyj.lk@gmail.com>
commit c882219ae43ed8d2a06583d24d2ed42d09ca93cf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c882219a.failed

Using list_move() instead of list_del() + list_add().

	Signed-off-by: Wei Yongjun <weiyj.lk@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c882219ae43ed8d2a06583d24d2ed42d09ca93cf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/addrconf.c
diff --cc net/ipv6/addrconf.c
index 836f13f8d356,ab3e796596b1..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -3330,20 -3596,42 +3330,41 @@@ static int addrconf_ifdown(struct net_d
  		write_lock_bh(&idev->lock);
  	}
  
 -	/* re-combine the user config with event to determine if permanent
 -	 * addresses are to be removed from the interface list
 -	 */
 -	keep_addr = (!how && _keep_addr > 0);
 -
 -	INIT_LIST_HEAD(&del_list);
 -	list_for_each_entry_safe(ifa, tmp, &idev->addr_list, if_list) {
 -		struct rt6_info *rt = NULL;
 -
 +	while (!list_empty(&idev->addr_list)) {
 +		ifa = list_first_entry(&idev->addr_list,
 +				       struct inet6_ifaddr, if_list);
  		addrconf_del_dad_work(ifa);
  
 +		list_del(&ifa->if_list);
 +
  		write_unlock_bh(&idev->lock);
 +
  		spin_lock_bh(&ifa->lock);
++<<<<<<< HEAD
 +		state = ifa->state;
 +		ifa->state = INET6_IFADDR_STATE_DEAD;
++=======
+ 
+ 		if (keep_addr && (ifa->flags & IFA_F_PERMANENT) &&
+ 		    !addr_is_local(&ifa->addr)) {
+ 			/* set state to skip the notifier below */
+ 			state = INET6_IFADDR_STATE_DEAD;
+ 			ifa->state = 0;
+ 			if (!(ifa->flags & IFA_F_NODAD))
+ 				ifa->flags |= IFA_F_TENTATIVE;
+ 
+ 			rt = ifa->rt;
+ 			ifa->rt = NULL;
+ 		} else {
+ 			state = ifa->state;
+ 			ifa->state = INET6_IFADDR_STATE_DEAD;
+ 
+ 			list_move(&ifa->if_list, &del_list);
+ 		}
+ 
++>>>>>>> c882219ae43e (net: ipv6: use list_move instead of list_del/list_add)
  		spin_unlock_bh(&ifa->lock);
  
 -		if (rt)
 -			ip6_del_rt(rt);
 -
  		if (state != INET6_IFADDR_STATE_DEAD) {
  			__ipv6_ifa_notify(RTM_DELADDR, ifa);
  			inet6addr_notifier_call_chain(NETDEV_DOWN, ifa);
* Unmerged path net/ipv6/addrconf.c
