xfs: allow unwritten extents in the CoW fork

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 05a630d76bd3f39baf0eecfa305bed2820796dee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/05a630d7.failed

In the data fork, we only allow extents to perform the following state
transitions:

delay -> real <-> unwritten

There's no way to move directly from a delalloc reservation to an
/unwritten/ allocated extent.  However, for the CoW fork we want to be
able to do the following to each extent:

delalloc -> unwritten -> written -> remapped to data fork

This will help us to avoid a race in the speculative CoW preallocation
code between a first thread that is allocating a CoW extent and a second
thread that is remapping part of a file after a write.  In order to do
this, however, we need two things: first, we have to be able to
transition from da to unwritten, and second the function that converts
between real and unwritten has to be made aware of the cow fork.  Do
both of those things.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 05a630d76bd3f39baf0eecfa305bed2820796dee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 2f128ede4d29,dcffbb09444e..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -1881,9 -1850,10 +1881,10 @@@ xfs_bmap_add_extent_delay_real
  		 */
  		trace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);
  		xfs_bmbt_set_startblock(ep, new->br_startblock);
+ 		xfs_bmbt_set_state(ep, new->br_state);
  		trace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);
  
 -		(*nextents)++;
 +		bma->ip->i_d.di_nextents++;
  		if (bma->cur == NULL)
  			rval = XFS_ILOG_CORE | XFS_ILOG_DEXT;
  		else {
@@@ -2705,8 -2690,13 +2715,16 @@@ xfs_bmap_add_extent_unwritten_real
  		ASSERT(0);
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* update reverse mappings */
+ 	error = xfs_rmap_convert_extent(mp, dfops, ip, whichfork, new);
+ 	if (error)
+ 		goto done;
+ 
++>>>>>>> 05a630d76bd3 (xfs: allow unwritten extents in the CoW fork)
  	/* convert to a btree if necessary */
- 	if (xfs_bmap_needs_btree(ip, XFS_DATA_FORK)) {
+ 	if (xfs_bmap_needs_btree(ip, whichfork)) {
  		int	tmp_logflags;	/* partial log flag return val */
  
  		ASSERT(cur == NULL);
@@@ -4457,9 -4537,15 +4485,18 @@@ xfs_bmapi_write
  	ASSERT(*nmap >= 1);
  	ASSERT(*nmap <= XFS_BMAP_MAX_NMAP);
  	ASSERT(!(flags & XFS_BMAPI_IGSTATE));
- 	ASSERT(tp != NULL);
+ 	ASSERT(tp != NULL ||
+ 	       (flags & (XFS_BMAPI_CONVERT | XFS_BMAPI_COWFORK)) ==
+ 			(XFS_BMAPI_CONVERT | XFS_BMAPI_COWFORK));
  	ASSERT(len > 0);
  	ASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL);
++<<<<<<< HEAD
++=======
+ 	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));
+ 	ASSERT(!(flags & XFS_BMAPI_REMAP) || whichfork == XFS_DATA_FORK);
+ 	ASSERT(!(flags & XFS_BMAPI_PREALLOC) || !(flags & XFS_BMAPI_REMAP));
+ 	ASSERT(!(flags & XFS_BMAPI_CONVERT) || !(flags & XFS_BMAPI_REMAP));
++>>>>>>> 05a630d76bd3 (xfs: allow unwritten extents in the CoW fork)
  
  	/* zeroing is for currently only for data extents, not metadata */
  	ASSERT((flags & (XFS_BMAPI_METADATA | XFS_BMAPI_ZERO)) !=
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
