nfp: bpf: require seamless reload for program replace

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit e4a91cd565e2c4e299abe9eb906c506ecc01032a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/e4a91cd5.failed

Firmware supports live replacement of programs for quite some
time now.  Remove the software-fallback related logic and
depend on the FW for program replace.  Seamless reload will
become a requirement if maps are present, anyway.

Load and start stages have to be split now, since replace
only needs a load, start has already been done on add.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e4a91cd565e2c4e299abe9eb906c506ecc01032a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/bpf/main.c
#	drivers/net/ethernet/netronome/nfp/bpf/main.h
#	drivers/net/ethernet/netronome/nfp/bpf/offload.c
diff --cc drivers/net/ethernet/netronome/nfp/bpf/main.c
index 4ca14182b178,7ae7528cd96b..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/main.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/main.c
@@@ -62,20 -60,19 +62,29 @@@ nfp_bpf_xdp_offload(struct nfp_app *app
  	if (!nfp_net_ebpf_capable(nn))
  		return -EINVAL;
  
 -	running = nn->dp.ctrl & NFP_NET_CFG_CTRL_BPF;
 -	xdp_running = running && nn->dp.bpf_offload_xdp;
 +	if (nn->dp.ctrl & NFP_NET_CFG_CTRL_BPF) {
 +		if (!nn->dp.bpf_offload_xdp)
 +			return prog ? -EBUSY : 0;
 +		cmd.command = prog ? TC_CLSBPF_REPLACE : TC_CLSBPF_DESTROY;
 +	} else {
 +		if (!prog)
 +			return 0;
 +		cmd.command = TC_CLSBPF_ADD;
 +	}
  
++<<<<<<< HEAD
 +	ret = nfp_net_bpf_offload(nn, &cmd);
++=======
+ 	if (!prog && !xdp_running)
+ 		return 0;
+ 	if (prog && running && !xdp_running)
+ 		return -EBUSY;
+ 
+ 	ret = nfp_net_bpf_offload(nn, prog, running);
++>>>>>>> e4a91cd565e2 (nfp: bpf: require seamless reload for program replace)
  	/* Stop offload if replace not possible */
 -	if (ret && prog)
 +	if (ret && cmd.command == TC_CLSBPF_REPLACE)
  		nfp_bpf_xdp_offload(app, nn, NULL);
 -
  	nn->dp.bpf_offload_xdp = prog && !ret;
  	return ret;
  }
@@@ -111,7 -86,63 +120,67 @@@ static void nfp_bpf_vnic_free(struct nf
  {
  	if (nn->dp.bpf_offload_xdp)
  		nfp_bpf_xdp_offload(app, nn, NULL);
++<<<<<<< HEAD
 +	kfree(nn->app_priv);
++=======
+ }
+ 
+ static int nfp_bpf_setup_tc_block_cb(enum tc_setup_type type,
+ 				     void *type_data, void *cb_priv)
+ {
+ 	struct tc_cls_bpf_offload *cls_bpf = type_data;
+ 	struct nfp_net *nn = cb_priv;
+ 
+ 	if (type != TC_SETUP_CLSBPF ||
+ 	    !tc_can_offload(nn->dp.netdev) ||
+ 	    !nfp_net_ebpf_capable(nn) ||
+ 	    cls_bpf->common.protocol != htons(ETH_P_ALL) ||
+ 	    cls_bpf->common.chain_index)
+ 		return -EOPNOTSUPP;
+ 	if (nn->dp.bpf_offload_xdp)
+ 		return -EBUSY;
+ 
+ 	/* Only support TC direct action */
+ 	if (!cls_bpf->exts_integrated ||
+ 	    tcf_exts_has_actions(cls_bpf->exts)) {
+ 		nn_err(nn, "only direct action with no legacy actions supported\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	switch (cls_bpf->command) {
+ 	case TC_CLSBPF_REPLACE:
+ 		return nfp_net_bpf_offload(nn, cls_bpf->prog, true);
+ 	case TC_CLSBPF_ADD:
+ 		return nfp_net_bpf_offload(nn, cls_bpf->prog, false);
+ 	case TC_CLSBPF_DESTROY:
+ 		return nfp_net_bpf_offload(nn, NULL, true);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int nfp_bpf_setup_tc_block(struct net_device *netdev,
+ 				  struct tc_block_offload *f)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 
+ 	if (f->binder_type != TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (f->command) {
+ 	case TC_BLOCK_BIND:
+ 		return tcf_block_cb_register(f->block,
+ 					     nfp_bpf_setup_tc_block_cb,
+ 					     nn, nn);
+ 	case TC_BLOCK_UNBIND:
+ 		tcf_block_cb_unregister(f->block,
+ 					nfp_bpf_setup_tc_block_cb,
+ 					nn);
+ 		return 0;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
++>>>>>>> e4a91cd565e2 (nfp: bpf: require seamless reload for program replace)
  }
  
  static int nfp_bpf_setup_tc(struct nfp_app *app, struct net_device *netdev,
diff --cc drivers/net/ethernet/netronome/nfp/bpf/main.h
index cc2a5beba757,df56f40fea7c..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/main.h
+++ b/drivers/net/ethernet/netronome/nfp/bpf/main.h
@@@ -194,24 -181,8 +194,29 @@@ nfp_bpf_jit(struct bpf_prog *filter, vo
  int nfp_prog_verify(struct nfp_prog *nfp_prog, struct bpf_prog *prog);
  
  struct nfp_net;
 +struct tc_cls_bpf_offload;
 +
++<<<<<<< HEAD
 +/**
 + * struct nfp_net_bpf_priv - per-vNIC BPF private data
 + * @rx_filter:		Filter offload statistics - dropped packets/bytes
 + * @rx_filter_prev:	Filter offload statistics - values from previous update
 + * @rx_filter_change:	Jiffies when statistics last changed
 + * @rx_filter_stats_timer:  Timer for polling filter offload statistics
 + * @rx_filter_lock:	Lock protecting timer state changes (teardown)
 + */
 +struct nfp_net_bpf_priv {
 +	struct nfp_stat_pair rx_filter, rx_filter_prev;
 +	unsigned long rx_filter_change;
 +	struct timer_list rx_filter_stats_timer;
 +	spinlock_t rx_filter_lock;
 +};
  
 +int nfp_net_bpf_offload(struct nfp_net *nn, struct tc_cls_bpf_offload *cls_bpf);
 +void nfp_net_filter_stats_timer(unsigned long data);
++=======
+ int nfp_net_bpf_offload(struct nfp_net *nn, struct bpf_prog *prog,
+ 			bool old_prog);
++>>>>>>> e4a91cd565e2 (nfp: bpf: require seamless reload for program replace)
  
  #endif
diff --cc drivers/net/ethernet/netronome/nfp/bpf/offload.c
index de79faf0874b,f4b9a46c844d..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/offload.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/offload.c
@@@ -203,22 -94,13 +203,30 @@@ out
  }
  
  static void
++<<<<<<< HEAD
 +nfp_net_bpf_load_and_start(struct nfp_net *nn, u32 tc_flags,
 +			   void *code, dma_addr_t dma_addr,
 +			   unsigned int code_sz, unsigned int n_instr,
 +			   bool dense_mode)
++=======
+ nfp_net_bpf_load(struct nfp_net *nn, void *code, dma_addr_t dma_addr,
+ 		 unsigned int code_sz, unsigned int n_instr)
++>>>>>>> e4a91cd565e2 (nfp: bpf: require seamless reload for program replace)
  {
 +	struct nfp_net_bpf_priv *priv = nn->app_priv;
 +	u64 bpf_addr = dma_addr;
  	int err;
  
++<<<<<<< HEAD
 +	nn->dp.bpf_offload_skip_sw = !!(tc_flags & TCA_CLS_FLAGS_SKIP_SW);
 +
 +	if (dense_mode)
 +		bpf_addr |= NFP_NET_CFG_BPF_CFG_8CTX;
 +
++=======
++>>>>>>> e4a91cd565e2 (nfp: bpf: require seamless reload for program replace)
  	nn_writew(nn, NFP_NET_CFG_BPF_SIZE, n_instr);
 -	nn_writeq(nn, NFP_NET_CFG_BPF_ADDR, dma_addr);
 +	nn_writeq(nn, NFP_NET_CFG_BPF_ADDR, bpf_addr);
  
  	/* Load up the JITed code */
  	err = nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_BPF);
@@@ -231,12 -120,6 +246,15 @@@ static void nfp_net_bpf_start(struct nf
  	err = nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_GEN);
  	if (err)
  		nn_err(nn, "FW command error while enabling BPF: %d\n", err);
++<<<<<<< HEAD
 +
 +	dma_free_coherent(nn->dp.dev, code_sz, code, dma_addr);
 +
 +	nfp_net_bpf_stats_reset(nn);
 +	mod_timer(&priv->rx_filter_stats_timer,
 +		  jiffies + NFP_NET_STAT_POLL_IVL);
++=======
++>>>>>>> e4a91cd565e2 (nfp: bpf: require seamless reload for program replace)
  }
  
  static int nfp_net_bpf_stop(struct nfp_net *nn)
@@@ -246,76 -127,49 +264,115 @@@
  	if (!(nn->dp.ctrl & NFP_NET_CFG_CTRL_BPF))
  		return 0;
  
 +	spin_lock_bh(&priv->rx_filter_lock);
  	nn->dp.ctrl &= ~NFP_NET_CFG_CTRL_BPF;
 +	spin_unlock_bh(&priv->rx_filter_lock);
  	nn_writel(nn, NFP_NET_CFG_CTRL, nn->dp.ctrl);
++<<<<<<< HEAD
 +
 +	del_timer_sync(&priv->rx_filter_stats_timer);
 +	nn->dp.bpf_offload_skip_sw = 0;
++=======
++>>>>>>> e4a91cd565e2 (nfp: bpf: require seamless reload for program replace)
  
  	return nfp_net_reconfig(nn, NFP_NET_CFG_UPDATE_GEN);
  }
 +#endif
  
++<<<<<<< HEAD
 +int nfp_net_bpf_offload(struct nfp_net *nn, struct tc_cls_bpf_offload *cls_bpf)
++=======
+ int nfp_net_bpf_offload(struct nfp_net *nn, struct bpf_prog *prog,
+ 			bool old_prog)
++>>>>>>> e4a91cd565e2 (nfp: bpf: require seamless reload for program replace)
  {
 +#if 0 /* Not in RHEL7 */
  	struct nfp_bpf_result res;
  	dma_addr_t dma_addr;
  	u16 max_instr;
  	void *code;
  	int err;
  
++<<<<<<< HEAD
 +	max_instr = nn_readw(nn, NFP_NET_CFG_BPF_MAX_LEN);
 +
 +	switch (cls_bpf->command) {
 +	case TC_CLSBPF_REPLACE:
 +		/* There is nothing stopping us from implementing seamless
 +		 * replace but the simple method of loading I adopted in
 +		 * the firmware does not handle atomic replace (i.e. we have to
 +		 * stop the BPF offload and re-enable it).  Leaking-in a few
 +		 * frames which didn't have BPF applied in the hardware should
 +		 * be fine if software fallback is available, though.
 +		 */
 +		if (nn->dp.bpf_offload_skip_sw)
 +			return -EBUSY;
 +
 +		err = nfp_net_bpf_offload_prepare(nn, cls_bpf, &res, &code,
 +						  &dma_addr, max_instr);
 +		if (err)
 +			return err;
 +
 +		nfp_net_bpf_stop(nn);
 +		nfp_net_bpf_load_and_start(nn, cls_bpf->gen_flags, code,
 +					   dma_addr, max_instr * sizeof(u64),
 +					   res.n_instr, res.dense_mode);
 +		return 0;
++=======
+ 	if (prog && old_prog) {
+ 		u8 cap;
+ 
+ 		cap = nn_readb(nn, NFP_NET_CFG_BPF_CAP);
+ 		if (!(cap & NFP_NET_BPF_CAP_RELO)) {
+ 			nn_err(nn, "FW does not support live reload\n");
+ 			return -EBUSY;
+ 		}
+ 	}
+ 
+ 	/* Something else is loaded, different program type? */
+ 	if (!old_prog && nn->dp.ctrl & NFP_NET_CFG_CTRL_BPF)
+ 		return -EBUSY;
+ 
+ 	if (old_prog && !prog)
+ 		return nfp_net_bpf_stop(nn);
+ 
+ 	max_instr = nn_readw(nn, NFP_NET_CFG_BPF_MAX_LEN);
+ 
+ 	err = nfp_net_bpf_offload_prepare(nn, prog, &res, &code, &dma_addr,
+ 					  max_instr);
+ 	if (err)
+ 		return err;
+ 
+ 	nfp_net_bpf_load(nn, code, dma_addr, max_instr * sizeof(u64),
+ 			 res.n_instr);
+ 	if (!old_prog)
+ 		nfp_net_bpf_start(nn);
++>>>>>>> e4a91cd565e2 (nfp: bpf: require seamless reload for program replace)
  
 -	return 0;
 +	case TC_CLSBPF_ADD:
 +		if (nn->dp.ctrl & NFP_NET_CFG_CTRL_BPF)
 +			return -EBUSY;
 +
 +		err = nfp_net_bpf_offload_prepare(nn, cls_bpf, &res, &code,
 +						  &dma_addr, max_instr);
 +		if (err)
 +			return err;
 +
 +		nfp_net_bpf_load_and_start(nn, cls_bpf->gen_flags, code,
 +					   dma_addr, max_instr * sizeof(u64),
 +					   res.n_instr, res.dense_mode);
 +		return 0;
 +
 +	case TC_CLSBPF_DESTROY:
 +		return nfp_net_bpf_stop(nn);
 +
 +	case TC_CLSBPF_STATS:
 +		return nfp_net_bpf_stats_update(nn, cls_bpf);
 +
 +	default:
 +		return -EOPNOTSUPP;
 +	}
 +#else
 +	return -EOPNOTSUPP;
 +#endif
  }
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/main.h
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/offload.c
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net.h b/drivers/net/ethernet/netronome/nfp/nfp_net.h
index f80b0a7bad34..431adf5a0602 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@ -477,7 +477,6 @@ struct nfp_stat_pair {
  * @dev:		Backpointer to struct device
  * @netdev:		Backpointer to net_device structure
  * @is_vf:		Is the driver attached to a VF?
- * @bpf_offload_skip_sw:  Offloaded BPF program will not be rerun by cls_bpf
  * @bpf_offload_xdp:	Offloaded BPF program is XDP
  * @chained_metadata_format:  Firemware will use new metadata format
  * @rx_dma_dir:		Mapping direction for RX buffers
@@ -503,7 +502,6 @@ struct nfp_net_dp {
 	struct net_device *netdev;
 
 	u8 is_vf:1;
-	u8 bpf_offload_skip_sw:1;
 	u8 bpf_offload_xdp:1;
 	u8 chained_metadata_format:1;
 
