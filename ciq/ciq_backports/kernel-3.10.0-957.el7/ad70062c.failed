nvme-pci: introduce RECONNECTING state to mark initializing procedure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jianchao Wang <jianchao.w.wang@oracle.com>
commit ad70062cdb4002c74db4fbed4e2b34daffccacc2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ad70062c.failed

After Sagi's commit (nvme-rdma: fix concurrent reset and reconnect),
both nvme-fc/rdma have following pattern:
RESETTING    - quiesce blk-mq queues, teardown and delete queues/
               connections, clear out outstanding IO requests...
RECONNECTING - establish new queues/connections and some other
               initializing things.
Introduce RECONNECTING to nvme-pci transport to do the same mark.
Then we get a coherent state definition among nvme pci/rdma/fc
transports.

	Suggested-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Reviewed-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jianchao Wang <jianchao.w.wang@oracle.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit ad70062cdb4002c74db4fbed4e2b34daffccacc2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index 27174fd02aa2,63c2c469112d..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -186,6 -258,15 +186,18 @@@ bool nvme_change_ctrl_state(struct nvme
  
  	old_state = ctrl->state;
  	switch (new_state) {
++<<<<<<< HEAD
++=======
+ 	case NVME_CTRL_ADMIN_ONLY:
+ 		switch (old_state) {
+ 		case NVME_CTRL_RECONNECTING:
+ 			changed = true;
+ 			/* FALLTHRU */
+ 		default:
+ 			break;
+ 		}
+ 		break;
++>>>>>>> ad70062cdb40 (nvme-pci: introduce RECONNECTING state to mark initializing procedure)
  	case NVME_CTRL_LIVE:
  		switch (old_state) {
  		case NVME_CTRL_NEW:
* Unmerged path drivers/nvme/host/core.c
diff --git a/drivers/nvme/host/pci.c b/drivers/nvme/host/pci.c
index e3ee89a3f5ff..1ea2def36648 100644
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@ -905,9 +905,14 @@ static bool nvme_should_reset(struct nvme_dev *dev, u32 csts)
 	 */
 	bool nssro = dev->subsystem && (csts & NVME_CSTS_NSSRO);
 
-	/* If there is a reset ongoing, we shouldn't reset again. */
-	if (dev->ctrl.state == NVME_CTRL_RESETTING)
+	/* If there is a reset/reinit ongoing, we shouldn't reset again. */
+	switch (dev->ctrl.state) {
+	case NVME_CTRL_RESETTING:
+	case NVME_CTRL_RECONNECTING:
 		return false;
+	default:
+		break;
+	}
 
 	/* We shouldn't reset unless the controller is on fatal error state
 	 * _or_ if we lost the communication with it.
@@ -2055,6 +2060,16 @@ static void nvme_reset_work(struct work_struct *work)
 	if (dev->ctrl.ctrl_config & NVME_CC_ENABLE)
 		nvme_dev_disable(dev, false);
 
+	/*
+	 * Introduce RECONNECTING state from nvme-fc/rdma transports to mark the
+	 * initializing procedure here.
+	 */
+	if (!nvme_change_ctrl_state(&dev->ctrl, NVME_CTRL_RECONNECTING)) {
+		dev_warn(dev->ctrl.device,
+			"failed to mark controller RECONNECTING\n");
+		goto out;
+	}
+
 	result = nvme_pci_enable(dev);
 	if (result)
 		goto out;
