xfs: implement online get/set fs label

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Eric Sandeen <sandeen@sandeen.net>
commit f7664b31975bd893190708e76b2c424328f0c49b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f7664b31.failed

The GET ioctl is trivial, just return the current label.

The SET ioctl is more involved:
It transactionally modifies the superblock to write a new filesystem
label to the primary super.

A new variant of xfs_sync_sb then writes the superblock buffer
immediately to disk so that the change is visible from userspace.

It then invalidates any page cache that userspace might have previously
read on the block device so that i.e. blkid can see the change
immediately, and updates all secondary superblocks as userspace relable
does.

	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
[darrick: use dchinner's new xfs_update_secondary_sbs function]
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit f7664b31975bd893190708e76b2c424328f0c49b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_format.h
#	fs/xfs/libxfs/xfs_sb.c
diff --cc fs/xfs/libxfs/xfs_format.h
index 7adfccb0f769,c1cb29a5f4f6..000000000000
--- a/fs/xfs/libxfs/xfs_format.h
+++ b/fs/xfs/libxfs/xfs_format.h
@@@ -118,19 -121,19 +121,35 @@@ typedef struct xfs_sb 
  	xfs_agnumber_t	sb_agcount;	/* number of allocation groups */
  	xfs_extlen_t	sb_rbmblocks;	/* number of rt bitmap blocks */
  	xfs_extlen_t	sb_logblocks;	/* number of log blocks */
++<<<<<<< HEAD
 +	__uint16_t	sb_versionnum;	/* header version == XFS_SB_VERSION */
 +	__uint16_t	sb_sectsize;	/* volume sector size, bytes */
 +	__uint16_t	sb_inodesize;	/* inode size, bytes */
 +	__uint16_t	sb_inopblock;	/* inodes per block */
 +	char		sb_fname[12];	/* file system name */
 +	__uint8_t	sb_blocklog;	/* log2 of sb_blocksize */
 +	__uint8_t	sb_sectlog;	/* log2 of sb_sectsize */
 +	__uint8_t	sb_inodelog;	/* log2 of sb_inodesize */
 +	__uint8_t	sb_inopblog;	/* log2 of sb_inopblock */
 +	__uint8_t	sb_agblklog;	/* log2 of sb_agblocks (rounded up) */
 +	__uint8_t	sb_rextslog;	/* log2 of sb_rextents */
 +	__uint8_t	sb_inprogress;	/* mkfs is in progress, don't mount */
 +	__uint8_t	sb_imax_pct;	/* max % of fs for inode space */
++=======
+ 	uint16_t	sb_versionnum;	/* header version == XFS_SB_VERSION */
+ 	uint16_t	sb_sectsize;	/* volume sector size, bytes */
+ 	uint16_t	sb_inodesize;	/* inode size, bytes */
+ 	uint16_t	sb_inopblock;	/* inodes per block */
+ 	char		sb_fname[XFSLABEL_MAX]; /* file system name */
+ 	uint8_t		sb_blocklog;	/* log2 of sb_blocksize */
+ 	uint8_t		sb_sectlog;	/* log2 of sb_sectsize */
+ 	uint8_t		sb_inodelog;	/* log2 of sb_inodesize */
+ 	uint8_t		sb_inopblog;	/* log2 of sb_inopblock */
+ 	uint8_t		sb_agblklog;	/* log2 of sb_agblocks (rounded up) */
+ 	uint8_t		sb_rextslog;	/* log2 of sb_rextents */
+ 	uint8_t		sb_inprogress;	/* mkfs is in progress, don't mount */
+ 	uint8_t		sb_imax_pct;	/* max % of fs for inode space */
++>>>>>>> f7664b31975b (xfs: implement online get/set fs label)
  					/* statistics */
  	/*
  	 * These fields must remain contiguous.  If you really
diff --cc fs/xfs/libxfs/xfs_sb.c
index d70ea7b614eb,ea6c85a4c27c..000000000000
--- a/fs/xfs/libxfs/xfs_sb.c
+++ b/fs/xfs/libxfs/xfs_sb.c
@@@ -859,3 -887,213 +859,216 @@@ xfs_sync_sb
  		xfs_trans_set_sync(tp);
  	return xfs_trans_commit(tp);
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Update all the secondary superblocks to match the new state of the primary.
+  * Because we are completely overwriting all the existing fields in the
+  * secondary superblock buffers, there is no need to read them in from disk.
+  * Just get a new buffer, stamp it and write it.
+  *
+  * The sb buffers need to be cached here so that we serialise against other
+  * operations that access the secondary superblocks, but we don't want to keep
+  * them in memory once it is written so we mark it as a one-shot buffer.
+  */
+ int
+ xfs_update_secondary_sbs(
+ 	struct xfs_mount	*mp)
+ {
+ 	xfs_agnumber_t		agno;
+ 	int			saved_error = 0;
+ 	int			error = 0;
+ 	LIST_HEAD		(buffer_list);
+ 
+ 	/* update secondary superblocks. */
+ 	for (agno = 1; agno < mp->m_sb.sb_agcount; agno++) {
+ 		struct xfs_buf		*bp;
+ 
+ 		bp = xfs_buf_get(mp->m_ddev_targp,
+ 				 XFS_AG_DADDR(mp, agno, XFS_SB_DADDR),
+ 				 XFS_FSS_TO_BB(mp, 1), 0);
+ 		/*
+ 		 * If we get an error reading or writing alternate superblocks,
+ 		 * continue.  xfs_repair chooses the "best" superblock based
+ 		 * on most matches; if we break early, we'll leave more
+ 		 * superblocks un-updated than updated, and xfs_repair may
+ 		 * pick them over the properly-updated primary.
+ 		 */
+ 		if (!bp) {
+ 			xfs_warn(mp,
+ 		"error allocating secondary superblock for ag %d",
+ 				agno);
+ 			if (!saved_error)
+ 				saved_error = -ENOMEM;
+ 			continue;
+ 		}
+ 
+ 		bp->b_ops = &xfs_sb_buf_ops;
+ 		xfs_buf_oneshot(bp);
+ 		xfs_buf_zero(bp, 0, BBTOB(bp->b_length));
+ 		xfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb);
+ 		xfs_buf_delwri_queue(bp, &buffer_list);
+ 		xfs_buf_relse(bp);
+ 
+ 		/* don't hold too many buffers at once */
+ 		if (agno % 16)
+ 			continue;
+ 
+ 		error = xfs_buf_delwri_submit(&buffer_list);
+ 		if (error) {
+ 			xfs_warn(mp,
+ 		"write error %d updating a secondary superblock near ag %d",
+ 				error, agno);
+ 			if (!saved_error)
+ 				saved_error = error;
+ 			continue;
+ 		}
+ 	}
+ 	error = xfs_buf_delwri_submit(&buffer_list);
+ 	if (error) {
+ 		xfs_warn(mp,
+ 		"write error %d updating a secondary superblock near ag %d",
+ 			error, agno);
+ 	}
+ 
+ 	return saved_error ? saved_error : error;
+ }
+ 
+ /*
+  * Same behavior as xfs_sync_sb, except that it is always synchronous and it
+  * also writes the superblock buffer to disk sector 0 immediately.
+  */
+ int
+ xfs_sync_sb_buf(
+ 	struct xfs_mount	*mp)
+ {
+ 	struct xfs_trans	*tp;
+ 	int			error;
+ 
+ 	error = xfs_trans_alloc(mp, &M_RES(mp)->tr_sb, 0, 0, 0, &tp);
+ 	if (error)
+ 		return error;
+ 
+ 	xfs_log_sb(tp);
+ 	xfs_trans_bhold(tp, mp->m_sb_bp);
+ 	xfs_trans_set_sync(tp);
+ 	error = xfs_trans_commit(tp);
+ 	if (error)
+ 		goto out;
+ 	/*
+ 	 * write out the sb buffer to get the changes to disk
+ 	 */
+ 	error = xfs_bwrite(mp->m_sb_bp);
+ out:
+ 	xfs_buf_relse(mp->m_sb_bp);
+ 	return error;
+ }
+ 
+ int
+ xfs_fs_geometry(
+ 	struct xfs_sb		*sbp,
+ 	struct xfs_fsop_geom	*geo,
+ 	int			struct_version)
+ {
+ 	memset(geo, 0, sizeof(struct xfs_fsop_geom));
+ 
+ 	geo->blocksize = sbp->sb_blocksize;
+ 	geo->rtextsize = sbp->sb_rextsize;
+ 	geo->agblocks = sbp->sb_agblocks;
+ 	geo->agcount = sbp->sb_agcount;
+ 	geo->logblocks = sbp->sb_logblocks;
+ 	geo->sectsize = sbp->sb_sectsize;
+ 	geo->inodesize = sbp->sb_inodesize;
+ 	geo->imaxpct = sbp->sb_imax_pct;
+ 	geo->datablocks = sbp->sb_dblocks;
+ 	geo->rtblocks = sbp->sb_rblocks;
+ 	geo->rtextents = sbp->sb_rextents;
+ 	geo->logstart = sbp->sb_logstart;
+ 	BUILD_BUG_ON(sizeof(geo->uuid) != sizeof(sbp->sb_uuid));
+ 	memcpy(geo->uuid, &sbp->sb_uuid, sizeof(sbp->sb_uuid));
+ 
+ 	if (struct_version < 2)
+ 		return 0;
+ 
+ 	geo->sunit = sbp->sb_unit;
+ 	geo->swidth = sbp->sb_width;
+ 
+ 	if (struct_version < 3)
+ 		return 0;
+ 
+ 	geo->version = XFS_FSOP_GEOM_VERSION;
+ 	geo->flags = XFS_FSOP_GEOM_FLAGS_NLINK |
+ 		     XFS_FSOP_GEOM_FLAGS_DIRV2;
+ 	if (xfs_sb_version_hasattr(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_ATTR;
+ 	if (xfs_sb_version_hasquota(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_QUOTA;
+ 	if (xfs_sb_version_hasalign(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_IALIGN;
+ 	if (xfs_sb_version_hasdalign(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_DALIGN;
+ 	if (xfs_sb_version_hasextflgbit(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_EXTFLG;
+ 	if (xfs_sb_version_hassector(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_SECTOR;
+ 	if (xfs_sb_version_hasasciici(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_DIRV2CI;
+ 	if (xfs_sb_version_haslazysbcount(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_LAZYSB;
+ 	if (xfs_sb_version_hasattr2(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_ATTR2;
+ 	if (xfs_sb_version_hasprojid32bit(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_PROJID32;
+ 	if (xfs_sb_version_hascrc(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_V5SB;
+ 	if (xfs_sb_version_hasftype(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_FTYPE;
+ 	if (xfs_sb_version_hasfinobt(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_FINOBT;
+ 	if (xfs_sb_version_hassparseinodes(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_SPINODES;
+ 	if (xfs_sb_version_hasrmapbt(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_RMAPBT;
+ 	if (xfs_sb_version_hasreflink(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_REFLINK;
+ 	if (xfs_sb_version_hassector(sbp))
+ 		geo->logsectsize = sbp->sb_logsectsize;
+ 	else
+ 		geo->logsectsize = BBSIZE;
+ 	geo->rtsectsize = sbp->sb_blocksize;
+ 	geo->dirblocksize = xfs_dir2_dirblock_bytes(sbp);
+ 
+ 	if (struct_version < 4)
+ 		return 0;
+ 
+ 	if (xfs_sb_version_haslogv2(sbp))
+ 		geo->flags |= XFS_FSOP_GEOM_FLAGS_LOGV2;
+ 
+ 	geo->logsunit = sbp->sb_logsunit;
+ 
+ 	return 0;
+ }
+ 
+ /* Read a secondary superblock. */
+ int
+ xfs_sb_read_secondary(
+ 	struct xfs_mount	*mp,
+ 	struct xfs_trans	*tp,
+ 	xfs_agnumber_t		agno,
+ 	struct xfs_buf		**bpp)
+ {
+ 	struct xfs_buf		*bp;
+ 	int			error;
+ 
+ 	ASSERT(agno != 0 && agno != NULLAGNUMBER);
+ 	error = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,
+ 			XFS_AG_DADDR(mp, agno, XFS_SB_BLOCK(mp)),
+ 			XFS_FSS_TO_BB(mp, 1), 0, &bp, &xfs_sb_buf_ops);
+ 	if (error)
+ 		return error;
+ 	xfs_buf_set_ref(bp, XFS_SSB_REF);
+ 	*bpp = bp;
+ 	return 0;
+ }
++>>>>>>> f7664b31975b (xfs: implement online get/set fs label)
* Unmerged path fs/xfs/libxfs/xfs_format.h
* Unmerged path fs/xfs/libxfs/xfs_sb.c
diff --git a/fs/xfs/libxfs/xfs_sb.h b/fs/xfs/libxfs/xfs_sb.h
index 961e6475a309..c0e970c5677a 100644
--- a/fs/xfs/libxfs/xfs_sb.h
+++ b/fs/xfs/libxfs/xfs_sb.h
@@ -29,6 +29,7 @@ extern int	xfs_initialize_perag_data(struct xfs_mount *, xfs_agnumber_t);
 
 extern void	xfs_log_sb(struct xfs_trans *tp);
 extern int	xfs_sync_sb(struct xfs_mount *mp, bool wait);
+extern int	xfs_sync_sb_buf(struct xfs_mount *mp);
 extern void	xfs_sb_mount_common(struct xfs_mount *mp, struct xfs_sb *sbp);
 extern void	xfs_sb_from_disk(struct xfs_sb *to, struct xfs_dsb *from);
 extern void	xfs_sb_to_disk(struct xfs_dsb *to, struct xfs_sb *from);
diff --git a/fs/xfs/xfs_ioctl.c b/fs/xfs/xfs_ioctl.c
index 16aae82f734b..e411381db6b9 100644
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@ -1653,6 +1653,88 @@ xfs_ioc_swapext(
 	return error;
 }
 
+static int
+xfs_ioc_getlabel(
+	struct xfs_mount	*mp,
+	char			__user *user_label)
+{
+	struct xfs_sb		*sbp = &mp->m_sb;
+	char			label[XFSLABEL_MAX + 1];
+
+	/* Paranoia */
+	BUILD_BUG_ON(sizeof(sbp->sb_fname) > FSLABEL_MAX);
+
+	spin_lock(&mp->m_sb_lock);
+	strncpy(label, sbp->sb_fname, sizeof(sbp->sb_fname));
+	spin_unlock(&mp->m_sb_lock);
+
+	/* xfs on-disk label is 12 chars, be sure we send a null to user */
+	label[XFSLABEL_MAX] = '\0';
+	if (copy_to_user(user_label, label, sizeof(sbp->sb_fname)))
+		return -EFAULT;
+	return 0;
+}
+
+static int
+xfs_ioc_setlabel(
+	struct file		*filp,
+	struct xfs_mount	*mp,
+	char			__user *newlabel)
+{
+	struct xfs_sb		*sbp = &mp->m_sb;
+	char			label[XFSLABEL_MAX + 1];
+	size_t			len;
+	int			error;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	/*
+	 * The generic ioctl allows up to FSLABEL_MAX chars, but XFS is much
+	 * smaller, at 12 bytes.  We copy one more to be sure we find the
+	 * (required) NULL character to test the incoming label length.
+	 * NB: The on disk label doesn't need to be null terminated.
+	 */
+	if (copy_from_user(label, newlabel, XFSLABEL_MAX + 1))
+		return -EFAULT;
+	len = strnlen(label, XFSLABEL_MAX + 1);
+	if (len > sizeof(sbp->sb_fname))
+		return -EINVAL;
+
+	error = mnt_want_write_file(filp);
+	if (error)
+		return error;
+
+	spin_lock(&mp->m_sb_lock);
+	memset(sbp->sb_fname, 0, sizeof(sbp->sb_fname));
+	strncpy(sbp->sb_fname, label, sizeof(sbp->sb_fname));
+	spin_unlock(&mp->m_sb_lock);
+
+	/*
+	 * Now we do several things to satisfy userspace.
+	 * In addition to normal logging of the primary superblock, we also
+	 * immediately write these changes to sector zero for the primary, then
+	 * update all backup supers (as xfs_db does for a label change), then
+	 * invalidate the block device page cache.  This is so that any prior
+	 * buffered reads from userspace (i.e. from blkid) are invalidated,
+	 * and userspace will see the newly-written label.
+	 */
+	error = xfs_sync_sb_buf(mp);
+	if (error)
+		goto out;
+	/*
+	 * growfs also updates backup supers so lock against that.
+	 */
+	mutex_lock(&mp->m_growlock);
+	error = xfs_update_secondary_sbs(mp);
+	mutex_unlock(&mp->m_growlock);
+
+	invalidate_bdev(mp->m_ddev_targp->bt_bdev);
+
+out:
+	mnt_drop_write_file(filp);
+	return error;
+}
+
 /*
  * Note: some of the ioctl's return positive numbers as a
  * byte count indicating success, such as readlink_by_handle.
@@ -1676,6 +1758,10 @@ xfs_file_ioctl(
 	switch (cmd) {
 	case FITRIM:
 		return xfs_ioc_trim(mp, arg);
+	case FS_IOC_GETFSLABEL:
+		return xfs_ioc_getlabel(mp, arg);
+	case FS_IOC_SETFSLABEL:
+		return xfs_ioc_setlabel(filp, mp, arg);
 	case XFS_IOC_ALLOCSP:
 	case XFS_IOC_FREESP:
 	case XFS_IOC_RESVSP:
