seccomp: remove 2-phase API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Kees Cook <keescook@chromium.org>
commit 8112c4f140fa03f9ee68aad2cc79afa7df5418d3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8112c4f1.failed

Since nothing is using the 2-phase API, and it adds more complexity than
benefit, remove it.

	Signed-off-by: Kees Cook <keescook@chromium.org>
	Cc: Andy Lutomirski <luto@kernel.org>
(cherry picked from commit 8112c4f140fa03f9ee68aad2cc79afa7df5418d3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/seccomp.h
#	kernel/seccomp.c
diff --cc include/linux/seccomp.h
index 9687691799ff,ecc296c137cd..000000000000
--- a/include/linux/seccomp.h
+++ b/include/linux/seccomp.h
@@@ -27,19 -27,17 +27,25 @@@ struct seccomp 
  	struct seccomp_filter *filter;
  };
  
 -#ifdef CONFIG_HAVE_ARCH_SECCOMP_FILTER
 -extern int __secure_computing(const struct seccomp_data *sd);
 -static inline int secure_computing(const struct seccomp_data *sd)
 +extern int __secure_computing(int);
 +static inline int secure_computing(int this_syscall)
  {
  	if (unlikely(test_thread_flag(TIF_SECCOMP)))
 -		return  __secure_computing(sd);
 +		return  __secure_computing(this_syscall);
  	return 0;
  }
++<<<<<<< HEAD
 +
 +/* A wrapper for architectures supporting only SECCOMP_MODE_STRICT. */
 +static inline void secure_computing_strict(int this_syscall)
 +{
 +	BUG_ON(secure_computing(this_syscall) != 0);
 +}
++=======
+ #else
+ extern void secure_computing_strict(int this_syscall);
+ #endif
++>>>>>>> 8112c4f140fa (seccomp: remove 2-phase API)
  
  extern long prctl_get_seccomp(void);
  extern long prctl_set_seccomp(unsigned long, char __user *);
diff --cc kernel/seccomp.c
index 42e55449c1a5,14a37d71b612..000000000000
--- a/kernel/seccomp.c
+++ b/kernel/seccomp.c
@@@ -201,10 -173,13 +201,14 @@@ static int seccomp_check_filter(struct 
   *
   * Returns valid seccomp BPF response codes.
   */
++<<<<<<< HEAD
 +static u32 seccomp_run_filters(int syscall)
++=======
+ static u32 seccomp_run_filters(const struct seccomp_data *sd)
++>>>>>>> 8112c4f140fa (seccomp: remove 2-phase API)
  {
 -	struct seccomp_data sd_local;
 +	struct seccomp_filter *f = ACCESS_ONCE(current->seccomp.filter);
  	u32 ret = SECCOMP_RET_ALLOW;
 -	/* Make sure cross-thread synced filter points somewhere sane. */
 -	struct seccomp_filter *f =
 -			lockless_dereference(current->seccomp.filter);
  
  	/* Ensure unexpected behavior doesn't result in failing open. */
  	if (unlikely(WARN_ON(f == NULL)))
@@@ -551,18 -518,48 +555,41 @@@ static int mode1_syscalls[] = 
  	0, /* null terminated */
  };
  
 -static void __secure_computing_strict(int this_syscall)
 -{
 -	const int *syscall_whitelist = mode1_syscalls;
  #ifdef CONFIG_COMPAT
 -	if (in_compat_syscall())
 -		syscall_whitelist = get_compat_mode1_syscalls();
 -#endif
 -	do {
 -		if (*syscall_whitelist == this_syscall)
 -			return;
 -	} while (*++syscall_whitelist);
 -
 -#ifdef SECCOMP_DEBUG
 -	dump_stack();
 +static int mode1_syscalls_32[] = {
 +	__NR_seccomp_read_32, __NR_seccomp_write_32, __NR_seccomp_exit_32, __NR_seccomp_sigreturn_32,
 +	0, /* null terminated */
 +};
  #endif
 -	audit_seccomp(this_syscall, SIGKILL, SECCOMP_RET_KILL);
 -	do_exit(SIGKILL);
 -}
  
 -#ifndef CONFIG_HAVE_ARCH_SECCOMP_FILTER
 -void secure_computing_strict(int this_syscall)
 +int __secure_computing(int this_syscall)
  {
++<<<<<<< HEAD
 +	int exit_sig = 0;
 +	int *syscall;
 +	u32 ret;
++=======
+ 	int mode = current->seccomp.mode;
+ 
+ 	if (config_enabled(CONFIG_CHECKPOINT_RESTORE) &&
+ 	    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))
+ 		return;
+ 
+ 	if (mode == SECCOMP_MODE_DISABLED)
+ 		return;
+ 	else if (mode == SECCOMP_MODE_STRICT)
+ 		__secure_computing_strict(this_syscall);
+ 	else
+ 		BUG();
+ }
+ #else
+ 
+ #ifdef CONFIG_SECCOMP_FILTER
+ static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd)
+ {
+ 	u32 filter_ret, action;
+ 	int data;
++>>>>>>> 8112c4f140fa (seccomp: remove 2-phase API)
  
  	/*
  	 * Make sure that any changes to mode from another thread have
@@@ -570,85 -567,97 +597,178 @@@
  	 */
  	rmb();
  
++<<<<<<< HEAD
 +	switch (current->seccomp.mode) {
 +	case SECCOMP_MODE_STRICT:
 +		syscall = mode1_syscalls;
 +#ifdef CONFIG_COMPAT
 +		if (is_compat_task())
 +			syscall = mode1_syscalls_32;
 +#endif
 +		do {
 +			if (*syscall == this_syscall)
 +				return 0;
 +		} while (*++syscall);
 +		exit_sig = SIGKILL;
 +		ret = SECCOMP_RET_KILL;
 +		break;
 +#ifdef CONFIG_SECCOMP_FILTER
 +	case SECCOMP_MODE_FILTER: {
 +		int data;
 +		struct pt_regs *regs = task_pt_regs(current);
 +		ret = seccomp_run_filters(this_syscall);
 +		data = ret & SECCOMP_RET_DATA;
 +		ret &= SECCOMP_RET_ACTION;
 +		switch (ret) {
 +		case SECCOMP_RET_ERRNO:
 +			/* Set the low-order 16-bits as a errno. */
 +			syscall_set_return_value(current, regs,
 +						 -data, 0);
 +			goto skip;
 +		case SECCOMP_RET_TRAP:
 +			/* Show the handler the original registers. */
 +			syscall_rollback(current, regs);
 +			/* Let the filter pass back 16 bits of data. */
 +			seccomp_send_sigsys(this_syscall, data);
 +			goto skip;
 +		case SECCOMP_RET_TRACE:
 +			/* Skip these calls if there is no tracer. */
 +			if (!ptrace_event_enabled(current, PTRACE_EVENT_SECCOMP)) {
 +				syscall_set_return_value(current, regs,
 +							 -ENOSYS, 0);
 +				goto skip;
 +			}
 +			/* Allow the BPF to provide the event message */
 +			ptrace_event(PTRACE_EVENT_SECCOMP, data);
 +			/*
 +			 * The delivery of a fatal signal during event
 +			 * notification may silently skip tracer notification.
 +			 * Terminating the task now avoids executing a system
 +			 * call that may not be intended.
 +			 */
 +			if (fatal_signal_pending(current))
 +				break;
 +			if (syscall_get_nr(current, regs) < 0)
 +				goto skip;  /* Explicit request to skip. */
 +
 +			return 0;
 +		case SECCOMP_RET_ALLOW:
 +			return 0;
 +		case SECCOMP_RET_KILL:
 +		default:
 +			break;
 +		}
 +		exit_sig = SIGSYS;
 +		break;
 +	}
 +#endif
++=======
+ 	filter_ret = seccomp_run_filters(sd);
+ 	data = filter_ret & SECCOMP_RET_DATA;
+ 	action = filter_ret & SECCOMP_RET_ACTION;
+ 
+ 	switch (action) {
+ 	case SECCOMP_RET_ERRNO:
+ 		/* Set low-order bits as an errno, capped at MAX_ERRNO. */
+ 		if (data > MAX_ERRNO)
+ 			data = MAX_ERRNO;
+ 		syscall_set_return_value(current, task_pt_regs(current),
+ 					 -data, 0);
+ 		goto skip;
+ 
+ 	case SECCOMP_RET_TRAP:
+ 		/* Show the handler the original registers. */
+ 		syscall_rollback(current, task_pt_regs(current));
+ 		/* Let the filter pass back 16 bits of data. */
+ 		seccomp_send_sigsys(this_syscall, data);
+ 		goto skip;
+ 
+ 	case SECCOMP_RET_TRACE:
+ 		/* ENOSYS these calls if there is no tracer attached. */
+ 		if (!ptrace_event_enabled(current, PTRACE_EVENT_SECCOMP)) {
+ 			syscall_set_return_value(current,
+ 						 task_pt_regs(current),
+ 						 -ENOSYS, 0);
+ 			goto skip;
+ 		}
+ 
+ 		/* Allow the BPF to provide the event message */
+ 		ptrace_event(PTRACE_EVENT_SECCOMP, data);
+ 		/*
+ 		 * The delivery of a fatal signal during event
+ 		 * notification may silently skip tracer notification.
+ 		 * Terminating the task now avoids executing a system
+ 		 * call that may not be intended.
+ 		 */
+ 		if (fatal_signal_pending(current))
+ 			do_exit(SIGSYS);
+ 		/* Check if the tracer forced the syscall to be skipped. */
+ 		this_syscall = syscall_get_nr(current, task_pt_regs(current));
+ 		if (this_syscall < 0)
+ 			goto skip;
+ 
+ 		return 0;
+ 
+ 	case SECCOMP_RET_ALLOW:
+ 		return 0;
+ 
+ 	case SECCOMP_RET_KILL:
+ 	default:
+ 		audit_seccomp(this_syscall, SIGSYS, action);
+ 		do_exit(SIGSYS);
+ 	}
+ 
+ 	unreachable();
+ 
+ skip:
+ 	audit_seccomp(this_syscall, 0, action);
+ 	return -1;
+ }
+ #else
+ static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd)
+ {
+ 	BUG();
+ }
+ #endif
+ 
+ int __secure_computing(const struct seccomp_data *sd)
+ {
+ 	int mode = current->seccomp.mode;
+ 	int this_syscall;
+ 
+ 	if (config_enabled(CONFIG_CHECKPOINT_RESTORE) &&
+ 	    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))
+ 		return 0;
+ 
+ 	this_syscall = sd ? sd->nr :
+ 		syscall_get_nr(current, task_pt_regs(current));
+ 
+ 	switch (mode) {
+ 	case SECCOMP_MODE_STRICT:
+ 		__secure_computing_strict(this_syscall);  /* may call do_exit */
+ 		return 0;
+ 	case SECCOMP_MODE_FILTER:
+ 		return __seccomp_filter(this_syscall, sd);
++>>>>>>> 8112c4f140fa (seccomp: remove 2-phase API)
  	default:
  		BUG();
  	}
 +
 +#ifdef SECCOMP_DEBUG
 +	dump_stack();
 +#endif
 +	audit_seccomp(this_syscall, exit_sig, ret);
 +	do_exit(exit_sig);
 +#ifdef CONFIG_SECCOMP_FILTER
 +skip:
 +	audit_seccomp(this_syscall, exit_sig, ret);
 +#endif
 +	return -1;
  }
++<<<<<<< HEAD
++=======
+ #endif /* CONFIG_HAVE_ARCH_SECCOMP_FILTER */
++>>>>>>> 8112c4f140fa (seccomp: remove 2-phase API)
  
  long prctl_get_seccomp(void)
  {
* Unmerged path include/linux/seccomp.h
* Unmerged path kernel/seccomp.c
