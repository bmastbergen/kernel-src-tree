md/raid1/10: add missed blk plug

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [md] raid1/10: add missed blk plug (Nigel Croxon) [1494474]
Rebuild_FUZZ: 95.08%
commit-author Shaohua Li <shli@fb.com>
commit 18022a1bd3709b74ca31ef0b28fccd52bcd6c504
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/18022a1b.failed

flush_pending_writes isn't always called with block plug, so add it, and plug
works in nested way.

	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit 18022a1bd3709b74ca31ef0b28fccd52bcd6c504)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid1.c
diff --cc drivers/md/raid1.c
index e54d0416ed5a,6df398e3a008..000000000000
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@@ -824,22 -815,9 +826,28 @@@ static void flush_pending_writes(struc
  		bio = bio_list_get(&conf->pending_bio_list);
  		conf->pending_count = 0;
  		spin_unlock_irq(&conf->device_lock);
++<<<<<<< HEAD
 +		/* flush any pending bitmap writes to
 +		 * disk before proceeding w/ I/O */
 +		bitmap_unplug(conf->mddev->bitmap);
 +		wake_up(&conf->wait_barrier);
 +
 +		while (bio) { /* submit pending writes */
 +			struct bio *next = bio->bi_next;
 +			bio->bi_next = NULL;
 +			if (unlikely((bio->bi_rw & REQ_DISCARD) &&
 +			    !blk_queue_discard(bdev_get_queue(bio->bi_bdev))))
 +				/* Just ignore it */
 +				bio_endio(bio, 0);
 +			else
 +				generic_make_request(bio);
 +			bio = next;
 +		}
++=======
+ 		blk_start_plug(&plug);
+ 		flush_bio_list(conf, bio);
+ 		blk_finish_plug(&plug);
++>>>>>>> 18022a1bd370 (md/raid1/10: add missed blk plug)
  	} else
  		spin_unlock_irq(&conf->device_lock);
  }
* Unmerged path drivers/md/raid1.c
diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c
index 17d84aee79e2..d7bbcf21081c 100644
--- a/drivers/md/raid10.c
+++ b/drivers/md/raid10.c
@@ -960,10 +960,13 @@ static void flush_pending_writes(struct r10conf *conf)
 	spin_lock_irq(&conf->device_lock);
 
 	if (conf->pending_bio_list.head) {
+		struct blk_plug plug;
 		struct bio *bio;
+
 		bio = bio_list_get(&conf->pending_bio_list);
 		conf->pending_count = 0;
 		spin_unlock_irq(&conf->device_lock);
+		blk_start_plug(&plug);
 		/* flush any pending bitmap writes to disk
 		 * before proceeding w/ I/O */
 		bitmap_unplug(conf->mddev->bitmap);
@@ -980,6 +983,7 @@ static void flush_pending_writes(struct r10conf *conf)
 				generic_make_request(bio);
 			bio = next;
 		}
+		blk_finish_plug(&plug);
 	} else
 		spin_unlock_irq(&conf->device_lock);
 }
