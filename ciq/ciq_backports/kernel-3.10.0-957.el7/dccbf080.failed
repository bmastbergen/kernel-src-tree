libceph, ceph: change ceph_calc_file_object_mapping() signature

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ilya Dryomov <idryomov@gmail.com>
commit dccbf08005df800f5c8e948ab6132ed5536134bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/dccbf080.failed

- make it void
- xlen (object extent length) out parameter should be u32 because only
  a single stripe unit is mapped at a time

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
	Reviewed-by: Alex Elder <elder@linaro.org>
(cherry picked from commit dccbf08005df800f5c8e948ab6132ed5536134bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ceph/osdmap.c
diff --cc net/ceph/osdmap.c
index f24224ba4cf0,e3ebbe2ecdad..000000000000
--- a/net/ceph/osdmap.c
+++ b/net/ceph/osdmap.c
@@@ -2121,72 -2141,38 +2121,84 @@@ bool ceph_osds_changed(const struct cep
  }
  
  /*
 - * Map a file extent to a stripe unit within an object.
 - * Fill in objno, offset into object, and object extent length (i.e. the
 - * number of bytes mapped, less than or equal to @l->stripe_unit).
 - *
 - * Example for stripe_count = 3, stripes_per_object = 4:
 + * calculate file layout from given offset, length.
 + * fill in correct oid, logical length, and object extent
 + * offset, length.
   *
 - * blockno   |  0  3  6  9 |  1  4  7 10 |  2  5  8 11 | 12 15 18 21 | 13 16 19
 - * stripeno  |  0  1  2  3 |  0  1  2  3 |  0  1  2  3 |  4  5  6  7 |  4  5  6
 - * stripepos |      0      |      1      |      2      |      0      |      1
 - * objno     |      0      |      1      |      2      |      3      |      4
 - * objsetno  |                    0                    |                    1
 + * for now, we write only a single su, until we can
 + * pass a stride back to the caller.
   */
++<<<<<<< HEAD
 +int ceph_calc_file_object_mapping(struct ceph_file_layout *layout,
 +				   u64 off, u64 len,
 +				   u64 *ono,
 +				   u64 *oxoff, u64 *oxlen)
++=======
+ void ceph_calc_file_object_mapping(struct ceph_file_layout *l,
+ 				   u64 off, u64 len,
+ 				   u64 *objno, u64 *objoff, u32 *xlen)
 -{
 -	u32 stripes_per_object = l->object_size / l->stripe_unit;
 -	u64 blockno;	/* which su in the file (i.e. globally) */
 -	u32 blockoff;	/* offset into su */
 -	u64 stripeno;	/* which stripe */
 -	u32 stripepos;	/* which su in the stripe,
 -			   which object in the object set */
 -	u64 objsetno;	/* which object set */
 -	u32 objsetpos;	/* which stripe in the object set */
++>>>>>>> dccbf08005df (libceph, ceph: change ceph_calc_file_object_mapping() signature)
 +{
 +	u32 osize = le32_to_cpu(layout->fl_object_size);
 +	u32 su = le32_to_cpu(layout->fl_stripe_unit);
 +	u32 sc = le32_to_cpu(layout->fl_stripe_count);
 +	u32 bl, stripeno, stripepos, objsetno;
 +	u32 su_per_object;
 +	u64 t, su_offset;
 +
 +	dout("mapping %llu~%llu  osize %u fl_su %u\n", off, len,
 +	     osize, su);
 +	if (su == 0 || sc == 0)
 +		goto invalid;
 +	su_per_object = osize / su;
 +	if (su_per_object == 0)
 +		goto invalid;
 +	dout("osize %u / su %u = su_per_object %u\n", osize, su,
 +	     su_per_object);
 +
++<<<<<<< HEAD
 +	if ((su & ~PAGE_MASK) != 0)
 +		goto invalid;
 +
 +	/* bl = *off / su; */
 +	t = off;
 +	do_div(t, su);
 +	bl = t;
 +	dout("off %llu / su %u = bl %u\n", off, su, bl);
 +
 +	stripeno = bl / sc;
 +	stripepos = bl % sc;
 +	objsetno = stripeno / su_per_object;
 +
 +	*ono = objsetno * sc + stripepos;
 +	dout("objset %u * sc %u = ono %u\n", objsetno, sc, (unsigned int)*ono);
 +
 +	/* *oxoff = *off % layout->fl_stripe_unit;  # offset in su */
 +	t = off;
 +	su_offset = do_div(t, su);
 +	*oxoff = su_offset + (stripeno % su_per_object) * su;
  
 -	blockno = div_u64_rem(off, l->stripe_unit, &blockoff);
 -	stripeno = div_u64_rem(blockno, l->stripe_count, &stripepos);
 -	objsetno = div_u64_rem(stripeno, stripes_per_object, &objsetpos);
 +	/*
 +	 * Calculate the length of the extent being written to the selected
 +	 * object. This is the minimum of the full length requested (len) or
 +	 * the remainder of the current stripe being written to.
 +	 */
 +	*oxlen = min_t(u64, len, su - su_offset);
  
 +	dout(" obj extent %llu~%llu\n", *oxoff, *oxlen);
 +	return 0;
 +
 +invalid:
 +	dout(" invalid layout\n");
 +	*ono = 0;
 +	*oxoff = 0;
 +	*oxlen = 0;
 +	return -EINVAL;
++=======
+ 	*objno = objsetno * l->stripe_count + stripepos;
+ 	*objoff = objsetpos * l->stripe_unit + blockoff;
+ 	*xlen = min_t(u64, len, l->stripe_unit - blockoff);
++>>>>>>> dccbf08005df (libceph, ceph: change ceph_calc_file_object_mapping() signature)
  }
  EXPORT_SYMBOL(ceph_calc_file_object_mapping);
  
diff --git a/fs/ceph/addr.c b/fs/ceph/addr.c
index adf7d1009bc0..3ce065046554 100644
--- a/fs/ceph/addr.c
+++ b/fs/ceph/addr.c
@@ -880,19 +880,15 @@ get_more_pages:
 			if (locked_pages == 0) {
 				u64 objnum;
 				u64 objoff;
+				u32 xlen;
 
 				/* prepare async write request */
 				offset = (u64)page_offset(page);
-				len = wsize;
-
-				rc = ceph_calc_file_object_mapping(&ci->i_layout,
-								offset, len,
-								&objnum, &objoff,
-								&len);
-				if (rc < 0) {
-					unlock_page(page);
-					break;
-				}
+				ceph_calc_file_object_mapping(&ci->i_layout,
+							      offset, wsize,
+							      &objnum, &objoff,
+							      &xlen);
+				len = xlen;
 
 				num_ops = 1;
 				strip_unit_end = page->index +
diff --git a/fs/ceph/ioctl.c b/fs/ceph/ioctl.c
index c4904b66320d..cb5a65b5d5fe 100644
--- a/fs/ceph/ioctl.c
+++ b/fs/ceph/ioctl.c
@@ -184,7 +184,7 @@ static long ceph_ioctl_get_dataloc(struct file *file, void __user *arg)
 		&ceph_sb_to_client(inode->i_sb)->client->osdc;
 	struct ceph_object_locator oloc;
 	CEPH_DEFINE_OID_ONSTACK(oid);
-	u64 len = 1, olen;
+	u32 xlen;
 	u64 tmp;
 	struct ceph_pg pgid;
 	int r;
@@ -194,13 +194,8 @@ static long ceph_ioctl_get_dataloc(struct file *file, void __user *arg)
 		return -EFAULT;
 
 	down_read(&osdc->lock);
-	r = ceph_calc_file_object_mapping(&ci->i_layout, dl.file_offset, len,
-					  &dl.object_no, &dl.object_offset,
-					  &olen);
-	if (r < 0) {
-		up_read(&osdc->lock);
-		return -EIO;
-	}
+	ceph_calc_file_object_mapping(&ci->i_layout, dl.file_offset, 1,
+				      &dl.object_no, &dl.object_offset, &xlen);
 	dl.file_offset -= dl.object_offset;
 	dl.object_size = ceph_file_layout_object_size(ci->i_layout);
 	dl.block_size = ceph_file_layout_su(ci->i_layout);
diff --git a/include/linux/ceph/osdmap.h b/include/linux/ceph/osdmap.h
index c104d9166429..1a7d7664fdf6 100644
--- a/include/linux/ceph/osdmap.h
+++ b/include/linux/ceph/osdmap.h
@@ -279,10 +279,9 @@ bool ceph_osds_changed(const struct ceph_osds *old_acting,
 		       const struct ceph_osds *new_acting,
 		       bool any_change);
 
-/* calculate mapping of a file extent to an object */
-extern int ceph_calc_file_object_mapping(struct ceph_file_layout *layout,
-					 u64 off, u64 len,
-					 u64 *bno, u64 *oxoff, u64 *oxlen);
+void ceph_calc_file_object_mapping(struct ceph_file_layout *l,
+				   u64 off, u64 len,
+				   u64 *objno, u64 *objoff, u32 *xlen);
 
 int __ceph_object_locator_to_pg(struct ceph_pg_pool_info *pi,
 				const struct ceph_object_id *oid,
diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c
index 105036300de0..3064423dbe29 100644
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@ -102,13 +102,12 @@ static int calc_layout(struct ceph_file_layout *layout, u64 off, u64 *plen,
 			u64 *objnum, u64 *objoff, u64 *objlen)
 {
 	u64 orig_len = *plen;
-	int r;
+	u32 xlen;
 
 	/* object extent? */
-	r = ceph_calc_file_object_mapping(layout, off, orig_len, objnum,
-					  objoff, objlen);
-	if (r < 0)
-		return r;
+	ceph_calc_file_object_mapping(layout, off, orig_len, objnum,
+					  objoff, &xlen);
+	*objlen = xlen;
 	if (*objlen < orig_len) {
 		*plen = *objlen;
 		dout(" skipping last %llu, final file extent %llu~%llu\n",
@@ -116,7 +115,6 @@ static int calc_layout(struct ceph_file_layout *layout, u64 off, u64 *plen,
 	}
 
 	dout("calc_layout objnum=%llx %llu~%llu\n", *objnum, *objoff, *objlen);
-
 	return 0;
 }
 
* Unmerged path net/ceph/osdmap.c
