Drivers: hv: vmbus: Remove x86-isms from arch independent drivers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [hv] vmbus: Remove x86-isms from arch independent drivers (Mohammed Gamal) [1551622]
Rebuild_FUZZ: 88.89%
commit-author Michael Kelley <mikelley@microsoft.com>
commit 4a5f3cde4d51c7afce859aed9d74d197751896d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4a5f3cde.failed

hv_is_hypercall_page_setup() is used to check if Hyper-V is
initialized, but a 'hypercall page' is an x86 implementation detail
that isn't necessarily present on other architectures. Rename to the
architecture independent hv_is_hyperv_initialized() and add check
that x86_hyper is pointing to Hyper-V.  Use this function instead of
direct references to x86-specific data structures in vmbus_drv.c,
and remove now redundant call in hv_init(). Also remove 'x86' from
the string name passed to cpuhp_setup_state().

	Signed-off-by: Michael Kelley <mikelley@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 4a5f3cde4d51c7afce859aed9d74d197751896d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/mshyperv.h
#	drivers/hv/vmbus_drv.c
diff --cc arch/x86/include/asm/mshyperv.h
index f72c56f6993c,b623a4288e8b..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -312,8 -311,8 +312,13 @@@ static inline int hv_cpu_number_to_vp_n
  void hyperv_init(void);
  void hyperv_setup_mmu_ops(void);
  void hyper_alloc_mmu(void);
++<<<<<<< HEAD
 +void hyperv_report_panic(struct pt_regs *regs);
 +bool hv_is_hypercall_page_setup(void);
++=======
+ void hyperv_report_panic(struct pt_regs *regs, long err);
+ bool hv_is_hyperv_initialized(void);
++>>>>>>> 4a5f3cde4d51 (Drivers: hv: vmbus: Remove x86-isms from arch independent drivers)
  void hyperv_cleanup(void);
  #else /* CONFIG_HYPERV */
  static inline void hyperv_init(void) {}
diff --cc drivers/hv/vmbus_drv.c
index 6942c2cfdf23,398643bb67e2..000000000000
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@@ -35,8 -34,9 +35,7 @@@
  #include <linux/kernel_stat.h>
  #include <linux/clockchips.h>
  #include <linux/cpu.h>
 -#include <linux/sched/task_stack.h>
 -
  #include <asm/hyperv.h>
- #include <asm/hypervisor.h>
  #include <asm/mshyperv.h>
  #include <linux/notifier.h>
  #include <linux/ptrace.h>
@@@ -1093,10 -1052,11 +1092,18 @@@ static int vmbus_bus_init(void
  	 * Initialize the per-cpu interrupt state and
  	 * connect to the host.
  	 */
++<<<<<<< HEAD
 +	cpu_notifier_register_begin();
 +	on_each_cpu(hv_synic_init_oncpu, NULL, 1);
 +	__register_hotcpu_notifier(&hv_cpuhp_notifier);
 +	cpu_notifier_register_done();
++=======
+ 	ret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "hyperv/vmbus:online",
+ 				hv_synic_init, hv_synic_cleanup);
+ 	if (ret < 0)
+ 		goto err_alloc;
+ 	hyperv_cpuhp_online = ret;
++>>>>>>> 4a5f3cde4d51 (Drivers: hv: vmbus: Remove x86-isms from arch independent drivers)
  
  	ret = vmbus_connect();
  	if (ret)
@@@ -1593,7 -1716,7 +1600,11 @@@ static int __init hv_acpi_init(void
  {
  	int ret, t;
  
++<<<<<<< HEAD
 +	if (x86_hyper != &x86_hyper_ms_hyperv)
++=======
+ 	if (!hv_is_hyperv_initialized())
++>>>>>>> 4a5f3cde4d51 (Drivers: hv: vmbus: Remove x86-isms from arch independent drivers)
  		return -ENODEV;
  
  	init_completion(&probe_event);
diff --git a/arch/x86/hyperv/hv_init.c b/arch/x86/hyperv/hv_init.c
index aa0dc08ef297..63ababf8d0e8 100644
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@ -264,17 +264,24 @@ void hyperv_report_panic(struct pt_regs *regs)
 }
 EXPORT_SYMBOL_GPL(hyperv_report_panic);
 
-bool hv_is_hypercall_page_setup(void)
+bool hv_is_hyperv_initialized(void)
 {
 	union hv_x64_msr_hypercall_contents hypercall_msr;
 
-	/* Check if the hypercall page is setup */
+	/*
+	 * Ensure that we're really on Hyper-V, and not a KVM or Xen
+	 * emulation of Hyper-V
+	 */
+	if (x86_hyper_type != X86_HYPER_MS_HYPERV)
+		return false;
+
+	/*
+	 * Verify that earlier initialization succeeded by checking
+	 * that the hypercall page is setup
+	 */
 	hypercall_msr.as_uint64 = 0;
 	rdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
 
-	if (!hypercall_msr.enable)
-		return false;
-
-	return true;
+	return hypercall_msr.enable;
 }
-EXPORT_SYMBOL_GPL(hv_is_hypercall_page_setup);
+EXPORT_SYMBOL_GPL(hv_is_hyperv_initialized);
* Unmerged path arch/x86/include/asm/mshyperv.h
diff --git a/drivers/hv/hv.c b/drivers/hv/hv.c
index d884d9b662e9..372d4e82ecfb 100644
--- a/drivers/hv/hv.c
+++ b/drivers/hv/hv.c
@@ -49,9 +49,6 @@ struct hv_context hv_context = {
  */
 int hv_init(void)
 {
-	if (!hv_is_hypercall_page_setup())
-		return -ENOTSUPP;
-
 	hv_context.cpu_context = alloc_percpu(struct hv_per_cpu_context);
 	if (!hv_context.cpu_context)
 		return -ENOMEM;
* Unmerged path drivers/hv/vmbus_drv.c
