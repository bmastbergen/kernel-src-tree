tcp: fix a stale ooo_last_skb after a replace

jira LE-1907
cve CVE-2018-5390
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 76f0dcbb5ae1a7c3dbeec13dd98233b8e6b0b32a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/76f0dcbb.failed

When skb replaces another one in ooo queue, I forgot to also
update tp->ooo_last_skb as well, if the replaced skb was the last one
in the queue.

To fix this, we simply can re-use the code that runs after an insertion,
trying to merge skbs at the right of current skb.

This not only fixes the bug, but also remove all small skbs that might
be a subset of the new one.

Example:

We receive segments 2001:3001,  4001:5001

Then we receive 2001:8001 : We should replace 2001:3001 with the big
skb, but also remove 4001:50001 from the queue to save space.

packetdrill test demonstrating the bug

0.000 socket(..., SOCK_STREAM, IPPROTO_TCP) = 3
+0 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
+0 bind(3, ..., ...) = 0
+0 listen(3, 1) = 0

+0 < S 0:0(0) win 32792 <mss 1000,sackOK,nop,nop,nop,wscale 7>
+0 > S. 0:0(0) ack 1 <mss 1460,nop,nop,sackOK,nop,wscale 7>
+0.100 < . 1:1(0) ack 1 win 1024
+0 accept(3, ..., ...) = 4

+0.01 < . 1001:2001(1000) ack 1 win 1024
+0    > . 1:1(0) ack 1 <nop,nop, sack 1001:2001>

+0.01 < . 1001:3001(2000) ack 1 win 1024
+0    > . 1:1(0) ack 1 <nop,nop, sack 1001:2001 1001:3001>

Fixes: 9f5afeae5152 ("tcp: use an RB tree for ooo receive queue")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reported-by: Yuchung Cheng <ycheng@google.com>
	Cc: Yaogong Wang <wygivan@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 76f0dcbb5ae1a7c3dbeec13dd98233b8e6b0b32a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_input.c
diff --cc net/ipv4/tcp_input.c
index 4ec1e4f8ab44,dad3e7eeed94..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -4327,72 -4451,73 +4327,113 @@@ static void tcp_data_queue_ofo(struct s
  		goto end;
  	}
  
 -	/* In the typical case, we are adding an skb to the end of the list.
 -	 * Use of ooo_last_skb avoids the O(Log(N)) rbtree lookup.
 -	 */
 -	if (tcp_try_coalesce(sk, tp->ooo_last_skb, skb, &fragstolen)) {
 -coalesce_done:
 -		tcp_grow_window(sk, skb);
 -		kfree_skb_partial(skb, fragstolen);
 -		skb = NULL;
 -		goto add_sack;
 -	}
 -	/* Can avoid an rbtree lookup if we are adding skb after ooo_last_skb */
 -	if (!before(seq, TCP_SKB_CB(tp->ooo_last_skb)->end_seq)) {
 -		parent = &tp->ooo_last_skb->rbnode;
 -		p = &parent->rb_right;
 -		goto insert;
 +	seq = TCP_SKB_CB(skb)->seq;
 +	end_seq = TCP_SKB_CB(skb)->end_seq;
 +
 +	if (seq == TCP_SKB_CB(skb1)->end_seq) {
 +		bool fragstolen;
 +
 +		if (!tcp_try_coalesce(sk, skb1, skb, &fragstolen)) {
 +			__skb_queue_after(&tp->out_of_order_queue, skb1, skb);
 +		} else {
 +			tcp_grow_window(sk, skb);
 +			kfree_skb_partial(skb, fragstolen);
 +			skb = NULL;
 +		}
 +
 +		if (!tp->rx_opt.num_sacks ||
 +		    tp->selective_acks[0].end_seq != seq)
 +			goto add_sack;
 +
 +		/* Common case: data arrive in order after hole. */
 +		tp->selective_acks[0].end_seq = end_seq;
 +		goto end;
  	}
  
 -	/* Find place to insert this segment. Handle overlaps on the way. */
 -	parent = NULL;
 -	while (*p) {
 -		parent = *p;
 -		skb1 = rb_entry(parent, struct sk_buff, rbnode);
 -		if (before(seq, TCP_SKB_CB(skb1)->seq)) {
 -			p = &parent->rb_left;
 -			continue;
 +	/* Find place to insert this segment. */
 +	while (1) {
 +		if (!after(TCP_SKB_CB(skb1)->seq, seq))
 +			break;
 +		if (skb_queue_is_first(&tp->out_of_order_queue, skb1)) {
 +			skb1 = NULL;
 +			break;
  		}
++<<<<<<< HEAD
 +		skb1 = skb_queue_prev(&tp->out_of_order_queue, skb1);
++=======
+ 		if (before(seq, TCP_SKB_CB(skb1)->end_seq)) {
+ 			if (!after(end_seq, TCP_SKB_CB(skb1)->end_seq)) {
+ 				/* All the bits are present. Drop. */
+ 				NET_INC_STATS(sock_net(sk),
+ 					      LINUX_MIB_TCPOFOMERGE);
+ 				__kfree_skb(skb);
+ 				skb = NULL;
+ 				tcp_dsack_set(sk, seq, end_seq);
+ 				goto add_sack;
+ 			}
+ 			if (after(seq, TCP_SKB_CB(skb1)->seq)) {
+ 				/* Partial overlap. */
+ 				tcp_dsack_set(sk, seq, TCP_SKB_CB(skb1)->end_seq);
+ 			} else {
+ 				/* skb's seq == skb1's seq and skb covers skb1.
+ 				 * Replace skb1 with skb.
+ 				 */
+ 				rb_replace_node(&skb1->rbnode, &skb->rbnode,
+ 						&tp->out_of_order_queue);
+ 				tcp_dsack_extend(sk,
+ 						 TCP_SKB_CB(skb1)->seq,
+ 						 TCP_SKB_CB(skb1)->end_seq);
+ 				NET_INC_STATS(sock_net(sk),
+ 					      LINUX_MIB_TCPOFOMERGE);
+ 				__kfree_skb(skb1);
+ 				goto merge_right;
+ 			}
+ 		} else if (tcp_try_coalesce(sk, skb1, skb, &fragstolen)) {
+ 			goto coalesce_done;
+ 		}
+ 		p = &parent->rb_right;
++>>>>>>> 76f0dcbb5ae1 (tcp: fix a stale ooo_last_skb after a replace)
  	}
 -insert:
 -	/* Insert segment into RB tree. */
 -	rb_link_node(&skb->rbnode, parent, p);
 -	rb_insert_color(&skb->rbnode, &tp->out_of_order_queue);
  
++<<<<<<< HEAD
 +	/* Do skb overlap to previous one? */
 +	if (skb1 && before(seq, TCP_SKB_CB(skb1)->end_seq)) {
 +		if (!after(end_seq, TCP_SKB_CB(skb1)->end_seq)) {
 +			/* All the bits are present. Drop. */
 +			NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPOFOMERGE);
 +			__kfree_skb(skb);
 +			skb = NULL;
 +			tcp_dsack_set(sk, seq, end_seq);
 +			goto add_sack;
 +		}
 +		if (after(seq, TCP_SKB_CB(skb1)->seq)) {
 +			/* Partial overlap. */
 +			tcp_dsack_set(sk, seq,
 +				      TCP_SKB_CB(skb1)->end_seq);
 +		} else {
 +			if (skb_queue_is_first(&tp->out_of_order_queue,
 +					       skb1))
 +				skb1 = NULL;
 +			else
 +				skb1 = skb_queue_prev(
 +					&tp->out_of_order_queue,
 +					skb1);
 +		}
 +	}
 +	if (!skb1)
 +		__skb_queue_head(&tp->out_of_order_queue, skb);
 +	else
 +		__skb_queue_after(&tp->out_of_order_queue, skb1, skb);
 +
 +	/* And clean segments covered by new one as whole. */
 +	while (!skb_queue_is_last(&tp->out_of_order_queue, skb)) {
 +		skb1 = skb_queue_next(&tp->out_of_order_queue, skb);
++=======
+ merge_right:
+ 	/* Remove other segments covered by skb. */
+ 	while ((q = rb_next(&skb->rbnode)) != NULL) {
+ 		skb1 = rb_entry(q, struct sk_buff, rbnode);
++>>>>>>> 76f0dcbb5ae1 (tcp: fix a stale ooo_last_skb after a replace)
  
  		if (!after(end_seq, TCP_SKB_CB(skb1)->seq))
  			break;
* Unmerged path net/ipv4/tcp_input.c
