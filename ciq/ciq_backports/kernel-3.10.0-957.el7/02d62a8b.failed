nvme-fc: release io queues to allow fast fail

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author James Smart <jsmart2021@gmail.com>
commit 02d62a8bc48e92171c46540722e2d52ce77d87af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/02d62a8b.failed

Rather than leaving io queues quiesced after tearing down an association,
restart them. This allows ios to be replayed, with fastfail ios terminating
and non-fastfail getting into loops of retry.

This follows rdma's lead.

	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Sagi Grimberg <sagi@grimber.me>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 02d62a8bc48e92171c46540722e2d52ce77d87af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/fc.c
diff --cc drivers/nvme/host/fc.c
index d165c0527376,41d45a1b5c62..000000000000
--- a/drivers/nvme/host/fc.c
+++ b/drivers/nvme/host/fc.c
@@@ -2920,47 -2807,6 +2923,50 @@@ nvme_fc_delete_ctrl_work(struct work_st
  	 * waiting for io to terminate
  	 */
  	nvme_fc_delete_association(ctrl);
++<<<<<<< HEAD
 +
 +	/*
 +	 * tear down the controller
 +	 * After the last reference on the nvme ctrl is removed,
 +	 * the transport nvme_fc_nvme_ctrl_freed() callback will be
 +	 * invoked. From there, the transport will tear down it's
 +	 * logical queues and association.
 +	 */
 +	nvme_uninit_ctrl(&ctrl->ctrl);
 +
 +	nvme_put_ctrl(&ctrl->ctrl);
 +}
 +
 +static int
 +__nvme_fc_del_ctrl(struct nvme_fc_ctrl *ctrl)
 +{
 +	if (!nvme_change_ctrl_state(&ctrl->ctrl, NVME_CTRL_DELETING))
 +		return -EBUSY;
 +	if (!queue_work(nvme_wq, &ctrl->delete_work))
 +		return -EBUSY;
 +	return 0;
 +}
 +
 +/*
 + * Request from nvme core layer to delete the controller
 + */
 +static int
 +nvme_fc_del_nvme_ctrl(struct nvme_ctrl *nctrl)
 +{
 +	struct nvme_fc_ctrl *ctrl = to_fc_ctrl(nctrl);
 +	int ret;
 +
 +	if (!kref_get_unless_zero(&ctrl->ctrl.kref))
 +		return -EBUSY;
 +
 +	ret = __nvme_fc_del_ctrl(ctrl);
 +	if (!ret)
 +		flush_work(&ctrl->delete_work);
 +	nvme_put_ctrl(&ctrl->ctrl);
 +
 +	return ret;
++=======
++>>>>>>> 02d62a8bc48e (nvme-fc: release io queues to allow fast fail)
  }
  
  static void
* Unmerged path drivers/nvme/host/fc.c
