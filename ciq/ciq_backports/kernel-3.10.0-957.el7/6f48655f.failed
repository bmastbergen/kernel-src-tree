target: Fix node_acl demo-mode + uncached dynamic shutdown regression

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [target] Fix node_acl demo-mode + uncached dynamic shutdown regression (Maurizio Lombardi) [1585081]
Rebuild_FUZZ: 93.85%
commit-author Nicholas Bellinger <nab@linux-iscsi.org>
commit 6f48655facfd7f7ccfe6d252ac0fe319ab02e4dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6f48655f.failed

This patch fixes a generate_node_acls = 1 + cache_dynamic_acls = 0
regression, that was introduced by

  commit 01d4d673558985d9a118e1e05026633c3e2ade9b
  Author: Nicholas Bellinger <nab@linux-iscsi.org>
  Date:   Wed Dec 7 12:55:54 2016 -0800

which originally had the proper list_del_init() usage, but was
dropped during list review as it was thought unnecessary by HCH.

However, list_del_init() usage is required during the special
generate_node_acls = 1 + cache_dynamic_acls = 0 case when
transport_free_session() does a list_del(&se_nacl->acl_list),
followed by target_complete_nacl() doing the same thing.

This was manifesting as a general protection fault as reported
by Justin:

kernel: general protection fault: 0000 [#1] SMP
kernel: Modules linked in:
kernel: CPU: 0 PID: 11047 Comm: iscsi_ttx Not tainted 4.13.0-rc2.x86_64.1+ #20
kernel: Hardware name: Intel Corporation S5500BC/S5500BC, BIOS S5500.86B.01.00.0064.050520141428 05/05/2014
kernel: task: ffff88026939e800 task.stack: ffffc90007884000
kernel: RIP: 0010:target_put_nacl+0x49/0xb0
kernel: RSP: 0018:ffffc90007887d70 EFLAGS: 00010246
kernel: RAX: dead000000000200 RBX: ffff8802556ca000 RCX: 0000000000000000
kernel: RDX: dead000000000100 RSI: 0000000000000246 RDI: ffff8802556ce028
kernel: RBP: ffffc90007887d88 R08: 0000000000000001 R09: 0000000000000000
kernel: R10: ffffc90007887df8 R11: ffffea0009986900 R12: ffff8802556ce020
kernel: R13: ffff8802556ce028 R14: ffff8802556ce028 R15: ffffffff88d85540
kernel: FS:  0000000000000000(0000) GS:ffff88027fc00000(0000) knlGS:0000000000000000
kernel: CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
kernel: CR2: 00007fffe36f5f94 CR3: 0000000009209000 CR4: 00000000003406f0
kernel: DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
kernel: DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
kernel: Call Trace:
kernel:  transport_free_session+0x67/0x140
kernel:  transport_deregister_session+0x7a/0xc0
kernel:  iscsit_close_session+0x92/0x210
kernel:  iscsit_close_connection+0x5f9/0x840
kernel:  iscsit_take_action_for_connection_exit+0xfe/0x110
kernel:  iscsi_target_tx_thread+0x140/0x1e0
kernel:  ? wait_woken+0x90/0x90
kernel:  kthread+0x124/0x160
kernel:  ? iscsit_thread_get_cpumask+0x90/0x90
kernel:  ? kthread_create_on_node+0x40/0x40
kernel:  ret_from_fork+0x22/0x30
kernel: Code: 00 48 89 fb 4c 8b a7 48 01 00 00 74 68 4d 8d 6c 24 08 4c
89 ef e8 e8 28 43 00 48 8b 93 20 04 00 00 48 8b 83 28 04 00 00 4c 89
ef <48> 89 42 08 48 89 10 48 b8 00 01 00 00 00 00 ad de 48 89 83 20
kernel: RIP: target_put_nacl+0x49/0xb0 RSP: ffffc90007887d70
kernel: ---[ end trace f12821adbfd46fed ]---

To address this, go ahead and use proper list_del_list() for all
cases of se_nacl->acl_list deletion.

	Reported-by: Justin Maggard <jmaggard01@gmail.com>
	Tested-by: Justin Maggard <jmaggard01@gmail.com>
	Cc: Justin Maggard <jmaggard01@gmail.com>
	Cc: stable@vger.kernel.org # 4.1+
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 6f48655facfd7f7ccfe6d252ac0fe319ab02e4dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_transport.c
diff --cc drivers/target/target_core_transport.c
index 556c74ae1874,836d552b0385..000000000000
--- a/drivers/target/target_core_transport.c
+++ b/drivers/target/target_core_transport.c
@@@ -481,8 -458,20 +481,23 @@@ static void target_complete_nacl(struc
  {
  	struct se_node_acl *nacl = container_of(kref,
  				struct se_node_acl, acl_kref);
 -	struct se_portal_group *se_tpg = nacl->se_tpg;
  
++<<<<<<< HEAD
 +	complete(&nacl->acl_free_comp);
++=======
+ 	if (!nacl->dynamic_stop) {
+ 		complete(&nacl->acl_free_comp);
+ 		return;
+ 	}
+ 
+ 	mutex_lock(&se_tpg->acl_node_mutex);
+ 	list_del_init(&nacl->acl_list);
+ 	mutex_unlock(&se_tpg->acl_node_mutex);
+ 
+ 	core_tpg_wait_for_nacl_pr_ref(nacl);
+ 	core_free_device_list_for_node(nacl, se_tpg);
+ 	kfree(nacl);
++>>>>>>> 6f48655facfd (target: Fix node_acl demo-mode + uncached dynamic shutdown regression)
  }
  
  void target_put_nacl(struct se_node_acl *nacl)
@@@ -528,7 -518,33 +543,32 @@@ void transport_free_session(struct se_s
  	 * core_tpg_get_initiator_node_acl().
  	 */
  	if (se_nacl) {
 -		struct se_portal_group *se_tpg = se_nacl->se_tpg;
 -		const struct target_core_fabric_ops *se_tfo = se_tpg->se_tpg_tfo;
 -		unsigned long flags;
 -
  		se_sess->se_node_acl = NULL;
++<<<<<<< HEAD
++=======
+ 
+ 		/*
+ 		 * Also determine if we need to drop the extra ->cmd_kref if
+ 		 * it had been previously dynamically generated, and
+ 		 * the endpoint is not caching dynamic ACLs.
+ 		 */
+ 		mutex_lock(&se_tpg->acl_node_mutex);
+ 		if (se_nacl->dynamic_node_acl &&
+ 		    !se_tfo->tpg_check_demo_mode_cache(se_tpg)) {
+ 			spin_lock_irqsave(&se_nacl->nacl_sess_lock, flags);
+ 			if (list_empty(&se_nacl->acl_sess_list))
+ 				se_nacl->dynamic_stop = true;
+ 			spin_unlock_irqrestore(&se_nacl->nacl_sess_lock, flags);
+ 
+ 			if (se_nacl->dynamic_stop)
+ 				list_del_init(&se_nacl->acl_list);
+ 		}
+ 		mutex_unlock(&se_tpg->acl_node_mutex);
+ 
+ 		if (se_nacl->dynamic_stop)
+ 			target_put_nacl(se_nacl);
+ 
++>>>>>>> 6f48655facfd (target: Fix node_acl demo-mode + uncached dynamic shutdown regression)
  		target_put_nacl(se_nacl);
  	}
  	if (se_sess->sess_cmd_map) {
diff --git a/drivers/target/target_core_tpg.c b/drivers/target/target_core_tpg.c
index d7652d7aa394..6f0b19324de0 100644
--- a/drivers/target/target_core_tpg.c
+++ b/drivers/target/target_core_tpg.c
@@ -373,7 +373,7 @@ void core_tpg_del_initiator_node_acl(struct se_node_acl *acl)
 	mutex_lock(&tpg->acl_node_mutex);
 	if (acl->dynamic_node_acl)
 		acl->dynamic_node_acl = 0;
-	list_del(&acl->acl_list);
+	list_del_init(&acl->acl_list);
 	mutex_unlock(&tpg->acl_node_mutex);
 
 	target_shutdown_sessions(acl, true);
@@ -557,7 +557,7 @@ int core_tpg_deregister(struct se_portal_group *se_tpg)
 	 * in transport_deregister_session().
 	 */
 	list_for_each_entry_safe(nacl, nacl_tmp, &node_list, acl_list) {
-		list_del(&nacl->acl_list);
+		list_del_init(&nacl->acl_list);
 
 		core_tpg_wait_for_nacl_pr_ref(nacl);
 		core_free_device_list_for_node(nacl, se_tpg);
* Unmerged path drivers/target/target_core_transport.c
