xfs: fix COW writeback race

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Christoph Hellwig <hch@lst.de>
commit d2b3964a0780d2d2994eba57f950d6c9fe489ed8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d2b3964a.failed

Due to the way how xfs_iomap_write_allocate tries to convert the whole
found extents from delalloc to real space we can run into a race
condition with multiple threads doing writes to this same extent.
For the non-COW case that is harmless as the only thing that can happen
is that we call xfs_bmapi_write on an extent that has already been
converted to a real allocation.  For COW writes where we move the extent
from the COW to the data fork after I/O completion the race is, however,
not quite as harmless.  In the worst case we are now calling
xfs_bmapi_write on a region that contains hole in the COW work, which
will trip up an assert in debug builds or lead to file system corruption
in non-debug builds.  This seems to be reproducible with workloads of
small O_DSYNC write, although so far I've not managed to come up with
a with an isolated reproducer.

The fix for the issue is relatively simple:  tell xfs_bmapi_write
that we are only asked to convert delayed allocations and skip holes
in that case.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit d2b3964a0780d2d2994eba57f950d6c9fe489ed8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/libxfs/xfs_bmap.h
#	fs/xfs/xfs_iomap.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 733d4b0952d3,ab82dd4a4980..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -4522,9 -4601,39 +4520,42 @@@ xfs_bmapi_write
  	bma.firstblock = firstblock;
  
  	while (bno < end && n < *nmap) {
- 		inhole = eof || bma.got.br_startoff > bno;
- 		wasdelay = !inhole && isnullstartblock(bma.got.br_startblock);
+ 		bool			need_alloc = false, wasdelay = false;
+ 
++<<<<<<< HEAD
++=======
+ 		/* in hole or beyoned EOF? */
+ 		if (eof || bma.got.br_startoff > bno) {
+ 			if (flags & XFS_BMAPI_DELALLOC) {
+ 				/*
+ 				 * For the COW fork we can reasonably get a
+ 				 * request for converting an extent that races
+ 				 * with other threads already having converted
+ 				 * part of it, as there converting COW to
+ 				 * regular blocks is not protected using the
+ 				 * IOLOCK.
+ 				 */
+ 				ASSERT(flags & XFS_BMAPI_COWFORK);
+ 				if (!(flags & XFS_BMAPI_COWFORK)) {
+ 					error = -EIO;
+ 					goto error0;
+ 				}
+ 
+ 				if (eof || bno >= end)
+ 					break;
+ 			} else {
+ 				need_alloc = true;
+ 			}
+ 		} else {
+ 			/*
+ 			 * Make sure we only reflink into a hole.
+ 			 */
+ 			ASSERT(!(flags & XFS_BMAPI_REMAP));
+ 			if (isnullstartblock(bma.got.br_startblock))
+ 				wasdelay = true;
+ 		}
  
++>>>>>>> d2b3964a0780 (xfs: fix COW writeback race)
  		/*
  		 * First, deal with the hole before the allocated space
  		 * that we found, if any.
diff --cc fs/xfs/libxfs/xfs_bmap.h
index b02804fe53c5,cdef87db5262..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.h
+++ b/fs/xfs/libxfs/xfs_bmap.h
@@@ -96,6 -97,22 +96,25 @@@ struct xfs_extent_free_ite
   */
  #define XFS_BMAPI_ZERO		0x080
  
++<<<<<<< HEAD
++=======
+ /*
+  * Map the inode offset to the block given in ap->firstblock.  Primarily
+  * used for reflink.  The range must be in a hole, and this flag cannot be
+  * turned on with PREALLOC or CONVERT, and cannot be used on the attr fork.
+  *
+  * For bunmapi, this flag unmaps the range without adjusting quota, reducing
+  * refcount, or freeing the blocks.
+  */
+ #define XFS_BMAPI_REMAP		0x100
+ 
+ /* Map something in the CoW fork. */
+ #define XFS_BMAPI_COWFORK	0x200
+ 
+ /* Only convert delalloc space, don't allocate entirely new extents */
+ #define XFS_BMAPI_DELALLOC	0x400
+ 
++>>>>>>> d2b3964a0780 (xfs: fix COW writeback race)
  #define XFS_BMAPI_FLAGS \
  	{ XFS_BMAPI_ENTIRE,	"ENTIRE" }, \
  	{ XFS_BMAPI_METADATA,	"METADATA" }, \
@@@ -104,7 -121,10 +123,14 @@@
  	{ XFS_BMAPI_IGSTATE,	"IGSTATE" }, \
  	{ XFS_BMAPI_CONTIG,	"CONTIG" }, \
  	{ XFS_BMAPI_CONVERT,	"CONVERT" }, \
++<<<<<<< HEAD
 +	{ XFS_BMAPI_ZERO,	"ZERO" }
++=======
+ 	{ XFS_BMAPI_ZERO,	"ZERO" }, \
+ 	{ XFS_BMAPI_REMAP,	"REMAP" }, \
+ 	{ XFS_BMAPI_COWFORK,	"COWFORK" }, \
+ 	{ XFS_BMAPI_DELALLOC,	"DELALLOC" }
++>>>>>>> d2b3964a0780 (xfs: fix COW writeback race)
  
  
  static inline int xfs_bmapi_aflag(int w)
diff --cc fs/xfs/xfs_iomap.c
index 936cba6f7d93,1aa3abd67b36..000000000000
--- a/fs/xfs/xfs_iomap.c
+++ b/fs/xfs/xfs_iomap.c
@@@ -701,8 -681,12 +701,12 @@@ xfs_iomap_write_allocate
  	xfs_trans_t	*tp;
  	int		nimaps;
  	int		error = 0;
++<<<<<<< HEAD
++=======
+ 	int		flags = XFS_BMAPI_DELALLOC;
++>>>>>>> d2b3964a0780 (xfs: fix COW writeback race)
  	int		nres;
  
 -	if (whichfork == XFS_COW_FORK)
 -		flags |= XFS_BMAPI_COWFORK;
 -
  	/*
  	 * Make sure that the dquots are there.
  	 */
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
* Unmerged path fs/xfs/libxfs/xfs_bmap.h
* Unmerged path fs/xfs/xfs_iomap.c
