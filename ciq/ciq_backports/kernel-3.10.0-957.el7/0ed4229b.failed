ipv6: defrag: drop non-last frags smaller than min mtu

jira LE-1907
cve CVE-2018-5391
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Florian Westphal <fw@strlen.de>
commit 0ed4229b08c13c84a3c301a08defdc9e7f4467e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0ed4229b.failed

don't bother with pathological cases, they only waste cycles.
IPv6 requires a minimum MTU of 1280 so we should never see fragments
smaller than this (except last frag).

v3: don't use awkward "-offset + len"
v2: drop IPv4 part, which added same check w. IPV4_MIN_MTU (68).
    There were concerns that there could be even smaller frags
    generated by intermediate nodes, e.g. on radio networks.

	Cc: Peter Oskolkov <posk@google.com>
	Cc: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0ed4229b08c13c84a3c301a08defdc9e7f4467e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/reassembly.c
diff --cc net/ipv6/reassembly.c
index ea7d2560bf2a,5c5b4f79296e..000000000000
--- a/net/ipv6/reassembly.c
+++ b/net/ipv6/reassembly.c
@@@ -554,14 -456,14 +554,23 @@@ static int ipv6_frag_rcv(struct sk_buf
  		return 1;
  	}
  
++<<<<<<< HEAD
 +	evicted = inet_frag_evictor(&net->ipv6.frags, &ip6_frags, false);
 +	if (evicted)
 +		IP6_ADD_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),
 +				 IPSTATS_MIB_REASMFAILS, evicted);
 +
 +	fq = fq_find(net, fhdr->identification, &hdr->saddr, &hdr->daddr,
 +		     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));
++=======
+ 	if (skb->len - skb_network_offset(skb) < IPV6_MIN_MTU &&
+ 	    fhdr->frag_off & htons(IP6_MF))
+ 		goto fail_hdr;
+ 
+ 	iif = skb->dev ? skb->dev->ifindex : 0;
+ 	fq = fq_find(net, fhdr->identification, hdr, iif);
++>>>>>>> 0ed4229b08c1 (ipv6: defrag: drop non-last frags smaller than min mtu)
  	if (fq) {
 -		u32 prob_offset = 0;
  		int ret;
  
  		spin_lock(&fq->q.lock);
diff --git a/net/ipv6/netfilter/nf_conntrack_reasm.c b/net/ipv6/netfilter/nf_conntrack_reasm.c
index 9bbd5893ebea..4320cccb64b6 100644
--- a/net/ipv6/netfilter/nf_conntrack_reasm.c
+++ b/net/ipv6/netfilter/nf_conntrack_reasm.c
@@ -602,6 +602,10 @@ struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)
 	inet_frag_evictor(&net->nf_frag.frags, &nf_frags, false);
 	local_bh_enable();
 
+	if (skb->len - skb_network_offset(skb) < IPV6_MIN_MTU &&
+	    fhdr->frag_off & htons(IP6_MF))
+		return -EINVAL;
+
 	skb_orphan(skb);
 	fq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,
 		     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));
* Unmerged path net/ipv6/reassembly.c
