tcmu: release blocks for partially setup cmds

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Mike Christie <mchristi@redhat.com>
commit 810b8153c4243d2012a6ec002ddd3bbc9a9ae8c2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/810b8153.failed

If we cannot setup a cmd because we run out of ring space
or global pages release the blocks before sleeping. This
prevents a deadlock where dev0 has waiting_blocks set and
needs N blocks, but dev1 to devX have each allocated N / X blocks
and also hit the global block limit so they went to sleep.

find_free_blocks is not able to take the sleeping dev's
blocks becaause their waiting_blocks is set and even
if it was not the block returned by find_last_bit could equal
dbi_max. The latter will probably never happen because
DATA_BLOCK_BITS is so high but in the next patches
DATA_BLOCK_BITS and TCMU_GLOBAL_MAX_BLOCKS will be settable so
it might be lower and could happen.

	Signed-off-by: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 810b8153c4243d2012a6ec002ddd3bbc9a9ae8c2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_user.c
diff --cc drivers/target/target_core_user.c
index 2ac4515b6a67,c7541f090453..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -642,10 -807,12 +642,19 @@@ tcmu_queue_cmd_ring(struct tcmu_cmd *tc
  		int ret;
  		DEFINE_WAIT(__wait);
  
++<<<<<<< HEAD
 +		if (!udev->qfull_time_out) {
 +			spin_unlock_irq(&udev->cmdr_lock);
 +			return TCM_OUT_OF_RESOURCES;
 +		}
++=======
+ 		/*
+ 		 * Don't leave commands partially setup because the unmap
+ 		 * thread might need the blocks to make forward progress.
+ 		 */
+ 		tcmu_cmd_free_data(tcmu_cmd, tcmu_cmd->dbi_cur);
+ 		tcmu_cmd_reset_dbi_cur(tcmu_cmd);
++>>>>>>> 810b8153c424 (tcmu: release blocks for partially setup cmds)
  
  		prepare_to_wait(&udev->wait_cmdr, &__wait, TASK_INTERRUPTIBLE);
  
* Unmerged path drivers/target/target_core_user.c
