netfilter: ipset: Use netlink callback dump args only

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 93302880d8a3e5dc6b7da3f9825beb839152c940
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/93302880.failed

Instead of cb->data, use callback dump args only and introduce symbolic
names instead of plain numbers at accessing the argument members.

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 93302880d8a3e5dc6b7da3f9825beb839152c940)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_bitmap_gen.h
#	net/netfilter/ipset/ip_set_core.c
#	net/netfilter/ipset/ip_set_list_set.c
diff --cc net/netfilter/ipset/ip_set_bitmap_gen.h
index 01a340ce9e94,f2c7d83dc23f..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_gen.h
+++ b/net/netfilter/ipset/ip_set_bitmap_gen.h
@@@ -178,9 -203,10 +178,16 @@@ mtype_list(const struct ip_set *set
  	adt = ipset_nest_start(skb, IPSET_ATTR_ADT);
  	if (!adt)
  		return -EMSGSIZE;
++<<<<<<< HEAD
 +	for (; cb->args[2] < map->elements; cb->args[2]++) {
 +		id = cb->args[2];
 +		x = get_ext(map, id);
++=======
+ 	for (; cb->args[IPSET_CB_ARG0] < map->elements;
+ 	     cb->args[IPSET_CB_ARG0]++) {
+ 		id = cb->args[IPSET_CB_ARG0];
+ 		x = get_ext(set, map, id);
++>>>>>>> 93302880d8a3 (netfilter: ipset: Use netlink callback dump args only)
  		if (!test_bit(id, map->members) ||
  		    (SET_WITH_TIMEOUT(set) &&
  #ifdef IP_SET_BITMAP_STORED_TIMEOUT
diff --cc net/netfilter/ipset/ip_set_core.c
index 99fcd252e259,bac7e01df67f..000000000000
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@@ -1121,10 -1182,12 +1121,19 @@@ ip_set_swap(struct sock *ctnl, struct s
  static int
  ip_set_dump_done(struct netlink_callback *cb)
  {
++<<<<<<< HEAD
 +	struct ip_set_net *inst = (struct ip_set_net *)cb->data;
 +	if (cb->args[2]) {
 +		pr_debug("release set %s\n", ip_set(inst, cb->args[1])->name);
 +		__ip_set_put_netlink(ip_set(inst, (ip_set_id_t)cb->args[1]));
++=======
+ 	struct ip_set_net *inst = (struct ip_set_net *)cb->args[IPSET_CB_NET];
+ 	if (cb->args[IPSET_CB_ARG0]) {
+ 		pr_debug("release set %s\n",
+ 			 nfnl_set(inst, cb->args[IPSET_CB_INDEX])->name);
+ 		__ip_set_put_byindex(inst,
+ 			(ip_set_id_t) cb->args[IPSET_CB_INDEX]);
++>>>>>>> 93302880d8a3 (netfilter: ipset: Use netlink callback dump args only)
  	}
  	return 0;
  }
@@@ -1190,13 -1254,12 +1200,13 @@@ ip_set_dump_start(struct sk_buff *skb, 
  	struct ip_set *set = NULL;
  	struct nlmsghdr *nlh = NULL;
  	unsigned int flags = NETLINK_CB(cb->skb).portid ? NLM_F_MULTI : 0;
+ 	struct ip_set_net *inst = ip_set_pernet(sock_net(skb->sk));
  	u32 dump_type, dump_flags;
 +	bool is_destroyed;
  	int ret = 0;
- 	struct ip_set_net *inst = (struct ip_set_net *)cb->data;
  
- 	if (!cb->args[0]) {
- 		ret = dump_init(cb);
+ 	if (!cb->args[IPSET_CB_DUMP]) {
+ 		ret = dump_init(cb, inst);
  		if (ret < 0) {
  			nlh = nlmsg_hdr(cb->skb);
  			/* We have to create and send the error message
@@@ -1207,22 -1270,20 +1217,32 @@@
  		}
  	}
  
- 	if (cb->args[1] >= inst->ip_set_max)
+ 	if (cb->args[IPSET_CB_INDEX] >= inst->ip_set_max)
  		goto out;
  
- 	dump_type = DUMP_TYPE(cb->args[0]);
- 	dump_flags = DUMP_FLAGS(cb->args[0]);
- 	max = dump_type == DUMP_ONE ? cb->args[1] + 1 : inst->ip_set_max;
+ 	dump_type = DUMP_TYPE(cb->args[IPSET_CB_DUMP]);
+ 	dump_flags = DUMP_FLAGS(cb->args[IPSET_CB_DUMP]);
+ 	max = dump_type == DUMP_ONE ? cb->args[IPSET_CB_INDEX] + 1
+ 				    : inst->ip_set_max;
  dump_last:
++<<<<<<< HEAD
 +	pr_debug("args[0]: %u %u args[1]: %ld\n",
 +		 dump_type, dump_flags, cb->args[1]);
 +	for (; cb->args[1] < max; cb->args[1]++) {
 +		index = (ip_set_id_t) cb->args[1];
 +		write_lock_bh(&ip_set_ref_lock);
 +		set = ip_set(inst, index);
 +		is_destroyed = inst->is_destroyed;
 +		if (!set || is_destroyed) {
 +			write_unlock_bh(&ip_set_ref_lock);
++=======
+ 	pr_debug("dump type, flag: %u %u index: %ld\n",
+ 		 dump_type, dump_flags, cb->args[IPSET_CB_INDEX]);
+ 	for (; cb->args[IPSET_CB_INDEX] < max; cb->args[IPSET_CB_INDEX]++) {
+ 		index = (ip_set_id_t) cb->args[IPSET_CB_INDEX];
+ 		set = nfnl_set(inst, index);
+ 		if (set == NULL) {
++>>>>>>> 93302880d8a3 (netfilter: ipset: Use netlink callback dump args only)
  			if (dump_type == DUMP_ONE) {
  				ret = -ENOENT;
  				goto out;
@@@ -1239,17 -1295,14 +1259,17 @@@
  		 */
  		if (dump_type != DUMP_ONE &&
  		    ((dump_type == DUMP_ALL) ==
 -		     !!(set->type->features & IPSET_DUMP_LAST)))
 +		     !!(set->type->features & IPSET_DUMP_LAST))) {
 +			write_unlock_bh(&ip_set_ref_lock);
  			continue;
 +		}
  		pr_debug("List set: %s\n", set->name);
- 		if (!cb->args[2]) {
+ 		if (!cb->args[IPSET_CB_ARG0]) {
  			/* Start listing: make sure set won't be destroyed */
  			pr_debug("reference set\n");
 -			__ip_set_get(set);
 +			set->ref_netlink++;
  		}
 +		write_unlock_bh(&ip_set_ref_lock);
  		nlh = start_msg(skb, NETLINK_CB(cb->skb).portid,
  				cb->nlh->nlmsg_seq, flags,
  				IPSET_CMD_LIST);
@@@ -1301,15 -1354,15 +1321,22 @@@ nla_put_failure
  	ret = -EFAULT;
  next_set:
  	if (dump_type == DUMP_ONE)
- 		cb->args[1] = IPSET_INVALID_ID;
+ 		cb->args[IPSET_CB_INDEX] = IPSET_INVALID_ID;
  	else
- 		cb->args[1]++;
+ 		cb->args[IPSET_CB_INDEX]++;
  release_refcount:
  	/* If there was an error or set is done, release set */
++<<<<<<< HEAD
 +	if (ret || !cb->args[2]) {
 +		pr_debug("release set %s\n", ip_set(inst, index)->name);
 +		__ip_set_put_netlink(ip_set(inst, index));
 +		cb->args[2] = 0;
++=======
+ 	if (ret || !cb->args[IPSET_CB_ARG0]) {
+ 		pr_debug("release set %s\n", nfnl_set(inst, index)->name);
+ 		__ip_set_put_byindex(inst, index);
+ 		cb->args[IPSET_CB_ARG0] = 0;
++>>>>>>> 93302880d8a3 (netfilter: ipset: Use netlink callback dump args only)
  	}
  out:
  	if (nlh) {
diff --cc net/netfilter/ipset/ip_set_list_set.c
index a9a97c07ecb4,3e2317f3cf68..000000000000
--- a/net/netfilter/ipset/ip_set_list_set.c
+++ b/net/netfilter/ipset/ip_set_list_set.c
@@@ -515,9 -496,10 +515,16 @@@ list_set_list(const struct ip_set *set
  	atd = ipset_nest_start(skb, IPSET_ATTR_ADT);
  	if (!atd)
  		return -EMSGSIZE;
++<<<<<<< HEAD
 +	for (; cb->args[2] < map->size; cb->args[2]++) {
 +		i = cb->args[2];
 +		e = list_set_elem(map, i);
++=======
+ 	for (; cb->args[IPSET_CB_ARG0] < map->size;
+ 	     cb->args[IPSET_CB_ARG0]++) {
+ 		i = cb->args[IPSET_CB_ARG0];
+ 		e = list_set_elem(set, map, i);
++>>>>>>> 93302880d8a3 (netfilter: ipset: Use netlink callback dump args only)
  		if (e->id == IPSET_INVALID_ID)
  			goto finish;
  		if (SET_WITH_TIMEOUT(set) &&
diff --git a/include/linux/netfilter/ipset/ip_set.h b/include/linux/netfilter/ipset/ip_set.h
index 1309bde24e27..cae75e0b24a5 100644
--- a/include/linux/netfilter/ipset/ip_set.h
+++ b/include/linux/netfilter/ipset/ip_set.h
@@ -254,6 +254,16 @@ ip_set_init_counter(struct ip_set_counter *counter,
 		atomic64_set(&(counter)->packets, (long long)(ext->packets));
 }
 
+/* Netlink CB args */
+enum {
+	IPSET_CB_NET = 0,
+	IPSET_CB_DUMP,
+	IPSET_CB_INDEX,
+	IPSET_CB_ARG0,
+	IPSET_CB_ARG1,
+	IPSET_CB_ARG2,
+};
+
 /* register and unregister set references */
 extern ip_set_id_t ip_set_get_byname(struct net *net,
 				     const char *name, struct ip_set **set);
* Unmerged path net/netfilter/ipset/ip_set_bitmap_gen.h
* Unmerged path net/netfilter/ipset/ip_set_core.c
diff --git a/net/netfilter/ipset/ip_set_hash_gen.h b/net/netfilter/ipset/ip_set_hash_gen.h
index acd02e6a3233..23a2e2e5446e 100644
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@ -859,7 +859,7 @@ mtype_list(const struct ip_set *set,
 	struct nlattr *atd, *nested;
 	const struct hbucket *n;
 	const struct mtype_elem *e;
-	u32 first = cb->args[2];
+	u32 first = cb->args[IPSET_CB_ARG0];
 	/* We assume that one hash bucket fills into one page */
 	void *incomplete;
 	int i;
@@ -868,20 +868,22 @@ mtype_list(const struct ip_set *set,
 	if (!atd)
 		return -EMSGSIZE;
 	pr_debug("list hash set %s\n", set->name);
-	for (; cb->args[2] < jhash_size(t->htable_bits); cb->args[2]++) {
+	for (; cb->args[IPSET_CB_ARG0] < jhash_size(t->htable_bits);
+	     cb->args[IPSET_CB_ARG0]++) {
 		incomplete = skb_tail_pointer(skb);
-		n = hbucket(t, cb->args[2]);
-		pr_debug("cb->args[2]: %lu, t %p n %p\n", cb->args[2], t, n);
+		n = hbucket(t, cb->args[IPSET_CB_ARG0]);
+		pr_debug("cb->arg bucket: %lu, t %p n %p\n",
+			 cb->args[IPSET_CB_ARG0], t, n);
 		for (i = 0; i < n->pos; i++) {
 			e = ahash_data(n, i, h->dsize);
 			if (SET_WITH_TIMEOUT(set) &&
 			    ip_set_timeout_expired(ext_timeout(e, h)))
 				continue;
 			pr_debug("list hash %lu hbucket %p i %u, data %p\n",
-				 cb->args[2], n, i, e);
+				 cb->args[IPSET_CB_ARG0], n, i, e);
 			nested = ipset_nest_start(skb, IPSET_ATTR_DATA);
 			if (!nested) {
-				if (cb->args[2] == first) {
+				if (cb->args[IPSET_CB_ARG0] == first) {
 					nla_nest_cancel(skb, atd);
 					return -EMSGSIZE;
 				} else
@@ -902,16 +904,16 @@ mtype_list(const struct ip_set *set,
 	}
 	ipset_nest_end(skb, atd);
 	/* Set listing finished */
-	cb->args[2] = 0;
+	cb->args[IPSET_CB_ARG0] = 0;
 
 	return 0;
 
 nla_put_failure:
 	nlmsg_trim(skb, incomplete);
-	if (unlikely(first == cb->args[2])) {
+	if (unlikely(first == cb->args[IPSET_CB_ARG0])) {
 		pr_warning("Can't list set %s: one bucket does not fit into "
 			   "a message. Please report it!\n", set->name);
-		cb->args[2] = 0;
+		cb->args[IPSET_CB_ARG0] = 0;
 		return -EMSGSIZE;
 	}
 	ipset_nest_end(skb, atd);
* Unmerged path net/netfilter/ipset/ip_set_list_set.c
