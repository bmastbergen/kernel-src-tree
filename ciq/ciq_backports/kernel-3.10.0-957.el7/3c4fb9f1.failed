usb: typec: wcove: start using tcpm for USB PD support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [usb] typec: wcove: start using tcpm for USB PD support (Torez Smith) [1540721]
Rebuild_FUZZ: 95.15%
commit-author Heikki Krogerus <heikki.krogerus@linux.intel.com>
commit 3c4fb9f169214290ec9a943907321e6265b36f65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3c4fb9f1.failed

This patch makes the driver work with USB Type-C Port
Manager (tcpm.c) to provide USB PD functionality.

	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 3c4fb9f169214290ec9a943907321e6265b36f65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/typec/Kconfig
#	drivers/usb/typec/typec_wcove.c
diff --cc drivers/usb/typec/Kconfig
index bc1b7745f1d4,103cb8bce3e7..000000000000
--- a/drivers/usb/typec/Kconfig
+++ b/drivers/usb/typec/Kconfig
@@@ -4,6 -4,18 +4,21 @@@ menu "USB Power Delivery and Type-C dri
  config TYPEC
  	tristate
  
++<<<<<<< HEAD
++=======
+ config TYPEC_TCPM
+ 	tristate "USB Type-C Port Controller Manager"
+ 	depends on USB
+ 	select TYPEC
+ 	help
+ 	  The Type-C Port Controller Manager provides a USB PD and USB Type-C
+ 	  state machine for use with Type-C Port Controllers.
+ 
+ if TYPEC_TCPM
+ 
+ source "drivers/usb/typec/fusb302/Kconfig"
+ 
++>>>>>>> 3c4fb9f16921 (usb: typec: wcove: start using tcpm for USB PD support)
  config TYPEC_WCOVE
  	tristate "Intel WhiskeyCove PMIC USB Type-C PHY driver"
  	depends on ACPI
diff --cc drivers/usb/typec/typec_wcove.c
index d5a7b21fa3f1,a47a93ad34b7..000000000000
--- a/drivers/usb/typec/typec_wcove.c
+++ b/drivers/usb/typec/typec_wcove.c
@@@ -105,8 -177,7 +177,12 @@@ enum wcove_typec_role 
  	WCOVE_ROLE_DEVICE,
  };
  
++<<<<<<< HEAD
 +static uuid_le uuid = UUID_LE(0x482383f0, 0x2876, 0x4e49,
 +			      0x86, 0x85, 0xdb, 0x66, 0x21, 0x1a, 0xf0, 0x37);
++=======
+ #define WCOVE_DSM_UUID		"482383f0-2876-4e49-8685-db66211af037"
++>>>>>>> 3c4fb9f16921 (usb: typec: wcove: start using tcpm for USB PD support)
  
  static int wcove_typec_func(struct wcove_typec *wcove,
  			    enum wcove_typec_func func, int param)
@@@ -118,7 -189,7 +194,11 @@@
  	tmp.type = ACPI_TYPE_INTEGER;
  	tmp.integer.value = param;
  
++<<<<<<< HEAD
 +	obj = acpi_evaluate_dsm(ACPI_HANDLE(wcove->dev), uuid.b, 1, func,
++=======
+ 	obj = acpi_evaluate_dsm(ACPI_HANDLE(wcove->dev), &wcove->guid, 1, func,
++>>>>>>> 3c4fb9f16921 (usb: typec: wcove: start using tcpm for USB PD support)
  				&argv4);
  	if (!obj) {
  		dev_err(wcove->dev, "%s: failed to evaluate _DSM\n", __func__);
@@@ -303,18 -595,16 +604,24 @@@ static int wcove_typec_probe(struct pla
  	wcove->dev = &pdev->dev;
  	wcove->regmap = pmic->regmap;
  
++<<<<<<< HEAD
 +	ret = regmap_irq_get_virq(pmic->irq_chip_data_level2,
++=======
+ 	irq = regmap_irq_get_virq(pmic->irq_chip_data_chgr,
++>>>>>>> 3c4fb9f16921 (usb: typec: wcove: start using tcpm for USB PD support)
  				  platform_get_irq(pdev, 0));
- 	if (ret < 0)
- 		return ret;
+ 	if (irq < 0)
+ 		return irq;
  
- 	ret = devm_request_threaded_irq(&pdev->dev, ret, NULL,
- 					wcove_typec_irq, IRQF_ONESHOT,
- 					"wcove_typec", wcove);
+ 	ret = guid_parse(WCOVE_DSM_UUID, &wcove->guid);
  	if (ret)
  		return ret;
  
++<<<<<<< HEAD
 +	if (!acpi_check_dsm(ACPI_HANDLE(&pdev->dev), uuid.b, 0, 0x1f)) {
++=======
+ 	if (!acpi_check_dsm(ACPI_HANDLE(&pdev->dev), &wcove->guid, 0, 0x1f)) {
++>>>>>>> 3c4fb9f16921 (usb: typec: wcove: start using tcpm for USB PD support)
  		dev_err(&pdev->dev, "Missing _DSM functions\n");
  		return -ENODEV;
  	}
* Unmerged path drivers/usb/typec/Kconfig
* Unmerged path drivers/usb/typec/typec_wcove.c
