platform/x86: wmi: Require query for data blocks, rename writable to setable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [platform] x86: wmi: Require query for data blocks, rename writable to setable (Jarod Wilson) [1562200]
Rebuild_FUZZ: 93.71%
commit-author Darren Hart (VMware) <dvhart@infradead.org>
commit fd70da6a6267c91fbdda9c560f098cfd52fba00f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/fd70da6a.failed

The Microsoft WMI documentation requires all data blocks to implement
the Query Control Method (WQxx). If we encounter a data block not
implementing this control method, issue a warning, and ignore the data
block. Remove the "readable" attribute as all data blocks must be
readable (query-able).

Be consistent with the language in the documentation, replace the
"writable" attribute with "setable".

Simplify (flatten) the control flow of wmi_create_device a bit while
we are updating it for the above changes.

	Signed-off-by: Darren Hart (VMware) <dvhart@infradead.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Mario Limonciello <mario_limonciello@dell.com>
	Cc: Pali Roh√°r <pali.rohar@gmail.com>
	Cc: linux-kernel@vger.kernel.org
	Cc: platform-driver-x86@vger.kernel.org
	Cc: linux-acpi@vger.kernel.org
	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit fd70da6a6267c91fbdda9c560f098cfd52fba00f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/platform/x86/wmi.c
#	include/linux/wmi.h
diff --cc drivers/platform/x86/wmi.c
index 84dcc7a04b0a,37f6651d1bf7..000000000000
--- a/drivers/platform/x86/wmi.c
+++ b/drivers/platform/x86/wmi.c
@@@ -68,7 -68,8 +68,12 @@@ struct wmi_block 
  	struct acpi_device *acpi_device;
  	wmi_notify_handler handler;
  	void *handler_data;
++<<<<<<< HEAD
 +	struct device dev;
++=======
+ 
+ 	bool read_takes_no_args;
++>>>>>>> fd70da6a6267 (platform/x86: wmi: Require query for data blocks, rename writable to setable)
  };
  
  
@@@ -649,53 -669,228 +654,192 @@@ static struct attribute *wmi_attrs[] = 
  };
  ATTRIBUTE_GROUPS(wmi);
  
++<<<<<<< HEAD
++=======
+ static ssize_t notify_id_show(struct device *dev, struct device_attribute *attr,
+ 			      char *buf)
+ {
+ 	struct wmi_block *wblock = dev_to_wblock(dev);
+ 
+ 	return sprintf(buf, "%02X\n", (unsigned int)wblock->gblock.notify_id);
+ }
+ static DEVICE_ATTR_RO(notify_id);
+ 
+ static struct attribute *wmi_event_attrs[] = {
+ 	&dev_attr_notify_id.attr,
+ 	NULL,
+ };
+ ATTRIBUTE_GROUPS(wmi_event);
+ 
+ static ssize_t object_id_show(struct device *dev, struct device_attribute *attr,
+ 			      char *buf)
+ {
+ 	struct wmi_block *wblock = dev_to_wblock(dev);
+ 
+ 	return sprintf(buf, "%c%c\n", wblock->gblock.object_id[0],
+ 		       wblock->gblock.object_id[1]);
+ }
+ static DEVICE_ATTR_RO(object_id);
+ 
+ static ssize_t setable_show(struct device *dev, struct device_attribute *attr,
+ 			    char *buf)
+ {
+ 	struct wmi_device *wdev = dev_to_wdev(dev);
+ 
+ 	return sprintf(buf, "%d\n", (int)wdev->setable);
+ }
+ static DEVICE_ATTR_RO(setable);
+ 
+ static struct attribute *wmi_data_attrs[] = {
+ 	&dev_attr_object_id.attr,
+ 	&dev_attr_setable.attr,
+ 	NULL,
+ };
+ ATTRIBUTE_GROUPS(wmi_data);
+ 
+ static struct attribute *wmi_method_attrs[] = {
+ 	&dev_attr_object_id.attr,
+ 	NULL,
+ };
+ ATTRIBUTE_GROUPS(wmi_method);
+ 
++>>>>>>> fd70da6a6267 (platform/x86: wmi: Require query for data blocks, rename writable to setable)
  static int wmi_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
  {
 -	struct wmi_block *wblock = dev_to_wblock(dev);
 +	char guid_string[37];
  
 -	if (add_uevent_var(env, "MODALIAS=wmi:%pUL", wblock->gblock.guid))
 -		return -ENOMEM;
 +	struct wmi_block *wblock;
  
 -	if (add_uevent_var(env, "WMI_GUID=%pUL", wblock->gblock.guid))
 +	if (add_uevent_var(env, "MODALIAS="))
  		return -ENOMEM;
  
 -	return 0;
 -}
 -
 -static void wmi_dev_release(struct device *dev)
 -{
 -	struct wmi_block *wblock = dev_to_wblock(dev);
 -
 -	kfree(wblock);
 -}
 -
 -static int wmi_dev_match(struct device *dev, struct device_driver *driver)
 -{
 -	struct wmi_driver *wmi_driver =
 -		container_of(driver, struct wmi_driver, driver);
 -	struct wmi_block *wblock = dev_to_wblock(dev);
 -	const struct wmi_device_id *id = wmi_driver->id_table;
 -
 -	while (id->guid_string) {
 -		uuid_le driver_guid;
 +	wblock = dev_get_drvdata(dev);
 +	if (!wblock)
 +		return -ENOMEM;
  
 -		if (WARN_ON(uuid_le_to_bin(id->guid_string, &driver_guid)))
 -			continue;
 -		if (!memcmp(&driver_guid, wblock->gblock.guid, 16))
 -			return 1;
 +	sprintf(guid_string, "%pUL", wblock->gblock.guid);
  
 -		id++;
 -	}
 +	strcpy(&env->buf[env->buflen - 1], "wmi:");
 +	memcpy(&env->buf[env->buflen - 1 + 4], guid_string, 36);
 +	env->buflen += 40;
  
  	return 0;
  }
  
 -static int wmi_dev_probe(struct device *dev)
 +static void wmi_dev_free(struct device *dev)
  {
 -	struct wmi_block *wblock = dev_to_wblock(dev);
 -	struct wmi_driver *wdriver =
 -		container_of(dev->driver, struct wmi_driver, driver);
 -	int ret = 0;
 -
 -	if (ACPI_FAILURE(wmi_method_enable(wblock, 1)))
 -		dev_warn(dev, "failed to enable device -- probing anyway\n");
 +	struct wmi_block *wmi_block = container_of(dev, struct wmi_block, dev);
  
 -	if (wdriver->probe) {
 -		ret = wdriver->probe(dev_to_wdev(dev));
 -		if (ret != 0 && ACPI_FAILURE(wmi_method_enable(wblock, 0)))
 -			dev_warn(dev, "failed to disable device\n");
 -	}
 -
 -	return ret;
 +	kfree(wmi_block);
  }
  
 -static int wmi_dev_remove(struct device *dev)
 -{
 -	struct wmi_block *wblock = dev_to_wblock(dev);
 -	struct wmi_driver *wdriver =
 -		container_of(dev->driver, struct wmi_driver, driver);
 -	int ret = 0;
 -
 -	if (wdriver->remove)
 -		ret = wdriver->remove(dev_to_wdev(dev));
 -
 -	if (ACPI_FAILURE(wmi_method_enable(wblock, 0)))
 -		dev_warn(dev, "failed to disable device\n");
 -
 -	return ret;
 -}
 -
 -static struct class wmi_bus_class = {
 -	.name = "wmi_bus",
 -};
 -
 -static struct bus_type wmi_bus_type = {
 +static struct class wmi_class = {
  	.name = "wmi",
 +	.dev_release = wmi_dev_free,
 +	.dev_uevent = wmi_dev_uevent,
  	.dev_groups = wmi_groups,
 -	.match = wmi_dev_match,
 -	.uevent = wmi_dev_uevent,
 -	.probe = wmi_dev_probe,
 -	.remove = wmi_dev_remove,
  };
  
++<<<<<<< HEAD
 +static int wmi_create_device(const struct guid_block *gblock,
 +			     struct wmi_block *wblock,
 +			     struct acpi_device *device)
 +{
 +	wblock->dev.class = &wmi_class;
++=======
+ static struct device_type wmi_type_event = {
+ 	.name = "event",
+ 	.groups = wmi_event_groups,
+ 	.release = wmi_dev_release,
+ };
+ 
+ static struct device_type wmi_type_method = {
+ 	.name = "method",
+ 	.groups = wmi_method_groups,
+ 	.release = wmi_dev_release,
+ };
+ 
+ static struct device_type wmi_type_data = {
+ 	.name = "data",
+ 	.groups = wmi_data_groups,
+ 	.release = wmi_dev_release,
+ };
+ 
+ static int wmi_create_device(struct device *wmi_bus_dev,
+ 			     const struct guid_block *gblock,
+ 			     struct wmi_block *wblock,
+ 			     struct acpi_device *device)
+ {
+ 	struct acpi_device_info *info;
+ 	char method[5];
+ 	int result;
+ 
+ 	if (gblock->flags & ACPI_WMI_EVENT) {
+ 		wblock->dev.dev.type = &wmi_type_event;
+ 		goto out_init;
+ 	}
+ 
+ 	if (gblock->flags & ACPI_WMI_METHOD) {
+ 		wblock->dev.dev.type = &wmi_type_method;
+ 		goto out_init;
+ 	}
+ 
+ 	/*
+ 	 * Data Block Query Control Method (WQxx by convention) is
+ 	 * required per the WMI documentation. If it is not present,
+ 	 * we ignore this data block.
+ 	 */
+ 	strcpy(method, "WQ");
+ 	strncat(method, wblock->gblock.object_id, 2);
+ 	result = get_subobj_info(device->handle, method, &info);
+ 
+ 	if (result) {
+ 		dev_warn(wmi_bus_dev,
+ 			 "%s data block query control method not found",
+ 			 method);
+ 		return result;
+ 	}
+ 
+ 	wblock->dev.dev.type = &wmi_type_data;
+ 
+ 	/*
+ 	 * The Microsoft documentation specifically states:
+ 	 *
+ 	 *   Data blocks registered with only a single instance
+ 	 *   can ignore the parameter.
+ 	 *
+ 	 * ACPICA will get mad at us if we call the method with the wrong number
+ 	 * of arguments, so check what our method expects.  (On some Dell
+ 	 * laptops, WQxx may not be a method at all.)
+ 	 */
+ 	if (info->type != ACPI_TYPE_METHOD || info->param_count == 0)
+ 		wblock->read_takes_no_args = true;
+ 
+ 	kfree(info);
+ 
+ 	strcpy(method, "WS");
+ 	strncat(method, wblock->gblock.object_id, 2);
+ 	result = get_subobj_info(device->handle, method, NULL);
+ 
+ 	if (result == 0)
+ 		wblock->dev.setable = true;
+ 
+  out_init:
+ 	wblock->dev.dev.bus = &wmi_bus_type;
+ 	wblock->dev.dev.parent = wmi_bus_dev;
++>>>>>>> fd70da6a6267 (platform/x86: wmi: Require query for data blocks, rename writable to setable)
 +
 +	dev_set_name(&wblock->dev, "%pUL", gblock->guid);
  
 -	dev_set_name(&wblock->dev.dev, "%pUL", gblock->guid);
++<<<<<<< HEAD
 +	dev_set_drvdata(&wblock->dev, wblock);
  
 +	return device_register(&wblock->dev);
++=======
+ 	device_initialize(&wblock->dev.dev);
+ 
+ 	return 0;
++>>>>>>> fd70da6a6267 (platform/x86: wmi: Require query for data blocks, rename writable to setable)
  }
  
  static void wmi_free_devices(struct acpi_device *device)
@@@ -776,18 -979,10 +920,25 @@@ static int parse_wdg(struct acpi_devic
  		wblock->acpi_device = device;
  		wblock->gblock = gblock[i];
  
++<<<<<<< HEAD
 +		/*
 +		  Some WMI devices, like those for nVidia hooks, have a
 +		  duplicate GUID. It's not clear what we should do in this
 +		  case yet, so for now, we'll just ignore the duplicate
 +		  for device creation.
 +		*/
 +		if (!guid_already_parsed(device, gblock[i].guid)) {
 +			retval = wmi_create_device(&gblock[i], wblock, device);
 +			if (retval) {
 +				wmi_free_devices(device);
 +				goto out_free_pointer;
 +			}
++=======
+ 		retval = wmi_create_device(wmi_bus_dev, &gblock[i], wblock, device);
+ 		if (retval) {
+ 			kfree(wblock);
+ 			continue;
++>>>>>>> fd70da6a6267 (platform/x86: wmi: Require query for data blocks, rename writable to setable)
  		}
  
  		list_add_tail(&wblock->list, &wmi_block_list);
* Unmerged path include/linux/wmi.h
* Unmerged path drivers/platform/x86/wmi.c
* Unmerged path include/linux/wmi.h
