PCI: Open-code the two pass loop when scanning bridges

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [pci] Open-code the two pass loop when scanning bridges (Myron Stowe) [1517629]
Rebuild_FUZZ: 95.15%
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 4147c2fd9b12ae1e0bdbb2dbb9a9163c94a10a22
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4147c2fd.failed

The current scanning code is really hard to understand because it calls
the same function in a loop where pass value is changed without any
comments explaining it:

  for (pass = 0; pass < 2; pass++)
    for_each_pci_bridge(dev, bus)
      max = pci_scan_bridge(bus, dev, max, pass);

Unfamiliar reader cannot tell easily what is the purpose of this loop
without looking at internals of pci_scan_bridge().

In order to make this bit easier to understand, open-code the loop in
pci_scan_child_bus() and pci_hp_add_bridge() with added comments.

No functional changes intended.

	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 4147c2fd9b12ae1e0bdbb2dbb9a9163c94a10a22)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/probe.c
diff --cc drivers/pci/probe.c
index 97079cdbf8bd,61813938d186..000000000000
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@@ -2068,9 -2387,18 +2068,9 @@@ void pcie_bus_configure_settings(struc
  }
  EXPORT_SYMBOL_GPL(pcie_bus_configure_settings);
  
 -/*
 - * Called after each bus is probed, but before its children are examined.  This
 - * is marked as __weak because multiple architectures define it.
 - */
 -void __weak pcibios_fixup_bus(struct pci_bus *bus)
 -{
 -       /* nothing to do, expected to be removed in the future */
 -}
 -
  unsigned int pci_scan_child_bus(struct pci_bus *bus)
  {
- 	unsigned int devfn, pass, max = bus->busn_res.start;
+ 	unsigned int devfn, max = bus->busn_res.start;
  	struct pci_dev *dev;
  
  	dev_dbg(&bus->dev, "scanning bus\n");
@@@ -2455,3 -2743,31 +2463,34 @@@ void __init pci_sort_breadthfirst(void
  {
  	bus_sort_breadthfirst(&pci_bus_type, &pci_sort_bf_cmp);
  }
++<<<<<<< HEAD
++=======
+ 
+ int pci_hp_add_bridge(struct pci_dev *dev)
+ {
+ 	struct pci_bus *parent = dev->bus;
+ 	int busnr, start = parent->busn_res.start;
+ 	int end = parent->busn_res.end;
+ 
+ 	for (busnr = start; busnr <= end; busnr++) {
+ 		if (!pci_find_bus(pci_domain_nr(parent), busnr))
+ 			break;
+ 	}
+ 	if (busnr-- > end) {
+ 		dev_err(&dev->dev, "No bus number available for hot-added bridge\n");
+ 		return -1;
+ 	}
+ 
+ 	/* Scan bridges that are already configured */
+ 	busnr = pci_scan_bridge(parent, dev, busnr, 0);
+ 
+ 	/* Scan bridges that need to be reconfigured */
+ 	pci_scan_bridge(parent, dev, busnr, 1);
+ 
+ 	if (!dev->subordinate)
+ 		return -1;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(pci_hp_add_bridge);
++>>>>>>> 4147c2fd9b12 (PCI: Open-code the two pass loop when scanning bridges)
* Unmerged path drivers/pci/probe.c
