iio: Always compute masklength

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iio] Always compute masklength (Tony Camuso) [1559170]
Rebuild_FUZZ: 90.91%
commit-author Lars-Peter Clausen <lars@metafoo.de>
commit 629bc02331f7aae6ef775fb4c15e6d8aa58722f1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/629bc023.failed

Even if no userspace consumer buffer is attached to the IIO device at
registration we still need to compute the masklength, since it is possible
that a in-kernel consumer buffer is going to get attached to the device at
a later point.

	Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit 629bc02331f7aae6ef775fb4c15e6d8aa58722f1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iio/industrialio-buffer.c
diff --cc drivers/iio/industrialio-buffer.c
index ed6b8aa675ce,209c7ad793c5..000000000000
--- a/drivers/iio/industrialio-buffer.c
+++ b/drivers/iio/industrialio-buffer.c
@@@ -379,106 -435,15 +379,131 @@@ static int iio_buffer_add_channel_sysfs
  					     &indio_dev->dev,
  					     &buffer->scan_el_dev_attr_list);
  	if (ret)
 -		return ret;
 +		goto error_ret;
  	attrcount++;
  	ret = attrcount;
 +error_ret:
 +	return ret;
 +}
 +
 +static const char * const iio_scan_elements_group_name = "scan_elements";
 +
 +int iio_buffer_register(struct iio_dev *indio_dev,
 +			const struct iio_chan_spec *channels,
 +			int num_channels)
 +{
 +	struct iio_dev_attr *p;
 +	struct attribute **attr;
 +	struct iio_buffer *buffer = indio_dev->buffer;
 +	int ret, i, attrn, attrcount, attrcount_orig = 0;
++<<<<<<< HEAD
++=======
++	const struct iio_chan_spec *channels;
++
++	channels = indio_dev->channels;
++	if (channels) {
++		int ml = indio_dev->masklength;
++
++		for (i = 0; i < indio_dev->num_channels; i++)
++			ml = max(ml, channels[i].scan_index + 1);
++		indio_dev->masklength = ml;
++	}
++
++	if (!buffer)
++		return 0;
++
++	attrcount = 0;
++	if (buffer->attrs) {
++		while (buffer->attrs[attrcount] != NULL)
++			attrcount++;
++	}
++
++	attr = kcalloc(attrcount + ARRAY_SIZE(iio_buffer_attrs) + 1,
++		       sizeof(struct attribute *), GFP_KERNEL);
++	if (!attr)
++		return -ENOMEM;
++
++	memcpy(attr, iio_buffer_attrs, sizeof(iio_buffer_attrs));
++	if (!buffer->access->set_length)
++		attr[0] = &dev_attr_length_ro.attr;
++>>>>>>> 629bc02331f7 (iio: Always compute masklength)
 +
 +	if (buffer->attrs)
 +		indio_dev->groups[indio_dev->groupcounter++] = buffer->attrs;
 +
 +	if (buffer->scan_el_attrs != NULL) {
 +		attr = buffer->scan_el_attrs->attrs;
 +		while (*attr++ != NULL)
 +			attrcount_orig++;
 +	}
 +	attrcount = attrcount_orig;
 +	INIT_LIST_HEAD(&buffer->scan_el_dev_attr_list);
 +	if (channels) {
 +		/* new magic */
 +		for (i = 0; i < num_channels; i++) {
 +			if (channels[i].scan_index < 0)
 +				continue;
 +
- 			/* Establish necessary mask length */
- 			if (channels[i].scan_index >
- 			    (int)indio_dev->masklength - 1)
- 				indio_dev->masklength
- 					= channels[i].scan_index + 1;
- 
 +			ret = iio_buffer_add_channel_sysfs(indio_dev,
 +							 &channels[i]);
 +			if (ret < 0)
 +				goto error_cleanup_dynamic;
 +			attrcount += ret;
 +			if (channels[i].type == IIO_TIMESTAMP)
 +				indio_dev->scan_index_timestamp =
 +					channels[i].scan_index;
 +		}
 +		if (indio_dev->masklength && buffer->scan_mask == NULL) {
 +			buffer->scan_mask = kcalloc(BITS_TO_LONGS(indio_dev->masklength),
 +						    sizeof(*buffer->scan_mask),
 +						    GFP_KERNEL);
 +			if (buffer->scan_mask == NULL) {
 +				ret = -ENOMEM;
 +				goto error_cleanup_dynamic;
 +			}
 +		}
 +	}
 +
 +	buffer->scan_el_group.name = iio_scan_elements_group_name;
 +
 +	buffer->scan_el_group.attrs = kcalloc(attrcount + 1,
 +					      sizeof(buffer->scan_el_group.attrs[0]),
 +					      GFP_KERNEL);
 +	if (buffer->scan_el_group.attrs == NULL) {
 +		ret = -ENOMEM;
 +		goto error_free_scan_mask;
 +	}
 +	if (buffer->scan_el_attrs)
 +		memcpy(buffer->scan_el_group.attrs, buffer->scan_el_attrs,
 +		       sizeof(buffer->scan_el_group.attrs[0])*attrcount_orig);
 +	attrn = attrcount_orig;
 +
 +	list_for_each_entry(p, &buffer->scan_el_dev_attr_list, l)
 +		buffer->scan_el_group.attrs[attrn++] = &p->dev_attr.attr;
 +	indio_dev->groups[indio_dev->groupcounter++] = &buffer->scan_el_group;
 +
 +	return 0;
 +
 +error_free_scan_mask:
 +	kfree(buffer->scan_mask);
 +error_cleanup_dynamic:
 +	iio_free_chan_devattr_list(&buffer->scan_el_dev_attr_list);
 +
  	return ret;
  }
 +EXPORT_SYMBOL(iio_buffer_register);
 +
 +void iio_buffer_unregister(struct iio_dev *indio_dev)
 +{
 +	kfree(indio_dev->buffer->scan_mask);
 +	kfree(indio_dev->buffer->scan_el_group.attrs);
 +	iio_free_chan_devattr_list(&indio_dev->buffer->scan_el_dev_attr_list);
 +}
 +EXPORT_SYMBOL(iio_buffer_unregister);
  
 -static ssize_t iio_buffer_read_length(struct device *dev,
 -				      struct device_attribute *attr,
 -				      char *buf)
 +ssize_t iio_buffer_read_length(struct device *dev,
 +			       struct device_attribute *attr,
 +			       char *buf)
  {
  	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
  	struct iio_buffer *buffer = indio_dev->buffer;
* Unmerged path drivers/iio/industrialio-buffer.c
