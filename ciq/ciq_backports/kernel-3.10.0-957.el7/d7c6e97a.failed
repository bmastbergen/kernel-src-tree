drm/nouveau/kms/nv50-: modify base allocation so the code can be split

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ben Skeggs <bskeggs@redhat.com>
commit d7c6e97a32329032ba7af1f53cab2767832fed77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d7c6e97a.failed

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit d7c6e97a32329032ba7af1f53cab2767832fed77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/dispnv50/disp.c
diff --cc drivers/gpu/drm/nouveau/dispnv50/disp.c
index a2ea42f947c7,f0edf9b5337a..000000000000
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.c
@@@ -605,63 -468,12 +605,66 @@@ struct nv50_sync 
  	u32 data;
  };
  
++<<<<<<< HEAD
 +static int
 +nv50_base_create(struct nvif_device *device, struct nvif_object *disp,
 +		 int head, u64 syncbuf, struct nv50_sync *base)
 +{
 +	struct nv50_disp_base_channel_dma_v0 args = {
 +		.pushbuf = 0xb0007c00 | head,
 +		.head = head,
 +	};
 +	static const s32 oclass[] = {
 +		GK110_DISP_BASE_CHANNEL_DMA,
 +		GK104_DISP_BASE_CHANNEL_DMA,
 +		GF110_DISP_BASE_CHANNEL_DMA,
 +		GT214_DISP_BASE_CHANNEL_DMA,
 +		GT200_DISP_BASE_CHANNEL_DMA,
 +		G82_DISP_BASE_CHANNEL_DMA,
 +		NV50_DISP_BASE_CHANNEL_DMA,
 +		0
 +	};
 +
 +	return nv50_dmac_create(device, disp, oclass, head, &args, sizeof(args),
 +				syncbuf, &base->base);
 +}
 +
 +/******************************************************************************
 + * Overlay
 + *****************************************************************************/
 +
 +struct nv50_ovly {
 +	struct nv50_dmac base;
 +};
 +
 +static int
 +nv50_ovly_create(struct nvif_device *device, struct nvif_object *disp,
 +		 int head, u64 syncbuf, struct nv50_ovly *ovly)
 +{
 +	struct nv50_disp_overlay_channel_dma_v0 args = {
 +		.pushbuf = 0xb0007e00 | head,
 +		.head = head,
 +	};
 +	static const s32 oclass[] = {
 +		GK104_DISP_OVERLAY_CONTROL_DMA,
 +		GF110_DISP_OVERLAY_CONTROL_DMA,
 +		GT214_DISP_OVERLAY_CHANNEL_DMA,
 +		GT200_DISP_OVERLAY_CHANNEL_DMA,
 +		G82_DISP_OVERLAY_CHANNEL_DMA,
 +		NV50_DISP_OVERLAY_CHANNEL_DMA,
 +		0
 +	};
 +
 +	return nv50_dmac_create(device, disp, oclass, head, &args, sizeof(args),
 +				syncbuf, &ovly->base);
 +}
 +
++=======
++>>>>>>> d7c6e97a3232 (drm/nouveau/kms/nv50-: modify base allocation so the code can be split)
  struct nv50_head {
  	struct nouveau_crtc base;
 -	struct {
 -		struct nouveau_bo *nvbo[2];
 -		int next;
 -	} lut;
 +	struct nv50_ovly ovly;
 +	struct nv50_oimm oimm;
  };
  
  #define nv50_head(c) ((struct nv50_head *)nouveau_crtc(c))
@@@ -746,7 -558,13 +749,17 @@@ evo_kick(u32 *push, void *evoc
  
  struct nv50_wndw {
  	const struct nv50_wndw_func *func;
++<<<<<<< HEAD
 +	struct nv50_dmac *dmac;
++=======
+ 	const struct nv50_wimm_func *immd;
+ 	int id;
+ 
+ 	struct {
+ 		struct nvif_object *parent;
+ 		struct list_head list;
+ 	} ctxdma;
++>>>>>>> d7c6e97a3232 (drm/nouveau/kms/nv50-: modify base allocation so the code can be split)
  
  	struct drm_plane plane;
  
@@@ -1042,11 -934,17 +1054,23 @@@ static voi
  nv50_wndw_destroy(struct drm_plane *plane)
  {
  	struct nv50_wndw *wndw = nv50_wndw(plane);
++<<<<<<< HEAD
 +	void *data;
 +	nvif_notify_fini(&wndw->notify);
 +	data = wndw->func->dtor(wndw);
++=======
+ 	struct nv50_wndw_ctxdma *ctxdma, *ctxtmp;
+ 
+ 	list_for_each_entry_safe(ctxdma, ctxtmp, &wndw->ctxdma.list, head) {
+ 		nv50_wndw_ctxdma_del(ctxdma);
+ 	}
+ 
+ 	nvif_notify_fini(&wndw->notify);
+ 	nv50_dmac_destroy(&wndw->wimm);
+ 	nv50_dmac_destroy(&wndw->wndw);
++>>>>>>> d7c6e97a3232 (drm/nouveau/kms/nv50-: modify base allocation so the code can be split)
  	drm_plane_cleanup(&wndw->plane);
- 	kfree(data);
+ 	kfree(wndw);
  }
  
  static const struct drm_plane_funcs
@@@ -1072,26 -976,178 +1102,200 @@@ nv50_wndw_init(struct nv50_wndw *wndw
  }
  
  static int
++<<<<<<< HEAD
 +nv50_wndw_ctor(const struct nv50_wndw_func *func, struct drm_device *dev,
 +	       enum drm_plane_type type, const char *name, int index,
 +	       struct nv50_dmac *dmac, const u32 *format, int nformat,
 +	       struct nv50_wndw *wndw)
 +{
 +	int ret;
 +
 +	wndw->func = func;
 +	wndw->dmac = dmac;
++=======
+ nv50_wndw_new_(const struct nv50_wndw_func *func, struct drm_device *dev,
+ 	       enum drm_plane_type type, const char *name, int index,
+ 	       const u32 *format, struct nv50_wndw **pwndw)
+ {
+ 	struct nv50_wndw *wndw;
+ 	int nformat;
+ 	int ret;
+ 
+ 	if (!(wndw = *pwndw = kzalloc(sizeof(*wndw), GFP_KERNEL)))
+ 		return -ENOMEM;
+ 	wndw->func = func;
+ 	wndw->id = index;
+ 
+ 	wndw->ctxdma.parent = &wndw->wndw.base.user;
+ 	INIT_LIST_HEAD(&wndw->ctxdma.list);
+ 
+ 	for (nformat = 0; format[nformat]; nformat++);
++>>>>>>> d7c6e97a3232 (drm/nouveau/kms/nv50-: modify base allocation so the code can be split)
  
  	ret = drm_universal_plane_init(dev, &wndw->plane, 0, &nv50_wndw,
  				       format, nformat, NULL,
  				       type, "%s-%d", name, index);
++<<<<<<< HEAD
 +	if (ret)
 +		return ret;
 +
 +	drm_plane_helper_add(&wndw->plane, &nv50_wndw_helper);
 +	return 0;
 +}
 +
++=======
+ 	if (ret) {
+ 		kfree(*pwndw);
+ 		*pwndw = NULL;
+ 		return ret;
+ 	}
+ 
+ 	drm_plane_helper_add(&wndw->plane, &nv50_wndw_helper);
+ 
+ 	wndw->notify.func = nv50_wndw_notify;
+ 	return 0;
+ }
+ 
+ /******************************************************************************
+  * Overlay
+  *****************************************************************************/
+ 
+ static const struct nv50_wimm_func
+ oimm507b = {
+ };
+ 
+ static int
+ oimm507b_init_(const struct nv50_wimm_func *func, struct nouveau_drm *drm,
+ 	       s32 oclass, struct nv50_wndw *wndw)
+ {
+ 	struct nv50_disp_overlay_v0 args = {
+ 		.head = wndw->id,
+ 	};
+ 	struct nv50_disp *disp = nv50_disp(drm->dev);
+ 	int ret;
+ 
+ 	ret = nvif_object_init(&disp->disp->object, 0, oclass, &args,
+ 			       sizeof(args), &wndw->wimm.base.user);
+ 	if (ret) {
+ 		NV_ERROR(drm, "oimm%04x allocation failed: %d\n", oclass, ret);
+ 		return ret;
+ 	}
+ 
+ 	nvif_object_map(&wndw->wimm.base.user, NULL, 0);
+ 	wndw->immd = func;
+ 	return 0;
+ }
+ 
+ static int
+ oimm507b_init(struct nouveau_drm *drm, s32 oclass, struct nv50_wndw *wndw)
+ {
+ 	return oimm507b_init_(&oimm507b, drm, oclass, wndw);
+ }
+ 
+ static int
+ nv50_oimm_init(struct nouveau_drm *drm, struct nv50_wndw *wndw)
+ {
+ 	static const struct {
+ 		s32 oclass;
+ 		int version;
+ 		int (*init)(struct nouveau_drm *, s32, struct nv50_wndw *);
+ 	} oimms[] = {
+ 		{ GK104_DISP_OVERLAY, 0, oimm507b_init },
+ 		{ GF110_DISP_OVERLAY, 0, oimm507b_init },
+ 		{ GT214_DISP_OVERLAY, 0, oimm507b_init },
+ 		{   G82_DISP_OVERLAY, 0, oimm507b_init },
+ 		{  NV50_DISP_OVERLAY, 0, oimm507b_init },
+ 		{}
+ 	};
+ 	struct nv50_disp *disp = nv50_disp(drm->dev);
+ 	int cid;
+ 
+ 	cid = nvif_mclass(&disp->disp->object, oimms);
+ 	if (cid < 0) {
+ 		NV_ERROR(drm, "No supported overlay immediate class\n");
+ 		return cid;
+ 	}
+ 
+ 	return oimms[cid].init(drm, oimms[cid].oclass, wndw);
+ }
+ 
+ static const struct nv50_wndw_func
+ ovly507e = {
+ };
+ 
+ static const u32
+ ovly507e_format[] = {
+ 	0
+ };
+ 
+ static int
+ ovly507e_new_(const struct nv50_wndw_func *func, const u32 *format,
+ 	      struct nouveau_drm *drm, int head, s32 oclass,
+ 	      struct nv50_wndw **pwndw)
+ {
+ 	struct nv50_disp_overlay_channel_dma_v0 args = {
+ 		.head = head,
+ 	};
+ 	struct nv50_disp *disp = nv50_disp(drm->dev);
+ 	struct nv50_wndw *wndw;
+ 	int ret;
+ 
+ 	ret = nv50_wndw_new_(func, drm->dev, DRM_PLANE_TYPE_OVERLAY,
+ 			     "ovly", head, format, &wndw);
+ 	if (*pwndw = wndw, ret)
+ 		return ret;
+ 
+ 	ret = nv50_dmac_create(&drm->client.device, &disp->disp->object,
+ 			       &oclass, 0, &args, sizeof(args),
+ 			       disp->sync->bo.offset, &wndw->wndw);
+ 	if (ret) {
+ 		NV_ERROR(drm, "ovly%04x allocation failed: %d\n", oclass, ret);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ ovly507e_new(struct nouveau_drm *drm, int head, s32 oclass,
+ 	     struct nv50_wndw **pwndw)
+ {
+ 	return ovly507e_new_(&ovly507e, ovly507e_format, drm, head, oclass, pwndw);
+ }
+ 
+ static int
+ nv50_ovly_new(struct nouveau_drm *drm, int head, struct nv50_wndw **pwndw)
+ {
+ 	static const struct {
+ 		s32 oclass;
+ 		int version;
+ 		int (*new)(struct nouveau_drm *, int, s32, struct nv50_wndw **);
+ 	} ovlys[] = {
+ 		{ GK104_DISP_OVERLAY_CONTROL_DMA, 0, ovly507e_new },
+ 		{ GF110_DISP_OVERLAY_CONTROL_DMA, 0, ovly507e_new },
+ 		{ GT214_DISP_OVERLAY_CHANNEL_DMA, 0, ovly507e_new },
+ 		{ GT200_DISP_OVERLAY_CHANNEL_DMA, 0, ovly507e_new },
+ 		{   G82_DISP_OVERLAY_CHANNEL_DMA, 0, ovly507e_new },
+ 		{  NV50_DISP_OVERLAY_CHANNEL_DMA, 0, ovly507e_new },
+ 		{}
+ 	};
+ 	struct nv50_disp *disp = nv50_disp(drm->dev);
+ 	int cid, ret;
+ 
+ 	cid = nvif_mclass(&disp->disp->object, ovlys);
+ 	if (cid < 0) {
+ 		NV_ERROR(drm, "No supported overlay class\n");
+ 		return cid;
+ 	}
+ 
+ 	ret = ovlys[cid].new(drm, head, ovlys[cid].oclass, pwndw);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return nv50_oimm_init(drm, *pwndw);
+ }
+ 
++>>>>>>> d7c6e97a3232 (drm/nouveau/kms/nv50-: modify base allocation so the code can be split)
  /******************************************************************************
   * Cursor plane
   *****************************************************************************/
@@@ -1467,15 -1504,6 +1649,18 @@@ nv50_base_acquire(struct nv50_wndw *wnd
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void *
 +nv50_base_dtor(struct nv50_wndw *wndw)
 +{
 +	struct nv50_disp *disp = nv50_disp(wndw->plane.dev);
 +	struct nv50_base *base = nv50_base(wndw);
 +	nv50_dmac_destroy(&base->chan.base, disp->disp);
 +	return base;
 +}
 +
++=======
++>>>>>>> d7c6e97a3232 (drm/nouveau/kms/nv50-: modify base allocation so the code can be split)
  static const u32
  nv50_base_format[] = {
  	DRM_FORMAT_C8,
@@@ -1530,8 -1559,12 +1716,17 @@@ base507c_new_(const struct nv50_wndw_fu
  		return ret;
  	}
  
++<<<<<<< HEAD
 +	ret = nv50_base_create(&drm->client.device, disp->disp, base->id,
 +			       disp->sync->bo.offset, &base->chan);
++=======
+ 	ret = nvif_notify_init(&wndw->wndw.base.user, wndw->notify.func,
+ 			       false, NV50_DISP_BASE_CHANNEL_DMA_V0_NTFY_UEVENT,
+ 			       &(struct nvif_notify_uevent_req) {},
+ 			       sizeof(struct nvif_notify_uevent_req),
+ 			       sizeof(struct nvif_notify_uevent_rep),
+ 			       &wndw->notify);
++>>>>>>> d7c6e97a3232 (drm/nouveau/kms/nv50-: modify base allocation so the code can be split)
  	if (ret)
  		return ret;
  
@@@ -2325,31 -2443,27 +2553,40 @@@ static in
  nv50_head_create(struct drm_device *dev, int index)
  {
  	struct nouveau_drm *drm = nouveau_drm(dev);
 +	struct nvif_device *device = &drm->client.device;
 +	struct nv50_disp *disp = nv50_disp(dev);
  	struct nv50_head *head;
++<<<<<<< HEAD
 +	struct nv50_base *base;
 +	struct nv50_curs *curs;
++=======
+ 	struct nv50_wndw *curs, *wndw;
++>>>>>>> d7c6e97a3232 (drm/nouveau/kms/nv50-: modify base allocation so the code can be split)
  	struct drm_crtc *crtc;
 -	int ret, i;
 +	int ret;
  
  	head = kzalloc(sizeof(*head), GFP_KERNEL);
  	if (!head)
  		return -ENOMEM;
  
  	head->base.index = index;
- 	ret = nv50_base_new(drm, head, &base);
+ 	ret = nv50_base_new(drm, head->base.index, &wndw);
  	if (ret == 0)
 -		ret = nv50_curs_new(drm, head->base.index, &curs);
 +		ret = nv50_curs_new(drm, head, &curs);
  	if (ret) {
  		kfree(head);
  		return ret;
  	}
  
  	crtc = &head->base.base;
++<<<<<<< HEAD
 +	drm_crtc_init_with_planes(dev, crtc, &base->wndw.plane,
 +				  &curs->wndw.plane, &nv50_head_func,
 +				  "head-%d", head->base.index);
++=======
+ 	drm_crtc_init_with_planes(dev, crtc, &wndw->plane, &curs->plane,
+ 				  &nv50_head_func, "head-%d", head->base.index);
++>>>>>>> d7c6e97a3232 (drm/nouveau/kms/nv50-: modify base allocation so the code can be split)
  	drm_crtc_helper_add(crtc, &nv50_head_help);
  	drm_mode_crtc_set_gamma_size(crtc, 256);
  
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/disp.c
