bpf: introduce BPF_F_ALLOW_OVERRIDE flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Alexei Starovoitov <ast@fb.com>
commit 7f677633379b4abb3281cdbe7e7006f049305c03
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7f677633.failed

If BPF_F_ALLOW_OVERRIDE flag is used in BPF_PROG_ATTACH command
to the given cgroup the descendent cgroup will be able to override
effective bpf program that was inherited from this cgroup.
By default it's not passed, therefore override is disallowed.

Examples:
1.
prog X attached to /A with default
prog Y fails to attach to /A/B and /A/B/C
Everything under /A runs prog X

2.
prog X attached to /A with allow_override.
prog Y fails to attach to /A/B with default (non-override)
prog M attached to /A/B with allow_override.
Everything under /A/B runs prog M only.

3.
prog X attached to /A with allow_override.
prog Y fails to attach to /A with default.
The user has to detach first to switch the mode.

In the future this behavior may be extended with a chain of
non-overridable programs.

Also fix the bug where detach from cgroup where nothing is attached
was not throwing error. Return ENOENT in such case.

Add several testcases and adjust libbpf.

Fixes: 3007098494be ("cgroup: add support for eBPF programs")
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Tejun Heo <tj@kernel.org>
	Acked-by: Daniel Mack <daniel@zonque.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7f677633379b4abb3281cdbe7e7006f049305c03)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf-cgroup.h
#	include/uapi/linux/bpf.h
#	kernel/bpf/cgroup.c
#	kernel/bpf/syscall.c
#	kernel/cgroup.c
#	samples/bpf/test_cgrp2_attach.c
#	samples/bpf/test_cgrp2_attach2.c
#	samples/bpf/test_cgrp2_sock.c
#	samples/bpf/test_cgrp2_sock2.c
#	tools/lib/bpf/bpf.c
#	tools/lib/bpf/bpf.h
diff --cc include/uapi/linux/bpf.h
index e369860b690e,d2b0ac799d03..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -115,8 -93,51 +115,42 @@@ enum bpf_map_type 
  
  enum bpf_prog_type {
  	BPF_PROG_TYPE_UNSPEC,
 -	BPF_PROG_TYPE_SOCKET_FILTER,
 -	BPF_PROG_TYPE_KPROBE,
 -	BPF_PROG_TYPE_SCHED_CLS,
 -	BPF_PROG_TYPE_SCHED_ACT,
 -	BPF_PROG_TYPE_TRACEPOINT,
 -	BPF_PROG_TYPE_XDP,
 -	BPF_PROG_TYPE_PERF_EVENT,
 -	BPF_PROG_TYPE_CGROUP_SKB,
 -	BPF_PROG_TYPE_CGROUP_SOCK,
 -	BPF_PROG_TYPE_LWT_IN,
 -	BPF_PROG_TYPE_LWT_OUT,
 -	BPF_PROG_TYPE_LWT_XMIT,
  };
  
++<<<<<<< HEAD
++=======
+ enum bpf_attach_type {
+ 	BPF_CGROUP_INET_INGRESS,
+ 	BPF_CGROUP_INET_EGRESS,
+ 	BPF_CGROUP_INET_SOCK_CREATE,
+ 	__MAX_BPF_ATTACH_TYPE
+ };
+ 
+ #define MAX_BPF_ATTACH_TYPE __MAX_BPF_ATTACH_TYPE
+ 
+ /* If BPF_F_ALLOW_OVERRIDE flag is used in BPF_PROG_ATTACH command
+  * to the given target_fd cgroup the descendent cgroup will be able to
+  * override effective bpf program that was inherited from this cgroup
+  */
+ #define BPF_F_ALLOW_OVERRIDE	(1U << 0)
+ 
+ #define BPF_PSEUDO_MAP_FD	1
+ 
+ /* flags for BPF_MAP_UPDATE_ELEM command */
+ #define BPF_ANY		0 /* create new element or update existing */
+ #define BPF_NOEXIST	1 /* create new element if it didn't exist */
+ #define BPF_EXIST	2 /* update existing element */
+ 
+ #define BPF_F_NO_PREALLOC	(1U << 0)
+ /* Instead of having one common LRU list in the
+  * BPF_MAP_TYPE_LRU_[PERCPU_]HASH map, use a percpu LRU list
+  * which can scale and perform better.
+  * Note, the LRU nodes (including free nodes) cannot be moved
+  * across different LRU lists.
+  */
+ #define BPF_F_NO_COMMON_LRU	(1U << 1)
+ 
++>>>>>>> 7f677633379b (bpf: introduce BPF_F_ALLOW_OVERRIDE flag)
  union bpf_attr {
  	struct { /* anonymous struct used by BPF_MAP_CREATE command */
  		__u32	map_type;	/* one of enum bpf_map_type */
@@@ -132,6 -154,30 +166,33 @@@
  			__aligned_u64 value;
  			__aligned_u64 next_key;
  		};
++<<<<<<< HEAD
++=======
+ 		__u64		flags;
+ 	};
+ 
+ 	struct { /* anonymous struct used by BPF_PROG_LOAD command */
+ 		__u32		prog_type;	/* one of enum bpf_prog_type */
+ 		__u32		insn_cnt;
+ 		__aligned_u64	insns;
+ 		__aligned_u64	license;
+ 		__u32		log_level;	/* verbosity level of verifier */
+ 		__u32		log_size;	/* size of user buffer */
+ 		__aligned_u64	log_buf;	/* user supplied buffer */
+ 		__u32		kern_version;	/* checked when prog_type=kprobe */
+ 	};
+ 
+ 	struct { /* anonymous struct used by BPF_OBJ_* commands */
+ 		__aligned_u64	pathname;
+ 		__u32		bpf_fd;
+ 	};
+ 
+ 	struct { /* anonymous struct used by BPF_PROG_ATTACH/DETACH commands */
+ 		__u32		target_fd;	/* container object to attach to */
+ 		__u32		attach_bpf_fd;	/* eBPF program to attach */
+ 		__u32		attach_type;
+ 		__u32		attach_flags;
++>>>>>>> 7f677633379b (bpf: introduce BPF_F_ALLOW_OVERRIDE flag)
  	};
  } __attribute__((aligned(8)));
  
diff --cc kernel/cgroup.c
index 4f351035f90c,53bbca7c4859..000000000000
--- a/kernel/cgroup.c
+++ b/kernel/cgroup.c
@@@ -5208,225 -6166,354 +5208,262 @@@ static int __init cgroup_disable(char *
  	}
  	return 1;
  }
 -__setup("cgroup_no_v1=", cgroup_no_v1);
 +__setup("cgroup_disable=", cgroup_disable);
  
 -/**
 - * css_tryget_online_from_dir - get corresponding css from a cgroup dentry
 - * @dentry: directory dentry of interest
 - * @ss: subsystem of interest
 - *
 - * If @dentry is a directory for a cgroup which has @ss enabled on it, try
 - * to get the corresponding css and return it.  If such css doesn't exist
 - * or can't be pinned, an ERR_PTR value is returned.
 +/*
 + * Functons for CSS ID.
   */
 -struct cgroup_subsys_state *css_tryget_online_from_dir(struct dentry *dentry,
 -						       struct cgroup_subsys *ss)
 -{
 -	struct kernfs_node *kn = kernfs_node_from_dentry(dentry);
 -	struct file_system_type *s_type = dentry->d_sb->s_type;
 -	struct cgroup_subsys_state *css = NULL;
 -	struct cgroup *cgrp;
  
 -	/* is @dentry a cgroup dir? */
 -	if ((s_type != &cgroup_fs_type && s_type != &cgroup2_fs_type) ||
 -	    !kn || kernfs_type(kn) != KERNFS_DIR)
 -		return ERR_PTR(-EBADF);
 -
 -	rcu_read_lock();
 +/*
 + *To get ID other than 0, this should be called when !cgroup_is_removed().
 + */
 +unsigned short css_id(struct cgroup_subsys_state *css)
 +{
 +	struct css_id *cssid;
  
  	/*
 -	 * This path doesn't originate from kernfs and @kn could already
 -	 * have been or be removed at any point.  @kn->priv is RCU
 -	 * protected for this access.  See css_release_work_fn() for details.
 +	 * This css_id() can return correct value when somone has refcnt
 +	 * on this or this is under rcu_read_lock(). Once css->id is allocated,
 +	 * it's unchanged until freed.
  	 */
 -	cgrp = rcu_dereference(kn->priv);
 -	if (cgrp)
 -		css = cgroup_css(cgrp, ss);
 -
 -	if (!css || !css_tryget_online(css))
 -		css = ERR_PTR(-ENOENT);
 -
 -	rcu_read_unlock();
 -	return css;
 -}
 +	cssid = rcu_dereference_check(css->id, css_refcnt(css));
  
 -/**
 - * css_from_id - lookup css by id
 - * @id: the cgroup id
 - * @ss: cgroup subsys to be looked into
 - *
 - * Returns the css if there's valid one with @id, otherwise returns NULL.
 - * Should be called under rcu_read_lock().
 - */
 -struct cgroup_subsys_state *css_from_id(int id, struct cgroup_subsys *ss)
 -{
 -	WARN_ON_ONCE(!rcu_read_lock_held());
 -	return idr_find(&ss->css_idr, id);
 +	if (cssid)
 +		return cssid->id;
 +	return 0;
  }
 +EXPORT_SYMBOL_GPL(css_id);
  
 -/**
 - * cgroup_get_from_path - lookup and get a cgroup from its default hierarchy path
 - * @path: path on the default hierarchy
 - *
 - * Find the cgroup at @path on the default hierarchy, increment its
 - * reference count and return it.  Returns pointer to the found cgroup on
 - * success, ERR_PTR(-ENOENT) if @path doens't exist and ERR_PTR(-ENOTDIR)
 - * if @path points to a non-directory.
 - */
 -struct cgroup *cgroup_get_from_path(const char *path)
 +unsigned short css_depth(struct cgroup_subsys_state *css)
  {
 -	struct kernfs_node *kn;
 -	struct cgroup *cgrp;
 -
 -	mutex_lock(&cgroup_mutex);
 +	struct css_id *cssid;
  
 -	kn = kernfs_walk_and_get(cgrp_dfl_root.cgrp.kn, path);
 -	if (kn) {
 -		if (kernfs_type(kn) == KERNFS_DIR) {
 -			cgrp = kn->priv;
 -			cgroup_get(cgrp);
 -		} else {
 -			cgrp = ERR_PTR(-ENOTDIR);
 -		}
 -		kernfs_put(kn);
 -	} else {
 -		cgrp = ERR_PTR(-ENOENT);
 -	}
 +	cssid = rcu_dereference_check(css->id, css_refcnt(css));
  
 -	mutex_unlock(&cgroup_mutex);
 -	return cgrp;
 +	if (cssid)
 +		return cssid->depth;
 +	return 0;
  }
 -EXPORT_SYMBOL_GPL(cgroup_get_from_path);
 +EXPORT_SYMBOL_GPL(css_depth);
  
  /**
 - * cgroup_get_from_fd - get a cgroup pointer from a fd
 - * @fd: fd obtained by open(cgroup2_dir)
 - *
 - * Find the cgroup from a fd which should be obtained
 - * by opening a cgroup directory.  Returns a pointer to the
 - * cgroup on success. ERR_PTR is returned if the cgroup
 - * cannot be found.
 + *  css_is_ancestor - test "root" css is an ancestor of "child"
 + * @child: the css to be tested.
 + * @root: the css supporsed to be an ancestor of the child.
 + *
 + * Returns true if "root" is an ancestor of "child" in its hierarchy. Because
 + * this function reads css->id, the caller must hold rcu_read_lock().
 + * But, considering usual usage, the csses should be valid objects after test.
 + * Assuming that the caller will do some action to the child if this returns
 + * returns true, the caller must take "child";s reference count.
 + * If "child" is valid object and this returns true, "root" is valid, too.
   */
 -struct cgroup *cgroup_get_from_fd(int fd)
 -{
 -	struct cgroup_subsys_state *css;
 -	struct cgroup *cgrp;
 -	struct file *f;
 -
 -	f = fget_raw(fd);
 -	if (!f)
 -		return ERR_PTR(-EBADF);
 -
 -	css = css_tryget_online_from_dir(f->f_path.dentry, NULL);
 -	fput(f);
 -	if (IS_ERR(css))
 -		return ERR_CAST(css);
  
 -	cgrp = css->cgroup;
 -	if (!cgroup_on_dfl(cgrp)) {
 -		cgroup_put(cgrp);
 -		return ERR_PTR(-EBADF);
 -	}
 +bool css_is_ancestor(struct cgroup_subsys_state *child,
 +		    const struct cgroup_subsys_state *root)
 +{
 +	struct css_id *child_id;
 +	struct css_id *root_id;
  
 -	return cgrp;
 +	child_id  = rcu_dereference(child->id);
 +	if (!child_id)
 +		return false;
 +	root_id = rcu_dereference(root->id);
 +	if (!root_id)
 +		return false;
 +	if (child_id->depth < root_id->depth)
 +		return false;
 +	if (child_id->stack[root_id->depth] != root_id->id)
 +		return false;
 +	return true;
  }
 -EXPORT_SYMBOL_GPL(cgroup_get_from_fd);
  
 -/*
 - * sock->sk_cgrp_data handling.  For more info, see sock_cgroup_data
 - * definition in cgroup-defs.h.
 - */
 -#ifdef CONFIG_SOCK_CGROUP_DATA
 -
 -#if defined(CONFIG_CGROUP_NET_PRIO) || defined(CONFIG_CGROUP_NET_CLASSID)
 -
 -DEFINE_SPINLOCK(cgroup_sk_update_lock);
 -static bool cgroup_sk_alloc_disabled __read_mostly;
 -
 -void cgroup_sk_alloc_disable(void)
 +void free_css_id(struct cgroup_subsys *ss, struct cgroup_subsys_state *css)
  {
 -	if (cgroup_sk_alloc_disabled)
 +	struct css_id *id = css->id;
 +	/* When this is called before css_id initialization, id can be NULL */
 +	if (!id)
  		return;
 -	pr_info("cgroup: disabling cgroup2 socket matching due to net_prio or net_cls activation\n");
 -	cgroup_sk_alloc_disabled = true;
 -}
  
 -#else
 +	BUG_ON(!ss->use_id);
  
 -#define cgroup_sk_alloc_disabled	false
 +	rcu_assign_pointer(id->css, NULL);
 +	rcu_assign_pointer(css->id, NULL);
 +	spin_lock(&ss->id_lock);
 +	idr_remove(&ss->idr, id->id);
 +	spin_unlock(&ss->id_lock);
 +	kfree_rcu(id, rcu_head);
 +}
 +EXPORT_SYMBOL_GPL(free_css_id);
  
 -#endif
 +/*
 + * This is called by init or create(). Then, calls to this function are
 + * always serialized (By cgroup_mutex() at create()).
 + */
  
 -void cgroup_sk_alloc(struct sock_cgroup_data *skcd)
 +static struct css_id *get_new_cssid(struct cgroup_subsys *ss, int depth)
  {
 -	if (cgroup_sk_alloc_disabled)
 -		return;
 -
 -	/* Socket clone path */
 -	if (skcd->val) {
 -		cgroup_get(sock_cgroup_ptr(skcd));
 -		return;
 -	}
 -
 -	rcu_read_lock();
 -
 -	while (true) {
 -		struct css_set *cset;
 +	struct css_id *newid;
 +	int ret, size;
  
 -		cset = task_css_set(current);
 -		if (likely(cgroup_tryget(cset->dfl_cgrp))) {
 -			skcd->val = (unsigned long)cset->dfl_cgrp;
 -			break;
 -		}
 -		cpu_relax();
 -	}
 +	BUG_ON(!ss->use_id);
  
 -	rcu_read_unlock();
 -}
 +	size = sizeof(*newid) + sizeof(unsigned short) * (depth + 1);
 +	newid = kzalloc(size, GFP_KERNEL);
 +	if (!newid)
 +		return ERR_PTR(-ENOMEM);
  
 -void cgroup_sk_free(struct sock_cgroup_data *skcd)
 -{
 -	cgroup_put(sock_cgroup_ptr(skcd));
 -}
 +	idr_preload(GFP_KERNEL);
 +	spin_lock(&ss->id_lock);
 +	/* Don't use 0. allocates an ID of 1-65535 */
 +	ret = idr_alloc(&ss->idr, newid, 1, CSS_ID_MAX + 1, GFP_NOWAIT);
 +	spin_unlock(&ss->id_lock);
 +	idr_preload_end();
  
 -#endif	/* CONFIG_SOCK_CGROUP_DATA */
 +	/* Returns error when there are no free spaces for new ID.*/
 +	if (ret < 0)
 +		goto err_out;
  
 -/* cgroup namespaces */
 +	newid->id = ret;
 +	newid->depth = depth;
 +	return newid;
 +err_out:
 +	kfree(newid);
 +	return ERR_PTR(ret);
  
 -static struct ucounts *inc_cgroup_namespaces(struct user_namespace *ns)
 -{
 -	return inc_ucount(ns, current_euid(), UCOUNT_CGROUP_NAMESPACES);
  }
  
 -static void dec_cgroup_namespaces(struct ucounts *ucounts)
 +static int __init_or_module cgroup_init_idr(struct cgroup_subsys *ss,
 +					    struct cgroup_subsys_state *rootcss)
  {
 -	dec_ucount(ucounts, UCOUNT_CGROUP_NAMESPACES);
 -}
 +	struct css_id *newid;
  
 -static struct cgroup_namespace *alloc_cgroup_ns(void)
 -{
 -	struct cgroup_namespace *new_ns;
 -	int ret;
 +	spin_lock_init(&ss->id_lock);
 +	idr_init(&ss->idr);
  
 -	new_ns = kzalloc(sizeof(struct cgroup_namespace), GFP_KERNEL);
 -	if (!new_ns)
 -		return ERR_PTR(-ENOMEM);
 -	ret = ns_alloc_inum(&new_ns->ns);
 -	if (ret) {
 -		kfree(new_ns);
 -		return ERR_PTR(ret);
 -	}
 -	atomic_set(&new_ns->count, 1);
 -	new_ns->ns.ops = &cgroupns_operations;
 -	return new_ns;
 -}
 +	newid = get_new_cssid(ss, 0);
 +	if (IS_ERR(newid))
 +		return PTR_ERR(newid);
  
 -void free_cgroup_ns(struct cgroup_namespace *ns)
 -{
 -	put_css_set(ns->root_cset);
 -	dec_cgroup_namespaces(ns->ucounts);
 -	put_user_ns(ns->user_ns);
 -	ns_free_inum(&ns->ns);
 -	kfree(ns);
 +	newid->stack[0] = newid->id;
 +	newid->css = rootcss;
 +	rootcss->id = newid;
 +	return 0;
  }
 -EXPORT_SYMBOL(free_cgroup_ns);
  
 -struct cgroup_namespace *copy_cgroup_ns(unsigned long flags,
 -					struct user_namespace *user_ns,
 -					struct cgroup_namespace *old_ns)
 +static int alloc_css_id(struct cgroup_subsys *ss, struct cgroup *parent,
 +			struct cgroup *child)
  {
 -	struct cgroup_namespace *new_ns;
 -	struct ucounts *ucounts;
 -	struct css_set *cset;
 -
 -	BUG_ON(!old_ns);
 -
 -	if (!(flags & CLONE_NEWCGROUP)) {
 -		get_cgroup_ns(old_ns);
 -		return old_ns;
 -	}
 +	int subsys_id, i, depth = 0;
 +	struct cgroup_subsys_state *parent_css, *child_css;
 +	struct css_id *child_id, *parent_id;
  
 -	/* Allow only sysadmin to create cgroup namespace. */
 -	if (!ns_capable(user_ns, CAP_SYS_ADMIN))
 -		return ERR_PTR(-EPERM);
 -
 -	ucounts = inc_cgroup_namespaces(user_ns);
 -	if (!ucounts)
 -		return ERR_PTR(-ENOSPC);
 -
 -	/* It is not safe to take cgroup_mutex here */
 -	spin_lock_irq(&css_set_lock);
 -	cset = task_css_set(current);
 -	get_css_set(cset);
 -	spin_unlock_irq(&css_set_lock);
 -
 -	new_ns = alloc_cgroup_ns();
 -	if (IS_ERR(new_ns)) {
 -		put_css_set(cset);
 -		dec_cgroup_namespaces(ucounts);
 -		return new_ns;
 -	}
 +	subsys_id = ss->subsys_id;
 +	parent_css = parent->subsys[subsys_id];
 +	child_css = child->subsys[subsys_id];
 +	parent_id = parent_css->id;
 +	depth = parent_id->depth + 1;
  
 -	new_ns->user_ns = get_user_ns(user_ns);
 -	new_ns->ucounts = ucounts;
 -	new_ns->root_cset = cset;
 +	child_id = get_new_cssid(ss, depth);
 +	if (IS_ERR(child_id))
 +		return PTR_ERR(child_id);
  
 -	return new_ns;
 -}
 +	for (i = 0; i < depth; i++)
 +		child_id->stack[i] = parent_id->stack[i];
 +	child_id->stack[depth] = child_id->id;
 +	/*
 +	 * child_id->css pointer will be set after this cgroup is available
 +	 * see cgroup_populate_dir()
 +	 */
 +	rcu_assign_pointer(child_css->id, child_id);
  
 -static inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)
 -{
 -	return container_of(ns, struct cgroup_namespace, ns);
 +	return 0;
  }
  
 -static int cgroupns_install(struct nsproxy *nsproxy, struct ns_common *ns)
 +/**
 + * css_lookup - lookup css by id
 + * @ss: cgroup subsys to be looked into.
 + * @id: the id
 + *
 + * Returns pointer to cgroup_subsys_state if there is valid one with id.
 + * NULL if not. Should be called under rcu_read_lock()
 + */
 +struct cgroup_subsys_state *css_lookup(struct cgroup_subsys *ss, int id)
  {
 -	struct cgroup_namespace *cgroup_ns = to_cg_ns(ns);
 -
 -	if (!ns_capable(current_user_ns(), CAP_SYS_ADMIN) ||
 -	    !ns_capable(cgroup_ns->user_ns, CAP_SYS_ADMIN))
 -		return -EPERM;
 +	struct css_id *cssid = NULL;
  
 -	/* Don't need to do anything if we are attaching to our own cgroupns. */
 -	if (cgroup_ns == nsproxy->cgroup_ns)
 -		return 0;
 +	BUG_ON(!ss->use_id);
 +	cssid = idr_find(&ss->idr, id);
  
 -	get_cgroup_ns(cgroup_ns);
 -	put_cgroup_ns(nsproxy->cgroup_ns);
 -	nsproxy->cgroup_ns = cgroup_ns;
 +	if (unlikely(!cssid))
 +		return NULL;
  
 -	return 0;
 +	return rcu_dereference(cssid->css);
  }
 +EXPORT_SYMBOL_GPL(css_lookup);
  
 -static struct ns_common *cgroupns_get(struct task_struct *task)
 +/*
 + * get corresponding css from file open on cgroupfs directory
 + */
 +struct cgroup_subsys_state *cgroup_css_from_dir(struct file *f, int id)
  {
 -	struct cgroup_namespace *ns = NULL;
 -	struct nsproxy *nsproxy;
 +	struct cgroup *cgrp;
 +	struct inode *inode;
 +	struct cgroup_subsys_state *css;
  
 -	task_lock(task);
 -	nsproxy = task->nsproxy;
 -	if (nsproxy) {
 -		ns = nsproxy->cgroup_ns;
 -		get_cgroup_ns(ns);
 -	}
 -	task_unlock(task);
 +	inode = file_inode(f);
 +	/* check in cgroup filesystem dir */
 +	if (inode->i_op != &cgroup_dir_inode_operations)
 +		return ERR_PTR(-EBADF);
  
 -	return ns ? &ns->ns : NULL;
 -}
 +	if (id < 0 || id >= CGROUP_SUBSYS_COUNT)
 +		return ERR_PTR(-EINVAL);
  
 -static void cgroupns_put(struct ns_common *ns)
 -{
 -	put_cgroup_ns(to_cg_ns(ns));
 +	/* get cgroup */
 +	cgrp = __d_cgrp(f->f_dentry);
 +	css = cgrp->subsys[id];
 +	return css ? css : ERR_PTR(-ENOENT);
  }
  
++<<<<<<< HEAD
++=======
+ static struct user_namespace *cgroupns_owner(struct ns_common *ns)
+ {
+ 	return to_cg_ns(ns)->user_ns;
+ }
+ 
+ const struct proc_ns_operations cgroupns_operations = {
+ 	.name		= "cgroup",
+ 	.type		= CLONE_NEWCGROUP,
+ 	.get		= cgroupns_get,
+ 	.put		= cgroupns_put,
+ 	.install	= cgroupns_install,
+ 	.owner		= cgroupns_owner,
+ };
+ 
+ static __init int cgroup_namespaces_init(void)
+ {
+ 	return 0;
+ }
+ subsys_initcall(cgroup_namespaces_init);
+ 
+ #ifdef CONFIG_CGROUP_BPF
+ int cgroup_bpf_update(struct cgroup *cgrp, struct bpf_prog *prog,
+ 		      enum bpf_attach_type type, bool overridable)
+ {
+ 	struct cgroup *parent = cgroup_parent(cgrp);
+ 	int ret;
+ 
+ 	mutex_lock(&cgroup_mutex);
+ 	ret = __cgroup_bpf_update(cgrp, parent, prog, type, overridable);
+ 	mutex_unlock(&cgroup_mutex);
+ 	return ret;
+ }
+ #endif /* CONFIG_CGROUP_BPF */
+ 
++>>>>>>> 7f677633379b (bpf: introduce BPF_F_ALLOW_OVERRIDE flag)
  #ifdef CONFIG_CGROUP_DEBUG
 -static struct cgroup_subsys_state *
 -debug_css_alloc(struct cgroup_subsys_state *parent_css)
 +static struct cgroup_subsys_state *debug_css_alloc(struct cgroup *cont)
  {
  	struct cgroup_subsys_state *css = kzalloc(sizeof(*css), GFP_KERNEL);
  
* Unmerged path include/linux/bpf-cgroup.h
* Unmerged path kernel/bpf/cgroup.c
* Unmerged path kernel/bpf/syscall.c
* Unmerged path samples/bpf/test_cgrp2_attach.c
* Unmerged path samples/bpf/test_cgrp2_attach2.c
* Unmerged path samples/bpf/test_cgrp2_sock.c
* Unmerged path samples/bpf/test_cgrp2_sock2.c
* Unmerged path tools/lib/bpf/bpf.c
* Unmerged path tools/lib/bpf/bpf.h
* Unmerged path include/linux/bpf-cgroup.h
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path kernel/bpf/cgroup.c
* Unmerged path kernel/bpf/syscall.c
* Unmerged path kernel/cgroup.c
* Unmerged path samples/bpf/test_cgrp2_attach.c
* Unmerged path samples/bpf/test_cgrp2_attach2.c
* Unmerged path samples/bpf/test_cgrp2_sock.c
* Unmerged path samples/bpf/test_cgrp2_sock2.c
* Unmerged path tools/lib/bpf/bpf.c
* Unmerged path tools/lib/bpf/bpf.h
