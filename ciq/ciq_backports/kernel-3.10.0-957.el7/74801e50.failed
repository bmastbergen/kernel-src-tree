nfp: bpf: reject program on instructions unknown to the JIT compiler

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Quentin Monnet <quentin.monnet@netronome.com>
commit 74801e50d5b89329e6c02b8bd924a41234f76316
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/74801e50.failed

If an eBPF instruction is unknown to the driver JIT compiler, we can
reject the program at verification time.

	Signed-off-by: Quentin Monnet <quentin.monnet@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Jiong Wang <jiong.wang@netronome.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 74801e50d5b89329e6c02b8bd924a41234f76316)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/bpf/jit.c
#	drivers/net/ethernet/netronome/nfp/bpf/main.h
diff --cc drivers/net/ethernet/netronome/nfp/bpf/jit.c
index 2a38b8e187f7,56451edf01c2..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/jit.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/jit.c
@@@ -2575,3 -2883,98 +2575,101 @@@ out
  
  	return ret;
  }
++<<<<<<< HEAD
++=======
+ 
+ void nfp_bpf_jit_prepare(struct nfp_prog *nfp_prog, unsigned int cnt)
+ {
+ 	struct nfp_insn_meta *meta;
+ 
+ 	/* Another pass to record jump information. */
+ 	list_for_each_entry(meta, &nfp_prog->insns, l) {
+ 		u64 code = meta->insn.code;
+ 
+ 		if (BPF_CLASS(code) == BPF_JMP && BPF_OP(code) != BPF_EXIT &&
+ 		    BPF_OP(code) != BPF_CALL) {
+ 			struct nfp_insn_meta *dst_meta;
+ 			unsigned short dst_indx;
+ 
+ 			dst_indx = meta->n + 1 + meta->insn.off;
+ 			dst_meta = nfp_bpf_goto_meta(nfp_prog, meta, dst_indx,
+ 						     cnt);
+ 
+ 			meta->jmp_dst = dst_meta;
+ 			dst_meta->flags |= FLAG_INSN_IS_JUMP_DST;
+ 		}
+ 	}
+ }
+ 
+ bool nfp_bpf_supported_opcode(u8 code)
+ {
+ 	return !!instr_cb[code];
+ }
+ 
+ void *nfp_bpf_relo_for_vnic(struct nfp_prog *nfp_prog, struct nfp_bpf_vnic *bv)
+ {
+ 	unsigned int i;
+ 	u64 *prog;
+ 	int err;
+ 
+ 	prog = kmemdup(nfp_prog->prog, nfp_prog->prog_len * sizeof(u64),
+ 		       GFP_KERNEL);
+ 	if (!prog)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	for (i = 0; i < nfp_prog->prog_len; i++) {
+ 		enum nfp_relo_type special;
+ 		u32 val;
+ 
+ 		special = FIELD_GET(OP_RELO_TYPE, prog[i]);
+ 		switch (special) {
+ 		case RELO_NONE:
+ 			continue;
+ 		case RELO_BR_REL:
+ 			br_add_offset(&prog[i], bv->start_off);
+ 			break;
+ 		case RELO_BR_GO_OUT:
+ 			br_set_offset(&prog[i],
+ 				      nfp_prog->tgt_out + bv->start_off);
+ 			break;
+ 		case RELO_BR_GO_ABORT:
+ 			br_set_offset(&prog[i],
+ 				      nfp_prog->tgt_abort + bv->start_off);
+ 			break;
+ 		case RELO_BR_NEXT_PKT:
+ 			br_set_offset(&prog[i], bv->tgt_done);
+ 			break;
+ 		case RELO_BR_HELPER:
+ 			val = br_get_offset(prog[i]);
+ 			val -= BR_OFF_RELO;
+ 			switch (val) {
+ 			case BPF_FUNC_map_lookup_elem:
+ 				val = nfp_prog->bpf->helpers.map_lookup;
+ 				break;
+ 			default:
+ 				pr_err("relocation of unknown helper %d\n",
+ 				       val);
+ 				err = -EINVAL;
+ 				goto err_free_prog;
+ 			}
+ 			br_set_offset(&prog[i], val);
+ 			break;
+ 		case RELO_IMMED_REL:
+ 			immed_add_value(&prog[i], bv->start_off);
+ 			break;
+ 		}
+ 
+ 		prog[i] &= ~OP_RELO_TYPE;
+ 	}
+ 
+ 	err = nfp_bpf_ustore_calc(prog, nfp_prog->prog_len);
+ 	if (err)
+ 		goto err_free_prog;
+ 
+ 	return prog;
+ 
+ err_free_prog:
+ 	kfree(prog);
+ 	return ERR_PTR(err);
+ }
++>>>>>>> 74801e50d5b8 (nfp: bpf: reject program on instructions unknown to the JIT compiler)
diff --cc drivers/net/ethernet/netronome/nfp/bpf/main.h
index 5212b54abaf7,c476bca15ba4..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/main.h
+++ b/drivers/net/ethernet/netronome/nfp/bpf/main.h
@@@ -183,37 -310,52 +183,43 @@@ struct nfp_prog 
  	struct list_head insns;
  };
  
 -/**
 - * struct nfp_bpf_vnic - per-vNIC BPF priv structure
 - * @tc_prog:	currently loaded cls_bpf program
 - * @start_off:	address of the first instruction in the memory
 - * @tgt_done:	jump target to get the next packet
 - */
 -struct nfp_bpf_vnic {
 -	struct bpf_prog *tc_prog;
 -	unsigned int start_off;
 -	unsigned int tgt_done;
 +struct nfp_bpf_result {
 +	unsigned int n_instr;
 +	bool dense_mode;
  };
  
++<<<<<<< HEAD
 +int
 +nfp_bpf_jit(struct bpf_prog *filter, void *prog, enum nfp_bpf_action_type act,
 +	    unsigned int prog_start, unsigned int prog_done,
 +	    unsigned int prog_sz, struct nfp_bpf_result *res);
++=======
+ void nfp_bpf_jit_prepare(struct nfp_prog *nfp_prog, unsigned int cnt);
+ int nfp_bpf_jit(struct nfp_prog *prog);
+ bool nfp_bpf_supported_opcode(u8 code);
++>>>>>>> 74801e50d5b8 (nfp: bpf: reject program on instructions unknown to the JIT compiler)
  
 -extern const struct bpf_prog_offload_ops nfp_bpf_analyzer_ops;
 +int nfp_prog_verify(struct nfp_prog *nfp_prog, struct bpf_prog *prog);
  
 -struct netdev_bpf;
 -struct nfp_app;
  struct nfp_net;
 +struct tc_cls_bpf_offload;
 +
 +/**
 + * struct nfp_net_bpf_priv - per-vNIC BPF private data
 + * @rx_filter:		Filter offload statistics - dropped packets/bytes
 + * @rx_filter_prev:	Filter offload statistics - values from previous update
 + * @rx_filter_change:	Jiffies when statistics last changed
 + * @rx_filter_stats_timer:  Timer for polling filter offload statistics
 + * @rx_filter_lock:	Lock protecting timer state changes (teardown)
 + */
 +struct nfp_net_bpf_priv {
 +	struct nfp_stat_pair rx_filter, rx_filter_prev;
 +	unsigned long rx_filter_change;
 +	struct timer_list rx_filter_stats_timer;
 +	spinlock_t rx_filter_lock;
 +};
 +
 +int nfp_net_bpf_offload(struct nfp_net *nn, struct tc_cls_bpf_offload *cls_bpf);
 +void nfp_net_filter_stats_timer(unsigned long data);
  
 -int nfp_ndo_bpf(struct nfp_app *app, struct nfp_net *nn,
 -		struct netdev_bpf *bpf);
 -int nfp_net_bpf_offload(struct nfp_net *nn, struct bpf_prog *prog,
 -			bool old_prog);
 -
 -struct nfp_insn_meta *
 -nfp_bpf_goto_meta(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,
 -		  unsigned int insn_idx, unsigned int n_insns);
 -
 -void *nfp_bpf_relo_for_vnic(struct nfp_prog *nfp_prog, struct nfp_bpf_vnic *bv);
 -
 -long long int
 -nfp_bpf_ctrl_alloc_map(struct nfp_app_bpf *bpf, struct bpf_map *map);
 -void
 -nfp_bpf_ctrl_free_map(struct nfp_app_bpf *bpf, struct nfp_bpf_map *nfp_map);
 -int nfp_bpf_ctrl_getfirst_entry(struct bpf_offloaded_map *offmap,
 -				void *next_key);
 -int nfp_bpf_ctrl_update_entry(struct bpf_offloaded_map *offmap,
 -			      void *key, void *value, u64 flags);
 -int nfp_bpf_ctrl_del_entry(struct bpf_offloaded_map *offmap, void *key);
 -int nfp_bpf_ctrl_lookup_entry(struct bpf_offloaded_map *offmap,
 -			      void *key, void *value);
 -int nfp_bpf_ctrl_getnext_entry(struct bpf_offloaded_map *offmap,
 -			       void *key, void *next_key);
 -
 -void nfp_bpf_ctrl_msg_rx(struct nfp_app *app, struct sk_buff *skb);
  #endif
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/jit.c
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/main.h
diff --git a/drivers/net/ethernet/netronome/nfp/bpf/verifier.c b/drivers/net/ethernet/netronome/nfp/bpf/verifier.c
index 0f4ae869a0f1..49689eeb4f5b 100644
--- a/drivers/net/ethernet/netronome/nfp/bpf/verifier.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/verifier.c
@@ -186,6 +186,12 @@ nfp_verify_insn(struct bpf_verifier_env *env, int insn_idx, int prev_insn_idx)
 	meta = nfp_bpf_goto_meta(priv->prog, meta, insn_idx, env->prog->len);
 	priv->meta = meta;
 
+	if (!nfp_bpf_supported_opcode(meta->insn.code)) {
+		pr_vlog(env, "instruction %#02x not supported\n",
+			meta->insn.code);
+		return -EINVAL;
+	}
+
 	if (meta->insn.src_reg >= MAX_BPF_REG ||
 	    meta->insn.dst_reg >= MAX_BPF_REG) {
 		pr_err("program uses extended registers - jit hardening?\n");
