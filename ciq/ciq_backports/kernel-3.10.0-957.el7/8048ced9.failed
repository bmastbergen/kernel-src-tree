net: ipv6: regenerate host route if moved to gc list

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] ipv6: regenerate host route if moved to gc list (Ivan Vecera) [1500871]
Rebuild_FUZZ: 94.95%
commit-author David Ahern <dsa@cumulusnetworks.com>
commit 8048ced9beb21a52e3305f3332ae82020619f24e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8048ced9.failed

Taking down the loopback device wreaks havoc on IPv6 routing. By
extension, taking down a VRF device wreaks havoc on its table.

Dmitry and Andrey both reported heap out-of-bounds reports in the IPv6
FIB code while running syzkaller fuzzer. The root cause is a dead dst
that is on the garbage list gets reinserted into the IPv6 FIB. While on
the gc (or perhaps when it gets added to the gc list) the dst->next is
set to an IPv4 dst. A subsequent walk of the ipv6 tables causes the
out-of-bounds access.

Andrey's reproducer was the key to getting to the bottom of this.

With IPv6, host routes for an address have the dst->dev set to the
loopback device. When the 'lo' device is taken down, rt6_ifdown initiates
a walk of the fib evicting routes with the 'lo' device which means all
host routes are removed. That process moves the dst which is attached to
an inet6_ifaddr to the gc list and marks it as dead.

The recent change to keep global IPv6 addresses added a new function,
fixup_permanent_addr, that is called on admin up. That function restarts
dad for an inet6_ifaddr and when it completes the host route attached
to it is inserted into the fib. Since the route was marked dead and
moved to the gc list, re-inserting the route causes the reported
out-of-bounds accesses. If the device with the address is taken down
or the address is removed, the WARN_ON in fib6_del is triggered.

All of those faults are fixed by regenerating the host route if the
existing one has been moved to the gc list, something that can be
determined by checking if the rt6i_ref counter is 0.

Fixes: f1705ec197e7 ("net: ipv6: Make address flushing on ifdown optional")
	Reported-by: Dmitry Vyukov <dvyukov@google.com>
	Reported-by: Andrey Konovalov <andreyknvl@google.com>
	Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8048ced9beb21a52e3305f3332ae82020619f24e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/addrconf.c
diff --cc net/ipv6/addrconf.c
index 836f13f8d356,0ea96c4d334d..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -3071,6 -3268,65 +3071,68 @@@ static void addrconf_gre_config(struct 
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ static int fixup_permanent_addr(struct inet6_dev *idev,
+ 				struct inet6_ifaddr *ifp)
+ {
+ 	/* rt6i_ref == 0 means the host route was removed from the
+ 	 * FIB, for example, if 'lo' device is taken down. In that
+ 	 * case regenerate the host route.
+ 	 */
+ 	if (!ifp->rt || !atomic_read(&ifp->rt->rt6i_ref)) {
+ 		struct rt6_info *rt, *prev;
+ 
+ 		rt = addrconf_dst_alloc(idev, &ifp->addr, false);
+ 		if (unlikely(IS_ERR(rt)))
+ 			return PTR_ERR(rt);
+ 
+ 		/* ifp->rt can be accessed outside of rtnl */
+ 		spin_lock(&ifp->lock);
+ 		prev = ifp->rt;
+ 		ifp->rt = rt;
+ 		spin_unlock(&ifp->lock);
+ 
+ 		ip6_rt_put(prev);
+ 	}
+ 
+ 	if (!(ifp->flags & IFA_F_NOPREFIXROUTE)) {
+ 		addrconf_prefix_route(&ifp->addr, ifp->prefix_len,
+ 				      idev->dev, 0, 0);
+ 	}
+ 
+ 	addrconf_dad_start(ifp);
+ 
+ 	return 0;
+ }
+ 
+ static void addrconf_permanent_addr(struct net_device *dev)
+ {
+ 	struct inet6_ifaddr *ifp, *tmp;
+ 	struct inet6_dev *idev;
+ 
+ 	idev = __in6_dev_get(dev);
+ 	if (!idev)
+ 		return;
+ 
+ 	write_lock_bh(&idev->lock);
+ 
+ 	list_for_each_entry_safe(ifp, tmp, &idev->addr_list, if_list) {
+ 		if ((ifp->flags & IFA_F_PERMANENT) &&
+ 		    fixup_permanent_addr(idev, ifp) < 0) {
+ 			write_unlock_bh(&idev->lock);
+ 			ipv6_del_addr(ifp);
+ 			write_lock_bh(&idev->lock);
+ 
+ 			net_info_ratelimited("%s: Failed to add prefix route for address %pI6c; dropping\n",
+ 					     idev->dev->name, &ifp->addr);
+ 		}
+ 	}
+ 
+ 	write_unlock_bh(&idev->lock);
+ }
+ 
++>>>>>>> 8048ced9beb2 (net: ipv6: regenerate host route if moved to gc list)
  static int addrconf_notify(struct notifier_block *this, unsigned long event,
  			   void *ptr)
  {
* Unmerged path net/ipv6/addrconf.c
