nfp: fix kdoc warnings on nested structures

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 703f578a353d0735961b7fd7e2589532dfa9bf11
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/703f578a.failed

Commit 84ce5b987783 ("scripts: kernel-doc: improve nested logic to
handle multiple identifiers") improved the handling of nested structure
definitions in scripts/kernel-doc, and changed the expected format of
documentation.  This causes new warnings to appear on W=1 builds.

Only comment changes.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 703f578a353d0735961b7fd7e2589532dfa9bf11)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/bpf/main.h
diff --cc drivers/net/ethernet/netronome/nfp/bpf/main.h
index 5212b54abaf7,054df3dc0698..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/main.h
+++ b/drivers/net/ethernet/netronome/nfp/bpf/main.h
@@@ -85,6 -96,89 +85,92 @@@ enum nfp_bpf_action_type 
  #define NFP_BPF_ABI_FLAGS	reg_imm(0)
  #define   NFP_BPF_ABI_FLAG_MARK	1
  
++<<<<<<< HEAD
++=======
+ /**
+  * struct nfp_app_bpf - bpf app priv structure
+  * @app:		backpointer to the app
+  *
+  * @tag_allocator:	bitmap of control message tags in use
+  * @tag_alloc_next:	next tag bit to allocate
+  * @tag_alloc_last:	next tag bit to be freed
+  *
+  * @cmsg_replies:	received cmsg replies waiting to be consumed
+  * @cmsg_wq:		work queue for waiting for cmsg replies
+  *
+  * @map_list:		list of offloaded maps
+  * @maps_in_use:	number of currently offloaded maps
+  * @map_elems_in_use:	number of elements allocated to offloaded maps
+  *
+  * @adjust_head:	adjust head capability
+  * @adjust_head.flags:		extra flags for adjust head
+  * @adjust_head.off_min:	minimal packet offset within buffer required
+  * @adjust_head.off_max:	maximum packet offset within buffer required
+  * @adjust_head.guaranteed_sub:	negative adjustment guaranteed possible
+  * @adjust_head.guaranteed_add:	positive adjustment guaranteed possible
+  *
+  * @maps:		map capability
+  * @maps.types:			supported map types
+  * @maps.max_maps:		max number of maps supported
+  * @maps.max_elems:		max number of entries in each map
+  * @maps.max_key_sz:		max size of map key
+  * @maps.max_val_sz:		max size of map value
+  * @maps.max_elem_sz:		max size of map entry (key + value)
+  *
+  * @helpers:		helper addressess for various calls
+  * @helpers.map_lookup:		map lookup helper address
+  */
+ struct nfp_app_bpf {
+ 	struct nfp_app *app;
+ 
+ 	DECLARE_BITMAP(tag_allocator, U16_MAX + 1);
+ 	u16 tag_alloc_next;
+ 	u16 tag_alloc_last;
+ 
+ 	struct sk_buff_head cmsg_replies;
+ 	struct wait_queue_head cmsg_wq;
+ 
+ 	struct list_head map_list;
+ 	unsigned int maps_in_use;
+ 	unsigned int map_elems_in_use;
+ 
+ 	struct nfp_bpf_cap_adjust_head {
+ 		u32 flags;
+ 		int off_min;
+ 		int off_max;
+ 		int guaranteed_sub;
+ 		int guaranteed_add;
+ 	} adjust_head;
+ 
+ 	struct {
+ 		u32 types;
+ 		u32 max_maps;
+ 		u32 max_elems;
+ 		u32 max_key_sz;
+ 		u32 max_val_sz;
+ 		u32 max_elem_sz;
+ 	} maps;
+ 
+ 	struct {
+ 		u32 map_lookup;
+ 	} helpers;
+ };
+ 
+ /**
+  * struct nfp_bpf_map - private per-map data attached to BPF maps for offload
+  * @offmap:	pointer to the offloaded BPF map
+  * @bpf:	back pointer to bpf app private structure
+  * @tid:	table id identifying map on datapath
+  * @l:		link on the nfp_app_bpf->map_list list
+  */
+ struct nfp_bpf_map {
+ 	struct bpf_offloaded_map *offmap;
+ 	struct nfp_app_bpf *bpf;
+ 	u32 tid;
+ 	struct list_head l;
+ };
+ 
++>>>>>>> 703f578a353d (nfp: fix kdoc warnings on nested structures)
  struct nfp_prog;
  struct nfp_insn_meta;
  typedef int (*instr_cb_t)(struct nfp_prog *, struct nfp_insn_meta *);
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/main.h
diff --git a/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c b/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c
index 32e2f58370a0..f9bc06ef945f 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c
@@ -50,9 +50,9 @@
  * @seq:		sequence number of the message
  * @count:		number of tunnels report in message
  * @flags:		options part of the request
- * @ipv4:		dest IPv4 address of active route
- * @egress_port:	port the encapsulated packet egressed
- * @extra:		reserved for future use
+ * @tun_info.ipv4:		dest IPv4 address of active route
+ * @tun_info.egress_port:	port the encapsulated packet egressed
+ * @tun_info.extra:		reserved for future use
  * @tun_info:		tunnels that have sent traffic in reported period
  */
 struct nfp_tun_active_tuns {
@@ -132,8 +132,8 @@ struct nfp_ipv4_addr_entry {
  * struct nfp_tun_mac_addr - configure MAC address of tunnel EP on NFP
  * @reserved:	reserved for future use
  * @count:	number of MAC addresses in the message
- * @index:	index of MAC address in the lookup table
- * @addr:	interface MAC address
+ * @addresses.index:	index of MAC address in the lookup table
+ * @addresses.addr:	interface MAC address
  * @addresses:	series of MACs to offload
  */
 struct nfp_tun_mac_addr {
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net.h b/drivers/net/ethernet/netronome/nfp/nfp_net.h
index ec9b8db06fe4..6f044fa21469 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@ -192,7 +192,8 @@ struct nfp_net_tx_desc {
 
 /**
  * struct nfp_net_tx_buf - software TX buffer descriptor
- * @skb:	sk_buff associated with this buffer
+ * @skb:	normal ring, sk_buff associated with this buffer
+ * @frag:	XDP ring, page frag associated with this buffer
  * @dma_addr:	DMA mapping address of the buffer
  * @fidx:	Fragment index (-1 for the head and [0..nr_frags-1] for frags)
  * @pkt_cnt:	Number of packets to be produced out of the skb associated
@@ -374,6 +375,9 @@ struct nfp_net_rx_ring {
  * struct nfp_net_r_vector - Per ring interrupt vector configuration
  * @nfp_net:        Backpointer to nfp_net structure
  * @napi:           NAPI structure for this ring vec
+ * @tasklet:        ctrl vNIC, tasklet for servicing the r_vec
+ * @queue:          ctrl vNIC, send queue
+ * @lock:           ctrl vNIC, r_vec lock protects @queue
  * @tx_ring:        Pointer to TX ring
  * @rx_ring:        Pointer to RX ring
  * @xdp_ring:	    Pointer to an extra TX ring for XDP
diff --git a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.h b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.h
index 820dade03c9d..73ce0818f3c3 100644
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.h
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.h
@@ -97,28 +97,29 @@ enum nfp_eth_fec {
  * @max_index:	max of @index fields of all @ports
  * @ports:	table of ports
  *
- * @eth_index:	port index according to legacy ethX numbering
- * @index:	chip-wide first channel index
- * @nbi:	NBI index
- * @base:	first channel index (within NBI)
- * @lanes:	number of channels
- * @speed:	interface speed (in Mbps)
- * @interface:	interface (module) plugged in
- * @media:	media type of the @interface
- * @fec:	forward error correction mode
- * @aneg:	auto negotiation mode
- * @mac_addr:	interface MAC address
- * @label_port:	port id
- * @label_subport:  id of interface within port (for split ports)
- * @enabled:	is enabled?
- * @tx_enabled:	is TX enabled?
- * @rx_enabled:	is RX enabled?
- * @override_changed: is media reconfig pending?
+ * @ports.eth_index:	port index according to legacy ethX numbering
+ * @ports.index:	chip-wide first channel index
+ * @ports.nbi:		NBI index
+ * @ports.base:		first channel index (within NBI)
+ * @ports.lanes:	number of channels
+ * @ports.speed:	interface speed (in Mbps)
+ * @ports.interface:	interface (module) plugged in
+ * @ports.media:	media type of the @interface
+ * @ports.fec:		forward error correction mode
+ * @ports.aneg:		auto negotiation mode
+ * @ports.mac_addr:	interface MAC address
+ * @ports.label_port:	port id
+ * @ports.label_subport:  id of interface within port (for split ports)
+ * @ports.enabled:	is enabled?
+ * @ports.tx_enabled:	is TX enabled?
+ * @ports.rx_enabled:	is RX enabled?
+ * @ports.override_changed: is media reconfig pending?
  *
- * @port_type:	one of %PORT_* defines for ethtool
- * @port_lanes:	total number of lanes on the port (sum of lanes of all subports)
- * @is_split:	is interface part of a split port
- * @fec_modes_supported:	bitmap of FEC modes supported
+ * @ports.port_type:	one of %PORT_* defines for ethtool
+ * @ports.port_lanes:	total number of lanes on the port (sum of lanes of all
+ *			subports)
+ * @ports.is_split:	is interface part of a split port
+ * @ports.fec_modes_supported:	bitmap of FEC modes supported
  */
 struct nfp_eth_table {
 	unsigned int count;
diff --git a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_resource.c b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_resource.c
index b1dd13ff282b..7e14725055c7 100644
--- a/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_resource.c
+++ b/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_resource.c
@@ -56,16 +56,17 @@
 
 /**
  * struct nfp_resource_entry - Resource table entry
- * @owner:		NFP CPP Lock, interface owner
- * @key:		NFP CPP Lock, posix_crc32(name, 8)
- * @region:		Memory region descriptor
- * @name:		ASCII, zero padded name
- * @reserved
- * @cpp_action:		CPP Action
- * @cpp_token:		CPP Token
- * @cpp_target:		CPP Target ID
- * @page_offset:	256-byte page offset into target's CPP address
- * @page_size:		size, in 256-byte pages
+ * @mutex:	NFP CPP Lock
+ * @mutex.owner:	NFP CPP Lock, interface owner
+ * @mutex.key:		NFP CPP Lock, posix_crc32(name, 8)
+ * @region:	Memory region descriptor
+ * @region.name:	ASCII, zero padded name
+ * @region.reserved:	padding
+ * @region.cpp_action:	CPP Action
+ * @region.cpp_token:	CPP Token
+ * @region.cpp_target:	CPP Target ID
+ * @region.page_offset:	256-byte page offset into target's CPP address
+ * @region.page_size:	size, in 256-byte pages
  */
 struct nfp_resource_entry {
 	struct nfp_resource_entry_mutex {
