libnvdimm, pmem: disable dax flushing when pmem is fronting a volatile region

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit 0b277961f4484fb3f142caaa1dd1748cb0b2cbee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0b277961.failed

The pmem driver attaches to both persistent and volatile memory ranges
advertised by the ACPI NFIT. When the region is volatile it is redundant
to spend cycles flushing caches at fsync(). Check if the hosting region
is volatile and do not set dax_write_cache() if it is.

	Cc: Jan Kara <jack@suse.cz>
	Cc: Jeff Moyer <jmoyer@redhat.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: Matthew Wilcox <mawilcox@microsoft.com>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 0b277961f4484fb3f142caaa1dd1748cb0b2cbee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvdimm/pmem.c
diff --cc drivers/nvdimm/pmem.c
index 49eeb1950ba6,e7a40f77f729..000000000000
--- a/drivers/nvdimm/pmem.c
+++ b/drivers/nvdimm/pmem.c
@@@ -334,10 -363,9 +337,14 @@@ static int pmem_attach_disk(struct devi
  		return PTR_ERR(addr);
  	pmem->virt_addr = addr;
  
++<<<<<<< HEAD
 +	blk_queue_flush(q, REQ_FLUSH|REQ_FUA);
++=======
+ 	blk_queue_write_cache(q, wbc, fua);
++>>>>>>> 0b277961f448 (libnvdimm, pmem: disable dax flushing when pmem is fronting a volatile region)
  	blk_queue_make_request(q, pmem_make_request);
  	blk_queue_physical_block_size(q, PAGE_SIZE);
 +	blk_queue_logical_block_size(q, pmem_sector_size(ndns));
  	blk_queue_max_hw_sectors(q, UINT_MAX);
  	blk_queue_bounce_limit(q, BLK_BOUNCE_ANY);
  	queue_flag_set_unlocked(QUEUE_FLAG_NONROT, q);
@@@ -366,9 -393,13 +373,13 @@@
  		put_disk(disk);
  		return -ENOMEM;
  	}
++<<<<<<< HEAD
++=======
+ 	dax_write_cache(dax_dev, wbc);
++>>>>>>> 0b277961f448 (libnvdimm, pmem: disable dax flushing when pmem is fronting a volatile region)
  	pmem->dax_dev = dax_dev;
  
 -	gendev = disk_to_dev(disk);
 -	gendev->groups = pmem_attribute_groups;
 -
 -	device_add_disk(dev, disk);
 +	add_disk(disk);
  	if (devm_add_action_or_reset(dev, pmem_release_disk, pmem))
  		return -ENOMEM;
  
* Unmerged path drivers/nvdimm/pmem.c
diff --git a/drivers/nvdimm/region_devs.c b/drivers/nvdimm/region_devs.c
index 6ef40b0f2bfd..3c69800d0ea5 100644
--- a/drivers/nvdimm/region_devs.c
+++ b/drivers/nvdimm/region_devs.c
@@ -1096,6 +1096,12 @@ int nvdimm_has_flush(struct nd_region *nd_region)
 }
 EXPORT_SYMBOL_GPL(nvdimm_has_flush);
 
+int nvdimm_has_cache(struct nd_region *nd_region)
+{
+	return is_nd_pmem(&nd_region->dev);
+}
+EXPORT_SYMBOL_GPL(nvdimm_has_cache);
+
 void __exit nd_region_devs_exit(void)
 {
 	ida_destroy(&region_ida);
diff --git a/include/linux/libnvdimm.h b/include/linux/libnvdimm.h
index a17c77f443ef..388dc7f2711f 100644
--- a/include/linux/libnvdimm.h
+++ b/include/linux/libnvdimm.h
@@ -172,4 +172,5 @@ void nd_region_release_lane(struct nd_region *nd_region, unsigned int lane);
 u64 nd_fletcher64(void *addr, size_t len, bool le);
 void nvdimm_flush(struct nd_region *nd_region);
 int nvdimm_has_flush(struct nd_region *nd_region);
+int nvdimm_has_cache(struct nd_region *nd_region);
 #endif /* __LIBNVDIMM_H__ */
