mlxsw: spectrum: Don't depend on ip_gre and ip6_gre

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Petr Machata <petrm@mellanox.com>
commit 99db5229db81e2b12d213ff7533fcaee1206e2f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/99db5229.failed

mlxsw_spectrum supports offloading of a tc action mirred egress mirror
to a gretap or an ip6gretap netdevice, which necessitates calls to
functions defined in ip_gre, ip6_gre and ip6_tunnel modules. Previously
this was enabled by introducing a hard dependency of MLXSW_SPECTRUM on
NET_IPGRE and IPV6_GRE. However the rest of mlxsw is careful about
picking which modules are absolutely required, and therefore the better
approach is to make mlxsw_spectrum tolerant of absence of one or both of
the GRE flavors.

Hence rework the NET_IPGRE and IPV6_GRE dependencies to just guard
matching modularity, and hide the corresponding code in spectrum_span.c
in an #if IS_ENABLED. Mark mlxsw_sp_span_entry_tunnel_parms_common as
maybe unused, to muffle warnings if neither GRE flavor is selected,
which seems cleaner than introducing a composite #if.

	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 99db5229db81e2b12d213ff7533fcaee1206e2f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c
index a025a77a589d,ae22a3daffbf..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c
@@@ -100,12 -118,352 +100,354 @@@ mlxsw_sp_span_entry_deconfigure(struct 
  	mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mpat), mpat_pl);
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ mlxsw_sp_span_entry_phys_deconfigure(struct mlxsw_sp_span_entry *span_entry)
+ {
+ 	mlxsw_sp_span_entry_deconfigure_common(span_entry,
+ 					    MLXSW_REG_MPAT_SPAN_TYPE_LOCAL_ETH);
+ }
+ 
+ static const
+ struct mlxsw_sp_span_entry_ops mlxsw_sp_span_entry_ops_phys = {
+ 	.can_handle = mlxsw_sp_port_dev_check,
+ 	.parms = mlxsw_sp_span_entry_phys_parms,
+ 	.configure = mlxsw_sp_span_entry_phys_configure,
+ 	.deconfigure = mlxsw_sp_span_entry_phys_deconfigure,
+ };
+ 
+ static int mlxsw_sp_span_dmac(struct neigh_table *tbl,
+ 			      const void *pkey,
+ 			      struct net_device *l3edev,
+ 			      unsigned char dmac[ETH_ALEN])
+ {
+ 	struct neighbour *neigh = neigh_lookup(tbl, pkey, l3edev);
+ 	int err = 0;
+ 
+ 	if (!neigh) {
+ 		neigh = neigh_create(tbl, pkey, l3edev);
+ 		if (IS_ERR(neigh))
+ 			return PTR_ERR(neigh);
+ 	}
+ 
+ 	neigh_event_send(neigh, NULL);
+ 
+ 	read_lock_bh(&neigh->lock);
+ 	if ((neigh->nud_state & NUD_VALID) && !neigh->dead)
+ 		memcpy(dmac, neigh->ha, ETH_ALEN);
+ 	else
+ 		err = -ENOENT;
+ 	read_unlock_bh(&neigh->lock);
+ 
+ 	neigh_release(neigh);
+ 	return err;
+ }
+ 
+ static int
+ mlxsw_sp_span_entry_unoffloadable(struct mlxsw_sp_span_parms *sparmsp)
+ {
+ 	sparmsp->dest_port = NULL;
+ 	return 0;
+ }
+ 
+ static __maybe_unused int
+ mlxsw_sp_span_entry_tunnel_parms_common(struct net_device *l3edev,
+ 					union mlxsw_sp_l3addr saddr,
+ 					union mlxsw_sp_l3addr daddr,
+ 					union mlxsw_sp_l3addr gw,
+ 					__u8 ttl,
+ 					struct neigh_table *tbl,
+ 					struct mlxsw_sp_span_parms *sparmsp)
+ {
+ 	unsigned char dmac[ETH_ALEN];
+ 
+ 	if (mlxsw_sp_l3addr_is_zero(gw))
+ 		gw = daddr;
+ 
+ 	if (!l3edev || !mlxsw_sp_port_dev_check(l3edev) ||
+ 	    mlxsw_sp_span_dmac(tbl, &gw, l3edev, dmac))
+ 		return mlxsw_sp_span_entry_unoffloadable(sparmsp);
+ 
+ 	sparmsp->dest_port = netdev_priv(l3edev);
+ 	sparmsp->ttl = ttl;
+ 	memcpy(sparmsp->dmac, dmac, ETH_ALEN);
+ 	memcpy(sparmsp->smac, l3edev->dev_addr, ETH_ALEN);
+ 	sparmsp->saddr = saddr;
+ 	sparmsp->daddr = daddr;
+ 	return 0;
+ }
+ 
+ #if IS_ENABLED(CONFIG_NET_IPGRE)
+ static struct net_device *
+ mlxsw_sp_span_gretap4_route(const struct net_device *to_dev,
+ 			    __be32 *saddrp, __be32 *daddrp)
+ {
+ 	struct ip_tunnel *tun = netdev_priv(to_dev);
+ 	struct net_device *dev = NULL;
+ 	struct ip_tunnel_parm parms;
+ 	struct rtable *rt = NULL;
+ 	struct flowi4 fl4;
+ 
+ 	/* We assume "dev" stays valid after rt is put. */
+ 	ASSERT_RTNL();
+ 
+ 	parms = mlxsw_sp_ipip_netdev_parms4(to_dev);
+ 	ip_tunnel_init_flow(&fl4, parms.iph.protocol, *daddrp, *saddrp,
+ 			    0, 0, parms.link, tun->fwmark);
+ 
+ 	rt = ip_route_output_key(tun->net, &fl4);
+ 	if (IS_ERR(rt))
+ 		return NULL;
+ 
+ 	if (rt->rt_type != RTN_UNICAST)
+ 		goto out;
+ 
+ 	dev = rt->dst.dev;
+ 	*saddrp = fl4.saddr;
+ 	*daddrp = rt->rt_gateway;
+ 
+ out:
+ 	ip_rt_put(rt);
+ 	return dev;
+ }
+ 
+ static int
+ mlxsw_sp_span_entry_gretap4_parms(const struct net_device *to_dev,
+ 				  struct mlxsw_sp_span_parms *sparmsp)
+ {
+ 	struct ip_tunnel_parm tparm = mlxsw_sp_ipip_netdev_parms4(to_dev);
+ 	union mlxsw_sp_l3addr saddr = { .addr4 = tparm.iph.saddr };
+ 	union mlxsw_sp_l3addr daddr = { .addr4 = tparm.iph.daddr };
+ 	bool inherit_tos = tparm.iph.tos & 0x1;
+ 	bool inherit_ttl = !tparm.iph.ttl;
+ 	union mlxsw_sp_l3addr gw = daddr;
+ 	struct net_device *l3edev;
+ 
+ 	if (!(to_dev->flags & IFF_UP) ||
+ 	    /* Reject tunnels with GRE keys, checksums, etc. */
+ 	    tparm.i_flags || tparm.o_flags ||
+ 	    /* Require a fixed TTL and a TOS copied from the mirrored packet. */
+ 	    inherit_ttl || !inherit_tos ||
+ 	    /* A destination address may not be "any". */
+ 	    mlxsw_sp_l3addr_is_zero(daddr))
+ 		return mlxsw_sp_span_entry_unoffloadable(sparmsp);
+ 
+ 	l3edev = mlxsw_sp_span_gretap4_route(to_dev, &saddr.addr4, &gw.addr4);
+ 	return mlxsw_sp_span_entry_tunnel_parms_common(l3edev, saddr, daddr, gw,
+ 						       tparm.iph.ttl,
+ 						       &arp_tbl, sparmsp);
+ }
+ 
+ static int
+ mlxsw_sp_span_entry_gretap4_configure(struct mlxsw_sp_span_entry *span_entry,
+ 				      struct mlxsw_sp_span_parms sparms)
+ {
+ 	struct mlxsw_sp_port *dest_port = sparms.dest_port;
+ 	struct mlxsw_sp *mlxsw_sp = dest_port->mlxsw_sp;
+ 	u8 local_port = dest_port->local_port;
+ 	char mpat_pl[MLXSW_REG_MPAT_LEN];
+ 	int pa_id = span_entry->id;
+ 
+ 	/* Create a new port analayzer entry for local_port. */
+ 	mlxsw_reg_mpat_pack(mpat_pl, pa_id, local_port, true,
+ 			    MLXSW_REG_MPAT_SPAN_TYPE_REMOTE_ETH_L3);
+ 	mlxsw_reg_mpat_eth_rspan_l2_pack(mpat_pl,
+ 				    MLXSW_REG_MPAT_ETH_RSPAN_VERSION_NO_HEADER,
+ 				    sparms.dmac, false);
+ 	mlxsw_reg_mpat_eth_rspan_l3_ipv4_pack(mpat_pl,
+ 					      sparms.ttl, sparms.smac,
+ 					      be32_to_cpu(sparms.saddr.addr4),
+ 					      be32_to_cpu(sparms.daddr.addr4));
+ 
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mpat), mpat_pl);
+ }
+ 
+ static void
+ mlxsw_sp_span_entry_gretap4_deconfigure(struct mlxsw_sp_span_entry *span_entry)
+ {
+ 	mlxsw_sp_span_entry_deconfigure_common(span_entry,
+ 					MLXSW_REG_MPAT_SPAN_TYPE_REMOTE_ETH_L3);
+ }
+ 
+ static const struct mlxsw_sp_span_entry_ops mlxsw_sp_span_entry_ops_gretap4 = {
+ 	.can_handle = is_gretap_dev,
+ 	.parms = mlxsw_sp_span_entry_gretap4_parms,
+ 	.configure = mlxsw_sp_span_entry_gretap4_configure,
+ 	.deconfigure = mlxsw_sp_span_entry_gretap4_deconfigure,
+ };
+ #endif
+ 
+ #if IS_ENABLED(CONFIG_IPV6_GRE)
+ static struct net_device *
+ mlxsw_sp_span_gretap6_route(const struct net_device *to_dev,
+ 			    struct in6_addr *saddrp,
+ 			    struct in6_addr *daddrp)
+ {
+ 	struct ip6_tnl *t = netdev_priv(to_dev);
+ 	struct flowi6 fl6 = t->fl.u.ip6;
+ 	struct net_device *dev = NULL;
+ 	struct dst_entry *dst;
+ 	struct rt6_info *rt6;
+ 
+ 	/* We assume "dev" stays valid after dst is released. */
+ 	ASSERT_RTNL();
+ 
+ 	fl6.flowi6_mark = t->parms.fwmark;
+ 	if (!ip6_tnl_xmit_ctl(t, &fl6.saddr, &fl6.daddr))
+ 		return NULL;
+ 
+ 	dst = ip6_route_output(t->net, NULL, &fl6);
+ 	if (!dst || dst->error)
+ 		goto out;
+ 
+ 	rt6 = container_of(dst, struct rt6_info, dst);
+ 
+ 	dev = dst->dev;
+ 	*saddrp = fl6.saddr;
+ 	*daddrp = rt6->rt6i_gateway;
+ 
+ out:
+ 	dst_release(dst);
+ 	return dev;
+ }
+ 
+ static int
+ mlxsw_sp_span_entry_gretap6_parms(const struct net_device *to_dev,
+ 				  struct mlxsw_sp_span_parms *sparmsp)
+ {
+ 	struct __ip6_tnl_parm tparm = mlxsw_sp_ipip_netdev_parms6(to_dev);
+ 	bool inherit_tos = tparm.flags & IP6_TNL_F_USE_ORIG_TCLASS;
+ 	union mlxsw_sp_l3addr saddr = { .addr6 = tparm.laddr };
+ 	union mlxsw_sp_l3addr daddr = { .addr6 = tparm.raddr };
+ 	bool inherit_ttl = !tparm.hop_limit;
+ 	union mlxsw_sp_l3addr gw = daddr;
+ 	struct net_device *l3edev;
+ 
+ 	if (!(to_dev->flags & IFF_UP) ||
+ 	    /* Reject tunnels with GRE keys, checksums, etc. */
+ 	    tparm.i_flags || tparm.o_flags ||
+ 	    /* Require a fixed TTL and a TOS copied from the mirrored packet. */
+ 	    inherit_ttl || !inherit_tos ||
+ 	    /* A destination address may not be "any". */
+ 	    mlxsw_sp_l3addr_is_zero(daddr))
+ 		return mlxsw_sp_span_entry_unoffloadable(sparmsp);
+ 
+ 	l3edev = mlxsw_sp_span_gretap6_route(to_dev, &saddr.addr6, &gw.addr6);
+ 	return mlxsw_sp_span_entry_tunnel_parms_common(l3edev, saddr, daddr, gw,
+ 						       tparm.hop_limit,
+ 						       &nd_tbl, sparmsp);
+ }
+ 
+ static int
+ mlxsw_sp_span_entry_gretap6_configure(struct mlxsw_sp_span_entry *span_entry,
+ 				      struct mlxsw_sp_span_parms sparms)
+ {
+ 	struct mlxsw_sp_port *dest_port = sparms.dest_port;
+ 	struct mlxsw_sp *mlxsw_sp = dest_port->mlxsw_sp;
+ 	u8 local_port = dest_port->local_port;
+ 	char mpat_pl[MLXSW_REG_MPAT_LEN];
+ 	int pa_id = span_entry->id;
+ 
+ 	/* Create a new port analayzer entry for local_port. */
+ 	mlxsw_reg_mpat_pack(mpat_pl, pa_id, local_port, true,
+ 			    MLXSW_REG_MPAT_SPAN_TYPE_REMOTE_ETH_L3);
+ 	mlxsw_reg_mpat_eth_rspan_l2_pack(mpat_pl,
+ 				    MLXSW_REG_MPAT_ETH_RSPAN_VERSION_NO_HEADER,
+ 				    sparms.dmac, false);
+ 	mlxsw_reg_mpat_eth_rspan_l3_ipv6_pack(mpat_pl, sparms.ttl, sparms.smac,
+ 					      sparms.saddr.addr6,
+ 					      sparms.daddr.addr6);
+ 
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mpat), mpat_pl);
+ }
+ 
+ static void
+ mlxsw_sp_span_entry_gretap6_deconfigure(struct mlxsw_sp_span_entry *span_entry)
+ {
+ 	mlxsw_sp_span_entry_deconfigure_common(span_entry,
+ 					MLXSW_REG_MPAT_SPAN_TYPE_REMOTE_ETH_L3);
+ }
+ 
+ static const
+ struct mlxsw_sp_span_entry_ops mlxsw_sp_span_entry_ops_gretap6 = {
+ 	.can_handle = is_ip6gretap_dev,
+ 	.parms = mlxsw_sp_span_entry_gretap6_parms,
+ 	.configure = mlxsw_sp_span_entry_gretap6_configure,
+ 	.deconfigure = mlxsw_sp_span_entry_gretap6_deconfigure,
+ };
+ #endif
+ 
+ static const
+ struct mlxsw_sp_span_entry_ops *const mlxsw_sp_span_entry_types[] = {
+ 	&mlxsw_sp_span_entry_ops_phys,
+ #if IS_ENABLED(CONFIG_NET_IPGRE)
+ 	&mlxsw_sp_span_entry_ops_gretap4,
+ #endif
+ #if IS_ENABLED(CONFIG_IPV6_GRE)
+ 	&mlxsw_sp_span_entry_ops_gretap6,
+ #endif
+ };
+ 
+ static int
+ mlxsw_sp_span_entry_nop_parms(const struct net_device *to_dev,
+ 			      struct mlxsw_sp_span_parms *sparmsp)
+ {
+ 	return mlxsw_sp_span_entry_unoffloadable(sparmsp);
+ }
+ 
+ static int
+ mlxsw_sp_span_entry_nop_configure(struct mlxsw_sp_span_entry *span_entry,
+ 				  struct mlxsw_sp_span_parms sparms)
+ {
+ 	return 0;
+ }
+ 
+ static void
+ mlxsw_sp_span_entry_nop_deconfigure(struct mlxsw_sp_span_entry *span_entry)
+ {
+ }
+ 
+ static const struct mlxsw_sp_span_entry_ops mlxsw_sp_span_entry_ops_nop = {
+ 	.parms = mlxsw_sp_span_entry_nop_parms,
+ 	.configure = mlxsw_sp_span_entry_nop_configure,
+ 	.deconfigure = mlxsw_sp_span_entry_nop_deconfigure,
+ };
+ 
+ static void
+ mlxsw_sp_span_entry_configure(struct mlxsw_sp *mlxsw_sp,
+ 			      struct mlxsw_sp_span_entry *span_entry,
+ 			      struct mlxsw_sp_span_parms sparms)
+ {
+ 	if (sparms.dest_port) {
+ 		if (sparms.dest_port->mlxsw_sp != mlxsw_sp) {
+ 			netdev_err(span_entry->to_dev, "Cannot mirror to %s, which belongs to a different mlxsw instance",
+ 				   sparms.dest_port->dev->name);
+ 			sparms.dest_port = NULL;
+ 		} else if (span_entry->ops->configure(span_entry, sparms)) {
+ 			netdev_err(span_entry->to_dev, "Failed to offload mirror to %s",
+ 				   sparms.dest_port->dev->name);
+ 			sparms.dest_port = NULL;
+ 		}
+ 	}
+ 
+ 	span_entry->parms = sparms;
+ }
+ 
+ static void
+ mlxsw_sp_span_entry_deconfigure(struct mlxsw_sp_span_entry *span_entry)
+ {
+ 	if (span_entry->parms.dest_port)
+ 		span_entry->ops->deconfigure(span_entry);
+ }
+ 
++>>>>>>> 99db5229db81 (mlxsw: spectrum: Don't depend on ip_gre and ip6_gre)
  static struct mlxsw_sp_span_entry *
 -mlxsw_sp_span_entry_create(struct mlxsw_sp *mlxsw_sp,
 -			   const struct net_device *to_dev,
 -			   const struct mlxsw_sp_span_entry_ops *ops,
 -			   struct mlxsw_sp_span_parms sparms)
 +mlxsw_sp_span_entry_create(struct mlxsw_sp_port *port)
  {
  	struct mlxsw_sp_span_entry *span_entry = NULL;
 +	struct mlxsw_sp *mlxsw_sp = port->mlxsw_sp;
 +	u8 local_port = port->local_port;
  	int i;
  
  	/* find a free entry to use */
diff --git a/drivers/net/ethernet/mellanox/mlxsw/Kconfig b/drivers/net/ethernet/mellanox/mlxsw/Kconfig
index d56eea310509..f4d9c9975ac3 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/Kconfig
+++ b/drivers/net/ethernet/mellanox/mlxsw/Kconfig
@@ -76,6 +76,8 @@ config MLXSW_SPECTRUM
 	depends on PSAMPLE || PSAMPLE=n
 	depends on BRIDGE || BRIDGE=n
 	depends on IPV6 || IPV6=n
+	depends on NET_IPGRE || NET_IPGRE=n
+	depends on IPV6_GRE || IPV6_GRE=n
 	select PARMAN
 	select MLXFW
 	default m
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c
