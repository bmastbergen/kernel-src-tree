netfilter: ipset: ipset list may return wrong member count for set with timeout

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Vishwanath Pai <vpai@akamai.com>
commit 7f4f7dd4417d9efd038b14d39c70170db2e0baa0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7f4f7dd4.failed

Simple testcase:

$ ipset create test hash:ip timeout 5
$ ipset add test 1.2.3.4
$ ipset add test 1.2.2.2
$ sleep 5

$ ipset l
Name: test
Type: hash:ip
Revision: 5
Header: family inet hashsize 1024 maxelem 65536 timeout 5
Size in memory: 296
References: 0
Number of entries: 2
Members:

We return "Number of entries: 2" but no members are listed. That is
because mtype_list runs "ip_set_timeout_expired" and does not list the
expired entries, but set->elements is never upated (until mtype_gc
cleans it up later).

	Reviewed-by: Joshua Hunt <johunt@akamai.com>
	Signed-off-by: Vishwanath Pai <vpai@akamai.com>
	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 7f4f7dd4417d9efd038b14d39c70170db2e0baa0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_hash_gen.h
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 9ce28af662bf,51063d9ed0f7..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -813,13 -1041,29 +813,38 @@@ mtype_test(struct ip_set *set, void *va
  static int
  mtype_head(struct ip_set *set, struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	const struct htype *h = set->data;
++=======
+ 	struct htype *h = set->data;
+ 	const struct htable *t;
++>>>>>>> 7f4f7dd4417d (netfilter: ipset: ipset list may return wrong member count for set with timeout)
  	struct nlattr *nested;
  	size_t memsize;
 -	u8 htable_bits;
  
++<<<<<<< HEAD
 +	read_lock_bh(&set->lock);
 +	memsize = mtype_ahash_memsize(h, NETS_LENGTH(set->family));
 +	read_unlock_bh(&set->lock);
++=======
+ 	/* If any members have expired, set->elements will be wrong
+ 	 * mytype_expire function will update it with the right count.
+ 	 * we do not hold set->lock here, so grab it first.
+ 	 * set->elements can still be incorrect in the case of a huge set,
+ 	 * because elements might time out during the listing.
+ 	 */
+ 	if (SET_WITH_TIMEOUT(set)) {
+ 		spin_lock_bh(&set->lock);
+ 		mtype_expire(set, h);
+ 		spin_unlock_bh(&set->lock);
+ 	}
+ 
+ 	rcu_read_lock_bh();
+ 	t = rcu_dereference_bh_nfnl(h->table);
+ 	memsize = mtype_ahash_memsize(h, t) + set->ext_size;
+ 	htable_bits = t->htable_bits;
+ 	rcu_read_unlock_bh();
++>>>>>>> 7f4f7dd4417d (netfilter: ipset: ipset list may return wrong member count for set with timeout)
  
  	nested = ipset_nest_start(skb, IPSET_ATTR_DATA);
  	if (!nested)
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
