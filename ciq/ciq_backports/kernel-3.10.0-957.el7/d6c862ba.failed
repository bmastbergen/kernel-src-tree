mlx5e: Convert ndo_setup_tc offloads to block callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jiri Pirko <jiri@mellanox.com>
commit d6c862baaf9fb27a385a101c7e86b6112bfd8f07
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d6c862ba.failed

Benefit from the newly introduced block callback infrastructure and
convert ndo_setup_tc calls for flower offloads to block callbacks.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d6c862baaf9fb27a385a101c7e86b6112bfd8f07)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index 3bc28bc1fd68,e613ce02216d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -1030,6 -1056,9 +1030,12 @@@ int mlx5e_ethtool_get_ts_info(struct ml
  int mlx5e_ethtool_flash_device(struct mlx5e_priv *priv,
  			       struct ethtool_flash *flash);
  
++<<<<<<< HEAD
++=======
+ int mlx5e_setup_tc_block_cb(enum tc_setup_type type, void *type_data,
+ 			    void *cb_priv);
+ 
++>>>>>>> d6c862baaf9f (mlx5e: Convert ndo_setup_tc offloads to block callbacks)
  /* mlx5e generic netdev management API */
  struct net_device*
  mlx5e_create_netdev(struct mlx5_core_dev *mdev, const struct mlx5e_profile *profile,
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 5e76a7bd5ba6,4edd92d9e1de..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -1077,6 -1011,12 +1078,15 @@@ mlx5e_vport_rep_load(struct mlx5_eswitc
  		goto err_detach_netdev;
  	}
  
++<<<<<<< HEAD
++=======
+ 	upriv = netdev_priv(mlx5_eswitch_get_uplink_netdev(esw));
+ 	err = tc_setup_cb_egdev_register(netdev, mlx5e_setup_tc_block_cb,
+ 					 upriv);
+ 	if (err)
+ 		goto err_neigh_cleanup;
+ 
++>>>>>>> d6c862baaf9f (mlx5e: Convert ndo_setup_tc offloads to block callbacks)
  	err = register_netdev(netdev);
  	if (err) {
  		pr_warn("Failed to register representor netdev for vport %d\n",
@@@ -1086,6 -1026,10 +1096,13 @@@
  
  	return 0;
  
++<<<<<<< HEAD
++=======
+ err_egdev_cleanup:
+ 	tc_setup_cb_egdev_unregister(netdev, mlx5e_setup_tc_block_cb,
+ 				     upriv);
+ 
++>>>>>>> d6c862baaf9f (mlx5e: Convert ndo_setup_tc offloads to block callbacks)
  err_neigh_cleanup:
  	mlx5e_rep_neigh_cleanup(rpriv);
  
@@@ -1105,9 -1049,12 +1122,16 @@@ mlx5e_vport_rep_unload(struct mlx5_eswi
  	struct mlx5e_priv *priv = netdev_priv(netdev);
  	struct mlx5e_rep_priv *rpriv = priv->ppriv;
  	void *ppriv = priv->ppriv;
+ 	struct mlx5e_priv *upriv;
  
  	unregister_netdev(rep->netdev);
++<<<<<<< HEAD
 +
++=======
+ 	upriv = netdev_priv(mlx5_eswitch_get_uplink_netdev(esw));
+ 	tc_setup_cb_egdev_unregister(netdev, mlx5e_setup_tc_block_cb,
+ 				     upriv);
++>>>>>>> d6c862baaf9f (mlx5e: Convert ndo_setup_tc offloads to block callbacks)
  	mlx5e_rep_neigh_cleanup(rpriv);
  	mlx5e_detach_netdev(priv);
  	mlx5e_destroy_netdev(priv);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index f9f9996c2b9e..9921d60fa5c0 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -2913,13 +2913,10 @@ out:
 }
 
 #ifdef CONFIG_MLX5_ESWITCH
-static int mlx5e_setup_tc_cls_flower(struct net_device *dev,
+static int mlx5e_setup_tc_cls_flower(struct mlx5e_priv *priv,
 				     struct tc_cls_flower_offload *cls_flower)
 {
-	struct mlx5e_priv *priv = netdev_priv(dev);
-
-	if (!is_classid_clsact_ingress(cls_flower->common.classid) ||
-	    cls_flower->common.chain_index)
+	if (cls_flower->common.chain_index)
 		return -EOPNOTSUPP;
 
 	switch (cls_flower->command) {
@@ -2933,6 +2930,40 @@ static int mlx5e_setup_tc_cls_flower(struct net_device *dev,
 		return -EOPNOTSUPP;
 	}
 }
+
+int mlx5e_setup_tc_block_cb(enum tc_setup_type type, void *type_data,
+			    void *cb_priv)
+{
+	struct mlx5e_priv *priv = cb_priv;
+
+	switch (type) {
+	case TC_SETUP_CLSFLOWER:
+		return mlx5e_setup_tc_cls_flower(priv, type_data);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static int mlx5e_setup_tc_block(struct net_device *dev,
+				struct tc_block_offload *f)
+{
+	struct mlx5e_priv *priv = netdev_priv(dev);
+
+	if (f->binder_type != TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
+		return -EOPNOTSUPP;
+
+	switch (f->command) {
+	case TC_BLOCK_BIND:
+		return tcf_block_cb_register(f->block, mlx5e_setup_tc_block_cb,
+					     priv, priv);
+	case TC_BLOCK_UNBIND:
+		tcf_block_cb_unregister(f->block, mlx5e_setup_tc_block_cb,
+					priv);
+		return 0;
+	default:
+		return -EOPNOTSUPP;
+	}
+}
 #endif
 
 static int mlx5e_setup_tc(struct net_device *dev, enum tc_setup_type type,
@@ -2941,7 +2972,9 @@ static int mlx5e_setup_tc(struct net_device *dev, enum tc_setup_type type,
 	switch (type) {
 #ifdef CONFIG_MLX5_ESWITCH
 	case TC_SETUP_CLSFLOWER:
-		return mlx5e_setup_tc_cls_flower(dev, type_data);
+		return 0; /* will be removed after conversion from ndo */
+	case TC_SETUP_BLOCK:
+		return mlx5e_setup_tc_block(dev, type_data);
 #endif
 	case TC_SETUP_MQPRIO:
 		return mlx5e_setup_tc_mqprio(dev, type_data);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
