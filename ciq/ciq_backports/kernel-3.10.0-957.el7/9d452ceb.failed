net/sched: Fix actions list corruption when adding offloaded tc flows

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] sched: Fix actions list corruption when adding offloaded tc flows (Ivan Vecera) [1557539]
Rebuild_FUZZ: 97.01%
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit 9d452cebd7d69e9eb22b4c0482fdbb6fc762167f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9d452ceb.failed

Prior to commit b3f55bdda8df, the networking core doesn't wire an in-place
actions list the when the low level driver is called to offload the flow,
but all low level drivers do that (call tcf_exts_to_list()) in their
offloading "add" logic.

Now, the in-place list is set in the core which goes over the list in a loop,
but also by the hw driver when their offloading code is invoked indirectly:

	cls_xxx add flow -> tc_setup_cb_call -> tc_exts_setup_cb_egdev_call -> hw driver

which messes up the core list instance upon driver return. Fix that by avoiding
in-place list on the net core code that deals with adding flows.

Fixes: b3f55bdda8df ('net: sched: introduce per-egress action device callbacks')
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9d452cebd7d69e9eb22b4c0482fdbb6fc762167f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_api.c
diff --cc net/sched/cls_api.c
index 3b8cc4dc4e82,0e96cdae9995..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -1012,27 -1176,56 +1012,46 @@@ int tcf_exts_dump_stats(struct sk_buff 
  }
  EXPORT_SYMBOL(tcf_exts_dump_stats);
  
 -static int tc_exts_setup_cb_egdev_call(struct tcf_exts *exts,
 -				       enum tc_setup_type type,
 -				       void *type_data, bool err_stop)
 +int tcf_exts_get_dev(struct net_device *dev, struct tcf_exts *exts,
 +		     struct net_device **hw_dev)
  {
 -	int ok_count = 0;
  #ifdef CONFIG_NET_CLS_ACT
  	const struct tc_action *a;
++<<<<<<< HEAD
 +	LIST_HEAD(actions);
++=======
+ 	struct net_device *dev;
+ 	int i, ret;
++>>>>>>> 9d452cebd7d6 (net/sched: Fix actions list corruption when adding offloaded tc flows)
  
  	if (!tcf_exts_has_actions(exts))
 -		return 0;
 +		return -EINVAL;
  
++<<<<<<< HEAD
 +	tcf_exts_to_list(exts, &actions);
 +	list_for_each_entry(a, &actions, list) {
 +		if (a->ops->get_dev)
 +			*hw_dev = a->ops->get_dev(a);
++=======
+ 	for (i = 0; i < exts->nr_actions; i++) {
+ 		a = exts->actions[i];
+ 		if (!a->ops->get_dev)
+ 			continue;
+ 		dev = a->ops->get_dev(a);
+ 		if (!dev || !tc_can_offload(dev))
+ 			continue;
+ 		ret = tc_setup_cb_egdev_call(dev, type, type_data, err_stop);
+ 		if (ret < 0)
+ 			return ret;
+ 		ok_count += ret;
++>>>>>>> 9d452cebd7d6 (net/sched: Fix actions list corruption when adding offloaded tc flows)
  	}
 +	if (*hw_dev)
 +		return 0;
  #endif
 -	return ok_count;
 -}
 -
 -int tc_setup_cb_call(struct tcf_block *block, struct tcf_exts *exts,
 -		     enum tc_setup_type type, void *type_data, bool err_stop)
 -{
 -	int ok_count;
 -	int ret;
 -
 -	ret = tcf_block_cb_call(block, type, type_data, err_stop);
 -	if (ret < 0)
 -		return ret;
 -	ok_count = ret;
 -
 -	if (!exts)
 -		return ok_count;
 -	ret = tc_exts_setup_cb_egdev_call(exts, type, type_data, err_stop);
 -	if (ret < 0)
 -		return ret;
 -	ok_count += ret;
 -
 -	return ok_count;
 +	return -EOPNOTSUPP;
  }
 -EXPORT_SYMBOL(tc_setup_cb_call);
 +EXPORT_SYMBOL(tcf_exts_get_dev);
  
  static int __init tc_filter_init(void)
  {
* Unmerged path net/sched/cls_api.c
