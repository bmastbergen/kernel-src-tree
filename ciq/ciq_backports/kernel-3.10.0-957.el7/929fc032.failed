ip6_gre: add the process for redirect in ip6gre_err

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit 929fc0327569aa745c9c3cb68a213c22fad3f3f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/929fc032.failed

This patch is to add redirect icmp packet process for ip6gre by
calling ip6_redirect() in ip6gre_err(), as in vti6_err.

Prior to this patch, there's even no route cache generated after
receiving redirect.

	Reported-by: Jianlin Shi <jishi@redhat.com>
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 929fc0327569aa745c9c3cb68a213c22fad3f3f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_gre.c
diff --cc net/ipv6/ip6_gre.c
index e05953a9ff71,0684d0ccaaa5..000000000000
--- a/net/ipv6/ip6_gre.c
+++ b/net/ipv6/ip6_gre.c
@@@ -368,36 -367,39 +368,43 @@@ static void ip6gre_tunnel_uninit(struc
  
  
  static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 -		       u8 type, u8 code, int offset, __be32 info)
 +		u8 type, u8 code, int offset, __be32 info)
  {
++<<<<<<< HEAD
 +	const struct ipv6hdr *ipv6h = (const struct ipv6hdr *)skb->data;
 +	__be16 *p = (__be16 *)(skb->data + offset);
 +	int grehlen = offset + 4;
++=======
+ 	struct net *net = dev_net(skb->dev);
+ 	const struct gre_base_hdr *greh;
+ 	const struct ipv6hdr *ipv6h;
+ 	int grehlen = sizeof(*greh);
++>>>>>>> 929fc0327569 (ip6_gre: add the process for redirect in ip6gre_err)
  	struct ip6_tnl *t;
 -	int key_off = 0;
  	__be16 flags;
 -	__be32 key;
  
 -	if (!pskb_may_pull(skb, offset + grehlen))
 -		return;
 -	greh = (const struct gre_base_hdr *)(skb->data + offset);
 -	flags = greh->flags;
 -	if (flags & (GRE_VERSION | GRE_ROUTING))
 -		return;
 -	if (flags & GRE_CSUM)
 -		grehlen += 4;
 -	if (flags & GRE_KEY) {
 -		key_off = grehlen + offset;
 -		grehlen += 4;
 +	flags = p[0];
 +	if (flags&(GRE_CSUM|GRE_KEY|GRE_SEQ|GRE_ROUTING|GRE_VERSION)) {
 +		if (flags&(GRE_VERSION|GRE_ROUTING))
 +			return;
 +		if (flags&GRE_KEY) {
 +			grehlen += 4;
 +			if (flags&GRE_CSUM)
 +				grehlen += 4;
 +		}
  	}
  
 -	if (!pskb_may_pull(skb, offset + grehlen))
 +	/* If only 8 bytes returned, keyed message will be dropped here */
 +	if (!pskb_may_pull(skb, grehlen))
  		return;
  	ipv6h = (const struct ipv6hdr *)skb->data;
 -	greh = (const struct gre_base_hdr *)(skb->data + offset);
 -	key = key_off ? *(__be32 *)(skb->data + key_off) : 0;
 +	p = (__be16 *)(skb->data + offset);
  
  	t = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,
 -				 key, greh->protocol);
 -	if (!t)
 +				flags & GRE_KEY ?
 +				*(((__be32 *)p) + (grehlen / 4) - 1) : 0,
 +				p[1]);
 +	if (t == NULL)
  		return;
  
  	switch (type) {
* Unmerged path net/ipv6/ip6_gre.c
