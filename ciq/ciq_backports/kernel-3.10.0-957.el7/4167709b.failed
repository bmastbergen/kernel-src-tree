x86/microcode/intel: Add a helper which gives the microcode revision

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] microcode/intel: Add a helper which gives the microcode revision (Prarit Bhargava) [1568249]
Rebuild_FUZZ: 96.97%
commit-author Borislav Petkov <bp@suse.de>
commit 4167709bbf826512a52ebd6aafda2be104adaec9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4167709b.failed

Since on Intel we're required to do CPUID(1) first, before reading
the microcode revision MSR, let's add a special helper which does the
required steps so that we don't forget to do them next time, when we
want to read the microcode revision.

	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: http://lkml.kernel.org/r/20170109114147.5082-4-bp@alien8.de
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 4167709bbf826512a52ebd6aafda2be104adaec9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/microcode_intel.h
#	arch/x86/kernel/cpu/intel.c
#	arch/x86/kernel/cpu/microcode/intel.c
diff --cc arch/x86/include/asm/microcode_intel.h
index f11207af2f16,e793fc9a9b20..000000000000
--- a/arch/x86/include/asm/microcode_intel.h
+++ b/arch/x86/include/asm/microcode_intel.h
@@@ -52,9 -52,20 +52,26 @@@ struct extended_sigtable 
  
  #define exttable_size(et) ((et)->count * EXT_SIGNATURE_SIZE + EXT_HEADER_SIZE)
  
++<<<<<<< HEAD
 +extern int has_newer_microcode(void *mc, unsigned int csig, int cpf, int rev);
 +extern int microcode_sanity_check(void *mc, int print_err);
 +extern int find_matching_signature(void *mc, unsigned int csig, int cpf);
++=======
+ static inline u32 intel_get_microcode_revision(void)
+ {
+ 	u32 rev, dummy;
+ 
+ 	native_wrmsrl(MSR_IA32_UCODE_REV, 0);
+ 
+ 	/* As documented in the SDM: Do a CPUID 1 here */
+ 	native_cpuid_eax(1);
+ 
+ 	/* get the current revision from MSR 0x8B */
+ 	native_rdmsr(MSR_IA32_UCODE_REV, dummy, rev);
+ 
+ 	return rev;
+ }
++>>>>>>> 4167709bbf82 (x86/microcode/intel: Add a helper which gives the microcode revision)
  
  #ifdef CONFIG_MICROCODE_INTEL
  extern void __init load_ucode_intel_bsp(void);
diff --cc arch/x86/kernel/cpu/intel.c
index 9ac0d10cb29f,203f860d2ab3..000000000000
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@@ -14,8 -14,7 +14,12 @@@
  #include <asm/bugs.h>
  #include <asm/cpu.h>
  #include <asm/intel-family.h>
++<<<<<<< HEAD
 +#include <asm/hwcap2.h>
 +#include <asm/elf.h>
++=======
+ #include <asm/microcode_intel.h>
++>>>>>>> 4167709bbf82 (x86/microcode/intel: Add a helper which gives the microcode revision)
  
  #ifdef CONFIG_X86_64
  #include <linux/topology.h>
@@@ -123,14 -79,8 +127,19 @@@ static void early_init_intel(struct cpu
  		(c->x86 == 0x6 && c->x86_model >= 0x0e))
  		set_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);
  
++<<<<<<< HEAD
 +	if (c->x86 >= 6 && !cpu_has(c, X86_FEATURE_IA64)) {
 +		unsigned lower_word;
 +
 +		wrmsr(MSR_IA32_UCODE_REV, 0, 0);
 +		/* Required by the SDM */
 +		sync_core();
 +		rdmsr(MSR_IA32_UCODE_REV, lower_word, c->microcode);
 +	}
++=======
+ 	if (c->x86 >= 6 && !cpu_has(c, X86_FEATURE_IA64))
+ 		c->microcode = intel_get_microcode_revision();
++>>>>>>> 4167709bbf82 (x86/microcode/intel: Add a helper which gives the microcode revision)
  
  	/*
  	 * Atom erratum AAE44/AAF40/AAG38/AAH41:
diff --cc arch/x86/kernel/cpu/microcode/intel.c
index c7e50a8f4783,faec8fa68ffd..000000000000
--- a/arch/x86/kernel/cpu/microcode/intel.c
+++ b/arch/x86/kernel/cpu/microcode/intel.c
@@@ -377,15 -390,8 +377,18 @@@ static int collect_cpu_info_early(struc
  		native_rdmsr(MSR_IA32_PLATFORM_ID, val[0], val[1]);
  		csig.pf = 1 << ((val[1] >> 18) & 7);
  	}
- 	native_wrmsrl(MSR_IA32_UCODE_REV, 0);
  
++<<<<<<< HEAD
 +	/* As documented in the SDM: Do a CPUID 1 here */
 +	sync_core();
 +
 +	/* get the current revision from MSR 0x8B */
 +	native_rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);
 +
 +	csig.rev = val[1];
++=======
+ 	csig.rev = intel_get_microcode_revision();
++>>>>>>> 4167709bbf82 (x86/microcode/intel: Add a helper which gives the microcode revision)
  
  	uci->cpu_sig = csig;
  	uci->valid = 1;
@@@ -625,14 -583,9 +628,18 @@@ static int apply_microcode_early(struc
  
  	/* write microcode via MSR 0x79 */
  	native_wrmsrl(MSR_IA32_UCODE_WRITE, (unsigned long)mc->bits);
- 	native_wrmsrl(MSR_IA32_UCODE_REV, 0);
  
++<<<<<<< HEAD
 +	/* As documented in the SDM: Do a CPUID 1 here */
 +	sync_core();
 +
 +	/* get the current revision from MSR 0x8B */
 +	native_rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);
 +	if (val[1] != mc->hdr.rev)
++=======
+ 	rev = intel_get_microcode_revision();
+ 	if (rev != mc->hdr.rev)
++>>>>>>> 4167709bbf82 (x86/microcode/intel: Add a helper which gives the microcode revision)
  		return -1;
  
  #ifdef CONFIG_X86_64
@@@ -928,15 -790,10 +935,15 @@@ static int apply_microcode_intel(int cp
  
  	/* write microcode via MSR 0x79 */
  	wrmsrl(MSR_IA32_UCODE_WRITE, (unsigned long)mc->bits);
- 	wrmsrl(MSR_IA32_UCODE_REV, 0);
  
++<<<<<<< HEAD
 +	/* As documented in the SDM: Do a CPUID 1 here */
 +	sync_core();
++=======
+ 	rev = intel_get_microcode_revision();
++>>>>>>> 4167709bbf82 (x86/microcode/intel: Add a helper which gives the microcode revision)
  
- 	/* get the current revision from MSR 0x8B */
- 	rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);
- 
- 	if (val[1] != mc->hdr.rev) {
+ 	if (rev != mc->hdr.rev) {
  		pr_err("CPU%d update to revision 0x%x failed\n",
  		       cpu, mc->hdr.rev);
  		return -1;
* Unmerged path arch/x86/include/asm/microcode_intel.h
* Unmerged path arch/x86/kernel/cpu/intel.c
* Unmerged path arch/x86/kernel/cpu/microcode/intel.c
