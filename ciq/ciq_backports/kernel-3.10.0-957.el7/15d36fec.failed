mm: disallow mappings that conflict for devm_memremap_pages()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Dave Jiang <dave.jiang@intel.com>
commit 15d36fecd0bdc7510b70a0e5ec6671140b3fce0c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/15d36fec.failed

When pmem namespaces created are smaller than section size, this can
cause an issue during removal and gpf was observed:

  general protection fault: 0000 1 SMP PTI
  CPU: 36 PID: 3941 Comm: ndctl Tainted: G W 4.14.28-1.el7uek.x86_64 #2
  task: ffff88acda150000 task.stack: ffffc900233a4000
  RIP: 0010:__put_page+0x56/0x79
  Call Trace:
    devm_memremap_pages_release+0x155/0x23a
    release_nodes+0x21e/0x260
    devres_release_all+0x3c/0x48
    device_release_driver_internal+0x15c/0x207
    device_release_driver+0x12/0x14
    unbind_store+0xba/0xd8
    drv_attr_store+0x27/0x31
    sysfs_kf_write+0x3f/0x46
    kernfs_fop_write+0x10f/0x18b
    __vfs_write+0x3a/0x16d
    vfs_write+0xb2/0x1a1
    SyS_write+0x55/0xb9
    do_syscall_64+0x79/0x1ae
    entry_SYSCALL_64_after_hwframe+0x3d/0x0

Add code to check whether we have a mapping already in the same section
and prevent additional mappings from being created if that is the case.

Link: http://lkml.kernel.org/r/152909478401.50143.312364396244072931.stgit@djiang5-desk3.ch.intel.com
	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Robert Elliott <elliott@hpe.com>
	Cc: Jeff Moyer <jmoyer@redhat.com>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 15d36fecd0bdc7510b70a0e5ec6671140b3fce0c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/memremap.c
diff --cc kernel/memremap.c
index eca98ec515d8,a734b1747466..000000000000
--- a/kernel/memremap.c
+++ b/kernel/memremap.c
@@@ -359,20 -167,38 +359,42 @@@ struct dev_pagemap *find_dev_pagemap(re
   *    treated as a "System RAM" range, i.e. not a device mmio range, but
   *    this is not enforced.
   */
 -void *devm_memremap_pages(struct device *dev, struct dev_pagemap *pgmap)
 +void *devm_memremap_pages(struct device *dev, struct resource *res,
 +		struct percpu_ref *ref, struct vmem_altmap *altmap)
  {
  	resource_size_t align_start, align_size, align_end;
 -	struct vmem_altmap *altmap = pgmap->altmap_valid ?
 -			&pgmap->altmap : NULL;
 -	struct resource *res = &pgmap->res;
  	unsigned long pfn, pgoff, order;
  	pgprot_t pgprot = PAGE_KERNEL;
 +	struct dev_pagemap *pgmap;
 +	struct page_map *page_map;
  	int error, nid, is_ram;
+ 	struct dev_pagemap *conflict_pgmap;
  
  	align_start = res->start & ~(SECTION_SIZE - 1);
  	align_size = ALIGN(res->start + resource_size(res), SECTION_SIZE)
  		- align_start;
++<<<<<<< HEAD
 +	is_ram = region_intersects_ram(align_start, align_size);
++=======
+ 	align_end = align_start + align_size - 1;
+ 
+ 	conflict_pgmap = get_dev_pagemap(PHYS_PFN(align_start), NULL);
+ 	if (conflict_pgmap) {
+ 		dev_WARN(dev, "Conflicting mapping in same section\n");
+ 		put_dev_pagemap(conflict_pgmap);
+ 		return ERR_PTR(-ENOMEM);
+ 	}
+ 
+ 	conflict_pgmap = get_dev_pagemap(PHYS_PFN(align_end), NULL);
+ 	if (conflict_pgmap) {
+ 		dev_WARN(dev, "Conflicting mapping in same section\n");
+ 		put_dev_pagemap(conflict_pgmap);
+ 		return ERR_PTR(-ENOMEM);
+ 	}
+ 
+ 	is_ram = region_intersects(align_start, align_size,
+ 		IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE);
++>>>>>>> 15d36fecd0bd (mm: disallow mappings that conflict for devm_memremap_pages())
  
  	if (is_ram == REGION_MIXED) {
  		WARN_ONCE(1, "%s attempted on mixed region %pr\n",
* Unmerged path kernel/memremap.c
