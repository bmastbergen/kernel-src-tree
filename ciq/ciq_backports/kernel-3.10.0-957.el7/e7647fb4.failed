iomap: return VM_FAULT_* codes from iomap_page_mkwrite

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Christoph Hellwig <hch@lst.de>
commit e7647fb49167809502724eb3c402cea77716fc67
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/e7647fb4.failed

All callers will need the VM_FAULT_* flags, so convert in the helper.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit e7647fb49167809502724eb3c402cea77716fc67)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_file.c
diff --cc fs/xfs/xfs_file.c
index cea567087acc,8b0181c6d2a6..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -1131,8 -1034,7 +1131,12 @@@ xfs_filemap_page_mkwrite
  	if (IS_DAX(inode)) {
  		ret = dax_iomap_fault(vmf, PE_SIZE_PTE, &xfs_iomap_ops);
  	} else {
++<<<<<<< HEAD
 +		ret = iomap_page_mkwrite(vma, vmf, &xfs_iomap_ops);
 +		ret = block_page_mkwrite_return(ret);
++=======
+ 		ret = iomap_page_mkwrite(vmf, &xfs_iomap_ops);
++>>>>>>> e7647fb49167 (iomap: return VM_FAULT_* codes from iomap_page_mkwrite)
  	}
  
  	xfs_iunlock(XFS_I(inode), XFS_MMAPLOCK_SHARED);
diff --git a/fs/iomap.c b/fs/iomap.c
index 4b8dc781bbd3..f81872222e28 100644
--- a/fs/iomap.c
+++ b/fs/iomap.c
@@ -494,10 +494,10 @@ int iomap_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,
 
 	set_page_dirty(page);
 	wait_for_stable_page(page);
-	return 0;
+	return VM_FAULT_LOCKED;
 out_unlock:
 	unlock_page(page);
-	return ret;
+	return block_page_mkwrite_return(ret);
 }
 EXPORT_SYMBOL_GPL(iomap_page_mkwrite);
 
* Unmerged path fs/xfs/xfs_file.c
