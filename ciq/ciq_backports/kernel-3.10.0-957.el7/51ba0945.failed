PCI: Delay after FLR of Intel DC P3700 NVMe

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [pci] Delay after FLR of Intel DC P3700 NVMe (Alex Williamson) [1592654]
Rebuild_FUZZ: 93.83%
commit-author Alex Williamson <alex.williamson@redhat.com>
commit 51ba09452d11b17248d80c740c2fd14c9fdc2c99
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/51ba0945.failed

Add a device-specific reset for Intel DC P3700 NVMe device which exhibits a
timeout failure in drivers waiting for the ready status to update after
NVMe enable if the driver interacts with the device too soon after FLR.  As
this has been observed in device assignment scenarios, resolve this with a
device-specific reset quirk to add an additional, heuristically determined,
delay after the FLR completes.

Link: https://bugzilla.redhat.com/show_bug.cgi?id=1592654
	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 51ba09452d11b17248d80c740c2fd14c9fdc2c99)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/quirks.c
diff --cc drivers/pci/quirks.c
index be41b3e1d0dc,deb051583eda..000000000000
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@@ -3715,6 -3665,108 +3715,111 @@@ static int reset_chelsio_generic_dev(st
  #define PCI_DEVICE_ID_INTEL_IVB_M_VGA      0x0156
  #define PCI_DEVICE_ID_INTEL_IVB_M2_VGA     0x0166
  
++<<<<<<< HEAD
++=======
+ /*
+  * The Samsung SM961/PM961 controller can sometimes enter a fatal state after
+  * FLR where config space reads from the device return -1.  We seem to be
+  * able to avoid this condition if we disable the NVMe controller prior to
+  * FLR.  This quirk is generic for any NVMe class device requiring similar
+  * assistance to quiesce the device prior to FLR.
+  *
+  * NVMe specification: https://nvmexpress.org/resources/specifications/
+  * Revision 1.0e:
+  *    Chapter 2: Required and optional PCI config registers
+  *    Chapter 3: NVMe control registers
+  *    Chapter 7.3: Reset behavior
+  */
+ static int nvme_disable_and_flr(struct pci_dev *dev, int probe)
+ {
+ 	void __iomem *bar;
+ 	u16 cmd;
+ 	u32 cfg;
+ 
+ 	if (dev->class != PCI_CLASS_STORAGE_EXPRESS ||
+ 	    !pcie_has_flr(dev) || !pci_resource_start(dev, 0))
+ 		return -ENOTTY;
+ 
+ 	if (probe)
+ 		return 0;
+ 
+ 	bar = pci_iomap(dev, 0, NVME_REG_CC + sizeof(cfg));
+ 	if (!bar)
+ 		return -ENOTTY;
+ 
+ 	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+ 	pci_write_config_word(dev, PCI_COMMAND, cmd | PCI_COMMAND_MEMORY);
+ 
+ 	cfg = readl(bar + NVME_REG_CC);
+ 
+ 	/* Disable controller if enabled */
+ 	if (cfg & NVME_CC_ENABLE) {
+ 		u32 cap = readl(bar + NVME_REG_CAP);
+ 		unsigned long timeout;
+ 
+ 		/*
+ 		 * Per nvme_disable_ctrl() skip shutdown notification as it
+ 		 * could complete commands to the admin queue.  We only intend
+ 		 * to quiesce the device before reset.
+ 		 */
+ 		cfg &= ~(NVME_CC_SHN_MASK | NVME_CC_ENABLE);
+ 
+ 		writel(cfg, bar + NVME_REG_CC);
+ 
+ 		/*
+ 		 * Some controllers require an additional delay here, see
+ 		 * NVME_QUIRK_DELAY_BEFORE_CHK_RDY.  None of those are yet
+ 		 * supported by this quirk.
+ 		 */
+ 
+ 		/* Cap register provides max timeout in 500ms increments */
+ 		timeout = ((NVME_CAP_TIMEOUT(cap) + 1) * HZ / 2) + jiffies;
+ 
+ 		for (;;) {
+ 			u32 status = readl(bar + NVME_REG_CSTS);
+ 
+ 			/* Ready status becomes zero on disable complete */
+ 			if (!(status & NVME_CSTS_RDY))
+ 				break;
+ 
+ 			msleep(100);
+ 
+ 			if (time_after(jiffies, timeout)) {
+ 				pci_warn(dev, "Timeout waiting for NVMe ready status to clear after disable\n");
+ 				break;
+ 			}
+ 		}
+ 	}
+ 
+ 	pci_iounmap(dev, bar);
+ 
+ 	pcie_flr(dev);
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Intel DC P3700 NVMe controller will timeout waiting for ready status
+  * to change after NVMe enable if the driver starts interacting with the
+  * device too soon after FLR.  A 250ms delay after FLR has heuristically
+  * proven to produce reliably working results for device assignment cases.
+  */
+ static int delay_250ms_after_flr(struct pci_dev *dev, int probe)
+ {
+ 	if (!pcie_has_flr(dev))
+ 		return -ENOTTY;
+ 
+ 	if (probe)
+ 		return 0;
+ 
+ 	pcie_flr(dev);
+ 
+ 	msleep(250);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 51ba09452d11 (PCI: Delay after FLR of Intel DC P3700 NVMe)
  static const struct pci_dev_reset_methods pci_dev_reset_methods[] = {
  	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82599_SFP_VF,
  		 reset_intel_82599_sfp_virtfn },
@@@ -3722,6 -3774,8 +3827,11 @@@
  		reset_ivb_igd },
  	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_IVB_M2_VGA,
  		reset_ivb_igd },
++<<<<<<< HEAD
++=======
+ 	{ PCI_VENDOR_ID_SAMSUNG, 0xa804, nvme_disable_and_flr },
+ 	{ PCI_VENDOR_ID_INTEL, 0x0953, delay_250ms_after_flr },
++>>>>>>> 51ba09452d11 (PCI: Delay after FLR of Intel DC P3700 NVMe)
  	{ PCI_VENDOR_ID_CHELSIO, PCI_ANY_ID,
  		reset_chelsio_generic_dev },
  	{ 0 }
* Unmerged path drivers/pci/quirks.c
