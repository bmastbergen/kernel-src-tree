xfs: correct null checks and error processing in xfs_initialize_perag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Bill O'Donnell <billodo@redhat.com>
commit b20fe4730ea5c037c16631fb0df659c7b6d4b3b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b20fe473.failed

If pag cannot be allocated, the current error exit path will trip
a null pointer deference error when calling xfs_buf_hash_destroy
with a null pag.  Fix this by adding a new error exit labels and
jumping to those accordingly, avoiding the hash destroy and
unnecessary kmem_free on pag.

Up to three things need to be properly unwound:

1) pag memory allocation
2) xfs_buf_hash_init
3) radix_tree_insert

For any given iteration through the loop, any of the above which
succeed must be unwound for /this/ pag, and then all prior
initialized pags must be unwound.

Addresses-Coverity-Id: 1397628 ("Dereference after null check")

	Reported-by: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: Bill O'Donnell <billodo@redhat.com>
	Reviewed-by: Eric Sandeen <sandeen@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit b20fe4730ea5c037c16631fb0df659c7b6d4b3b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_mount.c
diff --cc fs/xfs/xfs_mount.c
index 416b7cb28899,1f1e4ae44150..000000000000
--- a/fs/xfs/xfs_mount.c
+++ b/fs/xfs/xfs_mount.c
@@@ -209,11 -211,11 +207,16 @@@ xfs_initialize_perag
  		spin_lock_init(&pag->pag_ici_lock);
  		mutex_init(&pag->pag_ici_reclaim_lock);
  		INIT_RADIX_TREE(&pag->pag_ici_root, GFP_ATOMIC);
++<<<<<<< HEAD
 +		spin_lock_init(&pag->pag_buf_lock);
 +		pag->pag_buf_tree = RB_ROOT;
++=======
+ 		if (xfs_buf_hash_init(pag))
+ 			goto out_free_pag;
++>>>>>>> b20fe4730ea5 (xfs: correct null checks and error processing in xfs_initialize_perag)
  
  		if (radix_tree_preload(GFP_NOFS))
- 			goto out_unwind;
+ 			goto out_hash_destroy;
  
  		spin_lock(&mp->m_perag_lock);
  		if (radix_tree_insert(&mp->m_perag_tree, index, pag)) {
@@@ -231,12 -236,21 +237,26 @@@
  
  	if (maxagi)
  		*maxagi = index;
 -
 -	mp->m_ag_prealloc_blocks = xfs_prealloc_blocks(mp);
  	return 0;
  
++<<<<<<< HEAD
 +out_unwind:
++=======
+ out_hash_destroy:
+ 	xfs_buf_hash_destroy(pag);
+ out_free_pag:
++>>>>>>> b20fe4730ea5 (xfs: correct null checks and error processing in xfs_initialize_perag)
  	kmem_free(pag);
- 	for (; index > first_initialised; index--) {
+ out_unwind_new_pags:
+ 	/* unwind any prior newly initialized pags */
+ 	for (index = first_initialised; index < agcount; index++) {
  		pag = radix_tree_delete(&mp->m_perag_tree, index);
++<<<<<<< HEAD
++=======
+ 		if (!pag)
+ 			break;
+ 		xfs_buf_hash_destroy(pag);
++>>>>>>> b20fe4730ea5 (xfs: correct null checks and error processing in xfs_initialize_perag)
  		kmem_free(pag);
  	}
  	return error;
* Unmerged path fs/xfs/xfs_mount.c
