powerpc/rfi-flush: Differentiate enabled and patched flush types

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [powerpc] rfi-flush: Differentiate enabled and patched flush types (Mauricio Oliveira) [1561785]
Rebuild_FUZZ: 93.33%
commit-author Mauricio Faria de Oliveira <mauricfo@linux.vnet.ibm.com>
commit 0063d61ccfc011f379a31acaeba6de7c926fed2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0063d61c.failed

Currently the rfi-flush messages print 'Using <type> flush' for all
enabled_flush_types, but that is not necessarily true -- as now the
fallback flush is always enabled on pseries, but the fixup function
overwrites its nop/branch slot with other flush types, if available.

So, replace the 'Using <type> flush' messages with '<type> flush is
available'.

Also, print the patched flush types in the fixup function, so users
can know what is (not) being used (e.g., the slower, fallback flush,
or no flush type at all if flush is disabled via the debugfs switch).

	Suggested-by: Michael Ellerman <mpe@ellerman.id.au>
	Signed-off-by: Mauricio Faria de Oliveira <mauricfo@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 0063d61ccfc011f379a31acaeba6de7c926fed2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/setup_64.c
diff --cc arch/powerpc/kernel/setup_64.c
index 5dba321c5b53,4ec4a27b36a9..000000000000
--- a/arch/powerpc/kernel/setup_64.c
+++ b/arch/powerpc/kernel/setup_64.c
@@@ -816,32 -855,37 +816,37 @@@ void rfi_flush_enable(bool enable
  	rfi_flush = enable;
  }
  
 -static void init_fallback_flush(void)
 +void __init setup_rfi_flush(enum l1d_flush_type types, bool enable)
  {
 -	u64 l1d_size, limit;
 -	int cpu;
 -
 -	/* Only allocate the fallback flush area once (at boot time). */
 -	if (l1d_flush_fallback_area)
 -		return;
 +	if (types & L1D_FLUSH_FALLBACK) {
++<<<<<<< HEAD
 +		int cpu;
 +		u64 l1d_size = ppc64_caches.dsize;
  
 -	l1d_size = ppc64_caches.l1d.size;
 -	limit = min(ppc64_bolted_size(), ppc64_rma_size);
 +		pr_info("rfi-flush: Using fallback displacement flush\n");
  
 -	/*
 -	 * Align to L1d size, and size it at 2x L1d size, to catch possible
 -	 * hardware prefetch runoff. We don't have a recipe for load patterns to
 -	 * reliably avoid the prefetcher.
 -	 */
 -	l1d_flush_fallback_area = __va(memblock_alloc_base(l1d_size * 2, l1d_size, limit));
 -	memset(l1d_flush_fallback_area, 0, l1d_size * 2);
 +		/*
 +		 * We allocate 2x L1d size for the dummy area, to
 +		 * catch possible hardware prefetch runoff.
 +		 *
 +		 * We can't use memblock_alloc here because bootmem has
 +		 * been initialized, and the bootmem APIs don't work well
 +		 * with an upper limit we need, so we allocate it statically
 +		 * from BSS. The biggest L1d supported by this kernel is
 +		 * 64kB (POWER8), so 128kB is reserved above.
 +		 */
  
 -	for_each_possible_cpu(cpu) {
 -		paca[cpu].rfi_flush_fallback_area = l1d_flush_fallback_area;
 -		paca[cpu].l1d_flush_size = l1d_size;
 -	}
 -}
 +		WARN_ON(l1d_size > MAX_L1D_SIZE);
  
 -void setup_rfi_flush(enum l1d_flush_type types, bool enable)
 -{
 -	if (types & L1D_FLUSH_FALLBACK) {
 +		for_each_possible_cpu(cpu) {
 +			struct paca_aux_struct *paca_aux = paca_aux_of(cpu);
 +			paca_aux->rfi_flush_fallback_area = l1d_flush_fallback_area;
 +			paca_aux->l1d_flush_size = l1d_size;
 +		}
++=======
+ 		pr_info("rfi-flush: fallback displacement flush available\n");
+ 		init_fallback_flush();
++>>>>>>> 0063d61ccfc0 (powerpc/rfi-flush: Differentiate enabled and patched flush types)
  	}
  
  	if (types & L1D_FLUSH_ORI)
* Unmerged path arch/powerpc/kernel/setup_64.c
diff --git a/arch/powerpc/lib/feature-fixups.c b/arch/powerpc/lib/feature-fixups.c
index 2aca8d89d44c..a493512bc614 100644
--- a/arch/powerpc/lib/feature-fixups.c
+++ b/arch/powerpc/lib/feature-fixups.c
@@ -151,7 +151,14 @@ void do_rfi_flush_fixups(enum l1d_flush_type types)
 		patch_instruction(dest + 2, instrs[2]);
 	}
 
-	printk(KERN_DEBUG "rfi-flush: patched %d locations\n", i);
+	printk(KERN_DEBUG "rfi-flush: patched %d locations (%s flush)\n", i,
+		(types == L1D_FLUSH_NONE)       ? "no" :
+		(types == L1D_FLUSH_FALLBACK)   ? "fallback displacement" :
+		(types &  L1D_FLUSH_ORI)        ? (types & L1D_FLUSH_MTTRIG)
+							? "ori+mttrig type"
+							: "ori type" :
+		(types &  L1D_FLUSH_MTTRIG)     ? "mttrig type"
+						: "unknown");
 }
 #endif /* CONFIG_PPC_BOOK3S_64 */
 
