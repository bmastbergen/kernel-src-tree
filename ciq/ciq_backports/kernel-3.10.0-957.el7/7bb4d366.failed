x86/bugs: Make cpu_show_common() static

jira LE-1907
cve CVE-2018-3620
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] bugs: make cpu_show_common() static (Christoph von Recklinghausen) [1593384] {CVE-2018-3620}
Rebuild_FUZZ: 94.59%
commit-author Jiri Kosina <jkosina@suse.cz>
commit 7bb4d366cba992904bffa4820d24e70a3de93e76
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7bb4d366.failed

cpu_show_common() is not used outside of arch/x86/kernel/cpu/bugs.c, so
make it static.

	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 7bb4d366cba992904bffa4820d24e70a3de93e76)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/bugs.c
diff --cc arch/x86/kernel/cpu/bugs.c
index 29b8876b1f95,784753f0b41e..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -153,61 -331,344 +153,67 @@@ void __spectre_v2_select_mitigation(voi
  
  	case SPECTRE_V2_CMD_FORCE:
  	case SPECTRE_V2_CMD_AUTO:
 -		if (IS_ENABLED(CONFIG_RETPOLINE))
 -			goto retpoline_auto;
 -		break;
 -	case SPECTRE_V2_CMD_RETPOLINE_AMD:
 -		if (IS_ENABLED(CONFIG_RETPOLINE))
 -			goto retpoline_amd;
  		break;
 -	case SPECTRE_V2_CMD_RETPOLINE_GENERIC:
 -		if (IS_ENABLED(CONFIG_RETPOLINE))
 -			goto retpoline_generic;
 -		break;
 -	case SPECTRE_V2_CMD_RETPOLINE:
 -		if (IS_ENABLED(CONFIG_RETPOLINE))
 -			goto retpoline_auto;
 -		break;
 -	}
 -	pr_err("Spectre mitigation: kernel not compiled with retpoline; no mitigation available!");
 -	return;
 -
 -retpoline_auto:
 -	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) {
 -	retpoline_amd:
 -		if (!boot_cpu_has(X86_FEATURE_LFENCE_RDTSC)) {
 -			pr_err("Spectre mitigation: LFENCE not serializing, switching to generic retpoline\n");
 -			goto retpoline_generic;
 -		}
 -		mode = retp_compiler() ? SPECTRE_V2_RETPOLINE_AMD :
 -					 SPECTRE_V2_RETPOLINE_MINIMAL_AMD;
 -		setup_force_cpu_cap(X86_FEATURE_RETPOLINE_AMD);
 -		setup_force_cpu_cap(X86_FEATURE_RETPOLINE);
 -	} else {
 -	retpoline_generic:
 -		mode = retp_compiler() ? SPECTRE_V2_RETPOLINE_GENERIC :
 -					 SPECTRE_V2_RETPOLINE_MINIMAL;
 -		setup_force_cpu_cap(X86_FEATURE_RETPOLINE);
 -	}
 -
 -	spectre_v2_enabled = mode;
 -	pr_info("%s\n", spectre_v2_strings[mode]);
 -
 -	/*
 -	 * If neither SMEP nor PTI are available, there is a risk of
 -	 * hitting userspace addresses in the RSB after a context switch
 -	 * from a shallow call stack to a deeper one. To prevent this fill
 -	 * the entire RSB, even when using IBRS.
 -	 *
 -	 * Skylake era CPUs have a separate issue with *underflow* of the
 -	 * RSB, when they will predict 'ret' targets from the generic BTB.
 -	 * The proper mitigation for this is IBRS. If IBRS is not supported
 -	 * or deactivated in favour of retpolines the RSB fill on context
 -	 * switch is required.
 -	 */
 -	if ((!boot_cpu_has(X86_FEATURE_PTI) &&
 -	     !boot_cpu_has(X86_FEATURE_SMEP)) || is_skylake_era()) {
 -		setup_force_cpu_cap(X86_FEATURE_RSB_CTXSW);
 -		pr_info("Spectre v2 mitigation: Filling RSB on context switch\n");
 -	}
 -
 -	/* Initialize Indirect Branch Prediction Barrier if supported */
 -	if (boot_cpu_has(X86_FEATURE_IBPB)) {
 -		setup_force_cpu_cap(X86_FEATURE_USE_IBPB);
 -		pr_info("Spectre v2 mitigation: Enabling Indirect Branch Prediction Barrier\n");
 -	}
 -
 -	/*
 -	 * Retpoline means the kernel is safe because it has no indirect
 -	 * branches. But firmware isn't, so use IBRS to protect that.
 -	 */
 -	if (boot_cpu_has(X86_FEATURE_IBRS)) {
 -		setup_force_cpu_cap(X86_FEATURE_USE_IBRS_FW);
 -		pr_info("Enabling Restricted Speculation for firmware calls\n");
 -	}
 -}
 -
 -#undef pr_fmt
 -#define pr_fmt(fmt)	"Speculative Store Bypass: " fmt
 -
 -static enum ssb_mitigation ssb_mode __ro_after_init = SPEC_STORE_BYPASS_NONE;
 -
 -/* The kernel command line selection */
 -enum ssb_mitigation_cmd {
 -	SPEC_STORE_BYPASS_CMD_NONE,
 -	SPEC_STORE_BYPASS_CMD_AUTO,
 -	SPEC_STORE_BYPASS_CMD_ON,
 -	SPEC_STORE_BYPASS_CMD_PRCTL,
 -	SPEC_STORE_BYPASS_CMD_SECCOMP,
 -};
 -
 -static const char *ssb_strings[] = {
 -	[SPEC_STORE_BYPASS_NONE]	= "Vulnerable",
 -	[SPEC_STORE_BYPASS_DISABLE]	= "Mitigation: Speculative Store Bypass disabled",
 -	[SPEC_STORE_BYPASS_PRCTL]	= "Mitigation: Speculative Store Bypass disabled via prctl",
 -	[SPEC_STORE_BYPASS_SECCOMP]	= "Mitigation: Speculative Store Bypass disabled via prctl and seccomp",
 -};
 -
 -static const struct {
 -	const char *option;
 -	enum ssb_mitigation_cmd cmd;
 -} ssb_mitigation_options[] = {
 -	{ "auto",	SPEC_STORE_BYPASS_CMD_AUTO },    /* Platform decides */
 -	{ "on",		SPEC_STORE_BYPASS_CMD_ON },      /* Disable Speculative Store Bypass */
 -	{ "off",	SPEC_STORE_BYPASS_CMD_NONE },    /* Don't touch Speculative Store Bypass */
 -	{ "prctl",	SPEC_STORE_BYPASS_CMD_PRCTL },   /* Disable Speculative Store Bypass via prctl */
 -	{ "seccomp",	SPEC_STORE_BYPASS_CMD_SECCOMP }, /* Disable Speculative Store Bypass via prctl and seccomp */
 -};
 -
 -static enum ssb_mitigation_cmd __init ssb_parse_cmdline(void)
 -{
 -	enum ssb_mitigation_cmd cmd = SPEC_STORE_BYPASS_CMD_AUTO;
 -	char arg[20];
 -	int ret, i;
 -
 -	if (cmdline_find_option_bool(boot_command_line, "nospec_store_bypass_disable")) {
 -		return SPEC_STORE_BYPASS_CMD_NONE;
 -	} else {
 -		ret = cmdline_find_option(boot_command_line, "spec_store_bypass_disable",
 -					  arg, sizeof(arg));
 -		if (ret < 0)
 -			return SPEC_STORE_BYPASS_CMD_AUTO;
 -
 -		for (i = 0; i < ARRAY_SIZE(ssb_mitigation_options); i++) {
 -			if (!match_option(arg, ret, ssb_mitigation_options[i].option))
 -				continue;
 -
 -			cmd = ssb_mitigation_options[i].cmd;
 -			break;
 -		}
 -
 -		if (i >= ARRAY_SIZE(ssb_mitigation_options)) {
 -			pr_err("unknown option (%s). Switching to AUTO select\n", arg);
 -			return SPEC_STORE_BYPASS_CMD_AUTO;
 -		}
 -	}
 -
 -	return cmd;
 -}
 -
 -static enum ssb_mitigation __init __ssb_select_mitigation(void)
 -{
 -	enum ssb_mitigation mode = SPEC_STORE_BYPASS_NONE;
 -	enum ssb_mitigation_cmd cmd;
  
 -	if (!boot_cpu_has(X86_FEATURE_SSBD))
 -		return mode;
 -
 -	cmd = ssb_parse_cmdline();
 -	if (!boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS) &&
 -	    (cmd == SPEC_STORE_BYPASS_CMD_NONE ||
 -	     cmd == SPEC_STORE_BYPASS_CMD_AUTO))
 -		return mode;
 +	case SPECTRE_V2_CMD_RETPOLINE:
 +		spec_ctrl_enable_retpoline();
 +		return;
  
 -	switch (cmd) {
 -	case SPEC_STORE_BYPASS_CMD_AUTO:
 -	case SPEC_STORE_BYPASS_CMD_SECCOMP:
 -		/*
 -		 * Choose prctl+seccomp as the default mode if seccomp is
 -		 * enabled.
 -		 */
 -		if (IS_ENABLED(CONFIG_SECCOMP))
 -			mode = SPEC_STORE_BYPASS_SECCOMP;
 -		else
 -			mode = SPEC_STORE_BYPASS_PRCTL;
 -		break;
 -	case SPEC_STORE_BYPASS_CMD_ON:
 -		mode = SPEC_STORE_BYPASS_DISABLE;
 -		break;
 -	case SPEC_STORE_BYPASS_CMD_PRCTL:
 -		mode = SPEC_STORE_BYPASS_PRCTL;
 +	case SPECTRE_V2_CMD_IBRS:
 +		if (spec_ctrl_force_enable_ibrs())
 +			return;
  		break;
 -	case SPEC_STORE_BYPASS_CMD_NONE:
 -		break;
 -	}
 -
 -	/*
 -	 * We have three CPU feature flags that are in play here:
 -	 *  - X86_BUG_SPEC_STORE_BYPASS - CPU is susceptible.
 -	 *  - X86_FEATURE_SSBD - CPU is able to turn off speculative store bypass
 -	 *  - X86_FEATURE_SPEC_STORE_BYPASS_DISABLE - engage the mitigation
 -	 */
 -	if (mode == SPEC_STORE_BYPASS_DISABLE) {
 -		setup_force_cpu_cap(X86_FEATURE_SPEC_STORE_BYPASS_DISABLE);
 -		/*
 -		 * Intel uses the SPEC CTRL MSR Bit(2) for this, while AMD uses
 -		 * a completely different MSR and bit dependent on family.
 -		 */
 -		switch (boot_cpu_data.x86_vendor) {
 -		case X86_VENDOR_INTEL:
 -			x86_spec_ctrl_base |= SPEC_CTRL_SSBD;
 -			x86_spec_ctrl_mask &= ~SPEC_CTRL_SSBD;
 -			x86_spec_ctrl_set(SPEC_CTRL_SSBD);
 -			break;
 -		case X86_VENDOR_AMD:
 -			x86_amd_ssb_disable();
 -			break;
 -		}
 -	}
 -
 -	return mode;
 -}
 -
 -static void ssb_select_mitigation()
 -{
 -	ssb_mode = __ssb_select_mitigation();
  
 -	if (boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS))
 -		pr_info("%s\n", ssb_strings[ssb_mode]);
 -}
 -
 -#undef pr_fmt
 -#define pr_fmt(fmt)     "Speculation prctl: " fmt
 -
 -static int ssb_prctl_set(struct task_struct *task, unsigned long ctrl)
 -{
 -	bool update;
 -
 -	if (ssb_mode != SPEC_STORE_BYPASS_PRCTL &&
 -	    ssb_mode != SPEC_STORE_BYPASS_SECCOMP)
 -		return -ENXIO;
 -
 -	switch (ctrl) {
 -	case PR_SPEC_ENABLE:
 -		/* If speculation is force disabled, enable is not allowed */
 -		if (task_spec_ssb_force_disable(task))
 -			return -EPERM;
 -		task_clear_spec_ssb_disable(task);
 -		update = test_and_clear_tsk_thread_flag(task, TIF_SSBD);
 -		break;
 -	case PR_SPEC_DISABLE:
 -		task_set_spec_ssb_disable(task);
 -		update = !test_and_set_tsk_thread_flag(task, TIF_SSBD);
 +	case SPECTRE_V2_CMD_IBRS_ALWAYS:
 +		if (spec_ctrl_enable_ibrs_always() ||
 +		    spec_ctrl_force_enable_ibp_disabled())
 +			return;
  		break;
 -	case PR_SPEC_FORCE_DISABLE:
 -		task_set_spec_ssb_disable(task);
 -		task_set_spec_ssb_force_disable(task);
 -		update = !test_and_set_tsk_thread_flag(task, TIF_SSBD);
 +
 +	case SPECTRE_V2_CMD_RETPOLINE_IBRS_USER:
 +		if (spec_ctrl_enable_retpoline_ibrs_user())
 +			return;
  		break;
 -	default:
 -		return -ERANGE;
  	}
  
 -	/*
 -	 * If being set on non-current task, delay setting the CPU
 -	 * mitigation until it is next scheduled.
 -	 */
 -	if (task == current && update)
 -		speculative_store_bypass_update();
 +	if (spec_ctrl_cond_enable_ibrs(full_retpoline))
 +		return;
  
 -	return 0;
 -}
 +	if (spec_ctrl_cond_enable_ibp_disabled())
 +		return;
  
 -int arch_prctl_spec_ctrl_set(struct task_struct *task, unsigned long which,
 -			     unsigned long ctrl)
 -{
 -	switch (which) {
 -	case PR_SPEC_STORE_BYPASS:
 -		return ssb_prctl_set(task, ctrl);
 -	default:
 -		return -ENODEV;
 -	}
 +	spec_ctrl_enable_retpoline();
  }
  
 -#ifdef CONFIG_SECCOMP
 -void arch_seccomp_spec_mitigate(struct task_struct *task)
 +void spectre_v2_print_mitigation(void)
  {
 -	if (ssb_mode == SPEC_STORE_BYPASS_SECCOMP)
 -		ssb_prctl_set(task, PR_SPEC_FORCE_DISABLE);
 -}
 -#endif
  
 -static int ssb_prctl_get(struct task_struct *task)
 -{
 -	switch (ssb_mode) {
 -	case SPEC_STORE_BYPASS_DISABLE:
 -		return PR_SPEC_DISABLE;
 -	case SPEC_STORE_BYPASS_SECCOMP:
 -	case SPEC_STORE_BYPASS_PRCTL:
 -		if (task_spec_ssb_force_disable(task))
 -			return PR_SPEC_PRCTL | PR_SPEC_FORCE_DISABLE;
 -		if (task_spec_ssb_disable(task))
 -			return PR_SPEC_PRCTL | PR_SPEC_DISABLE;
 -		return PR_SPEC_PRCTL | PR_SPEC_ENABLE;
 -	default:
 -		if (boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS))
 -			return PR_SPEC_ENABLE;
 -		return PR_SPEC_NOT_AFFECTED;
 -	}
 +	pr_info("%s\n", spectre_v2_strings[spec_ctrl_get_mitigation()]);
  }
  
 -int arch_prctl_spec_ctrl_get(struct task_struct *task, unsigned long which)
 +static void __init spectre_v2_select_mitigation(void)
  {
 -	switch (which) {
 -	case PR_SPEC_STORE_BYPASS:
 -		return ssb_prctl_get(task);
 -	default:
 -		return -ENODEV;
 -	}
 +	spectre_v2_cmd = spectre_v2_parse_cmdline();
 +	__spectre_v2_select_mitigation();
 +	spectre_v2_print_mitigation();
  }
  
 -void x86_spec_ctrl_setup_ap(void)
 -{
 -	if (boot_cpu_has(X86_FEATURE_IBRS))
 -		x86_spec_ctrl_set(x86_spec_ctrl_base & ~x86_spec_ctrl_mask);
 -
 -	if (ssb_mode == SPEC_STORE_BYPASS_DISABLE)
 -		x86_amd_ssb_disable();
 -}
 +#undef pr_fmt
  
  #ifdef CONFIG_SYSFS
++<<<<<<< HEAD
 +ssize_t cpu_show_meltdown(struct device *dev,
 +			  struct device_attribute *attr, char *buf)
++=======
+ 
+ static ssize_t cpu_show_common(struct device *dev, struct device_attribute *attr,
+ 			char *buf, unsigned int bug)
++>>>>>>> 7bb4d366cba9 (x86/bugs: Make cpu_show_common() static)
  {
 -	if (!boot_cpu_has_bug(bug))
 +	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD)
  		return sprintf(buf, "Not affected\n");
 -
 -	switch (bug) {
 -	case X86_BUG_CPU_MELTDOWN:
 -		if (boot_cpu_has(X86_FEATURE_PTI))
 -			return sprintf(buf, "Mitigation: PTI\n");
 -
 -		break;
 -
 -	case X86_BUG_SPECTRE_V1:
 -		return sprintf(buf, "Mitigation: __user pointer sanitization\n");
 -
 -	case X86_BUG_SPECTRE_V2:
 -		return sprintf(buf, "%s%s%s%s\n", spectre_v2_strings[spectre_v2_enabled],
 -			       boot_cpu_has(X86_FEATURE_USE_IBPB) ? ", IBPB" : "",
 -			       boot_cpu_has(X86_FEATURE_USE_IBRS_FW) ? ", IBRS_FW" : "",
 -			       spectre_v2_module_string());
 -
 -	case X86_BUG_SPEC_STORE_BYPASS:
 -		return sprintf(buf, "%s\n", ssb_strings[ssb_mode]);
 -
 -	default:
 -		break;
 -	}
 -
 +	if (kaiser_enabled)
 +		return sprintf(buf, "Mitigation: PTI\n");
  	return sprintf(buf, "Vulnerable\n");
  }
  
* Unmerged path arch/x86/kernel/cpu/bugs.c
