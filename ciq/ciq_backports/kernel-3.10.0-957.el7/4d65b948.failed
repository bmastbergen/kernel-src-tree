ipmr: Add FIB notification access functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Yotam Gigi <yotamg@mellanox.com>
commit 4d65b9487831170e699b2fc64a91b839d729bd78
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4d65b948.failed

Make the ipmr module register as a FIB notifier. To do that, implement both
the ipmr_seq_read and ipmr_dump ops.

The ipmr_seq_read op returns a sequence counter that is incremented on
every notification related operation done by the ipmr. To implement that,
add a sequence counter in the netns_ipv4 struct and increment it whenever a
new MFC route or VIF are added or deleted. The sequence operations are
protected by the RTNL lock.

The ipmr_dump iterates the list of MFC routes and the list of VIF entries
and sends notifications about them. The entries dump is done under RCU
where the VIF dump uses the mrt_lock too, as the vif->dev field can change
under RCU.

	Signed-off-by: Yotam Gigi <yotamg@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4d65b9487831170e699b2fc64a91b839d729bd78)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mroute.h
#	include/net/netns/ipv4.h
#	net/ipv4/ipmr.c
diff --cc include/linux/mroute.h
index 50e6b3419aab,54c5cb82ddcb..000000000000
--- a/include/linux/mroute.h
+++ b/include/linux/mroute.h
@@@ -3,7 -3,9 +3,8 @@@
  
  #include <linux/in.h>
  #include <linux/pim.h>
 -#include <linux/rhashtable.h>
  #include <net/sock.h>
+ #include <net/fib_notifier.h>
  #include <uapi/linux/mroute.h>
  
  #ifdef CONFIG_IP_MROUTE
@@@ -57,8 -59,35 +58,16 @@@ struct vif_device 
  	int		link;			/* Physical interface index	*/
  };
  
+ struct vif_entry_notifier_info {
+ 	struct fib_notifier_info info;
+ 	struct net_device *dev;
+ 	vifi_t vif_index;
+ 	unsigned short vif_flags;
+ 	u32 tb_id;
+ };
+ 
  #define VIFF_STATIC 0x8000
  
 -#define VIF_EXISTS(_mrt, _idx) ((_mrt)->vif_table[_idx].dev != NULL)
 -
 -struct mr_table {
 -	struct list_head	list;
 -	possible_net_t		net;
 -	u32			id;
 -	struct sock __rcu	*mroute_sk;
 -	struct timer_list	ipmr_expire_timer;
 -	struct list_head	mfc_unres_queue;
 -	struct vif_device	vif_table[MAXVIFS];
 -	struct rhltable		mfc_hash;
 -	struct list_head	mfc_cache_list;
 -	int			maxvif;
 -	atomic_t		cache_resolve_queue_len;
 -	bool			mroute_do_assert;
 -	bool			mroute_do_pim;
 -	int			mroute_reg_vif_num;
 -};
 -
  /* mfc_flags:
   * MFC_STATIC - the entry was added statically (not by a routing daemon)
   */
@@@ -92,13 -154,12 +101,21 @@@ struct mfc_cache 
  	struct rcu_head	rcu;
  };
  
++<<<<<<< HEAD
 +#define MFC_LINES 64
 +
 +#ifdef __BIG_ENDIAN
 +#define MFC_HASH(a,b)	(((((__force u32)(__be32)a)>>24)^(((__force u32)(__be32)b)>>26))&(MFC_LINES-1))
 +#else
 +#define MFC_HASH(a,b)	((((__force u32)(__be32)a)^(((__force u32)(__be32)b)>>2))&(MFC_LINES-1))
 +#endif
++=======
+ struct mfc_entry_notifier_info {
+ 	struct fib_notifier_info info;
+ 	struct mfc_cache *mfc;
+ 	u32 tb_id;
+ };
++>>>>>>> 4d65b9487831 (ipmr: Add FIB notification access functions)
  
  struct rtmsg;
  int ipmr_get_route(struct net *net, struct sk_buff *skb,
diff --cc include/net/netns/ipv4.h
index 79c995f4a025,abc84d986da4..000000000000
--- a/include/net/netns/ipv4.h
+++ b/include/net/netns/ipv4.h
@@@ -86,5 -155,17 +86,20 @@@ struct netns_ipv4 
  	struct fib_rules_ops	*mr_rules_ops;
  #endif
  #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_IP_ROUTE_MULTIPATH
+ 	int sysctl_fib_multipath_use_neigh;
+ 	int sysctl_fib_multipath_hash_policy;
+ #endif
+ 
+ 	struct fib_notifier_ops	*notifier_ops;
+ 	unsigned int	fib_seq;	/* protected by rtnl_mutex */
+ 
+ 	struct fib_notifier_ops	*ipmr_notifier_ops;
+ 	unsigned int	ipmr_seq;	/* protected by rtnl_mutex */
+ 
+ 	atomic_t	rt_genid;
++>>>>>>> 4d65b9487831 (ipmr: Add FIB notification access functions)
  };
  #endif
diff --cc net/ipv4/ipmr.c
index 2741c7ea1966,49879c338357..000000000000
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@@ -279,9 -261,19 +279,19 @@@ static void __net_exit ipmr_rules_exit(
  		list_del(&mrt->list);
  		ipmr_free_table(mrt);
  	}
 -	fib_rules_unregister(net->ipv4.mr_rules_ops);
  	rtnl_unlock();
 +	fib_rules_unregister(net->ipv4.mr_rules_ops);
  }
+ 
+ static int ipmr_rules_dump(struct net *net, struct notifier_block *nb)
+ {
+ 	return fib_rules_dump(net, nb, RTNL_FAMILY_IPMR);
+ }
+ 
+ static unsigned int ipmr_rules_seq_read(struct net *net)
+ {
+ 	return fib_rules_seq_read(net, RTNL_FAMILY_IPMR);
+ }
  #else
  #define ipmr_for_each_table(mrt, net) \
  	for (mrt = net->ipv4.mrt; mrt; mrt = NULL)
@@@ -311,8 -308,38 +321,18 @@@ static void __net_exit ipmr_rules_exit(
  	net->ipv4.mrt = NULL;
  	rtnl_unlock();
  }
+ 
+ static int ipmr_rules_dump(struct net *net, struct notifier_block *nb)
+ {
+ 	return 0;
+ }
+ 
+ static unsigned int ipmr_rules_seq_read(struct net *net)
+ {
+ 	return 0;
+ }
  #endif
  
 -static inline int ipmr_hash_cmp(struct rhashtable_compare_arg *arg,
 -				const void *ptr)
 -{
 -	const struct mfc_cache_cmp_arg *cmparg = arg->key;
 -	struct mfc_cache *c = (struct mfc_cache *)ptr;
 -
 -	return cmparg->mfc_mcastgrp != c->mfc_mcastgrp ||
 -	       cmparg->mfc_origin != c->mfc_origin;
 -}
 -
 -static const struct rhashtable_params ipmr_rht_params = {
 -	.head_offset = offsetof(struct mfc_cache, mnode),
 -	.key_offset = offsetof(struct mfc_cache, cmparg),
 -	.key_len = sizeof(struct mfc_cache_cmp_arg),
 -	.nelem_hint = 3,
 -	.locks_mul = 1,
 -	.obj_cmpfn = ipmr_hash_cmp,
 -	.automatic_shrinking = true,
 -};
 -
  static struct mr_table *ipmr_new_table(struct net *net, u32 id)
  {
  	struct mr_table *mrt;
@@@ -536,8 -561,89 +556,45 @@@ failure
  	unregister_netdevice(dev);
  	return NULL;
  }
 -
 -/* called with rcu_read_lock() */
 -static int __pim_rcv(struct mr_table *mrt, struct sk_buff *skb,
 -		     unsigned int pimlen)
 -{
 -	struct net_device *reg_dev = NULL;
 -	struct iphdr *encap;
 -
 -	encap = (struct iphdr *)(skb_transport_header(skb) + pimlen);
 -	/* Check that:
 -	 * a. packet is really sent to a multicast group
 -	 * b. packet is not a NULL-REGISTER
 -	 * c. packet is not truncated
 -	 */
 -	if (!ipv4_is_multicast(encap->daddr) ||
 -	    encap->tot_len == 0 ||
 -	    ntohs(encap->tot_len) + pimlen > skb->len)
 -		return 1;
 -
 -	read_lock(&mrt_lock);
 -	if (mrt->mroute_reg_vif_num >= 0)
 -		reg_dev = mrt->vif_table[mrt->mroute_reg_vif_num].dev;
 -	read_unlock(&mrt_lock);
 -
 -	if (!reg_dev)
 -		return 1;
 -
 -	skb->mac_header = skb->network_header;
 -	skb_pull(skb, (u8 *)encap - skb->data);
 -	skb_reset_network_header(skb);
 -	skb->protocol = htons(ETH_P_IP);
 -	skb->ip_summed = CHECKSUM_NONE;
 -
 -	skb_tunnel_rx(skb, reg_dev, dev_net(reg_dev));
 -
 -	netif_rx(skb);
 -
 -	return NET_RX_SUCCESS;
 -}
 -#else
 -static struct net_device *ipmr_reg_vif(struct net *net, struct mr_table *mrt)
 -{
 -	return NULL;
 -}
  #endif
  
+ static int call_ipmr_vif_entry_notifier(struct notifier_block *nb,
+ 					struct net *net,
+ 					enum fib_event_type event_type,
+ 					struct vif_device *vif,
+ 					vifi_t vif_index, u32 tb_id)
+ {
+ 	struct vif_entry_notifier_info info = {
+ 		.info = {
+ 			.family = RTNL_FAMILY_IPMR,
+ 			.net = net,
+ 		},
+ 		.dev = vif->dev,
+ 		.vif_index = vif_index,
+ 		.vif_flags = vif->flags,
+ 		.tb_id = tb_id,
+ 	};
+ 
+ 	return call_fib_notifier(nb, net, event_type, &info.info);
+ }
+ 
+ static int call_ipmr_mfc_entry_notifier(struct notifier_block *nb,
+ 					struct net *net,
+ 					enum fib_event_type event_type,
+ 					struct mfc_cache *mfc, u32 tb_id)
+ {
+ 	struct mfc_entry_notifier_info info = {
+ 		.info = {
+ 			.family = RTNL_FAMILY_IPMR,
+ 			.net = net,
+ 		},
+ 		.mfc = mfc,
+ 		.tb_id = tb_id
+ 	};
+ 
+ 	return call_fib_notifier(nb, net, event_type, &info.info);
+ }
+ 
  /**
   *	vif_delete - Delete a VIF entry
   *	@notify: Set to 1, if the caller is a notifier_call
@@@ -2827,10 -3107,76 +2884,83 @@@ static const struct net_protocol pim_pr
  };
  #endif
  
++<<<<<<< HEAD
 +
 +/*
 + *	Setup for IP multicast routing
 + */
++=======
+ static unsigned int ipmr_seq_read(struct net *net)
+ {
+ 	ASSERT_RTNL();
+ 
+ 	return net->ipv4.ipmr_seq + ipmr_rules_seq_read(net);
+ }
+ 
+ static int ipmr_dump(struct net *net, struct notifier_block *nb)
+ {
+ 	struct mr_table *mrt;
+ 	int err;
+ 
+ 	err = ipmr_rules_dump(net, nb);
+ 	if (err)
+ 		return err;
+ 
+ 	ipmr_for_each_table(mrt, net) {
+ 		struct vif_device *v = &mrt->vif_table[0];
+ 		struct mfc_cache *mfc;
+ 		int vifi;
+ 
+ 		/* Notifiy on table VIF entries */
+ 		read_lock(&mrt_lock);
+ 		for (vifi = 0; vifi < mrt->maxvif; vifi++, v++) {
+ 			if (!v->dev)
+ 				continue;
+ 
+ 			call_ipmr_vif_entry_notifier(nb, net, FIB_EVENT_VIF_ADD,
+ 						     v, vifi, mrt->id);
+ 		}
+ 		read_unlock(&mrt_lock);
+ 
+ 		/* Notify on table MFC entries */
+ 		list_for_each_entry_rcu(mfc, &mrt->mfc_cache_list, list)
+ 			call_ipmr_mfc_entry_notifier(nb, net,
+ 						     FIB_EVENT_ENTRY_ADD, mfc,
+ 						     mrt->id);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static const struct fib_notifier_ops ipmr_notifier_ops_template = {
+ 	.family		= RTNL_FAMILY_IPMR,
+ 	.fib_seq_read	= ipmr_seq_read,
+ 	.fib_dump	= ipmr_dump,
+ 	.owner		= THIS_MODULE,
+ };
+ 
+ int __net_init ipmr_notifier_init(struct net *net)
+ {
+ 	struct fib_notifier_ops *ops;
+ 
+ 	net->ipv4.ipmr_seq = 0;
+ 
+ 	ops = fib_notifier_ops_register(&ipmr_notifier_ops_template, net);
+ 	if (IS_ERR(ops))
+ 		return PTR_ERR(ops);
+ 	net->ipv4.ipmr_notifier_ops = ops;
+ 
+ 	return 0;
+ }
+ 
+ static void __net_exit ipmr_notifier_exit(struct net *net)
+ {
+ 	fib_notifier_ops_unregister(net->ipv4.ipmr_notifier_ops);
+ 	net->ipv4.ipmr_notifier_ops = NULL;
+ }
+ 
+ /* Setup for IP multicast routing */
++>>>>>>> 4d65b9487831 (ipmr: Add FIB notification access functions)
  static int __net_init ipmr_net_init(struct net *net)
  {
  	int err;
* Unmerged path include/linux/mroute.h
* Unmerged path include/net/netns/ipv4.h
* Unmerged path net/ipv4/ipmr.c
