bpf: introduce BPF_MAP_TYPE_STACK_TRACE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Alexei Starovoitov <ast@fb.com>
commit d5a3b1f691865be576c2bffa708549b8cdccda19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d5a3b1f6.failed

add new map type to store stack traces and corresponding helper
bpf_get_stackid(ctx, map, flags) - walk user or kernel stack and return id
@ctx: struct pt_regs*
@map: pointer to stack_trace map
@flags: bits 0-7 - numer of stack frames to skip
        bit 8 - collect user stack instead of kernel
        bit 9 - compare stacks by hash only
        bit 10 - if two different stacks hash into the same stackid
                 discard old
        other bits - reserved
Return: >= 0 stackid on success or negative error

stackid is a 32-bit integer handle that can be further combined with
other data (including other stackid) and used as a key into maps.

Userspace will access stackmap using standard lookup/delete syscall commands to
retrieve full stack trace for given stackid.

	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d5a3b1f691865be576c2bffa708549b8cdccda19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	include/uapi/linux/bpf.h
#	kernel/bpf/Makefile
#	kernel/bpf/verifier.c
#	kernel/trace/bpf_trace.c
diff --cc include/linux/bpf.h
index d4c1f9049ad3,0cadbb7456c0..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -97,20 -125,122 +97,128 @@@ struct bpf_prog_type_list 
  	enum bpf_prog_type type;
  };
  
 +void bpf_register_prog_type(struct bpf_prog_type_list *tl);
 +
 +struct bpf_prog;
 +
  struct bpf_prog_aux {
  	atomic_t refcnt;
 -	u32 used_map_cnt;
 -	const struct bpf_verifier_ops *ops;
 +	bool is_gpl_compatible;
 +	enum bpf_prog_type prog_type;
 +	struct bpf_verifier_ops *ops;
 +	u32 id;
  	struct bpf_map **used_maps;
 +	u32 used_map_cnt;
  	struct bpf_prog *prog;
 -	struct user_struct *user;
 -	union {
 -		struct work_struct work;
 -		struct rcu_head	rcu;
 -	};
 +	struct work_struct work;
  };
  
++<<<<<<< HEAD
++=======
+ struct bpf_array {
+ 	struct bpf_map map;
+ 	u32 elem_size;
+ 	/* 'ownership' of prog_array is claimed by the first program that
+ 	 * is going to use this map or by the first program which FD is stored
+ 	 * in the map to make sure that all callers and callees have the same
+ 	 * prog_type and JITed flag
+ 	 */
+ 	enum bpf_prog_type owner_prog_type;
+ 	bool owner_jited;
+ 	union {
+ 		char value[0] __aligned(8);
+ 		void *ptrs[0] __aligned(8);
+ 		void __percpu *pptrs[0] __aligned(8);
+ 	};
+ };
+ #define MAX_TAIL_CALL_CNT 32
+ 
+ u64 bpf_tail_call(u64 ctx, u64 r2, u64 index, u64 r4, u64 r5);
+ void bpf_fd_array_map_clear(struct bpf_map *map);
+ bool bpf_prog_array_compatible(struct bpf_array *array, const struct bpf_prog *fp);
+ const struct bpf_func_proto *bpf_get_trace_printk_proto(void);
+ 
+ #ifdef CONFIG_BPF_SYSCALL
+ void bpf_register_prog_type(struct bpf_prog_type_list *tl);
+ void bpf_register_map_type(struct bpf_map_type_list *tl);
+ 
+ struct bpf_prog *bpf_prog_get(u32 ufd);
+ void bpf_prog_put(struct bpf_prog *prog);
+ void bpf_prog_put_rcu(struct bpf_prog *prog);
+ 
+ struct bpf_map *bpf_map_get_with_uref(u32 ufd);
+ struct bpf_map *__bpf_map_get(struct fd f);
+ void bpf_map_inc(struct bpf_map *map, bool uref);
+ void bpf_map_put_with_uref(struct bpf_map *map);
+ void bpf_map_put(struct bpf_map *map);
+ 
+ extern int sysctl_unprivileged_bpf_disabled;
+ 
+ int bpf_map_new_fd(struct bpf_map *map);
+ int bpf_prog_new_fd(struct bpf_prog *prog);
+ 
+ int bpf_obj_pin_user(u32 ufd, const char __user *pathname);
+ int bpf_obj_get_user(const char __user *pathname);
+ 
+ int bpf_percpu_hash_copy(struct bpf_map *map, void *key, void *value);
+ int bpf_percpu_array_copy(struct bpf_map *map, void *key, void *value);
+ int bpf_percpu_hash_update(struct bpf_map *map, void *key, void *value,
+ 			   u64 flags);
+ int bpf_percpu_array_update(struct bpf_map *map, void *key, void *value,
+ 			    u64 flags);
+ 
+ /* memcpy that is used with 8-byte aligned pointers, power-of-8 size and
+  * forced to use 'long' read/writes to try to atomically copy long counters.
+  * Best-effort only.  No barriers here, since it _will_ race with concurrent
+  * updates from BPF programs. Called from bpf syscall and mostly used with
+  * size 8 or 16 bytes, so ask compiler to inline it.
+  */
+ static inline void bpf_long_memcpy(void *dst, const void *src, u32 size)
+ {
+ 	const long *lsrc = src;
+ 	long *ldst = dst;
+ 
+ 	size /= sizeof(long);
+ 	while (size--)
+ 		*ldst++ = *lsrc++;
+ }
+ 
+ /* verify correctness of eBPF program */
+ int bpf_check(struct bpf_prog **fp, union bpf_attr *attr);
+ #else
+ static inline void bpf_register_prog_type(struct bpf_prog_type_list *tl)
+ {
+ }
+ 
+ static inline struct bpf_prog *bpf_prog_get(u32 ufd)
+ {
+ 	return ERR_PTR(-EOPNOTSUPP);
+ }
+ 
+ static inline void bpf_prog_put(struct bpf_prog *prog)
+ {
+ }
+ #endif /* CONFIG_BPF_SYSCALL */
+ 
+ /* verifier prototypes for helper functions called from eBPF programs */
+ extern const struct bpf_func_proto bpf_map_lookup_elem_proto;
+ extern const struct bpf_func_proto bpf_map_update_elem_proto;
+ extern const struct bpf_func_proto bpf_map_delete_elem_proto;
+ 
+ extern const struct bpf_func_proto bpf_get_prandom_u32_proto;
+ extern const struct bpf_func_proto bpf_get_smp_processor_id_proto;
+ extern const struct bpf_func_proto bpf_tail_call_proto;
+ extern const struct bpf_func_proto bpf_ktime_get_ns_proto;
+ extern const struct bpf_func_proto bpf_get_current_pid_tgid_proto;
+ extern const struct bpf_func_proto bpf_get_current_uid_gid_proto;
+ extern const struct bpf_func_proto bpf_get_current_comm_proto;
+ extern const struct bpf_func_proto bpf_skb_vlan_push_proto;
+ extern const struct bpf_func_proto bpf_skb_vlan_pop_proto;
+ extern const struct bpf_func_proto bpf_get_stackid_proto;
+ 
+ /* Shared helpers among cBPF and eBPF. */
+ void bpf_user_rnd_init_once(void);
+ u64 bpf_user_rnd_u32(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5);
+ 
++>>>>>>> d5a3b1f69186 (bpf: introduce BPF_MAP_TYPE_STACK_TRACE)
  #endif /* _LINUX_BPF_H */
diff --cc include/uapi/linux/bpf.h
index e369860b690e,d3e77da8e9e8..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -110,7 -77,13 +110,17 @@@ enum bpf_cmd 
  
  enum bpf_map_type {
  	BPF_MAP_TYPE_UNSPEC,
++<<<<<<< HEAD
 +	BPF_PROG_TYPE_XDP,
++=======
+ 	BPF_MAP_TYPE_HASH,
+ 	BPF_MAP_TYPE_ARRAY,
+ 	BPF_MAP_TYPE_PROG_ARRAY,
+ 	BPF_MAP_TYPE_PERF_EVENT_ARRAY,
+ 	BPF_MAP_TYPE_PERCPU_HASH,
+ 	BPF_MAP_TYPE_PERCPU_ARRAY,
+ 	BPF_MAP_TYPE_STACK_TRACE,
++>>>>>>> d5a3b1f69186 (bpf: introduce BPF_MAP_TYPE_STACK_TRACE)
  };
  
  enum bpf_prog_type {
@@@ -162,7 -141,209 +172,215 @@@ struct xdp_md 
   */
  enum bpf_func_id {
  	BPF_FUNC_unspec,
++<<<<<<< HEAD
 +	__BPF_FUNC_MAX_ID,
 +};
 +
++=======
+ 	BPF_FUNC_map_lookup_elem, /* void *map_lookup_elem(&map, &key) */
+ 	BPF_FUNC_map_update_elem, /* int map_update_elem(&map, &key, &value, flags) */
+ 	BPF_FUNC_map_delete_elem, /* int map_delete_elem(&map, &key) */
+ 	BPF_FUNC_probe_read,      /* int bpf_probe_read(void *dst, int size, void *src) */
+ 	BPF_FUNC_ktime_get_ns,    /* u64 bpf_ktime_get_ns(void) */
+ 	BPF_FUNC_trace_printk,    /* int bpf_trace_printk(const char *fmt, int fmt_size, ...) */
+ 	BPF_FUNC_get_prandom_u32, /* u32 prandom_u32(void) */
+ 	BPF_FUNC_get_smp_processor_id, /* u32 raw_smp_processor_id(void) */
+ 
+ 	/**
+ 	 * skb_store_bytes(skb, offset, from, len, flags) - store bytes into packet
+ 	 * @skb: pointer to skb
+ 	 * @offset: offset within packet from skb->mac_header
+ 	 * @from: pointer where to copy bytes from
+ 	 * @len: number of bytes to store into packet
+ 	 * @flags: bit 0 - if true, recompute skb->csum
+ 	 *         other bits - reserved
+ 	 * Return: 0 on success
+ 	 */
+ 	BPF_FUNC_skb_store_bytes,
+ 
+ 	/**
+ 	 * l3_csum_replace(skb, offset, from, to, flags) - recompute IP checksum
+ 	 * @skb: pointer to skb
+ 	 * @offset: offset within packet where IP checksum is located
+ 	 * @from: old value of header field
+ 	 * @to: new value of header field
+ 	 * @flags: bits 0-3 - size of header field
+ 	 *         other bits - reserved
+ 	 * Return: 0 on success
+ 	 */
+ 	BPF_FUNC_l3_csum_replace,
+ 
+ 	/**
+ 	 * l4_csum_replace(skb, offset, from, to, flags) - recompute TCP/UDP checksum
+ 	 * @skb: pointer to skb
+ 	 * @offset: offset within packet where TCP/UDP checksum is located
+ 	 * @from: old value of header field
+ 	 * @to: new value of header field
+ 	 * @flags: bits 0-3 - size of header field
+ 	 *         bit 4 - is pseudo header
+ 	 *         other bits - reserved
+ 	 * Return: 0 on success
+ 	 */
+ 	BPF_FUNC_l4_csum_replace,
+ 
+ 	/**
+ 	 * bpf_tail_call(ctx, prog_array_map, index) - jump into another BPF program
+ 	 * @ctx: context pointer passed to next program
+ 	 * @prog_array_map: pointer to map which type is BPF_MAP_TYPE_PROG_ARRAY
+ 	 * @index: index inside array that selects specific program to run
+ 	 * Return: 0 on success
+ 	 */
+ 	BPF_FUNC_tail_call,
+ 
+ 	/**
+ 	 * bpf_clone_redirect(skb, ifindex, flags) - redirect to another netdev
+ 	 * @skb: pointer to skb
+ 	 * @ifindex: ifindex of the net device
+ 	 * @flags: bit 0 - if set, redirect to ingress instead of egress
+ 	 *         other bits - reserved
+ 	 * Return: 0 on success
+ 	 */
+ 	BPF_FUNC_clone_redirect,
+ 
+ 	/**
+ 	 * u64 bpf_get_current_pid_tgid(void)
+ 	 * Return: current->tgid << 32 | current->pid
+ 	 */
+ 	BPF_FUNC_get_current_pid_tgid,
+ 
+ 	/**
+ 	 * u64 bpf_get_current_uid_gid(void)
+ 	 * Return: current_gid << 32 | current_uid
+ 	 */
+ 	BPF_FUNC_get_current_uid_gid,
+ 
+ 	/**
+ 	 * bpf_get_current_comm(char *buf, int size_of_buf)
+ 	 * stores current->comm into buf
+ 	 * Return: 0 on success
+ 	 */
+ 	BPF_FUNC_get_current_comm,
+ 
+ 	/**
+ 	 * bpf_get_cgroup_classid(skb) - retrieve a proc's classid
+ 	 * @skb: pointer to skb
+ 	 * Return: classid if != 0
+ 	 */
+ 	BPF_FUNC_get_cgroup_classid,
+ 	BPF_FUNC_skb_vlan_push, /* bpf_skb_vlan_push(skb, vlan_proto, vlan_tci) */
+ 	BPF_FUNC_skb_vlan_pop,  /* bpf_skb_vlan_pop(skb) */
+ 
+ 	/**
+ 	 * bpf_skb_[gs]et_tunnel_key(skb, key, size, flags)
+ 	 * retrieve or populate tunnel metadata
+ 	 * @skb: pointer to skb
+ 	 * @key: pointer to 'struct bpf_tunnel_key'
+ 	 * @size: size of 'struct bpf_tunnel_key'
+ 	 * @flags: room for future extensions
+ 	 * Retrun: 0 on success
+ 	 */
+ 	BPF_FUNC_skb_get_tunnel_key,
+ 	BPF_FUNC_skb_set_tunnel_key,
+ 	BPF_FUNC_perf_event_read,	/* u64 bpf_perf_event_read(&map, index) */
+ 	/**
+ 	 * bpf_redirect(ifindex, flags) - redirect to another netdev
+ 	 * @ifindex: ifindex of the net device
+ 	 * @flags: bit 0 - if set, redirect to ingress instead of egress
+ 	 *         other bits - reserved
+ 	 * Return: TC_ACT_REDIRECT
+ 	 */
+ 	BPF_FUNC_redirect,
+ 
+ 	/**
+ 	 * bpf_get_route_realm(skb) - retrieve a dst's tclassid
+ 	 * @skb: pointer to skb
+ 	 * Return: realm if != 0
+ 	 */
+ 	BPF_FUNC_get_route_realm,
+ 
+ 	/**
+ 	 * bpf_perf_event_output(ctx, map, index, data, size) - output perf raw sample
+ 	 * @ctx: struct pt_regs*
+ 	 * @map: pointer to perf_event_array map
+ 	 * @index: index of event in the map
+ 	 * @data: data on stack to be output as raw data
+ 	 * @size: size of data
+ 	 * Return: 0 on success
+ 	 */
+ 	BPF_FUNC_perf_event_output,
+ 	BPF_FUNC_skb_load_bytes,
+ 
+ 	/**
+ 	 * bpf_get_stackid(ctx, map, flags) - walk user or kernel stack and return id
+ 	 * @ctx: struct pt_regs*
+ 	 * @map: pointer to stack_trace map
+ 	 * @flags: bits 0-7 - numer of stack frames to skip
+ 	 *         bit 8 - collect user stack instead of kernel
+ 	 *         bit 9 - compare stacks by hash only
+ 	 *         bit 10 - if two different stacks hash into the same stackid
+ 	 *                  discard old
+ 	 *         other bits - reserved
+ 	 * Return: >= 0 stackid on success or negative error
+ 	 */
+ 	BPF_FUNC_get_stackid,
+ 	__BPF_FUNC_MAX_ID,
+ };
+ 
+ /* All flags used by eBPF helper functions, placed here. */
+ 
+ /* BPF_FUNC_skb_store_bytes flags. */
+ #define BPF_F_RECOMPUTE_CSUM		(1ULL << 0)
+ 
+ /* BPF_FUNC_l3_csum_replace and BPF_FUNC_l4_csum_replace flags.
+  * First 4 bits are for passing the header field size.
+  */
+ #define BPF_F_HDR_FIELD_MASK		0xfULL
+ 
+ /* BPF_FUNC_l4_csum_replace flags. */
+ #define BPF_F_PSEUDO_HDR		(1ULL << 4)
+ 
+ /* BPF_FUNC_clone_redirect and BPF_FUNC_redirect flags. */
+ #define BPF_F_INGRESS			(1ULL << 0)
+ 
+ /* BPF_FUNC_skb_set_tunnel_key and BPF_FUNC_skb_get_tunnel_key flags. */
+ #define BPF_F_TUNINFO_IPV6		(1ULL << 0)
+ 
+ /* BPF_FUNC_get_stackid flags. */
+ #define BPF_F_SKIP_FIELD_MASK		0xffULL
+ #define BPF_F_USER_STACK		(1ULL << 8)
+ #define BPF_F_FAST_STACK_CMP		(1ULL << 9)
+ #define BPF_F_REUSE_STACKID		(1ULL << 10)
+ 
+ /* user accessible mirror of in-kernel sk_buff.
+  * new fields can only be added to the end of this structure
+  */
+ struct __sk_buff {
+ 	__u32 len;
+ 	__u32 pkt_type;
+ 	__u32 mark;
+ 	__u32 queue_mapping;
+ 	__u32 protocol;
+ 	__u32 vlan_present;
+ 	__u32 vlan_tci;
+ 	__u32 vlan_proto;
+ 	__u32 priority;
+ 	__u32 ingress_ifindex;
+ 	__u32 ifindex;
+ 	__u32 tc_index;
+ 	__u32 cb[5];
+ 	__u32 hash;
+ 	__u32 tc_classid;
+ };
+ 
+ struct bpf_tunnel_key {
+ 	__u32 tunnel_id;
+ 	union {
+ 		__u32 remote_ipv4;
+ 		__u32 remote_ipv6[4];
+ 	};
+ 	__u8 tunnel_tos;
+ 	__u8 tunnel_ttl;
+ };
+ 
++>>>>>>> d5a3b1f69186 (bpf: introduce BPF_MAP_TYPE_STACK_TRACE)
  #endif /* _UAPI__LINUX_BPF_H__ */
* Unmerged path kernel/bpf/Makefile
* Unmerged path kernel/bpf/verifier.c
* Unmerged path kernel/trace/bpf_trace.c
* Unmerged path include/linux/bpf.h
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path kernel/bpf/Makefile
diff --git a/kernel/bpf/stackmap.c b/kernel/bpf/stackmap.c
new file mode 100644
index 000000000000..8a60ee14a977
--- /dev/null
+++ b/kernel/bpf/stackmap.c
@@ -0,0 +1,237 @@
+/* Copyright (c) 2016 Facebook
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ */
+#include <linux/bpf.h>
+#include <linux/jhash.h>
+#include <linux/filter.h>
+#include <linux/vmalloc.h>
+#include <linux/stacktrace.h>
+#include <linux/perf_event.h>
+
+struct stack_map_bucket {
+	struct rcu_head rcu;
+	u32 hash;
+	u32 nr;
+	u64 ip[];
+};
+
+struct bpf_stack_map {
+	struct bpf_map map;
+	u32 n_buckets;
+	struct stack_map_bucket __rcu *buckets[];
+};
+
+/* Called from syscall */
+static struct bpf_map *stack_map_alloc(union bpf_attr *attr)
+{
+	u32 value_size = attr->value_size;
+	struct bpf_stack_map *smap;
+	u64 cost, n_buckets;
+	int err;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return ERR_PTR(-EPERM);
+
+	/* check sanity of attributes */
+	if (attr->max_entries == 0 || attr->key_size != 4 ||
+	    value_size < 8 || value_size % 8 ||
+	    value_size / 8 > PERF_MAX_STACK_DEPTH)
+		return ERR_PTR(-EINVAL);
+
+	/* hash table size must be power of 2 */
+	n_buckets = roundup_pow_of_two(attr->max_entries);
+
+	cost = n_buckets * sizeof(struct stack_map_bucket *) + sizeof(*smap);
+	if (cost >= U32_MAX - PAGE_SIZE)
+		return ERR_PTR(-E2BIG);
+
+	smap = kzalloc(cost, GFP_USER | __GFP_NOWARN);
+	if (!smap) {
+		smap = vzalloc(cost);
+		if (!smap)
+			return ERR_PTR(-ENOMEM);
+	}
+
+	err = -E2BIG;
+	cost += n_buckets * (value_size + sizeof(struct stack_map_bucket));
+	if (cost >= U32_MAX - PAGE_SIZE)
+		goto free_smap;
+
+	smap->map.map_type = attr->map_type;
+	smap->map.key_size = attr->key_size;
+	smap->map.value_size = value_size;
+	smap->map.max_entries = attr->max_entries;
+	smap->n_buckets = n_buckets;
+	smap->map.pages = round_up(cost, PAGE_SIZE) >> PAGE_SHIFT;
+
+	err = get_callchain_buffers();
+	if (err)
+		goto free_smap;
+
+	return &smap->map;
+
+free_smap:
+	kvfree(smap);
+	return ERR_PTR(err);
+}
+
+static u64 bpf_get_stackid(u64 r1, u64 r2, u64 flags, u64 r4, u64 r5)
+{
+	struct pt_regs *regs = (struct pt_regs *) (long) r1;
+	struct bpf_map *map = (struct bpf_map *) (long) r2;
+	struct bpf_stack_map *smap = container_of(map, struct bpf_stack_map, map);
+	struct perf_callchain_entry *trace;
+	struct stack_map_bucket *bucket, *new_bucket, *old_bucket;
+	u32 max_depth = map->value_size / 8;
+	/* stack_map_alloc() checks that max_depth <= PERF_MAX_STACK_DEPTH */
+	u32 init_nr = PERF_MAX_STACK_DEPTH - max_depth;
+	u32 skip = flags & BPF_F_SKIP_FIELD_MASK;
+	u32 hash, id, trace_nr, trace_len;
+	bool user = flags & BPF_F_USER_STACK;
+	bool kernel = !user;
+	u64 *ips;
+
+	if (unlikely(flags & ~(BPF_F_SKIP_FIELD_MASK | BPF_F_USER_STACK |
+			       BPF_F_FAST_STACK_CMP | BPF_F_REUSE_STACKID)))
+		return -EINVAL;
+
+	trace = get_perf_callchain(regs, init_nr, kernel, user, false, false);
+
+	if (unlikely(!trace))
+		/* couldn't fetch the stack trace */
+		return -EFAULT;
+
+	/* get_perf_callchain() guarantees that trace->nr >= init_nr
+	 * and trace-nr <= PERF_MAX_STACK_DEPTH, so trace_nr <= max_depth
+	 */
+	trace_nr = trace->nr - init_nr;
+
+	if (trace_nr <= skip)
+		/* skipping more than usable stack trace */
+		return -EFAULT;
+
+	trace_nr -= skip;
+	trace_len = trace_nr * sizeof(u64);
+	ips = trace->ip + skip + init_nr;
+	hash = jhash2((u32 *)ips, trace_len / sizeof(u32), 0);
+	id = hash & (smap->n_buckets - 1);
+	bucket = rcu_dereference(smap->buckets[id]);
+
+	if (bucket && bucket->hash == hash) {
+		if (flags & BPF_F_FAST_STACK_CMP)
+			return id;
+		if (bucket->nr == trace_nr &&
+		    memcmp(bucket->ip, ips, trace_len) == 0)
+			return id;
+	}
+
+	/* this call stack is not in the map, try to add it */
+	if (bucket && !(flags & BPF_F_REUSE_STACKID))
+		return -EEXIST;
+
+	new_bucket = kmalloc(sizeof(struct stack_map_bucket) + map->value_size,
+			     GFP_ATOMIC | __GFP_NOWARN);
+	if (unlikely(!new_bucket))
+		return -ENOMEM;
+
+	memcpy(new_bucket->ip, ips, trace_len);
+	memset(new_bucket->ip + trace_len / 8, 0, map->value_size - trace_len);
+	new_bucket->hash = hash;
+	new_bucket->nr = trace_nr;
+
+	old_bucket = xchg(&smap->buckets[id], new_bucket);
+	if (old_bucket)
+		kfree_rcu(old_bucket, rcu);
+	return id;
+}
+
+const struct bpf_func_proto bpf_get_stackid_proto = {
+	.func		= bpf_get_stackid,
+	.gpl_only	= true,
+	.ret_type	= RET_INTEGER,
+	.arg1_type	= ARG_PTR_TO_CTX,
+	.arg2_type	= ARG_CONST_MAP_PTR,
+	.arg3_type	= ARG_ANYTHING,
+};
+
+/* Called from syscall or from eBPF program */
+static void *stack_map_lookup_elem(struct bpf_map *map, void *key)
+{
+	struct bpf_stack_map *smap = container_of(map, struct bpf_stack_map, map);
+	struct stack_map_bucket *bucket;
+	u32 id = *(u32 *)key;
+
+	if (unlikely(id >= smap->n_buckets))
+		return NULL;
+	bucket = rcu_dereference(smap->buckets[id]);
+	return bucket ? bucket->ip : NULL;
+}
+
+static int stack_map_get_next_key(struct bpf_map *map, void *key, void *next_key)
+{
+	return -EINVAL;
+}
+
+static int stack_map_update_elem(struct bpf_map *map, void *key, void *value,
+				 u64 map_flags)
+{
+	return -EINVAL;
+}
+
+/* Called from syscall or from eBPF program */
+static int stack_map_delete_elem(struct bpf_map *map, void *key)
+{
+	struct bpf_stack_map *smap = container_of(map, struct bpf_stack_map, map);
+	struct stack_map_bucket *old_bucket;
+	u32 id = *(u32 *)key;
+
+	if (unlikely(id >= smap->n_buckets))
+		return -E2BIG;
+
+	old_bucket = xchg(&smap->buckets[id], NULL);
+	if (old_bucket) {
+		kfree_rcu(old_bucket, rcu);
+		return 0;
+	} else {
+		return -ENOENT;
+	}
+}
+
+/* Called when map->refcnt goes to zero, either from workqueue or from syscall */
+static void stack_map_free(struct bpf_map *map)
+{
+	struct bpf_stack_map *smap = container_of(map, struct bpf_stack_map, map);
+	int i;
+
+	synchronize_rcu();
+
+	for (i = 0; i < smap->n_buckets; i++)
+		if (smap->buckets[i])
+			kfree_rcu(smap->buckets[i], rcu);
+	kvfree(smap);
+	put_callchain_buffers();
+}
+
+static const struct bpf_map_ops stack_map_ops = {
+	.map_alloc = stack_map_alloc,
+	.map_free = stack_map_free,
+	.map_get_next_key = stack_map_get_next_key,
+	.map_lookup_elem = stack_map_lookup_elem,
+	.map_update_elem = stack_map_update_elem,
+	.map_delete_elem = stack_map_delete_elem,
+};
+
+static struct bpf_map_type_list stack_map_type __read_mostly = {
+	.ops = &stack_map_ops,
+	.type = BPF_MAP_TYPE_STACK_TRACE,
+};
+
+static int __init register_stack_map(void)
+{
+	bpf_register_map_type(&stack_map_type);
+	return 0;
+}
+late_initcall(register_stack_map);
* Unmerged path kernel/bpf/verifier.c
* Unmerged path kernel/trace/bpf_trace.c
