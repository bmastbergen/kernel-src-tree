netfilter: ipset: Separate memsize calculation code into dedicated function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 722a94519a683d8ba5a8e75dec9622cc906273c1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/722a9451.failed

Hash types already has it's memsize calculation code in separate
functions. Clean up and do the same for *bitmap* and *list* sets.

Ported from a patch proposed by Sergey Popovich <popovich_sergei@mail.ua>.

	Suggested-by: Sergey Popovich <popovich_sergei@mail.ua>
	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 722a94519a683d8ba5a8e75dec9622cc906273c1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_bitmap_gen.h
#	net/netfilter/ipset/ip_set_list_set.c
diff --cc net/netfilter/ipset/ip_set_bitmap_gen.h
index 01a340ce9e94,4f07b90f8ef4..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_gen.h
+++ b/net/netfilter/ipset/ip_set_bitmap_gen.h
@@@ -79,6 -98,7 +88,10 @@@ mtype_head(struct ip_set *set, struct s
  {
  	const struct mtype *map = set->data;
  	struct nlattr *nested;
++<<<<<<< HEAD
++=======
+ 	size_t memsize = mtype_memsize(map, set->dsize);
++>>>>>>> 722a94519a68 (netfilter: ipset: Separate memsize calculation code into dedicated function)
  
  	nested = ipset_nest_start(skb, IPSET_ATTR_DATA);
  	if (!nested)
diff --cc net/netfilter/ipset/ip_set_list_set.c
index a9a97c07ecb4,462b0b1870e2..000000000000
--- a/net/netfilter/ipset/ip_set_list_set.c
+++ b/net/netfilter/ipset/ip_set_list_set.c
@@@ -477,6 -441,24 +477,29 @@@ list_set_destroy(struct ip_set *set
  	set->data = NULL;
  }
  
+ /* Calculate the actual memory size of the set data */
+ static size_t
+ list_set_memsize(const struct list_set *map, size_t dsize)
+ {
++<<<<<<< HEAD
++	const struct list_set *map = set->data;
++	struct nlattr *nested;
++=======
+ 	struct set_elem *e;
+ 	size_t memsize;
+ 	u32 n = 0;
+ 
+ 	rcu_read_lock();
+ 	list_for_each_entry_rcu(e, &map->members, list)
+ 		n++;
+ 	rcu_read_unlock();
++>>>>>>> 722a94519a68 (netfilter: ipset: Separate memsize calculation code into dedicated function)
+ 
+ 	memsize = sizeof(*map) + n * dsize;
+ 
+ 	return memsize;
+ }
+ 
  static int
  list_set_head(struct ip_set *set, struct sk_buff *skb)
  {
@@@ -487,14 -470,10 +511,20 @@@
  	if (!nested)
  		goto nla_put_failure;
  	if (nla_put_net32(skb, IPSET_ATTR_SIZE, htonl(map->size)) ||
 +	    (SET_WITH_TIMEOUT(set) &&
 +	     nla_put_net32(skb, IPSET_ATTR_TIMEOUT, htonl(map->timeout))) ||
 +	    (SET_WITH_COUNTER(set) &&
 +	     nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS,
 +			   htonl(IPSET_FLAG_WITH_COUNTERS))) ||
  	    nla_put_net32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref)) ||
++<<<<<<< HEAD
 +	    nla_put_net32(skb, IPSET_ATTR_MEMSIZE,
 +			  htonl(sizeof(*map) + map->size * map->dsize)))
++=======
+ 	    nla_put_net32(skb, IPSET_ATTR_MEMSIZE, htonl(memsize)))
+ 		goto nla_put_failure;
+ 	if (unlikely(ip_set_put_flags(skb, set)))
++>>>>>>> 722a94519a68 (netfilter: ipset: Separate memsize calculation code into dedicated function)
  		goto nla_put_failure;
  	ipset_nest_end(skb, nested);
  
* Unmerged path net/netfilter/ipset/ip_set_bitmap_gen.h
* Unmerged path net/netfilter/ipset/ip_set_list_set.c
