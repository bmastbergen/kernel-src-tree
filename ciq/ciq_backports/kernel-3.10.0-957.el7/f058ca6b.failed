liquidio: move a couple of functions to lio_core.c

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Pradeep Nalla <pradeep.nalla@cavium.com>
commit f058ca6b06d4c4685201de3760b1962641aad445
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f058ca6b.failed

To support the next patch in this series which has code that calls
octnet_get_link_stats from two different .c files, move that function (and
its dependency octnet_nic_stats_callback) to lio_core.c.  Remove
octnet_get_link_stats's static declaration and add its function prototype
in octeon_network.h.

	Signed-off-by: Pradeep Nalla <pradeep.nalla@cavium.com>
	Acked-by: Raghu Vatsavayi <raghu.vatsavayi@cavium.com>
	Signed-off-by: Felix Manlunas <felix.manlunas@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f058ca6b06d4c4685201de3760b1962641aad445)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/cavium/liquidio/lio_core.c
#	drivers/net/ethernet/cavium/liquidio/octeon_network.h
diff --cc drivers/net/ethernet/cavium/liquidio/lio_core.c
index 5c6599c797a0,334a068b6a62..000000000000
--- a/drivers/net/ethernet/cavium/liquidio/lio_core.c
+++ b/drivers/net/ethernet/cavium/liquidio/lio_core.c
@@@ -1070,3 -1061,263 +1070,266 @@@ int octeon_setup_interrupt(struct octeo
  	}
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ static void liquidio_change_mtu_completion(struct octeon_device *oct,
+ 					   u32 status, void *buf)
+ {
+ 	struct octeon_soft_command *sc = (struct octeon_soft_command *)buf;
+ 	struct liquidio_if_cfg_context *ctx;
+ 
+ 	ctx  = (struct liquidio_if_cfg_context *)sc->ctxptr;
+ 
+ 	if (status) {
+ 		dev_err(&oct->pci_dev->dev, "MTU change failed. Status: %llx\n",
+ 			CVM_CAST64(status));
+ 		WRITE_ONCE(ctx->cond, LIO_CHANGE_MTU_FAIL);
+ 	} else {
+ 		WRITE_ONCE(ctx->cond, LIO_CHANGE_MTU_SUCCESS);
+ 	}
+ 
+ 	/* This barrier is required to be sure that the response has been
+ 	 * written fully before waking up the handler
+ 	 */
+ 	wmb();
+ 
+ 	wake_up_interruptible(&ctx->wc);
+ }
+ 
+ /**
+  * \brief Net device change_mtu
+  * @param netdev network device
+  */
+ int liquidio_change_mtu(struct net_device *netdev, int new_mtu)
+ {
+ 	struct lio *lio = GET_LIO(netdev);
+ 	struct octeon_device *oct = lio->oct_dev;
+ 	struct liquidio_if_cfg_context *ctx;
+ 	struct octeon_soft_command *sc;
+ 	union octnet_cmd *ncmd;
+ 	int ctx_size;
+ 	int ret = 0;
+ 
+ 	ctx_size = sizeof(struct liquidio_if_cfg_context);
+ 	sc = (struct octeon_soft_command *)
+ 		octeon_alloc_soft_command(oct, OCTNET_CMD_SIZE, 16, ctx_size);
+ 
+ 	ncmd = (union octnet_cmd *)sc->virtdptr;
+ 	ctx  = (struct liquidio_if_cfg_context *)sc->ctxptr;
+ 
+ 	WRITE_ONCE(ctx->cond, 0);
+ 	ctx->octeon_id = lio_get_device_id(oct);
+ 	init_waitqueue_head(&ctx->wc);
+ 
+ 	ncmd->u64 = 0;
+ 	ncmd->s.cmd = OCTNET_CMD_CHANGE_MTU;
+ 	ncmd->s.param1 = new_mtu;
+ 
+ 	octeon_swap_8B_data((u64 *)ncmd, (OCTNET_CMD_SIZE >> 3));
+ 
+ 	sc->iq_no = lio->linfo.txpciq[0].s.q_no;
+ 
+ 	octeon_prepare_soft_command(oct, sc, OPCODE_NIC,
+ 				    OPCODE_NIC_CMD, 0, 0, 0);
+ 
+ 	sc->callback = liquidio_change_mtu_completion;
+ 	sc->callback_arg = sc;
+ 	sc->wait_time = 100;
+ 
+ 	ret = octeon_send_soft_command(oct, sc);
+ 	if (ret == IQ_SEND_FAILED) {
+ 		netif_info(lio, rx_err, lio->netdev, "Failed to change MTU\n");
+ 		return -EINVAL;
+ 	}
+ 	/* Sleep on a wait queue till the cond flag indicates that the
+ 	 * response arrived or timed-out.
+ 	 */
+ 	if (sleep_cond(&ctx->wc, &ctx->cond) == -EINTR ||
+ 	    ctx->cond == LIO_CHANGE_MTU_FAIL) {
+ 		octeon_free_soft_command(oct, sc);
+ 		return -EINVAL;
+ 	}
+ 
+ 	netdev->mtu = new_mtu;
+ 	lio->mtu = new_mtu;
+ 
+ 	octeon_free_soft_command(oct, sc);
+ 	return 0;
+ }
+ 
+ int lio_wait_for_clean_oq(struct octeon_device *oct)
+ {
+ 	int retry = 100, pending_pkts = 0;
+ 	int idx;
+ 
+ 	do {
+ 		pending_pkts = 0;
+ 
+ 		for (idx = 0; idx < MAX_OCTEON_OUTPUT_QUEUES(oct); idx++) {
+ 			if (!(oct->io_qmask.oq & BIT_ULL(idx)))
+ 				continue;
+ 			pending_pkts +=
+ 				atomic_read(&oct->droq[idx]->pkts_pending);
+ 		}
+ 
+ 		if (pending_pkts > 0)
+ 			schedule_timeout_uninterruptible(1);
+ 
+ 	} while (retry-- && pending_pkts);
+ 
+ 	return pending_pkts;
+ }
+ 
+ static void
+ octnet_nic_stats_callback(struct octeon_device *oct_dev,
+ 			  u32 status, void *ptr)
+ {
+ 	struct octeon_soft_command *sc = (struct octeon_soft_command *)ptr;
+ 	struct oct_nic_stats_resp *resp =
+ 	    (struct oct_nic_stats_resp *)sc->virtrptr;
+ 	struct oct_nic_stats_ctrl *ctrl =
+ 	    (struct oct_nic_stats_ctrl *)sc->ctxptr;
+ 	struct nic_rx_stats *rsp_rstats = &resp->stats.fromwire;
+ 	struct nic_tx_stats *rsp_tstats = &resp->stats.fromhost;
+ 	struct nic_rx_stats *rstats = &oct_dev->link_stats.fromwire;
+ 	struct nic_tx_stats *tstats = &oct_dev->link_stats.fromhost;
+ 
+ 	if (status != OCTEON_REQUEST_TIMEOUT && !resp->status) {
+ 		octeon_swap_8B_data((u64 *)&resp->stats,
+ 				    (sizeof(struct oct_link_stats)) >> 3);
+ 
+ 		/* RX link-level stats */
+ 		rstats->total_rcvd = rsp_rstats->total_rcvd;
+ 		rstats->bytes_rcvd = rsp_rstats->bytes_rcvd;
+ 		rstats->total_bcst = rsp_rstats->total_bcst;
+ 		rstats->total_mcst = rsp_rstats->total_mcst;
+ 		rstats->runts      = rsp_rstats->runts;
+ 		rstats->ctl_rcvd   = rsp_rstats->ctl_rcvd;
+ 		/* Accounts for over/under-run of buffers */
+ 		rstats->fifo_err  = rsp_rstats->fifo_err;
+ 		rstats->dmac_drop = rsp_rstats->dmac_drop;
+ 		rstats->fcs_err   = rsp_rstats->fcs_err;
+ 		rstats->jabber_err = rsp_rstats->jabber_err;
+ 		rstats->l2_err    = rsp_rstats->l2_err;
+ 		rstats->frame_err = rsp_rstats->frame_err;
+ 		rstats->red_drops = rsp_rstats->red_drops;
+ 
+ 		/* RX firmware stats */
+ 		rstats->fw_total_rcvd = rsp_rstats->fw_total_rcvd;
+ 		rstats->fw_total_fwd = rsp_rstats->fw_total_fwd;
+ 		rstats->fw_err_pko = rsp_rstats->fw_err_pko;
+ 		rstats->fw_err_link = rsp_rstats->fw_err_link;
+ 		rstats->fw_err_drop = rsp_rstats->fw_err_drop;
+ 		rstats->fw_rx_vxlan = rsp_rstats->fw_rx_vxlan;
+ 		rstats->fw_rx_vxlan_err = rsp_rstats->fw_rx_vxlan_err;
+ 
+ 		/* Number of packets that are LROed      */
+ 		rstats->fw_lro_pkts = rsp_rstats->fw_lro_pkts;
+ 		/* Number of octets that are LROed       */
+ 		rstats->fw_lro_octs = rsp_rstats->fw_lro_octs;
+ 		/* Number of LRO packets formed          */
+ 		rstats->fw_total_lro = rsp_rstats->fw_total_lro;
+ 		/* Number of times lRO of packet aborted */
+ 		rstats->fw_lro_aborts = rsp_rstats->fw_lro_aborts;
+ 		rstats->fw_lro_aborts_port = rsp_rstats->fw_lro_aborts_port;
+ 		rstats->fw_lro_aborts_seq = rsp_rstats->fw_lro_aborts_seq;
+ 		rstats->fw_lro_aborts_tsval = rsp_rstats->fw_lro_aborts_tsval;
+ 		rstats->fw_lro_aborts_timer = rsp_rstats->fw_lro_aborts_timer;
+ 		/* intrmod: packet forward rate */
+ 		rstats->fwd_rate = rsp_rstats->fwd_rate;
+ 
+ 		/* TX link-level stats */
+ 		tstats->total_pkts_sent = rsp_tstats->total_pkts_sent;
+ 		tstats->total_bytes_sent = rsp_tstats->total_bytes_sent;
+ 		tstats->mcast_pkts_sent = rsp_tstats->mcast_pkts_sent;
+ 		tstats->bcast_pkts_sent = rsp_tstats->bcast_pkts_sent;
+ 		tstats->ctl_sent = rsp_tstats->ctl_sent;
+ 		/* Packets sent after one collision*/
+ 		tstats->one_collision_sent = rsp_tstats->one_collision_sent;
+ 		/* Packets sent after multiple collision*/
+ 		tstats->multi_collision_sent = rsp_tstats->multi_collision_sent;
+ 		/* Packets not sent due to max collisions */
+ 		tstats->max_collision_fail = rsp_tstats->max_collision_fail;
+ 		/* Packets not sent due to max deferrals */
+ 		tstats->max_deferral_fail = rsp_tstats->max_deferral_fail;
+ 		/* Accounts for over/under-run of buffers */
+ 		tstats->fifo_err = rsp_tstats->fifo_err;
+ 		tstats->runts = rsp_tstats->runts;
+ 		/* Total number of collisions detected */
+ 		tstats->total_collisions = rsp_tstats->total_collisions;
+ 
+ 		/* firmware stats */
+ 		tstats->fw_total_sent = rsp_tstats->fw_total_sent;
+ 		tstats->fw_total_fwd = rsp_tstats->fw_total_fwd;
+ 		tstats->fw_err_pko = rsp_tstats->fw_err_pko;
+ 		tstats->fw_err_pki = rsp_tstats->fw_err_pki;
+ 		tstats->fw_err_link = rsp_tstats->fw_err_link;
+ 		tstats->fw_err_drop = rsp_tstats->fw_err_drop;
+ 		tstats->fw_tso = rsp_tstats->fw_tso;
+ 		tstats->fw_tso_fwd = rsp_tstats->fw_tso_fwd;
+ 		tstats->fw_err_tso = rsp_tstats->fw_err_tso;
+ 		tstats->fw_tx_vxlan = rsp_tstats->fw_tx_vxlan;
+ 
+ 		resp->status = 1;
+ 	} else {
+ 		resp->status = -1;
+ 	}
+ 	complete(&ctrl->complete);
+ }
+ 
+ int octnet_get_link_stats(struct net_device *netdev)
+ {
+ 	struct lio *lio = GET_LIO(netdev);
+ 	struct octeon_device *oct_dev = lio->oct_dev;
+ 	struct octeon_soft_command *sc;
+ 	struct oct_nic_stats_ctrl *ctrl;
+ 	struct oct_nic_stats_resp *resp;
+ 	int retval;
+ 
+ 	/* Alloc soft command */
+ 	sc = (struct octeon_soft_command *)
+ 		octeon_alloc_soft_command(oct_dev,
+ 					  0,
+ 					  sizeof(struct oct_nic_stats_resp),
+ 					  sizeof(struct octnic_ctrl_pkt));
+ 
+ 	if (!sc)
+ 		return -ENOMEM;
+ 
+ 	resp = (struct oct_nic_stats_resp *)sc->virtrptr;
+ 	memset(resp, 0, sizeof(struct oct_nic_stats_resp));
+ 
+ 	ctrl = (struct oct_nic_stats_ctrl *)sc->ctxptr;
+ 	memset(ctrl, 0, sizeof(struct oct_nic_stats_ctrl));
+ 	ctrl->netdev = netdev;
+ 	init_completion(&ctrl->complete);
+ 
+ 	sc->iq_no = lio->linfo.txpciq[0].s.q_no;
+ 
+ 	octeon_prepare_soft_command(oct_dev, sc, OPCODE_NIC,
+ 				    OPCODE_NIC_PORT_STATS, 0, 0, 0);
+ 
+ 	sc->callback = octnet_nic_stats_callback;
+ 	sc->callback_arg = sc;
+ 	sc->wait_time = 500;	/*in milli seconds*/
+ 
+ 	retval = octeon_send_soft_command(oct_dev, sc);
+ 	if (retval == IQ_SEND_FAILED) {
+ 		octeon_free_soft_command(oct_dev, sc);
+ 		return -EINVAL;
+ 	}
+ 
+ 	wait_for_completion_timeout(&ctrl->complete, msecs_to_jiffies(1000));
+ 
+ 	if (resp->status != 1) {
+ 		octeon_free_soft_command(oct_dev, sc);
+ 
+ 		return -EINVAL;
+ 	}
+ 
+ 	octeon_free_soft_command(oct_dev, sc);
+ 
+ 	return 0;
+ }
++>>>>>>> f058ca6b06d4 (liquidio: move a couple of functions to lio_core.c)
diff --cc drivers/net/ethernet/cavium/liquidio/octeon_network.h
index 7f5286059b2c,d090edd1a4a5..000000000000
--- a/drivers/net/ethernet/cavium/liquidio/octeon_network.h
+++ b/drivers/net/ethernet/cavium/liquidio/octeon_network.h
@@@ -178,6 -190,9 +178,12 @@@ irqreturn_t liquidio_msix_intr_handler(
  
  int octeon_setup_interrupt(struct octeon_device *oct, u32 num_ioqs);
  
++<<<<<<< HEAD
++=======
+ int octnet_get_link_stats(struct net_device *netdev);
+ 
+ int lio_wait_for_clean_oq(struct octeon_device *oct);
++>>>>>>> f058ca6b06d4 (liquidio: move a couple of functions to lio_core.c)
  /**
   * \brief Register ethtool operations
   * @param netdev    pointer to network device
* Unmerged path drivers/net/ethernet/cavium/liquidio/lio_core.c
diff --git a/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c b/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c
index 9926a12dd805..351549c83472 100644
--- a/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c
+++ b/drivers/net/ethernet/cavium/liquidio/lio_ethtool.c
@@ -32,7 +32,6 @@
 #include "cn23xx_vf_device.h"
 
 static int lio_reset_queues(struct net_device *netdev, uint32_t num_qs);
-static int octnet_get_link_stats(struct net_device *netdev);
 
 struct oct_intrmod_context {
 	int octeon_id;
@@ -1776,162 +1775,6 @@ static int octnet_set_intrmod_cfg(struct lio *lio,
 	return -EINTR;
 }
 
-static void
-octnet_nic_stats_callback(struct octeon_device *oct_dev,
-			  u32 status, void *ptr)
-{
-	struct octeon_soft_command *sc = (struct octeon_soft_command *)ptr;
-	struct oct_nic_stats_resp *resp =
-	    (struct oct_nic_stats_resp *)sc->virtrptr;
-	struct oct_nic_stats_ctrl *ctrl =
-	    (struct oct_nic_stats_ctrl *)sc->ctxptr;
-	struct nic_rx_stats *rsp_rstats = &resp->stats.fromwire;
-	struct nic_tx_stats *rsp_tstats = &resp->stats.fromhost;
-
-	struct nic_rx_stats *rstats = &oct_dev->link_stats.fromwire;
-	struct nic_tx_stats *tstats = &oct_dev->link_stats.fromhost;
-
-	if ((status != OCTEON_REQUEST_TIMEOUT) && !resp->status) {
-		octeon_swap_8B_data((u64 *)&resp->stats,
-				    (sizeof(struct oct_link_stats)) >> 3);
-
-		/* RX link-level stats */
-		rstats->total_rcvd = rsp_rstats->total_rcvd;
-		rstats->bytes_rcvd = rsp_rstats->bytes_rcvd;
-		rstats->total_bcst = rsp_rstats->total_bcst;
-		rstats->total_mcst = rsp_rstats->total_mcst;
-		rstats->runts      = rsp_rstats->runts;
-		rstats->ctl_rcvd   = rsp_rstats->ctl_rcvd;
-		/* Accounts for over/under-run of buffers */
-		rstats->fifo_err  = rsp_rstats->fifo_err;
-		rstats->dmac_drop = rsp_rstats->dmac_drop;
-		rstats->fcs_err   = rsp_rstats->fcs_err;
-		rstats->jabber_err = rsp_rstats->jabber_err;
-		rstats->l2_err    = rsp_rstats->l2_err;
-		rstats->frame_err = rsp_rstats->frame_err;
-		rstats->red_drops = rsp_rstats->red_drops;
-
-		/* RX firmware stats */
-		rstats->fw_total_rcvd = rsp_rstats->fw_total_rcvd;
-		rstats->fw_total_fwd = rsp_rstats->fw_total_fwd;
-		rstats->fw_err_pko = rsp_rstats->fw_err_pko;
-		rstats->fw_err_link = rsp_rstats->fw_err_link;
-		rstats->fw_err_drop = rsp_rstats->fw_err_drop;
-		rstats->fw_rx_vxlan = rsp_rstats->fw_rx_vxlan;
-		rstats->fw_rx_vxlan_err = rsp_rstats->fw_rx_vxlan_err;
-
-		/* Number of packets that are LROed      */
-		rstats->fw_lro_pkts = rsp_rstats->fw_lro_pkts;
-		/* Number of octets that are LROed       */
-		rstats->fw_lro_octs = rsp_rstats->fw_lro_octs;
-		/* Number of LRO packets formed          */
-		rstats->fw_total_lro = rsp_rstats->fw_total_lro;
-		/* Number of times lRO of packet aborted */
-		rstats->fw_lro_aborts = rsp_rstats->fw_lro_aborts;
-		rstats->fw_lro_aborts_port = rsp_rstats->fw_lro_aborts_port;
-		rstats->fw_lro_aborts_seq = rsp_rstats->fw_lro_aborts_seq;
-		rstats->fw_lro_aborts_tsval = rsp_rstats->fw_lro_aborts_tsval;
-		rstats->fw_lro_aborts_timer = rsp_rstats->fw_lro_aborts_timer;
-		/* intrmod: packet forward rate */
-		rstats->fwd_rate = rsp_rstats->fwd_rate;
-
-		/* TX link-level stats */
-		tstats->total_pkts_sent = rsp_tstats->total_pkts_sent;
-		tstats->total_bytes_sent = rsp_tstats->total_bytes_sent;
-		tstats->mcast_pkts_sent = rsp_tstats->mcast_pkts_sent;
-		tstats->bcast_pkts_sent = rsp_tstats->bcast_pkts_sent;
-		tstats->ctl_sent = rsp_tstats->ctl_sent;
-		/* Packets sent after one collision*/
-		tstats->one_collision_sent = rsp_tstats->one_collision_sent;
-		/* Packets sent after multiple collision*/
-		tstats->multi_collision_sent = rsp_tstats->multi_collision_sent;
-		/* Packets not sent due to max collisions */
-		tstats->max_collision_fail = rsp_tstats->max_collision_fail;
-		/* Packets not sent due to max deferrals */
-		tstats->max_deferral_fail = rsp_tstats->max_deferral_fail;
-		/* Accounts for over/under-run of buffers */
-		tstats->fifo_err = rsp_tstats->fifo_err;
-		tstats->runts = rsp_tstats->runts;
-		/* Total number of collisions detected */
-		tstats->total_collisions = rsp_tstats->total_collisions;
-
-		/* firmware stats */
-		tstats->fw_total_sent = rsp_tstats->fw_total_sent;
-		tstats->fw_total_fwd = rsp_tstats->fw_total_fwd;
-		tstats->fw_err_pko = rsp_tstats->fw_err_pko;
-		tstats->fw_err_pki = rsp_tstats->fw_err_pki;
-		tstats->fw_err_link = rsp_tstats->fw_err_link;
-		tstats->fw_err_drop = rsp_tstats->fw_err_drop;
-		tstats->fw_tso = rsp_tstats->fw_tso;
-		tstats->fw_tso_fwd = rsp_tstats->fw_tso_fwd;
-		tstats->fw_err_tso = rsp_tstats->fw_err_tso;
-		tstats->fw_tx_vxlan = rsp_tstats->fw_tx_vxlan;
-
-		resp->status = 1;
-	} else {
-		resp->status = -1;
-	}
-	complete(&ctrl->complete);
-}
-
-/*  Configure interrupt moderation parameters */
-static int octnet_get_link_stats(struct net_device *netdev)
-{
-	struct lio *lio = GET_LIO(netdev);
-	struct octeon_device *oct_dev = lio->oct_dev;
-
-	struct octeon_soft_command *sc;
-	struct oct_nic_stats_ctrl *ctrl;
-	struct oct_nic_stats_resp *resp;
-
-	int retval;
-
-	/* Alloc soft command */
-	sc = (struct octeon_soft_command *)
-		octeon_alloc_soft_command(oct_dev,
-					  0,
-					  sizeof(struct oct_nic_stats_resp),
-					  sizeof(struct octnic_ctrl_pkt));
-
-	if (!sc)
-		return -ENOMEM;
-
-	resp = (struct oct_nic_stats_resp *)sc->virtrptr;
-	memset(resp, 0, sizeof(struct oct_nic_stats_resp));
-
-	ctrl = (struct oct_nic_stats_ctrl *)sc->ctxptr;
-	memset(ctrl, 0, sizeof(struct oct_nic_stats_ctrl));
-	ctrl->netdev = netdev;
-	init_completion(&ctrl->complete);
-
-	sc->iq_no = lio->linfo.txpciq[0].s.q_no;
-
-	octeon_prepare_soft_command(oct_dev, sc, OPCODE_NIC,
-				    OPCODE_NIC_PORT_STATS, 0, 0, 0);
-
-	sc->callback = octnet_nic_stats_callback;
-	sc->callback_arg = sc;
-	sc->wait_time = 500;	/*in milli seconds*/
-
-	retval = octeon_send_soft_command(oct_dev, sc);
-	if (retval == IQ_SEND_FAILED) {
-		octeon_free_soft_command(oct_dev, sc);
-		return -EINVAL;
-	}
-
-	wait_for_completion_timeout(&ctrl->complete, msecs_to_jiffies(1000));
-
-	if (resp->status != 1) {
-		octeon_free_soft_command(oct_dev, sc);
-
-		return -EINVAL;
-	}
-
-	octeon_free_soft_command(oct_dev, sc);
-
-	return 0;
-}
-
 static int lio_get_intr_coalesce(struct net_device *netdev,
 				 struct ethtool_coalesce *intr_coal)
 {
* Unmerged path drivers/net/ethernet/cavium/liquidio/octeon_network.h
