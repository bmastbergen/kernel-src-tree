iio: trigger: helpers to determine own trigger

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iio] trigger: helpers to determine own trigger (Tony Camuso) [1559170]
Rebuild_FUZZ: 94.25%
commit-author Linus Walleij <linus.walleij@linaro.org>
commit 702a7b8e064a93df0b63e9d718b666a9851088fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/702a7b8e.failed

This adds a helper function to the IIO trigger framework:

iio_trigger_using_own(): for an IIO device, this tells
  whether the device is using itself as a trigger.
  This is true if the indio device:
  (A) supplies a trigger and
  (B) has assigned its own buffer poll function to use this
      trigger.

This helper function is good when constructing triggered,
buffered drivers that can either use its own hardware *OR*
an external trigger such as a HRTimer or even the trigger from
a totally different sensor.

Under such circumstances it is important to know for example
if the timestamp from the same trigger hardware should be used
when populating the buffer: if iio_trigger_using_own() is true,
we can use this timestamp, else we need to pick a unique
timestamp directly in the trigger handler.

For this to work of course IIO devices registering hardware
triggers must follow the convention to set the parent device
properly, as as well as setting the parent of the IIO device
itself.

When a new poll function is attached, we check if the parent
device of the IIO of the poll function is the same as the
parent device of the trigger and in that case we conclude that
the hardware is using itself as trigger.

	Cc: Giuseppe Barba <giuseppe.barba@st.com>
	Cc: Denis Ciocca <denis.ciocca@st.com>
	Cc: Crestez Dan Leonard <leonard.crestez@intel.com>
	Cc: Gregor Boirie <gregor.boirie@parrot.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit 702a7b8e064a93df0b63e9d718b666a9851088fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iio/industrialio-trigger.c
diff --cc drivers/iio/industrialio-trigger.c
index 27ac10a0a23f,e1e104845e38..000000000000
--- a/drivers/iio/industrialio-trigger.c
+++ b/drivers/iio/industrialio-trigger.c
@@@ -249,10 -267,27 +249,18 @@@ static int iio_trigger_attach_poll_func
  	if (trig->ops->set_trigger_state && notinuse) {
  		ret = trig->ops->set_trigger_state(trig, true);
  		if (ret < 0)
 -			goto out_free_irq;
 +			module_put(pf->indio_dev->info->driver_module);
  	}
  
+ 	/*
+ 	 * Check if we just registered to our own trigger: we determine that
+ 	 * this is the case if the IIO device and the trigger device share the
+ 	 * same parent device.
+ 	 */
+ 	if (pf->indio_dev->dev.parent == trig->dev.parent)
+ 		trig->attached_own_device = true;
+ 
  	return ret;
 -
 -out_free_irq:
 -	free_irq(pf->irq, pf);
 -out_put_irq:
 -	iio_trigger_put_irq(trig, pf->irq);
 -out_put_module:
 -	module_put(pf->indio_dev->info->driver_module);
 -	return ret;
  }
  
  static int iio_trigger_detach_poll_func(struct iio_trigger *trig,
@@@ -266,8 -301,10 +274,10 @@@
  	if (trig->ops->set_trigger_state && no_other_users) {
  		ret = trig->ops->set_trigger_state(trig, false);
  		if (ret)
 -			return ret;
 +			goto error_ret;
  	}
+ 	if (pf->indio_dev->dev.parent == trig->dev.parent)
+ 		trig->attached_own_device = false;
  	iio_trigger_put_irq(trig, pf->irq);
  	free_irq(pf->irq, pf);
  	module_put(pf->indio_dev->info->driver_module);
@@@ -516,6 -575,148 +526,151 @@@ void iio_trigger_free(struct iio_trigge
  }
  EXPORT_SYMBOL(iio_trigger_free);
  
++<<<<<<< HEAD
++=======
+ static void devm_iio_trigger_release(struct device *dev, void *res)
+ {
+ 	iio_trigger_free(*(struct iio_trigger **)res);
+ }
+ 
+ static int devm_iio_trigger_match(struct device *dev, void *res, void *data)
+ {
+ 	struct iio_trigger **r = res;
+ 
+ 	if (!r || !*r) {
+ 		WARN_ON(!r || !*r);
+ 		return 0;
+ 	}
+ 
+ 	return *r == data;
+ }
+ 
+ /**
+  * devm_iio_trigger_alloc - Resource-managed iio_trigger_alloc()
+  * @dev:		Device to allocate iio_trigger for
+  * @fmt:		trigger name format. If it includes format
+  *			specifiers, the additional arguments following
+  *			format are formatted and inserted in the resulting
+  *			string replacing their respective specifiers.
+  *
+  * Managed iio_trigger_alloc.  iio_trigger allocated with this function is
+  * automatically freed on driver detach.
+  *
+  * If an iio_trigger allocated with this function needs to be freed separately,
+  * devm_iio_trigger_free() must be used.
+  *
+  * RETURNS:
+  * Pointer to allocated iio_trigger on success, NULL on failure.
+  */
+ struct iio_trigger *devm_iio_trigger_alloc(struct device *dev,
+ 						const char *fmt, ...)
+ {
+ 	struct iio_trigger **ptr, *trig;
+ 	va_list vargs;
+ 
+ 	ptr = devres_alloc(devm_iio_trigger_release, sizeof(*ptr),
+ 			   GFP_KERNEL);
+ 	if (!ptr)
+ 		return NULL;
+ 
+ 	/* use raw alloc_dr for kmalloc caller tracing */
+ 	va_start(vargs, fmt);
+ 	trig = viio_trigger_alloc(fmt, vargs);
+ 	va_end(vargs);
+ 	if (trig) {
+ 		*ptr = trig;
+ 		devres_add(dev, ptr);
+ 	} else {
+ 		devres_free(ptr);
+ 	}
+ 
+ 	return trig;
+ }
+ EXPORT_SYMBOL_GPL(devm_iio_trigger_alloc);
+ 
+ /**
+  * devm_iio_trigger_free - Resource-managed iio_trigger_free()
+  * @dev:		Device this iio_dev belongs to
+  * @iio_trig:		the iio_trigger associated with the device
+  *
+  * Free iio_trigger allocated with devm_iio_trigger_alloc().
+  */
+ void devm_iio_trigger_free(struct device *dev, struct iio_trigger *iio_trig)
+ {
+ 	int rc;
+ 
+ 	rc = devres_release(dev, devm_iio_trigger_release,
+ 			    devm_iio_trigger_match, iio_trig);
+ 	WARN_ON(rc);
+ }
+ EXPORT_SYMBOL_GPL(devm_iio_trigger_free);
+ 
+ static void devm_iio_trigger_unreg(struct device *dev, void *res)
+ {
+ 	iio_trigger_unregister(*(struct iio_trigger **)res);
+ }
+ 
+ /**
+  * devm_iio_trigger_register - Resource-managed iio_trigger_register()
+  * @dev:	device this trigger was allocated for
+  * @trig_info:	trigger to register
+  *
+  * Managed iio_trigger_register().  The IIO trigger registered with this
+  * function is automatically unregistered on driver detach. This function
+  * calls iio_trigger_register() internally. Refer to that function for more
+  * information.
+  *
+  * If an iio_trigger registered with this function needs to be unregistered
+  * separately, devm_iio_trigger_unregister() must be used.
+  *
+  * RETURNS:
+  * 0 on success, negative error number on failure.
+  */
+ int devm_iio_trigger_register(struct device *dev, struct iio_trigger *trig_info)
+ {
+ 	struct iio_trigger **ptr;
+ 	int ret;
+ 
+ 	ptr = devres_alloc(devm_iio_trigger_unreg, sizeof(*ptr), GFP_KERNEL);
+ 	if (!ptr)
+ 		return -ENOMEM;
+ 
+ 	*ptr = trig_info;
+ 	ret = iio_trigger_register(trig_info);
+ 	if (!ret)
+ 		devres_add(dev, ptr);
+ 	else
+ 		devres_free(ptr);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(devm_iio_trigger_register);
+ 
+ /**
+  * devm_iio_trigger_unregister - Resource-managed iio_trigger_unregister()
+  * @dev:	device this iio_trigger belongs to
+  * @trig_info:	the trigger associated with the device
+  *
+  * Unregister trigger registered with devm_iio_trigger_register().
+  */
+ void devm_iio_trigger_unregister(struct device *dev,
+ 				 struct iio_trigger *trig_info)
+ {
+ 	int rc;
+ 
+ 	rc = devres_release(dev, devm_iio_trigger_unreg, devm_iio_trigger_match,
+ 			    trig_info);
+ 	WARN_ON(rc);
+ }
+ EXPORT_SYMBOL_GPL(devm_iio_trigger_unregister);
+ 
+ bool iio_trigger_using_own(struct iio_dev *indio_dev)
+ {
+ 	return indio_dev->trig->attached_own_device;
+ }
+ EXPORT_SYMBOL(iio_trigger_using_own);
+ 
++>>>>>>> 702a7b8e064a (iio: trigger: helpers to determine own trigger)
  void iio_device_register_trigger_consumer(struct iio_dev *indio_dev)
  {
  	indio_dev->groups[indio_dev->groupcounter++] =
* Unmerged path drivers/iio/industrialio-trigger.c
diff --git a/include/linux/iio/trigger.h b/include/linux/iio/trigger.h
index 1fa26d849585..f1c408890694 100644
--- a/include/linux/iio/trigger.h
+++ b/include/linux/iio/trigger.h
@@ -56,6 +56,9 @@ struct iio_trigger_ops {
  * @subirqs:		[INTERN] information about the 'child' irqs.
  * @pool:		[INTERN] bitmap of irqs currently in use.
  * @pool_lock:		[INTERN] protection of the irq pool.
+ * @attached_own_device:[INTERN] if we are using our own device as trigger,
+ *			i.e. if we registered a poll function to the same
+ *			device as the one providing the trigger.
  **/
 struct iio_trigger {
 	const struct iio_trigger_ops	*ops;
@@ -73,6 +76,7 @@ struct iio_trigger {
 	struct iio_subirq subirqs[CONFIG_IIO_CONSUMERS_PER_TRIGGER];
 	unsigned long pool[BITS_TO_LONGS(CONFIG_IIO_CONSUMERS_PER_TRIGGER)];
 	struct mutex			pool_lock;
+	bool				attached_own_device;
 };
 
 
@@ -146,6 +150,13 @@ irqreturn_t iio_trigger_generic_data_rdy_poll(int irq, void *private);
 __printf(1, 2) struct iio_trigger *iio_trigger_alloc(const char *fmt, ...);
 void iio_trigger_free(struct iio_trigger *trig);
 
+/**
+ * iio_trigger_using_own() - tells us if we use our own HW trigger ourselves
+ * @indio_dev:  device to check
+ */
+bool iio_trigger_using_own(struct iio_dev *indio_dev);
+
+
 #else
 struct iio_trigger;
 struct iio_trigger_ops;
