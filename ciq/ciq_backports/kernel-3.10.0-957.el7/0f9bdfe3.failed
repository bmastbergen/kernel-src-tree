powerpc/pseries: Fix clearing of security feature flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [powerpc] pseries: Fix clearing of security feature flags (Mauricio Oliveira) [1561787]
Rebuild_FUZZ: 92.16%
commit-author Mauricio Faria de Oliveira <mauricfo@linux.vnet.ibm.com>
commit 0f9bdfe3c77091e8704d2e510eb7c2c2c6cde524
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0f9bdfe3.failed

The H_CPU_BEHAV_* flags should be checked for in the 'behaviour' field
of 'struct h_cpu_char_result' -- 'character' is for H_CPU_CHAR_*
flags.

Found by playing around with QEMU's implementation of the hypercall:

  H_CPU_CHAR=0xf000000000000000
  H_CPU_BEHAV=0x0000000000000000

  This clears H_CPU_BEHAV_FAVOUR_SECURITY and H_CPU_BEHAV_L1D_FLUSH_PR
  so pseries_setup_rfi_flush() disables 'rfi_flush'; and it also
  clears H_CPU_CHAR_L1D_THREAD_PRIV flag. So there is no RFI flush
  mitigation at all for cpu_show_meltdown() to report; but currently
  it does:

  Original kernel:

    # cat /sys/devices/system/cpu/vulnerabilities/meltdown
    Mitigation: RFI Flush

  Patched kernel:

    # cat /sys/devices/system/cpu/vulnerabilities/meltdown
    Not affected

  H_CPU_CHAR=0x0000000000000000
  H_CPU_BEHAV=0xf000000000000000

  This sets H_CPU_BEHAV_BNDS_CHK_SPEC_BAR so cpu_show_spectre_v1() should
  report vulnerable; but currently it doesn't:

  Original kernel:

    # cat /sys/devices/system/cpu/vulnerabilities/spectre_v1
    Not affected

  Patched kernel:

    # cat /sys/devices/system/cpu/vulnerabilities/spectre_v1
    Vulnerable

Brown-paper-bag-by: Michael Ellerman <mpe@ellerman.id.au>
Fixes: f636c14790ea ("powerpc/pseries: Set or clear security feature flags")
	Signed-off-by: Mauricio Faria de Oliveira <mauricfo@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 0f9bdfe3c77091e8704d2e510eb7c2c2c6cde524)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/pseries/setup.c
diff --cc arch/powerpc/platforms/pseries/setup.c
index 16f5e74be2ee,b11564f2a4c7..000000000000
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@@ -501,58 -457,229 +501,96 @@@ static void __init find_and_init_phbs(v
  	 * PCI_PROBE_ONLY and PCI_REASSIGN_ALL_BUS can be set via properties
  	 * in chosen.
  	 */
 -	of_pci_check_probe_only();
 +	if (of_chosen) {
 +		const int *prop;
 +
 +		prop = of_get_property(of_chosen,
 +				"linux,pci-probe-only", NULL);
 +		if (prop) {
 +			if (*prop)
 +				pci_add_flags(PCI_PROBE_ONLY);
 +			else
 +				pci_clear_flags(PCI_PROBE_ONLY);
 +		}
 +
 +#ifdef CONFIG_PPC32 /* Will be made generic soon */
 +		prop = of_get_property(of_chosen,
 +				"linux,pci-assign-all-buses", NULL);
 +		if (prop && *prop)
 +			pci_add_flags(PCI_REASSIGN_ALL_BUS);
 +#endif /* CONFIG_PPC32 */
 +	}
  }
  
 -static void init_cpu_char_feature_flags(struct h_cpu_char_result *result)
 +static void pSeries_setup_rfi_flush(void)
  {
++<<<<<<< HEAD
 +	unsigned long character, behaviour, rc;
++=======
+ 	if (result->character & H_CPU_CHAR_SPEC_BAR_ORI31)
+ 		security_ftr_set(SEC_FTR_SPEC_BAR_ORI31);
+ 
+ 	if (result->character & H_CPU_CHAR_BCCTRL_SERIALISED)
+ 		security_ftr_set(SEC_FTR_BCCTRL_SERIALISED);
+ 
+ 	if (result->character & H_CPU_CHAR_L1D_FLUSH_ORI30)
+ 		security_ftr_set(SEC_FTR_L1D_FLUSH_ORI30);
+ 
+ 	if (result->character & H_CPU_CHAR_L1D_FLUSH_TRIG2)
+ 		security_ftr_set(SEC_FTR_L1D_FLUSH_TRIG2);
+ 
+ 	if (result->character & H_CPU_CHAR_L1D_THREAD_PRIV)
+ 		security_ftr_set(SEC_FTR_L1D_THREAD_PRIV);
+ 
+ 	if (result->character & H_CPU_CHAR_COUNT_CACHE_DISABLED)
+ 		security_ftr_set(SEC_FTR_COUNT_CACHE_DISABLED);
+ 
+ 	/*
+ 	 * The features below are enabled by default, so we instead look to see
+ 	 * if firmware has *disabled* them, and clear them if so.
+ 	 */
+ 	if (!(result->behaviour & H_CPU_BEHAV_FAVOUR_SECURITY))
+ 		security_ftr_clear(SEC_FTR_FAVOUR_SECURITY);
+ 
+ 	if (!(result->behaviour & H_CPU_BEHAV_L1D_FLUSH_PR))
+ 		security_ftr_clear(SEC_FTR_L1D_FLUSH_PR);
+ 
+ 	if (!(result->behaviour & H_CPU_BEHAV_BNDS_CHK_SPEC_BAR))
+ 		security_ftr_clear(SEC_FTR_BNDS_CHK_SPEC_BAR);
+ }
+ 
+ void pseries_setup_rfi_flush(void)
+ {
+ 	struct h_cpu_char_result result;
++>>>>>>> 0f9bdfe3c770 (powerpc/pseries: Fix clearing of security feature flags)
  	enum l1d_flush_type types;
  	bool enable;
 -	long rc;
 -
 -	rc = plpar_get_cpu_characteristics(&result);
 -	if (rc == H_SUCCESS)
 -		init_cpu_char_feature_flags(&result);
 -
 -	/*
 -	 * We're the guest so this doesn't apply to us, clear it to simplify
 -	 * handling of it elsewhere.
 -	 */
 -	security_ftr_clear(SEC_FTR_L1D_FLUSH_HV);
 -
 -	types = L1D_FLUSH_FALLBACK;
 -
 -	if (security_ftr_enabled(SEC_FTR_L1D_FLUSH_TRIG2))
 -		types |= L1D_FLUSH_MTTRIG;
 -
 -	if (security_ftr_enabled(SEC_FTR_L1D_FLUSH_ORI30))
 -		types |= L1D_FLUSH_ORI;
 -
 -	enable = security_ftr_enabled(SEC_FTR_FAVOUR_SECURITY) && \
 -		 security_ftr_enabled(SEC_FTR_L1D_FLUSH_PR);
 -
 -	setup_rfi_flush(types, enable);
 -}
 -
 -#ifdef CONFIG_PCI_IOV
 -enum rtas_iov_fw_value_map {
 -	NUM_RES_PROPERTY  = 0, /* Number of Resources */
 -	LOW_INT           = 1, /* Lowest 32 bits of Address */
 -	START_OF_ENTRIES  = 2, /* Always start of entry */
 -	APERTURE_PROPERTY = 2, /* Start of entry+ to  Aperture Size */
 -	WDW_SIZE_PROPERTY = 4, /* Start of entry+ to Window Size */
 -	NEXT_ENTRY        = 7  /* Go to next entry on array */
 -};
 -
 -enum get_iov_fw_value_index {
 -	BAR_ADDRS     = 1,    /*  Get Bar Address */
 -	APERTURE_SIZE = 2,    /*  Get Aperture Size */
 -	WDW_SIZE      = 3     /*  Get Window Size */
 -};
 -
 -resource_size_t pseries_get_iov_fw_value(struct pci_dev *dev, int resno,
 -					 enum get_iov_fw_value_index value)
 -{
 -	const int *indexes;
 -	struct device_node *dn = pci_device_to_OF_node(dev);
 -	int i, num_res, ret = 0;
  
 -	indexes = of_get_property(dn, "ibm,open-sriov-vf-bar-info", NULL);
 -	if (!indexes)
 -		return  0;
 +	/* Enable by default */
 +	enable = true;
  
 -	/*
 -	 * First element in the array is the number of Bars
 -	 * returned.  Search through the list to find the matching
 -	 * bar
 -	 */
 -	num_res = of_read_number(&indexes[NUM_RES_PROPERTY], 1);
 -	if (resno >= num_res)
 -		return 0; /* or an errror */
 -
 -	i = START_OF_ENTRIES + NEXT_ENTRY * resno;
 -	switch (value) {
 -	case BAR_ADDRS:
 -		ret = of_read_number(&indexes[i], 2);
 -		break;
 -	case APERTURE_SIZE:
 -		ret = of_read_number(&indexes[i + APERTURE_PROPERTY], 2);
 -		break;
 -	case WDW_SIZE:
 -		ret = of_read_number(&indexes[i + WDW_SIZE_PROPERTY], 2);
 -		break;
 -	}
 +	rc = plpar_get_cpu_characteristics(&character, &behaviour);
 +	if (rc == H_SUCCESS) {
 +		types = L1D_FLUSH_NONE;
  
 -	return ret;
 -}
 -
 -void of_pci_set_vf_bar_size(struct pci_dev *dev, const int *indexes)
 -{
 -	struct resource *res;
 -	resource_size_t base, size;
 -	int i, r, num_res;
 -
 -	num_res = of_read_number(&indexes[NUM_RES_PROPERTY], 1);
 -	num_res = min_t(int, num_res, PCI_SRIOV_NUM_BARS);
 -	for (i = START_OF_ENTRIES, r = 0; r < num_res && r < PCI_SRIOV_NUM_BARS;
 -	     i += NEXT_ENTRY, r++) {
 -		res = &dev->resource[r + PCI_IOV_RESOURCES];
 -		base = of_read_number(&indexes[i], 2);
 -		size = of_read_number(&indexes[i + APERTURE_PROPERTY], 2);
 -		res->flags = pci_parse_of_flags(of_read_number
 -						(&indexes[i + LOW_INT], 1), 0);
 -		res->flags |= (IORESOURCE_MEM_64 | IORESOURCE_PCI_FIXED);
 -		res->name = pci_name(dev);
 -		res->start = base;
 -		res->end = base + size - 1;
 -	}
 -}
 +		if (character & H_GET_CPU_CHAR_CHAR_MTTRIG2_L1_FLUSH)
 +			types |= L1D_FLUSH_MTTRIG;
 +		if (character & H_GET_CPU_CHAR_CHAR_ORI30_L1_FLUSH)
 +			types |= L1D_FLUSH_ORI;
  
 -void of_pci_parse_iov_addrs(struct pci_dev *dev, const int *indexes)
 -{
 -	struct resource *res, *root, *conflict;
 -	resource_size_t base, size;
 -	int i, r, num_res;
 +		/* Use fallback if nothing set in hcall */
 +		if (types == L1D_FLUSH_NONE)
 +			types = L1D_FLUSH_FALLBACK;
  
 -	/*
 -	 * First element in the array is the number of Bars
 -	 * returned.  Search through the list to find the matching
 -	 * bars assign them from firmware into resources structure.
 -	 */
 -	num_res = of_read_number(&indexes[NUM_RES_PROPERTY], 1);
 -	for (i = START_OF_ENTRIES, r = 0; r < num_res && r < PCI_SRIOV_NUM_BARS;
 -	     i += NEXT_ENTRY, r++) {
 -		res = &dev->resource[r + PCI_IOV_RESOURCES];
 -		base = of_read_number(&indexes[i], 2);
 -		size = of_read_number(&indexes[i + WDW_SIZE_PROPERTY], 2);
 -		res->name = pci_name(dev);
 -		res->start = base;
 -		res->end = base + size - 1;
 -		root = &iomem_resource;
 -		dev_dbg(&dev->dev,
 -			"pSeries IOV BAR %d: trying firmware assignment %pR\n",
 -			 r + PCI_IOV_RESOURCES, res);
 -		conflict = request_resource_conflict(root, res);
 -		if (conflict) {
 -			dev_info(&dev->dev,
 -				 "BAR %d: %pR conflicts with %s %pR\n",
 -				 r + PCI_IOV_RESOURCES, res,
 -				 conflict->name, conflict);
 -			res->flags |= IORESOURCE_UNSET;
 -		}
 +		if (!(behaviour & H_GET_CPU_CHAR_BEHAV_L1_FLUSH_LOW_PRIV))
 +			enable = false;
 +	} else {
 +		/* Default to fallback if case hcall is not available */
 +		types = L1D_FLUSH_FALLBACK;
  	}
 -}
 -
 -static void pseries_pci_fixup_resources(struct pci_dev *pdev)
 -{
 -	const int *indexes;
 -	struct device_node *dn = pci_device_to_OF_node(pdev);
  
 -	/*Firmware must support open sriov otherwise dont configure*/
 -	indexes = of_get_property(dn, "ibm,open-sriov-vf-bar-info", NULL);
 -	if (!indexes)
 -		return;
 -	/* Assign the addresses from device tree*/
 -	of_pci_set_vf_bar_size(pdev, indexes);
 -}
 -
 -static void pseries_pci_fixup_iov_resources(struct pci_dev *pdev)
 -{
 -	const int *indexes;
 -	struct device_node *dn = pci_device_to_OF_node(pdev);
 -
 -	if (!pdev->is_physfn || pdev->is_added)
 -		return;
 -	/*Firmware must support open sriov otherwise dont configure*/
 -	indexes = of_get_property(dn, "ibm,open-sriov-vf-bar-info", NULL);
 -	if (!indexes)
 -		return;
 -	/* Assign the addresses from device tree*/
 -	of_pci_parse_iov_addrs(pdev, indexes);
 -}
 -
 -static resource_size_t pseries_pci_iov_resource_alignment(struct pci_dev *pdev,
 -							  int resno)
 -{
 -	const __be32 *reg;
 -	struct device_node *dn = pci_device_to_OF_node(pdev);
 -
 -	/*Firmware must support open sriov otherwise report regular alignment*/
 -	reg = of_get_property(dn, "ibm,is-open-sriov-pf", NULL);
 -	if (!reg)
 -		return pci_iov_resource_size(pdev, resno);
 -
 -	if (!pdev->is_physfn)
 -		return 0;
 -	return pseries_get_iov_fw_value(pdev,
 -					resno - PCI_IOV_RESOURCES,
 -					APERTURE_SIZE);
 +	setup_rfi_flush(types, enable);
  }
 -#endif
  
  static void __init pSeries_setup_arch(void)
  {
* Unmerged path arch/powerpc/platforms/pseries/setup.c
