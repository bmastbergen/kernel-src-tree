net: tcp_memcontrol: remove bogus hierarchy pressure propagation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] tcp_memcontrol: remove bogus hierarchy pressure propagation (Davide Caratti) [1554191]
Rebuild_FUZZ: 95.93%
commit-author Johannes Weiner <hannes@cmpxchg.org>
commit 931f3f4beb031cd483c1c8ab159ef1f8bdbe8888
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/931f3f4b.failed

When a cgroup currently breaches its socket memory limit, it enters
memory pressure mode for itself and its *ancestors*.  This throttles
transmission in unrelated sibling and cousin subtrees that have nothing
to do with the breached limit.

On the contrary, breaching a limit should make that group and its
*children* enter memory pressure mode.  But this happens already, albeit
lazily: if an ancestor limit is breached, siblings will enter memory
pressure on their own once the next packet arrives for them.

So no additional hierarchy code is needed.  Remove the bogus stuff.

	Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
	Acked-by: David S. Miller <davem@davemloft.net>
	Reviewed-by: Vladimir Davydov <vdavydov@virtuozzo.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 931f3f4beb031cd483c1c8ab159ef1f8bdbe8888)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/sock.h
diff --cc include/net/sock.h
index 91144cd664b8,d3b035c7362b..000000000000
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@@ -1225,15 -1155,8 +1225,20 @@@ static inline void sk_leave_memory_pres
  	if (*memory_pressure)
  		*memory_pressure = 0;
  
++<<<<<<< HEAD
 +	if (mem_cgroup_sockets_enabled && sk->sk_cgrp) {
 +		struct cg_proto *cg_proto = sk->sk_cgrp;
 +		struct proto *prot = sk->sk_prot;
 +
 +		for (; cg_proto; cg_proto = parent_cg_proto(prot, cg_proto))
 +			if (*cg_proto->memory_pressure)
 +				*cg_proto->memory_pressure = 0;
 +	}
 +
++=======
+ 	if (mem_cgroup_sockets_enabled && sk->sk_cgrp)
+ 		sk->sk_cgrp->memory_pressure = 0;
++>>>>>>> 931f3f4beb03 (net: tcp_memcontrol: remove bogus hierarchy pressure propagation)
  }
  
  static inline void sk_enter_memory_pressure(struct sock *sk)
@@@ -1241,13 -1164,8 +1246,18 @@@
  	if (!sk->sk_prot->enter_memory_pressure)
  		return;
  
++<<<<<<< HEAD
 +	if (mem_cgroup_sockets_enabled && sk->sk_cgrp) {
 +		struct cg_proto *cg_proto = sk->sk_cgrp;
 +		struct proto *prot = sk->sk_prot;
 +
 +		for (; cg_proto; cg_proto = parent_cg_proto(prot, cg_proto))
 +			cg_proto->enter_memory_pressure(sk);
 +	}
++=======
+ 	if (mem_cgroup_sockets_enabled && sk->sk_cgrp)
+ 		sk->sk_cgrp->memory_pressure = 1;
++>>>>>>> 931f3f4beb03 (net: tcp_memcontrol: remove bogus hierarchy pressure propagation)
  
  	sk->sk_prot->enter_memory_pressure(sk);
  }
* Unmerged path include/net/sock.h
