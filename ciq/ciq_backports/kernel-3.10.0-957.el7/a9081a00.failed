usb: phy: Add USB charger support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [usb] phy: Add USB charger support (Torez Smith) [1540721]
Rebuild_FUZZ: 91.80%
commit-author Baolin Wang <baolin.wang@linaro.org>
commit a9081a008f84819ab2f3da596bf89afa16beea94
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/a9081a00.failed

This patch introduces the usb charger support based on usb phy that
makes an enhancement to a power driver. The basic conception of the
usb charger is that, when one usb charger is added or removed by
reporting from the extcon device state change, the usb charger will
report to power user to set the current limitation.

Power user can register a notifiee on the usb phy by issuing
usb_register_notifier() to get notified by charger status changes
or charger current changes.

we can notify what current to be drawn to power user according to
different charger type, and now we have 2 methods to get charger type.
One is get charger type from extcon subsystem, which also means the
charger state changes. Another is we can get the charger type from
USB controller detecting or PMIC detecting, and the charger state
changes should be told by issuing usb_phy_set_charger_state().

	Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
	Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
(cherry picked from commit a9081a008f84819ab2f3da596bf89afa16beea94)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/phy/phy.c
#	include/linux/usb/phy.h
diff --cc drivers/usb/phy/phy.c
index a9984c700d2c,2dc48bb2553c..000000000000
--- a/drivers/usb/phy/phy.c
+++ b/drivers/usb/phy/phy.c
@@@ -66,9 -86,224 +78,224 @@@ static struct usb_phy *__of_usb_find_ph
  		return phy;
  	}
  
 -	return ERR_PTR(-EPROBE_DEFER);
 +	return ERR_PTR(-ENODEV);
  }
  
+ static void usb_phy_set_default_current(struct usb_phy *usb_phy)
+ {
+ 	usb_phy->chg_cur.sdp_min = DEFAULT_SDP_CUR_MIN;
+ 	usb_phy->chg_cur.sdp_max = DEFAULT_SDP_CUR_MAX;
+ 	usb_phy->chg_cur.dcp_min = DEFAULT_DCP_CUR_MIN;
+ 	usb_phy->chg_cur.dcp_max = DEFAULT_DCP_CUR_MAX;
+ 	usb_phy->chg_cur.cdp_min = DEFAULT_CDP_CUR_MIN;
+ 	usb_phy->chg_cur.cdp_max = DEFAULT_CDP_CUR_MAX;
+ 	usb_phy->chg_cur.aca_min = DEFAULT_ACA_CUR_MIN;
+ 	usb_phy->chg_cur.aca_max = DEFAULT_ACA_CUR_MAX;
+ }
+ 
+ /**
+  * usb_phy_notify_charger_work - notify the USB charger state
+  * @work - the charger work to notify the USB charger state
+  *
+  * This work can be issued when USB charger state has been changed or
+  * USB charger current has been changed, then we can notify the current
+  * what can be drawn to power user and the charger state to userspace.
+  *
+  * If we get the charger type from extcon subsystem, we can notify the
+  * charger state to power user automatically by usb_phy_get_charger_type()
+  * issuing from extcon subsystem.
+  *
+  * If we get the charger type from ->charger_detect() instead of extcon
+  * subsystem, the usb phy driver should issue usb_phy_set_charger_state()
+  * to set charger state when the charger state has been changed.
+  */
+ static void usb_phy_notify_charger_work(struct work_struct *work)
+ {
+ 	struct usb_phy *usb_phy = container_of(work, struct usb_phy, chg_work);
+ 	char uchger_state[50] = { 0 };
+ 	char *envp[] = { uchger_state, NULL };
+ 	unsigned int min, max;
+ 
+ 	switch (usb_phy->chg_state) {
+ 	case USB_CHARGER_PRESENT:
+ 		usb_phy_get_charger_current(usb_phy, &min, &max);
+ 
+ 		atomic_notifier_call_chain(&usb_phy->notifier, max, usb_phy);
+ 		snprintf(uchger_state, ARRAY_SIZE(uchger_state),
+ 			 "USB_CHARGER_STATE=%s", "USB_CHARGER_PRESENT");
+ 		break;
+ 	case USB_CHARGER_ABSENT:
+ 		usb_phy_set_default_current(usb_phy);
+ 
+ 		atomic_notifier_call_chain(&usb_phy->notifier, 0, usb_phy);
+ 		snprintf(uchger_state, ARRAY_SIZE(uchger_state),
+ 			 "USB_CHARGER_STATE=%s", "USB_CHARGER_ABSENT");
+ 		break;
+ 	default:
+ 		dev_warn(usb_phy->dev, "Unknown USB charger state: %d\n",
+ 			 usb_phy->chg_state);
+ 		return;
+ 	}
+ 
+ 	kobject_uevent_env(&usb_phy->dev->kobj, KOBJ_CHANGE, envp);
+ }
+ 
+ static void __usb_phy_get_charger_type(struct usb_phy *usb_phy)
+ {
+ 	if (extcon_get_state(usb_phy->edev, EXTCON_CHG_USB_SDP) > 0) {
+ 		usb_phy->chg_type = SDP_TYPE;
+ 		usb_phy->chg_state = USB_CHARGER_PRESENT;
+ 	} else if (extcon_get_state(usb_phy->edev, EXTCON_CHG_USB_CDP) > 0) {
+ 		usb_phy->chg_type = CDP_TYPE;
+ 		usb_phy->chg_state = USB_CHARGER_PRESENT;
+ 	} else if (extcon_get_state(usb_phy->edev, EXTCON_CHG_USB_DCP) > 0) {
+ 		usb_phy->chg_type = DCP_TYPE;
+ 		usb_phy->chg_state = USB_CHARGER_PRESENT;
+ 	} else if (extcon_get_state(usb_phy->edev, EXTCON_CHG_USB_ACA) > 0) {
+ 		usb_phy->chg_type = ACA_TYPE;
+ 		usb_phy->chg_state = USB_CHARGER_PRESENT;
+ 	} else {
+ 		usb_phy->chg_type = UNKNOWN_TYPE;
+ 		usb_phy->chg_state = USB_CHARGER_ABSENT;
+ 	}
+ 
+ 	schedule_work(&usb_phy->chg_work);
+ }
+ 
+ /**
+  * usb_phy_get_charger_type - get charger type from extcon subsystem
+  * @nb -the notifier block to determine charger type
+  * @state - the cable state
+  * @data - private data
+  *
+  * Determin the charger type from extcon subsystem which also means the
+  * charger state has been chaned, then we should notify this event.
+  */
+ static int usb_phy_get_charger_type(struct notifier_block *nb,
+ 				    unsigned long state, void *data)
+ {
+ 	struct usb_phy *usb_phy = container_of(nb, struct usb_phy, type_nb);
+ 
+ 	__usb_phy_get_charger_type(usb_phy);
+ 	return NOTIFY_OK;
+ }
+ 
+ /**
+  * usb_phy_set_charger_current - set the USB charger current
+  * @usb_phy - the USB phy to be used
+  * @mA - the current need to be set
+  *
+  * Usually we only change the charger default current when USB finished the
+  * enumeration as one SDP charger. As one SDP charger, usb_phy_set_power()
+  * will issue this function to change charger current when after setting USB
+  * configuration, or suspend/resume USB. For other type charger, we should
+  * use the default charger current and we do not suggest to issue this function
+  * to change the charger current.
+  *
+  * When USB charger current has been changed, we need to notify the power users.
+  */
+ void usb_phy_set_charger_current(struct usb_phy *usb_phy, unsigned int mA)
+ {
+ 	switch (usb_phy->chg_type) {
+ 	case SDP_TYPE:
+ 		if (usb_phy->chg_cur.sdp_max == mA)
+ 			return;
+ 
+ 		usb_phy->chg_cur.sdp_max = (mA > DEFAULT_SDP_CUR_MAX_SS) ?
+ 			DEFAULT_SDP_CUR_MAX_SS : mA;
+ 		break;
+ 	case DCP_TYPE:
+ 		if (usb_phy->chg_cur.dcp_max == mA)
+ 			return;
+ 
+ 		usb_phy->chg_cur.dcp_max = (mA > DEFAULT_DCP_CUR_MAX) ?
+ 			DEFAULT_DCP_CUR_MAX : mA;
+ 		break;
+ 	case CDP_TYPE:
+ 		if (usb_phy->chg_cur.cdp_max == mA)
+ 			return;
+ 
+ 		usb_phy->chg_cur.cdp_max = (mA > DEFAULT_CDP_CUR_MAX) ?
+ 			DEFAULT_CDP_CUR_MAX : mA;
+ 		break;
+ 	case ACA_TYPE:
+ 		if (usb_phy->chg_cur.aca_max == mA)
+ 			return;
+ 
+ 		usb_phy->chg_cur.aca_max = (mA > DEFAULT_ACA_CUR_MAX) ?
+ 			DEFAULT_ACA_CUR_MAX : mA;
+ 		break;
+ 	default:
+ 		return;
+ 	}
+ 
+ 	schedule_work(&usb_phy->chg_work);
+ }
+ EXPORT_SYMBOL_GPL(usb_phy_set_charger_current);
+ 
+ /**
+  * usb_phy_get_charger_current - get the USB charger current
+  * @usb_phy - the USB phy to be used
+  * @min - the minimum current
+  * @max - the maximum current
+  *
+  * Usually we will notify the maximum current to power user, but for some
+  * special case, power user also need the minimum current value. Then the
+  * power user can issue this function to get the suitable current.
+  */
+ void usb_phy_get_charger_current(struct usb_phy *usb_phy,
+ 				 unsigned int *min, unsigned int *max)
+ {
+ 	switch (usb_phy->chg_type) {
+ 	case SDP_TYPE:
+ 		*min = usb_phy->chg_cur.sdp_min;
+ 		*max = usb_phy->chg_cur.sdp_max;
+ 		break;
+ 	case DCP_TYPE:
+ 		*min = usb_phy->chg_cur.dcp_min;
+ 		*max = usb_phy->chg_cur.dcp_max;
+ 		break;
+ 	case CDP_TYPE:
+ 		*min = usb_phy->chg_cur.cdp_min;
+ 		*max = usb_phy->chg_cur.cdp_max;
+ 		break;
+ 	case ACA_TYPE:
+ 		*min = usb_phy->chg_cur.aca_min;
+ 		*max = usb_phy->chg_cur.aca_max;
+ 		break;
+ 	default:
+ 		*min = 0;
+ 		*max = 0;
+ 		break;
+ 	}
+ }
+ EXPORT_SYMBOL_GPL(usb_phy_get_charger_current);
+ 
+ /**
+  * usb_phy_set_charger_state - set the USB charger state
+  * @usb_phy - the USB phy to be used
+  * @state - the new state need to be set for charger
+  *
+  * The usb phy driver can issue this function when the usb phy driver
+  * detected the charger state has been changed, in this case the charger
+  * type should be get from ->charger_detect().
+  */
+ void usb_phy_set_charger_state(struct usb_phy *usb_phy,
+ 			       enum usb_charger_state state)
+ {
+ 	if (usb_phy->chg_state == state || !usb_phy->charger_detect)
+ 		return;
+ 
+ 	usb_phy->chg_state = state;
+ 	if (usb_phy->chg_state == USB_CHARGER_PRESENT)
+ 		usb_phy->chg_type = usb_phy->charger_detect(usb_phy);
+ 	else
+ 		usb_phy->chg_type = UNKNOWN_TYPE;
+ 
+ 	schedule_work(&usb_phy->chg_work);
+ }
+ EXPORT_SYMBOL_GPL(usb_phy_set_charger_state);
+ 
  static void devm_usb_phy_release(struct device *dev, void *res)
  {
  	struct usb_phy *phy = *(struct usb_phy **)res;
@@@ -76,9 -311,113 +303,108 @@@
  	usb_put_phy(phy);
  }
  
 -static void devm_usb_phy_release2(struct device *dev, void *_res)
 -{
 -	struct phy_devm *res = _res;
 -
 -	if (res->nb)
 -		usb_unregister_notifier(res->phy, res->nb);
 -	usb_put_phy(res->phy);
 -}
 -
  static int devm_usb_phy_match(struct device *dev, void *res, void *match_data)
  {
++<<<<<<< HEAD
 +	return res == match_data;
++=======
+ 	struct usb_phy **phy = res;
+ 
+ 	return *phy == match_data;
+ }
+ 
+ static int usb_add_extcon(struct usb_phy *x)
+ {
+ 	int ret;
+ 
+ 	if (of_property_read_bool(x->dev->of_node, "extcon")) {
+ 		x->edev = extcon_get_edev_by_phandle(x->dev, 0);
+ 		if (IS_ERR(x->edev))
+ 			return PTR_ERR(x->edev);
+ 
+ 		x->id_edev = extcon_get_edev_by_phandle(x->dev, 1);
+ 		if (IS_ERR(x->id_edev)) {
+ 			x->id_edev = NULL;
+ 			dev_info(x->dev, "No separate ID extcon device\n");
+ 		}
+ 
+ 		if (x->vbus_nb.notifier_call) {
+ 			ret = devm_extcon_register_notifier(x->dev, x->edev,
+ 							    EXTCON_USB,
+ 							    &x->vbus_nb);
+ 			if (ret < 0) {
+ 				dev_err(x->dev,
+ 					"register VBUS notifier failed\n");
+ 				return ret;
+ 			}
+ 		} else {
+ 			x->type_nb.notifier_call = usb_phy_get_charger_type;
+ 
+ 			ret = devm_extcon_register_notifier(x->dev, x->edev,
+ 							    EXTCON_CHG_USB_SDP,
+ 							    &x->type_nb);
+ 			if (ret) {
+ 				dev_err(x->dev,
+ 					"register extcon USB SDP failed.\n");
+ 				return ret;
+ 			}
+ 
+ 			ret = devm_extcon_register_notifier(x->dev, x->edev,
+ 							    EXTCON_CHG_USB_CDP,
+ 							    &x->type_nb);
+ 			if (ret) {
+ 				dev_err(x->dev,
+ 					"register extcon USB CDP failed.\n");
+ 				return ret;
+ 			}
+ 
+ 			ret = devm_extcon_register_notifier(x->dev, x->edev,
+ 							    EXTCON_CHG_USB_DCP,
+ 							    &x->type_nb);
+ 			if (ret) {
+ 				dev_err(x->dev,
+ 					"register extcon USB DCP failed.\n");
+ 				return ret;
+ 			}
+ 
+ 			ret = devm_extcon_register_notifier(x->dev, x->edev,
+ 							    EXTCON_CHG_USB_ACA,
+ 							    &x->type_nb);
+ 			if (ret) {
+ 				dev_err(x->dev,
+ 					"register extcon USB ACA failed.\n");
+ 				return ret;
+ 			}
+ 		}
+ 
+ 		if (x->id_nb.notifier_call) {
+ 			struct extcon_dev *id_ext;
+ 
+ 			if (x->id_edev)
+ 				id_ext = x->id_edev;
+ 			else
+ 				id_ext = x->edev;
+ 
+ 			ret = devm_extcon_register_notifier(x->dev, id_ext,
+ 							    EXTCON_USB_HOST,
+ 							    &x->id_nb);
+ 			if (ret < 0) {
+ 				dev_err(x->dev,
+ 					"register ID notifier failed\n");
+ 				return ret;
+ 			}
+ 		}
+ 	}
+ 
+ 	usb_phy_set_default_current(x);
+ 	INIT_WORK(&x->chg_work, usb_phy_notify_charger_work);
+ 	x->chg_type = UNKNOWN_TYPE;
+ 	x->chg_state = USB_CHARGER_DEFAULT;
+ 	if (x->type_nb.notifier_call)
+ 		__usb_phy_get_charger_type(x);
+ 
+ 	return 0;
++>>>>>>> a9081a008f84 (usb: phy: Add USB charger support)
  }
  
  /**
diff --cc include/linux/usb/phy.h
index 31a8068c42a5,de881b171ba9..000000000000
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@@ -9,8 -9,10 +9,9 @@@
  #ifndef __LINUX_USB_PHY_H
  #define __LINUX_USB_PHY_H
  
 -#include <linux/extcon.h>
  #include <linux/notifier.h>
  #include <linux/usb.h>
+ #include <uapi/linux/usb/charger.h>
  
  enum usb_phy_interface {
  	USBPHY_INTERFACE_MODE_UNKNOWN,
@@@ -85,6 -98,19 +97,22 @@@ struct usb_phy 
  	struct usb_phy_io_ops	*io_ops;
  	void __iomem		*io_priv;
  
++<<<<<<< HEAD
++=======
+ 	/* to support extcon device */
+ 	struct extcon_dev	*edev;
+ 	struct extcon_dev	*id_edev;
+ 	struct notifier_block	vbus_nb;
+ 	struct notifier_block	id_nb;
+ 	struct notifier_block	type_nb;
+ 
+ 	/* Support USB charger */
+ 	enum usb_charger_type	chg_type;
+ 	enum usb_charger_state	chg_state;
+ 	struct usb_charger_current	chg_cur;
+ 	struct work_struct		chg_work;
+ 
++>>>>>>> a9081a008f84 (usb: phy: Add USB charger support)
  	/* for notification of usb_phy_events */
  	struct atomic_notifier_head	notifier;
  
* Unmerged path drivers/usb/phy/phy.c
* Unmerged path include/linux/usb/phy.h
