drm/nouveau/kms/nv50-: handle degamma LUT from window channels

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ben Skeggs <bskeggs@redhat.com>
commit 119608a7f3f1ef899f1f98d05306340b92834836
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/119608a7.failed

Required to eventually support DRM colour management APIs, and to
support Volta.

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit 119608a7f3f1ef899f1f98d05306340b92834836)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/powerplay/inc/pp_soc15.h
#	drivers/gpu/drm/nouveau/dispnv50/Kbuild
#	drivers/gpu/drm/nouveau/dispnv50/atom.h
#	drivers/gpu/drm/nouveau/dispnv50/base.h
#	drivers/gpu/drm/nouveau/dispnv50/base507c.c
#	drivers/gpu/drm/nouveau/dispnv50/base827c.c
#	drivers/gpu/drm/nouveau/dispnv50/base907c.c
#	drivers/gpu/drm/nouveau/dispnv50/head.c
#	drivers/gpu/drm/nouveau/dispnv50/head.h
#	drivers/gpu/drm/nouveau/dispnv50/head507d.c
#	drivers/gpu/drm/nouveau/dispnv50/head827d.c
#	drivers/gpu/drm/nouveau/dispnv50/head907d.c
#	drivers/gpu/drm/nouveau/dispnv50/wndw.c
#	drivers/gpu/drm/nouveau/dispnv50/wndw.h
diff --cc drivers/gpu/drm/amd/powerplay/inc/pp_soc15.h
index a511611ec7e0,5f654512c8c2..000000000000
--- a/drivers/gpu/drm/amd/powerplay/inc/pp_soc15.h
+++ b/drivers/gpu/drm/amd/powerplay/inc/pp_soc15.h
@@@ -18,33 -18,66 +18,81 @@@
   * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   * OTHER DEALINGS IN THE SOFTWARE.
 + *
   */
 -#include "head.h"
 -#include "core.h"
 +#ifndef PP_SOC15_H
 +#define PP_SOC15_H
  
 -static void
 -head917d_dither(struct nv50_head *head, struct nv50_head_atom *asyh)
 +#include "vega10/soc15ip.h"
 +
 +inline static uint32_t soc15_get_register_offset(
 +		uint32_t hw_id,
 +		uint32_t inst,
 +		uint32_t segment,
 +		uint32_t offset)
  {
 -	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
 -	u32 *push;
 -	if ((push = evo_wait(core, 2))) {
 -		evo_mthd(push, 0x04a0 + (head->base.index * 0x0300), 1);
 -		evo_data(push, asyh->dither.mode << 3 |
 -			       asyh->dither.bits << 1 |
 -			       asyh->dither.enable);
 -		evo_kick(push, core);
 -	}
 +	uint32_t reg = 0;
 +
 +	if (hw_id == THM_HWID)
 +		reg = THM_BASE.instance[inst].segment[segment] + offset;
 +	else if (hw_id == NBIF_HWID)
 +		reg = NBIF_BASE.instance[inst].segment[segment] + offset;
 +	else if (hw_id == MP1_HWID)
 +		reg = MP1_BASE.instance[inst].segment[segment] + offset;
 +	else if (hw_id == DF_HWID)
 +		reg = DF_BASE.instance[inst].segment[segment] + offset;
 +	else if (hw_id == GC_HWID)
 +		reg = GC_BASE.instance[inst].segment[segment] + offset;
 +
 +	return reg;
  }
  
++<<<<<<< HEAD:drivers/gpu/drm/amd/powerplay/inc/pp_soc15.h
 +#endif
++=======
+ static void
+ head917d_base(struct nv50_head *head, struct nv50_head_atom *asyh)
+ {
+ 	struct nv50_dmac *core = &nv50_disp(head->base.base.dev)->core->chan;
+ 	u32 bounds = 0;
+ 	u32 *push;
+ 
+ 	if (asyh->base.cpp) {
+ 		switch (asyh->base.cpp) {
+ 		case 8: bounds |= 0x00000500; break;
+ 		case 4: bounds |= 0x00000300; break;
+ 		case 2: bounds |= 0x00000100; break;
+ 		case 1: bounds |= 0x00000000; break;
+ 		default:
+ 			WARN_ON(1);
+ 			break;
+ 		}
+ 		bounds |= 0x00020001;
+ 	}
+ 
+ 	if ((push = evo_wait(core, 2))) {
+ 		evo_mthd(push, 0x04d0 + head->base.index * 0x300, 1);
+ 		evo_data(push, bounds);
+ 		evo_kick(push, core);
+ 	}
+ }
+ 
+ const struct nv50_head_func
+ head917d = {
+ 	.view = head907d_view,
+ 	.mode = head907d_mode,
+ 	.olut = head907d_olut,
+ 	.olut_set = head907d_olut_set,
+ 	.olut_clr = head907d_olut_clr,
+ 	.core_calc = head507d_core_calc,
+ 	.core_set = head907d_core_set,
+ 	.core_clr = head907d_core_clr,
+ 	.curs_set = head907d_curs_set,
+ 	.curs_clr = head907d_curs_clr,
+ 	.base = head917d_base,
+ 	.ovly = head907d_ovly,
+ 	.dither = head917d_dither,
+ 	.procamp = head907d_procamp,
+ 	.or = head907d_or,
+ };
++>>>>>>> 119608a7f3f1 (drm/nouveau/kms/nv50-: handle degamma LUT from window channels):drivers/gpu/drm/nouveau/dispnv50/head917d.c
diff --cc drivers/gpu/drm/nouveau/dispnv50/Kbuild
index 43fc8be49391,d074bb8ecd1b..000000000000
--- a/drivers/gpu/drm/nouveau/dispnv50/Kbuild
+++ b/drivers/gpu/drm/nouveau/dispnv50/Kbuild
@@@ -1,1 -1,41 +1,44 @@@
  nouveau-y += dispnv50/disp.o
++<<<<<<< HEAD
++=======
+ nouveau-y += dispnv50/lut.o
+ 
+ nouveau-y += dispnv50/core.o
+ nouveau-y += dispnv50/core507d.o
+ nouveau-y += dispnv50/core827d.o
+ nouveau-y += dispnv50/core907d.o
+ nouveau-y += dispnv50/core917d.o
+ 
+ nouveau-y += dispnv50/dac507d.o
+ nouveau-y += dispnv50/dac907d.o
+ 
+ nouveau-y += dispnv50/pior507d.o
+ 
+ nouveau-y += dispnv50/sor507d.o
+ nouveau-y += dispnv50/sor907d.o
+ 
+ nouveau-y += dispnv50/head.o
+ nouveau-y += dispnv50/head507d.o
+ nouveau-y += dispnv50/head827d.o
+ nouveau-y += dispnv50/head907d.o
+ nouveau-y += dispnv50/head917d.o
+ 
+ nouveau-y += dispnv50/wndw.o
+ 
+ nouveau-y += dispnv50/base.o
+ nouveau-y += dispnv50/base507c.o
+ nouveau-y += dispnv50/base827c.o
+ nouveau-y += dispnv50/base907c.o
+ 
+ nouveau-y += dispnv50/curs.o
+ nouveau-y += dispnv50/curs507a.o
+ nouveau-y += dispnv50/curs907a.o
+ 
+ nouveau-y += dispnv50/oimm.o
+ nouveau-y += dispnv50/oimm507b.o
+ 
+ nouveau-y += dispnv50/ovly.o
+ nouveau-y += dispnv50/ovly507e.o
+ nouveau-y += dispnv50/ovly827e.o
+ nouveau-y += dispnv50/ovly907e.o
++>>>>>>> 119608a7f3f1 (drm/nouveau/kms/nv50-: handle degamma LUT from window channels)
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/atom.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/base.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/base507c.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/base827c.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/base907c.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/head.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/head.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/head507d.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/head827d.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/head907d.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/wndw.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/wndw.h
* Unmerged path drivers/gpu/drm/amd/powerplay/inc/pp_soc15.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/Kbuild
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/atom.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/base.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/base507c.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/base827c.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/base907c.c
diff --git a/drivers/gpu/drm/nouveau/dispnv50/disp.c b/drivers/gpu/drm/nouveau/dispnv50/disp.c
index a2ea42f947c7..a940d00d2c41 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.c
@@ -4252,8 +4252,19 @@ nv50_disp_atomic_check(struct drm_device *dev, struct drm_atomic_state *state)
 	struct nv50_atom *atom = nv50_atom(state);
 	struct drm_connector_state *old_connector_state, *new_connector_state;
 	struct drm_connector *connector;
+	struct drm_crtc_state *new_crtc_state;
+	struct drm_crtc *crtc;
 	int ret, i;
 
+	/* We need to handle colour management on a per-plane basis. */
+	for_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {
+		if (new_crtc_state->color_mgmt_changed) {
+			ret = drm_atomic_add_affected_planes(state, crtc);
+			if (ret)
+				return ret;
+		}
+	}
+
 	ret = drm_atomic_helper_check(dev, state);
 	if (ret)
 		return ret;
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/head.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/head.h
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/head507d.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/head827d.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/head907d.c
diff --git a/drivers/gpu/drm/nouveau/dispnv50/lut.c b/drivers/gpu/drm/nouveau/dispnv50/lut.c
new file mode 100644
index 000000000000..a6b96ae2a22f
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv50/lut.c
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2018 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "lut.h"
+#include "disp.h"
+
+#include <drm/drm_color_mgmt.h>
+#include <drm/drm_mode.h>
+#include <drm/drm_property.h>
+
+#include <nvif/class.h>
+
+u32
+nv50_lut_load(struct nv50_lut *lut, bool legacy, int buffer,
+	      struct drm_property_blob *blob)
+{
+	struct drm_color_lut *in = (struct drm_color_lut *)blob->data;
+	void __iomem *mem = lut->mem[buffer].object.map.ptr;
+	const int size = blob->length / sizeof(*in);
+	int bits, shift, i;
+	u16 zero, r, g, b;
+	u32 addr = lut->mem[buffer].addr;
+
+	/* This can't happen.. But it shuts the compiler up. */
+	if (WARN_ON(size != 256))
+		return 0;
+
+	if (legacy) {
+		bits = 11;
+		shift = 3;
+		zero = 0x0000;
+	} else {
+		bits = 14;
+		shift = 0;
+		zero = 0x6000;
+	}
+
+	for (i = 0; i < size; i++) {
+		r = (drm_color_lut_extract(in[i].  red, bits) + zero) << shift;
+		g = (drm_color_lut_extract(in[i].green, bits) + zero) << shift;
+		b = (drm_color_lut_extract(in[i]. blue, bits) + zero) << shift;
+		writew(r, mem + (i * 0x08) + 0);
+		writew(g, mem + (i * 0x08) + 2);
+		writew(b, mem + (i * 0x08) + 4);
+	}
+
+	/* INTERPOLATE modes require a "next" entry to interpolate with,
+	 * so we replicate the last entry to deal with this for now.
+	 */
+	writew(r, mem + (i * 0x08) + 0);
+	writew(g, mem + (i * 0x08) + 2);
+	writew(b, mem + (i * 0x08) + 4);
+	return addr;
+}
+
+void
+nv50_lut_fini(struct nv50_lut *lut)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(lut->mem); i++)
+		nvif_mem_fini(&lut->mem[i]);
+}
+
+int
+nv50_lut_init(struct nv50_disp *disp, struct nvif_mmu *mmu,
+	      struct nv50_lut *lut)
+{
+	const u32 size = disp->disp->object.oclass < GF110_DISP ? 257 : 1025;
+	int i;
+	for (i = 0; i < ARRAY_SIZE(lut->mem); i++) {
+		int ret = nvif_mem_init_map(mmu, NVIF_MEM_VRAM, size * 8,
+					    &lut->mem[i]);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
diff --git a/drivers/gpu/drm/nouveau/dispnv50/lut.h b/drivers/gpu/drm/nouveau/dispnv50/lut.h
new file mode 100644
index 000000000000..6d7b8352e4cb
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv50/lut.h
@@ -0,0 +1,15 @@
+#ifndef __NV50_KMS_LUT_H__
+#define __NV50_KMS_LUT_H__
+#include <nvif/mem.h>
+struct drm_property_blob;
+struct nv50_disp;
+
+struct nv50_lut {
+	struct nvif_mem mem[2];
+};
+
+int nv50_lut_init(struct nv50_disp *, struct nvif_mmu *, struct nv50_lut *);
+void nv50_lut_fini(struct nv50_lut *);
+u32 nv50_lut_load(struct nv50_lut *, bool legacy, int buffer,
+		  struct drm_property_blob *);
+#endif
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/wndw.c
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/wndw.h
