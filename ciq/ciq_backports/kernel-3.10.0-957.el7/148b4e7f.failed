nvme-rdma: stop queues instead of simply flipping their state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Sagi Grimberg <sagi@grimberg.me>
commit 148b4e7ff31e4bb90cf7851ad1bcd305c292be2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/148b4e7f.failed

If we move the queues from LIVE state, we might as well stop them (drain
for rdma).  Do it after we stop the request queues to prevent a stray
request sneaking in .queue_rq after we stop the queue.

	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 148b4e7ff31e4bb90cf7851ad1bcd305c292be2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/rdma.c
diff --cc drivers/nvme/host/rdma.c
index 6d8e34242c5f,34d3ed8b249e..000000000000
--- a/drivers/nvme/host/rdma.c
+++ b/drivers/nvme/host/rdma.c
@@@ -792,16 -945,15 +792,19 @@@ static void nvme_rdma_error_recovery_wo
  {
  	struct nvme_rdma_ctrl *ctrl = container_of(work,
  			struct nvme_rdma_ctrl, err_work);
- 	int i;
  
 -	nvme_stop_ctrl(&ctrl->ctrl);
 +	nvme_stop_keep_alive(&ctrl->ctrl);
  
- 	for (i = 0; i < ctrl->ctrl.queue_count; i++)
- 		clear_bit(NVME_RDMA_Q_LIVE, &ctrl->queues[i].flags);
- 
- 	if (ctrl->ctrl.queue_count > 1)
+ 	if (ctrl->ctrl.queue_count > 1) {
  		nvme_stop_queues(&ctrl->ctrl);
++<<<<<<< HEAD
 +	blk_mq_stop_hw_queues(ctrl->ctrl.admin_q);
++=======
+ 		nvme_rdma_stop_io_queues(ctrl);
+ 	}
+ 	blk_mq_quiesce_queue(ctrl->ctrl.admin_q);
+ 	nvme_rdma_stop_queue(&ctrl->queues[0]);
++>>>>>>> 148b4e7ff31e (nvme-rdma: stop queues instead of simply flipping their state)
  
  	/* We must take care of fastfail/requeue all our inflight requests */
  	if (ctrl->ctrl.queue_count > 1)
* Unmerged path drivers/nvme/host/rdma.c
