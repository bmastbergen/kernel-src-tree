usb: typec: wcove: fix uninitialized usbc_irq1 and usbc_irq2

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [usb] typec: wcove: fix uninitialized usbc_irq1 and usbc_irq2 (Torez Smith) [1540721]
Rebuild_FUZZ: 95.65%
commit-author Colin Ian King <colin.king@canonical.com>
commit 707a123d7affbf1e98f08d1962d81a0d64f83191
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/707a123d.failed

Calls to regmap_read may fail with an -EINVAL return without setting
usbc_irq1 and usbc_irq2.  The error handling clean up expects these
to have been set (or zero on a failure) and currently may try to
clear the wrong IRQs if the uninitalized garbage values in usbc_irq1
or usbc_irq2 are non-zero.  The simplest fix is to ensure these
variables are initialized to zero.

Detected by CoverityScan, CID#1457737 ("Uninitialized scalar variable")

Fixes: 3c4fb9f16921 ("usb: typec: wcove: start using tcpm for USB PD support")
	Signed-off-by: Colin Ian King <colin.king@canonical.com>
	Acked-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 707a123d7affbf1e98f08d1962d81a0d64f83191)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/typec/typec_wcove.c
diff --cc drivers/usb/typec/typec_wcove.c
index d5a7b21fa3f1,4ce30a967962..000000000000
--- a/drivers/usb/typec/typec_wcove.c
+++ b/drivers/usb/typec/typec_wcove.c
@@@ -129,17 -200,250 +129,23 @@@ static int wcove_typec_func(struct wcov
  	return 0;
  }
  
 -static int wcove_init(struct tcpc_dev *tcpc)
 -{
 -	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
 -	int ret;
 -
 -	/* Unmask everything */
 -	ret = regmap_write(wcove->regmap, USBC_IRQMASK1, 0);
 -	if (ret)
 -		return ret;
 -
 -	return regmap_write(wcove->regmap, USBC_IRQMASK2, 0);
 -}
 -
 -static int wcove_get_vbus(struct tcpc_dev *tcpc)
 -{
 -	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
 -	unsigned int cc1ctrl;
 -	int ret;
 -
 -	ret = regmap_read(wcove->regmap, USBC_CC1_CTRL, &cc1ctrl);
 -	if (ret)
 -		return ret;
 -
 -	wcove->vbus = !!(cc1ctrl & USBC_CC_CTRL_VBUSOK);
 -
 -	return wcove->vbus;
 -}
 -
 -static int wcove_set_vbus(struct tcpc_dev *tcpc, bool on, bool sink)
 -{
 -	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
 -
 -	return wcove_typec_func(wcove, WCOVE_FUNC_DRIVE_VBUS, on);
 -}
 -
 -static int wcove_set_vconn(struct tcpc_dev *tcpc, bool on)
 -{
 -	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
 -
 -	return wcove_typec_func(wcove, WCOVE_FUNC_DRIVE_VCONN, on);
 -}
 -
 -static enum typec_cc_status wcove_to_typec_cc(unsigned int cc)
 -{
 -	if (cc & UCSC_CC_STATUS_SNK_RP) {
 -		if (cc & UCSC_CC_STATUS_PWRDEFSNK)
 -			return TYPEC_CC_RP_DEF;
 -		else if (cc & UCSC_CC_STATUS_PWR_1P5A_SNK)
 -			return TYPEC_CC_RP_1_5;
 -		else if (cc & UCSC_CC_STATUS_PWR_3A_SNK)
 -			return TYPEC_CC_RP_3_0;
 -	} else {
 -		switch (UCSC_CC_STATUS_RX(cc)) {
 -		case USBC_CC_STATUS_RD:
 -			return TYPEC_CC_RD;
 -		case USBC_CC_STATUS_RA:
 -			return TYPEC_CC_RA;
 -		default:
 -			break;
 -		}
 -	}
 -	return TYPEC_CC_OPEN;
 -}
 -
 -static int wcove_get_cc(struct tcpc_dev *tcpc, enum typec_cc_status *cc1,
 -			enum typec_cc_status *cc2)
 -{
 -	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
 -	unsigned int cc1_status;
 -	unsigned int cc2_status;
 -	int ret;
 -
 -	ret = regmap_read(wcove->regmap, USBC_CC1_STATUS, &cc1_status);
 -	if (ret)
 -		return ret;
 -
 -	ret = regmap_read(wcove->regmap, USBC_CC2_STATUS, &cc2_status);
 -	if (ret)
 -		return ret;
 -
 -	*cc1 = wcove_to_typec_cc(cc1_status);
 -	*cc2 = wcove_to_typec_cc(cc2_status);
 -
 -	return 0;
 -}
 -
 -static int wcove_set_cc(struct tcpc_dev *tcpc, enum typec_cc_status cc)
 -{
 -	/* XXX: Relying on the HW FSM to configure things correctly for now */
 -	return 0;
 -}
 -
 -static int wcove_set_polarity(struct tcpc_dev *tcpc, enum typec_cc_polarity pol)
 -{
 -	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
 -
 -	return wcove_typec_func(wcove, WCOVE_FUNC_ORIENTATION, pol);
 -}
 -
 -static int wcove_set_current_limit(struct tcpc_dev *tcpc, u32 max_ma, u32 mv)
 -{
 -	return 0;
 -}
 -
 -static int wcove_set_roles(struct tcpc_dev *tcpc, bool attached,
 -			   enum typec_role role, enum typec_data_role data)
 -{
 -	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
 -	unsigned int val;
 -	int ret;
 -
 -	ret = wcove_typec_func(wcove, WCOVE_FUNC_ROLE, data == TYPEC_HOST ?
 -			       WCOVE_ROLE_HOST : WCOVE_ROLE_DEVICE);
 -	if (ret)
 -		return ret;
 -
 -	val = role;
 -	val |= data << USBC_PDCFG3_DATAROLE_SHIFT;
 -	val |= PD_REV20 << USBC_PDCFG3_SOP_SHIFT;
 -
 -	return regmap_write(wcove->regmap, USBC_PDCFG3, val);
 -}
 -
 -static int wcove_set_pd_rx(struct tcpc_dev *tcpc, bool on)
 -{
 -	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
 -
 -	return regmap_write(wcove->regmap, USBC_PDCFG2,
 -			    on ? USBC_PDCFG2_SOP : 0);
 -}
 -
 -static int wcove_pd_transmit(struct tcpc_dev *tcpc,
 -			     enum tcpm_transmit_type type,
 -			     const struct pd_message *msg)
 -{
 -	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
 -	unsigned int info = 0;
 -	unsigned int cmd;
 -	int ret;
 -
 -	ret = regmap_read(wcove->regmap, USBC_TXCMD, &cmd);
 -	if (ret)
 -		return ret;
 -
 -	if (!(cmd & USBC_TXCMD_BUF_RDY)) {
 -		dev_warn(wcove->dev, "%s: Last transmission still ongoing!",
 -			 __func__);
 -		return -EBUSY;
 -	}
 -
 -	if (msg) {
 -		const u8 *data = (void *)msg;
 -		int i;
 -
 -		for (i = 0; i < pd_header_cnt(msg->header) * 4 + 2; i++) {
 -			ret = regmap_write(wcove->regmap, USBC_TX_DATA + i,
 -					   data[i]);
 -			if (ret)
 -				return ret;
 -		}
 -	}
 -
 -	switch (type) {
 -	case TCPC_TX_SOP:
 -	case TCPC_TX_SOP_PRIME:
 -	case TCPC_TX_SOP_PRIME_PRIME:
 -	case TCPC_TX_SOP_DEBUG_PRIME:
 -	case TCPC_TX_SOP_DEBUG_PRIME_PRIME:
 -		info = type + 1;
 -		cmd = USBC_TXCMD_MSG;
 -		break;
 -	case TCPC_TX_HARD_RESET:
 -		cmd = USBC_TXCMD_HR;
 -		break;
 -	case TCPC_TX_CABLE_RESET:
 -		cmd = USBC_TXCMD_CR;
 -		break;
 -	case TCPC_TX_BIST_MODE_2:
 -		cmd = USBC_TXCMD_BIST;
 -		break;
 -	default:
 -		return -EINVAL;
 -	}
 -
 -	/* NOTE Setting maximum number of retries (7) */
 -	ret = regmap_write(wcove->regmap, USBC_TXINFO,
 -			   info | USBC_TXINFO_RETRIES(7));
 -	if (ret)
 -		return ret;
 -
 -	return regmap_write(wcove->regmap, USBC_TXCMD, cmd | USBC_TXCMD_START);
 -}
 -
 -static int wcove_start_drp_toggling(struct tcpc_dev *tcpc,
 -				    enum typec_cc_status cc)
 -{
 -	struct wcove_typec *wcove = tcpc_to_wcove(tcpc);
 -	unsigned int usbc_ctrl;
 -
 -	usbc_ctrl = USBC_CONTROL1_MODE_DRP | USBC_CONTROL1_DRPTOGGLE_RANDOM;
 -
 -	switch (cc) {
 -	case TYPEC_CC_RP_1_5:
 -		usbc_ctrl |= USBC_CONTROL1_CURSRC_UA_180;
 -		break;
 -	case TYPEC_CC_RP_3_0:
 -		usbc_ctrl |= USBC_CONTROL1_CURSRC_UA_330;
 -		break;
 -	default:
 -		usbc_ctrl |= USBC_CONTROL1_CURSRC_UA_80;
 -		break;
 -	}
 -
 -	return regmap_write(wcove->regmap, USBC_CONTROL1, usbc_ctrl);
 -}
 -
 -static int wcove_read_rx_buffer(struct wcove_typec *wcove, void *msg)
 -{
 -	unsigned int info;
 -	int ret;
 -	int i;
 -
 -	ret = regmap_read(wcove->regmap, USBC_RXINFO, &info);
 -	if (ret)
 -		return ret;
 -
 -	/* FIXME: Check that USBC_RXINFO_RXBYTES(info) matches the header */
 -
 -	for (i = 0; i < USBC_RXINFO_RXBYTES(info); i++) {
 -		ret = regmap_read(wcove->regmap, USBC_RX_DATA + i, msg + i);
 -		if (ret)
 -			return ret;
 -	}
 -
 -	return regmap_write(wcove->regmap, USBC_RXSTATUS,
 -			    USBC_RXSTATUS_RXCLEAR);
 -}
 -
  static irqreturn_t wcove_typec_irq(int irq, void *data)
  {
 +	enum typec_role role = TYPEC_SINK;
 +	struct typec_partner_desc partner;
  	struct wcove_typec *wcove = data;
++<<<<<<< HEAD
 +	unsigned int cc1_ctrl;
 +	unsigned int cc2_ctrl;
 +	unsigned int cc_irq1;
 +	unsigned int cc_irq2;
 +	unsigned int status1;
 +	unsigned int status2;
++=======
+ 	unsigned int usbc_irq1 = 0;
+ 	unsigned int usbc_irq2 = 0;
+ 	unsigned int cc1ctrl;
++>>>>>>> 707a123d7aff (usb: typec: wcove: fix uninitialized usbc_irq1 and usbc_irq2)
  	int ret;
  
  	mutex_lock(&wcove->lock);
* Unmerged path drivers/usb/typec/typec_wcove.c
