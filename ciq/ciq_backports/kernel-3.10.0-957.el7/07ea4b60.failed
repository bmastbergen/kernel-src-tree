scsi: qla2xxx: do not check login_state if no loop id is assigned

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: do not check login_state if no loop id is assigned (Himanshu Madhani) [1547714]
Rebuild_FUZZ: 95.16%
commit-author Hannes Reinecke <hare@suse.de>
commit 07ea4b6026ee8b8dfaf9bbe83a09b3ba905d20fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/07ea4b60.failed

When no loop id is assigned in qla24xx_fcport_handle_login() the login
state needs to be ignored; it will get set later on in
qla_chk_n2n_b4_login().

	Cc: Quinn Tran <quinn.tran@cavium.com>
	Cc: Himanshu Madhani <himanshu.madhani@cavium.com>
Fixes: 040036bb0bc1 ("scsi: qla2xxx: Delay loop id allocation at login")
	Signed-off-by: Hannes Reinecke <hare@suse.com>
	Acked-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 07ea4b6026ee8b8dfaf9bbe83a09b3ba905d20fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 12e11bcce844,4efc25700e99..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -826,33 -1039,127 +826,39 @@@ void qla24xx_handle_gpdb_event(scsi_qla
  		/*
  		 * We have an existing session. A late RSCN delivery
  		 * must have triggered the session to be re-validate.
 -		 * Session is still valid.
 +		 * session is still valid.
  		 */
 -		ql_dbg(ql_dbg_disc, vha, 0x20d6,
 -		    "%s %d %8phC session revalidate success\n",
 -		    __func__, __LINE__, ea->fcport->port_name);
 -		ea->fcport->disc_state = DSC_LOGIN_COMPLETE;
 +		fcport->disc_state = DSC_LOGIN_COMPLETE;
  	}
  	spin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);
 -}
 -
 -static
 -void qla24xx_handle_gpdb_event(scsi_qla_host_t *vha, struct event_arg *ea)
 -{
 -	fc_port_t *fcport = ea->fcport;
 -	struct port_database_24xx *pd;
 -	struct srb *sp = ea->sp;
 -
 -	pd = (struct port_database_24xx *)sp->u.iocb_cmd.u.mbx.in;
 -
 -	fcport->flags &= ~FCF_ASYNC_SENT;
 -
 -	ql_dbg(ql_dbg_disc, vha, 0x20d2,
 -	    "%s %8phC DS %d LS %d rc %d\n", __func__, fcport->port_name,
 -	    fcport->disc_state, pd->current_login_state, ea->rc);
 -
 -	if (fcport->disc_state == DSC_DELETE_PEND)
 -		return;
 -
 -	switch (pd->current_login_state) {
 -	case PDS_PRLI_COMPLETE:
 -		__qla24xx_parse_gpdb(vha, fcport, pd);
 -		break;
 -	case PDS_PLOGI_PENDING:
 -	case PDS_PLOGI_COMPLETE:
 -	case PDS_PRLI_PENDING:
 -	case PDS_PRLI2_PENDING:
 -		ql_dbg(ql_dbg_disc, vha, 0x20d5, "%s %d %8phC relogin needed\n",
 -		    __func__, __LINE__, fcport->port_name);
 -		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
 -		return;
 -	case PDS_LOGO_PENDING:
 -	case PDS_PORT_UNAVAILABLE:
 -	default:
 -		ql_dbg(ql_dbg_disc, vha, 0x20d5, "%s %d %8phC post del sess\n",
 -		    __func__, __LINE__, fcport->port_name);
 -		qlt_schedule_sess_for_deletion(fcport);
 -		return;
 -	}
 -	__qla24xx_handle_gpdb_event(vha, ea);
  } /* gpdb event */
  
 -static void qla_chk_n2n_b4_login(struct scsi_qla_host *vha, fc_port_t *fcport)
 -{
 -	u8 login = 0;
 -	int rc;
 -
 -	if (qla_tgt_mode_enabled(vha))
 -		return;
 -
 -	if (qla_dual_mode_enabled(vha)) {
 -		if (N2N_TOPO(vha->hw)) {
 -			u64 mywwn, wwn;
 -
 -			mywwn = wwn_to_u64(vha->port_name);
 -			wwn = wwn_to_u64(fcport->port_name);
 -			if (mywwn > wwn)
 -				login = 1;
 -			else if ((fcport->fw_login_state == DSC_LS_PLOGI_COMP)
 -			    && time_after_eq(jiffies,
 -				    fcport->plogi_nack_done_deadline))
 -				login = 1;
 -		} else {
 -			login = 1;
 -		}
 -	} else {
 -		/* initiator mode */
 -		login = 1;
 -	}
 -
 -	if (login) {
 -		if (fcport->loop_id == FC_NO_LOOP_ID) {
 -			fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;
 -			rc = qla2x00_find_new_loop_id(vha, fcport);
 -			if (rc) {
 -				ql_dbg(ql_dbg_disc, vha, 0x20e6,
 -				    "%s %d %8phC post del sess - out of loopid\n",
 -				    __func__, __LINE__, fcport->port_name);
 -				fcport->scan_state = 0;
 -				qlt_schedule_sess_for_deletion(fcport);
 -				return;
 -			}
 -		}
 -		ql_dbg(ql_dbg_disc, vha, 0x20bf,
 -		    "%s %d %8phC post login\n",
 -		    __func__, __LINE__, fcport->port_name);
 -		qla2x00_post_async_login_work(vha, fcport, NULL);
 -	}
 -}
 -
  int qla24xx_fcport_handle_login(struct scsi_qla_host *vha, fc_port_t *fcport)
  {
 -	u16 data[2];
 -	u64 wwn;
 +	if (fcport->login_retry == 0)
 +		return 0;
  
 +	if (fcport->scan_state != QLA_FCPORT_FOUND)
 +		return 0;
 +
++<<<<<<< HEAD
  	ql_dbg(ql_dbg_disc, vha, 0x20d8,
 -	    "%s %8phC DS %d LS %d P %d fl %x confl %p rscn %d|%d login %d retry %d lid %d scan %d\n",
 +	    "%s %8phC DS %d LS %d P %d fl %x confl %p rscn %d|%d login %d|%d retry %d lid %d\n",
  	    __func__, fcport->port_name, fcport->disc_state,
  	    fcport->fw_login_state, fcport->login_pause, fcport->flags,
  	    fcport->conflict, fcport->last_rscn_gen, fcport->rscn_gen,
 -	    fcport->login_gen, fcport->login_retry,
 -	    fcport->loop_id, fcport->scan_state);
 +	    fcport->last_login_gen, fcport->login_gen, fcport->login_retry,
 +	    fcport->loop_id);
  
 -	if (fcport->login_retry == 0)
 -		return 0;
 -
 -	if (fcport->scan_state != QLA_FCPORT_FOUND)
 -		return 0;
 +	fcport->login_retry--;
  
 +	if ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||
 +	    (fcport->fw_login_state == DSC_LS_PRLI_PEND))
++=======
+ 	if ((fcport->loop_id != FC_NO_LOOP_ID) &&
+ 	    ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||
+ 	     (fcport->fw_login_state == DSC_LS_PRLI_PEND)))
++>>>>>>> 07ea4b6026ee (scsi: qla2xxx: do not check login_state if no loop id is assigned)
  		return 0;
  
  	if (fcport->fw_login_state == DSC_LS_PLOGI_COMP) {
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
