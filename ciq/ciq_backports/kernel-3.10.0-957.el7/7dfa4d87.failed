nfp: bpf: print map lookup problems into verifier log

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 7dfa4d87cfc48f3d4171f4a1b886bbbe4faf5c07
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7dfa4d87.failed

Use the verifier log to output error messages if map lookup
can't be offloaded.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Acked-by: Quentin Monnet <quentin.monnet@netronome.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 7dfa4d87cfc48f3d4171f4a1b886bbbe4faf5c07)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/bpf/verifier.c
diff --cc drivers/net/ethernet/netronome/nfp/bpf/verifier.c
index 0f4ae869a0f1,81dab462456c..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/verifier.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/verifier.c
@@@ -74,14 -70,104 +74,66 @@@ nfp_bpf_goto_meta(struct nfp_prog *nfp_
  	return meta;
  }
  
 -static void
 -nfp_record_adjust_head(struct nfp_app_bpf *bpf, struct nfp_prog *nfp_prog,
 -		       struct nfp_insn_meta *meta,
 -		       const struct bpf_reg_state *reg2)
 -{
 -	unsigned int location =	UINT_MAX;
 -	int imm;
 -
 -	/* Datapath usually can give us guarantees on how much adjust head
 -	 * can be done without the need for any checks.  Optimize the simple
 -	 * case where there is only one adjust head by a constant.
 -	 */
 -	if (reg2->type != SCALAR_VALUE || !tnum_is_const(reg2->var_off))
 -		goto exit_set_location;
 -	imm = reg2->var_off.value;
 -	/* Translator will skip all checks, we need to guarantee min pkt len */
 -	if (imm > ETH_ZLEN - ETH_HLEN)
 -		goto exit_set_location;
 -	if (imm > (int)bpf->adjust_head.guaranteed_add ||
 -	    imm < -bpf->adjust_head.guaranteed_sub)
 -		goto exit_set_location;
 -
 -	if (nfp_prog->adjust_head_location) {
 -		/* Only one call per program allowed */
 -		if (nfp_prog->adjust_head_location != meta->n)
 -			goto exit_set_location;
 -
 -		if (meta->arg2.var_off.value != imm)
 -			goto exit_set_location;
 -	}
 -
 -	location = meta->n;
 -exit_set_location:
 -	nfp_prog->adjust_head_location = location;
 -}
 -
  static int
 -nfp_bpf_check_call(struct nfp_prog *nfp_prog, struct bpf_verifier_env *env,
 -		   struct nfp_insn_meta *meta)
 +nfp_bpf_check_call(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)
  {
 -	const struct bpf_reg_state *reg1 = cur_regs(env) + BPF_REG_1;
 -	const struct bpf_reg_state *reg2 = cur_regs(env) + BPF_REG_2;
 -	struct nfp_app_bpf *bpf = nfp_prog->bpf;
  	u32 func_id = meta->insn.imm;
 -	s64 off, old_off;
  
  	switch (func_id) {
++<<<<<<< HEAD
++=======
+ 	case BPF_FUNC_xdp_adjust_head:
+ 		if (!bpf->adjust_head.off_max) {
+ 			pr_vlog(env, "adjust_head not supported by FW\n");
+ 			return -EOPNOTSUPP;
+ 		}
+ 		if (!(bpf->adjust_head.flags & NFP_BPF_ADJUST_HEAD_NO_META)) {
+ 			pr_vlog(env, "adjust_head: FW requires shifting metadata, not supported by the driver\n");
+ 			return -EOPNOTSUPP;
+ 		}
+ 
+ 		nfp_record_adjust_head(bpf, nfp_prog, meta, reg2);
+ 		break;
+ 
+ 	case BPF_FUNC_map_lookup_elem:
+ 		if (!bpf->helpers.map_lookup) {
+ 			pr_vlog(env, "map_lookup: not supported by FW\n");
+ 			return -EOPNOTSUPP;
+ 		}
+ 		if (reg2->type != PTR_TO_STACK) {
+ 			pr_vlog(env,
+ 				"map_lookup: unsupported key ptr type %d\n",
+ 				reg2->type);
+ 			return -EOPNOTSUPP;
+ 		}
+ 		if (!tnum_is_const(reg2->var_off)) {
+ 			pr_vlog(env, "map_lookup: variable key pointer\n");
+ 			return -EOPNOTSUPP;
+ 		}
+ 
+ 		off = reg2->var_off.value + reg2->off;
+ 		if (-off % 4) {
+ 			pr_vlog(env,
+ 				"map_lookup: unaligned stack pointer %lld\n",
+ 				-off);
+ 			return -EOPNOTSUPP;
+ 		}
+ 
+ 		/* Rest of the checks is only if we re-parse the same insn */
+ 		if (!meta->func_id)
+ 			break;
+ 
+ 		old_off = meta->arg2.var_off.value + meta->arg2.off;
+ 		meta->arg2_var_off |= off != old_off;
+ 
+ 		if (meta->arg1.map_ptr != reg1->map_ptr) {
+ 			pr_vlog(env, "map_lookup: called for different map\n");
+ 			return -EOPNOTSUPP;
+ 		}
+ 		break;
++>>>>>>> 7dfa4d87cfc4 (nfp: bpf: print map lookup problems into verifier log)
  	default:
 -		pr_vlog(env, "unsupported function id: %d\n", func_id);
 +		pr_warn("unsupported function id: %d\n", func_id);
  		return -EOPNOTSUPP;
  	}
  
@@@ -166,8 -263,15 +218,18 @@@ nfp_bpf_check_ptr(struct nfp_prog *nfp_
  			return err;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (reg->type == PTR_TO_MAP_VALUE) {
+ 		if (is_mbpf_store(meta)) {
+ 			pr_vlog(env, "map writes not supported\n");
+ 			return -EOPNOTSUPP;
+ 		}
+ 	}
+ 
++>>>>>>> 7dfa4d87cfc4 (nfp: bpf: print map lookup problems into verifier log)
  	if (meta->ptr.type != NOT_INIT && meta->ptr.type != reg->type) {
 -		pr_vlog(env, "ptr type changed for instruction %d -> %d\n",
 +		pr_info("ptr type changed for instruction %d -> %d\n",
  			meta->ptr.type, reg->type);
  		return -EINVAL;
  	}
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/verifier.c
