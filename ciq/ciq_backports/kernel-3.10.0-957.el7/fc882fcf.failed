ipv6: Regenerate host route according to node pointer upon interface up

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit fc882fcff1ee774cb6be9d3c714ae5ab9eec5aa4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/fc882fcf.failed

When an interface is brought back up, the kernel tries to restore the
host routes tied to its permanent addresses.

However, if the host route was removed from the FIB, then we need to
reinsert it. This is done by releasing the current dst and allocating a
new, so as to not reuse a dst with obsolete values.

Since this function is called under RTNL and using the same explanation
from the previous patch, we can test if the route is in the FIB by
checking its node pointer instead of its reference count.

Tested using the following script and Andrey's reproducer mentioned
in commit 8048ced9beb2 ("net: ipv6: regenerate host route if moved to gc
list") and linked below:

$ ip link set dev lo up
$ ip link add dummy1 type dummy
$ ip -6 address add cafe::1/64 dev dummy1
$ ip link set dev lo down	# cafe::1/128 is removed
$ ip link set dev dummy1 up
$ ip link set dev lo up

The host route is correctly regenerated.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
Link: http://lkml.kernel.org/r/CAAeHK+zSe82vc5gCRgr_EoUwiALPnWVdWJBPwJZBpbxYz=kGJw@mail.gmail.com
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fc882fcff1ee774cb6be9d3c714ae5ab9eec5aa4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/addrconf.c
diff --cc net/ipv6/addrconf.c
index 836f13f8d356,30ee23eef268..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -3071,6 -3318,66 +3071,69 @@@ static void addrconf_gre_config(struct 
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ static int fixup_permanent_addr(struct inet6_dev *idev,
+ 				struct inet6_ifaddr *ifp)
+ {
+ 	/* !rt6i_node means the host route was removed from the
+ 	 * FIB, for example, if 'lo' device is taken down. In that
+ 	 * case regenerate the host route.
+ 	 */
+ 	if (!ifp->rt || !ifp->rt->rt6i_node) {
+ 		struct rt6_info *rt, *prev;
+ 
+ 		rt = addrconf_dst_alloc(idev, &ifp->addr, false);
+ 		if (unlikely(IS_ERR(rt)))
+ 			return PTR_ERR(rt);
+ 
+ 		/* ifp->rt can be accessed outside of rtnl */
+ 		spin_lock(&ifp->lock);
+ 		prev = ifp->rt;
+ 		ifp->rt = rt;
+ 		spin_unlock(&ifp->lock);
+ 
+ 		ip6_rt_put(prev);
+ 	}
+ 
+ 	if (!(ifp->flags & IFA_F_NOPREFIXROUTE)) {
+ 		addrconf_prefix_route(&ifp->addr, ifp->prefix_len,
+ 				      idev->dev, 0, 0);
+ 	}
+ 
+ 	if (ifp->state == INET6_IFADDR_STATE_PREDAD)
+ 		addrconf_dad_start(ifp);
+ 
+ 	return 0;
+ }
+ 
+ static void addrconf_permanent_addr(struct net_device *dev)
+ {
+ 	struct inet6_ifaddr *ifp, *tmp;
+ 	struct inet6_dev *idev;
+ 
+ 	idev = __in6_dev_get(dev);
+ 	if (!idev)
+ 		return;
+ 
+ 	write_lock_bh(&idev->lock);
+ 
+ 	list_for_each_entry_safe(ifp, tmp, &idev->addr_list, if_list) {
+ 		if ((ifp->flags & IFA_F_PERMANENT) &&
+ 		    fixup_permanent_addr(idev, ifp) < 0) {
+ 			write_unlock_bh(&idev->lock);
+ 			ipv6_del_addr(ifp);
+ 			write_lock_bh(&idev->lock);
+ 
+ 			net_info_ratelimited("%s: Failed to add prefix route for address %pI6c; dropping\n",
+ 					     idev->dev->name, &ifp->addr);
+ 		}
+ 	}
+ 
+ 	write_unlock_bh(&idev->lock);
+ }
+ 
++>>>>>>> fc882fcff1ee (ipv6: Regenerate host route according to node pointer upon interface up)
  static int addrconf_notify(struct notifier_block *this, unsigned long event,
  			   void *ptr)
  {
* Unmerged path net/ipv6/addrconf.c
