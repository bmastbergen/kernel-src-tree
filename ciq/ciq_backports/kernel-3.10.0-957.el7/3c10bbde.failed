watchdog: core: Clear WDOG_HW_RUNNING before calling the stop function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [watchdog] core: Clear WDOG_HW_RUNNING before calling the stop function (David Arcari) [1576173]
Rebuild_FUZZ: 92.31%
commit-author Guenter Roeck <linux@roeck-us.net>
commit 3c10bbde10fe4dca52726e246cefa6b0a1dfbd3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3c10bbde.failed

WDOG_HW_RUNNING indicates that the hardware watchdog is running while the
watchdog device is closed. The flag may be set by the driver when it is
instantiated to indicate that the watchdog is running, and that the
watchdog core needs to send heartbeat requests to the driver until the
watchdog device is opened.

When the watchdog device is closed, the flag can be used by the driver's
stop function to indicate to the watchdog core that it was unable to stop
the watchdog, and that the watchdog core needs to send heartbeat requests.
This only works if the flag is actually cleared when the watchdog is
stopped. To avoid having to clear the flag in each driver's stop function,
clear it in the watchdog core before calling the stop function.

	Reported-by: Rasmus Villemoes <rasmus.villemoes@prevas.dk>
Fixes: ee142889e32f ("watchdog: Introduce WDOG_HW_RUNNING flag")
	Signed-off-by: Guenter Roeck <linux@roeck-us.net>
	Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
(cherry picked from commit 3c10bbde10fe4dca52726e246cefa6b0a1dfbd3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/watchdog/watchdog_dev.c
diff --cc drivers/watchdog/watchdog_dev.c
index f06fbcf0bea2,040bf8382f46..000000000000
--- a/drivers/watchdog/watchdog_dev.c
+++ b/drivers/watchdog/watchdog_dev.c
@@@ -129,28 -258,27 +129,39 @@@ static int watchdog_stop(struct watchdo
  {
  	int err = 0;
  
 +	mutex_lock(&wdd->lock);
 +
 +	if (test_bit(WDOG_UNREGISTERED, &wdd->status)) {
 +		err = -ENODEV;
 +		goto out_stop;
 +	}
 +
  	if (!watchdog_active(wdd))
 -		return 0;
 +		goto out_stop;
  
  	if (test_bit(WDOG_NO_WAY_OUT, &wdd->status)) {
 -		pr_info("watchdog%d: nowayout prevents watchdog being stopped!\n",
 -			wdd->id);
 -		return -EBUSY;
 +		dev_info(wdd->dev, "nowayout prevents watchdog being stopped!\n");
 +		err = -EBUSY;
 +		goto out_stop;
  	}
  
++<<<<<<< HEAD
 +	err = wdd->ops->stop(wdd);
 +	if (err == 0)
++=======
+ 	if (wdd->ops->stop) {
+ 		clear_bit(WDOG_HW_RUNNING, &wdd->status);
+ 		err = wdd->ops->stop(wdd);
+ 	} else {
+ 		set_bit(WDOG_HW_RUNNING, &wdd->status);
+ 	}
+ 
+ 	if (err == 0) {
++>>>>>>> 3c10bbde10fe (watchdog: core: Clear WDOG_HW_RUNNING before calling the stop function)
  		clear_bit(WDOG_ACTIVE, &wdd->status);
 -		watchdog_update_worker(wdd);
 -	}
  
 +out_stop:
 +	mutex_unlock(&wdd->lock);
  	return err;
  }
  
* Unmerged path drivers/watchdog/watchdog_dev.c
