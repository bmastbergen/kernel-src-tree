Input: synaptics - fix device info appearing different on reconnect

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [input] synaptics - fix device info appearing different on reconnect (Benjamin Tissoires) [1554926]
Rebuild_FUZZ: 94.49%
commit-author Anthony Martin <ality@pbrane.org>
commit 3f9db52dc87b003a1732f3e03f7f5fc8701ef4ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3f9db52d.failed

User-modified input settings no longer survive a suspend/resume cycle.
Starting with 4.12, the touchpad is reinitialized on every reconnect
because the hardware appears to be different. This can be reproduced
by running the following as root:

    echo -n reconnect >/sys/devices/platform/i8042/serio1/drvctl

A line like the following will show up in dmesg:

    [30378.295794] psmouse serio1: synaptics: hardware appears to be
                   different: id(149271-149271), model(114865-114865),
                   caps(d047b3-d047b1), ext(b40000-b40000).

Note the single bit difference in caps: bit 1 (SYN_CAP_MULTIFINGER).

This happens because we modify our stored copy of the device info
capabilities when we enable advanced gesture mode but this change is
not reflected in the actual hardware capabilities.

It worked in the past because synaptics_query_hardware used to modify
the stored synaptics_device_info struct instead of filling in a new
one, as it does now.

Fix it by no longer faking the SYN_CAP_MULTIFINGER bit when setting
advanced gesture mode. This necessitated a small refactoring.

Fixes: 6c53694fb222 ("Input: synaptics - split device info into a separate structure")
	Signed-off-by: Anthony Martin <ality@pbrane.org>
	Cc: stable@vger.kernel.org
	Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
(cherry picked from commit 3f9db52dc87b003a1732f3e03f7f5fc8701ef4ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/input/mouse/synaptics.c
diff --cc drivers/input/mouse/synaptics.c
index 5f5887ef5b0a,5af0b7d200bc..000000000000
--- a/drivers/input/mouse/synaptics.c
+++ b/drivers/input/mouse/synaptics.c
@@@ -451,44 -535,25 +451,63 @@@ static void synaptics_apply_quirks(stru
  	}
  }
  
++<<<<<<< HEAD
 +static int synaptics_query_hardware(struct psmouse *psmouse)
 +{
 +	if (synaptics_identify(psmouse))
 +		return -1;
 +	if (synaptics_model_id(psmouse))
 +		return -1;
 +	if (synaptics_firmware_id(psmouse))
 +		return -1;
 +	if (synaptics_query_modes(psmouse))
 +		return -1;
 +	if (synaptics_capability(psmouse))
 +		return -1;
 +	if (synaptics_resolution(psmouse))
 +		return -1;
 +
 +	synaptics_apply_quirks(psmouse);
 +
 +	return 0;
++=======
+ static bool synaptics_has_agm(struct synaptics_data *priv)
+ {
+ 	return (SYN_CAP_ADV_GESTURE(priv->info.ext_cap_0c) ||
+ 		SYN_CAP_IMAGE_SENSOR(priv->info.ext_cap_0c));
++>>>>>>> 3f9db52dc87b (Input: synaptics - fix device info appearing different on reconnect)
  }
  
  static int synaptics_set_advanced_gesture_mode(struct psmouse *psmouse)
  {
++<<<<<<< HEAD
 +	static unsigned char param = 0xc8;
 +	struct synaptics_data *priv = psmouse->private;
 +
 +	if (!(SYN_CAP_ADV_GESTURE(priv->ext_cap_0c) ||
 +	      SYN_CAP_IMAGE_SENSOR(priv->ext_cap_0c)))
 +		return 0;
 +
 +	if (psmouse_sliced_command(psmouse, SYN_QUE_MODEL))
 +		return -1;
++=======
+ 	static u8 param = 0xc8;
+ 	int error;
+ 
+ 	error = psmouse_sliced_command(psmouse, SYN_QUE_MODEL);
+ 	if (error)
+ 		return error;
++>>>>>>> 3f9db52dc87b (Input: synaptics - fix device info appearing different on reconnect)
  
 -	error = ps2_command(&psmouse->ps2dev, &param, PSMOUSE_CMD_SETRATE);
 -	if (error)
 -		return error;
 +	if (ps2_command(&psmouse->ps2dev, &param, PSMOUSE_CMD_SETRATE))
 +		return -1;
  
++<<<<<<< HEAD
 +	/* Advanced gesture mode also sends multi finger data */
 +	priv->capabilities |= BIT(1);
 +
++=======
++>>>>>>> 3f9db52dc87b (Input: synaptics - fix device info appearing different on reconnect)
  	return 0;
  }
  
@@@ -503,16 -569,21 +522,27 @@@ static int synaptics_set_mode(struct ps
  		priv->mode |= SYN_BIT_DISABLE_GESTURE;
  	if (psmouse->rate >= 80)
  		priv->mode |= SYN_BIT_HIGH_RATE;
 -	if (SYN_CAP_EXTENDED(priv->info.capabilities))
 +	if (SYN_CAP_EXTENDED(priv->capabilities))
  		priv->mode |= SYN_BIT_W_MODE;
  
 -	error = synaptics_mode_cmd(psmouse, priv->mode);
 -	if (error)
 -		return error;
 -
 +	if (synaptics_mode_cmd(psmouse, priv->mode))
 +		return -1;
 +
++<<<<<<< HEAD
 +	if (priv->absolute_mode &&
 +	    synaptics_set_advanced_gesture_mode(psmouse)) {
 +		psmouse_err(psmouse, "Advanced gesture mode init failed.\n");
 +		return -1;
++=======
+ 	if (priv->absolute_mode && synaptics_has_agm(priv)) {
+ 		error = synaptics_set_advanced_gesture_mode(psmouse);
+ 		if (error) {
+ 			psmouse_err(psmouse,
+ 				    "Advanced gesture mode init failed: %d\n",
+ 				    error);
+ 			return error;
+ 		}
++>>>>>>> 3f9db52dc87b (Input: synaptics - fix device info appearing different on reconnect)
  	}
  
  	return 0;
@@@ -700,6 -764,19 +730,7 @@@ static int synaptics_parse_hw_state(con
  			 ((buf[0] & 0x04) >> 1) |
  			 ((buf[3] & 0x04) >> 2));
  
 -		if (synaptics_has_agm(priv) && hw->w == 2) {
 -			synaptics_parse_agm(buf, priv, hw);
 -			return 1;
 -		}
 -
 -		hw->x = (((buf[3] & 0x10) << 8) |
 -			 ((buf[1] & 0x0f) << 8) |
 -			 buf[4]);
 -		hw->y = (((buf[3] & 0x20) << 7) |
 -			 ((buf[1] & 0xf0) << 4) |
 -			 buf[5]);
 -		hw->z = buf[2];
 -
++<<<<<<< HEAD
  		hw->left  = (buf[0] & 0x01) ? 1 : 0;
  		hw->right = (buf[0] & 0x02) ? 1 : 0;
  
@@@ -722,22 -835,7 +753,25 @@@
  			hw->down = ((buf[0] ^ buf[3]) & 0x02) ? 1 : 0;
  		}
  
 -		if (SYN_CAP_MULTI_BUTTON_NO(priv->info.ext_cap) > 0 &&
 +		if ((SYN_CAP_ADV_GESTURE(priv->ext_cap_0c) ||
 +			SYN_CAP_IMAGE_SENSOR(priv->ext_cap_0c)) &&
 +		    hw->w == 2) {
++=======
++		if (synaptics_has_agm(priv) && hw->w == 2) {
++>>>>>>> 3f9db52dc87b (Input: synaptics - fix device info appearing different on reconnect)
 +			synaptics_parse_agm(buf, priv, hw);
 +			return 1;
 +		}
 +
 +		hw->x = (((buf[3] & 0x10) << 8) |
 +			 ((buf[1] & 0x0f) << 8) |
 +			 buf[4]);
 +		hw->y = (((buf[3] & 0x20) << 7) |
 +			 ((buf[1] & 0xf0) << 4) |
 +			 buf[5]);
 +		hw->z = buf[2];
 +
 +		if (SYN_CAP_MULTI_BUTTON_NO(priv->ext_cap) > 0 &&
  		    ((buf[0] ^ buf[3]) & 0x02)) {
  			synaptics_parse_ext_buttons(buf, priv, hw);
  		}
@@@ -1233,24 -1015,29 +1267,33 @@@ static void synaptics_image_sensor_proc
  	 * Update mt_state using the new finger count and current mt_state.
  	 */
  	if (sgm->z == 0)
 -		num_fingers = 0;
 +		synaptics_image_sensor_0f(priv, &mt_state);
  	else if (sgm->w >= 4)
 -		num_fingers = 1;
 +		synaptics_image_sensor_1f(priv, &mt_state);
  	else if (sgm->w == 0)
 -		num_fingers = 2;
 -	else if (sgm->w == 1)
 -		num_fingers = priv->agm_count ? priv->agm_count : 3;
 +		synaptics_image_sensor_2f(priv, &mt_state);
 +	else if (sgm->w == 1 && mt_state.count <= 3)
 +		synaptics_image_sensor_3f(priv, &mt_state);
  	else
 -		num_fingers = 4;
 +		synaptics_image_sensor_45f(priv, &mt_state);
  
  	/* Send resulting input events to user space */
 -	synaptics_report_mt_data(psmouse, sgm, num_fingers);
 +	synaptics_report_mt_data(psmouse, &mt_state, sgm);
 +
 +	/* Store updated mt_state */
 +	priv->mt_state = agm->mt_state = mt_state;
 +	priv->agm_pending = false;
  }
  
+ static bool synaptics_has_multifinger(struct synaptics_data *priv)
+ {
+ 	if (SYN_CAP_MULTIFINGER(priv->info.capabilities))
+ 		return true;
+ 
+ 	/* Advanced gesture mode also sends multi finger data */
+ 	return synaptics_has_agm(priv);
+ }
+ 
  /*
   *  called for each full received packet from the touchpad
   */
@@@ -1293,10 -1081,10 +1336,14 @@@ static void synaptics_process_packet(st
  	if (hw.z > 0 && hw.x > 1) {
  		num_fingers = 1;
  		finger_width = 5;
 -		if (SYN_CAP_EXTENDED(info->capabilities)) {
 +		if (SYN_CAP_EXTENDED(priv->capabilities)) {
  			switch (hw.w) {
  			case 0 ... 1:
++<<<<<<< HEAD
 +				if (SYN_CAP_MULTIFINGER(priv->capabilities))
++=======
+ 				if (synaptics_has_multifinger(priv))
++>>>>>>> 3f9db52dc87b (Input: synaptics - fix device info appearing different on reconnect)
  					num_fingers = hw.w + 2;
  				break;
  			case 2:
@@@ -1335,7 -1128,7 +1382,11 @@@
  		input_report_abs(dev, ABS_TOOL_WIDTH, finger_width);
  
  	input_report_key(dev, BTN_TOOL_FINGER, num_fingers == 1);
++<<<<<<< HEAD
 +	if (SYN_CAP_MULTIFINGER(priv->capabilities)) {
++=======
+ 	if (synaptics_has_multifinger(priv)) {
++>>>>>>> 3f9db52dc87b (Input: synaptics - fix device info appearing different on reconnect)
  		input_report_key(dev, BTN_TOOL_DOUBLETAP, num_fingers == 2);
  		input_report_key(dev, BTN_TOOL_TRIPLETAP, num_fingers == 3);
  	}
@@@ -1484,7 -1288,7 +1535,11 @@@ static void set_input_params(struct psm
  	__set_bit(BTN_TOUCH, dev->keybit);
  	__set_bit(BTN_TOOL_FINGER, dev->keybit);
  
++<<<<<<< HEAD
 +	if (SYN_CAP_MULTIFINGER(priv->capabilities)) {
++=======
+ 	if (synaptics_has_multifinger(priv)) {
++>>>>>>> 3f9db52dc87b (Input: synaptics - fix device info appearing different on reconnect)
  		__set_bit(BTN_TOOL_DOUBLETAP, dev->keybit);
  		__set_bit(BTN_TOOL_TRIPLETAP, dev->keybit);
  	}
* Unmerged path drivers/input/mouse/synaptics.c
