netfilter: ipset: Count non-static extension memory for userspace

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 9e41f26a505cca04b7122e65053cf6447007ea79
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9e41f26a.failed

Non-static (i.e. comment) extension was not counted into the memory
size. A new internal counter is introduced for this. In the case of
the hash types the sizes of the arrays are counted there as well so
that we can avoid to scan the whole set when just the header data
is requested.

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 9e41f26a505cca04b7122e65053cf6447007ea79)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/ipset/ip_set.h
#	include/linux/netfilter/ipset/ip_set_comment.h
#	net/netfilter/ipset/ip_set_bitmap_gen.h
#	net/netfilter/ipset/ip_set_core.c
#	net/netfilter/ipset/ip_set_hash_gen.h
#	net/netfilter/ipset/ip_set_list_set.c
diff --cc include/linux/netfilter/ipset/ip_set.h
index 3e9c90cf5227,8e42253e5d4d..000000000000
--- a/include/linux/netfilter/ipset/ip_set.h
+++ b/include/linux/netfilter/ipset/ip_set.h
@@@ -68,9 -77,50 +68,49 @@@ enum ip_set_ext_id 
  	IPSET_EXT_ID_MAX,
  };
  
++<<<<<<< HEAD
++=======
+ struct ip_set;
+ 
+ /* Extension type */
+ struct ip_set_ext_type {
+ 	/* Destroy extension private data (can be NULL) */
+ 	void (*destroy)(struct ip_set *set, void *ext);
+ 	enum ip_set_extension type;
+ 	enum ipset_cadt_flags flag;
+ 	/* Size and minimal alignment */
+ 	u8 len;
+ 	u8 align;
+ };
+ 
+ extern const struct ip_set_ext_type ip_set_extensions[];
+ 
+ struct ip_set_counter {
+ 	atomic64_t bytes;
+ 	atomic64_t packets;
+ };
+ 
+ struct ip_set_comment_rcu {
+ 	struct rcu_head rcu;
+ 	char str[0];
+ };
+ 
+ struct ip_set_comment {
+ 	struct ip_set_comment_rcu __rcu *c;
+ };
+ 
+ struct ip_set_skbinfo {
+ 	u32 skbmark;
+ 	u32 skbmarkmask;
+ 	u32 skbprio;
+ 	u16 skbqueue;
+ 	u16 __pad;
+ };
+ 
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  struct ip_set_ext {
 -	struct ip_set_skbinfo skbinfo;
  	u64 packets;
  	u64 bytes;
 -	char *comment;
  	u32 timeout;
  };
  
@@@ -186,76 -248,66 +226,136 @@@ struct ip_set 
  	u8 revision;
  	/* Extensions */
  	u8 extensions;
++<<<<<<< HEAD
++=======
+ 	/* Create flags */
+ 	u8 flags;
+ 	/* Default timeout value, if enabled */
+ 	u32 timeout;
+ 	/* Number of elements (vs timeout) */
+ 	u32 elements;
+ 	/* Size of the dynamic extensions (vs timeout) */
+ 	size_t ext_size;
+ 	/* Element data size */
+ 	size_t dsize;
+ 	/* Offsets to extensions in elements */
+ 	size_t offset[IPSET_EXT_ID_MAX];
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  	/* The type specific data */
  	void *data;
  };
  
++<<<<<<< HEAD
 +struct ip_set_counter {
 +	atomic64_t bytes;
 +	atomic64_t packets;
++=======
+ static inline void
+ ip_set_ext_destroy(struct ip_set *set, void *data)
+ {
+ 	/* Check that the extension is enabled for the set and
+ 	 * call it's destroy function for its extension part in data.
+ 	 */
+ 	if (SET_WITH_COMMENT(set))
+ 		ip_set_extensions[IPSET_EXT_ID_COMMENT].destroy(
+ 			set, ext_comment(data, set));
+ }
+ 
+ static inline int
+ ip_set_put_flags(struct sk_buff *skb, struct ip_set *set)
+ {
+ 	u32 cadt_flags = 0;
+ 
+ 	if (SET_WITH_TIMEOUT(set))
+ 		if (unlikely(nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
+ 					   htonl(set->timeout))))
+ 			return -EMSGSIZE;
+ 	if (SET_WITH_COUNTER(set))
+ 		cadt_flags |= IPSET_FLAG_WITH_COUNTERS;
+ 	if (SET_WITH_COMMENT(set))
+ 		cadt_flags |= IPSET_FLAG_WITH_COMMENT;
+ 	if (SET_WITH_SKBINFO(set))
+ 		cadt_flags |= IPSET_FLAG_WITH_SKBINFO;
+ 	if (SET_WITH_FORCEADD(set))
+ 		cadt_flags |= IPSET_FLAG_WITH_FORCEADD;
+ 
+ 	if (!cadt_flags)
+ 		return 0;
+ 	return nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(cadt_flags));
+ }
+ 
+ /* Netlink CB args */
+ enum {
+ 	IPSET_CB_NET = 0,	/* net namespace */
+ 	IPSET_CB_DUMP,		/* dump single set/all sets */
+ 	IPSET_CB_INDEX,		/* set index */
+ 	IPSET_CB_PRIVATE,	/* set private data */
+ 	IPSET_CB_ARG0,		/* type specific */
+ 	IPSET_CB_ARG1,
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  };
  
 +static inline void
 +ip_set_add_bytes(u64 bytes, struct ip_set_counter *counter)
 +{
 +	atomic64_add((long long)bytes, &(counter)->bytes);
 +}
 +
 +static inline void
 +ip_set_add_packets(u64 packets, struct ip_set_counter *counter)
 +{
 +	atomic64_add((long long)packets, &(counter)->packets);
 +}
 +
 +static inline u64
 +ip_set_get_bytes(const struct ip_set_counter *counter)
 +{
 +	return (u64)atomic64_read(&(counter)->bytes);
 +}
 +
 +static inline u64
 +ip_set_get_packets(const struct ip_set_counter *counter)
 +{
 +	return (u64)atomic64_read(&(counter)->packets);
 +}
 +
 +static inline void
 +ip_set_update_counter(struct ip_set_counter *counter,
 +		      const struct ip_set_ext *ext,
 +		      struct ip_set_ext *mext, u32 flags)
 +{
 +	if (ext->packets != ULLONG_MAX &&
 +	    !(flags & IPSET_FLAG_SKIP_COUNTER_UPDATE)) {
 +		ip_set_add_bytes(ext->bytes, counter);
 +		ip_set_add_packets(ext->packets, counter);
 +	}
 +	if (flags & IPSET_FLAG_MATCH_COUNTERS) {
 +		mext->packets = ip_set_get_packets(counter);
 +		mext->bytes = ip_set_get_bytes(counter);
 +	}
 +}
 +
 +static inline bool
 +ip_set_put_counter(struct sk_buff *skb, struct ip_set_counter *counter)
 +{
 +	return nla_put_net64(skb, IPSET_ATTR_BYTES,
 +			     cpu_to_be64(ip_set_get_bytes(counter)),
 +			     IPSET_ATTR_PAD) ||
 +	       nla_put_net64(skb, IPSET_ATTR_PACKETS,
 +			     cpu_to_be64(ip_set_get_packets(counter)),
 +			     IPSET_ATTR_PAD);
 +}
 +
 +static inline void
 +ip_set_init_counter(struct ip_set_counter *counter,
 +		    const struct ip_set_ext *ext)
 +{
 +	if (ext->bytes != ULLONG_MAX)
 +		atomic64_set(&(counter)->bytes, (long long)(ext->bytes));
 +	if (ext->packets != ULLONG_MAX)
 +		atomic64_set(&(counter)->packets, (long long)(ext->packets));
 +}
 +
  /* register and unregister set references */
  extern ip_set_id_t ip_set_get_byname(struct net *net,
  				     const char *name, struct ip_set **set);
diff --cc net/netfilter/ipset/ip_set_bitmap_gen.h
index 01a340ce9e94,f8ea26cafa30..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_gen.h
+++ b/net/netfilter/ipset/ip_set_bitmap_gen.h
@@@ -71,7 -80,19 +71,20 @@@ mtype_flush(struct ip_set *set
  {
  	struct mtype *map = set->data;
  
 -	if (set->extensions & IPSET_EXT_DESTROY)
 -		mtype_ext_cleanup(set);
  	memset(map->members, 0, map->memsize);
++<<<<<<< HEAD
++=======
+ 	set->elements = 0;
+ 	set->ext_size = 0;
+ }
+ 
+ /* Calculate the actual memory size of the set data */
+ static size_t
+ mtype_memsize(const struct mtype *map, size_t dsize)
+ {
+ 	return sizeof(*map) + map->memsize +
+ 	       map->elements * dsize;
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  }
  
  static int
@@@ -79,6 -100,7 +92,10 @@@ mtype_head(struct ip_set *set, struct s
  {
  	const struct mtype *map = set->data;
  	struct nlattr *nested;
++<<<<<<< HEAD
++=======
+ 	size_t memsize = mtype_memsize(map, set->dsize) + set->ext_size;
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  
  	nested = ipset_nest_start(skb, IPSET_ATTR_DATA);
  	if (!nested)
@@@ -146,7 -172,16 +163,20 @@@ mtype_add(struct ip_set *set, void *val
  #endif
  
  	if (SET_WITH_COUNTER(set))
++<<<<<<< HEAD
 +		ip_set_init_counter(ext_counter(x, map), ext);
++=======
+ 		ip_set_init_counter(ext_counter(x, set), ext);
+ 	if (SET_WITH_COMMENT(set))
+ 		ip_set_init_comment(set, ext_comment(x, set), ext);
+ 	if (SET_WITH_SKBINFO(set))
+ 		ip_set_init_skbinfo(ext_skbinfo(x, set), ext);
+ 
+ 	/* Activate element */
+ 	set_bit(e->id, map->members);
+ 	set->elements++;
+ 
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  	return 0;
  }
  
diff --cc net/netfilter/ipset/ip_set_core.c
index 1b9673fde81c,23345d2d136a..000000000000
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@@ -324,6 -324,70 +324,73 @@@ ip_set_get_ipaddr6(struct nlattr *nla, 
  }
  EXPORT_SYMBOL_GPL(ip_set_get_ipaddr6);
  
++<<<<<<< HEAD
++=======
+ typedef void (*destroyer)(struct ip_set *, void *);
+ /* ipset data extension types, in size order */
+ 
+ const struct ip_set_ext_type ip_set_extensions[] = {
+ 	[IPSET_EXT_ID_COUNTER] = {
+ 		.type	= IPSET_EXT_COUNTER,
+ 		.flag	= IPSET_FLAG_WITH_COUNTERS,
+ 		.len	= sizeof(struct ip_set_counter),
+ 		.align	= __alignof__(struct ip_set_counter),
+ 	},
+ 	[IPSET_EXT_ID_TIMEOUT] = {
+ 		.type	= IPSET_EXT_TIMEOUT,
+ 		.len	= sizeof(unsigned long),
+ 		.align	= __alignof__(unsigned long),
+ 	},
+ 	[IPSET_EXT_ID_SKBINFO] = {
+ 		.type	= IPSET_EXT_SKBINFO,
+ 		.flag	= IPSET_FLAG_WITH_SKBINFO,
+ 		.len	= sizeof(struct ip_set_skbinfo),
+ 		.align	= __alignof__(struct ip_set_skbinfo),
+ 	},
+ 	[IPSET_EXT_ID_COMMENT] = {
+ 		.type	 = IPSET_EXT_COMMENT | IPSET_EXT_DESTROY,
+ 		.flag	 = IPSET_FLAG_WITH_COMMENT,
+ 		.len	 = sizeof(struct ip_set_comment),
+ 		.align	 = __alignof__(struct ip_set_comment),
+ 		.destroy = (destroyer) ip_set_comment_free,
+ 	},
+ };
+ EXPORT_SYMBOL_GPL(ip_set_extensions);
+ 
+ static inline bool
+ add_extension(enum ip_set_ext_id id, u32 flags, struct nlattr *tb[])
+ {
+ 	return ip_set_extensions[id].flag ?
+ 		(flags & ip_set_extensions[id].flag) :
+ 		!!tb[IPSET_ATTR_TIMEOUT];
+ }
+ 
+ size_t
+ ip_set_elem_len(struct ip_set *set, struct nlattr *tb[], size_t len,
+ 		size_t align)
+ {
+ 	enum ip_set_ext_id id;
+ 	u32 cadt_flags = 0;
+ 
+ 	if (tb[IPSET_ATTR_CADT_FLAGS])
+ 		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
+ 	if (cadt_flags & IPSET_FLAG_WITH_FORCEADD)
+ 		set->flags |= IPSET_CREATE_FLAG_FORCEADD;
+ 	if (!align)
+ 		align = 1;
+ 	for (id = 0; id < IPSET_EXT_ID_MAX; id++) {
+ 		if (!add_extension(id, cadt_flags, tb))
+ 			continue;
+ 		len = ALIGN(len, ip_set_extensions[id].align);
+ 		set->offset[id] = len;
+ 		set->extensions |= ip_set_extensions[id].type;
+ 		len += ip_set_extensions[id].len;
+ 	}
+ 	return ALIGN(len, align);
+ }
+ EXPORT_SYMBOL_GPL(ip_set_elem_len);
+ 
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  int
  ip_set_get_extensions(struct ip_set *set, struct nlattr *tb[],
  		      struct ip_set_ext *ext)
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 9ce28af662bf,0746405a1d14..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -345,21 -342,30 +345,32 @@@ mtype_del_cidr(struct htype *h, u8 cidr
  
  /* Calculate the actual memory size of the set data */
  static size_t
++<<<<<<< HEAD
 +mtype_ahash_memsize(const struct htype *h, u8 nets_length)
 +{
 +	u32 i;
 +	struct htable *t = h->table;
 +	size_t memsize = sizeof(*h)
 +			 + sizeof(*t)
++=======
+ mtype_ahash_memsize(const struct htype *h, const struct htable *t,
+ 		    u8 nets_length)
+ {
+ 	size_t memsize = sizeof(*h) + sizeof(*t);
+ 
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  #ifdef IP_SET_HASH_WITH_NETS
 -	memsize += sizeof(struct net_prefixes) * nets_length;
 +			 + sizeof(struct net_prefixes) * nets_length
  #endif
++<<<<<<< HEAD
 +			 + jhash_size(t->htable_bits) * sizeof(struct hbucket);
  
 -	return memsize;
 -}
 -
 -/* Get the ith element from the array block n */
 -#define ahash_data(n, i, dsize)	\
 -	((struct mtype_elem *)((n)->value + ((i) * (dsize))))
 -
 -static void
 -mtype_ext_cleanup(struct ip_set *set, struct hbucket *n)
 -{
 -	int i;
 +	for (i = 0; i < jhash_size(t->htable_bits); i++)
 +		memsize += t->bucket[i].size * h->dsize;
++=======
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  
 -	for (i = 0; i < n->pos; i++)
 -		if (test_bit(i, n->used))
 -			ip_set_ext_destroy(set, ahash_data(n, i, set->dsize));
 +	return memsize;
  }
  
  /* Flush a hash type of set: destroy all elements */
@@@ -371,19 -377,42 +382,44 @@@ mtype_flush(struct ip_set *set
  	struct hbucket *n;
  	u32 i;
  
 -	t = ipset_dereference_protected(h->table, set);
  	for (i = 0; i < jhash_size(t->htable_bits); i++) {
 -		n = __ipset_dereference_protected(hbucket(t, i), 1);
 -		if (!n)
 -			continue;
 -		if (set->extensions & IPSET_EXT_DESTROY)
 -			mtype_ext_cleanup(set, n);
 -		/* FIXME: use slab cache */
 -		rcu_assign_pointer(hbucket(t, i), NULL);
 -		kfree_rcu(n, rcu);
 +		n = hbucket(t, i);
 +		if (n->size) {
 +			n->size = n->pos = 0;
 +			/* FIXME: use slab cache */
 +			kfree(n->value);
 +		}
  	}
  #ifdef IP_SET_HASH_WITH_NETS
 -	memset(h->nets, 0, sizeof(struct net_prefixes) * NLEN(set->family));
 +	memset(h->nets, 0, sizeof(struct net_prefixes)
 +			   * NETS_LENGTH(set->family));
  #endif
++<<<<<<< HEAD
 +	h->elements = 0;
++=======
+ 	set->elements = 0;
+ 	set->ext_size = 0;
+ }
+ 
+ /* Destroy the hashtable part of the set */
+ static void
+ mtype_ahash_destroy(struct ip_set *set, struct htable *t, bool ext_destroy)
+ {
+ 	struct hbucket *n;
+ 	u32 i;
+ 
+ 	for (i = 0; i < jhash_size(t->htable_bits); i++) {
+ 		n = __ipset_dereference_protected(hbucket(t, i), 1);
+ 		if (!n)
+ 			continue;
+ 		if (set->extensions & IPSET_EXT_DESTROY && ext_destroy)
+ 			mtype_ext_cleanup(set, n);
+ 		/* FIXME: use slab cache */
+ 		kfree(n);
+ 	}
+ 
+ 	ip_set_free(t);
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  }
  
  /* Destroy a hash type of set */
@@@ -473,10 -514,19 +509,26 @@@ mtype_expire(struct htype *h, u8 nets_l
  			if (!tmp)
  				/* Still try to delete expired elements */
  				continue;
++<<<<<<< HEAD
 +			n->size -= AHASH_INIT_SIZE;
 +			memcpy(tmp, n->value, n->size * dsize);
 +			kfree(n->value);
 +			n->value = tmp;
++=======
+ 			tmp->size = n->size - AHASH_INIT_SIZE;
+ 			for (j = 0, d = 0; j < n->pos; j++) {
+ 				if (!test_bit(j, n->used))
+ 					continue;
+ 				data = ahash_data(n, j, dsize);
+ 				memcpy(tmp->value + d * dsize, data, dsize);
+ 				set_bit(d, tmp->used);
+ 				d++;
+ 			}
+ 			tmp->pos = d;
+ 			set->ext_size -= AHASH_INIT_SIZE * dsize;
+ 			rcu_assign_pointer(hbucket(t, i), tmp);
+ 			kfree_rcu(n, rcu);
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  		}
  	}
  }
@@@ -503,10 -554,12 +555,16 @@@ static in
  mtype_resize(struct ip_set *set, bool retried)
  {
  	struct htype *h = set->data;
++<<<<<<< HEAD
 +	struct htable *t, *orig = h->table;
 +	u8 htable_bits = orig->htable_bits;
++=======
+ 	struct htable *t, *orig;
+ 	u8 htable_bits;
+ 	size_t extsize, dsize = set->dsize;
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  #ifdef IP_SET_HASH_WITH_NETS
  	u8 flags;
 -	struct mtype_elem *tmp;
  #endif
  	struct mtype_elem *data;
  	struct mtype_elem *d;
@@@ -528,51 -580,93 +586,117 @@@
  retry:
  	ret = 0;
  	htable_bits++;
++<<<<<<< HEAD
++=======
+ 	if (!htable_bits) {
+ 		/* In case we have plenty of memory :-) */
+ 		pr_warn("Cannot increase the hashsize of set %s further\n",
+ 			set->name);
+ 		ret = -IPSET_ERR_HASH_FULL;
+ 		goto out;
+ 	}
+ 	t = ip_set_alloc(htable_size(htable_bits));
+ 	if (!t) {
+ 		ret = -ENOMEM;
+ 		goto out;
+ 	}
+ 	t->htable_bits = htable_bits;
+ 
+ 	spin_lock_bh(&set->lock);
+ 	orig = __ipset_dereference_protected(h->table, 1);
+ 	/* There can't be another parallel resizing, but dumping is possible */
+ 	atomic_set(&orig->ref, 1);
+ 	atomic_inc(&orig->uref);
+ 	extsize = 0;
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  	pr_debug("attempt to resize set %s from %u to %u, t %p\n",
  		 set->name, orig->htable_bits, htable_bits, orig);
 +	if (!htable_bits) {
 +		/* In case we have plenty of memory :-) */
 +		pr_warning("Cannot increase the hashsize of set %s further\n",
 +			   set->name);
 +		return -IPSET_ERR_HASH_FULL;
 +	}
 +	t = ip_set_alloc(sizeof(*t)
 +			 + jhash_size(htable_bits) * sizeof(struct hbucket));
 +	if (!t)
 +		return -ENOMEM;
 +	t->htable_bits = htable_bits;
 +
 +	read_lock_bh(&set->lock);
  	for (i = 0; i < jhash_size(orig->htable_bits); i++) {
 -		n = __ipset_dereference_protected(hbucket(orig, i), 1);
 -		if (!n)
 -			continue;
 +		n = hbucket(orig, i);
  		for (j = 0; j < n->pos; j++) {
 -			if (!test_bit(j, n->used))
 -				continue;
 -			data = ahash_data(n, j, dsize);
 +			data = ahash_data(n, j, h->dsize);
  #ifdef IP_SET_HASH_WITH_NETS
 -			/* We have readers running parallel with us,
 -			 * so the live data cannot be modified.
 -			 */
  			flags = 0;
 -			memcpy(tmp, data, dsize);
 -			data = tmp;
  			mtype_data_reset_flags(data, &flags);
  #endif
++<<<<<<< HEAD
 +			m = hbucket(t, HKEY(data, h->initval, htable_bits));
 +			ret = hbucket_elem_add(m, AHASH_MAX(h), h->dsize);
 +			if (ret < 0) {
 +#ifdef IP_SET_HASH_WITH_NETS
 +				mtype_data_reset_flags(data, &flags);
 +#endif
 +				read_unlock_bh(&set->lock);
 +				ahash_destroy(t);
 +				if (ret == -EAGAIN)
 +					goto retry;
 +				return ret;
++=======
+ 			key = HKEY(data, h->initval, htable_bits);
+ 			m = __ipset_dereference_protected(hbucket(t, key), 1);
+ 			if (!m) {
+ 				m = kzalloc(sizeof(*m) +
+ 					    AHASH_INIT_SIZE * dsize,
+ 					    GFP_ATOMIC);
+ 				if (!m) {
+ 					ret = -ENOMEM;
+ 					goto cleanup;
+ 				}
+ 				m->size = AHASH_INIT_SIZE;
+ 				extsize = sizeof(*m) + AHASH_INIT_SIZE * dsize;
+ 				RCU_INIT_POINTER(hbucket(t, key), m);
+ 			} else if (m->pos >= m->size) {
+ 				struct hbucket *ht;
+ 
+ 				if (m->size >= AHASH_MAX(h)) {
+ 					ret = -EAGAIN;
+ 				} else {
+ 					ht = kzalloc(sizeof(*ht) +
+ 						(m->size + AHASH_INIT_SIZE)
+ 						* dsize,
+ 						GFP_ATOMIC);
+ 					if (!ht)
+ 						ret = -ENOMEM;
+ 				}
+ 				if (ret < 0)
+ 					goto cleanup;
+ 				memcpy(ht, m, sizeof(struct hbucket) +
+ 					      m->size * dsize);
+ 				ht->size = m->size + AHASH_INIT_SIZE;
+ 				extsize += AHASH_INIT_SIZE * dsize;
+ 				kfree(m);
+ 				m = ht;
+ 				RCU_INIT_POINTER(hbucket(t, key), ht);
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  			}
 -			d = ahash_data(m, m->pos, dsize);
 -			memcpy(d, data, dsize);
 -			set_bit(m->pos++, m->used);
 +			d = ahash_data(m, m->pos++, h->dsize);
 +			memcpy(d, data, h->dsize);
  #ifdef IP_SET_HASH_WITH_NETS
  			mtype_data_reset_flags(d, &flags);
  #endif
  		}
  	}
++<<<<<<< HEAD
++=======
+ 	rcu_assign_pointer(h->table, t);
+ 	set->ext_size = extsize;
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  
 -	spin_unlock_bh(&set->lock);
 +	rcu_assign_pointer(h->table, t);
 +	read_unlock_bh(&set->lock);
  
  	/* Give time to other readers of the set */
  	synchronize_rcu_bh();
@@@ -594,29 -706,51 +718,51 @@@ mtype_add(struct ip_set *set, void *val
  	struct htable *t;
  	const struct mtype_elem *d = value;
  	struct mtype_elem *data;
 -	struct hbucket *n, *old = ERR_PTR(-ENOENT);
 -	int i, j = -1;
 +	struct hbucket *n;
 +	int i, ret = 0;
 +	int j = AHASH_MAX(h) + 1;
  	bool flag_exist = flags & IPSET_FLAG_EXIST;
 -	bool deleted = false, forceadd = false, reuse = false;
  	u32 key, multi = 0;
  
 -	if (set->elements >= h->maxelem) {
 -		if (SET_WITH_TIMEOUT(set))
 -			/* FIXME: when set is full, we slow down here */
 -			mtype_expire(set, h, NLEN(set->family), set->dsize);
 -		if (set->elements >= h->maxelem && SET_WITH_FORCEADD(set))
 -			forceadd = true;
 +	if (SET_WITH_TIMEOUT(set) && h->elements >= h->maxelem)
 +		/* FIXME: when set is full, we slow down here */
 +		mtype_expire(h, NETS_LENGTH(set->family), h->dsize);
 +
 +	if (h->elements >= h->maxelem) {
 +		if (net_ratelimit())
 +			pr_warning("Set %s is full, maxelem %u reached\n",
 +				   set->name, h->maxelem);
 +		return -IPSET_ERR_HASH_FULL;
  	}
  
 -	t = ipset_dereference_protected(h->table, set);
 +	rcu_read_lock_bh();
 +	t = rcu_dereference_bh(h->table);
  	key = HKEY(value, h->initval, t->htable_bits);
++<<<<<<< HEAD
 +	n = hbucket(t, key);
++=======
+ 	n = __ipset_dereference_protected(hbucket(t, key), 1);
+ 	if (!n) {
+ 		if (forceadd) {
+ 			if (net_ratelimit())
+ 				pr_warn("Set %s is full, maxelem %u reached\n",
+ 					set->name, h->maxelem);
+ 			return -IPSET_ERR_HASH_FULL;
+ 		} else if (set->elements >= h->maxelem) {
+ 			goto set_full;
+ 		}
+ 		old = NULL;
+ 		n = kzalloc(sizeof(*n) + AHASH_INIT_SIZE * set->dsize,
+ 			    GFP_ATOMIC);
+ 		if (!n)
+ 			return -ENOMEM;
+ 		n->size = AHASH_INIT_SIZE;
+ 		set->ext_size += sizeof(*n) + AHASH_INIT_SIZE * set->dsize;
+ 		goto copy_elem;
+ 	}
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  	for (i = 0; i < n->pos; i++) {
 -		if (!test_bit(i, n->used)) {
 -			/* Reuse first deleted entry */
 -			if (j == -1) {
 -				deleted = reuse = true;
 -				j = i;
 -			}
 -			continue;
 -		}
 -		data = ahash_data(n, i, set->dsize);
 +		data = ahash_data(n, i, h->dsize);
  		if (mtype_data_equal(data, d, &multi)) {
  			if (flag_exist ||
  			    (SET_WITH_TIMEOUT(set) &&
@@@ -631,49 -762,90 +777,79 @@@
  		}
  		/* Reuse first timed out entry */
  		if (SET_WITH_TIMEOUT(set) &&
 -		    ip_set_timeout_expired(ext_timeout(data, set)) &&
 -		    j == -1) {
 +		    ip_set_timeout_expired(ext_timeout(data, h)) &&
 +		    j != AHASH_MAX(h) + 1)
  			j = i;
 -			reuse = true;
 -		}
  	}
 -	if (reuse || forceadd) {
 -		data = ahash_data(n, j, set->dsize);
 -		if (!deleted) {
 +reuse_slot:
 +	if (j != AHASH_MAX(h) + 1) {
 +		/* Fill out reused slot */
 +		data = ahash_data(n, j, h->dsize);
  #ifdef IP_SET_HASH_WITH_NETS
 -			for (i = 0; i < IPSET_NET_COUNT; i++)
 -				mtype_del_cidr(h,
 -					NCIDR_PUT(DCIDR_GET(data->cidr, i)),
 -					NLEN(set->family), i);
 +		mtype_del_cidr(h, CIDR(data->cidr), NETS_LENGTH(set->family));
 +		mtype_add_cidr(h, CIDR(d->cidr), NETS_LENGTH(set->family));
  #endif
 -			ip_set_ext_destroy(set, data);
 -			set->elements--;
 -		}
 -		goto copy_data;
 -	}
 -	if (set->elements >= h->maxelem)
 -		goto set_full;
 -	/* Create a new slot */
 -	if (n->pos >= n->size) {
 +	} else {
 +		/* Use/create a new slot */
  		TUNE_AHASH_MAX(h, multi);
 -		if (n->size >= AHASH_MAX(h)) {
 -			/* Trigger rehashing */
 -			mtype_data_next(&h->next, d);
 -			return -EAGAIN;
 +		ret = hbucket_elem_add(n, AHASH_MAX(h), h->dsize);
 +		if (ret != 0) {
 +			if (ret == -EAGAIN)
 +				mtype_data_next(&h->next, d);
 +			goto out;
  		}
++<<<<<<< HEAD
 +		data = ahash_data(n, n->pos++, h->dsize);
++=======
+ 		old = n;
+ 		n = kzalloc(sizeof(*n) +
+ 			    (old->size + AHASH_INIT_SIZE) * set->dsize,
+ 			    GFP_ATOMIC);
+ 		if (!n)
+ 			return -ENOMEM;
+ 		memcpy(n, old, sizeof(struct hbucket) +
+ 		       old->size * set->dsize);
+ 		n->size = old->size + AHASH_INIT_SIZE;
+ 		set->ext_size += AHASH_INIT_SIZE * set->dsize;
+ 	}
+ 
+ copy_elem:
+ 	j = n->pos++;
+ 	data = ahash_data(n, j, set->dsize);
+ copy_data:
+ 	set->elements++;
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  #ifdef IP_SET_HASH_WITH_NETS
 -	for (i = 0; i < IPSET_NET_COUNT; i++)
 -		mtype_add_cidr(h, NCIDR_PUT(DCIDR_GET(d->cidr, i)),
 -			       NLEN(set->family), i);
 +		mtype_add_cidr(h, CIDR(d->cidr), NETS_LENGTH(set->family));
  #endif
 +		h->elements++;
 +	}
  	memcpy(data, d, sizeof(struct mtype_elem));
 -overwrite_extensions:
  #ifdef IP_SET_HASH_WITH_NETS
  	mtype_data_set_flags(data, flags);
  #endif
++<<<<<<< HEAD
++=======
+ 	if (SET_WITH_COUNTER(set))
+ 		ip_set_init_counter(ext_counter(data, set), ext);
+ 	if (SET_WITH_COMMENT(set))
+ 		ip_set_init_comment(set, ext_comment(data, set), ext);
+ 	if (SET_WITH_SKBINFO(set))
+ 		ip_set_init_skbinfo(ext_skbinfo(data, set), ext);
+ 	/* Must come last for the case when timed out entry is reused */
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  	if (SET_WITH_TIMEOUT(set))
 -		ip_set_timeout_set(ext_timeout(data, set), ext->timeout);
 -	smp_mb__before_atomic();
 -	set_bit(j, n->used);
 -	if (old != ERR_PTR(-ENOENT)) {
 -		rcu_assign_pointer(hbucket(t, key), n);
 -		if (old)
 -			kfree_rcu(old, rcu);
 -	}
 +		ip_set_timeout_set(ext_timeout(data, h), ext->timeout);
 +	if (SET_WITH_COUNTER(set))
 +		ip_set_init_counter(ext_counter(data, h), ext);
  
 -	return 0;
 -set_full:
 -	if (net_ratelimit())
 -		pr_warn("Set %s is full, maxelem %u reached\n",
 -			set->name, h->maxelem);
 -	return -IPSET_ERR_HASH_FULL;
 +out:
 +	rcu_read_unlock_bh();
 +	return ret;
  }
  
 -/* Delete an element from the hash and free up space if possible.
 +/* Delete an element from the hash: swap it with the last element
 + * and free up space if possible.
   */
  static int
  mtype_del(struct ip_set *set, void *value, const struct ip_set_ext *ext,
@@@ -694,33 -874,55 +870,65 @@@
  		if (!mtype_data_equal(data, d, &multi))
  			continue;
  		if (SET_WITH_TIMEOUT(set) &&
 -		    ip_set_timeout_expired(ext_timeout(data, set)))
 -			goto out;
 +		    ip_set_timeout_expired(ext_timeout(data, h)))
 +			return -IPSET_ERR_EXIST;
 +		if (i != n->pos - 1)
 +			/* Not last one */
 +			memcpy(data, ahash_data(n, n->pos - 1, h->dsize),
 +			       h->dsize);
  
 -		ret = 0;
 -		clear_bit(i, n->used);
 -		smp_mb__after_atomic();
 -		if (i + 1 == n->pos)
 -			n->pos--;
 -		set->elements--;
 +		n->pos--;
 +		h->elements--;
  #ifdef IP_SET_HASH_WITH_NETS
 -		for (j = 0; j < IPSET_NET_COUNT; j++)
 -			mtype_del_cidr(h, NCIDR_PUT(DCIDR_GET(d->cidr, j)),
 -				       NLEN(set->family), j);
 +		mtype_del_cidr(h, CIDR(d->cidr), NETS_LENGTH(set->family));
  #endif
++<<<<<<< HEAD
 +		if (n->pos + AHASH_INIT_SIZE < n->size) {
 +			void *tmp = kzalloc((n->size - AHASH_INIT_SIZE)
 +					    * h->dsize,
 +					    GFP_ATOMIC);
 +			if (!tmp)
 +				return 0;
 +			n->size -= AHASH_INIT_SIZE;
 +			memcpy(tmp, n->value, n->size * h->dsize);
 +			kfree(n->value);
 +			n->value = tmp;
++=======
+ 		ip_set_ext_destroy(set, data);
+ 
+ 		for (; i < n->pos; i++) {
+ 			if (!test_bit(i, n->used))
+ 				k++;
+ 		}
+ 		if (n->pos == 0 && k == 0) {
+ 			set->ext_size -= sizeof(*n) + n->size * dsize;
+ 			rcu_assign_pointer(hbucket(t, key), NULL);
+ 			kfree_rcu(n, rcu);
+ 		} else if (k >= AHASH_INIT_SIZE) {
+ 			struct hbucket *tmp = kzalloc(sizeof(*tmp) +
+ 					(n->size - AHASH_INIT_SIZE) * dsize,
+ 					GFP_ATOMIC);
+ 			if (!tmp)
+ 				goto out;
+ 			tmp->size = n->size - AHASH_INIT_SIZE;
+ 			for (j = 0, k = 0; j < n->pos; j++) {
+ 				if (!test_bit(j, n->used))
+ 					continue;
+ 				data = ahash_data(n, j, dsize);
+ 				memcpy(tmp->value + k * dsize, data, dsize);
+ 				set_bit(j, tmp->used);
+ 				k++;
+ 			}
+ 			tmp->pos = k;
+ 			set->ext_size -= AHASH_INIT_SIZE * dsize;
+ 			rcu_assign_pointer(hbucket(t, key), tmp);
+ 			kfree_rcu(n, rcu);
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  		}
 -		goto out;
 +		return 0;
  	}
  
 -out:
 -	return ret;
 +	return -IPSET_ERR_EXIST;
  }
  
  static inline int
@@@ -814,12 -1056,16 +1022,20 @@@ static in
  mtype_head(struct ip_set *set, struct sk_buff *skb)
  {
  	const struct htype *h = set->data;
 -	const struct htable *t;
  	struct nlattr *nested;
  	size_t memsize;
 -	u8 htable_bits;
  
++<<<<<<< HEAD
 +	read_lock_bh(&set->lock);
 +	memsize = mtype_ahash_memsize(h, NETS_LENGTH(set->family));
 +	read_unlock_bh(&set->lock);
++=======
+ 	rcu_read_lock_bh();
+ 	t = rcu_dereference_bh_nfnl(h->table);
+ 	memsize = mtype_ahash_memsize(h, t, NLEN(set->family)) + set->ext_size;
+ 	htable_bits = t->htable_bits;
+ 	rcu_read_unlock_bh();
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  
  	nested = ipset_nest_start(skb, IPSET_ATTR_DATA);
  	if (!nested)
diff --cc net/netfilter/ipset/ip_set_list_set.c
index a9a97c07ecb4,dede343a662b..000000000000
--- a/net/netfilter/ipset/ip_set_list_set.c
+++ b/net/netfilter/ipset/ip_set_list_set.c
@@@ -289,6 -221,20 +289,23 @@@ list_set_utest(struct ip_set *set, voi
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ list_set_init_extensions(struct ip_set *set, const struct ip_set_ext *ext,
+ 			 struct set_elem *e)
+ {
+ 	if (SET_WITH_COUNTER(set))
+ 		ip_set_init_counter(ext_counter(e, set), ext);
+ 	if (SET_WITH_COMMENT(set))
+ 		ip_set_init_comment(set, ext_comment(e, set), ext);
+ 	if (SET_WITH_SKBINFO(set))
+ 		ip_set_init_skbinfo(ext_skbinfo(e, set), ext);
+ 	/* Update timeout last */
+ 	if (SET_WITH_TIMEOUT(set))
+ 		ip_set_timeout_set(ext_timeout(e, set), ext->timeout);
+ }
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  
  static int
  list_set_uadd(struct ip_set *set, void *value, const struct ip_set_ext *ext,
@@@ -452,16 -417,12 +469,23 @@@ static voi
  list_set_flush(struct ip_set *set)
  {
  	struct list_set *map = set->data;
 -	struct set_elem *e, *n;
 -
 +	struct set_elem *e;
 +	u32 i;
 +
++<<<<<<< HEAD
 +	for (i = 0; i < map->size; i++) {
 +		e = list_set_elem(map, i);
 +		if (e->id != IPSET_INVALID_ID) {
 +			ip_set_put_byindex(map->net, e->id);
 +			e->id = IPSET_INVALID_ID;
 +		}
 +	}
++=======
+ 	list_for_each_entry_safe(e, n, &map->members, list)
+ 		list_set_del(set, e);
+ 	set->elements = 0;
+ 	set->ext_size = 0;
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  }
  
  static void
@@@ -482,6 -468,7 +506,10 @@@ list_set_head(struct ip_set *set, struc
  {
  	const struct list_set *map = set->data;
  	struct nlattr *nested;
++<<<<<<< HEAD
++=======
+ 	size_t memsize = list_set_memsize(map, set->dsize) + set->ext_size;
++>>>>>>> 9e41f26a505c (netfilter: ipset: Count non-static extension memory for userspace)
  
  	nested = ipset_nest_start(skb, IPSET_ATTR_DATA);
  	if (!nested)
* Unmerged path include/linux/netfilter/ipset/ip_set_comment.h
* Unmerged path include/linux/netfilter/ipset/ip_set.h
* Unmerged path include/linux/netfilter/ipset/ip_set_comment.h
* Unmerged path net/netfilter/ipset/ip_set_bitmap_gen.h
* Unmerged path net/netfilter/ipset/ip_set_core.c
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
* Unmerged path net/netfilter/ipset/ip_set_list_set.c
