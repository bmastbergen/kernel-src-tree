ip: discard IPv4 datagrams with overlapping segments.

jira LE-1907
cve CVE-2018-5391
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] ip: discard IPv4 datagrams with overlapping segments (Sabrina Dubroca) [1613924] {CVE-2018-5391}
Rebuild_FUZZ: 99.05%
commit-author Peter Oskolkov <posk@google.com>
commit 7969e5c40dfd04799d4341f1b7cd266b6e47f227
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7969e5c4.failed

This behavior is required in IPv6, and there is little need
to tolerate overlapping fragments in IPv4. This change
simplifies the code and eliminates potential DDoS attack vectors.

Tested: ran ip_defrag selftest (not yet available uptream).

	Suggested-by: David S. Miller <davem@davemloft.net>
	Signed-off-by: Peter Oskolkov <posk@google.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Florian Westphal <fw@strlen.de>
	Acked-by: Stephen Hemminger <stephen@networkplumber.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7969e5c40dfd04799d4341f1b7cd266b6e47f227)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/snmp.h
#	net/ipv4/ip_fragment.c
diff --cc include/uapi/linux/snmp.h
index e6bd1200ca78,f80135e5feaa..000000000000
--- a/include/uapi/linux/snmp.h
+++ b/include/uapi/linux/snmp.h
@@@ -56,7 -56,7 +56,11 @@@ enu
  	IPSTATS_MIB_ECT1PKTS,			/* InECT1Pkts */
  	IPSTATS_MIB_ECT0PKTS,			/* InECT0Pkts */
  	IPSTATS_MIB_CEPKTS,			/* InCEPkts */
++<<<<<<< HEAD
 +#endif
++=======
+ 	IPSTATS_MIB_REASM_OVERLAPS,		/* ReasmOverlaps */
++>>>>>>> 7969e5c40dfd (ip: discard IPv4 datagrams with overlapping segments.)
  	__IPSTATS_MIB_MAX
  };
  
diff --cc net/ipv4/ip_fragment.c
index 5921905304dd,960bf5eab59f..000000000000
--- a/net/ipv4/ip_fragment.c
+++ b/net/ipv4/ip_fragment.c
@@@ -413,62 -358,31 +414,67 @@@ static int ip_frag_queue(struct ipq *qp
  	}
  
  found:
- 	/* We found where to put this one.  Check for overlap with
- 	 * preceding fragment, and, if needed, align things so that
- 	 * any overlaps are eliminated.
+ 	/* RFC5722, Section 4, amended by Errata ID : 3089
+ 	 *                          When reassembling an IPv6 datagram, if
+ 	 *   one or more its constituent fragments is determined to be an
+ 	 *   overlapping fragment, the entire datagram (and any constituent
+ 	 *   fragments) MUST be silently discarded.
+ 	 *
+ 	 * We do the same here for IPv4.
  	 */
++<<<<<<< HEAD
 +	if (prev) {
 +		int i = (FRAG_CB(prev)->offset + prev->len) - offset;
++=======
++>>>>>>> 7969e5c40dfd (ip: discard IPv4 datagrams with overlapping segments.)
  
- 		if (i > 0) {
- 			offset += i;
- 			err = -EINVAL;
- 			if (end <= offset)
- 				goto err;
- 			err = -ENOMEM;
- 			if (!pskb_pull(skb, i))
- 				goto err;
- 			if (skb->ip_summed != CHECKSUM_UNNECESSARY)
- 				skb->ip_summed = CHECKSUM_NONE;
- 		}
- 	}
+ 	/* Is there an overlap with the previous fragment? */
+ 	if (prev &&
+ 	    (prev->ip_defrag_offset + prev->len) > offset)
+ 		goto discard_qp;
  
++<<<<<<< HEAD
 +	err = -ENOMEM;
 +
 +	while (next && FRAG_CB(next)->offset < end) {
 +		int i = end - FRAG_CB(next)->offset; /* overlap is 'i' bytes */
 +
 +		if (i < next->len) {
 +			/* Eat head of the next overlapped fragment
 +			 * and leave the loop. The next ones cannot overlap.
 +			 */
 +			if (!pskb_pull(next, i))
 +				goto err;
 +			FRAG_CB(next)->offset += i;
 +			qp->q.meat -= i;
 +			if (next->ip_summed != CHECKSUM_UNNECESSARY)
 +				next->ip_summed = CHECKSUM_NONE;
 +			break;
 +		} else {
 +			struct sk_buff *free_it = next;
 +
 +			/* Old fragment is completely overridden with
 +			 * new one drop it.
 +			 */
 +			next = next->next;
 +
 +			if (prev)
 +				prev->next = next;
 +			else
 +				qp->q.fragments = next;
 +
 +			qp->q.meat -= free_it->len;
 +			sub_frag_mem_limit(&qp->q, free_it->truesize);
 +			kfree_skb(free_it);
 +		}
 +	}
++=======
+ 	/* Is there an overlap with the next fragment? */
+ 	if (next && next->ip_defrag_offset < end)
+ 		goto discard_qp;
++>>>>>>> 7969e5c40dfd (ip: discard IPv4 datagrams with overlapping segments.)
  
 -	/* Note : skb->ip_defrag_offset and skb->dev share the same location */
 -	dev = skb->dev;
 -	if (dev)
 -		qp->iif = dev->ifindex;
 -	/* Makes sure compiler wont do silly aliasing games */
 -	barrier();
 -	skb->ip_defrag_offset = offset;
 +	FRAG_CB(skb)->offset = offset;
  
  	/* Insert this fragment in the chain of fragments. */
  	skb->next = next;
@@@ -511,9 -420,12 +517,13 @@@
  	}
  
  	skb_dst_drop(skb);
 +	inet_frag_lru_move(&qp->q);
  	return -EINPROGRESS;
  
+ discard_qp:
+ 	inet_frag_kill(&qp->q);
+ 	err = -EINVAL;
+ 	__IP_INC_STATS(net, IPSTATS_MIB_REASM_OVERLAPS);
  err:
  	kfree_skb(skb);
  	return err;
* Unmerged path include/uapi/linux/snmp.h
* Unmerged path net/ipv4/ip_fragment.c
diff --git a/net/ipv4/proc.c b/net/ipv4/proc.c
index 87665bea9c35..acef68ceb4cf 100644
--- a/net/ipv4/proc.c
+++ b/net/ipv4/proc.c
@@ -131,6 +131,7 @@ static const struct snmp_mib snmp4_ipextstats_list[] = {
 	SNMP_MIB_ITEM("InECT1Pkts", IPSTATS_MIB_ECT1PKTS),
 	SNMP_MIB_ITEM("InECT0Pkts", IPSTATS_MIB_ECT0PKTS),
 	SNMP_MIB_ITEM("InCEPkts", IPSTATS_MIB_CEPKTS),
+	SNMP_MIB_ITEM("ReasmOverlaps", IPSTATS_MIB_REASM_OVERLAPS),
 	SNMP_MIB_SENTINEL
 };
 
