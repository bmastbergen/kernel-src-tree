ext4: Fix data exposure after failed AIO DIO

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jan Kara <jack@suse.cz>
commit 74c66bcb7eda551f3b8588659c58fe29184af903
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/74c66bcb.failed

When AIO DIO fails e.g. due to IO error, we must not convert unwritten
extents as that will expose uninitialized data. Handle this case
by clearing unwritten flag from io_end in case of error and thus
preventing extent conversion.

	Signed-off-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 74c66bcb7eda551f3b8588659c58fe29184af903)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/ext4.h
diff --cc fs/ext4/ext4.h
index 76a16c835c1e,56c12df107ab..000000000000
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@@ -2905,14 -3284,26 +2896,37 @@@ extern struct mutex ext4__aio_mutex[EXT
  extern int ext4_resize_begin(struct super_block *sb);
  extern void ext4_resize_end(struct super_block *sb);
  
++<<<<<<< HEAD
 +static inline bool ext4_aligned_io(struct inode *inode, loff_t off, loff_t len)
 +{
 +	int blksize = 1 << inode->i_blkbits;
 +
 +	return IS_ALIGNED(off, blksize) && IS_ALIGNED(len, blksize);
 +}
 +
 +extern const struct iomap_ops ext4_iomap_ops;
++=======
+ static inline void ext4_set_io_unwritten_flag(struct inode *inode,
+ 					      struct ext4_io_end *io_end)
+ {
+ 	if (!(io_end->flag & EXT4_IO_END_UNWRITTEN)) {
+ 		io_end->flag |= EXT4_IO_END_UNWRITTEN;
+ 		atomic_inc(&EXT4_I(inode)->i_unwritten);
+ 	}
+ }
+ 
+ static inline void ext4_clear_io_unwritten_flag(ext4_io_end_t *io_end)
+ {
+ 	struct inode *inode = io_end->inode;
+ 
+ 	if (io_end->flag & EXT4_IO_END_UNWRITTEN) {
+ 		io_end->flag &= ~EXT4_IO_END_UNWRITTEN;
+ 		/* Wake up anyone waiting on unwritten extent conversion */
+ 		if (atomic_dec_and_test(&EXT4_I(inode)->i_unwritten))
+ 			wake_up_all(ext4_ioend_wq(inode));
+ 	}
+ }
++>>>>>>> 74c66bcb7eda (ext4: Fix data exposure after failed AIO DIO)
  
  #endif	/* __KERNEL__ */
  
* Unmerged path fs/ext4/ext4.h
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 83725648daac..88a65f94fed1 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -3264,6 +3264,14 @@ static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,
 		  size);
 
 	iocb->private = NULL;
+	/*
+	 * Error during AIO DIO. We cannot convert unwritten extents as the
+	 * data was not written. Just clear the unwritten flag and drop io_end.
+	 */
+	if (size <= 0) {
+		ext4_clear_io_unwritten_flag(io_end);
+		size = 0;
+	}
 	io_end->offset = offset;
 	io_end->size = size;
 	ext4_put_io_end(io_end);
@@ -3383,16 +3391,6 @@ static ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,
 	if (io_end) {
 		ext4_inode_aio_set(inode, NULL);
 		ext4_put_io_end(io_end);
-		/*
-		 * When no IO was submitted ext4_end_io_dio() was not
-		 * called so we have to put iocb's reference.
-		 */
-		if (ret <= 0 && ret != -EIOCBQUEUED && iocb->private) {
-			WARN_ON(iocb->private != io_end);
-			WARN_ON(io_end->flag & EXT4_IO_END_UNWRITTEN);
-			ext4_put_io_end(io_end);
-			iocb->private = NULL;
-		}
 	}
 	if (ret > 0 && !overwrite && ext4_test_inode_state(inode,
 						EXT4_STATE_DIO_UNWRITTEN)) {
diff --git a/fs/ext4/page-io.c b/fs/ext4/page-io.c
index c7091cab5714..739bd4c20b3b 100644
--- a/fs/ext4/page-io.c
+++ b/fs/ext4/page-io.c
@@ -126,16 +126,6 @@ static void ext4_release_io_end(ext4_io_end_t *io_end)
 	kmem_cache_free(io_end_cachep, io_end);
 }
 
-static void ext4_clear_io_unwritten_flag(ext4_io_end_t *io_end)
-{
-	struct inode *inode = io_end->inode;
-
-	io_end->flag &= ~EXT4_IO_END_UNWRITTEN;
-	/* Wake up anyone waiting on unwritten extent conversion */
-	if (atomic_dec_and_test(&EXT4_I(inode)->i_unwritten))
-		wake_up_all(ext4_ioend_wq(inode));
-}
-
 /*
  * Check a range of space and convert unwritten extents to written. Note that
  * we are protected from truncate touching same part of extent tree by the
