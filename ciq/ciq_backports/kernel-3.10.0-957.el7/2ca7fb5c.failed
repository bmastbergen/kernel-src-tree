drm/nouveau/kms/nv50: handle SetControlOutputResource from head

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ben Skeggs <bskeggs@redhat.com>
commit 2ca7fb5c1cc69ee7fc1a3c048c6f2b75cf842df9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/2ca7fb5c.failed

Removes duplicated code from OR-specific functions.

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit 2ca7fb5c1cc69ee7fc1a3c048c6f2b75cf842df9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/dispnv50/disp.c
diff --cc drivers/gpu/drm/nouveau/dispnv50/disp.c
index a2ea42f947c7,f22c6373fcc2..000000000000
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.c
@@@ -190,8 -194,15 +190,14 @@@ struct nv50_head_atom 
  		} sat;
  	} procamp;
  
+ 	struct {
+ 		u8 nhsync:1;
+ 		u8 nvsync:1;
+ 		u8 depth:4;
+ 	} or;
+ 
  	union {
  		struct {
 -			bool ilut:1;
  			bool core:1;
  			bool curs:1;
  		};
@@@ -605,74 -442,36 +612,94 @@@ struct nv50_sync 
  	u32 data;
  };
  
 +static int
 +nv50_base_create(struct nvif_device *device, struct nvif_object *disp,
 +		 int head, u64 syncbuf, struct nv50_sync *base)
 +{
 +	struct nv50_disp_base_channel_dma_v0 args = {
 +		.pushbuf = 0xb0007c00 | head,
 +		.head = head,
 +	};
 +	static const s32 oclass[] = {
 +		GK110_DISP_BASE_CHANNEL_DMA,
 +		GK104_DISP_BASE_CHANNEL_DMA,
 +		GF110_DISP_BASE_CHANNEL_DMA,
 +		GT214_DISP_BASE_CHANNEL_DMA,
 +		GT200_DISP_BASE_CHANNEL_DMA,
 +		G82_DISP_BASE_CHANNEL_DMA,
 +		NV50_DISP_BASE_CHANNEL_DMA,
 +		0
 +	};
 +
 +	return nv50_dmac_create(device, disp, oclass, head, &args, sizeof(args),
 +				syncbuf, &base->base);
 +}
 +
 +/******************************************************************************
 + * Overlay
 + *****************************************************************************/
 +
 +struct nv50_ovly {
 +	struct nv50_dmac base;
 +};
 +
 +static int
 +nv50_ovly_create(struct nvif_device *device, struct nvif_object *disp,
 +		 int head, u64 syncbuf, struct nv50_ovly *ovly)
 +{
 +	struct nv50_disp_overlay_channel_dma_v0 args = {
 +		.pushbuf = 0xb0007e00 | head,
 +		.head = head,
 +	};
 +	static const s32 oclass[] = {
 +		GK104_DISP_OVERLAY_CONTROL_DMA,
 +		GF110_DISP_OVERLAY_CONTROL_DMA,
 +		GT214_DISP_OVERLAY_CHANNEL_DMA,
 +		GT200_DISP_OVERLAY_CHANNEL_DMA,
 +		G82_DISP_OVERLAY_CHANNEL_DMA,
 +		NV50_DISP_OVERLAY_CHANNEL_DMA,
 +		0
 +	};
 +
 +	return nv50_dmac_create(device, disp, oclass, head, &args, sizeof(args),
 +				syncbuf, &ovly->base);
 +}
 +
  struct nv50_head {
 -	const struct nv50_head_func *func;
  	struct nouveau_crtc base;
 -	struct {
 -		struct nouveau_bo *nvbo[2];
 -		int next;
 -	} lut;
 +	struct nv50_ovly ovly;
 +	struct nv50_oimm oimm;
  };
  
++<<<<<<< HEAD
 +#define nv50_head(c) ((struct nv50_head *)nouveau_crtc(c))
 +#define nv50_ovly(c) (&nv50_head(c)->ovly)
 +#define nv50_oimm(c) (&nv50_head(c)->oimm)
 +#define nv50_chan(c) (&(c)->base.base)
 +#define nv50_vers(c) nv50_chan(c)->user.oclass
++=======
+ struct nv50_head_func {
+ 	void (*view)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*mode)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*ilut_set)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*ilut_clr)(struct nv50_head *);
+ 	void (*core_set)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*core_clr)(struct nv50_head *);
+ 	void (*curs_set)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*curs_clr)(struct nv50_head *);
+ 	void (*base)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*ovly)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*dither)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*procamp)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*or)(struct nv50_head *, struct nv50_head_atom *);
+ };
+ 
+ #define nv50_head(c) container_of((c), struct nv50_head, base.base)
++>>>>>>> 2ca7fb5c1cc6 (drm/nouveau/kms/nv50: handle SetControlOutputResource from head)
  
  struct nv50_disp {
 -	struct nvif_disp *disp;
 -	struct nv50_core *core;
 +	struct nvif_object *disp;
 +	struct nv50_mast mast;
  
  	struct nouveau_bo *sync;
  
@@@ -1891,6 -2044,23 +1935,26 @@@ nv50_head_view(struct nv50_head *head, 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static const struct nv50_head_func
+ head507d = {
+ 	.view = nv50_head_view,
+ 	.mode = nv50_head_mode,
+ 	.ilut_set = nv50_head_lut_set,
+ 	.ilut_clr = nv50_head_lut_clr,
+ 	.core_set = nv50_head_core_set,
+ 	.core_clr = nv50_head_core_clr,
+ 	.curs_set = nv50_head_curs_set,
+ 	.curs_clr = nv50_head_curs_clr,
+ 	.base = nv50_head_base,
+ 	.ovly = nv50_head_ovly,
+ 	.dither = nv50_head_dither,
+ 	.procamp = nv50_head_procamp,
+ 	.or = head907d_or,
+ };
+ 
++>>>>>>> 2ca7fb5c1cc6 (drm/nouveau/kms/nv50: handle SetControlOutputResource from head)
  static void
  nv50_head_flush_clr(struct nv50_head *head, struct nv50_head_atom *asyh, bool y)
  {
@@@ -1905,15 -2075,24 +1969,36 @@@
  static void
  nv50_head_flush_set(struct nv50_head *head, struct nv50_head_atom *asyh)
  {
++<<<<<<< HEAD
 +	if (asyh->set.view   ) nv50_head_view    (head, asyh);
 +	if (asyh->set.mode   ) nv50_head_mode    (head, asyh);
 +	if (asyh->set.core   ) nv50_head_lut_set (head, asyh);
 +	if (asyh->set.core   ) nv50_head_core_set(head, asyh);
 +	if (asyh->set.curs   ) nv50_head_curs_set(head, asyh);
 +	if (asyh->set.base   ) nv50_head_base    (head, asyh);
 +	if (asyh->set.ovly   ) nv50_head_ovly    (head, asyh);
 +	if (asyh->set.dither ) nv50_head_dither  (head, asyh);
 +	if (asyh->set.procamp) nv50_head_procamp (head, asyh);
++=======
+ 	if (asyh->set.view   ) head->func->view    (head, asyh);
+ 	if (asyh->set.mode   ) head->func->mode    (head, asyh);
+ 	if (asyh->set.ilut   ) {
+ 		struct nouveau_bo *nvbo = head->lut.nvbo[head->lut.next];
+ 		struct drm_property_blob *blob = asyh->state.gamma_lut;
+ 		if (blob)
+ 			nv50_head_lut_load(blob, asyh->lut.mode, nvbo);
+ 		asyh->lut.offset = nvbo->bo.offset;
+ 		head->lut.next ^= 1;
+ 		head->func->ilut_set(head, asyh);
+ 	}
+ 	if (asyh->set.core   ) head->func->core_set(head, asyh);
+ 	if (asyh->set.curs   ) head->func->curs_set(head, asyh);
+ 	if (asyh->set.base   ) head->func->base    (head, asyh);
+ 	if (asyh->set.ovly   ) head->func->ovly    (head, asyh);
+ 	if (asyh->set.dither ) head->func->dither  (head, asyh);
+ 	if (asyh->set.procamp) head->func->procamp (head, asyh);
+ 	if (asyh->set.or     ) head->func->or      (head, asyh);
++>>>>>>> 2ca7fb5c1cc6 (drm/nouveau/kms/nv50: handle SetControlOutputResource from head)
  }
  
  static void
@@@ -2518,48 -2735,28 +2607,39 @@@ nv50_dac_disable(struct drm_encoder *en
  static void
  nv50_dac_enable(struct drm_encoder *encoder)
  {
 -	struct nv50_dmac *core = &nv50_disp(encoder->dev)->core->chan;
 +	struct nv50_mast *mast = nv50_mast(encoder->dev);
  	struct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);
  	struct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);
- 	struct drm_display_mode *mode = &nv_crtc->base.state->adjusted_mode;
+ 	struct nv50_head_atom *asyh = nv50_head_atom(nv_crtc->base.state);
  	u32 *push;
  
  	nv50_outp_acquire(nv_encoder);
  
 -	push = evo_wait(core, 8);
 +	push = evo_wait(mast, 8);
  	if (push) {
++<<<<<<< HEAD
 +		if (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {
 +			u32 syncs = 0x00000000;
 +
 +			if (mode->flags & DRM_MODE_FLAG_NHSYNC)
 +				syncs |= 0x00000001;
 +			if (mode->flags & DRM_MODE_FLAG_NVSYNC)
 +				syncs |= 0x00000002;
 +
++=======
+ 		if (core->base.user.oclass < GF110_DISP_CORE_CHANNEL_DMA) {
++>>>>>>> 2ca7fb5c1cc6 (drm/nouveau/kms/nv50: handle SetControlOutputResource from head)
  			evo_mthd(push, 0x0400 + (nv_encoder->or * 0x080), 2);
  			evo_data(push, 1 << nv_crtc->index);
- 			evo_data(push, syncs);
+ 			evo_data(push, (asyh->or.nvsync << 1) | asyh->or.nhsync);
  		} else {
- 			u32 magic = 0x31ec6000 | (nv_crtc->index << 25);
- 			u32 syncs = 0x00000001;
- 
- 			if (mode->flags & DRM_MODE_FLAG_NHSYNC)
- 				syncs |= 0x00000008;
- 			if (mode->flags & DRM_MODE_FLAG_NVSYNC)
- 				syncs |= 0x00000010;
- 
- 			if (mode->flags & DRM_MODE_FLAG_INTERLACE)
- 				magic |= 0x00000001;
- 
- 			evo_mthd(push, 0x0404 + (nv_crtc->index * 0x300), 2);
- 			evo_data(push, syncs);
- 			evo_data(push, magic);
  			evo_mthd(push, 0x0180 + (nv_encoder->or * 0x020), 1);
  			evo_data(push, 1 << nv_crtc->index);
  		}
  
 -		evo_kick(push, core);
 +		evo_kick(push, mast);
  	}
+ 	asyh->or.depth = 0;
  
  	nv_encoder->crtc = encoder->crtc;
  }
@@@ -3428,12 -3623,13 +3508,12 @@@ nv50_mstm_new(struct nouveau_encoder *o
   *****************************************************************************/
  static void
  nv50_sor_update(struct nouveau_encoder *nv_encoder, u8 head,
- 		struct drm_display_mode *mode, u8 proto, u8 depth)
+ 		struct nv50_head_atom *asyh, u8 proto, u8 depth)
  {
 -	struct nv50_disp *disp = nv50_disp(nv_encoder->base.base.dev);
 -	struct nv50_dmac *core = &disp->core->chan;
 +	struct nv50_dmac *core = &nv50_mast(nv_encoder->base.base.dev)->base;
  	u32 *push;
  
- 	if (!mode) {
+ 	if (!asyh) {
  		nv_encoder->ctrl &= ~BIT(head);
  		if (!(nv_encoder->ctrl & 0x0000000f))
  			nv_encoder->ctrl = 0;
@@@ -3764,19 -3946,17 +3830,26 @@@ nv50_pior_enable(struct drm_encoder *en
  		break;
  	}
  
 -	push = evo_wait(core, 8);
 +	push = evo_wait(mast, 8);
  	if (push) {
++<<<<<<< HEAD
 +		if (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {
 +			u32 ctrl = (depth << 16) | (proto << 8) | owner;
 +			if (mode->flags & DRM_MODE_FLAG_NHSYNC)
 +				ctrl |= 0x00001000;
 +			if (mode->flags & DRM_MODE_FLAG_NVSYNC)
 +				ctrl |= 0x00002000;
++=======
+ 		if (core->base.user.oclass < GF110_DISP_CORE_CHANNEL_DMA) {
++>>>>>>> 2ca7fb5c1cc6 (drm/nouveau/kms/nv50: handle SetControlOutputResource from head)
  			evo_mthd(push, 0x0700 + (nv_encoder->or * 0x040), 1);
- 			evo_data(push, ctrl);
+ 			evo_data(push, (asyh->or.depth  << 16) |
+ 				       (asyh->or.nvsync << 13) |
+ 				       (asyh->or.nhsync << 12) |
+ 				       (proto << 8) | owner);
  		}
  
 -		evo_kick(push, core);
 +		evo_kick(push, mast);
  	}
  
  	nv_encoder->crtc = encoder->crtc;
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/disp.c
diff --git a/drivers/gpu/drm/nouveau/nouveau_encoder.h b/drivers/gpu/drm/nouveau/nouveau_encoder.h
index e28d966946a1..3517f920bf89 100644
--- a/drivers/gpu/drm/nouveau/nouveau_encoder.h
+++ b/drivers/gpu/drm/nouveau/nouveau_encoder.h
@@ -32,6 +32,7 @@
 #include <drm/drm_encoder_slave.h>
 #include <drm/drm_dp_mst_helper.h>
 #include "dispnv04/disp.h"
+struct nv50_head_atom;
 
 #define NV_DPMS_CLEARED 0x80
 
@@ -68,7 +69,7 @@ struct nouveau_encoder {
 	void (*enc_save)(struct drm_encoder *encoder);
 	void (*enc_restore)(struct drm_encoder *encoder);
 	void (*update)(struct nouveau_encoder *, u8 head,
-		       struct drm_display_mode *, u8 proto, u8 depth);
+		       struct nv50_head_atom *, u8 proto, u8 depth);
 };
 
 struct nouveau_encoder *
