exec: move allow_write_access/fput to exec_binprm()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Oleg Nesterov <oleg@redhat.com>
commit 52f14282bb0c3d3e5ba2a9eaacb12ff37a033e7e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/52f14282.failed

When search_binary_handler() succeeds it does allow_write_access() and
fput(), then it clears bprm->file to ensure the caller will not do the
same.

We can simply move this code to exec_binprm() which is called only once.
In fact we could move this to free_bprm() and remove the same code in
do_execve_common's error path.

	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Acked-by: Kees Cook <keescook@chromium.org>
	Cc: Al Viro <viro@ZenIV.linux.org.uk>
	Cc: Evgeniy Polyakov <zbr@ioremap.net>
	Cc: Zach Levis <zml@linux.vnet.ibm.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 52f14282bb0c3d3e5ba2a9eaacb12ff37a033e7e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/exec.c
diff --cc fs/exec.c
index 7eaf14e395d9,a4cfd1d725e0..000000000000
--- a/fs/exec.c
+++ b/fs/exec.c
@@@ -1453,18 -1399,7 +1453,21 @@@ int search_binary_handler(struct linux_
  			retval = fn(bprm);
  			bprm->recursion_depth--;
  			if (retval >= 0) {
 +				audit_bprm(bprm);
 +				if (depth == 0) {
 +					trace_sched_process_exec(current, old_pid, bprm);
 +					ptrace_event(PTRACE_EVENT_EXEC, old_vpid);
 +				}
  				put_binfmt(fmt);
++<<<<<<< HEAD
 +				allow_write_access(bprm->file);
 +				if (bprm->file)
 +					fput(bprm->file);
 +				bprm->file = NULL;
 +				current->did_exec = 1;
 +				proc_exec_connector(current);
++=======
++>>>>>>> 52f14282bb0c (exec: move allow_write_access/fput to exec_binprm())
  				return retval;
  			}
  			read_lock(&binfmt_lock);
@@@ -1497,9 -1432,36 +1500,40 @@@
  	}
  	return retval;
  }
 +
  EXPORT_SYMBOL(search_binary_handler);
  
++<<<<<<< HEAD
++=======
+ static int exec_binprm(struct linux_binprm *bprm)
+ {
+ 	pid_t old_pid, old_vpid;
+ 	int ret;
+ 
+ 	/* Need to fetch pid before load_binary changes it */
+ 	old_pid = current->pid;
+ 	rcu_read_lock();
+ 	old_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));
+ 	rcu_read_unlock();
+ 
+ 	ret = search_binary_handler(bprm);
+ 	if (ret >= 0) {
+ 		trace_sched_process_exec(current, old_pid, bprm);
+ 		ptrace_event(PTRACE_EVENT_EXEC, old_vpid);
+ 		current->did_exec = 1;
+ 		proc_exec_connector(current);
+ 
+ 		if (bprm->file) {
+ 			allow_write_access(bprm->file);
+ 			fput(bprm->file);
+ 			bprm->file = NULL; /* to catch use-after-free */
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 52f14282bb0c (exec: move allow_write_access/fput to exec_binprm())
  /*
   * sys_execve() executes a new program.
   */
* Unmerged path fs/exec.c
