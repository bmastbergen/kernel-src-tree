KVM: x86: add support for UMIP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] kvm: add support for UMIP (Paul Lai) [1457461]
Rebuild_FUZZ: 90.91%
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit ae3e61e1c28338d077b704505570fa181df1e41f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ae3e61e1.failed

Add the CPUID bits, make the CR4.UMIP bit not reserved anymore, and
add UMIP support for instructions that are already emulated by KVM.

	Reviewed-by: Wanpeng Li <wanpeng.li@hotmail.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit ae3e61e1c28338d077b704505570fa181df1e41f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/cpuid.c
#	arch/x86/kvm/x86.c
diff --cc arch/x86/include/asm/kvm_host.h
index 081db5ad9392,ff79134d1d71..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -62,8 -85,8 +62,13 @@@
  			  | X86_CR4_PSE | X86_CR4_PAE | X86_CR4_MCE     \
  			  | X86_CR4_PGE | X86_CR4_PCE | X86_CR4_OSFXSR | X86_CR4_PCIDE \
  			  | X86_CR4_OSXSAVE | X86_CR4_SMEP | X86_CR4_FSGSBASE \
++<<<<<<< HEAD
 +			  | X86_CR4_OSXMMEXCPT | X86_CR4_VMXE | X86_CR4_SMAP \
 +			  | X86_CR4_PKE))
++=======
+ 			  | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_VMXE \
+ 			  | X86_CR4_SMAP | X86_CR4_PKE | X86_CR4_UMIP))
++>>>>>>> ae3e61e1c283 (KVM: x86: add support for UMIP)
  
  #define CR8_RESERVED_BITS (~(unsigned long)X86_CR8_TPR)
  
diff --cc arch/x86/kvm/cpuid.c
index 7bb663af32bb,77fb8732b47b..000000000000
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -379,7 -387,8 +379,12 @@@ static inline int __do_cpuid_ent(struc
  
  	/* cpuid 7.0.ecx*/
  	const u32 kvm_cpuid_7_0_ecx_x86_features =
++<<<<<<< HEAD
 +		F(PKU) | 0 /*OSPKE*/ | F(AVX512VBMI) | F(AVX512_VPOPCNTDQ);
++=======
+ 		F(AVX512VBMI) | F(LA57) | F(PKU) | 0 /*OSPKE*/ |
+ 		F(AVX512_VPOPCNTDQ) | F(UMIP);
++>>>>>>> ae3e61e1c283 (KVM: x86: add support for UMIP)
  
  	/* cpuid 7.0.edx*/
  	const u32 kvm_cpuid_7_0_edx_x86_features =
diff --cc arch/x86/kvm/x86.c
index 3da33c482b14,dd2e80ac49ff..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -758,6 -791,12 +758,15 @@@ int kvm_set_cr4(struct kvm_vcpu *vcpu, 
  	if (!guest_cpuid_has(vcpu, X86_FEATURE_PKU) && (cr4 & X86_CR4_PKE))
  		return 1;
  
++<<<<<<< HEAD
++=======
+ 	if (!guest_cpuid_has(vcpu, X86_FEATURE_LA57) && (cr4 & X86_CR4_LA57))
+ 		return 1;
+ 
+ 	if (!guest_cpuid_has(vcpu, X86_FEATURE_UMIP) && (cr4 & X86_CR4_UMIP))
+ 		return 1;
+ 
++>>>>>>> ae3e61e1c283 (KVM: x86: add support for UMIP)
  	if (is_long_mode(vcpu)) {
  		if (!(cr4 & X86_CR4_PAE))
  			return 1;
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/cpuid.c
diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c
index da14bc5de528..05d389ffb09d 100644
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@ -3768,6 +3768,10 @@ static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,
 {
 	struct desc_ptr desc_ptr;
 
+	if ((ctxt->ops->get_cr(ctxt, 4) & X86_CR4_UMIP) &&
+	    ctxt->ops->cpl(ctxt) > 0)
+		return emulate_gp(ctxt, 0);
+
 	if (ctxt->mode == X86EMUL_MODE_PROT64)
 		ctxt->op_bytes = 8;
 	get(ctxt, &desc_ptr);
@@ -3827,6 +3831,10 @@ static int em_lidt(struct x86_emulate_ctxt *ctxt)
 
 static int em_smsw(struct x86_emulate_ctxt *ctxt)
 {
+	if ((ctxt->ops->get_cr(ctxt, 4) & X86_CR4_UMIP) &&
+	    ctxt->ops->cpl(ctxt) > 0)
+		return emulate_gp(ctxt, 0);
+
 	if (ctxt->dst.type == OP_MEM)
 		ctxt->dst.bytes = 2;
 	ctxt->dst.val = ctxt->ops->get_cr(ctxt, 0);
* Unmerged path arch/x86/kvm/x86.c
