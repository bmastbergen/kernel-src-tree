x86/cpu/AMD: Evaluate smp_num_siblings early

jira LE-1907
cve CVE-2018-3620
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] cpu/amd: evaluate smp_num_siblings early (Christoph von Recklinghausen) [1593384] {CVE-2018-3620}
Rebuild_FUZZ: 95.24%
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 1e1d7e25fd759eddf96d8ab39d0a90a1979b2d8c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1e1d7e25.failed

To support force disabling of SMT it's required to know the number of
thread siblings early. amd_get_topology() cannot be called before the APIC
driver is selected, so split out the part which initializes
smp_num_siblings and invoke it from amd_early_init().

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 1e1d7e25fd759eddf96d8ab39d0a90a1979b2d8c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/amd.c
diff --cc arch/x86/kernel/cpu/amd.c
index d354c50b9560,b20dee982a53..000000000000
--- a/arch/x86/kernel/cpu/amd.c
+++ b/arch/x86/kernel/cpu/amd.c
@@@ -553,35 -678,49 +564,63 @@@ static void early_init_amd(struct cpuin
  	 */
  	set_cpu_cap(c, X86_FEATURE_VMMCALL);
  
 -	/* F16h erratum 793, CVE-2013-6885 */
 -	if (c->x86 == 0x16 && c->x86_model <= 0xf)
 -		msr_set_bit(MSR_AMD64_LS_CFG, 15);
 -
  	/*
 -	 * Check whether the machine is affected by erratum 400. This is
 -	 * used to select the proper idle routine and to enable the check
 -	 * whether the machine is affected in arch_post_acpi_init(), which
 -	 * sets the X86_BUG_AMD_APIC_C1E bug depending on the MSR check.
 +	 * BIOS support is required for SME. If BIOS has enabled SME then
 +	 * adjust x86_phys_bits by the SME physical address space reduction
 +	 * value. If BIOS has not enabled SME then don't advertise the
 +	 * feature (set in scattered.c). Also, since the SME support requires
 +	 * long mode, don't advertise the feature under CONFIG_X86_32.
  	 */
 -	if (cpu_has_amd_erratum(c, amd_erratum_400))
 -		set_cpu_bug(c, X86_BUG_AMD_E400);
 +	if (cpu_has(c, X86_FEATURE_SME)) {
 +		u64 msr;
  
++<<<<<<< HEAD
 +		/* Check if SME is enabled */
 +		rdmsrl(MSR_K8_SYSCFG, msr);
 +		if (msr & MSR_K8_SYSCFG_MEM_ENCRYPT) {
 +			c->x86_phys_bits -= (cpuid_ebx(0x8000001f) >> 6) & 0x3f;
 +			if (IS_ENABLED(CONFIG_X86_32))
 +				clear_cpu_cap(c, X86_FEATURE_SME);
 +		} else {
 +			clear_cpu_cap(c, X86_FEATURE_SME);
++=======
+ 	early_detect_mem_encrypt(c);
+ 
+ 	amd_get_topology_early(c);
+ }
+ 
+ static void init_amd_k8(struct cpuinfo_x86 *c)
+ {
+ 	u32 level;
+ 	u64 value;
+ 
+ 	/* On C+ stepping K8 rep microcode works well for copy/memset */
+ 	level = cpuid_eax(1);
+ 	if ((level >= 0x0f48 && level < 0x0f50) || level >= 0x0f58)
+ 		set_cpu_cap(c, X86_FEATURE_REP_GOOD);
+ 
+ 	/*
+ 	 * Some BIOSes incorrectly force this feature, but only K8 revision D
+ 	 * (model = 0x14) and later actually support it.
+ 	 * (AMD Erratum #110, docId: 25759).
+ 	 */
+ 	if (c->x86_model < 0x14 && cpu_has(c, X86_FEATURE_LAHF_LM)) {
+ 		clear_cpu_cap(c, X86_FEATURE_LAHF_LM);
+ 		if (!rdmsrl_amd_safe(0xc001100d, &value)) {
+ 			value &= ~BIT_64(32);
+ 			wrmsrl_amd_safe(0xc001100d, value);
++>>>>>>> 1e1d7e25fd75 (x86/cpu/AMD: Evaluate smp_num_siblings early)
  		}
  	}
 +}
 +
 +static const int amd_erratum_383[];
 +static const int amd_erratum_400[];
 +static bool cpu_has_amd_erratum(struct cpuinfo_x86 *cpu, const int *erratum);
  
 -	if (!c->x86_model_id[0])
 -		strcpy(c->x86_model_id, "Hammer");
 +static void init_amd(struct cpuinfo_x86 *c)
 +{
 +	unsigned long long value;
  
  #ifdef CONFIG_SMP
  	/*
* Unmerged path arch/x86/kernel/cpu/amd.c
