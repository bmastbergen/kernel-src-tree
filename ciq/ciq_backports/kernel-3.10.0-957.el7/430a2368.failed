PCI: Add pci_enable_atomic_ops_to_root()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jay Cornwall <Jay.Cornwall@amd.com>
commit 430a23689dea2e36ae5a0fc75a67301fd46b18bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/430a2368.failed

The Atomic Operations feature (PCIe r4.0, sec 6.15) allows atomic
transctions to be requested by, routed through and completed by PCIe
components. Routing and completion do not require software support.
Component support for each is detectable via the DEVCAP2 register.

A Requester may use AtomicOps only if its PCI_EXP_DEVCTL2_ATOMIC_REQ is
set. This should be set only if the Completer and all intermediate routing
elements support AtomicOps.

A concrete example is the AMD Fiji-class GPU (which is capable of making
AtomicOp requests), below a PLX 8747 switch (advertising AtomicOp routing)
with a Haswell host bridge (advertising AtomicOp completion support).

Add pci_enable_atomic_ops_to_root() for per-device control over AtomicOp
requests. This checks to be sure the Root Port supports completion of the
desired AtomicOp sizes and the path to the Root Port supports routing the
AtomicOps.

	Signed-off-by: Jay Cornwall <Jay.Cornwall@amd.com>
	Signed-off-by: Felix Kuehling <Felix.Kuehling@amd.com>
[bhelgaas: changelog, comments, whitespace]
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 430a23689dea2e36ae5a0fc75a67301fd46b18bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pci.c
diff --cc drivers/pci/pci.c
index 78e7102016b2,6112dd8d68b6..000000000000
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@@ -2821,6 -2965,182 +2821,185 @@@ bool pci_acs_path_enabled(struct pci_de
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * pci_rebar_find_pos - find position of resize ctrl reg for BAR
+  * @pdev: PCI device
+  * @bar: BAR to find
+  *
+  * Helper to find the position of the ctrl register for a BAR.
+  * Returns -ENOTSUPP if resizable BARs are not supported at all.
+  * Returns -ENOENT if no ctrl register for the BAR could be found.
+  */
+ static int pci_rebar_find_pos(struct pci_dev *pdev, int bar)
+ {
+ 	unsigned int pos, nbars, i;
+ 	u32 ctrl;
+ 
+ 	pos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_REBAR);
+ 	if (!pos)
+ 		return -ENOTSUPP;
+ 
+ 	pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
+ 	nbars = (ctrl & PCI_REBAR_CTRL_NBAR_MASK) >>
+ 		    PCI_REBAR_CTRL_NBAR_SHIFT;
+ 
+ 	for (i = 0; i < nbars; i++, pos += 8) {
+ 		int bar_idx;
+ 
+ 		pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
+ 		bar_idx = ctrl & PCI_REBAR_CTRL_BAR_IDX;
+ 		if (bar_idx == bar)
+ 			return pos;
+ 	}
+ 
+ 	return -ENOENT;
+ }
+ 
+ /**
+  * pci_rebar_get_possible_sizes - get possible sizes for BAR
+  * @pdev: PCI device
+  * @bar: BAR to query
+  *
+  * Get the possible sizes of a resizable BAR as bitmask defined in the spec
+  * (bit 0=1MB, bit 19=512GB). Returns 0 if BAR isn't resizable.
+  */
+ u32 pci_rebar_get_possible_sizes(struct pci_dev *pdev, int bar)
+ {
+ 	int pos;
+ 	u32 cap;
+ 
+ 	pos = pci_rebar_find_pos(pdev, bar);
+ 	if (pos < 0)
+ 		return 0;
+ 
+ 	pci_read_config_dword(pdev, pos + PCI_REBAR_CAP, &cap);
+ 	return (cap & PCI_REBAR_CAP_SIZES) >> 4;
+ }
+ 
+ /**
+  * pci_rebar_get_current_size - get the current size of a BAR
+  * @pdev: PCI device
+  * @bar: BAR to set size to
+  *
+  * Read the size of a BAR from the resizable BAR config.
+  * Returns size if found or negative error code.
+  */
+ int pci_rebar_get_current_size(struct pci_dev *pdev, int bar)
+ {
+ 	int pos;
+ 	u32 ctrl;
+ 
+ 	pos = pci_rebar_find_pos(pdev, bar);
+ 	if (pos < 0)
+ 		return pos;
+ 
+ 	pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
+ 	return (ctrl & PCI_REBAR_CTRL_BAR_SIZE) >> 8;
+ }
+ 
+ /**
+  * pci_rebar_set_size - set a new size for a BAR
+  * @pdev: PCI device
+  * @bar: BAR to set size to
+  * @size: new size as defined in the spec (0=1MB, 19=512GB)
+  *
+  * Set the new size of a BAR as defined in the spec.
+  * Returns zero if resizing was successful, error code otherwise.
+  */
+ int pci_rebar_set_size(struct pci_dev *pdev, int bar, int size)
+ {
+ 	int pos;
+ 	u32 ctrl;
+ 
+ 	pos = pci_rebar_find_pos(pdev, bar);
+ 	if (pos < 0)
+ 		return pos;
+ 
+ 	pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
+ 	ctrl &= ~PCI_REBAR_CTRL_BAR_SIZE;
+ 	ctrl |= size << 8;
+ 	pci_write_config_dword(pdev, pos + PCI_REBAR_CTRL, ctrl);
+ 	return 0;
+ }
+ 
+ /**
+  * pci_enable_atomic_ops_to_root - enable AtomicOp requests to root port
+  * @dev: the PCI device
+  * @cap_mask: mask of desired AtomicOp sizes, including one or more of:
+  *	PCI_EXP_DEVCAP2_ATOMIC_COMP32
+  *	PCI_EXP_DEVCAP2_ATOMIC_COMP64
+  *	PCI_EXP_DEVCAP2_ATOMIC_COMP128
+  *
+  * Return 0 if all upstream bridges support AtomicOp routing, egress
+  * blocking is disabled on all upstream ports, and the root port supports
+  * the requested completion capabilities (32-bit, 64-bit and/or 128-bit
+  * AtomicOp completion), or negative otherwise.
+  */
+ int pci_enable_atomic_ops_to_root(struct pci_dev *dev, u32 cap_mask)
+ {
+ 	struct pci_bus *bus = dev->bus;
+ 	struct pci_dev *bridge;
+ 	u32 cap, ctl2;
+ 
+ 	if (!pci_is_pcie(dev))
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * Per PCIe r4.0, sec 6.15, endpoints and root ports may be
+ 	 * AtomicOp requesters.  For now, we only support endpoints as
+ 	 * requesters and root ports as completers.  No endpoints as
+ 	 * completers, and no peer-to-peer.
+ 	 */
+ 
+ 	switch (pci_pcie_type(dev)) {
+ 	case PCI_EXP_TYPE_ENDPOINT:
+ 	case PCI_EXP_TYPE_LEG_END:
+ 	case PCI_EXP_TYPE_RC_END:
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	while (bus->parent) {
+ 		bridge = bus->self;
+ 
+ 		pcie_capability_read_dword(bridge, PCI_EXP_DEVCAP2, &cap);
+ 
+ 		switch (pci_pcie_type(bridge)) {
+ 		/* Ensure switch ports support AtomicOp routing */
+ 		case PCI_EXP_TYPE_UPSTREAM:
+ 		case PCI_EXP_TYPE_DOWNSTREAM:
+ 			if (!(cap & PCI_EXP_DEVCAP2_ATOMIC_ROUTE))
+ 				return -EINVAL;
+ 			break;
+ 
+ 		/* Ensure root port supports all the sizes we care about */
+ 		case PCI_EXP_TYPE_ROOT_PORT:
+ 			if ((cap & cap_mask) != cap_mask)
+ 				return -EINVAL;
+ 			break;
+ 		}
+ 
+ 		/* Ensure upstream ports don't block AtomicOps on egress */
+ 		if (!bridge->has_secondary_link) {
+ 			pcie_capability_read_dword(bridge, PCI_EXP_DEVCTL2,
+ 						   &ctl2);
+ 			if (ctl2 & PCI_EXP_DEVCTL2_ATOMIC_EGRESS_BLOCK)
+ 				return -EINVAL;
+ 		}
+ 
+ 		bus = bus->parent;
+ 	}
+ 
+ 	pcie_capability_set_word(dev, PCI_EXP_DEVCTL2,
+ 				 PCI_EXP_DEVCTL2_ATOMIC_REQ);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(pci_enable_atomic_ops_to_root);
+ 
+ /**
++>>>>>>> 430a23689dea (PCI: Add pci_enable_atomic_ops_to_root())
   * pci_swizzle_interrupt_pin - swizzle INTx for device behind bridge
   * @dev: the PCI device
   * @pin: the INTx pin (1=INTA, 2=INTB, 3=INTC, 4=INTD)
* Unmerged path drivers/pci/pci.c
diff --git a/include/linux/pci.h b/include/linux/pci.h
index 3316697fb61f..8a6ddedb74fa 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -1921,6 +1921,7 @@ void pci_request_acs(void);
 bool pci_acs_enabled(struct pci_dev *pdev, u16 acs_flags);
 bool pci_acs_path_enabled(struct pci_dev *start,
 			  struct pci_dev *end, u16 acs_flags);
+int pci_enable_atomic_ops_to_root(struct pci_dev *dev, u32 cap_mask);
 
 #define PCI_VPD_LRDT			0x80	/* Large Resource Data Type */
 #define PCI_VPD_LRDT_ID(x)		((x) | PCI_VPD_LRDT)
diff --git a/include/uapi/linux/pci_regs.h b/include/uapi/linux/pci_regs.h
index 16d610857697..16453142b50c 100644
--- a/include/uapi/linux/pci_regs.h
+++ b/include/uapi/linux/pci_regs.h
@@ -621,7 +621,9 @@
 #define PCI_EXP_DEVCAP2		36	/* Device Capabilities 2 */
 #define  PCI_EXP_DEVCAP2_ARI		0x00000020 /* Alternative Routing-ID */
 #define  PCI_EXP_DEVCAP2_ATOMIC_ROUTE	0x00000040 /* Atomic Op routing */
-#define PCI_EXP_DEVCAP2_ATOMIC_COMP64	0x00000100 /* Atomic 64-bit compare */
+#define  PCI_EXP_DEVCAP2_ATOMIC_COMP32	0x00000080 /* 32b AtomicOp completion */
+#define  PCI_EXP_DEVCAP2_ATOMIC_COMP64	0x00000100 /* 64b AtomicOp completion */
+#define  PCI_EXP_DEVCAP2_ATOMIC_COMP128	0x00000200 /* 128b AtomicOp completion */
 #define  PCI_EXP_DEVCAP2_LTR		0x00000800 /* Latency tolerance reporting */
 #define  PCI_EXP_DEVCAP2_OBFF_MASK	0x000c0000 /* OBFF support mechanism */
 #define  PCI_EXP_DEVCAP2_OBFF_MSG	0x00040000 /* New message signaling */
