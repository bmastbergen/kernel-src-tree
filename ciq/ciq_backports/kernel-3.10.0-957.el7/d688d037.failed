perf trace beauty prctl: Generate 'option' string table from kernel headers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit d688d0376c6eb452565c16c95b26cd2c95aa8a82
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d688d037.failed

This is one more case where the way that syscall parameter values are
defined in kernel headers are easy to parse using a shell script that
will then generate the string table that gets used by the prctl 'option'
argument beautifier.

This way as soon as the header syncronization mechanism in perf's build
system detects a change in a copy of a kernel ABI header and that file
is syncronized, we get 'perf trace' updated automagically.

Further work needed for the PR_SET_ values, as well for using eBPF to
copy the non-integer arguments to/from the kernel.

E.g.: System wide prctl tracing:

  # perf trace -e prctl
  1668.028 ( 0.025 ms): TaskSchedulerR/10649 prctl(option: SET_NAME, arg2: 0x2b61d5db15d0) = 0
  3365.663 ( 0.018 ms): chrome/10650 prctl(option: SET_SECCOMP, arg2: 2, arg4: 8         ) = -1 EFAULT Bad address
  3366.585 ( 0.010 ms): chrome/10650 prctl(option: SET_NO_NEW_PRIVS, arg2: 1             ) = 0
  3367.173 ( 0.009 ms): TaskSchedulerR/10652 prctl(option: SET_NAME, arg2: 0x2b61d2aaa300) = 0
  3367.222 ( 0.003 ms): TaskSchedulerR/10653 prctl(option: SET_NAME, arg2: 0x2b61d2aaa1e0) = 0
  3367.244 ( 0.002 ms): TaskSchedulerR/10654 prctl(option: SET_NAME, arg2: 0x2b61d2aaa0c0) = 0
  3367.265 ( 0.002 ms): TaskSchedulerR/10655 prctl(option: SET_NAME, arg2: 0x2b61d2ac7f90) = 0
  3367.281 ( 0.002 ms): Chrome_ChildIO/10656 prctl(option: SET_NAME, arg2: 0x7efbe406bb11) = 0
  3367.220 ( 0.004 ms): TaskSchedulerS/10651 prctl(option: SET_NAME, arg2: 0x2b61d2ac1be0) = 0
  3370.906 ( 0.010 ms): GpuMemoryThrea/10657 prctl(option: SET_NAME, arg2: 0x7efbe386ab11) = 0
  3370.983 ( 0.003 ms): File/10658 prctl(option: SET_NAME, arg2: 0x7efbe3069b11          ) = 0
  3384.272 ( 0.020 ms): Compositor/10659 prctl(option: SET_NAME, arg2: 0x7efbe2868b11    ) = 0
  3612.091 ( 0.012 ms): DOM Worker/11489 prctl(option: SET_NAME, arg2: 0x7f49ab97ebf2    ) = 0
<SNIP>
  4512.437 ( 0.004 ms): (sa1)/11490 prctl(option: SET_NAME, arg2: 0x7ffca15af844         ) = 0
  4512.468 ( 0.002 ms): (sa1)/11490 prctl(option: SET_MM, arg2: ARG_START, arg3: 0x7f5cb7c81000) = 0
  4512.472 ( 0.001 ms): (sa1)/11490 prctl(option: SET_MM, arg2: ARG_END, arg3: 0x7f5cb7c81006) = 0
  4514.667 ( 0.002 ms): (sa1)/11490 prctl(option: GET_SECUREBITS                         ) = 0

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/n/tip-q0s2uw579o5ei6xlh2zjirgz@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit d688d0376c6eb452565c16c95b26cd2c95aa8a82)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Makefile.perf
#	tools/perf/builtin-trace.c
#	tools/perf/trace/beauty/Build
#	tools/perf/trace/beauty/beauty.h
diff --cc tools/perf/Makefile.perf
index bb39fa32cfd3,c872ca607b39..000000000000
--- a/tools/perf/Makefile.perf
+++ b/tools/perf/Makefile.perf
@@@ -377,6 -387,74 +377,77 @@@ export INSTALL SHELL_PAT
  
  SHELL = $(SHELL_PATH)
  
++<<<<<<< HEAD
++=======
+ beauty_outdir := $(OUTPUT)trace/beauty/generated
+ beauty_ioctl_outdir := $(beauty_outdir)/ioctl
+ drm_ioctl_array := $(beauty_ioctl_outdir)/drm_ioctl_array.c
+ drm_hdr_dir := $(srctree)/tools/include/uapi/drm
+ drm_ioctl_tbl := $(srctree)/tools/perf/trace/beauty/drm_ioctl.sh
+ 
+ # Create output directory if not already present
+ _dummy := $(shell [ -d '$(beauty_ioctl_outdir)' ] || mkdir -p '$(beauty_ioctl_outdir)')
+ 
+ $(drm_ioctl_array): $(drm_hdr_dir)/drm.h $(drm_hdr_dir)/i915_drm.h $(drm_ioctl_tbl)
+ 	$(Q)$(SHELL) '$(drm_ioctl_tbl)' $(drm_hdr_dir) > $@
+ 
+ pkey_alloc_access_rights_array := $(beauty_outdir)/pkey_alloc_access_rights_array.c
+ asm_generic_hdr_dir := $(srctree)/tools/include/uapi/asm-generic/
+ pkey_alloc_access_rights_tbl := $(srctree)/tools/perf/trace/beauty/pkey_alloc_access_rights.sh
+ 
+ $(pkey_alloc_access_rights_array): $(asm_generic_hdr_dir)/mman-common.h $(pkey_alloc_access_rights_tbl)
+ 	$(Q)$(SHELL) '$(pkey_alloc_access_rights_tbl)' $(asm_generic_hdr_dir) > $@
+ 
+ sndrv_ctl_ioctl_array := $(beauty_ioctl_outdir)/sndrv_ctl_ioctl_array.c
+ sndrv_ctl_hdr_dir := $(srctree)/tools/include/uapi/sound
+ sndrv_ctl_ioctl_tbl := $(srctree)/tools/perf/trace/beauty/sndrv_ctl_ioctl.sh
+ 
+ $(sndrv_ctl_ioctl_array): $(sndrv_ctl_hdr_dir)/asound.h $(sndrv_ctl_ioctl_tbl)
+ 	$(Q)$(SHELL) '$(sndrv_ctl_ioctl_tbl)' $(sndrv_ctl_hdr_dir) > $@
+ 
+ sndrv_pcm_ioctl_array := $(beauty_ioctl_outdir)/sndrv_pcm_ioctl_array.c
+ sndrv_pcm_hdr_dir := $(srctree)/tools/include/uapi/sound
+ sndrv_pcm_ioctl_tbl := $(srctree)/tools/perf/trace/beauty/sndrv_pcm_ioctl.sh
+ 
+ $(sndrv_pcm_ioctl_array): $(sndrv_pcm_hdr_dir)/asound.h $(sndrv_pcm_ioctl_tbl)
+ 	$(Q)$(SHELL) '$(sndrv_pcm_ioctl_tbl)' $(sndrv_pcm_hdr_dir) > $@
+ 
+ kvm_ioctl_array := $(beauty_ioctl_outdir)/kvm_ioctl_array.c
+ kvm_hdr_dir := $(srctree)/tools/include/uapi/linux
+ kvm_ioctl_tbl := $(srctree)/tools/perf/trace/beauty/kvm_ioctl.sh
+ 
+ $(kvm_ioctl_array): $(kvm_hdr_dir)/kvm.h $(kvm_ioctl_tbl)
+ 	$(Q)$(SHELL) '$(kvm_ioctl_tbl)' $(kvm_hdr_dir) > $@
+ 
+ vhost_virtio_ioctl_array := $(beauty_ioctl_outdir)/vhost_virtio_ioctl_array.c
+ vhost_virtio_hdr_dir := $(srctree)/tools/include/uapi/linux
+ vhost_virtio_ioctl_tbl := $(srctree)/tools/perf/trace/beauty/vhost_virtio_ioctl.sh
+ 
+ $(vhost_virtio_ioctl_array): $(vhost_virtio_hdr_dir)/vhost.h $(vhost_virtio_ioctl_tbl)
+ 	$(Q)$(SHELL) '$(vhost_virtio_ioctl_tbl)' $(vhost_virtio_hdr_dir) > $@
+ 
+ perf_ioctl_array := $(beauty_ioctl_outdir)/perf_ioctl_array.c
+ perf_hdr_dir := $(srctree)/tools/include/uapi/linux
+ perf_ioctl_tbl := $(srctree)/tools/perf/trace/beauty/perf_ioctl.sh
+ 
+ $(perf_ioctl_array): $(perf_hdr_dir)/perf_event.h $(perf_ioctl_tbl)
+ 	$(Q)$(SHELL) '$(perf_ioctl_tbl)' $(perf_hdr_dir) > $@
+ 
+ madvise_behavior_array := $(beauty_outdir)/madvise_behavior_array.c
+ madvise_hdr_dir := $(srctree)/tools/include/uapi/asm-generic/
+ madvise_behavior_tbl := $(srctree)/tools/perf/trace/beauty/madvise_behavior.sh
+ 
+ $(madvise_behavior_array): $(madvise_hdr_dir)/mman-common.h $(madvise_behavior_tbl)
+ 	$(Q)$(SHELL) '$(madvise_behavior_tbl)' $(madvise_hdr_dir) > $@
+ 
+ prctl_option_array := $(beauty_outdir)/prctl_option_array.c
+ prctl_hdr_dir := $(srctree)/tools/include/uapi/linux/
+ prctl_option_tbl := $(srctree)/tools/perf/trace/beauty/prctl_option.sh
+ 
+ $(prctl_option_array): $(prctl_hdr_dir)/prctl.h $(prctl_option_tbl)
+ 	$(Q)$(SHELL) '$(prctl_option_tbl)' $(prctl_hdr_dir) > $@
+ 
++>>>>>>> d688d0376c6e (perf trace beauty prctl: Generate 'option' string table from kernel headers)
  all: shell_compatibility_test $(ALL_PROGRAMS) $(LANG_BINDINGS) $(OTHER_PROGRAMS)
  
  $(OUTPUT)python/perf.so: $(PYTHON_EXT_SRCS) $(PYTHON_EXT_DEPS) $(LIBTRACEEVENT_DYNAMIC_LIST)
@@@ -486,7 -549,15 +557,19 @@@ endi
  __build-dir = $(subst $(OUTPUT),,$(dir $@))
  build-dir   = $(if $(__build-dir),$(__build-dir),.)
  
++<<<<<<< HEAD
 +prepare: $(OUTPUT)PERF-VERSION-FILE $(OUTPUT)common-cmds.h archheaders
++=======
+ prepare: $(OUTPUT)PERF-VERSION-FILE $(OUTPUT)common-cmds.h archheaders $(drm_ioctl_array) \
+ 	$(pkey_alloc_access_rights_array) \
+ 	$(sndrv_pcm_ioctl_array) \
+ 	$(sndrv_ctl_ioctl_array) \
+ 	$(kvm_ioctl_array) \
+ 	$(vhost_virtio_ioctl_array) \
+ 	$(madvise_behavior_array) \
+ 	$(perf_ioctl_array) \
+ 	$(prctl_option_array)
++>>>>>>> d688d0376c6e (perf trace beauty prctl: Generate 'option' string table from kernel headers)
  
  $(OUTPUT)%.o: %.c prepare FORCE
  	$(Q)$(MAKE) -f $(srctree)/tools/build/Makefile.build dir=$(build-dir) $@
@@@ -747,10 -828,18 +830,24 @@@ clean:: $(LIBTRACEEVENT)-clean $(LIBAPI
  	$(call QUIET_CLEAN, core-progs) $(RM) $(ALL_PROGRAMS) perf perf-read-vdso32 perf-read-vdsox32 $(OUTPUT)pmu-events/jevents $(OUTPUT)$(LIBJVMTI).so
  	$(call QUIET_CLEAN, core-gen)   $(RM)  *.spec *.pyc *.pyo */*.pyc */*.pyo $(OUTPUT)common-cmds.h TAGS tags cscope* $(OUTPUT)PERF-VERSION-FILE $(OUTPUT)FEATURE-DUMP $(OUTPUT)util/*-bison* $(OUTPUT)util/*-flex* \
  		$(OUTPUT)util/intel-pt-decoder/inat-tables.c \
++<<<<<<< HEAD
 +		$(OUTPUT)tests/llvm-src-{base,kbuild,prologue}.c \
 +		$(OUTPUT)pmu-events/pmu-events.c
++=======
+ 		$(OUTPUT)tests/llvm-src-{base,kbuild,prologue,relocation}.c \
+ 		$(OUTPUT)pmu-events/pmu-events.c \
+ 		$(OUTPUT)$(madvise_behavior_array) \
+ 		$(OUTPUT)$(drm_ioctl_array) \
+ 		$(OUTPUT)$(pkey_alloc_access_rights_array) \
+ 		$(OUTPUT)$(sndrv_ctl_ioctl_array) \
+ 		$(OUTPUT)$(sndrv_pcm_ioctl_array) \
+ 		$(OUTPUT)$(kvm_ioctl_array) \
+ 		$(OUTPUT)$(vhost_virtio_ioctl_array) \
+ 		$(OUTPUT)$(perf_ioctl_array) \
+ 		$(OUTPUT)$(prctl_option_array)
++>>>>>>> d688d0376c6e (perf trace beauty prctl: Generate 'option' string table from kernel headers)
  	$(QUIET_SUBDIR0)Documentation $(QUIET_SUBDIR1) clean
 +	$(python-clean)
  
  #
  # To provide FEATURE-DUMP into $(FEATURE_DUMP_COPY)
diff --cc tools/perf/builtin-trace.c
index 873215ce6cc7,78855916f4b0..000000000000
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@@ -609,57 -576,45 +609,64 @@@ static struct syscall_fmt 
  	bool	   timeout;
  	bool	   hexret;
  } syscall_fmts[] = {
++<<<<<<< HEAD
 +	{ .name	    = "access",	    .errmsg = true,
 +	  .arg_scnprintf = { [1] = SCA_ACCMODE,  /* mode */ }, },
 +	{ .name	    = "arch_prctl", .errmsg = true, .alias = "prctl", },
++=======
+ 	{ .name	    = "access",
+ 	  .arg = { [1] = { .scnprintf = SCA_ACCMODE,  /* mode */ }, }, },
+ 	{ .name	    = "bpf",
+ 	  .arg = { [0] = STRARRAY(cmd, bpf_cmd), }, },
++>>>>>>> d688d0376c6e (perf trace beauty prctl: Generate 'option' string table from kernel headers)
  	{ .name	    = "brk",	    .hexret = true,
 -	  .arg = { [0] = { .scnprintf = SCA_HEX, /* brk */ }, }, },
 -	{ .name     = "clock_gettime",
 -	  .arg = { [0] = STRARRAY(clk_id, clockid), }, },
 -	{ .name	    = "clone",	    .errpid = true, .nr_args = 5,
 -	  .arg = { [0] = { .name = "flags",	    .scnprintf = SCA_CLONE_FLAGS, },
 -		   [1] = { .name = "child_stack",   .scnprintf = SCA_HEX, },
 -		   [2] = { .name = "parent_tidptr", .scnprintf = SCA_HEX, },
 -		   [3] = { .name = "child_tidptr",  .scnprintf = SCA_HEX, },
 -		   [4] = { .name = "tls",	    .scnprintf = SCA_HEX, }, }, },
 -	{ .name	    = "close",
 -	  .arg = { [0] = { .scnprintf = SCA_CLOSE_FD, /* fd */ }, }, },
 -	{ .name	    = "epoll_ctl",
 -	  .arg = { [1] = STRARRAY(op, epoll_ctl_ops), }, },
 -	{ .name	    = "eventfd2",
 -	  .arg = { [1] = { .scnprintf = SCA_EFD_FLAGS, /* flags */ }, }, },
 -	{ .name	    = "fchmodat",
 -	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* fd */ }, }, },
 -	{ .name	    = "fchownat",
 -	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* fd */ }, }, },
 -	{ .name	    = "fcntl",
 -	  .arg = { [1] = { .scnprintf = SCA_FCNTL_CMD, /* cmd */
 -			   .parm      = &strarrays__fcntl_cmds_arrays,
 -			   .show_zero = true, },
 -		   [2] = { .scnprintf =  SCA_FCNTL_ARG, /* arg */ }, }, },
 -	{ .name	    = "flock",
 -	  .arg = { [1] = { .scnprintf = SCA_FLOCK, /* cmd */ }, }, },
 -	{ .name	    = "fstat", .alias = "newfstat", },
 -	{ .name	    = "fstatat", .alias = "newfstatat", },
 -	{ .name	    = "futex",
 -	  .arg = { [1] = { .scnprintf = SCA_FUTEX_OP, /* op */ }, }, },
 -	{ .name	    = "futimesat",
 -	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* fd */ }, }, },
 -	{ .name	    = "getitimer",
 -	  .arg = { [0] = STRARRAY(which, itimers), }, },
 +	  .arg_scnprintf = { [0] = SCA_HEX, /* brk */ }, },
 +	{ .name	    = "chdir",	    .errmsg = true, },
 +	{ .name	    = "chmod",	    .errmsg = true, },
 +	{ .name	    = "chroot",	    .errmsg = true, },
 +	{ .name     = "clock_gettime",  .errmsg = true, STRARRAY(0, clk_id, clockid), },
 +	{ .name	    = "clone",	    .errpid = true, },
 +	{ .name	    = "close",	    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_CLOSE_FD, /* fd */ }, },
 +	{ .name	    = "connect",    .errmsg = true, },
 +	{ .name	    = "creat",	    .errmsg = true, },
 +	{ .name	    = "dup",	    .errmsg = true, },
 +	{ .name	    = "dup2",	    .errmsg = true, },
 +	{ .name	    = "dup3",	    .errmsg = true, },
 +	{ .name	    = "epoll_ctl",  .errmsg = true, STRARRAY(1, op, epoll_ctl_ops), },
 +	{ .name	    = "eventfd2",   .errmsg = true,
 +	  .arg_scnprintf = { [1] = SCA_EFD_FLAGS, /* flags */ }, },
 +	{ .name	    = "faccessat",  .errmsg = true, },
 +	{ .name	    = "fadvise64",  .errmsg = true, },
 +	{ .name	    = "fallocate",  .errmsg = true, },
 +	{ .name	    = "fchdir",	    .errmsg = true, },
 +	{ .name	    = "fchmod",	    .errmsg = true, },
 +	{ .name	    = "fchmodat",   .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* fd */ }, },
 +	{ .name	    = "fchown",	    .errmsg = true, },
 +	{ .name	    = "fchownat",   .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* fd */ }, },
 +	{ .name	    = "fcntl",	    .errmsg = true,
 +	  .arg_scnprintf = { [1] = SCA_STRARRAYS, /* cmd */ },
 +	  .arg_parm	 = { [1] = &strarrays__fcntl_cmds_arrays, /* cmd */ }, },
 +	{ .name	    = "fdatasync",  .errmsg = true, },
 +	{ .name	    = "flock",	    .errmsg = true,
 +	  .arg_scnprintf = { [1] = SCA_FLOCK, /* cmd */ }, },
 +	{ .name	    = "fsetxattr",  .errmsg = true, },
 +	{ .name	    = "fstat",	    .errmsg = true, .alias = "newfstat", },
 +	{ .name	    = "fstatat",    .errmsg = true, .alias = "newfstatat", },
 +	{ .name	    = "fstatfs",    .errmsg = true, },
 +	{ .name	    = "fsync",    .errmsg = true, },
 +	{ .name	    = "ftruncate", .errmsg = true, },
 +	{ .name	    = "futex",	    .errmsg = true,
 +	  .arg_scnprintf = { [1] = SCA_FUTEX_OP, /* op */ }, },
 +	{ .name	    = "futimesat", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* fd */ }, },
 +	{ .name	    = "getdents",   .errmsg = true, },
 +	{ .name	    = "getdents64", .errmsg = true, },
 +	{ .name	    = "getitimer",  .errmsg = true, STRARRAY(0, which, itimers), },
 +	{ .name	    = "getrandom",  .errmsg = true,
 +	  .arg_scnprintf = { [2] = SCA_GETRANDOM_FLAGS, /* flags */ }, },
  	{ .name	    = "getpid",	    .errpid = true, },
  	{ .name	    = "getpgid",    .errpid = true, },
  	{ .name	    = "getppid",    .errpid = true, },
@@@ -712,132 -658,124 +719,209 @@@
  #if defined(__s390x__)
  	.alias = "old_mmap",
  #endif
 -	  .arg = { [0] = { .scnprintf = SCA_HEX,	/* addr */ },
 -		   [2] = { .scnprintf = SCA_MMAP_PROT,	/* prot */ },
 -		   [3] = { .scnprintf = SCA_MMAP_FLAGS,	/* flags */ }, }, },
 -	{ .name	    = "mprotect",
 -	  .arg = { [0] = { .scnprintf = SCA_HEX,	/* start */ },
 -		   [2] = { .scnprintf = SCA_MMAP_PROT,	/* prot */ }, }, },
 -	{ .name	    = "mq_unlink",
 -	  .arg = { [0] = { .scnprintf = SCA_FILENAME, /* u_name */ }, }, },
 +	  .arg_scnprintf = { [0] = SCA_HEX,	  /* addr */
 +			     [2] = SCA_MMAP_PROT, /* prot */
 +			     [3] = SCA_MMAP_FLAGS, /* flags */ }, },
 +	{ .name	    = "mprotect",   .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_HEX, /* start */
 +			     [2] = SCA_MMAP_PROT, /* prot */ }, },
 +	{ .name	    = "mq_unlink", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FILENAME, /* u_name */ }, },
  	{ .name	    = "mremap",	    .hexret = true,
++<<<<<<< HEAD
 +	  .arg_scnprintf = { [0] = SCA_HEX, /* addr */
 +			     [3] = SCA_MREMAP_FLAGS, /* flags */
 +			     [4] = SCA_HEX, /* new_addr */ }, },
 +	{ .name	    = "munlock",    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_HEX, /* addr */ }, },
 +	{ .name	    = "munmap",	    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_HEX, /* addr */ }, },
 +	{ .name	    = "name_to_handle_at", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dfd */ }, },
 +	{ .name	    = "newfstatat", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dfd */ }, },
 +	{ .name	    = "open",	    .errmsg = true,
 +	  .arg_scnprintf = { [1] = SCA_OPEN_FLAGS, /* flags */ }, },
 +	{ .name	    = "open_by_handle_at", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dfd */
 +			     [2] = SCA_OPEN_FLAGS, /* flags */ }, },
 +	{ .name	    = "openat",	    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dfd */
 +			     [2] = SCA_OPEN_FLAGS, /* flags */ }, },
 +	{ .name	    = "perf_event_open", .errmsg = true,
 +	  .arg_scnprintf = { [2] = SCA_INT, /* cpu */
 +			     [3] = SCA_FD,  /* group_fd */
 +			     [4] = SCA_PERF_FLAGS,  /* flags */ }, },
 +	{ .name	    = "pipe2",	    .errmsg = true,
 +	  .arg_scnprintf = { [1] = SCA_PIPE_FLAGS, /* flags */ }, },
 +	{ .name	    = "poll",	    .errmsg = true, .timeout = true, },
 +	{ .name	    = "ppoll",	    .errmsg = true, .timeout = true, },
 +	{ .name	    = "pread",	    .errmsg = true, .alias = "pread64", },
 +	{ .name	    = "preadv",	    .errmsg = true, .alias = "pread", },
 +	{ .name	    = "prlimit64",  .errmsg = true, STRARRAY(1, resource, rlimit_resources), },
 +	{ .name	    = "pwrite",	    .errmsg = true, .alias = "pwrite64", },
 +	{ .name	    = "pwritev",    .errmsg = true, },
 +	{ .name	    = "read",	    .errmsg = true, },
 +	{ .name	    = "readlink",   .errmsg = true, },
 +	{ .name	    = "readlinkat", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dfd */ }, },
 +	{ .name	    = "readv",	    .errmsg = true, },
 +	{ .name	    = "recvfrom",   .errmsg = true,
 +	  .arg_scnprintf = { [3] = SCA_MSG_FLAGS, /* flags */ }, },
 +	{ .name	    = "recvmmsg",   .errmsg = true,
 +	  .arg_scnprintf = { [3] = SCA_MSG_FLAGS, /* flags */ }, },
 +	{ .name	    = "recvmsg",    .errmsg = true,
 +	  .arg_scnprintf = { [2] = SCA_MSG_FLAGS, /* flags */ }, },
 +	{ .name	    = "removexattr", .errmsg = true, },
 +	{ .name	    = "renameat",   .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dfd */ }, },
 +	{ .name	    = "rmdir",    .errmsg = true, },
 +	{ .name	    = "rt_sigaction", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_SIGNUM, /* sig */ }, },
 +	{ .name	    = "rt_sigprocmask",  .errmsg = true, STRARRAY(0, how, sighow), },
 +	{ .name	    = "rt_sigqueueinfo", .errmsg = true,
 +	  .arg_scnprintf = { [1] = SCA_SIGNUM, /* sig */ }, },
 +	{ .name	    = "rt_tgsigqueueinfo", .errmsg = true,
 +	  .arg_scnprintf = { [2] = SCA_SIGNUM, /* sig */ }, },
 +	{ .name	    = "sched_getattr",	      .errmsg = true, },
 +	{ .name	    = "sched_setattr",	      .errmsg = true, },
 +	{ .name	    = "sched_setscheduler",   .errmsg = true,
 +	  .arg_scnprintf = { [1] = SCA_SCHED_POLICY, /* policy */ }, },
 +	{ .name	    = "seccomp", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_SECCOMP_OP, /* op */
 +			     [1] = SCA_SECCOMP_FLAGS, /* flags */ }, },
 +	{ .name	    = "select",	    .errmsg = true, .timeout = true, },
 +	{ .name	    = "sendmmsg",    .errmsg = true,
 +	  .arg_scnprintf = { [3] = SCA_MSG_FLAGS, /* flags */ }, },
 +	{ .name	    = "sendmsg",    .errmsg = true,
 +	  .arg_scnprintf = { [2] = SCA_MSG_FLAGS, /* flags */ }, },
 +	{ .name	    = "sendto",	    .errmsg = true,
 +	  .arg_scnprintf = { [3] = SCA_MSG_FLAGS, /* flags */ }, },
++=======
+ 	  .arg = { [0] = { .scnprintf = SCA_HEX,	  /* addr */ },
+ 		   [3] = { .scnprintf = SCA_MREMAP_FLAGS, /* flags */ },
+ 		   [4] = { .scnprintf = SCA_HEX,	  /* new_addr */ }, }, },
+ 	{ .name	    = "munlock",
+ 	  .arg = { [0] = { .scnprintf = SCA_HEX, /* addr */ }, }, },
+ 	{ .name	    = "munmap",
+ 	  .arg = { [0] = { .scnprintf = SCA_HEX, /* addr */ }, }, },
+ 	{ .name	    = "name_to_handle_at",
+ 	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* dfd */ }, }, },
+ 	{ .name	    = "newfstatat",
+ 	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* dfd */ }, }, },
+ 	{ .name	    = "open",
+ 	  .arg = { [1] = { .scnprintf = SCA_OPEN_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "open_by_handle_at",
+ 	  .arg = { [0] = { .scnprintf = SCA_FDAT,	/* dfd */ },
+ 		   [2] = { .scnprintf = SCA_OPEN_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "openat",
+ 	  .arg = { [0] = { .scnprintf = SCA_FDAT,	/* dfd */ },
+ 		   [2] = { .scnprintf = SCA_OPEN_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "perf_event_open",
+ 	  .arg = { [2] = { .scnprintf = SCA_INT,	/* cpu */ },
+ 		   [3] = { .scnprintf = SCA_FD,		/* group_fd */ },
+ 		   [4] = { .scnprintf = SCA_PERF_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "pipe2",
+ 	  .arg = { [1] = { .scnprintf = SCA_PIPE_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "pkey_alloc",
+ 	  .arg = { [1] = { .scnprintf = SCA_PKEY_ALLOC_ACCESS_RIGHTS,	/* access_rights */ }, }, },
+ 	{ .name	    = "pkey_free",
+ 	  .arg = { [0] = { .scnprintf = SCA_INT,	/* key */ }, }, },
+ 	{ .name	    = "pkey_mprotect",
+ 	  .arg = { [0] = { .scnprintf = SCA_HEX,	/* start */ },
+ 		   [2] = { .scnprintf = SCA_MMAP_PROT,	/* prot */ },
+ 		   [3] = { .scnprintf = SCA_INT,	/* pkey */ }, }, },
+ 	{ .name	    = "poll", .timeout = true, },
+ 	{ .name	    = "ppoll", .timeout = true, },
+ 	{ .name	    = "prctl", .alias = "arch_prctl",
+ 	  .arg = { [0] = { .scnprintf = SCA_PRCTL_OPTION, /* option */ },
+ 		   [1] = { .scnprintf = SCA_PRCTL_ARG2, /* arg2 */ },
+ 		   [2] = { .scnprintf = SCA_PRCTL_ARG3, /* arg3 */ }, }, },
+ 	{ .name	    = "pread", .alias = "pread64", },
+ 	{ .name	    = "preadv", .alias = "pread", },
+ 	{ .name	    = "prlimit64",
+ 	  .arg = { [1] = STRARRAY(resource, rlimit_resources), }, },
+ 	{ .name	    = "pwrite", .alias = "pwrite64", },
+ 	{ .name	    = "readlinkat",
+ 	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* dfd */ }, }, },
+ 	{ .name	    = "recvfrom",
+ 	  .arg = { [3] = { .scnprintf = SCA_MSG_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "recvmmsg",
+ 	  .arg = { [3] = { .scnprintf = SCA_MSG_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "recvmsg",
+ 	  .arg = { [2] = { .scnprintf = SCA_MSG_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "renameat",
+ 	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* dfd */ }, }, },
+ 	{ .name	    = "rt_sigaction",
+ 	  .arg = { [0] = { .scnprintf = SCA_SIGNUM, /* sig */ }, }, },
+ 	{ .name	    = "rt_sigprocmask",
+ 	  .arg = { [0] = STRARRAY(how, sighow), }, },
+ 	{ .name	    = "rt_sigqueueinfo",
+ 	  .arg = { [1] = { .scnprintf = SCA_SIGNUM, /* sig */ }, }, },
+ 	{ .name	    = "rt_tgsigqueueinfo",
+ 	  .arg = { [2] = { .scnprintf = SCA_SIGNUM, /* sig */ }, }, },
+ 	{ .name	    = "sched_setscheduler",
+ 	  .arg = { [1] = { .scnprintf = SCA_SCHED_POLICY, /* policy */ }, }, },
+ 	{ .name	    = "seccomp",
+ 	  .arg = { [0] = { .scnprintf = SCA_SECCOMP_OP,	   /* op */ },
+ 		   [1] = { .scnprintf = SCA_SECCOMP_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "select", .timeout = true, },
+ 	{ .name	    = "sendmmsg",
+ 	  .arg = { [3] = { .scnprintf = SCA_MSG_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "sendmsg",
+ 	  .arg = { [2] = { .scnprintf = SCA_MSG_FLAGS, /* flags */ }, }, },
+ 	{ .name	    = "sendto",
+ 	  .arg = { [3] = { .scnprintf = SCA_MSG_FLAGS, /* flags */ }, }, },
++>>>>>>> d688d0376c6e (perf trace beauty prctl: Generate 'option' string table from kernel headers)
  	{ .name	    = "set_tid_address", .errpid = true, },
 -	{ .name	    = "setitimer",
 -	  .arg = { [0] = STRARRAY(which, itimers), }, },
 -	{ .name	    = "setrlimit",
 -	  .arg = { [0] = STRARRAY(resource, rlimit_resources), }, },
 -	{ .name	    = "socket",
 -	  .arg = { [0] = STRARRAY(family, socket_families),
 -		   [1] = { .scnprintf = SCA_SK_TYPE, /* type */ }, }, },
 -	{ .name	    = "socketpair",
 -	  .arg = { [0] = STRARRAY(family, socket_families),
 -		   [1] = { .scnprintf = SCA_SK_TYPE, /* type */ }, }, },
 -	{ .name	    = "stat", .alias = "newstat", },
 -	{ .name	    = "statx",
 -	  .arg = { [0] = { .scnprintf = SCA_FDAT,	 /* fdat */ },
 -		   [2] = { .scnprintf = SCA_STATX_FLAGS, /* flags */ } ,
 -		   [3] = { .scnprintf = SCA_STATX_MASK,	 /* mask */ }, }, },
 -	{ .name	    = "swapoff",
 -	  .arg = { [0] = { .scnprintf = SCA_FILENAME, /* specialfile */ }, }, },
 -	{ .name	    = "swapon",
 -	  .arg = { [0] = { .scnprintf = SCA_FILENAME, /* specialfile */ }, }, },
 -	{ .name	    = "symlinkat",
 -	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* dfd */ }, }, },
 -	{ .name	    = "tgkill",
 -	  .arg = { [2] = { .scnprintf = SCA_SIGNUM, /* sig */ }, }, },
 -	{ .name	    = "tkill",
 -	  .arg = { [1] = { .scnprintf = SCA_SIGNUM, /* sig */ }, }, },
 -	{ .name	    = "uname", .alias = "newuname", },
 -	{ .name	    = "unlinkat",
 -	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* dfd */ }, }, },
 -	{ .name	    = "utimensat",
 -	  .arg = { [0] = { .scnprintf = SCA_FDAT, /* dirfd */ }, }, },
 +	{ .name	    = "setitimer",  .errmsg = true, STRARRAY(0, which, itimers), },
 +	{ .name	    = "setpgid",    .errmsg = true, },
 +	{ .name	    = "setrlimit",  .errmsg = true, STRARRAY(0, resource, rlimit_resources), },
 +	{ .name     = "setxattr",   .errmsg = true, },
 +	{ .name     = "shutdown",   .errmsg = true, },
 +	{ .name	    = "socket",	    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_STRARRAY, /* family */
 +			     [1] = SCA_SK_TYPE, /* type */ },
 +	  .arg_parm	 = { [0] = &strarray__socket_families, /* family */ }, },
 +	{ .name	    = "socketpair", .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_STRARRAY, /* family */
 +			     [1] = SCA_SK_TYPE, /* type */ },
 +	  .arg_parm	 = { [0] = &strarray__socket_families, /* family */ }, },
 +	{ .name	    = "stat",	    .errmsg = true, .alias = "newstat", },
 +	{ .name	    = "statfs",	    .errmsg = true, },
 +#if 0
 +	XXX there is no statx syscall in RHEL7
 +
 +	{ .name	    = "statx",	    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* flags */
 +			     [2] = SCA_STATX_FLAGS, /* flags */
 +			     [3] = SCA_STATX_MASK, /* mask */ }, },
 +#endif
 +	{ .name	    = "swapoff",    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FILENAME, /* specialfile */ }, },
 +	{ .name	    = "swapon",	    .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FILENAME, /* specialfile */ }, },
 +	{ .name	    = "symlinkat",  .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dfd */ }, },
 +	{ .name	    = "tgkill",	    .errmsg = true,
 +	  .arg_scnprintf = { [2] = SCA_SIGNUM, /* sig */ }, },
 +	{ .name	    = "tkill",	    .errmsg = true,
 +	  .arg_scnprintf = { [1] = SCA_SIGNUM, /* sig */ }, },
 +	{ .name	    = "truncate",   .errmsg = true, },
 +	{ .name	    = "uname",	    .errmsg = true, .alias = "newuname", },
 +	{ .name	    = "unlinkat",   .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dfd */ }, },
 +	{ .name	    = "utime",  .errmsg = true, },
 +	{ .name	    = "utimensat",  .errmsg = true,
 +	  .arg_scnprintf = { [0] = SCA_FDAT, /* dirfd */ }, },
 +	{ .name	    = "utimes",  .errmsg = true, },
 +	{ .name	    = "vmsplice",  .errmsg = true, },
  	{ .name	    = "wait4",	    .errpid = true,
 -	  .arg = { [2] = { .scnprintf = SCA_WAITID_OPTIONS, /* options */ }, }, },
 +	  .arg_scnprintf = { [2] = SCA_WAITID_OPTIONS, /* options */ }, },
  	{ .name	    = "waitid",	    .errpid = true,
 -	  .arg = { [3] = { .scnprintf = SCA_WAITID_OPTIONS, /* options */ }, }, },
 +	  .arg_scnprintf = { [3] = SCA_WAITID_OPTIONS, /* options */ }, },
 +	{ .name	    = "write",	    .errmsg = true, },
 +	{ .name	    = "writev",	    .errmsg = true, },
  };
  
  static int syscall_fmt__cmp(const void *name, const void *fmtp)
diff --cc tools/perf/trace/beauty/Build
index 55f4f086ea37,2f68b76ec39b..000000000000
--- a/tools/perf/trace/beauty/Build
+++ b/tools/perf/trace/beauty/Build
@@@ -1,2 -1,8 +1,13 @@@
++<<<<<<< HEAD
 +# XXX there's no statx syscall in RHEL7
 +#libperf-y += statx.o
++=======
+ libperf-y += clone.o
+ libperf-y += fcntl.o
+ ifeq ($(SRCARCH),$(filter $(SRCARCH),x86))
+ libperf-y += ioctl.o
+ endif
+ libperf-y += pkey_alloc.o
+ libperf-y += prctl.o
+ libperf-y += statx.o
++>>>>>>> d688d0376c6e (perf trace beauty prctl: Generate 'option' string table from kernel headers)
diff --cc tools/perf/trace/beauty/beauty.h
index d493f9e76cf1,b29f94ef5d6a..000000000000
--- a/tools/perf/trace/beauty/beauty.h
+++ b/tools/perf/trace/beauty/beauty.h
@@@ -51,6 -51,48 +51,51 @@@ unsigned long syscall_arg__val(struct s
  size_t syscall_arg__scnprintf_strarrays(char *bf, size_t size, struct syscall_arg *arg);
  #define SCA_STRARRAYS syscall_arg__scnprintf_strarrays
  
++<<<<<<< HEAD
++=======
+ size_t syscall_arg__scnprintf_fd(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_FD syscall_arg__scnprintf_fd
+ 
+ size_t syscall_arg__scnprintf_hex(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_HEX syscall_arg__scnprintf_hex
+ 
+ size_t syscall_arg__scnprintf_int(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_INT syscall_arg__scnprintf_int
+ 
+ size_t syscall_arg__scnprintf_long(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_LONG syscall_arg__scnprintf_long
+ 
+ size_t syscall_arg__scnprintf_pid(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_PID syscall_arg__scnprintf_pid
+ 
+ size_t syscall_arg__scnprintf_clone_flags(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_CLONE_FLAGS syscall_arg__scnprintf_clone_flags
+ 
+ size_t syscall_arg__scnprintf_fcntl_cmd(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_FCNTL_CMD syscall_arg__scnprintf_fcntl_cmd
+ 
+ size_t syscall_arg__scnprintf_fcntl_arg(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_FCNTL_ARG syscall_arg__scnprintf_fcntl_arg
+ 
+ size_t syscall_arg__scnprintf_ioctl_cmd(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_IOCTL_CMD syscall_arg__scnprintf_ioctl_cmd
+ 
+ size_t syscall_arg__scnprintf_pkey_alloc_access_rights(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_PKEY_ALLOC_ACCESS_RIGHTS syscall_arg__scnprintf_pkey_alloc_access_rights
+ 
+ size_t syscall_arg__scnprintf_open_flags(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_OPEN_FLAGS syscall_arg__scnprintf_open_flags
+ 
+ size_t syscall_arg__scnprintf_prctl_option(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_PRCTL_OPTION syscall_arg__scnprintf_prctl_option
+ 
+ size_t syscall_arg__scnprintf_prctl_arg2(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_PRCTL_ARG2 syscall_arg__scnprintf_prctl_arg2
+ 
+ size_t syscall_arg__scnprintf_prctl_arg3(char *bf, size_t size, struct syscall_arg *arg);
+ #define SCA_PRCTL_ARG3 syscall_arg__scnprintf_prctl_arg3
+ 
++>>>>>>> d688d0376c6e (perf trace beauty prctl: Generate 'option' string table from kernel headers)
  size_t syscall_arg__scnprintf_statx_flags(char *bf, size_t size, struct syscall_arg *arg);
  #define SCA_STATX_FLAGS syscall_arg__scnprintf_statx_flags
  
* Unmerged path tools/perf/Makefile.perf
* Unmerged path tools/perf/builtin-trace.c
* Unmerged path tools/perf/trace/beauty/Build
* Unmerged path tools/perf/trace/beauty/beauty.h
diff --git a/tools/perf/trace/beauty/prctl.c b/tools/perf/trace/beauty/prctl.c
new file mode 100644
index 000000000000..246130dad6c4
--- /dev/null
+++ b/tools/perf/trace/beauty/prctl.c
@@ -0,0 +1,82 @@
+/*
+ * trace/beauty/prctl.c
+ *
+ *  Copyright (C) 2017, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
+ *
+ * Released under the GPL v2. (and only v2, not any later version)
+ */
+
+#include "trace/beauty/beauty.h"
+#include <linux/kernel.h>
+#include <uapi/linux/prctl.h>
+
+#include "trace/beauty/generated/prctl_option_array.c"
+
+static size_t prctl__scnprintf_option(int option, char *bf, size_t size)
+{
+	static DEFINE_STRARRAY(prctl_options);
+	return strarray__scnprintf(&strarray__prctl_options, bf, size, "%d", option);
+}
+
+static size_t prctl__scnprintf_set_mm(int option, char *bf, size_t size)
+{
+	static DEFINE_STRARRAY(prctl_set_mm_options);
+	return strarray__scnprintf(&strarray__prctl_set_mm_options, bf, size, "%d", option);
+}
+
+size_t syscall_arg__scnprintf_prctl_arg2(char *bf, size_t size, struct syscall_arg *arg)
+{
+	int option = syscall_arg__val(arg, 0);
+
+	if (option == PR_SET_MM)
+		return prctl__scnprintf_set_mm(arg->val, bf, size);
+	/*
+	 * We still don't grab the contents of pointers on entry or exit,
+	 * so just print them as hex numbers
+	 */
+	if (option == PR_SET_NAME)
+		return syscall_arg__scnprintf_hex(bf, size, arg);
+
+	return syscall_arg__scnprintf_long(bf, size, arg);
+}
+
+size_t syscall_arg__scnprintf_prctl_arg3(char *bf, size_t size, struct syscall_arg *arg)
+{
+	int option = syscall_arg__val(arg, 0);
+
+	if (option == PR_SET_MM)
+		return syscall_arg__scnprintf_hex(bf, size, arg);
+
+	return syscall_arg__scnprintf_long(bf, size, arg);
+}
+
+size_t syscall_arg__scnprintf_prctl_option(char *bf, size_t size, struct syscall_arg *arg)
+{
+	unsigned long option = arg->val;
+	enum {
+                SPO_ARG2 = (1 << 1),
+                SPO_ARG3 = (1 << 2),
+                SPO_ARG4 = (1 << 3),
+                SPO_ARG5 = (1 << 4),
+                SPO_ARG6 = (1 << 5),
+        };
+	const u8 all_but2 = SPO_ARG3 | SPO_ARG4 | SPO_ARG5 | SPO_ARG6;
+	const u8 all = SPO_ARG2 | all_but2;
+	const u8 masks[] = {
+		[PR_GET_DUMPABLE]	 = all,
+		[PR_SET_DUMPABLE]	 = all_but2,
+		[PR_SET_NAME]		 = all_but2,
+		[PR_GET_CHILD_SUBREAPER] = all_but2,
+		[PR_SET_CHILD_SUBREAPER] = all_but2,
+		[PR_GET_SECUREBITS]	 = all,
+		[PR_SET_SECUREBITS]	 = all_but2,
+		[PR_SET_MM]		 = SPO_ARG4 | SPO_ARG5 | SPO_ARG6,
+		[PR_GET_PDEATHSIG]	 = all,
+		[PR_SET_PDEATHSIG]	 = all_but2,
+	};
+
+	if (option < ARRAY_SIZE(masks))
+		arg->mask |= masks[option];
+
+	return prctl__scnprintf_option(option, bf, size);
+}
diff --git a/tools/perf/trace/beauty/prctl_option.sh b/tools/perf/trace/beauty/prctl_option.sh
new file mode 100755
index 000000000000..0be4138fbe71
--- /dev/null
+++ b/tools/perf/trace/beauty/prctl_option.sh
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+header_dir=$1
+
+printf "static const char *prctl_options[] = {\n"
+regex='^#define[[:space:]]+PR_([GS]ET\w+)[[:space:]]*([[:xdigit:]]+).*'
+egrep $regex ${header_dir}/prctl.h | grep -v PR_SET_PTRACER | \
+	sed -r "s/$regex/\2 \1/g"	| \
+	sort -n | xargs printf "\t[%s] = \"%s\",\n"
+printf "};\n"
+
+printf "static const char *prctl_set_mm_options[] = {\n"
+regex='^#[[:space:]]+define[[:space:]]+PR_SET_MM_(\w+)[[:space:]]*([[:digit:]]+).*'
+egrep $regex ${header_dir}/prctl.h | \
+	sed -r "s/$regex/\2 \1/g"	| \
+	sort -n | xargs printf "\t[%s] = \"%s\",\n"
+printf "};\n"
