NFS: Lock the slot table from a single place during setup sequence

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Anna Schumaker <Anna.Schumaker@Netapp.com>
commit 6994cdd798568a0ddb8e0a85e2af24dbe655c341
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6994cdd7.failed

Rather than implementing this twice for NFS v4.0 and v4.1

	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 6994cdd798568a0ddb8e0a85e2af24dbe655c341)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4proc.c
diff --cc fs/nfs/nfs4proc.c
index 0a1efaa4e649,681cb5e77da2..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -626,11 -629,6 +626,14 @@@ int nfs40_setup_sequence(struct nfs4_sl
  {
  	struct nfs4_slot *slot;
  
++<<<<<<< HEAD
 +	/* slot already allocated? */
 +	if (res->sr_slot != NULL)
 +		goto out_start;
 +
 +	spin_lock(&tbl->slot_tbl_lock);
++=======
++>>>>>>> 6994cdd79856 (NFS: Lock the slot table from a single place during setup sequence)
  	if (nfs4_slot_tbl_draining(tbl) && !args->sa_privileged)
  		goto out_sleep;
  
@@@ -645,9 -642,6 +647,12 @@@
  	slot->privileged = args->sa_privileged ? 1 : 0;
  	args->sa_slot = slot;
  	res->sr_slot = slot;
++<<<<<<< HEAD
 +
 +out_start:
 +	rpc_call_start(task);
++=======
++>>>>>>> 6994cdd79856 (NFS: Lock the slot table from a single place during setup sequence)
  	return 0;
  
  out_sleep:
@@@ -656,10 -650,8 +661,9 @@@
  				NULL, RPC_PRIORITY_PRIVILEGED);
  	else
  		rpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);
- 	spin_unlock(&tbl->slot_tbl_lock);
  	return -EAGAIN;
  }
 +EXPORT_SYMBOL_GPL(nfs40_setup_sequence);
  
  static void nfs40_sequence_free_slot(struct nfs4_sequence_res *res)
  {
@@@ -925,8 -915,6 +927,11 @@@ int nfs41_setup_sequence(struct nfs4_se
  	 */
  	res->sr_status = 1;
  	trace_nfs4_setup_sequence(session, args);
++<<<<<<< HEAD
 +out_success:
 +	rpc_call_start(task);
++=======
++>>>>>>> 6994cdd79856 (NFS: Lock the slot table from a single place during setup sequence)
  	return 0;
  out_sleep:
  	/* Privileged tasks are queued with top priority */
@@@ -935,32 -923,8 +940,31 @@@
  				NULL, RPC_PRIORITY_PRIVILEGED);
  	else
  		rpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);
- 	spin_unlock(&tbl->slot_tbl_lock);
  	return -EAGAIN;
  }
 +EXPORT_SYMBOL_GPL(nfs41_setup_sequence);
 +
 +static int nfs4_setup_sequence(const struct nfs_server *server,
 +			       struct nfs4_sequence_args *args,
 +			       struct nfs4_sequence_res *res,
 +			       struct rpc_task *task)
 +{
 +	struct nfs4_session *session = nfs4_get_session(server->nfs_client);
 +	int ret = 0;
 +
 +	if (!session)
 +		return nfs40_setup_sequence(server->nfs_client->cl_slot_tbl,
 +					    args, res, task);
 +
 +	dprintk("--> %s clp %p session %p sr_slot %u\n",
 +		__func__, session->clp, session, res->sr_slot ?
 +			res->sr_slot->slot_nr : NFS4_NO_SLOT);
 +
 +	ret = nfs41_setup_sequence(session, args, res, task);
 +
 +	dprintk("<-- %s status=%d\n", __func__, ret);
 +	return ret;
 +}
  
  static void nfs41_call_sync_prepare(struct rpc_task *task, void *calldata)
  {
@@@ -1015,6 -970,39 +1019,42 @@@ EXPORT_SYMBOL_GPL(nfs4_sequence_done)
  
  #endif	/* !CONFIG_NFS_V4_1 */
  
++<<<<<<< HEAD
++=======
+ int nfs4_setup_sequence(const struct nfs_client *client,
+ 			struct nfs4_sequence_args *args,
+ 			struct nfs4_sequence_res *res,
+ 			struct rpc_task *task)
+ {
+ 	struct nfs4_session *session = nfs4_get_session(client);
+ 	struct nfs4_slot_table *tbl  = session ? &session->fc_slot_table :
+ 						  client->cl_slot_tbl;
+ 	int ret;
+ 
+ 	/* slot already allocated? */
+ 	if (res->sr_slot != NULL)
+ 		goto out_start;
+ 
+ 	spin_lock(&tbl->slot_tbl_lock);
+ 
+ #if defined(CONFIG_NFS_V4_1)
+ 	if (session)
+ 		ret = nfs41_setup_sequence(session, args, res, task);
+ 	else
+ #endif /* CONFIG_NFS_V4_1 */
+ 		ret = nfs40_setup_sequence(client->cl_slot_tbl, args, res, task);
+ 
+ 	spin_unlock(&tbl->slot_tbl_lock);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ out_start:
+ 	rpc_call_start(task);
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(nfs4_setup_sequence);
+ 
++>>>>>>> 6994cdd79856 (NFS: Lock the slot table from a single place during setup sequence)
  static void nfs40_call_sync_prepare(struct rpc_task *task, void *calldata)
  {
  	struct nfs4_call_sync_data *data = calldata;
* Unmerged path fs/nfs/nfs4proc.c
