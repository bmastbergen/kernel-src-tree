net: sched: introduce chain_head_change callback

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] sched: introduce chain_head_change callback (Ivan Vecera) [1572720]
Rebuild_FUZZ: 94.51%
commit-author Jiri Pirko <jiri@mellanox.com>
commit c7eb7d7230509ec862d4144f7a831f995bc5d028
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c7eb7d72.failed

Add a callback that is to be called whenever head of the chain changes.
Also provide a callback for the default case when the caller gets a
block using non-extended getter.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c7eb7d7230509ec862d4144f7a831f995bc5d028)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/pkt_cls.h
#	net/sched/cls_api.c
#	net/sched/sch_ingress.c
diff --cc include/net/pkt_cls.h
index c1d9bcb11bff,505d4b71975f..000000000000
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@@ -18,6 -18,19 +18,22 @@@ struct tcf_walker 
  int register_tcf_proto_ops(struct tcf_proto_ops *ops);
  int unregister_tcf_proto_ops(struct tcf_proto_ops *ops);
  
++<<<<<<< HEAD
++=======
+ enum tcf_block_binder_type {
+ 	TCF_BLOCK_BINDER_TYPE_UNSPEC,
+ 	TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS,
+ 	TCF_BLOCK_BINDER_TYPE_CLSACT_EGRESS,
+ };
+ 
+ struct tcf_block_ext_info {
+ 	enum tcf_block_binder_type binder_type;
+ 	tcf_chain_head_change_t *chain_head_change;
+ 	void *chain_head_change_priv;
+ };
+ 
+ struct tcf_block_cb;
++>>>>>>> c7eb7d723050 (net: sched: introduce chain_head_change callback)
  bool tcf_queue_work(struct work_struct *work);
  
  #ifdef CONFIG_NET_CLS
@@@ -25,8 -38,12 +41,17 @@@ struct tcf_chain *tcf_chain_get(struct 
  				bool create);
  void tcf_chain_put(struct tcf_chain *chain);
  int tcf_block_get(struct tcf_block **p_block,
++<<<<<<< HEAD
 +		  struct tcf_proto __rcu **p_filter_chain);
 +void tcf_block_put(struct tcf_block *block);
++=======
+ 		  struct tcf_proto __rcu **p_filter_chain, struct Qdisc *q);
+ int tcf_block_get_ext(struct tcf_block **p_block, struct Qdisc *q,
+ 		      struct tcf_block_ext_info *ei);
+ void tcf_block_put(struct tcf_block *block);
+ void tcf_block_put_ext(struct tcf_block *block, struct Qdisc *q,
+ 		       struct tcf_block_ext_info *ei);
++>>>>>>> c7eb7d723050 (net: sched: introduce chain_head_change callback)
  
  static inline struct Qdisc *tcf_block_q(struct tcf_block *block)
  {
@@@ -44,7 -76,14 +69,18 @@@ int tcf_classify(struct sk_buff *skb, c
  #else
  static inline
  int tcf_block_get(struct tcf_block **p_block,
++<<<<<<< HEAD
 +		  struct tcf_proto __rcu **p_filter_chain)
++=======
+ 		  struct tcf_proto __rcu **p_filter_chain, struct Qdisc *q)
+ {
+ 	return 0;
+ }
+ 
+ static inline
+ int tcf_block_get_ext(struct tcf_block **p_block, struct Qdisc *q,
+ 		      struct tcf_block_ext_info *ei)
++>>>>>>> c7eb7d723050 (net: sched: introduce chain_head_change callback)
  {
  	return 0;
  }
@@@ -53,6 -92,12 +89,15 @@@ static inline void tcf_block_put(struc
  {
  }
  
++<<<<<<< HEAD
++=======
+ static inline
+ void tcf_block_put_ext(struct tcf_block *block, struct Qdisc *q,
+ 		       struct tcf_block_ext_info *ei)
+ {
+ }
+ 
++>>>>>>> c7eb7d723050 (net: sched: introduce chain_head_change callback)
  static inline struct Qdisc *tcf_block_q(struct tcf_block *block)
  {
  	return NULL;
diff --cc net/sched/cls_api.c
index 0e9c21220742,206e19f4fc01..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -195,17 -195,23 +195,30 @@@ static struct tcf_chain *tcf_chain_crea
  	return chain;
  }
  
+ static void tcf_chain_head_change(struct tcf_chain *chain,
+ 				  struct tcf_proto *tp_head)
+ {
+ 	if (chain->chain_head_change)
+ 		chain->chain_head_change(tp_head,
+ 					 chain->chain_head_change_priv);
+ }
+ 
  static void tcf_chain_flush(struct tcf_chain *chain)
  {
 -	struct tcf_proto *tp;
 +	struct tcf_proto *tp = rtnl_dereference(chain->filter_chain);
  
++<<<<<<< HEAD
 +	if (chain->p_filter_chain)
 +		RCU_INIT_POINTER(*chain->p_filter_chain, NULL);
 +	while (tp) {
++=======
+ 	tcf_chain_head_change(chain, NULL);
+ 	while ((tp = rtnl_dereference(chain->filter_chain)) != NULL) {
++>>>>>>> c7eb7d723050 (net: sched: introduce chain_head_change callback)
  		RCU_INIT_POINTER(chain->filter_chain, tp->next);
 -		tcf_chain_put(chain);
  		tcf_proto_destroy(tp);
 +		tp = rtnl_dereference(chain->filter_chain);
 +		tcf_chain_put(chain);
  	}
  }
  
@@@ -247,15 -249,35 +260,47 @@@ void tcf_chain_put(struct tcf_chain *ch
  }
  EXPORT_SYMBOL(tcf_chain_put);
  
++<<<<<<< HEAD
 +static void
 +tcf_chain_filter_chain_ptr_set(struct tcf_chain *chain,
 +			       struct tcf_proto __rcu **p_filter_chain)
 +{
 +	chain->p_filter_chain = p_filter_chain;
 +}
 +
 +int tcf_block_get(struct tcf_block **p_block,
 +		  struct tcf_proto __rcu **p_filter_chain)
++=======
+ static void tcf_block_offload_cmd(struct tcf_block *block, struct Qdisc *q,
+ 				  struct tcf_block_ext_info *ei,
+ 				  enum tc_block_command command)
+ {
+ 	struct net_device *dev = q->dev_queue->dev;
+ 	struct tc_block_offload bo = {};
+ 
+ 	if (!dev->netdev_ops->ndo_setup_tc)
+ 		return;
+ 	bo.command = command;
+ 	bo.binder_type = ei->binder_type;
+ 	bo.block = block;
+ 	dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_BLOCK, &bo);
+ }
+ 
+ static void tcf_block_offload_bind(struct tcf_block *block, struct Qdisc *q,
+ 				   struct tcf_block_ext_info *ei)
+ {
+ 	tcf_block_offload_cmd(block, q, ei, TC_BLOCK_BIND);
+ }
+ 
+ static void tcf_block_offload_unbind(struct tcf_block *block, struct Qdisc *q,
+ 				     struct tcf_block_ext_info *ei)
+ {
+ 	tcf_block_offload_cmd(block, q, ei, TC_BLOCK_UNBIND);
+ }
+ 
+ int tcf_block_get_ext(struct tcf_block **p_block, struct Qdisc *q,
+ 		      struct tcf_block_ext_info *ei)
++>>>>>>> c7eb7d723050 (net: sched: introduce chain_head_change callback)
  {
  	struct tcf_block *block = kzalloc(sizeof(*block), GFP_KERNEL);
  	struct tcf_chain *chain;
@@@ -270,7 -294,12 +315,16 @@@
  		err = -ENOMEM;
  		goto err_chain_create;
  	}
++<<<<<<< HEAD
 +	tcf_chain_filter_chain_ptr_set(chain, p_filter_chain);
++=======
+ 	WARN_ON(!ei->chain_head_change);
+ 	chain->chain_head_change = ei->chain_head_change;
+ 	chain->chain_head_change_priv = ei->chain_head_change_priv;
+ 	block->net = qdisc_net(q);
+ 	block->q = q;
+ 	tcf_block_offload_bind(block, q, ei);
++>>>>>>> c7eb7d723050 (net: sched: introduce chain_head_change callback)
  	*p_block = block;
  	return 0;
  
@@@ -278,36 -307,178 +332,87 @@@ err_chain_create
  	kfree(block);
  	return err;
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL(tcf_block_get_ext);
+ 
+ static void tcf_chain_head_change_dflt(struct tcf_proto *tp_head, void *priv)
+ {
+ 	struct tcf_proto __rcu **p_filter_chain = priv;
+ 
+ 	rcu_assign_pointer(*p_filter_chain, tp_head);
+ }
+ 
+ int tcf_block_get(struct tcf_block **p_block,
+ 		  struct tcf_proto __rcu **p_filter_chain, struct Qdisc *q)
+ {
+ 	struct tcf_block_ext_info ei = {
+ 		.chain_head_change = tcf_chain_head_change_dflt,
+ 		.chain_head_change_priv = p_filter_chain,
+ 	};
+ 
+ 	WARN_ON(!p_filter_chain);
+ 	return tcf_block_get_ext(p_block, q, &ei);
+ }
++>>>>>>> c7eb7d723050 (net: sched: introduce chain_head_change callback)
  EXPORT_SYMBOL(tcf_block_get);
  
 -static void tcf_block_put_final(struct work_struct *work)
 -{
 -	struct tcf_block *block = container_of(work, struct tcf_block, work);
 -	struct tcf_chain *chain, *tmp;
 -
 -	rtnl_lock();
 -	/* Only chain 0 should be still here. */
 -	list_for_each_entry_safe(chain, tmp, &block->chain_list, list)
 -		tcf_chain_put(chain);
 -	rtnl_unlock();
 -	kfree(block);
 -}
 -
  /* XXX: Standalone actions are not allowed to jump to any chain, and bound
 - * actions should be all removed after flushing. However, filters are now
 - * destroyed in tc filter workqueue with RTNL lock, they can not race here.
 + * actions should be all removed after flushing.
   */
++<<<<<<< HEAD
++=======
+ void tcf_block_put_ext(struct tcf_block *block, struct Qdisc *q,
+ 		       struct tcf_block_ext_info *ei)
+ {
+ 	struct tcf_chain *chain, *tmp;
+ 
+ 	list_for_each_entry_safe(chain, tmp, &block->chain_list, list)
+ 		tcf_chain_flush(chain);
+ 
+ 	tcf_block_offload_unbind(block, q, ei);
+ 
+ 	INIT_WORK(&block->work, tcf_block_put_final);
+ 	/* Wait for existing RCU callbacks to cool down, make sure their works
+ 	 * have been queued before this. We can not flush pending works here
+ 	 * because we are holding the RTNL lock.
+ 	 */
+ 	rcu_barrier();
+ 	tcf_queue_work(&block->work);
+ }
+ EXPORT_SYMBOL(tcf_block_put_ext);
+ 
++>>>>>>> c7eb7d723050 (net: sched: introduce chain_head_change callback)
  void tcf_block_put(struct tcf_block *block)
  {
 -	struct tcf_block_ext_info ei = {0, };
 +	struct tcf_chain *chain, *tmp;
  
  	if (!block)
  		return;
++<<<<<<< HEAD
++=======
+ 	tcf_block_put_ext(block, block->q, &ei);
+ }
++>>>>>>> c7eb7d723050 (net: sched: introduce chain_head_change callback)
  
 -EXPORT_SYMBOL(tcf_block_put);
 -
 -struct tcf_block_cb {
 -	struct list_head list;
 -	tc_setup_cb_t *cb;
 -	void *cb_ident;
 -	void *cb_priv;
 -	unsigned int refcnt;
 -};
 -
 -void *tcf_block_cb_priv(struct tcf_block_cb *block_cb)
 -{
 -	return block_cb->cb_priv;
 -}
 -EXPORT_SYMBOL(tcf_block_cb_priv);
 -
 -struct tcf_block_cb *tcf_block_cb_lookup(struct tcf_block *block,
 -					 tc_setup_cb_t *cb, void *cb_ident)
 -{	struct tcf_block_cb *block_cb;
 -
 -	list_for_each_entry(block_cb, &block->cb_list, list)
 -		if (block_cb->cb == cb && block_cb->cb_ident == cb_ident)
 -			return block_cb;
 -	return NULL;
 -}
 -EXPORT_SYMBOL(tcf_block_cb_lookup);
 -
 -void tcf_block_cb_incref(struct tcf_block_cb *block_cb)
 -{
 -	block_cb->refcnt++;
 -}
 -EXPORT_SYMBOL(tcf_block_cb_incref);
 -
 -unsigned int tcf_block_cb_decref(struct tcf_block_cb *block_cb)
 -{
 -	return --block_cb->refcnt;
 -}
 -EXPORT_SYMBOL(tcf_block_cb_decref);
 -
 -struct tcf_block_cb *__tcf_block_cb_register(struct tcf_block *block,
 -					     tc_setup_cb_t *cb, void *cb_ident,
 -					     void *cb_priv)
 -{
 -	struct tcf_block_cb *block_cb;
 -
 -	block_cb = kzalloc(sizeof(*block_cb), GFP_KERNEL);
 -	if (!block_cb)
 -		return NULL;
 -	block_cb->cb = cb;
 -	block_cb->cb_ident = cb_ident;
 -	block_cb->cb_priv = cb_priv;
 -	list_add(&block_cb->list, &block->cb_list);
 -	return block_cb;
 -}
 -EXPORT_SYMBOL(__tcf_block_cb_register);
 -
 -int tcf_block_cb_register(struct tcf_block *block,
 -			  tc_setup_cb_t *cb, void *cb_ident,
 -			  void *cb_priv)
 -{
 -	struct tcf_block_cb *block_cb;
 -
 -	block_cb = __tcf_block_cb_register(block, cb, cb_ident, cb_priv);
 -	return block_cb ? 0 : -ENOMEM;
 -}
 -EXPORT_SYMBOL(tcf_block_cb_register);
 -
 -void __tcf_block_cb_unregister(struct tcf_block_cb *block_cb)
 -{
 -	list_del(&block_cb->list);
 -	kfree(block_cb);
 -}
 -EXPORT_SYMBOL(__tcf_block_cb_unregister);
 -
 -void tcf_block_cb_unregister(struct tcf_block *block,
 -			     tc_setup_cb_t *cb, void *cb_ident)
 -{
 -	struct tcf_block_cb *block_cb;
 +	/* Hold a refcnt for all chains, so that they don't disappear
 +	 * while we are iterating.
 +	 */
 +	list_for_each_entry(chain, &block->chain_list, list)
 +		tcf_chain_hold(chain);
  
 -	block_cb = tcf_block_cb_lookup(block, cb, cb_ident);
 -	if (!block_cb)
 -		return;
 -	__tcf_block_cb_unregister(block_cb);
 -}
 -EXPORT_SYMBOL(tcf_block_cb_unregister);
 +	list_for_each_entry(chain, &block->chain_list, list)
 +		tcf_chain_flush(chain);
  
 -static int tcf_block_cb_call(struct tcf_block *block, enum tc_setup_type type,
 -			     void *type_data, bool err_stop)
 -{
 -	struct tcf_block_cb *block_cb;
 -	int ok_count = 0;
 -	int err;
 +	/* At this point, all the chains should have refcnt >= 1. */
 +	list_for_each_entry_safe(chain, tmp, &block->chain_list, list)
 +		tcf_chain_put(chain);
  
 -	list_for_each_entry(block_cb, &block->cb_list, list) {
 -		err = block_cb->cb(type, type_data, block_cb->cb_priv);
 -		if (err) {
 -			if (err_stop)
 -				return err;
 -		} else {
 -			ok_count++;
 -		}
 -	}
 -	return ok_count;
 +	/* Finally, put chain 0 and allow block to be freed. */
 +	chain = list_first_entry(&block->chain_list, struct tcf_chain, list);
 +	tcf_chain_put(chain);
  }
 +EXPORT_SYMBOL(tcf_block_put);
  
  /* Main classifier routine: scans classifier chain attached
   * to this qdisc, (optionally) tests for protocol and asks
diff --cc net/sched/sch_ingress.c
index 790eb0f81e70,811845815b8c..000000000000
--- a/net/sched/sch_ingress.c
+++ b/net/sched/sch_ingress.c
@@@ -59,7 -67,11 +66,15 @@@ static int ingress_init(struct Qdisc *s
  	struct net_device *dev = qdisc_dev(sch);
  	int err;
  
++<<<<<<< HEAD
 +	err = tcf_block_get(&q->block, &dev->ingress_cl_list);
++=======
+ 	q->block_info.binder_type = TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS;
+ 	q->block_info.chain_head_change = clsact_chain_head_change;
+ 	q->block_info.chain_head_change_priv = &dev->ingress_cl_list;
+ 
+ 	err = tcf_block_get_ext(&q->block, sch, &q->block_info);
++>>>>>>> c7eb7d723050 (net: sched: introduce chain_head_change callback)
  	if (err)
  		return err;
  
@@@ -73,7 -85,7 +88,11 @@@ static void ingress_destroy(struct Qdis
  {
  	struct ingress_sched_data *q = qdisc_priv(sch);
  
++<<<<<<< HEAD
 +	tcf_block_put(q->block);
++=======
+ 	tcf_block_put_ext(q->block, sch, &q->block_info);
++>>>>>>> c7eb7d723050 (net: sched: introduce chain_head_change callback)
  	net_dec_ingress_queue();
  }
  
@@@ -153,13 -167,21 +172,29 @@@ static int clsact_init(struct Qdisc *sc
  	struct net_device *dev = qdisc_dev(sch);
  	int err;
  
++<<<<<<< HEAD
 +	err = tcf_block_get(&q->ingress_block, &dev->ingress_cl_list);
 +	if (err)
 +		return err;
 +
 +	err = tcf_block_get(&q->egress_block, &dev->extended->egress_cl_list);
++=======
+ 	q->ingress_block_info.binder_type = TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS;
+ 	q->ingress_block_info.chain_head_change = clsact_chain_head_change;
+ 	q->ingress_block_info.chain_head_change_priv = &dev->ingress_cl_list;
+ 
+ 	err = tcf_block_get_ext(&q->ingress_block, sch, &q->ingress_block_info);
+ 	if (err)
+ 		return err;
+ 
+ 	q->egress_block_info.binder_type = TCF_BLOCK_BINDER_TYPE_CLSACT_EGRESS;
+ 	q->egress_block_info.chain_head_change = clsact_chain_head_change;
+ 	q->egress_block_info.chain_head_change_priv = &dev->egress_cl_list;
+ 
+ 	err = tcf_block_get_ext(&q->egress_block, sch, &q->egress_block_info);
++>>>>>>> c7eb7d723050 (net: sched: introduce chain_head_change callback)
  	if (err)
 -		goto err_egress_block_get;
 +		return err;
  
  	net_inc_ingress_queue();
  	net_inc_egress_queue();
@@@ -167,14 -189,18 +202,26 @@@
  	sch->flags |= TCQ_F_CPUSTATS;
  
  	return 0;
++<<<<<<< HEAD
++=======
+ 
+ err_egress_block_get:
+ 	tcf_block_put_ext(q->ingress_block, sch, &q->ingress_block_info);
+ 	return err;
++>>>>>>> c7eb7d723050 (net: sched: introduce chain_head_change callback)
  }
  
  static void clsact_destroy(struct Qdisc *sch)
  {
  	struct clsact_sched_data *q = qdisc_priv(sch);
  
++<<<<<<< HEAD
 +	tcf_block_put(q->egress_block);
 +	tcf_block_put(q->ingress_block);
++=======
+ 	tcf_block_put_ext(q->egress_block, sch, &q->egress_block_info);
+ 	tcf_block_put_ext(q->ingress_block, sch, &q->ingress_block_info);
++>>>>>>> c7eb7d723050 (net: sched: introduce chain_head_change callback)
  
  	net_dec_ingress_queue();
  	net_dec_egress_queue();
* Unmerged path include/net/pkt_cls.h
diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h
index 3ef0057615ac..5e79f32f89fa 100644
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@ -275,9 +275,12 @@ struct qdisc_skb_cb {
 	unsigned char		data[QDISC_CB_PRIV_LEN];
 };
 
+typedef void tcf_chain_head_change_t(struct tcf_proto *tp_head, void *priv);
+
 struct tcf_chain {
 	struct tcf_proto __rcu *filter_chain;
-	struct tcf_proto __rcu **p_filter_chain;
+	tcf_chain_head_change_t *chain_head_change;
+	void *chain_head_change_priv;
 	struct list_head list;
 	struct tcf_block *block;
 	u32 index; /* chain index */
* Unmerged path net/sched/cls_api.c
* Unmerged path net/sched/sch_ingress.c
