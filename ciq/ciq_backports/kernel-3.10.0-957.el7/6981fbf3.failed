Drivers: hv: vmbus: Expose per-channel interrupts and events counters

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [hv] hv: vmbus: Expose per-channel interrupts and events counters (Mohammed Gamal) [1551622]
Rebuild_FUZZ: 93.02%
commit-author Stephen Hemminger <stephen@networkplumber.org>
commit 6981fbf3780366093858c5d2dcdaadcd1fbb04be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6981fbf3.failed

When investigating performance, it is useful to be able to look at
the number of host and guest events per-channel. This is equivalent
to per-device interrupt statistics.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 6981fbf3780366093858c5d2dcdaadcd1fbb04be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/ABI/stable/sysfs-bus-vmbus
#	drivers/hv/vmbus_drv.c
diff --cc drivers/hv/vmbus_drv.c
index 45ec8d5b4b72,bca8188f3c8c..000000000000
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@@ -1184,6 -1137,159 +1186,162 @@@ void vmbus_driver_unregister(struct hv_
  }
  EXPORT_SYMBOL_GPL(vmbus_driver_unregister);
  
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Called when last reference to channel is gone.
+  */
+ static void vmbus_chan_release(struct kobject *kobj)
+ {
+ 	struct vmbus_channel *channel
+ 		= container_of(kobj, struct vmbus_channel, kobj);
+ 
+ 	kfree_rcu(channel, rcu);
+ }
+ 
+ struct vmbus_chan_attribute {
+ 	struct attribute attr;
+ 	ssize_t (*show)(const struct vmbus_channel *chan, char *buf);
+ 	ssize_t (*store)(struct vmbus_channel *chan,
+ 			 const char *buf, size_t count);
+ };
+ #define VMBUS_CHAN_ATTR(_name, _mode, _show, _store) \
+ 	struct vmbus_chan_attribute chan_attr_##_name \
+ 		= __ATTR(_name, _mode, _show, _store)
+ #define VMBUS_CHAN_ATTR_RW(_name) \
+ 	struct vmbus_chan_attribute chan_attr_##_name = __ATTR_RW(_name)
+ #define VMBUS_CHAN_ATTR_RO(_name) \
+ 	struct vmbus_chan_attribute chan_attr_##_name = __ATTR_RO(_name)
+ #define VMBUS_CHAN_ATTR_WO(_name) \
+ 	struct vmbus_chan_attribute chan_attr_##_name = __ATTR_WO(_name)
+ 
+ static ssize_t vmbus_chan_attr_show(struct kobject *kobj,
+ 				    struct attribute *attr, char *buf)
+ {
+ 	const struct vmbus_chan_attribute *attribute
+ 		= container_of(attr, struct vmbus_chan_attribute, attr);
+ 	const struct vmbus_channel *chan
+ 		= container_of(kobj, struct vmbus_channel, kobj);
+ 
+ 	if (!attribute->show)
+ 		return -EIO;
+ 
+ 	return attribute->show(chan, buf);
+ }
+ 
+ static const struct sysfs_ops vmbus_chan_sysfs_ops = {
+ 	.show = vmbus_chan_attr_show,
+ };
+ 
+ static ssize_t out_mask_show(const struct vmbus_channel *channel, char *buf)
+ {
+ 	const struct hv_ring_buffer_info *rbi = &channel->outbound;
+ 
+ 	return sprintf(buf, "%u\n", rbi->ring_buffer->interrupt_mask);
+ }
+ VMBUS_CHAN_ATTR_RO(out_mask);
+ 
+ static ssize_t in_mask_show(const struct vmbus_channel *channel, char *buf)
+ {
+ 	const struct hv_ring_buffer_info *rbi = &channel->inbound;
+ 
+ 	return sprintf(buf, "%u\n", rbi->ring_buffer->interrupt_mask);
+ }
+ VMBUS_CHAN_ATTR_RO(in_mask);
+ 
+ static ssize_t read_avail_show(const struct vmbus_channel *channel, char *buf)
+ {
+ 	const struct hv_ring_buffer_info *rbi = &channel->inbound;
+ 
+ 	return sprintf(buf, "%u\n", hv_get_bytes_to_read(rbi));
+ }
+ VMBUS_CHAN_ATTR_RO(read_avail);
+ 
+ static ssize_t write_avail_show(const struct vmbus_channel *channel, char *buf)
+ {
+ 	const struct hv_ring_buffer_info *rbi = &channel->outbound;
+ 
+ 	return sprintf(buf, "%u\n", hv_get_bytes_to_write(rbi));
+ }
+ VMBUS_CHAN_ATTR_RO(write_avail);
+ 
+ static ssize_t show_target_cpu(const struct vmbus_channel *channel, char *buf)
+ {
+ 	return sprintf(buf, "%u\n", channel->target_cpu);
+ }
+ VMBUS_CHAN_ATTR(cpu, S_IRUGO, show_target_cpu, NULL);
+ 
+ static ssize_t channel_pending_show(const struct vmbus_channel *channel,
+ 				    char *buf)
+ {
+ 	return sprintf(buf, "%d\n",
+ 		       channel_pending(channel,
+ 				       vmbus_connection.monitor_pages[1]));
+ }
+ VMBUS_CHAN_ATTR(pending, S_IRUGO, channel_pending_show, NULL);
+ 
+ static ssize_t channel_latency_show(const struct vmbus_channel *channel,
+ 				    char *buf)
+ {
+ 	return sprintf(buf, "%d\n",
+ 		       channel_latency(channel,
+ 				       vmbus_connection.monitor_pages[1]));
+ }
+ VMBUS_CHAN_ATTR(latency, S_IRUGO, channel_latency_show, NULL);
+ 
+ static ssize_t channel_interrupts_show(const struct vmbus_channel *channel, char *buf)
+ {
+ 	return sprintf(buf, "%llu\n", channel->interrupts);
+ }
+ VMBUS_CHAN_ATTR(interrupts, S_IRUGO, channel_interrupts_show, NULL);
+ 
+ static ssize_t channel_events_show(const struct vmbus_channel *channel, char *buf)
+ {
+ 	return sprintf(buf, "%llu\n", channel->sig_events);
+ }
+ VMBUS_CHAN_ATTR(events, S_IRUGO, channel_events_show, NULL);
+ 
+ static struct attribute *vmbus_chan_attrs[] = {
+ 	&chan_attr_out_mask.attr,
+ 	&chan_attr_in_mask.attr,
+ 	&chan_attr_read_avail.attr,
+ 	&chan_attr_write_avail.attr,
+ 	&chan_attr_cpu.attr,
+ 	&chan_attr_pending.attr,
+ 	&chan_attr_latency.attr,
+ 	&chan_attr_interrupts.attr,
+ 	&chan_attr_events.attr,
+ 	NULL
+ };
+ 
+ static struct kobj_type vmbus_chan_ktype = {
+ 	.sysfs_ops = &vmbus_chan_sysfs_ops,
+ 	.release = vmbus_chan_release,
+ 	.default_attrs = vmbus_chan_attrs,
+ };
+ 
+ /*
+  * vmbus_add_channel_kobj - setup a sub-directory under device/channels
+  */
+ int vmbus_add_channel_kobj(struct hv_device *dev, struct vmbus_channel *channel)
+ {
+ 	struct kobject *kobj = &channel->kobj;
+ 	u32 relid = channel->offermsg.child_relid;
+ 	int ret;
+ 
+ 	kobj->kset = dev->channels_kset;
+ 	ret = kobject_init_and_add(kobj, &vmbus_chan_ktype, NULL,
+ 				   "%u", relid);
+ 	if (ret)
+ 		return ret;
+ 
+ 	kobject_uevent(kobj, KOBJ_ADD);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 6981fbf37803 (Drivers: hv: vmbus: Expose per-channel interrupts and events counters)
  /*
   * vmbus_device_create - Creates and registers a new child device
   * on the vmbus.
* Unmerged path Documentation/ABI/stable/sysfs-bus-vmbus
* Unmerged path Documentation/ABI/stable/sysfs-bus-vmbus
diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index f41901f80b64..b06a6b796819 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -409,6 +409,8 @@ void vmbus_set_event(struct vmbus_channel *channel)
 	if (!channel->is_dedicated_interrupt)
 		vmbus_send_interrupt(child_relid);
 
+	++channel->sig_events;
+
 	hv_do_fast_hypercall8(HVCALL_SIGNAL_EVENT, channel->sig_event);
 }
 EXPORT_SYMBOL_GPL(vmbus_set_event);
* Unmerged path drivers/hv/vmbus_drv.c
diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 24e1840de3ae..af459d60a102 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -713,6 +713,10 @@ struct vmbus_channel {
 
 	struct vmbus_close_msg close_msg;
 
+	/* Statistics */
+	u64	interrupts;	/* Host to Guest interrupts */
+	u64	sig_events;	/* Guest to Host events */
+
 	/* Channel callback's invoked in softirq context */
 	struct tasklet_struct callback_event;
 	void (*onchannel_callback)(void *context);
