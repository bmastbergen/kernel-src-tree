iio: magnetometer: separate the values of attributes based on their usage type for HID compass sensor

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iio] magnetometer: separate the values of attributes based on their usage type for HID compass sensor (Tony Camuso) [1559170]
Rebuild_FUZZ: 97.46%
commit-author Ooi, Joyce <joyce.ooi@intel.com>
commit 6f771d0b338d59c492699814b0fe554f9d1ee27c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6f771d0b.failed

There are 2 usage types (Magnetic Flux and Heading data field) for HID
compass sensor, thus the values of offset, scale, and sensitivity should
be separated according to their respective usage type. The changes made
are as below:
1. Hysteresis: A struct hid_sensor_common rot_attributes is created in
struct magn_3d_state to contain the sensitivity for IIO_ROT.
2. Scale: scale_pre_decml and scale_post_decml are separated for IIO_MAGN
and IIO_ROT.
3. Offset: Same as scale, value_offset is separated for IIO_MAGN and
IIO_ROT.

For sensitivity, HID_USAGE_SENSOR_ORIENT_MAGN_FLUX and
HID_USAGE_SENSOR_ORIENT_MAGN_HEADING are used for sensivitity fields based
on the HID Sensor Usages specifications. Hence, these changes are added on
the sensitivity field.

	Signed-off-by: Ooi, Joyce <joyce.ooi@intel.com>
	Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit 6f771d0b338d59c492699814b0fe554f9d1ee27c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iio/magnetometer/hid-sensor-magn-3d.c
diff --cc drivers/iio/magnetometer/hid-sensor-magn-3d.c
index a37c031493e7,0e791b02ed4a..000000000000
--- a/drivers/iio/magnetometer/hid-sensor-magn-3d.c
+++ b/drivers/iio/magnetometer/hid-sensor-magn-3d.c
@@@ -38,15 -38,30 +38,34 @@@ enum magn_3d_channel 
  	MAGN_3D_CHANNEL_MAX,
  };
  
+ struct common_attributes {
+ 	int scale_pre_decml;
+ 	int scale_post_decml;
+ 	int scale_precision;
+ 	int value_offset;
+ };
+ 
  struct magn_3d_state {
  	struct hid_sensor_hub_callbacks callbacks;
- 	struct hid_sensor_common common_attributes;
+ 	struct hid_sensor_common magn_flux_attributes;
+ 	struct hid_sensor_common rot_attributes;
  	struct hid_sensor_hub_attribute_info magn[MAGN_3D_CHANNEL_MAX];
++<<<<<<< HEAD
 +	u32 magn_val[MAGN_3D_CHANNEL_MAX];
 +	int scale_pre_decml;
 +	int scale_post_decml;
 +	int scale_precision;
 +	int value_offset;
++=======
+ 
+ 	/* dynamically sized array to hold sensor values */
+ 	u32 *iio_vals;
+ 	/* array of pointers to sensor value */
+ 	u32 *magn_val_addr[MAGN_3D_CHANNEL_MAX];
+ 
+ 	struct common_attributes magn_flux_attr;
+ 	struct common_attributes rot_attr;
++>>>>>>> 6f771d0b338d (iio: magnetometer: separate the values of attributes based on their usage type for HID compass sensor)
  };
  
  static const u32 magn_3d_addresses[MAGN_3D_CHANNEL_MAX] = {
@@@ -117,29 -168,25 +136,35 @@@ static int magn_3d_read_raw(struct iio_
  	*val2 = 0;
  	switch (mask) {
  	case 0:
++<<<<<<< HEAD
 +		poll_value = hid_sensor_read_poll_value(
 +					&magn_state->common_attributes);
 +		if (poll_value < 0)
 +				return -EINVAL;
 +
 +		hid_sensor_power_state(&magn_state->common_attributes, true);
 +		msleep_interruptible(poll_value * 2);
 +
++=======
+ 		hid_sensor_power_state(&magn_state->magn_flux_attributes, true);
++>>>>>>> 6f771d0b338d (iio: magnetometer: separate the values of attributes based on their usage type for HID compass sensor)
  		report_id =
 -			magn_state->magn[chan->address].report_id;
 -		address = magn_3d_addresses[chan->address];
 +			magn_state->magn[chan->scan_index].report_id;
 +		address = magn_3d_addresses[chan->scan_index];
  		if (report_id >= 0)
  			*val = sensor_hub_input_attr_get_raw_value(
- 				magn_state->common_attributes.hsdev,
+ 				magn_state->magn_flux_attributes.hsdev,
  				HID_USAGE_SENSOR_COMPASS_3D, address,
 -				report_id,
 -				SENSOR_HUB_SYNC);
 +				report_id);
  		else {
  			*val = 0;
- 			hid_sensor_power_state(&magn_state->common_attributes,
- 						false);
+ 			hid_sensor_power_state(
+ 				&magn_state->magn_flux_attributes,
+ 				false);
  			return -EINVAL;
  		}
- 		hid_sensor_power_state(&magn_state->common_attributes, false);
+ 		hid_sensor_power_state(&magn_state->magn_flux_attributes,
+ 					false);
  		ret_type = IIO_VAL_INT;
  		break;
  	case IIO_CHAN_INFO_SCALE:
@@@ -215,10 -303,8 +281,15 @@@ static int magn_3d_proc_event(struct hi
  	struct magn_3d_state *magn_state = iio_priv(indio_dev);
  
  	dev_dbg(&indio_dev->dev, "magn_3d_proc_event\n");
++<<<<<<< HEAD
 +	if (atomic_read(&magn_state->common_attributes.data_ready))
 +		hid_sensor_push_data(indio_dev,
 +				(u8 *)magn_state->magn_val,
 +				sizeof(magn_state->magn_val));
++=======
+ 	if (atomic_read(&magn_state->magn_flux_attributes.data_ready))
+ 		hid_sensor_push_data(indio_dev, magn_state->iio_vals);
++>>>>>>> 6f771d0b338d (iio: magnetometer: separate the values of attributes based on their usage type for HID compass sensor)
  
  	return 0;
  }
@@@ -278,24 -390,99 +349,103 @@@ static int magn_3d_parse_report(struct 
  			st->magn[1].index, st->magn[1].report_id,
  			st->magn[2].index, st->magn[2].report_id);
  
++<<<<<<< HEAD
 +	st->scale_precision = hid_sensor_format_scale(
++=======
+ 	/* Setup IIO channel array */
+ 	_channels = devm_kcalloc(&pdev->dev, attr_count,
+ 				sizeof(struct iio_chan_spec),
+ 				GFP_KERNEL);
+ 	if (!_channels) {
+ 		dev_err(&pdev->dev,
+ 			"failed to allocate space for iio channels\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	st->iio_vals = devm_kcalloc(&pdev->dev, attr_count,
+ 				sizeof(u32),
+ 				GFP_KERNEL);
+ 	if (!st->iio_vals) {
+ 		dev_err(&pdev->dev,
+ 			"failed to allocate space for iio values array\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	for (i = 0, *chan_count = 0;
+ 	i < MAGN_3D_CHANNEL_MAX && *chan_count < attr_count;
+ 	i++){
+ 		if (st->magn[i].index >= 0) {
+ 			/* Setup IIO channel struct */
+ 			(_channels[*chan_count]) = magn_3d_channels[i];
+ 			(_channels[*chan_count]).scan_index = *chan_count;
+ 			(_channels[*chan_count]).address = i;
+ 
+ 			/* Set magn_val_addr to iio value address */
+ 			st->magn_val_addr[i] = &(st->iio_vals[*chan_count]);
+ 			magn_3d_adjust_channel_bit_mask(_channels,
+ 							*chan_count,
+ 							st->magn[i].size);
+ 			(*chan_count)++;
+ 		}
+ 	}
+ 
+ 	if (*chan_count <= 0) {
+ 		dev_err(&pdev->dev,
+ 			"failed to find any magnetic channels setup\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	*channels = _channels;
+ 
+ 	dev_dbg(&pdev->dev, "magn_3d Setup %d IIO channels\n",
+ 			*chan_count);
+ 
+ 	st->magn_flux_attr.scale_precision = hid_sensor_format_scale(
++>>>>>>> 6f771d0b338d (iio: magnetometer: separate the values of attributes based on their usage type for HID compass sensor)
  				HID_USAGE_SENSOR_COMPASS_3D,
  				&st->magn[CHANNEL_SCAN_INDEX_X],
- 				&st->scale_pre_decml, &st->scale_post_decml);
+ 				&st->magn_flux_attr.scale_pre_decml,
+ 				&st->magn_flux_attr.scale_post_decml);
+ 	st->rot_attr.scale_precision
+ 		= hid_sensor_format_scale(
+ 			HID_USAGE_SENSOR_ORIENT_COMP_MAGN_NORTH,
+ 			&st->magn[CHANNEL_SCAN_INDEX_NORTH_MAGN_TILT_COMP],
+ 			&st->rot_attr.scale_pre_decml,
+ 			&st->rot_attr.scale_post_decml);
  
  	/* Set Sensitivity field ids, when there is no individual modifier */
- 	if (st->common_attributes.sensitivity.index < 0) {
+ 	if (st->magn_flux_attributes.sensitivity.index < 0) {
  		sensor_hub_input_get_attribute_info(hsdev,
  			HID_FEATURE_REPORT, usage_id,
  			HID_USAGE_SENSOR_DATA_MOD_CHANGE_SENSITIVITY_ABS |
  			HID_USAGE_SENSOR_DATA_ORIENTATION,
- 			&st->common_attributes.sensitivity);
+ 			&st->magn_flux_attributes.sensitivity);
  		dev_dbg(&pdev->dev, "Sensitivity index:report %d:%d\n",
- 			st->common_attributes.sensitivity.index,
- 			st->common_attributes.sensitivity.report_id);
+ 			st->magn_flux_attributes.sensitivity.index,
+ 			st->magn_flux_attributes.sensitivity.report_id);
+ 	}
+ 	if (st->magn_flux_attributes.sensitivity.index < 0) {
+ 		sensor_hub_input_get_attribute_info(hsdev,
+ 			HID_FEATURE_REPORT, usage_id,
+ 			HID_USAGE_SENSOR_DATA_MOD_CHANGE_SENSITIVITY_ABS |
+ 			HID_USAGE_SENSOR_ORIENT_MAGN_FLUX,
+ 			&st->magn_flux_attributes.sensitivity);
+ 		dev_dbg(&pdev->dev, "Sensitivity index:report %d:%d\n",
+ 			st->magn_flux_attributes.sensitivity.index,
+ 			st->magn_flux_attributes.sensitivity.report_id);
+ 	}
+ 	if (st->rot_attributes.sensitivity.index < 0) {
+ 		sensor_hub_input_get_attribute_info(hsdev,
+ 			HID_FEATURE_REPORT, usage_id,
+ 			HID_USAGE_SENSOR_DATA_MOD_CHANGE_SENSITIVITY_ABS |
+ 			HID_USAGE_SENSOR_ORIENT_COMP_MAGN_NORTH,
+ 			&st->rot_attributes.sensitivity);
+ 		dev_dbg(&pdev->dev, "Sensitivity index:report %d:%d\n",
+ 			st->rot_attributes.sensitivity.index,
+ 			st->rot_attributes.sensitivity.report_id);
  	}
  
 -	return 0;
 +	return ret;
  }
  
  /* Function to initialize the processing for usage id */
@@@ -326,19 -514,14 +476,20 @@@ static int hid_magn_3d_probe(struct pla
  		dev_err(&pdev->dev, "failed to setup common attributes\n");
  		return ret;
  	}
+ 	magn_state->rot_attributes = magn_state->magn_flux_attributes;
  
 -	ret = magn_3d_parse_report(pdev, hsdev,
 -				&channels, &chan_count,
 +	channels = kmemdup(magn_3d_channels, sizeof(magn_3d_channels),
 +			   GFP_KERNEL);
 +	if (!channels) {
 +		dev_err(&pdev->dev, "failed to duplicate channels\n");
 +		return -ENOMEM;
 +	}
 +
 +	ret = magn_3d_parse_report(pdev, hsdev, channels,
  				HID_USAGE_SENSOR_COMPASS_3D, magn_state);
  	if (ret) {
 -		dev_err(&pdev->dev, "failed to parse report\n");
 -		return ret;
 +		dev_err(&pdev->dev, "failed to setup attributes\n");
 +		goto error_free_dev_mem;
  	}
  
  	indio_dev->channels = channels;
@@@ -352,11 -535,11 +503,11 @@@
  		NULL, NULL);
  	if (ret) {
  		dev_err(&pdev->dev, "failed to initialize trigger buffer\n");
 -		return ret;
 +		goto error_free_dev_mem;
  	}
- 	atomic_set(&magn_state->common_attributes.data_ready, 0);
+ 	atomic_set(&magn_state->magn_flux_attributes.data_ready, 0);
  	ret = hid_sensor_setup_trigger(indio_dev, name,
- 					&magn_state->common_attributes);
+ 					&magn_state->magn_flux_attributes);
  	if (ret < 0) {
  		dev_err(&pdev->dev, "trigger setup failed\n");
  		goto error_unreg_buffer_funcs;
@@@ -383,11 -566,9 +534,11 @@@
  error_iio_unreg:
  	iio_device_unregister(indio_dev);
  error_remove_trigger:
- 	hid_sensor_remove_trigger(&magn_state->common_attributes);
+ 	hid_sensor_remove_trigger(&magn_state->magn_flux_attributes);
  error_unreg_buffer_funcs:
  	iio_triggered_buffer_cleanup(indio_dev);
 +error_free_dev_mem:
 +	kfree(indio_dev->channels);
  	return ret;
  }
  
@@@ -400,9 -581,8 +551,9 @@@ static int hid_magn_3d_remove(struct pl
  
  	sensor_hub_remove_callback(hsdev, HID_USAGE_SENSOR_COMPASS_3D);
  	iio_device_unregister(indio_dev);
- 	hid_sensor_remove_trigger(&magn_state->common_attributes);
+ 	hid_sensor_remove_trigger(&magn_state->magn_flux_attributes);
  	iio_triggered_buffer_cleanup(indio_dev);
 +	kfree(indio_dev->channels);
  
  	return 0;
  }
* Unmerged path drivers/iio/magnetometer/hid-sensor-magn-3d.c
