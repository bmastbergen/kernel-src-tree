net_sched: fix a missing rcu barrier in mini_qdisc_pair_swap()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] sched: fix a missing rcu barrier in mini_qdisc_pair_swap() (Ivan Vecera) [1572720]
Rebuild_FUZZ: 96.67%
commit-author Cong Wang <xiyou.wangcong@gmail.com>
commit b2fb01f426883a794ed80be9110675a2d8356347
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b2fb01f4.failed

The rcu_barrier_bh() in mini_qdisc_pair_swap() is to wait for
flying RCU callback installed by a previous mini_qdisc_pair_swap(),
however we miss it on the tp_head==NULL path, which leads to that
the RCU callback still uses miniq_old->rcu after it is freed together
with qdisc in qdisc_graft(). So just add it on that path too.

Fixes: 46209401f8f6 ("net: core: introduce mini_Qdisc and eliminate usage of tp->q for clsact fastpath ")
	Reported-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Tested-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Cc: Jiri Pirko <jiri@mellanox.com>
	Cc: John Fastabend <john.fastabend@gmail.com>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b2fb01f426883a794ed80be9110675a2d8356347)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_generic.c
diff --cc net/sched/sch_generic.c
index 550f656c2ac8,661c7144b53a..000000000000
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@@ -1063,3 -1027,51 +1063,54 @@@ void psched_ratecfg_precompute(struct p
  	}
  }
  EXPORT_SYMBOL(psched_ratecfg_precompute);
++<<<<<<< HEAD
++=======
+ 
+ static void mini_qdisc_rcu_func(struct rcu_head *head)
+ {
+ }
+ 
+ void mini_qdisc_pair_swap(struct mini_Qdisc_pair *miniqp,
+ 			  struct tcf_proto *tp_head)
+ {
+ 	struct mini_Qdisc *miniq_old = rtnl_dereference(*miniqp->p_miniq);
+ 	struct mini_Qdisc *miniq;
+ 
+ 	if (!tp_head) {
+ 		RCU_INIT_POINTER(*miniqp->p_miniq, NULL);
+ 		/* Wait for flying RCU callback before it is freed. */
+ 		rcu_barrier_bh();
+ 		return;
+ 	}
+ 
+ 	miniq = !miniq_old || miniq_old == &miniqp->miniq2 ?
+ 		&miniqp->miniq1 : &miniqp->miniq2;
+ 
+ 	/* We need to make sure that readers won't see the miniq
+ 	 * we are about to modify. So wait until previous call_rcu_bh callback
+ 	 * is done.
+ 	 */
+ 	rcu_barrier_bh();
+ 	miniq->filter_list = tp_head;
+ 	rcu_assign_pointer(*miniqp->p_miniq, miniq);
+ 
+ 	if (miniq_old)
+ 		/* This is counterpart of the rcu barriers above. We need to
+ 		 * block potential new user of miniq_old until all readers
+ 		 * are not seeing it.
+ 		 */
+ 		call_rcu_bh(&miniq_old->rcu, mini_qdisc_rcu_func);
+ }
+ EXPORT_SYMBOL(mini_qdisc_pair_swap);
+ 
+ void mini_qdisc_pair_init(struct mini_Qdisc_pair *miniqp, struct Qdisc *qdisc,
+ 			  struct mini_Qdisc __rcu **p_miniq)
+ {
+ 	miniqp->miniq1.cpu_bstats = qdisc->cpu_bstats;
+ 	miniqp->miniq1.cpu_qstats = qdisc->cpu_qstats;
+ 	miniqp->miniq2.cpu_bstats = qdisc->cpu_bstats;
+ 	miniqp->miniq2.cpu_qstats = qdisc->cpu_qstats;
+ 	miniqp->p_miniq = p_miniq;
+ }
+ EXPORT_SYMBOL(mini_qdisc_pair_init);
++>>>>>>> b2fb01f42688 (net_sched: fix a missing rcu barrier in mini_qdisc_pair_swap())
* Unmerged path net/sched/sch_generic.c
