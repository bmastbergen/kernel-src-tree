ext4, dax: introduce ext4_dax_aops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit 5f0663bb4a64f588f0a2dd6d1be68d40f9af0086
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5f0663bb.failed

In preparation for the dax implementation to start associating dax pages
to inodes via page->mapping, we need to provide a 'struct
address_space_operations' instance for dax. Otherwise, direct-I/O
triggers incorrect page cache assumptions and warnings.

	Cc: "Theodore Ts'o" <tytso@mit.edu>
	Cc: Andreas Dilger <adilger.kernel@dilger.ca>
	Cc: linux-ext4@vger.kernel.org
	Reviewed-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 5f0663bb4a64f588f0a2dd6d1be68d40f9af0086)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/inode.c
diff --cc fs/ext4/inode.c
index a2d511ecf734,249a97b19181..000000000000
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@@ -2396,12 -2719,12 +2396,15 @@@ static int ext4_writepages(struct addre
  	struct blk_plug plug;
  	bool give_up_on_write = false;
  
 -	if (unlikely(ext4_forced_shutdown(EXT4_SB(inode->i_sb))))
 -		return -EIO;
 -
 -	percpu_down_read(&sbi->s_journal_flag_rwsem);
  	trace_ext4_writepages(inode, wbc);
  
++<<<<<<< HEAD
 +	if (dax_mapping(mapping))
 +		return dax_writeback_mapping_range(mapping, inode->i_sb->s_bdev,
 +						   wbc);
 +
++=======
++>>>>>>> 5f0663bb4a64 (ext4, dax: introduce ext4_dax_aops)
  	/*
  	 * No pages to write? This is mainly a kludge to avoid starting
  	 * a transaction for special inodes like journal inode on last iput()
@@@ -3436,17 -3872,12 +3460,23 @@@ static ssize_t ext4_direct_IO(int rw, s
  	if (ext4_has_inline_data(inode))
  		return 0;
  
++<<<<<<< HEAD
 +	/* DAX uses iomap path now */
 +	if (WARN_ON_ONCE(IS_DAX(inode)))
 +		return 0;
 +
 +	trace_ext4_direct_IO_enter(inode, offset, iov_length(iov, nr_segs), rw);
 +	if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))
 +		ret = ext4_ext_direct_IO(rw, iocb, iov, offset, nr_segs);
++=======
+ 	trace_ext4_direct_IO_enter(inode, offset, count, iov_iter_rw(iter));
+ 	if (iov_iter_rw(iter) == READ)
+ 		ret = ext4_direct_IO_read(iocb, iter);
++>>>>>>> 5f0663bb4a64 (ext4, dax: introduce ext4_dax_aops)
  	else
 -		ret = ext4_direct_IO_write(iocb, iter);
 -	trace_ext4_direct_IO_exit(inode, offset, count, iov_iter_rw(iter), ret);
 +		ret = ext4_ind_direct_IO(rw, iocb, iov, offset, nr_segs);
 +	trace_ext4_direct_IO_exit(inode, offset,
 +				iov_length(iov, nr_segs), rw, ret);
  	return ret;
  }
  
* Unmerged path fs/ext4/inode.c
