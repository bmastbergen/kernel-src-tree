tcmu: fix free block calculation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Mike Christie <mchristi@redhat.com>
commit 3c0f26ff9d040c6193b33689bbc03103854dba4d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3c0f26ff.failed

The blocks_left calculation does not account for free blocks
between 0 and thresh, so we could be queueing/waiting when
there are enough blocks free.

This has us add in the blocks between 0 and thresh as well as
at the end from thresh to DATA_BLOCK_BITS.

	Signed-off-by: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 3c0f26ff9d040c6193b33689bbc03103854dba4d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_user.c
diff --cc drivers/target/target_core_user.c
index 8fa83807dcdc,5d1daea51079..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -516,13 -631,13 +516,17 @@@ static void gather_data_area(struct tcm
  		}
  		kunmap_atomic(to - sg->offset);
  	}
 -	if (from)
 -		kunmap_atomic(from);
  }
  
 -static inline size_t spc_bitmap_free(unsigned long *bitmap, uint32_t thresh)
 +static inline size_t spc_bitmap_free(unsigned long *bitmap,
 +				     unsigned int max_blocks)
  {
++<<<<<<< HEAD
 +	return DATA_BLOCK_SIZE *
 +			(max_blocks - bitmap_weight(bitmap, max_blocks));
++=======
+ 	return thresh - bitmap_weight(bitmap, thresh);
++>>>>>>> 3c0f26ff9d04 (tcmu: fix free block calculation)
  }
  
  /*
@@@ -557,14 -675,40 +561,48 @@@ static bool is_ring_space_avail(struct 
  		return false;
  	}
  
++<<<<<<< HEAD
 +	space = spc_bitmap_free(udev->data_bitmap, udev->max_blocks);
 +	if (space < data_needed) {
 +		pr_debug("no data space: only %zu available, but ask for %zu\n",
 +				space, data_needed);
 +		return false;
++=======
+ 	/* try to check and get the data blocks as needed */
+ 	space = spc_bitmap_free(udev->data_bitmap, udev->dbi_thresh);
+ 	if ((space * DATA_BLOCK_SIZE) < data_needed) {
+ 		unsigned long blocks_left = DATA_BLOCK_BITS - udev->dbi_thresh +
+ 						space;
+ 		unsigned long grow;
+ 
+ 		if (blocks_left < blocks_needed) {
+ 			pr_debug("no data space: only %lu available, but ask for %zu\n",
+ 					blocks_left * DATA_BLOCK_SIZE,
+ 					data_needed);
+ 			return false;
+ 		}
+ 
+ 		/* Try to expand the thresh */
+ 		if (!udev->dbi_thresh) {
+ 			/* From idle state */
+ 			uint32_t init_thresh = DATA_BLOCK_INIT_BITS;
+ 
+ 			udev->dbi_thresh = max(blocks_needed, init_thresh);
+ 		} else {
+ 			/*
+ 			 * Grow the data area by max(blocks needed,
+ 			 * dbi_thresh / 2), but limited to the max
+ 			 * DATA_BLOCK_BITS size.
+ 			 */
+ 			grow = max(blocks_needed, udev->dbi_thresh / 2);
+ 			udev->dbi_thresh += grow;
+ 			if (udev->dbi_thresh > DATA_BLOCK_BITS)
+ 				udev->dbi_thresh = DATA_BLOCK_BITS;
+ 		}
++>>>>>>> 3c0f26ff9d04 (tcmu: fix free block calculation)
  	}
  
 -	return tcmu_get_empty_blocks(udev, cmd);
 +	return true;
  }
  
  static inline size_t tcmu_cmd_get_base_cmd_size(size_t iov_cnt)
* Unmerged path drivers/target/target_core_user.c
