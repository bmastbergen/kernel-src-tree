uio: fix crash after the device is unregistered

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [uio] fix crash after the device is unregistered (Xiubo Li) [1560418]
Rebuild_FUZZ: 94.38%
commit-author Xiubo Li <xiubli@redhat.com>
commit 57c5f4df0a5a0ee83df799991251e2ee93a5e4e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/57c5f4df.failed

For the target_core_user use case, after the device is unregistered
it maybe still opened in user space, then the kernel will crash, like:

[  251.163692] BUG: unable to handle kernel NULL pointer dereference at 0000000000000008
[  251.163820] IP: [<ffffffffc0736213>] show_name+0x23/0x40 [uio]
[  251.163965] PGD 8000000062694067 PUD 62696067 PMD 0
[  251.164097] Oops: 0000 [#1] SMP
...
[  251.165605]  e1000 mptscsih mptbase drm_panel_orientation_quirks dm_mirror dm_region_hash dm_log dm_mod
[  251.166014] CPU: 0 PID: 13380 Comm: tcmu-runner Kdump: loaded Not tainted 3.10.0-916.el7.test.x86_64 #1
[  251.166381] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 05/19/2017
[  251.166747] task: ffff971eb91db0c0 ti: ffff971e9e384000 task.ti: ffff971e9e384000
[  251.167137] RIP: 0010:[<ffffffffc0736213>]  [<ffffffffc0736213>] show_name+0x23/0x40 [uio]
[  251.167563] RSP: 0018:ffff971e9e387dc8  EFLAGS: 00010282
[  251.167978] RAX: 0000000000000000 RBX: ffff971e9e3f8000 RCX: ffff971eb8368d98
[  251.168408] RDX: ffff971e9e3f8000 RSI: ffffffffc0738084 RDI: ffff971e9e3f8000
[  251.168856] RBP: ffff971e9e387dd0 R08: ffff971eb8bc0018 R09: 0000000000000000
[  251.169296] R10: 0000000000001000 R11: ffffffffa09d444d R12: ffffffffa1076e80
[  251.169750] R13: ffff971e9e387f18 R14: 0000000000000001 R15: ffff971e9cfb1c80
[  251.170213] FS:  00007ff37d175880(0000) GS:ffff971ebb600000(0000) knlGS:0000000000000000
[  251.170693] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  251.171248] CR2: 0000000000000008 CR3: 00000000001f6000 CR4: 00000000003607f0
[  251.172071] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[  251.172640] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[  251.173236] Call Trace:
[  251.173789]  [<ffffffffa0c9b2d3>] dev_attr_show+0x23/0x60
[  251.174356]  [<ffffffffa0f561b2>] ? mutex_lock+0x12/0x2f
[  251.174892]  [<ffffffffa0ac6d9f>] sysfs_kf_seq_show+0xcf/0x1f0
[  251.175433]  [<ffffffffa0ac54e6>] kernfs_seq_show+0x26/0x30
[  251.175981]  [<ffffffffa0a63be0>] seq_read+0x110/0x3f0
[  251.176609]  [<ffffffffa0ac5d45>] kernfs_fop_read+0xf5/0x160
[  251.177158]  [<ffffffffa0a3d3af>] vfs_read+0x9f/0x170
[  251.177707]  [<ffffffffa0a3e27f>] SyS_read+0x7f/0xf0
[  251.178268]  [<ffffffffa0f648af>] system_call_fastpath+0x1c/0x21
[  251.178823] Code: 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 55 48 89 e5 53 48 89 d3 e8 7e 96 56 e0 48 8b 80 d8 02 00 00 48 89 df 48 c7 c6 84 80 73 c0 <48> 8b 50 08 31 c0 e8 e2 67 44 e0 5b 48 98 5d c3 0f 1f 00 66 2e
[  251.180115] RIP  [<ffffffffc0736213>] show_name+0x23/0x40 [uio]
[  251.180820]  RSP <ffff971e9e387dc8>
[  251.181473] CR2: 0000000000000008

CC: Hamish Martin <hamish.martin@alliedtelesis.co.nz>
CC: Mike Christie <mchristi@redhat.com>
	Reviewed-by: Hamish Martin <hamish.martin@alliedtelesis.co.nz>
	Signed-off-by: Xiubo Li <xiubli@redhat.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 57c5f4df0a5a0ee83df799991251e2ee93a5e4e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/uio/uio.c
diff --cc drivers/uio/uio.c
index 6a5a7703969f,5d421d7e8904..000000000000
--- a/drivers/uio/uio.c
+++ b/drivers/uio/uio.c
@@@ -215,17 -215,45 +215,43 @@@ static ssize_t show_name(struct device 
  			 struct device_attribute *attr, char *buf)
  {
  	struct uio_device *idev = dev_get_drvdata(dev);
- 	return sprintf(buf, "%s\n", idev->info->name);
+ 	int ret;
+ 
+ 	mutex_lock(&idev->info_lock);
+ 	if (!idev->info) {
+ 		ret = -EINVAL;
+ 		dev_err(dev, "the device has been unregistered\n");
+ 		goto out;
+ 	}
+ 
+ 	ret = sprintf(buf, "%s\n", idev->info->name);
+ 
+ out:
+ 	mutex_unlock(&idev->info_lock);
+ 	return ret;
  }
 -static DEVICE_ATTR_RO(name);
  
 -static ssize_t version_show(struct device *dev,
 +static ssize_t show_version(struct device *dev,
  			    struct device_attribute *attr, char *buf)
  {
  	struct uio_device *idev = dev_get_drvdata(dev);
- 	return sprintf(buf, "%s\n", idev->info->version);
+ 	int ret;
+ 
+ 	mutex_lock(&idev->info_lock);
+ 	if (!idev->info) {
+ 		ret = -EINVAL;
+ 		dev_err(dev, "the device has been unregistered\n");
+ 		goto out;
+ 	}
+ 
+ 	ret = sprintf(buf, "%s\n", idev->info->version);
+ 
+ out:
+ 	mutex_unlock(&idev->info_lock);
+ 	return ret;
  }
 -static DEVICE_ATTR_RO(version);
  
 -static ssize_t event_show(struct device *dev,
 +static ssize_t show_event(struct device *dev,
  			  struct device_attribute *attr, char *buf)
  {
  	struct uio_device *idev = dev_get_drvdata(dev);
@@@ -441,11 -489,19 +471,22 @@@ static int uio_open(struct inode *inode
  	listener->event_count = atomic_read(&idev->event);
  	filep->private_data = listener;
  
++<<<<<<< HEAD
 +	if (idev->info->open) {
++=======
+ 	mutex_lock(&idev->info_lock);
+ 	if (!idev->info) {
+ 		mutex_unlock(&idev->info_lock);
+ 		ret = -EINVAL;
+ 		goto err_alloc_listener;
+ 	}
+ 
+ 	if (idev->info && idev->info->open)
++>>>>>>> 57c5f4df0a5a (uio: fix crash after the device is unregistered)
  		ret = idev->info->open(idev->info, inode);
 -	mutex_unlock(&idev->info_lock);
 -	if (ret)
 -		goto err_infoopen;
 -
 +		if (ret)
 +			goto err_infoopen;
 +	}
  	return 0;
  
  err_infoopen:
@@@ -552,7 -625,13 +593,17 @@@ static ssize_t uio_write(struct file *f
  	ssize_t retval;
  	s32 irq_on;
  
++<<<<<<< HEAD
 +	if (!idev->info->irq) {
++=======
+ 	mutex_lock(&idev->info_lock);
+ 	if (!idev->info) {
+ 		retval = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (!idev->info || !idev->info->irq) {
++>>>>>>> 57c5f4df0a5a (uio: fix crash after the device is unregistered)
  		retval = -EIO;
  		goto out;
  	}
@@@ -608,10 -676,20 +659,26 @@@ static int uio_vma_fault(struct vm_area
  	struct page *page;
  	unsigned long offset;
  	void *addr;
+ 	int ret = 0;
+ 	int mi;
  
++<<<<<<< HEAD
 +	int mi = uio_find_mem_index(vma);
 +	if (mi < 0)
 +		return VM_FAULT_SIGBUS;
++=======
+ 	mutex_lock(&idev->info_lock);
+ 	if (!idev->info) {
+ 		ret = VM_FAULT_SIGBUS;
+ 		goto out;
+ 	}
+ 
+ 	mi = uio_find_mem_index(vmf->vma);
+ 	if (mi < 0) {
+ 		ret = VM_FAULT_SIGBUS;
+ 		goto out;
+ 	}
++>>>>>>> 57c5f4df0a5a (uio: fix crash after the device is unregistered)
  
  	/*
  	 * We need to subtract mi because userspace uses offset = N*PAGE_SIZE
@@@ -695,15 -775,25 +767,25 @@@ static int uio_mmap(struct file *filep
  
  	vma->vm_private_data = idev;
  
+ 	mutex_lock(&idev->info_lock);
+ 	if (!idev->info) {
+ 		ret = -EINVAL;
+ 		goto out;
+ 	}
+ 
  	mi = uio_find_mem_index(vma);
- 	if (mi < 0)
- 		return -EINVAL;
+ 	if (mi < 0) {
+ 		ret = -EINVAL;
+ 		goto out;
+ 	}
  
 -	requested_pages = vma_pages(vma);
 +	requested_pages = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
  	actual_pages = ((idev->info->mem[mi].addr & ~PAGE_MASK)
  			+ idev->info->mem[mi].size + PAGE_SIZE -1) >> PAGE_SHIFT;
- 	if (requested_pages > actual_pages)
- 		return -EINVAL;
+ 	if (requested_pages > actual_pages) {
+ 		ret = -EINVAL;
+ 		goto out;
+ 	}
  
  	if (idev->info->mmap) {
  		ret = idev->info->mmap(idev->info, vma);
@@@ -890,13 -1004,16 +978,24 @@@ void uio_unregister_device(struct uio_i
  
  	uio_free_minor(idev);
  
++<<<<<<< HEAD
 +	if (info->irq && (info->irq != UIO_IRQ_CUSTOM))
 +		free_irq(info->irq, idev);
 +
 +	uio_dev_del_attributes(idev);
++=======
+ 	mutex_lock(&idev->info_lock);
+ 	uio_dev_del_attributes(idev);
+ 
+ 	if (info->irq && info->irq != UIO_IRQ_CUSTOM)
+ 		free_irq(info->irq, idev);
+ 
+ 	idev->info = NULL;
+ 	mutex_unlock(&idev->info_lock);
++>>>>>>> 57c5f4df0a5a (uio: fix crash after the device is unregistered)
  
 -	device_unregister(&idev->dev);
 +	device_destroy(&uio_class, MKDEV(uio_major, idev->minor));
 +	kfree(idev);
  
  	return;
  }
* Unmerged path drivers/uio/uio.c
