bpf: Add BPF_MAP_GET_FD_BY_ID

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Martin KaFai Lau <kafai@fb.com>
commit bd5f5f4ecb78e2698dad655645b6d6a2f7012a8c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/bd5f5f4e.failed

Add BPF_MAP_GET_FD_BY_ID command to allow user to get a fd
from a bpf_map's ID.

bpf_map_inc_not_zero() is added and is called with map_idr_lock
held.

__bpf_map_put() is also added which has the 'bool do_idr_lock'
param to decide if the map_idr_lock should be acquired when
freeing the map->id.

In the error path of bpf_map_inc_not_zero(), it may have to
call __bpf_map_put(map, false) which does not need
to take the map_idr_lock when freeing the map->id.

It is currently limited to CAP_SYS_ADMIN which we can
consider to lift it in followup patches.

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Acked-by: Alexei Starovoitov <ast@fb.com>
	Acked-by: Daniel Borkmann <daniel@iogearbox.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bd5f5f4ecb78e2698dad655645b6d6a2f7012a8c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	kernel/bpf/syscall.c
diff --cc include/uapi/linux/bpf.h
index e369860b690e,dd23f47ff00c..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -62,50 -63,29 +62,62 @@@ struct bpf_insn 
  	__s32	imm;		/* signed immediate constant */
  };
  
 -/* Key of an a BPF_MAP_TYPE_LPM_TRIE entry */
 -struct bpf_lpm_trie_key {
 -	__u32	prefixlen;	/* up to 32 for AF_INET, 128 for AF_INET6 */
 -	__u8	data[0];	/* Arbitrary size */
 -};
 -
 -/* BPF syscall commands, see bpf(2) man-page for details. */
 +/* BPF syscall commands */
  enum bpf_cmd {
 +	/* create a map with given type and attributes
 +	 * fd = bpf(BPF_MAP_CREATE, union bpf_attr *, u32 size)
 +	 * returns fd or negative error
 +	 * map is deleted when fd is closed
 +	 */
  	BPF_MAP_CREATE,
 +
 +	/* verify and load eBPF program
 +	 * prog_fd = bpf(BPF_PROG_LOAD, union bpf_attr *attr, u32 size)
 +	 * Using attr->prog_type, attr->insns, attr->license
 +	 * returns fd or negative error
 +	 */
 +	BPF_PROG_LOAD,
++<<<<<<< HEAD
 +
 +	/* lookup key in a given map
 +	 * err = bpf(BPF_MAP_LOOKUP_ELEM, union bpf_attr *attr, u32 size)
 +	 * Using attr->map_fd, attr->key, attr->value
 +	 * returns zero and stores found elem into value
 +	 * or negative error
 +	 */
  	BPF_MAP_LOOKUP_ELEM,
 +
 +	/* create or update key/value pair in a given map
 +	 * err = bpf(BPF_MAP_UPDATE_ELEM, union bpf_attr *attr, u32 size)
 +	 * Using attr->map_fd, attr->key, attr->value
 +	 * returns zero or negative error
 +	 */
  	BPF_MAP_UPDATE_ELEM,
 +
 +	/* find and delete elem by key in a given map
 +	 * err = bpf(BPF_MAP_DELETE_ELEM, union bpf_attr *attr, u32 size)
 +	 * Using attr->map_fd, attr->key
 +	 * returns zero or negative error
 +	 */
  	BPF_MAP_DELETE_ELEM,
 +
 +	/* lookup key in a given map and return next key
 +	 * err = bpf(BPF_MAP_GET_NEXT_KEY, union bpf_attr *attr, u32 size)
 +	 * Using attr->map_fd, attr->key, attr->next_key
 +	 * returns zero and stores next key or negative error
 +	 */
  	BPF_MAP_GET_NEXT_KEY,
 -	BPF_PROG_LOAD,
++=======
+ 	BPF_OBJ_PIN,
+ 	BPF_OBJ_GET,
+ 	BPF_PROG_ATTACH,
+ 	BPF_PROG_DETACH,
+ 	BPF_PROG_TEST_RUN,
+ 	BPF_PROG_GET_NEXT_ID,
+ 	BPF_MAP_GET_NEXT_ID,
+ 	BPF_PROG_GET_FD_BY_ID,
+ 	BPF_MAP_GET_FD_BY_ID,
++>>>>>>> bd5f5f4ecb78 (bpf: Add BPF_MAP_GET_FD_BY_ID)
  };
  
  enum bpf_map_type {
@@@ -132,6 -176,51 +144,54 @@@ union bpf_attr 
  			__aligned_u64 value;
  			__aligned_u64 next_key;
  		};
++<<<<<<< HEAD
++=======
+ 		__u64		flags;
+ 	};
+ 
+ 	struct { /* anonymous struct used by BPF_PROG_LOAD command */
+ 		__u32		prog_type;	/* one of enum bpf_prog_type */
+ 		__u32		insn_cnt;
+ 		__aligned_u64	insns;
+ 		__aligned_u64	license;
+ 		__u32		log_level;	/* verbosity level of verifier */
+ 		__u32		log_size;	/* size of user buffer */
+ 		__aligned_u64	log_buf;	/* user supplied buffer */
+ 		__u32		kern_version;	/* checked when prog_type=kprobe */
+ 		__u32		prog_flags;
+ 	};
+ 
+ 	struct { /* anonymous struct used by BPF_OBJ_* commands */
+ 		__aligned_u64	pathname;
+ 		__u32		bpf_fd;
+ 	};
+ 
+ 	struct { /* anonymous struct used by BPF_PROG_ATTACH/DETACH commands */
+ 		__u32		target_fd;	/* container object to attach to */
+ 		__u32		attach_bpf_fd;	/* eBPF program to attach */
+ 		__u32		attach_type;
+ 		__u32		attach_flags;
+ 	};
+ 
+ 	struct { /* anonymous struct used by BPF_PROG_TEST_RUN command */
+ 		__u32		prog_fd;
+ 		__u32		retval;
+ 		__u32		data_size_in;
+ 		__u32		data_size_out;
+ 		__aligned_u64	data_in;
+ 		__aligned_u64	data_out;
+ 		__u32		repeat;
+ 		__u32		duration;
+ 	} test;
+ 
+ 	struct { /* anonymous struct used by BPF_*_GET_*_ID */
+ 		union {
+ 			__u32		start_id;
+ 			__u32		prog_id;
+ 			__u32		map_id;
+ 		};
+ 		__u32		next_id;
++>>>>>>> bd5f5f4ecb78 (bpf: Add BPF_MAP_GET_FD_BY_ID)
  	};
  } __attribute__((aligned(8)));
  
* Unmerged path kernel/bpf/syscall.c
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path kernel/bpf/syscall.c
