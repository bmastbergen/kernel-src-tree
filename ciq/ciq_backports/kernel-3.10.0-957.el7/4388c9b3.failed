powerpc: Do not send system reset request through the oops path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [powerpc] Do not send system reset request through the oops path (Mauricio Oliveira) [1564126]
Rebuild_FUZZ: 92.31%
commit-author Nicholas Piggin <npiggin@gmail.com>
commit 4388c9b3a6ee7d6afc36c8a0bb5579b1606229b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4388c9b3.failed

A system reset is a request to crash / debug the system rather than
necessarily caused by encountering a BUG. So there is no need to
serialize all CPUs behind the die lock, adding taints to all
subsequent traces beyond the first, breaking console locks, etc.

The system reset is NMI context which has its own printk buffers to
prevent output being interleaved. Then it's better to have all
secondaries print out their debug as quickly as possible and the
primary will flush out all printk buffers during panic().

So remove the 0x100 path from die, and move it into system_reset. Name
the crash/dump reasons "System Reset".

This gives "not tained" traces when crashing an untainted kernel. It
also gives the panic reason as "System Reset" as opposed to "Fatal
exception in interrupt" (or "die oops" for fadump).

	Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 4388c9b3a6ee7d6afc36c8a0bb5579b1606229b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/traps.c
diff --cc arch/powerpc/kernel/traps.c
index 8b1f9ad2f1e0,5e4db2fc2add..000000000000
--- a/arch/powerpc/kernel/traps.c
+++ b/arch/powerpc/kernel/traps.c
@@@ -273,15 -278,61 +261,51 @@@ void system_reset_exception(struct pt_r
  	/* See if any machine dependent calls */
  	if (ppc_md.system_reset_exception) {
  		if (ppc_md.system_reset_exception(regs))
 -			goto out;
 +			return;
  	}
  
- 	die("System Reset", regs, SIGABRT);
+ 	if (debugger(regs))
+ 		goto out;
+ 
+ 	/*
+ 	 * A system reset is a request to dump, so we always send
+ 	 * it through the crashdump code (if fadump or kdump are
+ 	 * registered).
+ 	 */
+ 	crash_fadump(regs, "System Reset");
+ 
+ 	crash_kexec(regs);
  
+ 	/*
+ 	 * We aren't the primary crash CPU. We need to send it
+ 	 * to a holding pattern to avoid it ending up in the panic
+ 	 * code.
+ 	 */
+ 	crash_kexec_secondary(regs);
+ 
+ 	/*
+ 	 * No debugger or crash dump registered, print logs then
+ 	 * panic.
+ 	 */
+ 	__die("System Reset", regs, SIGABRT);
+ 
+ 	mdelay(2*MSEC_PER_SEC); /* Wait a little while for others to print */
+ 	add_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);
+ 	nmi_panic(regs, "System Reset");
+ 
++<<<<<<< HEAD
++=======
+ out:
+ #ifdef CONFIG_PPC_BOOK3S_64
+ 	BUG_ON(get_paca()->in_nmi == 0);
+ 	if (get_paca()->in_nmi > 1)
+ 		nmi_panic(regs, "Unrecoverable nested System Reset");
+ #endif
++>>>>>>> 4388c9b3a6ee (powerpc: Do not send system reset request through the oops path)
  	/* Must die if the interrupt is not recoverable */
  	if (!(regs->msr & MSR_RI))
- 		panic("Unrecoverable System Reset");
+ 		nmi_panic(regs, "Unrecoverable System Reset");
  
 -	if (!nested)
 -		nmi_exit();
 -
  	/* What should we do here? We could issue a shutdown or hard reset. */
  }
  
* Unmerged path arch/powerpc/kernel/traps.c
