netfilter: ipset: Make struct htype per ipset family

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 21956ab290f7f3f9203eb89adc0a1331e59b7f0f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/21956ab2.failed

Before this patch struct htype created at the first source
of ip_set_hash_gen.h and it is common for both IPv4 and IPv6
set variants.

Make struct htype per ipset family and use NLEN to make
nets array fixed size to simplify struct htype allocation.

Ported from a patch proposed by Sergey Popovich <popovich_sergei@mail.ua>.

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 21956ab290f7f3f9203eb89adc0a1331e59b7f0f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_hash_gen.h
#	net/netfilter/ipset/ip_set_hash_ipmark.c
#	net/netfilter/ipset/ip_set_hash_netnet.c
#	net/netfilter/ipset/ip_set_hash_netportnet.c
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 9ce28af662bf,c600f6d9f15e..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -171,16 -161,23 +171,28 @@@ hbucket_elem_add(struct hbucket *n, u8 
  #endif
  
  #else
 -#define NLEN			0
 +#define NETS_LENGTH(family)	0
  #endif /* IP_SET_HASH_WITH_NETS */
  
 +#define ext_timeout(e, h)	\
 +(unsigned long *)(((void *)(e)) + (h)->offset[IPSET_EXT_ID_TIMEOUT])
 +#define ext_counter(e, h)	\
 +(struct ip_set_counter *)(((void *)(e)) + (h)->offset[IPSET_EXT_ID_COUNTER])
 +
  #endif /* _IP_SET_HASH_GEN_H */
  
+ #ifndef MTYPE
+ #error "MTYPE is not defined!"
+ #endif
+ 
+ #ifndef HTYPE
+ #error "HTYPE is not defined!"
+ #endif
+ 
+ #ifndef HOST_MASK
+ #error "HOST_MASK is not defined!"
+ #endif
+ 
  /* Family dependent templates */
  
  #undef ahash_data
@@@ -258,38 -262,38 +269,60 @@@
  #define HKEY_DATALEN		sizeof(struct mtype_elem)
  #endif
  
+ #define htype			MTYPE
+ 
  #define HKEY(data, initval, htable_bits)			\
 -({								\
 -	const u32 *__k = (const u32 *)data;			\
 -	u32 __l = HKEY_DATALEN / sizeof(u32);			\
 -								\
 -	BUILD_BUG_ON(HKEY_DATALEN % sizeof(u32) != 0);		\
 -								\
 -	jhash2(__k, __l, initval) & jhash_mask(htable_bits);	\
 -})
 +(jhash2((u32 *)(data), HKEY_DATALEN/sizeof(u32), initval)	\
 +	& jhash_mask(htable_bits))
 +
++<<<<<<< HEAD
 +#ifndef htype
 +#define htype			HTYPE
  
 +/* The generic hash structure */
 +struct htype {
 +	struct htable *table;	/* the hash table */
++=======
+ /* The generic hash structure */
+ struct htype {
+ 	struct htable __rcu *table; /* the hash table */
+ 	struct timer_list gc;	/* garbage collection when timeout enabled */
++>>>>>>> 21956ab290f7 (netfilter: ipset: Make struct htype per ipset family)
  	u32 maxelem;		/* max elements in the hash */
 +	u32 elements;		/* current element (vs timeout) */
  	u32 initval;		/* random jhash init value */
++<<<<<<< HEAD
 +	u32 timeout;		/* timeout value, if enabled */
 +	size_t dsize;		/* data struct size */
 +	size_t offset[IPSET_EXT_ID_MAX]; /* Offsets to extensions */
 +	struct timer_list gc;	/* garbage collection when timeout enabled */
 +	struct mtype_elem next; /* temporary storage for uadd */
++=======
+ #ifdef IP_SET_HASH_WITH_MARKMASK
+ 	u32 markmask;		/* markmask value for mark mask to store */
+ #endif
++>>>>>>> 21956ab290f7 (netfilter: ipset: Make struct htype per ipset family)
  #ifdef IP_SET_HASH_WITH_MULTI
  	u8 ahash_max;		/* max elements in an array block */
  #endif
  #ifdef IP_SET_HASH_WITH_NETMASK
  	u8 netmask;		/* netmask value for subnets to store */
  #endif
++<<<<<<< HEAD
 +#ifdef IP_SET_HASH_WITH_RBTREE
 +	struct rb_root rbtree;
 +#endif
++=======
+ 	struct mtype_elem next; /* temporary storage for uadd */
++>>>>>>> 21956ab290f7 (netfilter: ipset: Make struct htype per ipset family)
  #ifdef IP_SET_HASH_WITH_NETS
- 	struct net_prefixes nets[0]; /* book-keeping of prefixes */
+ 	struct net_prefixes nets[NLEN]; /* book-keeping of prefixes */
  #endif
  };
++<<<<<<< HEAD
 +#endif
++=======
++>>>>>>> 21956ab290f7 (netfilter: ipset: Make struct htype per ipset family)
  
  #ifdef IP_SET_HASH_WITH_NETS
  /* Network cidr size book keeping when the hash stores different
@@@ -345,21 -344,23 +378,25 @@@ mtype_del_cidr(struct htype *h, u8 cidr
  
  /* Calculate the actual memory size of the set data */
  static size_t
 -mtype_ahash_memsize(const struct htype *h, const struct htable *t)
 +mtype_ahash_memsize(const struct htype *h, u8 nets_length)
  {
 -	return sizeof(*h) + sizeof(*t);
 -}
 -
 -/* Get the ith element from the array block n */
 -#define ahash_data(n, i, dsize)	\
 -	((struct mtype_elem *)((n)->value + ((i) * (dsize))))
++<<<<<<< HEAD
 +	u32 i;
 +	struct htable *t = h->table;
 +	size_t memsize = sizeof(*h)
 +			 + sizeof(*t)
 +#ifdef IP_SET_HASH_WITH_NETS
 +			 + sizeof(struct net_prefixes) * nets_length
 +#endif
 +			 + jhash_size(t->htable_bits) * sizeof(struct hbucket);
  
 -static void
 -mtype_ext_cleanup(struct ip_set *set, struct hbucket *n)
 -{
 -	int i;
 +	for (i = 0; i < jhash_size(t->htable_bits); i++)
 +		memsize += t->bucket[i].size * h->dsize;
  
 -	for (i = 0; i < n->pos; i++)
 -		if (test_bit(i, n->used))
 -			ip_set_ext_destroy(set, ahash_data(n, i, set->dsize));
 +	return memsize;
++=======
++	return sizeof(*h) + sizeof(*t);
++>>>>>>> 21956ab290f7 (netfilter: ipset: Make struct htype per ipset family)
  }
  
  /* Flush a hash type of set: destroy all elements */
@@@ -371,19 -372,42 +408,23 @@@ mtype_flush(struct ip_set *set
  	struct hbucket *n;
  	u32 i;
  
 -	t = ipset_dereference_protected(h->table, set);
  	for (i = 0; i < jhash_size(t->htable_bits); i++) {
 -		n = __ipset_dereference_protected(hbucket(t, i), 1);
 -		if (!n)
 -			continue;
 -		if (set->extensions & IPSET_EXT_DESTROY)
 -			mtype_ext_cleanup(set, n);
 -		/* FIXME: use slab cache */
 -		rcu_assign_pointer(hbucket(t, i), NULL);
 -		kfree_rcu(n, rcu);
 +		n = hbucket(t, i);
 +		if (n->size) {
 +			n->size = n->pos = 0;
 +			/* FIXME: use slab cache */
 +			kfree(n->value);
 +		}
  	}
  #ifdef IP_SET_HASH_WITH_NETS
++<<<<<<< HEAD
 +	memset(h->nets, 0, sizeof(struct net_prefixes)
 +			   * NETS_LENGTH(set->family));
++=======
+ 	memset(h->nets, 0, sizeof(h->nets));
++>>>>>>> 21956ab290f7 (netfilter: ipset: Make struct htype per ipset family)
  #endif
 -	set->elements = 0;
 -	set->ext_size = 0;
 -}
 -
 -/* Destroy the hashtable part of the set */
 -static void
 -mtype_ahash_destroy(struct ip_set *set, struct htable *t, bool ext_destroy)
 -{
 -	struct hbucket *n;
 -	u32 i;
 -
 -	for (i = 0; i < jhash_size(t->htable_bits); i++) {
 -		n = __ipset_dereference_protected(hbucket(t, i), 1);
 -		if (!n)
 -			continue;
 -		if (set->extensions & IPSET_EXT_DESTROY && ext_destroy)
 -			mtype_ext_cleanup(set, n);
 -		/* FIXME: use slab cache */
 -		kfree(n);
 -	}
 -
 -	ip_set_free(t);
 +	h->elements = 0;
  }
  
  /* Destroy a hash type of set */
@@@ -990,10 -1272,16 +1031,13 @@@ IPSET_TOKEN(HTYPE, _create)(struct net 
  	}
  #endif
  
 -	if (tb[IPSET_ATTR_HASHSIZE]) {
 -		hashsize = ip_set_get_h32(tb[IPSET_ATTR_HASHSIZE]);
 -		if (hashsize < IPSET_MIMINAL_HASHSIZE)
 -			hashsize = IPSET_MIMINAL_HASHSIZE;
 -	}
 -
 -	if (tb[IPSET_ATTR_MAXELEM])
 -		maxelem = ip_set_get_h32(tb[IPSET_ATTR_MAXELEM]);
 -
  	hsize = sizeof(*h);
++<<<<<<< HEAD
 +#ifdef IP_SET_HASH_WITH_NETS
 +	hsize += sizeof(struct net_prefixes) * NETS_LENGTH(set->family);
 +#endif
++=======
++>>>>>>> 21956ab290f7 (netfilter: ipset: Make struct htype per ipset family)
  	h = kzalloc(hsize, GFP_KERNEL);
  	if (!h)
  		return -ENOMEM;
diff --cc net/netfilter/ipset/ip_set_hash_ipmark.c
index 50389697a53a,b64cf14e8352..000000000000
--- a/net/netfilter/ipset/ip_set_hash_ipmark.c
+++ b/net/netfilter/ipset/ip_set_hash_ipmark.c
@@@ -84,6 -85,7 +84,10 @@@ hash_ipmark4_kadt(struct ip_set *set, c
  		  const struct xt_action_param *par,
  		  enum ipset_adt adt, struct ip_set_adt_opt *opt)
  {
++<<<<<<< HEAD
++=======
+ 	const struct hash_ipmark4 *h = set->data;
++>>>>>>> 21956ab290f7 (netfilter: ipset: Make struct htype per ipset family)
  	ipset_adtfn adtfn = set->variant->adt[adt];
  	struct hash_ipmark4_elem e = { };
  	struct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);
@@@ -210,6 -211,7 +214,10 @@@ hash_ipmark6_kadt(struct ip_set *set, c
  		  const struct xt_action_param *par,
  		  enum ipset_adt adt, struct ip_set_adt_opt *opt)
  {
++<<<<<<< HEAD
++=======
+ 	const struct hash_ipmark6 *h = set->data;
++>>>>>>> 21956ab290f7 (netfilter: ipset: Make struct htype per ipset family)
  	ipset_adtfn adtfn = set->variant->adt[adt];
  	struct hash_ipmark6_elem e = { };
  	struct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);
@@@ -224,6 -227,7 +232,10 @@@ static in
  hash_ipmark6_uadt(struct ip_set *set, struct nlattr *tb[],
  		  enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
  {
++<<<<<<< HEAD
++=======
+ 	const struct hash_ipmark6 *h = set->data;
++>>>>>>> 21956ab290f7 (netfilter: ipset: Make struct htype per ipset family)
  	ipset_adtfn adtfn = set->variant->adt[adt];
  	struct hash_ipmark6_elem e = { };
  	struct ip_set_ext ext = IP_SET_INIT_UEXT(set);
* Unmerged path net/netfilter/ipset/ip_set_hash_netnet.c
* Unmerged path net/netfilter/ipset/ip_set_hash_netportnet.c
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
diff --git a/net/netfilter/ipset/ip_set_hash_ip.c b/net/netfilter/ipset/ip_set_hash_ip.c
index 6e3d06eb397b..72b60077fc68 100644
--- a/net/netfilter/ipset/ip_set_hash_ip.c
+++ b/net/netfilter/ipset/ip_set_hash_ip.c
@@ -96,7 +96,7 @@ hash_ip4_kadt(struct ip_set *set, const struct sk_buff *skb,
 	      const struct xt_action_param *par,
 	      enum ipset_adt adt, struct ip_set_adt_opt *opt)
 {
-	const struct hash_ip *h = set->data;
+	const struct hash_ip4 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_ip4_elem e = {};
 	struct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, h);
@@ -115,7 +115,7 @@ static int
 hash_ip4_uadt(struct ip_set *set, struct nlattr *tb[],
 	      enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
 {
-	const struct hash_ip *h = set->data;
+	const struct hash_ip4 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_ip4_elem e = {};
 	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
@@ -229,7 +229,7 @@ nla_put_failure:
 }
 
 static inline void
-hash_ip6_data_next(struct hash_ip4_elem *next, const struct hash_ip6_elem *e)
+hash_ip6_data_next(struct hash_ip6_elem *next, const struct hash_ip6_elem *e)
 {
 }
 
@@ -249,7 +249,7 @@ hash_ip6_kadt(struct ip_set *set, const struct sk_buff *skb,
 	      const struct xt_action_param *par,
 	      enum ipset_adt adt, struct ip_set_adt_opt *opt)
 {
-	const struct hash_ip *h = set->data;
+	const struct hash_ip6 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_ip6_elem e = {};
 	struct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, h);
@@ -266,7 +266,7 @@ static int
 hash_ip6_uadt(struct ip_set *set, struct nlattr *tb[],
 	      enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
 {
-	const struct hash_ip *h = set->data;
+	const struct hash_ip6 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_ip6_elem e = {};
 	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
* Unmerged path net/netfilter/ipset/ip_set_hash_ipmark.c
diff --git a/net/netfilter/ipset/ip_set_hash_ipport.c b/net/netfilter/ipset/ip_set_hash_ipport.c
index 5e57c86de14d..9d7ce4b4428f 100644
--- a/net/netfilter/ipset/ip_set_hash_ipport.c
+++ b/net/netfilter/ipset/ip_set_hash_ipport.c
@@ -132,7 +132,7 @@ static int
 hash_ipport4_uadt(struct ip_set *set, struct nlattr *tb[],
 		  enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
 {
-	const struct hash_ipport *h = set->data;
+	const struct hash_ipport4 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_ipport4_elem e = { };
 	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
@@ -282,7 +282,7 @@ nla_put_failure:
 }
 
 static inline void
-hash_ipport6_data_next(struct hash_ipport4_elem *next,
+hash_ipport6_data_next(struct hash_ipport6_elem *next,
 		       const struct hash_ipport6_elem *d)
 {
 	next->port = d->port;
@@ -320,7 +320,7 @@ static int
 hash_ipport6_uadt(struct ip_set *set, struct nlattr *tb[],
 		  enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
 {
-	const struct hash_ipport *h = set->data;
+	const struct hash_ipport6 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_ipport6_elem e = { };
 	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
diff --git a/net/netfilter/ipset/ip_set_hash_ipportip.c b/net/netfilter/ipset/ip_set_hash_ipportip.c
index 24b9417eb2c5..9913cd755ddf 100644
--- a/net/netfilter/ipset/ip_set_hash_ipportip.c
+++ b/net/netfilter/ipset/ip_set_hash_ipportip.c
@@ -138,7 +138,7 @@ static int
 hash_ipportip4_uadt(struct ip_set *set, struct nlattr *tb[],
 		    enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
 {
-	const struct hash_ipportip *h = set->data;
+	const struct hash_ipportip4 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_ipportip4_elem e = { };
 	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
@@ -298,7 +298,7 @@ nla_put_failure:
 }
 
 static inline void
-hash_ipportip6_data_next(struct hash_ipportip4_elem *next,
+hash_ipportip6_data_next(struct hash_ipportip6_elem *next,
 			 const struct hash_ipportip6_elem *d)
 {
 	next->port = d->port;
@@ -337,7 +337,7 @@ static int
 hash_ipportip6_uadt(struct ip_set *set, struct nlattr *tb[],
 		    enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
 {
-	const struct hash_ipportip *h = set->data;
+	const struct hash_ipportip6 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_ipportip6_elem e = { };
 	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
diff --git a/net/netfilter/ipset/ip_set_hash_ipportnet.c b/net/netfilter/ipset/ip_set_hash_ipportnet.c
index bb1a8e8f02c9..9cc2155bee5b 100644
--- a/net/netfilter/ipset/ip_set_hash_ipportnet.c
+++ b/net/netfilter/ipset/ip_set_hash_ipportnet.c
@@ -167,7 +167,7 @@ hash_ipportnet4_kadt(struct ip_set *set, const struct sk_buff *skb,
 		     const struct xt_action_param *par,
 		     enum ipset_adt adt, struct ip_set_adt_opt *opt)
 {
-	const struct hash_ipportnet *h = set->data;
+	const struct hash_ipportnet4 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_ipportnet4_elem e = {
 		.cidr = h->nets[0].cidr ? h->nets[0].cidr - 1 : HOST_MASK - 1
@@ -192,7 +192,7 @@ static int
 hash_ipportnet4_uadt(struct ip_set *set, struct nlattr *tb[],
 		     enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
 {
-	const struct hash_ipportnet *h = set->data;
+	const struct hash_ipportnet4 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_ipportnet4_elem e = { .cidr = HOST_MASK - 1 };
 	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
@@ -430,7 +430,7 @@ nla_put_failure:
 }
 
 static inline void
-hash_ipportnet6_data_next(struct hash_ipportnet4_elem *next,
+hash_ipportnet6_data_next(struct hash_ipportnet6_elem *next,
 			  const struct hash_ipportnet6_elem *d)
 {
 	next->port = d->port;
@@ -451,7 +451,7 @@ hash_ipportnet6_kadt(struct ip_set *set, const struct sk_buff *skb,
 		     const struct xt_action_param *par,
 		     enum ipset_adt adt, struct ip_set_adt_opt *opt)
 {
-	const struct hash_ipportnet *h = set->data;
+	const struct hash_ipportnet6 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_ipportnet6_elem e = {
 		.cidr = h->nets[0].cidr ? h->nets[0].cidr - 1 : HOST_MASK - 1
@@ -476,7 +476,7 @@ static int
 hash_ipportnet6_uadt(struct ip_set *set, struct nlattr *tb[],
 		     enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
 {
-	const struct hash_ipportnet *h = set->data;
+	const struct hash_ipportnet6 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_ipportnet6_elem e = { .cidr = HOST_MASK - 1 };
 	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
diff --git a/net/netfilter/ipset/ip_set_hash_net.c b/net/netfilter/ipset/ip_set_hash_net.c
index 0a64dad156d9..09e196fdf361 100644
--- a/net/netfilter/ipset/ip_set_hash_net.c
+++ b/net/netfilter/ipset/ip_set_hash_net.c
@@ -140,7 +140,7 @@ hash_net4_kadt(struct ip_set *set, const struct sk_buff *skb,
 	       const struct xt_action_param *par,
 	       enum ipset_adt adt, struct ip_set_adt_opt *opt)
 {
-	const struct hash_net *h = set->data;
+	const struct hash_net4 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_net4_elem e = {
 		.cidr = h->nets[0].cidr ? h->nets[0].cidr : HOST_MASK
@@ -162,7 +162,7 @@ static int
 hash_net4_uadt(struct ip_set *set, struct nlattr *tb[],
 	       enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
 {
-	const struct hash_net *h = set->data;
+	const struct hash_net4 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_net4_elem e = { .cidr = HOST_MASK };
 	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
@@ -315,7 +315,7 @@ nla_put_failure:
 }
 
 static inline void
-hash_net6_data_next(struct hash_net4_elem *next,
+hash_net6_data_next(struct hash_net6_elem *next,
 		    const struct hash_net6_elem *d)
 {
 }
@@ -335,7 +335,7 @@ hash_net6_kadt(struct ip_set *set, const struct sk_buff *skb,
 	       const struct xt_action_param *par,
 	       enum ipset_adt adt, struct ip_set_adt_opt *opt)
 {
-	const struct hash_net *h = set->data;
+	const struct hash_net6 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_net6_elem e = {
 		.cidr = h->nets[0].cidr ? h->nets[0].cidr : HOST_MASK
diff --git a/net/netfilter/ipset/ip_set_hash_netiface.c b/net/netfilter/ipset/ip_set_hash_netiface.c
index adaa3e8ab417..d8606e70281a 100644
--- a/net/netfilter/ipset/ip_set_hash_netiface.c
+++ b/net/netfilter/ipset/ip_set_hash_netiface.c
@@ -279,7 +279,7 @@ hash_netiface4_kadt(struct ip_set *set, const struct sk_buff *skb,
 		    const struct xt_action_param *par,
 		    enum ipset_adt adt, struct ip_set_adt_opt *opt)
 {
-	struct hash_netiface *h = set->data;
+	struct hash_netiface4 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_netiface4_elem e = {
 		.cidr = h->nets[0].cidr ? h->nets[0].cidr : HOST_MASK,
@@ -330,7 +330,7 @@ static int
 hash_netiface4_uadt(struct ip_set *set, struct nlattr *tb[],
 		    enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
 {
-	struct hash_netiface *h = set->data;
+	struct hash_netiface4 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_netiface4_elem e = { .cidr = HOST_MASK, .elem = 1 };
 	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
@@ -523,7 +523,7 @@ nla_put_failure:
 }
 
 static inline void
-hash_netiface6_data_next(struct hash_netiface4_elem *next,
+hash_netiface6_data_next(struct hash_netiface6_elem *next,
 			 const struct hash_netiface6_elem *d)
 {
 }
@@ -544,7 +544,7 @@ hash_netiface6_kadt(struct ip_set *set, const struct sk_buff *skb,
 		    const struct xt_action_param *par,
 		    enum ipset_adt adt, struct ip_set_adt_opt *opt)
 {
-	struct hash_netiface *h = set->data;
+	struct hash_netiface6 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_netiface6_elem e = {
 		.cidr = h->nets[0].cidr ? h->nets[0].cidr : HOST_MASK,
* Unmerged path net/netfilter/ipset/ip_set_hash_netnet.c
diff --git a/net/netfilter/ipset/ip_set_hash_netport.c b/net/netfilter/ipset/ip_set_hash_netport.c
index d98a685cd916..4b84b1845098 100644
--- a/net/netfilter/ipset/ip_set_hash_netport.c
+++ b/net/netfilter/ipset/ip_set_hash_netport.c
@@ -159,7 +159,7 @@ hash_netport4_kadt(struct ip_set *set, const struct sk_buff *skb,
 		   const struct xt_action_param *par,
 		   enum ipset_adt adt, struct ip_set_adt_opt *opt)
 {
-	const struct hash_netport *h = set->data;
+	const struct hash_netport4 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_netport4_elem e = {
 		.cidr = h->nets[0].cidr ? h->nets[0].cidr - 1 : HOST_MASK - 1
@@ -183,7 +183,7 @@ static int
 hash_netport4_uadt(struct ip_set *set, struct nlattr *tb[],
 		   enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
 {
-	const struct hash_netport *h = set->data;
+	const struct hash_netport4 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_netport4_elem e = { .cidr = HOST_MASK - 1 };
 	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
@@ -383,7 +383,7 @@ nla_put_failure:
 }
 
 static inline void
-hash_netport6_data_next(struct hash_netport4_elem *next,
+hash_netport6_data_next(struct hash_netport6_elem *next,
 			const struct hash_netport6_elem *d)
 {
 	next->port = d->port;
@@ -404,7 +404,7 @@ hash_netport6_kadt(struct ip_set *set, const struct sk_buff *skb,
 		   const struct xt_action_param *par,
 		   enum ipset_adt adt, struct ip_set_adt_opt *opt)
 {
-	const struct hash_netport *h = set->data;
+	const struct hash_netport6 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_netport6_elem e = {
 		.cidr = h->nets[0].cidr ? h->nets[0].cidr - 1 : HOST_MASK - 1,
@@ -428,7 +428,7 @@ static int
 hash_netport6_uadt(struct ip_set *set, struct nlattr *tb[],
 		   enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)
 {
-	const struct hash_netport *h = set->data;
+	const struct hash_netport6 *h = set->data;
 	ipset_adtfn adtfn = set->variant->adt[adt];
 	struct hash_netport6_elem e = { .cidr = HOST_MASK  - 1 };
 	struct ip_set_ext ext = IP_SET_INIT_UEXT(h);
* Unmerged path net/netfilter/ipset/ip_set_hash_netportnet.c
