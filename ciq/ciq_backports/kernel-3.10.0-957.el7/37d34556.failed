iio: add watermark logic to iio read and poll

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iio] add watermark logic to iio read and poll (Tony Camuso) [1559170]
Rebuild_FUZZ: 94.12%
commit-author Josselin Costanzi <josselin.costanzi@mobile-devices.fr>
commit 37d3455672732b29a477732a94abfe95e199f0ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/37d34556.failed

Currently the IIO buffer blocking read only wait until at least one
data element is available.
This patch makes the reader sleep until enough data is collected before
returning to userspace. This should limit the read() calls count when
trying to get data in batches.

Co-author: Yannick Bedhomme <yannick.bedhomme@mobile-devices.fr>
	Signed-off-by: Josselin Costanzi <josselin.costanzi@mobile-devices.fr>
[rebased and remove buffer timeout]
	Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
	Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit 37d3455672732b29a477732a94abfe95e199f0ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/ABI/testing/sysfs-bus-iio
#	drivers/iio/industrialio-buffer.c
#	drivers/iio/kfifo_buf.c
#	drivers/staging/iio/accel/sca3000_ring.c
#	include/linux/iio/buffer.h
diff --cc Documentation/ABI/testing/sysfs-bus-iio
index 7ba396de2c76,0b6f0abf3370..000000000000
--- a/Documentation/ABI/testing/sysfs-bus-iio
+++ b/Documentation/ABI/testing/sysfs-bus-iio
@@@ -908,13 -1119,179 +908,188 @@@ Description
  		This attribute is used to read the amount of quadrature error
  		present in the device at a given time.
  
 -What:		/sys/.../iio:deviceX/in_accelX_power_mode
 -KernelVersion:	3.11
 +What:		/sys/bus/iio/devices/iio:device*/buffer/hwfifo_timeout
 +KernelVersion:	4.12
  Contact:	linux-iio@vger.kernel.org
  Description:
++<<<<<<< HEAD
 +		A read/write property to provide capability to delay reporting of
 +		samples till a timeout is reached. This allows host processors to
 +		sleep, while the sensor is storing samples in its internal fifo.
 +		The maximum timeout in seconds can be specified by setting
 +		hwfifo_timeout.The current delay can be read by reading
 +		hwfifo_timeout. A value of 0 means that there is no timeout.
++=======
+ 		Specifies the chip power mode.
+ 		low_noise: reduce noise level from ADC,
+ 		low_power: enable low current consumption.
+ 		For a list of available output power modes read
+ 		in_accel_power_mode_available.
+ 
+ What:		/sys/.../iio:deviceX/in_energy_input
+ What:		/sys/.../iio:deviceX/in_energy_raw
+ KernelVersion:	3.20
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		This attribute is used to read the energy value reported by the
+ 		device (e.g.: human activity sensors report energy burnt by the
+ 		user). Units after application of scale are Joules.
+ 
+ What:		/sys/.../iio:deviceX/in_distance_input
+ What:		/sys/.../iio:deviceX/in_distance_raw
+ KernelVersion:	3.20
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		This attribute is used to read the distance covered by the user
+ 		since the last reboot while activated. Units after application
+ 		of scale are meters.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/store_eeprom
+ KernelVersion:	3.4.0
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Writing '1' stores the current device configuration into
+ 		on-chip EEPROM. After power-up or chip reset the device will
+ 		automatically load the saved configuration.
+ 
+ What:		/sys/.../iio:deviceX/in_proximity_raw
+ What:		/sys/.../iio:deviceX/in_proximity_input
+ What:		/sys/.../iio:deviceX/in_proximityY_raw
+ KernelVersion:	3.4
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Proximity measurement indicating that some
+ 		object is near the sensor, usually be observing
+ 		reflectivity of infrared or ultrasound emitted.
+ 		Often these sensors are unit less and as such conversion
+ 		to SI units is not possible.  Where it is, the units should
+ 		be meters.  If such a conversion is not possible, the reported
+ 		values should behave in the same way as a distance, i.e. lower
+ 		values indicate something is closer to the sensor.
+ 
+ What:		/sys/.../iio:deviceX/in_illuminance_input
+ What:		/sys/.../iio:deviceX/in_illuminance_raw
+ What:		/sys/.../iio:deviceX/in_illuminanceY_input
+ What:		/sys/.../iio:deviceX/in_illuminanceY_raw
+ What:		/sys/.../iio:deviceX/in_illuminanceY_mean_raw
+ What:		/sys/.../iio:deviceX/in_illuminance_ir_raw
+ What:		/sys/.../iio:deviceX/in_illuminance_clear_raw
+ KernelVersion:	3.4
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Illuminance measurement, units after application of scale
+ 		and offset are lux.
+ 
+ What:		/sys/.../iio:deviceX/in_intensityY_raw
+ What:		/sys/.../iio:deviceX/in_intensityY_ir_raw
+ What:		/sys/.../iio:deviceX/in_intensityY_both_raw
+ KernelVersion:	3.4
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Unit-less light intensity. Modifiers both and ir indicate
+ 		that measurements contains visible and infrared light
+ 		components or just infrared light, respectively.
+ 
+ What:		/sys/.../iio:deviceX/in_intensity_red_integration_time
+ What:		/sys/.../iio:deviceX/in_intensity_green_integration_time
+ What:		/sys/.../iio:deviceX/in_intensity_blue_integration_time
+ What:		/sys/.../iio:deviceX/in_intensity_clear_integration_time
+ What:		/sys/.../iio:deviceX/in_illuminance_integration_time
+ KernelVersion:	3.12
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		This attribute is used to get/set the integration time in
+ 		seconds.
+ 
+ What:		/sys/.../iio:deviceX/in_velocity_sqrt(x^2+y^2+z^2)_integration_time
+ KernelVersion:	3.20
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Number of seconds in which to compute speed.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_rot_quaternion_raw
+ KernelVersion:	3.15
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Raw value of quaternion components using a format
+ 		x y z w. Here x, y, and z component represents the axis about
+ 		which a rotation will occur and w component represents the
+ 		amount of rotation.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_rot_from_north_magnetic_tilt_comp_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_rot_from_north_true_tilt_comp_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_rot_from_north_magnetic_raw
+ What:		/sys/bus/iio/devices/iio:deviceX/in_rot_from_north_true_raw
+ KernelVersion:	3.15
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Raw value of rotation from true/magnetic north measured with
+ 		or without compensation from tilt sensors.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/in_currentX_raw
+ KernelVersion:	3.18
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Raw current measurement from channel X. Units are in milliamps
+ 		after application of scale and offset. If no offset or scale is
+ 		present, output should be considered as processed with the
+ 		unit in milliamps.
+ 
+ What:		/sys/.../iio:deviceX/in_energy_en
+ What:		/sys/.../iio:deviceX/in_distance_en
+ What:		/sys/.../iio:deviceX/in_velocity_sqrt(x^2+y^2+z^2)_en
+ What:		/sys/.../iio:deviceX/in_steps_en
+ KernelVersion:	3.19
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Activates a device feature that runs in firmware/hardware.
+ 		E.g. for steps: the pedometer saves power while not used;
+ 		when activated, it will count the steps taken by the user in
+ 		firmware and export them through in_steps_input.
+ 
+ What:		/sys/.../iio:deviceX/in_steps_input
+ KernelVersion:	3.19
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		This attribute is used to read the number of steps taken by the user
+ 		since the last reboot while activated.
+ 
+ What:		/sys/.../iio:deviceX/in_velocity_sqrt(x^2+y^2+z^2)_input
+ What:		/sys/.../iio:deviceX/in_velocity_sqrt(x^2+y^2+z^2)_raw
+ KernelVersion:	3.19
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		This attribute is used to read the current speed value of the
+ 		user (which is the norm or magnitude of the velocity vector).
+ 		Units after application of scale are m/s.
+ 
+ What:		/sys/.../iio:deviceX/in_steps_debounce_count
+ KernelVersion:	3.20
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Specifies the number of steps that must occur within
+ 		in_steps_filter_debounce_time for the pedometer to decide the
+ 		consumer is making steps.
+ 
+ What:		/sys/.../iio:deviceX/in_steps_debounce_time
+ KernelVersion:	3.20
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		Specifies number of seconds in which we compute the steps
+ 		that occur in order to decide if the consumer is making steps.
+ 
+ What:		/sys/bus/iio/devices/iio:deviceX/buffer/watermark
+ KernelVersion:	4.2
+ Contact:	linux-iio@vger.kernel.org
+ Description:
+ 		A single positive integer specifying the maximum number of scan
+ 		elements to wait for.
+ 		Poll will block until the watermark is reached.
+ 		Blocking read will wait until the minimum between the requested
+ 		read amount or the low water mark is available.
+ 		Non-blocking read will retrieve the available samples from the
+ 		buffer even if there are less samples then watermark level. This
+ 		allows the application to block on poll with a timeout and read
+ 		the available samples after the timeout expires and thus have a
+ 		maximum delay guarantee.
++>>>>>>> 37d345567273 (iio: add watermark logic to iio read and poll)
diff --cc drivers/iio/industrialio-buffer.c
index ed6b8aa675ce,a24b2e005eb3..000000000000
--- a/drivers/iio/industrialio-buffer.c
+++ b/drivers/iio/industrialio-buffer.c
@@@ -37,14 -37,28 +37,31 @@@ static bool iio_buffer_is_active(struc
  	return !list_empty(&buf->buffer_list);
  }
  
- static bool iio_buffer_data_available(struct iio_buffer *buf)
+ static size_t iio_buffer_data_available(struct iio_buffer *buf)
  {
 -	return buf->access->data_available(buf);
 +	if (buf->access->data_available)
 +		return buf->access->data_available(buf);
 +
 +	return buf->stufftoread;
  }
  
+ static bool iio_buffer_ready(struct iio_dev *indio_dev, struct iio_buffer *buf,
+ 			     size_t to_wait)
+ {
+ 	/* wakeup if the device was unregistered */
+ 	if (!indio_dev->info)
+ 		return true;
+ 
+ 	/* drain the buffer if it was disabled */
+ 	if (!iio_buffer_is_active(buf))
+ 		to_wait = min_t(size_t, to_wait, 1);
+ 
+ 	if (iio_buffer_data_available(buf) >= to_wait)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
  /**
   * iio_buffer_read_first_n_outer() - chrdev read for buffer access
   *
@@@ -125,6 -147,8 +150,11 @@@ void iio_buffer_init(struct iio_buffer 
  	INIT_LIST_HEAD(&buffer->demux_list);
  	INIT_LIST_HEAD(&buffer->buffer_list);
  	init_waitqueue_head(&buffer->pollq);
++<<<<<<< HEAD
++=======
+ 	kref_init(&buffer->ref);
+ 	buffer->watermark = 1;
++>>>>>>> 37d345567273 (iio: add watermark logic to iio read and poll)
  }
  EXPORT_SYMBOL(iio_buffer_init);
  
@@@ -513,10 -439,14 +543,15 @@@ ssize_t iio_buffer_write_length(struct 
  	if (iio_buffer_is_active(indio_dev->buffer)) {
  		ret = -EBUSY;
  	} else {
 -		buffer->access->set_length(buffer, val);
 +		if (buffer->access->set_length)
 +			buffer->access->set_length(buffer, val);
  		ret = 0;
  	}
+ 	if (ret)
+ 		goto out;
+ 	if (buffer->length && buffer->length < buffer->watermark)
+ 		buffer->watermark = buffer->length;
+ out:
  	mutex_unlock(&indio_dev->mlock);
  
  	return ret ? ret : len;
@@@ -565,6 -493,20 +600,23 @@@ static int iio_compute_scan_bytes(struc
  	return bytes;
  }
  
++<<<<<<< HEAD
++=======
+ static void iio_buffer_activate(struct iio_dev *indio_dev,
+ 	struct iio_buffer *buffer)
+ {
+ 	iio_buffer_get(buffer);
+ 	list_add(&buffer->buffer_list, &indio_dev->buffer_list);
+ }
+ 
+ static void iio_buffer_deactivate(struct iio_buffer *buffer)
+ {
+ 	list_del_init(&buffer->buffer_list);
+ 	wake_up_interruptible(&buffer->pollq);
+ 	iio_buffer_put(buffer);
+ }
+ 
++>>>>>>> 37d345567273 (iio: add watermark logic to iio read and poll)
  void iio_disable_all_buffers(struct iio_dev *indio_dev)
  {
  	struct iio_buffer *buffer, *_buffer;
@@@ -837,7 -783,185 +889,189 @@@ done
  	mutex_unlock(&indio_dev->mlock);
  	return (ret < 0) ? ret : len;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(iio_buffer_store_enable);
++=======
+ 
+ static const char * const iio_scan_elements_group_name = "scan_elements";
+ 
+ static ssize_t iio_buffer_show_watermark(struct device *dev,
+ 					 struct device_attribute *attr,
+ 					 char *buf)
+ {
+ 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+ 	struct iio_buffer *buffer = indio_dev->buffer;
+ 
+ 	return sprintf(buf, "%u\n", buffer->watermark);
+ }
+ 
+ static ssize_t iio_buffer_store_watermark(struct device *dev,
+ 					  struct device_attribute *attr,
+ 					  const char *buf,
+ 					  size_t len)
+ {
+ 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+ 	struct iio_buffer *buffer = indio_dev->buffer;
+ 	unsigned int val;
+ 	int ret;
+ 
+ 	ret = kstrtouint(buf, 10, &val);
+ 	if (ret)
+ 		return ret;
+ 	if (!val)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&indio_dev->mlock);
+ 
+ 	if (val > buffer->length) {
+ 		ret = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (iio_buffer_is_active(indio_dev->buffer)) {
+ 		ret = -EBUSY;
+ 		goto out;
+ 	}
+ 
+ 	buffer->watermark = val;
+ out:
+ 	mutex_unlock(&indio_dev->mlock);
+ 
+ 	return ret ? ret : len;
+ }
+ 
+ static DEVICE_ATTR(length, S_IRUGO | S_IWUSR, iio_buffer_read_length,
+ 		   iio_buffer_write_length);
+ static struct device_attribute dev_attr_length_ro = __ATTR(length,
+ 	S_IRUGO, iio_buffer_read_length, NULL);
+ static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR,
+ 		   iio_buffer_show_enable, iio_buffer_store_enable);
+ static DEVICE_ATTR(watermark, S_IRUGO | S_IWUSR,
+ 		   iio_buffer_show_watermark, iio_buffer_store_watermark);
+ 
+ static struct attribute *iio_buffer_attrs[] = {
+ 	&dev_attr_length.attr,
+ 	&dev_attr_enable.attr,
+ 	&dev_attr_watermark.attr,
+ };
+ 
+ int iio_buffer_alloc_sysfs_and_mask(struct iio_dev *indio_dev)
+ {
+ 	struct iio_dev_attr *p;
+ 	struct attribute **attr;
+ 	struct iio_buffer *buffer = indio_dev->buffer;
+ 	int ret, i, attrn, attrcount, attrcount_orig = 0;
+ 	const struct iio_chan_spec *channels;
+ 
+ 	if (!buffer)
+ 		return 0;
+ 
+ 	attrcount = 0;
+ 	if (buffer->attrs) {
+ 		while (buffer->attrs[attrcount] != NULL)
+ 			attrcount++;
+ 	}
+ 
+ 	attr = kcalloc(attrcount + ARRAY_SIZE(iio_buffer_attrs) + 1,
+ 		       sizeof(struct attribute *), GFP_KERNEL);
+ 	if (!attr)
+ 		return -ENOMEM;
+ 
+ 	memcpy(attr, iio_buffer_attrs, sizeof(iio_buffer_attrs));
+ 	if (!buffer->access->set_length)
+ 		attr[0] = &dev_attr_length_ro.attr;
+ 
+ 	if (buffer->attrs)
+ 		memcpy(&attr[ARRAY_SIZE(iio_buffer_attrs)], buffer->attrs,
+ 		       sizeof(struct attribute *) * attrcount);
+ 
+ 	attr[attrcount + ARRAY_SIZE(iio_buffer_attrs)] = NULL;
+ 
+ 	buffer->buffer_group.name = "buffer";
+ 	buffer->buffer_group.attrs = attr;
+ 
+ 	indio_dev->groups[indio_dev->groupcounter++] = &buffer->buffer_group;
+ 
+ 	if (buffer->scan_el_attrs != NULL) {
+ 		attr = buffer->scan_el_attrs->attrs;
+ 		while (*attr++ != NULL)
+ 			attrcount_orig++;
+ 	}
+ 	attrcount = attrcount_orig;
+ 	INIT_LIST_HEAD(&buffer->scan_el_dev_attr_list);
+ 	channels = indio_dev->channels;
+ 	if (channels) {
+ 		/* new magic */
+ 		for (i = 0; i < indio_dev->num_channels; i++) {
+ 			if (channels[i].scan_index < 0)
+ 				continue;
+ 
+ 			/* Establish necessary mask length */
+ 			if (channels[i].scan_index >
+ 			    (int)indio_dev->masklength - 1)
+ 				indio_dev->masklength
+ 					= channels[i].scan_index + 1;
+ 
+ 			ret = iio_buffer_add_channel_sysfs(indio_dev,
+ 							 &channels[i]);
+ 			if (ret < 0)
+ 				goto error_cleanup_dynamic;
+ 			attrcount += ret;
+ 			if (channels[i].type == IIO_TIMESTAMP)
+ 				indio_dev->scan_index_timestamp =
+ 					channels[i].scan_index;
+ 		}
+ 		if (indio_dev->masklength && buffer->scan_mask == NULL) {
+ 			buffer->scan_mask = kcalloc(BITS_TO_LONGS(indio_dev->masklength),
+ 						    sizeof(*buffer->scan_mask),
+ 						    GFP_KERNEL);
+ 			if (buffer->scan_mask == NULL) {
+ 				ret = -ENOMEM;
+ 				goto error_cleanup_dynamic;
+ 			}
+ 		}
+ 	}
+ 
+ 	buffer->scan_el_group.name = iio_scan_elements_group_name;
+ 
+ 	buffer->scan_el_group.attrs = kcalloc(attrcount + 1,
+ 					      sizeof(buffer->scan_el_group.attrs[0]),
+ 					      GFP_KERNEL);
+ 	if (buffer->scan_el_group.attrs == NULL) {
+ 		ret = -ENOMEM;
+ 		goto error_free_scan_mask;
+ 	}
+ 	if (buffer->scan_el_attrs)
+ 		memcpy(buffer->scan_el_group.attrs, buffer->scan_el_attrs,
+ 		       sizeof(buffer->scan_el_group.attrs[0])*attrcount_orig);
+ 	attrn = attrcount_orig;
+ 
+ 	list_for_each_entry(p, &buffer->scan_el_dev_attr_list, l)
+ 		buffer->scan_el_group.attrs[attrn++] = &p->dev_attr.attr;
+ 	indio_dev->groups[indio_dev->groupcounter++] = &buffer->scan_el_group;
+ 
+ 	return 0;
+ 
+ error_free_scan_mask:
+ 	kfree(buffer->scan_mask);
+ error_cleanup_dynamic:
+ 	iio_free_chan_devattr_list(&buffer->scan_el_dev_attr_list);
+ 	kfree(indio_dev->buffer->buffer_group.attrs);
+ 
+ 	return ret;
+ }
+ 
+ void iio_buffer_free_sysfs_and_mask(struct iio_dev *indio_dev)
+ {
+ 	if (!indio_dev->buffer)
+ 		return;
+ 
+ 	kfree(indio_dev->buffer->scan_mask);
+ 	kfree(indio_dev->buffer->buffer_group.attrs);
+ 	kfree(indio_dev->buffer->scan_el_group.attrs);
+ 	iio_free_chan_devattr_list(&indio_dev->buffer->scan_el_dev_attr_list);
+ }
++>>>>>>> 37d345567273 (iio: add watermark logic to iio read and poll)
  
  /**
   * iio_validate_scan_mask_onehot() - Validates that exactly one channel is selected
@@@ -897,11 -1021,21 +1131,25 @@@ static unsigned char *iio_demux(struct 
  	return buffer->demux_bounce;
  }
  
 -static int iio_push_to_buffer(struct iio_buffer *buffer, const void *data)
 +static int iio_push_to_buffer(struct iio_buffer *buffer, unsigned char *data)
  {
++<<<<<<< HEAD
 +	unsigned char *dataout = iio_demux(buffer, data);
++=======
+ 	const void *dataout = iio_demux(buffer, data);
+ 	int ret;
++>>>>>>> 37d345567273 (iio: add watermark logic to iio read and poll)
  
- 	return buffer->access->store_to(buffer, dataout);
+ 	ret = buffer->access->store_to(buffer, dataout);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/*
+ 	 * We can't just test for watermark to decide if we wake the poll queue
+ 	 * because read may request less samples than the watermark.
+ 	 */
+ 	wake_up_interruptible_poll(&buffer->pollq, POLLIN | POLLRDNORM);
+ 	return 0;
  }
  
  static void iio_buffer_demux_free(struct iio_buffer *buffer)
diff --cc drivers/iio/kfifo_buf.c
index 1bea41bcbdc6,847ca561afe0..000000000000
--- a/drivers/iio/kfifo_buf.c
+++ b/drivers/iio/kfifo_buf.c
@@@ -102,9 -83,6 +102,12 @@@ static int iio_store_to_kfifo(struct ii
  	ret = kfifo_in(&kf->kf, data, 1);
  	if (ret != 1)
  		return -EBUSY;
++<<<<<<< HEAD
 +	r->stufftoread = true;
 +	wake_up_interruptible_poll(&r->pollq, POLLIN | POLLRDNORM);
 +
++=======
++>>>>>>> 37d345567273 (iio: add watermark logic to iio read and poll)
  	return 0;
  }
  
@@@ -130,6 -106,27 +133,30 @@@ static int iio_read_first_n_kfifo(struc
  	return copied;
  }
  
++<<<<<<< HEAD
++=======
+ static size_t iio_kfifo_buf_data_available(struct iio_buffer *r)
+ {
+ 	struct iio_kfifo *kf = iio_to_kfifo(r);
+ 	size_t samples;
+ 
+ 	mutex_lock(&kf->user_lock);
+ 	samples = kfifo_len(&kf->kf);
+ 	mutex_unlock(&kf->user_lock);
+ 
+ 	return samples;
+ }
+ 
+ static void iio_kfifo_buffer_release(struct iio_buffer *buffer)
+ {
+ 	struct iio_kfifo *kf = iio_to_kfifo(buffer);
+ 
+ 	mutex_destroy(&kf->user_lock);
+ 	kfifo_free(&kf->kf);
+ 	kfree(kf);
+ }
+ 
++>>>>>>> 37d345567273 (iio: add watermark logic to iio read and poll)
  static const struct iio_buffer_access_funcs kfifo_access_funcs = {
  	.store_to = &iio_store_to_kfifo,
  	.read_first_n = &iio_read_first_n_kfifo,
diff --cc drivers/staging/iio/accel/sca3000_ring.c
index 3e5e860aa38e,8589eade1057..000000000000
--- a/drivers/staging/iio/accel/sca3000_ring.c
+++ b/drivers/staging/iio/accel/sca3000_ring.c
@@@ -129,21 -129,11 +129,27 @@@ error_ret
  	return ret ? ret : num_read;
  }
  
++<<<<<<< HEAD
 +/* This is only valid with all 3 elements enabled */
 +static int sca3000_ring_get_length(struct iio_buffer *r)
 +{
 +	return 64;
++=======
+ static size_t sca3000_ring_buf_data_available(struct iio_buffer *r)
+ {
+ 	return r->stufftoread ? r->watermark : 0;
++>>>>>>> 37d345567273 (iio: add watermark logic to iio read and poll)
  }
  
 +/* only valid if resolution is kept at 11bits */
 +static int sca3000_ring_get_bytes_per_datum(struct iio_buffer *r)
 +{
 +	return 6;
 +}
 +
 +static IIO_BUFFER_ENABLE_ATTR;
 +static IIO_BUFFER_LENGTH_ATTR;
 +
  /**
   * sca3000_query_ring_int() is the hardware ring status interrupt enabled
   **/
diff --cc include/linux/iio/buffer.h
index 26890e4a025c,eb8622b78ec9..000000000000
--- a/include/linux/iio/buffer.h
+++ b/include/linux/iio/buffer.h
@@@ -20,14 -21,14 +20,14 @@@ struct iio_buffer
   * struct iio_buffer_access_funcs - access functions for buffers.
   * @store_to:		actually store stuff to the buffer
   * @read_first_n:	try to get a specified number of bytes (must exist)
-  * @data_available:	indicates whether data for reading from the buffer is
-  *			available.
+  * @data_available:	indicates how much data is available for reading from
+  *			the buffer.
   * @request_update:	if a parameter change has been marked, update underlying
   *			storage.
 + * @get_bytes_per_datum:get current bytes per datum
   * @set_bytes_per_datum:set number of bytes per datum
 + * @get_length:		get number of datums in buffer
   * @set_length:		set number of datums in buffer
 - * @release:		called when the last reference to the buffer is dropped,
 - *			should free all resources allocated by the buffer.
   *
   * The purpose of this structure is to make the buffer element
   * modular as event for a given driver, different usecases may require
@@@ -70,6 -71,8 +70,11 @@@ struct iio_buffer_access_funcs 
   * @demux_list:		[INTERN] list of operations required to demux the scan.
   * @demux_bounce:	[INTERN] buffer for doing gather from incoming scan.
   * @buffer_list:	[INTERN] entry in the devices list of current buffers.
++<<<<<<< HEAD
++=======
+  * @ref:		[INTERN] reference count of the buffer.
+  * @watermark:		[INTERN] number of datums to wait for poll/read.
++>>>>>>> 37d345567273 (iio: add watermark logic to iio read and poll)
   */
  struct iio_buffer {
  	int					length;
@@@ -82,10 -85,13 +87,15 @@@
  	struct attribute_group			scan_el_group;
  	wait_queue_head_t			pollq;
  	bool					stufftoread;
 -	const struct attribute			**attrs;
 +	const struct attribute_group *attrs;
  	struct list_head			demux_list;
 -	void					*demux_bounce;
 +	unsigned char				*demux_bounce;
  	struct list_head			buffer_list;
++<<<<<<< HEAD
++=======
+ 	struct kref				ref;
+ 	unsigned int				watermark;
++>>>>>>> 37d345567273 (iio: add watermark logic to iio read and poll)
  };
  
  /**
* Unmerged path Documentation/ABI/testing/sysfs-bus-iio
* Unmerged path drivers/iio/industrialio-buffer.c
* Unmerged path drivers/iio/kfifo_buf.c
* Unmerged path drivers/staging/iio/accel/sca3000_ring.c
* Unmerged path include/linux/iio/buffer.h
