nvme-pci: serialize pci resets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [nvme] pci: serialize pci resets (David Milburn) [1543698]
Rebuild_FUZZ: 90.91%
commit-author Sagi Grimberg <sagi@grimberg.me>
commit 79c48ccf2fec7c10105bd635d3bb1128167b1258
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/79c48ccf.failed

	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 79c48ccf2fec7c10105bd635d3bb1128167b1258)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/nvme.h
#	drivers/nvme/host/pci.c
diff --cc drivers/nvme/host/nvme.h
index ed57f61e9dbf,77faf2049917..000000000000
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@@ -322,12 -394,95 +322,18 @@@ int nvme_set_queue_count(struct nvme_ct
  void nvme_start_keep_alive(struct nvme_ctrl *ctrl);
  void nvme_stop_keep_alive(struct nvme_ctrl *ctrl);
  int nvme_reset_ctrl(struct nvme_ctrl *ctrl);
++<<<<<<< HEAD
++=======
+ int nvme_reset_ctrl_sync(struct nvme_ctrl *ctrl);
+ int nvme_delete_ctrl(struct nvme_ctrl *ctrl);
+ int nvme_delete_ctrl_sync(struct nvme_ctrl *ctrl);
++>>>>>>> 79c48ccf2fec (nvme-pci: serialize pci resets)
  
 -extern const struct attribute_group nvme_ns_id_attr_group;
 -extern const struct block_device_operations nvme_ns_head_ops;
 -
 -#ifdef CONFIG_NVME_MULTIPATH
 -void nvme_failover_req(struct request *req);
 -bool nvme_req_needs_failover(struct request *req, blk_status_t error);
 -void nvme_kick_requeue_lists(struct nvme_ctrl *ctrl);
 -int nvme_mpath_alloc_disk(struct nvme_ctrl *ctrl,struct nvme_ns_head *head);
 -void nvme_mpath_add_disk(struct nvme_ns_head *head);
 -void nvme_mpath_add_disk_links(struct nvme_ns *ns);
 -void nvme_mpath_remove_disk(struct nvme_ns_head *head);
 -void nvme_mpath_remove_disk_links(struct nvme_ns *ns);
 -
 -static inline void nvme_mpath_clear_current_path(struct nvme_ns *ns)
 -{
 -	struct nvme_ns_head *head = ns->head;
 -
 -	if (head && ns == srcu_dereference(head->current_path, &head->srcu))
 -		rcu_assign_pointer(head->current_path, NULL);
 -}
 -struct nvme_ns *nvme_find_path(struct nvme_ns_head *head);
 -#else
 -static inline void nvme_failover_req(struct request *req)
 -{
 -}
 -static inline bool nvme_req_needs_failover(struct request *req,
 -					   blk_status_t error)
 -{
 -	return false;
 -}
 -static inline void nvme_kick_requeue_lists(struct nvme_ctrl *ctrl)
 -{
 -}
 -static inline int nvme_mpath_alloc_disk(struct nvme_ctrl *ctrl,
 -		struct nvme_ns_head *head)
 -{
 -	return 0;
 -}
 -static inline void nvme_mpath_add_disk(struct nvme_ns_head *head)
 -{
 -}
 -static inline void nvme_mpath_remove_disk(struct nvme_ns_head *head)
 -{
 -}
 -static inline void nvme_mpath_add_disk_links(struct nvme_ns *ns)
 -{
 -}
 -static inline void nvme_mpath_remove_disk_links(struct nvme_ns *ns)
 -{
 -}
 -static inline void nvme_mpath_clear_current_path(struct nvme_ns *ns)
 -{
 -}
 -#endif /* CONFIG_NVME_MULTIPATH */
 -
 -#ifdef CONFIG_NVM
 -int nvme_nvm_register(struct nvme_ns *ns, char *disk_name, int node);
 -void nvme_nvm_unregister(struct nvme_ns *ns);
 -int nvme_nvm_register_sysfs(struct nvme_ns *ns);
 -void nvme_nvm_unregister_sysfs(struct nvme_ns *ns);
 -int nvme_nvm_ioctl(struct nvme_ns *ns, unsigned int cmd, unsigned long arg);
 -#else
 -static inline int nvme_nvm_register(struct nvme_ns *ns, char *disk_name,
 -				    int node)
 -{
 -	return 0;
 -}
 -
 -static inline void nvme_nvm_unregister(struct nvme_ns *ns) {};
 -static inline int nvme_nvm_register_sysfs(struct nvme_ns *ns)
 -{
 -	return 0;
 -}
 -static inline void nvme_nvm_unregister_sysfs(struct nvme_ns *ns) {};
 -static inline int nvme_nvm_ioctl(struct nvme_ns *ns, unsigned int cmd,
 -							unsigned long arg)
 -{
 -	return -ENOTTY;
 -}
 -#endif /* CONFIG_NVM */
 +struct sg_io_hdr;
  
 -static inline struct nvme_ns *nvme_get_ns_from_dev(struct device *dev)
 -{
 -	return dev_to_disk(dev)->private_data;
 -}
 +int nvme_sg_io(struct nvme_ns *ns, struct sg_io_hdr __user *u_hdr);
 +int nvme_sg_io32(struct nvme_ns *ns, unsigned long arg);
 +int nvme_sg_get_version_num(int __user *ip);
  
  int __init nvme_core_init(void);
  void nvme_core_exit(void);
diff --cc drivers/nvme/host/pci.c
index da397292f0d6,dc9a4cf7c1d1..000000000000
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@@ -2229,14 -2528,16 +2229,21 @@@ static int nvme_probe(struct pci_dev *p
  	return result;
  }
  
 -static void nvme_reset_prepare(struct pci_dev *pdev)
 +static void nvme_reset_notify(struct pci_dev *pdev, bool prepare)
  {
  	struct nvme_dev *dev = pci_get_drvdata(pdev);
 -	nvme_dev_disable(dev, false);
 -}
  
++<<<<<<< HEAD
 +	if (prepare)
 +		nvme_dev_disable(dev, false);
 +	else
 +		nvme_reset_ctrl(&dev->ctrl);
++=======
+ static void nvme_reset_done(struct pci_dev *pdev)
+ {
+ 	struct nvme_dev *dev = pci_get_drvdata(pdev);
+ 	nvme_reset_ctrl_sync(&dev->ctrl);
++>>>>>>> 79c48ccf2fec (nvme-pci: serialize pci resets)
  }
  
  static void nvme_shutdown(struct pci_dev *pdev)
diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index e5adfe00280c..1d76d21ebeb8 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -83,7 +83,7 @@ int nvme_reset_ctrl(struct nvme_ctrl *ctrl)
 }
 EXPORT_SYMBOL_GPL(nvme_reset_ctrl);
 
-static int nvme_reset_ctrl_sync(struct nvme_ctrl *ctrl)
+int nvme_reset_ctrl_sync(struct nvme_ctrl *ctrl)
 {
 	int ret;
 
@@ -92,6 +92,7 @@ static int nvme_reset_ctrl_sync(struct nvme_ctrl *ctrl)
 		flush_work(&ctrl->reset_work);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(nvme_reset_ctrl_sync);
 
 static int nvme_error_status(struct request *req)
 {
* Unmerged path drivers/nvme/host/nvme.h
* Unmerged path drivers/nvme/host/pci.c
