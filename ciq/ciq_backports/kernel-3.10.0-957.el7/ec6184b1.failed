Input: psmouse - limit protocols that we try on passthrough ports

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [input] psmouse - limit protocols that we try on passthrough ports (Benjamin Tissoires) [1554926]
Rebuild_FUZZ: 94.31%
commit-author Dmitry Torokhov <dmitry.torokhov@gmail.com>
commit ec6184b1c717b8768122e25fe6d312f609cc1bb4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ec6184b1.failed

PS/2 protocol is slow, and using it with pass-through port (where we
encapsulate PS/2 into PS/2) is slower yet so it takes quite a bit of time
to do full protocol discovery for device attached to a pass-through port.
However, so far we have not see anything but trackpoints or basic PS/2
mice on pass-through ports, so let's limit protocols that we probe there
to Trackpoint, IntelliMouse Explorer, IntelliMouse, and bare PS/2 protocol,
and avoid other extended protocols, such as Synaptics, ALPS, etc.

	Reviewed-by: Hans de Goede <hdegoede@redhat.com>
	Reviewed-by: Pali Roh√°r <pali.rohar@gmail.com>
	Tested-by: Marcin Sochacki <msochacki+kernel@gmail.com>
	Tested-by: Till <till2.schaefer@uni-dortmund.de>
	Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
(cherry picked from commit ec6184b1c717b8768122e25fe6d312f609cc1bb4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/input/mouse/psmouse-base.c
diff --cc drivers/input/mouse/psmouse-base.c
index e63171ffe241,f12df771eeb2..000000000000
--- a/drivers/input/mouse/psmouse-base.c
+++ b/drivers/input/mouse/psmouse-base.c
@@@ -1097,6 -889,273 +1102,276 @@@ static const struct psmouse_protocol *p
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Apply default settings to the psmouse structure. Most of them will
+  * be overridden by individual protocol initialization routines.
+  */
+ static void psmouse_apply_defaults(struct psmouse *psmouse)
+ {
+ 	struct input_dev *input_dev = psmouse->dev;
+ 
+ 	memset(input_dev->evbit, 0, sizeof(input_dev->evbit));
+ 	memset(input_dev->keybit, 0, sizeof(input_dev->keybit));
+ 	memset(input_dev->relbit, 0, sizeof(input_dev->relbit));
+ 	memset(input_dev->absbit, 0, sizeof(input_dev->absbit));
+ 	memset(input_dev->mscbit, 0, sizeof(input_dev->mscbit));
+ 
+ 	__set_bit(EV_KEY, input_dev->evbit);
+ 	__set_bit(EV_REL, input_dev->evbit);
+ 
+ 	__set_bit(BTN_LEFT, input_dev->keybit);
+ 	__set_bit(BTN_RIGHT, input_dev->keybit);
+ 
+ 	__set_bit(REL_X, input_dev->relbit);
+ 	__set_bit(REL_Y, input_dev->relbit);
+ 
+ 	__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 	psmouse->set_rate = psmouse_set_rate;
+ 	psmouse->set_resolution = psmouse_set_resolution;
+ 	psmouse->set_scale = psmouse_set_scale;
+ 	psmouse->poll = psmouse_poll;
+ 	psmouse->protocol_handler = psmouse_process_byte;
+ 	psmouse->pktsize = 3;
+ 	psmouse->reconnect = NULL;
+ 	psmouse->disconnect = NULL;
+ 	psmouse->cleanup = NULL;
+ 	psmouse->pt_activate = NULL;
+ 	psmouse->pt_deactivate = NULL;
+ }
+ 
+ static bool psmouse_try_protocol(struct psmouse *psmouse,
+ 				 enum psmouse_type type,
+ 				 unsigned int *max_proto,
+ 				 bool set_properties, bool init_allowed)
+ {
+ 	const struct psmouse_protocol *proto;
+ 
+ 	proto = __psmouse_protocol_by_type(type);
+ 	if (!proto)
+ 		return false;
+ 
+ 	if (psmouse->ps2dev.serio->id.type == SERIO_PS_PSTHRU &&
+ 	    !proto->try_passthru) {
+ 		return false;
+ 	}
+ 
+ 	if (set_properties)
+ 		psmouse_apply_defaults(psmouse);
+ 
+ 	if (proto->detect(psmouse, set_properties) != 0)
+ 		return false;
+ 
+ 	if (set_properties && proto->init && init_allowed) {
+ 		if (proto->init(psmouse) != 0) {
+ 			/*
+ 			 * We detected device, but init failed. Adjust
+ 			 * max_proto so we only try standard protocols.
+ 			 */
+ 			if (*max_proto > PSMOUSE_IMEX)
+ 				*max_proto = PSMOUSE_IMEX;
+ 
+ 			return false;
+ 		}
+ 	}
+ 
+ 	return true;
+ }
+ 
+ /*
+  * psmouse_extensions() probes for any extensions to the basic PS/2 protocol
+  * the mouse may have.
+  */
+ static int psmouse_extensions(struct psmouse *psmouse,
+ 			      unsigned int max_proto, bool set_properties)
+ {
+ 	bool synaptics_hardware = false;
+ 
+ 	/*
+ 	 * Always check for focaltech, this is safe as it uses pnp-id
+ 	 * matching.
+ 	 */
+ 	if (psmouse_try_protocol(psmouse, PSMOUSE_FOCALTECH,
+ 				 &max_proto, set_properties, false)) {
+ 		if (max_proto > PSMOUSE_IMEX &&
+ 		    IS_ENABLED(CONFIG_MOUSE_PS2_FOCALTECH) &&
+ 		    (!set_properties || focaltech_init(psmouse) == 0)) {
+ 			return PSMOUSE_FOCALTECH;
+ 		}
+ 		/*
+ 		 * Restrict psmouse_max_proto so that psmouse_initialize()
+ 		 * does not try to reset rate and resolution, because even
+ 		 * that upsets the device.
+ 		 * This also causes us to basically fall through to basic
+ 		 * protocol detection, where we fully reset the mouse,
+ 		 * and set it up as bare PS/2 protocol device.
+ 		 */
+ 		psmouse_max_proto = max_proto = PSMOUSE_PS2;
+ 	}
+ 
+ 	/*
+ 	 * We always check for LifeBook because it does not disturb mouse
+ 	 * (it only checks DMI information).
+ 	 */
+ 	if (psmouse_try_protocol(psmouse, PSMOUSE_LIFEBOOK, &max_proto,
+ 				 set_properties, max_proto > PSMOUSE_IMEX))
+ 		return PSMOUSE_LIFEBOOK;
+ 
+ 	if (psmouse_try_protocol(psmouse, PSMOUSE_VMMOUSE, &max_proto,
+ 				 set_properties, max_proto > PSMOUSE_IMEX))
+ 		return PSMOUSE_VMMOUSE;
+ 
+ 	/*
+ 	 * Try Kensington ThinkingMouse (we try first, because Synaptics
+ 	 * probe upsets the ThinkingMouse).
+ 	 */
+ 	if (max_proto > PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_THINKPS, &max_proto,
+ 				 set_properties, true)) {
+ 		return PSMOUSE_THINKPS;
+ 	}
+ 
+ 	/*
+ 	 * Try Synaptics TouchPad. Note that probing is done even if
+ 	 * Synaptics protocol support is disabled in config - we need to
+ 	 * know if it is Synaptics so we can reset it properly after
+ 	 * probing for IntelliMouse.
+ 	 */
+ 	if (max_proto > PSMOUSE_PS2 &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_SYNAPTICS, &max_proto,
+ 				 set_properties, false)) {
+ 		synaptics_hardware = true;
+ 
+ 		if (max_proto > PSMOUSE_IMEX) {
+ 			/*
+ 			 * Try activating protocol, but check if support is
+ 			 * enabled first, since we try detecting Synaptics
+ 			 * even when protocol is disabled.
+ 			 */
+ 			if (IS_ENABLED(CONFIG_MOUSE_PS2_SYNAPTICS) &&
+ 			    (!set_properties || synaptics_init(psmouse) == 0)) {
+ 				return PSMOUSE_SYNAPTICS;
+ 			}
+ 
+ 			/*
+ 			 * Some Synaptics touchpads can emulate extended
+ 			 * protocols (like IMPS/2).  Unfortunately
+ 			 * Logitech/Genius probes confuse some firmware
+ 			 * versions so we'll have to skip them.
+ 			 */
+ 			max_proto = PSMOUSE_IMEX;
+ 		}
+ 
+ 		/*
+ 		 * Make sure that touchpad is in relative mode, gestures
+ 		 * (taps) are enabled.
+ 		 */
+ 		synaptics_reset(psmouse);
+ 	}
+ 
+ 	/*
+ 	 * Try Cypress Trackpad. We must try it before Finger Sensing Pad
+ 	 * because Finger Sensing Pad probe upsets some modules of Cypress
+ 	 * Trackpads.
+ 	 */
+ 	if (max_proto > PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_CYPRESS, &max_proto,
+ 				 set_properties, true)) {
+ 		return PSMOUSE_CYPRESS;
+ 	}
+ 
+ 	/* Try ALPS TouchPad */
+ 	if (max_proto > PSMOUSE_IMEX) {
+ 		ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);
+ 		if (psmouse_try_protocol(psmouse, PSMOUSE_ALPS,
+ 					 &max_proto, set_properties, true))
+ 			return PSMOUSE_ALPS;
+ 	}
+ 
+ 	/* Try OLPC HGPK touchpad */
+ 	if (max_proto > PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_HGPK, &max_proto,
+ 				 set_properties, true)) {
+ 		return PSMOUSE_HGPK;
+ 	}
+ 
+ 	/* Try Elantech touchpad */
+ 	if (max_proto > PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_ELANTECH,
+ 				 &max_proto, set_properties, true)) {
+ 		return PSMOUSE_ELANTECH;
+ 	}
+ 
+ 	if (max_proto > PSMOUSE_IMEX) {
+ 		if (psmouse_try_protocol(psmouse, PSMOUSE_GENPS,
+ 					 &max_proto, set_properties, true))
+ 			return PSMOUSE_GENPS;
+ 
+ 		if (psmouse_try_protocol(psmouse, PSMOUSE_PS2PP,
+ 					 &max_proto, set_properties, true))
+ 			return PSMOUSE_PS2PP;
+ 
+ 		if (psmouse_try_protocol(psmouse, PSMOUSE_TRACKPOINT,
+ 					 &max_proto, set_properties, true))
+ 			return PSMOUSE_TRACKPOINT;
+ 
+ 		if (psmouse_try_protocol(psmouse, PSMOUSE_TOUCHKIT_PS2,
+ 					 &max_proto, set_properties, true))
+ 			return PSMOUSE_TOUCHKIT_PS2;
+ 	}
+ 
+ 	/*
+ 	 * Try Finger Sensing Pad. We do it here because its probe upsets
+ 	 * Trackpoint devices (causing TP_READ_ID command to time out).
+ 	 */
+ 	if (max_proto > PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_FSP,
+ 				 &max_proto, set_properties, true)) {
+ 		return PSMOUSE_FSP;
+ 	}
+ 
+ 	/*
+ 	 * Reset to defaults in case the device got confused by extended
+ 	 * protocol probes. Note that we follow up with full reset because
+ 	 * some mice put themselves to sleep when they see PSMOUSE_RESET_DIS.
+ 	 */
+ 	ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);
+ 	psmouse_reset(psmouse);
+ 
+ 	if (max_proto >= PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_IMEX,
+ 				 &max_proto, set_properties, true)) {
+ 		return PSMOUSE_IMEX;
+ 	}
+ 
+ 	if (max_proto >= PSMOUSE_IMPS &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_IMPS,
+ 				 &max_proto, set_properties, true)) {
+ 		return PSMOUSE_IMPS;
+ 	}
+ 
+ 	/*
+ 	 * Okay, all failed, we have a standard mouse here. The number of
+ 	 * the buttons is still a question, though. We assume 3.
+ 	 */
+ 	psmouse_try_protocol(psmouse, PSMOUSE_PS2,
+ 			     &max_proto, set_properties, true);
+ 
+ 	if (synaptics_hardware) {
+ 		/*
+ 		 * We detected Synaptics hardware but it did not respond to
+ 		 * IMPS/2 probes.  We need to reset the touchpad because if
+ 		 * there is a track point on the pass through port it could
+ 		 * get disabled while probing for protocol extensions.
+ 		 */
+ 		psmouse_reset(psmouse);
+ 	}
+ 
+ 	return PSMOUSE_PS2;
+ }
++>>>>>>> ec6184b1c717 (Input: psmouse - limit protocols that we try on passthrough ports)
  
  /*
   * psmouse_probe() probes for a PS/2 mouse.
* Unmerged path drivers/input/mouse/psmouse-base.c
