Partial revert "e1000e: Avoid receiver overrun interrupt bursts"

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Benjamin Poirier <bpoirier@suse.com>
commit 1f0ea19722ef9dfa229a9540f70b8d1c34a98a6a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1f0ea197.failed

This partially reverts commit 4aea7a5c5e940c1723add439f4088844cd26196d.

We keep the fix for the first part of the problem (1) described in the log
of that commit, that is to read ICR in the other interrupt handler. We
remove the fix for the second part of the problem (2), Other interrupt
throttling.

Bursts of "Other" interrupts may once again occur during rxo (receive
overflow) traffic conditions. This is deemed acceptable in the interest of
avoiding unforeseen fallout from changes that are not strictly necessary.
As discussed, the e1000e driver should be in "maintenance mode".

Link: https://www.spinics.net/lists/netdev/msg480675.html
	Signed-off-by: Benjamin Poirier <bpoirier@suse.com>
	Acked-by: Alexander Duyck <alexander.h.duyck@intel.com>
	Tested-by: Aaron Brown <aaron.f.brown@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 1f0ea19722ef9dfa229a9540f70b8d1c34a98a6a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/e1000e/netdev.c
diff --cc drivers/net/ethernet/intel/e1000e/netdev.c
index b81ce07a75e5,3b36efa6228d..000000000000
--- a/drivers/net/ethernet/intel/e1000e/netdev.c
+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
@@@ -1913,14 -1914,21 +1913,30 @@@ static irqreturn_t e1000_msix_other(in
  	struct net_device *netdev = data;
  	struct e1000_adapter *adapter = netdev_priv(netdev);
  	struct e1000_hw *hw = &adapter->hw;
++<<<<<<< HEAD
++=======
+ 	u32 icr;
++>>>>>>> 1f0ea19722ef (Partial revert "e1000e: Avoid receiver overrun interrupt bursts")
  
 -	icr = er32(ICR);
 -	ew32(ICR, E1000_ICR_OTHER);
 +	hw->mac.get_link_status = true;
  
++<<<<<<< HEAD
 +	/* guard against interrupt when we're going down */
 +	if (!test_bit(__E1000_DOWN, &adapter->state)) {
 +		mod_timer(&adapter->watchdog_timer, jiffies + 1);
++=======
+ 	if (icr & E1000_ICR_LSC) {
+ 		ew32(ICR, E1000_ICR_LSC);
+ 		hw->mac.get_link_status = true;
+ 		/* guard against interrupt when we're going down */
+ 		if (!test_bit(__E1000_DOWN, &adapter->state))
+ 			mod_timer(&adapter->watchdog_timer, jiffies + 1);
+ 	}
+ 
+ 	if (!test_bit(__E1000_DOWN, &adapter->state))
++>>>>>>> 1f0ea19722ef (Partial revert "e1000e: Avoid receiver overrun interrupt bursts")
  		ew32(IMS, E1000_IMS_OTHER);
 +	}
  
  	return IRQ_HANDLED;
  }
* Unmerged path drivers/net/ethernet/intel/e1000e/netdev.c
