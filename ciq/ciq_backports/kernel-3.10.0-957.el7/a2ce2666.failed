mremap: move_ptes: check pte dirty after its removal

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mm] move_ptes: check pte dirty after its removal (Christoph von Recklinghausen) [1490234]
Rebuild_FUZZ: 91.67%
commit-author Aaron Lu <aaron.lu@intel.com>
commit a2ce2666aa3509ac31fac0f540a3502372b7b630
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/a2ce2666.failed

Linus found there still is a race in mremap after commit 5d1904204c99
("mremap: fix race between mremap() and page cleanning").

As described by Linus:
 "the issue is that another thread might make the pte be dirty (in the
  hardware walker, so no locking of ours will make any difference)
  *after* we checked whether it was dirty, but *before* we removed it
  from the page tables"

Fix it by moving the check after we removed it from the page table.

	Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
	Signed-off-by: Aaron Lu <aaron.lu@intel.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit a2ce2666aa3509ac31fac0f540a3502372b7b630)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/huge_memory.c
#	mm/mremap.c
diff --cc mm/huge_memory.c
index 075f651aabed,d4a6e4001512..000000000000
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@@ -1856,9 -1456,13 +1856,15 @@@ int move_huge_pmd(struct vm_area_struc
  		new_ptl = pmd_lockptr(mm, new_pmd);
  		if (new_ptl != old_ptl)
  			spin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);
++<<<<<<< HEAD
 +		pmd = pmdp_get_and_clear(mm, old_addr, old_pmd);
++=======
+ 		pmd = pmdp_huge_get_and_clear(mm, old_addr, old_pmd);
+ 		if (pmd_present(pmd) && pmd_dirty(pmd))
+ 			force_flush = true;
++>>>>>>> a2ce2666aa35 (mremap: move_ptes: check pte dirty after its removal)
  		VM_BUG_ON(!pmd_none(*new_pmd));
 -
 -		if (pmd_move_must_withdraw(new_ptl, old_ptl) &&
 -				vma_is_anonymous(vma)) {
 +		if (pmd_move_must_withdraw(new_ptl, old_ptl)) {
  			pgtable_t pgtable;
  			pgtable = pgtable_trans_huge_withdraw(mm, old_pmd);
  			pgtable_trans_huge_deposit(mm, new_pmd, pgtable);
diff --cc mm/mremap.c
index 075feac0d8ea,30d7d2482eea..000000000000
--- a/mm/mremap.c
+++ b/mm/mremap.c
@@@ -145,7 -148,19 +145,22 @@@ static void move_ptes(struct vm_area_st
  				   new_pte++, new_addr += PAGE_SIZE) {
  		if (pte_none(*old_pte))
  			continue;
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> a2ce2666aa35 (mremap: move_ptes: check pte dirty after its removal)
  		pte = ptep_get_and_clear(mm, old_addr, old_pte);
+ 		/*
+ 		 * If we are remapping a dirty PTE, make sure
+ 		 * to flush TLB before we drop the PTL for the
+ 		 * old PTE or we may race with page_mkclean().
+ 		 *
+ 		 * This check has to be done after we removed the
+ 		 * old PTE from page tables or another thread may
+ 		 * dirty it after the check and before the removal.
+ 		 */
+ 		if (pte_present(pte) && pte_dirty(pte))
+ 			force_flush = true;
  		pte = move_pte(pte, new_vma->vm_page_prot, old_addr, new_addr);
  		pte = move_soft_dirty_pte(pte);
  		set_pte_at(mm, new_addr, new_pte, pte);
* Unmerged path mm/huge_memory.c
* Unmerged path mm/mremap.c
