net: aquantia: Change confusing no_ff_addr to more meaningful name

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] aquantia: Change confusing no_ff_addr to more meaningful name (David Arcari) [1546765]
Rebuild_FUZZ: 96.06%
commit-author Igor Russkikh <igor.russkikh@aquantia.com>
commit 76c19c6cfa8f7e4f8c7d5407f77237b80095e5d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/76c19c6c.failed

The address to check if HW is not dead/hang could be stored in
capabilities, since it is a constant. Change its name to better reflect
the idea.

	Signed-off-by: Igor Russkikh <igor.russkikh@aquantia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 76c19c6cfa8f7e4f8c7d5407f77237b80095e5d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_hw.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_hw.h
index cdd1acd417c2,a8bf38791079..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
@@@ -29,7 -31,7 +29,11 @@@ struct aq_hw_caps_s 
  	u32 vecs;
  	u32 mtu;
  	u32 mac_regs_count;
++<<<<<<< HEAD
 +	u8 ports;
++=======
+ 	u32 hw_alive_check_addr;
++>>>>>>> 76c19c6cfa8f (net: aquantia: Change confusing no_ff_addr to more meaningful name)
  	u8 msix_irqs;
  	u8 tcs;
  	u8 rxd_alignment;
@@@ -90,9 -92,17 +94,8 @@@ struct aq_stats_s 
  struct aq_hw_s {
  	atomic_t flags;
  	struct aq_nic_cfg_s *aq_nic_cfg;
 +	struct aq_pci_func_s *aq_pci_func;
  	void __iomem *mmio;
- 	unsigned int not_ff_addr;
  	struct aq_hw_link_status_s aq_link_status;
  	struct hw_aq_atl_utils_mbox mbox;
  	struct hw_atl_stats_s last_stats;
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c
index 773434b96bb0,52f2eb543ee4..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c
@@@ -17,45 -18,67 +17,73 @@@
  #include "hw_atl_llh.h"
  #include "hw_atl_a0_internal.h"
  
++<<<<<<< HEAD
 +static int hw_atl_a0_get_hw_caps(struct aq_hw_s *self,
 +				 struct aq_hw_caps_s *aq_hw_caps,
 +				 unsigned short device,
 +				 unsigned short subsystem_device)
 +{
 +	memcpy(aq_hw_caps, &hw_atl_a0_hw_caps_, sizeof(*aq_hw_caps));
++=======
+ #define DEFAULT_A0_BOARD_BASIC_CAPABILITIES \
+ 	.is_64_dma = true, \
+ 	.msix_irqs = 4U, \
+ 	.irq_mask = ~0U, \
+ 	.vecs = HW_ATL_A0_RSS_MAX, \
+ 	.tcs = HW_ATL_A0_TC_MAX, \
+ 	.rxd_alignment = 1U, \
+ 	.rxd_size = HW_ATL_A0_RXD_SIZE, \
+ 	.rxds = 248U, \
+ 	.txd_alignment = 1U, \
+ 	.txd_size = HW_ATL_A0_TXD_SIZE, \
+ 	.txds = 8U * 1024U, \
+ 	.txhwb_alignment = 4096U, \
+ 	.tx_rings = HW_ATL_A0_TX_RINGS, \
+ 	.rx_rings = HW_ATL_A0_RX_RINGS, \
+ 	.hw_features = NETIF_F_HW_CSUM | \
+ 			NETIF_F_RXHASH | \
+ 			NETIF_F_RXCSUM | \
+ 			NETIF_F_SG | \
+ 			NETIF_F_TSO, \
+ 	.hw_priv_flags = IFF_UNICAST_FLT, \
+ 	.flow_control = true, \
+ 	.mtu = HW_ATL_A0_MTU_JUMBO, \
+ 	.mac_regs_count = 88, \
+ 	.hw_alive_check_addr = 0x10U
++>>>>>>> 76c19c6cfa8f (net: aquantia: Change confusing no_ff_addr to more meaningful name)
  
 -const struct aq_hw_caps_s hw_atl_a0_caps_aqc100 = {
 -	DEFAULT_A0_BOARD_BASIC_CAPABILITIES,
 -	.media_type = AQ_HW_MEDIA_TYPE_FIBRE,
 -	.link_speed_msk = HW_ATL_A0_RATE_5G  |
 -			  HW_ATL_A0_RATE_2G5 |
 -			  HW_ATL_A0_RATE_1G  |
 -			  HW_ATL_A0_RATE_100M,
 -};
 +	if (device == HW_ATL_DEVICE_ID_D108 && subsystem_device == 0x0001)
 +		aq_hw_caps->link_speed_msk &= ~HW_ATL_A0_RATE_10G;
  
 -const struct aq_hw_caps_s hw_atl_a0_caps_aqc107 = {
 -	DEFAULT_A0_BOARD_BASIC_CAPABILITIES,
 -	.media_type = AQ_HW_MEDIA_TYPE_TP,
 -	.link_speed_msk = HW_ATL_A0_RATE_10G |
 -			  HW_ATL_A0_RATE_5G  |
 -			  HW_ATL_A0_RATE_2G5 |
 -			  HW_ATL_A0_RATE_1G  |
 -			  HW_ATL_A0_RATE_100M,
 -};
 +	if (device == HW_ATL_DEVICE_ID_D109 && subsystem_device == 0x0001) {
 +		aq_hw_caps->link_speed_msk &= ~HW_ATL_A0_RATE_10G;
 +		aq_hw_caps->link_speed_msk &= ~HW_ATL_A0_RATE_5G;
 +	}
  
 -const struct aq_hw_caps_s hw_atl_a0_caps_aqc108 = {
 -	DEFAULT_A0_BOARD_BASIC_CAPABILITIES,
 -	.media_type = AQ_HW_MEDIA_TYPE_TP,
 -	.link_speed_msk = HW_ATL_A0_RATE_5G  |
 -			  HW_ATL_A0_RATE_2G5 |
 -			  HW_ATL_A0_RATE_1G  |
 -			  HW_ATL_A0_RATE_100M,
 -};
 +	return 0;
 +}
  
 -const struct aq_hw_caps_s hw_atl_a0_caps_aqc109 = {
 -	DEFAULT_A0_BOARD_BASIC_CAPABILITIES,
 -	.media_type = AQ_HW_MEDIA_TYPE_TP,
 -	.link_speed_msk = HW_ATL_A0_RATE_2G5 |
 -			  HW_ATL_A0_RATE_1G  |
 -			  HW_ATL_A0_RATE_100M,
 -};
 +static struct aq_hw_s *hw_atl_a0_create(struct aq_pci_func_s *aq_pci_func,
 +					unsigned int port)
 +{
 +	struct aq_hw_s *self = NULL;
 +
 +	self = kzalloc(sizeof(*self), GFP_KERNEL);
 +	if (!self)
 +		goto err_exit;
 +
 +	self->aq_pci_func = aq_pci_func;
 +
 +	self->not_ff_addr = 0x10U;
 +
 +err_exit:
 +	return self;
 +}
 +
 +static void hw_atl_a0_destroy(struct aq_hw_s *self)
 +{
 +	kfree(self);
 +}
  
  static int hw_atl_a0_hw_reset(struct aq_hw_s *self)
  {
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
index 5e4035a987be,f601230166ee..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
@@@ -18,45 -19,69 +18,74 @@@
  #include "hw_atl_b0_internal.h"
  #include "hw_atl_llh_internal.h"
  
++<<<<<<< HEAD
 +static int hw_atl_b0_get_hw_caps(struct aq_hw_s *self,
 +				 struct aq_hw_caps_s *aq_hw_caps,
 +				 unsigned short device,
 +				 unsigned short subsystem_device)
 +{
 +	memcpy(aq_hw_caps, &hw_atl_b0_hw_caps_, sizeof(*aq_hw_caps));
++=======
+ #define DEFAULT_B0_BOARD_BASIC_CAPABILITIES \
+ 	.is_64_dma = true,	\
+ 	.msix_irqs = 4U,	\
+ 	.irq_mask = ~0U,	\
+ 	.vecs = HW_ATL_B0_RSS_MAX,	\
+ 	.tcs = HW_ATL_B0_TC_MAX,	\
+ 	.rxd_alignment = 1U,		\
+ 	.rxd_size = HW_ATL_B0_RXD_SIZE, \
+ 	.rxds = 4U * 1024U,		\
+ 	.txd_alignment = 1U,		\
+ 	.txd_size = HW_ATL_B0_TXD_SIZE, \
+ 	.txds = 8U * 1024U,		\
+ 	.txhwb_alignment = 4096U,	\
+ 	.tx_rings = HW_ATL_B0_TX_RINGS, \
+ 	.rx_rings = HW_ATL_B0_RX_RINGS, \
+ 	.hw_features = NETIF_F_HW_CSUM | \
+ 			NETIF_F_RXCSUM | \
+ 			NETIF_F_RXHASH | \
+ 			NETIF_F_SG |  \
+ 			NETIF_F_TSO | \
+ 			NETIF_F_LRO,  \
+ 	.hw_priv_flags = IFF_UNICAST_FLT,   \
+ 	.flow_control = true,		\
+ 	.mtu = HW_ATL_B0_MTU_JUMBO,	\
+ 	.mac_regs_count = 88,		\
+ 	.hw_alive_check_addr = 0x10U
++>>>>>>> 76c19c6cfa8f (net: aquantia: Change confusing no_ff_addr to more meaningful name)
  
 -const struct aq_hw_caps_s hw_atl_b0_caps_aqc100 = {
 -	DEFAULT_B0_BOARD_BASIC_CAPABILITIES,
 -	.media_type = AQ_HW_MEDIA_TYPE_FIBRE,
 -	.link_speed_msk = HW_ATL_B0_RATE_10G |
 -			  HW_ATL_B0_RATE_5G  |
 -			  HW_ATL_B0_RATE_2G5 |
 -			  HW_ATL_B0_RATE_1G  |
 -			  HW_ATL_B0_RATE_100M,
 -};
 +	if (device == HW_ATL_DEVICE_ID_D108 && subsystem_device == 0x0001)
 +		aq_hw_caps->link_speed_msk &= ~HW_ATL_B0_RATE_10G;
  
 -const struct aq_hw_caps_s hw_atl_b0_caps_aqc107 = {
 -	DEFAULT_B0_BOARD_BASIC_CAPABILITIES,
 -	.media_type = AQ_HW_MEDIA_TYPE_TP,
 -	.link_speed_msk = HW_ATL_B0_RATE_10G |
 -			  HW_ATL_B0_RATE_5G  |
 -			  HW_ATL_B0_RATE_2G5 |
 -			  HW_ATL_B0_RATE_1G  |
 -			  HW_ATL_B0_RATE_100M,
 -};
 +	if (device == HW_ATL_DEVICE_ID_D109 && subsystem_device == 0x0001) {
 +		aq_hw_caps->link_speed_msk &= ~HW_ATL_B0_RATE_10G;
 +		aq_hw_caps->link_speed_msk &= ~HW_ATL_B0_RATE_5G;
 +	}
  
 -const struct aq_hw_caps_s hw_atl_b0_caps_aqc108 = {
 -	DEFAULT_B0_BOARD_BASIC_CAPABILITIES,
 -	.media_type = AQ_HW_MEDIA_TYPE_TP,
 -	.link_speed_msk = HW_ATL_B0_RATE_5G  |
 -			  HW_ATL_B0_RATE_2G5 |
 -			  HW_ATL_B0_RATE_1G  |
 -			  HW_ATL_B0_RATE_100M,
 -};
 +	return 0;
 +}
  
 -const struct aq_hw_caps_s hw_atl_b0_caps_aqc109 = {
 -	DEFAULT_B0_BOARD_BASIC_CAPABILITIES,
 -	.media_type = AQ_HW_MEDIA_TYPE_TP,
 -	.link_speed_msk = HW_ATL_B0_RATE_2G5 |
 -			  HW_ATL_B0_RATE_1G  |
 -			  HW_ATL_B0_RATE_100M,
 -};
 +static struct aq_hw_s *hw_atl_b0_create(struct aq_pci_func_s *aq_pci_func,
 +					unsigned int port)
 +{
 +	struct aq_hw_s *self = NULL;
 +
 +	self = kzalloc(sizeof(*self), GFP_KERNEL);
 +	if (!self)
 +		goto err_exit;
 +
 +	self->aq_pci_func = aq_pci_func;
 +
 +	self->not_ff_addr = 0x10U;
 +
 +err_exit:
 +	return self;
 +}
 +
 +static void hw_atl_b0_destroy(struct aq_hw_s *self)
 +{
 +	kfree(self);
 +}
  
  static int hw_atl_b0_hw_reset(struct aq_hw_s *self)
  {
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_hw.h
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_hw_utils.c b/drivers/net/ethernet/aquantia/atlantic/aq_hw_utils.c
index 27e250d61da7..d526c4f19d34 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_hw_utils.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_hw_utils.c
@@ -13,6 +13,7 @@
 
 #include "aq_hw_utils.h"
 #include "aq_hw.h"
+#include "aq_nic.h"
 
 void aq_hw_write_reg_bit(struct aq_hw_s *aq_hw, u32 addr, u32 msk,
 			 u32 shift, u32 val)
@@ -39,7 +40,9 @@ u32 aq_hw_read_reg(struct aq_hw_s *hw, u32 reg)
 {
 	u32 value = readl(hw->mmio + reg);
 
-	if ((~0U) == value && (~0U) == readl(hw->mmio + hw->not_ff_addr))
+	if ((~0U) == value &&
+	    (~0U) == readl(hw->mmio +
+			   hw->aq_nic_cfg->aq_hw_caps->hw_alive_check_addr))
 		aq_utils_obj_set(&hw->flags, AQ_HW_FLAG_ERR_UNPLUG);
 
 	return value;
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
