EDAC, sb_edac: Check if ECC enabled when at least one DIMM is present

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [edac] sb_edac: Check if ECC enabled when at least one DIMM is present (Aristeu Rozanski) [1483004 1483026]
Rebuild_FUZZ: 95.45%
commit-author Qiuxu Zhuo <qiuxu.zhuo@intel.com>
commit 4d475dde79b561bbd843d7deb7100f9e75596487
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4d475dde.failed

This is based on previous work by Patrick Geary, see Link.

Additional cleanups ontop:

 - Remove the code to read MCMTR from pci_ha1_ta and CHN_TO_HA macro,
 now that TA0 and TA1 are unified.

 - Remove get_pdev_same_bus(), since in get_dimm_config() the
 variable "pvt->pci_ta" for KNL is also ready, we can simply use
 pci_read_config_dword(pvt->pci_ta, KNL_MCMTR, &pvt->info.mcmtr) to read
 MCMTR.

	Signed-off-by: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
	Cc: linux-edac <linux-edac@vger.kernel.org>
Link: https://lkml.kernel.org/r/57884350.1030401@supermicro.com
Link: http://lkml.kernel.org/r/20170523000910.87925-1-qiuxu.zhuo@intel.com
[ Make __populate_dimms() return int. ]
	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit 4d475dde79b561bbd843d7deb7100f9e75596487)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/sb_edac.c
diff --cc drivers/edac/sb_edac.c
index c0c2beb62547,30eb91011ac9..000000000000
--- a/drivers/edac/sb_edac.c
+++ b/drivers/edac/sb_edac.c
@@@ -1608,6 -1547,100 +1535,103 @@@ static void get_source_id(struct mem_ct
  		pvt->sbridge_dev->source_id = SOURCE_ID(reg);
  }
  
++<<<<<<< HEAD
++=======
+ static int __populate_dimms(struct mem_ctl_info *mci,
+ 			    u64 knl_mc_sizes[KNL_MAX_CHANNELS],
+ 			    enum edac_type mode)
+ {
+ 	struct sbridge_pvt *pvt = mci->pvt_info;
+ 	int channels = pvt->info.type == KNIGHTS_LANDING ? KNL_MAX_CHANNELS
+ 							 : NUM_CHANNELS;
+ 	unsigned int i, j, banks, ranks, rows, cols, npages;
+ 	struct dimm_info *dimm;
+ 	enum mem_type mtype;
+ 	u64 size;
+ 
+ 	mtype = pvt->info.get_memory_type(pvt);
+ 	if (mtype == MEM_RDDR3 || mtype == MEM_RDDR4)
+ 		edac_dbg(0, "Memory is registered\n");
+ 	else if (mtype == MEM_UNKNOWN)
+ 		edac_dbg(0, "Cannot determine memory type\n");
+ 	else
+ 		edac_dbg(0, "Memory is unregistered\n");
+ 
+ 	if (mtype == MEM_DDR4 || mtype == MEM_RDDR4)
+ 		banks = 16;
+ 	else
+ 		banks = 8;
+ 
+ 	for (i = 0; i < channels; i++) {
+ 		u32 mtr;
+ 
+ 		int max_dimms_per_channel;
+ 
+ 		if (pvt->info.type == KNIGHTS_LANDING) {
+ 			max_dimms_per_channel = 1;
+ 			if (!pvt->knl.pci_channel[i])
+ 				continue;
+ 		} else {
+ 			max_dimms_per_channel = ARRAY_SIZE(mtr_regs);
+ 			if (!pvt->pci_tad[i])
+ 				continue;
+ 		}
+ 
+ 		for (j = 0; j < max_dimms_per_channel; j++) {
+ 			dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms, mci->n_layers, i, j, 0);
+ 			if (pvt->info.type == KNIGHTS_LANDING) {
+ 				pci_read_config_dword(pvt->knl.pci_channel[i],
+ 					knl_mtr_reg, &mtr);
+ 			} else {
+ 				pci_read_config_dword(pvt->pci_tad[i],
+ 					mtr_regs[j], &mtr);
+ 			}
+ 			edac_dbg(4, "Channel #%d  MTR%d = %x\n", i, j, mtr);
+ 			if (IS_DIMM_PRESENT(mtr)) {
+ 				if (!IS_ECC_ENABLED(pvt->info.mcmtr)) {
+ 					sbridge_printk(KERN_ERR, "CPU SrcID #%d, Ha #%d, Channel #%d has DIMMs, but ECC is disabled\n",
+ 						       pvt->sbridge_dev->source_id,
+ 						       pvt->sbridge_dev->dom, i);
+ 					return -ENODEV;
+ 				}
+ 				pvt->channel[i].dimms++;
+ 
+ 				ranks = numrank(pvt->info.type, mtr);
+ 
+ 				if (pvt->info.type == KNIGHTS_LANDING) {
+ 					/* For DDR4, this is fixed. */
+ 					cols = 1 << 10;
+ 					rows = knl_mc_sizes[i] /
+ 						((u64) cols * ranks * banks * 8);
+ 				} else {
+ 					rows = numrow(mtr);
+ 					cols = numcol(mtr);
+ 				}
+ 
+ 				size = ((u64)rows * cols * banks * ranks) >> (20 - 3);
+ 				npages = MiB_TO_PAGES(size);
+ 
+ 				edac_dbg(0, "mc#%d: ha %d channel %d, dimm %d, %lld Mb (%d pages) bank: %d, rank: %d, row: %#x, col: %#x\n",
+ 					 pvt->sbridge_dev->mc, pvt->sbridge_dev->dom, i, j,
+ 					 size, npages,
+ 					 banks, ranks, rows, cols);
+ 
+ 				dimm->nr_pages = npages;
+ 				dimm->grain = 32;
+ 				dimm->dtype = pvt->info.get_width(pvt, mtr);
+ 				dimm->mtype = mtype;
+ 				dimm->edac_mode = mode;
+ 				snprintf(dimm->label, sizeof(dimm->label),
+ 						 "CPU_SrcID#%u_Ha#%u_Chan#%u_DIMM#%u",
+ 						 pvt->sbridge_dev->source_id, pvt->sbridge_dev->dom, i, j);
+ 			}
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 4d475dde79b5 (EDAC, sb_edac: Check if ECC enabled when at least one DIMM is present)
  static int get_dimm_config(struct mem_ctl_info *mci)
  {
  	struct sbridge_pvt *pvt = mci->pvt_info;
@@@ -1669,81 -1697,7 +1694,85 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	mtype = pvt->info.get_memory_type(pvt);
 +	if (mtype == MEM_RDDR3 || mtype == MEM_RDDR4)
 +		edac_dbg(0, "Memory is registered\n");
 +	else if (mtype == MEM_UNKNOWN)
 +		edac_dbg(0, "Cannot determine memory type\n");
 +	else
 +		edac_dbg(0, "Memory is unregistered\n");
 +
 +	if (mtype == MEM_DDR4 || mtype == MEM_RDDR4)
 +		banks = 16;
 +	else
 +		banks = 8;
 +
 +	for (i = 0; i < channels; i++) {
 +		u32 mtr;
 +
 +		int max_dimms_per_channel;
 +
 +		if (pvt->info.type == KNIGHTS_LANDING) {
 +			max_dimms_per_channel = 1;
 +			if (!pvt->knl.pci_channel[i])
 +				continue;
 +		} else {
 +			max_dimms_per_channel = ARRAY_SIZE(mtr_regs);
 +			if (!pvt->pci_tad[i])
 +				continue;
 +		}
 +
 +		for (j = 0; j < max_dimms_per_channel; j++) {
 +			dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms, mci->n_layers,
 +				       i, j, 0);
 +			if (pvt->info.type == KNIGHTS_LANDING) {
 +				pci_read_config_dword(pvt->knl.pci_channel[i],
 +					knl_mtr_reg, &mtr);
 +			} else {
 +				pci_read_config_dword(pvt->pci_tad[i],
 +					mtr_regs[j], &mtr);
 +			}
 +			edac_dbg(4, "Channel #%d  MTR%d = %x\n", i, j, mtr);
 +			if (IS_DIMM_PRESENT(mtr)) {
 +				pvt->channel[i].dimms++;
 +
 +				ranks = numrank(pvt->info.type, mtr);
 +
 +				if (pvt->info.type == KNIGHTS_LANDING) {
 +					/* For DDR4, this is fixed. */
 +					cols = 1 << 10;
 +					rows = knl_mc_sizes[i] /
 +						((u64) cols * ranks * banks * 8);
 +				} else {
 +					rows = numrow(mtr);
 +					cols = numcol(mtr);
 +				}
 +
 +				size = ((u64)rows * cols * banks * ranks) >> (20 - 3);
 +				npages = MiB_TO_PAGES(size);
 +
 +				edac_dbg(0, "mc#%d: ha %d channel %d, dimm %d, %lld Mb (%d pages) bank: %d, rank: %d, row: %#x, col: %#x\n",
 +					 pvt->sbridge_dev->mc, i/4, i%4, j,
 +					 size, npages,
 +					 banks, ranks, rows, cols);
 +
 +				dimm->nr_pages = npages;
 +				dimm->grain = 32;
 +				dimm->dtype = pvt->info.get_width(pvt, mtr);
 +				dimm->mtype = mtype;
 +				dimm->edac_mode = mode;
 +				snprintf(dimm->label, sizeof(dimm->label),
 +					 "CPU_SrcID#%u_Ha#%u_Chan#%u_DIMM#%u",
 +					 pvt->sbridge_dev->source_id, i/4, i%4, j);
 +			}
 +		}
 +	}
 +
 +	return 0;
++=======
+ 	return __populate_dimms(mci, knl_mc_sizes, mode);
++>>>>>>> 4d475dde79b5 (EDAC, sb_edac: Check if ECC enabled when at least one DIMM is present)
  }
  
  static void get_memory_layout(const struct mem_ctl_info *mci)
* Unmerged path drivers/edac/sb_edac.c
