sock_diag: request _diag module only when the family or proto has been registered

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit bf2ae2e4bf9360e07c0cdfa166bcdc0afd92f4ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/bf2ae2e4.failed

Now when using 'ss' in iproute, kernel would try to load all _diag
modules, which also causes corresponding family and proto modules
to be loaded as well due to module dependencies.

Like after running 'ss', sctp, dccp, af_packet (if it works as a module)
would be loaded.

For example:

  $ lsmod|grep sctp
  $ ss
  $ lsmod|grep sctp
  sctp_diag              16384  0
  sctp                  323584  5 sctp_diag
  inet_diag              24576  4 raw_diag,tcp_diag,sctp_diag,udp_diag
  libcrc32c              16384  3 nf_conntrack,nf_nat,sctp

As these family and proto modules are loaded unintentionally, it
could cause some problems, like:

- Some debug tools use 'ss' to collect the socket info, which loads all
  those diag and family and protocol modules. It's noisy for identifying
  issues.

- Users usually expect to drop sctp init packet silently when they
  have no sense of sctp protocol instead of sending abort back.

- It wastes resources (especially with multiple netns), and SCTP module
  can't be unloaded once it's loaded.

...

In short, it's really inappropriate to have these family and proto
modules loaded unexpectedly when just doing debugging with inet_diag.

This patch is to introduce sock_load_diag_module() where it loads
the _diag module only when it's corresponding family or proto has
been already registered.

Note that we can't just load _diag module without the family or
proto loaded, as some symbols used in _diag module are from the
family or proto module.

v1->v2:
  - move inet proto check to inet_diag to avoid a compiling err.
v2->v3:
  - define sock_load_diag_module in sock.c and export one symbol
    only.
  - improve the changelog.

	Reported-by: Sabrina Dubroca <sd@queasysnail.net>
	Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Acked-by: Phil Sutter <phil@nwl.cc>
	Acked-by: Sabrina Dubroca <sd@queasysnail.net>
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bf2ae2e4bf9360e07c0cdfa166bcdc0afd92f4ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/sock.h
#	net/core/sock_diag.c
diff --cc include/net/sock.h
index 91144cd664b8,ae23f3b389ca..000000000000
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@@ -1083,63 -1132,12 +1083,69 @@@ struct proto 
  #ifdef SOCK_REFCNT_DEBUG
  	atomic_t		socks;
  #endif
 -	int			(*diag_destroy)(struct sock *sk, int err);
 -} __randomize_layout;
 +#ifdef CONFIG_MEMCG_KMEM
 +	/*
 +	 * cgroup specific init/deinit functions. Called once for all
 +	 * protocols that implement it, from cgroups populate function.
 +	 * This function has to setup any files the protocol want to
 +	 * appear in the kmem cgroup filesystem.
 +	 */
 +	int			(*init_cgroup)(struct mem_cgroup *memcg,
 +					       struct cgroup_subsys *ss);
 +	void			(*destroy_cgroup)(struct mem_cgroup *memcg);
 +	struct cg_proto		*(*proto_cgroup)(struct mem_cgroup *memcg);
 +#endif
 +};
  
++<<<<<<< HEAD
 +/*
 + * Bits in struct cg_proto.flags
 + */
 +enum cg_proto_flags {
 +	/* Currently active and new sockets should be assigned to cgroups */
 +	MEMCG_SOCK_ACTIVE,
 +	/* It was ever activated; we must disarm static keys on destruction */
 +	MEMCG_SOCK_ACTIVATED,
 +};
 +
 +struct cg_proto {
 +	void			(*enter_memory_pressure)(struct sock *sk);
 +	/* Current allocated memory. */
 +	RH_KABI_REPLACE(struct res_counter	*memory_allocated,
 +			struct page_counter	*memory_allocated)
 +	struct percpu_counter	*sockets_allocated;	/* Current number of sockets. */
 +	int			*memory_pressure;
 +	long			*sysctl_mem;
 +	unsigned long		flags;
 +	/*
 +	 * memcg field is used to find which memcg we belong directly
 +	 * Each memcg struct can hold more than one cg_proto, so container_of
 +	 * won't really cut.
 +	 *
 +	 * The elegant solution would be having an inverse function to
 +	 * proto_cgroup in struct proto, but that means polluting the structure
 +	 * for everybody, instead of just for memcg users.
 +	 */
 +	struct mem_cgroup	*memcg;
 +};
 +
 +extern int proto_register(struct proto *prot, int alloc_slab);
 +extern void proto_unregister(struct proto *prot);
 +
 +static inline bool memcg_proto_active(struct cg_proto *cg_proto)
 +{
 +	return test_bit(MEMCG_SOCK_ACTIVE, &cg_proto->flags);
 +}
 +
 +static inline bool memcg_proto_activated(struct cg_proto *cg_proto)
 +{
 +	return test_bit(MEMCG_SOCK_ACTIVATED, &cg_proto->flags);
 +}
++=======
+ int proto_register(struct proto *prot, int alloc_slab);
+ void proto_unregister(struct proto *prot);
+ int sock_load_diag_module(int family, int protocol);
++>>>>>>> bf2ae2e4bf93 (sock_diag: request _diag module only when the family or proto has been registered)
  
  #ifdef SOCK_REFCNT_DEBUG
  static inline void sk_refcnt_debug_inc(struct sock *sk)
diff --cc net/core/sock_diag.c
index 39b9bcdc1390,c37b5be7c5e4..000000000000
--- a/net/core/sock_diag.c
+++ b/net/core/sock_diag.c
@@@ -198,6 -273,35 +196,38 @@@ static void sock_diag_rcv(struct sk_buf
  	mutex_unlock(&sock_diag_mutex);
  }
  
++<<<<<<< HEAD
++=======
+ static int sock_diag_bind(struct net *net, int group)
+ {
+ 	switch (group) {
+ 	case SKNLGRP_INET_TCP_DESTROY:
+ 	case SKNLGRP_INET_UDP_DESTROY:
+ 		if (!sock_diag_handlers[AF_INET])
+ 			sock_load_diag_module(AF_INET, 0);
+ 		break;
+ 	case SKNLGRP_INET6_TCP_DESTROY:
+ 	case SKNLGRP_INET6_UDP_DESTROY:
+ 		if (!sock_diag_handlers[AF_INET6])
+ 			sock_load_diag_module(AF_INET6, 0);
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ int sock_diag_destroy(struct sock *sk, int err)
+ {
+ 	if (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))
+ 		return -EPERM;
+ 
+ 	if (!sk->sk_prot->diag_destroy)
+ 		return -EOPNOTSUPP;
+ 
+ 	return sk->sk_prot->diag_destroy(sk, err);
+ }
+ EXPORT_SYMBOL_GPL(sock_diag_destroy);
+ 
++>>>>>>> bf2ae2e4bf93 (sock_diag: request _diag module only when the family or proto has been registered)
  static int __net_init diag_net_init(struct net *net)
  {
  	struct netlink_kernel_cfg cfg = {
diff --git a/include/linux/net.h b/include/linux/net.h
index 76c9e575580f..e81fe7d472ad 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -211,6 +211,7 @@ enum {
 int sock_wake_async(struct socket *sk, int how, int band);
 int sock_register(const struct net_proto_family *fam);
 void sock_unregister(int family);
+bool sock_is_registered(int family);
 int __sock_create(struct net *net, int family, int type, int proto,
 		  struct socket **res, int kern);
 int sock_create(int family, int type, int proto, struct socket **res);
* Unmerged path include/net/sock.h
diff --git a/net/core/sock.c b/net/core/sock.c
index f3c6d177e08c..b064521e26d2 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -2829,6 +2829,27 @@ void proto_unregister(struct proto *prot)
 }
 EXPORT_SYMBOL(proto_unregister);
 
+int sock_load_diag_module(int family, int protocol)
+{
+	if (!protocol) {
+		if (!sock_is_registered(family))
+			return -ENOENT;
+
+		return request_module("net-pf-%d-proto-%d-type-%d", PF_NETLINK,
+				      NETLINK_SOCK_DIAG, family);
+	}
+
+#ifdef CONFIG_INET
+	if (family == AF_INET &&
+	    !rcu_access_pointer(inet_protos[protocol]))
+		return -ENOENT;
+#endif
+
+	return request_module("net-pf-%d-proto-%d-type-%d-%d", PF_NETLINK,
+			      NETLINK_SOCK_DIAG, family, protocol);
+}
+EXPORT_SYMBOL(sock_load_diag_module);
+
 #ifdef CONFIG_PROC_FS
 static void *proto_seq_start(struct seq_file *seq, loff_t *pos)
 	__acquires(proto_list_mutex)
* Unmerged path net/core/sock_diag.c
diff --git a/net/ipv4/inet_diag.c b/net/ipv4/inet_diag.c
index 663d5f200ff0..8810261b16e6 100644
--- a/net/ipv4/inet_diag.c
+++ b/net/ipv4/inet_diag.c
@@ -51,8 +51,7 @@ static DEFINE_MUTEX(inet_diag_table_mutex);
 static const struct inet_diag_handler *inet_diag_lock_handler(int proto)
 {
 	if (!inet_diag_table[proto])
-		request_module("net-pf-%d-proto-%d-type-%d-%d", PF_NETLINK,
-			       NETLINK_SOCK_DIAG, AF_INET, proto);
+		sock_load_diag_module(AF_INET, proto);
 
 	mutex_lock(&inet_diag_table_mutex);
 	if (!inet_diag_table[proto])
diff --git a/net/socket.c b/net/socket.c
index b4122d2a2a25..99af33f73ea8 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -2670,6 +2670,11 @@ void sock_unregister(int family)
 }
 EXPORT_SYMBOL(sock_unregister);
 
+bool sock_is_registered(int family)
+{
+	return family < NPROTO && rcu_access_pointer(net_families[family]);
+}
+
 static int __init sock_init(void)
 {
 	int err;
