tick/sched: Do not mess with an enqueued hrtimer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 1f71addd34f4c442bec7d7c749acc1beb58126f2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1f71addd.failed

Kaike reported that in tests rdma hrtimers occasionaly stopped working. He
did great debugging, which provided enough context to decode the problem.

CPU 3			     	      	     CPU 2

idle
start sched_timer expires = 712171000000
 queue->next = sched_timer
					    start rdmavt timer. expires = 712172915662
					    lock(baseof(CPU3))
tick_nohz_stop_tick()
tick = 716767000000			    timerqueue_add(tmr)

hrtimer_set_expires(sched_timer, tick);
  sched_timer->expires = 716767000000  <---- FAIL
					     if (tmr->expires < queue->next->expires)
hrtimer_start(sched_timer)		          queue->next = tmr;
lock(baseof(CPU3))
					     unlock(baseof(CPU3))
timerqueue_remove()
timerqueue_add()

ts->sched_timer is queued and queue->next is pointing to it, but then
ts->sched_timer.expires is modified.

This not only corrupts the ordering of the timerqueue RB tree, it also
makes CPU2 see the new expiry time of timerqueue->next->expires when
checking whether timerqueue->next needs to be updated. So CPU2 sees that
the rdma timer is earlier than timerqueue->next and sets the rdma timer as
new next.

Depending on whether it had also seen the new time at RB tree enqueue, it
might have queued the rdma timer at the wrong place and then after removing
the sched_timer the RB tree is completely hosed.

The problem was introduced with a commit which tried to solve inconsistency
between the hrtimer in the tick_sched data and the underlying hardware
clockevent. It split out hrtimer_set_expires() to store the new tick time
in both the NOHZ and the NOHZ + HIGHRES case, but missed the fact that in
the NOHZ + HIGHRES case the hrtimer might still be queued.

Use hrtimer_start(timer, tick...) for the NOHZ + HIGHRES case which sets
timer->expires after canceling the timer and move the hrtimer_set_expires()
invocation into the NOHZ only code path which is not affected as it merily
uses the hrtimer as next event storage so code pathes can be shared with
the NOHZ + HIGHRES case.

Fixes: d4af6d933ccf ("nohz: Fix spurious warning when hrtimer and clockevent get out of sync")
	Reported-by: "Wan Kaike" <kaike.wan@intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: Frederic Weisbecker <frederic@kernel.org>
	Cc: "Marciniszyn Mike" <mike.marciniszyn@intel.com>
	Cc: Anna-Maria Gleixner <anna-maria@linutronix.de>
	Cc: linux-rdma@vger.kernel.org
	Cc: "Dalessandro Dennis" <dennis.dalessandro@intel.com>
	Cc: "Fleck John" <john.fleck@intel.com>
	Cc: stable@vger.kernel.org
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: "Weiny Ira" <ira.weiny@intel.com>
	Cc: "linux-rdma@vger.kernel.org"
Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1804241637390.1679@nanos.tec.linutronix.de
Link: https://lkml.kernel.org/r/alpine.DEB.2.21.1804242119210.1597@nanos.tec.linutronix.de


(cherry picked from commit 1f71addd34f4c442bec7d7c749acc1beb58126f2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/tick-sched.c
diff --cc kernel/time/tick-sched.c
index 85c7fe06eace,d31bec177fa5..000000000000
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@@ -692,25 -801,56 +692,51 @@@ static ktime_t tick_nohz_stop_sched_tic
  	if (unlikely(expires == KTIME_MAX)) {
  		if (ts->nohz_mode == NOHZ_MODE_HIGHRES)
  			hrtimer_cancel(&ts->sched_timer);
 -		return;
 +		goto out;
  	}
  
- 	hrtimer_set_expires(&ts->sched_timer, tick);
- 
- 	if (ts->nohz_mode == NOHZ_MODE_HIGHRES)
- 		hrtimer_start_expires(&ts->sched_timer, HRTIMER_MODE_ABS_PINNED);
- 	else
+ 	if (ts->nohz_mode == NOHZ_MODE_HIGHRES) {
+ 		hrtimer_start(&ts->sched_timer, tick, HRTIMER_MODE_ABS_PINNED);
+ 	} else {
+ 		hrtimer_set_expires(&ts->sched_timer, tick);
  		tick_program_event(tick, 1);
++<<<<<<< HEAD
 +out:
++=======
+ 	}
+ }
+ 
+ static void tick_nohz_retain_tick(struct tick_sched *ts)
+ {
+ 	ts->timer_expires_base = 0;
+ }
+ 
+ #ifdef CONFIG_NO_HZ_FULL
+ static void tick_nohz_stop_sched_tick(struct tick_sched *ts, int cpu)
+ {
+ 	if (tick_nohz_next_event(ts, cpu))
+ 		tick_nohz_stop_tick(ts, cpu);
+ 	else
+ 		tick_nohz_retain_tick(ts);
+ }
+ #endif /* CONFIG_NO_HZ_FULL */
+ 
+ static void tick_nohz_restart_sched_tick(struct tick_sched *ts, ktime_t now)
+ {
+ 	/* Update jiffies first */
+ 	tick_do_update_jiffies64(now);
+ 	cpu_load_update_nohz_stop();
+ 
++>>>>>>> 1f71addd34f4 (tick/sched: Do not mess with an enqueued hrtimer)
  	/*
 -	 * Clear the timer idle flag, so we avoid IPIs on remote queueing and
 -	 * the clock forward checks in the enqueue path:
 +	 * Update the estimated sleep length until the next timer
 +	 * (not only the tick).
  	 */
 -	timer_clear_idle();
 -
 -	calc_load_nohz_stop();
 -	touch_softlockup_watchdog_sched();
 -	/*
 -	 * Cancel the scheduled timer and restore the tick
 -	 */
 -	ts->tick_stopped  = 0;
 -	ts->idle_exittime = now;
 -
 -	tick_nohz_restart(ts, now);
 +	ts->sleep_length = ktime_sub(dev->next_event, now);
 +	return tick;
  }
  
 -static void tick_nohz_full_update_tick(struct tick_sched *ts)
 +static void tick_nohz_full_stop_tick(struct tick_sched *ts)
  {
  #ifdef CONFIG_NO_HZ_FULL
  	int cpu = smp_processor_id();
* Unmerged path kernel/time/tick-sched.c
