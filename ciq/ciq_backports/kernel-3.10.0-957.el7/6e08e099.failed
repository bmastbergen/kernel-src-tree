drm/amdgpu: Avoid reclaim while holding locks taken in MMU notifier

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Felix Kuehling <Felix.Kuehling@amd.com>
commit 6e08e0995b8f339fd2a7ee4fa11f17396405ef60
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6e08e099.failed

When an MMU notifier runs in memory reclaim context, it can deadlock
trying to take locks that are already held in the thread causing the
memory reclaim. The solution is to avoid memory reclaim while holding
locks that are taken in MMU notifiers.

This commit fixes kmalloc while holding rmn->lock by moving the call
outside the lock. The GFX MMU notifier also locks reservation objects.
I have no good solution for avoiding reclaim while holding reservation
objects. The HSA MMU notifier will not lock any reservation objects.

v2: Moved allocation outside lock instead of using GFP_NOIO

	Signed-off-by: Felix Kuehling <Felix.Kuehling@amd.com>
	Acked-by: Oded Gabbay <oded.gabbay@gmail.com>
	Reviewed-by: Christian KÃ¶nig <christian.koenig@amd.com>
	Signed-off-by: Oded Gabbay <oded.gabbay@gmail.com>
(cherry picked from commit 6e08e0995b8f339fd2a7ee4fa11f17396405ef60)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/amdgpu/amdgpu_mn.c
diff --cc drivers/gpu/drm/amd/amdgpu/amdgpu_mn.c
index e1cde6b80027,83e344fbb50a..000000000000
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_mn.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_mn.c
@@@ -256,8 -377,10 +256,8 @@@ int amdgpu_mn_register(struct amdgpu_b
  {
  	unsigned long end = addr + amdgpu_bo_size(bo) - 1;
  	struct amdgpu_device *adev = amdgpu_ttm_adev(bo->tbo.bdev);
 -	enum amdgpu_mn_type type =
 -		bo->kfd_bo ? AMDGPU_MN_TYPE_HSA : AMDGPU_MN_TYPE_GFX;
  	struct amdgpu_mn *rmn;
- 	struct amdgpu_mn_node *node = NULL;
+ 	struct amdgpu_mn_node *node = NULL, *new_node;
  	struct list_head bos;
  	struct interval_tree_node *it;
  
@@@ -265,9 -388,13 +265,13 @@@
  	if (IS_ERR(rmn))
  		return PTR_ERR(rmn);
  
+ 	new_node = kmalloc(sizeof(*new_node), GFP_KERNEL);
+ 	if (!new_node)
+ 		return -ENOMEM;
+ 
  	INIT_LIST_HEAD(&bos);
  
 -	down_write(&rmn->lock);
 +	mutex_lock(&rmn->lock);
  
  	while ((it = interval_tree_iter_first(&rmn->objects, addr, end))) {
  		kfree(node);
@@@ -278,13 -405,10 +282,20 @@@
  		list_splice(&node->bos, &bos);
  	}
  
++<<<<<<< HEAD
 +	if (!node) {
 +		node = kmalloc(sizeof(struct amdgpu_mn_node), GFP_KERNEL);
 +		if (!node) {
 +			mutex_unlock(&rmn->lock);
 +			return -ENOMEM;
 +		}
 +	}
++=======
+ 	if (!node)
+ 		node = new_node;
+ 	else
+ 		kfree(new_node);
++>>>>>>> 6e08e0995b8f (drm/amdgpu: Avoid reclaim while holding locks taken in MMU notifier)
  
  	bo->mn = rmn;
  
* Unmerged path drivers/gpu/drm/amd/amdgpu/amdgpu_mn.c
