ceph: change variable name to follow common rule

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Chengguang Xu <cgxu519@icloud.com>
commit 73737682e0598ae73bd4c481e478a0d75884aa8a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/73737682.failed

Variable name ci is mostly used for ceph_inode_info.
Variable name fi is mostly used for ceph_file_info.
Variable name cf is mostly used for ceph_cap_flush.

Change variable name to follow above common rules
in case of confusing.

	Signed-off-by: Chengguang Xu <cgxu519@icloud.com>
	Reviewed-by: "Yan, Zheng" <zyan@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 73737682e0598ae73bd4c481e478a0d75884aa8a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/addr.c
#	fs/ceph/file.c
diff --cc fs/ceph/addr.c
index adf7d1009bc0,4b3cf53d5641..000000000000
--- a/fs/ceph/addr.c
+++ b/fs/ceph/addr.c
@@@ -417,17 -439,26 +417,32 @@@ static int ceph_readpages(struct file *
  {
  	struct inode *inode = file_inode(file);
  	struct ceph_fs_client *fsc = ceph_inode_to_client(inode);
++<<<<<<< HEAD
++=======
+ 	struct ceph_file_info *fi = file->private_data;
+ 	struct ceph_rw_context *rw_ctx;
++>>>>>>> 73737682e059 (ceph: change variable name to follow common rule)
  	int rc = 0;
  	int max = 0;
  
  	if (ceph_inode(inode)->i_inline_version != CEPH_INLINE_NONE)
  		return -EINVAL;
  
++<<<<<<< HEAD
++=======
+ 	rc = ceph_readpages_from_fscache(mapping->host, mapping, page_list,
+ 					 &nr_pages);
+ 
+ 	if (rc == 0)
+ 		goto out;
+ 
+ 	rw_ctx = ceph_find_rw_context(fi);
++>>>>>>> 73737682e059 (ceph: change variable name to follow common rule)
  	max = fsc->mount_options->rsize >> PAGE_SHIFT;
 -	dout("readpages %p file %p ctx %p nr_pages %d max %d\n",
 -	     inode, file, rw_ctx, nr_pages, max);
 +	dout("readpages %p file %p nr_pages %d max %d\n",
 +	     inode, file, nr_pages, max);
  	while (!list_empty(page_list)) {
 -		rc = start_read(inode, rw_ctx, page_list, max);
 +		rc = start_read(inode, page_list, max);
  		if (rc < 0)
  			goto out;
  	}
diff --cc fs/ceph/file.c
index 4be6ff2c3e9e,df9f435c5260..000000000000
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@@ -183,10 -180,14 +183,21 @@@ static int ceph_init_file(struct inode 
  			ceph_put_fmode(ceph_inode(inode), fmode); /* clean up */
  			return -ENOMEM;
  		}
++<<<<<<< HEAD
 +		cf->fmode = fmode;
 +		cf->next_offset = 2;
 +		cf->readdir_cache_idx = -1;
 +		file->private_data = cf;
++=======
+ 		fi->fmode = fmode;
+ 
+ 		spin_lock_init(&fi->rw_contexts_lock);
+ 		INIT_LIST_HEAD(&fi->rw_contexts);
+ 
+ 		fi->next_offset = 2;
+ 		fi->readdir_cache_idx = -1;
+ 		file->private_data = fi;
++>>>>>>> 73737682e059 (ceph: change variable name to follow common rule)
  		BUG_ON(inode->i_fop->release != ceph_release);
  		break;
  
@@@ -461,15 -460,16 +472,25 @@@ out_acl
  int ceph_release(struct inode *inode, struct file *file)
  {
  	struct ceph_inode_info *ci = ceph_inode(inode);
- 	struct ceph_file_info *cf = file->private_data;
+ 	struct ceph_file_info *fi = file->private_data;
  
  	dout("release inode %p file %p\n", inode, file);
++<<<<<<< HEAD
 +	ceph_put_fmode(ci, cf->fmode);
 +	if (cf->last_readdir)
 +		ceph_mdsc_put_request(cf->last_readdir);
 +	kfree(cf->last_name);
 +	kfree(cf->dir_info);
 +	kmem_cache_free(ceph_file_cachep, cf);
++=======
+ 	ceph_put_fmode(ci, fi->fmode);
+ 	if (fi->last_readdir)
+ 		ceph_mdsc_put_request(fi->last_readdir);
+ 	kfree(fi->last_name);
+ 	kfree(fi->dir_info);
+ 	WARN_ON(!list_empty(&fi->rw_contexts));
+ 	kmem_cache_free(ceph_file_cachep, fi);
++>>>>>>> 73737682e059 (ceph: change variable name to follow common rule)
  
  	/* wake up anyone waiting for caps on this inode */
  	wake_up_all(&ci->i_cap_wq);
* Unmerged path fs/ceph/addr.c
diff --git a/fs/ceph/dir.c b/fs/ceph/dir.c
index 83040cdc8671..a09bc2b4edcd 100644
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@ -1381,7 +1381,7 @@ static void ceph_d_prune(struct dentry *dentry)
 static ssize_t ceph_read_dir(struct file *file, char __user *buf, size_t size,
 			     loff_t *ppos)
 {
-	struct ceph_file_info *cf = file->private_data;
+	struct ceph_file_info *fi = file->private_data;
 	struct inode *inode = file_inode(file);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	int left;
@@ -1390,12 +1390,12 @@ static ssize_t ceph_read_dir(struct file *file, char __user *buf, size_t size,
 	if (!ceph_test_mount_opt(ceph_sb_to_client(inode->i_sb), DIRSTAT))
 		return -EISDIR;
 
-	if (!cf->dir_info) {
-		cf->dir_info = kmalloc(bufsize, GFP_KERNEL);
-		if (!cf->dir_info)
+	if (!fi->dir_info) {
+		fi->dir_info = kmalloc(bufsize, GFP_KERNEL);
+		if (!fi->dir_info)
 			return -ENOMEM;
-		cf->dir_info_len =
-			snprintf(cf->dir_info, bufsize,
+		fi->dir_info_len =
+			snprintf(fi->dir_info, bufsize,
 				"entries:   %20lld\n"
 				" files:    %20lld\n"
 				" subdirs:  %20lld\n"
@@ -1415,10 +1415,10 @@ static ssize_t ceph_read_dir(struct file *file, char __user *buf, size_t size,
 				(long)ci->i_rctime.tv_nsec);
 	}
 
-	if (*ppos >= cf->dir_info_len)
+	if (*ppos >= fi->dir_info_len)
 		return 0;
-	size = min_t(unsigned, size, cf->dir_info_len-*ppos);
-	left = copy_to_user(buf, cf->dir_info + *ppos, size);
+	size = min_t(unsigned, size, fi->dir_info_len-*ppos);
+	left = copy_to_user(buf, fi->dir_info + *ppos, size);
 	if (left == size)
 		return -EFAULT;
 	*ppos += (size - left);
* Unmerged path fs/ceph/file.c
