HID: sensor-hub: make dyn_callback_lock IRQ-safe

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [hid] sensor-hub: make dyn_callback_lock IRQ-safe (Tony Camuso) [1559170]
Rebuild_FUZZ: 94.51%
commit-author Jiri Kosina <jkosina@suse.cz>
commit 0ccf091d1fbc1f99bb7f93bff8cf346769a9b0cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0ccf091d.failed

dyn_callback_lock is being taken from IRQ context through hid_irq_in() ->
hid_input_report() -> sensor_hub_raw_event() -> sensor_hub_get_callback(),
therefore anyone else acquiring it needs to disable IRQs to disable deadlocks.

	Reported-by: Alexander Holler <holler@ahsoftware.de>
	Tested-by: Alexander Holler <holler@ahsoftware.de>
	Reported-by: Reyad Attiyat <reyad.attiyat@gmail.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 0ccf091d1fbc1f99bb7f93bff8cf346769a9b0cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/hid-sensor-hub.c
diff --cc drivers/hid/hid-sensor-hub.c
index 3e67ed86c707,13ce4e3aebf4..000000000000
--- a/drivers/hid/hid-sensor-hub.c
+++ b/drivers/hid/hid-sensor-hub.c
@@@ -150,18 -159,21 +150,25 @@@ int sensor_hub_register_callback(struc
  {
  	struct hid_sensor_hub_callbacks_list *callback;
  	struct sensor_hub_data *pdata = hid_get_drvdata(hsdev->hdev);
+ 	unsigned long flags;
  
- 	spin_lock(&pdata->dyn_callback_lock);
+ 	spin_lock_irqsave(&pdata->dyn_callback_lock, flags);
  	list_for_each_entry(callback, &pdata->dyn_callback_list, list)
++<<<<<<< HEAD
 +		if (callback->usage_id == usage_id) {
 +			spin_unlock(&pdata->dyn_callback_lock);
++=======
+ 		if (callback->usage_id == usage_id &&
+ 						callback->hsdev == hsdev) {
+ 			spin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);
++>>>>>>> 0ccf091d1fbc (HID: sensor-hub: make dyn_callback_lock IRQ-safe)
  			return -EINVAL;
  		}
  	callback = kzalloc(sizeof(*callback), GFP_ATOMIC);
  	if (!callback) {
- 		spin_unlock(&pdata->dyn_callback_lock);
+ 		spin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);
  		return -ENOMEM;
  	}
 -	callback->hsdev = hsdev;
  	callback->usage_callback = usage_callback;
  	callback->usage_id = usage_id;
  	callback->priv = NULL;
@@@ -177,10 -189,12 +184,11 @@@ int sensor_hub_remove_callback(struct h
  {
  	struct hid_sensor_hub_callbacks_list *callback;
  	struct sensor_hub_data *pdata = hid_get_drvdata(hsdev->hdev);
+ 	unsigned long flags;
  
- 	spin_lock(&pdata->dyn_callback_lock);
+ 	spin_lock_irqsave(&pdata->dyn_callback_lock, flags);
  	list_for_each_entry(callback, &pdata->dyn_callback_list, list)
 -		if (callback->usage_id == usage_id &&
 -						callback->hsdev == hsdev) {
 +		if (callback->usage_id == usage_id) {
  			list_del(&callback->list);
  			kfree(callback);
  			break;
@@@ -385,34 -378,36 +393,36 @@@ EXPORT_SYMBOL_GPL(sensor_hub_input_get_
  #ifdef CONFIG_PM
  static int sensor_hub_suspend(struct hid_device *hdev, pm_message_t message)
  {
 -	struct sensor_hub_data *pdata = hid_get_drvdata(hdev);
 +	struct sensor_hub_data *pdata =  hid_get_drvdata(hdev);
  	struct hid_sensor_hub_callbacks_list *callback;
+ 	unsigned long flags;
  
  	hid_dbg(hdev, " sensor_hub_suspend\n");
- 	spin_lock(&pdata->dyn_callback_lock);
+ 	spin_lock_irqsave(&pdata->dyn_callback_lock, flags);
  	list_for_each_entry(callback, &pdata->dyn_callback_list, list) {
  		if (callback->usage_callback->suspend)
  			callback->usage_callback->suspend(
 -					callback->hsdev, callback->priv);
 +					pdata->hsdev, callback->priv);
  	}
- 	spin_unlock(&pdata->dyn_callback_lock);
+ 	spin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);
  
  	return 0;
  }
  
  static int sensor_hub_resume(struct hid_device *hdev)
  {
 -	struct sensor_hub_data *pdata = hid_get_drvdata(hdev);
 +	struct sensor_hub_data *pdata =  hid_get_drvdata(hdev);
  	struct hid_sensor_hub_callbacks_list *callback;
+ 	unsigned long flags;
  
  	hid_dbg(hdev, " sensor_hub_resume\n");
- 	spin_lock(&pdata->dyn_callback_lock);
+ 	spin_lock_irqsave(&pdata->dyn_callback_lock, flags);
  	list_for_each_entry(callback, &pdata->dyn_callback_list, list) {
  		if (callback->usage_callback->resume)
  			callback->usage_callback->resume(
 -					callback->hsdev, callback->priv);
 +					pdata->hsdev, callback->priv);
  	}
- 	spin_unlock(&pdata->dyn_callback_lock);
+ 	spin_unlock_irqrestore(&pdata->dyn_callback_lock, flags);
  
  	return 0;
  }
* Unmerged path drivers/hid/hid-sensor-hub.c
