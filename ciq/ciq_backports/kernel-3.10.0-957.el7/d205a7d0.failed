xfs: refactor dir2 leaf readahead shadow buffer cleverness

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit d205a7d0ec47d11977882b5e910ad35f7be912b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d205a7d0.failed

Currently, the dir2 leaf block getdents function uses a complex state
tracking mechanism to create a shadow copy of the block mappings and
then uses the shadow copy to schedule readahead.  Since the read and
readahead functions are perfectly capable of reading the mappings
themselves, we can tear all that out in favor of a simpler function that
simply keeps pushing the readahead window further out.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit d205a7d0ec47d11977882b5e910ad35f7be912b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_dir2_readdir.c
diff --cc fs/xfs/xfs_dir2_readdir.c
index dcd58b2d6d72,1bc7401ea1b2..000000000000
--- a/fs/xfs/xfs_dir2_readdir.c
+++ b/fs/xfs/xfs_dir2_readdir.c
@@@ -498,33 -377,15 +387,15 @@@ xfs_dir2_leaf_getdents
  	 * If the offset is at or past the largest allowed value,
  	 * give up right away.
  	 */
 -	if (ctx->pos >= XFS_DIR2_MAX_DATAPTR)
 +	if (*offset >= XFS_DIR2_MAX_DATAPTR)
  		return 0;
  
- 	/*
- 	 * Set up to bmap a number of blocks based on the caller's
- 	 * buffer size, the directory block size, and the filesystem
- 	 * block size.
- 	 */
- 	length = howmany(bufsize + geo->blksize, (1 << geo->fsblog));
- 	map_info = kmem_zalloc(offsetof(struct xfs_dir2_leaf_map_info, map) +
- 				(length * sizeof(struct xfs_bmbt_irec)),
- 			       KM_SLEEP | KM_NOFS);
- 	map_info->map_size = length;
- 
  	/*
  	 * Inside the loop we keep the main offset value as a byte offset
  	 * in the directory file.
  	 */
 -	curoff = xfs_dir2_dataptr_to_byte(ctx->pos);
 +	curoff = xfs_dir2_dataptr_to_byte(*offset);
  
- 	/*
- 	 * Force this conversion through db so we truncate the offset
- 	 * down to get the start of the data block.
- 	 */
- 	map_info->map_off = xfs_dir2_db_to_da(geo,
- 					      xfs_dir2_byte_to_db(geo, curoff));
- 
  	/*
  	 * Loop over directory entries until we reach the end offset.
  	 * Get more blocks and readahead as necessary.
@@@ -650,10 -491,9 +501,14 @@@
  	 * All done.  Set output offset value to current offset.
  	 */
  	if (curoff > xfs_dir2_dataptr_to_byte(XFS_DIR2_MAX_DATAPTR))
 -		ctx->pos = XFS_DIR2_MAX_DATAPTR & 0x7fffffff;
 +		*offset = XFS_DIR2_MAX_DATAPTR & 0x7fffffff;
  	else
++<<<<<<< HEAD
 +		*offset = xfs_dir2_byte_to_dataptr(curoff) & 0x7fffffff;
 +	kmem_free(map_info);
++=======
+ 		ctx->pos = xfs_dir2_byte_to_dataptr(curoff) & 0x7fffffff;
++>>>>>>> d205a7d0ec47 (xfs: refactor dir2 leaf readahead shadow buffer cleverness)
  	if (bp)
  		xfs_trans_brelse(NULL, bp);
  	return error;
* Unmerged path fs/xfs/xfs_dir2_readdir.c
