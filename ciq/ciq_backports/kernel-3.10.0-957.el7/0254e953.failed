watchdog: Drop pointer to watchdog device from struct watchdog_device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [watchdog] Drop pointer to watchdog device from struct watchdog_device (David Arcari) [1576173]
Rebuild_FUZZ: 92.19%
commit-author Guenter Roeck <linux@roeck-us.net>
commit 0254e953537c92df3e7d0176f401a211e944fd61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0254e953.failed

The lifetime of the watchdog device pointer is different from the lifetime
of its character device. Remove it entirely to avoid race conditions.

	Signed-off-by: Guenter Roeck <linux@roeck-us.net>
	Signed-off-by: Guenter Roeck <linux@roeck-us.net>
	Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
(cherry picked from commit 0254e953537c92df3e7d0176f401a211e944fd61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/watchdog/watchdog-kernel-api.txt
#	drivers/watchdog/watchdog_core.c
#	drivers/watchdog/watchdog_dev.c
#	include/linux/watchdog.h
diff --cc Documentation/watchdog/watchdog-kernel-api.txt
index d8b0d3367706,55120a055a14..000000000000
--- a/Documentation/watchdog/watchdog-kernel-api.txt
+++ b/Documentation/watchdog/watchdog-kernel-api.txt
@@@ -44,9 -44,8 +44,12 @@@ The watchdog device structure looks lik
  
  struct watchdog_device {
  	int id;
++<<<<<<< HEAD
 +	struct cdev cdev;
 +	struct device *dev;
++=======
++>>>>>>> 0254e953537c (watchdog: Drop pointer to watchdog device from struct watchdog_device)
  	struct device *parent;
 -	const struct attribute_group **groups;
  	const struct watchdog_info *info;
  	const struct watchdog_ops *ops;
  	unsigned int bootstatus;
@@@ -64,11 -65,10 +67,14 @@@ It contains following fields
    /dev/watchdog0 cdev (dynamic major, minor 0) as well as the old
    /dev/watchdog miscdev. The id is set automatically when calling
    watchdog_register_device.
++<<<<<<< HEAD
 +* cdev: cdev for the dynamic /dev/watchdog<id> device nodes. This
 +  field is also populated by watchdog_register_device.
 +* dev: device under the watchdog class (created by watchdog_register_device).
++=======
++>>>>>>> 0254e953537c (watchdog: Drop pointer to watchdog device from struct watchdog_device)
  * parent: set this to the parent device (or NULL) before calling
    watchdog_register_device.
 -* groups: List of sysfs attribute groups to create when creating the watchdog
 -  device.
  * info: a pointer to a watchdog_info structure. This structure gives some
    additional information about the watchdog timer itself. (Like it's unique name)
  * ops: a pointer to the list of watchdog operations that the watchdog supports.
diff --cc drivers/watchdog/watchdog_core.c
index ec37c78cc500,e600fd93b7de..000000000000
--- a/drivers/watchdog/watchdog_core.c
+++ b/drivers/watchdog/watchdog_core.c
@@@ -192,14 -244,26 +192,37 @@@ static int __watchdog_register_device(s
  		}
  	}
  
++<<<<<<< HEAD
 +	devno = wdd->cdev.dev;
 +	wdd->dev = device_create(watchdog_class, wdd->parent, devno,
 +					wdd, "watchdog%d", wdd->id);
 +	if (IS_ERR(wdd->dev)) {
 +		watchdog_dev_unregister(wdd);
 +		ida_simple_remove(&watchdog_ida, id);
 +		ret = PTR_ERR(wdd->dev);
 +		return ret;
++=======
+ 	if (test_bit(WDOG_STOP_ON_REBOOT, &wdd->status)) {
+ 		wdd->reboot_nb.notifier_call = watchdog_reboot_notifier;
+ 
+ 		ret = register_reboot_notifier(&wdd->reboot_nb);
+ 		if (ret) {
+ 			pr_err("watchdog%d: Cannot register reboot notifier (%d)\n",
+ 			       wdd->id, ret);
+ 			watchdog_dev_unregister(wdd);
+ 			ida_simple_remove(&watchdog_ida, wdd->id);
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	if (wdd->ops->restart) {
+ 		wdd->restart_nb.notifier_call = watchdog_restart_notifier;
+ 
+ 		ret = register_restart_handler(&wdd->restart_nb);
+ 		if (ret)
+ 			pr_warn("watchog%d: Cannot register restart handler (%d)\n",
+ 				wdd->id, ret);
++>>>>>>> 0254e953537c (watchdog: Drop pointer to watchdog device from struct watchdog_device)
  	}
  
  	return 0;
diff --cc drivers/watchdog/watchdog_dev.c
index f06fbcf0bea2,ba2ecce4aae6..000000000000
--- a/drivers/watchdog/watchdog_dev.c
+++ b/drivers/watchdog/watchdog_dev.c
@@@ -127,22 -137,15 +127,28 @@@ out_start
  
  static int watchdog_stop(struct watchdog_device *wdd)
  {
 -	int err;
 +	int err = 0;
 +
 +	mutex_lock(&wdd->lock);
 +
 +	if (test_bit(WDOG_UNREGISTERED, &wdd->status)) {
 +		err = -ENODEV;
 +		goto out_stop;
 +	}
  
  	if (!watchdog_active(wdd))
 -		return 0;
 +		goto out_stop;
  
  	if (test_bit(WDOG_NO_WAY_OUT, &wdd->status)) {
++<<<<<<< HEAD
 +		dev_info(wdd->dev, "nowayout prevents watchdog being stopped!\n");
 +		err = -EBUSY;
 +		goto out_stop;
++=======
+ 		pr_info("watchdog%d: nowayout prevents watchdog being stopped!\n",
+ 			wdd->id);
+ 		return -EBUSY;
++>>>>>>> 0254e953537c (watchdog: Drop pointer to watchdog device from struct watchdog_device)
  	}
  
  	err = wdd->ops->stop(wdd);
@@@ -593,10 -605,7 +599,14 @@@ static int watchdog_release(struct inod
  
  	/* If the watchdog was not stopped, send a keepalive ping */
  	if (err < 0) {
++<<<<<<< HEAD
 +		mutex_lock(&wdd->lock);
 +		if (!test_bit(WDOG_UNREGISTERED, &wdd->status))
 +			dev_crit(wdd->dev, "watchdog did not stop!\n");
 +		mutex_unlock(&wdd->lock);
++=======
+ 		pr_crit("watchdog%d: watchdog did not stop!\n", wdd->id);
++>>>>>>> 0254e953537c (watchdog: Drop pointer to watchdog device from struct watchdog_device)
  		watchdog_ping(wdd);
  	}
  
@@@ -674,24 -693,29 +684,29 @@@ int watchdog_dev_register(struct watchd
  }
  
  /*
 - *	watchdog_cdev_unregister: unregister watchdog character device
 + *	watchdog_dev_unregister: unregister a watchdog device
   *	@watchdog: watchdog device
   *
 - *	Unregister watchdog character device and if needed the legacy
 - *	/dev/watchdog device.
 + *	Unregister the watchdog and if needed the legacy /dev/watchdog device.
   */
  
 -static void watchdog_cdev_unregister(struct watchdog_device *wdd)
 +int watchdog_dev_unregister(struct watchdog_device *wdd)
  {
 -	struct watchdog_core_data *wd_data = wdd->wd_data;
++<<<<<<< HEAD
 +	mutex_lock(&wdd->lock);
 +	set_bit(WDOG_UNREGISTERED, &wdd->status);
 +	mutex_unlock(&wdd->lock);
  
 -	cdev_del(&wd_data->cdev);
 +	cdev_del(&wdd->cdev);
  	if (wdd->id == 0) {
  		misc_deregister(&watchdog_miscdev);
 -		old_wd_data = NULL;
 +		old_wdd = NULL;
  	}
 -
 -	mutex_lock(&wd_data->lock);
 -	wd_data->wdd = NULL;
 -	wdd->wd_data = NULL;
 -	mutex_unlock(&wd_data->lock);
 -
 -	kref_put(&wd_data->kref, watchdog_core_data_release);
 +	return 0;
++=======
++	device_destroy(&watchdog_class, wdd->wd_data->cdev.dev);
++	watchdog_cdev_unregister(wdd);
++>>>>>>> 0254e953537c (watchdog: Drop pointer to watchdog device from struct watchdog_device)
  }
  
  static struct class watchdog_class = {
diff --cc include/linux/watchdog.h
index e90e3ea5ebeb,b585fa2507ee..000000000000
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@@ -53,9 -53,9 +53,12 @@@ struct watchdog_ops 
  /** struct watchdog_device - The structure that defines a watchdog device
   *
   * @id:		The watchdog's ID. (Allocated by watchdog_register_device)
++<<<<<<< HEAD
 + * @cdev:	The watchdog's Character device.
 + * @dev:	The device for our watchdog
++=======
++>>>>>>> 0254e953537c (watchdog: Drop pointer to watchdog device from struct watchdog_device)
   * @parent:	The parent bus device
 - * @groups:	List of sysfs attribute groups to create when creating the
 - *		watchdog device.
   * @info:	Pointer to a watchdog_info structure.
   * @ops:	Pointer to the list of watchdog operations.
   * @bootstatus:	Status of the watchdog device at boot.
@@@ -79,9 -81,8 +82,12 @@@
   */
  struct watchdog_device {
  	int id;
++<<<<<<< HEAD
 +	struct cdev cdev;
 +	struct device *dev;
++=======
++>>>>>>> 0254e953537c (watchdog: Drop pointer to watchdog device from struct watchdog_device)
  	struct device *parent;
 -	const struct attribute_group **groups;
  	const struct watchdog_info *info;
  	const struct watchdog_ops *ops;
  	unsigned int bootstatus;
* Unmerged path Documentation/watchdog/watchdog-kernel-api.txt
* Unmerged path drivers/watchdog/watchdog_core.c
* Unmerged path drivers/watchdog/watchdog_dev.c
* Unmerged path include/linux/watchdog.h
