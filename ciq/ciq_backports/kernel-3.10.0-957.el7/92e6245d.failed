md/r5cache: print more info of log recovery

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [md] r5cache: print more info of log recovery (Nigel Croxon) [1494474]
Rebuild_FUZZ: 96.39%
commit-author Song Liu <songliubraving@fb.com>
commit 92e6245deab80f0934a102ba969d8b891b8ba5bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/92e6245d.failed

Log recovery is critical for raid5 journal/cache. Printing information
about each recovery by default will help the system admin monitor the
status of the array.

	Signed-off-by: Song Liu <songliubraving@fb.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit 92e6245deab80f0934a102ba969d8b891b8ba5bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid5-cache.c
diff --cc drivers/md/raid5-cache.c
index 2c6c8b7c2873,8b8f9db05e91..000000000000
--- a/drivers/md/raid5-cache.c
+++ b/drivers/md/raid5-cache.c
@@@ -2117,46 -2462,54 +2117,56 @@@ static int r5l_recovery_log(struct r5l_
  	int ret;
  	sector_t pos;
  
 -	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
 -	if (!ctx)
 -		return -ENOMEM;
 +	ctx.pos = log->last_checkpoint;
 +	ctx.seq = log->last_cp_seq;
 +	ctx.meta_page = alloc_page(GFP_KERNEL);
 +	ctx.data_only_stripes = 0;
 +	ctx.data_parity_stripes = 0;
 +	INIT_LIST_HEAD(&ctx.cached_list);
  
 -	ctx->pos = log->last_checkpoint;
 -	ctx->seq = log->last_cp_seq;
 -	INIT_LIST_HEAD(&ctx->cached_list);
 -	ctx->meta_page = alloc_page(GFP_KERNEL);
 -
 -	if (!ctx->meta_page) {
 -		ret =  -ENOMEM;
 -		goto meta_page;
 -	}
 -
 -	if (r5l_recovery_allocate_ra_pool(log, ctx) != 0) {
 -		ret = -ENOMEM;
 -		goto ra_pool;
 -	}
 +	if (!ctx.meta_page)
 +		return -ENOMEM;
  
 -	ret = r5c_recovery_flush_log(log, ctx);
 +	ret = r5c_recovery_flush_log(log, &ctx);
 +	__free_page(ctx.meta_page);
  
  	if (ret)
 -		goto error;
 +		return ret;
  
 -	pos = ctx->pos;
 -	ctx->seq += 10000;
 +	pos = ctx.pos;
 +	ctx.seq += 10000;
  
++<<<<<<< HEAD
 +
 +	if ((ctx.data_only_stripes == 0) && (ctx.data_parity_stripes == 0))
 +		pr_debug("md/raid:%s: starting from clean shutdown\n",
 +			 mdname(mddev));
 +	else
 +		pr_debug("md/raid:%s: recovering %d data-only stripes and %d data-parity stripes\n",
 +			 mdname(mddev), ctx.data_only_stripes,
 +			 ctx.data_parity_stripes);
++=======
+ 	if ((ctx->data_only_stripes == 0) && (ctx->data_parity_stripes == 0))
+ 		pr_info("md/raid:%s: starting from clean shutdown\n",
+ 			 mdname(mddev));
+ 	else
+ 		pr_info("md/raid:%s: recovering %d data-only stripes and %d data-parity stripes\n",
+ 			 mdname(mddev), ctx->data_only_stripes,
+ 			 ctx->data_parity_stripes);
++>>>>>>> 92e6245deab8 (md/r5cache: print more info of log recovery)
  
 -	if (ctx->data_only_stripes == 0) {
 -		log->next_checkpoint = ctx->pos;
 -		r5l_log_write_empty_meta_block(log, ctx->pos, ctx->seq++);
 -		ctx->pos = r5l_ring_add(log, ctx->pos, BLOCK_SECTORS);
 -	} else if (r5c_recovery_rewrite_data_only_stripes(log, ctx)) {
 +	if (ctx.data_only_stripes == 0) {
 +		log->next_checkpoint = ctx.pos;
 +		r5l_log_write_empty_meta_block(log, ctx.pos, ctx.seq++);
 +		ctx.pos = r5l_ring_add(log, ctx.pos, BLOCK_SECTORS);
 +	} else if (r5c_recovery_rewrite_data_only_stripes(log, &ctx)) {
  		pr_err("md/raid:%s: failed to rewrite stripes to journal\n",
  		       mdname(mddev));
 -		ret =  -EIO;
 -		goto error;
 +		return -EIO;
  	}
  
 -	log->log_start = ctx->pos;
 -	log->seq = ctx->seq;
 +	log->log_start = ctx.pos;
 +	log->seq = ctx.seq;
  	log->last_checkpoint = pos;
  	r5l_write_super(log, pos);
  
* Unmerged path drivers/md/raid5-cache.c
