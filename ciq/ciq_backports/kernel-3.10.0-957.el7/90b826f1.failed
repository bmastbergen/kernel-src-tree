watchdog: Implement status function in watchdog core

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [watchdog] Implement status function in watchdog core (David Arcari) [1576173]
Rebuild_FUZZ: 89.36%
commit-author Guenter Roeck <linux@roeck-us.net>
commit 90b826f17a4e1c4ff2b3ef69512a6409e94f4d64
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/90b826f1.failed

Up to now, the watchdog status function called a driver function,
which was supposed to return the watchdog status. All but one
driver using the watchdog core did not implement this function,
and the driver implementing it did not implement it correctly
(the function is supposed to return WDIOF_ flags). At the same time,
at least some of the status information can be provided by the watchdog
core.

Provide the available status bits directly from the watchdog driver core.
Call the driver status function if it exists to get the boot status, but
always provide WDIOF_MAGICCLOSE and WDIOF_KEEPALIVEPING internally.
This patch makes the 'status' sysfs attribute always available.
This attribute is now displayed as hex number with 0x prepended to be
easier to decode.

	Signed-off-by: Guenter Roeck <linux@roeck-us.net>
	Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
(cherry picked from commit 90b826f17a4e1c4ff2b3ef69512a6409e94f4d64)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/watchdog/watchdog_dev.c
diff --cc drivers/watchdog/watchdog_dev.c
index f06fbcf0bea2,270f4bf291e3..000000000000
--- a/drivers/watchdog/watchdog_dev.c
+++ b/drivers/watchdog/watchdog_dev.c
@@@ -44,10 -50,121 +44,35 @@@
  
  #include "watchdog_core.h"
  
++<<<<<<< HEAD
++=======
+ /*
+  * struct watchdog_core_data - watchdog core internal data
+  * @kref:	Reference count.
+  * @cdev:	The watchdog's Character device.
+  * @wdd:	Pointer to watchdog device.
+  * @lock:	Lock for watchdog core.
+  * @status:	Watchdog core internal status bits.
+  */
+ struct watchdog_core_data {
+ 	struct kref kref;
+ 	struct cdev cdev;
+ 	struct watchdog_device *wdd;
+ 	struct mutex lock;
+ 	unsigned long last_keepalive;
+ 	unsigned long last_hw_keepalive;
+ 	struct delayed_work work;
+ 	unsigned long status;		/* Internal status bits */
+ #define _WDOG_DEV_OPEN		0	/* Opened ? */
+ #define _WDOG_ALLOW_RELEASE	1	/* Did we receive the magic char ? */
+ #define _WDOG_KEEPALIVE		2	/* Did we receive a keepalive ? */
+ };
+ 
++>>>>>>> 90b826f17a4e (watchdog: Implement status function in watchdog core)
  /* the dev_t structure to store the dynamically allocated watchdog devices */
  static dev_t watchdog_devt;
 -/* Reference to watchdog device behind /dev/watchdog */
 -static struct watchdog_core_data *old_wd_data;
 -
 -static struct workqueue_struct *watchdog_wq;
 -
 -static inline bool watchdog_need_worker(struct watchdog_device *wdd)
 -{
 -	/* All variables in milli-seconds */
 -	unsigned int hm = wdd->max_hw_heartbeat_ms;
 -	unsigned int t = wdd->timeout * 1000;
 -
 -	/*
 -	 * A worker to generate heartbeat requests is needed if all of the
 -	 * following conditions are true.
 -	 * - Userspace activated the watchdog.
 -	 * - The driver provided a value for the maximum hardware timeout, and
 -	 *   thus is aware that the framework supports generating heartbeat
 -	 *   requests.
 -	 * - Userspace requests a longer timeout than the hardware can handle.
 -	 *
 -	 * Alternatively, if userspace has not opened the watchdog
 -	 * device, we take care of feeding the watchdog if it is
 -	 * running.
 -	 */
 -	return (hm && watchdog_active(wdd) && t > hm) ||
 -		(t && !watchdog_active(wdd) && watchdog_hw_running(wdd));
 -}
 -
 -static long watchdog_next_keepalive(struct watchdog_device *wdd)
 -{
 -	struct watchdog_core_data *wd_data = wdd->wd_data;
 -	unsigned int timeout_ms = wdd->timeout * 1000;
 -	unsigned long keepalive_interval;
 -	unsigned long last_heartbeat;
 -	unsigned long virt_timeout;
 -	unsigned int hw_heartbeat_ms;
 -
 -	virt_timeout = wd_data->last_keepalive + msecs_to_jiffies(timeout_ms);
 -	hw_heartbeat_ms = min_not_zero(timeout_ms, wdd->max_hw_heartbeat_ms);
 -	keepalive_interval = msecs_to_jiffies(hw_heartbeat_ms / 2);
 -
 -	if (!watchdog_active(wdd))
 -		return keepalive_interval;
 -
 -	/*
 -	 * To ensure that the watchdog times out wdd->timeout seconds
 -	 * after the most recent ping from userspace, the last
 -	 * worker ping has to come in hw_heartbeat_ms before this timeout.
 -	 */
 -	last_heartbeat = virt_timeout - msecs_to_jiffies(hw_heartbeat_ms);
 -	return min_t(long, last_heartbeat - jiffies, keepalive_interval);
 -}
 -
 -static inline void watchdog_update_worker(struct watchdog_device *wdd)
 -{
 -	struct watchdog_core_data *wd_data = wdd->wd_data;
 -
 -	if (watchdog_need_worker(wdd)) {
 -		long t = watchdog_next_keepalive(wdd);
 -
 -		if (t > 0)
 -			mod_delayed_work(watchdog_wq, &wd_data->work, t);
 -	} else {
 -		cancel_delayed_work(&wd_data->work);
 -	}
 -}
 -
 -static int __watchdog_ping(struct watchdog_device *wdd)
 -{
 -	struct watchdog_core_data *wd_data = wdd->wd_data;
 -	unsigned long earliest_keepalive = wd_data->last_hw_keepalive +
 -				msecs_to_jiffies(wdd->min_hw_heartbeat_ms);
 -	int err;
 -
 -	if (time_is_after_jiffies(earliest_keepalive)) {
 -		mod_delayed_work(watchdog_wq, &wd_data->work,
 -				 earliest_keepalive - jiffies);
 -		return 0;
 -	}
 -
 -	wd_data->last_hw_keepalive = jiffies;
 -
 -	if (wdd->ops->ping)
 -		err = wdd->ops->ping(wdd);  /* ping the watchdog */
 -	else
 -		err = wdd->ops->start(wdd); /* restart watchdog */
 -
 -	watchdog_update_worker(wdd);
 -
 -	return err;
 -}
 +/* the watchdog device behind /dev/watchdog */
 +static struct watchdog_device *old_wdd;
  
  /*
   *	watchdog_ping: ping the watchdog.
@@@ -61,26 -180,30 +86,34 @@@
  
  static int watchdog_ping(struct watchdog_device *wdd)
  {
 -	struct watchdog_core_data *wd_data = wdd->wd_data;
 +	int err = 0;
  
 -	if (!watchdog_active(wdd) && !watchdog_hw_running(wdd))
 -		return 0;
 +	mutex_lock(&wdd->lock);
  
++<<<<<<< HEAD
 +	if (test_bit(WDOG_UNREGISTERED, &wdd->status)) {
 +		err = -ENODEV;
 +		goto out_ping;
 +	}
++=======
+ 	set_bit(_WDOG_KEEPALIVE, &wd_data->status);
+ 
+ 	wd_data->last_keepalive = jiffies;
+ 	return __watchdog_ping(wdd);
+ }
++>>>>>>> 90b826f17a4e (watchdog: Implement status function in watchdog core)
  
 -static void watchdog_ping_work(struct work_struct *work)
 -{
 -	struct watchdog_core_data *wd_data;
 -	struct watchdog_device *wdd;
 +	if (!watchdog_active(wdd))
 +		goto out_ping;
  
 -	wd_data = container_of(to_delayed_work(work), struct watchdog_core_data,
 -			       work);
 +	if (wdd->ops->ping)
 +		err = wdd->ops->ping(wdd);	/* ping the watchdog */
 +	else
 +		err = wdd->ops->start(wdd);	/* restart watchdog */
  
 -	mutex_lock(&wd_data->lock);
 -	wdd = wd_data->wdd;
 -	if (wdd && (watchdog_active(wdd) || watchdog_hw_running(wdd)))
 -		__watchdog_ping(wdd);
 -	mutex_unlock(&wd_data->lock);
 +out_ping:
 +	mutex_unlock(&wdd->lock);
 +	return err;
  }
  
  /*
@@@ -94,24 -219,26 +127,38 @@@
  
  static int watchdog_start(struct watchdog_device *wdd)
  {
 -	struct watchdog_core_data *wd_data = wdd->wd_data;
 -	unsigned long started_at;
 -	int err;
 +	int err = 0;
  
 -	if (watchdog_active(wdd))
 -		return 0;
 +	mutex_lock(&wdd->lock);
  
++<<<<<<< HEAD
 +	if (test_bit(WDOG_UNREGISTERED, &wdd->status)) {
 +		err = -ENODEV;
 +		goto out_start;
++=======
+ 	set_bit(_WDOG_KEEPALIVE, &wd_data->status);
+ 
+ 	started_at = jiffies;
+ 	if (watchdog_hw_running(wdd) && wdd->ops->ping)
+ 		err = wdd->ops->ping(wdd);
+ 	else
+ 		err = wdd->ops->start(wdd);
+ 	if (err == 0) {
+ 		set_bit(WDOG_ACTIVE, &wdd->status);
+ 		wd_data->last_keepalive = started_at;
+ 		watchdog_update_worker(wdd);
++>>>>>>> 90b826f17a4e (watchdog: Implement status function in watchdog core)
  	}
  
 +	if (watchdog_active(wdd))
 +		goto out_start;
 +
 +	err = wdd->ops->start(wdd);
 +	if (err == 0)
 +		set_bit(WDOG_ACTIVE, &wdd->status);
 +
 +out_start:
 +	mutex_unlock(&wdd->lock);
  	return err;
  }
  
@@@ -162,27 -289,29 +209,51 @@@ out_stop
   *	Get the watchdog's status flags.
   */
  
 -static unsigned int watchdog_get_status(struct watchdog_device *wdd)
 +static int watchdog_get_status(struct watchdog_device *wdd,
 +							unsigned int *status)
  {
++<<<<<<< HEAD
 +	int err = 0;
 +
 +	*status = 0;
 +	if (!wdd->ops->status)
 +		return -EOPNOTSUPP;
 +
 +	mutex_lock(&wdd->lock);
 +
 +	if (test_bit(WDOG_UNREGISTERED, &wdd->status)) {
 +		err = -ENODEV;
 +		goto out_status;
 +	}
 +
 +	*status = wdd->ops->status(wdd);
 +
 +out_status:
 +	mutex_unlock(&wdd->lock);
 +	return err;
++=======
+ 	struct watchdog_core_data *wd_data = wdd->wd_data;
+ 	unsigned int status;
+ 
+ 	if (wdd->ops->status)
+ 		status = wdd->ops->status(wdd);
+ 	else
+ 		status = wdd->bootstatus & (WDIOF_CARDRESET |
+ 					    WDIOF_OVERHEAT |
+ 					    WDIOF_FANFAULT |
+ 					    WDIOF_EXTERN1 |
+ 					    WDIOF_EXTERN2 |
+ 					    WDIOF_POWERUNDER |
+ 					    WDIOF_POWEROVER);
+ 
+ 	if (test_bit(_WDOG_ALLOW_RELEASE, &wd_data->status))
+ 		status |= WDIOF_MAGICCLOSE;
+ 
+ 	if (test_and_clear_bit(_WDOG_KEEPALIVE, &wd_data->status))
+ 		status |= WDIOF_KEEPALIVEPING;
+ 
+ 	return status;
++>>>>>>> 90b826f17a4e (watchdog: Implement status function in watchdog core)
  }
  
  /*
@@@ -261,14 -380,14 +332,18 @@@ static ssize_t status_show(struct devic
  				char *buf)
  {
  	struct watchdog_device *wdd = dev_get_drvdata(dev);
 -	struct watchdog_core_data *wd_data = wdd->wd_data;
 -	unsigned int status;
 +	ssize_t status;
 +	unsigned int val;
  
 -	mutex_lock(&wd_data->lock);
 -	status = watchdog_get_status(wdd);
 -	mutex_unlock(&wd_data->lock);
 +	status = watchdog_get_status(wdd, &val);
 +	if (!status)
 +		status = sprintf(buf, "%u\n", val);
  
++<<<<<<< HEAD
 +	return status;
++=======
+ 	return sprintf(buf, "0x%x\n", status);
++>>>>>>> 90b826f17a4e (watchdog: Implement status function in watchdog core)
  }
  static DEVICE_ATTR_RO(status);
  
diff --git a/Documentation/watchdog/watchdog-kernel-api.txt b/Documentation/watchdog/watchdog-kernel-api.txt
index d8b0d3367706..478ab756ee35 100644
--- a/Documentation/watchdog/watchdog-kernel-api.txt
+++ b/Documentation/watchdog/watchdog-kernel-api.txt
@@ -155,6 +155,10 @@ they are supported. These optional routines/operations are:
   info structure).
 * status: this routine checks the status of the watchdog timer device. The
   status of the device is reported with watchdog WDIOF_* status flags/bits.
+  WDIOF_MAGICCLOSE and WDIOF_KEEPALIVEPING are reported by the watchdog core;
+  it is not necessary to report those bits from the driver. Also, if no status
+  function is provided by the driver, the watchdog core reports the status bits
+  provided in the bootstatus variable of struct watchdog_device.
 * set_timeout: this routine checks and changes the timeout of the watchdog
   timer device. It returns 0 on success, -EINVAL for "parameter out of range"
   and -EIO for "could not write value to the watchdog". On success this
* Unmerged path drivers/watchdog/watchdog_dev.c
