mm: mlock: add mlock flags to enable VM_LOCKONFAULT usage

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mm] mlock: add mlock flags to enable VM_LOCKONFAULT usage (Rafael Aquini) [1560030]
Rebuild_FUZZ: 96.36%
commit-author Eric B Munson <emunson@akamai.com>
commit b0f205c2a3082dd9081f9a94e50658c5fa906ff1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b0f205c2.failed

The previous patch introduced a flag that specified pages in a VMA should
be placed on the unevictable LRU, but they should not be made present when
the area is created.  This patch adds the ability to set this state via
the new mlock system calls.

We add MLOCK_ONFAULT for mlock2 and MCL_ONFAULT for mlockall.
MLOCK_ONFAULT will set the VM_LOCKONFAULT modifier for VM_LOCKED.
MCL_ONFAULT should be used as a modifier to the two other mlockall flags.
When used with MCL_CURRENT, all current mappings will be marked with
VM_LOCKED | VM_LOCKONFAULT.  When used with MCL_FUTURE, the mm->def_flags
will be marked with VM_LOCKED | VM_LOCKONFAULT.  When used with both
MCL_CURRENT and MCL_FUTURE, all current mappings and mm->def_flags will be
marked with VM_LOCKED | VM_LOCKONFAULT.

Prior to this patch, mlockall() will unconditionally clear the
mm->def_flags any time it is called without MCL_FUTURE.  This behavior is
maintained after adding MCL_ONFAULT.  If a call to mlockall(MCL_FUTURE) is
followed by mlockall(MCL_CURRENT), the mm->def_flags will be cleared and
new VMAs will be unlocked.  This remains true with or without MCL_ONFAULT
in either mlockall() invocation.

munlock() will unconditionally clear both vma flags.  munlockall()
unconditionally clears for VMA flags on all VMAs and in the mm->def_flags
field.

	Signed-off-by: Eric B Munson <emunson@akamai.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Acked-by: Vlastimil Babka <vbabka@suse.cz>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Geert Uytterhoeven <geert@linux-m68k.org>
	Cc: Guenter Roeck <linux@roeck-us.net>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Michael Kerrisk <mtk.manpages@gmail.com>
	Cc: Ralf Baechle <ralf@linux-mips.org>
	Cc: Shuah Khan <shuahkh@osg.samsung.com>
	Cc: Stephen Rothwell <sfr@canb.auug.org.au>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit b0f205c2a3082dd9081f9a94e50658c5fa906ff1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/mlock.c
diff --cc mm/mlock.c
index 51bce8fdbf14,339d9e0949b6..000000000000
--- a/mm/mlock.c
+++ b/mm/mlock.c
@@@ -594,14 -578,11 +595,20 @@@ static int do_mlock(unsigned long start
  		prev = vma;
  
  	for (nstart = start ; ; ) {
++<<<<<<< HEAD
 +		vm_flags_t newflags;
++=======
+ 		vm_flags_t newflags = vma->vm_flags & VM_LOCKED_CLEAR_MASK;
+ 
+ 		newflags |= flags;
++>>>>>>> b0f205c2a308 (mm: mlock: add mlock flags to enable VM_LOCKONFAULT usage)
  
  		/* Here we know that  vma->vm_start <= nstart < vma->vm_end. */
 +
 +		newflags = vma->vm_flags & ~VM_LOCKED;
 +		if (on)
 +			newflags |= VM_LOCKED;
 +
  		tmp = vma->vm_end;
  		if (tmp > end)
  			tmp = end;
@@@ -721,6 -640,24 +728,27 @@@ SYSCALL_DEFINE2(mlock, unsigned long, s
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ SYSCALL_DEFINE2(mlock, unsigned long, start, size_t, len)
+ {
+ 	return do_mlock(start, len, VM_LOCKED);
+ }
+ 
+ SYSCALL_DEFINE3(mlock2, unsigned long, start, size_t, len, int, flags)
+ {
+ 	vm_flags_t vm_flags = VM_LOCKED;
+ 
+ 	if (flags & ~MLOCK_ONFAULT)
+ 		return -EINVAL;
+ 
+ 	if (flags & MLOCK_ONFAULT)
+ 		vm_flags |= VM_LOCKONFAULT;
+ 
+ 	return do_mlock(start, len, vm_flags);
+ }
+ 
++>>>>>>> b0f205c2a308 (mm: mlock: add mlock flags to enable VM_LOCKONFAULT usage)
  SYSCALL_DEFINE2(munlock, unsigned long, start, size_t, len)
  {
  	int ret;
@@@ -735,16 -672,37 +763,48 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int do_mlockall(int flags)
++=======
+ /*
+  * Take the MCL_* flags passed into mlockall (or 0 if called from munlockall)
+  * and translate into the appropriate modifications to mm->def_flags and/or the
+  * flags for all current VMAs.
+  *
+  * There are a couple of subtleties with this.  If mlockall() is called multiple
+  * times with different flags, the values do not necessarily stack.  If mlockall
+  * is called once including the MCL_FUTURE flag and then a second time without
+  * it, VM_LOCKED and VM_LOCKONFAULT will be cleared from mm->def_flags.
+  */
+ static int apply_mlockall_flags(int flags)
++>>>>>>> b0f205c2a308 (mm: mlock: add mlock flags to enable VM_LOCKONFAULT usage)
  {
  	struct vm_area_struct * vma, * prev = NULL;
+ 	vm_flags_t to_add = 0;
  
- 	if (flags & MCL_FUTURE)
+ 	current->mm->def_flags &= VM_LOCKED_CLEAR_MASK;
+ 	if (flags & MCL_FUTURE) {
  		current->mm->def_flags |= VM_LOCKED;
++<<<<<<< HEAD
 +	else
 +		current->mm->def_flags &= ~VM_LOCKED;
 +	if (flags == MCL_FUTURE)
 +		goto out;
++=======
+ 
+ 		if (flags & MCL_ONFAULT)
+ 			current->mm->def_flags |= VM_LOCKONFAULT;
+ 
+ 		if (!(flags & MCL_CURRENT))
+ 			goto out;
+ 	}
+ 
+ 	if (flags & MCL_CURRENT) {
+ 		to_add |= VM_LOCKED;
+ 		if (flags & MCL_ONFAULT)
+ 			to_add |= VM_LOCKONFAULT;
+ 	}
++>>>>>>> b0f205c2a308 (mm: mlock: add mlock flags to enable VM_LOCKONFAULT usage)
  
  	for (vma = current->mm->mmap; vma ; vma = prev->vm_next) {
  		vm_flags_t newflags;
diff --git a/arch/alpha/include/uapi/asm/mman.h b/arch/alpha/include/uapi/asm/mman.h
index 0086b472bc2b..f2f949671798 100644
--- a/arch/alpha/include/uapi/asm/mman.h
+++ b/arch/alpha/include/uapi/asm/mman.h
@@ -37,6 +37,9 @@
 
 #define MCL_CURRENT	 8192		/* lock all currently mapped pages */
 #define MCL_FUTURE	16384		/* lock all additions to address space */
+#define MCL_ONFAULT	32768		/* lock all pages that are faulted in */
+
+#define MLOCK_ONFAULT	0x01		/* Lock pages in range after they are faulted in, do not prefault */
 
 #define MADV_NORMAL	0		/* no further special treatment */
 #define MADV_RANDOM	1		/* expect random page references */
diff --git a/arch/mips/include/uapi/asm/mman.h b/arch/mips/include/uapi/asm/mman.h
index cfcb876cae6b..97c03f468924 100644
--- a/arch/mips/include/uapi/asm/mman.h
+++ b/arch/mips/include/uapi/asm/mman.h
@@ -61,6 +61,12 @@
  */
 #define MCL_CURRENT	1		/* lock all current mappings */
 #define MCL_FUTURE	2		/* lock all future mappings */
+#define MCL_ONFAULT	4		/* lock all pages that are faulted in */
+
+/*
+ * Flags for mlock
+ */
+#define MLOCK_ONFAULT	0x01		/* Lock pages in range after they are faulted in, do not prefault */
 
 #define MADV_NORMAL	0		/* no further special treatment */
 #define MADV_RANDOM	1		/* expect random page references */
diff --git a/arch/parisc/include/uapi/asm/mman.h b/arch/parisc/include/uapi/asm/mman.h
index 294d251ca7b2..ecc3ae1ca28e 100644
--- a/arch/parisc/include/uapi/asm/mman.h
+++ b/arch/parisc/include/uapi/asm/mman.h
@@ -31,6 +31,9 @@
 
 #define MCL_CURRENT	1		/* lock all current mappings */
 #define MCL_FUTURE	2		/* lock all future mappings */
+#define MCL_ONFAULT	4		/* lock all pages that are faulted in */
+
+#define MLOCK_ONFAULT	0x01		/* Lock pages in range after they are faulted in, do not prefault */
 
 #define MADV_NORMAL     0               /* no further special treatment */
 #define MADV_RANDOM     1               /* expect random page references */
diff --git a/arch/powerpc/include/uapi/asm/mman.h b/arch/powerpc/include/uapi/asm/mman.h
index 6ea26df0a73c..03c06ba7464f 100644
--- a/arch/powerpc/include/uapi/asm/mman.h
+++ b/arch/powerpc/include/uapi/asm/mman.h
@@ -22,6 +22,7 @@
 
 #define MCL_CURRENT     0x2000          /* lock all currently mapped pages */
 #define MCL_FUTURE      0x4000          /* lock all additions to address space */
+#define MCL_ONFAULT	0x8000		/* lock all pages that are faulted in */
 
 #define MAP_POPULATE	0x8000		/* populate (prefault) pagetables */
 #define MAP_NONBLOCK	0x10000		/* do not block on IO */
diff --git a/arch/sparc/include/uapi/asm/mman.h b/arch/sparc/include/uapi/asm/mman.h
index 0b14df33cffa..9765896ecb2c 100644
--- a/arch/sparc/include/uapi/asm/mman.h
+++ b/arch/sparc/include/uapi/asm/mman.h
@@ -17,6 +17,7 @@
 
 #define MCL_CURRENT     0x2000          /* lock all currently mapped pages */
 #define MCL_FUTURE      0x4000          /* lock all additions to address space */
+#define MCL_ONFAULT	0x8000		/* lock all pages that are faulted in */
 
 #define MAP_POPULATE	0x8000		/* populate (prefault) pagetables */
 #define MAP_NONBLOCK	0x10000		/* do not block on IO */
diff --git a/arch/tile/include/uapi/asm/mman.h b/arch/tile/include/uapi/asm/mman.h
index 81b8fc348d63..63ee13faf17d 100644
--- a/arch/tile/include/uapi/asm/mman.h
+++ b/arch/tile/include/uapi/asm/mman.h
@@ -36,6 +36,7 @@
  */
 #define MCL_CURRENT	1		/* lock all current mappings */
 #define MCL_FUTURE	2		/* lock all future mappings */
+#define MCL_ONFAULT	4		/* lock all pages that are faulted in */
 
 
 #endif /* _ASM_TILE_MMAN_H */
diff --git a/arch/xtensa/include/uapi/asm/mman.h b/arch/xtensa/include/uapi/asm/mman.h
index 00eed6786d7e..0844ae223965 100644
--- a/arch/xtensa/include/uapi/asm/mman.h
+++ b/arch/xtensa/include/uapi/asm/mman.h
@@ -68,6 +68,12 @@
  */
 #define MCL_CURRENT	1		/* lock all current mappings */
 #define MCL_FUTURE	2		/* lock all future mappings */
+#define MCL_ONFAULT	4		/* lock all pages that are faulted in */
+
+/*
+ * Flags for mlock
+ */
+#define MLOCK_ONFAULT	0x01		/* Lock pages in range after they are faulted in, do not prefault */
 
 #define MADV_NORMAL	0		/* no further special treatment */
 #define MADV_RANDOM	1		/* expect random page references */
diff --git a/include/uapi/asm-generic/mman-common.h b/include/uapi/asm-generic/mman-common.h
index 2c8ab0e60aae..4304d6382aed 100644
--- a/include/uapi/asm-generic/mman-common.h
+++ b/include/uapi/asm-generic/mman-common.h
@@ -25,6 +25,11 @@
 # define MAP_UNINITIALIZED 0x0		/* Don't support this flag */
 #endif
 
+/*
+ * Flags for mlock
+ */
+#define MLOCK_ONFAULT	0x01		/* Lock pages in range after they are faulted in, do not prefault */
+
 #define MS_ASYNC	1		/* sync memory asynchronously */
 #define MS_INVALIDATE	2		/* invalidate the caches */
 #define MS_SYNC		4		/* synchronous memory sync */
diff --git a/include/uapi/asm-generic/mman.h b/include/uapi/asm-generic/mman.h
index e9fe6fd2a074..7162cd4cca73 100644
--- a/include/uapi/asm-generic/mman.h
+++ b/include/uapi/asm-generic/mman.h
@@ -17,5 +17,6 @@
 
 #define MCL_CURRENT	1		/* lock all current mappings */
 #define MCL_FUTURE	2		/* lock all future mappings */
+#define MCL_ONFAULT	4		/* lock all pages that are faulted in */
 
 #endif /* __ASM_GENERIC_MMAN_H */
* Unmerged path mm/mlock.c
