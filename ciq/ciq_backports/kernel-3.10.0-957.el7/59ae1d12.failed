networking: introduce and use skb_put_data()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Johannes Berg <johannes.berg@intel.com>
commit 59ae1d127ac0ae404baf414c434ba2651b793f46
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/59ae1d12.failed

A common pattern with skb_put() is to just want to memcpy()
some data into the new space, introduce skb_put_data() for
this.

An spatch similar to the one for skb_put_zero() converts many
of the places using it:

    @@
    identifier p, p2;
    expression len, skb, data;
    type t, t2;
    @@
    (
    -p = skb_put(skb, len);
    +p = skb_put_data(skb, data, len);
    |
    -p = (t)skb_put(skb, len);
    +p = skb_put_data(skb, data, len);
    )
    (
    p2 = (t2)p;
    -memcpy(p2, data, len);
    |
    -memcpy(p, data, len);
    )

    @@
    type t, t2;
    identifier p, p2;
    expression skb, data;
    @@
    t *p;
    ...
    (
    -p = skb_put(skb, sizeof(t));
    +p = skb_put_data(skb, data, sizeof(t));
    |
    -p = (t *)skb_put(skb, sizeof(t));
    +p = skb_put_data(skb, data, sizeof(t));
    )
    (
    p2 = (t2)p;
    -memcpy(p2, data, sizeof(*p));
    |
    -memcpy(p, data, sizeof(*p));
    )

    @@
    expression skb, len, data;
    @@
    -memcpy(skb_put(skb, len), data, len);
    +skb_put_data(skb, data, len);

(again, manually post-processed to retain some comments)

	Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 59ae1d127ac0ae404baf414c434ba2651b793f46)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btusb.c
#	drivers/media/dvb-core/dvb_net.c
#	drivers/net/can/slcan.c
#	drivers/net/ethernet/aurora/nb8800.c
#	drivers/net/ethernet/cadence/macb.c
#	drivers/net/ethernet/ec_bhf.c
#	drivers/net/ethernet/marvell/mvneta.c
#	drivers/net/ieee802154/ca8210.c
#	drivers/net/wireless/ath/ath10k/wmi.c
#	drivers/net/wireless/ath/ath9k/wmi.c
#	drivers/net/wireless/mediatek/mt7601u/dma.c
#	drivers/net/wireless/mediatek/mt7601u/mcu.c
#	drivers/net/wireless/quantenna/qtnfmac/pearl/pcie.c
#	drivers/net/wireless/quantenna/qtnfmac/qlink_util.h
#	drivers/net/wireless/realtek/rtlwifi/pci.c
#	drivers/net/wireless/rsi/rsi_91x_mgmt.c
#	drivers/net/wireless/st/cw1200/scan.c
#	drivers/net/wireless/ti/wlcore/cmd.c
#	drivers/nfc/fdp/fdp.c
#	drivers/nfc/fdp/i2c.c
#	drivers/nfc/nfcmrvl/fw_dnld.c
#	drivers/nfc/nfcmrvl/i2c.c
#	drivers/nfc/nfcmrvl/usb.c
#	drivers/nfc/nxp-nci/firmware.c
#	drivers/nfc/nxp-nci/i2c.c
#	drivers/nfc/pn533.c
#	drivers/nfc/pn533/usb.c
#	drivers/nfc/port100.c
#	drivers/nfc/s3fwrn5/firmware.c
#	drivers/nfc/s3fwrn5/i2c.c
#	drivers/nfc/st21nfca/dep.c
#	drivers/nfc/st21nfca/i2c.c
#	drivers/rpmsg/rpmsg_char.c
#	drivers/s390/net/netiucv.c
#	drivers/staging/et131x/et131x.c
#	drivers/staging/gdm724x/gdm_lte.c
#	drivers/staging/ks7010/ks_hostif.c
#	drivers/staging/most/aim-network/networking.c
#	drivers/staging/octeon/ethernet-rx.c
#	drivers/staging/rtl8188eu/core/rtw_recv.c
#	drivers/staging/rtl8188eu/os_dep/mon.c
#	drivers/staging/rtl8192e/rtllib_rx.c
#	drivers/staging/rtl8192e/rtllib_tx.c
#	drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c
#	drivers/staging/rtl8192u/ieee80211/ieee80211_tx.c
#	drivers/staging/rtl8192u/r819xU_cmdpkt.c
#	drivers/staging/rtl8723bs/os_dep/recv_linux.c
#	drivers/staging/wilc1000/linux_mon.c
#	drivers/staging/wilc1000/linux_wlan.c
#	drivers/staging/wlan-ng/hfa384x_usb.c
#	drivers/usb/gadget/f_ncm.c
#	include/linux/skbuff.h
#	net/batman-adv/bat_v_ogm.c
#	net/batman-adv/fragmentation.c
#	net/bluetooth/hci_sock.c
#	net/can/bcm.c
#	net/mac80211/mlme.c
#	net/mac80211/tdls.c
#	net/netlink/af_netlink.c
#	net/nfc/digital_dep.c
#	net/nfc/nci/core.c
#	net/nfc/nci/hci.c
#	net/nfc/nci/uart.c
#	net/qrtr/qrtr.c
diff --cc drivers/bluetooth/btusb.c
index 7d3fe5357eb2,c7ea398e65c1..000000000000
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@@ -2398,6 -2365,50 +2398,53 @@@ static int btusb_shutdown_intel(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PM
+ /* Configure an out-of-band gpio as wake-up pin, if specified in device tree */
+ static int marvell_config_oob_wake(struct hci_dev *hdev)
+ {
+ 	struct sk_buff *skb;
+ 	struct btusb_data *data = hci_get_drvdata(hdev);
+ 	struct device *dev = &data->udev->dev;
+ 	u16 pin, gap, opcode;
+ 	int ret;
+ 	u8 cmd[5];
+ 
+ 	/* Move on if no wakeup pin specified */
+ 	if (of_property_read_u16(dev->of_node, "marvell,wakeup-pin", &pin) ||
+ 	    of_property_read_u16(dev->of_node, "marvell,wakeup-gap-ms", &gap))
+ 		return 0;
+ 
+ 	/* Vendor specific command to configure a GPIO as wake-up pin */
+ 	opcode = hci_opcode_pack(0x3F, 0x59);
+ 	cmd[0] = opcode & 0xFF;
+ 	cmd[1] = opcode >> 8;
+ 	cmd[2] = 2; /* length of parameters that follow */
+ 	cmd[3] = pin;
+ 	cmd[4] = gap; /* time in ms, for which wakeup pin should be asserted */
+ 
+ 	skb = bt_skb_alloc(sizeof(cmd), GFP_KERNEL);
+ 	if (!skb) {
+ 		bt_dev_err(hdev, "%s: No memory\n", __func__);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	skb_put_data(skb, cmd, sizeof(cmd));
+ 	hci_skb_pkt_type(skb) = HCI_COMMAND_PKT;
+ 
+ 	ret = btusb_send_frame(hdev, skb);
+ 	if (ret) {
+ 		bt_dev_err(hdev, "%s: configuration failed\n", __func__);
+ 		kfree_skb(skb);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ #endif
+ 
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  static int btusb_set_bdaddr_marvell(struct hci_dev *hdev,
  				    const bdaddr_t *bdaddr)
  {
diff --cc drivers/media/dvb-core/dvb_net.c
index e52276c98350,bbaf0a8cae8b..000000000000
--- a/drivers/media/dvb-core/dvb_net.c
+++ b/drivers/media/dvb-core/dvb_net.c
@@@ -596,17 -827,17 +596,25 @@@ static void dvb_net_ule( struct net_dev
  		}
  
  		/* Copy data into our current skb. */
++<<<<<<< HEAD
 +		how_much = min(priv->ule_sndu_remain, (int)ts_remain);
 +		memcpy(skb_put(priv->ule_skb, how_much), from_where, how_much);
 +		priv->ule_sndu_remain -= how_much;
 +		ts_remain -= how_much;
 +		from_where += how_much;
++=======
+ 		h.how_much = min(h.priv->ule_sndu_remain, (int)h.ts_remain);
+ 		skb_put_data(h.priv->ule_skb, h.from_where, h.how_much);
+ 		h.priv->ule_sndu_remain -= h.how_much;
+ 		h.ts_remain -= h.how_much;
+ 		h.from_where += h.how_much;
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  
  		/* Check for complete payload. */
 -		if (h.priv->ule_sndu_remain <= 0) {
 +		if (priv->ule_sndu_remain <= 0) {
  			/* Check CRC32, we've got it in our skb already. */
 -			__be16 ulen = htons(h.priv->ule_sndu_len);
 -			__be16 utype = htons(h.priv->ule_sndu_type);
 +			__be16 ulen = htons(priv->ule_sndu_len);
 +			__be16 utype = htons(priv->ule_sndu_type);
  			const u8 *tail;
  			struct kvec iov[3] = {
  				{ &ulen, sizeof ulen },
diff --cc drivers/net/can/slcan.c
index 92bc87cbf3e3,5d067c1b987f..000000000000
--- a/drivers/net/can/slcan.c
+++ b/drivers/net/can/slcan.c
@@@ -199,9 -216,7 +199,13 @@@ static void slc_bump(struct slcan *sl
  	can_skb_prv(skb)->ifindex = sl->dev->ifindex;
  	can_skb_prv(skb)->skbcnt = 0;
  
++<<<<<<< HEAD
 +	memcpy(skb_put(skb, sizeof(struct can_frame)),
 +	       &cf, sizeof(struct can_frame));
 +	netif_rx_ni(skb);
++=======
+ 	skb_put_data(skb, &cf, sizeof(struct can_frame));
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  
  	sl->dev->stats.rx_packets++;
  	sl->dev->stats.rx_bytes += cf.can_dlc;
diff --cc drivers/net/ethernet/cadence/macb.c
index a07dfe433fae,4b0168bcbc8a..000000000000
--- a/drivers/net/ethernet/cadence/macb.c
+++ b/drivers/net/ethernet/cadence/macb.c
@@@ -1479,15 -2557,663 +1479,404 @@@ static const struct net_device_ops macb
  #ifdef CONFIG_NET_POLL_CONTROLLER
  	.ndo_poll_controller	= macb_poll_controller,
  #endif
 -	.ndo_set_features	= macb_set_features,
 -	.ndo_features_check	= macb_features_check,
  };
  
 -/* Configure peripheral capabilities according to device tree
 - * and integration options used
 - */
 -static void macb_configure_caps(struct macb *bp,
 -				const struct macb_config *dt_conf)
 -{
 -	u32 dcfg;
 -
 -	if (dt_conf)
 -		bp->caps = dt_conf->caps;
 -
 -	if (hw_is_gem(bp->regs, bp->native_io)) {
 -		bp->caps |= MACB_CAPS_MACB_IS_GEM;
 -
 -		dcfg = gem_readl(bp, DCFG1);
 -		if (GEM_BFEXT(IRQCOR, dcfg) == 0)
 -			bp->caps |= MACB_CAPS_ISR_CLEAR_ON_WRITE;
 -		dcfg = gem_readl(bp, DCFG2);
 -		if ((dcfg & (GEM_BIT(RX_PKT_BUFF) | GEM_BIT(TX_PKT_BUFF))) == 0)
 -			bp->caps |= MACB_CAPS_FIFO_MODE;
 -	}
 -
 -	dev_dbg(&bp->pdev->dev, "Cadence caps 0x%08x\n", bp->caps);
 -}
 -
 -static void macb_probe_queues(void __iomem *mem,
 -			      bool native_io,
 -			      unsigned int *queue_mask,
 -			      unsigned int *num_queues)
 -{
 -	unsigned int hw_q;
 -
 -	*queue_mask = 0x1;
 -	*num_queues = 1;
 -
 -	/* is it macb or gem ?
 -	 *
 -	 * We need to read directly from the hardware here because
 -	 * we are early in the probe process and don't have the
 -	 * MACB_CAPS_MACB_IS_GEM flag positioned
 -	 */
 -	if (!hw_is_gem(mem, native_io))
 -		return;
 -
 -	/* bit 0 is never set but queue 0 always exists */
 -	*queue_mask = readl_relaxed(mem + GEM_DCFG6) & 0xff;
 -
 -	*queue_mask |= 0x1;
 -
 -	for (hw_q = 1; hw_q < MACB_MAX_QUEUES; ++hw_q)
 -		if (*queue_mask & (1 << hw_q))
 -			(*num_queues)++;
 -}
 -
 -static int macb_clk_init(struct platform_device *pdev, struct clk **pclk,
 -			 struct clk **hclk, struct clk **tx_clk,
 -			 struct clk **rx_clk)
 -{
 -	struct macb_platform_data *pdata;
 -	int err;
 -
 -	pdata = dev_get_platdata(&pdev->dev);
 -	if (pdata) {
 -		*pclk = pdata->pclk;
 -		*hclk = pdata->hclk;
 -	} else {
 -		*pclk = devm_clk_get(&pdev->dev, "pclk");
 -		*hclk = devm_clk_get(&pdev->dev, "hclk");
 -	}
 -
 -	if (IS_ERR(*pclk)) {
 -		err = PTR_ERR(*pclk);
 -		dev_err(&pdev->dev, "failed to get macb_clk (%u)\n", err);
 -		return err;
 -	}
 -
 -	if (IS_ERR(*hclk)) {
 -		err = PTR_ERR(*hclk);
 -		dev_err(&pdev->dev, "failed to get hclk (%u)\n", err);
 -		return err;
 -	}
 -
 -	*tx_clk = devm_clk_get(&pdev->dev, "tx_clk");
 -	if (IS_ERR(*tx_clk))
 -		*tx_clk = NULL;
 -
 -	*rx_clk = devm_clk_get(&pdev->dev, "rx_clk");
 -	if (IS_ERR(*rx_clk))
 -		*rx_clk = NULL;
 -
 -	err = clk_prepare_enable(*pclk);
 -	if (err) {
 -		dev_err(&pdev->dev, "failed to enable pclk (%u)\n", err);
 -		return err;
 -	}
 -
 -	err = clk_prepare_enable(*hclk);
 -	if (err) {
 -		dev_err(&pdev->dev, "failed to enable hclk (%u)\n", err);
 -		goto err_disable_pclk;
 -	}
 -
 -	err = clk_prepare_enable(*tx_clk);
 -	if (err) {
 -		dev_err(&pdev->dev, "failed to enable tx_clk (%u)\n", err);
 -		goto err_disable_hclk;
 -	}
 -
 -	err = clk_prepare_enable(*rx_clk);
 -	if (err) {
 -		dev_err(&pdev->dev, "failed to enable rx_clk (%u)\n", err);
 -		goto err_disable_txclk;
 -	}
 -
 -	return 0;
 -
 -err_disable_txclk:
 -	clk_disable_unprepare(*tx_clk);
 -
 -err_disable_hclk:
 -	clk_disable_unprepare(*hclk);
 -
 -err_disable_pclk:
 -	clk_disable_unprepare(*pclk);
 -
 -	return err;
 -}
 -
 -static int macb_init(struct platform_device *pdev)
 -{
 -	struct net_device *dev = platform_get_drvdata(pdev);
 -	unsigned int hw_q, q;
 -	struct macb *bp = netdev_priv(dev);
 -	struct macb_queue *queue;
 -	int err;
 -	u32 val;
 -
 -	bp->tx_ring_size = DEFAULT_TX_RING_SIZE;
 -	bp->rx_ring_size = DEFAULT_RX_RING_SIZE;
 -
 -	/* set the queue register mapping once for all: queue0 has a special
 -	 * register mapping but we don't want to test the queue index then
 -	 * compute the corresponding register offset at run time.
 -	 */
 -	for (hw_q = 0, q = 0; hw_q < MACB_MAX_QUEUES; ++hw_q) {
 -		if (!(bp->queue_mask & (1 << hw_q)))
 -			continue;
 -
 -		queue = &bp->queues[q];
 -		queue->bp = bp;
 -		if (hw_q) {
 -			queue->ISR  = GEM_ISR(hw_q - 1);
 -			queue->IER  = GEM_IER(hw_q - 1);
 -			queue->IDR  = GEM_IDR(hw_q - 1);
 -			queue->IMR  = GEM_IMR(hw_q - 1);
 -			queue->TBQP = GEM_TBQP(hw_q - 1);
 -#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
 -			if (bp->hw_dma_cap == HW_DMA_CAP_64B)
 -				queue->TBQPH = GEM_TBQPH(hw_q - 1);
 -#endif
 -		} else {
 -			/* queue0 uses legacy registers */
 -			queue->ISR  = MACB_ISR;
 -			queue->IER  = MACB_IER;
 -			queue->IDR  = MACB_IDR;
 -			queue->IMR  = MACB_IMR;
 -			queue->TBQP = MACB_TBQP;
 -#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
 -			if (bp->hw_dma_cap == HW_DMA_CAP_64B)
 -				queue->TBQPH = MACB_TBQPH;
 -#endif
 -		}
 -
 -		/* get irq: here we use the linux queue index, not the hardware
 -		 * queue index. the queue irq definitions in the device tree
 -		 * must remove the optional gaps that could exist in the
 -		 * hardware queue mask.
 -		 */
 -		queue->irq = platform_get_irq(pdev, q);
 -		err = devm_request_irq(&pdev->dev, queue->irq, macb_interrupt,
 -				       IRQF_SHARED, dev->name, queue);
 -		if (err) {
 -			dev_err(&pdev->dev,
 -				"Unable to request IRQ %d (error %d)\n",
 -				queue->irq, err);
 -			return err;
 -		}
 -
 -		INIT_WORK(&queue->tx_error_task, macb_tx_error_task);
 -		q++;
 -	}
 -
 -	dev->netdev_ops = &macb_netdev_ops;
 -	netif_napi_add(dev, &bp->napi, macb_poll, 64);
 -
 -	/* setup appropriated routines according to adapter type */
 -	if (macb_is_gem(bp)) {
 -		bp->max_tx_length = GEM_MAX_TX_LEN;
 -		bp->macbgem_ops.mog_alloc_rx_buffers = gem_alloc_rx_buffers;
 -		bp->macbgem_ops.mog_free_rx_buffers = gem_free_rx_buffers;
 -		bp->macbgem_ops.mog_init_rings = gem_init_rings;
 -		bp->macbgem_ops.mog_rx = gem_rx;
 -		dev->ethtool_ops = &gem_ethtool_ops;
 -	} else {
 -		bp->max_tx_length = MACB_MAX_TX_LEN;
 -		bp->macbgem_ops.mog_alloc_rx_buffers = macb_alloc_rx_buffers;
 -		bp->macbgem_ops.mog_free_rx_buffers = macb_free_rx_buffers;
 -		bp->macbgem_ops.mog_init_rings = macb_init_rings;
 -		bp->macbgem_ops.mog_rx = macb_rx;
 -		dev->ethtool_ops = &macb_ethtool_ops;
 -	}
 -
 -	/* Set features */
 -	dev->hw_features = NETIF_F_SG;
 -
 -	/* Check LSO capability */
 -	if (GEM_BFEXT(PBUF_LSO, gem_readl(bp, DCFG6)))
 -		dev->hw_features |= MACB_NETIF_LSO;
 -
 -	/* Checksum offload is only available on gem with packet buffer */
 -	if (macb_is_gem(bp) && !(bp->caps & MACB_CAPS_FIFO_MODE))
 -		dev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_RXCSUM;
 -	if (bp->caps & MACB_CAPS_SG_DISABLED)
 -		dev->hw_features &= ~NETIF_F_SG;
 -	dev->features = dev->hw_features;
 -
 -	if (!(bp->caps & MACB_CAPS_USRIO_DISABLED)) {
 -		val = 0;
 -		if (bp->phy_interface == PHY_INTERFACE_MODE_RGMII)
 -			val = GEM_BIT(RGMII);
 -		else if (bp->phy_interface == PHY_INTERFACE_MODE_RMII &&
 -			 (bp->caps & MACB_CAPS_USRIO_DEFAULT_IS_MII_GMII))
 -			val = MACB_BIT(RMII);
 -		else if (!(bp->caps & MACB_CAPS_USRIO_DEFAULT_IS_MII_GMII))
 -			val = MACB_BIT(MII);
 -
 -		if (bp->caps & MACB_CAPS_USRIO_HAS_CLKEN)
 -			val |= MACB_BIT(CLKEN);
 -
 -		macb_or_gem_writel(bp, USRIO, val);
 -	}
 -
 -	/* Set MII management clock divider */
 -	val = macb_mdc_clk_div(bp);
 -	val |= macb_dbw(bp);
 -	if (bp->phy_interface == PHY_INTERFACE_MODE_SGMII)
 -		val |= GEM_BIT(SGMIIEN) | GEM_BIT(PCSSEL);
 -	macb_writel(bp, NCFGR, val);
 -
 -	return 0;
 -}
 -
  #if defined(CONFIG_OF)
++<<<<<<< HEAD
++=======
+ /* 1518 rounded up */
+ #define AT91ETHER_MAX_RBUFF_SZ	0x600
+ /* max number of receive buffers */
+ #define AT91ETHER_MAX_RX_DESCR	9
+ 
+ /* Initialize and start the Receiver and Transmit subsystems */
+ static int at91ether_start(struct net_device *dev)
+ {
+ 	struct macb *lp = netdev_priv(dev);
+ 	struct macb_dma_desc *desc;
+ 	dma_addr_t addr;
+ 	u32 ctl;
+ 	int i;
+ 
+ 	lp->rx_ring = dma_alloc_coherent(&lp->pdev->dev,
+ 					 (AT91ETHER_MAX_RX_DESCR *
+ 					  macb_dma_desc_get_size(lp)),
+ 					 &lp->rx_ring_dma, GFP_KERNEL);
+ 	if (!lp->rx_ring)
+ 		return -ENOMEM;
+ 
+ 	lp->rx_buffers = dma_alloc_coherent(&lp->pdev->dev,
+ 					    AT91ETHER_MAX_RX_DESCR *
+ 					    AT91ETHER_MAX_RBUFF_SZ,
+ 					    &lp->rx_buffers_dma, GFP_KERNEL);
+ 	if (!lp->rx_buffers) {
+ 		dma_free_coherent(&lp->pdev->dev,
+ 				  AT91ETHER_MAX_RX_DESCR *
+ 				  macb_dma_desc_get_size(lp),
+ 				  lp->rx_ring, lp->rx_ring_dma);
+ 		lp->rx_ring = NULL;
+ 		return -ENOMEM;
+ 	}
+ 
+ 	addr = lp->rx_buffers_dma;
+ 	for (i = 0; i < AT91ETHER_MAX_RX_DESCR; i++) {
+ 		desc = macb_rx_desc(lp, i);
+ 		macb_set_addr(lp, desc, addr);
+ 		desc->ctrl = 0;
+ 		addr += AT91ETHER_MAX_RBUFF_SZ;
+ 	}
+ 
+ 	/* Set the Wrap bit on the last descriptor */
+ 	desc->addr |= MACB_BIT(RX_WRAP);
+ 
+ 	/* Reset buffer index */
+ 	lp->rx_tail = 0;
+ 
+ 	/* Program address of descriptor list in Rx Buffer Queue register */
+ 	macb_writel(lp, RBQP, lp->rx_ring_dma);
+ 
+ 	/* Enable Receive and Transmit */
+ 	ctl = macb_readl(lp, NCR);
+ 	macb_writel(lp, NCR, ctl | MACB_BIT(RE) | MACB_BIT(TE));
+ 
+ 	return 0;
+ }
+ 
+ /* Open the ethernet interface */
+ static int at91ether_open(struct net_device *dev)
+ {
+ 	struct macb *lp = netdev_priv(dev);
+ 	u32 ctl;
+ 	int ret;
+ 
+ 	/* Clear internal statistics */
+ 	ctl = macb_readl(lp, NCR);
+ 	macb_writel(lp, NCR, ctl | MACB_BIT(CLRSTAT));
+ 
+ 	macb_set_hwaddr(lp);
+ 
+ 	ret = at91ether_start(dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Enable MAC interrupts */
+ 	macb_writel(lp, IER, MACB_BIT(RCOMP)	|
+ 			     MACB_BIT(RXUBR)	|
+ 			     MACB_BIT(ISR_TUND)	|
+ 			     MACB_BIT(ISR_RLE)	|
+ 			     MACB_BIT(TCOMP)	|
+ 			     MACB_BIT(ISR_ROVR)	|
+ 			     MACB_BIT(HRESP));
+ 
+ 	/* schedule a link state check */
+ 	phy_start(dev->phydev);
+ 
+ 	netif_start_queue(dev);
+ 
+ 	return 0;
+ }
+ 
+ /* Close the interface */
+ static int at91ether_close(struct net_device *dev)
+ {
+ 	struct macb *lp = netdev_priv(dev);
+ 	u32 ctl;
+ 
+ 	/* Disable Receiver and Transmitter */
+ 	ctl = macb_readl(lp, NCR);
+ 	macb_writel(lp, NCR, ctl & ~(MACB_BIT(TE) | MACB_BIT(RE)));
+ 
+ 	/* Disable MAC interrupts */
+ 	macb_writel(lp, IDR, MACB_BIT(RCOMP)	|
+ 			     MACB_BIT(RXUBR)	|
+ 			     MACB_BIT(ISR_TUND)	|
+ 			     MACB_BIT(ISR_RLE)	|
+ 			     MACB_BIT(TCOMP)	|
+ 			     MACB_BIT(ISR_ROVR) |
+ 			     MACB_BIT(HRESP));
+ 
+ 	netif_stop_queue(dev);
+ 
+ 	dma_free_coherent(&lp->pdev->dev,
+ 			  AT91ETHER_MAX_RX_DESCR *
+ 			  macb_dma_desc_get_size(lp),
+ 			  lp->rx_ring, lp->rx_ring_dma);
+ 	lp->rx_ring = NULL;
+ 
+ 	dma_free_coherent(&lp->pdev->dev,
+ 			  AT91ETHER_MAX_RX_DESCR * AT91ETHER_MAX_RBUFF_SZ,
+ 			  lp->rx_buffers, lp->rx_buffers_dma);
+ 	lp->rx_buffers = NULL;
+ 
+ 	return 0;
+ }
+ 
+ /* Transmit packet */
+ static int at91ether_start_xmit(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct macb *lp = netdev_priv(dev);
+ 
+ 	if (macb_readl(lp, TSR) & MACB_BIT(RM9200_BNQ)) {
+ 		netif_stop_queue(dev);
+ 
+ 		/* Store packet information (to free when Tx completed) */
+ 		lp->skb = skb;
+ 		lp->skb_length = skb->len;
+ 		lp->skb_physaddr = dma_map_single(NULL, skb->data, skb->len,
+ 							DMA_TO_DEVICE);
+ 		if (dma_mapping_error(NULL, lp->skb_physaddr)) {
+ 			dev_kfree_skb_any(skb);
+ 			dev->stats.tx_dropped++;
+ 			netdev_err(dev, "%s: DMA mapping error\n", __func__);
+ 			return NETDEV_TX_OK;
+ 		}
+ 
+ 		/* Set address of the data in the Transmit Address register */
+ 		macb_writel(lp, TAR, lp->skb_physaddr);
+ 		/* Set length of the packet in the Transmit Control register */
+ 		macb_writel(lp, TCR, skb->len);
+ 
+ 	} else {
+ 		netdev_err(dev, "%s called, but device is busy!\n", __func__);
+ 		return NETDEV_TX_BUSY;
+ 	}
+ 
+ 	return NETDEV_TX_OK;
+ }
+ 
+ /* Extract received frame from buffer descriptors and sent to upper layers.
+  * (Called from interrupt context)
+  */
+ static void at91ether_rx(struct net_device *dev)
+ {
+ 	struct macb *lp = netdev_priv(dev);
+ 	struct macb_dma_desc *desc;
+ 	unsigned char *p_recv;
+ 	struct sk_buff *skb;
+ 	unsigned int pktlen;
+ 
+ 	desc = macb_rx_desc(lp, lp->rx_tail);
+ 	while (desc->addr & MACB_BIT(RX_USED)) {
+ 		p_recv = lp->rx_buffers + lp->rx_tail * AT91ETHER_MAX_RBUFF_SZ;
+ 		pktlen = MACB_BF(RX_FRMLEN, desc->ctrl);
+ 		skb = netdev_alloc_skb(dev, pktlen + 2);
+ 		if (skb) {
+ 			skb_reserve(skb, 2);
+ 			skb_put_data(skb, p_recv, pktlen);
+ 
+ 			skb->protocol = eth_type_trans(skb, dev);
+ 			dev->stats.rx_packets++;
+ 			dev->stats.rx_bytes += pktlen;
+ 			netif_rx(skb);
+ 		} else {
+ 			dev->stats.rx_dropped++;
+ 		}
+ 
+ 		if (desc->ctrl & MACB_BIT(RX_MHASH_MATCH))
+ 			dev->stats.multicast++;
+ 
+ 		/* reset ownership bit */
+ 		desc->addr &= ~MACB_BIT(RX_USED);
+ 
+ 		/* wrap after last buffer */
+ 		if (lp->rx_tail == AT91ETHER_MAX_RX_DESCR - 1)
+ 			lp->rx_tail = 0;
+ 		else
+ 			lp->rx_tail++;
+ 
+ 		desc = macb_rx_desc(lp, lp->rx_tail);
+ 	}
+ }
+ 
+ /* MAC interrupt handler */
+ static irqreturn_t at91ether_interrupt(int irq, void *dev_id)
+ {
+ 	struct net_device *dev = dev_id;
+ 	struct macb *lp = netdev_priv(dev);
+ 	u32 intstatus, ctl;
+ 
+ 	/* MAC Interrupt Status register indicates what interrupts are pending.
+ 	 * It is automatically cleared once read.
+ 	 */
+ 	intstatus = macb_readl(lp, ISR);
+ 
+ 	/* Receive complete */
+ 	if (intstatus & MACB_BIT(RCOMP))
+ 		at91ether_rx(dev);
+ 
+ 	/* Transmit complete */
+ 	if (intstatus & MACB_BIT(TCOMP)) {
+ 		/* The TCOM bit is set even if the transmission failed */
+ 		if (intstatus & (MACB_BIT(ISR_TUND) | MACB_BIT(ISR_RLE)))
+ 			dev->stats.tx_errors++;
+ 
+ 		if (lp->skb) {
+ 			dev_kfree_skb_irq(lp->skb);
+ 			lp->skb = NULL;
+ 			dma_unmap_single(NULL, lp->skb_physaddr,
+ 					 lp->skb_length, DMA_TO_DEVICE);
+ 			dev->stats.tx_packets++;
+ 			dev->stats.tx_bytes += lp->skb_length;
+ 		}
+ 		netif_wake_queue(dev);
+ 	}
+ 
+ 	/* Work-around for EMAC Errata section 41.3.1 */
+ 	if (intstatus & MACB_BIT(RXUBR)) {
+ 		ctl = macb_readl(lp, NCR);
+ 		macb_writel(lp, NCR, ctl & ~MACB_BIT(RE));
+ 		wmb();
+ 		macb_writel(lp, NCR, ctl | MACB_BIT(RE));
+ 	}
+ 
+ 	if (intstatus & MACB_BIT(ISR_ROVR))
+ 		netdev_err(dev, "ROVR error\n");
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ #ifdef CONFIG_NET_POLL_CONTROLLER
+ static void at91ether_poll_controller(struct net_device *dev)
+ {
+ 	unsigned long flags;
+ 
+ 	local_irq_save(flags);
+ 	at91ether_interrupt(dev->irq, dev);
+ 	local_irq_restore(flags);
+ }
+ #endif
+ 
+ static const struct net_device_ops at91ether_netdev_ops = {
+ 	.ndo_open		= at91ether_open,
+ 	.ndo_stop		= at91ether_close,
+ 	.ndo_start_xmit		= at91ether_start_xmit,
+ 	.ndo_get_stats		= macb_get_stats,
+ 	.ndo_set_rx_mode	= macb_set_rx_mode,
+ 	.ndo_set_mac_address	= eth_mac_addr,
+ 	.ndo_do_ioctl		= macb_ioctl,
+ 	.ndo_validate_addr	= eth_validate_addr,
+ #ifdef CONFIG_NET_POLL_CONTROLLER
+ 	.ndo_poll_controller	= at91ether_poll_controller,
+ #endif
+ };
+ 
+ static int at91ether_clk_init(struct platform_device *pdev, struct clk **pclk,
+ 			      struct clk **hclk, struct clk **tx_clk,
+ 			      struct clk **rx_clk)
+ {
+ 	int err;
+ 
+ 	*hclk = NULL;
+ 	*tx_clk = NULL;
+ 	*rx_clk = NULL;
+ 
+ 	*pclk = devm_clk_get(&pdev->dev, "ether_clk");
+ 	if (IS_ERR(*pclk))
+ 		return PTR_ERR(*pclk);
+ 
+ 	err = clk_prepare_enable(*pclk);
+ 	if (err) {
+ 		dev_err(&pdev->dev, "failed to enable pclk (%u)\n", err);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int at91ether_init(struct platform_device *pdev)
+ {
+ 	struct net_device *dev = platform_get_drvdata(pdev);
+ 	struct macb *bp = netdev_priv(dev);
+ 	int err;
+ 	u32 reg;
+ 
+ 	dev->netdev_ops = &at91ether_netdev_ops;
+ 	dev->ethtool_ops = &macb_ethtool_ops;
+ 
+ 	err = devm_request_irq(&pdev->dev, dev->irq, at91ether_interrupt,
+ 			       0, dev->name, dev);
+ 	if (err)
+ 		return err;
+ 
+ 	macb_writel(bp, NCR, 0);
+ 
+ 	reg = MACB_BF(CLK, MACB_CLK_DIV32) | MACB_BIT(BIG);
+ 	if (bp->phy_interface == PHY_INTERFACE_MODE_RMII)
+ 		reg |= MACB_BIT(RM9200_RMII);
+ 
+ 	macb_writel(bp, NCFGR, reg);
+ 
+ 	return 0;
+ }
+ 
+ static const struct macb_config at91sam9260_config = {
+ 	.caps = MACB_CAPS_USRIO_HAS_CLKEN | MACB_CAPS_USRIO_DEFAULT_IS_MII_GMII,
+ 	.clk_init = macb_clk_init,
+ 	.init = macb_init,
+ };
+ 
+ static const struct macb_config pc302gem_config = {
+ 	.caps = MACB_CAPS_SG_DISABLED | MACB_CAPS_GIGABIT_MODE_AVAILABLE,
+ 	.dma_burst_length = 16,
+ 	.clk_init = macb_clk_init,
+ 	.init = macb_init,
+ };
+ 
+ static const struct macb_config sama5d2_config = {
+ 	.caps = MACB_CAPS_USRIO_DEFAULT_IS_MII_GMII,
+ 	.dma_burst_length = 16,
+ 	.clk_init = macb_clk_init,
+ 	.init = macb_init,
+ };
+ 
+ static const struct macb_config sama5d3_config = {
+ 	.caps = MACB_CAPS_SG_DISABLED | MACB_CAPS_GIGABIT_MODE_AVAILABLE
+ 	      | MACB_CAPS_USRIO_DEFAULT_IS_MII_GMII,
+ 	.dma_burst_length = 16,
+ 	.clk_init = macb_clk_init,
+ 	.init = macb_init,
+ };
+ 
+ static const struct macb_config sama5d4_config = {
+ 	.caps = MACB_CAPS_USRIO_DEFAULT_IS_MII_GMII,
+ 	.dma_burst_length = 4,
+ 	.clk_init = macb_clk_init,
+ 	.init = macb_init,
+ };
+ 
+ static const struct macb_config emac_config = {
+ 	.clk_init = at91ether_clk_init,
+ 	.init = at91ether_init,
+ };
+ 
+ static const struct macb_config np4_config = {
+ 	.caps = MACB_CAPS_USRIO_DISABLED,
+ 	.clk_init = macb_clk_init,
+ 	.init = macb_init,
+ };
+ 
+ static const struct macb_config zynqmp_config = {
+ 	.caps = MACB_CAPS_GIGABIT_MODE_AVAILABLE | MACB_CAPS_JUMBO,
+ 	.dma_burst_length = 16,
+ 	.clk_init = macb_clk_init,
+ 	.init = macb_init,
+ 	.jumbo_max_len = 10240,
+ };
+ 
+ static const struct macb_config zynq_config = {
+ 	.caps = MACB_CAPS_GIGABIT_MODE_AVAILABLE | MACB_CAPS_NO_GIGABIT_HALF,
+ 	.dma_burst_length = 16,
+ 	.clk_init = macb_clk_init,
+ 	.init = macb_init,
+ };
+ 
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  static const struct of_device_id macb_dt_ids[] = {
  	{ .compatible = "cdns,at32ap7000-macb" },
 -	{ .compatible = "cdns,at91sam9260-macb", .data = &at91sam9260_config },
 +	{ .compatible = "cdns,at91sam9260-macb" },
  	{ .compatible = "cdns,macb" },
 -	{ .compatible = "cdns,np4-macb", .data = &np4_config },
 -	{ .compatible = "cdns,pc302-gem", .data = &pc302gem_config },
 -	{ .compatible = "cdns,gem", .data = &pc302gem_config },
 -	{ .compatible = "atmel,sama5d2-gem", .data = &sama5d2_config },
 -	{ .compatible = "atmel,sama5d3-gem", .data = &sama5d3_config },
 -	{ .compatible = "atmel,sama5d4-gem", .data = &sama5d4_config },
 -	{ .compatible = "cdns,at91rm9200-emac", .data = &emac_config },
 -	{ .compatible = "cdns,emac", .data = &emac_config },
 -	{ .compatible = "cdns,zynqmp-gem", .data = &zynqmp_config},
 -	{ .compatible = "cdns,zynq-gem", .data = &zynq_config },
 +	{ .compatible = "cdns,pc302-gem" },
 +	{ .compatible = "cdns,gem" },
  	{ /* sentinel */ }
  };
  MODULE_DEVICE_TABLE(of, macb_dt_ids);
diff --cc drivers/net/ethernet/marvell/mvneta.c
index bcf995e5c9b0,0aab74c2a209..000000000000
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@@ -1337,84 -1894,273 +1337,278 @@@ static void mvneta_rxq_drop_pkts(struc
  	int rx_done, i;
  
  	rx_done = mvneta_rxq_busy_desc_num_get(pp, rxq);
 -	if (rx_done)
 -		mvneta_rxq_desc_num_update(pp, rxq, rx_done, rx_done);
 -
 -	if (pp->bm_priv) {
 -		for (i = 0; i < rx_done; i++) {
 -			struct mvneta_rx_desc *rx_desc =
 -						  mvneta_rxq_next_desc_get(rxq);
 -			u8 pool_id = MVNETA_RX_GET_BM_POOL_ID(rx_desc);
 -			struct mvneta_bm_pool *bm_pool;
 -
 -			bm_pool = &pp->bm_priv->bm_pools[pool_id];
 -			/* Return dropped buffer to the pool */
 -			mvneta_bm_pool_put_bp(pp->bm_priv, bm_pool,
 -					      rx_desc->buf_phys_addr);
 -		}
 -		return;
 -	}
 -
  	for (i = 0; i < rxq->size; i++) {
  		struct mvneta_rx_desc *rx_desc = rxq->descs + i;
 -		void *data = rxq->buf_virt_addr[i];
 +		struct sk_buff *skb = (struct sk_buff *)rx_desc->buf_cookie;
  
 +		dev_kfree_skb_any(skb);
  		dma_unmap_single(pp->dev->dev.parent, rx_desc->buf_phys_addr,
 -				 MVNETA_RX_BUF_SIZE(pp->pkt_size), DMA_FROM_DEVICE);
 -		mvneta_frag_free(pp->frag_size, data);
 +				 rx_desc->data_size, DMA_FROM_DEVICE);
  	}
 +
 +	if (rx_done)
 +		mvneta_rxq_desc_num_update(pp, rxq, rx_done, rx_done);
  }
  
 +/* Main rx processing */
 +static int mvneta_rx(struct mvneta_port *pp, int rx_todo,
 +		     struct mvneta_rx_queue *rxq)
 +{
 +	struct net_device *dev = pp->dev;
 +	int rx_done, rx_filled;
 +
 +	/* Get number of received packets */
 +	rx_done = mvneta_rxq_busy_desc_num_get(pp, rxq);
 +
 +	if (rx_todo > rx_done)
 +		rx_todo = rx_done;
 +
 +	rx_done = 0;
 +	rx_filled = 0;
 +
 +	/* Fairness NAPI loop */
 +	while (rx_done < rx_todo) {
 +		struct mvneta_rx_desc *rx_desc = mvneta_rxq_next_desc_get(rxq);
 +		struct sk_buff *skb;
 +		u32 rx_status;
 +		int rx_bytes, err;
 +
 +		prefetch(rx_desc);
 +		rx_done++;
 +		rx_filled++;
 +		rx_status = rx_desc->status;
 +		skb = (struct sk_buff *)rx_desc->buf_cookie;
 +
 +		if (!mvneta_rxq_desc_is_first_last(rx_desc) ||
 +		    (rx_status & MVNETA_RXD_ERR_SUMMARY)) {
 +			dev->stats.rx_errors++;
 +			mvneta_rx_error(pp, rx_desc);
 +			mvneta_rx_desc_fill(rx_desc, rx_desc->buf_phys_addr,
 +					    (u32)skb);
 +			continue;
 +		}
 +
 +		dma_unmap_single(pp->dev->dev.parent, rx_desc->buf_phys_addr,
 +				 rx_desc->data_size, DMA_FROM_DEVICE);
 +
++<<<<<<< HEAD
 +		rx_bytes = rx_desc->data_size -
 +			(ETH_FCS_LEN + MVNETA_MH_SIZE);
 +		u64_stats_update_begin(&pp->rx_stats.syncp);
 +		pp->rx_stats.packets++;
 +		pp->rx_stats.bytes += rx_bytes;
 +		u64_stats_update_end(&pp->rx_stats.syncp);
++=======
+ /* Main rx processing when using software buffer management */
+ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
+ 			  struct mvneta_rx_queue *rxq)
+ {
+ 	struct mvneta_pcpu_port *port = this_cpu_ptr(pp->ports);
+ 	struct net_device *dev = pp->dev;
+ 	int rx_done;
+ 	u32 rcvd_pkts = 0;
+ 	u32 rcvd_bytes = 0;
+ 
+ 	/* Get number of received packets */
+ 	rx_done = mvneta_rxq_busy_desc_num_get(pp, rxq);
+ 
+ 	if (rx_todo > rx_done)
+ 		rx_todo = rx_done;
+ 
+ 	rx_done = 0;
+ 
+ 	/* Fairness NAPI loop */
+ 	while (rx_done < rx_todo) {
+ 		struct mvneta_rx_desc *rx_desc = mvneta_rxq_next_desc_get(rxq);
+ 		struct sk_buff *skb;
+ 		unsigned char *data;
+ 		dma_addr_t phys_addr;
+ 		u32 rx_status, frag_size;
+ 		int rx_bytes, err, index;
+ 
+ 		rx_done++;
+ 		rx_status = rx_desc->status;
+ 		rx_bytes = rx_desc->data_size - (ETH_FCS_LEN + MVNETA_MH_SIZE);
+ 		index = rx_desc - rxq->descs;
+ 		data = rxq->buf_virt_addr[index];
+ 		phys_addr = rx_desc->buf_phys_addr;
+ 
+ 		if (!mvneta_rxq_desc_is_first_last(rx_status) ||
+ 		    (rx_status & MVNETA_RXD_ERR_SUMMARY)) {
+ err_drop_frame:
+ 			dev->stats.rx_errors++;
+ 			mvneta_rx_error(pp, rx_desc);
+ 			/* leave the descriptor untouched */
+ 			continue;
+ 		}
+ 
+ 		if (rx_bytes <= rx_copybreak) {
+ 		/* better copy a small frame and not unmap the DMA region */
+ 			skb = netdev_alloc_skb_ip_align(dev, rx_bytes);
+ 			if (unlikely(!skb))
+ 				goto err_drop_frame;
+ 
+ 			dma_sync_single_range_for_cpu(dev->dev.parent,
+ 						      phys_addr,
+ 						      MVNETA_MH_SIZE + NET_SKB_PAD,
+ 						      rx_bytes,
+ 						      DMA_FROM_DEVICE);
+ 			skb_put_data(skb, data + MVNETA_MH_SIZE + NET_SKB_PAD,
+ 				     rx_bytes);
+ 
+ 			skb->protocol = eth_type_trans(skb, dev);
+ 			mvneta_rx_csum(pp, rx_status, skb);
+ 			napi_gro_receive(&port->napi, skb);
+ 
+ 			rcvd_pkts++;
+ 			rcvd_bytes += rx_bytes;
+ 
+ 			/* leave the descriptor and buffer untouched */
+ 			continue;
+ 		}
+ 
+ 		/* Refill processing */
+ 		err = mvneta_rx_refill(pp, rx_desc, rxq);
+ 		if (err) {
+ 			netdev_err(dev, "Linux processing - Can't refill\n");
+ 			rxq->missed++;
+ 			goto err_drop_frame;
+ 		}
+ 
+ 		frag_size = pp->frag_size;
+ 
+ 		skb = build_skb(data, frag_size > PAGE_SIZE ? 0 : frag_size);
+ 
+ 		/* After refill old buffer has to be unmapped regardless
+ 		 * the skb is successfully built or not.
+ 		 */
+ 		dma_unmap_single(dev->dev.parent, phys_addr,
+ 				 MVNETA_RX_BUF_SIZE(pp->pkt_size),
+ 				 DMA_FROM_DEVICE);
+ 
+ 		if (!skb)
+ 			goto err_drop_frame;
+ 
+ 		rcvd_pkts++;
+ 		rcvd_bytes += rx_bytes;
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  
  		/* Linux processing */
 -		skb_reserve(skb, MVNETA_MH_SIZE + NET_SKB_PAD);
 +		skb_reserve(skb, MVNETA_MH_SIZE);
  		skb_put(skb, rx_bytes);
  
  		skb->protocol = eth_type_trans(skb, dev);
  
 -		mvneta_rx_csum(pp, rx_status, skb);
 +		mvneta_rx_csum(pp, rx_desc, skb);
  
++<<<<<<< HEAD
 +		napi_gro_receive(&pp->napi, skb);
++=======
+ 		napi_gro_receive(&port->napi, skb);
+ 	}
+ 
+ 	if (rcvd_pkts) {
+ 		struct mvneta_pcpu_stats *stats = this_cpu_ptr(pp->stats);
+ 
+ 		u64_stats_update_begin(&stats->syncp);
+ 		stats->rx_packets += rcvd_pkts;
+ 		stats->rx_bytes   += rcvd_bytes;
+ 		u64_stats_update_end(&stats->syncp);
+ 	}
+ 
+ 	/* Update rxq management counters */
+ 	mvneta_rxq_desc_num_update(pp, rxq, rx_done, rx_done);
+ 
+ 	return rx_done;
+ }
+ 
+ /* Main rx processing when using hardware buffer management */
+ static int mvneta_rx_hwbm(struct mvneta_port *pp, int rx_todo,
+ 			  struct mvneta_rx_queue *rxq)
+ {
+ 	struct mvneta_pcpu_port *port = this_cpu_ptr(pp->ports);
+ 	struct net_device *dev = pp->dev;
+ 	int rx_done;
+ 	u32 rcvd_pkts = 0;
+ 	u32 rcvd_bytes = 0;
+ 
+ 	/* Get number of received packets */
+ 	rx_done = mvneta_rxq_busy_desc_num_get(pp, rxq);
+ 
+ 	if (rx_todo > rx_done)
+ 		rx_todo = rx_done;
+ 
+ 	rx_done = 0;
+ 
+ 	/* Fairness NAPI loop */
+ 	while (rx_done < rx_todo) {
+ 		struct mvneta_rx_desc *rx_desc = mvneta_rxq_next_desc_get(rxq);
+ 		struct mvneta_bm_pool *bm_pool = NULL;
+ 		struct sk_buff *skb;
+ 		unsigned char *data;
+ 		dma_addr_t phys_addr;
+ 		u32 rx_status, frag_size;
+ 		int rx_bytes, err;
+ 		u8 pool_id;
+ 
+ 		rx_done++;
+ 		rx_status = rx_desc->status;
+ 		rx_bytes = rx_desc->data_size - (ETH_FCS_LEN + MVNETA_MH_SIZE);
+ 		data = (u8 *)(uintptr_t)rx_desc->buf_cookie;
+ 		phys_addr = rx_desc->buf_phys_addr;
+ 		pool_id = MVNETA_RX_GET_BM_POOL_ID(rx_desc);
+ 		bm_pool = &pp->bm_priv->bm_pools[pool_id];
+ 
+ 		if (!mvneta_rxq_desc_is_first_last(rx_status) ||
+ 		    (rx_status & MVNETA_RXD_ERR_SUMMARY)) {
+ err_drop_frame_ret_pool:
+ 			/* Return the buffer to the pool */
+ 			mvneta_bm_pool_put_bp(pp->bm_priv, bm_pool,
+ 					      rx_desc->buf_phys_addr);
+ err_drop_frame:
+ 			dev->stats.rx_errors++;
+ 			mvneta_rx_error(pp, rx_desc);
+ 			/* leave the descriptor untouched */
+ 			continue;
+ 		}
+ 
+ 		if (rx_bytes <= rx_copybreak) {
+ 			/* better copy a small frame and not unmap the DMA region */
+ 			skb = netdev_alloc_skb_ip_align(dev, rx_bytes);
+ 			if (unlikely(!skb))
+ 				goto err_drop_frame_ret_pool;
+ 
+ 			dma_sync_single_range_for_cpu(dev->dev.parent,
+ 			                              rx_desc->buf_phys_addr,
+ 			                              MVNETA_MH_SIZE + NET_SKB_PAD,
+ 			                              rx_bytes,
+ 			                              DMA_FROM_DEVICE);
+ 			skb_put_data(skb, data + MVNETA_MH_SIZE + NET_SKB_PAD,
+ 				     rx_bytes);
+ 
+ 			skb->protocol = eth_type_trans(skb, dev);
+ 			mvneta_rx_csum(pp, rx_status, skb);
+ 			napi_gro_receive(&port->napi, skb);
+ 
+ 			rcvd_pkts++;
+ 			rcvd_bytes += rx_bytes;
+ 
+ 			/* Return the buffer to the pool */
+ 			mvneta_bm_pool_put_bp(pp->bm_priv, bm_pool,
+ 					      rx_desc->buf_phys_addr);
+ 
+ 			/* leave the descriptor and buffer untouched */
+ 			continue;
+ 		}
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  
  		/* Refill processing */
 -		err = hwbm_pool_refill(&bm_pool->hwbm_pool, GFP_ATOMIC);
 +		err = mvneta_rx_refill(pp, rx_desc);
  		if (err) {
 -			netdev_err(dev, "Linux processing - Can't refill\n");
 +			netdev_err(pp->dev, "Linux processing - Can't refill\n");
  			rxq->missed++;
 -			goto err_drop_frame_ret_pool;
 +			rx_filled--;
  		}
 -
 -		frag_size = bm_pool->hwbm_pool.frag_size;
 -
 -		skb = build_skb(data, frag_size > PAGE_SIZE ? 0 : frag_size);
 -
 -		/* After refill old buffer has to be unmapped regardless
 -		 * the skb is successfully built or not.
 -		 */
 -		dma_unmap_single(&pp->bm_priv->pdev->dev, phys_addr,
 -				 bm_pool->buf_size, DMA_FROM_DEVICE);
 -		if (!skb)
 -			goto err_drop_frame;
 -
 -		rcvd_pkts++;
 -		rcvd_bytes += rx_bytes;
 -
 -		/* Linux processing */
 -		skb_reserve(skb, MVNETA_MH_SIZE + NET_SKB_PAD);
 -		skb_put(skb, rx_bytes);
 -
 -		skb->protocol = eth_type_trans(skb, dev);
 -
 -		mvneta_rx_csum(pp, rx_status, skb);
 -
 -		napi_gro_receive(&port->napi, skb);
 -	}
 -
 -	if (rcvd_pkts) {
 -		struct mvneta_pcpu_stats *stats = this_cpu_ptr(pp->stats);
 -
 -		u64_stats_update_begin(&stats->syncp);
 -		stats->rx_packets += rcvd_pkts;
 -		stats->rx_bytes   += rcvd_bytes;
 -		u64_stats_update_end(&stats->syncp);
  	}
  
  	/* Update rxq management counters */
diff --cc drivers/net/wireless/ath/ath10k/wmi.c
index 38a97086708b,a66e2482897f..000000000000
--- a/drivers/net/wireless/ath/ath10k/wmi.c
+++ b/drivers/net/wireless/ath/ath10k/wmi.c
@@@ -3330,7 -3305,7 +3330,11 @@@ static void ath10k_wmi_update_noa(struc
  	if (arvif->u.ap.noa_data)
  		if (!pskb_expand_head(bcn, 0, arvif->u.ap.noa_len, GFP_ATOMIC))
  			skb_put_data(bcn, arvif->u.ap.noa_data,
++<<<<<<< HEAD
 +				     arvif->u.ap.noa_len);
++=======
+ 			             arvif->u.ap.noa_len);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  }
  
  static int ath10k_wmi_op_pull_swba_ev(struct ath10k *ar, struct sk_buff *skb,
diff --cc drivers/net/wireless/ath/ath9k/wmi.c
index 64a354fa78ab,c51c69b1ad96..000000000000
--- a/drivers/net/wireless/ath/ath9k/wmi.c
+++ b/drivers/net/wireless/ath/ath9k/wmi.c
@@@ -311,7 -312,7 +311,11 @@@ int ath9k_wmi_cmd(struct wmi *wmi, enu
  	skb_reserve(skb, headroom);
  
  	if (cmd_len != 0 && cmd_buf != NULL) {
++<<<<<<< HEAD
 +		skb_put_data(skb, cmd_buf, cmd_len);
++=======
+ 		data = skb_put_data(skb, cmd_buf, cmd_len);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  	}
  
  	mutex_lock(&wmi->op_mutex);
diff --cc drivers/net/wireless/realtek/rtlwifi/pci.c
index 08dc8919ef60,0c1f8307e179..000000000000
--- a/drivers/net/wireless/realtek/rtlwifi/pci.c
+++ b/drivers/net/wireless/realtek/rtlwifi/pci.c
@@@ -734,7 -735,7 +734,11 @@@ static void _rtl_pci_rx_to_mac80211(str
  		if (likely(uskb)) {
  			memcpy(IEEE80211_SKB_RXCB(uskb), &rx_status,
  			       sizeof(rx_status));
++<<<<<<< HEAD
 +			skb_put_data(uskb, skb->data, skb->len);
++=======
+ 			pdata = skb_put_data(uskb, skb->data, skb->len);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  			dev_kfree_skb_any(skb);
  			ieee80211_rx_irqsafe(hw, uskb);
  		} else {
diff --cc drivers/net/wireless/ti/wlcore/cmd.c
index c9e060795d13,229f4d01f239..000000000000
--- a/drivers/net/wireless/ti/wlcore/cmd.c
+++ b/drivers/net/wireless/ti/wlcore/cmd.c
@@@ -1132,10 -1155,10 +1132,17 @@@ int wl12xx_cmd_build_probe_req(struct w
  		ret = -ENOMEM;
  		goto out;
  	}
++<<<<<<< HEAD
 +	if (ie_len)
 +		memcpy(skb_put(skb, ie_len), ie, ie_len);
 +
 +	wl1271_dump(DEBUG_SCAN, "PROBE REQ: ", skb->data, skb->len);
++=======
+ 	if (ie0_len)
+ 		skb_put_data(skb, ie0, ie0_len);
+ 	if (ie1_len)
+ 		skb_put_data(skb, ie1, ie1_len);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  
  	if (sched_scan &&
  	    (wl->quirks & WLCORE_QUIRK_DUAL_PROBE_TMPL)) {
diff --cc drivers/nfc/pn533.c
index 8f6f2baa930d,9200bb308e42..000000000000
--- a/drivers/nfc/pn533.c
+++ b/drivers/nfc/pn533.c
@@@ -1654,7 -1242,163 +1652,167 @@@ static void pn533_listen_mode_timer(uns
  
  	pn533_poll_next_mod(dev);
  
++<<<<<<< HEAD:drivers/nfc/pn533.c
 +	queue_work(dev->wq, &dev->poll_work);
++=======
+ 	queue_delayed_work(dev->wq, &dev->poll_work,
+ 			   msecs_to_jiffies(PN533_POLL_INTERVAL));
+ }
+ 
+ static int pn533_rf_complete(struct pn533 *dev, void *arg,
+ 			     struct sk_buff *resp)
+ {
+ 	int rc = 0;
+ 
+ 	dev_dbg(dev->dev, "%s\n", __func__);
+ 
+ 	if (IS_ERR(resp)) {
+ 		rc = PTR_ERR(resp);
+ 
+ 		nfc_err(dev->dev, "RF setting error %d\n", rc);
+ 
+ 		return rc;
+ 	}
+ 
+ 	queue_delayed_work(dev->wq, &dev->poll_work,
+ 			   msecs_to_jiffies(PN533_POLL_INTERVAL));
+ 
+ 	dev_kfree_skb(resp);
+ 	return rc;
+ }
+ 
+ static void pn533_wq_rf(struct work_struct *work)
+ {
+ 	struct pn533 *dev = container_of(work, struct pn533, rf_work);
+ 	struct sk_buff *skb;
+ 	int rc;
+ 
+ 	dev_dbg(dev->dev, "%s\n", __func__);
+ 
+ 	skb = pn533_alloc_skb(dev, 2);
+ 	if (!skb)
+ 		return;
+ 
+ 	*skb_put(skb, 1) = PN533_CFGITEM_RF_FIELD;
+ 	*skb_put(skb, 1) = PN533_CFGITEM_RF_FIELD_AUTO_RFCA;
+ 
+ 	rc = pn533_send_cmd_async(dev, PN533_CMD_RF_CONFIGURATION, skb,
+ 				  pn533_rf_complete, NULL);
+ 	if (rc < 0) {
+ 		dev_kfree_skb(skb);
+ 		nfc_err(dev->dev, "RF setting error %d\n", rc);
+ 	}
+ }
+ 
+ static int pn533_poll_dep_complete(struct pn533 *dev, void *arg,
+ 				   struct sk_buff *resp)
+ {
+ 	struct pn533_cmd_jump_dep_response *rsp;
+ 	struct nfc_target nfc_target;
+ 	u8 target_gt_len;
+ 	int rc;
+ 
+ 	if (IS_ERR(resp))
+ 		return PTR_ERR(resp);
+ 
+ 	rsp = (struct pn533_cmd_jump_dep_response *)resp->data;
+ 
+ 	rc = rsp->status & PN533_CMD_RET_MASK;
+ 	if (rc != PN533_CMD_RET_SUCCESS) {
+ 		/* Not target found, turn radio off */
+ 		queue_work(dev->wq, &dev->rf_work);
+ 
+ 		dev_kfree_skb(resp);
+ 		return 0;
+ 	}
+ 
+ 	dev_dbg(dev->dev, "Creating new target");
+ 
+ 	nfc_target.supported_protocols = NFC_PROTO_NFC_DEP_MASK;
+ 	nfc_target.nfcid1_len = 10;
+ 	memcpy(nfc_target.nfcid1, rsp->nfcid3t, nfc_target.nfcid1_len);
+ 	rc = nfc_targets_found(dev->nfc_dev, &nfc_target, 1);
+ 	if (rc)
+ 		goto error;
+ 
+ 	dev->tgt_available_prots = 0;
+ 	dev->tgt_active_prot = NFC_PROTO_NFC_DEP;
+ 
+ 	/* ATR_RES general bytes are located at offset 17 */
+ 	target_gt_len = resp->len - 17;
+ 	rc = nfc_set_remote_general_bytes(dev->nfc_dev,
+ 					  rsp->gt, target_gt_len);
+ 	if (!rc) {
+ 		rc = nfc_dep_link_is_up(dev->nfc_dev,
+ 					dev->nfc_dev->targets[0].idx,
+ 					0, NFC_RF_INITIATOR);
+ 
+ 		if (!rc)
+ 			pn533_poll_reset_mod_list(dev);
+ 	}
+ error:
+ 	dev_kfree_skb(resp);
+ 	return rc;
+ }
+ 
+ #define PASSIVE_DATA_LEN 5
+ static int pn533_poll_dep(struct nfc_dev *nfc_dev)
+ {
+ 	struct pn533 *dev = nfc_get_drvdata(nfc_dev);
+ 	struct sk_buff *skb;
+ 	int rc, skb_len;
+ 	u8 *next, nfcid3[NFC_NFCID3_MAXSIZE];
+ 	u8 passive_data[PASSIVE_DATA_LEN] = {0x00, 0xff, 0xff, 0x00, 0x3};
+ 
+ 	dev_dbg(dev->dev, "%s", __func__);
+ 
+ 	if (!dev->gb) {
+ 		dev->gb = nfc_get_local_general_bytes(nfc_dev, &dev->gb_len);
+ 
+ 		if (!dev->gb || !dev->gb_len) {
+ 			dev->poll_dep = 0;
+ 			queue_work(dev->wq, &dev->rf_work);
+ 		}
+ 	}
+ 
+ 	skb_len = 3 + dev->gb_len; /* ActPass + BR + Next */
+ 	skb_len += PASSIVE_DATA_LEN;
+ 
+ 	/* NFCID3 */
+ 	skb_len += NFC_NFCID3_MAXSIZE;
+ 	nfcid3[0] = 0x1;
+ 	nfcid3[1] = 0xfe;
+ 	get_random_bytes(nfcid3 + 2, 6);
+ 
+ 	skb = pn533_alloc_skb(dev, skb_len);
+ 	if (!skb)
+ 		return -ENOMEM;
+ 
+ 	*skb_put(skb, 1) = 0x01;  /* Active */
+ 	*skb_put(skb, 1) = 0x02;  /* 424 kbps */
+ 
+ 	next = skb_put(skb, 1);  /* Next */
+ 	*next = 0;
+ 
+ 	/* Copy passive data */
+ 	skb_put_data(skb, passive_data, PASSIVE_DATA_LEN);
+ 	*next |= 1;
+ 
+ 	/* Copy NFCID3 (which is NFCID2 from SENSF_RES) */
+ 	skb_put_data(skb, nfcid3, NFC_NFCID3_MAXSIZE);
+ 	*next |= 2;
+ 
+ 	skb_put_data(skb, dev->gb, dev->gb_len);
+ 	*next |= 4; /* We have some Gi */
+ 
+ 	rc = pn533_send_cmd_async(dev, PN533_CMD_IN_JUMP_FOR_DEP, skb,
+ 				  pn533_poll_dep_complete, NULL);
+ 
+ 	if (rc < 0)
+ 		dev_kfree_skb(skb);
+ 
+ 	return rc;
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data()):drivers/nfc/pn533/pn533.c
  }
  
  static int pn533_poll_complete(struct pn533 *dev, void *arg,
@@@ -2094,14 -1854,20 +2252,28 @@@ static int pn533_dep_link_up(struct nfc
  	next = skb_put(skb, 1);  /* Next */
  	*next = 0;
  
++<<<<<<< HEAD:drivers/nfc/pn533.c
 +	if (comm_mode == NFC_COMM_PASSIVE && baud > 0) {
 +		memcpy(skb_put(skb, PASSIVE_DATA_LEN), passive_data,
 +		       PASSIVE_DATA_LEN);
 +		*next |= 1;
 +	}
++=======
+ 	/* Copy passive data */
+ 	skb_put_data(skb, passive_data, PASSIVE_DATA_LEN);
+ 	*next |= 1;
+ 
+ 	/* Copy NFCID3 (which is NFCID2 from SENSF_RES) */
+ 	if (target && target->nfcid2_len)
+ 		memcpy(skb_put(skb, NFC_NFCID3_MAXSIZE), target->nfcid2,
+ 		       target->nfcid2_len);
+ 	else
+ 		skb_put_data(skb, nfcid3, NFC_NFCID3_MAXSIZE);
+ 	*next |= 2;
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data()):drivers/nfc/pn533/pn533.c
  
  	if (gb != NULL && gb_len > 0) {
- 		memcpy(skb_put(skb, gb_len), gb, gb_len);
+ 		skb_put_data(skb, gb, gb_len);
  		*next |= 4; /* We have some Gi */
  	} else {
  		*next = 0;
@@@ -2241,6 -2019,98 +2413,101 @@@ _error
  	return rc;
  }
  
++<<<<<<< HEAD:drivers/nfc/pn533.c
++=======
+ /*
+  * Receive an incoming pn533 frame. skb contains only header and payload.
+  * If skb == NULL, it is a notification that the link below is dead.
+  */
+ void pn533_recv_frame(struct pn533 *dev, struct sk_buff *skb, int status)
+ {
+ 	if (!dev->cmd)
+ 		goto sched_wq;
+ 
+ 	dev->cmd->status = status;
+ 
+ 	if (status != 0) {
+ 		dev_dbg(dev->dev, "%s: Error received: %d\n", __func__, status);
+ 		goto sched_wq;
+ 	}
+ 
+ 	if (skb == NULL) {
+ 		pr_err("NULL Frame -> link is dead\n");
+ 		goto sched_wq;
+ 	}
+ 
+ 	if (pn533_rx_frame_is_ack(skb->data)) {
+ 		dev_dbg(dev->dev, "%s: Received ACK frame\n", __func__);
+ 		dev_kfree_skb(skb);
+ 		return;
+ 	}
+ 
+ 	print_hex_dump_debug("PN533 RX: ", DUMP_PREFIX_NONE, 16, 1, skb->data,
+ 			     dev->ops->rx_frame_size(skb->data), false);
+ 
+ 	if (!dev->ops->rx_is_frame_valid(skb->data, dev)) {
+ 		nfc_err(dev->dev, "Received an invalid frame\n");
+ 		dev->cmd->status = -EIO;
+ 	} else if (!pn533_rx_frame_is_cmd_response(dev, skb->data)) {
+ 		nfc_err(dev->dev, "It it not the response to the last command\n");
+ 		dev->cmd->status = -EIO;
+ 	}
+ 
+ 	dev->cmd->resp = skb;
+ 
+ sched_wq:
+ 	queue_work(dev->wq, &dev->cmd_complete_work);
+ }
+ EXPORT_SYMBOL(pn533_recv_frame);
+ 
+ /* Split the Tx skb into small chunks */
+ static int pn533_fill_fragment_skbs(struct pn533 *dev, struct sk_buff *skb)
+ {
+ 	struct sk_buff *frag;
+ 	int  frag_size;
+ 
+ 	do {
+ 		/* Remaining size */
+ 		if (skb->len > PN533_CMD_DATAFRAME_MAXLEN)
+ 			frag_size = PN533_CMD_DATAFRAME_MAXLEN;
+ 		else
+ 			frag_size = skb->len;
+ 
+ 		/* Allocate and reserve */
+ 		frag = pn533_alloc_skb(dev, frag_size);
+ 		if (!frag) {
+ 			skb_queue_purge(&dev->fragment_skb);
+ 			break;
+ 		}
+ 
+ 		if (!dev->tgt_mode) {
+ 			/* Reserve the TG/MI byte */
+ 			skb_reserve(frag, 1);
+ 
+ 			/* MI + TG */
+ 			if (frag_size  == PN533_CMD_DATAFRAME_MAXLEN)
+ 				*skb_push(frag, sizeof(u8)) =
+ 							(PN533_CMD_MI_MASK | 1);
+ 			else
+ 				*skb_push(frag, sizeof(u8)) =  1; /* TG */
+ 		}
+ 
+ 		skb_put_data(frag, skb->data, frag_size);
+ 
+ 		/* Reduce the size of incoming buffer */
+ 		skb_pull(skb, frag_size);
+ 
+ 		/* Add this to skb_queue */
+ 		skb_queue_tail(&dev->fragment_skb, frag);
+ 
+ 	} while (skb->len > 0);
+ 
+ 	dev_kfree_skb(skb);
+ 
+ 	return skb_queue_len(&dev->fragment_skb);
+ }
+ 
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data()):drivers/nfc/pn533/pn533.c
  static int pn533_transceive(struct nfc_dev *nfc_dev,
  			    struct nfc_target *target, struct sk_buff *skb,
  			    data_exchange_cb_t cb, void *cb_context)
diff --cc drivers/s390/net/netiucv.c
index 33bd773f5b3b,7db427c0a6a4..000000000000
--- a/drivers/s390/net/netiucv.c
+++ b/drivers/s390/net/netiucv.c
@@@ -807,8 -779,8 +806,13 @@@ static void conn_action_txdone(fsm_inst
  	}
  
  	header.next = 0;
++<<<<<<< HEAD
 +	memcpy(skb_put(conn->tx_buff, NETIUCV_HDRLEN), &header, NETIUCV_HDRLEN);
 +	conn->prof.send_stamp = current_kernel_time();
++=======
+ 	skb_put_data(conn->tx_buff, &header, NETIUCV_HDRLEN);
+ 	conn->prof.send_stamp = jiffies;
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  	txmsg.class = 0;
  	txmsg.tag = 0;
  	rc = iucv_message_send(conn->path, &txmsg, 0, 0,
@@@ -1239,10 -1210,10 +1242,10 @@@ static int netiucv_transmit_skb(struct 
  		header.next = nskb->len + NETIUCV_HDRLEN;
  		memcpy(skb_push(nskb, NETIUCV_HDRLEN), &header, NETIUCV_HDRLEN);
  		header.next = 0;
- 		memcpy(skb_put(nskb, NETIUCV_HDRLEN), &header,  NETIUCV_HDRLEN);
+ 		skb_put_data(nskb, &header, NETIUCV_HDRLEN);
  
  		fsm_newstate(conn->fsm, CONN_STATE_TX);
 -		conn->prof.send_stamp = jiffies;
 +		conn->prof.send_stamp = current_kernel_time();
  
  		msg.tag = 1;
  		msg.class = 0;
diff --cc drivers/staging/et131x/et131x.c
index f73e58f5ef8d,54eff90e2f02..000000000000
--- a/drivers/staging/et131x/et131x.c
+++ b/drivers/staging/et131x/et131x.c
@@@ -2719,16 -2277,12 +2719,20 @@@ static struct rfd *nic_rx_pkts(struct e
  	rfd->len = len;
  
  	skb = dev_alloc_skb(rfd->len + 2);
 -	if (!skb)
 +	if (!skb) {
 +		dev_err(&adapter->pdev->dev, "Couldn't alloc an SKB for Rx\n");
  		return NULL;
 +	}
  
 -	adapter->netdev->stats.rx_bytes += rfd->len;
 +	adapter->net_stats.rx_bytes += rfd->len;
  
++<<<<<<< HEAD:drivers/staging/et131x/et131x.c
 +	memcpy(skb_put(skb, rfd->len),
 +	       rx_local->fbr[ring_index]->virt[buff_index],
 +	       rfd->len);
++=======
+ 	skb_put_data(skb, fbr->virt[buff_index], rfd->len);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data()):drivers/net/ethernet/agere/et131x.c
  
  	skb->protocol = eth_type_trans(skb, adapter->netdev);
  	skb->ip_summed = CHECKSUM_NONE;
diff --cc drivers/staging/octeon/ethernet-rx.c
index 34afc16bc493,72baedefa0f1..000000000000
--- a/drivers/staging/octeon/ethernet-rx.c
+++ b/drivers/staging/octeon/ethernet-rx.c
@@@ -360,7 -287,7 +360,11 @@@ static int cvm_oct_napi_poll(struct nap
  					else
  						ptr += 6;
  				}
++<<<<<<< HEAD
 +				memcpy(skb_put(skb, work->len), ptr, work->len);
++=======
+ 				skb_put_data(skb, ptr, work->word1.len);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  				/* No packet buffers to free */
  			} else {
  				int segments = work->word2.s.bufs;
@@@ -389,9 -322,9 +393,15 @@@
  					if (segment_size > len)
  						segment_size = len;
  					/* Copy the data into the packet */
++<<<<<<< HEAD
 +					memcpy(skb_put(skb, segment_size),
 +					       cvmx_phys_to_ptr(segment_ptr.s.addr),
 +					       segment_size);
++=======
+ 					skb_put_data(skb,
+ 						     cvmx_phys_to_ptr(segment_ptr.s.addr),
+ 						     segment_size);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  					len -= segment_size;
  					segment_ptr = next_ptr;
  				}
diff --cc drivers/staging/rtl8192e/rtllib_rx.c
index a8425d885efb,bae98ca0a9b6..000000000000
--- a/drivers/staging/rtl8192e/rtllib_rx.c
+++ b/drivers/staging/rtl8192e/rtllib_rx.c
@@@ -777,9 -814,10 +777,8 @@@ static u8 parse_subframe(struct rtllib_
  
  		/* Allocate new skb for releasing to upper layer */
  		sub_skb = dev_alloc_skb(RTLLIB_SKBBUFFER_SIZE);
 -		if (!sub_skb)
 -			return 0;
  		skb_reserve(sub_skb, 12);
- 		data_ptr = (u8 *)skb_put(sub_skb, skb->len);
- 		memcpy(data_ptr, skb->data, skb->len);
+ 		data_ptr = skb_put_data(sub_skb, skb->data, skb->len);
  		sub_skb->dev = ieee->dev;
  
  		rxb->subframes[0] = sub_skb;
@@@ -788,71 -826,74 +787,133 @@@
  		memcpy(rxb->dst, dst, ETH_ALEN);
  		rxb->subframes[0]->dev = ieee->dev;
  		return 1;
 -	}
 -
 +	} else {
 +		rxb->nr_subframes = 0;
 +		memcpy(rxb->src, src, ETH_ALEN);
 +		memcpy(rxb->dst, dst, ETH_ALEN);
 +		while (skb->len > ETHERNET_HEADER_SIZE) {
 +			/* Offset 12 denote 2 mac address */
 +			nSubframe_Length = *((u16 *)(skb->data + 12));
 +			nSubframe_Length = (nSubframe_Length >> 8) +
 +					   (nSubframe_Length << 8);
 +
++<<<<<<< HEAD
 +			if (skb->len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {
 +				printk(KERN_INFO "%s: A-MSDU parse error!! "
 +				       "pRfd->nTotalSubframe : %d\n",\
 +				       __func__, rxb->nr_subframes);
 +				printk(KERN_INFO "%s: A-MSDU parse error!! "
 +				       "Subframe Length: %d\n", __func__,
 +				       nSubframe_Length);
 +				printk(KERN_INFO "nRemain_Length is %d and "
 +				       "nSubframe_Length is : %d\n", skb->len,
 +				       nSubframe_Length);
 +				printk(KERN_INFO "The Packet SeqNum is %d\n", SeqNum);
++=======
+ 	rxb->nr_subframes = 0;
+ 	memcpy(rxb->src, src, ETH_ALEN);
+ 	memcpy(rxb->dst, dst, ETH_ALEN);
+ 	while (skb->len > ETHERNET_HEADER_SIZE) {
+ 		/* Offset 12 denote 2 mac address */
+ 		nSubframe_Length = *((u16 *)(skb->data + 12));
+ 		nSubframe_Length = (nSubframe_Length >> 8) +
+ 				   (nSubframe_Length << 8);
+ 
+ 		if (skb->len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {
+ 			netdev_info(ieee->dev,
+ 				    "%s: A-MSDU parse error!! pRfd->nTotalSubframe : %d\n",
+ 				    __func__, rxb->nr_subframes);
+ 			netdev_info(ieee->dev,
+ 				    "%s: A-MSDU parse error!! Subframe Length: %d\n",
+ 				    __func__, nSubframe_Length);
+ 			netdev_info(ieee->dev,
+ 				    "nRemain_Length is %d and nSubframe_Length is : %d\n",
+ 				    skb->len, nSubframe_Length);
+ 			netdev_info(ieee->dev,
+ 				    "The Packet SeqNum is %d\n",
+ 				    SeqNum);
+ 			return 0;
+ 		}
+ 
+ 		/* move the data point to data content */
+ 		skb_pull(skb, ETHERNET_HEADER_SIZE);
+ 
+ 		/* altered by clark 3/30/2010
+ 		 * The struct buffer size of the skb indicated to upper layer
+ 		 * must be less than 5000, or the defraged IP datagram
+ 		 * in the IP layer will exceed "ipfrag_high_tresh" and be
+ 		 * discarded. so there must not use the function
+ 		 * "skb_copy" and "skb_clone" for "skb".
+ 		 */
+ 
+ 		/* Allocate new skb for releasing to upper layer */
+ 		sub_skb = dev_alloc_skb(nSubframe_Length + 12);
+ 		if (!sub_skb)
+ 			return 0;
+ 		skb_reserve(sub_skb, 12);
+ 		data_ptr = skb_put_data(sub_skb, skb->data, nSubframe_Length);
+ 
+ 		sub_skb->dev = ieee->dev;
+ 		rxb->subframes[rxb->nr_subframes++] = sub_skb;
+ 		if (rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {
+ 			netdev_dbg(ieee->dev,
+ 				   "ParseSubframe(): Too many Subframes! Packets dropped!\n");
+ 			break;
+ 		}
+ 		skb_pull(skb, nSubframe_Length);
+ 
+ 		if (skb->len != 0) {
+ 			nPadding_Length = 4 - ((nSubframe_Length +
+ 					  ETHERNET_HEADER_SIZE) % 4);
+ 			if (nPadding_Length == 4)
+ 				nPadding_Length = 0;
+ 
+ 			if (skb->len < nPadding_Length)
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  				return 0;
 +			}
 +
 +			/* move the data point to data content */
 +			skb_pull(skb, ETHERNET_HEADER_SIZE);
  
 -			skb_pull(skb, nPadding_Length);
 +			/* altered by clark 3/30/2010
 +			 * The struct buffer size of the skb indicated to upper layer
 +			 * must be less than 5000, or the defraged IP datagram
 +			 * in the IP layer will exceed "ipfrag_high_tresh" and be
 +			 * discarded. so there must not use the function
 +			 * "skb_copy" and "skb_clone" for "skb".
 +			 */
 +
 +			/* Allocate new skb for releasing to upper layer */
 +			sub_skb = dev_alloc_skb(nSubframe_Length + 12);
 +			skb_reserve(sub_skb, 12);
 +			data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
 +			memcpy(data_ptr, skb->data, nSubframe_Length);
 +
 +			sub_skb->dev = ieee->dev;
 +			rxb->subframes[rxb->nr_subframes++] = sub_skb;
 +			if (rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {
 +				RTLLIB_DEBUG_RX("ParseSubframe(): Too many "
 +						"Subframes! Packets dropped!\n");
 +				break;
 +			}
 +			skb_pull(skb, nSubframe_Length);
 +
 +			if (skb->len != 0) {
 +				nPadding_Length = 4 - ((nSubframe_Length +
 +						  ETHERNET_HEADER_SIZE) % 4);
 +				if (nPadding_Length == 4)
 +					nPadding_Length = 0;
 +
 +				if (skb->len < nPadding_Length)
 +					return 0;
 +
 +				skb_pull(skb, nPadding_Length);
 +			}
  		}
 -	}
  
 -	return rxb->nr_subframes;
 +		return rxb->nr_subframes;
 +	}
  }
  
  
@@@ -1095,13 -1137,14 +1156,24 @@@ static int rtllib_rx_decrypt(struct rtl
  
  		if (frag == 0) {
  			/* copy first fragment (including full headers) into
++<<<<<<< HEAD
 +			 * beginning of the fragment cache skb */
 +			memcpy(skb_put(frag_skb, flen), skb->data, flen);
 +		} else {
 +			/* append frame payload to the end of the fragment
 +			 * cache skb */
 +			memcpy(skb_put(frag_skb, flen), skb->data + hdrlen,
 +			       flen);
++=======
+ 			 * beginning of the fragment cache skb
+ 			 */
+ 			skb_put_data(frag_skb, skb->data, flen);
+ 		} else {
+ 			/* append frame payload to the end of the fragment
+ 			 * cache skb
+ 			 */
+ 			skb_put_data(frag_skb, skb->data + hdrlen, flen);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  		}
  		dev_kfree_skb_any(skb);
  		skb = NULL;
diff --cc drivers/staging/rtl8192e/rtllib_tx.c
index 759d7c7d78e5,fc88d47dea43..000000000000
--- a/drivers/staging/rtl8192e/rtllib_tx.c
+++ b/drivers/staging/rtl8192e/rtllib_tx.c
@@@ -610,9 -623,8 +610,14 @@@ int rtllib_xmit_inter(struct sk_buff *s
  			}
  
  			txb->encrypted = 0;
++<<<<<<< HEAD
 +			txb->payload_size = skb->len;
 +			memcpy(skb_put(txb->fragments[0], skb->len), skb->data,
 +			       skb->len);
++=======
+ 			txb->payload_size = cpu_to_le16(skb->len);
+ 			skb_put_data(txb->fragments[0], skb->data, skb->len);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  
  			goto success;
  		}
@@@ -795,12 -817,11 +800,10 @@@
  			} else {
  				tcb_desc->bHwSec = 0;
  			}
- 			frag_hdr = (struct rtllib_hdr_3addrqos *)
- 				   skb_put(skb_frag, hdr_len);
- 			memcpy(frag_hdr, &header, hdr_len);
+ 			frag_hdr = skb_put_data(skb_frag, &header, hdr_len);
  
  			/* If this is not the last fragment, then add the
 -			 * MOREFRAGS bit to the frame control
 -			 */
 +			 * MOREFRAGS bit to the frame control */
  			if (i != nr_frags - 1) {
  				frag_hdr->frame_ctl = cpu_to_le16(
  					fc | RTLLIB_FCTL_MOREFRAGS);
@@@ -870,9 -891,8 +873,14 @@@
  		}
  
  		txb->encrypted = 0;
++<<<<<<< HEAD
 +		txb->payload_size = skb->len;
 +		memcpy(skb_put(txb->fragments[0], skb->len), skb->data,
 +		       skb->len);
++=======
+ 		txb->payload_size = cpu_to_le16(skb->len);
+ 		skb_put_data(txb->fragments[0], skb->data, skb->len);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  	}
  
   success:
diff --cc drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c
index efcaf2007a93,c0e2f711cb4e..000000000000
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c
@@@ -854,12 -845,14 +854,17 @@@ u8 parse_subframe(struct sk_buff *skb
  #else
  			/* Allocate new skb for releasing to upper layer */
  			sub_skb = dev_alloc_skb(nSubframe_Length + 12);
 -			if (!sub_skb)
 -				return 0;
  			skb_reserve(sub_skb, 12);
++<<<<<<< HEAD
 +			data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
 +			memcpy(data_ptr,skb->data,nSubframe_Length);
++=======
+ 			data_ptr = skb_put_data(sub_skb, skb->data,
+ 						nSubframe_Length);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  #endif
  			rxb->subframes[rxb->nr_subframes++] = sub_skb;
 -			if (rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {
 +			if(rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {
  				IEEE80211_DEBUG_RX("ParseSubframe(): Too many Subframes! Packets dropped!\n");
  				break;
  			}
diff --cc drivers/staging/rtl8192u/ieee80211/ieee80211_tx.c
index c39e680bb0ac,f58971a4a2e3..000000000000
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_tx.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_tx.c
@@@ -781,11 -794,11 +781,15 @@@ int ieee80211_xmit(struct sk_buff *skb
  			{
  				tcb_desc->bHwSec = 0;
  			}
++<<<<<<< HEAD
 +			frag_hdr = (struct ieee80211_hdr_3addrqos *)skb_put(skb_frag, hdr_len);
 +			memcpy(frag_hdr, &header, hdr_len);
++=======
+ 			frag_hdr = skb_put_data(skb_frag, &header, hdr_len);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  
  			/* If this is not the last fragment, then add the MOREFRAGS
 -			 * bit to the frame control
 -			 */
 +			* bit to the frame control */
  			if (i != nr_frags - 1) {
  				frag_hdr->frame_ctl = cpu_to_le16(
  					fc | IEEE80211_FCTL_MOREFRAGS);
@@@ -853,8 -867,8 +857,13 @@@
  		}
  
  		txb->encrypted = 0;
++<<<<<<< HEAD
 +		txb->payload_size = skb->len;
 +		memcpy(skb_put(txb->fragments[0],skb->len), skb->data, skb->len);
++=======
+ 		txb->payload_size = __cpu_to_le16(skb->len);
+ 		skb_put_data(txb->fragments[0], skb->data, skb->len);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  	}
  
   success:
diff --cc drivers/staging/rtl8192u/r819xU_cmdpkt.c
index b755eb46341f,c3cf01c842a3..000000000000
--- a/drivers/staging/rtl8192u/r819xU_cmdpkt.c
+++ b/drivers/staging/rtl8192u/r819xU_cmdpkt.c
@@@ -62,127 -45,21 +62,132 @@@ SendTxCommandPacket
  	tcb_desc->bCmdOrInit = DESC_PACKET_TYPE_NORMAL;
  	tcb_desc->bLastIniPkt = 0;
  	skb_reserve(skb, USB_HWDESC_HEADER_LEN);
++<<<<<<< HEAD
 +	ptr_buf = skb_put(skb, DataLen);
 +	memcpy(ptr_buf,pData,DataLen);
 +	tcb_desc->txbuf_size= (u16)DataLen;
++=======
+ 	ptr_buf = skb_put_data(skb, pData, DataLen);
+ 	tcb_desc->txbuf_size = (u16)DataLen;
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  
 -	if (!priv->ieee80211->check_nic_enough_desc(dev, tcb_desc->queue_index) ||
 -	    (!skb_queue_empty(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index])) ||
 -	    (priv->ieee80211->queue_stop)) {
 -		RT_TRACE(COMP_FIRMWARE, "=== NULL packet ======> tx full!\n");
 -		skb_queue_tail(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index], skb);
 -	} else {
 -		priv->ieee80211->softmac_hard_start_xmit(skb, dev);
 -	}
 +	if(!priv->ieee80211->check_nic_enough_desc(dev,tcb_desc->queue_index)||
 +			(!skb_queue_empty(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index]))||\
 +			(priv->ieee80211->queue_stop) ) {
 +			RT_TRACE(COMP_FIRMWARE,"===================NULL packet==================================> tx full!\n");
 +			skb_queue_tail(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index], skb);
 +		} else {
 +			priv->ieee80211->softmac_hard_start_xmit(skb,dev);
 +		}
  
 -	return RT_STATUS_SUCCESS;
 +	//PlatformReleaseSpinLock(Adapter, RT_TX_SPINLOCK);
 +	return rtStatus;
  }
  
 +/*-----------------------------------------------------------------------------
 + * Function:	cmpk_message_handle_tx()
 + *
 + * Overview:	Driver internal module can call the API to send message to
 + *				firmware side. For example, you can send a debug command packet.
 + *				Or you can send a request for FW to modify RLX4181 LBUS HW bank.
 + *				Otherwise, you can change MAC/PHT/RF register by firmware at
 + *				run time. We do not support message more than one segment now.
 + *
 + * Input:		NONE
 + *
 + * Output:		NONE
 + *
 + * Return:		NONE
 + *
 + * Revised History:
 + *	When		Who		Remark
 + *	05/06/2008	amy		porting from windows code.
 + *
 + *---------------------------------------------------------------------------*/
 + extern	rt_status	cmpk_message_handle_tx(
 +	struct net_device *dev,
 +	u8*	codevirtualaddress,
 +	u32	packettype,
 +	u32	buffer_len)
 +{
 +
 +	bool	    rt_status = true;
 +#ifdef RTL8192U
 +	return rt_status;
 +#else
 +	struct r8192_priv   *priv = ieee80211_priv(dev);
 +	u16		    frag_threshold;
 +	u16		    frag_length, frag_offset = 0;
 +	//u16		    total_size;
 +	//int		    i;
 +
 +	rt_firmware	    *pfirmware = priv->pFirmware;
 +	struct sk_buff	    *skb;
 +	unsigned char	    *seg_ptr;
 +	cb_desc		    *tcb_desc;
 +	u8                  bLastIniPkt;
 +
 +	firmware_init_param(dev);
 +	//Fragmentation might be required
 +	frag_threshold = pfirmware->cmdpacket_frag_thresold;
 +	do {
 +		if((buffer_len - frag_offset) > frag_threshold) {
 +			frag_length = frag_threshold ;
 +			bLastIniPkt = 0;
 +
 +		} else {
 +			frag_length = buffer_len - frag_offset;
 +			bLastIniPkt = 1;
 +
 +		}
 +
 +		/* Allocate skb buffer to contain firmware info and tx descriptor info
 +		 * add 4 to avoid packet appending overflow.
 +		 * */
 +		#ifdef RTL8192U
 +		skb  = dev_alloc_skb(USB_HWDESC_HEADER_LEN + frag_length + 4);
 +		#else
 +		skb  = dev_alloc_skb(frag_length + 4);
 +		#endif
 +		memcpy((unsigned char *)(skb->cb),&dev,sizeof(dev));
 +		tcb_desc = (cb_desc*)(skb->cb + MAX_DEV_ADDR_SIZE);
 +		tcb_desc->queue_index = TXCMD_QUEUE;
 +		tcb_desc->bCmdOrInit = packettype;
 +		tcb_desc->bLastIniPkt = bLastIniPkt;
 +
 +		#ifdef RTL8192U
 +		skb_reserve(skb, USB_HWDESC_HEADER_LEN);
 +		#endif
 +
 +		seg_ptr = skb_put(skb, buffer_len);
 +		/*
 +		 * Transform from little endian to big endian
 +		 * and pending zero
 +		 */
 +		memcpy(seg_ptr,codevirtualaddress,buffer_len);
 +		tcb_desc->txbuf_size= (u16)buffer_len;
 +
 +
 +		if(!priv->ieee80211->check_nic_enough_desc(dev,tcb_desc->queue_index)||
 +			(!skb_queue_empty(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index]))||\
 +			(priv->ieee80211->queue_stop) ) {
 +			RT_TRACE(COMP_FIRMWARE,"=====================================================> tx full!\n");
 +			skb_queue_tail(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index], skb);
 +		} else {
 +			priv->ieee80211->softmac_hard_start_xmit(skb,dev);
 +		}
 +
 +		codevirtualaddress += frag_length;
 +		frag_offset += frag_length;
 +
 +	}while(frag_offset < buffer_len);
 +
 +	return rt_status;
 +
 +
 +#endif
 +}	/* CMPK_Message_Handle_Tx */
 +
  /*-----------------------------------------------------------------------------
   * Function:    cmpk_counttxstatistic()
   *
diff --cc drivers/staging/wlan-ng/hfa384x_usb.c
index df2956f2ba5a,1de67f209f2c..000000000000
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@@ -3626,9 -3528,9 +3626,15 @@@ static void hfa384x_int_rxmonitor(wland
  	}
  
  	/* Copy the 802.11 header to the skb
++<<<<<<< HEAD
 +	   (ctl frames may be less than a full header) */
 +	datap = skb_put(skb, hdrlen);
 +	memcpy(datap, &(rxdesc->frame_control), hdrlen);
++=======
+ 	 * (ctl frames may be less than a full header)
+ 	 */
+ 	datap = skb_put_data(skb, &rxdesc->frame_control, hdrlen);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  
  	/* If any, copy the data from the card to the skb */
  	if (datalen > 0) {
diff --cc drivers/usb/gadget/f_ncm.c
index ee19bc8d0040,630616aaa861..000000000000
--- a/drivers/usb/gadget/f_ncm.c
+++ b/drivers/usb/gadget/f_ncm.c
@@@ -859,98 -957,239 +859,205 @@@ static int ncm_get_alt(struct usb_funct
  
  	if (intf == ncm->ctrl_id)
  		return 0;
++<<<<<<< HEAD:drivers/usb/gadget/f_ncm.c
 +	return ncm->port.in_ep->driver_data ? 1 : 0;
++=======
+ 	return ncm->port.in_ep->enabled ? 1 : 0;
+ }
+ 
+ static struct sk_buff *package_for_tx(struct f_ncm *ncm)
+ {
+ 	__le16		*ntb_iter;
+ 	struct sk_buff	*skb2 = NULL;
+ 	unsigned	ndp_pad;
+ 	unsigned	ndp_index;
+ 	unsigned	new_len;
+ 
+ 	const struct ndp_parser_opts *opts = ncm->parser_opts;
+ 	const int ndp_align = le16_to_cpu(ntb_parameters.wNdpInAlignment);
+ 	const int dgram_idx_len = 2 * 2 * opts->dgram_item_len;
+ 
+ 	/* Stop the timer */
+ 	hrtimer_try_to_cancel(&ncm->task_timer);
+ 
+ 	ndp_pad = ALIGN(ncm->skb_tx_data->len, ndp_align) -
+ 			ncm->skb_tx_data->len;
+ 	ndp_index = ncm->skb_tx_data->len + ndp_pad;
+ 	new_len = ndp_index + dgram_idx_len + ncm->skb_tx_ndp->len;
+ 
+ 	/* Set the final BlockLength and wNdpIndex */
+ 	ntb_iter = (void *) ncm->skb_tx_data->data;
+ 	/* Increment pointer to BlockLength */
+ 	ntb_iter += 2 + 1 + 1;
+ 	put_ncm(&ntb_iter, opts->block_length, new_len);
+ 	put_ncm(&ntb_iter, opts->ndp_index, ndp_index);
+ 
+ 	/* Set the final NDP wLength */
+ 	new_len = opts->ndp_size +
+ 			(ncm->ndp_dgram_count * dgram_idx_len);
+ 	ncm->ndp_dgram_count = 0;
+ 	/* Increment from start to wLength */
+ 	ntb_iter = (void *) ncm->skb_tx_ndp->data;
+ 	ntb_iter += 2;
+ 	put_unaligned_le16(new_len, ntb_iter);
+ 
+ 	/* Merge the skbs */
+ 	swap(skb2, ncm->skb_tx_data);
+ 	if (ncm->skb_tx_data) {
+ 		dev_consume_skb_any(ncm->skb_tx_data);
+ 		ncm->skb_tx_data = NULL;
+ 	}
+ 
+ 	/* Insert NDP alignment. */
+ 	ntb_iter = skb_put_zero(skb2, ndp_pad);
+ 
+ 	/* Copy NTB across. */
+ 	ntb_iter = skb_put_data(skb2, ncm->skb_tx_ndp->data,
+ 				ncm->skb_tx_ndp->len);
+ 	dev_consume_skb_any(ncm->skb_tx_ndp);
+ 	ncm->skb_tx_ndp = NULL;
+ 
+ 	/* Insert zero'd datagram. */
+ 	ntb_iter = skb_put_zero(skb2, dgram_idx_len);
+ 
+ 	return skb2;
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data()):drivers/usb/gadget/function/f_ncm.c
  }
  
  static struct sk_buff *ncm_wrap_ntb(struct gether *port,
  				    struct sk_buff *skb)
  {
  	struct f_ncm	*ncm = func_to_ncm(&port->func);
 -	struct sk_buff	*skb2 = NULL;
 +	struct sk_buff	*skb2;
  	int		ncb_len = 0;
 -	__le16		*ntb_data;
 -	__le16		*ntb_ndp;
 -	int		dgram_pad;
 -
 +	__le16		*tmp;
 +	int		div;
 +	int		rem;
 +	int		pad;
 +	int		ndp_align;
 +	int		ndp_pad;
  	unsigned	max_size = ncm->port.fixed_in_len;
  	const struct ndp_parser_opts *opts = ncm->parser_opts;
 -	const int ndp_align = le16_to_cpu(ntb_parameters.wNdpInAlignment);
 -	const int div = le16_to_cpu(ntb_parameters.wNdpInDivisor);
 -	const int rem = le16_to_cpu(ntb_parameters.wNdpInPayloadRemainder);
 -	const int dgram_idx_len = 2 * 2 * opts->dgram_item_len;
 +	unsigned	crc_len = ncm->is_crc ? sizeof(uint32_t) : 0;
 +
 +	div = le16_to_cpu(ntb_parameters.wNdpInDivisor);
 +	rem = le16_to_cpu(ntb_parameters.wNdpInPayloadRemainder);
 +	ndp_align = le16_to_cpu(ntb_parameters.wNdpInAlignment);
  
 -	if (!skb && !ncm->skb_tx_data)
 +	ncb_len += opts->nth_size;
 +	ndp_pad = ALIGN(ncb_len, ndp_align) - ncb_len;
 +	ncb_len += ndp_pad;
 +	ncb_len += opts->ndp_size;
 +	ncb_len += 2 * 2 * opts->dgram_item_len; /* Datagram entry */
 +	ncb_len += 2 * 2 * opts->dgram_item_len; /* Zero datagram entry */
 +	pad = ALIGN(ncb_len, div) + rem - ncb_len;
 +	ncb_len += pad;
 +
 +	if (ncb_len + skb->len + crc_len > max_size) {
 +		dev_kfree_skb_any(skb);
  		return NULL;
 +	}
  
 -	if (skb) {
 -		/* Add the CRC if required up front */
 -		if (ncm->is_crc) {
 -			uint32_t	crc;
 -			__le16		*crc_pos;
 -
 -			crc = ~crc32_le(~0,
 -					skb->data,
 -					skb->len);
 -			crc_pos = (void *) skb_put(skb, sizeof(uint32_t));
 -			put_unaligned_le32(crc, crc_pos);
 -		}
 +	skb2 = skb_copy_expand(skb, ncb_len,
 +			       max_size - skb->len - ncb_len - crc_len,
 +			       GFP_ATOMIC);
 +	dev_kfree_skb_any(skb);
 +	if (!skb2)
 +		return NULL;
  
 -		/* If the new skb is too big for the current NCM NTB then
 -		 * set the current stored skb to be sent now and clear it
 -		 * ready for new data.
 -		 * NOTE: Assume maximum align for speed of calculation.
 -		 */
 -		if (ncm->skb_tx_data
 -		    && (ncm->ndp_dgram_count >= TX_MAX_NUM_DPE
 -		    || (ncm->skb_tx_data->len +
 -		    div + rem + skb->len +
 -		    ncm->skb_tx_ndp->len + ndp_align + (2 * dgram_idx_len))
 -		    > max_size)) {
 -			skb2 = package_for_tx(ncm);
 -			if (!skb2)
 -				goto err;
 -		}
 +	skb = skb2;
  
 -		if (!ncm->skb_tx_data) {
 -			ncb_len = opts->nth_size;
 -			dgram_pad = ALIGN(ncb_len, div) + rem - ncb_len;
 -			ncb_len += dgram_pad;
 +	tmp = (void *) skb_push(skb, ncb_len);
 +	memset(tmp, 0, ncb_len);
  
 -			/* Create a new skb for the NTH and datagrams. */
 -			ncm->skb_tx_data = alloc_skb(max_size, GFP_ATOMIC);
 -			if (!ncm->skb_tx_data)
 -				goto err;
 +	put_unaligned_le32(opts->nth_sign, tmp); /* dwSignature */
 +	tmp += 2;
 +	/* wHeaderLength */
 +	put_unaligned_le16(opts->nth_size, tmp++);
 +	tmp++; /* skip wSequence */
 +	put_ncm(&tmp, opts->block_length, skb->len); /* (d)wBlockLength */
 +	/* (d)wFpIndex */
 +	/* the first pointer is right after the NTH + align */
 +	put_ncm(&tmp, opts->fp_index, opts->nth_size + ndp_pad);
  
 -			ncm->skb_tx_data->dev = ncm->netdev;
 -			ntb_data = skb_put_zero(ncm->skb_tx_data, ncb_len);
 -			/* dwSignature */
 -			put_unaligned_le32(opts->nth_sign, ntb_data);
 -			ntb_data += 2;
 -			/* wHeaderLength */
 -			put_unaligned_le16(opts->nth_size, ntb_data++);
 -
 -			/* Allocate an skb for storing the NDP,
 -			 * TX_MAX_NUM_DPE should easily suffice for a
 -			 * 16k packet.
 -			 */
 -			ncm->skb_tx_ndp = alloc_skb((int)(opts->ndp_size
 -						    + opts->dpe_size
 -						    * TX_MAX_NUM_DPE),
 -						    GFP_ATOMIC);
 -			if (!ncm->skb_tx_ndp)
 -				goto err;
 +	tmp = (void *)tmp + ndp_pad;
  
 +	/* NDP */
 +	put_unaligned_le32(ncm->ndp_sign, tmp); /* dwSignature */
 +	tmp += 2;
 +	/* wLength */
 +	put_unaligned_le16(ncb_len - opts->nth_size - pad, tmp++);
 +
 +	tmp += opts->reserved1;
 +	tmp += opts->next_fp_index; /* skip reserved (d)wNextFpIndex */
 +	tmp += opts->reserved2;
 +
 +	if (ncm->is_crc) {
 +		uint32_t crc;
 +
++<<<<<<< HEAD:drivers/usb/gadget/f_ncm.c
 +		crc = ~crc32_le(~0,
 +				skb->data + ncb_len,
 +				skb->len - ncb_len);
 +		put_unaligned_le32(crc, skb->data + skb->len);
 +		skb_put(skb, crc_len);
++=======
+ 			ncm->skb_tx_ndp->dev = ncm->netdev;
+ 			ntb_ndp = (void *) skb_put(ncm->skb_tx_ndp,
+ 						    opts->ndp_size);
+ 			memset(ntb_ndp, 0, ncb_len);
+ 			/* dwSignature */
+ 			put_unaligned_le32(ncm->ndp_sign, ntb_ndp);
+ 			ntb_ndp += 2;
+ 
+ 			/* There is always a zeroed entry */
+ 			ncm->ndp_dgram_count = 1;
+ 
+ 			/* Note: we skip opts->next_ndp_index */
+ 		}
+ 
+ 		/* Delay the timer. */
+ 		hrtimer_start(&ncm->task_timer, TX_TIMEOUT_NSECS,
+ 			      HRTIMER_MODE_REL);
+ 
+ 		/* Add the datagram position entries */
+ 		ntb_ndp = skb_put_zero(ncm->skb_tx_ndp, dgram_idx_len);
+ 
+ 		ncb_len = ncm->skb_tx_data->len;
+ 		dgram_pad = ALIGN(ncb_len, div) + rem - ncb_len;
+ 		ncb_len += dgram_pad;
+ 
+ 		/* (d)wDatagramIndex */
+ 		put_ncm(&ntb_ndp, opts->dgram_item_len, ncb_len);
+ 		/* (d)wDatagramLength */
+ 		put_ncm(&ntb_ndp, opts->dgram_item_len, skb->len);
+ 		ncm->ndp_dgram_count++;
+ 
+ 		/* Add the new data to the skb */
+ 		ntb_data = skb_put_zero(ncm->skb_tx_data, dgram_pad);
+ 		ntb_data = skb_put_data(ncm->skb_tx_data, skb->data, skb->len);
+ 		dev_consume_skb_any(skb);
+ 		skb = NULL;
+ 
+ 	} else if (ncm->skb_tx_data && ncm->timer_force_tx) {
+ 		/* If the tx was requested because of a timeout then send */
+ 		skb2 = package_for_tx(ncm);
+ 		if (!skb2)
+ 			goto err;
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data()):drivers/usb/gadget/function/f_ncm.c
  	}
  
 -	return skb2;
 -
 -err:
 -	ncm->netdev->stats.tx_dropped++;
 -
 -	if (skb)
 -		dev_kfree_skb_any(skb);
 -	if (ncm->skb_tx_data)
 -		dev_kfree_skb_any(ncm->skb_tx_data);
 -	if (ncm->skb_tx_ndp)
 -		dev_kfree_skb_any(ncm->skb_tx_ndp);
 -
 -	return NULL;
 -}
 -
 -/*
 - * This transmits the NTB if there are frames waiting.
 - */
 -static void ncm_tx_tasklet(unsigned long data)
 -{
 -	struct f_ncm	*ncm = (void *)data;
 -
 -	if (ncm->timer_stopping)
 -		return;
 -
 -	/* Only send if data is available. */
 -	if (ncm->skb_tx_data) {
 -		ncm->timer_force_tx = true;
 -
 -		/* XXX This allowance of a NULL skb argument to ndo_start_xmit
 -		 * XXX is not sane.  The gadget layer should be redesigned so
 -		 * XXX that the dev->wrap() invocations to build SKBs is transparent
 -		 * XXX and performed in some way outside of the ndo_start_xmit
 -		 * XXX interface.
 -		 */
 -		ncm->netdev->netdev_ops->ndo_start_xmit(NULL, ncm->netdev);
 +	/* (d)wDatagramIndex[0] */
 +	put_ncm(&tmp, opts->dgram_item_len, ncb_len);
 +	/* (d)wDatagramLength[0] */
 +	put_ncm(&tmp, opts->dgram_item_len, skb->len - ncb_len);
 +	/* (d)wDatagramIndex[1] and  (d)wDatagramLength[1] already zeroed */
  
 -		ncm->timer_force_tx = false;
 -	}
 -}
 +	if (skb->len > MAX_TX_NONFIXED)
 +		memset(skb_put(skb, max_size - skb->len),
 +		       0, max_size - skb->len);
  
 -/*
 - * The transmit should only be run if no skb data has been sent
 - * for a certain duration.
 - */
 -static enum hrtimer_restart ncm_tx_timeout(struct hrtimer *data)
 -{
 -	struct f_ncm *ncm = container_of(data, struct f_ncm, task_timer);
 -	tasklet_schedule(&ncm->tx_tasklet);
 -	return HRTIMER_NORESTART;
 +	return skb;
  }
  
  static int ncm_unwrap_ntb(struct gether *port,
@@@ -992,91 -1232,101 +1099,96 @@@
  		goto err;
  	}
  
 -	ndp_index = get_ncm(&tmp, opts->ndp_index);
 +	index = get_ncm(&tmp, opts->fp_index);
 +	/* NCM 3.2 */
 +	if (((index % 4) != 0) && (index < opts->nth_size)) {
 +		INFO(port->func.config->cdev, "Bad index: %x\n",
 +			index);
 +		goto err;
 +	}
  
 -	/* Run through all the NDP's in the NTB */
 -	do {
 -		/* NCM 3.2 */
 -		if (((ndp_index % 4) != 0) &&
 -				(ndp_index < opts->nth_size)) {
 -			INFO(port->func.config->cdev, "Bad index: %#X\n",
 -			     ndp_index);
 -			goto err;
 -		}
 +	/* walk through NDP */
 +	tmp = ((void *)skb->data) + index;
 +	if (get_unaligned_le32(tmp) != ncm->ndp_sign) {
 +		INFO(port->func.config->cdev, "Wrong NDP SIGN\n");
 +		goto err;
 +	}
 +	tmp += 2;
  
 -		/* walk through NDP */
 -		tmp = (void *)(skb->data + ndp_index);
 -		if (get_unaligned_le32(tmp) != ncm->ndp_sign) {
 -			INFO(port->func.config->cdev, "Wrong NDP SIGN\n");
 -			goto err;
 -		}
 -		tmp += 2;
 +	ndp_len = get_unaligned_le16(tmp++);
 +	/*
 +	 * NCM 3.3.1
 +	 * entry is 2 items
 +	 * item size is 16/32 bits, opts->dgram_item_len * 2 bytes
 +	 * minimal: struct usb_cdc_ncm_ndpX + normal entry + zero entry
 +	 */
 +	if ((ndp_len < opts->ndp_size + 2 * 2 * (opts->dgram_item_len * 2))
 +	    || (ndp_len % opts->ndplen_align != 0)) {
 +		INFO(port->func.config->cdev, "Bad NDP length: %x\n", ndp_len);
 +		goto err;
 +	}
 +	tmp += opts->reserved1;
 +	tmp += opts->next_fp_index; /* skip reserved (d)wNextFpIndex */
 +	tmp += opts->reserved2;
  
 -		ndp_len = get_unaligned_le16(tmp++);
 -		/*
 -		 * NCM 3.3.1
 -		 * entry is 2 items
 -		 * item size is 16/32 bits, opts->dgram_item_len * 2 bytes
 -		 * minimal: struct usb_cdc_ncm_ndpX + normal entry + zero entry
 -		 * Each entry is a dgram index and a dgram length.
 -		 */
 -		if ((ndp_len < opts->ndp_size
 -				+ 2 * 2 * (opts->dgram_item_len * 2))
 -				|| (ndp_len % opts->ndplen_align != 0)) {
 -			INFO(port->func.config->cdev, "Bad NDP length: %#X\n",
 -			     ndp_len);
 +	ndp_len -= opts->ndp_size;
 +	index2 = get_ncm(&tmp, opts->dgram_item_len);
 +	dg_len2 = get_ncm(&tmp, opts->dgram_item_len);
 +	dgram_counter = 0;
 +
 +	do {
 +		index = index2;
 +		dg_len = dg_len2;
 +		if (dg_len < 14 + crc_len) { /* ethernet header + crc */
 +			INFO(port->func.config->cdev, "Bad dgram length: %x\n",
 +			     dg_len);
  			goto err;
  		}
 -		tmp += opts->reserved1;
 -		/* Check for another NDP (d)wNextNdpIndex */
 -		ndp_index = get_ncm(&tmp, opts->next_ndp_index);
 -		tmp += opts->reserved2;
 -
 -		ndp_len -= opts->ndp_size;
 -		index2 = get_ncm(&tmp, opts->dgram_item_len);
 -		dg_len2 = get_ncm(&tmp, opts->dgram_item_len);
 -		dgram_counter = 0;
 -
 -		do {
 -			index = index2;
 -			dg_len = dg_len2;
 -			if (dg_len < 14 + crc_len) { /* ethernet hdr + crc */
 -				INFO(port->func.config->cdev,
 -				     "Bad dgram length: %#X\n", dg_len);
 +		if (ncm->is_crc) {
 +			uint32_t crc, crc2;
 +
 +			crc = get_unaligned_le32(skb->data +
 +						 index + dg_len - crc_len);
 +			crc2 = ~crc32_le(~0,
 +					 skb->data + index,
 +					 dg_len - crc_len);
 +			if (crc != crc2) {
 +				INFO(port->func.config->cdev, "Bad CRC\n");
  				goto err;
  			}
 -			if (ncm->is_crc) {
 -				uint32_t crc, crc2;
 -
 -				crc = get_unaligned_le32(skb->data +
 -							 index + dg_len -
 -							 crc_len);
 -				crc2 = ~crc32_le(~0,
 -						 skb->data + index,
 -						 dg_len - crc_len);
 -				if (crc != crc2) {
 -					INFO(port->func.config->cdev,
 -					     "Bad CRC\n");
 -					goto err;
 -				}
 -			}
 +		}
  
 -			index2 = get_ncm(&tmp, opts->dgram_item_len);
 -			dg_len2 = get_ncm(&tmp, opts->dgram_item_len);
 +		index2 = get_ncm(&tmp, opts->dgram_item_len);
 +		dg_len2 = get_ncm(&tmp, opts->dgram_item_len);
  
 -			/*
 -			 * Copy the data into a new skb.
 -			 * This ensures the truesize is correct
 -			 */
 -			skb2 = netdev_alloc_skb_ip_align(ncm->netdev,
 -							 dg_len - crc_len);
 +		if (index2 == 0 || dg_len2 == 0) {
 +			skb2 = skb;
 +		} else {
 +			skb2 = skb_clone(skb, GFP_ATOMIC);
  			if (skb2 == NULL)
  				goto err;
++<<<<<<< HEAD:drivers/usb/gadget/f_ncm.c
 +		}
++=======
+ 			skb_put_data(skb2, skb->data + index,
+ 				     dg_len - crc_len);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data()):drivers/usb/gadget/function/f_ncm.c
  
 -			skb_queue_tail(list, skb2);
 +		if (!skb_pull(skb2, index)) {
 +			ret = -EOVERFLOW;
 +			goto err;
 +		}
  
 -			ndp_len -= 2 * (opts->dgram_item_len * 2);
 +		skb_trim(skb2, dg_len - crc_len);
 +		skb_queue_tail(list, skb2);
  
 -			dgram_counter++;
 +		ndp_len -= 2 * (opts->dgram_item_len * 2);
  
 -			if (index2 == 0 || dg_len2 == 0)
 -				break;
 -		} while (ndp_len > 2 * (opts->dgram_item_len * 2));
 -	} while (ndp_index);
 +		dgram_counter++;
  
 -	dev_consume_skb_any(skb);
 +		if (index2 == 0 || dg_len2 == 0)
 +			break;
 +	} while (ndp_len > 2 * (opts->dgram_item_len * 2)); /* zero entry */
  
  	VDBG(port->func.config->cdev,
  	     "Parsed NTB with %d frames\n", dgram_counter);
diff --cc include/linux/skbuff.h
index dee52dfc1c40,5af5385a0e72..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -2009,16 -1923,8 +2009,21 @@@ static inline void *skb_put_data(struc
  	return tmp;
  }
  
++<<<<<<< HEAD
 +static inline void skb_put_u8(struct sk_buff *skb, u8 val)
 +{
 +	*(u8 *)skb_put(skb, 1) = val;
 +}
 +
 +RH_KABI_REPLACE_UNSAFE(
 +	unsigned char *skb_push(struct sk_buff *skb, unsigned int len),
 +	void *skb_push(struct sk_buff *skb, unsigned int len)
 +)
 +static inline void *__skb_push(struct sk_buff *skb, unsigned int len)
++=======
+ unsigned char *skb_push(struct sk_buff *skb, unsigned int len);
+ static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  {
  	skb->data -= len;
  	skb->len  += len;
diff --cc net/bluetooth/hci_sock.c
index 03a6c436b668,083e87f26a0f..000000000000
--- a/net/bluetooth/hci_sock.c
+++ b/net/bluetooth/hci_sock.c
@@@ -515,10 -515,10 +515,15 @@@ static struct sk_buff *create_monitor_c
  
  	put_unaligned_le32(hci_pi(sk)->cookie, skb_put(skb, 4));
  	put_unaligned_le16(format, skb_put(skb, 2));
- 	memcpy(skb_put(skb, sizeof(ver)), ver, sizeof(ver));
+ 	skb_put_data(skb, ver, sizeof(ver));
  	put_unaligned_le32(flags, skb_put(skb, 4));
++<<<<<<< HEAD
 +	*(u8 *)skb_put(skb, 1) = TASK_COMM_LEN;
 +	memcpy(skb_put(skb, TASK_COMM_LEN), hci_pi(sk)->comm, TASK_COMM_LEN);
++=======
+ 	*skb_put(skb, 1) = TASK_COMM_LEN;
+ 	skb_put_data(skb, hci_pi(sk)->comm, TASK_COMM_LEN);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  
  	__net_timestamp(skb);
  
diff --cc net/can/bcm.c
index a192e8509d71,47a8748d953a..000000000000
--- a/net/can/bcm.c
+++ b/net/can/bcm.c
@@@ -265,7 -282,7 +265,11 @@@ static void bcm_can_tx(struct bcm_op *o
  	can_skb_prv(skb)->ifindex = dev->ifindex;
  	can_skb_prv(skb)->skbcnt = 0;
  
++<<<<<<< HEAD
 +	memcpy(skb_put(skb, CFSIZ), cf, CFSIZ);
++=======
+ 	skb_put_data(skb, cf, op->cfsiz);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  
  	/* send with loopback */
  	skb->dev = dev;
@@@ -301,16 -318,16 +305,16 @@@ static void bcm_send_to_user(struct bcm
  	if (!skb)
  		return;
  
- 	memcpy(skb_put(skb, sizeof(*head)), head, sizeof(*head));
+ 	skb_put_data(skb, head, sizeof(*head));
  
  	if (head->nframes) {
 -		/* CAN frames starting here */
 -		firstframe = (struct canfd_frame *)skb_tail_pointer(skb);
 +		/* can_frames starting here */
 +		firstframe = (struct can_frame *)skb_tail_pointer(skb);
  
- 		memcpy(skb_put(skb, datalen), frames, datalen);
+ 		skb_put_data(skb, frames, datalen);
  
  		/*
 -		 * the BCM uses the flags-element of the canfd_frame
 +		 * the BCM uses the can_dlc-element of the can_frame
  		 * structure for internal purposes. This is only
  		 * relevant for updates that are generated by the
  		 * BCM, where nframes is 1
diff --cc net/mac80211/mlme.c
index 3b8e2709d8de,7be7917e1541..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -796,7 -796,8 +796,12 @@@ static void ieee80211_send_assoc(struc
  						 after_ric,
  						 ARRAY_SIZE(after_ric),
  						 offset);
++<<<<<<< HEAD
 +		skb_put_data(skb, assoc_data->ie + offset, noffset - offset);
++=======
+ 		pos = skb_put_data(skb, assoc_data->ie + offset,
+ 				   noffset - offset);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  		offset = noffset;
  	}
  
@@@ -833,7 -834,8 +838,12 @@@
  		noffset = ieee80211_ie_split(assoc_data->ie, assoc_data->ie_len,
  					     before_vht, ARRAY_SIZE(before_vht),
  					     offset);
++<<<<<<< HEAD
 +		skb_put_data(skb, assoc_data->ie + offset, noffset - offset);
++=======
+ 		pos = skb_put_data(skb, assoc_data->ie + offset,
+ 				   noffset - offset);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  		offset = noffset;
  	}
  
@@@ -846,7 -848,8 +856,12 @@@
  		noffset = ieee80211_ie_split_vendor(assoc_data->ie,
  						    assoc_data->ie_len,
  						    offset);
++<<<<<<< HEAD
 +		skb_put_data(skb, assoc_data->ie + offset, noffset - offset);
++=======
+ 		pos = skb_put_data(skb, assoc_data->ie + offset,
+ 				   noffset - offset);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  		offset = noffset;
  	}
  
@@@ -865,7 -868,8 +880,12 @@@
  	/* add any remaining custom (i.e. vendor specific here) IEs */
  	if (assoc_data->ie_len) {
  		noffset = assoc_data->ie_len;
++<<<<<<< HEAD
 +		skb_put_data(skb, assoc_data->ie + offset, noffset - offset);
++=======
+ 		pos = skb_put_data(skb, assoc_data->ie + offset,
+ 				   noffset - offset);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  	}
  
  	if (assoc_data->fils_kek_len &&
diff --cc net/mac80211/tdls.c
index 91093d4a2f84,86740670102d..000000000000
--- a/net/mac80211/tdls.c
+++ b/net/mac80211/tdls.c
@@@ -388,7 -388,7 +388,11 @@@ ieee80211_tdls_add_setup_start_ies(stru
  					     before_ext_cap,
  					     ARRAY_SIZE(before_ext_cap),
  					     offset);
++<<<<<<< HEAD
 +		skb_put_data(skb, extra_ies + offset, noffset - offset);
++=======
+ 		pos = skb_put_data(skb, extra_ies + offset, noffset - offset);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  		offset = noffset;
  	}
  
@@@ -417,7 -417,7 +421,11 @@@
  					     before_ht_cap,
  					     ARRAY_SIZE(before_ht_cap),
  					     offset);
++<<<<<<< HEAD
 +		skb_put_data(skb, extra_ies + offset, noffset - offset);
++=======
+ 		pos = skb_put_data(skb, extra_ies + offset, noffset - offset);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  		offset = noffset;
  	}
  
@@@ -488,7 -488,7 +496,11 @@@
  					     before_vht_cap,
  					     ARRAY_SIZE(before_vht_cap),
  					     offset);
++<<<<<<< HEAD
 +		skb_put_data(skb, extra_ies + offset, noffset - offset);
++=======
+ 		pos = skb_put_data(skb, extra_ies + offset, noffset - offset);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  		offset = noffset;
  	}
  
@@@ -529,7 -529,7 +541,11 @@@
  	/* add any remaining IEs */
  	if (extra_ies_len) {
  		noffset = extra_ies_len;
++<<<<<<< HEAD
 +		skb_put_data(skb, extra_ies + offset, noffset - offset);
++=======
+ 		pos = skb_put_data(skb, extra_ies + offset, noffset - offset);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  	}
  
  }
@@@ -571,7 -571,7 +587,11 @@@ ieee80211_tdls_add_setup_cfm_ies(struc
  					     before_qos,
  					     ARRAY_SIZE(before_qos),
  					     offset);
++<<<<<<< HEAD
 +		skb_put_data(skb, extra_ies + offset, noffset - offset);
++=======
+ 		pos = skb_put_data(skb, extra_ies + offset, noffset - offset);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  		offset = noffset;
  	}
  
@@@ -591,7 -591,7 +611,11 @@@
  					     before_ht_op,
  					     ARRAY_SIZE(before_ht_op),
  					     offset);
++<<<<<<< HEAD
 +		skb_put_data(skb, extra_ies + offset, noffset - offset);
++=======
+ 		pos = skb_put_data(skb, extra_ies + offset, noffset - offset);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  		offset = noffset;
  	}
  
@@@ -632,7 -632,7 +656,11 @@@
  	/* add any remaining IEs */
  	if (extra_ies_len) {
  		noffset = extra_ies_len;
++<<<<<<< HEAD
 +		skb_put_data(skb, extra_ies + offset, noffset - offset);
++=======
+ 		pos = skb_put_data(skb, extra_ies + offset, noffset - offset);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  	}
  }
  
@@@ -662,7 -663,7 +690,11 @@@ ieee80211_tdls_add_chan_switch_req_ies(
  					     before_lnkie,
  					     ARRAY_SIZE(before_lnkie),
  					     offset);
++<<<<<<< HEAD
 +		skb_put_data(skb, extra_ies + offset, noffset - offset);
++=======
+ 		pos = skb_put_data(skb, extra_ies + offset, noffset - offset);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  		offset = noffset;
  	}
  
@@@ -671,7 -672,7 +703,11 @@@
  	/* add any remaining IEs */
  	if (extra_ies_len) {
  		noffset = extra_ies_len;
++<<<<<<< HEAD
 +		skb_put_data(skb, extra_ies + offset, noffset - offset);
++=======
+ 		pos = skb_put_data(skb, extra_ies + offset, noffset - offset);
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  	}
  }
  
diff --cc net/netlink/af_netlink.c
index b5b7b952da74,bd24a975fd49..000000000000
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@@ -124,6 -156,24 +124,27 @@@ static inline u32 netlink_group_mask(u3
  	return group ? 1 << (group - 1) : 0;
  }
  
++<<<<<<< HEAD
++=======
+ static struct sk_buff *netlink_to_full_skb(const struct sk_buff *skb,
+ 					   gfp_t gfp_mask)
+ {
+ 	unsigned int len = skb_end_offset(skb);
+ 	struct sk_buff *new;
+ 
+ 	new = alloc_skb(len, gfp_mask);
+ 	if (new == NULL)
+ 		return NULL;
+ 
+ 	NETLINK_CB(new).portid = NETLINK_CB(skb).portid;
+ 	NETLINK_CB(new).dst_group = NETLINK_CB(skb).dst_group;
+ 	NETLINK_CB(new).creds = NETLINK_CB(skb).creds;
+ 
+ 	skb_put_data(new, skb->data, len);
+ 	return new;
+ }
+ 
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  int netlink_add_tap(struct netlink_tap *nt)
  {
  	if (unlikely(nt->dev->type != ARPHRD_NETLINK))
diff --cc net/nfc/nci/core.c
index 48ada0ec749e,17b9f1ce23db..000000000000
--- a/net/nfc/nci/core.c
+++ b/net/nfc/nci/core.c
@@@ -279,6 -346,137 +279,140 @@@ static void nci_rf_deactivate_req(struc
  		     sizeof(struct nci_rf_deactivate_cmd), &cmd);
  }
  
++<<<<<<< HEAD
++=======
+ struct nci_cmd_param {
+ 	__u16 opcode;
+ 	size_t len;
+ 	__u8 *payload;
+ };
+ 
+ static void nci_generic_req(struct nci_dev *ndev, unsigned long opt)
+ {
+ 	struct nci_cmd_param *param =
+ 		(struct nci_cmd_param *)opt;
+ 
+ 	nci_send_cmd(ndev, param->opcode, param->len, param->payload);
+ }
+ 
+ int nci_prop_cmd(struct nci_dev *ndev, __u8 oid, size_t len, __u8 *payload)
+ {
+ 	struct nci_cmd_param param;
+ 
+ 	param.opcode = nci_opcode_pack(NCI_GID_PROPRIETARY, oid);
+ 	param.len = len;
+ 	param.payload = payload;
+ 
+ 	return __nci_request(ndev, nci_generic_req, (unsigned long)&param,
+ 			     msecs_to_jiffies(NCI_CMD_TIMEOUT));
+ }
+ EXPORT_SYMBOL(nci_prop_cmd);
+ 
+ int nci_core_cmd(struct nci_dev *ndev, __u16 opcode, size_t len, __u8 *payload)
+ {
+ 	struct nci_cmd_param param;
+ 
+ 	param.opcode = opcode;
+ 	param.len = len;
+ 	param.payload = payload;
+ 
+ 	return __nci_request(ndev, nci_generic_req, (unsigned long)&param,
+ 			     msecs_to_jiffies(NCI_CMD_TIMEOUT));
+ }
+ EXPORT_SYMBOL(nci_core_cmd);
+ 
+ int nci_core_reset(struct nci_dev *ndev)
+ {
+ 	return __nci_request(ndev, nci_reset_req, 0,
+ 			     msecs_to_jiffies(NCI_RESET_TIMEOUT));
+ }
+ EXPORT_SYMBOL(nci_core_reset);
+ 
+ int nci_core_init(struct nci_dev *ndev)
+ {
+ 	return __nci_request(ndev, nci_init_req, 0,
+ 			     msecs_to_jiffies(NCI_INIT_TIMEOUT));
+ }
+ EXPORT_SYMBOL(nci_core_init);
+ 
+ struct nci_loopback_data {
+ 	u8 conn_id;
+ 	struct sk_buff *data;
+ };
+ 
+ static void nci_send_data_req(struct nci_dev *ndev, unsigned long opt)
+ {
+ 	struct nci_loopback_data *data = (struct nci_loopback_data *)opt;
+ 
+ 	nci_send_data(ndev, data->conn_id, data->data);
+ }
+ 
+ static void nci_nfcc_loopback_cb(void *context, struct sk_buff *skb, int err)
+ {
+ 	struct nci_dev *ndev = (struct nci_dev *)context;
+ 	struct nci_conn_info    *conn_info;
+ 
+ 	conn_info = nci_get_conn_info_by_conn_id(ndev, ndev->cur_conn_id);
+ 	if (!conn_info) {
+ 		nci_req_complete(ndev, NCI_STATUS_REJECTED);
+ 		return;
+ 	}
+ 
+ 	conn_info->rx_skb = skb;
+ 
+ 	nci_req_complete(ndev, NCI_STATUS_OK);
+ }
+ 
+ int nci_nfcc_loopback(struct nci_dev *ndev, void *data, size_t data_len,
+ 		      struct sk_buff **resp)
+ {
+ 	int r;
+ 	struct nci_loopback_data loopback_data;
+ 	struct nci_conn_info *conn_info;
+ 	struct sk_buff *skb;
+ 	int conn_id = nci_get_conn_info_by_dest_type_params(ndev,
+ 					NCI_DESTINATION_NFCC_LOOPBACK, NULL);
+ 
+ 	if (conn_id < 0) {
+ 		r = nci_core_conn_create(ndev, NCI_DESTINATION_NFCC_LOOPBACK,
+ 					 0, 0, NULL);
+ 		if (r != NCI_STATUS_OK)
+ 			return r;
+ 
+ 		conn_id = nci_get_conn_info_by_dest_type_params(ndev,
+ 					NCI_DESTINATION_NFCC_LOOPBACK,
+ 					NULL);
+ 	}
+ 
+ 	conn_info = nci_get_conn_info_by_conn_id(ndev, conn_id);
+ 	if (!conn_info)
+ 		return -EPROTO;
+ 
+ 	/* store cb and context to be used on receiving data */
+ 	conn_info->data_exchange_cb = nci_nfcc_loopback_cb;
+ 	conn_info->data_exchange_cb_context = ndev;
+ 
+ 	skb = nci_skb_alloc(ndev, NCI_DATA_HDR_SIZE + data_len, GFP_KERNEL);
+ 	if (!skb)
+ 		return -ENOMEM;
+ 
+ 	skb_reserve(skb, NCI_DATA_HDR_SIZE);
+ 	skb_put_data(skb, data, data_len);
+ 
+ 	loopback_data.conn_id = conn_id;
+ 	loopback_data.data = skb;
+ 
+ 	ndev->cur_conn_id = conn_id;
+ 	r = nci_request(ndev, nci_send_data_req, (unsigned long)&loopback_data,
+ 			msecs_to_jiffies(NCI_DATA_TIMEOUT));
+ 	if (r == NCI_STATUS_OK && resp)
+ 		*resp = conn_info->rx_skb;
+ 
+ 	return r;
+ }
+ EXPORT_SYMBOL(nci_nfcc_loopback);
+ 
++>>>>>>> 59ae1d127ac0 (networking: introduce and use skb_put_data())
  static int nci_open_device(struct nci_dev *ndev)
  {
  	int rc = 0;
@@@ -859,10 -1350,8 +993,10 @@@ int nci_send_cmd(struct nci_dev *ndev, 
  	nci_pbf_set((__u8 *)hdr, NCI_PBF_LAST);
  
  	if (plen)
- 		memcpy(skb_put(skb, plen), payload, plen);
+ 		skb_put_data(skb, payload, plen);
  
 +	skb->dev = (void *) ndev;
 +
  	skb_queue_tail(&ndev->cmd_q, skb);
  	queue_work(ndev->cmd_wq, &ndev->cmd_work);
  
* Unmerged path drivers/net/ethernet/aurora/nb8800.c
* Unmerged path drivers/net/ethernet/ec_bhf.c
* Unmerged path drivers/net/ieee802154/ca8210.c
* Unmerged path drivers/net/wireless/mediatek/mt7601u/dma.c
* Unmerged path drivers/net/wireless/mediatek/mt7601u/mcu.c
* Unmerged path drivers/net/wireless/quantenna/qtnfmac/pearl/pcie.c
* Unmerged path drivers/net/wireless/quantenna/qtnfmac/qlink_util.h
* Unmerged path drivers/net/wireless/rsi/rsi_91x_mgmt.c
* Unmerged path drivers/net/wireless/st/cw1200/scan.c
* Unmerged path drivers/nfc/fdp/fdp.c
* Unmerged path drivers/nfc/fdp/i2c.c
* Unmerged path drivers/nfc/nfcmrvl/fw_dnld.c
* Unmerged path drivers/nfc/nfcmrvl/i2c.c
* Unmerged path drivers/nfc/nfcmrvl/usb.c
* Unmerged path drivers/nfc/nxp-nci/firmware.c
* Unmerged path drivers/nfc/nxp-nci/i2c.c
* Unmerged path drivers/nfc/pn533/usb.c
* Unmerged path drivers/nfc/port100.c
* Unmerged path drivers/nfc/s3fwrn5/firmware.c
* Unmerged path drivers/nfc/s3fwrn5/i2c.c
* Unmerged path drivers/nfc/st21nfca/dep.c
* Unmerged path drivers/nfc/st21nfca/i2c.c
* Unmerged path drivers/rpmsg/rpmsg_char.c
* Unmerged path drivers/staging/gdm724x/gdm_lte.c
* Unmerged path drivers/staging/ks7010/ks_hostif.c
* Unmerged path drivers/staging/most/aim-network/networking.c
* Unmerged path drivers/staging/rtl8188eu/core/rtw_recv.c
* Unmerged path drivers/staging/rtl8188eu/os_dep/mon.c
* Unmerged path drivers/staging/rtl8723bs/os_dep/recv_linux.c
* Unmerged path drivers/staging/wilc1000/linux_mon.c
* Unmerged path drivers/staging/wilc1000/linux_wlan.c
* Unmerged path net/batman-adv/bat_v_ogm.c
* Unmerged path net/batman-adv/fragmentation.c
* Unmerged path net/nfc/digital_dep.c
* Unmerged path net/nfc/nci/hci.c
* Unmerged path net/nfc/nci/uart.c
* Unmerged path net/qrtr/qrtr.c
diff --git a/drivers/atm/fore200e.c b/drivers/atm/fore200e.c
index 204814e88e46..5dc7cece81fb 100644
--- a/drivers/atm/fore200e.c
+++ b/drivers/atm/fore200e.c
@@ -1103,7 +1103,7 @@ fore200e_push_rpd(struct fore200e* fore200e, struct atm_vcc* vcc, struct rpd* rp
 	/* Make device DMA transfer visible to CPU.  */
 	fore200e->bus->dma_sync_for_cpu(fore200e, buffer->data.dma_addr, rpd->rsd[ i ].length, DMA_FROM_DEVICE);
 	
-	memcpy(skb_put(skb, rpd->rsd[ i ].length), buffer->data.align_addr, rpd->rsd[ i ].length);
+	skb_put_data(skb, buffer->data.align_addr, rpd->rsd[i].length);
 
 	/* Now let the device get at it again.  */
 	fore200e->bus->dma_sync_for_device(fore200e, buffer->data.dma_addr, rpd->rsd[ i ].length, DMA_FROM_DEVICE);
diff --git a/drivers/atm/he.c b/drivers/atm/he.c
index 507362a76a73..ff90ca696725 100644
--- a/drivers/atm/he.c
+++ b/drivers/atm/he.c
@@ -1742,7 +1742,7 @@ he_service_rbrq(struct he_dev *he_dev, int group)
 		__net_timestamp(skb);
 
 		list_for_each_entry(heb, &he_vcc->buffers, entry)
-			memcpy(skb_put(skb, heb->len), &heb->data, heb->len);
+			skb_put_data(skb, &heb->data, heb->len);
 
 		switch (vcc->qos.aal) {
 			case ATM_AAL0:
diff --git a/drivers/atm/idt77252.c b/drivers/atm/idt77252.c
index 1bdf104e90bb..a5ff9ff1c321 100644
--- a/drivers/atm/idt77252.c
+++ b/drivers/atm/idt77252.c
@@ -1092,8 +1092,7 @@ dequeue_rx(struct idt77252_dev *card, struct rsq_entry *rsqe)
 
 			*((u32 *) sb->data) = aal0;
 			skb_put(sb, sizeof(u32));
-			memcpy(skb_put(sb, ATM_CELL_PAYLOAD),
-			       cell, ATM_CELL_PAYLOAD);
+			skb_put_data(sb, cell, ATM_CELL_PAYLOAD);
 
 			ATM_SKB(sb)->vcc = vcc;
 			__net_timestamp(sb);
@@ -1161,8 +1160,7 @@ dequeue_rx(struct idt77252_dev *card, struct rsq_entry *rsqe)
 				return;
 			}
 			skb_queue_walk(&rpp->queue, sb)
-				memcpy(skb_put(skb, sb->len),
-				       sb->data, sb->len);
+				skb_put_data(skb, sb->data, sb->len);
 
 			recycle_rx_pool_skb(card, rpp);
 
@@ -1324,8 +1322,7 @@ idt77252_rx_raw(struct idt77252_dev *card)
 
 		*((u32 *) sb->data) = header;
 		skb_put(sb, sizeof(u32));
-		memcpy(skb_put(sb, ATM_CELL_PAYLOAD), &(queue->data[16]),
-		       ATM_CELL_PAYLOAD);
+		skb_put_data(sb, &(queue->data[16]), ATM_CELL_PAYLOAD);
 
 		ATM_SKB(sb)->vcc = vcc;
 		__net_timestamp(sb);
@@ -2016,7 +2013,7 @@ idt77252_send_oam(struct atm_vcc *vcc, void *cell, int flags)
 	}
 	atomic_add(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc);
 
-	memcpy(skb_put(skb, 52), cell, 52);
+	skb_put_data(skb, cell, 52);
 
 	return idt77252_send_skb(vcc, skb, 1);
 }
diff --git a/drivers/atm/solos-pci.c b/drivers/atm/solos-pci.c
index 32784d18d1f7..8ea180fb4781 100644
--- a/drivers/atm/solos-pci.c
+++ b/drivers/atm/solos-pci.c
@@ -487,7 +487,7 @@ static int send_command(struct solos_card *card, int dev, const char *buf, size_
 	header->vci = cpu_to_le16(0);
 	header->type = cpu_to_le16(PKT_COMMAND);
 
-	memcpy(skb_put(skb, size), buf, size);
+	skb_put_data(skb, buf, size);
 
 	fpga_queue(card, dev, skb, NULL);
 
diff --git a/drivers/bluetooth/bfusb.c b/drivers/bluetooth/bfusb.c
index 3bf4ec60e073..ab090a313a5f 100644
--- a/drivers/bluetooth/bfusb.c
+++ b/drivers/bluetooth/bfusb.c
@@ -335,7 +335,7 @@ static inline int bfusb_recv_block(struct bfusb_data *data, int hdr, unsigned ch
 	}
 
 	if (len > 0)
-		memcpy(skb_put(data->reassembly, len), buf, len);
+		skb_put_data(data->reassembly, buf, len);
 
 	if (hdr & 0x08) {
 		hci_recv_frame(data->hdev, data->reassembly);
@@ -505,7 +505,7 @@ static int bfusb_send_frame(struct hci_dev *hdev, struct sk_buff *skb)
 		buf[1] = 0x00;
 		buf[2] = (size == BFUSB_MAX_BLOCK_SIZE) ? 0 : size;
 
-		memcpy(skb_put(nskb, 3), buf, 3);
+		skb_put_data(nskb, buf, 3);
 		skb_copy_from_linear_data_offset(skb, sent, skb_put(nskb, size), size);
 
 		sent  += size;
@@ -516,7 +516,7 @@ static int bfusb_send_frame(struct hci_dev *hdev, struct sk_buff *skb)
 	if ((nskb->len % data->bulk_pkt_size) == 0) {
 		buf[0] = 0xdd;
 		buf[1] = 0x00;
-		memcpy(skb_put(nskb, 2), buf, 2);
+		skb_put_data(nskb, buf, 2);
 	}
 
 	read_lock(&data->lock);
diff --git a/drivers/bluetooth/bluecard_cs.c b/drivers/bluetooth/bluecard_cs.c
index 007c0a45f31b..1d30c116b2ee 100644
--- a/drivers/bluetooth/bluecard_cs.c
+++ b/drivers/bluetooth/bluecard_cs.c
@@ -597,7 +597,7 @@ static int bluecard_hci_set_baud_rate(struct hci_dev *hdev, int baud)
 		break;
 	}
 
-	memcpy(skb_put(skb, sizeof(cmd)), cmd, sizeof(cmd));
+	skb_put_data(skb, cmd, sizeof(cmd));
 
 	skb_queue_tail(&(info->txq), skb);
 
diff --git a/drivers/bluetooth/btmrvl_main.c b/drivers/bluetooth/btmrvl_main.c
index c38cb5b91291..24a188eab360 100644
--- a/drivers/bluetooth/btmrvl_main.c
+++ b/drivers/bluetooth/btmrvl_main.c
@@ -194,7 +194,7 @@ static int btmrvl_send_sync_cmd(struct btmrvl_private *priv, u16 opcode,
 	hdr->plen = len;
 
 	if (len)
-		memcpy(skb_put(skb, len), param, len);
+		skb_put_data(skb, param, len);
 
 	hci_skb_pkt_type(skb) = MRVL_VENDOR_PKT;
 
diff --git a/drivers/bluetooth/btqcomsmd.c b/drivers/bluetooth/btqcomsmd.c
index 8d4868af9bbd..73a1a5508dc4 100644
--- a/drivers/bluetooth/btqcomsmd.c
+++ b/drivers/bluetooth/btqcomsmd.c
@@ -43,7 +43,7 @@ static int btqcomsmd_recv(struct hci_dev *hdev, unsigned int type,
 	}
 
 	hci_skb_pkt_type(skb) = type;
-	memcpy(skb_put(skb, count), data, count);
+	skb_put_data(skb, data, count);
 
 	return hci_recv_frame(hdev, skb);
 }
* Unmerged path drivers/bluetooth/btusb.c
diff --git a/drivers/bluetooth/hci_bcsp.c b/drivers/bluetooth/hci_bcsp.c
index 910ec968f022..d880f4e33c75 100644
--- a/drivers/bluetooth/hci_bcsp.c
+++ b/drivers/bluetooth/hci_bcsp.c
@@ -125,7 +125,7 @@ static void bcsp_slip_msgdelim(struct sk_buff *skb)
 {
 	const char pkt_delim = 0xc0;
 
-	memcpy(skb_put(skb, 1), &pkt_delim, 1);
+	skb_put_data(skb, &pkt_delim, 1);
 }
 
 static void bcsp_slip_one_byte(struct sk_buff *skb, u8 c)
@@ -135,13 +135,13 @@ static void bcsp_slip_one_byte(struct sk_buff *skb, u8 c)
 
 	switch (c) {
 	case 0xc0:
-		memcpy(skb_put(skb, 2), &esc_c0, 2);
+		skb_put_data(skb, &esc_c0, 2);
 		break;
 	case 0xdb:
-		memcpy(skb_put(skb, 2), &esc_db, 2);
+		skb_put_data(skb, &esc_db, 2);
 		break;
 	default:
-		memcpy(skb_put(skb, 1), &c, 1);
+		skb_put_data(skb, &c, 1);
 	}
 }
 
@@ -423,7 +423,7 @@ static void bcsp_handle_le_pkt(struct hci_uart *hu)
 		BT_DBG("Found a LE conf pkt");
 		if (!nskb)
 			return;
-		memcpy(skb_put(nskb, 4), conf_rsp_pkt, 4);
+		skb_put_data(nskb, conf_rsp_pkt, 4);
 		hci_skb_pkt_type(nskb) = BCSP_LE_PKT;
 
 		skb_queue_head(&bcsp->unrel, nskb);
@@ -447,7 +447,7 @@ static inline void bcsp_unslip_one_byte(struct bcsp_struct *bcsp, unsigned char
 			bcsp->rx_esc_state = BCSP_ESCSTATE_ESC;
 			break;
 		default:
-			memcpy(skb_put(bcsp->rx_skb, 1), &byte, 1);
+			skb_put_data(bcsp->rx_skb, &byte, 1);
 			if ((bcsp->rx_skb->data[0] & 0x40) != 0 &&
 			    bcsp->rx_state != BCSP_W4_CRC)
 				bcsp_crc_update(&bcsp->message_crc, byte);
@@ -458,7 +458,7 @@ static inline void bcsp_unslip_one_byte(struct bcsp_struct *bcsp, unsigned char
 	case BCSP_ESCSTATE_ESC:
 		switch (byte) {
 		case 0xdc:
-			memcpy(skb_put(bcsp->rx_skb, 1), &c0, 1);
+			skb_put_data(bcsp->rx_skb, &c0, 1);
 			if ((bcsp->rx_skb->data[0] & 0x40) != 0 &&
 			    bcsp->rx_state != BCSP_W4_CRC)
 				bcsp_crc_update(&bcsp->message_crc, 0xc0);
@@ -467,7 +467,7 @@ static inline void bcsp_unslip_one_byte(struct bcsp_struct *bcsp, unsigned char
 			break;
 
 		case 0xdd:
-			memcpy(skb_put(bcsp->rx_skb, 1), &db, 1);
+			skb_put_data(bcsp->rx_skb, &db, 1);
 			if ((bcsp->rx_skb->data[0] & 0x40) != 0 &&
 			    bcsp->rx_state != BCSP_W4_CRC)
 				bcsp_crc_update(&bcsp->message_crc, 0xdb);
diff --git a/drivers/bluetooth/hci_h4.c b/drivers/bluetooth/hci_h4.c
index 82e5a32b87a4..4e328d7d47bb 100644
--- a/drivers/bluetooth/hci_h4.c
+++ b/drivers/bluetooth/hci_h4.c
@@ -209,7 +209,7 @@ struct sk_buff *h4_recv_buf(struct hci_dev *hdev, struct sk_buff *skb,
 		}
 
 		len = min_t(uint, hci_skb_expect(skb) - skb->len, count);
-		memcpy(skb_put(skb, len), buffer, len);
+		skb_put_data(skb, buffer, len);
 
 		count -= len;
 		buffer += len;
diff --git a/drivers/bluetooth/hci_h5.c b/drivers/bluetooth/hci_h5.c
index 90d0456b6744..c0e4e26dc30d 100644
--- a/drivers/bluetooth/hci_h5.c
+++ b/drivers/bluetooth/hci_h5.c
@@ -109,7 +109,7 @@ static void h5_link_control(struct hci_uart *hu, const void *data, size_t len)
 
 	hci_skb_pkt_type(nskb) = HCI_3WIRE_LINK_PKT;
 
-	memcpy(skb_put(nskb, len), data, len);
+	skb_put_data(nskb, data, len);
 
 	skb_queue_tail(&h5->unrel, nskb);
 }
@@ -487,7 +487,7 @@ static void h5_unslip_one_byte(struct h5 *h5, unsigned char c)
 		}
 	}
 
-	memcpy(skb_put(h5->rx_skb, 1), byte, 1);
+	skb_put_data(h5->rx_skb, byte, 1);
 	h5->rx_pending--;
 
 	BT_DBG("unsliped 0x%02hhx, rx_pending %zu", *byte, h5->rx_pending);
@@ -579,7 +579,7 @@ static void h5_slip_delim(struct sk_buff *skb)
 {
 	const char delim = SLIP_DELIMITER;
 
-	memcpy(skb_put(skb, 1), &delim, 1);
+	skb_put_data(skb, &delim, 1);
 }
 
 static void h5_slip_one_byte(struct sk_buff *skb, u8 c)
@@ -589,13 +589,13 @@ static void h5_slip_one_byte(struct sk_buff *skb, u8 c)
 
 	switch (c) {
 	case SLIP_DELIMITER:
-		memcpy(skb_put(skb, 2), &esc_delim, 2);
+		skb_put_data(skb, &esc_delim, 2);
 		break;
 	case SLIP_ESC:
-		memcpy(skb_put(skb, 2), &esc_esc, 2);
+		skb_put_data(skb, &esc_esc, 2);
 		break;
 	default:
-		memcpy(skb_put(skb, 1), &c, 1);
+		skb_put_data(skb, &c, 1);
 	}
 }
 
diff --git a/drivers/bluetooth/hci_intel.c b/drivers/bluetooth/hci_intel.c
index fa5099986f1b..54f7b2518807 100644
--- a/drivers/bluetooth/hci_intel.c
+++ b/drivers/bluetooth/hci_intel.c
@@ -185,7 +185,7 @@ static int intel_lpm_suspend(struct hci_uart *hu)
 		return -ENOMEM;
 	}
 
-	memcpy(skb_put(skb, sizeof(suspend)), suspend, sizeof(suspend));
+	skb_put_data(skb, suspend, sizeof(suspend));
 	hci_skb_pkt_type(skb) = HCI_LPM_PKT;
 
 	set_bit(STATE_LPM_TRANSACTION, &intel->flags);
@@ -270,8 +270,7 @@ static int intel_lpm_host_wake(struct hci_uart *hu)
 		return -ENOMEM;
 	}
 
-	memcpy(skb_put(skb, sizeof(lpm_resume_ack)), lpm_resume_ack,
-	       sizeof(lpm_resume_ack));
+	skb_put_data(skb, lpm_resume_ack, sizeof(lpm_resume_ack));
 	hci_skb_pkt_type(skb) = HCI_LPM_PKT;
 
 	/* LPM flow is a priority, enqueue packet at list head */
@@ -522,7 +521,7 @@ static int intel_set_baudrate(struct hci_uart *hu, unsigned int speed)
 		return -ENOMEM;
 	}
 
-	memcpy(skb_put(skb, sizeof(speed_cmd)), speed_cmd, sizeof(speed_cmd));
+	skb_put_data(skb, speed_cmd, sizeof(speed_cmd));
 	hci_skb_pkt_type(skb) = HCI_COMMAND_PKT;
 
 	hci_uart_set_flow_control(hu, true);
diff --git a/drivers/bluetooth/hci_ll.c b/drivers/bluetooth/hci_ll.c
index 02692fe30279..50e08369fbfc 100644
--- a/drivers/bluetooth/hci_ll.c
+++ b/drivers/bluetooth/hci_ll.c
@@ -385,7 +385,7 @@ static int ll_recv(struct hci_uart *hu, const void *data, int count)
 	while (count) {
 		if (ll->rx_count) {
 			len = min_t(unsigned int, ll->rx_count, count);
-			memcpy(skb_put(ll->rx_skb, len), ptr, len);
+			skb_put_data(ll->rx_skb, ptr, len);
 			ll->rx_count -= len; count -= len; ptr += len;
 
 			if (ll->rx_count)
diff --git a/drivers/bluetooth/hci_mrvl.c b/drivers/bluetooth/hci_mrvl.c
index bbc4b39b1dbf..ffb00669346f 100644
--- a/drivers/bluetooth/hci_mrvl.c
+++ b/drivers/bluetooth/hci_mrvl.c
@@ -328,7 +328,7 @@ static int mrvl_load_firmware(struct hci_dev *hdev, const char *name)
 		}
 		bt_cb(skb)->pkt_type = MRVL_RAW_DATA;
 
-		memcpy(skb_put(skb, mrvl->tx_len), fw_ptr, mrvl->tx_len);
+		skb_put_data(skb, fw_ptr, mrvl->tx_len);
 		fw_ptr += mrvl->tx_len;
 
 		set_bit(STATE_FW_REQ_PENDING, &mrvl->flags);
diff --git a/drivers/bluetooth/hci_qca.c b/drivers/bluetooth/hci_qca.c
index 3d5afe150112..e462fb12d7dd 100644
--- a/drivers/bluetooth/hci_qca.c
+++ b/drivers/bluetooth/hci_qca.c
@@ -869,7 +869,7 @@ static int qca_set_baudrate(struct hci_dev *hdev, uint8_t baudrate)
 	}
 
 	/* Assign commands to change baudrate and packet type. */
-	memcpy(skb_put(skb, sizeof(cmd)), cmd, sizeof(cmd));
+	skb_put_data(skb, cmd, sizeof(cmd));
 	hci_skb_pkt_type(skb) = HCI_COMMAND_PKT;
 
 	skb_queue_tail(&qca->txq, skb);
diff --git a/drivers/char/pcmcia/synclink_cs.c b/drivers/char/pcmcia/synclink_cs.c
index 13c2b5e263e3..b26b7eb03cfa 100644
--- a/drivers/char/pcmcia/synclink_cs.c
+++ b/drivers/char/pcmcia/synclink_cs.c
@@ -4249,7 +4249,7 @@ static void hdlcdev_rx(MGSLPC_INFO *info, char *buf, int size)
 		return;
 	}
 
-	memcpy(skb_put(skb, size), buf, size);
+	skb_put_data(skb, buf, size);
 
 	skb->protocol = hdlc_type_trans(skb, dev);
 
diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 9dd4573c4f95..33d0a8c01788 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -613,7 +613,7 @@ static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 			return -ENOMEM;
 		}
 		skb_reserve(skb, LL_RESERVED_SPACE(net));
-		memcpy(skb_put(skb, len), buf, len);
+		skb_put_data(skb, buf, len);
 
 		return fwnet_finish_incoming_packet(net, skb, source_node_id,
 						    is_broadcast, ether_type);
diff --git a/drivers/isdn/capi/capi.c b/drivers/isdn/capi/capi.c
index 7ebdd9466f94..214454cf50a1 100644
--- a/drivers/isdn/capi/capi.c
+++ b/drivers/isdn/capi/capi.c
@@ -1058,7 +1058,7 @@ static int capinc_tty_write(struct tty_struct *tty,
 	}
 
 	skb_reserve(skb, CAPI_DATA_B3_REQ_LEN);
-	memcpy(skb_put(skb, count), buf, count);
+	skb_put_data(skb, buf, count);
 
 	__skb_queue_tail(&mp->outqueue, skb);
 	mp->outbytes += skb->len;
diff --git a/drivers/isdn/capi/capidrv.c b/drivers/isdn/capi/capidrv.c
index cc9f1927a322..360a47bfbd2b 100644
--- a/drivers/isdn/capi/capidrv.c
+++ b/drivers/isdn/capi/capidrv.c
@@ -513,7 +513,7 @@ static void send_message(capidrv_contr *card, _cmsg *cmsg)
 		printk(KERN_ERR "capidrv::send_message: can't allocate mem\n");
 		return;
 	}
-	memcpy(skb_put(skb, len), cmsg->buf, len);
+	skb_put_data(skb, cmsg->buf, len);
 	if (capi20_put_message(&global.ap, skb) != CAPI_NOERROR)
 		kfree_skb(skb);
 }
diff --git a/drivers/isdn/hardware/avm/b1.c b/drivers/isdn/hardware/avm/b1.c
index 4d9b195547c5..d8dfdea890b7 100644
--- a/drivers/isdn/hardware/avm/b1.c
+++ b/drivers/isdn/hardware/avm/b1.c
@@ -529,8 +529,8 @@ irqreturn_t b1_interrupt(int interrupt, void *devptr)
 			printk(KERN_ERR "%s: incoming packet dropped\n",
 			       card->name);
 		} else {
-			memcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);
-			memcpy(skb_put(skb, DataB3Len), card->databuf, DataB3Len);
+			skb_put_data(skb, card->msgbuf, MsgLen);
+			skb_put_data(skb, card->databuf, DataB3Len);
 			capi_ctr_handle_message(ctrl, ApplId, skb);
 		}
 		break;
@@ -544,7 +544,7 @@ irqreturn_t b1_interrupt(int interrupt, void *devptr)
 			       card->name);
 			spin_unlock_irqrestore(&card->lock, flags);
 		} else {
-			memcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);
+			skb_put_data(skb, card->msgbuf, MsgLen);
 			if (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3_CONF)
 				capilib_data_b3_conf(&cinfo->ncci_head, ApplId,
 						     CAPIMSG_NCCI(skb->data),
diff --git a/drivers/isdn/hardware/avm/b1dma.c b/drivers/isdn/hardware/avm/b1dma.c
index 19b113faeb7b..5bc8a1119372 100644
--- a/drivers/isdn/hardware/avm/b1dma.c
+++ b/drivers/isdn/hardware/avm/b1dma.c
@@ -474,8 +474,8 @@ static void b1dma_handle_rx(avmcard *card)
 			printk(KERN_ERR "%s: incoming packet dropped\n",
 			       card->name);
 		} else {
-			memcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);
-			memcpy(skb_put(skb, DataB3Len), card->databuf, DataB3Len);
+			skb_put_data(skb, card->msgbuf, MsgLen);
+			skb_put_data(skb, card->databuf, DataB3Len);
 			capi_ctr_handle_message(ctrl, ApplId, skb);
 		}
 		break;
@@ -488,7 +488,7 @@ static void b1dma_handle_rx(avmcard *card)
 			printk(KERN_ERR "%s: incoming packet dropped\n",
 			       card->name);
 		} else {
-			memcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);
+			skb_put_data(skb, card->msgbuf, MsgLen);
 			if (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3_CONF) {
 				spin_lock(&card->lock);
 				capilib_data_b3_conf(&cinfo->ncci_head, ApplId,
diff --git a/drivers/isdn/hardware/avm/c4.c b/drivers/isdn/hardware/avm/c4.c
index 5d00d72fe482..a368c6a56084 100644
--- a/drivers/isdn/hardware/avm/c4.c
+++ b/drivers/isdn/hardware/avm/c4.c
@@ -536,8 +536,8 @@ static void c4_handle_rx(avmcard *card)
 			printk(KERN_ERR "%s: incoming packet dropped\n",
 			       card->name);
 		} else {
-			memcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);
-			memcpy(skb_put(skb, DataB3Len), card->databuf, DataB3Len);
+			skb_put_data(skb, card->msgbuf, MsgLen);
+			skb_put_data(skb, card->databuf, DataB3Len);
 			capi_ctr_handle_message(ctrl, ApplId, skb);
 		}
 		break;
@@ -555,7 +555,7 @@ static void c4_handle_rx(avmcard *card)
 			printk(KERN_ERR "%s: incoming packet dropped\n",
 			       card->name);
 		} else {
-			memcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);
+			skb_put_data(skb, card->msgbuf, MsgLen);
 			if (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3_CONF)
 				capilib_data_b3_conf(&cinfo->ncci_head, ApplId,
 						     CAPIMSG_NCCI(skb->data),
diff --git a/drivers/isdn/hardware/avm/t1isa.c b/drivers/isdn/hardware/avm/t1isa.c
index 72ef18853951..e70cd741df07 100644
--- a/drivers/isdn/hardware/avm/t1isa.c
+++ b/drivers/isdn/hardware/avm/t1isa.c
@@ -171,8 +171,8 @@ static irqreturn_t t1isa_interrupt(int interrupt, void *devptr)
 				printk(KERN_ERR "%s: incoming packet dropped\n",
 				       card->name);
 			} else {
-				memcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);
-				memcpy(skb_put(skb, DataB3Len), card->databuf, DataB3Len);
+				skb_put_data(skb, card->msgbuf, MsgLen);
+				skb_put_data(skb, card->databuf, DataB3Len);
 				capi_ctr_handle_message(ctrl, ApplId, skb);
 			}
 			break;
@@ -186,7 +186,7 @@ static irqreturn_t t1isa_interrupt(int interrupt, void *devptr)
 				printk(KERN_ERR "%s: incoming packet dropped\n",
 				       card->name);
 			} else {
-				memcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);
+				skb_put_data(skb, card->msgbuf, MsgLen);
 				if (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3)
 					capilib_data_b3_conf(&cinfo->ncci_head, ApplId,
 							     CAPIMSG_NCCI(skb->data),
diff --git a/drivers/isdn/hardware/mISDN/hfcmulti.c b/drivers/isdn/hardware/mISDN/hfcmulti.c
index 28543d795188..a48128df34c3 100644
--- a/drivers/isdn/hardware/mISDN/hfcmulti.c
+++ b/drivers/isdn/hardware/mISDN/hfcmulti.c
@@ -1926,7 +1926,7 @@ hfcmulti_dtmf(struct hfc_multi *hc)
 			hh = mISDN_HEAD_P(skb);
 			hh->prim = PH_CONTROL_IND;
 			hh->id = DTMF_HFC_COEF;
-			memcpy(skb_put(skb, 512), hc->chan[ch].coeff, 512);
+			skb_put_data(skb, hc->chan[ch].coeff, 512);
 			recv_Bchannel_skb(bch, skb);
 		}
 	}
@@ -2332,8 +2332,7 @@ next_frame:
 				skb = *sp;
 				*sp = mI_alloc_skb(skb->len, GFP_ATOMIC);
 				if (*sp) {
-					memcpy(skb_put(*sp, skb->len),
-					       skb->data, skb->len);
+					skb_put_data(*sp, skb->data, skb->len);
 					skb_trim(skb, 0);
 				} else {
 					printk(KERN_DEBUG "%s: No mem\n",
diff --git a/drivers/isdn/hardware/mISDN/hfcsusb.c b/drivers/isdn/hardware/mISDN/hfcsusb.c
index 114f3bcba1b0..17cc879ad2bb 100644
--- a/drivers/isdn/hardware/mISDN/hfcsusb.c
+++ b/drivers/isdn/hardware/mISDN/hfcsusb.c
@@ -893,7 +893,7 @@ hfcsusb_rx_frame(struct usb_fifo *fifo, __u8 *data, unsigned int len,
 		}
 	}
 
-	memcpy(skb_put(rx_skb, len), data, len);
+	skb_put_data(rx_skb, data, len);
 
 	if (hdlc) {
 		/* we have a complete hdlc packet */
diff --git a/drivers/isdn/hisax/amd7930_fn.c b/drivers/isdn/hisax/amd7930_fn.c
index 1063babe1d3a..1d35b8e571ef 100644
--- a/drivers/isdn/hisax/amd7930_fn.c
+++ b/drivers/isdn/hisax/amd7930_fn.c
@@ -317,7 +317,8 @@ Amd7930_empty_Dfifo(struct IsdnCardState *cs, int flag)
 							debugl1(cs, cs->dlog);
 						}
 						/* moves received data in sk-buffer */
-						memcpy(skb_put(skb, cs->rcvidx), cs->rcvbuf, cs->rcvidx);
+						skb_put_data(skb, cs->rcvbuf,
+							     cs->rcvidx);
 						skb_queue_tail(&cs->rq, skb);
 					}
 				}
diff --git a/drivers/isdn/hisax/avm_pci.c b/drivers/isdn/hisax/avm_pci.c
index ee9b9a03cffa..c760236a59a4 100644
--- a/drivers/isdn/hisax/avm_pci.c
+++ b/drivers/isdn/hisax/avm_pci.c
@@ -378,8 +378,9 @@ HDLC_irq(struct BCState *bcs, u_int stat) {
 					if (!(skb = dev_alloc_skb(bcs->hw.hdlc.rcvidx)))
 						printk(KERN_WARNING "HDLC: receive out of memory\n");
 					else {
-						memcpy(skb_put(skb, bcs->hw.hdlc.rcvidx),
-						       bcs->hw.hdlc.rcvbuf, bcs->hw.hdlc.rcvidx);
+						skb_put_data(skb,
+							     bcs->hw.hdlc.rcvbuf,
+							     bcs->hw.hdlc.rcvidx);
 						skb_queue_tail(&bcs->rqueue, skb);
 					}
 					bcs->hw.hdlc.rcvidx = 0;
diff --git a/drivers/isdn/hisax/diva.c b/drivers/isdn/hisax/diva.c
index 8d0cf6e4dc00..0cace548c683 100644
--- a/drivers/isdn/hisax/diva.c
+++ b/drivers/isdn/hisax/diva.c
@@ -511,7 +511,8 @@ Memhscx_interrupt(struct IsdnCardState *cs, u_char val, u_char hscx)
 				if (!(skb = dev_alloc_skb(count)))
 					printk(KERN_WARNING "HSCX: receive out of memory\n");
 				else {
-					memcpy(skb_put(skb, count), bcs->hw.hscx.rcvbuf, count);
+					skb_put_data(skb, bcs->hw.hscx.rcvbuf,
+						     count);
 					skb_queue_tail(&bcs->rqueue, skb);
 				}
 			}
@@ -526,7 +527,8 @@ Memhscx_interrupt(struct IsdnCardState *cs, u_char val, u_char hscx)
 			if (!(skb = dev_alloc_skb(fifo_size)))
 				printk(KERN_WARNING "HiSax: receive out of memory\n");
 			else {
-				memcpy(skb_put(skb, fifo_size), bcs->hw.hscx.rcvbuf, fifo_size);
+				skb_put_data(skb, bcs->hw.hscx.rcvbuf,
+					     fifo_size);
 				skb_queue_tail(&bcs->rqueue, skb);
 			}
 			bcs->hw.hscx.rcvidx = 0;
diff --git a/drivers/isdn/hisax/elsa_ser.c b/drivers/isdn/hisax/elsa_ser.c
index d4c98d330bfe..d46aa67fed0d 100644
--- a/drivers/isdn/hisax/elsa_ser.c
+++ b/drivers/isdn/hisax/elsa_ser.c
@@ -333,8 +333,8 @@ static inline void receive_chars(struct IsdnCardState *cs,
 		if (!(skb = dev_alloc_skb(cs->hw.elsa.rcvcnt)))
 			printk(KERN_WARNING "ElsaSER: receive out of memory\n");
 		else {
-			memcpy(skb_put(skb, cs->hw.elsa.rcvcnt), cs->hw.elsa.rcvbuf,
-			       cs->hw.elsa.rcvcnt);
+			skb_put_data(skb, cs->hw.elsa.rcvbuf,
+				     cs->hw.elsa.rcvcnt);
 			skb_queue_tail(&cs->hw.elsa.bcs->rqueue, skb);
 		}
 		schedule_event(cs->hw.elsa.bcs, B_RCVBUFREADY);
diff --git a/drivers/isdn/hisax/hfc_usb.c b/drivers/isdn/hisax/hfc_usb.c
index 849a80752685..33fae51795a6 100644
--- a/drivers/isdn/hisax/hfc_usb.c
+++ b/drivers/isdn/hisax/hfc_usb.c
@@ -799,7 +799,7 @@ collect_rx_frame(usb_fifo *fifo, __u8 *data, int len, int finish)
 	}
 	if (len) {
 		if (fifo->skbuff->len + len < fifo->max_size) {
-			memcpy(skb_put(fifo->skbuff, len), data, len);
+			skb_put_data(fifo->skbuff, data, len);
 		} else {
 			DBG(HFCUSB_DBG_FIFO_ERR,
 			    "HCF-USB: got frame exceeded fifo->max_size(%d) fifo(%d)",
diff --git a/drivers/isdn/hisax/hisax_fcpcipnp.c b/drivers/isdn/hisax/hisax_fcpcipnp.c
index 5e8a5d967162..5a9f39ed1d5d 100644
--- a/drivers/isdn/hisax/hisax_fcpcipnp.c
+++ b/drivers/isdn/hisax/hisax_fcpcipnp.c
@@ -495,8 +495,7 @@ static inline void hdlc_rpr_irq(struct fritz_bcs *bcs, u32 stat)
 			if (!skb) {
 				printk(KERN_WARNING "HDLC: receive out of memory\n");
 			} else {
-				memcpy(skb_put(skb, bcs->rcvidx), bcs->rcvbuf,
-				       bcs->rcvidx);
+				skb_put_data(skb, bcs->rcvbuf, bcs->rcvidx);
 				DBG_SKB(1, skb);
 				B_L1L2(bcs, PH_DATA | INDICATION, skb);
 			}
diff --git a/drivers/isdn/hisax/hisax_isac.c b/drivers/isdn/hisax/hisax_isac.c
index 5154c252a25f..0f36375478c5 100644
--- a/drivers/isdn/hisax/hisax_isac.c
+++ b/drivers/isdn/hisax/hisax_isac.c
@@ -557,7 +557,7 @@ static inline void isac_rme_interrupt(struct isac *isac)
 		DBG(DBG_WARN, "no memory, dropping\n");
 		goto out;
 	}
-	memcpy(skb_put(skb, count), isac->rcvbuf, count);
+	skb_put_data(skb, isac->rcvbuf, count);
 	DBG_SKB(DBG_RPACKET, skb);
 	D_L1L2(isac, PH_DATA | INDICATION, skb);
 out:
@@ -687,7 +687,7 @@ static inline void isacsx_rme_interrupt(struct isac *isac)
 		DBG(DBG_WARN, "no memory, dropping");
 		goto out;
 	}
-	memcpy(skb_put(skb, count), isac->rcvbuf, count);
+	skb_put_data(skb, isac->rcvbuf, count);
 	DBG_SKB(DBG_RPACKET, skb);
 	D_L1L2(isac, PH_DATA | INDICATION, skb);
 out:
diff --git a/drivers/isdn/hisax/hscx_irq.c b/drivers/isdn/hisax/hscx_irq.c
index f398d4838937..3ace62239f1e 100644
--- a/drivers/isdn/hisax/hscx_irq.c
+++ b/drivers/isdn/hisax/hscx_irq.c
@@ -169,7 +169,8 @@ hscx_interrupt(struct IsdnCardState *cs, u_char val, u_char hscx)
 				if (!(skb = dev_alloc_skb(count)))
 					printk(KERN_WARNING "HSCX: receive out of memory\n");
 				else {
-					memcpy(skb_put(skb, count), bcs->hw.hscx.rcvbuf, count);
+					skb_put_data(skb, bcs->hw.hscx.rcvbuf,
+						     count);
 					skb_queue_tail(&bcs->rqueue, skb);
 				}
 			}
@@ -184,7 +185,8 @@ hscx_interrupt(struct IsdnCardState *cs, u_char val, u_char hscx)
 			if (!(skb = dev_alloc_skb(fifo_size)))
 				printk(KERN_WARNING "HiSax: receive out of memory\n");
 			else {
-				memcpy(skb_put(skb, fifo_size), bcs->hw.hscx.rcvbuf, fifo_size);
+				skb_put_data(skb, bcs->hw.hscx.rcvbuf,
+					     fifo_size);
 				skb_queue_tail(&bcs->rqueue, skb);
 			}
 			bcs->hw.hscx.rcvidx = 0;
diff --git a/drivers/isdn/hisax/icc.c b/drivers/isdn/hisax/icc.c
index db5321f6379b..18dc3c47b7ef 100644
--- a/drivers/isdn/hisax/icc.c
+++ b/drivers/isdn/hisax/icc.c
@@ -217,7 +217,7 @@ icc_interrupt(struct IsdnCardState *cs, u_char val)
 				if (!(skb = alloc_skb(count, GFP_ATOMIC)))
 					printk(KERN_WARNING "HiSax: D receive out of memory\n");
 				else {
-					memcpy(skb_put(skb, count), cs->rcvbuf, count);
+					skb_put_data(skb, cs->rcvbuf, count);
 					skb_queue_tail(&cs->rq, skb);
 				}
 			}
diff --git a/drivers/isdn/hisax/ipacx.c b/drivers/isdn/hisax/ipacx.c
index 74feb5c83067..2eaa97719f3e 100644
--- a/drivers/isdn/hisax/ipacx.c
+++ b/drivers/isdn/hisax/ipacx.c
@@ -350,7 +350,7 @@ dch_int(struct IsdnCardState *cs)
 				if (!(skb = dev_alloc_skb(count)))
 					printk(KERN_WARNING "HiSax dch_int(): receive out of memory\n");
 				else {
-					memcpy(skb_put(skb, count), cs->rcvbuf, count);
+					skb_put_data(skb, cs->rcvbuf, count);
 					skb_queue_tail(&cs->rq, skb);
 				}
 			}
@@ -629,7 +629,8 @@ bch_int(struct IsdnCardState *cs, u_char hscx)
 				if (!(skb = dev_alloc_skb(count)))
 					printk(KERN_WARNING "HiSax bch_int(): receive frame out of memory\n");
 				else {
-					memcpy(skb_put(skb, count), bcs->hw.hscx.rcvbuf, count);
+					skb_put_data(skb, bcs->hw.hscx.rcvbuf,
+						     count);
 					skb_queue_tail(&bcs->rqueue, skb);
 				}
 			}
@@ -646,7 +647,8 @@ bch_int(struct IsdnCardState *cs, u_char hscx)
 			if (!(skb = dev_alloc_skb(B_FIFO_SIZE)))
 				printk(KERN_WARNING "HiSax bch_int(): receive transparent out of memory\n");
 			else {
-				memcpy(skb_put(skb, B_FIFO_SIZE), bcs->hw.hscx.rcvbuf, B_FIFO_SIZE);
+				skb_put_data(skb, bcs->hw.hscx.rcvbuf,
+					     B_FIFO_SIZE);
 				skb_queue_tail(&bcs->rqueue, skb);
 			}
 			bcs->hw.hscx.rcvidx = 0;
diff --git a/drivers/isdn/hisax/isac.c b/drivers/isdn/hisax/isac.c
index a365ccc1c99c..908c4aac34f0 100644
--- a/drivers/isdn/hisax/isac.c
+++ b/drivers/isdn/hisax/isac.c
@@ -220,7 +220,7 @@ isac_interrupt(struct IsdnCardState *cs, u_char val)
 				if (!(skb = alloc_skb(count, GFP_ATOMIC)))
 					printk(KERN_WARNING "HiSax: D receive out of memory\n");
 				else {
-					memcpy(skb_put(skb, count), cs->rcvbuf, count);
+					skb_put_data(skb, cs->rcvbuf, count);
 					skb_queue_tail(&cs->rq, skb);
 				}
 			}
diff --git a/drivers/isdn/hisax/isar.c b/drivers/isdn/hisax/isar.c
index 7fdf34704fe5..5562d2b1120e 100644
--- a/drivers/isdn/hisax/isar.c
+++ b/drivers/isdn/hisax/isar.c
@@ -458,7 +458,7 @@ send_DLE_ETX(struct BCState *bcs)
 	struct sk_buff *skb;
 
 	if ((skb = dev_alloc_skb(2))) {
-		memcpy(skb_put(skb, 2), dleetx, 2);
+		skb_put_data(skb, dleetx, 2);
 		skb_queue_tail(&bcs->rqueue, skb);
 		schedule_event(bcs, B_RCVBUFREADY);
 	} else {
@@ -550,8 +550,8 @@ isar_rcv_frame(struct IsdnCardState *cs, struct BCState *bcs)
 				} else if (!(skb = dev_alloc_skb(bcs->hw.isar.rcvidx - 2))) {
 					printk(KERN_WARNING "ISAR: receive out of memory\n");
 				} else {
-					memcpy(skb_put(skb, bcs->hw.isar.rcvidx - 2),
-					       bcs->hw.isar.rcvbuf, bcs->hw.isar.rcvidx - 2);
+					skb_put_data(skb, bcs->hw.isar.rcvbuf,
+						     bcs->hw.isar.rcvidx - 2);
 					skb_queue_tail(&bcs->rqueue, skb);
 					schedule_event(bcs, B_RCVBUFREADY);
 				}
diff --git a/drivers/isdn/hisax/isdnl2.c b/drivers/isdn/hisax/isdnl2.c
index 18accb0a79cc..728a89ab6a47 100644
--- a/drivers/isdn/hisax/isdnl2.c
+++ b/drivers/isdn/hisax/isdnl2.c
@@ -433,7 +433,7 @@ send_uframe(struct PStack *st, u_char cmd, u_char cr)
 		printk(KERN_WARNING "isdl2 can't alloc sbbuff for send_uframe\n");
 		return;
 	}
-	memcpy(skb_put(skb, i), tmp, i);
+	skb_put_data(skb, tmp, i);
 	enqueue_super(st, skb);
 }
 
@@ -894,7 +894,7 @@ enquiry_cr(struct PStack *st, u_char typ, u_char cr, u_char pf)
 		printk(KERN_WARNING "isdl2 can't alloc sbbuff for enquiry_cr\n");
 		return;
 	}
-	memcpy(skb_put(skb, i), tmp, i);
+	skb_put_data(skb, tmp, i);
 	enqueue_super(st, skb);
 }
 
diff --git a/drivers/isdn/hisax/jade_irq.c b/drivers/isdn/hisax/jade_irq.c
index f521fc83dc76..df83a6409ec8 100644
--- a/drivers/isdn/hisax/jade_irq.c
+++ b/drivers/isdn/hisax/jade_irq.c
@@ -147,7 +147,8 @@ jade_interrupt(struct IsdnCardState *cs, u_char val, u_char jade)
 				if (!(skb = dev_alloc_skb(count)))
 					printk(KERN_WARNING "JADE %s receive out of memory\n", (jade ? "B" : "A"));
 				else {
-					memcpy(skb_put(skb, count), bcs->hw.hscx.rcvbuf, count);
+					skb_put_data(skb, bcs->hw.hscx.rcvbuf,
+						     count);
 					skb_queue_tail(&bcs->rqueue, skb);
 				}
 			}
@@ -162,7 +163,8 @@ jade_interrupt(struct IsdnCardState *cs, u_char val, u_char jade)
 			if (!(skb = dev_alloc_skb(fifo_size)))
 				printk(KERN_WARNING "HiSax: receive out of memory\n");
 			else {
-				memcpy(skb_put(skb, fifo_size), bcs->hw.hscx.rcvbuf, fifo_size);
+				skb_put_data(skb, bcs->hw.hscx.rcvbuf,
+					     fifo_size);
 				skb_queue_tail(&bcs->rqueue, skb);
 			}
 			bcs->hw.hscx.rcvidx = 0;
diff --git a/drivers/isdn/hisax/l3_1tr6.c b/drivers/isdn/hisax/l3_1tr6.c
index 4c1bca5caa1d..2f9034de2828 100644
--- a/drivers/isdn/hisax/l3_1tr6.c
+++ b/drivers/isdn/hisax/l3_1tr6.c
@@ -149,7 +149,7 @@ l3_1tr6_setup_req(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	L3DelTimer(&pc->timer);
 	L3AddTimer(&pc->timer, T303, CC_T303);
 	newl3state(pc, 1);
@@ -499,7 +499,7 @@ l3_1tr6_setup_rsp(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 	L3DelTimer(&pc->timer);
 	L3AddTimer(&pc->timer, T313, CC_T313);
@@ -545,7 +545,7 @@ l3_1tr6_disconnect_req(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 	L3AddTimer(&pc->timer, T305, CC_T305);
 }
@@ -604,7 +604,7 @@ l3_1tr6_t305(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 	L3AddTimer(&pc->timer, T308, CC_T308_1);
 }
diff --git a/drivers/isdn/hisax/l3dss1.c b/drivers/isdn/hisax/l3dss1.c
index cda700664e9c..18a3484b1f7e 100644
--- a/drivers/isdn/hisax/l3dss1.c
+++ b/drivers/isdn/hisax/l3dss1.c
@@ -525,7 +525,7 @@ l3dss1_message_cause(struct l3_process *pc, u_char mt, u_char cause)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 }
 
@@ -551,7 +551,7 @@ l3dss1_status_send(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 }
 
@@ -587,7 +587,7 @@ l3dss1_msg_without_setup(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 	dss1_release_l3_process(pc);
 }
@@ -944,7 +944,7 @@ l3dss1_msg_with_uus(struct l3_process *pc, u_char cmd)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 } /* l3dss1_msg_with_uus */
 
@@ -1420,7 +1420,7 @@ l3dss1_setup_req(struct l3_process *pc, u_char pr,
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	L3DelTimer(&pc->timer);
 	L3AddTimer(&pc->timer, T303, CC_T303);
 	newl3state(pc, 1);
@@ -1786,7 +1786,7 @@ l3dss1_disconnect_req(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	newl3state(pc, 11);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 	L3AddTimer(&pc->timer, T305, CC_T305);
@@ -1848,7 +1848,7 @@ l3dss1_reject_req(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 	pc->st->l3.l3l4(pc->st, CC_RELEASE | INDICATION, pc);
 	newl3state(pc, 0);
@@ -2145,7 +2145,7 @@ static void l3dss1_redir_req(struct l3_process *pc, u_char pr, void *arg)
 
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l))) return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 } /* l3dss1_redir_req */
@@ -2216,7 +2216,7 @@ static int l3dss1_cmd_global(struct PStack *st, isdn_ctrl *ic)
 				if (pc) dss1_release_l3_process(pc);
 				return (-2);
 			}
-			memcpy(skb_put(skb, l), temp, l);
+			skb_put_data(skb, temp, l);
 
 			if (pc)
 			{ pc->prot.dss1.invoke_id = id; /* remember id */
@@ -2359,7 +2359,7 @@ l3dss1_t305(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	newl3state(pc, 19);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 	L3AddTimer(&pc->timer, T308, CC_T308_1);
@@ -2528,7 +2528,7 @@ l3dss1_suspend_req(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 	newl3state(pc, 15);
 	L3AddTimer(&pc->timer, T319, CC_T319);
@@ -2603,7 +2603,7 @@ l3dss1_resume_req(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 	newl3state(pc, 17);
 	L3AddTimer(&pc->timer, T318, CC_T318);
@@ -2721,7 +2721,7 @@ l3dss1_global_restart(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	newl3state(pc, 0);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 }
@@ -2929,7 +2929,7 @@ global_handler(struct PStack *st, int mt, struct sk_buff *skb)
 		l = p - tmp;
 		if (!(skb = l3_alloc_skb(l)))
 			return;
-		memcpy(skb_put(skb, l), tmp, l);
+		skb_put_data(skb, tmp, l);
 		l3_msg(proc->st, DL_DATA | REQUEST, skb);
 	} else {
 		if (st->l3.debug & L3_DEB_STATE) {
diff --git a/drivers/isdn/hisax/l3ni1.c b/drivers/isdn/hisax/l3ni1.c
index 0df6691d045c..3ff697fbdc08 100644
--- a/drivers/isdn/hisax/l3ni1.c
+++ b/drivers/isdn/hisax/l3ni1.c
@@ -454,7 +454,7 @@ l3ni1_message_plus_chid(struct l3_process *pc, u_char mt)
 
 	if (!(skb = l3_alloc_skb(7)))
 		return;
-	memcpy(skb_put(skb, 7), tmp, 7);
+	skb_put_data(skb, tmp, 7);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 }
 
@@ -475,7 +475,7 @@ l3ni1_message_cause(struct l3_process *pc, u_char mt, u_char cause)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 }
 
@@ -501,7 +501,7 @@ l3ni1_status_send(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 }
 
@@ -537,7 +537,7 @@ l3ni1_msg_without_setup(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 	ni1_release_l3_process(pc);
 }
@@ -894,7 +894,7 @@ l3ni1_msg_with_uus(struct l3_process *pc, u_char cmd)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 } /* l3ni1_msg_with_uus */
 
@@ -1274,7 +1274,7 @@ l3ni1_setup_req(struct l3_process *pc, u_char pr,
 	{
 		return;
 	}
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	L3DelTimer(&pc->timer);
 	L3AddTimer(&pc->timer, T303, CC_T303);
 	newl3state(pc, 1);
@@ -1640,7 +1640,7 @@ l3ni1_disconnect_req(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	newl3state(pc, 11);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 	L3AddTimer(&pc->timer, T305, CC_T305);
@@ -1704,7 +1704,7 @@ l3ni1_reject_req(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 	pc->st->l3.l3l4(pc->st, CC_RELEASE | INDICATION, pc);
 	newl3state(pc, 0);
@@ -2001,7 +2001,7 @@ static void l3ni1_redir_req(struct l3_process *pc, u_char pr, void *arg)
 
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l))) return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 } /* l3ni1_redir_req */
@@ -2072,7 +2072,7 @@ static int l3ni1_cmd_global(struct PStack *st, isdn_ctrl *ic)
 				if (pc) ni1_release_l3_process(pc);
 				return (-2);
 			}
-			memcpy(skb_put(skb, l), temp, l);
+			skb_put_data(skb, temp, l);
 
 			if (pc)
 			{ pc->prot.ni1.invoke_id = id; /* remember id */
@@ -2215,7 +2215,7 @@ l3ni1_t305(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	newl3state(pc, 19);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 	L3AddTimer(&pc->timer, T308, CC_T308_1);
@@ -2384,7 +2384,7 @@ l3ni1_suspend_req(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 	newl3state(pc, 15);
 	L3AddTimer(&pc->timer, T319, CC_T319);
@@ -2459,7 +2459,7 @@ l3ni1_resume_req(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 	newl3state(pc, 17);
 	L3AddTimer(&pc->timer, T318, CC_T318);
@@ -2578,7 +2578,7 @@ l3ni1_global_restart(struct l3_process *pc, u_char pr, void *arg)
 	l = p - tmp;
 	if (!(skb = l3_alloc_skb(l)))
 		return;
-	memcpy(skb_put(skb, l), tmp, l);
+	skb_put_data(skb, tmp, l);
 	newl3state(pc, 0);
 	l3_msg(pc->st, DL_DATA | REQUEST, skb);
 }
@@ -2651,7 +2651,7 @@ static void l3ni1_SendSpid(struct l3_process *pc, u_char pr, struct sk_buff *skb
 	*p++ = IE_SPID;
 	*p++ = l;
 
-	memcpy(skb_put(skb, l), pSPID, l);
+	skb_put_data(skb, pSPID, l);
 
 	newl3state(pc, iNewState);
 
@@ -2869,7 +2869,7 @@ global_handler(struct PStack *st, int mt, struct sk_buff *skb)
 		l = p - tmp;
 		if (!(skb = l3_alloc_skb(l)))
 			return;
-		memcpy(skb_put(skb, l), tmp, l);
+		skb_put_data(skb, tmp, l);
 		l3_msg(proc->st, DL_DATA | REQUEST, skb);
 	} else {
 		if (st->l3.debug & L3_DEB_STATE) {
diff --git a/drivers/isdn/hisax/netjet.c b/drivers/isdn/hisax/netjet.c
index b646eed379df..f85ae7167814 100644
--- a/drivers/isdn/hisax/netjet.c
+++ b/drivers/isdn/hisax/netjet.c
@@ -383,7 +383,7 @@ static void got_frame(struct BCState *bcs, int count) {
 	if (!(skb = dev_alloc_skb(count)))
 		printk(KERN_WARNING "TIGER: receive out of memory\n");
 	else {
-		memcpy(skb_put(skb, count), bcs->hw.tiger.rcvbuf, count);
+		skb_put_data(skb, bcs->hw.tiger.rcvbuf, count);
 		skb_queue_tail(&bcs->rqueue, skb);
 	}
 	test_and_set_bit(B_RCVBUFREADY, &bcs->event);
diff --git a/drivers/isdn/hisax/st5481_usb.c b/drivers/isdn/hisax/st5481_usb.c
index ead0a4fb7448..5c8e45267d13 100644
--- a/drivers/isdn/hisax/st5481_usb.c
+++ b/drivers/isdn/hisax/st5481_usb.c
@@ -527,7 +527,7 @@ static void usb_in_complete(struct urb *urb)
 				WARNING("receive out of memory\n");
 				break;
 			}
-			memcpy(skb_put(skb, status), in->rcvbuf, status);
+			skb_put_data(skb, in->rcvbuf, status);
 			in->hisax_if->l1l2(in->hisax_if, PH_DATA | INDICATION, skb);
 		} else if (status == -HDLC_CRC_ERROR) {
 			INFO("CRC error");
diff --git a/drivers/isdn/hisax/w6692.c b/drivers/isdn/hisax/w6692.c
index d8cac6935818..65ee8dbc8656 100644
--- a/drivers/isdn/hisax/w6692.c
+++ b/drivers/isdn/hisax/w6692.c
@@ -309,7 +309,9 @@ W6692B_interrupt(struct IsdnCardState *cs, u_char bchan)
 				if (!(skb = dev_alloc_skb(count)))
 					printk(KERN_WARNING "W6692: Bchan receive out of memory\n");
 				else {
-					memcpy(skb_put(skb, count), bcs->hw.w6692.rcvbuf, count);
+					skb_put_data(skb,
+						     bcs->hw.w6692.rcvbuf,
+						     count);
 					skb_queue_tail(&bcs->rqueue, skb);
 				}
 			}
@@ -332,7 +334,8 @@ W6692B_interrupt(struct IsdnCardState *cs, u_char bchan)
 			if (!(skb = dev_alloc_skb(W_B_FIFO_THRESH)))
 				printk(KERN_WARNING "HiSax: receive out of memory\n");
 			else {
-				memcpy(skb_put(skb, W_B_FIFO_THRESH), bcs->hw.w6692.rcvbuf, W_B_FIFO_THRESH);
+				skb_put_data(skb, bcs->hw.w6692.rcvbuf,
+					     W_B_FIFO_THRESH);
 				skb_queue_tail(&bcs->rqueue, skb);
 			}
 			bcs->hw.w6692.rcvidx = 0;
@@ -441,7 +444,7 @@ StartW6692:
 				if (!(skb = alloc_skb(count, GFP_ATOMIC)))
 					printk(KERN_WARNING "HiSax: D receive out of memory\n");
 				else {
-					memcpy(skb_put(skb, count), cs->rcvbuf, count);
+					skb_put_data(skb, cs->rcvbuf, count);
 					skb_queue_tail(&cs->rq, skb);
 				}
 			}
diff --git a/drivers/isdn/hysdn/hycapi.c b/drivers/isdn/hysdn/hycapi.c
index 00aad10507d8..707f9edfd822 100644
--- a/drivers/isdn/hysdn/hycapi.c
+++ b/drivers/isdn/hysdn/hycapi.c
@@ -171,16 +171,16 @@ hycapi_register_internal(struct capi_ctr *ctrl, __u16 appl,
 		       card->myid);
 		return;
 	}
-	memcpy(skb_put(skb, sizeof(__u16)), &len, sizeof(__u16));
-	memcpy(skb_put(skb, sizeof(__u16)), &appl, sizeof(__u16));
+	skb_put_data(skb, &len, sizeof(__u16));
+	skb_put_data(skb, &appl, sizeof(__u16));
 	memcpy(skb_put(skb, sizeof(__u8)), &_command, sizeof(_command));
 	memcpy(skb_put(skb, sizeof(__u8)), &_subcommand, sizeof(_subcommand));
-	memcpy(skb_put(skb, sizeof(__u16)), &MessageNumber, sizeof(__u16));
-	memcpy(skb_put(skb, sizeof(__u16)), &MessageBufferSize, sizeof(__u16));
-	memcpy(skb_put(skb, sizeof(__u16)), &(rp->level3cnt), sizeof(__u16));
-	memcpy(skb_put(skb, sizeof(__u16)), &(rp->datablkcnt), sizeof(__u16));
-	memcpy(skb_put(skb, sizeof(__u16)), &(rp->datablklen), sizeof(__u16));
-	memcpy(skb_put(skb, slen), ExtFeatureDefaults, slen);
+	skb_put_data(skb, &MessageNumber, sizeof(__u16));
+	skb_put_data(skb, &MessageBufferSize, sizeof(__u16));
+	skb_put_data(skb, &(rp->level3cnt), sizeof(__u16));
+	skb_put_data(skb, &(rp->datablkcnt), sizeof(__u16));
+	skb_put_data(skb, &(rp->datablklen), sizeof(__u16));
+	skb_put_data(skb, ExtFeatureDefaults, slen);
 	hycapi_applications[appl - 1].ctrl_mask |= (1 << (ctrl->cnr - 1));
 	hycapi_send_message(ctrl, skb);
 }
@@ -279,11 +279,11 @@ static void hycapi_release_internal(struct capi_ctr *ctrl, __u16 appl)
 		       card->myid);
 		return;
 	}
-	memcpy(skb_put(skb, sizeof(__u16)), &len, sizeof(__u16));
-	memcpy(skb_put(skb, sizeof(__u16)), &appl, sizeof(__u16));
+	skb_put_data(skb, &len, sizeof(__u16));
+	skb_put_data(skb, &appl, sizeof(__u16));
 	memcpy(skb_put(skb, sizeof(__u8)), &_command, sizeof(_command));
 	memcpy(skb_put(skb, sizeof(__u8)), &_subcommand, sizeof(_subcommand));
-	memcpy(skb_put(skb, sizeof(__u16)), &MessageNumber, sizeof(__u16));
+	skb_put_data(skb, &MessageNumber, sizeof(__u16));
 	hycapi_send_message(ctrl, skb);
 	hycapi_applications[appl - 1].ctrl_mask &= ~(1 << (ctrl->cnr - 1));
 }
@@ -557,10 +557,9 @@ hycapi_rx_capipkt(hysdn_card *card, unsigned char *buf, unsigned short len)
 			       card->myid);
 			return;
 		}
-		memcpy(skb_put(skb, MsgLen), buf, MsgLen);
-		memcpy(skb_put(skb, 2 * sizeof(__u32)), CP64, 2 * sizeof(__u32));
-		memcpy(skb_put(skb, len - MsgLen), buf + MsgLen,
-		       len - MsgLen);
+		skb_put_data(skb, buf, MsgLen);
+		skb_put_data(skb, CP64, 2 * sizeof(__u32));
+		skb_put_data(skb, buf + MsgLen, len - MsgLen);
 		CAPIMSG_SETLEN(skb->data, 30);
 	} else {
 		if (!(skb = alloc_skb(len, GFP_ATOMIC))) {
@@ -568,7 +567,7 @@ hycapi_rx_capipkt(hysdn_card *card, unsigned char *buf, unsigned short len)
 			       card->myid);
 			return;
 		}
-		memcpy(skb_put(skb, len), buf, len);
+		skb_put_data(skb, buf, len);
 	}
 	switch (CAPIMSG_CMD(skb->data))
 	{
diff --git a/drivers/isdn/hysdn/hysdn_net.c b/drivers/isdn/hysdn/hysdn_net.c
index 979e4b9416db..43f2fb16008a 100644
--- a/drivers/isdn/hysdn/hysdn_net.c
+++ b/drivers/isdn/hysdn/hysdn_net.c
@@ -201,7 +201,7 @@ hysdn_rx_netpkt(hysdn_card *card, unsigned char *buf, unsigned short len)
 		return;
 	}
 	/* copy the data */
-	memcpy(skb_put(skb, len), buf, len);
+	skb_put_data(skb, buf, len);
 
 	/* determine the used protocol */
 	skb->protocol = eth_type_trans(skb, dev);
diff --git a/drivers/isdn/i4l/isdn_ppp.c b/drivers/isdn/i4l/isdn_ppp.c
index 8d2de72b972c..d7c8b6a2b162 100644
--- a/drivers/isdn/i4l/isdn_ppp.c
+++ b/drivers/isdn/i4l/isdn_ppp.c
@@ -2229,8 +2229,7 @@ static void isdn_ppp_ccp_xmit_reset(struct ippp_struct *is, int proto,
 
 	/* Now stuff remaining bytes */
 	if (len) {
-		p = skb_put(skb, len);
-		memcpy(p, data, len);
+		p = skb_put_data(skb, data, len);
 	}
 
 	/* skb is now ready for xmit */
diff --git a/drivers/isdn/i4l/isdn_tty.c b/drivers/isdn/i4l/isdn_tty.c
index 732f68a5c9c3..5a39b6f4e55b 100644
--- a/drivers/isdn/i4l/isdn_tty.c
+++ b/drivers/isdn/i4l/isdn_tty.c
@@ -473,7 +473,7 @@ isdn_tty_senddown(modem_info *info)
 		return;
 	}
 	skb_reserve(skb, skb_res);
-	memcpy(skb_put(skb, buflen), info->port.xmit_buf, buflen);
+	skb_put_data(skb, info->port.xmit_buf, buflen);
 	info->xmit_count = 0;
 #ifdef CONFIG_ISDN_AUDIO
 	if (info->vonline & 2) {
diff --git a/drivers/isdn/i4l/isdn_v110.c b/drivers/isdn/i4l/isdn_v110.c
index 52827a80c51f..8b74ce412524 100644
--- a/drivers/isdn/i4l/isdn_v110.c
+++ b/drivers/isdn/i4l/isdn_v110.c
@@ -421,7 +421,7 @@ isdn_v110_sync(isdn_v110_stream *v)
 	}
 	if ((skb = dev_alloc_skb(v->framelen + v->skbres))) {
 		skb_reserve(skb, v->skbres);
-		memcpy(skb_put(skb, v->framelen), v->OfflineFrame, v->framelen);
+		skb_put_data(skb, v->OfflineFrame, v->framelen);
 	}
 	return skb;
 }
@@ -441,7 +441,7 @@ isdn_v110_idle(isdn_v110_stream *v)
 	}
 	if ((skb = dev_alloc_skb(v->framelen + v->skbres))) {
 		skb_reserve(skb, v->skbres);
-		memcpy(skb_put(skb, v->framelen), v->OnlineFrame, v->framelen);
+		skb_put_data(skb, v->OnlineFrame, v->framelen);
 	}
 	return skb;
 }
@@ -486,7 +486,7 @@ isdn_v110_encode(isdn_v110_stream *v, struct sk_buff *skb)
 	}
 	skb_reserve(nskb, v->skbres + sizeof(int));
 	if (skb->len == 0) {
-		memcpy(skb_put(nskb, v->framelen), v->OnlineFrame, v->framelen);
+		skb_put_data(nskb, v->OnlineFrame, v->framelen);
 		*((int *)skb_push(nskb, sizeof(int))) = 0;
 		return nskb;
 	}
diff --git a/drivers/isdn/isdnloop/isdnloop.c b/drivers/isdn/isdnloop/isdnloop.c
index 02125e6a9109..334380317164 100644
--- a/drivers/isdn/isdnloop/isdnloop.c
+++ b/drivers/isdn/isdnloop/isdnloop.c
@@ -478,7 +478,7 @@ isdnloop_fake(isdnloop_card *card, char *s, int ch)
 	}
 	if (ch >= 0)
 		sprintf(skb_put(skb, 3), "%02d;", ch);
-	memcpy(skb_put(skb, strlen(s)), s, strlen(s));
+	skb_put_data(skb, s, strlen(s));
 	skb_queue_tail(&card->dqueue, skb);
 	return 0;
 }
diff --git a/drivers/isdn/mISDN/dsp_cmx.c b/drivers/isdn/mISDN/dsp_cmx.c
index a4f05c54c32b..1dbb4a102a9d 100644
--- a/drivers/isdn/mISDN/dsp_cmx.c
+++ b/drivers/isdn/mISDN/dsp_cmx.c
@@ -1598,8 +1598,7 @@ send_packet:
 				thh = mISDN_HEAD_P(txskb);
 				thh->prim = DL_DATA_REQ;
 				thh->id = 0;
-				memcpy(skb_put(txskb, len), nskb->data + preload,
-				       len);
+				skb_put_data(txskb, nskb->data + preload, len);
 				/* queue (trigger later) */
 				skb_queue_tail(&dsp->sendq, txskb);
 			}
diff --git a/drivers/isdn/mISDN/layer2.c b/drivers/isdn/mISDN/layer2.c
index 949cabb88f1c..aa1f3386acff 100644
--- a/drivers/isdn/mISDN/layer2.c
+++ b/drivers/isdn/mISDN/layer2.c
@@ -176,7 +176,7 @@ l2up_create(struct layer2 *l2, u_int prim, int len, void *arg)
 	hh->prim = prim;
 	hh->id = (l2->ch.nr << 16) | l2->ch.addr;
 	if (len)
-		memcpy(skb_put(skb, len), arg, len);
+		skb_put_data(skb, arg, len);
 	err = l2->up->send(l2->up, skb);
 	if (err) {
 		printk(KERN_WARNING "%s: dev %s err=%d\n", __func__,
@@ -235,7 +235,7 @@ l2down_create(struct layer2 *l2, u_int prim, u_int id, int len, void *arg)
 	hh->prim = prim;
 	hh->id = id;
 	if (len)
-		memcpy(skb_put(skb, len), arg, len);
+		skb_put_data(skb, arg, len);
 	err = l2down_raw(l2, skb);
 	if (err)
 		dev_kfree_skb(skb);
@@ -640,7 +640,7 @@ send_uframe(struct layer2 *l2, struct sk_buff *skb, u_char cmd, u_char cr)
 			return;
 		}
 	}
-	memcpy(skb_put(skb, i), tmp, i);
+	skb_put_data(skb, tmp, i);
 	enqueue_super(l2, skb);
 }
 
@@ -1125,7 +1125,7 @@ enquiry_cr(struct layer2 *l2, u_char typ, u_char cr, u_char pf)
 		       mISDNDevName4ch(&l2->ch), __func__);
 		return;
 	}
-	memcpy(skb_put(skb, i), tmp, i);
+	skb_put_data(skb, tmp, i);
 	enqueue_super(l2, skb);
 }
 
diff --git a/drivers/isdn/mISDN/tei.c b/drivers/isdn/mISDN/tei.c
index 592f597d8951..908127efccf8 100644
--- a/drivers/isdn/mISDN/tei.c
+++ b/drivers/isdn/mISDN/tei.c
@@ -312,7 +312,7 @@ teiup_create(struct manager *mgr, u_int prim, int len, void *arg)
 	hh->prim = prim;
 	hh->id = (mgr->ch.nr << 16) | mgr->ch.addr;
 	if (len)
-		memcpy(skb_put(skb, len), arg, len);
+		skb_put_data(skb, arg, len);
 	err = mgr->up->send(mgr->up, skb);
 	if (err) {
 		printk(KERN_WARNING "%s: err=%d\n", __func__, err);
* Unmerged path drivers/media/dvb-core/dvb_net.c
diff --git a/drivers/media/radio/wl128x/fmdrv_common.c b/drivers/media/radio/wl128x/fmdrv_common.c
index 917740d9c058..771b72619225 100644
--- a/drivers/media/radio/wl128x/fmdrv_common.c
+++ b/drivers/media/radio/wl128x/fmdrv_common.c
@@ -446,7 +446,7 @@ static int fm_send_cmd(struct fmdev *fmdev, u8 fm_op, u16 type,	void *payload,
 		fm_cb(skb)->fm_op = *((u8 *)payload + 2);
 	}
 	if (payload != NULL)
-		memcpy(skb_put(skb, payload_len), payload, payload_len);
+		skb_put_data(skb, payload, payload_len);
 
 	fm_cb(skb)->completion = wait_completion;
 	skb_queue_tail(&fmdev->tx_q, skb);
diff --git a/drivers/misc/ti-st/st_core.c b/drivers/misc/ti-st/st_core.c
index 732d6aa6c027..ded394949e48 100644
--- a/drivers/misc/ti-st/st_core.c
+++ b/drivers/misc/ti-st/st_core.c
@@ -262,7 +262,7 @@ void st_int_recv(void *disc_data,
 	while (count) {
 		if (st_gdata->rx_count) {
 			len = min_t(unsigned int, st_gdata->rx_count, count);
-			memcpy(skb_put(st_gdata->rx_skb, len), ptr, len);
+			skb_put_data(st_gdata->rx_skb, ptr, len);
 			st_gdata->rx_count -= len;
 			count -= len;
 			ptr += len;
diff --git a/drivers/misc/ti-st/st_kim.c b/drivers/misc/ti-st/st_kim.c
index 83269f1d16e3..2f16eeceafb9 100644
--- a/drivers/misc/ti-st/st_kim.c
+++ b/drivers/misc/ti-st/st_kim.c
@@ -154,7 +154,7 @@ static void kim_int_recv(struct kim_data_s *kim_gdata,
 	while (count) {
 		if (kim_gdata->rx_count) {
 			len = min_t(unsigned int, kim_gdata->rx_count, count);
-			memcpy(skb_put(kim_gdata->rx_skb, len), ptr, len);
+			skb_put_data(kim_gdata->rx_skb, ptr, len);
 			kim_gdata->rx_count -= len;
 			count -= len;
 			ptr += len;
diff --git a/drivers/net/bonding/bond_alb.c b/drivers/net/bonding/bond_alb.c
index 7d50d66d81b0..f8cfb442e5cb 100644
--- a/drivers/net/bonding/bond_alb.c
+++ b/drivers/net/bonding/bond_alb.c
@@ -935,8 +935,7 @@ static void alb_send_lp_vid(struct slave *slave, u8 mac_addr[],
 	if (!skb)
 		return;
 
-	data = skb_put(skb, size);
-	memcpy(data, &pkt, size);
+	data = skb_put_data(skb, &pkt, size);
 
 	skb_reset_mac_header(skb);
 	skb->network_header = skb->mac_header + ETH_HLEN;
diff --git a/drivers/net/caif/caif_hsi.c b/drivers/net/caif/caif_hsi.c
index 5e40a8b68cbe..bbedd903d4b6 100644
--- a/drivers/net/caif/caif_hsi.c
+++ b/drivers/net/caif/caif_hsi.c
@@ -454,8 +454,7 @@ static int cfhsi_rx_desc(struct cfhsi_desc *desc, struct cfhsi *cfhsi)
 		}
 		caif_assert(skb != NULL);
 
-		dst = skb_put(skb, len);
-		memcpy(dst, pfrm, len);
+		dst = skb_put_data(skb, pfrm, len);
 
 		skb->protocol = htons(ETH_P_CAIF);
 		skb_reset_mac_header(skb);
@@ -585,8 +584,7 @@ static int cfhsi_rx_pld(struct cfhsi_desc *desc, struct cfhsi *cfhsi)
 		}
 		caif_assert(skb != NULL);
 
-		dst = skb_put(skb, len);
-		memcpy(dst, pcffrm, len);
+		dst = skb_put_data(skb, pcffrm, len);
 
 		skb->protocol = htons(ETH_P_CAIF);
 		skb_reset_mac_header(skb);
diff --git a/drivers/net/caif/caif_serial.c b/drivers/net/caif/caif_serial.c
index 77be3cb0b5fe..fcd2670ad571 100644
--- a/drivers/net/caif/caif_serial.c
+++ b/drivers/net/caif/caif_serial.c
@@ -198,8 +198,7 @@ static void ldisc_receive(struct tty_struct *tty, const u8 *data,
 	skb = netdev_alloc_skb(ser->dev, count+1);
 	if (skb == NULL)
 		return;
-	p = skb_put(skb, count);
-	memcpy(p, data, count);
+	p = skb_put_data(skb, data, count);
 
 	skb->protocol = htons(ETH_P_CAIF);
 	skb_reset_mac_header(skb);
diff --git a/drivers/net/caif/caif_spi.c b/drivers/net/caif/caif_spi.c
index 155db68e13ba..1d6dd2cebcd5 100644
--- a/drivers/net/caif/caif_spi.c
+++ b/drivers/net/caif/caif_spi.c
@@ -548,8 +548,7 @@ int cfspi_rxfrm(struct cfspi *cfspi, u8 *buf, size_t len)
 		skb = netdev_alloc_skb(cfspi->ndev, pkt_len + 1);
 		caif_assert(skb != NULL);
 
-		dst = skb_put(skb, pkt_len);
-		memcpy(dst, src, pkt_len);
+		dst = skb_put_data(skb, src, pkt_len);
 		src += pkt_len;
 
 		skb->protocol = htons(ETH_P_CAIF);
diff --git a/drivers/net/caif/caif_virtio.c b/drivers/net/caif/caif_virtio.c
index 7d899f19da0b..ec4241f4e57b 100644
--- a/drivers/net/caif/caif_virtio.c
+++ b/drivers/net/caif/caif_virtio.c
@@ -242,7 +242,7 @@ static struct sk_buff *cfv_alloc_and_copy_skb(int *err,
 
 	skb_reserve(skb, cfv->rx_hr + pad_len);
 
-	memcpy(skb_put(skb, cfpkt_len), frm + cfv->rx_hr, cfpkt_len);
+	skb_put_data(skb, frm + cfv->rx_hr, cfpkt_len);
 	return skb;
 }
 
* Unmerged path drivers/net/can/slcan.c
diff --git a/drivers/net/ethernet/3com/3c515.c b/drivers/net/ethernet/3com/3c515.c
index 85cab07af924..79c2f04ba211 100644
--- a/drivers/net/ethernet/3com/3c515.c
+++ b/drivers/net/ethernet/3com/3c515.c
@@ -1370,9 +1370,9 @@ static int boomerang_rx(struct net_device *dev)
 			    (skb = netdev_alloc_skb(dev, pkt_len + 4)) != NULL) {
 				skb_reserve(skb, 2);	/* Align IP on 16 byte boundaries */
 				/* 'skb_put()' points to the start of sk_buff data area. */
-				memcpy(skb_put(skb, pkt_len),
-				       isa_bus_to_virt(vp->rx_ring[entry].
-						   addr), pkt_len);
+				skb_put_data(skb,
+					     isa_bus_to_virt(vp->rx_ring[entry].addr),
+					     pkt_len);
 				rx_copy++;
 			} else {
 				void *temp;
diff --git a/drivers/net/ethernet/3com/3c59x.c b/drivers/net/ethernet/3com/3c59x.c
index 82bb07ec24a5..cc7eac592caf 100644
--- a/drivers/net/ethernet/3com/3c59x.c
+++ b/drivers/net/ethernet/3com/3c59x.c
@@ -2581,9 +2581,8 @@ boomerang_rx(struct net_device *dev)
 				skb_reserve(skb, 2);	/* Align IP on 16 byte boundaries */
 				pci_dma_sync_single_for_cpu(VORTEX_PCI(vp), dma, PKT_BUF_SZ, PCI_DMA_FROMDEVICE);
 				/* 'skb_put()' points to the start of sk_buff data area. */
-				memcpy(skb_put(skb, pkt_len),
-					   vp->rx_skbuff[entry]->data,
-					   pkt_len);
+				skb_put_data(skb, vp->rx_skbuff[entry]->data,
+					     pkt_len);
 				pci_dma_sync_single_for_device(VORTEX_PCI(vp), dma, PKT_BUF_SZ, PCI_DMA_FROMDEVICE);
 				vp->rx_copy++;
 			} else {
diff --git a/drivers/net/ethernet/aeroflex/greth.c b/drivers/net/ethernet/aeroflex/greth.c
index 48dd6ff189ba..b09393d32748 100644
--- a/drivers/net/ethernet/aeroflex/greth.c
+++ b/drivers/net/ethernet/aeroflex/greth.c
@@ -794,7 +794,8 @@ static int greth_rx(struct net_device *dev, int limit)
 				if (netif_msg_pktdata(greth))
 					greth_print_rx_packet(phys_to_virt(dma_addr), pkt_len);
 
-				memcpy(skb_put(skb, pkt_len), phys_to_virt(dma_addr), pkt_len);
+				skb_put_data(skb, phys_to_virt(dma_addr),
+					     pkt_len);
 
 				skb->protocol = eth_type_trans(skb, dev);
 				dev->stats.rx_bytes += pkt_len;
diff --git a/drivers/net/ethernet/apple/macmace.c b/drivers/net/ethernet/apple/macmace.c
index 4ce8ceb62205..17133e4e76c4 100644
--- a/drivers/net/ethernet/apple/macmace.c
+++ b/drivers/net/ethernet/apple/macmace.c
@@ -663,7 +663,7 @@ static void mace_dma_rx_frame(struct net_device *dev, struct mace_frame *mf)
 			return;
 		}
 		skb_reserve(skb, 2);
-		memcpy(skb_put(skb, frame_length), mf->data, frame_length);
+		skb_put_data(skb, mf->data, frame_length);
 
 		skb->protocol = eth_type_trans(skb, dev);
 		netif_rx(skb);
* Unmerged path drivers/net/ethernet/aurora/nb8800.c
* Unmerged path drivers/net/ethernet/cadence/macb.c
diff --git a/drivers/net/ethernet/cavium/liquidio/octeon_network.h b/drivers/net/ethernet/cavium/liquidio/octeon_network.h
index 6b6ac6672ca3..1e07a08f51ce 100644
--- a/drivers/net/ethernet/cavium/liquidio/octeon_network.h
+++ b/drivers/net/ethernet/cavium/liquidio/octeon_network.h
@@ -426,8 +426,8 @@ static inline void octeon_fast_packet_next(struct octeon_droq *droq,
 					   int copy_len,
 					   int idx)
 {
-	memcpy(skb_put(nicbuf, copy_len),
-	       get_rbd(droq->recv_buf_list[idx].buffer), copy_len);
+	skb_put_data(nicbuf, get_rbd(droq->recv_buf_list[idx].buffer),
+		     copy_len);
 }
 
 /**
diff --git a/drivers/net/ethernet/cirrus/cs89x0.c b/drivers/net/ethernet/cirrus/cs89x0.c
index 19f642a45f40..3bab112f14f2 100644
--- a/drivers/net/ethernet/cirrus/cs89x0.c
+++ b/drivers/net/ethernet/cirrus/cs89x0.c
@@ -448,11 +448,10 @@ skip_this_frame:
 
 	if (bp + length > lp->end_dma_buff) {
 		int semi_cnt = lp->end_dma_buff - bp;
-		memcpy(skb_put(skb, semi_cnt), bp, semi_cnt);
-		memcpy(skb_put(skb, length - semi_cnt), lp->dma_buff,
-		       length - semi_cnt);
+		skb_put_data(skb, bp, semi_cnt);
+		skb_put_data(skb, lp->dma_buff, length - semi_cnt);
 	} else {
-		memcpy(skb_put(skb, length), bp, length);
+		skb_put_data(skb, bp, length);
 	}
 	bp += (length + 3) & ~3;
 	if (bp >= lp->end_dma_buff)
diff --git a/drivers/net/ethernet/dec/tulip/de4x5.c b/drivers/net/ethernet/dec/tulip/de4x5.c
index fbf4fca387b0..71e98f19f7a6 100644
--- a/drivers/net/ethernet/dec/tulip/de4x5.c
+++ b/drivers/net/ethernet/dec/tulip/de4x5.c
@@ -3624,10 +3624,10 @@ de4x5_alloc_rx_buff(struct net_device *dev, int index, int len)
     skb_reserve(p, 2);	                               /* Align */
     if (index < lp->rx_old) {                          /* Wrapped buffer */
 	short tlen = (lp->rxRingSize - lp->rx_old) * RX_BUFF_SZ;
-	memcpy(skb_put(p,tlen),lp->rx_bufs + lp->rx_old * RX_BUFF_SZ,tlen);
-	memcpy(skb_put(p,len-tlen),lp->rx_bufs,len-tlen);
+	skb_put_data(p, lp->rx_bufs + lp->rx_old * RX_BUFF_SZ, tlen);
+	skb_put_data(p, lp->rx_bufs, len - tlen);
     } else {                                           /* Linear buffer */
-	memcpy(skb_put(p,len),lp->rx_bufs + lp->rx_old * RX_BUFF_SZ,len);
+	skb_put_data(p, lp->rx_bufs + lp->rx_old * RX_BUFF_SZ, len);
     }
 
     return p;
diff --git a/drivers/net/ethernet/dec/tulip/interrupt.c b/drivers/net/ethernet/dec/tulip/interrupt.c
index 92306b320840..ce9ca912a97a 100644
--- a/drivers/net/ethernet/dec/tulip/interrupt.c
+++ b/drivers/net/ethernet/dec/tulip/interrupt.c
@@ -218,9 +218,9 @@ int tulip_poll(struct napi_struct *napi, int budget)
                                                         pkt_len);
                                        skb_put(skb, pkt_len);
 #else
-                                       memcpy(skb_put(skb, pkt_len),
-                                              tp->rx_buffers[entry].skb->data,
-                                              pkt_len);
+                                       skb_put_data(skb,
+                                                    tp->rx_buffers[entry].skb->data,
+                                                    pkt_len);
 #endif
                                        pci_dma_sync_single_for_device(tp->pdev,
 								      tp->rx_buffers[entry].mapping,
@@ -444,9 +444,9 @@ static int tulip_rx(struct net_device *dev)
 						 pkt_len);
 				skb_put(skb, pkt_len);
 #else
-				memcpy(skb_put(skb, pkt_len),
-				       tp->rx_buffers[entry].skb->data,
-				       pkt_len);
+				skb_put_data(skb,
+					     tp->rx_buffers[entry].skb->data,
+					     pkt_len);
 #endif
 				pci_dma_sync_single_for_device(tp->pdev,
 							       tp->rx_buffers[entry].mapping,
diff --git a/drivers/net/ethernet/dec/tulip/uli526x.c b/drivers/net/ethernet/dec/tulip/uli526x.c
index 22cb959cf6e1..46155e95c871 100644
--- a/drivers/net/ethernet/dec/tulip/uli526x.c
+++ b/drivers/net/ethernet/dec/tulip/uli526x.c
@@ -867,9 +867,9 @@ static void uli526x_rx_packet(struct net_device *dev, struct uli526x_board_info
 					skb = new_skb;
 					/* size less than COPY_SIZE, allocate a rxlen SKB */
 					skb_reserve(skb, 2); /* 16byte align */
-					memcpy(skb_put(skb, rxlen),
-					       skb_tail_pointer(rxptr->rx_skb_ptr),
-					       rxlen);
+					skb_put_data(skb,
+						     skb_tail_pointer(rxptr->rx_skb_ptr),
+						     rxlen);
 					uli526x_reuse_skb(db, rxptr->rx_skb_ptr);
 				} else
 					skb_put(skb, rxlen);
* Unmerged path drivers/net/ethernet/ec_bhf.c
diff --git a/drivers/net/ethernet/fealnx.c b/drivers/net/ethernet/fealnx.c
index fa65392264ad..50069cd9cf72 100644
--- a/drivers/net/ethernet/fealnx.c
+++ b/drivers/net/ethernet/fealnx.c
@@ -1713,8 +1713,8 @@ static int netdev_rx(struct net_device *dev)
 					np->cur_rx->skbuff->data, pkt_len);
 				skb_put(skb, pkt_len);
 #else
-				memcpy(skb_put(skb, pkt_len),
-					np->cur_rx->skbuff->data, pkt_len);
+				skb_put_data(skb, np->cur_rx->skbuff->data,
+					     pkt_len);
 #endif
 				pci_dma_sync_single_for_device(np->pci_dev,
 							       np->cur_rx->buffer,
diff --git a/drivers/net/ethernet/i825xx/82596.c b/drivers/net/ethernet/i825xx/82596.c
index bfe928ca355b..5b7b800fb9c6 100644
--- a/drivers/net/ethernet/i825xx/82596.c
+++ b/drivers/net/ethernet/i825xx/82596.c
@@ -809,7 +809,8 @@ memory_squeeze:
 				if (!rx_in_place) {
 					/* 16 byte align the data fields */
 					skb_reserve(skb, 2);
-					memcpy(skb_put(skb,pkt_len), rbd->v_data, pkt_len);
+					skb_put_data(skb, rbd->v_data,
+						     pkt_len);
 				}
 				skb->protocol=eth_type_trans(skb,dev);
 				skb->len = pkt_len;
diff --git a/drivers/net/ethernet/i825xx/lib82596.c b/drivers/net/ethernet/i825xx/lib82596.c
index 83be45419685..985707043fa9 100644
--- a/drivers/net/ethernet/i825xx/lib82596.c
+++ b/drivers/net/ethernet/i825xx/lib82596.c
@@ -728,7 +728,8 @@ memory_squeeze:
 					dma_sync_single_for_cpu(dev->dev.parent,
 								(dma_addr_t)SWAP32(rbd->b_data),
 								PKT_BUF_SZ, DMA_FROM_DEVICE);
-					memcpy(skb_put(skb, pkt_len), rbd->v_data, pkt_len);
+					skb_put_data(skb, rbd->v_data,
+						     pkt_len);
 					dma_sync_single_for_device(dev->dev.parent,
 								   (dma_addr_t)SWAP32(rbd->b_data),
 								   PKT_BUF_SZ, DMA_FROM_DEVICE);
diff --git a/drivers/net/ethernet/intel/e1000/e1000_main.c b/drivers/net/ethernet/intel/e1000/e1000_main.c
index a2d7eafe4e3c..937c7ca473f8 100644
--- a/drivers/net/ethernet/intel/e1000/e1000_main.c
+++ b/drivers/net/ethernet/intel/e1000/e1000_main.c
@@ -4370,7 +4370,7 @@ static struct sk_buff *e1000_copybreak(struct e1000_adapter *adapter,
 	dma_sync_single_for_cpu(&adapter->pdev->dev, buffer_info->dma,
 				length, DMA_FROM_DEVICE);
 
-	memcpy(skb_put(skb, length), data, length);
+	skb_put_data(skb, data, length);
 
 	return skb;
 }
* Unmerged path drivers/net/ethernet/marvell/mvneta.c
diff --git a/drivers/net/ethernet/micrel/ksz884x.c b/drivers/net/ethernet/micrel/ksz884x.c
index 3bd89509c643..4a5d128656fc 100644
--- a/drivers/net/ethernet/micrel/ksz884x.c
+++ b/drivers/net/ethernet/micrel/ksz884x.c
@@ -5029,8 +5029,7 @@ static inline int rx_proc(struct net_device *dev, struct ksz_hw* hw,
 		 */
 		skb_reserve(skb, 2);
 
-		memcpy(skb_put(skb, packet_len),
-			dma_buf->skb->data, packet_len);
+		skb_put_data(skb, dma_buf->skb->data, packet_len);
 	} while (0);
 
 	skb->protocol = eth_type_trans(skb, dev);
diff --git a/drivers/net/ethernet/nxp/lpc_eth.c b/drivers/net/ethernet/nxp/lpc_eth.c
index 55a5548d6add..5a3c890d5314 100644
--- a/drivers/net/ethernet/nxp/lpc_eth.c
+++ b/drivers/net/ethernet/nxp/lpc_eth.c
@@ -984,11 +984,10 @@ static int __lpc_handle_recv(struct net_device *ndev, int budget)
 			if (!skb) {
 				ndev->stats.rx_dropped++;
 			} else {
-				prdbuf = skb_put(skb, len);
-
 				/* Copy packet from buffer */
-				memcpy(prdbuf, pldat->rx_buff_v +
-					rxconsidx * ENET_MAXF_SIZE, len);
+				prdbuf = skb_put_data(skb,
+						      pldat->rx_buff_v + rxconsidx * ENET_MAXF_SIZE,
+						      len);
 
 				/* Pass to upper layer */
 				skb->protocol = eth_type_trans(skb, ndev);
diff --git a/drivers/net/ethernet/qlogic/qede/qede_fp.c b/drivers/net/ethernet/qlogic/qede/qede_fp.c
index 37d784f6cdda..8463467b265a 100644
--- a/drivers/net/ethernet/qlogic/qede/qede_fp.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_fp.c
@@ -942,8 +942,7 @@ static struct sk_buff *qede_rx_allocate_skb(struct qede_dev *edev,
 	 * re-use the already allcoated & mapped memory.
 	 */
 	if (len + pad <= edev->rx_copybreak) {
-		memcpy(skb_put(skb, len),
-		       page_address(page) + offset, len);
+		skb_put_data(skb, page_address(page) + offset, len);
 		qede_reuse_page(rxq, bd);
 		goto out;
 	}
diff --git a/drivers/net/ethernet/qlogic/qlge/qlge_main.c b/drivers/net/ethernet/qlogic/qlge/qlge_main.c
index 55efbcdfa7f9..c518a7b8eefb 100644
--- a/drivers/net/ethernet/qlogic/qlge/qlge_main.c
+++ b/drivers/net/ethernet/qlogic/qlge/qlge_main.c
@@ -1577,7 +1577,7 @@ static void ql_process_mac_rx_page(struct ql_adapter *qdev,
 		rx_ring->rx_dropped++;
 		goto err_out;
 	}
-	memcpy(skb_put(skb, hlen), addr, hlen);
+	skb_put_data(skb, addr, hlen);
 	netif_printk(qdev, rx_status, KERN_DEBUG, qdev->ndev,
 		     "%d bytes of headers and data in large. Chain page to new skb and pull tail.\n",
 		     length);
@@ -1654,7 +1654,7 @@ static void ql_process_mac_rx_skb(struct ql_adapter *qdev,
 				    dma_unmap_len(sbq_desc, maplen),
 				    PCI_DMA_FROMDEVICE);
 
-	memcpy(skb_put(new_skb, length), skb->data, length);
+	skb_put_data(new_skb, skb->data, length);
 
 	pci_dma_sync_single_for_device(qdev->pdev,
 				       dma_unmap_addr(sbq_desc, mapaddr),
@@ -1817,8 +1817,7 @@ static struct sk_buff *ql_build_rx_skb(struct ql_adapter *qdev,
 						    dma_unmap_len
 						    (sbq_desc, maplen),
 						    PCI_DMA_FROMDEVICE);
-			memcpy(skb_put(skb, length),
-			       sbq_desc->p.skb->data, length);
+			skb_put_data(skb, sbq_desc->p.skb->data, length);
 			pci_dma_sync_single_for_device(qdev->pdev,
 						       dma_unmap_addr
 						       (sbq_desc,
diff --git a/drivers/net/ethernet/silan/sc92031.c b/drivers/net/ethernet/silan/sc92031.c
index 9af74759927a..d347a0e303dc 100644
--- a/drivers/net/ethernet/silan/sc92031.c
+++ b/drivers/net/ethernet/silan/sc92031.c
@@ -795,12 +795,12 @@ static void _sc92031_rx_tasklet(struct net_device *dev)
 		}
 
 		if ((rx_ring_offset + pkt_size) > RX_BUF_LEN) {
-			memcpy(skb_put(skb, RX_BUF_LEN - rx_ring_offset),
-				rx_ring + rx_ring_offset, RX_BUF_LEN - rx_ring_offset);
-			memcpy(skb_put(skb, pkt_size - (RX_BUF_LEN - rx_ring_offset)),
-				rx_ring, pkt_size - (RX_BUF_LEN - rx_ring_offset));
+			skb_put_data(skb, rx_ring + rx_ring_offset,
+				     RX_BUF_LEN - rx_ring_offset);
+			skb_put_data(skb, rx_ring,
+				     pkt_size - (RX_BUF_LEN - rx_ring_offset));
 		} else {
-			memcpy(skb_put(skb, pkt_size), rx_ring + rx_ring_offset, pkt_size);
+			skb_put_data(skb, rx_ring + rx_ring_offset, pkt_size);
 		}
 
 		skb->protocol = eth_type_trans(skb, dev);
diff --git a/drivers/net/fjes/fjes_main.c b/drivers/net/fjes/fjes_main.c
index 7cdaf486605a..5f63bc9fb57a 100644
--- a/drivers/net/fjes/fjes_main.c
+++ b/drivers/net/fjes/fjes_main.c
@@ -1157,8 +1157,7 @@ static int fjes_poll(struct napi_struct *napi, int budget)
 				hw->ep_shm_info[cur_epid].net_stats
 							 .rx_errors += 1;
 			} else {
-				memcpy(skb_put(skb, frame_len),
-				       frame, frame_len);
+				skb_put_data(skb, frame, frame_len);
 				skb->protocol = eth_type_trans(skb, netdev);
 				skb->ip_summed = CHECKSUM_UNNECESSARY;
 
diff --git a/drivers/net/hamradio/mkiss.c b/drivers/net/hamradio/mkiss.c
index ef2224d3acef..b9af9b6cd349 100644
--- a/drivers/net/hamradio/mkiss.c
+++ b/drivers/net/hamradio/mkiss.c
@@ -299,7 +299,7 @@ static void ax_bump(struct mkiss *ax)
 		return;
 	}
 
-	memcpy(skb_put(skb,count), ax->rbuff, count);
+	skb_put_data(skb, ax->rbuff, count);
 	skb->protocol = ax25_type_trans(skb, ax->dev);
 	netif_rx(skb);
 	ax->dev->stats.rx_packets++;
diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 91d46c3c11b0..a2e51b635f25 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -966,8 +966,8 @@ static void rx_int(struct net_device *dev, u32 rxlimit, u32 index)
 								    pkt_len,
 								    PCI_DMA_FROMDEVICE);
 
-					memcpy(skb_put(skb, pkt_len),
-					       rx_skb->data, pkt_len);
+					skb_put_data(skb, rx_skb->data,
+						     pkt_len);
 
 					pci_dma_sync_single_for_device(rrpriv->pci_dev,
 								       desc->addr.addrlo,
diff --git a/drivers/net/hyperv/netvsc_drv.c b/drivers/net/hyperv/netvsc_drv.c
index 65d3ecac72a0..12c91f3d5cc6 100644
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@ -718,7 +718,7 @@ static struct sk_buff *netvsc_alloc_recv_skb(struct net_device *net,
 	 * Copy to skb. This copy is needed here since the memory pointed by
 	 * hv_netvsc_packet cannot be deallocated
 	 */
-	memcpy(skb_put(skb, buflen), data, buflen);
+	skb_put_data(skb, data, buflen);
 
 	skb->protocol = eth_type_trans(skb, net);
 
diff --git a/drivers/net/ieee802154/at86rf230.c b/drivers/net/ieee802154/at86rf230.c
index 3af5439033e3..a990594d299a 100644
--- a/drivers/net/ieee802154/at86rf230.c
+++ b/drivers/net/ieee802154/at86rf230.c
@@ -724,7 +724,7 @@ at86rf230_rx_read_frame_complete(void *context)
 		return;
 	}
 
-	memcpy(skb_put(skb, len), buf + 2, len);
+	skb_put_data(skb, buf + 2, len);
 	ieee802154_rx_irqsafe(lp->hw, skb, lqi);
 	kfree(ctx);
 }
* Unmerged path drivers/net/ieee802154/ca8210.c
diff --git a/drivers/net/ieee802154/mrf24j40.c b/drivers/net/ieee802154/mrf24j40.c
index 7b131f8e4093..cf5d676c479a 100644
--- a/drivers/net/ieee802154/mrf24j40.c
+++ b/drivers/net/ieee802154/mrf24j40.c
@@ -773,7 +773,7 @@ static void mrf24j40_handle_rx_read_buf_complete(void *context)
 		return;
 	}
 
-	memcpy(skb_put(skb, len), rx_local_buf, len);
+	skb_put_data(skb, rx_local_buf, len);
 	ieee802154_rx_irqsafe(devrec->hw, skb, 0);
 
 #ifdef DEBUG
diff --git a/drivers/net/irda/smsc-ircc2.c b/drivers/net/irda/smsc-ircc2.c
index 9f059489357d..012f2e79c147 100644
--- a/drivers/net/irda/smsc-ircc2.c
+++ b/drivers/net/irda/smsc-ircc2.c
@@ -1458,7 +1458,7 @@ static void smsc_ircc_dma_receive_complete(struct smsc_ircc_cb *self)
 	/* Make sure IP header gets aligned */
 	skb_reserve(skb, 1);
 
-	memcpy(skb_put(skb, len), self->rx_buff.data, len);
+	skb_put_data(skb, self->rx_buff.data, len);
 	self->netdev->stats.rx_packets++;
 	self->netdev->stats.rx_bytes += len;
 
diff --git a/drivers/net/irda/vlsi_ir.c b/drivers/net/irda/vlsi_ir.c
index 8e1e3b9ce7af..8dee0ff868e1 100644
--- a/drivers/net/irda/vlsi_ir.c
+++ b/drivers/net/irda/vlsi_ir.c
@@ -595,7 +595,7 @@ static int vlsi_process_rx(struct vlsi_ring *r, struct ring_descr *rd)
 	skb = rd->skb;
 	rd->skb = NULL;
 	skb->dev = ndev;
-	memcpy(skb_put(skb,len), rd->buf, len);
+	skb_put_data(skb, rd->buf, len);
 	skb_reset_mac_header(skb);
 	if (in_interrupt())
 		netif_rx(skb);
diff --git a/drivers/net/ppp/ppp_async.c b/drivers/net/ppp/ppp_async.c
index 8711f2af34a8..73324951fce0 100644
--- a/drivers/net/ppp/ppp_async.c
+++ b/drivers/net/ppp/ppp_async.c
@@ -894,8 +894,7 @@ ppp_async_input(struct asyncppp *ap, const unsigned char *buf,
 				/* packet overflowed MRU */
 				ap->state |= SC_TOSS;
 			} else {
-				sp = skb_put(skb, n);
-				memcpy(sp, buf, n);
+				sp = skb_put_data(skb, buf, n);
 				if (ap->state & SC_ESCAPE) {
 					sp[0] ^= PPP_TRANS;
 					ap->state &= ~SC_ESCAPE;
diff --git a/drivers/net/ppp/ppp_synctty.c b/drivers/net/ppp/ppp_synctty.c
index 0741ba835986..ae01692e13a3 100644
--- a/drivers/net/ppp/ppp_synctty.c
+++ b/drivers/net/ppp/ppp_synctty.c
@@ -697,8 +697,7 @@ ppp_sync_input(struct syncppp *ap, const unsigned char *buf,
 		goto err;
 	}
 
-	p = skb_put(skb, count);
-	memcpy(p, buf, count);
+	p = skb_put_data(skb, buf, count);
 
 	/* strip address/control field if present */
 	p = skb->data;
diff --git a/drivers/net/slip/slip.c b/drivers/net/slip/slip.c
index 3a65fc0cbfe5..b932cc86292b 100644
--- a/drivers/net/slip/slip.c
+++ b/drivers/net/slip/slip.c
@@ -364,7 +364,7 @@ static void sl_bump(struct slip *sl)
 		return;
 	}
 	skb->dev = dev;
-	memcpy(skb_put(skb, count), sl->rbuff, count);
+	skb_put_data(skb, sl->rbuff, count);
 	skb_reset_mac_header(skb);
 	skb->protocol = htons(ETH_P_IP);
 	netif_rx_ni(skb);
diff --git a/drivers/net/usb/asix_common.c b/drivers/net/usb/asix_common.c
index 10f6a41ed699..f5c17134cf79 100644
--- a/drivers/net/usb/asix_common.c
+++ b/drivers/net/usb/asix_common.c
@@ -165,8 +165,8 @@ int asix_rx_fixup_internal(struct usbnet *dev, struct sk_buff *skb,
 		}
 
 		if (rx->ax_skb) {
-			data = skb_put(rx->ax_skb, copy_length);
-			memcpy(data, skb->data + offset, copy_length);
+			data = skb_put_data(rx->ax_skb, skb->data + offset,
+					    copy_length);
 			if (!rx->remaining)
 				usbnet_skb_return(dev, rx->ax_skb);
 		}
diff --git a/drivers/net/usb/cdc-phonet.c b/drivers/net/usb/cdc-phonet.c
index 1f7a005beb3c..b6eddc090917 100644
--- a/drivers/net/usb/cdc-phonet.c
+++ b/drivers/net/usb/cdc-phonet.c
@@ -162,7 +162,7 @@ static void rx_complete(struct urb *req)
 			skb = pnd->rx_skb = netdev_alloc_skb(dev, 12);
 			if (likely(skb)) {
 				/* Can't use pskb_pull() on page in IRQ */
-				memcpy(skb_put(skb, 1), page_address(page), 1);
+				skb_put_data(skb, page_address(page), 1);
 				skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags,
 						page, 1, req->actual_length,
 						PAGE_SIZE);
diff --git a/drivers/net/usb/cdc_mbim.c b/drivers/net/usb/cdc_mbim.c
index ade0d5ec45c5..0702197fbb72 100644
--- a/drivers/net/usb/cdc_mbim.c
+++ b/drivers/net/usb/cdc_mbim.c
@@ -398,7 +398,7 @@ static struct sk_buff *cdc_mbim_process_dgram(struct usbnet *dev, u8 *buf, size_
 	memcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);
 
 	/* add datagram */
-	memcpy(skb_put(skb, len), buf, len);
+	skb_put_data(skb, buf, len);
 
 	/* map MBIM session to VLAN */
 	if (tci)
diff --git a/drivers/net/usb/cdc_ncm.c b/drivers/net/usb/cdc_ncm.c
index 3e582e83ebb5..119169f72a0c 100644
--- a/drivers/net/usb/cdc_ncm.c
+++ b/drivers/net/usb/cdc_ncm.c
@@ -1181,7 +1181,7 @@ cdc_ncm_fill_tx_frame(struct usbnet *dev, struct sk_buff *skb, __le32 sign)
 		ndp16->dpe16[index].wDatagramLength = cpu_to_le16(skb->len);
 		ndp16->dpe16[index].wDatagramIndex = cpu_to_le16(skb_out->len);
 		ndp16->wLength = cpu_to_le16(ndplen + sizeof(struct usb_cdc_ncm_dpe16));
-		memcpy(skb_put(skb_out, skb->len), skb->data, skb->len);
+		skb_put_data(skb_out, skb->data, skb->len);
 		ctx->tx_curr_frame_payload += skb->len;	/* count real tx payload data */
 		dev_kfree_skb_any(skb);
 		skb = NULL;
@@ -1230,7 +1230,7 @@ cdc_ncm_fill_tx_frame(struct usbnet *dev, struct sk_buff *skb, __le32 sign)
 		nth16 = (struct usb_cdc_ncm_nth16 *)skb_out->data;
 		cdc_ncm_align_tail(skb_out, ctx->tx_ndp_modulus, 0, ctx->tx_max);
 		nth16->wNdpIndex = cpu_to_le16(skb_out->len);
-		memcpy(skb_put(skb_out, ctx->max_ndp_size), ctx->delayed_ndp16, ctx->max_ndp_size);
+		skb_put_data(skb_out, ctx->delayed_ndp16, ctx->max_ndp_size);
 
 		/* Zero out delayed NDP - signature checking will naturally fail. */
 		ndp16 = memset(ctx->delayed_ndp16, 0, ctx->max_ndp_size);
@@ -1496,7 +1496,7 @@ next_ndp:
 			skb = netdev_alloc_skb_ip_align(dev->net,  len);
 			if (!skb)
 				goto error;
-			memcpy(skb_put(skb, len), skb_in->data + offset, len);
+			skb_put_data(skb, skb_in->data + offset, len);
 			usbnet_skb_return(dev, skb);
 			payload += len;	/* count payload bytes in this NTB */
 		}
diff --git a/drivers/net/usb/gl620a.c b/drivers/net/usb/gl620a.c
index 1cc24e6f23e2..29276e54bb8b 100644
--- a/drivers/net/usb/gl620a.c
+++ b/drivers/net/usb/gl620a.c
@@ -121,8 +121,7 @@ static int genelink_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
 		if (gl_skb) {
 
 			// copy the packet data to the new skb
-			memcpy(skb_put(gl_skb, size),
-					packet->packet_data, size);
+			skb_put_data(gl_skb, packet->packet_data, size);
 			usbnet_skb_return(dev, gl_skb);
 		}
 
diff --git a/drivers/net/usb/hso.c b/drivers/net/usb/hso.c
index 61eea5cb637f..285204180293 100644
--- a/drivers/net/usb/hso.c
+++ b/drivers/net/usb/hso.c
@@ -911,11 +911,9 @@ static void packetizeRx(struct hso_net *odev, unsigned char *ip_pkt,
 
 				/* Copy what we got so far. make room for iphdr
 				 * after tail. */
-				tmp_rx_buf =
-				    skb_put(odev->skb_rx_buf,
-					    sizeof(struct iphdr));
-				memcpy(tmp_rx_buf, (char *)&(odev->rx_ip_hdr),
-				       sizeof(struct iphdr));
+				tmp_rx_buf = skb_put_data(odev->skb_rx_buf,
+							  (char *)&(odev->rx_ip_hdr),
+							  sizeof(struct iphdr));
 
 				/* ETH_HLEN */
 				odev->rx_buf_size = sizeof(struct iphdr);
@@ -934,8 +932,9 @@ static void packetizeRx(struct hso_net *odev, unsigned char *ip_pkt,
 			/* Copy the rest of the bytes that are left in the
 			 * buffer into the waiting sk_buf. */
 			/* Make room for temp_bytes after tail. */
-			tmp_rx_buf = skb_put(odev->skb_rx_buf, temp_bytes);
-			memcpy(tmp_rx_buf, ip_pkt + buffer_offset, temp_bytes);
+			tmp_rx_buf = skb_put_data(odev->skb_rx_buf,
+						  ip_pkt + buffer_offset,
+						  temp_bytes);
 
 			odev->rx_buf_missing -= temp_bytes;
 			count -= temp_bytes;
diff --git a/drivers/net/usb/ipheth.c b/drivers/net/usb/ipheth.c
index 76465b117b72..0f213ea22c75 100644
--- a/drivers/net/usb/ipheth.c
+++ b/drivers/net/usb/ipheth.c
@@ -253,7 +253,7 @@ static void ipheth_rcvbulk_callback(struct urb *urb)
 		return;
 	}
 
-	memcpy(skb_put(skb, len), buf, len);
+	skb_put_data(skb, buf, len);
 	skb->dev = dev->net;
 	skb->protocol = eth_type_trans(skb, dev->net);
 
diff --git a/drivers/net/usb/lg-vl600.c b/drivers/net/usb/lg-vl600.c
index 5714107533bb..d633492bf9eb 100644
--- a/drivers/net/usb/lg-vl600.c
+++ b/drivers/net/usb/lg-vl600.c
@@ -135,7 +135,7 @@ static int vl600_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
 		}
 
 		buf = s->current_rx_buf;
-		memcpy(skb_put(buf, skb->len), skb->data, skb->len);
+		skb_put_data(buf, skb->data, skb->len);
 	} else if (skb->len < 4) {
 		netif_err(dev, ifup, dev->net, "Frame too short\n");
 		dev->net->stats.rx_length_errors++;
diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c
index 77ae705f278d..df2ac51aae54 100644
--- a/drivers/net/usb/qmi_wwan.c
+++ b/drivers/net/usb/qmi_wwan.c
@@ -187,7 +187,7 @@ static int qmimux_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
 			goto skip;
 		}
 
-		memcpy(skb_put(skbn, len), skb->data + offset, len);
+		skb_put_data(skbn, skb->data + offset, len);
 		if (netif_rx(skbn) != NET_RX_SUCCESS)
 			return 0;
 
diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index 7b0841ddd139..48d53c1081df 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -259,7 +259,7 @@ static struct sk_buff *page_to_skb(struct virtnet_info *vi,
 	copy = len;
 	if (copy > skb_tailroom(skb))
 		copy = skb_tailroom(skb);
-	memcpy(skb_put(skb, copy), p, copy);
+	skb_put_data(skb, p, copy);
 
 	len -= copy;
 	offset += copy;
diff --git a/drivers/net/wan/farsync.c b/drivers/net/wan/farsync.c
index e97377fcea3b..4ac2ed327e67 100644
--- a/drivers/net/wan/farsync.c
+++ b/drivers/net/wan/farsync.c
@@ -861,7 +861,7 @@ fst_rx_dma_complete(struct fst_card_info *card, struct fst_port_info *port,
 
 	dbg(DBG_TX, "fst_rx_dma_complete\n");
 	pi = port->index;
-	memcpy(skb_put(skb, len), card->rx_dma_handle_host, len);
+	skb_put_data(skb, card->rx_dma_handle_host, len);
 
 	/* Reset buffer descriptor */
 	FST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);
diff --git a/drivers/net/wan/hdlc_ppp.c b/drivers/net/wan/hdlc_ppp.c
index 0d7645581f91..bac4cf02a4ce 100644
--- a/drivers/net/wan/hdlc_ppp.c
+++ b/drivers/net/wan/hdlc_ppp.c
@@ -234,9 +234,9 @@ static void ppp_tx_cp(struct net_device *dev, u16 pid, u8 code,
 	cp->len = htons(sizeof(struct cp_header) + magic_len + len);
 
 	if (magic_len)
-		memcpy(skb_put(skb, magic_len), &magic, magic_len);
+		skb_put_data(skb, &magic, magic_len);
 	if (len)
-		memcpy(skb_put(skb, len), data, len);
+		skb_put_data(skb, data, len);
 
 #if DEBUG_CP
 	BUG_ON(code >= CP_CODES);
diff --git a/drivers/net/wan/x25_asy.c b/drivers/net/wan/x25_asy.c
index 5895f1978691..d064ec6d9130 100644
--- a/drivers/net/wan/x25_asy.c
+++ b/drivers/net/wan/x25_asy.c
@@ -201,7 +201,7 @@ static void x25_asy_bump(struct x25_asy *sl)
 		return;
 	}
 	skb_push(skb, 1);	/* LAPB internal control */
-	memcpy(skb_put(skb, count), sl->rbuff, count);
+	skb_put_data(skb, sl->rbuff, count);
 	skb->protocol = x25_type_trans(skb, sl->dev);
 	err = lapb_data_received(skb->dev, skb);
 	if (err != LAPB_OK) {
diff --git a/drivers/net/wimax/i2400m/netdev.c b/drivers/net/wimax/i2400m/netdev.c
index 47ef231a031a..10eea67f8d6e 100644
--- a/drivers/net/wimax/i2400m/netdev.c
+++ b/drivers/net/wimax/i2400m/netdev.c
@@ -508,7 +508,7 @@ void i2400m_net_rx(struct i2400m *i2400m, struct sk_buff *skb_rx,
 			net_dev->stats.rx_dropped++;
 			goto error_skb_realloc;
 		}
-		memcpy(skb_put(skb, buf_len), buf, buf_len);
+		skb_put_data(skb, buf, buf_len);
 	}
 	i2400m_rx_fake_eth_header(i2400m->wimax_dev.net_dev,
 				  skb->data - ETH_HLEN,
diff --git a/drivers/net/wireless/adm8211.c b/drivers/net/wireless/adm8211.c
index 2b0d1966552a..0d10f30b9c85 100644
--- a/drivers/net/wireless/adm8211.c
+++ b/drivers/net/wireless/adm8211.c
@@ -391,9 +391,9 @@ static void adm8211_interrupt_rci(struct ieee80211_hw *dev)
 					priv->pdev,
 					priv->rx_buffers[entry].mapping,
 					pktlen, PCI_DMA_FROMDEVICE);
-				memcpy(skb_put(skb, pktlen),
-				       skb_tail_pointer(priv->rx_buffers[entry].skb),
-				       pktlen);
+				skb_put_data(skb,
+					     skb_tail_pointer(priv->rx_buffers[entry].skb),
+					     pktlen);
 				pci_dma_sync_single_for_device(
 					priv->pdev,
 					priv->rx_buffers[entry].mapping,
* Unmerged path drivers/net/wireless/ath/ath10k/wmi.c
* Unmerged path drivers/net/wireless/ath/ath9k/wmi.c
diff --git a/drivers/net/wireless/atmel.c b/drivers/net/wireless/atmel.c
index a55ae6494c3b..b580bec6be90 100644
--- a/drivers/net/wireless/atmel.c
+++ b/drivers/net/wireless/atmel.c
@@ -1038,9 +1038,8 @@ static void frag_rx_path(struct atmel_private *priv,
 				priv->dev->stats.rx_dropped++;
 			} else {
 				skb_reserve(skb, 2);
-				memcpy(skb_put(skb, priv->frag_len + 12),
-				       priv->rx_buf,
-				       priv->frag_len + 12);
+				skb_put_data(skb, priv->rx_buf,
+				             priv->frag_len + 12);
 				skb->protocol = eth_type_trans(skb, priv->dev);
 				skb->ip_summed = CHECKSUM_NONE;
 				netif_rx(skb);
diff --git a/drivers/net/wireless/b43legacy/dma.c b/drivers/net/wireless/b43legacy/dma.c
index faeafe219c57..cc23bd5fbe61 100644
--- a/drivers/net/wireless/b43legacy/dma.c
+++ b/drivers/net/wireless/b43legacy/dma.c
@@ -1076,7 +1076,7 @@ static int dma_tx_fragment(struct b43legacy_dmaring *ring,
 			goto out_unmap_hdr;
 		}
 
-		memcpy(skb_put(bounce_skb, skb->len), skb->data, skb->len);
+		skb_put_data(bounce_skb, skb->data, skb->len);
 		memcpy(bounce_skb->cb, skb->cb, sizeof(skb->cb));
 		bounce_skb->dev = skb->dev;
 		skb_set_queue_mapping(bounce_skb, skb_get_queue_mapping(skb));
diff --git a/drivers/net/wireless/hostap/hostap_80211_tx.c b/drivers/net/wireless/hostap/hostap_80211_tx.c
index 344a981a052e..0ea2c48e4470 100644
--- a/drivers/net/wireless/hostap/hostap_80211_tx.c
+++ b/drivers/net/wireless/hostap/hostap_80211_tx.c
@@ -242,7 +242,7 @@ netdev_tx_t hostap_data_start_xmit(struct sk_buff *skb,
 		memcpy(skb_push(skb, encaps_len), encaps_data, encaps_len);
 	memcpy(skb_push(skb, hdr_len), &hdr, hdr_len);
 	if (use_wds == WDS_OWN_FRAME) {
-		memcpy(skb_put(skb, ETH_ALEN), &hdr.addr4, ETH_ALEN);
+		skb_put_data(skb, &hdr.addr4, ETH_ALEN);
 	}
 
 	iface->stats.tx_packets++;
diff --git a/drivers/net/wireless/hostap/hostap_ap.c b/drivers/net/wireless/hostap/hostap_ap.c
index d6033a8e5dea..fc41fdf655eb 100644
--- a/drivers/net/wireless/hostap/hostap_ap.c
+++ b/drivers/net/wireless/hostap/hostap_ap.c
@@ -1000,7 +1000,7 @@ static void prism2_send_mgmt(struct net_device *dev,
 	hdrlen = hostap_80211_get_hdrlen(cpu_to_le16(type_subtype));
 	hdr = (struct ieee80211_hdr *) skb_put(skb, hdrlen);
 	if (body)
-		memcpy(skb_put(skb, body_len), body, body_len);
+		skb_put_data(skb, body, body_len);
 
 	memset(hdr, 0, hdrlen);
 
diff --git a/drivers/net/wireless/hostap/hostap_hw.c b/drivers/net/wireless/hostap/hostap_hw.c
index 6307a4e36c85..2f6cbb0074ac 100644
--- a/drivers/net/wireless/hostap/hostap_hw.c
+++ b/drivers/net/wireless/hostap/hostap_hw.c
@@ -2000,7 +2000,7 @@ static void prism2_rx(local_info_t *local)
 		goto rx_dropped;
 	}
 	skb->dev = dev;
-	memcpy(skb_put(skb, hdr_len), &rxdesc, hdr_len);
+	skb_put_data(skb, &rxdesc, hdr_len);
 
 	if (len > 0)
 		res = hfa384x_from_bap(dev, BAP0, skb_put(skb, len), len);
@@ -2204,9 +2204,9 @@ static void hostap_tx_callback(local_info_t *local,
 		return;
 	}
 
-	memcpy(skb_put(skb, hdrlen), (void *) &txdesc->frame_control, hdrlen);
+	skb_put_data(skb, (void *)&txdesc->frame_control, hdrlen);
 	if (payload)
-		memcpy(skb_put(skb, len), payload, len);
+		skb_put_data(skb, payload, len);
 
 	skb->dev = local->dev;
 	skb_reset_mac_header(skb);
@@ -2357,8 +2357,7 @@ static void prism2_txexc(local_info_t *local)
 		struct sk_buff *skb;
 		skb = dev_alloc_skb(sizeof(txdesc));
 		if (skb) {
-			memcpy(skb_put(skb, sizeof(txdesc)), &txdesc,
-			       sizeof(txdesc));
+			skb_put_data(skb, &txdesc, sizeof(txdesc));
 			skb_queue_tail(&local->sta_tx_exc_list, skb);
 			tasklet_schedule(&local->sta_tx_exc_tasklet);
 		}
@@ -2455,7 +2454,7 @@ static void prism2_info(local_info_t *local)
 		goto out;
 	}
 
-	memcpy(skb_put(skb, sizeof(info)), &info, sizeof(info));
+	skb_put_data(skb, &info, sizeof(info));
 	if (left > 0 && hfa384x_from_bap(dev, BAP0, skb_put(skb, left), left))
 	{
 		spin_unlock(&local->baplock);
diff --git a/drivers/net/wireless/hostap/hostap_main.c b/drivers/net/wireless/hostap/hostap_main.c
index 15f0fad39add..19a036d71bd6 100644
--- a/drivers/net/wireless/hostap/hostap_main.c
+++ b/drivers/net/wireless/hostap/hostap_main.c
@@ -1061,7 +1061,7 @@ int prism2_sta_send_mgmt(local_info_t *local, u8 *dst, u16 stype,
 	memcpy(mgmt->sa, dev->dev_addr, ETH_ALEN);
 	memcpy(mgmt->bssid, dst, ETH_ALEN);
 	if (body)
-		memcpy(skb_put(skb, bodylen), body, bodylen);
+		skb_put_data(skb, body, bodylen);
 
 	meta = (struct hostap_skb_tx_data *) skb->cb;
 	memset(meta, 0, sizeof(*meta));
diff --git a/drivers/net/wireless/ipw2x00/ipw2200.c b/drivers/net/wireless/ipw2x00/ipw2200.c
index e0f00c7afc46..52fad170d0ac 100644
--- a/drivers/net/wireless/ipw2x00/ipw2200.c
+++ b/drivers/net/wireless/ipw2x00/ipw2200.c
@@ -10371,8 +10371,9 @@ static int ipw_tx_skb(struct ipw_priv *priv, struct libipw_txb *txb,
 
 				printk(KERN_INFO "Adding frag %d %d...\n",
 				       j, size);
-				memcpy(skb_put(skb, size),
-				       txb->fragments[j]->data + hdr_len, size);
+				skb_put_data(skb,
+					     txb->fragments[j]->data + hdr_len,
+					     size);
 			}
 			dev_kfree_skb_any(txb->fragments[i]);
 			txb->fragments[i] = skb;
diff --git a/drivers/net/wireless/ipw2x00/libipw_tx.c b/drivers/net/wireless/ipw2x00/libipw_tx.c
index e8c039879b05..bbd7166ac90a 100644
--- a/drivers/net/wireless/ipw2x00/libipw_tx.c
+++ b/drivers/net/wireless/ipw2x00/libipw_tx.c
@@ -359,7 +359,7 @@ netdev_tx_t libipw_xmit(struct sk_buff *skb, struct net_device *dev)
 			goto failed;
 
 		skb_reserve(skb_new, crypt->ops->extra_msdu_prefix_len);
-		memcpy(skb_put(skb_new, hdr_len), &header, hdr_len);
+		skb_put_data(skb_new, &header, hdr_len);
 		snapped = 1;
 		libipw_copy_snap(skb_put(skb_new, SNAP_SIZE + sizeof(u16)),
 				    ether_type);
@@ -470,9 +470,7 @@ netdev_tx_t libipw_xmit(struct sk_buff *skb, struct net_device *dev)
 			skb_reserve(skb_frag,
 				    crypt->ops->extra_mpdu_prefix_len);
 
-		frag_hdr =
-		    (struct libipw_hdr_3addrqos *)skb_put(skb_frag, hdr_len);
-		memcpy(frag_hdr, &header, hdr_len);
+		frag_hdr = skb_put_data(skb_frag, &header, hdr_len);
 
 		/* If this is not the last fragment, then add the MOREFRAGS
 		 * bit to the frame control */
diff --git a/drivers/net/wireless/libertas/if_sdio.c b/drivers/net/wireless/libertas/if_sdio.c
index 45578335e420..df28fb02c35e 100644
--- a/drivers/net/wireless/libertas/if_sdio.c
+++ b/drivers/net/wireless/libertas/if_sdio.c
@@ -261,9 +261,7 @@ static int if_sdio_handle_data(struct if_sdio_card *card,
 
 	skb_reserve(skb, NET_IP_ALIGN);
 
-	data = skb_put(skb, size);
-
-	memcpy(data, buffer, size);
+	data = skb_put_data(skb, buffer, size);
 
 	lbs_process_rxed_packet(card->priv, skb);
 
* Unmerged path drivers/net/wireless/mediatek/mt7601u/dma.c
* Unmerged path drivers/net/wireless/mediatek/mt7601u/mcu.c
diff --git a/drivers/net/wireless/orinoco/main.c b/drivers/net/wireless/orinoco/main.c
index 38ec8d19ac29..34b6fd9481f4 100644
--- a/drivers/net/wireless/orinoco/main.c
+++ b/drivers/net/wireless/orinoco/main.c
@@ -807,7 +807,7 @@ static void orinoco_rx_monitor(struct net_device *dev, u16 rxfid,
 	}
 
 	/* Copy the 802.11 header to the skb */
-	memcpy(skb_put(skb, hdrlen), &(desc->frame_ctl), hdrlen);
+	skb_put_data(skb, &(desc->frame_ctl), hdrlen);
 	skb_reset_mac_header(skb);
 
 	/* If any, copy the data from the card to the skb */
diff --git a/drivers/net/wireless/p54/p54spi.c b/drivers/net/wireless/p54/p54spi.c
index 978e7eb26567..c3262f22d3c4 100644
--- a/drivers/net/wireless/p54/p54spi.c
+++ b/drivers/net/wireless/p54/p54spi.c
@@ -374,9 +374,9 @@ static int p54spi_rx(struct p54s_priv *priv)
 	}
 
 	if (len <= READAHEAD_SZ) {
-		memcpy(skb_put(skb, len), rx_head + 1, len);
+		skb_put_data(skb, rx_head + 1, len);
 	} else {
-		memcpy(skb_put(skb, READAHEAD_SZ), rx_head + 1, READAHEAD_SZ);
+		skb_put_data(skb, rx_head + 1, READAHEAD_SZ);
 		p54spi_spi_read(priv, SPI_ADRS_DMA_DATA,
 				skb_put(skb, len - READAHEAD_SZ),
 				len - READAHEAD_SZ);
diff --git a/drivers/net/wireless/p54/txrx.c b/drivers/net/wireless/p54/txrx.c
index f95de0d16216..feb06ff4a77e 100644
--- a/drivers/net/wireless/p54/txrx.c
+++ b/drivers/net/wireless/p54/txrx.c
@@ -906,8 +906,9 @@ void p54_tx_80211(struct ieee80211_hw *dev,
 		if (info->control.hw_key->cipher == WLAN_CIPHER_SUITE_TKIP) {
 			/* reserve space for the MIC key */
 			len += 8;
-			memcpy(skb_put(skb, 8), &(info->control.hw_key->key
-				[NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY]), 8);
+			skb_put_data(skb,
+				     &(info->control.hw_key->key[NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY]),
+				     8);
 		}
 		/* reserve some space for ICV */
 		len += info->control.hw_key->icv_len;
* Unmerged path drivers/net/wireless/quantenna/qtnfmac/pearl/pcie.c
* Unmerged path drivers/net/wireless/quantenna/qtnfmac/qlink_util.h
* Unmerged path drivers/net/wireless/realtek/rtlwifi/pci.c
* Unmerged path drivers/net/wireless/rsi/rsi_91x_mgmt.c
* Unmerged path drivers/net/wireless/st/cw1200/scan.c
diff --git a/drivers/net/wireless/ti/wl1251/main.c b/drivers/net/wireless/ti/wl1251/main.c
index 3291ffa95273..a1c7f9aedecc 100644
--- a/drivers/net/wireless/ti/wl1251/main.c
+++ b/drivers/net/wireless/ti/wl1251/main.c
@@ -913,7 +913,7 @@ static int wl1251_op_hw_scan(struct ieee80211_hw *hw,
 		goto out_idle;
 	}
 	if (req->ie_len)
-		memcpy(skb_put(skb, req->ie_len), req->ie, req->ie_len);
+		skb_put_data(skb, req->ie, req->ie_len);
 
 	ret = wl1251_cmd_template_set(wl, CMD_PROBE_REQ, skb->data,
 				      skb->len);
* Unmerged path drivers/net/wireless/ti/wlcore/cmd.c
diff --git a/drivers/net/wireless/ti/wlcore/rx.c b/drivers/net/wireless/ti/wlcore/rx.c
index 6791a1a6afba..b277d2fd41a1 100644
--- a/drivers/net/wireless/ti/wlcore/rx.c
+++ b/drivers/net/wireless/ti/wlcore/rx.c
@@ -168,15 +168,13 @@ static int wl1271_rx_handle_data(struct wl1271 *wl, u8 *data, u32 length,
 	/* reserve the unaligned payload(if any) */
 	skb_reserve(skb, reserved);
 
-	buf = skb_put(skb, pkt_data_len);
-
 	/*
 	 * Copy packets from aggregation buffer to the skbs without rx
 	 * descriptor and with packet payload aligned care. In case of unaligned
 	 * packets copy the packets in offset of 2 bytes guarantee IP header
 	 * payload aligned to 4 bytes.
 	 */
-	memcpy(buf, data + sizeof(*desc), pkt_data_len);
+	buf = skb_put_data(skb, data + sizeof(*desc), pkt_data_len);
 	if (rx_align == WLCORE_RX_BUF_PADDED)
 		skb_pull(skb, RX_BUF_ALIGN);
 
diff --git a/drivers/net/wireless/zd1201.c b/drivers/net/wireless/zd1201.c
index b8ba1f925e75..7208ced98c36 100644
--- a/drivers/net/wireless/zd1201.c
+++ b/drivers/net/wireless/zd1201.c
@@ -324,13 +324,13 @@ static void zd1201_usbrx(struct urb *urb)
 			if (!(skb = dev_alloc_skb(datalen+24)))
 				goto resubmit;
 			
-			memcpy(skb_put(skb, 2), &data[datalen-16], 2);
-			memcpy(skb_put(skb, 2), &data[datalen-2], 2);
-			memcpy(skb_put(skb, 6), &data[datalen-14], 6);
-			memcpy(skb_put(skb, 6), &data[datalen-22], 6);
-			memcpy(skb_put(skb, 6), &data[datalen-8], 6);
-			memcpy(skb_put(skb, 2), &data[datalen-24], 2);
-			memcpy(skb_put(skb, len), data, len);
+			skb_put_data(skb, &data[datalen - 16], 2);
+			skb_put_data(skb, &data[datalen - 2], 2);
+			skb_put_data(skb, &data[datalen - 14], 6);
+			skb_put_data(skb, &data[datalen - 22], 6);
+			skb_put_data(skb, &data[datalen - 8], 6);
+			skb_put_data(skb, &data[datalen - 24], 2);
+			skb_put_data(skb, data, len);
 			skb->protocol = eth_type_trans(skb, zd->dev);
 			zd->dev->stats.rx_packets++;
 			zd->dev->stats.rx_bytes += skb->len;
@@ -357,9 +357,9 @@ static void zd1201_usbrx(struct urb *urb)
 				frag->skb = skb;
 				frag->seq = seq & IEEE80211_SCTL_SEQ;
 				skb_reserve(skb, 2);
-				memcpy(skb_put(skb, 12), &data[datalen-14], 12);
-				memcpy(skb_put(skb, 2), &data[6], 2);
-				memcpy(skb_put(skb, len), data+8, len);
+				skb_put_data(skb, &data[datalen - 14], 12);
+				skb_put_data(skb, &data[6], 2);
+				skb_put_data(skb, data + 8, len);
 				hlist_add_head(&frag->fnode, &zd->fraglist);
 				goto resubmit;
 			}
@@ -383,9 +383,9 @@ static void zd1201_usbrx(struct urb *urb)
 			if (!skb)
 				goto resubmit;
 			skb_reserve(skb, 2);
-			memcpy(skb_put(skb, 12), &data[datalen-14], 12);
-			memcpy(skb_put(skb, 2), &data[6], 2);
-			memcpy(skb_put(skb, len), data+8, len);
+			skb_put_data(skb, &data[datalen - 14], 12);
+			skb_put_data(skb, &data[6], 2);
+			skb_put_data(skb, data + 8, len);
 		}
 		skb->protocol = eth_type_trans(skb, zd->dev);
 		zd->dev->stats.rx_packets++;
diff --git a/drivers/net/wireless/zd1211rw/zd_mac.c b/drivers/net/wireless/zd1211rw/zd_mac.c
index c6208a7988e4..d0a3b4f39d76 100644
--- a/drivers/net/wireless/zd1211rw/zd_mac.c
+++ b/drivers/net/wireless/zd1211rw/zd_mac.c
@@ -1105,7 +1105,7 @@ int zd_mac_rx(struct ieee80211_hw *hw, const u8 *buffer, unsigned int length)
 	}
 
 	/* FIXME : could we avoid this big memcpy ? */
-	memcpy(skb_put(skb, length), buffer, length);
+	skb_put_data(skb, buffer, length);
 
 	memcpy(IEEE80211_SKB_RXCB(skb), &stats, sizeof(stats));
 	ieee80211_rx_irqsafe(hw, skb);
* Unmerged path drivers/nfc/fdp/fdp.c
* Unmerged path drivers/nfc/fdp/i2c.c
* Unmerged path drivers/nfc/nfcmrvl/fw_dnld.c
* Unmerged path drivers/nfc/nfcmrvl/i2c.c
* Unmerged path drivers/nfc/nfcmrvl/usb.c
* Unmerged path drivers/nfc/nxp-nci/firmware.c
* Unmerged path drivers/nfc/nxp-nci/i2c.c
* Unmerged path drivers/nfc/pn533.c
* Unmerged path drivers/nfc/pn533/usb.c
* Unmerged path drivers/nfc/port100.c
* Unmerged path drivers/nfc/s3fwrn5/firmware.c
* Unmerged path drivers/nfc/s3fwrn5/i2c.c
* Unmerged path drivers/nfc/st21nfca/dep.c
* Unmerged path drivers/nfc/st21nfca/i2c.c
* Unmerged path drivers/rpmsg/rpmsg_char.c
diff --git a/drivers/s390/net/ctcm_fsms.c b/drivers/s390/net/ctcm_fsms.c
index fb92524d24ef..6320f87cdaca 100644
--- a/drivers/s390/net/ctcm_fsms.c
+++ b/drivers/s390/net/ctcm_fsms.c
@@ -1283,7 +1283,7 @@ static void ctcmpc_chx_txdone(fsm_instance *fi, int event, void *arg)
 		       __func__, data_space);
 
 	while ((skb = skb_dequeue(&ch->collect_queue))) {
-		memcpy(skb_put(ch->trans_skb, skb->len), skb->data, skb->len);
+		skb_put_data(ch->trans_skb, skb->data, skb->len);
 		p_header = (struct pdu *)
 			(skb_tail_pointer(ch->trans_skb) - skb->len);
 		p_header->pdu_flag = 0x00;
@@ -1435,13 +1435,12 @@ static void ctcmpc_chx_rx(fsm_instance *fi, int event, void *arg)
 			break;
 		case MPCG_STATE_FLOWC:
 		case MPCG_STATE_READY:
-			memcpy(skb_put(new_skb, block_len),
-					       skb->data, block_len);
+			skb_put_data(new_skb, skb->data, block_len);
 			skb_queue_tail(&ch->io_queue, new_skb);
 			tasklet_schedule(&ch->ch_tasklet);
 			break;
 		default:
-			memcpy(skb_put(new_skb, len), skb->data, len);
+			skb_put_data(new_skb, skb->data, len);
 			skb_queue_tail(&ch->io_queue, new_skb);
 			tasklet_hi_schedule(&ch->ch_tasklet);
 			break;
diff --git a/drivers/s390/net/ctcm_main.c b/drivers/s390/net/ctcm_main.c
index 49c4dc04f705..1e6328d77a1f 100644
--- a/drivers/s390/net/ctcm_main.c
+++ b/drivers/s390/net/ctcm_main.c
@@ -522,7 +522,7 @@ static int ctcm_transmit_skb(struct channel *ch, struct sk_buff *skb)
 			ctcm_clear_busy(ch->netdev);
 			return -ENOMEM;
 		} else {
-			memcpy(skb_put(nskb, skb->len), skb->data, skb->len);
+			skb_put_data(nskb, skb->data, skb->len);
 			atomic_inc(&nskb->users);
 			atomic_dec(&skb->users);
 			dev_kfree_skb_irq(skb);
@@ -638,7 +638,7 @@ static void ctcmpc_send_sweep_req(struct channel *rch)
 	header->th.th_seq_num	= 0x00;
 	header->sw.th_last_seq	= ch->th_seq_num;
 
-	memcpy(skb_put(sweep_skb, TH_SWEEP_LENGTH), header, TH_SWEEP_LENGTH);
+	skb_put_data(sweep_skb, header, TH_SWEEP_LENGTH);
 
 	kfree(header);
 
@@ -728,7 +728,7 @@ static int ctcmpc_transmit_skb(struct channel *ch, struct sk_buff *skb)
 		if (!nskb) {
 			goto nomem_exit;
 		} else {
-			memcpy(skb_put(nskb, skb->len), skb->data, skb->len);
+			skb_put_data(nskb, skb->data, skb->len);
 			atomic_inc(&nskb->users);
 			atomic_dec(&skb->users);
 			dev_kfree_skb_irq(skb);
@@ -809,7 +809,7 @@ static int ctcmpc_transmit_skb(struct channel *ch, struct sk_buff *skb)
 		skb_reset_tail_pointer(ch->trans_skb);
 		ch->trans_skb->len = 0;
 		ch->ccw[1].count = skb->len;
-		memcpy(skb_put(ch->trans_skb, skb->len), skb->data, skb->len);
+		skb_put_data(ch->trans_skb, skb->data, skb->len);
 		atomic_dec(&skb->users);
 		dev_kfree_skb_irq(skb);
 		ccw_idx = 0;
@@ -960,7 +960,7 @@ static int ctcmpc_tx(struct sk_buff *skb, struct net_device *dev)
 		}
 		newskb->protocol = skb->protocol;
 		skb_reserve(newskb, TH_HEADER_LENGTH + PDU_HEADER_LENGTH);
-		memcpy(skb_put(newskb, skb->len), skb->data, skb->len);
+		skb_put_data(newskb, skb->data, skb->len);
 		dev_kfree_skb_any(skb);
 		skb = newskb;
 	}
diff --git a/drivers/s390/net/ctcm_mpc.c b/drivers/s390/net/ctcm_mpc.c
index d3c576d790f7..4c7761cdc01d 100644
--- a/drivers/s390/net/ctcm_mpc.c
+++ b/drivers/s390/net/ctcm_mpc.c
@@ -679,7 +679,7 @@ static void ctcmpc_send_sweep_resp(struct channel *rch)
 	header->th.th_seq_num	= 0x00;
 	header->sw.th_last_seq	= ch->th_seq_num;
 
-	memcpy(skb_put(sweep_skb, TH_SWEEP_LENGTH), header, TH_SWEEP_LENGTH);
+	skb_put_data(sweep_skb, header, TH_SWEEP_LENGTH);
 
 	kfree(header);
 
@@ -986,9 +986,8 @@ void mpc_channel_action(struct channel *ch, int direction, int action)
 		skb_reset_tail_pointer(ch->xid_skb);
 		ch->xid_skb->len = 0;
 
-		memcpy(skb_put(ch->xid_skb, grp->xid_skb->len),
-				grp->xid_skb->data,
-				grp->xid_skb->len);
+		skb_put_data(ch->xid_skb, grp->xid_skb->data,
+			     grp->xid_skb->len);
 
 		ch->xid->xid2_dlc_type =
 			((CHANNEL_DIRECTION(ch->flags) == CTCM_READ)
@@ -1161,7 +1160,7 @@ static void ctcmpc_unpack_skb(struct channel *ch, struct sk_buff *pskb)
 				fsm_event(grp->fsm, MPCG_EVENT_INOP, dev);
 						goto done;
 			}
-			memcpy(skb_put(skb, new_len), pskb->data, new_len);
+			skb_put_data(skb, pskb->data, new_len);
 
 			skb_reset_mac_header(skb);
 			skb->dev = pskb->dev;
@@ -1309,16 +1308,15 @@ struct mpc_group *ctcmpc_init_mpc_group(struct ctcm_priv *priv)
 	/*  base xid for all channels in group  */
 	grp->xid_skb_data = grp->xid_skb->data;
 	grp->xid_th = (struct th_header *)grp->xid_skb->data;
-	memcpy(skb_put(grp->xid_skb, TH_HEADER_LENGTH),
-			&thnorm, TH_HEADER_LENGTH);
+	skb_put_data(grp->xid_skb, &thnorm, TH_HEADER_LENGTH);
 
 	grp->xid = (struct xid2 *)skb_tail_pointer(grp->xid_skb);
-	memcpy(skb_put(grp->xid_skb, XID2_LENGTH), &init_xid, XID2_LENGTH);
+	skb_put_data(grp->xid_skb, &init_xid, XID2_LENGTH);
 	grp->xid->xid2_adj_id = jiffies | 0xfff00000;
 	grp->xid->xid2_sender_id = jiffies;
 
 	grp->xid_id = skb_tail_pointer(grp->xid_skb);
-	memcpy(skb_put(grp->xid_skb, 4), "VTAM", 4);
+	skb_put_data(grp->xid_skb, "VTAM", 4);
 
 	grp->rcvd_xid_skb =
 		__dev_alloc_skb(MPC_BUFSIZE_DEFAULT, GFP_ATOMIC|GFP_DMA);
@@ -1330,8 +1328,7 @@ struct mpc_group *ctcmpc_init_mpc_group(struct ctcm_priv *priv)
 	}
 	grp->rcvd_xid_data = grp->rcvd_xid_skb->data;
 	grp->rcvd_xid_th = (struct th_header *)grp->rcvd_xid_skb->data;
-	memcpy(skb_put(grp->rcvd_xid_skb, TH_HEADER_LENGTH),
-			&thnorm, TH_HEADER_LENGTH);
+	skb_put_data(grp->rcvd_xid_skb, &thnorm, TH_HEADER_LENGTH);
 	grp->saved_xid2 = NULL;
 	priv->xid = grp->xid;
 	priv->mpcg = grp;
@@ -1422,8 +1419,7 @@ static void mpc_action_go_inop(fsm_instance *fi, int event, void *arg)
 	skb_reset_tail_pointer(grp->rcvd_xid_skb);
 	grp->rcvd_xid_skb->len = 0;
 	grp->rcvd_xid_th = (struct th_header *)grp->rcvd_xid_skb->data;
-	memcpy(skb_put(grp->rcvd_xid_skb, TH_HEADER_LENGTH), &thnorm,
-	       TH_HEADER_LENGTH);
+	skb_put_data(grp->rcvd_xid_skb, &thnorm, TH_HEADER_LENGTH);
 
 	if (grp->send_qllc_disc == 1) {
 		grp->send_qllc_disc = 0;
@@ -1602,8 +1598,7 @@ static int mpc_validate_xid(struct mpcg_info *mpcginfo)
 		grp->saved_xid2 =
 			(struct xid2 *)skb_tail_pointer(grp->rcvd_xid_skb);
 
-		memcpy(skb_put(grp->rcvd_xid_skb,
-					XID2_LENGTH), xid, XID2_LENGTH);
+		skb_put_data(grp->rcvd_xid_skb, xid, XID2_LENGTH);
 		grp->rcvd_xid_skb->data = grp->rcvd_xid_data;
 
 		skb_reset_tail_pointer(grp->rcvd_xid_skb);
@@ -1920,17 +1915,15 @@ static void mpc_action_doxid7(fsm_instance *fsm, int event, void *arg)
 				if (fsm_getstate(ch->fsm) == CH_XID7_PENDING1) {
 					fsm_newstate(ch->fsm, CH_XID7_PENDING2);
 					ch->ccw[8].cmd_code = CCW_CMD_SENSE_CMD;
-					memcpy(skb_put(ch->xid_skb,
-							TH_HEADER_LENGTH),
-					       &thdummy, TH_HEADER_LENGTH);
+					skb_put_data(ch->xid_skb, &thdummy,
+						     TH_HEADER_LENGTH);
 					send = 1;
 				}
 			} else if (fsm_getstate(ch->fsm) < CH_XID7_PENDING2) {
 					fsm_newstate(ch->fsm, CH_XID7_PENDING2);
 					ch->ccw[8].cmd_code = CCW_CMD_WRITE_CTL;
-					memcpy(skb_put(ch->xid_skb,
-						       TH_HEADER_LENGTH),
-					       &thnorm, TH_HEADER_LENGTH);
+					skb_put_data(ch->xid_skb, &thnorm,
+						     TH_HEADER_LENGTH);
 					send = 1;
 			}
 		} else {
@@ -1938,17 +1931,16 @@ static void mpc_action_doxid7(fsm_instance *fsm, int event, void *arg)
 			if (grp->roll == YSIDE) {
 				if (fsm_getstate(ch->fsm) < CH_XID7_PENDING4) {
 					fsm_newstate(ch->fsm, CH_XID7_PENDING4);
-					memcpy(skb_put(ch->xid_skb,
-						       TH_HEADER_LENGTH),
-					       &thnorm, TH_HEADER_LENGTH);
+					skb_put_data(ch->xid_skb, &thnorm,
+						     TH_HEADER_LENGTH);
 					ch->ccw[8].cmd_code = CCW_CMD_WRITE_CTL;
 					send = 1;
 				}
 			} else if (fsm_getstate(ch->fsm) == CH_XID7_PENDING3) {
 				fsm_newstate(ch->fsm, CH_XID7_PENDING4);
 				ch->ccw[8].cmd_code = CCW_CMD_SENSE_CMD;
-				memcpy(skb_put(ch->xid_skb, TH_HEADER_LENGTH),
-						&thdummy, TH_HEADER_LENGTH);
+				skb_put_data(ch->xid_skb, &thdummy,
+					     TH_HEADER_LENGTH);
 				send = 1;
 			}
 		}
@@ -2134,7 +2126,7 @@ static int mpc_send_qllc_discontact(struct net_device *dev)
 			return -ENOMEM;
 		}
 
-		memcpy(skb_put(skb, new_len), qllcptr, new_len);
+		skb_put_data(skb, qllcptr, new_len);
 		kfree(qllcptr);
 
 		if (skb_headroom(skb) < 4) {
diff --git a/drivers/s390/net/lcs.c b/drivers/s390/net/lcs.c
index c645dc9e98af..574ac82cb462 100644
--- a/drivers/s390/net/lcs.c
+++ b/drivers/s390/net/lcs.c
@@ -1797,7 +1797,7 @@ lcs_get_skb(struct lcs_card *card, char *skb_data, unsigned int skb_len)
 		card->stats.rx_dropped++;
 		return;
 	}
-	memcpy(skb_put(skb, skb_len), skb_data, skb_len);
+	skb_put_data(skb, skb_data, skb_len);
 	skb->protocol =	card->lan_type_trans(skb, card->dev);
 	card->stats.rx_bytes += skb_len;
 	card->stats.rx_packets++;
* Unmerged path drivers/s390/net/netiucv.c
diff --git a/drivers/s390/net/qeth_core_main.c b/drivers/s390/net/qeth_core_main.c
index 5eea114ca5c1..eb838af5a22f 100644
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -5118,12 +5118,11 @@ static inline int qeth_create_skb_frag(struct qeth_qdio_buffer *qethbuffer,
 
 		skb_reserve(*pskb, ETH_HLEN);
 		if (data_len <= QETH_RX_PULL_LEN) {
-			memcpy(skb_put(*pskb, data_len), element->addr + offset,
-				data_len);
+			skb_put_data(*pskb, element->addr + offset, data_len);
 		} else {
 			get_page(page);
-			memcpy(skb_put(*pskb, QETH_RX_PULL_LEN),
-			       element->addr + offset, QETH_RX_PULL_LEN);
+			skb_put_data(*pskb, element->addr + offset,
+				     QETH_RX_PULL_LEN);
 			skb_fill_page_desc(*pskb, *pfrag, page,
 				offset + QETH_RX_PULL_LEN,
 				data_len - QETH_RX_PULL_LEN);
@@ -5214,8 +5213,7 @@ struct sk_buff *qeth_core_get_next_skb(struct qeth_card *card,
 				    &skb, offset, &frag, data_len))
 					goto no_mem;
 			} else {
-				memcpy(skb_put(skb, data_len), data_ptr,
-					data_len);
+				skb_put_data(skb, data_ptr, data_len);
 			}
 		}
 		skb_len -= data_len;
* Unmerged path drivers/staging/et131x/et131x.c
* Unmerged path drivers/staging/gdm724x/gdm_lte.c
* Unmerged path drivers/staging/ks7010/ks_hostif.c
* Unmerged path drivers/staging/most/aim-network/networking.c
* Unmerged path drivers/staging/octeon/ethernet-rx.c
* Unmerged path drivers/staging/rtl8188eu/core/rtw_recv.c
* Unmerged path drivers/staging/rtl8188eu/os_dep/mon.c
* Unmerged path drivers/staging/rtl8192e/rtllib_rx.c
diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index fb67ec36689c..d3de57409c2f 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -1284,8 +1284,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 	hdr->info_element[0].id = MFIE_TYPE_SSID;
 
 	hdr->info_element[0].len = beacon->ssid_len;
-	tag = skb_put(skb, beacon->ssid_len);
-	memcpy(tag, beacon->ssid, beacon->ssid_len);
+	tag = skb_put_data(skb, beacon->ssid, beacon->ssid_len);
 
 	tag = skb_put(skb, rate_len);
 
@@ -1359,8 +1358,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 	}
 
 	if (wpa_ie_len) {
-		tag = skb_put(skb, ieee->wpa_ie_len);
-		memcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);
+		tag = skb_put_data(skb, ieee->wpa_ie, ieee->wpa_ie_len);
 
 		if (PMKCacheIdx >= 0) {
 			tag = skb_put(skb, 18);
@@ -1376,8 +1374,7 @@ inline struct sk_buff *rtllib_association_req(struct rtllib_network *beacon,
 	}
 
 	if (wps_ie_len && ieee->wps_ie) {
-		tag = skb_put(skb, wps_ie_len);
-		memcpy(tag, ieee->wps_ie, wps_ie_len);
+		tag = skb_put_data(skb, ieee->wps_ie, wps_ie_len);
 	}
 
 	tag = skb_put(skb, turbo_info_len);
* Unmerged path drivers/staging/rtl8192e/rtllib_tx.c
* Unmerged path drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c
diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c b/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
index 5ff6803c9763..d90b30b43cd8 100644
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
@@ -1107,8 +1107,7 @@ inline struct sk_buff *ieee80211_association_req(struct ieee80211_network *beaco
 	hdr->info_element[0].id = MFIE_TYPE_SSID;
 
 	hdr->info_element[0].len = beacon->ssid_len;
-	tag = skb_put(skb, beacon->ssid_len);
-	memcpy(tag, beacon->ssid, beacon->ssid_len);
+	tag = skb_put_data(skb, beacon->ssid, beacon->ssid_len);
 
 	tag = skb_put(skb, rate_len);
 
* Unmerged path drivers/staging/rtl8192u/ieee80211/ieee80211_tx.c
* Unmerged path drivers/staging/rtl8192u/r819xU_cmdpkt.c
diff --git a/drivers/staging/rtl8712/rtl8712_recv.c b/drivers/staging/rtl8712/rtl8712_recv.c
index d59a74aa3048..42b725a2a67f 100644
--- a/drivers/staging/rtl8712/rtl8712_recv.c
+++ b/drivers/staging/rtl8712/rtl8712_recv.c
@@ -376,8 +376,7 @@ static int amsdu_to_msdu(struct _adapter *padapter, union recv_frame *prframe)
 		if (!sub_skb)
 			break;
 		skb_reserve(sub_skb, 12);
-		data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
-		memcpy(data_ptr, pdata, nSubframe_Length);
+		data_ptr = skb_put_data(sub_skb, pdata, nSubframe_Length);
 		subframes[nr_subframes++] = sub_skb;
 		if (nr_subframes >= MAX_SUBFRAME_COUNT) {
 			netdev_warn(padapter->pnetdev, "r8712u: ParseSubframe(): Too many Subframes! Packets dropped!\n");
* Unmerged path drivers/staging/rtl8723bs/os_dep/recv_linux.c
* Unmerged path drivers/staging/wilc1000/linux_mon.c
* Unmerged path drivers/staging/wilc1000/linux_wlan.c
* Unmerged path drivers/staging/wlan-ng/hfa384x_usb.c
diff --git a/drivers/tty/ipwireless/network.c b/drivers/tty/ipwireless/network.c
index c0dfb642383b..c2f9a3263b37 100644
--- a/drivers/tty/ipwireless/network.c
+++ b/drivers/tty/ipwireless/network.c
@@ -355,7 +355,7 @@ static struct sk_buff *ipw_packet_received_skb(unsigned char *data,
 	if (skb == NULL)
 		return NULL;
 	skb_reserve(skb, 2);
-	memcpy(skb_put(skb, length), data, length);
+	skb_put_data(skb, data, length);
 
 	return skb;
 }
diff --git a/drivers/tty/n_gsm.c b/drivers/tty/n_gsm.c
index 86e3e207c94b..51fb307d3f33 100644
--- a/drivers/tty/n_gsm.c
+++ b/drivers/tty/n_gsm.c
@@ -2695,7 +2695,7 @@ static void gsm_mux_rx_netchar(struct gsm_dlci *dlci,
 		return;
 	}
 	skb_reserve(skb, NET_IP_ALIGN);
-	memcpy(skb_put(skb, size), in_buf, size);
+	skb_put_data(skb, in_buf, size);
 
 	skb->dev = net;
 	skb->protocol = __constant_htons(ETH_P_IP);
diff --git a/drivers/tty/synclink.c b/drivers/tty/synclink.c
index ccdb675dc166..b7ad6301ee9c 100644
--- a/drivers/tty/synclink.c
+++ b/drivers/tty/synclink.c
@@ -7972,7 +7972,7 @@ static void hdlcdev_rx(struct mgsl_struct *info, char *buf, int size)
 		return;
 	}
 
-	memcpy(skb_put(skb, size), buf, size);
+	skb_put_data(skb, buf, size);
 
 	skb->protocol = hdlc_type_trans(skb, dev);
 
diff --git a/drivers/tty/synclink_gt.c b/drivers/tty/synclink_gt.c
index 718a1a333de7..bcd5c744f9e8 100644
--- a/drivers/tty/synclink_gt.c
+++ b/drivers/tty/synclink_gt.c
@@ -1759,7 +1759,7 @@ static void hdlcdev_rx(struct slgt_info *info, char *buf, int size)
 		return;
 	}
 
-	memcpy(skb_put(skb, size), buf, size);
+	skb_put_data(skb, buf, size);
 
 	skb->protocol = hdlc_type_trans(skb, dev);
 
diff --git a/drivers/tty/synclinkmp.c b/drivers/tty/synclinkmp.c
index 8ae81aa5950b..543a9170e0be 100644
--- a/drivers/tty/synclinkmp.c
+++ b/drivers/tty/synclinkmp.c
@@ -1877,7 +1877,7 @@ static void hdlcdev_rx(SLMP_INFO *info, char *buf, int size)
 		return;
 	}
 
-	memcpy(skb_put(skb, size), buf, size);
+	skb_put_data(skb, buf, size);
 
 	skb->protocol = hdlc_type_trans(skb, dev);
 
* Unmerged path drivers/usb/gadget/f_ncm.c
diff --git a/drivers/usb/gadget/f_phonet.c b/drivers/usb/gadget/f_phonet.c
index b21ab558b6c0..5f8a23cac38b 100644
--- a/drivers/usb/gadget/f_phonet.c
+++ b/drivers/usb/gadget/f_phonet.c
@@ -341,7 +341,7 @@ static void pn_rx_complete(struct usb_ep *ep, struct usb_request *req)
 			skb->protocol = htons(ETH_P_PHONET);
 			skb_reset_mac_header(skb);
 			/* Can't use pskb_pull() on page in IRQ */
-			memcpy(skb_put(skb, 1), page_address(page), 1);
+			skb_put_data(skb, page_address(page), 1);
 		}
 
 		skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,
diff --git a/include/linux/mISDNif.h b/include/linux/mISDNif.h
index 246a3529ecf6..e61dddb2c33b 100644
--- a/include/linux/mISDNif.h
+++ b/include/linux/mISDNif.h
@@ -554,7 +554,7 @@ _alloc_mISDN_skb(u_int prim, u_int id, u_int len, void *dp, gfp_t gfp_mask)
 	if (!skb)
 		return NULL;
 	if (len)
-		memcpy(skb_put(skb, len), dp, len);
+		skb_put_data(skb, dp, len);
 	hh = mISDN_HEAD_P(skb);
 	hh->prim = prim;
 	hh->id = id;
* Unmerged path include/linux/skbuff.h
diff --git a/net/batman-adv/bat_iv_ogm.c b/net/batman-adv/bat_iv_ogm.c
index f680ee101878..c44f3955888d 100644
--- a/net/batman-adv/bat_iv_ogm.c
+++ b/net/batman-adv/bat_iv_ogm.c
@@ -480,8 +480,8 @@ static void batadv_iv_ogm_aggregate(struct batadv_forw_packet *forw_packet_aggr,
 	unsigned char *skb_buff;
 	unsigned long new_direct_link_flag;
 
-	skb_buff = skb_put(forw_packet_aggr->skb, packet_len);
-	memcpy(skb_buff, packet_buff, packet_len);
+	skb_buff = skb_put_data(forw_packet_aggr->skb, packet_buff,
+				packet_len);
 	forw_packet_aggr->packet_len += packet_len;
 	forw_packet_aggr->num_packets++;
 
* Unmerged path net/batman-adv/bat_v_ogm.c
* Unmerged path net/batman-adv/fragmentation.c
diff --git a/net/bluetooth/cmtp/core.c b/net/bluetooth/cmtp/core.c
index 9e59b6654126..f4c64ef01c24 100644
--- a/net/bluetooth/cmtp/core.c
+++ b/net/bluetooth/cmtp/core.c
@@ -122,7 +122,7 @@ static inline void cmtp_add_msgpart(struct cmtp_session *session, int id, const
 	if (skb && (skb->len > 0))
 		skb_copy_from_linear_data(skb, skb_put(nskb, skb->len), skb->len);
 
-	memcpy(skb_put(nskb, count), buf, count);
+	skb_put_data(nskb, buf, count);
 
 	session->reassembly[id] = nskb;
 
diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index 31a5b9ba6407..2a1951b18055 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -3219,7 +3219,7 @@ int hci_reset_dev(struct hci_dev *hdev)
 		return -ENOMEM;
 
 	hci_skb_pkt_type(skb) = HCI_EVENT_PKT;
-	memcpy(skb_put(skb, 3), hw_err, 3);
+	skb_put_data(skb, hw_err, 3);
 
 	/* Send Hardware Error to upper stack */
 	return hci_recv_frame(hdev, skb);
diff --git a/net/bluetooth/hci_request.c b/net/bluetooth/hci_request.c
index 1015d9c8d97d..df8a00038b26 100644
--- a/net/bluetooth/hci_request.c
+++ b/net/bluetooth/hci_request.c
@@ -302,7 +302,7 @@ struct sk_buff *hci_prepare_cmd(struct hci_dev *hdev, u16 opcode, u32 plen,
 	hdr->plen   = plen;
 
 	if (plen)
-		memcpy(skb_put(skb, plen), param, plen);
+		skb_put_data(skb, param, plen);
 
 	BT_DBG("skb len %d", skb->len);
 
* Unmerged path net/bluetooth/hci_sock.c
diff --git a/net/bluetooth/hidp/core.c b/net/bluetooth/hidp/core.c
index bb065657543d..fd9986885752 100644
--- a/net/bluetooth/hidp/core.c
+++ b/net/bluetooth/hidp/core.c
@@ -114,7 +114,7 @@ static int hidp_send_message(struct hidp_session *session, struct socket *sock,
 
 	*(u8 *)skb_put(skb, 1) = hdr;
 	if (data && size > 0)
-		memcpy(skb_put(skb, size), data, size);
+		skb_put_data(skb, data, size);
 
 	skb_queue_tail(transmit, skb);
 	wake_up_interruptible(sk_sleep(sk));
diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c
index 3657fcda68d1..f87312790eaf 100644
--- a/net/bluetooth/l2cap_core.c
+++ b/net/bluetooth/l2cap_core.c
@@ -2918,7 +2918,7 @@ static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn, u8 code,
 
 	if (dlen) {
 		count -= L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE;
-		memcpy(skb_put(skb, count), data, count);
+		skb_put_data(skb, data, count);
 		data += count;
 	}
 
@@ -2933,7 +2933,7 @@ static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn, u8 code,
 		if (!*frag)
 			goto fail;
 
-		memcpy(skb_put(*frag, count), data, count);
+		skb_put_data(*frag, data, count);
 
 		len  -= count;
 		data += count;
diff --git a/net/bluetooth/mgmt_util.c b/net/bluetooth/mgmt_util.c
index c933bd08c1fe..11d0ca64402b 100644
--- a/net/bluetooth/mgmt_util.c
+++ b/net/bluetooth/mgmt_util.c
@@ -44,7 +44,7 @@ static struct sk_buff *create_monitor_ctrl_event(__le16 index, u32 cookie,
 	put_unaligned_le16(opcode, skb_put(skb, 2));
 
 	if (buf)
-		memcpy(skb_put(skb, len), buf, len);
+		skb_put_data(skb, buf, len);
 
 	__net_timestamp(skb);
 
@@ -75,7 +75,7 @@ int mgmt_send_event(u16 event, struct hci_dev *hdev, unsigned short channel,
 	hdr->len = cpu_to_le16(data_len);
 
 	if (data)
-		memcpy(skb_put(skb, data_len), data, data_len);
+		skb_put_data(skb, data, data_len);
 
 	/* Time stamp */
 	__net_timestamp(skb);
diff --git a/net/bluetooth/rfcomm/tty.c b/net/bluetooth/rfcomm/tty.c
index 2f2cb5e27cdd..5f3074cb6b4d 100644
--- a/net/bluetooth/rfcomm/tty.c
+++ b/net/bluetooth/rfcomm/tty.c
@@ -798,7 +798,7 @@ static int rfcomm_tty_write(struct tty_struct *tty, const unsigned char *buf, in
 
 		skb_reserve(skb, RFCOMM_SKB_HEAD_RESERVE);
 
-		memcpy(skb_put(skb, size), buf + sent, size);
+		skb_put_data(skb, buf + sent, size);
 
 		rfcomm_dlc_send_noerror(dlc, skb);
 
* Unmerged path net/can/bcm.c
diff --git a/net/decnet/dn_nsp_out.c b/net/decnet/dn_nsp_out.c
index 1aaa51ebbda6..f252492666bf 100644
--- a/net/decnet/dn_nsp_out.c
+++ b/net/decnet/dn_nsp_out.c
@@ -533,7 +533,7 @@ void dn_send_conn_conf(struct sock *sk, gfp_t gfp)
 	*skb_put(skb,1) = len;
 
 	if (len > 0)
-		memcpy(skb_put(skb, len), scp->conndata_out.opt_data, len);
+		skb_put_data(skb, scp->conndata_out.opt_data, len);
 
 
 	dn_nsp_send(skb);
@@ -691,22 +691,22 @@ void dn_nsp_send_conninit(struct sock *sk, unsigned char msgflg)
 	aux = scp->accessdata.acc_userl;
 	*skb_put(skb, 1) = aux;
 	if (aux > 0)
-		memcpy(skb_put(skb, aux), scp->accessdata.acc_user, aux);
+		skb_put_data(skb, scp->accessdata.acc_user, aux);
 
 	aux = scp->accessdata.acc_passl;
 	*skb_put(skb, 1) = aux;
 	if (aux > 0)
-		memcpy(skb_put(skb, aux), scp->accessdata.acc_pass, aux);
+		skb_put_data(skb, scp->accessdata.acc_pass, aux);
 
 	aux = scp->accessdata.acc_accl;
 	*skb_put(skb, 1) = aux;
 	if (aux > 0)
-		memcpy(skb_put(skb, aux), scp->accessdata.acc_acc, aux);
+		skb_put_data(skb, scp->accessdata.acc_acc, aux);
 
 	aux = (__u8)le16_to_cpu(scp->conndata_out.opt_optl);
 	*skb_put(skb, 1) = aux;
 	if (aux > 0)
-		memcpy(skb_put(skb, aux), scp->conndata_out.opt_data, aux);
+		skb_put_data(skb, scp->conndata_out.opt_data, aux);
 
 	scp->persist = dn_nsp_persist(sk);
 	scp->persist_fxn = dn_nsp_retrans_conninit;
diff --git a/net/ieee802154/6lowpan/tx.c b/net/ieee802154/6lowpan/tx.c
index dbb476d7d38f..e6ff5128e61a 100644
--- a/net/ieee802154/6lowpan/tx.c
+++ b/net/ieee802154/6lowpan/tx.c
@@ -121,8 +121,7 @@ lowpan_alloc_frag(struct sk_buff *skb, int size,
 		*mac_cb(frag) = *mac_cb(skb);
 
 		if (frag1) {
-			memcpy(skb_put(frag, skb->mac_len),
-			       skb_mac_header(skb), skb->mac_len);
+			skb_put_data(frag, skb_mac_header(skb), skb->mac_len);
 		} else {
 			rc = wpan_dev_hard_header(frag, wdev,
 						  &master_hdr->dest,
@@ -152,8 +151,8 @@ lowpan_xmit_fragment(struct sk_buff *skb, const struct ieee802154_hdr *wpan_hdr,
 	if (IS_ERR(frag))
 		return PTR_ERR(frag);
 
-	memcpy(skb_put(frag, frag_hdrlen), frag_hdr, frag_hdrlen);
-	memcpy(skb_put(frag, len), skb_network_header(skb) + offset, len);
+	skb_put_data(frag, frag_hdr, frag_hdrlen);
+	skb_put_data(frag, skb_network_header(skb) + offset, len);
 
 	raw_dump_table(__func__, " fragment dump", frag->data, frag->len);
 
diff --git a/net/irda/ircomm/ircomm_tty.c b/net/irda/ircomm/ircomm_tty.c
index e683ed5b0927..cdc6795dcb52 100644
--- a/net/irda/ircomm/ircomm_tty.c
+++ b/net/irda/ircomm/ircomm_tty.c
@@ -708,7 +708,7 @@ static int ircomm_tty_write(struct tty_struct *tty,
 		}
 
 		/* Copy data */
-		memcpy(skb_put(skb,size), buf + len, size);
+		skb_put_data(skb, buf + len, size);
 
 		count -= size;
 		len += size;
diff --git a/net/irda/irlap_frame.c b/net/irda/irlap_frame.c
index 9ea0c933b9ff..9089e367340c 100644
--- a/net/irda/irlap_frame.c
+++ b/net/irda/irlap_frame.c
@@ -394,8 +394,7 @@ void irlap_send_discovery_xid_frame(struct irlap_cb *self, int S, __u8 s,
 		info[0] = discovery->data.charset;
 
 		len = IRDA_MIN(discovery->name_len, skb_tailroom(tx_skb));
-		info = skb_put(tx_skb, len);
-		memcpy(info, discovery->data.info, len);
+		info = skb_put_data(tx_skb, discovery->data.info, len);
 	}
 	irlap_queue_xmit(self, tx_skb);
 }
@@ -1237,8 +1236,7 @@ void irlap_send_test_frame(struct irlap_cb *self, __u8 caddr, __u32 daddr,
 	frame->control = TEST_RSP | PF_BIT;
 
 	/* Copy info */
-	info = skb_put(tx_skb, cmd->len);
-	memcpy(info, cmd->data, cmd->len);
+	info = skb_put_data(tx_skb, cmd->data, cmd->len);
 
 	/* Return to sender */
 	irlap_wait_min_turn_around(self, &self->qos_tx);
* Unmerged path net/mac80211/mlme.c
* Unmerged path net/mac80211/tdls.c
* Unmerged path net/netlink/af_netlink.c
* Unmerged path net/nfc/digital_dep.c
diff --git a/net/nfc/hci/core.c b/net/nfc/hci/core.c
index 91020b210d87..7631e5014e3f 100644
--- a/net/nfc/hci/core.c
+++ b/net/nfc/hci/core.c
@@ -750,9 +750,9 @@ static void nfc_hci_recv_from_llc(struct nfc_hci_dev *hdev, struct sk_buff *skb)
 
 		skb_queue_walk(&hdev->rx_hcp_frags, frag_skb) {
 			msg_len = frag_skb->len - NFC_HCI_HCP_PACKET_HEADER_LEN;
-			memcpy(skb_put(hcp_skb, msg_len),
-			       frag_skb->data + NFC_HCI_HCP_PACKET_HEADER_LEN,
-			       msg_len);
+			skb_put_data(hcp_skb,
+				     frag_skb->data + NFC_HCI_HCP_PACKET_HEADER_LEN,
+				     msg_len);
 		}
 
 		skb_queue_purge(&hdev->rx_hcp_frags);
diff --git a/net/nfc/llcp_commands.c b/net/nfc/llcp_commands.c
index b2e4ddb18db9..c58b62534296 100644
--- a/net/nfc/llcp_commands.c
+++ b/net/nfc/llcp_commands.c
@@ -300,7 +300,7 @@ static struct sk_buff *llcp_add_header(struct sk_buff *pdu,
 
 	pr_debug("header 0x%x 0x%x\n", header[0], header[1]);
 
-	memcpy(skb_put(pdu, LLCP_HEADER_SIZE), header, LLCP_HEADER_SIZE);
+	skb_put_data(pdu, header, LLCP_HEADER_SIZE);
 
 	return pdu;
 }
@@ -313,7 +313,7 @@ static struct sk_buff *llcp_add_tlv(struct sk_buff *pdu, u8 *tlv,
 	if (tlv == NULL)
 		return NULL;
 
-	memcpy(skb_put(pdu, tlv_length), tlv, tlv_length);
+	skb_put_data(pdu, tlv, tlv_length);
 
 	return pdu;
 }
@@ -550,7 +550,7 @@ int nfc_llcp_send_snl_sdres(struct nfc_llcp_local *local,
 		return PTR_ERR(skb);
 
 	hlist_for_each_entry_safe(sdp, n, tlv_list, node) {
-		memcpy(skb_put(skb, sdp->tlv_len), sdp->tlv, sdp->tlv_len);
+		skb_put_data(skb, sdp->tlv, sdp->tlv_len);
 
 		hlist_del(&sdp->node);
 
@@ -582,8 +582,7 @@ int nfc_llcp_send_snl_sdreq(struct nfc_llcp_local *local,
 	hlist_for_each_entry_safe(sdreq, n, tlv_list, node) {
 		pr_debug("tid %d for %s\n", sdreq->tid, sdreq->uri);
 
-		memcpy(skb_put(skb, sdreq->tlv_len), sdreq->tlv,
-		       sdreq->tlv_len);
+		skb_put_data(skb, sdreq->tlv, sdreq->tlv_len);
 
 		hlist_del(&sdreq->node);
 
@@ -623,7 +622,7 @@ int nfc_llcp_send_dm(struct nfc_llcp_local *local, u8 ssap, u8 dsap, u8 reason)
 
 	skb = llcp_add_header(skb, dsap, ssap, LLCP_PDU_DM);
 
-	memcpy(skb_put(skb, 1), &reason, 1);
+	skb_put_data(skb, &reason, 1);
 
 	skb_queue_head(&local->tx_queue, skb);
 
@@ -712,7 +711,7 @@ int nfc_llcp_send_i_frame(struct nfc_llcp_sock *sock,
 		skb_put(pdu, LLCP_SEQUENCE_SIZE);
 
 		if (likely(frag_len > 0))
-			memcpy(skb_put(pdu, frag_len), msg_ptr, frag_len);
+			skb_put_data(pdu, msg_ptr, frag_len);
 
 		skb_queue_tail(&sock->tx_queue, pdu);
 
@@ -778,7 +777,7 @@ int nfc_llcp_send_ui_frame(struct nfc_llcp_sock *sock, u8 ssap, u8 dsap,
 		pdu = llcp_add_header(pdu, dsap, ssap, LLCP_PDU_UI);
 
 		if (likely(frag_len > 0))
-			memcpy(skb_put(pdu, frag_len), msg_ptr, frag_len);
+			skb_put_data(pdu, msg_ptr, frag_len);
 
 		/* No need to check for the peer RW for UI frames */
 		skb_queue_tail(&local->tx_queue, pdu);
diff --git a/net/nfc/llcp_core.c b/net/nfc/llcp_core.c
index 158bdbf668cc..f5530142e218 100644
--- a/net/nfc/llcp_core.c
+++ b/net/nfc/llcp_core.c
@@ -1379,7 +1379,7 @@ static void nfc_llcp_recv_agf(struct nfc_llcp_local *local, struct sk_buff *skb)
 			return;
 		}
 
-		memcpy(skb_put(new_skb, pdu_len), skb->data, pdu_len);
+		skb_put_data(new_skb, skb->data, pdu_len);
 
 		nfc_llcp_rx_skb(local, new_skb);
 
* Unmerged path net/nfc/nci/core.c
diff --git a/net/nfc/nci/data.c b/net/nfc/nci/data.c
index 76c48c5324f8..70ad08e54a54 100644
--- a/net/nfc/nci/data.c
+++ b/net/nfc/nci/data.c
@@ -113,7 +113,7 @@ static int nci_queue_tx_data_frags(struct nci_dev *ndev,
 		skb_reserve(skb_frag, NCI_DATA_HDR_SIZE);
 
 		/* first, copy the data */
-		memcpy(skb_put(skb_frag, frag_len), data, frag_len);
+		skb_put_data(skb_frag, data, frag_len);
 
 		/* second, set the header */
 		nci_push_data_hdr(ndev, conn_id, skb_frag,
* Unmerged path net/nfc/nci/hci.c
* Unmerged path net/nfc/nci/uart.c
* Unmerged path net/qrtr/qrtr.c
diff --git a/net/vmw_vsock/virtio_transport_common.c b/net/vmw_vsock/virtio_transport_common.c
index b1d963c14d24..ed22708f7275 100644
--- a/net/vmw_vsock/virtio_transport_common.c
+++ b/net/vmw_vsock/virtio_transport_common.c
@@ -130,12 +130,10 @@ static struct sk_buff *virtio_transport_build_skb(void *opaque)
 		break;
 	}
 
-	t_hdr = skb_put(skb, sizeof(pkt->hdr));
-	memcpy(t_hdr, &pkt->hdr, sizeof(pkt->hdr));
+	t_hdr = skb_put_data(skb, &pkt->hdr, sizeof(pkt->hdr));
 
 	if (pkt->len) {
-		payload = skb_put(skb, pkt->len);
-		memcpy(payload, pkt->buf, pkt->len);
+		payload = skb_put_data(skb, pkt->buf, pkt->len);
 	}
 
 	return skb;
diff --git a/net/x25/x25_subr.c b/net/x25/x25_subr.c
index 5170d52bfd96..cf9b4cce3924 100644
--- a/net/x25/x25_subr.c
+++ b/net/x25/x25_subr.c
@@ -186,17 +186,14 @@ void x25_write_internal(struct sock *sk, int frametype)
 			*dptr++ = X25_CALL_REQUEST;
 			len     = x25_addr_aton(addresses, &x25->dest_addr,
 						&x25->source_addr);
-			dptr    = skb_put(skb, len);
-			memcpy(dptr, addresses, len);
+			dptr = skb_put_data(skb, addresses, len);
 			len     = x25_create_facilities(facilities,
 					&x25->facilities,
 					&x25->dte_facilities,
 					x25->neighbour->global_facil_mask);
-			dptr    = skb_put(skb, len);
-			memcpy(dptr, facilities, len);
-			dptr = skb_put(skb, x25->calluserdata.cudlength);
-			memcpy(dptr, x25->calluserdata.cuddata,
-			       x25->calluserdata.cudlength);
+			dptr = skb_put_data(skb, facilities, len);
+			dptr = skb_put_data(skb, x25->calluserdata.cuddata,
+					    x25->calluserdata.cudlength);
 			x25->calluserdata.cudlength = 0;
 			break;
 
@@ -208,17 +205,15 @@ void x25_write_internal(struct sock *sk, int frametype)
 							&x25->facilities,
 							&x25->dte_facilities,
 							x25->vc_facil_mask);
-			dptr    = skb_put(skb, len);
-			memcpy(dptr, facilities, len);
+			dptr = skb_put_data(skb, facilities, len);
 
 			/* fast select with no restriction on response
 				allows call user data. Userland must
 				ensure it is ours and not theirs */
 			if(x25->facilities.reverse & 0x80) {
-				dptr = skb_put(skb,
-					x25->calluserdata.cudlength);
-				memcpy(dptr, x25->calluserdata.cuddata,
-				       x25->calluserdata.cudlength);
+				dptr = skb_put_data(skb,
+						    x25->calluserdata.cuddata,
+						    x25->calluserdata.cudlength);
 			}
 			x25->calluserdata.cudlength = 0;
 			break;
