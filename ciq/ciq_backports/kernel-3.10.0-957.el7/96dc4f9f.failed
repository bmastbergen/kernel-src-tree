usercopy: Move enum for arch_within_stack_frames()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Sahara <keun-o.park@darkmatter.ae>
commit 96dc4f9fb64690fc34410415fd1fc609cf803f61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/96dc4f9f.failed

This patch moves the arch_within_stack_frames() return value enum up in
the header files so that per-architecture implementations can reuse the
same return values.

	Signed-off-by: Sahara <keun-o.park@darkmatter.ae>
	Signed-off-by: James Morse <james.morse@arm.com>
[kees: adjusted naming and commit log]
	Signed-off-by: Kees Cook <keescook@chromium.org>
(cherry picked from commit 96dc4f9fb64690fc34410415fd1fc609cf803f61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/thread_info.h
#	mm/usercopy.c
diff --cc arch/x86/include/asm/thread_info.h
index 2fcd0a3d04a2,920ca1f7adea..000000000000
--- a/arch/x86/include/asm/thread_info.h
+++ b/arch/x86/include/asm/thread_info.h
@@@ -169,15 -152,60 +169,61 @@@ struct thread_info 
   */
  #ifndef __ASSEMBLY__
  
 -static inline unsigned long current_stack_pointer(void)
 -{
 -	unsigned long sp;
 -#ifdef CONFIG_X86_64
 -	asm("mov %%rsp,%0" : "=g" (sp));
 -#else
 -	asm("mov %%esp,%0" : "=g" (sp));
 -#endif
 -	return sp;
 -}
  
++<<<<<<< HEAD
 +/* how to get the current stack pointer from C */
 +register unsigned long current_stack_pointer asm("esp") __used;
 +
 +/* how to get the thread information struct from C */
 +static inline struct thread_info *current_thread_info(void)
 +{
 +	return (struct thread_info *)
 +		(current_stack_pointer & ~(THREAD_SIZE - 1));
++=======
+ /*
+  * Walks up the stack frames to make sure that the specified object is
+  * entirely contained by a single stack frame.
+  *
+  * Returns:
+  *	GOOD_FRAME	if within a frame
+  *	BAD_STACK	if placed across a frame boundary (or outside stack)
+  *	NOT_STACK	unable to determine (no frame pointers, etc)
+  */
+ static inline int arch_within_stack_frames(const void * const stack,
+ 					   const void * const stackend,
+ 					   const void *obj, unsigned long len)
+ {
+ #if defined(CONFIG_FRAME_POINTER)
+ 	const void *frame = NULL;
+ 	const void *oldframe;
+ 
+ 	oldframe = __builtin_frame_address(1);
+ 	if (oldframe)
+ 		frame = __builtin_frame_address(2);
+ 	/*
+ 	 * low ----------------------------------------------> high
+ 	 * [saved bp][saved ip][args][local vars][saved bp][saved ip]
+ 	 *                     ^----------------^
+ 	 *               allow copies only within here
+ 	 */
+ 	while (stack <= frame && frame < stackend) {
+ 		/*
+ 		 * If obj + len extends past the last frame, this
+ 		 * check won't pass and the next frame will be 0,
+ 		 * causing us to bail out and correctly report
+ 		 * the copy as invalid.
+ 		 */
+ 		if (obj + len <= frame)
+ 			return obj >= oldframe + 2 * sizeof(void *) ?
+ 				GOOD_FRAME : BAD_STACK;
+ 		oldframe = frame;
+ 		frame = *(const void * const *)frame;
+ 	}
+ 	return BAD_STACK;
+ #else
+ 	return NOT_STACK;
+ #endif
++>>>>>>> 96dc4f9fb646 (usercopy: Move enum for arch_within_stack_frames())
  }
  
  #else /* !__ASSEMBLY__ */
* Unmerged path mm/usercopy.c
* Unmerged path arch/x86/include/asm/thread_info.h
diff --git a/include/linux/thread_info.h b/include/linux/thread_info.h
index 819f1dd5d204..e5b13e4cc69c 100644
--- a/include/linux/thread_info.h
+++ b/include/linux/thread_info.h
@@ -51,6 +51,18 @@ struct restart_block {
 extern long do_no_restart_syscall(struct restart_block *parm);
 
 #include <linux/bitops.h>
+
+/*
+ * For per-arch arch_within_stack_frames() implementations, defined in
+ * asm/thread_info.h.
+ */
+enum {
+	BAD_STACK = -1,
+	NOT_STACK = 0,
+	GOOD_FRAME,
+	GOOD_STACK,
+};
+
 #include <asm/thread_info.h>
 
 #ifdef __KERNEL__
* Unmerged path mm/usercopy.c
