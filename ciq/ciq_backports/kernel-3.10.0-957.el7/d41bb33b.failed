ip6_tunnel: update mtu properly for ARPHRD_ETHER tunnel device in tx path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit d41bb33ba33b8f8debe54ed36be6925eb496e354
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d41bb33b.failed

Now when updating mtu in tx path, it doesn't consider ARPHRD_ETHER tunnel
device, like ip6gre_tap tunnel, for which it should also subtract ether
header to get the correct mtu.

	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d41bb33ba33b8f8debe54ed36be6925eb496e354)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_tunnel.c
diff --cc net/ipv6/ip6_tunnel.c
index a12e6c346803,a1c24443cd9e..000000000000
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@@ -1024,32 -1043,44 +1024,38 @@@ int ip6_tnl_xmit(struct sk_buff *skb, s
  	struct dst_entry *dst = NULL, *ndst = NULL;
  	struct net_device *tdev;
  	int mtu;
++<<<<<<< HEAD
 +	unsigned int max_headroom = sizeof(struct ipv6hdr);
++=======
+ 	unsigned int eth_hlen = t->dev->type == ARPHRD_ETHER ? ETH_HLEN : 0;
+ 	unsigned int psh_hlen = sizeof(struct ipv6hdr) + t->encap_hlen;
+ 	unsigned int max_headroom = psh_hlen;
++>>>>>>> d41bb33ba33b (ip6_tunnel: update mtu properly for ARPHRD_ETHER tunnel device in tx path)
  	bool use_cache = false;
 -	u8 hop_limit;
  	int err = -1;
  
 -	if (t->parms.collect_md) {
 -		hop_limit = skb_tunnel_info(skb)->key.ttl;
 -		goto route_lookup;
 -	} else {
 -		hop_limit = t->parms.hop_limit;
 -	}
 -
  	/* NBMA tunnel */
  	if (ipv6_addr_any(&t->parms.raddr)) {
 -		if (skb->protocol == htons(ETH_P_IPV6)) {
 -			struct in6_addr *addr6;
 -			struct neighbour *neigh;
 -			int addr_type;
 +		struct in6_addr *addr6;
 +		struct neighbour *neigh;
 +		int addr_type;
  
 -			if (!skb_dst(skb))
 -				goto tx_err_link_failure;
 +		if (!skb_dst(skb))
 +			goto tx_err_link_failure;
  
 -			neigh = dst_neigh_lookup(skb_dst(skb),
 -						 &ipv6_hdr(skb)->daddr);
 -			if (!neigh)
 -				goto tx_err_link_failure;
 +		neigh = dst_neigh_lookup(skb_dst(skb),
 +					 &ipv6_hdr(skb)->daddr);
 +		if (!neigh)
 +			goto tx_err_link_failure;
  
 -			addr6 = (struct in6_addr *)&neigh->primary_key;
 -			addr_type = ipv6_addr_type(addr6);
 +		addr6 = (struct in6_addr *)&neigh->primary_key;
 +		addr_type = ipv6_addr_type(addr6);
  
 -			if (addr_type == IPV6_ADDR_ANY)
 -				addr6 = &ipv6_hdr(skb)->daddr;
 +		if (addr_type == IPV6_ADDR_ANY)
 +			addr6 = &ipv6_hdr(skb)->daddr;
  
 -			memcpy(&fl6->daddr, addr6, sizeof(fl6->daddr));
 -			neigh_release(neigh);
 -		}
 +		memcpy(&fl6->daddr, addr6, sizeof(fl6->daddr));
 +		neigh_release(neigh);
  	} else if (!(t->parms.flags &
  		     (IP6_TNL_F_USE_ORIG_TCLASS | IP6_TNL_F_USE_ORIG_FWMARK))) {
  		/* enable the cache only only if the routing decision does
@@@ -1086,16 -1125,16 +1092,20 @@@
  				     t->parms.name);
  		goto tx_err_dst_release;
  	}
++<<<<<<< HEAD
 +	mtu = dst_mtu(dst) - sizeof (*ipv6h) - t->tun_hlen;
++=======
+ 	mtu = dst_mtu(dst) - eth_hlen - psh_hlen - t->tun_hlen;
++>>>>>>> d41bb33ba33b (ip6_tunnel: update mtu properly for ARPHRD_ETHER tunnel device in tx path)
  	if (encap_limit >= 0) {
  		max_headroom += 8;
  		mtu -= 8;
  	}
  	if (mtu < IPV6_MIN_MTU)
  		mtu = IPV6_MIN_MTU;
 -	if (skb_dst(skb) && !t->parms.collect_md)
 +	if (skb_dst(skb))
  		skb_dst(skb)->ops->update_pmtu(skb_dst(skb), NULL, skb, mtu);
- 	if (skb->len - t->tun_hlen > mtu && !skb_is_gso(skb)) {
+ 	if (skb->len - t->tun_hlen - eth_hlen > mtu && !skb_is_gso(skb)) {
  		*pmtu = mtu;
  		err = -EMSGSIZE;
  		goto tx_err_dst_release;
* Unmerged path net/ipv6/ip6_tunnel.c
