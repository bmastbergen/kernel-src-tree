PCI/portdrv: Rename and reverse sense of pcie_ports_auto

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [pci] portdrv: Rename and reverse sense of pcie_ports_auto (Jarod Wilson) [1495223]
Rebuild_FUZZ: 96.30%
commit-author Bjorn Helgaas <bhelgaas@google.com>
commit d850882b726f6db01b0792151e72e69b234aa461
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d850882b.failed

The platform may restrict the OS's use of PCIe services, e.g., via the ACPI
_OSC method.  The user may use "pcie_ports=native" to force the port driver
to use PCIe services even if the platform asked us not to.

The "pcie_ports=native" parameter determines the setting of
pcie_ports_auto.  Rename this to pcie_ports_native and reverse the
sense to simplify the code.

	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit d850882b726f6db01b0792151e72e69b234aa461)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pcie/portdrv.h
#	drivers/pci/pcie/portdrv_core.c
#	drivers/pci/pcie/portdrv_pci.c
diff --cc drivers/pci/pcie/portdrv.h
index 587aef36030d,3e0058a5500f..000000000000
--- a/drivers/pci/pcie/portdrv.h
+++ b/drivers/pci/pcie/portdrv.h
@@@ -11,12 -12,72 +11,75 @@@
  
  #include <linux/compiler.h>
  
++<<<<<<< HEAD
 +#define PCIE_PORT_DEVICE_MAXSERVICES   5
++=======
+ extern bool pcie_ports_native;
+ 
+ /* Service Type */
+ #define PCIE_PORT_SERVICE_PME_SHIFT	0	/* Power Management Event */
+ #define PCIE_PORT_SERVICE_PME		(1 << PCIE_PORT_SERVICE_PME_SHIFT)
+ #define PCIE_PORT_SERVICE_AER_SHIFT	1	/* Advanced Error Reporting */
+ #define PCIE_PORT_SERVICE_AER		(1 << PCIE_PORT_SERVICE_AER_SHIFT)
+ #define PCIE_PORT_SERVICE_HP_SHIFT	2	/* Native Hotplug */
+ #define PCIE_PORT_SERVICE_HP		(1 << PCIE_PORT_SERVICE_HP_SHIFT)
+ #define PCIE_PORT_SERVICE_DPC_SHIFT	3	/* Downstream Port Containment */
+ #define PCIE_PORT_SERVICE_DPC		(1 << PCIE_PORT_SERVICE_DPC_SHIFT)
+ 
+ #define PCIE_PORT_DEVICE_MAXSERVICES   4
+ 
+ /* Port Type */
+ #define PCIE_ANY_PORT			(~0)
+ 
+ struct pcie_device {
+ 	int		irq;	    /* Service IRQ/MSI/MSI-X Vector */
+ 	struct pci_dev *port;	    /* Root/Upstream/Downstream Port */
+ 	u32		service;    /* Port service this device represents */
+ 	void		*priv_data; /* Service Private Data */
+ 	struct device	device;     /* Generic Device Interface */
+ };
+ #define to_pcie_device(d) container_of(d, struct pcie_device, device)
+ 
+ static inline void set_service_data(struct pcie_device *dev, void *data)
+ {
+ 	dev->priv_data = data;
+ }
+ 
+ static inline void *get_service_data(struct pcie_device *dev)
+ {
+ 	return dev->priv_data;
+ }
+ 
+ struct pcie_port_service_driver {
+ 	const char *name;
+ 	int (*probe) (struct pcie_device *dev);
+ 	void (*remove) (struct pcie_device *dev);
+ 	int (*suspend) (struct pcie_device *dev);
+ 	int (*resume) (struct pcie_device *dev);
+ 
+ 	/* Device driver may resume normal operations */
+ 	void (*error_resume)(struct pci_dev *dev);
+ 
+ 	/* Link Reset Capability - AER service driver specific */
+ 	pci_ers_result_t (*reset_link) (struct pci_dev *dev);
+ 
+ 	int port_type;  /* Type of the port this driver can handle */
+ 	u32 service;    /* Port service this device represents */
+ 
+ 	struct device_driver driver;
+ };
+ #define to_service_driver(d) \
+ 	container_of(d, struct pcie_port_service_driver, driver)
+ 
+ int pcie_port_service_register(struct pcie_port_service_driver *new);
+ void pcie_port_service_unregister(struct pcie_port_service_driver *new);
+ 
++>>>>>>> d850882b726f (PCI/portdrv: Rename and reverse sense of pcie_ports_auto)
  /*
 - * The PCIe Capability Interrupt Message Number (PCIe r3.1, sec 7.8.2) must
 - * be one of the first 32 MSI-X entries.  Per PCI r3.0, sec 6.8.3.1, MSI
 - * supports a maximum of 32 vectors per function.
 + * According to the PCI Express Base Specification 2.0, the indices of
 + * the MSI-X table entries used by port services must not exceed 31
   */
 -#define PCIE_PORT_MAX_MSI_ENTRIES	32
 +#define PCIE_PORT_MAX_MSIX_ENTRIES	32
  
  #define get_descriptor_id(type, service) (((type - 4) << 8) | service)
  
diff --cc drivers/pci/pcie/portdrv_core.c
index b7a5dc54a88e,6890aea4a550..000000000000
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@@ -189,20 -192,13 +189,29 @@@ static int pcie_init_service_irqs(struc
   */
  static int get_port_device_capability(struct pci_dev *dev)
  {
++<<<<<<< HEAD
++=======
+ 	struct pci_host_bridge *host = pci_find_host_bridge(dev->bus);
++>>>>>>> d850882b726f (PCI/portdrv: Rename and reverse sense of pcie_ports_auto)
  	int services = 0;
 +	int cap_mask = 0;
 +
++<<<<<<< HEAD
 +	cap_mask = PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP
 +			| PCIE_PORT_SERVICE_VC | PCIE_PORT_SERVICE_DPC;
 +	if (pci_aer_available())
 +		cap_mask |= PCIE_PORT_SERVICE_AER;
  
 +	if (pcie_ports_auto)
 +		pcie_port_platform_notify(dev, &cap_mask);
 +
 +	/* Hot-Plug Capable */
 +	if ((cap_mask & PCIE_PORT_SERVICE_HP) && dev->is_hotplug_bridge) {
++=======
+ 	if (dev->is_hotplug_bridge &&
+ 	    (pcie_ports_native || host->native_hotplug)) {
++>>>>>>> d850882b726f (PCI/portdrv: Rename and reverse sense of pcie_ports_auto)
  		services |= PCIE_PORT_SERVICE_HP;
 -
  		/*
  		 * Disable hot-plug interrupts in case they have been enabled
  		 * by the BIOS and the hot-plug service driver is not loaded.
@@@ -210,23 -206,27 +219,40 @@@
  		pcie_capability_clear_word(dev, PCI_EXP_SLTCTL,
  			  PCI_EXP_SLTCTL_CCIE | PCI_EXP_SLTCTL_HPIE);
  	}
++<<<<<<< HEAD
 +	/* AER capable */
 +	if ((cap_mask & PCIE_PORT_SERVICE_AER)
 +	    && pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR)) {
++=======
+ 
+ 	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR) &&
+ 	    pci_aer_available() && (pcie_ports_native || host->native_aer)) {
++>>>>>>> d850882b726f (PCI/portdrv: Rename and reverse sense of pcie_ports_auto)
  		services |= PCIE_PORT_SERVICE_AER;
 -
  		/*
  		 * Disable AER on this port in case it's been enabled by the
  		 * BIOS (the AER service driver will enable it when necessary).
  		 */
  		pci_disable_pcie_error_reporting(dev);
  	}
++<<<<<<< HEAD
 +	/* VC support */
 +	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_VC))
 +		services |= PCIE_PORT_SERVICE_VC;
 +	/* Root ports are capable of generating PME too */
 +	if ((cap_mask & PCIE_PORT_SERVICE_PME)
 +	    && pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT) {
++=======
+ 
+ 	/*
+ 	 * Root ports are capable of generating PME too.  Root Complex
+ 	 * Event Collectors can also generate PMEs, but we don't handle
+ 	 * those yet.
+ 	 */
+ 	if (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT &&
+ 	    (pcie_ports_native || host->native_pme)) {
++>>>>>>> d850882b726f (PCI/portdrv: Rename and reverse sense of pcie_ports_auto)
  		services |= PCIE_PORT_SERVICE_PME;
 -
  		/*
  		 * Disable PME interrupt on this port in case it's been enabled
  		 * by the BIOS (the PME service driver will enable it when
diff --cc drivers/pci/pcie/portdrv_pci.c
index 870bdb036ac1,8e4260d25941..000000000000
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@@ -42,15 -33,10 +43,20 @@@ bool pcie_ports_native
  
  static int __init pcie_port_setup(char *str)
  {
- 	if (!strncmp(str, "compat", 6)) {
+ 	if (!strncmp(str, "compat", 6))
  		pcie_ports_disabled = true;
++<<<<<<< HEAD
 +	} else if (!strncmp(str, "native", 6)) {
 +		pcie_ports_disabled = false;
 +		pcie_ports_auto = false;
 +	} else if (!strncmp(str, "auto", 4)) {
 +		pcie_ports_disabled = false;
 +		pcie_ports_auto = true;
 +	}
++=======
+ 	else if (!strncmp(str, "native", 6))
+ 		pcie_ports_native = true;
++>>>>>>> d850882b726f (PCI/portdrv: Rename and reverse sense of pcie_ports_auto)
  
  	return 1;
  }
* Unmerged path drivers/pci/pcie/portdrv.h
* Unmerged path drivers/pci/pcie/portdrv_core.c
* Unmerged path drivers/pci/pcie/portdrv_pci.c
