bpf: allow access into map value arrays

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Josef Bacik <jbacik@fb.com>
commit 484611357c19f9e19ef742ebef4505a07d243cc9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/48461135.failed

Suppose you have a map array value that is something like this

struct foo {
	unsigned iter;
	int array[SOME_CONSTANT];
};

You can easily insert this into an array, but you cannot modify the contents of
foo->array[] after the fact.  This is because we have no way to verify we won't
go off the end of the array at verification time.  This patch provides a start
for this work.  We accomplish this by keeping track of a minimum and maximum
value a register could be while we're checking the code.  Then at the time we
try to do an access into a MAP_VALUE we verify that the maximum offset into that
region is a valid access into that memory region.  So in practice, code such as
this

unsigned index = 0;

if (foo->iter >= SOME_CONSTANT)
	foo->iter = index;
else
	index = foo->iter++;
foo->array[index] = bar;

would be allowed, as we can verify that index will always be between 0 and
SOME_CONSTANT-1.  If you wish to use signed values you'll have to have an extra
check to make sure the index isn't less than 0, or do something like index %=
SOME_CONSTANT.

	Signed-off-by: Josef Bacik <jbacik@fb.com>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 484611357c19f9e19ef742ebef4505a07d243cc9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	include/linux/bpf_verifier.h
#	kernel/bpf/verifier.c
#	samples/bpf/libbpf.h
#	samples/bpf/test_verifier.c
diff --cc include/linux/bpf.h
index d4c1f9049ad3,c201017b5730..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -84,8 -96,60 +84,56 @@@ struct bpf_map *bpf_map_get(struct fd f
  struct bpf_func_proto {
  	u64 (*func)(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5);
  	bool gpl_only;
 -	bool pkt_access;
 -	enum bpf_return_type ret_type;
 -	enum bpf_arg_type arg1_type;
 -	enum bpf_arg_type arg2_type;
 -	enum bpf_arg_type arg3_type;
 -	enum bpf_arg_type arg4_type;
 -	enum bpf_arg_type arg5_type;
  };
  
++<<<<<<< HEAD
++=======
+ /* bpf_context is intentionally undefined structure. Pointer to bpf_context is
+  * the first argument to eBPF programs.
+  * For socket filters: 'struct bpf_context *' == 'struct sk_buff *'
+  */
+ struct bpf_context;
+ 
+ enum bpf_access_type {
+ 	BPF_READ = 1,
+ 	BPF_WRITE = 2
+ };
+ 
+ /* types of values stored in eBPF registers */
+ enum bpf_reg_type {
+ 	NOT_INIT = 0,		 /* nothing was written into register */
+ 	UNKNOWN_VALUE,		 /* reg doesn't contain a valid pointer */
+ 	PTR_TO_CTX,		 /* reg points to bpf_context */
+ 	CONST_PTR_TO_MAP,	 /* reg points to struct bpf_map */
+ 	PTR_TO_MAP_VALUE,	 /* reg points to map element value */
+ 	PTR_TO_MAP_VALUE_OR_NULL,/* points to map elem value or NULL */
+ 	FRAME_PTR,		 /* reg == frame_pointer */
+ 	PTR_TO_STACK,		 /* reg == frame_pointer + imm */
+ 	CONST_IMM,		 /* constant integer value */
+ 
+ 	/* PTR_TO_PACKET represents:
+ 	 * skb->data
+ 	 * skb->data + imm
+ 	 * skb->data + (u16) var
+ 	 * skb->data + (u16) var + imm
+ 	 * if (range > 0) then [ptr, ptr + range - off) is safe to access
+ 	 * if (id > 0) means that some 'var' was added
+ 	 * if (off > 0) menas that 'imm' was added
+ 	 */
+ 	PTR_TO_PACKET,
+ 	PTR_TO_PACKET_END,	 /* skb->data + headlen */
+ 
+ 	/* PTR_TO_MAP_VALUE_ADJ is used for doing pointer math inside of a map
+ 	 * elem value.  We only allow this if we can statically verify that
+ 	 * access from this register are going to fall within the size of the
+ 	 * map element.
+ 	 */
+ 	PTR_TO_MAP_VALUE_ADJ,
+ };
+ 
+ struct bpf_prog;
+ 
++>>>>>>> 484611357c19 (bpf: allow access into map value arrays)
  struct bpf_verifier_ops {
  	/* return eBPF function prototype for verification */
  	const struct bpf_func_proto *(*get_func_proto)(enum bpf_func_id func_id);
* Unmerged path include/linux/bpf_verifier.h
* Unmerged path kernel/bpf/verifier.c
* Unmerged path samples/bpf/libbpf.h
* Unmerged path samples/bpf/test_verifier.c
* Unmerged path include/linux/bpf.h
* Unmerged path include/linux/bpf_verifier.h
* Unmerged path kernel/bpf/verifier.c
* Unmerged path samples/bpf/libbpf.h
* Unmerged path samples/bpf/test_verifier.c
