bpf: fix net.core.bpf_jit_enable race

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Alexei Starovoitov <ast@fb.com>
commit 60b58afc96c9df71871df2dbad42037757ceef26
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/60b58afc.failed

global bpf_jit_enable variable is tested multiple times in JITs,
blinding and verifier core. The malicious root can try to toggle
it while loading the programs. This race condition was accounted
for and there should be no issues, but it's safer to avoid
this race condition.

	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Daniel Borkmann <daniel@iogearbox.net>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 60b58afc96c9df71871df2dbad42037757ceef26)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/net/bpf_jit_32.c
#	arch/arm64/net/bpf_jit_comp.c
#	arch/mips/net/ebpf_jit.c
#	arch/powerpc/net/bpf_jit_comp64.c
#	arch/s390/net/bpf_jit_comp.c
#	arch/sparc/net/bpf_jit_comp_64.c
#	arch/x86/net/bpf_jit_comp.c
#	include/linux/filter.h
#	kernel/bpf/core.c
#	kernel/bpf/verifier.c
diff --cc arch/arm/net/bpf_jit_32.c
index 09420d09618b,4425189bb24c..000000000000
--- a/arch/arm/net/bpf_jit_32.c
+++ b/arch/arm/net/bpf_jit_32.c
@@@ -857,27 -1806,66 +857,48 @@@ b_epilogue
  	return 0;
  }
  
 -void bpf_jit_compile(struct bpf_prog *prog)
 -{
 -	/* Nothing to do here. We support Internal BPF. */
 -}
  
 -struct bpf_prog *bpf_int_jit_compile(struct bpf_prog *prog)
 +void bpf_jit_compile(struct sk_filter *fp)
  {
 -	struct bpf_prog *tmp, *orig_prog = prog;
 -	struct bpf_binary_header *header;
 -	bool tmp_blinded = false;
  	struct jit_ctx ctx;
 -	unsigned int tmp_idx;
 -	unsigned int image_size;
 -	u8 *image_ptr;
 +	unsigned tmp_idx;
 +	unsigned alloc_size;
  
++<<<<<<< HEAD
 +	if (!bpf_jit_enable)
 +		return;
++=======
+ 	/* If BPF JIT was not enabled then we must fall back to
+ 	 * the interpreter.
+ 	 */
+ 	if (!prog->jit_requested)
+ 		return orig_prog;
+ 
+ 	/* If constant blinding was enabled and we failed during blinding
+ 	 * then we must fall back to the interpreter. Otherwise, we save
+ 	 * the new JITed code.
+ 	 */
+ 	tmp = bpf_jit_blind_constants(prog);
+ 
+ 	if (IS_ERR(tmp))
+ 		return orig_prog;
+ 	if (tmp != prog) {
+ 		tmp_blinded = true;
+ 		prog = tmp;
+ 	}
++>>>>>>> 60b58afc96c9 (bpf: fix net.core.bpf_jit_enable race)
  
  	memset(&ctx, 0, sizeof(ctx));
 -	ctx.prog = prog;
 +	ctx.skf		= fp;
 +	ctx.ret0_fp_idx = -1;
  
 -	/* Not able to allocate memory for offsets[] , then
 -	 * we must fall back to the interpreter
 -	 */
 -	ctx.offsets = kcalloc(prog->len, sizeof(int), GFP_KERNEL);
 -	if (ctx.offsets == NULL) {
 -		prog = orig_prog;
 -		goto out;
 -	}
 +	ctx.offsets = kzalloc(4 * (ctx.skf->len + 1), GFP_KERNEL);
 +	if (ctx.offsets == NULL)
 +		return;
  
 -	/* 1) fake pass to find in the length of the JITed code,
 -	 * to compute ctx->offsets and other context variables
 -	 * needed to compute final JITed code.
 -	 * Also, calculate random starting pointer/start of JITed code
 -	 * which is prefixed by random number of fault instructions.
 -	 *
 -	 * If the first pass fails then there is no chance of it
 -	 * being successful in the second pass, so just fall back
 -	 * to the interpreter.
 -	 */
 -	if (build_body(&ctx)) {
 -		prog = orig_prog;
 -		goto out_off;
 -	}
 +	/* fake pass to fill in the ctx->seen */
 +	if (unlikely(build_body(&ctx)))
 +		goto out;
  
  	tmp_idx = ctx.idx;
  	build_prologue(&ctx);
diff --cc arch/s390/net/bpf_jit_comp.c
index 600b1e5c8c9d,f4baa8c514d3..000000000000
--- a/arch/s390/net/bpf_jit_comp.c
+++ b/arch/s390/net/bpf_jit_comp.c
@@@ -641,187 -1068,299 +641,252 @@@ call_fn:	/* lg %r1,<d(function)>(%r13) 
  		/* j <exit> */
  		EMIT4_PCREL(0xa7f40000, jit->exit_ip - jit->prg);
  		break;
 -	/*
 -	 * Branch relative (number of skipped instructions) to offset on
 -	 * condition.
 -	 *
 -	 * Condition code to mask mapping:
 -	 *
 -	 * CC | Description	   | Mask
 -	 * ------------------------------
 -	 * 0  | Operands equal	   |	8
 -	 * 1  | First operand low  |	4
 -	 * 2  | First operand high |	2
 -	 * 3  | Unused		   |	1
 -	 *
 -	 * For s390x relative branches: ip = ip + off_bytes
 -	 * For BPF relative branches:	insn = insn + off_insns + 1
 -	 *
 -	 * For example for s390x with offset 0 we jump to the branch
 -	 * instruction itself (loop) and for BPF with offset 0 we
 -	 * branch to the instruction behind the branch.
 -	 */
 -	case BPF_JMP | BPF_JA: /* if (true) */
 -		mask = 0xf000; /* j */
 -		goto branch_oc;
 -	case BPF_JMP | BPF_JSGT | BPF_K: /* ((s64) dst > (s64) imm) */
 -		mask = 0x2000; /* jh */
 -		goto branch_ks;
 -	case BPF_JMP | BPF_JSLT | BPF_K: /* ((s64) dst < (s64) imm) */
 -		mask = 0x4000; /* jl */
 -		goto branch_ks;
 -	case BPF_JMP | BPF_JSGE | BPF_K: /* ((s64) dst >= (s64) imm) */
 -		mask = 0xa000; /* jhe */
 -		goto branch_ks;
 -	case BPF_JMP | BPF_JSLE | BPF_K: /* ((s64) dst <= (s64) imm) */
 -		mask = 0xc000; /* jle */
 -		goto branch_ks;
 -	case BPF_JMP | BPF_JGT | BPF_K: /* (dst_reg > imm) */
 -		mask = 0x2000; /* jh */
 -		goto branch_ku;
 -	case BPF_JMP | BPF_JLT | BPF_K: /* (dst_reg < imm) */
 -		mask = 0x4000; /* jl */
 -		goto branch_ku;
 -	case BPF_JMP | BPF_JGE | BPF_K: /* (dst_reg >= imm) */
 -		mask = 0xa000; /* jhe */
 -		goto branch_ku;
 -	case BPF_JMP | BPF_JLE | BPF_K: /* (dst_reg <= imm) */
 -		mask = 0xc000; /* jle */
 -		goto branch_ku;
 -	case BPF_JMP | BPF_JNE | BPF_K: /* (dst_reg != imm) */
 -		mask = 0x7000; /* jne */
 -		goto branch_ku;
 -	case BPF_JMP | BPF_JEQ | BPF_K: /* (dst_reg == imm) */
 -		mask = 0x8000; /* je */
 -		goto branch_ku;
 -	case BPF_JMP | BPF_JSET | BPF_K: /* (dst_reg & imm) */
 -		mask = 0x7000; /* jnz */
 -		/* lgfi %w1,imm (load sign extend imm) */
 -		EMIT6_IMM(0xc0010000, REG_W1, imm);
 -		/* ngr %w1,%dst */
 -		EMIT4(0xb9800000, REG_W1, dst_reg);
 -		goto branch_oc;
 -
 -	case BPF_JMP | BPF_JSGT | BPF_X: /* ((s64) dst > (s64) src) */
 -		mask = 0x2000; /* jh */
 -		goto branch_xs;
 -	case BPF_JMP | BPF_JSLT | BPF_X: /* ((s64) dst < (s64) src) */
 -		mask = 0x4000; /* jl */
 -		goto branch_xs;
 -	case BPF_JMP | BPF_JSGE | BPF_X: /* ((s64) dst >= (s64) src) */
 -		mask = 0xa000; /* jhe */
 -		goto branch_xs;
 -	case BPF_JMP | BPF_JSLE | BPF_X: /* ((s64) dst <= (s64) src) */
 -		mask = 0xc000; /* jle */
 -		goto branch_xs;
 -	case BPF_JMP | BPF_JGT | BPF_X: /* (dst > src) */
 -		mask = 0x2000; /* jh */
 -		goto branch_xu;
 -	case BPF_JMP | BPF_JLT | BPF_X: /* (dst < src) */
 -		mask = 0x4000; /* jl */
 -		goto branch_xu;
 -	case BPF_JMP | BPF_JGE | BPF_X: /* (dst >= src) */
 -		mask = 0xa000; /* jhe */
 -		goto branch_xu;
 -	case BPF_JMP | BPF_JLE | BPF_X: /* (dst <= src) */
 -		mask = 0xc000; /* jle */
 -		goto branch_xu;
 -	case BPF_JMP | BPF_JNE | BPF_X: /* (dst != src) */
 -		mask = 0x7000; /* jne */
 -		goto branch_xu;
 -	case BPF_JMP | BPF_JEQ | BPF_X: /* (dst == src) */
 -		mask = 0x8000; /* je */
 -		goto branch_xu;
 -	case BPF_JMP | BPF_JSET | BPF_X: /* (dst & src) */
 -		mask = 0x7000; /* jnz */
 -		/* ngrk %w1,%dst,%src */
 -		EMIT4_RRF(0xb9e40000, REG_W1, dst_reg, src_reg);
 -		goto branch_oc;
 -branch_ks:
 -		/* lgfi %w1,imm (load sign extend imm) */
 -		EMIT6_IMM(0xc0010000, REG_W1, imm);
 -		/* cgrj %dst,%w1,mask,off */
 -		EMIT6_PCREL(0xec000000, 0x0064, dst_reg, REG_W1, i, off, mask);
 -		break;
 -branch_ku:
 -		/* lgfi %w1,imm (load sign extend imm) */
 -		EMIT6_IMM(0xc0010000, REG_W1, imm);
 -		/* clgrj %dst,%w1,mask,off */
 -		EMIT6_PCREL(0xec000000, 0x0065, dst_reg, REG_W1, i, off, mask);
 -		break;
 -branch_xs:
 -		/* cgrj %dst,%src,mask,off */
 -		EMIT6_PCREL(0xec000000, 0x0064, dst_reg, src_reg, i, off, mask);
 -		break;
 -branch_xu:
 -		/* clgrj %dst,%src,mask,off */
 -		EMIT6_PCREL(0xec000000, 0x0065, dst_reg, src_reg, i, off, mask);
 -		break;
 -branch_oc:
 -		/* brc mask,jmp_off (branch instruction needs 4 bytes) */
 -		jmp_off = addrs[i + off + 1] - (addrs[i + 1] - 4);
 -		EMIT4_PCREL(0xa7040000 | mask << 8, jmp_off);
 +	case BPF_S_ST: /* mem[K] = A */
 +		jit->seen |= SEEN_MEM;
 +		/* st %r5,<K>(%r15) */
 +		EMIT4_DISP(0x5050f000,
 +			   (jit->seen & SEEN_DATAREF) ? 160 + K*4 : K*4);
 +		break;
 +	case BPF_S_STX: /* mem[K] = X : mov %ebx,off8(%rbp) */
 +		jit->seen |= SEEN_XREG | SEEN_MEM;
 +		/* st %r12,<K>(%r15) */
 +		EMIT4_DISP(0x50c0f000,
 +			   (jit->seen & SEEN_DATAREF) ? 160 + K*4 : K*4);
 +		break;
 +	case BPF_S_ANC_PROTOCOL: /* A = ntohs(skb->protocol); */
 +		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);
 +		/* lhi %r5,0 */
 +		EMIT4(0xa7580000);
 +		/* icm	%r5,3,<d(protocol)>(%r2) */
 +		EMIT4_DISP(0xbf532000, offsetof(struct sk_buff, protocol));
 +		break;
 +	case BPF_S_ANC_IFINDEX:	/* if (!skb->dev) return 0;
 +				 * A = skb->dev->ifindex */
 +		BUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);
 +		jit->seen |= SEEN_RET0;
 +		/* lg %r1,<d(dev)>(%r2) */
 +		EMIT6_DISP(0xe3102000, 0x0004, offsetof(struct sk_buff, dev));
 +		/* ltgr %r1,%r1 */
 +		EMIT4(0xb9020011);
 +		/* jz <ret0> */
 +		EMIT4_PCREL(0xa7840000, jit->ret0_ip - jit->prg);
 +		/* l %r5,<d(ifindex)>(%r1) */
 +		EMIT4_DISP(0x58501000, offsetof(struct net_device, ifindex));
 +		break;
 +	case BPF_S_ANC_MARK: /* A = skb->mark */
 +		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);
 +		/* l %r5,<d(mark)>(%r2) */
 +		EMIT4_DISP(0x58502000, offsetof(struct sk_buff, mark));
 +		break;
 +	case BPF_S_ANC_QUEUE: /* A = skb->queue_mapping */
 +		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);
 +		/* lhi %r5,0 */
 +		EMIT4(0xa7580000);
 +		/* icm	%r5,3,<d(queue_mapping)>(%r2) */
 +		EMIT4_DISP(0xbf532000, offsetof(struct sk_buff, queue_mapping));
 +		break;
 +	case BPF_S_ANC_HATYPE:	/* if (!skb->dev) return 0;
 +				 * A = skb->dev->type */
 +		BUILD_BUG_ON(FIELD_SIZEOF(struct net_device, type) != 2);
 +		jit->seen |= SEEN_RET0;
 +		/* lg %r1,<d(dev)>(%r2) */
 +		EMIT6_DISP(0xe3102000, 0x0004, offsetof(struct sk_buff, dev));
 +		/* ltgr %r1,%r1 */
 +		EMIT4(0xb9020011);
 +		/* jz <ret0> */
 +		EMIT4_PCREL(0xa7840000, jit->ret0_ip - jit->prg);
 +		/* lhi %r5,0 */
 +		EMIT4(0xa7580000);
 +		/* icm	%r5,3,<d(type)>(%r1) */
 +		EMIT4_DISP(0xbf531000, offsetof(struct net_device, type));
 +		break;
 +	case BPF_S_ANC_RXHASH: /* A = skb->hash */
 +		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, hash) != 4);
 +		/* l %r5,<d(hash)>(%r2) */
 +		EMIT4_DISP(0x58502000, offsetof(struct sk_buff, hash));
 +		break;
 +	case BPF_S_ANC_VLAN_TAG:
 +	case BPF_S_ANC_VLAN_TAG_PRESENT:
 +		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, vlan_tci) != 2);
 +		BUILD_BUG_ON(VLAN_TAG_PRESENT != 0x1000);
 +		/* lhi %r5,0 */
 +		EMIT4(0xa7580000);
 +		/* icm	%r5,3,<d(vlan_tci)>(%r2) */
 +		EMIT4_DISP(0xbf532000, offsetof(struct sk_buff, vlan_tci));
 +		if (filter->code == BPF_S_ANC_VLAN_TAG) {
 +			/* nill %r5,0xefff */
 +			EMIT4_IMM(0xa5570000, ~VLAN_TAG_PRESENT);
 +		} else {
 +			/* nill %r5,0x1000 */
 +			EMIT4_IMM(0xa5570000, VLAN_TAG_PRESENT);
 +			/* srl %r5,12 */
 +			EMIT4_DISP(0x88500000, 12);
 +		}
  		break;
 -	/*
 -	 * BPF_LD
 -	 */
 -	case BPF_LD | BPF_ABS | BPF_B: /* b0 = *(u8 *) (skb->data+imm) */
 -	case BPF_LD | BPF_IND | BPF_B: /* b0 = *(u8 *) (skb->data+imm+src) */
 -		if ((BPF_MODE(insn->code) == BPF_ABS) && (imm >= 0))
 -			func_addr = __pa(sk_load_byte_pos);
 -		else
 -			func_addr = __pa(sk_load_byte);
 -		goto call_fn;
 -	case BPF_LD | BPF_ABS | BPF_H: /* b0 = *(u16 *) (skb->data+imm) */
 -	case BPF_LD | BPF_IND | BPF_H: /* b0 = *(u16 *) (skb->data+imm+src) */
 -		if ((BPF_MODE(insn->code) == BPF_ABS) && (imm >= 0))
 -			func_addr = __pa(sk_load_half_pos);
 -		else
 -			func_addr = __pa(sk_load_half);
 -		goto call_fn;
 -	case BPF_LD | BPF_ABS | BPF_W: /* b0 = *(u32 *) (skb->data+imm) */
 -	case BPF_LD | BPF_IND | BPF_W: /* b0 = *(u32 *) (skb->data+imm+src) */
 -		if ((BPF_MODE(insn->code) == BPF_ABS) && (imm >= 0))
 -			func_addr = __pa(sk_load_word_pos);
 -		else
 -			func_addr = __pa(sk_load_word);
 -		goto call_fn;
 -call_fn:
 -		jit->seen |= SEEN_SKB | SEEN_RET0 | SEEN_FUNC;
 -		REG_SET_SEEN(REG_14); /* Return address of possible func call */
 -
 -		/*
 -		 * Implicit input:
 -		 *  BPF_REG_6	 (R7) : skb pointer
 -		 *  REG_SKB_DATA (R12): skb data pointer (if no BPF_REG_AX)
 -		 *
 -		 * Calculated input:
 -		 *  BPF_REG_2	 (R3) : offset of byte(s) to fetch in skb
 -		 *  BPF_REG_5	 (R6) : return address
 -		 *
 -		 * Output:
 -		 *  BPF_REG_0	 (R14): data read from skb
 -		 *
 -		 * Scratch registers (BPF_REG_1-5)
 -		 */
 -
 -		/* Call function: llilf %w1,func_addr  */
 -		EMIT6_IMM(0xc00f0000, REG_W1, func_addr);
 -
 -		/* Offset: lgfi %b2,imm */
 -		EMIT6_IMM(0xc0010000, BPF_REG_2, imm);
 -		if (BPF_MODE(insn->code) == BPF_IND)
 -			/* agfr %b2,%src (%src is s32 here) */
 -			EMIT4(0xb9180000, BPF_REG_2, src_reg);
 -
 -		/* Reload REG_SKB_DATA if BPF_REG_AX is used */
 -		if (jit->seen & SEEN_REG_AX)
 -			/* lg %skb_data,data_off(%b6) */
 -			EMIT6_DISP_LH(0xe3000000, 0x0004, REG_SKB_DATA, REG_0,
 -				      BPF_REG_6, offsetof(struct sk_buff, data));
 -		/* basr %b5,%w1 (%b5 is call saved) */
 -		EMIT2(0x0d00, BPF_REG_5, REG_W1);
 -
 -		/*
 -		 * Note: For fast access we jump directly after the
 -		 * jnz instruction from bpf_jit.S
 -		 */
 -		/* jnz <ret0> */
 -		EMIT4_PCREL(0xa7740000, jit->ret0_ip - jit->prg);
 +	case BPF_S_ANC_CPU: /* A = smp_processor_id() */
 +#ifdef CONFIG_SMP
 +		/* l %r5,<d(cpu_nr)> */
 +		EMIT4_DISP(0x58500000, offsetof(struct _lowcore, cpu_nr));
 +#else
 +		/* lhi %r5,0 */
 +		EMIT4(0xa7580000);
 +#endif
  		break;
  	default: /* too complex, give up */
++<<<<<<< HEAD
++=======
+ 		pr_err("Unknown opcode %02x\n", insn->code);
+ 		return -1;
+ 	}
+ 	return insn_count;
+ }
+ 
+ /*
+  * Compile eBPF program into s390x code
+  */
+ static int bpf_jit_prog(struct bpf_jit *jit, struct bpf_prog *fp)
+ {
+ 	int i, insn_count;
+ 
+ 	jit->lit = jit->lit_start;
+ 	jit->prg = 0;
+ 
+ 	bpf_jit_prologue(jit, fp->aux->stack_depth);
+ 	for (i = 0; i < fp->len; i += insn_count) {
+ 		insn_count = bpf_jit_insn(jit, fp, i);
+ 		if (insn_count < 0)
+ 			return -1;
+ 		/* Next instruction address */
+ 		jit->addrs[i + insn_count] = jit->prg;
+ 	}
+ 	bpf_jit_epilogue(jit, fp->aux->stack_depth);
+ 
+ 	jit->lit_start = jit->prg;
+ 	jit->size = jit->lit;
+ 	jit->size_prg = jit->prg;
+ 	return 0;
+ }
+ 
+ /*
+  * Compile eBPF program "fp"
+  */
+ struct bpf_prog *bpf_int_jit_compile(struct bpf_prog *fp)
+ {
+ 	struct bpf_prog *tmp, *orig_fp = fp;
+ 	struct bpf_binary_header *header;
+ 	bool tmp_blinded = false;
+ 	struct bpf_jit jit;
+ 	int pass;
+ 
+ 	if (!fp->jit_requested)
+ 		return orig_fp;
+ 
+ 	tmp = bpf_jit_blind_constants(fp);
+ 	/*
+ 	 * If blinding was requested and we failed during blinding,
+ 	 * we must fall back to the interpreter.
+ 	 */
+ 	if (IS_ERR(tmp))
+ 		return orig_fp;
+ 	if (tmp != fp) {
+ 		tmp_blinded = true;
+ 		fp = tmp;
+ 	}
+ 
+ 	memset(&jit, 0, sizeof(jit));
+ 	jit.addrs = kcalloc(fp->len + 1, sizeof(*jit.addrs), GFP_KERNEL);
+ 	if (jit.addrs == NULL) {
+ 		fp = orig_fp;
++>>>>>>> 60b58afc96c9 (bpf: fix net.core.bpf_jit_enable race)
  		goto out;
  	}
 -	/*
 -	 * Three initial passes:
 -	 *   - 1/2: Determine clobbered registers
 -	 *   - 3:   Calculate program size and addrs arrray
 -	 */
 -	for (pass = 1; pass <= 3; pass++) {
 -		if (bpf_jit_prog(&jit, fp)) {
 -			fp = orig_fp;
 -			goto free_addrs;
 +	addrs[i] = jit->prg - jit->start;
 +	return 0;
 +out:
 +	return -1;
 +}
 +
 +void bpf_jit_compile(struct sk_filter *fp)
 +{
 +	unsigned long size, prg_len, lit_len;
 +	struct bpf_jit jit, cjit;
 +	unsigned int *addrs;
 +	int pass, i;
 +
 +	if (!bpf_jit_enable)
 +		return;
 +	addrs = kcalloc(fp->len, sizeof(*addrs), GFP_KERNEL);
 +	if (addrs == NULL)
 +		return;
 +	memset(&jit, 0, sizeof(cjit));
 +	memset(&cjit, 0, sizeof(cjit));
 +
 +	for (pass = 0; pass < 10; pass++) {
 +		jit.prg = jit.start;
 +		jit.lit = jit.mid;
 +
 +		bpf_jit_prologue(&jit);
 +		bpf_jit_noleaks(&jit, fp->insns);
 +		for (i = 0; i < fp->len; i++) {
 +			if (bpf_jit_insn(&jit, fp->insns + i, addrs, i,
 +					 i == fp->len - 1))
 +				goto out;
  		}
 -	}
 -	/*
 -	 * Final pass: Allocate and generate program
 -	 */
 -	if (jit.size >= BPF_SIZE_MAX) {
 -		fp = orig_fp;
 -		goto free_addrs;
 -	}
 -	header = bpf_jit_binary_alloc(jit.size, &jit.prg_buf, 2, jit_fill_hole);
 -	if (!header) {
 -		fp = orig_fp;
 -		goto free_addrs;
 -	}
 -	if (bpf_jit_prog(&jit, fp)) {
 -		fp = orig_fp;
 -		goto free_addrs;
 +		bpf_jit_epilogue(&jit);
 +		if (jit.start) {
 +			WARN_ON(jit.prg > cjit.prg || jit.lit > cjit.lit);
 +			if (memcmp(&jit, &cjit, sizeof(jit)) == 0)
 +				break;
 +		} else if (jit.prg == cjit.prg && jit.lit == cjit.lit) {
 +			prg_len = jit.prg - jit.start;
 +			lit_len = jit.lit - jit.mid;
 +			size = max_t(unsigned long, prg_len + lit_len,
 +				     sizeof(struct work_struct));
 +			if (size >= BPF_SIZE_MAX)
 +				goto out;
 +			jit.start = module_alloc(size);
 +			if (!jit.start)
 +				goto out;
 +			jit.prg = jit.mid = jit.start + prg_len;
 +			jit.lit = jit.end = jit.start + prg_len + lit_len;
 +			jit.base_ip += (unsigned long) jit.start;
 +			jit.exit_ip += (unsigned long) jit.start;
 +			jit.ret0_ip += (unsigned long) jit.start;
 +		}
 +		cjit = jit;
  	}
  	if (bpf_jit_enable > 1) {
 -		bpf_jit_dump(fp->len, jit.size, pass, jit.prg_buf);
 -		print_fn_code(jit.prg_buf, jit.size_prg);
 +		pr_err("flen=%d proglen=%lu pass=%d image=%p\n",
 +		       fp->len, jit.end - jit.start, pass, jit.start);
 +		if (jit.start) {
 +			printk(KERN_ERR "JIT code:\n");
 +			print_fn_code(jit.start, jit.mid - jit.start);
 +			print_hex_dump(KERN_ERR, "JIT literals:\n",
 +				       DUMP_PREFIX_ADDRESS, 16, 1,
 +				       jit.mid, jit.end - jit.mid, false);
 +		}
  	}
 -	bpf_jit_binary_lock_ro(header);
 -	fp->bpf_func = (void *) jit.prg_buf;
 -	fp->jited = 1;
 -	fp->jited_len = jit.size;
 -free_addrs:
 -	kfree(jit.addrs);
 +	if (jit.start)
 +		fp->bpf_func = (void *) jit.start;
  out:
 -	if (tmp_blinded)
 -		bpf_jit_prog_release_other(fp, fp == orig_fp ?
 -					   tmp : orig_fp);
 -	return fp;
 +	kfree(addrs);
 +}
 +
 +static void jit_free_defer(struct work_struct *arg)
 +{
 +	module_free(NULL, arg);
 +}
 +
 +/* run from softirq, we must use a work_struct to call
 + * module_free() from process context
 + */
 +void bpf_jit_free(struct sk_filter *fp)
 +{
 +	struct work_struct *work;
 +
 +	if (fp->bpf_func == sk_run_filter)
 +		return;
 +	work = (struct work_struct *)fp->bpf_func;
 +	INIT_WORK(work, jit_free_defer);
 +	schedule_work(work);
  }
diff --cc arch/x86/net/bpf_jit_comp.c
index 76c7b3a140ad,68859b58ab84..000000000000
--- a/arch/x86/net/bpf_jit_comp.c
+++ b/arch/x86/net/bpf_jit_comp.c
@@@ -124,607 -112,1065 +124,612 @@@ static inline void bpf_flush_icache(voi
  #define CHOOSE_LOAD_FUNC(K, func) \
  	((int)K < 0 ? ((int)K >= SKF_LL_OFF ? func##_negative_offset : func) : func##_positive_offset)
  
 -/* pick a register outside of BPF range for JIT internal work */
 -#define AUX_REG (MAX_BPF_JIT_REG + 1)
 -
 -/* The following table maps BPF registers to x64 registers.
 - *
 - * x64 register r12 is unused, since if used as base address
 - * register in load/store instructions, it always needs an
 - * extra byte of encoding and is callee saved.
 - *
 - *  r9 caches skb->len - skb->data_len
 - * r10 caches skb->data, and used for blinding (if enabled)
 - */
 -static const int reg2hex[] = {
 -	[BPF_REG_0] = 0,  /* rax */
 -	[BPF_REG_1] = 7,  /* rdi */
 -	[BPF_REG_2] = 6,  /* rsi */
 -	[BPF_REG_3] = 2,  /* rdx */
 -	[BPF_REG_4] = 1,  /* rcx */
 -	[BPF_REG_5] = 0,  /* r8 */
 -	[BPF_REG_6] = 3,  /* rbx callee saved */
 -	[BPF_REG_7] = 5,  /* r13 callee saved */
 -	[BPF_REG_8] = 6,  /* r14 callee saved */
 -	[BPF_REG_9] = 7,  /* r15 callee saved */
 -	[BPF_REG_FP] = 5, /* rbp readonly */
 -	[BPF_REG_AX] = 2, /* r10 temp register */
 -	[AUX_REG] = 3,    /* r11 temp register */
 -};
 -
 -/* is_ereg() == true if BPF register 'reg' maps to x64 r8..r15
 - * which need extra byte of encoding.
 - * rax,rcx,...,rbp have simpler encoding
 +/* Helper to find the offset of pkt_type in sk_buff
 + * We want to make sure its still a 3bit field starting at a byte boundary.
   */
 -static bool is_ereg(u32 reg)
 +#define PKT_TYPE_MAX 7
 +static int pkt_type_offset(void)
  {
 -	return (1 << reg) & (BIT(BPF_REG_5) |
 -			     BIT(AUX_REG) |
 -			     BIT(BPF_REG_7) |
 -			     BIT(BPF_REG_8) |
 -			     BIT(BPF_REG_9) |
 -			     BIT(BPF_REG_AX));
 -}
 -
 -/* add modifiers if 'reg' maps to x64 registers r8..r15 */
 -static u8 add_1mod(u8 byte, u32 reg)
 -{
 -	if (is_ereg(reg))
 -		byte |= 1;
 -	return byte;
 -}
 -
 -static u8 add_2mod(u8 byte, u32 r1, u32 r2)
 -{
 -	if (is_ereg(r1))
 -		byte |= 1;
 -	if (is_ereg(r2))
 -		byte |= 4;
 -	return byte;
 -}
 -
 -/* encode 'dst_reg' register into x64 opcode 'byte' */
 -static u8 add_1reg(u8 byte, u32 dst_reg)
 -{
 -	return byte + reg2hex[dst_reg];
 -}
 -
 -/* encode 'dst_reg' and 'src_reg' registers into x64 opcode 'byte' */
 -static u8 add_2reg(u8 byte, u32 dst_reg, u32 src_reg)
 -{
 -	return byte + reg2hex[dst_reg] + (reg2hex[src_reg] << 3);
 -}
 -
 -static void jit_fill_hole(void *area, unsigned int size)
 -{
 -	/* fill whole space with int3 instructions */
 -	memset(area, 0xcc, size);
 -}
 -
 -struct jit_context {
 -	int cleanup_addr; /* epilogue code offset */
 -	bool seen_ld_abs;
 -	bool seen_ax_reg;
 -};
 -
 -/* maximum number of bytes emitted while JITing one eBPF insn */
 -#define BPF_MAX_INSN_SIZE	128
 -#define BPF_INSN_SAFETY		64
 -
 -#define AUX_STACK_SPACE \
 -	(32 /* space for rbx, r13, r14, r15 */ + \
 -	 8 /* space for skb_copy_bits() buffer */)
 -
 -#define PROLOGUE_SIZE 37
 -
 -/* emit x64 prologue code for BPF program and check it's size.
 - * bpf_tail_call helper will skip it while jumping into another program
 - */
 -static void emit_prologue(u8 **pprog, u32 stack_depth)
 -{
 -	u8 *prog = *pprog;
 -	int cnt = 0;
 -
 -	EMIT1(0x55); /* push rbp */
 -	EMIT3(0x48, 0x89, 0xE5); /* mov rbp,rsp */
 -
 -	/* sub rsp, rounded_stack_depth + AUX_STACK_SPACE */
 -	EMIT3_off32(0x48, 0x81, 0xEC,
 -		    round_up(stack_depth, 8) + AUX_STACK_SPACE);
 -
 -	/* sub rbp, AUX_STACK_SPACE */
 -	EMIT4(0x48, 0x83, 0xED, AUX_STACK_SPACE);
 -
 -	/* all classic BPF filters use R6(rbx) save it */
 -
 -	/* mov qword ptr [rbp+0],rbx */
 -	EMIT4(0x48, 0x89, 0x5D, 0);
 -
 -	/* bpf_convert_filter() maps classic BPF register X to R7 and uses R8
 -	 * as temporary, so all tcpdump filters need to spill/fill R7(r13) and
 -	 * R8(r14). R9(r15) spill could be made conditional, but there is only
 -	 * one 'bpf_error' return path out of helper functions inside bpf_jit.S
 -	 * The overhead of extra spill is negligible for any filter other
 -	 * than synthetic ones. Therefore not worth adding complexity.
 -	 */
 -
 -	/* mov qword ptr [rbp+8],r13 */
 -	EMIT4(0x4C, 0x89, 0x6D, 8);
 -	/* mov qword ptr [rbp+16],r14 */
 -	EMIT4(0x4C, 0x89, 0x75, 16);
 -	/* mov qword ptr [rbp+24],r15 */
 -	EMIT4(0x4C, 0x89, 0x7D, 24);
 -
 -	/* Clear the tail call counter (tail_call_cnt): for eBPF tail calls
 -	 * we need to reset the counter to 0. It's done in two instructions,
 -	 * resetting rax register to 0 (xor on eax gets 0 extended), and
 -	 * moving it to the counter location.
 -	 */
 -
 -	/* xor eax, eax */
 -	EMIT2(0x31, 0xc0);
 -	/* mov qword ptr [rbp+32], rax */
 -	EMIT4(0x48, 0x89, 0x45, 32);
 -
 -	BUILD_BUG_ON(cnt != PROLOGUE_SIZE);
 -	*pprog = prog;
 +	struct sk_buff skb_probe = {
 +		.pkt_type = ~0,
 +	};
 +	char *ct = (char *)&skb_probe;
 +	unsigned int off;
 +
 +	for (off = 0; off < sizeof(struct sk_buff); off++) {
 +		if (ct[off] == PKT_TYPE_MAX)
 +			return off;
 +	}
 +	pr_err_once("Please fix pkt_type_offset(), as pkt_type couldn't be found\n");
 +	return -1;
  }
  
 -/* generate the following code:
 - * ... bpf_tail_call(void *ctx, struct bpf_array *array, u64 index) ...
 - *   if (index >= array->map.max_entries)
 - *     goto out;
 - *   if (++tail_call_cnt > MAX_TAIL_CALL_CNT)
 - *     goto out;
 - *   prog = array->ptrs[index];
 - *   if (prog == NULL)
 - *     goto out;
 - *   goto *(prog->bpf_func + prologue_size);
 - * out:
 - */
 -static void emit_bpf_tail_call(u8 **pprog)
 +void bpf_jit_compile(struct sk_filter *fp)
  {
 -	u8 *prog = *pprog;
 -	int label1, label2, label3;
 -	int cnt = 0;
 -
 -	/* rdi - pointer to ctx
 -	 * rsi - pointer to bpf_array
 -	 * rdx - index in bpf_array
 -	 */
 -
 -	/* if (index >= array->map.max_entries)
 -	 *   goto out;
 -	 */
 -	EMIT2(0x89, 0xD2);                        /* mov edx, edx */
 -	EMIT3(0x39, 0x56,                         /* cmp dword ptr [rsi + 16], edx */
 -	      offsetof(struct bpf_array, map.max_entries));
 -#define OFFSET1 43 /* number of bytes to jump */
 -	EMIT2(X86_JBE, OFFSET1);                  /* jbe out */
 -	label1 = cnt;
 -
 -	/* if (tail_call_cnt > MAX_TAIL_CALL_CNT)
 -	 *   goto out;
 -	 */
 -	EMIT2_off32(0x8B, 0x85, 36);              /* mov eax, dword ptr [rbp + 36] */
 -	EMIT3(0x83, 0xF8, MAX_TAIL_CALL_CNT);     /* cmp eax, MAX_TAIL_CALL_CNT */
 -#define OFFSET2 32
 -	EMIT2(X86_JA, OFFSET2);                   /* ja out */
 -	label2 = cnt;
 -	EMIT3(0x83, 0xC0, 0x01);                  /* add eax, 1 */
 -	EMIT2_off32(0x89, 0x85, 36);              /* mov dword ptr [rbp + 36], eax */
 -
 -	/* prog = array->ptrs[index]; */
 -	EMIT4_off32(0x48, 0x8B, 0x84, 0xD6,       /* mov rax, [rsi + rdx * 8 + offsetof(...)] */
 -		    offsetof(struct bpf_array, ptrs));
 -
 -	/* if (prog == NULL)
 -	 *   goto out;
 -	 */
 -	EMIT3(0x48, 0x85, 0xC0);		  /* test rax,rax */
 -#define OFFSET3 10
 -	EMIT2(X86_JE, OFFSET3);                   /* je out */
 -	label3 = cnt;
 +	u8 temp[64];
 +	u8 *prog;
 +	unsigned int proglen, oldproglen = 0;
 +	int ilen, i;
 +	int t_offset, f_offset;
 +	u8 t_op, f_op, seen = 0, pass;
 +	u8 *image = NULL;
 +	u8 *func;
 +	int pc_ret0 = -1; /* bpf index of first RET #0 instruction (if any) */
 +	unsigned int cleanup_addr; /* epilogue code offset */
 +	unsigned int *addrs;
 +	const struct sock_filter *filter = fp->insns;
 +	int flen = fp->len;
 +
++<<<<<<< HEAD
 +	if (!bpf_jit_enable)
 +		return;
++=======
++	if (!prog->jit_requested)
++		return orig_prog;
++>>>>>>> 60b58afc96c9 (bpf: fix net.core.bpf_jit_enable race)
  
 -	/* goto *(prog->bpf_func + prologue_size); */
 -	EMIT4(0x48, 0x8B, 0x40,                   /* mov rax, qword ptr [rax + 32] */
 -	      offsetof(struct bpf_prog, bpf_func));
 -	EMIT4(0x48, 0x83, 0xC0, PROLOGUE_SIZE);   /* add rax, prologue_size */
 +	addrs = kmalloc(flen * sizeof(*addrs), GFP_KERNEL);
 +	if (addrs == NULL)
 +		return;
  
 -	/* now we're ready to jump into next BPF program
 -	 * rdi == ctx (1st arg)
 -	 * rax == prog->bpf_func + prologue_size
 +	/* Before first pass, make a rough estimation of addrs[]
 +	 * each bpf instruction is translated to less than 64 bytes
  	 */
 -	EMIT2(0xFF, 0xE0);                        /* jmp rax */
 -
 -	/* out: */
 -	BUILD_BUG_ON(cnt - label1 != OFFSET1);
 -	BUILD_BUG_ON(cnt - label2 != OFFSET2);
 -	BUILD_BUG_ON(cnt - label3 != OFFSET3);
 -	*pprog = prog;
 -}
 -
 -
 -static void emit_load_skb_data_hlen(u8 **pprog)
 -{
 -	u8 *prog = *pprog;
 -	int cnt = 0;
 +	for (proglen = 0, i = 0; i < flen; i++) {
 +		proglen += 64;
 +		addrs[i] = proglen;
 +	}
 +	cleanup_addr = proglen; /* epilogue address */
  
 -	/* r9d = skb->len - skb->data_len (headlen)
 -	 * r10 = skb->data
 +	/* JITed image shrinks with every pass and the loop iterates
 +	 * until the image stops shrinking. Very large bpf programs
 +	 * may converge on the last pass. In such case do one more
 +	 * pass to emit the final image
  	 */
 -	/* mov %r9d, off32(%rdi) */
 -	EMIT3_off32(0x44, 0x8b, 0x8f, offsetof(struct sk_buff, len));
 -
 -	/* sub %r9d, off32(%rdi) */
 -	EMIT3_off32(0x44, 0x2b, 0x8f, offsetof(struct sk_buff, data_len));
 -
 -	/* mov %r10, off32(%rdi) */
 -	EMIT3_off32(0x4c, 0x8b, 0x97, offsetof(struct sk_buff, data));
 -	*pprog = prog;
 -}
 -
 -static int do_jit(struct bpf_prog *bpf_prog, int *addrs, u8 *image,
 -		  int oldproglen, struct jit_context *ctx)
 -{
 -	struct bpf_insn *insn = bpf_prog->insnsi;
 -	int insn_cnt = bpf_prog->len;
 -	bool seen_ld_abs = ctx->seen_ld_abs | (oldproglen == 0);
 -	bool seen_ax_reg = ctx->seen_ax_reg | (oldproglen == 0);
 -	bool seen_exit = false;
 -	u8 temp[BPF_MAX_INSN_SIZE + BPF_INSN_SAFETY];
 -	int i, cnt = 0;
 -	int proglen = 0;
 -	u8 *prog = temp;
 -
 -	emit_prologue(&prog, bpf_prog->aux->stack_depth);
 -
 -	if (seen_ld_abs)
 -		emit_load_skb_data_hlen(&prog);
 -
 -	for (i = 0; i < insn_cnt; i++, insn++) {
 -		const s32 imm32 = insn->imm;
 -		u32 dst_reg = insn->dst_reg;
 -		u32 src_reg = insn->src_reg;
 -		u8 b1 = 0, b2 = 0, b3 = 0;
 -		s64 jmp_offset;
 -		u8 jmp_cond;
 -		bool reload_skb_data;
 -		int ilen;
 -		u8 *func;
 +	for (pass = 0; pass < 10 || image; pass++) {
 +		u8 seen_or_pass0 = (pass == 0) ? (SEEN_XREG | SEEN_DATAREF | SEEN_MEM) : seen;
 +		/* no prologue/epilogue for trivial filters (RET something) */
 +		proglen = 0;
 +		prog = temp;
  
 -		if (dst_reg == BPF_REG_AX || src_reg == BPF_REG_AX)
 -			ctx->seen_ax_reg = seen_ax_reg = true;
 +		if (seen_or_pass0) {
 +			EMIT4(0x55, 0x48, 0x89, 0xe5); /* push %rbp; mov %rsp,%rbp */
 +			EMIT4(0x48, 0x83, 0xec, 96);	/* subq  $96,%rsp	*/
 +			/* note : must save %rbx in case bpf_error is hit */
 +			if (seen_or_pass0 & (SEEN_XREG | SEEN_DATAREF))
 +				EMIT4(0x48, 0x89, 0x5d, 0xf8); /* mov %rbx, -8(%rbp) */
 +			if (seen_or_pass0 & SEEN_XREG)
 +				CLEAR_X(); /* make sure we dont leek kernel memory */
 +
 +			/*
 +			 * If this filter needs to access skb data,
 +			 * loads r9 and r8 with :
 +			 *  r9 = skb->len - skb->data_len
 +			 *  r8 = skb->data
 +			 */
 +			if (seen_or_pass0 & SEEN_DATAREF) {
 +				if (offsetof(struct sk_buff, len) <= 127)
 +					/* mov    off8(%rdi),%r9d */
 +					EMIT4(0x44, 0x8b, 0x4f, offsetof(struct sk_buff, len));
 +				else {
 +					/* mov    off32(%rdi),%r9d */
 +					EMIT3(0x44, 0x8b, 0x8f);
 +					EMIT(offsetof(struct sk_buff, len), 4);
 +				}
 +				if (is_imm8(offsetof(struct sk_buff, data_len)))
 +					/* sub    off8(%rdi),%r9d */
 +					EMIT4(0x44, 0x2b, 0x4f, offsetof(struct sk_buff, data_len));
 +				else {
 +					EMIT3(0x44, 0x2b, 0x8f);
 +					EMIT(offsetof(struct sk_buff, data_len), 4);
 +				}
  
 -		switch (insn->code) {
 -			/* ALU */
 -		case BPF_ALU | BPF_ADD | BPF_X:
 -		case BPF_ALU | BPF_SUB | BPF_X:
 -		case BPF_ALU | BPF_AND | BPF_X:
 -		case BPF_ALU | BPF_OR | BPF_X:
 -		case BPF_ALU | BPF_XOR | BPF_X:
 -		case BPF_ALU64 | BPF_ADD | BPF_X:
 -		case BPF_ALU64 | BPF_SUB | BPF_X:
 -		case BPF_ALU64 | BPF_AND | BPF_X:
 -		case BPF_ALU64 | BPF_OR | BPF_X:
 -		case BPF_ALU64 | BPF_XOR | BPF_X:
 -			switch (BPF_OP(insn->code)) {
 -			case BPF_ADD: b2 = 0x01; break;
 -			case BPF_SUB: b2 = 0x29; break;
 -			case BPF_AND: b2 = 0x21; break;
 -			case BPF_OR: b2 = 0x09; break;
 -			case BPF_XOR: b2 = 0x31; break;
 +				if (is_imm8(offsetof(struct sk_buff, data)))
 +					/* mov off8(%rdi),%r8 */
 +					EMIT4(0x4c, 0x8b, 0x47, offsetof(struct sk_buff, data));
 +				else {
 +					/* mov off32(%rdi),%r8 */
 +					EMIT3(0x4c, 0x8b, 0x87);
 +					EMIT(offsetof(struct sk_buff, data), 4);
 +				}
  			}
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_2mod(0x48, dst_reg, src_reg));
 -			else if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT1(add_2mod(0x40, dst_reg, src_reg));
 -			EMIT2(b2, add_2reg(0xC0, dst_reg, src_reg));
 -			break;
 -
 -			/* mov dst, src */
 -		case BPF_ALU64 | BPF_MOV | BPF_X:
 -			EMIT_mov(dst_reg, src_reg);
 -			break;
 -
 -			/* mov32 dst, src */
 -		case BPF_ALU | BPF_MOV | BPF_X:
 -			if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT1(add_2mod(0x40, dst_reg, src_reg));
 -			EMIT2(0x89, add_2reg(0xC0, dst_reg, src_reg));
 -			break;
 +		}
  
 -			/* neg dst */
 -		case BPF_ALU | BPF_NEG:
 -		case BPF_ALU64 | BPF_NEG:
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_1mod(0x48, dst_reg));
 -			else if (is_ereg(dst_reg))
 -				EMIT1(add_1mod(0x40, dst_reg));
 -			EMIT2(0xF7, add_1reg(0xD8, dst_reg));
 +		switch (filter[0].code) {
 +		case BPF_S_RET_K:
 +		case BPF_S_LD_W_LEN:
 +		case BPF_S_ANC_PROTOCOL:
 +		case BPF_S_ANC_IFINDEX:
 +		case BPF_S_ANC_MARK:
 +		case BPF_S_ANC_RXHASH:
 +		case BPF_S_ANC_CPU:
 +		case BPF_S_ANC_VLAN_TAG:
 +		case BPF_S_ANC_VLAN_TAG_PRESENT:
 +		case BPF_S_ANC_QUEUE:
 +		case BPF_S_ANC_PKTTYPE:
 +		case BPF_S_LD_W_ABS:
 +		case BPF_S_LD_H_ABS:
 +		case BPF_S_LD_B_ABS:
 +			/* first instruction sets A register (or is RET 'constant') */
  			break;
 +		default:
 +			/* make sure we dont leak kernel information to user */
 +			CLEAR_A(); /* A = 0 */
 +		}
  
 -		case BPF_ALU | BPF_ADD | BPF_K:
 -		case BPF_ALU | BPF_SUB | BPF_K:
 -		case BPF_ALU | BPF_AND | BPF_K:
 -		case BPF_ALU | BPF_OR | BPF_K:
 -		case BPF_ALU | BPF_XOR | BPF_K:
 -		case BPF_ALU64 | BPF_ADD | BPF_K:
 -		case BPF_ALU64 | BPF_SUB | BPF_K:
 -		case BPF_ALU64 | BPF_AND | BPF_K:
 -		case BPF_ALU64 | BPF_OR | BPF_K:
 -		case BPF_ALU64 | BPF_XOR | BPF_K:
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_1mod(0x48, dst_reg));
 -			else if (is_ereg(dst_reg))
 -				EMIT1(add_1mod(0x40, dst_reg));
 -
 -			switch (BPF_OP(insn->code)) {
 -			case BPF_ADD: b3 = 0xC0; break;
 -			case BPF_SUB: b3 = 0xE8; break;
 -			case BPF_AND: b3 = 0xE0; break;
 -			case BPF_OR: b3 = 0xC8; break;
 -			case BPF_XOR: b3 = 0xF0; break;
 -			}
 -
 -			if (is_imm8(imm32))
 -				EMIT3(0x83, add_1reg(b3, dst_reg), imm32);
 -			else
 -				EMIT2_off32(0x81, add_1reg(b3, dst_reg), imm32);
 -			break;
 +		for (i = 0; i < flen; i++) {
 +			unsigned int K = filter[i].k;
  
 -		case BPF_ALU64 | BPF_MOV | BPF_K:
 -			/* optimization: if imm32 is positive,
 -			 * use 'mov eax, imm32' (which zero-extends imm32)
 -			 * to save 2 bytes
 -			 */
 -			if (imm32 < 0) {
 -				/* 'mov rax, imm32' sign extends imm32 */
 -				b1 = add_1mod(0x48, dst_reg);
 -				b2 = 0xC7;
 -				b3 = 0xC0;
 -				EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
 +			switch (filter[i].code) {
 +			case BPF_S_ALU_ADD_X: /* A += X; */
 +				seen |= SEEN_XREG;
 +				EMIT2(0x01, 0xd8);		/* add %ebx,%eax */
  				break;
 -			}
 -
 -		case BPF_ALU | BPF_MOV | BPF_K:
 -			/* optimization: if imm32 is zero, use 'xor <dst>,<dst>'
 -			 * to save 3 bytes.
 -			 */
 -			if (imm32 == 0) {
 -				if (is_ereg(dst_reg))
 -					EMIT1(add_2mod(0x40, dst_reg, dst_reg));
 -				b2 = 0x31; /* xor */
 -				b3 = 0xC0;
 -				EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
 +			case BPF_S_ALU_ADD_K: /* A += K; */
 +				if (!K)
 +					break;
 +				if (is_imm8(K))
 +					EMIT3(0x83, 0xc0, K);	/* add imm8,%eax */
 +				else
 +					EMIT1_off32(0x05, K);	/* add imm32,%eax */
  				break;
 -			}
 -
 -			/* mov %eax, imm32 */
 -			if (is_ereg(dst_reg))
 -				EMIT1(add_1mod(0x40, dst_reg));
 -			EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
 -			break;
 -
 -		case BPF_LD | BPF_IMM | BPF_DW:
 -			/* optimization: if imm64 is zero, use 'xor <dst>,<dst>'
 -			 * to save 7 bytes.
 -			 */
 -			if (insn[0].imm == 0 && insn[1].imm == 0) {
 -				b1 = add_2mod(0x48, dst_reg, dst_reg);
 -				b2 = 0x31; /* xor */
 -				b3 = 0xC0;
 -				EMIT3(b1, b2, add_2reg(b3, dst_reg, dst_reg));
 -
 -				insn++;
 -				i++;
 +			case BPF_S_ALU_SUB_X: /* A -= X; */
 +				seen |= SEEN_XREG;
 +				EMIT2(0x29, 0xd8);		/* sub    %ebx,%eax */
  				break;
 -			}
 -
 -			/* movabsq %rax, imm64 */
 -			EMIT2(add_1mod(0x48, dst_reg), add_1reg(0xB8, dst_reg));
 -			EMIT(insn[0].imm, 4);
 -			EMIT(insn[1].imm, 4);
 -
 -			insn++;
 -			i++;
 -			break;
 -
 -			/* dst %= src, dst /= src, dst %= imm32, dst /= imm32 */
 -		case BPF_ALU | BPF_MOD | BPF_X:
 -		case BPF_ALU | BPF_DIV | BPF_X:
 -		case BPF_ALU | BPF_MOD | BPF_K:
 -		case BPF_ALU | BPF_DIV | BPF_K:
 -		case BPF_ALU64 | BPF_MOD | BPF_X:
 -		case BPF_ALU64 | BPF_DIV | BPF_X:
 -		case BPF_ALU64 | BPF_MOD | BPF_K:
 -		case BPF_ALU64 | BPF_DIV | BPF_K:
 -			EMIT1(0x50); /* push rax */
 -			EMIT1(0x52); /* push rdx */
 -
 -			if (BPF_SRC(insn->code) == BPF_X)
 -				/* mov r11, src_reg */
 -				EMIT_mov(AUX_REG, src_reg);
 -			else
 -				/* mov r11, imm32 */
 -				EMIT3_off32(0x49, 0xC7, 0xC3, imm32);
 -
 -			/* mov rax, dst_reg */
 -			EMIT_mov(BPF_REG_0, dst_reg);
 -
 -			/* xor edx, edx
 -			 * equivalent to 'xor rdx, rdx', but one byte less
 -			 */
 -			EMIT2(0x31, 0xd2);
 -
 -			if (BPF_SRC(insn->code) == BPF_X) {
 -				/* if (src_reg == 0) return 0 */
 -
 -				/* cmp r11, 0 */
 -				EMIT4(0x49, 0x83, 0xFB, 0x00);
 -
 -				/* jne .+9 (skip over pop, pop, xor and jmp) */
 -				EMIT2(X86_JNE, 1 + 1 + 2 + 5);
 -				EMIT1(0x5A); /* pop rdx */
 -				EMIT1(0x58); /* pop rax */
 -				EMIT2(0x31, 0xc0); /* xor eax, eax */
 -
 -				/* jmp cleanup_addr
 -				 * addrs[i] - 11, because there are 11 bytes
 -				 * after this insn: div, mov, pop, pop, mov
 -				 */
 -				jmp_offset = ctx->cleanup_addr - (addrs[i] - 11);
 -				EMIT1_off32(0xE9, jmp_offset);
 -			}
 -
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				/* div r11 */
 -				EMIT3(0x49, 0xF7, 0xF3);
 -			else
 -				/* div r11d */
 -				EMIT3(0x41, 0xF7, 0xF3);
 -
 -			if (BPF_OP(insn->code) == BPF_MOD)
 -				/* mov r11, rdx */
 -				EMIT3(0x49, 0x89, 0xD3);
 -			else
 -				/* mov r11, rax */
 -				EMIT3(0x49, 0x89, 0xC3);
 -
 -			EMIT1(0x5A); /* pop rdx */
 -			EMIT1(0x58); /* pop rax */
 -
 -			/* mov dst_reg, r11 */
 -			EMIT_mov(dst_reg, AUX_REG);
 -			break;
 -
 -		case BPF_ALU | BPF_MUL | BPF_K:
 -		case BPF_ALU | BPF_MUL | BPF_X:
 -		case BPF_ALU64 | BPF_MUL | BPF_K:
 -		case BPF_ALU64 | BPF_MUL | BPF_X:
 -			EMIT1(0x50); /* push rax */
 -			EMIT1(0x52); /* push rdx */
 -
 -			/* mov r11, dst_reg */
 -			EMIT_mov(AUX_REG, dst_reg);
 -
 -			if (BPF_SRC(insn->code) == BPF_X)
 -				/* mov rax, src_reg */
 -				EMIT_mov(BPF_REG_0, src_reg);
 -			else
 -				/* mov rax, imm32 */
 -				EMIT3_off32(0x48, 0xC7, 0xC0, imm32);
 -
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_1mod(0x48, AUX_REG));
 -			else if (is_ereg(AUX_REG))
 -				EMIT1(add_1mod(0x40, AUX_REG));
 -			/* mul(q) r11 */
 -			EMIT2(0xF7, add_1reg(0xE0, AUX_REG));
 -
 -			/* mov r11, rax */
 -			EMIT_mov(AUX_REG, BPF_REG_0);
 -
 -			EMIT1(0x5A); /* pop rdx */
 -			EMIT1(0x58); /* pop rax */
 -
 -			/* mov dst_reg, r11 */
 -			EMIT_mov(dst_reg, AUX_REG);
 -			break;
 -
 -			/* shifts */
 -		case BPF_ALU | BPF_LSH | BPF_K:
 -		case BPF_ALU | BPF_RSH | BPF_K:
 -		case BPF_ALU | BPF_ARSH | BPF_K:
 -		case BPF_ALU64 | BPF_LSH | BPF_K:
 -		case BPF_ALU64 | BPF_RSH | BPF_K:
 -		case BPF_ALU64 | BPF_ARSH | BPF_K:
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_1mod(0x48, dst_reg));
 -			else if (is_ereg(dst_reg))
 -				EMIT1(add_1mod(0x40, dst_reg));
 -
 -			switch (BPF_OP(insn->code)) {
 -			case BPF_LSH: b3 = 0xE0; break;
 -			case BPF_RSH: b3 = 0xE8; break;
 -			case BPF_ARSH: b3 = 0xF8; break;
 -			}
 -			EMIT3(0xC1, add_1reg(b3, dst_reg), imm32);
 -			break;
 -
 -		case BPF_ALU | BPF_LSH | BPF_X:
 -		case BPF_ALU | BPF_RSH | BPF_X:
 -		case BPF_ALU | BPF_ARSH | BPF_X:
 -		case BPF_ALU64 | BPF_LSH | BPF_X:
 -		case BPF_ALU64 | BPF_RSH | BPF_X:
 -		case BPF_ALU64 | BPF_ARSH | BPF_X:
 -
 -			/* check for bad case when dst_reg == rcx */
 -			if (dst_reg == BPF_REG_4) {
 -				/* mov r11, dst_reg */
 -				EMIT_mov(AUX_REG, dst_reg);
 -				dst_reg = AUX_REG;
 -			}
 -
 -			if (src_reg != BPF_REG_4) { /* common case */
 -				EMIT1(0x51); /* push rcx */
 -
 -				/* mov rcx, src_reg */
 -				EMIT_mov(BPF_REG_4, src_reg);
 -			}
 -
 -			/* shl %rax, %cl | shr %rax, %cl | sar %rax, %cl */
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_1mod(0x48, dst_reg));
 -			else if (is_ereg(dst_reg))
 -				EMIT1(add_1mod(0x40, dst_reg));
 -
 -			switch (BPF_OP(insn->code)) {
 -			case BPF_LSH: b3 = 0xE0; break;
 -			case BPF_RSH: b3 = 0xE8; break;
 -			case BPF_ARSH: b3 = 0xF8; break;
 -			}
 -			EMIT2(0xD3, add_1reg(b3, dst_reg));
 -
 -			if (src_reg != BPF_REG_4)
 -				EMIT1(0x59); /* pop rcx */
 -
 -			if (insn->dst_reg == BPF_REG_4)
 -				/* mov dst_reg, r11 */
 -				EMIT_mov(insn->dst_reg, AUX_REG);
 -			break;
 -
 -		case BPF_ALU | BPF_END | BPF_FROM_BE:
 -			switch (imm32) {
 -			case 16:
 -				/* emit 'ror %ax, 8' to swap lower 2 bytes */
 -				EMIT1(0x66);
 -				if (is_ereg(dst_reg))
 -					EMIT1(0x41);
 -				EMIT3(0xC1, add_1reg(0xC8, dst_reg), 8);
 -
 -				/* emit 'movzwl eax, ax' */
 -				if (is_ereg(dst_reg))
 -					EMIT3(0x45, 0x0F, 0xB7);
 +			case BPF_S_ALU_SUB_K: /* A -= K */
 +				if (!K)
 +					break;
 +				if (is_imm8(K))
 +					EMIT3(0x83, 0xe8, K); /* sub imm8,%eax */
  				else
 -					EMIT2(0x0F, 0xB7);
 -				EMIT1(add_2reg(0xC0, dst_reg, dst_reg));
 +					EMIT1_off32(0x2d, K); /* sub imm32,%eax */
 +				break;
 +			case BPF_S_ALU_MUL_X: /* A *= X; */
 +				seen |= SEEN_XREG;
 +				EMIT3(0x0f, 0xaf, 0xc3);	/* imul %ebx,%eax */
 +				break;
 +			case BPF_S_ALU_MUL_K: /* A *= K */
 +				if (is_imm8(K))
 +					EMIT3(0x6b, 0xc0, K); /* imul imm8,%eax,%eax */
 +				else {
 +					EMIT2(0x69, 0xc0);		/* imul imm32,%eax */
 +					EMIT(K, 4);
 +				}
 +				break;
 +			case BPF_S_ALU_DIV_X: /* A /= X; */
 +				seen |= SEEN_XREG;
 +				EMIT2(0x85, 0xdb);	/* test %ebx,%ebx */
 +				if (pc_ret0 > 0) {
 +					/* addrs[pc_ret0 - 1] is start address of target
 +					 * (addrs[i] - 4) is the address following this jmp
 +					 * ("xor %edx,%edx; div %ebx" being 4 bytes long)
 +					 */
 +					EMIT_COND_JMP(X86_JE, addrs[pc_ret0 - 1] -
 +								(addrs[i] - 4));
 +				} else {
 +					EMIT_COND_JMP(X86_JNE, 2 + 5);
 +					CLEAR_A();
 +					EMIT1_off32(0xe9, cleanup_addr - (addrs[i] - 4)); /* jmp .+off32 */
 +				}
 +				EMIT4(0x31, 0xd2, 0xf7, 0xf3); /* xor %edx,%edx; div %ebx */
 +				break;
 +			case BPF_S_ALU_MOD_X: /* A %= X; */
 +				seen |= SEEN_XREG;
 +				EMIT2(0x85, 0xdb);	/* test %ebx,%ebx */
 +				if (pc_ret0 > 0) {
 +					/* addrs[pc_ret0 - 1] is start address of target
 +					 * (addrs[i] - 6) is the address following this jmp
 +					 * ("xor %edx,%edx; div %ebx;mov %edx,%eax" being 6 bytes long)
 +					 */
 +					EMIT_COND_JMP(X86_JE, addrs[pc_ret0 - 1] -
 +								(addrs[i] - 6));
 +				} else {
 +					EMIT_COND_JMP(X86_JNE, 2 + 5);
 +					CLEAR_A();
 +					EMIT1_off32(0xe9, cleanup_addr - (addrs[i] - 6)); /* jmp .+off32 */
 +				}
 +				EMIT2(0x31, 0xd2);	/* xor %edx,%edx */
 +				EMIT2(0xf7, 0xf3);	/* div %ebx */
 +				EMIT2(0x89, 0xd0);	/* mov %edx,%eax */
 +				break;
 +			case BPF_S_ALU_MOD_K: /* A %= K; */
 +				if (K == 1) {
 +					CLEAR_A();
 +					break;
 +				}
 +				EMIT2(0x31, 0xd2);	/* xor %edx,%edx */
 +				EMIT1(0xb9);EMIT(K, 4);	/* mov imm32,%ecx */
 +				EMIT2(0xf7, 0xf1);	/* div %ecx */
 +				EMIT2(0x89, 0xd0);	/* mov %edx,%eax */
 +				break;
 +			case BPF_S_ALU_DIV_K: /* A /= K */
 +				if (K == 1)
 +					break;
 +				EMIT2(0x31, 0xd2);	/* xor %edx,%edx */
 +				EMIT1(0xb9);EMIT(K, 4);	/* mov imm32,%ecx */
 +				EMIT2(0xf7, 0xf1);	/* div %ecx */
 +				break;
 +			case BPF_S_ALU_AND_X:
 +				seen |= SEEN_XREG;
 +				EMIT2(0x21, 0xd8);		/* and %ebx,%eax */
 +				break;
 +			case BPF_S_ALU_AND_K:
 +				if (K >= 0xFFFFFF00) {
 +					EMIT2(0x24, K & 0xFF); /* and imm8,%al */
 +				} else if (K >= 0xFFFF0000) {
 +					EMIT2(0x66, 0x25);	/* and imm16,%ax */
 +					EMIT(K, 2);
 +				} else {
 +					EMIT1_off32(0x25, K);	/* and imm32,%eax */
 +				}
 +				break;
 +			case BPF_S_ALU_OR_X:
 +				seen |= SEEN_XREG;
 +				EMIT2(0x09, 0xd8);		/* or %ebx,%eax */
  				break;
 -			case 32:
 -				/* emit 'bswap eax' to swap lower 4 bytes */
 -				if (is_ereg(dst_reg))
 -					EMIT2(0x41, 0x0F);
 +			case BPF_S_ALU_OR_K:
 +				if (is_imm8(K))
 +					EMIT3(0x83, 0xc8, K); /* or imm8,%eax */
  				else
 -					EMIT1(0x0F);
 -				EMIT1(add_1reg(0xC8, dst_reg));
 +					EMIT1_off32(0x0d, K);	/* or imm32,%eax */
  				break;
 -			case 64:
 -				/* emit 'bswap rax' to swap 8 bytes */
 -				EMIT3(add_1mod(0x48, dst_reg), 0x0F,
 -				      add_1reg(0xC8, dst_reg));
 +			case BPF_S_ANC_ALU_XOR_X: /* A ^= X; */
 +			case BPF_S_ALU_XOR_X:
 +				seen |= SEEN_XREG;
 +				EMIT2(0x31, 0xd8);		/* xor %ebx,%eax */
  				break;
 -			}
 -			break;
 -
 -		case BPF_ALU | BPF_END | BPF_FROM_LE:
 -			switch (imm32) {
 -			case 16:
 -				/* emit 'movzwl eax, ax' to zero extend 16-bit
 -				 * into 64 bit
 -				 */
 -				if (is_ereg(dst_reg))
 -					EMIT3(0x45, 0x0F, 0xB7);
 +			case BPF_S_ALU_XOR_K: /* A ^= K; */
 +				if (K == 0)
 +					break;
 +				if (is_imm8(K))
 +					EMIT3(0x83, 0xf0, K);	/* xor imm8,%eax */
  				else
 -					EMIT2(0x0F, 0xB7);
 -				EMIT1(add_2reg(0xC0, dst_reg, dst_reg));
 +					EMIT1_off32(0x35, K);	/* xor imm32,%eax */
  				break;
 -			case 32:
 -				/* emit 'mov eax, eax' to clear upper 32-bits */
 -				if (is_ereg(dst_reg))
 -					EMIT1(0x45);
 -				EMIT2(0x89, add_2reg(0xC0, dst_reg, dst_reg));
 +			case BPF_S_ALU_LSH_X: /* A <<= X; */
 +				seen |= SEEN_XREG;
 +				EMIT4(0x89, 0xd9, 0xd3, 0xe0);	/* mov %ebx,%ecx; shl %cl,%eax */
  				break;
 -			case 64:
 -				/* nop */
 +			case BPF_S_ALU_LSH_K:
 +				if (K == 0)
 +					break;
 +				else if (K == 1)
 +					EMIT2(0xd1, 0xe0); /* shl %eax */
 +				else
 +					EMIT3(0xc1, 0xe0, K);
  				break;
 -			}
 -			break;
 -
 -			/* ST: *(u8*)(dst_reg + off) = imm */
 -		case BPF_ST | BPF_MEM | BPF_B:
 -			if (is_ereg(dst_reg))
 -				EMIT2(0x41, 0xC6);
 -			else
 -				EMIT1(0xC6);
 -			goto st;
 -		case BPF_ST | BPF_MEM | BPF_H:
 -			if (is_ereg(dst_reg))
 -				EMIT3(0x66, 0x41, 0xC7);
 -			else
 -				EMIT2(0x66, 0xC7);
 -			goto st;
 -		case BPF_ST | BPF_MEM | BPF_W:
 -			if (is_ereg(dst_reg))
 -				EMIT2(0x41, 0xC7);
 -			else
 -				EMIT1(0xC7);
 -			goto st;
 -		case BPF_ST | BPF_MEM | BPF_DW:
 -			EMIT2(add_1mod(0x48, dst_reg), 0xC7);
 -
 -st:			if (is_imm8(insn->off))
 -				EMIT2(add_1reg(0x40, dst_reg), insn->off);
 -			else
 -				EMIT1_off32(add_1reg(0x80, dst_reg), insn->off);
 -
 -			EMIT(imm32, bpf_size_to_x86_bytes(BPF_SIZE(insn->code)));
 -			break;
 -
 -			/* STX: *(u8*)(dst_reg + off) = src_reg */
 -		case BPF_STX | BPF_MEM | BPF_B:
 -			/* emit 'mov byte ptr [rax + off], al' */
 -			if (is_ereg(dst_reg) || is_ereg(src_reg) ||
 -			    /* have to add extra byte for x86 SIL, DIL regs */
 -			    src_reg == BPF_REG_1 || src_reg == BPF_REG_2)
 -				EMIT2(add_2mod(0x40, dst_reg, src_reg), 0x88);
 -			else
 -				EMIT1(0x88);
 -			goto stx;
 -		case BPF_STX | BPF_MEM | BPF_H:
 -			if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT3(0x66, add_2mod(0x40, dst_reg, src_reg), 0x89);
 -			else
 -				EMIT2(0x66, 0x89);
 -			goto stx;
 -		case BPF_STX | BPF_MEM | BPF_W:
 -			if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT2(add_2mod(0x40, dst_reg, src_reg), 0x89);
 -			else
 -				EMIT1(0x89);
 -			goto stx;
 -		case BPF_STX | BPF_MEM | BPF_DW:
 -			EMIT2(add_2mod(0x48, dst_reg, src_reg), 0x89);
 -stx:			if (is_imm8(insn->off))
 -				EMIT2(add_2reg(0x40, dst_reg, src_reg), insn->off);
 -			else
 -				EMIT1_off32(add_2reg(0x80, dst_reg, src_reg),
 -					    insn->off);
 -			break;
 -
 -			/* LDX: dst_reg = *(u8*)(src_reg + off) */
 -		case BPF_LDX | BPF_MEM | BPF_B:
 -			/* emit 'movzx rax, byte ptr [rax + off]' */
 -			EMIT3(add_2mod(0x48, src_reg, dst_reg), 0x0F, 0xB6);
 -			goto ldx;
 -		case BPF_LDX | BPF_MEM | BPF_H:
 -			/* emit 'movzx rax, word ptr [rax + off]' */
 -			EMIT3(add_2mod(0x48, src_reg, dst_reg), 0x0F, 0xB7);
 -			goto ldx;
 -		case BPF_LDX | BPF_MEM | BPF_W:
 -			/* emit 'mov eax, dword ptr [rax+0x14]' */
 -			if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT2(add_2mod(0x40, src_reg, dst_reg), 0x8B);
 -			else
 -				EMIT1(0x8B);
 -			goto ldx;
 -		case BPF_LDX | BPF_MEM | BPF_DW:
 -			/* emit 'mov rax, qword ptr [rax+0x14]' */
 -			EMIT2(add_2mod(0x48, src_reg, dst_reg), 0x8B);
 -ldx:			/* if insn->off == 0 we can save one extra byte, but
 -			 * special case of x86 r13 which always needs an offset
 -			 * is not worth the hassle
 -			 */
 -			if (is_imm8(insn->off))
 -				EMIT2(add_2reg(0x40, src_reg, dst_reg), insn->off);
 -			else
 -				EMIT1_off32(add_2reg(0x80, src_reg, dst_reg),
 -					    insn->off);
 -			break;
 -
 -			/* STX XADD: lock *(u32*)(dst_reg + off) += src_reg */
 -		case BPF_STX | BPF_XADD | BPF_W:
 -			/* emit 'lock add dword ptr [rax + off], eax' */
 -			if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT3(0xF0, add_2mod(0x40, dst_reg, src_reg), 0x01);
 -			else
 -				EMIT2(0xF0, 0x01);
 -			goto xadd;
 -		case BPF_STX | BPF_XADD | BPF_DW:
 -			EMIT3(0xF0, add_2mod(0x48, dst_reg, src_reg), 0x01);
 -xadd:			if (is_imm8(insn->off))
 -				EMIT2(add_2reg(0x40, dst_reg, src_reg), insn->off);
 -			else
 -				EMIT1_off32(add_2reg(0x80, dst_reg, src_reg),
 -					    insn->off);
 -			break;
 -
 -			/* call */
 -		case BPF_JMP | BPF_CALL:
 -			func = (u8 *) __bpf_call_base + imm32;
 -			jmp_offset = func - (image + addrs[i]);
 -			if (seen_ld_abs) {
 -				reload_skb_data = bpf_helper_changes_pkt_data(func);
 -				if (reload_skb_data) {
 -					EMIT1(0x57); /* push %rdi */
 -					jmp_offset += 22; /* pop, mov, sub, mov */
 +			case BPF_S_ALU_RSH_X: /* A >>= X; */
 +				seen |= SEEN_XREG;
 +				EMIT4(0x89, 0xd9, 0xd3, 0xe8);	/* mov %ebx,%ecx; shr %cl,%eax */
 +				break;
 +			case BPF_S_ALU_RSH_K: /* A >>= K; */
 +				if (K == 0)
 +					break;
 +				else if (K == 1)
 +					EMIT2(0xd1, 0xe8); /* shr %eax */
 +				else
 +					EMIT3(0xc1, 0xe8, K);
 +				break;
 +			case BPF_S_ALU_NEG:
 +				EMIT2(0xf7, 0xd8);		/* neg %eax */
 +				break;
 +			case BPF_S_RET_K:
 +				if (!K) {
 +					if (pc_ret0 == -1)
 +						pc_ret0 = i;
 +					CLEAR_A();
  				} else {
 -					EMIT2(0x41, 0x52); /* push %r10 */
 -					EMIT2(0x41, 0x51); /* push %r9 */
 -					/* need to adjust jmp offset, since
 -					 * pop %r9, pop %r10 take 4 bytes after call insn
 -					 */
 -					jmp_offset += 4;
 +					EMIT1_off32(0xb8, K);	/* mov $imm32,%eax */
  				}
 -			}
 -			if (!imm32 || !is_simm32(jmp_offset)) {
 -				pr_err("unsupported bpf func %d addr %p image %p\n",
 -				       imm32, func, image);
 -				return -EINVAL;
 -			}
 -			EMIT1_off32(0xE8, jmp_offset);
 -			if (seen_ld_abs) {
 -				if (reload_skb_data) {
 -					EMIT1(0x5F); /* pop %rdi */
 -					emit_load_skb_data_hlen(&prog);
 -				} else {
 -					EMIT2(0x41, 0x59); /* pop %r9 */
 -					EMIT2(0x41, 0x5A); /* pop %r10 */
 +				/* fallinto */
 +			case BPF_S_RET_A:
 +				if (seen_or_pass0) {
 +					if (i != flen - 1) {
 +						EMIT_JMP(cleanup_addr - addrs[i]);
 +						break;
 +					}
 +					if (seen_or_pass0 & SEEN_XREG)
 +						EMIT4(0x48, 0x8b, 0x5d, 0xf8);  /* mov  -8(%rbp),%rbx */
 +					EMIT1(0xc9);		/* leaveq */
  				}
 -			}
 -			break;
 -
 -		case BPF_JMP | BPF_TAIL_CALL:
 -			emit_bpf_tail_call(&prog);
 -			break;
 -
 -			/* cond jump */
 -		case BPF_JMP | BPF_JEQ | BPF_X:
 -		case BPF_JMP | BPF_JNE | BPF_X:
 -		case BPF_JMP | BPF_JGT | BPF_X:
 -		case BPF_JMP | BPF_JLT | BPF_X:
 -		case BPF_JMP | BPF_JGE | BPF_X:
 -		case BPF_JMP | BPF_JLE | BPF_X:
 -		case BPF_JMP | BPF_JSGT | BPF_X:
 -		case BPF_JMP | BPF_JSLT | BPF_X:
 -		case BPF_JMP | BPF_JSGE | BPF_X:
 -		case BPF_JMP | BPF_JSLE | BPF_X:
 -			/* cmp dst_reg, src_reg */
 -			EMIT3(add_2mod(0x48, dst_reg, src_reg), 0x39,
 -			      add_2reg(0xC0, dst_reg, src_reg));
 -			goto emit_cond_jmp;
 -
 -		case BPF_JMP | BPF_JSET | BPF_X:
 -			/* test dst_reg, src_reg */
 -			EMIT3(add_2mod(0x48, dst_reg, src_reg), 0x85,
 -			      add_2reg(0xC0, dst_reg, src_reg));
 -			goto emit_cond_jmp;
 -
 -		case BPF_JMP | BPF_JSET | BPF_K:
 -			/* test dst_reg, imm32 */
 -			EMIT1(add_1mod(0x48, dst_reg));
 -			EMIT2_off32(0xF7, add_1reg(0xC0, dst_reg), imm32);
 -			goto emit_cond_jmp;
 -
 -		case BPF_JMP | BPF_JEQ | BPF_K:
 -		case BPF_JMP | BPF_JNE | BPF_K:
 -		case BPF_JMP | BPF_JGT | BPF_K:
 -		case BPF_JMP | BPF_JLT | BPF_K:
 -		case BPF_JMP | BPF_JGE | BPF_K:
 -		case BPF_JMP | BPF_JLE | BPF_K:
 -		case BPF_JMP | BPF_JSGT | BPF_K:
 -		case BPF_JMP | BPF_JSLT | BPF_K:
 -		case BPF_JMP | BPF_JSGE | BPF_K:
 -		case BPF_JMP | BPF_JSLE | BPF_K:
 -			/* cmp dst_reg, imm8/32 */
 -			EMIT1(add_1mod(0x48, dst_reg));
 -
 -			if (is_imm8(imm32))
 -				EMIT3(0x83, add_1reg(0xF8, dst_reg), imm32);
 -			else
 -				EMIT2_off32(0x81, add_1reg(0xF8, dst_reg), imm32);
 -
 -emit_cond_jmp:		/* convert BPF opcode to x86 */
 -			switch (BPF_OP(insn->code)) {
 -			case BPF_JEQ:
 -				jmp_cond = X86_JE;
 +				EMIT1(0xc3);		/* ret */
  				break;
 -			case BPF_JSET:
 -			case BPF_JNE:
 -				jmp_cond = X86_JNE;
 +			case BPF_S_MISC_TAX: /* X = A */
 +				seen |= SEEN_XREG;
 +				EMIT2(0x89, 0xc3);	/* mov    %eax,%ebx */
  				break;
 -			case BPF_JGT:
 -				/* GT is unsigned '>', JA in x86 */
 -				jmp_cond = X86_JA;
 +			case BPF_S_MISC_TXA: /* A = X */
 +				seen |= SEEN_XREG;
 +				EMIT2(0x89, 0xd8);	/* mov    %ebx,%eax */
  				break;
 -			case BPF_JLT:
 -				/* LT is unsigned '<', JB in x86 */
 -				jmp_cond = X86_JB;
 +			case BPF_S_LD_IMM: /* A = K */
 +				if (!K)
 +					CLEAR_A();
 +				else
 +					EMIT1_off32(0xb8, K); /* mov $imm32,%eax */
  				break;
 -			case BPF_JGE:
 -				/* GE is unsigned '>=', JAE in x86 */
 -				jmp_cond = X86_JAE;
 +			case BPF_S_LDX_IMM: /* X = K */
 +				seen |= SEEN_XREG;
 +				if (!K)
 +					CLEAR_X();
 +				else
 +					EMIT1_off32(0xbb, K); /* mov $imm32,%ebx */
  				break;
 -			case BPF_JLE:
 -				/* LE is unsigned '<=', JBE in x86 */
 -				jmp_cond = X86_JBE;
 +			case BPF_S_LD_MEM: /* A = mem[K] : mov off8(%rbp),%eax */
 +				seen |= SEEN_MEM;
 +				EMIT3(0x8b, 0x45, 0xf0 - K*4);
  				break;
 -			case BPF_JSGT:
 -				/* signed '>', GT in x86 */
 -				jmp_cond = X86_JG;
 +			case BPF_S_LDX_MEM: /* X = mem[K] : mov off8(%rbp),%ebx */
 +				seen |= SEEN_XREG | SEEN_MEM;
 +				EMIT3(0x8b, 0x5d, 0xf0 - K*4);
  				break;
 -			case BPF_JSLT:
 -				/* signed '<', LT in x86 */
 -				jmp_cond = X86_JL;
 +			case BPF_S_ST: /* mem[K] = A : mov %eax,off8(%rbp) */
 +				seen |= SEEN_MEM;
 +				EMIT3(0x89, 0x45, 0xf0 - K*4);
  				break;
 -			case BPF_JSGE:
 -				/* signed '>=', GE in x86 */
 -				jmp_cond = X86_JGE;
 +			case BPF_S_STX: /* mem[K] = X : mov %ebx,off8(%rbp) */
 +				seen |= SEEN_XREG | SEEN_MEM;
 +				EMIT3(0x89, 0x5d, 0xf0 - K*4);
  				break;
 -			case BPF_JSLE:
 -				/* signed '<=', LE in x86 */
 -				jmp_cond = X86_JLE;
 +			case BPF_S_LD_W_LEN: /*	A = skb->len; */
 +				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, len) != 4);
 +				if (is_imm8(offsetof(struct sk_buff, len)))
 +					/* mov    off8(%rdi),%eax */
 +					EMIT3(0x8b, 0x47, offsetof(struct sk_buff, len));
 +				else {
 +					EMIT2(0x8b, 0x87);
 +					EMIT(offsetof(struct sk_buff, len), 4);
 +				}
  				break;
 -			default: /* to silence gcc warning */
 -				return -EFAULT;
 -			}
 -			jmp_offset = addrs[i + insn->off] - addrs[i];
 -			if (is_imm8(jmp_offset)) {
 -				EMIT2(jmp_cond, jmp_offset);
 -			} else if (is_simm32(jmp_offset)) {
 -				EMIT2_off32(0x0F, jmp_cond + 0x10, jmp_offset);
 -			} else {
 -				pr_err("cond_jmp gen bug %llx\n", jmp_offset);
 -				return -EFAULT;
 -			}
 -
 -			break;
 -
 -		case BPF_JMP | BPF_JA:
 -			jmp_offset = addrs[i + insn->off] - addrs[i];
 -			if (!jmp_offset)
 -				/* optimize out nop jumps */
 +			case BPF_S_LDX_W_LEN: /* X = skb->len; */
 +				seen |= SEEN_XREG;
 +				if (is_imm8(offsetof(struct sk_buff, len)))
 +					/* mov off8(%rdi),%ebx */
 +					EMIT3(0x8b, 0x5f, offsetof(struct sk_buff, len));
 +				else {
 +					EMIT2(0x8b, 0x9f);
 +					EMIT(offsetof(struct sk_buff, len), 4);
 +				}
 +				break;
 +			case BPF_S_ANC_PROTOCOL: /* A = ntohs(skb->protocol); */
 +				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);
 +				if (is_imm8(offsetof(struct sk_buff, protocol))) {
 +					/* movzwl off8(%rdi),%eax */
 +					EMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, protocol));
 +				} else {
 +					EMIT3(0x0f, 0xb7, 0x87); /* movzwl off32(%rdi),%eax */
 +					EMIT(offsetof(struct sk_buff, protocol), 4);
 +				}
 +				EMIT2(0x86, 0xc4); /* ntohs() : xchg   %al,%ah */
 +				break;
 +			case BPF_S_ANC_IFINDEX:
 +				if (is_imm8(offsetof(struct sk_buff, dev))) {
 +					/* movq off8(%rdi),%rax */
 +					EMIT4(0x48, 0x8b, 0x47, offsetof(struct sk_buff, dev));
 +				} else {
 +					EMIT3(0x48, 0x8b, 0x87); /* movq off32(%rdi),%rax */
 +					EMIT(offsetof(struct sk_buff, dev), 4);
 +				}
 +				EMIT3(0x48, 0x85, 0xc0);	/* test %rax,%rax */
 +				EMIT_COND_JMP(X86_JE, cleanup_addr - (addrs[i] - 6));
 +				BUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);
 +				EMIT2(0x8b, 0x80);	/* mov off32(%rax),%eax */
 +				EMIT(offsetof(struct net_device, ifindex), 4);
 +				break;
 +			case BPF_S_ANC_MARK:
 +				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);
 +				if (is_imm8(offsetof(struct sk_buff, mark))) {
 +					/* mov off8(%rdi),%eax */
 +					EMIT3(0x8b, 0x47, offsetof(struct sk_buff, mark));
 +				} else {
 +					EMIT2(0x8b, 0x87);
 +					EMIT(offsetof(struct sk_buff, mark), 4);
 +				}
 +				break;
 +			case BPF_S_ANC_RXHASH:
 +				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, hash) != 4);
 +				if (is_imm8(offsetof(struct sk_buff, hash))) {
 +					/* mov off8(%rdi),%eax */
 +					EMIT3(0x8b, 0x47, offsetof(struct sk_buff, hash));
 +				} else {
 +					EMIT2(0x8b, 0x87);
 +					EMIT(offsetof(struct sk_buff, hash), 4);
 +				}
 +				break;
 +			case BPF_S_ANC_QUEUE:
 +				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);
 +				if (is_imm8(offsetof(struct sk_buff, queue_mapping))) {
 +					/* movzwl off8(%rdi),%eax */
 +					EMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, queue_mapping));
 +				} else {
 +					EMIT3(0x0f, 0xb7, 0x87); /* movzwl off32(%rdi),%eax */
 +					EMIT(offsetof(struct sk_buff, queue_mapping), 4);
 +				}
 +				break;
 +			case BPF_S_ANC_CPU:
 +#ifdef CONFIG_SMP
 +				EMIT4(0x65, 0x8b, 0x04, 0x25); /* mov %gs:off32,%eax */
 +				EMIT((u32)(unsigned long)&cpu_number, 4); /* A = smp_processor_id(); */
 +#else
 +				CLEAR_A();
 +#endif
 +				break;
 +			case BPF_S_ANC_VLAN_TAG:
 +			case BPF_S_ANC_VLAN_TAG_PRESENT:
 +				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, vlan_tci) != 2);
 +				if (is_imm8(offsetof(struct sk_buff, vlan_tci))) {
 +					/* movzwl off8(%rdi),%eax */
 +					EMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, vlan_tci));
 +				} else {
 +					EMIT3(0x0f, 0xb7, 0x87); /* movzwl off32(%rdi),%eax */
 +					EMIT(offsetof(struct sk_buff, vlan_tci), 4);
 +				}
 +				BUILD_BUG_ON(VLAN_TAG_PRESENT != 0x1000);
 +				if (filter[i].code == BPF_S_ANC_VLAN_TAG) {
 +					EMIT3(0x80, 0xe4, 0xef); /* and    $0xef,%ah */
 +				} else {
 +					EMIT3(0xc1, 0xe8, 0x0c); /* shr    $0xc,%eax */
 +					EMIT3(0x83, 0xe0, 0x01); /* and    $0x1,%eax */
 +				}
 +				break;
 +			case BPF_S_ANC_PKTTYPE:
 +			{
 +				int off = pkt_type_offset();
 +
 +				if (off < 0)
 +					goto out;
 +				if (is_imm8(off)) {
 +					/* movzbl off8(%rdi),%eax */
 +					EMIT4(0x0f, 0xb6, 0x47, off);
 +				} else {
 +					/* movbl off32(%rdi),%eax */
 +					EMIT3(0x0f, 0xb6, 0x87);
 +					EMIT(off, 4);
 +				}
 +				EMIT3(0x83, 0xe0, PKT_TYPE_MAX); /* and    $0x7,%eax */
  				break;
 -emit_jmp:
 -			if (is_imm8(jmp_offset)) {
 -				EMIT2(0xEB, jmp_offset);
 -			} else if (is_simm32(jmp_offset)) {
 -				EMIT1_off32(0xE9, jmp_offset);
 -			} else {
 -				pr_err("jmp gen bug %llx\n", jmp_offset);
 -				return -EFAULT;
  			}
 -			break;
 +			case BPF_S_LD_W_ABS:
 +				func = CHOOSE_LOAD_FUNC(K, sk_load_word);
 +common_load:			seen |= SEEN_DATAREF;
 +				t_offset = func - (image + addrs[i]);
 +				EMIT1_off32(0xbe, K); /* mov imm32,%esi */
 +				EMIT1_off32(0xe8, t_offset); /* call */
 +				break;
 +			case BPF_S_LD_H_ABS:
 +				func = CHOOSE_LOAD_FUNC(K, sk_load_half);
 +				goto common_load;
 +			case BPF_S_LD_B_ABS:
 +				func = CHOOSE_LOAD_FUNC(K, sk_load_byte);
 +				goto common_load;
 +			case BPF_S_LDX_B_MSH:
 +				func = CHOOSE_LOAD_FUNC(K, sk_load_byte_msh);
 +				seen |= SEEN_DATAREF | SEEN_XREG;
 +				t_offset = func - (image + addrs[i]);
 +				EMIT1_off32(0xbe, K);	/* mov imm32,%esi */
 +				EMIT1_off32(0xe8, t_offset); /* call sk_load_byte_msh */
 +				break;
 +			case BPF_S_LD_W_IND:
 +				func = sk_load_word;
 +common_load_ind:		seen |= SEEN_DATAREF | SEEN_XREG;
 +				t_offset = func - (image + addrs[i]);
 +				if (K) {
 +					if (is_imm8(K)) {
 +						EMIT3(0x8d, 0x73, K); /* lea imm8(%rbx), %esi */
 +					} else {
 +						EMIT2(0x8d, 0xb3); /* lea imm32(%rbx),%esi */
 +						EMIT(K, 4);
 +					}
 +				} else {
 +					EMIT2(0x89,0xde); /* mov %ebx,%esi */
 +				}
 +				EMIT1_off32(0xe8, t_offset);	/* call sk_load_xxx_ind */
 +				break;
 +			case BPF_S_LD_H_IND:
 +				func = sk_load_half;
 +				goto common_load_ind;
 +			case BPF_S_LD_B_IND:
 +				func = sk_load_byte;
 +				goto common_load_ind;
 +			case BPF_S_JMP_JA:
 +				t_offset = addrs[i + K] - addrs[i];
 +				EMIT_JMP(t_offset);
 +				break;
 +			COND_SEL(BPF_S_JMP_JGT_K, X86_JA, X86_JBE);
 +			COND_SEL(BPF_S_JMP_JGE_K, X86_JAE, X86_JB);
 +			COND_SEL(BPF_S_JMP_JEQ_K, X86_JE, X86_JNE);
 +			COND_SEL(BPF_S_JMP_JSET_K,X86_JNE, X86_JE);
 +			COND_SEL(BPF_S_JMP_JGT_X, X86_JA, X86_JBE);
 +			COND_SEL(BPF_S_JMP_JGE_X, X86_JAE, X86_JB);
 +			COND_SEL(BPF_S_JMP_JEQ_X, X86_JE, X86_JNE);
 +			COND_SEL(BPF_S_JMP_JSET_X,X86_JNE, X86_JE);
 +
 +cond_branch:			f_offset = addrs[i + filter[i].jf] - addrs[i];
 +				t_offset = addrs[i + filter[i].jt] - addrs[i];
 +
 +				/* same targets, can avoid doing the test :) */
 +				if (filter[i].jt == filter[i].jf) {
 +					EMIT_JMP(t_offset);
 +					break;
 +				}
  
 -		case BPF_LD | BPF_IND | BPF_W:
 -			func = sk_load_word;
 -			goto common_load;
 -		case BPF_LD | BPF_ABS | BPF_W:
 -			func = CHOOSE_LOAD_FUNC(imm32, sk_load_word);
 -common_load:
 -			ctx->seen_ld_abs = seen_ld_abs = true;
 -			jmp_offset = func - (image + addrs[i]);
 -			if (!func || !is_simm32(jmp_offset)) {
 -				pr_err("unsupported bpf func %d addr %p image %p\n",
 -				       imm32, func, image);
 -				return -EINVAL;
 -			}
 -			if (BPF_MODE(insn->code) == BPF_ABS) {
 -				/* mov %esi, imm32 */
 -				EMIT1_off32(0xBE, imm32);
 -			} else {
 -				/* mov %rsi, src_reg */
 -				EMIT_mov(BPF_REG_2, src_reg);
 -				if (imm32) {
 -					if (is_imm8(imm32))
 -						/* add %esi, imm8 */
 -						EMIT3(0x83, 0xC6, imm32);
 +				switch (filter[i].code) {
 +				case BPF_S_JMP_JGT_X:
 +				case BPF_S_JMP_JGE_X:
 +				case BPF_S_JMP_JEQ_X:
 +					seen |= SEEN_XREG;
 +					EMIT2(0x39, 0xd8); /* cmp %ebx,%eax */
 +					break;
 +				case BPF_S_JMP_JSET_X:
 +					seen |= SEEN_XREG;
 +					EMIT2(0x85, 0xd8); /* test %ebx,%eax */
 +					break;
 +				case BPF_S_JMP_JEQ_K:
 +					if (K == 0) {
 +						EMIT2(0x85, 0xc0); /* test   %eax,%eax */
 +						break;
 +					}
 +				case BPF_S_JMP_JGT_K:
 +				case BPF_S_JMP_JGE_K:
 +					if (K <= 127)
 +						EMIT3(0x83, 0xf8, K); /* cmp imm8,%eax */
  					else
 -						/* add %esi, imm32 */
 -						EMIT2_off32(0x81, 0xC6, imm32);
 +						EMIT1_off32(0x3d, K); /* cmp imm32,%eax */
 +					break;
 +				case BPF_S_JMP_JSET_K:
 +					if (K <= 0xFF)
 +						EMIT2(0xa8, K); /* test imm8,%al */
 +					else if (!(K & 0xFFFF00FF))
 +						EMIT3(0xf6, 0xc4, K >> 8); /* test imm8,%ah */
 +					else if (K <= 0xFFFF) {
 +						EMIT2(0x66, 0xa9); /* test imm16,%ax */
 +						EMIT(K, 2);
 +					} else {
 +						EMIT1_off32(0xa9, K); /* test imm32,%eax */
 +					}
 +					break;
  				}
 +				if (filter[i].jt != 0) {
 +					if (filter[i].jf && f_offset)
 +						t_offset += is_near(f_offset) ? 2 : 5;
 +					EMIT_COND_JMP(t_op, t_offset);
 +					if (filter[i].jf)
 +						EMIT_JMP(f_offset);
 +					break;
 +				}
 +				EMIT_COND_JMP(f_op, f_offset);
 +				break;
 +			default:
 +				/* hmm, too complex filter, give up with jit compiler */
 +				goto out;
  			}
 -			/* skb pointer is in R6 (%rbx), it will be copied into
 -			 * %rdi if skb_copy_bits() call is necessary.
 -			 * sk_load_* helpers also use %r10 and %r9d.
 -			 * See bpf_jit.S
 -			 */
 -			if (seen_ax_reg)
 -				/* r10 = skb->data, mov %r10, off32(%rbx) */
 -				EMIT3_off32(0x4c, 0x8b, 0x93,
 -					    offsetof(struct sk_buff, data));
 -			EMIT1_off32(0xE8, jmp_offset); /* call */
 -			break;
 -
 -		case BPF_LD | BPF_IND | BPF_H:
 -			func = sk_load_half;
 -			goto common_load;
 -		case BPF_LD | BPF_ABS | BPF_H:
 -			func = CHOOSE_LOAD_FUNC(imm32, sk_load_half);
 -			goto common_load;
 -		case BPF_LD | BPF_IND | BPF_B:
 -			func = sk_load_byte;
 -			goto common_load;
 -		case BPF_LD | BPF_ABS | BPF_B:
 -			func = CHOOSE_LOAD_FUNC(imm32, sk_load_byte);
 -			goto common_load;
 -
 -		case BPF_JMP | BPF_EXIT:
 -			if (seen_exit) {
 -				jmp_offset = ctx->cleanup_addr - addrs[i];
 -				goto emit_jmp;
 -			}
 -			seen_exit = true;
 -			/* update cleanup_addr */
 -			ctx->cleanup_addr = proglen;
 -			/* mov rbx, qword ptr [rbp+0] */
 -			EMIT4(0x48, 0x8B, 0x5D, 0);
 -			/* mov r13, qword ptr [rbp+8] */
 -			EMIT4(0x4C, 0x8B, 0x6D, 8);
 -			/* mov r14, qword ptr [rbp+16] */
 -			EMIT4(0x4C, 0x8B, 0x75, 16);
 -			/* mov r15, qword ptr [rbp+24] */
 -			EMIT4(0x4C, 0x8B, 0x7D, 24);
 -
 -			/* add rbp, AUX_STACK_SPACE */
 -			EMIT4(0x48, 0x83, 0xC5, AUX_STACK_SPACE);
 -			EMIT1(0xC9); /* leave */
 -			EMIT1(0xC3); /* ret */
 -			break;
 -
 -		default:
 -			/* By design x64 JIT should support all BPF instructions
 -			 * This error will be seen if new instruction was added
 -			 * to interpreter, but not to JIT
 -			 * or if there is junk in bpf_prog
 -			 */
 -			pr_err("bpf_jit: unknown opcode %02x\n", insn->code);
 -			return -EINVAL;
 -		}
 -
 -		ilen = prog - temp;
 -		if (ilen > BPF_MAX_INSN_SIZE) {
 -			pr_err("bpf_jit: fatal insn size error\n");
 -			return -EFAULT;
 -		}
 -
 -		if (image) {
 -			if (unlikely(proglen + ilen > oldproglen)) {
 -				pr_err("bpf_jit: fatal error\n");
 -				return -EFAULT;
 +			ilen = prog - temp;
 +			if (image) {
 +				if (unlikely(proglen + ilen > oldproglen)) {
 +					pr_err("bpb_jit_compile fatal error\n");
 +					kfree(addrs);
 +					module_free(NULL, image);
 +					return;
 +				}
 +				memcpy(image + proglen, temp, ilen);
  			}
 -			memcpy(image + proglen, temp, ilen);
 +			proglen += ilen;
 +			addrs[i] = proglen;
 +			prog = temp;
  		}
 -		proglen += ilen;
 -		addrs[i] = proglen;
 -		prog = temp;
 -	}
 -	return proglen;
 -}
 +		/* last bpf instruction is always a RET :
 +		 * use it to give the cleanup instruction(s) addr
 +		 */
 +		cleanup_addr = proglen - 1; /* ret */
 +		if (seen_or_pass0)
 +			cleanup_addr -= 1; /* leaveq */
 +		if (seen_or_pass0 & SEEN_XREG)
 +			cleanup_addr -= 4; /* mov  -8(%rbp),%rbx */
  
 -struct bpf_prog *bpf_int_jit_compile(struct bpf_prog *prog)
 -{
 -	struct bpf_binary_header *header = NULL;
 -	struct bpf_prog *tmp, *orig_prog = prog;
 -	int proglen, oldproglen = 0;
 -	struct jit_context ctx = {};
 -	bool tmp_blinded = false;
 -	u8 *image = NULL;
 -	int *addrs;
 -	int pass;
 -	int i;
 -
 -	if (!prog->jit_requested)
 -		return orig_prog;
 -
 -	tmp = bpf_jit_blind_constants(prog);
 -	/* If blinding was requested and we failed during blinding,
 -	 * we must fall back to the interpreter.
 -	 */
 -	if (IS_ERR(tmp))
 -		return orig_prog;
 -	if (tmp != prog) {
 -		tmp_blinded = true;
 -		prog = tmp;
 -	}
 -
 -	addrs = kmalloc(prog->len * sizeof(*addrs), GFP_KERNEL);
 -	if (!addrs) {
 -		prog = orig_prog;
 -		goto out;
 -	}
 -
 -	/* Before first pass, make a rough estimation of addrs[]
 -	 * each bpf instruction is translated to less than 64 bytes
 -	 */
 -	for (proglen = 0, i = 0; i < prog->len; i++) {
 -		proglen += 64;
 -		addrs[i] = proglen;
 -	}
 -	ctx.cleanup_addr = proglen;
 -
 -	/* JITed image shrinks with every pass and the loop iterates
 -	 * until the image stops shrinking. Very large bpf programs
 -	 * may converge on the last pass. In such case do one more
 -	 * pass to emit the final image
 -	 */
 -	for (pass = 0; pass < 10 || image; pass++) {
 -		proglen = do_jit(prog, addrs, image, oldproglen, &ctx);
 -		if (proglen <= 0) {
 -			image = NULL;
 -			if (header)
 -				bpf_jit_binary_free(header);
 -			prog = orig_prog;
 -			goto out_addrs;
 -		}
  		if (image) {
 -			if (proglen != oldproglen) {
 -				pr_err("bpf_jit: proglen=%d != oldproglen=%d\n",
 -				       proglen, oldproglen);
 -				prog = orig_prog;
 -				goto out_addrs;
 -			}
 +			if (proglen != oldproglen)
 +				pr_err("bpb_jit_compile proglen=%u != oldproglen=%u\n", proglen, oldproglen);
  			break;
  		}
  		if (proglen == oldproglen) {
diff --cc include/linux/filter.h
index d322ed880333,3d6edc34932c..000000000000
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@@ -21,23 -445,54 +21,69 @@@ struct compat_sock_fprog 
  };
  #endif
  
 -struct sock_fprog_kern {
 -	u16			len;
 -	struct sock_filter	*filter;
 +struct sk_buff;
 +struct sock;
 +struct bpf_prog_aux;
 +
 +struct bpf_prog
 +{
 +	struct bpf_prog_aux	*aux;	/* Auxiliary fields */
  };
  
++<<<<<<< HEAD
 +struct sk_filter
 +{
 +	atomic_t		refcnt;
 +	unsigned int         	len;	/* Number of filter blocks */
 +	unsigned int		(*bpf_func)(const struct sk_buff *skb,
 +					    const struct sock_filter *filter);
 +	struct rcu_head		rcu;
 +	struct sock_filter     	insns[0];
++=======
+ struct bpf_binary_header {
+ 	unsigned int pages;
+ 	u8 image[];
+ };
+ 
+ struct bpf_prog {
+ 	u16			pages;		/* Number of allocated pages */
+ 	u16			jited:1,	/* Is our filter JIT'ed? */
+ 				jit_requested:1,/* archs need to JIT the prog */
+ 				locked:1,	/* Program image locked? */
+ 				gpl_compatible:1, /* Is filter GPL compatible? */
+ 				cb_access:1,	/* Is control block accessed? */
+ 				dst_needed:1,	/* Do we need dst entry? */
+ 				kprobe_override:1; /* Do we override a kprobe? */
+ 	enum bpf_prog_type	type;		/* Type of BPF program */
+ 	u32			len;		/* Number of filter blocks */
+ 	u32			jited_len;	/* Size of jited insns in bytes */
+ 	u8			tag[BPF_TAG_SIZE];
+ 	struct bpf_prog_aux	*aux;		/* Auxiliary fields */
+ 	struct sock_fprog_kern	*orig_prog;	/* Original BPF program */
+ 	unsigned int		(*bpf_func)(const void *ctx,
+ 					    const struct bpf_insn *insn);
+ 	/* Instructions for interpreter */
+ 	union {
+ 		struct sock_filter	insns[0];
+ 		struct bpf_insn		insnsi[0];
+ 	};
+ };
+ 
+ struct sk_filter {
+ 	refcount_t	refcnt;
+ 	struct rcu_head	rcu;
+ 	struct bpf_prog	*prog;
+ };
+ 
+ #define BPF_PROG_RUN(filter, ctx)  (*(filter)->bpf_func)(ctx, (filter)->insnsi)
+ 
+ #define BPF_SKB_CB_LEN QDISC_CB_PRIV_LEN
+ 
+ struct bpf_skb_data_end {
+ 	struct qdisc_skb_cb qdisc_cb;
+ 	void *data_meta;
+ 	void *data_end;
++>>>>>>> 60b58afc96c9 (bpf: fix net.core.bpf_jit_enable race)
  };
  
  struct xdp_buff {
@@@ -98,22 -778,208 +144,146 @@@ extern void bpf_jit_free(struct sk_filt
  static inline void bpf_jit_dump(unsigned int flen, unsigned int proglen,
  				u32 pass, void *image)
  {
 -	pr_err("flen=%u proglen=%u pass=%u image=%pK from=%s pid=%d\n", flen,
 -	       proglen, pass, image, current->comm, task_pid_nr(current));
 -
 +	pr_err("flen=%u proglen=%u pass=%u image=%p\n",
 +	       flen, proglen, pass, image);
  	if (image)
 -		print_hex_dump(KERN_ERR, "JIT code: ", DUMP_PREFIX_OFFSET,
 +		print_hex_dump(KERN_ERR, "JIT code: ", DUMP_PREFIX_ADDRESS,
  			       16, 1, image, proglen, false);
  }
++<<<<<<< HEAD
 +#define SK_RUN_FILTER(FILTER, SKB) (*FILTER->bpf_func)(SKB, FILTER->insns)
 +#else
 +static inline void bpf_jit_compile(struct sk_filter *fp)
++=======
+ 
+ static inline bool bpf_jit_is_ebpf(void)
+ {
+ # ifdef CONFIG_HAVE_EBPF_JIT
+ 	return true;
+ # else
+ 	return false;
+ # endif
+ }
+ 
+ static inline bool ebpf_jit_enabled(void)
+ {
+ 	return bpf_jit_enable && bpf_jit_is_ebpf();
+ }
+ 
+ static inline bool bpf_prog_ebpf_jited(const struct bpf_prog *fp)
+ {
+ 	return fp->jited && bpf_jit_is_ebpf();
+ }
+ 
+ static inline bool bpf_jit_blinding_enabled(struct bpf_prog *prog)
+ {
+ 	/* These are the prerequisites, should someone ever have the
+ 	 * idea to call blinding outside of them, we make sure to
+ 	 * bail out.
+ 	 */
+ 	if (!bpf_jit_is_ebpf())
+ 		return false;
+ 	if (!prog->jit_requested)
+ 		return false;
+ 	if (!bpf_jit_harden)
+ 		return false;
+ 	if (bpf_jit_harden == 1 && capable(CAP_SYS_ADMIN))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static inline bool bpf_jit_kallsyms_enabled(void)
+ {
+ 	/* There are a couple of corner cases where kallsyms should
+ 	 * not be enabled f.e. on hardening.
+ 	 */
+ 	if (bpf_jit_harden)
+ 		return false;
+ 	if (!bpf_jit_kallsyms)
+ 		return false;
+ 	if (bpf_jit_kallsyms == 1)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ const char *__bpf_address_lookup(unsigned long addr, unsigned long *size,
+ 				 unsigned long *off, char *sym);
+ bool is_bpf_text_address(unsigned long addr);
+ int bpf_get_kallsym(unsigned int symnum, unsigned long *value, char *type,
+ 		    char *sym);
+ 
+ static inline const char *
+ bpf_address_lookup(unsigned long addr, unsigned long *size,
+ 		   unsigned long *off, char **modname, char *sym)
+ {
+ 	const char *ret = __bpf_address_lookup(addr, size, off, sym);
+ 
+ 	if (ret && modname)
+ 		*modname = NULL;
+ 	return ret;
+ }
+ 
+ void bpf_prog_kallsyms_add(struct bpf_prog *fp);
+ void bpf_prog_kallsyms_del(struct bpf_prog *fp);
+ 
+ #else /* CONFIG_BPF_JIT */
+ 
+ static inline bool ebpf_jit_enabled(void)
+ {
+ 	return false;
+ }
+ 
+ static inline bool bpf_prog_ebpf_jited(const struct bpf_prog *fp)
+ {
+ 	return false;
+ }
+ 
+ static inline void bpf_jit_free(struct bpf_prog *fp)
+ {
+ 	bpf_prog_unlock_free(fp);
+ }
+ 
+ static inline bool bpf_jit_kallsyms_enabled(void)
+ {
+ 	return false;
+ }
+ 
+ static inline const char *
+ __bpf_address_lookup(unsigned long addr, unsigned long *size,
+ 		     unsigned long *off, char *sym)
+ {
+ 	return NULL;
+ }
+ 
+ static inline bool is_bpf_text_address(unsigned long addr)
+ {
+ 	return false;
+ }
+ 
+ static inline int bpf_get_kallsym(unsigned int symnum, unsigned long *value,
+ 				  char *type, char *sym)
+ {
+ 	return -ERANGE;
+ }
+ 
+ static inline const char *
+ bpf_address_lookup(unsigned long addr, unsigned long *size,
+ 		   unsigned long *off, char **modname, char *sym)
+ {
+ 	return NULL;
+ }
+ 
+ static inline void bpf_prog_kallsyms_add(struct bpf_prog *fp)
++>>>>>>> 60b58afc96c9 (bpf: fix net.core.bpf_jit_enable race)
  {
  }
 -
 -static inline void bpf_prog_kallsyms_del(struct bpf_prog *fp)
 +static inline void bpf_jit_free(struct sk_filter *fp)
  {
  }
 -#endif /* CONFIG_BPF_JIT */
 -
 -#define BPF_ANC		BIT(15)
 -
 -static inline bool bpf_needs_clear_a(const struct sock_filter *first)
 -{
 -	switch (first->code) {
 -	case BPF_RET | BPF_K:
 -	case BPF_LD | BPF_W | BPF_LEN:
 -		return false;
 -
 -	case BPF_LD | BPF_W | BPF_ABS:
 -	case BPF_LD | BPF_H | BPF_ABS:
 -	case BPF_LD | BPF_B | BPF_ABS:
 -		if (first->k == SKF_AD_OFF + SKF_AD_ALU_XOR_X)
 -			return true;
 -		return false;
 -
 -	default:
 -		return true;
 -	}
 -}
 -
 -static inline u16 bpf_anc_helper(const struct sock_filter *ftest)
 -{
 -	BUG_ON(ftest->code & BPF_ANC);
 -
 -	switch (ftest->code) {
 -	case BPF_LD | BPF_W | BPF_ABS:
 -	case BPF_LD | BPF_H | BPF_ABS:
 -	case BPF_LD | BPF_B | BPF_ABS:
 -#define BPF_ANCILLARY(CODE)	case SKF_AD_OFF + SKF_AD_##CODE:	\
 -				return BPF_ANC | SKF_AD_##CODE
 -		switch (ftest->k) {
 -		BPF_ANCILLARY(PROTOCOL);
 -		BPF_ANCILLARY(PKTTYPE);
 -		BPF_ANCILLARY(IFINDEX);
 -		BPF_ANCILLARY(NLATTR);
 -		BPF_ANCILLARY(NLATTR_NEST);
 -		BPF_ANCILLARY(MARK);
 -		BPF_ANCILLARY(QUEUE);
 -		BPF_ANCILLARY(HATYPE);
 -		BPF_ANCILLARY(RXHASH);
 -		BPF_ANCILLARY(CPU);
 -		BPF_ANCILLARY(ALU_XOR_X);
 -		BPF_ANCILLARY(VLAN_TAG);
 -		BPF_ANCILLARY(VLAN_TAG_PRESENT);
 -		BPF_ANCILLARY(PAY_OFFSET);
 -		BPF_ANCILLARY(RANDOM);
 -		BPF_ANCILLARY(VLAN_TPID);
 -		}
 -		/* Fallthrough. */
 -	default:
 -		return ftest->code;
 -	}
 -}
 -
 -void *bpf_internal_load_pointer_neg_helper(const struct sk_buff *skb,
 -					   int k, unsigned int size);
 -
 -static inline void *bpf_load_pointer(const struct sk_buff *skb, int k,
 -				     unsigned int size, void *buffer)
 -{
 -	if (k >= 0)
 -		return skb_header_pointer(skb, k, size, buffer);
 -
 -	return bpf_internal_load_pointer_neg_helper(skb, k, size);
 -}
 +#define SK_RUN_FILTER(FILTER, SKB) sk_run_filter(SKB, FILTER->insns)
 +#endif
  
  static inline int bpf_tell_extensions(void)
  {
* Unmerged path arch/arm64/net/bpf_jit_comp.c
* Unmerged path arch/mips/net/ebpf_jit.c
* Unmerged path arch/powerpc/net/bpf_jit_comp64.c
* Unmerged path arch/sparc/net/bpf_jit_comp_64.c
* Unmerged path kernel/bpf/core.c
* Unmerged path kernel/bpf/verifier.c
* Unmerged path arch/arm/net/bpf_jit_32.c
* Unmerged path arch/arm64/net/bpf_jit_comp.c
* Unmerged path arch/mips/net/ebpf_jit.c
* Unmerged path arch/powerpc/net/bpf_jit_comp64.c
* Unmerged path arch/s390/net/bpf_jit_comp.c
* Unmerged path arch/sparc/net/bpf_jit_comp_64.c
* Unmerged path arch/x86/net/bpf_jit_comp.c
* Unmerged path include/linux/filter.h
* Unmerged path kernel/bpf/core.c
* Unmerged path kernel/bpf/verifier.c
