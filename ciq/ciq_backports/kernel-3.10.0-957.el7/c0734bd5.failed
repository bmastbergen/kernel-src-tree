ipmi: Retry BMC registration on a failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Corey Minyard <cminyard@mvista.com>
commit c0734bd594d43a28afcbe476bbf0d35a5bbffa4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c0734bd5.failed

If the BMC fails to register, just set up to retry periodically.

	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit c0734bd594d43a28afcbe476bbf0d35a5bbffa4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_msghandler.c
diff --cc drivers/char/ipmi/ipmi_msghandler.c
index ac86372bf4bd,c6ee1de8d76b..000000000000
--- a/drivers/char/ipmi/ipmi_msghandler.c
+++ b/drivers/char/ipmi/ipmi_msghandler.c
@@@ -47,9 -47,8 +47,10 @@@
  #include <linux/rcupdate.h>
  #include <linux/interrupt.h>
  #include <linux/moduleparam.h>
+ #include <linux/workqueue.h>
  
 +#include <linux/rh_kabi.h>
 +
  #define PFX "IPMI message handler: "
  
  #define IPMI_DRIVER_VERSION "39.2"
@@@ -423,6 -430,8 +424,11 @@@ struct ipmi_smi 
  	bool bmc_registered;
  	struct list_head bmc_link;
  	char *my_dev_name;
++<<<<<<< HEAD
++=======
+ 	bool in_bmc_register;  /* Handle recursive situations.  Yuck. */
+ 	struct work_struct bmc_reg_work;
++>>>>>>> c0734bd594d4 (ipmi: Retry BMC registration on a failure)
  
  	/*
  	 * This is the lower-layer's sender routine.  Note that you
@@@ -2252,7 -2253,49 +2258,53 @@@ retry_bmc_lock
  	if (rv)
  		goto out;
  
++<<<<<<< HEAD
 +	memcpy(&bmc->id, &bmc->fetch_id, sizeof(bmc->id));
++=======
+ 	/*
+ 	 * The guid, device id, manufacturer id, and product id should
+ 	 * not change on a BMC.  If it does we have to do some dancing.
+ 	 */
+ 	if (!intf->bmc_registered
+ 	    || (!prev_guid_set && bmc->dyn_guid_set)
+ 	    || (!prev_dyn_id_set && bmc->dyn_id_set)
+ 	    || (prev_guid_set && bmc->dyn_guid_set
+ 		&& memcmp(bmc->guid, bmc->fetch_guid, 16))
+ 	    || bmc->id.device_id != bmc->fetch_id.device_id
+ 	    || bmc->id.manufacturer_id != bmc->fetch_id.manufacturer_id
+ 	    || bmc->id.product_id != bmc->fetch_id.product_id) {
+ 		struct ipmi_device_id id = bmc->fetch_id;
+ 		int guid_set = bmc->dyn_guid_set;
+ 		u8 guid[16];
+ 
+ 		memcpy(guid, bmc->fetch_guid, 16);
+ 		mutex_unlock(&bmc->dyn_mutex);
+ 
+ 		__ipmi_bmc_unregister(intf);
+ 		/* Fill in the temporary BMC for good measure. */
+ 		intf->bmc->id = id;
+ 		intf->bmc->dyn_guid_set = guid_set;
+ 		memcpy(intf->bmc->guid, guid, 16);
+ 		if (__ipmi_bmc_register(intf, &id, guid_set, guid, intf_num))
+ 			need_waiter(intf); /* Retry later on an error. */
+ 
+ 		if (!intf_set) {
+ 			/*
+ 			 * We weren't given the interface on the
+ 			 * command line, so restart the operation on
+ 			 * the next interface for the BMC.
+ 			 */
+ 			mutex_unlock(&intf->bmc_reg_mutex);
+ 			mutex_lock(&bmc->dyn_mutex);
+ 			goto retry_bmc_lock;
+ 		}
+ 
+ 		/* We have a new BMC, set it up. */
+ 		bmc = intf->bmc;
+ 		mutex_lock(&bmc->dyn_mutex);
+ 		goto out_noprocessing;
+ 	}
++>>>>>>> c0734bd594d4 (ipmi: Retry BMC registration on a failure)
  
  	bmc->dyn_id_expiry = jiffies + IPMI_DYN_DEV_ID_EXPIRY;
  
@@@ -3171,11 -3279,19 +3223,25 @@@ void ipmi_poll_interface(ipmi_user_t us
  }
  EXPORT_SYMBOL(ipmi_poll_interface);
  
++<<<<<<< HEAD
 +int ipmi_register_smi(struct ipmi_smi_handlers *handlers,
++=======
+ static void redo_bmc_reg(struct work_struct *work)
+ {
+ 	ipmi_smi_t intf = container_of(work, struct ipmi_smi, bmc_reg_work);
+ 
+ 	if (!intf->in_shutdown)
+ 		bmc_get_device_id(intf, NULL, NULL, NULL, NULL);
+ 
+ 	kref_put(&intf->refcount, intf_free);
+ }
+ 
+ int ipmi_register_smi(const struct ipmi_smi_handlers *handlers,
++>>>>>>> c0734bd594d4 (ipmi: Retry BMC registration on a failure)
  		      void		       *send_info,
 +		      struct ipmi_device_id    *device_id,
  		      struct device            *si_dev,
 +		      const char               *sysfs_name,
  		      unsigned char            slave_addr)
  {
  	int              i, j;
* Unmerged path drivers/char/ipmi/ipmi_msghandler.c
