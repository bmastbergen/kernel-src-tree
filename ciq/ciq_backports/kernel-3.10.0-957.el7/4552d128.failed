powerpc: System reset avoid interleaving oops using die synchronisation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [powerpc] System reset avoid interleaving oops using die synchronisation (Mauricio Oliveira) [1564126]
Rebuild_FUZZ: 93.23%
commit-author Nicholas Piggin <npiggin@gmail.com>
commit 4552d128c26e0f0f27a5bd2fadc24092b8f6c1d7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4552d128.failed

The die() oops path contains a serializing lock to prevent oops
messages from being interleaved. In the case of a system reset
initiated oops (e.g., qemu nmi command), __die was being called
which lacks that synchronisation and oops reports could be
interleaved across CPUs.

A recent patch 4388c9b3a6ee7 ("powerpc: Do not send system reset
request through the oops path") changed this to __die to avoid
the debugger() call, but there is no real harm to calling it twice
if the first time fell through. So go back to using die() here.
This was observed to fix the problem.

Fixes: 4388c9b3a6ee7 ("powerpc: Do not send system reset request through the oops path")
	Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
	Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 4552d128c26e0f0f27a5bd2fadc24092b8f6c1d7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/traps.c
diff --cc arch/powerpc/kernel/traps.c
index 8b1f9ad2f1e0,d139117d3339..000000000000
--- a/arch/powerpc/kernel/traps.c
+++ b/arch/powerpc/kernel/traps.c
@@@ -273,14 -301,60 +273,49 @@@ void system_reset_exception(struct pt_r
  	/* See if any machine dependent calls */
  	if (ppc_md.system_reset_exception) {
  		if (ppc_md.system_reset_exception(regs))
 -			goto out;
 +			return;
  	}
  
 -	if (debugger(regs))
 -		goto out;
 +	die("System Reset", regs, SIGABRT);
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * A system reset is a request to dump, so we always send
+ 	 * it through the crashdump code (if fadump or kdump are
+ 	 * registered).
+ 	 */
+ 	crash_fadump(regs, "System Reset");
+ 
+ 	crash_kexec(regs);
+ 
+ 	/*
+ 	 * We aren't the primary crash CPU. We need to send it
+ 	 * to a holding pattern to avoid it ending up in the panic
+ 	 * code.
+ 	 */
+ 	crash_kexec_secondary(regs);
+ 
+ 	/*
+ 	 * No debugger or crash dump registered, print logs then
+ 	 * panic.
+ 	 */
+ 	die("System Reset", regs, SIGABRT);
+ 
+ 	mdelay(2*MSEC_PER_SEC); /* Wait a little while for others to print */
+ 	add_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);
+ 	nmi_panic(regs, "System Reset");
+ 
+ out:
+ #ifdef CONFIG_PPC_BOOK3S_64
+ 	BUG_ON(get_paca()->in_nmi == 0);
+ 	if (get_paca()->in_nmi > 1)
+ 		nmi_panic(regs, "Unrecoverable nested System Reset");
+ #endif
++>>>>>>> 4552d128c26e (powerpc: System reset avoid interleaving oops using die synchronisation)
  	/* Must die if the interrupt is not recoverable */
  	if (!(regs->msr & MSR_RI))
 -		nmi_panic(regs, "Unrecoverable System Reset");
 -
 -	if (!nested)
 -		nmi_exit();
 +		panic("Unrecoverable System Reset");
  
  	/* What should we do here? We could issue a shutdown or hard reset. */
  }
* Unmerged path arch/powerpc/kernel/traps.c
