netfilter: ipset: Simplify cidr handling for hash:*net* types

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 25a76f3463e0424fdf85773afb4be4972b1c0a29
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/25a76f34.failed

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 25a76f3463e0424fdf85773afb4be4972b1c0a29)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_hash_gen.h
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 72686abe715e,8ef9135d8bb5..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -155,11 -142,22 +155,30 @@@ hbucket_elem_add(struct hbucket *n, u8 
  }
  
  #ifdef IP_SET_HASH_WITH_NETS
++<<<<<<< HEAD
 +#ifdef IP_SET_HASH_WITH_NETS_PACKED
 +/* When cidr is packed with nomatch, cidr - 1 is stored in the entry */
 +#define CIDR(cidr)		(cidr + 1)
 +#else
 +#define CIDR(cidr)		(cidr)
++=======
+ #if IPSET_NET_COUNT > 1
+ #define __CIDR(cidr, i)		(cidr[i])
+ #else
+ #define __CIDR(cidr, i)		(cidr)
+ #endif
+ 
+ /* cidr + 1 is stored in net_prefixes to support /0 */
+ #define SCIDR(cidr, i)		(__CIDR(cidr, i) + 1)
+ 
+ #ifdef IP_SET_HASH_WITH_NETS_PACKED
+ /* When cidr is packed with nomatch, cidr - 1 is stored in the data entry */
+ #define GCIDR(cidr, i)		(__CIDR(cidr, i) + 1)
+ #define NCIDR(cidr)		(cidr)
+ #else
+ #define GCIDR(cidr, i)		(__CIDR(cidr, i))
+ #define NCIDR(cidr)		(cidr - 1)
++>>>>>>> 25a76f3463e0 (netfilter: ipset: Simplify cidr handling for hash:*net* types)
  #endif
  
  #define SET_HOST_MASK(family)	(family == AF_INET ? 32 : 128)
@@@ -300,24 -298,22 +319,41 @@@ mtype_add_cidr(struct htype *h, u8 cidr
  	int i, j;
  
  	/* Add in increasing prefix order, so larger cidr first */
++<<<<<<< HEAD
 +	for (i = 0, j = -1; i < nets_length && h->nets[i].nets; i++) {
++=======
+ 	for (i = 0, j = -1; i < nets_length && h->nets[i].cidr[n]; i++) {
++>>>>>>> 25a76f3463e0 (netfilter: ipset: Simplify cidr handling for hash:*net* types)
  		if (j != -1)
  			continue;
 -		else if (h->nets[i].cidr[n] < cidr)
 +		else if (h->nets[i].cidr < cidr)
  			j = i;
++<<<<<<< HEAD
 +		else if (h->nets[i].cidr == cidr) {
 +			h->nets[i].nets++;
++=======
+ 		else if (h->nets[i].cidr[n] == cidr) {
+ 			h->nets[cidr - 1].nets[n]++;
++>>>>>>> 25a76f3463e0 (netfilter: ipset: Simplify cidr handling for hash:*net* types)
  			return;
  		}
  	}
  	if (j != -1) {
++<<<<<<< HEAD
 +		for (; i > j; i--) {
 +			h->nets[i].cidr = h->nets[i - 1].cidr;
 +			h->nets[i].nets = h->nets[i - 1].nets;
 +		}
 +	}
 +	h->nets[i].cidr = cidr;
 +	h->nets[i].nets = 1;
++=======
+ 		for (; i > j; i--)
+ 			h->nets[i].cidr[n] = h->nets[i - 1].cidr[n];
+ 	}
+ 	h->nets[i].cidr[n] = cidr;
+ 	h->nets[cidr - 1].nets[n] = 1;
++>>>>>>> 25a76f3463e0 (netfilter: ipset: Simplify cidr handling for hash:*net* types)
  }
  
  static void
@@@ -326,18 -322,14 +362,27 @@@ mtype_del_cidr(struct htype *h, u8 cidr
  	u8 i, j, net_end = nets_length - 1;
  
  	for (i = 0; i < nets_length; i++) {
 -	        if (h->nets[i].cidr[n] != cidr)
 +	        if (h->nets[i].cidr != cidr)
  	                continue;
++<<<<<<< HEAD
 +                if (h->nets[i].nets > 1 || i == net_end ||
 +                    h->nets[i + 1].nets == 0) {
 +                        h->nets[i].nets--;
 +                        return;
 +                }
 +                for (j = i; j < net_end && h->nets[j].nets; j++) {
 +		        h->nets[j].cidr = h->nets[j + 1].cidr;
 +		        h->nets[j].nets = h->nets[j + 1].nets;
 +                }
 +                h->nets[j].nets = 0;
++=======
+ 		h->nets[cidr -1].nets[n]--;
+ 		if (h->nets[cidr -1].nets[n] > 0)
+                         return;
+ 		for (j = i; j < net_end && h->nets[j].cidr[n]; j++)
+ 		        h->nets[j].cidr[n] = h->nets[j + 1].cidr[n];
+ 		h->nets[j].cidr[n] = 0;
++>>>>>>> 25a76f3463e0 (netfilter: ipset: Simplify cidr handling for hash:*net* types)
                  return;
  	}
  }
@@@ -451,12 -482,14 +496,18 @@@ mtype_expire(struct htype *h, u8 nets_l
  		n = hbucket(t, i);
  		for (j = 0; j < n->pos; j++) {
  			data = ahash_data(n, j, dsize);
 -			if (ip_set_timeout_expired(ext_timeout(data, set))) {
 +			if (ip_set_timeout_expired(ext_timeout(data, h))) {
  				pr_debug("expired %u/%u\n", i, j);
  #ifdef IP_SET_HASH_WITH_NETS
++<<<<<<< HEAD
 +				mtype_del_cidr(h, CIDR(data->cidr),
 +					       nets_length);
++=======
+ 				for (k = 0; k < IPSET_NET_COUNT; k++)
+ 					mtype_del_cidr(h, SCIDR(data->cidr, k),
+ 						       nets_length, k);
++>>>>>>> 25a76f3463e0 (netfilter: ipset: Simplify cidr handling for hash:*net* types)
  #endif
 -				ip_set_ext_destroy(set, data);
  				if (j != n->pos - 1)
  					/* Not last one */
  					memcpy(data,
@@@ -638,11 -660,33 +689,20 @@@ mtype_add(struct ip_set *set, void *val
  reuse_slot:
  	if (j != AHASH_MAX(h) + 1) {
  		/* Fill out reused slot */
 -		data = ahash_data(n, j, set->dsize);
 +		data = ahash_data(n, j, h->dsize);
  #ifdef IP_SET_HASH_WITH_NETS
++<<<<<<< HEAD
 +		mtype_del_cidr(h, CIDR(data->cidr), NETS_LENGTH(set->family));
 +		mtype_add_cidr(h, CIDR(d->cidr), NETS_LENGTH(set->family));
++=======
+ 		for (i = 0; i < IPSET_NET_COUNT; i++) {
+ 			mtype_del_cidr(h, SCIDR(data->cidr, i),
+ 				       NLEN(set->family), i);
+ 			mtype_add_cidr(h, SCIDR(d->cidr, i),
+ 				       NLEN(set->family), i);
+ 		}
++>>>>>>> 25a76f3463e0 (netfilter: ipset: Simplify cidr handling for hash:*net* types)
  #endif
 -		ip_set_ext_destroy(set, data);
  	} else {
  		/* Use/create a new slot */
  		TUNE_AHASH_MAX(h, multi);
@@@ -652,9 -696,11 +712,15 @@@
  				mtype_data_next(&h->next, d);
  			goto out;
  		}
 -		data = ahash_data(n, n->pos++, set->dsize);
 +		data = ahash_data(n, n->pos++, h->dsize);
  #ifdef IP_SET_HASH_WITH_NETS
++<<<<<<< HEAD
 +		mtype_add_cidr(h, CIDR(d->cidr), NETS_LENGTH(set->family));
++=======
+ 		for (i = 0; i < IPSET_NET_COUNT; i++)
+ 			mtype_add_cidr(h, SCIDR(d->cidr, i), NLEN(set->family),
+ 				       i);
++>>>>>>> 25a76f3463e0 (netfilter: ipset: Simplify cidr handling for hash:*net* types)
  #endif
  		h->elements++;
  	}
@@@ -704,16 -759,21 +770,22 @@@ mtype_del(struct ip_set *set, void *val
  		n->pos--;
  		h->elements--;
  #ifdef IP_SET_HASH_WITH_NETS
++<<<<<<< HEAD
 +		mtype_del_cidr(h, CIDR(d->cidr), NETS_LENGTH(set->family));
++=======
+ 		for (j = 0; j < IPSET_NET_COUNT; j++)
+ 			mtype_del_cidr(h, SCIDR(d->cidr, j), NLEN(set->family),
+ 				       j);
++>>>>>>> 25a76f3463e0 (netfilter: ipset: Simplify cidr handling for hash:*net* types)
  #endif
 -		ip_set_ext_destroy(set, data);
  		if (n->pos + AHASH_INIT_SIZE < n->size) {
  			void *tmp = kzalloc((n->size - AHASH_INIT_SIZE)
 -					    * set->dsize,
 +					    * h->dsize,
  					    GFP_ATOMIC);
 -			if (!tmp) {
 -				ret = 0;
 -				goto out;
 -			}
 +			if (!tmp)
 +				return 0;
  			n->size -= AHASH_INIT_SIZE;
 -			memcpy(tmp, n->value, n->size * set->dsize);
 +			memcpy(tmp, n->value, n->size * h->dsize);
  			kfree(n->value);
  			n->value = tmp;
  		}
@@@ -743,16 -808,29 +815,29 @@@ mtype_test_cidrs(struct ip_set *set, st
  		 struct ip_set_ext *mext, u32 flags)
  {
  	struct htype *h = set->data;
 -	struct htable *t = rcu_dereference_bh(h->table);
 +	struct htable *t = h->table;
  	struct hbucket *n;
  	struct mtype_elem *data;
 -#if IPSET_NET_COUNT == 2
 -	struct mtype_elem orig = *d;
 -	int i, j = 0, k;
 -#else
  	int i, j = 0;
 -#endif
  	u32 key, multi = 0;
 -	u8 nets_length = NLEN(set->family);
 +	u8 nets_length = NETS_LENGTH(set->family);
  
  	pr_debug("test by nets\n");
++<<<<<<< HEAD
 +	for (; j < nets_length && h->nets[j].nets && !multi; j++) {
 +		mtype_data_netmask(d, h->nets[j].cidr);
++=======
+ 	for (; j < nets_length && h->nets[j].cidr[0] && !multi; j++) {
+ #if IPSET_NET_COUNT == 2
+ 		mtype_data_reset_elem(d, &orig);
+ 		mtype_data_netmask(d, NCIDR(h->nets[j].cidr[0]), false);
+ 		for (k = 0; k < nets_length && h->nets[k].cidr[1] && !multi;
+ 		     k++) {
+ 			mtype_data_netmask(d, NCIDR(h->nets[k].cidr[1]), true);
+ #else
+ 		mtype_data_netmask(d, NCIDR(h->nets[j].cidr[0]));
+ #endif
++>>>>>>> 25a76f3463e0 (netfilter: ipset: Simplify cidr handling for hash:*net* types)
  		key = HKEY(d, h->initval, t->htable_bits);
  		n = hbucket(t, key);
  		for (i = 0; i < n->pos; i++) {
@@@ -793,8 -874,15 +878,18 @@@ mtype_test(struct ip_set *set, void *va
  #ifdef IP_SET_HASH_WITH_NETS
  	/* If we test an IP address and not a network address,
  	 * try all possible network sizes */
++<<<<<<< HEAD
 +	if (CIDR(d->cidr) == SET_HOST_MASK(set->family))
 +		return mtype_test_cidrs(set, d, ext, mext, flags);
++=======
+ 	for (i = 0; i < IPSET_NET_COUNT; i++)
+ 		if (GCIDR(d->cidr, i) != SET_HOST_MASK(set->family))
+ 			break;
+ 	if (i == IPSET_NET_COUNT) {
+ 		ret = mtype_test_cidrs(set, d, ext, mext, flags);
+ 		goto out;
+ 	}
++>>>>>>> 25a76f3463e0 (netfilter: ipset: Simplify cidr handling for hash:*net* types)
  #endif
  
  	key = HKEY(d, h->initval, t->htable_bits);
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
