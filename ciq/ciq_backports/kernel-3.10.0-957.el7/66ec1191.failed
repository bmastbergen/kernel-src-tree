perf pmu: Unbreak perf record for arm/arm64 with events with explicit PMU

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Mark Rutland <mark.rutland@arm.com>
commit 66ec11919a0f96e936bb731fdbc2851316077d26
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/66ec1191.failed

Currently, perf record is broken on arm/arm64 systems when the PMU is
specified explicitly as part of the event, e.g.

$ ./perf record -e armv8_cortex_a53/cpu_cycles/u true

In such cases, perf record fails to open events unless
perf_event_paranoid is set to -1, even if the PMU in question supports
mode exclusion. Further, even when perf_event_paranoid is toggled, no
samples are recorded.

This is an unintended side effect of commit:

  e3ba76deef23064f ("perf tools: Force uncore events to system wide monitoring)

... which assumes that if a PMU has an associated cpu_map, it is an
uncore PMU, and forces events for such PMUs to be system-wide.

This is not true for arm/arm64 systems, which can have heterogeneous
CPUs. To account for this, multiple CPU PMUs are exposed, each with a
"cpus" field under sysfs, which the perf tool parses into a cpu_map. ARM
PMUs do not have a "cpumask" file, and only have a "cpus" file. For the
gory details as to why, see commit:

 7e3fcffe95544010 ("perf pmu: Support alternative sysfs cpumask")

Given all of this, we can instead identify uncore PMUs by explicitly
checking for a "cpumask" file, and restore arm/arm64 PMU support back to
a working state. This patch does so, adding a new perf_pmu::is_uncore
field, and splitting the existing cpumask parsing so that it can be
reused.

	Signed-off-by: Mark Rutland <mark.rutland@arm.com>
	Tested-by Will Deacon <will.deacon@arm.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: 4.12+ <stable@vger.kernel.org>
Fixes: e3ba76deef23064f ("perf tools: Force uncore events to system wide monitoring)
Link: http://lkml.kernel.org/r/1507315102-5942-1-git-send-email-mark.rutland@arm.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 66ec11919a0f96e936bb731fdbc2851316077d26)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/parse-events.c
#	tools/perf/util/pmu.c
diff --cc tools/perf/util/parse-events.c
index eb476984ddca,39b15968eab1..000000000000
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@@ -304,10 -309,11 +304,16 @@@ static char *get_config_name(struct lis
  static struct perf_evsel *
  __add_event(struct list_head *list, int *idx,
  	    struct perf_event_attr *attr,
++<<<<<<< HEAD
 +	    char *name, struct cpu_map *cpus,
 +	    struct list_head *config_terms)
++=======
+ 	    char *name, struct perf_pmu *pmu,
+ 	    struct list_head *config_terms, bool auto_merge_stats)
++>>>>>>> 66ec11919a0f (perf pmu: Unbreak perf record for arm/arm64 with events with explicit PMU)
  {
  	struct perf_evsel *evsel;
+ 	struct cpu_map *cpus = pmu ? pmu->cpus : NULL;
  
  	event_attr_init(attr);
  
@@@ -318,7 -324,8 +324,12 @@@
  	(*idx)++;
  	evsel->cpus        = cpu_map__get(cpus);
  	evsel->own_cpus    = cpu_map__get(cpus);
++<<<<<<< HEAD
 +	evsel->system_wide = !!cpus;
++=======
+ 	evsel->system_wide = pmu ? pmu->is_uncore : false;
+ 	evsel->auto_merge_stats = auto_merge_stats;
++>>>>>>> 66ec11919a0f (perf pmu: Unbreak perf record for arm/arm64 with events with explicit PMU)
  
  	if (name)
  		evsel->name = strdup(name);
@@@ -998,7 -1234,7 +1009,11 @@@ int parse_events_add_pmu(struct parse_e
  
  	if (!head_config) {
  		attr.type = pmu->type;
++<<<<<<< HEAD
 +		evsel = __add_event(list, &data->idx, &attr, NULL, pmu->cpus, NULL);
++=======
+ 		evsel = __add_event(list, &parse_state->idx, &attr, NULL, pmu, NULL, auto_merge_stats);
++>>>>>>> 66ec11919a0f (perf pmu: Unbreak perf record for arm/arm64 with events with explicit PMU)
  		return evsel ? 0 : -ENOMEM;
  	}
  
@@@ -1015,12 -1251,12 +1030,18 @@@
  	if (get_config_terms(head_config, &config_terms))
  		return -ENOMEM;
  
 -	if (perf_pmu__config(pmu, &attr, head_config, parse_state->error))
 +	if (perf_pmu__config(pmu, &attr, head_config, data->error))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	evsel = __add_event(list, &data->idx, &attr,
 +			    get_config_name(head_config), pmu->cpus,
 +			    &config_terms);
++=======
+ 	evsel = __add_event(list, &parse_state->idx, &attr,
+ 			    get_config_name(head_config), pmu,
+ 			    &config_terms, auto_merge_stats);
++>>>>>>> 66ec11919a0f (perf pmu: Unbreak perf record for arm/arm64 with events with explicit PMU)
  	if (evsel) {
  		evsel->unit = info.unit;
  		evsel->scale = info.scale;
diff --cc tools/perf/util/pmu.c
index 49b96580235e,1c4d7b4e4fb5..000000000000
--- a/tools/perf/util/pmu.c
+++ b/tools/perf/util/pmu.c
@@@ -507,31 -485,48 +486,76 @@@ static struct cpu_map *__pmu_cpumask(co
  }
  
  /*
++<<<<<<< HEAD
 + *  PMU CORE devices have different name other than cpu in sysfs on some
 + *  platforms. looking for possible sysfs files to identify as core device.
 + */
 +static int is_pmu_core(const char *name)
 +{
 +	struct stat st;
 +	char path[PATH_MAX];
 +	const char *sysfs = sysfs__mountpoint();
 +
 +	if (!sysfs)
 +		return 0;
 +
 +	/* Look for cpu sysfs (x86 and others) */
 +	scnprintf(path, PATH_MAX, "%s/bus/event_source/devices/cpu", sysfs);
 +	if ((stat(path, &st) == 0) &&
 +			(strncmp(name, "cpu", strlen("cpu")) == 0))
 +		return 1;
 +
 +	/* Look for cpu sysfs (specific to arm) */
 +	scnprintf(path, PATH_MAX, "%s/bus/event_source/devices/%s/cpus",
 +				sysfs, name);
 +	if (stat(path, &st) == 0)
 +		return 1;
 +
 +	return 0;
++=======
+  * Uncore PMUs have a "cpumask" file under sysfs. CPU PMUs (e.g. on arm/arm64)
+  * may have a "cpus" file.
+  */
+ #define CPUS_TEMPLATE_UNCORE	"%s/bus/event_source/devices/%s/cpumask"
+ #define CPUS_TEMPLATE_CPU	"%s/bus/event_source/devices/%s/cpus"
+ 
+ static struct cpu_map *pmu_cpumask(const char *name)
+ {
+ 	char path[PATH_MAX];
+ 	struct cpu_map *cpus;
+ 	const char *sysfs = sysfs__mountpoint();
+ 	const char *templates[] = {
+ 		CPUS_TEMPLATE_UNCORE,
+ 		CPUS_TEMPLATE_CPU,
+ 		NULL
+ 	};
+ 	const char **template;
+ 
+ 	if (!sysfs)
+ 		return NULL;
+ 
+ 	for (template = templates; *template; template++) {
+ 		snprintf(path, PATH_MAX, *template, sysfs, name);
+ 		cpus = __pmu_cpumask(path);
+ 		if (cpus)
+ 			return cpus;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static bool pmu_is_uncore(const char *name)
+ {
+ 	char path[PATH_MAX];
+ 	struct cpu_map *cpus;
+ 	const char *sysfs = sysfs__mountpoint();
+ 
+ 	snprintf(path, PATH_MAX, CPUS_TEMPLATE_UNCORE, sysfs, name);
+ 	cpus = __pmu_cpumask(path);
+ 	cpu_map__put(cpus);
+ 
+ 	return !!cpus;
++>>>>>>> 66ec11919a0f (perf pmu: Unbreak perf record for arm/arm64 with events with explicit PMU)
  }
  
  /*
* Unmerged path tools/perf/util/parse-events.c
* Unmerged path tools/perf/util/pmu.c
diff --git a/tools/perf/util/pmu.h b/tools/perf/util/pmu.h
index 3aaccfcc468d..6053be135e86 100644
--- a/tools/perf/util/pmu.h
+++ b/tools/perf/util/pmu.h
@@ -21,6 +21,7 @@ struct perf_pmu {
 	char *name;
 	__u32 type;
 	bool selectable;
+	bool is_uncore;
 	struct perf_event_attr *default_config;
 	struct cpu_map *cpus;
 	struct list_head format;  /* HEAD struct perf_pmu_format -> list */
