blk-mq: fix sysfs inflight counter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Omar Sandoval <osandov@fb.com>
commit bf0ddaba65ddbb2715af97041da8e7a45b2d8628
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/bf0ddaba.failed

When the blk-mq inflight implementation was added, /proc/diskstats was
converted to use it, but /sys/block/$dev/inflight was not. Fix it by
adding another helper to count in-flight requests by data direction.

Fixes: f299b7c7a9de ("blk-mq: provide internal in-flight variant")
	Signed-off-by: Omar Sandoval <osandov@fb.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit bf0ddaba65ddbb2715af97041da8e7a45b2d8628)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
#	block/blk-mq.h
#	block/genhd.c
#	include/linux/genhd.h
diff --cc block/blk-mq.c
index a8e551c0c631,9ce9cac16c3f..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -65,6 -84,56 +65,59 @@@ static void blk_mq_hctx_clear_pending(s
  	sbitmap_clear_bit(&hctx->ctx_map, ctx->index_hw);
  }
  
++<<<<<<< HEAD
++=======
+ struct mq_inflight {
+ 	struct hd_struct *part;
+ 	unsigned int *inflight;
+ };
+ 
+ static void blk_mq_check_inflight(struct blk_mq_hw_ctx *hctx,
+ 				  struct request *rq, void *priv,
+ 				  bool reserved)
+ {
+ 	struct mq_inflight *mi = priv;
+ 
+ 	/*
+ 	 * index[0] counts the specific partition that was asked for. index[1]
+ 	 * counts the ones that are active on the whole device, so increment
+ 	 * that if mi->part is indeed a partition, and not a whole device.
+ 	 */
+ 	if (rq->part == mi->part)
+ 		mi->inflight[0]++;
+ 	if (mi->part->partno)
+ 		mi->inflight[1]++;
+ }
+ 
+ void blk_mq_in_flight(struct request_queue *q, struct hd_struct *part,
+ 		      unsigned int inflight[2])
+ {
+ 	struct mq_inflight mi = { .part = part, .inflight = inflight, };
+ 
+ 	inflight[0] = inflight[1] = 0;
+ 	blk_mq_queue_tag_busy_iter(q, blk_mq_check_inflight, &mi);
+ }
+ 
+ static void blk_mq_check_inflight_rw(struct blk_mq_hw_ctx *hctx,
+ 				     struct request *rq, void *priv,
+ 				     bool reserved)
+ {
+ 	struct mq_inflight *mi = priv;
+ 
+ 	if (rq->part == mi->part)
+ 		mi->inflight[rq_data_dir(rq)]++;
+ }
+ 
+ void blk_mq_in_flight_rw(struct request_queue *q, struct hd_struct *part,
+ 			 unsigned int inflight[2])
+ {
+ 	struct mq_inflight mi = { .part = part, .inflight = inflight, };
+ 
+ 	inflight[0] = inflight[1] = 0;
+ 	blk_mq_queue_tag_busy_iter(q, blk_mq_check_inflight_rw, &mi);
+ }
+ 
++>>>>>>> bf0ddaba65dd (blk-mq: fix sysfs inflight counter)
  void blk_freeze_queue_start(struct request_queue *q)
  {
  	int freeze_depth;
diff --cc block/blk-mq.h
index a1edc1df16f2,e1bb420dc5d6..000000000000
--- a/block/blk-mq.h
+++ b/block/blk-mq.h
@@@ -160,6 -187,11 +160,14 @@@ static inline bool blk_mq_hw_queue_mapp
  	return hctx->nr_ctx && hctx->tags;
  }
  
++<<<<<<< HEAD
++=======
+ void blk_mq_in_flight(struct request_queue *q, struct hd_struct *part,
+ 		      unsigned int inflight[2]);
+ void blk_mq_in_flight_rw(struct request_queue *q, struct hd_struct *part,
+ 			 unsigned int inflight[2]);
+ 
++>>>>>>> bf0ddaba65dd (blk-mq: fix sysfs inflight counter)
  static inline void blk_mq_put_dispatch_budget(struct blk_mq_hw_ctx *hctx)
  {
  	struct request_queue *q = hctx->queue;
diff --cc block/genhd.c
index efc72b7773e8,c4513fe1adda..000000000000
--- a/block/genhd.c
+++ b/block/genhd.c
@@@ -44,6 -45,64 +44,67 @@@ static void disk_add_events(struct gend
  static void disk_del_events(struct gendisk *disk);
  static void disk_release_events(struct gendisk *disk);
  
++<<<<<<< HEAD
++=======
+ void part_inc_in_flight(struct request_queue *q, struct hd_struct *part, int rw)
+ {
+ 	if (q->mq_ops)
+ 		return;
+ 
+ 	atomic_inc(&part->in_flight[rw]);
+ 	if (part->partno)
+ 		atomic_inc(&part_to_disk(part)->part0.in_flight[rw]);
+ }
+ 
+ void part_dec_in_flight(struct request_queue *q, struct hd_struct *part, int rw)
+ {
+ 	if (q->mq_ops)
+ 		return;
+ 
+ 	atomic_dec(&part->in_flight[rw]);
+ 	if (part->partno)
+ 		atomic_dec(&part_to_disk(part)->part0.in_flight[rw]);
+ }
+ 
+ void part_in_flight(struct request_queue *q, struct hd_struct *part,
+ 		    unsigned int inflight[2])
+ {
+ 	if (q->mq_ops) {
+ 		blk_mq_in_flight(q, part, inflight);
+ 		return;
+ 	}
+ 
+ 	inflight[0] = atomic_read(&part->in_flight[0]) +
+ 			atomic_read(&part->in_flight[1]);
+ 	if (part->partno) {
+ 		part = &part_to_disk(part)->part0;
+ 		inflight[1] = atomic_read(&part->in_flight[0]) +
+ 				atomic_read(&part->in_flight[1]);
+ 	}
+ }
+ 
+ void part_in_flight_rw(struct request_queue *q, struct hd_struct *part,
+ 		       unsigned int inflight[2])
+ {
+ 	if (q->mq_ops) {
+ 		blk_mq_in_flight_rw(q, part, inflight);
+ 		return;
+ 	}
+ 
+ 	inflight[0] = atomic_read(&part->in_flight[0]);
+ 	inflight[1] = atomic_read(&part->in_flight[1]);
+ }
+ 
+ struct hd_struct *__disk_get_part(struct gendisk *disk, int partno)
+ {
+ 	struct disk_part_tbl *ptbl = rcu_dereference(disk->part_tbl);
+ 
+ 	if (unlikely(partno < 0 || partno >= ptbl->len))
+ 		return NULL;
+ 	return rcu_dereference(ptbl->part[partno]);
+ }
+ 
++>>>>>>> bf0ddaba65dd (blk-mq: fix sysfs inflight counter)
  /**
   * disk_get_part - get partition
   * @disk: disk to look partition from
diff --cc include/linux/genhd.h
index 4292be9dbdf8,6cb8a5789668..000000000000
--- a/include/linux/genhd.h
+++ b/include/linux/genhd.h
@@@ -382,24 -367,14 +382,35 @@@ static inline void free_part_stats(stru
  #define part_stat_sub(cpu, gendiskp, field, subnd)			\
  	part_stat_add(cpu, gendiskp, field, -subnd)
  
++<<<<<<< HEAD
 +static inline void part_inc_in_flight(struct hd_struct *part, int rw)
 +{
 +	atomic_inc(&part->in_flight[rw]);
 +	if (part->partno)
 +		atomic_inc(&part_to_disk(part)->part0.in_flight[rw]);
 +}
 +
 +static inline void part_dec_in_flight(struct hd_struct *part, int rw)
 +{
 +	atomic_dec(&part->in_flight[rw]);
 +	if (part->partno)
 +		atomic_dec(&part_to_disk(part)->part0.in_flight[rw]);
 +}
 +
 +static inline int part_in_flight(struct hd_struct *part)
 +{
 +	return atomic_read(&part->in_flight[0]) + atomic_read(&part->in_flight[1]);
 +}
++=======
+ void part_in_flight(struct request_queue *q, struct hd_struct *part,
+ 		    unsigned int inflight[2]);
+ void part_in_flight_rw(struct request_queue *q, struct hd_struct *part,
+ 		       unsigned int inflight[2]);
+ void part_dec_in_flight(struct request_queue *q, struct hd_struct *part,
+ 			int rw);
+ void part_inc_in_flight(struct request_queue *q, struct hd_struct *part,
+ 			int rw);
++>>>>>>> bf0ddaba65dd (blk-mq: fix sysfs inflight counter)
  
  static inline struct partition_meta_info *alloc_part_info(struct gendisk *disk)
  {
* Unmerged path block/blk-mq.c
* Unmerged path block/blk-mq.h
* Unmerged path block/genhd.c
diff --git a/block/partition-generic.c b/block/partition-generic.c
index 195b56c1be27..0c91659683fb 100644
--- a/block/partition-generic.c
+++ b/block/partition-generic.c
@@ -135,13 +135,15 @@ ssize_t part_stat_show(struct device *dev,
 		jiffies_to_msecs(part_stat_read(p, time_in_queue)));
 }
 
-ssize_t part_inflight_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
+ssize_t part_inflight_show(struct device *dev, struct device_attribute *attr,
+			   char *buf)
 {
 	struct hd_struct *p = dev_to_part(dev);
+	struct request_queue *q = part_to_disk(p)->queue;
+	unsigned int inflight[2];
 
-	return sprintf(buf, "%8u %8u\n", atomic_read(&p->in_flight[0]),
-		atomic_read(&p->in_flight[1]));
+	part_in_flight_rw(q, p, inflight);
+	return sprintf(buf, "%8u %8u\n", inflight[0], inflight[1]);
 }
 
 #ifdef CONFIG_FAIL_MAKE_REQUEST
* Unmerged path include/linux/genhd.h
