mmc: sdhci: Let drivers decide whether to use mmc_retune_needed() with pm

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] sdhci: Let drivers decide whether to use mmc_retune_needed() with pm (Gopal Tiwari) [1549495]
Rebuild_FUZZ: 96.45%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit d38dcad4e7b48f3d68d5d058f8f4f52a99862e6e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d38dcad4.failed

Devices might save and restore tuning values so that re-tuning might not be
needed after a pm transition.  Let drivers decide by pushing the
mmc_retune_needed() logic down to them.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Tested-by: Ludovic Desroches <ludovic.desroches@microchip.com>
(cherry picked from commit d38dcad4e7b48f3d68d5d058f8f4f52a99862e6e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci-esdhc-imx.c
#	drivers/mmc/host/sdhci-of-arasan.c
#	drivers/mmc/host/sdhci-of-at91.c
#	drivers/mmc/host/sdhci-of-esdhc.c
#	drivers/mmc/host/sdhci-pxav3.c
#	drivers/mmc/host/sdhci-s3c.c
#	drivers/mmc/host/sdhci-st.c
diff --cc drivers/mmc/host/sdhci-esdhc-imx.c
index d5f0d59e1310,abad67aeabdd..000000000000
--- a/drivers/mmc/host/sdhci-esdhc-imx.c
+++ b/drivers/mmc/host/sdhci-esdhc-imx.c
@@@ -659,6 -1318,72 +659,75 @@@ static int sdhci_esdhc_imx_remove(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PM_SLEEP
+ static int sdhci_esdhc_suspend(struct device *dev)
+ {
+ 	struct sdhci_host *host = dev_get_drvdata(dev);
+ 
+ 	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
+ 		mmc_retune_needed(host->mmc);
+ 
+ 	return sdhci_suspend_host(host);
+ }
+ 
+ static int sdhci_esdhc_resume(struct device *dev)
+ {
+ 	struct sdhci_host *host = dev_get_drvdata(dev);
+ 
+ 	/* re-initialize hw state in case it's lost in low power mode */
+ 	sdhci_esdhc_imx_hwinit(host);
+ 
+ 	return sdhci_resume_host(host);
+ }
+ #endif
+ 
+ #ifdef CONFIG_PM
+ static int sdhci_esdhc_runtime_suspend(struct device *dev)
+ {
+ 	struct sdhci_host *host = dev_get_drvdata(dev);
+ 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+ 	struct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);
+ 	int ret;
+ 
+ 	ret = sdhci_runtime_suspend_host(host);
+ 
+ 	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
+ 		mmc_retune_needed(host->mmc);
+ 
+ 	if (!sdhci_sdio_irq_enabled(host)) {
+ 		clk_disable_unprepare(imx_data->clk_per);
+ 		clk_disable_unprepare(imx_data->clk_ipg);
+ 	}
+ 	clk_disable_unprepare(imx_data->clk_ahb);
+ 
+ 	return ret;
+ }
+ 
+ static int sdhci_esdhc_runtime_resume(struct device *dev)
+ {
+ 	struct sdhci_host *host = dev_get_drvdata(dev);
+ 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+ 	struct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);
+ 
+ 	if (!sdhci_sdio_irq_enabled(host)) {
+ 		clk_prepare_enable(imx_data->clk_per);
+ 		clk_prepare_enable(imx_data->clk_ipg);
+ 	}
+ 	clk_prepare_enable(imx_data->clk_ahb);
+ 
+ 	return sdhci_runtime_resume_host(host);
+ }
+ #endif
+ 
+ static const struct dev_pm_ops sdhci_esdhc_pmops = {
+ 	SET_SYSTEM_SLEEP_PM_OPS(sdhci_esdhc_suspend, sdhci_esdhc_resume)
+ 	SET_RUNTIME_PM_OPS(sdhci_esdhc_runtime_suspend,
+ 				sdhci_esdhc_runtime_resume, NULL)
+ };
+ 
++>>>>>>> d38dcad4e7b4 (mmc: sdhci: Let drivers decide whether to use mmc_retune_needed() with pm)
  static struct platform_driver sdhci_esdhc_imx_driver = {
  	.driver		= {
  		.name	= "sdhci-esdhc-imx",
diff --cc drivers/mmc/host/sdhci-of-esdhc.c
index 5e68adc2461e,ff37e7459386..000000000000
--- a/drivers/mmc/host/sdhci-of-esdhc.c
+++ b/drivers/mmc/host/sdhci-of-esdhc.c
@@@ -199,21 -451,100 +199,32 @@@ static void esdhc_of_set_clock(struct s
  			clock -= 5000000;
  	}
  
 -	temp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);
 -	temp &= ~(ESDHC_CLOCK_SDCLKEN | ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN |
 -		  ESDHC_CLOCK_PEREN | ESDHC_CLOCK_MASK);
 -	sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
 -
 -	while (host->max_clk / pre_div / 16 > clock && pre_div < 256)
 -		pre_div *= 2;
 -
 -	while (host->max_clk / pre_div / div > clock && div < 16)
 -		div++;
 -
 -	dev_dbg(mmc_dev(host->mmc), "desired SD clock: %d, actual: %d\n",
 -		clock, host->max_clk / pre_div / div);
 -	host->mmc->actual_clock = host->max_clk / pre_div / div;
 -	pre_div >>= 1;
 -	div--;
 -
 -	temp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);
 -	temp |= (ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN | ESDHC_CLOCK_PEREN
 -		| (div << ESDHC_DIVIDER_SHIFT)
 -		| (pre_div << ESDHC_PREDIV_SHIFT));
 -	sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
 -
 -	/* Wait max 20 ms */
 -	timeout = 20;
 -	while (!(sdhci_readl(host, ESDHC_PRSSTAT) & ESDHC_CLOCK_STABLE)) {
 -		if (timeout == 0) {
 -			pr_err("%s: Internal clock never stabilised.\n",
 -				mmc_hostname(host->mmc));
 -			return;
 -		}
 -		timeout--;
 -		mdelay(1);
 -	}
 -
 -	temp |= ESDHC_CLOCK_SDCLKEN;
 -	sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
 -}
 -
 -static void esdhc_pltfm_set_bus_width(struct sdhci_host *host, int width)
 -{
 -	u32 ctrl;
 -
 -	ctrl = sdhci_readl(host, ESDHC_PROCTL);
 -	ctrl &= (~ESDHC_CTRL_BUSWIDTH_MASK);
 -	switch (width) {
 -	case MMC_BUS_WIDTH_8:
 -		ctrl |= ESDHC_CTRL_8BITBUS;
 -		break;
 -
 -	case MMC_BUS_WIDTH_4:
 -		ctrl |= ESDHC_CTRL_4BITBUS;
 -		break;
 -
 -	default:
 -		break;
 -	}
 -
 -	sdhci_writel(host, ctrl, ESDHC_PROCTL);
 -}
 -
 -static void esdhc_reset(struct sdhci_host *host, u8 mask)
 -{
 -	sdhci_reset(host, mask);
 -
 -	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
 -	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
 +	/* Set the clock */
 +	esdhc_set_clock(host, clock);
  }
  
 -#ifdef CONFIG_PM_SLEEP
 +#ifdef CONFIG_PM
  static u32 esdhc_proctl;
 -static int esdhc_of_suspend(struct device *dev)
 +static void esdhc_of_suspend(struct sdhci_host *host)
  {
++<<<<<<< HEAD
 +	esdhc_proctl = sdhci_be32bs_readl(host, SDHCI_HOST_CONTROL);
++=======
+ 	struct sdhci_host *host = dev_get_drvdata(dev);
+ 
+ 	esdhc_proctl = sdhci_readl(host, SDHCI_HOST_CONTROL);
+ 
+ 	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
+ 		mmc_retune_needed(host->mmc);
+ 
+ 	return sdhci_suspend_host(host);
++>>>>>>> d38dcad4e7b4 (mmc: sdhci: Let drivers decide whether to use mmc_retune_needed() with pm)
  }
  
 -static int esdhc_of_resume(struct device *dev)
 +static void esdhc_of_resume(struct sdhci_host *host)
  {
 -	struct sdhci_host *host = dev_get_drvdata(dev);
 -	int ret = sdhci_resume_host(host);
 -
 -	if (ret == 0) {
 -		/* Isn't this already done by sdhci_resume_host() ? --rmk */
 -		esdhc_of_enable_dma(host);
 -		sdhci_writel(host, esdhc_proctl, SDHCI_HOST_CONTROL);
 -	}
 -	return ret;
 +	esdhc_of_enable_dma(host);
 +	sdhci_be32bs_writel(host, esdhc_proctl, SDHCI_HOST_CONTROL);
  }
  #endif
  
diff --cc drivers/mmc/host/sdhci-pxav3.c
index 1ae358e0662d,22ed90433d29..000000000000
--- a/drivers/mmc/host/sdhci-pxav3.c
+++ b/drivers/mmc/host/sdhci-pxav3.c
@@@ -377,15 -555,19 +379,24 @@@ static int sdhci_pxav3_runtime_suspend(
  {
  	struct sdhci_host *host = dev_get_drvdata(dev);
  	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 -	struct sdhci_pxa *pxa = sdhci_pltfm_priv(pltfm_host);
 -	int ret;
 +	unsigned long flags;
  
 -	ret = sdhci_runtime_suspend_host(host);
 -	if (ret)
 -		return ret;
 +	if (pltfm_host->clk) {
 +		spin_lock_irqsave(&host->lock, flags);
 +		host->runtime_suspended = true;
 +		spin_unlock_irqrestore(&host->lock, flags);
  
++<<<<<<< HEAD
 +		clk_disable_unprepare(pltfm_host->clk);
 +	}
++=======
+ 	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
+ 		mmc_retune_needed(host->mmc);
+ 
+ 	clk_disable_unprepare(pxa->clk_io);
+ 	if (!IS_ERR(pxa->clk_core))
+ 		clk_disable_unprepare(pxa->clk_core);
++>>>>>>> d38dcad4e7b4 (mmc: sdhci: Let drivers decide whether to use mmc_retune_needed() with pm)
  
  	return 0;
  }
diff --cc drivers/mmc/host/sdhci-s3c.c
index c6f6246a4933,d02284da2ec6..000000000000
--- a/drivers/mmc/host/sdhci-s3c.c
+++ b/drivers/mmc/host/sdhci-s3c.c
@@@ -776,7 -767,11 +779,15 @@@ static int sdhci_s3c_runtime_suspend(st
  
  	ret = sdhci_runtime_suspend_host(host);
  
++<<<<<<< HEAD
 +	clk_disable_unprepare(ourhost->clk_bus[ourhost->cur_clk]);
++=======
+ 	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
+ 		mmc_retune_needed(host->mmc);
+ 
+ 	if (ourhost->cur_clk >= 0)
+ 		clk_disable_unprepare(ourhost->clk_bus[ourhost->cur_clk]);
++>>>>>>> d38dcad4e7b4 (mmc: sdhci: Let drivers decide whether to use mmc_retune_needed() with pm)
  	clk_disable_unprepare(busclk);
  	return ret;
  }
* Unmerged path drivers/mmc/host/sdhci-of-arasan.c
* Unmerged path drivers/mmc/host/sdhci-of-at91.c
* Unmerged path drivers/mmc/host/sdhci-st.c
diff --git a/drivers/mmc/host/sdhci-acpi.c b/drivers/mmc/host/sdhci-acpi.c
index 7d6aeb832e67..bcff4c0fe01e 100644
--- a/drivers/mmc/host/sdhci-acpi.c
+++ b/drivers/mmc/host/sdhci-acpi.c
@@ -524,8 +524,12 @@ static int sdhci_acpi_remove(struct platform_device *pdev)
 static int sdhci_acpi_suspend(struct device *dev)
 {
 	struct sdhci_acpi_host *c = dev_get_drvdata(dev);
+	struct sdhci_host *host = c->host;
 
-	return sdhci_suspend_host(c->host);
+	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
+		mmc_retune_needed(host->mmc);
+
+	return sdhci_suspend_host(host);
 }
 
 static int sdhci_acpi_resume(struct device *dev)
@@ -544,8 +548,12 @@ static int sdhci_acpi_resume(struct device *dev)
 static int sdhci_acpi_runtime_suspend(struct device *dev)
 {
 	struct sdhci_acpi_host *c = dev_get_drvdata(dev);
+	struct sdhci_host *host = c->host;
+
+	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
+		mmc_retune_needed(host->mmc);
 
-	return sdhci_runtime_suspend_host(c->host);
+	return sdhci_runtime_suspend_host(host);
 }
 
 static int sdhci_acpi_runtime_resume(struct device *dev)
diff --git a/drivers/mmc/host/sdhci-brcmstb.c b/drivers/mmc/host/sdhci-brcmstb.c
index 159f6f64c68e..242c5dc7a81e 100644
--- a/drivers/mmc/host/sdhci-brcmstb.c
+++ b/drivers/mmc/host/sdhci-brcmstb.c
@@ -29,6 +29,9 @@ static int sdhci_brcmstb_suspend(struct device *dev)
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	int res;
 
+	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
+		mmc_retune_needed(host->mmc);
+
 	res = sdhci_suspend_host(host);
 	if (res)
 		return res;
* Unmerged path drivers/mmc/host/sdhci-esdhc-imx.c
* Unmerged path drivers/mmc/host/sdhci-of-arasan.c
* Unmerged path drivers/mmc/host/sdhci-of-at91.c
* Unmerged path drivers/mmc/host/sdhci-of-esdhc.c
diff --git a/drivers/mmc/host/sdhci-pci-core.c b/drivers/mmc/host/sdhci-pci-core.c
index cdfda9db34e1..13abf9c07171 100644
--- a/drivers/mmc/host/sdhci-pci-core.c
+++ b/drivers/mmc/host/sdhci-pci-core.c
@@ -1214,6 +1214,7 @@ static int sdhci_pci_suspend(struct device *dev)
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct sdhci_pci_chip *chip;
 	struct sdhci_pci_slot *slot;
+	struct sdhci_host *host;
 	mmc_pm_flag_t slot_pm_flags;
 	mmc_pm_flag_t pm_flags = 0;
 	int i, ret;
@@ -1227,14 +1228,19 @@ static int sdhci_pci_suspend(struct device *dev)
 		if (!slot)
 			continue;
 
-		ret = sdhci_suspend_host(slot->host);
+		host = slot->host;
+
+		if (chip->pm_retune && host->tuning_mode != SDHCI_TUNING_MODE_3)
+			mmc_retune_needed(host->mmc);
+
+		ret = sdhci_suspend_host(host);
 
 		if (ret)
 			goto err_pci_suspend;
 
-		slot_pm_flags = slot->host->mmc->pm_flags;
+		slot_pm_flags = host->mmc->pm_flags;
 		if (slot_pm_flags & MMC_PM_WAKE_SDIO_IRQ)
-			sdhci_enable_irq_wakeups(slot->host);
+			sdhci_enable_irq_wakeups(host);
 
 		pm_flags |= slot_pm_flags;
 	}
@@ -1298,6 +1304,7 @@ static int sdhci_pci_runtime_suspend(struct device *dev)
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct sdhci_pci_chip *chip;
 	struct sdhci_pci_slot *slot;
+	struct sdhci_host *host;
 	int i, ret;
 
 	chip = pci_get_drvdata(pdev);
@@ -1309,10 +1316,15 @@ static int sdhci_pci_runtime_suspend(struct device *dev)
 		if (!slot)
 			continue;
 
-		ret = sdhci_runtime_suspend_host(slot->host);
+		host = slot->host;
 
+		ret = sdhci_runtime_suspend_host(host);
 		if (ret)
 			goto err_pci_runtime_suspend;
+
+		if (chip->rpm_retune &&
+		    host->tuning_mode != SDHCI_TUNING_MODE_3)
+			mmc_retune_needed(host->mmc);
 	}
 
 	if (chip->fixes && chip->fixes->suspend) {
@@ -1603,6 +1615,8 @@ static int sdhci_pci_probe(struct pci_dev *pdev,
 		chip->allow_runtime_pm = chip->fixes->allow_runtime_pm;
 	}
 	chip->num_slots = slots;
+	chip->pm_retune = true;
+	chip->rpm_retune = true;
 
 	pci_set_drvdata(pdev, chip);
 
diff --git a/drivers/mmc/host/sdhci-pci.h b/drivers/mmc/host/sdhci-pci.h
index a46affcbb2fd..6a955242d907 100644
--- a/drivers/mmc/host/sdhci-pci.h
+++ b/drivers/mmc/host/sdhci-pci.h
@@ -141,6 +141,8 @@ struct sdhci_pci_chip {
 	unsigned int		quirks;
 	unsigned int		quirks2;
 	bool			allow_runtime_pm;
+	bool			pm_retune;
+	bool			rpm_retune;
 	const struct sdhci_pci_fixes *fixes;
 
 	int			num_slots;	/* Slots on controller */
diff --git a/drivers/mmc/host/sdhci-pltfm.c b/drivers/mmc/host/sdhci-pltfm.c
index ad49bfaf5bf8..e090d8c42ddb 100644
--- a/drivers/mmc/host/sdhci-pltfm.c
+++ b/drivers/mmc/host/sdhci-pltfm.c
@@ -213,6 +213,9 @@ static int sdhci_pltfm_suspend(struct device *dev)
 {
 	struct sdhci_host *host = dev_get_drvdata(dev);
 
+	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
+		mmc_retune_needed(host->mmc);
+
 	return sdhci_suspend_host(host);
 }
 
* Unmerged path drivers/mmc/host/sdhci-pxav3.c
* Unmerged path drivers/mmc/host/sdhci-s3c.c
diff --git a/drivers/mmc/host/sdhci-sirf.c b/drivers/mmc/host/sdhci-sirf.c
index 09805af0526d..bdb96ef07fbd 100644
--- a/drivers/mmc/host/sdhci-sirf.c
+++ b/drivers/mmc/host/sdhci-sirf.c
@@ -139,6 +139,9 @@ static int sdhci_sirf_suspend(struct device *dev)
 	struct sdhci_sirf_priv *priv = pltfm_host->priv;
 	int ret;
 
+	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
+		mmc_retune_needed(host->mmc);
+
 	ret = sdhci_suspend_host(host);
 	if (ret)
 		return ret;
diff --git a/drivers/mmc/host/sdhci-spear.c b/drivers/mmc/host/sdhci-spear.c
index 7ae5b3ae7bad..3637616f7eef 100644
--- a/drivers/mmc/host/sdhci-spear.c
+++ b/drivers/mmc/host/sdhci-spear.c
@@ -298,6 +298,9 @@ static int sdhci_suspend(struct device *dev)
 	struct spear_sdhci *sdhci = dev_get_platdata(dev);
 	int ret;
 
+	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
+		mmc_retune_needed(host->mmc);
+
 	ret = sdhci_suspend_host(host);
 	if (!ret)
 		clk_disable(sdhci->clk);
* Unmerged path drivers/mmc/host/sdhci-st.c
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 777c82efce1d..105f4448145d 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -2857,8 +2857,6 @@ int sdhci_suspend_host(struct sdhci_host *host)
 	sdhci_disable_card_detection(host);
 
 	mmc_retune_timer_stop(host->mmc);
-	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
-		mmc_retune_needed(host->mmc);
 
 	if (!device_may_wakeup(mmc_dev(host->mmc))) {
 		host->ier = 0;
@@ -2919,8 +2917,6 @@ int sdhci_runtime_suspend_host(struct sdhci_host *host)
 	unsigned long flags;
 
 	mmc_retune_timer_stop(host->mmc);
-	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
-		mmc_retune_needed(host->mmc);
 
 	spin_lock_irqsave(&host->lock, flags);
 	host->ier &= SDHCI_INT_CARD_INT;
