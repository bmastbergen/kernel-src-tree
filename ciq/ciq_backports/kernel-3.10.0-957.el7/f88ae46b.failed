xfs: glean crc status from mp not flags in xfs_btree_init_block_int

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Eric Sandeen <sandeen@sandeen.net>
commit f88ae46b09e93ef07ac9efaf85df62adb5ba58e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f88ae46b.failed

xfs_btree_init_block_int() can determine whether crcs are
in effect without the passed-in XFS_BTREE_CRC_BLOCKS flag;
the mp argument allows us to determine this from the
superblock.  Remove the flag from callers, and use
xfs_sb_version_hascrc(&mp->m_sb) internally instead.

This removes one difference between the if & else cases
in the callers.

	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit f88ae46b09e93ef07ac9efaf85df62adb5ba58e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_fsops.c
diff --cc fs/xfs/xfs_fsops.c
index 4c191d2194e8,21e3cdbaebbc..000000000000
--- a/fs/xfs/xfs_fsops.c
+++ b/fs/xfs/xfs_fsops.c
@@@ -379,6 -399,83 +379,86 @@@ xfs_growfs_data_private
  		if (error)
  			goto error0;
  
++<<<<<<< HEAD
++=======
+ 		/* RMAP btree root block */
+ 		if (xfs_sb_version_hasrmapbt(&mp->m_sb)) {
+ 			struct xfs_rmap_rec	*rrec;
+ 			struct xfs_btree_block	*block;
+ 
+ 			bp = xfs_growfs_get_hdr_buf(mp,
+ 				XFS_AGB_TO_DADDR(mp, agno, XFS_RMAP_BLOCK(mp)),
+ 				BTOBB(mp->m_sb.sb_blocksize), 0,
+ 				&xfs_rmapbt_buf_ops);
+ 			if (!bp) {
+ 				error = -ENOMEM;
+ 				goto error0;
+ 			}
+ 
+ 			xfs_btree_init_block(mp, bp, XFS_RMAP_CRC_MAGIC, 0, 0,
+ 						agno, 0);
+ 			block = XFS_BUF_TO_BLOCK(bp);
+ 
+ 
+ 			/*
+ 			 * mark the AG header regions as static metadata The BNO
+ 			 * btree block is the first block after the headers, so
+ 			 * it's location defines the size of region the static
+ 			 * metadata consumes.
+ 			 *
+ 			 * Note: unlike mkfs, we never have to account for log
+ 			 * space when growing the data regions
+ 			 */
+ 			rrec = XFS_RMAP_REC_ADDR(block, 1);
+ 			rrec->rm_startblock = 0;
+ 			rrec->rm_blockcount = cpu_to_be32(XFS_BNO_BLOCK(mp));
+ 			rrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_FS);
+ 			rrec->rm_offset = 0;
+ 			be16_add_cpu(&block->bb_numrecs, 1);
+ 
+ 			/* account freespace btree root blocks */
+ 			rrec = XFS_RMAP_REC_ADDR(block, 2);
+ 			rrec->rm_startblock = cpu_to_be32(XFS_BNO_BLOCK(mp));
+ 			rrec->rm_blockcount = cpu_to_be32(2);
+ 			rrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_AG);
+ 			rrec->rm_offset = 0;
+ 			be16_add_cpu(&block->bb_numrecs, 1);
+ 
+ 			/* account inode btree root blocks */
+ 			rrec = XFS_RMAP_REC_ADDR(block, 3);
+ 			rrec->rm_startblock = cpu_to_be32(XFS_IBT_BLOCK(mp));
+ 			rrec->rm_blockcount = cpu_to_be32(XFS_RMAP_BLOCK(mp) -
+ 							XFS_IBT_BLOCK(mp));
+ 			rrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_INOBT);
+ 			rrec->rm_offset = 0;
+ 			be16_add_cpu(&block->bb_numrecs, 1);
+ 
+ 			/* account for rmap btree root */
+ 			rrec = XFS_RMAP_REC_ADDR(block, 4);
+ 			rrec->rm_startblock = cpu_to_be32(XFS_RMAP_BLOCK(mp));
+ 			rrec->rm_blockcount = cpu_to_be32(1);
+ 			rrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_AG);
+ 			rrec->rm_offset = 0;
+ 			be16_add_cpu(&block->bb_numrecs, 1);
+ 
+ 			/* account for refc btree root */
+ 			if (xfs_sb_version_hasreflink(&mp->m_sb)) {
+ 				rrec = XFS_RMAP_REC_ADDR(block, 5);
+ 				rrec->rm_startblock = cpu_to_be32(
+ 						xfs_refc_block(mp));
+ 				rrec->rm_blockcount = cpu_to_be32(1);
+ 				rrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_REFC);
+ 				rrec->rm_offset = 0;
+ 				be16_add_cpu(&block->bb_numrecs, 1);
+ 			}
+ 
+ 			error = xfs_bwrite(bp);
+ 			xfs_buf_relse(bp);
+ 			if (error)
+ 				goto error0;
+ 		}
+ 
++>>>>>>> f88ae46b09e9 (xfs: glean crc status from mp not flags in xfs_btree_init_block_int)
  		/*
  		 * INO btree root block
  		 */
@@@ -430,6 -526,27 +509,30 @@@
  				goto error0;
  		}
  
++<<<<<<< HEAD
++=======
+ 		/*
+ 		 * refcount btree root block
+ 		 */
+ 		if (xfs_sb_version_hasreflink(&mp->m_sb)) {
+ 			bp = xfs_growfs_get_hdr_buf(mp,
+ 				XFS_AGB_TO_DADDR(mp, agno, xfs_refc_block(mp)),
+ 				BTOBB(mp->m_sb.sb_blocksize), 0,
+ 				&xfs_refcountbt_buf_ops);
+ 			if (!bp) {
+ 				error = -ENOMEM;
+ 				goto error0;
+ 			}
+ 
+ 			xfs_btree_init_block(mp, bp, XFS_REFC_CRC_MAGIC,
+ 					     0, 0, agno, 0);
+ 
+ 			error = xfs_bwrite(bp);
+ 			xfs_buf_relse(bp);
+ 			if (error)
+ 				goto error0;
+ 		}
++>>>>>>> f88ae46b09e9 (xfs: glean crc status from mp not flags in xfs_btree_init_block_int)
  	}
  	xfs_trans_agblocks_delta(tp, nfree);
  	/*
diff --git a/fs/xfs/libxfs/xfs_bmap.c b/fs/xfs/libxfs/xfs_bmap.c
index 9518d7cd5523..a84f33737863 100644
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@ -712,7 +712,7 @@ xfs_bmap_extents_to_btree(
 	if (xfs_sb_version_hascrc(&mp->m_sb))
 		xfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,
 				 XFS_BMAP_CRC_MAGIC, 1, 1, ip->i_ino,
-				 XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);
+				 XFS_BTREE_LONG_PTRS);
 	else
 		xfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,
 				 XFS_BMAP_MAGIC, 1, 1, ip->i_ino,
@@ -772,7 +772,7 @@ xfs_bmap_extents_to_btree(
 	if (xfs_sb_version_hascrc(&mp->m_sb))
 		xfs_btree_init_block_int(mp, ablock, abp->b_bn,
 				XFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,
-				XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);
+				XFS_BTREE_LONG_PTRS);
 	else
 		xfs_btree_init_block_int(mp, ablock, abp->b_bn,
 				XFS_BMAP_MAGIC, 0, 0, ip->i_ino,
diff --git a/fs/xfs/libxfs/xfs_bmap_btree.c b/fs/xfs/libxfs/xfs_bmap_btree.c
index 02efded83ebf..efde222e64e3 100644
--- a/fs/xfs/libxfs/xfs_bmap_btree.c
+++ b/fs/xfs/libxfs/xfs_bmap_btree.c
@@ -73,7 +73,7 @@ xfs_bmdr_to_bmbt(
 	if (xfs_sb_version_hascrc(&mp->m_sb))
 		xfs_btree_init_block_int(mp, rblock, XFS_BUF_DADDR_NULL,
 				 XFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,
-				 XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);
+				 XFS_BTREE_LONG_PTRS);
 	else
 		xfs_btree_init_block_int(mp, rblock, XFS_BUF_DADDR_NULL,
 				 XFS_BMAP_MAGIC, 0, 0, ip->i_ino,
diff --git a/fs/xfs/libxfs/xfs_btree.c b/fs/xfs/libxfs/xfs_btree.c
index 53c6db5531c1..2ebac238d49a 100644
--- a/fs/xfs/libxfs/xfs_btree.c
+++ b/fs/xfs/libxfs/xfs_btree.c
@@ -1021,6 +1021,8 @@ xfs_btree_init_block_int(
 	__u64			owner,
 	unsigned int		flags)
 {
+	int			crc = xfs_sb_version_hascrc(&mp->m_sb);
+
 	buf->bb_magic = cpu_to_be32(magic);
 	buf->bb_level = cpu_to_be16(level);
 	buf->bb_numrecs = cpu_to_be16(numrecs);
@@ -1028,7 +1030,7 @@ xfs_btree_init_block_int(
 	if (flags & XFS_BTREE_LONG_PTRS) {
 		buf->bb_u.l.bb_leftsib = cpu_to_be64(NULLFSBLOCK);
 		buf->bb_u.l.bb_rightsib = cpu_to_be64(NULLFSBLOCK);
-		if (flags & XFS_BTREE_CRC_BLOCKS) {
+		if (crc) {
 			buf->bb_u.l.bb_blkno = cpu_to_be64(blkno);
 			buf->bb_u.l.bb_owner = cpu_to_be64(owner);
 			uuid_copy(&buf->bb_u.l.bb_uuid, &mp->m_sb.sb_meta_uuid);
@@ -1041,7 +1043,7 @@ xfs_btree_init_block_int(
 
 		buf->bb_u.s.bb_leftsib = cpu_to_be32(NULLAGBLOCK);
 		buf->bb_u.s.bb_rightsib = cpu_to_be32(NULLAGBLOCK);
-		if (flags & XFS_BTREE_CRC_BLOCKS) {
+		if (crc) {
 			buf->bb_u.s.bb_blkno = cpu_to_be64(blkno);
 			buf->bb_u.s.bb_owner = cpu_to_be32(__owner);
 			uuid_copy(&buf->bb_u.s.bb_uuid, &mp->m_sb.sb_meta_uuid);
* Unmerged path fs/xfs/xfs_fsops.c
