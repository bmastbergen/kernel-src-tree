mmc: block: Remove code no longer needed after the switch to blk-mq

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] block: Remove code no longer needed after the switch to blk-mq (Gopal Tiwari) [1456570]
Rebuild_FUZZ: 96.12%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 0fbfd12518303e9b32ac9fd231439459eac848f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0fbfd125.failed

Remove code no longer needed after the switch to blk-mq.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Acked-by: Linus Walleij <linus.walleij@linaro.org>
	Tested-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 0fbfd12518303e9b32ac9fd231439459eac848f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/block.c
#	drivers/mmc/core/block.h
#	drivers/mmc/core/queue.c
#	drivers/mmc/core/queue.h
diff --cc drivers/mmc/core/block.c
index f1d3365980df,579fc0bd722f..000000000000
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@@ -860,7 -967,7 +860,11 @@@ static inline bool mmc_blk_in_tran_stat
  }
  
  static int card_busy_detect(struct mmc_card *card, unsigned int timeout_ms,
++<<<<<<< HEAD
 +		bool hw_busy_detect, struct request *req, bool *gen_err)
++=======
+ 			    struct request *req, u32 *resp_errs)
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  {
  	unsigned long timeout = jiffies + msecs_to_jiffies(timeout_ms);
  	int err = 0;
@@@ -876,17 -983,10 +880,12 @@@
  			return err;
  		}
  
 -		/* Accumulate any response error bits seen */
 -		if (resp_errs)
 -			*resp_errs |= status;
 +		if (status & R1_ERROR) {
 +			pr_err("%s: %s: error sending status cmd, status %#x\n",
 +				req->rq_disk->disk_name, __func__, status);
 +			*gen_err = true;
 +		}
  
- 		/* We may rely on the host hw to handle busy detection.*/
- 		if ((card->host->caps & MMC_CAP_WAIT_WHILE_BUSY) &&
- 			hw_busy_detect)
- 			break;
- 
  		/*
  		 * Timeout if the device never becomes ready for data and never
  		 * leaves the program state.
@@@ -908,223 -1008,6 +907,226 @@@
  	return err;
  }
  
++<<<<<<< HEAD
 +static int send_stop(struct mmc_card *card, unsigned int timeout_ms,
 +		struct request *req, bool *gen_err, u32 *stop_status)
 +{
 +	struct mmc_host *host = card->host;
 +	struct mmc_command cmd = {};
 +	int err;
 +	bool use_r1b_resp = rq_data_dir(req) == WRITE;
 +
 +	/*
 +	 * Normally we use R1B responses for WRITE, but in cases where the host
 +	 * has specified a max_busy_timeout we need to validate it. A failure
 +	 * means we need to prevent the host from doing hw busy detection, which
 +	 * is done by converting to a R1 response instead.
 +	 */
 +	if (host->max_busy_timeout && (timeout_ms > host->max_busy_timeout))
 +		use_r1b_resp = false;
 +
 +	cmd.opcode = MMC_STOP_TRANSMISSION;
 +	if (use_r1b_resp) {
 +		cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
 +		cmd.busy_timeout = timeout_ms;
 +	} else {
 +		cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
 +	}
 +
 +	err = mmc_wait_for_cmd(host, &cmd, 5);
 +	if (err)
 +		return err;
 +
 +	*stop_status = cmd.resp[0];
 +
 +	/* No need to check card status in case of READ. */
 +	if (rq_data_dir(req) == READ)
 +		return 0;
 +
 +	if (!mmc_host_is_spi(host) &&
 +		(*stop_status & R1_ERROR)) {
 +		pr_err("%s: %s: general error sending stop command, resp %#x\n",
 +			req->rq_disk->disk_name, __func__, *stop_status);
 +		*gen_err = true;
 +	}
 +
 +	return card_busy_detect(card, timeout_ms, use_r1b_resp, req, gen_err);
 +}
 +
 +#define ERR_NOMEDIUM	3
 +#define ERR_RETRY	2
 +#define ERR_ABORT	1
 +#define ERR_CONTINUE	0
 +
 +static int mmc_blk_cmd_error(struct request *req, const char *name, int error,
 +	bool status_valid, u32 status)
 +{
 +	switch (error) {
 +	case -EILSEQ:
 +		/* response crc error, retry the r/w cmd */
 +		pr_err("%s: %s sending %s command, card status %#x\n",
 +			req->rq_disk->disk_name, "response CRC error",
 +			name, status);
 +		return ERR_RETRY;
 +
 +	case -ETIMEDOUT:
 +		pr_err("%s: %s sending %s command, card status %#x\n",
 +			req->rq_disk->disk_name, "timed out", name, status);
 +
 +		/* If the status cmd initially failed, retry the r/w cmd */
 +		if (!status_valid) {
 +			pr_err("%s: status not valid, retrying timeout\n",
 +				req->rq_disk->disk_name);
 +			return ERR_RETRY;
 +		}
 +
 +		/*
 +		 * If it was a r/w cmd crc error, or illegal command
 +		 * (eg, issued in wrong state) then retry - we should
 +		 * have corrected the state problem above.
 +		 */
 +		if (status & (R1_COM_CRC_ERROR | R1_ILLEGAL_COMMAND)) {
 +			pr_err("%s: command error, retrying timeout\n",
 +				req->rq_disk->disk_name);
 +			return ERR_RETRY;
 +		}
 +
 +		/* Otherwise abort the command */
 +		return ERR_ABORT;
 +
 +	default:
 +		/* We don't understand the error code the driver gave us */
 +		pr_err("%s: unknown error %d sending read/write command, card status %#x\n",
 +		       req->rq_disk->disk_name, error, status);
 +		return ERR_ABORT;
 +	}
 +}
 +
 +/*
 + * Initial r/w and stop cmd error recovery.
 + * We don't know whether the card received the r/w cmd or not, so try to
 + * restore things back to a sane state.  Essentially, we do this as follows:
 + * - Obtain card status.  If the first attempt to obtain card status fails,
 + *   the status word will reflect the failed status cmd, not the failed
 + *   r/w cmd.  If we fail to obtain card status, it suggests we can no
 + *   longer communicate with the card.
 + * - Check the card state.  If the card received the cmd but there was a
 + *   transient problem with the response, it might still be in a data transfer
 + *   mode.  Try to send it a stop command.  If this fails, we can't recover.
 + * - If the r/w cmd failed due to a response CRC error, it was probably
 + *   transient, so retry the cmd.
 + * - If the r/w cmd timed out, but we didn't get the r/w cmd status, retry.
 + * - If the r/w cmd timed out, and the r/w cmd failed due to CRC error or
 + *   illegal cmd, retry.
 + * Otherwise we don't understand what happened, so abort.
 + */
 +static int mmc_blk_cmd_recovery(struct mmc_card *card, struct request *req,
 +	struct mmc_blk_request *brq, bool *ecc_err, bool *gen_err)
 +{
 +	bool prev_cmd_status_valid = true;
 +	u32 status, stop_status = 0;
 +	int err, retry;
 +
 +	if (mmc_card_removed(card))
 +		return ERR_NOMEDIUM;
 +
 +	/*
 +	 * Try to get card status which indicates both the card state
 +	 * and why there was no response.  If the first attempt fails,
 +	 * we can't be sure the returned status is for the r/w command.
 +	 */
 +	for (retry = 2; retry >= 0; retry--) {
 +		err = __mmc_send_status(card, &status, 0);
 +		if (!err)
 +			break;
 +
 +		/* Re-tune if needed */
 +		mmc_retune_recheck(card->host);
 +
 +		prev_cmd_status_valid = false;
 +		pr_err("%s: error %d sending status command, %sing\n",
 +		       req->rq_disk->disk_name, err, retry ? "retry" : "abort");
 +	}
 +
 +	/* We couldn't get a response from the card.  Give up. */
 +	if (err) {
 +		/* Check if the card is removed */
 +		if (mmc_detect_card_removed(card->host))
 +			return ERR_NOMEDIUM;
 +		return ERR_ABORT;
 +	}
 +
 +	/* Flag ECC errors */
 +	if ((status & R1_CARD_ECC_FAILED) ||
 +	    (brq->stop.resp[0] & R1_CARD_ECC_FAILED) ||
 +	    (brq->cmd.resp[0] & R1_CARD_ECC_FAILED))
 +		*ecc_err = true;
 +
 +	/* Flag General errors */
 +	if (!mmc_host_is_spi(card->host) && rq_data_dir(req) != READ)
 +		if ((status & R1_ERROR) ||
 +			(brq->stop.resp[0] & R1_ERROR)) {
 +			pr_err("%s: %s: general error sending stop or status command, stop cmd response %#x, card status %#x\n",
 +			       req->rq_disk->disk_name, __func__,
 +			       brq->stop.resp[0], status);
 +			*gen_err = true;
 +		}
 +
 +	/*
 +	 * Check the current card state.  If it is in some data transfer
 +	 * mode, tell it to stop (and hopefully transition back to TRAN.)
 +	 */
 +	if (R1_CURRENT_STATE(status) == R1_STATE_DATA ||
 +	    R1_CURRENT_STATE(status) == R1_STATE_RCV) {
 +		err = send_stop(card,
 +			DIV_ROUND_UP(brq->data.timeout_ns, 1000000),
 +			req, gen_err, &stop_status);
 +		if (err) {
 +			pr_err("%s: error %d sending stop command\n",
 +			       req->rq_disk->disk_name, err);
 +			/*
 +			 * If the stop cmd also timed out, the card is probably
 +			 * not present, so abort. Other errors are bad news too.
 +			 */
 +			return ERR_ABORT;
 +		}
 +
 +		if (stop_status & R1_CARD_ECC_FAILED)
 +			*ecc_err = true;
 +	}
 +
 +	/* Check for set block count errors */
 +	if (brq->sbc.error)
 +		return mmc_blk_cmd_error(req, "SET_BLOCK_COUNT", brq->sbc.error,
 +				prev_cmd_status_valid, status);
 +
 +	/* Check for r/w command errors */
 +	if (brq->cmd.error)
 +		return mmc_blk_cmd_error(req, "r/w cmd", brq->cmd.error,
 +				prev_cmd_status_valid, status);
 +
 +	/* Data errors */
 +	if (!brq->stop.error)
 +		return ERR_CONTINUE;
 +
 +	/* Now for stop errors.  These aren't fatal to the transfer. */
 +	pr_info("%s: error %d sending stop command, original cmd response %#x, card status %#x\n",
 +	       req->rq_disk->disk_name, brq->stop.error,
 +	       brq->cmd.resp[0], status);
 +
 +	/*
 +	 * Subsitute in our own stop status as this will give the error
 +	 * state which happened during the execution of the r/w command.
 +	 */
 +	if (stop_status) {
 +		brq->stop.resp[0] = stop_status;
 +		brq->stop.error = 0;
 +	}
 +	return ERR_CONTINUE;
 +}
 +
++=======
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  static int mmc_blk_reset(struct mmc_blk_data *md, struct mmc_host *host,
  			 int type)
  {
@@@ -1159,19 -1042,71 +1161,79 @@@ static inline void mmc_blk_reset_succes
  	md->reset_done &= ~type;
  }
  
++<<<<<<< HEAD
 +int mmc_access_rpmb(struct mmc_queue *mq)
 +{
++=======
+ /*
+  * The non-block commands come back from the block layer after it queued it and
+  * processed it with all other requests and then they get issued in this
+  * function.
+  */
+ static void mmc_blk_issue_drv_op(struct mmc_queue *mq, struct request *req)
+ {
+ 	struct mmc_queue_req *mq_rq;
+ 	struct mmc_card *card = mq->card;
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  	struct mmc_blk_data *md = mq->blkdata;
 -	struct mmc_blk_ioc_data **idata;
 -	bool rpmb_ioctl;
 -	u8 **ext_csd;
 -	u32 status;
 -	int ret;
 -	int i;
 +	/*
 +	 * If this is a RPMB partition access, return ture
 +	 */
 +	if (md && md->part_type == EXT_CSD_PART_CONFIG_ACC_RPMB)
 +		return true;
  
++<<<<<<< HEAD
 +	return false;
++=======
+ 	mq_rq = req_to_mmc_queue_req(req);
+ 	rpmb_ioctl = (mq_rq->drv_op == MMC_DRV_OP_IOCTL_RPMB);
+ 
+ 	switch (mq_rq->drv_op) {
+ 	case MMC_DRV_OP_IOCTL:
+ 	case MMC_DRV_OP_IOCTL_RPMB:
+ 		idata = mq_rq->drv_op_data;
+ 		for (i = 0, ret = 0; i < mq_rq->ioc_count; i++) {
+ 			ret = __mmc_blk_ioctl_cmd(card, md, idata[i]);
+ 			if (ret)
+ 				break;
+ 		}
+ 		/* Always switch back to main area after RPMB access */
+ 		if (rpmb_ioctl)
+ 			mmc_blk_part_switch(card, 0);
+ 		break;
+ 	case MMC_DRV_OP_BOOT_WP:
+ 		ret = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_BOOT_WP,
+ 				 card->ext_csd.boot_ro_lock |
+ 				 EXT_CSD_BOOT_WP_B_PWR_WP_EN,
+ 				 card->ext_csd.part_time);
+ 		if (ret)
+ 			pr_err("%s: Locking boot partition ro until next power on failed: %d\n",
+ 			       md->disk->disk_name, ret);
+ 		else
+ 			card->ext_csd.boot_ro_lock |=
+ 				EXT_CSD_BOOT_WP_B_PWR_WP_EN;
+ 		break;
+ 	case MMC_DRV_OP_GET_CARD_STATUS:
+ 		ret = mmc_send_status(card, &status);
+ 		if (!ret)
+ 			ret = status;
+ 		break;
+ 	case MMC_DRV_OP_GET_EXT_CSD:
+ 		ext_csd = mq_rq->drv_op_data;
+ 		ret = mmc_get_ext_csd(card, ext_csd);
+ 		break;
+ 	default:
+ 		pr_err("%s: unknown driver specific operation\n",
+ 		       md->disk->disk_name);
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 	mq_rq->drv_op_result = ret;
+ 	blk_mq_end_request(req, ret ? BLK_STS_IOERR : BLK_STS_OK);
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  }
  
 -static void mmc_blk_issue_discard_rq(struct mmc_queue *mq, struct request *req)
 +static int mmc_blk_issue_discard_rq(struct mmc_queue *mq, struct request *req)
  {
  	struct mmc_blk_data *md = mq->blkdata;
  	struct mmc_card *card = md->queue.card;
@@@ -1205,15 -1141,15 +1267,19 @@@
  		if (!err)
  			err = mmc_erase(card, from, nr, arg);
  	} while (err == -EIO && !mmc_blk_reset(md, card->host, type));
 -	if (err)
 -		status = BLK_STS_IOERR;
 -	else
 +	if (!err)
  		mmc_blk_reset_success(md, type);
  fail:
++<<<<<<< HEAD
 +	blk_end_request(req, err, blk_rq_bytes(req));
 +
 +	return err ? 0 : 1;
++=======
+ 	blk_mq_end_request(req, status);
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  }
  
 -static void mmc_blk_issue_secdiscard_rq(struct mmc_queue *mq,
 +static int mmc_blk_issue_secdiscard_rq(struct mmc_queue *mq,
  				       struct request *req)
  {
  	struct mmc_blk_data *md = mq->blkdata;
@@@ -1275,24 -1216,17 +1341,32 @@@ out_retry
  	if (!err)
  		mmc_blk_reset_success(md, type);
  out:
++<<<<<<< HEAD
 +	blk_end_request(req, err, blk_rq_bytes(req));
 +
 +	return err ? 0 : 1;
++=======
+ 	blk_mq_end_request(req, status);
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  }
  
 -static void mmc_blk_issue_flush(struct mmc_queue *mq, struct request *req)
 +static int mmc_blk_issue_flush(struct mmc_queue *mq, struct request *req)
  {
  	struct mmc_blk_data *md = mq->blkdata;
  	struct mmc_card *card = md->queue.card;
  	int ret = 0;
  
  	ret = mmc_flush_cache(card);
++<<<<<<< HEAD
 +	if (ret)
 +		ret = -EIO;
 +
 +	blk_end_request_all(req, ret);
 +
 +	return ret ? 0 : 1;
++=======
+ 	blk_mq_end_request(req, ret ? BLK_STS_IOERR : BLK_STS_OK);
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  }
  
  /*
@@@ -1369,126 -1306,15 +1443,132 @@@ static void mmc_blk_eval_resp_error(str
  	}
  }
  
++<<<<<<< HEAD
 +static enum mmc_blk_status mmc_blk_err_check(struct mmc_card *card,
 +					     struct mmc_async_req *areq)
 +{
 +	struct mmc_queue_req *mq_mrq = container_of(areq, struct mmc_queue_req,
 +						    mmc_active);
 +	struct mmc_blk_request *brq = &mq_mrq->brq;
 +	struct request *req = mq_mrq->req;
 +	int need_retune = card->host->need_retune;
 +	bool ecc_err = false;
 +	bool gen_err = false;
 +
 +	/*
 +	 * sbc.error indicates a problem with the set block count
 +	 * command.  No data will have been transferred.
 +	 *
 +	 * cmd.error indicates a problem with the r/w command.  No
 +	 * data will have been transferred.
 +	 *
 +	 * stop.error indicates a problem with the stop command.  Data
 +	 * may have been transferred, or may still be transferring.
 +	 */
 +
 +	mmc_blk_eval_resp_error(brq);
 +
 +	if (brq->sbc.error || brq->cmd.error ||
 +	    brq->stop.error || brq->data.error) {
 +		switch (mmc_blk_cmd_recovery(card, req, brq, &ecc_err, &gen_err)) {
 +		case ERR_RETRY:
 +			return MMC_BLK_RETRY;
 +		case ERR_ABORT:
 +			return MMC_BLK_ABORT;
 +		case ERR_NOMEDIUM:
 +			return MMC_BLK_NOMEDIUM;
 +		case ERR_CONTINUE:
 +			break;
 +		}
 +	}
 +
 +	/*
 +	 * Check for errors relating to the execution of the
 +	 * initial command - such as address errors.  No data
 +	 * has been transferred.
 +	 */
 +	if (brq->cmd.resp[0] & CMD_ERRORS) {
 +		pr_err("%s: r/w command failed, status = %#x\n",
 +		       req->rq_disk->disk_name, brq->cmd.resp[0]);
 +		return MMC_BLK_ABORT;
 +	}
 +
 +	/*
 +	 * Everything else is either success, or a data error of some
 +	 * kind.  If it was a write, we may have transitioned to
 +	 * program mode, which we have to wait for it to complete.
 +	 */
 +	if (!mmc_host_is_spi(card->host) && rq_data_dir(req) != READ) {
 +		int err;
 +
 +		/* Check stop command response */
 +		if (brq->stop.resp[0] & R1_ERROR) {
 +			pr_err("%s: %s: general error sending stop command, stop cmd response %#x\n",
 +			       req->rq_disk->disk_name, __func__,
 +			       brq->stop.resp[0]);
 +			gen_err = true;
 +		}
 +
 +		err = card_busy_detect(card, MMC_BLK_TIMEOUT_MS, false, req,
 +					&gen_err);
 +		if (err)
 +			return MMC_BLK_CMD_ERR;
 +	}
 +
 +	/* if general error occurs, retry the write operation. */
 +	if (gen_err) {
 +		pr_warn("%s: retrying write for general error\n",
 +				req->rq_disk->disk_name);
 +		return MMC_BLK_RETRY;
 +	}
 +
 +	/* Some errors (ECC) are flagged on the next commmand, so check stop, too */
 +	if (brq->data.error || brq->stop.error) {
 +		if (need_retune && !brq->retune_retry_done) {
 +			pr_debug("%s: retrying because a re-tune was needed\n",
 +				 req->rq_disk->disk_name);
 +			brq->retune_retry_done = 1;
 +			return MMC_BLK_RETRY;
 +		}
 +		pr_err("%s: error %d transferring data, sector %u, nr %u, cmd response %#x, card status %#x\n",
 +		       req->rq_disk->disk_name, brq->data.error ?: brq->stop.error,
 +		       (unsigned)blk_rq_pos(req),
 +		       (unsigned)blk_rq_sectors(req),
 +		       brq->cmd.resp[0], brq->stop.resp[0]);
 +
 +		if (rq_data_dir(req) == READ) {
 +			if (ecc_err)
 +				return MMC_BLK_ECC_ERR;
 +			return MMC_BLK_DATA_ERR;
 +		} else {
 +			return MMC_BLK_CMD_ERR;
 +		}
 +	}
 +
 +	if (!brq->data.bytes_xfered)
 +		return MMC_BLK_RETRY;
 +
 +	if (blk_rq_bytes(req) != brq->data.bytes_xfered)
 +		return MMC_BLK_PARTIAL;
 +
 +	return MMC_BLK_SUCCESS;
 +}
 +
 +static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 +			       struct mmc_card *card,
 +			       int disable_multi,
 +			       struct mmc_queue *mq)
++=======
+ static void mmc_blk_data_prep(struct mmc_queue *mq, struct mmc_queue_req *mqrq,
+ 			      int disable_multi, bool *do_rel_wr_p,
+ 			      bool *do_data_tag_p)
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  {
 -	struct mmc_blk_data *md = mq->blkdata;
 -	struct mmc_card *card = md->queue.card;
 +	u32 readcmd, writecmd;
  	struct mmc_blk_request *brq = &mqrq->brq;
 -	struct request *req = mmc_queue_req_to_req(mqrq);
 -	bool do_rel_wr, do_data_tag;
 +	struct request *req = mqrq->req;
 +	struct mmc_blk_data *md = mq->blkdata;
 +	bool do_data_tag;
  
  	/*
  	 * Reliable writes are used to implement Forced Unit Access and
@@@ -1539,6 -1379,207 +1619,210 @@@
  						brq->data.blocks);
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (do_rel_wr) {
+ 		mmc_apply_rel_rw(brq, card, req);
+ 		brq->data.flags |= MMC_DATA_REL_WR;
+ 	}
+ 
+ 	/*
+ 	 * Data tag is used only during writing meta data to speed
+ 	 * up write and any subsequent read of this meta data
+ 	 */
+ 	do_data_tag = card->ext_csd.data_tag_unit_size &&
+ 		      (req->cmd_flags & REQ_META) &&
+ 		      (rq_data_dir(req) == WRITE) &&
+ 		      ((brq->data.blocks * brq->data.blksz) >=
+ 		       card->ext_csd.data_tag_unit_size);
+ 
+ 	if (do_data_tag)
+ 		brq->data.flags |= MMC_DATA_DAT_TAG;
+ 
+ 	mmc_set_data_timeout(&brq->data, card);
+ 
+ 	brq->data.sg = mqrq->sg;
+ 	brq->data.sg_len = mmc_queue_map_sg(mq, mqrq);
+ 
+ 	/*
+ 	 * Adjust the sg list so it is the same size as the
+ 	 * request.
+ 	 */
+ 	if (brq->data.blocks != blk_rq_sectors(req)) {
+ 		int i, data_size = brq->data.blocks << 9;
+ 		struct scatterlist *sg;
+ 
+ 		for_each_sg(brq->data.sg, sg, brq->data.sg_len, i) {
+ 			data_size -= sg->length;
+ 			if (data_size <= 0) {
+ 				sg->length += data_size;
+ 				i++;
+ 				break;
+ 			}
+ 		}
+ 		brq->data.sg_len = i;
+ 	}
+ 
+ 	if (do_rel_wr_p)
+ 		*do_rel_wr_p = do_rel_wr;
+ 
+ 	if (do_data_tag_p)
+ 		*do_data_tag_p = do_data_tag;
+ }
+ 
+ #define MMC_CQE_RETRIES 2
+ 
+ static void mmc_blk_cqe_complete_rq(struct mmc_queue *mq, struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	struct mmc_request *mrq = &mqrq->brq.mrq;
+ 	struct request_queue *q = req->q;
+ 	struct mmc_host *host = mq->card->host;
+ 	unsigned long flags;
+ 	bool put_card;
+ 	int err;
+ 
+ 	mmc_cqe_post_req(host, mrq);
+ 
+ 	if (mrq->cmd && mrq->cmd->error)
+ 		err = mrq->cmd->error;
+ 	else if (mrq->data && mrq->data->error)
+ 		err = mrq->data->error;
+ 	else
+ 		err = 0;
+ 
+ 	if (err) {
+ 		if (mqrq->retries++ < MMC_CQE_RETRIES)
+ 			blk_mq_requeue_request(req, true);
+ 		else
+ 			blk_mq_end_request(req, BLK_STS_IOERR);
+ 	} else if (mrq->data) {
+ 		if (blk_update_request(req, BLK_STS_OK, mrq->data->bytes_xfered))
+ 			blk_mq_requeue_request(req, true);
+ 		else
+ 			__blk_mq_end_request(req, BLK_STS_OK);
+ 	} else {
+ 		blk_mq_end_request(req, BLK_STS_OK);
+ 	}
+ 
+ 	spin_lock_irqsave(q->queue_lock, flags);
+ 
+ 	mq->in_flight[mmc_issue_type(mq, req)] -= 1;
+ 
+ 	put_card = (mmc_tot_in_flight(mq) == 0);
+ 
+ 	mmc_cqe_check_busy(mq);
+ 
+ 	spin_unlock_irqrestore(q->queue_lock, flags);
+ 
+ 	if (!mq->cqe_busy)
+ 		blk_mq_run_hw_queues(q, true);
+ 
+ 	if (put_card)
+ 		mmc_put_card(mq->card, &mq->ctx);
+ }
+ 
+ void mmc_blk_cqe_recovery(struct mmc_queue *mq)
+ {
+ 	struct mmc_card *card = mq->card;
+ 	struct mmc_host *host = card->host;
+ 	int err;
+ 
+ 	pr_debug("%s: CQE recovery start\n", mmc_hostname(host));
+ 
+ 	err = mmc_cqe_recovery(host);
+ 	if (err)
+ 		mmc_blk_reset(mq->blkdata, host, MMC_BLK_CQE_RECOVERY);
+ 	else
+ 		mmc_blk_reset_success(mq->blkdata, MMC_BLK_CQE_RECOVERY);
+ 
+ 	pr_debug("%s: CQE recovery done\n", mmc_hostname(host));
+ }
+ 
+ static void mmc_blk_cqe_req_done(struct mmc_request *mrq)
+ {
+ 	struct mmc_queue_req *mqrq = container_of(mrq, struct mmc_queue_req,
+ 						  brq.mrq);
+ 	struct request *req = mmc_queue_req_to_req(mqrq);
+ 	struct request_queue *q = req->q;
+ 	struct mmc_queue *mq = q->queuedata;
+ 
+ 	/*
+ 	 * Block layer timeouts race with completions which means the normal
+ 	 * completion path cannot be used during recovery.
+ 	 */
+ 	if (mq->in_recovery)
+ 		mmc_blk_cqe_complete_rq(mq, req);
+ 	else
+ 		blk_mq_complete_request(req);
+ }
+ 
+ static int mmc_blk_cqe_start_req(struct mmc_host *host, struct mmc_request *mrq)
+ {
+ 	mrq->done		= mmc_blk_cqe_req_done;
+ 	mrq->recovery_notifier	= mmc_cqe_recovery_notifier;
+ 
+ 	return mmc_cqe_start_req(host, mrq);
+ }
+ 
+ static struct mmc_request *mmc_blk_cqe_prep_dcmd(struct mmc_queue_req *mqrq,
+ 						 struct request *req)
+ {
+ 	struct mmc_blk_request *brq = &mqrq->brq;
+ 
+ 	memset(brq, 0, sizeof(*brq));
+ 
+ 	brq->mrq.cmd = &brq->cmd;
+ 	brq->mrq.tag = req->tag;
+ 
+ 	return &brq->mrq;
+ }
+ 
+ static int mmc_blk_cqe_issue_flush(struct mmc_queue *mq, struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	struct mmc_request *mrq = mmc_blk_cqe_prep_dcmd(mqrq, req);
+ 
+ 	mrq->cmd->opcode = MMC_SWITCH;
+ 	mrq->cmd->arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
+ 			(EXT_CSD_FLUSH_CACHE << 16) |
+ 			(1 << 8) |
+ 			EXT_CSD_CMD_SET_NORMAL;
+ 	mrq->cmd->flags = MMC_CMD_AC | MMC_RSP_R1B;
+ 
+ 	return mmc_blk_cqe_start_req(mq->card->host, mrq);
+ }
+ 
+ static int mmc_blk_cqe_issue_rw_rq(struct mmc_queue *mq, struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 
+ 	mmc_blk_data_prep(mq, mqrq, 0, NULL, NULL);
+ 
+ 	return mmc_blk_cqe_start_req(mq->card->host, &mqrq->brq.mrq);
+ }
+ 
+ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
+ 			       struct mmc_card *card,
+ 			       int disable_multi,
+ 			       struct mmc_queue *mq)
+ {
+ 	u32 readcmd, writecmd;
+ 	struct mmc_blk_request *brq = &mqrq->brq;
+ 	struct request *req = mmc_queue_req_to_req(mqrq);
+ 	struct mmc_blk_data *md = mq->blkdata;
+ 	bool do_rel_wr, do_data_tag;
+ 
+ 	mmc_blk_data_prep(mq, mqrq, disable_multi, &do_rel_wr, &do_data_tag);
+ 
+ 	brq->mrq.cmd = &brq->cmd;
+ 
+ 	brq->cmd.arg = blk_rq_pos(req);
+ 	if (!mmc_card_blockaddr(card))
+ 		brq->cmd.arg <<= 9;
+ 	brq->cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
+ 
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  	if (brq->data.blocks > 1 || do_rel_wr) {
  		/* SPI multiblock writes terminate using a special
  		 * token, not a STOP_TRANSMISSION request.
@@@ -1608,284 -1624,637 +1892,737 @@@
  		brq->sbc.flags = MMC_RSP_R1 | MMC_CMD_AC;
  		brq->mrq.sbc = &brq->sbc;
  	}
++<<<<<<< HEAD
 +
 +	mmc_set_data_timeout(&brq->data, card);
++=======
+ }
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  
 -#define MMC_MAX_RETRIES		5
 -#define MMC_DATA_RETRIES	2
 -#define MMC_NO_RETRIES		(MMC_MAX_RETRIES + 1)
 +	brq->data.sg = mqrq->sg;
 +	brq->data.sg_len = mmc_queue_map_sg(mq, mqrq);
  
 -static int mmc_blk_send_stop(struct mmc_card *card, unsigned int timeout)
 -{
 -	struct mmc_command cmd = {
 -		.opcode = MMC_STOP_TRANSMISSION,
 -		.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC,
 -		/* Some hosts wait for busy anyway, so provide a busy timeout */
 -		.busy_timeout = timeout,
 -	};
 +	/*
 +	 * Adjust the sg list so it is the same size as the
 +	 * request.
 +	 */
 +	if (brq->data.blocks != blk_rq_sectors(req)) {
 +		int i, data_size = brq->data.blocks << 9;
 +		struct scatterlist *sg;
  
 -	return mmc_wait_for_cmd(card->host, &cmd, 5);
++<<<<<<< HEAD
 +		for_each_sg(brq->data.sg, sg, brq->data.sg_len, i) {
 +			data_size -= sg->length;
 +			if (data_size <= 0) {
 +				sg->length += data_size;
 +				i++;
 +				break;
 +			}
++=======
++	return mmc_wait_for_cmd(card->host, &cmd, 5);
+ }
+ 
+ static int mmc_blk_fix_state(struct mmc_card *card, struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	struct mmc_blk_request *brq = &mqrq->brq;
+ 	unsigned int timeout = mmc_blk_data_timeout_ms(card->host, &brq->data);
+ 	int err;
+ 
+ 	mmc_retune_hold_now(card->host);
+ 
+ 	mmc_blk_send_stop(card, timeout);
+ 
+ 	err = card_busy_detect(card, timeout, req, NULL);
+ 
+ 	mmc_retune_release(card->host);
+ 
+ 	return err;
+ }
+ 
+ #define MMC_READ_SINGLE_RETRIES	2
+ 
+ /* Single sector read during recovery */
+ static void mmc_blk_read_single(struct mmc_queue *mq, struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	struct mmc_request *mrq = &mqrq->brq.mrq;
+ 	struct mmc_card *card = mq->card;
+ 	struct mmc_host *host = card->host;
+ 	blk_status_t error = BLK_STS_OK;
+ 	int retries = 0;
+ 
+ 	do {
+ 		u32 status;
+ 		int err;
+ 
+ 		mmc_blk_rw_rq_prep(mqrq, card, 1, mq);
+ 
+ 		mmc_wait_for_req(host, mrq);
+ 
+ 		err = mmc_send_status(card, &status);
+ 		if (err)
+ 			goto error_exit;
+ 
+ 		if (!mmc_host_is_spi(host) &&
+ 		    !mmc_blk_in_tran_state(status)) {
+ 			err = mmc_blk_fix_state(card, req);
+ 			if (err)
+ 				goto error_exit;
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  		}
 +		brq->data.sg_len = i;
 +	}
  
 -		if (mrq->cmd->error && retries++ < MMC_READ_SINGLE_RETRIES)
 -			continue;
 -
 -		retries = 0;
 -
 -		if (mrq->cmd->error ||
 -		    mrq->data->error ||
 -		    (!mmc_host_is_spi(host) &&
 -		     (mrq->cmd->resp[0] & CMD_ERRORS || status & CMD_ERRORS)))
 -			error = BLK_STS_IOERR;
 -		else
 -			error = BLK_STS_OK;
 -
 -	} while (blk_update_request(req, error, 512));
 -
 -	return;
 -
 -error_exit:
 -	mrq->data->bytes_xfered = 0;
 -	blk_update_request(req, BLK_STS_IOERR, 512);
 -	/* Let it try the remaining request again */
 -	if (mqrq->retries > MMC_MAX_RETRIES - 1)
 -		mqrq->retries = MMC_MAX_RETRIES - 1;
 -}
 -
 -static inline bool mmc_blk_oor_valid(struct mmc_blk_request *brq)
 -{
 -	return !!brq->mrq.sbc;
 -}
 +	mqrq->mmc_active.mrq = &brq->mrq;
 +	mqrq->mmc_active.err_check = mmc_blk_err_check;
  
 -static inline u32 mmc_blk_stop_err_bits(struct mmc_blk_request *brq)
 -{
 -	return mmc_blk_oor_valid(brq) ? CMD_ERRORS : CMD_ERRORS_EXCL_OOR;
 +	mmc_queue_bounce_pre(mqrq);
  }
  
 -/*
 - * Check for errors the host controller driver might not have seen such as
 - * response mode errors or invalid card state.
 - */
 -static bool mmc_blk_status_error(struct request *req, u32 status)
 +static int mmc_blk_cmd_err(struct mmc_blk_data *md, struct mmc_card *card,
 +			   struct mmc_blk_request *brq, struct request *req,
 +			   int ret)
  {
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_blk_request *brq = &mqrq->brq;
 -	struct mmc_queue *mq = req->q->queuedata;
 -	u32 stop_err_bits;
 -
 -	if (mmc_host_is_spi(mq->card->host))
 -		return false;
 -
 -	stop_err_bits = mmc_blk_stop_err_bits(brq);
++<<<<<<< HEAD
 +	struct mmc_queue_req *mq_rq;
 +	mq_rq = container_of(brq, struct mmc_queue_req, brq);
  
 -	return brq->cmd.resp[0]  & CMD_ERRORS    ||
 -	       brq->stop.resp[0] & stop_err_bits ||
 -	       status            & stop_err_bits ||
 -	       (rq_data_dir(req) == WRITE && !mmc_blk_in_tran_state(status));
 -}
 +	/*
 +	 * If this is an SD card and we're writing, we can first
 +	 * mark the known good sectors as ok.
 +	 *
 +	 * If the card is not SD, we can still ok written sectors
 +	 * as reported by the controller (which might be less than
 +	 * the real number of written sectors, but never more).
 +	 */
 +	if (mmc_card_sd(card)) {
 +		u32 blocks;
 +		int err;
  
 -static inline bool mmc_blk_cmd_started(struct mmc_blk_request *brq)
 -{
 -	return !brq->sbc.error && !brq->cmd.error &&
 -	       !(brq->cmd.resp[0] & CMD_ERRORS);
 +		err = mmc_sd_num_wr_blocks(card, &blocks);
 +		if (!err) {
 +			ret = blk_end_request(req, 0, blocks << 9);
 +		}
 +	} else {
 +		ret = blk_end_request(req, 0, brq->data.bytes_xfered);
 +	}
 +	return ret;
  }
  
 -/*
 - * Requests are completed by mmc_blk_mq_complete_rq() which sets simple
 - * policy:
 - * 1. A request that has transferred at least some data is considered
 - * successful and will be requeued if there is remaining data to
 - * transfer.
 - * 2. Otherwise the number of retries is incremented and the request
 - * will be requeued if there are remaining retries.
 - * 3. Otherwise the request will be errored out.
 - * That means mmc_blk_mq_complete_rq() is controlled by bytes_xfered and
 - * mqrq->retries. So there are only 4 possible actions here:
 - *	1. do not accept the bytes_xfered value i.e. set it to zero
 - *	2. change mqrq->retries to determine the number of retries
 - *	3. try to reset the card
 - *	4. read one sector at a time
 - */
 -static void mmc_blk_mq_rw_recovery(struct mmc_queue *mq, struct request *req)
 +static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)
  {
 -	int type = rq_data_dir(req) == READ ? MMC_BLK_READ : MMC_BLK_WRITE;
 -	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
 -	struct mmc_blk_request *brq = &mqrq->brq;
  	struct mmc_blk_data *md = mq->blkdata;
 -	struct mmc_card *card = mq->card;
 -	u32 status;
 -	u32 blocks;
 -	int err;
 +	struct mmc_card *card = md->queue.card;
 +	struct mmc_blk_request *brq;
 +	int ret = 1, disable_multi = 0, retry = 0, type, retune_retry_done = 0;
 +	enum mmc_blk_status status;
 +	struct mmc_queue_req *mq_rq;
 +	struct request *req;
 +	struct mmc_async_req *new_areq;
 +	struct mmc_async_req *old_areq;
  
 -	/*
 -	 * Some errors the host driver might not have seen. Set the number of
 -	 * bytes transferred to zero in that case.
 -	 */
 -	err = __mmc_send_status(card, &status, 0);
 -	if (err || mmc_blk_status_error(req, status))
 -		brq->data.bytes_xfered = 0;
 +	if (!rqc && !mq->mqrq_prev->req)
 +		return 0;
  
 -	mmc_retune_release(card->host);
 +	do {
 +		if (rqc) {
 +			/*
 +			 * When 4KB native sector is enabled, only 8 blocks
 +			 * multiple read or write is allowed
 +			 */
 +			if (mmc_large_sector(card) &&
 +				!IS_ALIGNED(blk_rq_sectors(rqc), 8)) {
 +				pr_err("%s: Transfer size is not 4KB sector size aligned\n",
 +					rqc->rq_disk->disk_name);
 +				mmc_blk_rw_cmd_abort(card, rqc);
 +				return 0;
 +			}
  
 -	/*
 -	 * Try again to get the status. This also provides an opportunity for
 -	 * re-tuning.
 -	 */
 -	if (err)
 -		err = __mmc_send_status(card, &status, 0);
 +			mmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);
 +			new_areq = &mq->mqrq_cur->mmc_active;
 +		} else
 +			new_areq = NULL;
  
 -	/*
 -	 * Nothing more to do after the number of bytes transferred has been
 -	 * updated and there is no card.
 -	 */
 -	if (err && mmc_detect_card_removed(card->host))
 -		return;
 +		old_areq = mmc_start_req(card->host, new_areq, &status);
 +		if (!old_areq) {
 +			/*
 +			 * We have just put the first request into the pipeline
 +			 * and there is nothing more to do until it is
 +			 * complete.
 +			 */
 +			if (status == MMC_BLK_NEW_REQUEST)
 +				mq->flags |= MMC_QUEUE_NEW_REQUEST;
 +			return 0;
 +		}
 +
 +		/*
 +		 * An asynchronous request has been completed and we proceed
 +		 * to handle the result of it.
 +		 */
 +		mq_rq =	container_of(old_areq, struct mmc_queue_req, mmc_active);
 +		brq = &mq_rq->brq;
 +		req = mq_rq->req;
 +		type = rq_data_dir(req) == READ ? MMC_BLK_READ : MMC_BLK_WRITE;
 +		mmc_queue_bounce_post(mq_rq);
 +
 +		switch (status) {
 +		case MMC_BLK_SUCCESS:
 +		case MMC_BLK_PARTIAL:
 +			/*
 +			 * A block was successfully transferred.
 +			 */
 +			mmc_blk_reset_success(md, type);
  
 -	/* Try to get back to "tran" state */
 -	if (!mmc_host_is_spi(mq->card->host) &&
 -	    (err || !mmc_blk_in_tran_state(status)))
 -		err = mmc_blk_fix_state(mq->card, req);
 +			ret = blk_end_request(req, 0,
 +					brq->data.bytes_xfered);
  
 -	/*
 -	 * Special case for SD cards where the card might record the number of
 -	 * blocks written.
 -	 */
 -	if (!err && mmc_blk_cmd_started(brq) && mmc_card_sd(card) &&
 -	    rq_data_dir(req) == WRITE) {
 -		if (mmc_sd_num_wr_blocks(card, &blocks))
 -			brq->data.bytes_xfered = 0;
 -		else
 -			brq->data.bytes_xfered = blocks << 9;
 -	}
 +			/*
 +			 * If the blk_end_request function returns non-zero even
 +			 * though all data has been transferred and no errors
 +			 * were returned by the host controller, it's a bug.
 +			 */
 +			if (status == MMC_BLK_SUCCESS && ret) {
 +				pr_err("%s BUG rq_tot %d d_xfer %d\n",
 +				       __func__, blk_rq_bytes(req),
 +				       brq->data.bytes_xfered);
 +				mmc_blk_rw_cmd_abort(card, req);
 +				return 0;
 +			}
 +			break;
 +		case MMC_BLK_CMD_ERR:
 +			ret = mmc_blk_cmd_err(md, card, brq, req, ret);
 +			if (mmc_blk_reset(md, card->host, type))
 +				goto cmd_abort;
 +			if (!ret)
 +				goto start_new_req;
 +			break;
 +		case MMC_BLK_RETRY:
 +			retune_retry_done = brq->retune_retry_done;
 +			if (retry++ < 5)
 +				break;
 +			/* Fall through */
 +		case MMC_BLK_ABORT:
 +			if (!mmc_blk_reset(md, card->host, type))
 +				break;
 +			goto cmd_abort;
 +		case MMC_BLK_DATA_ERR: {
 +			int err;
  
 -	/* Reset if the card is in a bad state */
 -	if (!mmc_host_is_spi(mq->card->host) &&
 -	    err && mmc_blk_reset(md, card->host, type)) {
 -		pr_err("%s: recovery failed!\n", req->rq_disk->disk_name);
 -		mqrq->retries = MMC_NO_RETRIES;
 -		return;
 +			err = mmc_blk_reset(md, card->host, type);
 +			if (!err)
 +				break;
 +			if (err == -ENODEV)
 +				goto cmd_abort;
 +			/* Fall through */
 +		}
 +		case MMC_BLK_ECC_ERR:
 +			if (brq->data.blocks > 1) {
 +				/* Redo read one sector at a time */
 +				pr_warn("%s: retrying using single block read\n",
 +					req->rq_disk->disk_name);
 +				disable_multi = 1;
 +				break;
 +			}
 +			/*
 +			 * After an error, we redo I/O one sector at a
 +			 * time, so we only reach here after trying to
 +			 * read a single sector.
 +			 */
 +			ret = blk_end_request(req, -EIO,
 +						brq->data.blksz);
 +			if (!ret)
 +				goto start_new_req;
 +			break;
 +		case MMC_BLK_NOMEDIUM:
 +			goto cmd_abort;
 +		default:
 +			pr_err("%s: Unhandled return value (%d)",
 +					req->rq_disk->disk_name, status);
 +			goto cmd_abort;
 +		}
 +
 +		if (ret) {
 +			/*
 +			 * In case of a incomplete request
 +			 * prepare it again and resend.
 +			 */
 +			mmc_blk_rw_rq_prep(mq_rq, card,
 +					disable_multi, mq);
 +			mmc_start_req(card->host,
 +					&mq_rq->mmc_active, NULL);
 +			mq_rq->brq.retune_retry_done = retune_retry_done;
 +		}
 +	} while (ret);
 +
 +	return 1;
 +
 + cmd_abort:
 +	if (mmc_card_removed(card))
 +		req->cmd_flags |= REQ_QUIET;
 +	while (ret)
 +		ret = blk_end_request(req, -EIO,
 +				blk_rq_cur_bytes(req));
 +
 + start_new_req:
 +	if (rqc) {
 +		if (mmc_card_removed(card)) {
 +			rqc->cmd_flags |= REQ_QUIET;
 +			blk_end_request_all(rqc, -EIO);
 +		} else {
 +			mmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);
 +			mmc_start_req(card->host,
 +				      &mq->mqrq_cur->mmc_active, NULL);
 +		}
  	}
  
 -	/*
 -	 * If anything was done, just return and if there is anything remaining
 -	 * on the request it will get requeued.
 -	 */
 -	if (brq->data.bytes_xfered)
 -		return;
 +	return 0;
 +}
  
 -	/* Reset before last retry */
 -	if (mqrq->retries + 1 == MMC_MAX_RETRIES)
 -		mmc_blk_reset(md, card->host, type);
 +int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
 +{
 +	int ret;
 +	struct mmc_blk_data *md = mq->blkdata;
 +	struct mmc_card *card = md->queue.card;
 +	unsigned int cmd_flags = req ? req->cmd_flags : 0;
  
 -	/* Command errors fail fast, so use all MMC_MAX_RETRIES */
 -	if (brq->sbc.error || brq->cmd.error)
 -		return;
 +	if (req && !mq->mqrq_prev->req)
 +		/* claim host only for the first request */
 +		mmc_get_card(card);
  
 -	/* Reduce the remaining retries for data errors */
 -	if (mqrq->retries < MMC_MAX_RETRIES - MMC_DATA_RETRIES) {
 -		mqrq->retries = MMC_MAX_RETRIES - MMC_DATA_RETRIES;
 -		return;
 +	ret = mmc_blk_part_switch(card, md);
 +	if (ret) {
 +		if (req) {
 +			blk_end_request_all(req, -EIO);
 +		}
 +		ret = 0;
 +		goto out;
  	}
  
 -	/* FIXME: Missing single sector read for large sector size */
 -	if (!mmc_large_sector(card) && rq_data_dir(req) == READ &&
 -	    brq->data.blocks > 1) {
 -		/* Read one sector at a time */
 -		mmc_blk_read_single(mq, req);
 -		return;
 +	mq->flags &= ~MMC_QUEUE_NEW_REQUEST;
 +	if (cmd_flags & REQ_DISCARD) {
 +		/* complete ongoing async transfer before issuing discard */
 +		if (card->host->areq)
 +			mmc_blk_issue_rw_rq(mq, NULL);
 +		if (req->cmd_flags & REQ_SECURE)
 +			ret = mmc_blk_issue_secdiscard_rq(mq, req);
 +		else
 +			ret = mmc_blk_issue_discard_rq(mq, req);
 +	} else if (cmd_flags & REQ_FLUSH) {
 +		/* complete ongoing async transfer before issuing flush */
 +		if (card->host->areq)
 +			mmc_blk_issue_rw_rq(mq, NULL);
 +		ret = mmc_blk_issue_flush(mq, req);
 +	} else {
 +		ret = mmc_blk_issue_rw_rq(mq, req);
  	}
 -}
  
 -static inline bool mmc_blk_rq_error(struct mmc_blk_request *brq)
 -{
 +out:
 +	if ((!req && !(mq->flags & MMC_QUEUE_NEW_REQUEST)) ||
 +	     (cmd_flags & MMC_REQ_SPECIAL_MASK))
 +		/*
 +		 * Release host when there are no more requests
 +		 * and after special request(discard, flush) is done.
 +		 * In case sepecial request, there is no reentry to
 +		 * the 'mmc_blk_issue_rq' with 'mqrq_prev->req'.
 +		 */
 +		mmc_put_card(card);
 +	return ret;
++=======
+ 	mmc_blk_eval_resp_error(brq);
+ 
+ 	return brq->sbc.error || brq->cmd.error || brq->stop.error ||
+ 	       brq->data.error || brq->cmd.resp[0] & CMD_ERRORS;
+ }
+ 
+ static int mmc_blk_card_busy(struct mmc_card *card, struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	u32 status = 0;
+ 	int err;
+ 
+ 	if (mmc_host_is_spi(card->host) || rq_data_dir(req) == READ)
+ 		return 0;
+ 
+ 	err = card_busy_detect(card, MMC_BLK_TIMEOUT_MS, req, &status);
+ 
+ 	/*
+ 	 * Do not assume data transferred correctly if there are any error bits
+ 	 * set.
+ 	 */
+ 	if (status & mmc_blk_stop_err_bits(&mqrq->brq)) {
+ 		mqrq->brq.data.bytes_xfered = 0;
+ 		err = err ? err : -EIO;
+ 	}
+ 
+ 	/* Copy the exception bit so it will be seen later on */
+ 	if (mmc_card_mmc(card) && status & R1_EXCEPTION_EVENT)
+ 		mqrq->brq.cmd.resp[0] |= R1_EXCEPTION_EVENT;
+ 
+ 	return err;
+ }
+ 
+ static inline void mmc_blk_rw_reset_success(struct mmc_queue *mq,
+ 					    struct request *req)
+ {
+ 	int type = rq_data_dir(req) == READ ? MMC_BLK_READ : MMC_BLK_WRITE;
+ 
+ 	mmc_blk_reset_success(mq->blkdata, type);
+ }
+ 
+ static void mmc_blk_mq_complete_rq(struct mmc_queue *mq, struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	unsigned int nr_bytes = mqrq->brq.data.bytes_xfered;
+ 
+ 	if (nr_bytes) {
+ 		if (blk_update_request(req, BLK_STS_OK, nr_bytes))
+ 			blk_mq_requeue_request(req, true);
+ 		else
+ 			__blk_mq_end_request(req, BLK_STS_OK);
+ 	} else if (!blk_rq_bytes(req)) {
+ 		__blk_mq_end_request(req, BLK_STS_IOERR);
+ 	} else if (mqrq->retries++ < MMC_MAX_RETRIES) {
+ 		blk_mq_requeue_request(req, true);
+ 	} else {
+ 		if (mmc_card_removed(mq->card))
+ 			req->rq_flags |= RQF_QUIET;
+ 		blk_mq_end_request(req, BLK_STS_IOERR);
+ 	}
+ }
+ 
+ static bool mmc_blk_urgent_bkops_needed(struct mmc_queue *mq,
+ 					struct mmc_queue_req *mqrq)
+ {
+ 	return mmc_card_mmc(mq->card) && !mmc_host_is_spi(mq->card->host) &&
+ 	       (mqrq->brq.cmd.resp[0] & R1_EXCEPTION_EVENT ||
+ 		mqrq->brq.stop.resp[0] & R1_EXCEPTION_EVENT);
+ }
+ 
+ static void mmc_blk_urgent_bkops(struct mmc_queue *mq,
+ 				 struct mmc_queue_req *mqrq)
+ {
+ 	if (mmc_blk_urgent_bkops_needed(mq, mqrq))
+ 		mmc_start_bkops(mq->card, true);
+ }
+ 
+ void mmc_blk_mq_complete(struct request *req)
+ {
+ 	struct mmc_queue *mq = req->q->queuedata;
+ 
+ 	if (mq->use_cqe)
+ 		mmc_blk_cqe_complete_rq(mq, req);
+ 	else
+ 		mmc_blk_mq_complete_rq(mq, req);
+ }
+ 
+ static void mmc_blk_mq_poll_completion(struct mmc_queue *mq,
+ 				       struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	struct mmc_host *host = mq->card->host;
+ 
+ 	if (mmc_blk_rq_error(&mqrq->brq) ||
+ 	    mmc_blk_card_busy(mq->card, req)) {
+ 		mmc_blk_mq_rw_recovery(mq, req);
+ 	} else {
+ 		mmc_blk_rw_reset_success(mq, req);
+ 		mmc_retune_release(host);
+ 	}
+ 
+ 	mmc_blk_urgent_bkops(mq, mqrq);
+ }
+ 
+ static void mmc_blk_mq_dec_in_flight(struct mmc_queue *mq, struct request *req)
+ {
+ 	struct request_queue *q = req->q;
+ 	unsigned long flags;
+ 	bool put_card;
+ 
+ 	spin_lock_irqsave(q->queue_lock, flags);
+ 
+ 	mq->in_flight[mmc_issue_type(mq, req)] -= 1;
+ 
+ 	put_card = (mmc_tot_in_flight(mq) == 0);
+ 
+ 	spin_unlock_irqrestore(q->queue_lock, flags);
+ 
+ 	if (put_card)
+ 		mmc_put_card(mq->card, &mq->ctx);
+ }
+ 
+ static void mmc_blk_mq_post_req(struct mmc_queue *mq, struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	struct mmc_request *mrq = &mqrq->brq.mrq;
+ 	struct mmc_host *host = mq->card->host;
+ 
+ 	mmc_post_req(host, mrq, 0);
+ 
+ 	/*
+ 	 * Block layer timeouts race with completions which means the normal
+ 	 * completion path cannot be used during recovery.
+ 	 */
+ 	if (mq->in_recovery)
+ 		mmc_blk_mq_complete_rq(mq, req);
+ 	else
+ 		blk_mq_complete_request(req);
+ 
+ 	mmc_blk_mq_dec_in_flight(mq, req);
+ }
+ 
+ void mmc_blk_mq_recovery(struct mmc_queue *mq)
+ {
+ 	struct request *req = mq->recovery_req;
+ 	struct mmc_host *host = mq->card->host;
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 
+ 	mq->recovery_req = NULL;
+ 	mq->rw_wait = false;
+ 
+ 	if (mmc_blk_rq_error(&mqrq->brq)) {
+ 		mmc_retune_hold_now(host);
+ 		mmc_blk_mq_rw_recovery(mq, req);
+ 	}
+ 
+ 	mmc_blk_urgent_bkops(mq, mqrq);
+ 
+ 	mmc_blk_mq_post_req(mq, req);
+ }
+ 
+ static void mmc_blk_mq_complete_prev_req(struct mmc_queue *mq,
+ 					 struct request **prev_req)
+ {
+ 	if (mmc_host_done_complete(mq->card->host))
+ 		return;
+ 
+ 	mutex_lock(&mq->complete_lock);
+ 
+ 	if (!mq->complete_req)
+ 		goto out_unlock;
+ 
+ 	mmc_blk_mq_poll_completion(mq, mq->complete_req);
+ 
+ 	if (prev_req)
+ 		*prev_req = mq->complete_req;
+ 	else
+ 		mmc_blk_mq_post_req(mq, mq->complete_req);
+ 
+ 	mq->complete_req = NULL;
+ 
+ out_unlock:
+ 	mutex_unlock(&mq->complete_lock);
+ }
+ 
+ void mmc_blk_mq_complete_work(struct work_struct *work)
+ {
+ 	struct mmc_queue *mq = container_of(work, struct mmc_queue,
+ 					    complete_work);
+ 
+ 	mmc_blk_mq_complete_prev_req(mq, NULL);
+ }
+ 
+ static void mmc_blk_mq_req_done(struct mmc_request *mrq)
+ {
+ 	struct mmc_queue_req *mqrq = container_of(mrq, struct mmc_queue_req,
+ 						  brq.mrq);
+ 	struct request *req = mmc_queue_req_to_req(mqrq);
+ 	struct request_queue *q = req->q;
+ 	struct mmc_queue *mq = q->queuedata;
+ 	struct mmc_host *host = mq->card->host;
+ 	unsigned long flags;
+ 
+ 	if (!mmc_host_done_complete(host)) {
+ 		bool waiting;
+ 
+ 		/*
+ 		 * We cannot complete the request in this context, so record
+ 		 * that there is a request to complete, and that a following
+ 		 * request does not need to wait (although it does need to
+ 		 * complete complete_req first).
+ 		 */
+ 		spin_lock_irqsave(q->queue_lock, flags);
+ 		mq->complete_req = req;
+ 		mq->rw_wait = false;
+ 		waiting = mq->waiting;
+ 		spin_unlock_irqrestore(q->queue_lock, flags);
+ 
+ 		/*
+ 		 * If 'waiting' then the waiting task will complete this
+ 		 * request, otherwise queue a work to do it. Note that
+ 		 * complete_work may still race with the dispatch of a following
+ 		 * request.
+ 		 */
+ 		if (waiting)
+ 			wake_up(&mq->wait);
+ 		else
+ 			kblockd_schedule_work(&mq->complete_work);
+ 
+ 		return;
+ 	}
+ 
+ 	/* Take the recovery path for errors or urgent background operations */
+ 	if (mmc_blk_rq_error(&mqrq->brq) ||
+ 	    mmc_blk_urgent_bkops_needed(mq, mqrq)) {
+ 		spin_lock_irqsave(q->queue_lock, flags);
+ 		mq->recovery_needed = true;
+ 		mq->recovery_req = req;
+ 		spin_unlock_irqrestore(q->queue_lock, flags);
+ 		wake_up(&mq->wait);
+ 		schedule_work(&mq->recovery_work);
+ 		return;
+ 	}
+ 
+ 	mmc_blk_rw_reset_success(mq, req);
+ 
+ 	mq->rw_wait = false;
+ 	wake_up(&mq->wait);
+ 
+ 	mmc_blk_mq_post_req(mq, req);
+ }
+ 
+ static bool mmc_blk_rw_wait_cond(struct mmc_queue *mq, int *err)
+ {
+ 	struct request_queue *q = mq->queue;
+ 	unsigned long flags;
+ 	bool done;
+ 
+ 	/*
+ 	 * Wait while there is another request in progress, but not if recovery
+ 	 * is needed. Also indicate whether there is a request waiting to start.
+ 	 */
+ 	spin_lock_irqsave(q->queue_lock, flags);
+ 	if (mq->recovery_needed) {
+ 		*err = -EBUSY;
+ 		done = true;
+ 	} else {
+ 		done = !mq->rw_wait;
+ 	}
+ 	mq->waiting = !done;
+ 	spin_unlock_irqrestore(q->queue_lock, flags);
+ 
+ 	return done;
+ }
+ 
+ static int mmc_blk_rw_wait(struct mmc_queue *mq, struct request **prev_req)
+ {
+ 	int err = 0;
+ 
+ 	wait_event(mq->wait, mmc_blk_rw_wait_cond(mq, &err));
+ 
+ 	/* Always complete the previous request if there is one */
+ 	mmc_blk_mq_complete_prev_req(mq, prev_req);
+ 
+ 	return err;
+ }
+ 
+ static int mmc_blk_mq_issue_rw_rq(struct mmc_queue *mq,
+ 				  struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	struct mmc_host *host = mq->card->host;
+ 	struct request *prev_req = NULL;
+ 	int err = 0;
+ 
+ 	mmc_blk_rw_rq_prep(mqrq, mq->card, 0, mq);
+ 
+ 	mqrq->brq.mrq.done = mmc_blk_mq_req_done;
+ 
+ 	mmc_pre_req(host, &mqrq->brq.mrq);
+ 
+ 	err = mmc_blk_rw_wait(mq, &prev_req);
+ 	if (err)
+ 		goto out_post_req;
+ 
+ 	mq->rw_wait = true;
+ 
+ 	err = mmc_start_request(host, &mqrq->brq.mrq);
+ 
+ 	if (prev_req)
+ 		mmc_blk_mq_post_req(mq, prev_req);
+ 
+ 	if (err)
+ 		mq->rw_wait = false;
+ 
+ 	/* Release re-tuning here where there is no synchronization required */
+ 	if (err || mmc_host_done_complete(host))
+ 		mmc_retune_release(host);
+ 
+ out_post_req:
+ 	if (err)
+ 		mmc_post_req(host, &mqrq->brq.mrq, err);
+ 
+ 	return err;
+ }
+ 
+ static int mmc_blk_wait_for_idle(struct mmc_queue *mq, struct mmc_host *host)
+ {
+ 	if (mq->use_cqe)
+ 		return host->cqe_ops->cqe_wait_for_idle(host);
+ 
+ 	return mmc_blk_rw_wait(mq, NULL);
+ }
+ 
+ enum mmc_issued mmc_blk_mq_issue_rq(struct mmc_queue *mq, struct request *req)
+ {
+ 	struct mmc_blk_data *md = mq->blkdata;
+ 	struct mmc_card *card = md->queue.card;
+ 	struct mmc_host *host = card->host;
+ 	int ret;
+ 
+ 	ret = mmc_blk_part_switch(card, md->part_type);
+ 	if (ret)
+ 		return MMC_REQ_FAILED_TO_START;
+ 
+ 	switch (mmc_issue_type(mq, req)) {
+ 	case MMC_ISSUE_SYNC:
+ 		ret = mmc_blk_wait_for_idle(mq, host);
+ 		if (ret)
+ 			return MMC_REQ_BUSY;
+ 		switch (req_op(req)) {
+ 		case REQ_OP_DRV_IN:
+ 		case REQ_OP_DRV_OUT:
+ 			mmc_blk_issue_drv_op(mq, req);
+ 			break;
+ 		case REQ_OP_DISCARD:
+ 			mmc_blk_issue_discard_rq(mq, req);
+ 			break;
+ 		case REQ_OP_SECURE_ERASE:
+ 			mmc_blk_issue_secdiscard_rq(mq, req);
+ 			break;
+ 		case REQ_OP_FLUSH:
+ 			mmc_blk_issue_flush(mq, req);
+ 			break;
+ 		default:
+ 			WARN_ON_ONCE(1);
+ 			return MMC_REQ_FAILED_TO_START;
+ 		}
+ 		return MMC_REQ_FINISHED;
+ 	case MMC_ISSUE_DCMD:
+ 	case MMC_ISSUE_ASYNC:
+ 		switch (req_op(req)) {
+ 		case REQ_OP_FLUSH:
+ 			ret = mmc_blk_cqe_issue_flush(mq, req);
+ 			break;
+ 		case REQ_OP_READ:
+ 		case REQ_OP_WRITE:
+ 			if (mq->use_cqe)
+ 				ret = mmc_blk_cqe_issue_rw_rq(mq, req);
+ 			else
+ 				ret = mmc_blk_mq_issue_rw_rq(mq, req);
+ 			break;
+ 		default:
+ 			WARN_ON_ONCE(1);
+ 			ret = -EINVAL;
+ 		}
+ 		if (!ret)
+ 			return MMC_REQ_STARTED;
+ 		return ret == -EBUSY ? MMC_REQ_BUSY : MMC_REQ_FAILED_TO_START;
+ 	default:
+ 		WARN_ON_ONCE(1);
+ 		return MMC_REQ_FAILED_TO_START;
+ 	}
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  }
  
  static inline int mmc_blk_readonly(struct mmc_card *card)
diff --cc drivers/mmc/core/block.h
index cdabb2ee74be,31153f656f41..000000000000
--- a/drivers/mmc/core/block.h
+++ b/drivers/mmc/core/block.h
@@@ -1,1 -1,20 +1,24 @@@
++<<<<<<< HEAD
 +int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req);
++=======
+ /* SPDX-License-Identifier: GPL-2.0 */
+ #ifndef _MMC_CORE_BLOCK_H
+ #define _MMC_CORE_BLOCK_H
+ 
+ struct mmc_queue;
+ struct request;
+ 
+ void mmc_blk_cqe_recovery(struct mmc_queue *mq);
+ 
+ enum mmc_issued;
+ 
+ enum mmc_issued mmc_blk_mq_issue_rq(struct mmc_queue *mq, struct request *req);
+ void mmc_blk_mq_complete(struct request *req);
+ void mmc_blk_mq_recovery(struct mmc_queue *mq);
+ 
+ struct work_struct;
+ 
+ void mmc_blk_mq_complete_work(struct work_struct *work);
+ 
+ #endif
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
diff --cc drivers/mmc/core/queue.c
index 8704591ee805,421fab7250ac..000000000000
--- a/drivers/mmc/core/queue.c
+++ b/drivers/mmc/core/queue.c
@@@ -21,134 -20,152 +21,279 @@@
  
  #include "queue.h"
  #include "block.h"
 -#include "core.h"
 -#include "card.h"
 -#include "host.h"
  
 +#define MMC_QUEUE_BOUNCESZ	65536
 +
++<<<<<<< HEAD
 +/*
 + * Prepare a MMC request. This just filters out odd stuff.
 + */
 +static int mmc_prep_request(struct request_queue *q, struct request *req)
 +{
 +	struct mmc_queue *mq = q->queuedata;
 +
 +	/*
 +	 * We only like normal block requests and discards.
 +	 */
 +	if (req->cmd_type != REQ_TYPE_FS && !(req->cmd_flags & REQ_DISCARD)) {
 +		blk_dump_rq_flags(req, "MMC bad request");
 +		return BLKPREP_KILL;
 +	}
 +
 +	if (mq && (mmc_card_removed(mq->card) || mmc_access_rpmb(mq)))
 +		return BLKPREP_KILL;
 +
 +	req->cmd_flags |= REQ_DONTPREP;
 +
 +	return BLKPREP_OK;
 +}
 +
 +static int mmc_queue_thread(void *d)
 +{
 +	struct mmc_queue *mq = d;
 +	struct request_queue *q = mq->queue;
 +	struct mmc_context_info *cntx = &mq->card->host->context_info;
 +
 +	current->flags |= PF_MEMALLOC;
 +
 +	down(&mq->thread_sem);
 +	do {
 +		struct request *req = NULL;
 +		unsigned int cmd_flags = 0;
 +
 +		spin_lock_irq(q->queue_lock);
 +		set_current_state(TASK_INTERRUPTIBLE);
 +		req = blk_fetch_request(q);
 +		mq->asleep = false;
 +		cntx->is_waiting_last_req = false;
 +		cntx->is_new_req = false;
 +		if (!req) {
 +			/*
 +			 * Dispatch queue is empty so set flags for
 +			 * mmc_request_fn() to wake us up.
 +			 */
 +			if (mq->mqrq_prev->req)
 +				cntx->is_waiting_last_req = true;
 +			else
 +				mq->asleep = true;
 +		}
 +		mq->mqrq_cur->req = req;
 +		spin_unlock_irq(q->queue_lock);
 +
 +		if (req || mq->mqrq_prev->req) {
 +			set_current_state(TASK_RUNNING);
 +			cmd_flags = req ? req->cmd_flags : 0;
 +			mmc_blk_issue_rq(mq, req);
 +			cond_resched();
 +			if (mq->flags & MMC_QUEUE_NEW_REQUEST) {
 +				mq->flags &= ~MMC_QUEUE_NEW_REQUEST;
 +				continue; /* fetch again */
 +			}
 +
 +			/*
 +			 * Current request becomes previous request
 +			 * and vice versa.
 +			 * In case of special requests, current request
 +			 * has been finished. Do not assign it to previous
 +			 * request.
 +			 */
 +			if (cmd_flags & MMC_REQ_SPECIAL_MASK)
 +				mq->mqrq_cur->req = NULL;
 +
 +			mq->mqrq_prev->brq.mrq.data = NULL;
 +			mq->mqrq_prev->req = NULL;
 +			swap(mq->mqrq_prev, mq->mqrq_cur);
 +		} else {
 +			if (kthread_should_stop()) {
 +				set_current_state(TASK_RUNNING);
 +				break;
 +			}
 +			up(&mq->thread_sem);
 +			schedule();
 +			down(&mq->thread_sem);
 +		}
 +	} while (1);
 +	up(&mq->thread_sem);
 +
 +	return 0;
 +}
 +
 +/*
 + * Generic MMC request handler.  This is called for any queue on a
 + * particular host.  When the host is not busy, we look for a request
 + * on any queue on this host, and attempt to issue it.  This may
 + * not be the queue we were asked to process.
 + */
 +static void mmc_request_fn(struct request_queue *q)
 +{
 +	struct mmc_queue *mq = q->queuedata;
 +	struct request *req;
 +	struct mmc_context_info *cntx;
 +
 +	if (!mq) {
 +		while ((req = blk_fetch_request(q)) != NULL) {
 +			req->cmd_flags |= REQ_QUIET;
 +			__blk_end_request_all(req, -EIO);
 +		}
 +		return;
 +	}
 +
 +	cntx = &mq->card->host->context_info;
 +
 +	if (cntx->is_waiting_last_req) {
 +		cntx->is_new_req = true;
 +		wake_up_interruptible(&cntx->wait);
 +	}
 +
 +	if (mq->asleep)
 +		wake_up_process(mq->thread);
 +}
 +
 +static struct scatterlist *mmc_alloc_sg(int sg_len, int *err)
++=======
+ static inline bool mmc_cqe_dcmd_busy(struct mmc_queue *mq)
+ {
+ 	/* Allow only 1 DCMD at a time */
+ 	return mq->in_flight[MMC_ISSUE_DCMD];
+ }
+ 
+ void mmc_cqe_check_busy(struct mmc_queue *mq)
+ {
+ 	if ((mq->cqe_busy & MMC_CQE_DCMD_BUSY) && !mmc_cqe_dcmd_busy(mq))
+ 		mq->cqe_busy &= ~MMC_CQE_DCMD_BUSY;
+ 
+ 	mq->cqe_busy &= ~MMC_CQE_QUEUE_FULL;
+ }
+ 
+ static inline bool mmc_cqe_can_dcmd(struct mmc_host *host)
+ {
+ 	return host->caps2 & MMC_CAP2_CQE_DCMD;
+ }
+ 
+ static enum mmc_issue_type mmc_cqe_issue_type(struct mmc_host *host,
+ 					      struct request *req)
+ {
+ 	switch (req_op(req)) {
+ 	case REQ_OP_DRV_IN:
+ 	case REQ_OP_DRV_OUT:
+ 	case REQ_OP_DISCARD:
+ 	case REQ_OP_SECURE_ERASE:
+ 		return MMC_ISSUE_SYNC;
+ 	case REQ_OP_FLUSH:
+ 		return mmc_cqe_can_dcmd(host) ? MMC_ISSUE_DCMD : MMC_ISSUE_SYNC;
+ 	default:
+ 		return MMC_ISSUE_ASYNC;
+ 	}
+ }
+ 
+ enum mmc_issue_type mmc_issue_type(struct mmc_queue *mq, struct request *req)
+ {
+ 	struct mmc_host *host = mq->card->host;
+ 
+ 	if (mq->use_cqe)
+ 		return mmc_cqe_issue_type(host, req);
+ 
+ 	if (req_op(req) == REQ_OP_READ || req_op(req) == REQ_OP_WRITE)
+ 		return MMC_ISSUE_ASYNC;
+ 
+ 	return MMC_ISSUE_SYNC;
+ }
+ 
+ static void __mmc_cqe_recovery_notifier(struct mmc_queue *mq)
+ {
+ 	if (!mq->recovery_needed) {
+ 		mq->recovery_needed = true;
+ 		schedule_work(&mq->recovery_work);
+ 	}
+ }
+ 
+ void mmc_cqe_recovery_notifier(struct mmc_request *mrq)
+ {
+ 	struct mmc_queue_req *mqrq = container_of(mrq, struct mmc_queue_req,
+ 						  brq.mrq);
+ 	struct request *req = mmc_queue_req_to_req(mqrq);
+ 	struct request_queue *q = req->q;
+ 	struct mmc_queue *mq = q->queuedata;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(q->queue_lock, flags);
+ 	__mmc_cqe_recovery_notifier(mq);
+ 	spin_unlock_irqrestore(q->queue_lock, flags);
+ }
+ 
+ static enum blk_eh_timer_return mmc_cqe_timed_out(struct request *req)
+ {
+ 	struct mmc_queue_req *mqrq = req_to_mmc_queue_req(req);
+ 	struct mmc_request *mrq = &mqrq->brq.mrq;
+ 	struct mmc_queue *mq = req->q->queuedata;
+ 	struct mmc_host *host = mq->card->host;
+ 	enum mmc_issue_type issue_type = mmc_issue_type(mq, req);
+ 	bool recovery_needed = false;
+ 
+ 	switch (issue_type) {
+ 	case MMC_ISSUE_ASYNC:
+ 	case MMC_ISSUE_DCMD:
+ 		if (host->cqe_ops->cqe_timeout(host, mrq, &recovery_needed)) {
+ 			if (recovery_needed)
+ 				__mmc_cqe_recovery_notifier(mq);
+ 			return BLK_EH_RESET_TIMER;
+ 		}
+ 		/* No timeout */
+ 		return BLK_EH_HANDLED;
+ 	default:
+ 		/* Timeout is handled by mmc core */
+ 		return BLK_EH_RESET_TIMER;
+ 	}
+ }
+ 
+ static enum blk_eh_timer_return mmc_mq_timed_out(struct request *req,
+ 						 bool reserved)
+ {
+ 	struct request_queue *q = req->q;
+ 	struct mmc_queue *mq = q->queuedata;
+ 	unsigned long flags;
+ 	int ret;
+ 
+ 	spin_lock_irqsave(q->queue_lock, flags);
+ 
+ 	if (mq->recovery_needed || !mq->use_cqe)
+ 		ret = BLK_EH_RESET_TIMER;
+ 	else
+ 		ret = mmc_cqe_timed_out(req);
+ 
+ 	spin_unlock_irqrestore(q->queue_lock, flags);
+ 
+ 	return ret;
+ }
+ 
+ static void mmc_mq_recovery_handler(struct work_struct *work)
+ {
+ 	struct mmc_queue *mq = container_of(work, struct mmc_queue,
+ 					    recovery_work);
+ 	struct request_queue *q = mq->queue;
+ 
+ 	mmc_get_card(mq->card, &mq->ctx);
+ 
+ 	mq->in_recovery = true;
+ 
+ 	if (mq->use_cqe)
+ 		mmc_blk_cqe_recovery(mq);
+ 	else
+ 		mmc_blk_mq_recovery(mq);
+ 
+ 	mq->in_recovery = false;
+ 
+ 	spin_lock_irq(q->queue_lock);
+ 	mq->recovery_needed = false;
+ 	spin_unlock_irq(q->queue_lock);
+ 
+ 	mmc_put_card(mq->card, &mq->ctx);
+ 
+ 	blk_mq_run_hw_queues(q, true);
+ }
+ 
+ static struct scatterlist *mmc_alloc_sg(int sg_len, gfp_t gfp)
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  {
  	struct scatterlist *sg;
  
@@@ -238,24 -215,230 +383,251 @@@ static int mmc_queue_alloc_sgs(struct m
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void mmc_queue_req_free_bufs(struct mmc_queue_req *mqrq)
 +{
 +	kfree(mqrq->bounce_sg);
 +	mqrq->bounce_sg = NULL;
 +
 +	kfree(mqrq->sg);
 +	mqrq->sg = NULL;
 +
 +	kfree(mqrq->bounce_buf);
 +	mqrq->bounce_buf = NULL;
 +}
 +
 +static void mmc_queue_reqs_free_bufs(struct mmc_queue *mq)
++=======
+ static void mmc_exit_request(struct request_queue *q, struct request *req)
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  {
 -	struct mmc_queue_req *mq_rq = req_to_mmc_queue_req(req);
 +	int i;
  
++<<<<<<< HEAD
 +	for (i = 0; i < mq->qdepth; i++)
 +		mmc_queue_req_free_bufs(&mq->mqrq[i]);
++=======
+ 	kfree(mq_rq->sg);
+ 	mq_rq->sg = NULL;
+ }
+ 
+ static int mmc_mq_init_request(struct blk_mq_tag_set *set, struct request *req,
+ 			       unsigned int hctx_idx, unsigned int numa_node)
+ {
+ 	return __mmc_init_request(set->driver_data, req, GFP_KERNEL);
+ }
+ 
+ static void mmc_mq_exit_request(struct blk_mq_tag_set *set, struct request *req,
+ 				unsigned int hctx_idx)
+ {
+ 	struct mmc_queue *mq = set->driver_data;
+ 
+ 	mmc_exit_request(mq->queue, req);
+ }
+ 
+ /*
+  * We use BLK_MQ_F_BLOCKING and have only 1 hardware queue, which means requests
+  * will not be dispatched in parallel.
+  */
+ static blk_status_t mmc_mq_queue_rq(struct blk_mq_hw_ctx *hctx,
+ 				    const struct blk_mq_queue_data *bd)
+ {
+ 	struct request *req = bd->rq;
+ 	struct request_queue *q = req->q;
+ 	struct mmc_queue *mq = q->queuedata;
+ 	struct mmc_card *card = mq->card;
+ 	struct mmc_host *host = card->host;
+ 	enum mmc_issue_type issue_type;
+ 	enum mmc_issued issued;
+ 	bool get_card, cqe_retune_ok;
+ 	int ret;
+ 
+ 	if (mmc_card_removed(mq->card)) {
+ 		req->rq_flags |= RQF_QUIET;
+ 		return BLK_STS_IOERR;
+ 	}
+ 
+ 	issue_type = mmc_issue_type(mq, req);
+ 
+ 	spin_lock_irq(q->queue_lock);
+ 
+ 	if (mq->recovery_needed) {
+ 		spin_unlock_irq(q->queue_lock);
+ 		return BLK_STS_RESOURCE;
+ 	}
+ 
+ 	switch (issue_type) {
+ 	case MMC_ISSUE_DCMD:
+ 		if (mmc_cqe_dcmd_busy(mq)) {
+ 			mq->cqe_busy |= MMC_CQE_DCMD_BUSY;
+ 			spin_unlock_irq(q->queue_lock);
+ 			return BLK_STS_RESOURCE;
+ 		}
+ 		break;
+ 	case MMC_ISSUE_ASYNC:
+ 		break;
+ 	default:
+ 		/*
+ 		 * Timeouts are handled by mmc core, and we don't have a host
+ 		 * API to abort requests, so we can't handle the timeout anyway.
+ 		 * However, when the timeout happens, blk_mq_complete_request()
+ 		 * no longer works (to stop the request disappearing under us).
+ 		 * To avoid racing with that, set a large timeout.
+ 		 */
+ 		req->timeout = 600 * HZ;
+ 		break;
+ 	}
+ 
+ 	mq->in_flight[issue_type] += 1;
+ 	get_card = (mmc_tot_in_flight(mq) == 1);
+ 	cqe_retune_ok = (mmc_cqe_qcnt(mq) == 1);
+ 
+ 	spin_unlock_irq(q->queue_lock);
+ 
+ 	if (!(req->rq_flags & RQF_DONTPREP)) {
+ 		req_to_mmc_queue_req(req)->retries = 0;
+ 		req->rq_flags |= RQF_DONTPREP;
+ 	}
+ 
+ 	if (get_card)
+ 		mmc_get_card(card, &mq->ctx);
+ 
+ 	if (mq->use_cqe) {
+ 		host->retune_now = host->need_retune && cqe_retune_ok &&
+ 				   !host->hold_retune;
+ 	}
+ 
+ 	blk_mq_start_request(req);
+ 
+ 	issued = mmc_blk_mq_issue_rq(mq, req);
+ 
+ 	switch (issued) {
+ 	case MMC_REQ_BUSY:
+ 		ret = BLK_STS_RESOURCE;
+ 		break;
+ 	case MMC_REQ_FAILED_TO_START:
+ 		ret = BLK_STS_IOERR;
+ 		break;
+ 	default:
+ 		ret = BLK_STS_OK;
+ 		break;
+ 	}
+ 
+ 	if (issued != MMC_REQ_STARTED) {
+ 		bool put_card = false;
+ 
+ 		spin_lock_irq(q->queue_lock);
+ 		mq->in_flight[issue_type] -= 1;
+ 		if (mmc_tot_in_flight(mq) == 0)
+ 			put_card = true;
+ 		spin_unlock_irq(q->queue_lock);
+ 		if (put_card)
+ 			mmc_put_card(card, &mq->ctx);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static const struct blk_mq_ops mmc_mq_ops = {
+ 	.queue_rq	= mmc_mq_queue_rq,
+ 	.init_request	= mmc_mq_init_request,
+ 	.exit_request	= mmc_mq_exit_request,
+ 	.complete	= mmc_blk_mq_complete,
+ 	.timeout	= mmc_mq_timed_out,
+ };
+ 
+ static void mmc_setup_queue(struct mmc_queue *mq, struct mmc_card *card)
+ {
+ 	struct mmc_host *host = card->host;
+ 	u64 limit = BLK_BOUNCE_HIGH;
+ 
+ 	if (mmc_dev(host)->dma_mask && *mmc_dev(host)->dma_mask)
+ 		limit = (u64)dma_max_pfn(mmc_dev(host)) << PAGE_SHIFT;
+ 
+ 	queue_flag_set_unlocked(QUEUE_FLAG_NONROT, mq->queue);
+ 	queue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, mq->queue);
+ 	if (mmc_can_erase(card))
+ 		mmc_queue_setup_discard(mq->queue, card);
+ 
+ 	blk_queue_bounce_limit(mq->queue, limit);
+ 	blk_queue_max_hw_sectors(mq->queue,
+ 		min(host->max_blk_count, host->max_req_size / 512));
+ 	blk_queue_max_segments(mq->queue, host->max_segs);
+ 	blk_queue_max_segment_size(mq->queue, host->max_seg_size);
+ 
+ 	INIT_WORK(&mq->recovery_work, mmc_mq_recovery_handler);
+ 	INIT_WORK(&mq->complete_work, mmc_blk_mq_complete_work);
+ 
+ 	mutex_init(&mq->complete_lock);
+ 
+ 	init_waitqueue_head(&mq->wait);
+ }
+ 
+ static int mmc_mq_init_queue(struct mmc_queue *mq, int q_depth,
+ 			     const struct blk_mq_ops *mq_ops, spinlock_t *lock)
+ {
+ 	int ret;
+ 
+ 	memset(&mq->tag_set, 0, sizeof(mq->tag_set));
+ 	mq->tag_set.ops = mq_ops;
+ 	mq->tag_set.queue_depth = q_depth;
+ 	mq->tag_set.numa_node = NUMA_NO_NODE;
+ 	mq->tag_set.flags = BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE |
+ 			    BLK_MQ_F_BLOCKING;
+ 	mq->tag_set.nr_hw_queues = 1;
+ 	mq->tag_set.cmd_size = sizeof(struct mmc_queue_req);
+ 	mq->tag_set.driver_data = mq;
+ 
+ 	ret = blk_mq_alloc_tag_set(&mq->tag_set);
+ 	if (ret)
+ 		return ret;
+ 
+ 	mq->queue = blk_mq_init_queue(&mq->tag_set);
+ 	if (IS_ERR(mq->queue)) {
+ 		ret = PTR_ERR(mq->queue);
+ 		goto free_tag_set;
+ 	}
+ 
+ 	mq->queue->queue_lock = lock;
+ 	mq->queue->queuedata = mq;
+ 
+ 	return 0;
+ 
+ free_tag_set:
+ 	blk_mq_free_tag_set(&mq->tag_set);
+ 
+ 	return ret;
+ }
+ 
+ /* Set queue depth to get a reasonable value for q->nr_requests */
+ #define MMC_QUEUE_DEPTH 64
+ 
+ static int mmc_mq_init(struct mmc_queue *mq, struct mmc_card *card,
+ 			 spinlock_t *lock)
+ {
+ 	struct mmc_host *host = card->host;
+ 	int q_depth;
+ 	int ret;
+ 
+ 	/*
+ 	 * The queue depth for CQE must match the hardware because the request
+ 	 * tag is used to index the hardware queue.
+ 	 */
+ 	if (mq->use_cqe)
+ 		q_depth = min_t(int, card->ext_csd.cmdq_depth, host->cqe_qdepth);
+ 	else
+ 		q_depth = MMC_QUEUE_DEPTH;
+ 
+ 	ret = mmc_mq_init_queue(mq, q_depth, &mmc_mq_ops, lock);
+ 	if (ret)
+ 		return ret;
+ 
+ 	blk_queue_rq_timeout(mq->queue, 60 * HZ);
+ 
+ 	mmc_setup_queue(mq, card);
+ 
+ 	return 0;
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  }
  
  /**
@@@ -271,162 -454,54 +643,211 @@@ int mmc_init_queue(struct mmc_queue *mq
  		   spinlock_t *lock, const char *subname)
  {
  	struct mmc_host *host = card->host;
++<<<<<<< HEAD
 +	u64 limit = BLK_BOUNCE_HIGH;
 +	bool bounce = false;
 +	int ret = -ENOMEM;
++=======
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
 +
 +	if (mmc_dev(host)->dma_mask && *mmc_dev(host)->dma_mask)
 +		limit = *mmc_dev(host)->dma_mask;
  
  	mq->card = card;
++<<<<<<< HEAD
 +	mq->queue = blk_init_queue(mmc_request_fn, lock);
 +	if (!mq->queue)
 +		return -ENOMEM;
 +
 +	mq->qdepth = 2;
 +	mq->mqrq = kcalloc(mq->qdepth, sizeof(struct mmc_queue_req),
 +			   GFP_KERNEL);
 +	if (!mq->mqrq)
 +		goto blk_cleanup;
 +	mq->mqrq_cur = &mq->mqrq[0];
 +	mq->mqrq_prev = &mq->mqrq[1];
 +	mq->queue->queuedata = mq;
 +
 +	blk_queue_prep_rq(mq->queue, mmc_prep_request);
 +	queue_flag_set_unlocked(QUEUE_FLAG_NONROT, mq->queue);
 +	queue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, mq->queue);
 +	if (mmc_can_erase(card))
 +		mmc_queue_setup_discard(mq->queue, card);
 +
 +#ifdef CONFIG_MMC_BLOCK_BOUNCE
 +	if (host->max_segs == 1) {
 +		unsigned int bouncesz;
 +
 +		bouncesz = MMC_QUEUE_BOUNCESZ;
 +
 +		if (bouncesz > host->max_req_size)
 +			bouncesz = host->max_req_size;
 +		if (bouncesz > host->max_seg_size)
 +			bouncesz = host->max_seg_size;
 +		if (bouncesz > (host->max_blk_count * 512))
 +			bouncesz = host->max_blk_count * 512;
 +
 +		if (bouncesz > 512 &&
 +		    mmc_queue_alloc_bounce_bufs(mq, bouncesz)) {
 +			blk_queue_bounce_limit(mq->queue, BLK_BOUNCE_ANY);
 +			blk_queue_max_hw_sectors(mq->queue, bouncesz / 512);
 +			blk_queue_max_segments(mq->queue, bouncesz / 512);
 +			blk_queue_max_segment_size(mq->queue, bouncesz);
 +
 +			ret = mmc_queue_alloc_bounce_sgs(mq, bouncesz);
 +			if (ret)
 +				goto cleanup_queue;
 +			bounce = true;
 +		}
 +	}
 +#endif
 +
 +	if (!bounce) {
 +		blk_queue_bounce_limit(mq->queue, limit);
 +		blk_queue_max_hw_sectors(mq->queue,
 +			min(host->max_blk_count, host->max_req_size / 512));
 +		blk_queue_max_segments(mq->queue, host->max_segs);
 +		blk_queue_max_segment_size(mq->queue, host->max_seg_size);
 +
 +		ret = mmc_queue_alloc_sgs(mq, host->max_segs);
 +		if (ret)
 +			goto cleanup_queue;
 +	}
 +
 +	sema_init(&mq->thread_sem, 1);
 +
 +	mq->thread = kthread_run(mmc_queue_thread, mq, "mmcqd/%d%s",
 +		host->index, subname ? subname : "");
 +
 +	if (IS_ERR(mq->thread)) {
 +		ret = PTR_ERR(mq->thread);
 +		goto cleanup_queue;
 +	}
 +
 +	return 0;
 +
 + cleanup_queue:
 +	mmc_queue_reqs_free_bufs(mq);
 +	kfree(mq->mqrq);
 +	mq->mqrq = NULL;
 +blk_cleanup:
 +	blk_cleanup_queue(mq->queue);
 +	return ret;
 +}
 +
++=======
+ 
+ 	mq->use_cqe = host->cqe_enabled;
+ 
+ 	return mmc_mq_init(mq, card, lock);
+ }
+ 
+ void mmc_queue_suspend(struct mmc_queue *mq)
+ {
+ 	blk_mq_quiesce_queue(mq->queue);
+ 
+ 	/*
+ 	 * The host remains claimed while there are outstanding requests, so
+ 	 * simply claiming and releasing here ensures there are none.
+ 	 */
+ 	mmc_claim_host(mq->card->host);
+ 	mmc_release_host(mq->card->host);
+ }
+ 
+ void mmc_queue_resume(struct mmc_queue *mq)
+ {
+ 	blk_mq_unquiesce_queue(mq->queue);
+ }
+ 
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  void mmc_cleanup_queue(struct mmc_queue *mq)
  {
  	struct request_queue *q = mq->queue;
- 	unsigned long flags;
  
++<<<<<<< HEAD
 +	/* Make sure the queue isn't suspended, as that will deadlock */
 +	mmc_queue_resume(mq);
 +
 +	/* Then terminate our worker thread */
 +	kthread_stop(mq->thread);
 +
 +	/* Empty the queue */
 +	spin_lock_irqsave(q->queue_lock, flags);
 +	q->queuedata = NULL;
 +	blk_start_queue(q);
 +	spin_unlock_irqrestore(q->queue_lock, flags);
 +
 +	mmc_queue_reqs_free_bufs(mq);
 +	kfree(mq->mqrq);
 +	mq->mqrq = NULL;
++=======
+ 	/*
+ 	 * The legacy code handled the possibility of being suspended,
+ 	 * so do that here too.
+ 	 */
+ 	if (blk_queue_quiesced(q))
+ 		blk_mq_unquiesce_queue(q);
+ 
+ 	blk_cleanup_queue(q);
+ 
+ 	/*
+ 	 * A request can be completed before the next request, potentially
+ 	 * leaving a complete_work with nothing to do. Such a work item might
+ 	 * still be queued at this point. Flush it.
+ 	 */
+ 	flush_work(&mq->complete_work);
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  
  	mq->card = NULL;
  }
  
++<<<<<<< HEAD
 +/**
 + * mmc_queue_suspend - suspend a MMC request queue
 + * @mq: MMC queue to suspend
 + *
 + * Stop the block request queue, and wait for our thread to
 + * complete any outstanding requests.  This ensures that we
 + * won't suspend while a request is being processed.
 + */
 +void mmc_queue_suspend(struct mmc_queue *mq)
 +{
 +	struct request_queue *q = mq->queue;
 +	unsigned long flags;
 +
 +	if (!(mq->flags & MMC_QUEUE_SUSPENDED)) {
 +		mq->flags |= MMC_QUEUE_SUSPENDED;
 +
 +		spin_lock_irqsave(q->queue_lock, flags);
 +		blk_stop_queue(q);
 +		spin_unlock_irqrestore(q->queue_lock, flags);
 +
 +		down(&mq->thread_sem);
 +	}
 +}
 +
 +/**
 + * mmc_queue_resume - resume a previously suspended MMC request queue
 + * @mq: MMC queue to resume
 + */
 +void mmc_queue_resume(struct mmc_queue *mq)
 +{
 +	struct request_queue *q = mq->queue;
 +	unsigned long flags;
 +
 +	if (mq->flags & MMC_QUEUE_SUSPENDED) {
 +		mq->flags &= ~MMC_QUEUE_SUSPENDED;
 +
 +		up(&mq->thread_sem);
 +
 +		spin_lock_irqsave(q->queue_lock, flags);
 +		blk_start_queue(q);
 +		spin_unlock_irqrestore(q->queue_lock, flags);
 +	}
 +}
 +
++=======
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  /*
   * Prepare the sg list(s) to be handed of to the host driver
   */
diff --cc drivers/mmc/core/queue.h
index a61f88199573,17e59d50b496..000000000000
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@@ -1,11 -1,41 +1,14 @@@
  #ifndef MMC_QUEUE_H
  #define MMC_QUEUE_H
  
 -#include <linux/types.h>
 -#include <linux/blkdev.h>
 -#include <linux/blk-mq.h>
 -#include <linux/mmc/core.h>
 -#include <linux/mmc/host.h>
 -
 -enum mmc_issued {
 -	MMC_REQ_STARTED,
 -	MMC_REQ_BUSY,
 -	MMC_REQ_FAILED_TO_START,
 -	MMC_REQ_FINISHED,
 -};
 -
 -enum mmc_issue_type {
 -	MMC_ISSUE_SYNC,
 -	MMC_ISSUE_DCMD,
 -	MMC_ISSUE_ASYNC,
 -	MMC_ISSUE_MAX,
 -};
 -
 -static inline struct mmc_queue_req *req_to_mmc_queue_req(struct request *rq)
 -{
 -	return blk_mq_rq_to_pdu(rq);
 -}
 -
 -struct mmc_queue_req;
 -
 -static inline struct request *mmc_queue_req_to_req(struct mmc_queue_req *mqr)
 -{
 -	return blk_mq_rq_from_pdu(mqr);
 -}
 +#define MMC_REQ_SPECIAL_MASK	(REQ_DISCARD | REQ_FLUSH)
  
++<<<<<<< HEAD
 +struct request;
 +struct task_struct;
++=======
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  struct mmc_blk_data;
 -struct mmc_blk_ioc_data;
  
  struct mmc_blk_request {
  	struct mmc_request	mrq;
@@@ -13,33 -43,55 +16,62 @@@
  	struct mmc_command	cmd;
  	struct mmc_command	stop;
  	struct mmc_data		data;
- 	int			retune_retry_done;
  };
  
 -/**
 - * enum mmc_drv_op - enumerates the operations in the mmc_queue_req
 - * @MMC_DRV_OP_IOCTL: ioctl operation
 - * @MMC_DRV_OP_IOCTL_RPMB: RPMB-oriented ioctl operation
 - * @MMC_DRV_OP_BOOT_WP: write protect boot partitions
 - * @MMC_DRV_OP_GET_CARD_STATUS: get card status
 - * @MMC_DRV_OP_GET_EXT_CSD: get the EXT CSD from an eMMC card
 - */
 -enum mmc_drv_op {
 -	MMC_DRV_OP_IOCTL,
 -	MMC_DRV_OP_IOCTL_RPMB,
 -	MMC_DRV_OP_BOOT_WP,
 -	MMC_DRV_OP_GET_CARD_STATUS,
 -	MMC_DRV_OP_GET_EXT_CSD,
 -};
 -
  struct mmc_queue_req {
 +	struct request		*req;
  	struct mmc_blk_request	brq;
  	struct scatterlist	*sg;
++<<<<<<< HEAD
 +	char			*bounce_buf;
 +	struct scatterlist	*bounce_sg;
 +	unsigned int		bounce_sg_len;
 +	struct mmc_async_req	mmc_active;
++=======
+ 	enum mmc_drv_op		drv_op;
+ 	int			drv_op_result;
+ 	void			*drv_op_data;
+ 	unsigned int		ioc_count;
+ 	int			retries;
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  };
  
  struct mmc_queue {
  	struct mmc_card		*card;
++<<<<<<< HEAD
 +	struct task_struct	*thread;
 +	struct semaphore	thread_sem;
 +	unsigned int		flags;
 +#define MMC_QUEUE_SUSPENDED	(1 << 0)
 +#define MMC_QUEUE_NEW_REQUEST	(1 << 1)
 +	bool			asleep;
 +	struct mmc_blk_data	*blkdata;
 +	struct request_queue	*queue;
 +	struct mmc_queue_req	*mqrq;
 +	struct mmc_queue_req	*mqrq_cur;
 +	struct mmc_queue_req	*mqrq_prev;
 +	int			qdepth;
++=======
+ 	struct mmc_ctx		ctx;
+ 	struct blk_mq_tag_set	tag_set;
+ 	struct mmc_blk_data	*blkdata;
+ 	struct request_queue	*queue;
+ 	int			in_flight[MMC_ISSUE_MAX];
+ 	unsigned int		cqe_busy;
+ #define MMC_CQE_DCMD_BUSY	BIT(0)
+ #define MMC_CQE_QUEUE_FULL	BIT(1)
+ 	bool			use_cqe;
+ 	bool			recovery_needed;
+ 	bool			in_recovery;
+ 	bool			rw_wait;
+ 	bool			waiting;
+ 	struct work_struct	recovery_work;
+ 	wait_queue_head_t	wait;
+ 	struct request		*recovery_req;
+ 	struct request		*complete_req;
+ 	struct mutex		complete_lock;
+ 	struct work_struct	complete_work;
++>>>>>>> 0fbfd1251830 (mmc: block: Remove code no longer needed after the switch to blk-mq)
  };
  
  extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *,
* Unmerged path drivers/mmc/core/block.c
* Unmerged path drivers/mmc/core/block.h
* Unmerged path drivers/mmc/core/queue.c
* Unmerged path drivers/mmc/core/queue.h
