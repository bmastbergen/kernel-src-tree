filesystem-dax: convert to dax_copy_from_iter()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit fec53774fd043038e57ac737d90e8d58975d6e92
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/fec53774.failed

Now that all possible providers of the dax_operations copy_from_iter
method are implemented, switch filesytem-dax to call the driver rather
than copy_to_iter_pmem.

	Reviewed-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit fec53774fd043038e57ac737d90e8d58975d6e92)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/pmem.h
#	fs/dax.c
#	include/linux/pmem.h
diff --cc arch/x86/include/asm/pmem.h
index ab4983df7bff,60e8edbe0205..000000000000
--- a/arch/x86/include/asm/pmem.h
+++ b/arch/x86/include/asm/pmem.h
@@@ -64,6 -65,19 +64,22 @@@ static inline void arch_wb_cache_pmem(v
  		clwb(p);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * arch_clear_pmem - zero a PMEM memory range
+  * @addr:	virtual start address
+  * @size:	number of bytes to zero
+  *
+  * Write zeros into the memory range starting at 'addr' for 'size' bytes.
+  */
+ static inline void arch_clear_pmem(void *addr, size_t size)
+ {
+ 	memset(addr, 0, size);
+ 	arch_wb_cache_pmem(addr, size);
+ }
+ 
++>>>>>>> fec53774fd04 (filesystem-dax: convert to dax_copy_from_iter())
  static inline void arch_invalidate_pmem(void *addr, size_t size)
  {
  	clflush_cache_range(addr, size);
diff --cc fs/dax.c
index 879d2cfa39b7,b459948de427..000000000000
--- a/fs/dax.c
+++ b/fs/dax.c
@@@ -1093,14 -1053,11 +1093,20 @@@ dax_iomap_actor(int rw, struct inode *i
  		if (map_len > end - pos)
  			map_len = end - pos;
  
++<<<<<<< HEAD
 +		if (rw & WRITE)
 +			map_len = memcpy_fromiovecend_partial_flushcache(
 +					kaddr, iter->iov,
 +					iter->iov_offset, map_len);
++=======
+ 		if (iov_iter_rw(iter) == WRITE)
+ 			map_len = dax_copy_from_iter(dax_dev, pgoff, kaddr,
+ 					map_len, iter);
++>>>>>>> fec53774fd04 (filesystem-dax: convert to dax_copy_from_iter())
  		else
 -			map_len = copy_to_iter(kaddr, map_len, iter);
 +			map_len = memcpy_toiovecend_partial(iter->iov,
 +					kaddr, iter->iov_offset, map_len);
 +
  		if (map_len <= 0) {
  			ret = map_len ? map_len : -EFAULT;
  			break;
diff --cc include/linux/pmem.h
index e34add5f758c,9d542a5600e4..000000000000
--- a/include/linux/pmem.h
+++ b/include/linux/pmem.h
@@@ -26,8 -26,12 +26,17 @@@
   * calling these symbols with arch_has_pmem_api() and redirect to the
   * implementation in asm/pmem.h.
   */
++<<<<<<< HEAD
 +static inline void arch_memcpy_to_pmem(void *dst, const void *src,
 +		size_t n)
++=======
+ static inline void arch_memcpy_to_pmem(void *dst, const void *src, size_t n)
+ {
+ 	BUG();
+ }
+ 
+ static inline void arch_clear_pmem(void *addr, size_t size)
++>>>>>>> fec53774fd04 (filesystem-dax: convert to dax_copy_from_iter())
  {
  	BUG();
  }
@@@ -90,6 -73,22 +99,25 @@@ static inline void memcpy_to_pmem(void 
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * clear_pmem - zero a PMEM memory range
+  * @addr:	virtual start address
+  * @size:	number of bytes to zero
+  *
+  * Write zeros into the memory range starting at 'addr' for 'size' bytes.
+  * See blkdev_issue_flush() note for memcpy_to_pmem().
+  */
+ static inline void clear_pmem(void *addr, size_t size)
+ {
+ 	if (arch_has_pmem_api())
+ 		arch_clear_pmem(addr, size);
+ 	else
+ 		memset(addr, 0, size);
+ }
+ 
+ /**
++>>>>>>> fec53774fd04 (filesystem-dax: convert to dax_copy_from_iter())
   * invalidate_pmem - flush a pmem range from the cache hierarchy
   * @addr:	virtual start address
   * @size:	bytes to invalidate (internally aligned to cache line size)
* Unmerged path arch/x86/include/asm/pmem.h
* Unmerged path fs/dax.c
* Unmerged path include/linux/pmem.h
