perf top: Implement multithreading for perf_event__synthesize_threads

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Kan Liang <kan.liang@intel.com>
commit 340b47f510bbe55a76b7309107276f02ea11f117
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/340b47f5.failed

The proc files which is sorted with alphabetical order are evenly
assigned to several synthesize threads to be processed in parallel.

For 'perf top', the threads number hard code to online CPU number. The
following patch will introduce an option to set it.

For other perf tools, the thread number is 1. Because the process
function is not ready for multithreading, e.g.
process_synthesized_event.

This patch series only support event synthesize multithreading for 'perf
top'. For other tools, it can be done separately later.

With multithread applied, the total processing time can get up to 1.56x
speedup on Knights Mill for 'perf top'.

For specific single event processing, the processing time could increase
because of the lock contention. So proc_map_timeout may need to be
increased. Otherwise some proc maps will be truncated.

Based on my test, increasing the proc_map_timeout has small impact
on the total processing time. The total processing time still get 1.49x
speedup on Knights Mill after increasing the proc_map_timeout.
The patch itself doesn't increase the proc_map_timeout.

Doesn't need to implement multithreading for per task monitoring,
perf_event__synthesize_thread_map. It doesn't have performance issue.

Committer testing:

  # getconf _NPROCESSORS_ONLN
  4
  # perf trace --no-inherit -e clone -o /tmp/output perf top
  # tail -4 /tmp/bla
     0.124 ( 0.041 ms): clone(flags: VM|FS|FILES|SIGHAND|THREAD|SYSVSEM|SETTLS|PARENT_SETTID|CHILD_CLEARTID, child_stack: 0x7fc3eb3a8f30, parent_tidptr: 0x7fc3eb3a99d0, child_tidptr: 0x7fc3eb3a99d0, tls: 0x7fc3eb3a9700) = 9548 (perf)
     0.246 ( 0.023 ms): clone(flags: VM|FS|FILES|SIGHAND|THREAD|SYSVSEM|SETTLS|PARENT_SETTID|CHILD_CLEARTID, child_stack: 0x7fc3eaba7f30, parent_tidptr: 0x7fc3eaba89d0, child_tidptr: 0x7fc3eaba89d0, tls: 0x7fc3eaba8700) = 9549 (perf)
     0.286 ( 0.019 ms): clone(flags: VM|FS|FILES|SIGHAND|THREAD|SYSVSEM|SETTLS|PARENT_SETTID|CHILD_CLEARTID, child_stack: 0x7fc3ea3a6f30, parent_tidptr: 0x7fc3ea3a79d0, child_tidptr: 0x7fc3ea3a79d0, tls: 0x7fc3ea3a7700) = 9550 (perf)
   246.540 ( 0.047 ms): clone(flags: VM|FS|FILES|SIGHAND|THREAD|SYSVSEM|SETTLS|PARENT_SETTID|CHILD_CLEARTID, child_stack: 0x7fc3ea3a6f30, parent_tidptr: 0x7fc3ea3a79d0, child_tidptr: 0x7fc3ea3a79d0, tls: 0x7fc3ea3a7700) = 9551 (perf)
  #

	Signed-off-by: Kan Liang <kan.liang@intel.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Alexei Starovoitov <ast@kernel.org>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: He Kuang <hekuang@huawei.com>
	Cc: Lukasz Odzioba <lukasz.odzioba@intel.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/r/1506696477-146932-4-git-send-email-kan.liang@intel.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 340b47f510bbe55a76b7309107276f02ea11f117)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/event.c
diff --cc tools/perf/util/event.c
index ac6ce5ceef74,0e678dd6bdbe..000000000000
--- a/tools/perf/util/event.c
+++ b/tools/perf/util/event.c
@@@ -587,20 -678,21 +587,32 @@@ out
  	return err;
  }
  
- int perf_event__synthesize_threads(struct perf_tool *tool,
- 				   perf_event__handler_t process,
- 				   struct machine *machine,
- 				   bool mmap_data,
- 				   unsigned int proc_map_timeout)
+ static int __perf_event__synthesize_threads(struct perf_tool *tool,
+ 					    perf_event__handler_t process,
+ 					    struct machine *machine,
+ 					    bool mmap_data,
+ 					    unsigned int proc_map_timeout,
+ 					    struct dirent **dirent,
+ 					    int start,
+ 					    int num)
  {
++<<<<<<< HEAD
 +	DIR *proc;
 +	char proc_path[PATH_MAX];
 +	struct dirent *dirent;
 +	union perf_event *comm_event, *mmap_event, *fork_event;
 +	int err = -1;
 +
 +	if (machine__is_default_guest(machine))
 +		return 0;
++=======
+ 	union perf_event *comm_event, *mmap_event, *fork_event;
+ 	union perf_event *namespaces_event;
+ 	int err = -1;
+ 	char *end;
+ 	pid_t pid;
+ 	int i;
++>>>>>>> 340b47f510bb (perf top: Implement multithreading for perf_event__synthesize_threads)
  
  	comm_event = malloc(sizeof(comm_event->comm) + machine->id_hdr_size);
  	if (comm_event == NULL)
@@@ -614,29 -706,32 +626,52 @@@
  	if (fork_event == NULL)
  		goto out_free_mmap;
  
 -	namespaces_event = malloc(sizeof(namespaces_event->namespaces) +
 -				  (NR_NAMESPACES * sizeof(struct perf_ns_link_info)) +
 -				  machine->id_hdr_size);
 -	if (namespaces_event == NULL)
 +	snprintf(proc_path, sizeof(proc_path), "%s/proc", machine->root_dir);
 +	proc = opendir(proc_path);
 +
 +	if (proc == NULL)
  		goto out_free_fork;
  
++<<<<<<< HEAD
 +	while ((dirent = readdir(proc)) != NULL) {
 +		char *end;
 +		pid_t pid = strtol(dirent->d_name, &end, 10);
 +
 +		if (*end) /* only interested in proper numerical dirents */
 +			continue;
 +		/*
 + 		 * We may race with exiting thread, so don't stop just because
 + 		 * one thread couldn't be synthesized.
 + 		 */
 +		__event__synthesize_thread(comm_event, mmap_event, fork_event, pid,
 +					   1, process, tool, machine, mmap_data,
 +					   proc_map_timeout);
 +	}
 +
 +	err = 0;
 +	closedir(proc);
++=======
+ 	for (i = start; i < start + num; i++) {
+ 		if (!isdigit(dirent[i]->d_name[0]))
+ 			continue;
+ 
+ 		pid = (pid_t)strtol(dirent[i]->d_name, &end, 10);
+ 		/* only interested in proper numerical dirents */
+ 		if (*end)
+ 			continue;
+ 		/*
+ 		 * We may race with exiting thread, so don't stop just because
+ 		 * one thread couldn't be synthesized.
+ 		 */
+ 		__event__synthesize_thread(comm_event, mmap_event, fork_event,
+ 					   namespaces_event, pid, 1, process,
+ 					   tool, machine, mmap_data,
+ 					   proc_map_timeout);
+ 	}
+ 	err = 0;
+ 
+ 	free(namespaces_event);
++>>>>>>> 340b47f510bb (perf top: Implement multithreading for perf_event__synthesize_threads)
  out_free_fork:
  	free(fork_event);
  out_free_mmap:
diff --git a/tools/perf/builtin-kvm.c b/tools/perf/builtin-kvm.c
index a4c3ce78bab6..6de7bcd0f3ea 100644
--- a/tools/perf/builtin-kvm.c
+++ b/tools/perf/builtin-kvm.c
@@ -1396,7 +1396,8 @@ static int kvm_events_live(struct perf_kvm_stat *kvm,
 	perf_session__set_id_hdr_size(kvm->session);
 	ordered_events__set_copy_on_queue(&kvm->session->ordered_events, true);
 	machine__synthesize_threads(&kvm->session->machines.host, &kvm->opts.target,
-				    kvm->evlist->threads, false, kvm->opts.proc_map_timeout);
+				    kvm->evlist->threads, false,
+				    kvm->opts.proc_map_timeout, 1);
 	err = kvm_live_open_events(kvm);
 	if (err)
 		goto out;
diff --git a/tools/perf/builtin-record.c b/tools/perf/builtin-record.c
index 9f85044e5725..41439351ba1c 100644
--- a/tools/perf/builtin-record.c
+++ b/tools/perf/builtin-record.c
@@ -861,7 +861,7 @@ static int record__synthesize(struct record *rec, bool tail)
 
 	err = __machine__synthesize_threads(machine, tool, &opts->target, rec->evlist->threads,
 					    process_synthesized_event, opts->sample_address,
-					    opts->proc_map_timeout);
+					    opts->proc_map_timeout, 1);
 out:
 	return err;
 }
diff --git a/tools/perf/builtin-top.c b/tools/perf/builtin-top.c
index 0cb8dc7c3247..03f48994a197 100644
--- a/tools/perf/builtin-top.c
+++ b/tools/perf/builtin-top.c
@@ -958,8 +958,14 @@ static int __cmd_top(struct perf_top *top)
 	if (perf_session__register_idle_thread(top->session) < 0)
 		goto out_delete;
 
+	perf_set_multithreaded();
+
 	machine__synthesize_threads(&top->session->machines.host, &opts->target,
-				    top->evlist->threads, false, opts->proc_map_timeout);
+				    top->evlist->threads, false,
+				    opts->proc_map_timeout,
+				    (unsigned int)sysconf(_SC_NPROCESSORS_ONLN));
+
+	perf_set_singlethreaded();
 
 	if (perf_hpp_list.socket) {
 		ret = perf_env__read_cpu_topology_map(&perf_env);
diff --git a/tools/perf/builtin-trace.c b/tools/perf/builtin-trace.c
index 873215ce6cc7..f42f5fb68c62 100644
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@ -1198,7 +1198,7 @@ static int trace__symbols_init(struct trace *trace, struct perf_evlist *evlist)
 
 	err = __machine__synthesize_threads(trace->host, &trace->tool, &trace->opts.target,
 					    evlist->threads, trace__tool_process, false,
-					    trace->opts.proc_map_timeout);
+					    trace->opts.proc_map_timeout, 1);
 	if (err)
 		symbol__exit();
 
diff --git a/tools/perf/tests/mmap-thread-lookup.c b/tools/perf/tests/mmap-thread-lookup.c
index 6ea4d8a5d26b..70e72ffe7c11 100644
--- a/tools/perf/tests/mmap-thread-lookup.c
+++ b/tools/perf/tests/mmap-thread-lookup.c
@@ -131,7 +131,7 @@ static int synth_all(struct machine *machine)
 {
 	return perf_event__synthesize_threads(NULL,
 					      perf_event__process,
-					      machine, 0, 500);
+					      machine, 0, 500, 1);
 }
 
 static int synth_process(struct machine *machine)
* Unmerged path tools/perf/util/event.c
diff --git a/tools/perf/util/event.h b/tools/perf/util/event.h
index dfad6102ae7f..9d897a2438d3 100644
--- a/tools/perf/util/event.h
+++ b/tools/perf/util/event.h
@@ -554,7 +554,8 @@ int perf_event__synthesize_cpu_map(struct perf_tool *tool,
 int perf_event__synthesize_threads(struct perf_tool *tool,
 				   perf_event__handler_t process,
 				   struct machine *machine, bool mmap_data,
-				   unsigned int proc_map_timeout);
+				   unsigned int proc_map_timeout,
+				   unsigned int nr_threads_synthesize);
 int perf_event__synthesize_kernel_mmap(struct perf_tool *tool,
 				       perf_event__handler_t process,
 				       struct machine *machine);
diff --git a/tools/perf/util/machine.c b/tools/perf/util/machine.c
index dd04122c6a82..8b40f79d2458 100644
--- a/tools/perf/util/machine.c
+++ b/tools/perf/util/machine.c
@@ -2178,12 +2178,16 @@ int machines__for_each_thread(struct machines *machines,
 int __machine__synthesize_threads(struct machine *machine, struct perf_tool *tool,
 				  struct target *target, struct thread_map *threads,
 				  perf_event__handler_t process, bool data_mmap,
-				  unsigned int proc_map_timeout)
+				  unsigned int proc_map_timeout,
+				  unsigned int nr_threads_synthesize)
 {
 	if (target__has_task(target))
 		return perf_event__synthesize_thread_map(tool, threads, process, machine, data_mmap, proc_map_timeout);
 	else if (target__has_cpu(target))
-		return perf_event__synthesize_threads(tool, process, machine, data_mmap, proc_map_timeout);
+		return perf_event__synthesize_threads(tool, process,
+						      machine, data_mmap,
+						      proc_map_timeout,
+						      nr_threads_synthesize);
 	/* command specified */
 	return 0;
 }
diff --git a/tools/perf/util/machine.h b/tools/perf/util/machine.h
index 7de7f73c48bd..23adf98f1deb 100644
--- a/tools/perf/util/machine.h
+++ b/tools/perf/util/machine.h
@@ -253,15 +253,18 @@ int machines__for_each_thread(struct machines *machines,
 int __machine__synthesize_threads(struct machine *machine, struct perf_tool *tool,
 				  struct target *target, struct thread_map *threads,
 				  perf_event__handler_t process, bool data_mmap,
-				  unsigned int proc_map_timeout);
+				  unsigned int proc_map_timeout,
+				  unsigned int nr_threads_synthesize);
 static inline
 int machine__synthesize_threads(struct machine *machine, struct target *target,
 				struct thread_map *threads, bool data_mmap,
-				unsigned int proc_map_timeout)
+				unsigned int proc_map_timeout,
+				unsigned int nr_threads_synthesize)
 {
 	return __machine__synthesize_threads(machine, NULL, target, threads,
 					     perf_event__process, data_mmap,
-					     proc_map_timeout);
+					     proc_map_timeout,
+					     nr_threads_synthesize);
 }
 
 pid_t machine__get_current_tid(struct machine *machine, int cpu);
