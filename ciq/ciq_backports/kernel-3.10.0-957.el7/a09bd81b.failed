net: aquantia: Limit number of vectors to actually allocated irqs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Igor Russkikh <igor.russkikh@aquantia.com>
commit a09bd81b5413d1b4d705c6c5303b5d311069da22
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/a09bd81b.failed

Driver should use pci_alloc_irq_vectors return value to correct number
of allocated vectors and napi instances. Otherwise it'll panic later
in pci_irq_vector.

Driver also should allow more than one MSI vectors to be allocated.

Error return path from pci_alloc_irq_vectors is also fixed to revert
resources in a correct sequence when error happens.

	Reported-by: Long, Nicholas <nicholas.a.long@baesystems.com>
Fixes: 23ee07a ("net: aquantia: Cleanup pci functions module")
	Signed-off-by: Igor Russkikh <igor.russkikh@aquantia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a09bd81b5413d1b4d705c6c5303b5d311069da22)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_nic.h
#	drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_nic.h
index 715b53c689ef,faa533a0ec47..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
@@@ -70,13 -57,38 +70,48 @@@ struct aq_nic_cfg_s 
  #define AQ_NIC_TCVEC2RING(_NIC_, _TC_, _VEC_) \
  	((_TC_) * AQ_CFG_TCS_MAX + (_VEC_))
  
++<<<<<<< HEAD
 +struct aq_nic_s *aq_nic_alloc_cold(const struct net_device_ops *ndev_ops,
 +				   const struct ethtool_ops *et_ops,
 +				   struct pci_dev *pdev,
 +				   struct aq_pci_func_s *aq_pci_func,
 +				   unsigned int port,
 +				   const struct aq_hw_ops *aq_hw_ops);
 +int aq_nic_ndev_init(struct aq_nic_s *self);
++=======
+ struct aq_nic_s {
+ 	atomic_t flags;
+ 	struct aq_vec_s *aq_vec[AQ_CFG_VECS_MAX];
+ 	struct aq_ring_s *aq_ring_tx[AQ_CFG_VECS_MAX * AQ_CFG_TCS_MAX];
+ 	struct aq_hw_s *aq_hw;
+ 	struct net_device *ndev;
+ 	unsigned int aq_vecs;
+ 	unsigned int packet_filter;
+ 	unsigned int power_state;
+ 	u8 port;
+ 	const struct aq_hw_ops *aq_hw_ops;
+ 	const struct aq_fw_ops *aq_fw_ops;
+ 	struct aq_nic_cfg_s aq_nic_cfg;
+ 	struct timer_list service_timer;
+ 	struct timer_list polling_timer;
+ 	struct aq_hw_link_status_s link_status;
+ 	struct {
+ 		u32 count;
+ 		u8 ar[AQ_CFG_MULTICAST_ADDRESS_MAX][ETH_ALEN];
+ 	} mc_list;
+ 
+ 	struct pci_dev *pdev;
+ 	unsigned int msix_entry_mask;
+ 	u32 irqvecs;
+ };
+ 
+ static inline struct device *aq_nic_get_dev(struct aq_nic_s *self)
+ {
+ 	return self->ndev->dev.parent;
+ }
+ 
+ void aq_nic_ndev_init(struct aq_nic_s *self);
++>>>>>>> a09bd81b5413 (net: aquantia: Limit number of vectors to actually allocated irqs)
  struct aq_nic_s *aq_nic_alloc_hot(struct net_device *ndev);
  void aq_nic_set_tx_ring(struct aq_nic_s *self, unsigned int idx,
  			struct aq_ring_s *ring);
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
index 667e08a571a5,a50e08bb4748..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
@@@ -261,87 -177,189 +261,177 @@@ void aq_pci_func_free_irqs(struct aq_pc
  	}
  }
  
 -unsigned int aq_pci_func_get_irq_type(struct aq_nic_s *self)
 +void __iomem *aq_pci_func_get_mmio(struct aq_pci_func_s *self)
  {
 -	if (self->pdev->msix_enabled)
 -		return AQ_HW_IRQ_MSIX;
 -	if (self->pdev->msi_enabled)
 -		return AQ_HW_IRQ_MSIX;
 -	return AQ_HW_IRQ_LEGACY;
 +	return self->mmio;
  }
  
 -static void aq_pci_free_irq_vectors(struct aq_nic_s *self)
 +unsigned int aq_pci_func_get_irq_type(struct aq_pci_func_s *self)
  {
 -	pci_free_irq_vectors(self->pdev);
 +	return self->irq_type;
  }
  
 -static int aq_pci_probe(struct pci_dev *pdev,
 -			const struct pci_device_id *pci_id)
 +void aq_pci_func_deinit(struct aq_pci_func_s *self)
  {
 -	struct aq_nic_s *self = NULL;
 -	int err = 0;
 -	struct net_device *ndev;
 -	resource_size_t mmio_pa;
 -	u32 bar;
 -	u32 numvecs;
 +	if (!self)
 +		goto err_exit;
  
 -	err = pci_enable_device(pdev);
 -	if (err)
 -		return err;
 +	aq_pci_func_free_irqs(self);
  
 -	err = aq_pci_func_init(pdev);
 -	if (err)
 -		goto err_pci_func;
 +	switch (self->irq_type) {
 +	case AQ_HW_IRQ_MSI:
 +		pci_disable_msi(self->pdev);
 +		break;
  
 -	ndev = aq_ndev_alloc();
 -	if (!ndev) {
 -		err = -ENOMEM;
 -		goto err_ndev;
 +	case AQ_HW_IRQ_MSIX:
 +		pci_disable_msix(self->pdev);
 +		break;
 +
 +	case AQ_HW_IRQ_LEGACY:
 +		break;
 +
 +	default:
 +		break;
  	}
  
 +	if (self->is_regions)
 +		pci_release_regions(self->pdev);
 +
 +	if (self->is_pci_enabled)
 +		pci_disable_device(self->pdev);
 +
 +err_exit:;
 +}
 +
 +void aq_pci_func_free(struct aq_pci_func_s *self)
 +{
 +	unsigned int port = 0U;
 +
 +	if (!self)
 +		goto err_exit;
 +
 +	for (port = 0; port < self->ports; ++port) {
 +		if (!self->port[port])
 +			continue;
 +
 +		aq_nic_ndev_free(self->port[port]);
 +	}
 +
 +	if (self->mmio)
 +		iounmap(self->mmio);
 +
 +	kfree(self);
 +
 +err_exit:;
 +}
 +
 +int aq_pci_func_change_pm_state(struct aq_pci_func_s *self,
 +				pm_message_t *pm_msg)
 +{
 +	int err = 0;
 +	unsigned int port = 0U;
 +
 +	if (!self) {
 +		err = -EFAULT;
 +		goto err_exit;
 +	}
 +	for (port = 0; port < self->ports; ++port) {
 +		if (!self->port[port])
 +			continue;
 +
 +		(void)aq_nic_change_pm_state(self->port[port], pm_msg);
 +	}
 +
++<<<<<<< HEAD
 +err_exit:
++=======
+ 	self = netdev_priv(ndev);
+ 	self->pdev = pdev;
+ 	SET_NETDEV_DEV(ndev, &pdev->dev);
+ 	pci_set_drvdata(pdev, self);
+ 
+ 	err = aq_pci_probe_get_hw_by_id(pdev, &self->aq_hw_ops,
+ 					&aq_nic_get_cfg(self)->aq_hw_caps);
+ 	if (err)
+ 		goto err_ioremap;
+ 
+ 	self->aq_hw = kzalloc(sizeof(*self->aq_hw), GFP_KERNEL);
+ 	if (!self->aq_hw) {
+ 		err = -ENOMEM;
+ 		goto err_ioremap;
+ 	}
+ 	self->aq_hw->aq_nic_cfg = aq_nic_get_cfg(self);
+ 
+ 	for (bar = 0; bar < 4; ++bar) {
+ 		if (IORESOURCE_MEM & pci_resource_flags(pdev, bar)) {
+ 			resource_size_t reg_sz;
+ 
+ 			mmio_pa = pci_resource_start(pdev, bar);
+ 			if (mmio_pa == 0U) {
+ 				err = -EIO;
+ 				goto err_free_aq_hw;
+ 			}
+ 
+ 			reg_sz = pci_resource_len(pdev, bar);
+ 			if ((reg_sz <= 24 /*ATL_REGS_SIZE*/)) {
+ 				err = -EIO;
+ 				goto err_free_aq_hw;
+ 			}
+ 
+ 			self->aq_hw->mmio = ioremap_nocache(mmio_pa, reg_sz);
+ 			if (!self->aq_hw->mmio) {
+ 				err = -EIO;
+ 				goto err_free_aq_hw;
+ 			}
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (bar == 4) {
+ 		err = -EIO;
+ 		goto err_free_aq_hw;
+ 	}
+ 
+ 	numvecs = min((u8)AQ_CFG_VECS_DEF,
+ 		      aq_nic_get_cfg(self)->aq_hw_caps->msix_irqs);
+ 	numvecs = min(numvecs, num_online_cpus());
+ 	/*enable interrupts */
+ #if !AQ_CFG_FORCE_LEGACY_INT
+ 	numvecs = pci_alloc_irq_vectors(self->pdev, 1, numvecs,
+ 					PCI_IRQ_MSIX | PCI_IRQ_MSI |
+ 					PCI_IRQ_LEGACY);
+ 
+ 	if (numvecs < 0) {
+ 		err = numvecs;
+ 		goto err_hwinit;
+ 	}
+ #endif
+ 	self->irqvecs = numvecs;
+ 
+ 	/* net device init */
+ 	aq_nic_cfg_start(self);
+ 
+ 	aq_nic_ndev_init(self);
+ 
+ 	err = aq_nic_ndev_register(self);
+ 	if (err < 0)
+ 		goto err_register;
+ 
+ 	return 0;
+ 
+ err_register:
+ 	aq_nic_free_vectors(self);
+ 	aq_pci_free_irq_vectors(self);
+ err_hwinit:
+ 	iounmap(self->aq_hw->mmio);
+ err_free_aq_hw:
+ 	kfree(self->aq_hw);
+ err_ioremap:
+ 	free_netdev(ndev);
+ err_ndev:
+ 	pci_release_regions(pdev);
+ err_pci_func:
+ 	pci_disable_device(pdev);
++>>>>>>> a09bd81b5413 (net: aquantia: Limit number of vectors to actually allocated irqs)
  	return err;
  }
 -
 -static void aq_pci_remove(struct pci_dev *pdev)
 -{
 -	struct aq_nic_s *self = pci_get_drvdata(pdev);
 -
 -	if (self->ndev) {
 -		if (self->ndev->reg_state == NETREG_REGISTERED)
 -			unregister_netdev(self->ndev);
 -		aq_nic_free_vectors(self);
 -		aq_pci_free_irq_vectors(self);
 -		iounmap(self->aq_hw->mmio);
 -		kfree(self->aq_hw);
 -		pci_release_regions(pdev);
 -		free_netdev(self->ndev);
 -	}
 -
 -	pci_disable_device(pdev);
 -}
 -
 -static void aq_pci_shutdown(struct pci_dev *pdev)
 -{
 -	struct aq_nic_s *self = pci_get_drvdata(pdev);
 -
 -	aq_nic_shutdown(self);
 -
 -	pci_disable_device(pdev);
 -
 -	if (system_state == SYSTEM_POWER_OFF) {
 -		pci_wake_from_d3(pdev, false);
 -		pci_set_power_state(pdev, PCI_D3hot);
 -	}
 -}
 -
 -static int aq_pci_suspend(struct pci_dev *pdev, pm_message_t pm_msg)
 -{
 -	struct aq_nic_s *self = pci_get_drvdata(pdev);
 -
 -	return aq_nic_change_pm_state(self, &pm_msg);
 -}
 -
 -static int aq_pci_resume(struct pci_dev *pdev)
 -{
 -	struct aq_nic_s *self = pci_get_drvdata(pdev);
 -	pm_message_t pm_msg = PMSG_RESTORE;
 -
 -	return aq_nic_change_pm_state(self, &pm_msg);
 -}
 -
 -static struct pci_driver aq_pci_ops = {
 -	.name = AQ_CFG_DRV_NAME,
 -	.id_table = aq_pci_tbl,
 -	.probe = aq_pci_probe,
 -	.remove = aq_pci_remove,
 -	.suspend = aq_pci_suspend,
 -	.resume = aq_pci_resume,
 -	.shutdown = aq_pci_shutdown,
 -};
 -
 -module_pci_driver(aq_pci_ops);
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
index 06b1526703b5..ecbc61021804 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
@@ -108,6 +108,7 @@ int aq_nic_cfg_start(struct aq_nic_s *self)
 	/*rss rings */
 	cfg->vecs = min(cfg->vecs, cfg->aq_hw_caps->vecs);
 	cfg->vecs = min(cfg->vecs, num_online_cpus());
+	cfg->vecs = min(cfg->vecs, self->irqvecs);
 	/* cfg->vecs should be power of 2 for RSS */
 	if (cfg->vecs >= 8U)
 		cfg->vecs = 8U;
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_nic.h
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
