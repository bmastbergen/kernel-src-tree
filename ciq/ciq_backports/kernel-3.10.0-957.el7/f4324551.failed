bpf: add BPF_PROG_ATTACH and BPF_PROG_DETACH commands

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Daniel Mack <daniel@zonque.org>
commit f4324551489e8781d838f941b7aee4208e52e8bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f4324551.failed

Extend the bpf(2) syscall by two new commands, BPF_PROG_ATTACH and
BPF_PROG_DETACH which allow attaching and detaching eBPF programs
to a target.

On the API level, the target could be anything that has an fd in
userspace, hence the name of the field in union bpf_attr is called
'target_fd'.

When called with BPF_ATTACH_TYPE_CGROUP_INET_{E,IN}GRESS, the target is
expected to be a valid file descriptor of a cgroup v2 directory which
has the bpf controller enabled. These are the only use-cases
implemented by this patch at this point, but more can be added.

If a program of the given type already exists in the given cgroup,
the program is swapped automically, so userspace does not have to drop
an existing program first before installing a new one, which would
otherwise leave a gap in which no program is attached.

For more information on the propagation logic to subcgroups, please
refer to the bpf cgroup controller implementation.

The API is guarded by CAP_NET_ADMIN.

	Signed-off-by: Daniel Mack <daniel@zonque.org>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f4324551489e8781d838f941b7aee4208e52e8bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	kernel/bpf/syscall.c
diff --cc include/uapi/linux/bpf.h
index e369860b690e,1370a9d1456f..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -62,50 -63,18 +62,57 @@@ struct bpf_insn 
  	__s32	imm;		/* signed immediate constant */
  };
  
 -/* BPF syscall commands, see bpf(2) man-page for details. */
 +/* BPF syscall commands */
  enum bpf_cmd {
 +	/* create a map with given type and attributes
 +	 * fd = bpf(BPF_MAP_CREATE, union bpf_attr *, u32 size)
 +	 * returns fd or negative error
 +	 * map is deleted when fd is closed
 +	 */
  	BPF_MAP_CREATE,
 +
 +	/* verify and load eBPF program
 +	 * prog_fd = bpf(BPF_PROG_LOAD, union bpf_attr *attr, u32 size)
 +	 * Using attr->prog_type, attr->insns, attr->license
 +	 * returns fd or negative error
 +	 */
 +	BPF_PROG_LOAD,
++<<<<<<< HEAD
 +
 +	/* lookup key in a given map
 +	 * err = bpf(BPF_MAP_LOOKUP_ELEM, union bpf_attr *attr, u32 size)
 +	 * Using attr->map_fd, attr->key, attr->value
 +	 * returns zero and stores found elem into value
 +	 * or negative error
 +	 */
  	BPF_MAP_LOOKUP_ELEM,
 +
 +	/* create or update key/value pair in a given map
 +	 * err = bpf(BPF_MAP_UPDATE_ELEM, union bpf_attr *attr, u32 size)
 +	 * Using attr->map_fd, attr->key, attr->value
 +	 * returns zero or negative error
 +	 */
  	BPF_MAP_UPDATE_ELEM,
 +
 +	/* find and delete elem by key in a given map
 +	 * err = bpf(BPF_MAP_DELETE_ELEM, union bpf_attr *attr, u32 size)
 +	 * Using attr->map_fd, attr->key
 +	 * returns zero or negative error
 +	 */
  	BPF_MAP_DELETE_ELEM,
 +
 +	/* lookup key in a given map and return next key
 +	 * err = bpf(BPF_MAP_GET_NEXT_KEY, union bpf_attr *attr, u32 size)
 +	 * Using attr->map_fd, attr->key, attr->next_key
 +	 * returns zero and stores next key or negative error
 +	 */
  	BPF_MAP_GET_NEXT_KEY,
 -	BPF_PROG_LOAD,
++=======
+ 	BPF_OBJ_PIN,
+ 	BPF_OBJ_GET,
+ 	BPF_PROG_ATTACH,
+ 	BPF_PROG_DETACH,
++>>>>>>> f4324551489e (bpf: add BPF_PROG_ATTACH and BPF_PROG_DETACH commands)
  };
  
  enum bpf_map_type {
@@@ -132,9 -143,400 +139,15 @@@ union bpf_attr 
  			__aligned_u64 value;
  			__aligned_u64 next_key;
  		};
 -		__u64		flags;
 -	};
 -
 -	struct { /* anonymous struct used by BPF_PROG_LOAD command */
 -		__u32		prog_type;	/* one of enum bpf_prog_type */
 -		__u32		insn_cnt;
 -		__aligned_u64	insns;
 -		__aligned_u64	license;
 -		__u32		log_level;	/* verbosity level of verifier */
 -		__u32		log_size;	/* size of user buffer */
 -		__aligned_u64	log_buf;	/* user supplied buffer */
 -		__u32		kern_version;	/* checked when prog_type=kprobe */
 -	};
 -
 -	struct { /* anonymous struct used by BPF_OBJ_* commands */
 -		__aligned_u64	pathname;
 -		__u32		bpf_fd;
  	};
+ 
+ 	struct { /* anonymous struct used by BPF_PROG_ATTACH/DETACH commands */
+ 		__u32		target_fd;	/* container object to attach to */
+ 		__u32		attach_bpf_fd;	/* eBPF program to attach */
+ 		__u32		attach_type;
+ 	};
  } __attribute__((aligned(8)));
  
 -/* BPF helper function descriptions:
 - *
 - * void *bpf_map_lookup_elem(&map, &key)
 - *     Return: Map value or NULL
 - *
 - * int bpf_map_update_elem(&map, &key, &value, flags)
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_map_delete_elem(&map, &key)
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_probe_read(void *dst, int size, void *src)
 - *     Return: 0 on success or negative error
 - *
 - * u64 bpf_ktime_get_ns(void)
 - *     Return: current ktime
 - *
 - * int bpf_trace_printk(const char *fmt, int fmt_size, ...)
 - *     Return: length of buffer written or negative error
 - *
 - * u32 bpf_prandom_u32(void)
 - *     Return: random value
 - *
 - * u32 bpf_raw_smp_processor_id(void)
 - *     Return: SMP processor ID
 - *
 - * int bpf_skb_store_bytes(skb, offset, from, len, flags)
 - *     store bytes into packet
 - *     @skb: pointer to skb
 - *     @offset: offset within packet from skb->mac_header
 - *     @from: pointer where to copy bytes from
 - *     @len: number of bytes to store into packet
 - *     @flags: bit 0 - if true, recompute skb->csum
 - *             other bits - reserved
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_l3_csum_replace(skb, offset, from, to, flags)
 - *     recompute IP checksum
 - *     @skb: pointer to skb
 - *     @offset: offset within packet where IP checksum is located
 - *     @from: old value of header field
 - *     @to: new value of header field
 - *     @flags: bits 0-3 - size of header field
 - *             other bits - reserved
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_l4_csum_replace(skb, offset, from, to, flags)
 - *     recompute TCP/UDP checksum
 - *     @skb: pointer to skb
 - *     @offset: offset within packet where TCP/UDP checksum is located
 - *     @from: old value of header field
 - *     @to: new value of header field
 - *     @flags: bits 0-3 - size of header field
 - *             bit 4 - is pseudo header
 - *             other bits - reserved
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_tail_call(ctx, prog_array_map, index)
 - *     jump into another BPF program
 - *     @ctx: context pointer passed to next program
 - *     @prog_array_map: pointer to map which type is BPF_MAP_TYPE_PROG_ARRAY
 - *     @index: index inside array that selects specific program to run
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_clone_redirect(skb, ifindex, flags)
 - *     redirect to another netdev
 - *     @skb: pointer to skb
 - *     @ifindex: ifindex of the net device
 - *     @flags: bit 0 - if set, redirect to ingress instead of egress
 - *             other bits - reserved
 - *     Return: 0 on success or negative error
 - *
 - * u64 bpf_get_current_pid_tgid(void)
 - *     Return: current->tgid << 32 | current->pid
 - *
 - * u64 bpf_get_current_uid_gid(void)
 - *     Return: current_gid << 32 | current_uid
 - *
 - * int bpf_get_current_comm(char *buf, int size_of_buf)
 - *     stores current->comm into buf
 - *     Return: 0 on success or negative error
 - *
 - * u32 bpf_get_cgroup_classid(skb)
 - *     retrieve a proc's classid
 - *     @skb: pointer to skb
 - *     Return: classid if != 0
 - *
 - * int bpf_skb_vlan_push(skb, vlan_proto, vlan_tci)
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_skb_vlan_pop(skb)
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_skb_get_tunnel_key(skb, key, size, flags)
 - * int bpf_skb_set_tunnel_key(skb, key, size, flags)
 - *     retrieve or populate tunnel metadata
 - *     @skb: pointer to skb
 - *     @key: pointer to 'struct bpf_tunnel_key'
 - *     @size: size of 'struct bpf_tunnel_key'
 - *     @flags: room for future extensions
 - *     Return: 0 on success or negative error
 - *
 - * u64 bpf_perf_event_read(&map, index)
 - *     Return: Number events read or error code
 - *
 - * int bpf_redirect(ifindex, flags)
 - *     redirect to another netdev
 - *     @ifindex: ifindex of the net device
 - *     @flags: bit 0 - if set, redirect to ingress instead of egress
 - *             other bits - reserved
 - *     Return: TC_ACT_REDIRECT
 - *
 - * u32 bpf_get_route_realm(skb)
 - *     retrieve a dst's tclassid
 - *     @skb: pointer to skb
 - *     Return: realm if != 0
 - *
 - * int bpf_perf_event_output(ctx, map, index, data, size)
 - *     output perf raw sample
 - *     @ctx: struct pt_regs*
 - *     @map: pointer to perf_event_array map
 - *     @index: index of event in the map
 - *     @data: data on stack to be output as raw data
 - *     @size: size of data
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_get_stackid(ctx, map, flags)
 - *     walk user or kernel stack and return id
 - *     @ctx: struct pt_regs*
 - *     @map: pointer to stack_trace map
 - *     @flags: bits 0-7 - numer of stack frames to skip
 - *             bit 8 - collect user stack instead of kernel
 - *             bit 9 - compare stacks by hash only
 - *             bit 10 - if two different stacks hash into the same stackid
 - *                      discard old
 - *             other bits - reserved
 - *     Return: >= 0 stackid on success or negative error
 - *
 - * s64 bpf_csum_diff(from, from_size, to, to_size, seed)
 - *     calculate csum diff
 - *     @from: raw from buffer
 - *     @from_size: length of from buffer
 - *     @to: raw to buffer
 - *     @to_size: length of to buffer
 - *     @seed: optional seed
 - *     Return: csum result or negative error code
 - *
 - * int bpf_skb_get_tunnel_opt(skb, opt, size)
 - *     retrieve tunnel options metadata
 - *     @skb: pointer to skb
 - *     @opt: pointer to raw tunnel option data
 - *     @size: size of @opt
 - *     Return: option size
 - *
 - * int bpf_skb_set_tunnel_opt(skb, opt, size)
 - *     populate tunnel options metadata
 - *     @skb: pointer to skb
 - *     @opt: pointer to raw tunnel option data
 - *     @size: size of @opt
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_skb_change_proto(skb, proto, flags)
 - *     Change protocol of the skb. Currently supported is v4 -> v6,
 - *     v6 -> v4 transitions. The helper will also resize the skb. eBPF
 - *     program is expected to fill the new headers via skb_store_bytes
 - *     and lX_csum_replace.
 - *     @skb: pointer to skb
 - *     @proto: new skb->protocol type
 - *     @flags: reserved
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_skb_change_type(skb, type)
 - *     Change packet type of skb.
 - *     @skb: pointer to skb
 - *     @type: new skb->pkt_type type
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_skb_under_cgroup(skb, map, index)
 - *     Check cgroup2 membership of skb
 - *     @skb: pointer to skb
 - *     @map: pointer to bpf_map in BPF_MAP_TYPE_CGROUP_ARRAY type
 - *     @index: index of the cgroup in the bpf_map
 - *     Return:
 - *       == 0 skb failed the cgroup2 descendant test
 - *       == 1 skb succeeded the cgroup2 descendant test
 - *        < 0 error
 - *
 - * u32 bpf_get_hash_recalc(skb)
 - *     Retrieve and possibly recalculate skb->hash.
 - *     @skb: pointer to skb
 - *     Return: hash
 - *
 - * u64 bpf_get_current_task(void)
 - *     Returns current task_struct
 - *     Return: current
 - *
 - * int bpf_probe_write_user(void *dst, void *src, int len)
 - *     safely attempt to write to a location
 - *     @dst: destination address in userspace
 - *     @src: source address on stack
 - *     @len: number of bytes to copy
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_current_task_under_cgroup(map, index)
 - *     Check cgroup2 membership of current task
 - *     @map: pointer to bpf_map in BPF_MAP_TYPE_CGROUP_ARRAY type
 - *     @index: index of the cgroup in the bpf_map
 - *     Return:
 - *       == 0 current failed the cgroup2 descendant test
 - *       == 1 current succeeded the cgroup2 descendant test
 - *        < 0 error
 - *
 - * int bpf_skb_change_tail(skb, len, flags)
 - *     The helper will resize the skb to the given new size, to be used f.e.
 - *     with control messages.
 - *     @skb: pointer to skb
 - *     @len: new skb length
 - *     @flags: reserved
 - *     Return: 0 on success or negative error
 - *
 - * int bpf_skb_pull_data(skb, len)
 - *     The helper will pull in non-linear data in case the skb is non-linear
 - *     and not all of len are part of the linear section. Only needed for
 - *     read/write with direct packet access.
 - *     @skb: pointer to skb
 - *     @len: len to make read/writeable
 - *     Return: 0 on success or negative error
 - *
 - * s64 bpf_csum_update(skb, csum)
 - *     Adds csum into skb->csum in case of CHECKSUM_COMPLETE.
 - *     @skb: pointer to skb
 - *     @csum: csum to add
 - *     Return: csum on success or negative error
 - *
 - * void bpf_set_hash_invalid(skb)
 - *     Invalidate current skb->hash.
 - *     @skb: pointer to skb
 - *
 - * int bpf_get_numa_node_id()
 - *     Return: Id of current NUMA node.
 - */
 -#define __BPF_FUNC_MAPPER(FN)		\
 -	FN(unspec),			\
 -	FN(map_lookup_elem),		\
 -	FN(map_update_elem),		\
 -	FN(map_delete_elem),		\
 -	FN(probe_read),			\
 -	FN(ktime_get_ns),		\
 -	FN(trace_printk),		\
 -	FN(get_prandom_u32),		\
 -	FN(get_smp_processor_id),	\
 -	FN(skb_store_bytes),		\
 -	FN(l3_csum_replace),		\
 -	FN(l4_csum_replace),		\
 -	FN(tail_call),			\
 -	FN(clone_redirect),		\
 -	FN(get_current_pid_tgid),	\
 -	FN(get_current_uid_gid),	\
 -	FN(get_current_comm),		\
 -	FN(get_cgroup_classid),		\
 -	FN(skb_vlan_push),		\
 -	FN(skb_vlan_pop),		\
 -	FN(skb_get_tunnel_key),		\
 -	FN(skb_set_tunnel_key),		\
 -	FN(perf_event_read),		\
 -	FN(redirect),			\
 -	FN(get_route_realm),		\
 -	FN(perf_event_output),		\
 -	FN(skb_load_bytes),		\
 -	FN(get_stackid),		\
 -	FN(csum_diff),			\
 -	FN(skb_get_tunnel_opt),		\
 -	FN(skb_set_tunnel_opt),		\
 -	FN(skb_change_proto),		\
 -	FN(skb_change_type),		\
 -	FN(skb_under_cgroup),		\
 -	FN(get_hash_recalc),		\
 -	FN(get_current_task),		\
 -	FN(probe_write_user),		\
 -	FN(current_task_under_cgroup),	\
 -	FN(skb_change_tail),		\
 -	FN(skb_pull_data),		\
 -	FN(csum_update),		\
 -	FN(set_hash_invalid),		\
 -	FN(get_numa_node_id),
 -
 -/* integer value in 'imm' field of BPF_CALL instruction selects which helper
 - * function eBPF program intends to call
 - */
 -#define __BPF_ENUM_FN(x) BPF_FUNC_ ## x
 -enum bpf_func_id {
 -	__BPF_FUNC_MAPPER(__BPF_ENUM_FN)
 -	__BPF_FUNC_MAX_ID,
 -};
 -#undef __BPF_ENUM_FN
 -
 -/* All flags used by eBPF helper functions, placed here. */
 -
 -/* BPF_FUNC_skb_store_bytes flags. */
 -#define BPF_F_RECOMPUTE_CSUM		(1ULL << 0)
 -#define BPF_F_INVALIDATE_HASH		(1ULL << 1)
 -
 -/* BPF_FUNC_l3_csum_replace and BPF_FUNC_l4_csum_replace flags.
 - * First 4 bits are for passing the header field size.
 - */
 -#define BPF_F_HDR_FIELD_MASK		0xfULL
 -
 -/* BPF_FUNC_l4_csum_replace flags. */
 -#define BPF_F_PSEUDO_HDR		(1ULL << 4)
 -#define BPF_F_MARK_MANGLED_0		(1ULL << 5)
 -
 -/* BPF_FUNC_clone_redirect and BPF_FUNC_redirect flags. */
 -#define BPF_F_INGRESS			(1ULL << 0)
 -
 -/* BPF_FUNC_skb_set_tunnel_key and BPF_FUNC_skb_get_tunnel_key flags. */
 -#define BPF_F_TUNINFO_IPV6		(1ULL << 0)
 -
 -/* BPF_FUNC_get_stackid flags. */
 -#define BPF_F_SKIP_FIELD_MASK		0xffULL
 -#define BPF_F_USER_STACK		(1ULL << 8)
 -#define BPF_F_FAST_STACK_CMP		(1ULL << 9)
 -#define BPF_F_REUSE_STACKID		(1ULL << 10)
 -
 -/* BPF_FUNC_skb_set_tunnel_key flags. */
 -#define BPF_F_ZERO_CSUM_TX		(1ULL << 1)
 -#define BPF_F_DONT_FRAGMENT		(1ULL << 2)
 -
 -/* BPF_FUNC_perf_event_output and BPF_FUNC_perf_event_read flags. */
 -#define BPF_F_INDEX_MASK		0xffffffffULL
 -#define BPF_F_CURRENT_CPU		BPF_F_INDEX_MASK
 -/* BPF_FUNC_perf_event_output for sk_buff input context. */
 -#define BPF_F_CTXLEN_MASK		(0xfffffULL << 32)
 -
 -/* user accessible mirror of in-kernel sk_buff.
 - * new fields can only be added to the end of this structure
 - */
 -struct __sk_buff {
 -	__u32 len;
 -	__u32 pkt_type;
 -	__u32 mark;
 -	__u32 queue_mapping;
 -	__u32 protocol;
 -	__u32 vlan_present;
 -	__u32 vlan_tci;
 -	__u32 vlan_proto;
 -	__u32 priority;
 -	__u32 ingress_ifindex;
 -	__u32 ifindex;
 -	__u32 tc_index;
 -	__u32 cb[5];
 -	__u32 hash;
 -	__u32 tc_classid;
 -	__u32 data;
 -	__u32 data_end;
 -};
 -
 -struct bpf_tunnel_key {
 -	__u32 tunnel_id;
 -	union {
 -		__u32 remote_ipv4;
 -		__u32 remote_ipv6[4];
 -	};
 -	__u8 tunnel_tos;
 -	__u8 tunnel_ttl;
 -	__u16 tunnel_ext;
 -	__u32 tunnel_label;
 -};
 -
  /* User return codes for XDP prog type.
   * A valid XDP program must return one of these defined values. All other
   * return codes are reserved for future use. Unknown return codes will result
* Unmerged path kernel/bpf/syscall.c
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path kernel/bpf/syscall.c
