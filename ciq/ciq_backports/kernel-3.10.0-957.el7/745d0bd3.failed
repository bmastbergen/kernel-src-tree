e1000e: Remove Other from EIAC

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Benjamin Poirier <bpoirier@suse.com>
commit 745d0bd3af99ccc8c5f5822f808cd133eadad6ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/745d0bd3.failed

It was reported that emulated e1000e devices in vmware esxi 6.5 Build
7526125 do not link up after commit 4aea7a5c5e94 ("e1000e: Avoid receiver
overrun interrupt bursts", v4.15-rc1). Some tracing shows that after
e1000e_trigger_lsc() is called, ICR reads out as 0x0 in e1000_msix_other()
on emulated e1000e devices. In comparison, on real e1000e 82574 hardware,
icr=0x80000004 (_INT_ASSERTED | _LSC) in the same situation.

Some experimentation showed that this flaw in vmware e1000e emulation can
be worked around by not setting Other in EIAC. This is how it was before
16ecba59bc33 ("e1000e: Do not read ICR in Other interrupt", v4.5-rc1).

Fixes: 4aea7a5c5e94 ("e1000e: Avoid receiver overrun interrupt bursts")
	Signed-off-by: Benjamin Poirier <bpoirier@suse.com>
	Tested-by: Aaron Brown <aaron.f.brown@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 745d0bd3af99ccc8c5f5822f808cd133eadad6ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/e1000e/netdev.c
diff --cc drivers/net/ethernet/intel/e1000e/netdev.c
index b81ce07a75e5,153ad406c65e..000000000000
--- a/drivers/net/ethernet/intel/e1000e/netdev.c
+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
@@@ -1913,14 -1914,32 +1913,37 @@@ static irqreturn_t e1000_msix_other(in
  	struct net_device *netdev = data;
  	struct e1000_adapter *adapter = netdev_priv(netdev);
  	struct e1000_hw *hw = &adapter->hw;
 -	u32 icr;
 -	bool enable = true;
  
++<<<<<<< HEAD
 +	hw->mac.get_link_status = true;
++=======
+ 	icr = er32(ICR);
+ 	ew32(ICR, E1000_ICR_OTHER);
+ 
+ 	if (icr & E1000_ICR_RXO) {
+ 		ew32(ICR, E1000_ICR_RXO);
+ 		enable = false;
+ 		/* napi poll will re-enable Other, make sure it runs */
+ 		if (napi_schedule_prep(&adapter->napi)) {
+ 			adapter->total_rx_bytes = 0;
+ 			adapter->total_rx_packets = 0;
+ 			__napi_schedule(&adapter->napi);
+ 		}
+ 	}
+ 	if (icr & E1000_ICR_LSC) {
+ 		ew32(ICR, E1000_ICR_LSC);
+ 		hw->mac.get_link_status = true;
+ 		/* guard against interrupt when we're going down */
+ 		if (!test_bit(__E1000_DOWN, &adapter->state))
+ 			mod_timer(&adapter->watchdog_timer, jiffies + 1);
+ 	}
++>>>>>>> 745d0bd3af99 (e1000e: Remove Other from EIAC)
  
 -	if (enable && !test_bit(__E1000_DOWN, &adapter->state))
 +	/* guard against interrupt when we're going down */
 +	if (!test_bit(__E1000_DOWN, &adapter->state)) {
 +		mod_timer(&adapter->watchdog_timer, jiffies + 1);
  		ew32(IMS, E1000_IMS_OTHER);
 +	}
  
  	return IRQ_HANDLED;
  }
* Unmerged path drivers/net/ethernet/intel/e1000e/netdev.c
