dax: check for QUEUE_FLAG_DAX in bdev_dax_supported()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ross Zwisler <ross.zwisler@linux.intel.com>
commit 15256f6cc4b44f2e70503758150267fd2a53c0d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/15256f6c.failed

Add an explicit check for QUEUE_FLAG_DAX to __bdev_dax_supported().  This
is needed for DM configurations where the first element in the dm-linear or
dm-stripe target supports DAX, but other elements do not.  Without this
check __bdev_dax_supported() will pass for such devices, letting a
filesystem on that device mount with the DAX option.

	Signed-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Suggested-by: Mike Snitzer <snitzer@redhat.com>
Fixes: commit 545ed20e6df6 ("dm: add infrastructure for DAX support")
	Cc: stable@vger.kernel.org
	Acked-by: Dan Williams <dan.j.williams@intel.com>
	Reviewed-by: Toshi Kani <toshi.kani@hpe.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 15256f6cc4b44f2e70503758150267fd2a53c0d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dax/super.c
diff --cc drivers/dax/super.c
index 41efc362f7f7,45276abf03aa..000000000000
--- a/drivers/dax/super.c
+++ b/drivers/dax/super.c
@@@ -70,29 -80,38 +70,41 @@@ EXPORT_SYMBOL(bdev_dax_pgoff)
   * This is a library function for filesystems to check if the block device
   * can be mounted with dax option.
   *
 - * Return: true if supported, false if unsupported
 + * Return: negative errno if unsupported, 0 if supported.
   */
 -bool __bdev_dax_supported(struct block_device *bdev, int blocksize)
 +int __bdev_dax_supported(struct super_block *sb, int blocksize)
  {
 +	struct block_device *bdev = sb->s_bdev;
  	struct dax_device *dax_dev;
++<<<<<<< HEAD
++=======
+ 	bool dax_enabled = false;
+ 	struct request_queue *q;
++>>>>>>> 15256f6cc4b4 (dax: check for QUEUE_FLAG_DAX in bdev_dax_supported())
  	pgoff_t pgoff;
  	int err, id;
  	void *kaddr;
  	pfn_t pfn;
  	long len;
 -	char buf[BDEVNAME_SIZE];
  
  	if (blocksize != PAGE_SIZE) {
 -		pr_debug("%s: error: unsupported blocksize for dax\n",
 -				bdevname(bdev, buf));
 -		return false;
 +		pr_err("VFS (%s): error: unsupported blocksize for dax\n",
 +				sb->s_id);
 +		return -EINVAL;
  	}
  
+ 	q = bdev_get_queue(bdev);
+ 	if (!q || !blk_queue_dax(q)) {
+ 		pr_debug("%s: error: request queue doesn't support dax\n",
+ 				bdevname(bdev, buf));
+ 		return false;
+ 	}
+ 
  	err = bdev_dax_pgoff(bdev, 0, PAGE_SIZE, &pgoff);
  	if (err) {
 -		pr_debug("%s: error: unaligned partition for dax\n",
 -				bdevname(bdev, buf));
 -		return false;
 +		pr_err("VFS (%s): error: unaligned partition for dax\n",
 +				sb->s_id);
 +		return err;
  	}
  
  	dax_dev = dax_get_by_host(bdev->bd_disk->disk_name);
* Unmerged path drivers/dax/super.c
