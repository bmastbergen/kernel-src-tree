netfilter: ipset: For set:list types, replaced elements must be zeroed out

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 8ec81f9a4db94fa5638c55793365b896dd9daecc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8ec81f9a.failed

The new extensions require zero initialization for the new element
to be added into a slot from where another element was pushed away.

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 8ec81f9a4db94fa5638c55793365b896dd9daecc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_list_set.c
diff --cc net/netfilter/ipset/ip_set_list_set.c
index a9a97c07ecb4,e23f33c14435..000000000000
--- a/net/netfilter/ipset/ip_set_list_set.c
+++ b/net/netfilter/ipset/ip_set_list_set.c
@@@ -200,28 -166,36 +200,45 @@@ list_set_add(struct ip_set *set, u32 i
  	     const struct ip_set_ext *ext)
  {
  	struct list_set *map = set->data;
 -	struct set_elem *e = list_set_elem(set, map, i);
 +	struct set_elem *e = list_set_elem(map, i);
  
  	if (e->id != IPSET_INVALID_ID) {
 -		if (i == map->size - 1) {
 +		if (i == map->size - 1)
  			/* Last element replaced: e.g. add new,before,last */
 -			ip_set_put_byindex(e->id);
 -			ip_set_ext_destroy(set, e);
 -		} else {
 -			struct set_elem *x = list_set_elem(set, map,
 -							   map->size - 1);
 +			ip_set_put_byindex(map->net, e->id);
 +		else {
 +			struct set_elem *x = list_set_elem(map, map->size - 1);
  
  			/* Last element pushed off */
++<<<<<<< HEAD
 +			if (x->id != IPSET_INVALID_ID)
 +				ip_set_put_byindex(map->net, x->id);
 +			memmove(list_set_elem(map, i + 1), e,
 +				map->dsize * (map->size - (i + 1)));
++=======
+ 			if (x->id != IPSET_INVALID_ID) {
+ 				ip_set_put_byindex(x->id);
+ 				ip_set_ext_destroy(set, x);
+ 			}
+ 			memmove(list_set_elem(set, map, i + 1), e,
+ 				set->dsize * (map->size - (i + 1)));
+ 			/* Extensions must be initialized to zero */
+ 			memset(e, 0, set->dsize);
++>>>>>>> 8ec81f9a4db9 (netfilter: ipset: For set:list types, replaced elements must be zeroed out)
  		}
  	}
  
  	e->id = d->id;
  	if (SET_WITH_TIMEOUT(set))
 -		ip_set_timeout_set(ext_timeout(e, set), ext->timeout);
 +		ip_set_timeout_set(ext_timeout(e, map), ext->timeout);
  	if (SET_WITH_COUNTER(set))
++<<<<<<< HEAD
 +		ip_set_init_counter(ext_counter(e, map), ext);
++=======
+ 		ip_set_init_counter(ext_counter(e, set), ext);
+ 	if (SET_WITH_COMMENT(set))
+ 		ip_set_init_comment(ext_comment(e, set), ext);
++>>>>>>> 8ec81f9a4db9 (netfilter: ipset: For set:list types, replaced elements must be zeroed out)
  	return 0;
  }
  
* Unmerged path net/netfilter/ipset/ip_set_list_set.c
