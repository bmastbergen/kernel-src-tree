sctp: do not abandon the other frags in unsent outq if one msg has outstanding frags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit 779edd7348878a7376c0e3d0f96485c30b5f1b7d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/779edd73.failed

Now for the abandoned chunks in unsent outq, it would just free the chunks.
Because no tsn is assigned to them yet, there's no need to send fwd tsn to
peer, unlike for the abandoned chunks in sent outq.

The problem is when parts of the msg have been sent and the other frags
are still in unsent outq, if they are abandoned/dropped, the peer would
never get this msg reassembled.

So these frags in unsent outq can't be dropped if this msg already has
outstanding frags.

This patch does the check in sctp_chunk_abandoned and
sctp_prsctp_prune_unsent.

	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 779edd7348878a7376c0e3d0f96485c30b5f1b7d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/chunk.c
#	net/sctp/outqueue.c
diff --cc net/sctp/chunk.c
index b2433e21ed45,7f8baa48e7c2..000000000000
--- a/net/sctp/chunk.c
+++ b/net/sctp/chunk.c
@@@ -354,12 -305,26 +354,22 @@@ int sctp_chunk_abandoned(struct sctp_ch
  	if (!chunk->asoc->peer.prsctp_capable)
  		return 0;
  
++<<<<<<< HEAD
++=======
+ 	if (chunk->msg->abandoned)
+ 		return 1;
+ 
+ 	if (!chunk->has_tsn &&
+ 	    !(chunk->chunk_hdr->flags & SCTP_DATA_FIRST_FRAG))
+ 		return 0;
+ 
++>>>>>>> 779edd734887 (sctp: do not abandon the other frags in unsent outq if one msg has outstanding frags)
  	if (SCTP_PR_TTL_ENABLED(chunk->sinfo.sinfo_flags) &&
  	    time_after(jiffies, chunk->msg->expires_at)) {
 -		struct sctp_stream_out *streamout =
 -			&chunk->asoc->stream.out[chunk->sinfo.sinfo_stream];
 -
 -		if (chunk->sent_count) {
 +		if (chunk->sent_count)
  			chunk->asoc->abandoned_sent[SCTP_PR_INDEX(TTL)]++;
 -			streamout->ext->abandoned_sent[SCTP_PR_INDEX(TTL)]++;
 -		} else {
 +		else
  			chunk->asoc->abandoned_unsent[SCTP_PR_INDEX(TTL)]++;
 -			streamout->ext->abandoned_unsent[SCTP_PR_INDEX(TTL)]++;
 -		}
 -		chunk->msg->abandoned = 1;
  		return 1;
  	} else if (SCTP_PR_RTX_ENABLED(chunk->sinfo.sinfo_flags) &&
  		   chunk->sent_count > chunk->sinfo.sinfo_timetolive) {
diff --cc net/sctp/outqueue.c
index 4dc8a54e8836,7d67feeeffc1..000000000000
--- a/net/sctp/outqueue.c
+++ b/net/sctp/outqueue.c
@@@ -395,15 -403,25 +395,22 @@@ static int sctp_prsctp_prune_unsent(str
  	struct sctp_outq *q = &asoc->outqueue;
  	struct sctp_chunk *chk, *temp;
  
 -	q->sched->unsched_all(&asoc->stream);
 -
  	list_for_each_entry_safe(chk, temp, &q->out_chunk_list, list) {
++<<<<<<< HEAD
 +		if (!SCTP_PR_PRIO_ENABLED(chk->sinfo.sinfo_flags) ||
 +		    chk->sinfo.sinfo_timetolive <= sinfo->sinfo_timetolive)
++=======
+ 		if (!chk->msg->abandoned &&
+ 		    (!(chk->chunk_hdr->flags & SCTP_DATA_FIRST_FRAG) ||
+ 		     !SCTP_PR_PRIO_ENABLED(chk->sinfo.sinfo_flags) ||
+ 		     chk->sinfo.sinfo_timetolive <= sinfo->sinfo_timetolive))
++>>>>>>> 779edd734887 (sctp: do not abandon the other frags in unsent outq if one msg has outstanding frags)
  			continue;
  
 -		chk->msg->abandoned = 1;
 -		sctp_sched_dequeue_common(q, chk);
 +		list_del_init(&chk->list);
 +		q->out_qlen -= chk->skb->len;
  		asoc->sent_cnt_removable--;
  		asoc->abandoned_unsent[SCTP_PR_INDEX(PRIO)]++;
 -		if (chk->sinfo.sinfo_stream < asoc->stream.outcnt) {
 -			struct sctp_stream_out *streamout =
 -				&asoc->stream.out[chk->sinfo.sinfo_stream];
 -
 -			streamout->ext->abandoned_unsent[SCTP_PR_INDEX(PRIO)]++;
 -		}
  
  		msg_len -= SCTP_DATA_SNDSIZE(chk) +
  			   sizeof(struct sk_buff) +
* Unmerged path net/sctp/chunk.c
* Unmerged path net/sctp/outqueue.c
