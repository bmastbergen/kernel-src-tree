iio: buffer: Move iio_buffer_alloc_sysfs and iio_buffer_free_sysfs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iio] buffer: Move iio_buffer_alloc_sysfs and iio_buffer_free_sysfs (Tony Camuso) [1559170]
Rebuild_FUZZ: 96.06%
commit-author Lars-Peter Clausen <lars@metafoo.de>
commit d967cb6bd4e79c0cd7b150f1382d3d04e00408a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d967cb6b.failed

The next patch will introduce new dependencies in iio_buffer_alloc_sysfs()
to functions which are currently defined after iio_buffer_alloc_sysfs(). To
avoid forward declarations move both iio_buffer_alloc_sysfs() and
iio_buffer_free_sysfs() after those function.

This is split into two patches one moving the functions and one adding the
dependencies to make review of the actual changes easier.

	Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit d967cb6bd4e79c0cd7b150f1382d3d04e00408a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iio/industrialio-buffer.c
diff --cc drivers/iio/industrialio-buffer.c
index 5ef822987c05,8cd89eb269c5..000000000000
--- a/drivers/iio/industrialio-buffer.c
+++ b/drivers/iio/industrialio-buffer.c
@@@ -379,103 -377,12 +379,106 @@@ static int iio_buffer_add_channel_sysfs
  					     &indio_dev->dev,
  					     &buffer->scan_el_dev_attr_list);
  	if (ret)
 -		return ret;
 +		goto error_ret;
  	attrcount++;
  	ret = attrcount;
 +error_ret:
 +	return ret;
 +}
 +
++<<<<<<< HEAD
 +static const char * const iio_scan_elements_group_name = "scan_elements";
 +
 +int iio_buffer_register(struct iio_dev *indio_dev,
 +			const struct iio_chan_spec *channels,
 +			int num_channels)
 +{
 +	struct iio_dev_attr *p;
 +	struct attribute **attr;
 +	struct iio_buffer *buffer = indio_dev->buffer;
 +	int ret, i, attrn, attrcount, attrcount_orig = 0;
 +
 +	if (buffer->attrs)
 +		indio_dev->groups[indio_dev->groupcounter++] = buffer->attrs;
 +
 +	if (buffer->scan_el_attrs != NULL) {
 +		attr = buffer->scan_el_attrs->attrs;
 +		while (*attr++ != NULL)
 +			attrcount_orig++;
 +	}
 +	attrcount = attrcount_orig;
 +	INIT_LIST_HEAD(&buffer->scan_el_dev_attr_list);
 +	if (channels) {
 +		/* new magic */
 +		for (i = 0; i < num_channels; i++) {
 +			if (channels[i].scan_index < 0)
 +				continue;
 +
 +			/* Establish necessary mask length */
 +			if (channels[i].scan_index >
 +			    (int)indio_dev->masklength - 1)
 +				indio_dev->masklength
 +					= channels[i].scan_index + 1;
 +
 +			ret = iio_buffer_add_channel_sysfs(indio_dev,
 +							 &channels[i]);
 +			if (ret < 0)
 +				goto error_cleanup_dynamic;
 +			attrcount += ret;
 +			if (channels[i].type == IIO_TIMESTAMP)
 +				indio_dev->scan_index_timestamp =
 +					channels[i].scan_index;
 +		}
 +		if (indio_dev->masklength && buffer->scan_mask == NULL) {
 +			buffer->scan_mask = kcalloc(BITS_TO_LONGS(indio_dev->masklength),
 +						    sizeof(*buffer->scan_mask),
 +						    GFP_KERNEL);
 +			if (buffer->scan_mask == NULL) {
 +				ret = -ENOMEM;
 +				goto error_cleanup_dynamic;
 +			}
 +		}
 +	}
 +
 +	buffer->scan_el_group.name = iio_scan_elements_group_name;
 +
 +	buffer->scan_el_group.attrs = kcalloc(attrcount + 1,
 +					      sizeof(buffer->scan_el_group.attrs[0]),
 +					      GFP_KERNEL);
 +	if (buffer->scan_el_group.attrs == NULL) {
 +		ret = -ENOMEM;
 +		goto error_free_scan_mask;
 +	}
 +	if (buffer->scan_el_attrs)
 +		memcpy(buffer->scan_el_group.attrs, buffer->scan_el_attrs,
 +		       sizeof(buffer->scan_el_group.attrs[0])*attrcount_orig);
 +	attrn = attrcount_orig;
 +
 +	list_for_each_entry(p, &buffer->scan_el_dev_attr_list, l)
 +		buffer->scan_el_group.attrs[attrn++] = &p->dev_attr.attr;
 +	indio_dev->groups[indio_dev->groupcounter++] = &buffer->scan_el_group;
 +
 +	return 0;
 +
 +error_free_scan_mask:
 +	kfree(buffer->scan_mask);
 +error_cleanup_dynamic:
 +	iio_free_chan_devattr_list(&buffer->scan_el_dev_attr_list);
 +
  	return ret;
  }
 +EXPORT_SYMBOL(iio_buffer_register);
  
 +void iio_buffer_unregister(struct iio_dev *indio_dev)
 +{
 +	kfree(indio_dev->buffer->scan_mask);
 +	kfree(indio_dev->buffer->scan_el_group.attrs);
 +	iio_free_chan_devattr_list(&indio_dev->buffer->scan_el_dev_attr_list);
 +}
 +EXPORT_SYMBOL(iio_buffer_unregister);
 +
++=======
++>>>>>>> d967cb6bd4e7 (iio: buffer: Move iio_buffer_alloc_sysfs and iio_buffer_free_sysfs)
  ssize_t iio_buffer_read_length(struct device *dev,
  			       struct device_attribute *attr,
  			       char *buf)
* Unmerged path drivers/iio/industrialio-buffer.c
