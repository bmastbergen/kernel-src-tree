netfilter: ipset: Optimize hash creation routine

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 961509ac183ec1069616541938728fcb822f5dff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/961509ac.failed

Exit as easly as possible on error and use RCU_INIT_POINTER()
as set is not seen at creation time.

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 961509ac183ec1069616541938728fcb822f5dff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_hash_gen.h
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 9ce28af662bf,de1d16fd4121..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -954,14 -1238,15 +954,23 @@@ IPSET_TOKEN(HTYPE, _create)(struct net 
  	u8 netmask;
  #endif
  	size_t hsize;
 -	struct htype *h;
 -	struct htable *t;
 +	struct HTYPE *h;
  
++<<<<<<< HEAD
 +	if (!(set->family == NFPROTO_IPV4 || set->family == NFPROTO_IPV6))
 +		return -IPSET_ERR_INVALID_FAMILY;
 +#ifdef IP_SET_HASH_WITH_NETMASK
 +	netmask = set->family == NFPROTO_IPV4 ? 32 : 128;
 +	pr_debug("Create set %s with family %s\n",
 +		 set->name, set->family == NFPROTO_IPV4 ? "inet" : "inet6");
++=======
+ 	pr_debug("Create set %s with family %s\n",
+ 		 set->name, set->family == NFPROTO_IPV4 ? "inet" : "inet6");
+ 
+ #ifndef IP_SET_PROTO_UNDEF
+ 	if (!(set->family == NFPROTO_IPV4 || set->family == NFPROTO_IPV6))
+ 		return -IPSET_ERR_INVALID_FAMILY;
++>>>>>>> 961509ac183e (netfilter: ipset: Optimize hash creation routine)
  #endif
  
  	if (unlikely(!ip_set_optattr_netorder(tb, IPSET_ATTR_HASHSIZE) ||
@@@ -969,6 -1254,31 +978,34 @@@
  		     !ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||
  		     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))
  		return -IPSET_ERR_PROTOCOL;
++<<<<<<< HEAD
++=======
+ 
+ #ifdef IP_SET_HASH_WITH_MARKMASK
+ 	/* Separated condition in order to avoid directive in argument list */
+ 	if (unlikely(!ip_set_optattr_netorder(tb, IPSET_ATTR_MARKMASK)))
+ 		return -IPSET_ERR_PROTOCOL;
+ 
+ 	markmask = 0xffffffff;
+ 	if (tb[IPSET_ATTR_MARKMASK]) {
+ 		markmask = ntohl(nla_get_be32(tb[IPSET_ATTR_MARKMASK]));
+ 		if (markmask == 0)
+ 			return -IPSET_ERR_INVALID_MARKMASK;
+ 	}
+ #endif
+ 
+ #ifdef IP_SET_HASH_WITH_NETMASK
+ 	netmask = set->family == NFPROTO_IPV4 ? 32 : 128;
+ 	if (tb[IPSET_ATTR_NETMASK]) {
+ 		netmask = nla_get_u8(tb[IPSET_ATTR_NETMASK]);
+ 
+ 		if ((set->family == NFPROTO_IPV4 && netmask > 32) ||
+ 		    (set->family == NFPROTO_IPV6 && netmask > 128) ||
+ 		    netmask == 0)
+ 			return -IPSET_ERR_INVALID_NETMASK;
+ 	}
+ #endif
++>>>>>>> 961509ac183e (netfilter: ipset: Optimize hash creation routine)
  
  	if (tb[IPSET_ATTR_HASHSIZE]) {
  		hashsize = ip_set_get_h32(tb[IPSET_ATTR_HASHSIZE]);
@@@ -979,32 -1289,14 +1016,38 @@@
  	if (tb[IPSET_ATTR_MAXELEM])
  		maxelem = ip_set_get_h32(tb[IPSET_ATTR_MAXELEM]);
  
++<<<<<<< HEAD
 +#ifdef IP_SET_HASH_WITH_NETMASK
 +	if (tb[IPSET_ATTR_NETMASK]) {
 +		netmask = nla_get_u8(tb[IPSET_ATTR_NETMASK]);
 +
 +		if ((set->family == NFPROTO_IPV4 && netmask > 32) ||
 +		    (set->family == NFPROTO_IPV6 && netmask > 128) ||
 +		    netmask == 0)
 +			return -IPSET_ERR_INVALID_NETMASK;
 +	}
 +#endif
 +
++=======
++>>>>>>> 961509ac183e (netfilter: ipset: Optimize hash creation routine)
  	hsize = sizeof(*h);
  #ifdef IP_SET_HASH_WITH_NETS
 -	hsize += sizeof(struct net_prefixes) * NLEN;
 +	hsize += sizeof(struct net_prefixes) * NETS_LENGTH(set->family);
  #endif
  	h = kzalloc(hsize, GFP_KERNEL);
  	if (!h)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	h->maxelem = maxelem;
 +#ifdef IP_SET_HASH_WITH_NETMASK
 +	h->netmask = netmask;
 +#endif
 +	get_random_bytes(&h->initval, sizeof(h->initval));
 +	h->timeout = IPSET_NO_TIMEOUT;
 +
++=======
++>>>>>>> 961509ac183e (netfilter: ipset: Optimize hash creation routine)
  	hbits = htable_bits(hashsize);
  	hsize = htable_size(hbits);
  	if (hsize == 0) {
@@@ -1016,96 -1308,51 +1059,124 @@@
  		kfree(h);
  		return -ENOMEM;
  	}
++<<<<<<< HEAD
 +	h->table->htable_bits = hbits;
++=======
+ 	h->maxelem = maxelem;
+ #ifdef IP_SET_HASH_WITH_NETMASK
+ 	h->netmask = netmask;
+ #endif
+ #ifdef IP_SET_HASH_WITH_MARKMASK
+ 	h->markmask = markmask;
+ #endif
+ 	get_random_bytes(&h->initval, sizeof(h->initval));
+ 
+ 	t->htable_bits = hbits;
+ 	RCU_INIT_POINTER(h->table, t);
++>>>>>>> 961509ac183e (netfilter: ipset: Optimize hash creation routine)
  
  	set->data = h;
 -#ifndef IP_SET_PROTO_UNDEF
 -	if (set->family == NFPROTO_IPV4) {
 -#endif
 +	if (set->family ==  NFPROTO_IPV4)
  		set->variant = &IPSET_TOKEN(HTYPE, 4_variant);
 -		set->dsize = ip_set_elem_len(set, tb,
 -			sizeof(struct IPSET_TOKEN(HTYPE, 4_elem)),
 -			__alignof__(struct IPSET_TOKEN(HTYPE, 4_elem)));
 -#ifndef IP_SET_PROTO_UNDEF
 -	} else {
 +	else
  		set->variant = &IPSET_TOKEN(HTYPE, 6_variant);
++<<<<<<< HEAD
 +
 +	if (tb[IPSET_ATTR_CADT_FLAGS])
 +		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
 +	if (cadt_flags & IPSET_FLAG_WITH_COUNTERS) {
 +		set->extensions |= IPSET_EXT_COUNTER;
 +		if (tb[IPSET_ATTR_TIMEOUT]) {
 +			h->timeout =
 +				ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 +			set->extensions |= IPSET_EXT_TIMEOUT;
 +			if (set->family == NFPROTO_IPV4) {
 +				h->dsize = sizeof(struct
 +					IPSET_TOKEN(HTYPE, 4ct_elem));
 +				h->offset[IPSET_EXT_ID_TIMEOUT] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 4ct_elem),
 +						timeout);
 +				h->offset[IPSET_EXT_ID_COUNTER] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 4ct_elem),
 +						counter);
 +				IPSET_TOKEN(HTYPE, 4_gc_init)(set,
 +					IPSET_TOKEN(HTYPE, 4_gc));
 +			} else {
 +				h->dsize = sizeof(struct
 +					IPSET_TOKEN(HTYPE, 6ct_elem));
 +				h->offset[IPSET_EXT_ID_TIMEOUT] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 6ct_elem),
 +						timeout);
 +				h->offset[IPSET_EXT_ID_COUNTER] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 6ct_elem),
 +						counter);
 +				IPSET_TOKEN(HTYPE, 6_gc_init)(set,
 +					IPSET_TOKEN(HTYPE, 6_gc));
 +			}
 +		} else {
 +			if (set->family == NFPROTO_IPV4) {
 +				h->dsize =
 +					sizeof(struct
 +						IPSET_TOKEN(HTYPE, 4c_elem));
 +				h->offset[IPSET_EXT_ID_COUNTER] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 4c_elem),
 +						counter);
 +			} else {
 +				h->dsize =
 +					sizeof(struct
 +						IPSET_TOKEN(HTYPE, 6c_elem));
 +				h->offset[IPSET_EXT_ID_COUNTER] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 6c_elem),
 +						counter);
 +			}
 +		}
 +	} else if (tb[IPSET_ATTR_TIMEOUT]) {
 +		h->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 +		set->extensions |= IPSET_EXT_TIMEOUT;
 +		if (set->family == NFPROTO_IPV4) {
 +			h->dsize = sizeof(struct IPSET_TOKEN(HTYPE, 4t_elem));
 +			h->offset[IPSET_EXT_ID_TIMEOUT] =
 +				offsetof(struct IPSET_TOKEN(HTYPE, 4t_elem),
 +					 timeout);
++=======
+ 		set->dsize = ip_set_elem_len(set, tb,
+ 			sizeof(struct IPSET_TOKEN(HTYPE, 6_elem)),
+ 			__alignof__(struct IPSET_TOKEN(HTYPE, 6_elem)));
+ 	}
+ #endif
+ 	set->timeout = IPSET_NO_TIMEOUT;
+ 	if (tb[IPSET_ATTR_TIMEOUT]) {
+ 		set->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
+ #ifndef IP_SET_PROTO_UNDEF
+ 		if (set->family == NFPROTO_IPV4)
+ #endif
++>>>>>>> 961509ac183e (netfilter: ipset: Optimize hash creation routine)
  			IPSET_TOKEN(HTYPE, 4_gc_init)(set,
  				IPSET_TOKEN(HTYPE, 4_gc));
 -#ifndef IP_SET_PROTO_UNDEF
 -		else
 +		} else {
 +			h->dsize = sizeof(struct IPSET_TOKEN(HTYPE, 6t_elem));
 +			h->offset[IPSET_EXT_ID_TIMEOUT] =
 +				offsetof(struct IPSET_TOKEN(HTYPE, 6t_elem),
 +					 timeout);
  			IPSET_TOKEN(HTYPE, 6_gc_init)(set,
  				IPSET_TOKEN(HTYPE, 6_gc));
 -#endif
 +		}
 +	} else {
 +		if (set->family == NFPROTO_IPV4)
 +			h->dsize = sizeof(struct IPSET_TOKEN(HTYPE, 4_elem));
 +		else
 +			h->dsize = sizeof(struct IPSET_TOKEN(HTYPE, 6_elem));
  	}
 +
  	pr_debug("create %s hashsize %u (%u) maxelem %u: %p(%p)\n",
 -		 set->name, jhash_size(t->htable_bits),
 -		 t->htable_bits, h->maxelem, set->data, t);
 +		 set->name, jhash_size(h->table->htable_bits),
 +		 h->table->htable_bits, h->maxelem, set->data, h->table);
  
  	return 0;
  }
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
