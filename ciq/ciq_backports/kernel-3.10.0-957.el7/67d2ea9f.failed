usb: xhci: Make some static functions global

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [usb] xhci: Make some static functions global (Torez Smith) [1540721]
Rebuild_FUZZ: 93.98%
commit-author Lu Baolu <baolu.lu@linux.intel.com>
commit 67d2ea9fde2aa96f36af0537e4004efb123319fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/67d2ea9f.failed

This patch makes some static functions global to avoid duplications
in different files. These functions can be used in the implementation
of xHCI debug capability. There is no functional change.

	Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
	Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 67d2ea9fde2aa96f36af0537e4004efb123319fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/host/xhci-mem.c
diff --cc drivers/usb/host/xhci-mem.c
index 9315a58ac308,5bee81a5be49..000000000000
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@@ -1765,10 -1757,55 +1765,60 @@@ void xhci_free_command(struct xhci_hcd 
  	kfree(command);
  }
  
+ int xhci_alloc_erst(struct xhci_hcd *xhci,
+ 		    struct xhci_ring *evt_ring,
+ 		    struct xhci_erst *erst,
+ 		    gfp_t flags)
+ {
+ 	size_t size;
+ 	unsigned int val;
+ 	struct xhci_segment *seg;
+ 	struct xhci_erst_entry *entry;
+ 
+ 	size = sizeof(struct xhci_erst_entry) * evt_ring->num_segs;
+ 	erst->entries = dma_alloc_coherent(xhci_to_hcd(xhci)->self.sysdev,
+ 					   size,
+ 					   &erst->erst_dma_addr,
+ 					   flags);
+ 	if (!erst->entries)
+ 		return -ENOMEM;
+ 
+ 	memset(erst->entries, 0, size);
+ 	erst->num_entries = evt_ring->num_segs;
+ 
+ 	seg = evt_ring->first_seg;
+ 	for (val = 0; val < evt_ring->num_segs; val++) {
+ 		entry = &erst->entries[val];
+ 		entry->seg_addr = cpu_to_le64(seg->dma);
+ 		entry->seg_size = cpu_to_le32(TRBS_PER_SEGMENT);
+ 		entry->rsvd = 0;
+ 		seg = seg->next;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void xhci_free_erst(struct xhci_hcd *xhci, struct xhci_erst *erst)
+ {
+ 	size_t size;
+ 	struct device *dev = xhci_to_hcd(xhci)->self.sysdev;
+ 
+ 	size = sizeof(struct xhci_erst_entry) * (erst->num_entries);
+ 	if (erst->entries)
+ 		dma_free_coherent(dev, size,
+ 				erst->entries,
+ 				erst->erst_dma_addr);
+ 	erst->entries = NULL;
+ }
+ 
  void xhci_mem_cleanup(struct xhci_hcd *xhci)
  {
++<<<<<<< HEAD
 +	struct device	*dev = xhci_to_hcd(xhci)->self.controller;
 +	int size;
++=======
+ 	struct device	*dev = xhci_to_hcd(xhci)->self.sysdev;
++>>>>>>> 67d2ea9fde2a (usb: xhci: Make some static functions global)
  	int i, j, num_ports;
  
  	cancel_delayed_work_sync(&xhci->cmd_timer);
@@@ -2313,12 -2345,11 +2358,11 @@@ static int xhci_setup_port_arrays(struc
  int xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags)
  {
  	dma_addr_t	dma;
 -	struct device	*dev = xhci_to_hcd(xhci)->self.sysdev;
 +	struct device	*dev = xhci_to_hcd(xhci)->self.controller;
  	unsigned int	val, val2;
  	u64		val_64;
- 	struct xhci_segment	*seg;
- 	u32 page_size, temp;
- 	int i;
+ 	u32		page_size, temp;
+ 	int		i, ret;
  
  	INIT_LIST_HEAD(&xhci->cmd_list);
  
* Unmerged path drivers/usb/host/xhci-mem.c
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index ac210b9af027..2e6ea76ca7b7 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -165,7 +165,7 @@ static void next_trb(struct xhci_hcd *xhci,
  * See Cycle bit rules. SW is the consumer for the event ring only.
  * Don't make a ring full of link TRBs.  That would be dumb and this would loop.
  */
-static void inc_deq(struct xhci_hcd *xhci, struct xhci_ring *ring)
+void inc_deq(struct xhci_hcd *xhci, struct xhci_ring *ring)
 {
 	/* event ring doesn't have link trbs, check for last trb */
 	if (ring->type == TYPE_EVENT) {
@@ -2973,7 +2973,7 @@ static int prepare_transfer(struct xhci_hcd *xhci,
 	return 0;
 }
 
-static unsigned int count_trbs(u64 addr, u64 len)
+unsigned int count_trbs(u64 addr, u64 len)
 {
 	unsigned int num_trbs;
 
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 29ef43185d63..9af79852d3fc 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1976,9 +1976,17 @@ void xhci_slot_copy(struct xhci_hcd *xhci,
 int xhci_endpoint_init(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev,
 		struct usb_device *udev, struct usb_host_endpoint *ep,
 		gfp_t mem_flags);
+struct xhci_ring *xhci_ring_alloc(struct xhci_hcd *xhci,
+		unsigned int num_segs, unsigned int cycle_state,
+		enum xhci_ring_type type, unsigned int max_packet, gfp_t flags);
 void xhci_ring_free(struct xhci_hcd *xhci, struct xhci_ring *ring);
 int xhci_ring_expansion(struct xhci_hcd *xhci, struct xhci_ring *ring,
-				unsigned int num_trbs, gfp_t flags);
+		unsigned int num_trbs, gfp_t flags);
+int xhci_alloc_erst(struct xhci_hcd *xhci,
+		struct xhci_ring *evt_ring,
+		struct xhci_erst *erst,
+		gfp_t flags);
+void xhci_free_erst(struct xhci_hcd *xhci, struct xhci_erst *erst);
 void xhci_free_endpoint_ring(struct xhci_hcd *xhci,
 		struct xhci_virt_device *virt_dev,
 		unsigned int ep_index);
@@ -2009,6 +2017,10 @@ struct xhci_command *xhci_alloc_command_with_ctx(struct xhci_hcd *xhci,
 void xhci_urb_free_priv(struct urb_priv *urb_priv);
 void xhci_free_command(struct xhci_hcd *xhci,
 		struct xhci_command *command);
+struct xhci_container_ctx *xhci_alloc_container_ctx(struct xhci_hcd *xhci,
+		int type, gfp_t flags);
+void xhci_free_container_ctx(struct xhci_hcd *xhci,
+		struct xhci_container_ctx *ctx);
 
 /* xHCI host controller glue */
 typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);
@@ -2087,6 +2099,8 @@ void xhci_handle_command_timeout(struct work_struct *work);
 void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 		unsigned int ep_index, unsigned int stream_id);
 void xhci_cleanup_command_queue(struct xhci_hcd *xhci);
+void inc_deq(struct xhci_hcd *xhci, struct xhci_ring *ring);
+unsigned int count_trbs(u64 addr, u64 len);
 
 /* xHCI roothub code */
 void xhci_set_link_state(struct xhci_hcd *xhci, __le32 __iomem **port_array,
