ipmi: Convert IPMI GUID over to Linux guid_t

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Corey Minyard <cminyard@mvista.com>
commit 3fd32f9ec84f57ff6d86e762012d7626a9b31124
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3fd32f9e.failed

	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit 3fd32f9ec84f57ff6d86e762012d7626a9b31124)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_msghandler.c
diff --cc drivers/char/ipmi/ipmi_msghandler.c
index 23529b23ec40,1c8bef2e1dc1..000000000000
--- a/drivers/char/ipmi/ipmi_msghandler.c
+++ b/drivers/char/ipmi/ipmi_msghandler.c
@@@ -47,8 -47,8 +47,13 @@@
  #include <linux/rcupdate.h>
  #include <linux/interrupt.h>
  #include <linux/moduleparam.h>
++<<<<<<< HEAD
 +
 +#include <linux/rh_kabi.h>
++=======
+ #include <linux/workqueue.h>
+ #include <linux/uuid.h>
++>>>>>>> 3fd32f9ec84f (ipmi: Convert IPMI GUID over to Linux guid_t)
  
  #define PFX "IPMI message handler: "
  
@@@ -275,10 -286,12 +280,17 @@@ struct bmc_device 
  	struct ipmi_device_id  fetch_id;
  	int                    dyn_id_set;
  	unsigned long          dyn_id_expiry;
++<<<<<<< HEAD
 +	struct mutex           dyn_mutex; /* protects id & dyn* fields */
 +	u8                     guid[16];
 +	int                    guid_set;
++=======
+ 	struct mutex           dyn_mutex; /* Protects id, intfs, & dyn* */
+ 	guid_t                 guid;
+ 	guid_t                 fetch_guid;
+ 	int                    dyn_guid_set;
++>>>>>>> 3fd32f9ec84f (ipmi: Convert IPMI GUID over to Linux guid_t)
  	struct kref	       usecount;
 -	struct work_struct     remove_work;
  };
  #define to_bmc_device(x) container_of((x), struct bmc_device, pdev.dev)
  
@@@ -548,12 -557,13 +560,22 @@@ struct ipmi_smi 
  };
  #define to_si_intf_from_dev(device) container_of(device, struct ipmi_smi, dev)
  
++<<<<<<< HEAD
 +struct ipmi_shadow_smi_handlers shadow_smi_handlers;
 +struct ipmi_shadow_smi_handlers *ipmi_get_shadow_smi_handlers(void)
 +{
 +	return &shadow_smi_handlers;
 +}
 +EXPORT_SYMBOL_GPL(ipmi_get_shadow_smi_handlers);
++=======
+ static void __get_guid(ipmi_smi_t intf);
+ static void __ipmi_bmc_unregister(ipmi_smi_t intf);
+ static int __ipmi_bmc_register(ipmi_smi_t intf,
+ 			       struct ipmi_device_id *id,
+ 			       bool guid_set, guid_t *guid, int intf_num);
+ static int __scan_channels(ipmi_smi_t intf, struct ipmi_device_id *id);
+ 
++>>>>>>> 3fd32f9ec84f (ipmi: Convert IPMI GUID over to Linux guid_t)
  
  /**
   * The driver model view of the IPMI messaging driver.
@@@ -2212,12 -2223,13 +2234,18 @@@ static int __get_device_id(ipmi_smi_t i
   * Except for the first time this is called (in ipmi_register_smi()),
   * this will always return good data;
   */
++<<<<<<< HEAD
 +static int bmc_get_device_id(ipmi_smi_t intf, struct bmc_device *bmc,
 +			     struct ipmi_device_id *id,
 +			     bool *guid_set, u8 *guid)
++=======
+ static int __bmc_get_device_id(ipmi_smi_t intf, struct bmc_device *bmc,
+ 			       struct ipmi_device_id *id,
+ 			       bool *guid_set, guid_t *guid, int intf_num)
++>>>>>>> 3fd32f9ec84f (ipmi: Convert IPMI GUID over to Linux guid_t)
  {
  	int rv = 0;
 -	int prev_dyn_id_set, prev_guid_set;
 -	bool intf_set = intf != NULL;
 +	int prev_dyn_id_set;
  
  	if (!intf) {
  		mutex_lock(&bmc->dyn_mutex);
@@@ -2255,7 -2270,54 +2283,58 @@@ retry_bmc_lock
  	if (rv)
  		goto out;
  
++<<<<<<< HEAD
 +	memcpy(&bmc->id, &bmc->fetch_id, sizeof(bmc->id));
++=======
+ 	/*
+ 	 * The guid, device id, manufacturer id, and product id should
+ 	 * not change on a BMC.  If it does we have to do some dancing.
+ 	 */
+ 	if (!intf->bmc_registered
+ 	    || (!prev_guid_set && bmc->dyn_guid_set)
+ 	    || (!prev_dyn_id_set && bmc->dyn_id_set)
+ 	    || (prev_guid_set && bmc->dyn_guid_set
+ 		&& !guid_equal(&bmc->guid, &bmc->fetch_guid))
+ 	    || bmc->id.device_id != bmc->fetch_id.device_id
+ 	    || bmc->id.manufacturer_id != bmc->fetch_id.manufacturer_id
+ 	    || bmc->id.product_id != bmc->fetch_id.product_id) {
+ 		struct ipmi_device_id id = bmc->fetch_id;
+ 		int guid_set = bmc->dyn_guid_set;
+ 		guid_t guid;
+ 
+ 		guid = bmc->fetch_guid;
+ 		mutex_unlock(&bmc->dyn_mutex);
+ 
+ 		__ipmi_bmc_unregister(intf);
+ 		/* Fill in the temporary BMC for good measure. */
+ 		intf->bmc->id = id;
+ 		intf->bmc->dyn_guid_set = guid_set;
+ 		intf->bmc->guid = guid;
+ 		if (__ipmi_bmc_register(intf, &id, guid_set, &guid, intf_num))
+ 			need_waiter(intf); /* Retry later on an error. */
+ 		else
+ 			__scan_channels(intf, &id);
+ 
+ 
+ 		if (!intf_set) {
+ 			/*
+ 			 * We weren't given the interface on the
+ 			 * command line, so restart the operation on
+ 			 * the next interface for the BMC.
+ 			 */
+ 			mutex_unlock(&intf->bmc_reg_mutex);
+ 			mutex_lock(&bmc->dyn_mutex);
+ 			goto retry_bmc_lock;
+ 		}
+ 
+ 		/* We have a new BMC, set it up. */
+ 		bmc = intf->bmc;
+ 		mutex_lock(&bmc->dyn_mutex);
+ 		goto out_noprocessing;
+ 	} else if (memcmp(&bmc->fetch_id, &bmc->id, sizeof(bmc->id)))
+ 		/* Version info changes, scan the channels again. */
+ 		__scan_channels(intf, &bmc->fetch_id);
++>>>>>>> 3fd32f9ec84f (ipmi: Convert IPMI GUID over to Linux guid_t)
  
  	bmc->dyn_id_expiry = jiffies + IPMI_DYN_DEV_ID_EXPIRY;
  
@@@ -2264,15 -2326,28 +2343,39 @@@ out
  		rv = 0; /* Ignore failures if we have previous data. */
  		bmc->dyn_id_set = prev_dyn_id_set;
  	}
++<<<<<<< HEAD
++=======
+ 	if (!rv) {
+ 		bmc->id = bmc->fetch_id;
+ 		if (bmc->dyn_guid_set)
+ 			bmc->guid = bmc->fetch_guid;
+ 		else if (prev_guid_set)
+ 			/*
+ 			 * The guid used to be valid and it failed to fetch,
+ 			 * just use the cached value.
+ 			 */
+ 			bmc->dyn_guid_set = prev_guid_set;
+ 	}
+ out_noprocessing:
+ 	if (!rv) {
+ 		if (id)
+ 			*id = bmc->id;
++>>>>>>> 3fd32f9ec84f (ipmi: Convert IPMI GUID over to Linux guid_t)
  
 -		if (guid_set)
 -			*guid_set = bmc->dyn_guid_set;
 +	if (id)
 +		*id = bmc->id;
  
++<<<<<<< HEAD
 +	if (guid_set)
 +		*guid_set = bmc->guid_set;
 +
 +	if (guid && bmc->guid_set)
 +		memcpy(guid, bmc->guid, 16);
++=======
+ 		if (guid && bmc->dyn_guid_set)
+ 			*guid =  bmc->guid;
+ 	}
++>>>>>>> 3fd32f9ec84f (ipmi: Convert IPMI GUID over to Linux guid_t)
  
  	mutex_unlock(&bmc->dyn_mutex);
  	mutex_unlock(&intf->bmc_reg_mutex);
@@@ -2281,6 -2356,13 +2384,16 @@@
  	return rv;
  }
  
++<<<<<<< HEAD
++=======
+ static int bmc_get_device_id(ipmi_smi_t intf, struct bmc_device *bmc,
+ 			     struct ipmi_device_id *id,
+ 			     bool *guid_set, guid_t *guid)
+ {
+ 	return __bmc_get_device_id(intf, bmc, id, guid_set, guid, -1);
+ }
+ 
++>>>>>>> 3fd32f9ec84f (ipmi: Convert IPMI GUID over to Linux guid_t)
  #ifdef CONFIG_PROC_FS
  static int smi_ipmb_proc_show(struct seq_file *m, void *v)
  {
@@@ -2725,29 -2802,25 +2833,40 @@@ static const struct device_type bmc_dev
  
  static int __find_bmc_guid(struct device *dev, void *data)
  {
++<<<<<<< HEAD
 +	unsigned char *id = data;
++=======
+ 	guid_t *guid = data;
++>>>>>>> 3fd32f9ec84f (ipmi: Convert IPMI GUID over to Linux guid_t)
  	struct bmc_device *bmc;
 +	bool guid_set;
 +	u8 guid[16];
  	int rv;
  
  	if (dev->type != &bmc_device_type)
  		return 0;
  
  	bmc = to_bmc_device(dev);
++<<<<<<< HEAD
 +	rv = bmc_get_device_id(NULL, bmc, NULL, &guid_set, guid);
 +	if (rv || !guid_set)
 +		return 0;
 +
 +	return memcmp(guid, id, 16) == 0;
++=======
+ 	rv = bmc->dyn_guid_set && guid_equal(&bmc->guid, guid);
+ 	if (rv)
+ 		rv = kref_get_unless_zero(&bmc->usecount);
+ 	return rv;
++>>>>>>> 3fd32f9ec84f (ipmi: Convert IPMI GUID over to Linux guid_t)
  }
  
  /*
 - * Returns with the bmc's usecount incremented, if it is non-NULL.
 + * Must be called with ipmidriver_mutex held.  Returns with the
 + * bmc's usecount incremented, if it is non-NULL.
   */
  static struct bmc_device *ipmi_find_bmc_guid(struct device_driver *drv,
- 					     unsigned char *guid)
+ 					     guid_t *guid)
  {
  	struct device *dev;
  	struct bmc_device *bmc = NULL;
@@@ -2853,7 -2934,16 +2972,16 @@@ static void ipmi_bmc_unregister(ipmi_sm
  	mutex_unlock(&intf->bmc_reg_mutex);
  }
  
++<<<<<<< HEAD
 +static int ipmi_bmc_register(ipmi_smi_t intf, int ifnum)
++=======
+ /*
+  * Must be called with intf->bmc_reg_mutex held.
+  */
+ static int __ipmi_bmc_register(ipmi_smi_t intf,
+ 			       struct ipmi_device_id *id,
+ 			       bool guid_set, guid_t *guid, int intf_num)
++>>>>>>> 3fd32f9ec84f (ipmi: Convert IPMI GUID over to Linux guid_t)
  {
  	int               rv;
  	struct bmc_device *bmc = intf->bmc;
@@@ -2897,6 -2999,13 +3025,16 @@@
  		}
  		INIT_LIST_HEAD(&bmc->intfs);
  		mutex_init(&bmc->dyn_mutex);
++<<<<<<< HEAD
++=======
+ 		INIT_WORK(&bmc->remove_work, cleanup_bmc_work);
+ 
+ 		bmc->id = *id;
+ 		bmc->dyn_id_set = 1;
+ 		bmc->dyn_guid_set = guid_set;
+ 		bmc->guid = *guid;
+ 		bmc->dyn_id_expiry = jiffies + IPMI_DYN_DEV_ID_EXPIRY;
++>>>>>>> 3fd32f9ec84f (ipmi: Convert IPMI GUID over to Linux guid_t)
  
  		bmc->pdev.name = "ipmi_bmc";
  
@@@ -3048,8 -3161,13 +3186,18 @@@ guid_handler(ipmi_smi_t intf, struct ip
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	memcpy(intf->bmc->guid, msg->msg.data + 1, 16);
 +	intf->bmc->guid_set = 1;
++=======
+ 	memcpy(bmc->fetch_guid.b, msg->msg.data + 1, 16);
+ 	/*
+ 	 * Make sure the guid data is available before setting
+ 	 * dyn_guid_set.
+ 	 */
+ 	smp_wmb();
+ 	bmc->dyn_guid_set = 1;
++>>>>>>> 3fd32f9ec84f (ipmi: Convert IPMI GUID over to Linux guid_t)
   out:
  	wake_up(&intf->waitq);
  }
* Unmerged path drivers/char/ipmi/ipmi_msghandler.c
