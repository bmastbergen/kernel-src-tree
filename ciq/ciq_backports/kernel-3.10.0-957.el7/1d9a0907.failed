powerpc/numa: Invalidate numa_cpu_lookup_table on cpu remove

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [powerpc] numa: Invalidate numa_cpu_lookup_table on cpu remove (Gustavo Duarte) [1544437]
Rebuild_FUZZ: 92.86%
commit-author Nathan Fontenot <nfont@linux.vnet.ibm.com>
commit 1d9a090783bef19fe8cdec878620d22f05191316
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1d9a0907.failed

When DLPAR removing a CPU, the unmapping of the cpu from a node in
unmap_cpu_from_node() should also invalidate the CPUs entry in the
numa_cpu_lookup_table. There is not a guarantee that on a subsequent
DLPAR add of the CPU the associativity will be the same and thus
could be in a different node. Invalidating the entry in the
numa_cpu_lookup_table causes the associativity to be read from the
device tree at the time of the add.

The current behavior of not invalidating the CPUs entry in the
numa_cpu_lookup_table can result in scenarios where the the topology
layout of CPUs in the partition does not match the device tree
or the topology reported by the HMC.

This bug looks like it was introduced in 2004 in the commit titled
"ppc64: cpu hotplug notifier for numa", which is 6b15e4e87e32 in the
linux-fullhist tree. Hence tag it for all stable releases.

	Cc: stable@vger.kernel.org
	Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
	Reviewed-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 1d9a090783bef19fe8cdec878620d22f05191316)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/topology.h
diff --cc arch/powerpc/include/asm/topology.h
index f24035c6878f,1c02e6900f78..000000000000
--- a/arch/powerpc/include/asm/topology.h
+++ b/arch/powerpc/include/asm/topology.h
@@@ -43,9 -42,29 +43,29 @@@ extern void __init dump_numa_cpu_topolo
  
  extern int sysfs_add_device_to_node(struct device *dev, int nid);
  extern void sysfs_remove_device_from_node(struct device *dev, int nid);
 -extern int numa_update_cpu_topology(bool cpus_locked);
  
++<<<<<<< HEAD
++=======
+ static inline void update_numa_cpu_lookup_table(unsigned int cpu, int node)
+ {
+ 	numa_cpu_lookup_table[cpu] = node;
+ }
+ 
+ static inline int early_cpu_to_node(int cpu)
+ {
+ 	int nid;
+ 
+ 	nid = numa_cpu_lookup_table[cpu];
+ 
+ 	/*
+ 	 * Fall back to node 0 if nid is unset (it should be, except bugs).
+ 	 * This allows callers to safely do NODE_DATA(early_cpu_to_node(cpu)).
+ 	 */
+ 	return (nid < 0) ? 0 : nid;
+ }
++>>>>>>> 1d9a090783be (powerpc/numa: Invalidate numa_cpu_lookup_table on cpu remove)
  #else
  
 -static inline int early_cpu_to_node(int cpu) { return 0; }
 -
  static inline void dump_numa_cpu_topology(void) {}
  
  static inline int sysfs_add_device_to_node(struct device *dev, int nid)
* Unmerged path arch/powerpc/include/asm/topology.h
diff --git a/arch/powerpc/mm/numa.c b/arch/powerpc/mm/numa.c
index 587a6f961154..58ccc1911556 100644
--- a/arch/powerpc/mm/numa.c
+++ b/arch/powerpc/mm/numa.c
@@ -164,11 +164,6 @@ static void reset_numa_cpu_lookup_table(void)
 		numa_cpu_lookup_table[cpu] = -1;
 }
 
-static void update_numa_cpu_lookup_table(unsigned int cpu, int node)
-{
-	numa_cpu_lookup_table[cpu] = node;
-}
-
 static void map_cpu_to_node(int cpu, int node)
 {
 	update_numa_cpu_lookup_table(cpu, node);
diff --git a/arch/powerpc/platforms/pseries/hotplug-cpu.c b/arch/powerpc/platforms/pseries/hotplug-cpu.c
index 6084e50bd058..7d7a892e8e2f 100644
--- a/arch/powerpc/platforms/pseries/hotplug-cpu.c
+++ b/arch/powerpc/platforms/pseries/hotplug-cpu.c
@@ -34,6 +34,7 @@
 #include <asm/vdso_datapage.h>
 #include <asm/xics.h>
 #include <asm/plpar_wrappers.h>
+#include <asm/topology.h>
 
 #include "pseries.h"
 #include "offline_states.h"
@@ -334,6 +335,7 @@ static void pseries_remove_processor(struct device_node *np)
 			BUG_ON(cpu_online(cpu));
 			set_cpu_present(cpu, false);
 			set_hard_smp_processor_id(cpu, -1);
+			update_numa_cpu_lookup_table(cpu, -1);
 			break;
 		}
 		if (cpu >= nr_cpu_ids)
