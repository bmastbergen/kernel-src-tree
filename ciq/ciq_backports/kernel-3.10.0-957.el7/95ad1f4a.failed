netfilter: ipset: Fix extension alignment

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 95ad1f4a9358dff1dcf84bf5c9cc84caa9215f7f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/95ad1f4a.failed

The data extensions in ipset lacked the proper memory alignment and
thus could lead to kernel crash on several architectures. Therefore
the structures have been reorganized and alignment attributes added
where needed. The patch was tested on armv7h by Gerhard Wiesinger and
on x86_64, sparc64 by Jozsef Kadlecsik.

	Reported-by: Gerhard Wiesinger <lists@wiesinger.com>
	Tested-by: Gerhard Wiesinger <lists@wiesinger.com>
	Tested-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 95ad1f4a9358dff1dcf84bf5c9cc84caa9215f7f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/ipset/ip_set.h
#	net/netfilter/ipset/ip_set_bitmap_gen.h
#	net/netfilter/ipset/ip_set_bitmap_ip.c
#	net/netfilter/ipset/ip_set_bitmap_ipmac.c
#	net/netfilter/ipset/ip_set_bitmap_port.c
#	net/netfilter/ipset/ip_set_core.c
#	net/netfilter/ipset/ip_set_hash_gen.h
#	net/netfilter/ipset/ip_set_list_set.c
diff --cc include/linux/netfilter/ipset/ip_set.h
index 3e9c90cf5227,0e1f433cc4b7..000000000000
--- a/include/linux/netfilter/ipset/ip_set.h
+++ b/include/linux/netfilter/ipset/ip_set.h
@@@ -281,6 -420,8 +281,11 @@@ extern void *ip_set_alloc(size_t size)
  extern void ip_set_free(void *members);
  extern int ip_set_get_ipaddr4(struct nlattr *nla,  __be32 *ipaddr);
  extern int ip_set_get_ipaddr6(struct nlattr *nla, union nf_inet_addr *ipaddr);
++<<<<<<< HEAD
++=======
+ extern size_t ip_set_elem_len(struct ip_set *set, struct nlattr *tb[],
+ 			      size_t len, size_t align);
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  extern int ip_set_get_extensions(struct ip_set *set, struct nlattr *tb[],
  				 struct ip_set_ext *ext);
  
diff --cc net/netfilter/ipset/ip_set_bitmap_gen.h
index 01a340ce9e94,b0bc475f641e..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_gen.h
+++ b/net/netfilter/ipset/ip_set_bitmap_gen.h
@@@ -32,11 -33,7 +32,15 @@@
  #define mtype_gc		IPSET_TOKEN(MTYPE, _gc)
  #define mtype			MTYPE
  
++<<<<<<< HEAD
 +#define ext_timeout(e, m)	\
 +	(unsigned long *)((e) + (m)->offset[IPSET_EXT_ID_TIMEOUT])
 +#define ext_counter(e, m)	\
 +	(struct ip_set_counter *)((e) + (m)->offset[IPSET_EXT_ID_COUNTER])
 +#define get_ext(map, id)	((map)->extensions + (map)->dsize * (id))
++=======
+ #define get_ext(set, map, id)	((map)->extensions + ((set)->dsize * (id)))
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  
  static void
  mtype_gc_init(struct ip_set *set, void (*gc)(unsigned long ul_set))
@@@ -59,9 -67,9 +63,15 @@@ mtype_destroy(struct ip_set *set
  		del_timer_sync(&map->gc);
  
  	ip_set_free(map->members);
++<<<<<<< HEAD
 +	if (map->dsize)
 +		ip_set_free(map->extensions);
 +	kfree(map);
++=======
+ 	if (set->dsize && set->extensions & IPSET_EXT_DESTROY)
+ 		mtype_ext_cleanup(set);
+ 	ip_set_free(map);
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  
  	set->data = NULL;
  }
@@@ -84,16 -95,10 +95,23 @@@ mtype_head(struct ip_set *set, struct s
  	if (!nested)
  		goto nla_put_failure;
  	if (mtype_do_head(skb, map) ||
++<<<<<<< HEAD
 +	    nla_put_net32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref)) ||
 +	    nla_put_net32(skb, IPSET_ATTR_MEMSIZE,
 +			  htonl(sizeof(*map) +
 +				map->memsize +
 +				map->dsize * map->elements)) ||
 +	    (SET_WITH_TIMEOUT(set) &&
 +	     nla_put_net32(skb, IPSET_ATTR_TIMEOUT, htonl(map->timeout))) ||
 +	    (SET_WITH_COUNTER(set) &&
 +	     nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS,
 +			   htonl(IPSET_FLAG_WITH_COUNTERS))))
++=======
+ 	    nla_put_net32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref - 1)) ||
+ 	    nla_put_net32(skb, IPSET_ATTR_MEMSIZE, htonl(memsize)))
+ 		goto nla_put_failure;
+ 	if (unlikely(ip_set_put_flags(skb, set)))
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  		goto nla_put_failure;
  	ipset_nest_end(skb, nested);
  
diff --cc net/netfilter/ipset/ip_set_bitmap_ip.c
index faaca51bf3fa,4783efff0bde..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_ip.c
+++ b/net/netfilter/ipset/ip_set_bitmap_ip.c
@@@ -45,11 -46,10 +44,13 @@@ struct bitmap_ip 
  	u32 elements;		/* number of max elements in the set */
  	u32 hosts;		/* number of hosts in a subnet */
  	size_t memsize;		/* members size */
 +	size_t dsize;		/* extensions struct size */
 +	size_t offset[IPSET_EXT_ID_MAX]; /* Offsets to extensions */
  	u8 netmask;		/* subnet netmask */
 +	u32 timeout;		/* timeout parameter */
  	struct timer_list gc;	/* garbage collection */
+ 	unsigned char extensions[0]	/* data extensions */
+ 		__aligned(__alignof__(u64));
  };
  
  /* ADT structure for generic function args */
@@@ -241,13 -225,6 +242,16 @@@ init_map_ip(struct ip_set *set, struct 
  	map->members = ip_set_alloc(map->memsize);
  	if (!map->members)
  		return false;
++<<<<<<< HEAD
 +	if (map->dsize) {
 +		map->extensions = ip_set_alloc(map->dsize * elements);
 +		if (!map->extensions) {
 +			kfree(map->members);
 +			return false;
 +		}
 +	}
++=======
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  	map->first_ip = first_ip;
  	map->last_ip = last_ip;
  	map->elements = elements;
@@@ -338,61 -317,14 +343,71 @@@ bitmap_ip_create(struct net *net, struc
  
  	map->memsize = bitmap_bytes(0, elements - 1);
  	set->variant = &bitmap_ip;
++<<<<<<< HEAD
 +	if (tb[IPSET_ATTR_CADT_FLAGS])
 +		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
 +	if (cadt_flags & IPSET_FLAG_WITH_COUNTERS) {
 +		set->extensions |= IPSET_EXT_COUNTER;
 +		if (tb[IPSET_ATTR_TIMEOUT]) {
 +			map->dsize = sizeof(struct bitmap_ipct_elem);
 +			map->offset[IPSET_EXT_ID_TIMEOUT] =
 +				offsetof(struct bitmap_ipct_elem, timeout);
 +			map->offset[IPSET_EXT_ID_COUNTER] =
 +				offsetof(struct bitmap_ipct_elem, counter);
 +
 +			if (!init_map_ip(set, map, first_ip, last_ip,
 +					 elements, hosts, netmask)) {
 +				kfree(map);
 +				return -ENOMEM;
 +			}
 +
 +			map->timeout = ip_set_timeout_uget(
 +				tb[IPSET_ATTR_TIMEOUT]);
 +			set->extensions |= IPSET_EXT_TIMEOUT;
 +
 +			bitmap_ip_gc_init(set, bitmap_ip_gc);
 +		} else {
 +			map->dsize = sizeof(struct bitmap_ipc_elem);
 +			map->offset[IPSET_EXT_ID_COUNTER] =
 +				offsetof(struct bitmap_ipc_elem, counter);
 +
 +			if (!init_map_ip(set, map, first_ip, last_ip,
 +					 elements, hosts, netmask)) {
 +				kfree(map);
 +				return -ENOMEM;
 +			}
 +		}
 +	} else if (tb[IPSET_ATTR_TIMEOUT]) {
 +		map->dsize = sizeof(struct bitmap_ipt_elem);
 +		map->offset[IPSET_EXT_ID_TIMEOUT] =
 +			offsetof(struct bitmap_ipt_elem, timeout);
 +
 +		if (!init_map_ip(set, map, first_ip, last_ip,
 +				 elements, hosts, netmask)) {
 +			kfree(map);
 +			return -ENOMEM;
 +		}
 +
 +		map->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 +		set->extensions |= IPSET_EXT_TIMEOUT;
 +
++=======
+ 	if (!init_map_ip(set, map, first_ip, last_ip,
+ 			 elements, hosts, netmask)) {
+ 		kfree(map);
+ 		return -ENOMEM;
+ 	}
+ 	if (tb[IPSET_ATTR_TIMEOUT]) {
+ 		set->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  		bitmap_ip_gc_init(set, bitmap_ip_gc);
 +	} else {
 +		map->dsize = 0;
 +		if (!init_map_ip(set, map, first_ip, last_ip,
 +				 elements, hosts, netmask)) {
 +			kfree(map);
 +			return -ENOMEM;
 +		}
  	}
  	return 0;
  }
diff --cc net/netfilter/ipset/ip_set_bitmap_ipmac.c
index b2a7bea3f7b6,29dde208381d..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_ipmac.c
+++ b/net/netfilter/ipset/ip_set_bitmap_ipmac.c
@@@ -48,12 -50,10 +48,16 @@@ struct bitmap_ipmac 
  	u32 first_ip;		/* host byte order, included in range */
  	u32 last_ip;		/* host byte order, included in range */
  	u32 elements;		/* number of max elements in the set */
 -	size_t memsize;		/* members size */
 +	u32 timeout;		/* timeout value */
  	struct timer_list gc;	/* garbage collector */
++<<<<<<< HEAD
 +	size_t memsize;		/* members size */
 +	size_t dsize;		/* size of element */
 +	size_t offset[IPSET_EXT_ID_MAX]; /* Offsets to extensions */
++=======
+ 	unsigned char extensions[0]	/* MAC + data extensions */
+ 		__aligned(__alignof__(u64));
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  };
  
  /* ADT structure for generic function args */
@@@ -89,10 -90,9 +94,16 @@@ bitmap_ipmac_do_test(const struct bitma
  
  	if (!test_bit(e->id, map->members))
  		return 0;
++<<<<<<< HEAD
 +	elem = get_elem(map->extensions, e->id, map->dsize);
 +	if (elem->filled == MAC_FILLED)
 +		return e->ether == NULL ||
 +		       ether_addr_equal(e->ether, elem->ether);
++=======
+ 	elem = get_const_elem(map->extensions, e->id, dsize);
+ 	if (e->add_mac && elem->filled == MAC_FILLED)
+ 		return ether_addr_equal(e->ether, elem->ether);
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  	/* Trigger kernel to fill out the ethernet address */
  	return -EAGAIN;
  }
@@@ -104,7 -104,7 +115,11 @@@ bitmap_ipmac_gc_test(u16 id, const stru
  
  	if (!test_bit(id, map->members))
  		return 0;
++<<<<<<< HEAD
 +	elem = get_elem(map->extensions, id, map->dsize);
++=======
+ 	elem = get_const_elem(map->extensions, id, dsize);
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  	/* Timer not started for the incomplete elements */
  	return elem->filled == MAC_FILLED;
  }
@@@ -132,8 -132,9 +147,14 @@@ bitmap_ipmac_add_timeout(unsigned long 
  		/* If MAC is unset yet, we store plain timeout value
  		 * because the timer is not activated yet
  		 * and we can reuse it later when MAC is filled out,
++<<<<<<< HEAD
 +		 * possibly by the kernel */
 +		if (e->ether)
++=======
+ 		 * possibly by the kernel
+ 		 */
+ 		if (e->add_mac)
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  			ip_set_timeout_set(timeout, t);
  		else
  			*timeout = t;
@@@ -147,29 -148,36 +168,40 @@@ bitmap_ipmac_do_add(const struct bitmap
  {
  	struct bitmap_ipmac_elem *elem;
  
 -	elem = get_elem(map->extensions, e->id, dsize);
 -	if (test_bit(e->id, map->members)) {
 +	elem = get_elem(map->extensions, e->id, map->dsize);
 +	if (test_and_set_bit(e->id, map->members)) {
  		if (elem->filled == MAC_FILLED) {
++<<<<<<< HEAD
 +			if (e->ether && (flags & IPSET_FLAG_EXIST))
 +				memcpy(elem->ether, e->ether, ETH_ALEN);
++=======
+ 			if (e->add_mac &&
+ 			    (flags & IPSET_FLAG_EXIST) &&
+ 			    !ether_addr_equal(e->ether, elem->ether)) {
+ 				/* memcpy isn't atomic */
+ 				clear_bit(e->id, map->members);
+ 				smp_mb__after_atomic();
+ 				ether_addr_copy(elem->ether, e->ether);
+ 			}
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  			return IPSET_ADD_FAILED;
- 		} else if (!e->ether)
+ 		} else if (!e->add_mac)
  			/* Already added without ethernet address */
  			return IPSET_ADD_FAILED;
  		/* Fill the MAC address and trigger the timer activation */
 -		clear_bit(e->id, map->members);
 -		smp_mb__after_atomic();
 -		ether_addr_copy(elem->ether, e->ether);
 +		memcpy(elem->ether, e->ether, ETH_ALEN);
  		elem->filled = MAC_FILLED;
  		return IPSET_ADD_START_STORED_TIMEOUT;
- 	} else if (e->ether) {
+ 	} else if (e->add_mac) {
  		/* We can store MAC too */
 -		ether_addr_copy(elem->ether, e->ether);
 +		memcpy(elem->ether, e->ether, ETH_ALEN);
  		elem->filled = MAC_FILLED;
  		return 0;
 +	} else {
 +		elem->filled = MAC_UNSET;
 +		/* MAC is not stored yet, don't start timer */
 +		return IPSET_ADD_STORE_PLAIN_TIMEOUT;
  	}
 -	elem->filled = MAC_UNSET;
 -	/* MAC is not stored yet, don't start timer */
 -	return IPSET_ADD_STORE_PLAIN_TIMEOUT;
  }
  
  static inline int
@@@ -179,22 -187,12 +211,26 @@@ bitmap_ipmac_do_del(const struct bitmap
  	return !test_and_clear_bit(e->id, map->members);
  }
  
 +static inline unsigned long
 +ip_set_timeout_stored(struct bitmap_ipmac *map, u32 id, unsigned long *timeout)
 +{
 +	const struct bitmap_ipmac_elem *elem =
++<<<<<<< HEAD
 +		get_elem(map->extensions, id, map->dsize);
 +
 +	return elem->filled == MAC_FILLED ? ip_set_timeout_get(timeout) :
 +					    *timeout;
 +}
 +
  static inline int
  bitmap_ipmac_do_list(struct sk_buff *skb, const struct bitmap_ipmac *map,
 -		     u32 id, size_t dsize)
 +		     u32 id)
  {
  	const struct bitmap_ipmac_elem *elem =
 +		get_elem(map->extensions, id, map->dsize);
++=======
+ 		get_const_elem(map->extensions, id, dsize);
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  
  	return nla_put_ipaddr4(skb, IPSET_ATTR_IP,
  			       htonl(map->first_ip + id)) ||
@@@ -216,8 -214,8 +252,13 @@@ bitmap_ipmac_kadt(struct ip_set *set, c
  {
  	struct bitmap_ipmac *map = set->data;
  	ipset_adtfn adtfn = set->variant->adt[adt];
++<<<<<<< HEAD
 +	struct bitmap_ipmac_adt_elem e = {};
 +	struct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, map);
++=======
+ 	struct bitmap_ipmac_adt_elem e = { .id = 0, .add_mac = 1 };
+ 	struct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  	u32 ip;
  
  	/* MAC can be src only */
@@@ -331,16 -297,9 +371,19 @@@ static boo
  init_map_ipmac(struct ip_set *set, struct bitmap_ipmac *map,
  	       u32 first_ip, u32 last_ip, u32 elements)
  {
 -	map->members = ip_set_alloc(map->memsize);
 +	map->members = ip_set_alloc((last_ip - first_ip + 1) * map->dsize);
  	if (!map->members)
  		return false;
++<<<<<<< HEAD
 +	if (map->dsize) {
 +		map->extensions = ip_set_alloc(map->dsize * elements);
 +		if (!map->extensions) {
 +			kfree(map->members);
 +			return false;
 +		}
 +	}
++=======
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  	map->first_ip = first_ip;
  	map->last_ip = last_ip;
  	map->elements = elements;
@@@ -400,57 -363,13 +446,66 @@@ bitmap_ipmac_create(struct net *net, st
  
  	map->memsize = bitmap_bytes(0, elements - 1);
  	set->variant = &bitmap_ipmac;
++<<<<<<< HEAD
 +	if (tb[IPSET_ATTR_CADT_FLAGS])
 +		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
 +	if (cadt_flags & IPSET_FLAG_WITH_COUNTERS) {
 +		set->extensions |= IPSET_EXT_COUNTER;
 +		if (tb[IPSET_ATTR_TIMEOUT]) {
 +			map->dsize = sizeof(struct bitmap_ipmacct_elem);
 +			map->offset[IPSET_EXT_ID_TIMEOUT] =
 +				offsetof(struct bitmap_ipmacct_elem, timeout);
 +			map->offset[IPSET_EXT_ID_COUNTER] =
 +				offsetof(struct bitmap_ipmacct_elem, counter);
 +
 +			if (!init_map_ipmac(set, map, first_ip, last_ip,
 +					    elements)) {
 +				kfree(map);
 +				return -ENOMEM;
 +			}
 +			map->timeout = ip_set_timeout_uget(
 +				tb[IPSET_ATTR_TIMEOUT]);
 +			set->extensions |= IPSET_EXT_TIMEOUT;
 +			bitmap_ipmac_gc_init(set, bitmap_ipmac_gc);
 +		} else {
 +			map->dsize = sizeof(struct bitmap_ipmacc_elem);
 +			map->offset[IPSET_EXT_ID_COUNTER] =
 +				offsetof(struct bitmap_ipmacc_elem, counter);
 +
 +			if (!init_map_ipmac(set, map, first_ip, last_ip,
 +					    elements)) {
 +				kfree(map);
 +				return -ENOMEM;
 +			}
 +		}
 +	} else if (tb[IPSET_ATTR_TIMEOUT]) {
 +		map->dsize = sizeof(struct bitmap_ipmact_elem);
 +		map->offset[IPSET_EXT_ID_TIMEOUT] =
 +			offsetof(struct bitmap_ipmact_elem, timeout);
 +
 +		if (!init_map_ipmac(set, map, first_ip, last_ip, elements)) {
 +			kfree(map);
 +			return -ENOMEM;
 +		}
 +		map->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 +		set->extensions |= IPSET_EXT_TIMEOUT;
++=======
+ 	if (!init_map_ipmac(set, map, first_ip, last_ip, elements)) {
+ 		kfree(map);
+ 		return -ENOMEM;
+ 	}
+ 	if (tb[IPSET_ATTR_TIMEOUT]) {
+ 		set->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  		bitmap_ipmac_gc_init(set, bitmap_ipmac_gc);
 +	} else {
 +		map->dsize = sizeof(struct bitmap_ipmac_elem);
 +
 +		if (!init_map_ipmac(set, map, first_ip, last_ip, elements)) {
 +			kfree(map);
 +			return -ENOMEM;
 +		}
 +		set->variant = &bitmap_ipmac;
  	}
  	return 0;
  }
diff --cc net/netfilter/ipset/ip_set_bitmap_port.c
index 3fcb6e11fac3,7f0c733358a4..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_port.c
+++ b/net/netfilter/ipset/ip_set_bitmap_port.c
@@@ -38,10 -39,9 +37,12 @@@ struct bitmap_port 
  	u16 last_port;		/* host byte order, included in range */
  	u32 elements;		/* number of max elements in the set */
  	size_t memsize;		/* members size */
 +	size_t dsize;		/* extensions struct size */
 +	size_t offset[IPSET_EXT_ID_MAX]; /* Offsets to extensions */
 +	u32 timeout;		/* timeout parameter */
  	struct timer_list gc;	/* garbage collection */
+ 	unsigned char extensions[0]	/* data extensions */
+ 		__aligned(__alignof__(u64));
  };
  
  /* ADT structure for generic function args */
@@@ -230,16 -210,9 +231,19 @@@ init_map_port(struct ip_set *set, struc
  	map->members = ip_set_alloc(map->memsize);
  	if (!map->members)
  		return false;
++<<<<<<< HEAD
 +	if (map->dsize) {
 +		map->extensions = ip_set_alloc(map->dsize * map->elements);
 +		if (!map->extensions) {
 +			kfree(map->members);
 +			return false;
 +		}
 +	}
++=======
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  	map->first_port = first_port;
  	map->last_port = last_port;
 -	set->timeout = IPSET_NO_TIMEOUT;
 +	map->timeout = IPSET_NO_TIMEOUT;
  
  	set->data = map;
  	set->family = NFPROTO_UNSPEC;
@@@ -253,7 -226,7 +257,11 @@@ bitmap_port_create(struct net *net, str
  {
  	struct bitmap_port *map;
  	u16 first_port, last_port;
++<<<<<<< HEAD
 +	u32 cadt_flags = 0;
++=======
+ 	u32 elements;
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  
  	if (unlikely(!ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||
  		     !ip_set_attr_netorder(tb, IPSET_ATTR_PORT_TO) ||
@@@ -274,56 -249,16 +284,65 @@@
  	if (!map)
  		return -ENOMEM;
  
- 	map->elements = last_port - first_port + 1;
+ 	map->elements = elements;
  	map->memsize = bitmap_bytes(0, map->elements);
  	set->variant = &bitmap_port;
++<<<<<<< HEAD
 +	if (tb[IPSET_ATTR_CADT_FLAGS])
 +		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
 +	if (cadt_flags & IPSET_FLAG_WITH_COUNTERS) {
 +		set->extensions |= IPSET_EXT_COUNTER;
 +		if (tb[IPSET_ATTR_TIMEOUT]) {
 +			map->dsize = sizeof(struct bitmap_portct_elem);
 +			map->offset[IPSET_EXT_ID_TIMEOUT] =
 +				offsetof(struct bitmap_portct_elem, timeout);
 +			map->offset[IPSET_EXT_ID_COUNTER] =
 +				offsetof(struct bitmap_portct_elem, counter);
 +			if (!init_map_port(set, map, first_port, last_port)) {
 +				kfree(map);
 +				return -ENOMEM;
 +			}
 +
 +			map->timeout =
 +				ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 +			set->extensions |= IPSET_EXT_TIMEOUT;
 +			bitmap_port_gc_init(set, bitmap_port_gc);
 +		} else {
 +			map->dsize = sizeof(struct bitmap_portc_elem);
 +			map->offset[IPSET_EXT_ID_COUNTER] =
 +				offsetof(struct bitmap_portc_elem, counter);
 +			if (!init_map_port(set, map, first_port, last_port)) {
 +				kfree(map);
 +				return -ENOMEM;
 +			}
 +		}
 +	} else if (tb[IPSET_ATTR_TIMEOUT]) {
 +		map->dsize = sizeof(struct bitmap_portt_elem);
 +		map->offset[IPSET_EXT_ID_TIMEOUT] =
 +			offsetof(struct bitmap_portt_elem, timeout);
 +		if (!init_map_port(set, map, first_port, last_port)) {
 +			kfree(map);
 +			return -ENOMEM;
 +		}
 +
 +		map->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 +		set->extensions |= IPSET_EXT_TIMEOUT;
++=======
+ 	if (!init_map_port(set, map, first_port, last_port)) {
+ 		kfree(map);
+ 		return -ENOMEM;
+ 	}
+ 	if (tb[IPSET_ATTR_TIMEOUT]) {
+ 		set->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  		bitmap_port_gc_init(set, bitmap_port_gc);
 +	} else {
 +		map->dsize = 0;
 +		if (!init_map_port(set, map, first_port, last_port)) {
 +			kfree(map);
 +			return -ENOMEM;
 +		}
 +
  	}
  	return 0;
  }
diff --cc net/netfilter/ipset/ip_set_core.c
index 1b9673fde81c,54f3d7cb23e6..000000000000
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@@ -324,6 -324,70 +324,73 @@@ ip_set_get_ipaddr6(struct nlattr *nla, 
  }
  EXPORT_SYMBOL_GPL(ip_set_get_ipaddr6);
  
++<<<<<<< HEAD
++=======
+ typedef void (*destroyer)(void *);
+ /* ipset data extension types, in size order */
+ 
+ const struct ip_set_ext_type ip_set_extensions[] = {
+ 	[IPSET_EXT_ID_COUNTER] = {
+ 		.type	= IPSET_EXT_COUNTER,
+ 		.flag	= IPSET_FLAG_WITH_COUNTERS,
+ 		.len	= sizeof(struct ip_set_counter),
+ 		.align	= __alignof__(struct ip_set_counter),
+ 	},
+ 	[IPSET_EXT_ID_TIMEOUT] = {
+ 		.type	= IPSET_EXT_TIMEOUT,
+ 		.len	= sizeof(unsigned long),
+ 		.align	= __alignof__(unsigned long),
+ 	},
+ 	[IPSET_EXT_ID_SKBINFO] = {
+ 		.type	= IPSET_EXT_SKBINFO,
+ 		.flag	= IPSET_FLAG_WITH_SKBINFO,
+ 		.len	= sizeof(struct ip_set_skbinfo),
+ 		.align	= __alignof__(struct ip_set_skbinfo),
+ 	},
+ 	[IPSET_EXT_ID_COMMENT] = {
+ 		.type	 = IPSET_EXT_COMMENT | IPSET_EXT_DESTROY,
+ 		.flag	 = IPSET_FLAG_WITH_COMMENT,
+ 		.len	 = sizeof(struct ip_set_comment),
+ 		.align	 = __alignof__(struct ip_set_comment),
+ 		.destroy = (destroyer) ip_set_comment_free,
+ 	},
+ };
+ EXPORT_SYMBOL_GPL(ip_set_extensions);
+ 
+ static inline bool
+ add_extension(enum ip_set_ext_id id, u32 flags, struct nlattr *tb[])
+ {
+ 	return ip_set_extensions[id].flag ?
+ 		(flags & ip_set_extensions[id].flag) :
+ 		!!tb[IPSET_ATTR_TIMEOUT];
+ }
+ 
+ size_t
+ ip_set_elem_len(struct ip_set *set, struct nlattr *tb[], size_t len,
+ 		size_t align)
+ {
+ 	enum ip_set_ext_id id;
+ 	u32 cadt_flags = 0;
+ 
+ 	if (tb[IPSET_ATTR_CADT_FLAGS])
+ 		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
+ 	if (cadt_flags & IPSET_FLAG_WITH_FORCEADD)
+ 		set->flags |= IPSET_CREATE_FLAG_FORCEADD;
+ 	if (!align)
+ 		align = 1;
+ 	for (id = 0; id < IPSET_EXT_ID_MAX; id++) {
+ 		if (!add_extension(id, cadt_flags, tb))
+ 			continue;
+ 		len = ALIGN(len, ip_set_extensions[id].align);
+ 		set->offset[id] = len;
+ 		set->extensions |= ip_set_extensions[id].type;
+ 		len += ip_set_extensions[id].len;
+ 	}
+ 	return ALIGN(len, align);
+ }
+ EXPORT_SYMBOL_GPL(ip_set_elem_len);
+ 
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  int
  ip_set_get_extensions(struct ip_set *set, struct nlattr *tb[],
  		      struct ip_set_ext *ext)
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 9ce28af662bf,4ff22194ce55..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -64,9 -67,13 +64,14 @@@ tune_ahash_max(u8 curr, u32 multi
  
  /* A hash bucket */
  struct hbucket {
 -	struct rcu_head rcu;	/* for call_rcu_bh */
 -	/* Which positions are used in the array */
 -	DECLARE_BITMAP(used, AHASH_MAX_TUNED);
 +	void *value;		/* the array of the values */
  	u8 size;		/* size of the array */
  	u8 pos;			/* position of the first free entry */
++<<<<<<< HEAD
++=======
+ 	unsigned char value[0]	/* the array of the values */
+ 		__aligned(__alignof__(u64));
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  };
  
  /* The hash table: the table size stored here in order to make resizing easy */
@@@ -1016,96 -1315,41 +1021,115 @@@ IPSET_TOKEN(HTYPE, _create)(struct net 
  		kfree(h);
  		return -ENOMEM;
  	}
 -	t->htable_bits = hbits;
 -	rcu_assign_pointer(h->table, t);
 +	h->table->htable_bits = hbits;
  
  	set->data = h;
 -#ifndef IP_SET_PROTO_UNDEF
 -	if (set->family == NFPROTO_IPV4) {
 -#endif
 +	if (set->family ==  NFPROTO_IPV4)
  		set->variant = &IPSET_TOKEN(HTYPE, 4_variant);
++<<<<<<< HEAD
 +	else
 +		set->variant = &IPSET_TOKEN(HTYPE, 6_variant);
 +
 +	if (tb[IPSET_ATTR_CADT_FLAGS])
 +		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
 +	if (cadt_flags & IPSET_FLAG_WITH_COUNTERS) {
 +		set->extensions |= IPSET_EXT_COUNTER;
 +		if (tb[IPSET_ATTR_TIMEOUT]) {
 +			h->timeout =
 +				ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 +			set->extensions |= IPSET_EXT_TIMEOUT;
 +			if (set->family == NFPROTO_IPV4) {
 +				h->dsize = sizeof(struct
 +					IPSET_TOKEN(HTYPE, 4ct_elem));
 +				h->offset[IPSET_EXT_ID_TIMEOUT] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 4ct_elem),
 +						timeout);
 +				h->offset[IPSET_EXT_ID_COUNTER] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 4ct_elem),
 +						counter);
 +				IPSET_TOKEN(HTYPE, 4_gc_init)(set,
 +					IPSET_TOKEN(HTYPE, 4_gc));
 +			} else {
 +				h->dsize = sizeof(struct
 +					IPSET_TOKEN(HTYPE, 6ct_elem));
 +				h->offset[IPSET_EXT_ID_TIMEOUT] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 6ct_elem),
 +						timeout);
 +				h->offset[IPSET_EXT_ID_COUNTER] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 6ct_elem),
 +						counter);
 +				IPSET_TOKEN(HTYPE, 6_gc_init)(set,
 +					IPSET_TOKEN(HTYPE, 6_gc));
 +			}
 +		} else {
 +			if (set->family == NFPROTO_IPV4) {
 +				h->dsize =
 +					sizeof(struct
 +						IPSET_TOKEN(HTYPE, 4c_elem));
 +				h->offset[IPSET_EXT_ID_COUNTER] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 4c_elem),
 +						counter);
 +			} else {
 +				h->dsize =
 +					sizeof(struct
 +						IPSET_TOKEN(HTYPE, 6c_elem));
 +				h->offset[IPSET_EXT_ID_COUNTER] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 6c_elem),
 +						counter);
 +			}
 +		}
 +	} else if (tb[IPSET_ATTR_TIMEOUT]) {
 +		h->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 +		set->extensions |= IPSET_EXT_TIMEOUT;
 +		if (set->family == NFPROTO_IPV4) {
 +			h->dsize = sizeof(struct IPSET_TOKEN(HTYPE, 4t_elem));
 +			h->offset[IPSET_EXT_ID_TIMEOUT] =
 +				offsetof(struct IPSET_TOKEN(HTYPE, 4t_elem),
 +					 timeout);
++=======
+ 		set->dsize = ip_set_elem_len(set, tb,
+ 			sizeof(struct IPSET_TOKEN(HTYPE, 4_elem)),
+ 			__alignof__(struct IPSET_TOKEN(HTYPE, 4_elem)));
+ #ifndef IP_SET_PROTO_UNDEF
+ 	} else {
+ 		set->variant = &IPSET_TOKEN(HTYPE, 6_variant);
+ 		set->dsize = ip_set_elem_len(set, tb,
+ 			sizeof(struct IPSET_TOKEN(HTYPE, 6_elem)),
+ 			__alignof__(struct IPSET_TOKEN(HTYPE, 6_elem)));
+ 	}
+ #endif
+ 	if (tb[IPSET_ATTR_TIMEOUT]) {
+ 		set->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
+ #ifndef IP_SET_PROTO_UNDEF
+ 		if (set->family == NFPROTO_IPV4)
+ #endif
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  			IPSET_TOKEN(HTYPE, 4_gc_init)(set,
  				IPSET_TOKEN(HTYPE, 4_gc));
 -#ifndef IP_SET_PROTO_UNDEF
 -		else
 +		} else {
 +			h->dsize = sizeof(struct IPSET_TOKEN(HTYPE, 6t_elem));
 +			h->offset[IPSET_EXT_ID_TIMEOUT] =
 +				offsetof(struct IPSET_TOKEN(HTYPE, 6t_elem),
 +					 timeout);
  			IPSET_TOKEN(HTYPE, 6_gc_init)(set,
  				IPSET_TOKEN(HTYPE, 6_gc));
 -#endif
 +		}
 +	} else {
 +		if (set->family == NFPROTO_IPV4)
 +			h->dsize = sizeof(struct IPSET_TOKEN(HTYPE, 4_elem));
 +		else
 +			h->dsize = sizeof(struct IPSET_TOKEN(HTYPE, 6_elem));
  	}
 +
  	pr_debug("create %s hashsize %u (%u) maxelem %u: %p(%p)\n",
 -		 set->name, jhash_size(t->htable_bits),
 -		 t->htable_bits, h->maxelem, set->data, t);
 +		 set->name, jhash_size(h->table->htable_bits),
 +		 h->table->htable_bits, h->maxelem, set->data, h->table);
  
  	return 0;
  }
diff --cc net/netfilter/ipset/ip_set_list_set.c
index a9a97c07ecb4,bbede95c9f68..000000000000
--- a/net/netfilter/ipset/ip_set_list_set.c
+++ b/net/netfilter/ipset/ip_set_list_set.c
@@@ -25,31 -28,11 +25,31 @@@ MODULE_ALIAS("ip_set_list:set")
  
  /* Member elements  */
  struct set_elem {
 -	struct rcu_head rcu;
 -	struct list_head list;
  	ip_set_id_t id;
- };
+ } __aligned(__alignof__(u64));
  
 +struct sett_elem {
 +	struct {
 +		ip_set_id_t id;
 +	} __attribute__ ((aligned));
 +	unsigned long timeout;
 +};
 +
 +struct setc_elem {
 +	struct {
 +		ip_set_id_t id;
 +	} __attribute__ ((aligned));
 +	struct ip_set_counter counter;
 +};
 +
 +struct setct_elem {
 +	struct {
 +		ip_set_id_t id;
 +	} __attribute__ ((aligned));
 +	struct ip_set_counter counter;
 +	unsigned long timeout;
 +};
 +
  struct set_adt_elem {
  	ip_set_id_t id;
  	ip_set_id_t refid;
@@@ -658,45 -617,14 +658,54 @@@ list_set_create(struct net *net, struc
  	if (size < IP_SET_LIST_MIN_SIZE)
  		size = IP_SET_LIST_MIN_SIZE;
  
 +	if (tb[IPSET_ATTR_CADT_FLAGS])
 +		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
 +	if (tb[IPSET_ATTR_TIMEOUT])
 +		timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
  	set->variant = &set_variant;
++<<<<<<< HEAD
 +	if (cadt_flags & IPSET_FLAG_WITH_COUNTERS) {
 +		set->extensions |= IPSET_EXT_COUNTER;
 +		if (tb[IPSET_ATTR_TIMEOUT]) {
 +			map = init_list_set(net, set, size,
 +					sizeof(struct setct_elem), timeout);
 +			if (!map)
 +				return -ENOMEM;
 +			set->extensions |= IPSET_EXT_TIMEOUT;
 +			map->offset[IPSET_EXT_ID_TIMEOUT] =
 +				offsetof(struct setct_elem, timeout);
 +			map->offset[IPSET_EXT_ID_COUNTER] =
 +				offsetof(struct setct_elem, counter);
 +			list_set_gc_init(set, list_set_gc);
 +		} else {
 +			map = init_list_set(net, set, size,
 +					    sizeof(struct setc_elem), 0);
 +			if (!map)
 +				return -ENOMEM;
 +			map->offset[IPSET_EXT_ID_COUNTER] =
 +				offsetof(struct setc_elem, counter);
 +		}
 +	} else if (tb[IPSET_ATTR_TIMEOUT]) {
 +		map = init_list_set(net, set, size,
 +				    sizeof(struct sett_elem), timeout);
 +		if (!map)
 +			return -ENOMEM;
 +		set->extensions |= IPSET_EXT_TIMEOUT;
 +		map->offset[IPSET_EXT_ID_TIMEOUT] =
 +			offsetof(struct sett_elem, timeout);
++=======
+ 	set->dsize = ip_set_elem_len(set, tb, sizeof(struct set_elem),
+ 				     __alignof__(struct set_elem));
+ 	if (!init_list_set(net, set, size))
+ 		return -ENOMEM;
+ 	if (tb[IPSET_ATTR_TIMEOUT]) {
+ 		set->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
++>>>>>>> 95ad1f4a9358 (netfilter: ipset: Fix extension alignment)
  		list_set_gc_init(set, list_set_gc);
 +	} else {
 +		map = init_list_set(net, set, size, sizeof(struct set_elem), 0);
 +		if (!map)
 +			return -ENOMEM;
  	}
  	return 0;
  }
* Unmerged path include/linux/netfilter/ipset/ip_set.h
* Unmerged path net/netfilter/ipset/ip_set_bitmap_gen.h
* Unmerged path net/netfilter/ipset/ip_set_bitmap_ip.c
* Unmerged path net/netfilter/ipset/ip_set_bitmap_ipmac.c
* Unmerged path net/netfilter/ipset/ip_set_bitmap_port.c
* Unmerged path net/netfilter/ipset/ip_set_core.c
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
* Unmerged path net/netfilter/ipset/ip_set_list_set.c
