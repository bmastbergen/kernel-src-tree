net: sched: Identify hardware traffic classes using classid

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] sched: Identify hardware traffic classes using classid (Ivan Vecera) [1579358]
Rebuild_FUZZ: 95.58%
commit-author Amritha Nambiar <amritha.nambiar@intel.com>
commit 384c181e3780ddc45e70483e29d84495b484730d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/384c181e.failed

This patch offloads the classid to hardware and uses the classid
reserved in the range :ffe0 - :ffef to identify hardware traffic
classes reported via dev->num_tc.

tcf_result structure contains the class ID of the class to which
the packet belongs and is offloaded to hardware via flower filter.
A new helper function is introduced to represent HW traffic
classes 0 through 15 using the reserved classid values :ffe0 - :ffef.

	Signed-off-by: Amritha Nambiar <amritha.nambiar@intel.com>
	Acked-by: Shannon Nelson <shannon.nelson@oracle.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 384c181e3780ddc45e70483e29d84495b484730d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/pkt_cls.h
#	net/sched/cls_flower.c
diff --cc include/net/pkt_cls.h
index bf70a6a4bd8a,37c5ef766655..000000000000
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@@ -576,7 -666,7 +576,11 @@@ struct tc_cls_flower_offload 
  	struct fl_flow_key *mask;
  	struct fl_flow_key *key;
  	struct tcf_exts *exts;
++<<<<<<< HEAD
 +	bool egress_dev;
++=======
+ 	u32 classid;
++>>>>>>> 384c181e3780 (net: sched: Identify hardware traffic classes using classid)
  };
  
  enum tc_matchall_command {
diff --cc net/sched/cls_flower.c
index 0f196b560aec,c99fa9e5be46..000000000000
--- a/net/sched/cls_flower.c
+++ b/net/sched/cls_flower.c
@@@ -286,13 -241,20 +286,14 @@@ static int fl_hw_replace_filter(struct 
  	cls_flower.mask = mask;
  	cls_flower.key = &f->mkey;
  	cls_flower.exts = &f->exts;
+ 	cls_flower.classid = f->res.classid;
  
 -	err = tc_setup_cb_call(block, &f->exts, TC_SETUP_CLSFLOWER,
 -			       &cls_flower, skip_sw);
 -	if (err < 0) {
 -		fl_hw_destroy_filter(tp, f);
 -		return err;
 -	} else if (err > 0) {
 +	err = __rh_call_ndo_setup_tc(dev, TC_SETUP_CLSFLOWER, &cls_flower);
 +	if (!err)
  		f->flags |= TCA_CLS_FLAGS_IN_HW;
 -	}
 -
 -	if (skip_sw && !(f->flags & TCA_CLS_FLAGS_IN_HW))
 -		return -EINVAL;
  
 +	if (tc_skip_sw(f->flags))
 +		return err;
  	return 0;
  }
  
@@@ -308,9 -267,10 +309,13 @@@ static void fl_hw_update_stats(struct t
  	cls_flower.command = TC_CLSFLOWER_STATS;
  	cls_flower.cookie = (unsigned long) f;
  	cls_flower.exts = &f->exts;
++<<<<<<< HEAD
 +	cls_flower.egress_dev = f->hw_dev != tp->q->dev_queue->dev;
++=======
+ 	cls_flower.classid = f->res.classid;
++>>>>>>> 384c181e3780 (net: sched: Identify hardware traffic classes using classid)
  
 -	tc_setup_cb_call(block, &f->exts, TC_SETUP_CLSFLOWER,
 -			 &cls_flower, false);
 +	__rh_call_ndo_setup_tc(dev, TC_SETUP_CLSFLOWER, &cls_flower);
  }
  
  static void __fl_delete(struct tcf_proto *tp, struct cls_fl_filter *f)
* Unmerged path include/net/pkt_cls.h
diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h
index 983518dc3688..c5d37853e9a8 100644
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@ -421,6 +421,13 @@ qdisc_class_find(const struct Qdisc_class_hash *hash, u32 id)
 	return NULL;
 }
 
+static inline int tc_classid_to_hwtc(struct net_device *dev, u32 classid)
+{
+	u32 hwtc = TC_H_MIN(classid) - TC_H_MIN_PRIORITY;
+
+	return (hwtc < netdev_get_num_tc(dev)) ? hwtc : -EINVAL;
+}
+
 int qdisc_class_hash_init(struct Qdisc_class_hash *);
 void qdisc_class_hash_insert(struct Qdisc_class_hash *,
 			     struct Qdisc_class_common *);
* Unmerged path net/sched/cls_flower.c
