dax: stop requiring a live device for dax_flush()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [dax] stop requiring a live device for dax_flush() (Jeff Moyer) [1515085]
Rebuild_FUZZ: 94.62%
commit-author Dan Williams <dan.j.williams@intel.com>
commit 6a21586a637e624ae736f94aeb0839f6a1dd0411
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6a21586a.failed

Now that dax_flush() is no longer a driver callback (commit c3ca015fab6d
"dax: remove the pmem_dax_ops->flush abstraction"), stop requiring the
dax_read_lock() to be held and the device to be alive.  This is in
preparation for switching filesystem-dax to store pfns instead of
sectors in the radix.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 6a21586a637e624ae736f94aeb0839f6a1dd0411)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dax/super.c
diff --cc drivers/dax/super.c
index 949ff36e0910,69329e3954ea..000000000000
--- a/drivers/dax/super.c
+++ b/drivers/dax/super.c
@@@ -190,6 -259,47 +190,50 @@@ long dax_direct_access(struct dax_devic
  }
  EXPORT_SYMBOL_GPL(dax_direct_access);
  
++<<<<<<< HEAD
++=======
+ size_t dax_copy_from_iter(struct dax_device *dax_dev, pgoff_t pgoff, void *addr,
+ 		size_t bytes, struct iov_iter *i)
+ {
+ 	if (!dax_alive(dax_dev))
+ 		return 0;
+ 
+ 	return dax_dev->ops->copy_from_iter(dax_dev, pgoff, addr, bytes, i);
+ }
+ EXPORT_SYMBOL_GPL(dax_copy_from_iter);
+ 
+ #ifdef CONFIG_ARCH_HAS_PMEM_API
+ void arch_wb_cache_pmem(void *addr, size_t size);
+ void dax_flush(struct dax_device *dax_dev, void *addr, size_t size)
+ {
+ 	if (unlikely(!test_bit(DAXDEV_WRITE_CACHE, &dax_dev->flags)))
+ 		return;
+ 
+ 	arch_wb_cache_pmem(addr, size);
+ }
+ #else
+ void dax_flush(struct dax_device *dax_dev, void *addr, size_t size)
+ {
+ }
+ #endif
+ EXPORT_SYMBOL_GPL(dax_flush);
+ 
+ void dax_write_cache(struct dax_device *dax_dev, bool wc)
+ {
+ 	if (wc)
+ 		set_bit(DAXDEV_WRITE_CACHE, &dax_dev->flags);
+ 	else
+ 		clear_bit(DAXDEV_WRITE_CACHE, &dax_dev->flags);
+ }
+ EXPORT_SYMBOL_GPL(dax_write_cache);
+ 
+ bool dax_write_cache_enabled(struct dax_device *dax_dev)
+ {
+ 	return test_bit(DAXDEV_WRITE_CACHE, &dax_dev->flags);
+ }
+ EXPORT_SYMBOL_GPL(dax_write_cache_enabled);
+ 
++>>>>>>> 6a21586a637e (dax: stop requiring a live device for dax_flush())
  bool dax_alive(struct dax_device *dax_dev)
  {
  	lockdep_assert_held(&dax_srcu);
* Unmerged path drivers/dax/super.c
