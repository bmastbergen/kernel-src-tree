xhci: switch to pci_alloc_irq_vectors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 77d45b4500967de674b8f75a9a91f58d57d5704d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/77d45b45.failed

Use the modern API to request MSI or MSI-X interrupts, which allows us to
get rid of the msix_entries array, as well as cleaning up the cleanup
code.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 77d45b4500967de674b8f75a9a91f58d57d5704d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/host/xhci.c
diff --cc drivers/usb/host/xhci.c
index e47292b7e7d5,2d1310220832..000000000000
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@@ -219,31 -216,21 +219,36 @@@ int xhci_reset(struct xhci_hcd *xhci
  	return ret;
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_PCI
 +static int xhci_free_msi(struct xhci_hcd *xhci)
 +{
 +	int i;
 +
 +	if (!xhci->msix_entries)
 +		return -EINVAL;
 +
 +	for (i = 0; i < xhci->msix_count; i++)
 +		if (xhci->msix_entries[i].vector)
 +			free_irq(xhci->msix_entries[i].vector,
 +					xhci_to_hcd(xhci));
 +	return 0;
 +}
 +
++=======
+ 
+ #ifdef CONFIG_USB_PCI
++>>>>>>> 77d45b450096 (xhci: switch to pci_alloc_irq_vectors)
  /*
   * Set up MSI
   */
  static int xhci_setup_msi(struct xhci_hcd *xhci)
  {
  	int ret;
 -	/*
 -	 * TODO:Check with MSI Soc for sysdev
 -	 */
  	struct pci_dev  *pdev = to_pci_dev(xhci_to_hcd(xhci)->self.controller);
  
- 	ret = pci_enable_msi(pdev);
- 	if (ret) {
+ 	ret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);
+ 	if (ret < 0) {
  		xhci_dbg_trace(xhci, trace_xhci_dbg_init,
  				"failed to allocate MSI entry");
  		return ret;
@@@ -261,28 -248,6 +266,31 @@@
  }
  
  /*
++<<<<<<< HEAD
 + * Free IRQs
 + * free all IRQs request
 + */
 +static void xhci_free_irq(struct xhci_hcd *xhci)
 +{
 +	struct pci_dev *pdev = to_pci_dev(xhci_to_hcd(xhci)->self.controller);
 +	int ret;
 +
 +	/* return if using legacy interrupt */
 +	if (xhci_to_hcd(xhci)->irq > 0)
 +		return;
 +
 +	ret = xhci_free_msi(xhci);
 +	if (!ret)
 +		return;
 +	if (pdev->irq > 0)
 +		free_irq(pdev->irq, xhci_to_hcd(xhci));
 +
 +	return;
 +}
 +
 +/*
++=======
++>>>>>>> 77d45b450096 (xhci: switch to pci_alloc_irq_vectors)
   * Set up MSI-X
   */
  static int xhci_setup_msix(struct xhci_hcd *xhci)
* Unmerged path drivers/usb/host/xhci.c
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 2aac1123ccfc..5b072072faf4 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1725,7 +1725,6 @@ struct xhci_hcd {
 	int		page_shift;
 	/* msi-x vectors */
 	int		msix_count;
-	struct msix_entry	*msix_entries;
 	/* optional clock */
 	struct clk		*clk;
 	/* data structures */
