x86/microcode: Request microcode on the BSP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] microcode: Request microcode on the BSP (Prarit Bhargava) [1568249]
Rebuild_FUZZ: 95.12%
commit-author Borislav Petkov <bp@suse.de>
commit cfb52a5a09c8ae3a1dafb44ce549fde5b69e8117
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/cfb52a5a.failed

... so that any newer version can land in the cache and can later be
fished out by the application functions. Do that before grabbing the
hotplug lock.

	Signed-off-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Tested-by: Tom Lendacky <thomas.lendacky@amd.com>
	Tested-by: Ashok Raj <ashok.raj@intel.com>
	Reviewed-by: Tom Lendacky <thomas.lendacky@amd.com>
	Cc: Arjan Van De Ven <arjan.van.de.ven@intel.com>
Link: https://lkml.kernel.org/r/20180228102846.13447-7-bp@alien8.de

(cherry picked from commit cfb52a5a09c8ae3a1dafb44ce549fde5b69e8117)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/microcode/core.c
diff --cc arch/x86/kernel/cpu/microcode/core.c
index 1b81185d9250,5dd157d48606..000000000000
--- a/arch/x86/kernel/cpu/microcode/core.c
+++ b/arch/x86/kernel/cpu/microcode/core.c
@@@ -369,31 -486,35 +369,46 @@@ static void __exit microcode_dev_exit(v
  /* fake device for request_firmware */
  static struct platform_device	*microcode_pdev;
  
 -static int check_online_cpus(void)
 -{
 -	if (num_online_cpus() == num_present_cpus())
 -		return 0;
 -
 -	pr_err("Not all CPUs online, aborting microcode update.\n");
 -
 -	return -EINVAL;
 -}
 -
 -static enum ucode_state reload_for_cpu(int cpu)
 +static int reload_for_cpu(int cpu)
  {
  	struct ucode_cpu_info *uci = ucode_cpu_info + cpu;
++<<<<<<< HEAD
 +	enum ucode_state ustate;
 +	int err = 0;
++=======
++>>>>>>> cfb52a5a09c8 (x86/microcode: Request microcode on the BSP)
  
  	if (!uci->valid)
 -		return UCODE_OK;
 +		return err;
  
++<<<<<<< HEAD
 +	ustate = microcode_ops->request_microcode_fw(cpu, &microcode_pdev->dev, true);
 +	if (ustate == UCODE_OK)
 +		apply_microcode_on_target(cpu);
 +	else
 +		if (ustate == UCODE_ERROR)
 +			err = -EINVAL;
 +	return err;
++=======
+ 	return apply_microcode_on_target(cpu);
++>>>>>>> cfb52a5a09c8 (x86/microcode: Request microcode on the BSP)
  }
  
  static ssize_t reload_store(struct device *dev,
  			    struct device_attribute *attr,
  			    const char *buf, size_t size)
  {
++<<<<<<< HEAD
 +	unsigned long val;
 +	int cpu;
 +	ssize_t ret = 0, tmp_ret;
++=======
+ 	int cpu, bsp = boot_cpu_data.cpu_index;
+ 	enum ucode_state tmp_ret = UCODE_OK;
+ 	bool do_callback = false;
+ 	unsigned long val;
+ 	ssize_t ret = 0;
++>>>>>>> cfb52a5a09c8 (x86/microcode: Request microcode on the BSP)
  
  	ret = kstrtoul(buf, 0, &val);
  	if (ret)
@@@ -402,22 -523,38 +417,26 @@@
  	if (val != 1)
  		return size;
  
+ 	tmp_ret = microcode_ops->request_microcode_fw(bsp, &microcode_pdev->dev, true);
+ 	if (tmp_ret != UCODE_OK)
+ 		return size;
+ 
  	get_online_cpus();
 -
 -	ret = check_online_cpus();
 -	if (ret)
 -		goto put;
 -
  	mutex_lock(&microcode_mutex);
 -
  	for_each_online_cpu(cpu) {
  		tmp_ret = reload_for_cpu(cpu);
 -		if (tmp_ret > UCODE_NFOUND) {
 +		if (tmp_ret != 0)
  			pr_warn("Error reloading microcode on CPU %d\n", cpu);
  
 -			/* set retval for the first encountered reload error */
 -			if (!ret)
 -				ret = -EINVAL;
 -		}
 -
 -		if (tmp_ret == UCODE_UPDATED)
 -			do_callback = true;
 +		/* save retval of the first encountered reload error */
 +		if (!ret)
 +			ret = tmp_ret;
 +	}
 +	if (!ret) {
 +		perf_check_microcode();
 +		spec_ctrl_rescan_cpuid();
  	}
 -
 -	if (!ret && do_callback)
 -		microcode_check();
 -
  	mutex_unlock(&microcode_mutex);
 -
 -put:
  	put_online_cpus();
  
  	if (!ret)
* Unmerged path arch/x86/kernel/cpu/microcode/core.c
