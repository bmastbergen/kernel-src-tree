x86/PCI: VMD: Eliminate index member from IRQ list

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] pci: vmd: Eliminate index member from IRQ list (Myron Stowe) [1515090]
Rebuild_FUZZ: 95.83%
commit-author Jon Derrick <jonathan.derrick@intel.com>
commit b31822277abcd7c83d1c1c0af876da9ccdf3b7d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b3182227.failed

Use math to discover the IRQ list index number relative to the IRQ list
head.

	Signed-off-by: Jon Derrick <jonathan.derrick@intel.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Acked-by: Keith Busch <keith.busch@intel.com>
(cherry picked from commit b31822277abcd7c83d1c1c0af876da9ccdf3b7d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/pci/vmd.c
diff --cc arch/x86/pci/vmd.c
index f5897b179675,e785907acb79..000000000000
--- a/arch/x86/pci/vmd.c
+++ b/arch/x86/pci/vmd.c
@@@ -56,16 -56,11 +56,22 @@@ struct vmd_irq 
  /**
   * struct vmd_irq_list - list of driver requested IRQs mapping to a VMD vector
   * @irq_list:	the list of irq's the VMD one demuxes to.
++<<<<<<< HEAD
 + * @vmd_vector:	the h/w IRQ assigned to the VMD.
 + * @index:	index into the VMD MSI-X table; used for message routing.
++=======
++>>>>>>> b31822277abc (x86/PCI: VMD: Eliminate index member from IRQ list)
   * @count:	number of child IRQs assigned to this vector; used to track
   *		sharing.
   */
  struct vmd_irq_list {
  	struct list_head	irq_list;
++<<<<<<< HEAD
 +	struct vmd_dev		*vmd;
 +	unsigned int		vmd_vector;
 +	unsigned int		index;
++=======
++>>>>>>> b31822277abc (x86/PCI: VMD: Eliminate index member from IRQ list)
  	unsigned int		count;
  };
  
@@@ -93,7 -89,33 +99,36 @@@ static inline struct vmd_dev *vmd_from_
  	return container_of(bus->sysdata, struct vmd_dev, sysdata);
  }
  
+ static inline unsigned int index_from_irqs(struct vmd_dev *vmd,
+ 					   struct vmd_irq_list *irqs)
+ {
+ 	return irqs - vmd->irqs;
+ }
+ 
+ /*
++<<<<<<< HEAD
++=======
+  * Drivers managing a device in a VMD domain allocate their own IRQs as before,
+  * but the MSI entry for the hardware it's driving will be programmed with a
+  * destination ID for the VMD MSI-X table.  The VMD muxes interrupts in its
+  * domain into one of its own, and the VMD driver de-muxes these for the
+  * handlers sharing that VMD IRQ.  The vmd irq_domain provides the operations
+  * and irq_chip to set this up.
+  */
+ static void vmd_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)
+ {
+ 	struct vmd_irq *vmdirq = data->chip_data;
+ 	struct vmd_irq_list *irq = vmdirq->irq;
+ 	struct vmd_dev *vmd = irq_data_get_irq_handler_data(data);
+ 
+ 	msg->address_hi = MSI_ADDR_BASE_HI;
+ 	msg->address_lo = MSI_ADDR_BASE_LO |
+ 			  MSI_ADDR_DEST_ID(index_from_irqs(vmd, irq));
+ 	msg->data = 0;
+ }
+ 
  /*
++>>>>>>> b31822277abc (x86/PCI: VMD: Eliminate index member from IRQ list)
   * We rely on MSI_FLAG_USE_DEF_CHIP_OPS to set the IRQ mask/unmask ops.
   */
  static void vmd_irq_enable(struct irq_data *data)
@@@ -169,55 -189,26 +204,73 @@@ static struct vmd_irq_list *vmd_next_ir
  	return &vmd->irqs[best];
  }
  
 -static int vmd_msi_init(struct irq_domain *domain, struct msi_domain_info *info,
 -			unsigned int virq, irq_hw_number_t hwirq,
 -			msi_alloc_info_t *arg)
 +static int vmd_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)
  {
++<<<<<<< HEAD
 +	int i = 0;
 +	unsigned int irq, virq;
 +	struct msi_desc *msidesc;
 +	struct irq_desc *desc;
 +	struct vmd_dev *vmd = vmd_from_bus(dev->bus);
++=======
+ 	struct msi_desc *desc = arg->desc;
+ 	struct vmd_dev *vmd = vmd_from_bus(msi_desc_to_pci_dev(desc)->bus);
+ 	struct vmd_irq *vmdirq = kzalloc(sizeof(*vmdirq), GFP_KERNEL);
+ 	unsigned int index, vector;
++>>>>>>> b31822277abc (x86/PCI: VMD: Eliminate index member from IRQ list)
  
 -	if (!vmdirq)
 -		return -ENOMEM;
 +	if (type == PCI_CAP_ID_MSI && nvec > 1)
 +		return 1;
 +	if (nvec > vmd->msix_count)
 +		return vmd->msix_count;
 +	if (nvec <= 0)
 +		return -EINVAL;
 +
++<<<<<<< HEAD
 +	irq = irq_alloc_descs(-1, 0, nvec, -1);
 +	if (irq < 0)
 +		return irq;
  
 +	list_for_each_entry(msidesc, &dev->msi_list, list) {
 +		struct vmd_irq *vmdirq;
 +		struct msi_msg msg;
 +
 +		vmdirq = kzalloc(sizeof(*vmdirq), GFP_KERNEL);
 +		if (!vmdirq)
 +			return -ENOMEM;
 +
 +		virq = i + irq;
 +		desc = irq_to_desc(virq);
 +		desc->irq_data.msi_desc = msidesc;
 +
 +		INIT_LIST_HEAD(&vmdirq->node);
 +		vmdirq->irq = vmd_next_irq(vmd, msidesc);
 +		vmdirq->virq = virq;
 +
 +		irq_set_handler_data(virq, vmdirq);
 +		irq_set_chip_and_handler(virq, &vmd_msi_controller,
 +					 handle_untracked_irq);
 +
 +		msg.address_hi = MSI_ADDR_BASE_HI;
 +		msg.address_lo = MSI_ADDR_BASE_LO | MSI_ADDR_DEST_ID(vmdirq->irq->index);
 +		msg.data = 0;
 +
 +		msidesc->irq = virq;
 +		msidesc->msg = msg;
 +		write_msi_msg(virq, &msg);
 +
 +		i++;
 +	}
++=======
+ 	INIT_LIST_HEAD(&vmdirq->node);
+ 	vmdirq->irq = vmd_next_irq(vmd, desc);
+ 	vmdirq->virq = virq;
+ 	index = index_from_irqs(vmd, vmdirq->irq);
+ 	vector = pci_irq_vector(vmd->dev, index);
+ 
+ 	irq_domain_set_info(domain, virq, vector, info->chip, vmdirq,
+ 			    handle_untracked_irq, vmd, NULL);
++>>>>>>> b31822277abc (x86/PCI: VMD: Eliminate index member from IRQ list)
  	return 0;
  }
  
@@@ -665,10 -688,7 +718,14 @@@ static int vmd_probe(struct pci_dev *de
  
  	for (i = 0; i < vmd->msix_count; i++) {
  		INIT_LIST_HEAD(&vmd->irqs[i].irq_list);
++<<<<<<< HEAD
 +		vmd->irqs[i].vmd_vector = pci_irq_vector(dev, i);
 +		vmd->irqs[i].index = i;
 +
 +		err = devm_request_irq(&dev->dev, vmd->irqs[i].vmd_vector,
++=======
+ 		err = devm_request_irq(&dev->dev, pci_irq_vector(dev, i),
++>>>>>>> b31822277abc (x86/PCI: VMD: Eliminate index member from IRQ list)
  				       vmd_irq, 0, "vmd", &vmd->irqs[i]);
  		if (err)
  			return err;
* Unmerged path arch/x86/pci/vmd.c
