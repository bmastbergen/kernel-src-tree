ceph: wait on writeback after writing snapshot data

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Yan, Zheng <zyan@redhat.com>
commit f275635ee0b6641151dfaf07b901d7c8d4d8e987
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f275635e.failed

In sync mode, writepages() needs to write all dirty pages. But
it can only write dirty pages associated with the oldest snapc.
To write dirty pages associated with next snapc, it needs to wait
until current writes complete.

Without this wait, writepages() keeps looking up dirty pages, but
the found dirty pages are not writeable. It wastes CPU time.

	Signed-off-by: "Yan, Zheng" <zyan@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit f275635ee0b6641151dfaf07b901d7c8d4d8e987)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/addr.c
diff --cc fs/ceph/addr.c
index adf7d1009bc0,b3e3edc09d80..000000000000
--- a/fs/ceph/addr.c
+++ b/fs/ceph/addr.c
@@@ -1089,7 -1164,32 +1089,36 @@@ release_pvec_pages
  	if (should_loop && !done) {
  		/* more to do; loop back to beginning of file */
  		dout("writepages looping back to beginning of file\n");
++<<<<<<< HEAD
 +		should_loop = 0;
++=======
+ 		end = start_index - 1; /* OK even when start_index == 0 */
+ 
+ 		/* to write dirty pages associated with next snapc,
+ 		 * we need to wait until current writes complete */
+ 		if (wbc->sync_mode != WB_SYNC_NONE &&
+ 		    start_index == 0 && /* all dirty pages were checked */
+ 		    !ceph_wbc.head_snapc) {
+ 			struct page *page;
+ 			unsigned i, nr;
+ 			index = 0;
+ 			while ((index <= end) &&
+ 			       (nr = pagevec_lookup_tag(&pvec, mapping, &index,
+ 							PAGECACHE_TAG_WRITEBACK,
+ 							PAGEVEC_SIZE))) {
+ 				for (i = 0; i < nr; i++) {
+ 					page = pvec.pages[i];
+ 					if (page_snap_context(page) != snapc)
+ 						continue;
+ 					wait_on_page_writeback(page);
+ 				}
+ 				pagevec_release(&pvec);
+ 				cond_resched();
+ 			}
+ 		}
+ 
+ 		start_index = 0;
++>>>>>>> f275635ee0b6 (ceph: wait on writeback after writing snapshot data)
  		index = 0;
  		goto retry;
  	}
* Unmerged path fs/ceph/addr.c
