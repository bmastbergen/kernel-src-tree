mmc: core: start to break apart mmc_start_areq()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] core: start to break apart mmc_start_areq() (Gopal Tiwari) [1549495]
Rebuild_FUZZ: 94.51%
commit-author Linus Walleij <linus.walleij@linaro.org>
commit 37dac0681e2be4f3c32b090a8c0591d4ce57e6f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/37dac068.failed

This function is doing to many clever things at the same time under
too many various conditions.

Start to make things clearer by refactoring: break out the
finalization of the previous asynchronous request to its own
function mmc_finalize_areq(). We can get rid of the default
assignment of status and let the call deal with this.

	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 37dac0681e2be4f3c32b090a8c0591d4ce57e6f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/core.c
diff --cc drivers/mmc/core/core.c
index 2669557edd36,926e0fde07d7..000000000000
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@@ -629,10 -631,41 +629,45 @@@ static void mmc_post_req(struct mmc_hos
  }
  
  /**
++<<<<<<< HEAD
 + *	mmc_start_req - start a non-blocking request
++=======
+  * mmc_finalize_areq() - finalize an asynchronous request
+  * @host: MMC host to finalize any ongoing request on
+  *
+  * Returns the status of the ongoing asynchronous request, but
+  * MMC_BLK_SUCCESS if no request was going on.
+  */
+ static enum mmc_blk_status mmc_finalize_areq(struct mmc_host *host)
+ {
+ 	enum mmc_blk_status status;
+ 
+ 	if (!host->areq)
+ 		return MMC_BLK_SUCCESS;
+ 
+ 	status = mmc_wait_for_data_req_done(host, host->areq->mrq);
+ 	if (status == MMC_BLK_NEW_REQUEST)
+ 		return status;
+ 
+ 	/*
+ 	 * Check BKOPS urgency for each R1 response
+ 	 */
+ 	if (host->card && mmc_card_mmc(host->card) &&
+ 	    ((mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1) ||
+ 	     (mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1B)) &&
+ 	    (host->areq->mrq->cmd->resp[0] & R1_EXCEPTION_EVENT)) {
+ 		mmc_start_bkops(host->card, true);
+ 	}
+ 
+ 	return status;
+ }
+ 
+ /**
+  *	mmc_start_areq - start an asynchronous request
++>>>>>>> 37dac0681e2b (mmc: core: start to break apart mmc_start_areq())
   *	@host: MMC host to start command
 - *	@areq: asynchronous request to start
 - *	@ret_stat: out parameter for status
 + *	@areq: async request to start
 + *	@error: out parameter returns 0 for success, otherwise non zero
   *
   *	Start a new MMC custom command request for a host.
   *	If there is on ongoing async request wait for completion
@@@ -644,11 -677,11 +679,11 @@@
   *	return the completed request. If there is no ongoing request, NULL
   *	is returned without waiting. NULL is not an error condition.
   */
 -struct mmc_async_req *mmc_start_areq(struct mmc_host *host,
 -				     struct mmc_async_req *areq,
 -				     enum mmc_blk_status *ret_stat)
 +struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 +				    struct mmc_async_req *areq,
 +				    enum mmc_blk_status *ret_stat)
  {
- 	enum mmc_blk_status status = MMC_BLK_SUCCESS;
+ 	enum mmc_blk_status status;
  	int start_err = 0;
  	struct mmc_async_req *data = host->areq;
  
@@@ -656,37 -689,17 +691,49 @@@
  	if (areq)
  		mmc_pre_req(host, areq->mrq);
  
++<<<<<<< HEAD
 +	if (host->areq) {
 +		status = mmc_wait_for_data_req_done(host, host->areq->mrq);
 +		if (status == MMC_BLK_NEW_REQUEST) {
 +			if (ret_stat)
 +				*ret_stat = status;
 +			/*
 +			 * The previous request was not completed,
 +			 * nothing to return
 +			 */
 +			return NULL;
 +		}
 +		/*
 +		 * Check BKOPS urgency for each R1 response
 +		 */
 +		if (host->card && mmc_card_mmc(host->card) &&
 +		    ((mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1) ||
 +		     (mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1B)) &&
 +		    (host->areq->mrq->cmd->resp[0] & R1_EXCEPTION_EVENT)) {
 +
 +			/* Cancel the prepared request */
 +			if (areq)
 +				mmc_post_req(host, areq->mrq, -EINVAL);
 +
 +			mmc_start_bkops(host->card, true);
 +
 +			/* prepare the request again */
 +			if (areq)
 +				mmc_pre_req(host, areq->mrq);
 +		}
++=======
+ 	/* Finalize previous request */
+ 	status = mmc_finalize_areq(host);
+ 
+ 	/* The previous request is still going on... */
+ 	if (status == MMC_BLK_NEW_REQUEST) {
+ 		if (ret_stat)
+ 			*ret_stat = status;
+ 		return NULL;
++>>>>>>> 37dac0681e2b (mmc: core: start to break apart mmc_start_areq())
  	}
  
+ 	/* Fine so far, start the new request! */
  	if (status == MMC_BLK_SUCCESS && areq)
  		start_err = __mmc_start_data_req(host, areq->mrq);
  
* Unmerged path drivers/mmc/core/core.c
