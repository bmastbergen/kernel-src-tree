vmbus: don't return values for uninitalized channels

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Stephen Hemminger <stephen@networkplumber.org>
commit 6712cc9c22117a8af9f3df272b4a44fd2e4201cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6712cc9c.failed

For unsupported device types, the vmbus channel ringbuffer is never
initialized, and therefore reading the sysfs files will return garbage
or cause a kernel OOPS.

Fixes: c2e5df616e1a ("vmbus: add per-channel sysfs info")

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Cc: <stable@vger.kernel.org> # 4.15
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 6712cc9c22117a8af9f3df272b4a44fd2e4201cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/vmbus_drv.c
diff --cc drivers/hv/vmbus_drv.c
index e26423054c5d,c71cc857b649..000000000000
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@@ -1186,6 -1252,179 +1186,182 @@@ void vmbus_driver_unregister(struct hv_
  }
  EXPORT_SYMBOL_GPL(vmbus_driver_unregister);
  
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Called when last reference to channel is gone.
+  */
+ static void vmbus_chan_release(struct kobject *kobj)
+ {
+ 	struct vmbus_channel *channel
+ 		= container_of(kobj, struct vmbus_channel, kobj);
+ 
+ 	kfree_rcu(channel, rcu);
+ }
+ 
+ struct vmbus_chan_attribute {
+ 	struct attribute attr;
+ 	ssize_t (*show)(const struct vmbus_channel *chan, char *buf);
+ 	ssize_t (*store)(struct vmbus_channel *chan,
+ 			 const char *buf, size_t count);
+ };
+ #define VMBUS_CHAN_ATTR(_name, _mode, _show, _store) \
+ 	struct vmbus_chan_attribute chan_attr_##_name \
+ 		= __ATTR(_name, _mode, _show, _store)
+ #define VMBUS_CHAN_ATTR_RW(_name) \
+ 	struct vmbus_chan_attribute chan_attr_##_name = __ATTR_RW(_name)
+ #define VMBUS_CHAN_ATTR_RO(_name) \
+ 	struct vmbus_chan_attribute chan_attr_##_name = __ATTR_RO(_name)
+ #define VMBUS_CHAN_ATTR_WO(_name) \
+ 	struct vmbus_chan_attribute chan_attr_##_name = __ATTR_WO(_name)
+ 
+ static ssize_t vmbus_chan_attr_show(struct kobject *kobj,
+ 				    struct attribute *attr, char *buf)
+ {
+ 	const struct vmbus_chan_attribute *attribute
+ 		= container_of(attr, struct vmbus_chan_attribute, attr);
+ 	const struct vmbus_channel *chan
+ 		= container_of(kobj, struct vmbus_channel, kobj);
+ 
+ 	if (!attribute->show)
+ 		return -EIO;
+ 
+ 	if (chan->state != CHANNEL_OPENED_STATE)
+ 		return -EINVAL;
+ 
+ 	return attribute->show(chan, buf);
+ }
+ 
+ static const struct sysfs_ops vmbus_chan_sysfs_ops = {
+ 	.show = vmbus_chan_attr_show,
+ };
+ 
+ static ssize_t out_mask_show(const struct vmbus_channel *channel, char *buf)
+ {
+ 	const struct hv_ring_buffer_info *rbi = &channel->outbound;
+ 
+ 	return sprintf(buf, "%u\n", rbi->ring_buffer->interrupt_mask);
+ }
+ static VMBUS_CHAN_ATTR_RO(out_mask);
+ 
+ static ssize_t in_mask_show(const struct vmbus_channel *channel, char *buf)
+ {
+ 	const struct hv_ring_buffer_info *rbi = &channel->inbound;
+ 
+ 	return sprintf(buf, "%u\n", rbi->ring_buffer->interrupt_mask);
+ }
+ static VMBUS_CHAN_ATTR_RO(in_mask);
+ 
+ static ssize_t read_avail_show(const struct vmbus_channel *channel, char *buf)
+ {
+ 	const struct hv_ring_buffer_info *rbi = &channel->inbound;
+ 
+ 	return sprintf(buf, "%u\n", hv_get_bytes_to_read(rbi));
+ }
+ static VMBUS_CHAN_ATTR_RO(read_avail);
+ 
+ static ssize_t write_avail_show(const struct vmbus_channel *channel, char *buf)
+ {
+ 	const struct hv_ring_buffer_info *rbi = &channel->outbound;
+ 
+ 	return sprintf(buf, "%u\n", hv_get_bytes_to_write(rbi));
+ }
+ static VMBUS_CHAN_ATTR_RO(write_avail);
+ 
+ static ssize_t show_target_cpu(const struct vmbus_channel *channel, char *buf)
+ {
+ 	return sprintf(buf, "%u\n", channel->target_cpu);
+ }
+ static VMBUS_CHAN_ATTR(cpu, S_IRUGO, show_target_cpu, NULL);
+ 
+ static ssize_t channel_pending_show(const struct vmbus_channel *channel,
+ 				    char *buf)
+ {
+ 	return sprintf(buf, "%d\n",
+ 		       channel_pending(channel,
+ 				       vmbus_connection.monitor_pages[1]));
+ }
+ static VMBUS_CHAN_ATTR(pending, S_IRUGO, channel_pending_show, NULL);
+ 
+ static ssize_t channel_latency_show(const struct vmbus_channel *channel,
+ 				    char *buf)
+ {
+ 	return sprintf(buf, "%d\n",
+ 		       channel_latency(channel,
+ 				       vmbus_connection.monitor_pages[1]));
+ }
+ static VMBUS_CHAN_ATTR(latency, S_IRUGO, channel_latency_show, NULL);
+ 
+ static ssize_t channel_interrupts_show(const struct vmbus_channel *channel, char *buf)
+ {
+ 	return sprintf(buf, "%llu\n", channel->interrupts);
+ }
+ static VMBUS_CHAN_ATTR(interrupts, S_IRUGO, channel_interrupts_show, NULL);
+ 
+ static ssize_t channel_events_show(const struct vmbus_channel *channel, char *buf)
+ {
+ 	return sprintf(buf, "%llu\n", channel->sig_events);
+ }
+ static VMBUS_CHAN_ATTR(events, S_IRUGO, channel_events_show, NULL);
+ 
+ static ssize_t subchannel_monitor_id_show(const struct vmbus_channel *channel,
+ 					  char *buf)
+ {
+ 	return sprintf(buf, "%u\n", channel->offermsg.monitorid);
+ }
+ static VMBUS_CHAN_ATTR(monitor_id, S_IRUGO, subchannel_monitor_id_show, NULL);
+ 
+ static ssize_t subchannel_id_show(const struct vmbus_channel *channel,
+ 				  char *buf)
+ {
+ 	return sprintf(buf, "%u\n",
+ 		       channel->offermsg.offer.sub_channel_index);
+ }
+ static VMBUS_CHAN_ATTR_RO(subchannel_id);
+ 
+ static struct attribute *vmbus_chan_attrs[] = {
+ 	&chan_attr_out_mask.attr,
+ 	&chan_attr_in_mask.attr,
+ 	&chan_attr_read_avail.attr,
+ 	&chan_attr_write_avail.attr,
+ 	&chan_attr_cpu.attr,
+ 	&chan_attr_pending.attr,
+ 	&chan_attr_latency.attr,
+ 	&chan_attr_interrupts.attr,
+ 	&chan_attr_events.attr,
+ 	&chan_attr_monitor_id.attr,
+ 	&chan_attr_subchannel_id.attr,
+ 	NULL
+ };
+ 
+ static struct kobj_type vmbus_chan_ktype = {
+ 	.sysfs_ops = &vmbus_chan_sysfs_ops,
+ 	.release = vmbus_chan_release,
+ 	.default_attrs = vmbus_chan_attrs,
+ };
+ 
+ /*
+  * vmbus_add_channel_kobj - setup a sub-directory under device/channels
+  */
+ int vmbus_add_channel_kobj(struct hv_device *dev, struct vmbus_channel *channel)
+ {
+ 	struct kobject *kobj = &channel->kobj;
+ 	u32 relid = channel->offermsg.child_relid;
+ 	int ret;
+ 
+ 	kobj->kset = dev->channels_kset;
+ 	ret = kobject_init_and_add(kobj, &vmbus_chan_ktype, NULL,
+ 				   "%u", relid);
+ 	if (ret)
+ 		return ret;
+ 
+ 	kobject_uevent(kobj, KOBJ_ADD);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 6712cc9c2211 (vmbus: don't return values for uninitalized channels)
  /*
   * vmbus_device_create - Creates and registers a new child device
   * on the vmbus.
* Unmerged path drivers/hv/vmbus_drv.c
