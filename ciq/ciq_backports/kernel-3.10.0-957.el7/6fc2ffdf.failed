bnxt_en: Fix vnic accounting in the bnxt_check_rings() path.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] bnxt_en: Fix vnic accounting in the bnxt_check_rings() path (Jonathan Toppins) [1526120]
Rebuild_FUZZ: 99.16%
commit-author Eddie Wai <eddie.wai@broadcom.com>
commit 6fc2ffdf1001ae4fb485b3ba95ff757ae54565c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6fc2ffdf.failed

The number of vnics to check must be determined ahead of time because
only standard RX rings require vnics to support RFS.  The logic is
similar to the ring reservation logic and we can now use the
refactored common functions to do most of the work in setting up
the firmware message.

Fixes: 8f23d638b36b ("bnxt_en: Expand bnxt_check_rings() to check all resources.")
	Signed-off-by: Eddie Wai <eddie.wai@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6fc2ffdf1001ae4fb485b3ba95ff757ae54565c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 6a4dbaafe7b1,b847d54504ed..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -4734,26 -4763,68 +4734,91 @@@ static bool bnxt_need_reserve_rings(str
  	return false;
  }
  
++<<<<<<< HEAD
 +static int bnxt_hwrm_check_tx_rings(struct bnxt *bp, int tx_rings)
 +{
 +	struct hwrm_func_cfg_input req = {0};
 +	int rc;
 +
 +	if (bp->hwrm_spec_code < 0x10801)
 +		return 0;
 +
 +	if (BNXT_VF(bp))
 +		return 0;
 +
 +	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_FUNC_CFG, -1, -1);
 +	req.fid = cpu_to_le16(0xffff);
 +	req.flags = cpu_to_le32(FUNC_CFG_REQ_FLAGS_TX_ASSETS_TEST);
 +	req.enables = cpu_to_le32(FUNC_CFG_REQ_ENABLES_NUM_TX_RINGS);
 +	req.num_tx_rings = cpu_to_le16(tx_rings);
 +	rc = hwrm_send_message_silent(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
 +	if (rc)
 +		return -ENOMEM;
 +	return 0;
++=======
+ static int bnxt_hwrm_check_vf_rings(struct bnxt *bp, int tx_rings, int rx_rings,
+ 				    int ring_grps, int cp_rings, int vnics)
+ {
+ 	struct hwrm_func_vf_cfg_input req = {0};
+ 	u32 flags;
+ 	int rc;
+ 
+ 	if (!(bp->flags & BNXT_FLAG_NEW_RM))
+ 		return 0;
+ 
+ 	__bnxt_hwrm_reserve_vf_rings(bp, &req, tx_rings, rx_rings, ring_grps,
+ 				     cp_rings, vnics);
+ 	flags = FUNC_VF_CFG_REQ_FLAGS_TX_ASSETS_TEST |
+ 		FUNC_VF_CFG_REQ_FLAGS_RX_ASSETS_TEST |
+ 		FUNC_VF_CFG_REQ_FLAGS_CMPL_ASSETS_TEST |
+ 		FUNC_VF_CFG_REQ_FLAGS_RING_GRP_ASSETS_TEST |
+ 		FUNC_VF_CFG_REQ_FLAGS_STAT_CTX_ASSETS_TEST |
+ 		FUNC_VF_CFG_REQ_FLAGS_VNIC_ASSETS_TEST;
+ 
+ 	req.flags = cpu_to_le32(flags);
+ 	rc = hwrm_send_message_silent(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ 	if (rc)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ static int bnxt_hwrm_check_pf_rings(struct bnxt *bp, int tx_rings, int rx_rings,
+ 				    int ring_grps, int cp_rings, int vnics)
+ {
+ 	struct hwrm_func_cfg_input req = {0};
+ 	u32 flags;
+ 	int rc;
+ 
+ 	__bnxt_hwrm_reserve_pf_rings(bp, &req, tx_rings, rx_rings, ring_grps,
+ 				     cp_rings, vnics);
+ 	flags = FUNC_CFG_REQ_FLAGS_TX_ASSETS_TEST;
+ 	if (bp->flags & BNXT_FLAG_NEW_RM)
+ 		flags |= FUNC_CFG_REQ_FLAGS_RX_ASSETS_TEST |
+ 			 FUNC_CFG_REQ_FLAGS_CMPL_ASSETS_TEST |
+ 			 FUNC_CFG_REQ_FLAGS_RING_GRP_ASSETS_TEST |
+ 			 FUNC_CFG_REQ_FLAGS_STAT_CTX_ASSETS_TEST |
+ 			 FUNC_CFG_REQ_FLAGS_VNIC_ASSETS_TEST;
+ 
+ 	req.flags = cpu_to_le32(flags);
+ 	rc = hwrm_send_message_silent(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT);
+ 	if (rc)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ static int bnxt_hwrm_check_rings(struct bnxt *bp, int tx_rings, int rx_rings,
+ 				 int ring_grps, int cp_rings, int vnics)
+ {
+ 	if (bp->hwrm_spec_code < 0x10801)
+ 		return 0;
+ 
+ 	if (BNXT_PF(bp))
+ 		return bnxt_hwrm_check_pf_rings(bp, tx_rings, rx_rings,
+ 						ring_grps, cp_rings, vnics);
+ 
+ 	return bnxt_hwrm_check_vf_rings(bp, tx_rings, rx_rings, ring_grps,
+ 					cp_rings, vnics);
++>>>>>>> 6fc2ffdf1001 (bnxt_en: Fix vnic accounting in the bnxt_check_rings() path.)
  }
  
  static void bnxt_hwrm_set_coal_params(struct bnxt_coal *hw_coal,
@@@ -7450,6 -7516,40 +7515,43 @@@ static void bnxt_sp_task(struct work_st
  	clear_bit(BNXT_STATE_IN_SP_TASK, &bp->state);
  }
  
++<<<<<<< HEAD
++=======
+ /* Under rtnl_lock */
+ int bnxt_check_rings(struct bnxt *bp, int tx, int rx, bool sh, int tcs,
+ 		     int tx_xdp)
+ {
+ 	int max_rx, max_tx, tx_sets = 1;
+ 	int tx_rings_needed;
+ 	int rx_rings = rx;
+ 	int cp, vnics, rc;
+ 
+ 	if (tcs)
+ 		tx_sets = tcs;
+ 
+ 	rc = bnxt_get_max_rings(bp, &max_rx, &max_tx, sh);
+ 	if (rc)
+ 		return rc;
+ 
+ 	if (max_rx < rx)
+ 		return -ENOMEM;
+ 
+ 	tx_rings_needed = tx * tx_sets + tx_xdp;
+ 	if (max_tx < tx_rings_needed)
+ 		return -ENOMEM;
+ 
+ 	vnics = 1;
+ 	if (bp->flags & BNXT_FLAG_RFS)
+ 		vnics += rx_rings;
+ 
+ 	if (bp->flags & BNXT_FLAG_AGG_RINGS)
+ 		rx_rings <<= 1;
+ 	cp = sh ? max_t(int, tx_rings_needed, rx) : tx_rings_needed + rx;
+ 	return bnxt_hwrm_check_rings(bp, tx_rings_needed, rx_rings, rx, cp,
+ 				     vnics);
+ }
+ 
++>>>>>>> 6fc2ffdf1001 (bnxt_en: Fix vnic accounting in the bnxt_check_rings() path.)
  static void bnxt_unmap_bars(struct bnxt *bp, struct pci_dev *pdev)
  {
  	if (bp->bar2) {
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
