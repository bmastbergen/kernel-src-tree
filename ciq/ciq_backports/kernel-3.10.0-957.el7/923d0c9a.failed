perf tools: Introduce binary__fprintf()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 923d0c9ae570c3f33a0b5a9517c23ccc816d9b75
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/923d0c9a.failed

Out of print_binary() but receiving a fp pointer and expecting that the
printer be a fprintf like function, i.e. receive a FILE pointer and
return the number of characters printed.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
	Cc: yuzhoujian <yuzhoujian@didichuxing.com>
Link: http://lkml.kernel.org/n/tip-6oqnxr6lmgqe6q6p3iugnscx@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 923d0c9ae570c3f33a0b5a9517c23ccc816d9b75)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-script.c
#	tools/perf/builtin-trace.c
diff --cc tools/perf/builtin-script.c
index 5d6697e4eb08,5a7dfc5691a1..000000000000
--- a/tools/perf/builtin-script.c
+++ b/tools/perf/builtin-script.c
@@@ -1037,6 -1158,207 +1037,210 @@@ static void print_sample_flags(u32 flag
  		printf("  %-11s ", str);
  }
  
++<<<<<<< HEAD
++=======
+ struct printer_data {
+ 	int line_no;
+ 	bool hit_nul;
+ 	bool is_printable;
+ };
+ 
+ static int sample__fprintf_bpf_output(enum binary_printer_ops op,
+ 				      unsigned int val,
+ 				      void *extra, FILE *fp)
+ {
+ 	unsigned char ch = (unsigned char)val;
+ 	struct printer_data *printer_data = extra;
+ 	int printed = 0;
+ 
+ 	switch (op) {
+ 	case BINARY_PRINT_DATA_BEGIN:
+ 		printed += fprintf(fp, "\n");
+ 		break;
+ 	case BINARY_PRINT_LINE_BEGIN:
+ 		printed += fprintf(fp, "%17s", !printer_data->line_no ? "BPF output:" :
+ 						        "           ");
+ 		break;
+ 	case BINARY_PRINT_ADDR:
+ 		printed += fprintf(fp, " %04x:", val);
+ 		break;
+ 	case BINARY_PRINT_NUM_DATA:
+ 		printed += fprintf(fp, " %02x", val);
+ 		break;
+ 	case BINARY_PRINT_NUM_PAD:
+ 		printed += fprintf(fp, "   ");
+ 		break;
+ 	case BINARY_PRINT_SEP:
+ 		printed += fprintf(fp, "  ");
+ 		break;
+ 	case BINARY_PRINT_CHAR_DATA:
+ 		if (printer_data->hit_nul && ch)
+ 			printer_data->is_printable = false;
+ 
+ 		if (!isprint(ch)) {
+ 			printed += fprintf(fp, "%c", '.');
+ 
+ 			if (!printer_data->is_printable)
+ 				break;
+ 
+ 			if (ch == '\0')
+ 				printer_data->hit_nul = true;
+ 			else
+ 				printer_data->is_printable = false;
+ 		} else {
+ 			printed += fprintf(fp, "%c", ch);
+ 		}
+ 		break;
+ 	case BINARY_PRINT_CHAR_PAD:
+ 		printed += fprintf(fp, " ");
+ 		break;
+ 	case BINARY_PRINT_LINE_END:
+ 		printed += fprintf(fp, "\n");
+ 		printer_data->line_no++;
+ 		break;
+ 	case BINARY_PRINT_DATA_END:
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return printed;
+ }
+ 
+ static void print_sample_bpf_output(struct perf_sample *sample)
+ {
+ 	unsigned int nr_bytes = sample->raw_size;
+ 	struct printer_data printer_data = {0, false, true};
+ 
+ 	print_binary(sample->raw_data, nr_bytes, 8,
+ 		     sample__fprintf_bpf_output, &printer_data);
+ 
+ 	if (printer_data.is_printable && printer_data.hit_nul)
+ 		printf("%17s \"%s\"\n", "BPF string:",
+ 		       (char *)(sample->raw_data));
+ }
+ 
+ static void print_sample_spacing(int len, int spacing)
+ {
+ 	if (len > 0 && len < spacing)
+ 		printf("%*s", spacing - len, "");
+ }
+ 
+ static void print_sample_pt_spacing(int len)
+ {
+ 	print_sample_spacing(len, 34);
+ }
+ 
+ static void print_sample_synth_ptwrite(struct perf_sample *sample)
+ {
+ 	struct perf_synth_intel_ptwrite *data = perf_sample__synth_ptr(sample);
+ 	int len;
+ 
+ 	if (perf_sample__bad_synth_size(sample, *data))
+ 		return;
+ 
+ 	len = printf(" IP: %u payload: %#" PRIx64 " ",
+ 		     data->ip, le64_to_cpu(data->payload));
+ 	print_sample_pt_spacing(len);
+ }
+ 
+ static void print_sample_synth_mwait(struct perf_sample *sample)
+ {
+ 	struct perf_synth_intel_mwait *data = perf_sample__synth_ptr(sample);
+ 	int len;
+ 
+ 	if (perf_sample__bad_synth_size(sample, *data))
+ 		return;
+ 
+ 	len = printf(" hints: %#x extensions: %#x ",
+ 		     data->hints, data->extensions);
+ 	print_sample_pt_spacing(len);
+ }
+ 
+ static void print_sample_synth_pwre(struct perf_sample *sample)
+ {
+ 	struct perf_synth_intel_pwre *data = perf_sample__synth_ptr(sample);
+ 	int len;
+ 
+ 	if (perf_sample__bad_synth_size(sample, *data))
+ 		return;
+ 
+ 	len = printf(" hw: %u cstate: %u sub-cstate: %u ",
+ 		     data->hw, data->cstate, data->subcstate);
+ 	print_sample_pt_spacing(len);
+ }
+ 
+ static void print_sample_synth_exstop(struct perf_sample *sample)
+ {
+ 	struct perf_synth_intel_exstop *data = perf_sample__synth_ptr(sample);
+ 	int len;
+ 
+ 	if (perf_sample__bad_synth_size(sample, *data))
+ 		return;
+ 
+ 	len = printf(" IP: %u ", data->ip);
+ 	print_sample_pt_spacing(len);
+ }
+ 
+ static void print_sample_synth_pwrx(struct perf_sample *sample)
+ {
+ 	struct perf_synth_intel_pwrx *data = perf_sample__synth_ptr(sample);
+ 	int len;
+ 
+ 	if (perf_sample__bad_synth_size(sample, *data))
+ 		return;
+ 
+ 	len = printf(" deepest cstate: %u last cstate: %u wake reason: %#x ",
+ 		     data->deepest_cstate, data->last_cstate,
+ 		     data->wake_reason);
+ 	print_sample_pt_spacing(len);
+ }
+ 
+ static void print_sample_synth_cbr(struct perf_sample *sample)
+ {
+ 	struct perf_synth_intel_cbr *data = perf_sample__synth_ptr(sample);
+ 	unsigned int percent, freq;
+ 	int len;
+ 
+ 	if (perf_sample__bad_synth_size(sample, *data))
+ 		return;
+ 
+ 	freq = (le32_to_cpu(data->freq) + 500) / 1000;
+ 	len = printf(" cbr: %2u freq: %4u MHz ", data->cbr, freq);
+ 	if (data->max_nonturbo) {
+ 		percent = (5 + (1000 * data->cbr) / data->max_nonturbo) / 10;
+ 		len += printf("(%3u%%) ", percent);
+ 	}
+ 	print_sample_pt_spacing(len);
+ }
+ 
+ static void print_sample_synth(struct perf_sample *sample,
+ 			       struct perf_evsel *evsel)
+ {
+ 	switch (evsel->attr.config) {
+ 	case PERF_SYNTH_INTEL_PTWRITE:
+ 		print_sample_synth_ptwrite(sample);
+ 		break;
+ 	case PERF_SYNTH_INTEL_MWAIT:
+ 		print_sample_synth_mwait(sample);
+ 		break;
+ 	case PERF_SYNTH_INTEL_PWRE:
+ 		print_sample_synth_pwre(sample);
+ 		break;
+ 	case PERF_SYNTH_INTEL_EXSTOP:
+ 		print_sample_synth_exstop(sample);
+ 		break;
+ 	case PERF_SYNTH_INTEL_PWRX:
+ 		print_sample_synth_pwrx(sample);
+ 		break;
+ 	case PERF_SYNTH_INTEL_CBR:
+ 		print_sample_synth_cbr(sample);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 923d0c9ae570 (perf tools: Introduce binary__fprintf())
  struct perf_script {
  	struct perf_tool	tool;
  	struct perf_session	*session;
diff --cc tools/perf/builtin-trace.c
index 873215ce6cc7,8b23982dd9f2..000000000000
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@@ -1860,6 -1828,37 +1860,40 @@@ out_dump
  	goto out_put;
  }
  
++<<<<<<< HEAD
++=======
+ static int bpf_output__printer(enum binary_printer_ops op,
+ 			       unsigned int val, void *extra __maybe_unused, FILE *fp)
+ {
+ 	unsigned char ch = (unsigned char)val;
+ 
+ 	switch (op) {
+ 	case BINARY_PRINT_CHAR_DATA:
+ 		return fprintf(fp, "%c", isprint(ch) ? ch : '.');
+ 	case BINARY_PRINT_DATA_BEGIN:
+ 	case BINARY_PRINT_LINE_BEGIN:
+ 	case BINARY_PRINT_ADDR:
+ 	case BINARY_PRINT_NUM_DATA:
+ 	case BINARY_PRINT_NUM_PAD:
+ 	case BINARY_PRINT_SEP:
+ 	case BINARY_PRINT_CHAR_PAD:
+ 	case BINARY_PRINT_LINE_END:
+ 	case BINARY_PRINT_DATA_END:
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void bpf_output__fprintf(struct trace *trace,
+ 				struct perf_sample *sample)
+ {
+ 	binary__fprintf(sample->raw_data, sample->raw_size, 8,
+ 			bpf_output__printer, NULL, trace->output);
+ }
+ 
++>>>>>>> 923d0c9ae570 (perf tools: Introduce binary__fprintf())
  static int trace__event_handler(struct trace *trace, struct perf_evsel *evsel,
  				union perf_event *event __maybe_unused,
  				struct perf_sample *sample)
* Unmerged path tools/perf/builtin-script.c
* Unmerged path tools/perf/builtin-trace.c
diff --git a/tools/perf/util/debug.c b/tools/perf/util/debug.c
index a5b3777ffee6..cd24ebf0da2f 100644
--- a/tools/perf/util/debug.c
+++ b/tools/perf/util/debug.c
@@ -111,50 +111,53 @@ int dump_printf(const char *fmt, ...)
 	return ret;
 }
 
-static void trace_event_printer(enum binary_printer_ops op,
-				unsigned int val, void *extra)
+static int trace_event_printer(enum binary_printer_ops op,
+			       unsigned int val, void *extra, FILE *fp)
 {
 	const char *color = PERF_COLOR_BLUE;
 	union perf_event *event = (union perf_event *)extra;
 	unsigned char ch = (unsigned char)val;
+	int printed = 0;
 
 	switch (op) {
 	case BINARY_PRINT_DATA_BEGIN:
-		printf(".");
-		color_fprintf(stdout, color, "\n. ... raw event: size %d bytes\n",
-				event->header.size);
+		printed += fprintf(fp, ".");
+		printed += color_fprintf(fp, color, "\n. ... raw event: size %d bytes\n",
+					 event->header.size);
 		break;
 	case BINARY_PRINT_LINE_BEGIN:
-		printf(".");
+		printed += fprintf(fp, ".");
 		break;
 	case BINARY_PRINT_ADDR:
-		color_fprintf(stdout, color, "  %04x: ", val);
+		printed += color_fprintf(fp, color, "  %04x: ", val);
 		break;
 	case BINARY_PRINT_NUM_DATA:
-		color_fprintf(stdout, color, " %02x", val);
+		printed += color_fprintf(fp, color, " %02x", val);
 		break;
 	case BINARY_PRINT_NUM_PAD:
-		color_fprintf(stdout, color, "   ");
+		printed += color_fprintf(fp, color, "   ");
 		break;
 	case BINARY_PRINT_SEP:
-		color_fprintf(stdout, color, "  ");
+		printed += color_fprintf(fp, color, "  ");
 		break;
 	case BINARY_PRINT_CHAR_DATA:
-		color_fprintf(stdout, color, "%c",
+		printed += color_fprintf(fp, color, "%c",
 			      isprint(ch) ? ch : '.');
 		break;
 	case BINARY_PRINT_CHAR_PAD:
-		color_fprintf(stdout, color, " ");
+		printed += color_fprintf(fp, color, " ");
 		break;
 	case BINARY_PRINT_LINE_END:
-		color_fprintf(stdout, color, "\n");
+		printed += color_fprintf(fp, color, "\n");
 		break;
 	case BINARY_PRINT_DATA_END:
-		printf("\n");
+		printed += fprintf(fp, "\n");
 		break;
 	default:
 		break;
 	}
+
+	return printed;
 }
 
 void trace_event(union perf_event *event)
diff --git a/tools/perf/util/print_binary.c b/tools/perf/util/print_binary.c
index e908177b9976..df55ad3b47a0 100644
--- a/tools/perf/util/print_binary.c
+++ b/tools/perf/util/print_binary.c
@@ -2,40 +2,42 @@
 #include <linux/log2.h>
 #include "sane_ctype.h"
 
-void print_binary(unsigned char *data, size_t len,
-		  size_t bytes_per_line, print_binary_t printer,
-		  void *extra)
+int binary__fprintf(unsigned char *data, size_t len,
+		    size_t bytes_per_line, binary__fprintf_t printer,
+		    void *extra, FILE *fp)
 {
 	size_t i, j, mask;
+	int printed = 0;
 
 	if (!printer)
-		return;
+		return 0;
 
 	bytes_per_line = roundup_pow_of_two(bytes_per_line);
 	mask = bytes_per_line - 1;
 
-	printer(BINARY_PRINT_DATA_BEGIN, 0, extra);
+	printed += printer(BINARY_PRINT_DATA_BEGIN, 0, extra, fp);
 	for (i = 0; i < len; i++) {
 		if ((i & mask) == 0) {
-			printer(BINARY_PRINT_LINE_BEGIN, -1, extra);
-			printer(BINARY_PRINT_ADDR, i, extra);
+			printed += printer(BINARY_PRINT_LINE_BEGIN, -1, extra, fp);
+			printed += printer(BINARY_PRINT_ADDR, i, extra, fp);
 		}
 
-		printer(BINARY_PRINT_NUM_DATA, data[i], extra);
+		printed += printer(BINARY_PRINT_NUM_DATA, data[i], extra, fp);
 
 		if (((i & mask) == mask) || i == len - 1) {
 			for (j = 0; j < mask-(i & mask); j++)
-				printer(BINARY_PRINT_NUM_PAD, -1, extra);
+				printed += printer(BINARY_PRINT_NUM_PAD, -1, extra, fp);
 
-			printer(BINARY_PRINT_SEP, i, extra);
+			printer(BINARY_PRINT_SEP, i, extra, fp);
 			for (j = i & ~mask; j <= i; j++)
-				printer(BINARY_PRINT_CHAR_DATA, data[j], extra);
+				printed += printer(BINARY_PRINT_CHAR_DATA, data[j], extra, fp);
 			for (j = 0; j < mask-(i & mask); j++)
-				printer(BINARY_PRINT_CHAR_PAD, i, extra);
-			printer(BINARY_PRINT_LINE_END, -1, extra);
+				printed += printer(BINARY_PRINT_CHAR_PAD, i, extra, fp);
+			printed += printer(BINARY_PRINT_LINE_END, -1, extra, fp);
 		}
 	}
-	printer(BINARY_PRINT_DATA_END, -1, extra);
+	printed += printer(BINARY_PRINT_DATA_END, -1, extra, fp);
+	return printed;
 }
 
 int is_printable_array(char *p, unsigned int len)
diff --git a/tools/perf/util/print_binary.h b/tools/perf/util/print_binary.h
index da0427263d2d..f97918a179db 100644
--- a/tools/perf/util/print_binary.h
+++ b/tools/perf/util/print_binary.h
@@ -2,6 +2,7 @@
 #define PERF_PRINT_BINARY_H
 
 #include <stddef.h>
+#include <stdio.h>
 
 enum binary_printer_ops {
 	BINARY_PRINT_DATA_BEGIN,
@@ -16,12 +17,19 @@ enum binary_printer_ops {
 	BINARY_PRINT_DATA_END,
 };
 
-typedef void (*print_binary_t)(enum binary_printer_ops op,
-			       unsigned int val, void *extra);
+typedef int (*binary__fprintf_t)(enum binary_printer_ops op,
+				 unsigned int val, void *extra, FILE *fp);
 
-void print_binary(unsigned char *data, size_t len,
-		  size_t bytes_per_line, print_binary_t printer,
-		  void *extra);
+int binary__fprintf(unsigned char *data, size_t len,
+		    size_t bytes_per_line, binary__fprintf_t printer,
+		    void *extra, FILE *fp);
+
+static inline void print_binary(unsigned char *data, size_t len,
+				size_t bytes_per_line, binary__fprintf_t printer,
+				void *extra)
+{
+	binary__fprintf(data, len, bytes_per_line, printer, extra, stdout);
+}
 
 int is_printable_array(char *p, unsigned int len);
 
