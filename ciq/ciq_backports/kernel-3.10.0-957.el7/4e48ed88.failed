netlink: reset network header before passing to taps

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Daniel Borkmann <dborkman@redhat.com>
commit 4e48ed883c72e78c5a910f8831ffe90c9b18f0ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4e48ed88.failed

netlink doesn't set any network header offset thus when the skb is
being passed to tap devices via dev_queue_xmit_nit(), it emits klog
false positives due to it being unset like:

  ...
  [  124.990397] protocol 0000 is buggy, dev nlmon0
  [  124.990411] protocol 0000 is buggy, dev nlmon0
  ...

So just reset the network header before passing to the device; for
packet sockets that just means nothing will change - mac and net
offset hold the same value just as before.

	Reported-by: Marcel Holtmann <marcel@holtmann.org>
	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4e48ed883c72e78c5a910f8831ffe90c9b18f0ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netlink/af_netlink.c
diff --cc net/netlink/af_netlink.c
index b5b7b952da74,2e152e5f2186..000000000000
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@@ -216,7 -211,9 +216,13 @@@ static int __netlink_deliver_tap_skb(st
  	if (nskb) {
  		nskb->dev = dev;
  		nskb->protocol = htons((u16) sk->sk_protocol);
++<<<<<<< HEAD
 +
++=======
+ 		nskb->pkt_type = netlink_is_kernel(sk) ?
+ 				 PACKET_KERNEL : PACKET_USER;
+ 		skb_reset_network_header(nskb);
++>>>>>>> 4e48ed883c72 (netlink: reset network header before passing to taps)
  		ret = dev_queue_xmit(nskb);
  		if (unlikely(ret > 0))
  			ret = net_xmit_errno(ret);
* Unmerged path net/netlink/af_netlink.c
