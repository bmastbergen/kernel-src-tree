dm crypt: reject sector_size feature if device length is not aligned to it

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Milan Broz <gmazyland@gmail.com>
commit 783874b050768d361239e444ba0fa396bb6d463f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/783874b0.failed

If a crypt mapping uses optional sector_size feature, additional
restrictions to mapped device segment size must be applied in
constructor, otherwise the device activation will fail later.

Fixes: 8f0009a225 ("dm crypt: optionally support larger encryption sector size")
	Cc: stable@vger.kernel.org # 4.12+
	Signed-off-by: Milan Broz <gmazyland@gmail.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 783874b050768d361239e444ba0fa396bb6d463f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-crypt.c
diff --cc drivers/md/dm-crypt.c
index 91e9c1daa9b3,96ab46512e1f..000000000000
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@@ -1696,14 -2523,82 +1696,90 @@@ static int crypt_ctr_cipher(struct dm_t
  		}
  	}
  
 +	ret = 0;
 +bad:
 +	kfree(cipher_api);
  	return ret;
 -}
  
++<<<<<<< HEAD
 +bad_mem:
 +	ti->error = "Cannot allocate cipher strings";
 +	return -ENOMEM;
++=======
+ static int crypt_ctr_optional(struct dm_target *ti, unsigned int argc, char **argv)
+ {
+ 	struct crypt_config *cc = ti->private;
+ 	struct dm_arg_set as;
+ 	static const struct dm_arg _args[] = {
+ 		{0, 6, "Invalid number of feature args"},
+ 	};
+ 	unsigned int opt_params, val;
+ 	const char *opt_string, *sval;
+ 	char dummy;
+ 	int ret;
+ 
+ 	/* Optional parameters */
+ 	as.argc = argc;
+ 	as.argv = argv;
+ 
+ 	ret = dm_read_arg_group(_args, &as, &opt_params, &ti->error);
+ 	if (ret)
+ 		return ret;
+ 
+ 	while (opt_params--) {
+ 		opt_string = dm_shift_arg(&as);
+ 		if (!opt_string) {
+ 			ti->error = "Not enough feature arguments";
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (!strcasecmp(opt_string, "allow_discards"))
+ 			ti->num_discard_bios = 1;
+ 
+ 		else if (!strcasecmp(opt_string, "same_cpu_crypt"))
+ 			set_bit(DM_CRYPT_SAME_CPU, &cc->flags);
+ 
+ 		else if (!strcasecmp(opt_string, "submit_from_crypt_cpus"))
+ 			set_bit(DM_CRYPT_NO_OFFLOAD, &cc->flags);
+ 		else if (sscanf(opt_string, "integrity:%u:", &val) == 1) {
+ 			if (val == 0 || val > MAX_TAG_SIZE) {
+ 				ti->error = "Invalid integrity arguments";
+ 				return -EINVAL;
+ 			}
+ 			cc->on_disk_tag_size = val;
+ 			sval = strchr(opt_string + strlen("integrity:"), ':') + 1;
+ 			if (!strcasecmp(sval, "aead")) {
+ 				set_bit(CRYPT_MODE_INTEGRITY_AEAD, &cc->cipher_flags);
+ 			} else  if (strcasecmp(sval, "none")) {
+ 				ti->error = "Unknown integrity profile";
+ 				return -EINVAL;
+ 			}
+ 
+ 			cc->cipher_auth = kstrdup(sval, GFP_KERNEL);
+ 			if (!cc->cipher_auth)
+ 				return -ENOMEM;
+ 		} else if (sscanf(opt_string, "sector_size:%hu%c", &cc->sector_size, &dummy) == 1) {
+ 			if (cc->sector_size < (1 << SECTOR_SHIFT) ||
+ 			    cc->sector_size > 4096 ||
+ 			    (cc->sector_size & (cc->sector_size - 1))) {
+ 				ti->error = "Invalid feature value for sector_size";
+ 				return -EINVAL;
+ 			}
+ 			if (ti->len & ((cc->sector_size >> SECTOR_SHIFT) - 1)) {
+ 				ti->error = "Device size is not multiple of sector_size feature";
+ 				return -EINVAL;
+ 			}
+ 			cc->sector_shift = __ffs(cc->sector_size) - SECTOR_SHIFT;
+ 		} else if (!strcasecmp(opt_string, "iv_large_sectors"))
+ 			set_bit(CRYPT_IV_LARGE_SECTORS, &cc->cipher_flags);
+ 		else {
+ 			ti->error = "Invalid feature arguments";
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	return 0;
++>>>>>>> 783874b05076 (dm crypt: reject sector_size feature if device length is not aligned to it)
  }
  
  /*
* Unmerged path drivers/md/dm-crypt.c
