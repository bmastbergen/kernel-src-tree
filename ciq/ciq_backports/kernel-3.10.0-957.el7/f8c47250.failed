xfs: convert drop_writes to use the errortag mechanism

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit f8c47250ba46eb221d1ac537266ac65bcf2866d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f8c47250.failed

We now have enhanced error injection that can control the frequency
with which errors happen, so convert drop_writes to use this.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Carlos Maiolino <cmaiolino@redhat.com>
(cherry picked from commit f8c47250ba46eb221d1ac537266ac65bcf2866d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_error.h
#	fs/xfs/xfs_mount.h
diff --cc fs/xfs/xfs_error.h
index 5f48fc573075,e0e4cf776fac..000000000000
--- a/fs/xfs/xfs_error.h
+++ b/fs/xfs/xfs_error.h
@@@ -91,7 -91,21 +91,25 @@@ extern void xfs_verifier_error(struct x
  #define XFS_ERRTAG_DIOWRITE_IOERR			20
  #define XFS_ERRTAG_BMAPIFORMAT				21
  #define XFS_ERRTAG_FREE_EXTENT				22
++<<<<<<< HEAD
 +#define XFS_ERRTAG_MAX					23
++=======
+ #define XFS_ERRTAG_RMAP_FINISH_ONE			23
+ #define XFS_ERRTAG_REFCOUNT_CONTINUE_UPDATE		24
+ #define XFS_ERRTAG_REFCOUNT_FINISH_ONE			25
+ #define XFS_ERRTAG_BMAP_FINISH_ONE			26
+ #define XFS_ERRTAG_AG_RESV_CRITICAL			27
+ /*
+  * DEBUG mode instrumentation to test and/or trigger delayed allocation
+  * block killing in the event of failed writes. When enabled, all
+  * buffered writes are silenty dropped and handled as if they failed.
+  * All delalloc blocks in the range of the write (including pre-existing
+  * delalloc blocks!) are tossed as part of the write failure error
+  * handling sequence.
+  */
+ #define XFS_ERRTAG_DROP_WRITES				28
+ #define XFS_ERRTAG_MAX					29
++>>>>>>> f8c47250ba46 (xfs: convert drop_writes to use the errortag mechanism)
  
  /*
   * Random factors for above tags, 1 means always, 2 means 1/2 time, etc.
@@@ -119,6 -133,12 +137,15 @@@
  #define XFS_RANDOM_DIOWRITE_IOERR			(XFS_RANDOM_DEFAULT/10)
  #define	XFS_RANDOM_BMAPIFORMAT				XFS_RANDOM_DEFAULT
  #define XFS_RANDOM_FREE_EXTENT				1
++<<<<<<< HEAD
++=======
+ #define XFS_RANDOM_RMAP_FINISH_ONE			1
+ #define XFS_RANDOM_REFCOUNT_CONTINUE_UPDATE		1
+ #define XFS_RANDOM_REFCOUNT_FINISH_ONE			1
+ #define XFS_RANDOM_BMAP_FINISH_ONE			1
+ #define XFS_RANDOM_AG_RESV_CRITICAL			4
+ #define XFS_RANDOM_DROP_WRITES				1
++>>>>>>> f8c47250ba46 (xfs: convert drop_writes to use the errortag mechanism)
  
  #ifdef DEBUG
  extern int xfs_errortag_init(struct xfs_mount *mp);
diff --cc fs/xfs/xfs_mount.h
index 3299252eab3a,e0792d036be2..000000000000
--- a/fs/xfs/xfs_mount.h
+++ b/fs/xfs/xfs_mount.h
@@@ -320,19 -323,21 +310,37 @@@ xfs_daddr_to_agbno(struct xfs_mount *mp
  	return (xfs_agblock_t) do_div(ld, mp->m_sb.sb_agblocks);
  }
  
++<<<<<<< HEAD
 +#ifdef DEBUG
 +static inline bool
 +xfs_mp_drop_writes(struct xfs_mount *mp)
 +{
 +	return mp->m_drop_writes;
 +}
 +#else
 +static inline bool
 +xfs_mp_drop_writes(struct xfs_mount *mp)
 +{
 +	return 0;
 +}
 +#endif
++=======
+ /* per-AG block reservation data structures*/
+ enum xfs_ag_resv_type {
+ 	XFS_AG_RESV_NONE = 0,
+ 	XFS_AG_RESV_METADATA,
+ 	XFS_AG_RESV_AGFL,
+ };
+ 
+ struct xfs_ag_resv {
+ 	/* number of blocks originally reserved here */
+ 	xfs_extlen_t			ar_orig_reserved;
+ 	/* number of blocks reserved here */
+ 	xfs_extlen_t			ar_reserved;
+ 	/* number of blocks originally asked for */
+ 	xfs_extlen_t			ar_asked;
+ };
++>>>>>>> f8c47250ba46 (xfs: convert drop_writes to use the errortag mechanism)
  
  /*
   * Per-ag incore structure, copies of information in agf and agi, to improve the
diff --git a/fs/xfs/xfs_error.c b/fs/xfs/xfs_error.c
index e2278af6aed1..a2f23d2bab16 100644
--- a/fs/xfs/xfs_error.c
+++ b/fs/xfs/xfs_error.c
@@ -55,6 +55,7 @@ static unsigned int xfs_errortag_random_default[] = {
 	XFS_RANDOM_REFCOUNT_FINISH_ONE,
 	XFS_RANDOM_BMAP_FINISH_ONE,
 	XFS_RANDOM_AG_RESV_CRITICAL,
+	XFS_RANDOM_DROP_WRITES,
 };
 
 struct xfs_errortag_attr {
@@ -157,6 +158,7 @@ XFS_ERRORTAG_ATTR_RW(refcount_continue_update,	XFS_ERRTAG_REFCOUNT_CONTINUE_UPDA
 XFS_ERRORTAG_ATTR_RW(refcount_finish_one,	XFS_ERRTAG_REFCOUNT_FINISH_ONE);
 XFS_ERRORTAG_ATTR_RW(bmap_finish_one,	XFS_ERRTAG_BMAP_FINISH_ONE);
 XFS_ERRORTAG_ATTR_RW(ag_resv_critical,	XFS_ERRTAG_AG_RESV_CRITICAL);
+XFS_ERRORTAG_ATTR_RW(drop_writes,	XFS_ERRTAG_DROP_WRITES);
 
 static struct attribute *xfs_errortag_attrs[] = {
 	XFS_ERRORTAG_ATTR_LIST(noerror),
@@ -187,6 +189,7 @@ static struct attribute *xfs_errortag_attrs[] = {
 	XFS_ERRORTAG_ATTR_LIST(refcount_finish_one),
 	XFS_ERRORTAG_ATTR_LIST(bmap_finish_one),
 	XFS_ERRORTAG_ATTR_LIST(ag_resv_critical),
+	XFS_ERRORTAG_ATTR_LIST(drop_writes),
 	NULL,
 };
 
* Unmerged path fs/xfs/xfs_error.h
diff --git a/fs/xfs/xfs_iomap.c b/fs/xfs/xfs_iomap.c
index dee0317e2022..b56b2af858ac 100644
--- a/fs/xfs/xfs_iomap.c
+++ b/fs/xfs/xfs_iomap.c
@@ -1060,7 +1060,7 @@ xfs_file_iomap_end_delalloc(
 	 * Behave as if the write failed if drop writes is enabled. Set the NEW
 	 * flag to force delalloc cleanup.
 	 */
-	if (xfs_mp_drop_writes(mp)) {
+	if (XFS_TEST_ERROR(false, mp, XFS_ERRTAG_DROP_WRITES)) {
 		iomap->flags |= IOMAP_F_NEW;
 		written = 0;
 	}
* Unmerged path fs/xfs/xfs_mount.h
diff --git a/fs/xfs/xfs_sysfs.c b/fs/xfs/xfs_sysfs.c
index ec6e0e2f95d6..56610a973593 100644
--- a/fs/xfs/xfs_sysfs.c
+++ b/fs/xfs/xfs_sysfs.c
@@ -90,49 +90,7 @@ to_mp(struct kobject *kobject)
 	return container_of(kobj, struct xfs_mount, m_kobj);
 }
 
-#ifdef DEBUG
-
-STATIC ssize_t
-drop_writes_store(
-	struct kobject		*kobject,
-	const char		*buf,
-	size_t			count)
-{
-	struct xfs_mount	*mp = to_mp(kobject);
-	int			ret;
-	int			val;
-
-	ret = kstrtoint(buf, 0, &val);
-	if (ret)
-		return ret;
-
-	if (val == 1)
-		mp->m_drop_writes = true;
-	else if (val == 0)
-		mp->m_drop_writes = false;
-	else
-		return -EINVAL;
-
-	return count;
-}
-
-STATIC ssize_t
-drop_writes_show(
-	struct kobject		*kobject,
-	char			*buf)
-{
-	struct xfs_mount	*mp = to_mp(kobject);
-
-	return snprintf(buf, PAGE_SIZE, "%d\n", mp->m_drop_writes ? 1 : 0);
-}
-XFS_SYSFS_ATTR_RW(drop_writes);
-
-#endif /* DEBUG */
-
 static struct attribute *xfs_mp_attrs[] = {
-#ifdef DEBUG
-	ATTR_LIST(drop_writes),
-#endif
 	NULL,
 };
 
