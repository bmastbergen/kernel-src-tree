KVM: VMX: fixes for vmentry_l1d_flush module parameter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 0027ff2a75f9dcf0537ac0a65c5840b0e21a4950
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0027ff2a.failed

Two bug fixes:

1) missing entries in the l1d_param array; this can cause a host crash
if an access attempts to reach the missing entry. Future-proof the get
function against any overflows as well.  However, the two entries
VMENTER_L1D_FLUSH_EPT_DISABLED and VMENTER_L1D_FLUSH_NOT_REQUIRED must
not be accepted by the parse function, so disable them there.

2) invalid values must be rejected even if the CPU does not have the
bug, so test for them before checking boot_cpu_has(X86_BUG_L1TF)

... and a small refactoring, since the .cmd field is redundant with
the index in the array.

	Reported-by: Bandan Das <bsd@redhat.com>
	Cc: stable@vger.kernel.org
Fixes: a7b9020b06ec6d7c3f3b0d4ef1a9eba12654f4f7
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 0027ff2a75f9dcf0537ac0a65c5840b0e21a4950)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index e2f48f8aba96,8dae47e7267a..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -175,10 -189,182 +175,180 @@@ module_param(ple_window_max, uint, 0444
  
  extern const ulong vmx_return;
  
++<<<<<<< HEAD
++=======
+ static DEFINE_STATIC_KEY_FALSE(vmx_l1d_should_flush);
+ static DEFINE_STATIC_KEY_FALSE(vmx_l1d_flush_cond);
+ static DEFINE_MUTEX(vmx_l1d_flush_mutex);
+ 
+ /* Storage for pre module init parameter parsing */
+ static enum vmx_l1d_flush_state __read_mostly vmentry_l1d_flush_param = VMENTER_L1D_FLUSH_AUTO;
+ 
+ static const struct {
+ 	const char *option;
+ 	bool for_parse;
+ } vmentry_l1d_param[] = {
+ 	[VMENTER_L1D_FLUSH_AUTO]	 = {"auto", true},
+ 	[VMENTER_L1D_FLUSH_NEVER]	 = {"never", true},
+ 	[VMENTER_L1D_FLUSH_COND]	 = {"cond", true},
+ 	[VMENTER_L1D_FLUSH_ALWAYS]	 = {"always", true},
+ 	[VMENTER_L1D_FLUSH_EPT_DISABLED] = {"EPT disabled", false},
+ 	[VMENTER_L1D_FLUSH_NOT_REQUIRED] = {"not required", false},
+ };
+ 
+ #define L1D_CACHE_ORDER 4
+ static void *vmx_l1d_flush_pages;
+ 
+ static int vmx_setup_l1d_flush(enum vmx_l1d_flush_state l1tf)
+ {
+ 	struct page *page;
+ 	unsigned int i;
+ 
+ 	if (!enable_ept) {
+ 		l1tf_vmx_mitigation = VMENTER_L1D_FLUSH_EPT_DISABLED;
+ 		return 0;
+ 	}
+ 
+ 	if (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES)) {
+ 		u64 msr;
+ 
+ 		rdmsrl(MSR_IA32_ARCH_CAPABILITIES, msr);
+ 		if (msr & ARCH_CAP_SKIP_VMENTRY_L1DFLUSH) {
+ 			l1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	/* If set to auto use the default l1tf mitigation method */
+ 	if (l1tf == VMENTER_L1D_FLUSH_AUTO) {
+ 		switch (l1tf_mitigation) {
+ 		case L1TF_MITIGATION_OFF:
+ 			l1tf = VMENTER_L1D_FLUSH_NEVER;
+ 			break;
+ 		case L1TF_MITIGATION_FLUSH_NOWARN:
+ 		case L1TF_MITIGATION_FLUSH:
+ 		case L1TF_MITIGATION_FLUSH_NOSMT:
+ 			l1tf = VMENTER_L1D_FLUSH_COND;
+ 			break;
+ 		case L1TF_MITIGATION_FULL:
+ 		case L1TF_MITIGATION_FULL_FORCE:
+ 			l1tf = VMENTER_L1D_FLUSH_ALWAYS;
+ 			break;
+ 		}
+ 	} else if (l1tf_mitigation == L1TF_MITIGATION_FULL_FORCE) {
+ 		l1tf = VMENTER_L1D_FLUSH_ALWAYS;
+ 	}
+ 
+ 	if (l1tf != VMENTER_L1D_FLUSH_NEVER && !vmx_l1d_flush_pages &&
+ 	    !boot_cpu_has(X86_FEATURE_FLUSH_L1D)) {
+ 		page = alloc_pages(GFP_KERNEL, L1D_CACHE_ORDER);
+ 		if (!page)
+ 			return -ENOMEM;
+ 		vmx_l1d_flush_pages = page_address(page);
+ 
+ 		/*
+ 		 * Initialize each page with a different pattern in
+ 		 * order to protect against KSM in the nested
+ 		 * virtualization case.
+ 		 */
+ 		for (i = 0; i < 1u << L1D_CACHE_ORDER; ++i) {
+ 			memset(vmx_l1d_flush_pages + i * PAGE_SIZE, i + 1,
+ 			       PAGE_SIZE);
+ 		}
+ 	}
+ 
+ 	l1tf_vmx_mitigation = l1tf;
+ 
+ 	if (l1tf != VMENTER_L1D_FLUSH_NEVER)
+ 		static_branch_enable(&vmx_l1d_should_flush);
+ 	else
+ 		static_branch_disable(&vmx_l1d_should_flush);
+ 
+ 	if (l1tf == VMENTER_L1D_FLUSH_COND)
+ 		static_branch_enable(&vmx_l1d_flush_cond);
+ 	else
+ 		static_branch_disable(&vmx_l1d_flush_cond);
+ 	return 0;
+ }
+ 
+ static int vmentry_l1d_flush_parse(const char *s)
+ {
+ 	unsigned int i;
+ 
+ 	if (s) {
+ 		for (i = 0; i < ARRAY_SIZE(vmentry_l1d_param); i++) {
+ 			if (vmentry_l1d_param[i].for_parse &&
+ 			    sysfs_streq(s, vmentry_l1d_param[i].option))
+ 				return i;
+ 		}
+ 	}
+ 	return -EINVAL;
+ }
+ 
+ static int vmentry_l1d_flush_set(const char *s, const struct kernel_param *kp)
+ {
+ 	int l1tf, ret;
+ 
+ 	l1tf = vmentry_l1d_flush_parse(s);
+ 	if (l1tf < 0)
+ 		return l1tf;
+ 
+ 	if (!boot_cpu_has(X86_BUG_L1TF))
+ 		return 0;
+ 
+ 	/*
+ 	 * Has vmx_init() run already? If not then this is the pre init
+ 	 * parameter parsing. In that case just store the value and let
+ 	 * vmx_init() do the proper setup after enable_ept has been
+ 	 * established.
+ 	 */
+ 	if (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_AUTO) {
+ 		vmentry_l1d_flush_param = l1tf;
+ 		return 0;
+ 	}
+ 
+ 	mutex_lock(&vmx_l1d_flush_mutex);
+ 	ret = vmx_setup_l1d_flush(l1tf);
+ 	mutex_unlock(&vmx_l1d_flush_mutex);
+ 	return ret;
+ }
+ 
+ static int vmentry_l1d_flush_get(char *s, const struct kernel_param *kp)
+ {
+ 	if (WARN_ON_ONCE(l1tf_vmx_mitigation >= ARRAY_SIZE(vmentry_l1d_param)))
+ 		return sprintf(s, "???\n");
+ 
+ 	return sprintf(s, "%s\n", vmentry_l1d_param[l1tf_vmx_mitigation].option);
+ }
+ 
+ static const struct kernel_param_ops vmentry_l1d_flush_ops = {
+ 	.set = vmentry_l1d_flush_set,
+ 	.get = vmentry_l1d_flush_get,
+ };
+ module_param_cb(vmentry_l1d_flush, &vmentry_l1d_flush_ops, NULL, 0644);
+ 
+ enum ept_pointers_status {
+ 	EPT_POINTERS_CHECK = 0,
+ 	EPT_POINTERS_MATCH = 1,
+ 	EPT_POINTERS_MISMATCH = 2
+ };
+ 
+ struct kvm_vmx {
+ 	struct kvm kvm;
+ 
+ 	unsigned int tss_addr;
+ 	bool ept_identity_pagetable_done;
+ 	gpa_t ept_identity_map_addr;
+ 
+ 	enum ept_pointers_status ept_pointers_match;
+ 	spinlock_t ept_pointer_lock;
+ };
+ 
++>>>>>>> 0027ff2a75f9 (KVM: VMX: fixes for vmentry_l1d_flush module parameter)
  #define NR_AUTOLOAD_MSRS 8
  
 -struct vmcs_hdr {
 -	u32 revision_id:31;
 -	u32 shadow_vmcs:1;
 -};
 -
  struct vmcs {
 -	struct vmcs_hdr hdr;
 +	u32 revision_id;
  	u32 abort;
  	char data[0];
  };
* Unmerged path arch/x86/kvm/vmx.c
