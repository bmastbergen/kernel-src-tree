raid5-cache: use bio chaining

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 6143e2cecb9ef9c7d3392c9c2583f231705413a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6143e2ce.failed

Simplify the bio completion handler by using bio chaining and submitting
bios as soon as they are full.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Shaohua Li <shli@fb.com>
	Signed-off-by: NeilBrown <neilb@suse.com>
(cherry picked from commit 6143e2cecb9ef9c7d3392c9c2583f231705413a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid5-cache.c
diff --cc drivers/md/raid5-cache.c
index 04e5f78a9fc3,d3b5441b4c11..000000000000
--- a/drivers/md/raid5-cache.c
+++ b/drivers/md/raid5-cache.c
@@@ -506,14 -212,8 +505,11 @@@ static void r5l_log_endio(struct bio *b
  	struct r5l_log *log = io->log;
  	unsigned long flags;
  
 +	if (error)
 +		md_error(log->rdev->mddev, log->rdev);
 +
  	bio_put(bio);
  
- 	if (!atomic_dec_and_test(&io->pending_io))
- 		return;
- 
  	spin_lock_irqsave(&log->io_list_lock, flags);
  	__r5l_set_io_unit_state(io, IO_UNIT_IO_END);
  	if (log->need_cache_flush)
@@@ -573,22 -247,17 +568,23 @@@ static void r5l_submit_current_io(struc
  	__r5l_set_io_unit_state(io, IO_UNIT_IO_START);
  	spin_unlock_irqrestore(&log->io_list_lock, flags);
  
- 	while ((bio = bio_list_pop(&io->bios)))
- 		submit_bio(WRITE, bio);
+ 	submit_bio(WRITE, io->current_bio);
  }
  
- static struct bio *r5l_bio_alloc(struct r5l_log *log, struct r5l_io_unit *io)
+ static struct bio *r5l_bio_alloc(struct r5l_log *log)
  {
 -	struct bio *bio = bio_kmalloc(GFP_NOIO | __GFP_NOFAIL, BIO_MAX_PAGES);
 +	struct bio *bio = bio_alloc_bioset(GFP_NOIO, BIO_MAX_PAGES, log->bs);
  
  	bio->bi_rw = WRITE;
  	bio->bi_bdev = log->rdev->bdev;
++<<<<<<< HEAD
 +	bio->bi_sector = log->rdev->data_offset + log->log_start;
 +	bio->bi_end_io = r5l_log_endio;
 +	bio->bi_private = io;
++=======
+ 	bio->bi_iter.bi_sector = log->rdev->data_offset + log->log_start;
++>>>>>>> 6143e2cecb9e (raid5-cache: use bio chaining)
  
- 	bio_list_add(&io->bios, bio);
- 	atomic_inc(&io->pending_io);
  	return bio;
  }
  
@@@ -615,13 -283,9 +611,12 @@@ static struct r5l_io_unit *r5l_new_meta
  	struct r5l_io_unit *io;
  	struct r5l_meta_block *block;
  
 -	/* We can't handle memory allocate failure so far */
 -	io = kmem_cache_zalloc(log->io_kc, GFP_NOIO | __GFP_NOFAIL);
 +	io = mempool_alloc(log->io_pool, GFP_ATOMIC);
 +	if (!io)
 +		return NULL;
 +	memset(io, 0, sizeof(*io));
 +
  	io->log = log;
- 	bio_list_init(&io->bios);
  	INIT_LIST_HEAD(&io->log_sibling);
  	INIT_LIST_HEAD(&io->stripe_list);
  	io->state = IO_UNIT_RUNNING;
* Unmerged path drivers/md/raid5-cache.c
