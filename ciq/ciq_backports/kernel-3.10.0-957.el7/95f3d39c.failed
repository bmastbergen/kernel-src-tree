x86/cpu/topology: Provide detect_extended_topology_early()

jira LE-1907
cve CVE-2018-3620
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] cpu/topology: provide detect_extended_topology_early() (Christoph von Recklinghausen) [1593384] {CVE-2018-3620}
Rebuild_FUZZ: 96.43%
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 95f3d39ccf7aaea79d1ffdac1c887c2e100ec1b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/95f3d39c.failed

To support force disabling of SMT it's required to know the number of
thread siblings early. detect_extended_topology() cannot be called before
the APIC driver is selected, so split out the part which initializes
smp_num_siblings.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Acked-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 95f3d39ccf7aaea79d1ffdac1c887c2e100ec1b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/cpu.h
#	arch/x86/kernel/cpu/topology.c
diff --cc arch/x86/kernel/cpu/cpu.h
index 4041c24ae7db,e59c0ea82a33..000000000000
--- a/arch/x86/kernel/cpu/cpu.h
+++ b/arch/x86/kernel/cpu/cpu.h
@@@ -43,4 -47,21 +43,24 @@@ extern const struct cpu_dev *const __x8
  
  extern void get_cpu_cap(struct cpuinfo_x86 *c);
  extern void cpu_detect_cache_sizes(struct cpuinfo_x86 *c);
++<<<<<<< HEAD
++=======
+ extern void init_scattered_cpuid_features(struct cpuinfo_x86 *c);
+ extern u32 get_scattered_cpuid_leaf(unsigned int level,
+ 				    unsigned int sub_leaf,
+ 				    enum cpuid_regs_idx reg);
+ extern void init_intel_cacheinfo(struct cpuinfo_x86 *c);
+ extern void init_amd_cacheinfo(struct cpuinfo_x86 *c);
+ 
+ extern void detect_num_cpu_cores(struct cpuinfo_x86 *c);
+ extern int detect_extended_topology_early(struct cpuinfo_x86 *c);
+ extern int detect_extended_topology(struct cpuinfo_x86 *c);
+ extern int detect_ht_early(struct cpuinfo_x86 *c);
+ extern void detect_ht(struct cpuinfo_x86 *c);
+ 
+ unsigned int aperfmperf_get_khz(int cpu);
+ 
+ extern void x86_spec_ctrl_setup_ap(void);
+ 
++>>>>>>> 95f3d39ccf7a (x86/cpu/topology: Provide detect_extended_topology_early())
  #endif /* ARCH_X86_CPU_H */
diff --cc arch/x86/kernel/cpu/topology.c
index e321c1f4d260,71ca064e3794..000000000000
--- a/arch/x86/kernel/cpu/topology.c
+++ b/arch/x86/kernel/cpu/topology.c
@@@ -21,18 -22,10 +21,17 @@@
  #define BITS_SHIFT_NEXT_LEVEL(eax)	((eax) & 0x1f)
  #define LEVEL_MAX_SIBLINGS(ebx)		((ebx) & 0xffff)
  
- /*
-  * Check for extended topology enumeration cpuid leaf 0xb and if it
-  * exists, use it for populating initial_apicid and cpu topology
-  * detection.
-  */
- int detect_extended_topology(struct cpuinfo_x86 *c)
+ int detect_extended_topology_early(struct cpuinfo_x86 *c)
  {
  #ifdef CONFIG_SMP
++<<<<<<< HEAD
 +	unsigned int eax, ebx, ecx, edx, sub_index;
 +	unsigned int ht_mask_width, core_plus_mask_width;
 +	unsigned int core_select_mask, core_level_siblings;
 +	static bool printed;
++=======
+ 	unsigned int eax, ebx, ecx, edx;
++>>>>>>> 95f3d39ccf7a (x86/cpu/topology: Provide detect_extended_topology_early())
  
  	if (c->cpuid_level < 0xb)
  		return -1;
* Unmerged path arch/x86/kernel/cpu/cpu.h
* Unmerged path arch/x86/kernel/cpu/topology.c
