lib/scatterlist: Avoid potential scatterlist entry overflow

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Tvrtko Ursulin <tvrtko.ursulin@intel.com>
commit c125906b839b794c580a5de911de65bd2c63aaee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c125906b.failed

Since the scatterlist length field is an unsigned int, make
sure that sg_alloc_table_from_pages does not overflow it while
coalescing pages to a single entry.

v2: Drop reference to future use. Use UINT_MAX.
v3: max_segment must be page aligned.
v4: Do not rely on compiler to optimise out the rounddown.
    (Joonas Lahtinen)
v5: Simplified loops and use post-increments rather than
    pre-increments. Use PAGE_MASK and fix comment typo.
    (Andy Shevchenko)
v6: Commit spelling fix.

	Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
	Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
	Cc: linux-kernel@vger.kernel.org
	Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
	Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
	Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20170803091312.22875-1-tvrtko.ursulin@linux.intel.com
(cherry picked from commit c125906b839b794c580a5de911de65bd2c63aaee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/scatterlist.h
diff --cc include/linux/scatterlist.h
index c057e0ebe7b9,6dd2ddbc6230..000000000000
--- a/include/linux/scatterlist.h
+++ b/include/linux/scatterlist.h
@@@ -2,13 -2,45 +2,50 @@@
  #define _LINUX_SCATTERLIST_H
  
  #include <linux/string.h>
 -#include <linux/types.h>
  #include <linux/bug.h>
  #include <linux/mm.h>
 +
 +#include <asm/types.h>
 +#include <asm/scatterlist.h>
  #include <asm/io.h>
  
++<<<<<<< HEAD
++=======
+ struct scatterlist {
+ #ifdef CONFIG_DEBUG_SG
+ 	unsigned long	sg_magic;
+ #endif
+ 	unsigned long	page_link;
+ 	unsigned int	offset;
+ 	unsigned int	length;
+ 	dma_addr_t	dma_address;
+ #ifdef CONFIG_NEED_SG_DMA_LENGTH
+ 	unsigned int	dma_length;
+ #endif
+ };
+ 
+ /*
+  * Since the above length field is an unsigned int, below we define the maximum
+  * length in bytes that can be stored in one scatterlist entry.
+  */
+ #define SCATTERLIST_MAX_SEGMENT (UINT_MAX & PAGE_MASK)
+ 
+ /*
+  * These macros should be used after a dma_map_sg call has been done
+  * to get bus addresses of each of the SG entries and their lengths.
+  * You should only work with the number of sg entries dma_map_sg
+  * returns, or alternatively stop on the first sg_dma_len(sg) which
+  * is 0.
+  */
+ #define sg_dma_address(sg)	((sg)->dma_address)
+ 
+ #ifdef CONFIG_NEED_SG_DMA_LENGTH
+ #define sg_dma_len(sg)		((sg)->dma_length)
+ #else
+ #define sg_dma_len(sg)		((sg)->length)
+ #endif
+ 
++>>>>>>> c125906b839b (lib/scatterlist: Avoid potential scatterlist entry overflow)
  struct sg_table {
  	struct scatterlist *sgl;	/* the list */
  	unsigned int nents;		/* number of mapped entries */
* Unmerged path include/linux/scatterlist.h
diff --git a/lib/scatterlist.c b/lib/scatterlist.c
index c736fa14d666..0b1b706d06c9 100644
--- a/lib/scatterlist.c
+++ b/lib/scatterlist.c
@@ -396,17 +396,22 @@ int sg_alloc_table_from_pages(struct sg_table *sgt,
 	unsigned long offset, unsigned long size,
 	gfp_t gfp_mask)
 {
-	unsigned int chunks;
-	unsigned int i;
-	unsigned int cur_page;
+	const unsigned int max_segment = SCATTERLIST_MAX_SEGMENT;
+	unsigned int chunks, cur_page, seg_len, i;
 	int ret;
 	struct scatterlist *s;
 
 	/* compute number of contiguous chunks */
 	chunks = 1;
-	for (i = 1; i < n_pages; ++i)
-		if (page_to_pfn(pages[i]) != page_to_pfn(pages[i - 1]) + 1)
-			++chunks;
+	seg_len = 0;
+	for (i = 1; i < n_pages; i++) {
+		seg_len += PAGE_SIZE;
+		if (seg_len >= max_segment ||
+		    page_to_pfn(pages[i]) != page_to_pfn(pages[i - 1]) + 1) {
+			chunks++;
+			seg_len = 0;
+		}
+	}
 
 	ret = sg_alloc_table(sgt, chunks, gfp_mask);
 	if (unlikely(ret))
@@ -415,17 +420,21 @@ int sg_alloc_table_from_pages(struct sg_table *sgt,
 	/* merging chunks and putting them into the scatterlist */
 	cur_page = 0;
 	for_each_sg(sgt->sgl, s, sgt->orig_nents, i) {
-		unsigned long chunk_size;
-		unsigned int j;
+		unsigned int j, chunk_size;
 
 		/* look for the end of the current chunk */
-		for (j = cur_page + 1; j < n_pages; ++j)
-			if (page_to_pfn(pages[j]) !=
+		seg_len = 0;
+		for (j = cur_page + 1; j < n_pages; j++) {
+			seg_len += PAGE_SIZE;
+			if (seg_len >= max_segment ||
+			    page_to_pfn(pages[j]) !=
 			    page_to_pfn(pages[j - 1]) + 1)
 				break;
+		}
 
 		chunk_size = ((j - cur_page) << PAGE_SHIFT) - offset;
-		sg_set_page(s, pages[cur_page], min(size, chunk_size), offset);
+		sg_set_page(s, pages[cur_page],
+			    min_t(unsigned long, size, chunk_size), offset);
 		size -= chunk_size;
 		offset = 0;
 		cur_page = j;
