md/r5cache: gracefully handle journal device errors for writeback mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [md] r5cache: gracefully handle journal device errors for writeback mode (Nigel Croxon) [1494474]
Rebuild_FUZZ: 97.81%
commit-author Song Liu <songliubraving@fb.com>
commit 70d466f760b351fe30b5f8c956354ddf29aa676b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/70d466f7.failed

For the raid456 with writeback cache, when journal device failed during
normal operation, it is still possible to persist all data, as all
pending data is still in stripe cache. However, it is necessary to handle
journal failure gracefully.

During journal failures, the following logic handles the graceful shutdown
of journal:
1. raid5_error() marks the device as Faulty and schedules async work
   log->disable_writeback_work;
2. In disable_writeback_work (r5c_disable_writeback_async), the mddev is
   suspended, set to write through, and then resumed. mddev_suspend()
   flushes all cached stripes;
3. All cached stripes need to be flushed carefully to the RAID array.

This patch fixes issues within the process above:
1. In r5c_update_on_rdev_error() schedule disable_writeback_work for
   journal failures;
2. In r5c_disable_writeback_async(), wait for MD_SB_CHANGE_PENDING,
   since raid5_error() updates superblock.
3. In handle_stripe(), allow stripes with data in journal (s.injournal > 0)
   to make progress during log_failed;
4. In delay_towrite(), if log failed only process data in the cache (skip
   new writes in dev->towrite);
5. In __get_priority_stripe(), process loprio_list during journal device
   failures.
6. In raid5_remove_disk(), wait for all cached stripes are flushed before
   calling log_exit().

	Signed-off-by: Song Liu <songliubraving@fb.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit 70d466f760b351fe30b5f8c956354ddf29aa676b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid5-cache.c
#	drivers/md/raid5-log.h
diff --cc drivers/md/raid5-cache.c
index a6628b7c2270,cc3f8442f11f..000000000000
--- a/drivers/md/raid5-cache.c
+++ b/drivers/md/raid5-cache.c
@@@ -556,15 -684,11 +557,23 @@@ static void r5c_disable_writeback_async
  
  	/* wait superblock change before suspend */
  	wait_event(mddev->sb_wait,
++<<<<<<< HEAD
 +		   conf->log == NULL ||
 +		   (!test_bit(MD_SB_CHANGE_PENDING, &mddev->sb_flags) &&
 +		    (locked = mddev_trylock(mddev))));
 +	if (locked) {
 +		mddev_suspend(mddev);
 +		log->r5c_journal_mode = R5C_JOURNAL_MODE_WRITE_THROUGH;
 +		mddev_resume(mddev);
 +		mddev_unlock(mddev);
 +	}
++=======
+ 		   !test_bit(MD_SB_CHANGE_PENDING, &mddev->sb_flags));
+ 
+ 	mddev_suspend(mddev);
+ 	log->r5c_journal_mode = R5C_JOURNAL_MODE_WRITE_THROUGH;
+ 	mddev_resume(mddev);
++>>>>>>> 70d466f760b3 (md/r5cache: gracefully handle journal device errors for writeback mode)
  }
  
  static void r5l_submit_current_io(struct r5l_log *log)
diff --cc drivers/md/raid5-log.h
index dccbe0ceaf4b,328d67aedda4..000000000000
--- a/drivers/md/raid5-log.h
+++ b/drivers/md/raid5-log.h
@@@ -10,6 -10,27 +10,30 @@@ extern void r5l_stripe_write_finished(s
  extern int r5l_handle_flush_request(struct r5l_log *log, struct bio *bio);
  extern void r5l_quiesce(struct r5l_log *log, int state);
  extern bool r5l_log_disk_error(struct r5conf *conf);
++<<<<<<< HEAD
++=======
+ extern bool r5c_is_writeback(struct r5l_log *log);
+ extern int
+ r5c_try_caching_write(struct r5conf *conf, struct stripe_head *sh,
+ 		      struct stripe_head_state *s, int disks);
+ extern void
+ r5c_finish_stripe_write_out(struct r5conf *conf, struct stripe_head *sh,
+ 			    struct stripe_head_state *s);
+ extern void r5c_release_extra_page(struct stripe_head *sh);
+ extern void r5c_use_extra_page(struct stripe_head *sh);
+ extern void r5l_wake_reclaim(struct r5l_log *log, sector_t space);
+ extern void r5c_handle_cached_data_endio(struct r5conf *conf,
+ 	struct stripe_head *sh, int disks);
+ extern int r5c_cache_data(struct r5l_log *log, struct stripe_head *sh);
+ extern void r5c_make_stripe_write_out(struct stripe_head *sh);
+ extern void r5c_flush_cache(struct r5conf *conf, int num);
+ extern void r5c_check_stripe_cache_usage(struct r5conf *conf);
+ extern void r5c_check_cached_full_stripe(struct r5conf *conf);
+ extern struct md_sysfs_entry r5c_journal_mode;
+ extern void r5c_update_on_rdev_error(struct mddev *mddev,
+ 				     struct md_rdev *rdev);
+ extern bool r5c_big_stripe_cached(struct r5conf *conf, sector_t sect);
++>>>>>>> 70d466f760b3 (md/r5cache: gracefully handle journal device errors for writeback mode)
  
  extern struct dma_async_tx_descriptor *
  ops_run_partial_parity(struct stripe_head *sh, struct raid5_percpu *percpu,
* Unmerged path drivers/md/raid5-cache.c
* Unmerged path drivers/md/raid5-log.h
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index 1b3c1d5171eb..90d80c169378 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -2608,7 +2608,7 @@ static void raid5_error(struct mddev *mddev, struct md_rdev *rdev)
 		bdevname(rdev->bdev, b),
 		mdname(mddev),
 		conf->raid_disks - mddev->degraded);
-	r5c_update_on_rdev_error(mddev);
+	r5c_update_on_rdev_error(mddev, rdev);
 }
 
 /*
@@ -2969,6 +2969,11 @@ sector_t raid5_compute_blocknr(struct stripe_head *sh, int i, int previous)
  *      When LOG_CRITICAL, stripes with injournal == 0 will be sent to
  *      no_space_stripes list.
  *
+ *   3. during journal failure
+ *      In journal failure, we try to flush all cached data to raid disks
+ *      based on data in stripe cache. The array is read-only to upper
+ *      layers, so we would skip all pending writes.
+ *
  */
 static inline bool delay_towrite(struct r5conf *conf,
 				 struct r5dev *dev,
@@ -2982,6 +2987,9 @@ static inline bool delay_towrite(struct r5conf *conf,
 	if (test_bit(R5C_LOG_CRITICAL, &conf->cache_state) &&
 	    s->injournal > 0)
 		return true;
+	/* case 3 above */
+	if (s->log_failed && s->injournal)
+		return true;
 	return false;
 }
 
@@ -4626,10 +4634,15 @@ static void handle_stripe(struct stripe_head *sh)
 	       " to_write=%d failed=%d failed_num=%d,%d\n",
 	       s.locked, s.uptodate, s.to_read, s.to_write, s.failed,
 	       s.failed_num[0], s.failed_num[1]);
-	/* check if the array has lost more than max_degraded devices and,
+	/*
+	 * check if the array has lost more than max_degraded devices and,
 	 * if so, some requests might need to be failed.
+	 *
+	 * When journal device failed (log_failed), we will only process
+	 * the stripe if there is data need write to raid disks
 	 */
-	if (s.failed > conf->max_degraded || s.log_failed) {
+	if (s.failed > conf->max_degraded ||
+	    (s.log_failed && s.injournal == 0)) {
 		sh->check_state = 0;
 		sh->reconstruct_state = 0;
 		break_stripe_batch_list(sh, 0);
@@ -5230,8 +5243,10 @@ static struct stripe_head *__get_priority_stripe(struct r5conf *conf, int group)
 	struct stripe_head *sh, *tmp;
 	struct list_head *handle_list = NULL;
 	struct r5worker_group *wg;
-	bool second_try = !r5c_is_writeback(conf->log);
-	bool try_loprio = test_bit(R5C_LOG_TIGHT, &conf->cache_state);
+	bool second_try = !r5c_is_writeback(conf->log) &&
+		!r5l_log_disk_error(conf);
+	bool try_loprio = test_bit(R5C_LOG_TIGHT, &conf->cache_state) ||
+		r5l_log_disk_error(conf);
 
 again:
 	wg = NULL;
@@ -7495,7 +7510,9 @@ static int raid5_remove_disk(struct mddev *mddev, struct md_rdev *rdev)
 		 * neilb: there is no locking about new writes here,
 		 * so this cannot be safe.
 		 */
-		if (atomic_read(&conf->active_stripes)) {
+		if (atomic_read(&conf->active_stripes) ||
+		    atomic_read(&conf->r5c_cached_full_stripes) ||
+		    atomic_read(&conf->r5c_cached_partial_stripes)) {
 			return -EBUSY;
 		}
 		log_exit(conf);
