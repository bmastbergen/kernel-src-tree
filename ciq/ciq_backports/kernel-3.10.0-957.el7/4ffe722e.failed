thunderbolt: Add polling mode for rings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 4ffe722eefcb07c76701f03e0d759fbaecedf79f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4ffe722e.failed

In order to support things like networking over Thunderbolt cable, there
needs to be a way to switch the ring to a mode where it can be polled
with the interrupt masked. We implement such mode so that the caller can
allocate a ring by passing pointer to a function that is then called
when an interrupt is triggered. Completed frames can be fetched using
tb_ring_poll() and the interrupt can be re-enabled when the caller is
finished with polling by using tb_ring_poll_complete().

	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Reviewed-by: Michael Jamet <michael.jamet@intel.com>
	Reviewed-by: Yehezkel Bernat <yehezkel.bernat@intel.com>
	Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4ffe722eefcb07c76701f03e0d759fbaecedf79f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/thunderbolt/ctl.c
#	drivers/thunderbolt/nhi.c
#	include/linux/thunderbolt.h
diff --cc drivers/thunderbolt/ctl.c
index 7342f062c36f,d079dbba2c03..000000000000
--- a/drivers/thunderbolt/ctl.c
+++ b/drivers/thunderbolt/ctl.c
@@@ -617,7 -618,8 +617,12 @@@ struct tb_ctl *tb_ctl_alloc(struct tb_n
  	if (!ctl->tx)
  		goto err;
  
++<<<<<<< HEAD
 +	ctl->rx = ring_alloc_rx(nhi, 0, 10, RING_FLAG_NO_SUSPEND);
++=======
+ 	ctl->rx = tb_ring_alloc_rx(nhi, 0, 10, RING_FLAG_NO_SUSPEND, 0xffff,
+ 				0xffff, NULL, NULL);
++>>>>>>> 4ffe722eefcb (thunderbolt: Add polling mode for rings)
  	if (!ctl->rx)
  		goto err;
  
diff --cc drivers/thunderbolt/nhi.c
index 8a7a3d0133f9,af0a80ddf594..000000000000
--- a/drivers/thunderbolt/nhi.c
+++ b/drivers/thunderbolt/nhi.c
@@@ -274,10 -269,101 +275,100 @@@ int __ring_enqueue(struct tb_ring *ring
  	} else {
  		ret = -ESHUTDOWN;
  	}
 -	spin_unlock_irqrestore(&ring->lock, flags);
 +	mutex_unlock(&ring->lock);
  	return ret;
  }
 -EXPORT_SYMBOL_GPL(__tb_ring_enqueue);
  
+ /**
+  * tb_ring_poll() - Poll one completed frame from the ring
+  * @ring: Ring to poll
+  *
+  * This function can be called when @start_poll callback of the @ring
+  * has been called. It will read one completed frame from the ring and
+  * return it to the caller. Returns %NULL if there is no more completed
+  * frames.
+  */
+ struct ring_frame *tb_ring_poll(struct tb_ring *ring)
+ {
+ 	struct ring_frame *frame = NULL;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&ring->lock, flags);
+ 	if (!ring->running)
+ 		goto unlock;
+ 	if (ring_empty(ring))
+ 		goto unlock;
+ 
+ 	if (ring->descriptors[ring->tail].flags & RING_DESC_COMPLETED) {
+ 		frame = list_first_entry(&ring->in_flight, typeof(*frame),
+ 					 list);
+ 		list_del_init(&frame->list);
+ 
+ 		if (!ring->is_tx) {
+ 			frame->size = ring->descriptors[ring->tail].length;
+ 			frame->eof = ring->descriptors[ring->tail].eof;
+ 			frame->sof = ring->descriptors[ring->tail].sof;
+ 			frame->flags = ring->descriptors[ring->tail].flags;
+ 		}
+ 
+ 		ring->tail = (ring->tail + 1) % ring->size;
+ 	}
+ 
+ unlock:
+ 	spin_unlock_irqrestore(&ring->lock, flags);
+ 	return frame;
+ }
+ EXPORT_SYMBOL_GPL(tb_ring_poll);
+ 
+ static void __ring_interrupt_mask(struct tb_ring *ring, bool mask)
+ {
+ 	int idx = ring_interrupt_index(ring);
+ 	int reg = REG_RING_INTERRUPT_BASE + idx / 32 * 4;
+ 	int bit = idx % 32;
+ 	u32 val;
+ 
+ 	val = ioread32(ring->nhi->iobase + reg);
+ 	if (mask)
+ 		val &= ~BIT(bit);
+ 	else
+ 		val |= BIT(bit);
+ 	iowrite32(val, ring->nhi->iobase + reg);
+ }
+ 
+ /* Both @nhi->lock and @ring->lock should be held */
+ static void __ring_interrupt(struct tb_ring *ring)
+ {
+ 	if (!ring->running)
+ 		return;
+ 
+ 	if (ring->start_poll) {
+ 		__ring_interrupt_mask(ring, false);
+ 		ring->start_poll(ring->poll_data);
+ 	} else {
+ 		schedule_work(&ring->work);
+ 	}
+ }
+ 
+ /**
+  * tb_ring_poll_complete() - Re-start interrupt for the ring
+  * @ring: Ring to re-start the interrupt
+  *
+  * This will re-start (unmask) the ring interrupt once the user is done
+  * with polling.
+  */
+ void tb_ring_poll_complete(struct tb_ring *ring)
+ {
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&ring->nhi->lock, flags);
+ 	spin_lock(&ring->lock);
+ 	if (ring->start_poll)
+ 		__ring_interrupt_mask(ring, false);
+ 	spin_unlock(&ring->lock);
+ 	spin_unlock_irqrestore(&ring->nhi->lock, flags);
+ }
+ EXPORT_SYMBOL_GPL(tb_ring_poll_complete);
+ 
  static irqreturn_t ring_msix(int irq, void *data)
  {
  	struct tb_ring *ring = data;
@@@ -320,8 -411,11 +416,16 @@@ static void ring_release_msix(struct tb
  	ring->irq = 0;
  }
  
++<<<<<<< HEAD
 +static struct tb_ring *ring_alloc(struct tb_nhi *nhi, u32 hop, int size,
 +				  bool transmit, unsigned int flags)
++=======
+ static struct tb_ring *tb_ring_alloc(struct tb_nhi *nhi, u32 hop, int size,
+ 				     bool transmit, unsigned int flags,
+ 				     u16 sof_mask, u16 eof_mask,
+ 				     void (*start_poll)(void *),
+ 				     void *poll_data)
++>>>>>>> 4ffe722eefcb (thunderbolt: Add polling mode for rings)
  {
  	struct tb_ring *ring = NULL;
  	dev_info(&nhi->pdev->dev, "allocating %s ring %d of size %d\n",
@@@ -356,10 -442,11 +460,12 @@@
  	ring->head = 0;
  	ring->tail = 0;
  	ring->running = false;
+ 	ring->start_poll = start_poll;
+ 	ring->poll_data = poll_data;
  
 +	if (ring_request_msix(ring, flags & RING_FLAG_NO_SUSPEND))
 +		goto err;
 +
  	ring->descriptors = dma_alloc_coherent(&ring->nhi->pdev->dev,
  			size * sizeof(*ring->descriptors),
  			&ring->descriptors_dma, GFP_KERNEL | __GFP_ZERO);
@@@ -381,27 -489,54 +487,57 @@@ err
  	return NULL;
  }
  
 -/**
 - * tb_ring_alloc_tx() - Allocate DMA ring for transmit
 - * @nhi: Pointer to the NHI the ring is to be allocated
 - * @hop: HopID (ring) to allocate
 - * @size: Number of entries in the ring
 - * @flags: Flags for the ring
 - */
 -struct tb_ring *tb_ring_alloc_tx(struct tb_nhi *nhi, int hop, int size,
 -				 unsigned int flags)
 +struct tb_ring *ring_alloc_tx(struct tb_nhi *nhi, int hop, int size,
 +			      unsigned int flags)
 +{
++<<<<<<< HEAD
 +	return ring_alloc(nhi, hop, size, true, flags);
 +}
 +
 +struct tb_ring *ring_alloc_rx(struct tb_nhi *nhi, int hop, int size,
 +			      unsigned int flags)
  {
 +	return ring_alloc(nhi, hop, size, false, flags);
++=======
+ 	return tb_ring_alloc(nhi, hop, size, true, flags, 0, 0, NULL, NULL);
++>>>>>>> 4ffe722eefcb (thunderbolt: Add polling mode for rings)
  }
 -EXPORT_SYMBOL_GPL(tb_ring_alloc_tx);
  
  /**
++<<<<<<< HEAD
 + * ring_start() - enable a ring
++=======
+  * tb_ring_alloc_rx() - Allocate DMA ring for receive
+  * @nhi: Pointer to the NHI the ring is to be allocated
+  * @hop: HopID (ring) to allocate
+  * @size: Number of entries in the ring
+  * @flags: Flags for the ring
+  * @sof_mask: Mask of PDF values that start a frame
+  * @eof_mask: Mask of PDF values that end a frame
+  * @start_poll: If not %NULL the ring will call this function when an
+  *		interrupt is triggered and masked, instead of callback
+  *		in each Rx frame.
+  * @poll_data: Optional data passed to @start_poll
+  */
+ struct tb_ring *tb_ring_alloc_rx(struct tb_nhi *nhi, int hop, int size,
+ 				 unsigned int flags, u16 sof_mask, u16 eof_mask,
+ 				 void (*start_poll)(void *), void *poll_data)
+ {
+ 	return tb_ring_alloc(nhi, hop, size, false, flags, sof_mask, eof_mask,
+ 			     start_poll, poll_data);
+ }
+ EXPORT_SYMBOL_GPL(tb_ring_alloc_rx);
+ 
+ /**
+  * tb_ring_start() - enable a ring
++>>>>>>> 4ffe722eefcb (thunderbolt: Add polling mode for rings)
   *
 - * Must not be invoked in parallel with tb_ring_stop().
 + * Must not be invoked in parallel with ring_stop().
   */
 -void tb_ring_start(struct tb_ring *ring)
 +void ring_start(struct tb_ring *ring)
  {
 -	u16 frame_size;
 -	u32 flags;
 -
 -	spin_lock_irq(&ring->nhi->lock);
 -	spin_lock(&ring->lock);
 +	mutex_lock(&ring->nhi->lock);
 +	mutex_lock(&ring->lock);
  	if (ring->nhi->going_away)
  		goto err;
  	if (ring->running) {
@@@ -520,7 -679,6 +657,10 @@@ void ring_free(struct tb_ring *ring
  		 RING_TYPE(ring),
  		 ring->hop);
  
++<<<<<<< HEAD
 +	mutex_unlock(&ring->nhi->lock);
++=======
++>>>>>>> 4ffe722eefcb (thunderbolt: Add polling mode for rings)
  	/**
  	 * ring->work can no longer be scheduled (it is scheduled only
  	 * by nhi_interrupt_work, ring_stop and ring_msix). Wait for it
@@@ -630,10 -788,12 +770,12 @@@ static void nhi_interrupt_work(struct w
  				 hop);
  			continue;
  		}
- 		/* we do not check ring->running, this is done in ring->work */
- 		schedule_work(&ring->work);
+ 
+ 		spin_lock(&ring->lock);
+ 		__ring_interrupt(ring);
+ 		spin_unlock(&ring->lock);
  	}
 -	spin_unlock_irq(&nhi->lock);
 +	mutex_unlock(&nhi->lock);
  }
  
  static irqreturn_t nhi_msi(int irq, void *data)
diff --cc include/linux/thunderbolt.h
index 43b8d1e09341,36925e3aec7c..000000000000
--- a/include/linux/thunderbolt.h
+++ b/include/linux/thunderbolt.h
@@@ -155,4 -160,426 +155,429 @@@ struct tb_property *tb_property_get_nex
  	     property;						\
  	     property = tb_property_get_next(dir, property))
  
++<<<<<<< HEAD
++=======
+ int tb_register_property_dir(const char *key, struct tb_property_dir *dir);
+ void tb_unregister_property_dir(const char *key, struct tb_property_dir *dir);
+ 
+ /**
+  * struct tb_xdomain - Cross-domain (XDomain) connection
+  * @dev: XDomain device
+  * @tb: Pointer to the domain
+  * @remote_uuid: UUID of the remote domain (host)
+  * @local_uuid: Cached local UUID
+  * @route: Route string the other domain can be reached
+  * @vendor: Vendor ID of the remote domain
+  * @device: Device ID of the demote domain
+  * @lock: Lock to serialize access to the following fields of this structure
+  * @vendor_name: Name of the vendor (or %NULL if not known)
+  * @device_name: Name of the device (or %NULL if not known)
+  * @is_unplugged: The XDomain is unplugged
+  * @resume: The XDomain is being resumed
+  * @transmit_path: HopID which the remote end expects us to transmit
+  * @transmit_ring: Local ring (hop) where outgoing packets are pushed
+  * @receive_path: HopID which we expect the remote end to transmit
+  * @receive_ring: Local ring (hop) where incoming packets arrive
+  * @service_ids: Used to generate IDs for the services
+  * @properties: Properties exported by the remote domain
+  * @property_block_gen: Generation of @properties
+  * @properties_lock: Lock protecting @properties.
+  * @get_properties_work: Work used to get remote domain properties
+  * @properties_retries: Number of times left to read properties
+  * @properties_changed_work: Work used to notify the remote domain that
+  *			     our properties have changed
+  * @properties_changed_retries: Number of times left to send properties
+  *				changed notification
+  * @link: Root switch link the remote domain is connected (ICM only)
+  * @depth: Depth in the chain the remote domain is connected (ICM only)
+  *
+  * This structure represents connection across two domains (hosts).
+  * Each XDomain contains zero or more services which are exposed as
+  * &struct tb_service objects.
+  *
+  * Service drivers may access this structure if they need to enumerate
+  * non-standard properties but they need hold @lock when doing so
+  * because properties can be changed asynchronously in response to
+  * changes in the remote domain.
+  */
+ struct tb_xdomain {
+ 	struct device dev;
+ 	struct tb *tb;
+ 	uuid_t *remote_uuid;
+ 	const uuid_t *local_uuid;
+ 	u64 route;
+ 	u16 vendor;
+ 	u16 device;
+ 	struct mutex lock;
+ 	const char *vendor_name;
+ 	const char *device_name;
+ 	bool is_unplugged;
+ 	bool resume;
+ 	u16 transmit_path;
+ 	u16 transmit_ring;
+ 	u16 receive_path;
+ 	u16 receive_ring;
+ 	struct ida service_ids;
+ 	struct tb_property_dir *properties;
+ 	u32 property_block_gen;
+ 	struct delayed_work get_properties_work;
+ 	int properties_retries;
+ 	struct delayed_work properties_changed_work;
+ 	int properties_changed_retries;
+ 	u8 link;
+ 	u8 depth;
+ };
+ 
+ int tb_xdomain_enable_paths(struct tb_xdomain *xd, u16 transmit_path,
+ 			    u16 transmit_ring, u16 receive_path,
+ 			    u16 receive_ring);
+ int tb_xdomain_disable_paths(struct tb_xdomain *xd);
+ struct tb_xdomain *tb_xdomain_find_by_uuid(struct tb *tb, const uuid_t *uuid);
+ 
+ static inline struct tb_xdomain *
+ tb_xdomain_find_by_uuid_locked(struct tb *tb, const uuid_t *uuid)
+ {
+ 	struct tb_xdomain *xd;
+ 
+ 	mutex_lock(&tb->lock);
+ 	xd = tb_xdomain_find_by_uuid(tb, uuid);
+ 	mutex_unlock(&tb->lock);
+ 
+ 	return xd;
+ }
+ 
+ static inline struct tb_xdomain *tb_xdomain_get(struct tb_xdomain *xd)
+ {
+ 	if (xd)
+ 		get_device(&xd->dev);
+ 	return xd;
+ }
+ 
+ static inline void tb_xdomain_put(struct tb_xdomain *xd)
+ {
+ 	if (xd)
+ 		put_device(&xd->dev);
+ }
+ 
+ static inline bool tb_is_xdomain(const struct device *dev)
+ {
+ 	return dev->type == &tb_xdomain_type;
+ }
+ 
+ static inline struct tb_xdomain *tb_to_xdomain(struct device *dev)
+ {
+ 	if (tb_is_xdomain(dev))
+ 		return container_of(dev, struct tb_xdomain, dev);
+ 	return NULL;
+ }
+ 
+ int tb_xdomain_response(struct tb_xdomain *xd, const void *response,
+ 			size_t size, enum tb_cfg_pkg_type type);
+ int tb_xdomain_request(struct tb_xdomain *xd, const void *request,
+ 		       size_t request_size, enum tb_cfg_pkg_type request_type,
+ 		       void *response, size_t response_size,
+ 		       enum tb_cfg_pkg_type response_type,
+ 		       unsigned int timeout_msec);
+ 
+ /**
+  * tb_protocol_handler - Protocol specific handler
+  * @uuid: XDomain messages with this UUID are dispatched to this handler
+  * @callback: Callback called with the XDomain message. Returning %1
+  *	      here tells the XDomain core that the message was handled
+  *	      by this handler and should not be forwared to other
+  *	      handlers.
+  * @data: Data passed with the callback
+  * @list: Handlers are linked using this
+  *
+  * Thunderbolt services can hook into incoming XDomain requests by
+  * registering protocol handler. Only limitation is that the XDomain
+  * discovery protocol UUID cannot be registered since it is handled by
+  * the core XDomain code.
+  *
+  * The @callback must check that the message is really directed to the
+  * service the driver implements.
+  */
+ struct tb_protocol_handler {
+ 	const uuid_t *uuid;
+ 	int (*callback)(const void *buf, size_t size, void *data);
+ 	void *data;
+ 	struct list_head list;
+ };
+ 
+ int tb_register_protocol_handler(struct tb_protocol_handler *handler);
+ void tb_unregister_protocol_handler(struct tb_protocol_handler *handler);
+ 
+ /**
+  * struct tb_service - Thunderbolt service
+  * @dev: XDomain device
+  * @id: ID of the service (shown in sysfs)
+  * @key: Protocol key from the properties directory
+  * @prtcid: Protocol ID from the properties directory
+  * @prtcvers: Protocol version from the properties directory
+  * @prtcrevs: Protocol software revision from the properties directory
+  * @prtcstns: Protocol settings mask from the properties directory
+  *
+  * Each domain exposes set of services it supports as collection of
+  * properties. For each service there will be one corresponding
+  * &struct tb_service. Service drivers are bound to these.
+  */
+ struct tb_service {
+ 	struct device dev;
+ 	int id;
+ 	const char *key;
+ 	u32 prtcid;
+ 	u32 prtcvers;
+ 	u32 prtcrevs;
+ 	u32 prtcstns;
+ };
+ 
+ static inline struct tb_service *tb_service_get(struct tb_service *svc)
+ {
+ 	if (svc)
+ 		get_device(&svc->dev);
+ 	return svc;
+ }
+ 
+ static inline void tb_service_put(struct tb_service *svc)
+ {
+ 	if (svc)
+ 		put_device(&svc->dev);
+ }
+ 
+ static inline bool tb_is_service(const struct device *dev)
+ {
+ 	return dev->type == &tb_service_type;
+ }
+ 
+ static inline struct tb_service *tb_to_service(struct device *dev)
+ {
+ 	if (tb_is_service(dev))
+ 		return container_of(dev, struct tb_service, dev);
+ 	return NULL;
+ }
+ 
+ /**
+  * tb_service_driver - Thunderbolt service driver
+  * @driver: Driver structure
+  * @probe: Called when the driver is probed
+  * @remove: Called when the driver is removed (optional)
+  * @shutdown: Called at shutdown time to stop the service (optional)
+  * @id_table: Table of service identifiers the driver supports
+  */
+ struct tb_service_driver {
+ 	struct device_driver driver;
+ 	int (*probe)(struct tb_service *svc, const struct tb_service_id *id);
+ 	void (*remove)(struct tb_service *svc);
+ 	void (*shutdown)(struct tb_service *svc);
+ 	const struct tb_service_id *id_table;
+ };
+ 
+ #define TB_SERVICE(key, id)				\
+ 	.match_flags = TBSVC_MATCH_PROTOCOL_KEY |	\
+ 		       TBSVC_MATCH_PROTOCOL_ID,		\
+ 	.protocol_key = (key),				\
+ 	.protocol_id = (id)
+ 
+ int tb_register_service_driver(struct tb_service_driver *drv);
+ void tb_unregister_service_driver(struct tb_service_driver *drv);
+ 
+ static inline void *tb_service_get_drvdata(const struct tb_service *svc)
+ {
+ 	return dev_get_drvdata(&svc->dev);
+ }
+ 
+ static inline void tb_service_set_drvdata(struct tb_service *svc, void *data)
+ {
+ 	dev_set_drvdata(&svc->dev, data);
+ }
+ 
+ static inline struct tb_xdomain *tb_service_parent(struct tb_service *svc)
+ {
+ 	return tb_to_xdomain(svc->dev.parent);
+ }
+ 
+ /**
+  * struct tb_nhi - thunderbolt native host interface
+  * @lock: Must be held during ring creation/destruction. Is acquired by
+  *	  interrupt_work when dispatching interrupts to individual rings.
+  * @pdev: Pointer to the PCI device
+  * @iobase: MMIO space of the NHI
+  * @tx_rings: All Tx rings available on this host controller
+  * @rx_rings: All Rx rings available on this host controller
+  * @msix_ida: Used to allocate MSI-X vectors for rings
+  * @going_away: The host controller device is about to disappear so when
+  *		this flag is set, avoid touching the hardware anymore.
+  * @interrupt_work: Work scheduled to handle ring interrupt when no
+  *		    MSI-X is used.
+  * @hop_count: Number of rings (end point hops) supported by NHI.
+  */
+ struct tb_nhi {
+ 	spinlock_t lock;
+ 	struct pci_dev *pdev;
+ 	void __iomem *iobase;
+ 	struct tb_ring **tx_rings;
+ 	struct tb_ring **rx_rings;
+ 	struct ida msix_ida;
+ 	bool going_away;
+ 	struct work_struct interrupt_work;
+ 	u32 hop_count;
+ };
+ 
+ /**
+  * struct tb_ring - thunderbolt TX or RX ring associated with a NHI
+  * @lock: Lock serializing actions to this ring. Must be acquired after
+  *	  nhi->lock.
+  * @nhi: Pointer to the native host controller interface
+  * @size: Size of the ring
+  * @hop: Hop (DMA channel) associated with this ring
+  * @head: Head of the ring (write next descriptor here)
+  * @tail: Tail of the ring (complete next descriptor here)
+  * @descriptors: Allocated descriptors for this ring
+  * @queue: Queue holding frames to be transferred over this ring
+  * @in_flight: Queue holding frames that are currently in flight
+  * @work: Interrupt work structure
+  * @is_tx: Is the ring Tx or Rx
+  * @running: Is the ring running
+  * @irq: MSI-X irq number if the ring uses MSI-X. %0 otherwise.
+  * @vector: MSI-X vector number the ring uses (only set if @irq is > 0)
+  * @flags: Ring specific flags
+  * @sof_mask: Bit mask used to detect start of frame PDF
+  * @eof_mask: Bit mask used to detect end of frame PDF
+  * @start_poll: Called when ring interrupt is triggered to start
+  *		polling. Passing %NULL keeps the ring in interrupt mode.
+  * @poll_data: Data passed to @start_poll
+  */
+ struct tb_ring {
+ 	spinlock_t lock;
+ 	struct tb_nhi *nhi;
+ 	int size;
+ 	int hop;
+ 	int head;
+ 	int tail;
+ 	struct ring_desc *descriptors;
+ 	dma_addr_t descriptors_dma;
+ 	struct list_head queue;
+ 	struct list_head in_flight;
+ 	struct work_struct work;
+ 	bool is_tx:1;
+ 	bool running:1;
+ 	int irq;
+ 	u8 vector;
+ 	unsigned int flags;
+ 	u16 sof_mask;
+ 	u16 eof_mask;
+ 	void (*start_poll)(void *data);
+ 	void *poll_data;
+ };
+ 
+ /* Leave ring interrupt enabled on suspend */
+ #define RING_FLAG_NO_SUSPEND	BIT(0)
+ /* Configure the ring to be in frame mode */
+ #define RING_FLAG_FRAME		BIT(1)
+ /* Enable end-to-end flow control */
+ #define RING_FLAG_E2E		BIT(2)
+ 
+ struct ring_frame;
+ typedef void (*ring_cb)(struct tb_ring *, struct ring_frame *, bool canceled);
+ 
+ /**
+  * enum ring_desc_flags - Flags for DMA ring descriptor
+  * %RING_DESC_ISOCH: Enable isonchronous DMA (Tx only)
+  * %RING_DESC_CRC_ERROR: In frame mode CRC check failed for the frame (Rx only)
+  * %RING_DESC_COMPLETED: Descriptor completed (set by NHI)
+  * %RING_DESC_POSTED: Always set this
+  * %RING_DESC_BUFFER_OVERRUN: RX buffer overrun
+  * %RING_DESC_INTERRUPT: Request an interrupt on completion
+  */
+ enum ring_desc_flags {
+ 	RING_DESC_ISOCH = 0x1,
+ 	RING_DESC_CRC_ERROR = 0x1,
+ 	RING_DESC_COMPLETED = 0x2,
+ 	RING_DESC_POSTED = 0x4,
+ 	RING_DESC_BUFFER_OVERRUN = 0x04,
+ 	RING_DESC_INTERRUPT = 0x8,
+ };
+ 
+ /**
+  * struct ring_frame - For use with ring_rx/ring_tx
+  * @buffer_phy: DMA mapped address of the frame
+  * @callback: Callback called when the frame is finished (optional)
+  * @list: Frame is linked to a queue using this
+  * @size: Size of the frame in bytes (%0 means %4096)
+  * @flags: Flags for the frame (see &enum ring_desc_flags)
+  * @eof: End of frame protocol defined field
+  * @sof: Start of frame protocol defined field
+  */
+ struct ring_frame {
+ 	dma_addr_t buffer_phy;
+ 	ring_cb callback;
+ 	struct list_head list;
+ 	u32 size:12;
+ 	u32 flags:12;
+ 	u32 eof:4;
+ 	u32 sof:4;
+ };
+ 
+ /* Minimum size for ring_rx */
+ #define TB_FRAME_SIZE		0x100
+ 
+ struct tb_ring *tb_ring_alloc_tx(struct tb_nhi *nhi, int hop, int size,
+ 				 unsigned int flags);
+ struct tb_ring *tb_ring_alloc_rx(struct tb_nhi *nhi, int hop, int size,
+ 				 unsigned int flags, u16 sof_mask, u16 eof_mask,
+ 				 void (*start_poll)(void *), void *poll_data);
+ void tb_ring_start(struct tb_ring *ring);
+ void tb_ring_stop(struct tb_ring *ring);
+ void tb_ring_free(struct tb_ring *ring);
+ 
+ int __tb_ring_enqueue(struct tb_ring *ring, struct ring_frame *frame);
+ 
+ /**
+  * tb_ring_rx() - enqueue a frame on an RX ring
+  * @ring: Ring to enqueue the frame
+  * @frame: Frame to enqueue
+  *
+  * @frame->buffer, @frame->buffer_phy have to be set. The buffer must
+  * contain at least %TB_FRAME_SIZE bytes.
+  *
+  * @frame->callback will be invoked with @frame->size, @frame->flags,
+  * @frame->eof, @frame->sof set once the frame has been received.
+  *
+  * If ring_stop() is called after the packet has been enqueued
+  * @frame->callback will be called with canceled set to true.
+  *
+  * Return: Returns %-ESHUTDOWN if ring_stop has been called. Zero otherwise.
+  */
+ static inline int tb_ring_rx(struct tb_ring *ring, struct ring_frame *frame)
+ {
+ 	WARN_ON(ring->is_tx);
+ 	return __tb_ring_enqueue(ring, frame);
+ }
+ 
+ /**
+  * tb_ring_tx() - enqueue a frame on an TX ring
+  * @ring: Ring the enqueue the frame
+  * @frame: Frame to enqueue
+  *
+  * @frame->buffer, @frame->buffer_phy, @frame->size, @frame->eof and
+  * @frame->sof have to be set.
+  *
+  * @frame->callback will be invoked with once the frame has been transmitted.
+  *
+  * If ring_stop() is called after the packet has been enqueued @frame->callback
+  * will be called with canceled set to true.
+  *
+  * Return: Returns %-ESHUTDOWN if ring_stop has been called. Zero otherwise.
+  */
+ static inline int tb_ring_tx(struct tb_ring *ring, struct ring_frame *frame)
+ {
+ 	WARN_ON(!ring->is_tx);
+ 	return __tb_ring_enqueue(ring, frame);
+ }
+ 
+ /* Used only when the ring is in polling mode */
+ struct ring_frame *tb_ring_poll(struct tb_ring *ring);
+ void tb_ring_poll_complete(struct tb_ring *ring);
+ 
++>>>>>>> 4ffe722eefcb (thunderbolt: Add polling mode for rings)
  #endif /* THUNDERBOLT_H_ */
* Unmerged path drivers/thunderbolt/ctl.c
* Unmerged path drivers/thunderbolt/nhi.c
* Unmerged path include/linux/thunderbolt.h
