nvme-pci: Suspend queues after deleting them

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Keith Busch <keith.busch@intel.com>
commit ee9aebb27cbdac677525e0e56e8844cf4bf46461
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ee9aebb2.failed

The driver had been abusing the cq_vector state to know if new submissions
were safe, but that was before we could quiesce blk-mq. If the controller
happens to get an interrupt through while we're suspending those queues,
'no irq handler' warnings may occur.

This patch will disable the interrupts only after the queues are deleted.

	Reported-by: Jianchao Wang <jianchao.w.wang@oracle.com>
	Tested-by: Jianchao Wang <jianchao.w.wang@oracle.com>
	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit ee9aebb27cbdac677525e0e56e8844cf4bf46461)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/pci.c
diff --cc drivers/nvme/host/pci.c
index e3ee89a3f5ff,e2342d365d3c..000000000000
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@@ -1081,13 -1322,8 +1081,16 @@@ static int nvme_suspend_queue(struct nv
  
  static void nvme_disable_admin_queue(struct nvme_dev *dev, bool shutdown)
  {
 -	struct nvme_queue *nvmeq = &dev->queues[0];
 +	struct nvme_queue *nvmeq = dev->queues[0];
  
++<<<<<<< HEAD
 +	if (!nvmeq)
 +		return;
 +	if (nvme_suspend_queue(nvmeq))
 +		return;
 +
++=======
++>>>>>>> ee9aebb27cbd (nvme-pci: Suspend queues after deleting them)
  	if (shutdown)
  		nvme_shutdown_ctrl(&dev->ctrl);
  	else
@@@ -1962,21 -2196,13 +1965,29 @@@ static void nvme_dev_disable(struct nvm
  	}
  	nvme_stop_queues(&dev->ctrl);
  
++<<<<<<< HEAD
 +	queues = dev->online_queues - 1;
 +	for (i = dev->ctrl.queue_count - 1; i > 0; i--)
 +		nvme_suspend_queue(dev->queues[i]);
 +
 +	if (dead) {
 +		/* A device might become IO incapable very soon during
 +		 * probe, before the admin queue is configured. Thus,
 +		 * queue_count can be 0 here.
 +		 */
 +		if (dev->ctrl.queue_count)
 +			nvme_suspend_queue(dev->queues[0]);
 +	} else {
 +		nvme_disable_io_queues(dev, queues);
++=======
+ 	if (!dead) {
+ 		nvme_disable_io_queues(dev);
++>>>>>>> ee9aebb27cbd (nvme-pci: Suspend queues after deleting them)
  		nvme_disable_admin_queue(dev, shutdown);
  	}
+ 	for (i = dev->ctrl.queue_count - 1; i >= 0; i--)
+ 		nvme_suspend_queue(&dev->queues[i]);
+ 
  	nvme_pci_disable(dev);
  
  	blk_mq_tagset_busy_iter(&dev->tagset, nvme_cancel_request, &dev->ctrl);
* Unmerged path drivers/nvme/host/pci.c
