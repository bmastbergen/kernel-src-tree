pinctrl: intel: Allow custom GPIO base for pad groups

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [pinctrl] intel: Allow custom GPIO base for pad groups (David Arcari) [1567849]
Rebuild_FUZZ: 90.72%
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit a60eac3239f01838bdd34eaac8c486c4c6e84551
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/a60eac32.failed

Currently we always have direct mapping between GPIO numbers and the
hardware pin numbers. However, there are cases where that's not the case
anymore (more about this in the next patch). Instead we need to be able
to specify custom GPIO base for certain pad groups.

To support this, add a new field (gpio_base) to the pad group structure
and update the core Intel pinctrl driver to handle this accordingly.
Passing 0 as gpio_base will use direct mapping so the existing drivers
do not need to be modified. Passing -1 excludes the whole pad group from
having GPIO mapping.

	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit a60eac3239f01838bdd34eaac8c486c4c6e84551)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pinctrl/intel/pinctrl-intel.c
diff --cc drivers/pinctrl/intel/pinctrl-intel.c
index 2350f7aeaaab,4c2369a8d926..000000000000
--- a/drivers/pinctrl/intel/pinctrl-intel.c
+++ b/drivers/pinctrl/intel/pinctrl-intel.c
@@@ -827,16 -856,12 +872,19 @@@ static void intel_gpio_irq_ack(struct i
  	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
  	struct intel_pinctrl *pctrl = gpiochip_get_data(gc);
  	const struct intel_community *community;
- 	unsigned pin = irqd_to_hwirq(d);
+ 	const struct intel_padgroup *padgrp;
+ 	int pin;
  
++<<<<<<< HEAD
 +	community = intel_get_community(pctrl, pin);
 +	if (community) {
 +		const struct intel_padgroup *padgrp;
 +		unsigned gpp, gpp_offset;
- 
- 		padgrp = intel_community_get_padgroup(community, pin);
- 		if (!padgrp)
- 			return;
++=======
+ 	pin = intel_gpio_to_pin(pctrl, irqd_to_hwirq(d), &community, &padgrp);
+ 	if (pin >= 0) {
+ 		unsigned gpp, gpp_offset, is_offset;
++>>>>>>> a60eac3239f0 (pinctrl: intel: Allow custom GPIO base for pad groups)
  
  		gpp = padgrp->reg_num;
  		gpp_offset = padgroup_offset(padgrp, pin);
@@@ -852,21 -878,18 +900,24 @@@ static void intel_gpio_irq_enable(struc
  	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
  	struct intel_pinctrl *pctrl = gpiochip_get_data(gc);
  	const struct intel_community *community;
- 	unsigned pin = irqd_to_hwirq(d);
+ 	const struct intel_padgroup *padgrp;
+ 	int pin;
  
++<<<<<<< HEAD
 +	community = intel_get_community(pctrl, pin);
 +	if (community) {
 +		const struct intel_padgroup *padgrp;
 +		unsigned gpp, gpp_offset;
++=======
+ 	pin = intel_gpio_to_pin(pctrl, irqd_to_hwirq(d), &community, &padgrp);
+ 	if (pin >= 0) {
+ 		unsigned gpp, gpp_offset, is_offset;
++>>>>>>> a60eac3239f0 (pinctrl: intel: Allow custom GPIO base for pad groups)
  		unsigned long flags;
  		u32 value;
  
- 		padgrp = intel_community_get_padgroup(community, pin);
- 		if (!padgrp)
- 			return;
- 
  		gpp = padgrp->reg_num;
  		gpp_offset = padgroup_offset(padgrp, pin);
 -		is_offset = community->is_offset + gpp * 4;
  
  		raw_spin_lock_irqsave(&pctrl->lock, flags);
  		/* Clear interrupt status first to avoid unexpected interrupt */
@@@ -1013,14 -1033,10 +1060,15 @@@ static irqreturn_t intel_gpio_community
  		pending &= enabled;
  
  		for_each_set_bit(gpp_offset, &pending, padgrp->size) {
- 			unsigned padno, irq;
- 
- 			padno = padgrp->base - community->pin_base + gpp_offset;
- 			if (padno >= community->npins)
- 				break;
+ 			unsigned irq;
  
++<<<<<<< HEAD
 +			irq = irq_find_mapping(gc->irqdomain,
 +					       community->pin_base + padno);
++=======
+ 			irq = irq_find_mapping(gc->irq.domain,
+ 					       padgrp->gpio_base + gpp_offset);
++>>>>>>> a60eac3239f0 (pinctrl: intel: Allow custom GPIO base for pad groups)
  			generic_handle_irq(irq);
  
  			ret |= IRQ_HANDLED;
@@@ -1054,26 -1070,50 +1102,70 @@@ static struct irq_chip intel_gpio_irqch
  	.irq_unmask = intel_gpio_irq_unmask,
  	.irq_set_type = intel_gpio_irq_type,
  	.irq_set_wake = intel_gpio_irq_wake,
 -	.flags = IRQCHIP_MASK_ON_SUSPEND,
  };
  
++<<<<<<< HEAD
 +static void intel_gpio_irq_init(struct intel_pinctrl *pctrl)
 +{
 +	size_t i;
 +
 +	for (i = 0; i < pctrl->ncommunities; i++) {
 +		const struct intel_community *community;
 +		void __iomem *base;
 +		unsigned gpp;
 +
 +		community = &pctrl->communities[i];
 +		base = community->regs;
 +
 +		for (gpp = 0; gpp < community->ngpps; gpp++) {
 +			/* Mask and clear all interrupts */
 +			writel(0, base + community->ie_offset + gpp * 4);
 +			writel(0xffff, base + GPI_IS + gpp * 4);
 +		}
 +	}
++=======
+ static int intel_gpio_add_pin_ranges(struct intel_pinctrl *pctrl,
+ 				     const struct intel_community *community)
+ {
+ 	int ret, i;
+ 
+ 	for (i = 0; i < community->ngpps; i++) {
+ 		const struct intel_padgroup *gpp = &community->gpps[i];
+ 
+ 		if (gpp->gpio_base < 0)
+ 			continue;
+ 
+ 		ret = gpiochip_add_pin_range(&pctrl->chip, dev_name(pctrl->dev),
+ 					     gpp->gpio_base, gpp->base,
+ 					     gpp->size);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static unsigned intel_gpio_ngpio(const struct intel_pinctrl *pctrl)
+ {
+ 	const struct intel_community *community;
+ 	unsigned ngpio = 0;
+ 	int i, j;
+ 
+ 	for (i = 0; i < pctrl->ncommunities; i++) {
+ 		community = &pctrl->communities[i];
+ 		for (j = 0; j < community->ngpps; j++) {
+ 			const struct intel_padgroup *gpp = &community->gpps[j];
+ 
+ 			if (gpp->gpio_base < 0)
+ 				continue;
+ 
+ 			if (gpp->gpio_base + gpp->size > ngpio)
+ 				ngpio = gpp->gpio_base + gpp->size;
+ 		}
+ 	}
+ 
+ 	return ngpio;
++>>>>>>> a60eac3239f0 (pinctrl: intel: Allow custom GPIO base for pad groups)
  }
  
  static int intel_gpio_probe(struct intel_pinctrl *pctrl, int irq)
@@@ -1082,9 -1122,9 +1174,9 @@@
  
  	pctrl->chip = intel_gpio_chip;
  
- 	pctrl->chip.ngpio = pctrl->soc->npins;
+ 	pctrl->chip.ngpio = intel_gpio_ngpio(pctrl);
  	pctrl->chip.label = dev_name(pctrl->dev);
 -	pctrl->chip.parent = pctrl->dev;
 +	pctrl->chip.dev = pctrl->dev;
  	pctrl->chip.base = -1;
  	pctrl->irq = irq;
  
@@@ -1094,11 -1134,14 +1186,22 @@@
  		return ret;
  	}
  
++<<<<<<< HEAD
 +	ret = gpiochip_add_pin_range(&pctrl->chip, dev_name(pctrl->dev),
 +				     0, 0, pctrl->soc->npins);
 +	if (ret) {
 +		dev_err(pctrl->dev, "failed to add GPIO pin range\n");
 +		goto fail;
++=======
+ 	for (i = 0; i < pctrl->ncommunities; i++) {
+ 		struct intel_community *community = &pctrl->communities[i];
+ 
+ 		ret = intel_gpio_add_pin_ranges(pctrl, community);
+ 		if (ret) {
+ 			dev_err(pctrl->dev, "failed to add GPIO pin range\n");
+ 			return ret;
+ 		}
++>>>>>>> a60eac3239f0 (pinctrl: intel: Allow custom GPIO base for pad groups)
  	}
  
  	/*
* Unmerged path drivers/pinctrl/intel/pinctrl-intel.c
diff --git a/drivers/pinctrl/intel/pinctrl-intel.h b/drivers/pinctrl/intel/pinctrl-intel.h
index e178b29f1942..13fff8555468 100644
--- a/drivers/pinctrl/intel/pinctrl-intel.h
+++ b/drivers/pinctrl/intel/pinctrl-intel.h
@@ -51,6 +51,8 @@ struct intel_function {
  * @reg_num: GPI_IS register number
  * @base: Starting pin of this group
  * @size: Size of this group (maximum is 32).
+ * @gpio_base: Starting GPIO base of this group (%0 if matches with @base,
+ *	       and %-1 if no GPIO mapping should be created)
  * @padown_num: PAD_OWN register number (assigned by the core driver)
  *
  * If pad groups of a community are not the same size, use this structure
@@ -60,6 +62,7 @@ struct intel_padgroup {
 	unsigned reg_num;
 	unsigned base;
 	unsigned size;
+	int gpio_base;
 	unsigned padown_num;
 };
 
