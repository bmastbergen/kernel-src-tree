ipmi_si: Change ipmi_si_add_smi() to take just I/O info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Corey Minyard <cminyard@mvista.com>
commit bb398a4cb09a0ed96cf0fc2e90012cf6bf13a824
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/bb398a4c.failed

Instead of allocating the smi_info structure, filling in the I/O
info, and passing it to ipmi_si_add_smi(), just pass the I/O
info in the io structure and let ipmi_si_add_smi() allocate
the smi_info structure.

This required redoing the way the remove functions for some
device interfaces worked, a new function named
ipmi_si_remove_by_dev() allows the device to be passed in and
detected instead of using driver data, which couldn't be
filled out easily othersize.

After this the platform handling should be decoupled from the
smi_info structure and that handling can be pulled out to its
own files.

	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit bb398a4cb09a0ed96cf0fc2e90012cf6bf13a824)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_si.h
#	drivers/char/ipmi/ipmi_si_intf.c
#	drivers/char/ipmi/ipmi_si_sm.h
diff --cc drivers/char/ipmi/ipmi_si.h
index a4d993b1fe66,9573b35d73af..000000000000
--- a/drivers/char/ipmi/ipmi_si.h
+++ b/drivers/char/ipmi/ipmi_si.h
@@@ -13,6 -14,9 +13,15 @@@
  #define DEFAULT_REGSPACING	1
  #define DEFAULT_REGSIZE		1
  
++<<<<<<< HEAD
 +struct smi_info;
 +
 +int ipmi_si_add_smi(struct smi_info *info);
++=======
+ int ipmi_si_add_smi(struct si_sm_io *io);
+ irqreturn_t ipmi_si_irq_handler(int irq, void *data);
+ void ipmi_irq_start_cleanup(struct si_sm_io *io);
+ int ipmi_std_irq_setup(struct si_sm_io *io);
+ void ipmi_irq_finish_setup(struct si_sm_io *io);
+ int ipmi_si_remove_by_dev(struct device *dev);
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 72982bfaeaf1,6c2e14af8321..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -1267,10 -1242,10 +1266,17 @@@ static int get_smi_info(void *send_info
  {
  	struct smi_info *smi = send_info;
  
++<<<<<<< HEAD
 +	data->addr_src = smi->addr_source;
 +	data->dev = smi->dev;
 +	data->addr_info = smi->addr_info;
 +	get_device(smi->dev);
++=======
+ 	data->addr_src = smi->io.addr_source;
+ 	data->dev = smi->io.dev;
+ 	data->addr_info = smi->io.addr_info;
+ 	get_device(smi->io.dev);
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  
  	return 0;
  }
@@@ -1910,46 -1888,30 +1915,54 @@@ static int hotmod_handler(const char *v
  		}
  
  		if (op == HM_ADD) {
- 			info = smi_info_alloc();
- 			if (!info) {
- 				rv = -ENOMEM;
- 				goto out;
- 			}
+ 			struct si_sm_io io;
  
++<<<<<<< HEAD
 +			info->addr_source = SI_HOTMOD;
 +			info->si_type = si_type;
 +			info->io.addr_data = addr;
 +			info->io.addr_type = addr_space;
 +			if (addr_space == IPMI_MEM_ADDR_SPACE)
 +				info->io_setup = mem_setup;
 +			else
 +				info->io_setup = port_setup;
 +
 +			info->io.addr = NULL;
 +			info->io.regspacing = regspacing;
 +			if (!info->io.regspacing)
 +				info->io.regspacing = DEFAULT_REGSPACING;
 +			info->io.regsize = regsize;
 +			if (!info->io.regsize)
 +				info->io.regsize = DEFAULT_REGSIZE;
 +			info->io.regshift = regshift;
 +			info->irq = irq;
 +			if (info->irq)
 +				info->irq_setup = std_irq_setup;
 +			info->slave_addr = ipmb;
- 
- 			rv = ipmi_si_add_smi(info);
- 			if (rv) {
- 				kfree(info);
- 				goto out;
- 			}
- 			mutex_lock(&smi_infos_lock);
- 			rv = try_smi_init(info);
- 			mutex_unlock(&smi_infos_lock);
- 			if (rv) {
- 				cleanup_one_si(info);
++=======
+ 			memset(&io, 0, sizeof(io));
+ 			io.addr_source = SI_HOTMOD;
+ 			io.si_type = si_type;
+ 			io.addr_data = addr;
+ 			io.addr_type = addr_space;
+ 
+ 			io.addr = NULL;
+ 			io.regspacing = regspacing;
+ 			if (!io.regspacing)
+ 				io.regspacing = DEFAULT_REGSPACING;
+ 			io.regsize = regsize;
+ 			if (!io.regsize)
+ 				io.regsize = DEFAULT_REGSIZE;
+ 			io.regshift = regshift;
+ 			io.irq = irq;
+ 			if (io.irq)
+ 				io.irq_setup = ipmi_std_irq_setup;
+ 			io.slave_addr = ipmb;
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
+ 
+ 			rv = ipmi_si_add_smi(&io);
+ 			if (rv)
  				goto out;
- 			}
  		} else {
  			/* remove */
  			struct smi_info *e, *tmp_e;
@@@ -1982,19 -1945,15 +1996,31 @@@ static int hardcode_find_bmc(void
  		if (!ports[i] && !addrs[i])
  			continue;
  
++<<<<<<< HEAD
 +		info = smi_info_alloc();
 +		if (!info)
 +			return -ENOMEM;
 +
 +		info->addr_source = SI_HARDCODED;
 +		pr_info(PFX "probing via hardcoded address\n");
 +
 +		if (!si_type[i] || strcmp(si_type[i], "kcs") == 0) {
 +			info->si_type = SI_KCS;
 +		} else if (strcmp(si_type[i], "smic") == 0) {
 +			info->si_type = SI_SMIC;
 +		} else if (strcmp(si_type[i], "bt") == 0) {
 +			info->si_type = SI_BT;
++=======
+ 		io.addr_source = SI_HARDCODED;
+ 		pr_info(PFX "probing via hardcoded address\n");
+ 
+ 		if (!si_type[i] || strcmp(si_type[i], "kcs") == 0) {
+ 			io.si_type = SI_KCS;
+ 		} else if (strcmp(si_type[i], "smic") == 0) {
+ 			io.si_type = SI_SMIC;
+ 		} else if (strcmp(si_type[i], "bt") == 0) {
+ 			io.si_type = SI_BT;
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  		} else {
  			pr_warn(PFX "Interface type specified for interface %d, was invalid: %s\n",
  				i, si_type[i]);
@@@ -2004,43 -1962,32 +2029,58 @@@
  
  		if (ports[i]) {
  			/* An I/O port */
++<<<<<<< HEAD
 +			info->io_setup = port_setup;
 +			info->io.addr_data = ports[i];
 +			info->io.addr_type = IPMI_IO_ADDR_SPACE;
 +		} else if (addrs[i]) {
 +			/* A memory port */
 +			info->io_setup = mem_setup;
 +			info->io.addr_data = addrs[i];
 +			info->io.addr_type = IPMI_MEM_ADDR_SPACE;
++=======
+ 			io.addr_data = ports[i];
+ 			io.addr_type = IPMI_IO_ADDR_SPACE;
+ 		} else if (addrs[i]) {
+ 			/* A memory port */
+ 			io.addr_data = addrs[i];
+ 			io.addr_type = IPMI_MEM_ADDR_SPACE;
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  		} else {
  			pr_warn(PFX "Interface type specified for interface %d, but port and address were not set or set to zero.\n",
  				i);
  			continue;
  		}
  
++<<<<<<< HEAD
 +		info->io.addr = NULL;
 +		info->io.regspacing = regspacings[i];
 +		if (!info->io.regspacing)
 +			info->io.regspacing = DEFAULT_REGSPACING;
 +		info->io.regsize = regsizes[i];
 +		if (!info->io.regsize)
 +			info->io.regsize = DEFAULT_REGSIZE;
 +		info->io.regshift = regshifts[i];
 +		info->irq = irqs[i];
 +		if (info->irq)
 +			info->irq_setup = std_irq_setup;
 +		info->slave_addr = slave_addrs[i];
- 
- 		if (!ipmi_si_add_smi(info)) {
- 			mutex_lock(&smi_infos_lock);
- 			if (try_smi_init(info))
- 				cleanup_one_si(info);
- 			mutex_unlock(&smi_infos_lock);
- 			ret = 0;
- 		} else {
- 			kfree(info);
- 		}
++=======
+ 		io.addr = NULL;
+ 		io.regspacing = regspacings[i];
+ 		if (!io.regspacing)
+ 			io.regspacing = DEFAULT_REGSPACING;
+ 		io.regsize = regsizes[i];
+ 		if (!io.regsize)
+ 			io.regsize = DEFAULT_REGSIZE;
+ 		io.regshift = regshifts[i];
+ 		io.irq = irqs[i];
+ 		if (io.irq)
+ 			io.irq_setup = ipmi_std_irq_setup;
+ 		io.slave_addr = slave_addrs[i];
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
+ 
+ 		ret = ipmi_si_add_smi(&io);
  	}
  	return ret;
  }
@@@ -2161,28 -2101,22 +2200,42 @@@ static int try_init_spmi(struct SPMITab
  		return -ENODEV;
  	}
  
++<<<<<<< HEAD
 +	info = smi_info_alloc();
 +	if (!info) {
 +		pr_err(PFX "Could not allocate SI data (3)\n");
 +		return -ENOMEM;
 +	}
 +
 +	info->addr_source = SI_SPMI;
++=======
+ 	memset(&io, 0, sizeof(io));
+ 	io.addr_source = SI_SPMI;
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  	pr_info(PFX "probing via SPMI\n");
  
  	/* Figure out the interface type. */
  	switch (spmi->InterfaceType) {
  	case 1:	/* KCS */
++<<<<<<< HEAD
 +		info->si_type = SI_KCS;
 +		break;
 +	case 2:	/* SMIC */
 +		info->si_type = SI_SMIC;
 +		break;
 +	case 3:	/* BT */
 +		info->si_type = SI_BT;
++=======
+ 		io.si_type = SI_KCS;
+ 		break;
+ 	case 2:	/* SMIC */
+ 		io.si_type = SI_SMIC;
+ 		break;
+ 	case 3:	/* BT */
+ 		io.si_type = SI_BT;
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  		break;
  	case 4: /* SSIF, just ignore */
- 		kfree(info);
  		return -EIO;
  	default:
  		pr_info(PFX "Unknown ACPI/SPMI SI type %d\n",
@@@ -2193,50 -2126,42 +2245,69 @@@
  
  	if (spmi->InterruptType & 1) {
  		/* We've got a GPE interrupt. */
++<<<<<<< HEAD
 +		info->irq = spmi->GPE;
 +		info->irq_setup = acpi_gpe_irq_setup;
 +	} else if (spmi->InterruptType & 2) {
 +		/* We've got an APIC/SAPIC interrupt. */
 +		info->irq = spmi->GlobalSystemInterrupt;
 +		info->irq_setup = std_irq_setup;
 +	} else {
 +		/* Use the default interrupt setting. */
 +		info->irq = 0;
 +		info->irq_setup = NULL;
++=======
+ 		io.irq = spmi->GPE;
+ 		io.irq_setup = acpi_gpe_irq_setup;
+ 	} else if (spmi->InterruptType & 2) {
+ 		/* We've got an APIC/SAPIC interrupt. */
+ 		io.irq = spmi->GlobalSystemInterrupt;
+ 		io.irq_setup = ipmi_std_irq_setup;
+ 	} else {
+ 		/* Use the default interrupt setting. */
+ 		io.irq = 0;
+ 		io.irq_setup = NULL;
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  	}
  
  	if (spmi->addr.bit_width) {
  		/* A (hopefully) properly formed register bit width. */
- 		info->io.regspacing = spmi->addr.bit_width / 8;
+ 		io.regspacing = spmi->addr.bit_width / 8;
  	} else {
- 		info->io.regspacing = DEFAULT_REGSPACING;
+ 		io.regspacing = DEFAULT_REGSPACING;
  	}
- 	info->io.regsize = info->io.regspacing;
- 	info->io.regshift = spmi->addr.bit_offset;
+ 	io.regsize = io.regspacing;
+ 	io.regshift = spmi->addr.bit_offset;
  
  	if (spmi->addr.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {
++<<<<<<< HEAD
 +		info->io_setup = mem_setup;
 +		info->io.addr_type = IPMI_MEM_ADDR_SPACE;
 +	} else if (spmi->addr.space_id == ACPI_ADR_SPACE_SYSTEM_IO) {
 +		info->io_setup = port_setup;
 +		info->io.addr_type = IPMI_IO_ADDR_SPACE;
++=======
+ 		io.addr_type = IPMI_MEM_ADDR_SPACE;
+ 	} else if (spmi->addr.space_id == ACPI_ADR_SPACE_SYSTEM_IO) {
+ 		io.addr_type = IPMI_IO_ADDR_SPACE;
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  	} else {
- 		kfree(info);
  		pr_warn(PFX "Unknown ACPI I/O Address type\n");
  		return -EIO;
  	}
- 	info->io.addr_data = spmi->addr.address;
+ 	io.addr_data = spmi->addr.address;
  
  	pr_info("ipmi_si: SPMI: %s %#lx regsize %d spacing %d irq %d\n",
++<<<<<<< HEAD
 +		(info->io.addr_type == IPMI_IO_ADDR_SPACE) ? "io" : "mem",
 +		info->io.addr_data, info->io.regsize, info->io.regspacing,
 +		info->irq);
++=======
+ 		(io.addr_type == IPMI_IO_ADDR_SPACE) ? "io" : "mem",
+ 		io.addr_data, io.regsize, io.regspacing, io.irq);
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  
- 	rv = ipmi_si_add_smi(info);
- 	if (rv)
- 		kfree(info);
- 
- 	return rv;
+ 	return ipmi_si_add_smi(&io);
  }
  
  static void spmi_find_bmc(void)
@@@ -2263,21 -2188,19 +2334,35 @@@
  #endif
  
  #if defined(CONFIG_DMI) || defined(CONFIG_ACPI)
++<<<<<<< HEAD
 +struct resource *ipmi_get_info_from_resources(struct platform_device *pdev,
 +					      struct smi_info *info)
++=======
+ static struct resource *
+ ipmi_get_info_from_resources(struct platform_device *pdev,
+ 			     struct si_sm_io *io)
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  {
  	struct resource *res, *res_second;
  
  	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
  	if (res) {
++<<<<<<< HEAD
 +		info->io_setup = port_setup;
 +		info->io.addr_type = IPMI_IO_ADDR_SPACE;
 +	} else {
 +		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 +		if (res) {
 +			info->io_setup = mem_setup;
 +			info->io.addr_type = IPMI_MEM_ADDR_SPACE;
 +		}
++=======
+ 		io->addr_type = IPMI_IO_ADDR_SPACE;
+ 	} else {
+ 		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 		if (res)
+ 			io->addr_type = IPMI_MEM_ADDR_SPACE;
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  	}
  	if (!res) {
  		dev_err(&pdev->dev, "no I/O or memory address\n");
@@@ -2317,27 -2239,21 +2401,41 @@@ static int dmi_ipmi_probe(struct platfo
  	if (rv)
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	info = smi_info_alloc();
 +	if (!info) {
 +		pr_err(PFX "Could not allocate SI data\n");
 +		return -ENOMEM;
 +	}
 +
 +	info->addr_source = SI_SMBIOS;
++=======
+ 	memset(&io, 0, sizeof(io));
+ 	io.addr_source = SI_SMBIOS;
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  	pr_info(PFX "probing via SMBIOS\n");
  
  	switch (type) {
  	case IPMI_DMI_TYPE_KCS:
++<<<<<<< HEAD
 +		info->si_type = SI_KCS;
 +		break;
 +	case IPMI_DMI_TYPE_SMIC:
 +		info->si_type = SI_SMIC;
 +		break;
 +	case IPMI_DMI_TYPE_BT:
 +		info->si_type = SI_BT;
++=======
+ 		io.si_type = SI_KCS;
+ 		break;
+ 	case IPMI_DMI_TYPE_SMIC:
+ 		io.si_type = SI_SMIC;
+ 		break;
+ 	case IPMI_DMI_TYPE_BT:
+ 		io.si_type = SI_BT;
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  		break;
  	default:
- 		kfree(info);
  		return -EINVAL;
  	}
  
@@@ -2349,26 -2265,24 +2447,44 @@@
  	rv = device_property_read_u8(&pdev->dev, "slave-addr", &slave_addr);
  	if (rv) {
  		dev_warn(&pdev->dev, "device has no slave-addr property");
++<<<<<<< HEAD
 +		info->slave_addr = 0x20;
 +	} else {
 +		info->slave_addr = slave_addr;
 +	}
 +
 +	info->irq = platform_get_irq(pdev, 0);
 +	if (info->irq > 0)
 +		info->irq_setup = std_irq_setup;
 +	else
 +		info->irq = 0;
 +
 +	info->dev = &pdev->dev;
 +
 +	pr_info("ipmi_si: SMBIOS: %s %#lx regsize %d spacing %d irq %d\n",
 +		(info->io.addr_type == IPMI_IO_ADDR_SPACE) ? "io" : "mem",
 +		info->io.addr_data, info->io.regsize, info->io.regspacing,
 +		info->irq);
++=======
+ 		io.slave_addr = 0x20;
+ 	} else {
+ 		io.slave_addr = slave_addr;
+ 	}
  
- 	if (ipmi_si_add_smi(info))
- 		kfree(info);
+ 	io.irq = platform_get_irq(pdev, 0);
+ 	if (io.irq > 0)
+ 		io.irq_setup = ipmi_std_irq_setup;
+ 	else
+ 		io.irq = 0;
+ 
+ 	io.dev = &pdev->dev;
+ 
+ 	pr_info("ipmi_si: SMBIOS: %s %#lx regsize %d spacing %d irq %d\n",
+ 		(io.addr_type == IPMI_IO_ADDR_SPACE) ? "io" : "mem",
+ 		io.addr_data, io.regsize, io.regspacing, io.irq);
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
+ 
+ 	ipmi_si_add_smi(&io);
  
  	return 0;
  
@@@ -2403,30 -2316,28 +2518,50 @@@ static void ipmi_pci_cleanup(struct smi
  	pci_disable_device(pdev);
  }
  
- static int ipmi_pci_probe_regspacing(struct smi_info *info)
+ static int ipmi_pci_probe_regspacing(struct si_sm_io *io)
  {
++<<<<<<< HEAD
 +	if (info->si_type == SI_KCS) {
 +		unsigned char	status;
 +		int		regspacing;
 +
 +		info->io.regsize = DEFAULT_REGSIZE;
 +		info->io.regshift = 0;
 +		info->io_size = 2;
 +		info->handlers = &kcs_smi_handlers;
 +
 +		/* detect 1, 4, 16byte spacing */
 +		for (regspacing = DEFAULT_REGSPACING; regspacing <= 16;) {
 +			info->io.regspacing = regspacing;
 +			if (info->io_setup(info)) {
 +				dev_err(info->dev,
++=======
+ 	if (io->si_type == SI_KCS) {
+ 		unsigned char	status;
+ 		int		regspacing;
+ 
+ 		io->regsize = DEFAULT_REGSIZE;
+ 		io->regshift = 0;
+ 
+ 		/* detect 1, 4, 16byte spacing */
+ 		for (regspacing = DEFAULT_REGSPACING; regspacing <= 16;) {
+ 			io->regspacing = regspacing;
+ 			if (io->io_setup(io)) {
+ 				dev_err(io->dev,
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  					"Could not setup I/O space\n");
  				return DEFAULT_REGSPACING;
  			}
  			/* write invalid cmd */
- 			info->io.outputb(&info->io, 1, 0x10);
+ 			io->outputb(io, 1, 0x10);
  			/* read status back */
++<<<<<<< HEAD
 +			status = info->io.inputb(&info->io, 1);
 +			info->io_cleanup(info);
++=======
+ 			status = io->inputb(io, 1);
+ 			io->io_cleanup(io);
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  			if (status)
  				return regspacing;
  			regspacing *= 4;
@@@ -2440,26 -2351,23 +2575,43 @@@ static int ipmi_pci_probe(struct pci_de
  {
  	int rv;
  	int class_type = pdev->class & PCI_ERMC_CLASSCODE_TYPE_MASK;
- 	struct smi_info *info;
+ 	struct si_sm_io io;
  
++<<<<<<< HEAD
 +	info = smi_info_alloc();
 +	if (!info)
 +		return -ENOMEM;
 +
 +	info->addr_source = SI_PCI;
++=======
+ 	memset(&io, 0, sizeof(io));
+ 	io.addr_source = SI_PCI;
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  	dev_info(&pdev->dev, "probing via PCI");
  
  	switch (class_type) {
  	case PCI_ERMC_CLASSCODE_TYPE_SMIC:
++<<<<<<< HEAD
 +		info->si_type = SI_SMIC;
 +		break;
 +
 +	case PCI_ERMC_CLASSCODE_TYPE_KCS:
 +		info->si_type = SI_KCS;
 +		break;
 +
 +	case PCI_ERMC_CLASSCODE_TYPE_BT:
 +		info->si_type = SI_BT;
++=======
+ 		io.si_type = SI_SMIC;
+ 		break;
+ 
+ 	case PCI_ERMC_CLASSCODE_TYPE_KCS:
+ 		io.si_type = SI_KCS;
+ 		break;
+ 
+ 	case PCI_ERMC_CLASSCODE_TYPE_BT:
+ 		io.si_type = SI_BT;
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  		break;
  
  	default:
@@@ -2474,39 -2381,31 +2625,58 @@@
  		return rv;
  	}
  
++<<<<<<< HEAD
 +	info->addr_source_cleanup = ipmi_pci_cleanup;
 +	info->addr_source_data = pdev;
 +
 +	if (pci_resource_flags(pdev, 0) & IORESOURCE_IO) {
 +		info->io_setup = port_setup;
 +		info->io.addr_type = IPMI_IO_ADDR_SPACE;
 +	} else {
 +		info->io_setup = mem_setup;
 +		info->io.addr_type = IPMI_MEM_ADDR_SPACE;
 +	}
 +	info->io.addr_data = pci_resource_start(pdev, 0);
++=======
+ 	io.addr_source_cleanup = ipmi_pci_cleanup;
+ 	io.addr_source_data = pdev;
+ 
+ 	if (pci_resource_flags(pdev, 0) & IORESOURCE_IO)
+ 		io.addr_type = IPMI_IO_ADDR_SPACE;
+ 	else
+ 		io.addr_type = IPMI_MEM_ADDR_SPACE;
+ 	io.addr_data = pci_resource_start(pdev, 0);
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  
- 	info->io.regspacing = ipmi_pci_probe_regspacing(info);
- 	info->io.regsize = DEFAULT_REGSIZE;
- 	info->io.regshift = 0;
+ 	io.regspacing = ipmi_pci_probe_regspacing(&io);
+ 	io.regsize = DEFAULT_REGSIZE;
+ 	io.regshift = 0;
  
++<<<<<<< HEAD
 +	info->irq = pdev->irq;
 +	if (info->irq)
 +		info->irq_setup = std_irq_setup;
 +
 +	info->dev = &pdev->dev;
 +	pci_set_drvdata(pdev, info);
 +
 +	dev_info(&pdev->dev, "%pR regsize %d spacing %d irq %d\n",
 +		&pdev->resource[0], info->io.regsize, info->io.regspacing,
 +		info->irq);
++=======
+ 	io.irq = pdev->irq;
+ 	if (io.irq)
+ 		io.irq_setup = ipmi_std_irq_setup;
  
- 	rv = ipmi_si_add_smi(info);
- 	if (rv) {
- 		kfree(info);
+ 	io.dev = &pdev->dev;
+ 
+ 	dev_info(&pdev->dev, "%pR regsize %d spacing %d irq %d\n",
+ 		&pdev->resource[0], io.regsize, io.regspacing, io.irq);
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
+ 
+ 	rv = ipmi_si_add_smi(&io);
+ 	if (rv)
  		pci_disable_device(pdev);
- 	}
  
  	return rv;
  }
@@@ -2542,14 -2440,15 +2711,14 @@@ static const struct of_device_id of_ipm
  	  .data = (void *)(unsigned long) SI_BT },
  	{},
  };
 -MODULE_DEVICE_TABLE(of, of_ipmi_match);
  
 -static int of_ipmi_probe(struct platform_device *pdev)
 +static int of_ipmi_probe(struct platform_device *dev)
  {
  	const struct of_device_id *match;
- 	struct smi_info *info;
+ 	struct si_sm_io io;
  	struct resource resource;
  	const __be32 *regsize, *regspacing, *regshift;
 -	struct device_node *np = pdev->dev.of_node;
 +	struct device_node *np = dev->dev.of_node;
  	int ret;
  	int proplen;
  
@@@ -2586,47 -2485,29 +2755,69 @@@
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	info = smi_info_alloc();
 +
 +	if (!info) {
 +		dev_err(&dev->dev,
 +			"could not allocate memory for OF probe\n");
 +		return -ENOMEM;
 +	}
 +
 +	info->si_type		= (enum si_type) match->data;
 +	info->addr_source	= SI_DEVICETREE;
 +	info->irq_setup		= std_irq_setup;
 +
 +	if (resource.flags & IORESOURCE_IO) {
 +		info->io_setup		= port_setup;
 +		info->io.addr_type	= IPMI_IO_ADDR_SPACE;
 +	} else {
 +		info->io_setup		= mem_setup;
 +		info->io.addr_type	= IPMI_MEM_ADDR_SPACE;
 +	}
++=======
+ 	memset(&io, 0, sizeof(io));
+ 	io.si_type	= (enum si_type) match->data;
+ 	io.addr_source	= SI_DEVICETREE;
+ 	io.irq_setup	= ipmi_std_irq_setup;
+ 
+ 	if (resource.flags & IORESOURCE_IO)
+ 		io.addr_type = IPMI_IO_ADDR_SPACE;
+ 	else
+ 		io.addr_type = IPMI_MEM_ADDR_SPACE;
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  
- 	info->io.addr_data	= resource.start;
+ 	io.addr_data	= resource.start;
  
- 	info->io.regsize	= regsize ? be32_to_cpup(regsize) : DEFAULT_REGSIZE;
- 	info->io.regspacing	= regspacing ? be32_to_cpup(regspacing) : DEFAULT_REGSPACING;
- 	info->io.regshift	= regshift ? be32_to_cpup(regshift) : 0;
+ 	io.regsize	= regsize ? be32_to_cpup(regsize) : DEFAULT_REGSIZE;
+ 	io.regspacing	= regspacing ? be32_to_cpup(regspacing) : DEFAULT_REGSPACING;
+ 	io.regshift	= regshift ? be32_to_cpup(regshift) : 0;
  
++<<<<<<< HEAD
 +	info->irq		= irq_of_parse_and_map(dev->dev.of_node, 0);
 +	info->dev		= &dev->dev;
 +
 +	dev_dbg(&dev->dev, "addr 0x%lx regsize %d spacing %d irq %d\n",
 +		info->io.addr_data, info->io.regsize, info->io.regspacing,
 +		info->irq);
 +
 +	dev_set_drvdata(&dev->dev, info);
 +
 +	ret = ipmi_si_add_smi(info);
 +	if (ret) {
 +		kfree(info);
 +		return ret;
 +	}
 +	return 0;
++=======
+ 	io.irq		= irq_of_parse_and_map(pdev->dev.of_node, 0);
+ 	io.dev		= &pdev->dev;
+ 
+ 	dev_dbg(&pdev->dev, "addr 0x%lx regsize %d spacing %d irq %d\n",
+ 		io.addr_data, io.regsize, io.regspacing, io.irq);
+ 
+ 	return ipmi_si_add_smi(&io);
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  }
  #else
  #define of_ipmi_match NULL
@@@ -2644,7 -2525,7 +2835,11 @@@ static int find_slave_address(struct si
  		int type = -1;
  		u32 flags = IORESOURCE_IO;
  
++<<<<<<< HEAD
 +		switch (info->si_type) {
++=======
+ 		switch (io->si_type) {
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  		case SI_KCS:
  			type = IPMI_DMI_TYPE_KCS;
  			break;
@@@ -2667,9 -2548,9 +2862,9 @@@
  	return slave_addr;
  }
  
 -static int acpi_ipmi_probe(struct platform_device *pdev)
 +static int acpi_ipmi_probe(struct platform_device *dev)
  {
- 	struct smi_info *info;
+ 	struct si_sm_io io;
  	acpi_handle handle;
  	acpi_status status;
  	unsigned long long tmp;
@@@ -2683,14 -2564,11 +2878,20 @@@
  	if (!handle)
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	info = smi_info_alloc();
 +	if (!info)
 +		return -ENOMEM;
 +
 +	info->addr_source = SI_ACPI;
 +	dev_info(&dev->dev, PFX "probing via ACPI\n");
++=======
+ 	memset(&io, 0, sizeof(io));
+ 	io.addr_source = SI_ACPI;
+ 	dev_info(&pdev->dev, PFX "probing via ACPI\n");
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  
- 	info->addr_info.acpi_info.acpi_handle = handle;
+ 	io.addr_info.acpi_info.acpi_handle = handle;
  
  	/* _IFT tells us the interface type: KCS, BT, etc */
  	status = acpi_evaluate_integer(handle, "_IFT", NULL, &tmp);
@@@ -2701,13 -2580,13 +2902,23 @@@
  
  	switch (tmp) {
  	case 1:
++<<<<<<< HEAD
 +		info->si_type = SI_KCS;
 +		break;
 +	case 2:
 +		info->si_type = SI_SMIC;
 +		break;
 +	case 3:
 +		info->si_type = SI_BT;
++=======
+ 		io.si_type = SI_KCS;
+ 		break;
+ 	case 2:
+ 		io.si_type = SI_SMIC;
+ 		break;
+ 	case 3:
+ 		io.si_type = SI_BT;
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  		break;
  	case 4: /* SSIF, just ignore */
  		rv = -ENODEV;
@@@ -2717,7 -2596,7 +2928,11 @@@
  		goto err_free;
  	}
  
++<<<<<<< HEAD
 +	res = ipmi_get_info_from_resources(dev, info);
++=======
+ 	res = ipmi_get_info_from_resources(pdev, &io);
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  	if (!res) {
  		rv = -EINVAL;
  		goto err_free;
@@@ -2726,34 -2605,27 +2941,48 @@@
  	/* If _GPE exists, use it; otherwise use standard interrupts */
  	status = acpi_evaluate_integer(handle, "_GPE", NULL, &tmp);
  	if (ACPI_SUCCESS(status)) {
++<<<<<<< HEAD
 +		info->irq = tmp;
 +		info->irq_setup = acpi_gpe_irq_setup;
++=======
+ 		io.irq = tmp;
+ 		io.irq_setup = acpi_gpe_irq_setup;
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  	} else {
 -		int irq = platform_get_irq(pdev, 0);
 +		int irq = platform_get_irq(dev, 0);
  
  		if (irq > 0) {
++<<<<<<< HEAD
 +			info->irq = irq;
 +			info->irq_setup = std_irq_setup;
 +		}
 +	}
 +
 +	info->slave_addr = find_slave_address(info, info->slave_addr);
 +
 +	info->dev = &dev->dev;
 +	platform_set_drvdata(dev, info);
 +
 +	dev_info(info->dev, "%pR regsize %d spacing %d irq %d\n",
 +		 res, info->io.regsize, info->io.regspacing,
 +		 info->irq);
++=======
+ 			io.irq = irq;
+ 			io.irq_setup = ipmi_std_irq_setup;
+ 		}
+ 	}
  
- 	rv = ipmi_si_add_smi(info);
- 	if (rv)
- 		kfree(info);
+ 	io.slave_addr = find_slave_address(&io, io.slave_addr);
  
- 	return rv;
+ 	io.dev = &pdev->dev;
+ 
+ 	dev_info(io.dev, "%pR regsize %d spacing %d irq %d\n",
+ 		 res, io.regsize, io.regspacing, io.irq);
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
+ 
+ 	return ipmi_si_add_smi(&io);
  
  err_free:
- 	kfree(info);
  	return rv;
  }
  
@@@ -2769,23 -2641,20 +2998,27 @@@ static int acpi_ipmi_probe(struct platf
  }
  #endif
  
 -static int ipmi_probe(struct platform_device *pdev)
 +static int ipmi_probe(struct platform_device *dev)
  {
 -	if (pdev->dev.of_node && of_ipmi_probe(pdev) == 0)
 +	if (dev->dev.of_node && of_ipmi_probe(dev) == 0)
  		return 0;
  
 -	if (acpi_ipmi_probe(pdev) == 0)
 +	if (acpi_ipmi_probe(dev) == 0)
  		return 0;
  
 -	return dmi_ipmi_probe(pdev);
 +	return dmi_ipmi_probe(dev);
  }
  
 -static int ipmi_remove(struct platform_device *pdev)
 +static int ipmi_remove(struct platform_device *dev)
  {
++<<<<<<< HEAD
 +	struct smi_info *info = dev_get_drvdata(&dev->dev);
 +
 +	cleanup_one_si(info);
 +	return 0;
++=======
+ 	return ipmi_si_remove_by_dev(&pdev->dev);
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  }
  
  static struct platform_driver ipmi_driver = {
@@@ -2799,51 -2668,32 +3032,58 @@@
  };
  
  #ifdef CONFIG_PARISC
 -static int __init ipmi_parisc_probe(struct parisc_device *dev)
 +static int ipmi_parisc_probe(struct parisc_device *dev)
  {
- 	struct smi_info *info;
- 	int rv;
+ 	struct si_sm_io io;
  
- 	info = smi_info_alloc();
+ 	io.si_type	= SI_KCS;
+ 	io.addr_source	= SI_DEVICETREE;
+ 	io.addr_type	= IPMI_MEM_ADDR_SPACE;
+ 	io.addr_data	= dev->hpa.start;
+ 	io.regsize	= 1;
+ 	io.regspacing	= 1;
+ 	io.regshift	= 0;
+ 	io.irq		= 0; /* no interrupt */
+ 	io.irq_setup	= NULL;
+ 	io.dev		= &dev->dev;
  
- 	if (!info) {
- 		dev_err(&dev->dev,
- 			"could not allocate memory for PARISC probe\n");
- 		return -ENOMEM;
- 	}
+ 	dev_dbg(&dev->dev, "addr 0x%lx\n", io.addr_data);
  
++<<<<<<< HEAD
 +	info->si_type		= SI_KCS;
 +	info->addr_source	= SI_DEVICETREE;
 +	info->io_setup		= mem_setup;
 +	info->io.addr_type	= IPMI_MEM_ADDR_SPACE;
 +	info->io.addr_data	= dev->hpa.start;
 +	info->io.regsize	= 1;
 +	info->io.regspacing	= 1;
 +	info->io.regshift	= 0;
 +	info->irq		= 0; /* no interrupt */
 +	info->irq_setup		= NULL;
 +	info->dev		= &dev->dev;
 +
 +	dev_dbg(&dev->dev, "addr 0x%lx\n", info->io.addr_data);
 +
 +	dev_set_drvdata(&dev->dev, info);
 +
 +	rv = ipmi_si_add_smi(info);
 +	if (rv) {
 +		kfree(info);
 +		return rv;
 +	}
 +
 +	return 0;
++=======
+ 	return ipmi_si_add_smi(&io);
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  }
  
 -static int __exit ipmi_parisc_remove(struct parisc_device *dev)
 +static int ipmi_parisc_remove(struct parisc_device *dev)
  {
- 	cleanup_one_si(dev_get_drvdata(&dev->dev));
- 	return 0;
+ 	return ipmi_si_remove_by_dev(&pdev->dev);
  }
  
 -static const struct parisc_device_id ipmi_parisc_tbl[] __initconst = {
 +static const struct parisc_device_id ipmi_parisc_tbl[] = {
  	{ HPHW_MC, HVERSION_REV_ANY_ID, 0x004, 0xC0 },
  	{ 0, }
  };
@@@ -3432,11 -3284,27 +3672,30 @@@ static struct smi_info *find_dup_si(str
  	return NULL;
  }
  
- int ipmi_si_add_smi(struct smi_info *new_smi)
+ int ipmi_si_add_smi(struct si_sm_io *io)
  {
  	int rv = 0;
- 	struct smi_info *dup;
+ 	struct smi_info *new_smi, *dup;
+ 
++<<<<<<< HEAD
++=======
+ 	if (!io->io_setup) {
+ 		if (io->addr_type == IPMI_IO_ADDR_SPACE) {
+ 			io->io_setup = port_setup;
+ 		} else if (io->addr_type == IPMI_MEM_ADDR_SPACE) {
+ 			io->io_setup = mem_setup;
+ 		} else {
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	new_smi = smi_info_alloc();
+ 	if (!new_smi)
+ 		return -ENOMEM;
  
+ 	new_smi->io = *io;
+ 
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  	mutex_lock(&smi_infos_lock);
  	dup = find_dup_si(new_smi);
  	if (dup) {
@@@ -3731,18 -3600,7 +3998,17 @@@ static int init_ipmi_si(void
  
  	if (initialized)
  		return 0;
- 	initialized = 1;
  
 +	/* RHEL7-only - Init ipmi_shadow_smi_handlers
 +	 * The instance of struct ipmi_shadow_smi_handlers is located in
 +	 * ipmi_msghandler.c. Locating it in this file would cause a
 +	 * module dependency loop, because ipmi_msghandler would then
 +	 * depend on ipmi_si, which already depends on ipmi_msghandler.
 +	 */
 +	shadow_handlers = ipmi_get_shadow_smi_handlers();
 +	shadow_handlers->handlers = &handlers;
 +	shadow_handlers->set_need_watch = set_need_watch;
 +
  	if (si_tryplatform) {
  		rv = platform_driver_register(&ipmi_driver);
  		if (rv) {
@@@ -3860,9 -3719,6 +4127,12 @@@ static void cleanup_one_si(struct smi_i
  		}
  	}
  
++<<<<<<< HEAD
 +	if (to_clean->dev)
 +		dev_set_drvdata(to_clean->dev, NULL);
 +
++=======
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  	list_del(&to_clean->link);
  
  	/*
diff --cc drivers/char/ipmi/ipmi_si_sm.h
index a705027c0493,fbf5bfccde2e..000000000000
--- a/drivers/char/ipmi/ipmi_si_sm.h
+++ b/drivers/char/ipmi/ipmi_si_sm.h
@@@ -61,6 -67,23 +61,26 @@@ struct si_sm_io 
  	int  regshift;
  	int addr_type;
  	long addr_data;
++<<<<<<< HEAD
++=======
+ 	enum ipmi_addr_src addr_source; /* ACPI, PCI, SMBIOS, hardcode, etc. */
+ 	void (*addr_source_cleanup)(struct si_sm_io *io);
+ 	void *addr_source_data;
+ 	union ipmi_smi_info_union addr_info;
+ 
+ 	int (*io_setup)(struct si_sm_io *info);
+ 	void (*io_cleanup)(struct si_sm_io *info);
+ 	unsigned int io_size;
+ 
+ 	int irq;
+ 	int (*irq_setup)(struct si_sm_io *io);
+ 	void *irq_handler_data;
+ 	void (*irq_cleanup)(struct si_sm_io *io);
+ 
+ 	u8 slave_addr;
+ 	enum si_type si_type;
+ 	struct device *dev;
++>>>>>>> bb398a4cb09a (ipmi_si: Change ipmi_si_add_smi() to take just I/O info)
  };
  
  /* Results of SMI events. */
* Unmerged path drivers/char/ipmi/ipmi_si.h
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
* Unmerged path drivers/char/ipmi/ipmi_si_sm.h
