tcmu: Skip Data-Out blocks before gathering Data-In buffer for BIDI case

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Xiubo Li <lixiubo@cmss.chinamobile.com>
commit a5d68ba85801a78c892a0eb8efb711e293ed314b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/a5d68ba8.failed

For the bidirectional case, the Data-Out buffer blocks will always at
the head of the tcmu_cmd's bitmap, and before gathering the Data-In
buffer, first of all it should skip the Data-Out ones, or the device
supporting BIDI commands won't work.

Fixed: 26418649eead ("target/user: Introduce data_bitmap, replace
		data_length/data_head/data_tail")
	Reported-by: Ilias Tsitsimpis <iliastsi@arrikto.com>
	Tested-by: Ilias Tsitsimpis <iliastsi@arrikto.com>
	Signed-off-by: Xiubo Li <lixiubo@cmss.chinamobile.com>
	Cc: stable@vger.kernel.org # 4.6+
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit a5d68ba85801a78c892a0eb8efb711e293ed314b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_user.c
diff --cc drivers/target/target_core_user.c
index 2ac4515b6a67,f615c3bbb73e..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -478,12 -308,13 +478,13 @@@ static void alloc_and_scatter_data_area
  static void free_data_area(struct tcmu_dev *udev, struct tcmu_cmd *cmd)
  {
  	bitmap_xor(udev->data_bitmap, udev->data_bitmap, cmd->data_bitmap,
 -		   DATA_BLOCK_BITS);
 +		   udev->max_blocks);
  }
  
- static void gather_data_area(struct tcmu_dev *udev, unsigned long *cmd_bitmap,
- 		struct scatterlist *data_sg, unsigned int data_nents)
+ static void gather_data_area(struct tcmu_dev *udev, struct tcmu_cmd *cmd,
+ 			     bool bidi)
  {
+ 	struct se_cmd *se_cmd = cmd->se_cmd;
  	int i, block;
  	int block_remaining = 0;
  	void *from, *to;
@@@ -495,11 -351,10 +521,18 @@@
  		to = kmap_atomic(sg_page(sg)) + sg->offset;
  		while (sg_remaining > 0) {
  			if (block_remaining == 0) {
++<<<<<<< HEAD
 +				block = find_first_bit(cmd_bitmap,
 +						       udev->max_blocks);
 +				block_remaining = DATA_BLOCK_SIZE;
 +				clear_bit(block, udev->data_bitmap);
 +				clear_bit(block, cmd_bitmap);
++=======
+ 				block = find_first_bit(bitmap,
+ 						DATA_BLOCK_BITS);
+ 				block_remaining = DATA_BLOCK_SIZE;
+ 				clear_bit(block, bitmap);
++>>>>>>> a5d68ba85801 (tcmu: Skip Data-Out blocks before gathering Data-In buffer for BIDI case)
  			}
  			copy_bytes = min_t(size_t, sg_remaining,
  					block_remaining);
@@@ -799,11 -637,11 +832,19 @@@ static void tcmu_handle_completion(stru
  		free_data_area(udev, cmd);
  	} else if (se_cmd->se_cmd_flags & SCF_BIDI) {
  		/* Get Data-In buffer before clean up */
++<<<<<<< HEAD
 +		gather_data_area(udev, cmd->data_bitmap,
 +			se_cmd->t_bidi_data_sg, se_cmd->t_bidi_data_nents);
 +	} else if (se_cmd->data_direction == DMA_FROM_DEVICE) {
 +		gather_data_area(udev, cmd->data_bitmap,
 +			se_cmd->t_data_sg, se_cmd->t_data_nents);
++=======
+ 		gather_data_area(udev, cmd, true);
+ 		free_data_area(udev, cmd);
+ 	} else if (se_cmd->data_direction == DMA_FROM_DEVICE) {
+ 		gather_data_area(udev, cmd, false);
+ 		free_data_area(udev, cmd);
++>>>>>>> a5d68ba85801 (tcmu: Skip Data-Out blocks before gathering Data-In buffer for BIDI case)
  	} else if (se_cmd->data_direction == DMA_TO_DEVICE) {
  		free_data_area(udev, cmd);
  	} else if (se_cmd->data_direction != DMA_NONE) {
* Unmerged path drivers/target/target_core_user.c
