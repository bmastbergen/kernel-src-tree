ext4: factor out helper ext4_sample_last_mounted()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 833a950882d33a7dfc319d5e152fdf35028936eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/833a9508.failed

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Reviewed-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 833a950882d33a7dfc319d5e152fdf35028936eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/file.c
diff --cc fs/ext4/file.c
index feb7f54458b2,c48ea76b63e4..000000000000
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@@ -383,46 -381,65 +383,101 @@@ static int ext4_file_mmap(struct file *
  	return 0;
  }
  
- static int ext4_file_open(struct inode * inode, struct file * filp)
+ static int ext4_sample_last_mounted(struct super_block *sb,
+ 				    struct vfsmount *mnt)
  {
- 	struct super_block *sb = inode->i_sb;
- 	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
- 	struct vfsmount *mnt = filp->f_path.mnt;
+ 	struct ext4_sb_info *sbi = EXT4_SB(sb);
  	struct path path;
  	char buf[64], *cp;
++<<<<<<< HEAD
 +
 +	if (unlikely(!(sbi->s_mount_flags & EXT4_MF_MNTDIR_SAMPLED) &&
 +		     !(sb->s_flags & MS_RDONLY))) {
 +		sbi->s_mount_flags |= EXT4_MF_MNTDIR_SAMPLED;
 +		/*
 +		 * Sample where the filesystem has been mounted and
 +		 * store it in the superblock for sysadmin convenience
 +		 * when trying to sort through large numbers of block
 +		 * devices or filesystem images.
 +		 */
 +		memset(buf, 0, sizeof(buf));
 +		path.mnt = mnt;
 +		path.dentry = mnt->mnt_root;
 +		cp = d_path(&path, buf, sizeof(buf));
 +		if (!IS_ERR(cp)) {
 +			handle_t *handle;
 +			int err;
 +
 +			handle = ext4_journal_start_sb(sb, EXT4_HT_MISC, 1);
 +			if (IS_ERR(handle))
 +				return PTR_ERR(handle);
 +			BUFFER_TRACE(sbi->s_sbh, "get_write_access");
 +			err = ext4_journal_get_write_access(handle, sbi->s_sbh);
 +			if (err) {
 +				ext4_journal_stop(handle);
 +				return err;
 +			}
 +			strlcpy(sbi->s_es->s_last_mounted, cp,
 +				sizeof(sbi->s_es->s_last_mounted));
 +			ext4_handle_dirty_super(handle, sb);
 +			ext4_journal_stop(handle);
 +		}
 +	}
++=======
+ 	handle_t *handle;
+ 	int err;
+ 
+ 	if (likely(sbi->s_mount_flags & EXT4_MF_MNTDIR_SAMPLED))
+ 		return 0;
+ 
+ 	if (sb_rdonly(sb))
+ 		return 0;
+ 
+ 	sbi->s_mount_flags |= EXT4_MF_MNTDIR_SAMPLED;
+ 	/*
+ 	 * Sample where the filesystem has been mounted and
+ 	 * store it in the superblock for sysadmin convenience
+ 	 * when trying to sort through large numbers of block
+ 	 * devices or filesystem images.
+ 	 */
+ 	memset(buf, 0, sizeof(buf));
+ 	path.mnt = mnt;
+ 	path.dentry = mnt->mnt_root;
+ 	cp = d_path(&path, buf, sizeof(buf));
+ 	if (IS_ERR(cp))
+ 		return 0;
+ 
+ 	handle = ext4_journal_start_sb(sb, EXT4_HT_MISC, 1);
+ 	if (IS_ERR(handle))
+ 		return PTR_ERR(handle);
+ 	BUFFER_TRACE(sbi->s_sbh, "get_write_access");
+ 	err = ext4_journal_get_write_access(handle, sbi->s_sbh);
+ 	if (err)
+ 		goto out;
+ 	strlcpy(sbi->s_es->s_last_mounted, cp,
+ 		sizeof(sbi->s_es->s_last_mounted));
+ 	ext4_handle_dirty_super(handle, sb);
+ out:
+ 	ext4_journal_stop(handle);
+ 	return err;
+ }
+ 
+ static int ext4_file_open(struct inode * inode, struct file * filp)
+ {
+ 	int ret;
+ 
+ 	if (unlikely(ext4_forced_shutdown(EXT4_SB(inode->i_sb))))
+ 		return -EIO;
+ 
+ 	ret = ext4_sample_last_mounted(inode->i_sb, filp->f_path.mnt);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = fscrypt_file_open(inode, filp);
+ 	if (ret)
+ 		return ret;
+ 
++>>>>>>> 833a950882d3 (ext4: factor out helper ext4_sample_last_mounted())
  	/*
  	 * Set up the jbd2_inode if we are opening the inode for
  	 * writing and the journal is present
* Unmerged path fs/ext4/file.c
