bpf: BPF for lightweight tunnel infrastructure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Thomas Graf <tgraf@suug.ch>
commit 3a0af8fd61f90920f6fa04e4f1e9a6a73c1b4fd2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3a0af8fd.failed

Registers new BPF program types which correspond to the LWT hooks:
  - BPF_PROG_TYPE_LWT_IN   => dst_input()
  - BPF_PROG_TYPE_LWT_OUT  => dst_output()
  - BPF_PROG_TYPE_LWT_XMIT => lwtunnel_xmit()

The separate program types are required to differentiate between the
capabilities each LWT hook allows:

 * Programs attached to dst_input() or dst_output() are restricted and
   may only read the data of an skb. This prevent modification and
   possible invalidation of already validated packet headers on receive
   and the construction of illegal headers while the IP headers are
   still being assembled.

 * Programs attached to lwtunnel_xmit() are allowed to modify packet
   content as well as prepending an L2 header via a newly introduced
   helper bpf_skb_change_head(). This is safe as lwtunnel_xmit() is
   invoked after the IP header has been assembled completely.

All BPF programs receive an skb with L3 headers attached and may return
one of the following error codes:

 BPF_OK - Continue routing as per nexthop
 BPF_DROP - Drop skb and return EPERM
 BPF_REDIRECT - Redirect skb to device as per redirect() helper.
                (Only valid in lwtunnel_xmit() context)

The return codes are binary compatible with their TC_ACT_
relatives to ease compatibility.

	Signed-off-by: Thomas Graf <tgraf@suug.ch>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Daniel Borkmann <daniel@iogearbox.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3a0af8fd61f90920f6fa04e4f1e9a6a73c1b4fd2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	include/uapi/linux/lwtunnel.h
#	kernel/bpf/verifier.c
#	net/core/filter.c
#	net/core/lwtunnel.c
diff --cc include/uapi/linux/bpf.h
index e369860b690e,22ac82792687..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -115,8 -93,43 +115,22 @@@ enum bpf_map_type 
  
  enum bpf_prog_type {
  	BPF_PROG_TYPE_UNSPEC,
++<<<<<<< HEAD
++=======
+ 	BPF_PROG_TYPE_SOCKET_FILTER,
+ 	BPF_PROG_TYPE_KPROBE,
+ 	BPF_PROG_TYPE_SCHED_CLS,
+ 	BPF_PROG_TYPE_SCHED_ACT,
+ 	BPF_PROG_TYPE_TRACEPOINT,
+ 	BPF_PROG_TYPE_XDP,
+ 	BPF_PROG_TYPE_PERF_EVENT,
+ 	BPF_PROG_TYPE_CGROUP_SKB,
+ 	BPF_PROG_TYPE_LWT_IN,
+ 	BPF_PROG_TYPE_LWT_OUT,
+ 	BPF_PROG_TYPE_LWT_XMIT,
++>>>>>>> 3a0af8fd61f9 (bpf: BPF for lightweight tunnel infrastructure)
  };
  
 -enum bpf_attach_type {
 -	BPF_CGROUP_INET_INGRESS,
 -	BPF_CGROUP_INET_EGRESS,
 -	__MAX_BPF_ATTACH_TYPE
 -};
 -
 -#define MAX_BPF_ATTACH_TYPE __MAX_BPF_ATTACH_TYPE
 -
 -#define BPF_PSEUDO_MAP_FD	1
 -
 -/* flags for BPF_MAP_UPDATE_ELEM command */
 -#define BPF_ANY		0 /* create new element or update existing */
 -#define BPF_NOEXIST	1 /* create new element if it didn't exist */
 -#define BPF_EXIST	2 /* update existing element */
 -
 -#define BPF_F_NO_PREALLOC	(1U << 0)
 -/* Instead of having one common LRU list in the
 - * BPF_MAP_TYPE_LRU_[PERCPU_]HASH map, use a percpu LRU list
 - * which can scale and perform better.
 - * Note, the LRU nodes (including free nodes) cannot be moved
 - * across different LRU lists.
 - */
 -#define BPF_F_NO_COMMON_LRU	(1U << 1)
 -
  union bpf_attr {
  	struct { /* anonymous struct used by BPF_MAP_CREATE command */
  		__u32	map_type;	/* one of enum bpf_map_type */
@@@ -135,6 -149,424 +149,404 @@@
  	};
  } __attribute__((aligned(8)));
  
++<<<<<<< HEAD
++=======
+ /* BPF helper function descriptions:
+  *
+  * void *bpf_map_lookup_elem(&map, &key)
+  *     Return: Map value or NULL
+  *
+  * int bpf_map_update_elem(&map, &key, &value, flags)
+  *     Return: 0 on success or negative error
+  *
+  * int bpf_map_delete_elem(&map, &key)
+  *     Return: 0 on success or negative error
+  *
+  * int bpf_probe_read(void *dst, int size, void *src)
+  *     Return: 0 on success or negative error
+  *
+  * u64 bpf_ktime_get_ns(void)
+  *     Return: current ktime
+  *
+  * int bpf_trace_printk(const char *fmt, int fmt_size, ...)
+  *     Return: length of buffer written or negative error
+  *
+  * u32 bpf_prandom_u32(void)
+  *     Return: random value
+  *
+  * u32 bpf_raw_smp_processor_id(void)
+  *     Return: SMP processor ID
+  *
+  * int bpf_skb_store_bytes(skb, offset, from, len, flags)
+  *     store bytes into packet
+  *     @skb: pointer to skb
+  *     @offset: offset within packet from skb->mac_header
+  *     @from: pointer where to copy bytes from
+  *     @len: number of bytes to store into packet
+  *     @flags: bit 0 - if true, recompute skb->csum
+  *             other bits - reserved
+  *     Return: 0 on success or negative error
+  *
+  * int bpf_l3_csum_replace(skb, offset, from, to, flags)
+  *     recompute IP checksum
+  *     @skb: pointer to skb
+  *     @offset: offset within packet where IP checksum is located
+  *     @from: old value of header field
+  *     @to: new value of header field
+  *     @flags: bits 0-3 - size of header field
+  *             other bits - reserved
+  *     Return: 0 on success or negative error
+  *
+  * int bpf_l4_csum_replace(skb, offset, from, to, flags)
+  *     recompute TCP/UDP checksum
+  *     @skb: pointer to skb
+  *     @offset: offset within packet where TCP/UDP checksum is located
+  *     @from: old value of header field
+  *     @to: new value of header field
+  *     @flags: bits 0-3 - size of header field
+  *             bit 4 - is pseudo header
+  *             other bits - reserved
+  *     Return: 0 on success or negative error
+  *
+  * int bpf_tail_call(ctx, prog_array_map, index)
+  *     jump into another BPF program
+  *     @ctx: context pointer passed to next program
+  *     @prog_array_map: pointer to map which type is BPF_MAP_TYPE_PROG_ARRAY
+  *     @index: index inside array that selects specific program to run
+  *     Return: 0 on success or negative error
+  *
+  * int bpf_clone_redirect(skb, ifindex, flags)
+  *     redirect to another netdev
+  *     @skb: pointer to skb
+  *     @ifindex: ifindex of the net device
+  *     @flags: bit 0 - if set, redirect to ingress instead of egress
+  *             other bits - reserved
+  *     Return: 0 on success or negative error
+  *
+  * u64 bpf_get_current_pid_tgid(void)
+  *     Return: current->tgid << 32 | current->pid
+  *
+  * u64 bpf_get_current_uid_gid(void)
+  *     Return: current_gid << 32 | current_uid
+  *
+  * int bpf_get_current_comm(char *buf, int size_of_buf)
+  *     stores current->comm into buf
+  *     Return: 0 on success or negative error
+  *
+  * u32 bpf_get_cgroup_classid(skb)
+  *     retrieve a proc's classid
+  *     @skb: pointer to skb
+  *     Return: classid if != 0
+  *
+  * int bpf_skb_vlan_push(skb, vlan_proto, vlan_tci)
+  *     Return: 0 on success or negative error
+  *
+  * int bpf_skb_vlan_pop(skb)
+  *     Return: 0 on success or negative error
+  *
+  * int bpf_skb_get_tunnel_key(skb, key, size, flags)
+  * int bpf_skb_set_tunnel_key(skb, key, size, flags)
+  *     retrieve or populate tunnel metadata
+  *     @skb: pointer to skb
+  *     @key: pointer to 'struct bpf_tunnel_key'
+  *     @size: size of 'struct bpf_tunnel_key'
+  *     @flags: room for future extensions
+  *     Return: 0 on success or negative error
+  *
+  * u64 bpf_perf_event_read(&map, index)
+  *     Return: Number events read or error code
+  *
+  * int bpf_redirect(ifindex, flags)
+  *     redirect to another netdev
+  *     @ifindex: ifindex of the net device
+  *     @flags: bit 0 - if set, redirect to ingress instead of egress
+  *             other bits - reserved
+  *     Return: TC_ACT_REDIRECT
+  *
+  * u32 bpf_get_route_realm(skb)
+  *     retrieve a dst's tclassid
+  *     @skb: pointer to skb
+  *     Return: realm if != 0
+  *
+  * int bpf_perf_event_output(ctx, map, index, data, size)
+  *     output perf raw sample
+  *     @ctx: struct pt_regs*
+  *     @map: pointer to perf_event_array map
+  *     @index: index of event in the map
+  *     @data: data on stack to be output as raw data
+  *     @size: size of data
+  *     Return: 0 on success or negative error
+  *
+  * int bpf_get_stackid(ctx, map, flags)
+  *     walk user or kernel stack and return id
+  *     @ctx: struct pt_regs*
+  *     @map: pointer to stack_trace map
+  *     @flags: bits 0-7 - numer of stack frames to skip
+  *             bit 8 - collect user stack instead of kernel
+  *             bit 9 - compare stacks by hash only
+  *             bit 10 - if two different stacks hash into the same stackid
+  *                      discard old
+  *             other bits - reserved
+  *     Return: >= 0 stackid on success or negative error
+  *
+  * s64 bpf_csum_diff(from, from_size, to, to_size, seed)
+  *     calculate csum diff
+  *     @from: raw from buffer
+  *     @from_size: length of from buffer
+  *     @to: raw to buffer
+  *     @to_size: length of to buffer
+  *     @seed: optional seed
+  *     Return: csum result or negative error code
+  *
+  * int bpf_skb_get_tunnel_opt(skb, opt, size)
+  *     retrieve tunnel options metadata
+  *     @skb: pointer to skb
+  *     @opt: pointer to raw tunnel option data
+  *     @size: size of @opt
+  *     Return: option size
+  *
+  * int bpf_skb_set_tunnel_opt(skb, opt, size)
+  *     populate tunnel options metadata
+  *     @skb: pointer to skb
+  *     @opt: pointer to raw tunnel option data
+  *     @size: size of @opt
+  *     Return: 0 on success or negative error
+  *
+  * int bpf_skb_change_proto(skb, proto, flags)
+  *     Change protocol of the skb. Currently supported is v4 -> v6,
+  *     v6 -> v4 transitions. The helper will also resize the skb. eBPF
+  *     program is expected to fill the new headers via skb_store_bytes
+  *     and lX_csum_replace.
+  *     @skb: pointer to skb
+  *     @proto: new skb->protocol type
+  *     @flags: reserved
+  *     Return: 0 on success or negative error
+  *
+  * int bpf_skb_change_type(skb, type)
+  *     Change packet type of skb.
+  *     @skb: pointer to skb
+  *     @type: new skb->pkt_type type
+  *     Return: 0 on success or negative error
+  *
+  * int bpf_skb_under_cgroup(skb, map, index)
+  *     Check cgroup2 membership of skb
+  *     @skb: pointer to skb
+  *     @map: pointer to bpf_map in BPF_MAP_TYPE_CGROUP_ARRAY type
+  *     @index: index of the cgroup in the bpf_map
+  *     Return:
+  *       == 0 skb failed the cgroup2 descendant test
+  *       == 1 skb succeeded the cgroup2 descendant test
+  *        < 0 error
+  *
+  * u32 bpf_get_hash_recalc(skb)
+  *     Retrieve and possibly recalculate skb->hash.
+  *     @skb: pointer to skb
+  *     Return: hash
+  *
+  * u64 bpf_get_current_task(void)
+  *     Returns current task_struct
+  *     Return: current
+  *
+  * int bpf_probe_write_user(void *dst, void *src, int len)
+  *     safely attempt to write to a location
+  *     @dst: destination address in userspace
+  *     @src: source address on stack
+  *     @len: number of bytes to copy
+  *     Return: 0 on success or negative error
+  *
+  * int bpf_current_task_under_cgroup(map, index)
+  *     Check cgroup2 membership of current task
+  *     @map: pointer to bpf_map in BPF_MAP_TYPE_CGROUP_ARRAY type
+  *     @index: index of the cgroup in the bpf_map
+  *     Return:
+  *       == 0 current failed the cgroup2 descendant test
+  *       == 1 current succeeded the cgroup2 descendant test
+  *        < 0 error
+  *
+  * int bpf_skb_change_tail(skb, len, flags)
+  *     The helper will resize the skb to the given new size, to be used f.e.
+  *     with control messages.
+  *     @skb: pointer to skb
+  *     @len: new skb length
+  *     @flags: reserved
+  *     Return: 0 on success or negative error
+  *
+  * int bpf_skb_pull_data(skb, len)
+  *     The helper will pull in non-linear data in case the skb is non-linear
+  *     and not all of len are part of the linear section. Only needed for
+  *     read/write with direct packet access.
+  *     @skb: pointer to skb
+  *     @len: len to make read/writeable
+  *     Return: 0 on success or negative error
+  *
+  * s64 bpf_csum_update(skb, csum)
+  *     Adds csum into skb->csum in case of CHECKSUM_COMPLETE.
+  *     @skb: pointer to skb
+  *     @csum: csum to add
+  *     Return: csum on success or negative error
+  *
+  * void bpf_set_hash_invalid(skb)
+  *     Invalidate current skb->hash.
+  *     @skb: pointer to skb
+  *
+  * int bpf_get_numa_node_id()
+  *     Return: Id of current NUMA node.
+  *
+  * int bpf_skb_change_head()
+  *     Grows headroom of skb and adjusts MAC header offset accordingly.
+  *     Will extends/reallocae as required automatically.
+  *     May change skb data pointer and will thus invalidate any check
+  *     performed for direct packet access.
+  *     @skb: pointer to skb
+  *     @len: length of header to be pushed in front
+  *     @flags: Flags (unused for now)
+  *     Return: 0 on success or negative error
+  */
+ #define __BPF_FUNC_MAPPER(FN)		\
+ 	FN(unspec),			\
+ 	FN(map_lookup_elem),		\
+ 	FN(map_update_elem),		\
+ 	FN(map_delete_elem),		\
+ 	FN(probe_read),			\
+ 	FN(ktime_get_ns),		\
+ 	FN(trace_printk),		\
+ 	FN(get_prandom_u32),		\
+ 	FN(get_smp_processor_id),	\
+ 	FN(skb_store_bytes),		\
+ 	FN(l3_csum_replace),		\
+ 	FN(l4_csum_replace),		\
+ 	FN(tail_call),			\
+ 	FN(clone_redirect),		\
+ 	FN(get_current_pid_tgid),	\
+ 	FN(get_current_uid_gid),	\
+ 	FN(get_current_comm),		\
+ 	FN(get_cgroup_classid),		\
+ 	FN(skb_vlan_push),		\
+ 	FN(skb_vlan_pop),		\
+ 	FN(skb_get_tunnel_key),		\
+ 	FN(skb_set_tunnel_key),		\
+ 	FN(perf_event_read),		\
+ 	FN(redirect),			\
+ 	FN(get_route_realm),		\
+ 	FN(perf_event_output),		\
+ 	FN(skb_load_bytes),		\
+ 	FN(get_stackid),		\
+ 	FN(csum_diff),			\
+ 	FN(skb_get_tunnel_opt),		\
+ 	FN(skb_set_tunnel_opt),		\
+ 	FN(skb_change_proto),		\
+ 	FN(skb_change_type),		\
+ 	FN(skb_under_cgroup),		\
+ 	FN(get_hash_recalc),		\
+ 	FN(get_current_task),		\
+ 	FN(probe_write_user),		\
+ 	FN(current_task_under_cgroup),	\
+ 	FN(skb_change_tail),		\
+ 	FN(skb_pull_data),		\
+ 	FN(csum_update),		\
+ 	FN(set_hash_invalid),		\
+ 	FN(get_numa_node_id),		\
+ 	FN(skb_change_head),
+ 
+ /* integer value in 'imm' field of BPF_CALL instruction selects which helper
+  * function eBPF program intends to call
+  */
+ #define __BPF_ENUM_FN(x) BPF_FUNC_ ## x
+ enum bpf_func_id {
+ 	__BPF_FUNC_MAPPER(__BPF_ENUM_FN)
+ 	__BPF_FUNC_MAX_ID,
+ };
+ #undef __BPF_ENUM_FN
+ 
+ /* All flags used by eBPF helper functions, placed here. */
+ 
+ /* BPF_FUNC_skb_store_bytes flags. */
+ #define BPF_F_RECOMPUTE_CSUM		(1ULL << 0)
+ #define BPF_F_INVALIDATE_HASH		(1ULL << 1)
+ 
+ /* BPF_FUNC_l3_csum_replace and BPF_FUNC_l4_csum_replace flags.
+  * First 4 bits are for passing the header field size.
+  */
+ #define BPF_F_HDR_FIELD_MASK		0xfULL
+ 
+ /* BPF_FUNC_l4_csum_replace flags. */
+ #define BPF_F_PSEUDO_HDR		(1ULL << 4)
+ #define BPF_F_MARK_MANGLED_0		(1ULL << 5)
+ 
+ /* BPF_FUNC_clone_redirect and BPF_FUNC_redirect flags. */
+ #define BPF_F_INGRESS			(1ULL << 0)
+ 
+ /* BPF_FUNC_skb_set_tunnel_key and BPF_FUNC_skb_get_tunnel_key flags. */
+ #define BPF_F_TUNINFO_IPV6		(1ULL << 0)
+ 
+ /* BPF_FUNC_get_stackid flags. */
+ #define BPF_F_SKIP_FIELD_MASK		0xffULL
+ #define BPF_F_USER_STACK		(1ULL << 8)
+ #define BPF_F_FAST_STACK_CMP		(1ULL << 9)
+ #define BPF_F_REUSE_STACKID		(1ULL << 10)
+ 
+ /* BPF_FUNC_skb_set_tunnel_key flags. */
+ #define BPF_F_ZERO_CSUM_TX		(1ULL << 1)
+ #define BPF_F_DONT_FRAGMENT		(1ULL << 2)
+ 
+ /* BPF_FUNC_perf_event_output and BPF_FUNC_perf_event_read flags. */
+ #define BPF_F_INDEX_MASK		0xffffffffULL
+ #define BPF_F_CURRENT_CPU		BPF_F_INDEX_MASK
+ /* BPF_FUNC_perf_event_output for sk_buff input context. */
+ #define BPF_F_CTXLEN_MASK		(0xfffffULL << 32)
+ 
+ /* user accessible mirror of in-kernel sk_buff.
+  * new fields can only be added to the end of this structure
+  */
+ struct __sk_buff {
+ 	__u32 len;
+ 	__u32 pkt_type;
+ 	__u32 mark;
+ 	__u32 queue_mapping;
+ 	__u32 protocol;
+ 	__u32 vlan_present;
+ 	__u32 vlan_tci;
+ 	__u32 vlan_proto;
+ 	__u32 priority;
+ 	__u32 ingress_ifindex;
+ 	__u32 ifindex;
+ 	__u32 tc_index;
+ 	__u32 cb[5];
+ 	__u32 hash;
+ 	__u32 tc_classid;
+ 	__u32 data;
+ 	__u32 data_end;
+ };
+ 
+ struct bpf_tunnel_key {
+ 	__u32 tunnel_id;
+ 	union {
+ 		__u32 remote_ipv4;
+ 		__u32 remote_ipv6[4];
+ 	};
+ 	__u8 tunnel_tos;
+ 	__u8 tunnel_ttl;
+ 	__u16 tunnel_ext;
+ 	__u32 tunnel_label;
+ };
+ 
+ /* Generic BPF return codes which all BPF program types may support.
+  * The values are binary compatible with their TC_ACT_* counter-part to
+  * provide backwards compatibility with existing SCHED_CLS and SCHED_ACT
+  * programs.
+  *
+  * XDP is handled seprately, see XDP_*.
+  */
+ enum bpf_ret_code {
+ 	BPF_OK = 0,
+ 	/* 1 reserved */
+ 	BPF_DROP = 2,
+ 	/* 3-6 reserved */
+ 	BPF_REDIRECT = 7,
+ 	/* >127 are reserved for prog type specific return codes */
+ };
+ 
++>>>>>>> 3a0af8fd61f9 (bpf: BPF for lightweight tunnel infrastructure)
  /* User return codes for XDP prog type.
   * A valid XDP program must return one of these defined values. All other
   * return codes are reserved for future use. Unknown return codes will result
diff --cc include/uapi/linux/lwtunnel.h
index bbfef5378d58,92724cba1eba..000000000000
--- a/include/uapi/linux/lwtunnel.h
+++ b/include/uapi/linux/lwtunnel.h
@@@ -5,10 -5,12 +5,15 @@@
  
  enum lwtunnel_encap_types {
  	LWTUNNEL_ENCAP_NONE,
 -	LWTUNNEL_ENCAP_MPLS,
 +	__RH_RESERVED_LWTUNNEL_ENCAP_MPLS,
  	LWTUNNEL_ENCAP_IP,
 -	LWTUNNEL_ENCAP_ILA,
 +	__RH_RESERVED_LWTUNNEL_ENCAP_ILA,
  	LWTUNNEL_ENCAP_IP6,
++<<<<<<< HEAD
++=======
+ 	LWTUNNEL_ENCAP_SEG6,
+ 	LWTUNNEL_ENCAP_BPF,
++>>>>>>> 3a0af8fd61f9 (bpf: BPF for lightweight tunnel infrastructure)
  	__LWTUNNEL_ENCAP_MAX,
  };
  
diff --cc net/core/filter.c
index 060ed5f86613,1c4d0faf22c8..000000000000
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@@ -763,6 -1284,1939 +763,1942 @@@ int sk_attach_filter(struct sock_fprog 
  }
  EXPORT_SYMBOL_GPL(sk_attach_filter);
  
++<<<<<<< HEAD
++=======
+ int sk_reuseport_attach_filter(struct sock_fprog *fprog, struct sock *sk)
+ {
+ 	struct bpf_prog *prog = __get_filter(fprog, sk);
+ 	int err;
+ 
+ 	if (IS_ERR(prog))
+ 		return PTR_ERR(prog);
+ 
+ 	err = __reuseport_attach_prog(prog, sk);
+ 	if (err < 0) {
+ 		__bpf_prog_release(prog);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static struct bpf_prog *__get_bpf(u32 ufd, struct sock *sk)
+ {
+ 	if (sock_flag(sk, SOCK_FILTER_LOCKED))
+ 		return ERR_PTR(-EPERM);
+ 
+ 	return bpf_prog_get_type(ufd, BPF_PROG_TYPE_SOCKET_FILTER);
+ }
+ 
+ int sk_attach_bpf(u32 ufd, struct sock *sk)
+ {
+ 	struct bpf_prog *prog = __get_bpf(ufd, sk);
+ 	int err;
+ 
+ 	if (IS_ERR(prog))
+ 		return PTR_ERR(prog);
+ 
+ 	err = __sk_attach_prog(prog, sk);
+ 	if (err < 0) {
+ 		bpf_prog_put(prog);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int sk_reuseport_attach_bpf(u32 ufd, struct sock *sk)
+ {
+ 	struct bpf_prog *prog = __get_bpf(ufd, sk);
+ 	int err;
+ 
+ 	if (IS_ERR(prog))
+ 		return PTR_ERR(prog);
+ 
+ 	err = __reuseport_attach_prog(prog, sk);
+ 	if (err < 0) {
+ 		bpf_prog_put(prog);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ struct bpf_scratchpad {
+ 	union {
+ 		__be32 diff[MAX_BPF_STACK / sizeof(__be32)];
+ 		u8     buff[MAX_BPF_STACK];
+ 	};
+ };
+ 
+ static DEFINE_PER_CPU(struct bpf_scratchpad, bpf_sp);
+ 
+ static inline int __bpf_try_make_writable(struct sk_buff *skb,
+ 					  unsigned int write_len)
+ {
+ 	return skb_ensure_writable(skb, write_len);
+ }
+ 
+ static inline int bpf_try_make_writable(struct sk_buff *skb,
+ 					unsigned int write_len)
+ {
+ 	int err = __bpf_try_make_writable(skb, write_len);
+ 
+ 	bpf_compute_data_end(skb);
+ 	return err;
+ }
+ 
+ static int bpf_try_make_head_writable(struct sk_buff *skb)
+ {
+ 	return bpf_try_make_writable(skb, skb_headlen(skb));
+ }
+ 
+ static inline void bpf_push_mac_rcsum(struct sk_buff *skb)
+ {
+ 	if (skb_at_tc_ingress(skb))
+ 		skb_postpush_rcsum(skb, skb_mac_header(skb), skb->mac_len);
+ }
+ 
+ static inline void bpf_pull_mac_rcsum(struct sk_buff *skb)
+ {
+ 	if (skb_at_tc_ingress(skb))
+ 		skb_postpull_rcsum(skb, skb_mac_header(skb), skb->mac_len);
+ }
+ 
+ BPF_CALL_5(bpf_skb_store_bytes, struct sk_buff *, skb, u32, offset,
+ 	   const void *, from, u32, len, u64, flags)
+ {
+ 	void *ptr;
+ 
+ 	if (unlikely(flags & ~(BPF_F_RECOMPUTE_CSUM | BPF_F_INVALIDATE_HASH)))
+ 		return -EINVAL;
+ 	if (unlikely(offset > 0xffff))
+ 		return -EFAULT;
+ 	if (unlikely(bpf_try_make_writable(skb, offset + len)))
+ 		return -EFAULT;
+ 
+ 	ptr = skb->data + offset;
+ 	if (flags & BPF_F_RECOMPUTE_CSUM)
+ 		__skb_postpull_rcsum(skb, ptr, len, offset);
+ 
+ 	memcpy(ptr, from, len);
+ 
+ 	if (flags & BPF_F_RECOMPUTE_CSUM)
+ 		__skb_postpush_rcsum(skb, ptr, len, offset);
+ 	if (flags & BPF_F_INVALIDATE_HASH)
+ 		skb_clear_hash(skb);
+ 
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_store_bytes_proto = {
+ 	.func		= bpf_skb_store_bytes,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_PTR_TO_STACK,
+ 	.arg4_type	= ARG_CONST_STACK_SIZE,
+ 	.arg5_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_4(bpf_skb_load_bytes, const struct sk_buff *, skb, u32, offset,
+ 	   void *, to, u32, len)
+ {
+ 	void *ptr;
+ 
+ 	if (unlikely(offset > 0xffff))
+ 		goto err_clear;
+ 
+ 	ptr = skb_header_pointer(skb, offset, len, to);
+ 	if (unlikely(!ptr))
+ 		goto err_clear;
+ 	if (ptr != to)
+ 		memcpy(to, ptr, len);
+ 
+ 	return 0;
+ err_clear:
+ 	memset(to, 0, len);
+ 	return -EFAULT;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_load_bytes_proto = {
+ 	.func		= bpf_skb_load_bytes,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_PTR_TO_RAW_STACK,
+ 	.arg4_type	= ARG_CONST_STACK_SIZE,
+ };
+ 
+ BPF_CALL_2(bpf_skb_pull_data, struct sk_buff *, skb, u32, len)
+ {
+ 	/* Idea is the following: should the needed direct read/write
+ 	 * test fail during runtime, we can pull in more data and redo
+ 	 * again, since implicitly, we invalidate previous checks here.
+ 	 *
+ 	 * Or, since we know how much we need to make read/writeable,
+ 	 * this can be done once at the program beginning for direct
+ 	 * access case. By this we overcome limitations of only current
+ 	 * headroom being accessible.
+ 	 */
+ 	return bpf_try_make_writable(skb, len ? : skb_headlen(skb));
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_pull_data_proto = {
+ 	.func		= bpf_skb_pull_data,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_5(bpf_l3_csum_replace, struct sk_buff *, skb, u32, offset,
+ 	   u64, from, u64, to, u64, flags)
+ {
+ 	__sum16 *ptr;
+ 
+ 	if (unlikely(flags & ~(BPF_F_HDR_FIELD_MASK)))
+ 		return -EINVAL;
+ 	if (unlikely(offset > 0xffff || offset & 1))
+ 		return -EFAULT;
+ 	if (unlikely(bpf_try_make_writable(skb, offset + sizeof(*ptr))))
+ 		return -EFAULT;
+ 
+ 	ptr = (__sum16 *)(skb->data + offset);
+ 	switch (flags & BPF_F_HDR_FIELD_MASK) {
+ 	case 0:
+ 		if (unlikely(from != 0))
+ 			return -EINVAL;
+ 
+ 		csum_replace_by_diff(ptr, to);
+ 		break;
+ 	case 2:
+ 		csum_replace2(ptr, from, to);
+ 		break;
+ 	case 4:
+ 		csum_replace4(ptr, from, to);
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_l3_csum_replace_proto = {
+ 	.func		= bpf_l3_csum_replace,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_ANYTHING,
+ 	.arg4_type	= ARG_ANYTHING,
+ 	.arg5_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_5(bpf_l4_csum_replace, struct sk_buff *, skb, u32, offset,
+ 	   u64, from, u64, to, u64, flags)
+ {
+ 	bool is_pseudo = flags & BPF_F_PSEUDO_HDR;
+ 	bool is_mmzero = flags & BPF_F_MARK_MANGLED_0;
+ 	__sum16 *ptr;
+ 
+ 	if (unlikely(flags & ~(BPF_F_MARK_MANGLED_0 | BPF_F_PSEUDO_HDR |
+ 			       BPF_F_HDR_FIELD_MASK)))
+ 		return -EINVAL;
+ 	if (unlikely(offset > 0xffff || offset & 1))
+ 		return -EFAULT;
+ 	if (unlikely(bpf_try_make_writable(skb, offset + sizeof(*ptr))))
+ 		return -EFAULT;
+ 
+ 	ptr = (__sum16 *)(skb->data + offset);
+ 	if (is_mmzero && !*ptr)
+ 		return 0;
+ 
+ 	switch (flags & BPF_F_HDR_FIELD_MASK) {
+ 	case 0:
+ 		if (unlikely(from != 0))
+ 			return -EINVAL;
+ 
+ 		inet_proto_csum_replace_by_diff(ptr, skb, to, is_pseudo);
+ 		break;
+ 	case 2:
+ 		inet_proto_csum_replace2(ptr, skb, from, to, is_pseudo);
+ 		break;
+ 	case 4:
+ 		inet_proto_csum_replace4(ptr, skb, from, to, is_pseudo);
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (is_mmzero && !*ptr)
+ 		*ptr = CSUM_MANGLED_0;
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_l4_csum_replace_proto = {
+ 	.func		= bpf_l4_csum_replace,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_ANYTHING,
+ 	.arg4_type	= ARG_ANYTHING,
+ 	.arg5_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_5(bpf_csum_diff, __be32 *, from, u32, from_size,
+ 	   __be32 *, to, u32, to_size, __wsum, seed)
+ {
+ 	struct bpf_scratchpad *sp = this_cpu_ptr(&bpf_sp);
+ 	u32 diff_size = from_size + to_size;
+ 	int i, j = 0;
+ 
+ 	/* This is quite flexible, some examples:
+ 	 *
+ 	 * from_size == 0, to_size > 0,  seed := csum --> pushing data
+ 	 * from_size > 0,  to_size == 0, seed := csum --> pulling data
+ 	 * from_size > 0,  to_size > 0,  seed := 0    --> diffing data
+ 	 *
+ 	 * Even for diffing, from_size and to_size don't need to be equal.
+ 	 */
+ 	if (unlikely(((from_size | to_size) & (sizeof(__be32) - 1)) ||
+ 		     diff_size > sizeof(sp->diff)))
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < from_size / sizeof(__be32); i++, j++)
+ 		sp->diff[j] = ~from[i];
+ 	for (i = 0; i <   to_size / sizeof(__be32); i++, j++)
+ 		sp->diff[j] = to[i];
+ 
+ 	return csum_partial(sp->diff, diff_size, seed);
+ }
+ 
+ static const struct bpf_func_proto bpf_csum_diff_proto = {
+ 	.func		= bpf_csum_diff,
+ 	.gpl_only	= false,
+ 	.pkt_access	= true,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_STACK,
+ 	.arg2_type	= ARG_CONST_STACK_SIZE_OR_ZERO,
+ 	.arg3_type	= ARG_PTR_TO_STACK,
+ 	.arg4_type	= ARG_CONST_STACK_SIZE_OR_ZERO,
+ 	.arg5_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_2(bpf_csum_update, struct sk_buff *, skb, __wsum, csum)
+ {
+ 	/* The interface is to be used in combination with bpf_csum_diff()
+ 	 * for direct packet writes. csum rotation for alignment as well
+ 	 * as emulating csum_sub() can be done from the eBPF program.
+ 	 */
+ 	if (skb->ip_summed == CHECKSUM_COMPLETE)
+ 		return (skb->csum = csum_add(skb->csum, csum));
+ 
+ 	return -ENOTSUPP;
+ }
+ 
+ static const struct bpf_func_proto bpf_csum_update_proto = {
+ 	.func		= bpf_csum_update,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ };
+ 
+ static inline int __bpf_rx_skb(struct net_device *dev, struct sk_buff *skb)
+ {
+ 	return dev_forward_skb(dev, skb);
+ }
+ 
+ static inline int __bpf_rx_skb_no_mac(struct net_device *dev,
+ 				      struct sk_buff *skb)
+ {
+ 	int ret = ____dev_forward_skb(dev, skb);
+ 
+ 	if (likely(!ret)) {
+ 		skb->dev = dev;
+ 		ret = netif_rx(skb);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static inline int __bpf_tx_skb(struct net_device *dev, struct sk_buff *skb)
+ {
+ 	int ret;
+ 
+ 	if (unlikely(__this_cpu_read(xmit_recursion) > XMIT_RECURSION_LIMIT)) {
+ 		net_crit_ratelimited("bpf: recursion limit reached on datapath, buggy bpf program?\n");
+ 		kfree_skb(skb);
+ 		return -ENETDOWN;
+ 	}
+ 
+ 	skb->dev = dev;
+ 
+ 	__this_cpu_inc(xmit_recursion);
+ 	ret = dev_queue_xmit(skb);
+ 	__this_cpu_dec(xmit_recursion);
+ 
+ 	return ret;
+ }
+ 
+ static int __bpf_redirect_no_mac(struct sk_buff *skb, struct net_device *dev,
+ 				 u32 flags)
+ {
+ 	/* skb->mac_len is not set on normal egress */
+ 	unsigned int mlen = skb->network_header - skb->mac_header;
+ 
+ 	__skb_pull(skb, mlen);
+ 
+ 	/* At ingress, the mac header has already been pulled once.
+ 	 * At egress, skb_pospull_rcsum has to be done in case that
+ 	 * the skb is originated from ingress (i.e. a forwarded skb)
+ 	 * to ensure that rcsum starts at net header.
+ 	 */
+ 	if (!skb_at_tc_ingress(skb))
+ 		skb_postpull_rcsum(skb, skb_mac_header(skb), mlen);
+ 	skb_pop_mac_header(skb);
+ 	skb_reset_mac_len(skb);
+ 	return flags & BPF_F_INGRESS ?
+ 	       __bpf_rx_skb_no_mac(dev, skb) : __bpf_tx_skb(dev, skb);
+ }
+ 
+ static int __bpf_redirect_common(struct sk_buff *skb, struct net_device *dev,
+ 				 u32 flags)
+ {
+ 	/* Verify that a link layer header is carried */
+ 	if (unlikely(skb->mac_header >= skb->network_header)) {
+ 		kfree_skb(skb);
+ 		return -ERANGE;
+ 	}
+ 
+ 	bpf_push_mac_rcsum(skb);
+ 	return flags & BPF_F_INGRESS ?
+ 	       __bpf_rx_skb(dev, skb) : __bpf_tx_skb(dev, skb);
+ }
+ 
+ static int __bpf_redirect(struct sk_buff *skb, struct net_device *dev,
+ 			  u32 flags)
+ {
+ 	if (dev_is_mac_header_xmit(dev))
+ 		return __bpf_redirect_common(skb, dev, flags);
+ 	else
+ 		return __bpf_redirect_no_mac(skb, dev, flags);
+ }
+ 
+ BPF_CALL_3(bpf_clone_redirect, struct sk_buff *, skb, u32, ifindex, u64, flags)
+ {
+ 	struct net_device *dev;
+ 	struct sk_buff *clone;
+ 	int ret;
+ 
+ 	if (unlikely(flags & ~(BPF_F_INGRESS)))
+ 		return -EINVAL;
+ 
+ 	dev = dev_get_by_index_rcu(dev_net(skb->dev), ifindex);
+ 	if (unlikely(!dev))
+ 		return -EINVAL;
+ 
+ 	clone = skb_clone(skb, GFP_ATOMIC);
+ 	if (unlikely(!clone))
+ 		return -ENOMEM;
+ 
+ 	/* For direct write, we need to keep the invariant that the skbs
+ 	 * we're dealing with need to be uncloned. Should uncloning fail
+ 	 * here, we need to free the just generated clone to unclone once
+ 	 * again.
+ 	 */
+ 	ret = bpf_try_make_head_writable(skb);
+ 	if (unlikely(ret)) {
+ 		kfree_skb(clone);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	return __bpf_redirect(clone, dev, flags);
+ }
+ 
+ static const struct bpf_func_proto bpf_clone_redirect_proto = {
+ 	.func           = bpf_clone_redirect,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type      = ARG_PTR_TO_CTX,
+ 	.arg2_type      = ARG_ANYTHING,
+ 	.arg3_type      = ARG_ANYTHING,
+ };
+ 
+ struct redirect_info {
+ 	u32 ifindex;
+ 	u32 flags;
+ };
+ 
+ static DEFINE_PER_CPU(struct redirect_info, redirect_info);
+ 
+ BPF_CALL_2(bpf_redirect, u32, ifindex, u64, flags)
+ {
+ 	struct redirect_info *ri = this_cpu_ptr(&redirect_info);
+ 
+ 	if (unlikely(flags & ~(BPF_F_INGRESS)))
+ 		return TC_ACT_SHOT;
+ 
+ 	ri->ifindex = ifindex;
+ 	ri->flags = flags;
+ 
+ 	return TC_ACT_REDIRECT;
+ }
+ 
+ int skb_do_redirect(struct sk_buff *skb)
+ {
+ 	struct redirect_info *ri = this_cpu_ptr(&redirect_info);
+ 	struct net_device *dev;
+ 
+ 	dev = dev_get_by_index_rcu(dev_net(skb->dev), ri->ifindex);
+ 	ri->ifindex = 0;
+ 	if (unlikely(!dev)) {
+ 		kfree_skb(skb);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return __bpf_redirect(skb, dev, ri->flags);
+ }
+ 
+ static const struct bpf_func_proto bpf_redirect_proto = {
+ 	.func           = bpf_redirect,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type      = ARG_ANYTHING,
+ 	.arg2_type      = ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_1(bpf_get_cgroup_classid, const struct sk_buff *, skb)
+ {
+ 	return task_get_classid(skb);
+ }
+ 
+ static const struct bpf_func_proto bpf_get_cgroup_classid_proto = {
+ 	.func           = bpf_get_cgroup_classid,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type      = ARG_PTR_TO_CTX,
+ };
+ 
+ BPF_CALL_1(bpf_get_route_realm, const struct sk_buff *, skb)
+ {
+ 	return dst_tclassid(skb);
+ }
+ 
+ static const struct bpf_func_proto bpf_get_route_realm_proto = {
+ 	.func           = bpf_get_route_realm,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type      = ARG_PTR_TO_CTX,
+ };
+ 
+ BPF_CALL_1(bpf_get_hash_recalc, struct sk_buff *, skb)
+ {
+ 	/* If skb_clear_hash() was called due to mangling, we can
+ 	 * trigger SW recalculation here. Later access to hash
+ 	 * can then use the inline skb->hash via context directly
+ 	 * instead of calling this helper again.
+ 	 */
+ 	return skb_get_hash(skb);
+ }
+ 
+ static const struct bpf_func_proto bpf_get_hash_recalc_proto = {
+ 	.func		= bpf_get_hash_recalc,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ };
+ 
+ BPF_CALL_1(bpf_set_hash_invalid, struct sk_buff *, skb)
+ {
+ 	/* After all direct packet write, this can be used once for
+ 	 * triggering a lazy recalc on next skb_get_hash() invocation.
+ 	 */
+ 	skb_clear_hash(skb);
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_set_hash_invalid_proto = {
+ 	.func		= bpf_set_hash_invalid,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ };
+ 
+ BPF_CALL_3(bpf_skb_vlan_push, struct sk_buff *, skb, __be16, vlan_proto,
+ 	   u16, vlan_tci)
+ {
+ 	int ret;
+ 
+ 	if (unlikely(vlan_proto != htons(ETH_P_8021Q) &&
+ 		     vlan_proto != htons(ETH_P_8021AD)))
+ 		vlan_proto = htons(ETH_P_8021Q);
+ 
+ 	bpf_push_mac_rcsum(skb);
+ 	ret = skb_vlan_push(skb, vlan_proto, vlan_tci);
+ 	bpf_pull_mac_rcsum(skb);
+ 
+ 	bpf_compute_data_end(skb);
+ 	return ret;
+ }
+ 
+ const struct bpf_func_proto bpf_skb_vlan_push_proto = {
+ 	.func           = bpf_skb_vlan_push,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type      = ARG_PTR_TO_CTX,
+ 	.arg2_type      = ARG_ANYTHING,
+ 	.arg3_type      = ARG_ANYTHING,
+ };
+ EXPORT_SYMBOL_GPL(bpf_skb_vlan_push_proto);
+ 
+ BPF_CALL_1(bpf_skb_vlan_pop, struct sk_buff *, skb)
+ {
+ 	int ret;
+ 
+ 	bpf_push_mac_rcsum(skb);
+ 	ret = skb_vlan_pop(skb);
+ 	bpf_pull_mac_rcsum(skb);
+ 
+ 	bpf_compute_data_end(skb);
+ 	return ret;
+ }
+ 
+ const struct bpf_func_proto bpf_skb_vlan_pop_proto = {
+ 	.func           = bpf_skb_vlan_pop,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type      = ARG_PTR_TO_CTX,
+ };
+ EXPORT_SYMBOL_GPL(bpf_skb_vlan_pop_proto);
+ 
+ static int bpf_skb_generic_push(struct sk_buff *skb, u32 off, u32 len)
+ {
+ 	/* Caller already did skb_cow() with len as headroom,
+ 	 * so no need to do it here.
+ 	 */
+ 	skb_push(skb, len);
+ 	memmove(skb->data, skb->data + len, off);
+ 	memset(skb->data + off, 0, len);
+ 
+ 	/* No skb_postpush_rcsum(skb, skb->data + off, len)
+ 	 * needed here as it does not change the skb->csum
+ 	 * result for checksum complete when summing over
+ 	 * zeroed blocks.
+ 	 */
+ 	return 0;
+ }
+ 
+ static int bpf_skb_generic_pop(struct sk_buff *skb, u32 off, u32 len)
+ {
+ 	/* skb_ensure_writable() is not needed here, as we're
+ 	 * already working on an uncloned skb.
+ 	 */
+ 	if (unlikely(!pskb_may_pull(skb, off + len)))
+ 		return -ENOMEM;
+ 
+ 	skb_postpull_rcsum(skb, skb->data + off, len);
+ 	memmove(skb->data + len, skb->data, off);
+ 	__skb_pull(skb, len);
+ 
+ 	return 0;
+ }
+ 
+ static int bpf_skb_net_hdr_push(struct sk_buff *skb, u32 off, u32 len)
+ {
+ 	bool trans_same = skb->transport_header == skb->network_header;
+ 	int ret;
+ 
+ 	/* There's no need for __skb_push()/__skb_pull() pair to
+ 	 * get to the start of the mac header as we're guaranteed
+ 	 * to always start from here under eBPF.
+ 	 */
+ 	ret = bpf_skb_generic_push(skb, off, len);
+ 	if (likely(!ret)) {
+ 		skb->mac_header -= len;
+ 		skb->network_header -= len;
+ 		if (trans_same)
+ 			skb->transport_header = skb->network_header;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int bpf_skb_net_hdr_pop(struct sk_buff *skb, u32 off, u32 len)
+ {
+ 	bool trans_same = skb->transport_header == skb->network_header;
+ 	int ret;
+ 
+ 	/* Same here, __skb_push()/__skb_pull() pair not needed. */
+ 	ret = bpf_skb_generic_pop(skb, off, len);
+ 	if (likely(!ret)) {
+ 		skb->mac_header += len;
+ 		skb->network_header += len;
+ 		if (trans_same)
+ 			skb->transport_header = skb->network_header;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int bpf_skb_proto_4_to_6(struct sk_buff *skb)
+ {
+ 	const u32 len_diff = sizeof(struct ipv6hdr) - sizeof(struct iphdr);
+ 	u32 off = skb->network_header - skb->mac_header;
+ 	int ret;
+ 
+ 	ret = skb_cow(skb, len_diff);
+ 	if (unlikely(ret < 0))
+ 		return ret;
+ 
+ 	ret = bpf_skb_net_hdr_push(skb, off, len_diff);
+ 	if (unlikely(ret < 0))
+ 		return ret;
+ 
+ 	if (skb_is_gso(skb)) {
+ 		/* SKB_GSO_UDP stays as is. SKB_GSO_TCPV4 needs to
+ 		 * be changed into SKB_GSO_TCPV6.
+ 		 */
+ 		if (skb_shinfo(skb)->gso_type & SKB_GSO_TCPV4) {
+ 			skb_shinfo(skb)->gso_type &= ~SKB_GSO_TCPV4;
+ 			skb_shinfo(skb)->gso_type |=  SKB_GSO_TCPV6;
+ 		}
+ 
+ 		/* Due to IPv6 header, MSS needs to be downgraded. */
+ 		skb_shinfo(skb)->gso_size -= len_diff;
+ 		/* Header must be checked, and gso_segs recomputed. */
+ 		skb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;
+ 		skb_shinfo(skb)->gso_segs = 0;
+ 	}
+ 
+ 	skb->protocol = htons(ETH_P_IPV6);
+ 	skb_clear_hash(skb);
+ 
+ 	return 0;
+ }
+ 
+ static int bpf_skb_proto_6_to_4(struct sk_buff *skb)
+ {
+ 	const u32 len_diff = sizeof(struct ipv6hdr) - sizeof(struct iphdr);
+ 	u32 off = skb->network_header - skb->mac_header;
+ 	int ret;
+ 
+ 	ret = skb_unclone(skb, GFP_ATOMIC);
+ 	if (unlikely(ret < 0))
+ 		return ret;
+ 
+ 	ret = bpf_skb_net_hdr_pop(skb, off, len_diff);
+ 	if (unlikely(ret < 0))
+ 		return ret;
+ 
+ 	if (skb_is_gso(skb)) {
+ 		/* SKB_GSO_UDP stays as is. SKB_GSO_TCPV6 needs to
+ 		 * be changed into SKB_GSO_TCPV4.
+ 		 */
+ 		if (skb_shinfo(skb)->gso_type & SKB_GSO_TCPV6) {
+ 			skb_shinfo(skb)->gso_type &= ~SKB_GSO_TCPV6;
+ 			skb_shinfo(skb)->gso_type |=  SKB_GSO_TCPV4;
+ 		}
+ 
+ 		/* Due to IPv4 header, MSS can be upgraded. */
+ 		skb_shinfo(skb)->gso_size += len_diff;
+ 		/* Header must be checked, and gso_segs recomputed. */
+ 		skb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;
+ 		skb_shinfo(skb)->gso_segs = 0;
+ 	}
+ 
+ 	skb->protocol = htons(ETH_P_IP);
+ 	skb_clear_hash(skb);
+ 
+ 	return 0;
+ }
+ 
+ static int bpf_skb_proto_xlat(struct sk_buff *skb, __be16 to_proto)
+ {
+ 	__be16 from_proto = skb->protocol;
+ 
+ 	if (from_proto == htons(ETH_P_IP) &&
+ 	      to_proto == htons(ETH_P_IPV6))
+ 		return bpf_skb_proto_4_to_6(skb);
+ 
+ 	if (from_proto == htons(ETH_P_IPV6) &&
+ 	      to_proto == htons(ETH_P_IP))
+ 		return bpf_skb_proto_6_to_4(skb);
+ 
+ 	return -ENOTSUPP;
+ }
+ 
+ BPF_CALL_3(bpf_skb_change_proto, struct sk_buff *, skb, __be16, proto,
+ 	   u64, flags)
+ {
+ 	int ret;
+ 
+ 	if (unlikely(flags))
+ 		return -EINVAL;
+ 
+ 	/* General idea is that this helper does the basic groundwork
+ 	 * needed for changing the protocol, and eBPF program fills the
+ 	 * rest through bpf_skb_store_bytes(), bpf_lX_csum_replace()
+ 	 * and other helpers, rather than passing a raw buffer here.
+ 	 *
+ 	 * The rationale is to keep this minimal and without a need to
+ 	 * deal with raw packet data. F.e. even if we would pass buffers
+ 	 * here, the program still needs to call the bpf_lX_csum_replace()
+ 	 * helpers anyway. Plus, this way we keep also separation of
+ 	 * concerns, since f.e. bpf_skb_store_bytes() should only take
+ 	 * care of stores.
+ 	 *
+ 	 * Currently, additional options and extension header space are
+ 	 * not supported, but flags register is reserved so we can adapt
+ 	 * that. For offloads, we mark packet as dodgy, so that headers
+ 	 * need to be verified first.
+ 	 */
+ 	ret = bpf_skb_proto_xlat(skb, proto);
+ 	bpf_compute_data_end(skb);
+ 	return ret;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_change_proto_proto = {
+ 	.func		= bpf_skb_change_proto,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_2(bpf_skb_change_type, struct sk_buff *, skb, u32, pkt_type)
+ {
+ 	/* We only allow a restricted subset to be changed for now. */
+ 	if (unlikely(!skb_pkt_type_ok(skb->pkt_type) ||
+ 		     !skb_pkt_type_ok(pkt_type)))
+ 		return -EINVAL;
+ 
+ 	skb->pkt_type = pkt_type;
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_change_type_proto = {
+ 	.func		= bpf_skb_change_type,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ };
+ 
+ static u32 __bpf_skb_min_len(const struct sk_buff *skb)
+ {
+ 	u32 min_len = skb_network_offset(skb);
+ 
+ 	if (skb_transport_header_was_set(skb))
+ 		min_len = skb_transport_offset(skb);
+ 	if (skb->ip_summed == CHECKSUM_PARTIAL)
+ 		min_len = skb_checksum_start_offset(skb) +
+ 			  skb->csum_offset + sizeof(__sum16);
+ 	return min_len;
+ }
+ 
+ static u32 __bpf_skb_max_len(const struct sk_buff *skb)
+ {
+ 	return skb->dev->mtu + skb->dev->hard_header_len;
+ }
+ 
+ static int bpf_skb_grow_rcsum(struct sk_buff *skb, unsigned int new_len)
+ {
+ 	unsigned int old_len = skb->len;
+ 	int ret;
+ 
+ 	ret = __skb_grow_rcsum(skb, new_len);
+ 	if (!ret)
+ 		memset(skb->data + old_len, 0, new_len - old_len);
+ 	return ret;
+ }
+ 
+ static int bpf_skb_trim_rcsum(struct sk_buff *skb, unsigned int new_len)
+ {
+ 	return __skb_trim_rcsum(skb, new_len);
+ }
+ 
+ BPF_CALL_3(bpf_skb_change_tail, struct sk_buff *, skb, u32, new_len,
+ 	   u64, flags)
+ {
+ 	u32 max_len = __bpf_skb_max_len(skb);
+ 	u32 min_len = __bpf_skb_min_len(skb);
+ 	int ret;
+ 
+ 	if (unlikely(flags || new_len > max_len || new_len < min_len))
+ 		return -EINVAL;
+ 	if (skb->encapsulation)
+ 		return -ENOTSUPP;
+ 
+ 	/* The basic idea of this helper is that it's performing the
+ 	 * needed work to either grow or trim an skb, and eBPF program
+ 	 * rewrites the rest via helpers like bpf_skb_store_bytes(),
+ 	 * bpf_lX_csum_replace() and others rather than passing a raw
+ 	 * buffer here. This one is a slow path helper and intended
+ 	 * for replies with control messages.
+ 	 *
+ 	 * Like in bpf_skb_change_proto(), we want to keep this rather
+ 	 * minimal and without protocol specifics so that we are able
+ 	 * to separate concerns as in bpf_skb_store_bytes() should only
+ 	 * be the one responsible for writing buffers.
+ 	 *
+ 	 * It's really expected to be a slow path operation here for
+ 	 * control message replies, so we're implicitly linearizing,
+ 	 * uncloning and drop offloads from the skb by this.
+ 	 */
+ 	ret = __bpf_try_make_writable(skb, skb->len);
+ 	if (!ret) {
+ 		if (new_len > skb->len)
+ 			ret = bpf_skb_grow_rcsum(skb, new_len);
+ 		else if (new_len < skb->len)
+ 			ret = bpf_skb_trim_rcsum(skb, new_len);
+ 		if (!ret && skb_is_gso(skb))
+ 			skb_gso_reset(skb);
+ 	}
+ 
+ 	bpf_compute_data_end(skb);
+ 	return ret;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_change_tail_proto = {
+ 	.func		= bpf_skb_change_tail,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_3(bpf_skb_change_head, struct sk_buff *, skb, u32, head_room,
+ 	   u64, flags)
+ {
+ 	u32 max_len = __bpf_skb_max_len(skb);
+ 	u32 new_len = skb->len + head_room;
+ 	int ret;
+ 
+ 	if (unlikely(flags || (!skb_is_gso(skb) && new_len > max_len) ||
+ 		     new_len < skb->len))
+ 		return -EINVAL;
+ 
+ 	ret = skb_cow(skb, head_room);
+ 	if (likely(!ret)) {
+ 		/* Idea for this helper is that we currently only
+ 		 * allow to expand on mac header. This means that
+ 		 * skb->protocol network header, etc, stay as is.
+ 		 * Compared to bpf_skb_change_tail(), we're more
+ 		 * flexible due to not needing to linearize or
+ 		 * reset GSO. Intention for this helper is to be
+ 		 * used by an L3 skb that needs to push mac header
+ 		 * for redirection into L2 device.
+ 		 */
+ 		__skb_push(skb, head_room);
+ 		memset(skb->data, 0, head_room);
+ 		skb_reset_mac_header(skb);
+ 	}
+ 
+ 	bpf_compute_data_end(skb);
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_change_head_proto = {
+ 	.func		= bpf_skb_change_head,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_ANYTHING,
+ };
+ 
+ bool bpf_helper_changes_skb_data(void *func)
+ {
+ 	if (func == bpf_skb_vlan_push ||
+ 	    func == bpf_skb_vlan_pop ||
+ 	    func == bpf_skb_store_bytes ||
+ 	    func == bpf_skb_change_proto ||
+ 	    func == bpf_skb_change_head ||
+ 	    func == bpf_skb_change_tail ||
+ 	    func == bpf_skb_pull_data ||
+ 	    func == bpf_l3_csum_replace ||
+ 	    func == bpf_l4_csum_replace)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static unsigned long bpf_skb_copy(void *dst_buff, const void *skb,
+ 				  unsigned long off, unsigned long len)
+ {
+ 	void *ptr = skb_header_pointer(skb, off, len, dst_buff);
+ 
+ 	if (unlikely(!ptr))
+ 		return len;
+ 	if (ptr != dst_buff)
+ 		memcpy(dst_buff, ptr, len);
+ 
+ 	return 0;
+ }
+ 
+ BPF_CALL_5(bpf_skb_event_output, struct sk_buff *, skb, struct bpf_map *, map,
+ 	   u64, flags, void *, meta, u64, meta_size)
+ {
+ 	u64 skb_size = (flags & BPF_F_CTXLEN_MASK) >> 32;
+ 
+ 	if (unlikely(flags & ~(BPF_F_CTXLEN_MASK | BPF_F_INDEX_MASK)))
+ 		return -EINVAL;
+ 	if (unlikely(skb_size > skb->len))
+ 		return -EFAULT;
+ 
+ 	return bpf_event_output(map, flags, meta, meta_size, skb, skb_size,
+ 				bpf_skb_copy);
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_event_output_proto = {
+ 	.func		= bpf_skb_event_output,
+ 	.gpl_only	= true,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_CONST_MAP_PTR,
+ 	.arg3_type	= ARG_ANYTHING,
+ 	.arg4_type	= ARG_PTR_TO_STACK,
+ 	.arg5_type	= ARG_CONST_STACK_SIZE,
+ };
+ 
+ static unsigned short bpf_tunnel_key_af(u64 flags)
+ {
+ 	return flags & BPF_F_TUNINFO_IPV6 ? AF_INET6 : AF_INET;
+ }
+ 
+ BPF_CALL_4(bpf_skb_get_tunnel_key, struct sk_buff *, skb, struct bpf_tunnel_key *, to,
+ 	   u32, size, u64, flags)
+ {
+ 	const struct ip_tunnel_info *info = skb_tunnel_info(skb);
+ 	u8 compat[sizeof(struct bpf_tunnel_key)];
+ 	void *to_orig = to;
+ 	int err;
+ 
+ 	if (unlikely(!info || (flags & ~(BPF_F_TUNINFO_IPV6)))) {
+ 		err = -EINVAL;
+ 		goto err_clear;
+ 	}
+ 	if (ip_tunnel_info_af(info) != bpf_tunnel_key_af(flags)) {
+ 		err = -EPROTO;
+ 		goto err_clear;
+ 	}
+ 	if (unlikely(size != sizeof(struct bpf_tunnel_key))) {
+ 		err = -EINVAL;
+ 		switch (size) {
+ 		case offsetof(struct bpf_tunnel_key, tunnel_label):
+ 		case offsetof(struct bpf_tunnel_key, tunnel_ext):
+ 			goto set_compat;
+ 		case offsetof(struct bpf_tunnel_key, remote_ipv6[1]):
+ 			/* Fixup deprecated structure layouts here, so we have
+ 			 * a common path later on.
+ 			 */
+ 			if (ip_tunnel_info_af(info) != AF_INET)
+ 				goto err_clear;
+ set_compat:
+ 			to = (struct bpf_tunnel_key *)compat;
+ 			break;
+ 		default:
+ 			goto err_clear;
+ 		}
+ 	}
+ 
+ 	to->tunnel_id = be64_to_cpu(info->key.tun_id);
+ 	to->tunnel_tos = info->key.tos;
+ 	to->tunnel_ttl = info->key.ttl;
+ 
+ 	if (flags & BPF_F_TUNINFO_IPV6) {
+ 		memcpy(to->remote_ipv6, &info->key.u.ipv6.src,
+ 		       sizeof(to->remote_ipv6));
+ 		to->tunnel_label = be32_to_cpu(info->key.label);
+ 	} else {
+ 		to->remote_ipv4 = be32_to_cpu(info->key.u.ipv4.src);
+ 	}
+ 
+ 	if (unlikely(size != sizeof(struct bpf_tunnel_key)))
+ 		memcpy(to_orig, to, size);
+ 
+ 	return 0;
+ err_clear:
+ 	memset(to_orig, 0, size);
+ 	return err;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_get_tunnel_key_proto = {
+ 	.func		= bpf_skb_get_tunnel_key,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_RAW_STACK,
+ 	.arg3_type	= ARG_CONST_STACK_SIZE,
+ 	.arg4_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_3(bpf_skb_get_tunnel_opt, struct sk_buff *, skb, u8 *, to, u32, size)
+ {
+ 	const struct ip_tunnel_info *info = skb_tunnel_info(skb);
+ 	int err;
+ 
+ 	if (unlikely(!info ||
+ 		     !(info->key.tun_flags & TUNNEL_OPTIONS_PRESENT))) {
+ 		err = -ENOENT;
+ 		goto err_clear;
+ 	}
+ 	if (unlikely(size < info->options_len)) {
+ 		err = -ENOMEM;
+ 		goto err_clear;
+ 	}
+ 
+ 	ip_tunnel_info_opts_get(to, info);
+ 	if (size > info->options_len)
+ 		memset(to + info->options_len, 0, size - info->options_len);
+ 
+ 	return info->options_len;
+ err_clear:
+ 	memset(to, 0, size);
+ 	return err;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_get_tunnel_opt_proto = {
+ 	.func		= bpf_skb_get_tunnel_opt,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_RAW_STACK,
+ 	.arg3_type	= ARG_CONST_STACK_SIZE,
+ };
+ 
+ static struct metadata_dst __percpu *md_dst;
+ 
+ BPF_CALL_4(bpf_skb_set_tunnel_key, struct sk_buff *, skb,
+ 	   const struct bpf_tunnel_key *, from, u32, size, u64, flags)
+ {
+ 	struct metadata_dst *md = this_cpu_ptr(md_dst);
+ 	u8 compat[sizeof(struct bpf_tunnel_key)];
+ 	struct ip_tunnel_info *info;
+ 
+ 	if (unlikely(flags & ~(BPF_F_TUNINFO_IPV6 | BPF_F_ZERO_CSUM_TX |
+ 			       BPF_F_DONT_FRAGMENT)))
+ 		return -EINVAL;
+ 	if (unlikely(size != sizeof(struct bpf_tunnel_key))) {
+ 		switch (size) {
+ 		case offsetof(struct bpf_tunnel_key, tunnel_label):
+ 		case offsetof(struct bpf_tunnel_key, tunnel_ext):
+ 		case offsetof(struct bpf_tunnel_key, remote_ipv6[1]):
+ 			/* Fixup deprecated structure layouts here, so we have
+ 			 * a common path later on.
+ 			 */
+ 			memcpy(compat, from, size);
+ 			memset(compat + size, 0, sizeof(compat) - size);
+ 			from = (const struct bpf_tunnel_key *) compat;
+ 			break;
+ 		default:
+ 			return -EINVAL;
+ 		}
+ 	}
+ 	if (unlikely((!(flags & BPF_F_TUNINFO_IPV6) && from->tunnel_label) ||
+ 		     from->tunnel_ext))
+ 		return -EINVAL;
+ 
+ 	skb_dst_drop(skb);
+ 	dst_hold((struct dst_entry *) md);
+ 	skb_dst_set(skb, (struct dst_entry *) md);
+ 
+ 	info = &md->u.tun_info;
+ 	info->mode = IP_TUNNEL_INFO_TX;
+ 
+ 	info->key.tun_flags = TUNNEL_KEY | TUNNEL_CSUM | TUNNEL_NOCACHE;
+ 	if (flags & BPF_F_DONT_FRAGMENT)
+ 		info->key.tun_flags |= TUNNEL_DONT_FRAGMENT;
+ 
+ 	info->key.tun_id = cpu_to_be64(from->tunnel_id);
+ 	info->key.tos = from->tunnel_tos;
+ 	info->key.ttl = from->tunnel_ttl;
+ 
+ 	if (flags & BPF_F_TUNINFO_IPV6) {
+ 		info->mode |= IP_TUNNEL_INFO_IPV6;
+ 		memcpy(&info->key.u.ipv6.dst, from->remote_ipv6,
+ 		       sizeof(from->remote_ipv6));
+ 		info->key.label = cpu_to_be32(from->tunnel_label) &
+ 				  IPV6_FLOWLABEL_MASK;
+ 	} else {
+ 		info->key.u.ipv4.dst = cpu_to_be32(from->remote_ipv4);
+ 		if (flags & BPF_F_ZERO_CSUM_TX)
+ 			info->key.tun_flags &= ~TUNNEL_CSUM;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_set_tunnel_key_proto = {
+ 	.func		= bpf_skb_set_tunnel_key,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_STACK,
+ 	.arg3_type	= ARG_CONST_STACK_SIZE,
+ 	.arg4_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_3(bpf_skb_set_tunnel_opt, struct sk_buff *, skb,
+ 	   const u8 *, from, u32, size)
+ {
+ 	struct ip_tunnel_info *info = skb_tunnel_info(skb);
+ 	const struct metadata_dst *md = this_cpu_ptr(md_dst);
+ 
+ 	if (unlikely(info != &md->u.tun_info || (size & (sizeof(u32) - 1))))
+ 		return -EINVAL;
+ 	if (unlikely(size > IP_TUNNEL_OPTS_MAX))
+ 		return -ENOMEM;
+ 
+ 	ip_tunnel_info_opts_set(info, from, size);
+ 
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_set_tunnel_opt_proto = {
+ 	.func		= bpf_skb_set_tunnel_opt,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_STACK,
+ 	.arg3_type	= ARG_CONST_STACK_SIZE,
+ };
+ 
+ static const struct bpf_func_proto *
+ bpf_get_skb_set_tunnel_proto(enum bpf_func_id which)
+ {
+ 	if (!md_dst) {
+ 		/* Race is not possible, since it's called from verifier
+ 		 * that is holding verifier mutex.
+ 		 */
+ 		md_dst = metadata_dst_alloc_percpu(IP_TUNNEL_OPTS_MAX,
+ 						   GFP_KERNEL);
+ 		if (!md_dst)
+ 			return NULL;
+ 	}
+ 
+ 	switch (which) {
+ 	case BPF_FUNC_skb_set_tunnel_key:
+ 		return &bpf_skb_set_tunnel_key_proto;
+ 	case BPF_FUNC_skb_set_tunnel_opt:
+ 		return &bpf_skb_set_tunnel_opt_proto;
+ 	default:
+ 		return NULL;
+ 	}
+ }
+ 
+ BPF_CALL_3(bpf_skb_under_cgroup, struct sk_buff *, skb, struct bpf_map *, map,
+ 	   u32, idx)
+ {
+ 	struct bpf_array *array = container_of(map, struct bpf_array, map);
+ 	struct cgroup *cgrp;
+ 	struct sock *sk;
+ 
+ 	sk = skb_to_full_sk(skb);
+ 	if (!sk || !sk_fullsock(sk))
+ 		return -ENOENT;
+ 	if (unlikely(idx >= array->map.max_entries))
+ 		return -E2BIG;
+ 
+ 	cgrp = READ_ONCE(array->ptrs[idx]);
+ 	if (unlikely(!cgrp))
+ 		return -EAGAIN;
+ 
+ 	return sk_under_cgroup_hierarchy(sk, cgrp);
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_under_cgroup_proto = {
+ 	.func		= bpf_skb_under_cgroup,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_CONST_MAP_PTR,
+ 	.arg3_type	= ARG_ANYTHING,
+ };
+ 
+ static unsigned long bpf_xdp_copy(void *dst_buff, const void *src_buff,
+ 				  unsigned long off, unsigned long len)
+ {
+ 	memcpy(dst_buff, src_buff + off, len);
+ 	return 0;
+ }
+ 
+ BPF_CALL_5(bpf_xdp_event_output, struct xdp_buff *, xdp, struct bpf_map *, map,
+ 	   u64, flags, void *, meta, u64, meta_size)
+ {
+ 	u64 xdp_size = (flags & BPF_F_CTXLEN_MASK) >> 32;
+ 
+ 	if (unlikely(flags & ~(BPF_F_CTXLEN_MASK | BPF_F_INDEX_MASK)))
+ 		return -EINVAL;
+ 	if (unlikely(xdp_size > (unsigned long)(xdp->data_end - xdp->data)))
+ 		return -EFAULT;
+ 
+ 	return bpf_event_output(map, flags, meta, meta_size, xdp, xdp_size,
+ 				bpf_xdp_copy);
+ }
+ 
+ static const struct bpf_func_proto bpf_xdp_event_output_proto = {
+ 	.func		= bpf_xdp_event_output,
+ 	.gpl_only	= true,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_CONST_MAP_PTR,
+ 	.arg3_type	= ARG_ANYTHING,
+ 	.arg4_type	= ARG_PTR_TO_STACK,
+ 	.arg5_type	= ARG_CONST_STACK_SIZE,
+ };
+ 
+ static const struct bpf_func_proto *
+ sk_filter_func_proto(enum bpf_func_id func_id)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_map_lookup_elem:
+ 		return &bpf_map_lookup_elem_proto;
+ 	case BPF_FUNC_map_update_elem:
+ 		return &bpf_map_update_elem_proto;
+ 	case BPF_FUNC_map_delete_elem:
+ 		return &bpf_map_delete_elem_proto;
+ 	case BPF_FUNC_get_prandom_u32:
+ 		return &bpf_get_prandom_u32_proto;
+ 	case BPF_FUNC_get_smp_processor_id:
+ 		return &bpf_get_raw_smp_processor_id_proto;
+ 	case BPF_FUNC_get_numa_node_id:
+ 		return &bpf_get_numa_node_id_proto;
+ 	case BPF_FUNC_tail_call:
+ 		return &bpf_tail_call_proto;
+ 	case BPF_FUNC_ktime_get_ns:
+ 		return &bpf_ktime_get_ns_proto;
+ 	case BPF_FUNC_trace_printk:
+ 		if (capable(CAP_SYS_ADMIN))
+ 			return bpf_get_trace_printk_proto();
+ 	default:
+ 		return NULL;
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ tc_cls_act_func_proto(enum bpf_func_id func_id)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_skb_store_bytes:
+ 		return &bpf_skb_store_bytes_proto;
+ 	case BPF_FUNC_skb_load_bytes:
+ 		return &bpf_skb_load_bytes_proto;
+ 	case BPF_FUNC_skb_pull_data:
+ 		return &bpf_skb_pull_data_proto;
+ 	case BPF_FUNC_csum_diff:
+ 		return &bpf_csum_diff_proto;
+ 	case BPF_FUNC_csum_update:
+ 		return &bpf_csum_update_proto;
+ 	case BPF_FUNC_l3_csum_replace:
+ 		return &bpf_l3_csum_replace_proto;
+ 	case BPF_FUNC_l4_csum_replace:
+ 		return &bpf_l4_csum_replace_proto;
+ 	case BPF_FUNC_clone_redirect:
+ 		return &bpf_clone_redirect_proto;
+ 	case BPF_FUNC_get_cgroup_classid:
+ 		return &bpf_get_cgroup_classid_proto;
+ 	case BPF_FUNC_skb_vlan_push:
+ 		return &bpf_skb_vlan_push_proto;
+ 	case BPF_FUNC_skb_vlan_pop:
+ 		return &bpf_skb_vlan_pop_proto;
+ 	case BPF_FUNC_skb_change_proto:
+ 		return &bpf_skb_change_proto_proto;
+ 	case BPF_FUNC_skb_change_type:
+ 		return &bpf_skb_change_type_proto;
+ 	case BPF_FUNC_skb_change_tail:
+ 		return &bpf_skb_change_tail_proto;
+ 	case BPF_FUNC_skb_get_tunnel_key:
+ 		return &bpf_skb_get_tunnel_key_proto;
+ 	case BPF_FUNC_skb_set_tunnel_key:
+ 		return bpf_get_skb_set_tunnel_proto(func_id);
+ 	case BPF_FUNC_skb_get_tunnel_opt:
+ 		return &bpf_skb_get_tunnel_opt_proto;
+ 	case BPF_FUNC_skb_set_tunnel_opt:
+ 		return bpf_get_skb_set_tunnel_proto(func_id);
+ 	case BPF_FUNC_redirect:
+ 		return &bpf_redirect_proto;
+ 	case BPF_FUNC_get_route_realm:
+ 		return &bpf_get_route_realm_proto;
+ 	case BPF_FUNC_get_hash_recalc:
+ 		return &bpf_get_hash_recalc_proto;
+ 	case BPF_FUNC_set_hash_invalid:
+ 		return &bpf_set_hash_invalid_proto;
+ 	case BPF_FUNC_perf_event_output:
+ 		return &bpf_skb_event_output_proto;
+ 	case BPF_FUNC_get_smp_processor_id:
+ 		return &bpf_get_smp_processor_id_proto;
+ 	case BPF_FUNC_skb_under_cgroup:
+ 		return &bpf_skb_under_cgroup_proto;
+ 	default:
+ 		return sk_filter_func_proto(func_id);
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ xdp_func_proto(enum bpf_func_id func_id)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_perf_event_output:
+ 		return &bpf_xdp_event_output_proto;
+ 	case BPF_FUNC_get_smp_processor_id:
+ 		return &bpf_get_smp_processor_id_proto;
+ 	default:
+ 		return sk_filter_func_proto(func_id);
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ cg_skb_func_proto(enum bpf_func_id func_id)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_skb_load_bytes:
+ 		return &bpf_skb_load_bytes_proto;
+ 	default:
+ 		return sk_filter_func_proto(func_id);
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ lwt_inout_func_proto(enum bpf_func_id func_id)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_skb_load_bytes:
+ 		return &bpf_skb_load_bytes_proto;
+ 	case BPF_FUNC_skb_pull_data:
+ 		return &bpf_skb_pull_data_proto;
+ 	case BPF_FUNC_csum_diff:
+ 		return &bpf_csum_diff_proto;
+ 	case BPF_FUNC_get_cgroup_classid:
+ 		return &bpf_get_cgroup_classid_proto;
+ 	case BPF_FUNC_get_route_realm:
+ 		return &bpf_get_route_realm_proto;
+ 	case BPF_FUNC_get_hash_recalc:
+ 		return &bpf_get_hash_recalc_proto;
+ 	case BPF_FUNC_perf_event_output:
+ 		return &bpf_skb_event_output_proto;
+ 	case BPF_FUNC_get_smp_processor_id:
+ 		return &bpf_get_smp_processor_id_proto;
+ 	case BPF_FUNC_skb_under_cgroup:
+ 		return &bpf_skb_under_cgroup_proto;
+ 	default:
+ 		return sk_filter_func_proto(func_id);
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ lwt_xmit_func_proto(enum bpf_func_id func_id)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_skb_get_tunnel_key:
+ 		return &bpf_skb_get_tunnel_key_proto;
+ 	case BPF_FUNC_skb_set_tunnel_key:
+ 		return bpf_get_skb_set_tunnel_proto(func_id);
+ 	case BPF_FUNC_skb_get_tunnel_opt:
+ 		return &bpf_skb_get_tunnel_opt_proto;
+ 	case BPF_FUNC_skb_set_tunnel_opt:
+ 		return bpf_get_skb_set_tunnel_proto(func_id);
+ 	case BPF_FUNC_redirect:
+ 		return &bpf_redirect_proto;
+ 	case BPF_FUNC_clone_redirect:
+ 		return &bpf_clone_redirect_proto;
+ 	case BPF_FUNC_skb_change_tail:
+ 		return &bpf_skb_change_tail_proto;
+ 	case BPF_FUNC_skb_change_head:
+ 		return &bpf_skb_change_head_proto;
+ 	case BPF_FUNC_skb_store_bytes:
+ 		return &bpf_skb_store_bytes_proto;
+ 	case BPF_FUNC_csum_update:
+ 		return &bpf_csum_update_proto;
+ 	case BPF_FUNC_l3_csum_replace:
+ 		return &bpf_l3_csum_replace_proto;
+ 	case BPF_FUNC_l4_csum_replace:
+ 		return &bpf_l4_csum_replace_proto;
+ 	case BPF_FUNC_set_hash_invalid:
+ 		return &bpf_set_hash_invalid_proto;
+ 	default:
+ 		return lwt_inout_func_proto(func_id);
+ 	}
+ }
+ 
+ static bool __is_valid_access(int off, int size, enum bpf_access_type type)
+ {
+ 	if (off < 0 || off >= sizeof(struct __sk_buff))
+ 		return false;
+ 	/* The verifier guarantees that size > 0. */
+ 	if (off % size != 0)
+ 		return false;
+ 	if (size != sizeof(__u32))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static bool sk_filter_is_valid_access(int off, int size,
+ 				      enum bpf_access_type type,
+ 				      enum bpf_reg_type *reg_type)
+ {
+ 	switch (off) {
+ 	case offsetof(struct __sk_buff, tc_classid):
+ 	case offsetof(struct __sk_buff, data):
+ 	case offsetof(struct __sk_buff, data_end):
+ 		return false;
+ 	}
+ 
+ 	if (type == BPF_WRITE) {
+ 		switch (off) {
+ 		case offsetof(struct __sk_buff, cb[0]) ...
+ 		     offsetof(struct __sk_buff, cb[4]):
+ 			break;
+ 		default:
+ 			return false;
+ 		}
+ 	}
+ 
+ 	return __is_valid_access(off, size, type);
+ }
+ 
+ static bool lwt_is_valid_access(int off, int size,
+ 				enum bpf_access_type type,
+ 				enum bpf_reg_type *reg_type)
+ {
+ 	switch (off) {
+ 	case offsetof(struct __sk_buff, tc_classid):
+ 		return false;
+ 	}
+ 
+ 	if (type == BPF_WRITE) {
+ 		switch (off) {
+ 		case offsetof(struct __sk_buff, mark):
+ 		case offsetof(struct __sk_buff, priority):
+ 		case offsetof(struct __sk_buff, cb[0]) ...
+ 		     offsetof(struct __sk_buff, cb[4]):
+ 			break;
+ 		default:
+ 			return false;
+ 		}
+ 	}
+ 
+ 	switch (off) {
+ 	case offsetof(struct __sk_buff, data):
+ 		*reg_type = PTR_TO_PACKET;
+ 		break;
+ 	case offsetof(struct __sk_buff, data_end):
+ 		*reg_type = PTR_TO_PACKET_END;
+ 		break;
+ 	}
+ 
+ 	return __is_valid_access(off, size, type);
+ }
+ 
+ static int tc_cls_act_prologue(struct bpf_insn *insn_buf, bool direct_write,
+ 			       const struct bpf_prog *prog)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 
+ 	if (!direct_write)
+ 		return 0;
+ 
+ 	/* if (!skb->cloned)
+ 	 *       goto start;
+ 	 *
+ 	 * (Fast-path, otherwise approximation that we might be
+ 	 *  a clone, do the rest in helper.)
+ 	 */
+ 	*insn++ = BPF_LDX_MEM(BPF_B, BPF_REG_6, BPF_REG_1, CLONED_OFFSET());
+ 	*insn++ = BPF_ALU32_IMM(BPF_AND, BPF_REG_6, CLONED_MASK);
+ 	*insn++ = BPF_JMP_IMM(BPF_JEQ, BPF_REG_6, 0, 7);
+ 
+ 	/* ret = bpf_skb_pull_data(skb, 0); */
+ 	*insn++ = BPF_MOV64_REG(BPF_REG_6, BPF_REG_1);
+ 	*insn++ = BPF_ALU64_REG(BPF_XOR, BPF_REG_2, BPF_REG_2);
+ 	*insn++ = BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,
+ 			       BPF_FUNC_skb_pull_data);
+ 	/* if (!ret)
+ 	 *      goto restore;
+ 	 * return TC_ACT_SHOT;
+ 	 */
+ 	*insn++ = BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2);
+ 	*insn++ = BPF_ALU32_IMM(BPF_MOV, BPF_REG_0, TC_ACT_SHOT);
+ 	*insn++ = BPF_EXIT_INSN();
+ 
+ 	/* restore: */
+ 	*insn++ = BPF_MOV64_REG(BPF_REG_1, BPF_REG_6);
+ 	/* start: */
+ 	*insn++ = prog->insnsi[0];
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ static bool tc_cls_act_is_valid_access(int off, int size,
+ 				       enum bpf_access_type type,
+ 				       enum bpf_reg_type *reg_type)
+ {
+ 	if (type == BPF_WRITE) {
+ 		switch (off) {
+ 		case offsetof(struct __sk_buff, mark):
+ 		case offsetof(struct __sk_buff, tc_index):
+ 		case offsetof(struct __sk_buff, priority):
+ 		case offsetof(struct __sk_buff, cb[0]) ...
+ 		     offsetof(struct __sk_buff, cb[4]):
+ 		case offsetof(struct __sk_buff, tc_classid):
+ 			break;
+ 		default:
+ 			return false;
+ 		}
+ 	}
+ 
+ 	switch (off) {
+ 	case offsetof(struct __sk_buff, data):
+ 		*reg_type = PTR_TO_PACKET;
+ 		break;
+ 	case offsetof(struct __sk_buff, data_end):
+ 		*reg_type = PTR_TO_PACKET_END;
+ 		break;
+ 	}
+ 
+ 	return __is_valid_access(off, size, type);
+ }
+ 
+ static bool __is_valid_xdp_access(int off, int size,
+ 				  enum bpf_access_type type)
+ {
+ 	if (off < 0 || off >= sizeof(struct xdp_md))
+ 		return false;
+ 	if (off % size != 0)
+ 		return false;
+ 	if (size != sizeof(__u32))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static bool xdp_is_valid_access(int off, int size,
+ 				enum bpf_access_type type,
+ 				enum bpf_reg_type *reg_type)
+ {
+ 	if (type == BPF_WRITE)
+ 		return false;
+ 
+ 	switch (off) {
+ 	case offsetof(struct xdp_md, data):
+ 		*reg_type = PTR_TO_PACKET;
+ 		break;
+ 	case offsetof(struct xdp_md, data_end):
+ 		*reg_type = PTR_TO_PACKET_END;
+ 		break;
+ 	}
+ 
+ 	return __is_valid_xdp_access(off, size, type);
+ }
+ 
+ void bpf_warn_invalid_xdp_action(u32 act)
+ {
+ 	WARN_ONCE(1, "Illegal XDP return value %u, expect packet loss\n", act);
+ }
+ EXPORT_SYMBOL_GPL(bpf_warn_invalid_xdp_action);
+ 
+ static u32 sk_filter_convert_ctx_access(enum bpf_access_type type, int dst_reg,
+ 					int src_reg, int ctx_off,
+ 					struct bpf_insn *insn_buf,
+ 					struct bpf_prog *prog)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 
+ 	switch (ctx_off) {
+ 	case offsetof(struct __sk_buff, len):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, len) != 4);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_W, dst_reg, src_reg,
+ 				      offsetof(struct sk_buff, len));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, protocol):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_H, dst_reg, src_reg,
+ 				      offsetof(struct sk_buff, protocol));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, vlan_proto):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, vlan_proto) != 2);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_H, dst_reg, src_reg,
+ 				      offsetof(struct sk_buff, vlan_proto));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, priority):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, priority) != 4);
+ 
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_STX_MEM(BPF_W, dst_reg, src_reg,
+ 					      offsetof(struct sk_buff, priority));
+ 		else
+ 			*insn++ = BPF_LDX_MEM(BPF_W, dst_reg, src_reg,
+ 					      offsetof(struct sk_buff, priority));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, ingress_ifindex):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, skb_iif) != 4);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_W, dst_reg, src_reg,
+ 				      offsetof(struct sk_buff, skb_iif));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, ifindex):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_buff, dev),
+ 				      dst_reg, src_reg,
+ 				      offsetof(struct sk_buff, dev));
+ 		*insn++ = BPF_JMP_IMM(BPF_JEQ, dst_reg, 0, 1);
+ 		*insn++ = BPF_LDX_MEM(BPF_W, dst_reg, dst_reg,
+ 				      offsetof(struct net_device, ifindex));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, hash):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, hash) != 4);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_W, dst_reg, src_reg,
+ 				      offsetof(struct sk_buff, hash));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, mark):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);
+ 
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_STX_MEM(BPF_W, dst_reg, src_reg,
+ 					      offsetof(struct sk_buff, mark));
+ 		else
+ 			*insn++ = BPF_LDX_MEM(BPF_W, dst_reg, src_reg,
+ 					      offsetof(struct sk_buff, mark));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, pkt_type):
+ 		return convert_skb_access(SKF_AD_PKTTYPE, dst_reg, src_reg, insn);
+ 
+ 	case offsetof(struct __sk_buff, queue_mapping):
+ 		return convert_skb_access(SKF_AD_QUEUE, dst_reg, src_reg, insn);
+ 
+ 	case offsetof(struct __sk_buff, vlan_present):
+ 		return convert_skb_access(SKF_AD_VLAN_TAG_PRESENT,
+ 					  dst_reg, src_reg, insn);
+ 
+ 	case offsetof(struct __sk_buff, vlan_tci):
+ 		return convert_skb_access(SKF_AD_VLAN_TAG,
+ 					  dst_reg, src_reg, insn);
+ 
+ 	case offsetof(struct __sk_buff, cb[0]) ...
+ 	     offsetof(struct __sk_buff, cb[4]):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct qdisc_skb_cb, data) < 20);
+ 
+ 		prog->cb_access = 1;
+ 		ctx_off -= offsetof(struct __sk_buff, cb[0]);
+ 		ctx_off += offsetof(struct sk_buff, cb);
+ 		ctx_off += offsetof(struct qdisc_skb_cb, data);
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_STX_MEM(BPF_W, dst_reg, src_reg, ctx_off);
+ 		else
+ 			*insn++ = BPF_LDX_MEM(BPF_W, dst_reg, src_reg, ctx_off);
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, tc_classid):
+ 		ctx_off -= offsetof(struct __sk_buff, tc_classid);
+ 		ctx_off += offsetof(struct sk_buff, cb);
+ 		ctx_off += offsetof(struct qdisc_skb_cb, tc_classid);
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_STX_MEM(BPF_H, dst_reg, src_reg, ctx_off);
+ 		else
+ 			*insn++ = BPF_LDX_MEM(BPF_H, dst_reg, src_reg, ctx_off);
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, data):
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_buff, data),
+ 				      dst_reg, src_reg,
+ 				      offsetof(struct sk_buff, data));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, data_end):
+ 		ctx_off -= offsetof(struct __sk_buff, data_end);
+ 		ctx_off += offsetof(struct sk_buff, cb);
+ 		ctx_off += offsetof(struct bpf_skb_data_end, data_end);
+ 		*insn++ = BPF_LDX_MEM(BPF_SIZEOF(void *), dst_reg, src_reg,
+ 				      ctx_off);
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, tc_index):
+ #ifdef CONFIG_NET_SCHED
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, tc_index) != 2);
+ 
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_STX_MEM(BPF_H, dst_reg, src_reg,
+ 					      offsetof(struct sk_buff, tc_index));
+ 		else
+ 			*insn++ = BPF_LDX_MEM(BPF_H, dst_reg, src_reg,
+ 					      offsetof(struct sk_buff, tc_index));
+ 		break;
+ #else
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_MOV64_REG(dst_reg, dst_reg);
+ 		else
+ 			*insn++ = BPF_MOV64_IMM(dst_reg, 0);
+ 		break;
+ #endif
+ 	}
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ static u32 tc_cls_act_convert_ctx_access(enum bpf_access_type type, int dst_reg,
+ 					 int src_reg, int ctx_off,
+ 					 struct bpf_insn *insn_buf,
+ 					 struct bpf_prog *prog)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 
+ 	switch (ctx_off) {
+ 	case offsetof(struct __sk_buff, ifindex):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_buff, dev),
+ 				      dst_reg, src_reg,
+ 				      offsetof(struct sk_buff, dev));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, dst_reg, dst_reg,
+ 				      offsetof(struct net_device, ifindex));
+ 		break;
+ 	default:
+ 		return sk_filter_convert_ctx_access(type, dst_reg, src_reg,
+ 						    ctx_off, insn_buf, prog);
+ 	}
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ static u32 xdp_convert_ctx_access(enum bpf_access_type type, int dst_reg,
+ 				  int src_reg, int ctx_off,
+ 				  struct bpf_insn *insn_buf,
+ 				  struct bpf_prog *prog)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 
+ 	switch (ctx_off) {
+ 	case offsetof(struct xdp_md, data):
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct xdp_buff, data),
+ 				      dst_reg, src_reg,
+ 				      offsetof(struct xdp_buff, data));
+ 		break;
+ 	case offsetof(struct xdp_md, data_end):
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct xdp_buff, data_end),
+ 				      dst_reg, src_reg,
+ 				      offsetof(struct xdp_buff, data_end));
+ 		break;
+ 	}
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ static const struct bpf_verifier_ops sk_filter_ops = {
+ 	.get_func_proto		= sk_filter_func_proto,
+ 	.is_valid_access	= sk_filter_is_valid_access,
+ 	.convert_ctx_access	= sk_filter_convert_ctx_access,
+ };
+ 
+ static const struct bpf_verifier_ops tc_cls_act_ops = {
+ 	.get_func_proto		= tc_cls_act_func_proto,
+ 	.is_valid_access	= tc_cls_act_is_valid_access,
+ 	.convert_ctx_access	= tc_cls_act_convert_ctx_access,
+ 	.gen_prologue		= tc_cls_act_prologue,
+ };
+ 
+ static const struct bpf_verifier_ops xdp_ops = {
+ 	.get_func_proto		= xdp_func_proto,
+ 	.is_valid_access	= xdp_is_valid_access,
+ 	.convert_ctx_access	= xdp_convert_ctx_access,
+ };
+ 
+ static const struct bpf_verifier_ops cg_skb_ops = {
+ 	.get_func_proto		= cg_skb_func_proto,
+ 	.is_valid_access	= sk_filter_is_valid_access,
+ 	.convert_ctx_access	= sk_filter_convert_ctx_access,
+ };
+ 
+ static const struct bpf_verifier_ops lwt_inout_ops = {
+ 	.get_func_proto		= lwt_inout_func_proto,
+ 	.is_valid_access	= lwt_is_valid_access,
+ 	.convert_ctx_access	= sk_filter_convert_ctx_access,
+ };
+ 
+ static const struct bpf_verifier_ops lwt_xmit_ops = {
+ 	.get_func_proto		= lwt_xmit_func_proto,
+ 	.is_valid_access	= lwt_is_valid_access,
+ 	.convert_ctx_access	= sk_filter_convert_ctx_access,
+ 	.gen_prologue		= tc_cls_act_prologue,
+ };
+ 
+ static struct bpf_prog_type_list sk_filter_type __read_mostly = {
+ 	.ops	= &sk_filter_ops,
+ 	.type	= BPF_PROG_TYPE_SOCKET_FILTER,
+ };
+ 
+ static struct bpf_prog_type_list sched_cls_type __read_mostly = {
+ 	.ops	= &tc_cls_act_ops,
+ 	.type	= BPF_PROG_TYPE_SCHED_CLS,
+ };
+ 
+ static struct bpf_prog_type_list sched_act_type __read_mostly = {
+ 	.ops	= &tc_cls_act_ops,
+ 	.type	= BPF_PROG_TYPE_SCHED_ACT,
+ };
+ 
+ static struct bpf_prog_type_list xdp_type __read_mostly = {
+ 	.ops	= &xdp_ops,
+ 	.type	= BPF_PROG_TYPE_XDP,
+ };
+ 
+ static struct bpf_prog_type_list cg_skb_type __read_mostly = {
+ 	.ops	= &cg_skb_ops,
+ 	.type	= BPF_PROG_TYPE_CGROUP_SKB,
+ };
+ 
+ static struct bpf_prog_type_list lwt_in_type __read_mostly = {
+ 	.ops	= &lwt_inout_ops,
+ 	.type	= BPF_PROG_TYPE_LWT_IN,
+ };
+ 
+ static struct bpf_prog_type_list lwt_out_type __read_mostly = {
+ 	.ops	= &lwt_inout_ops,
+ 	.type	= BPF_PROG_TYPE_LWT_OUT,
+ };
+ 
+ static struct bpf_prog_type_list lwt_xmit_type __read_mostly = {
+ 	.ops	= &lwt_xmit_ops,
+ 	.type	= BPF_PROG_TYPE_LWT_XMIT,
+ };
+ 
+ static int __init register_sk_filter_ops(void)
+ {
+ 	bpf_register_prog_type(&sk_filter_type);
+ 	bpf_register_prog_type(&sched_cls_type);
+ 	bpf_register_prog_type(&sched_act_type);
+ 	bpf_register_prog_type(&xdp_type);
+ 	bpf_register_prog_type(&cg_skb_type);
+ 	bpf_register_prog_type(&lwt_in_type);
+ 	bpf_register_prog_type(&lwt_out_type);
+ 	bpf_register_prog_type(&lwt_xmit_type);
+ 
+ 	return 0;
+ }
+ late_initcall(register_sk_filter_ops);
+ 
++>>>>>>> 3a0af8fd61f9 (bpf: BPF for lightweight tunnel infrastructure)
  int sk_detach_filter(struct sock *sk)
  {
  	int ret = -ENOENT;
diff --cc net/core/lwtunnel.c
index dfb1a9ca0835,a5d4e866ce88..000000000000
--- a/net/core/lwtunnel.c
+++ b/net/core/lwtunnel.c
@@@ -27,6 -27,35 +27,38 @@@
  #include <net/rtnetlink.h>
  #include <net/ip6_fib.h>
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_MODULES
+ 
+ static const char *lwtunnel_encap_str(enum lwtunnel_encap_types encap_type)
+ {
+ 	/* Only lwt encaps implemented without using an interface for
+ 	 * the encap need to return a string here.
+ 	 */
+ 	switch (encap_type) {
+ 	case LWTUNNEL_ENCAP_MPLS:
+ 		return "MPLS";
+ 	case LWTUNNEL_ENCAP_ILA:
+ 		return "ILA";
+ 	case LWTUNNEL_ENCAP_SEG6:
+ 		return "SEG6";
+ 	case LWTUNNEL_ENCAP_BPF:
+ 		return "BPF";
+ 	case LWTUNNEL_ENCAP_IP6:
+ 	case LWTUNNEL_ENCAP_IP:
+ 	case LWTUNNEL_ENCAP_NONE:
+ 	case __LWTUNNEL_ENCAP_MAX:
+ 		/* should not have got here */
+ 		WARN_ON(1);
+ 		break;
+ 	}
+ 	return NULL;
+ }
+ 
+ #endif /* CONFIG_MODULES */
+ 
++>>>>>>> 3a0af8fd61f9 (bpf: BPF for lightweight tunnel infrastructure)
  struct lwtunnel_state *lwtunnel_state_alloc(int encap_len)
  {
  	struct lwtunnel_state *lws;
* Unmerged path kernel/bpf/verifier.c
diff --git a/include/linux/filter.h b/include/linux/filter.h
index d322ed880333..01e11cefd566 100644
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@ -47,7 +47,7 @@ struct xdp_buff {
 };
 
 /* compute the linear packet data range [data, data_end) which
- * will be accessed by cls_bpf and act_bpf programs
+ * will be accessed by cls_bpf, act_bpf and lwt programs
  */
 static inline unsigned int sk_filter_len(const struct sk_filter *fp)
 {
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path include/uapi/linux/lwtunnel.h
* Unmerged path kernel/bpf/verifier.c
diff --git a/net/Kconfig b/net/Kconfig
index 6019eecc5f21..f0e69ac88884 100644
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -361,6 +361,14 @@ config LWTUNNEL
 	  weight tunnel endpoint. Tunnel encapsulation parameters are stored
 	  with light weight tunnel state associated with fib routes.
 
+config LWTUNNEL_BPF
+	bool "Execute BPF program as route nexthop action"
+	depends on LWTUNNEL
+	default y if LWTUNNEL=y
+	---help---
+	  Allows to run BPF programs as a nexthop action following a route
+	  lookup for incoming and outgoing packets.
+
 config DST_CACHE
 	bool
 	default n
diff --git a/net/core/Makefile b/net/core/Makefile
index 149101a792d7..4b2a39cf6830 100644
--- a/net/core/Makefile
+++ b/net/core/Makefile
@@ -23,5 +23,6 @@ obj-$(CONFIG_NET_DROP_MONITOR) += drop_monitor.o
 obj-$(CONFIG_NETWORK_PHY_TIMESTAMPING) += timestamping.o
 obj-$(CONFIG_NETPRIO_CGROUP) += netprio_cgroup.o
 obj-$(CONFIG_LWTUNNEL) += lwtunnel.o
+obj-$(CONFIG_LWTUNNEL_BPF) += lwt_bpf.o
 obj-$(CONFIG_DST_CACHE) += dst_cache.o
 obj-$(CONFIG_NET_DEVLINK) += devlink.o
* Unmerged path net/core/filter.c
diff --git a/net/core/lwt_bpf.c b/net/core/lwt_bpf.c
new file mode 100644
index 000000000000..71bb3e2eca08
--- /dev/null
+++ b/net/core/lwt_bpf.c
@@ -0,0 +1,396 @@
+/* Copyright (c) 2016 Thomas Graf <tgraf@tgraf.ch>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/types.h>
+#include <linux/bpf.h>
+#include <net/lwtunnel.h>
+
+struct bpf_lwt_prog {
+	struct bpf_prog *prog;
+	char *name;
+};
+
+struct bpf_lwt {
+	struct bpf_lwt_prog in;
+	struct bpf_lwt_prog out;
+	struct bpf_lwt_prog xmit;
+	int family;
+};
+
+#define MAX_PROG_NAME 256
+
+static inline struct bpf_lwt *bpf_lwt_lwtunnel(struct lwtunnel_state *lwt)
+{
+	return (struct bpf_lwt *)lwt->data;
+}
+
+#define NO_REDIRECT false
+#define CAN_REDIRECT true
+
+static int run_lwt_bpf(struct sk_buff *skb, struct bpf_lwt_prog *lwt,
+		       struct dst_entry *dst, bool can_redirect)
+{
+	int ret;
+
+	/* Preempt disable is needed to protect per-cpu redirect_info between
+	 * BPF prog and skb_do_redirect(). The call_rcu in bpf_prog_put() and
+	 * access to maps strictly require a rcu_read_lock() for protection,
+	 * mixing with BH RCU lock doesn't work.
+	 */
+	preempt_disable();
+	rcu_read_lock();
+	bpf_compute_data_end(skb);
+	ret = bpf_prog_run_save_cb(lwt->prog, skb);
+	rcu_read_unlock();
+
+	switch (ret) {
+	case BPF_OK:
+		break;
+
+	case BPF_REDIRECT:
+		if (unlikely(!can_redirect)) {
+			pr_warn_once("Illegal redirect return code in prog %s\n",
+				     lwt->name ? : "<unknown>");
+			ret = BPF_OK;
+		} else {
+			ret = skb_do_redirect(skb);
+			if (ret == 0)
+				ret = BPF_REDIRECT;
+		}
+		break;
+
+	case BPF_DROP:
+		kfree_skb(skb);
+		ret = -EPERM;
+		break;
+
+	default:
+		pr_warn_once("bpf-lwt: Illegal return value %u, expect packet loss\n", ret);
+		kfree_skb(skb);
+		ret = -EINVAL;
+		break;
+	}
+
+	preempt_enable();
+
+	return ret;
+}
+
+static int bpf_input(struct sk_buff *skb)
+{
+	struct dst_entry *dst = skb_dst(skb);
+	struct bpf_lwt *bpf;
+	int ret;
+
+	bpf = bpf_lwt_lwtunnel(dst->lwtstate);
+	if (bpf->in.prog) {
+		ret = run_lwt_bpf(skb, &bpf->in, dst, NO_REDIRECT);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (unlikely(!dst->lwtstate->orig_input)) {
+		pr_warn_once("orig_input not set on dst for prog %s\n",
+			     bpf->out.name);
+		kfree_skb(skb);
+		return -EINVAL;
+	}
+
+	return dst->lwtstate->orig_input(skb);
+}
+
+static int bpf_output(struct net *net, struct sock *sk, struct sk_buff *skb)
+{
+	struct dst_entry *dst = skb_dst(skb);
+	struct bpf_lwt *bpf;
+	int ret;
+
+	bpf = bpf_lwt_lwtunnel(dst->lwtstate);
+	if (bpf->out.prog) {
+		ret = run_lwt_bpf(skb, &bpf->out, dst, NO_REDIRECT);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (unlikely(!dst->lwtstate->orig_output)) {
+		pr_warn_once("orig_output not set on dst for prog %s\n",
+			     bpf->out.name);
+		kfree_skb(skb);
+		return -EINVAL;
+	}
+
+	return dst->lwtstate->orig_output(net, sk, skb);
+}
+
+static int xmit_check_hhlen(struct sk_buff *skb)
+{
+	int hh_len = skb_dst(skb)->dev->hard_header_len;
+
+	if (skb_headroom(skb) < hh_len) {
+		int nhead = HH_DATA_ALIGN(hh_len - skb_headroom(skb));
+
+		if (pskb_expand_head(skb, nhead, 0, GFP_ATOMIC))
+			return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int bpf_xmit(struct sk_buff *skb)
+{
+	struct dst_entry *dst = skb_dst(skb);
+	struct bpf_lwt *bpf;
+
+	bpf = bpf_lwt_lwtunnel(dst->lwtstate);
+	if (bpf->xmit.prog) {
+		int ret;
+
+		ret = run_lwt_bpf(skb, &bpf->xmit, dst, CAN_REDIRECT);
+		switch (ret) {
+		case BPF_OK:
+			/* If the header was expanded, headroom might be too
+			 * small for L2 header to come, expand as needed.
+			 */
+			ret = xmit_check_hhlen(skb);
+			if (unlikely(ret))
+				return ret;
+
+			return LWTUNNEL_XMIT_CONTINUE;
+		case BPF_REDIRECT:
+			return LWTUNNEL_XMIT_DONE;
+		default:
+			return ret;
+		}
+	}
+
+	return LWTUNNEL_XMIT_CONTINUE;
+}
+
+static void bpf_lwt_prog_destroy(struct bpf_lwt_prog *prog)
+{
+	if (prog->prog)
+		bpf_prog_put(prog->prog);
+
+	kfree(prog->name);
+}
+
+static void bpf_destroy_state(struct lwtunnel_state *lwt)
+{
+	struct bpf_lwt *bpf = bpf_lwt_lwtunnel(lwt);
+
+	bpf_lwt_prog_destroy(&bpf->in);
+	bpf_lwt_prog_destroy(&bpf->out);
+	bpf_lwt_prog_destroy(&bpf->xmit);
+}
+
+static const struct nla_policy bpf_prog_policy[LWT_BPF_PROG_MAX + 1] = {
+	[LWT_BPF_PROG_FD]   = { .type = NLA_U32, },
+	[LWT_BPF_PROG_NAME] = { .type = NLA_NUL_STRING,
+				.len = MAX_PROG_NAME },
+};
+
+static int bpf_parse_prog(struct nlattr *attr, struct bpf_lwt_prog *prog,
+			  enum bpf_prog_type type)
+{
+	struct nlattr *tb[LWT_BPF_PROG_MAX + 1];
+	struct bpf_prog *p;
+	int ret;
+	u32 fd;
+
+	ret = nla_parse_nested(tb, LWT_BPF_PROG_MAX, attr, bpf_prog_policy);
+	if (ret < 0)
+		return ret;
+
+	if (!tb[LWT_BPF_PROG_FD] || !tb[LWT_BPF_PROG_NAME])
+		return -EINVAL;
+
+	prog->name = nla_memdup(tb[LWT_BPF_PROG_NAME], GFP_KERNEL);
+	if (!prog->name)
+		return -ENOMEM;
+
+	fd = nla_get_u32(tb[LWT_BPF_PROG_FD]);
+	p = bpf_prog_get_type(fd, type);
+	if (IS_ERR(p))
+		return PTR_ERR(p);
+
+	prog->prog = p;
+
+	return 0;
+}
+
+static const struct nla_policy bpf_nl_policy[LWT_BPF_MAX + 1] = {
+	[LWT_BPF_IN]		= { .type = NLA_NESTED, },
+	[LWT_BPF_OUT]		= { .type = NLA_NESTED, },
+	[LWT_BPF_XMIT]		= { .type = NLA_NESTED, },
+	[LWT_BPF_XMIT_HEADROOM]	= { .type = NLA_U32 },
+};
+
+static int bpf_build_state(struct net_device *dev, struct nlattr *nla,
+			   unsigned int family, const void *cfg,
+			   struct lwtunnel_state **ts)
+{
+	struct nlattr *tb[LWT_BPF_MAX + 1];
+	struct lwtunnel_state *newts;
+	struct bpf_lwt *bpf;
+	int ret;
+
+	if (family != AF_INET && family != AF_INET6)
+		return -EAFNOSUPPORT;
+
+	ret = nla_parse_nested(tb, LWT_BPF_MAX, nla, bpf_nl_policy);
+	if (ret < 0)
+		return ret;
+
+	if (!tb[LWT_BPF_IN] && !tb[LWT_BPF_OUT] && !tb[LWT_BPF_XMIT])
+		return -EINVAL;
+
+	newts = lwtunnel_state_alloc(sizeof(*bpf));
+	if (!newts)
+		return -ENOMEM;
+
+	newts->type = LWTUNNEL_ENCAP_BPF;
+	bpf = bpf_lwt_lwtunnel(newts);
+
+	if (tb[LWT_BPF_IN]) {
+		newts->flags |= LWTUNNEL_STATE_INPUT_REDIRECT;
+		ret = bpf_parse_prog(tb[LWT_BPF_IN], &bpf->in,
+				     BPF_PROG_TYPE_LWT_IN);
+		if (ret  < 0)
+			goto errout;
+	}
+
+	if (tb[LWT_BPF_OUT]) {
+		newts->flags |= LWTUNNEL_STATE_OUTPUT_REDIRECT;
+		ret = bpf_parse_prog(tb[LWT_BPF_OUT], &bpf->out,
+				     BPF_PROG_TYPE_LWT_OUT);
+		if (ret < 0)
+			goto errout;
+	}
+
+	if (tb[LWT_BPF_XMIT]) {
+		newts->flags |= LWTUNNEL_STATE_XMIT_REDIRECT;
+		ret = bpf_parse_prog(tb[LWT_BPF_XMIT], &bpf->xmit,
+				     BPF_PROG_TYPE_LWT_XMIT);
+		if (ret < 0)
+			goto errout;
+	}
+
+	if (tb[LWT_BPF_XMIT_HEADROOM]) {
+		u32 headroom = nla_get_u32(tb[LWT_BPF_XMIT_HEADROOM]);
+
+		if (headroom > LWT_BPF_MAX_HEADROOM) {
+			ret = -ERANGE;
+			goto errout;
+		}
+
+		newts->headroom = headroom;
+	}
+
+	bpf->family = family;
+	*ts = newts;
+
+	return 0;
+
+errout:
+	bpf_destroy_state(newts);
+	kfree(newts);
+	return ret;
+}
+
+static int bpf_fill_lwt_prog(struct sk_buff *skb, int attr,
+			     struct bpf_lwt_prog *prog)
+{
+	struct nlattr *nest;
+
+	if (!prog->prog)
+		return 0;
+
+	nest = nla_nest_start(skb, attr);
+	if (!nest)
+		return -EMSGSIZE;
+
+	if (prog->name &&
+	    nla_put_string(skb, LWT_BPF_PROG_NAME, prog->name))
+		return -EMSGSIZE;
+
+	return nla_nest_end(skb, nest);
+}
+
+static int bpf_fill_encap_info(struct sk_buff *skb, struct lwtunnel_state *lwt)
+{
+	struct bpf_lwt *bpf = bpf_lwt_lwtunnel(lwt);
+
+	if (bpf_fill_lwt_prog(skb, LWT_BPF_IN, &bpf->in) < 0 ||
+	    bpf_fill_lwt_prog(skb, LWT_BPF_OUT, &bpf->out) < 0 ||
+	    bpf_fill_lwt_prog(skb, LWT_BPF_XMIT, &bpf->xmit) < 0)
+		return -EMSGSIZE;
+
+	return 0;
+}
+
+static int bpf_encap_nlsize(struct lwtunnel_state *lwtstate)
+{
+	int nest_len = nla_total_size(sizeof(struct nlattr)) +
+		       nla_total_size(MAX_PROG_NAME) + /* LWT_BPF_PROG_NAME */
+		       0;
+
+	return nest_len + /* LWT_BPF_IN */
+	       nest_len + /* LWT_BPF_OUT */
+	       nest_len + /* LWT_BPF_XMIT */
+	       0;
+}
+
+int bpf_lwt_prog_cmp(struct bpf_lwt_prog *a, struct bpf_lwt_prog *b)
+{
+	/* FIXME:
+	 * The LWT state is currently rebuilt for delete requests which
+	 * results in a new bpf_prog instance. Comparing names for now.
+	 */
+	if (!a->name && !b->name)
+		return 0;
+
+	if (!a->name || !b->name)
+		return 1;
+
+	return strcmp(a->name, b->name);
+}
+
+static int bpf_encap_cmp(struct lwtunnel_state *a, struct lwtunnel_state *b)
+{
+	struct bpf_lwt *a_bpf = bpf_lwt_lwtunnel(a);
+	struct bpf_lwt *b_bpf = bpf_lwt_lwtunnel(b);
+
+	return bpf_lwt_prog_cmp(&a_bpf->in, &b_bpf->in) ||
+	       bpf_lwt_prog_cmp(&a_bpf->out, &b_bpf->out) ||
+	       bpf_lwt_prog_cmp(&a_bpf->xmit, &b_bpf->xmit);
+}
+
+static const struct lwtunnel_encap_ops bpf_encap_ops = {
+	.build_state	= bpf_build_state,
+	.destroy_state	= bpf_destroy_state,
+	.input		= bpf_input,
+	.output		= bpf_output,
+	.xmit		= bpf_xmit,
+	.fill_encap	= bpf_fill_encap_info,
+	.get_encap_size = bpf_encap_nlsize,
+	.cmp_encap	= bpf_encap_cmp,
+};
+
+static int __init bpf_lwt_init(void)
+{
+	return lwtunnel_encap_add_ops(&bpf_encap_ops, LWTUNNEL_ENCAP_BPF);
+}
+
+subsys_initcall(bpf_lwt_init)
* Unmerged path net/core/lwtunnel.c
