ext4: always verify the magic number in xattr blocks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit 513f86d73855ce556ea9522b6bfd79f87356dc3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/513f86d7.failed

If there an inode points to a block which is also some other type of
metadata block (such as a block allocation bitmap), the
buffer_verified flag can be set when it was validated as that other
metadata block type; however, it would make a really terrible external
attribute block.  The reason why we use the verified flag is to avoid
constantly reverifying the block.  However, it doesn't take much
overhead to make sure the magic number of the xattr block is correct,
and this will avoid potential crashes.

This addresses CVE-2018-10879.

https://bugzilla.kernel.org/show_bug.cgi?id=200001

	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Reviewed-by: Andreas Dilger <adilger@dilger.ca>
	Cc: stable@kernel.org
(cherry picked from commit 513f86d73855ce556ea9522b6bfd79f87356dc3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/xattr.c
diff --cc fs/ext4/xattr.c
index d7ce9e3d8174,0263692979ec..000000000000
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@@ -213,21 -225,28 +213,36 @@@ ext4_xattr_check_names(struct ext4_xatt
  }
  
  static inline int
 -__ext4_xattr_check_block(struct inode *inode, struct buffer_head *bh,
 -			 const char *function, unsigned int line)
 +ext4_xattr_check_block(struct inode *inode, struct buffer_head *bh)
  {
 -	int error = -EFSCORRUPTED;
 +	int error;
  
- 	if (buffer_verified(bh))
- 		return 0;
- 
  	if (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||
  	    BHDR(bh)->h_blocks != cpu_to_le32(1))
++<<<<<<< HEAD
 +		return -EIO;
 +	if (!ext4_xattr_block_csum_verify(inode, bh->b_blocknr, BHDR(bh)))
 +		return -EIO;
 +	error = ext4_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size,
 +				       bh->b_data);
 +	if (!error)
++=======
+ 		goto errout;
+ 	if (buffer_verified(bh))
+ 		return 0;
+ 
+ 	error = -EFSBADCRC;
+ 	if (!ext4_xattr_block_csum_verify(inode, bh))
+ 		goto errout;
+ 	error = ext4_xattr_check_entries(BFIRST(bh), bh->b_data + bh->b_size,
+ 					 bh->b_data);
+ errout:
+ 	if (error)
+ 		__ext4_error_inode(inode, function, line, 0,
+ 				   "corrupted xattr block %llu",
+ 				   (unsigned long long) bh->b_blocknr);
+ 	else
++>>>>>>> 513f86d73855 (ext4: always verify the magic number in xattr blocks)
  		set_buffer_verified(bh);
  	return error;
  }
* Unmerged path fs/ext4/xattr.c
