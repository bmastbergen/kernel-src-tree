blk-mq: use the introduced blk_mq_unquiesce_queue()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [blk-mq] use the introduced blk_mq_unquiesce_queue() (Ewan Milne) [1549232]
Rebuild_FUZZ: 91.49%
commit-author Ming Lei <ming.lei@redhat.com>
commit f660174e8bcdb2bf99129f9f7c86e5fc0e830f85
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f660174e.failed

blk_mq_unquiesce_queue() is used for unquiescing the
queue explicitly, so replace blk_mq_start_stopped_hw_queues()
with it.

For the scsi part, this patch takes Bart's suggestion to
switch to block quiesce/unquiesce API completely.

	Cc: linux-nvme@lists.infradead.org
	Cc: linux-scsi@vger.kernel.org
	Cc: dm-devel@redhat.com
	Reviewed-by: Bart Van Assche <Bart.VanAssche@sandisk.com>
	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit f660174e8bcdb2bf99129f9f7c86e5fc0e830f85)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index d4f7dcb0ad7b,05f713e866f6..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -2636,8 -2672,8 +2636,13 @@@ void nvme_start_queues(struct nvme_ctr
  
  	mutex_lock(&ctrl->namespaces_mutex);
  	list_for_each_entry(ns, &ctrl->namespaces, list) {
++<<<<<<< HEAD
 +		queue_flag_clear_unlocked(QUEUE_FLAG_STOPPED, ns->queue);
 +		blk_mq_start_stopped_hw_queues(ns->queue, true);
++=======
+ 		blk_mq_unquiesce_queue(ns->queue);
+ 		blk_mq_kick_requeue_list(ns->queue);
++>>>>>>> f660174e8bcd (blk-mq: use the introduced blk_mq_unquiesce_queue())
  	}
  	mutex_unlock(&ctrl->namespaces_mutex);
  }
diff --git a/drivers/md/dm-rq.c b/drivers/md/dm-rq.c
index d5df417cac04..8079afe134ef 100644
--- a/drivers/md/dm-rq.c
+++ b/drivers/md/dm-rq.c
@@ -71,7 +71,7 @@ static void dm_old_start_queue(struct request_queue *q)
 
 static void dm_mq_start_queue(struct request_queue *q)
 {
-	blk_mq_start_stopped_hw_queues(q, true);
+	blk_mq_unquiesce_queue(q);
 	blk_mq_kick_requeue_list(q);
 }
 
* Unmerged path drivers/nvme/host/core.c
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index e0f2e99b8896..8d3d0ceb31cb 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -2886,7 +2886,7 @@ scsi_internal_device_block_internal(struct scsi_device *sdev, bool wait)
 		if (wait)
 			blk_mq_quiesce_queue(q);
 		else
-			blk_mq_stop_hw_queues(q);
+			blk_mq_quiesce_queue_nowait(q);
 	} else {
 		spin_lock_irqsave(q->queue_lock, flags);
 		blk_stop_queue(q);
@@ -2953,7 +2953,7 @@ scsi_internal_device_unblock(struct scsi_device *sdev,
 		return -EINVAL;
 
 	if (q->mq_ops) {
-		blk_mq_start_stopped_hw_queues(q, false);
+		blk_mq_unquiesce_queue(q);
 	} else {
 		spin_lock_irqsave(q->queue_lock, flags);
 		blk_start_queue(q);
