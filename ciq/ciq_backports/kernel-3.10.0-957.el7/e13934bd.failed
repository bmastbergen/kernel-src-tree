mmc: core/mmci: restore pre/post_req behaviour

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] core/mmci: restore pre/post_req behaviour (Gopal Tiwari) [1549495]
Rebuild_FUZZ: 94.25%
commit-author Linus Walleij <linus.walleij@linaro.org>
commit e13934bdf45935f51243515c275629922dc43839
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/e13934bd.failed

commit 64b12a68a9f74bb32d8efd7af1ad8a2ba02fc884
"mmc: core: fix prepared requests while doing bkops"
is fixing a bug in the wrong way. A bug in the MMCI
device driver is fixed by amending the MMC core.

Thinking about it: what the pre- and post-callbacks
are doing is to essentially map and unmap SG lists
for DMA transfers. Why would we not be able to do that
just because a BKOPS command is sent inbetween?
Having to unprepare/prepare the next asynchronous
request for DMA seems wrong.

Looking the backtrace in that commit we can see what
the real problem actually is:

mmci_data_irq() is calling mmci_dma_unmap() twice
which is goung to call arm_dma_unmap_sg() twice
and v7_dma_inv_range() twice for the same sglist
and that will crash.

This happens because a request is prepared, then
a BKOPS is sent. The IRQ completing the BKOPS command
goes through mmci_data_irq() and thinks that a DMA
operation has just been completed because
dma_inprogress() reports true. It then proceeds to
unmap the sglist.

But that was wrong! dma_inprogress() should NOT be
true because no DMA was actually in progress! We had
just prepared the sglist, and the DMA channel
dma_current has been configured, but NOT started!

Because of this, the sglist is already unmapped when
we get our actual data completion IRQ, and we are
unmapping the sglist once more, and we get this crash.

Therefore, we need to revert this solution pushing
the problem to the core and causing problems, and
instead augment the implementation such that
dma_inprogress() only reports true if some DMA has
actually been started.

After this we can keep the request prepared during the
BKOPS and we need not unprepare/reprepare it.

Fixes: 64b12a68a9f7 ("mmc: core: fix prepared requests while doing bkops")
	Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
	Tested-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit e13934bdf45935f51243515c275629922dc43839)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/mmci.c
diff --cc drivers/mmc/host/mmci.c
index f4f3038c1df0,0c6420bb2f00..000000000000
--- a/drivers/mmc/host/mmci.c
+++ b/drivers/mmc/host/mmci.c
@@@ -616,8 -740,17 +619,19 @@@ static void mmci_post_request(struct mm
  			chan = host->dma_tx_channel;
  		dmaengine_terminate_all(chan);
  
++<<<<<<< HEAD
++=======
+ 		if (host->dma_desc_current == next->dma_desc)
+ 			host->dma_desc_current = NULL;
+ 
+ 		if (host->dma_current == next->dma_chan) {
+ 			host->dma_in_progress = false;
+ 			host->dma_current = NULL;
+ 		}
+ 
++>>>>>>> e13934bdf459 (mmc: core/mmci: restore pre/post_req behaviour)
  		next->dma_desc = NULL;
  		next->dma_chan = NULL;
 -		data->host_cookie = 0;
  	}
  }
  
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 2669557edd36..7074f7432cc8 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -674,16 +674,7 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 		    ((mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1) ||
 		     (mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1B)) &&
 		    (host->areq->mrq->cmd->resp[0] & R1_EXCEPTION_EVENT)) {
-
-			/* Cancel the prepared request */
-			if (areq)
-				mmc_post_req(host, areq->mrq, -EINVAL);
-
 			mmc_start_bkops(host->card, true);
-
-			/* prepare the request again */
-			if (areq)
-				mmc_pre_req(host, areq->mrq);
 		}
 	}
 
* Unmerged path drivers/mmc/host/mmci.c
diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index 1f33ad5333a0..14bc8126904b 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -207,8 +207,9 @@ struct mmci_host {
 	struct dma_chan		*dma_tx_channel;
 	struct dma_async_tx_descriptor	*dma_desc_current;
 	struct mmci_host_next	next_data;
+	bool			dma_in_progress;
 
-#define dma_inprogress(host)	((host)->dma_current)
+#define dma_inprogress(host)	((host)->dma_in_progress)
 #else
 #define dma_inprogress(host)	(0)
 #endif
