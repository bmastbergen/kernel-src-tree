netfilter: ipset: Fix hash type expire: release empty hash bucket block

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 0aae24eb409fc429f54ca3809f904f1b91e295e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0aae24eb.failed

When all entries are expired/all slots are empty, release the bucket.

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 0aae24eb409fc429f54ca3809f904f1b91e295e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_hash_gen.h
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 9ce28af662bf,e5336ab36d67..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -433,43 -471,54 +433,60 @@@ mtype_same_set(const struct ip_set *a, 
  	       a->extensions == b->extensions;
  }
  
 +/* Get the ith element from the array block n */
 +#define ahash_data(n, i, dsize)	\
 +	((struct mtype_elem *)((n)->value + ((i) * (dsize))))
 +
  /* Delete expired elements from the hashtable */
  static void
 -mtype_expire(struct ip_set *set, struct htype *h, u8 nets_length, size_t dsize)
 +mtype_expire(struct htype *h, u8 nets_length, size_t dsize)
  {
++<<<<<<< HEAD
 +	struct htable *t = h->table;
 +	struct hbucket *n;
++=======
+ 	struct htable *t;
+ 	struct hbucket *n, *tmp;
++>>>>>>> 0aae24eb409f (netfilter: ipset: Fix hash type expire: release empty hash bucket block)
  	struct mtype_elem *data;
 -	u32 i, j, d;
 -#ifdef IP_SET_HASH_WITH_NETS
 -	u8 k;
 -#endif
 +	u32 i;
 +	int j;
  
 -	t = ipset_dereference_protected(h->table, set);
  	for (i = 0; i < jhash_size(t->htable_bits); i++) {
 -		n = __ipset_dereference_protected(hbucket(t, i), 1);
 -		if (!n)
 -			continue;
 -		for (j = 0, d = 0; j < n->pos; j++) {
 -			if (!test_bit(j, n->used)) {
 -				d++;
 -				continue;
 -			}
 +		n = hbucket(t, i);
 +		for (j = 0; j < n->pos; j++) {
  			data = ahash_data(n, j, dsize);
 -			if (ip_set_timeout_expired(ext_timeout(data, set))) {
 +			if (ip_set_timeout_expired(ext_timeout(data, h))) {
  				pr_debug("expired %u/%u\n", i, j);
 -				clear_bit(j, n->used);
 -				smp_mb__after_atomic();
  #ifdef IP_SET_HASH_WITH_NETS
 -				for (k = 0; k < IPSET_NET_COUNT; k++)
 -					mtype_del_cidr(h,
 -						NCIDR_PUT(DCIDR_GET(data->cidr,
 -								    k)),
 -						nets_length, k);
 +				mtype_del_cidr(h, CIDR(data->cidr),
 +					       nets_length);
  #endif
 -				ip_set_ext_destroy(set, data);
 +				if (j != n->pos - 1)
 +					/* Not last one */
 +					memcpy(data,
 +					       ahash_data(n, n->pos - 1, dsize),
 +					       dsize);
 +				n->pos--;
  				h->elements--;
 -				d++;
  			}
  		}
++<<<<<<< HEAD
 +		if (n->pos + AHASH_INIT_SIZE < n->size) {
 +			void *tmp = kzalloc((n->size - AHASH_INIT_SIZE)
 +					    * dsize,
 +					    GFP_ATOMIC);
++=======
+ 		if (d >= AHASH_INIT_SIZE) {
+ 			if (d >= n->size) {
+ 				rcu_assign_pointer(hbucket(t, i), NULL);
+ 				kfree_rcu(n, rcu);
+ 				continue;
+ 			}
+ 			tmp = kzalloc(sizeof(*tmp) +
+ 				      (n->size - AHASH_INIT_SIZE) * dsize,
+ 				      GFP_ATOMIC);
++>>>>>>> 0aae24eb409f (netfilter: ipset: Fix hash type expire: release empty hash bucket block)
  			if (!tmp)
  				/* Still try to delete expired elements */
  				continue;
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
