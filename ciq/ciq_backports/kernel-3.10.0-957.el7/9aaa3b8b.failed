thunderbolt: Add support for preboot ACL

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 9aaa3b8b4c56d24210acef37b7c800ca218c3d40
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9aaa3b8b.failed

Preboot ACL is a mechanism that allows connecting Thunderbolt devices
boot time in more secure way than the legacy Thunderbolt boot support.
As with the legacy boot option, this also needs to be enabled from the
BIOS before booting is allowed. Difference to the legacy mode is that
the userspace software explicitly adds device UUIDs by sending a special
message to the ICM firmware. Only the devices listed in the boot ACL are
connected automatically during the boot. This works in both "user" and
"secure" security levels.

We implement this in Linux by exposing a new sysfs attribute (boot_acl)
below each Thunderbolt domain. The userspace software can then update
the full list as needed.

	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
(cherry picked from commit 9aaa3b8b4c56d24210acef37b7c800ca218c3d40)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/thunderbolt/icm.c
#	drivers/thunderbolt/tb_msgs.h
diff --cc drivers/thunderbolt/icm.c
index 675365e444f0,93a198a17f42..000000000000
--- a/drivers/thunderbolt/icm.c
+++ b/drivers/thunderbolt/icm.c
@@@ -70,6 -76,9 +72,12 @@@ struct icm 
  	bool (*is_supported)(struct tb *tb);
  	int (*get_mode)(struct tb *tb);
  	int (*get_route)(struct tb *tb, u8 link, u8 depth, u64 *route);
++<<<<<<< HEAD
++=======
+ 	int (*driver_ready)(struct tb *tb,
+ 			    enum tb_security_level *security_level,
+ 			    size_t *nboot_acl);
++>>>>>>> 9aaa3b8b4c56 (thunderbolt: Add support for preboot ACL)
  	void (*device_connected)(struct tb *tb,
  				 const struct icm_pkg_header *hdr);
  	void (*device_disconnected)(struct tb *tb,
@@@ -241,6 -252,28 +249,31 @@@ err_free
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ icm_fr_driver_ready(struct tb *tb, enum tb_security_level *security_level,
+ 		    size_t *nboot_acl)
+ {
+ 	struct icm_fr_pkg_driver_ready_response reply;
+ 	struct icm_pkg_driver_ready request = {
+ 		.hdr.code = ICM_DRIVER_READY,
+ 	};
+ 	int ret;
+ 
+ 	memset(&reply, 0, sizeof(reply));
+ 	ret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),
+ 			  1, ICM_TIMEOUT);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (security_level)
+ 		*security_level = reply.security_level & ICM_FR_SLEVEL_MASK;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 9aaa3b8b4c56 (thunderbolt: Add support for preboot ACL)
  static int icm_fr_approve_switch(struct tb *tb, struct tb_switch *sw)
  {
  	struct icm_fr_pkg_approve_device request;
@@@ -624,23 -1004,18 +762,30 @@@ static void icm_handle_event(struct tb 
  }
  
  static int
- __icm_driver_ready(struct tb *tb, enum tb_security_level *security_level)
+ __icm_driver_ready(struct tb *tb, enum tb_security_level *security_level,
+ 		   size_t *nboot_acl)
  {
 -	struct icm *icm = tb_priv(tb);
 +	struct icm_pkg_driver_ready_response reply;
 +	struct icm_pkg_driver_ready request = {
 +		.hdr.code = ICM_DRIVER_READY,
 +	};
  	unsigned int retries = 50;
  	int ret;
  
++<<<<<<< HEAD
 +	memset(&reply, 0, sizeof(reply));
 +	ret = icm_request(tb, &request, sizeof(request), &reply, sizeof(reply),
 +			  1, ICM_TIMEOUT);
 +	if (ret)
++=======
+ 	ret = icm->driver_ready(tb, security_level, nboot_acl);
+ 	if (ret) {
+ 		tb_err(tb, "failed to send driver ready to ICM\n");
++>>>>>>> 9aaa3b8b4c56 (thunderbolt: Add support for preboot ACL)
  		return ret;
 -	}
 +
 +	if (security_level)
 +		*security_level = reply.security_level & 0xf;
  
  	/*
  	 * Hold on here until the switch config space is accessible so
@@@ -1051,8 -1450,28 +1207,26 @@@ static const struct tb_cm_ops icm_fr_op
  	.add_switch_key = icm_fr_add_switch_key,
  	.challenge_switch_key = icm_fr_challenge_switch_key,
  	.disconnect_pcie_paths = icm_disconnect_pcie_paths,
 -	.approve_xdomain_paths = icm_fr_approve_xdomain_paths,
 -	.disconnect_xdomain_paths = icm_fr_disconnect_xdomain_paths,
  };
  
+ /* Alpine Ridge */
+ static const struct tb_cm_ops icm_ar_ops = {
+ 	.driver_ready = icm_driver_ready,
+ 	.start = icm_start,
+ 	.stop = icm_stop,
+ 	.suspend = icm_suspend,
+ 	.complete = icm_complete,
+ 	.handle_event = icm_handle_event,
+ 	.get_boot_acl = icm_ar_get_boot_acl,
+ 	.set_boot_acl = icm_ar_set_boot_acl,
+ 	.approve_switch = icm_fr_approve_switch,
+ 	.add_switch_key = icm_fr_add_switch_key,
+ 	.challenge_switch_key = icm_fr_challenge_switch_key,
+ 	.disconnect_pcie_paths = icm_disconnect_pcie_paths,
+ 	.approve_xdomain_paths = icm_fr_approve_xdomain_paths,
+ 	.disconnect_xdomain_paths = icm_fr_disconnect_xdomain_paths,
+ };
+ 
  struct tb *icm_probe(struct tb_nhi *nhi)
  {
  	struct icm *icm;
@@@ -1084,9 -1507,12 +1259,18 @@@
  		icm->is_supported = icm_ar_is_supported;
  		icm->get_mode = icm_ar_get_mode;
  		icm->get_route = icm_ar_get_route;
++<<<<<<< HEAD
 +		icm->device_connected = icm_fr_device_connected;
 +		icm->device_disconnected = icm_fr_device_disconnected;
 +		tb->cm_ops = &icm_fr_ops;
++=======
+ 		icm->driver_ready = icm_ar_driver_ready;
+ 		icm->device_connected = icm_fr_device_connected;
+ 		icm->device_disconnected = icm_fr_device_disconnected;
+ 		icm->xdomain_connected = icm_fr_xdomain_connected;
+ 		icm->xdomain_disconnected = icm_fr_xdomain_disconnected;
+ 		tb->cm_ops = &icm_ar_ops;
++>>>>>>> 9aaa3b8b4c56 (thunderbolt: Add support for preboot ACL)
  		break;
  	}
  
diff --cc drivers/thunderbolt/tb_msgs.h
index fe3039b05da6,496b91f3b579..000000000000
--- a/drivers/thunderbolt/tb_msgs.h
+++ b/drivers/thunderbolt/tb_msgs.h
@@@ -101,6 -101,8 +101,11 @@@ enum icm_pkg_code 
  	ICM_CHALLENGE_DEVICE = 0x5,
  	ICM_ADD_DEVICE_KEY = 0x6,
  	ICM_GET_ROUTE = 0xa,
++<<<<<<< HEAD
++=======
+ 	ICM_APPROVE_XDOMAIN = 0x10,
+ 	ICM_PREBOOT_ACL = 0x18,
++>>>>>>> 9aaa3b8b4c56 (thunderbolt: Add support for preboot ACL)
  };
  
  enum icm_event_code {
@@@ -122,20 -127,24 +128,28 @@@ struct icm_pkg_header 
  
  struct icm_pkg_driver_ready {
  	struct icm_pkg_header hdr;
 -};
 +} __packed;
  
++<<<<<<< HEAD
 +struct icm_pkg_driver_ready_response {
++=======
+ /* Falcon Ridge only messages */
+ 
+ struct icm_fr_pkg_driver_ready_response {
++>>>>>>> 9aaa3b8b4c56 (thunderbolt: Add support for preboot ACL)
  	struct icm_pkg_header hdr;
  	u8 romver;
  	u8 ramver;
  	u16 security_level;
 -};
 +} __packed;
  
 -#define ICM_FR_SLEVEL_MASK		0xf
 +/* Falcon Ridge & Alpine Ridge common messages */
  
+ /* Falcon Ridge & Alpine Ridge common messages */
+ 
  struct icm_fr_pkg_get_topology {
  	struct icm_pkg_header hdr;
 -};
 +} __packed;
  
  #define ICM_GET_TOPOLOGY_PACKETS	14
  
@@@ -238,6 -302,102 +264,106 @@@ struct icm_ar_pkg_get_route_response 
  	u16 link_info;
  	u32 route_hi;
  	u32 route_lo;
++<<<<<<< HEAD
 +} __packed;
++=======
+ };
+ 
+ struct icm_ar_boot_acl_entry {
+ 	u32 uuid_lo;
+ 	u32 uuid_hi;
+ };
+ 
+ #define ICM_AR_PREBOOT_ACL_ENTRIES	16
+ 
+ struct icm_ar_pkg_preboot_acl {
+ 	struct icm_pkg_header hdr;
+ 	struct icm_ar_boot_acl_entry acl[ICM_AR_PREBOOT_ACL_ENTRIES];
+ };
+ 
+ struct icm_ar_pkg_preboot_acl_response {
+ 	struct icm_pkg_header hdr;
+ 	struct icm_ar_boot_acl_entry acl[ICM_AR_PREBOOT_ACL_ENTRIES];
+ };
+ 
+ /* XDomain messages */
+ 
+ struct tb_xdomain_header {
+ 	u32 route_hi;
+ 	u32 route_lo;
+ 	u32 length_sn;
+ };
+ 
+ #define TB_XDOMAIN_LENGTH_MASK	GENMASK(5, 0)
+ #define TB_XDOMAIN_SN_MASK	GENMASK(28, 27)
+ #define TB_XDOMAIN_SN_SHIFT	27
+ 
+ enum tb_xdp_type {
+ 	UUID_REQUEST_OLD = 1,
+ 	UUID_RESPONSE = 2,
+ 	PROPERTIES_REQUEST,
+ 	PROPERTIES_RESPONSE,
+ 	PROPERTIES_CHANGED_REQUEST,
+ 	PROPERTIES_CHANGED_RESPONSE,
+ 	ERROR_RESPONSE,
+ 	UUID_REQUEST = 12,
+ };
+ 
+ struct tb_xdp_header {
+ 	struct tb_xdomain_header xd_hdr;
+ 	uuid_t uuid;
+ 	u32 type;
+ };
+ 
+ struct tb_xdp_properties {
+ 	struct tb_xdp_header hdr;
+ 	uuid_t src_uuid;
+ 	uuid_t dst_uuid;
+ 	u16 offset;
+ 	u16 reserved;
+ };
+ 
+ struct tb_xdp_properties_response {
+ 	struct tb_xdp_header hdr;
+ 	uuid_t src_uuid;
+ 	uuid_t dst_uuid;
+ 	u16 offset;
+ 	u16 data_length;
+ 	u32 generation;
+ 	u32 data[0];
+ };
+ 
+ /*
+  * Max length of data array single XDomain property response is allowed
+  * to carry.
+  */
+ #define TB_XDP_PROPERTIES_MAX_DATA_LENGTH	\
+ 	(((256 - 4 - sizeof(struct tb_xdp_properties_response))) / 4)
+ 
+ /* Maximum size of the total property block in dwords we allow */
+ #define TB_XDP_PROPERTIES_MAX_LENGTH		500
+ 
+ struct tb_xdp_properties_changed {
+ 	struct tb_xdp_header hdr;
+ 	uuid_t src_uuid;
+ };
+ 
+ struct tb_xdp_properties_changed_response {
+ 	struct tb_xdp_header hdr;
+ };
+ 
+ enum tb_xdp_error {
+ 	ERROR_SUCCESS,
+ 	ERROR_UNKNOWN_PACKET,
+ 	ERROR_UNKNOWN_DOMAIN,
+ 	ERROR_NOT_SUPPORTED,
+ 	ERROR_NOT_READY,
+ };
+ 
+ struct tb_xdp_error_response {
+ 	struct tb_xdp_header hdr;
+ 	u32 error;
+ };
++>>>>>>> 9aaa3b8b4c56 (thunderbolt: Add support for preboot ACL)
  
  #endif
diff --git a/Documentation/ABI/testing/sysfs-bus-thunderbolt b/Documentation/ABI/testing/sysfs-bus-thunderbolt
index 392bef5bd399..146359ccd32a 100644
--- a/Documentation/ABI/testing/sysfs-bus-thunderbolt
+++ b/Documentation/ABI/testing/sysfs-bus-thunderbolt
@@ -1,3 +1,26 @@
+What: /sys/bus/thunderbolt/devices/.../domainX/boot_acl
+Date:		Jun 2018
+KernelVersion:	4.17
+Contact:	thunderbolt-software@lists.01.org
+Description:	Holds a comma separated list of device unique_ids that
+		are allowed to be connected automatically during system
+		startup (e.g boot devices). The list always contains
+		maximum supported number of unique_ids where unused
+		entries are empty. This allows the userspace software
+		to determine how many entries the controller supports.
+		If there are multiple controllers, each controller has
+		its own ACL list and size may be different between the
+		controllers.
+
+		System BIOS may have an option "Preboot ACL" or similar
+		that needs to be selected before this list is taken into
+		consideration.
+
+		Software always updates a full list in each write.
+
+		If a device is authorized automatically during boot its
+		boot attribute is set to 1.
+
 What: /sys/bus/thunderbolt/devices/.../domainX/security
 Date:		Sep 2017
 KernelVersion:	4.13
diff --git a/drivers/thunderbolt/domain.c b/drivers/thunderbolt/domain.c
index 9f2dcd48974d..0dc53a72bbb7 100644
--- a/drivers/thunderbolt/domain.c
+++ b/drivers/thunderbolt/domain.c
@@ -27,6 +27,110 @@ static const char * const tb_security_names[] = {
 	[TB_SECURITY_DPONLY] = "dponly",
 };
 
+static ssize_t boot_acl_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	struct tb *tb = container_of(dev, struct tb, dev);
+	uuid_t *uuids;
+	ssize_t ret;
+	int i;
+
+	uuids = kcalloc(tb->nboot_acl, sizeof(uuid_t), GFP_KERNEL);
+	if (!uuids)
+		return -ENOMEM;
+
+	if (mutex_lock_interruptible(&tb->lock)) {
+		ret = -ERESTARTSYS;
+		goto out;
+	}
+	ret = tb->cm_ops->get_boot_acl(tb, uuids, tb->nboot_acl);
+	if (ret) {
+		mutex_unlock(&tb->lock);
+		goto out;
+	}
+	mutex_unlock(&tb->lock);
+
+	for (ret = 0, i = 0; i < tb->nboot_acl; i++) {
+		if (!uuid_is_null(&uuids[i]))
+			ret += snprintf(buf + ret, PAGE_SIZE - ret, "%pUb",
+					&uuids[i]);
+
+		ret += snprintf(buf + ret, PAGE_SIZE - ret, "%s",
+			       i < tb->nboot_acl - 1 ? "," : "\n");
+	}
+
+out:
+	kfree(uuids);
+	return ret;
+}
+
+static ssize_t boot_acl_store(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct tb *tb = container_of(dev, struct tb, dev);
+	char *str, *s, *uuid_str;
+	ssize_t ret = 0;
+	uuid_t *acl;
+	int i = 0;
+
+	/*
+	 * Make sure the value is not bigger than tb->nboot_acl * UUID
+	 * length + commas and optional "\n". Also the smallest allowable
+	 * string is tb->nboot_acl * ",".
+	 */
+	if (count > (UUID_STRING_LEN + 1) * tb->nboot_acl + 1)
+		return -EINVAL;
+	if (count < tb->nboot_acl - 1)
+		return -EINVAL;
+
+	str = kstrdup(buf, GFP_KERNEL);
+	if (!str)
+		return -ENOMEM;
+
+	acl = kcalloc(tb->nboot_acl, sizeof(uuid_t), GFP_KERNEL);
+	if (!acl) {
+		ret = -ENOMEM;
+		goto err_free_str;
+	}
+
+	uuid_str = strim(str);
+	while ((s = strsep(&uuid_str, ",")) != NULL && i < tb->nboot_acl) {
+		size_t len = strlen(s);
+
+		if (len) {
+			if (len != UUID_STRING_LEN) {
+				ret = -EINVAL;
+				goto err_free_acl;
+			}
+			ret = uuid_parse(s, &acl[i]);
+			if (ret)
+				goto err_free_acl;
+		}
+
+		i++;
+	}
+
+	if (s || i < tb->nboot_acl) {
+		ret = -EINVAL;
+		goto err_free_acl;
+	}
+
+	if (mutex_lock_interruptible(&tb->lock)) {
+		ret = -ERESTARTSYS;
+		goto err_free_acl;
+	}
+	ret = tb->cm_ops->set_boot_acl(tb, acl, tb->nboot_acl);
+	mutex_unlock(&tb->lock);
+
+err_free_acl:
+	kfree(acl);
+err_free_str:
+	kfree(str);
+
+	return ret ?: count;
+}
+static DEVICE_ATTR_RW(boot_acl);
+
 static ssize_t security_show(struct device *dev, struct device_attribute *attr,
 			     char *buf)
 {
@@ -37,11 +141,30 @@ static ssize_t security_show(struct device *dev, struct device_attribute *attr,
 static DEVICE_ATTR_RO(security);
 
 static struct attribute *domain_attrs[] = {
+	&dev_attr_boot_acl.attr,
 	&dev_attr_security.attr,
 	NULL,
 };
 
+static umode_t domain_attr_is_visible(struct kobject *kobj,
+				      struct attribute *attr, int n)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct tb *tb = container_of(dev, struct tb, dev);
+
+	if (attr == &dev_attr_boot_acl.attr) {
+		if (tb->nboot_acl &&
+		    tb->cm_ops->get_boot_acl &&
+		    tb->cm_ops->set_boot_acl)
+			return attr->mode;
+		return 0;
+	}
+
+	return attr->mode;
+}
+
 static struct attribute_group domain_attr_group = {
+	.is_visible = domain_attr_is_visible,
 	.attrs = domain_attrs,
 };
 
* Unmerged path drivers/thunderbolt/icm.c
diff --git a/drivers/thunderbolt/tb.h b/drivers/thunderbolt/tb.h
index ea21d927bd09..d77900581042 100644
--- a/drivers/thunderbolt/tb.h
+++ b/drivers/thunderbolt/tb.h
@@ -185,6 +185,8 @@ struct tb_path {
  * @suspend: Connection manager specific suspend
  * @complete: Connection manager specific complete
  * @handle_event: Handle thunderbolt event
+ * @get_boot_acl: Get boot ACL list
+ * @set_boot_acl: Set boot ACL list
  * @approve_switch: Approve switch
  * @add_switch_key: Add key to switch
  * @challenge_switch_key: Challenge switch using key
@@ -200,6 +202,8 @@ struct tb_cm_ops {
 	void (*complete)(struct tb *tb);
 	void (*handle_event)(struct tb *tb, enum tb_cfg_pkg_type,
 			     const void *buf, size_t size);
+	int (*get_boot_acl)(struct tb *tb, uuid_t *uuids, size_t nuuids);
+	int (*set_boot_acl)(struct tb *tb, const uuid_t *uuids, size_t nuuids);
 	int (*approve_switch)(struct tb *tb, struct tb_switch *sw);
 	int (*add_switch_key)(struct tb *tb, struct tb_switch *sw);
 	int (*challenge_switch_key)(struct tb *tb, struct tb_switch *sw,
* Unmerged path drivers/thunderbolt/tb_msgs.h
diff --git a/include/linux/thunderbolt.h b/include/linux/thunderbolt.h
index 43b8d1e09341..de7b5505c736 100644
--- a/include/linux/thunderbolt.h
+++ b/include/linux/thunderbolt.h
@@ -61,6 +61,7 @@ enum tb_security_level {
  * @cm_ops: Connection manager specific operations vector
  * @index: Linux assigned domain number
  * @security_level: Current security level
+ * @nboot_acl: Number of boot ACLs the domain supports
  * @privdata: Private connection manager specific data
  */
 struct tb {
@@ -73,6 +74,7 @@ struct tb {
 	const struct tb_cm_ops *cm_ops;
 	int index;
 	enum tb_security_level security_level;
+	size_t nboot_acl;
 	unsigned long privdata[0];
 };
 
