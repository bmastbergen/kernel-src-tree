xfs: move inode fork verifiers to xfs_dinode_verify

jira LE-1907
cve CVE-2018-10322
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 71493b839e294065ba63bd6f8d07263f3afee8c6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/71493b83.failed

Consolidate the fork size and format verifiers to xfs_dinode_verify so
that we can reject bad inodes earlier and in a single place.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit 71493b839e294065ba63bd6f8d07263f3afee8c6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_inode_buf.c
#	fs/xfs/libxfs/xfs_inode_fork.c
diff --cc fs/xfs/libxfs/xfs_inode_buf.c
index 5fb249cbd278,4035b5d5f6fd..000000000000
--- a/fs/xfs/libxfs/xfs_inode_buf.c
+++ b/fs/xfs/libxfs/xfs_inode_buf.c
@@@ -386,36 -387,124 +386,137 @@@ xfs_dinode_verify
  	struct xfs_dinode	*dip)
  {
  	uint16_t		mode;
++<<<<<<< HEAD
++=======
+ 	uint16_t		flags;
+ 	uint64_t		flags2;
+ 	uint64_t		di_size;
++>>>>>>> 71493b839e29 (xfs: move inode fork verifiers to xfs_dinode_verify)
  
  	if (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))
 -		return __this_address;
 -
 -	/* Verify v3 integrity information first */
 -	if (dip->di_version >= 3) {
 -		if (!xfs_sb_version_hascrc(&mp->m_sb))
 -			return __this_address;
 -		if (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,
 -				      XFS_DINODE_CRC_OFF))
 -			return __this_address;
 -		if (be64_to_cpu(dip->di_ino) != ino)
 -			return __this_address;
 -		if (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_uuid))
 -			return __this_address;
 -	}
 +		return false;
  
  	/* don't allow invalid i_size */
++<<<<<<< HEAD
 +	if (be64_to_cpu(dip->di_size) & (1ULL << 63))
 +		return false;
++=======
+ 	di_size = be64_to_cpu(dip->di_size);
+ 	if (di_size & (1ULL << 63))
+ 		return __this_address;
++>>>>>>> 71493b839e29 (xfs: move inode fork verifiers to xfs_dinode_verify)
  
  	mode = be16_to_cpu(dip->di_mode);
  	if (mode && xfs_mode_to_ftype(mode) == XFS_DIR3_FT_UNKNOWN)
 -		return __this_address;
 +		return false;
  
  	/* No zero-length symlinks/dirs. */
++<<<<<<< HEAD
 +	if ((S_ISLNK(mode) || S_ISDIR(mode)) && dip->di_size == 0)
 +		return false;
++=======
+ 	if ((S_ISLNK(mode) || S_ISDIR(mode)) && di_size == 0)
+ 		return __this_address;
++>>>>>>> 71493b839e29 (xfs: move inode fork verifiers to xfs_dinode_verify)
+ 
+ 	/* Fork checks carried over from xfs_iformat_fork */
+ 	if (mode &&
+ 	    be32_to_cpu(dip->di_nextents) + be16_to_cpu(dip->di_anextents) >
+ 			be64_to_cpu(dip->di_nblocks))
+ 		return __this_address;
+ 
+ 	if (mode && XFS_DFORK_BOFF(dip) > mp->m_sb.sb_inodesize)
+ 		return __this_address;
+ 
+ 	flags = be16_to_cpu(dip->di_flags);
+ 
+ 	if (mode && (flags & XFS_DIFLAG_REALTIME) && !mp->m_rtdev_targp)
+ 		return __this_address;
+ 
+ 	/* Do we have appropriate data fork formats for the mode? */
+ 	switch (mode & S_IFMT) {
+ 	case S_IFIFO:
+ 	case S_IFCHR:
+ 	case S_IFBLK:
+ 	case S_IFSOCK:
+ 		if (dip->di_format != XFS_DINODE_FMT_DEV)
+ 			return __this_address;
+ 		break;
+ 	case S_IFREG:
+ 	case S_IFLNK:
+ 	case S_IFDIR:
+ 		switch (dip->di_format) {
+ 		case XFS_DINODE_FMT_LOCAL:
+ 			/*
+ 			 * no local regular files yet
+ 			 */
+ 			if (S_ISREG(mode))
+ 				return __this_address;
+ 			if (di_size > XFS_DFORK_DSIZE(dip, mp))
+ 				return __this_address;
+ 			/* fall through */
+ 		case XFS_DINODE_FMT_EXTENTS:
+ 		case XFS_DINODE_FMT_BTREE:
+ 			break;
+ 		default:
+ 			return __this_address;
+ 		}
+ 		break;
+ 	case 0:
+ 		/* Uninitialized inode ok. */
+ 		break;
+ 	default:
+ 		return __this_address;
+ 	}
+ 
+ 	if (XFS_DFORK_Q(dip)) {
+ 		switch (dip->di_aformat) {
+ 		case XFS_DINODE_FMT_LOCAL:
+ 		case XFS_DINODE_FMT_EXTENTS:
+ 		case XFS_DINODE_FMT_BTREE:
+ 			break;
+ 		default:
+ 			return __this_address;
+ 		}
+ 	}
  
  	/* only version 3 or greater inodes are extensively verified here */
  	if (dip->di_version < 3)
 -		return NULL;
 -
 +		return true;
 +
++<<<<<<< HEAD
 +	if (!xfs_sb_version_hascrc(&mp->m_sb))
 +		return false;
 +	if (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,
 +			      XFS_DINODE_CRC_OFF))
 +		return false;
 +	if (be64_to_cpu(dip->di_ino) != ino)
 +		return false;
 +	if (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_uuid))
 +		return false;
 +	return true;
++=======
+ 	flags2 = be64_to_cpu(dip->di_flags2);
+ 
+ 	/* don't allow reflink/cowextsize if we don't have reflink */
+ 	if ((flags2 & (XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)) &&
+             !xfs_sb_version_hasreflink(&mp->m_sb))
+ 		return __this_address;
+ 
+ 	/* only regular files get reflink */
+ 	if ((flags2 & XFS_DIFLAG2_REFLINK) && (mode & S_IFMT) != S_IFREG)
+ 		return __this_address;
+ 
+ 	/* don't let reflink and realtime mix */
+ 	if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags & XFS_DIFLAG_REALTIME))
+ 		return __this_address;
+ 
+ 	/* don't let reflink and dax mix */
+ 	if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags2 & XFS_DIFLAG2_DAX))
+ 		return __this_address;
+ 
+ 	return NULL;
++>>>>>>> 71493b839e29 (xfs: move inode fork verifiers to xfs_dinode_verify)
  }
  
  void
diff --cc fs/xfs/libxfs/xfs_inode_fork.c
index 8d32195a5669,fd88cbe8c264..000000000000
--- a/fs/xfs/libxfs/xfs_inode_fork.c
+++ b/fs/xfs/libxfs/xfs_inode_fork.c
@@@ -90,52 -62,13 +90,51 @@@ xfs_iformat_fork
  	int			error = 0;
  	xfs_fsize_t             di_size;
  
++<<<<<<< HEAD
 +	if (unlikely(be32_to_cpu(dip->di_nextents) +
 +		     be16_to_cpu(dip->di_anextents) >
 +		     be64_to_cpu(dip->di_nblocks))) {
 +		xfs_warn(ip->i_mount,
 +			"corrupt dinode %Lu, extent total = %d, nblocks = %Lu.",
 +			(unsigned long long)ip->i_ino,
 +			(int)(be32_to_cpu(dip->di_nextents) +
 +			      be16_to_cpu(dip->di_anextents)),
 +			(unsigned long long)
 +				be64_to_cpu(dip->di_nblocks));
 +		XFS_CORRUPTION_ERROR("xfs_iformat(1)", XFS_ERRLEVEL_LOW,
 +				     ip->i_mount, dip);
 +		return -EFSCORRUPTED;
 +	}
 +
 +	if (unlikely(dip->di_forkoff > ip->i_mount->m_sb.sb_inodesize)) {
 +		xfs_warn(ip->i_mount, "corrupt dinode %Lu, forkoff = 0x%x.",
 +			(unsigned long long)ip->i_ino,
 +			dip->di_forkoff);
 +		XFS_CORRUPTION_ERROR("xfs_iformat(2)", XFS_ERRLEVEL_LOW,
 +				     ip->i_mount, dip);
 +		return -EFSCORRUPTED;
 +	}
 +
 +	if (unlikely((ip->i_d.di_flags & XFS_DIFLAG_REALTIME) &&
 +		     !ip->i_mount->m_rtdev_targp)) {
 +		xfs_warn(ip->i_mount,
 +			"corrupt dinode %Lu, has realtime flag set.",
 +			ip->i_ino);
 +		XFS_CORRUPTION_ERROR("xfs_iformat(realtime)",
 +				     XFS_ERRLEVEL_LOW, ip->i_mount, dip);
 +		return -EFSCORRUPTED;
 +	}
 +
 +	switch (VFS_I(ip)->i_mode & S_IFMT) {
++=======
+ 	switch (inode->i_mode & S_IFMT) {
++>>>>>>> 71493b839e29 (xfs: move inode fork verifiers to xfs_dinode_verify)
  	case S_IFIFO:
  	case S_IFCHR:
  	case S_IFBLK:
  	case S_IFSOCK:
- 		if (unlikely(dip->di_format != XFS_DINODE_FMT_DEV)) {
- 			XFS_CORRUPTION_ERROR("xfs_iformat(3)", XFS_ERRLEVEL_LOW,
- 					      ip->i_mount, dip);
- 			return -EFSCORRUPTED;
- 		}
  		ip->i_d.di_size = 0;
 -		inode->i_rdev = xfs_to_linux_dev_t(xfs_dinode_get_rdev(dip));
 +		ip->i_df.if_u2.if_rdev = xfs_dinode_get_rdev(dip);
  		break;
  
  	case S_IFREG:
@@@ -186,16 -92,13 +158,15 @@@
  		break;
  
  	default:
- 		XFS_ERROR_REPORT("xfs_iformat(7)", XFS_ERRLEVEL_LOW, ip->i_mount);
  		return -EFSCORRUPTED;
  	}
 -	if (error)
 +	if (error) {
  		return error;
 +	}
  
  	/* Check inline dir contents. */
 -	if (S_ISDIR(inode->i_mode) && dip->di_format == XFS_DINODE_FMT_LOCAL) {
 +	if (S_ISDIR(VFS_I(ip)->i_mode) &&
 +	    dip->di_format == XFS_DINODE_FMT_LOCAL) {
  		error = xfs_dir2_sf_verify(ip);
  		if (error) {
  			xfs_idestroy_fork(ip, XFS_DATA_FORK);
* Unmerged path fs/xfs/libxfs/xfs_inode_buf.c
* Unmerged path fs/xfs/libxfs/xfs_inode_fork.c
