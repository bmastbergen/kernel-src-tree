xfs: always compile the btree inorder check functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 38dee376d67047e9877a34e408013852c9729eb8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/38dee376.failed

The btree record and key inorder check functions will be used by the
btree scrubber code, so make sure they're always built.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
(cherry picked from commit 38dee376d67047e9877a34e408013852c9729eb8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_alloc_btree.c
#	fs/xfs/libxfs/xfs_bmap_btree.c
#	fs/xfs/libxfs/xfs_btree.h
#	fs/xfs/libxfs/xfs_ialloc_btree.c
#	fs/xfs/libxfs/xfs_refcount_btree.c
#	fs/xfs/libxfs/xfs_rmap_btree.c
diff --cc fs/xfs/libxfs/xfs_alloc_btree.c
index a2ae2e9137f4,cfde0a0f9706..000000000000
--- a/fs/xfs/libxfs/xfs_alloc_btree.c
+++ b/fs/xfs/libxfs/xfs_alloc_btree.c
@@@ -344,9 -395,8 +344,8 @@@ const struct xfs_buf_ops xfs_allocbt_bu
  };
  
  
- #if defined(DEBUG) || defined(XFS_WARN)
  STATIC int
 -xfs_bnobt_keys_inorder(
 +xfs_allocbt_keys_inorder(
  	struct xfs_btree_cur	*cur,
  	union xfs_btree_key	*k1,
  	union xfs_btree_key	*k2)
@@@ -369,21 -411,38 +368,51 @@@ xfs_allocbt_recs_inorder
  	union xfs_btree_rec	*r1,
  	union xfs_btree_rec	*r2)
  {
 -	return be32_to_cpu(r1->alloc.ar_startblock) +
 -		be32_to_cpu(r1->alloc.ar_blockcount) <=
 -		be32_to_cpu(r2->alloc.ar_startblock);
 +	if (cur->bc_btnum == XFS_BTNUM_BNO) {
 +		return be32_to_cpu(r1->alloc.ar_startblock) +
 +			be32_to_cpu(r1->alloc.ar_blockcount) <=
 +			be32_to_cpu(r2->alloc.ar_startblock);
 +	} else {
 +		return be32_to_cpu(r1->alloc.ar_blockcount) <
 +			be32_to_cpu(r2->alloc.ar_blockcount) ||
 +			(r1->alloc.ar_blockcount == r2->alloc.ar_blockcount &&
 +			 be32_to_cpu(r1->alloc.ar_startblock) <
 +			 be32_to_cpu(r2->alloc.ar_startblock));
 +	}
  }
 +#endif	/* DEBUG */
  
++<<<<<<< HEAD
 +static const struct xfs_btree_ops xfs_allocbt_ops = {
++=======
+ STATIC int
+ xfs_cntbt_keys_inorder(
+ 	struct xfs_btree_cur	*cur,
+ 	union xfs_btree_key	*k1,
+ 	union xfs_btree_key	*k2)
+ {
+ 	return be32_to_cpu(k1->alloc.ar_blockcount) <
+ 		be32_to_cpu(k2->alloc.ar_blockcount) ||
+ 		(k1->alloc.ar_blockcount == k2->alloc.ar_blockcount &&
+ 		 be32_to_cpu(k1->alloc.ar_startblock) <
+ 		 be32_to_cpu(k2->alloc.ar_startblock));
+ }
+ 
+ STATIC int
+ xfs_cntbt_recs_inorder(
+ 	struct xfs_btree_cur	*cur,
+ 	union xfs_btree_rec	*r1,
+ 	union xfs_btree_rec	*r2)
+ {
+ 	return be32_to_cpu(r1->alloc.ar_blockcount) <
+ 		be32_to_cpu(r2->alloc.ar_blockcount) ||
+ 		(r1->alloc.ar_blockcount == r2->alloc.ar_blockcount &&
+ 		 be32_to_cpu(r1->alloc.ar_startblock) <
+ 		 be32_to_cpu(r2->alloc.ar_startblock));
+ }
+ 
+ static const struct xfs_btree_ops xfs_bnobt_ops = {
++>>>>>>> 38dee376d670 (xfs: always compile the btree inorder check functions)
  	.rec_len		= sizeof(xfs_alloc_rec_t),
  	.key_len		= sizeof(xfs_alloc_key_t),
  
@@@ -395,18 -454,36 +424,46 @@@
  	.get_minrecs		= xfs_allocbt_get_minrecs,
  	.get_maxrecs		= xfs_allocbt_get_maxrecs,
  	.init_key_from_rec	= xfs_allocbt_init_key_from_rec,
 -	.init_high_key_from_rec	= xfs_bnobt_init_high_key_from_rec,
  	.init_rec_from_cur	= xfs_allocbt_init_rec_from_cur,
  	.init_ptr_from_cur	= xfs_allocbt_init_ptr_from_cur,
 -	.key_diff		= xfs_bnobt_key_diff,
 +	.key_diff		= xfs_allocbt_key_diff,
  	.buf_ops		= &xfs_allocbt_buf_ops,
++<<<<<<< HEAD
 +#if defined(DEBUG) || defined(XFS_WARN)
 +	.keys_inorder		= xfs_allocbt_keys_inorder,
 +	.recs_inorder		= xfs_allocbt_recs_inorder,
 +#endif
 +
 +	.get_leaf_keys		= xfs_btree_get_leaf_keys,
 +	.get_node_keys		= xfs_btree_get_node_keys,
 +	.update_keys		= xfs_btree_update_keys,
++=======
+ 	.diff_two_keys		= xfs_bnobt_diff_two_keys,
+ 	.keys_inorder		= xfs_bnobt_keys_inorder,
+ 	.recs_inorder		= xfs_bnobt_recs_inorder,
+ };
+ 
+ static const struct xfs_btree_ops xfs_cntbt_ops = {
+ 	.rec_len		= sizeof(xfs_alloc_rec_t),
+ 	.key_len		= sizeof(xfs_alloc_key_t),
+ 
+ 	.dup_cursor		= xfs_allocbt_dup_cursor,
+ 	.set_root		= xfs_allocbt_set_root,
+ 	.alloc_block		= xfs_allocbt_alloc_block,
+ 	.free_block		= xfs_allocbt_free_block,
+ 	.update_lastrec		= xfs_allocbt_update_lastrec,
+ 	.get_minrecs		= xfs_allocbt_get_minrecs,
+ 	.get_maxrecs		= xfs_allocbt_get_maxrecs,
+ 	.init_key_from_rec	= xfs_allocbt_init_key_from_rec,
+ 	.init_high_key_from_rec	= xfs_cntbt_init_high_key_from_rec,
+ 	.init_rec_from_cur	= xfs_allocbt_init_rec_from_cur,
+ 	.init_ptr_from_cur	= xfs_allocbt_init_ptr_from_cur,
+ 	.key_diff		= xfs_cntbt_key_diff,
+ 	.buf_ops		= &xfs_allocbt_buf_ops,
+ 	.diff_two_keys		= xfs_cntbt_diff_two_keys,
+ 	.keys_inorder		= xfs_cntbt_keys_inorder,
+ 	.recs_inorder		= xfs_cntbt_recs_inorder,
++>>>>>>> 38dee376d670 (xfs: always compile the btree inorder check functions)
  };
  
  /*
diff --cc fs/xfs/libxfs/xfs_bmap_btree.c
index 02efded83ebf,e23495e23620..000000000000
--- a/fs/xfs/libxfs/xfs_bmap_btree.c
+++ b/fs/xfs/libxfs/xfs_bmap_btree.c
@@@ -753,14 -724,8 +751,16 @@@ static const struct xfs_btree_ops xfs_b
  	.init_ptr_from_cur	= xfs_bmbt_init_ptr_from_cur,
  	.key_diff		= xfs_bmbt_key_diff,
  	.buf_ops		= &xfs_bmbt_buf_ops,
- #if defined(DEBUG) || defined(XFS_WARN)
  	.keys_inorder		= xfs_bmbt_keys_inorder,
  	.recs_inorder		= xfs_bmbt_recs_inorder,
++<<<<<<< HEAD
 +#endif
 +
 +	.get_leaf_keys		= xfs_btree_get_leaf_keys,
 +	.get_node_keys		= xfs_btree_get_node_keys,
 +	.update_keys		= xfs_btree_update_keys,
++=======
++>>>>>>> 38dee376d670 (xfs: always compile the btree inorder check functions)
  };
  
  /*
diff --cc fs/xfs/libxfs/xfs_btree.h
index 352598858d21,177a364ce5cf..000000000000
--- a/fs/xfs/libxfs/xfs_btree.h
+++ b/fs/xfs/libxfs/xfs_btree.h
@@@ -164,14 -146,23 +164,13 @@@ struct xfs_btree_ops 
  				     union xfs_btree_rec *rec);
  	void	(*init_ptr_from_cur)(struct xfs_btree_cur *cur,
  				     union xfs_btree_ptr *ptr);
 -	void	(*init_high_key_from_rec)(union xfs_btree_key *key,
 -					  union xfs_btree_rec *rec);
  
  	/* difference between key value and cursor value */
 -	int64_t (*key_diff)(struct xfs_btree_cur *cur,
 +	__int64_t (*key_diff)(struct xfs_btree_cur *cur,
  			      union xfs_btree_key *key);
  
 -	/*
 -	 * Difference between key2 and key1 -- positive if key1 > key2,
 -	 * negative if key1 < key2, and zero if equal.
 -	 */
 -	int64_t (*diff_two_keys)(struct xfs_btree_cur *cur,
 -				   union xfs_btree_key *key1,
 -				   union xfs_btree_key *key2);
 -
  	const struct xfs_buf_ops	*buf_ops;
  
- #if defined(DEBUG) || defined(XFS_WARN)
  	/* check that k1 is lower than k2 */
  	int	(*keys_inorder)(struct xfs_btree_cur *cur,
  				union xfs_btree_key *k1,
@@@ -181,20 -172,6 +180,23 @@@
  	int	(*recs_inorder)(struct xfs_btree_cur *cur,
  				union xfs_btree_rec *r1,
  				union xfs_btree_rec *r2);
++<<<<<<< HEAD
 +#endif
 +
 +	/* derive the low & high keys from the records in a leaf block */
 +	void	(*get_leaf_keys)(struct xfs_btree_cur *cur,
 +				 struct xfs_btree_block *block,
 +				 union xfs_btree_key *key);
 +
 +	/* derive the low & high keys from the keys in a node block */
 +	void	(*get_node_keys)(struct xfs_btree_cur *cur,
 +				 struct xfs_btree_block *block,
 +				 union xfs_btree_key *key);
 +
 +	/* update the parent keys of given btree level */
 +	int	(*update_keys)(struct xfs_btree_cur *cur, int level);
++=======
++>>>>>>> 38dee376d670 (xfs: always compile the btree inorder check functions)
  };
  
  /*
diff --cc fs/xfs/libxfs/xfs_ialloc_btree.c
index 1002677e914d,6b1ddeb7e5c1..000000000000
--- a/fs/xfs/libxfs/xfs_ialloc_btree.c
+++ b/fs/xfs/libxfs/xfs_ialloc_btree.c
@@@ -310,14 -337,8 +308,16 @@@ static const struct xfs_btree_ops xfs_i
  	.init_ptr_from_cur	= xfs_inobt_init_ptr_from_cur,
  	.key_diff		= xfs_inobt_key_diff,
  	.buf_ops		= &xfs_inobt_buf_ops,
- #if defined(DEBUG) || defined(XFS_WARN)
  	.keys_inorder		= xfs_inobt_keys_inorder,
  	.recs_inorder		= xfs_inobt_recs_inorder,
++<<<<<<< HEAD
 +#endif
 +
 +	.get_leaf_keys		= xfs_btree_get_leaf_keys,
 +	.get_node_keys		= xfs_btree_get_node_keys,
 +	.update_keys		= xfs_btree_update_keys,
++=======
++>>>>>>> 38dee376d670 (xfs: always compile the btree inorder check functions)
  };
  
  static const struct xfs_btree_ops xfs_finobt_ops = {
@@@ -335,14 -356,8 +335,16 @@@
  	.init_ptr_from_cur	= xfs_finobt_init_ptr_from_cur,
  	.key_diff		= xfs_inobt_key_diff,
  	.buf_ops		= &xfs_inobt_buf_ops,
- #if defined(DEBUG) || defined(XFS_WARN)
  	.keys_inorder		= xfs_inobt_keys_inorder,
  	.recs_inorder		= xfs_inobt_recs_inorder,
++<<<<<<< HEAD
 +#endif
 +
 +	.get_leaf_keys		= xfs_btree_get_leaf_keys,
 +	.get_node_keys		= xfs_btree_get_node_keys,
 +	.update_keys		= xfs_btree_update_keys,
++=======
++>>>>>>> 38dee376d670 (xfs: always compile the btree inorder check functions)
  };
  
  /*
* Unmerged path fs/xfs/libxfs/xfs_refcount_btree.c
* Unmerged path fs/xfs/libxfs/xfs_rmap_btree.c
* Unmerged path fs/xfs/libxfs/xfs_alloc_btree.c
* Unmerged path fs/xfs/libxfs/xfs_bmap_btree.c
* Unmerged path fs/xfs/libxfs/xfs_btree.h
* Unmerged path fs/xfs/libxfs/xfs_ialloc_btree.c
* Unmerged path fs/xfs/libxfs/xfs_refcount_btree.c
* Unmerged path fs/xfs/libxfs/xfs_rmap_btree.c
