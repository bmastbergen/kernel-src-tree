net: ipv6/l3mdev: Move host route on saved address if necessary

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] ipv6/l3mdev: Move host route on saved address if necessary (Ivan Vecera) [1500871]
Rebuild_FUZZ: 95.87%
commit-author David Ahern <dsa@cumulusnetworks.com>
commit 4f25a1110cd4f5746b750a9567303c7ef6826b7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4f25a111.failed

Commit f1705ec197e70 allows IPv6 addresses to be retained on a link down.
The address can have a cached host route which can point to the wrong
FIB table if the L3 enslavement is changed (e.g., route can point to local
table instead of VRF table if device is added to an L3 domain).

On link up check the table of the cached host route against the FIB
table associated with the device and correct if needed.

	Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4f25a1110cd4f5746b750a9567303c7ef6826b7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/addrconf.c
diff --cc net/ipv6/addrconf.c
index e92da293a901,b1169d511ab4..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -3071,6 -3170,81 +3071,84 @@@ static void addrconf_gre_config(struct 
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_NET_L3_MASTER_DEV)
+ /* If the host route is cached on the addr struct make sure it is associated
+  * with the proper table. e.g., enslavement can change and if so the cached
+  * host route needs to move to the new table.
+  */
+ static void l3mdev_check_host_rt(struct inet6_dev *idev,
+ 				  struct inet6_ifaddr *ifp)
+ {
+ 	if (ifp->rt) {
+ 		u32 tb_id = l3mdev_fib_table(idev->dev) ? : RT6_TABLE_LOCAL;
+ 
+ 		if (tb_id != ifp->rt->rt6i_table->tb6_id) {
+ 			ip6_del_rt(ifp->rt);
+ 			ifp->rt = NULL;
+ 		}
+ 	}
+ }
+ #else
+ static void l3mdev_check_host_rt(struct inet6_dev *idev,
+ 				  struct inet6_ifaddr *ifp)
+ {
+ }
+ #endif
+ 
+ static int fixup_permanent_addr(struct inet6_dev *idev,
+ 				struct inet6_ifaddr *ifp)
+ {
+ 	l3mdev_check_host_rt(idev, ifp);
+ 
+ 	if (!ifp->rt) {
+ 		struct rt6_info *rt;
+ 
+ 		rt = addrconf_dst_alloc(idev, &ifp->addr, false);
+ 		if (unlikely(IS_ERR(rt)))
+ 			return PTR_ERR(rt);
+ 
+ 		ifp->rt = rt;
+ 	}
+ 
+ 	if (!(ifp->flags & IFA_F_NOPREFIXROUTE)) {
+ 		addrconf_prefix_route(&ifp->addr, ifp->prefix_len,
+ 				      idev->dev, 0, 0);
+ 	}
+ 
+ 	addrconf_dad_start(ifp);
+ 
+ 	return 0;
+ }
+ 
+ static void addrconf_permanent_addr(struct net_device *dev)
+ {
+ 	struct inet6_ifaddr *ifp, *tmp;
+ 	struct inet6_dev *idev;
+ 
+ 	idev = __in6_dev_get(dev);
+ 	if (!idev)
+ 		return;
+ 
+ 	write_lock_bh(&idev->lock);
+ 
+ 	list_for_each_entry_safe(ifp, tmp, &idev->addr_list, if_list) {
+ 		if ((ifp->flags & IFA_F_PERMANENT) &&
+ 		    fixup_permanent_addr(idev, ifp) < 0) {
+ 			write_unlock_bh(&idev->lock);
+ 			ipv6_del_addr(ifp);
+ 			write_lock_bh(&idev->lock);
+ 
+ 			net_info_ratelimited("%s: Failed to add prefix route for address %pI6c; dropping\n",
+ 					     idev->dev->name, &ifp->addr);
+ 		}
+ 	}
+ 
+ 	write_unlock_bh(&idev->lock);
+ }
+ 
++>>>>>>> 4f25a1110cd4 (net: ipv6/l3mdev: Move host route on saved address if necessary)
  static int addrconf_notify(struct notifier_block *this, unsigned long event,
  			   void *ptr)
  {
* Unmerged path net/ipv6/addrconf.c
