IB/uverbs: Use inline data transfer for UHW_IN

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jason Gunthorpe <jgg@mellanox.com>
commit 6c976c30ad1c205bd6e34182c5ba9a1267d752ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6c976c30.failed

The rule for the API is pointers less than 8 bytes are inlined into
the .data field of the attribute. Fix the creation of the driver udata
struct to follow this rule and point to the .data itself when the size
is less than 8 bytes.

Otherwise if the UHW struct is less than 8 bytes the driver will get
EFAULT during copy_from_user.

	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 6c976c30ad1c205bd6e34182c5ba9a1267d752ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_std_types.c
diff --cc drivers/infiniband/core/uverbs_std_types.c
index afd8b1cee88c,7b0e4d778d79..000000000000
--- a/drivers/infiniband/core/uverbs_std_types.c
+++ b/drivers/infiniband/core/uverbs_std_types.c
@@@ -238,8 -234,14 +238,19 @@@ static void create_udata(struct uverbs_
  		uverbs_attr_get(ctx, UVERBS_UHW_OUT);
  
  	if (!IS_ERR(uhw_in)) {
++<<<<<<< HEAD
 +		inbuf = uhw_in->ptr_attr.ptr;
 +		inbuf_len = uhw_in->ptr_attr.len;
++=======
+ 		udata->inlen = uhw_in->ptr_attr.len;
+ 		if (uverbs_attr_ptr_is_inline(uhw_in))
+ 			udata->inbuf = &uhw_in->uattr->data;
+ 		else
+ 			udata->inbuf = uhw_in->ptr_attr.ptr;
+ 	} else {
+ 		udata->inbuf = NULL;
+ 		udata->inlen = 0;
++>>>>>>> 6c976c30ad1c (IB/uverbs: Use inline data transfer for UHW_IN)
  	}
  
  	if (!IS_ERR(uhw_out)) {
* Unmerged path drivers/infiniband/core/uverbs_std_types.c
