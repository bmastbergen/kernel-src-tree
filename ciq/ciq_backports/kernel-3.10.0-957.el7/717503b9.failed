net: sched: convert cls_flower->egress_dev users to tc_setup_cb_egdev infra

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] sched: convert cls_flower->egress_dev users to tc_setup_cb_egdev infra (Ivan Vecera) [1557539]
Rebuild_FUZZ: 96.55%
commit-author Jiri Pirko <jiri@mellanox.com>
commit 717503b9cf57c0bb7ea4d3a9f5699c9a04adf988
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/717503b9.failed

The only user of cls_flower->egress_dev is mlx5. So do the conversion
there alongside with the code originating the call in cls_flower
function fl_hw_replace_filter to the newly introduced egress device
callback infrastucture.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 717503b9cf57c0bb7ea4d3a9f5699c9a04adf988)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
#	net/sched/cls_api.c
#	net/sched/cls_flower.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index c78fae70e2de,765fc74fbb1b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -667,14 -668,6 +668,17 @@@ mlx5e_rep_setup_tc_cls_flower(struct ne
  	    cls_flower->common.chain_index)
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	if (cls_flower->egress_dev) {
 +		struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 +
 +		dev = mlx5_eswitch_get_uplink_netdev(esw);
 +		return __rh_call_ndo_setup_tc(dev, TC_SETUP_CLSFLOWER,
 +					      cls_flower);
 +	}
 +
++=======
++>>>>>>> 717503b9cf57 (net: sched: convert cls_flower->egress_dev users to tc_setup_cb_egdev infra)
  	switch (cls_flower->command) {
  	case TC_CLSFLOWER_REPLACE:
  		return mlx5e_configure_flower(priv, cls_flower);
diff --cc net/sched/cls_api.c
index 3b8cc4dc4e82,51994a202585..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -1034,16 -1026,49 +1034,56 @@@ int tcf_exts_get_dev(struct net_device 
  }
  EXPORT_SYMBOL(tcf_exts_get_dev);
  
++<<<<<<< HEAD
++=======
+ static int tc_exts_setup_cb_egdev_call(struct tcf_exts *exts,
+ 				       enum tc_setup_type type,
+ 				       void *type_data, bool err_stop)
+ {
+ 	int ok_count = 0;
+ #ifdef CONFIG_NET_CLS_ACT
+ 	const struct tc_action *a;
+ 	struct net_device *dev;
+ 	LIST_HEAD(actions);
+ 	int ret;
+ 
+ 	if (!tcf_exts_has_actions(exts))
+ 		return 0;
+ 
+ 	tcf_exts_to_list(exts, &actions);
+ 	list_for_each_entry(a, &actions, list) {
+ 		if (!a->ops->get_dev)
+ 			continue;
+ 		dev = a->ops->get_dev(a);
+ 		if (!dev || !tc_can_offload(dev))
+ 			continue;
+ 		ret = tc_setup_cb_egdev_call(dev, type, type_data, err_stop);
+ 		if (ret < 0)
+ 			return ret;
+ 		ok_count += ret;
+ 	}
+ #endif
+ 	return ok_count;
+ }
+ 
+ int tc_setup_cb_call(struct tcf_exts *exts, enum tc_setup_type type,
+ 		     void *type_data, bool err_stop)
+ {
+ 	return tc_exts_setup_cb_egdev_call(exts, type, type_data, err_stop);
+ }
+ EXPORT_SYMBOL(tc_setup_cb_call);
+ 
++>>>>>>> 717503b9cf57 (net: sched: convert cls_flower->egress_dev users to tc_setup_cb_egdev infra)
  static int __init tc_filter_init(void)
  {
 -	rtnl_register(PF_UNSPEC, RTM_NEWTFILTER, tc_ctl_tfilter, NULL, 0);
 -	rtnl_register(PF_UNSPEC, RTM_DELTFILTER, tc_ctl_tfilter, NULL, 0);
 +	tc_filter_wq = alloc_ordered_workqueue("tc_filter_workqueue", 0);
 +	if (!tc_filter_wq)
 +		return -ENOMEM;
 +
 +	rtnl_register(PF_UNSPEC, RTM_NEWTFILTER, tc_ctl_tfilter, NULL, NULL);
 +	rtnl_register(PF_UNSPEC, RTM_DELTFILTER, tc_ctl_tfilter, NULL, NULL);
  	rtnl_register(PF_UNSPEC, RTM_GETTFILTER, tc_ctl_tfilter,
 -		      tc_dump_tfilter, 0);
 +		      tc_dump_tfilter, NULL);
  
  	return 0;
  }
diff --cc net/sched/cls_flower.c
index 2219661bba77,5b7bb968d1d4..000000000000
--- a/net/sched/cls_flower.c
+++ b/net/sched/cls_flower.c
@@@ -87,11 -87,7 +87,15 @@@ struct cls_fl_filter 
  	struct list_head list;
  	u32 handle;
  	u32 flags;
++<<<<<<< HEAD
 +	union {
 +		struct work_struct work;
 +		struct rcu_head	rcu;
 +	};
 +	struct net_device *hw_dev;
++=======
+ 	struct rcu_head	rcu;
++>>>>>>> 717503b9cf57 (net: sched: convert cls_flower->egress_dev users to tc_setup_cb_egdev infra)
  };
  
  static unsigned short int fl_mask_range(const struct fl_flow_mask *mask)
@@@ -253,9 -205,12 +254,17 @@@ static void fl_hw_destroy_filter(struc
  	tc_cls_common_offload_init(&cls_flower.common, tp);
  	cls_flower.command = TC_CLSFLOWER_DESTROY;
  	cls_flower.cookie = (unsigned long) f;
 +	cls_flower.egress_dev = f->hw_dev != tp->q->dev_queue->dev;
  
++<<<<<<< HEAD
 +	__rh_call_ndo_setup_tc(dev, TC_SETUP_CLSFLOWER, &cls_flower);
++=======
+ 	if (tc_can_offload(dev))
+ 		dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_CLSFLOWER,
+ 					      &cls_flower);
+ 	tc_setup_cb_call(&f->exts, TC_SETUP_CLSFLOWER,
+ 			 &cls_flower, false);
++>>>>>>> 717503b9cf57 (net: sched: convert cls_flower->egress_dev users to tc_setup_cb_egdev infra)
  }
  
  static int fl_hw_replace_filter(struct tcf_proto *tp,
@@@ -287,12 -231,29 +285,35 @@@
  	cls_flower.key = &f->mkey;
  	cls_flower.exts = &f->exts;
  
++<<<<<<< HEAD
 +	err = __rh_call_ndo_setup_tc(dev, TC_SETUP_CLSFLOWER, &cls_flower);
 +	if (!err)
 +		f->flags |= TCA_CLS_FLAGS_IN_HW;
++=======
+ 	if (tc_can_offload(dev)) {
+ 		err = dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_CLSFLOWER,
+ 						    &cls_flower);
+ 		if (err) {
+ 			if (skip_sw)
+ 				return err;
+ 		} else {
+ 			f->flags |= TCA_CLS_FLAGS_IN_HW;
+ 		}
+ 	}
++>>>>>>> 717503b9cf57 (net: sched: convert cls_flower->egress_dev users to tc_setup_cb_egdev infra)
  
- 	if (tc_skip_sw(f->flags))
+ 	err = tc_setup_cb_call(&f->exts, TC_SETUP_CLSFLOWER,
+ 			       &cls_flower, skip_sw);
+ 	if (err < 0) {
+ 		fl_hw_destroy_filter(tp, f);
  		return err;
+ 	} else if (err > 0) {
+ 		f->flags |= TCA_CLS_FLAGS_IN_HW;
+ 	}
+ 
+ 	if (skip_sw && !(f->flags & TCA_CLS_FLAGS_IN_HW))
+ 		return -EINVAL;
+ 
  	return 0;
  }
  
@@@ -308,9 -266,12 +326,17 @@@ static void fl_hw_update_stats(struct t
  	cls_flower.command = TC_CLSFLOWER_STATS;
  	cls_flower.cookie = (unsigned long) f;
  	cls_flower.exts = &f->exts;
 +	cls_flower.egress_dev = f->hw_dev != tp->q->dev_queue->dev;
  
++<<<<<<< HEAD
 +	__rh_call_ndo_setup_tc(dev, TC_SETUP_CLSFLOWER, &cls_flower);
++=======
+ 	if (tc_can_offload(dev))
+ 		dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_CLSFLOWER,
+ 					      &cls_flower);
+ 	tc_setup_cb_call(&f->exts, TC_SETUP_CLSFLOWER,
+ 			 &cls_flower, false);
++>>>>>>> 717503b9cf57 (net: sched: convert cls_flower->egress_dev users to tc_setup_cb_egdev infra)
  }
  
  static void __fl_delete(struct tcf_proto *tp, struct cls_fl_filter *f)
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index b8372399d956..1f543ef1c9d8 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -1018,6 +1018,9 @@ int mlx5e_ethtool_get_ts_info(struct mlx5e_priv *priv,
 int mlx5e_ethtool_flash_device(struct mlx5e_priv *priv,
 			       struct ethtool_flash *flash);
 
+int mlx5e_setup_tc(struct net_device *dev, enum tc_setup_type type,
+		   void *type_data);
+
 /* mlx5e generic netdev management API */
 struct net_device*
 mlx5e_create_netdev(struct mlx5_core_dev *mdev, const struct mlx5e_profile *profile,
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 661319054465..6a2c359ec6e9 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -2932,8 +2932,8 @@ static int mlx5e_setup_tc_cls_flower(struct net_device *dev,
 }
 #endif
 
-static int mlx5e_setup_tc(struct net_device *dev, enum tc_setup_type type,
-			  void *type_data)
+int mlx5e_setup_tc(struct net_device *dev, enum tc_setup_type type,
+		   void *type_data)
 {
 	switch (type) {
 #ifdef CONFIG_MLX5_ESWITCH
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --git a/include/net/pkt_cls.h b/include/net/pkt_cls.h
index 065c00671d15..623f5ed62ea8 100644
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@ -432,6 +432,9 @@ tcf_match_indev(struct sk_buff *skb, int ifindex)
 }
 #endif /* CONFIG_NET_CLS_IND */
 
+int tc_setup_cb_call(struct tcf_exts *exts, enum tc_setup_type type,
+		     void *type_data, bool err_stop);
+
 struct tc_cls_common_offload {
 	u32 handle;
 	u32 chain_index;
* Unmerged path net/sched/cls_api.c
* Unmerged path net/sched/cls_flower.c
