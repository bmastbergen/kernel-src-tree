resource: Provide resource struct in resource walk callback

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Tom Lendacky <thomas.lendacky@amd.com>
commit 1d2e733b13b450e5854f4a8f8efcd77fa7362d62
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1d2e733b.failed

In preperation for a new function that will need additional resource
information during the resource walk, update the resource walk callback to
pass the resource structure.  Since the current callback start and end
arguments are pulled from the resource structure, the callback functions
can obtain them from the resource structure directly.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: Brijesh Singh <brijesh.singh@amd.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Kees Cook <keescook@chromium.org>
	Reviewed-by: Borislav Petkov <bp@suse.de>
	Tested-by: Borislav Petkov <bp@suse.de>
	Cc: kvm@vger.kernel.org
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: linuxppc-dev@lists.ozlabs.org
Link: https://lkml.kernel.org/r/20171020143059.3291-10-brijesh.singh@amd.com

(cherry picked from commit 1d2e733b13b450e5854f4a8f8efcd77fa7362d62)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/machine_kexec_file_64.c
#	include/linux/ioport.h
#	include/linux/kexec.h
#	kernel/kexec_file.c
#	kernel/resource.c
diff --cc include/linux/ioport.h
index 1f908f9caecf,c0070d7c4b99..000000000000
--- a/include/linux/ioport.h
+++ b/include/linux/ioport.h
@@@ -261,10 -272,10 +261,15 @@@ walk_system_ram_range(unsigned long sta
  		void *arg, int (*func)(unsigned long, unsigned long, void *));
  extern int
  walk_system_ram_res(u64 start, u64 end, void *arg,
- 		    int (*func)(u64, u64, void *));
+ 		    int (*func)(struct resource *, void *));
  extern int
++<<<<<<< HEAD
 +walk_iomem_res(char *name, unsigned long flags, u64 start, u64 end, void *arg,
 +	       int (*func)(u64, u64, void *));
++=======
+ walk_iomem_res_desc(unsigned long desc, unsigned long flags, u64 start, u64 end,
+ 		    void *arg, int (*func)(struct resource *, void *));
++>>>>>>> 1d2e733b13b4 (resource: Provide resource struct in resource walk callback)
  
  /* True if any part of r1 overlaps r2 */
  static inline bool resource_overlaps(struct resource *r1, struct resource *r2)
diff --cc include/linux/kexec.h
index 66127f61e0df,f16f6ceb3875..000000000000
--- a/include/linux/kexec.h
+++ b/include/linux/kexec.h
@@@ -122,7 -134,36 +122,40 @@@ struct kexec_file_ops 
  	kexec_verify_sig_t *verify_sig;
  #endif
  };
++<<<<<<< HEAD
 +#endif
++=======
+ 
+ /**
+  * struct kexec_buf - parameters for finding a place for a buffer in memory
+  * @image:	kexec image in which memory to search.
+  * @buffer:	Contents which will be copied to the allocated memory.
+  * @bufsz:	Size of @buffer.
+  * @mem:	On return will have address of the buffer in memory.
+  * @memsz:	Size for the buffer in memory.
+  * @buf_align:	Minimum alignment needed.
+  * @buf_min:	The buffer can't be placed below this address.
+  * @buf_max:	The buffer can't be placed above this address.
+  * @top_down:	Allocate from top of memory.
+  */
+ struct kexec_buf {
+ 	struct kimage *image;
+ 	void *buffer;
+ 	unsigned long bufsz;
+ 	unsigned long mem;
+ 	unsigned long memsz;
+ 	unsigned long buf_align;
+ 	unsigned long buf_min;
+ 	unsigned long buf_max;
+ 	bool top_down;
+ };
+ 
+ int __weak arch_kexec_walk_mem(struct kexec_buf *kbuf,
+ 			       int (*func)(struct resource *, void *));
+ extern int kexec_add_buffer(struct kexec_buf *kbuf);
+ int kexec_locate_mem_hole(struct kexec_buf *kbuf);
+ #endif /* CONFIG_KEXEC_FILE */
++>>>>>>> 1d2e733b13b4 (resource: Provide resource struct in resource walk callback)
  
  struct kimage {
  	kimage_entry_t head;
diff --cc kernel/kexec_file.c
index 08daef8e5e78,e5bcd94c1efb..000000000000
--- a/kernel/kexec_file.c
+++ b/kernel/kexec_file.c
@@@ -481,14 -428,55 +482,57 @@@ static int locate_mem_hole_callback(str
  	return locate_mem_hole_bottom_up(start, end, kbuf);
  }
  
 -/**
 - * arch_kexec_walk_mem - call func(data) on free memory regions
 - * @kbuf:	Context info for the search. Also passed to @func.
 - * @func:	Function to call for each memory region.
 - *
 - * Return: The memory walk will stop when func returns a non-zero value
 - * and that value will be returned. If all free regions are visited without
 - * func returning non-zero, then zero will be returned.
 +/*
 + * Helper function for placing a buffer in a kexec segment. This assumes
 + * that kexec_mutex is held.
   */
++<<<<<<< HEAD
 +int kexec_add_buffer(struct kimage *image, char *buffer, unsigned long bufsz,
 +		     unsigned long memsz, unsigned long buf_align,
 +		     unsigned long buf_min, unsigned long buf_max,
 +		     bool top_down, unsigned long *load_addr)
++=======
+ int __weak arch_kexec_walk_mem(struct kexec_buf *kbuf,
+ 			       int (*func)(struct resource *, void *))
+ {
+ 	if (kbuf->image->type == KEXEC_TYPE_CRASH)
+ 		return walk_iomem_res_desc(crashk_res.desc,
+ 					   IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY,
+ 					   crashk_res.start, crashk_res.end,
+ 					   kbuf, func);
+ 	else
+ 		return walk_system_ram_res(0, ULONG_MAX, kbuf, func);
+ }
+ 
+ /**
+  * kexec_locate_mem_hole - find free memory for the purgatory or the next kernel
+  * @kbuf:	Parameters for the memory search.
+  *
+  * On success, kbuf->mem will have the start address of the memory region found.
+  *
+  * Return: 0 on success, negative errno on error.
+  */
+ int kexec_locate_mem_hole(struct kexec_buf *kbuf)
+ {
+ 	int ret;
+ 
+ 	ret = arch_kexec_walk_mem(kbuf, locate_mem_hole_callback);
+ 
+ 	return ret == 1 ? 0 : -EADDRNOTAVAIL;
+ }
+ 
+ /**
+  * kexec_add_buffer - place a buffer in a kexec segment
+  * @kbuf:	Buffer contents and memory parameters.
+  *
+  * This function assumes that kexec_mutex is held.
+  * On successful return, @kbuf->mem will have the physical address of
+  * the buffer in memory.
+  *
+  * Return: 0 on success, negative errno on error.
+  */
+ int kexec_add_buffer(struct kexec_buf *kbuf)
++>>>>>>> 1d2e733b13b4 (resource: Provide resource struct in resource walk callback)
  {
  
  	struct kexec_segment *ksegment;
diff --cc kernel/resource.c
index c6ecc9dca549,8430042fa77b..000000000000
--- a/kernel/resource.c
+++ b/kernel/resource.c
@@@ -391,23 -400,45 +391,52 @@@ static int find_next_iomem_res(struct r
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int __walk_iomem_res_desc(struct resource *res, unsigned long desc,
+ 				 bool first_level_children_only,
+ 				 void *arg,
+ 				 int (*func)(struct resource *, void *))
+ {
+ 	u64 orig_end = res->end;
+ 	int ret = -1;
+ 
+ 	while ((res->start < res->end) &&
+ 	       !find_next_iomem_res(res, desc, first_level_children_only)) {
+ 		ret = (*func)(res, arg);
+ 		if (ret)
+ 			break;
+ 
+ 		res->start = res->end + 1;
+ 		res->end = orig_end;
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 1d2e733b13b4 (resource: Provide resource struct in resource walk callback)
  /*
   * Walks through iomem resources and calls func() with matching resource
   * ranges. This walks through whole tree and not just first level children.
   * All the memory ranges which overlap start,end and also match flags and
 - * desc are valid candidates.
 + * name are valid candidates.
   *
 - * @desc: I/O resource descriptor. Use IORES_DESC_NONE to skip @desc check.
 - * @flags: I/O resource flags
 + * @name: name of resource
 + * @flags: resource flags
   * @start: start addr
   * @end: end addr
 - *
 - * NOTE: For a new descriptor search, define a new IORES_DESC in
 - * <linux/ioport.h> and set it in 'desc' of a target resource entry.
   */
++<<<<<<< HEAD
 +int walk_iomem_res(char *name, unsigned long flags, u64 start, u64 end,
 +		void *arg, int (*func)(u64, u64, void *))
++=======
+ int walk_iomem_res_desc(unsigned long desc, unsigned long flags, u64 start,
+ 		u64 end, void *arg, int (*func)(struct resource *, void *))
++>>>>>>> 1d2e733b13b4 (resource: Provide resource struct in resource walk callback)
  {
  	struct resource res;
 +	u64 orig_end;
 +	int ret = -1;
  
  	res.start = start;
  	res.end = end;
@@@ -432,11 -455,9 +461,11 @@@
   * ranges.
   */
  int walk_system_ram_res(u64 start, u64 end, void *arg,
- 				int (*func)(u64, u64, void *))
+ 				int (*func)(struct resource *, void *))
  {
  	struct resource res;
 +	u64 orig_end;
 +	int ret = -1;
  
  	res.start = start;
  	res.end = end;
* Unmerged path arch/powerpc/kernel/machine_kexec_file_64.c
* Unmerged path arch/powerpc/kernel/machine_kexec_file_64.c
diff --git a/arch/x86/kernel/crash.c b/arch/x86/kernel/crash.c
index 34f40056ff8a..dcefc1badf6d 100644
--- a/arch/x86/kernel/crash.c
+++ b/arch/x86/kernel/crash.c
@@ -212,7 +212,7 @@ void native_machine_crash_shutdown(struct pt_regs *regs)
 }
 
 #ifdef CONFIG_KEXEC_FILE
-static int get_nr_ram_ranges_callback(u64 start, u64 end, void *arg)
+static int get_nr_ram_ranges_callback(struct resource *res, void *arg)
 {
 	unsigned int *nr_ranges = arg;
 
@@ -343,7 +343,7 @@ static int elf_header_exclude_ranges(struct crash_elf_data *ced,
 	return ret;
 }
 
-static int prepare_elf64_ram_headers_callback(u64 start, u64 end, void *arg)
+static int prepare_elf64_ram_headers_callback(struct resource *res, void *arg)
 {
 	struct crash_elf_data *ced = arg;
 	Elf64_Ehdr *ehdr;
@@ -356,7 +356,7 @@ static int prepare_elf64_ram_headers_callback(u64 start, u64 end, void *arg)
 	ehdr = ced->ehdr;
 
 	/* Exclude unwanted mem ranges */
-	ret = elf_header_exclude_ranges(ced, start, end);
+	ret = elf_header_exclude_ranges(ced, res->start, res->end);
 	if (ret)
 		return ret;
 
@@ -519,14 +519,14 @@ static int add_e820_entry(struct boot_params *params, struct e820entry *entry)
 	return 0;
 }
 
-static int memmap_entry_callback(u64 start, u64 end, void *arg)
+static int memmap_entry_callback(struct resource *res, void *arg)
 {
 	struct crash_memmap_data *cmd = arg;
 	struct boot_params *params = cmd->params;
 	struct e820entry ei;
 
-	ei.addr = start;
-	ei.size = end - start + 1;
+	ei.addr = res->start;
+	ei.size = res->end - res->start + 1;
 	ei.type = cmd->type;
 	add_e820_entry(params, &ei);
 
@@ -620,12 +620,12 @@ out:
 	return ret;
 }
 
-static int determine_backup_region(u64 start, u64 end, void *arg)
+static int determine_backup_region(struct resource *res, void *arg)
 {
 	struct kimage *image = arg;
 
-	image->arch.backup_src_start = start;
-	image->arch.backup_src_sz = end - start + 1;
+	image->arch.backup_src_start = res->start;
+	image->arch.backup_src_sz = res->end - res->start + 1;
 
 	/* Expecting only one range for backup region */
 	return 1;
diff --git a/arch/x86/kernel/pmem.c b/arch/x86/kernel/pmem.c
index 14415aff1813..87bf3adb6baf 100644
--- a/arch/x86/kernel/pmem.c
+++ b/arch/x86/kernel/pmem.c
@@ -6,7 +6,7 @@
 #include <linux/module.h>
 #include <linux/ioport.h>
 
-static int found(u64 start, u64 end, void *data)
+static int found(struct resource *res, void *data)
 {
 	return 1;
 }
* Unmerged path include/linux/ioport.h
* Unmerged path include/linux/kexec.h
* Unmerged path kernel/kexec_file.c
* Unmerged path kernel/resource.c
