uio: change to use the mutex lock instead of the spin lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [uio] change to use the mutex lock instead of the spin lock (Xiubo Li) [1560418]
Rebuild_FUZZ: 95.50%
commit-author Xiubo Li <xiubli@redhat.com>
commit 543af5861f41af0a5d2432f6fb5976af50f9cee5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/543af586.failed

We are hitting a regression with the following commit:

commit a93e7b331568227500186a465fee3c2cb5dffd1f
Author: Hamish Martin <hamish.martin@alliedtelesis.co.nz>
Date:   Mon May 14 13:32:23 2018 +1200

    uio: Prevent device destruction while fds are open

The problem is the addition of spin_lock_irqsave in uio_write. This
leads to hitting  uio_write -> copy_from_user -> _copy_from_user ->
might_fault and the logs filling up with sleeping warnings.

I also noticed some uio drivers allocate memory, sleep, grab mutexes
from callouts like open() and release and uio is now doing
spin_lock_irqsave while calling them.

	Reported-by: Mike Christie <mchristi@redhat.com>
CC: Hamish Martin <hamish.martin@alliedtelesis.co.nz>
	Reviewed-by: Hamish Martin <hamish.martin@alliedtelesis.co.nz>
	Signed-off-by: Xiubo Li <xiubli@redhat.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 543af5861f41af0a5d2432f6fb5976af50f9cee5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/uio/uio.c
#	include/linux/uio_driver.h
diff --cc drivers/uio/uio.c
index 6a5a7703969f,655ade4fb3b1..000000000000
--- a/drivers/uio/uio.c
+++ b/drivers/uio/uio.c
@@@ -441,11 -459,13 +441,21 @@@ static int uio_open(struct inode *inode
  	listener->event_count = atomic_read(&idev->event);
  	filep->private_data = listener;
  
++<<<<<<< HEAD
 +	if (idev->info->open) {
 +		ret = idev->info->open(idev->info, inode);
 +		if (ret)
 +			goto err_infoopen;
 +	}
++=======
+ 	mutex_lock(&idev->info_lock);
+ 	if (idev->info && idev->info->open)
+ 		ret = idev->info->open(idev->info, inode);
+ 	mutex_unlock(&idev->info_lock);
+ 	if (ret)
+ 		goto err_infoopen;
+ 
++>>>>>>> 543af5861f41 (uio: change to use the mutex lock instead of the spin lock)
  	return 0;
  
  err_infoopen:
@@@ -472,8 -495,10 +482,15 @@@ static int uio_release(struct inode *in
  	struct uio_listener *listener = filep->private_data;
  	struct uio_device *idev = listener->dev;
  
++<<<<<<< HEAD
 +	if (idev->info->release)
 +		ret = idev->info->release(idev->info, inode);
++=======
+ 	mutex_lock(&idev->info_lock);
+ 	if (idev->info && idev->info->release)
+ 		ret = idev->info->release(idev->info, inode);
+ 	mutex_unlock(&idev->info_lock);
++>>>>>>> 543af5861f41 (uio: change to use the mutex lock instead of the spin lock)
  
  	module_put(idev->owner);
  	kfree(listener);
@@@ -484,9 -510,15 +501,21 @@@ static unsigned int uio_poll(struct fil
  {
  	struct uio_listener *listener = filep->private_data;
  	struct uio_device *idev = listener->dev;
++<<<<<<< HEAD
 +
 +	if (!idev->info->irq)
 +		return -EIO;
++=======
+ 	__poll_t ret = 0;
+ 
+ 	mutex_lock(&idev->info_lock);
+ 	if (!idev->info || !idev->info->irq)
+ 		ret = -EIO;
+ 	mutex_unlock(&idev->info_lock);
+ 
+ 	if (ret)
+ 		return ret;
++>>>>>>> 543af5861f41 (uio: change to use the mutex lock instead of the spin lock)
  
  	poll_wait(filep, &idev->wait, wait);
  	if (listener->event_count != atomic_read(&idev->event))
@@@ -500,11 -532,16 +529,21 @@@ static ssize_t uio_read(struct file *fi
  	struct uio_listener *listener = filep->private_data;
  	struct uio_device *idev = listener->dev;
  	DECLARE_WAITQUEUE(wait, current);
 -	ssize_t retval = 0;
 +	ssize_t retval;
  	s32 event_count;
  
++<<<<<<< HEAD
 +	if (!idev->info->irq)
 +		return -EIO;
++=======
+ 	mutex_lock(&idev->info_lock);
+ 	if (!idev->info || !idev->info->irq)
+ 		retval = -EIO;
+ 	mutex_unlock(&idev->info_lock);
+ 
+ 	if (retval)
+ 		return retval;
++>>>>>>> 543af5861f41 (uio: change to use the mutex lock instead of the spin lock)
  
  	if (count != sizeof(s32))
  		return -EINVAL;
@@@ -552,7 -589,8 +591,12 @@@ static ssize_t uio_write(struct file *f
  	ssize_t retval;
  	s32 irq_on;
  
++<<<<<<< HEAD
 +	if (!idev->info->irq) {
++=======
+ 	mutex_lock(&idev->info_lock);
+ 	if (!idev->info || !idev->info->irq) {
++>>>>>>> 543af5861f41 (uio: change to use the mutex lock instead of the spin lock)
  		retval = -EIO;
  		goto out;
  	}
@@@ -575,6 -613,7 +619,10 @@@
  	retval = idev->info->irqcontrol(idev->info, irq_on);
  
  out:
++<<<<<<< HEAD
++=======
+ 	mutex_unlock(&idev->info_lock);
++>>>>>>> 543af5861f41 (uio: change to use the mutex lock instead of the spin lock)
  	return retval ? retval : sizeof(s32);
  }
  
@@@ -830,6 -860,7 +878,10 @@@ int __uio_register_device(struct modul
  
  	idev->owner = owner;
  	idev->info = info;
++<<<<<<< HEAD
++=======
+ 	mutex_init(&idev->info_lock);
++>>>>>>> 543af5861f41 (uio: change to use the mutex lock instead of the spin lock)
  	init_waitqueue_head(&idev->wait);
  	atomic_set(&idev->event, 0);
  
@@@ -890,13 -932,16 +942,19 @@@ void uio_unregister_device(struct uio_i
  
  	uio_free_minor(idev);
  
 -	uio_dev_del_attributes(idev);
 -
 -	if (info->irq && info->irq != UIO_IRQ_CUSTOM)
 +	if (info->irq && (info->irq != UIO_IRQ_CUSTOM))
  		free_irq(info->irq, idev);
  
++<<<<<<< HEAD
 +	uio_dev_del_attributes(idev);
++=======
+ 	mutex_lock(&idev->info_lock);
+ 	idev->info = NULL;
+ 	mutex_unlock(&idev->info_lock);
++>>>>>>> 543af5861f41 (uio: change to use the mutex lock instead of the spin lock)
  
 -	device_unregister(&idev->dev);
 +	device_destroy(&uio_class, MKDEV(uio_major, idev->minor));
 +	kfree(idev);
  
  	return;
  }
diff --cc include/linux/uio_driver.h
index 9122e4758846,6f8b68cd460f..000000000000
--- a/include/linux/uio_driver.h
+++ b/include/linux/uio_driver.h
@@@ -64,16 -68,16 +64,29 @@@ struct uio_port 
  #define MAX_UIO_PORT_REGIONS	5
  
  struct uio_device {
++<<<<<<< HEAD
 +	struct module           *owner;
 +	struct device           *dev;
 +	int                     minor;
 +	atomic_t                event;
 +	struct fasync_struct    *async_queue;
 +	wait_queue_head_t       wait;
 +	int                     vma_count;
 +	struct uio_info         *info;
 +	struct kobject          *map_dir;
 +	struct kobject          *portio_dir;
++=======
+         struct module           *owner;
+ 	struct device		dev;
+         int                     minor;
+         atomic_t                event;
+         struct fasync_struct    *async_queue;
+         wait_queue_head_t       wait;
+         struct uio_info         *info;
+ 	struct mutex		info_lock;
+         struct kobject          *map_dir;
+         struct kobject          *portio_dir;
++>>>>>>> 543af5861f41 (uio: change to use the mutex lock instead of the spin lock)
  };
  
  /**
* Unmerged path drivers/uio/uio.c
* Unmerged path include/linux/uio_driver.h
