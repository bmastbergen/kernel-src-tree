drm/nouveau/kms/nv50-: abstract head interfaces so the code can be split

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ben Skeggs <bskeggs@redhat.com>
commit 10ffe0fad53308ff54da0c6b1c5befca4e6915a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/10ffe0fa.failed

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit 10ffe0fad53308ff54da0c6b1c5befca4e6915a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/dispnv50/disp.c
diff --cc drivers/gpu/drm/nouveau/dispnv50/disp.c
index a2ea42f947c7,a23a33de401d..000000000000
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.c
@@@ -605,74 -435,35 +605,94 @@@ struct nv50_sync 
  	u32 data;
  };
  
 +static int
 +nv50_base_create(struct nvif_device *device, struct nvif_object *disp,
 +		 int head, u64 syncbuf, struct nv50_sync *base)
 +{
 +	struct nv50_disp_base_channel_dma_v0 args = {
 +		.pushbuf = 0xb0007c00 | head,
 +		.head = head,
 +	};
 +	static const s32 oclass[] = {
 +		GK110_DISP_BASE_CHANNEL_DMA,
 +		GK104_DISP_BASE_CHANNEL_DMA,
 +		GF110_DISP_BASE_CHANNEL_DMA,
 +		GT214_DISP_BASE_CHANNEL_DMA,
 +		GT200_DISP_BASE_CHANNEL_DMA,
 +		G82_DISP_BASE_CHANNEL_DMA,
 +		NV50_DISP_BASE_CHANNEL_DMA,
 +		0
 +	};
 +
 +	return nv50_dmac_create(device, disp, oclass, head, &args, sizeof(args),
 +				syncbuf, &base->base);
 +}
 +
 +/******************************************************************************
 + * Overlay
 + *****************************************************************************/
 +
 +struct nv50_ovly {
 +	struct nv50_dmac base;
 +};
 +
 +static int
 +nv50_ovly_create(struct nvif_device *device, struct nvif_object *disp,
 +		 int head, u64 syncbuf, struct nv50_ovly *ovly)
 +{
 +	struct nv50_disp_overlay_channel_dma_v0 args = {
 +		.pushbuf = 0xb0007e00 | head,
 +		.head = head,
 +	};
 +	static const s32 oclass[] = {
 +		GK104_DISP_OVERLAY_CONTROL_DMA,
 +		GF110_DISP_OVERLAY_CONTROL_DMA,
 +		GT214_DISP_OVERLAY_CHANNEL_DMA,
 +		GT200_DISP_OVERLAY_CHANNEL_DMA,
 +		G82_DISP_OVERLAY_CHANNEL_DMA,
 +		NV50_DISP_OVERLAY_CHANNEL_DMA,
 +		0
 +	};
 +
 +	return nv50_dmac_create(device, disp, oclass, head, &args, sizeof(args),
 +				syncbuf, &ovly->base);
 +}
 +
  struct nv50_head {
+ 	const struct nv50_head_func *func;
  	struct nouveau_crtc base;
 -	struct {
 -		struct nouveau_bo *nvbo[2];
 -		int next;
 -	} lut;
 +	struct nv50_ovly ovly;
 +	struct nv50_oimm oimm;
  };
  
++<<<<<<< HEAD
 +#define nv50_head(c) ((struct nv50_head *)nouveau_crtc(c))
 +#define nv50_ovly(c) (&nv50_head(c)->ovly)
 +#define nv50_oimm(c) (&nv50_head(c)->oimm)
 +#define nv50_chan(c) (&(c)->base.base)
 +#define nv50_vers(c) nv50_chan(c)->user.oclass
++=======
+ struct nv50_head_func {
+ 	void (*view)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*mode)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*ilut_set)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*ilut_clr)(struct nv50_head *);
+ 	void (*core_set)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*core_clr)(struct nv50_head *);
+ 	void (*curs_set)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*curs_clr)(struct nv50_head *);
+ 	void (*base)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*ovly)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*dither)(struct nv50_head *, struct nv50_head_atom *);
+ 	void (*procamp)(struct nv50_head *, struct nv50_head_atom *);
+ };
+ 
+ #define nv50_head(c) container_of((c), struct nv50_head, base.base)
++>>>>>>> 10ffe0fad533 (drm/nouveau/kms/nv50-: abstract head interfaces so the code can be split)
  
  struct nv50_disp {
 -	struct nvif_disp *disp;
 -	struct nv50_core *core;
 +	struct nvif_object *disp;
 +	struct nv50_mast mast;
  
  	struct nouveau_bo *sync;
  
@@@ -685,7 -476,42 +705,46 @@@ nv50_disp(struct drm_device *dev
  	return nouveau_display(dev)->priv;
  }
  
++<<<<<<< HEAD
 +#define nv50_mast(d) (&nv50_disp(d)->mast)
++=======
+ /******************************************************************************
+  * Core
+  *****************************************************************************/
+ 
+ struct nv50_core {
+ 	const struct nv50_core_func *func;
+ 	struct nv50_dmac chan;
+ };
+ 
+ struct nv50_core_func {
+ 	const struct nv50_head_func *head;
+ };
+ 
+ static int
+ core507d_new_(const struct nv50_core_func *func, struct nouveau_drm *drm,
+ 	      s32 oclass, struct nv50_core **pcore)
+ {
+ 	struct nv50_disp_core_channel_dma_v0 args = {};
+ 	struct nv50_disp *disp = nv50_disp(drm->dev);
+ 	struct nv50_core *core;
+ 	int ret;
+ 
+ 	if (!(core = *pcore = kzalloc(sizeof(*core), GFP_KERNEL)))
+ 		return -ENOMEM;
+ 	core->func = func;
+ 
+ 	ret = nv50_dmac_create(&drm->client.device, &disp->disp->object,
+ 			       &oclass, 0, &args, sizeof(args),
+ 			       disp->sync->bo.offset, &core->chan);
+ 	if (ret) {
+ 		NV_ERROR(drm, "core%04x allocation failed: %d\n", oclass, ret);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
++>>>>>>> 10ffe0fad533 (drm/nouveau/kms/nv50-: abstract head interfaces so the code can be split)
  
  /******************************************************************************
   * EVO channel helpers
@@@ -1894,26 -2038,34 +1969,51 @@@ head507d = 
  static void
  nv50_head_flush_clr(struct nv50_head *head, struct nv50_head_atom *asyh, bool y)
  {
++<<<<<<< HEAD
 +	if (asyh->clr.core && (!asyh->set.core || y))
 +		nv50_head_lut_clr(head);
++=======
+ 	if (asyh->clr.ilut && (!asyh->set.ilut || y))
+ 		head->func->ilut_clr(head);
++>>>>>>> 10ffe0fad533 (drm/nouveau/kms/nv50-: abstract head interfaces so the code can be split)
  	if (asyh->clr.core && (!asyh->set.core || y))
- 		nv50_head_core_clr(head);
+ 		head->func->core_clr(head);
  	if (asyh->clr.curs && (!asyh->set.curs || y))
- 		nv50_head_curs_clr(head);
+ 		head->func->curs_clr(head);
  }
  
  static void
  nv50_head_flush_set(struct nv50_head *head, struct nv50_head_atom *asyh)
  {
++<<<<<<< HEAD
 +	if (asyh->set.view   ) nv50_head_view    (head, asyh);
 +	if (asyh->set.mode   ) nv50_head_mode    (head, asyh);
 +	if (asyh->set.core   ) nv50_head_lut_set (head, asyh);
 +	if (asyh->set.core   ) nv50_head_core_set(head, asyh);
 +	if (asyh->set.curs   ) nv50_head_curs_set(head, asyh);
 +	if (asyh->set.base   ) nv50_head_base    (head, asyh);
 +	if (asyh->set.ovly   ) nv50_head_ovly    (head, asyh);
 +	if (asyh->set.dither ) nv50_head_dither  (head, asyh);
 +	if (asyh->set.procamp) nv50_head_procamp (head, asyh);
++=======
+ 	if (asyh->set.view   ) head->func->view    (head, asyh);
+ 	if (asyh->set.mode   ) head->func->mode    (head, asyh);
+ 	if (asyh->set.ilut   ) {
+ 		struct nouveau_bo *nvbo = head->lut.nvbo[head->lut.next];
+ 		struct drm_property_blob *blob = asyh->state.gamma_lut;
+ 		if (blob)
+ 			nv50_head_lut_load(blob, asyh->lut.mode, nvbo);
+ 		asyh->lut.offset = nvbo->bo.offset;
+ 		head->lut.next ^= 1;
+ 		head->func->ilut_set(head, asyh);
+ 	}
+ 	if (asyh->set.core   ) head->func->core_set(head, asyh);
+ 	if (asyh->set.curs   ) head->func->curs_set(head, asyh);
+ 	if (asyh->set.base   ) head->func->base    (head, asyh);
+ 	if (asyh->set.ovly   ) head->func->ovly    (head, asyh);
+ 	if (asyh->set.dither ) head->func->dither  (head, asyh);
+ 	if (asyh->set.procamp) head->func->procamp (head, asyh);
++>>>>>>> 10ffe0fad533 (drm/nouveau/kms/nv50-: abstract head interfaces so the code can be split)
  }
  
  static void
@@@ -2294,20 -2448,14 +2394,20 @@@ nv50_head_reset(struct drm_crtc *crtc
  static void
  nv50_head_destroy(struct drm_crtc *crtc)
  {
 +	struct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);
 +	struct nv50_disp *disp = nv50_disp(crtc->dev);
  	struct nv50_head *head = nv50_head(crtc);
 -	int i;
  
 -	for (i = 0; i < ARRAY_SIZE(head->lut.nvbo); i++)
 -		nouveau_bo_unmap_unpin_unref(&head->lut.nvbo[i]);
 +	nv50_dmac_destroy(&head->ovly.base, disp->disp);
 +	nv50_pioc_destroy(&head->oimm.base);
 +
 +	nouveau_bo_unmap(nv_crtc->lut.nvbo);
 +	if (nv_crtc->lut.nvbo)
 +		nouveau_bo_unpin(nv_crtc->lut.nvbo);
 +	nouveau_bo_ref(NULL, &nv_crtc->lut.nvbo);
  
  	drm_crtc_cleanup(crtc);
- 	kfree(crtc);
+ 	kfree(head);
  }
  
  static const struct drm_crtc_funcs
@@@ -2325,22 -2473,21 +2425,26 @@@ static in
  nv50_head_create(struct drm_device *dev, int index)
  {
  	struct nouveau_drm *drm = nouveau_drm(dev);
++<<<<<<< HEAD
 +	struct nvif_device *device = &drm->client.device;
++=======
++>>>>>>> 10ffe0fad533 (drm/nouveau/kms/nv50-: abstract head interfaces so the code can be split)
  	struct nv50_disp *disp = nv50_disp(dev);
  	struct nv50_head *head;
 -	struct nv50_wndw *curs, *wndw;
 +	struct nv50_base *base;
 +	struct nv50_curs *curs;
  	struct drm_crtc *crtc;
 -	int ret, i;
 +	int ret;
  
  	head = kzalloc(sizeof(*head), GFP_KERNEL);
  	if (!head)
  		return -ENOMEM;
  
+ 	head->func = disp->core->func->head;
  	head->base.index = index;
 -	ret = nv50_base_new(drm, head->base.index, &wndw);
 +	ret = nv50_base_new(drm, head, &base);
  	if (ret == 0)
 -		ret = nv50_curs_new(drm, head->base.index, &curs);
 +		ret = nv50_curs_new(drm, head, &curs);
  	if (ret) {
  		kfree(head);
  		return ret;
@@@ -2385,6 -2515,62 +2489,65 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static const struct nv50_core_func
+ core507d = {
+ 	.head = &head507d,
+ };
+ 
+ static int
+ core507d_new(struct nouveau_drm *drm, s32 oclass, struct nv50_core **pcore)
+ {
+ 	return core507d_new_(&core507d, drm, oclass, pcore);
+ }
+ 
+ static void
+ nv50_core_del(struct nv50_core **pcore)
+ {
+ 	struct nv50_core *core = *pcore;
+ 	if (core) {
+ 		nv50_dmac_destroy(&core->chan);
+ 		kfree(*pcore);
+ 		*pcore = NULL;
+ 	}
+ }
+ 
+ static int
+ nv50_core_new(struct nouveau_drm *drm, struct nv50_core **pcore)
+ {
+ 	struct {
+ 		s32 oclass;
+ 		int version;
+ 		int (*new)(struct nouveau_drm *, s32, struct nv50_core **);
+ 	} cores[] = {
+ 		{ GP102_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GP100_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GM200_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GM107_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GK110_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GK104_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GF110_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GT214_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GT206_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{ GT200_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{   G82_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{  NV50_DISP_CORE_CHANNEL_DMA, 0, core507d_new },
+ 		{}
+ 	};
+ 	struct nv50_disp *disp = nv50_disp(drm->dev);
+ 	int cid;
+ 
+ 	cid = nvif_mclass(&disp->disp->object, cores);
+ 	if (cid < 0) {
+ 		NV_ERROR(drm, "No supported core channel class\n");
+ 		return cid;
+ 	}
+ 
+ 	return cores[cid].new(drm, cores[cid].oclass, pcore);
+ }
+ 
++>>>>>>> 10ffe0fad533 (drm/nouveau/kms/nv50-: abstract head interfaces so the code can be split)
  /******************************************************************************
   * Output path helpers
   *****************************************************************************/
* Unmerged path drivers/gpu/drm/nouveau/dispnv50/disp.c
