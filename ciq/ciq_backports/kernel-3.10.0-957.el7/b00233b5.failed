perf/x86: Export some PMU attributes in caps/ directory

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Andi Kleen <ak@linux.intel.com>
commit b00233b5306512a09e339d69ef5e390a77f2d302
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b00233b5.failed

It can be difficult to figure out for user programs what features
the x86 CPU PMU driver actually supports. Currently it requires
grepping in dmesg, but dmesg is not always available.

This adds a caps directory to /sys/bus/event_source/devices/cpu/,
similar to the caps already used on intel_pt, which can be used to
discover the available capabilities cleanly.

Three capabilities are defined:

 - pmu_name:	Underlying CPU name known to the driver
 - max_precise:	Max precise level supported
 - branches:	Known depth of LBR.

Example:

  % grep . /sys/bus/event_source/devices/cpu/caps/*
  /sys/bus/event_source/devices/cpu/caps/branches:32
  /sys/bus/event_source/devices/cpu/caps/max_precise:3
  /sys/bus/event_source/devices/cpu/caps/pmu_name:skylake

	Signed-off-by: Andi Kleen <ak@linux.intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/20170822185201.9261-3-andi@firstfloor.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit b00233b5306512a09e339d69ef5e390a77f2d302)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/events/intel/core.c
diff --cc arch/x86/events/intel/core.c
index 5aafb5e77243,8fa2abd9c8b6..000000000000
--- a/arch/x86/events/intel/core.c
+++ b/arch/x86/events/intel/core.c
@@@ -3710,6 -3849,8 +3750,11 @@@ __init int intel_pmu_init(void
  	unsigned int unused;
  	struct extra_reg *er;
  	int version, i;
++<<<<<<< HEAD
++=======
+ 	struct attribute **extra_attr = NULL;
+ 	char *name;
++>>>>>>> b00233b53065 (perf/x86: Export some PMU attributes in caps/ directory)
  
  	if (!cpu_has(&boot_cpu_data, X86_FEATURE_ARCH_PERFMON)) {
  		switch (boot_cpu_data.x86) {
@@@ -3821,8 -3964,10 +3868,9 @@@
  		intel_pmu_pebs_data_source_nhm();
  		x86_add_quirk(intel_nehalem_quirk);
  		x86_pmu.pebs_no_tlb = 1;
 -		extra_attr = nhm_format_attr;
  
  		pr_cont("Nehalem events, ");
+ 		name = "nehalem";
  		break;
  
  	case INTEL_FAM6_ATOM_PINEVIEW:
@@@ -3855,7 -4001,10 +3904,8 @@@
  		x86_pmu.pebs_constraints = intel_slm_pebs_event_constraints;
  		x86_pmu.extra_regs = intel_slm_extra_regs;
  		x86_pmu.flags |= PMU_FL_HAS_RSP_1;
 -		x86_pmu.cpu_events = slm_events_attrs;
 -		extra_attr = slm_format_attr;
  		pr_cont("Silvermont events, ");
+ 		name = "silvermont";
  		break;
  
  	case INTEL_FAM6_ATOM_GOLDMONT:
@@@ -3880,7 -4029,9 +3930,8 @@@
  		x86_pmu.lbr_pt_coexist = true;
  		x86_pmu.flags |= PMU_FL_HAS_RSP_1;
  		x86_pmu.cpu_events = glm_events_attrs;
 -		extra_attr = slm_format_attr;
  		pr_cont("Goldmont events, ");
+ 		name = "goldmont";
  		break;
  
  	case INTEL_FAM6_ATOM_GEMINI_LAKE:
@@@ -3906,7 -4057,9 +3957,8 @@@
  		x86_pmu.cpu_events = glm_events_attrs;
  		/* Goldmont Plus has 4-wide pipeline */
  		event_attr_td_total_slots_scale_glm.event_str = "4";
 -		extra_attr = slm_format_attr;
  		pr_cont("Goldmont plus events, ");
+ 		name = "goldmont_plus";
  		break;
  
  	case INTEL_FAM6_WESTMERE:
@@@ -3935,7 -4088,9 +3987,8 @@@
  			X86_CONFIG(.event=0xb1, .umask=0x3f, .inv=1, .cmask=1);
  
  		intel_pmu_pebs_data_source_nhm();
 -		extra_attr = nhm_format_attr;
  		pr_cont("Westmere events, ");
+ 		name = "westmere";
  		break;
  
  	case INTEL_FAM6_SANDYBRIDGE:
@@@ -3971,7 -4126,10 +4024,8 @@@
  		intel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =
  			X86_CONFIG(.event=0xb1, .umask=0x01, .inv=1, .cmask=1);
  
 -		extra_attr = nhm_format_attr;
 -
  		pr_cont("SandyBridge events, ");
+ 		name = "sandybridge";
  		break;
  
  	case INTEL_FAM6_IVYBRIDGE:
@@@ -4005,7 -4163,10 +4059,8 @@@
  		intel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND] =
  			X86_CONFIG(.event=0x0e, .umask=0x01, .inv=1, .cmask=1);
  
 -		extra_attr = nhm_format_attr;
 -
  		pr_cont("IvyBridge events, ");
+ 		name = "ivybridge";
  		break;
  
  
@@@ -4033,7 -4194,10 +4088,8 @@@
  		x86_pmu.get_event_constraints = hsw_get_event_constraints;
  		x86_pmu.cpu_events = hsw_events_attrs;
  		x86_pmu.lbr_double_abort = true;
 -		extra_attr = boot_cpu_has(X86_FEATURE_RTM) ?
 -			hsw_format_attr : nhm_format_attr;
  		pr_cont("Haswell events, ");
+ 		name = "haswell";
  		break;
  
  	case INTEL_FAM6_BROADWELL_CORE:
@@@ -4069,7 -4233,10 +4125,8 @@@
  		x86_pmu.get_event_constraints = hsw_get_event_constraints;
  		x86_pmu.cpu_events = hsw_events_attrs;
  		x86_pmu.limit_period = bdw_limit_period;
 -		extra_attr = boot_cpu_has(X86_FEATURE_RTM) ?
 -			hsw_format_attr : nhm_format_attr;
  		pr_cont("Broadwell events, ");
+ 		name = "broadwell";
  		break;
  
  	case INTEL_FAM6_XEON_PHI_KNL:
@@@ -4087,8 -4254,9 +4144,9 @@@
  		/* all extra regs are per-cpu when HT is on */
  		x86_pmu.flags |= PMU_FL_HAS_RSP_1;
  		x86_pmu.flags |= PMU_FL_NO_HT_SHARING;
 -		extra_attr = slm_format_attr;
 +
  		pr_cont("Knights Landing/Mill events, ");
+ 		name = "knights-landing";
  		break;
  
  	case INTEL_FAM6_SKYLAKE_MOBILE:
@@@ -4137,6 -4314,14 +4198,17 @@@
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	snprintf(pmu_name_str, sizeof pmu_name_str, "%s", name);
+ 
+ 	if (version >= 2 && extra_attr) {
+ 		x86_pmu.format_attrs = merge_attr(intel_arch3_formats_attr,
+ 						  extra_attr);
+ 		WARN_ON(!x86_pmu.format_attrs);
+ 	}
+ 
++>>>>>>> b00233b53065 (perf/x86: Export some PMU attributes in caps/ directory)
  	if (x86_pmu.num_counters > INTEL_PMC_MAX_GENERIC) {
  		WARN(1, KERN_ERR "hw perf events %d > max(%d), clipping!",
  		     x86_pmu.num_counters, INTEL_PMC_MAX_GENERIC);
diff --git a/arch/x86/events/core.c b/arch/x86/events/core.c
index d8ebf9d6cf72..310a80a4e095 100644
--- a/arch/x86/events/core.c
+++ b/arch/x86/events/core.c
@@ -477,22 +477,28 @@ static inline int precise_br_compat(struct perf_event *event)
 	return m == b;
 }
 
-int x86_pmu_hw_config(struct perf_event *event)
+int x86_pmu_max_precise(void)
 {
-	if (event->attr.precise_ip) {
-		int precise = 0;
+	int precise = 0;
+
+	/* Support for constant skid */
+	if (x86_pmu.pebs_active && !x86_pmu.pebs_broken) {
+		precise++;
 
-		/* Support for constant skid */
-		if (x86_pmu.pebs_active && !x86_pmu.pebs_broken) {
+		/* Support for IP fixup */
+		if (x86_pmu.lbr_nr || x86_pmu.intel_cap.pebs_format >= 2)
 			precise++;
 
-			/* Support for IP fixup */
-			if (x86_pmu.lbr_nr || x86_pmu.intel_cap.pebs_format >= 2)
-				precise++;
+		if (x86_pmu.pebs_prec_dist)
+			precise++;
+	}
+	return precise;
+}
 
-			if (x86_pmu.pebs_prec_dist)
-				precise++;
-		}
+int x86_pmu_hw_config(struct perf_event *event)
+{
+	if (event->attr.precise_ip) {
+		int precise = x86_pmu_max_precise();
 
 		if (event->attr.precise_ip > precise)
 			return -EOPNOTSUPP;
@@ -1714,6 +1720,10 @@ ssize_t x86_event_sysfs_show(char *page, u64 config, u64 event)
 
 static struct attribute_group x86_pmu_attr_group;
 
+static struct attribute_group x86_pmu_caps_group = {
+	.name = "caps",
+};
+
 static int __init init_hw_perf_events(void)
 {
 	struct x86_pmu_quirk *quirk;
@@ -1760,6 +1770,7 @@ static int __init init_hw_perf_events(void)
 				   0, x86_pmu.num_counters, 0, 0);
 
 	x86_pmu_format_group.attrs = x86_pmu.format_attrs;
+	x86_pmu_caps_group.attrs = x86_pmu.caps_attrs;
 
 	if (x86_pmu.event_attrs)
 		x86_pmu_events_group.attrs = x86_pmu.event_attrs;
@@ -2108,6 +2119,7 @@ static const struct attribute_group *x86_pmu_attr_groups[] = {
 	&x86_pmu_attr_group,
 	&x86_pmu_format_group,
 	&x86_pmu_events_group,
+	&x86_pmu_caps_group,
 	NULL,
 };
 
* Unmerged path arch/x86/events/intel/core.c
diff --git a/arch/x86/events/perf_event.h b/arch/x86/events/perf_event.h
index 24270b406370..779d607e303d 100644
--- a/arch/x86/events/perf_event.h
+++ b/arch/x86/events/perf_event.h
@@ -557,6 +557,7 @@ struct x86_pmu {
 	int		attr_rdpmc;
 	struct attribute **format_attrs;
 	struct attribute **event_attrs;
+	struct attribute **caps_attrs;
 
 	ssize_t		(*events_sysfs_show)(char *page, u64 config);
 	struct attribute **cpu_events;
@@ -732,6 +733,8 @@ int x86_reserve_hardware(void);
 
 void x86_release_hardware(void);
 
+int x86_pmu_max_precise(void);
+
 void hw_perf_lbr_event_destroy(struct perf_event *event);
 
 int x86_setup_perfctr(struct perf_event *event);
