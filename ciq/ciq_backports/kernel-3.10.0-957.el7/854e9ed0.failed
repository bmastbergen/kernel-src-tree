mm: support madvise(MADV_FREE)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mm] madvise: support madvise(MADV_FREE) (Rafael Aquini) [1562137]
Rebuild_FUZZ: 89.23%
commit-author Minchan Kim <minchan@kernel.org>
commit 854e9ed09dedf0c19ac8640e91bcc74bc3f9e5c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/854e9ed0.failed

Linux doesn't have an ability to free pages lazy while other OS already
have been supported that named by madvise(MADV_FREE).

The gain is clear that kernel can discard freed pages rather than
swapping out or OOM if memory pressure happens.

Without memory pressure, freed pages would be reused by userspace
without another additional overhead(ex, page fault + allocation +
zeroing).

Jason Evans said:

: Facebook has been using MAP_UNINITIALIZED
: (https://lkml.org/lkml/2012/1/18/308) in some of its applications for
: several years, but there are operational costs to maintaining this
: out-of-tree in our kernel and in jemalloc, and we are anxious to retire it
: in favor of MADV_FREE.  When we first enabled MAP_UNINITIALIZED it
: increased throughput for much of our workload by ~5%, and although the
: benefit has decreased using newer hardware and kernels, there is still
: enough benefit that we cannot reasonably retire it without a replacement.
:
: Aside from Facebook operations, there are numerous broadly used
: applications that would benefit from MADV_FREE.  The ones that immediately
: come to mind are redis, varnish, and MariaDB.  I don't have much insight
: into Android internals and development process, but I would hope to see
: MADV_FREE support eventually end up there as well to benefit applications
: linked with the integrated jemalloc.
:
: jemalloc will use MADV_FREE once it becomes available in the Linux kernel.
: In fact, jemalloc already uses MADV_FREE or equivalent everywhere it's
: available: *BSD, OS X, Windows, and Solaris -- every platform except Linux
: (and AIX, but I'm not sure it even compiles on AIX).  The lack of
: MADV_FREE on Linux forced me down a long series of increasingly
: sophisticated heuristics for madvise() volume reduction, and even so this
: remains a common performance issue for people using jemalloc on Linux.
: Please integrate MADV_FREE; many people will benefit substantially.

How it works:

When madvise syscall is called, VM clears dirty bit of ptes of the
range.  If memory pressure happens, VM checks dirty bit of page table
and if it found still "clean", it means it's a "lazyfree pages" so VM
could discard the page instead of swapping out.  Once there was store
operation for the page before VM peek a page to reclaim, dirty bit is
set so VM can swap out the page instead of discarding.

One thing we should notice is that basically, MADV_FREE relies on dirty
bit in page table entry to decide whether VM allows to discard the page
or not.  IOW, if page table entry includes marked dirty bit, VM
shouldn't discard the page.

However, as a example, if swap-in by read fault happens, page table
entry doesn't have dirty bit so MADV_FREE could discard the page
wrongly.

For avoiding the problem, MADV_FREE did more checks with PageDirty and
PageSwapCache.  It worked out because swapped-in page lives on swap
cache and since it is evicted from the swap cache, the page has PG_dirty
flag.  So both page flags check effectively prevent wrong discarding by
MADV_FREE.

However, a problem in above logic is that swapped-in page has PG_dirty
still after they are removed from swap cache so VM cannot consider the
page as freeable any more even if madvise_free is called in future.

Look at below example for detail.

    ptr = malloc();
    memset(ptr);
    ..
    ..
    .. heavy memory pressure so all of pages are swapped out
    ..
    ..
    var = *ptr; -> a page swapped-in and could be removed from
                   swapcache. Then, page table doesn't mark
                   dirty bit and page descriptor includes PG_dirty
    ..
    ..
    madvise_free(ptr); -> It doesn't clear PG_dirty of the page.
    ..
    ..
    ..
    .. heavy memory pressure again.
    .. In this time, VM cannot discard the page because the page
    .. has *PG_dirty*

To solve the problem, this patch clears PG_dirty if only the page is
owned exclusively by current process when madvise is called because
PG_dirty represents ptes's dirtiness in several processes so we could
clear it only if we own it exclusively.

Firstly, heavy users would be general allocators(ex, jemalloc, tcmalloc
and hope glibc supports it) and jemalloc/tcmalloc already have supported
the feature for other OS(ex, FreeBSD)

  barrios@blaptop:~/benchmark/ebizzy$ lscpu
  Architecture:          x86_64
  CPU op-mode(s):        32-bit, 64-bit
  Byte Order:            Little Endian
  CPU(s):                12
  On-line CPU(s) list:   0-11
  Thread(s) per core:    1
  Core(s) per socket:    1
  Socket(s):             12
  NUMA node(s):          1
  Vendor ID:             GenuineIntel
  CPU family:            6
  Model:                 2
  Stepping:              3
  CPU MHz:               3200.185
  BogoMIPS:              6400.53
  Virtualization:        VT-x
  Hypervisor vendor:     KVM
  Virtualization type:   full
  L1d cache:             32K
  L1i cache:             32K
  L2 cache:              4096K
  NUMA node0 CPU(s):     0-11
  ebizzy benchmark(./ebizzy -S 10 -n 512)

  Higher avg is better.

   vanilla-jemalloc             MADV_free-jemalloc

  1 thread
  records: 10                   records: 10
  avg:   2961.90                avg:  12069.70
  std:     71.96(2.43%)         std:    186.68(1.55%)
  max:   3070.00                max:  12385.00
  min:   2796.00                min:  11746.00

  2 thread
  records: 10                   records: 10
  avg:   5020.00                avg:  17827.00
  std:    264.87(5.28%)         std:    358.52(2.01%)
  max:   5244.00                max:  18760.00
  min:   4251.00                min:  17382.00

  4 thread
  records: 10                   records: 10
  avg:   8988.80                avg:  27930.80
  std:   1175.33(13.08%)        std:   3317.33(11.88%)
  max:   9508.00                max:  30879.00
  min:   5477.00                min:  21024.00

  8 thread
  records: 10                   records: 10
  avg:  13036.50                avg:  33739.40
  std:    170.67(1.31%)         std:   5146.22(15.25%)
  max:  13371.00                max:  40572.00
  min:  12785.00                min:  24088.00

  16 thread
  records: 10                   records: 10
  avg:  11092.40                avg:  31424.20
  std:    710.60(6.41%)         std:   3763.89(11.98%)
  max:  12446.00                max:  36635.00
  min:   9949.00                min:  25669.00

  32 thread
  records: 10                   records: 10
  avg:  11067.00                avg:  34495.80
  std:    971.06(8.77%)         std:   2721.36(7.89%)
  max:  12010.00                max:  38598.00
  min:   9002.00                min:  30636.00

In summary, MADV_FREE is about much faster than MADV_DONTNEED.

This patch (of 12):

Add core MADV_FREE implementation.

[akpm@linux-foundation.org: small cleanups]
	Signed-off-by: Minchan Kim <minchan@kernel.org>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Acked-by: Hugh Dickins <hughd@google.com>
	Cc: Mika Penttil <mika.penttila@nextfour.com>
	Cc: Michael Kerrisk <mtk.manpages@gmail.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Mel Gorman <mgorman@suse.de>
	Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
	Cc: Jason Evans <je@fb.com>
	Cc: Daniel Micay <danielmicay@gmail.com>
	Cc: "Kirill A. Shutemov" <kirill@shutemov.name>
	Cc: Shaohua Li <shli@kernel.org>
	Cc: <yalin.wang2010@gmail.com>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
	Cc: "Kirill A. Shutemov" <kirill@shutemov.name>
	Cc: "Shaohua Li" <shli@kernel.org>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Chen Gang <gang.chen.5i5j@gmail.com>
	Cc: Chris Zankel <chris@zankel.net>
	Cc: Darrick J. Wong <darrick.wong@oracle.com>
	Cc: David S. Miller <davem@davemloft.net>
	Cc: Helge Deller <deller@gmx.de>
	Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
	Cc: Matt Turner <mattst88@gmail.com>
	Cc: Max Filippov <jcmvbkbc@gmail.com>
	Cc: Ralf Baechle <ralf@linux-mips.org>
	Cc: Richard Henderson <rth@twiddle.net>
	Cc: Roland Dreier <roland@kernel.org>
	Cc: Russell King <rmk@arm.linux.org.uk>
	Cc: Shaohua Li <shli@kernel.org>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: Wu Fengguang <fengguang.wu@intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 854e9ed09dedf0c19ac8640e91bcc74bc3f9e5c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/rmap.c
diff --cc mm/rmap.c
index 794c49685fc7,68af2e32f7ed..000000000000
--- a/mm/rmap.c
+++ b/mm/rmap.c
@@@ -1331,70 -1409,26 +1331,80 @@@ void page_remove_rmap(struct page *page
  	 * Leaving it set also helps swapoff to reinstate ptes
  	 * faster for those pages still in swapcache.
  	 */
 +	return;
 +out:
 +	if (!anon)
 +		mem_cgroup_end_update_page_stat(page, &locked, &flags);
  }
  
+ struct rmap_private {
+ 	enum ttu_flags flags;
+ 	int lazyfreed;
+ };
+ 
  /*
 - * @arg: enum ttu_flags will be passed to this argument
 + * Subfunctions of try_to_unmap: try_to_unmap_one called
 + * repeatedly from try_to_unmap_ksm, try_to_unmap_anon or try_to_unmap_file.
   */
 -static int try_to_unmap_one(struct page *page, struct vm_area_struct *vma,
 -		     unsigned long address, void *arg)
 +int try_to_unmap_one(struct page *page, struct vm_area_struct *vma,
 +		     unsigned long address, enum ttu_flags flags)
  {
  	struct mm_struct *mm = vma->vm_mm;
  	pte_t *pte;
  	pte_t pteval;
  	spinlock_t *ptl;
  	int ret = SWAP_AGAIN;
++<<<<<<< HEAD
 +
 +	if ((flags & TTU_MIGRATION) && is_zone_device_page(page)) {
 +		swp_entry_t entry;
 +		pte_t swp_pte;
 +		pmd_t *pmdp;
 +
 +		if (!is_hmm_page(page))
 +			goto out;
 +
 +		pmdp = mm_find_pmd(mm, address);
 +		if (!pmdp)
 +			goto out;
 +
 +		pte = pte_offset_map_lock(mm, pmdp, address, &ptl);
 +		if (!pte)
 +			goto out;
 +
 +		pteval = ptep_get_and_clear(mm, address, pte);
 +		if (pte_present(pteval) || pte_none(pteval) || pte_file(pteval)) {
 +			set_pte_at(mm, address, pte, pteval);
 +			goto out_unmap;
 +		}
 +
 +		entry = pte_to_swp_entry(pteval);
 +		if (!is_hmm_entry(entry)) {
 +			set_pte_at(mm, address, pte, pteval);
 +			goto out_unmap;
 +		}
 +
 +		if (hmm_entry_to_page(entry) != page) {
 +			set_pte_at(mm, address, pte, pteval);
 +			goto out_unmap;
 +		}
 +
 +		/*
 +		 * Store the pfn of the page in a special migration
 +		 * pte. do_swap_page() will wait until the migration
 +		 * pte is removed and then restart fault handling.
 +		 */
 +		entry = make_migration_entry(page, 0);
 +		swp_pte = swp_entry_to_pte(entry);
 +		if (pte_soft_dirty(*pte))
 +			swp_pte = pte_swp_mksoft_dirty(swp_pte);
 +		set_pte_at(mm, address, pte, swp_pte);
 +		goto out_unmap;
 +	}
++=======
+ 	struct rmap_private *rp = arg;
+ 	enum ttu_flags flags = rp->flags;
++>>>>>>> 854e9ed09ded (mm: support madvise(MADV_FREE))
  
  	/* munlock has nothing to gain from examining un-locked vmas */
  	if ((flags & TTU_MUNLOCK) && !(vma->vm_flags & VM_LOCKED))
@@@ -1458,34 -1495,52 +1468,54 @@@
  	} else if (PageAnon(page)) {
  		swp_entry_t entry = { .val = page_private(page) };
  		pte_t swp_pte;
++<<<<<<< HEAD
 +
 +		if (PageSwapCache(page)) {
 +			/*
 +			 * Store the swap location in the pte.
 +			 * See handle_pte_fault() ...
 +			 */
 +			if (swap_duplicate(entry) < 0) {
 +				set_pte_at(mm, address, pte, pteval);
 +				ret = SWAP_FAIL;
 +				goto out_unmap;
 +			}
 +			if (list_empty(&mm->mmlist)) {
 +				spin_lock(&mmlist_lock);
 +				if (list_empty(&mm->mmlist))
 +					list_add(&mm->mmlist, &init_mm.mmlist);
 +				spin_unlock(&mmlist_lock);
 +			}
 +			dec_mm_counter(mm, MM_ANONPAGES);
 +			inc_mm_counter(mm, MM_SWAPENTS);
 +		} else if (IS_ENABLED(CONFIG_MIGRATION)) {
 +			/*
 +			 * Store the pfn of the page in a special migration
 +			 * pte. do_swap_page() will wait until the migration
 +			 * pte is removed and then restart fault handling.
 +			 */
 +			BUG_ON(!(flags & TTU_MIGRATION));
 +			entry = make_migration_entry(page, pte_write(pteval));
++=======
+ 		/*
+ 		 * Store the swap location in the pte.
+ 		 * See handle_pte_fault() ...
+ 		 */
+ 		VM_BUG_ON_PAGE(!PageSwapCache(page), page);
+ 
+ 		if (!PageDirty(page) && (flags & TTU_LZFREE)) {
+ 			/* It's a freeable page by MADV_FREE */
+ 			dec_mm_counter(mm, MM_ANONPAGES);
+ 			rp->lazyfreed++;
+ 			goto discard;
+ 		}
+ 
+ 		if (swap_duplicate(entry) < 0) {
+ 			set_pte_at(mm, address, pte, pteval);
+ 			ret = SWAP_FAIL;
+ 			goto out_unmap;
++>>>>>>> 854e9ed09ded (mm: support madvise(MADV_FREE))
  		}
 -		if (list_empty(&mm->mmlist)) {
 -			spin_lock(&mmlist_lock);
 -			if (list_empty(&mm->mmlist))
 -				list_add(&mm->mmlist, &init_mm.mmlist);
 -			spin_unlock(&mmlist_lock);
 -		}
 -		dec_mm_counter(mm, MM_ANONPAGES);
 -		inc_mm_counter(mm, MM_SWAPENTS);
  		swp_pte = swp_entry_to_pte(entry);
  		if (pte_soft_dirty(pteval))
  			swp_pte = pte_swp_mksoft_dirty(swp_pte);
@@@ -1500,7 -1548,8 +1530,12 @@@
  	} else
  		dec_mm_counter(mm, mm_counter_file(page));
  
++<<<<<<< HEAD
 +	page_remove_rmap(page);
++=======
+ discard:
+ 	page_remove_rmap(page, PageHuge(page));
++>>>>>>> 854e9ed09ded (mm: support madvise(MADV_FREE))
  	page_cache_release(page);
  
  out_unmap:
@@@ -1843,18 -1601,38 +1878,39 @@@ out
  int try_to_unmap(struct page *page, enum ttu_flags flags)
  {
  	int ret;
++<<<<<<< HEAD
++=======
+ 	struct rmap_private rp = {
+ 		.flags = flags,
+ 		.lazyfreed = 0,
+ 	};
+ 
+ 	struct rmap_walk_control rwc = {
+ 		.rmap_one = try_to_unmap_one,
+ 		.arg = &rp,
+ 		.done = page_not_mapped,
+ 		.anon_lock = page_lock_anon_vma_read,
+ 	};
++>>>>>>> 854e9ed09ded (mm: support madvise(MADV_FREE))
  
 -	VM_BUG_ON_PAGE(!PageHuge(page) && PageTransHuge(page), page);
 -
 -	/*
 -	 * During exec, a temporary VMA is setup and later moved.
 -	 * The VMA is moved under the anon_vma lock but not the
 -	 * page tables leading to a race where migration cannot
 -	 * find the migration ptes. Rather than increasing the
 -	 * locking requirements of exec(), migration skips
 -	 * temporary VMAs until after exec() completes.
 -	 */
 -	if ((flags & TTU_MIGRATION) && !PageKsm(page) && PageAnon(page))
 -		rwc.invalid_vma = invalid_migration_vma;
 -
 -	ret = rmap_walk(page, &rwc);
 +	BUG_ON(!PageLocked(page));
 +	VM_BUG_ON(!PageHuge(page) && PageTransHuge(page));
  
++<<<<<<< HEAD
 +	if (unlikely(PageKsm(page)))
 +		ret = try_to_unmap_ksm(page, flags);
 +	else if (PageAnon(page))
 +		ret = try_to_unmap_anon(page, flags);
 +	else
 +		ret = try_to_unmap_file(page, flags);
 +	if (ret != SWAP_MLOCK && !page_mapped(page))
++=======
+ 	if (ret != SWAP_MLOCK && !page_mapped(page)) {
++>>>>>>> 854e9ed09ded (mm: support madvise(MADV_FREE))
  		ret = SWAP_SUCCESS;
+ 		if (rp.lazyfreed && !PageDirty(page))
+ 			ret = SWAP_LZFREE;
+ 	}
  	return ret;
  }
  
@@@ -1875,14 -1653,24 +1931,28 @@@
   */
  int try_to_munlock(struct page *page)
  {
++<<<<<<< HEAD
 +	VM_BUG_ON(!PageLocked(page) || PageLRU(page));
++=======
+ 	int ret;
+ 	struct rmap_private rp = {
+ 		.flags = TTU_MUNLOCK,
+ 		.lazyfreed = 0,
+ 	};
+ 
+ 	struct rmap_walk_control rwc = {
+ 		.rmap_one = try_to_unmap_one,
+ 		.arg = &rp,
+ 		.done = page_not_mapped,
+ 		.anon_lock = page_lock_anon_vma_read,
++>>>>>>> 854e9ed09ded (mm: support madvise(MADV_FREE))
  
 -	};
 -
 -	VM_BUG_ON_PAGE(!PageLocked(page) || PageLRU(page), page);
 -
 -	ret = rmap_walk(page, &rwc);
 -	return ret;
 +	if (unlikely(PageKsm(page)))
 +		return try_to_unmap_ksm(page, TTU_MUNLOCK);
 +	else if (PageAnon(page))
 +		return try_to_unmap_anon(page, TTU_MUNLOCK);
 +	else
 +		return try_to_unmap_file(page, TTU_MUNLOCK);
  }
  
  void __put_anon_vma(struct anon_vma *anon_vma)
diff --git a/include/linux/rmap.h b/include/linux/rmap.h
index 4fef883ac5c3..f768464a30c3 100644
--- a/include/linux/rmap.h
+++ b/include/linux/rmap.h
@@ -85,6 +85,7 @@ enum ttu_flags {
 	TTU_UNMAP = 1,			/* unmap mode */
 	TTU_MIGRATION = 2,		/* migration mode */
 	TTU_MUNLOCK = 4,		/* munlock mode */
+	TTU_LZFREE = 8,			/* lazy free mode */
 
 	TTU_IGNORE_MLOCK = (1 << 8),	/* ignore mlock */
 	TTU_IGNORE_ACCESS = (1 << 9),	/* don't age */
@@ -282,5 +283,6 @@ static inline int page_mkclean(struct page *page)
 #define SWAP_AGAIN	1
 #define SWAP_FAIL	2
 #define SWAP_MLOCK	3
+#define SWAP_LZFREE	4
 
 #endif	/* _LINUX_RMAP_H */
diff --git a/include/linux/vm_event_item.h b/include/linux/vm_event_item.h
index 7289c3e69561..7f1f41abc0d7 100644
--- a/include/linux/vm_event_item.h
+++ b/include/linux/vm_event_item.h
@@ -25,6 +25,7 @@ enum vm_event_item { PGPGIN, PGPGOUT, PSWPIN, PSWPOUT,
 		FOR_ALL_ZONES(PGALLOC),
 		PGFREE, PGACTIVATE, PGDEACTIVATE,
 		PGFAULT, PGMAJFAULT,
+		PGLAZYFREED,
 		FOR_ALL_ZONES(PGREFILL),
 		FOR_ALL_ZONES(PGSTEAL_KSWAPD),
 		FOR_ALL_ZONES(PGSTEAL_DIRECT),
diff --git a/include/uapi/asm-generic/mman-common.h b/include/uapi/asm-generic/mman-common.h
index 2c8ab0e60aae..6aa485ee0ba3 100644
--- a/include/uapi/asm-generic/mman-common.h
+++ b/include/uapi/asm-generic/mman-common.h
@@ -34,6 +34,7 @@
 #define MADV_SEQUENTIAL	2		/* expect sequential page references */
 #define MADV_WILLNEED	3		/* will need these pages */
 #define MADV_DONTNEED	4		/* don't need these pages */
+#define MADV_FREE	5		/* free pages only if memory pressure */
 
 /* common parameters: try to keep these consistent across architectures */
 #define MADV_REMOVE	9		/* remove these pages & resources */
diff --git a/mm/madvise.c b/mm/madvise.c
index 896fc122d177..87b3c258b6af 100644
--- a/mm/madvise.c
+++ b/mm/madvise.c
@@ -20,6 +20,9 @@
 #include <linux/blkdev.h>
 #include <linux/swap.h>
 #include <linux/swapops.h>
+#include <linux/mmu_notifier.h>
+
+#include <asm/tlb.h>
 
 /*
  * Any behaviour which results in changes to the vma->vm_flags needs to
@@ -32,6 +35,7 @@ static int madvise_need_mmap_write(int behavior)
 	case MADV_REMOVE:
 	case MADV_WILLNEED:
 	case MADV_DONTNEED:
+	case MADV_FREE:
 		return 0;
 	default:
 		/* be safe, default to 1. list exceptions explicitly */
@@ -253,6 +257,163 @@ static long madvise_willneed(struct vm_area_struct * vma,
 	return 0;
 }
 
+static int madvise_free_pte_range(pmd_t *pmd, unsigned long addr,
+				unsigned long end, struct mm_walk *walk)
+
+{
+	struct mmu_gather *tlb = walk->private;
+	struct mm_struct *mm = tlb->mm;
+	struct vm_area_struct *vma = walk->vma;
+	spinlock_t *ptl;
+	pte_t *orig_pte, *pte, ptent;
+	struct page *page;
+
+	split_huge_pmd(vma, pmd, addr);
+	if (pmd_trans_unstable(pmd))
+		return 0;
+
+	orig_pte = pte = pte_offset_map_lock(mm, pmd, addr, &ptl);
+	arch_enter_lazy_mmu_mode();
+	for (; addr != end; pte++, addr += PAGE_SIZE) {
+		ptent = *pte;
+
+		if (!pte_present(ptent))
+			continue;
+
+		page = vm_normal_page(vma, addr, ptent);
+		if (!page)
+			continue;
+
+		/*
+		 * If pmd isn't transhuge but the page is THP and
+		 * is owned by only this process, split it and
+		 * deactivate all pages.
+		 */
+		if (PageTransCompound(page)) {
+			if (page_mapcount(page) != 1)
+				goto out;
+			get_page(page);
+			if (!trylock_page(page)) {
+				put_page(page);
+				goto out;
+			}
+			pte_unmap_unlock(orig_pte, ptl);
+			if (split_huge_page(page)) {
+				unlock_page(page);
+				put_page(page);
+				pte_offset_map_lock(mm, pmd, addr, &ptl);
+				goto out;
+			}
+			put_page(page);
+			unlock_page(page);
+			pte = pte_offset_map_lock(mm, pmd, addr, &ptl);
+			pte--;
+			addr -= PAGE_SIZE;
+			continue;
+		}
+
+		VM_BUG_ON_PAGE(PageTransCompound(page), page);
+
+		if (PageSwapCache(page) || PageDirty(page)) {
+			if (!trylock_page(page))
+				continue;
+			/*
+			 * If page is shared with others, we couldn't clear
+			 * PG_dirty of the page.
+			 */
+			if (page_mapcount(page) != 1) {
+				unlock_page(page);
+				continue;
+			}
+
+			if (PageSwapCache(page) && !try_to_free_swap(page)) {
+				unlock_page(page);
+				continue;
+			}
+
+			ClearPageDirty(page);
+			unlock_page(page);
+		}
+
+		if (pte_young(ptent) || pte_dirty(ptent)) {
+			/*
+			 * Some of architecture(ex, PPC) don't update TLB
+			 * with set_pte_at and tlb_remove_tlb_entry so for
+			 * the portability, remap the pte with old|clean
+			 * after pte clearing.
+			 */
+			ptent = ptep_get_and_clear_full(mm, addr, pte,
+							tlb->fullmm);
+
+			ptent = pte_mkold(ptent);
+			ptent = pte_mkclean(ptent);
+			set_pte_at(mm, addr, pte, ptent);
+			tlb_remove_tlb_entry(tlb, pte, addr);
+		}
+	}
+out:
+	arch_leave_lazy_mmu_mode();
+	pte_unmap_unlock(orig_pte, ptl);
+	cond_resched();
+	return 0;
+}
+
+static void madvise_free_page_range(struct mmu_gather *tlb,
+			     struct vm_area_struct *vma,
+			     unsigned long addr, unsigned long end)
+{
+	struct mm_walk free_walk = {
+		.pmd_entry = madvise_free_pte_range,
+		.mm = vma->vm_mm,
+		.private = tlb,
+	};
+
+	tlb_start_vma(tlb, vma);
+	walk_page_range(addr, end, &free_walk);
+	tlb_end_vma(tlb, vma);
+}
+
+static int madvise_free_single_vma(struct vm_area_struct *vma,
+			unsigned long start_addr, unsigned long end_addr)
+{
+	unsigned long start, end;
+	struct mm_struct *mm = vma->vm_mm;
+	struct mmu_gather tlb;
+
+	if (vma->vm_flags & (VM_LOCKED|VM_HUGETLB|VM_PFNMAP))
+		return -EINVAL;
+
+	/* MADV_FREE works for only anon vma at the moment */
+	if (!vma_is_anonymous(vma))
+		return -EINVAL;
+
+	start = max(vma->vm_start, start_addr);
+	if (start >= vma->vm_end)
+		return -EINVAL;
+	end = min(vma->vm_end, end_addr);
+	if (end <= vma->vm_start)
+		return -EINVAL;
+
+	lru_add_drain();
+	tlb_gather_mmu(&tlb, mm, start, end);
+	update_hiwater_rss(mm);
+
+	mmu_notifier_invalidate_range_start(mm, start, end);
+	madvise_free_page_range(&tlb, vma, start, end);
+	mmu_notifier_invalidate_range_end(mm, start, end);
+	tlb_finish_mmu(&tlb, start, end);
+
+	return 0;
+}
+
+static long madvise_free(struct vm_area_struct *vma,
+			     struct vm_area_struct **prev,
+			     unsigned long start, unsigned long end)
+{
+	*prev = vma;
+	return madvise_free_single_vma(vma, start, end);
+}
+
 /*
  * Application no longer needs these pages.  If the pages are dirty,
  * it's OK to just throw them away.  The app will be more careful about
@@ -425,6 +586,14 @@ madvise_vma(struct vm_area_struct *vma, struct vm_area_struct **prev,
 		return madvise_remove(vma, prev, start, end);
 	case MADV_WILLNEED:
 		return madvise_willneed(vma, prev, start, end);
+	case MADV_FREE:
+		/*
+		 * XXX: In this implementation, MADV_FREE works like
+		 * MADV_DONTNEED on swapless system or full swap.
+		 */
+		if (get_nr_swap_pages() > 0)
+			return madvise_free(vma, prev, start, end);
+		/* passthrough */
 	case MADV_DONTNEED:
 		return madvise_dontneed(vma, prev, start, end);
 	default:
@@ -444,6 +613,7 @@ madvise_behavior_valid(int behavior)
 	case MADV_REMOVE:
 	case MADV_WILLNEED:
 	case MADV_DONTNEED:
+	case MADV_FREE:
 #ifdef CONFIG_KSM
 	case MADV_MERGEABLE:
 	case MADV_UNMERGEABLE:
* Unmerged path mm/rmap.c
diff --git a/mm/swap_state.c b/mm/swap_state.c
index 6de42bfae090..dfedf8f79dc6 100644
--- a/mm/swap_state.c
+++ b/mm/swap_state.c
@@ -199,13 +199,12 @@ int add_to_swap(struct page *page, struct list_head *list)
 	 * deadlock in the swap out path.
 	 */
 	/*
-	 * Add it to the swap cache and mark it dirty
+	 * Add it to the swap cache.
 	 */
 	err = add_to_swap_cache(page, entry,
 			__GFP_HIGH|__GFP_NOMEMALLOC|__GFP_NOWARN);
 
-	if (!err) {	/* Success */
-		SetPageDirty(page);
+	if (!err) {
 		return 1;
 	} else {	/* -ENOMEM radix-tree allocation failure */
 		/*
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 4438cd89e986..f2af564ea6fb 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -815,6 +815,8 @@ static unsigned long shrink_page_list(struct list_head *page_list,
 		int may_enter_fs;
 		enum page_references references = PAGEREF_RECLAIM_CLEAN;
 		bool dirty, writeback;
+		bool lazyfree = false;
+		int ret = SWAP_SUCCESS;
 
 		cond_resched();
 
@@ -954,6 +956,7 @@ static unsigned long shrink_page_list(struct list_head *page_list,
 				goto keep_locked;
 			if (!add_to_swap(page, page_list))
 				goto activate_locked;
+			lazyfree = true;
 			may_enter_fs = 1;
 
 			/* Adding to swap updated mapping */
@@ -965,14 +968,17 @@ static unsigned long shrink_page_list(struct list_head *page_list,
 		 * processes. Try to unmap it here.
 		 */
 		if (page_mapped(page) && mapping) {
-			switch (try_to_unmap(page,
-					ttu_flags|TTU_BATCH_FLUSH)) {
+			switch (ret = try_to_unmap(page, lazyfree ?
+				(ttu_flags | TTU_BATCH_FLUSH | TTU_LZFREE) :
+				(ttu_flags | TTU_BATCH_FLUSH))) {
 			case SWAP_FAIL:
 				goto activate_locked;
 			case SWAP_AGAIN:
 				goto keep_locked;
 			case SWAP_MLOCK:
 				goto cull_mlocked;
+			case SWAP_LZFREE:
+				goto lazyfree;
 			case SWAP_SUCCESS:
 				; /* try to free the page below */
 			}
@@ -1079,6 +1085,7 @@ static unsigned long shrink_page_list(struct list_head *page_list,
 			}
 		}
 
+lazyfree:
 		if (!mapping || !__remove_mapping(mapping, page, true))
 			goto keep_locked;
 
@@ -1091,6 +1098,9 @@ static unsigned long shrink_page_list(struct list_head *page_list,
 		 */
 		__clear_page_locked(page);
 free_it:
+		if (ret == SWAP_LZFREE)
+			count_vm_event(PGLAZYFREED);
+
 		nr_reclaimed++;
 
 		/*
diff --git a/mm/vmstat.c b/mm/vmstat.c
index c8232f53f076..bf0311ec1984 100644
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@ -810,6 +810,7 @@ const char * const vmstat_text[] = {
 
 	"pgfault",
 	"pgmajfault",
+	"pglazyfreed",
 
 	TEXTS_FOR_ZONES("pgrefill")
 	TEXTS_FOR_ZONES("pgsteal_kswapd")
