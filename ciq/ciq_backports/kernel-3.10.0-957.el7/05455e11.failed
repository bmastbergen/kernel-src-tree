ceph: make writepage_nounlock() invalidate page that beyonds EOF

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Yan, Zheng <zyan@redhat.com>
commit 05455e1177f76849e0a6450e8710dcb2c361f337
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/05455e11.failed

Otherwise, the page left in state that page is associated with a
snapc, but (PageDirty(page) || PageWriteback(page)) is false.

	Signed-off-by: "Yan, Zheng" <zyan@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 05455e1177f76849e0a6450e8710dcb2c361f337)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/addr.c
diff --cc fs/ceph/addr.c
index 2c8328a70fdb,8526359c08b2..000000000000
--- a/fs/ceph/addr.c
+++ b/fs/ceph/addr.c
@@@ -440,10 -475,9 +440,16 @@@ out
   * Get ref for the oldest snapc for an inode with dirty data... that is, the
   * only snap context we are allowed to write back.
   */
++<<<<<<< HEAD
 +static struct ceph_snap_context *get_oldest_context(struct inode *inode,
 +						    loff_t *snap_size,
 +						    u64 *truncate_size,
 +						    u32 *truncate_seq)
++=======
+ static struct ceph_snap_context *
+ get_oldest_context(struct inode *inode, struct ceph_writeback_ctl *ctl,
+ 		   struct ceph_snap_context *page_snapc)
++>>>>>>> 05455e1177f7 (ceph: make writepage_nounlock() invalidate page that beyonds EOF)
  {
  	struct ceph_inode_info *ci = ceph_inode(inode);
  	struct ceph_snap_context *snapc = NULL;
@@@ -453,16 -487,33 +459,45 @@@
  	list_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {
  		dout(" cap_snap %p snapc %p has %d dirty pages\n", capsnap,
  		     capsnap->context, capsnap->dirty_pages);
++<<<<<<< HEAD
 +		if (capsnap->dirty_pages) {
 +			snapc = ceph_get_snap_context(capsnap->context);
 +			if (snap_size)
 +				*snap_size = capsnap->size;
 +			if (truncate_size)
 +				*truncate_size = capsnap->truncate_size;
 +			if (truncate_seq)
 +				*truncate_seq = capsnap->truncate_seq;
 +			break;
++=======
+ 		if (!capsnap->dirty_pages)
+ 			continue;
+ 
+ 		/* get i_size, truncate_{seq,size} for page_snapc? */
+ 		if (snapc && capsnap->context != page_snapc)
+ 			continue;
+ 
+ 		if (ctl) {
+ 			if (capsnap->writing) {
+ 				ctl->i_size = i_size_read(inode);
+ 				ctl->size_stable = false;
+ 			} else {
+ 				ctl->i_size = capsnap->size;
+ 				ctl->size_stable = true;
+ 			}
+ 			ctl->truncate_size = capsnap->truncate_size;
+ 			ctl->truncate_seq = capsnap->truncate_seq;
++>>>>>>> 05455e1177f7 (ceph: make writepage_nounlock() invalidate page that beyonds EOF)
  		}
+ 
+ 		if (snapc)
+ 			break;
+ 
+ 		snapc = ceph_get_snap_context(capsnap->context);
+ 		if (!page_snapc ||
+ 		    page_snapc == snapc ||
+ 		    page_snapc->seq > snapc->seq)
+ 			break;
  	}
  	if (!snapc && ci->i_wrbuffer_ref_head) {
  		snapc = ceph_get_snap_context(ci->i_head_snapc);
@@@ -510,8 -586,7 +545,12 @@@ static int writepage_nounlock(struct pa
  		dout("writepage %p page %p not dirty?\n", inode, page);
  		return 0;
  	}
++<<<<<<< HEAD
 +	oldest = get_oldest_context(inode, &snap_size,
 +				    &truncate_size, &truncate_seq);
++=======
+ 	oldest = get_oldest_context(inode, &ceph_wbc, snapc);
++>>>>>>> 05455e1177f7 (ceph: make writepage_nounlock() invalidate page that beyonds EOF)
  	if (snapc->seq > oldest->seq) {
  		dout("writepage %p page %p snapc %p not writeable - noop\n",
  		     inode, page, snapc);
@@@ -523,12 -598,10 +562,18 @@@
  	}
  	ceph_put_snap_context(oldest);
  
 +	if (snap_size == -1)
 +		snap_size = i_size_read(inode);
 +
  	/* is this a partial page at end of file? */
++<<<<<<< HEAD
 +	if (page_off >= snap_size) {
 +		dout("%p page eof %llu\n", page, snap_size);
++=======
+ 	if (page_off >= ceph_wbc.i_size) {
+ 		dout("%p page eof %llu\n", page, ceph_wbc.i_size);
+ 		page->mapping->a_ops->invalidatepage(page, 0, PAGE_SIZE);
++>>>>>>> 05455e1177f7 (ceph: make writepage_nounlock() invalidate page that beyonds EOF)
  		return 0;
  	}
  
@@@ -761,9 -830,7 +806,13 @@@ static int ceph_writepages_start(struc
  retry:
  	/* find oldest snap context with dirty data */
  	ceph_put_snap_context(snapc);
++<<<<<<< HEAD
 +	snap_size = -1;
 +	snapc = get_oldest_context(inode, &snap_size,
 +				   &truncate_size, &truncate_seq);
++=======
+ 	snapc = get_oldest_context(inode, &ceph_wbc, NULL);
++>>>>>>> 05455e1177f7 (ceph: make writepage_nounlock() invalidate page that beyonds EOF)
  	if (!snapc) {
  		/* hmm, why does writepages get called when there
  		   is no dirty data? */
@@@ -1112,8 -1176,7 +1161,12 @@@ out
  static int context_is_writeable_or_written(struct inode *inode,
  					   struct ceph_snap_context *snapc)
  {
++<<<<<<< HEAD
 +	struct ceph_snap_context *oldest = get_oldest_context(inode, NULL,
 +							      NULL, NULL);
++=======
+ 	struct ceph_snap_context *oldest = get_oldest_context(inode, NULL, NULL);
++>>>>>>> 05455e1177f7 (ceph: make writepage_nounlock() invalidate page that beyonds EOF)
  	int ret = !oldest || snapc->seq <= oldest->seq;
  
  	ceph_put_snap_context(oldest);
@@@ -1158,8 -1221,7 +1211,12 @@@ retry_locked
  		 * this page is already dirty in another (older) snap
  		 * context!  is it writeable now?
  		 */
++<<<<<<< HEAD
 +		oldest = get_oldest_context(inode, NULL, NULL, NULL);
 +
++=======
+ 		oldest = get_oldest_context(inode, NULL, NULL);
++>>>>>>> 05455e1177f7 (ceph: make writepage_nounlock() invalidate page that beyonds EOF)
  		if (snapc->seq > oldest->seq) {
  			ceph_put_snap_context(oldest);
  			dout(" page %p snapc %p not current or oldest\n",
* Unmerged path fs/ceph/addr.c
