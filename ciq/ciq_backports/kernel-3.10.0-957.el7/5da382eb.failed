perf/x86: Fix caps/ for !Intel

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit 5da382eb6ea37e2c49ef521c636d73f6ecc3fa81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5da382eb.failed

Move the 'max_precise' capability into generic x86 code where it
belongs. This fixes a sysfs splat on !Intel systems where we fail to set
x86_pmu_caps_group.atts.

Reported-and-tested-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Andi Kleen <ak@linux.intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: hpa@zytor.com
Fixes: 22688d1c20f5 ("x86/perf: Export some PMU attributes in caps/ directory")
Link: http://lkml.kernel.org/r/20170828104650.2u3rsim4jafyjzv2@hirez.programming.kicks-ass.net
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 5da382eb6ea37e2c49ef521c636d73f6ecc3fa81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/events/core.c
#	arch/x86/events/intel/core.c
diff --cc arch/x86/events/core.c
index d8ebf9d6cf72,73a6311c8baa..000000000000
--- a/arch/x86/events/core.c
+++ b/arch/x86/events/core.c
@@@ -1713,6 -1757,7 +1713,10 @@@ ssize_t x86_event_sysfs_show(char *page
  }
  
  static struct attribute_group x86_pmu_attr_group;
++<<<<<<< HEAD
++=======
+ static struct attribute_group x86_pmu_caps_group;
++>>>>>>> 5da382eb6ea3 (perf/x86: Fix caps/ for !Intel)
  
  static int __init init_hw_perf_events(void)
  {
@@@ -1760,6 -1805,14 +1764,17 @@@
  				   0, x86_pmu.num_counters, 0, 0);
  
  	x86_pmu_format_group.attrs = x86_pmu.format_attrs;
++<<<<<<< HEAD
++=======
+ 
+ 	if (x86_pmu.caps_attrs) {
+ 		struct attribute **tmp;
+ 
+ 		tmp = merge_attr(x86_pmu_caps_group.attrs, x86_pmu.caps_attrs);
+ 		if (!WARN_ON(!tmp))
+ 			x86_pmu_caps_group.attrs = tmp;
+ 	}
++>>>>>>> 5da382eb6ea3 (perf/x86: Fix caps/ for !Intel)
  
  	if (x86_pmu.event_attrs)
  		x86_pmu_events_group.attrs = x86_pmu.event_attrs;
diff --cc arch/x86/events/intel/core.c
index 5aafb5e77243,829e89cfcee2..000000000000
--- a/arch/x86/events/intel/core.c
+++ b/arch/x86/events/intel/core.c
@@@ -3696,6 -3795,36 +3696,39 @@@ done
  
  static DEVICE_ATTR_RW(freeze_on_smi);
  
++<<<<<<< HEAD
++=======
+ static ssize_t branches_show(struct device *cdev,
+ 			     struct device_attribute *attr,
+ 			     char *buf)
+ {
+ 	return snprintf(buf, PAGE_SIZE, "%d\n", x86_pmu.lbr_nr);
+ }
+ 
+ static DEVICE_ATTR_RO(branches);
+ 
+ static struct attribute *lbr_attrs[] = {
+ 	&dev_attr_branches.attr,
+ 	NULL
+ };
+ 
+ static char pmu_name_str[30];
+ 
+ static ssize_t pmu_name_show(struct device *cdev,
+ 			     struct device_attribute *attr,
+ 			     char *buf)
+ {
+ 	return snprintf(buf, PAGE_SIZE, "%s\n", pmu_name_str);
+ }
+ 
+ static DEVICE_ATTR_RO(pmu_name);
+ 
+ static struct attribute *intel_pmu_caps_attrs[] = {
+        &dev_attr_pmu_name.attr,
+        NULL
+ };
+ 
++>>>>>>> 5da382eb6ea3 (perf/x86: Fix caps/ for !Intel)
  static struct attribute *intel_pmu_attrs[] = {
  	&dev_attr_freeze_on_smi.attr,
  	NULL,
* Unmerged path arch/x86/events/core.c
* Unmerged path arch/x86/events/intel/core.c
