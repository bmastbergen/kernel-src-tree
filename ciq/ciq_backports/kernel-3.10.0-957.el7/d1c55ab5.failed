bpf: prepare bpf_int_jit_compile/bpf_prog_select_runtime apis

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit d1c55ab5e41fcd72cb0a8bef86d3f652ad9ad9f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d1c55ab5.failed

Since the blinding is strictly only called from inside eBPF JITs,
we need to change signatures for bpf_int_jit_compile() and
bpf_prog_select_runtime() first in order to prepare that the
eBPF program we're dealing with can change underneath. Hence,
for call sites, we need to return the latest prog. No functional
change in this patch.

	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d1c55ab5e41fcd72cb0a8bef86d3f652ad9ad9f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/net/bpf_jit_comp.c
#	arch/s390/net/bpf_jit_comp.c
#	arch/x86/net/bpf_jit_comp.c
#	include/linux/filter.h
#	kernel/bpf/core.c
#	kernel/bpf/syscall.c
#	lib/test_bpf.c
#	net/core/filter.c
diff --cc arch/s390/net/bpf_jit_comp.c
index 600b1e5c8c9d,fcf301a889e7..000000000000
--- a/arch/s390/net/bpf_jit_comp.c
+++ b/arch/s390/net/bpf_jit_comp.c
@@@ -641,187 -1060,269 +641,227 @@@ call_fn:	/* lg %r1,<d(function)>(%r13) 
  		/* j <exit> */
  		EMIT4_PCREL(0xa7f40000, jit->exit_ip - jit->prg);
  		break;
 -	/*
 -	 * Branch relative (number of skipped instructions) to offset on
 -	 * condition.
 -	 *
 -	 * Condition code to mask mapping:
 -	 *
 -	 * CC | Description	   | Mask
 -	 * ------------------------------
 -	 * 0  | Operands equal	   |	8
 -	 * 1  | First operand low  |	4
 -	 * 2  | First operand high |	2
 -	 * 3  | Unused		   |	1
 -	 *
 -	 * For s390x relative branches: ip = ip + off_bytes
 -	 * For BPF relative branches:	insn = insn + off_insns + 1
 -	 *
 -	 * For example for s390x with offset 0 we jump to the branch
 -	 * instruction itself (loop) and for BPF with offset 0 we
 -	 * branch to the instruction behind the branch.
 -	 */
 -	case BPF_JMP | BPF_JA: /* if (true) */
 -		mask = 0xf000; /* j */
 -		goto branch_oc;
 -	case BPF_JMP | BPF_JSGT | BPF_K: /* ((s64) dst > (s64) imm) */
 -		mask = 0x2000; /* jh */
 -		goto branch_ks;
 -	case BPF_JMP | BPF_JSGE | BPF_K: /* ((s64) dst >= (s64) imm) */
 -		mask = 0xa000; /* jhe */
 -		goto branch_ks;
 -	case BPF_JMP | BPF_JGT | BPF_K: /* (dst_reg > imm) */
 -		mask = 0x2000; /* jh */
 -		goto branch_ku;
 -	case BPF_JMP | BPF_JGE | BPF_K: /* (dst_reg >= imm) */
 -		mask = 0xa000; /* jhe */
 -		goto branch_ku;
 -	case BPF_JMP | BPF_JNE | BPF_K: /* (dst_reg != imm) */
 -		mask = 0x7000; /* jne */
 -		goto branch_ku;
 -	case BPF_JMP | BPF_JEQ | BPF_K: /* (dst_reg == imm) */
 -		mask = 0x8000; /* je */
 -		goto branch_ku;
 -	case BPF_JMP | BPF_JSET | BPF_K: /* (dst_reg & imm) */
 -		mask = 0x7000; /* jnz */
 -		/* lgfi %w1,imm (load sign extend imm) */
 -		EMIT6_IMM(0xc0010000, REG_W1, imm);
 -		/* ngr %w1,%dst */
 -		EMIT4(0xb9800000, REG_W1, dst_reg);
 -		goto branch_oc;
 -
 -	case BPF_JMP | BPF_JSGT | BPF_X: /* ((s64) dst > (s64) src) */
 -		mask = 0x2000; /* jh */
 -		goto branch_xs;
 -	case BPF_JMP | BPF_JSGE | BPF_X: /* ((s64) dst >= (s64) src) */
 -		mask = 0xa000; /* jhe */
 -		goto branch_xs;
 -	case BPF_JMP | BPF_JGT | BPF_X: /* (dst > src) */
 -		mask = 0x2000; /* jh */
 -		goto branch_xu;
 -	case BPF_JMP | BPF_JGE | BPF_X: /* (dst >= src) */
 -		mask = 0xa000; /* jhe */
 -		goto branch_xu;
 -	case BPF_JMP | BPF_JNE | BPF_X: /* (dst != src) */
 -		mask = 0x7000; /* jne */
 -		goto branch_xu;
 -	case BPF_JMP | BPF_JEQ | BPF_X: /* (dst == src) */
 -		mask = 0x8000; /* je */
 -		goto branch_xu;
 -	case BPF_JMP | BPF_JSET | BPF_X: /* (dst & src) */
 -		mask = 0x7000; /* jnz */
 -		/* ngrk %w1,%dst,%src */
 -		EMIT4_RRF(0xb9e40000, REG_W1, dst_reg, src_reg);
 -		goto branch_oc;
 -branch_ks:
 -		/* lgfi %w1,imm (load sign extend imm) */
 -		EMIT6_IMM(0xc0010000, REG_W1, imm);
 -		/* cgrj %dst,%w1,mask,off */
 -		EMIT6_PCREL(0xec000000, 0x0064, dst_reg, REG_W1, i, off, mask);
 -		break;
 -branch_ku:
 -		/* lgfi %w1,imm (load sign extend imm) */
 -		EMIT6_IMM(0xc0010000, REG_W1, imm);
 -		/* clgrj %dst,%w1,mask,off */
 -		EMIT6_PCREL(0xec000000, 0x0065, dst_reg, REG_W1, i, off, mask);
 -		break;
 -branch_xs:
 -		/* cgrj %dst,%src,mask,off */
 -		EMIT6_PCREL(0xec000000, 0x0064, dst_reg, src_reg, i, off, mask);
 -		break;
 -branch_xu:
 -		/* clgrj %dst,%src,mask,off */
 -		EMIT6_PCREL(0xec000000, 0x0065, dst_reg, src_reg, i, off, mask);
 -		break;
 -branch_oc:
 -		/* brc mask,jmp_off (branch instruction needs 4 bytes) */
 -		jmp_off = addrs[i + off + 1] - (addrs[i + 1] - 4);
 -		EMIT4_PCREL(0xa7040000 | mask << 8, jmp_off);
 +	case BPF_S_ST: /* mem[K] = A */
 +		jit->seen |= SEEN_MEM;
 +		/* st %r5,<K>(%r15) */
 +		EMIT4_DISP(0x5050f000,
 +			   (jit->seen & SEEN_DATAREF) ? 160 + K*4 : K*4);
 +		break;
 +	case BPF_S_STX: /* mem[K] = X : mov %ebx,off8(%rbp) */
 +		jit->seen |= SEEN_XREG | SEEN_MEM;
 +		/* st %r12,<K>(%r15) */
 +		EMIT4_DISP(0x50c0f000,
 +			   (jit->seen & SEEN_DATAREF) ? 160 + K*4 : K*4);
 +		break;
 +	case BPF_S_ANC_PROTOCOL: /* A = ntohs(skb->protocol); */
 +		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);
 +		/* lhi %r5,0 */
 +		EMIT4(0xa7580000);
 +		/* icm	%r5,3,<d(protocol)>(%r2) */
 +		EMIT4_DISP(0xbf532000, offsetof(struct sk_buff, protocol));
 +		break;
 +	case BPF_S_ANC_IFINDEX:	/* if (!skb->dev) return 0;
 +				 * A = skb->dev->ifindex */
 +		BUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);
 +		jit->seen |= SEEN_RET0;
 +		/* lg %r1,<d(dev)>(%r2) */
 +		EMIT6_DISP(0xe3102000, 0x0004, offsetof(struct sk_buff, dev));
 +		/* ltgr %r1,%r1 */
 +		EMIT4(0xb9020011);
 +		/* jz <ret0> */
 +		EMIT4_PCREL(0xa7840000, jit->ret0_ip - jit->prg);
 +		/* l %r5,<d(ifindex)>(%r1) */
 +		EMIT4_DISP(0x58501000, offsetof(struct net_device, ifindex));
 +		break;
 +	case BPF_S_ANC_MARK: /* A = skb->mark */
 +		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);
 +		/* l %r5,<d(mark)>(%r2) */
 +		EMIT4_DISP(0x58502000, offsetof(struct sk_buff, mark));
 +		break;
 +	case BPF_S_ANC_QUEUE: /* A = skb->queue_mapping */
 +		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);
 +		/* lhi %r5,0 */
 +		EMIT4(0xa7580000);
 +		/* icm	%r5,3,<d(queue_mapping)>(%r2) */
 +		EMIT4_DISP(0xbf532000, offsetof(struct sk_buff, queue_mapping));
 +		break;
 +	case BPF_S_ANC_HATYPE:	/* if (!skb->dev) return 0;
 +				 * A = skb->dev->type */
 +		BUILD_BUG_ON(FIELD_SIZEOF(struct net_device, type) != 2);
 +		jit->seen |= SEEN_RET0;
 +		/* lg %r1,<d(dev)>(%r2) */
 +		EMIT6_DISP(0xe3102000, 0x0004, offsetof(struct sk_buff, dev));
 +		/* ltgr %r1,%r1 */
 +		EMIT4(0xb9020011);
 +		/* jz <ret0> */
 +		EMIT4_PCREL(0xa7840000, jit->ret0_ip - jit->prg);
 +		/* lhi %r5,0 */
 +		EMIT4(0xa7580000);
 +		/* icm	%r5,3,<d(type)>(%r1) */
 +		EMIT4_DISP(0xbf531000, offsetof(struct net_device, type));
 +		break;
 +	case BPF_S_ANC_RXHASH: /* A = skb->hash */
 +		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, hash) != 4);
 +		/* l %r5,<d(hash)>(%r2) */
 +		EMIT4_DISP(0x58502000, offsetof(struct sk_buff, hash));
 +		break;
 +	case BPF_S_ANC_VLAN_TAG:
 +	case BPF_S_ANC_VLAN_TAG_PRESENT:
 +		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, vlan_tci) != 2);
 +		BUILD_BUG_ON(VLAN_TAG_PRESENT != 0x1000);
 +		/* lhi %r5,0 */
 +		EMIT4(0xa7580000);
 +		/* icm	%r5,3,<d(vlan_tci)>(%r2) */
 +		EMIT4_DISP(0xbf532000, offsetof(struct sk_buff, vlan_tci));
 +		if (filter->code == BPF_S_ANC_VLAN_TAG) {
 +			/* nill %r5,0xefff */
 +			EMIT4_IMM(0xa5570000, ~VLAN_TAG_PRESENT);
 +		} else {
 +			/* nill %r5,0x1000 */
 +			EMIT4_IMM(0xa5570000, VLAN_TAG_PRESENT);
 +			/* srl %r5,12 */
 +			EMIT4_DISP(0x88500000, 12);
 +		}
  		break;
 -	/*
 -	 * BPF_LD
 -	 */
 -	case BPF_LD | BPF_ABS | BPF_B: /* b0 = *(u8 *) (skb->data+imm) */
 -	case BPF_LD | BPF_IND | BPF_B: /* b0 = *(u8 *) (skb->data+imm+src) */
 -		if ((BPF_MODE(insn->code) == BPF_ABS) && (imm >= 0))
 -			func_addr = __pa(sk_load_byte_pos);
 -		else
 -			func_addr = __pa(sk_load_byte);
 -		goto call_fn;
 -	case BPF_LD | BPF_ABS | BPF_H: /* b0 = *(u16 *) (skb->data+imm) */
 -	case BPF_LD | BPF_IND | BPF_H: /* b0 = *(u16 *) (skb->data+imm+src) */
 -		if ((BPF_MODE(insn->code) == BPF_ABS) && (imm >= 0))
 -			func_addr = __pa(sk_load_half_pos);
 -		else
 -			func_addr = __pa(sk_load_half);
 -		goto call_fn;
 -	case BPF_LD | BPF_ABS | BPF_W: /* b0 = *(u32 *) (skb->data+imm) */
 -	case BPF_LD | BPF_IND | BPF_W: /* b0 = *(u32 *) (skb->data+imm+src) */
 -		if ((BPF_MODE(insn->code) == BPF_ABS) && (imm >= 0))
 -			func_addr = __pa(sk_load_word_pos);
 -		else
 -			func_addr = __pa(sk_load_word);
 -		goto call_fn;
 -call_fn:
 -		jit->seen |= SEEN_SKB | SEEN_RET0 | SEEN_FUNC;
 -		REG_SET_SEEN(REG_14); /* Return address of possible func call */
 -
 -		/*
 -		 * Implicit input:
 -		 *  BPF_REG_6	 (R7) : skb pointer
 -		 *  REG_SKB_DATA (R12): skb data pointer
 -		 *
 -		 * Calculated input:
 -		 *  BPF_REG_2	 (R3) : offset of byte(s) to fetch in skb
 -		 *  BPF_REG_5	 (R6) : return address
 -		 *
 -		 * Output:
 -		 *  BPF_REG_0	 (R14): data read from skb
 -		 *
 -		 * Scratch registers (BPF_REG_1-5)
 -		 */
 -
 -		/* Call function: llilf %w1,func_addr  */
 -		EMIT6_IMM(0xc00f0000, REG_W1, func_addr);
 -
 -		/* Offset: lgfi %b2,imm */
 -		EMIT6_IMM(0xc0010000, BPF_REG_2, imm);
 -		if (BPF_MODE(insn->code) == BPF_IND)
 -			/* agfr %b2,%src (%src is s32 here) */
 -			EMIT4(0xb9180000, BPF_REG_2, src_reg);
 -
 -		/* basr %b5,%w1 (%b5 is call saved) */
 -		EMIT2(0x0d00, BPF_REG_5, REG_W1);
 -
 -		/*
 -		 * Note: For fast access we jump directly after the
 -		 * jnz instruction from bpf_jit.S
 -		 */
 -		/* jnz <ret0> */
 -		EMIT4_PCREL(0xa7740000, jit->ret0_ip - jit->prg);
 +	case BPF_S_ANC_CPU: /* A = smp_processor_id() */
 +#ifdef CONFIG_SMP
 +		/* l %r5,<d(cpu_nr)> */
 +		EMIT4_DISP(0x58500000, offsetof(struct _lowcore, cpu_nr));
 +#else
 +		/* lhi %r5,0 */
 +		EMIT4(0xa7580000);
 +#endif
  		break;
  	default: /* too complex, give up */
 -		pr_err("Unknown opcode %02x\n", insn->code);
 -		return -1;
 -	}
 -	return insn_count;
 -}
 -
 -/*
 - * Compile eBPF program into s390x code
 - */
 -static int bpf_jit_prog(struct bpf_jit *jit, struct bpf_prog *fp)
 -{
 -	int i, insn_count;
 -
 -	jit->lit = jit->lit_start;
 -	jit->prg = 0;
 -
 -	bpf_jit_prologue(jit);
 -	for (i = 0; i < fp->len; i += insn_count) {
 -		insn_count = bpf_jit_insn(jit, fp, i);
 -		if (insn_count < 0)
 -			return -1;
 -		jit->addrs[i + 1] = jit->prg; /* Next instruction address */
 +		goto out;
  	}
 -	bpf_jit_epilogue(jit);
 -
 -	jit->lit_start = jit->prg;
 -	jit->size = jit->lit;
 -	jit->size_prg = jit->prg;
 +	addrs[i] = jit->prg - jit->start;
  	return 0;
 +out:
 +	return -1;
  }
  
 -/*
 - * Classic BPF function stub. BPF programs will be converted into
 - * eBPF and then bpf_int_jit_compile() will be called.
 - */
 -void bpf_jit_compile(struct bpf_prog *fp)
 +void bpf_jit_compile(struct sk_filter *fp)
  {
++<<<<<<< HEAD
 +	unsigned long size, prg_len, lit_len;
 +	struct bpf_jit jit, cjit;
 +	unsigned int *addrs;
 +	int pass, i;
 +
 +	if (!bpf_jit_enable)
 +		return;
 +	addrs = kcalloc(fp->len, sizeof(*addrs), GFP_KERNEL);
 +	if (addrs == NULL)
 +		return;
 +	memset(&jit, 0, sizeof(cjit));
 +	memset(&cjit, 0, sizeof(cjit));
 +
 +	for (pass = 0; pass < 10; pass++) {
 +		jit.prg = jit.start;
 +		jit.lit = jit.mid;
 +
 +		bpf_jit_prologue(&jit);
 +		bpf_jit_noleaks(&jit, fp->insns);
 +		for (i = 0; i < fp->len; i++) {
 +			if (bpf_jit_insn(&jit, fp->insns + i, addrs, i,
 +					 i == fp->len - 1))
 +				goto out;
 +		}
 +		bpf_jit_epilogue(&jit);
 +		if (jit.start) {
 +			WARN_ON(jit.prg > cjit.prg || jit.lit > cjit.lit);
 +			if (memcmp(&jit, &cjit, sizeof(jit)) == 0)
 +				break;
 +		} else if (jit.prg == cjit.prg && jit.lit == cjit.lit) {
 +			prg_len = jit.prg - jit.start;
 +			lit_len = jit.lit - jit.mid;
 +			size = max_t(unsigned long, prg_len + lit_len,
 +				     sizeof(struct work_struct));
 +			if (size >= BPF_SIZE_MAX)
 +				goto out;
 +			jit.start = module_alloc(size);
 +			if (!jit.start)
 +				goto out;
 +			jit.prg = jit.mid = jit.start + prg_len;
 +			jit.lit = jit.end = jit.start + prg_len + lit_len;
 +			jit.base_ip += (unsigned long) jit.start;
 +			jit.exit_ip += (unsigned long) jit.start;
 +			jit.ret0_ip += (unsigned long) jit.start;
 +		}
 +		cjit = jit;
++=======
+ }
+ 
+ /*
+  * Compile eBPF program "fp"
+  */
+ struct bpf_prog *bpf_int_jit_compile(struct bpf_prog *fp)
+ {
+ 	struct bpf_binary_header *header;
+ 	struct bpf_jit jit;
+ 	int pass;
+ 
+ 	if (!bpf_jit_enable)
+ 		return fp;
+ 
+ 	memset(&jit, 0, sizeof(jit));
+ 	jit.addrs = kcalloc(fp->len + 1, sizeof(*jit.addrs), GFP_KERNEL);
+ 	if (jit.addrs == NULL)
+ 		return fp;
+ 	/*
+ 	 * Three initial passes:
+ 	 *   - 1/2: Determine clobbered registers
+ 	 *   - 3:   Calculate program size and addrs arrray
+ 	 */
+ 	for (pass = 1; pass <= 3; pass++) {
+ 		if (bpf_jit_prog(&jit, fp))
+ 			goto free_addrs;
++>>>>>>> d1c55ab5e41f (bpf: prepare bpf_int_jit_compile/bpf_prog_select_runtime apis)
  	}
 -	/*
 -	 * Final pass: Allocate and generate program
 -	 */
 -	if (jit.size >= BPF_SIZE_MAX)
 -		goto free_addrs;
 -	header = bpf_jit_binary_alloc(jit.size, &jit.prg_buf, 2, jit_fill_hole);
 -	if (!header)
 -		goto free_addrs;
 -	if (bpf_jit_prog(&jit, fp))
 -		goto free_addrs;
  	if (bpf_jit_enable > 1) {
 -		bpf_jit_dump(fp->len, jit.size, pass, jit.prg_buf);
 -		if (jit.prg_buf)
 -			print_fn_code(jit.prg_buf, jit.size_prg);
 +		pr_err("flen=%d proglen=%lu pass=%d image=%p\n",
 +		       fp->len, jit.end - jit.start, pass, jit.start);
 +		if (jit.start) {
 +			printk(KERN_ERR "JIT code:\n");
 +			print_fn_code(jit.start, jit.mid - jit.start);
 +			print_hex_dump(KERN_ERR, "JIT literals:\n",
 +				       DUMP_PREFIX_ADDRESS, 16, 1,
 +				       jit.mid, jit.end - jit.mid, false);
 +		}
  	}
++<<<<<<< HEAD
 +	if (jit.start)
 +		fp->bpf_func = (void *) jit.start;
 +out:
 +	kfree(addrs);
++=======
+ 	if (jit.prg_buf) {
+ 		set_memory_ro((unsigned long)header, header->pages);
+ 		fp->bpf_func = (void *) jit.prg_buf;
+ 		fp->jited = 1;
+ 	}
+ free_addrs:
+ 	kfree(jit.addrs);
+ 	return fp;
++>>>>>>> d1c55ab5e41f (bpf: prepare bpf_int_jit_compile/bpf_prog_select_runtime apis)
  }
  
 -/*
 - * Free eBPF program
 - */
 -void bpf_jit_free(struct bpf_prog *fp)
 +static void jit_free_defer(struct work_struct *arg)
  {
 -	unsigned long addr = (unsigned long)fp->bpf_func & PAGE_MASK;
 -	struct bpf_binary_header *header = (void *)addr;
 -
 -	if (!fp->jited)
 -		goto free_filter;
 +	module_free(NULL, arg);
 +}
  
 -	set_memory_rw(addr, header->pages);
 -	bpf_jit_binary_free(header);
 +/* run from softirq, we must use a work_struct to call
 + * module_free() from process context
 + */
 +void bpf_jit_free(struct sk_filter *fp)
 +{
 +	struct work_struct *work;
  
 -free_filter:
 -	bpf_prog_unlock_free(fp);
 +	if (fp->bpf_func == sk_run_filter)
 +		return;
 +	work = (struct work_struct *)fp->bpf_func;
 +	INIT_WORK(work, jit_free_defer);
 +	schedule_work(work);
  }
diff --cc arch/x86/net/bpf_jit_comp.c
index 76c7b3a140ad,6b2d23ea3590..000000000000
--- a/arch/x86/net/bpf_jit_comp.c
+++ b/arch/x86/net/bpf_jit_comp.c
@@@ -124,607 -109,1015 +124,623 @@@ static inline void bpf_flush_icache(voi
  #define CHOOSE_LOAD_FUNC(K, func) \
  	((int)K < 0 ? ((int)K >= SKF_LL_OFF ? func##_negative_offset : func) : func##_positive_offset)
  
 -/* pick a register outside of BPF range for JIT internal work */
 -#define AUX_REG (MAX_BPF_REG + 1)
 -
 -/* the following table maps BPF registers to x64 registers.
 - * x64 register r12 is unused, since if used as base address register
 - * in load/store instructions, it always needs an extra byte of encoding
 +/* Helper to find the offset of pkt_type in sk_buff
 + * We want to make sure its still a 3bit field starting at a byte boundary.
   */
 -static const int reg2hex[] = {
 -	[BPF_REG_0] = 0,  /* rax */
 -	[BPF_REG_1] = 7,  /* rdi */
 -	[BPF_REG_2] = 6,  /* rsi */
 -	[BPF_REG_3] = 2,  /* rdx */
 -	[BPF_REG_4] = 1,  /* rcx */
 -	[BPF_REG_5] = 0,  /* r8 */
 -	[BPF_REG_6] = 3,  /* rbx callee saved */
 -	[BPF_REG_7] = 5,  /* r13 callee saved */
 -	[BPF_REG_8] = 6,  /* r14 callee saved */
 -	[BPF_REG_9] = 7,  /* r15 callee saved */
 -	[BPF_REG_FP] = 5, /* rbp readonly */
 -	[AUX_REG] = 3,    /* r11 temp register */
 -};
 -
 -/* is_ereg() == true if BPF register 'reg' maps to x64 r8..r15
 - * which need extra byte of encoding.
 - * rax,rcx,...,rbp have simpler encoding
 - */
 -static bool is_ereg(u32 reg)
 -{
 -	return (1 << reg) & (BIT(BPF_REG_5) |
 -			     BIT(AUX_REG) |
 -			     BIT(BPF_REG_7) |
 -			     BIT(BPF_REG_8) |
 -			     BIT(BPF_REG_9));
 -}
 -
 -/* add modifiers if 'reg' maps to x64 registers r8..r15 */
 -static u8 add_1mod(u8 byte, u32 reg)
 -{
 -	if (is_ereg(reg))
 -		byte |= 1;
 -	return byte;
 -}
 -
 -static u8 add_2mod(u8 byte, u32 r1, u32 r2)
 +#define PKT_TYPE_MAX 7
 +static int pkt_type_offset(void)
  {
 -	if (is_ereg(r1))
 -		byte |= 1;
 -	if (is_ereg(r2))
 -		byte |= 4;
 -	return byte;
 -}
 -
 -/* encode 'dst_reg' register into x64 opcode 'byte' */
 -static u8 add_1reg(u8 byte, u32 dst_reg)
 -{
 -	return byte + reg2hex[dst_reg];
 -}
 -
 -/* encode 'dst_reg' and 'src_reg' registers into x64 opcode 'byte' */
 -static u8 add_2reg(u8 byte, u32 dst_reg, u32 src_reg)
 -{
 -	return byte + reg2hex[dst_reg] + (reg2hex[src_reg] << 3);
 +	struct sk_buff skb_probe = {
 +		.pkt_type = ~0,
 +	};
 +	char *ct = (char *)&skb_probe;
 +	unsigned int off;
 +
 +	for (off = 0; off < sizeof(struct sk_buff); off++) {
 +		if (ct[off] == PKT_TYPE_MAX)
 +			return off;
 +	}
 +	pr_err_once("Please fix pkt_type_offset(), as pkt_type couldn't be found\n");
 +	return -1;
  }
  
 -static void jit_fill_hole(void *area, unsigned int size)
 +void bpf_jit_compile(struct sk_filter *fp)
  {
 -	/* fill whole space with int3 instructions */
 -	memset(area, 0xcc, size);
++<<<<<<< HEAD
 +	u8 temp[64];
 +	u8 *prog;
 +	unsigned int proglen, oldproglen = 0;
 +	int ilen, i;
 +	int t_offset, f_offset;
 +	u8 t_op, f_op, seen = 0, pass;
++=======
+ }
+ 
 -struct jit_context {
 -	int cleanup_addr; /* epilogue code offset */
 -	bool seen_ld_abs;
 -};
 -
 -/* maximum number of bytes emitted while JITing one eBPF insn */
 -#define BPF_MAX_INSN_SIZE	128
 -#define BPF_INSN_SAFETY		64
 -
 -#define STACKSIZE \
 -	(MAX_BPF_STACK + \
 -	 32 /* space for rbx, r13, r14, r15 */ + \
 -	 8 /* space for skb_copy_bits() buffer */)
 -
 -#define PROLOGUE_SIZE 48
 -
 -/* emit x64 prologue code for BPF program and check it's size.
 - * bpf_tail_call helper will skip it while jumping into another program
 - */
 -static void emit_prologue(u8 **pprog)
 -{
 -	u8 *prog = *pprog;
 -	int cnt = 0;
 -
 -	EMIT1(0x55); /* push rbp */
 -	EMIT3(0x48, 0x89, 0xE5); /* mov rbp,rsp */
 -
 -	/* sub rsp, STACKSIZE */
 -	EMIT3_off32(0x48, 0x81, 0xEC, STACKSIZE);
 -
 -	/* all classic BPF filters use R6(rbx) save it */
 -
 -	/* mov qword ptr [rbp-X],rbx */
 -	EMIT3_off32(0x48, 0x89, 0x9D, -STACKSIZE);
 -
 -	/* bpf_convert_filter() maps classic BPF register X to R7 and uses R8
 -	 * as temporary, so all tcpdump filters need to spill/fill R7(r13) and
 -	 * R8(r14). R9(r15) spill could be made conditional, but there is only
 -	 * one 'bpf_error' return path out of helper functions inside bpf_jit.S
 -	 * The overhead of extra spill is negligible for any filter other
 -	 * than synthetic ones. Therefore not worth adding complexity.
 -	 */
 -
 -	/* mov qword ptr [rbp-X],r13 */
 -	EMIT3_off32(0x4C, 0x89, 0xAD, -STACKSIZE + 8);
 -	/* mov qword ptr [rbp-X],r14 */
 -	EMIT3_off32(0x4C, 0x89, 0xB5, -STACKSIZE + 16);
 -	/* mov qword ptr [rbp-X],r15 */
 -	EMIT3_off32(0x4C, 0x89, 0xBD, -STACKSIZE + 24);
 -
 -	/* Clear the tail call counter (tail_call_cnt): for eBPF tail calls
 -	 * we need to reset the counter to 0. It's done in two instructions,
 -	 * resetting rax register to 0 (xor on eax gets 0 extended), and
 -	 * moving it to the counter location.
 -	 */
 -
 -	/* xor eax, eax */
 -	EMIT2(0x31, 0xc0);
 -	/* mov qword ptr [rbp-X], rax */
 -	EMIT3_off32(0x48, 0x89, 0x85, -STACKSIZE + 32);
 -
 -	BUILD_BUG_ON(cnt != PROLOGUE_SIZE);
 -	*pprog = prog;
 -}
 -
 -/* generate the following code:
 - * ... bpf_tail_call(void *ctx, struct bpf_array *array, u64 index) ...
 - *   if (index >= array->map.max_entries)
 - *     goto out;
 - *   if (++tail_call_cnt > MAX_TAIL_CALL_CNT)
 - *     goto out;
 - *   prog = array->ptrs[index];
 - *   if (prog == NULL)
 - *     goto out;
 - *   goto *(prog->bpf_func + prologue_size);
 - * out:
 - */
 -static void emit_bpf_tail_call(u8 **pprog)
++struct bpf_prog *bpf_int_jit_compile(struct bpf_prog *prog)
+ {
 -	u8 *prog = *pprog;
 -	int label1, label2, label3;
 -	int cnt = 0;
 -
 -	/* rdi - pointer to ctx
 -	 * rsi - pointer to bpf_array
 -	 * rdx - index in bpf_array
 -	 */
 -
 -	/* if (index >= array->map.max_entries)
 -	 *   goto out;
 -	 */
 -	EMIT4(0x48, 0x8B, 0x46,                   /* mov rax, qword ptr [rsi + 16] */
 -	      offsetof(struct bpf_array, map.max_entries));
 -	EMIT3(0x48, 0x39, 0xD0);                  /* cmp rax, rdx */
 -#define OFFSET1 47 /* number of bytes to jump */
 -	EMIT2(X86_JBE, OFFSET1);                  /* jbe out */
 -	label1 = cnt;
 -
 -	/* if (tail_call_cnt > MAX_TAIL_CALL_CNT)
 -	 *   goto out;
 -	 */
 -	EMIT2_off32(0x8B, 0x85, -STACKSIZE + 36); /* mov eax, dword ptr [rbp - 516] */
 -	EMIT3(0x83, 0xF8, MAX_TAIL_CALL_CNT);     /* cmp eax, MAX_TAIL_CALL_CNT */
 -#define OFFSET2 36
 -	EMIT2(X86_JA, OFFSET2);                   /* ja out */
 -	label2 = cnt;
 -	EMIT3(0x83, 0xC0, 0x01);                  /* add eax, 1 */
 -	EMIT2_off32(0x89, 0x85, -STACKSIZE + 36); /* mov dword ptr [rbp - 516], eax */
 -
 -	/* prog = array->ptrs[index]; */
 -	EMIT4_off32(0x48, 0x8D, 0x84, 0xD6,       /* lea rax, [rsi + rdx * 8 + offsetof(...)] */
 -		    offsetof(struct bpf_array, ptrs));
 -	EMIT3(0x48, 0x8B, 0x00);                  /* mov rax, qword ptr [rax] */
++	struct bpf_binary_header *header = NULL;
++	int proglen, oldproglen = 0;
++	struct jit_context ctx = {};
++>>>>>>> d1c55ab5e41f (bpf: prepare bpf_int_jit_compile/bpf_prog_select_runtime apis)
 +	u8 *image = NULL;
 +	u8 *func;
 +	int pc_ret0 = -1; /* bpf index of first RET #0 instruction (if any) */
 +	unsigned int cleanup_addr; /* epilogue code offset */
 +	unsigned int *addrs;
 +	const struct sock_filter *filter = fp->insns;
 +	int flen = fp->len;
  
 -	/* if (prog == NULL)
 -	 *   goto out;
 -	 */
 -	EMIT4(0x48, 0x83, 0xF8, 0x00);            /* cmp rax, 0 */
 -#define OFFSET3 10
 -	EMIT2(X86_JE, OFFSET3);                   /* je out */
 -	label3 = cnt;
 +	if (!bpf_jit_enable)
- 		return;
++		return prog;
  
 -	/* goto *(prog->bpf_func + prologue_size); */
 -	EMIT4(0x48, 0x8B, 0x40,                   /* mov rax, qword ptr [rax + 32] */
 -	      offsetof(struct bpf_prog, bpf_func));
 -	EMIT4(0x48, 0x83, 0xC0, PROLOGUE_SIZE);   /* add rax, prologue_size */
++<<<<<<< HEAD
 +	addrs = kmalloc(flen * sizeof(*addrs), GFP_KERNEL);
 +	if (addrs == NULL)
 +		return;
++=======
++	addrs = kmalloc(prog->len * sizeof(*addrs), GFP_KERNEL);
++	if (!addrs)
++		return prog;
++>>>>>>> d1c55ab5e41f (bpf: prepare bpf_int_jit_compile/bpf_prog_select_runtime apis)
  
 -	/* now we're ready to jump into next BPF program
 -	 * rdi == ctx (1st arg)
 -	 * rax == prog->bpf_func + prologue_size
 +	/* Before first pass, make a rough estimation of addrs[]
 +	 * each bpf instruction is translated to less than 64 bytes
  	 */
 -	EMIT2(0xFF, 0xE0);                        /* jmp rax */
 -
 -	/* out: */
 -	BUILD_BUG_ON(cnt - label1 != OFFSET1);
 -	BUILD_BUG_ON(cnt - label2 != OFFSET2);
 -	BUILD_BUG_ON(cnt - label3 != OFFSET3);
 -	*pprog = prog;
 -}
 -
 -
 -static void emit_load_skb_data_hlen(u8 **pprog)
 -{
 -	u8 *prog = *pprog;
 -	int cnt = 0;
 +	for (proglen = 0, i = 0; i < flen; i++) {
 +		proglen += 64;
 +		addrs[i] = proglen;
 +	}
 +	cleanup_addr = proglen; /* epilogue address */
  
 -	/* r9d = skb->len - skb->data_len (headlen)
 -	 * r10 = skb->data
 +	/* JITed image shrinks with every pass and the loop iterates
 +	 * until the image stops shrinking. Very large bpf programs
 +	 * may converge on the last pass. In such case do one more
 +	 * pass to emit the final image
  	 */
 -	/* mov %r9d, off32(%rdi) */
 -	EMIT3_off32(0x44, 0x8b, 0x8f, offsetof(struct sk_buff, len));
 -
 -	/* sub %r9d, off32(%rdi) */
 -	EMIT3_off32(0x44, 0x2b, 0x8f, offsetof(struct sk_buff, data_len));
 -
 -	/* mov %r10, off32(%rdi) */
 -	EMIT3_off32(0x4c, 0x8b, 0x97, offsetof(struct sk_buff, data));
 -	*pprog = prog;
 -}
 -
 -static int do_jit(struct bpf_prog *bpf_prog, int *addrs, u8 *image,
 -		  int oldproglen, struct jit_context *ctx)
 -{
 -	struct bpf_insn *insn = bpf_prog->insnsi;
 -	int insn_cnt = bpf_prog->len;
 -	bool seen_ld_abs = ctx->seen_ld_abs | (oldproglen == 0);
 -	bool seen_exit = false;
 -	u8 temp[BPF_MAX_INSN_SIZE + BPF_INSN_SAFETY];
 -	int i, cnt = 0;
 -	int proglen = 0;
 -	u8 *prog = temp;
 -
 -	emit_prologue(&prog);
 -
 -	if (seen_ld_abs)
 -		emit_load_skb_data_hlen(&prog);
 +	for (pass = 0; pass < 10 || image; pass++) {
 +		u8 seen_or_pass0 = (pass == 0) ? (SEEN_XREG | SEEN_DATAREF | SEEN_MEM) : seen;
 +		/* no prologue/epilogue for trivial filters (RET something) */
 +		proglen = 0;
 +		prog = temp;
  
 -	for (i = 0; i < insn_cnt; i++, insn++) {
 -		const s32 imm32 = insn->imm;
 -		u32 dst_reg = insn->dst_reg;
 -		u32 src_reg = insn->src_reg;
 -		u8 b1 = 0, b2 = 0, b3 = 0;
 -		s64 jmp_offset;
 -		u8 jmp_cond;
 -		bool reload_skb_data;
 -		int ilen;
 -		u8 *func;
 +		if (seen_or_pass0) {
 +			EMIT4(0x55, 0x48, 0x89, 0xe5); /* push %rbp; mov %rsp,%rbp */
 +			EMIT4(0x48, 0x83, 0xec, 96);	/* subq  $96,%rsp	*/
 +			/* note : must save %rbx in case bpf_error is hit */
 +			if (seen_or_pass0 & (SEEN_XREG | SEEN_DATAREF))
 +				EMIT4(0x48, 0x89, 0x5d, 0xf8); /* mov %rbx, -8(%rbp) */
 +			if (seen_or_pass0 & SEEN_XREG)
 +				CLEAR_X(); /* make sure we dont leek kernel memory */
 +
 +			/*
 +			 * If this filter needs to access skb data,
 +			 * loads r9 and r8 with :
 +			 *  r9 = skb->len - skb->data_len
 +			 *  r8 = skb->data
 +			 */
 +			if (seen_or_pass0 & SEEN_DATAREF) {
 +				if (offsetof(struct sk_buff, len) <= 127)
 +					/* mov    off8(%rdi),%r9d */
 +					EMIT4(0x44, 0x8b, 0x4f, offsetof(struct sk_buff, len));
 +				else {
 +					/* mov    off32(%rdi),%r9d */
 +					EMIT3(0x44, 0x8b, 0x8f);
 +					EMIT(offsetof(struct sk_buff, len), 4);
 +				}
 +				if (is_imm8(offsetof(struct sk_buff, data_len)))
 +					/* sub    off8(%rdi),%r9d */
 +					EMIT4(0x44, 0x2b, 0x4f, offsetof(struct sk_buff, data_len));
 +				else {
 +					EMIT3(0x44, 0x2b, 0x8f);
 +					EMIT(offsetof(struct sk_buff, data_len), 4);
 +				}
  
 -		switch (insn->code) {
 -			/* ALU */
 -		case BPF_ALU | BPF_ADD | BPF_X:
 -		case BPF_ALU | BPF_SUB | BPF_X:
 -		case BPF_ALU | BPF_AND | BPF_X:
 -		case BPF_ALU | BPF_OR | BPF_X:
 -		case BPF_ALU | BPF_XOR | BPF_X:
 -		case BPF_ALU64 | BPF_ADD | BPF_X:
 -		case BPF_ALU64 | BPF_SUB | BPF_X:
 -		case BPF_ALU64 | BPF_AND | BPF_X:
 -		case BPF_ALU64 | BPF_OR | BPF_X:
 -		case BPF_ALU64 | BPF_XOR | BPF_X:
 -			switch (BPF_OP(insn->code)) {
 -			case BPF_ADD: b2 = 0x01; break;
 -			case BPF_SUB: b2 = 0x29; break;
 -			case BPF_AND: b2 = 0x21; break;
 -			case BPF_OR: b2 = 0x09; break;
 -			case BPF_XOR: b2 = 0x31; break;
 +				if (is_imm8(offsetof(struct sk_buff, data)))
 +					/* mov off8(%rdi),%r8 */
 +					EMIT4(0x4c, 0x8b, 0x47, offsetof(struct sk_buff, data));
 +				else {
 +					/* mov off32(%rdi),%r8 */
 +					EMIT3(0x4c, 0x8b, 0x87);
 +					EMIT(offsetof(struct sk_buff, data), 4);
 +				}
  			}
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_2mod(0x48, dst_reg, src_reg));
 -			else if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT1(add_2mod(0x40, dst_reg, src_reg));
 -			EMIT2(b2, add_2reg(0xC0, dst_reg, src_reg));
 -			break;
 -
 -			/* mov dst, src */
 -		case BPF_ALU64 | BPF_MOV | BPF_X:
 -			EMIT_mov(dst_reg, src_reg);
 -			break;
 -
 -			/* mov32 dst, src */
 -		case BPF_ALU | BPF_MOV | BPF_X:
 -			if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT1(add_2mod(0x40, dst_reg, src_reg));
 -			EMIT2(0x89, add_2reg(0xC0, dst_reg, src_reg));
 -			break;
 +		}
  
 -			/* neg dst */
 -		case BPF_ALU | BPF_NEG:
 -		case BPF_ALU64 | BPF_NEG:
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_1mod(0x48, dst_reg));
 -			else if (is_ereg(dst_reg))
 -				EMIT1(add_1mod(0x40, dst_reg));
 -			EMIT2(0xF7, add_1reg(0xD8, dst_reg));
 +		switch (filter[0].code) {
 +		case BPF_S_RET_K:
 +		case BPF_S_LD_W_LEN:
 +		case BPF_S_ANC_PROTOCOL:
 +		case BPF_S_ANC_IFINDEX:
 +		case BPF_S_ANC_MARK:
 +		case BPF_S_ANC_RXHASH:
 +		case BPF_S_ANC_CPU:
 +		case BPF_S_ANC_VLAN_TAG:
 +		case BPF_S_ANC_VLAN_TAG_PRESENT:
 +		case BPF_S_ANC_QUEUE:
 +		case BPF_S_ANC_PKTTYPE:
 +		case BPF_S_LD_W_ABS:
 +		case BPF_S_LD_H_ABS:
 +		case BPF_S_LD_B_ABS:
 +			/* first instruction sets A register (or is RET 'constant') */
  			break;
 +		default:
 +			/* make sure we dont leak kernel information to user */
 +			CLEAR_A(); /* A = 0 */
 +		}
  
 -		case BPF_ALU | BPF_ADD | BPF_K:
 -		case BPF_ALU | BPF_SUB | BPF_K:
 -		case BPF_ALU | BPF_AND | BPF_K:
 -		case BPF_ALU | BPF_OR | BPF_K:
 -		case BPF_ALU | BPF_XOR | BPF_K:
 -		case BPF_ALU64 | BPF_ADD | BPF_K:
 -		case BPF_ALU64 | BPF_SUB | BPF_K:
 -		case BPF_ALU64 | BPF_AND | BPF_K:
 -		case BPF_ALU64 | BPF_OR | BPF_K:
 -		case BPF_ALU64 | BPF_XOR | BPF_K:
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_1mod(0x48, dst_reg));
 -			else if (is_ereg(dst_reg))
 -				EMIT1(add_1mod(0x40, dst_reg));
 -
 -			switch (BPF_OP(insn->code)) {
 -			case BPF_ADD: b3 = 0xC0; break;
 -			case BPF_SUB: b3 = 0xE8; break;
 -			case BPF_AND: b3 = 0xE0; break;
 -			case BPF_OR: b3 = 0xC8; break;
 -			case BPF_XOR: b3 = 0xF0; break;
 -			}
 -
 -			if (is_imm8(imm32))
 -				EMIT3(0x83, add_1reg(b3, dst_reg), imm32);
 -			else
 -				EMIT2_off32(0x81, add_1reg(b3, dst_reg), imm32);
 -			break;
 +		for (i = 0; i < flen; i++) {
 +			unsigned int K = filter[i].k;
  
 -		case BPF_ALU64 | BPF_MOV | BPF_K:
 -			/* optimization: if imm32 is positive,
 -			 * use 'mov eax, imm32' (which zero-extends imm32)
 -			 * to save 2 bytes
 -			 */
 -			if (imm32 < 0) {
 -				/* 'mov rax, imm32' sign extends imm32 */
 -				b1 = add_1mod(0x48, dst_reg);
 -				b2 = 0xC7;
 -				b3 = 0xC0;
 -				EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
 +			switch (filter[i].code) {
 +			case BPF_S_ALU_ADD_X: /* A += X; */
 +				seen |= SEEN_XREG;
 +				EMIT2(0x01, 0xd8);		/* add %ebx,%eax */
  				break;
 -			}
 -
 -		case BPF_ALU | BPF_MOV | BPF_K:
 -			/* optimization: if imm32 is zero, use 'xor <dst>,<dst>'
 -			 * to save 3 bytes.
 -			 */
 -			if (imm32 == 0) {
 -				if (is_ereg(dst_reg))
 -					EMIT1(add_2mod(0x40, dst_reg, dst_reg));
 -				b2 = 0x31; /* xor */
 -				b3 = 0xC0;
 -				EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
 +			case BPF_S_ALU_ADD_K: /* A += K; */
 +				if (!K)
 +					break;
 +				if (is_imm8(K))
 +					EMIT3(0x83, 0xc0, K);	/* add imm8,%eax */
 +				else
 +					EMIT1_off32(0x05, K);	/* add imm32,%eax */
  				break;
 -			}
 -
 -			/* mov %eax, imm32 */
 -			if (is_ereg(dst_reg))
 -				EMIT1(add_1mod(0x40, dst_reg));
 -			EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
 -			break;
 -
 -		case BPF_LD | BPF_IMM | BPF_DW:
 -			if (insn[1].code != 0 || insn[1].src_reg != 0 ||
 -			    insn[1].dst_reg != 0 || insn[1].off != 0) {
 -				/* verifier must catch invalid insns */
 -				pr_err("invalid BPF_LD_IMM64 insn\n");
 -				return -EINVAL;
 -			}
 -
 -			/* optimization: if imm64 is zero, use 'xor <dst>,<dst>'
 -			 * to save 7 bytes.
 -			 */
 -			if (insn[0].imm == 0 && insn[1].imm == 0) {
 -				b1 = add_2mod(0x48, dst_reg, dst_reg);
 -				b2 = 0x31; /* xor */
 -				b3 = 0xC0;
 -				EMIT3(b1, b2, add_2reg(b3, dst_reg, dst_reg));
 -
 -				insn++;
 -				i++;
 +			case BPF_S_ALU_SUB_X: /* A -= X; */
 +				seen |= SEEN_XREG;
 +				EMIT2(0x29, 0xd8);		/* sub    %ebx,%eax */
  				break;
 -			}
 -
 -			/* movabsq %rax, imm64 */
 -			EMIT2(add_1mod(0x48, dst_reg), add_1reg(0xB8, dst_reg));
 -			EMIT(insn[0].imm, 4);
 -			EMIT(insn[1].imm, 4);
 -
 -			insn++;
 -			i++;
 -			break;
 -
 -			/* dst %= src, dst /= src, dst %= imm32, dst /= imm32 */
 -		case BPF_ALU | BPF_MOD | BPF_X:
 -		case BPF_ALU | BPF_DIV | BPF_X:
 -		case BPF_ALU | BPF_MOD | BPF_K:
 -		case BPF_ALU | BPF_DIV | BPF_K:
 -		case BPF_ALU64 | BPF_MOD | BPF_X:
 -		case BPF_ALU64 | BPF_DIV | BPF_X:
 -		case BPF_ALU64 | BPF_MOD | BPF_K:
 -		case BPF_ALU64 | BPF_DIV | BPF_K:
 -			EMIT1(0x50); /* push rax */
 -			EMIT1(0x52); /* push rdx */
 -
 -			if (BPF_SRC(insn->code) == BPF_X)
 -				/* mov r11, src_reg */
 -				EMIT_mov(AUX_REG, src_reg);
 -			else
 -				/* mov r11, imm32 */
 -				EMIT3_off32(0x49, 0xC7, 0xC3, imm32);
 -
 -			/* mov rax, dst_reg */
 -			EMIT_mov(BPF_REG_0, dst_reg);
 -
 -			/* xor edx, edx
 -			 * equivalent to 'xor rdx, rdx', but one byte less
 -			 */
 -			EMIT2(0x31, 0xd2);
 -
 -			if (BPF_SRC(insn->code) == BPF_X) {
 -				/* if (src_reg == 0) return 0 */
 -
 -				/* cmp r11, 0 */
 -				EMIT4(0x49, 0x83, 0xFB, 0x00);
 -
 -				/* jne .+9 (skip over pop, pop, xor and jmp) */
 -				EMIT2(X86_JNE, 1 + 1 + 2 + 5);
 -				EMIT1(0x5A); /* pop rdx */
 -				EMIT1(0x58); /* pop rax */
 -				EMIT2(0x31, 0xc0); /* xor eax, eax */
 -
 -				/* jmp cleanup_addr
 -				 * addrs[i] - 11, because there are 11 bytes
 -				 * after this insn: div, mov, pop, pop, mov
 -				 */
 -				jmp_offset = ctx->cleanup_addr - (addrs[i] - 11);
 -				EMIT1_off32(0xE9, jmp_offset);
 -			}
 -
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				/* div r11 */
 -				EMIT3(0x49, 0xF7, 0xF3);
 -			else
 -				/* div r11d */
 -				EMIT3(0x41, 0xF7, 0xF3);
 -
 -			if (BPF_OP(insn->code) == BPF_MOD)
 -				/* mov r11, rdx */
 -				EMIT3(0x49, 0x89, 0xD3);
 -			else
 -				/* mov r11, rax */
 -				EMIT3(0x49, 0x89, 0xC3);
 -
 -			EMIT1(0x5A); /* pop rdx */
 -			EMIT1(0x58); /* pop rax */
 -
 -			/* mov dst_reg, r11 */
 -			EMIT_mov(dst_reg, AUX_REG);
 -			break;
 -
 -		case BPF_ALU | BPF_MUL | BPF_K:
 -		case BPF_ALU | BPF_MUL | BPF_X:
 -		case BPF_ALU64 | BPF_MUL | BPF_K:
 -		case BPF_ALU64 | BPF_MUL | BPF_X:
 -			EMIT1(0x50); /* push rax */
 -			EMIT1(0x52); /* push rdx */
 -
 -			/* mov r11, dst_reg */
 -			EMIT_mov(AUX_REG, dst_reg);
 -
 -			if (BPF_SRC(insn->code) == BPF_X)
 -				/* mov rax, src_reg */
 -				EMIT_mov(BPF_REG_0, src_reg);
 -			else
 -				/* mov rax, imm32 */
 -				EMIT3_off32(0x48, 0xC7, 0xC0, imm32);
 -
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_1mod(0x48, AUX_REG));
 -			else if (is_ereg(AUX_REG))
 -				EMIT1(add_1mod(0x40, AUX_REG));
 -			/* mul(q) r11 */
 -			EMIT2(0xF7, add_1reg(0xE0, AUX_REG));
 -
 -			/* mov r11, rax */
 -			EMIT_mov(AUX_REG, BPF_REG_0);
 -
 -			EMIT1(0x5A); /* pop rdx */
 -			EMIT1(0x58); /* pop rax */
 -
 -			/* mov dst_reg, r11 */
 -			EMIT_mov(dst_reg, AUX_REG);
 -			break;
 -
 -			/* shifts */
 -		case BPF_ALU | BPF_LSH | BPF_K:
 -		case BPF_ALU | BPF_RSH | BPF_K:
 -		case BPF_ALU | BPF_ARSH | BPF_K:
 -		case BPF_ALU64 | BPF_LSH | BPF_K:
 -		case BPF_ALU64 | BPF_RSH | BPF_K:
 -		case BPF_ALU64 | BPF_ARSH | BPF_K:
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_1mod(0x48, dst_reg));
 -			else if (is_ereg(dst_reg))
 -				EMIT1(add_1mod(0x40, dst_reg));
 -
 -			switch (BPF_OP(insn->code)) {
 -			case BPF_LSH: b3 = 0xE0; break;
 -			case BPF_RSH: b3 = 0xE8; break;
 -			case BPF_ARSH: b3 = 0xF8; break;
 -			}
 -			EMIT3(0xC1, add_1reg(b3, dst_reg), imm32);
 -			break;
 -
 -		case BPF_ALU | BPF_LSH | BPF_X:
 -		case BPF_ALU | BPF_RSH | BPF_X:
 -		case BPF_ALU | BPF_ARSH | BPF_X:
 -		case BPF_ALU64 | BPF_LSH | BPF_X:
 -		case BPF_ALU64 | BPF_RSH | BPF_X:
 -		case BPF_ALU64 | BPF_ARSH | BPF_X:
 -
 -			/* check for bad case when dst_reg == rcx */
 -			if (dst_reg == BPF_REG_4) {
 -				/* mov r11, dst_reg */
 -				EMIT_mov(AUX_REG, dst_reg);
 -				dst_reg = AUX_REG;
 -			}
 -
 -			if (src_reg != BPF_REG_4) { /* common case */
 -				EMIT1(0x51); /* push rcx */
 -
 -				/* mov rcx, src_reg */
 -				EMIT_mov(BPF_REG_4, src_reg);
 -			}
 -
 -			/* shl %rax, %cl | shr %rax, %cl | sar %rax, %cl */
 -			if (BPF_CLASS(insn->code) == BPF_ALU64)
 -				EMIT1(add_1mod(0x48, dst_reg));
 -			else if (is_ereg(dst_reg))
 -				EMIT1(add_1mod(0x40, dst_reg));
 -
 -			switch (BPF_OP(insn->code)) {
 -			case BPF_LSH: b3 = 0xE0; break;
 -			case BPF_RSH: b3 = 0xE8; break;
 -			case BPF_ARSH: b3 = 0xF8; break;
 -			}
 -			EMIT2(0xD3, add_1reg(b3, dst_reg));
 -
 -			if (src_reg != BPF_REG_4)
 -				EMIT1(0x59); /* pop rcx */
 -
 -			if (insn->dst_reg == BPF_REG_4)
 -				/* mov dst_reg, r11 */
 -				EMIT_mov(insn->dst_reg, AUX_REG);
 -			break;
 -
 -		case BPF_ALU | BPF_END | BPF_FROM_BE:
 -			switch (imm32) {
 -			case 16:
 -				/* emit 'ror %ax, 8' to swap lower 2 bytes */
 -				EMIT1(0x66);
 -				if (is_ereg(dst_reg))
 -					EMIT1(0x41);
 -				EMIT3(0xC1, add_1reg(0xC8, dst_reg), 8);
 -
 -				/* emit 'movzwl eax, ax' */
 -				if (is_ereg(dst_reg))
 -					EMIT3(0x45, 0x0F, 0xB7);
 +			case BPF_S_ALU_SUB_K: /* A -= K */
 +				if (!K)
 +					break;
 +				if (is_imm8(K))
 +					EMIT3(0x83, 0xe8, K); /* sub imm8,%eax */
  				else
 -					EMIT2(0x0F, 0xB7);
 -				EMIT1(add_2reg(0xC0, dst_reg, dst_reg));
 +					EMIT1_off32(0x2d, K); /* sub imm32,%eax */
 +				break;
 +			case BPF_S_ALU_MUL_X: /* A *= X; */
 +				seen |= SEEN_XREG;
 +				EMIT3(0x0f, 0xaf, 0xc3);	/* imul %ebx,%eax */
 +				break;
 +			case BPF_S_ALU_MUL_K: /* A *= K */
 +				if (is_imm8(K))
 +					EMIT3(0x6b, 0xc0, K); /* imul imm8,%eax,%eax */
 +				else {
 +					EMIT2(0x69, 0xc0);		/* imul imm32,%eax */
 +					EMIT(K, 4);
 +				}
  				break;
 -			case 32:
 -				/* emit 'bswap eax' to swap lower 4 bytes */
 -				if (is_ereg(dst_reg))
 -					EMIT2(0x41, 0x0F);
 +			case BPF_S_ALU_DIV_X: /* A /= X; */
 +				seen |= SEEN_XREG;
 +				EMIT2(0x85, 0xdb);	/* test %ebx,%ebx */
 +				if (pc_ret0 > 0) {
 +					/* addrs[pc_ret0 - 1] is start address of target
 +					 * (addrs[i] - 4) is the address following this jmp
 +					 * ("xor %edx,%edx; div %ebx" being 4 bytes long)
 +					 */
 +					EMIT_COND_JMP(X86_JE, addrs[pc_ret0 - 1] -
 +								(addrs[i] - 4));
 +				} else {
 +					EMIT_COND_JMP(X86_JNE, 2 + 5);
 +					CLEAR_A();
 +					EMIT1_off32(0xe9, cleanup_addr - (addrs[i] - 4)); /* jmp .+off32 */
 +				}
 +				EMIT4(0x31, 0xd2, 0xf7, 0xf3); /* xor %edx,%edx; div %ebx */
 +				break;
 +			case BPF_S_ALU_MOD_X: /* A %= X; */
 +				seen |= SEEN_XREG;
 +				EMIT2(0x85, 0xdb);	/* test %ebx,%ebx */
 +				if (pc_ret0 > 0) {
 +					/* addrs[pc_ret0 - 1] is start address of target
 +					 * (addrs[i] - 6) is the address following this jmp
 +					 * ("xor %edx,%edx; div %ebx;mov %edx,%eax" being 6 bytes long)
 +					 */
 +					EMIT_COND_JMP(X86_JE, addrs[pc_ret0 - 1] -
 +								(addrs[i] - 6));
 +				} else {
 +					EMIT_COND_JMP(X86_JNE, 2 + 5);
 +					CLEAR_A();
 +					EMIT1_off32(0xe9, cleanup_addr - (addrs[i] - 6)); /* jmp .+off32 */
 +				}
 +				EMIT2(0x31, 0xd2);	/* xor %edx,%edx */
 +				EMIT2(0xf7, 0xf3);	/* div %ebx */
 +				EMIT2(0x89, 0xd0);	/* mov %edx,%eax */
 +				break;
 +			case BPF_S_ALU_MOD_K: /* A %= K; */
 +				if (K == 1) {
 +					CLEAR_A();
 +					break;
 +				}
 +				EMIT2(0x31, 0xd2);	/* xor %edx,%edx */
 +				EMIT1(0xb9);EMIT(K, 4);	/* mov imm32,%ecx */
 +				EMIT2(0xf7, 0xf1);	/* div %ecx */
 +				EMIT2(0x89, 0xd0);	/* mov %edx,%eax */
 +				break;
 +			case BPF_S_ALU_DIV_K: /* A /= K */
 +				if (K == 1)
 +					break;
 +				EMIT2(0x31, 0xd2);	/* xor %edx,%edx */
 +				EMIT1(0xb9);EMIT(K, 4);	/* mov imm32,%ecx */
 +				EMIT2(0xf7, 0xf1);	/* div %ecx */
 +				break;
 +			case BPF_S_ALU_AND_X:
 +				seen |= SEEN_XREG;
 +				EMIT2(0x21, 0xd8);		/* and %ebx,%eax */
 +				break;
 +			case BPF_S_ALU_AND_K:
 +				if (K >= 0xFFFFFF00) {
 +					EMIT2(0x24, K & 0xFF); /* and imm8,%al */
 +				} else if (K >= 0xFFFF0000) {
 +					EMIT2(0x66, 0x25);	/* and imm16,%ax */
 +					EMIT(K, 2);
 +				} else {
 +					EMIT1_off32(0x25, K);	/* and imm32,%eax */
 +				}
 +				break;
 +			case BPF_S_ALU_OR_X:
 +				seen |= SEEN_XREG;
 +				EMIT2(0x09, 0xd8);		/* or %ebx,%eax */
 +				break;
 +			case BPF_S_ALU_OR_K:
 +				if (is_imm8(K))
 +					EMIT3(0x83, 0xc8, K); /* or imm8,%eax */
  				else
 -					EMIT1(0x0F);
 -				EMIT1(add_1reg(0xC8, dst_reg));
 +					EMIT1_off32(0x0d, K);	/* or imm32,%eax */
  				break;
 -			case 64:
 -				/* emit 'bswap rax' to swap 8 bytes */
 -				EMIT3(add_1mod(0x48, dst_reg), 0x0F,
 -				      add_1reg(0xC8, dst_reg));
 +			case BPF_S_ANC_ALU_XOR_X: /* A ^= X; */
 +			case BPF_S_ALU_XOR_X:
 +				seen |= SEEN_XREG;
 +				EMIT2(0x31, 0xd8);		/* xor %ebx,%eax */
  				break;
 -			}
 -			break;
 -
 -		case BPF_ALU | BPF_END | BPF_FROM_LE:
 -			switch (imm32) {
 -			case 16:
 -				/* emit 'movzwl eax, ax' to zero extend 16-bit
 -				 * into 64 bit
 -				 */
 -				if (is_ereg(dst_reg))
 -					EMIT3(0x45, 0x0F, 0xB7);
 +			case BPF_S_ALU_XOR_K: /* A ^= K; */
 +				if (K == 0)
 +					break;
 +				if (is_imm8(K))
 +					EMIT3(0x83, 0xf0, K);	/* xor imm8,%eax */
  				else
 -					EMIT2(0x0F, 0xB7);
 -				EMIT1(add_2reg(0xC0, dst_reg, dst_reg));
 +					EMIT1_off32(0x35, K);	/* xor imm32,%eax */
  				break;
 -			case 32:
 -				/* emit 'mov eax, eax' to clear upper 32-bits */
 -				if (is_ereg(dst_reg))
 -					EMIT1(0x45);
 -				EMIT2(0x89, add_2reg(0xC0, dst_reg, dst_reg));
 +			case BPF_S_ALU_LSH_X: /* A <<= X; */
 +				seen |= SEEN_XREG;
 +				EMIT4(0x89, 0xd9, 0xd3, 0xe0);	/* mov %ebx,%ecx; shl %cl,%eax */
  				break;
 -			case 64:
 -				/* nop */
 +			case BPF_S_ALU_LSH_K:
 +				if (K == 0)
 +					break;
 +				else if (K == 1)
 +					EMIT2(0xd1, 0xe0); /* shl %eax */
 +				else
 +					EMIT3(0xc1, 0xe0, K);
  				break;
 -			}
 -			break;
 -
 -			/* ST: *(u8*)(dst_reg + off) = imm */
 -		case BPF_ST | BPF_MEM | BPF_B:
 -			if (is_ereg(dst_reg))
 -				EMIT2(0x41, 0xC6);
 -			else
 -				EMIT1(0xC6);
 -			goto st;
 -		case BPF_ST | BPF_MEM | BPF_H:
 -			if (is_ereg(dst_reg))
 -				EMIT3(0x66, 0x41, 0xC7);
 -			else
 -				EMIT2(0x66, 0xC7);
 -			goto st;
 -		case BPF_ST | BPF_MEM | BPF_W:
 -			if (is_ereg(dst_reg))
 -				EMIT2(0x41, 0xC7);
 -			else
 -				EMIT1(0xC7);
 -			goto st;
 -		case BPF_ST | BPF_MEM | BPF_DW:
 -			EMIT2(add_1mod(0x48, dst_reg), 0xC7);
 -
 -st:			if (is_imm8(insn->off))
 -				EMIT2(add_1reg(0x40, dst_reg), insn->off);
 -			else
 -				EMIT1_off32(add_1reg(0x80, dst_reg), insn->off);
 -
 -			EMIT(imm32, bpf_size_to_x86_bytes(BPF_SIZE(insn->code)));
 -			break;
 -
 -			/* STX: *(u8*)(dst_reg + off) = src_reg */
 -		case BPF_STX | BPF_MEM | BPF_B:
 -			/* emit 'mov byte ptr [rax + off], al' */
 -			if (is_ereg(dst_reg) || is_ereg(src_reg) ||
 -			    /* have to add extra byte for x86 SIL, DIL regs */
 -			    src_reg == BPF_REG_1 || src_reg == BPF_REG_2)
 -				EMIT2(add_2mod(0x40, dst_reg, src_reg), 0x88);
 -			else
 -				EMIT1(0x88);
 -			goto stx;
 -		case BPF_STX | BPF_MEM | BPF_H:
 -			if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT3(0x66, add_2mod(0x40, dst_reg, src_reg), 0x89);
 -			else
 -				EMIT2(0x66, 0x89);
 -			goto stx;
 -		case BPF_STX | BPF_MEM | BPF_W:
 -			if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT2(add_2mod(0x40, dst_reg, src_reg), 0x89);
 -			else
 -				EMIT1(0x89);
 -			goto stx;
 -		case BPF_STX | BPF_MEM | BPF_DW:
 -			EMIT2(add_2mod(0x48, dst_reg, src_reg), 0x89);
 -stx:			if (is_imm8(insn->off))
 -				EMIT2(add_2reg(0x40, dst_reg, src_reg), insn->off);
 -			else
 -				EMIT1_off32(add_2reg(0x80, dst_reg, src_reg),
 -					    insn->off);
 -			break;
 -
 -			/* LDX: dst_reg = *(u8*)(src_reg + off) */
 -		case BPF_LDX | BPF_MEM | BPF_B:
 -			/* emit 'movzx rax, byte ptr [rax + off]' */
 -			EMIT3(add_2mod(0x48, src_reg, dst_reg), 0x0F, 0xB6);
 -			goto ldx;
 -		case BPF_LDX | BPF_MEM | BPF_H:
 -			/* emit 'movzx rax, word ptr [rax + off]' */
 -			EMIT3(add_2mod(0x48, src_reg, dst_reg), 0x0F, 0xB7);
 -			goto ldx;
 -		case BPF_LDX | BPF_MEM | BPF_W:
 -			/* emit 'mov eax, dword ptr [rax+0x14]' */
 -			if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT2(add_2mod(0x40, src_reg, dst_reg), 0x8B);
 -			else
 -				EMIT1(0x8B);
 -			goto ldx;
 -		case BPF_LDX | BPF_MEM | BPF_DW:
 -			/* emit 'mov rax, qword ptr [rax+0x14]' */
 -			EMIT2(add_2mod(0x48, src_reg, dst_reg), 0x8B);
 -ldx:			/* if insn->off == 0 we can save one extra byte, but
 -			 * special case of x86 r13 which always needs an offset
 -			 * is not worth the hassle
 -			 */
 -			if (is_imm8(insn->off))
 -				EMIT2(add_2reg(0x40, src_reg, dst_reg), insn->off);
 -			else
 -				EMIT1_off32(add_2reg(0x80, src_reg, dst_reg),
 -					    insn->off);
 -			break;
 -
 -			/* STX XADD: lock *(u32*)(dst_reg + off) += src_reg */
 -		case BPF_STX | BPF_XADD | BPF_W:
 -			/* emit 'lock add dword ptr [rax + off], eax' */
 -			if (is_ereg(dst_reg) || is_ereg(src_reg))
 -				EMIT3(0xF0, add_2mod(0x40, dst_reg, src_reg), 0x01);
 -			else
 -				EMIT2(0xF0, 0x01);
 -			goto xadd;
 -		case BPF_STX | BPF_XADD | BPF_DW:
 -			EMIT3(0xF0, add_2mod(0x48, dst_reg, src_reg), 0x01);
 -xadd:			if (is_imm8(insn->off))
 -				EMIT2(add_2reg(0x40, dst_reg, src_reg), insn->off);
 -			else
 -				EMIT1_off32(add_2reg(0x80, dst_reg, src_reg),
 -					    insn->off);
 -			break;
 -
 -			/* call */
 -		case BPF_JMP | BPF_CALL:
 -			func = (u8 *) __bpf_call_base + imm32;
 -			jmp_offset = func - (image + addrs[i]);
 -			if (seen_ld_abs) {
 -				reload_skb_data = bpf_helper_changes_skb_data(func);
 -				if (reload_skb_data) {
 -					EMIT1(0x57); /* push %rdi */
 -					jmp_offset += 22; /* pop, mov, sub, mov */
 +			case BPF_S_ALU_RSH_X: /* A >>= X; */
 +				seen |= SEEN_XREG;
 +				EMIT4(0x89, 0xd9, 0xd3, 0xe8);	/* mov %ebx,%ecx; shr %cl,%eax */
 +				break;
 +			case BPF_S_ALU_RSH_K: /* A >>= K; */
 +				if (K == 0)
 +					break;
 +				else if (K == 1)
 +					EMIT2(0xd1, 0xe8); /* shr %eax */
 +				else
 +					EMIT3(0xc1, 0xe8, K);
 +				break;
 +			case BPF_S_ALU_NEG:
 +				EMIT2(0xf7, 0xd8);		/* neg %eax */
 +				break;
 +			case BPF_S_RET_K:
 +				if (!K) {
 +					if (pc_ret0 == -1)
 +						pc_ret0 = i;
 +					CLEAR_A();
  				} else {
 -					EMIT2(0x41, 0x52); /* push %r10 */
 -					EMIT2(0x41, 0x51); /* push %r9 */
 -					/* need to adjust jmp offset, since
 -					 * pop %r9, pop %r10 take 4 bytes after call insn
 -					 */
 -					jmp_offset += 4;
 +					EMIT1_off32(0xb8, K);	/* mov $imm32,%eax */
  				}
 -			}
 -			if (!imm32 || !is_simm32(jmp_offset)) {
 -				pr_err("unsupported bpf func %d addr %p image %p\n",
 -				       imm32, func, image);
 -				return -EINVAL;
 -			}
 -			EMIT1_off32(0xE8, jmp_offset);
 -			if (seen_ld_abs) {
 -				if (reload_skb_data) {
 -					EMIT1(0x5F); /* pop %rdi */
 -					emit_load_skb_data_hlen(&prog);
 +				/* fallinto */
 +			case BPF_S_RET_A:
 +				if (seen_or_pass0) {
 +					if (i != flen - 1) {
 +						EMIT_JMP(cleanup_addr - addrs[i]);
 +						break;
 +					}
 +					if (seen_or_pass0 & SEEN_XREG)
 +						EMIT4(0x48, 0x8b, 0x5d, 0xf8);  /* mov  -8(%rbp),%rbx */
 +					EMIT1(0xc9);		/* leaveq */
 +				}
 +				EMIT1(0xc3);		/* ret */
 +				break;
 +			case BPF_S_MISC_TAX: /* X = A */
 +				seen |= SEEN_XREG;
 +				EMIT2(0x89, 0xc3);	/* mov    %eax,%ebx */
 +				break;
 +			case BPF_S_MISC_TXA: /* A = X */
 +				seen |= SEEN_XREG;
 +				EMIT2(0x89, 0xd8);	/* mov    %ebx,%eax */
 +				break;
 +			case BPF_S_LD_IMM: /* A = K */
 +				if (!K)
 +					CLEAR_A();
 +				else
 +					EMIT1_off32(0xb8, K); /* mov $imm32,%eax */
 +				break;
 +			case BPF_S_LDX_IMM: /* X = K */
 +				seen |= SEEN_XREG;
 +				if (!K)
 +					CLEAR_X();
 +				else
 +					EMIT1_off32(0xbb, K); /* mov $imm32,%ebx */
 +				break;
 +			case BPF_S_LD_MEM: /* A = mem[K] : mov off8(%rbp),%eax */
 +				seen |= SEEN_MEM;
 +				EMIT3(0x8b, 0x45, 0xf0 - K*4);
 +				break;
 +			case BPF_S_LDX_MEM: /* X = mem[K] : mov off8(%rbp),%ebx */
 +				seen |= SEEN_XREG | SEEN_MEM;
 +				EMIT3(0x8b, 0x5d, 0xf0 - K*4);
 +				break;
 +			case BPF_S_ST: /* mem[K] = A : mov %eax,off8(%rbp) */
 +				seen |= SEEN_MEM;
 +				EMIT3(0x89, 0x45, 0xf0 - K*4);
 +				break;
 +			case BPF_S_STX: /* mem[K] = X : mov %ebx,off8(%rbp) */
 +				seen |= SEEN_XREG | SEEN_MEM;
 +				EMIT3(0x89, 0x5d, 0xf0 - K*4);
 +				break;
 +			case BPF_S_LD_W_LEN: /*	A = skb->len; */
 +				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, len) != 4);
 +				if (is_imm8(offsetof(struct sk_buff, len)))
 +					/* mov    off8(%rdi),%eax */
 +					EMIT3(0x8b, 0x47, offsetof(struct sk_buff, len));
 +				else {
 +					EMIT2(0x8b, 0x87);
 +					EMIT(offsetof(struct sk_buff, len), 4);
 +				}
 +				break;
 +			case BPF_S_LDX_W_LEN: /* X = skb->len; */
 +				seen |= SEEN_XREG;
 +				if (is_imm8(offsetof(struct sk_buff, len)))
 +					/* mov off8(%rdi),%ebx */
 +					EMIT3(0x8b, 0x5f, offsetof(struct sk_buff, len));
 +				else {
 +					EMIT2(0x8b, 0x9f);
 +					EMIT(offsetof(struct sk_buff, len), 4);
 +				}
 +				break;
 +			case BPF_S_ANC_PROTOCOL: /* A = ntohs(skb->protocol); */
 +				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);
 +				if (is_imm8(offsetof(struct sk_buff, protocol))) {
 +					/* movzwl off8(%rdi),%eax */
 +					EMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, protocol));
  				} else {
 -					EMIT2(0x41, 0x59); /* pop %r9 */
 -					EMIT2(0x41, 0x5A); /* pop %r10 */
 +					EMIT3(0x0f, 0xb7, 0x87); /* movzwl off32(%rdi),%eax */
 +					EMIT(offsetof(struct sk_buff, protocol), 4);
  				}
 -			}
 -			break;
 -
 -		case BPF_JMP | BPF_CALL | BPF_X:
 -			emit_bpf_tail_call(&prog);
 -			break;
 -
 -			/* cond jump */
 -		case BPF_JMP | BPF_JEQ | BPF_X:
 -		case BPF_JMP | BPF_JNE | BPF_X:
 -		case BPF_JMP | BPF_JGT | BPF_X:
 -		case BPF_JMP | BPF_JGE | BPF_X:
 -		case BPF_JMP | BPF_JSGT | BPF_X:
 -		case BPF_JMP | BPF_JSGE | BPF_X:
 -			/* cmp dst_reg, src_reg */
 -			EMIT3(add_2mod(0x48, dst_reg, src_reg), 0x39,
 -			      add_2reg(0xC0, dst_reg, src_reg));
 -			goto emit_cond_jmp;
 -
 -		case BPF_JMP | BPF_JSET | BPF_X:
 -			/* test dst_reg, src_reg */
 -			EMIT3(add_2mod(0x48, dst_reg, src_reg), 0x85,
 -			      add_2reg(0xC0, dst_reg, src_reg));
 -			goto emit_cond_jmp;
 -
 -		case BPF_JMP | BPF_JSET | BPF_K:
 -			/* test dst_reg, imm32 */
 -			EMIT1(add_1mod(0x48, dst_reg));
 -			EMIT2_off32(0xF7, add_1reg(0xC0, dst_reg), imm32);
 -			goto emit_cond_jmp;
 -
 -		case BPF_JMP | BPF_JEQ | BPF_K:
 -		case BPF_JMP | BPF_JNE | BPF_K:
 -		case BPF_JMP | BPF_JGT | BPF_K:
 -		case BPF_JMP | BPF_JGE | BPF_K:
 -		case BPF_JMP | BPF_JSGT | BPF_K:
 -		case BPF_JMP | BPF_JSGE | BPF_K:
 -			/* cmp dst_reg, imm8/32 */
 -			EMIT1(add_1mod(0x48, dst_reg));
 -
 -			if (is_imm8(imm32))
 -				EMIT3(0x83, add_1reg(0xF8, dst_reg), imm32);
 -			else
 -				EMIT2_off32(0x81, add_1reg(0xF8, dst_reg), imm32);
 -
 -emit_cond_jmp:		/* convert BPF opcode to x86 */
 -			switch (BPF_OP(insn->code)) {
 -			case BPF_JEQ:
 -				jmp_cond = X86_JE;
 +				EMIT2(0x86, 0xc4); /* ntohs() : xchg   %al,%ah */
  				break;
 -			case BPF_JSET:
 -			case BPF_JNE:
 -				jmp_cond = X86_JNE;
 +			case BPF_S_ANC_IFINDEX:
 +				if (is_imm8(offsetof(struct sk_buff, dev))) {
 +					/* movq off8(%rdi),%rax */
 +					EMIT4(0x48, 0x8b, 0x47, offsetof(struct sk_buff, dev));
 +				} else {
 +					EMIT3(0x48, 0x8b, 0x87); /* movq off32(%rdi),%rax */
 +					EMIT(offsetof(struct sk_buff, dev), 4);
 +				}
 +				EMIT3(0x48, 0x85, 0xc0);	/* test %rax,%rax */
 +				EMIT_COND_JMP(X86_JE, cleanup_addr - (addrs[i] - 6));
 +				BUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);
 +				EMIT2(0x8b, 0x80);	/* mov off32(%rax),%eax */
 +				EMIT(offsetof(struct net_device, ifindex), 4);
  				break;
 -			case BPF_JGT:
 -				/* GT is unsigned '>', JA in x86 */
 -				jmp_cond = X86_JA;
 +			case BPF_S_ANC_MARK:
 +				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);
 +				if (is_imm8(offsetof(struct sk_buff, mark))) {
 +					/* mov off8(%rdi),%eax */
 +					EMIT3(0x8b, 0x47, offsetof(struct sk_buff, mark));
 +				} else {
 +					EMIT2(0x8b, 0x87);
 +					EMIT(offsetof(struct sk_buff, mark), 4);
 +				}
  				break;
 -			case BPF_JGE:
 -				/* GE is unsigned '>=', JAE in x86 */
 -				jmp_cond = X86_JAE;
 +			case BPF_S_ANC_RXHASH:
 +				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, hash) != 4);
 +				if (is_imm8(offsetof(struct sk_buff, hash))) {
 +					/* mov off8(%rdi),%eax */
 +					EMIT3(0x8b, 0x47, offsetof(struct sk_buff, hash));
 +				} else {
 +					EMIT2(0x8b, 0x87);
 +					EMIT(offsetof(struct sk_buff, hash), 4);
 +				}
  				break;
 -			case BPF_JSGT:
 -				/* signed '>', GT in x86 */
 -				jmp_cond = X86_JG;
 +			case BPF_S_ANC_QUEUE:
 +				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);
 +				if (is_imm8(offsetof(struct sk_buff, queue_mapping))) {
 +					/* movzwl off8(%rdi),%eax */
 +					EMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, queue_mapping));
 +				} else {
 +					EMIT3(0x0f, 0xb7, 0x87); /* movzwl off32(%rdi),%eax */
 +					EMIT(offsetof(struct sk_buff, queue_mapping), 4);
 +				}
  				break;
 -			case BPF_JSGE:
 -				/* signed '>=', GE in x86 */
 -				jmp_cond = X86_JGE;
 +			case BPF_S_ANC_CPU:
 +#ifdef CONFIG_SMP
 +				EMIT4(0x65, 0x8b, 0x04, 0x25); /* mov %gs:off32,%eax */
 +				EMIT((u32)(unsigned long)&cpu_number, 4); /* A = smp_processor_id(); */
 +#else
 +				CLEAR_A();
 +#endif
  				break;
 -			default: /* to silence gcc warning */
 -				return -EFAULT;
 -			}
 -			jmp_offset = addrs[i + insn->off] - addrs[i];
 -			if (is_imm8(jmp_offset)) {
 -				EMIT2(jmp_cond, jmp_offset);
 -			} else if (is_simm32(jmp_offset)) {
 -				EMIT2_off32(0x0F, jmp_cond + 0x10, jmp_offset);
 -			} else {
 -				pr_err("cond_jmp gen bug %llx\n", jmp_offset);
 -				return -EFAULT;
 -			}
 -
 -			break;
 -
 -		case BPF_JMP | BPF_JA:
 -			jmp_offset = addrs[i + insn->off] - addrs[i];
 -			if (!jmp_offset)
 -				/* optimize out nop jumps */
 +			case BPF_S_ANC_VLAN_TAG:
 +			case BPF_S_ANC_VLAN_TAG_PRESENT:
 +				BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, vlan_tci) != 2);
 +				if (is_imm8(offsetof(struct sk_buff, vlan_tci))) {
 +					/* movzwl off8(%rdi),%eax */
 +					EMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, vlan_tci));
 +				} else {
 +					EMIT3(0x0f, 0xb7, 0x87); /* movzwl off32(%rdi),%eax */
 +					EMIT(offsetof(struct sk_buff, vlan_tci), 4);
 +				}
 +				BUILD_BUG_ON(VLAN_TAG_PRESENT != 0x1000);
 +				if (filter[i].code == BPF_S_ANC_VLAN_TAG) {
 +					EMIT3(0x80, 0xe4, 0xef); /* and    $0xef,%ah */
 +				} else {
 +					EMIT3(0xc1, 0xe8, 0x0c); /* shr    $0xc,%eax */
 +					EMIT3(0x83, 0xe0, 0x01); /* and    $0x1,%eax */
 +				}
 +				break;
 +			case BPF_S_ANC_PKTTYPE:
 +			{
 +				int off = pkt_type_offset();
 +
 +				if (off < 0)
 +					goto out;
 +				if (is_imm8(off)) {
 +					/* movzbl off8(%rdi),%eax */
 +					EMIT4(0x0f, 0xb6, 0x47, off);
 +				} else {
 +					/* movbl off32(%rdi),%eax */
 +					EMIT3(0x0f, 0xb6, 0x87);
 +					EMIT(off, 4);
 +				}
 +				EMIT3(0x83, 0xe0, PKT_TYPE_MAX); /* and    $0x7,%eax */
  				break;
 -emit_jmp:
 -			if (is_imm8(jmp_offset)) {
 -				EMIT2(0xEB, jmp_offset);
 -			} else if (is_simm32(jmp_offset)) {
 -				EMIT1_off32(0xE9, jmp_offset);
 -			} else {
 -				pr_err("jmp gen bug %llx\n", jmp_offset);
 -				return -EFAULT;
  			}
 -			break;
 +			case BPF_S_LD_W_ABS:
 +				func = CHOOSE_LOAD_FUNC(K, sk_load_word);
 +common_load:			seen |= SEEN_DATAREF;
 +				t_offset = func - (image + addrs[i]);
 +				EMIT1_off32(0xbe, K); /* mov imm32,%esi */
 +				EMIT1_off32(0xe8, t_offset); /* call */
 +				break;
 +			case BPF_S_LD_H_ABS:
 +				func = CHOOSE_LOAD_FUNC(K, sk_load_half);
 +				goto common_load;
 +			case BPF_S_LD_B_ABS:
 +				func = CHOOSE_LOAD_FUNC(K, sk_load_byte);
 +				goto common_load;
 +			case BPF_S_LDX_B_MSH:
 +				func = CHOOSE_LOAD_FUNC(K, sk_load_byte_msh);
 +				seen |= SEEN_DATAREF | SEEN_XREG;
 +				t_offset = func - (image + addrs[i]);
 +				EMIT1_off32(0xbe, K);	/* mov imm32,%esi */
 +				EMIT1_off32(0xe8, t_offset); /* call sk_load_byte_msh */
 +				break;
 +			case BPF_S_LD_W_IND:
 +				func = sk_load_word;
 +common_load_ind:		seen |= SEEN_DATAREF | SEEN_XREG;
 +				t_offset = func - (image + addrs[i]);
 +				if (K) {
 +					if (is_imm8(K)) {
 +						EMIT3(0x8d, 0x73, K); /* lea imm8(%rbx), %esi */
 +					} else {
 +						EMIT2(0x8d, 0xb3); /* lea imm32(%rbx),%esi */
 +						EMIT(K, 4);
 +					}
 +				} else {
 +					EMIT2(0x89,0xde); /* mov %ebx,%esi */
 +				}
 +				EMIT1_off32(0xe8, t_offset);	/* call sk_load_xxx_ind */
 +				break;
 +			case BPF_S_LD_H_IND:
 +				func = sk_load_half;
 +				goto common_load_ind;
 +			case BPF_S_LD_B_IND:
 +				func = sk_load_byte;
 +				goto common_load_ind;
 +			case BPF_S_JMP_JA:
 +				t_offset = addrs[i + K] - addrs[i];
 +				EMIT_JMP(t_offset);
 +				break;
 +			COND_SEL(BPF_S_JMP_JGT_K, X86_JA, X86_JBE);
 +			COND_SEL(BPF_S_JMP_JGE_K, X86_JAE, X86_JB);
 +			COND_SEL(BPF_S_JMP_JEQ_K, X86_JE, X86_JNE);
 +			COND_SEL(BPF_S_JMP_JSET_K,X86_JNE, X86_JE);
 +			COND_SEL(BPF_S_JMP_JGT_X, X86_JA, X86_JBE);
 +			COND_SEL(BPF_S_JMP_JGE_X, X86_JAE, X86_JB);
 +			COND_SEL(BPF_S_JMP_JEQ_X, X86_JE, X86_JNE);
 +			COND_SEL(BPF_S_JMP_JSET_X,X86_JNE, X86_JE);
 +
 +cond_branch:			f_offset = addrs[i + filter[i].jf] - addrs[i];
 +				t_offset = addrs[i + filter[i].jt] - addrs[i];
 +
 +				/* same targets, can avoid doing the test :) */
 +				if (filter[i].jt == filter[i].jf) {
 +					EMIT_JMP(t_offset);
 +					break;
 +				}
  
 -		case BPF_LD | BPF_IND | BPF_W:
 -			func = sk_load_word;
 -			goto common_load;
 -		case BPF_LD | BPF_ABS | BPF_W:
 -			func = CHOOSE_LOAD_FUNC(imm32, sk_load_word);
 -common_load:
 -			ctx->seen_ld_abs = seen_ld_abs = true;
 -			jmp_offset = func - (image + addrs[i]);
 -			if (!func || !is_simm32(jmp_offset)) {
 -				pr_err("unsupported bpf func %d addr %p image %p\n",
 -				       imm32, func, image);
 -				return -EINVAL;
 -			}
 -			if (BPF_MODE(insn->code) == BPF_ABS) {
 -				/* mov %esi, imm32 */
 -				EMIT1_off32(0xBE, imm32);
 -			} else {
 -				/* mov %rsi, src_reg */
 -				EMIT_mov(BPF_REG_2, src_reg);
 -				if (imm32) {
 -					if (is_imm8(imm32))
 -						/* add %esi, imm8 */
 -						EMIT3(0x83, 0xC6, imm32);
 +				switch (filter[i].code) {
 +				case BPF_S_JMP_JGT_X:
 +				case BPF_S_JMP_JGE_X:
 +				case BPF_S_JMP_JEQ_X:
 +					seen |= SEEN_XREG;
 +					EMIT2(0x39, 0xd8); /* cmp %ebx,%eax */
 +					break;
 +				case BPF_S_JMP_JSET_X:
 +					seen |= SEEN_XREG;
 +					EMIT2(0x85, 0xd8); /* test %ebx,%eax */
 +					break;
 +				case BPF_S_JMP_JEQ_K:
 +					if (K == 0) {
 +						EMIT2(0x85, 0xc0); /* test   %eax,%eax */
 +						break;
 +					}
 +				case BPF_S_JMP_JGT_K:
 +				case BPF_S_JMP_JGE_K:
 +					if (K <= 127)
 +						EMIT3(0x83, 0xf8, K); /* cmp imm8,%eax */
  					else
 -						/* add %esi, imm32 */
 -						EMIT2_off32(0x81, 0xC6, imm32);
 +						EMIT1_off32(0x3d, K); /* cmp imm32,%eax */
 +					break;
 +				case BPF_S_JMP_JSET_K:
 +					if (K <= 0xFF)
 +						EMIT2(0xa8, K); /* test imm8,%al */
 +					else if (!(K & 0xFFFF00FF))
 +						EMIT3(0xf6, 0xc4, K >> 8); /* test imm8,%ah */
 +					else if (K <= 0xFFFF) {
 +						EMIT2(0x66, 0xa9); /* test imm16,%ax */
 +						EMIT(K, 2);
 +					} else {
 +						EMIT1_off32(0xa9, K); /* test imm32,%eax */
 +					}
 +					break;
  				}
 +				if (filter[i].jt != 0) {
 +					if (filter[i].jf && f_offset)
 +						t_offset += is_near(f_offset) ? 2 : 5;
 +					EMIT_COND_JMP(t_op, t_offset);
 +					if (filter[i].jf)
 +						EMIT_JMP(f_offset);
 +					break;
 +				}
 +				EMIT_COND_JMP(f_op, f_offset);
 +				break;
 +			default:
 +				/* hmm, too complex filter, give up with jit compiler */
 +				goto out;
  			}
 -			/* skb pointer is in R6 (%rbx), it will be copied into
 -			 * %rdi if skb_copy_bits() call is necessary.
 -			 * sk_load_* helpers also use %r10 and %r9d.
 -			 * See bpf_jit.S
 -			 */
 -			EMIT1_off32(0xE8, jmp_offset); /* call */
 -			break;
 -
 -		case BPF_LD | BPF_IND | BPF_H:
 -			func = sk_load_half;
 -			goto common_load;
 -		case BPF_LD | BPF_ABS | BPF_H:
 -			func = CHOOSE_LOAD_FUNC(imm32, sk_load_half);
 -			goto common_load;
 -		case BPF_LD | BPF_IND | BPF_B:
 -			func = sk_load_byte;
 -			goto common_load;
 -		case BPF_LD | BPF_ABS | BPF_B:
 -			func = CHOOSE_LOAD_FUNC(imm32, sk_load_byte);
 -			goto common_load;
 -
 -		case BPF_JMP | BPF_EXIT:
 -			if (seen_exit) {
 -				jmp_offset = ctx->cleanup_addr - addrs[i];
 -				goto emit_jmp;
 -			}
 -			seen_exit = true;
 -			/* update cleanup_addr */
 -			ctx->cleanup_addr = proglen;
 -			/* mov rbx, qword ptr [rbp-X] */
 -			EMIT3_off32(0x48, 0x8B, 0x9D, -STACKSIZE);
 -			/* mov r13, qword ptr [rbp-X] */
 -			EMIT3_off32(0x4C, 0x8B, 0xAD, -STACKSIZE + 8);
 -			/* mov r14, qword ptr [rbp-X] */
 -			EMIT3_off32(0x4C, 0x8B, 0xB5, -STACKSIZE + 16);
 -			/* mov r15, qword ptr [rbp-X] */
 -			EMIT3_off32(0x4C, 0x8B, 0xBD, -STACKSIZE + 24);
 -
 -			EMIT1(0xC9); /* leave */
 -			EMIT1(0xC3); /* ret */
 -			break;
 -
 -		default:
 -			/* By design x64 JIT should support all BPF instructions
 -			 * This error will be seen if new instruction was added
 -			 * to interpreter, but not to JIT
 -			 * or if there is junk in bpf_prog
 -			 */
 -			pr_err("bpf_jit: unknown opcode %02x\n", insn->code);
 -			return -EINVAL;
 -		}
 -
 -		ilen = prog - temp;
 -		if (ilen > BPF_MAX_INSN_SIZE) {
 -			pr_err("bpf_jit_compile fatal insn size error\n");
 -			return -EFAULT;
 -		}
 -
 -		if (image) {
 -			if (unlikely(proglen + ilen > oldproglen)) {
 -				pr_err("bpf_jit_compile fatal error\n");
 -				return -EFAULT;
 +			ilen = prog - temp;
 +			if (image) {
 +				if (unlikely(proglen + ilen > oldproglen)) {
 +					pr_err("bpb_jit_compile fatal error\n");
 +					kfree(addrs);
 +					module_free(NULL, image);
 +					return;
 +				}
 +				memcpy(image + proglen, temp, ilen);
  			}
 -			memcpy(image + proglen, temp, ilen);
 +			proglen += ilen;
 +			addrs[i] = proglen;
 +			prog = temp;
  		}
 -		proglen += ilen;
 -		addrs[i] = proglen;
 -		prog = temp;
 -	}
 -	return proglen;
 -}
 -
 -void bpf_jit_compile(struct bpf_prog *prog)
 -{
 -}
 -
 -struct bpf_prog *bpf_int_jit_compile(struct bpf_prog *prog)
 -{
 -	struct bpf_binary_header *header = NULL;
 -	int proglen, oldproglen = 0;
 -	struct jit_context ctx = {};
 -	u8 *image = NULL;
 -	int *addrs;
 -	int pass;
 -	int i;
 -
 -	if (!bpf_jit_enable)
 -		return prog;
 -
 -	addrs = kmalloc(prog->len * sizeof(*addrs), GFP_KERNEL);
 -	if (!addrs)
 -		return prog;
 -
 -	/* Before first pass, make a rough estimation of addrs[]
 -	 * each bpf instruction is translated to less than 64 bytes
 -	 */
 -	for (proglen = 0, i = 0; i < prog->len; i++) {
 -		proglen += 64;
 -		addrs[i] = proglen;
 -	}
 -	ctx.cleanup_addr = proglen;
 +		/* last bpf instruction is always a RET :
 +		 * use it to give the cleanup instruction(s) addr
 +		 */
 +		cleanup_addr = proglen - 1; /* ret */
 +		if (seen_or_pass0)
 +			cleanup_addr -= 1; /* leaveq */
 +		if (seen_or_pass0 & SEEN_XREG)
 +			cleanup_addr -= 4; /* mov  -8(%rbp),%rbx */
  
 -	/* JITed image shrinks with every pass and the loop iterates
 -	 * until the image stops shrinking. Very large bpf programs
 -	 * may converge on the last pass. In such case do one more
 -	 * pass to emit the final image
 -	 */
 -	for (pass = 0; pass < 10 || image; pass++) {
 -		proglen = do_jit(prog, addrs, image, oldproglen, &ctx);
 -		if (proglen <= 0) {
 -			image = NULL;
 -			if (header)
 -				bpf_jit_binary_free(header);
 -			goto out;
 -		}
  		if (image) {
 -			if (proglen != oldproglen) {
 -				pr_err("bpf_jit: proglen=%d != oldproglen=%d\n",
 -				       proglen, oldproglen);
 -				goto out;
 -			}
 +			if (proglen != oldproglen)
 +				pr_err("bpb_jit_compile proglen=%u != oldproglen=%u\n", proglen, oldproglen);
  			break;
  		}
  		if (proglen == oldproglen) {
@@@ -746,23 -1140,20 +762,27 @@@
  	}
  out:
  	kfree(addrs);
++<<<<<<< HEAD
 +	return;
++=======
+ 	return prog;
++>>>>>>> d1c55ab5e41f (bpf: prepare bpf_int_jit_compile/bpf_prog_select_runtime apis)
  }
  
 -void bpf_jit_free(struct bpf_prog *fp)
 +static void jit_free_defer(struct work_struct *arg)
  {
 -	unsigned long addr = (unsigned long)fp->bpf_func & PAGE_MASK;
 -	struct bpf_binary_header *header = (void *)addr;
 -
 -	if (!fp->jited)
 -		goto free_filter;
 +	module_free(NULL, arg);
 +}
  
 -	set_memory_rw(addr, header->pages);
 -	bpf_jit_binary_free(header);
 +/* run from softirq, we must use a work_struct to call
 + * module_free() from process context
 + */
 +void bpf_jit_free(struct sk_filter *fp)
 +{
 +	if (fp->bpf_func != sk_run_filter) {
 +		struct work_struct *work = (struct work_struct *)fp->bpf_func;
  
 -free_filter:
 -	bpf_prog_unlock_free(fp);
 +		INIT_WORK(work, jit_free_defer);
 +		schedule_work(work);
 +	}
  }
diff --cc include/linux/filter.h
index d322ed880333,891852cf7716..000000000000
--- a/include/linux/filter.h
+++ b/include/linux/filter.h
@@@ -49,51 -360,158 +49,135 @@@ struct xdp_buff 
  /* compute the linear packet data range [data, data_end) which
   * will be accessed by cls_bpf and act_bpf programs
   */
 -static inline void bpf_compute_data_end(struct sk_buff *skb)
 +static inline unsigned int sk_filter_len(const struct sk_filter *fp)
  {
 -	struct bpf_skb_data_end *cb = (struct bpf_skb_data_end *)skb->cb;
 -
 -	BUILD_BUG_ON(sizeof(*cb) > FIELD_SIZEOF(struct sk_buff, cb));
 -	cb->data_end = skb->data + skb_headlen(skb);
 +	return fp->len * sizeof(struct sock_filter) + sizeof(*fp);
  }
  
 -static inline u8 *bpf_skb_cb(struct sk_buff *skb)
 +static inline void bpf_compute_data_end(struct sk_buff *skb)
  {
 -	/* eBPF programs may read/write skb->cb[] area to transfer meta
 -	 * data between tail calls. Since this also needs to work with
 -	 * tc, that scratch memory is mapped to qdisc_skb_cb's data area.
 -	 *
 -	 * In some socket filter cases, the cb unfortunately needs to be
 -	 * saved/restored so that protocol specific skb->cb[] data won't
 -	 * be lost. In any case, due to unpriviledged eBPF programs
 -	 * attached to sockets, we need to clear the bpf_skb_cb() area
 -	 * to not leak previous contents to user space.
 -	 */
 -	BUILD_BUG_ON(FIELD_SIZEOF(struct __sk_buff, cb) != BPF_SKB_CB_LEN);
 -	BUILD_BUG_ON(FIELD_SIZEOF(struct __sk_buff, cb) !=
 -		     FIELD_SIZEOF(struct qdisc_skb_cb, data));
 -
 -	return qdisc_skb_cb(skb)->data;
 +	return;
  }
  
 -static inline u32 bpf_prog_run_save_cb(const struct bpf_prog *prog,
 -				       struct sk_buff *skb)
 +int sk_filter_trim_cap(struct sock *sk, struct sk_buff *skb, unsigned int cap);
 +static inline int sk_filter(struct sock *sk, struct sk_buff *skb)
  {
 -	u8 *cb_data = bpf_skb_cb(skb);
 -	u8 cb_saved[BPF_SKB_CB_LEN];
 -	u32 res;
 -
 -	if (unlikely(prog->cb_access)) {
 -		memcpy(cb_saved, cb_data, sizeof(cb_saved));
 -		memset(cb_data, 0, sizeof(cb_saved));
 -	}
 -
 -	res = BPF_PROG_RUN(prog, skb);
 -
 -	if (unlikely(prog->cb_access))
 -		memcpy(cb_data, cb_saved, sizeof(cb_saved));
 -
 -	return res;
 +	return sk_filter_trim_cap(sk, skb, 1);
  }
  
 -static inline u32 bpf_prog_run_clear_cb(const struct bpf_prog *prog,
 -					struct sk_buff *skb)
 +extern unsigned int sk_run_filter(const struct sk_buff *skb,
 +				  const struct sock_filter *filter);
 +extern int sk_unattached_filter_create(struct sk_filter **pfp,
 +				       struct sock_fprog *fprog);
 +extern void sk_unattached_filter_destroy(struct sk_filter *fp);
 +extern int sk_attach_filter(struct sock_fprog *fprog, struct sock *sk);
 +extern int sk_detach_filter(struct sock *sk);
 +extern int sk_chk_filter(struct sock_filter *filter, unsigned int flen);
 +extern int sk_get_filter(struct sock *sk, struct sock_filter __user *filter, unsigned len);
 +extern void sk_decode_filter(struct sock_filter *filt, struct sock_filter *to);
 +
 +static inline u32 bpf_prog_run_xdp(const struct bpf_prog *prog,
 +				   struct xdp_buff *xdp)
  {
 -	u8 *cb_data = bpf_skb_cb(skb);
 -
 -	if (unlikely(prog->cb_access))
 -		memset(cb_data, 0, BPF_SKB_CB_LEN);
 +	return 0;
 +}
  
 -	return BPF_PROG_RUN(prog, skb);
 +static inline void bpf_warn_invalid_xdp_action(u32 act)
 +{
 +	return;
  }
  
++<<<<<<< HEAD
++=======
+ static inline unsigned int bpf_prog_size(unsigned int proglen)
+ {
+ 	return max(sizeof(struct bpf_prog),
+ 		   offsetof(struct bpf_prog, insns[proglen]));
+ }
+ 
+ static inline bool bpf_prog_was_classic(const struct bpf_prog *prog)
+ {
+ 	/* When classic BPF programs have been loaded and the arch
+ 	 * does not have a classic BPF JIT (anymore), they have been
+ 	 * converted via bpf_migrate_filter() to eBPF and thus always
+ 	 * have an unspec program type.
+ 	 */
+ 	return prog->type == BPF_PROG_TYPE_UNSPEC;
+ }
+ 
+ #define bpf_classic_proglen(fprog) (fprog->len * sizeof(fprog->filter[0]))
+ 
+ #ifdef CONFIG_DEBUG_SET_MODULE_RONX
+ static inline void bpf_prog_lock_ro(struct bpf_prog *fp)
+ {
+ 	set_memory_ro((unsigned long)fp, fp->pages);
+ }
+ 
+ static inline void bpf_prog_unlock_ro(struct bpf_prog *fp)
+ {
+ 	set_memory_rw((unsigned long)fp, fp->pages);
+ }
+ #else
+ static inline void bpf_prog_lock_ro(struct bpf_prog *fp)
+ {
+ }
+ 
+ static inline void bpf_prog_unlock_ro(struct bpf_prog *fp)
+ {
+ }
+ #endif /* CONFIG_DEBUG_SET_MODULE_RONX */
+ 
+ int sk_filter(struct sock *sk, struct sk_buff *skb);
+ 
+ struct bpf_prog *bpf_prog_select_runtime(struct bpf_prog *fp, int *err);
+ void bpf_prog_free(struct bpf_prog *fp);
+ 
+ struct bpf_prog *bpf_prog_alloc(unsigned int size, gfp_t gfp_extra_flags);
+ struct bpf_prog *bpf_prog_realloc(struct bpf_prog *fp_old, unsigned int size,
+ 				  gfp_t gfp_extra_flags);
+ void __bpf_prog_free(struct bpf_prog *fp);
+ 
+ static inline void bpf_prog_unlock_free(struct bpf_prog *fp)
+ {
+ 	bpf_prog_unlock_ro(fp);
+ 	__bpf_prog_free(fp);
+ }
+ 
+ typedef int (*bpf_aux_classic_check_t)(struct sock_filter *filter,
+ 				       unsigned int flen);
+ 
+ int bpf_prog_create(struct bpf_prog **pfp, struct sock_fprog_kern *fprog);
+ int bpf_prog_create_from_user(struct bpf_prog **pfp, struct sock_fprog *fprog,
+ 			      bpf_aux_classic_check_t trans, bool save_orig);
+ void bpf_prog_destroy(struct bpf_prog *fp);
+ 
+ int sk_attach_filter(struct sock_fprog *fprog, struct sock *sk);
+ int sk_attach_bpf(u32 ufd, struct sock *sk);
+ int sk_reuseport_attach_filter(struct sock_fprog *fprog, struct sock *sk);
+ int sk_reuseport_attach_bpf(u32 ufd, struct sock *sk);
+ int sk_detach_filter(struct sock *sk);
+ int sk_get_filter(struct sock *sk, struct sock_filter __user *filter,
+ 		  unsigned int len);
+ 
+ bool sk_filter_charge(struct sock *sk, struct sk_filter *fp);
+ void sk_filter_uncharge(struct sock *sk, struct sk_filter *fp);
+ 
+ u64 __bpf_call_base(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5);
+ 
+ struct bpf_prog *bpf_int_jit_compile(struct bpf_prog *prog);
+ bool bpf_helper_changes_skb_data(void *func);
+ 
+ struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,
+ 				       const struct bpf_insn *patch, u32 len);
+ 
++>>>>>>> d1c55ab5e41f (bpf: prepare bpf_int_jit_compile/bpf_prog_select_runtime apis)
  #ifdef CONFIG_BPF_JIT
 -extern int bpf_jit_enable;
 -
 -typedef void (*bpf_jit_fill_hole_t)(void *area, unsigned int size);
 -
 -struct bpf_binary_header *
 -bpf_jit_binary_alloc(unsigned int proglen, u8 **image_ptr,
 -		     unsigned int alignment,
 -		     bpf_jit_fill_hole_t bpf_fill_ill_insns);
 -void bpf_jit_binary_free(struct bpf_binary_header *hdr);
 +#include <stdarg.h>
 +#include <linux/linkage.h>
 +#include <linux/printk.h>
  
 -void bpf_jit_compile(struct bpf_prog *fp);
 -void bpf_jit_free(struct bpf_prog *fp);
 +extern void bpf_jit_compile(struct sk_filter *fp);
 +extern void bpf_jit_free(struct sk_filter *fp);
  
  static inline void bpf_jit_dump(unsigned int flen, unsigned int proglen,
  				u32 pass, void *image)
diff --cc net/core/filter.c
index 060ed5f86613,68adb5f52110..000000000000
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@@ -647,12 -900,118 +647,124 @@@ void sk_filter_release_rcu(struct rcu_h
  {
  	struct sk_filter *fp = container_of(rcu, struct sk_filter, rcu);
  
 -	__sk_filter_release(fp);
 +	bpf_jit_free(fp);
 +	kfree(fp);
  }
 +EXPORT_SYMBOL(sk_filter_release_rcu);
  
++<<<<<<< HEAD
 +static int __sk_prepare_filter(struct sk_filter *fp)
++=======
+ /**
+  *	sk_filter_release - release a socket filter
+  *	@fp: filter to remove
+  *
+  *	Remove a filter from a socket and release its resources.
+  */
+ static void sk_filter_release(struct sk_filter *fp)
+ {
+ 	if (atomic_dec_and_test(&fp->refcnt))
+ 		call_rcu(&fp->rcu, sk_filter_release_rcu);
+ }
+ 
+ void sk_filter_uncharge(struct sock *sk, struct sk_filter *fp)
+ {
+ 	u32 filter_size = bpf_prog_size(fp->prog->len);
+ 
+ 	atomic_sub(filter_size, &sk->sk_omem_alloc);
+ 	sk_filter_release(fp);
+ }
+ 
+ /* try to charge the socket memory if there is space available
+  * return true on success
+  */
+ bool sk_filter_charge(struct sock *sk, struct sk_filter *fp)
+ {
+ 	u32 filter_size = bpf_prog_size(fp->prog->len);
+ 
+ 	/* same check as in sock_kmalloc() */
+ 	if (filter_size <= sysctl_optmem_max &&
+ 	    atomic_read(&sk->sk_omem_alloc) + filter_size < sysctl_optmem_max) {
+ 		atomic_inc(&fp->refcnt);
+ 		atomic_add(filter_size, &sk->sk_omem_alloc);
+ 		return true;
+ 	}
+ 	return false;
+ }
+ 
+ static struct bpf_prog *bpf_migrate_filter(struct bpf_prog *fp)
+ {
+ 	struct sock_filter *old_prog;
+ 	struct bpf_prog *old_fp;
+ 	int err, new_len, old_len = fp->len;
+ 
+ 	/* We are free to overwrite insns et al right here as it
+ 	 * won't be used at this point in time anymore internally
+ 	 * after the migration to the internal BPF instruction
+ 	 * representation.
+ 	 */
+ 	BUILD_BUG_ON(sizeof(struct sock_filter) !=
+ 		     sizeof(struct bpf_insn));
+ 
+ 	/* Conversion cannot happen on overlapping memory areas,
+ 	 * so we need to keep the user BPF around until the 2nd
+ 	 * pass. At this time, the user BPF is stored in fp->insns.
+ 	 */
+ 	old_prog = kmemdup(fp->insns, old_len * sizeof(struct sock_filter),
+ 			   GFP_KERNEL | __GFP_NOWARN);
+ 	if (!old_prog) {
+ 		err = -ENOMEM;
+ 		goto out_err;
+ 	}
+ 
+ 	/* 1st pass: calculate the new program length. */
+ 	err = bpf_convert_filter(old_prog, old_len, NULL, &new_len);
+ 	if (err)
+ 		goto out_err_free;
+ 
+ 	/* Expand fp for appending the new filter representation. */
+ 	old_fp = fp;
+ 	fp = bpf_prog_realloc(old_fp, bpf_prog_size(new_len), 0);
+ 	if (!fp) {
+ 		/* The old_fp is still around in case we couldn't
+ 		 * allocate new memory, so uncharge on that one.
+ 		 */
+ 		fp = old_fp;
+ 		err = -ENOMEM;
+ 		goto out_err_free;
+ 	}
+ 
+ 	fp->len = new_len;
+ 
+ 	/* 2nd pass: remap sock_filter insns into bpf_insn insns. */
+ 	err = bpf_convert_filter(old_prog, old_len, fp->insnsi, &new_len);
+ 	if (err)
+ 		/* 2nd bpf_convert_filter() can fail only if it fails
+ 		 * to allocate memory, remapping must succeed. Note,
+ 		 * that at this time old_fp has already been released
+ 		 * by krealloc().
+ 		 */
+ 		goto out_err_free;
+ 
+ 	/* We are guaranteed to never error here with cBPF to eBPF
+ 	 * transitions, since there's no issue with type compatibility
+ 	 * checks on program arrays.
+ 	 */
+ 	fp = bpf_prog_select_runtime(fp, &err);
+ 
+ 	kfree(old_prog);
+ 	return fp;
+ 
+ out_err_free:
+ 	kfree(old_prog);
+ out_err:
+ 	__bpf_prog_release(fp);
+ 	return ERR_PTR(err);
+ }
+ 
+ static struct bpf_prog *bpf_prepare_filter(struct bpf_prog *fp,
+ 					   bpf_aux_classic_check_t trans)
++>>>>>>> d1c55ab5e41f (bpf: prepare bpf_int_jit_compile/bpf_prog_select_runtime apis)
  {
  	int err;
  
* Unmerged path arch/arm64/net/bpf_jit_comp.c
* Unmerged path kernel/bpf/core.c
* Unmerged path kernel/bpf/syscall.c
* Unmerged path lib/test_bpf.c
* Unmerged path arch/arm64/net/bpf_jit_comp.c
* Unmerged path arch/s390/net/bpf_jit_comp.c
* Unmerged path arch/x86/net/bpf_jit_comp.c
* Unmerged path include/linux/filter.h
* Unmerged path kernel/bpf/core.c
* Unmerged path kernel/bpf/syscall.c
* Unmerged path lib/test_bpf.c
* Unmerged path net/core/filter.c
