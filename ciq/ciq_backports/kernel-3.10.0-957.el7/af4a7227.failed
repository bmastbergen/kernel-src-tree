s390/zcrypt: Support up to 256 crypto adapters.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [s390] zcrypt: Support up to 256 crypto adapters (Hendrik Brueckner) [1568734]
Rebuild_FUZZ: 93.18%
commit-author Harald Freudenberger <freude@linux.vnet.ibm.com>
commit af4a72276d49da117dbc99799afee740a26f8f10
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/af4a7227.failed

There was an artificial restriction on the card/adapter id
to only 6 bits but all the AP commands do support adapter
ids with 8 bit. This patch removes this restriction to 64
adapters and now up to 256 adapter can get addressed.

Some of the ioctl calls work on the max number of cards
possible (which was 64). These ioctls are now deprecated
but still supported. All the defines, structs and ioctl
interface declarations have been kept for compabibility.
There are now new ioctls (and defines for these) with an
additional '2' appended which provide the extended versions
with 256 cards supported.

	Signed-off-by: Harald Freudenberger <freude@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit af4a72276d49da117dbc99799afee740a26f8f10)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/uapi/asm/zcrypt.h
#	drivers/s390/crypto/zcrypt_api.c
diff --cc arch/s390/include/uapi/asm/zcrypt.h
index a777f87ef889,b62e0614e440..000000000000
--- a/arch/s390/include/uapi/asm/zcrypt.h
+++ b/arch/s390/include/uapi/asm/zcrypt.h
@@@ -292,62 -278,22 +291,70 @@@ struct zcrypt_device_matrix_ext 
   *	 0x04: PCIXCC_MCL3
   *	 0x05: CEX2C
   *	 0x06: CEX2A
-  *	 0x0d: device is disabled via the proc filesystem
-  *
-  *   Z90STAT_QDEPTH_MASK
-  *     Return an 64 element array of unsigned chars for the queue
-  *     depth of all devices.
-  *
-  *   Z90STAT_PERDEV_REQCNT
-  *     Return an 64 element array of unsigned integers for the number
-  *     of successfully completed requests per device since the device
-  *     was detected and made available.
-  *
+  *	 0x07: CEX3C
+  *	 0x08: CEX3A
+  *	 0x0a: CEX4
+  *	 0x0b: CEX5
+  *	 0x0c: CEX6
+  *	 0x0d: device is disabled
+  *
+  *   ZCRYPT_QDEPTH_MASK
+  *     Return an MAX_ZDEV_CARDIDS_EXT element array of unsigned chars for the
+  *     queue depth of all devices.
+  *
+  *   ZCRYPT_PERDEV_REQCNT
+  *     Return an MAX_ZDEV_CARDIDS_EXT element array of unsigned integers for
+  *     the number of successfully completed requests per device since the
+  *     device was detected and made available.
+  *
++<<<<<<< HEAD
 + *   Z90STAT_REQUESTQ_COUNT
 + *     Return an integer count of the number of entries waiting to be
 + *     sent to a device.
 + *
 + *   Z90STAT_PENDINGQ_COUNT
 + *     Return an integer count of the number of entries sent to all
 + *     devices awaiting the reply.
 + *
 + *   Z90STAT_TOTALOPEN_COUNT
 + *     Return an integer count of the number of open file handles.
 + *
 + *   Z90STAT_DOMAIN_INDEX
 + *     Return the integer value of the Cryptographic Domain.
 + *
 + *   The following ioctls are deprecated and should be no longer used:
 + *
 + *   Z90STAT_TOTALCOUNT
 + *     Return an integer count of all device types together.
 + *
 + *   Z90STAT_PCICACOUNT
 + *     Return an integer count of all PCICAs.
 + *
 + *   Z90STAT_PCICCCOUNT
 + *     Return an integer count of all PCICCs.
 + *
 + *   Z90STAT_PCIXCCMCL2COUNT
 + *     Return an integer count of all MCL2 PCIXCCs.
 + *
 + *   Z90STAT_PCIXCCMCL3COUNT
 + *     Return an integer count of all MCL3 PCIXCCs.
 + *
 + *   Z90STAT_CEX2CCOUNT
 + *     Return an integer count of all CEX2Cs.
 + *
 + *   Z90STAT_CEX2ACOUNT
 + *     Return an integer count of all CEX2As.
 + *
 + *   ICAZ90STATUS
 + *     Return some device driver status in a ica_z90_status struct
 + *     This takes an ica_z90_status struct as its arg.
 + *
 + *   Z90STAT_PCIXCCCOUNT
 + *     Return an integer count of all PCIXCCs (MCL2 + MCL3).
 + *     This is DEPRECATED now that MCL3 PCIXCCs are treated differently from
 + *     MCL2 PCIXCCs.
++=======
++>>>>>>> af4a72276d49 (s390/zcrypt: Support up to 256 crypto adapters.)
   */
  
  /**
@@@ -357,16 -303,48 +364,59 @@@
  #define ICARSACRT	_IOC(_IOC_READ|_IOC_WRITE, ZCRYPT_IOCTL_MAGIC, 0x06, 0)
  #define ZSECSENDCPRB	_IOC(_IOC_READ|_IOC_WRITE, ZCRYPT_IOCTL_MAGIC, 0x81, 0)
  #define ZSENDEP11CPRB	_IOC(_IOC_READ|_IOC_WRITE, ZCRYPT_IOCTL_MAGIC, 0x04, 0)
- #define ZDEVICESTATUS	_IOC(_IOC_READ|_IOC_WRITE, ZCRYPT_IOCTL_MAGIC, 0x4f, 0)
  
++<<<<<<< HEAD
 +/* New status calls */
 +#define Z90STAT_TOTALCOUNT	_IOR(ZCRYPT_IOCTL_MAGIC, 0x40, int)
 +#define Z90STAT_PCICACOUNT	_IOR(ZCRYPT_IOCTL_MAGIC, 0x41, int)
 +#define Z90STAT_PCICCCOUNT	_IOR(ZCRYPT_IOCTL_MAGIC, 0x42, int)
 +#define Z90STAT_PCIXCCMCL2COUNT	_IOR(ZCRYPT_IOCTL_MAGIC, 0x4b, int)
 +#define Z90STAT_PCIXCCMCL3COUNT	_IOR(ZCRYPT_IOCTL_MAGIC, 0x4c, int)
 +#define Z90STAT_CEX2CCOUNT	_IOR(ZCRYPT_IOCTL_MAGIC, 0x4d, int)
 +#define Z90STAT_CEX2ACOUNT	_IOR(ZCRYPT_IOCTL_MAGIC, 0x4e, int)
++=======
+ #define ZCRYPT_DEVICE_STATUS _IOC(_IOC_READ|_IOC_WRITE, ZCRYPT_IOCTL_MAGIC, 0x5f, 0)
+ #define ZCRYPT_STATUS_MASK   _IOR(ZCRYPT_IOCTL_MAGIC, 0x58, char[MAX_ZDEV_CARDIDS_EXT])
+ #define ZCRYPT_QDEPTH_MASK   _IOR(ZCRYPT_IOCTL_MAGIC, 0x59, char[MAX_ZDEV_CARDIDS_EXT])
+ #define ZCRYPT_PERDEV_REQCNT _IOR(ZCRYPT_IOCTL_MAGIC, 0x5a, int[MAX_ZDEV_CARDIDS_EXT])
+ 
+ /*
+  * Only deprecated defines, structs and ioctls below this line.
+  */
+ 
+ /* Deprecated: use MAX_ZDEV_CARDIDS_EXT */
+ #define MAX_ZDEV_CARDIDS 64
+ /* Deprecated: use MAX_ZDEV_DOMAINS_EXT */
+ #define MAX_ZDEV_DOMAINS 256
+ 
+ /* Deprecated: use MAX_ZDEV_ENTRIES_EXT */
+ #define MAX_ZDEV_ENTRIES (MAX_ZDEV_CARDIDS * MAX_ZDEV_DOMAINS)
+ 
+ /* Deprecated: use struct zcrypt_device_status_ext */
+ struct zcrypt_device_status {
+ 	unsigned int hwtype:8;
+ 	unsigned int qid:14;
+ 	unsigned int online:1;
+ 	unsigned int functions:6;
+ 	unsigned int reserved:3;
+ };
+ 
+ /* Deprecated: use struct zcrypt_device_matrix_ext */
+ struct zcrypt_device_matrix {
+ 	struct zcrypt_device_status device[MAX_ZDEV_ENTRIES];
+ };
+ 
+ /* Deprecated: use ZCRYPT_DEVICE_STATUS */
+ #define ZDEVICESTATUS _IOC(_IOC_READ|_IOC_WRITE, ZCRYPT_IOCTL_MAGIC, 0x4f, 0)
+ /* Deprecated: use ZCRYPT_STATUS_MASK */
+ #define Z90STAT_STATUS_MASK _IOR(ZCRYPT_IOCTL_MAGIC, 0x48, char[64])
+ /* Deprecated: use ZCRYPT_QDEPTH_MASK */
+ #define Z90STAT_QDEPTH_MASK _IOR(ZCRYPT_IOCTL_MAGIC, 0x49, char[64])
+ /* Deprecated: use ZCRYPT_PERDEV_REQCNT */
+ #define Z90STAT_PERDEV_REQCNT _IOR(ZCRYPT_IOCTL_MAGIC, 0x4a, int[64])
+ 
+ /* Deprecated: use sysfs to query these values */
++>>>>>>> af4a72276d49 (s390/zcrypt: Support up to 256 crypto adapters.)
  #define Z90STAT_REQUESTQ_COUNT	_IOR(ZCRYPT_IOCTL_MAGIC, 0x44, int)
  #define Z90STAT_PENDINGQ_COUNT	_IOR(ZCRYPT_IOCTL_MAGIC, 0x45, int)
  #define Z90STAT_TOTALOPEN_COUNT _IOR(ZCRYPT_IOCTL_MAGIC, 0x46, int)
diff --cc drivers/s390/crypto/zcrypt_api.c
index eec75e31cb8f,5efd84862ccb..000000000000
--- a/drivers/s390/crypto/zcrypt_api.c
+++ b/drivers/s390/crypto/zcrypt_api.c
@@@ -946,38 -909,54 +983,89 @@@ static long zcrypt_unlocked_ioctl(struc
  	case Z90STAT_DOMAIN_INDEX:
  		return put_user(ap_domain_index, (int __user *) arg);
  	/*
++<<<<<<< HEAD
 +	 * Deprecated ioctls. Don't add another device count ioctl,
 +	 * you can count them yourself in the user space with the
 +	 * output of the Z90STAT_STATUS_MASK ioctl.
 +	 */
 +	case ICAZ90STATUS:
 +		return zcrypt_ica_status(filp, arg);
 +	case Z90STAT_TOTALCOUNT:
 +		return put_user(zcrypt_device_count, (int __user *) arg);
 +	case Z90STAT_PCICACOUNT:
 +		return put_user(zcrypt_count_type(ZCRYPT_PCICA),
 +				(int __user *) arg);
 +	case Z90STAT_PCICCCOUNT:
 +		return put_user(zcrypt_count_type(ZCRYPT_PCICC),
 +				(int __user *) arg);
 +	case Z90STAT_PCIXCCMCL2COUNT:
 +		return put_user(zcrypt_count_type(ZCRYPT_PCIXCC_MCL2),
 +				(int __user *) arg);
 +	case Z90STAT_PCIXCCMCL3COUNT:
 +		return put_user(zcrypt_count_type(ZCRYPT_PCIXCC_MCL3),
 +				(int __user *) arg);
 +	case Z90STAT_PCIXCCCOUNT:
 +		return put_user(zcrypt_count_type(ZCRYPT_PCIXCC_MCL2) +
 +				zcrypt_count_type(ZCRYPT_PCIXCC_MCL3),
 +				(int __user *) arg);
 +	case Z90STAT_CEX2CCOUNT:
 +		return put_user(zcrypt_count_type(ZCRYPT_CEX2C),
 +				(int __user *) arg);
 +	case Z90STAT_CEX2ACOUNT:
 +		return put_user(zcrypt_count_type(ZCRYPT_CEX2A),
 +				(int __user *) arg);
 +	default:
 +		/* unknown ioctl number */
++=======
+ 	 * Deprecated ioctls
+ 	 */
+ 	case ZDEVICESTATUS: {
+ 		/* the old ioctl supports only 64 adapters */
+ 		struct zcrypt_device_status *device_status;
+ 		size_t total_size = MAX_ZDEV_ENTRIES
+ 			* sizeof(struct zcrypt_device_status);
+ 
+ 		device_status = kzalloc(total_size, GFP_KERNEL);
+ 		if (!device_status)
+ 			return -ENOMEM;
+ 		zcrypt_device_status_mask(device_status);
+ 		if (copy_to_user((char __user *) arg, device_status,
+ 				 total_size))
+ 			rc = -EFAULT;
+ 		kfree(device_status);
+ 		return rc;
+ 	}
+ 	case Z90STAT_STATUS_MASK: {
+ 		/* the old ioctl supports only 64 adapters */
+ 		char status[MAX_ZDEV_CARDIDS];
+ 
+ 		zcrypt_status_mask(status, MAX_ZDEV_CARDIDS);
+ 		if (copy_to_user((char __user *) arg, status, sizeof(status)))
+ 			return -EFAULT;
+ 		return 0;
+ 	}
+ 	case Z90STAT_QDEPTH_MASK: {
+ 		/* the old ioctl supports only 64 adapters */
+ 		char qdepth[MAX_ZDEV_CARDIDS];
+ 
+ 		zcrypt_qdepth_mask(qdepth, MAX_ZDEV_CARDIDS);
+ 		if (copy_to_user((char __user *) arg, qdepth, sizeof(qdepth)))
+ 			return -EFAULT;
+ 		return 0;
+ 	}
+ 	case Z90STAT_PERDEV_REQCNT: {
+ 		/* the old ioctl supports only 64 adapters */
+ 		int reqcnt[MAX_ZDEV_CARDIDS];
+ 
+ 		zcrypt_perdev_reqcnt(reqcnt, MAX_ZDEV_CARDIDS);
+ 		if (copy_to_user((int __user *) arg, reqcnt, sizeof(reqcnt)))
+ 			return -EFAULT;
+ 		return 0;
+ 	}
+ 	/* unknown ioctl number */
+ 	default:
+ 		ZCRYPT_DBF(DBF_DEBUG, "unknown ioctl 0x%08x\n", cmd);
++>>>>>>> af4a72276d49 (s390/zcrypt: Support up to 256 crypto adapters.)
  		return -ENOIOCTLCMD;
  	}
  }
diff --git a/arch/s390/include/asm/ap.h b/arch/s390/include/asm/ap.h
index c02f4aba88a6..0d99749b5d09 100644
--- a/arch/s390/include/asm/ap.h
+++ b/arch/s390/include/asm/ap.h
@@ -23,9 +23,9 @@
  */
 typedef unsigned int ap_qid_t;
 
-#define AP_MKQID(_card, _queue) (((_card) & 63) << 8 | ((_queue) & 255))
-#define AP_QID_CARD(_qid) (((_qid) >> 8) & 63)
-#define AP_QID_QUEUE(_qid) ((_qid) & 255)
+#define AP_MKQID(_card, _queue) (((_card) & 0xff) << 8 | ((_queue) & 0xff))
+#define AP_QID_CARD(_qid) (((_qid) >> 8) & 0xff)
+#define AP_QID_QUEUE(_qid) ((_qid) & 0xff)
 
 /**
  * struct ap_queue_status - Holds the AP queue status.
* Unmerged path arch/s390/include/uapi/asm/zcrypt.h
diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index f99aa0e91022..6f7bb3c0020d 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -30,7 +30,7 @@
 #include <linux/types.h>
 #include <asm/ap.h>
 
-#define AP_DEVICES 64		/* Number of AP devices. */
+#define AP_DEVICES 256		/* Number of AP devices. */
 #define AP_DOMAINS 256		/* Number of AP domains. */
 #define AP_RESET_TIMEOUT (HZ*0.7)	/* Time in ticks for reset timeouts. */
 #define AP_CONFIG_TIME 30	/* Time in seconds between AP bus rescans. */
diff --git a/drivers/s390/crypto/pkey_api.c b/drivers/s390/crypto/pkey_api.c
index ea86da8c75f9..5398fbe82b19 100644
--- a/drivers/s390/crypto/pkey_api.c
+++ b/drivers/s390/crypto/pkey_api.c
@@ -894,7 +894,7 @@ int pkey_findcard(const struct pkey_seckey *seckey,
 		  u16 *pcardnr, u16 *pdomain, int verify)
 {
 	struct secaeskeytoken *t = (struct secaeskeytoken *) seckey;
-	struct zcrypt_device_matrix *device_matrix;
+	struct zcrypt_device_status_ext *device_status;
 	u16 card, dom;
 	u64 mkvp[2];
 	int i, rc, oi = -1;
@@ -904,18 +904,19 @@ int pkey_findcard(const struct pkey_seckey *seckey,
 		return -EINVAL;
 
 	/* fetch status of all crypto cards */
-	device_matrix = kmalloc(sizeof(struct zcrypt_device_matrix),
+	device_status = kmalloc(MAX_ZDEV_ENTRIES_EXT
+				* sizeof(struct zcrypt_device_status_ext),
 				GFP_KERNEL);
-	if (!device_matrix)
+	if (!device_status)
 		return -ENOMEM;
-	zcrypt_device_status_mask(device_matrix);
+	zcrypt_device_status_mask_ext(device_status);
 
 	/* walk through all crypto cards */
-	for (i = 0; i < MAX_ZDEV_ENTRIES; i++) {
-		card = AP_QID_CARD(device_matrix->device[i].qid);
-		dom = AP_QID_QUEUE(device_matrix->device[i].qid);
-		if (device_matrix->device[i].online &&
-		    device_matrix->device[i].functions & 0x04) {
+	for (i = 0; i < MAX_ZDEV_ENTRIES_EXT; i++) {
+		card = AP_QID_CARD(device_status[i].qid);
+		dom = AP_QID_QUEUE(device_status[i].qid);
+		if (device_status[i].online &&
+		    device_status[i].functions & 0x04) {
 			/* an enabled CCA Coprocessor card */
 			/* try cached mkvp */
 			if (mkvp_cache_fetch(card, dom, mkvp) == 0 &&
@@ -935,14 +936,14 @@ int pkey_findcard(const struct pkey_seckey *seckey,
 			mkvp_cache_scrub(card, dom);
 		}
 	}
-	if (i >= MAX_ZDEV_ENTRIES) {
+	if (i >= MAX_ZDEV_ENTRIES_EXT) {
 		/* nothing found, so this time without cache */
-		for (i = 0; i < MAX_ZDEV_ENTRIES; i++) {
-			if (!(device_matrix->device[i].online &&
-			      device_matrix->device[i].functions & 0x04))
+		for (i = 0; i < MAX_ZDEV_ENTRIES_EXT; i++) {
+			if (!(device_status[i].online &&
+			      device_status[i].functions & 0x04))
 				continue;
-			card = AP_QID_CARD(device_matrix->device[i].qid);
-			dom = AP_QID_QUEUE(device_matrix->device[i].qid);
+			card = AP_QID_CARD(device_status[i].qid);
+			dom = AP_QID_QUEUE(device_status[i].qid);
 			/* fresh fetch mkvp from adapter */
 			if (fetch_mkvp(card, dom, mkvp) == 0) {
 				mkvp_cache_update(card, dom, mkvp);
@@ -952,13 +953,13 @@ int pkey_findcard(const struct pkey_seckey *seckey,
 					oi = i;
 			}
 		}
-		if (i >= MAX_ZDEV_ENTRIES && oi >= 0) {
+		if (i >= MAX_ZDEV_ENTRIES_EXT && oi >= 0) {
 			/* old mkvp matched, use this card then */
-			card = AP_QID_CARD(device_matrix->device[oi].qid);
-			dom = AP_QID_QUEUE(device_matrix->device[oi].qid);
+			card = AP_QID_CARD(device_status[oi].qid);
+			dom = AP_QID_QUEUE(device_status[oi].qid);
 		}
 	}
-	if (i < MAX_ZDEV_ENTRIES || oi >= 0) {
+	if (i < MAX_ZDEV_ENTRIES_EXT || oi >= 0) {
 		if (pcardnr)
 			*pcardnr = card;
 		if (pdomain)
@@ -967,7 +968,7 @@ int pkey_findcard(const struct pkey_seckey *seckey,
 	} else
 		rc = -ENODEV;
 
-	kfree(device_matrix);
+	kfree(device_status);
 	return rc;
 }
 EXPORT_SYMBOL(pkey_findcard);
* Unmerged path drivers/s390/crypto/zcrypt_api.c
diff --git a/drivers/s390/crypto/zcrypt_api.h b/drivers/s390/crypto/zcrypt_api.h
index 973bb9a44906..177aa5d0c550 100644
--- a/drivers/s390/crypto/zcrypt_api.h
+++ b/drivers/s390/crypto/zcrypt_api.h
@@ -191,6 +191,6 @@ struct zcrypt_ops *zcrypt_msgtype(unsigned char *, int);
 int zcrypt_api_init(void);
 void zcrypt_api_exit(void);
 long zcrypt_send_cprb(struct ica_xcRB *xcRB);
-void zcrypt_device_status_mask(struct zcrypt_device_matrix *devstatus);
+void zcrypt_device_status_mask_ext(struct zcrypt_device_status_ext *devstatus);
 
 #endif /* _ZCRYPT_API_H_ */
