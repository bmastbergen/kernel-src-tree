KVM: s390: Add operation exception interception handler

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Janosch Frank <frankja@linux.vnet.ibm.com>
commit a011eeb2a3d6cd778eb63bea0bf149ebbe658ab5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/a011eeb2.failed

This commit introduces code that handles operation exception
interceptions. With this handler we can emulate instructions by using
illegal opcodes.

	Signed-off-by: Janosch Frank <frankja@linux.vnet.ibm.com>
	Reviewed-by: David Hildenbrand <dahi@linux.vnet.ibm.com>
	Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
(cherry picked from commit a011eeb2a3d6cd778eb63bea0bf149ebbe658ab5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/kvm_host.h
#	arch/s390/kvm/intercept.c
diff --cc arch/s390/include/asm/kvm_host.h
index 0aaab12c8aec,093ea14109e2..000000000000
--- a/arch/s390/include/asm/kvm_host.h
+++ b/arch/s390/include/asm/kvm_host.h
@@@ -118,97 -214,226 +118,163 @@@ struct kvm_s390_sie_block 
  	__u64	gbea;			/* 0x0180 */
  	__u8	reserved188[24];	/* 0x0188 */
  	__u32	fac;			/* 0x01a0 */
 -	__u8	reserved1a4[20];	/* 0x01a4 */
 -	__u64	cbrlo;			/* 0x01b8 */
 -	__u8	reserved1c0[8];		/* 0x01c0 */
 -	__u32	ecd;			/* 0x01c8 */
 -	__u8	reserved1cc[18];	/* 0x01cc */
 -	__u64	pp;			/* 0x01de */
 -	__u8	reserved1e6[2];		/* 0x01e6 */
 -	__u64	itdba;			/* 0x01e8 */
 -	__u64   riccbd;			/* 0x01f0 */
 -	__u8    reserved1f8[8];		/* 0x01f8 */
 +	__u8	reserved1a4[92];	/* 0x01a4 */
  } __attribute__((packed));
  
 -struct kvm_s390_itdb {
 -	__u8	data[256];
 -} __packed;
 -
 -struct sie_page {
 -	struct kvm_s390_sie_block sie_block;
 -	__u8 reserved200[1024];		/* 0x0200 */
 -	struct kvm_s390_itdb itdb;	/* 0x0600 */
 -	__u8 reserved700[2304];		/* 0x0700 */
 -} __packed;
 -
  struct kvm_vcpu_stat {
++<<<<<<< HEAD
 +	u64 exit_userspace;
 +	u64 exit_null;
 +	u64 exit_external_request;
 +	u64 exit_external_interrupt;
 +	u64 exit_stop_request;
 +	u64 exit_validity;
 +	u64 exit_instruction;
 +	u64 halt_successful_poll;
 +	u64 halt_attempted_poll;
 +	u64 instruction_lctl;
 +	u64 instruction_lctlg;
 +	u64 exit_program_interruption;
 +	u64 exit_instr_and_program;
 +	u64 deliver_external_call;
 +	u64 deliver_emergency_signal;
 +	u64 deliver_service_signal;
 +	u64 deliver_virtio_interrupt;
 +	u64 deliver_stop_signal;
 +	u64 deliver_prefix_signal;
 +	u64 deliver_restart_signal;
 +	u64 deliver_program_int;
 +	u64 deliver_io_int;
 +	u64 exit_wait_state;
 +	u64 instruction_pfmf;
 +	u64 instruction_stidp;
 +	u64 instruction_spx;
 +	u64 instruction_stpx;
 +	u64 instruction_stap;
 +	u64 instruction_storage_key;
 +	u64 instruction_stsch;
 +	u64 instruction_chsc;
 +	u64 instruction_stsi;
 +	u64 instruction_stfl;
 +	u64 instruction_tprot;
 +	u64 instruction_sigp_sense;
 +	u64 instruction_sigp_sense_running;
 +	u64 instruction_sigp_external_call;
 +	u64 instruction_sigp_emergency;
 +	u64 instruction_sigp_stop;
 +	u64 instruction_sigp_arch;
 +	u64 instruction_sigp_prefix;
 +	u64 instruction_sigp_restart;
 +	u64 diagnose_10;
 +	u64 diagnose_44;
 +	u64 diagnose_9c;
++=======
+ 	u32 exit_userspace;
+ 	u32 exit_null;
+ 	u32 exit_external_request;
+ 	u32 exit_external_interrupt;
+ 	u32 exit_stop_request;
+ 	u32 exit_validity;
+ 	u32 exit_instruction;
+ 	u32 halt_successful_poll;
+ 	u32 halt_attempted_poll;
+ 	u32 halt_poll_invalid;
+ 	u32 halt_wakeup;
+ 	u32 instruction_lctl;
+ 	u32 instruction_lctlg;
+ 	u32 instruction_stctl;
+ 	u32 instruction_stctg;
+ 	u32 exit_program_interruption;
+ 	u32 exit_instr_and_program;
+ 	u32 exit_operation_exception;
+ 	u32 deliver_external_call;
+ 	u32 deliver_emergency_signal;
+ 	u32 deliver_service_signal;
+ 	u32 deliver_virtio_interrupt;
+ 	u32 deliver_stop_signal;
+ 	u32 deliver_prefix_signal;
+ 	u32 deliver_restart_signal;
+ 	u32 deliver_program_int;
+ 	u32 deliver_io_int;
+ 	u32 exit_wait_state;
+ 	u32 instruction_pfmf;
+ 	u32 instruction_stidp;
+ 	u32 instruction_spx;
+ 	u32 instruction_stpx;
+ 	u32 instruction_stap;
+ 	u32 instruction_storage_key;
+ 	u32 instruction_ipte_interlock;
+ 	u32 instruction_stsch;
+ 	u32 instruction_chsc;
+ 	u32 instruction_stsi;
+ 	u32 instruction_stfl;
+ 	u32 instruction_tprot;
+ 	u32 instruction_essa;
+ 	u32 instruction_sigp_sense;
+ 	u32 instruction_sigp_sense_running;
+ 	u32 instruction_sigp_external_call;
+ 	u32 instruction_sigp_emergency;
+ 	u32 instruction_sigp_cond_emergency;
+ 	u32 instruction_sigp_start;
+ 	u32 instruction_sigp_stop;
+ 	u32 instruction_sigp_stop_store_status;
+ 	u32 instruction_sigp_store_status;
+ 	u32 instruction_sigp_store_adtl_status;
+ 	u32 instruction_sigp_arch;
+ 	u32 instruction_sigp_prefix;
+ 	u32 instruction_sigp_restart;
+ 	u32 instruction_sigp_init_cpu_reset;
+ 	u32 instruction_sigp_cpu_reset;
+ 	u32 instruction_sigp_unknown;
+ 	u32 diagnose_10;
+ 	u32 diagnose_44;
+ 	u32 diagnose_9c;
+ 	u32 diagnose_258;
+ 	u32 diagnose_308;
+ 	u32 diagnose_500;
++>>>>>>> a011eeb2a3d6 (KVM: s390: Add operation exception interception handler)
  };
  
 -#define PGM_OPERATION			0x01
 -#define PGM_PRIVILEGED_OP		0x02
 -#define PGM_EXECUTE			0x03
 -#define PGM_PROTECTION			0x04
 -#define PGM_ADDRESSING			0x05
 -#define PGM_SPECIFICATION		0x06
 -#define PGM_DATA			0x07
 -#define PGM_FIXED_POINT_OVERFLOW	0x08
 -#define PGM_FIXED_POINT_DIVIDE		0x09
 -#define PGM_DECIMAL_OVERFLOW		0x0a
 -#define PGM_DECIMAL_DIVIDE		0x0b
 -#define PGM_HFP_EXPONENT_OVERFLOW	0x0c
 -#define PGM_HFP_EXPONENT_UNDERFLOW	0x0d
 -#define PGM_HFP_SIGNIFICANCE		0x0e
 -#define PGM_HFP_DIVIDE			0x0f
 -#define PGM_SEGMENT_TRANSLATION		0x10
 -#define PGM_PAGE_TRANSLATION		0x11
 -#define PGM_TRANSLATION_SPEC		0x12
 -#define PGM_SPECIAL_OPERATION		0x13
 -#define PGM_OPERAND			0x15
 -#define PGM_TRACE_TABEL			0x16
 -#define PGM_VECTOR_PROCESSING		0x1b
 -#define PGM_SPACE_SWITCH		0x1c
 -#define PGM_HFP_SQUARE_ROOT		0x1d
 -#define PGM_PC_TRANSLATION_SPEC		0x1f
 -#define PGM_AFX_TRANSLATION		0x20
 -#define PGM_ASX_TRANSLATION		0x21
 -#define PGM_LX_TRANSLATION		0x22
 -#define PGM_EX_TRANSLATION		0x23
 -#define PGM_PRIMARY_AUTHORITY		0x24
 -#define PGM_SECONDARY_AUTHORITY		0x25
 -#define PGM_LFX_TRANSLATION		0x26
 -#define PGM_LSX_TRANSLATION		0x27
 -#define PGM_ALET_SPECIFICATION		0x28
 -#define PGM_ALEN_TRANSLATION		0x29
 -#define PGM_ALE_SEQUENCE		0x2a
 -#define PGM_ASTE_VALIDITY		0x2b
 -#define PGM_ASTE_SEQUENCE		0x2c
 -#define PGM_EXTENDED_AUTHORITY		0x2d
 -#define PGM_LSTE_SEQUENCE		0x2e
 -#define PGM_ASTE_INSTANCE		0x2f
 -#define PGM_STACK_FULL			0x30
 -#define PGM_STACK_EMPTY			0x31
 -#define PGM_STACK_SPECIFICATION		0x32
 -#define PGM_STACK_TYPE			0x33
 -#define PGM_STACK_OPERATION		0x34
 -#define PGM_ASCE_TYPE			0x38
 -#define PGM_REGION_FIRST_TRANS		0x39
 -#define PGM_REGION_SECOND_TRANS		0x3a
 -#define PGM_REGION_THIRD_TRANS		0x3b
 -#define PGM_MONITOR			0x40
 -#define PGM_PER				0x80
 -#define PGM_CRYPTO_OPERATION		0x119
 -
 -/* irq types in order of priority */
 -enum irq_types {
 -	IRQ_PEND_MCHK_EX = 0,
 -	IRQ_PEND_SVC,
 -	IRQ_PEND_PROG,
 -	IRQ_PEND_MCHK_REP,
 -	IRQ_PEND_EXT_IRQ_KEY,
 -	IRQ_PEND_EXT_MALFUNC,
 -	IRQ_PEND_EXT_EMERGENCY,
 -	IRQ_PEND_EXT_EXTERNAL,
 -	IRQ_PEND_EXT_CLOCK_COMP,
 -	IRQ_PEND_EXT_CPU_TIMER,
 -	IRQ_PEND_EXT_TIMING,
 -	IRQ_PEND_EXT_SERVICE,
 -	IRQ_PEND_EXT_HOST,
 -	IRQ_PEND_PFAULT_INIT,
 -	IRQ_PEND_PFAULT_DONE,
 -	IRQ_PEND_VIRTIO,
 -	IRQ_PEND_IO_ISC_0,
 -	IRQ_PEND_IO_ISC_1,
 -	IRQ_PEND_IO_ISC_2,
 -	IRQ_PEND_IO_ISC_3,
 -	IRQ_PEND_IO_ISC_4,
 -	IRQ_PEND_IO_ISC_5,
 -	IRQ_PEND_IO_ISC_6,
 -	IRQ_PEND_IO_ISC_7,
 -	IRQ_PEND_SIGP_STOP,
 -	IRQ_PEND_RESTART,
 -	IRQ_PEND_SET_PREFIX,
 -	IRQ_PEND_COUNT
 +struct kvm_s390_io_info {
 +	__u16        subchannel_id;            /* 0x0b8 */
 +	__u16        subchannel_nr;            /* 0x0ba */
 +	__u32        io_int_parm;              /* 0x0bc */
 +	__u32        io_int_word;              /* 0x0c0 */
  };
  
 -/* We have 2M for virtio device descriptor pages. Smallest amount of
 - * memory per page is 24 bytes (1 queue), so (2048*1024) / 24 = 87381
 - */
 -#define KVM_S390_MAX_VIRTIO_IRQS 87381
 +struct kvm_s390_ext_info {
 +	__u32 ext_params;
 +	__u64 ext_params2;
 +};
  
 -/*
 - * Repressible (non-floating) machine check interrupts
 - * subclass bits in MCIC
 - */
 -#define MCHK_EXTD_BIT 58
 -#define MCHK_DEGR_BIT 56
 -#define MCHK_WARN_BIT 55
 -#define MCHK_REP_MASK ((1UL << MCHK_DEGR_BIT) | \
 -		       (1UL << MCHK_EXTD_BIT) | \
 -		       (1UL << MCHK_WARN_BIT))
 -
 -/* Exigent machine check interrupts subclass bits in MCIC */
 -#define MCHK_SD_BIT 63
 -#define MCHK_PD_BIT 62
 -#define MCHK_EX_MASK ((1UL << MCHK_SD_BIT) | (1UL << MCHK_PD_BIT))
 -
 -#define IRQ_PEND_EXT_MASK ((1UL << IRQ_PEND_EXT_IRQ_KEY)    | \
 -			   (1UL << IRQ_PEND_EXT_CLOCK_COMP) | \
 -			   (1UL << IRQ_PEND_EXT_CPU_TIMER)  | \
 -			   (1UL << IRQ_PEND_EXT_MALFUNC)    | \
 -			   (1UL << IRQ_PEND_EXT_EMERGENCY)  | \
 -			   (1UL << IRQ_PEND_EXT_EXTERNAL)   | \
 -			   (1UL << IRQ_PEND_EXT_TIMING)     | \
 -			   (1UL << IRQ_PEND_EXT_HOST)       | \
 -			   (1UL << IRQ_PEND_EXT_SERVICE)    | \
 -			   (1UL << IRQ_PEND_VIRTIO)         | \
 -			   (1UL << IRQ_PEND_PFAULT_INIT)    | \
 -			   (1UL << IRQ_PEND_PFAULT_DONE))
 -
 -#define IRQ_PEND_IO_MASK ((1UL << IRQ_PEND_IO_ISC_0) | \
 -			  (1UL << IRQ_PEND_IO_ISC_1) | \
 -			  (1UL << IRQ_PEND_IO_ISC_2) | \
 -			  (1UL << IRQ_PEND_IO_ISC_3) | \
 -			  (1UL << IRQ_PEND_IO_ISC_4) | \
 -			  (1UL << IRQ_PEND_IO_ISC_5) | \
 -			  (1UL << IRQ_PEND_IO_ISC_6) | \
 -			  (1UL << IRQ_PEND_IO_ISC_7))
 -
 -#define IRQ_PEND_MCHK_MASK ((1UL << IRQ_PEND_MCHK_REP) | \
 -			    (1UL << IRQ_PEND_MCHK_EX))
 +#define PGM_OPERATION            0x01
 +#define PGM_PRIVILEGED_OP	 0x02
 +#define PGM_EXECUTE              0x03
 +#define PGM_PROTECTION           0x04
 +#define PGM_ADDRESSING           0x05
 +#define PGM_SPECIFICATION        0x06
 +#define PGM_DATA                 0x07
 +
 +struct kvm_s390_pgm_info {
 +	__u16 code;
 +};
 +
 +struct kvm_s390_prefix_info {
 +	__u32 address;
 +};
 +
 +struct kvm_s390_extcall_info {
 +	__u16 code;
 +};
 +
 +struct kvm_s390_emerg_info {
 +	__u16 code;
 +};
 +
 +struct kvm_s390_mchk_info {
 +	__u64 cr14;
 +	__u64 mcic;
 +};
  
  struct kvm_s390_interrupt_info {
  	struct list_head list;
diff --cc arch/s390/kvm/intercept.c
index 5ee56e5acc23,09c13db1416f..000000000000
--- a/arch/s390/kvm/intercept.c
+++ b/arch/s390/kvm/intercept.c
@@@ -115,50 -136,254 +115,83 @@@ static int handle_instruction(struct kv
  	return -EOPNOTSUPP;
  }
  
 -static int inject_prog_on_prog_intercept(struct kvm_vcpu *vcpu)
 -{
 -	struct kvm_s390_pgm_info pgm_info = {
 -		.code = vcpu->arch.sie_block->iprcc,
 -		/* the PSW has already been rewound */
 -		.flags = KVM_S390_PGM_FLAGS_NO_REWIND,
 -	};
 -
 -	switch (vcpu->arch.sie_block->iprcc & ~PGM_PER) {
 -	case PGM_AFX_TRANSLATION:
 -	case PGM_ASX_TRANSLATION:
 -	case PGM_EX_TRANSLATION:
 -	case PGM_LFX_TRANSLATION:
 -	case PGM_LSTE_SEQUENCE:
 -	case PGM_LSX_TRANSLATION:
 -	case PGM_LX_TRANSLATION:
 -	case PGM_PRIMARY_AUTHORITY:
 -	case PGM_SECONDARY_AUTHORITY:
 -	case PGM_SPACE_SWITCH:
 -		pgm_info.trans_exc_code = vcpu->arch.sie_block->tecmc;
 -		break;
 -	case PGM_ALEN_TRANSLATION:
 -	case PGM_ALE_SEQUENCE:
 -	case PGM_ASTE_INSTANCE:
 -	case PGM_ASTE_SEQUENCE:
 -	case PGM_ASTE_VALIDITY:
 -	case PGM_EXTENDED_AUTHORITY:
 -		pgm_info.exc_access_id = vcpu->arch.sie_block->eai;
 -		break;
 -	case PGM_ASCE_TYPE:
 -	case PGM_PAGE_TRANSLATION:
 -	case PGM_REGION_FIRST_TRANS:
 -	case PGM_REGION_SECOND_TRANS:
 -	case PGM_REGION_THIRD_TRANS:
 -	case PGM_SEGMENT_TRANSLATION:
 -		pgm_info.trans_exc_code = vcpu->arch.sie_block->tecmc;
 -		pgm_info.exc_access_id  = vcpu->arch.sie_block->eai;
 -		pgm_info.op_access_id  = vcpu->arch.sie_block->oai;
 -		break;
 -	case PGM_MONITOR:
 -		pgm_info.mon_class_nr = vcpu->arch.sie_block->mcn;
 -		pgm_info.mon_code = vcpu->arch.sie_block->tecmc;
 -		break;
 -	case PGM_VECTOR_PROCESSING:
 -	case PGM_DATA:
 -		pgm_info.data_exc_code = vcpu->arch.sie_block->dxc;
 -		break;
 -	case PGM_PROTECTION:
 -		pgm_info.trans_exc_code = vcpu->arch.sie_block->tecmc;
 -		pgm_info.exc_access_id  = vcpu->arch.sie_block->eai;
 -		break;
 -	default:
 -		break;
 -	}
 -
 -	if (vcpu->arch.sie_block->iprcc & PGM_PER) {
 -		pgm_info.per_code = vcpu->arch.sie_block->perc;
 -		pgm_info.per_atmid = vcpu->arch.sie_block->peratmid;
 -		pgm_info.per_address = vcpu->arch.sie_block->peraddr;
 -		pgm_info.per_access_id = vcpu->arch.sie_block->peraid;
 -	}
 -	return kvm_s390_inject_prog_irq(vcpu, &pgm_info);
 -}
 -
 -/*
 - * restore ITDB to program-interruption TDB in guest lowcore
 - * and set TX abort indication if required
 -*/
 -static int handle_itdb(struct kvm_vcpu *vcpu)
 -{
 -	struct kvm_s390_itdb *itdb;
 -	int rc;
 -
 -	if (!IS_TE_ENABLED(vcpu) || !IS_ITDB_VALID(vcpu))
 -		return 0;
 -	if (current->thread.per_flags & PER_FLAG_NO_TE)
 -		return 0;
 -	itdb = (struct kvm_s390_itdb *)vcpu->arch.sie_block->itdba;
 -	rc = write_guest_lc(vcpu, __LC_PGM_TDB, itdb, sizeof(*itdb));
 -	if (rc)
 -		return rc;
 -	memset(itdb, 0, sizeof(*itdb));
 -
 -	return 0;
 -}
 -
 -#define per_event(vcpu) (vcpu->arch.sie_block->iprcc & PGM_PER)
 -
  static int handle_prog(struct kvm_vcpu *vcpu)
  {
 -	psw_t psw;
 -	int rc;
 -
  	vcpu->stat.exit_program_interruption++;
 -
 -	if (guestdbg_enabled(vcpu) && per_event(vcpu)) {
 -		kvm_s390_handle_per_event(vcpu);
 -		/* the interrupt might have been filtered out completely */
 -		if (vcpu->arch.sie_block->iprcc == 0)
 -			return 0;
 -	}
 -
  	trace_kvm_s390_intercept_prog(vcpu, vcpu->arch.sie_block->iprcc);
 -	if (vcpu->arch.sie_block->iprcc == PGM_SPECIFICATION) {
 -		rc = read_guest_lc(vcpu, __LC_PGM_NEW_PSW, &psw, sizeof(psw_t));
 -		if (rc)
 -			return rc;
 -		/* Avoid endless loops of specification exceptions */
 -		if (!is_valid_psw(&psw))
 -			return -EOPNOTSUPP;
 -	}
 -	rc = handle_itdb(vcpu);
 -	if (rc)
 -		return rc;
 -
 -	return inject_prog_on_prog_intercept(vcpu);
 +	return kvm_s390_inject_program_int(vcpu, vcpu->arch.sie_block->iprcc);
  }
  
 -/**
 - * handle_external_interrupt - used for external interruption interceptions
 - *
 - * This interception only occurs if the CPUSTAT_EXT_INT bit was set, or if
 - * the new PSW does not have external interrupts disabled. In the first case,
 - * we've got to deliver the interrupt manually, and in the second case, we
 - * drop to userspace to handle the situation there.
 - */
 -static int handle_external_interrupt(struct kvm_vcpu *vcpu)
 +static int handle_instruction_and_prog(struct kvm_vcpu *vcpu)
  {
 -	u16 eic = vcpu->arch.sie_block->eic;
 -	struct kvm_s390_irq irq;
 -	psw_t newpsw;
 -	int rc;
 +	int rc, rc2;
  
 -	vcpu->stat.exit_external_interrupt++;
 +	vcpu->stat.exit_instr_and_program++;
 +	rc = handle_instruction(vcpu);
 +	rc2 = handle_prog(vcpu);
  
 -	rc = read_guest_lc(vcpu, __LC_EXT_NEW_PSW, &newpsw, sizeof(psw_t));
 +	if (rc == -EOPNOTSUPP)
 +		vcpu->arch.sie_block->icptcode = 0x04;
  	if (rc)
  		return rc;
 -	/* We can not handle clock comparator or timer interrupt with bad PSW */
 -	if ((eic == EXT_IRQ_CLK_COMP || eic == EXT_IRQ_CPU_TIMER) &&
 -	    (newpsw.mask & PSW_MASK_EXT))
 -		return -EOPNOTSUPP;
 -
 -	switch (eic) {
 -	case EXT_IRQ_CLK_COMP:
 -		irq.type = KVM_S390_INT_CLOCK_COMP;
 -		break;
 -	case EXT_IRQ_CPU_TIMER:
 -		irq.type = KVM_S390_INT_CPU_TIMER;
 -		break;
 -	case EXT_IRQ_EXTERNAL_CALL:
 -		irq.type = KVM_S390_INT_EXTERNAL_CALL;
 -		irq.u.extcall.code = vcpu->arch.sie_block->extcpuaddr;
 -		rc = kvm_s390_inject_vcpu(vcpu, &irq);
 -		/* ignore if another external call is already pending */
 -		if (rc == -EBUSY)
 -			return 0;
 -		return rc;
 -	default:
 -		return -EOPNOTSUPP;
 -	}
 -
 -	return kvm_s390_inject_vcpu(vcpu, &irq);
 +	return rc2;
  }
  
 -/**
 - * Handle MOVE PAGE partial execution interception.
 - *
 - * This interception can only happen for guests with DAT disabled and
 - * addresses that are currently not mapped in the host. Thus we try to
 - * set up the mappings for the corresponding user pages here (or throw
 - * addressing exceptions in case of illegal guest addresses).
 - */
 -static int handle_mvpg_pei(struct kvm_vcpu *vcpu)
 -{
 -	unsigned long srcaddr, dstaddr;
 -	int reg1, reg2, rc;
 -
 -	kvm_s390_get_regs_rre(vcpu, &reg1, &reg2);
 -
 -	/* Make sure that the source is paged-in */
 -	rc = guest_translate_address(vcpu, vcpu->run->s.regs.gprs[reg2],
 -				     reg2, &srcaddr, GACC_FETCH);
 -	if (rc)
 -		return kvm_s390_inject_prog_cond(vcpu, rc);
 -	rc = kvm_arch_fault_in_page(vcpu, srcaddr, 0);
 -	if (rc != 0)
 -		return rc;
 -
 -	/* Make sure that the destination is paged-in */
 -	rc = guest_translate_address(vcpu, vcpu->run->s.regs.gprs[reg1],
 -				     reg1, &dstaddr, GACC_STORE);
 -	if (rc)
 -		return kvm_s390_inject_prog_cond(vcpu, rc);
 -	rc = kvm_arch_fault_in_page(vcpu, dstaddr, 1);
 -	if (rc != 0)
 -		return rc;
 -
 -	kvm_s390_retry_instr(vcpu);
 -
 -	return 0;
 -}
 -
 -static int handle_partial_execution(struct kvm_vcpu *vcpu)
 -{
 -	if (vcpu->arch.sie_block->ipa == 0xb254)	/* MVPG */
 -		return handle_mvpg_pei(vcpu);
 -	if (vcpu->arch.sie_block->ipa >> 8 == 0xae)	/* SIGP */
 -		return kvm_s390_handle_sigp_pei(vcpu);
 -
 -	return -EOPNOTSUPP;
 -}
 +static const intercept_handler_t intercept_funcs[] = {
 +	[0x00 >> 2] = handle_noop,
 +	[0x04 >> 2] = handle_instruction,
 +	[0x08 >> 2] = handle_prog,
 +	[0x0C >> 2] = handle_instruction_and_prog,
 +	[0x10 >> 2] = handle_noop,
 +	[0x14 >> 2] = handle_noop,
 +	[0x18 >> 2] = handle_noop,
 +	[0x1C >> 2] = kvm_s390_handle_wait,
 +	[0x20 >> 2] = handle_validity,
 +	[0x28 >> 2] = handle_stop,
 +};
  
+ static int handle_operexc(struct kvm_vcpu *vcpu)
+ {
+ 	vcpu->stat.exit_operation_exception++;
+ 	trace_kvm_s390_handle_operexc(vcpu, vcpu->arch.sie_block->ipa,
+ 				      vcpu->arch.sie_block->ipb);
+ 
+ 	return kvm_s390_inject_program_int(vcpu, PGM_OPERATION);
+ }
+ 
  int kvm_handle_sie_intercept(struct kvm_vcpu *vcpu)
  {
 -	if (kvm_is_ucontrol(vcpu->kvm))
 -		return -EOPNOTSUPP;
 +	intercept_handler_t func;
 +	u8 code = vcpu->arch.sie_block->icptcode;
  
++<<<<<<< HEAD
 +	if (code & 3 || (code >> 2) >= ARRAY_SIZE(intercept_funcs))
++=======
+ 	switch (vcpu->arch.sie_block->icptcode) {
+ 	case 0x10:
+ 	case 0x18:
+ 		return handle_noop(vcpu);
+ 	case 0x04:
+ 		return handle_instruction(vcpu);
+ 	case 0x08:
+ 		return handle_prog(vcpu);
+ 	case 0x14:
+ 		return handle_external_interrupt(vcpu);
+ 	case 0x1c:
+ 		return kvm_s390_handle_wait(vcpu);
+ 	case 0x20:
+ 		return handle_validity(vcpu);
+ 	case 0x28:
+ 		return handle_stop(vcpu);
+ 	case 0x2c:
+ 		return handle_operexc(vcpu);
+ 	case 0x38:
+ 		return handle_partial_execution(vcpu);
+ 	default:
++>>>>>>> a011eeb2a3d6 (KVM: s390: Add operation exception interception handler)
  		return -EOPNOTSUPP;
 -	}
 +	func = intercept_funcs[code >> 2];
 +	if (func)
 +		return func(vcpu);
 +	return -EOPNOTSUPP;
  }
* Unmerged path arch/s390/include/asm/kvm_host.h
* Unmerged path arch/s390/kvm/intercept.c
diff --git a/arch/s390/kvm/kvm-s390.c b/arch/s390/kvm/kvm-s390.c
index 9b2d6973d202..1abc3fe3f77e 100644
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@ -49,6 +49,7 @@ struct kvm_stats_debugfs_item debugfs_entries[] = {
 	{ "exit_instruction", VCPU_STAT(exit_instruction) },
 	{ "exit_program_interruption", VCPU_STAT(exit_program_interruption) },
 	{ "exit_instr_and_program_int", VCPU_STAT(exit_instr_and_program) },
+	{ "exit_operation_exception", VCPU_STAT(exit_operation_exception) },
 	{ "halt_successful_poll", VCPU_STAT(halt_successful_poll) },
 	{ "halt_attempted_poll", VCPU_STAT(halt_attempted_poll) },
 	{ "instruction_lctlg", VCPU_STAT(instruction_lctlg) },
diff --git a/arch/s390/kvm/trace.h b/arch/s390/kvm/trace.h
index 0c991c6748ab..a4689f592c65 100644
--- a/arch/s390/kvm/trace.h
+++ b/arch/s390/kvm/trace.h
@@ -336,6 +336,27 @@ TRACE_EVENT(kvm_s390_handle_stsi,
 			   __entry->addr)
 	);
 
+TRACE_EVENT(kvm_s390_handle_operexc,
+	    TP_PROTO(VCPU_PROTO_COMMON, __u16 ipa, __u32 ipb),
+	    TP_ARGS(VCPU_ARGS_COMMON, ipa, ipb),
+
+	    TP_STRUCT__entry(
+		    VCPU_FIELD_COMMON
+		    __field(__u64, instruction)
+		    ),
+
+	    TP_fast_assign(
+		    VCPU_ASSIGN_COMMON
+		    __entry->instruction = ((__u64)ipa << 48) |
+		    ((__u64)ipb << 16);
+		    ),
+
+	    VCPU_TP_PRINTK("operation exception on instruction %016llx (%s)",
+			   __entry->instruction,
+			   __print_symbolic(icpt_insn_decoder(__entry->instruction),
+					    icpt_insn_codes))
+	);
+
 #endif /* _TRACE_KVM_H */
 
 /* This part must be outside protection */
