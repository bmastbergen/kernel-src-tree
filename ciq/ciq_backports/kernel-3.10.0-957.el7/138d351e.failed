iscsi-target: Add login_keys_workaround attribute for non RFC initiators

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iscsi-target] Add login_keys_workaround attribute for non RFC initiators (Maurizio Lombardi) [1585081]
Rebuild_FUZZ: 89.23%
commit-author Nicholas Bellinger <nab@linux-iscsi.org>
commit 138d351eefb727ab9e41a3dc5f112ceb4f6e59f2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/138d351e.failed

This patch re-introduces part of a long standing login workaround that
was recently dropped by:

  commit 1c99de981f30b3e7868b8d20ce5479fa1c0fea46
  Author: Nicholas Bellinger <nab@linux-iscsi.org>
  Date:   Sun Apr 2 13:36:44 2017 -0700

      iscsi-target: Drop work-around for legacy GlobalSAN initiator

Namely, the workaround for FirstBurstLength ended up being required by
Mellanox Flexboot PXE boot ROMs as reported by Robert.

So this patch re-adds the work-around for FirstBurstLength within
iscsi_check_proposer_for_optional_reply(), and makes the key optional
to respond when the initiator does not propose, nor respond to it.

Also as requested by Arun, this patch introduces a new TPG attribute
named 'login_keys_workaround' that controls the use of both the
FirstBurstLength workaround, as well as the two other existing
workarounds for gPXE iSCSI boot client.

By default, the workaround is enabled with login_keys_workaround=1,
since Mellanox FlexBoot requires it, and Arun has verified the Qlogic
MSFT initiator already proposes FirstBurstLength, so it's uneffected
by this re-adding this part of the original work-around.

	Reported-by: Robert LeBlanc <robert@leblancnet.us>
	Cc: Robert LeBlanc <robert@leblancnet.us>
	Reviewed-by: Arun Easi <arun.easi@cavium.com>
	Cc: <stable@vger.kernel.org> # 3.1+
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 138d351eefb727ab9e41a3dc5f112ceb4f6e59f2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/iscsi/iscsi_target_parameters.c
#	drivers/target/iscsi/iscsi_target_tpg.c
diff --cc drivers/target/iscsi/iscsi_target_parameters.c
index 0efa80bb8962,caab1045742d..000000000000
--- a/drivers/target/iscsi/iscsi_target_parameters.c
+++ b/drivers/target/iscsi/iscsi_target_parameters.c
@@@ -781,27 -785,20 +785,44 @@@ static void iscsi_check_proposer_for_op
  	} else if (IS_TYPE_NUMBER(param)) {
  		if (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH))
  			SET_PSTATE_REPLY_OPTIONAL(param);
++<<<<<<< HEAD
 +		/*
 +		 * The GlobalSAN iSCSI Initiator for MacOSX does
 +		 * not respond to MaxBurstLength, FirstBurstLength,
 +		 * DefaultTime2Wait or DefaultTime2Retain parameter keys.
 +		 * So, we set them to 'reply optional' here, and assume the
 +		 * the defaults from iscsi_parameters.h if the initiator
 +		 * is not RFC compliant and the keys are not negotiated.
 +		 */
 +		if (!strcmp(param->name, MAXBURSTLENGTH))
 +			SET_PSTATE_REPLY_OPTIONAL(param);
 +		if (!strcmp(param->name, FIRSTBURSTLENGTH))
 +			SET_PSTATE_REPLY_OPTIONAL(param);
 +		if (!strcmp(param->name, DEFAULTTIME2WAIT))
 +			SET_PSTATE_REPLY_OPTIONAL(param);
 +		if (!strcmp(param->name, DEFAULTTIME2RETAIN))
 +			SET_PSTATE_REPLY_OPTIONAL(param);
 +		/*
 +		 * Required for gPXE iSCSI boot client
 +		 */
 +		if (!strcmp(param->name, MAXCONNECTIONS))
 +			SET_PSTATE_REPLY_OPTIONAL(param);
++=======
+ 
+ 		if (keys_workaround) {
+ 			/*
+ 			 * Required for Mellanox Flexboot PXE boot ROM
+ 			 */
+ 			if (!strcmp(param->name, FIRSTBURSTLENGTH))
+ 				SET_PSTATE_REPLY_OPTIONAL(param);
+ 
+ 			/*
+ 			 * Required for gPXE iSCSI boot client
+ 			 */
+ 			if (!strcmp(param->name, MAXCONNECTIONS))
+ 				SET_PSTATE_REPLY_OPTIONAL(param);
+ 		}
++>>>>>>> 138d351eefb7 (iscsi-target: Add login_keys_workaround attribute for non RFC initiators)
  	} else if (IS_PHASE_DECLARATIVE(param))
  		SET_PSTATE_REPLY_OPTIONAL(param);
  }
diff --cc drivers/target/iscsi/iscsi_target_tpg.c
index c9dd58828262,594d07a1e995..000000000000
--- a/drivers/target/iscsi/iscsi_target_tpg.c
+++ b/drivers/target/iscsi/iscsi_target_tpg.c
@@@ -878,20 -897,20 +879,37 @@@ int iscsit_ta_tpg_enabled_sendtargets
  	return 0;
  }
  
++<<<<<<< HEAD
 +int iscsit_ta_fabric_prot_type(
 +	struct iscsi_portal_group *tpg,
 +	u32 prot_type)
 +{
 +	struct iscsi_tpg_attrib *a = &tpg->tpg_attrib;
 +
 +	if ((prot_type != 0) && (prot_type != 1) && (prot_type != 3)) {
 +		pr_err("Illegal value for fabric_prot_type: %u\n", prot_type);
 +		return -EINVAL;
 +	}
 +
 +	a->fabric_prot_type = prot_type;
 +	pr_debug("iSCSI_TPG[%hu] - T10 Fabric Protection Type: %u\n",
 +		 tpg->tpgt, prot_type);
++=======
+ int iscsit_ta_login_keys_workaround(
+ 	struct iscsi_portal_group *tpg,
+ 	u32 flag)
+ {
+ 	struct iscsi_tpg_attrib *a = &tpg->tpg_attrib;
+ 
+ 	if ((flag != 0) && (flag != 1)) {
+ 		pr_err("Illegal value %d\n", flag);
+ 		return -EINVAL;
+ 	}
+ 
+ 	a->login_keys_workaround = flag;
+ 	pr_debug("iSCSI_TPG[%hu] - TPG enabled bit for login keys workaround: %s ",
+ 		tpg->tpgt, (a->login_keys_workaround) ? "ON" : "OFF");
++>>>>>>> 138d351eefb7 (iscsi-target: Add login_keys_workaround attribute for non RFC initiators)
  
  	return 0;
  }
diff --git a/drivers/target/iscsi/iscsi_target_configfs.c b/drivers/target/iscsi/iscsi_target_configfs.c
index 24fef2f84fba..6392b4a6f0eb 100644
--- a/drivers/target/iscsi/iscsi_target_configfs.c
+++ b/drivers/target/iscsi/iscsi_target_configfs.c
@@ -925,6 +925,7 @@ DEF_TPG_ATTRIB(default_erl);
 DEF_TPG_ATTRIB(t10_pi);
 DEF_TPG_ATTRIB(fabric_prot_type);
 DEF_TPG_ATTRIB(tpg_enabled_sendtargets);
+DEF_TPG_ATTRIB(login_keys_workaround);
 
 static struct configfs_attribute *lio_target_tpg_attrib_attrs[] = {
 	&iscsi_tpg_attrib_attr_authentication,
@@ -940,6 +941,7 @@ static struct configfs_attribute *lio_target_tpg_attrib_attrs[] = {
 	&iscsi_tpg_attrib_attr_t10_pi,
 	&iscsi_tpg_attrib_attr_fabric_prot_type,
 	&iscsi_tpg_attrib_attr_tpg_enabled_sendtargets,
+	&iscsi_tpg_attrib_attr_login_keys_workaround,
 	NULL,
 };
 
diff --git a/drivers/target/iscsi/iscsi_target_nego.c b/drivers/target/iscsi/iscsi_target_nego.c
index 7c5ffdba6e7f..9123049413f0 100644
--- a/drivers/target/iscsi/iscsi_target_nego.c
+++ b/drivers/target/iscsi/iscsi_target_nego.c
@@ -883,7 +883,8 @@ static int iscsi_target_handle_csg_zero(
 			SENDER_TARGET,
 			login->rsp_buf,
 			&login->rsp_length,
-			conn->param_list);
+			conn->param_list,
+			conn->tpg->tpg_attrib.login_keys_workaround);
 	if (ret < 0)
 		return -1;
 
@@ -953,7 +954,8 @@ static int iscsi_target_handle_csg_one(struct iscsi_conn *conn, struct iscsi_log
 			SENDER_TARGET,
 			login->rsp_buf,
 			&login->rsp_length,
-			conn->param_list);
+			conn->param_list,
+			conn->tpg->tpg_attrib.login_keys_workaround);
 	if (ret < 0) {
 		iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,
 				ISCSI_LOGIN_STATUS_INIT_ERR);
* Unmerged path drivers/target/iscsi/iscsi_target_parameters.c
diff --git a/drivers/target/iscsi/iscsi_target_parameters.h b/drivers/target/iscsi/iscsi_target_parameters.h
index a0751e3f0813..17a58c2913f2 100644
--- a/drivers/target/iscsi/iscsi_target_parameters.h
+++ b/drivers/target/iscsi/iscsi_target_parameters.h
@@ -40,7 +40,7 @@ extern int iscsi_extract_key_value(char *, char **, char **);
 extern int iscsi_update_param_value(struct iscsi_param *, char *);
 extern int iscsi_decode_text_input(u8, u8, char *, u32, struct iscsi_conn *);
 extern int iscsi_encode_text_output(u8, u8, char *, u32 *,
-			struct iscsi_param_list *);
+			struct iscsi_param_list *, bool);
 extern int iscsi_check_negotiated_keys(struct iscsi_param_list *);
 extern void iscsi_set_connection_parameters(struct iscsi_conn_ops *,
 			struct iscsi_param_list *);
* Unmerged path drivers/target/iscsi/iscsi_target_tpg.c
diff --git a/drivers/target/iscsi/iscsi_target_tpg.h b/drivers/target/iscsi/iscsi_target_tpg.h
index 2da211920c18..901a712180f0 100644
--- a/drivers/target/iscsi/iscsi_target_tpg.h
+++ b/drivers/target/iscsi/iscsi_target_tpg.h
@@ -39,5 +39,6 @@ extern int iscsit_ta_default_erl(struct iscsi_portal_group *, u32);
 extern int iscsit_ta_t10_pi(struct iscsi_portal_group *, u32);
 extern int iscsit_ta_fabric_prot_type(struct iscsi_portal_group *, u32);
 extern int iscsit_ta_tpg_enabled_sendtargets(struct iscsi_portal_group *, u32);
+extern int iscsit_ta_login_keys_workaround(struct iscsi_portal_group *, u32);
 
 #endif /* ISCSI_TARGET_TPG_H */
diff --git a/include/target/iscsi/iscsi_target_core.h b/include/target/iscsi/iscsi_target_core.h
index a3b6d1d44961..f35f2df43f4a 100644
--- a/include/target/iscsi/iscsi_target_core.h
+++ b/include/target/iscsi/iscsi_target_core.h
@@ -65,6 +65,14 @@
 #define TA_DEFAULT_FABRIC_PROT_TYPE     0
 /* TPG status needs to be enabled to return sendtargets discovery endpoint info */
 #define TA_DEFAULT_TPG_ENABLED_SENDTARGETS 1
+/*
+ * Used to control the sending of keys with optional to respond state bit,
+ * as a workaround for non RFC compliant initiators,that do not propose,
+ * nor respond to specific keys required for login to complete.
+ *
+ * See iscsi_check_proposer_for_optional_reply() for more details.
+ */
+#define TA_DEFAULT_LOGIN_KEYS_WORKAROUND 1
 
 #define ISCSI_IOV_DATA_BUFFER		5
 
@@ -768,6 +776,7 @@ struct iscsi_tpg_attrib {
 	u8			t10_pi;
 	u32                     fabric_prot_type;
 	u32			tpg_enabled_sendtargets;
+	u32			login_keys_workaround;
 	struct iscsi_portal_group *tpg;
 };
 
