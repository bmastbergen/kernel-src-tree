e1000e: Fix queue interrupt re-raising in Other interrupt

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Benjamin Poirier <bpoirier@suse.com>
commit 361a954e6a7215de11a6179ad9bdc07d7e394b04
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/361a954e.failed

Restores the ICS write for Rx/Tx queue interrupts which was present before
commit 16ecba59bc33 ("e1000e: Do not read ICR in Other interrupt", v4.5-rc1)
but was not restored in commit 4aea7a5c5e94
("e1000e: Avoid receiver overrun interrupt bursts", v4.15-rc1).

This re-raises the queue interrupts in case the txq or rxq bits were set in
ICR and the Other interrupt handler read and cleared ICR before the queue
interrupt was raised.

Fixes: 4aea7a5c5e94 ("e1000e: Avoid receiver overrun interrupt bursts")
	Signed-off-by: Benjamin Poirier <bpoirier@suse.com>
	Acked-by: Alexander Duyck <alexander.h.duyck@intel.com>
	Tested-by: Aaron Brown <aaron.f.brown@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 361a954e6a7215de11a6179ad9bdc07d7e394b04)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/e1000e/netdev.c
diff --cc drivers/net/ethernet/intel/e1000e/netdev.c
index b81ce07a75e5,2c9609bee2ae..000000000000
--- a/drivers/net/ethernet/intel/e1000e/netdev.c
+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
@@@ -1913,14 -1914,24 +1913,29 @@@ static irqreturn_t e1000_msix_other(in
  	struct net_device *netdev = data;
  	struct e1000_adapter *adapter = netdev_priv(netdev);
  	struct e1000_hw *hw = &adapter->hw;
 -	u32 icr;
  
 -	icr = er32(ICR);
 -	ew32(ICR, E1000_ICR_OTHER);
 +	hw->mac.get_link_status = true;
  
++<<<<<<< HEAD
 +	/* guard against interrupt when we're going down */
 +	if (!test_bit(__E1000_DOWN, &adapter->state)) {
 +		mod_timer(&adapter->watchdog_timer, jiffies + 1);
++=======
+ 	if (icr & adapter->eiac_mask)
+ 		ew32(ICS, (icr & adapter->eiac_mask));
+ 
+ 	if (icr & E1000_ICR_LSC) {
+ 		ew32(ICR, E1000_ICR_LSC);
+ 		hw->mac.get_link_status = true;
+ 		/* guard against interrupt when we're going down */
+ 		if (!test_bit(__E1000_DOWN, &adapter->state))
+ 			mod_timer(&adapter->watchdog_timer, jiffies + 1);
+ 	}
+ 
+ 	if (!test_bit(__E1000_DOWN, &adapter->state))
++>>>>>>> 361a954e6a72 (e1000e: Fix queue interrupt re-raising in Other interrupt)
  		ew32(IMS, E1000_IMS_OTHER);
 +	}
  
  	return IRQ_HANDLED;
  }
* Unmerged path drivers/net/ethernet/intel/e1000e/netdev.c
