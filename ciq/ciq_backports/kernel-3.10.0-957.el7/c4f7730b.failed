nfp: bpf: round up the size of the stack

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit c4f7730be580f8c39decc058246a83ddf7d7b3cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c4f7730b.failed

Kernel enforces the alignment of the bottom of the stack, NFP
deals with positive offsets better so we should align the top
of the stack.  Round the stack size to NFP word size (4B).

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit c4f7730be580f8c39decc058246a83ddf7d7b3cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/bpf/offload.c
diff --cc drivers/net/ethernet/netronome/nfp/bpf/offload.c
index de79faf0874b,8dbf13450bab..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/offload.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/offload.c
@@@ -129,40 -143,41 +129,46 @@@ nfp_net_bpf_get_act(struct nfp_net *nn
  		return -EOPNOTSUPP;
  	}
  
++<<<<<<< HEAD
 +	/* TC legacy mode */
 +	if (!tc_single_action(cls_bpf->exts))
 +		return -EOPNOTSUPP;
++=======
+ 	nfp_prog->stack_depth = round_up(prog->aux->stack_depth, 4);
+ 	nfp_prog->start_off = nn_readw(nn, NFP_NET_CFG_BPF_START);
+ 	nfp_prog->tgt_done = nn_readw(nn, NFP_NET_CFG_BPF_DONE);
++>>>>>>> c4f7730be580 (nfp: bpf: round up the size of the stack)
  
 -	max_instr = nn_readw(nn, NFP_NET_CFG_BPF_MAX_LEN);
 -	nfp_prog->__prog_alloc_len = max_instr * sizeof(u64);
 -
 -	nfp_prog->prog = kmalloc(nfp_prog->__prog_alloc_len, GFP_KERNEL);
 -	if (!nfp_prog->prog)
 -		return -ENOMEM;
 -
 -	return nfp_bpf_jit(nfp_prog);
 -}
 -
 -int nfp_bpf_destroy(struct nfp_app *app, struct nfp_net *nn,
 -		    struct bpf_prog *prog)
 -{
 -	struct nfp_prog *nfp_prog = prog->aux->offload->dev_priv;
 +	tcf_exts_to_list(cls_bpf->exts, &actions);
 +	list_for_each_entry(a, &actions, list) {
 +		if (is_tcf_gact_shot(a))
 +			return NN_ACT_TC_DROP;
  
 -	kfree(nfp_prog->prog);
 -	nfp_prog_free(nfp_prog);
 +		if (is_tcf_mirred_egress_redirect(a) &&
 +		    tcf_mirred_ifindex(a) == nn->dp.netdev->ifindex)
 +			return NN_ACT_TC_REDIR;
 +	}
  
 -	return 0;
 +	return -EOPNOTSUPP;
  }
  
 -static int nfp_net_bpf_load(struct nfp_net *nn, struct bpf_prog *prog)
 +static int
 +nfp_net_bpf_offload_prepare(struct nfp_net *nn,
 +			    struct tc_cls_bpf_offload *cls_bpf,
 +			    struct nfp_bpf_result *res,
 +			    void **code, dma_addr_t *dma_addr, u16 max_instr)
  {
 -	struct nfp_prog *nfp_prog = prog->aux->offload->dev_priv;
 +	unsigned int code_sz = max_instr * sizeof(u64);
 +	enum nfp_bpf_action_type act;
 +	unsigned int stack_size;
 +	u16 start_off, done_off;
  	unsigned int max_mtu;
 -	dma_addr_t dma_addr;
 -	int err;
 +	int ret;
 +
 +	ret = nfp_net_bpf_get_act(nn, cls_bpf);
 +	if (ret < 0)
 +		return ret;
 +	act = ret;
  
  	max_mtu = nn_readb(nn, NFP_NET_CFG_BPF_INL_MTU) * 64 - 32;
  	if (max_mtu < nn->dp.netdev->mtu) {
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/offload.c
