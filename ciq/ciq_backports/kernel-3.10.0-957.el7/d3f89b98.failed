nfp: bpf: keep track of the offloaded program

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit d3f89b98e391475419ae2d8834813d3ecbb48f67
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d3f89b98.failed

After TC offloads were converted to callbacks we have no choice
but keep track of the offloaded filter in the driver.

The check for nn->dp.bpf_offload_xdp was a stop gap solution
to make sure failed TC offload won't disable XDP, it's no longer
necessary.  nfp_net_bpf_offload() will return -EBUSY on
TC vs XDP conflicts.

Fixes: 3f7889c4c79b ("net: sched: cls_bpf: call block callbacks for offload")
	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d3f89b98e391475419ae2d8834813d3ecbb48f67)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/bpf/main.c
#	drivers/net/ethernet/netronome/nfp/bpf/main.h
diff --cc drivers/net/ethernet/netronome/nfp/bpf/main.c
index 4ca14182b178,13190aa09faf..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/main.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/main.c
@@@ -88,30 -85,97 +88,121 @@@ static const char *nfp_bpf_extra_cap(st
  static int
  nfp_bpf_vnic_alloc(struct nfp_app *app, struct nfp_net *nn, unsigned int id)
  {
++<<<<<<< HEAD
 +	struct nfp_net_bpf_priv *priv;
 +	int ret;
 +
 +	priv = kmalloc(sizeof(*priv), GFP_KERNEL);
 +	if (!priv)
 +		return -ENOMEM;
 +
 +	nn->app_priv = priv;
 +	spin_lock_init(&priv->rx_filter_lock);
 +	setup_timer(&priv->rx_filter_stats_timer,
 +		    nfp_net_filter_stats_timer, (unsigned long)nn);
 +
 +	ret = nfp_app_nic_vnic_alloc(app, nn, id);
 +	if (ret)
 +		kfree(priv);
 +
 +	return ret;
++=======
+ 	int err;
+ 
+ 	nn->app_priv = kzalloc(sizeof(struct nfp_bpf_vnic), GFP_KERNEL);
+ 	if (!nn->app_priv)
+ 		return -ENOMEM;
+ 
+ 	err = nfp_app_nic_vnic_alloc(app, nn, id);
+ 	if (err)
+ 		goto err_free_priv;
+ 
+ 	return 0;
+ err_free_priv:
+ 	kfree(nn->app_priv);
+ 	return err;
++>>>>>>> d3f89b98e391 (nfp: bpf: keep track of the offloaded program)
  }
  
  static void nfp_bpf_vnic_free(struct nfp_app *app, struct nfp_net *nn)
  {
+ 	struct nfp_bpf_vnic *bv = nn->app_priv;
+ 
  	if (nn->dp.bpf_offload_xdp)
  		nfp_bpf_xdp_offload(app, nn, NULL);
++<<<<<<< HEAD
 +	kfree(nn->app_priv);
++=======
+ 	WARN_ON(bv->tc_prog);
+ 	kfree(bv);
+ }
+ 
+ static int nfp_bpf_setup_tc_block_cb(enum tc_setup_type type,
+ 				     void *type_data, void *cb_priv)
+ {
+ 	struct tc_cls_bpf_offload *cls_bpf = type_data;
+ 	struct nfp_net *nn = cb_priv;
+ 	struct bpf_prog *oldprog;
+ 	struct nfp_bpf_vnic *bv;
+ 	int err;
+ 
+ 	if (type != TC_SETUP_CLSBPF ||
+ 	    !tc_can_offload(nn->dp.netdev) ||
+ 	    !nfp_net_ebpf_capable(nn) ||
+ 	    cls_bpf->common.protocol != htons(ETH_P_ALL) ||
+ 	    cls_bpf->common.chain_index)
+ 		return -EOPNOTSUPP;
+ 
+ 	/* Only support TC direct action */
+ 	if (!cls_bpf->exts_integrated ||
+ 	    tcf_exts_has_actions(cls_bpf->exts)) {
+ 		nn_err(nn, "only direct action with no legacy actions supported\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (cls_bpf->command != TC_CLSBPF_OFFLOAD)
+ 		return -EOPNOTSUPP;
+ 
+ 	bv = nn->app_priv;
+ 	oldprog = cls_bpf->oldprog;
+ 
+ 	/* Don't remove if oldprog doesn't match driver's state */
+ 	if (bv->tc_prog != oldprog) {
+ 		oldprog = NULL;
+ 		if (!cls_bpf->prog)
+ 			return 0;
+ 	}
+ 
+ 	err = nfp_net_bpf_offload(nn, cls_bpf->prog, oldprog);
+ 	if (err)
+ 		return err;
+ 
+ 	bv->tc_prog = cls_bpf->prog;
+ 	return 0;
+ }
+ 
+ static int nfp_bpf_setup_tc_block(struct net_device *netdev,
+ 				  struct tc_block_offload *f)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 
+ 	if (f->binder_type != TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (f->command) {
+ 	case TC_BLOCK_BIND:
+ 		return tcf_block_cb_register(f->block,
+ 					     nfp_bpf_setup_tc_block_cb,
+ 					     nn, nn);
+ 	case TC_BLOCK_UNBIND:
+ 		tcf_block_cb_unregister(f->block,
+ 					nfp_bpf_setup_tc_block_cb,
+ 					nn);
+ 		return 0;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
++>>>>>>> d3f89b98e391 (nfp: bpf: keep track of the offloaded program)
  }
  
  static int nfp_bpf_setup_tc(struct nfp_app *app, struct net_device *netdev,
diff --cc drivers/net/ethernet/netronome/nfp/bpf/main.h
index cc2a5beba757,57b6043177a3..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/main.h
+++ b/drivers/net/ethernet/netronome/nfp/bpf/main.h
@@@ -181,37 -172,29 +181,49 @@@ struct nfp_prog 
  	struct list_head insns;
  };
  
++<<<<<<< HEAD
 +struct nfp_bpf_result {
 +	unsigned int n_instr;
 +	bool dense_mode;
 +};
++=======
+ /**
+  * struct nfp_bpf_vnic - per-vNIC BPF priv structure
+  * @tc_prog:	currently loaded cls_bpf program
+  */
+ struct nfp_bpf_vnic {
+ 	struct bpf_prog *tc_prog;
+ };
+ 
+ int nfp_bpf_jit(struct nfp_prog *prog);
++>>>>>>> d3f89b98e391 (nfp: bpf: keep track of the offloaded program)
 +
 +int
 +nfp_bpf_jit(struct bpf_prog *filter, void *prog, enum nfp_bpf_action_type act,
 +	    unsigned int prog_start, unsigned int prog_done,
 +	    unsigned int prog_sz, struct nfp_bpf_result *res);
  
 -extern const struct bpf_ext_analyzer_ops nfp_bpf_analyzer_ops;
 +int nfp_prog_verify(struct nfp_prog *nfp_prog, struct bpf_prog *prog);
  
 -struct netdev_bpf;
 -struct nfp_app;
  struct nfp_net;
 +struct tc_cls_bpf_offload;
 +
 +/**
 + * struct nfp_net_bpf_priv - per-vNIC BPF private data
 + * @rx_filter:		Filter offload statistics - dropped packets/bytes
 + * @rx_filter_prev:	Filter offload statistics - values from previous update
 + * @rx_filter_change:	Jiffies when statistics last changed
 + * @rx_filter_stats_timer:  Timer for polling filter offload statistics
 + * @rx_filter_lock:	Lock protecting timer state changes (teardown)
 + */
 +struct nfp_net_bpf_priv {
 +	struct nfp_stat_pair rx_filter, rx_filter_prev;
 +	unsigned long rx_filter_change;
 +	struct timer_list rx_filter_stats_timer;
 +	spinlock_t rx_filter_lock;
 +};
  
 -int nfp_net_bpf_offload(struct nfp_net *nn, struct bpf_prog *prog,
 -			bool old_prog);
 +int nfp_net_bpf_offload(struct nfp_net *nn, struct tc_cls_bpf_offload *cls_bpf);
 +void nfp_net_filter_stats_timer(unsigned long data);
  
 -int nfp_bpf_verifier_prep(struct nfp_app *app, struct nfp_net *nn,
 -			  struct netdev_bpf *bpf);
 -int nfp_bpf_translate(struct nfp_app *app, struct nfp_net *nn,
 -		      struct bpf_prog *prog);
 -int nfp_bpf_destroy(struct nfp_app *app, struct nfp_net *nn,
 -		    struct bpf_prog *prog);
  #endif
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/main.h
