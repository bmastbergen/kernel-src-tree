mmc: core: Export API to allow hosts to get the card address

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] core: Export API to allow hosts to get the card address (Gopal Tiwari) [1549495]
Rebuild_FUZZ: 95.65%
commit-author Ulf Hansson <ulf.hansson@linaro.org>
commit 33e6d74d65c358270f00d228877178964aab84b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/33e6d74d.failed

Some hosts controllers, like Cavium, needs to know whether the card
operates in byte- or block-address mode. Therefore export a new API,
mmc_card_is_blockaddr(), which provides this information.

	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Signed-off-by: Steven J. Hill <Steven.Hill@cavium.com>
	Acked-by: David Daney <david.daney@cavium.com>
(cherry picked from commit 33e6d74d65c358270f00d228877178964aab84b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mmc/card.h
diff --cc include/linux/mmc/card.h
index e3f1031064a7,aad015e0152b..000000000000
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@@ -332,109 -315,7 +332,113 @@@ static inline bool mmc_large_sector(str
  	return card->ext_csd.data_sector_size == 4096;
  }
  
++<<<<<<< HEAD
 +/*
 + *  The world is not perfect and supplies us with broken mmc/sdio devices.
 + *  For at least some of these bugs we need a work-around.
 + */
 +
 +struct mmc_fixup {
 +	/* CID-specific fields. */
 +	const char *name;
 +
 +	/* Valid revision range */
 +	u64 rev_start, rev_end;
 +
 +	unsigned int manfid;
 +	unsigned short oemid;
 +
 +	/* SDIO-specfic fields. You can use SDIO_ANY_ID here of course */
 +	u16 cis_vendor, cis_device;
 +
 +	/* for MMC cards */
 +	unsigned int ext_csd_rev;
 +
 +	void (*vendor_fixup)(struct mmc_card *card, int data);
 +	int data;
 +};
 +
 +#define CID_MANFID_ANY (-1u)
 +#define CID_OEMID_ANY ((unsigned short) -1)
 +#define CID_NAME_ANY (NULL)
 +
 +#define EXT_CSD_REV_ANY (-1u)
 +
 +#define CID_MANFID_SANDISK      0x2
 +#define CID_MANFID_TOSHIBA      0x11
 +#define CID_MANFID_MICRON       0x13
 +#define CID_MANFID_SAMSUNG      0x15
 +#define CID_MANFID_KINGSTON     0x70
 +#define CID_MANFID_HYNIX	0x90
 +
 +#define END_FIXUP { NULL }
 +
 +#define _FIXUP_EXT(_name, _manfid, _oemid, _rev_start, _rev_end,	\
 +		   _cis_vendor, _cis_device,				\
 +		   _fixup, _data, _ext_csd_rev)				\
 +	{						   \
 +		.name = (_name),			   \
 +		.manfid = (_manfid),			   \
 +		.oemid = (_oemid),			   \
 +		.rev_start = (_rev_start),		   \
 +		.rev_end = (_rev_end),			   \
 +		.cis_vendor = (_cis_vendor),		   \
 +		.cis_device = (_cis_device),		   \
 +		.vendor_fixup = (_fixup),		   \
 +		.data = (_data),			   \
 +		.ext_csd_rev = (_ext_csd_rev),		   \
 +	 }
 +
 +#define MMC_FIXUP_REV(_name, _manfid, _oemid, _rev_start, _rev_end,	\
 +		      _fixup, _data, _ext_csd_rev)			\
 +	_FIXUP_EXT(_name, _manfid,					\
 +		   _oemid, _rev_start, _rev_end,			\
 +		   SDIO_ANY_ID, SDIO_ANY_ID,				\
 +		   _fixup, _data, _ext_csd_rev)				\
 +
 +#define MMC_FIXUP(_name, _manfid, _oemid, _fixup, _data) \
 +	MMC_FIXUP_REV(_name, _manfid, _oemid, 0, -1ull, _fixup, _data,	\
 +		      EXT_CSD_REV_ANY)
 +
 +#define MMC_FIXUP_EXT_CSD_REV(_name, _manfid, _oemid, _fixup, _data,	\
 +			      _ext_csd_rev)				\
 +	MMC_FIXUP_REV(_name, _manfid, _oemid, 0, -1ull, _fixup, _data,	\
 +		      _ext_csd_rev)
 +
 +#define SDIO_FIXUP(_vendor, _device, _fixup, _data)			\
 +	_FIXUP_EXT(CID_NAME_ANY, CID_MANFID_ANY,			\
 +		    CID_OEMID_ANY, 0, -1ull,				\
 +		   _vendor, _device,					\
 +		   _fixup, _data, EXT_CSD_REV_ANY)			\
 +
 +#define cid_rev(hwrev, fwrev, year, month)	\
 +	(((u64) hwrev) << 40 |                  \
 +	 ((u64) fwrev) << 32 |                  \
 +	 ((u64) year) << 16 |                   \
 +	 ((u64) month))
 +
 +#define cid_rev_card(card)		  \
 +	cid_rev(card->cid.hwrev,	  \
 +		    card->cid.fwrev,      \
 +		    card->cid.year,	  \
 +		    card->cid.month)
 +
 +/*
 + * Unconditionally quirk add/remove.
 + */
 +
 +static inline void __maybe_unused add_quirk(struct mmc_card *card, int data)
 +{
 +	card->quirks |= data;
 +}
 +
 +static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 +{
 +	card->quirks &= ~data;
 +}
++=======
+ bool mmc_card_is_blockaddr(struct mmc_card *card);
++>>>>>>> 33e6d74d65c3 (mmc: core: Export API to allow hosts to get the card address)
  
  #define mmc_card_mmc(c)		((c)->type == MMC_TYPE_MMC)
  #define mmc_card_sd(c)		((c)->type == MMC_TYPE_SD)
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 5e2ff759d808..8be559876f62 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2565,6 +2565,12 @@ unsigned int mmc_calc_max_discard(struct mmc_card *card)
 }
 EXPORT_SYMBOL(mmc_calc_max_discard);
 
+bool mmc_card_is_blockaddr(struct mmc_card *card)
+{
+	return card ? mmc_card_blockaddr(card) : false;
+}
+EXPORT_SYMBOL(mmc_card_is_blockaddr);
+
 int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
 {
 	struct mmc_command cmd = {};
* Unmerged path include/linux/mmc/card.h
