mmc: block: rename rqc and req

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] block: rename rqc and req (Gopal Tiwari) [1549495]
Rebuild_FUZZ: 90.91%
commit-author Linus Walleij <linus.walleij@linaro.org>
commit acd8dbd64a2adcd950c31261247cda6f847f57eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/acd8dbd6.failed

In the function mmc_blk_issue_rw_rq() the new request coming in
from the block layer is called "rqc" and the old request that
was potentially just returned back from the asynchronous
mechanism is called "req".

This is really confusing when trying to analyze and understand
the code, it becomes a perceptual nightmare to me. Maybe others
have better parserheads but it is not working for me.

Rename "rqc" to "new_req" and "req" to "old_req" to reflect what
is semantically going on into the syntax.

	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit acd8dbd64a2adcd950c31261247cda6f847f57eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/block.c
diff --cc drivers/mmc/core/block.c
index d7cc8dd6684d,2b9ae44f72f9..000000000000
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@@ -1586,7 -1587,34 +1586,38 @@@ static int mmc_blk_cmd_err(struct mmc_b
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)
++=======
+ static void mmc_blk_rw_cmd_abort(struct mmc_card *card, struct request *req)
+ {
+ 	int ret = 1;
+ 
+ 	if (mmc_card_removed(card))
+ 		req->rq_flags |= RQF_QUIET;
+ 	while (ret)
+ 		ret = blk_end_request(req, -EIO,
+ 				      blk_rq_cur_bytes(req));
+ }
+ 
+ static void mmc_blk_rw_start_new(struct mmc_queue *mq, struct mmc_card *card,
+ 				 struct request *req)
+ {
+ 	if (!req)
+ 		return;
+ 
+ 	if (mmc_card_removed(card)) {
+ 		req->rq_flags |= RQF_QUIET;
+ 		blk_end_request_all(req, -EIO);
+ 	} else {
+ 		mmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);
+ 		mmc_start_req(card->host,
+ 			      &mq->mqrq_cur->mmc_active, NULL);
+ 	}
+ }
+ 
+ static void mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *new_req)
++>>>>>>> acd8dbd64a2a (mmc: block: rename rqc and req)
  {
  	struct mmc_blk_data *md = mq->blkdata;
  	struct mmc_card *card = md->queue.card;
@@@ -1598,21 -1626,21 +1629,32 @@@
  	struct mmc_async_req *new_areq;
  	struct mmc_async_req *old_areq;
  
++<<<<<<< HEAD
 +	if (!rqc && !mq->mqrq_prev->req)
 +		return 0;
++=======
+ 	if (!new_req && !mq->mqrq_prev->req)
+ 		return;
++>>>>>>> acd8dbd64a2a (mmc: block: rename rqc and req)
  
  	do {
- 		if (rqc) {
+ 		if (new_req) {
  			/*
  			 * When 4KB native sector is enabled, only 8 blocks
  			 * multiple read or write is allowed
  			 */
  			if (mmc_large_sector(card) &&
- 				!IS_ALIGNED(blk_rq_sectors(rqc), 8)) {
+ 				!IS_ALIGNED(blk_rq_sectors(new_req), 8)) {
  				pr_err("%s: Transfer size is not 4KB sector size aligned\n",
++<<<<<<< HEAD
 +					rqc->rq_disk->disk_name);
 +				mmc_blk_rw_cmd_abort(card, rqc);
 +				return 0;
++=======
+ 					new_req->rq_disk->disk_name);
+ 				mmc_blk_rw_cmd_abort(card, new_req);
+ 				return;
++>>>>>>> acd8dbd64a2a (mmc: block: rename rqc and req)
  			}
  
  			mmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);
@@@ -1660,18 -1688,23 +1702,36 @@@
  			 */
  			if (status == MMC_BLK_SUCCESS && ret) {
  				pr_err("%s BUG rq_tot %d d_xfer %d\n",
- 				       __func__, blk_rq_bytes(req),
+ 				       __func__, blk_rq_bytes(old_req),
  				       brq->data.bytes_xfered);
++<<<<<<< HEAD
 +				mmc_blk_rw_cmd_abort(card, req);
 +				return 0;
 +			}
 +			break;
 +		case MMC_BLK_CMD_ERR:
 +			ret = mmc_blk_cmd_err(md, card, brq, req, ret);
 +			if (mmc_blk_reset(md, card->host, type))
 +				goto cmd_abort;
 +			if (!ret)
 +				goto start_new_req;
++=======
+ 				mmc_blk_rw_cmd_abort(card, old_req);
+ 				return;
+ 			}
+ 			break;
+ 		case MMC_BLK_CMD_ERR:
+ 			ret = mmc_blk_cmd_err(md, card, brq, old_req, ret);
+ 			if (mmc_blk_reset(md, card->host, type)) {
+ 				mmc_blk_rw_cmd_abort(card, old_req);
+ 				mmc_blk_rw_start_new(mq, card, new_req);
+ 				return;
+ 			}
+ 			if (!ret) {
+ 				mmc_blk_rw_start_new(mq, card, new_req);
+ 				return;
+ 			}
++>>>>>>> acd8dbd64a2a (mmc: block: rename rqc and req)
  			break;
  		case MMC_BLK_RETRY:
  			retune_retry_done = brq->retune_retry_done;
@@@ -1681,15 -1714,20 +1741,29 @@@
  		case MMC_BLK_ABORT:
  			if (!mmc_blk_reset(md, card->host, type))
  				break;
++<<<<<<< HEAD
 +			goto cmd_abort;
++=======
+ 			mmc_blk_rw_cmd_abort(card, old_req);
+ 			mmc_blk_rw_start_new(mq, card, new_req);
+ 			return;
++>>>>>>> acd8dbd64a2a (mmc: block: rename rqc and req)
  		case MMC_BLK_DATA_ERR: {
  			int err;
  
  			err = mmc_blk_reset(md, card->host, type);
  			if (!err)
  				break;
++<<<<<<< HEAD
 +			if (err == -ENODEV)
 +				goto cmd_abort;
++=======
+ 			if (err == -ENODEV) {
+ 				mmc_blk_rw_cmd_abort(card, old_req);
+ 				mmc_blk_rw_start_new(mq, card, new_req);
+ 				return;
+ 			}
++>>>>>>> acd8dbd64a2a (mmc: block: rename rqc and req)
  			/* Fall through */
  		}
  		case MMC_BLK_ECC_ERR:
@@@ -1705,17 -1743,23 +1779,35 @@@
  			 * time, so we only reach here after trying to
  			 * read a single sector.
  			 */
- 			ret = blk_end_request(req, -EIO,
+ 			ret = blk_end_request(old_req, -EIO,
  						brq->data.blksz);
++<<<<<<< HEAD
 +			if (!ret)
 +				goto start_new_req;
 +			break;
 +		case MMC_BLK_NOMEDIUM:
 +			goto cmd_abort;
 +		default:
 +			pr_err("%s: Unhandled return value (%d)",
 +					req->rq_disk->disk_name, status);
 +			goto cmd_abort;
++=======
+ 			if (!ret) {
+ 				mmc_blk_rw_start_new(mq, card, new_req);
+ 				return;
+ 			}
+ 			break;
+ 		case MMC_BLK_NOMEDIUM:
+ 			mmc_blk_rw_cmd_abort(card, old_req);
+ 			mmc_blk_rw_start_new(mq, card, new_req);
+ 			return;
+ 		default:
+ 			pr_err("%s: Unhandled return value (%d)",
+ 					old_req->rq_disk->disk_name, status);
+ 			mmc_blk_rw_cmd_abort(card, old_req);
+ 			mmc_blk_rw_start_new(mq, card, new_req);
+ 			return;
++>>>>>>> acd8dbd64a2a (mmc: block: rename rqc and req)
  		}
  
  		if (ret) {
* Unmerged path drivers/mmc/core/block.c
