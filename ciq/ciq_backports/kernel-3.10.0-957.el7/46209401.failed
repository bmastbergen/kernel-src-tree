net: core: introduce mini_Qdisc and eliminate usage of tp->q for clsact fastpath

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] core: introduce mini_Qdisc and eliminate usage of tp->q for clsact fastpath (Ivan Vecera) [1572720]
Rebuild_FUZZ: 96.77%
commit-author Jiri Pirko <jiri@mellanox.com>
commit 46209401f8f6116bd0b2c2d14a63958e83ffca0b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/46209401.failed

In sch_handle_egress and sch_handle_ingress tp->q is used only in order
to update stats. So stats and filter list are the only things that are
needed in clsact qdisc fastpath processing. Introduce new mini_Qdisc
struct to hold those items. Also, introduce a helper to swap the
mini_Qdisc structures in case filter list head changes.

This removes need for tp->q usage without added overhead.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 46209401f8f6116bd0b2c2d14a63958e83ffca0b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	net/core/dev.c
#	net/sched/sch_ingress.c
diff --cc include/linux/netdevice.h
index fe1a249a50cb,7de7656550c2..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1611,6 -1431,207 +1611,210 @@@ enum netdev_priv_flags 
   *	data with strictly "high-level" data, and it has to know about
   *	almost every data structure used in the INET module.
   *
++<<<<<<< HEAD
++=======
+  *	@name:	This is the first field of the "visible" part of this structure
+  *		(i.e. as seen by users in the "Space.c" file).  It is the name
+  *		of the interface.
+  *
+  *	@name_hlist: 	Device name hash chain, please keep it close to name[]
+  *	@ifalias:	SNMP alias
+  *	@mem_end:	Shared memory end
+  *	@mem_start:	Shared memory start
+  *	@base_addr:	Device I/O address
+  *	@irq:		Device IRQ number
+  *
+  *	@carrier_changes:	Stats to monitor carrier on<->off transitions
+  *
+  *	@state:		Generic network queuing layer state, see netdev_state_t
+  *	@dev_list:	The global list of network devices
+  *	@napi_list:	List entry used for polling NAPI devices
+  *	@unreg_list:	List entry  when we are unregistering the
+  *			device; see the function unregister_netdev
+  *	@close_list:	List entry used when we are closing the device
+  *	@ptype_all:     Device-specific packet handlers for all protocols
+  *	@ptype_specific: Device-specific, protocol-specific packet handlers
+  *
+  *	@adj_list:	Directly linked devices, like slaves for bonding
+  *	@features:	Currently active device features
+  *	@hw_features:	User-changeable features
+  *
+  *	@wanted_features:	User-requested features
+  *	@vlan_features:		Mask of features inheritable by VLAN devices
+  *
+  *	@hw_enc_features:	Mask of features inherited by encapsulating devices
+  *				This field indicates what encapsulation
+  *				offloads the hardware is capable of doing,
+  *				and drivers will need to set them appropriately.
+  *
+  *	@mpls_features:	Mask of features inheritable by MPLS
+  *
+  *	@ifindex:	interface index
+  *	@group:		The group the device belongs to
+  *
+  *	@stats:		Statistics struct, which was left as a legacy, use
+  *			rtnl_link_stats64 instead
+  *
+  *	@rx_dropped:	Dropped packets by core network,
+  *			do not use this in drivers
+  *	@tx_dropped:	Dropped packets by core network,
+  *			do not use this in drivers
+  *	@rx_nohandler:	nohandler dropped packets by core network on
+  *			inactive devices, do not use this in drivers
+  *
+  *	@wireless_handlers:	List of functions to handle Wireless Extensions,
+  *				instead of ioctl,
+  *				see <net/iw_handler.h> for details.
+  *	@wireless_data:	Instance data managed by the core of wireless extensions
+  *
+  *	@netdev_ops:	Includes several pointers to callbacks,
+  *			if one wants to override the ndo_*() functions
+  *	@ethtool_ops:	Management operations
+  *	@ndisc_ops:	Includes callbacks for different IPv6 neighbour
+  *			discovery handling. Necessary for e.g. 6LoWPAN.
+  *	@header_ops:	Includes callbacks for creating,parsing,caching,etc
+  *			of Layer 2 headers.
+  *
+  *	@flags:		Interface flags (a la BSD)
+  *	@priv_flags:	Like 'flags' but invisible to userspace,
+  *			see if.h for the definitions
+  *	@gflags:	Global flags ( kept as legacy )
+  *	@padded:	How much padding added by alloc_netdev()
+  *	@operstate:	RFC2863 operstate
+  *	@link_mode:	Mapping policy to operstate
+  *	@if_port:	Selectable AUI, TP, ...
+  *	@dma:		DMA channel
+  *	@mtu:		Interface MTU value
+  *	@min_mtu:	Interface Minimum MTU value
+  *	@max_mtu:	Interface Maximum MTU value
+  *	@type:		Interface hardware type
+  *	@hard_header_len: Maximum hardware header length.
+  *	@min_header_len:  Minimum hardware header length
+  *
+  *	@needed_headroom: Extra headroom the hardware may need, but not in all
+  *			  cases can this be guaranteed
+  *	@needed_tailroom: Extra tailroom the hardware may need, but not in all
+  *			  cases can this be guaranteed. Some cases also use
+  *			  LL_MAX_HEADER instead to allocate the skb
+  *
+  *	interface address info:
+  *
+  * 	@perm_addr:		Permanent hw address
+  * 	@addr_assign_type:	Hw address assignment type
+  * 	@addr_len:		Hardware address length
+  *	@neigh_priv_len:	Used in neigh_alloc()
+  * 	@dev_id:		Used to differentiate devices that share
+  * 				the same link layer address
+  * 	@dev_port:		Used to differentiate devices that share
+  * 				the same function
+  *	@addr_list_lock:	XXX: need comments on this one
+  *	@uc_promisc:		Counter that indicates promiscuous mode
+  *				has been enabled due to the need to listen to
+  *				additional unicast addresses in a device that
+  *				does not implement ndo_set_rx_mode()
+  *	@uc:			unicast mac addresses
+  *	@mc:			multicast mac addresses
+  *	@dev_addrs:		list of device hw addresses
+  *	@queues_kset:		Group of all Kobjects in the Tx and RX queues
+  *	@promiscuity:		Number of times the NIC is told to work in
+  *				promiscuous mode; if it becomes 0 the NIC will
+  *				exit promiscuous mode
+  *	@allmulti:		Counter, enables or disables allmulticast mode
+  *
+  *	@vlan_info:	VLAN info
+  *	@dsa_ptr:	dsa specific data
+  *	@tipc_ptr:	TIPC specific data
+  *	@atalk_ptr:	AppleTalk link
+  *	@ip_ptr:	IPv4 specific data
+  *	@dn_ptr:	DECnet specific data
+  *	@ip6_ptr:	IPv6 specific data
+  *	@ax25_ptr:	AX.25 specific data
+  *	@ieee80211_ptr:	IEEE 802.11 specific data, assign before registering
+  *
+  *	@dev_addr:	Hw address (before bcast,
+  *			because most packets are unicast)
+  *
+  *	@_rx:			Array of RX queues
+  *	@num_rx_queues:		Number of RX queues
+  *				allocated at register_netdev() time
+  *	@real_num_rx_queues: 	Number of RX queues currently active in device
+  *
+  *	@rx_handler:		handler for received packets
+  *	@rx_handler_data: 	XXX: need comments on this one
+  *	@miniq_ingress:		ingress/clsact qdisc specific data for
+  *				ingress processing
+  *	@ingress_queue:		XXX: need comments on this one
+  *	@broadcast:		hw bcast address
+  *
+  *	@rx_cpu_rmap:	CPU reverse-mapping for RX completion interrupts,
+  *			indexed by RX queue number. Assigned by driver.
+  *			This must only be set if the ndo_rx_flow_steer
+  *			operation is defined
+  *	@index_hlist:		Device index hash chain
+  *
+  *	@_tx:			Array of TX queues
+  *	@num_tx_queues:		Number of TX queues allocated at alloc_netdev_mq() time
+  *	@real_num_tx_queues: 	Number of TX queues currently active in device
+  *	@qdisc:			Root qdisc from userspace point of view
+  *	@tx_queue_len:		Max frames per queue allowed
+  *	@tx_global_lock: 	XXX: need comments on this one
+  *
+  *	@xps_maps:	XXX: need comments on this one
+  *	@miniq_egress:		clsact qdisc specific data for
+  *				egress processing
+  *	@watchdog_timeo:	Represents the timeout that is used by
+  *				the watchdog (see dev_watchdog())
+  *	@watchdog_timer:	List of timers
+  *
+  *	@pcpu_refcnt:		Number of references to this device
+  *	@todo_list:		Delayed register/unregister
+  *	@link_watch_list:	XXX: need comments on this one
+  *
+  *	@reg_state:		Register/unregister state machine
+  *	@dismantle:		Device is going to be freed
+  *	@rtnl_link_state:	This enum represents the phases of creating
+  *				a new link
+  *
+  *	@needs_free_netdev:	Should unregister perform free_netdev?
+  *	@priv_destructor:	Called from unregister
+  *	@npinfo:		XXX: need comments on this one
+  * 	@nd_net:		Network namespace this network device is inside
+  *
+  * 	@ml_priv:	Mid-layer private
+  * 	@lstats:	Loopback statistics
+  * 	@tstats:	Tunnel statistics
+  * 	@dstats:	Dummy statistics
+  * 	@vstats:	Virtual ethernet statistics
+  *
+  *	@garp_port:	GARP
+  *	@mrp_port:	MRP
+  *
+  *	@dev:		Class/net/name entry
+  *	@sysfs_groups:	Space for optional device, statistics and wireless
+  *			sysfs groups
+  *
+  *	@sysfs_rx_queue_group:	Space for optional per-rx queue attributes
+  *	@rtnl_link_ops:	Rtnl_link_ops
+  *
+  *	@gso_max_size:	Maximum size of generic segmentation offload
+  *	@gso_max_segs:	Maximum number of segments that can be passed to the
+  *			NIC for GSO
+  *
+  *	@dcbnl_ops:	Data Center Bridging netlink ops
+  *	@num_tc:	Number of traffic classes in the net device
+  *	@tc_to_txq:	XXX: need comments on this one
+  *	@prio_tc_map:	XXX: need comments on this one
+  *
+  *	@fcoe_ddp_xid:	Max exchange id for FCoE LRO by ddp
+  *
+  *	@priomap:	XXX: need comments on this one
+  *	@phydev:	Physical device may attach itself
+  *			for hardware timestamping
+  *
+  *	@qdisc_tx_busylock: lockdep class annotating Qdisc->busylock spinlock
+  *	@qdisc_running_key: lockdep class annotating Qdisc->running seqcount
+  *
++>>>>>>> 46209401f8f6 (net: core: introduce mini_Qdisc and eliminate usage of tp->q for clsact fastpath)
   *	@proto_down:	protocol port state information can be sent to the
   *			switch driver and used to set the phys state of the
   *			switch port.
@@@ -1796,13 -1795,21 +2000,19 @@@ struct net_device 
  	rx_handler_func_t __rcu	*rx_handler;
  	void __rcu		*rx_handler_data;
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NET_CLS_ACT
+ 	struct mini_Qdisc __rcu	*miniq_ingress;
+ #endif
++>>>>>>> 46209401f8f6 (net: core: introduce mini_Qdisc and eliminate usage of tp->q for clsact fastpath)
  	struct netdev_queue __rcu *ingress_queue;
 -#ifdef CONFIG_NETFILTER_INGRESS
 -	struct nf_hook_entries __rcu *nf_hooks_ingress;
 -#endif
 +	unsigned char		broadcast[MAX_ADDR_LEN];	/* hw bcast add	*/
  
 -	unsigned char		broadcast[MAX_ADDR_LEN];
 -#ifdef CONFIG_RFS_ACCEL
 -	struct cpu_rmap		*rx_cpu_rmap;
 +#ifdef CONFIG_NET_CLS_ACT
 +	RH_KABI_FILL_HOLE(struct tcf_proto __rcu *ingress_cl_list)
  #endif
 -	struct hlist_node	index_hlist;
 +	/* Hole: 16 bytes remain */
  
  /*
   * Cache lines mostly used on transmit path
@@@ -1824,11 -1828,8 +2034,16 @@@
  #ifdef CONFIG_XPS
  	struct xps_dev_maps __rcu *xps_maps;
  #endif
++<<<<<<< HEAD
 +#ifdef CONFIG_RFS_ACCEL
 +	/* CPU reverse-mapping for RX completion interrupts, indexed
 +	 * by RX queue number.  Assigned by driver.  This must only be
 +	 * set if the ndo_rx_flow_steer operation is defined. */
 +	struct cpu_rmap		*rx_cpu_rmap;
++=======
+ #ifdef CONFIG_NET_CLS_ACT
+ 	struct mini_Qdisc __rcu	*miniq_egress;
++>>>>>>> 46209401f8f6 (net: core: introduce mini_Qdisc and eliminate usage of tp->q for clsact fastpath)
  #endif
  
  	/* These may be needed for future network-power-down code. */
diff --cc net/core/dev.c
index 2401cdc6aa09,1423cf4d695c..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -3218,10 -3274,10 +3218,14 @@@ EXPORT_SYMBOL(dev_loopback_xmit)
  static struct sk_buff *
  sch_handle_egress(struct sk_buff *skb, int *ret, struct net_device *dev)
  {
++<<<<<<< HEAD
 +	struct tcf_proto *cl = rcu_dereference_bh(dev->extended->egress_cl_list);
++=======
+ 	struct mini_Qdisc *miniq = rcu_dereference_bh(dev->miniq_egress);
++>>>>>>> 46209401f8f6 (net: core: introduce mini_Qdisc and eliminate usage of tp->q for clsact fastpath)
  	struct tcf_result cl_res;
  
- 	if (!cl)
+ 	if (!miniq)
  		return skb;
  
  	/* qdisc_skb_cb(skb)->pkt_len was already set by the caller. */
@@@ -3937,10 -4206,10 +3942,15 @@@ sch_handle_ingress(struct sk_buff *skb
  	}
  
  	qdisc_skb_cb(skb)->pkt_len = skb->len;
++<<<<<<< HEAD
 +	skb->tc_verd = SET_TC_AT(skb->tc_verd, AT_INGRESS);
 +	qdisc_bstats_cpu_update(cl->q, skb);
++=======
+ 	skb->tc_at_ingress = 1;
+ 	mini_qdisc_bstats_cpu_update(miniq, skb);
++>>>>>>> 46209401f8f6 (net: core: introduce mini_Qdisc and eliminate usage of tp->q for clsact fastpath)
  
- 	switch (tcf_classify(skb, cl, &cl_res, false)) {
+ 	switch (tcf_classify(skb, miniq->filter_list, &cl_res, false)) {
  	case TC_ACT_OK:
  	case TC_ACT_RECLASSIFY:
  		skb->tc_index = TC_H_MIN(cl_res.classid);
diff --cc net/sched/sch_ingress.c
index 790eb0f81e70,5ecc38f35d47..000000000000
--- a/net/sched/sch_ingress.c
+++ b/net/sched/sch_ingress.c
@@@ -20,6 -20,8 +20,11 @@@
  
  struct ingress_sched_data {
  	struct tcf_block *block;
++<<<<<<< HEAD
++=======
+ 	struct tcf_block_ext_info block_info;
+ 	struct mini_Qdisc_pair miniqp;
++>>>>>>> 46209401f8f6 (net: core: introduce mini_Qdisc and eliminate usage of tp->q for clsact fastpath)
  };
  
  static struct Qdisc *ingress_leaf(struct Qdisc *sch, unsigned long arg)
@@@ -53,13 -55,26 +58,33 @@@ static struct tcf_block *ingress_tcf_bl
  	return q->block;
  }
  
++<<<<<<< HEAD
++=======
+ static void clsact_chain_head_change(struct tcf_proto *tp_head, void *priv)
+ {
+ 	struct mini_Qdisc_pair *miniqp = priv;
+ 
+ 	mini_qdisc_pair_swap(miniqp, tp_head);
+ }
+ 
++>>>>>>> 46209401f8f6 (net: core: introduce mini_Qdisc and eliminate usage of tp->q for clsact fastpath)
  static int ingress_init(struct Qdisc *sch, struct nlattr *opt)
  {
  	struct ingress_sched_data *q = qdisc_priv(sch);
  	struct net_device *dev = qdisc_dev(sch);
  	int err;
  
++<<<<<<< HEAD
 +	err = tcf_block_get(&q->block, &dev->ingress_cl_list);
++=======
+ 	mini_qdisc_pair_init(&q->miniqp, sch, &dev->miniq_ingress);
+ 
+ 	q->block_info.binder_type = TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS;
+ 	q->block_info.chain_head_change = clsact_chain_head_change;
+ 	q->block_info.chain_head_change_priv = &q->miniqp;
+ 
+ 	err = tcf_block_get_ext(&q->block, sch, &q->block_info);
++>>>>>>> 46209401f8f6 (net: core: introduce mini_Qdisc and eliminate usage of tp->q for clsact fastpath)
  	if (err)
  		return err;
  
@@@ -114,6 -129,10 +139,13 @@@ static struct Qdisc_ops ingress_qdisc_o
  struct clsact_sched_data {
  	struct tcf_block *ingress_block;
  	struct tcf_block *egress_block;
++<<<<<<< HEAD
++=======
+ 	struct tcf_block_ext_info ingress_block_info;
+ 	struct tcf_block_ext_info egress_block_info;
+ 	struct mini_Qdisc_pair miniqp_ingress;
+ 	struct mini_Qdisc_pair miniqp_egress;
++>>>>>>> 46209401f8f6 (net: core: introduce mini_Qdisc and eliminate usage of tp->q for clsact fastpath)
  };
  
  static unsigned long clsact_find(struct Qdisc *sch, u32 classid)
@@@ -153,13 -172,25 +185,33 @@@ static int clsact_init(struct Qdisc *sc
  	struct net_device *dev = qdisc_dev(sch);
  	int err;
  
++<<<<<<< HEAD
 +	err = tcf_block_get(&q->ingress_block, &dev->ingress_cl_list);
 +	if (err)
 +		return err;
 +
 +	err = tcf_block_get(&q->egress_block, &dev->extended->egress_cl_list);
++=======
+ 	mini_qdisc_pair_init(&q->miniqp_ingress, sch, &dev->miniq_ingress);
+ 
+ 	q->ingress_block_info.binder_type = TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS;
+ 	q->ingress_block_info.chain_head_change = clsact_chain_head_change;
+ 	q->ingress_block_info.chain_head_change_priv = &q->miniqp_ingress;
+ 
+ 	err = tcf_block_get_ext(&q->ingress_block, sch, &q->ingress_block_info);
+ 	if (err)
+ 		return err;
+ 
+ 	mini_qdisc_pair_init(&q->miniqp_egress, sch, &dev->miniq_egress);
+ 
+ 	q->egress_block_info.binder_type = TCF_BLOCK_BINDER_TYPE_CLSACT_EGRESS;
+ 	q->egress_block_info.chain_head_change = clsact_chain_head_change;
+ 	q->egress_block_info.chain_head_change_priv = &q->miniqp_egress;
+ 
+ 	err = tcf_block_get_ext(&q->egress_block, sch, &q->egress_block_info);
++>>>>>>> 46209401f8f6 (net: core: introduce mini_Qdisc and eliminate usage of tp->q for clsact fastpath)
  	if (err)
 -		goto err_egress_block_get;
 +		return err;
  
  	net_inc_ingress_queue();
  	net_inc_egress_queue();
* Unmerged path include/linux/netdevice.h
diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h
index 3ef0057615ac..0c6a1cd8d7fb 100644
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@ -904,5 +904,37 @@ static inline void psched_ratecfg_getrate(struct tc_ratespec *res,
 	res->linklayer = (r->linklayer & TC_LINKLAYER_MASK);
 }
 
+/* Mini Qdisc serves for specific needs of ingress/clsact Qdisc.
+ * The fast path only needs to access filter list and to update stats
+ */
+struct mini_Qdisc {
+	struct tcf_proto *filter_list;
+	struct gnet_stats_basic_cpu __percpu *cpu_bstats;
+	struct gnet_stats_queue	__percpu *cpu_qstats;
+	struct rcu_head rcu;
+};
+
+static inline void mini_qdisc_bstats_cpu_update(struct mini_Qdisc *miniq,
+						const struct sk_buff *skb)
+{
+	bstats_cpu_update(this_cpu_ptr(miniq->cpu_bstats), skb);
+}
+
+static inline void mini_qdisc_qstats_cpu_drop(struct mini_Qdisc *miniq)
+{
+	this_cpu_inc(miniq->cpu_qstats->drops);
+}
+
+struct mini_Qdisc_pair {
+	struct mini_Qdisc miniq1;
+	struct mini_Qdisc miniq2;
+	struct mini_Qdisc __rcu **p_miniq;
+};
+
+void mini_qdisc_pair_swap(struct mini_Qdisc_pair *miniqp,
+			  struct tcf_proto *tp_head);
+void mini_qdisc_pair_init(struct mini_Qdisc_pair *miniqp, struct Qdisc *qdisc,
+			  struct mini_Qdisc __rcu **p_miniq);
+
 #endif
 #endif
* Unmerged path net/core/dev.c
diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c
index 550f656c2ac8..d54a0595d0e6 100644
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@ -1063,3 +1063,49 @@ void psched_ratecfg_precompute(struct psched_ratecfg *r,
 	}
 }
 EXPORT_SYMBOL(psched_ratecfg_precompute);
+
+static void mini_qdisc_rcu_func(struct rcu_head *head)
+{
+}
+
+void mini_qdisc_pair_swap(struct mini_Qdisc_pair *miniqp,
+			  struct tcf_proto *tp_head)
+{
+	struct mini_Qdisc *miniq_old = rtnl_dereference(*miniqp->p_miniq);
+	struct mini_Qdisc *miniq;
+
+	if (!tp_head) {
+		RCU_INIT_POINTER(*miniqp->p_miniq, NULL);
+		return;
+	}
+
+	miniq = !miniq_old || miniq_old == &miniqp->miniq2 ?
+		&miniqp->miniq1 : &miniqp->miniq2;
+
+	/* We need to make sure that readers won't see the miniq
+	 * we are about to modify. So wait until previous call_rcu_bh callback
+	 * is done.
+	 */
+	rcu_barrier_bh();
+	miniq->filter_list = tp_head;
+	rcu_assign_pointer(*miniqp->p_miniq, miniq);
+
+	if (miniq_old)
+		/* This is counterpart of the rcu barrier above. We need to
+		 * block potential new user of miniq_old until all readers
+		 * are not seeing it.
+		 */
+		call_rcu_bh(&miniq_old->rcu, mini_qdisc_rcu_func);
+}
+EXPORT_SYMBOL(mini_qdisc_pair_swap);
+
+void mini_qdisc_pair_init(struct mini_Qdisc_pair *miniqp, struct Qdisc *qdisc,
+			  struct mini_Qdisc __rcu **p_miniq)
+{
+	miniqp->miniq1.cpu_bstats = qdisc->cpu_bstats;
+	miniqp->miniq1.cpu_qstats = qdisc->cpu_qstats;
+	miniqp->miniq2.cpu_bstats = qdisc->cpu_bstats;
+	miniqp->miniq2.cpu_qstats = qdisc->cpu_qstats;
+	miniqp->p_miniq = p_miniq;
+}
+EXPORT_SYMBOL(mini_qdisc_pair_init);
* Unmerged path net/sched/sch_ingress.c
