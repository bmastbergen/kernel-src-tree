mlxsw: spectrum_router: Demote tunnels on VRF migration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Petr Machata <petrm@mellanox.com>
commit cab43d9c877456d2d8feb77335327316d3de9871
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/cab43d9c.failed

The mlxsw driver currently doesn't offload GRE tunnels if they have the
same local address and use the same underlay VRF. When such a situation
arises, the tunnels in conflict are demoted to slow path.

However, the current code only verifies this condition on tunnel
creation and tunnel change, not when a tunnel is moved to a different
VRF. When the tunnel has no bound device, underlay and overlay are the
same. Thus moving a tunnel moves the underlay as well, and that can
cause local address conflict.

So modify mlxsw_sp_netdevice_ipip_ol_vrf_event() to check if there are
any conflicting tunnels, and demote them if yes.

Fixes: af641713e97d ("mlxsw: spectrum_router: Onload conflicting tunnels")
	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cab43d9c877456d2d8feb77335327316d3de9871)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index edab76a34b3f,a23e452f7261..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -1387,12 -1443,159 +1387,164 @@@ static int mlxsw_sp_netdevice_ipip_ol_v
  	return 0;
  }
  
 -static int mlxsw_sp_netdevice_ipip_ol_vrf_event(struct mlxsw_sp *mlxsw_sp,
 -						struct net_device *ol_dev,
 -						struct netlink_ext_ack *extack)
 +int
 +mlxsw_sp_netdevice_ipip_ol_event(struct mlxsw_sp *mlxsw_sp,
 +				 struct net_device *ol_dev,
 +				 unsigned long event,
 +				 struct netdev_notifier_changeupper_info *info)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlxsw_sp_ipip_entry *ipip_entry =
+ 		mlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, ol_dev);
+ 	enum mlxsw_sp_l3proto ul_proto;
+ 	union mlxsw_sp_l3addr saddr;
+ 	u32 ul_tb_id;
+ 
+ 	if (!ipip_entry)
+ 		return 0;
+ 
+ 	/* For flat configuration cases, moving overlay to a different VRF might
+ 	 * cause local address conflict, and the conflicting tunnels need to be
+ 	 * demoted.
+ 	 */
+ 	ul_tb_id = mlxsw_sp_ipip_dev_ul_tb_id(ol_dev);
+ 	ul_proto = mlxsw_sp->router->ipip_ops_arr[ipip_entry->ipipt]->ul_proto;
+ 	saddr = mlxsw_sp_ipip_netdev_saddr(ul_proto, ol_dev);
+ 	if (mlxsw_sp_ipip_demote_tunnel_by_saddr(mlxsw_sp, ul_proto,
+ 						 saddr, ul_tb_id,
+ 						 ipip_entry)) {
+ 		mlxsw_sp_ipip_entry_demote_tunnel(mlxsw_sp, ipip_entry);
+ 		return 0;
+ 	}
+ 
+ 	return __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,
+ 						   true, false, false, extack);
+ }
+ 
+ static int
+ mlxsw_sp_netdevice_ipip_ul_vrf_event(struct mlxsw_sp *mlxsw_sp,
+ 				     struct mlxsw_sp_ipip_entry *ipip_entry,
+ 				     struct net_device *ul_dev,
+ 				     struct netlink_ext_ack *extack)
+ {
+ 	return __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,
+ 						   true, true, false, extack);
+ }
+ 
+ static int
+ mlxsw_sp_netdevice_ipip_ul_up_event(struct mlxsw_sp *mlxsw_sp,
+ 				    struct mlxsw_sp_ipip_entry *ipip_entry,
+ 				    struct net_device *ul_dev)
+ {
+ 	return __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,
+ 						   false, false, true, NULL);
+ }
+ 
+ static int
+ mlxsw_sp_netdevice_ipip_ul_down_event(struct mlxsw_sp *mlxsw_sp,
+ 				      struct mlxsw_sp_ipip_entry *ipip_entry,
+ 				      struct net_device *ul_dev)
+ {
+ 	/* A down underlay device causes encapsulated packets to not be
+ 	 * forwarded, but decap still works. So refresh next hops without
+ 	 * touching anything else.
+ 	 */
+ 	return __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,
+ 						   false, false, true, NULL);
+ }
+ 
+ static int
+ mlxsw_sp_netdevice_ipip_ol_change_event(struct mlxsw_sp *mlxsw_sp,
+ 					struct net_device *ol_dev,
+ 					struct netlink_ext_ack *extack)
+ {
+ 	const struct mlxsw_sp_ipip_ops *ipip_ops;
+ 	struct mlxsw_sp_ipip_entry *ipip_entry;
+ 	int err;
+ 
+ 	ipip_entry = mlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, ol_dev);
+ 	if (!ipip_entry)
+ 		/* A change might make a tunnel eligible for offloading, but
+ 		 * that is currently not implemented. What falls to slow path
+ 		 * stays there.
+ 		 */
+ 		return 0;
+ 
+ 	/* A change might make a tunnel not eligible for offloading. */
+ 	if (!mlxsw_sp_netdevice_ipip_can_offload(mlxsw_sp, ol_dev,
+ 						 ipip_entry->ipipt)) {
+ 		mlxsw_sp_ipip_entry_demote_tunnel(mlxsw_sp, ipip_entry);
+ 		return 0;
+ 	}
+ 
+ 	ipip_ops = mlxsw_sp->router->ipip_ops_arr[ipip_entry->ipipt];
+ 	err = ipip_ops->ol_netdev_change(mlxsw_sp, ipip_entry, extack);
+ 	return err;
+ }
+ 
+ void mlxsw_sp_ipip_entry_demote_tunnel(struct mlxsw_sp *mlxsw_sp,
+ 				       struct mlxsw_sp_ipip_entry *ipip_entry)
+ {
+ 	struct net_device *ol_dev = ipip_entry->ol_dev;
+ 
+ 	if (ol_dev->flags & IFF_UP)
+ 		mlxsw_sp_ipip_entry_ol_down_event(mlxsw_sp, ipip_entry);
+ 	mlxsw_sp_ipip_entry_destroy(mlxsw_sp, ipip_entry);
+ }
+ 
+ /* The configuration where several tunnels have the same local address in the
+  * same underlay table needs special treatment in the HW. That is currently not
+  * implemented in the driver. This function finds and demotes the first tunnel
+  * with a given source address, except the one passed in in the argument
+  * `except'.
+  */
+ bool
+ mlxsw_sp_ipip_demote_tunnel_by_saddr(struct mlxsw_sp *mlxsw_sp,
+ 				     enum mlxsw_sp_l3proto ul_proto,
+ 				     union mlxsw_sp_l3addr saddr,
+ 				     u32 ul_tb_id,
+ 				     const struct mlxsw_sp_ipip_entry *except)
+ {
+ 	struct mlxsw_sp_ipip_entry *ipip_entry, *tmp;
+ 
+ 	list_for_each_entry_safe(ipip_entry, tmp, &mlxsw_sp->router->ipip_list,
+ 				 ipip_list_node) {
+ 		if (ipip_entry != except &&
+ 		    mlxsw_sp_ipip_entry_saddr_matches(mlxsw_sp, ul_proto, saddr,
+ 						      ul_tb_id, ipip_entry)) {
+ 			mlxsw_sp_ipip_entry_demote_tunnel(mlxsw_sp, ipip_entry);
+ 			return true;
+ 		}
+ 	}
+ 
+ 	return false;
+ }
+ 
+ static void mlxsw_sp_ipip_demote_tunnel_by_ul_netdev(struct mlxsw_sp *mlxsw_sp,
+ 						     struct net_device *ul_dev)
+ {
+ 	struct mlxsw_sp_ipip_entry *ipip_entry, *tmp;
+ 
+ 	list_for_each_entry_safe(ipip_entry, tmp, &mlxsw_sp->router->ipip_list,
+ 				 ipip_list_node) {
+ 		struct net_device *ipip_ul_dev =
+ 			__mlxsw_sp_ipip_netdev_ul_dev_get(ipip_entry->ol_dev);
+ 
+ 		if (ipip_ul_dev == ul_dev)
+ 			mlxsw_sp_ipip_entry_demote_tunnel(mlxsw_sp, ipip_entry);
+ 	}
+ }
+ 
+ int mlxsw_sp_netdevice_ipip_ol_event(struct mlxsw_sp *mlxsw_sp,
+ 				     struct net_device *ol_dev,
+ 				     unsigned long event,
+ 				     struct netdev_notifier_info *info)
+ {
+ 	struct netdev_notifier_changeupper_info *chup;
+ 	struct netlink_ext_ack *extack;
+ 
++>>>>>>> cab43d9c8774 (mlxsw: spectrum_router: Demote tunnels on VRF migration)
  	switch (event) {
  	case NETDEV_REGISTER:
  		return mlxsw_sp_netdevice_ipip_ol_reg_event(mlxsw_sp, ol_dev);
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
