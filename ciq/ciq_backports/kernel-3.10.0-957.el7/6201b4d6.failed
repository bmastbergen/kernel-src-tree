timer: Remove code redundancy while calling get_nohz_timer_target()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 6201b4d61fbf194df6371fb3376c5026cb8f5eec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6201b4d6.failed

There are only two users of get_nohz_timer_target(): timer and hrtimer. Both
call it under same circumstances, i.e.

	#ifdef CONFIG_NO_HZ_COMMON
	       if (!pinned && get_sysctl_timer_migration() && idle_cpu(this_cpu))
	               return get_nohz_timer_target();
	#endif

So, it makes more sense to get all this as part of get_nohz_timer_target()
instead of duplicating code at two places. For this another parameter is
required to be passed to this routine, pinned.

	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Cc: linaro-kernel@lists.linaro.org
	Cc: fweisbec@gmail.com
	Cc: peterz@infradead.org
Link: http://lkml.kernel.org/r/1e1b53537217d58d48c2d7a222a9c3ac47d5b64c.1395140107.git.viresh.kumar@linaro.org
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 6201b4d61fbf194df6371fb3376c5026cb8f5eec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/hrtimer.c
#	kernel/sched/core.c
#	kernel/timer.c
diff --cc kernel/hrtimer.c
index ecbe27cbadd0,d55092ceee29..000000000000
--- a/kernel/hrtimer.c
+++ b/kernel/hrtimer.c
@@@ -146,19 -168,6 +146,22 @@@ struct hrtimer_clock_base *lock_hrtimer
  	}
  }
  
++<<<<<<< HEAD
 +
 +/*
 + * Get the preferred target CPU for NOHZ
 + */
 +static int hrtimer_get_target(int this_cpu, int pinned)
 +{
 +#ifdef CONFIG_NO_HZ_COMMON
 +	if (!pinned && get_sysctl_timer_migration())
 +		return get_nohz_timer_target();
 +#endif
 +	return this_cpu;
 +}
 +
++=======
++>>>>>>> 6201b4d61fbf (timer: Remove code redundancy while calling get_nohz_timer_target())
  /*
   * With HIGHRES=y we do not migrate the timer when it is expiring
   * before the next event on the target cpu because we cannot reprogram
diff --cc kernel/sched/core.c
index 1a5e18b224eb,c0339e206cc2..000000000000
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@@ -640,7 -561,7 +640,11 @@@ int get_nohz_timer_target(int pinned
  	int i;
  	struct sched_domain *sd;
  
++<<<<<<< HEAD
 +	if (!idle_cpu(cpu) && is_housekeeping_cpu(cpu))
++=======
+ 	if (pinned || !get_sysctl_timer_migration() || !idle_cpu(cpu))
++>>>>>>> 6201b4d61fbf (timer: Remove code redundancy while calling get_nohz_timer_target())
  		return cpu;
  
  	rcu_read_lock();
diff --cc kernel/timer.c
index 032a9a53e430,1d35ddadc045..000000000000
--- a/kernel/timer.c
+++ b/kernel/timer.c
@@@ -762,12 -760,7 +762,16 @@@ __mod_timer(struct timer_list *timer, u
  
  	debug_activate(timer, expires);
  
++<<<<<<< HEAD
 +	cpu = smp_processor_id();
 +
 +#if defined(CONFIG_NO_HZ_COMMON) && defined(CONFIG_SMP)
 +	if (!pinned && get_sysctl_timer_migration())
 +		cpu = get_nohz_timer_target();
 +#endif
++=======
+ 	cpu = get_nohz_timer_target(pinned);
++>>>>>>> 6201b4d61fbf (timer: Remove code redundancy while calling get_nohz_timer_target())
  	new_base = per_cpu(tvec_bases, cpu);
  
  	if (base != new_base) {
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 0646138be0ad..44b570af57c3 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -298,10 +298,14 @@ extern int runqueue_is_locked(int cpu);
 #if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)
 extern void nohz_balance_enter_idle(int cpu);
 extern void set_cpu_sd_state_idle(void);
-extern int get_nohz_timer_target(void);
+extern int get_nohz_timer_target(int pinned);
 #else
 static inline void nohz_balance_enter_idle(int cpu) { }
 static inline void set_cpu_sd_state_idle(void) { }
+static inline int get_nohz_timer_target(int pinned)
+{
+	return smp_processor_id();
+}
 #endif
 
 /*
* Unmerged path kernel/hrtimer.c
* Unmerged path kernel/sched/core.c
* Unmerged path kernel/timer.c
