watchdog: Ensure that wdd is not dereferenced if NULL

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [watchdog] Ensure that wdd is not dereferenced if NULL (David Arcari) [1576173]
Rebuild_FUZZ: 89.58%
commit-author Guenter Roeck <linux@roeck-us.net>
commit d1ed3ba4e3d76b4ebec239c64f990c26d7935700
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d1ed3ba4.failed

Smatch rightfully complains that wdd is dereferenced in the watchdog
release function after being checked for NULL. Also make sure that it
is not accessed outside mutex protection to avoid use-after-free problems.

Fixes: e6c71e84e4c0 ("watchdog: Introduce WDOG_HW_RUNNING flag")
	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Guenter Roeck <linux@roeck-us.net>
	Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
(cherry picked from commit d1ed3ba4e3d76b4ebec239c64f990c26d7935700)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/watchdog/watchdog_dev.c
diff --cc drivers/watchdog/watchdog_dev.c
index f06fbcf0bea2,e2c5abbb45ff..000000000000
--- a/drivers/watchdog/watchdog_dev.c
+++ b/drivers/watchdog/watchdog_dev.c
@@@ -577,9 -708,17 +577,10 @@@ out
  
  static int watchdog_release(struct inode *inode, struct file *file)
  {
 -	struct watchdog_core_data *wd_data = file->private_data;
 -	struct watchdog_device *wdd;
 +	struct watchdog_device *wdd = file->private_data;
  	int err = -EBUSY;
+ 	bool running;
  
 -	mutex_lock(&wd_data->lock);
 -
 -	wdd = wd_data->wdd;
 -	if (!wdd)
 -		goto done;
 -
  	/*
  	 * We only stop the watchdog if we received the magic character
  	 * or if WDIOF_MAGICCLOSE is not set. If nowayout was set then
@@@ -600,16 -736,24 +601,31 @@@
  		watchdog_ping(wdd);
  	}
  
 -	cancel_delayed_work_sync(&wd_data->work);
 -	watchdog_update_worker(wdd);
 +	/* Allow the owner module to be unloaded again */
 +	module_put(wdd->ops->owner);
  
  	/* make sure that /dev/watchdog can be re-opened */
 -	clear_bit(_WDOG_DEV_OPEN, &wd_data->status);
 +	clear_bit(WDOG_DEV_OPEN, &wdd->status);
 +
 +	/* Note wdd may be gone after this, do not use after this! */
 +	if (wdd->ops->unref)
 +		wdd->ops->unref(wdd);
  
++<<<<<<< HEAD
++=======
+ done:
+ 	running = wdd && watchdog_hw_running(wdd);
+ 	mutex_unlock(&wd_data->lock);
+ 	/*
+ 	 * Allow the owner module to be unloaded again unless the watchdog
+ 	 * is still running. If the watchdog is still running, it can not
+ 	 * be stopped, and its driver must not be unloaded.
+ 	 */
+ 	if (!running) {
+ 		module_put(wd_data->cdev.owner);
+ 		kref_put(&wd_data->kref, watchdog_core_data_release);
+ 	}
++>>>>>>> d1ed3ba4e3d7 (watchdog: Ensure that wdd is not dereferenced if NULL)
  	return 0;
  }
  
* Unmerged path drivers/watchdog/watchdog_dev.c
