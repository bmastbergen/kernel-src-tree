x86/mm, resource: Use PAGE_KERNEL protection for ioremap of memory pages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] mm, resource: Use PAGE_KERNEL protection for ioremap of memory pages (Gary Hook) [1361286]
Rebuild_FUZZ: 97.14%
commit-author Tom Lendacky <thomas.lendacky@amd.com>
commit 0e4c12b45aa88e74fdda117896d2b61c4e510cb9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0e4c12b4.failed

In order for memory pages to be properly mapped when SEV is active, it's
necessary to use the PAGE_KERNEL protection attribute as the base
protection.  This ensures that memory mapping of, e.g. ACPI tables,
receives the proper mapping attributes.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: Brijesh Singh <brijesh.singh@amd.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Borislav Petkov <bp@suse.de>
	Tested-by: Borislav Petkov <bp@suse.de>
	Cc: Laura Abbott <labbott@redhat.com>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: kvm@vger.kernel.org
	Cc: Jérôme Glisse <jglisse@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
Link: https://lkml.kernel.org/r/20171020143059.3291-11-brijesh.singh@amd.com

(cherry picked from commit 0e4c12b45aa88e74fdda117896d2b61c4e510cb9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/ioremap.c
diff --cc arch/x86/mm/ioremap.c
index 30ab4df60805,6e4573b1da34..000000000000
--- a/arch/x86/mm/ioremap.c
+++ b/arch/x86/mm/ioremap.c
@@@ -107,12 -161,9 +157,18 @@@ static void __iomem *__ioremap_caller(r
  	/*
  	 * Don't allow anybody to remap normal RAM that we're using..
  	 */
++<<<<<<< HEAD
 +	pfn      = phys_addr >> PAGE_SHIFT;
 +	last_pfn = last_addr >> PAGE_SHIFT;
 +	if (walk_system_ram_range(pfn, last_pfn - pfn + 1, NULL,
 +					  __ioremap_check_ram) == 1) {
 +		WARN_ONCE(1, "ioremap on RAM at 0x%llx - 0x%llx\n",
 +					phys_addr, last_addr);
++=======
+ 	if (mem_flags.system_ram) {
+ 		WARN_ONCE(1, "ioremap on RAM at %pa - %pa\n",
+ 			  &phys_addr, &last_addr);
++>>>>>>> 0e4c12b45aa8 (x86/mm, resource: Use PAGE_KERNEL protection for ioremap of memory pages)
  		return NULL;
  	}
  
* Unmerged path arch/x86/mm/ioremap.c
diff --git a/include/linux/ioport.h b/include/linux/ioport.h
index 1f908f9caecf..bc18a74419ec 100644
--- a/include/linux/ioport.h
+++ b/include/linux/ioport.h
@@ -260,6 +260,9 @@ extern int
 walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,
 		void *arg, int (*func)(unsigned long, unsigned long, void *));
 extern int
+walk_mem_res(u64 start, u64 end, void *arg,
+	     int (*func)(struct resource *, void *));
+extern int
 walk_system_ram_res(u64 start, u64 end, void *arg,
 		    int (*func)(u64, u64, void *));
 extern int
diff --git a/kernel/resource.c b/kernel/resource.c
index c6ecc9dca549..cf197f99b016 100644
--- a/kernel/resource.c
+++ b/kernel/resource.c
@@ -388,6 +388,8 @@ static int find_next_iomem_res(struct resource *res, char *name,
 		res->start = p->start;
 	if (res->end > p->end)
 		res->end = p->end;
+	res->flags = p->flags;
+	res->desc = p->desc;
 	return 0;
 }
 
@@ -453,6 +455,23 @@ int walk_system_ram_res(u64 start, u64 end, void *arg,
 	return ret;
 }
 
+/*
+ * This function calls the @func callback against all memory ranges, which
+ * are ranges marked as IORESOURCE_MEM and IORESOUCE_BUSY.
+ */
+int walk_mem_res(u64 start, u64 end, void *arg,
+		 int (*func)(struct resource *, void *))
+{
+	struct resource res;
+
+	res.start = start;
+	res.end = end;
+	res.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+
+	return __walk_iomem_res_desc(&res, IORES_DESC_NONE, true,
+				     arg, func);
+}
+
 #if !defined(CONFIG_ARCH_HAS_WALK_MEMORY)
 
 /*
