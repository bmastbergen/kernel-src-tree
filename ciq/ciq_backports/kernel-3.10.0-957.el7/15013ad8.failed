watchdog: Add support for minimum time between heartbeats

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [watchdog] Add support for minimum time between heartbeats (David Arcari) [1576173]
Rebuild_FUZZ: 90.38%
commit-author Guenter Roeck <linux@roeck-us.net>
commit 15013ad813f6544be8e79afc23672745950d59bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/15013ad8.failed

Some watchdogs require a minimum time between heartbeats.
Examples are the watchdogs in DA9062 and AT91SAM9x.

	Signed-off-by: Guenter Roeck <linux@roeck-us.net>
	Signed-off-by: Wim Van Sebroeck <wim@iguana.be>
(cherry picked from commit 15013ad813f6544be8e79afc23672745950d59bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/watchdog/watchdog-kernel-api.txt
#	drivers/watchdog/watchdog_dev.c
#	include/linux/watchdog.h
diff --cc Documentation/watchdog/watchdog-kernel-api.txt
index d8b0d3367706,917eeeabfa5e..000000000000
--- a/Documentation/watchdog/watchdog-kernel-api.txt
+++ b/Documentation/watchdog/watchdog-kernel-api.txt
@@@ -53,8 -52,12 +53,15 @@@ struct watchdog_device 
  	unsigned int timeout;
  	unsigned int min_timeout;
  	unsigned int max_timeout;
++<<<<<<< HEAD
++=======
+ 	unsigned int min_hw_heartbeat_ms;
+ 	unsigned int max_hw_heartbeat_ms;
+ 	struct notifier_block reboot_nb;
+ 	struct notifier_block restart_nb;
++>>>>>>> 15013ad813f6 (watchdog: Add support for minimum time between heartbeats)
  	void *driver_data;
 -	struct watchdog_core_data *wd_data;
 +	struct mutex lock;
  	unsigned long status;
  	struct list_head deferred;
  };
@@@ -73,8 -75,28 +80,30 @@@ It contains following fields
    additional information about the watchdog timer itself. (Like it's unique name)
  * ops: a pointer to the list of watchdog operations that the watchdog supports.
  * timeout: the watchdog timer's timeout value (in seconds).
 -  This is the time after which the system will reboot if user space does
 -  not send a heartbeat request if WDOG_ACTIVE is set.
  * min_timeout: the watchdog timer's minimum timeout value (in seconds).
++<<<<<<< HEAD
 +* max_timeout: the watchdog timer's maximum timeout value (in seconds).
++=======
+   If set, the minimum configurable value for 'timeout'.
+ * max_timeout: the watchdog timer's maximum timeout value (in seconds),
+   as seen from userspace. If set, the maximum configurable value for
+   'timeout'. Not used if max_hw_heartbeat_ms is non-zero.
+ * min_hw_heartbeat_ms: Minimum time between heartbeats sent to the chip,
+   in milli-seconds.
+ * max_hw_heartbeat_ms: Maximum hardware heartbeat, in milli-seconds.
+   If set, the infrastructure will send heartbeats to the watchdog driver
+   if 'timeout' is larger than max_hw_heartbeat_ms, unless WDOG_ACTIVE
+   is set and userspace failed to send a heartbeat for at least 'timeout'
+   seconds. max_hw_heartbeat_ms must be set if a driver does not implement
+   the stop function.
+ * reboot_nb: notifier block that is registered for reboot notifications, for
+   internal use only. If the driver calls watchdog_stop_on_reboot, watchdog core
+   will stop the watchdog on such notifications.
+ * restart_nb: notifier block that is registered for machine restart, for
+   internal use only. If a watchdog is capable of restarting the machine, it
+   should define ops->restart. Priority can be changed through
+   watchdog_set_restart_priority.
++>>>>>>> 15013ad813f6 (watchdog: Add support for minimum time between heartbeats)
  * bootstatus: status of the device after booting (reported with watchdog
    WDIOF_* status bits).
  * driver_data: a pointer to the drivers private data of a watchdog device.
diff --cc drivers/watchdog/watchdog_dev.c
index f06fbcf0bea2,2d6110278eac..000000000000
--- a/drivers/watchdog/watchdog_dev.c
+++ b/drivers/watchdog/watchdog_dev.c
@@@ -44,10 -50,116 +44,123 @@@
  
  #include "watchdog_core.h"
  
++<<<<<<< HEAD
 +/* the dev_t structure to store the dynamically allocated watchdog devices */
 +static dev_t watchdog_devt;
 +/* the watchdog device behind /dev/watchdog */
 +static struct watchdog_device *old_wdd;
++=======
+ /*
+  * struct watchdog_core_data - watchdog core internal data
+  * @kref:	Reference count.
+  * @cdev:	The watchdog's Character device.
+  * @wdd:	Pointer to watchdog device.
+  * @lock:	Lock for watchdog core.
+  * @status:	Watchdog core internal status bits.
+  */
+ struct watchdog_core_data {
+ 	struct kref kref;
+ 	struct cdev cdev;
+ 	struct watchdog_device *wdd;
+ 	struct mutex lock;
+ 	unsigned long last_keepalive;
+ 	unsigned long last_hw_keepalive;
+ 	struct delayed_work work;
+ 	unsigned long status;		/* Internal status bits */
+ #define _WDOG_DEV_OPEN		0	/* Opened ? */
+ #define _WDOG_ALLOW_RELEASE	1	/* Did we receive the magic char ? */
+ };
+ 
+ /* the dev_t structure to store the dynamically allocated watchdog devices */
+ static dev_t watchdog_devt;
+ /* Reference to watchdog device behind /dev/watchdog */
+ static struct watchdog_core_data *old_wd_data;
+ 
+ static struct workqueue_struct *watchdog_wq;
+ 
+ static inline bool watchdog_need_worker(struct watchdog_device *wdd)
+ {
+ 	/* All variables in milli-seconds */
+ 	unsigned int hm = wdd->max_hw_heartbeat_ms;
+ 	unsigned int t = wdd->timeout * 1000;
+ 
+ 	/*
+ 	 * A worker to generate heartbeat requests is needed if all of the
+ 	 * following conditions are true.
+ 	 * - Userspace activated the watchdog.
+ 	 * - The driver provided a value for the maximum hardware timeout, and
+ 	 *   thus is aware that the framework supports generating heartbeat
+ 	 *   requests.
+ 	 * - Userspace requests a longer timeout than the hardware can handle.
+ 	 */
+ 	return hm && ((watchdog_active(wdd) && t > hm) ||
+ 		      (t && !watchdog_active(wdd) && watchdog_hw_running(wdd)));
+ }
+ 
+ static long watchdog_next_keepalive(struct watchdog_device *wdd)
+ {
+ 	struct watchdog_core_data *wd_data = wdd->wd_data;
+ 	unsigned int timeout_ms = wdd->timeout * 1000;
+ 	unsigned long keepalive_interval;
+ 	unsigned long last_heartbeat;
+ 	unsigned long virt_timeout;
+ 	unsigned int hw_heartbeat_ms;
+ 
+ 	virt_timeout = wd_data->last_keepalive + msecs_to_jiffies(timeout_ms);
+ 	hw_heartbeat_ms = min(timeout_ms, wdd->max_hw_heartbeat_ms);
+ 	keepalive_interval = msecs_to_jiffies(hw_heartbeat_ms / 2);
+ 
+ 	if (!watchdog_active(wdd))
+ 		return keepalive_interval;
+ 
+ 	/*
+ 	 * To ensure that the watchdog times out wdd->timeout seconds
+ 	 * after the most recent ping from userspace, the last
+ 	 * worker ping has to come in hw_heartbeat_ms before this timeout.
+ 	 */
+ 	last_heartbeat = virt_timeout - msecs_to_jiffies(hw_heartbeat_ms);
+ 	return min_t(long, last_heartbeat - jiffies, keepalive_interval);
+ }
+ 
+ static inline void watchdog_update_worker(struct watchdog_device *wdd)
+ {
+ 	struct watchdog_core_data *wd_data = wdd->wd_data;
+ 
+ 	if (watchdog_need_worker(wdd)) {
+ 		long t = watchdog_next_keepalive(wdd);
+ 
+ 		if (t > 0)
+ 			mod_delayed_work(watchdog_wq, &wd_data->work, t);
+ 	} else {
+ 		cancel_delayed_work(&wd_data->work);
+ 	}
+ }
+ 
+ static int __watchdog_ping(struct watchdog_device *wdd)
+ {
+ 	struct watchdog_core_data *wd_data = wdd->wd_data;
+ 	unsigned long earliest_keepalive = wd_data->last_hw_keepalive +
+ 				msecs_to_jiffies(wdd->min_hw_heartbeat_ms);
+ 	int err;
+ 
+ 	if (time_is_after_jiffies(earliest_keepalive)) {
+ 		mod_delayed_work(watchdog_wq, &wd_data->work,
+ 				 earliest_keepalive - jiffies);
+ 		return 0;
+ 	}
+ 
+ 	wd_data->last_hw_keepalive = jiffies;
+ 
+ 	if (wdd->ops->ping)
+ 		err = wdd->ops->ping(wdd);  /* ping the watchdog */
+ 	else
+ 		err = wdd->ops->start(wdd); /* restart watchdog */
+ 
+ 	watchdog_update_worker(wdd);
+ 
+ 	return err;
+ }
++>>>>>>> 15013ad813f6 (watchdog: Add support for minimum time between heartbeats)
  
  /*
   *	watchdog_ping: ping the watchdog.
@@@ -628,6 -770,118 +741,121 @@@ static struct miscdevice watchdog_miscd
  };
  
  /*
++<<<<<<< HEAD
++=======
+  *	watchdog_cdev_register: register watchdog character device
+  *	@wdd: watchdog device
+  *	@devno: character device number
+  *
+  *	Register a watchdog character device including handling the legacy
+  *	/dev/watchdog node. /dev/watchdog is actually a miscdevice and
+  *	thus we set it up like that.
+  */
+ 
+ static int watchdog_cdev_register(struct watchdog_device *wdd, dev_t devno)
+ {
+ 	struct watchdog_core_data *wd_data;
+ 	int err;
+ 
+ 	wd_data = kzalloc(sizeof(struct watchdog_core_data), GFP_KERNEL);
+ 	if (!wd_data)
+ 		return -ENOMEM;
+ 	kref_init(&wd_data->kref);
+ 	mutex_init(&wd_data->lock);
+ 
+ 	wd_data->wdd = wdd;
+ 	wdd->wd_data = wd_data;
+ 
+ 	if (!watchdog_wq)
+ 		return -ENODEV;
+ 
+ 	INIT_DELAYED_WORK(&wd_data->work, watchdog_ping_work);
+ 
+ 	if (wdd->id == 0) {
+ 		old_wd_data = wd_data;
+ 		watchdog_miscdev.parent = wdd->parent;
+ 		err = misc_register(&watchdog_miscdev);
+ 		if (err != 0) {
+ 			pr_err("%s: cannot register miscdev on minor=%d (err=%d).\n",
+ 				wdd->info->identity, WATCHDOG_MINOR, err);
+ 			if (err == -EBUSY)
+ 				pr_err("%s: a legacy watchdog module is probably present.\n",
+ 					wdd->info->identity);
+ 			old_wd_data = NULL;
+ 			kfree(wd_data);
+ 			return err;
+ 		}
+ 	}
+ 
+ 	/* Fill in the data structures */
+ 	cdev_init(&wd_data->cdev, &watchdog_fops);
+ 	wd_data->cdev.owner = wdd->ops->owner;
+ 
+ 	/* Add the device */
+ 	err = cdev_add(&wd_data->cdev, devno, 1);
+ 	if (err) {
+ 		pr_err("watchdog%d unable to add device %d:%d\n",
+ 			wdd->id,  MAJOR(watchdog_devt), wdd->id);
+ 		if (wdd->id == 0) {
+ 			misc_deregister(&watchdog_miscdev);
+ 			old_wd_data = NULL;
+ 			kref_put(&wd_data->kref, watchdog_core_data_release);
+ 		}
+ 		return err;
+ 	}
+ 
+ 	/* Record time of most recent heartbeat as 'just before now'. */
+ 	wd_data->last_hw_keepalive = jiffies - 1;
+ 
+ 	/*
+ 	 * If the watchdog is running, prevent its driver from being unloaded,
+ 	 * and schedule an immediate ping.
+ 	 */
+ 	if (watchdog_hw_running(wdd)) {
+ 		__module_get(wdd->ops->owner);
+ 		kref_get(&wd_data->kref);
+ 		queue_delayed_work(watchdog_wq, &wd_data->work, 0);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  *	watchdog_cdev_unregister: unregister watchdog character device
+  *	@watchdog: watchdog device
+  *
+  *	Unregister watchdog character device and if needed the legacy
+  *	/dev/watchdog device.
+  */
+ 
+ static void watchdog_cdev_unregister(struct watchdog_device *wdd)
+ {
+ 	struct watchdog_core_data *wd_data = wdd->wd_data;
+ 
+ 	cdev_del(&wd_data->cdev);
+ 	if (wdd->id == 0) {
+ 		misc_deregister(&watchdog_miscdev);
+ 		old_wd_data = NULL;
+ 	}
+ 
+ 	mutex_lock(&wd_data->lock);
+ 	wd_data->wdd = NULL;
+ 	wdd->wd_data = NULL;
+ 	mutex_unlock(&wd_data->lock);
+ 
+ 	cancel_delayed_work_sync(&wd_data->work);
+ 
+ 	kref_put(&wd_data->kref, watchdog_core_data_release);
+ }
+ 
+ static struct class watchdog_class = {
+ 	.name =		"watchdog",
+ 	.owner =	THIS_MODULE,
+ 	.dev_groups =	wdt_groups,
+ };
+ 
+ /*
++>>>>>>> 15013ad813f6 (watchdog: Add support for minimum time between heartbeats)
   *	watchdog_dev_register: register a watchdog device
   *	@wdd: watchdog device
   *
diff --cc include/linux/watchdog.h
index e90e3ea5ebeb,51732d6c9555..000000000000
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@@ -59,14 -58,25 +59,31 @@@ struct watchdog_ops 
   * @info:	Pointer to a watchdog_info structure.
   * @ops:	Pointer to the list of watchdog operations.
   * @bootstatus:	Status of the watchdog device at boot.
++<<<<<<< HEAD
 + * @timeout:	The watchdog devices timeout value.
 + * @min_timeout:The watchdog devices minimum timeout value.
 + * @max_timeout:The watchdog devices maximum timeout value.
 + * @driver-data:Pointer to the drivers private data.
 + * @lock:	Lock for watchdog core internal use only.
++=======
+  * @timeout:	The watchdog devices timeout value (in seconds).
+  * @min_timeout:The watchdog devices minimum timeout value (in seconds).
+  * @max_timeout:The watchdog devices maximum timeout value (in seconds)
+  *		as configurable from user space. Only relevant if
+  *		max_hw_heartbeat_ms is not provided.
+  * @min_hw_heartbeat_ms:
+  *		Minimum time between heartbeats, in milli-seconds.
+  * @max_hw_heartbeat_ms:
+  *		Hardware limit for maximum timeout, in milli-seconds.
+  *		Replaces max_timeout if specified.
+  * @reboot_nb:	The notifier block to stop watchdog on reboot.
+  * @restart_nb:	The notifier block to register a restart function.
+  * @driver_data:Pointer to the drivers private data.
+  * @wd_data:	Pointer to watchdog core internal data.
++>>>>>>> 15013ad813f6 (watchdog: Add support for minimum time between heartbeats)
   * @status:	Field that contains the devices internal status bits.
 - * @deferred:	Entry in wtd_deferred_reg_list which is used to
 - *		register early initialized watchdogs.
 + * @deferred: entry in wtd_deferred_reg_list which is used to
 + *			   register early initialized watchdogs.
   *
   * The watchdog_device structure contains all information about a
   * watchdog timer device.
@@@ -88,8 -97,12 +105,15 @@@ struct watchdog_device 
  	unsigned int timeout;
  	unsigned int min_timeout;
  	unsigned int max_timeout;
++<<<<<<< HEAD
++=======
+ 	unsigned int min_hw_heartbeat_ms;
+ 	unsigned int max_hw_heartbeat_ms;
+ 	struct notifier_block reboot_nb;
+ 	struct notifier_block restart_nb;
++>>>>>>> 15013ad813f6 (watchdog: Add support for minimum time between heartbeats)
  	void *driver_data;
 -	struct watchdog_core_data *wd_data;
 +	struct mutex lock;
  	unsigned long status;
  /* Bit numbers for status flags */
  #define WDOG_ACTIVE		0	/* Is the watchdog running/active */
* Unmerged path Documentation/watchdog/watchdog-kernel-api.txt
* Unmerged path drivers/watchdog/watchdog_dev.c
* Unmerged path include/linux/watchdog.h
