netfilter: ipset: Split extensions into separate files

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 57982edc2739b4473868e7579c0185270468bae1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/57982edc.failed

Cleanup to separate all extensions into individual files.

Ported from a patch proposed by Sergey Popovich <popovich_sergei@mail.ua>.

	Suggested-by: Sergey Popovich <popovich_sergei@mail.ua>
	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 57982edc2739b4473868e7579c0185270468bae1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/ipset/ip_set.h
diff --cc include/linux/netfilter/ipset/ip_set.h
index 3e9c90cf5227,b5bd0fb3d07b..000000000000
--- a/include/linux/netfilter/ipset/ip_set.h
+++ b/include/linux/netfilter/ipset/ip_set.h
@@@ -190,71 -258,49 +190,83 @@@ struct ip_set 
  	void *data;
  };
  
 +struct ip_set_counter {
 +	atomic64_t bytes;
 +	atomic64_t packets;
 +};
 +
++<<<<<<< HEAD
  static inline void
 -ip_set_ext_destroy(struct ip_set *set, void *data)
 +ip_set_add_bytes(u64 bytes, struct ip_set_counter *counter)
  {
 -	/* Check that the extension is enabled for the set and
 -	 * call it's destroy function for its extension part in data.
 -	 */
 -	if (SET_WITH_COMMENT(set))
 -		ip_set_extensions[IPSET_EXT_ID_COMMENT].destroy(
 -			ext_comment(data, set));
 +	atomic64_add((long long)bytes, &(counter)->bytes);
  }
  
 -static inline int
 -ip_set_put_flags(struct sk_buff *skb, struct ip_set *set)
 +static inline void
 +ip_set_add_packets(u64 packets, struct ip_set_counter *counter)
 +{
 +	atomic64_add((long long)packets, &(counter)->packets);
 +}
 +
 +static inline u64
 +ip_set_get_bytes(const struct ip_set_counter *counter)
  {
 -	u32 cadt_flags = 0;
 -
 -	if (SET_WITH_TIMEOUT(set))
 -		if (unlikely(nla_put_net32(skb, IPSET_ATTR_TIMEOUT,
 -					   htonl(set->timeout))))
 -			return -EMSGSIZE;
 -	if (SET_WITH_COUNTER(set))
 -		cadt_flags |= IPSET_FLAG_WITH_COUNTERS;
 -	if (SET_WITH_COMMENT(set))
 -		cadt_flags |= IPSET_FLAG_WITH_COMMENT;
 -	if (SET_WITH_SKBINFO(set))
 -		cadt_flags |= IPSET_FLAG_WITH_SKBINFO;
 -	if (SET_WITH_FORCEADD(set))
 -		cadt_flags |= IPSET_FLAG_WITH_FORCEADD;
 -
 -	if (!cadt_flags)
 -		return 0;
 -	return nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(cadt_flags));
 +	return (u64)atomic64_read(&(counter)->bytes);
  }
  
 +static inline u64
 +ip_set_get_packets(const struct ip_set_counter *counter)
 +{
 +	return (u64)atomic64_read(&(counter)->packets);
 +}
 +
 +static inline void
 +ip_set_update_counter(struct ip_set_counter *counter,
 +		      const struct ip_set_ext *ext,
 +		      struct ip_set_ext *mext, u32 flags)
 +{
 +	if (ext->packets != ULLONG_MAX &&
 +	    !(flags & IPSET_FLAG_SKIP_COUNTER_UPDATE)) {
 +		ip_set_add_bytes(ext->bytes, counter);
 +		ip_set_add_packets(ext->packets, counter);
 +	}
 +	if (flags & IPSET_FLAG_MATCH_COUNTERS) {
 +		mext->packets = ip_set_get_packets(counter);
 +		mext->bytes = ip_set_get_bytes(counter);
 +	}
 +}
 +
 +static inline bool
 +ip_set_put_counter(struct sk_buff *skb, struct ip_set_counter *counter)
 +{
 +	return nla_put_net64(skb, IPSET_ATTR_BYTES,
 +			     cpu_to_be64(ip_set_get_bytes(counter)),
 +			     IPSET_ATTR_PAD) ||
 +	       nla_put_net64(skb, IPSET_ATTR_PACKETS,
 +			     cpu_to_be64(ip_set_get_packets(counter)),
 +			     IPSET_ATTR_PAD);
 +}
 +
 +static inline void
 +ip_set_init_counter(struct ip_set_counter *counter,
 +		    const struct ip_set_ext *ext)
 +{
 +	if (ext->bytes != ULLONG_MAX)
 +		atomic64_set(&(counter)->bytes, (long long)(ext->bytes));
 +	if (ext->packets != ULLONG_MAX)
 +		atomic64_set(&(counter)->packets, (long long)(ext->packets));
 +}
++=======
+ /* Netlink CB args */
+ enum {
+ 	IPSET_CB_NET = 0,	/* net namespace */
+ 	IPSET_CB_DUMP,		/* dump single set/all sets */
+ 	IPSET_CB_INDEX,		/* set index */
+ 	IPSET_CB_PRIVATE,	/* set private data */
+ 	IPSET_CB_ARG0,		/* type specific */
+ 	IPSET_CB_ARG1,
+ };
++>>>>>>> 57982edc2739 (netfilter: ipset: Split extensions into separate files)
  
  /* register and unregister set references */
  extern ip_set_id_t ip_set_get_byname(struct net *net,
@@@ -397,14 -445,21 +409,20 @@@ bitmap_bytes(u32 a, u32 b
  }
  
  #include <linux/netfilter/ipset/ip_set_timeout.h>
++<<<<<<< HEAD
++=======
+ #include <linux/netfilter/ipset/ip_set_comment.h>
+ #include <linux/netfilter/ipset/ip_set_counter.h>
+ #include <linux/netfilter/ipset/ip_set_skbinfo.h>
++>>>>>>> 57982edc2739 (netfilter: ipset: Split extensions into separate files)
  
 -int
 -ip_set_put_extensions(struct sk_buff *skb, const struct ip_set *set,
 -		      const void *e, bool active);
 -
 -#define IP_SET_INIT_KEXT(skb, opt, set)			\
 +#define IP_SET_INIT_KEXT(skb, opt, map)			\
  	{ .bytes = (skb)->len, .packets = 1,		\
 -	  .timeout = ip_set_adt_opt_timeout(opt, set) }
 +	  .timeout = ip_set_adt_opt_timeout(opt, map) }
  
 -#define IP_SET_INIT_UEXT(set)				\
 +#define IP_SET_INIT_UEXT(map)				\
  	{ .bytes = ULLONG_MAX, .packets = ULLONG_MAX,	\
 -	  .timeout = (set)->timeout }
 +	  .timeout = (map)->timeout }
  
  #define IPSET_CONCAT(a, b)		a##b
  #define IPSET_TOKEN(a, b)		IPSET_CONCAT(a, b)
* Unmerged path include/linux/netfilter/ipset/ip_set.h
diff --git a/include/linux/netfilter/ipset/ip_set_counter.h b/include/linux/netfilter/ipset/ip_set_counter.h
new file mode 100644
index 000000000000..bb6fba480118
--- /dev/null
+++ b/include/linux/netfilter/ipset/ip_set_counter.h
@@ -0,0 +1,75 @@
+#ifndef _IP_SET_COUNTER_H
+#define _IP_SET_COUNTER_H
+
+/* Copyright (C) 2015 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifdef __KERNEL__
+
+static inline void
+ip_set_add_bytes(u64 bytes, struct ip_set_counter *counter)
+{
+	atomic64_add((long long)bytes, &(counter)->bytes);
+}
+
+static inline void
+ip_set_add_packets(u64 packets, struct ip_set_counter *counter)
+{
+	atomic64_add((long long)packets, &(counter)->packets);
+}
+
+static inline u64
+ip_set_get_bytes(const struct ip_set_counter *counter)
+{
+	return (u64)atomic64_read(&(counter)->bytes);
+}
+
+static inline u64
+ip_set_get_packets(const struct ip_set_counter *counter)
+{
+	return (u64)atomic64_read(&(counter)->packets);
+}
+
+static inline void
+ip_set_update_counter(struct ip_set_counter *counter,
+		      const struct ip_set_ext *ext,
+		      struct ip_set_ext *mext, u32 flags)
+{
+	if (ext->packets != ULLONG_MAX &&
+	    !(flags & IPSET_FLAG_SKIP_COUNTER_UPDATE)) {
+		ip_set_add_bytes(ext->bytes, counter);
+		ip_set_add_packets(ext->packets, counter);
+	}
+	if (flags & IPSET_FLAG_MATCH_COUNTERS) {
+		mext->packets = ip_set_get_packets(counter);
+		mext->bytes = ip_set_get_bytes(counter);
+	}
+}
+
+static inline bool
+ip_set_put_counter(struct sk_buff *skb, const struct ip_set_counter *counter)
+{
+	return nla_put_net64(skb, IPSET_ATTR_BYTES,
+			     cpu_to_be64(ip_set_get_bytes(counter)),
+			     IPSET_ATTR_PAD) ||
+	       nla_put_net64(skb, IPSET_ATTR_PACKETS,
+			     cpu_to_be64(ip_set_get_packets(counter)),
+			     IPSET_ATTR_PAD);
+}
+
+static inline void
+ip_set_init_counter(struct ip_set_counter *counter,
+		    const struct ip_set_ext *ext)
+{
+	if (ext->bytes != ULLONG_MAX)
+		atomic64_set(&(counter)->bytes, (long long)(ext->bytes));
+	if (ext->packets != ULLONG_MAX)
+		atomic64_set(&(counter)->packets, (long long)(ext->packets));
+}
+
+#endif /* __KERNEL__ */
+#endif /* _IP_SET_COUNTER_H */
diff --git a/include/linux/netfilter/ipset/ip_set_skbinfo.h b/include/linux/netfilter/ipset/ip_set_skbinfo.h
new file mode 100644
index 000000000000..29d7ef2bc3fa
--- /dev/null
+++ b/include/linux/netfilter/ipset/ip_set_skbinfo.h
@@ -0,0 +1,46 @@
+#ifndef _IP_SET_SKBINFO_H
+#define _IP_SET_SKBINFO_H
+
+/* Copyright (C) 2015 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifdef __KERNEL__
+
+static inline void
+ip_set_get_skbinfo(struct ip_set_skbinfo *skbinfo,
+		   const struct ip_set_ext *ext,
+		   struct ip_set_ext *mext, u32 flags)
+{
+	mext->skbinfo = *skbinfo;
+}
+
+static inline bool
+ip_set_put_skbinfo(struct sk_buff *skb, const struct ip_set_skbinfo *skbinfo)
+{
+	/* Send nonzero parameters only */
+	return ((skbinfo->skbmark || skbinfo->skbmarkmask) &&
+		nla_put_net64(skb, IPSET_ATTR_SKBMARK,
+			      cpu_to_be64((u64)skbinfo->skbmark << 32 |
+					  skbinfo->skbmarkmask),
+			      IPSET_ATTR_PAD)) ||
+	       (skbinfo->skbprio &&
+		nla_put_net32(skb, IPSET_ATTR_SKBPRIO,
+			      cpu_to_be32(skbinfo->skbprio))) ||
+	       (skbinfo->skbqueue &&
+		nla_put_net16(skb, IPSET_ATTR_SKBQUEUE,
+			      cpu_to_be16(skbinfo->skbqueue)));
+}
+
+static inline void
+ip_set_init_skbinfo(struct ip_set_skbinfo *skbinfo,
+		    const struct ip_set_ext *ext)
+{
+	*skbinfo = ext->skbinfo;
+}
+
+#endif /* __KERNEL__ */
+#endif /* _IP_SET_SKBINFO_H */
