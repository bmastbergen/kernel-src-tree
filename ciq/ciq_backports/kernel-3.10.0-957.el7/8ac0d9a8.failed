elevator: allow name aliases

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jens Axboe <axboe@kernel.dk>
commit 8ac0d9a81edf2ef4a2268b65b802a6b856dc77e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8ac0d9a8.failed

Since we now lookup elevator types with the appropriate multiqueue
capability, allow schedulers to register with an alias alongside
the real name. This is in preparation for allowing 'mq-deadline'
to register an alias of 'deadline' as well.

	Reviewed-by: Omar Sandoval <osandov@fb.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 8ac0d9a81edf2ef4a2268b65b802a6b856dc77e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/elevator.c
diff --cc block/elevator.c
index a19fdd6f2df1,7bda083d5968..000000000000
--- a/block/elevator.c
+++ b/block/elevator.c
@@@ -83,11 -83,15 +83,23 @@@ bool elv_bio_merge_ok(struct request *r
  }
  EXPORT_SYMBOL(elv_bio_merge_ok);
  
++<<<<<<< HEAD
 +bool elv_rq_merge_ok(struct request *rq, struct bio *bio)
 +{
 +	return elv_bio_merge_ok(rq, bio);
 +}
 +EXPORT_SYMBOL(elv_rq_merge_ok);
++=======
+ static bool elevator_match(const struct elevator_type *e, const char *name)
+ {
+ 	if (!strcmp(e->elevator_name, name))
+ 		return true;
+ 	if (e->elevator_alias && !strcmp(e->elevator_alias, name))
+ 		return true;
+ 
+ 	return false;
+ }
++>>>>>>> 8ac0d9a81edf (elevator: allow name aliases)
  
  /*
   * Return scheduler with name 'name' and with matching 'mq capability
@@@ -97,8 -101,7 +109,12 @@@ static struct elevator_type *elevator_f
  	struct elevator_type *e;
  
  	list_for_each_entry(e, &elv_list, list) {
++<<<<<<< HEAD
 +		if (!strcmp(e->elevator_name, name) &&
 +				(mq == !e->ops.elevator_init_fn))
++=======
+ 		if (elevator_match(e, name) && (mq == e->uses_mq))
++>>>>>>> 8ac0d9a81edf (elevator: allow name aliases)
  			return e;
  	}
  
@@@ -997,12 -932,10 +1013,12 @@@ int elv_register(struct elevator_type *
  	spin_unlock(&elv_list_lock);
  
  	/* print pretty message */
- 	if (!strcmp(e->elevator_name, chosen_elevator) ||
+ 	if (elevator_match(e, chosen_elevator) ||
  			(!*chosen_elevator &&
- 			 !strcmp(e->elevator_name, CONFIG_DEFAULT_IOSCHED)))
+ 			 elevator_match(e, CONFIG_DEFAULT_IOSCHED)))
  				def = " (default)";
 +	if (elv_aux_register(e))
 +		return -ENOMEM;
  
  	printk(KERN_INFO "io scheduler %s registered%s\n", e->elevator_name,
  								def);
@@@ -1203,9 -1123,10 +1218,10 @@@ ssize_t elv_iosched_show(struct request
  	struct elevator_queue *e = q->elevator;
  	struct elevator_type *elv = NULL;
  	struct elevator_type *__e;
+ 	bool uses_mq = q->mq_ops != NULL;
  	int len = 0;
  
 -	if (!queue_is_rq_based(q))
 +	if (!blk_queue_stackable(q))
  		return sprintf(name, "none\n");
  
  	if (!q->elevator)
@@@ -1215,9 -1136,8 +1231,14 @@@
  
  	spin_lock(&elv_list_lock);
  	list_for_each_entry(__e, &elv_list, list) {
++<<<<<<< HEAD
 +		struct elevator_type_aux *aux;
 +
 +		if (elv && !strcmp(elv->elevator_name, __e->elevator_name)) {
++=======
+ 		if (elv && elevator_match(elv, __e->elevator_name) &&
+ 		    (__e->uses_mq == uses_mq)) {
++>>>>>>> 8ac0d9a81edf (elevator: allow name aliases)
  			len += sprintf(name+len, "[%s] ", elv->elevator_name);
  			continue;
  		}
* Unmerged path block/elevator.c
diff --git a/include/linux/elevator.h b/include/linux/elevator.h
index 666c848eba47..8ff567c30439 100644
--- a/include/linux/elevator.h
+++ b/include/linux/elevator.h
@@ -180,6 +180,7 @@ struct elevator_type
 	size_t icq_align;	/* ditto */
 	struct elv_fs_entry *elevator_attrs;
 	char elevator_name[ELV_NAME_MAX];
+	const char *elevator_alias;
 	struct module *elevator_owner;
 
 	/* managed by elevator core */
