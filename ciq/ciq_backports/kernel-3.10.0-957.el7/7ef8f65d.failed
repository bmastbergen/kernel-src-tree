net: ipmr: fix code and comment style

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] ipmr: fix code and comment style (Ivan Vecera) [1584232]
Rebuild_FUZZ: 92.75%
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit 7ef8f65df976369588fa1b6466668b1b6a26eb3c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7ef8f65d.failed

Trivial code and comment style fixes, also removed some extra newlines,
spaces and tabs.

	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7ef8f65df976369588fa1b6466668b1b6a26eb3c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ipmr.c
diff --cc net/ipv4/ipmr.c
index cacb0d4bd4b6,286ede3716ee..000000000000
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@@ -543,6 -549,50 +540,53 @@@ failure
  	unregister_netdevice(dev);
  	return NULL;
  }
++<<<<<<< HEAD
++=======
+ 
+ /* called with rcu_read_lock() */
+ static int __pim_rcv(struct mr_table *mrt, struct sk_buff *skb,
+ 		     unsigned int pimlen)
+ {
+ 	struct net_device *reg_dev = NULL;
+ 	struct iphdr *encap;
+ 
+ 	encap = (struct iphdr *)(skb_transport_header(skb) + pimlen);
+ 	/* Check that:
+ 	 * a. packet is really sent to a multicast group
+ 	 * b. packet is not a NULL-REGISTER
+ 	 * c. packet is not truncated
+ 	 */
+ 	if (!ipv4_is_multicast(encap->daddr) ||
+ 	    encap->tot_len == 0 ||
+ 	    ntohs(encap->tot_len) + pimlen > skb->len)
+ 		return 1;
+ 
+ 	read_lock(&mrt_lock);
+ 	if (mrt->mroute_reg_vif_num >= 0)
+ 		reg_dev = mrt->vif_table[mrt->mroute_reg_vif_num].dev;
+ 	read_unlock(&mrt_lock);
+ 
+ 	if (!reg_dev)
+ 		return 1;
+ 
+ 	skb->mac_header = skb->network_header;
+ 	skb_pull(skb, (u8 *)encap - skb->data);
+ 	skb_reset_network_header(skb);
+ 	skb->protocol = htons(ETH_P_IP);
+ 	skb->ip_summed = CHECKSUM_NONE;
+ 
+ 	skb_tunnel_rx(skb, reg_dev, dev_net(reg_dev));
+ 
+ 	netif_rx(skb);
+ 
+ 	return NET_RX_SUCCESS;
+ }
+ #else
+ static struct net_device *ipmr_reg_vif(struct net *net, struct mr_table *mrt)
+ {
+ 	return NULL;
+ }
++>>>>>>> 7ef8f65df976 (net: ipmr: fix code and comment style)
  #endif
  
  /**
@@@ -910,11 -947,9 +943,10 @@@ static void ipmr_cache_resolve(struct n
  	struct nlmsgerr *e;
  
  	/* Play the pending entries through our router */
- 
  	while ((skb = __skb_dequeue(&uc->mfc_un.unres.unresolved))) {
  		if (ip_hdr(skb)->version == 0) {
 -			struct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct iphdr));
 +			struct nlmsghdr *nlh = skb_pull(skb,
 +							sizeof(struct iphdr));
  
  			if (__ipmr_fill_mroute(mrt, skb, c, nlmsg_data(nlh)) > 0) {
  				nlh->nlmsg_len = skb_tail_pointer(skb) -
@@@ -1198,30 -1212,24 +1220,33 @@@ static int ipmr_mfc_add(struct net *net
  	return 0;
  }
  
++<<<<<<< HEAD
 +/*
 + *	Close the multicast socket, and clear the vif tables etc
 + */
 +
 +static void mroute_clean_tables(struct mr_table *mrt, bool all)
++=======
+ /* Close the multicast socket, and clear the vif tables etc */
+ static void mroute_clean_tables(struct mr_table *mrt)
++>>>>>>> 7ef8f65df976 (net: ipmr: fix code and comment style)
  {
  	int i;
  	LIST_HEAD(list);
  	struct mfc_cache *c, *next;
  
  	/* Shut down all active vif entries */
- 
  	for (i = 0; i < mrt->maxvif; i++) {
 -		if (!(mrt->vif_table[i].flags & VIFF_STATIC))
 -			vif_delete(mrt, i, 0, &list);
 +		if (!all && (mrt->vif_table[i].flags & VIFF_STATIC))
 +			continue;
 +		vif_delete(mrt, i, 0, &list);
  	}
  	unregister_netdevice_many(&list);
  
  	/* Wipe the cache */
- 
  	for (i = 0; i < MFC_LINES; i++) {
  		list_for_each_entry_safe(c, next, &mrt->mfc_cache_array[i], list) {
 -			if (c->mfc_flags & MFC_STATIC)
 +			if (!all && (c->mfc_flags & MFC_STATIC))
  				continue;
  			list_del_rcu(&c->list);
  			mroute_netlink_event(mrt, c, RTM_DELROUTE);
@@@ -1684,12 -1671,10 +1692,10 @@@ static inline int ipmr_forward_finish(s
  	if (unlikely(opt->optlen))
  		ip_forward_options(skb);
  
 -	return dst_output(net, sk, skb);
 +	return dst_output_sk(sk, skb);
  }
  
- /*
-  *	Processing handlers for ipmr_forward
-  */
+ /* Processing handlers for ipmr_forward */
  
  static void ipmr_queue_xmit(struct net *net, struct mr_table *mrt,
  			    struct sk_buff *skb, struct mfc_cache *c, int vifi)
@@@ -1740,8 -1723,7 +1746,12 @@@
  		 * allow to send ICMP, so that packets will disappear
  		 * to blackhole.
  		 */
++<<<<<<< HEAD
 +
 +		IP_INC_STATS_BH(net, IPSTATS_MIB_FRAGFAILS);
++=======
+ 		IP_INC_STATS(net, IPSTATS_MIB_FRAGFAILS);
++>>>>>>> 7ef8f65df976 (net: ipmr: fix code and comment style)
  		ip_rt_put(rt);
  		goto out_free;
  	}
@@@ -2001,10 -1975,8 +2003,15 @@@ int ip_mr_input(struct sk_buff *skb
  						    vif);
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 *	No usable cache entry
 +	 */
 +	if (cache == NULL) {
++=======
+ 	/* No usable cache entry */
+ 	if (!cache) {
++>>>>>>> 7ef8f65df976 (net: ipmr: fix code and comment style)
  		int vif;
  
  		if (local) {
@@@ -2044,53 -2016,8 +2051,50 @@@ dont_forward
  	return 0;
  }
  
 +#ifdef CONFIG_IP_PIMSM
 +/* called with rcu_read_lock() */
 +static int __pim_rcv(struct mr_table *mrt, struct sk_buff *skb,
 +		     unsigned int pimlen)
 +{
 +	struct net_device *reg_dev = NULL;
 +	struct iphdr *encap;
 +
 +	encap = (struct iphdr *)(skb_transport_header(skb) + pimlen);
 +	/*
 +	 * Check that:
 +	 * a. packet is really sent to a multicast group
 +	 * b. packet is not a NULL-REGISTER
 +	 * c. packet is not truncated
 +	 */
 +	if (!ipv4_is_multicast(encap->daddr) ||
 +	    encap->tot_len == 0 ||
 +	    ntohs(encap->tot_len) + pimlen > skb->len)
 +		return 1;
 +
 +	read_lock(&mrt_lock);
 +	if (mrt->mroute_reg_vif_num >= 0)
 +		reg_dev = mrt->vif_table[mrt->mroute_reg_vif_num].dev;
 +	read_unlock(&mrt_lock);
 +
 +	if (reg_dev == NULL)
 +		return 1;
 +
 +	skb->mac_header = skb->network_header;
 +	skb_pull(skb, (u8 *)encap - skb->data);
 +	skb_reset_network_header(skb);
 +	skb->protocol = htons(ETH_P_IP);
 +	skb->ip_summed = CHECKSUM_NONE;
 +
 +	skb_tunnel_rx(skb, reg_dev, dev_net(reg_dev));
 +
 +	netif_rx(skb);
 +
 +	return NET_RX_SUCCESS;
 +}
 +#endif
 +
  #ifdef CONFIG_IP_PIMSM_V1
- /*
-  * Handle IGMP messages of PIMv1
-  */
- 
+ /* Handle IGMP messages of PIMv1 */
  int pim_rcv_v1(struct sk_buff *skb)
  {
  	struct igmphdr *pim;
diff --git a/include/uapi/linux/mroute.h b/include/uapi/linux/mroute.h
index a382d2c04a42..cf943016930f 100644
--- a/include/uapi/linux/mroute.h
+++ b/include/uapi/linux/mroute.h
@@ -4,15 +4,13 @@
 #include <linux/sockios.h>
 #include <linux/types.h>
 
-/*
- *	Based on the MROUTING 3.5 defines primarily to keep
- *	source compatibility with BSD.
+/* Based on the MROUTING 3.5 defines primarily to keep
+ * source compatibility with BSD.
  *
- *	See the mrouted code for the original history.
- *
- *      Protocol Independent Multicast (PIM) data structures included
- *      Carlos Picoto (cap@di.fc.ul.pt)
+ * See the mrouted code for the original history.
  *
+ * Protocol Independent Multicast (PIM) data structures included
+ * Carlos Picoto (cap@di.fc.ul.pt)
  */
 
 #define MRT_BASE	200
@@ -34,15 +32,13 @@
 #define SIOCGETSGCNT	(SIOCPROTOPRIVATE+1)
 #define SIOCGETRPF	(SIOCPROTOPRIVATE+2)
 
-#define MAXVIFS		32	
+#define MAXVIFS		32
 typedef unsigned long vifbitmap_t;	/* User mode code depends on this lot */
 typedef unsigned short vifi_t;
 #define ALL_VIFS	((vifi_t)(-1))
 
-/*
- *	Same idea as select
- */
- 
+/* Same idea as select */
+
 #define VIFM_SET(n,m)	((m)|=(1<<(n)))
 #define VIFM_CLR(n,m)	((m)&=~(1<<(n)))
 #define VIFM_ISSET(n,m)	((m)&(1<<(n)))
@@ -50,11 +46,9 @@ typedef unsigned short vifi_t;
 #define VIFM_COPY(mfrom,mto)	((mto)=(mfrom))
 #define VIFM_SAME(m1,m2)	((m1)==(m2))
 
-/*
- *	Passed by mrouted for an MRT_ADD_VIF - again we use the
- *	mrouted 3.6 structures for compatibility
+/* Passed by mrouted for an MRT_ADD_VIF - again we use the
+ * mrouted 3.6 structures for compatibility
  */
- 
 struct vifctl {
 	vifi_t	vifc_vifi;		/* Index of VIF */
 	unsigned char vifc_flags;	/* VIFF_ flags */
@@ -73,10 +67,7 @@ struct vifctl {
 #define VIFF_USE_IFINDEX	0x8	/* use vifc_lcl_ifindex instead of
 					   vifc_lcl_addr to find an interface */
 
-/*
- *	Cache manipulation structures for mrouted and PIMd
- */
- 
+/* Cache manipulation structures for mrouted and PIMd */
 struct mfcctl {
 	struct in_addr mfcc_origin;		/* Origin of mcast	*/
 	struct in_addr mfcc_mcastgrp;		/* Group in question	*/
@@ -88,10 +79,7 @@ struct mfcctl {
 	int	     mfcc_expire;
 };
 
-/* 
- *	Group count retrieval for mrouted
- */
- 
+/*  Group count retrieval for mrouted */
 struct sioc_sg_req {
 	struct in_addr src;
 	struct in_addr grp;
@@ -100,10 +88,7 @@ struct sioc_sg_req {
 	unsigned long wrong_if;
 };
 
-/*
- *	To get vif packet counts
- */
-
+/* To get vif packet counts */
 struct sioc_vif_req {
 	vifi_t	vifi;		/* Which iface */
 	unsigned long icount;	/* In packets */
@@ -112,11 +97,9 @@ struct sioc_vif_req {
 	unsigned long obytes;	/* Out bytes */
 };
 
-/*
- *	This is the format the mroute daemon expects to see IGMP control
- *	data. Magically happens to be like an IP packet as per the original
+/* This is the format the mroute daemon expects to see IGMP control
+ * data. Magically happens to be like an IP packet as per the original
  */
- 
 struct igmpmsg {
 	__u32 unused1,unused2;
 	unsigned char im_msgtype;		/* What is this */
@@ -126,21 +109,13 @@ struct igmpmsg {
 	struct in_addr im_src,im_dst;
 };
 
-/*
- *	That's all usermode folks
- */
-
-
+/* That's all usermode folks */
 
 #define MFC_ASSERT_THRESH (3*HZ)		/* Maximal freq. of asserts */
 
-/*
- *	Pseudo messages used by mrouted
- */
-
+/* Pseudo messages used by mrouted */
 #define IGMPMSG_NOCACHE		1		/* Kern cache fill request to mrouted */
 #define IGMPMSG_WRONGVIF	2		/* For PIM assert processing (unused) */
 #define IGMPMSG_WHOLEPKT	3		/* For PIM Register processing */
 
-
 #endif /* _UAPI__LINUX_MROUTE_H */
* Unmerged path net/ipv4/ipmr.c
