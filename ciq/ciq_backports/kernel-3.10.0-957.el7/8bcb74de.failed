mm: hwpoison: call shake_page() unconditionally

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mm] hwpoison: call shake_page() unconditionally (Aristeu Rozanski) [1525701]
Rebuild_FUZZ: 95.56%
commit-author Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
commit 8bcb74de764aaa261d6af3ce5ac723e435f00ff4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8bcb74de.failed

shake_page() is called before going into core error handling code in
order to ensure that the error page is flushed from lru_cache lists
where pages stay during transferring among LRU lists.

But currently it's not fully functional because when the page is linked
to lru_cache by calling activate_page(), its PageLRU flag is set and
shake_page() is skipped.  The result is to fail error handling with
"still referenced by 1 users" message.

When the page is linked to lru_cache by isolate_lru_page(), its PageLRU
is clear, so that's fine.

This patch makes shake_page() unconditionally called to avoild the
failure.

Fixes: 23a003bfd23ea9ea0b7756b920e51f64b284b468 ("mm/madvise: pass return code of memory_failure() to userspace")
Link: http://lkml.kernel.org/r/20170417055948.GM31394@yexl-desktop
Link: http://lkml.kernel.org/r/1493197841-23986-2-git-send-email-n-horiguchi@ah.jp.nec.com
	Signed-off-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Reported-by: kernel test robot <lkp@intel.com>
	Cc: Xiaolong Ye <xiaolong.ye@intel.com>
	Cc: Chen Gong <gong.chen@linux.intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8bcb74de764aaa261d6af3ce5ac723e435f00ff4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory-failure.c
diff --cc mm/memory-failure.c
index f00ac116a6dd,9d87fcab96c9..000000000000
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@@ -1159,28 -1140,16 +1162,39 @@@ int memory_failure(unsigned long pfn, i
  	 * The check (unnecessarily) ignores LRU pages being isolated and
  	 * walked by the page reclaim code, however that's not a big loss.
  	 */
++<<<<<<< HEAD
 +	if (!PageHuge(p)) {
 +		if (!PageLRU(p))
 +			shake_page(p, 0);
 +		if (!PageLRU(p)) {
 +			/*
 +			 * shake_page could have turned it free.
 +			 */
 +			if (is_free_buddy_page(p)) {
 +				if (flags & MF_COUNT_INCREASED)
 +					action_result(pfn, "free buddy", DELAYED);
 +				else
 +					action_result(pfn, "free buddy, 2nd try", DELAYED);
 +				return 0;
 +			}
 +		}
++=======
+ 	shake_page(p, 0);
+ 	/* shake_page could have turned it free. */
+ 	if (!PageLRU(p) && is_free_buddy_page(p)) {
+ 		if (flags & MF_COUNT_INCREASED)
+ 			action_result(pfn, MF_MSG_BUDDY, MF_DELAYED);
+ 		else
+ 			action_result(pfn, MF_MSG_BUDDY_2ND, MF_DELAYED);
+ 		return 0;
++>>>>>>> 8bcb74de764a (mm: hwpoison: call shake_page() unconditionally)
  	}
  
 +	/*
 +	 * Lock the page and wait for writeback to finish.
 +	 * It's very difficult to mess with pages currently under IO
 +	 * and in many cases impossible, so we just avoid it here.
 +	 */
  	lock_page(hpage);
  
  	/*
diff --git a/mm/hwpoison-inject.c b/mm/hwpoison-inject.c
index 337cc4d7a739..93cb76f3793e 100644
--- a/mm/hwpoison-inject.c
+++ b/mm/hwpoison-inject.c
@@ -34,8 +34,7 @@ static int hwpoison_inject(void *data, u64 val)
 	if (!hwpoison_filter_enable)
 		goto inject;
 
-	if (!PageLRU(hpage) && !PageHuge(p))
-		shake_page(hpage, 0);
+	shake_page(hpage, 0);
 	/*
 	 * This implies unable to support non-LRU pages.
 	 */
* Unmerged path mm/memory-failure.c
