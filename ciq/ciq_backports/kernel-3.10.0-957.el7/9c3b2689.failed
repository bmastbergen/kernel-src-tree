drm/i915/cnl: Map VBT DDC Pin to BSpec DDC Pin.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [gpu] drm/i915/cnl: Map VBT DDC Pin to BSpec DDC Pin (Rob Clark) [1464911]
Rebuild_FUZZ: 98.92%
commit-author Rodrigo Vivi <rodrigo.vivi@intel.com>
commit 9c3b2689d01ff03e2b8e8d47538881dbff756d78
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9c3b2689.failed

Starting on CNL we now need to map VBT DDC Pin to
BSPec DDC Pin values. Not a direct translation anymore.

According to VBT
Block 2 (General Bytes Definition)
DDC Bus

+----------+-----------+--------------------+
| DDI Type | VBT Value | Bspec Mapped Value |
+----------+-----------+--------------------+
| DDI-B    | 0x1       | 0x1                |
| DDI-C    | 0x2       | 0x2                |
| DDI-D    | 0x3       | 0x4                |
| DDI-F    | 0x4       | 0x3                |
+----------+-----------+--------------------+

v2: Move defines to a better place.
    This is actually CNL_PCH not CNL only.
v3: Accepting Ville's suggestions: enums and array to
    to make this future proof.
v4: Protect the array access as Ville suggested.
    Also accepting all Jani's suggestions:
    	      - use already defined gmbus pin definitions.
	      - use map_ddc_pin for disambiguation.
	      - Add /* sic */ comment on inverted values
	      	so people can easily see it it nos a mistake
		we have the map 3 -> 4 and 4 -> 3 :/

	Cc: Jani Nikula <jani.nikula@intel.com>
	Cc: Paulo Zanoni <paulo.r.zanoni@intel.com>
	Cc: Anusha Srivatsa <anusha.srivatsa@intel.com>
	Cc: Clinton Taylor <clinton.a.taylor@intel.com>
	Cc: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
	Reviewed-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20171020172641.16029-1-rodrigo.vivi@intel.com
(cherry picked from commit 9c3b2689d01ff03e2b8e8d47538881dbff756d78)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_vbt_defs.h
diff --cc drivers/gpu/drm/i915/intel_vbt_defs.h
index a92e7762f596,f225c288a121..000000000000
--- a/drivers/gpu/drm/i915/intel_vbt_defs.h
+++ b/drivers/gpu/drm/i915/intel_vbt_defs.h
@@@ -230,43 -285,82 +230,75 @@@ struct bdb_general_features 
  #define DEVICE_PORT_DVOB	0x01
  #define DEVICE_PORT_DVOC	0x02
  
++<<<<<<< HEAD
++=======
+ /* dvo_port BDB 155+ */
+ #define DVO_PORT_HDMIA		0
+ #define DVO_PORT_HDMIB		1
+ #define DVO_PORT_HDMIC		2
+ #define DVO_PORT_HDMID		3
+ #define DVO_PORT_LVDS		4
+ #define DVO_PORT_TV		5
+ #define DVO_PORT_CRT		6
+ #define DVO_PORT_DPB		7
+ #define DVO_PORT_DPC		8
+ #define DVO_PORT_DPD		9
+ #define DVO_PORT_DPA		10
+ #define DVO_PORT_DPE		11				/* 193 */
+ #define DVO_PORT_HDMIE		12				/* 193 */
+ #define DVO_PORT_MIPIA		21				/* 171 */
+ #define DVO_PORT_MIPIB		22				/* 171 */
+ #define DVO_PORT_MIPIC		23				/* 171 */
+ #define DVO_PORT_MIPID		24				/* 171 */
+ 
+ #define LEGACY_CHILD_DEVICE_CONFIG_SIZE		33
+ 
+ /* DDC Bus DDI Type 155+ */
+ enum vbt_gmbus_ddi {
+ 	DDC_BUS_DDI_B = 0x1,
+ 	DDC_BUS_DDI_C,
+ 	DDC_BUS_DDI_D,
+ 	DDC_BUS_DDI_F,
+ };
+ 
++>>>>>>> 9c3b2689d01f (drm/i915/cnl: Map VBT DDC Pin to BSpec DDC Pin.)
  /*
 - * The child device config, aka the display device data structure, provides a
 - * description of a port and its configuration on the platform.
 - *
 - * The child device config size has been increased, and fields have been added
 - * and their meaning has changed over time. Care must be taken when accessing
 - * basically any of the fields to ensure the correct interpretation for the BDB
 - * version in question.
 - *
 - * When we copy the child device configs to dev_priv->vbt.child_dev, we reserve
 - * space for the full structure below, and initialize the tail not actually
 - * present in VBT to zeros. Accessing those fields is fine, as long as the
 - * default zero is taken into account, again according to the BDB version.
 - *
 - * BDB versions 155 and below are considered legacy, and version 155 seems to be
 - * a baseline for some of the VBT documentation. When adding new fields, please
 - * include the BDB version when the field was added, if it's above that.
 + * We used to keep this struct but without any version control. We should avoid
 + * using it in the future, but it should be safe to keep using it in the old
 + * code. Do not change; we rely on its size.
   */
 -struct child_device_config {
 +struct old_child_dev_config {
  	u16 handle;
 -	u16 device_type; /* See DEVICE_TYPE_* above */
 -
 -	union {
 -		u8  device_id[10]; /* ascii string */
 -		struct {
 -			u8 i2c_speed;
 -			u8 dp_onboard_redriver;			/* 158 */
 -			u8 dp_ondock_redriver;			/* 158 */
 -			u8 hdmi_level_shifter_value:4;		/* 169 */
 -			u8 hdmi_max_data_rate:4;		/* 204 */
 -			u16 dtd_buf_ptr;			/* 161 */
 -			u8 edidless_efp:1;			/* 161 */
 -			u8 compression_enable:1;		/* 198 */
 -			u8 compression_method:1;		/* 198 */
 -			u8 ganged_edp:1;			/* 202 */
 -			u8 reserved0:4;
 -			u8 compression_structure_index:4;	/* 198 */
 -			u8 reserved1:4;
 -			u8 slave_port;				/* 202 */
 -			u8 reserved2;
 -		} __packed;
 -	} __packed;
 -
 +	u16 device_type;
 +	u8  device_id[10]; /* ascii string */
  	u16 addin_offset;
 -	u8 dvo_port; /* See DEVICE_PORT_* and DVO_PORT_* above */
 -	u8 i2c_pin;
 -	u8 slave_addr;
 +	u8  dvo_port; /* See Device_PORT_* above */
 +	u8  i2c_pin;
 +	u8  slave_addr;
 +	u8  ddc_pin;
 +	u16 edid_ptr;
 +	u8  dvo_cfg; /* See DEVICE_CFG_* above */
 +	u8  dvo2_port;
 +	u8  i2c2_pin;
 +	u8  slave2_addr;
 +	u8  ddc2_pin;
 +	u8  capabilities;
 +	u8  dvo_wiring;/* See DEVICE_WIRE_* above */
 +	u8  dvo2_wiring;
 +	u16 extended_type;
 +	u8  dvo_function;
 +} __packed;
 +
 +/* This one contains field offsets that are known to be common for all BDB
 + * versions. Notice that the meaning of the contents contents may still change,
 + * but at least the offsets are consistent. */
 +
 +struct common_child_dev_config {
 +	u16 handle;
 +	u16 device_type;
 +	u8 not_common1[12];
 +	u8 dvo_port;
 +	u8 not_common2[2];
  	u8 ddc_pin;
  	u16 edid_ptr;
  	u8 dvo_cfg; /* See DEVICE_CFG_* above */
diff --git a/drivers/gpu/drm/i915/intel_bios.c b/drivers/gpu/drm/i915/intel_bios.c
index 5d4cd3d00564..1e3049e69af3 100644
--- a/drivers/gpu/drm/i915/intel_bios.c
+++ b/drivers/gpu/drm/i915/intel_bios.c
@@ -1110,6 +1110,22 @@ static void sanitize_aux_ch(struct drm_i915_private *dev_priv,
 	}
 }
 
+static const u8 cnp_ddc_pin_map[] = {
+	[DDC_BUS_DDI_B] = GMBUS_PIN_1_BXT,
+	[DDC_BUS_DDI_C] = GMBUS_PIN_2_BXT,
+	[DDC_BUS_DDI_D] = GMBUS_PIN_4_CNP, /* sic */
+	[DDC_BUS_DDI_F] = GMBUS_PIN_3_BXT, /* sic */
+};
+
+static u8 map_ddc_pin(struct drm_i915_private *dev_priv, u8 vbt_pin)
+{
+	if (HAS_PCH_CNP(dev_priv) &&
+	    vbt_pin > 0 && vbt_pin < ARRAY_SIZE(cnp_ddc_pin_map))
+		return cnp_ddc_pin_map[vbt_pin];
+
+	return vbt_pin;
+}
+
 static void parse_ddi_port(struct drm_i915_private *dev_priv, enum port port,
 			   const struct bdb_header *bdb)
 {
@@ -1195,16 +1211,7 @@ static void parse_ddi_port(struct drm_i915_private *dev_priv, enum port port,
 		DRM_DEBUG_KMS("Port %c is internal DP\n", port_name(port));
 
 	if (is_dvi) {
-		info->alternate_ddc_pin = ddc_pin;
-
-		/*
-		 * All VBTs that we got so far for B Stepping has this
-		 * information wrong for Port D. So, let's just ignore for now.
-		 */
-		if (IS_CNL_REVID(dev_priv, CNL_REVID_B0, CNL_REVID_B0) &&
-		    port == PORT_D) {
-			info->alternate_ddc_pin = 0;
-		}
+		info->alternate_ddc_pin = map_ddc_pin(dev_priv, ddc_pin);
 
 		sanitize_ddc_pin(dev_priv, port);
 	}
* Unmerged path drivers/gpu/drm/i915/intel_vbt_defs.h
