mmc: sdhci: Do not use spin lock in set_ios paths

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] sdhci: Do not use spin lock in set_ios paths (Gopal Tiwari) [1549495]
Rebuild_FUZZ: 94.62%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit d1e4f74f911daee4d69b5fd0c81902f7d37de579
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d1e4f74f.failed

The spin lock is not necessary in set_ios. Anything that is racing with
changes to the I/O state is already broken. The mmc core already provides
synchronization via "claiming" the host. So remove spin_lock and friends
from sdhci_set_ios and related callbacks.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Tested-by: Ludovic Desroches <ludovic.desroches@microchip.com>
(cherry picked from commit d1e4f74f911daee4d69b5fd0c81902f7d37de579)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci-msm.c
#	drivers/mmc/host/sdhci-of-arasan.c
#	drivers/mmc/host/sdhci-of-at91.c
#	drivers/mmc/host/sdhci-pci-core.c
#	drivers/mmc/host/sdhci-pxav3.c
#	drivers/mmc/host/sdhci-s3c.c
diff --cc drivers/mmc/host/sdhci-pci-core.c
index cdfda9db34e1,98ed90cbd9b4..000000000000
--- a/drivers/mmc/host/sdhci-pci-core.c
+++ b/drivers/mmc/host/sdhci-pci-core.c
@@@ -506,6 -470,44 +506,47 @@@ static int byt_sd_probe_slot(struct sdh
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ #define SDHCI_INTEL_PWR_TIMEOUT_CNT	20
+ #define SDHCI_INTEL_PWR_TIMEOUT_UDELAY	100
+ 
+ static void sdhci_intel_set_power(struct sdhci_host *host, unsigned char mode,
+ 				  unsigned short vdd)
+ {
+ 	int cntr;
+ 	u8 reg;
+ 
+ 	sdhci_set_power(host, mode, vdd);
+ 
+ 	if (mode == MMC_POWER_OFF)
+ 		return;
+ 
+ 	/*
+ 	 * Bus power might not enable after D3 -> D0 transition due to the
+ 	 * present state not yet having propagated. Retry for up to 2ms.
+ 	 */
+ 	for (cntr = 0; cntr < SDHCI_INTEL_PWR_TIMEOUT_CNT; cntr++) {
+ 		reg = sdhci_readb(host, SDHCI_POWER_CONTROL);
+ 		if (reg & SDHCI_POWER_ON)
+ 			break;
+ 		udelay(SDHCI_INTEL_PWR_TIMEOUT_UDELAY);
+ 		reg |= SDHCI_POWER_ON;
+ 		sdhci_writeb(host, reg, SDHCI_POWER_CONTROL);
+ 	}
+ }
+ 
+ static const struct sdhci_ops sdhci_intel_byt_ops = {
+ 	.set_clock		= sdhci_set_clock,
+ 	.set_power		= sdhci_intel_set_power,
+ 	.enable_dma		= sdhci_pci_enable_dma,
+ 	.set_bus_width		= sdhci_pci_set_bus_width,
+ 	.reset			= sdhci_reset,
+ 	.set_uhs_signaling	= sdhci_set_uhs_signaling,
+ 	.hw_reset		= sdhci_pci_hw_reset,
+ };
+ 
++>>>>>>> d1e4f74f911d (mmc: sdhci: Do not use spin lock in set_ios paths)
  static const struct sdhci_pci_fixes sdhci_intel_byt_emmc = {
  	.allow_runtime_pm = true,
  	.probe_slot	= byt_emmc_probe_slot,
diff --cc drivers/mmc/host/sdhci-pxav3.c
index 1ae358e0662d,f953f35c2624..000000000000
--- a/drivers/mmc/host/sdhci-pxav3.c
+++ b/drivers/mmc/host/sdhci-pxav3.c
@@@ -163,8 -307,24 +163,27 @@@ static int pxav3_set_uhs_signaling(stru
  	dev_dbg(mmc_dev(host->mmc),
  		"%s uhs = %d, ctrl_2 = %04X\n",
  		__func__, uhs, ctrl_2);
 -}
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ static void pxav3_set_power(struct sdhci_host *host, unsigned char mode,
+ 			    unsigned short vdd)
+ {
+ 	struct mmc_host *mmc = host->mmc;
+ 	u8 pwr = host->pwr;
+ 
+ 	sdhci_set_power_noreg(host, mode, vdd);
+ 
+ 	if (host->pwr == pwr)
+ 		return;
+ 
+ 	if (host->pwr == 0)
+ 		vdd = 0;
+ 
+ 	if (!IS_ERR(mmc->supply.vmmc))
+ 		mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, vdd);
++>>>>>>> d1e4f74f911d (mmc: sdhci: Do not use spin lock in set_ios paths)
  }
  
  static const struct sdhci_ops pxav3_sdhci_ops = {
diff --cc drivers/mmc/host/sdhci-s3c.c
index c6f6246a4933,7c065a70f92b..000000000000
--- a/drivers/mmc/host/sdhci-s3c.c
+++ b/drivers/mmc/host/sdhci-s3c.c
@@@ -153,7 -189,7 +153,11 @@@ static unsigned int sdhci_s3c_consider_
  	 * If controller uses a non-standard clock division, find the best clock
  	 * speed possible with selected clock source and skip the division.
  	 */
++<<<<<<< HEAD
 +	if (ourhost->host->quirks & SDHCI_QUIRK_NONSTANDARD_CLOCK) {
++=======
+ 	if (ourhost->no_divider) {
++>>>>>>> d1e4f74f911d (mmc: sdhci: Do not use spin lock in set_ios paths)
  		rate = clk_round_rate(clksrc, wanted);
  		return wanted - rate;
  	}
@@@ -302,9 -381,18 +306,18 @@@ static void sdhci_cmu_set_clock(struct 
  
  	sdhci_s3c_set_clock(host, clock);
  
 -	/* Reset SD Clock Enable */
 -	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
 -	clk &= ~SDHCI_CLOCK_CARD_EN;
 -	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
 +	clk_set_rate(ourhost->clk_bus[ourhost->cur_clk], clock);
  
++<<<<<<< HEAD
 +	host->clock = clock;
++=======
+ 	ret = clk_set_rate(ourhost->clk_bus[ourhost->cur_clk], clock);
+ 	if (ret != 0) {
+ 		dev_err(dev, "%s: failed to set clock rate %uHz\n",
+ 			mmc_hostname(host->mmc), clock);
+ 		return;
+ 	}
++>>>>>>> d1e4f74f911d (mmc: sdhci: Do not use spin lock in set_ios paths)
  
  	clk = SDHCI_CLOCK_INT_EN;
  	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
* Unmerged path drivers/mmc/host/sdhci-msm.c
* Unmerged path drivers/mmc/host/sdhci-of-arasan.c
* Unmerged path drivers/mmc/host/sdhci-of-at91.c
* Unmerged path drivers/mmc/host/sdhci-msm.c
* Unmerged path drivers/mmc/host/sdhci-of-arasan.c
* Unmerged path drivers/mmc/host/sdhci-of-at91.c
* Unmerged path drivers/mmc/host/sdhci-pci-core.c
* Unmerged path drivers/mmc/host/sdhci-pxav3.c
* Unmerged path drivers/mmc/host/sdhci-s3c.c
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 777c82efce1d..e06fa8d0a287 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -1361,9 +1361,7 @@ void sdhci_enable_clk(struct sdhci_host *host, u16 clk)
 			sdhci_dumpregs(host);
 			return;
 		}
-		spin_unlock_irq(&host->lock);
 		udelay(10);
-		spin_lock_irq(&host->lock);
 	}
 
 	clk |= SDHCI_CLOCK_CARD_EN;
@@ -1392,9 +1390,7 @@ static void sdhci_set_power_reg(struct sdhci_host *host, unsigned char mode,
 {
 	struct mmc_host *mmc = host->mmc;
 
-	spin_unlock_irq(&host->lock);
 	mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, vdd);
-	spin_lock_irq(&host->lock);
 
 	if (mode != MMC_POWER_OFF)
 		sdhci_writeb(host, SDHCI_POWER_ON, SDHCI_POWER_CONTROL);
@@ -1574,16 +1570,12 @@ EXPORT_SYMBOL_GPL(sdhci_set_uhs_signaling);
 static void sdhci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 {
 	struct sdhci_host *host = mmc_priv(mmc);
-	unsigned long flags;
 	u8 ctrl;
 
 	if (ios->power_mode == MMC_POWER_UNDEFINED)
 		return;
 
-	spin_lock_irqsave(&host->lock, flags);
-
 	if (host->flags & SDHCI_DEVICE_DEAD) {
-		spin_unlock_irqrestore(&host->lock, flags);
 		if (!IS_ERR(mmc->supply.vmmc) &&
 		    ios->power_mode == MMC_POWER_OFF)
 			mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);
@@ -1729,7 +1721,6 @@ static void sdhci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		sdhci_do_reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);
 
 	mmiowb();
-	spin_unlock_irqrestore(&host->lock, flags);
 }
 
 static int sdhci_get_cd(struct mmc_host *mmc)
