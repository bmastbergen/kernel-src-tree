ceph: don't wait on writeback when there is no more dirty pages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Yan, Zheng <zyan@redhat.com>
commit 1582af2eaaf17cbcd7864172347c1db10b6b2210
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1582af2e.failed

In sync mode, writepages() needs to write all dirty pages. But
it can only write dirty pages associated with the oldest snapc.
To write dirty pages associated with next snapc, it needs to wait
until current writes complete.

If there is no more dirty pages, writepages() should not wait on
writeback. Otherwise, dirty page writeback becomes very slow.

	Signed-off-by: "Yan, Zheng" <zyan@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 1582af2eaaf17cbcd7864172347c1db10b6b2210)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/addr.c
diff --cc fs/ceph/addr.c
index adf7d1009bc0,5f7ad3d0df2e..000000000000
--- a/fs/ceph/addr.c
+++ b/fs/ceph/addr.c
@@@ -773,15 -836,33 +773,43 @@@ retry
  	dout(" oldest snapc is %p seq %lld (%d snaps)\n",
  	     snapc, snapc->seq, snapc->num_snaps);
  
++<<<<<<< HEAD
 +	i_size = i_size_read(inode);
++=======
+ 	should_loop = false;
+ 	if (ceph_wbc.head_snapc && snapc != last_snapc) {
+ 		/* where to start/end? */
+ 		if (wbc->range_cyclic) {
+ 			index = start_index;
+ 			end = -1;
+ 			if (index > 0)
+ 				should_loop = true;
+ 			dout(" cyclic, start at %lu\n", index);
+ 		} else {
+ 			index = wbc->range_start >> PAGE_SHIFT;
+ 			end = wbc->range_end >> PAGE_SHIFT;
+ 			if (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)
+ 				range_whole = true;
+ 			dout(" not cyclic, %lu to %lu\n", index, end);
+ 		}
+ 	} else if (!ceph_wbc.head_snapc) {
+ 		/* Do not respect wbc->range_{start,end}. Dirty pages
+ 		 * in that range can be associated with newer snapc.
+ 		 * They are not writeable until we write all dirty pages
+ 		 * associated with 'snapc' get written */
+ 		if (index > 0)
+ 			should_loop = true;
+ 		dout(" non-head snapc, range whole\n");
+ 	}
 -
 -	ceph_put_snap_context(last_snapc);
++>>>>>>> 1582af2eaaf1 (ceph: don't wait on writeback when there is no more dirty pages)
 +
 +	if (last_snapc && snapc != last_snapc) {
 +		/* if we switched to a newer snapc, restart our scan at the
 +		 * start of the original file range. */
 +		dout("  snapc differs from last pass, restarting at %lu\n",
 +		     index);
 +		index = start;
 +	}
  	last_snapc = snapc;
  
  	while (!done && index <= end) {
@@@ -823,13 -896,29 +851,25 @@@ get_more_pages
  			    unlikely(page->mapping != mapping)) {
  				dout("!dirty or !mapping %p\n", page);
  				unlock_page(page);
 -				continue;
 +				break;
  			}
++<<<<<<< HEAD
 +			if (!wbc->range_cyclic && page->index > end) {
 +				dout("end of range %p\n", page);
 +				done = 1;
++=======
+ 			/* only if matching snap context */
+ 			pgsnapc = page_snap_context(page);
+ 			if (pgsnapc != snapc) {
+ 				dout("page snapc %p %lld != oldest %p %lld\n",
+ 				     pgsnapc, pgsnapc->seq, snapc, snapc->seq);
+ 				if (!should_loop &&
+ 				    !ceph_wbc.head_snapc &&
+ 				    wbc->sync_mode != WB_SYNC_NONE)
+ 					should_loop = true;
++>>>>>>> 1582af2eaaf1 (ceph: don't wait on writeback when there is no more dirty pages)
  				unlock_page(page);
 -				continue;
 -			}
 -			if (page_offset(page) >= ceph_wbc.i_size) {
 -				dout("%p page eof %llu\n",
 -				     page, ceph_wbc.i_size);
 -				if (ceph_wbc.size_stable ||
 -				    page_offset(page) >= i_size_read(inode))
 -					mapping->a_ops->invalidatepage(page,
 -								0, PAGE_SIZE);
 -				unlock_page(page);
 -				continue;
 +				break;
  			}
  			if (strip_unit_end && (page->index > strip_unit_end)) {
  				dout("end of strip unit %p\n", page);
* Unmerged path fs/ceph/addr.c
