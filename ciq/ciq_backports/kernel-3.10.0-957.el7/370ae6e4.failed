nvme-rdma: cleanup error path in controller reset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Sagi Grimberg <sagi@grimberg.me>
commit 370ae6e450260c8bd3e1ea75c1390f746d3c71ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/370ae6e4.failed

No need to queue an extra work to indirect controller removal, just call the
ctrl remove routine.

	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 370ae6e450260c8bd3e1ea75c1390f746d3c71ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/rdma.c
diff --cc drivers/nvme/host/rdma.c
index 6d8e34242c5f,1bf7c3a55c96..000000000000
--- a/drivers/nvme/host/rdma.c
+++ b/drivers/nvme/host/rdma.c
@@@ -1664,32 -1717,26 +1664,35 @@@ static void nvme_rdma_shutdown_ctrl(str
  		nvme_stop_queues(&ctrl->ctrl);
  		blk_mq_tagset_busy_iter(&ctrl->tag_set,
  					nvme_cancel_request, &ctrl->ctrl);
 -		nvme_rdma_destroy_io_queues(ctrl, shutdown);
 +		nvme_rdma_free_io_queues(ctrl);
  	}
  
 -	if (shutdown)
 +	if (test_bit(NVME_RDMA_Q_LIVE, &ctrl->queues[0].flags))
  		nvme_shutdown_ctrl(&ctrl->ctrl);
 -	else
 -		nvme_disable_ctrl(&ctrl->ctrl, ctrl->ctrl.cap);
  
 -	blk_mq_quiesce_queue(ctrl->ctrl.admin_q);
 +	blk_mq_stop_hw_queues(ctrl->ctrl.admin_q);
  	blk_mq_tagset_busy_iter(&ctrl->admin_tag_set,
  				nvme_cancel_request, &ctrl->ctrl);
 -	blk_mq_unquiesce_queue(ctrl->ctrl.admin_q);
 -	nvme_rdma_destroy_admin_queue(ctrl, shutdown);
 +	nvme_rdma_destroy_admin_queue(ctrl);
  }
  
- static void __nvme_rdma_remove_ctrl(struct nvme_rdma_ctrl *ctrl, bool shutdown)
+ static void nvme_rdma_remove_ctrl(struct nvme_rdma_ctrl *ctrl)
  {
- 	nvme_stop_ctrl(&ctrl->ctrl);
  	nvme_remove_namespaces(&ctrl->ctrl);
++<<<<<<< HEAD
 +	if (shutdown)
 +		nvme_rdma_shutdown_ctrl(ctrl);
 +
++=======
+ 	nvme_rdma_shutdown_ctrl(ctrl, true);
++>>>>>>> 370ae6e45026 (nvme-rdma: cleanup error path in controller reset)
  	nvme_uninit_ctrl(&ctrl->ctrl);
 +	if (ctrl->ctrl.tagset) {
 +		blk_cleanup_queue(ctrl->ctrl.connect_q);
 +		blk_mq_free_tag_set(&ctrl->tag_set);
 +		nvme_rdma_dev_put(ctrl->device);
 +	}
 +
  	nvme_put_ctrl(&ctrl->ctrl);
  }
  
@@@ -1746,36 -1786,16 +1742,46 @@@ static void nvme_rdma_reset_ctrl_work(s
  	bool changed;
  
  	nvme_stop_ctrl(&ctrl->ctrl);
 -	nvme_rdma_shutdown_ctrl(ctrl, false);
 +	nvme_rdma_shutdown_ctrl(ctrl);
 +
++<<<<<<< HEAD
 +	if (!nvme_change_ctrl_state(&ctrl->ctrl, NVME_CTRL_RECONNECTING)) {
 +		/* state change failure should never happen */
 +		WARN_ON_ONCE(1);
 +		return;
 +	}
  
 +	ret = nvme_rdma_configure_admin_queue(ctrl);
 +	if (ret) {
 +		/* ctrl is already shutdown, just remove the ctrl */
 +		INIT_WORK(&ctrl->delete_work, nvme_rdma_remove_ctrl_work);
 +		goto del_dead_ctrl;
 +	}
++=======
+ 	ret = nvme_rdma_configure_admin_queue(ctrl, false);
+ 	if (ret)
+ 		goto out_fail;
++>>>>>>> 370ae6e45026 (nvme-rdma: cleanup error path in controller reset)
  
  	if (ctrl->ctrl.queue_count > 1) {
 -		ret = nvme_rdma_configure_io_queues(ctrl, false);
 +		ret = blk_mq_reinit_tagset(&ctrl->tag_set);
 +		if (ret)
++<<<<<<< HEAD
 +			goto del_dead_ctrl;
 +
 +		ret = nvme_rdma_init_io_queues(ctrl);
  		if (ret)
 +			goto del_dead_ctrl;
 +
 +		ret = nvme_rdma_connect_io_queues(ctrl);
 +		if (ret)
 +			goto del_dead_ctrl;
 +
 +		blk_mq_update_nr_hw_queues(&ctrl->tag_set,
 +				ctrl->ctrl.queue_count - 1);
++=======
+ 			goto out_fail;
++>>>>>>> 370ae6e45026 (nvme-rdma: cleanup error path in controller reset)
  	}
  
  	changed = nvme_change_ctrl_state(&ctrl->ctrl, NVME_CTRL_LIVE);
* Unmerged path drivers/nvme/host/rdma.c
