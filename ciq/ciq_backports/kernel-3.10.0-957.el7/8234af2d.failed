net_sch: red: Fix the new offload indication

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] sched: red: Fix the new offload indication (Ivan Vecera) [1583702]
Rebuild_FUZZ: 93.02%
commit-author Nogah Frankel <nogahf@mellanox.com>
commit 8234af2db3614d78b49e77ef46ea8cfab6586568
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8234af2d.failed

Update the offload flag, TCQ_F_OFFLOADED, in each dump call (and ignore
the offloading function return value in relation to this flag).
This is done because a qdisc is being initialized, and therefore offloaded
before being grafted. Since the ability of the driver to offload the qdisc
depends on its location, a qdisc can be offloaded and un-offloaded by graft
calls, that doesn't effect the qdisc itself.

Fixes: 428a68af3a7c ("net: sched: Move to new offload indication in RED"
	Signed-off-by: Nogah Frankel <nogahf@mellanox.com>
	Reviewed-by: Yuval Mintz <yuvalm@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8234af2db3614d78b49e77ef46ea8cfab6586568)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_red.c
diff --cc net/sched/sch_red.c
index ffa7875f9b91,a392eaa4a0b4..000000000000
--- a/net/sched/sch_red.c
+++ b/net/sched/sch_red.c
@@@ -147,6 -149,31 +147,34 @@@ static void red_reset(struct Qdisc *sch
  	red_restart(&q->vars);
  }
  
++<<<<<<< HEAD
++=======
+ static int red_offload(struct Qdisc *sch, bool enable)
+ {
+ 	struct red_sched_data *q = qdisc_priv(sch);
+ 	struct net_device *dev = qdisc_dev(sch);
+ 	struct tc_red_qopt_offload opt = {
+ 		.handle = sch->handle,
+ 		.parent = sch->parent,
+ 	};
+ 
+ 	if (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (enable) {
+ 		opt.command = TC_RED_REPLACE;
+ 		opt.set.min = q->parms.qth_min >> q->parms.Wlog;
+ 		opt.set.max = q->parms.qth_max >> q->parms.Wlog;
+ 		opt.set.probability = q->parms.max_P;
+ 		opt.set.is_ecn = red_use_ecn(q);
+ 	} else {
+ 		opt.command = TC_RED_DESTROY;
+ 	}
+ 
+ 	return dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_RED, &opt);
+ }
+ 
++>>>>>>> 8234af2db361 (net_sch: red: Fix the new offload indication)
  static void red_destroy(struct Qdisc *sch)
  {
  	struct red_sched_data *q = qdisc_priv(sch);
@@@ -238,8 -272,39 +266,44 @@@ static int red_init(struct Qdisc *sch, 
  	struct red_sched_data *q = qdisc_priv(sch);
  
  	q->qdisc = &noop_qdisc;
++<<<<<<< HEAD
 +	setup_timer(&q->adapt_timer, red_adaptative_timer, (unsigned long)sch);
 +	return red_change(sch, opt);
++=======
+ 	q->sch = sch;
+ 	timer_setup(&q->adapt_timer, red_adaptative_timer, 0);
+ 	return red_change(sch, opt, extack);
+ }
+ 
+ static int red_dump_offload_stats(struct Qdisc *sch, struct tc_red_qopt *opt)
+ {
+ 	struct net_device *dev = qdisc_dev(sch);
+ 	struct tc_red_qopt_offload hw_stats = {
+ 		.command = TC_RED_STATS,
+ 		.handle = sch->handle,
+ 		.parent = sch->parent,
+ 		{
+ 			.stats.bstats = &sch->bstats,
+ 			.stats.qstats = &sch->qstats,
+ 		},
+ 	};
+ 	int err;
+ 
+ 	sch->flags &= ~TCQ_F_OFFLOADED;
+ 
+ 	if (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)
+ 		return 0;
+ 
+ 	err = dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_RED,
+ 					    &hw_stats);
+ 	if (err == -EOPNOTSUPP)
+ 		return 0;
+ 
+ 	if (!err)
+ 		sch->flags |= TCQ_F_OFFLOADED;
+ 
+ 	return err;
++>>>>>>> 8234af2db361 (net_sch: red: Fix the new offload indication)
  }
  
  static int red_dump(struct Qdisc *sch, struct sk_buff *skb)
* Unmerged path net/sched/sch_red.c
