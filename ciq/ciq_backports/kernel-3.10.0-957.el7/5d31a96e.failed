powerpc/livepatch: Add livepatch stack to struct thread_info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [powerpc] livepatch: Add livepatch stack to struct thread_info (Josh Poimboeuf) [1578960]
Rebuild_FUZZ: 92.86%
commit-author Michael Ellerman <mpe@ellerman.id.au>
commit 5d31a96e6c0187f2c5d7004e005fd094a1277e9e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5d31a96e.failed

In order to support live patching we need to maintain an alternate
stack of TOC & LR values. We use the base of the stack for this, and
store the "live patch stack pointer" in struct thread_info.

Unlike the other fields of thread_info, we can not statically initialise
that value, so it must be done at run time.

This patch just adds the code to support that, it is not enabled until
the next patch which actually adds live patch support.

	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
	Acked-by: Balbir Singh <bsingharora@gmail.com>
(cherry picked from commit 5d31a96e6c0187f2c5d7004e005fd094a1277e9e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/process.c
#	arch/powerpc/kernel/setup_64.c
diff --cc arch/powerpc/kernel/process.c
index 13e89d95565a,a38ce49648cb..000000000000
--- a/arch/powerpc/kernel/process.c
+++ b/arch/powerpc/kernel/process.c
@@@ -1128,7 -1277,7 +1133,11 @@@ int copy_thread(unsigned long clone_fla
  	sp -= sizeof(struct pt_regs);
  	childregs = (struct pt_regs *) sp;
  	if (unlikely(p->flags & PF_KTHREAD)) {
++<<<<<<< HEAD
 +		struct thread_info *ti = (void *)task_stack_page(p);
++=======
+ 		/* kernel thread */
++>>>>>>> 5d31a96e6c01 (powerpc/livepatch: Add livepatch stack to struct thread_info)
  		memset(childregs, 0, sizeof(struct pt_regs));
  		childregs->gpr[1] = sp + sizeof(struct pt_regs);
  		/* function */
diff --cc arch/powerpc/kernel/setup_64.c
index 5dba321c5b53,e37b92ebb315..000000000000
--- a/arch/powerpc/kernel/setup_64.c
+++ b/arch/powerpc/kernel/setup_64.c
@@@ -69,6 -68,8 +69,11 @@@
  #include <asm/code-patching.h>
  #include <asm/kvm_ppc.h>
  #include <asm/hugetlb.h>
++<<<<<<< HEAD
++=======
+ #include <asm/epapr_hcalls.h>
+ #include <asm/livepatch.h>
++>>>>>>> 5d31a96e6c01 (powerpc/livepatch: Add livepatch stack to struct thread_info)
  
  #ifdef DEBUG
  #define DBG(fmt...) udbg_printf(fmt)
diff --git a/arch/powerpc/include/asm/livepatch.h b/arch/powerpc/include/asm/livepatch.h
index ad36e8e34fa1..a402f7f94896 100644
--- a/arch/powerpc/include/asm/livepatch.h
+++ b/arch/powerpc/include/asm/livepatch.h
@@ -49,6 +49,14 @@ static inline unsigned long klp_get_ftrace_location(unsigned long faddr)
 	 */
 	return ftrace_location_range(faddr, faddr + 16);
 }
+
+static inline void klp_init_thread_info(struct thread_info *ti)
+{
+	/* + 1 to account for STACK_END_MAGIC */
+	ti->livepatch_sp = (unsigned long *)(ti + 1) + 1;
+}
+#else
+static void klp_init_thread_info(struct thread_info *ti) { }
 #endif /* CONFIG_LIVEPATCH */
 
 #endif /* _ASM_POWERPC_LIVEPATCH_H */
diff --git a/arch/powerpc/include/asm/thread_info.h b/arch/powerpc/include/asm/thread_info.h
index 8b268bbc125d..129f90fa4e67 100644
--- a/arch/powerpc/include/asm/thread_info.h
+++ b/arch/powerpc/include/asm/thread_info.h
@@ -45,7 +45,9 @@ struct thread_info {
 						   <0 => BUG */
 	struct restart_block restart_block;
 	unsigned long	local_flags;		/* private flags for thread */
-
+#ifdef CONFIG_LIVEPATCH
+	unsigned long *livepatch_sp;
+#endif
 	/* low level flags - has atomic operations done on it */
 	unsigned long	flags ____cacheline_aligned_in_smp;
 };
diff --git a/arch/powerpc/kernel/irq.c b/arch/powerpc/kernel/irq.c
index 3df43527d09a..d39ccd29b2ec 100644
--- a/arch/powerpc/kernel/irq.c
+++ b/arch/powerpc/kernel/irq.c
@@ -67,6 +67,7 @@
 #include <asm/udbg.h>
 #include <asm/smp.h>
 #include <asm/debug.h>
+#include <asm/livepatch.h>
 
 #ifdef CONFIG_PPC64
 #include <asm/paca.h>
@@ -603,10 +604,12 @@ void irq_ctx_init(void)
 		memset((void *)softirq_ctx[i], 0, THREAD_SIZE);
 		tp = softirq_ctx[i];
 		tp->cpu = i;
+		klp_init_thread_info(tp);
 
 		memset((void *)hardirq_ctx[i], 0, THREAD_SIZE);
 		tp = hardirq_ctx[i];
 		tp->cpu = i;
+		klp_init_thread_info(tp);
 	}
 }
 
* Unmerged path arch/powerpc/kernel/process.c
* Unmerged path arch/powerpc/kernel/setup_64.c
