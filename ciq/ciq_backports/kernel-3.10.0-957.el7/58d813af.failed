net: aquantia: fix unsigned numvecs comparison with less than zero

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Colin Ian King <colin.king@canonical.com>
commit 58d813afbe89658a5972747460a5fe19dec4dbcb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/58d813af.failed

From: Colin Ian King <colin.king@canonical.com>

This was originally mistakenly submitted to net-next. Resubmitting to net.

The comparison of numvecs < 0 is always false because numvecs is a u32
and hence the error return from a failed call to pci_alloc_irq_vectores
is never detected.  Fix this by using the signed int ret to handle the
error return and assign numvecs to err.

Detected by CoverityScan, CID#1468650 ("Unsigned compared against 0")

Fixes: a09bd81b5413 ("net: aquantia: Limit number of vectors to actually allocated irqs")
	Signed-off-by: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: Igor Russkikh <igor.russkikh@aquantia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 58d813afbe89658a5972747460a5fe19dec4dbcb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
index 667e08a571a5,750007513f9d..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
@@@ -261,87 -177,188 +261,176 @@@ void aq_pci_func_free_irqs(struct aq_pc
  	}
  }
  
 -unsigned int aq_pci_func_get_irq_type(struct aq_nic_s *self)
 +void __iomem *aq_pci_func_get_mmio(struct aq_pci_func_s *self)
  {
 -	if (self->pdev->msix_enabled)
 -		return AQ_HW_IRQ_MSIX;
 -	if (self->pdev->msi_enabled)
 -		return AQ_HW_IRQ_MSIX;
 -	return AQ_HW_IRQ_LEGACY;
 +	return self->mmio;
  }
  
 -static void aq_pci_free_irq_vectors(struct aq_nic_s *self)
 +unsigned int aq_pci_func_get_irq_type(struct aq_pci_func_s *self)
  {
 -	pci_free_irq_vectors(self->pdev);
 +	return self->irq_type;
  }
  
 -static int aq_pci_probe(struct pci_dev *pdev,
 -			const struct pci_device_id *pci_id)
 +void aq_pci_func_deinit(struct aq_pci_func_s *self)
  {
 -	struct aq_nic_s *self = NULL;
 -	int err = 0;
 -	struct net_device *ndev;
 -	resource_size_t mmio_pa;
 -	u32 bar;
 -	u32 numvecs;
 +	if (!self)
 +		goto err_exit;
  
 -	err = pci_enable_device(pdev);
 -	if (err)
 -		return err;
 +	aq_pci_func_free_irqs(self);
  
 -	err = aq_pci_func_init(pdev);
 -	if (err)
 -		goto err_pci_func;
 +	switch (self->irq_type) {
 +	case AQ_HW_IRQ_MSI:
 +		pci_disable_msi(self->pdev);
 +		break;
  
 -	ndev = aq_ndev_alloc();
 -	if (!ndev) {
 -		err = -ENOMEM;
 -		goto err_ndev;
 +	case AQ_HW_IRQ_MSIX:
 +		pci_disable_msix(self->pdev);
 +		break;
 +
 +	case AQ_HW_IRQ_LEGACY:
 +		break;
 +
 +	default:
 +		break;
  	}
  
 +	if (self->is_regions)
 +		pci_release_regions(self->pdev);
 +
 +	if (self->is_pci_enabled)
 +		pci_disable_device(self->pdev);
 +
 +err_exit:;
 +}
 +
 +void aq_pci_func_free(struct aq_pci_func_s *self)
 +{
 +	unsigned int port = 0U;
 +
 +	if (!self)
 +		goto err_exit;
 +
 +	for (port = 0; port < self->ports; ++port) {
 +		if (!self->port[port])
 +			continue;
 +
 +		aq_nic_ndev_free(self->port[port]);
 +	}
 +
 +	if (self->mmio)
 +		iounmap(self->mmio);
 +
 +	kfree(self);
 +
 +err_exit:;
 +}
 +
 +int aq_pci_func_change_pm_state(struct aq_pci_func_s *self,
 +				pm_message_t *pm_msg)
 +{
 +	int err = 0;
 +	unsigned int port = 0U;
 +
 +	if (!self) {
 +		err = -EFAULT;
 +		goto err_exit;
 +	}
 +	for (port = 0; port < self->ports; ++port) {
 +		if (!self->port[port])
 +			continue;
 +
 +		(void)aq_nic_change_pm_state(self->port[port], pm_msg);
 +	}
 +
++<<<<<<< HEAD
 +err_exit:
++=======
+ 	self = netdev_priv(ndev);
+ 	self->pdev = pdev;
+ 	SET_NETDEV_DEV(ndev, &pdev->dev);
+ 	pci_set_drvdata(pdev, self);
+ 
+ 	err = aq_pci_probe_get_hw_by_id(pdev, &self->aq_hw_ops,
+ 					&aq_nic_get_cfg(self)->aq_hw_caps);
+ 	if (err)
+ 		goto err_ioremap;
+ 
+ 	self->aq_hw = kzalloc(sizeof(*self->aq_hw), GFP_KERNEL);
+ 	if (!self->aq_hw) {
+ 		err = -ENOMEM;
+ 		goto err_ioremap;
+ 	}
+ 	self->aq_hw->aq_nic_cfg = aq_nic_get_cfg(self);
+ 
+ 	for (bar = 0; bar < 4; ++bar) {
+ 		if (IORESOURCE_MEM & pci_resource_flags(pdev, bar)) {
+ 			resource_size_t reg_sz;
+ 
+ 			mmio_pa = pci_resource_start(pdev, bar);
+ 			if (mmio_pa == 0U) {
+ 				err = -EIO;
+ 				goto err_free_aq_hw;
+ 			}
+ 
+ 			reg_sz = pci_resource_len(pdev, bar);
+ 			if ((reg_sz <= 24 /*ATL_REGS_SIZE*/)) {
+ 				err = -EIO;
+ 				goto err_free_aq_hw;
+ 			}
+ 
+ 			self->aq_hw->mmio = ioremap_nocache(mmio_pa, reg_sz);
+ 			if (!self->aq_hw->mmio) {
+ 				err = -EIO;
+ 				goto err_free_aq_hw;
+ 			}
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (bar == 4) {
+ 		err = -EIO;
+ 		goto err_free_aq_hw;
+ 	}
+ 
+ 	numvecs = min((u8)AQ_CFG_VECS_DEF,
+ 		      aq_nic_get_cfg(self)->aq_hw_caps->msix_irqs);
+ 	numvecs = min(numvecs, num_online_cpus());
+ 	/*enable interrupts */
+ #if !AQ_CFG_FORCE_LEGACY_INT
+ 	err = pci_alloc_irq_vectors(self->pdev, 1, numvecs,
+ 				    PCI_IRQ_MSIX | PCI_IRQ_MSI |
+ 				    PCI_IRQ_LEGACY);
+ 
+ 	if (err < 0)
+ 		goto err_hwinit;
+ 	numvecs = err;
+ #endif
+ 	self->irqvecs = numvecs;
+ 
+ 	/* net device init */
+ 	aq_nic_cfg_start(self);
+ 
+ 	aq_nic_ndev_init(self);
+ 
+ 	err = aq_nic_ndev_register(self);
+ 	if (err < 0)
+ 		goto err_register;
+ 
+ 	return 0;
+ 
+ err_register:
+ 	aq_nic_free_vectors(self);
+ 	aq_pci_free_irq_vectors(self);
+ err_hwinit:
+ 	iounmap(self->aq_hw->mmio);
+ err_free_aq_hw:
+ 	kfree(self->aq_hw);
+ err_ioremap:
+ 	free_netdev(ndev);
+ err_ndev:
+ 	pci_release_regions(pdev);
+ err_pci_func:
+ 	pci_disable_device(pdev);
++>>>>>>> 58d813afbe89 (net: aquantia: fix unsigned numvecs comparison with less than zero)
  	return err;
  }
 -
 -static void aq_pci_remove(struct pci_dev *pdev)
 -{
 -	struct aq_nic_s *self = pci_get_drvdata(pdev);
 -
 -	if (self->ndev) {
 -		if (self->ndev->reg_state == NETREG_REGISTERED)
 -			unregister_netdev(self->ndev);
 -		aq_nic_free_vectors(self);
 -		aq_pci_free_irq_vectors(self);
 -		iounmap(self->aq_hw->mmio);
 -		kfree(self->aq_hw);
 -		pci_release_regions(pdev);
 -		free_netdev(self->ndev);
 -	}
 -
 -	pci_disable_device(pdev);
 -}
 -
 -static void aq_pci_shutdown(struct pci_dev *pdev)
 -{
 -	struct aq_nic_s *self = pci_get_drvdata(pdev);
 -
 -	aq_nic_shutdown(self);
 -
 -	pci_disable_device(pdev);
 -
 -	if (system_state == SYSTEM_POWER_OFF) {
 -		pci_wake_from_d3(pdev, false);
 -		pci_set_power_state(pdev, PCI_D3hot);
 -	}
 -}
 -
 -static int aq_pci_suspend(struct pci_dev *pdev, pm_message_t pm_msg)
 -{
 -	struct aq_nic_s *self = pci_get_drvdata(pdev);
 -
 -	return aq_nic_change_pm_state(self, &pm_msg);
 -}
 -
 -static int aq_pci_resume(struct pci_dev *pdev)
 -{
 -	struct aq_nic_s *self = pci_get_drvdata(pdev);
 -	pm_message_t pm_msg = PMSG_RESTORE;
 -
 -	return aq_nic_change_pm_state(self, &pm_msg);
 -}
 -
 -static struct pci_driver aq_pci_ops = {
 -	.name = AQ_CFG_DRV_NAME,
 -	.id_table = aq_pci_tbl,
 -	.probe = aq_pci_probe,
 -	.remove = aq_pci_remove,
 -	.suspend = aq_pci_suspend,
 -	.resume = aq_pci_resume,
 -	.shutdown = aq_pci_shutdown,
 -};
 -
 -module_pci_driver(aq_pci_ops);
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c
