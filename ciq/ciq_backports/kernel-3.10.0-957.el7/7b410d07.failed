mmc: queue: Share mmc request array between partitions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] queue: Share mmc request array between partitions (Gopal Tiwari) [1549495]
Rebuild_FUZZ: 95.15%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 7b410d074b253a44624497a18e73f666a9574f37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7b410d07.failed

eMMC can have multiple internal partitions that are represented as separate
disks / queues. However switching between partitions is only done when the
queue is empty. Consequently the array of mmc requests that are queued can
be shared between partitions saving memory.

Keep a pointer to the mmc request queue on the card, and use that instead
of allocating a new one for each partition.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 7b410d074b253a44624497a18e73f666a9574f37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/queue.c
diff --cc drivers/mmc/core/queue.c
index b0ae9d688e28,3423b7acf744..000000000000
--- a/drivers/mmc/core/queue.c
+++ b/drivers/mmc/core/queue.c
@@@ -179,46 -178,67 +175,71 @@@ static void mmc_queue_setup_discard(str
  	if (card->pref_erase > max_discard)
  		q->limits.discard_granularity = 0;
  	if (mmc_can_secure_erase_trim(card))
++<<<<<<< HEAD
 +		queue_flag_set_unlocked(QUEUE_FLAG_SECDISCARD, q);
++=======
+ 		queue_flag_set_unlocked(QUEUE_FLAG_SECERASE, q);
  }
  
- #ifdef CONFIG_MMC_BLOCK_BOUNCE
- static bool mmc_queue_alloc_bounce_bufs(struct mmc_queue *mq,
- 					unsigned int bouncesz)
+ static void mmc_queue_req_free_bufs(struct mmc_queue_req *mqrq)
+ {
+ 	kfree(mqrq->bounce_sg);
+ 	mqrq->bounce_sg = NULL;
+ 
+ 	kfree(mqrq->sg);
+ 	mqrq->sg = NULL;
+ 
+ 	kfree(mqrq->bounce_buf);
+ 	mqrq->bounce_buf = NULL;
+ }
+ 
+ static void mmc_queue_reqs_free_bufs(struct mmc_queue_req *mqrq, int qdepth)
  {
  	int i;
  
- 	for (i = 0; i < mq->qdepth; i++) {
- 		mq->mqrq[i].bounce_buf = kmalloc(bouncesz, GFP_KERNEL);
- 		if (!mq->mqrq[i].bounce_buf)
- 			goto out_err;
- 	}
+ 	for (i = 0; i < qdepth; i++)
+ 		mmc_queue_req_free_bufs(&mqrq[i]);
+ }
  
- 	return true;
+ static void mmc_queue_free_mqrqs(struct mmc_queue_req *mqrq, int qdepth)
+ {
+ 	mmc_queue_reqs_free_bufs(mqrq, qdepth);
+ 	kfree(mqrq);
+ }
  
- out_err:
- 	while (--i >= 0) {
- 		kfree(mq->mqrq[i].bounce_buf);
- 		mq->mqrq[i].bounce_buf = NULL;
+ static struct mmc_queue_req *mmc_queue_alloc_mqrqs(int qdepth)
+ {
+ 	struct mmc_queue_req *mqrq;
+ 	int i;
+ 
+ 	mqrq = kcalloc(qdepth, sizeof(*mqrq), GFP_KERNEL);
+ 	if (mqrq) {
+ 		for (i = 0; i < qdepth; i++)
+ 			mqrq[i].task_id = i;
  	}
- 	pr_warn("%s: unable to allocate bounce buffers\n",
- 		mmc_card_name(mq->card));
- 	return false;
+ 
+ 	return mqrq;
++>>>>>>> 7b410d074b25 (mmc: queue: Share mmc request array between partitions)
  }
  
- static int mmc_queue_alloc_bounce_sgs(struct mmc_queue *mq,
- 				      unsigned int bouncesz)
+ #ifdef CONFIG_MMC_BLOCK_BOUNCE
+ static int mmc_queue_alloc_bounce_bufs(struct mmc_queue_req *mqrq, int qdepth,
+ 				       unsigned int bouncesz)
  {
- 	int i, ret;
+ 	int i;
  
- 	for (i = 0; i < mq->qdepth; i++) {
- 		mq->mqrq[i].sg = mmc_alloc_sg(1, &ret);
- 		if (ret)
- 			return ret;
+ 	for (i = 0; i < qdepth; i++) {
+ 		mqrq[i].bounce_buf = kmalloc(bouncesz, GFP_KERNEL);
+ 		if (!mqrq[i].bounce_buf)
+ 			return -ENOMEM;
  
- 		mq->mqrq[i].bounce_sg = mmc_alloc_sg(bouncesz / 512, &ret);
- 		if (ret)
- 			return ret;
+ 		mqrq[i].sg = mmc_alloc_sg(1);
+ 		if (!mqrq[i].sg)
+ 			return -ENOMEM;
+ 
+ 		mqrq[i].bounce_sg = mmc_alloc_sg(bouncesz / 512);
+ 		if (!mqrq[i].bounce_sg)
+ 			return -ENOMEM;
  	}
  
  	return 0;
@@@ -283,13 -379,8 +380,18 @@@ int mmc_init_queue(struct mmc_queue *mq
  	if (!mq->queue)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	mq->qdepth = 2;
 +	mq->mqrq = kcalloc(mq->qdepth, sizeof(struct mmc_queue_req),
 +			   GFP_KERNEL);
 +	if (!mq->mqrq)
 +		goto blk_cleanup;
 +	mq->mqrq_cur = &mq->mqrq[0];
 +	mq->mqrq_prev = &mq->mqrq[1];
++=======
+ 	mq->mqrq = card->mqrq;
+ 	mq->qdepth = card->qdepth;
++>>>>>>> 7b410d074b25 (mmc: queue: Share mmc request array between partitions)
  	mq->queue->queuedata = mq;
  
  	blk_queue_prep_rq(mq->queue, mmc_prep_request);
diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c
index 49dc294d6eb1..d6922ae1d984 100644
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@ -2079,6 +2079,7 @@ static int mmc_blk_probe(struct mmc_card *card)
 {
 	struct mmc_blk_data *md, *part_md;
 	char cap_str[10];
+	int ret;
 
 	/*
 	 * Check that the card supports the command class(es) we need.
@@ -2088,9 +2089,15 @@ static int mmc_blk_probe(struct mmc_card *card)
 
 	mmc_fixup_device(card, mmc_blk_fixups);
 
+	ret = mmc_queue_alloc_shared_queue(card);
+	if (ret)
+		return ret;
+
 	md = mmc_blk_alloc(card);
-	if (IS_ERR(md))
+	if (IS_ERR(md)) {
+		mmc_queue_free_shared_queue(card);
 		return PTR_ERR(md);
+	}
 
 	string_get_size((u64)get_capacity(md->disk) << 9, STRING_UNITS_2,
 			cap_str, sizeof(cap_str));
@@ -2128,6 +2135,7 @@ static int mmc_blk_probe(struct mmc_card *card)
  out:
 	mmc_blk_remove_parts(card, md);
 	mmc_blk_remove_req(md);
+	mmc_queue_free_shared_queue(card);
 	return 0;
 }
 
@@ -2145,6 +2153,7 @@ static void mmc_blk_remove(struct mmc_card *card)
 	pm_runtime_put_noidle(&card->dev);
 	mmc_blk_remove_req(md);
 	dev_set_drvdata(&card->dev, NULL);
+	mmc_queue_free_shared_queue(card);
 }
 
 static int _mmc_blk_suspend(struct mmc_card *card)
* Unmerged path drivers/mmc/core/queue.c
diff --git a/drivers/mmc/core/queue.h b/drivers/mmc/core/queue.h
index a61f88199573..82db33f7a9fc 100644
--- a/drivers/mmc/core/queue.h
+++ b/drivers/mmc/core/queue.h
@@ -42,6 +42,8 @@ struct mmc_queue {
 	int			qdepth;
 };
 
+extern int mmc_queue_alloc_shared_queue(struct mmc_card *card);
+extern void mmc_queue_free_shared_queue(struct mmc_card *card);
 extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *,
 			  const char *);
 extern void mmc_cleanup_queue(struct mmc_queue *);
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index e3f1031064a7..e7c4df7ab3af 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -210,6 +210,7 @@ struct mmc_host;
 struct mmc_ios;
 struct sdio_func;
 struct sdio_func_tuple;
+struct mmc_queue_req;
 
 #define SDIO_MAX_FUNCS		7
 
@@ -310,6 +311,10 @@ struct mmc_card {
 	struct dentry		*debugfs_root;
 	struct mmc_part	part[MMC_NUM_PHY_PARTITION]; /* physical partitions */
 	unsigned int    nr_parts;
+
+	struct mmc_queue_req	*mqrq;		/* Shared queue structure */
+	unsigned int		bouncesz;	/* Bounce buffer size */
+	int			qdepth;		/* Shared queue depth */
 };
 
 /*
