mlxsw: spectrum_acl: Pass mlxsw_sp_port down to ruleset bind/unbind ops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jiri Pirko <jiri@mellanox.com>
commit 4b23258d6a1b0040c1e7d2d997800cfd09294b7f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4b23258d.failed

No need to convert from mlxsw_sp_port to net_device and back again.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4b23258d6a1b0040c1e7d2d997800cfd09294b7f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_acl.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_acl.c
index 7fb41a4ef0b3,9439bfa4ecc2..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl.c
@@@ -118,22 -133,180 +118,157 @@@ struct mlxsw_sp_fid *mlxsw_sp_acl_dummy
  	return mlxsw_sp->acl->dummy_fid;
  }
  
 -struct mlxsw_sp *mlxsw_sp_acl_block_mlxsw_sp(struct mlxsw_sp_acl_block *block)
 -{
 -	return block->mlxsw_sp;
 -}
 -
 -unsigned int mlxsw_sp_acl_block_rule_count(struct mlxsw_sp_acl_block *block)
 -{
 -	return block ? block->rule_count : 0;
 -}
 -
 -void mlxsw_sp_acl_block_disable_inc(struct mlxsw_sp_acl_block *block)
 -{
 -	if (block)
 -		block->disable_count++;
 -}
 -
 -void mlxsw_sp_acl_block_disable_dec(struct mlxsw_sp_acl_block *block)
 -{
 -	if (block)
 -		block->disable_count--;
 -}
 -
 -bool mlxsw_sp_acl_block_disabled(struct mlxsw_sp_acl_block *block)
 +static int mlxsw_sp_acl_ruleset_bind(struct mlxsw_sp *mlxsw_sp,
 +				     struct mlxsw_sp_acl_ruleset *ruleset,
 +				     struct net_device *dev, bool ingress)
  {
 -	return block->disable_count;
 -}
 -
 -static int
 -mlxsw_sp_acl_ruleset_bind(struct mlxsw_sp *mlxsw_sp,
 -			  struct mlxsw_sp_acl_block *block,
 -			  struct mlxsw_sp_acl_block_binding *binding)
 -{
 -	struct mlxsw_sp_acl_ruleset *ruleset = block->ruleset_zero;
  	const struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;
  
++<<<<<<< HEAD
 +	return ops->ruleset_bind(mlxsw_sp, ruleset->priv, dev, ingress);
++=======
+ 	return ops->ruleset_bind(mlxsw_sp, ruleset->priv,
+ 				 binding->mlxsw_sp_port, binding->ingress);
++>>>>>>> 4b23258d6a1b (mlxsw: spectrum_acl: Pass mlxsw_sp_port down to ruleset bind/unbind ops)
  }
  
 -static void
 -mlxsw_sp_acl_ruleset_unbind(struct mlxsw_sp *mlxsw_sp,
 -			    struct mlxsw_sp_acl_block *block,
 -			    struct mlxsw_sp_acl_block_binding *binding)
 +static void mlxsw_sp_acl_ruleset_unbind(struct mlxsw_sp *mlxsw_sp,
 +					struct mlxsw_sp_acl_ruleset *ruleset,
 +					struct net_device *dev, bool ingress)
  {
 -	struct mlxsw_sp_acl_ruleset *ruleset = block->ruleset_zero;
  	const struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;
  
++<<<<<<< HEAD
 +	ops->ruleset_unbind(mlxsw_sp, ruleset->priv, dev, ingress);
++=======
+ 	ops->ruleset_unbind(mlxsw_sp, ruleset->priv,
+ 			    binding->mlxsw_sp_port, binding->ingress);
+ }
+ 
+ static bool mlxsw_sp_acl_ruleset_block_bound(struct mlxsw_sp_acl_block *block)
+ {
+ 	return block->ruleset_zero;
+ }
+ 
+ static int
+ mlxsw_sp_acl_ruleset_block_bind(struct mlxsw_sp *mlxsw_sp,
+ 				struct mlxsw_sp_acl_ruleset *ruleset,
+ 				struct mlxsw_sp_acl_block *block)
+ {
+ 	struct mlxsw_sp_acl_block_binding *binding;
+ 	int err;
+ 
+ 	block->ruleset_zero = ruleset;
+ 	list_for_each_entry(binding, &block->binding_list, list) {
+ 		err = mlxsw_sp_acl_ruleset_bind(mlxsw_sp, block, binding);
+ 		if (err)
+ 			goto rollback;
+ 	}
+ 	return 0;
+ 
+ rollback:
+ 	list_for_each_entry_continue_reverse(binding, &block->binding_list,
+ 					     list)
+ 		mlxsw_sp_acl_ruleset_unbind(mlxsw_sp, block, binding);
+ 	block->ruleset_zero = NULL;
+ 
+ 	return err;
+ }
+ 
+ static void
+ mlxsw_sp_acl_ruleset_block_unbind(struct mlxsw_sp *mlxsw_sp,
+ 				  struct mlxsw_sp_acl_ruleset *ruleset,
+ 				  struct mlxsw_sp_acl_block *block)
+ {
+ 	struct mlxsw_sp_acl_block_binding *binding;
+ 
+ 	list_for_each_entry(binding, &block->binding_list, list)
+ 		mlxsw_sp_acl_ruleset_unbind(mlxsw_sp, block, binding);
+ 	block->ruleset_zero = NULL;
+ }
+ 
+ struct mlxsw_sp_acl_block *mlxsw_sp_acl_block_create(struct mlxsw_sp *mlxsw_sp,
+ 						     struct net *net)
+ {
+ 	struct mlxsw_sp_acl_block *block;
+ 
+ 	block = kzalloc(sizeof(*block), GFP_KERNEL);
+ 	if (!block)
+ 		return NULL;
+ 	INIT_LIST_HEAD(&block->binding_list);
+ 	block->mlxsw_sp = mlxsw_sp;
+ 	return block;
+ }
+ 
+ void mlxsw_sp_acl_block_destroy(struct mlxsw_sp_acl_block *block)
+ {
+ 	WARN_ON(!list_empty(&block->binding_list));
+ 	kfree(block);
+ }
+ 
+ static struct mlxsw_sp_acl_block_binding *
+ mlxsw_sp_acl_block_lookup(struct mlxsw_sp_acl_block *block,
+ 			  struct mlxsw_sp_port *mlxsw_sp_port, bool ingress)
+ {
+ 	struct mlxsw_sp_acl_block_binding *binding;
+ 
+ 	list_for_each_entry(binding, &block->binding_list, list)
+ 		if (binding->mlxsw_sp_port == mlxsw_sp_port &&
+ 		    binding->ingress == ingress)
+ 			return binding;
+ 	return NULL;
+ }
+ 
+ int mlxsw_sp_acl_block_bind(struct mlxsw_sp *mlxsw_sp,
+ 			    struct mlxsw_sp_acl_block *block,
+ 			    struct mlxsw_sp_port *mlxsw_sp_port,
+ 			    bool ingress)
+ {
+ 	struct mlxsw_sp_acl_block_binding *binding;
+ 	int err;
+ 
+ 	if (WARN_ON(mlxsw_sp_acl_block_lookup(block, mlxsw_sp_port, ingress)))
+ 		return -EEXIST;
+ 
+ 	binding = kzalloc(sizeof(*binding), GFP_KERNEL);
+ 	if (!binding)
+ 		return -ENOMEM;
+ 	binding->mlxsw_sp_port = mlxsw_sp_port;
+ 	binding->ingress = ingress;
+ 
+ 	if (mlxsw_sp_acl_ruleset_block_bound(block)) {
+ 		err = mlxsw_sp_acl_ruleset_bind(mlxsw_sp, block, binding);
+ 		if (err)
+ 			goto err_ruleset_bind;
+ 	}
+ 
+ 	list_add(&binding->list, &block->binding_list);
+ 	return 0;
+ 
+ err_ruleset_bind:
+ 	kfree(binding);
+ 	return err;
+ }
+ 
+ int mlxsw_sp_acl_block_unbind(struct mlxsw_sp *mlxsw_sp,
+ 			      struct mlxsw_sp_acl_block *block,
+ 			      struct mlxsw_sp_port *mlxsw_sp_port,
+ 			      bool ingress)
+ {
+ 	struct mlxsw_sp_acl_block_binding *binding;
+ 
+ 	binding = mlxsw_sp_acl_block_lookup(block, mlxsw_sp_port, ingress);
+ 	if (!binding)
+ 		return -ENOENT;
+ 
+ 	list_del(&binding->list);
+ 
+ 	if (mlxsw_sp_acl_ruleset_block_bound(block))
+ 		mlxsw_sp_acl_ruleset_unbind(mlxsw_sp, block, binding);
+ 
+ 	kfree(binding);
+ 	return 0;
++>>>>>>> 4b23258d6a1b (mlxsw: spectrum_acl: Pass mlxsw_sp_port down to ruleset bind/unbind ops)
  }
  
  static struct mlxsw_sp_acl_ruleset *
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
index d8b9214cc28d..9ced26f0912d 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
@@ -474,9 +474,11 @@ struct mlxsw_sp_acl_profile_ops {
 			   void *priv, void *ruleset_priv);
 	void (*ruleset_del)(struct mlxsw_sp *mlxsw_sp, void *ruleset_priv);
 	int (*ruleset_bind)(struct mlxsw_sp *mlxsw_sp, void *ruleset_priv,
-			    struct net_device *dev, bool ingress);
+			    struct mlxsw_sp_port *mlxsw_sp_port,
+			    bool ingress);
 	void (*ruleset_unbind)(struct mlxsw_sp *mlxsw_sp, void *ruleset_priv,
-			       struct net_device *dev, bool ingress);
+			       struct mlxsw_sp_port *mlxsw_sp_port,
+			       bool ingress);
 	u16 (*ruleset_group_id)(void *ruleset_priv);
 	size_t rule_priv_size;
 	int (*rule_add)(struct mlxsw_sp *mlxsw_sp,
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_acl.c
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
index 50b2f9add20a..c6e180c2be1e 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c
@@ -258,15 +258,11 @@ static void mlxsw_sp_acl_tcam_group_del(struct mlxsw_sp *mlxsw_sp,
 static int
 mlxsw_sp_acl_tcam_group_bind(struct mlxsw_sp *mlxsw_sp,
 			     struct mlxsw_sp_acl_tcam_group *group,
-			     struct net_device *dev, bool ingress)
+			     struct mlxsw_sp_port *mlxsw_sp_port,
+			     bool ingress)
 {
-	struct mlxsw_sp_port *mlxsw_sp_port;
 	char ppbt_pl[MLXSW_REG_PPBT_LEN];
 
-	if (!mlxsw_sp_port_dev_check(dev))
-		return -EINVAL;
-
-	mlxsw_sp_port = netdev_priv(dev);
 	mlxsw_reg_ppbt_pack(ppbt_pl, ingress ? MLXSW_REG_PXBT_E_IACL :
 					       MLXSW_REG_PXBT_E_EACL,
 			    MLXSW_REG_PXBT_OP_BIND, mlxsw_sp_port->local_port,
@@ -277,15 +273,11 @@ mlxsw_sp_acl_tcam_group_bind(struct mlxsw_sp *mlxsw_sp,
 static void
 mlxsw_sp_acl_tcam_group_unbind(struct mlxsw_sp *mlxsw_sp,
 			       struct mlxsw_sp_acl_tcam_group *group,
-			       struct net_device *dev, bool ingress)
+			       struct mlxsw_sp_port *mlxsw_sp_port,
+			       bool ingress)
 {
-	struct mlxsw_sp_port *mlxsw_sp_port;
 	char ppbt_pl[MLXSW_REG_PPBT_LEN];
 
-	if (WARN_ON(!mlxsw_sp_port_dev_check(dev)))
-		return;
-
-	mlxsw_sp_port = netdev_priv(dev);
 	mlxsw_reg_ppbt_pack(ppbt_pl, ingress ? MLXSW_REG_PXBT_E_IACL :
 					       MLXSW_REG_PXBT_E_EACL,
 			    MLXSW_REG_PXBT_OP_UNBIND, mlxsw_sp_port->local_port,
@@ -1054,22 +1046,25 @@ mlxsw_sp_acl_tcam_flower_ruleset_del(struct mlxsw_sp *mlxsw_sp,
 static int
 mlxsw_sp_acl_tcam_flower_ruleset_bind(struct mlxsw_sp *mlxsw_sp,
 				      void *ruleset_priv,
-				      struct net_device *dev, bool ingress)
+				      struct mlxsw_sp_port *mlxsw_sp_port,
+				      bool ingress)
 {
 	struct mlxsw_sp_acl_tcam_flower_ruleset *ruleset = ruleset_priv;
 
 	return mlxsw_sp_acl_tcam_group_bind(mlxsw_sp, &ruleset->group,
-					    dev, ingress);
+					    mlxsw_sp_port, ingress);
 }
 
 static void
 mlxsw_sp_acl_tcam_flower_ruleset_unbind(struct mlxsw_sp *mlxsw_sp,
 					void *ruleset_priv,
-					struct net_device *dev, bool ingress)
+					struct mlxsw_sp_port *mlxsw_sp_port,
+					bool ingress)
 {
 	struct mlxsw_sp_acl_tcam_flower_ruleset *ruleset = ruleset_priv;
 
-	mlxsw_sp_acl_tcam_group_unbind(mlxsw_sp, &ruleset->group, dev, ingress);
+	mlxsw_sp_acl_tcam_group_unbind(mlxsw_sp, &ruleset->group,
+				       mlxsw_sp_port, ingress);
 }
 
 static u16
