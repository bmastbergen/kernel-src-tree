tcmu: Fix possible to/from address overflow when doing the memcpy

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Xiubo Li <lixiubo@cmss.chinamobile.com>
commit c542942cb42186f99b6d715a833c7afad359f48f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c542942c.failed

For most case the sg->length equals to PAGE_SIZE, so this bug won't
be triggered. Otherwise this will crash the kernel, for example when
all segments' sg->length equal to 1K.

	Signed-off-by: Xiubo Li <lixiubo@cmss.chinamobile.com>
	Reviewed-by: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit c542942cb42186f99b6d715a833c7afad359f48f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_user.c
diff --cc drivers/target/target_core_user.c
index 2ac4515b6a67,db29b5cd0b95..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -444,19 -550,22 +444,23 @@@ static void alloc_and_scatter_data_area
  		from = kmap_atomic(sg_page(sg)) + sg->offset;
  		while (sg_remaining > 0) {
  			if (block_remaining == 0) {
 -				if (to)
 -					kunmap_atomic(to);
 -
 +				block = find_first_zero_bit(udev->data_bitmap,
 +							    udev->max_blocks);
  				block_remaining = DATA_BLOCK_SIZE;
 -				dbi = tcmu_cmd_get_dbi(tcmu_cmd);
 -				page = tcmu_get_block_page(udev, dbi);
 -				to = kmap_atomic(page);
 +				set_bit(block, udev->data_bitmap);
 +				set_bit(block, cmd_bitmap);
  			}
 -
  			copy_bytes = min_t(size_t, sg_remaining,
  					block_remaining);
 -			to_offset = get_block_offset_user(udev, dbi,
 +			to_offset = get_block_offset(udev, block,
  					block_remaining);
++<<<<<<< HEAD
 +			to = (void *)udev->mb_addr + to_offset;
++=======
+ 
++>>>>>>> c542942cb421 (tcmu: Fix possible to/from address overflow when doing the memcpy)
  			if (*iov_cnt != 0 &&
 -			    to_offset == iov_tail(*iov)) {
 +			    to_offset == iov_tail(udev, *iov)) {
  				(*iov)->iov_len += copy_bytes;
  			} else {
  				new_iov(iov, iov_cnt, udev);
@@@ -503,11 -636,9 +509,15 @@@ static void gather_data_area(struct tcm
  			}
  			copy_bytes = min_t(size_t, sg_remaining,
  					block_remaining);
++<<<<<<< HEAD
 +			from_offset = get_block_offset(udev, block,
 +					block_remaining);
 +			from = (void *) udev->mb_addr + from_offset;
++=======
+ 			offset = DATA_BLOCK_SIZE - block_remaining;
++>>>>>>> c542942cb421 (tcmu: Fix possible to/from address overflow when doing the memcpy)
  			tcmu_flush_dcache_range(from, copy_bytes);
- 			memcpy(to + sg->length - sg_remaining, from,
+ 			memcpy(to + sg->length - sg_remaining, from + offset,
  					copy_bytes);
  
  			sg_remaining -= copy_bytes;
* Unmerged path drivers/target/target_core_user.c
