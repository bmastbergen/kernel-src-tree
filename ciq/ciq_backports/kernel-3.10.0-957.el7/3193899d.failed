tracing: Fix possible out of bounds memory access when parsing enums

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Steven Rostedt (Red Hat) <rostedt@goodmis.org>
commit 3193899d4dd54056f8c2e0b1e40dd6e2f0009f28
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3193899d.failed

The code that replaces the enum names with the enum values in the
tracepoints' format files could possible miss the end of string nul
character. This was caused by processing things like backslashes, quotes
and other tokens. After processing the tokens, a check for the nul
character needed to be done before continuing the loop, because the loop
incremented the pointer before doing the check, which could bypass the nul
character.

Link: http://lkml.kernel.org/r/552E661D.5060502@oracle.com

	Reported-by: Sasha Levin <sasha.levin@oracle.com> # via KASan
	Tested-by: Andrey Ryabinin <a.ryabinin@samsung.com>
Fixes: 0c564a538aa9 "tracing: Add TRACE_DEFINE_ENUM() macro to map enums to their values"
	Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
(cherry picked from commit 3193899d4dd54056f8c2e0b1e40dd6e2f0009f28)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace_events.c
diff --cc kernel/trace/trace_events.c
index 066ceef073dc,b49c107f82ac..000000000000
--- a/kernel/trace/trace_events.c
+++ b/kernel/trace/trace_events.c
@@@ -1669,6 -1711,131 +1669,134 @@@ __register_event(struct ftrace_event_ca
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static char *enum_replace(char *ptr, struct trace_enum_map *map, int len)
+ {
+ 	int rlen;
+ 	int elen;
+ 
+ 	/* Find the length of the enum value as a string */
+ 	elen = snprintf(ptr, 0, "%ld", map->enum_value);
+ 	/* Make sure there's enough room to replace the string with the value */
+ 	if (len < elen)
+ 		return NULL;
+ 
+ 	snprintf(ptr, elen + 1, "%ld", map->enum_value);
+ 
+ 	/* Get the rest of the string of ptr */
+ 	rlen = strlen(ptr + len);
+ 	memmove(ptr + elen, ptr + len, rlen);
+ 	/* Make sure we end the new string */
+ 	ptr[elen + rlen] = 0;
+ 
+ 	return ptr + elen;
+ }
+ 
+ static void update_event_printk(struct ftrace_event_call *call,
+ 				struct trace_enum_map *map)
+ {
+ 	char *ptr;
+ 	int quote = 0;
+ 	int len = strlen(map->enum_string);
+ 
+ 	for (ptr = call->print_fmt; *ptr; ptr++) {
+ 		if (*ptr == '\\') {
+ 			ptr++;
+ 			/* paranoid */
+ 			if (!*ptr)
+ 				break;
+ 			continue;
+ 		}
+ 		if (*ptr == '"') {
+ 			quote ^= 1;
+ 			continue;
+ 		}
+ 		if (quote)
+ 			continue;
+ 		if (isdigit(*ptr)) {
+ 			/* skip numbers */
+ 			do {
+ 				ptr++;
+ 				/* Check for alpha chars like ULL */
+ 			} while (isalnum(*ptr));
+ 			if (!*ptr)
+ 				break;
+ 			/*
+ 			 * A number must have some kind of delimiter after
+ 			 * it, and we can ignore that too.
+ 			 */
+ 			continue;
+ 		}
+ 		if (isalpha(*ptr) || *ptr == '_') {
+ 			if (strncmp(map->enum_string, ptr, len) == 0 &&
+ 			    !isalnum(ptr[len]) && ptr[len] != '_') {
+ 				ptr = enum_replace(ptr, map, len);
+ 				/* Hmm, enum string smaller than value */
+ 				if (WARN_ON_ONCE(!ptr))
+ 					return;
+ 				/*
+ 				 * No need to decrement here, as enum_replace()
+ 				 * returns the pointer to the character passed
+ 				 * the enum, and two enums can not be placed
+ 				 * back to back without something in between.
+ 				 * We can skip that something in between.
+ 				 */
+ 				continue;
+ 			}
+ 		skip_more:
+ 			do {
+ 				ptr++;
+ 			} while (isalnum(*ptr) || *ptr == '_');
+ 			if (!*ptr)
+ 				break;
+ 			/*
+ 			 * If what comes after this variable is a '.' or
+ 			 * '->' then we can continue to ignore that string.
+ 			 */
+ 			if (*ptr == '.' || (ptr[0] == '-' && ptr[1] == '>')) {
+ 				ptr += *ptr == '.' ? 1 : 2;
+ 				if (!*ptr)
+ 					break;
+ 				goto skip_more;
+ 			}
+ 			/*
+ 			 * Once again, we can skip the delimiter that came
+ 			 * after the string.
+ 			 */
+ 			continue;
+ 		}
+ 	}
+ }
+ 
+ void trace_event_enum_update(struct trace_enum_map **map, int len)
+ {
+ 	struct ftrace_event_call *call, *p;
+ 	const char *last_system = NULL;
+ 	int last_i;
+ 	int i;
+ 
+ 	down_write(&trace_event_sem);
+ 	list_for_each_entry_safe(call, p, &ftrace_events, list) {
+ 		/* events are usually grouped together with systems */
+ 		if (!last_system || call->class->system != last_system) {
+ 			last_i = 0;
+ 			last_system = call->class->system;
+ 		}
+ 
+ 		for (i = last_i; i < len; i++) {
+ 			if (call->class->system == map[i]->system) {
+ 				/* Save the first system if need be */
+ 				if (!last_i)
+ 					last_i = i;
+ 				update_event_printk(call, map[i]);
+ 			}
+ 		}
+ 	}
+ 	up_write(&trace_event_sem);
+ }
+ 
++>>>>>>> 3193899d4dd5 (tracing: Fix possible out of bounds memory access when parsing enums)
  static struct ftrace_event_file *
  trace_create_new_event(struct ftrace_event_call *call,
  		       struct trace_array *tr)
* Unmerged path kernel/trace/trace_events.c
