nvme-fc: fix nulling of queue data on reconnect

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author James Smart <jsmart2021@gmail.com>
commit 3e493c00cedb457c0731399a835f7ba1c6df172b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3e493c00.failed

The reconnect path is calling the init routines to clear a queue
structure. But the queue structure has state that perhaps needs
to persist as long as the controller is live.

Remove the nvme_fc_init_queue() calls on reconnect.
The nvme_fc_free_queue() calls will clear state bits and reset
any relevant queue state for a new connection.

	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 3e493c00cedb457c0731399a835f7ba1c6df172b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/fc.c
diff --cc drivers/nvme/host/fc.c
index d165c0527376,318e827e74ec..000000000000
--- a/drivers/nvme/host/fc.c
+++ b/drivers/nvme/host/fc.c
@@@ -1963,7 -1879,7 +1963,11 @@@ nvme_fc_free_queue(struct nvme_fc_queu
  	 */
  
  	queue->connection_id = 0;
++<<<<<<< HEAD
 +	clear_bit(NVME_FC_Q_CONNECTED, &queue->flags);
++=======
+ 	atomic_set(&queue->csn, 1);
++>>>>>>> 3e493c00cedb (nvme-fc: fix nulling of queue data on reconnect)
  }
  
  static void
@@@ -2599,13 -2489,7 +2603,17 @@@ nvme_fc_recreate_io_queues(struct nvme_
  	if (ctrl->ctrl.queue_count == 1)
  		return 0;
  
++<<<<<<< HEAD
 +	nvme_fc_init_io_queues(ctrl);
 +
 +	ret = blk_mq_reinit_tagset(&ctrl->tag_set);
++=======
+ 	ret = nvme_fc_create_hw_io_queues(ctrl, ctrl->ctrl.sqsize + 1);
++>>>>>>> 3e493c00cedb (nvme-fc: fix nulling of queue data on reconnect)
 +	if (ret)
 +		goto out_free_io_queues;
 +
 +	ret = nvme_fc_create_hw_io_queues(ctrl, ctrl->ctrl.opts->queue_size);
  	if (ret)
  		goto out_free_io_queues;
  
@@@ -2702,10 -2586,8 +2710,13 @@@ nvme_fc_create_association(struct nvme_
  	 * Create the admin queue
  	 */
  
++<<<<<<< HEAD
 +	nvme_fc_init_queue(ctrl, 0, NVME_FC_AQ_BLKMQ_DEPTH);
 +
++=======
++>>>>>>> 3e493c00cedb (nvme-fc: fix nulling of queue data on reconnect)
  	ret = __nvme_fc_create_hw_queue(ctrl, &ctrl->queues[0], 0,
 -				NVME_AQ_DEPTH);
 +				NVME_FC_AQ_BLKMQ_DEPTH);
  	if (ret)
  		goto out_free_queue;
  
@@@ -2779,10 -2669,10 +2790,10 @@@
  	 */
  
  	if (ctrl->ctrl.queue_count > 1) {
 -		if (!ctrl->ioq_live)
 +		if (ctrl->ctrl.state == NVME_CTRL_NEW)
  			ret = nvme_fc_create_io_queues(ctrl);
  		else
- 			ret = nvme_fc_reinit_io_queues(ctrl);
+ 			ret = nvme_fc_recreate_io_queues(ctrl);
  		if (ret)
  			goto out_term_aen_ops;
  	}
@@@ -3173,9 -3020,11 +3184,11 @@@ nvme_fc_init_ctrl(struct device *dev, s
  	if (!ctrl->queues)
  		goto out_free_ida;
  
+ 	nvme_fc_init_queue(ctrl, 0);
+ 
  	memset(&ctrl->admin_tag_set, 0, sizeof(ctrl->admin_tag_set));
  	ctrl->admin_tag_set.ops = &nvme_fc_admin_mq_ops;
 -	ctrl->admin_tag_set.queue_depth = NVME_AQ_MQ_TAG_DEPTH;
 +	ctrl->admin_tag_set.queue_depth = NVME_FC_AQ_BLKMQ_DEPTH;
  	ctrl->admin_tag_set.reserved_tags = 2; /* fabric connect + Keep-Alive */
  	ctrl->admin_tag_set.numa_node = NUMA_NO_NODE;
  	ctrl->admin_tag_set.cmd_size = sizeof(struct nvme_fc_fcp_op) +
* Unmerged path drivers/nvme/host/fc.c
