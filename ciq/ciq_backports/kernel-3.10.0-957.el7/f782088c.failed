xfs: pass post-eof speculative prealloc blocks to bmapi

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Brian Foster <bfoster@redhat.com>
commit f782088c9e5d08e9494c63e68b4e85716df3e5f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/f782088c.failed

xfs_file_iomap_begin_delay() implements post-eof speculative
preallocation by extending the block count of the requested delayed
allocation. Now that xfs_bmapi_reserve_delalloc() has been updated to
handle prealloc blocks separately and tag the inode, update
xfs_file_iomap_begin_delay() to use the new parameter and rely on the
former to tag the inode.

Note that this patch does not change behavior.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit f782088c9e5d08e9494c63e68b4e85716df3e5f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_iomap.c
diff --cc fs/xfs/xfs_iomap.c
index 936cba6f7d93,15a83813b708..000000000000
--- a/fs/xfs/xfs_iomap.c
+++ b/fs/xfs/xfs_iomap.c
@@@ -538,8 -540,8 +538,9 @@@ xfs_iomap_write_delay
  	int			error = 0, eof = 0;
  	struct xfs_bmbt_irec	got;
  	xfs_extnum_t		idx;
+ 	xfs_fsblock_t		prealloc_blocks = 0;
  
 +	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));
  	ASSERT(!XFS_IS_REALTIME_INODE(ip));
  	ASSERT(!xfs_get_extsz_hint(ip));
  
@@@ -604,9 -619,8 +604,14 @@@
  	}
  
  retry:
++<<<<<<< HEAD
 +	error = xfs_bmapi_reserve_delalloc(ip, offset_fsb,
 +			end_fsb - offset_fsb, &got,
 +			&prev, &idx, eof);
++=======
+ 	error = xfs_bmapi_reserve_delalloc(ip, XFS_DATA_FORK, offset_fsb,
+ 			end_fsb - offset_fsb, prealloc_blocks, &got, &idx, eof);
++>>>>>>> f782088c9e5d (xfs: pass post-eof speculative prealloc blocks to bmapi)
  	switch (error) {
  	case 0:
  		break;
@@@ -620,22 -634,9 +625,25 @@@
  		}
  		/*FALLTHRU*/
  	default:
 -		goto out_unlock;
 +		return error;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * Tag the inode as speculatively preallocated so we can reclaim this
 +	 * space on demand, if necessary.
 +	 */
 +	if (end_fsb != orig_end_fsb)
 +		xfs_inode_set_eofblocks_tag(ip);
 +
 +	/*
 +	 * Flag newly allocated delalloc blocks with IOMAP_F_NEW so we punch
 +	 * them out if the write happens to fail.
 +	 */
 +	if (iomap)
 +		iomap->flags = IOMAP_F_NEW;
++=======
++>>>>>>> f782088c9e5d (xfs: pass post-eof speculative prealloc blocks to bmapi)
  	trace_xfs_iomap_alloc(ip, offset, count, 0, &got);
  done:
  	if (isnullstartblock(got.br_startblock))
* Unmerged path fs/xfs/xfs_iomap.c
