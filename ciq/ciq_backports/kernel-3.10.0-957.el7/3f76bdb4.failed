i40e: use the more traditional 'i' loop variable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 3f76bdb437c6a9a4621ee64f1c877b7532efa7d3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3f76bdb4.failed

Since we no longer use i as an array index for the data variable,
replace the use of 'j' with 'i' so that we match the general loop
variable name.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 3f76bdb437c6a9a4621ee64f1c877b7532efa7d3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_ethtool.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index 07042090c395,6947a2a571cb..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@@ -1622,30 -1726,37 +1622,50 @@@ static void i40e_get_ethtool_stats(stru
  	struct i40e_ring *tx_ring, *rx_ring;
  	struct i40e_vsi *vsi = np->vsi;
  	struct i40e_pf *pf = vsi->back;
++<<<<<<< HEAD
 +	unsigned int j;
 +	int i = 0;
++=======
+ 	unsigned int i;
++>>>>>>> 3f76bdb437c6 (i40e: use the more traditional 'i' loop variable)
  	char *p;
  	struct rtnl_link_stats64 *net_stats = i40e_get_vsi_stats_struct(vsi);
  	unsigned int start;
  
  	i40e_update_stats(vsi);
  
++<<<<<<< HEAD
 +	for (j = 0; j < I40E_NETDEV_STATS_LEN; j++) {
 +		p = (char *)net_stats + i40e_gstrings_net_stats[j].stat_offset;
 +		data[i++] = (i40e_gstrings_net_stats[j].sizeof_stat ==
 +			sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
 +	}
 +	for (j = 0; j < I40E_MISC_STATS_LEN; j++) {
 +		p = (char *)vsi + i40e_gstrings_misc_stats[j].stat_offset;
 +		data[i++] = (i40e_gstrings_misc_stats[j].sizeof_stat ==
 +			    sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
 +	}
 +	rcu_read_lock();
 +	for (j = 0; j < vsi->num_queue_pairs; j++) {
 +		tx_ring = ACCESS_ONCE(vsi->tx_rings[j]);
++=======
+ 	for (i = 0; i < I40E_NETDEV_STATS_LEN; i++) {
+ 		p = (char *)net_stats + i40e_gstrings_net_stats[i].stat_offset;
+ 		*(data++) = (i40e_gstrings_net_stats[i].sizeof_stat ==
+ 			sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
+ 	}
+ 	for (i = 0; i < I40E_MISC_STATS_LEN; i++) {
+ 		p = (char *)vsi + i40e_gstrings_misc_stats[i].stat_offset;
+ 		*(data++) = (i40e_gstrings_misc_stats[i].sizeof_stat ==
+ 			    sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
+ 	}
+ 	rcu_read_lock();
+ 	for (i = 0; i < I40E_MAX_NUM_QUEUES(netdev) ; i++) {
+ 		tx_ring = READ_ONCE(vsi->tx_rings[i]);
++>>>>>>> 3f76bdb437c6 (i40e: use the more traditional 'i' loop variable)
  
 -		if (!tx_ring) {
 -			/* Bump the stat counter to skip these stats, and make
 -			 * sure the memory is zero'd
 -			 */
 -			*(data++) = 0;
 -			*(data++) = 0;
 -			*(data++) = 0;
 -			*(data++) = 0;
 +		if (!tx_ring)
  			continue;
 -		}
  
  		/* process Tx ring statistics */
  		do {
@@@ -1672,40 -1783,131 +1692,70 @@@
  	    (pf->flags & I40E_FLAG_VEB_STATS_ENABLED)) {
  		struct i40e_veb *veb = pf->veb[pf->lan_veb];
  
- 		for (j = 0; j < I40E_VEB_STATS_LEN; j++) {
+ 		for (i = 0; i < I40E_VEB_STATS_LEN; i++) {
  			p = (char *)veb;
++<<<<<<< HEAD
 +			p += i40e_gstrings_veb_stats[j].stat_offset;
 +			data[i++] = (i40e_gstrings_veb_stats[j].sizeof_stat ==
 +				     sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
 +		}
 +		for (j = 0; j < I40E_MAX_TRAFFIC_CLASS; j++) {
 +			data[i++] = veb->tc_stats.tc_tx_packets[j];
 +			data[i++] = veb->tc_stats.tc_tx_bytes[j];
 +			data[i++] = veb->tc_stats.tc_rx_packets[j];
 +			data[i++] = veb->tc_stats.tc_rx_bytes[j];
++=======
+ 			p += i40e_gstrings_veb_stats[i].stat_offset;
+ 			*(data++) = (i40e_gstrings_veb_stats[i].sizeof_stat ==
+ 				     sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
+ 		}
+ 		for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+ 			*(data++) = veb->tc_stats.tc_tx_packets[i];
+ 			*(data++) = veb->tc_stats.tc_tx_bytes[i];
+ 			*(data++) = veb->tc_stats.tc_rx_packets[i];
+ 			*(data++) = veb->tc_stats.tc_rx_bytes[i];
++>>>>>>> 3f76bdb437c6 (i40e: use the more traditional 'i' loop variable)
  		}
  	} else {
 -		data += I40E_VEB_STATS_TOTAL;
 +		i += I40E_VEB_STATS_TOTAL;
  	}
++<<<<<<< HEAD
 +	for (j = 0; j < I40E_GLOBAL_STATS_LEN; j++) {
 +		p = (char *)pf + i40e_gstrings_stats[j].stat_offset;
 +		data[i++] = (i40e_gstrings_stats[j].sizeof_stat ==
 +			     sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
 +	}
 +	for (j = 0; j < I40E_MAX_USER_PRIORITY; j++) {
 +		data[i++] = pf->stats.priority_xon_tx[j];
 +		data[i++] = pf->stats.priority_xoff_tx[j];
 +	}
 +	for (j = 0; j < I40E_MAX_USER_PRIORITY; j++) {
 +		data[i++] = pf->stats.priority_xon_rx[j];
 +		data[i++] = pf->stats.priority_xoff_rx[j];
 +	}
 +	for (j = 0; j < I40E_MAX_USER_PRIORITY; j++)
 +		data[i++] = pf->stats.priority_xon_2_xoff[j];
++=======
+ 	for (i = 0; i < I40E_GLOBAL_STATS_LEN; i++) {
+ 		p = (char *)pf + i40e_gstrings_stats[i].stat_offset;
+ 		*(data++) = (i40e_gstrings_stats[i].sizeof_stat ==
+ 			     sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
+ 	}
+ 	for (i = 0; i < I40E_MAX_USER_PRIORITY; i++) {
+ 		*(data++) = pf->stats.priority_xon_tx[i];
+ 		*(data++) = pf->stats.priority_xoff_tx[i];
+ 	}
+ 	for (i = 0; i < I40E_MAX_USER_PRIORITY; i++) {
+ 		*(data++) = pf->stats.priority_xon_rx[i];
+ 		*(data++) = pf->stats.priority_xoff_rx[i];
+ 	}
+ 	for (i = 0; i < I40E_MAX_USER_PRIORITY; i++)
+ 		*(data++) = pf->stats.priority_xon_2_xoff[i];
++>>>>>>> 3f76bdb437c6 (i40e: use the more traditional 'i' loop variable)
  }
  
 -/**
 - * i40e_get_stat_strings - copy stat strings into supplied buffer
 - * @netdev: the netdev to collect strings for
 - * @data: supplied buffer to copy strings into
 - *
 - * Copy the strings related to stats for this netdev. Expects data to be
 - * pre-allocated with the size reported by i40e_get_stats_count. Note that the
 - * strings must be copied in a static order and the total count must not
 - * change for a given netdev. See i40e_get_stats_count for more details.
 - **/
 -static void i40e_get_stat_strings(struct net_device *netdev, u8 *data)
 -{
 -	struct i40e_netdev_priv *np = netdev_priv(netdev);
 -	struct i40e_vsi *vsi = np->vsi;
 -	struct i40e_pf *pf = vsi->back;
 -	unsigned int i;
 -	u8 *p = data;
 -
 -	for (i = 0; i < I40E_NETDEV_STATS_LEN; i++) {
 -		snprintf(data, ETH_GSTRING_LEN, "%s",
 -			 i40e_gstrings_net_stats[i].stat_string);
 -		data += ETH_GSTRING_LEN;
 -	}
 -	for (i = 0; i < I40E_MISC_STATS_LEN; i++) {
 -		snprintf(data, ETH_GSTRING_LEN, "%s",
 -			 i40e_gstrings_misc_stats[i].stat_string);
 -		data += ETH_GSTRING_LEN;
 -	}
 -	for (i = 0; i < I40E_MAX_NUM_QUEUES(netdev); i++) {
 -		snprintf(data, ETH_GSTRING_LEN, "tx-%u.tx_packets", i);
 -		data += ETH_GSTRING_LEN;
 -		snprintf(data, ETH_GSTRING_LEN, "tx-%u.tx_bytes", i);
 -		data += ETH_GSTRING_LEN;
 -		snprintf(data, ETH_GSTRING_LEN, "rx-%u.rx_packets", i);
 -		data += ETH_GSTRING_LEN;
 -		snprintf(data, ETH_GSTRING_LEN, "rx-%u.rx_bytes", i);
 -		data += ETH_GSTRING_LEN;
 -	}
 -	if (vsi != pf->vsi[pf->lan_vsi] || pf->hw.partition_id != 1)
 -		return;
 -
 -	for (i = 0; i < I40E_VEB_STATS_LEN; i++) {
 -		snprintf(data, ETH_GSTRING_LEN, "%s",
 -			 i40e_gstrings_veb_stats[i].stat_string);
 -		data += ETH_GSTRING_LEN;
 -	}
 -	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
 -		snprintf(data, ETH_GSTRING_LEN,
 -			 "veb.tc_%u_tx_packets", i);
 -		data += ETH_GSTRING_LEN;
 -		snprintf(data, ETH_GSTRING_LEN,
 -			 "veb.tc_%u_tx_bytes", i);
 -		data += ETH_GSTRING_LEN;
 -		snprintf(data, ETH_GSTRING_LEN,
 -			 "veb.tc_%u_rx_packets", i);
 -		data += ETH_GSTRING_LEN;
 -		snprintf(data, ETH_GSTRING_LEN,
 -			 "veb.tc_%u_rx_bytes", i);
 -		data += ETH_GSTRING_LEN;
 -	}
 -
 -	for (i = 0; i < I40E_GLOBAL_STATS_LEN; i++) {
 -		snprintf(data, ETH_GSTRING_LEN, "%s",
 -			 i40e_gstrings_stats[i].stat_string);
 -		data += ETH_GSTRING_LEN;
 -	}
 -	for (i = 0; i < I40E_MAX_USER_PRIORITY; i++) {
 -		snprintf(data, ETH_GSTRING_LEN,
 -			 "port.tx_priority_%u_xon", i);
 -		data += ETH_GSTRING_LEN;
 -		snprintf(data, ETH_GSTRING_LEN,
 -			 "port.tx_priority_%u_xoff", i);
 -		data += ETH_GSTRING_LEN;
 -	}
 -	for (i = 0; i < I40E_MAX_USER_PRIORITY; i++) {
 -		snprintf(data, ETH_GSTRING_LEN,
 -			 "port.rx_priority_%u_xon", i);
 -		data += ETH_GSTRING_LEN;
 -		snprintf(data, ETH_GSTRING_LEN,
 -			 "port.rx_priority_%u_xoff", i);
 -		data += ETH_GSTRING_LEN;
 -	}
 -	for (i = 0; i < I40E_MAX_USER_PRIORITY; i++) {
 -		snprintf(data, ETH_GSTRING_LEN,
 -			 "port.rx_priority_%u_xon_2_xoff", i);
 -		data += ETH_GSTRING_LEN;
 -	}
 -
 -	WARN_ONCE(p - data != i40e_get_stats_count(netdev) * ETH_GSTRING_LEN,
 -		  "stat strings count mismatch!");
 -}
 -
 -static void i40e_get_priv_flag_strings(struct net_device *netdev, u8 *data)
 +static void i40e_get_strings(struct net_device *netdev, u32 stringset,
 +			     u8 *data)
  {
  	struct i40e_netdev_priv *np = netdev_priv(netdev);
  	struct i40e_vsi *vsi = np->vsi;
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_ethtool.c
