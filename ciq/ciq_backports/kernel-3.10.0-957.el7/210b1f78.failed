IB/mlx5: When not in dual port RoCE mode, use provided port as native

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Mark Bloch <markb@mellanox.com>
commit 210b1f78076f88cad25b333fffafbac6ae870fcc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/210b1f78.failed

The series that introduced dual port RoCE mode assumed that we don't have
a dual port HCA that use the mlx5 driver, this is not the case for
Connect-IB HCAs. This reasoning led to assigning 1 as the native port
index which causes issue when the second port is used.

For example query_pkey() when called on the second port will return values
of the first port. Make sure that we assign the right port index as the
native port index.

Fixes: 32f69e4be269 ("{net, IB}/mlx5: Manage port association for multiport RoCE")
	Reviewed-by: Daniel Jurgens <danielj@mellanox.com>
	Signed-off-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 210b1f78076f88cad25b333fffafbac6ae870fcc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
diff --cc drivers/infiniband/hw/mlx5/main.c
index a4d7e9c37555,033b6af90de9..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -192,6 -233,71 +192,72 @@@ static struct net_device *mlx5_ib_get_n
  	return ndev;
  }
  
++<<<<<<< HEAD
++=======
+ struct mlx5_core_dev *mlx5_ib_get_native_port_mdev(struct mlx5_ib_dev *ibdev,
+ 						   u8 ib_port_num,
+ 						   u8 *native_port_num)
+ {
+ 	enum rdma_link_layer ll = mlx5_ib_port_link_layer(&ibdev->ib_dev,
+ 							  ib_port_num);
+ 	struct mlx5_core_dev *mdev = NULL;
+ 	struct mlx5_ib_multiport_info *mpi;
+ 	struct mlx5_ib_port *port;
+ 
+ 	if (!mlx5_core_mp_enabled(ibdev->mdev) ||
+ 	    ll != IB_LINK_LAYER_ETHERNET) {
+ 		if (native_port_num)
+ 			*native_port_num = ib_port_num;
+ 		return ibdev->mdev;
+ 	}
+ 
+ 	if (native_port_num)
+ 		*native_port_num = 1;
+ 
+ 	port = &ibdev->port[ib_port_num - 1];
+ 	if (!port)
+ 		return NULL;
+ 
+ 	spin_lock(&port->mp.mpi_lock);
+ 	mpi = ibdev->port[ib_port_num - 1].mp.mpi;
+ 	if (mpi && !mpi->unaffiliate) {
+ 		mdev = mpi->mdev;
+ 		/* If it's the master no need to refcount, it'll exist
+ 		 * as long as the ib_dev exists.
+ 		 */
+ 		if (!mpi->is_master)
+ 			mpi->mdev_refcnt++;
+ 	}
+ 	spin_unlock(&port->mp.mpi_lock);
+ 
+ 	return mdev;
+ }
+ 
+ void mlx5_ib_put_native_port_mdev(struct mlx5_ib_dev *ibdev, u8 port_num)
+ {
+ 	enum rdma_link_layer ll = mlx5_ib_port_link_layer(&ibdev->ib_dev,
+ 							  port_num);
+ 	struct mlx5_ib_multiport_info *mpi;
+ 	struct mlx5_ib_port *port;
+ 
+ 	if (!mlx5_core_mp_enabled(ibdev->mdev) || ll != IB_LINK_LAYER_ETHERNET)
+ 		return;
+ 
+ 	port = &ibdev->port[port_num - 1];
+ 
+ 	spin_lock(&port->mp.mpi_lock);
+ 	mpi = ibdev->port[port_num - 1].mp.mpi;
+ 	if (mpi->is_master)
+ 		goto out;
+ 
+ 	mpi->mdev_refcnt--;
+ 	if (mpi->unaffiliate)
+ 		complete(&mpi->unref_comp);
+ out:
+ 	spin_unlock(&port->mp.mpi_lock);
+ }
+ 
++>>>>>>> 210b1f78076f (IB/mlx5: When not in dual port RoCE mode, use provided port as native)
  static int translate_eth_proto_oper(u32 eth_proto_oper, u8 *active_speed,
  				    u8 *active_width)
  {
* Unmerged path drivers/infiniband/hw/mlx5/main.c
