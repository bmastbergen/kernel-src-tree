mmc: block: stop passing around pointless return values

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] block: stop passing around pointless return values (Gopal Tiwari) [1549495]
Rebuild_FUZZ: 95.24%
commit-author Linus Walleij <linus.walleij@linaro.org>
commit df0615889651321712b0b429780617d35c1ed963
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/df061588.failed

The mmc_blk_issue_rq() function is called in exactly one place
in queue.c and there the return value is ignored. So the
functions called from that function that also meticulously
return 0/1 do so for no good reason.

Error reporting on the asynchronous requests are done upward to
the block layer when the requests are eventually completed or
fail, which may happen during the flow of the mmc_blk_issue_*
functions directly (for "special commands") or later, when an
asynchronous read/write request is completed.

The issuing functions do not give rise to errors on their own,
and there is nothing to return back to the caller in queue.c.
Drop all return values and make the function return void.

	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit df0615889651321712b0b429780617d35c1ed963)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/block.c
#	drivers/mmc/core/block.h
diff --cc drivers/mmc/core/block.c
index 993977f4fb6c,6c8be1a80551..000000000000
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@@ -1591,7 -1592,34 +1585,38 @@@ static int mmc_blk_cmd_err(struct mmc_b
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)
++=======
+ static void mmc_blk_rw_cmd_abort(struct mmc_card *card, struct request *req)
+ {
+ 	int ret = 1;
+ 
+ 	if (mmc_card_removed(card))
+ 		req->rq_flags |= RQF_QUIET;
+ 	while (ret)
+ 		ret = blk_end_request(req, -EIO,
+ 				      blk_rq_cur_bytes(req));
+ }
+ 
+ static void mmc_blk_rw_start_new(struct mmc_queue *mq, struct mmc_card *card,
+ 				 struct request *req)
+ {
+ 	if (!req)
+ 		return;
+ 
+ 	if (mmc_card_removed(card)) {
+ 		req->rq_flags |= RQF_QUIET;
+ 		blk_end_request_all(req, -EIO);
+ 	} else {
+ 		mmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);
+ 		mmc_start_req(card->host,
+ 			      &mq->mqrq_cur->mmc_active, NULL);
+ 	}
+ }
+ 
+ static void mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)
++>>>>>>> df0615889651 (mmc: block: stop passing around pointless return values)
  {
  	struct mmc_blk_data *md = mq->blkdata;
  	struct mmc_card *card = md->queue.card;
@@@ -1736,31 -1764,16 +1761,35 @@@
  		}
  	} while (ret);
  
- 	return 1;
+ 	return;
  
   cmd_abort:
 -	mmc_blk_rw_cmd_abort(card, req);
 +	if (mmc_card_removed(card))
 +		req->cmd_flags |= REQ_QUIET;
 +	while (ret)
 +		ret = blk_end_request(req, -EIO,
 +				blk_rq_cur_bytes(req));
  
   start_new_req:
++<<<<<<< HEAD
 +	if (rqc) {
 +		if (mmc_card_removed(card)) {
 +			rqc->cmd_flags |= REQ_QUIET;
 +			blk_end_request_all(rqc, -EIO);
 +		} else {
 +			mmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);
 +			mmc_start_req(card->host,
 +				      &mq->mqrq_cur->mmc_active, NULL);
 +		}
 +	}
 +
 +	return 0;
++=======
+ 	mmc_blk_rw_start_new(mq, card, rqc);
++>>>>>>> df0615889651 (mmc: block: stop passing around pointless return values)
  }
  
- int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
+ void mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
  {
  	int ret;
  	struct mmc_blk_data *md = mq->blkdata;
@@@ -1785,11 -1797,13 +1813,21 @@@
  		/* complete ongoing async transfer before issuing discard */
  		if (card->host->areq)
  			mmc_blk_issue_rw_rq(mq, NULL);
++<<<<<<< HEAD
 +		if (req->cmd_flags & REQ_SECURE)
 +			ret = mmc_blk_issue_secdiscard_rq(mq, req);
 +		else
 +			ret = mmc_blk_issue_discard_rq(mq, req);
 +	} else if (cmd_flags & REQ_FLUSH) {
++=======
+ 		mmc_blk_issue_discard_rq(mq, req);
+ 	} else if (req && req_op(req) == REQ_OP_SECURE_ERASE) {
+ 		/* complete ongoing async transfer before issuing secure erase*/
+ 		if (card->host->areq)
+ 			mmc_blk_issue_rw_rq(mq, NULL);
+ 		mmc_blk_issue_secdiscard_rq(mq, req);
+ 	} else if (req && req_op(req) == REQ_OP_FLUSH) {
++>>>>>>> df0615889651 (mmc: block: stop passing around pointless return values)
  		/* complete ongoing async transfer before issuing flush */
  		if (card->host->areq)
  			mmc_blk_issue_rw_rq(mq, NULL);
diff --cc drivers/mmc/core/block.h
index cdabb2ee74be,860ca7c8df86..000000000000
--- a/drivers/mmc/core/block.h
+++ b/drivers/mmc/core/block.h
@@@ -1,1 -1,9 +1,13 @@@
++<<<<<<< HEAD
 +int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req);
++=======
+ #ifndef _MMC_CORE_BLOCK_H
+ #define _MMC_CORE_BLOCK_H
+ 
+ struct mmc_queue;
+ struct request;
+ 
+ void mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req);
+ 
+ #endif
++>>>>>>> df0615889651 (mmc: block: stop passing around pointless return values)
* Unmerged path drivers/mmc/core/block.c
* Unmerged path drivers/mmc/core/block.h
