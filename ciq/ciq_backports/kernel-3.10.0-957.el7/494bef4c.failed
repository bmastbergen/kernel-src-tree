sfc: insert ARFS filters with replace_equal=true

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Edward Cree <ecree@solarflare.com>
commit 494bef4c2a087876e75f3e95f7f63b06d6a65921
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/494bef4c.failed

Necessary to allow redirecting a flow when the application moves.

Fixes: 3af0f34290f6 ("sfc: replace asynchronous filter operations")
	Signed-off-by: Edward Cree <ecree@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 494bef4c2a087876e75f3e95f7f63b06d6a65921)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/rx.c
diff --cc drivers/net/ethernet/sfc/rx.c
index 90c85f16047f,13b0eb71dbf3..000000000000
--- a/drivers/net/ethernet/sfc/rx.c
+++ b/drivers/net/ethernet/sfc/rx.c
@@@ -827,6 -827,61 +827,64 @@@ MODULE_PARM_DESC(rx_refill_threshold
  
  #ifdef CONFIG_RFS_ACCEL
  
++<<<<<<< HEAD
++=======
+ /**
+  * struct efx_async_filter_insertion - Request to asynchronously insert a filter
+  * @net_dev: Reference to the netdevice
+  * @spec: The filter to insert
+  * @work: Workitem for this request
+  * @rxq_index: Identifies the channel for which this request was made
+  * @flow_id: Identifies the kernel-side flow for which this request was made
+  */
+ struct efx_async_filter_insertion {
+ 	struct net_device *net_dev;
+ 	struct efx_filter_spec spec;
+ 	struct work_struct work;
+ 	u16 rxq_index;
+ 	u32 flow_id;
+ };
+ 
+ static void efx_filter_rfs_work(struct work_struct *data)
+ {
+ 	struct efx_async_filter_insertion *req = container_of(data, struct efx_async_filter_insertion,
+ 							      work);
+ 	struct efx_nic *efx = netdev_priv(req->net_dev);
+ 	struct efx_channel *channel = efx_get_channel(efx, req->rxq_index);
+ 	int rc;
+ 
+ 	rc = efx->type->filter_insert(efx, &req->spec, true);
+ 	if (rc >= 0) {
+ 		/* Remember this so we can check whether to expire the filter
+ 		 * later.
+ 		 */
+ 		mutex_lock(&efx->rps_mutex);
+ 		channel->rps_flow_id[rc] = req->flow_id;
+ 		++channel->rfs_filters_added;
+ 		mutex_unlock(&efx->rps_mutex);
+ 
+ 		if (req->spec.ether_type == htons(ETH_P_IP))
+ 			netif_info(efx, rx_status, efx->net_dev,
+ 				   "steering %s %pI4:%u:%pI4:%u to queue %u [flow %u filter %d]\n",
+ 				   (req->spec.ip_proto == IPPROTO_TCP) ? "TCP" : "UDP",
+ 				   req->spec.rem_host, ntohs(req->spec.rem_port),
+ 				   req->spec.loc_host, ntohs(req->spec.loc_port),
+ 				   req->rxq_index, req->flow_id, rc);
+ 		else
+ 			netif_info(efx, rx_status, efx->net_dev,
+ 				   "steering %s [%pI6]:%u:[%pI6]:%u to queue %u [flow %u filter %d]\n",
+ 				   (req->spec.ip_proto == IPPROTO_TCP) ? "TCP" : "UDP",
+ 				   req->spec.rem_host, ntohs(req->spec.rem_port),
+ 				   req->spec.loc_host, ntohs(req->spec.loc_port),
+ 				   req->rxq_index, req->flow_id, rc);
+ 	}
+ 
+ 	/* Release references */
+ 	dev_put(req->net_dev);
+ 	kfree(req);
+ }
+ 
++>>>>>>> 494bef4c2a08 (sfc: insert ARFS filters with replace_equal=true)
  int efx_filter_rfs(struct net_device *net_dev, const struct sk_buff *skb,
  		   u16 rxq_index, u32 flow_id)
  {
* Unmerged path drivers/net/ethernet/sfc/rx.c
