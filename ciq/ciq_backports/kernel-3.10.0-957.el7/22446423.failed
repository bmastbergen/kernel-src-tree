ext4: fix ENOSPC handling in DAX page fault handler

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jan Kara <jack@suse.cz>
commit 22446423108f3687167c9fdc080e6f21dd784d18
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/22446423.failed

When allocation of underlying block for a page fault fails, we fail the
fault with SIGBUS. However we may well hit ENOSPC just due to lots of
free blocks being held by the running / committing transaction. So
propagate the error from ext4_iomap_begin() and implement do standard
allocation retry loop in ext4_dax_huge_fault().

	Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit 22446423108f3687167c9fdc080e6f21dd784d18)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/file.c
diff --cc fs/ext4/file.c
index feb7f54458b2,fb6f023622fe..000000000000
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@@ -295,18 -305,27 +296,32 @@@ static int ext4_dax_huge_fault(struct v
  		sb_start_pagefault(sb);
  		file_update_time(vmf->vma->vm_file);
  		down_read(&EXT4_I(inode)->i_mmap_sem);
+ retry:
  		handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,
  					       EXT4_DATA_TRANS_BLOCKS(sb));
 -		if (IS_ERR(handle)) {
 -			up_read(&EXT4_I(inode)->i_mmap_sem);
 -			sb_end_pagefault(sb);
 -			return VM_FAULT_SIGBUS;
 -		}
  	} else {
  		down_read(&EXT4_I(inode)->i_mmap_sem);
  	}
++<<<<<<< HEAD
 +	if (!IS_ERR(handle))
 +		result = dax_iomap_fault(vmf, pe_size, &ext4_iomap_ops);
 +	else
 +		result = VM_FAULT_SIGBUS;
 +	if (write) {
 +		if (!IS_ERR(handle))
 +			ext4_journal_stop(handle);
++=======
+ 	result = dax_iomap_fault(vmf, pe_size, &pfn, &error, &ext4_iomap_ops);
+ 	if (write) {
+ 		ext4_journal_stop(handle);
+ 
+ 		if ((result & VM_FAULT_ERROR) && error == -ENOSPC &&
+ 		    ext4_should_retry_alloc(sb, &retries))
+ 			goto retry;
+ 		/* Handling synchronous page fault? */
+ 		if (result & VM_FAULT_NEEDDSYNC)
+ 			result = dax_finish_sync_fault(vmf, pe_size, pfn);
++>>>>>>> 22446423108f (ext4: fix ENOSPC handling in DAX page fault handler)
  		up_read(&EXT4_I(inode)->i_mmap_sem);
  		sb_end_pagefault(sb);
  	} else {
* Unmerged path fs/ext4/file.c
