xfs: allow reading of already-locked remote symbolic link

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 5da8f2f8908aabcfa4113d37d470039c79962ba9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5da8f2f8.failed

Expose the readlink variant that doesn't take the inode lock so that
the scrubber can inspect symlink contents.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
(cherry picked from commit 5da8f2f8908aabcfa4113d37d470039c79962ba9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_symlink.c
diff --cc fs/xfs/xfs_symlink.c
index a0d9a7837984,493804857d67..000000000000
--- a/fs/xfs/xfs_symlink.c
+++ b/fs/xfs/xfs_symlink.c
@@@ -151,12 -153,7 +151,16 @@@ xfs_readlink
  	}
  
  
++<<<<<<< HEAD
 +	if (ip->i_df.if_flags & XFS_IFINLINE) {
 +		memcpy(link, ip->i_df.if_u1.if_data, pathlen);
 +		link[pathlen] = '\0';
 +	} else {
 +		error = xfs_readlink_bmap(ip, link);
 +	}
++=======
+ 	error = xfs_readlink_bmap_ilocked(ip, link);
++>>>>>>> 5da8f2f8908a (xfs: allow reading of already-locked remote symbolic link)
  
   out:
  	xfs_iunlock(ip, XFS_ILOCK_SHARED);
* Unmerged path fs/xfs/xfs_symlink.c
diff --git a/fs/xfs/xfs_symlink.h b/fs/xfs/xfs_symlink.h
index e75245d09116..aeaee8923617 100644
--- a/fs/xfs/xfs_symlink.h
+++ b/fs/xfs/xfs_symlink.h
@@ -21,6 +21,7 @@
 
 int xfs_symlink(struct xfs_inode *dp, struct xfs_name *link_name,
 		const char *target_path, umode_t mode, struct xfs_inode **ipp);
+int xfs_readlink_bmap_ilocked(struct xfs_inode *ip, char *link);
 int xfs_readlink(struct xfs_inode *ip, char *link);
 int xfs_inactive_symlink(struct xfs_inode *ip);
 
