IB/opa_vnic: Add routing control information

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Niranjana Vishwanathapura <niranjana.vishwanathapura@intel.com>
commit b209a368eb72cacce290e327d3f783e9cdee040c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b209a368.failed

Add protocol specific routing control information in the encapsulation
header as per the configuration.

	Reviewed-by: Sudeep Dutt <sudeep.dutt@intel.com>
	Signed-off-by: Niranjana Vishwanathapura <niranjana.vishwanathapura@intel.com>
	Signed-off-by: Scott Franco <safranco@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit b209a368eb72cacce290e327d3f783e9cdee040c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/opa_vnic/opa_vnic_encap.h
#	drivers/infiniband/ulp/opa_vnic/opa_vnic_internal.h
diff --cc drivers/infiniband/ulp/opa_vnic/opa_vnic_encap.h
index 4c434b9dd84c,e4c9bf2ef7e2..000000000000
--- a/drivers/infiniband/ulp/opa_vnic/opa_vnic_encap.h
+++ b/drivers/infiniband/ulp/opa_vnic/opa_vnic_encap.h
@@@ -111,8 -122,8 +122,13 @@@
   * @pkey: partition key
   * @u_mcast_dlid: unknown multicast dlid
   * @u_ucast_dlid: array of unknown unicast dlids
++<<<<<<< HEAD
 + * @eth_mtu: MTUs for each vlan PCP
 + * @eth_mtu_non_vlan: MTU for non vlan packets
++=======
+  * @rc: routing control
+  * @eth_mtu: Ethernet MTU
++>>>>>>> b209a368eb72 (IB/opa_vnic: Add routing control information)
   */
  struct opa_vesw_info {
  	__be16  fabric_id;
@@@ -128,9 -139,10 +144,16 @@@
  	__be32  u_mcast_dlid;
  	__be32  u_ucast_dlid[OPA_VESW_MAX_NUM_DEF_PORT];
  
++<<<<<<< HEAD
 +	u8      rsvd3[44];
 +	__be16  eth_mtu[OPA_VNIC_MAX_NUM_PCP];
 +	__be16  eth_mtu_non_vlan;
++=======
+ 	__be32  rc;
+ 
+ 	u8      rsvd3[56];
+ 	__be16  eth_mtu;
++>>>>>>> b209a368eb72 (IB/opa_vnic: Add routing control information)
  	u8      rsvd4[2];
  } __packed;
  
diff --cc drivers/infiniband/ulp/opa_vnic/opa_vnic_internal.h
index ca29e6d5aedc,afd95f432262..000000000000
--- a/drivers/infiniband/ulp/opa_vnic/opa_vnic_internal.h
+++ b/drivers/infiniband/ulp/opa_vnic/opa_vnic_internal.h
@@@ -89,9 -89,10 +89,16 @@@ struct __opa_vesw_info 
  	u32  u_mcast_dlid;
  	u32  u_ucast_dlid[OPA_VESW_MAX_NUM_DEF_PORT];
  
++<<<<<<< HEAD
 +	u8   rsvd3[44];
 +	u16  eth_mtu[OPA_VNIC_MAX_NUM_PCP];
 +	u16  eth_mtu_non_vlan;
++=======
+ 	u32  rc;
+ 
+ 	u8   rsvd3[56];
+ 	u16  eth_mtu;
++>>>>>>> b209a368eb72 (IB/opa_vnic: Add routing control information)
  	u8   rsvd4[2];
  } __packed;
  
diff --git a/drivers/infiniband/ulp/opa_vnic/opa_vnic_encap.c b/drivers/infiniband/ulp/opa_vnic/opa_vnic_encap.c
index 88c3de23b51d..a7c0a61506c8 100644
--- a/drivers/infiniband/ulp/opa_vnic/opa_vnic_encap.c
+++ b/drivers/infiniband/ulp/opa_vnic/opa_vnic_encap.c
@@ -406,6 +406,42 @@ u8 opa_vnic_get_vl(struct opa_vnic_adapter *adapter, struct sk_buff *skb)
 	return vl;
 }
 
+/* opa_vnic_get_rc - return the routing control */
+static u8 opa_vnic_get_rc(struct __opa_veswport_info *info,
+			  struct sk_buff *skb)
+{
+	u8 proto, rout_ctrl;
+
+	switch (vlan_get_protocol(skb)) {
+	case htons(ETH_P_IPV6):
+		proto = ipv6_hdr(skb)->nexthdr;
+		if (proto == IPPROTO_TCP)
+			rout_ctrl = OPA_VNIC_ENCAP_RC_EXT(info->vesw.rc,
+							  IPV6_TCP);
+		else if (proto == IPPROTO_UDP)
+			rout_ctrl = OPA_VNIC_ENCAP_RC_EXT(info->vesw.rc,
+							  IPV6_UDP);
+		else
+			rout_ctrl = OPA_VNIC_ENCAP_RC_EXT(info->vesw.rc, IPV6);
+		break;
+	case htons(ETH_P_IP):
+		proto = ip_hdr(skb)->protocol;
+		if (proto == IPPROTO_TCP)
+			rout_ctrl = OPA_VNIC_ENCAP_RC_EXT(info->vesw.rc,
+							  IPV4_TCP);
+		else if (proto == IPPROTO_UDP)
+			rout_ctrl = OPA_VNIC_ENCAP_RC_EXT(info->vesw.rc,
+							  IPV4_UDP);
+		else
+			rout_ctrl = OPA_VNIC_ENCAP_RC_EXT(info->vesw.rc, IPV4);
+		break;
+	default:
+		rout_ctrl = OPA_VNIC_ENCAP_RC_EXT(info->vesw.rc, DEFAULT);
+	}
+
+	return rout_ctrl;
+}
+
 /* opa_vnic_calc_entropy - calculate the packet entropy */
 u8 opa_vnic_calc_entropy(struct opa_vnic_adapter *adapter, struct sk_buff *skb)
 {
@@ -448,7 +484,7 @@ void opa_vnic_encap_skb(struct opa_vnic_adapter *adapter, struct sk_buff *skb)
 {
 	struct __opa_veswport_info *info = &adapter->info;
 	struct opa_vnic_skb_mdata *mdata;
-	u8 def_port, sc, entropy, *hdr;
+	u8 def_port, sc, rc, entropy, *hdr;
 	u16 len, l4_hdr;
 	u32 dlid;
 
@@ -459,6 +495,7 @@ void opa_vnic_encap_skb(struct opa_vnic_adapter *adapter, struct sk_buff *skb)
 	len = opa_vnic_wire_length(skb);
 	dlid = opa_vnic_get_dlid(adapter, skb, def_port);
 	sc = opa_vnic_get_sc(info, skb);
+	rc = opa_vnic_get_rc(info, skb);
 	l4_hdr = info->vesw.vesw_id;
 
 	mdata = (struct opa_vnic_skb_mdata *)skb_push(skb, sizeof(*mdata));
@@ -471,6 +508,6 @@ void opa_vnic_encap_skb(struct opa_vnic_adapter *adapter, struct sk_buff *skb)
 	}
 
 	opa_vnic_make_header(hdr, info->vport.encap_slid, dlid, len,
-			     info->vesw.pkey, entropy, sc, 0,
+			     info->vesw.pkey, entropy, sc, rc,
 			     OPA_VNIC_L4_ETHR, l4_hdr);
 }
* Unmerged path drivers/infiniband/ulp/opa_vnic/opa_vnic_encap.h
* Unmerged path drivers/infiniband/ulp/opa_vnic/opa_vnic_internal.h
diff --git a/drivers/infiniband/ulp/opa_vnic/opa_vnic_vema_iface.c b/drivers/infiniband/ulp/opa_vnic/opa_vnic_vema_iface.c
index 9655cc3aa3a0..5376b3c25b25 100644
--- a/drivers/infiniband/ulp/opa_vnic/opa_vnic_vema_iface.c
+++ b/drivers/infiniband/ulp/opa_vnic/opa_vnic_vema_iface.c
@@ -176,6 +176,8 @@ void opa_vnic_get_vesw_info(struct opa_vnic_adapter *adapter,
 	for (i = 0; i < OPA_VESW_MAX_NUM_DEF_PORT; i++)
 		info->u_ucast_dlid[i] = cpu_to_be32(src->u_ucast_dlid[i]);
 
+	info->rc = cpu_to_be32(src->rc);
+
 	memcpy(info->rsvd3, src->rsvd3, ARRAY_SIZE(src->rsvd3));
 	for (i = 0; i < OPA_VNIC_MAX_NUM_PCP; i++)
 		info->eth_mtu[i] = cpu_to_be16(src->eth_mtu[i]);
@@ -211,6 +213,8 @@ void opa_vnic_set_vesw_info(struct opa_vnic_adapter *adapter,
 	for (i = 0; i < OPA_VESW_MAX_NUM_DEF_PORT; i++)
 		dst->u_ucast_dlid[i] = be32_to_cpu(info->u_ucast_dlid[i]);
 
+	dst->rc = be32_to_cpu(info->rc);
+
 	memcpy(dst->rsvd3, info->rsvd3, ARRAY_SIZE(info->rsvd3));
 	for (i = 0; i < OPA_VNIC_MAX_NUM_PCP; i++)
 		dst->eth_mtu[i] = be16_to_cpu(info->eth_mtu[i]);
