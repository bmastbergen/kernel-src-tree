nfp: bpf: add helpers for updating immediate instructions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit ce4ebfd859c33ea098bfa2e1b4623128046f59c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ce4ebfd8.failed

Immediate loads are used to load the return address of a helper.
We need to be able to update those loads for relocations.
Immediate loads can be slightly more complex and spread over
two instructions in general, but here we only care about simple
loads of small (< 65k) constants, so complex cases are not handled.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit ce4ebfd859c33ea098bfa2e1b4623128046f59c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_asm.c
#	drivers/net/ethernet/netronome/nfp/nfp_asm.h
diff --cc drivers/net/ethernet/netronome/nfp/nfp_asm.c
index 1fbe2c4bc84e,3f6952b66a49..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_asm.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_asm.c
@@@ -49,6 -50,94 +49,97 @@@ const struct cmd_tgt_act cmd_tgt_act[__
  	[CMD_TGT_READ_SWAP_LE] =	{ 0x03, 0x40 },
  };
  
++<<<<<<< HEAD
++=======
+ static bool unreg_is_imm(u16 reg)
+ {
+ 	return (reg & UR_REG_IMM) == UR_REG_IMM;
+ }
+ 
+ u16 br_get_offset(u64 instr)
+ {
+ 	u16 addr_lo, addr_hi;
+ 
+ 	addr_lo = FIELD_GET(OP_BR_ADDR_LO, instr);
+ 	addr_hi = FIELD_GET(OP_BR_ADDR_HI, instr);
+ 
+ 	return (addr_hi * ((OP_BR_ADDR_LO >> __bf_shf(OP_BR_ADDR_LO)) + 1)) |
+ 		addr_lo;
+ }
+ 
+ void br_set_offset(u64 *instr, u16 offset)
+ {
+ 	u16 addr_lo, addr_hi;
+ 
+ 	addr_lo = offset & (OP_BR_ADDR_LO >> __bf_shf(OP_BR_ADDR_LO));
+ 	addr_hi = offset != addr_lo;
+ 	*instr &= ~(OP_BR_ADDR_HI | OP_BR_ADDR_LO);
+ 	*instr |= FIELD_PREP(OP_BR_ADDR_HI, addr_hi);
+ 	*instr |= FIELD_PREP(OP_BR_ADDR_LO, addr_lo);
+ }
+ 
+ void br_add_offset(u64 *instr, u16 offset)
+ {
+ 	u16 addr;
+ 
+ 	addr = br_get_offset(*instr);
+ 	br_set_offset(instr, addr + offset);
+ }
+ 
+ static bool immed_can_modify(u64 instr)
+ {
+ 	if (FIELD_GET(OP_IMMED_INV, instr) ||
+ 	    FIELD_GET(OP_IMMED_SHIFT, instr) ||
+ 	    FIELD_GET(OP_IMMED_WIDTH, instr) != IMMED_WIDTH_ALL) {
+ 		pr_err("Can't decode/encode immed!\n");
+ 		return false;
+ 	}
+ 	return true;
+ }
+ 
+ u16 immed_get_value(u64 instr)
+ {
+ 	u16 reg;
+ 
+ 	if (!immed_can_modify(instr))
+ 		return 0;
+ 
+ 	reg = FIELD_GET(OP_IMMED_A_SRC, instr);
+ 	if (!unreg_is_imm(reg))
+ 		reg = FIELD_GET(OP_IMMED_B_SRC, instr);
+ 
+ 	return (reg & 0xff) | FIELD_GET(OP_IMMED_IMM, instr);
+ }
+ 
+ void immed_set_value(u64 *instr, u16 immed)
+ {
+ 	if (!immed_can_modify(*instr))
+ 		return;
+ 
+ 	if (unreg_is_imm(FIELD_GET(OP_IMMED_A_SRC, *instr))) {
+ 		*instr &= ~FIELD_PREP(OP_IMMED_A_SRC, 0xff);
+ 		*instr |= FIELD_PREP(OP_IMMED_A_SRC, immed & 0xff);
+ 	} else {
+ 		*instr &= ~FIELD_PREP(OP_IMMED_B_SRC, 0xff);
+ 		*instr |= FIELD_PREP(OP_IMMED_B_SRC, immed & 0xff);
+ 	}
+ 
+ 	*instr &= ~OP_IMMED_IMM;
+ 	*instr |= FIELD_PREP(OP_IMMED_IMM, immed >> 8);
+ }
+ 
+ void immed_add_value(u64 *instr, u16 offset)
+ {
+ 	u16 val;
+ 
+ 	if (!immed_can_modify(*instr))
+ 		return;
+ 
+ 	val = immed_get_value(*instr);
+ 	immed_set_value(instr, val + offset);
+ }
+ 
++>>>>>>> ce4ebfd859c3 (nfp: bpf: add helpers for updating immediate instructions)
  static u16 nfp_swreg_to_unreg(swreg reg, bool is_dst)
  {
  	bool lm_id, lm_dec = false;
diff --cc drivers/net/ethernet/netronome/nfp/nfp_asm.h
index ee917321543b,5f9291db98e0..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_asm.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_asm.h
@@@ -130,17 -138,23 +130,37 @@@ enum immed_shift 
  	IMMED_SHIFT_2B = 2,
  };
  
++<<<<<<< HEAD
 +#define OP_SHF_BASE	0x08000000000ULL
 +#define OP_SHF_A_SRC	0x000000000ffULL
 +#define OP_SHF_SC	0x00000000300ULL
 +#define OP_SHF_B_SRC	0x0000003fc00ULL
 +#define OP_SHF_I8	0x00000040000ULL
 +#define OP_SHF_SW	0x00000080000ULL
 +#define OP_SHF_DST	0x0000ff00000ULL
 +#define OP_SHF_SHIFT	0x001f0000000ULL
 +#define OP_SHF_OP	0x00e00000000ULL
 +#define OP_SHF_DST_AB	0x01000000000ULL
 +#define OP_SHF_WR_AB	0x20000000000ULL
++=======
+ u16 immed_get_value(u64 instr);
+ void immed_set_value(u64 *instr, u16 immed);
+ void immed_add_value(u64 *instr, u16 offset);
+ 
+ #define OP_SHF_BASE		0x08000000000ULL
+ #define OP_SHF_A_SRC		0x000000000ffULL
+ #define OP_SHF_SC		0x00000000300ULL
+ #define OP_SHF_B_SRC		0x0000003fc00ULL
+ #define OP_SHF_I8		0x00000040000ULL
+ #define OP_SHF_SW		0x00000080000ULL
+ #define OP_SHF_DST		0x0000ff00000ULL
+ #define OP_SHF_SHIFT		0x001f0000000ULL
+ #define OP_SHF_OP		0x00e00000000ULL
+ #define OP_SHF_DST_AB		0x01000000000ULL
+ #define OP_SHF_WR_AB		0x20000000000ULL
+ #define OP_SHF_SRC_LMEXTN	0x40000000000ULL
+ #define OP_SHF_DST_LMEXTN	0x80000000000ULL
++>>>>>>> ce4ebfd859c3 (nfp: bpf: add helpers for updating immediate instructions)
  
  enum shf_op {
  	SHF_OP_NONE = 0,
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_asm.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_asm.h
