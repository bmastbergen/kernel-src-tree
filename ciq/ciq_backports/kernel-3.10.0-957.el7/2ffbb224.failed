tools/power turbostat: Fix logical node enumeration to allow for non-sequential physical nodes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [tools] power turbostat: Fix logical node enumeration to allow for non-sequential physical nodes (Prarit Bhargava) [1612902]
Rebuild_FUZZ: 96.70%
commit-author Prarit Bhargava <prarit@redhat.com>
commit 2ffbb22406079fec2c3a6ad6ee1dc99fede740ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/2ffbb224.failed

turbostat fails on some multi-package topologies because the logical node
enumeration assumes that the nodes are sequentially numbered,
which causes the logical numa nodes to not be enumerated, or enumerated incorrectly.

Use a more robust enumeration algorithm which allows for non-seqential physical nodes.

	Signed-off-by: Prarit Bhargava <prarit@redhat.com>
	Signed-off-by: Len Brown <len.brown@intel.com>
(cherry picked from commit 2ffbb22406079fec2c3a6ad6ee1dc99fede740ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/power/x86/turbostat/turbostat.c
diff --cc tools/power/x86/turbostat/turbostat.c
index b87a8d9134f5,2b0135599f37..000000000000
--- a/tools/power/x86/turbostat/turbostat.c
+++ b/tools/power/x86/turbostat/turbostat.c
@@@ -2305,49 -2471,43 +2305,58 @@@ int get_core_id(int cpu
  
  void set_node_data(void)
  {
- 	char path[80];
- 	FILE *filep;
- 	int pkg, node, cpu;
- 
- 	struct pkg_node_info {
- 		int count;
- 		int min;
- 	} *pni;
- 
- 	pni = calloc(topo.num_packages, sizeof(struct pkg_node_info));
- 	if (!pni)
- 		err(1, "calloc pkg_node_count");
- 
- 	for (pkg = 0; pkg < topo.num_packages; pkg++)
- 		pni[pkg].min = topo.num_cpus;
- 
- 	for (node = 0; node <= topo.max_node_num; node++) {
- 		/* find the "first" cpu in the node */
- 		sprintf(path, "/sys/bus/node/devices/node%d/cpulist", node);
- 		filep = fopen(path, "r");
- 		if (!filep)
- 			continue;
- 		fscanf(filep, "%d", &cpu);
- 		fclose(filep);
- 
- 		pkg = cpus[cpu].physical_package_id;
- 		pni[pkg].count++;
- 
- 		if (node < pni[pkg].min)
- 			pni[pkg].min = node;
+ 	int pkg, node, lnode, cpu, cpux;
+ 	int cpu_count;
+ 
+ 	/* initialize logical_node_id */
+ 	for (cpu = 0; cpu <= topo.max_cpu_num; ++cpu)
+ 		cpus[cpu].logical_node_id = -1;
+ 
+ 	cpu_count = 0;
+ 	for (pkg = 0; pkg < topo.num_packages; pkg++) {
+ 		lnode = 0;
+ 		for (cpu = 0; cpu <= topo.max_cpu_num; ++cpu) {
+ 			if (cpus[cpu].physical_package_id != pkg)
+ 				continue;
+ 			/* find a cpu with an unset logical_node_id */
+ 			if (cpus[cpu].logical_node_id != -1)
+ 				continue;
+ 			cpus[cpu].logical_node_id = lnode;
+ 			node = cpus[cpu].physical_node_id;
+ 			cpu_count++;
+ 			/*
+ 			 * find all matching cpus on this pkg and set
+ 			 * the logical_node_id
+ 			 */
+ 			for (cpux = cpu; cpux <= topo.max_cpu_num; cpux++) {
+ 				if ((cpus[cpux].physical_package_id == pkg) &&
+ 				   (cpus[cpux].physical_node_id == node)) {
+ 					cpus[cpux].logical_node_id = lnode;
+ 					cpu_count++;
+ 				}
+ 			}
+ 			lnode++;
+ 			if (lnode > topo.nodes_per_pkg)
+ 				topo.nodes_per_pkg = lnode;
+ 		}
+ 		if (cpu_count >= topo.max_cpu_num)
+ 			break;
  	}
++<<<<<<< HEAD
 +
 +	for (pkg = 0; pkg < topo.num_packages; pkg++)
 +		if (pni[pkg].count > topo.nodes_per_pkg)
 +			topo.nodes_per_pkg = pni[0].count;
 +
 +	for (cpu = 0; cpu < topo.num_cpus; cpu++) {
 +		pkg = cpus[cpu].physical_package_id;
 +		node = cpus[cpu].physical_node_id;
 +		cpus[cpu].logical_node_id = node - pni[pkg].min;
 +	}
 +	free(pni);
 +
++=======
++>>>>>>> 2ffbb2240607 (tools/power turbostat: Fix logical node enumeration to allow for non-sequential physical nodes)
  }
  
  int get_physical_node_id(struct cpu_topology *thiscpu)
@@@ -4597,16 -4826,8 +4606,8 @@@ void topology_probe(
  		siblings = get_thread_siblings(&cpus[i]);
  		if (siblings > max_siblings)
  			max_siblings = siblings;
 -		if (cpus[i].thread_id == 0)
 +		if (cpus[i].thread_id != -1)
  			topo.num_cores++;
- 
- 		if (debug > 1)
- 			fprintf(outf,
- 				"cpu %d pkg %d node %d core %d thread %d\n",
- 				i, cpus[i].physical_package_id,
- 				cpus[i].physical_node_id,
- 				cpus[i].physical_core_id,
- 				cpus[i].thread_id);
  	}
  
  	topo.cores_per_node = max_core_id + 1;
* Unmerged path tools/power/x86/turbostat/turbostat.c
