mmc: core: refactor asynchronous request finalization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] core: refactor asynchronous request finalization (Gopal Tiwari) [1549495]
Rebuild_FUZZ: 95.05%
commit-author Linus Walleij <linus.walleij@linaro.org>
commit 0e72f95bf329dea7985f0f4ac81cc888e8b79797
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0e72f95b.failed

mmc_wait_for_data_req_done() is called in exactly one place,
and having it spread out is making things hard to oversee.
Factor this function into mmc_finalize_areq().

	Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 0e72f95bf329dea7985f0f4ac81cc888e8b79797)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/core.c
diff --cc drivers/mmc/core/core.c
index 6fb0618a3362,d6831dc05d98..000000000000
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@@ -650,10 -602,71 +600,75 @@@ static void mmc_post_req(struct mmc_hos
  }
  
  /**
++<<<<<<< HEAD
 + *	mmc_start_req - start a non-blocking request
++=======
+  * mmc_finalize_areq() - finalize an asynchronous request
+  * @host: MMC host to finalize any ongoing request on
+  *
+  * Returns the status of the ongoing asynchronous request, but
+  * MMC_BLK_SUCCESS if no request was going on.
+  */
+ static enum mmc_blk_status mmc_finalize_areq(struct mmc_host *host)
+ {
+ 	struct mmc_context_info *context_info = &host->context_info;
+ 	enum mmc_blk_status status;
+ 
+ 	if (!host->areq)
+ 		return MMC_BLK_SUCCESS;
+ 
+ 	while (1) {
+ 		wait_event_interruptible(context_info->wait,
+ 				(context_info->is_done_rcv ||
+ 				 context_info->is_new_req));
+ 
+ 		if (context_info->is_done_rcv) {
+ 			struct mmc_command *cmd;
+ 
+ 			context_info->is_done_rcv = false;
+ 			cmd = host->areq->mrq->cmd;
+ 
+ 			if (!cmd->error || !cmd->retries ||
+ 			    mmc_card_removed(host->card)) {
+ 				status = host->areq->err_check(host->card,
+ 							       host->areq);
+ 				break; /* return status */
+ 			} else {
+ 				mmc_retune_recheck(host);
+ 				pr_info("%s: req failed (CMD%u): %d, retrying...\n",
+ 					mmc_hostname(host),
+ 					cmd->opcode, cmd->error);
+ 				cmd->retries--;
+ 				cmd->error = 0;
+ 				__mmc_start_request(host, host->areq->mrq);
+ 				continue; /* wait for done/new event again */
+ 			}
+ 		}
+ 
+ 		return MMC_BLK_NEW_REQUEST;
+ 	}
+ 
+ 	mmc_retune_release(host);
+ 
+ 	/*
+ 	 * Check BKOPS urgency for each R1 response
+ 	 */
+ 	if (host->card && mmc_card_mmc(host->card) &&
+ 	    ((mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1) ||
+ 	     (mmc_resp_type(host->areq->mrq->cmd) == MMC_RSP_R1B)) &&
+ 	    (host->areq->mrq->cmd->resp[0] & R1_EXCEPTION_EVENT)) {
+ 		mmc_start_bkops(host->card, true);
+ 	}
+ 
+ 	return status;
+ }
+ 
+ /**
+  *	mmc_start_areq - start an asynchronous request
++>>>>>>> 0e72f95bf329 (mmc: core: refactor asynchronous request finalization)
   *	@host: MMC host to start command
 - *	@areq: asynchronous request to start
 - *	@ret_stat: out parameter for status
 + *	@areq: async request to start
 + *	@error: out parameter returns 0 for success, otherwise non zero
   *
   *	Start a new MMC custom command request for a host.
   *	If there is on ongoing async request wait for completion
* Unmerged path drivers/mmc/core/core.c
