scsi: libfc: Add lockdep annotations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [scsi] libfc: Add lockdep annotations (Chris Leech) [1608481]
Rebuild_FUZZ: 90.91%
commit-author Hannes Reinecke <hare@suse.de>
commit ee35624e1e4e4e9a26a30d56c25a07ba9cdd8ecb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ee35624e.failed

Convert the free text locking notes into proper lockdep annotations.

	Signed-off-by: Hannes Reinecke <hare@suse.com>
	Acked-by: Johannes Thumshirn <jth@kernel.org>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit ee35624e1e4e4e9a26a30d56c25a07ba9cdd8ecb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/libfc/fc_disc.c
#	drivers/scsi/libfc/fc_lport.c
#	drivers/scsi/libfc/fc_rport.c
diff --cc drivers/scsi/libfc/fc_disc.c
index ad3965f9d03d,6125df787200..000000000000
--- a/drivers/scsi/libfc/fc_disc.c
+++ b/drivers/scsi/libfc/fc_disc.c
@@@ -690,7 -679,9 +678,13 @@@ static int fc_disc_single(struct fc_lpo
  {
  	struct fc_rport_priv *rdata;
  
++<<<<<<< HEAD
 +	rdata = lport->tt.rport_create(lport, dp->port_id);
++=======
+ 	lockdep_assert_held(&lport->disc.disc_mutex);
+ 
+ 	rdata = fc_rport_create(lport, dp->port_id);
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
  	if (!rdata)
  		return -ENOMEM;
  	rdata->disc_id = 0;
diff --cc drivers/scsi/libfc/fc_lport.c
index 898fae9b9b3b,be83590ed955..000000000000
--- a/drivers/scsi/libfc/fc_lport.c
+++ b/drivers/scsi/libfc/fc_lport.c
@@@ -245,12 -242,14 +242,14 @@@ static void fc_lport_ptp_setup(struct f
  			       u32 remote_fid, u64 remote_wwpn,
  			       u64 remote_wwnn)
  {
+ 	lockdep_assert_held(&lport->lp_mutex);
+ 
  	if (lport->ptp_rdata) {
 -		fc_rport_logoff(lport->ptp_rdata);
 -		kref_put(&lport->ptp_rdata->kref, fc_rport_destroy);
 +		lport->tt.rport_logoff(lport->ptp_rdata);
 +		kref_put(&lport->ptp_rdata->kref, lport->tt.rport_destroy);
  	}
  	mutex_lock(&lport->disc.disc_mutex);
 -	lport->ptp_rdata = fc_rport_create(lport, remote_fid);
 +	lport->ptp_rdata = lport->tt.rport_create(lport, remote_fid);
  	kref_get(&lport->ptp_rdata->kref);
  	lport->ptp_rdata->ids.port_name = remote_wwpn;
  	lport->ptp_rdata->ids.node_name = remote_wwnn;
@@@ -518,13 -511,12 +514,22 @@@ static void fc_lport_recv_rnid_req(stru
   * fc_lport_recv_logo_req() - Handle received fabric LOGO request
   * @lport: The local port receiving the LOGO
   * @fp:	   The LOGO request frame
++<<<<<<< HEAD
 + *
 + * Locking Note: The lport lock is exected to be held before calling
 + * this function.
 + */
 +static void fc_lport_recv_logo_req(struct fc_lport *lport, struct fc_frame *fp)
 +{
 +	lport->tt.seq_els_rsp_send(fp, ELS_LS_ACC, NULL);
++=======
+  */
+ static void fc_lport_recv_logo_req(struct fc_lport *lport, struct fc_frame *fp)
+ {
+ 	lockdep_assert_held(&lport->lp_mutex);
+ 
+ 	fc_seq_els_rsp_send(fp, ELS_LS_ACC, NULL);
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
  	fc_lport_enter_reset(lport);
  	fc_frame_free(fp);
  }
@@@ -1010,11 -1001,10 +1012,10 @@@ EXPORT_SYMBOL(fc_lport_reset)
   */
  static void fc_lport_reset_locked(struct fc_lport *lport)
  {
+ 	lockdep_assert_held(&lport->lp_mutex);
+ 
  	if (lport->dns_rdata) {
 -		fc_rport_logoff(lport->dns_rdata);
 +		lport->tt.rport_logoff(lport->dns_rdata);
  		lport->dns_rdata = NULL;
  	}
  
@@@ -1966,11 -1944,8 +1958,8 @@@ static void fc_lport_bsg_resp(struct fc
   * @job:   The BSG Passthrough job
   * @lport: The local port sending the request
   * @did:   The destination port id
-  *
-  * Locking Note: The lport lock is expected to be held before calling
-  * this routine.
   */
 -static int fc_lport_els_request(struct bsg_job *job,
 +static int fc_lport_els_request(struct fc_bsg_job *job,
  				struct fc_lport *lport,
  				u32 did, u32 tov)
  {
@@@ -2027,11 -2004,8 +2018,8 @@@
   * @lport: The local port sending the request
   * @did:   The destination FC-ID
   * @tov:   The timeout period to wait for the response
-  *
-  * Locking Note: The lport lock is expected to be held before calling
-  * this routine.
   */
 -static int fc_lport_ct_request(struct bsg_job *job,
 +static int fc_lport_ct_request(struct fc_bsg_job *job,
  			       struct fc_lport *lport, u32 did, u32 tov)
  {
  	struct fc_bsg_info *info;
diff --cc drivers/scsi/libfc/fc_rport.c
index 45ec8b8fafe0,6aff9303251a..000000000000
--- a/drivers/scsi/libfc/fc_rport.c
+++ b/drivers/scsi/libfc/fc_rport.c
@@@ -120,15 -136,14 +120,19 @@@ static struct fc_rport_priv *fc_rport_l
   * @ids:   The identifiers for the new remote port
   *
   * The remote port will start in the INIT state.
-  *
-  * Locking note:  must be called with the disc_mutex held.
   */
 -struct fc_rport_priv *fc_rport_create(struct fc_lport *lport, u32 port_id)
 +static struct fc_rport_priv *fc_rport_create(struct fc_lport *lport,
 +					     u32 port_id)
  {
  	struct fc_rport_priv *rdata;
  
++<<<<<<< HEAD
 +	rdata = lport->tt.rport_lookup(lport, port_id);
++=======
+ 	lockdep_assert_held(&lport->disc.disc_mutex);
+ 
+ 	rdata = fc_rport_lookup(lport, port_id);
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
  	if (rdata)
  		return rdata;
  
@@@ -484,8 -546,7 +488,12 @@@ out
   * fc_rport_enter_ready() - Transition to the RPORT_ST_READY state
   * @rdata: The remote port that is ready
   *
++<<<<<<< HEAD
 + * Locking Note: The rport lock is expected to be held before calling
 + * this routine.
++=======
+  * Reference counting: schedules workqueue, does not modify kref
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
   */
  static void fc_rport_enter_ready(struct fc_rport_priv *rdata)
  {
@@@ -542,16 -612,18 +552,29 @@@ static void fc_rport_timeout(struct wor
  /**
   * fc_rport_error() - Error handler, called once retries have been exhausted
   * @rdata: The remote port the error is happened on
 - * @err:   The error code
 + * @fp:	   The error code encapsulated in a frame pointer
   *
++<<<<<<< HEAD
 + * Locking Note: The rport lock is expected to be held before
 + * calling this routine
++=======
+  * Reference counting: does not modify kref
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
   */
 -static void fc_rport_error(struct fc_rport_priv *rdata, int err)
 +static void fc_rport_error(struct fc_rport_priv *rdata, struct fc_frame *fp)
  {
++<<<<<<< HEAD
 +	FC_RPORT_DBG(rdata, "Error %ld in state %s, retries %d\n",
 +		     IS_ERR(fp) ? -PTR_ERR(fp) : 0,
 +		     fc_rport_state(rdata), rdata->retries);
++=======
+ 	struct fc_lport *lport = rdata->local_port;
+ 
+ 	lockdep_assert_held(&rdata->rp_mutex);
+ 
+ 	FC_RPORT_DBG(rdata, "Error %d in state %s, retries %d\n",
+ 		     -err, fc_rport_state(rdata), rdata->retries);
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
  
  	switch (rdata->rp_state) {
  	case RPORT_ST_FLOGI:
@@@ -582,16 -660,16 +605,22 @@@
   * If the error was an exchange timeout retry immediately,
   * otherwise wait for E_D_TOV.
   *
++<<<<<<< HEAD
 + * Locking Note: The rport lock is expected to be held before
 + * calling this routine
++=======
+  * Reference counting: increments kref when scheduling retry_work
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
   */
 -static void fc_rport_error_retry(struct fc_rport_priv *rdata, int err)
 +static void fc_rport_error_retry(struct fc_rport_priv *rdata,
 +				 struct fc_frame *fp)
  {
 -	unsigned long delay = msecs_to_jiffies(rdata->e_d_tov);
 +	unsigned long delay = msecs_to_jiffies(FC_DEF_E_D_TOV);
  
+ 	lockdep_assert_held(&rdata->rp_mutex);
+ 
  	/* make sure this isn't an FC_EX_CLOSED error, never retry those */
 -	if (err == -FC_EX_CLOSED)
 +	if (PTR_ERR(fp) == -FC_EX_CLOSED)
  		goto out;
  
  	if (rdata->retries < rdata->local_port->max_rport_retry_count) {
@@@ -720,8 -819,7 +749,12 @@@ bad
   * fc_rport_enter_flogi() - Send a FLOGI request to the remote port for p-mp
   * @rdata: The remote port to send a FLOGI to
   *
++<<<<<<< HEAD
 + * Locking Note: The rport lock is expected to be held before calling
 + * this routine.
++=======
+  * Reference counting: increments kref when sending ELS
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
   */
  static void fc_rport_enter_flogi(struct fc_rport_priv *rdata)
  {
@@@ -935,14 -1067,21 +970,29 @@@ err
   * fc_rport_enter_plogi() - Send Port Login (PLOGI) request
   * @rdata: The remote port to send a PLOGI to
   *
++<<<<<<< HEAD
 + * Locking Note: The rport lock is expected to be held before calling
 + * this routine.
++=======
+  * Reference counting: increments kref when sending ELS
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
   */
  static void fc_rport_enter_plogi(struct fc_rport_priv *rdata)
  {
  	struct fc_lport *lport = rdata->local_port;
  	struct fc_frame *fp;
  
++<<<<<<< HEAD
++=======
+ 	lockdep_assert_held(&rdata->rp_mutex);
+ 
+ 	if (!fc_rport_compatible_roles(lport, rdata)) {
+ 		FC_RPORT_DBG(rdata, "PLOGI suppressed for incompatible role\n");
+ 		fc_rport_state_enter(rdata, RPORT_ST_PLOGI_WAIT);
+ 		return;
+ 	}
+ 
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
  	FC_RPORT_DBG(rdata, "Port entered PLOGI state from %s state\n",
  		     fc_rport_state(rdata));
  
@@@ -1068,8 -1227,7 +1118,12 @@@ err
   * fc_rport_enter_prli() - Send Process Login (PRLI) request
   * @rdata: The remote port to send the PRLI request to
   *
++<<<<<<< HEAD
 + * Locking Note: The rport lock is expected to be held before calling
 + * this routine.
++=======
+  * Reference counting: increments kref when sending ELS
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
   */
  static void fc_rport_enter_prli(struct fc_rport_priv *rdata)
  {
@@@ -1190,8 -1366,7 +1246,12 @@@ err
   * fc_rport_enter_rtv() - Send Request Timeout Value (RTV) request
   * @rdata: The remote port to send the RTV request to
   *
++<<<<<<< HEAD
 + * Locking Note: The rport lock is expected to be held before calling
 + * this routine.
++=======
+  * Reference counting: increments kref when sending ELS
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
   */
  static void fc_rport_enter_rtv(struct fc_rport_priv *rdata)
  {
@@@ -1209,12 -1386,49 +1271,55 @@@
  		return;
  	}
  
 -	kref_get(&rdata->kref);
  	if (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, ELS_RTV,
  				  fc_rport_rtv_resp, rdata,
++<<<<<<< HEAD
 +				  2 * lport->r_a_tov))
 +		fc_rport_error_retry(rdata, NULL);
 +	else
 +		kref_get(&rdata->kref);
++=======
+ 				  2 * lport->r_a_tov)) {
+ 		fc_rport_error_retry(rdata, -FC_EX_XMIT_ERR);
+ 		kref_put(&rdata->kref, fc_rport_destroy);
+ 	}
+ }
+ 
+ /**
+  * fc_rport_recv_rtv_req() - Handler for Read Timeout Value (RTV) requests
+  * @rdata: The remote port that sent the RTV request
+  * @in_fp: The RTV request frame
+  */
+ static void fc_rport_recv_rtv_req(struct fc_rport_priv *rdata,
+ 				  struct fc_frame *in_fp)
+ {
+ 	struct fc_lport *lport = rdata->local_port;
+ 	struct fc_frame *fp;
+ 	struct fc_els_rtv_acc *rtv;
+ 	struct fc_seq_els_data rjt_data;
+ 
+ 	lockdep_assert_held(&rdata->rp_mutex);
+ 	lockdep_assert_held(&lport->lp_mutex);
+ 
+ 	FC_RPORT_DBG(rdata, "Received RTV request\n");
+ 
+ 	fp = fc_frame_alloc(lport, sizeof(*rtv));
+ 	if (!fp) {
+ 		rjt_data.reason = ELS_RJT_UNAB;
+ 		rjt_data.explan = ELS_EXPL_INSUF_RES;
+ 		fc_seq_els_rsp_send(in_fp, ELS_LS_RJT, &rjt_data);
+ 		goto drop;
+ 	}
+ 	rtv = fc_frame_payload_get(fp, sizeof(*rtv));
+ 	rtv->rtv_cmd = ELS_LS_ACC;
+ 	rtv->rtv_r_a_tov = htonl(lport->r_a_tov);
+ 	rtv->rtv_e_d_tov = htonl(lport->e_d_tov);
+ 	rtv->rtv_toq = 0;
+ 	fc_fill_reply_hdr(fp, in_fp, FC_RCTL_ELS_REP, 0);
+ 	lport->tt.frame_send(lport, fp);
+ drop:
+ 	fc_frame_free(in_fp);
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
  }
  
  /**
@@@ -1239,8 -1454,7 +1344,12 @@@ static void fc_rport_logo_resp(struct f
   * fc_rport_enter_logo() - Send a logout (LOGO) request
   * @rdata: The remote port to send the LOGO request to
   *
++<<<<<<< HEAD
 + * Locking Note: The rport lock is expected to be held before calling
 + * this routine.
++=======
+  * Reference counting: increments kref when sending ELS
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
   */
  static void fc_rport_enter_logo(struct fc_rport_priv *rdata)
  {
@@@ -1319,8 -1541,7 +1430,12 @@@ err
   * fc_rport_enter_adisc() - Send Address Discover (ADISC) request
   * @rdata: The remote port to send the ADISC request to
   *
++<<<<<<< HEAD
 + * Locking Note: The rport lock is expected to be held before calling
 + * this routine.
++=======
+  * Reference counting: increments kref when sending ELS
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
   */
  static void fc_rport_enter_adisc(struct fc_rport_priv *rdata)
  {
@@@ -1455,16 -1679,22 +1572,30 @@@ out
   * Handle incoming ELS requests that require port login.
   * The ELS opcode has already been validated by the caller.
   *
++<<<<<<< HEAD
 + * Locking Note: Called with the lport lock held.
++=======
+  * Reference counting: does not modify kref
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
   */
  static void fc_rport_recv_els_req(struct fc_lport *lport, struct fc_frame *fp)
  {
  	struct fc_rport_priv *rdata;
  	struct fc_seq_els_data els_data;
  
++<<<<<<< HEAD
 +	rdata = lport->tt.rport_lookup(lport, fc_frame_sid(fp));
 +	if (!rdata)
++=======
+ 	lockdep_assert_held(&lport->lp_mutex);
+ 
+ 	rdata = fc_rport_lookup(lport, fc_frame_sid(fp));
+ 	if (!rdata) {
+ 		FC_RPORT_ID_DBG(lport, fc_frame_sid(fp),
+ 				"Received ELS 0x%02x from non-logged-in port\n",
+ 				fc_frame_payload_op(fp));
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
  		goto reject;
 -	}
  
  	mutex_lock(&rdata->rp_mutex);
  
@@@ -1522,9 -1775,9 +1653,13 @@@ reject
   * @lport: The local port that received the request
   * @fp:	   The request frame
   *
++<<<<<<< HEAD
 + * Locking Note: Called with the lport lock held.
++=======
+  * Reference counting: does not modify kref
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
   */
 -void fc_rport_recv_req(struct fc_lport *lport, struct fc_frame *fp)
 +static void fc_rport_recv_req(struct fc_lport *lport, struct fc_frame *fp)
  {
  	struct fc_seq_els_data els_data;
  
@@@ -1566,7 -1823,7 +1703,11 @@@
   * @lport: The local port that received the PLOGI request
   * @rx_fp: The PLOGI request frame
   *
++<<<<<<< HEAD
 + * Locking Note: The rport lock is held before calling this function.
++=======
+  * Reference counting: increments kref on return
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
   */
  static void fc_rport_recv_plogi_req(struct fc_lport *lport,
  				    struct fc_frame *rx_fp)
@@@ -1681,9 -1947,6 +1824,12 @@@ reject
   * fc_rport_recv_prli_req() - Handler for process login (PRLI) requests
   * @rdata: The remote port that sent the PRLI request
   * @rx_fp: The PRLI request frame
++<<<<<<< HEAD
 + *
 + * Locking Note: The rport lock is exected to be held before calling
 + * this function.
++=======
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
   */
  static void fc_rport_recv_prli_req(struct fc_rport_priv *rdata,
  				   struct fc_frame *rx_fp)
@@@ -1800,9 -2063,6 +1948,12 @@@ drop
   * fc_rport_recv_prlo_req() - Handler for process logout (PRLO) requests
   * @rdata: The remote port that sent the PRLO request
   * @rx_fp: The PRLO request frame
++<<<<<<< HEAD
 + *
 + * Locking Note: The rport lock is exected to be held before calling
 + * this function.
++=======
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
   */
  static void fc_rport_recv_prlo_req(struct fc_rport_priv *rdata,
  				   struct fc_frame *rx_fp)
@@@ -1872,15 -2134,16 +2025,25 @@@ drop
   * @lport: The local port that received the LOGO request
   * @fp:	   The LOGO request frame
   *
++<<<<<<< HEAD
 + * Locking Note: The rport lock is exected to be held before calling
 + * this function.
++=======
+  * Reference counting: drops kref on return
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
   */
  static void fc_rport_recv_logo_req(struct fc_lport *lport, struct fc_frame *fp)
  {
  	struct fc_rport_priv *rdata;
  	u32 sid;
  
++<<<<<<< HEAD
 +	lport->tt.seq_els_rsp_send(fp, ELS_LS_ACC, NULL);
++=======
+ 	lockdep_assert_held(&lport->lp_mutex);
+ 
+ 	fc_seq_els_rsp_send(fp, ELS_LS_ACC, NULL);
++>>>>>>> ee35624e1e4e (scsi: libfc: Add lockdep annotations)
  
  	sid = fc_frame_sid(fp);
  
* Unmerged path drivers/scsi/libfc/fc_disc.c
* Unmerged path drivers/scsi/libfc/fc_lport.c
* Unmerged path drivers/scsi/libfc/fc_rport.c
