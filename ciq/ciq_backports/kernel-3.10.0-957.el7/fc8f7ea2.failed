ASoC: da7219: Add common clock usage for providing DAI clks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [sound] alsa: asoc: da7219: Add common clock usage for providing DAI clks (Jaroslav Kysela) [1535427]
Rebuild_FUZZ: 95.16%
commit-author Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
commit fc8f7ea2d6c074baaad202c9187962bfa493ef13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/fc8f7ea2.failed

There is a need to use DA7219 as DAI clock master for other codecs
within a system, which means that the DAI clocks are required to
remain, regardless of whether the codec is actually running
playback/capture. To be able to expose control of the DAI clocking
the common clock framework has been employed.

The current implementation adds a simple clock gate for enabling
and disabling the DAI clocks, with no rate control supported
(this is still handled through standard hw_params() functions as
before). If DT is enabled then the clock is added to the OF
providers list, otherwise a clkdev lookup is used.

	Signed-off-by: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit fc8f7ea2d6c074baaad202c9187962bfa493ef13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/codecs/da7219.c
diff --cc sound/soc/codecs/da7219.c
index 82f52140d836,441215997273..000000000000
--- a/sound/soc/codecs/da7219.c
+++ b/sound/soc/codecs/da7219.c
@@@ -769,22 -771,33 +771,39 @@@ static const struct snd_kcontrol_new da
  static int da7219_dai_event(struct snd_soc_dapm_widget *w,
  			    struct snd_kcontrol *kcontrol, int event)
  {
 -	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
 -	struct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);
 +	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);
 +	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
  	u8 pll_ctrl, pll_status;
- 	int i = 0;
+ 	int i = 0, ret;
  	bool srm_lock = false;
  
  	switch (event) {
  	case SND_SOC_DAPM_PRE_PMU:
- 		if (da7219->master)
+ 		if (da7219->master) {
  			/* Enable DAI clks for master mode */
++<<<<<<< HEAD
 +			snd_soc_update_bits(codec, DA7219_DAI_CLK_MODE,
 +					    DA7219_DAI_CLK_EN_MASK,
 +					    DA7219_DAI_CLK_EN_MASK);
++=======
+ 			if (da7219->dai_clks) {
+ 				ret = clk_prepare_enable(da7219->dai_clks);
+ 				if (ret) {
+ 					dev_err(component->dev,
+ 						"Failed to enable dai_clks\n");
+ 					return ret;
+ 				}
+ 			} else {
+ 				snd_soc_component_update_bits(component,
+ 							      DA7219_DAI_CLK_MODE,
+ 							      DA7219_DAI_CLK_EN_MASK,
+ 							      DA7219_DAI_CLK_EN_MASK);
+ 			}
+ 		}
++>>>>>>> fc8f7ea2d6c0 (ASoC: da7219: Add common clock usage for providing DAI clks)
  
  		/* PC synchronised to DAI */
 -		snd_soc_component_update_bits(component, DA7219_PC_COUNT,
 +		snd_soc_update_bits(codec, DA7219_PC_COUNT,
  				    DA7219_PC_FREERUN_MASK, 0);
  
  		/* Slave mode, if SRM not enabled no need for status checks */
@@@ -814,9 -827,16 +833,22 @@@
  				    DA7219_PC_FREERUN_MASK);
  
  		/* Disable DAI clks if in master mode */
++<<<<<<< HEAD
 +		if (da7219->master)
 +			snd_soc_update_bits(codec, DA7219_DAI_CLK_MODE,
 +					    DA7219_DAI_CLK_EN_MASK, 0);
++=======
+ 		if (da7219->master) {
+ 			if (da7219->dai_clks)
+ 				clk_disable_unprepare(da7219->dai_clks);
+ 			else
+ 				snd_soc_component_update_bits(component,
+ 							      DA7219_DAI_CLK_MODE,
+ 							      DA7219_DAI_CLK_EN_MASK,
+ 							      0);
+ 		}
+ 
++>>>>>>> fc8f7ea2d6c0 (ASoC: da7219: Add common clock usage for providing DAI clks)
  		return 0;
  	default:
  		return -EINVAL;
@@@ -1712,9 -1738,91 +1750,95 @@@ static int da7219_handle_supplies(struc
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void da7219_handle_pdata(struct snd_soc_codec *codec)
++=======
+ #ifdef CONFIG_COMMON_CLK
+ static int da7219_dai_clks_prepare(struct clk_hw *hw)
+ {
+ 	struct da7219_priv *da7219 =
+ 		container_of(hw, struct da7219_priv, dai_clks_hw);
+ 	struct snd_soc_component *component = da7219->aad->component;
+ 
+ 	snd_soc_component_update_bits(component, DA7219_DAI_CLK_MODE,
+ 				      DA7219_DAI_CLK_EN_MASK,
+ 				      DA7219_DAI_CLK_EN_MASK);
+ 
+ 	return 0;
+ }
+ 
+ static void da7219_dai_clks_unprepare(struct clk_hw *hw)
+ {
+ 	struct da7219_priv *da7219 =
+ 		container_of(hw, struct da7219_priv, dai_clks_hw);
+ 	struct snd_soc_component *component = da7219->aad->component;
+ 
+ 	snd_soc_component_update_bits(component, DA7219_DAI_CLK_MODE,
+ 				      DA7219_DAI_CLK_EN_MASK, 0);
+ }
+ 
+ static int da7219_dai_clks_is_prepared(struct clk_hw *hw)
+ {
+ 	struct da7219_priv *da7219 =
+ 		container_of(hw, struct da7219_priv, dai_clks_hw);
+ 	struct snd_soc_component *component = da7219->aad->component;
+ 	u8 clk_reg;
+ 
+ 	clk_reg = snd_soc_component_read32(component, DA7219_DAI_CLK_MODE);
+ 
+ 	return !!(clk_reg & DA7219_DAI_CLK_EN_MASK);
+ }
+ 
+ const struct clk_ops da7219_dai_clks_ops = {
+ 	.prepare = da7219_dai_clks_prepare,
+ 	.unprepare = da7219_dai_clks_unprepare,
+ 	.is_prepared = da7219_dai_clks_is_prepared,
+ };
+ 
+ static void da7219_register_dai_clks(struct snd_soc_component *component)
+ {
+ 	struct device *dev = component->dev;
+ 	struct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);
+ 	struct da7219_pdata *pdata = da7219->pdata;
+ 	struct clk_init_data init = {};
+ 	struct clk *dai_clks;
+ 	struct clk_lookup *dai_clks_lookup;
+ 
+ 	init.parent_names = NULL;
+ 	init.num_parents = 0;
+ 	init.name = pdata->dai_clks_name;
+ 	init.ops = &da7219_dai_clks_ops;
+ 	da7219->dai_clks_hw.init = &init;
+ 
+ 	dai_clks = devm_clk_register(dev, &da7219->dai_clks_hw);
+ 	if (IS_ERR(dai_clks)) {
+ 		dev_warn(dev, "Failed to register DAI clocks: %ld\n",
+ 			 PTR_ERR(dai_clks));
+ 		return;
+ 	}
+ 	da7219->dai_clks = dai_clks;
+ 
+ 	/* If we're using DT, then register as provider accordingly */
+ 	if (dev->of_node) {
+ 		devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,
+ 					    &da7219->dai_clks_hw);
+ 	} else {
+ 		dai_clks_lookup = clkdev_create(dai_clks, pdata->dai_clks_name,
+ 						"%s", dev_name(dev));
+ 		if (!dai_clks_lookup)
+ 			dev_warn(dev, "Failed to create DAI clkdev");
+ 		else
+ 			da7219->dai_clks_lookup = dai_clks_lookup;
+ 	}
+ }
+ #else
+ static inline void da7219_register_dai_clks(struct snd_soc_component *component) {}
+ #endif /* CONFIG_COMMON_CLK */
+ 
+ static void da7219_handle_pdata(struct snd_soc_component *component)
++>>>>>>> fc8f7ea2d6c0 (ASoC: da7219: Add common clock usage for providing DAI clks)
  {
 -	struct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);
 +	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
  	struct da7219_pdata *pdata = da7219->pdata;
  
  	if (pdata) {
@@@ -1850,14 -1960,17 +1976,17 @@@ err_disable_reg
  	return ret;
  }
  
 -static void da7219_remove(struct snd_soc_component *component)
 +static int da7219_remove(struct snd_soc_codec *codec)
  {
 -	struct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);
 +	struct da7219_priv *da7219 = snd_soc_codec_get_drvdata(codec);
  
 -	da7219_aad_exit(component);
 +	da7219_aad_exit(codec);
  
+ 	if (da7219->dai_clks_lookup)
+ 		clkdev_drop(da7219->dai_clks_lookup);
+ 
  	/* Supplies */
 -	regulator_bulk_disable(DA7219_NUM_SUPPLIES, da7219->supplies);
 +	return regulator_bulk_disable(DA7219_NUM_SUPPLIES, da7219->supplies);
  }
  
  #ifdef CONFIG_PM
diff --git a/Documentation/devicetree/bindings/sound/da7219.txt b/Documentation/devicetree/bindings/sound/da7219.txt
index cf61681826b6..0606724ae13a 100644
--- a/Documentation/devicetree/bindings/sound/da7219.txt
+++ b/Documentation/devicetree/bindings/sound/da7219.txt
@@ -25,6 +25,9 @@ Optional properties:
   interrupt is to be used to wake system, otherwise "irq" should be used.
 - wakeup-source: Flag to indicate this device can wake system (suspend/resume).
 
+- #clock-cells :  Should be set to '<0>', only one clock source provided;
+- clock-output-names : Name given for DAI clocks output;
+
 - clocks : phandle and clock specifier for codec MCLK.
 - clock-names : Clock name string for 'clocks' attribute, should be "mclk".
 
@@ -83,6 +86,9 @@ Example:
 		VDDMIC-supply = <&reg_audio>;
 		VDDIO-supply = <&reg_audio>;
 
+		#clock-cells = <0>;
+		clock-output-names = "dai-clks";
+
 		clocks = <&clks 201>;
 		clock-names = "mclk";
 
diff --git a/include/sound/da7219.h b/include/sound/da7219.h
index 409ef1397fd3..1bfcb16f2d10 100644
--- a/include/sound/da7219.h
+++ b/include/sound/da7219.h
@@ -36,6 +36,8 @@ struct da7219_aad_pdata;
 struct da7219_pdata {
 	bool wakeup_source;
 
+	const char *dai_clks_name;
+
 	/* Mic */
 	enum da7219_micbias_voltage micbias_lvl;
 	enum da7219_mic_amp_in_sel mic_amp_in_sel;
* Unmerged path sound/soc/codecs/da7219.c
diff --git a/sound/soc/codecs/da7219.h b/sound/soc/codecs/da7219.h
index 8d6c3c8c8026..b25721a450b2 100644
--- a/sound/soc/codecs/da7219.h
+++ b/sound/soc/codecs/da7219.h
@@ -14,6 +14,9 @@
 #ifndef __DA7219_H
 #define __DA7219_H
 
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
 #include <linux/regmap.h>
 #include <linux/regulator/consumer.h>
 #include <sound/da7219.h>
@@ -813,6 +816,12 @@ struct da7219_priv {
 	struct mutex ctrl_lock;
 	struct mutex pll_lock;
 
+#ifdef CONFIG_COMMON_CLK
+	struct clk_hw dai_clks_hw;
+#endif
+	struct clk_lookup *dai_clks_lookup;
+	struct clk *dai_clks;
+
 	struct clk *mclk;
 	unsigned int mclk_rate;
 	int clk_src;
