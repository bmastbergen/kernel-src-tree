perf trace: Allow specifying names to syscall arguments formatters

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit c51bdfecd782eec710237c53137e0fefd032d287
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c51bdfec.failed

For tracepointless syscalls, like clone, otherwise get them from the
tracepoint's /format file.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/n/tip-ml5qvv1w5k96ghwhxpzzsmm3@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit c51bdfecd782eec710237c53137e0fefd032d287)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-trace.c
diff --cc tools/perf/builtin-trace.c
index 5114abbd2e32,6664293584df..000000000000
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@@ -599,6 -601,13 +599,16 @@@ static size_t syscall_arg__scnprintf_ge
  #include "trace/beauty/socket_type.c"
  #include "trace/beauty/waitid_options.c"
  
++<<<<<<< HEAD
++=======
+ struct syscall_arg_fmt {
+ 	size_t	   (*scnprintf)(char *bf, size_t size, struct syscall_arg *arg);
+ 	void	   *parm;
+ 	const char *name;
+ 	bool	   show_zero;
+ };
+ 
++>>>>>>> c51bdfecd782 (perf trace: Allow specifying names to syscall arguments formatters)
  static struct syscall_fmt {
  	const char *name;
  	const char *alias;
@@@ -1373,9 -1350,25 +1383,23 @@@ static unsigned long __syscall_arg__val
  	return val;
  }
  
++<<<<<<< HEAD
 +unsigned long syscall_arg__val(struct syscall_arg *arg, u8 idx)
++=======
+ static size_t syscall__scnprintf_name(struct syscall *sc, char *bf, size_t size,
+ 				      struct syscall_arg *arg)
+ {
+ 	if (sc->arg_fmt && sc->arg_fmt[arg->idx].name)
+ 		return scnprintf(bf, size, "%s: ", sc->arg_fmt[arg->idx].name);
+ 
+ 	return scnprintf(bf, size, "arg%d: ", arg->idx);
+ }
+ 
+ static size_t syscall__scnprintf_val(struct syscall *sc, char *bf, size_t size,
+ 				     struct syscall_arg *arg, unsigned long val)
++>>>>>>> c51bdfecd782 (perf trace: Allow specifying names to syscall arguments formatters)
  {
 -	if (sc->arg_fmt && sc->arg_fmt[arg->idx].scnprintf) {
 -		arg->val = val;
 -		if (sc->arg_fmt[arg->idx].parm)
 -			arg->parm = sc->arg_fmt[arg->idx].parm;
 -		return sc->arg_fmt[arg->idx].scnprintf(bf, size, arg);
 -	}
 -	return scnprintf(bf, size, "%ld", val);
 +	return __syscall_arg__val(arg->args, idx);
  }
  
  static size_t syscall__scnprintf_args(struct syscall *sc, char *bf, size_t size,
@@@ -1442,14 -1427,17 +1466,28 @@@
  		 * may end up not having any args, like with gettid(), so only
  		 * print the raw args when we didn't manage to read it.
  		 */
++<<<<<<< HEAD
 +		int i = 0;
 +
 +		while (i < 6) {
 +			val = __syscall_arg__val(args, i);
 +			printed += scnprintf(bf + printed, size - printed,
 +					     "%sarg%d: %ld",
 +					     printed ? ", " : "", i, val);
 +			++i;
++=======
+ 		while (arg.idx < sc->nr_args) {
+ 			if (arg.mask & bit)
+ 				goto next_arg;
+ 			val = syscall_arg__val(&arg, arg.idx);
+ 			if (printed)
+ 				printed += scnprintf(bf + printed, size - printed, ", ");
+ 			printed += syscall__scnprintf_name(sc, bf + printed, size - printed, &arg);
+ 			printed += syscall__scnprintf_val(sc, bf + printed, size - printed, &arg, val);
+ next_arg:
+ 			++arg.idx;
+ 			bit <<= 1;
++>>>>>>> c51bdfecd782 (perf trace: Allow specifying names to syscall arguments formatters)
  		}
  	}
  
* Unmerged path tools/perf/builtin-trace.c
