mlxsw: span: Remove span_entry by span_id

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Petr Machata <petrm@mellanox.com>
commit 98977089d8eef337608272699f4197c631d447b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/98977089.failed

Instead of removing span_entry by the port number, allow removing by
SPAN id. That simplifies some code right here, and for mirroring to soft
netdevices, avoids problems with netdevice pointer invalidation and
reuse.

Rename mlxsw_sp_span_entry_find() to mlxsw_sp_span_entry_find_by_port()
and keep it--follow-up patches will make use of it.

	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 98977089d8eef337608272699f4197c631d447b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/core_acl_flex_actions.h
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_flex_actions.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/core_acl_flex_actions.h
index 0cacb3bf2df2,4e991ca6dce5..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/core_acl_flex_actions.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/core_acl_flex_actions.h
@@@ -48,6 -48,10 +48,13 @@@ struct mlxsw_afa_ops 
  	void (*kvdl_fwd_entry_del)(void *priv, u32 kvdl_index);
  	int (*counter_index_get)(void *priv, unsigned int *p_counter_index);
  	void (*counter_index_put)(void *priv, unsigned int counter_index);
++<<<<<<< HEAD
++=======
+ 	int (*mirror_add)(void *priv, u8 locol_in_port, u8 local_out_port,
+ 			  bool ingress, int *p_span_id);
+ 	void (*mirror_del)(void *priv, u8 local_in_port, int span_id,
+ 			   bool ingress);
++>>>>>>> 98977089d8ee (mlxsw: span: Remove span_entry by span_id)
  };
  
  struct mlxsw_afa *mlxsw_afa_create(unsigned int max_acts_per_set,
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_flex_actions.c
index de31b142e56f,b450d3e4a905..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_flex_actions.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_flex_actions.c
@@@ -125,6 -125,35 +125,38 @@@ mlxsw_sp_act_counter_index_put(void *pr
  	mlxsw_sp_flow_counter_free(mlxsw_sp, counter_index);
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ mlxsw_sp_act_mirror_add(void *priv, u8 local_in_port, u8 local_out_port,
+ 			bool ingress, int *p_span_id)
+ {
+ 	struct mlxsw_sp_port *in_port, *out_port;
+ 	struct mlxsw_sp *mlxsw_sp = priv;
+ 	enum mlxsw_sp_span_type type;
+ 
+ 	type = ingress ? MLXSW_SP_SPAN_INGRESS : MLXSW_SP_SPAN_EGRESS;
+ 	out_port = mlxsw_sp->ports[local_out_port];
+ 	in_port = mlxsw_sp->ports[local_in_port];
+ 
+ 	return mlxsw_sp_span_mirror_add(in_port, out_port, type,
+ 					false, p_span_id);
+ }
+ 
+ static void
+ mlxsw_sp_act_mirror_del(void *priv, u8 local_in_port, int span_id, bool ingress)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = priv;
+ 	struct mlxsw_sp_port *in_port;
+ 	enum mlxsw_sp_span_type type;
+ 
+ 	type = ingress ? MLXSW_SP_SPAN_INGRESS : MLXSW_SP_SPAN_EGRESS;
+ 	in_port = mlxsw_sp->ports[local_in_port];
+ 
+ 	mlxsw_sp_span_mirror_del(in_port, span_id, type, false);
+ }
+ 
++>>>>>>> 98977089d8ee (mlxsw: span: Remove span_entry by span_id)
  static const struct mlxsw_afa_ops mlxsw_sp_act_afa_ops = {
  	.kvdl_set_add		= mlxsw_sp_act_kvdl_set_add,
  	.kvdl_set_del		= mlxsw_sp_act_kvdl_set_del,
diff --git a/drivers/net/ethernet/mellanox/mlxsw/core_acl_flex_actions.c b/drivers/net/ethernet/mellanox/mlxsw/core_acl_flex_actions.c
index b698fb481b2e..d1c2d85f396d 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/core_acl_flex_actions.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/core_acl_flex_actions.c
@@ -1,6 +1,6 @@
 /*
  * drivers/net/ethernet/mellanox/mlxsw/core_acl_flex_actions.c
- * Copyright (c) 2017 Mellanox Technologies. All rights reserved.
+ * Copyright (c) 2017, 2018 Mellanox Technologies. All rights reserved.
  * Copyright (c) 2017 Jiri Pirko <jiri@mellanox.com>
  *
  * Redistribution and use in source and binary forms, with or without
@@ -838,7 +838,6 @@ struct mlxsw_afa_mirror {
 	struct mlxsw_afa_resource resource;
 	int span_id;
 	u8 local_in_port;
-	u8 local_out_port;
 	bool ingress;
 };
 
@@ -848,7 +847,7 @@ mlxsw_afa_mirror_destroy(struct mlxsw_afa_block *block,
 {
 	block->afa->ops->mirror_del(block->afa->ops_priv,
 				    mirror->local_in_port,
-				    mirror->local_out_port,
+				    mirror->span_id,
 				    mirror->ingress);
 	kfree(mirror);
 }
@@ -882,7 +881,6 @@ mlxsw_afa_mirror_create(struct mlxsw_afa_block *block,
 		goto err_mirror_add;
 
 	mirror->ingress = ingress;
-	mirror->local_out_port = local_out_port;
 	mirror->local_in_port = local_in_port;
 	mirror->resource.destructor = mlxsw_afa_mirror_destructor;
 	mlxsw_afa_resource_add(block, &mirror->resource);
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/core_acl_flex_actions.h
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
index b68d3beaa490..7017dba24261 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
@@ -1277,11 +1277,10 @@ mlxsw_sp_port_add_cls_matchall_mirror(struct mlxsw_sp_port *mlxsw_sp_port,
 	}
 	to_port = netdev_priv(to_dev);
 
-	mirror->to_local_port = to_port->local_port;
 	mirror->ingress = ingress;
 	span_type = ingress ? MLXSW_SP_SPAN_INGRESS : MLXSW_SP_SPAN_EGRESS;
 	return mlxsw_sp_span_mirror_add(mlxsw_sp_port, to_port, span_type,
-					true);
+					true, &mirror->span_id);
 }
 
 static void
@@ -1292,7 +1291,7 @@ mlxsw_sp_port_del_cls_matchall_mirror(struct mlxsw_sp_port *mlxsw_sp_port,
 
 	span_type = mirror->ingress ?
 			MLXSW_SP_SPAN_INGRESS : MLXSW_SP_SPAN_EGRESS;
-	mlxsw_sp_span_mirror_del(mlxsw_sp_port, mirror->to_local_port,
+	mlxsw_sp_span_mirror_del(mlxsw_sp_port, mirror->span_id,
 				 span_type, true);
 }
 
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
index f0d32fc85499..4f8bbcba4e2c 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
@@ -118,7 +118,7 @@ enum mlxsw_sp_port_mall_action_type {
 };
 
 struct mlxsw_sp_port_mall_mirror_tc_entry {
-	u8 to_local_port;
+	int span_id;
 	bool ingress;
 };
 
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_flex_actions.c
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c
index 1433d4890b88..9e596b064582 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c
@@ -118,7 +118,7 @@ static void mlxsw_sp_span_entry_destroy(struct mlxsw_sp *mlxsw_sp,
 }
 
 struct mlxsw_sp_span_entry *
-mlxsw_sp_span_entry_find(struct mlxsw_sp *mlxsw_sp, u8 local_port)
+mlxsw_sp_span_entry_find_by_port(struct mlxsw_sp *mlxsw_sp, u8 local_port)
 {
 	int i;
 
@@ -131,13 +131,27 @@ mlxsw_sp_span_entry_find(struct mlxsw_sp *mlxsw_sp, u8 local_port)
 	return NULL;
 }
 
+static struct mlxsw_sp_span_entry *
+mlxsw_sp_span_entry_find_by_id(struct mlxsw_sp *mlxsw_sp, int span_id)
+{
+	int i;
+
+	for (i = 0; i < mlxsw_sp->span.entries_count; i++) {
+		struct mlxsw_sp_span_entry *curr = &mlxsw_sp->span.entries[i];
+
+		if (curr->ref_count && curr->id == span_id)
+			return curr;
+	}
+	return NULL;
+}
+
 static struct mlxsw_sp_span_entry *
 mlxsw_sp_span_entry_get(struct mlxsw_sp_port *port)
 {
 	struct mlxsw_sp_span_entry *span_entry;
 
-	span_entry = mlxsw_sp_span_entry_find(port->mlxsw_sp,
-					      port->local_port);
+	span_entry = mlxsw_sp_span_entry_find_by_port(port->mlxsw_sp,
+						      port->local_port);
 	if (span_entry) {
 		/* Already exists, just take a reference */
 		span_entry->ref_count++;
@@ -316,7 +330,8 @@ mlxsw_sp_span_inspected_port_del(struct mlxsw_sp_port *port,
 
 int mlxsw_sp_span_mirror_add(struct mlxsw_sp_port *from,
 			     struct mlxsw_sp_port *to,
-			     enum mlxsw_sp_span_type type, bool bind)
+			     enum mlxsw_sp_span_type type, bool bind,
+			     int *p_span_id)
 {
 	struct mlxsw_sp *mlxsw_sp = from->mlxsw_sp;
 	struct mlxsw_sp_span_entry *span_entry;
@@ -333,6 +348,7 @@ int mlxsw_sp_span_mirror_add(struct mlxsw_sp_port *from,
 	if (err)
 		goto err_port_bind;
 
+	*p_span_id = span_entry->id;
 	return 0;
 
 err_port_bind:
@@ -340,13 +356,12 @@ err_port_bind:
 	return err;
 }
 
-void mlxsw_sp_span_mirror_del(struct mlxsw_sp_port *from, u8 destination_port,
+void mlxsw_sp_span_mirror_del(struct mlxsw_sp_port *from, int span_id,
 			      enum mlxsw_sp_span_type type, bool bind)
 {
 	struct mlxsw_sp_span_entry *span_entry;
 
-	span_entry = mlxsw_sp_span_entry_find(from->mlxsw_sp,
-					      destination_port);
+	span_entry = mlxsw_sp_span_entry_find_by_id(from->mlxsw_sp, span_id);
 	if (!span_entry) {
 		netdev_err(from->dev, "no span entry found\n");
 		return;
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.h b/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.h
index 069050e385ff..02dedf2fcd3f 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.h
@@ -62,11 +62,12 @@ void mlxsw_sp_span_fini(struct mlxsw_sp *mlxsw_sp);
 
 int mlxsw_sp_span_mirror_add(struct mlxsw_sp_port *from,
 			     struct mlxsw_sp_port *to,
-			     enum mlxsw_sp_span_type type, bool bind);
-void mlxsw_sp_span_mirror_del(struct mlxsw_sp_port *from, u8 destination_port,
+			     enum mlxsw_sp_span_type type,
+			     bool bind, int *p_span_id);
+void mlxsw_sp_span_mirror_del(struct mlxsw_sp_port *from, int span_id,
 			      enum mlxsw_sp_span_type type, bool bind);
 struct mlxsw_sp_span_entry *
-mlxsw_sp_span_entry_find(struct mlxsw_sp *mlxsw_sp, u8 local_port);
+mlxsw_sp_span_entry_find_by_port(struct mlxsw_sp *mlxsw_sp, u8 local_port);
 
 int mlxsw_sp_span_port_mtu_update(struct mlxsw_sp_port *port, u16 mtu);
 
