xfs: don't use ioends for direct write completions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 273dda76f757108bc2b29d30a9595b6dd3bdf3a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/273dda76.failed

We only need to communicate two bits of information to the direct I/O
completion handler:

 (1) do we need to convert any unwritten extents in the range
 (2) do we need to check if we need to update the inode size based
     on the range passed to the completion handler

We can use the private data passed to the get_block handler and the
completion handler as a simple bitmask to communicate this information
instead of the current complicated infrastructure reusing the ioends
from the buffer I/O path, and thus avoiding a memory allocation and
a context switch for any non-trivial direct write.  As a nice side
effect we also decouple the direct I/O path implementation from that
of the buffered I/O path.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Brian Foster <bfoster@redhat.com>


(cherry picked from commit 273dda76f757108bc2b29d30a9595b6dd3bdf3a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_aops.c
#	fs/xfs/xfs_trace.h
diff --cc fs/xfs/xfs_aops.c
index 767102523abf,f008a4f9dcea..000000000000
--- a/fs/xfs/xfs_aops.c
+++ b/fs/xfs/xfs_aops.c
@@@ -37,16 -36,9 +37,22 @@@
  #include <linux/pagevec.h>
  #include <linux/writeback.h>
  
++<<<<<<< HEAD
 +/*
 + * structure owned by writepages passed to individual writepage calls
 + */
 +struct xfs_writepage_ctx {
 +	struct xfs_bmbt_irec    imap;
 +	bool			imap_valid;
 +	unsigned int		io_type;
 +	struct xfs_ioend	*ioend;
 +	sector_t		last_block;
 +};
++=======
+ /* flags for direct write completions */
+ #define XFS_DIO_FLAG_UNWRITTEN	(1 << 0)
+ #define XFS_DIO_FLAG_APPEND	(1 << 1)
++>>>>>>> 273dda76f757 (xfs: don't use ioends for direct write completions)
  
  void
  xfs_count_page_state(
@@@ -1157,45 -1259,18 +1143,44 @@@ xfs_map_direct
  	struct xfs_bmbt_irec	*imap,
  	xfs_off_t		offset)
  {
- 	struct xfs_ioend	*ioend;
+ 	uintptr_t		*flags = (uintptr_t *)&bh_result->b_private;
  	xfs_off_t		size = bh_result->b_size;
- 	int			type;
  
- 	if (ISUNWRITTEN(imap))
- 		type = XFS_IO_UNWRITTEN;
- 	else
- 		type = XFS_IO_OVERWRITE;
+ 	trace_xfs_get_blocks_map_direct(XFS_I(inode), offset, size,
+ 		ISUNWRITTEN(imap) ? XFS_IO_UNWRITTEN : XFS_IO_OVERWRITE, imap);
  
++<<<<<<< HEAD
 +	trace_xfs_gbmap_direct(XFS_I(inode), offset, size, type, imap);
 +
 +	if (bh_result->b_private) {
 +		ioend = bh_result->b_private;
 +		ASSERT(ioend->io_size > 0);
 +		ASSERT(offset >= ioend->io_offset);
 +		if (offset + size > ioend->io_offset + ioend->io_size)
 +			ioend->io_size = offset - ioend->io_offset + size;
 +
 +		if (type == XFS_IO_UNWRITTEN && type != ioend->io_type)
 +			ioend->io_type = XFS_IO_UNWRITTEN;
 +
 +		trace_xfs_gbmap_direct_update(XFS_I(inode), ioend->io_offset,
 +					      ioend->io_size, ioend->io_type,
 +					      imap);
 +	} else if (type == XFS_IO_UNWRITTEN ||
 +		   offset + size > i_size_read(inode) ||
 +		   offset + size < 0) {
 +		ioend = xfs_alloc_ioend(inode, type, offset, bh_result);
 +		ioend->io_offset = offset;
 +		ioend->io_size = size;
 +
 +		bh_result->b_private = ioend;
++=======
+ 	if (ISUNWRITTEN(imap)) {
+ 		*flags |= XFS_DIO_FLAG_UNWRITTEN;
+ 		set_buffer_defer_completion(bh_result);
+ 	} else if (offset + size > i_size_read(inode) || offset + size < 0) {
+ 		*flags |= XFS_DIO_FLAG_APPEND;
++>>>>>>> 273dda76f757 (xfs: don't use ioends for direct write completions)
  		set_buffer_defer_completion(bh_result);
- 
- 		trace_xfs_gbmap_direct_new(XFS_I(inode), offset, size, type,
- 					   imap);
- 	} else {
- 		trace_xfs_gbmap_direct_none(XFS_I(inode), offset, size, type,
- 					    imap);
  	}
  }
  
@@@ -1387,8 -1441,12 +1372,17 @@@ __xfs_get_blocks
  		if (ISUNWRITTEN(&imap))
  			set_buffer_unwritten(bh_result);
  		/* direct IO needs special help */
++<<<<<<< HEAD
 +		if (create && direct)
 +			xfs_map_direct(inode, bh_result, &imap, offset);
++=======
+ 		if (create && direct) {
+ 			if (dax_fault)
+ 				ASSERT(!ISUNWRITTEN(&imap));
+ 			else
+ 				xfs_map_direct(inode, bh_result, &imap, offset);
+ 		}
++>>>>>>> 273dda76f757 (xfs: don't use ioends for direct write completions)
  	}
  
  	/*
@@@ -1444,42 -1503,53 +1438,48 @@@ xfs_get_blocks_direct
  	struct buffer_head	*bh_result,
  	int			create)
  {
 -	return __xfs_get_blocks(inode, iblock, bh_result, create, true, false);
 -}
 -
 -int
 -xfs_get_blocks_dax_fault(
 -	struct inode		*inode,
 -	sector_t		iblock,
 -	struct buffer_head	*bh_result,
 -	int			create)
 -{
 -	return __xfs_get_blocks(inode, iblock, bh_result, create, true, true);
 +	return __xfs_get_blocks(inode, iblock, bh_result, create, true);
  }
  
- static void
- __xfs_end_io_direct_write(
- 	struct inode		*inode,
- 	struct xfs_ioend	*ioend,
+ /*
+  * Complete a direct I/O write request.
+  *
+  * xfs_map_direct passes us some flags in the private data to tell us what to
+  * do.  If no flags are set, then the write IO is an overwrite wholly within
+  * the existing allocated file size and so there is nothing for us to do.
+  *
+  * Note that in this case the completion can be called in interrupt context,
+  * whereas if we have flags set we will always be called in task context
+  * (i.e. from a workqueue).
+  */
+ STATIC int
+ xfs_end_io_direct_write(
+ 	struct kiocb		*iocb,
  	loff_t			offset,
- 	ssize_t			size)
+ 	ssize_t			size,
+ 	void			*private)
  {
++<<<<<<< HEAD
 +	struct xfs_mount	*mp = XFS_I(inode)->i_mount;
 +	unsigned long		flags;
++=======
+ 	struct inode		*inode = file_inode(iocb->ki_filp);
+ 	struct xfs_inode	*ip = XFS_I(inode);
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	uintptr_t		flags = (uintptr_t)private;
+ 	int			error = 0;
++>>>>>>> 273dda76f757 (xfs: don't use ioends for direct write completions)
  
- 	if (XFS_FORCED_SHUTDOWN(mp) || ioend->io_error)
- 		goto out_end_io;
+ 	trace_xfs_end_io_direct_write(ip, offset, size);
  
- 	/*
- 	 * dio completion end_io functions are only called on writes if more
- 	 * than 0 bytes was written.
- 	 */
- 	ASSERT(size > 0);
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
  
- 	/*
- 	 * The ioend only maps whole blocks, while the IO may be sector aligned.
- 	 * Hence the ioend offset/size may not match the IO offset/size exactly.
- 	 * Because we don't map overwrites within EOF into the ioend, the offset
- 	 * may not match, but only if the endio spans EOF.  Either way, write
- 	 * the IO sizes into the ioend so that completion processing does the
- 	 * right thing.
- 	 */
- 	ASSERT(offset + size <= ioend->io_offset + ioend->io_size);
- 	ioend->io_size = size;
- 	ioend->io_offset = offset;
+ 	if (size <= 0)
+ 		return size;
  
  	/*
- 	 * The ioend tells us whether we are doing unwritten extent conversion
+ 	 * The flags tell us whether we are doing unwritten extent conversions
  	 * or an append transaction that updates the on-disk file size. These
  	 * cases are the only cases where we should *potentially* be needing
  	 * to update the VFS inode size.
@@@ -1494,56 -1570,50 +1500,90 @@@
  	 * here can result in EOF moving backwards and Bad Things Happen when
  	 * that occurs.
  	 */
++<<<<<<< HEAD
 +	spin_lock_irqsave(&XFS_I(inode)->i_size_lock, flags);
 +	if (offset + size > i_size_read(inode))
 +		i_size_write(inode, offset + size);
 +	spin_unlock_irqrestore(&XFS_I(inode)->i_size_lock, flags);
++=======
+ 	spin_lock(&ip->i_flags_lock);
+ 	if (offset + size > i_size_read(inode))
+ 		i_size_write(inode, offset + size);
+ 	spin_unlock(&ip->i_flags_lock);
++>>>>>>> 273dda76f757 (xfs: don't use ioends for direct write completions)
  
- 	/*
- 	 * If we are doing an append IO that needs to update the EOF on disk,
- 	 * do the transaction reserve now so we can use common end io
- 	 * processing. Stashing the error (if there is one) in the ioend will
- 	 * result in the ioend processing passing on the error if it is
- 	 * possible as we can't return it from here.
- 	 */
- 	if (ioend->io_type == XFS_IO_OVERWRITE)
- 		ioend->io_error = xfs_setfilesize_trans_alloc(ioend);
+ 	if (flags & XFS_DIO_FLAG_UNWRITTEN) {
+ 		trace_xfs_end_io_direct_write_unwritten(ip, offset, size);
  
- out_end_io:
- 	xfs_end_io(&ioend->io_work);
- 	return;
- }
+ 		error = xfs_iomap_write_unwritten(ip, offset, size);
+ 	} else if (flags & XFS_DIO_FLAG_APPEND) {
+ 		struct xfs_trans *tp;
  
++<<<<<<< HEAD
 +/*
 + * Complete a direct I/O write request.
 + *
 + * The ioend structure is passed from __xfs_get_blocks() to tell us what to do.
 + * If no ioend exists (i.e. @private == NULL) then the write IO is an overwrite
 + * wholly within the EOF and so there is nothing for us to do. Note that in this
 + * case the completion can be called in interrupt context, whereas if we have an
 + * ioend we will always be called in task context (i.e. from a workqueue).
 + */
 +void
 +xfs_end_io_direct_write(
 +	struct kiocb		*iocb,
 +	loff_t			offset,
 +	ssize_t			size,
 +	void			*private,
 +	int			__attribute__((unused))ret,
 +	bool			__attribute__((unused))is_async)
 +{
 +	struct inode		*inode = file_inode(iocb->ki_filp);
 +	struct xfs_ioend	*ioend = private;
 +
 +	trace_xfs_gbmap_direct_endio(XFS_I(inode), offset, size,
 +				     ioend ? ioend->io_type : 0, NULL);
 +
 +	if (!ioend) {
 +		ASSERT(offset + size <= i_size_read(inode));
 +		return;
 +	}
 +
 +	__xfs_end_io_direct_write(inode, ioend, offset, size);
++=======
+ 		trace_xfs_end_io_direct_write_append(ip, offset, size);
+ 
+ 		tp = xfs_trans_alloc(mp, XFS_TRANS_FSYNC_TS);
+ 		error = xfs_trans_reserve(tp, &M_RES(mp)->tr_fsyncts, 0, 0);
+ 		if (error) {
+ 			xfs_trans_cancel(tp);
+ 			return error;
+ 		}
+ 		error = xfs_setfilesize(ip, tp, offset, size);
+ 	}
+ 
+ 	return error;
+ }
+ 
+ static inline ssize_t
+ xfs_vm_do_dio(
+ 	struct inode		*inode,
+ 	struct kiocb		*iocb,
+ 	struct iov_iter		*iter,
+ 	loff_t			offset,
+ 	dio_iodone_t		endio,
+ 	int			flags)
+ {
+ 	struct block_device	*bdev;
+ 
+ 	if (IS_DAX(inode))
+ 		return dax_do_io(iocb, inode, iter, offset,
+ 				 xfs_get_blocks_direct, endio, 0);
+ 
+ 	bdev = xfs_find_bdev_for_inode(inode);
+ 	return  __blockdev_direct_IO(iocb, inode, bdev, iter, offset,
+ 				     xfs_get_blocks_direct, endio, NULL, flags);
++>>>>>>> 273dda76f757 (xfs: don't use ioends for direct write completions)
  }
  
  STATIC ssize_t
diff --cc fs/xfs/xfs_trace.h
index 32faa02465ef,c8d58426008e..000000000000
--- a/fs/xfs/xfs_trace.h
+++ b/fs/xfs/xfs_trace.h
@@@ -1294,13 -1296,7 +1294,17 @@@ DEFINE_IOMAP_EVENT(xfs_map_blocks_found
  DEFINE_IOMAP_EVENT(xfs_map_blocks_alloc);
  DEFINE_IOMAP_EVENT(xfs_get_blocks_found);
  DEFINE_IOMAP_EVENT(xfs_get_blocks_alloc);
++<<<<<<< HEAD
 +DEFINE_IOMAP_EVENT(xfs_gbmap_direct);
 +DEFINE_IOMAP_EVENT(xfs_gbmap_direct_new);
 +DEFINE_IOMAP_EVENT(xfs_gbmap_direct_update);
 +DEFINE_IOMAP_EVENT(xfs_gbmap_direct_none);
 +DEFINE_IOMAP_EVENT(xfs_gbmap_direct_endio);
 +DEFINE_IOMAP_EVENT(xfs_iomap_alloc);
 +DEFINE_IOMAP_EVENT(xfs_iomap_found);
++=======
+ DEFINE_IOMAP_EVENT(xfs_get_blocks_map_direct);
++>>>>>>> 273dda76f757 (xfs: don't use ioends for direct write completions)
  
  DECLARE_EVENT_CLASS(xfs_simple_io_class,
  	TP_PROTO(struct xfs_inode *ip, xfs_off_t offset, ssize_t count),
* Unmerged path fs/xfs/xfs_aops.c
* Unmerged path fs/xfs/xfs_trace.h
