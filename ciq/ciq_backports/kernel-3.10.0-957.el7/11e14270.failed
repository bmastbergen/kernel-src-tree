acpi, nfit: add support for NVDIMM_FAMILY_INTEL v1.6 DSMs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [acpi] nfit: add support for NVDIMM_FAMILY_INTEL v1.6 DSMs (Jeff Moyer) [1507717]
Rebuild_FUZZ: 94.44%
commit-author Dan Williams <dan.j.williams@intel.com>
commit 11e142701609546632ba1fda586252d391026a3f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/11e14270.failed

Per v1.6 of the NVDIMM_FAMILY_INTEL command set [1] some of the new
commands require rev-id 2. In addition to enabling ND_CMD_CALL for these
new function numbers, add a lookup table for revision-ids by family
and function number.

[1]: http://pmem.io/documents/NVDIMM_DSM_Interface-V1.6.pdf

	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 11e142701609546632ba1fda586252d391026a3f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/nfit/core.c
diff --cc drivers/acpi/nfit/core.c
index b50d8cd25e0f,aa75d67ceee9..000000000000
--- a/drivers/acpi/nfit/core.c
+++ b/drivers/acpi/nfit/core.c
@@@ -470,8 -494,15 +496,20 @@@ int acpi_nfit_ctl(struct nvdimm_bus_des
  
  		out_obj = acpi_label_write(handle, p->in_offset, p->in_length,
  				p->in_buf);
++<<<<<<< HEAD
 +	} else
 +		out_obj = acpi_evaluate_dsm(handle, guid->b, 1, func, &in_obj);
++=======
+ 	} else {
+ 		u8 revid;
+ 
+ 		if (nfit_mem)
+ 			revid = nfit_dsm_revid(nfit_mem->family, func);
+ 		else
+ 			revid = 1;
+ 		out_obj = acpi_evaluate_dsm(handle, guid, revid, func, &in_obj);
+ 	}
++>>>>>>> 11e142701609 (acpi, nfit: add support for NVDIMM_FAMILY_INTEL v1.6 DSMs)
  
  	if (!out_obj) {
  		dev_dbg(dev, "%s:%s _DSM failed cmd: %s\n", __func__, dimm_name,
@@@ -1644,8 -1673,8 +1682,13 @@@ static int acpi_nfit_add_dimm(struct ac
  	 * different command sets.  Note, that checking for function0 (bit0)
  	 * tells us if any commands are reachable through this GUID.
  	 */
++<<<<<<< HEAD
 +	for (i = NVDIMM_FAMILY_INTEL; i <= NVDIMM_FAMILY_MSFT; i++)
 +		if (acpi_check_dsm(adev_dimm->handle, (to_nfit_uuid(i))->b, 1, 1))
++=======
+ 	for (i = 0; i <= NVDIMM_FAMILY_MAX; i++)
+ 		if (acpi_check_dsm(adev_dimm->handle, to_nfit_uuid(i), 1, 1))
++>>>>>>> 11e142701609 (acpi, nfit: add support for NVDIMM_FAMILY_INTEL v1.6 DSMs)
  			if (family < 0 || i == default_dsm_family)
  				family = i;
  
@@@ -1674,7 -1703,9 +1717,13 @@@
  
  	guid = to_nfit_uuid(nfit_mem->family);
  	for_each_set_bit(i, &dsm_mask, BITS_PER_LONG)
++<<<<<<< HEAD
 +		if (acpi_check_dsm(adev_dimm->handle, guid->b, 1, 1ULL << i))
++=======
+ 		if (acpi_check_dsm(adev_dimm->handle, guid,
+ 					nfit_dsm_revid(nfit_mem->family, i),
+ 					1ULL << i))
++>>>>>>> 11e142701609 (acpi, nfit: add support for NVDIMM_FAMILY_INTEL v1.6 DSMs)
  			set_bit(i, &nfit_mem->dsm_mask);
  
  	obj = acpi_label_info(adev_dimm->handle);
* Unmerged path drivers/acpi/nfit/core.c
diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h
index b987196bf132..341be9511d0e 100644
--- a/drivers/acpi/nfit/nfit.h
+++ b/drivers/acpi/nfit/nfit.h
@@ -24,7 +24,7 @@
 /* ACPI 6.1 */
 #define UUID_NFIT_BUS "2f10e7a4-9e91-11e4-89d3-123b93f75cba"
 
-/* http://pmem.io/documents/NVDIMM_DSM_Interface_Example.pdf */
+/* http://pmem.io/documents/NVDIMM_DSM_Interface-V1.6.pdf */
 #define UUID_NFIT_DIMM "4309ac30-0d11-11e4-9191-0800200c9a66"
 
 /* https://github.com/HewlettPackard/hpe-nvm/blob/master/Documentation/ */
@@ -38,12 +38,36 @@
 		| ACPI_NFIT_MEM_RESTORE_FAILED | ACPI_NFIT_MEM_FLUSH_FAILED \
 		| ACPI_NFIT_MEM_NOT_ARMED | ACPI_NFIT_MEM_MAP_FAILED)
 
+#define NVDIMM_FAMILY_MAX NVDIMM_FAMILY_MSFT
+
 #define NVDIMM_STANDARD_CMDMASK \
 (1 << ND_CMD_SMART | 1 << ND_CMD_SMART_THRESHOLD | 1 << ND_CMD_DIMM_FLAGS \
  | 1 << ND_CMD_GET_CONFIG_SIZE | 1 << ND_CMD_GET_CONFIG_DATA \
  | 1 << ND_CMD_SET_CONFIG_DATA | 1 << ND_CMD_VENDOR_EFFECT_LOG_SIZE \
  | 1 << ND_CMD_VENDOR_EFFECT_LOG | 1 << ND_CMD_VENDOR)
 
+/*
+ * Command numbers that the kernel needs to know about to handle
+ * non-default DSM revision ids
+ */
+enum nvdimm_family_cmds {
+	NVDIMM_INTEL_GET_MODES = 11,
+	NVDIMM_INTEL_GET_FWINFO = 12,
+	NVDIMM_INTEL_START_FWUPDATE = 13,
+	NVDIMM_INTEL_SEND_FWUPDATE = 14,
+	NVDIMM_INTEL_FINISH_FWUPDATE = 15,
+	NVDIMM_INTEL_QUERY_FWUPDATE = 16,
+	NVDIMM_INTEL_SET_THRESHOLD = 17,
+	NVDIMM_INTEL_INJECT_ERROR = 18,
+};
+
+#define NVDIMM_INTEL_CMDMASK \
+(NVDIMM_STANDARD_CMDMASK | 1 << NVDIMM_INTEL_GET_MODES \
+ | 1 << NVDIMM_INTEL_GET_FWINFO | 1 << NVDIMM_INTEL_START_FWUPDATE \
+ | 1 << NVDIMM_INTEL_SEND_FWUPDATE | 1 << NVDIMM_INTEL_FINISH_FWUPDATE \
+ | 1 << NVDIMM_INTEL_QUERY_FWUPDATE | 1 << NVDIMM_INTEL_SET_THRESHOLD \
+ | 1 << NVDIMM_INTEL_INJECT_ERROR)
+
 enum nfit_uuids {
 	/* for simplicity alias the uuid index with the family id */
 	NFIT_DEV_DIMM = NVDIMM_FAMILY_INTEL,
