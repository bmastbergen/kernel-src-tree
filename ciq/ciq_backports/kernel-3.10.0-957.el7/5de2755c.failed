hrtimer: Allow concurrent hrtimer_start() for self restarting timers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit 5de2755c8c8b3a6b8414870e2c284914a2b42e4d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5de2755c.failed

Because we drop cpu_base->lock around calling hrtimer::function, it is
possible for hrtimer_start() to come in between and enqueue the timer.

If hrtimer::function then returns HRTIMER_RESTART we'll hit the BUG_ON
because HRTIMER_STATE_ENQUEUED will be set.

Since the above is a perfectly valid scenario, remove the BUG_ON and
make the enqueue_hrtimer() call conditional on the timer not being
enqueued already.

NOTE: in that concurrent scenario its entirely common for both sites
to want to modify the hrtimer, since hrtimers don't provide
serialization themselves be sure to provide some such that the
hrtimer::function and the hrtimer_start() caller don't both try and
fudge the expiration state at the same time.

To that effect, add a WARN when someone tries to forward an already
enqueued timer, the most common way to change the expiry of self
restarting timers. Ideally we'd put the WARN in everything modifying
the expiry but most of that is inlines and we don't need the bloat.

Fixes: 2d44ae4d7135 ("hrtimer: clean up cpu->base locking tricks")
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Ben Segall <bsegall@google.com>
	Cc: Roman Gushchin <klamm@yandex-team.ru>
	Cc: Paul Turner <pjt@google.com>
Link: http://lkml.kernel.org/r/20150415113105.GT5029@twins.programming.kicks-ass.net
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 5de2755c8c8b3a6b8414870e2c284914a2b42e4d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/hrtimer.c
diff --cc kernel/hrtimer.c
index ecbe27cbadd0,4adf32067862..000000000000
--- a/kernel/hrtimer.c
+++ b/kernel/hrtimer.c
@@@ -841,8 -799,11 +841,16 @@@ u64 hrtimer_forward(struct hrtimer *tim
  	if (delta.tv64 < 0)
  		return 0;
  
++<<<<<<< HEAD:kernel/hrtimer.c
 +	if (interval.tv64 < timer->base->resolution.tv64)
 +		interval.tv64 = timer->base->resolution.tv64;
++=======
+ 	if (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))
+ 		return 0;
+ 
+ 	if (interval.tv64 < hrtimer_resolution)
+ 		interval.tv64 = hrtimer_resolution;
++>>>>>>> 5de2755c8c8b (hrtimer: Allow concurrent hrtimer_start() for self restarting timers):kernel/time/hrtimer.c
  
  	if (unlikely(delta.tv64 >= interval.tv64)) {
  		s64 incr = ktime_to_ns(interval);
* Unmerged path kernel/hrtimer.c
