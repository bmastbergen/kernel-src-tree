mmc: core: Remove option not to use blk-mq

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [mmc] core: Remove option not to use blk-mq (Gopal Tiwari) [1456570]
Rebuild_FUZZ: 93.67%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 1bec43a3b181baebdf8a4cd739b480a9132601d7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/1bec43a3.failed

Remove config option MMC_MQ_DEFAULT and parameter mmc_use_blk_mq, so that
blk-mq must be used always.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Acked-by: Linus Walleij <linus.walleij@linaro.org>
	Tested-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 1bec43a3b181baebdf8a4cd739b480a9132601d7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/host.c
#	drivers/mmc/core/host.h
diff --cc drivers/mmc/core/host.c
index d793f9c6e54a,64b03d6eaf18..000000000000
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@@ -391,11 -396,13 +391,17 @@@ struct mmc_host *mmc_alloc_host(int ext
  	 * They have to set these according to their abilities.
  	 */
  	host->max_segs = 1;
 -	host->max_seg_size = PAGE_SIZE;
 +	host->max_seg_size = PAGE_CACHE_SIZE;
  
 -	host->max_req_size = PAGE_SIZE;
 +	host->max_req_size = PAGE_CACHE_SIZE;
  	host->max_blk_size = 512;
++<<<<<<< HEAD
 +	host->max_blk_count = PAGE_CACHE_SIZE / 512;
++=======
+ 	host->max_blk_count = PAGE_SIZE / 512;
+ 
+ 	host->fixed_drv_type = -EINVAL;
++>>>>>>> 1bec43a3b181 (mmc: core: Remove option not to use blk-mq)
  
  	return host;
  }
diff --cc drivers/mmc/core/host.h
index 5e9a1293091b,6d896869e5c6..000000000000
--- a/drivers/mmc/core/host.h
+++ b/drivers/mmc/core/host.h
@@@ -18,9 -19,70 +18,74 @@@ void mmc_unregister_host_class(void)
  void mmc_retune_enable(struct mmc_host *host);
  void mmc_retune_disable(struct mmc_host *host);
  void mmc_retune_hold(struct mmc_host *host);
 +void mmc_retune_hold_now(struct mmc_host *host);
  void mmc_retune_release(struct mmc_host *host);
  int mmc_retune(struct mmc_host *host);
++<<<<<<< HEAD
++=======
+ void mmc_retune_pause(struct mmc_host *host);
+ void mmc_retune_unpause(struct mmc_host *host);
+ 
+ static inline void mmc_retune_hold_now(struct mmc_host *host)
+ {
+ 	host->retune_now = 0;
+ 	host->hold_retune += 1;
+ }
+ 
+ static inline void mmc_retune_recheck(struct mmc_host *host)
+ {
+ 	if (host->hold_retune <= 1)
+ 		host->retune_now = 1;
+ }
+ 
+ static inline int mmc_host_cmd23(struct mmc_host *host)
+ {
+ 	return host->caps & MMC_CAP_CMD23;
+ }
+ 
+ static inline bool mmc_host_done_complete(struct mmc_host *host)
+ {
+ 	return host->caps & MMC_CAP_DONE_COMPLETE;
+ }
+ 
+ static inline int mmc_boot_partition_access(struct mmc_host *host)
+ {
+ 	return !(host->caps2 & MMC_CAP2_BOOTPART_NOACC);
+ }
+ 
+ static inline int mmc_host_uhs(struct mmc_host *host)
+ {
+ 	return host->caps &
+ 		(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
+ 		 MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 |
+ 		 MMC_CAP_UHS_DDR50);
+ }
+ 
+ static inline bool mmc_card_hs200(struct mmc_card *card)
+ {
+ 	return card->host->ios.timing == MMC_TIMING_MMC_HS200;
+ }
+ 
+ static inline bool mmc_card_ddr52(struct mmc_card *card)
+ {
+ 	return card->host->ios.timing == MMC_TIMING_MMC_DDR52;
+ }
+ 
+ static inline bool mmc_card_hs400(struct mmc_card *card)
+ {
+ 	return card->host->ios.timing == MMC_TIMING_MMC_HS400;
+ }
+ 
+ static inline bool mmc_card_hs400es(struct mmc_card *card)
+ {
+ 	return card->host->ios.enhanced_strobe;
+ }
+ 
+ static inline bool mmc_host_use_blk_mq(struct mmc_host *host)
+ {
+ 	return true;
+ }
++>>>>>>> 1bec43a3b181 (mmc: core: Remove option not to use blk-mq)
  
  #endif
  
* Unmerged path drivers/mmc/core/host.c
* Unmerged path drivers/mmc/core/host.h
