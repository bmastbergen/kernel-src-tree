net: sched: introduce shared filter blocks infrastructure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] sched: introduce shared filter blocks infrastructure (Ivan Vecera) [1584592]
Rebuild_FUZZ: 95.41%
commit-author Jiri Pirko <jiri@mellanox.com>
commit 4861738775d70e0165d04fe014f32b41bcb5414a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/48617387.failed

Allow qdiscs to share filter blocks among them. Each qdisc type has to
use block get/put extended modifications that enable sharing.
Shared blocks are tracked within each net namespace and identified
by u32 index. This index is passed from user during the qdisc creation.
If user passes index that is not used by any other qdisc, new block
is created. If user passes index that is already used, the existing
block will be re-used.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Acked-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4861738775d70e0165d04fe014f32b41bcb5414a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/pkt_cls.h
#	include/net/sch_generic.h
#	net/sched/cls_api.c
diff --cc include/net/pkt_cls.h
index bf70a6a4bd8a,c40d60e6a883..000000000000
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@@ -18,6 -19,20 +18,23 @@@ struct tcf_walker 
  int register_tcf_proto_ops(struct tcf_proto_ops *ops);
  int unregister_tcf_proto_ops(struct tcf_proto_ops *ops);
  
++<<<<<<< HEAD
++=======
+ enum tcf_block_binder_type {
+ 	TCF_BLOCK_BINDER_TYPE_UNSPEC,
+ 	TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS,
+ 	TCF_BLOCK_BINDER_TYPE_CLSACT_EGRESS,
+ };
+ 
+ struct tcf_block_ext_info {
+ 	enum tcf_block_binder_type binder_type;
+ 	tcf_chain_head_change_t *chain_head_change;
+ 	void *chain_head_change_priv;
+ 	u32 block_index;
+ };
+ 
+ struct tcf_block_cb;
++>>>>>>> 4861738775d7 (net: sched: introduce shared filter blocks infrastructure)
  bool tcf_queue_work(struct work_struct *work);
  
  #ifdef CONFIG_NET_CLS
@@@ -25,11 -40,23 +42,17 @@@ struct tcf_chain *tcf_chain_get(struct 
  				bool create);
  void tcf_chain_put(struct tcf_chain *chain);
  int tcf_block_get(struct tcf_block **p_block,
 -		  struct tcf_proto __rcu **p_filter_chain, struct Qdisc *q,
 -		  struct netlink_ext_ack *extack);
 -int tcf_block_get_ext(struct tcf_block **p_block, struct Qdisc *q,
 -		      struct tcf_block_ext_info *ei,
 -		      struct netlink_ext_ack *extack);
 +		  struct tcf_proto __rcu **p_filter_chain);
  void tcf_block_put(struct tcf_block *block);
 -void tcf_block_put_ext(struct tcf_block *block, struct Qdisc *q,
 -		       struct tcf_block_ext_info *ei);
  
+ static inline bool tcf_block_shared(struct tcf_block *block)
+ {
+ 	return block->index;
+ }
+ 
  static inline struct Qdisc *tcf_block_q(struct tcf_block *block)
  {
+ 	WARN_ON(tcf_block_shared(block));
  	return block->q;
  }
  
diff --cc include/net/sch_generic.h
index 7a74a222e0f8,cc0c1e4711dc..000000000000
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@@ -286,6 -284,11 +286,14 @@@ struct tcf_chain 
  
  struct tcf_block {
  	struct list_head chain_list;
++<<<<<<< HEAD
++=======
+ 	u32 index; /* block index for shared blocks */
+ 	unsigned int refcnt;
+ 	struct net *net;
+ 	struct Qdisc *q;
+ 	struct list_head cb_list;
++>>>>>>> 4861738775d7 (net: sched: introduce shared filter blocks infrastructure)
  };
  
  static inline void qdisc_cb_private_validate(const struct sk_buff *skb, int sz)
diff --cc net/sched/cls_api.c
index 0e9c21220742,ee319b1598b5..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -23,8 -23,8 +23,9 @@@
  #include <linux/skbuff.h>
  #include <linux/init.h>
  #include <linux/kmod.h>
 +#include <linux/err.h>
  #include <linux/slab.h>
+ #include <linux/idr.h>
  #include <net/net_namespace.h>
  #include <net/sock.h>
  #include <net/netlink.h>
@@@ -247,37 -268,214 +248,150 @@@ void tcf_chain_put(struct tcf_chain *ch
  }
  EXPORT_SYMBOL(tcf_chain_put);
  
 -static void tcf_block_offload_cmd(struct tcf_block *block, struct Qdisc *q,
 -				  struct tcf_block_ext_info *ei,
 -				  enum tc_block_command command)
 -{
 -	struct net_device *dev = q->dev_queue->dev;
 -	struct tc_block_offload bo = {};
 -
 -	if (!dev->netdev_ops->ndo_setup_tc)
 -		return;
 -	bo.command = command;
 -	bo.binder_type = ei->binder_type;
 -	bo.block = block;
 -	dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_BLOCK, &bo);
 -}
 -
 -static void tcf_block_offload_bind(struct tcf_block *block, struct Qdisc *q,
 -				   struct tcf_block_ext_info *ei)
 -{
 -	tcf_block_offload_cmd(block, q, ei, TC_BLOCK_BIND);
 -}
 -
 -static void tcf_block_offload_unbind(struct tcf_block *block, struct Qdisc *q,
 -				     struct tcf_block_ext_info *ei)
 -{
 -	tcf_block_offload_cmd(block, q, ei, TC_BLOCK_UNBIND);
 -}
 -
 -static int
 -tcf_chain_head_change_cb_add(struct tcf_chain *chain,
 -			     struct tcf_block_ext_info *ei,
 -			     struct netlink_ext_ack *extack)
 -{
 -	struct tcf_filter_chain_list_item *item;
 -
 -	item = kmalloc(sizeof(*item), GFP_KERNEL);
 -	if (!item) {
 -		NL_SET_ERR_MSG(extack, "Memory allocation for head change callback item failed");
 -		return -ENOMEM;
 -	}
 -	item->chain_head_change = ei->chain_head_change;
 -	item->chain_head_change_priv = ei->chain_head_change_priv;
 -	if (chain->filter_chain)
 -		tcf_chain_head_change_item(item, chain->filter_chain);
 -	list_add(&item->list, &chain->filter_chain_list);
 -	return 0;
 -}
 -
  static void
 -tcf_chain_head_change_cb_del(struct tcf_chain *chain,
 -			     struct tcf_block_ext_info *ei)
 +tcf_chain_filter_chain_ptr_set(struct tcf_chain *chain,
 +			       struct tcf_proto __rcu **p_filter_chain)
  {
 -	struct tcf_filter_chain_list_item *item;
 -
 -	list_for_each_entry(item, &chain->filter_chain_list, list) {
 -		if ((!ei->chain_head_change && !ei->chain_head_change_priv) ||
 -		    (item->chain_head_change == ei->chain_head_change &&
 -		     item->chain_head_change_priv == ei->chain_head_change_priv)) {
 -			tcf_chain_head_change_item(item, NULL);
 -			list_del(&item->list);
 -			kfree(item);
 -			return;
 -		}
 -	}
 -	WARN_ON(1);
 +	chain->p_filter_chain = p_filter_chain;
  }
  
++<<<<<<< HEAD
 +int tcf_block_get(struct tcf_block **p_block,
 +		  struct tcf_proto __rcu **p_filter_chain)
++=======
+ struct tcf_net {
+ 	struct idr idr;
+ };
+ 
+ static unsigned int tcf_net_id;
+ 
+ static int tcf_block_insert(struct tcf_block *block, struct net *net,
+ 			    u32 block_index, struct netlink_ext_ack *extack)
  {
- 	struct tcf_block *block = kzalloc(sizeof(*block), GFP_KERNEL);
+ 	struct tcf_net *tn = net_generic(net, tcf_net_id);
+ 	int err;
+ 
+ 	err = idr_alloc_ext(&tn->idr, block, NULL, block_index,
+ 			    block_index + 1, GFP_KERNEL);
+ 	if (err)
+ 		return err;
+ 	block->index = block_index;
+ 	return 0;
+ }
+ 
+ static void tcf_block_remove(struct tcf_block *block, struct net *net)
++>>>>>>> 4861738775d7 (net: sched: introduce shared filter blocks infrastructure)
+ {
+ 	struct tcf_net *tn = net_generic(net, tcf_net_id);
+ 
+ 	idr_remove_ext(&tn->idr, block->index);
+ }
+ 
+ static struct tcf_block *tcf_block_create(struct net *net, struct Qdisc *q,
+ 					  struct netlink_ext_ack *extack)
+ {
+ 	struct tcf_block *block;
  	struct tcf_chain *chain;
  	int err;
  
++<<<<<<< HEAD
 +	if (!block)
 +		return -ENOMEM;
++=======
+ 	block = kzalloc(sizeof(*block), GFP_KERNEL);
+ 	if (!block) {
+ 		NL_SET_ERR_MSG(extack, "Memory allocation for block failed");
+ 		return ERR_PTR(-ENOMEM);
+ 	}
++>>>>>>> 4861738775d7 (net: sched: introduce shared filter blocks infrastructure)
  	INIT_LIST_HEAD(&block->chain_list);
 -	INIT_LIST_HEAD(&block->cb_list);
 -
  	/* Create chain 0 by default, it has to be always present. */
  	chain = tcf_chain_create(block, 0);
  	if (!chain) {
  		err = -ENOMEM;
  		goto err_chain_create;
  	}
++<<<<<<< HEAD
 +	tcf_chain_filter_chain_ptr_set(chain, p_filter_chain);
 +	*p_block = block;
 +	return 0;
 +
 +err_chain_create:
 +	kfree(block);
++=======
+ 	block->net = qdisc_net(q);
+ 	block->refcnt = 1;
+ 	block->net = net;
+ 	block->q = q;
+ 	return block;
+ 
+ err_chain_create:
+ 	kfree(block);
+ 	return ERR_PTR(err);
+ }
+ 
+ static struct tcf_block *tcf_block_lookup(struct net *net, u32 block_index)
+ {
+ 	struct tcf_net *tn = net_generic(net, tcf_net_id);
+ 
+ 	return idr_find_ext(&tn->idr, block_index);
+ }
+ 
+ static struct tcf_chain *tcf_block_chain_zero(struct tcf_block *block)
+ {
+ 	return list_first_entry(&block->chain_list, struct tcf_chain, list);
+ }
+ 
+ int tcf_block_get_ext(struct tcf_block **p_block, struct Qdisc *q,
+ 		      struct tcf_block_ext_info *ei,
+ 		      struct netlink_ext_ack *extack)
+ {
+ 	struct net *net = qdisc_net(q);
+ 	struct tcf_block *block = NULL;
+ 	bool created = false;
+ 	int err;
+ 
+ 	if (ei->block_index) {
+ 		/* block_index not 0 means the shared block is requested */
+ 		block = tcf_block_lookup(net, ei->block_index);
+ 		if (block)
+ 			block->refcnt++;
+ 	}
+ 
+ 	if (!block) {
+ 		block = tcf_block_create(net, q, extack);
+ 		if (IS_ERR(block))
+ 			return PTR_ERR(block);
+ 		created = true;
+ 		if (ei->block_index) {
+ 			err = tcf_block_insert(block, net,
+ 					       ei->block_index, extack);
+ 			if (err)
+ 				goto err_block_insert;
+ 		}
+ 	}
+ 
+ 	err = tcf_chain_head_change_cb_add(tcf_block_chain_zero(block),
+ 					   ei, extack);
+ 	if (err)
+ 		goto err_chain_head_change_cb_add;
+ 	tcf_block_offload_bind(block, q, ei);
+ 	*p_block = block;
+ 	return 0;
+ 
+ err_chain_head_change_cb_add:
+ 	if (created) {
+ 		if (tcf_block_shared(block))
+ 			tcf_block_remove(block, net);
+ err_block_insert:
+ 		kfree(tcf_block_chain_zero(block));
+ 		kfree(block);
+ 	} else {
+ 		block->refcnt--;
+ 	}
++>>>>>>> 4861738775d7 (net: sched: introduce shared filter blocks infrastructure)
  	return err;
  }
 -EXPORT_SYMBOL(tcf_block_get_ext);
 -
 -static void tcf_chain_head_change_dflt(struct tcf_proto *tp_head, void *priv)
 -{
 -	struct tcf_proto __rcu **p_filter_chain = priv;
 -
 -	rcu_assign_pointer(*p_filter_chain, tp_head);
 -}
 -
 -int tcf_block_get(struct tcf_block **p_block,
 -		  struct tcf_proto __rcu **p_filter_chain, struct Qdisc *q,
 -		  struct netlink_ext_ack *extack)
 -{
 -	struct tcf_block_ext_info ei = {
 -		.chain_head_change = tcf_chain_head_change_dflt,
 -		.chain_head_change_priv = p_filter_chain,
 -	};
 -
 -	WARN_ON(!p_filter_chain);
 -	return tcf_block_get_ext(p_block, q, &ei, extack);
 -}
  EXPORT_SYMBOL(tcf_block_get);
  
  /* XXX: Standalone actions are not allowed to jump to any chain, and bound
@@@ -289,26 -488,149 +403,54 @@@ void tcf_block_put(struct tcf_block *bl
  
  	if (!block)
  		return;
++<<<<<<< HEAD
 +
 +	/* Hold a refcnt for all chains, so that they don't disappear
 +	 * while we are iterating.
 +	 */
 +	list_for_each_entry(chain, &block->chain_list, list)
 +		tcf_chain_hold(chain);
++=======
+ 	tcf_chain_head_change_cb_del(tcf_block_chain_zero(block), ei);
++>>>>>>> 4861738775d7 (net: sched: introduce shared filter blocks infrastructure)
  
- 	list_for_each_entry(chain, &block->chain_list, list)
- 		tcf_chain_flush(chain);
+ 	if (--block->refcnt == 0) {
+ 		if (tcf_block_shared(block))
+ 			tcf_block_remove(block, block->net);
+ 
+ 		/* Hold a refcnt for all chains, so that they don't disappear
+ 		 * while we are iterating.
+ 		 */
+ 		list_for_each_entry(chain, &block->chain_list, list)
+ 			tcf_chain_hold(chain);
  
+ 		list_for_each_entry(chain, &block->chain_list, list)
+ 			tcf_chain_flush(chain);
+ 	}
+ 
++<<<<<<< HEAD
 +	/* At this point, all the chains should have refcnt >= 1. */
 +	list_for_each_entry_safe(chain, tmp, &block->chain_list, list)
 +		tcf_chain_put(chain);
 +
 +	/* Finally, put chain 0 and allow block to be freed. */
 +	chain = list_first_entry(&block->chain_list, struct tcf_chain, list);
 +	tcf_chain_put(chain);
++=======
+ 	tcf_block_offload_unbind(block, q, ei);
+ 
+ 	if (block->refcnt == 0) {
+ 		/* At this point, all the chains should have refcnt >= 1. */
+ 		list_for_each_entry_safe(chain, tmp, &block->chain_list, list)
+ 			tcf_chain_put(chain);
+ 
+ 		/* Finally, put chain 0 and allow block to be freed. */
+ 		tcf_chain_put(tcf_block_chain_zero(block));
+ 	}
++>>>>>>> 4861738775d7 (net: sched: introduce shared filter blocks infrastructure)
  }
 -EXPORT_SYMBOL(tcf_block_put_ext);
 -
 -void tcf_block_put(struct tcf_block *block)
 -{
 -	struct tcf_block_ext_info ei = {0, };
 -
 -	if (!block)
 -		return;
 -	tcf_block_put_ext(block, block->q, &ei);
 -}
 -
  EXPORT_SYMBOL(tcf_block_put);
  
 -struct tcf_block_cb {
 -	struct list_head list;
 -	tc_setup_cb_t *cb;
 -	void *cb_ident;
 -	void *cb_priv;
 -	unsigned int refcnt;
 -};
 -
 -void *tcf_block_cb_priv(struct tcf_block_cb *block_cb)
 -{
 -	return block_cb->cb_priv;
 -}
 -EXPORT_SYMBOL(tcf_block_cb_priv);
 -
 -struct tcf_block_cb *tcf_block_cb_lookup(struct tcf_block *block,
 -					 tc_setup_cb_t *cb, void *cb_ident)
 -{	struct tcf_block_cb *block_cb;
 -
 -	list_for_each_entry(block_cb, &block->cb_list, list)
 -		if (block_cb->cb == cb && block_cb->cb_ident == cb_ident)
 -			return block_cb;
 -	return NULL;
 -}
 -EXPORT_SYMBOL(tcf_block_cb_lookup);
 -
 -void tcf_block_cb_incref(struct tcf_block_cb *block_cb)
 -{
 -	block_cb->refcnt++;
 -}
 -EXPORT_SYMBOL(tcf_block_cb_incref);
 -
 -unsigned int tcf_block_cb_decref(struct tcf_block_cb *block_cb)
 -{
 -	return --block_cb->refcnt;
 -}
 -EXPORT_SYMBOL(tcf_block_cb_decref);
 -
 -struct tcf_block_cb *__tcf_block_cb_register(struct tcf_block *block,
 -					     tc_setup_cb_t *cb, void *cb_ident,
 -					     void *cb_priv)
 -{
 -	struct tcf_block_cb *block_cb;
 -
 -	block_cb = kzalloc(sizeof(*block_cb), GFP_KERNEL);
 -	if (!block_cb)
 -		return NULL;
 -	block_cb->cb = cb;
 -	block_cb->cb_ident = cb_ident;
 -	block_cb->cb_priv = cb_priv;
 -	list_add(&block_cb->list, &block->cb_list);
 -	return block_cb;
 -}
 -EXPORT_SYMBOL(__tcf_block_cb_register);
 -
 -int tcf_block_cb_register(struct tcf_block *block,
 -			  tc_setup_cb_t *cb, void *cb_ident,
 -			  void *cb_priv)
 -{
 -	struct tcf_block_cb *block_cb;
 -
 -	block_cb = __tcf_block_cb_register(block, cb, cb_ident, cb_priv);
 -	return block_cb ? 0 : -ENOMEM;
 -}
 -EXPORT_SYMBOL(tcf_block_cb_register);
 -
 -void __tcf_block_cb_unregister(struct tcf_block_cb *block_cb)
 -{
 -	list_del(&block_cb->list);
 -	kfree(block_cb);
 -}
 -EXPORT_SYMBOL(__tcf_block_cb_unregister);
 -
 -void tcf_block_cb_unregister(struct tcf_block *block,
 -			     tc_setup_cb_t *cb, void *cb_ident)
 -{
 -	struct tcf_block_cb *block_cb;
 -
 -	block_cb = tcf_block_cb_lookup(block, cb, cb_ident);
 -	if (!block_cb)
 -		return;
 -	__tcf_block_cb_unregister(block_cb);
 -}
 -EXPORT_SYMBOL(tcf_block_cb_unregister);
 -
 -static int tcf_block_cb_call(struct tcf_block *block, enum tc_setup_type type,
 -			     void *type_data, bool err_stop)
 -{
 -	struct tcf_block_cb *block_cb;
 -	int ok_count = 0;
 -	int err;
 -
 -	list_for_each_entry(block_cb, &block->cb_list, list) {
 -		err = block_cb->cb(type, type_data, block_cb->cb_priv);
 -		if (err) {
 -			if (err_stop)
 -				return err;
 -		} else {
 -			ok_count++;
 -		}
 -	}
 -	return ok_count;
 -}
 -
  /* Main classifier routine: scans classifier chain attached
   * to this qdisc, (optionally) tests for protocol and asks
   * specific classifiers.
@@@ -1027,40 -1349,101 +1169,77 @@@ int tcf_exts_dump_stats(struct sk_buff 
  }
  EXPORT_SYMBOL(tcf_exts_dump_stats);
  
 -static int tc_exts_setup_cb_egdev_call(struct tcf_exts *exts,
 -				       enum tc_setup_type type,
 -				       void *type_data, bool err_stop)
 +int tcf_exts_get_dev(struct net_device *dev, struct tcf_exts *exts,
 +		     struct net_device **hw_dev)
  {
 -	int ok_count = 0;
  #ifdef CONFIG_NET_CLS_ACT
  	const struct tc_action *a;
 -	struct net_device *dev;
 -	int i, ret;
 +	LIST_HEAD(actions);
  
  	if (!tcf_exts_has_actions(exts))
 -		return 0;
 +		return -EINVAL;
  
 -	for (i = 0; i < exts->nr_actions; i++) {
 -		a = exts->actions[i];
 -		if (!a->ops->get_dev)
 -			continue;
 -		dev = a->ops->get_dev(a);
 -		if (!dev)
 -			continue;
 -		ret = tc_setup_cb_egdev_call(dev, type, type_data, err_stop);
 -		if (ret < 0)
 -			return ret;
 -		ok_count += ret;
 +	tcf_exts_to_list(exts, &actions);
 +	list_for_each_entry(a, &actions, list) {
 +		if (a->ops->get_dev)
 +			*hw_dev = a->ops->get_dev(a);
  	}
 +	if (*hw_dev)
 +		return 0;
  #endif
 -	return ok_count;
 -}
 -
 -int tc_setup_cb_call(struct tcf_block *block, struct tcf_exts *exts,
 -		     enum tc_setup_type type, void *type_data, bool err_stop)
 -{
 -	int ok_count;
 -	int ret;
 -
 -	ret = tcf_block_cb_call(block, type, type_data, err_stop);
 -	if (ret < 0)
 -		return ret;
 -	ok_count = ret;
 -
 -	if (!exts)
 -		return ok_count;
 -	ret = tc_exts_setup_cb_egdev_call(exts, type, type_data, err_stop);
 -	if (ret < 0)
 -		return ret;
 -	ok_count += ret;
 -
 -	return ok_count;
 +	return -EOPNOTSUPP;
  }
 -EXPORT_SYMBOL(tc_setup_cb_call);
 +EXPORT_SYMBOL(tcf_exts_get_dev);
  
+ static __net_init int tcf_net_init(struct net *net)
+ {
+ 	struct tcf_net *tn = net_generic(net, tcf_net_id);
+ 
+ 	idr_init(&tn->idr);
+ 	return 0;
+ }
+ 
+ static void __net_exit tcf_net_exit(struct net *net)
+ {
+ 	struct tcf_net *tn = net_generic(net, tcf_net_id);
+ 
+ 	idr_destroy(&tn->idr);
+ }
+ 
+ static struct pernet_operations tcf_net_ops = {
+ 	.init = tcf_net_init,
+ 	.exit = tcf_net_exit,
+ 	.id   = &tcf_net_id,
+ 	.size = sizeof(struct tcf_net),
+ };
+ 
  static int __init tc_filter_init(void)
  {
+ 	int err;
+ 
  	tc_filter_wq = alloc_ordered_workqueue("tc_filter_workqueue", 0);
  	if (!tc_filter_wq)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	rtnl_register(PF_UNSPEC, RTM_NEWTFILTER, tc_ctl_tfilter, NULL, NULL);
 +	rtnl_register(PF_UNSPEC, RTM_DELTFILTER, tc_ctl_tfilter, NULL, NULL);
++=======
+ 	err = register_pernet_subsys(&tcf_net_ops);
+ 	if (err)
+ 		goto err_register_pernet_subsys;
+ 
+ 	rtnl_register(PF_UNSPEC, RTM_NEWTFILTER, tc_ctl_tfilter, NULL, 0);
+ 	rtnl_register(PF_UNSPEC, RTM_DELTFILTER, tc_ctl_tfilter, NULL, 0);
++>>>>>>> 4861738775d7 (net: sched: introduce shared filter blocks infrastructure)
  	rtnl_register(PF_UNSPEC, RTM_GETTFILTER, tc_ctl_tfilter,
 -		      tc_dump_tfilter, 0);
 +		      tc_dump_tfilter, NULL);
  
  	return 0;
+ 
+ err_register_pernet_subsys:
+ 	destroy_workqueue(tc_filter_wq);
+ 	return err;
  }
  
  subsys_initcall(tc_filter_init);
* Unmerged path include/net/pkt_cls.h
* Unmerged path include/net/sch_generic.h
* Unmerged path net/sched/cls_api.c
