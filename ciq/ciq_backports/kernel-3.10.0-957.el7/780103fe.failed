iio: kfifo: Add resource management devm_iio_kfifo_allocate/free

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [iio] kfifo: Add resource management devm_iio_kfifo_allocate/free (Tony Camuso) [1559170]
Rebuild_FUZZ: 95.93%
commit-author Karol Wrona <k.wrona@samsung.com>
commit 780103fef5c88a97fb9c8d0079bf326ed6147f1f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/780103fe.failed

iio kfifo allocate/free gained their devm_ wrappers.

	Signed-off-by: Karol Wrona <k.wrona@samsung.com>
	Suggested-by: Jonathan Cameron <jic23@kernel.org>
	Signed-off-by: Jonathan Cameron <jic23@kernel.org>
(cherry picked from commit 780103fef5c88a97fb9c8d0079bf326ed6147f1f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/driver-model/devres.txt
diff --cc Documentation/driver-model/devres.txt
index 74e282453485,6d1e8eeb5990..000000000000
--- a/Documentation/driver-model/devres.txt
+++ b/Documentation/driver-model/devres.txt
@@@ -233,10 -233,35 +233,42 @@@ certainly invest a bit more effort int
    6. List of managed interfaces
    -----------------------------
  
++<<<<<<< HEAD
 +MEM
 +  devm_kzalloc()
 +  devm_kfree()
 +  devm_kmemdup()
++=======
+ CLOCK
+   devm_clk_get()
+   devm_clk_put()
+ 
+ DMA
+   dmam_alloc_coherent()
+   dmam_alloc_noncoherent()
+   dmam_declare_coherent_memory()
+   dmam_free_coherent()
+   dmam_free_noncoherent()
+   dmam_pool_create()
+   dmam_pool_destroy()
+ 
+ GPIO
+   devm_gpiod_get()
+   devm_gpiod_get_index()
+   devm_gpiod_get_index_optional()
+   devm_gpiod_get_optional()
+   devm_gpiod_put()
+ 
+ IIO
+   devm_iio_device_alloc()
+   devm_iio_device_free()
+   devm_iio_device_register()
+   devm_iio_device_unregister()
+   devm_iio_kfifo_allocate()
+   devm_iio_kfifo_free()
+   devm_iio_trigger_alloc()
+   devm_iio_trigger_free()
++>>>>>>> 780103fef5c8 (iio: kfifo: Add resource management devm_iio_kfifo_allocate/free)
  
  IO region
    devm_release_mem_region()
* Unmerged path Documentation/driver-model/devres.txt
diff --git a/drivers/iio/kfifo_buf.c b/drivers/iio/kfifo_buf.c
index 1bea41bcbdc6..17940c3d3606 100644
--- a/drivers/iio/kfifo_buf.c
+++ b/drivers/iio/kfifo_buf.c
@@ -162,4 +162,58 @@ void iio_kfifo_free(struct iio_buffer *r)
 }
 EXPORT_SYMBOL(iio_kfifo_free);
 
+static void devm_iio_kfifo_release(struct device *dev, void *res)
+{
+	iio_kfifo_free(*(struct iio_buffer **)res);
+}
+
+static int devm_iio_kfifo_match(struct device *dev, void *res, void *data)
+{
+	struct iio_buffer **r = res;
+
+	if (WARN_ON(!r || !*r))
+		return 0;
+
+	return *r == data;
+}
+
+/**
+ * devm_iio_fifo_allocate - Resource-managed iio_kfifo_allocate()
+ * @dev:		Device to allocate kfifo buffer for
+ *
+ * RETURNS:
+ * Pointer to allocated iio_buffer on success, NULL on failure.
+ */
+struct iio_buffer *devm_iio_kfifo_allocate(struct device *dev)
+{
+	struct iio_buffer **ptr, *r;
+
+	ptr = devres_alloc(devm_iio_kfifo_release, sizeof(*ptr), GFP_KERNEL);
+	if (!ptr)
+		return NULL;
+
+	r = iio_kfifo_allocate();
+	if (r) {
+		*ptr = r;
+		devres_add(dev, ptr);
+	} else {
+		devres_free(ptr);
+	}
+
+	return r;
+}
+EXPORT_SYMBOL(devm_iio_kfifo_allocate);
+
+/**
+ * devm_iio_fifo_free - Resource-managed iio_kfifo_free()
+ * @dev:		Device the buffer belongs to
+ * @r:			The buffer associated with the device
+ */
+void devm_iio_kfifo_free(struct device *dev, struct iio_buffer *r)
+{
+	WARN_ON(devres_release(dev, devm_iio_kfifo_release,
+			       devm_iio_kfifo_match, r));
+}
+EXPORT_SYMBOL(devm_iio_kfifo_free);
+
 MODULE_LICENSE("GPL");
diff --git a/include/linux/iio/kfifo_buf.h b/include/linux/iio/kfifo_buf.h
index 25eeac762e84..7ad748c56057 100644
--- a/include/linux/iio/kfifo_buf.h
+++ b/include/linux/iio/kfifo_buf.h
@@ -8,4 +8,7 @@
 struct iio_buffer *iio_kfifo_allocate(struct iio_dev *indio_dev);
 void iio_kfifo_free(struct iio_buffer *r);
 
+struct iio_buffer *devm_iio_kfifo_allocate(struct device *dev);
+void devm_iio_kfifo_free(struct device *dev, struct iio_buffer *r);
+
 #endif
