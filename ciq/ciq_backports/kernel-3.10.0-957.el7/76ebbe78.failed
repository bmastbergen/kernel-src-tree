locking/barriers: Add implicit smp_read_barrier_depends() to READ_ONCE()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Will Deacon <will.deacon@arm.com>
commit 76ebbe78f7390aee075a7f3768af197ded1bdfbb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/76ebbe78.failed

In preparation for the removal of lockless_dereference(), which is the
same as READ_ONCE() on all architectures other than Alpha, add an
implicit smp_read_barrier_depends() to READ_ONCE() so that it can be
used to head dependency chains on all architectures.

	Signed-off-by: Will Deacon <will.deacon@arm.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/1508840570-22169-3-git-send-email-will.deacon@arm.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 76ebbe78f7390aee075a7f3768af197ded1bdfbb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/compiler.h
diff --cc include/linux/compiler.h
index e754056ff6a4,7d7b77da9716..000000000000
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@@ -234,12 -233,33 +234,32 @@@ static __always_inline void __write_onc
   * with an explicit memory barrier or atomic instruction that provides the
   * required ordering.
   */
 -#include <asm/barrier.h>
  
++<<<<<<< HEAD
 +#define READ_ONCE(x) \
 +	({ union { typeof(x) __val; char __c[1]; } __u; __read_once_size(&(x), __u.__c, sizeof(x)); __u.__val; })
++=======
+ #define __READ_ONCE(x, check)						\
+ ({									\
+ 	union { typeof(x) __val; char __c[1]; } __u;			\
+ 	if (check)							\
+ 		__read_once_size(&(x), __u.__c, sizeof(x));		\
+ 	else								\
+ 		__read_once_size_nocheck(&(x), __u.__c, sizeof(x));	\
+ 	smp_read_barrier_depends(); /* Enforce dependency ordering from x */ \
+ 	__u.__val;							\
+ })
+ #define READ_ONCE(x) __READ_ONCE(x, 1)
+ 
+ /*
+  * Use READ_ONCE_NOCHECK() instead of READ_ONCE() if you need
+  * to hide memory access from KASAN.
+  */
+ #define READ_ONCE_NOCHECK(x) __READ_ONCE(x, 0)
++>>>>>>> 76ebbe78f739 (locking/barriers: Add implicit smp_read_barrier_depends() to READ_ONCE())
  
  #define WRITE_ONCE(x, val) \
 -({							\
 -	union { typeof(x) __val; char __c[1]; } __u =	\
 -		{ .__val = (__force typeof(x)) (val) }; \
 -	__write_once_size(&(x), __u.__c, sizeof(x));	\
 -	__u.__val;					\
 -})
 +	({ typeof(x) __val = (val); __write_once_size(&(x), &__val, sizeof(__val)); __val; })
  
  #endif /* __KERNEL__ */
  
* Unmerged path include/linux/compiler.h
