netfilter: ipset: Generalize extensions support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 03c8b234e61a9a3aab8d970b3bf681934ecfe443
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/03c8b234.failed

Get rid of the structure based extensions and introduce a blob for
the extensions. Thus we can support more extension types easily.

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 03c8b234e61a9a3aab8d970b3bf681934ecfe443)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_bitmap_ip.c
#	net/netfilter/ipset/ip_set_bitmap_ipmac.c
#	net/netfilter/ipset/ip_set_bitmap_port.c
#	net/netfilter/ipset/ip_set_hash_gen.h
#	net/netfilter/ipset/ip_set_list_set.c
diff --cc net/netfilter/ipset/ip_set_bitmap_ip.c
index deffacab62dc,94d985457c51..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_ip.c
+++ b/net/netfilter/ipset/ip_set_bitmap_ip.c
@@@ -261,11 -241,10 +242,11 @@@ init_map_ip(struct ip_set *set, struct 
  }
  
  static int
 -bitmap_ip_create(struct ip_set *set, struct nlattr *tb[], u32 flags)
 +bitmap_ip_create(struct net *net, struct ip_set *set, struct nlattr *tb[],
 +		 u32 flags)
  {
  	struct bitmap_ip *map;
- 	u32 first_ip = 0, last_ip = 0, hosts, cadt_flags = 0;
+ 	u32 first_ip = 0, last_ip = 0, hosts;
  	u64 elements;
  	u8 netmask = 32;
  	int ret;
@@@ -337,61 -316,15 +318,73 @@@
  
  	map->memsize = bitmap_bytes(0, elements - 1);
  	set->variant = &bitmap_ip;
++<<<<<<< HEAD
 +	if (tb[IPSET_ATTR_CADT_FLAGS])
 +		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
 +	if (cadt_flags & IPSET_FLAG_WITH_COUNTERS) {
 +		set->extensions |= IPSET_EXT_COUNTER;
 +		if (tb[IPSET_ATTR_TIMEOUT]) {
 +			map->dsize = sizeof(struct bitmap_ipct_elem);
 +			map->offset[IPSET_EXT_ID_TIMEOUT] =
 +				offsetof(struct bitmap_ipct_elem, timeout);
 +			map->offset[IPSET_EXT_ID_COUNTER] =
 +				offsetof(struct bitmap_ipct_elem, counter);
 +
 +			if (!init_map_ip(set, map, first_ip, last_ip,
 +					 elements, hosts, netmask)) {
 +				kfree(map);
 +				return -ENOMEM;
 +			}
 +
 +			map->timeout = ip_set_timeout_uget(
 +				tb[IPSET_ATTR_TIMEOUT]);
 +			set->extensions |= IPSET_EXT_TIMEOUT;
 +
 +			bitmap_ip_gc_init(set, bitmap_ip_gc);
 +		} else {
 +			map->dsize = sizeof(struct bitmap_ipc_elem);
 +			map->offset[IPSET_EXT_ID_COUNTER] =
 +				offsetof(struct bitmap_ipc_elem, counter);
 +
 +			if (!init_map_ip(set, map, first_ip, last_ip,
 +					 elements, hosts, netmask)) {
 +				kfree(map);
 +				return -ENOMEM;
 +			}
 +		}
 +	} else if (tb[IPSET_ATTR_TIMEOUT]) {
 +		map->dsize = sizeof(struct bitmap_ipt_elem);
 +		map->offset[IPSET_EXT_ID_TIMEOUT] =
 +			offsetof(struct bitmap_ipt_elem, timeout);
 +
 +		if (!init_map_ip(set, map, first_ip, last_ip,
 +				 elements, hosts, netmask)) {
 +			kfree(map);
 +			return -ENOMEM;
 +		}
 +
 +		map->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 +		set->extensions |= IPSET_EXT_TIMEOUT;
 +
 +		bitmap_ip_gc_init(set, bitmap_ip_gc);
 +	} else {
 +		map->dsize = 0;
 +		if (!init_map_ip(set, map, first_ip, last_ip,
 +				 elements, hosts, netmask)) {
 +			kfree(map);
 +			return -ENOMEM;
 +		}
++=======
+ 	set->dsize = ip_set_elem_len(set, tb, 0);
+ 	if (!init_map_ip(set, map, first_ip, last_ip,
+ 			 elements, hosts, netmask)) {
+ 		kfree(map);
+ 		return -ENOMEM;
+ 	}
+ 	if (tb[IPSET_ATTR_TIMEOUT]) {
+ 		set->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
+ 		bitmap_ip_gc_init(set, bitmap_ip_gc);
++>>>>>>> 03c8b234e61a (netfilter: ipset: Generalize extensions support)
  	}
  	return 0;
  }
diff --cc net/netfilter/ipset/ip_set_bitmap_ipmac.c
index a041a2f15eb0,654a97bedfe9..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_ipmac.c
+++ b/net/netfilter/ipset/ip_set_bitmap_ipmac.c
@@@ -330,11 -297,11 +299,15 @@@ static boo
  init_map_ipmac(struct ip_set *set, struct bitmap_ipmac *map,
  	       u32 first_ip, u32 last_ip, u32 elements)
  {
++<<<<<<< HEAD
 +	map->members = ip_set_alloc((last_ip - first_ip + 1) * map->dsize);
++=======
+ 	map->members = ip_set_alloc(map->memsize);
++>>>>>>> 03c8b234e61a (netfilter: ipset: Generalize extensions support)
  	if (!map->members)
  		return false;
 -	if (set->dsize) {
 -		map->extensions = ip_set_alloc(set->dsize * elements);
 +	if (map->dsize) {
 +		map->extensions = ip_set_alloc(map->dsize * elements);
  		if (!map->extensions) {
  			kfree(map->members);
  			return false;
@@@ -352,10 -319,10 +325,10 @@@
  }
  
  static int
 -bitmap_ipmac_create(struct ip_set *set, struct nlattr *tb[],
 +bitmap_ipmac_create(struct net *net, struct ip_set *set, struct nlattr *tb[],
  		    u32 flags)
  {
- 	u32 first_ip = 0, last_ip = 0, cadt_flags = 0;
+ 	u32 first_ip = 0, last_ip = 0;
  	u64 elements;
  	struct bitmap_ipmac *map;
  	int ret;
@@@ -399,57 -366,15 +372,69 @@@
  
  	map->memsize = bitmap_bytes(0, elements - 1);
  	set->variant = &bitmap_ipmac;
++<<<<<<< HEAD
 +	if (tb[IPSET_ATTR_CADT_FLAGS])
 +		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
 +	if (cadt_flags & IPSET_FLAG_WITH_COUNTERS) {
 +		set->extensions |= IPSET_EXT_COUNTER;
 +		if (tb[IPSET_ATTR_TIMEOUT]) {
 +			map->dsize = sizeof(struct bitmap_ipmacct_elem);
 +			map->offset[IPSET_EXT_ID_TIMEOUT] =
 +				offsetof(struct bitmap_ipmacct_elem, timeout);
 +			map->offset[IPSET_EXT_ID_COUNTER] =
 +				offsetof(struct bitmap_ipmacct_elem, counter);
 +
 +			if (!init_map_ipmac(set, map, first_ip, last_ip,
 +					    elements)) {
 +				kfree(map);
 +				return -ENOMEM;
 +			}
 +			map->timeout = ip_set_timeout_uget(
 +				tb[IPSET_ATTR_TIMEOUT]);
 +			set->extensions |= IPSET_EXT_TIMEOUT;
 +			bitmap_ipmac_gc_init(set, bitmap_ipmac_gc);
 +		} else {
 +			map->dsize = sizeof(struct bitmap_ipmacc_elem);
 +			map->offset[IPSET_EXT_ID_COUNTER] =
 +				offsetof(struct bitmap_ipmacc_elem, counter);
 +
 +			if (!init_map_ipmac(set, map, first_ip, last_ip,
 +					    elements)) {
 +				kfree(map);
 +				return -ENOMEM;
 +			}
 +		}
 +	} else if (tb[IPSET_ATTR_TIMEOUT]) {
 +		map->dsize = sizeof(struct bitmap_ipmact_elem);
 +		map->offset[IPSET_EXT_ID_TIMEOUT] =
 +			offsetof(struct bitmap_ipmact_elem, timeout);
 +
 +		if (!init_map_ipmac(set, map, first_ip, last_ip, elements)) {
 +			kfree(map);
 +			return -ENOMEM;
 +		}
 +		map->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 +		set->extensions |= IPSET_EXT_TIMEOUT;
 +		bitmap_ipmac_gc_init(set, bitmap_ipmac_gc);
 +	} else {
 +		map->dsize = sizeof(struct bitmap_ipmac_elem);
 +
 +		if (!init_map_ipmac(set, map, first_ip, last_ip, elements)) {
 +			kfree(map);
 +			return -ENOMEM;
 +		}
 +		set->variant = &bitmap_ipmac;
++=======
+ 	set->dsize = ip_set_elem_len(set, tb,
+ 				     sizeof(struct bitmap_ipmac_elem));
+ 	if (!init_map_ipmac(set, map, first_ip, last_ip, elements)) {
+ 		kfree(map);
+ 		return -ENOMEM;
+ 	}
+ 	if (tb[IPSET_ATTR_TIMEOUT]) {
+ 		set->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
+ 		bitmap_ipmac_gc_init(set, bitmap_ipmac_gc);
++>>>>>>> 03c8b234e61a (netfilter: ipset: Generalize extensions support)
  	}
  	return 0;
  }
diff --cc net/netfilter/ipset/ip_set_bitmap_port.c
index b176a33294c3,1ef2f3186b80..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_port.c
+++ b/net/netfilter/ipset/ip_set_bitmap_port.c
@@@ -277,53 -254,14 +257,64 @@@ bitmap_port_create(struct net *net, str
  	map->elements = last_port - first_port + 1;
  	map->memsize = map->elements * sizeof(unsigned long);
  	set->variant = &bitmap_port;
++<<<<<<< HEAD
 +	if (tb[IPSET_ATTR_CADT_FLAGS])
 +		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
 +	if (cadt_flags & IPSET_FLAG_WITH_COUNTERS) {
 +		set->extensions |= IPSET_EXT_COUNTER;
 +		if (tb[IPSET_ATTR_TIMEOUT]) {
 +			map->dsize = sizeof(struct bitmap_portct_elem);
 +			map->offset[IPSET_EXT_ID_TIMEOUT] =
 +				offsetof(struct bitmap_portct_elem, timeout);
 +			map->offset[IPSET_EXT_ID_COUNTER] =
 +				offsetof(struct bitmap_portct_elem, counter);
 +			if (!init_map_port(set, map, first_port, last_port)) {
 +				kfree(map);
 +				return -ENOMEM;
 +			}
 +
 +			map->timeout =
 +				ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 +			set->extensions |= IPSET_EXT_TIMEOUT;
 +			bitmap_port_gc_init(set, bitmap_port_gc);
 +		} else {
 +			map->dsize = sizeof(struct bitmap_portc_elem);
 +			map->offset[IPSET_EXT_ID_COUNTER] =
 +				offsetof(struct bitmap_portc_elem, counter);
 +			if (!init_map_port(set, map, first_port, last_port)) {
 +				kfree(map);
 +				return -ENOMEM;
 +			}
 +		}
 +	} else if (tb[IPSET_ATTR_TIMEOUT]) {
 +		map->dsize = sizeof(struct bitmap_portt_elem);
 +		map->offset[IPSET_EXT_ID_TIMEOUT] =
 +			offsetof(struct bitmap_portt_elem, timeout);
 +		if (!init_map_port(set, map, first_port, last_port)) {
 +			kfree(map);
 +			return -ENOMEM;
 +		}
 +
 +		map->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 +		set->extensions |= IPSET_EXT_TIMEOUT;
 +		bitmap_port_gc_init(set, bitmap_port_gc);
 +	} else {
 +		map->dsize = 0;
 +		if (!init_map_port(set, map, first_port, last_port)) {
 +			kfree(map);
 +			return -ENOMEM;
 +		}
 +
++=======
+ 	set->dsize = ip_set_elem_len(set, tb, 0);
+ 	if (!init_map_port(set, map, first_port, last_port)) {
+ 		kfree(map);
+ 		return -ENOMEM;
+ 	}
+ 	if (tb[IPSET_ATTR_TIMEOUT]) {
+ 		set->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
+ 		bitmap_port_gc_init(set, bitmap_port_gc);
++>>>>>>> 03c8b234e61a (netfilter: ipset: Generalize extensions support)
  	}
  	return 0;
  }
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index acd02e6a3233,3999f1719f69..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -945,11 -957,9 +945,10 @@@ static const struct ip_set_type_varian
  
  #ifdef IP_SET_EMIT_CREATE
  static int
 -IPSET_TOKEN(HTYPE, _create)(struct ip_set *set, struct nlattr *tb[], u32 flags)
 +IPSET_TOKEN(HTYPE, _create)(struct net *net, struct ip_set *set,
 +			    struct nlattr *tb[], u32 flags)
  {
  	u32 hashsize = IPSET_DEFAULT_HASHSIZE, maxelem = IPSET_DEFAULT_MAXELEM;
- 	u32 cadt_flags = 0;
  	u8 hbits;
  #ifdef IP_SET_HASH_WITH_NETMASK
  	u8 netmask;
@@@ -1017,91 -1029,27 +1016,107 @@@
  		kfree(h);
  		return -ENOMEM;
  	}
 -	t->htable_bits = hbits;
 -	rcu_assign_pointer(h->table, t);
 +	h->table->htable_bits = hbits;
  
  	set->data = h;
- 	if (set->family ==  NFPROTO_IPV4)
+ 	if (set->family ==  NFPROTO_IPV4) {
  		set->variant = &IPSET_TOKEN(HTYPE, 4_variant);
- 	else
+ 		set->dsize = ip_set_elem_len(set, tb,
+ 				sizeof(struct IPSET_TOKEN(HTYPE, 4_elem)));
+ 	} else {
  		set->variant = &IPSET_TOKEN(HTYPE, 6_variant);
++<<<<<<< HEAD
 +
 +	if (tb[IPSET_ATTR_CADT_FLAGS])
 +		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
 +	if (cadt_flags & IPSET_FLAG_WITH_COUNTERS) {
 +		set->extensions |= IPSET_EXT_COUNTER;
 +		if (tb[IPSET_ATTR_TIMEOUT]) {
 +			h->timeout =
 +				ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 +			set->extensions |= IPSET_EXT_TIMEOUT;
 +			if (set->family == NFPROTO_IPV4) {
 +				h->dsize = sizeof(struct
 +					IPSET_TOKEN(HTYPE, 4ct_elem));
 +				h->offset[IPSET_EXT_ID_TIMEOUT] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 4ct_elem),
 +						timeout);
 +				h->offset[IPSET_EXT_ID_COUNTER] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 4ct_elem),
 +						counter);
 +				IPSET_TOKEN(HTYPE, 4_gc_init)(set,
 +					IPSET_TOKEN(HTYPE, 4_gc));
 +			} else {
 +				h->dsize = sizeof(struct
 +					IPSET_TOKEN(HTYPE, 6ct_elem));
 +				h->offset[IPSET_EXT_ID_TIMEOUT] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 6ct_elem),
 +						timeout);
 +				h->offset[IPSET_EXT_ID_COUNTER] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 6ct_elem),
 +						counter);
 +				IPSET_TOKEN(HTYPE, 6_gc_init)(set,
 +					IPSET_TOKEN(HTYPE, 6_gc));
 +			}
 +		} else {
 +			if (set->family == NFPROTO_IPV4) {
 +				h->dsize =
 +					sizeof(struct
 +						IPSET_TOKEN(HTYPE, 4c_elem));
 +				h->offset[IPSET_EXT_ID_COUNTER] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 4c_elem),
 +						counter);
 +			} else {
 +				h->dsize =
 +					sizeof(struct
 +						IPSET_TOKEN(HTYPE, 6c_elem));
 +				h->offset[IPSET_EXT_ID_COUNTER] =
 +					offsetof(struct
 +						IPSET_TOKEN(HTYPE, 6c_elem),
 +						counter);
 +			}
 +		}
 +	} else if (tb[IPSET_ATTR_TIMEOUT]) {
 +		h->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
 +		set->extensions |= IPSET_EXT_TIMEOUT;
 +		if (set->family == NFPROTO_IPV4) {
 +			h->dsize = sizeof(struct IPSET_TOKEN(HTYPE, 4t_elem));
 +			h->offset[IPSET_EXT_ID_TIMEOUT] =
 +				offsetof(struct IPSET_TOKEN(HTYPE, 4t_elem),
 +					 timeout);
 +			IPSET_TOKEN(HTYPE, 4_gc_init)(set,
 +				IPSET_TOKEN(HTYPE, 4_gc));
 +		} else {
 +			h->dsize = sizeof(struct IPSET_TOKEN(HTYPE, 6t_elem));
 +			h->offset[IPSET_EXT_ID_TIMEOUT] =
 +				offsetof(struct IPSET_TOKEN(HTYPE, 6t_elem),
 +					 timeout);
 +			IPSET_TOKEN(HTYPE, 6_gc_init)(set,
 +				IPSET_TOKEN(HTYPE, 6_gc));
 +		}
 +	} else {
 +		if (set->family == NFPROTO_IPV4)
 +			h->dsize = sizeof(struct IPSET_TOKEN(HTYPE, 4_elem));
 +		else
 +			h->dsize = sizeof(struct IPSET_TOKEN(HTYPE, 6_elem));
++=======
+ 		set->dsize = ip_set_elem_len(set, tb,
+ 				sizeof(struct IPSET_TOKEN(HTYPE, 6_elem)));
+ 	}
+ 	if (tb[IPSET_ATTR_TIMEOUT]) {
+ 		set->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
+ 		if (set->family == NFPROTO_IPV4)
+ 			IPSET_TOKEN(HTYPE, 4_gc_init)(set,
+ 				IPSET_TOKEN(HTYPE, 4_gc));
+ 		else
+ 			IPSET_TOKEN(HTYPE, 6_gc_init)(set,
+ 				IPSET_TOKEN(HTYPE, 6_gc));
++>>>>>>> 03c8b234e61a (netfilter: ipset: Generalize extensions support)
  	}
  
  	pr_debug("create %s hashsize %u (%u) maxelem %u: %p(%p)\n",
diff --cc net/netfilter/ipset/ip_set_list_set.c
index a9a97c07ecb4,7fd11c79aff4..000000000000
--- a/net/netfilter/ipset/ip_set_list_set.c
+++ b/net/netfilter/ipset/ip_set_list_set.c
@@@ -614,22 -578,18 +592,30 @@@ list_set_gc_init(struct ip_set *set, vo
  
  /* Create list:set type of sets */
  
++<<<<<<< HEAD
 +static struct list_set *
 +init_list_set(struct net *net, struct ip_set *set, u32 size, size_t dsize,
 +	      unsigned long timeout)
++=======
+ static bool
+ init_list_set(struct ip_set *set, u32 size)
++>>>>>>> 03c8b234e61a (netfilter: ipset: Generalize extensions support)
  {
  	struct list_set *map;
  	struct set_elem *e;
  	u32 i;
  
- 	map = kzalloc(sizeof(*map) + size * dsize, GFP_KERNEL);
+ 	map = kzalloc(sizeof(*map) + size * set->dsize, GFP_KERNEL);
  	if (!map)
- 		return NULL;
+ 		return false;
  
  	map->size = size;
++<<<<<<< HEAD
 +	map->dsize = dsize;
 +	map->timeout = timeout;
 +	map->net = net;
++=======
++>>>>>>> 03c8b234e61a (netfilter: ipset: Generalize extensions support)
  	set->data = map;
  
  	for (i = 0; i < size; i++) {
@@@ -641,12 -601,9 +627,10 @@@
  }
  
  static int
 -list_set_create(struct ip_set *set, struct nlattr *tb[], u32 flags)
 +list_set_create(struct net *net, struct ip_set *set, struct nlattr *tb[],
 +		u32 flags)
  {
- 	struct list_set *map;
- 	u32 size = IP_SET_LIST_DEFAULT_SIZE, cadt_flags = 0;
- 	unsigned long timeout = 0;
+ 	u32 size = IP_SET_LIST_DEFAULT_SIZE;
  
  	if (unlikely(!ip_set_optattr_netorder(tb, IPSET_ATTR_SIZE) ||
  		     !ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||
@@@ -658,45 -615,13 +642,50 @@@
  	if (size < IP_SET_LIST_MIN_SIZE)
  		size = IP_SET_LIST_MIN_SIZE;
  
- 	if (tb[IPSET_ATTR_CADT_FLAGS])
- 		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
- 	if (tb[IPSET_ATTR_TIMEOUT])
- 		timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
  	set->variant = &set_variant;
++<<<<<<< HEAD
 +	if (cadt_flags & IPSET_FLAG_WITH_COUNTERS) {
 +		set->extensions |= IPSET_EXT_COUNTER;
 +		if (tb[IPSET_ATTR_TIMEOUT]) {
 +			map = init_list_set(net, set, size,
 +					sizeof(struct setct_elem), timeout);
 +			if (!map)
 +				return -ENOMEM;
 +			set->extensions |= IPSET_EXT_TIMEOUT;
 +			map->offset[IPSET_EXT_ID_TIMEOUT] =
 +				offsetof(struct setct_elem, timeout);
 +			map->offset[IPSET_EXT_ID_COUNTER] =
 +				offsetof(struct setct_elem, counter);
 +			list_set_gc_init(set, list_set_gc);
 +		} else {
 +			map = init_list_set(net, set, size,
 +					    sizeof(struct setc_elem), 0);
 +			if (!map)
 +				return -ENOMEM;
 +			map->offset[IPSET_EXT_ID_COUNTER] =
 +				offsetof(struct setc_elem, counter);
 +		}
 +	} else if (tb[IPSET_ATTR_TIMEOUT]) {
 +		map = init_list_set(net, set, size,
 +				    sizeof(struct sett_elem), timeout);
 +		if (!map)
 +			return -ENOMEM;
 +		set->extensions |= IPSET_EXT_TIMEOUT;
 +		map->offset[IPSET_EXT_ID_TIMEOUT] =
 +			offsetof(struct sett_elem, timeout);
 +		list_set_gc_init(set, list_set_gc);
 +	} else {
 +		map = init_list_set(net, set, size, sizeof(struct set_elem), 0);
 +		if (!map)
 +			return -ENOMEM;
++=======
+ 	set->dsize = ip_set_elem_len(set, tb, sizeof(struct set_elem));
+ 	if (!init_list_set(set, size))
+ 		return -ENOMEM;
+ 	if (tb[IPSET_ATTR_TIMEOUT]) {
+ 		set->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);
+ 		list_set_gc_init(set, list_set_gc);
++>>>>>>> 03c8b234e61a (netfilter: ipset: Generalize extensions support)
  	}
  	return 0;
  }
diff --git a/include/linux/netfilter/ipset/ip_set.h b/include/linux/netfilter/ipset/ip_set.h
index 1309bde24e27..b529ba4a1bf4 100644
--- a/include/linux/netfilter/ipset/ip_set.h
+++ b/include/linux/netfilter/ipset/ip_set.h
@@ -66,6 +66,17 @@ enum ip_set_ext_id {
 	IPSET_EXT_ID_MAX,
 };
 
+/* Extension type */
+struct ip_set_ext_type {
+	enum ip_set_extension type;
+	enum ipset_cadt_flags flag;
+	/* Size and minimal alignment */
+	u8 len;
+	u8 align;
+};
+
+extern const struct ip_set_ext_type ip_set_extensions[];
+
 struct ip_set_ext {
 	u64 packets;
 	u64 bytes;
@@ -279,6 +290,8 @@ extern void *ip_set_alloc(size_t size);
 extern void ip_set_free(void *members);
 extern int ip_set_get_ipaddr4(struct nlattr *nla,  __be32 *ipaddr);
 extern int ip_set_get_ipaddr6(struct nlattr *nla, union nf_inet_addr *ipaddr);
+extern size_t ip_set_elem_len(struct ip_set *set, struct nlattr *tb[],
+			      size_t len);
 extern int ip_set_get_extensions(struct ip_set *set, struct nlattr *tb[],
 				 struct ip_set_ext *ext);
 
* Unmerged path net/netfilter/ipset/ip_set_bitmap_ip.c
* Unmerged path net/netfilter/ipset/ip_set_bitmap_ipmac.c
* Unmerged path net/netfilter/ipset/ip_set_bitmap_port.c
diff --git a/net/netfilter/ipset/ip_set_core.c b/net/netfilter/ipset/ip_set_core.c
index 99fcd252e259..8b90d46b0d08 100644
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@ -324,6 +324,52 @@ ip_set_get_ipaddr6(struct nlattr *nla, union nf_inet_addr *ipaddr)
 }
 EXPORT_SYMBOL_GPL(ip_set_get_ipaddr6);
 
+/* ipset data extension types, in size order */
+
+const struct ip_set_ext_type ip_set_extensions[] = {
+	[IPSET_EXT_ID_COUNTER] = {
+		.type	= IPSET_EXT_COUNTER,
+		.flag	= IPSET_FLAG_WITH_COUNTERS,
+		.len	= sizeof(struct ip_set_counter),
+		.align	= __alignof__(struct ip_set_counter),
+	},
+	[IPSET_EXT_ID_TIMEOUT] = {
+		.type	= IPSET_EXT_TIMEOUT,
+		.len	= sizeof(unsigned long),
+		.align	= __alignof__(unsigned long),
+	},
+};
+EXPORT_SYMBOL_GPL(ip_set_extensions);
+
+static inline bool
+add_extension(enum ip_set_ext_id id, u32 flags, struct nlattr *tb[])
+{
+	return ip_set_extensions[id].flag ?
+		(flags & ip_set_extensions[id].flag) :
+		!!tb[IPSET_ATTR_TIMEOUT];
+}
+
+size_t
+ip_set_elem_len(struct ip_set *set, struct nlattr *tb[], size_t len)
+{
+	enum ip_set_ext_id id;
+	size_t offset = 0;
+	u32 cadt_flags = 0;
+
+	if (tb[IPSET_ATTR_CADT_FLAGS])
+		cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);
+	for (id = 0; id < IPSET_EXT_ID_MAX; id++) {
+		if (!add_extension(id, cadt_flags, tb))
+			continue;
+		offset += ALIGN(len + offset, ip_set_extensions[id].align);
+		set->offset[id] = offset;
+		set->extensions |= ip_set_extensions[id].type;
+		offset += ip_set_extensions[id].len;
+	}
+	return len + offset;
+}
+EXPORT_SYMBOL_GPL(ip_set_elem_len);
+
 int
 ip_set_get_extensions(struct ip_set *set, struct nlattr *tb[],
 		      struct ip_set_ext *ext)
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
diff --git a/net/netfilter/ipset/ip_set_hash_ip.c b/net/netfilter/ipset/ip_set_hash_ip.c
index 260c9a80d8a5..fc5ea249539d 100644
--- a/net/netfilter/ipset/ip_set_hash_ip.c
+++ b/net/netfilter/ipset/ip_set_hash_ip.c
@@ -35,7 +35,7 @@ MODULE_ALIAS("ip_set_hash:ip");
 #define HTYPE		hash_ip
 #define IP_SET_HASH_WITH_NETMASK
 
-/* IPv4 variants */
+/* IPv4 variant */
 
 /* Member elements */
 struct hash_ip4_elem {
@@ -43,22 +43,6 @@ struct hash_ip4_elem {
 	__be32 ip;
 };
 
-struct hash_ip4t_elem {
-	__be32 ip;
-	unsigned long timeout;
-};
-
-struct hash_ip4c_elem {
-	__be32 ip;
-	struct ip_set_counter counter;
-};
-
-struct hash_ip4ct_elem {
-	__be32 ip;
-	struct ip_set_counter counter;
-	unsigned long timeout;
-};
-
 /* Common functions */
 
 static inline bool
@@ -178,29 +162,13 @@ hash_ip4_uadt(struct ip_set *set, struct nlattr *tb[],
 	return ret;
 }
 
-/* IPv6 variants */
+/* IPv6 variant */
 
 /* Member elements */
 struct hash_ip6_elem {
 	union nf_inet_addr ip;
 };
 
-struct hash_ip6t_elem {
-	union nf_inet_addr ip;
-	unsigned long timeout;
-};
-
-struct hash_ip6c_elem {
-	union nf_inet_addr ip;
-	struct ip_set_counter counter;
-};
-
-struct hash_ip6ct_elem {
-	union nf_inet_addr ip;
-	struct ip_set_counter counter;
-	unsigned long timeout;
-};
-
 /* Common functions */
 
 static inline bool
diff --git a/net/netfilter/ipset/ip_set_hash_ipport.c b/net/netfilter/ipset/ip_set_hash_ipport.c
index 64caad35a391..61d7d2372dcc 100644
--- a/net/netfilter/ipset/ip_set_hash_ipport.c
+++ b/net/netfilter/ipset/ip_set_hash_ipport.c
@@ -36,7 +36,7 @@ MODULE_ALIAS("ip_set_hash:ip,port");
 /* Type specific function prefix */
 #define HTYPE		hash_ipport
 
-/* IPv4 variants */
+/* IPv4 variant */
 
 /* Member elements */
 struct hash_ipport4_elem {
@@ -46,31 +46,6 @@ struct hash_ipport4_elem {
 	u8 padding;
 };
 
-struct hash_ipport4t_elem {
-	__be32 ip;
-	__be16 port;
-	u8 proto;
-	u8 padding;
-	unsigned long timeout;
-};
-
-struct hash_ipport4c_elem {
-	__be32 ip;
-	__be16 port;
-	u8 proto;
-	u8 padding;
-	struct ip_set_counter counter;
-};
-
-struct hash_ipport4ct_elem {
-	__be32 ip;
-	__be16 port;
-	u8 proto;
-	u8 padding;
-	struct ip_set_counter counter;
-	unsigned long timeout;
-};
-
 /* Common functions */
 
 static inline bool
@@ -222,7 +197,7 @@ hash_ipport4_uadt(struct ip_set *set, struct nlattr *tb[],
 	return ret;
 }
 
-/* IPv6 variants */
+/* IPv6 variant */
 
 struct hash_ipport6_elem {
 	union nf_inet_addr ip;
@@ -231,31 +206,6 @@ struct hash_ipport6_elem {
 	u8 padding;
 };
 
-struct hash_ipport6t_elem {
-	union nf_inet_addr ip;
-	__be16 port;
-	u8 proto;
-	u8 padding;
-	unsigned long timeout;
-};
-
-struct hash_ipport6c_elem {
-	union nf_inet_addr ip;
-	__be16 port;
-	u8 proto;
-	u8 padding;
-	struct ip_set_counter counter;
-};
-
-struct hash_ipport6ct_elem {
-	union nf_inet_addr ip;
-	__be16 port;
-	u8 proto;
-	u8 padding;
-	struct ip_set_counter counter;
-	unsigned long timeout;
-};
-
 /* Common functions */
 
 static inline bool
diff --git a/net/netfilter/ipset/ip_set_hash_ipportip.c b/net/netfilter/ipset/ip_set_hash_ipportip.c
index 2873bbc20d7a..7c4370694781 100644
--- a/net/netfilter/ipset/ip_set_hash_ipportip.c
+++ b/net/netfilter/ipset/ip_set_hash_ipportip.c
@@ -36,7 +36,7 @@ MODULE_ALIAS("ip_set_hash:ip,port,ip");
 /* Type specific function prefix */
 #define HTYPE		hash_ipportip
 
-/* IPv4 variants */
+/* IPv4 variant */
 
 /* Member elements  */
 struct hash_ipportip4_elem {
@@ -47,34 +47,6 @@ struct hash_ipportip4_elem {
 	u8 padding;
 };
 
-struct hash_ipportip4t_elem {
-	__be32 ip;
-	__be32 ip2;
-	__be16 port;
-	u8 proto;
-	u8 padding;
-	unsigned long timeout;
-};
-
-struct hash_ipportip4c_elem {
-	__be32 ip;
-	__be32 ip2;
-	__be16 port;
-	u8 proto;
-	u8 padding;
-	struct ip_set_counter counter;
-};
-
-struct hash_ipportip4ct_elem {
-	__be32 ip;
-	__be32 ip2;
-	__be16 port;
-	u8 proto;
-	u8 padding;
-	struct ip_set_counter counter;
-	unsigned long timeout;
-};
-
 static inline bool
 hash_ipportip4_data_equal(const struct hash_ipportip4_elem *ip1,
 			  const struct hash_ipportip4_elem *ip2,
@@ -231,7 +203,7 @@ hash_ipportip4_uadt(struct ip_set *set, struct nlattr *tb[],
 	return ret;
 }
 
-/* IPv6 variants */
+/* IPv6 variant */
 
 struct hash_ipportip6_elem {
 	union nf_inet_addr ip;
@@ -241,34 +213,6 @@ struct hash_ipportip6_elem {
 	u8 padding;
 };
 
-struct hash_ipportip6t_elem {
-	union nf_inet_addr ip;
-	union nf_inet_addr ip2;
-	__be16 port;
-	u8 proto;
-	u8 padding;
-	unsigned long timeout;
-};
-
-struct hash_ipportip6c_elem {
-	union nf_inet_addr ip;
-	union nf_inet_addr ip2;
-	__be16 port;
-	u8 proto;
-	u8 padding;
-	struct ip_set_counter counter;
-};
-
-struct hash_ipportip6ct_elem {
-	union nf_inet_addr ip;
-	union nf_inet_addr ip2;
-	__be16 port;
-	u8 proto;
-	u8 padding;
-	struct ip_set_counter counter;
-	unsigned long timeout;
-};
-
 /* Common functions */
 
 static inline bool
diff --git a/net/netfilter/ipset/ip_set_hash_ipportnet.c b/net/netfilter/ipset/ip_set_hash_ipportnet.c
index f111558c4597..12dbb2bb8bfb 100644
--- a/net/netfilter/ipset/ip_set_hash_ipportnet.c
+++ b/net/netfilter/ipset/ip_set_hash_ipportnet.c
@@ -46,7 +46,7 @@ MODULE_ALIAS("ip_set_hash:ip,port,net");
 #define IP_SET_HASH_WITH_PROTO
 #define IP_SET_HASH_WITH_NETS
 
-/* IPv4 variants */
+/* IPv4 variant */
 
 /* Member elements */
 struct hash_ipportnet4_elem {
@@ -58,37 +58,6 @@ struct hash_ipportnet4_elem {
 	u8 proto;
 };
 
-struct hash_ipportnet4t_elem {
-	__be32 ip;
-	__be32 ip2;
-	__be16 port;
-	u8 cidr:7;
-	u8 nomatch:1;
-	u8 proto;
-	unsigned long timeout;
-};
-
-struct hash_ipportnet4c_elem {
-	__be32 ip;
-	__be32 ip2;
-	__be16 port;
-	u8 cidr:7;
-	u8 nomatch:1;
-	u8 proto;
-	struct ip_set_counter counter;
-};
-
-struct hash_ipportnet4ct_elem {
-	__be32 ip;
-	__be32 ip2;
-	__be16 port;
-	u8 cidr:7;
-	u8 nomatch:1;
-	u8 proto;
-	struct ip_set_counter counter;
-	unsigned long timeout;
-};
-
 /* Common functions */
 
 static inline bool
@@ -328,7 +297,7 @@ hash_ipportnet4_uadt(struct ip_set *set, struct nlattr *tb[],
 	return ret;
 }
 
-/* IPv6 variants */
+/* IPv6 variant */
 
 struct hash_ipportnet6_elem {
 	union nf_inet_addr ip;
@@ -339,37 +308,6 @@ struct hash_ipportnet6_elem {
 	u8 proto;
 };
 
-struct hash_ipportnet6t_elem {
-	union nf_inet_addr ip;
-	union nf_inet_addr ip2;
-	__be16 port;
-	u8 cidr:7;
-	u8 nomatch:1;
-	u8 proto;
-	unsigned long timeout;
-};
-
-struct hash_ipportnet6c_elem {
-	union nf_inet_addr ip;
-	union nf_inet_addr ip2;
-	__be16 port;
-	u8 cidr:7;
-	u8 nomatch:1;
-	u8 proto;
-	struct ip_set_counter counter;
-};
-
-struct hash_ipportnet6ct_elem {
-	union nf_inet_addr ip;
-	union nf_inet_addr ip2;
-	__be16 port;
-	u8 cidr:7;
-	u8 nomatch:1;
-	u8 proto;
-	struct ip_set_counter counter;
-	unsigned long timeout;
-};
-
 /* Common functions */
 
 static inline bool
diff --git a/net/netfilter/ipset/ip_set_hash_net.c b/net/netfilter/ipset/ip_set_hash_net.c
index 0a64dad156d9..ad50b440cd93 100644
--- a/net/netfilter/ipset/ip_set_hash_net.c
+++ b/net/netfilter/ipset/ip_set_hash_net.c
@@ -36,7 +36,7 @@ MODULE_ALIAS("ip_set_hash:net");
 #define HTYPE		hash_net
 #define IP_SET_HASH_WITH_NETS
 
-/* IPv4 variants */
+/* IPv4 variant */
 
 /* Member elements  */
 struct hash_net4_elem {
@@ -46,31 +46,6 @@ struct hash_net4_elem {
 	u8 cidr;
 };
 
-struct hash_net4t_elem {
-	__be32 ip;
-	u16 padding0;
-	u8 nomatch;
-	u8 cidr;
-	unsigned long timeout;
-};
-
-struct hash_net4c_elem {
-	__be32 ip;
-	u16 padding0;
-	u8 nomatch;
-	u8 cidr;
-	struct ip_set_counter counter;
-};
-
-struct hash_net4ct_elem {
-	__be32 ip;
-	u16 padding0;
-	u8 nomatch;
-	u8 cidr;
-	struct ip_set_counter counter;
-	unsigned long timeout;
-};
-
 /* Common functions */
 
 static inline bool
@@ -228,7 +203,7 @@ hash_net4_uadt(struct ip_set *set, struct nlattr *tb[],
 	return ret;
 }
 
-/* IPv6 variants */
+/* IPv6 variant */
 
 struct hash_net6_elem {
 	union nf_inet_addr ip;
@@ -237,31 +212,6 @@ struct hash_net6_elem {
 	u8 cidr;
 };
 
-struct hash_net6t_elem {
-	union nf_inet_addr ip;
-	u16 padding0;
-	u8 nomatch;
-	u8 cidr;
-	unsigned long timeout;
-};
-
-struct hash_net6c_elem {
-	union nf_inet_addr ip;
-	u16 padding0;
-	u8 nomatch;
-	u8 cidr;
-	struct ip_set_counter counter;
-};
-
-struct hash_net6ct_elem {
-	union nf_inet_addr ip;
-	u16 padding0;
-	u8 nomatch;
-	u8 cidr;
-	struct ip_set_counter counter;
-	unsigned long timeout;
-};
-
 /* Common functions */
 
 static inline bool
diff --git a/net/netfilter/ipset/ip_set_hash_netiface.c b/net/netfilter/ipset/ip_set_hash_netiface.c
index 8bdeb0791689..3f5e8911397c 100644
--- a/net/netfilter/ipset/ip_set_hash_netiface.c
+++ b/net/netfilter/ipset/ip_set_hash_netiface.c
@@ -135,7 +135,7 @@ iface_add(struct rb_root *root, const char **iface)
 
 #define STREQ(a, b)	(strcmp(a, b) == 0)
 
-/* IPv4 variants */
+/* IPv4 variant */
 
 struct hash_netiface4_elem_hashed {
 	__be32 ip;
@@ -145,7 +145,7 @@ struct hash_netiface4_elem_hashed {
 	u8 elem;
 };
 
-/* Member elements without timeout */
+/* Member elements */
 struct hash_netiface4_elem {
 	__be32 ip;
 	u8 physdev;
@@ -155,37 +155,6 @@ struct hash_netiface4_elem {
 	const char *iface;
 };
 
-struct hash_netiface4t_elem {
-	__be32 ip;
-	u8 physdev;
-	u8 cidr;
-	u8 nomatch;
-	u8 elem;
-	const char *iface;
-	unsigned long timeout;
-};
-
-struct hash_netiface4c_elem {
-	__be32 ip;
-	u8 physdev;
-	u8 cidr;
-	u8 nomatch;
-	u8 elem;
-	const char *iface;
-	struct ip_set_counter counter;
-};
-
-struct hash_netiface4ct_elem {
-	__be32 ip;
-	u8 physdev;
-	u8 cidr;
-	u8 nomatch;
-	u8 elem;
-	const char *iface;
-	struct ip_set_counter counter;
-	unsigned long timeout;
-};
-
 /* Common functions */
 
 static inline bool
@@ -415,7 +384,7 @@ hash_netiface4_uadt(struct ip_set *set, struct nlattr *tb[],
 	return ret;
 }
 
-/* IPv6 variants */
+/* IPv6 variant */
 
 struct hash_netiface6_elem_hashed {
 	union nf_inet_addr ip;
@@ -434,37 +403,6 @@ struct hash_netiface6_elem {
 	const char *iface;
 };
 
-struct hash_netiface6t_elem {
-	union nf_inet_addr ip;
-	u8 physdev;
-	u8 cidr;
-	u8 nomatch;
-	u8 elem;
-	const char *iface;
-	unsigned long timeout;
-};
-
-struct hash_netiface6c_elem {
-	union nf_inet_addr ip;
-	u8 physdev;
-	u8 cidr;
-	u8 nomatch;
-	u8 elem;
-	const char *iface;
-	struct ip_set_counter counter;
-};
-
-struct hash_netiface6ct_elem {
-	union nf_inet_addr ip;
-	u8 physdev;
-	u8 cidr;
-	u8 nomatch;
-	u8 elem;
-	const char *iface;
-	struct ip_set_counter counter;
-	unsigned long timeout;
-};
-
 /* Common functions */
 
 static inline bool
diff --git a/net/netfilter/ipset/ip_set_hash_netport.c b/net/netfilter/ipset/ip_set_hash_netport.c
index d98a685cd916..6c2531266aa1 100644
--- a/net/netfilter/ipset/ip_set_hash_netport.c
+++ b/net/netfilter/ipset/ip_set_hash_netport.c
@@ -45,7 +45,7 @@ MODULE_ALIAS("ip_set_hash:net,port");
  */
 #define IP_SET_HASH_WITH_NETS_PACKED
 
-/* IPv4 variants */
+/* IPv4 variant */
 
 /* Member elements */
 struct hash_netport4_elem {
@@ -56,34 +56,6 @@ struct hash_netport4_elem {
 	u8 nomatch:1;
 };
 
-struct hash_netport4t_elem {
-	__be32 ip;
-	__be16 port;
-	u8 proto;
-	u8 cidr:7;
-	u8 nomatch:1;
-	unsigned long timeout;
-};
-
-struct hash_netport4c_elem {
-	__be32 ip;
-	__be16 port;
-	u8 proto;
-	u8 cidr:7;
-	u8 nomatch:1;
-	struct ip_set_counter counter;
-};
-
-struct hash_netport4ct_elem {
-	__be32 ip;
-	__be16 port;
-	u8 proto;
-	u8 cidr:7;
-	u8 nomatch:1;
-	struct ip_set_counter counter;
-	unsigned long timeout;
-};
-
 /* Common functions */
 
 static inline bool
@@ -287,7 +259,7 @@ hash_netport4_uadt(struct ip_set *set, struct nlattr *tb[],
 	return ret;
 }
 
-/* IPv6 variants */
+/* IPv6 variant */
 
 struct hash_netport6_elem {
 	union nf_inet_addr ip;
@@ -297,34 +269,6 @@ struct hash_netport6_elem {
 	u8 nomatch:1;
 };
 
-struct hash_netport6t_elem {
-	union nf_inet_addr ip;
-	__be16 port;
-	u8 proto;
-	u8 cidr:7;
-	u8 nomatch:1;
-	unsigned long timeout;
-};
-
-struct hash_netport6c_elem {
-	union nf_inet_addr ip;
-	__be16 port;
-	u8 proto;
-	u8 cidr:7;
-	u8 nomatch:1;
-	struct ip_set_counter counter;
-};
-
-struct hash_netport6ct_elem {
-	union nf_inet_addr ip;
-	__be16 port;
-	u8 proto;
-	u8 cidr:7;
-	u8 nomatch:1;
-	struct ip_set_counter counter;
-	unsigned long timeout;
-};
-
 /* Common functions */
 
 static inline bool
* Unmerged path net/netfilter/ipset/ip_set_list_set.c
