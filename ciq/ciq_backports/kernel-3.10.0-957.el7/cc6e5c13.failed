mlxsw: spectrum: qdiscs: Update backlog handling of a child qdiscs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Nogah Frankel <nogahf@mellanox.com>
commit cc6e5c13af8b592cfed49f4854eddddbb58c6949
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/cc6e5c13.failed

When removing a child qdisc its backlog will be decreased from the parent
backlog. The driver backlog count should do the same.
When the parent changes its configuration, the child might need to clean
its stats. However, the backlog can't be cleaned with the rest of the
stats, because it reflects a momentary value that needs to be synced with
the core, not the history of the qdisc.

	Signed-off-by: Nogah Frankel <nogahf@mellanox.com>
	Reviewed-by: Yuval Mintz <yuvalm@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cc6e5c13af8b592cfed49f4854eddddbb58c6949)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
index b5397da94d7f,5ddaafc8aa18..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
@@@ -111,20 -291,17 +111,31 @@@ mlxsw_sp_setup_tc_qdisc_clean_stats(str
  }
  
  static int
 -mlxsw_sp_qdisc_red_destroy(struct mlxsw_sp_port *mlxsw_sp_port,
 -			   struct mlxsw_sp_qdisc *mlxsw_sp_qdisc)
 +mlxsw_sp_qdisc_red_destroy(struct mlxsw_sp_port *mlxsw_sp_port, u32 handle,
 +			   struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
 +			   int tclass_num)
  {
++<<<<<<< HEAD
 +	int err;
 +
 +	if (mlxsw_sp_qdisc->handle != handle)
 +		return 0;
 +
 +	err = mlxsw_sp_tclass_congestion_disable(mlxsw_sp_port, tclass_num);
 +	mlxsw_sp_qdisc->handle = TC_H_UNSPEC;
 +	mlxsw_sp_qdisc->type = MLXSW_SP_QDISC_NO_QDISC;
 +
 +	return err;
++=======
+ 	struct mlxsw_sp_qdisc *root_qdisc = mlxsw_sp_port->root_qdisc;
+ 
+ 	if (root_qdisc != mlxsw_sp_qdisc)
+ 		root_qdisc->stats_base.backlog -=
+ 					mlxsw_sp_qdisc->stats_base.backlog;
+ 
+ 	return mlxsw_sp_tclass_congestion_disable(mlxsw_sp_port,
+ 						  mlxsw_sp_qdisc->tclass_num);
++>>>>>>> cc6e5c13af8b (mlxsw: spectrum: qdiscs: Update backlog handling of a child qdiscs)
  }
  
  static int
@@@ -162,26 -349,22 +173,33 @@@ mlxsw_sp_qdisc_red_replace(struct mlxsw
  	prob = DIV_ROUND_UP(prob, 1 << 16);
  	min = mlxsw_sp_bytes_cells(mlxsw_sp, p->min);
  	max = mlxsw_sp_bytes_cells(mlxsw_sp, p->max);
 -	return mlxsw_sp_tclass_congestion_enable(mlxsw_sp_port, tclass_num, min,
 -						 max, prob, p->is_ecn);
 -}
 +	err = mlxsw_sp_tclass_congestion_enable(mlxsw_sp_port, tclass_num, min,
 +						max, prob, p->is_ecn);
 +	if (err)
 +		goto err_config;
  
 -static void
 -mlxsw_sp_qdisc_red_unoffload(struct mlxsw_sp_port *mlxsw_sp_port,
 -			     struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
 -			     void *params)
 -{
 -	struct tc_red_qopt_offload_params *p = params;
 -	u64 backlog;
 +	mlxsw_sp_qdisc->type = MLXSW_SP_QDISC_RED;
 +	if (mlxsw_sp_qdisc->handle != handle)
 +		mlxsw_sp_setup_tc_qdisc_clean_stats(mlxsw_sp_port,
 +						    mlxsw_sp_qdisc,
 +						    tclass_num);
  
++<<<<<<< HEAD
 +	mlxsw_sp_qdisc->handle = handle;
 +	return 0;
 +
 +err_bad_param:
 +	err = -EINVAL;
 +err_config:
 +	mlxsw_sp_qdisc_red_destroy(mlxsw_sp_port, mlxsw_sp_qdisc->handle,
 +				   mlxsw_sp_qdisc, tclass_num);
 +	return err;
++=======
+ 	backlog = mlxsw_sp_cells_bytes(mlxsw_sp_port->mlxsw_sp,
+ 				       mlxsw_sp_qdisc->stats_base.backlog);
+ 	p->qstats->backlog -= backlog;
+ 	mlxsw_sp_qdisc->stats_base.backlog = 0;
++>>>>>>> cc6e5c13af8b (mlxsw: spectrum: qdiscs: Update backlog handling of a child qdiscs)
  }
  
  static int
@@@ -275,3 -481,222 +293,225 @@@ int mlxsw_sp_setup_tc_red(struct mlxsw_
  		return -EOPNOTSUPP;
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ static int
+ mlxsw_sp_qdisc_prio_destroy(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			    struct mlxsw_sp_qdisc *mlxsw_sp_qdisc)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+ 		mlxsw_sp_port_prio_tc_set(mlxsw_sp_port, i,
+ 					  MLXSW_SP_PORT_DEFAULT_TCLASS);
+ 		mlxsw_sp_qdisc_destroy(mlxsw_sp_port,
+ 				       &mlxsw_sp_port->tclass_qdiscs[i]);
+ 		mlxsw_sp_port->tclass_qdiscs[i].prio_bitmap = 0;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_prio_check_params(struct mlxsw_sp_port *mlxsw_sp_port,
+ 				 struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 				 void *params)
+ {
+ 	struct tc_prio_qopt_offload_params *p = params;
+ 
+ 	if (p->bands > IEEE_8021QAZ_MAX_TCS)
+ 		return -EOPNOTSUPP;
+ 
+ 	return 0;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_prio_replace(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			    struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			    void *params)
+ {
+ 	struct tc_prio_qopt_offload_params *p = params;
+ 	struct mlxsw_sp_qdisc *child_qdisc;
+ 	int tclass, i, band, backlog;
+ 	u8 old_priomap;
+ 	int err;
+ 
+ 	for (band = 0; band < p->bands; band++) {
+ 		tclass = MLXSW_SP_PRIO_BAND_TO_TCLASS(band);
+ 		child_qdisc = &mlxsw_sp_port->tclass_qdiscs[tclass];
+ 		old_priomap = child_qdisc->prio_bitmap;
+ 		child_qdisc->prio_bitmap = 0;
+ 		for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+ 			if (p->priomap[i] == band) {
+ 				child_qdisc->prio_bitmap |= BIT(i);
+ 				if (BIT(i) & old_priomap)
+ 					continue;
+ 				err = mlxsw_sp_port_prio_tc_set(mlxsw_sp_port,
+ 								i, tclass);
+ 				if (err)
+ 					return err;
+ 			}
+ 		}
+ 		if (old_priomap != child_qdisc->prio_bitmap &&
+ 		    child_qdisc->ops && child_qdisc->ops->clean_stats) {
+ 			backlog = child_qdisc->stats_base.backlog;
+ 			child_qdisc->ops->clean_stats(mlxsw_sp_port,
+ 						      child_qdisc);
+ 			child_qdisc->stats_base.backlog = backlog;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void
+ mlxsw_sp_qdisc_prio_unoffload(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			      struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			      void *params)
+ {
+ 	struct tc_prio_qopt_offload_params *p = params;
+ 	u64 backlog;
+ 
+ 	backlog = mlxsw_sp_cells_bytes(mlxsw_sp_port->mlxsw_sp,
+ 				       mlxsw_sp_qdisc->stats_base.backlog);
+ 	p->qstats->backlog -= backlog;
+ }
+ 
+ static int
+ mlxsw_sp_qdisc_get_prio_stats(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			      struct mlxsw_sp_qdisc *mlxsw_sp_qdisc,
+ 			      struct tc_qopt_offload_stats *stats_ptr)
+ {
+ 	u64 tx_bytes, tx_packets, drops = 0, backlog = 0;
+ 	struct mlxsw_sp_qdisc_stats *stats_base;
+ 	struct mlxsw_sp_port_xstats *xstats;
+ 	struct rtnl_link_stats64 *stats;
+ 	int i;
+ 
+ 	xstats = &mlxsw_sp_port->periodic_hw_stats.xstats;
+ 	stats = &mlxsw_sp_port->periodic_hw_stats.stats;
+ 	stats_base = &mlxsw_sp_qdisc->stats_base;
+ 
+ 	tx_bytes = stats->tx_bytes - stats_base->tx_bytes;
+ 	tx_packets = stats->tx_packets - stats_base->tx_packets;
+ 
+ 	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+ 		drops += xstats->tail_drop[i];
+ 		backlog += xstats->backlog[i];
+ 	}
+ 	drops = drops - stats_base->drops;
+ 
+ 	_bstats_update(stats_ptr->bstats, tx_bytes, tx_packets);
+ 	stats_ptr->qstats->drops += drops;
+ 	stats_ptr->qstats->backlog +=
+ 				mlxsw_sp_cells_bytes(mlxsw_sp_port->mlxsw_sp,
+ 						     backlog) -
+ 				mlxsw_sp_cells_bytes(mlxsw_sp_port->mlxsw_sp,
+ 						     stats_base->backlog);
+ 	stats_base->backlog = backlog;
+ 	stats_base->drops += drops;
+ 	stats_base->tx_bytes += tx_bytes;
+ 	stats_base->tx_packets += tx_packets;
+ 	return 0;
+ }
+ 
+ static void
+ mlxsw_sp_setup_tc_qdisc_prio_clean_stats(struct mlxsw_sp_port *mlxsw_sp_port,
+ 					 struct mlxsw_sp_qdisc *mlxsw_sp_qdisc)
+ {
+ 	struct mlxsw_sp_qdisc_stats *stats_base;
+ 	struct mlxsw_sp_port_xstats *xstats;
+ 	struct rtnl_link_stats64 *stats;
+ 	int i;
+ 
+ 	xstats = &mlxsw_sp_port->periodic_hw_stats.xstats;
+ 	stats = &mlxsw_sp_port->periodic_hw_stats.stats;
+ 	stats_base = &mlxsw_sp_qdisc->stats_base;
+ 
+ 	stats_base->tx_packets = stats->tx_packets;
+ 	stats_base->tx_bytes = stats->tx_bytes;
+ 
+ 	stats_base->drops = 0;
+ 	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)
+ 		stats_base->drops += xstats->tail_drop[i];
+ 
+ 	mlxsw_sp_qdisc->stats_base.backlog = 0;
+ }
+ 
+ static struct mlxsw_sp_qdisc_ops mlxsw_sp_qdisc_ops_prio = {
+ 	.type = MLXSW_SP_QDISC_PRIO,
+ 	.check_params = mlxsw_sp_qdisc_prio_check_params,
+ 	.replace = mlxsw_sp_qdisc_prio_replace,
+ 	.unoffload = mlxsw_sp_qdisc_prio_unoffload,
+ 	.destroy = mlxsw_sp_qdisc_prio_destroy,
+ 	.get_stats = mlxsw_sp_qdisc_get_prio_stats,
+ 	.clean_stats = mlxsw_sp_setup_tc_qdisc_prio_clean_stats,
+ };
+ 
+ int mlxsw_sp_setup_tc_prio(struct mlxsw_sp_port *mlxsw_sp_port,
+ 			   struct tc_prio_qopt_offload *p)
+ {
+ 	struct mlxsw_sp_qdisc *mlxsw_sp_qdisc;
+ 
+ 	mlxsw_sp_qdisc = mlxsw_sp_qdisc_find(mlxsw_sp_port, p->parent, true);
+ 	if (!mlxsw_sp_qdisc)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (p->command == TC_PRIO_REPLACE)
+ 		return mlxsw_sp_qdisc_replace(mlxsw_sp_port, p->handle,
+ 					      mlxsw_sp_qdisc,
+ 					      &mlxsw_sp_qdisc_ops_prio,
+ 					      &p->replace_params);
+ 
+ 	if (!mlxsw_sp_qdisc_compare(mlxsw_sp_qdisc, p->handle,
+ 				    MLXSW_SP_QDISC_PRIO))
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (p->command) {
+ 	case TC_PRIO_DESTROY:
+ 		return mlxsw_sp_qdisc_destroy(mlxsw_sp_port, mlxsw_sp_qdisc);
+ 	case TC_PRIO_STATS:
+ 		return mlxsw_sp_qdisc_get_stats(mlxsw_sp_port, mlxsw_sp_qdisc,
+ 						&p->stats);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ int mlxsw_sp_tc_qdisc_init(struct mlxsw_sp_port *mlxsw_sp_port)
+ {
+ 	struct mlxsw_sp_qdisc *mlxsw_sp_qdisc;
+ 	int i;
+ 
+ 	mlxsw_sp_qdisc = kzalloc(sizeof(*mlxsw_sp_qdisc), GFP_KERNEL);
+ 	if (!mlxsw_sp_qdisc)
+ 		goto err_root_qdisc_init;
+ 
+ 	mlxsw_sp_port->root_qdisc = mlxsw_sp_qdisc;
+ 	mlxsw_sp_port->root_qdisc->prio_bitmap = 0xff;
+ 	mlxsw_sp_port->root_qdisc->tclass_num = MLXSW_SP_PORT_DEFAULT_TCLASS;
+ 
+ 	mlxsw_sp_qdisc = kzalloc(sizeof(*mlxsw_sp_qdisc) * IEEE_8021QAZ_MAX_TCS,
+ 				 GFP_KERNEL);
+ 	if (!mlxsw_sp_qdisc)
+ 		goto err_tclass_qdiscs_init;
+ 
+ 	mlxsw_sp_port->tclass_qdiscs = mlxsw_sp_qdisc;
+ 	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)
+ 		mlxsw_sp_port->tclass_qdiscs[i].tclass_num = i;
+ 
+ 	return 0;
+ 
+ err_tclass_qdiscs_init:
+ 	kfree(mlxsw_sp_port->root_qdisc);
+ err_root_qdisc_init:
+ 	return -ENOMEM;
+ }
+ 
+ void mlxsw_sp_tc_qdisc_fini(struct mlxsw_sp_port *mlxsw_sp_port)
+ {
+ 	kfree(mlxsw_sp_port->tclass_qdiscs);
+ 	kfree(mlxsw_sp_port->root_qdisc);
+ }
++>>>>>>> cc6e5c13af8b (mlxsw: spectrum: qdiscs: Update backlog handling of a child qdiscs)
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
