netfilter: mark expected switch fall-throughs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Gustavo A. R. Silva <garsilva@embeddedor.com>
commit e8542dcec002b31339f7771441fd5dffb42223ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/e8542dce.failed

In preparation to enabling -Wimplicit-fallthrough, mark switch cases
where we are expecting to fall through.

	Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
	Signed-off-by: Simon Horman <horms@verge.net.au>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit e8542dcec002b31339f7771441fd5dffb42223ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_core.c
diff --cc net/netfilter/ipset/ip_set_core.c
index 8f5256a53627,d5a43cad90f0..000000000000
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@@ -1269,12 -1384,14 +1269,18 @@@ dump_last
  				goto release_refcount;
  			if (dump_flags & IPSET_FLAG_LIST_HEADER)
  				goto next_set;
++<<<<<<< HEAD
 +			/* Fall through and add elements */
++=======
+ 			if (set->variant->uref)
+ 				set->variant->uref(set, cb, true);
+ 			/* fall through */
++>>>>>>> e8542dcec002 (netfilter: mark expected switch fall-throughs)
  		default:
 -			rcu_read_lock_bh();
 +			read_lock_bh(&set->lock);
  			ret = set->variant->list(set, skb, cb);
 -			rcu_read_unlock_bh();
 -			if (!cb->args[IPSET_CB_ARG0])
 +			read_unlock_bh(&set->lock);
 +			if (!cb->args[2])
  				/* Set is done, proceed with next one */
  				goto next_set;
  			goto release_refcount;
* Unmerged path net/netfilter/ipset/ip_set_core.c
diff --git a/net/netfilter/ipvs/ip_vs_proto_tcp.c b/net/netfilter/ipvs/ip_vs_proto_tcp.c
index 50a15944c6c1..41378c9b4b4e 100644
--- a/net/netfilter/ipvs/ip_vs_proto_tcp.c
+++ b/net/netfilter/ipvs/ip_vs_proto_tcp.c
@@ -297,6 +297,7 @@ tcp_csum_check(int af, struct sk_buff *skb, struct ip_vs_protocol *pp)
 	switch (skb->ip_summed) {
 	case CHECKSUM_NONE:
 		skb->csum = skb_checksum(skb, tcphoff, skb->len - tcphoff, 0);
+		/* fall through */
 	case CHECKSUM_COMPLETE:
 #ifdef CONFIG_IP_VS_IPV6
 		if (af == AF_INET6) {
diff --git a/net/netfilter/ipvs/ip_vs_proto_udp.c b/net/netfilter/ipvs/ip_vs_proto_udp.c
index b62a3c0ff9bf..b65d50b37e36 100644
--- a/net/netfilter/ipvs/ip_vs_proto_udp.c
+++ b/net/netfilter/ipvs/ip_vs_proto_udp.c
@@ -309,6 +309,7 @@ udp_csum_check(int af, struct sk_buff *skb, struct ip_vs_protocol *pp)
 		case CHECKSUM_NONE:
 			skb->csum = skb_checksum(skb, udphoff,
 						 skb->len - udphoff, 0);
+			/* fall through */
 		case CHECKSUM_COMPLETE:
 #ifdef CONFIG_IP_VS_IPV6
 			if (af == AF_INET6) {
diff --git a/net/netfilter/nf_conntrack_h323_asn1.c b/net/netfilter/nf_conntrack_h323_asn1.c
index bcd5ed6b7130..80cb4092b26f 100644
--- a/net/netfilter/nf_conntrack_h323_asn1.c
+++ b/net/netfilter/nf_conntrack_h323_asn1.c
@@ -250,12 +250,15 @@ static unsigned int get_uint(bitstr_t *bs, int b)
 	case 4:
 		v |= *bs->cur++;
 		v <<= 8;
+		/* fall through */
 	case 3:
 		v |= *bs->cur++;
 		v <<= 8;
+		/* fall through */
 	case 2:
 		v |= *bs->cur++;
 		v <<= 8;
+		/* fall through */
 	case 1:
 		v |= *bs->cur++;
 		break;
diff --git a/net/netfilter/nft_cmp.c b/net/netfilter/nft_cmp.c
index 2b96effeadc1..31e1aaef3ff0 100644
--- a/net/netfilter/nft_cmp.c
+++ b/net/netfilter/nft_cmp.c
@@ -44,6 +44,7 @@ static void nft_cmp_eval(const struct nft_expr *expr,
 	case NFT_CMP_LT:
 		if (d == 0)
 			goto mismatch;
+		/* fall through */
 	case NFT_CMP_LTE:
 		if (d > 0)
 			goto mismatch;
@@ -51,6 +52,7 @@ static void nft_cmp_eval(const struct nft_expr *expr,
 	case NFT_CMP_GT:
 		if (d == 0)
 			goto mismatch;
+		/* fall through */
 	case NFT_CMP_GTE:
 		if (d < 0)
 			goto mismatch;
diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c
index aba72ac7a97f..29c6de7aa902 100644
--- a/net/netfilter/x_tables.c
+++ b/net/netfilter/x_tables.c
@@ -1331,7 +1331,7 @@ static void *xt_mttg_seq_next(struct seq_file *seq, void *v, loff_t *ppos,
 		trav->curr = trav->curr->next;
 		if (trav->curr != trav->head)
 			break;
-		/* fallthru, _stop will unlock */
+		/* fall through */
 	default:
 		return NULL;
 	}
