liquidio: Moved common function setup_glists to lio_core.c

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Intiyaz Basha <intiyaz.basha@cavium.com>
commit 128ea39439341d4f60bda1740a59ce34bcc19e4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/128ea394.failed

Moved common function setup_glists to lio_core.c
and reamed it to lio_setup_glists

	Signed-off-by: Intiyaz Basha <intiyaz.basha@cavium.com>
	Acked-by: Derek Chickles <derek.chickles@cavium.com>
	Signed-off-by: Felix Manlunas <felix.manlunas@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 128ea39439341d4f60bda1740a59ce34bcc19e4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/cavium/liquidio/lio_core.c
#	drivers/net/ethernet/cavium/liquidio/lio_main.c
#	drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
#	drivers/net/ethernet/cavium/liquidio/octeon_network.h
diff --cc drivers/net/ethernet/cavium/liquidio/lio_core.c
index 5c6599c797a0,b805d54d8e00..000000000000
--- a/drivers/net/ethernet/cavium/liquidio/lio_core.c
+++ b/drivers/net/ethernet/cavium/liquidio/lio_core.c
@@@ -29,6 -29,162 +29,165 @@@
  /* OOM task polling interval */
  #define LIO_OOM_POLL_INTERVAL_MS 250
  
++<<<<<<< HEAD
++=======
+ #define OCTNIC_MAX_SG  MAX_SKB_FRAGS
+ 
+ /**
+  * \brief Callback for getting interface configuration
+  * @param status status of request
+  * @param buf pointer to resp structure
+  */
+ void lio_if_cfg_callback(struct octeon_device *oct,
+ 			 u32 status __attribute__((unused)), void *buf)
+ {
+ 	struct octeon_soft_command *sc = (struct octeon_soft_command *)buf;
+ 	struct liquidio_if_cfg_context *ctx;
+ 	struct liquidio_if_cfg_resp *resp;
+ 
+ 	resp = (struct liquidio_if_cfg_resp *)sc->virtrptr;
+ 	ctx = (struct liquidio_if_cfg_context *)sc->ctxptr;
+ 
+ 	oct = lio_get_device(ctx->octeon_id);
+ 	if (resp->status)
+ 		dev_err(&oct->pci_dev->dev, "nic if cfg instruction failed. Status: %llx\n",
+ 			CVM_CAST64(resp->status));
+ 	WRITE_ONCE(ctx->cond, 1);
+ 
+ 	snprintf(oct->fw_info.liquidio_firmware_version, 32, "%s",
+ 		 resp->cfg_info.liquidio_firmware_version);
+ 
+ 	/* This barrier is required to be sure that the response has been
+ 	 * written fully before waking up the handler
+ 	 */
+ 	wmb();
+ 
+ 	wake_up_interruptible(&ctx->wc);
+ }
+ 
+ /**
+  * \brief Delete gather lists
+  * @param lio per-network private data
+  */
+ void lio_delete_glists(struct lio *lio)
+ {
+ 	struct octnic_gather *g;
+ 	int i;
+ 
+ 	kfree(lio->glist_lock);
+ 	lio->glist_lock = NULL;
+ 
+ 	if (!lio->glist)
+ 		return;
+ 
+ 	for (i = 0; i < lio->linfo.num_txpciq; i++) {
+ 		do {
+ 			g = (struct octnic_gather *)
+ 			    lio_list_delete_head(&lio->glist[i]);
+ 			kfree(g);
+ 		} while (g);
+ 
+ 		if (lio->glists_virt_base && lio->glists_virt_base[i] &&
+ 		    lio->glists_dma_base && lio->glists_dma_base[i]) {
+ 			lio_dma_free(lio->oct_dev,
+ 				     lio->glist_entry_size * lio->tx_qsize,
+ 				     lio->glists_virt_base[i],
+ 				     lio->glists_dma_base[i]);
+ 		}
+ 	}
+ 
+ 	kfree(lio->glists_virt_base);
+ 	lio->glists_virt_base = NULL;
+ 
+ 	kfree(lio->glists_dma_base);
+ 	lio->glists_dma_base = NULL;
+ 
+ 	kfree(lio->glist);
+ 	lio->glist = NULL;
+ }
+ 
+ /**
+  * \brief Setup gather lists
+  * @param lio per-network private data
+  */
+ int lio_setup_glists(struct octeon_device *oct, struct lio *lio, int num_iqs)
+ {
+ 	struct octnic_gather *g;
+ 	int i, j;
+ 
+ 	lio->glist_lock =
+ 	    kcalloc(num_iqs, sizeof(*lio->glist_lock), GFP_KERNEL);
+ 	if (!lio->glist_lock)
+ 		return -ENOMEM;
+ 
+ 	lio->glist =
+ 	    kcalloc(num_iqs, sizeof(*lio->glist), GFP_KERNEL);
+ 	if (!lio->glist) {
+ 		kfree(lio->glist_lock);
+ 		lio->glist_lock = NULL;
+ 		return -ENOMEM;
+ 	}
+ 
+ 	lio->glist_entry_size =
+ 		ROUNDUP8((ROUNDUP4(OCTNIC_MAX_SG) >> 2) * OCT_SG_ENTRY_SIZE);
+ 
+ 	/* allocate memory to store virtual and dma base address of
+ 	 * per glist consistent memory
+ 	 */
+ 	lio->glists_virt_base = kcalloc(num_iqs, sizeof(*lio->glists_virt_base),
+ 					GFP_KERNEL);
+ 	lio->glists_dma_base = kcalloc(num_iqs, sizeof(*lio->glists_dma_base),
+ 				       GFP_KERNEL);
+ 
+ 	if (!lio->glists_virt_base || !lio->glists_dma_base) {
+ 		lio_delete_glists(lio);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	for (i = 0; i < num_iqs; i++) {
+ 		int numa_node = dev_to_node(&oct->pci_dev->dev);
+ 
+ 		spin_lock_init(&lio->glist_lock[i]);
+ 
+ 		INIT_LIST_HEAD(&lio->glist[i]);
+ 
+ 		lio->glists_virt_base[i] =
+ 			lio_dma_alloc(oct,
+ 				      lio->glist_entry_size * lio->tx_qsize,
+ 				      &lio->glists_dma_base[i]);
+ 
+ 		if (!lio->glists_virt_base[i]) {
+ 			lio_delete_glists(lio);
+ 			return -ENOMEM;
+ 		}
+ 
+ 		for (j = 0; j < lio->tx_qsize; j++) {
+ 			g = kzalloc_node(sizeof(*g), GFP_KERNEL,
+ 					 numa_node);
+ 			if (!g)
+ 				g = kzalloc(sizeof(*g), GFP_KERNEL);
+ 			if (!g)
+ 				break;
+ 
+ 			g->sg = lio->glists_virt_base[i] +
+ 				(j * lio->glist_entry_size);
+ 
+ 			g->sg_dma_ptr = lio->glists_dma_base[i] +
+ 					(j * lio->glist_entry_size);
+ 
+ 			list_add_tail(&g->list, &lio->glist[i]);
+ 		}
+ 
+ 		if (j != lio->tx_qsize) {
+ 			lio_delete_glists(lio);
+ 			return -ENOMEM;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 128ea3943934 (liquidio: Moved common function setup_glists to lio_core.c)
  int liquidio_set_feature(struct net_device *netdev, int cmd, u16 param1)
  {
  	struct lio *lio = GET_LIO(netdev);
diff --cc drivers/net/ethernet/cavium/liquidio/lio_main.c
index 5562c7185976,4b8e29f4e621..000000000000
--- a/drivers/net/ethernet/cavium/liquidio/lio_main.c
+++ b/drivers/net/ethernet/cavium/liquidio/lio_main.c
@@@ -551,129 -519,6 +549,132 @@@ static inline int check_txq_status(stru
  }
  
  /**
++<<<<<<< HEAD
 + * \brief Delete gather lists
 + * @param lio per-network private data
 + */
 +static void delete_glists(struct lio *lio)
 +{
 +	struct octnic_gather *g;
 +	int i;
 +
 +	kfree(lio->glist_lock);
 +	lio->glist_lock = NULL;
 +
 +	if (!lio->glist)
 +		return;
 +
 +	for (i = 0; i < lio->linfo.num_txpciq; i++) {
 +		do {
 +			g = (struct octnic_gather *)
 +				lio_list_delete_head(&lio->glist[i]);
 +			if (g)
 +				kfree(g);
 +		} while (g);
 +
 +		if (lio->glists_virt_base && lio->glists_virt_base[i] &&
 +		    lio->glists_dma_base && lio->glists_dma_base[i]) {
 +			lio_dma_free(lio->oct_dev,
 +				     lio->glist_entry_size * lio->tx_qsize,
 +				     lio->glists_virt_base[i],
 +				     lio->glists_dma_base[i]);
 +		}
 +	}
 +
 +	kfree(lio->glists_virt_base);
 +	lio->glists_virt_base = NULL;
 +
 +	kfree(lio->glists_dma_base);
 +	lio->glists_dma_base = NULL;
 +
 +	kfree(lio->glist);
 +	lio->glist = NULL;
 +}
 +
 +/**
 + * \brief Setup gather lists
 + * @param lio per-network private data
 + */
 +static int setup_glists(struct octeon_device *oct, struct lio *lio, int num_iqs)
 +{
 +	int i, j;
 +	struct octnic_gather *g;
 +
 +	lio->glist_lock = kcalloc(num_iqs, sizeof(*lio->glist_lock),
 +				  GFP_KERNEL);
 +	if (!lio->glist_lock)
 +		return -ENOMEM;
 +
 +	lio->glist = kcalloc(num_iqs, sizeof(*lio->glist),
 +			     GFP_KERNEL);
 +	if (!lio->glist) {
 +		kfree(lio->glist_lock);
 +		lio->glist_lock = NULL;
 +		return -ENOMEM;
 +	}
 +
 +	lio->glist_entry_size =
 +		ROUNDUP8((ROUNDUP4(OCTNIC_MAX_SG) >> 2) * OCT_SG_ENTRY_SIZE);
 +
 +	/* allocate memory to store virtual and dma base address of
 +	 * per glist consistent memory
 +	 */
 +	lio->glists_virt_base = kcalloc(num_iqs, sizeof(*lio->glists_virt_base),
 +					GFP_KERNEL);
 +	lio->glists_dma_base = kcalloc(num_iqs, sizeof(*lio->glists_dma_base),
 +				       GFP_KERNEL);
 +
 +	if (!lio->glists_virt_base || !lio->glists_dma_base) {
 +		delete_glists(lio);
 +		return -ENOMEM;
 +	}
 +
 +	for (i = 0; i < num_iqs; i++) {
 +		int numa_node = dev_to_node(&oct->pci_dev->dev);
 +
 +		spin_lock_init(&lio->glist_lock[i]);
 +
 +		INIT_LIST_HEAD(&lio->glist[i]);
 +
 +		lio->glists_virt_base[i] =
 +			lio_dma_alloc(oct,
 +				      lio->glist_entry_size * lio->tx_qsize,
 +				      &lio->glists_dma_base[i]);
 +
 +		if (!lio->glists_virt_base[i]) {
 +			delete_glists(lio);
 +			return -ENOMEM;
 +		}
 +
 +		for (j = 0; j < lio->tx_qsize; j++) {
 +			g = kzalloc_node(sizeof(*g), GFP_KERNEL,
 +					 numa_node);
 +			if (!g)
 +				g = kzalloc(sizeof(*g), GFP_KERNEL);
 +			if (!g)
 +				break;
 +
 +			g->sg = lio->glists_virt_base[i] +
 +				(j * lio->glist_entry_size);
 +
 +			g->sg_dma_ptr = lio->glists_dma_base[i] +
 +					(j * lio->glist_entry_size);
 +
 +			list_add_tail(&g->list, &lio->glist[i]);
 +		}
 +
 +		if (j != lio->tx_qsize) {
 +			delete_glists(lio);
 +			return -ENOMEM;
 +		}
 +	}
 +
 +	return 0;
 +}
 +
 +/**
++=======
++>>>>>>> 128ea3943934 (liquidio: Moved common function setup_glists to lio_core.c)
   * \brief Print link information
   * @param netdev network device
   */
diff --cc drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
index ef511e6543e8,be28b8f1f67d..000000000000
--- a/drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
+++ b/drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
@@@ -299,123 -265,6 +297,126 @@@ static struct pci_driver liquidio_vf_pc
  };
  
  /**
++<<<<<<< HEAD
 + * \brief Delete gather lists
 + * @param lio per-network private data
 + */
 +static void delete_glists(struct lio *lio)
 +{
 +	struct octnic_gather *g;
 +	int i;
 +
 +	kfree(lio->glist_lock);
 +	lio->glist_lock = NULL;
 +
 +	if (!lio->glist)
 +		return;
 +
 +	for (i = 0; i < lio->linfo.num_txpciq; i++) {
 +		do {
 +			g = (struct octnic_gather *)
 +			    lio_list_delete_head(&lio->glist[i]);
 +			kfree(g);
 +		} while (g);
 +
 +		if (lio->glists_virt_base && lio->glists_virt_base[i] &&
 +		    lio->glists_dma_base && lio->glists_dma_base[i]) {
 +			lio_dma_free(lio->oct_dev,
 +				     lio->glist_entry_size * lio->tx_qsize,
 +				     lio->glists_virt_base[i],
 +				     lio->glists_dma_base[i]);
 +		}
 +	}
 +
 +	kfree(lio->glists_virt_base);
 +	lio->glists_virt_base = NULL;
 +
 +	kfree(lio->glists_dma_base);
 +	lio->glists_dma_base = NULL;
 +
 +	kfree(lio->glist);
 +	lio->glist = NULL;
 +}
 +
 +/**
 + * \brief Setup gather lists
 + * @param lio per-network private data
 + */
 +static int setup_glists(struct lio *lio, int num_iqs)
 +{
 +	struct octnic_gather *g;
 +	int i, j;
 +
 +	lio->glist_lock =
 +	    kzalloc(sizeof(*lio->glist_lock) * num_iqs, GFP_KERNEL);
 +	if (!lio->glist_lock)
 +		return -ENOMEM;
 +
 +	lio->glist =
 +	    kzalloc(sizeof(*lio->glist) * num_iqs, GFP_KERNEL);
 +	if (!lio->glist) {
 +		kfree(lio->glist_lock);
 +		lio->glist_lock = NULL;
 +		return -ENOMEM;
 +	}
 +
 +	lio->glist_entry_size =
 +		ROUNDUP8((ROUNDUP4(OCTNIC_MAX_SG) >> 2) * OCT_SG_ENTRY_SIZE);
 +
 +	/* allocate memory to store virtual and dma base address of
 +	 * per glist consistent memory
 +	 */
 +	lio->glists_virt_base = kcalloc(num_iqs, sizeof(*lio->glists_virt_base),
 +					GFP_KERNEL);
 +	lio->glists_dma_base = kcalloc(num_iqs, sizeof(*lio->glists_dma_base),
 +				       GFP_KERNEL);
 +
 +	if (!lio->glists_virt_base || !lio->glists_dma_base) {
 +		delete_glists(lio);
 +		return -ENOMEM;
 +	}
 +
 +	for (i = 0; i < num_iqs; i++) {
 +		spin_lock_init(&lio->glist_lock[i]);
 +
 +		INIT_LIST_HEAD(&lio->glist[i]);
 +
 +		lio->glists_virt_base[i] =
 +			lio_dma_alloc(lio->oct_dev,
 +				      lio->glist_entry_size * lio->tx_qsize,
 +				      &lio->glists_dma_base[i]);
 +
 +		if (!lio->glists_virt_base[i]) {
 +			delete_glists(lio);
 +			return -ENOMEM;
 +		}
 +
 +		for (j = 0; j < lio->tx_qsize; j++) {
 +			g = kzalloc(sizeof(*g), GFP_KERNEL);
 +			if (!g)
 +				break;
 +
 +			g->sg = lio->glists_virt_base[i] +
 +				(j * lio->glist_entry_size);
 +
 +			g->sg_dma_ptr = lio->glists_dma_base[i] +
 +					(j * lio->glist_entry_size);
 +
 +			list_add_tail(&g->list, &lio->glist[i]);
 +		}
 +
 +		if (j != lio->tx_qsize) {
 +			delete_glists(lio);
 +			return -ENOMEM;
 +		}
 +	}
 +
 +	return 0;
 +}
 +
 +/**
++=======
++>>>>>>> 128ea3943934 (liquidio: Moved common function setup_glists to lio_core.c)
   * \brief Print link information
   * @param netdev network device
   */
diff --cc drivers/net/ethernet/cavium/liquidio/octeon_network.h
index ad6851b4defa,f8c1091639ae..000000000000
--- a/drivers/net/ethernet/cavium/liquidio/octeon_network.h
+++ b/drivers/net/ethernet/cavium/liquidio/octeon_network.h
@@@ -184,6 -220,22 +184,25 @@@ int octeon_setup_interrupt(struct octeo
   */
  void liquidio_set_ethtool_ops(struct net_device *netdev);
  
++<<<<<<< HEAD
++=======
+ void lio_if_cfg_callback(struct octeon_device *oct,
+ 			 u32 status __attribute__((unused)),
+ 			 void *buf);
+ 
+ void lio_delete_glists(struct lio *lio);
+ 
+ int lio_setup_glists(struct octeon_device *oct, struct lio *lio, int num_qs);
+ 
+ /**
+  * \brief Net device change_mtu
+  * @param netdev network device
+  */
+ int liquidio_change_mtu(struct net_device *netdev, int new_mtu);
+ #define LIO_CHANGE_MTU_SUCCESS 1
+ #define LIO_CHANGE_MTU_FAIL    2
+ 
++>>>>>>> 128ea3943934 (liquidio: Moved common function setup_glists to lio_core.c)
  #define SKB_ADJ_MASK  0x3F
  #define SKB_ADJ       (SKB_ADJ_MASK + 1)
  
* Unmerged path drivers/net/ethernet/cavium/liquidio/lio_core.c
* Unmerged path drivers/net/ethernet/cavium/liquidio/lio_main.c
* Unmerged path drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
* Unmerged path drivers/net/ethernet/cavium/liquidio/octeon_network.h
