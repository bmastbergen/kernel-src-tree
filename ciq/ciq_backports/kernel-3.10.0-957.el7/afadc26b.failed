mlxsw: spectrum: Add support for getting kvdl occupancy

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Arkadi Sharshevsky <arkadis@mellanox.com>
commit afadc26b3aa3e94d1cedf9472889b4c32aecc6ac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/afadc26b.failed

Add support for getting the kvdl occupancy through the resource interface.

	Signed-off-by: Arkadi Sharshevsky <arkadis@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit afadc26b3aa3e94d1cedf9472889b4c32aecc6ac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum.h
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_kvdl.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum.h
index 8e4a9d41ad1f,237cad373dbe..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
@@@ -455,6 -443,12 +455,13 @@@ void mlxsw_sp_rif_destroy(struct mlxsw_
  int mlxsw_sp_kvdl_alloc(struct mlxsw_sp *mlxsw_sp, unsigned int entry_count,
  			u32 *p_entry_index);
  void mlxsw_sp_kvdl_free(struct mlxsw_sp *mlxsw_sp, int entry_index);
++<<<<<<< HEAD
++=======
+ int mlxsw_sp_kvdl_alloc_size_query(struct mlxsw_sp *mlxsw_sp,
+ 				   unsigned int entry_count,
+ 				   unsigned int *p_alloc_size);
+ u64 mlxsw_sp_kvdl_occ_get(const struct mlxsw_sp *mlxsw_sp);
++>>>>>>> afadc26b3aa3 (mlxsw: spectrum: Add support for getting kvdl occupancy)
  
  struct mlxsw_sp_acl_rule_info {
  	unsigned int priority;
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_kvdl.c
index 26c26cd30c3d,cfacc176a1bd..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_kvdl.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_kvdl.c
@@@ -48,46 -151,190 +48,104 @@@
  int mlxsw_sp_kvdl_alloc(struct mlxsw_sp *mlxsw_sp, unsigned int entry_count,
  			u32 *p_entry_index)
  {
 -	struct mlxsw_sp_kvdl_part *part;
 -
 -	/* Find partition with smallest allocation size satisfying the
 -	 * requested size.
 -	 */
 -	part = mlxsw_sp_kvdl_alloc_size_part(mlxsw_sp->kvdl, entry_count);
 -	if (IS_ERR(part))
 -		return PTR_ERR(part);
 -
 -	return mlxsw_sp_kvdl_part_alloc(part, p_entry_index);
 -}
 -
 -void mlxsw_sp_kvdl_free(struct mlxsw_sp *mlxsw_sp, int entry_index)
 -{
 -	struct mlxsw_sp_kvdl_part *part;
 -
 -	part = mlxsw_sp_kvdl_index_part(mlxsw_sp->kvdl, entry_index);
 -	if (IS_ERR(part))
 -		return;
 -	mlxsw_sp_kvdl_part_free(part, entry_index);
 -}
 -
 -int mlxsw_sp_kvdl_alloc_size_query(struct mlxsw_sp *mlxsw_sp,
 -				   unsigned int entry_count,
 -				   unsigned int *p_alloc_size)
 -{
 -	struct mlxsw_sp_kvdl_part *part;
 -
 -	part = mlxsw_sp_kvdl_alloc_size_part(mlxsw_sp->kvdl, entry_count);
 -	if (IS_ERR(part))
 -		return PTR_ERR(part);
 -
 -	*p_alloc_size = part->info->alloc_size;
 -
 -	return 0;
 -}
 -
 -static const struct mlxsw_sp_kvdl_part_info kvdl_parts_info[] = {
 -	{
 -		.part_index	= 0,
 -		.start_index	= MLXSW_SP_KVDL_SINGLE_BASE,
 -		.end_index	= MLXSW_SP_KVDL_SINGLE_END,
 -		.alloc_size	= 1,
 -	},
 -	{
 -		.part_index	= 1,
 -		.start_index	= MLXSW_SP_KVDL_CHUNKS_BASE,
 -		.end_index	= MLXSW_SP_KVDL_CHUNKS_END,
 -		.alloc_size	= MLXSW_SP_CHUNK_MAX,
 -	},
 -	{
 -		.part_index	= 2,
 -		.start_index	= MLXSW_SP_KVDL_LARGE_CHUNKS_BASE,
 -		.end_index	= MLXSW_SP_KVDL_LARGE_CHUNKS_END,
 -		.alloc_size	= MLXSW_SP_LARGE_CHUNK_MAX,
 -	},
 -};
 -
 -static struct mlxsw_sp_kvdl_part *
 -mlxsw_sp_kvdl_part_find(struct mlxsw_sp *mlxsw_sp, unsigned int part_index)
 -{
 -	struct mlxsw_sp_kvdl_part *part;
 -
 -	list_for_each_entry(part, &mlxsw_sp->kvdl->parts_list, list) {
 -		if (part->info->part_index == part_index)
 -			return part;
 +	int entry_index;
 +	int size;
 +	int type_base;
 +	int type_size;
 +	int type_entries;
 +
 +	if (entry_count == 0 || entry_count > MLXSW_SP_CHUNK_MAX) {
 +		return -EINVAL;
 +	} else if (entry_count == 1) {
 +		type_base = MLXSW_SP_KVDL_SINGLE_BASE;
 +		type_size = MLXSW_SP_KVDL_SINGLE_SIZE;
 +		type_entries = 1;
 +	} else {
 +		type_base = MLXSW_SP_KVDL_CHUNKS_BASE;
 +		type_size = MLXSW_SP_KVDL_CHUNKS_SIZE;
 +		type_entries = MLXSW_SP_CHUNK_MAX;
  	}
  
 -	return NULL;
 -}
 -
 -static int mlxsw_sp_kvdl_part_init(struct mlxsw_sp *mlxsw_sp,
 -				   unsigned int part_index)
 -{
 -	const struct mlxsw_sp_kvdl_part_info *info;
 -	struct mlxsw_sp_kvdl_part *part;
 -	unsigned int nr_entries;
 -	size_t usage_size;
 -
 -	info = &kvdl_parts_info[part_index];
 +	entry_index = type_base;
 +	size = type_base + type_size;
 +	for_each_clear_bit_from(entry_index, mlxsw_sp->kvdl.usage, size) {
 +		int i;
  
 -	nr_entries = (info->end_index - info->start_index + 1) /
 -		     info->alloc_size;
 -	usage_size = BITS_TO_LONGS(nr_entries) * sizeof(unsigned long);
 -	part = kzalloc(sizeof(*part) + usage_size, GFP_KERNEL);
 -	if (!part)
 -		return -ENOMEM;
 -
 -	part->info = info;
 -	list_add(&part->list, &mlxsw_sp->kvdl->parts_list);
 -
 -	return 0;
 -}
 -
 -static void mlxsw_sp_kvdl_part_fini(struct mlxsw_sp *mlxsw_sp,
 -				    unsigned int part_index)
 -{
 -	struct mlxsw_sp_kvdl_part *part;
 -
 -	part = mlxsw_sp_kvdl_part_find(mlxsw_sp, part_index);
 -	if (!part)
 -		return;
 -
 -	list_del(&part->list);
 -	kfree(part);
 -}
 -
 -static int mlxsw_sp_kvdl_parts_init(struct mlxsw_sp *mlxsw_sp)
 -{
 -	int err, i;
 -
 -	INIT_LIST_HEAD(&mlxsw_sp->kvdl->parts_list);
 -
 -	for (i = 0; i < ARRAY_SIZE(kvdl_parts_info); i++) {
 -		err = mlxsw_sp_kvdl_part_init(mlxsw_sp, i);
 -		if (err)
 -			goto err_kvdl_part_init;
 +		for (i = 0; i < type_entries; i++)
 +			set_bit(entry_index + i, mlxsw_sp->kvdl.usage);
 +		*p_entry_index = entry_index;
 +		return 0;
  	}
 -
 -	return 0;
 -
 -err_kvdl_part_init:
 -	for (i--; i >= 0; i--)
 -		mlxsw_sp_kvdl_part_fini(mlxsw_sp, i);
 -	return err;
 +	return -ENOBUFS;
  }
  
 -static void mlxsw_sp_kvdl_parts_fini(struct mlxsw_sp *mlxsw_sp)
 +void mlxsw_sp_kvdl_free(struct mlxsw_sp *mlxsw_sp, int entry_index)
  {
 +	int type_entries;
  	int i;
  
++<<<<<<< HEAD
 +	if (entry_index < MLXSW_SP_KVDL_CHUNKS_BASE)
 +		type_entries = 1;
 +	else
 +		type_entries = MLXSW_SP_CHUNK_MAX;
 +	for (i = 0; i < type_entries; i++)
 +		clear_bit(entry_index + i, mlxsw_sp->kvdl.usage);
++=======
+ 	for (i = ARRAY_SIZE(kvdl_parts_info) - 1; i >= 0; i--)
+ 		mlxsw_sp_kvdl_part_fini(mlxsw_sp, i);
+ }
+ 
+ u64 mlxsw_sp_kvdl_part_occ(struct mlxsw_sp_kvdl_part *part)
+ {
+ 	unsigned int nr_entries;
+ 	int bit = -1;
+ 	u64 occ = 0;
+ 
+ 	nr_entries = (part->info->end_index -
+ 		      part->info->start_index + 1) /
+ 		      part->info->alloc_size;
+ 	while ((bit = find_next_bit(part->usage, nr_entries, bit + 1))
+ 		< nr_entries)
+ 		occ += part->info->alloc_size;
+ 	return occ;
+ }
+ 
+ u64 mlxsw_sp_kvdl_occ_get(const struct mlxsw_sp *mlxsw_sp)
+ {
+ 	struct mlxsw_sp_kvdl_part *part;
+ 	u64 occ = 0;
+ 
+ 	list_for_each_entry(part, &mlxsw_sp->kvdl->parts_list, list)
+ 		occ += mlxsw_sp_kvdl_part_occ(part);
+ 
+ 	return occ;
+ }
+ 
+ int mlxsw_sp_kvdl_init(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	struct mlxsw_sp_kvdl *kvdl;
+ 	int err;
+ 
+ 	kvdl = kzalloc(sizeof(*mlxsw_sp->kvdl), GFP_KERNEL);
+ 	if (!kvdl)
+ 		return -ENOMEM;
+ 	mlxsw_sp->kvdl = kvdl;
+ 
+ 	err = mlxsw_sp_kvdl_parts_init(mlxsw_sp);
+ 	if (err)
+ 		goto err_kvdl_parts_init;
+ 
+ 	return 0;
+ 
+ err_kvdl_parts_init:
+ 	kfree(mlxsw_sp->kvdl);
+ 	return err;
+ }
+ 
+ void mlxsw_sp_kvdl_fini(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	mlxsw_sp_kvdl_parts_fini(mlxsw_sp);
+ 	kfree(mlxsw_sp->kvdl);
++>>>>>>> afadc26b3aa3 (mlxsw: spectrum: Add support for getting kvdl occupancy)
  }
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
index 56e52a7f6efd..83a815478a2e 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
@@ -3974,12 +3974,21 @@ mlxsw_sp_resource_kvd_hash_double_size_validate(struct devlink *devlink, u64 siz
 	return 0;
 }
 
+static u64 mlxsw_sp_resource_kvd_linear_occ_get(struct devlink *devlink)
+{
+	struct mlxsw_core *mlxsw_core = devlink_priv(devlink);
+	struct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);
+
+	return mlxsw_sp_kvdl_occ_get(mlxsw_sp);
+}
+
 static struct devlink_resource_ops mlxsw_sp_resource_kvd_ops = {
 	.size_validate = mlxsw_sp_resource_kvd_size_validate,
 };
 
 static struct devlink_resource_ops mlxsw_sp_resource_kvd_linear_ops = {
 	.size_validate = mlxsw_sp_resource_kvd_linear_size_validate,
+	.occ_get = mlxsw_sp_resource_kvd_linear_occ_get,
 };
 
 static struct devlink_resource_ops mlxsw_sp_resource_kvd_hash_single_ops = {
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum.h
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_kvdl.c
