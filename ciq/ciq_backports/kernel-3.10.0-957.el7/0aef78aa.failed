ipv6: addrconf: don't evaluate keep_addr_on_down twice

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Ivan Vecera <cera@cera.cz>
commit 0aef78aa7b39829a2a46c1c0e6e96276d744e07a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0aef78aa.failed

The addrconf_ifdown() evaluates keep_addr_on_down state twice. There
is no need to do it.

	Cc: David Ahern <dsahern@gmail.com>
	Signed-off-by: Ivan Vecera <cera@cera.cz>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0aef78aa7b39829a2a46c1c0e6e96276d744e07a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/addrconf.c
diff --cc net/ipv6/addrconf.c
index 836f13f8d356,fbfd71a2d9c8..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -3255,11 -3610,19 +3255,16 @@@ static void addrconf_type_change(struc
  		ipv6_mc_unmap(idev);
  }
  
 -static bool addr_is_local(const struct in6_addr *addr)
 -{
 -	return ipv6_addr_type(addr) &
 -		(IPV6_ADDR_LINKLOCAL | IPV6_ADDR_LOOPBACK);
 -}
 -
  static int addrconf_ifdown(struct net_device *dev, int how)
  {
 -	unsigned long event = how ? NETDEV_UNREGISTER : NETDEV_DOWN;
  	struct net *net = dev_net(dev);
  	struct inet6_dev *idev;
++<<<<<<< HEAD
 +	struct inet6_ifaddr *ifa;
++=======
+ 	struct inet6_ifaddr *ifa, *tmp;
+ 	bool keep_addr = false;
++>>>>>>> 0aef78aa7b39 (ipv6: addrconf: don't evaluate keep_addr_on_down twice)
  	int state, i;
  
  	ASSERT_RTNL();
@@@ -3286,6 -3648,19 +3291,22 @@@
  
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* combine the user config with event to determine if permanent
+ 	 * addresses are to be removed from address hash table
+ 	 */
+ 	if (!how && !idev->cnf.disable_ipv6) {
+ 		/* aggregate the system setting and interface setting */
+ 		int _keep_addr = net->ipv6.devconf_all->keep_addr_on_down;
+ 
+ 		if (!_keep_addr)
+ 			_keep_addr = idev->cnf.keep_addr_on_down;
+ 
+ 		keep_addr = (_keep_addr > 0);
+ 	}
+ 
++>>>>>>> 0aef78aa7b39 (ipv6: addrconf: don't evaluate keep_addr_on_down twice)
  	/* Step 2: clear hash table */
  	for (i = 0; i < IN6_ADDR_HSIZE; i++) {
  		struct hlist_head *h = &inet6_addr_lst[i];
@@@ -3330,20 -3709,37 +3351,27 @@@
  		write_lock_bh(&idev->lock);
  	}
  
++<<<<<<< HEAD
 +	while (!list_empty(&idev->addr_list)) {
 +		ifa = list_first_entry(&idev->addr_list,
 +				       struct inet6_ifaddr, if_list);
++=======
+ 	list_for_each_entry_safe(ifa, tmp, &idev->addr_list, if_list) {
+ 		struct fib6_info *rt = NULL;
+ 		bool keep;
+ 
++>>>>>>> 0aef78aa7b39 (ipv6: addrconf: don't evaluate keep_addr_on_down twice)
  		addrconf_del_dad_work(ifa);
  
 -		keep = keep_addr && (ifa->flags & IFA_F_PERMANENT) &&
 -			!addr_is_local(&ifa->addr);
 +		list_del(&ifa->if_list);
  
  		write_unlock_bh(&idev->lock);
 -		spin_lock_bh(&ifa->lock);
 -
 -		if (keep) {
 -			/* set state to skip the notifier below */
 -			state = INET6_IFADDR_STATE_DEAD;
 -			ifa->state = INET6_IFADDR_STATE_PREDAD;
 -			if (!(ifa->flags & IFA_F_NODAD))
 -				ifa->flags |= IFA_F_TENTATIVE;
 -
 -			rt = ifa->rt;
 -			ifa->rt = NULL;
 -		} else {
 -			state = ifa->state;
 -			ifa->state = INET6_IFADDR_STATE_DEAD;
 -		}
  
 +		spin_lock_bh(&ifa->lock);
 +		state = ifa->state;
 +		ifa->state = INET6_IFADDR_STATE_DEAD;
  		spin_unlock_bh(&ifa->lock);
  
 -		if (rt)
 -			ip6_del_rt(net, rt);
 -
  		if (state != INET6_IFADDR_STATE_DEAD) {
  			__ipv6_ifa_notify(RTM_DELADDR, ifa);
  			inet6addr_notifier_call_chain(NETDEV_DOWN, ifa);
* Unmerged path net/ipv6/addrconf.c
