netfilter: ipset: Make NLEN compile time constant for hash types

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit cee8b97b6c13b1331aa3a89a1aab2ca6a7bd06d0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/cee8b97b.failed

Hash types define HOST_MASK before inclusion of ip_set_hash_gen.h
and the only place where NLEN needed to be calculated at runtime
is *_create() method.

Ported from a patch proposed by Sergey Popovich <popovich_sergei@mail.ua>.

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit cee8b97b6c13b1331aa3a89a1aab2ca6a7bd06d0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_hash_gen.h
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 9ce28af662bf,6c88c20ae1d4..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -113,72 -127,43 +113,90 @@@ htable_bits(u32 hashsize
  	return bits;
  }
  
 +/* Destroy the hashtable part of the set */
 +static void
 +ahash_destroy(struct htable *t)
 +{
 +	struct hbucket *n;
 +	u32 i;
 +
 +	for (i = 0; i < jhash_size(t->htable_bits); i++) {
 +		n = hbucket(t, i);
 +		if (n->size)
 +			/* FIXME: use slab cache */
 +			kfree(n->value);
 +	}
 +
 +	ip_set_free(t);
 +}
 +
 +static int
 +hbucket_elem_add(struct hbucket *n, u8 ahash_max, size_t dsize)
 +{
 +	if (n->pos >= n->size) {
 +		void *tmp;
 +
 +		if (n->size >= ahash_max)
 +			/* Trigger rehashing */
 +			return -EAGAIN;
 +
 +		tmp = kzalloc((n->size + AHASH_INIT_SIZE) * dsize,
 +			      GFP_ATOMIC);
 +		if (!tmp)
 +			return -ENOMEM;
 +		if (n->size) {
 +			memcpy(tmp, n->value, n->size * dsize);
 +			kfree(n->value);
 +		}
 +		n->value = tmp;
 +		n->size += AHASH_INIT_SIZE;
 +	}
 +	return 0;
 +}
 +
  #ifdef IP_SET_HASH_WITH_NETS
 -#if IPSET_NET_COUNT > 1
 -#define __CIDR(cidr, i)		(cidr[i])
 +#ifdef IP_SET_HASH_WITH_NETS_PACKED
 +/* When cidr is packed with nomatch, cidr - 1 is stored in the entry */
 +#define CIDR(cidr)		(cidr + 1)
  #else
 -#define __CIDR(cidr, i)		(cidr)
 +#define CIDR(cidr)		(cidr)
  #endif
  
 -/* cidr + 1 is stored in net_prefixes to support /0 */
 -#define NCIDR_PUT(cidr)		((cidr) + 1)
 -#define NCIDR_GET(cidr)		((cidr) - 1)
++<<<<<<< HEAD
 +#define SET_HOST_MASK(family)	(family == AF_INET ? 32 : 128)
  
 -#ifdef IP_SET_HASH_WITH_NETS_PACKED
 -/* When cidr is packed with nomatch, cidr - 1 is stored in the data entry */
 -#define DCIDR_PUT(cidr)		((cidr) - 1)
 -#define DCIDR_GET(cidr, i)	(__CIDR(cidr, i) + 1)
 +#ifdef IP_SET_HASH_WITH_MULTI
 +#define NETS_LENGTH(family)	(SET_HOST_MASK(family) + 1)
  #else
 -#define DCIDR_PUT(cidr)		(cidr)
 -#define DCIDR_GET(cidr, i)	__CIDR(cidr, i)
 +#define NETS_LENGTH(family)	SET_HOST_MASK(family)
  #endif
  
 +#else
 +#define NETS_LENGTH(family)	0
++=======
+ #define INIT_CIDR(cidr, host_mask)	\
+ 	DCIDR_PUT(((cidr) ? NCIDR_GET(cidr) : host_mask))
+ 
+ #ifdef IP_SET_HASH_WITH_NET0
+ /* cidr from 0 to HOST_MASK value and c = cidr + 1 */
+ #define NLEN			(HOST_MASK + 1)
+ #define CIDR_POS(c)		((c) - 1)
+ #else
+ /* cidr from 1 to HOST_MASK value and c = cidr + 1 */
+ #define NLEN			HOST_MASK
+ #define CIDR_POS(c)		((c) - 2)
+ #endif
+ 
+ #else
+ #define NLEN			0
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  #endif /* IP_SET_HASH_WITH_NETS */
  
 +#define ext_timeout(e, h)	\
 +(unsigned long *)(((void *)(e)) + (h)->offset[IPSET_EXT_ID_TIMEOUT])
 +#define ext_counter(e, h)	\
 +(struct ip_set_counter *)(((void *)(e)) + (h)->offset[IPSET_EXT_ID_COUNTER])
 +
  #endif /* _IP_SET_HASH_GEN_H */
  
  /* Family dependent templates */
@@@ -293,20 -293,21 +311,29 @@@ struct htype 
  
  #ifdef IP_SET_HASH_WITH_NETS
  /* Network cidr size book keeping when the hash stores different
 - * sized networks. cidr == real cidr + 1 to support /0.
 - */
 + * sized networks */
  static void
++<<<<<<< HEAD
 +mtype_add_cidr(struct htype *h, u8 cidr, u8 nets_length)
++=======
+ mtype_add_cidr(struct htype *h, u8 cidr, u8 n)
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  {
  	int i, j;
  
  	/* Add in increasing prefix order, so larger cidr first */
++<<<<<<< HEAD
 +	for (i = 0, j = -1; i < nets_length && h->nets[i].nets; i++) {
 +		if (j != -1)
++=======
+ 	for (i = 0, j = -1; i < NLEN && h->nets[i].cidr[n]; i++) {
+ 		if (j != -1) {
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  			continue;
 -		} else if (h->nets[i].cidr[n] < cidr) {
 +		else if (h->nets[i].cidr < cidr)
  			j = i;
 -		} else if (h->nets[i].cidr[n] == cidr) {
 -			h->nets[CIDR_POS(cidr)].nets[n]++;
 +		else if (h->nets[i].cidr == cidr) {
 +			h->nets[i].nets++;
  			return;
  		}
  	}
@@@ -321,45 -320,49 +348,70 @@@
  }
  
  static void
++<<<<<<< HEAD
 +mtype_del_cidr(struct htype *h, u8 cidr, u8 nets_length)
++=======
+ mtype_del_cidr(struct htype *h, u8 cidr, u8 n)
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  {
- 	u8 i, j, net_end = nets_length - 1;
+ 	u8 i, j, net_end = NLEN - 1;
  
++<<<<<<< HEAD
 +	for (i = 0; i < nets_length; i++) {
 +	        if (h->nets[i].cidr != cidr)
 +	                continue;
 +                if (h->nets[i].nets > 1 || i == net_end ||
 +                    h->nets[i + 1].nets == 0) {
 +                        h->nets[i].nets--;
 +                        return;
 +                }
 +                for (j = i; j < net_end && h->nets[j].nets; j++) {
 +		        h->nets[j].cidr = h->nets[j + 1].cidr;
 +		        h->nets[j].nets = h->nets[j + 1].nets;
 +                }
 +                h->nets[j].nets = 0;
 +                return;
++=======
+ 	for (i = 0; i < NLEN; i++) {
+ 		if (h->nets[i].cidr[n] != cidr)
+ 			continue;
+ 		h->nets[CIDR_POS(cidr)].nets[n]--;
+ 		if (h->nets[CIDR_POS(cidr)].nets[n] > 0)
+ 			return;
+ 		for (j = i; j < net_end && h->nets[j].cidr[n]; j++)
+ 			h->nets[j].cidr[n] = h->nets[j + 1].cidr[n];
+ 		h->nets[j].cidr[n] = 0;
+ 		return;
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  	}
  }
  #endif
  
  /* Calculate the actual memory size of the set data */
  static size_t
++<<<<<<< HEAD
 +mtype_ahash_memsize(const struct htype *h, u8 nets_length)
++=======
+ mtype_ahash_memsize(const struct htype *h, const struct htable *t)
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  {
 -	size_t memsize = sizeof(*h) + sizeof(*t);
 -
 +	u32 i;
 +	struct htable *t = h->table;
 +	size_t memsize = sizeof(*h)
 +			 + sizeof(*t)
  #ifdef IP_SET_HASH_WITH_NETS
++<<<<<<< HEAD
 +			 + sizeof(struct net_prefixes) * nets_length
++=======
+ 	memsize += sizeof(struct net_prefixes) * NLEN;
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  #endif
 +			 + jhash_size(t->htable_bits) * sizeof(struct hbucket);
  
 -	return memsize;
 -}
 -
 -/* Get the ith element from the array block n */
 -#define ahash_data(n, i, dsize)	\
 -	((struct mtype_elem *)((n)->value + ((i) * (dsize))))
 -
 -static void
 -mtype_ext_cleanup(struct ip_set *set, struct hbucket *n)
 -{
 -	int i;
 +	for (i = 0; i < jhash_size(t->htable_bits); i++)
 +		memsize += t->bucket[i].size * h->dsize;
  
 -	for (i = 0; i < n->pos; i++)
 -		if (test_bit(i, n->used))
 -			ip_set_ext_destroy(set, ahash_data(n, i, set->dsize));
 +	return memsize;
  }
  
  /* Flush a hash type of set: destroy all elements */
@@@ -371,19 -374,42 +423,23 @@@ mtype_flush(struct ip_set *set
  	struct hbucket *n;
  	u32 i;
  
 -	t = ipset_dereference_protected(h->table, set);
  	for (i = 0; i < jhash_size(t->htable_bits); i++) {
 -		n = __ipset_dereference_protected(hbucket(t, i), 1);
 -		if (!n)
 -			continue;
 -		if (set->extensions & IPSET_EXT_DESTROY)
 -			mtype_ext_cleanup(set, n);
 -		/* FIXME: use slab cache */
 -		rcu_assign_pointer(hbucket(t, i), NULL);
 -		kfree_rcu(n, rcu);
 +		n = hbucket(t, i);
 +		if (n->size) {
 +			n->size = n->pos = 0;
 +			/* FIXME: use slab cache */
 +			kfree(n->value);
 +		}
  	}
  #ifdef IP_SET_HASH_WITH_NETS
++<<<<<<< HEAD
 +	memset(h->nets, 0, sizeof(struct net_prefixes)
 +			   * NETS_LENGTH(set->family));
++=======
+ 	memset(h->nets, 0, sizeof(struct net_prefixes) * NLEN);
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  #endif
 -	set->elements = 0;
 -	set->ext_size = 0;
 -}
 -
 -/* Destroy the hashtable part of the set */
 -static void
 -mtype_ahash_destroy(struct ip_set *set, struct htable *t, bool ext_destroy)
 -{
 -	struct hbucket *n;
 -	u32 i;
 -
 -	for (i = 0; i < jhash_size(t->htable_bits); i++) {
 -		n = __ipset_dereference_protected(hbucket(t, i), 1);
 -		if (!n)
 -			continue;
 -		if (set->extensions & IPSET_EXT_DESTROY && ext_destroy)
 -			mtype_ext_cleanup(set, n);
 -		/* FIXME: use slab cache */
 -		kfree(n);
 -	}
 -
 -	ip_set_free(t);
 +	h->elements = 0;
  }
  
  /* Destroy a hash type of set */
@@@ -433,43 -460,54 +489,58 @@@ mtype_same_set(const struct ip_set *a, 
  	       a->extensions == b->extensions;
  }
  
 +/* Get the ith element from the array block n */
 +#define ahash_data(n, i, dsize)	\
 +	((struct mtype_elem *)((n)->value + ((i) * (dsize))))
 +
  /* Delete expired elements from the hashtable */
  static void
 -mtype_expire(struct ip_set *set, struct htype *h)
 +mtype_expire(struct htype *h, u8 nets_length, size_t dsize)
  {
 -	struct htable *t;
 -	struct hbucket *n, *tmp;
 +	struct htable *t = h->table;
 +	struct hbucket *n;
  	struct mtype_elem *data;
++<<<<<<< HEAD
 +	u32 i;
 +	int j;
++=======
+ 	u32 i, j, d;
+ 	size_t dsize = set->dsize;
+ #ifdef IP_SET_HASH_WITH_NETS
+ 	u8 k;
+ #endif
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  
 -	t = ipset_dereference_protected(h->table, set);
  	for (i = 0; i < jhash_size(t->htable_bits); i++) {
 -		n = __ipset_dereference_protected(hbucket(t, i), 1);
 -		if (!n)
 -			continue;
 -		for (j = 0, d = 0; j < n->pos; j++) {
 -			if (!test_bit(j, n->used)) {
 -				d++;
 -				continue;
 -			}
 +		n = hbucket(t, i);
 +		for (j = 0; j < n->pos; j++) {
  			data = ahash_data(n, j, dsize);
 -			if (!ip_set_timeout_expired(ext_timeout(data, set)))
 -				continue;
 -			pr_debug("expired %u/%u\n", i, j);
 -			clear_bit(j, n->used);
 -			smp_mb__after_atomic();
 +			if (ip_set_timeout_expired(ext_timeout(data, h))) {
 +				pr_debug("expired %u/%u\n", i, j);
  #ifdef IP_SET_HASH_WITH_NETS
++<<<<<<< HEAD
 +				mtype_del_cidr(h, CIDR(data->cidr),
 +					       nets_length);
++=======
+ 			for (k = 0; k < IPSET_NET_COUNT; k++)
+ 				mtype_del_cidr(h,
+ 					NCIDR_PUT(DCIDR_GET(data->cidr, k)),
+ 					k);
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  #endif
 -			ip_set_ext_destroy(set, data);
 -			set->elements--;
 -			d++;
 -		}
 -		if (d >= AHASH_INIT_SIZE) {
 -			if (d >= n->size) {
 -				rcu_assign_pointer(hbucket(t, i), NULL);
 -				kfree_rcu(n, rcu);
 -				continue;
 +				if (j != n->pos - 1)
 +					/* Not last one */
 +					memcpy(data,
 +					       ahash_data(n, n->pos - 1, dsize),
 +					       dsize);
 +				n->pos--;
 +				h->elements--;
  			}
 -			tmp = kzalloc(sizeof(*tmp) +
 -				      (n->size - AHASH_INIT_SIZE) * dsize,
 -				      GFP_ATOMIC);
 +		}
 +		if (n->pos + AHASH_INIT_SIZE < n->size) {
 +			void *tmp = kzalloc((n->size - AHASH_INIT_SIZE)
 +					    * dsize,
 +					    GFP_ATOMIC);
  			if (!tmp)
  				/* Still try to delete expired elements */
  				continue;
@@@ -631,34 -759,60 +702,46 @@@ mtype_add(struct ip_set *set, void *val
  		}
  		/* Reuse first timed out entry */
  		if (SET_WITH_TIMEOUT(set) &&
 -		    ip_set_timeout_expired(ext_timeout(data, set)) &&
 -		    j == -1) {
 +		    ip_set_timeout_expired(ext_timeout(data, h)) &&
 +		    j != AHASH_MAX(h) + 1)
  			j = i;
 -			reuse = true;
 -		}
  	}
 -	if (reuse || forceadd) {
 -		data = ahash_data(n, j, set->dsize);
 -		if (!deleted) {
 +reuse_slot:
 +	if (j != AHASH_MAX(h) + 1) {
 +		/* Fill out reused slot */
 +		data = ahash_data(n, j, h->dsize);
  #ifdef IP_SET_HASH_WITH_NETS
++<<<<<<< HEAD
 +		mtype_del_cidr(h, CIDR(data->cidr), NETS_LENGTH(set->family));
 +		mtype_add_cidr(h, CIDR(d->cidr), NETS_LENGTH(set->family));
++=======
+ 			for (i = 0; i < IPSET_NET_COUNT; i++)
+ 				mtype_del_cidr(h,
+ 					NCIDR_PUT(DCIDR_GET(data->cidr, i)),
+ 					i);
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  #endif
 -			ip_set_ext_destroy(set, data);
 -			set->elements--;
 -		}
 -		goto copy_data;
 -	}
 -	if (set->elements >= h->maxelem)
 -		goto set_full;
 -	/* Create a new slot */
 -	if (n->pos >= n->size) {
 +	} else {
 +		/* Use/create a new slot */
  		TUNE_AHASH_MAX(h, multi);
 -		if (n->size >= AHASH_MAX(h)) {
 -			/* Trigger rehashing */
 -			mtype_data_next(&h->next, d);
 -			return -EAGAIN;
 +		ret = hbucket_elem_add(n, AHASH_MAX(h), h->dsize);
 +		if (ret != 0) {
 +			if (ret == -EAGAIN)
 +				mtype_data_next(&h->next, d);
 +			goto out;
  		}
 -		old = n;
 -		n = kzalloc(sizeof(*n) +
 -			    (old->size + AHASH_INIT_SIZE) * set->dsize,
 -			    GFP_ATOMIC);
 -		if (!n)
 -			return -ENOMEM;
 -		memcpy(n, old, sizeof(struct hbucket) +
 -		       old->size * set->dsize);
 -		n->size = old->size + AHASH_INIT_SIZE;
 -		set->ext_size += AHASH_INIT_SIZE * set->dsize;
 -	}
 -
 -copy_elem:
 -	j = n->pos++;
 -	data = ahash_data(n, j, set->dsize);
 -copy_data:
 -	set->elements++;
 +		data = ahash_data(n, n->pos++, h->dsize);
  #ifdef IP_SET_HASH_WITH_NETS
++<<<<<<< HEAD
 +		mtype_add_cidr(h, CIDR(d->cidr), NETS_LENGTH(set->family));
++=======
+ 	for (i = 0; i < IPSET_NET_COUNT; i++)
+ 		mtype_add_cidr(h, NCIDR_PUT(DCIDR_GET(d->cidr, i)), i);
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  #endif
 +		h->elements++;
 +	}
  	memcpy(data, d, sizeof(struct mtype_elem));
 -overwrite_extensions:
  #ifdef IP_SET_HASH_WITH_NETS
  	mtype_data_set_flags(data, flags);
  #endif
@@@ -694,33 -870,55 +777,39 @@@ mtype_del(struct ip_set *set, void *val
  		if (!mtype_data_equal(data, d, &multi))
  			continue;
  		if (SET_WITH_TIMEOUT(set) &&
 -		    ip_set_timeout_expired(ext_timeout(data, set)))
 -			goto out;
 +		    ip_set_timeout_expired(ext_timeout(data, h)))
 +			return -IPSET_ERR_EXIST;
 +		if (i != n->pos - 1)
 +			/* Not last one */
 +			memcpy(data, ahash_data(n, n->pos - 1, h->dsize),
 +			       h->dsize);
  
 -		ret = 0;
 -		clear_bit(i, n->used);
 -		smp_mb__after_atomic();
 -		if (i + 1 == n->pos)
 -			n->pos--;
 -		set->elements--;
 +		n->pos--;
 +		h->elements--;
  #ifdef IP_SET_HASH_WITH_NETS
++<<<<<<< HEAD
 +		mtype_del_cidr(h, CIDR(d->cidr), NETS_LENGTH(set->family));
++=======
+ 		for (j = 0; j < IPSET_NET_COUNT; j++)
+ 			mtype_del_cidr(h, NCIDR_PUT(DCIDR_GET(d->cidr, j)),
+ 				       j);
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  #endif
 -		ip_set_ext_destroy(set, data);
 -
 -		for (; i < n->pos; i++) {
 -			if (!test_bit(i, n->used))
 -				k++;
 -		}
 -		if (n->pos == 0 && k == 0) {
 -			set->ext_size -= sizeof(*n) + n->size * dsize;
 -			rcu_assign_pointer(hbucket(t, key), NULL);
 -			kfree_rcu(n, rcu);
 -		} else if (k >= AHASH_INIT_SIZE) {
 -			struct hbucket *tmp = kzalloc(sizeof(*tmp) +
 -					(n->size - AHASH_INIT_SIZE) * dsize,
 -					GFP_ATOMIC);
 +		if (n->pos + AHASH_INIT_SIZE < n->size) {
 +			void *tmp = kzalloc((n->size - AHASH_INIT_SIZE)
 +					    * h->dsize,
 +					    GFP_ATOMIC);
  			if (!tmp)
 -				goto out;
 -			tmp->size = n->size - AHASH_INIT_SIZE;
 -			for (j = 0, k = 0; j < n->pos; j++) {
 -				if (!test_bit(j, n->used))
 -					continue;
 -				data = ahash_data(n, j, dsize);
 -				memcpy(tmp->value + k * dsize, data, dsize);
 -				set_bit(j, tmp->used);
 -				k++;
 -			}
 -			tmp->pos = k;
 -			set->ext_size -= AHASH_INIT_SIZE * dsize;
 -			rcu_assign_pointer(hbucket(t, key), tmp);
 -			kfree_rcu(n, rcu);
 +				return 0;
 +			n->size -= AHASH_INIT_SIZE;
 +			memcpy(tmp, n->value, n->size * h->dsize);
 +			kfree(n->value);
 +			n->value = tmp;
  		}
 -		goto out;
 +		return 0;
  	}
  
 -out:
 -	return ret;
 +	return -IPSET_ERR_EXIST;
  }
  
  static inline int
@@@ -743,20 -944,37 +832,36 @@@ mtype_test_cidrs(struct ip_set *set, st
  		 struct ip_set_ext *mext, u32 flags)
  {
  	struct htype *h = set->data;
 -	struct htable *t = rcu_dereference_bh(h->table);
 +	struct htable *t = h->table;
  	struct hbucket *n;
  	struct mtype_elem *data;
 -#if IPSET_NET_COUNT == 2
 -	struct mtype_elem orig = *d;
 -	int i, j = 0, k;
 -#else
  	int i, j = 0;
 -#endif
  	u32 key, multi = 0;
++<<<<<<< HEAD
 +	u8 nets_length = NETS_LENGTH(set->family);
 +
 +	pr_debug("test by nets\n");
 +	for (; j < nets_length && h->nets[j].nets && !multi; j++) {
 +		mtype_data_netmask(d, h->nets[j].cidr);
++=======
+ 
+ 	pr_debug("test by nets\n");
+ 	for (; j < NLEN && h->nets[j].cidr[0] && !multi; j++) {
+ #if IPSET_NET_COUNT == 2
+ 		mtype_data_reset_elem(d, &orig);
+ 		mtype_data_netmask(d, NCIDR_GET(h->nets[j].cidr[0]), false);
+ 		for (k = 0; k < NLEN && h->nets[k].cidr[1] && !multi;
+ 		     k++) {
+ 			mtype_data_netmask(d, NCIDR_GET(h->nets[k].cidr[1]),
+ 					   true);
+ #else
+ 		mtype_data_netmask(d, NCIDR_GET(h->nets[j].cidr[0]));
+ #endif
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  		key = HKEY(d, h->initval, t->htable_bits);
 -		n =  rcu_dereference_bh(hbucket(t, key));
 -		if (!n)
 -			continue;
 +		n = hbucket(t, key);
  		for (i = 0; i < n->pos; i++) {
 -			if (!test_bit(i, n->used))
 -				continue;
 -			data = ahash_data(n, i, set->dsize);
 +			data = ahash_data(n, i, h->dsize);
  			if (!mtype_data_equal(data, d, &multi))
  				continue;
  			if (SET_WITH_TIMEOUT(set)) {
@@@ -787,14 -1008,21 +892,26 @@@ mtype_test(struct ip_set *set, void *va
  	struct mtype_elem *d = value;
  	struct hbucket *n;
  	struct mtype_elem *data;
 -	int i, ret = 0;
 +	int i;
  	u32 key, multi = 0;
  
 -	t = rcu_dereference_bh(h->table);
  #ifdef IP_SET_HASH_WITH_NETS
  	/* If we test an IP address and not a network address,
++<<<<<<< HEAD
 +	 * try all possible network sizes */
 +	if (CIDR(d->cidr) == SET_HOST_MASK(set->family))
 +		return mtype_test_cidrs(set, d, ext, mext, flags);
++=======
+ 	 * try all possible network sizes
+ 	 */
+ 	for (i = 0; i < IPSET_NET_COUNT; i++)
+ 		if (DCIDR_GET(d->cidr, i) != HOST_MASK)
+ 			break;
+ 	if (i == IPSET_NET_COUNT) {
+ 		ret = mtype_test_cidrs(set, d, ext, mext, flags);
+ 		goto out;
+ 	}
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  #endif
  
  	key = HKEY(d, h->initval, t->htable_bits);
@@@ -814,12 -1051,16 +931,20 @@@ static in
  mtype_head(struct ip_set *set, struct sk_buff *skb)
  {
  	const struct htype *h = set->data;
 -	const struct htable *t;
  	struct nlattr *nested;
  	size_t memsize;
 -	u8 htable_bits;
  
++<<<<<<< HEAD
 +	read_lock_bh(&set->lock);
 +	memsize = mtype_ahash_memsize(h, NETS_LENGTH(set->family));
 +	read_unlock_bh(&set->lock);
++=======
+ 	rcu_read_lock_bh();
+ 	t = rcu_dereference_bh_nfnl(h->table);
+ 	memsize = mtype_ahash_memsize(h, t) + set->ext_size;
+ 	htable_bits = t->htable_bits;
+ 	rcu_read_unlock_bh();
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  
  	nested = ipset_nest_start(skb, IPSET_ATTR_DATA);
  	if (!nested)
@@@ -992,7 -1282,15 +1117,11 @@@ IPSET_TOKEN(HTYPE, _create)(struct net 
  
  	hsize = sizeof(*h);
  #ifdef IP_SET_HASH_WITH_NETS
++<<<<<<< HEAD
 +	hsize += sizeof(struct net_prefixes) * NETS_LENGTH(set->family);
++=======
+ 	hsize += sizeof(struct net_prefixes) * NLEN;
++>>>>>>> cee8b97b6c13 (netfilter: ipset: Make NLEN compile time constant for hash types)
  #endif
  	h = kzalloc(hsize, GFP_KERNEL);
  	if (!h)
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
