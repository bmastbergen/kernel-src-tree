EDAC, sb_edac: Add support for systems with segmented PCI buses

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [edac] sb_edac: Add support for systems with segmented PCI buses (Aristeu Rozanski) [1600649]
Rebuild_FUZZ: 95.00%
commit-author Masayoshi Mizuma <m.mizuma@jp.fujitsu.com>
commit 190bd6e98afc512fb16d4a471acd488e36141637
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/190bd6e9.failed

Extend the driver to check whether segment number and bus number matches
when deciding how to group memory controller PCI devices to CPU sockets.

	Signed-off-by: Masayoshi Mizuma <m.mizuma@jp.fujitsu.com>
	Reviewed-by: Tony Luck <tony.luck@intel.com>
	Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
	Cc: linux-edac <linux-edac@vger.kernel.org>
Link: http://lkml.kernel.org/r/20180724190213.26359-1-msys.mizuma@gmail.com
[ Cleanup commit message. ]
	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit 190bd6e98afc512fb16d4a471acd488e36141637)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/sb_edac.c
diff --cc drivers/edac/sb_edac.c
index 4d11a3328f84,07726fb00321..000000000000
--- a/drivers/edac/sb_edac.c
+++ b/drivers/edac/sb_edac.c
@@@ -727,7 -730,9 +728,13 @@@ static inline int numcol(u32 mtr
  	return 1 << cols;
  }
  
++<<<<<<< HEAD
 +static struct sbridge_dev *get_sbridge_dev(u8 bus, int multi_bus)
++=======
+ static struct sbridge_dev *get_sbridge_dev(int seg, u8 bus, enum domain dom,
+ 					   int multi_bus,
+ 					   struct sbridge_dev *prev)
++>>>>>>> 190bd6e98afc (EDAC, sb_edac: Add support for systems with segmented PCI buses)
  {
  	struct sbridge_dev *sbridge_dev;
  
@@@ -740,15 -745,20 +747,29 @@@
  				struct sbridge_dev, list);
  	}
  
++<<<<<<< HEAD
 +	list_for_each_entry(sbridge_dev, &sbridge_edac_list, list) {
 +		if (sbridge_dev->bus == bus)
++=======
+ 	sbridge_dev = list_entry(prev ? prev->list.next
+ 				      : sbridge_edac_list.next, struct sbridge_dev, list);
+ 
+ 	list_for_each_entry_from(sbridge_dev, &sbridge_edac_list, list) {
+ 		if ((sbridge_dev->seg == seg) && (sbridge_dev->bus == bus) &&
+ 				(dom == SOCK || dom == sbridge_dev->dom))
++>>>>>>> 190bd6e98afc (EDAC, sb_edac: Add support for systems with segmented PCI buses)
  			return sbridge_dev;
  	}
  
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static struct sbridge_dev *alloc_sbridge_dev(u8 bus, enum domain dom, const struct pci_id_table *table)
++=======
+ static struct sbridge_dev *alloc_sbridge_dev(int seg, u8 bus, enum domain dom,
+ 					     const struct pci_id_table *table)
++>>>>>>> 190bd6e98afc (EDAC, sb_edac: Add support for systems with segmented PCI buses)
  {
  	struct sbridge_dev *sbridge_dev;
  
@@@ -762,9 -774,10 +783,10 @@@
  		return NULL;
  	}
  
+ 	sbridge_dev->seg = seg;
  	sbridge_dev->bus = bus;
  	sbridge_dev->dom = dom;
 -	sbridge_dev->n_devs = table->n_devs_per_imc;
 +	sbridge_dev->n_devs = table->n_devs_per_sock;
  	list_add_tail(&sbridge_dev->list, &sbridge_edac_list);
  
  	return sbridge_dev;
@@@ -2287,10 -2247,12 +2309,11 @@@ static int sbridge_get_onedevice(struc
  				 const unsigned devno,
  				 const int multi_bus)
  {
 -	struct sbridge_dev *sbridge_dev = NULL;
 +	struct sbridge_dev *sbridge_dev;
  	const struct pci_id_descr *dev_descr = &table->descr[devno];
  	struct pci_dev *pdev = NULL;
+ 	int seg = 0;
  	u8 bus = 0;
 -	int i = 0;
  
  	sbridge_printk(KERN_DEBUG,
  		"Seeking for: PCI ID %04x:%04x\n",
@@@ -2319,9 -2281,12 +2342,16 @@@
  		/* End of list, leave */
  		return -ENODEV;
  	}
+ 	seg = pci_domain_nr(pdev->bus);
  	bus = pdev->bus->number;
  
++<<<<<<< HEAD
 +	sbridge_dev = get_sbridge_dev(bus, multi_bus);
++=======
+ next_imc:
+ 	sbridge_dev = get_sbridge_dev(seg, bus, dev_descr->dom,
+ 				      multi_bus, sbridge_dev);
++>>>>>>> 190bd6e98afc (EDAC, sb_edac: Add support for systems with segmented PCI buses)
  	if (!sbridge_dev) {
  		/* If the HA1 wasn't found, don't create EDAC second memory controller */
  		if (dev_descr->dom == IMC1 && devno != 1) {
* Unmerged path drivers/edac/sb_edac.c
