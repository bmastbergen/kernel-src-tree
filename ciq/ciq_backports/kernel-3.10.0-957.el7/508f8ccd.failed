netfilter: nf_tables: introduce nft_chain_parse_hook()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 508f8ccdab0ef530dbc0ef8bb526ee11acc409ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/508f8ccd.failed

Introduce a new function to wrap the code that parses the chain hook
configuration so we can reuse this code to validate chain updates.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 508f8ccdab0ef530dbc0ef8bb526ee11acc409ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index 3611175e1d49,463fcada6074..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -1211,7 -1283,7 +1288,11 @@@ static int nf_tables_newchain(struct ne
  	struct nft_table *table;
  	struct nft_chain *chain;
  	struct nft_base_chain *basechain = NULL;
++<<<<<<< HEAD
 +	struct nlattr *ha[NFTA_HOOK_MAX + 1];
++=======
+ 	u8 genmask = nft_genmask_next(net);
++>>>>>>> 508f8ccdab0e (netfilter: nf_tables: introduce nft_chain_parse_hook())
  	int family = nfmsg->nfgen_family;
  	u8 policy = NF_ACCEPT;
  	u64 handle = 0;
@@@ -1319,45 -1395,23 +1400,47 @@@
  		return -EOVERFLOW;
  
  	if (nla[NFTA_CHAIN_HOOK]) {
- 		const struct nf_chain_type *type;
+ 		struct nft_chain_hook hook;
  		struct nf_hook_ops *ops;
  		nf_hookfn *hookfn;
- 		u32 hooknum, priority;
- 
- 		type = chain_type[family][NFT_CHAIN_T_DEFAULT];
- 		if (nla[NFTA_CHAIN_TYPE]) {
- 			type = nf_tables_chain_type_lookup(afi,
- 							   nla[NFTA_CHAIN_TYPE],
- 							   create);
- 			if (IS_ERR(type))
- 				return PTR_ERR(type);
- 		}
  
- 		err = nla_parse_nested(ha, NFTA_HOOK_MAX, nla[NFTA_CHAIN_HOOK],
- 				       nft_hook_policy);
+ 		err = nft_chain_parse_hook(net, nla, afi, &hook, create);
  		if (err < 0)
  			return err;
++<<<<<<< HEAD
 +		if (ha[NFTA_HOOK_HOOKNUM] == NULL ||
 +		    ha[NFTA_HOOK_PRIORITY] == NULL)
 +			return -EINVAL;
 +
 +		hooknum = ntohl(nla_get_be32(ha[NFTA_HOOK_HOOKNUM]));
 +		if (hooknum >= afi->nhooks)
 +			return -EINVAL;
 +		priority = ntohl(nla_get_be32(ha[NFTA_HOOK_PRIORITY]));
 +
 +		if (!(type->hook_mask & (1 << hooknum)))
 +			return -EOPNOTSUPP;
 +		if (!try_module_get(type->owner))
 +			return -ENOENT;
 +		hookfn = type->hooks[hooknum];
 +
 +		basechain = kzalloc(sizeof(*basechain), GFP_KERNEL);
 +		if (basechain == NULL) {
 +			module_put(type->owner);
 +			return -ENOMEM;
 +		}
 +
++=======
+ 
+ 		basechain = kzalloc(sizeof(*basechain), GFP_KERNEL);
+ 		if (basechain == NULL) {
+ 			nft_chain_release_hook(&hook);
+ 			return -ENOMEM;
+ 		}
+ 
+ 		if (hook.dev != NULL)
+ 			strncpy(basechain->dev_name, hook.dev->name, IFNAMSIZ);
+ 
++>>>>>>> 508f8ccdab0e (netfilter: nf_tables: introduce nft_chain_parse_hook())
  		if (nla[NFTA_CHAIN_COUNTERS]) {
  			stats = nft_stats_alloc(nla[NFTA_CHAIN_COUNTERS]);
  			if (IS_ERR(stats)) {
@@@ -1376,18 -1430,18 +1459,31 @@@
  			rcu_assign_pointer(basechain->stats, stats);
  		}
  
++<<<<<<< HEAD
 +		write_pnet(&basechain->pnet, net);
 +		basechain->type = type;
++=======
+ 		hookfn = hook.type->hooks[hook.num];
+ 		basechain->type = hook.type;
++>>>>>>> 508f8ccdab0e (netfilter: nf_tables: introduce nft_chain_parse_hook())
  		chain = &basechain->chain;
  
  		for (i = 0; i < afi->nops; i++) {
  			ops = &basechain->ops[i];
  			ops->pf		= family;
++<<<<<<< HEAD
 +			ops->owner	= afi->owner;
 +			ops->hooknum	= hooknum;
 +			ops->priority	= priority;
 +			ops->priv	= chain;
 +			ops->hook	= afi->hooks[ops->hooknum];
++=======
+ 			ops->hooknum	= hook.num;
+ 			ops->priority	= hook.priority;
+ 			ops->priv	= chain;
+ 			ops->hook	= afi->hooks[ops->hooknum];
+ 			ops->dev	= hook.dev;
++>>>>>>> 508f8ccdab0e (netfilter: nf_tables: introduce nft_chain_parse_hook())
  			if (hookfn)
  				ops->hook = hookfn;
  			if (afi->hook_ops_init)
* Unmerged path net/netfilter/nf_tables_api.c
