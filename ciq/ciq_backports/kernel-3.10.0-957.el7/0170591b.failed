PCI/MSI: Skip disabling disconnected devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [pci] msi: Skip disabling disconnected devices (Myron Stowe) [1523998]
Rebuild_FUZZ: 95.24%
commit-author Keith Busch <keith.busch@intel.com>
commit 0170591bb06788034ae72bfa56e42f283ab3de5a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0170591b.failed

Check the device connected state prior to executing device shutdown
operations or writing MSI messages so that tear down on disconnected
devices completes quicker.

	Tested-by: Krishna Dhulipala <krishnad@fb.com>
	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Wei Zhang <wzhang@fb.com>
(cherry picked from commit 0170591bb06788034ae72bfa56e42f283ab3de5a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/msi.c
diff --cc drivers/pci/msi.c
index 49ffa5581f51,33e766a9dd91..000000000000
--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@@ -271,34 -294,11 +271,38 @@@ void __read_msi_msg(struct msi_desc *en
  	}
  }
  
 -void __pci_write_msi_msg(struct msi_desc *entry, struct msi_msg *msg)
 +void read_msi_msg(unsigned int irq, struct msi_msg *msg)
 +{
 +	struct msi_desc *entry = irq_get_msi_desc(irq);
 +
++<<<<<<< HEAD
 +	__read_msi_msg(entry, msg);
 +}
 +
 +void __get_cached_msi_msg(struct msi_desc *entry, struct msi_msg *msg)
 +{
 +	/* Assert that the cache is valid, assuming that
 +	 * valid messages are not all-zeroes. */
 +	BUG_ON(!(entry->msg.address_hi | entry->msg.address_lo |
 +		 entry->msg.data));
 +
 +	*msg = entry->msg;
 +}
 +
 +void get_cached_msi_msg(unsigned int irq, struct msi_msg *msg)
  {
 -	struct pci_dev *dev = msi_desc_to_pci_dev(entry);
 +	struct msi_desc *entry = irq_get_msi_desc(irq);
  
 +	__get_cached_msi_msg(entry, msg);
 +}
 +EXPORT_SYMBOL_GPL(get_cached_msi_msg);
 +
 +void __write_msi_msg(struct msi_desc *entry, struct msi_msg *msg)
 +{
 +	if (entry->dev->current_state != PCI_D0) {
++=======
+ 	if (dev->current_state != PCI_D0 || pci_dev_is_disconnected(dev)) {
++>>>>>>> 0170591bb067 (PCI/MSI: Skip disabling disconnected devices)
  		/* Don't touch the hardware now */
  	} else if (entry->msi_attrib.is_msix) {
  		void __iomem *base = pci_msix_desc_addr(entry);
@@@ -1084,10 -1001,15 +1088,15 @@@ void pci_msix_shutdown(struct pci_dev *
  	if (!pci_msi_enable || !dev || !dev->msix_enabled)
  		return;
  
+ 	if (pci_dev_is_disconnected(dev)) {
+ 		dev->msix_enabled = 0;
+ 		return;
+ 	}
+ 
  	/* Return the device with MSI-X masked as initial states */
 -	for_each_pci_msi_entry(entry, dev) {
 +	list_for_each_entry(entry, &dev->msi_list, list) {
  		/* Keep cached states to be restored */
 -		__pci_msix_desc_mask_irq(entry, 1);
 +		arch_msix_mask_irq(entry, 1);
  	}
  
  	pci_msix_clear_and_set_ctrl(dev, PCI_MSIX_FLAGS_ENABLE, 0);
* Unmerged path drivers/pci/msi.c
