ceph: quota: support for ceph.quota.max_files

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Luis Henriques <lhenriques@suse.com>
commit b7a2921765cf796280baf653a52b22b52e0ba266
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b7a29217.failed

This patch adds support for the max_files quota.  It hooks into all the
ceph functions that add new filesystem objects that need to be checked
against the quota limits.  When these limits are hit, -EDQUOT is returned.

Note that we're not checking quotas on ceph_link().  ceph_link doesn't
really create a new inode,  and since the MDS doesn't update the directory
statistics when a new (hard) link is created (only with symlinks), they
are not accounted as a new file.

	Signed-off-by: Luis Henriques <lhenriques@suse.com>
	Reviewed-by: "Yan, Zheng" <zyan@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit b7a2921765cf796280baf653a52b22b52e0ba266)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/quota.c
#	fs/ceph/super.h
diff --cc fs/ceph/super.h
index 2ea6359d8d08,4afc6cca8786..000000000000
--- a/fs/ceph/super.h
+++ b/fs/ceph/super.h
@@@ -1022,4 -1073,10 +1022,13 @@@ extern int lock_to_ceph_filelock(struc
  extern int ceph_fs_debugfs_init(struct ceph_fs_client *client);
  extern void ceph_fs_debugfs_cleanup(struct ceph_fs_client *client);
  
++<<<<<<< HEAD
++=======
+ /* quota.c */
+ extern void ceph_handle_quota(struct ceph_mds_client *mdsc,
+ 			      struct ceph_mds_session *session,
+ 			      struct ceph_msg *msg);
+ extern bool ceph_quota_is_max_files_exceeded(struct inode *inode);
+ 
++>>>>>>> b7a2921765cf (ceph: quota: support for ceph.quota.max_files)
  #endif /* _FS_CEPH_SUPER_H */
* Unmerged path fs/ceph/quota.c
diff --git a/fs/ceph/dir.c b/fs/ceph/dir.c
index 83040cdc8671..24e27d5b2e91 100644
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@ -845,6 +845,9 @@ static int ceph_mknod(struct inode *dir, struct dentry *dentry,
 	if (ceph_snap(dir) != CEPH_NOSNAP)
 		return -EROFS;
 
+	if (ceph_quota_is_max_files_exceeded(dir))
+		return -EDQUOT;
+
 	err = ceph_pre_init_acls(dir, &mode, &acls);
 	if (err < 0)
 		return err;
@@ -898,6 +901,9 @@ static int ceph_symlink(struct inode *dir, struct dentry *dentry,
 	if (ceph_snap(dir) != CEPH_NOSNAP)
 		return -EROFS;
 
+	if (ceph_quota_is_max_files_exceeded(dir))
+		return -EDQUOT;
+
 	dout("symlink in dir %p dentry %p to '%s'\n", dir, dentry, dest);
 	req = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SYMLINK, USE_AUTH_MDS);
 	if (IS_ERR(req)) {
@@ -947,6 +953,11 @@ static int ceph_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 		goto out;
 	}
 
+	if (ceph_quota_is_max_files_exceeded(dir)) {
+		err = -EDQUOT;
+		goto out;
+	}
+
 	mode |= S_IFDIR;
 	err = ceph_pre_init_acls(dir, &mode, &acls);
 	if (err < 0)
diff --git a/fs/ceph/file.c b/fs/ceph/file.c
index 7fa7d870dbaf..f9300f431288 100644
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@ -374,7 +374,7 @@ int ceph_atomic_open(struct inode *dir, struct dentry *dentry,
 	struct ceph_mds_request *req;
 	struct dentry *dn;
 	struct ceph_acls_info acls = {};
-       int mask;
+	int mask;
 	int err;
 
 	dout("atomic_open %p dentry %p '%pd' %s flags %d mode 0%o\n",
@@ -389,6 +389,8 @@ int ceph_atomic_open(struct inode *dir, struct dentry *dentry,
 		return err;
 
 	if (flags & O_CREAT) {
+		if (ceph_quota_is_max_files_exceeded(dir))
+			return -EDQUOT;
 		err = ceph_pre_init_acls(dir, &mode, &acls);
 		if (err < 0)
 			return err;
* Unmerged path fs/ceph/quota.c
* Unmerged path fs/ceph/super.h
