xfs: prepare xfs_break_layouts() to be called with XFS_MMAPLOCK_EXCL

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit c63a8eae63d3859c9c7067aa239a4cfd7423a665
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c63a8eae.failed

In preparation for adding coordination between extent unmap operations
and busy dax-pages, update xfs_break_layouts() to permit it to be called
with the mmap lock held. This lock scheme will be required for
coordinating the break of 'dax layouts' (non-idle dax (ZONE_DEVICE)
pages mapped into the file's address space). Breaking dax layouts will
be added to xfs_break_layouts() in a future patch, for now this preps
the unmap call sites to take and hold XFS_MMAPLOCK_EXCL over the call to
xfs_break_layouts().

	Cc: "Darrick J. Wong" <darrick.wong@oracle.com>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: Dave Chinner <david@fromorbit.com>
	Suggested-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: "Darrick J. Wong" <darrick.wong@oracle.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit c63a8eae63d3859c9c7067aa239a4cfd7423a665)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_iops.c
#	fs/xfs/xfs_pnfs.c
diff --cc fs/xfs/xfs_iops.c
index 8c9150043298,138fb36ca875..000000000000
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@@ -1022,17 -1031,19 +1022,33 @@@ xfs_vn_setattr
  
  	if (iattr->ia_valid & ATTR_SIZE) {
  		struct xfs_inode	*ip = XFS_I(d_inode(dentry));
++<<<<<<< HEAD
 +		uint			iolock = XFS_IOLOCK_EXCL;
 +
 +		xfs_ilock(ip, iolock);
 +		error = xfs_break_layouts(dentry->d_inode, &iolock, true);
 +		if (!error) {
 +			xfs_ilock(ip, XFS_MMAPLOCK_EXCL);
 +			iolock |= XFS_MMAPLOCK_EXCL;
 +
 +			error = xfs_vn_setattr_size(dentry, iattr);
 +		}
 +		xfs_iunlock(ip, iolock);
++=======
+ 		uint			iolock;
+ 
+ 		xfs_ilock(ip, XFS_MMAPLOCK_EXCL);
+ 		iolock = XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL;
+ 
+ 		error = xfs_break_layouts(d_inode(dentry), &iolock);
+ 		if (error) {
+ 			xfs_iunlock(ip, XFS_MMAPLOCK_EXCL);
+ 			return error;
+ 		}
+ 
+ 		error = xfs_vn_setattr_size(dentry, iattr);
+ 		xfs_iunlock(ip, XFS_MMAPLOCK_EXCL);
++>>>>>>> c63a8eae63d3 (xfs: prepare xfs_break_layouts() to be called with XFS_MMAPLOCK_EXCL)
  	} else {
  		error = xfs_vn_setattr_nonsize(dentry, iattr);
  	}
diff --cc fs/xfs/xfs_pnfs.c
index 28b343e7dd14,6ea7b0b55d02..000000000000
--- a/fs/xfs/xfs_pnfs.c
+++ b/fs/xfs/xfs_pnfs.c
@@@ -42,12 -42,9 +42,17 @@@ xfs_break_layouts
  
  	while ((error = break_layout(inode, false) == -EWOULDBLOCK)) {
  		xfs_iunlock(ip, *iolock);
 +		if (with_imutex && (*iolock & XFS_IOLOCK_EXCL))
 +			mutex_unlock(&inode->i_mutex);
  		error = break_layout(inode, true);
++<<<<<<< HEAD
 +		*iolock = XFS_IOLOCK_EXCL;
 +		if (with_imutex)
 +			mutex_lock(&inode->i_mutex);
++=======
+ 		*iolock &= ~XFS_IOLOCK_SHARED;
+ 		*iolock |= XFS_IOLOCK_EXCL;
++>>>>>>> c63a8eae63d3 (xfs: prepare xfs_break_layouts() to be called with XFS_MMAPLOCK_EXCL)
  		xfs_ilock(ip, *iolock);
  	}
  
diff --git a/fs/xfs/xfs_file.c b/fs/xfs/xfs_file.c
index cea567087acc..4b84d0937bdf 100644
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@ -913,7 +913,7 @@ xfs_file_fallocate(
 	struct xfs_inode	*ip = XFS_I(inode);
 	long			error;
 	enum xfs_prealloc_flags	flags = 0;
-	uint			iolock = XFS_IOLOCK_EXCL;
+	uint			iolock = XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL;
 	loff_t			new_size = 0;
 
 	if (!S_ISREG(inode->i_mode))
@@ -927,9 +927,6 @@ xfs_file_fallocate(
 	if (error)
 		goto out_unlock;
 
-	xfs_ilock(ip, XFS_MMAPLOCK_EXCL);
-	iolock |= XFS_MMAPLOCK_EXCL;
-
 	if (mode & FALLOC_FL_PUNCH_HOLE) {
 		error = xfs_free_file_space(ip, offset, len);
 		if (error)
diff --git a/fs/xfs/xfs_ioctl.c b/fs/xfs/xfs_ioctl.c
index 16aae82f734b..2d7a7c193a25 100644
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@ -648,7 +648,7 @@ xfs_ioc_space(
 	struct xfs_inode	*ip = XFS_I(inode);
 	struct iattr		iattr;
 	enum xfs_prealloc_flags	flags = 0;
-	uint			iolock = XFS_IOLOCK_EXCL;
+	uint			iolock = XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL;
 	int			error;
 
 	/*
@@ -682,9 +682,6 @@ xfs_ioc_space(
 	if (error)
 		goto out_unlock;
 
-	xfs_ilock(ip, XFS_MMAPLOCK_EXCL);
-	iolock |= XFS_MMAPLOCK_EXCL;
-
 	switch (bf->l_whence) {
 	case 0: /*SEEK_SET*/
 		break;
* Unmerged path fs/xfs/xfs_iops.c
* Unmerged path fs/xfs/xfs_pnfs.c
