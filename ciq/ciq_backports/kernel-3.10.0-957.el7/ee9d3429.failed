net/sched/sch_red.c: work around gcc-4.4.4 anon union initializer issue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] sched: red: work around gcc-4.4.4 anon union initializer issue (Ivan Vecera) [1583702]
Rebuild_FUZZ: 90.23%
commit-author Andrew Morton <akpm@linux-foundation.org>
commit ee9d3429c0e47a57e3e73b638785cafa33773639
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/ee9d3429.failed

gcc-4.4.4 (at lest) has issues with initializers and anonymous unions:

net/sched/sch_red.c: In function 'red_dump_offload':
net/sched/sch_red.c:282: error: unknown field 'stats' specified in initializer
net/sched/sch_red.c:282: warning: initialization makes integer from pointer without a cast
net/sched/sch_red.c:283: error: unknown field 'stats' specified in initializer
net/sched/sch_red.c:283: warning: initialization makes integer from pointer without a cast
net/sched/sch_red.c: In function 'red_dump_stats':
net/sched/sch_red.c:352: error: unknown field 'xstats' specified in initializer
net/sched/sch_red.c:352: warning: initialization makes integer from pointer without a cast

Work around this.

Fixes: 602f3baf2218 ("net_sch: red: Add offload ability to RED qdisc")
	Cc: Nogah Frankel <nogahf@mellanox.com>
	Cc: Jiri Pirko <jiri@mellanox.com>
	Cc: Simon Horman <simon.horman@netronome.com>
	Cc: David S. Miller <davem@davemloft.net>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ee9d3429c0e47a57e3e73b638785cafa33773639)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_red.c
diff --cc net/sched/sch_red.c
index ffa7875f9b91,7f8ea9e297c3..000000000000
--- a/net/sched/sch_red.c
+++ b/net/sched/sch_red.c
@@@ -242,6 -272,35 +242,38 @@@ static int red_init(struct Qdisc *sch, 
  	return red_change(sch, opt);
  }
  
++<<<<<<< HEAD
++=======
+ static int red_dump_offload(struct Qdisc *sch, struct tc_red_qopt *opt)
+ {
+ 	struct net_device *dev = qdisc_dev(sch);
+ 	struct tc_red_qopt_offload hw_stats = {
+ 		.command = TC_RED_STATS,
+ 		.handle = sch->handle,
+ 		.parent = sch->parent,
+ 		{
+ 			.stats.bstats = &sch->bstats,
+ 			.stats.qstats = &sch->qstats,
+ 		},
+ 	};
+ 	int err;
+ 
+ 	opt->flags &= ~TC_RED_OFFLOADED;
+ 	if (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)
+ 		return 0;
+ 
+ 	err = dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_RED,
+ 					    &hw_stats);
+ 	if (err == -EOPNOTSUPP)
+ 		return 0;
+ 
+ 	if (!err)
+ 		opt->flags |= TC_RED_OFFLOADED;
+ 
+ 	return err;
+ }
+ 
++>>>>>>> ee9d3429c0e4 (net/sched/sch_red.c: work around gcc-4.4.4 anon union initializer issue)
  static int red_dump(struct Qdisc *sch, struct sk_buff *skb)
  {
  	struct red_sched_data *q = qdisc_priv(sch);
@@@ -280,6 -345,26 +312,29 @@@ static int red_dump_stats(struct Qdisc 
  		.marked	= q->stats.prob_mark + q->stats.forced_mark,
  	};
  
++<<<<<<< HEAD
++=======
+ 	if (tc_can_offload(dev) &&  dev->netdev_ops->ndo_setup_tc) {
+ 		struct red_stats hw_stats = {0};
+ 		struct tc_red_qopt_offload hw_stats_request = {
+ 			.command = TC_RED_XSTATS,
+ 			.handle = sch->handle,
+ 			.parent = sch->parent,
+ 			{
+ 				.xstats = &hw_stats,
+ 			},
+ 		};
+ 		if (!dev->netdev_ops->ndo_setup_tc(dev,
+ 						   TC_SETUP_QDISC_RED,
+ 						   &hw_stats_request)) {
+ 			st.early += hw_stats.prob_drop + hw_stats.forced_drop;
+ 			st.pdrop += hw_stats.pdrop;
+ 			st.other += hw_stats.other;
+ 			st.marked += hw_stats.prob_mark + hw_stats.forced_mark;
+ 		}
+ 	}
+ 
++>>>>>>> ee9d3429c0e4 (net/sched/sch_red.c: work around gcc-4.4.4 anon union initializer issue)
  	return gnet_stats_copy_app(d, &st, sizeof(st));
  }
  
* Unmerged path net/sched/sch_red.c
