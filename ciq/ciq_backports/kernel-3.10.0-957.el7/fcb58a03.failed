netfilter: ipset: use setup_timer() and mod_timer().

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] netfilter: ipset: use setup_timer() and mod_timer() (Stefano Brivio) [1557599]
Rebuild_FUZZ: 99.03%
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit fcb58a033271e448c3e49a3b3d3e9e0c0bcf61d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/fcb58a03.failed

Use setup_timer() and instead of init_timer(), being the preferred way
of setting up a timer.

Also, quoting the mod_timer() function comment:
-> mod_timer() is a more efficient way to update the expire field of an
   active timer (if the timer is inactive it will be activated).

Use setup_timer() and mod_timer() to setup and arm a timer, making the
code compact and easier to read.

	Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit fcb58a033271e448c3e49a3b3d3e9e0c0bcf61d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_bitmap_gen.h
#	net/netfilter/ipset/ip_set_hash_gen.h
#	net/netfilter/ipset/ip_set_list_set.c
diff --cc net/netfilter/ipset/ip_set_bitmap_gen.h
index 01a340ce9e94,6f09a99298cd..000000000000
--- a/net/netfilter/ipset/ip_set_bitmap_gen.h
+++ b/net/netfilter/ipset/ip_set_bitmap_gen.h
@@@ -43,11 -41,19 +43,16 @@@ mtype_gc_init(struct ip_set *set, void 
  {
  	struct mtype *map = set->data;
  
++<<<<<<< HEAD
 +	init_timer(&map->gc);
 +	map->gc.data = (unsigned long) set;
 +	map->gc.function = gc;
 +	map->gc.expires = jiffies + IPSET_GC_PERIOD(map->timeout) * HZ;
 +	add_timer(&map->gc);
++=======
+ 	setup_timer(&map->gc, gc, (unsigned long)set);
+ 	mod_timer(&map->gc, jiffies + IPSET_GC_PERIOD(set->timeout) * HZ);
 -}
 -
 -static void
 -mtype_ext_cleanup(struct ip_set *set)
 -{
 -	struct mtype *map = set->data;
 -	u32 id;
 -
 -	for (id = 0; id < map->elements; id++)
 -		if (test_bit(id, map->members))
 -			ip_set_ext_destroy(set, get_ext(set, map, id));
++>>>>>>> fcb58a033271 (netfilter: ipset: use setup_timer() and mod_timer().)
  }
  
  static void
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 9ce28af662bf,1b05d4a7d5a1..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -409,13 -433,10 +409,18 @@@ mtype_gc_init(struct ip_set *set, void 
  {
  	struct htype *h = set->data;
  
++<<<<<<< HEAD
 +	init_timer(&h->gc);
 +	h->gc.data = (unsigned long) set;
 +	h->gc.function = gc;
 +	h->gc.expires = jiffies + IPSET_GC_PERIOD(h->timeout) * HZ;
 +	add_timer(&h->gc);
++=======
+ 	setup_timer(&h->gc, gc, (unsigned long)set);
+ 	mod_timer(&h->gc, jiffies + IPSET_GC_PERIOD(set->timeout) * HZ);
++>>>>>>> fcb58a033271 (netfilter: ipset: use setup_timer() and mod_timer().)
  	pr_debug("gc initialized, run in every %u\n",
 -		 IPSET_GC_PERIOD(set->timeout));
 +		 IPSET_GC_PERIOD(h->timeout));
  }
  
  static bool
diff --cc net/netfilter/ipset/ip_set_list_set.c
index a9a97c07ecb4,51077c53d76b..000000000000
--- a/net/netfilter/ipset/ip_set_list_set.c
+++ b/net/netfilter/ipset/ip_set_list_set.c
@@@ -605,11 -586,8 +605,16 @@@ list_set_gc_init(struct ip_set *set, vo
  {
  	struct list_set *map = set->data;
  
++<<<<<<< HEAD
 +	init_timer(&map->gc);
 +	map->gc.data = (unsigned long) set;
 +	map->gc.function = gc;
 +	map->gc.expires = jiffies + IPSET_GC_PERIOD(map->timeout) * HZ;
 +	add_timer(&map->gc);
++=======
+ 	setup_timer(&map->gc, gc, (unsigned long)set);
+ 	mod_timer(&map->gc, jiffies + IPSET_GC_PERIOD(set->timeout) * HZ);
++>>>>>>> fcb58a033271 (netfilter: ipset: use setup_timer() and mod_timer().)
  }
  
  /* Create list:set type of sets */
* Unmerged path net/netfilter/ipset/ip_set_bitmap_gen.h
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
* Unmerged path net/netfilter/ipset/ip_set_list_set.c
