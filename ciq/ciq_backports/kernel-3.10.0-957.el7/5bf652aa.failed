tracing/probes: Integrate duplicate set_print_fmt()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Namhyung Kim <namhyung.kim@lge.com>
commit 5bf652aaf46ca6ae477ea0d162e68d577cf244aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/5bf652aa.failed

The set_print_fmt() functions are implemented almost same for
[ku]probes.  Move it to a common place and get rid of the duplication.

	Acked-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
	Acked-by: Oleg Nesterov <oleg@redhat.com>
	Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
	Cc: zhangwei(Jovi) <jovi.zhangwei@huawei.com>
	Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
(cherry picked from commit 5bf652aaf46ca6ae477ea0d162e68d577cf244aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace_kprobe.c
#	kernel/trace/trace_uprobe.c
diff --cc kernel/trace/trace_kprobe.c
index 0a5b1d7d9b73,c9ffdafb9ada..000000000000
--- a/kernel/trace/trace_kprobe.c
+++ b/kernel/trace/trace_kprobe.c
@@@ -1208,67 -964,6 +1208,70 @@@ static int kretprobe_event_define_field
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int __set_print_fmt(struct trace_probe *tp, char *buf, int len)
 +{
 +	int i;
 +	int pos = 0;
 +
 +	const char *fmt, *arg;
 +
 +	if (!trace_probe_is_return(tp)) {
 +		fmt = "(%lx)";
 +		arg = "REC->" FIELD_STRING_IP;
 +	} else {
 +		fmt = "(%lx <- %lx)";
 +		arg = "REC->" FIELD_STRING_FUNC ", REC->" FIELD_STRING_RETIP;
 +	}
 +
 +	/* When len=0, we just calculate the needed length */
 +#define LEN_OR_ZERO (len ? len - pos : 0)
 +
 +	pos += snprintf(buf + pos, LEN_OR_ZERO, "\"%s", fmt);
 +
 +	for (i = 0; i < tp->nr_args; i++) {
 +		pos += snprintf(buf + pos, LEN_OR_ZERO, " %s=%s",
 +				tp->args[i].name, tp->args[i].type->fmt);
 +	}
 +
 +	pos += snprintf(buf + pos, LEN_OR_ZERO, "\", %s", arg);
 +
 +	for (i = 0; i < tp->nr_args; i++) {
 +		if (strcmp(tp->args[i].type->name, "string") == 0)
 +			pos += snprintf(buf + pos, LEN_OR_ZERO,
 +					", __get_str(%s)",
 +					tp->args[i].name);
 +		else
 +			pos += snprintf(buf + pos, LEN_OR_ZERO, ", REC->%s",
 +					tp->args[i].name);
 +	}
 +
 +#undef LEN_OR_ZERO
 +
 +	/* return the length of print_fmt */
 +	return pos;
 +}
 +
 +static int set_print_fmt(struct trace_probe *tp)
 +{
 +	int len;
 +	char *print_fmt;
 +
 +	/* First: called with 0 length to calculate the needed length */
 +	len = __set_print_fmt(tp, NULL, 0);
 +	print_fmt = kmalloc(len + 1, GFP_KERNEL);
 +	if (!print_fmt)
 +		return -ENOMEM;
 +
 +	/* Second: actually write the @print_fmt */
 +	__set_print_fmt(tp, print_fmt, len + 1);
 +	tp->call.print_fmt = print_fmt;
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> 5bf652aaf46c (tracing/probes: Integrate duplicate set_print_fmt())
  #ifdef CONFIG_PERF_EVENTS
  
  /* Kprobe profile handler */
@@@ -1417,7 -1114,7 +1420,11 @@@ static int register_probe_event(struct 
  		call->event.funcs = &kprobe_funcs;
  		call->class->define_fields = kprobe_event_define_fields;
  	}
++<<<<<<< HEAD
 +	if (set_print_fmt(tp) < 0)
++=======
+ 	if (set_print_fmt(&tk->tp, trace_kprobe_is_return(tk)) < 0)
++>>>>>>> 5bf652aaf46c (tracing/probes: Integrate duplicate set_print_fmt())
  		return -ENOMEM;
  	ret = register_ftrace_event(&call->event);
  	if (!ret) {
diff --cc kernel/trace/trace_uprobe.c
index 84f228258d8e,b233d9cb1216..000000000000
--- a/kernel/trace/trace_uprobe.c
+++ b/kernel/trace/trace_uprobe.c
@@@ -834,59 -682,6 +834,62 @@@ static int uprobe_event_define_fields(s
  	return 0;
  }
  
++<<<<<<< HEAD
 +#define LEN_OR_ZERO		(len ? len - pos : 0)
 +static int __set_print_fmt(struct trace_uprobe *tu, char *buf, int len)
 +{
 +	const char *fmt, *arg;
 +	int i;
 +	int pos = 0;
 +
 +	if (is_ret_probe(tu)) {
 +		fmt = "(%lx <- %lx)";
 +		arg = "REC->" FIELD_STRING_FUNC ", REC->" FIELD_STRING_RETIP;
 +	} else {
 +		fmt = "(%lx)";
 +		arg = "REC->" FIELD_STRING_IP;
 +	}
 +
 +	/* When len=0, we just calculate the needed length */
 +
 +	pos += snprintf(buf + pos, LEN_OR_ZERO, "\"%s", fmt);
 +
 +	for (i = 0; i < tu->nr_args; i++) {
 +		pos += snprintf(buf + pos, LEN_OR_ZERO, " %s=%s",
 +				tu->args[i].name, tu->args[i].type->fmt);
 +	}
 +
 +	pos += snprintf(buf + pos, LEN_OR_ZERO, "\", %s", arg);
 +
 +	for (i = 0; i < tu->nr_args; i++) {
 +		pos += snprintf(buf + pos, LEN_OR_ZERO, ", REC->%s",
 +				tu->args[i].name);
 +	}
 +
 +	return pos;	/* return the length of print_fmt */
 +}
 +#undef LEN_OR_ZERO
 +
 +static int set_print_fmt(struct trace_uprobe *tu)
 +{
 +	char *print_fmt;
 +	int len;
 +
 +	/* First: called with 0 length to calculate the needed length */
 +	len = __set_print_fmt(tu, NULL, 0);
 +	print_fmt = kmalloc(len + 1, GFP_KERNEL);
 +	if (!print_fmt)
 +		return -ENOMEM;
 +
 +	/* Second: actually write the @print_fmt */
 +	__set_print_fmt(tu, print_fmt, len + 1);
 +	tu->call.print_fmt = print_fmt;
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> 5bf652aaf46c (tracing/probes: Integrate duplicate set_print_fmt())
  #ifdef CONFIG_PERF_EVENTS
  static bool
  __uprobe_perf_filter(struct trace_uprobe_filter *filter, struct mm_struct *mm)
* Unmerged path kernel/trace/trace_kprobe.c
diff --git a/kernel/trace/trace_probe.c b/kernel/trace/trace_probe.c
index e5a5e595e69e..8364a421b4df 100644
--- a/kernel/trace/trace_probe.c
+++ b/kernel/trace/trace_probe.c
@@ -657,3 +657,65 @@ out:
 
 	return ret;
 }
+
+static int __set_print_fmt(struct trace_probe *tp, char *buf, int len,
+			   bool is_return)
+{
+	int i;
+	int pos = 0;
+
+	const char *fmt, *arg;
+
+	if (!is_return) {
+		fmt = "(%lx)";
+		arg = "REC->" FIELD_STRING_IP;
+	} else {
+		fmt = "(%lx <- %lx)";
+		arg = "REC->" FIELD_STRING_FUNC ", REC->" FIELD_STRING_RETIP;
+	}
+
+	/* When len=0, we just calculate the needed length */
+#define LEN_OR_ZERO (len ? len - pos : 0)
+
+	pos += snprintf(buf + pos, LEN_OR_ZERO, "\"%s", fmt);
+
+	for (i = 0; i < tp->nr_args; i++) {
+		pos += snprintf(buf + pos, LEN_OR_ZERO, " %s=%s",
+				tp->args[i].name, tp->args[i].type->fmt);
+	}
+
+	pos += snprintf(buf + pos, LEN_OR_ZERO, "\", %s", arg);
+
+	for (i = 0; i < tp->nr_args; i++) {
+		if (strcmp(tp->args[i].type->name, "string") == 0)
+			pos += snprintf(buf + pos, LEN_OR_ZERO,
+					", __get_str(%s)",
+					tp->args[i].name);
+		else
+			pos += snprintf(buf + pos, LEN_OR_ZERO, ", REC->%s",
+					tp->args[i].name);
+	}
+
+#undef LEN_OR_ZERO
+
+	/* return the length of print_fmt */
+	return pos;
+}
+
+int set_print_fmt(struct trace_probe *tp, bool is_return)
+{
+	int len;
+	char *print_fmt;
+
+	/* First: called with 0 length to calculate the needed length */
+	len = __set_print_fmt(tp, NULL, 0, is_return);
+	print_fmt = kmalloc(len + 1, GFP_KERNEL);
+	if (!print_fmt)
+		return -ENOMEM;
+
+	/* Second: actually write the @print_fmt */
+	__set_print_fmt(tp, print_fmt, len + 1, is_return);
+	tp->call.print_fmt = print_fmt;
+
+	return 0;
+}
diff --git a/kernel/trace/trace_probe.h b/kernel/trace/trace_probe.h
index 5b4f8bdfb3a5..9bfd365529f5 100644
--- a/kernel/trace/trace_probe.h
+++ b/kernel/trace/trace_probe.h
@@ -352,3 +352,5 @@ store_trace_args(int ent_size, struct trace_probe *tp, struct pt_regs *regs,
 				   data + tp->args[i].offset);
 	}
 }
+
+extern int set_print_fmt(struct trace_probe *tp, bool is_return);
* Unmerged path kernel/trace/trace_uprobe.c
