mlxsw: spectrum_span: Support mirror to gretap

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Petr Machata <petrm@mellanox.com>
commit 27cf76fe60ec6fbe2ba8844261b90a6aecbc42f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/27cf76fe.failed

When a user requests mirror from a mlxsw physical port (possibly based
on an ACL match) to a gretap netdevice, the driver needs to resolve the
request to a particular physical port that the mirrored packets will
egress through, and a suite of configuration keys (importantly, IP and
MAC addresses). That means calling into routing and neighbor kernel code
to simulate the decisions made by the system for packets passing through
a gretap netdevice.

Add a new instance of mlxsw_sp_span_entry_ops to support this.

	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 27cf76fe60ec6fbe2ba8844261b90a6aecbc42f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_span.h
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c
index a025a77a589d,d5fda4f13c31..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c
@@@ -100,12 -116,245 +104,247 @@@ mlxsw_sp_span_entry_deconfigure(struct 
  	mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mpat), mpat_pl);
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ mlxsw_sp_span_entry_phys_deconfigure(struct mlxsw_sp_span_entry *span_entry)
+ {
+ 	mlxsw_sp_span_entry_deconfigure_common(span_entry,
+ 					    MLXSW_REG_MPAT_SPAN_TYPE_LOCAL_ETH);
+ }
+ 
+ static const
+ struct mlxsw_sp_span_entry_ops mlxsw_sp_span_entry_ops_phys = {
+ 	.can_handle = mlxsw_sp_port_dev_check,
+ 	.parms = mlxsw_sp_span_entry_phys_parms,
+ 	.configure = mlxsw_sp_span_entry_phys_configure,
+ 	.deconfigure = mlxsw_sp_span_entry_phys_deconfigure,
+ };
+ 
+ static struct net_device *
+ mlxsw_sp_span_gretap4_route(const struct net_device *to_dev,
+ 			    __be32 *saddrp, __be32 *daddrp)
+ {
+ 	struct ip_tunnel *tun = netdev_priv(to_dev);
+ 	struct net_device *dev = NULL;
+ 	struct ip_tunnel_parm parms;
+ 	struct rtable *rt = NULL;
+ 	struct flowi4 fl4;
+ 
+ 	/* We assume "dev" stays valid after rt is put. */
+ 	ASSERT_RTNL();
+ 
+ 	parms = mlxsw_sp_ipip_netdev_parms4(to_dev);
+ 	ip_tunnel_init_flow(&fl4, parms.iph.protocol, *daddrp, *saddrp,
+ 			    0, 0, parms.link, tun->fwmark);
+ 
+ 	rt = ip_route_output_key(tun->net, &fl4);
+ 	if (IS_ERR(rt))
+ 		return NULL;
+ 
+ 	if (rt->rt_type != RTN_UNICAST)
+ 		goto out;
+ 
+ 	dev = rt->dst.dev;
+ 	*saddrp = fl4.saddr;
+ 	*daddrp = rt->rt_gateway;
+ 
+ out:
+ 	ip_rt_put(rt);
+ 	return dev;
+ }
+ 
+ static int mlxsw_sp_span_dmac(struct neigh_table *tbl,
+ 			      const void *pkey,
+ 			      struct net_device *l3edev,
+ 			      unsigned char dmac[ETH_ALEN])
+ {
+ 	struct neighbour *neigh = neigh_lookup(tbl, pkey, l3edev);
+ 	int err = 0;
+ 
+ 	if (!neigh) {
+ 		neigh = neigh_create(tbl, pkey, l3edev);
+ 		if (IS_ERR(neigh))
+ 			return PTR_ERR(neigh);
+ 	}
+ 
+ 	neigh_event_send(neigh, NULL);
+ 
+ 	read_lock_bh(&neigh->lock);
+ 	if ((neigh->nud_state & NUD_VALID) && !neigh->dead)
+ 		memcpy(dmac, neigh->ha, ETH_ALEN);
+ 	else
+ 		err = -ENOENT;
+ 	read_unlock_bh(&neigh->lock);
+ 
+ 	neigh_release(neigh);
+ 	return err;
+ }
+ 
+ static int
+ mlxsw_sp_span_entry_unoffloadable(struct mlxsw_sp_span_parms *sparmsp)
+ {
+ 	sparmsp->dest_port = NULL;
+ 	return 0;
+ }
+ 
+ static int
+ mlxsw_sp_span_entry_tunnel_parms_common(struct net_device *l3edev,
+ 					union mlxsw_sp_l3addr saddr,
+ 					union mlxsw_sp_l3addr daddr,
+ 					union mlxsw_sp_l3addr gw,
+ 					__u8 ttl,
+ 					struct neigh_table *tbl,
+ 					struct mlxsw_sp_span_parms *sparmsp)
+ {
+ 	unsigned char dmac[ETH_ALEN];
+ 
+ 	if (mlxsw_sp_l3addr_is_zero(gw))
+ 		gw = daddr;
+ 
+ 	if (!l3edev || !mlxsw_sp_port_dev_check(l3edev) ||
+ 	    mlxsw_sp_span_dmac(tbl, &gw, l3edev, dmac))
+ 		return mlxsw_sp_span_entry_unoffloadable(sparmsp);
+ 
+ 	sparmsp->dest_port = netdev_priv(l3edev);
+ 	sparmsp->ttl = ttl;
+ 	memcpy(sparmsp->dmac, dmac, ETH_ALEN);
+ 	memcpy(sparmsp->smac, l3edev->dev_addr, ETH_ALEN);
+ 	sparmsp->saddr = saddr;
+ 	sparmsp->daddr = daddr;
+ 	return 0;
+ }
+ 
+ static int
+ mlxsw_sp_span_entry_gretap4_parms(const struct net_device *to_dev,
+ 				  struct mlxsw_sp_span_parms *sparmsp)
+ {
+ 	struct ip_tunnel_parm tparm = mlxsw_sp_ipip_netdev_parms4(to_dev);
+ 	union mlxsw_sp_l3addr saddr = { .addr4 = tparm.iph.saddr };
+ 	union mlxsw_sp_l3addr daddr = { .addr4 = tparm.iph.daddr };
+ 	bool inherit_tos = tparm.iph.tos & 0x1;
+ 	bool inherit_ttl = !tparm.iph.ttl;
+ 	union mlxsw_sp_l3addr gw = daddr;
+ 	struct net_device *l3edev;
+ 
+ 	if (!(to_dev->flags & IFF_UP) ||
+ 	    /* Reject tunnels with GRE keys, checksums, etc. */
+ 	    tparm.i_flags || tparm.o_flags ||
+ 	    /* Require a fixed TTL and a TOS copied from the mirrored packet. */
+ 	    inherit_ttl || !inherit_tos ||
+ 	    /* A destination address may not be "any". */
+ 	    mlxsw_sp_l3addr_is_zero(daddr))
+ 		return mlxsw_sp_span_entry_unoffloadable(sparmsp);
+ 
+ 	l3edev = mlxsw_sp_span_gretap4_route(to_dev, &saddr.addr4, &gw.addr4);
+ 	return mlxsw_sp_span_entry_tunnel_parms_common(l3edev, saddr, daddr, gw,
+ 						       tparm.iph.ttl,
+ 						       &arp_tbl, sparmsp);
+ }
+ 
+ static int
+ mlxsw_sp_span_entry_gretap4_configure(struct mlxsw_sp_span_entry *span_entry,
+ 				      struct mlxsw_sp_span_parms sparms)
+ {
+ 	struct mlxsw_sp_port *dest_port = sparms.dest_port;
+ 	struct mlxsw_sp *mlxsw_sp = dest_port->mlxsw_sp;
+ 	u8 local_port = dest_port->local_port;
+ 	char mpat_pl[MLXSW_REG_MPAT_LEN];
+ 	int pa_id = span_entry->id;
+ 
+ 	/* Create a new port analayzer entry for local_port. */
+ 	mlxsw_reg_mpat_pack(mpat_pl, pa_id, local_port, true,
+ 			    MLXSW_REG_MPAT_SPAN_TYPE_REMOTE_ETH_L3);
+ 	mlxsw_reg_mpat_eth_rspan_l2_pack(mpat_pl,
+ 				    MLXSW_REG_MPAT_ETH_RSPAN_VERSION_NO_HEADER,
+ 				    sparms.dmac, false);
+ 	mlxsw_reg_mpat_eth_rspan_l3_ipv4_pack(mpat_pl,
+ 					      sparms.ttl, sparms.smac,
+ 					      be32_to_cpu(sparms.saddr.addr4),
+ 					      be32_to_cpu(sparms.daddr.addr4));
+ 
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mpat), mpat_pl);
+ }
+ 
+ static void
+ mlxsw_sp_span_entry_gretap4_deconfigure(struct mlxsw_sp_span_entry *span_entry)
+ {
+ 	mlxsw_sp_span_entry_deconfigure_common(span_entry,
+ 					MLXSW_REG_MPAT_SPAN_TYPE_REMOTE_ETH_L3);
+ }
+ 
+ static const struct mlxsw_sp_span_entry_ops mlxsw_sp_span_entry_ops_gretap4 = {
+ 	.can_handle = is_gretap_dev,
+ 	.parms = mlxsw_sp_span_entry_gretap4_parms,
+ 	.configure = mlxsw_sp_span_entry_gretap4_configure,
+ 	.deconfigure = mlxsw_sp_span_entry_gretap4_deconfigure,
+ };
+ 
+ static const
+ struct mlxsw_sp_span_entry_ops *const mlxsw_sp_span_entry_types[] = {
+ 	&mlxsw_sp_span_entry_ops_phys,
+ 	&mlxsw_sp_span_entry_ops_gretap4,
+ };
+ 
+ static int
+ mlxsw_sp_span_entry_nop_parms(const struct net_device *to_dev,
+ 			      struct mlxsw_sp_span_parms *sparmsp)
+ {
+ 	return mlxsw_sp_span_entry_unoffloadable(sparmsp);
+ }
+ 
+ static int
+ mlxsw_sp_span_entry_nop_configure(struct mlxsw_sp_span_entry *span_entry,
+ 				  struct mlxsw_sp_span_parms sparms)
+ {
+ 	return 0;
+ }
+ 
+ static void
+ mlxsw_sp_span_entry_nop_deconfigure(struct mlxsw_sp_span_entry *span_entry)
+ {
+ }
+ 
+ static const struct mlxsw_sp_span_entry_ops mlxsw_sp_span_entry_ops_nop = {
+ 	.parms = mlxsw_sp_span_entry_nop_parms,
+ 	.configure = mlxsw_sp_span_entry_nop_configure,
+ 	.deconfigure = mlxsw_sp_span_entry_nop_deconfigure,
+ };
+ 
+ static void
+ mlxsw_sp_span_entry_configure(struct mlxsw_sp *mlxsw_sp,
+ 			      struct mlxsw_sp_span_entry *span_entry,
+ 			      struct mlxsw_sp_span_parms sparms)
+ {
+ 	if (sparms.dest_port) {
+ 		if (sparms.dest_port->mlxsw_sp != mlxsw_sp) {
+ 			netdev_err(span_entry->to_dev, "Cannot mirror to %s, which belongs to a different mlxsw instance",
+ 				   sparms.dest_port->dev->name);
+ 			sparms.dest_port = NULL;
+ 		} else if (span_entry->ops->configure(span_entry, sparms)) {
+ 			netdev_err(span_entry->to_dev, "Failed to offload mirror to %s",
+ 				   sparms.dest_port->dev->name);
+ 			sparms.dest_port = NULL;
+ 		}
+ 	}
+ 
+ 	span_entry->parms = sparms;
+ }
+ 
+ static void
+ mlxsw_sp_span_entry_deconfigure(struct mlxsw_sp_span_entry *span_entry)
+ {
+ 	if (span_entry->parms.dest_port)
+ 		span_entry->ops->deconfigure(span_entry);
+ }
+ 
++>>>>>>> 27cf76fe60ec (mlxsw: spectrum_span: Support mirror to gretap)
  static struct mlxsw_sp_span_entry *
 -mlxsw_sp_span_entry_create(struct mlxsw_sp *mlxsw_sp,
 -			   const struct net_device *to_dev,
 -			   const struct mlxsw_sp_span_entry_ops *ops,
 -			   struct mlxsw_sp_span_parms sparms)
 +mlxsw_sp_span_entry_create(struct mlxsw_sp_port *port)
  {
  	struct mlxsw_sp_span_entry *span_entry = NULL;
 +	struct mlxsw_sp *mlxsw_sp = port->mlxsw_sp;
 +	u8 local_port = port->local_port;
  	int i;
  
  	/* find a free entry to use */
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_span.h
index 069050e385ff,948aceb512c5..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.h
@@@ -50,8 -53,21 +53,22 @@@ struct mlxsw_sp_span_inspected_port 
  	u8 local_port;
  };
  
++<<<<<<< HEAD
++=======
+ struct mlxsw_sp_span_parms {
+ 	struct mlxsw_sp_port *dest_port; /* NULL for unoffloaded SPAN. */
+ 	unsigned int ttl;
+ 	unsigned char dmac[ETH_ALEN];
+ 	unsigned char smac[ETH_ALEN];
+ 	union mlxsw_sp_l3addr daddr;
+ 	union mlxsw_sp_l3addr saddr;
+ };
+ 
+ struct mlxsw_sp_span_entry_ops;
+ 
++>>>>>>> 27cf76fe60ec (mlxsw: spectrum_span: Support mirror to gretap)
  struct mlxsw_sp_span_entry {
 -	const struct net_device *to_dev;
 -	const struct mlxsw_sp_span_entry_ops *ops;
 -	struct mlxsw_sp_span_parms parms;
 +	u8 local_port;
  	struct list_head bound_ports_list;
  	int ref_count;
  	int id;
diff --git a/drivers/net/ethernet/mellanox/mlxsw/Kconfig b/drivers/net/ethernet/mellanox/mlxsw/Kconfig
index d56eea310509..830c3e28505e 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/Kconfig
+++ b/drivers/net/ethernet/mellanox/mlxsw/Kconfig
@@ -78,6 +78,8 @@ config MLXSW_SPECTRUM
 	depends on IPV6 || IPV6=n
 	select PARMAN
 	select MLXFW
+	depends on NET_IPGRE
+	depends on !(MLXSW_CORE=y && NET_IPGRE=m)
 	default m
 	---help---
 	  This driver supports Mellanox Technologies Spectrum Ethernet
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_span.h
