Input: psmouse - factor out common protocol probing code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [input] psmouse - factor out common protocol probing code (Benjamin Tissoires) [1554926]
Rebuild_FUZZ: 93.33%
commit-author Dmitry Torokhov <dmitry.torokhov@gmail.com>
commit c378b5119eb0ea25bfd3348a06b51fca654d9903
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/c378b511.failed

In preparation of limiting protocols that we try on pass-through ports,
let's rework initialization code and factor common code into
psmouse_try_protocol() that accepts protocol type (instead of detec()
function pointer) and can, for most protocols, perform both detection and
initialization.

Note that this removes option of forcing Lifebook protocol on devices that
are not recognized by lifebook_detect() as having the hardware, but I do
not recall anyone using this option.

	Reviewed-by: Hans de Goede <hdegoede@redhat.com>
	Tested-by: Marcin Sochacki <msochacki+kernel@gmail.com>
	Tested-by: Till <till2.schaefer@uni-dortmund.de>
	Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
(cherry picked from commit c378b5119eb0ea25bfd3348a06b51fca654d9903)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/input/mouse/psmouse-base.c
diff --cc drivers/input/mouse/psmouse-base.c
index e63171ffe241,316105e30064..000000000000
--- a/drivers/input/mouse/psmouse-base.c
+++ b/drivers/input/mouse/psmouse-base.c
@@@ -1097,6 -884,268 +1109,271 @@@ static const struct psmouse_protocol *p
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Apply default settings to the psmouse structure. Most of them will
+  * be overridden by individual protocol initialization routines.
+  */
+ static void psmouse_apply_defaults(struct psmouse *psmouse)
+ {
+ 	struct input_dev *input_dev = psmouse->dev;
+ 
+ 	memset(input_dev->evbit, 0, sizeof(input_dev->evbit));
+ 	memset(input_dev->keybit, 0, sizeof(input_dev->keybit));
+ 	memset(input_dev->relbit, 0, sizeof(input_dev->relbit));
+ 	memset(input_dev->absbit, 0, sizeof(input_dev->absbit));
+ 	memset(input_dev->mscbit, 0, sizeof(input_dev->mscbit));
+ 
+ 	__set_bit(EV_KEY, input_dev->evbit);
+ 	__set_bit(EV_REL, input_dev->evbit);
+ 
+ 	__set_bit(BTN_LEFT, input_dev->keybit);
+ 	__set_bit(BTN_RIGHT, input_dev->keybit);
+ 
+ 	__set_bit(REL_X, input_dev->relbit);
+ 	__set_bit(REL_Y, input_dev->relbit);
+ 
+ 	__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 	psmouse->set_rate = psmouse_set_rate;
+ 	psmouse->set_resolution = psmouse_set_resolution;
+ 	psmouse->set_scale = psmouse_set_scale;
+ 	psmouse->poll = psmouse_poll;
+ 	psmouse->protocol_handler = psmouse_process_byte;
+ 	psmouse->pktsize = 3;
+ 	psmouse->reconnect = NULL;
+ 	psmouse->disconnect = NULL;
+ 	psmouse->cleanup = NULL;
+ 	psmouse->pt_activate = NULL;
+ 	psmouse->pt_deactivate = NULL;
+ }
+ 
+ static bool psmouse_try_protocol(struct psmouse *psmouse,
+ 				 enum psmouse_type type,
+ 				 unsigned int *max_proto,
+ 				 bool set_properties, bool init_allowed)
+ {
+ 	const struct psmouse_protocol *proto;
+ 
+ 	proto = __psmouse_protocol_by_type(type);
+ 	if (!proto)
+ 		return false;
+ 
+ 	if (set_properties)
+ 		psmouse_apply_defaults(psmouse);
+ 
+ 	if (proto->detect(psmouse, set_properties) != 0)
+ 		return false;
+ 
+ 	if (set_properties && proto->init && init_allowed) {
+ 		if (proto->init(psmouse) != 0) {
+ 			/*
+ 			 * We detected device, but init failed. Adjust
+ 			 * max_proto so we only try standard protocols.
+ 			 */
+ 			if (*max_proto > PSMOUSE_IMEX)
+ 				*max_proto = PSMOUSE_IMEX;
+ 
+ 			return false;
+ 		}
+ 	}
+ 
+ 	return true;
+ }
+ 
+ /*
+  * psmouse_extensions() probes for any extensions to the basic PS/2 protocol
+  * the mouse may have.
+  */
+ static int psmouse_extensions(struct psmouse *psmouse,
+ 			      unsigned int max_proto, bool set_properties)
+ {
+ 	bool synaptics_hardware = false;
+ 
+ 	/*
+ 	 * Always check for focaltech, this is safe as it uses pnp-id
+ 	 * matching.
+ 	 */
+ 	if (psmouse_try_protocol(psmouse, PSMOUSE_FOCALTECH,
+ 				 &max_proto, set_properties, false)) {
+ 		if (max_proto > PSMOUSE_IMEX &&
+ 		    IS_ENABLED(CONFIG_MOUSE_PS2_FOCALTECH) &&
+ 		    (!set_properties || focaltech_init(psmouse) == 0)) {
+ 			return PSMOUSE_FOCALTECH;
+ 		}
+ 		/*
+ 		 * Restrict psmouse_max_proto so that psmouse_initialize()
+ 		 * does not try to reset rate and resolution, because even
+ 		 * that upsets the device.
+ 		 * This also causes us to basically fall through to basic
+ 		 * protocol detection, where we fully reset the mouse,
+ 		 * and set it up as bare PS/2 protocol device.
+ 		 */
+ 		psmouse_max_proto = max_proto = PSMOUSE_PS2;
+ 	}
+ 
+ 	/*
+ 	 * We always check for LifeBook because it does not disturb mouse
+ 	 * (it only checks DMI information).
+ 	 */
+ 	if (psmouse_try_protocol(psmouse, PSMOUSE_LIFEBOOK, &max_proto,
+ 				 set_properties, max_proto > PSMOUSE_IMEX))
+ 		return PSMOUSE_LIFEBOOK;
+ 
+ 	if (psmouse_try_protocol(psmouse, PSMOUSE_VMMOUSE, &max_proto,
+ 				 set_properties, max_proto > PSMOUSE_IMEX))
+ 		return PSMOUSE_VMMOUSE;
+ 
+ 	/*
+ 	 * Try Kensington ThinkingMouse (we try first, because Synaptics
+ 	 * probe upsets the ThinkingMouse).
+ 	 */
+ 	if (max_proto > PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_THINKPS, &max_proto,
+ 				 set_properties, true)) {
+ 		return PSMOUSE_THINKPS;
+ 	}
+ 
+ 	/*
+ 	 * Try Synaptics TouchPad. Note that probing is done even if
+ 	 * Synaptics protocol support is disabled in config - we need to
+ 	 * know if it is Synaptics so we can reset it properly after
+ 	 * probing for IntelliMouse.
+ 	 */
+ 	if (max_proto > PSMOUSE_PS2 &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_SYNAPTICS, &max_proto,
+ 				 set_properties, false)) {
+ 		synaptics_hardware = true;
+ 
+ 		if (max_proto > PSMOUSE_IMEX) {
+ 			/*
+ 			 * Try activating protocol, but check if support is
+ 			 * enabled first, since we try detecting Synaptics
+ 			 * even when protocol is disabled.
+ 			 */
+ 			if (IS_ENABLED(CONFIG_MOUSE_PS2_SYNAPTICS) &&
+ 			    (!set_properties || synaptics_init(psmouse) == 0)) {
+ 				return PSMOUSE_SYNAPTICS;
+ 			}
+ 
+ 			/*
+ 			 * Some Synaptics touchpads can emulate extended
+ 			 * protocols (like IMPS/2).  Unfortunately
+ 			 * Logitech/Genius probes confuse some firmware
+ 			 * versions so we'll have to skip them.
+ 			 */
+ 			max_proto = PSMOUSE_IMEX;
+ 		}
+ 
+ 		/*
+ 		 * Make sure that touchpad is in relative mode, gestures
+ 		 * (taps) are enabled.
+ 		 */
+ 		synaptics_reset(psmouse);
+ 	}
+ 
+ 	/*
+ 	 * Try Cypress Trackpad. We must try it before Finger Sensing Pad
+ 	 * because Finger Sensing Pad probe upsets some modules of Cypress
+ 	 * Trackpads.
+ 	 */
+ 	if (max_proto > PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_CYPRESS, &max_proto,
+ 				 set_properties, true)) {
+ 		return PSMOUSE_CYPRESS;
+ 	}
+ 
+ 	/* Try ALPS TouchPad */
+ 	if (max_proto > PSMOUSE_IMEX) {
+ 		ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);
+ 		if (psmouse_try_protocol(psmouse, PSMOUSE_ALPS,
+ 					 &max_proto, set_properties, true))
+ 			return PSMOUSE_ALPS;
+ 	}
+ 
+ 	/* Try OLPC HGPK touchpad */
+ 	if (max_proto > PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_HGPK, &max_proto,
+ 				 set_properties, true)) {
+ 		return PSMOUSE_HGPK;
+ 	}
+ 
+ 	/* Try Elantech touchpad */
+ 	if (max_proto > PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_ELANTECH,
+ 				 &max_proto, set_properties, true)) {
+ 		return PSMOUSE_ELANTECH;
+ 	}
+ 
+ 	if (max_proto > PSMOUSE_IMEX) {
+ 		if (psmouse_try_protocol(psmouse, PSMOUSE_GENPS,
+ 					 &max_proto, set_properties, true))
+ 			return PSMOUSE_GENPS;
+ 
+ 		if (psmouse_try_protocol(psmouse, PSMOUSE_PS2PP,
+ 					 &max_proto, set_properties, true))
+ 			return PSMOUSE_PS2PP;
+ 
+ 		if (psmouse_try_protocol(psmouse, PSMOUSE_TRACKPOINT,
+ 					 &max_proto, set_properties, true))
+ 			return PSMOUSE_TRACKPOINT;
+ 
+ 		if (psmouse_try_protocol(psmouse, PSMOUSE_TOUCHKIT_PS2,
+ 					 &max_proto, set_properties, true))
+ 			return PSMOUSE_TOUCHKIT_PS2;
+ 	}
+ 
+ 	/*
+ 	 * Try Finger Sensing Pad. We do it here because its probe upsets
+ 	 * Trackpoint devices (causing TP_READ_ID command to time out).
+ 	 */
+ 	if (max_proto > PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_FSP,
+ 				 &max_proto, set_properties, true)) {
+ 		return PSMOUSE_FSP;
+ 	}
+ 
+ 	/*
+ 	 * Reset to defaults in case the device got confused by extended
+ 	 * protocol probes. Note that we follow up with full reset because
+ 	 * some mice put themselves to sleep when they see PSMOUSE_RESET_DIS.
+ 	 */
+ 	ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);
+ 	psmouse_reset(psmouse);
+ 
+ 	if (max_proto >= PSMOUSE_IMEX &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_IMEX,
+ 				 &max_proto, set_properties, true)) {
+ 		return PSMOUSE_IMEX;
+ 	}
+ 
+ 	if (max_proto >= PSMOUSE_IMPS &&
+ 	    psmouse_try_protocol(psmouse, PSMOUSE_IMPS,
+ 				 &max_proto, set_properties, true)) {
+ 		return PSMOUSE_IMPS;
+ 	}
+ 
+ 	/*
+ 	 * Okay, all failed, we have a standard mouse here. The number of
+ 	 * the buttons is still a question, though. We assume 3.
+ 	 */
+ 	psmouse_try_protocol(psmouse, PSMOUSE_PS2,
+ 			     &max_proto, set_properties, true);
+ 
+ 	if (synaptics_hardware) {
+ 		/*
+ 		 * We detected Synaptics hardware but it did not respond to
+ 		 * IMPS/2 probes.  We need to reset the touchpad because if
+ 		 * there is a track point on the pass through port it could
+ 		 * get disabled while probing for protocol extensions.
+ 		 */
+ 		psmouse_reset(psmouse);
+ 	}
+ 
+ 	return PSMOUSE_PS2;
+ }
++>>>>>>> c378b5119eb0 (Input: psmouse - factor out common protocol probing code)
  
  /*
   * psmouse_probe() probes for a PS/2 mouse.
* Unmerged path drivers/input/mouse/psmouse-base.c
