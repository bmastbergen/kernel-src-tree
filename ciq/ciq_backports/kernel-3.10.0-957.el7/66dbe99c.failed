x86/efi/bgrt: Don't ignore the BGRT if the 'valid' bit is 0

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] efi/bgrt: Don't ignore the BGRT if the 'valid' bit is 0 (Lenny Szubowicz) [1464241]
Rebuild_FUZZ: 96.49%
commit-author Môshe van der Sterre <me@moshe.nl>
commit 66dbe99cfe30e113d2e571e68b9b6a1a8985a157
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/66dbe99c.failed

Unintuitively, the BGRT graphic is apparently meant to be usable
if the valid bit in not set. The valid bit only conveys
uncertainty about the validity in relation to the screen state.

Windows 10 actually uses the BGRT image for its boot screen even
if not 'valid', for example when the user triggered the boot
menu. Because it is unclear if all firmwares will provide a
usable graphic in this case, we now look at the BMP magic number
as an additional check.

	Reviewed-by: Josh Triplett <josh@joshtriplett.org>
	Signed-off-by: Môshe van der Sterre <me@moshe.nl>
	Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
	Cc: =?UTF-8?q?M=C3=B4she=20van=20der=20Sterre?= <me@moshe.nl>
Link: http://lkml.kernel.org/r/1454364428-494-10-git-send-email-matt@codeblueprint.co.uk
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 66dbe99cfe30e113d2e571e68b9b6a1a8985a157)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/platform/efi/efi-bgrt.c
diff --cc arch/x86/platform/efi/efi-bgrt.c
index e376723efd84,a2433817c987..000000000000
--- a/arch/x86/platform/efi/efi-bgrt.c
+++ b/arch/x86/platform/efi/efi-bgrt.c
@@@ -42,28 -42,54 +42,50 @@@ void __init efi_bgrt_init(void
  	if (ACPI_FAILURE(status))
  		return;
  
 -	if (bgrt_tab->header.length < sizeof(*bgrt_tab)) {
 -		pr_err("Ignoring BGRT: invalid length %u (expected %zu)\n",
 -		       bgrt_tab->header.length, sizeof(*bgrt_tab));
 +	if (bgrt_tab->header.length < sizeof(*bgrt_tab))
  		return;
 -	}
 -	if (bgrt_tab->version != 1) {
 -		pr_err("Ignoring BGRT: invalid version %u (expected 1)\n",
 -		       bgrt_tab->version);
 +	if (bgrt_tab->version != 1 || bgrt_tab->status != 1)
  		return;
 -	}
 -	if (bgrt_tab->status & 0xfe) {
 -		pr_err("Ignoring BGRT: reserved status bits are non-zero %u\n",
 -		       bgrt_tab->status);
 +	if (bgrt_tab->image_type != 0 || !bgrt_tab->image_address)
  		return;
++<<<<<<< HEAD
++=======
+ 	}
+ 	if (bgrt_tab->image_type != 0) {
+ 		pr_err("Ignoring BGRT: invalid image type %u (expected 0)\n",
+ 		       bgrt_tab->image_type);
+ 		return;
+ 	}
+ 	if (!bgrt_tab->image_address) {
+ 		pr_err("Ignoring BGRT: null image address\n");
+ 		return;
+ 	}
++>>>>>>> 66dbe99cfe30 (x86/efi/bgrt: Don't ignore the BGRT if the 'valid' bit is 0)
  
 -	image = memremap(bgrt_tab->image_address, sizeof(bmp_header), MEMREMAP_WB);
 +	image = ioremap(bgrt_tab->image_address, sizeof(bmp_header));
  	if (!image) {
  		pr_err("Ignoring BGRT: failed to map image header memory\n");
  		return;
  	}
  
  	memcpy(&bmp_header, image, sizeof(bmp_header));
++<<<<<<< HEAD
 +	iounmap(image);
++=======
+ 	memunmap(image);
+ 	if (bmp_header.id != 0x4d42) {
+ 		pr_err("Ignoring BGRT: Incorrect BMP magic number 0x%x (expected 0x4d42)\n",
+ 			bmp_header.id);
+ 		return;
+ 	}
++>>>>>>> 66dbe99cfe30 (x86/efi/bgrt: Don't ignore the BGRT if the 'valid' bit is 0)
  	bgrt_image_size = bmp_header.size;
  
 -	bgrt_image = kmalloc(bgrt_image_size, GFP_KERNEL | __GFP_NOWARN);
 -	if (!bgrt_image) {
 -		pr_err("Ignoring BGRT: failed to allocate memory for image (wanted %zu bytes)\n",
 -		       bgrt_image_size);
 +	bgrt_image = kmalloc(bgrt_image_size, GFP_KERNEL);
 +	if (!bgrt_image)
  		return;
 -	}
  
 -	image = memremap(bgrt_tab->image_address, bmp_header.size, MEMREMAP_WB);
 +	image = ioremap(bgrt_tab->image_address, bmp_header.size);
  	if (!image) {
  		pr_err("Ignoring BGRT: failed to map image memory\n");
  		kfree(bgrt_image);
* Unmerged path arch/x86/platform/efi/efi-bgrt.c
