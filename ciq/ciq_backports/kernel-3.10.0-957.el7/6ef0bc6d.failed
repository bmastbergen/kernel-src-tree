ceph: flush dirty caps of unlinked inode ASAP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Zhi Zhang <zhang.david2011@gmail.com>
commit 6ef0bc6ddee1f62310877a1d53b1ea1d0d8e51a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/6ef0bc6d.failed

Client should release unlinked inode from its cache ASAP. But client
can't release inode with dirty caps.

Link: http://tracker.ceph.com/issues/22886
	Signed-off-by: Zhi Zhang <zhang.david2011@gmail.com>
	Reviewed-by: "Yan, Zheng" <zyan@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 6ef0bc6ddee1f62310877a1d53b1ea1d0d8e51a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/dir.c
diff --cc fs/ceph/dir.c
index 83040cdc8671,f1d9c6cc0491..000000000000
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@@ -1119,9 -1083,11 +1099,17 @@@ static int ceph_rename(struct inode *ol
  	req->r_dentry_drop = CEPH_CAP_FILE_SHARED;
  	req->r_dentry_unless = CEPH_CAP_FILE_EXCL;
  	/* release LINK_RDCACHE on source inode (mds will lock it) */
++<<<<<<< HEAD
 +	req->r_old_inode_drop = CEPH_CAP_LINK_SHARED;
 +	if (new_dentry->d_inode)
 +		req->r_inode_drop = drop_caps_for_unlink(new_dentry->d_inode);
++=======
+ 	req->r_old_inode_drop = CEPH_CAP_LINK_SHARED | CEPH_CAP_LINK_EXCL;
+ 	if (d_really_is_positive(new_dentry)) {
+ 		req->r_inode_drop =
+ 			ceph_drop_caps_for_unlink(d_inode(new_dentry));
+ 	}
++>>>>>>> 6ef0bc6ddee1 (ceph: flush dirty caps of unlinked inode ASAP)
  	err = ceph_mdsc_do_request(mdsc, old_dir, req);
  	if (!err && !req->r_reply_info.head->is_dentry) {
  		/*
diff --git a/fs/ceph/caps.c b/fs/ceph/caps.c
index bef5bb710814..08d4e6bd3241 100644
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@ -3947,6 +3947,32 @@ void ceph_put_fmode(struct ceph_inode_info *ci, int fmode)
 		ceph_check_caps(ci, 0, NULL);
 }
 
+/*
+ * For a soon-to-be unlinked file, drop the AUTH_RDCACHE caps. If it
+ * looks like the link count will hit 0, drop any other caps (other
+ * than PIN) we don't specifically want (due to the file still being
+ * open).
+ */
+int ceph_drop_caps_for_unlink(struct inode *inode)
+{
+	struct ceph_inode_info *ci = ceph_inode(inode);
+	int drop = CEPH_CAP_LINK_SHARED | CEPH_CAP_LINK_EXCL;
+
+	spin_lock(&ci->i_ceph_lock);
+	if (inode->i_nlink == 1) {
+		drop |= ~(__ceph_caps_wanted(ci) | CEPH_CAP_PIN);
+
+		ci->i_ceph_flags |= CEPH_I_NODELAY;
+		if (__ceph_caps_dirty(ci)) {
+			struct ceph_mds_client *mdsc =
+				ceph_inode_to_client(inode)->mdsc;
+			__cap_delay_requeue_front(mdsc, ci);
+		}
+	}
+	spin_unlock(&ci->i_ceph_lock);
+	return drop;
+}
+
 /*
  * Helpers for embedding cap and dentry lease releases into mds
  * requests.
* Unmerged path fs/ceph/dir.c
diff --git a/fs/ceph/super.h b/fs/ceph/super.h
index 2ea6359d8d08..d940a072e918 100644
--- a/fs/ceph/super.h
+++ b/fs/ceph/super.h
@@ -934,7 +934,7 @@ extern void ceph_check_caps(struct ceph_inode_info *ci, int flags,
 			    struct ceph_mds_session *session);
 extern void ceph_check_delayed_caps(struct ceph_mds_client *mdsc);
 extern void ceph_flush_dirty_caps(struct ceph_mds_client *mdsc);
-
+extern int  ceph_drop_caps_for_unlink(struct inode *inode);
 extern int ceph_encode_inode_release(void **p, struct inode *inode,
 				     int mds, int drop, int unless, int force);
 extern int ceph_encode_dentry_release(void **p, struct dentry *dn,
