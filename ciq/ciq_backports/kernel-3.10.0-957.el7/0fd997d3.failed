nvme-fc: correct hang in nvme_ns_remove()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [nvme-fc] correct hang in nvme_ns_remove() (Ewan Milne) [1549232]
Rebuild_FUZZ: 87.67%
commit-author James Smart <jsmart2021@gmail.com>
commit 0fd997d3f77296522e836f7002e8a0636c9886aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0fd997d3.failed

When connectivity is lost to a device, the association is terminated
and the blk-mq queues are quiesced/stopped. When connectivity is
re-established, they are resumed.

If connectivity is lost for a sufficient amount of time that the
controller is then deleted, the delete path starts tearing down queues,
and eventually calling nvme_ns_remove(). It appears that pending
commands may cause blk_cleanup_queue() to never complete and the
teardown stalls.

Correct by starting the ns queues after transitioning to a DELETING
state, allowing pending commands to be flushed with io failures. Thus
the delete path is clear when reached.

	Signed-off-by: James Smart <james.smart@broadcom.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 0fd997d3f77296522e836f7002e8a0636c9886aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/fc.c
diff --cc drivers/nvme/host/fc.c
index 48f49adb80ac,b76ba4629e02..000000000000
--- a/drivers/nvme/host/fc.c
+++ b/drivers/nvme/host/fc.c
@@@ -2926,46 -2939,8 +2926,51 @@@ nvme_fc_delete_ctrl_work(struct work_st
  	 */
  	nvme_fc_delete_association(ctrl);
  
++<<<<<<< HEAD
 +	/*
 +	 * tear down the controller
 +	 * After the last reference on the nvme ctrl is removed,
 +	 * the transport nvme_fc_nvme_ctrl_freed() callback will be
 +	 * invoked. From there, the transport will tear down it's
 +	 * logical queues and association.
 +	 */
 +	nvme_uninit_ctrl(&ctrl->ctrl);
 +
 +	nvme_put_ctrl(&ctrl->ctrl);
 +}
 +
 +static int
 +__nvme_fc_del_ctrl(struct nvme_fc_ctrl *ctrl)
 +{
 +	if (!nvme_change_ctrl_state(&ctrl->ctrl, NVME_CTRL_DELETING))
 +		return -EBUSY;
 +	if (!queue_work(nvme_wq, &ctrl->delete_work))
 +		return -EBUSY;
 +	return 0;
 +}
 +
 +/*
 + * Request from nvme core layer to delete the controller
 + */
 +static int
 +nvme_fc_del_nvme_ctrl(struct nvme_ctrl *nctrl)
 +{
 +	struct nvme_fc_ctrl *ctrl = to_fc_ctrl(nctrl);
 +	int ret;
 +
 +	if (!kref_get_unless_zero(&ctrl->ctrl.kref))
 +		return -EBUSY;
 +
 +	ret = __nvme_fc_del_ctrl(ctrl);
 +	if (!ret)
 +		flush_work(&ctrl->delete_work);
 +	nvme_put_ctrl(&ctrl->ctrl);
 +
 +	return ret;
++=======
+ 	/* resume the io queues so that things will fast fail */
+ 	nvme_start_queues(nctrl);
++>>>>>>> 0fd997d3f772 (nvme-fc: correct hang in nvme_ns_remove())
  }
  
  static void
* Unmerged path drivers/nvme/host/fc.c
