net: speed up skb_rbtree_purge()

jira LE-1907
cve CVE-2018-5391
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] speed up skb_rbtree_purge() (Sabrina Dubroca) [1613924] {CVE-2018-5391}
Rebuild_FUZZ: 91.53%
commit-author Eric Dumazet <edumazet@google.com>
commit 7c90584c66cc4b033a3b684b0e0950f79e7b7166
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7c90584c.failed

As measured in my prior patch ("sch_netem: faster rb tree removal"),
rbtree_postorder_for_each_entry_safe() is nice looking but much slower
than using rb_next() directly, except when tree is small enough
to fit in CPU caches (then the cost is the same)

Also note that there is not even an increase of text size :
$ size net/core/skbuff.o.before net/core/skbuff.o
   text	   data	    bss	    dec	    hex	filename
  40711	   1298	      0	  42009	   a419	net/core/skbuff.o.before
  40711	   1298	      0	  42009	   a419	net/core/skbuff.o

From: Eric Dumazet <edumazet@google.com>

	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7c90584c66cc4b033a3b684b0e0950f79e7b7166)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/skbuff.c
diff --cc net/core/skbuff.c
index 5e1f674884e9,000ce735fa8d..000000000000
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@@ -2550,6 -2838,28 +2550,31 @@@ void skb_queue_purge(struct sk_buff_hea
  EXPORT_SYMBOL(skb_queue_purge);
  
  /**
++<<<<<<< HEAD
++=======
+  *	skb_rbtree_purge - empty a skb rbtree
+  *	@root: root of the rbtree to empty
+  *
+  *	Delete all buffers on an &sk_buff rbtree. Each buffer is removed from
+  *	the list and one reference dropped. This function does not take
+  *	any lock. Synchronization should be handled by the caller (e.g., TCP
+  *	out-of-order queue is protected by the socket lock).
+  */
+ void skb_rbtree_purge(struct rb_root *root)
+ {
+ 	struct rb_node *p = rb_first(root);
+ 
+ 	while (p) {
+ 		struct sk_buff *skb = rb_entry(p, struct sk_buff, rbnode);
+ 
+ 		p = rb_next(p);
+ 		rb_erase(&skb->rbnode, root);
+ 		kfree_skb(skb);
+ 	}
+ }
+ 
+ /**
++>>>>>>> 7c90584c66cc (net: speed up skb_rbtree_purge())
   *	skb_queue_head - queue a buffer at the list head
   *	@list: list to use
   *	@newsk: buffer to queue
* Unmerged path net/core/skbuff.c
