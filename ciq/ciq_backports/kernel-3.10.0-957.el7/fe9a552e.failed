libnvdimm, nfit: fix persistence domain reporting

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit fe9a552e715dfe5167d52deb74ea16335896bdaf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/fe9a552e.failed

The persistence domain is a point in the platform where once writes
reach that destination the platform claims it will make them persistent
relative to power loss. In the ACPI NFIT this is currently communicated
as 2 bits in the "NFIT - Platform Capabilities Structure". The bits
comprise a hierarchy, i.e. bit0 "CPU Cache Flush to NVDIMM Durability on
Power Loss Capable" implies bit1 "Memory Controller Flush to NVDIMM
Durability on Power Loss Capable".

Commit 96c3a239054a "libnvdimm: expose platform persistence attr..."
shows the persistence domain as flags, but it's really an enumerated
hierarchy.

Fix this newly introduced user ABI to show the closest available
persistence domain before userspace develops dependencies on seeing, or
needing to develop code to tolerate, the raw NFIT flags communicated
through the libnvdimm-generic region attribute.

Fixes: 96c3a239054a ("libnvdimm: expose platform persistence attr...")
	Reviewed-by: Dave Jiang <dave.jiang@intel.com>
	Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
	Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit fe9a552e715dfe5167d52deb74ea16335896bdaf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/nfit/core.c
diff --cc drivers/acpi/nfit/core.c
index b50d8cd25e0f,eb09ef55c38a..000000000000
--- a/drivers/acpi/nfit/core.c
+++ b/drivers/acpi/nfit/core.c
@@@ -2613,6 -2675,16 +2613,19 @@@ static int acpi_nfit_register_region(st
  	else
  		ndr_desc->numa_node = NUMA_NO_NODE;
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Persistence domain bits are hierarchical, if
+ 	 * ACPI_NFIT_CAPABILITY_CACHE_FLUSH is set then
+ 	 * ACPI_NFIT_CAPABILITY_MEM_FLUSH is implied.
+ 	 */
+ 	if (acpi_desc->platform_cap & ACPI_NFIT_CAPABILITY_CACHE_FLUSH)
+ 		set_bit(ND_REGION_PERSIST_CACHE, &ndr_desc->flags);
+ 	else if (acpi_desc->platform_cap & ACPI_NFIT_CAPABILITY_MEM_FLUSH)
+ 		set_bit(ND_REGION_PERSIST_MEMCTRL, &ndr_desc->flags);
+ 
++>>>>>>> fe9a552e715d (libnvdimm, nfit: fix persistence domain reporting)
  	list_for_each_entry(nfit_memdev, &acpi_desc->memdevs, list) {
  		struct acpi_nfit_memory_map *memdev = nfit_memdev->memdev;
  		struct nd_mapping_desc *mapping;
* Unmerged path drivers/acpi/nfit/core.c
diff --git a/drivers/nvdimm/region_devs.c b/drivers/nvdimm/region_devs.c
index 7a7f86aa6595..1a349450537c 100644
--- a/drivers/nvdimm/region_devs.c
+++ b/drivers/nvdimm/region_devs.c
@@ -533,11 +533,13 @@ static ssize_t persistence_domain_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	struct nd_region *nd_region = to_nd_region(dev);
-	unsigned long flags = nd_region->flags;
 
-	return sprintf(buf, "%s%s\n",
-			flags & BIT(ND_REGION_PERSIST_CACHE) ? "cpu_cache " : "",
-			flags & BIT(ND_REGION_PERSIST_MEMCTRL) ? "memory_controller " : "");
+	if (test_bit(ND_REGION_PERSIST_CACHE, &nd_region->flags))
+		return sprintf(buf, "cpu_cache\n");
+	else if (test_bit(ND_REGION_PERSIST_MEMCTRL, &nd_region->flags))
+		return sprintf(buf, "memory_controller\n");
+	else
+		return sprintf(buf, "\n");
 }
 static DEVICE_ATTR_RO(persistence_domain);
 
