sfc: hold filter_sem consistently during reset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Bert Kenward <bkenward@solarflare.com>
commit 193f20033c54db0dc9563f722fbafbcd5fa0e80d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/193f2003.failed

We should take and release the filter_sem consistently during the
reset process, in the same manner as the mac_lock and reset_lock.

For lockdep consistency we also take the filter_sem for write around
other calls to efx->type->init().

Fixes: c2bebe37c6b6 ("sfc: give ef10 its own rwsem in the filter table instead of filter_lock")
	Signed-off-by: Bert Kenward <bkenward@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 193f20033c54db0dc9563f722fbafbcd5fa0e80d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/efx.c
diff --cc drivers/net/ethernet/sfc/efx.c
index 9559ba0654b0,ce3a177081a8..000000000000
--- a/drivers/net/ethernet/sfc/efx.c
+++ b/drivers/net/ethernet/sfc/efx.c
@@@ -2650,6 -2682,8 +2644,11 @@@ void efx_reset_down(struct efx_nic *efx
  	efx_disable_interrupts(efx);
  
  	mutex_lock(&efx->mac_lock);
++<<<<<<< HEAD
++=======
+ 	down_write(&efx->filter_sem);
+ 	mutex_lock(&efx->rss_lock);
++>>>>>>> 193f20033c54 (sfc: hold filter_sem consistently during reset)
  	if (efx->port_initialized && method != RESET_TYPE_INVISIBLE &&
  	    method != RESET_TYPE_DATAPATH)
  		efx->phy_op->fini(efx);
@@@ -2705,9 -2739,9 +2704,15 @@@ int efx_reset_up(struct efx_nic *efx, e
  
  	if (efx->type->rx_restore_rss_contexts)
  		efx->type->rx_restore_rss_contexts(efx);
++<<<<<<< HEAD
 +	down_read(&efx->filter_sem);
 +	efx_restore_filters(efx);
 +	up_read(&efx->filter_sem);
++=======
+ 	mutex_unlock(&efx->rss_lock);
+ 	efx->type->filter_table_restore(efx);
+ 	up_write(&efx->filter_sem);
++>>>>>>> 193f20033c54 (sfc: hold filter_sem consistently during reset)
  	if (efx->type->sriov_reset)
  		efx->type->sriov_reset(efx);
  
@@@ -2723,6 -2757,8 +2728,11 @@@
  fail:
  	efx->port_initialized = false;
  
++<<<<<<< HEAD
++=======
+ 	mutex_unlock(&efx->rss_lock);
+ 	up_write(&efx->filter_sem);
++>>>>>>> 193f20033c54 (sfc: hold filter_sem consistently during reset)
  	mutex_unlock(&efx->mac_lock);
  
  	return rc;
* Unmerged path drivers/net/ethernet/sfc/efx.c
