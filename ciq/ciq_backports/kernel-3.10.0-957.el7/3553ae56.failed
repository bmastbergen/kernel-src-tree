x86/kvm: Don't use pvqspinlock code if only 1 vCPU

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] kvm: Don't use pvqspinlock code if only 1 vCPU (Waiman Long) [1602155]
Rebuild_FUZZ: 95.83%
commit-author Waiman Long <longman@redhat.com>
commit 3553ae5690a84a5baae5baa329467b3df2d99f72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/3553ae56.failed

On a VM with only 1 vCPU, the locking fast path will always be
successful. In this case, there is no need to use the the PV qspinlock
code which has higher overhead on the unlock side than the native
qspinlock code.

	Signed-off-by: Waiman Long <longman@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 3553ae5690a84a5baae5baa329467b3df2d99f72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/kvm.c
diff --cc arch/x86/kernel/kvm.c
index 63158e3d1dd9,575c9a51e6ba..000000000000
--- a/arch/x86/kernel/kvm.c
+++ b/arch/x86/kernel/kvm.c
@@@ -859,7 -745,13 +859,17 @@@ void __init kvm_spinlock_init(void
  	if (!kvm_para_has_feature(KVM_FEATURE_PV_UNHALT))
  		return;
  
++<<<<<<< HEAD
 +#ifdef CONFIG_QUEUED_SPINLOCKS
++=======
+ 	if (kvm_para_has_hint(KVM_HINTS_REALTIME))
+ 		return;
+ 
+ 	/* Don't use the pvqspinlock code if there is only 1 vCPU. */
+ 	if (num_possible_cpus() == 1)
+ 		return;
+ 
++>>>>>>> 3553ae5690a8 (x86/kvm: Don't use pvqspinlock code if only 1 vCPU)
  	__pv_init_lock_hash();
  	pv_lock_ops.queued_spin_lock_slowpath = __pv_queued_spin_lock_slowpath;
  	pv_lock_ops.queued_spin_unlock = PV_CALLEE_SAVE(__pv_queued_spin_unlock);
* Unmerged path arch/x86/kernel/kvm.c
