i40e/i40evf: Add support for new mechanism of updating adaptive ITR

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Alexander Duyck <alexander.h.duyck@intel.com>
commit a0073a4b8b5906b2a7eab5e9d4a91759b56bc96f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/a0073a4b.failed

This patch replaces the existing mechanism for determining the correct
value to program for adaptive ITR with yet another new and more
complicated approach.

The basic idea from a 30K foot view is that this new approach will push the
Rx interrupt moderation up so that by default it starts in low latency and
is gradually pushed up into a higher latency setup as long as doing so
increases the number of packets processed, if the number of packets drops
to 4 to 1 per packet we will reset and just base our ITR on the size of the
packets being received. For Tx we leave it floating at a high interrupt
delay and do not pull it down unless we start processing more than 112
packets per interrupt. If we start exceeding that we will cut our interrupt
rates in half until we are back below 112.

The side effect of these patches are that we will be processing more
packets per interrupt. This is both a good and a bad thing as it means we
will not be blocking processing in the case of things like pktgen and XDP,
but we will also be consuming a bit more CPU in the cases of things such as
network throughput tests using netperf.

One delta from this versus the ixgbe version of the changes is that I have
made the interrupt moderation a bit more aggressive when we are in bulk
mode by moving our "goldilocks zone" up from 48 to 96 to 56 to 112. The
main motivation behind moving this is to address the fact that we need to
update less frequently, and have more fine grained control due to the
separate Tx and Rx ITR times.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit a0073a4b8b5906b2a7eab5e9d4a91759b56bc96f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
#	drivers/net/ethernet/intel/i40e/i40e_txrx.c
#	drivers/net/ethernet/intel/i40e/i40e_txrx.h
#	drivers/net/ethernet/intel/i40evf/i40e_txrx.c
#	drivers/net/ethernet/intel/i40evf/i40e_txrx.h
#	drivers/net/ethernet/intel/i40evf/i40evf_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 6c3f00818e15,70ecd9c3a163..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -3388,15 -3449,20 +3388,32 @@@ static void i40e_vsi_configure_msix(str
  	for (i = 0; i < vsi->num_q_vectors; i++, vector++) {
  		struct i40e_q_vector *q_vector = vsi->q_vectors[i];
  
++<<<<<<< HEAD
 +		q_vector->itr_countdown = ITR_COUNTDOWN_START;
 +		q_vector->rx.itr = ITR_TO_REG(vsi->rx_rings[i]->rx_itr_setting);
 +		q_vector->rx.latency_range = I40E_LOW_LATENCY;
 +		wr32(hw, I40E_PFINT_ITRN(I40E_RX_ITR, vector - 1),
 +		     q_vector->rx.itr);
 +		q_vector->tx.itr = ITR_TO_REG(vsi->tx_rings[i]->tx_itr_setting);
 +		q_vector->tx.latency_range = I40E_LOW_LATENCY;
 +		wr32(hw, I40E_PFINT_ITRN(I40E_TX_ITR, vector - 1),
 +		     q_vector->tx.itr);
++=======
+ 		q_vector->rx.next_update = jiffies + 1;
+ 		q_vector->rx.target_itr =
+ 			ITR_TO_REG(vsi->rx_rings[i]->itr_setting);
+ 		wr32(hw, I40E_PFINT_ITRN(I40E_RX_ITR, vector - 1),
+ 		     q_vector->rx.target_itr);
+ 		q_vector->rx.current_itr = q_vector->rx.target_itr;
+ 
+ 		q_vector->tx.next_update = jiffies + 1;
+ 		q_vector->tx.target_itr =
+ 			ITR_TO_REG(vsi->tx_rings[i]->itr_setting);
+ 		wr32(hw, I40E_PFINT_ITRN(I40E_TX_ITR, vector - 1),
+ 		     q_vector->tx.target_itr);
+ 		q_vector->tx.current_itr = q_vector->tx.target_itr;
+ 
++>>>>>>> a0073a4b8b59 (i40e/i40evf: Add support for new mechanism of updating adaptive ITR)
  		wr32(hw, I40E_PFINT_RATEN(vector - 1),
  		     i40e_intrl_usec_to_reg(vsi->int_rate_limit));
  
@@@ -3484,13 -3563,14 +3501,24 @@@ static void i40e_configure_msi_and_lega
  	u32 val;
  
  	/* set the ITR configuration */
++<<<<<<< HEAD
 +	q_vector->itr_countdown = ITR_COUNTDOWN_START;
 +	q_vector->rx.itr = ITR_TO_REG(vsi->rx_rings[0]->rx_itr_setting);
 +	q_vector->rx.latency_range = I40E_LOW_LATENCY;
 +	wr32(hw, I40E_PFINT_ITR0(I40E_RX_ITR), q_vector->rx.itr);
 +	q_vector->tx.itr = ITR_TO_REG(vsi->tx_rings[0]->tx_itr_setting);
 +	q_vector->tx.latency_range = I40E_LOW_LATENCY;
 +	wr32(hw, I40E_PFINT_ITR0(I40E_TX_ITR), q_vector->tx.itr);
++=======
+ 	q_vector->rx.next_update = jiffies + 1;
+ 	q_vector->rx.target_itr = ITR_TO_REG(vsi->rx_rings[0]->itr_setting);
+ 	wr32(hw, I40E_PFINT_ITR0(I40E_RX_ITR), q_vector->rx.target_itr);
+ 	q_vector->rx.current_itr = q_vector->rx.target_itr;
+ 	q_vector->tx.next_update = jiffies + 1;
+ 	q_vector->tx.target_itr = ITR_TO_REG(vsi->tx_rings[0]->itr_setting);
+ 	wr32(hw, I40E_PFINT_ITR0(I40E_TX_ITR), q_vector->tx.target_itr);
+ 	q_vector->tx.current_itr = q_vector->tx.target_itr;
++>>>>>>> a0073a4b8b59 (i40e/i40evf: Add support for new mechanism of updating adaptive ITR)
  
  	i40e_enable_misc_int_causes(pf);
  
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 29471f5698b7,1ec9b1d8023d..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@@ -986,99 -995,241 +986,284 @@@ void i40e_force_wb(struct i40e_vsi *vsi
  	}
  }
  
+ static inline bool i40e_container_is_rx(struct i40e_q_vector *q_vector,
+ 					struct i40e_ring_container *rc)
+ {
+ 	return &q_vector->rx == rc;
+ }
+ 
+ static inline unsigned int i40e_itr_divisor(struct i40e_q_vector *q_vector)
+ {
+ 	unsigned int divisor;
+ 
+ 	switch (q_vector->vsi->back->hw.phy.link_info.link_speed) {
+ 	case I40E_LINK_SPEED_40GB:
+ 		divisor = I40E_ITR_ADAPTIVE_MIN_INC * 1024;
+ 		break;
+ 	case I40E_LINK_SPEED_25GB:
+ 	case I40E_LINK_SPEED_20GB:
+ 		divisor = I40E_ITR_ADAPTIVE_MIN_INC * 512;
+ 		break;
+ 	default:
+ 	case I40E_LINK_SPEED_10GB:
+ 		divisor = I40E_ITR_ADAPTIVE_MIN_INC * 256;
+ 		break;
+ 	case I40E_LINK_SPEED_1GB:
+ 	case I40E_LINK_SPEED_100MB:
+ 		divisor = I40E_ITR_ADAPTIVE_MIN_INC * 32;
+ 		break;
+ 	}
+ 
+ 	return divisor;
+ }
+ 
  /**
-  * i40e_set_new_dynamic_itr - Find new ITR level
+  * i40e_update_itr - update the dynamic ITR value based on statistics
+  * @q_vector: structure containing interrupt and ring information
   * @rc: structure containing ring performance data
   *
-  * Returns true if ITR changed, false if not
-  *
-  * Stores a new ITR value based on packets and byte counts during
-  * the last interrupt.  The advantage of per interrupt computation
-  * is faster updates and more accurate ITR for the current traffic
-  * pattern.  Constants in this function were computed based on
-  * theoretical maximum wire speed and thresholds were set based on
-  * testing data as well as attempting to minimize response time
+  * Stores a new ITR value based on packets and byte
+  * counts during the last interrupt.  The advantage of per interrupt
+  * computation is faster updates and more accurate ITR for the current
+  * traffic pattern.  Constants in this function were computed
+  * based on theoretical maximum wire speed and thresholds were set based
+  * on testing data as well as attempting to minimize response time
   * while increasing bulk throughput.
   **/
- static bool i40e_set_new_dynamic_itr(struct i40e_ring_container *rc)
+ static void i40e_update_itr(struct i40e_q_vector *q_vector,
+ 			    struct i40e_ring_container *rc)
  {
++<<<<<<< HEAD
 +	enum i40e_latency_range new_latency_range = rc->latency_range;
 +	u32 new_itr = rc->itr;
 +	int bytes_per_usec;
 +	unsigned int usecs, estimated_usecs;
 +
 +	if (rc->total_packets == 0 || !rc->itr)
 +		return false;
 +
 +	usecs = (rc->itr << 1) * ITR_COUNTDOWN_START;
 +	bytes_per_usec = rc->total_bytes / usecs;
 +
 +	/* The calculations in this algorithm depend on interrupts actually
 +	 * firing at the ITR rate. This may not happen if the packet rate is
 +	 * really low, or if we've been napi polling. Check to make sure
 +	 * that's not the case before we continue.
++=======
+ 	unsigned int avg_wire_size, packets, bytes, itr;
+ 	unsigned long next_update = jiffies;
+ 
+ 	/* If we don't have any rings just leave ourselves set for maximum
+ 	 * possible latency so we take ourselves out of the equation.
+ 	 */
+ 	if (!rc->ring || !ITR_IS_DYNAMIC(rc->ring->itr_setting))
+ 		return;
+ 
+ 	/* For Rx we want to push the delay up and default to low latency.
+ 	 * for Tx we want to pull the delay down and default to high latency.
++>>>>>>> a0073a4b8b59 (i40e/i40evf: Add support for new mechanism of updating adaptive ITR)
  	 */
- 	estimated_usecs = jiffies_to_usecs(jiffies - rc->last_itr_update);
- 	if (estimated_usecs > usecs) {
- 		new_latency_range = I40E_LOW_LATENCY;
- 		goto reset_latency;
+ 	itr = i40e_container_is_rx(q_vector, rc) ?
+ 	      I40E_ITR_ADAPTIVE_MIN_USECS | I40E_ITR_ADAPTIVE_LATENCY :
+ 	      I40E_ITR_ADAPTIVE_MAX_USECS | I40E_ITR_ADAPTIVE_LATENCY;
+ 
+ 	/* If we didn't update within up to 1 - 2 jiffies we can assume
+ 	 * that either packets are coming in so slow there hasn't been
+ 	 * any work, or that there is so much work that NAPI is dealing
+ 	 * with interrupt moderation and we don't need to do anything.
+ 	 */
+ 	if (time_after(next_update, rc->next_update))
+ 		goto clear_counts;
+ 
+ 	/* If itr_countdown is set it means we programmed an ITR within
+ 	 * the last 4 interrupt cycles. This has a side effect of us
+ 	 * potentially firing an early interrupt. In order to work around
+ 	 * this we need to throw out any data received for a few
+ 	 * interrupts following the update.
+ 	 */
+ 	if (q_vector->itr_countdown) {
+ 		itr = rc->target_itr;
+ 		goto clear_counts;
+ 	}
+ 
+ 	packets = rc->total_packets;
+ 	bytes = rc->total_bytes;
+ 
+ 	if (i40e_container_is_rx(q_vector, rc)) {
+ 		/* If Rx there are 1 to 4 packets and bytes are less than
+ 		 * 9000 assume insufficient data to use bulk rate limiting
+ 		 * approach unless Tx is already in bulk rate limiting. We
+ 		 * are likely latency driven.
+ 		 */
+ 		if (packets && packets < 4 && bytes < 9000 &&
+ 		    (q_vector->tx.target_itr & I40E_ITR_ADAPTIVE_LATENCY)) {
+ 			itr = I40E_ITR_ADAPTIVE_LATENCY;
+ 			goto adjust_by_size;
+ 		}
+ 	} else if (packets < 4) {
+ 		/* If we have Tx and Rx ITR maxed and Tx ITR is running in
+ 		 * bulk mode and we are receiving 4 or fewer packets just
+ 		 * reset the ITR_ADAPTIVE_LATENCY bit for latency mode so
+ 		 * that the Rx can relax.
+ 		 */
+ 		if (rc->target_itr == I40E_ITR_ADAPTIVE_MAX_USECS &&
+ 		    (q_vector->rx.target_itr & I40E_ITR_MASK) ==
+ 		     I40E_ITR_ADAPTIVE_MAX_USECS)
+ 			goto clear_counts;
+ 	} else if (packets > 32) {
+ 		/* If we have processed over 32 packets in a single interrupt
+ 		 * for Tx assume we need to switch over to "bulk" mode.
+ 		 */
+ 		rc->target_itr &= ~I40E_ITR_ADAPTIVE_LATENCY;
  	}
  
- 	/* simple throttlerate management
- 	 *   0-10MB/s   lowest (50000 ints/s)
- 	 *  10-20MB/s   low    (20000 ints/s)
- 	 *  20-1249MB/s bulk   (18000 ints/s)
+ 	/* We have no packets to actually measure against. This means
+ 	 * either one of the other queues on this vector is active or
+ 	 * we are a Tx queue doing TSO with too high of an interrupt rate.
  	 *
- 	 * The math works out because the divisor is in 10^(-6) which
- 	 * turns the bytes/us input value into MB/s values, but
- 	 * make sure to use usecs, as the register values written
- 	 * are in 2 usec increments in the ITR registers, and make sure
- 	 * to use the smoothed values that the countdown timer gives us.
+ 	 * Between 4 and 56 we can assume that our current interrupt delay
+ 	 * is only slightly too low. As such we should increase it by a small
+ 	 * fixed amount.
  	 */
- 	switch (new_latency_range) {
- 	case I40E_LOWEST_LATENCY:
- 		if (bytes_per_usec > 10)
- 			new_latency_range = I40E_LOW_LATENCY;
- 		break;
- 	case I40E_LOW_LATENCY:
- 		if (bytes_per_usec > 20)
- 			new_latency_range = I40E_BULK_LATENCY;
- 		else if (bytes_per_usec <= 10)
- 			new_latency_range = I40E_LOWEST_LATENCY;
- 		break;
- 	case I40E_BULK_LATENCY:
- 	default:
- 		if (bytes_per_usec <= 20)
- 			new_latency_range = I40E_LOW_LATENCY;
- 		break;
+ 	if (packets < 56) {
+ 		itr = rc->target_itr + I40E_ITR_ADAPTIVE_MIN_INC;
+ 		if ((itr & I40E_ITR_MASK) > I40E_ITR_ADAPTIVE_MAX_USECS) {
+ 			itr &= I40E_ITR_ADAPTIVE_LATENCY;
+ 			itr += I40E_ITR_ADAPTIVE_MAX_USECS;
+ 		}
+ 		goto clear_counts;
  	}
  
- reset_latency:
- 	rc->latency_range = new_latency_range;
+ 	if (packets <= 256) {
+ 		itr = min(q_vector->tx.current_itr, q_vector->rx.current_itr);
+ 		itr &= I40E_ITR_MASK;
  
++<<<<<<< HEAD
 +	switch (new_latency_range) {
 +	case I40E_LOWEST_LATENCY:
 +		new_itr = I40E_ITR_50K;
 +		break;
 +	case I40E_LOW_LATENCY:
 +		new_itr = I40E_ITR_20K;
 +		break;
 +	case I40E_BULK_LATENCY:
 +		new_itr = I40E_ITR_18K;
 +		break;
 +	default:
 +		break;
++=======
+ 		/* Between 56 and 112 is our "goldilocks" zone where we are
+ 		 * working out "just right". Just report that our current
+ 		 * ITR is good for us.
+ 		 */
+ 		if (packets <= 112)
+ 			goto clear_counts;
+ 
+ 		/* If packet count is 128 or greater we are likely looking
+ 		 * at a slight overrun of the delay we want. Try halving
+ 		 * our delay to see if that will cut the number of packets
+ 		 * in half per interrupt.
+ 		 */
+ 		itr /= 2;
+ 		itr &= I40E_ITR_MASK;
+ 		if (itr < I40E_ITR_ADAPTIVE_MIN_USECS)
+ 			itr = I40E_ITR_ADAPTIVE_MIN_USECS;
+ 
+ 		goto clear_counts;
++>>>>>>> a0073a4b8b59 (i40e/i40evf: Add support for new mechanism of updating adaptive ITR)
+ 	}
+ 
+ 	/* The paths below assume we are dealing with a bulk ITR since
+ 	 * number of packets is greater than 256. We are just going to have
+ 	 * to compute a value and try to bring the count under control,
+ 	 * though for smaller packet sizes there isn't much we can do as
+ 	 * NAPI polling will likely be kicking in sooner rather than later.
+ 	 */
+ 	itr = I40E_ITR_ADAPTIVE_BULK;
+ 
+ adjust_by_size:
+ 	/* If packet counts are 256 or greater we can assume we have a gross
+ 	 * overestimation of what the rate should be. Instead of trying to fine
+ 	 * tune it just use the formula below to try and dial in an exact value
+ 	 * give the current packet size of the frame.
+ 	 */
+ 	avg_wire_size = bytes / packets;
+ 
+ 	/* The following is a crude approximation of:
+ 	 *  wmem_default / (size + overhead) = desired_pkts_per_int
+ 	 *  rate / bits_per_byte / (size + ethernet overhead) = pkt_rate
+ 	 *  (desired_pkt_rate / pkt_rate) * usecs_per_sec = ITR value
+ 	 *
+ 	 * Assuming wmem_default is 212992 and overhead is 640 bytes per
+ 	 * packet, (256 skb, 64 headroom, 320 shared info), we can reduce the
+ 	 * formula down to
+ 	 *
+ 	 *  (170 * (size + 24)) / (size + 640) = ITR
+ 	 *
+ 	 * We first do some math on the packet size and then finally bitshift
+ 	 * by 8 after rounding up. We also have to account for PCIe link speed
+ 	 * difference as ITR scales based on this.
+ 	 */
+ 	if (avg_wire_size <= 60) {
+ 		/* Start at 250k ints/sec */
+ 		avg_wire_size = 4096;
+ 	} else if (avg_wire_size <= 380) {
+ 		/* 250K ints/sec to 60K ints/sec */
+ 		avg_wire_size *= 40;
+ 		avg_wire_size += 1696;
+ 	} else if (avg_wire_size <= 1084) {
+ 		/* 60K ints/sec to 36K ints/sec */
+ 		avg_wire_size *= 15;
+ 		avg_wire_size += 11452;
+ 	} else if (avg_wire_size <= 1980) {
+ 		/* 36K ints/sec to 30K ints/sec */
+ 		avg_wire_size *= 5;
+ 		avg_wire_size += 22420;
+ 	} else {
+ 		/* plateau at a limit of 30K ints/sec */
+ 		avg_wire_size = 32256;
+ 	}
+ 
+ 	/* If we are in low latency mode halve our delay which doubles the
+ 	 * rate to somewhere between 100K to 16K ints/sec
+ 	 */
+ 	if (itr & I40E_ITR_ADAPTIVE_LATENCY)
+ 		avg_wire_size /= 2;
+ 
+ 	/* Resultant value is 256 times larger than it needs to be. This
+ 	 * gives us room to adjust the value as needed to either increase
+ 	 * or decrease the value based on link speeds of 10G, 2.5G, 1G, etc.
+ 	 *
+ 	 * Use addition as we have already recorded the new latency flag
+ 	 * for the ITR value.
+ 	 */
+ 	itr += DIV_ROUND_UP(avg_wire_size, i40e_itr_divisor(q_vector)) *
+ 	       I40E_ITR_ADAPTIVE_MIN_INC;
+ 
+ 	if ((itr & I40E_ITR_MASK) > I40E_ITR_ADAPTIVE_MAX_USECS) {
+ 		itr &= I40E_ITR_ADAPTIVE_LATENCY;
+ 		itr += I40E_ITR_ADAPTIVE_MAX_USECS;
  	}
  
+ clear_counts:
+ 	/* write back value */
+ 	rc->target_itr = itr;
+ 
+ 	/* next update should occur within next jiffy */
+ 	rc->next_update = next_update + 1;
+ 
  	rc->total_bytes = 0;
  	rc->total_packets = 0;
++<<<<<<< HEAD
 +	rc->last_itr_update = jiffies;
 +
 +	if (new_itr != rc->itr) {
 +		rc->itr = new_itr;
 +		return true;
 +	}
 +	return false;
++=======
++>>>>>>> a0073a4b8b59 (i40e/i40evf: Add support for new mechanism of updating adaptive ITR)
  }
  
  /**
@@@ -2236,16 -2446,16 +2421,25 @@@ static u32 i40e_buildreg_itr(const int 
  
  /* a small macro to shorten up some long lines */
  #define INTREG I40E_PFINT_DYN_CTLN
 +static inline int get_rx_itr(struct i40e_vsi *vsi, int idx)
 +{
 +	return vsi->rx_rings[idx]->rx_itr_setting;
 +}
 +
 +static inline int get_tx_itr(struct i40e_vsi *vsi, int idx)
 +{
 +	return vsi->tx_rings[idx]->tx_itr_setting;
 +}
  
+ /* The act of updating the ITR will cause it to immediately trigger. In order
+  * to prevent this from throwing off adaptive update statistics we defer the
+  * update so that it can only happen so often. So after either Tx or Rx are
+  * updated we make the adaptive scheme wait until either the ITR completely
+  * expires via the next_update expiration or we have been through at least
+  * 3 interrupts.
+  */
+ #define ITR_COUNTDOWN_START 3
+ 
  /**
   * i40e_update_enable_itr - Update itr and re-enable MSIX interrupt
   * @vsi: the VSI we care about
@@@ -2256,10 -2466,7 +2450,14 @@@ static inline void i40e_update_enable_i
  					  struct i40e_q_vector *q_vector)
  {
  	struct i40e_hw *hw = &vsi->back->hw;
++<<<<<<< HEAD
 +	bool rx = false, tx = false;
 +	u32 rxval, txval;
 +	int idx = q_vector->v_idx;
 +	int rx_itr_setting, tx_itr_setting;
++=======
+ 	u32 intval;
++>>>>>>> a0073a4b8b59 (i40e/i40evf: Add support for new mechanism of updating adaptive ITR)
  
  	/* If we don't have MSIX, then we only need to re-enable icr0 */
  	if (!(vsi->back->flags & I40E_FLAG_MSIX_ENABLED)) {
@@@ -2267,65 -2474,49 +2465,111 @@@
  		return;
  	}
  
++<<<<<<< HEAD
 +	/* avoid dynamic calculation if in countdown mode OR if
 +	 * all dynamic is disabled
 +	 */
 +	rxval = txval = i40e_buildreg_itr(I40E_ITR_NONE, 0);
 +
 +	rx_itr_setting = get_rx_itr(vsi, idx);
 +	tx_itr_setting = get_tx_itr(vsi, idx);
 +
 +	if (q_vector->itr_countdown > 0 ||
 +	    (!ITR_IS_DYNAMIC(rx_itr_setting) &&
 +	     !ITR_IS_DYNAMIC(tx_itr_setting))) {
 +		goto enable_int;
 +	}
 +
 +	if (ITR_IS_DYNAMIC(rx_itr_setting)) {
 +		rx = i40e_set_new_dynamic_itr(&q_vector->rx);
 +		rxval = i40e_buildreg_itr(I40E_RX_ITR, q_vector->rx.itr);
 +	}
 +
 +	if (ITR_IS_DYNAMIC(tx_itr_setting)) {
 +		tx = i40e_set_new_dynamic_itr(&q_vector->tx);
 +		txval = i40e_buildreg_itr(I40E_TX_ITR, q_vector->tx.itr);
 +	}
 +
 +	if (rx || tx) {
 +		/* get the higher of the two ITR adjustments and
 +		 * use the same value for both ITR registers
 +		 * when in adaptive mode (Rx and/or Tx)
 +		 */
 +		u16 itr = max(q_vector->tx.itr, q_vector->rx.itr);
 +
 +		q_vector->tx.itr = q_vector->rx.itr = itr;
 +		txval = i40e_buildreg_itr(I40E_TX_ITR, itr);
 +		tx = true;
 +		rxval = i40e_buildreg_itr(I40E_RX_ITR, itr);
 +		rx = true;
 +	}
 +
 +	/* only need to enable the interrupt once, but need
 +	 * to possibly update both ITR values
 +	 */
 +	if (rx) {
 +		/* set the INTENA_MSK_MASK so that this first write
 +		 * won't actually enable the interrupt, instead just
 +		 * updating the ITR (it's bit 31 PF and VF)
 +		 */
 +		rxval |= BIT(31);
 +		/* don't check _DOWN because interrupt isn't being enabled */
 +		wr32(hw, INTREG(q_vector->reg_idx), rxval);
 +	}
 +
 +enable_int:
 +	if (!test_bit(__I40E_VSI_DOWN, vsi->state))
 +		wr32(hw, INTREG(q_vector->reg_idx), txval);
 +
 +	if (q_vector->itr_countdown)
 +		q_vector->itr_countdown--;
 +	else
 +		q_vector->itr_countdown = ITR_COUNTDOWN_START;
++=======
+ 	/* These will do nothing if dynamic updates are not enabled */
+ 	i40e_update_itr(q_vector, &q_vector->tx);
+ 	i40e_update_itr(q_vector, &q_vector->rx);
+ 
+ 	/* This block of logic allows us to get away with only updating
+ 	 * one ITR value with each interrupt. The idea is to perform a
+ 	 * pseudo-lazy update with the following criteria.
+ 	 *
+ 	 * 1. Rx is given higher priority than Tx if both are in same state
+ 	 * 2. If we must reduce an ITR that is given highest priority.
+ 	 * 3. We then give priority to increasing ITR based on amount.
+ 	 */
+ 	if (q_vector->rx.target_itr < q_vector->rx.current_itr) {
+ 		/* Rx ITR needs to be reduced, this is highest priority */
+ 		intval = i40e_buildreg_itr(I40E_RX_ITR,
+ 					   q_vector->rx.target_itr);
+ 		q_vector->rx.current_itr = q_vector->rx.target_itr;
+ 		q_vector->itr_countdown = ITR_COUNTDOWN_START;
+ 	} else if ((q_vector->tx.target_itr < q_vector->tx.current_itr) ||
+ 		   ((q_vector->rx.target_itr - q_vector->rx.current_itr) <
+ 		    (q_vector->tx.target_itr - q_vector->tx.current_itr))) {
+ 		/* Tx ITR needs to be reduced, this is second priority
+ 		 * Tx ITR needs to be increased more than Rx, fourth priority
+ 		 */
+ 		intval = i40e_buildreg_itr(I40E_TX_ITR,
+ 					   q_vector->tx.target_itr);
+ 		q_vector->tx.current_itr = q_vector->tx.target_itr;
+ 		q_vector->itr_countdown = ITR_COUNTDOWN_START;
+ 	} else if (q_vector->rx.current_itr != q_vector->rx.target_itr) {
+ 		/* Rx ITR needs to be increased, third priority */
+ 		intval = i40e_buildreg_itr(I40E_RX_ITR,
+ 					   q_vector->rx.target_itr);
+ 		q_vector->rx.current_itr = q_vector->rx.target_itr;
+ 		q_vector->itr_countdown = ITR_COUNTDOWN_START;
+ 	} else {
+ 		/* No ITR update, lowest priority */
+ 		intval = i40e_buildreg_itr(I40E_ITR_NONE, 0);
+ 		if (q_vector->itr_countdown)
+ 			q_vector->itr_countdown--;
+ 	}
+ 
+ 	if (!test_bit(__I40E_VSI_DOWN, vsi->state))
+ 		wr32(hw, INTREG(q_vector->reg_idx), intval);
++>>>>>>> a0073a4b8b59 (i40e/i40evf: Add support for new mechanism of updating adaptive ITR)
  }
  
  /**
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.h
index b39e067a394b,f75a8fe68fcf..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.h
@@@ -447,21 -453,31 +447,44 @@@ static inline void clear_ring_build_skb
  	ring->flags &= ~I40E_RXR_FLAGS_BUILD_SKB_ENABLED;
  }
  
++<<<<<<< HEAD
 +enum i40e_latency_range {
 +	I40E_LOWEST_LATENCY = 0,
 +	I40E_LOW_LATENCY = 1,
 +	I40E_BULK_LATENCY = 2,
 +};
++=======
+ static inline bool ring_is_xdp(struct i40e_ring *ring)
+ {
+ 	return !!(ring->flags & I40E_TXR_FLAGS_XDP);
+ }
+ 
+ static inline void set_ring_xdp(struct i40e_ring *ring)
+ {
+ 	ring->flags |= I40E_TXR_FLAGS_XDP;
+ }
+ 
+ #define I40E_ITR_ADAPTIVE_MIN_INC	0x0002
+ #define I40E_ITR_ADAPTIVE_MIN_USECS	0x0002
+ #define I40E_ITR_ADAPTIVE_MAX_USECS	0x007e
+ #define I40E_ITR_ADAPTIVE_LATENCY	0x8000
+ #define I40E_ITR_ADAPTIVE_BULK		0x0000
+ #define ITR_IS_BULK(x) (!((x) & I40E_ITR_ADAPTIVE_LATENCY))
++>>>>>>> a0073a4b8b59 (i40e/i40evf: Add support for new mechanism of updating adaptive ITR)
  
  struct i40e_ring_container {
- 	/* array of pointers to rings */
- 	struct i40e_ring *ring;
+ 	struct i40e_ring *ring;		/* pointer to linked list of ring(s) */
+ 	unsigned long next_update;	/* jiffies value of next update */
  	unsigned int total_bytes;	/* total bytes processed this int */
  	unsigned int total_packets;	/* total packets processed this int */
- 	unsigned long last_itr_update;	/* jiffies of last ITR update */
  	u16 count;
++<<<<<<< HEAD
 +	enum i40e_latency_range latency_range;
 +	u16 itr;
++=======
+ 	u16 target_itr;			/* target ITR setting for ring(s) */
+ 	u16 current_itr;		/* current ITR setting for ring(s) */
++>>>>>>> a0073a4b8b59 (i40e/i40evf: Add support for new mechanism of updating adaptive ITR)
  };
  
  /* iterator for handling rings in ring container */
diff --cc drivers/net/ethernet/intel/i40evf/i40e_txrx.c
index 7b9ead8b878f,eb8f3e327f6b..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
@@@ -392,99 -392,241 +392,284 @@@ void i40evf_force_wb(struct i40e_vsi *v
  	     val);
  }
  
+ static inline bool i40e_container_is_rx(struct i40e_q_vector *q_vector,
+ 					struct i40e_ring_container *rc)
+ {
+ 	return &q_vector->rx == rc;
+ }
+ 
+ static inline unsigned int i40e_itr_divisor(struct i40e_q_vector *q_vector)
+ {
+ 	unsigned int divisor;
+ 
+ 	switch (q_vector->adapter->link_speed) {
+ 	case I40E_LINK_SPEED_40GB:
+ 		divisor = I40E_ITR_ADAPTIVE_MIN_INC * 1024;
+ 		break;
+ 	case I40E_LINK_SPEED_25GB:
+ 	case I40E_LINK_SPEED_20GB:
+ 		divisor = I40E_ITR_ADAPTIVE_MIN_INC * 512;
+ 		break;
+ 	default:
+ 	case I40E_LINK_SPEED_10GB:
+ 		divisor = I40E_ITR_ADAPTIVE_MIN_INC * 256;
+ 		break;
+ 	case I40E_LINK_SPEED_1GB:
+ 	case I40E_LINK_SPEED_100MB:
+ 		divisor = I40E_ITR_ADAPTIVE_MIN_INC * 32;
+ 		break;
+ 	}
+ 
+ 	return divisor;
+ }
+ 
  /**
-  * i40e_set_new_dynamic_itr - Find new ITR level
+  * i40e_update_itr - update the dynamic ITR value based on statistics
+  * @q_vector: structure containing interrupt and ring information
   * @rc: structure containing ring performance data
   *
-  * Returns true if ITR changed, false if not
-  *
-  * Stores a new ITR value based on packets and byte counts during
-  * the last interrupt.  The advantage of per interrupt computation
-  * is faster updates and more accurate ITR for the current traffic
-  * pattern.  Constants in this function were computed based on
-  * theoretical maximum wire speed and thresholds were set based on
-  * testing data as well as attempting to minimize response time
+  * Stores a new ITR value based on packets and byte
+  * counts during the last interrupt.  The advantage of per interrupt
+  * computation is faster updates and more accurate ITR for the current
+  * traffic pattern.  Constants in this function were computed
+  * based on theoretical maximum wire speed and thresholds were set based
+  * on testing data as well as attempting to minimize response time
   * while increasing bulk throughput.
   **/
- static bool i40e_set_new_dynamic_itr(struct i40e_ring_container *rc)
+ static void i40e_update_itr(struct i40e_q_vector *q_vector,
+ 			    struct i40e_ring_container *rc)
  {
++<<<<<<< HEAD
 +	enum i40e_latency_range new_latency_range = rc->latency_range;
 +	u32 new_itr = rc->itr;
 +	int bytes_per_usec;
 +	unsigned int usecs, estimated_usecs;
 +
 +	if (rc->total_packets == 0 || !rc->itr)
 +		return false;
 +
 +	usecs = (rc->itr << 1) * ITR_COUNTDOWN_START;
 +	bytes_per_usec = rc->total_bytes / usecs;
 +
 +	/* The calculations in this algorithm depend on interrupts actually
 +	 * firing at the ITR rate. This may not happen if the packet rate is
 +	 * really low, or if we've been napi polling. Check to make sure
 +	 * that's not the case before we continue.
++=======
+ 	unsigned int avg_wire_size, packets, bytes, itr;
+ 	unsigned long next_update = jiffies;
+ 
+ 	/* If we don't have any rings just leave ourselves set for maximum
+ 	 * possible latency so we take ourselves out of the equation.
+ 	 */
+ 	if (!rc->ring || !ITR_IS_DYNAMIC(rc->ring->itr_setting))
+ 		return;
+ 
+ 	/* For Rx we want to push the delay up and default to low latency.
+ 	 * for Tx we want to pull the delay down and default to high latency.
++>>>>>>> a0073a4b8b59 (i40e/i40evf: Add support for new mechanism of updating adaptive ITR)
  	 */
- 	estimated_usecs = jiffies_to_usecs(jiffies - rc->last_itr_update);
- 	if (estimated_usecs > usecs) {
- 		new_latency_range = I40E_LOW_LATENCY;
- 		goto reset_latency;
+ 	itr = i40e_container_is_rx(q_vector, rc) ?
+ 	      I40E_ITR_ADAPTIVE_MIN_USECS | I40E_ITR_ADAPTIVE_LATENCY :
+ 	      I40E_ITR_ADAPTIVE_MAX_USECS | I40E_ITR_ADAPTIVE_LATENCY;
+ 
+ 	/* If we didn't update within up to 1 - 2 jiffies we can assume
+ 	 * that either packets are coming in so slow there hasn't been
+ 	 * any work, or that there is so much work that NAPI is dealing
+ 	 * with interrupt moderation and we don't need to do anything.
+ 	 */
+ 	if (time_after(next_update, rc->next_update))
+ 		goto clear_counts;
+ 
+ 	/* If itr_countdown is set it means we programmed an ITR within
+ 	 * the last 4 interrupt cycles. This has a side effect of us
+ 	 * potentially firing an early interrupt. In order to work around
+ 	 * this we need to throw out any data received for a few
+ 	 * interrupts following the update.
+ 	 */
+ 	if (q_vector->itr_countdown) {
+ 		itr = rc->target_itr;
+ 		goto clear_counts;
+ 	}
+ 
+ 	packets = rc->total_packets;
+ 	bytes = rc->total_bytes;
+ 
+ 	if (i40e_container_is_rx(q_vector, rc)) {
+ 		/* If Rx there are 1 to 4 packets and bytes are less than
+ 		 * 9000 assume insufficient data to use bulk rate limiting
+ 		 * approach unless Tx is already in bulk rate limiting. We
+ 		 * are likely latency driven.
+ 		 */
+ 		if (packets && packets < 4 && bytes < 9000 &&
+ 		    (q_vector->tx.target_itr & I40E_ITR_ADAPTIVE_LATENCY)) {
+ 			itr = I40E_ITR_ADAPTIVE_LATENCY;
+ 			goto adjust_by_size;
+ 		}
+ 	} else if (packets < 4) {
+ 		/* If we have Tx and Rx ITR maxed and Tx ITR is running in
+ 		 * bulk mode and we are receiving 4 or fewer packets just
+ 		 * reset the ITR_ADAPTIVE_LATENCY bit for latency mode so
+ 		 * that the Rx can relax.
+ 		 */
+ 		if (rc->target_itr == I40E_ITR_ADAPTIVE_MAX_USECS &&
+ 		    (q_vector->rx.target_itr & I40E_ITR_MASK) ==
+ 		     I40E_ITR_ADAPTIVE_MAX_USECS)
+ 			goto clear_counts;
+ 	} else if (packets > 32) {
+ 		/* If we have processed over 32 packets in a single interrupt
+ 		 * for Tx assume we need to switch over to "bulk" mode.
+ 		 */
+ 		rc->target_itr &= ~I40E_ITR_ADAPTIVE_LATENCY;
  	}
  
- 	/* simple throttlerate management
- 	 *   0-10MB/s   lowest (50000 ints/s)
- 	 *  10-20MB/s   low    (20000 ints/s)
- 	 *  20-1249MB/s bulk   (18000 ints/s)
+ 	/* We have no packets to actually measure against. This means
+ 	 * either one of the other queues on this vector is active or
+ 	 * we are a Tx queue doing TSO with too high of an interrupt rate.
  	 *
- 	 * The math works out because the divisor is in 10^(-6) which
- 	 * turns the bytes/us input value into MB/s values, but
- 	 * make sure to use usecs, as the register values written
- 	 * are in 2 usec increments in the ITR registers, and make sure
- 	 * to use the smoothed values that the countdown timer gives us.
+ 	 * Between 4 and 56 we can assume that our current interrupt delay
+ 	 * is only slightly too low. As such we should increase it by a small
+ 	 * fixed amount.
  	 */
- 	switch (new_latency_range) {
- 	case I40E_LOWEST_LATENCY:
- 		if (bytes_per_usec > 10)
- 			new_latency_range = I40E_LOW_LATENCY;
- 		break;
- 	case I40E_LOW_LATENCY:
- 		if (bytes_per_usec > 20)
- 			new_latency_range = I40E_BULK_LATENCY;
- 		else if (bytes_per_usec <= 10)
- 			new_latency_range = I40E_LOWEST_LATENCY;
- 		break;
- 	case I40E_BULK_LATENCY:
- 	default:
- 		if (bytes_per_usec <= 20)
- 			new_latency_range = I40E_LOW_LATENCY;
- 		break;
+ 	if (packets < 56) {
+ 		itr = rc->target_itr + I40E_ITR_ADAPTIVE_MIN_INC;
+ 		if ((itr & I40E_ITR_MASK) > I40E_ITR_ADAPTIVE_MAX_USECS) {
+ 			itr &= I40E_ITR_ADAPTIVE_LATENCY;
+ 			itr += I40E_ITR_ADAPTIVE_MAX_USECS;
+ 		}
+ 		goto clear_counts;
  	}
  
- reset_latency:
- 	rc->latency_range = new_latency_range;
+ 	if (packets <= 256) {
+ 		itr = min(q_vector->tx.current_itr, q_vector->rx.current_itr);
+ 		itr &= I40E_ITR_MASK;
  
++<<<<<<< HEAD
 +	switch (new_latency_range) {
 +	case I40E_LOWEST_LATENCY:
 +		new_itr = I40E_ITR_50K;
 +		break;
 +	case I40E_LOW_LATENCY:
 +		new_itr = I40E_ITR_20K;
 +		break;
 +	case I40E_BULK_LATENCY:
 +		new_itr = I40E_ITR_18K;
 +		break;
 +	default:
 +		break;
++=======
+ 		/* Between 56 and 112 is our "goldilocks" zone where we are
+ 		 * working out "just right". Just report that our current
+ 		 * ITR is good for us.
+ 		 */
+ 		if (packets <= 112)
+ 			goto clear_counts;
+ 
+ 		/* If packet count is 128 or greater we are likely looking
+ 		 * at a slight overrun of the delay we want. Try halving
+ 		 * our delay to see if that will cut the number of packets
+ 		 * in half per interrupt.
+ 		 */
+ 		itr /= 2;
+ 		itr &= I40E_ITR_MASK;
+ 		if (itr < I40E_ITR_ADAPTIVE_MIN_USECS)
+ 			itr = I40E_ITR_ADAPTIVE_MIN_USECS;
+ 
+ 		goto clear_counts;
++>>>>>>> a0073a4b8b59 (i40e/i40evf: Add support for new mechanism of updating adaptive ITR)
  	}
  
+ 	/* The paths below assume we are dealing with a bulk ITR since
+ 	 * number of packets is greater than 256. We are just going to have
+ 	 * to compute a value and try to bring the count under control,
+ 	 * though for smaller packet sizes there isn't much we can do as
+ 	 * NAPI polling will likely be kicking in sooner rather than later.
+ 	 */
+ 	itr = I40E_ITR_ADAPTIVE_BULK;
+ 
+ adjust_by_size:
+ 	/* If packet counts are 256 or greater we can assume we have a gross
+ 	 * overestimation of what the rate should be. Instead of trying to fine
+ 	 * tune it just use the formula below to try and dial in an exact value
+ 	 * give the current packet size of the frame.
+ 	 */
+ 	avg_wire_size = bytes / packets;
+ 
+ 	/* The following is a crude approximation of:
+ 	 *  wmem_default / (size + overhead) = desired_pkts_per_int
+ 	 *  rate / bits_per_byte / (size + ethernet overhead) = pkt_rate
+ 	 *  (desired_pkt_rate / pkt_rate) * usecs_per_sec = ITR value
+ 	 *
+ 	 * Assuming wmem_default is 212992 and overhead is 640 bytes per
+ 	 * packet, (256 skb, 64 headroom, 320 shared info), we can reduce the
+ 	 * formula down to
+ 	 *
+ 	 *  (170 * (size + 24)) / (size + 640) = ITR
+ 	 *
+ 	 * We first do some math on the packet size and then finally bitshift
+ 	 * by 8 after rounding up. We also have to account for PCIe link speed
+ 	 * difference as ITR scales based on this.
+ 	 */
+ 	if (avg_wire_size <= 60) {
+ 		/* Start at 250k ints/sec */
+ 		avg_wire_size = 4096;
+ 	} else if (avg_wire_size <= 380) {
+ 		/* 250K ints/sec to 60K ints/sec */
+ 		avg_wire_size *= 40;
+ 		avg_wire_size += 1696;
+ 	} else if (avg_wire_size <= 1084) {
+ 		/* 60K ints/sec to 36K ints/sec */
+ 		avg_wire_size *= 15;
+ 		avg_wire_size += 11452;
+ 	} else if (avg_wire_size <= 1980) {
+ 		/* 36K ints/sec to 30K ints/sec */
+ 		avg_wire_size *= 5;
+ 		avg_wire_size += 22420;
+ 	} else {
+ 		/* plateau at a limit of 30K ints/sec */
+ 		avg_wire_size = 32256;
+ 	}
+ 
+ 	/* If we are in low latency mode halve our delay which doubles the
+ 	 * rate to somewhere between 100K to 16K ints/sec
+ 	 */
+ 	if (itr & I40E_ITR_ADAPTIVE_LATENCY)
+ 		avg_wire_size /= 2;
+ 
+ 	/* Resultant value is 256 times larger than it needs to be. This
+ 	 * gives us room to adjust the value as needed to either increase
+ 	 * or decrease the value based on link speeds of 10G, 2.5G, 1G, etc.
+ 	 *
+ 	 * Use addition as we have already recorded the new latency flag
+ 	 * for the ITR value.
+ 	 */
+ 	itr += DIV_ROUND_UP(avg_wire_size, i40e_itr_divisor(q_vector)) *
+ 	       I40E_ITR_ADAPTIVE_MIN_INC;
+ 
+ 	if ((itr & I40E_ITR_MASK) > I40E_ITR_ADAPTIVE_MAX_USECS) {
+ 		itr &= I40E_ITR_ADAPTIVE_LATENCY;
+ 		itr += I40E_ITR_ADAPTIVE_MAX_USECS;
+ 	}
+ 
+ clear_counts:
+ 	/* write back value */
+ 	rc->target_itr = itr;
+ 
+ 	/* next update should occur within next jiffy */
+ 	rc->next_update = next_update + 1;
+ 
  	rc->total_bytes = 0;
  	rc->total_packets = 0;
++<<<<<<< HEAD
 +	rc->last_itr_update = jiffies;
 +
 +	if (new_itr != rc->itr) {
 +		rc->itr = new_itr;
 +		return true;
 +	}
 +	return false;
++=======
++>>>>>>> a0073a4b8b59 (i40e/i40evf: Add support for new mechanism of updating adaptive ITR)
  }
  
  /**
@@@ -1490,20 -1629,16 +1675,29 @@@ static u32 i40e_buildreg_itr(const int 
  
  /* a small macro to shorten up some long lines */
  #define INTREG I40E_VFINT_DYN_CTLN1
 +static inline int get_rx_itr(struct i40e_vsi *vsi, int idx)
 +{
 +	struct i40evf_adapter *adapter = vsi->back;
 +
 +	return adapter->rx_rings[idx].rx_itr_setting;
 +}
 +
 +static inline int get_tx_itr(struct i40e_vsi *vsi, int idx)
 +{
 +	struct i40evf_adapter *adapter = vsi->back;
 +
 +	return adapter->tx_rings[idx].tx_itr_setting;
 +}
  
+ /* The act of updating the ITR will cause it to immediately trigger. In order
+  * to prevent this from throwing off adaptive update statistics we defer the
+  * update so that it can only happen so often. So after either Tx or Rx are
+  * updated we make the adaptive scheme wait until either the ITR completely
+  * expires via the next_update expiration or we have been through at least
+  * 3 interrupts.
+  */
+ #define ITR_COUNTDOWN_START 3
+ 
  /**
   * i40e_update_enable_itr - Update itr and re-enable MSIX interrupt
   * @vsi: the VSI we care about
@@@ -1514,70 -1649,51 +1708,118 @@@ static inline void i40e_update_enable_i
  					  struct i40e_q_vector *q_vector)
  {
  	struct i40e_hw *hw = &vsi->back->hw;
++<<<<<<< HEAD
 +	bool rx = false, tx = false;
 +	u32 rxval, txval;
 +	int idx = q_vector->v_idx;
 +	int rx_itr_setting, tx_itr_setting;
 +
 +	/* avoid dynamic calculation if in countdown mode OR if
 +	 * all dynamic is disabled
 +	 */
 +	rxval = txval = i40e_buildreg_itr(I40E_ITR_NONE, 0);
 +
 +	rx_itr_setting = get_rx_itr(vsi, idx);
 +	tx_itr_setting = get_tx_itr(vsi, idx);
 +
 +	if (q_vector->itr_countdown > 0 ||
 +	    (!ITR_IS_DYNAMIC(rx_itr_setting) &&
 +	     !ITR_IS_DYNAMIC(tx_itr_setting))) {
 +		goto enable_int;
 +	}
 +
 +	if (ITR_IS_DYNAMIC(rx_itr_setting)) {
 +		rx = i40e_set_new_dynamic_itr(&q_vector->rx);
 +		rxval = i40e_buildreg_itr(I40E_RX_ITR, q_vector->rx.itr);
 +	}
 +
 +	if (ITR_IS_DYNAMIC(tx_itr_setting)) {
 +		tx = i40e_set_new_dynamic_itr(&q_vector->tx);
 +		txval = i40e_buildreg_itr(I40E_TX_ITR, q_vector->tx.itr);
 +	}
 +
 +	if (rx || tx) {
 +		/* get the higher of the two ITR adjustments and
 +		 * use the same value for both ITR registers
 +		 * when in adaptive mode (Rx and/or Tx)
 +		 */
 +		u16 itr = max(q_vector->tx.itr, q_vector->rx.itr);
 +
 +		q_vector->tx.itr = q_vector->rx.itr = itr;
 +		txval = i40e_buildreg_itr(I40E_TX_ITR, itr);
 +		tx = true;
 +		rxval = i40e_buildreg_itr(I40E_RX_ITR, itr);
 +		rx = true;
 +	}
 +
 +	/* only need to enable the interrupt once, but need
 +	 * to possibly update both ITR values
 +	 */
 +	if (rx) {
 +		/* set the INTENA_MSK_MASK so that this first write
 +		 * won't actually enable the interrupt, instead just
 +		 * updating the ITR (it's bit 31 PF and VF)
 +		 */
 +		rxval |= BIT(31);
 +		/* don't check _DOWN because interrupt isn't being enabled */
 +		wr32(hw, INTREG(q_vector->reg_idx), rxval);
 +	}
 +
 +enable_int:
 +	if (!test_bit(__I40E_VSI_DOWN, vsi->state))
 +		wr32(hw, INTREG(q_vector->reg_idx), txval);
 +
 +	if (q_vector->itr_countdown)
 +		q_vector->itr_countdown--;
 +	else
 +		q_vector->itr_countdown = ITR_COUNTDOWN_START;
++=======
+ 	u32 intval;
+ 
+ 	/* These will do nothing if dynamic updates are not enabled */
+ 	i40e_update_itr(q_vector, &q_vector->tx);
+ 	i40e_update_itr(q_vector, &q_vector->rx);
+ 
+ 	/* This block of logic allows us to get away with only updating
+ 	 * one ITR value with each interrupt. The idea is to perform a
+ 	 * pseudo-lazy update with the following criteria.
+ 	 *
+ 	 * 1. Rx is given higher priority than Tx if both are in same state
+ 	 * 2. If we must reduce an ITR that is given highest priority.
+ 	 * 3. We then give priority to increasing ITR based on amount.
+ 	 */
+ 	if (q_vector->rx.target_itr < q_vector->rx.current_itr) {
+ 		/* Rx ITR needs to be reduced, this is highest priority */
+ 		intval = i40e_buildreg_itr(I40E_RX_ITR,
+ 					   q_vector->rx.target_itr);
+ 		q_vector->rx.current_itr = q_vector->rx.target_itr;
+ 		q_vector->itr_countdown = ITR_COUNTDOWN_START;
+ 	} else if ((q_vector->tx.target_itr < q_vector->tx.current_itr) ||
+ 		   ((q_vector->rx.target_itr - q_vector->rx.current_itr) <
+ 		    (q_vector->tx.target_itr - q_vector->tx.current_itr))) {
+ 		/* Tx ITR needs to be reduced, this is second priority
+ 		 * Tx ITR needs to be increased more than Rx, fourth priority
+ 		 */
+ 		intval = i40e_buildreg_itr(I40E_TX_ITR,
+ 					   q_vector->tx.target_itr);
+ 		q_vector->tx.current_itr = q_vector->tx.target_itr;
+ 		q_vector->itr_countdown = ITR_COUNTDOWN_START;
+ 	} else if (q_vector->rx.current_itr != q_vector->rx.target_itr) {
+ 		/* Rx ITR needs to be increased, third priority */
+ 		intval = i40e_buildreg_itr(I40E_RX_ITR,
+ 					   q_vector->rx.target_itr);
+ 		q_vector->rx.current_itr = q_vector->rx.target_itr;
+ 		q_vector->itr_countdown = ITR_COUNTDOWN_START;
+ 	} else {
+ 		/* No ITR update, lowest priority */
+ 		intval = i40e_buildreg_itr(I40E_ITR_NONE, 0);
+ 		if (q_vector->itr_countdown)
+ 			q_vector->itr_countdown--;
+ 	}
+ 
+ 	if (!test_bit(__I40E_VSI_DOWN, vsi->state))
+ 		wr32(hw, INTREG(q_vector->reg_idx), intval);
++>>>>>>> a0073a4b8b59 (i40e/i40evf: Add support for new mechanism of updating adaptive ITR)
  }
  
  /**
diff --cc drivers/net/ethernet/intel/i40evf/i40e_txrx.h
index 6278d2a2abeb,9129447d079b..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.h
@@@ -427,21 -428,21 +427,26 @@@ static inline void clear_ring_build_skb
  	ring->flags &= ~I40E_RXR_FLAGS_BUILD_SKB_ENABLED;
  }
  
- enum i40e_latency_range {
- 	I40E_LOWEST_LATENCY = 0,
- 	I40E_LOW_LATENCY = 1,
- 	I40E_BULK_LATENCY = 2,
- };
+ #define I40E_ITR_ADAPTIVE_MIN_INC	0x0002
+ #define I40E_ITR_ADAPTIVE_MIN_USECS	0x0002
+ #define I40E_ITR_ADAPTIVE_MAX_USECS	0x007e
+ #define I40E_ITR_ADAPTIVE_LATENCY	0x8000
+ #define I40E_ITR_ADAPTIVE_BULK		0x0000
+ #define ITR_IS_BULK(x) (!((x) & I40E_ITR_ADAPTIVE_LATENCY))
  
  struct i40e_ring_container {
- 	/* array of pointers to rings */
- 	struct i40e_ring *ring;
+ 	struct i40e_ring *ring;		/* pointer to linked list of ring(s) */
+ 	unsigned long next_update;	/* jiffies value of next update */
  	unsigned int total_bytes;	/* total bytes processed this int */
  	unsigned int total_packets;	/* total packets processed this int */
- 	unsigned long last_itr_update;	/* jiffies of last ITR update */
  	u16 count;
++<<<<<<< HEAD
 +	enum i40e_latency_range latency_range;
 +	u16 itr;
++=======
+ 	u16 target_itr;			/* target ITR setting for ring(s) */
+ 	u16 current_itr;		/* current ITR setting for ring(s) */
++>>>>>>> a0073a4b8b59 (i40e/i40evf: Add support for new mechanism of updating adaptive ITR)
  };
  
  /* iterator for handling rings in ring container */
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_main.c
index b473966a345a,6fd09926181a..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_main.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
@@@ -353,11 -353,12 +353,20 @@@ i40evf_map_vector_to_rxq(struct i40evf_
  	rx_ring->vsi = &adapter->vsi;
  	q_vector->rx.ring = rx_ring;
  	q_vector->rx.count++;
++<<<<<<< HEAD
 +	q_vector->rx.latency_range = I40E_LOW_LATENCY;
 +	q_vector->rx.itr = ITR_TO_REG(rx_ring->rx_itr_setting);
 +	q_vector->ring_mask |= BIT(r_idx);
 +	q_vector->itr_countdown = ITR_COUNTDOWN_START;
 +	wr32(hw, I40E_VFINT_ITRN1(I40E_RX_ITR, v_idx - 1), q_vector->rx.itr);
++=======
+ 	q_vector->rx.next_update = jiffies + 1;
+ 	q_vector->rx.target_itr = ITR_TO_REG(rx_ring->itr_setting);
+ 	q_vector->ring_mask |= BIT(r_idx);
+ 	wr32(hw, I40E_VFINT_ITRN1(I40E_RX_ITR, q_vector->reg_idx),
+ 	     q_vector->rx.current_itr);
+ 	q_vector->rx.current_itr = q_vector->rx.target_itr;
++>>>>>>> a0073a4b8b59 (i40e/i40evf: Add support for new mechanism of updating adaptive ITR)
  }
  
  /**
@@@ -378,11 -379,12 +387,16 @@@ i40evf_map_vector_to_txq(struct i40evf_
  	tx_ring->vsi = &adapter->vsi;
  	q_vector->tx.ring = tx_ring;
  	q_vector->tx.count++;
++<<<<<<< HEAD
 +	q_vector->tx.latency_range = I40E_LOW_LATENCY;
 +	q_vector->tx.itr = ITR_TO_REG(tx_ring->tx_itr_setting);
 +	q_vector->itr_countdown = ITR_COUNTDOWN_START;
++=======
+ 	q_vector->tx.next_update = jiffies + 1;
+ 	q_vector->tx.target_itr = ITR_TO_REG(tx_ring->itr_setting);
++>>>>>>> a0073a4b8b59 (i40e/i40evf: Add support for new mechanism of updating adaptive ITR)
  	q_vector->num_ringpairs++;
 -	wr32(hw, I40E_VFINT_ITRN1(I40E_TX_ITR, q_vector->reg_idx),
 -	     q_vector->tx.target_itr);
 -	q_vector->tx.current_itr = q_vector->tx.target_itr;
 +	wr32(hw, I40E_VFINT_ITRN1(I40E_TX_ITR, v_idx - 1), q_vector->tx.itr);
  }
  
  /**
diff --git a/drivers/net/ethernet/intel/i40e/i40e.h b/drivers/net/ethernet/intel/i40e/i40e.h
index c9c7f1b0e200..303ba405bf89 100644
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@ -823,6 +823,7 @@ struct i40e_q_vector {
 	struct i40e_ring_container rx;
 	struct i40e_ring_container tx;
 
+	u8 itr_countdown;	/* when 0 should adjust adaptive ITR */
 	u8 num_ringpairs;	/* total number of ring pairs in vector */
 
 	cpumask_t affinity_mask;
@@ -831,8 +832,6 @@ struct i40e_q_vector {
 	struct rcu_head rcu;	/* to avoid race with update stats on free */
 	char name[I40E_INT_NAME_STR_LEN];
 	bool arm_wb_state;
-#define ITR_COUNTDOWN_START 100
-	u8 itr_countdown;	/* when 0 should adjust ITR */
 } ____cacheline_internodealigned_in_smp;
 
 /* lan device */
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.c
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.h
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_txrx.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_txrx.h
diff --git a/drivers/net/ethernet/intel/i40evf/i40evf.h b/drivers/net/ethernet/intel/i40evf/i40evf.h
index 9690c1ea019e..b6991e8014d8 100644
--- a/drivers/net/ethernet/intel/i40evf/i40evf.h
+++ b/drivers/net/ethernet/intel/i40evf/i40evf.h
@@ -117,9 +117,8 @@ struct i40e_q_vector {
 	struct i40e_ring_container rx;
 	struct i40e_ring_container tx;
 	u32 ring_mask;
+	u8 itr_countdown;	/* when 0 should adjust adaptive ITR */
 	u8 num_ringpairs;	/* total number of ring pairs in vector */
-#define ITR_COUNTDOWN_START 100
-	u8 itr_countdown;	/* when 0 or 1 update ITR */
 	u16 v_idx;		/* index in the vsi->q_vector array. */
 	u16 reg_idx;		/* register index of the interrupt */
 	char name[IFNAMSIZ + 15];
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_main.c
