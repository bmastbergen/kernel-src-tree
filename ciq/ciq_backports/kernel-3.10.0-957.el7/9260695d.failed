tcmu: fix multiple uio open/close sequences

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Mike Christie <mchristi@redhat.com>
commit 9260695d65590f4711d1166eadbfcb0acfa0625a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/9260695d.failed

If the uio device is open and closed multiple times, the
kref count will be off due to tcmu_release getting called
multiple times for each close. This patch integrates
Wenji Tang's patch to add a kref_get on open that now
matches the kref_put done on tcmu_release and adds
a kref_put in tcmu_destroy_device to match the kref_get
done in succesful tcmu_configure_device calls.

	Signed-off-by: Mike Christie <mchristi@redhat.com>
	Cc: Wenji Tang <tang.wenji@zte.com.cn>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 9260695d65590f4711d1166eadbfcb0acfa0625a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_user.c
diff --cc drivers/target/target_core_user.c
index 747d70975df5,1e69b1b32558..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -1053,6 -1268,9 +1053,12 @@@ static int tcmu_open(struct uio_info *i
  	if (test_and_set_bit(TCMU_DEV_BIT_OPEN, &udev->flags))
  		return -EBUSY;
  
++<<<<<<< HEAD
++=======
+ 	udev->inode = inode;
+ 	kref_get(&udev->kref);
+ 
++>>>>>>> 9260695d6559 (tcmu: fix multiple uio open/close sequences)
  	pr_debug("open\n");
  
  	return 0;
@@@ -1065,7 -1301,8 +1071,12 @@@ static int tcmu_release(struct uio_inf
  	clear_bit(TCMU_DEV_BIT_OPEN, &udev->flags);
  
  	pr_debug("close\n");
++<<<<<<< HEAD
 +
++=======
+ 	/* release ref from open */
+ 	kref_put(&udev->kref, tcmu_dev_kref_release);
++>>>>>>> 9260695d6559 (tcmu: fix multiple uio open/close sequences)
  	return 0;
  }
  
@@@ -1345,7 -1591,15 +1356,19 @@@ static void tcmu_destroy_device(struct 
  	idr_destroy(&udev->commands);
  	spin_unlock_irq(&udev->commands_lock);
  	WARN_ON(!all_expired);
++<<<<<<< HEAD
 +	kfree(udev->data_bitmap);
++=======
+ 
+ 	tcmu_blocks_release(udev);
+ 
+ 	tcmu_netlink_event(udev, TCMU_CMD_REMOVED_DEVICE, 0, NULL);
+ 
+ 	uio_unregister_device(&udev->uio_info);
+ 
+ 	/* release ref from configure */
+ 	kref_put(&udev->kref, tcmu_dev_kref_release);
++>>>>>>> 9260695d6559 (tcmu: fix multiple uio open/close sequences)
  }
  
  enum {
* Unmerged path drivers/target/target_core_user.c
