ipmi: Stop timers before cleaning up the module

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Masamitsu Yamazaki <m-yamazaki@ah.jp.nec.com>
commit 4f7f5551a760eb0124267be65763008169db7087
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/4f7f5551.failed

System may crash after unloading ipmi_si.ko module
because a timer may remain and fire after the module cleaned up resources.

cleanup_one_si() contains the following processing.

        /*
         * Make sure that interrupts, the timer and the thread are
         * stopped and will not run again.
         */
        if (to_clean->irq_cleanup)
                to_clean->irq_cleanup(to_clean);
        wait_for_timer_and_thread(to_clean);

        /*
         * Timeouts are stopped, now make sure the interrupts are off
         * in the BMC.  Note that timers and CPU interrupts are off,
         * so no need for locks.
         */
        while (to_clean->curr_msg || (to_clean->si_state != SI_NORMAL)) {
                poll(to_clean);
                schedule_timeout_uninterruptible(1);
        }

si_state changes as following in the while loop calling poll(to_clean).

  SI_GETTING_MESSAGES
    => SI_CHECKING_ENABLES
     => SI_SETTING_ENABLES
      => SI_GETTING_EVENTS
       => SI_NORMAL

As written in the code comments above,
timers are expected to stop before the polling loop and not to run again.
But the timer is set again in the following process
when si_state becomes SI_SETTING_ENABLES.

  => poll
     => smi_event_handler
       => handle_transaction_done
          // smi_info->si_state == SI_SETTING_ENABLES
         => start_getting_events
           => start_new_msg
            => smi_mod_timer
              => mod_timer

As a result, before the timer set in start_new_msg() expires,
the polling loop may see si_state becoming SI_NORMAL
and the module clean-up finishes.

For example, hard LOCKUP and panic occurred as following.
smi_timeout was called after smi_event_handler,
kcs_event and hangs at port_inb()
trying to access I/O port after release.

    [exception RIP: port_inb+19]
    RIP: ffffffffc0473053  RSP: ffff88069fdc3d80  RFLAGS: 00000006
    RAX: ffff8806800f8e00  RBX: ffff880682bd9400  RCX: 0000000000000000
    RDX: 0000000000000ca3  RSI: 0000000000000ca3  RDI: ffff8806800f8e40
    RBP: ffff88069fdc3d80   R8: ffffffff81d86dfc   R9: ffffffff81e36426
    R10: 00000000000509f0  R11: 0000000000100000  R12: 0000000000]:000000
    R13: 0000000000000000  R14: 0000000000000246  R15: ffff8806800f8e00
    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0000
 --- <NMI exception stack> ---

To fix the problem I defined a flag, timer_can_start,
as member of struct smi_info.
The flag is enabled immediately after initializing the timer
and disabled immediately before waiting for timer deletion.

Fixes: 0cfec916e86d ("ipmi: Start the timer and thread on internal msgs")
	Signed-off-by: Yamazaki Masamitsu <m-yamazaki@ah.jp.nec.com>
[Adjusted for recent changes in the driver.]
	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit 4f7f5551a760eb0124267be65763008169db7087)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_si_intf.c
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 709742a62b66,99b0513bb55b..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -491,11 -434,11 +490,11 @@@ static void start_getting_events(struc
   * Note that we cannot just use disable_irq(), since the interrupt may
   * be shared.
   */
- static inline bool disable_si_irq(struct smi_info *smi_info, bool start_timer)
+ static inline bool disable_si_irq(struct smi_info *smi_info)
  {
 -	if ((smi_info->io.irq) && (!smi_info->interrupt_disabled)) {
 +	if ((smi_info->irq) && (!smi_info->interrupt_disabled)) {
  		smi_info->interrupt_disabled = true;
- 		start_check_enables(smi_info, start_timer);
+ 		start_check_enables(smi_info);
  		return true;
  	}
  	return false;
@@@ -503,9 -446,9 +502,9 @@@
  
  static inline bool enable_si_irq(struct smi_info *smi_info)
  {
 -	if ((smi_info->io.irq) && (smi_info->interrupt_disabled)) {
 +	if ((smi_info->irq) && (smi_info->interrupt_disabled)) {
  		smi_info->interrupt_disabled = false;
- 		start_check_enables(smi_info, true);
+ 		start_check_enables(smi_info);
  		return true;
  	}
  	return false;
@@@ -921,8 -864,8 +920,13 @@@ restart
  		 * asynchronously reset, and may thus get interrupts
  		 * disable and messages disabled.
  		 */
++<<<<<<< HEAD
 +		if (smi_info->supports_event_msg_buff || smi_info->irq) {
 +			start_check_enables(smi_info, true);
++=======
+ 		if (smi_info->supports_event_msg_buff || smi_info->io.irq) {
+ 			start_check_enables(smi_info);
++>>>>>>> 4f7f5551a760 (ipmi: Stop timers before cleaning up the module)
  		} else {
  			smi_info->curr_msg = alloc_msg_handle_irq(smi_info);
  			if (!smi_info->curr_msg)
@@@ -3667,8 -2235,12 +3674,8 @@@ static int try_smi_init(struct smi_inf
  
  	return 0;
  
 -out_err_remove_attrs:
 -	device_remove_group(new_smi->io.dev, &ipmi_si_dev_attr_group);
 -	dev_set_drvdata(new_smi->io.dev, NULL);
 -
  out_err_stop_timer:
- 	wait_for_timer_and_thread(new_smi);
+ 	stop_timer_and_thread(new_smi);
  
  out_err:
  	new_smi->interrupt_disabled = true;
@@@ -3869,9 -2388,9 +3876,15 @@@ static void cleanup_one_si(struct smi_i
  	 * Make sure that interrupts, the timer and the thread are
  	 * stopped and will not run again.
  	 */
++<<<<<<< HEAD
 +	if (to_clean->irq_cleanup)
 +		to_clean->irq_cleanup(to_clean);
 +	wait_for_timer_and_thread(to_clean);
++=======
+ 	if (to_clean->io.irq_cleanup)
+ 		to_clean->io.irq_cleanup(&to_clean->io);
+ 	stop_timer_and_thread(to_clean);
++>>>>>>> 4f7f5551a760 (ipmi: Stop timers before cleaning up the module)
  
  	/*
  	 * Timeouts are stopped, now make sure the interrupts are off
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
