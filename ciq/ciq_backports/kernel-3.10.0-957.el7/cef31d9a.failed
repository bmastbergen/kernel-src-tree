posix-timer: Properly check sigevent->sigev_notify

jira LE-1907
cve CVE-2017-18344
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit cef31d9af908243421258f1df35a4a644604efbe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/cef31d9a.failed

timer_create() specifies via sigevent->sigev_notify the signal delivery for
the new timer. The valid modes are SIGEV_NONE, SIGEV_SIGNAL, SIGEV_THREAD
and (SIGEV_SIGNAL | SIGEV_THREAD_ID).

The sanity check in good_sigevent() is only checking the valid combination
for the SIGEV_THREAD_ID bit, i.e. SIGEV_SIGNAL, but if SIGEV_THREAD_ID is
not set it accepts any random value.

This has no real effects on the posix timer and signal delivery code, but
it affects show_timer() which handles the output of /proc/$PID/timers. That
function uses a string array to pretty print sigev_notify. The access to
that array has no bound checks, so random sigev_notify cause access beyond
the array bounds.

Add proper checks for the valid notify modes and remove the SIGEV_THREAD_ID
masking from various code pathes as SIGEV_NONE can never be set in
combination with SIGEV_THREAD_ID.

	Reported-by: Eric Biggers <ebiggers3@gmail.com>
	Reported-by: Dmitry Vyukov <dvyukov@google.com>
	Reported-by: Alexey Dobriyan <adobriyan@gmail.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: John Stultz <john.stultz@linaro.org>
	Cc: stable@vger.kernel.org
(cherry picked from commit cef31d9af908243421258f1df35a4a644604efbe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/posix-timers.c
diff --cc kernel/posix-timers.c
index 5a4d6a493c9b,ec999f32c840..000000000000
--- a/kernel/posix-timers.c
+++ b/kernel/posix-timers.c
@@@ -500,43 -434,24 +500,48 @@@ static struct pid *good_sigevent(sigeve
  {
  	struct task_struct *rtn = current->group_leader;
  
- 	if ((event->sigev_notify & SIGEV_THREAD_ID ) &&
- 		(!(rtn = find_task_by_vpid(event->sigev_notify_thread_id)) ||
- 		 !same_thread_group(rtn, current) ||
- 		 (event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_SIGNAL))
+ 	switch (event->sigev_notify) {
+ 	case SIGEV_SIGNAL | SIGEV_THREAD_ID:
+ 		rtn = find_task_by_vpid(event->sigev_notify_thread_id);
+ 		if (!rtn || !same_thread_group(rtn, current))
+ 			return NULL;
+ 		/* FALLTHRU */
+ 	case SIGEV_SIGNAL:
+ 	case SIGEV_THREAD:
+ 		if (event->sigev_signo <= 0 || event->sigev_signo > SIGRTMAX)
+ 			return NULL;
+ 		/* FALLTHRU */
+ 	case SIGEV_NONE:
+ 		return task_pid(rtn);
+ 	default:
  		return NULL;
- 
- 	if (((event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_NONE) &&
- 	    ((event->sigev_signo <= 0) || (event->sigev_signo > SIGRTMAX)))
- 		return NULL;
- 
- 	return task_pid(rtn);
+ 	}
  }
  
 +void posix_timers_register_clock(const clockid_t clock_id,
 +				 struct k_clock *new_clock)
 +{
 +	if ((unsigned) clock_id >= MAX_CLOCKS) {
 +		printk(KERN_WARNING "POSIX clock register failed for clock_id %d\n",
 +		       clock_id);
 +		return;
 +	}
 +
 +	if (!new_clock->clock_get) {
 +		printk(KERN_WARNING "POSIX clock id %d lacks clock_get()\n",
 +		       clock_id);
 +		return;
 +	}
 +	if (!new_clock->clock_getres) {
 +		printk(KERN_WARNING "POSIX clock id %d lacks clock_getres()\n",
 +		       clock_id);
 +		return;
 +	}
 +
 +	posix_clocks[clock_id] = *new_clock;
 +}
 +EXPORT_SYMBOL_GPL(posix_timers_register_clock);
 +
  static struct k_itimer * alloc_posix_timer(void)
  {
  	struct k_itimer *tmr;
@@@ -724,37 -667,45 +729,42 @@@ static struct k_itimer *__lock_timer(ti
   * it is the same as a requeue pending timer WRT to what we should
   * report.
   */
 -void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)
 +static void
 +common_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
  {
 -	const struct k_clock *kc = timr->kclock;
  	ktime_t now, remaining, iv;
 -	struct timespec64 ts64;
 -	bool sig_none;
 +	struct hrtimer *timer = &timr->it.real.timer;
 +
++<<<<<<< HEAD:kernel/posix-timers.c
 +	memset(cur_setting, 0, sizeof(struct itimerspec));
  
 +	iv = timr->it.real.interval;
++=======
+ 	sig_none = timr->it_sigev_notify == SIGEV_NONE;
+ 	iv = timr->it_interval;
++>>>>>>> cef31d9af908 (posix-timer: Properly check sigevent->sigev_notify):kernel/time/posix-timers.c
  
  	/* interval timer ? */
 -	if (iv) {
 -		cur_setting->it_interval = ktime_to_timespec64(iv);
 -	} else if (!timr->it_active) {
 -		/*
 -		 * SIGEV_NONE oneshot timers are never queued. Check them
 -		 * below.
 -		 */
 -		if (!sig_none)
 -			return;
 -	}
 +	if (iv.tv64)
 +		cur_setting->it_interval = ktime_to_timespec(iv);
 +	else if (!hrtimer_active(timer) &&
 +		 (timr->it_sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_NONE)
 +		return;
  
 -	/*
 -	 * The timespec64 based conversion is suboptimal, but it's not
 -	 * worth to implement yet another callback.
 -	 */
 -	kc->clock_get(timr->it_clock, &ts64);
 -	now = timespec64_to_ktime(ts64);
 +	now = timer->base->get_time();
  
  	/*
 -	 * When a requeue is pending or this is a SIGEV_NONE timer move the
 -	 * expiry time forward by intervals, so expiry is > now.
 +	 * When a requeue is pending or this is a SIGEV_NONE
 +	 * timer move the expiry time forward by intervals, so
 +	 * expiry is > now.
  	 */
 -	if (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))
 -		timr->it_overrun += kc->timer_forward(timr, now);
 +	if (iv.tv64 && (timr->it_requeue_pending & REQUEUE_PENDING ||
 +	    (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE))
 +		timr->it_overrun += (unsigned int) hrtimer_forward(timer, now, iv);
  
 -	remaining = kc->timer_remaining(timr, now);
 +	remaining = ktime_sub(hrtimer_get_expires(timer), now);
  	/* Return 0 only, when the timer is expired and not pending */
 -	if (remaining <= 0) {
 +	if (remaining.tv64 <= 0) {
  		/*
  		 * A single shot SIGEV_NONE timer must return 0, when
  		 * it is expired !
@@@ -847,25 -859,12 +857,31 @@@ common_timer_set(struct k_itimer *timr
  	if (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)
  		return 0;
  
++<<<<<<< HEAD:kernel/posix-timers.c
 +	mode = flags & TIMER_ABSTIME ? HRTIMER_MODE_ABS : HRTIMER_MODE_REL;
 +	hrtimer_init(&timr->it.real.timer, timr->it_clock, mode);
 +	timr->it.real.timer.function = posix_timer_fn;
++=======
+ 	timr->it_interval = timespec64_to_ktime(new_setting->it_interval);
+ 	expires = timespec64_to_ktime(new_setting->it_value);
+ 	sigev_none = timr->it_sigev_notify == SIGEV_NONE;
++>>>>>>> cef31d9af908 (posix-timer: Properly check sigevent->sigev_notify):kernel/time/posix-timers.c
 +
 +	hrtimer_set_expires(timer, timespec_to_ktime(new_setting->it_value));
 +
 +	/* Convert interval */
 +	timr->it.real.interval = timespec_to_ktime(new_setting->it_interval);
 +
 +	/* SIGEV_NONE timers are not queued ! See common_timer_get */
 +	if (((timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE)) {
 +		/* Setup correct expiry time for relative timers */
 +		if (mode == HRTIMER_MODE_REL) {
 +			hrtimer_add_expires(timer, timer->base->get_time());
 +		}
 +		return 0;
 +	}
  
 -	kc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);
 -	timr->it_active = !sigev_none;
 +	hrtimer_start_expires(timer, mode);
  	return 0;
  }
  
* Unmerged path kernel/posix-timers.c
