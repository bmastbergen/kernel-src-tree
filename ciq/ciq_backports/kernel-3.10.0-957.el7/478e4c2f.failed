net: mroute: Check if rule is a default rule

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [net] mroute: Check if rule is a default rule (Ivan Vecera) [1584232]
Rebuild_FUZZ: 93.98%
commit-author Yotam Gigi <yotamg@mellanox.com>
commit 478e4c2f0067d57d7c17059caafab026ca32084a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/478e4c2f.failed

When the ipmr starts, it adds one default FIB rule that matches all packets
and sends them to the DEFAULT (multicast) FIB table. A more complex rule
can be added by user to specify that for a specific interface, a packet
should be look up at either an arbitrary table or according to the l3mdev
of the interface.

For drivers willing to offload the ipmr logic into a hardware but don't
want to offload all the FIB rules functionality, provide a function that
can indicate whether the FIB rule is the default multicast rule, thus only
one routing table is needed.

This way, a driver can register to the FIB notification chain, get
notifications about FIB rules added and trigger some kind of an internal
abort mechanism when a non default rule is added by the user.

	Signed-off-by: Yotam Gigi <yotamg@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 478e4c2f0067d57d7c17059caafab026ca32084a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mroute.h
#	net/ipv4/ipmr.c
diff --cc include/linux/mroute.h
index 041f79f8571c,b072a84fbe1c..000000000000
--- a/include/linux/mroute.h
+++ b/include/linux/mroute.h
@@@ -3,7 -3,10 +3,12 @@@
  
  #include <linux/in.h>
  #include <linux/pim.h>
 -#include <linux/rhashtable.h>
  #include <net/sock.h>
++<<<<<<< HEAD
++=======
+ #include <net/fib_rules.h>
+ #include <net/fib_notifier.h>
++>>>>>>> 478e4c2f0067 (net: mroute: Check if rule is a default rule)
  #include <uapi/linux/mroute.h>
  
  #ifdef CONFIG_IP_MROUTE
diff --cc net/ipv4/ipmr.c
index 1dc6a27cc66c,292a8e80bdfa..000000000000
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@@ -279,9 -261,25 +279,15 @@@ static void __net_exit ipmr_rules_exit(
  		list_del(&mrt->list);
  		ipmr_free_table(mrt);
  	}
 -	fib_rules_unregister(net->ipv4.mr_rules_ops);
  	rtnl_unlock();
 -}
 -
 -static int ipmr_rules_dump(struct net *net, struct notifier_block *nb)
 -{
 -	return fib_rules_dump(net, nb, RTNL_FAMILY_IPMR);
 -}
 -
 -static unsigned int ipmr_rules_seq_read(struct net *net)
 -{
 -	return fib_rules_seq_read(net, RTNL_FAMILY_IPMR);
 +	fib_rules_unregister(net->ipv4.mr_rules_ops);
  }
+ 
+ bool ipmr_rule_default(const struct fib_rule *rule)
+ {
+ 	return fib_rule_matchall(rule) && rule->table == RT_TABLE_DEFAULT;
+ }
+ EXPORT_SYMBOL(ipmr_rule_default);
  #else
  #define ipmr_for_each_table(mrt, net) \
  	for (mrt = net->ipv4.mrt; mrt; mrt = NULL)
@@@ -311,8 -314,44 +317,27 @@@ static void __net_exit ipmr_rules_exit(
  	net->ipv4.mrt = NULL;
  	rtnl_unlock();
  }
++<<<<<<< HEAD
++=======
+ 
+ static int ipmr_rules_dump(struct net *net, struct notifier_block *nb)
+ {
+ 	return 0;
+ }
+ 
+ static unsigned int ipmr_rules_seq_read(struct net *net)
+ {
+ 	return 0;
+ }
+ 
+ bool ipmr_rule_default(const struct fib_rule *rule)
+ {
+ 	return true;
+ }
+ EXPORT_SYMBOL(ipmr_rule_default);
++>>>>>>> 478e4c2f0067 (net: mroute: Check if rule is a default rule)
  #endif
  
 -static inline int ipmr_hash_cmp(struct rhashtable_compare_arg *arg,
 -				const void *ptr)
 -{
 -	const struct mfc_cache_cmp_arg *cmparg = arg->key;
 -	struct mfc_cache *c = (struct mfc_cache *)ptr;
 -
 -	return cmparg->mfc_mcastgrp != c->mfc_mcastgrp ||
 -	       cmparg->mfc_origin != c->mfc_origin;
 -}
 -
 -static const struct rhashtable_params ipmr_rht_params = {
 -	.head_offset = offsetof(struct mfc_cache, mnode),
 -	.key_offset = offsetof(struct mfc_cache, cmparg),
 -	.key_len = sizeof(struct mfc_cache_cmp_arg),
 -	.nelem_hint = 3,
 -	.locks_mul = 1,
 -	.obj_cmpfn = ipmr_hash_cmp,
 -	.automatic_shrinking = true,
 -};
 -
  static struct mr_table *ipmr_new_table(struct net *net, u32 id)
  {
  	struct mr_table *mrt;
* Unmerged path include/linux/mroute.h
* Unmerged path net/ipv4/ipmr.c
