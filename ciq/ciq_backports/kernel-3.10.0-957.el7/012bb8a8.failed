nfp: bpf: drop support for cls_bpf with legacy actions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 012bb8a8b5a2688590f829884acc83697d68a96d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/012bb8a8.failed

Only support BPF_PROG_TYPE_SCHED_CLS programs in direct
action mode.  This simplifies preparing the offload since
there will now be only one mode of operation for that type
of program.  We need to know the attachment mode type of
cls_bpf programs, because exit codes are interpreted
differently for legacy vs DA mode.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 012bb8a8b5a2688590f829884acc83697d68a96d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/bpf/jit.c
#	drivers/net/ethernet/netronome/nfp/bpf/main.c
#	drivers/net/ethernet/netronome/nfp/bpf/main.h
#	drivers/net/ethernet/netronome/nfp/bpf/offload.c
#	drivers/net/ethernet/netronome/nfp/bpf/verifier.c
diff --cc drivers/net/ethernet/netronome/nfp/bpf/jit.c
index a86508b776ac,e1907a1d269e..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/jit.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/jit.c
@@@ -197,49 -202,10 +197,52 @@@ emit_br(struct nfp_prog *nfp_prog, enu
  }
  
  static void
++<<<<<<< HEAD
 +__emit_br_byte(struct nfp_prog *nfp_prog, u8 areg, u8 breg, bool imm8,
 +	       u8 byte, bool equal, u16 addr, u8 defer)
 +{
 +	u16 addr_lo, addr_hi;
 +	u64 insn;
 +
 +	addr_lo = addr & (OP_BB_ADDR_LO >> __bf_shf(OP_BB_ADDR_LO));
 +	addr_hi = addr != addr_lo;
 +
 +	insn = OP_BBYTE_BASE |
 +		FIELD_PREP(OP_BB_A_SRC, areg) |
 +		FIELD_PREP(OP_BB_BYTE, byte) |
 +		FIELD_PREP(OP_BB_B_SRC, breg) |
 +		FIELD_PREP(OP_BB_I8, imm8) |
 +		FIELD_PREP(OP_BB_EQ, equal) |
 +		FIELD_PREP(OP_BB_DEFBR, defer) |
 +		FIELD_PREP(OP_BB_ADDR_LO, addr_lo) |
 +		FIELD_PREP(OP_BB_ADDR_HI, addr_hi);
 +
 +	nfp_prog_push(nfp_prog, insn);
 +}
 +
 +static void
 +emit_br_byte_neq(struct nfp_prog *nfp_prog,
 +		 swreg dst, u8 imm, u8 byte, u16 addr, u8 defer)
 +{
 +	struct nfp_insn_re_regs reg;
 +	int err;
 +
 +	err = swreg_to_restricted(reg_none(), dst, reg_imm(imm), &reg, true);
 +	if (err) {
 +		nfp_prog->error = err;
 +		return;
 +	}
 +
 +	__emit_br_byte(nfp_prog, reg.areg, reg.breg, reg.i8, byte, false, addr,
 +		       defer);
 +}
 +
 +static void
++=======
++>>>>>>> 012bb8a8b5a2 (nfp: bpf: drop support for cls_bpf with legacy actions)
  __emit_immed(struct nfp_prog *nfp_prog, u16 areg, u16 breg, u16 imm_hi,
  	     enum immed_width width, bool invert,
 -	     enum immed_shift shift, bool wr_both,
 -	     bool dst_lmextn, bool src_lmextn)
 +	     enum immed_shift shift, bool wr_both)
  {
  	u64 insn;
  
diff --cc drivers/net/ethernet/netronome/nfp/bpf/main.c
index 4ca14182b178,2ff97f12c160..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/main.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/main.c
@@@ -85,35 -85,66 +85,94 @@@ static const char *nfp_bpf_extra_cap(st
  	return nfp_net_ebpf_capable(nn) ? "BPF" : "";
  }
  
++<<<<<<< HEAD
 +static int
 +nfp_bpf_vnic_alloc(struct nfp_app *app, struct nfp_net *nn, unsigned int id)
 +{
 +	struct nfp_net_bpf_priv *priv;
 +	int ret;
 +
 +	priv = kmalloc(sizeof(*priv), GFP_KERNEL);
 +	if (!priv)
 +		return -ENOMEM;
 +
 +	nn->app_priv = priv;
 +	spin_lock_init(&priv->rx_filter_lock);
 +	setup_timer(&priv->rx_filter_stats_timer,
 +		    nfp_net_filter_stats_timer, (unsigned long)nn);
 +
 +	ret = nfp_app_nic_vnic_alloc(app, nn, id);
 +	if (ret)
 +		kfree(priv);
 +
 +	return ret;
 +}
 +
++=======
++>>>>>>> 012bb8a8b5a2 (nfp: bpf: drop support for cls_bpf with legacy actions)
  static void nfp_bpf_vnic_free(struct nfp_app *app, struct nfp_net *nn)
  {
  	if (nn->dp.bpf_offload_xdp)
  		nfp_bpf_xdp_offload(app, nn, NULL);
- 	kfree(nn->app_priv);
  }
  
++<<<<<<< HEAD
++=======
+ static int nfp_bpf_setup_tc_block_cb(enum tc_setup_type type,
+ 				     void *type_data, void *cb_priv)
+ {
+ 	struct tc_cls_bpf_offload *cls_bpf = type_data;
+ 	struct nfp_net *nn = cb_priv;
+ 
+ 	if (!tc_can_offload(nn->dp.netdev))
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (type) {
+ 	case TC_SETUP_CLSBPF:
+ 		if (!nfp_net_ebpf_capable(nn) ||
+ 		    cls_bpf->common.protocol != htons(ETH_P_ALL) ||
+ 		    cls_bpf->common.chain_index)
+ 			return -EOPNOTSUPP;
+ 		if (nn->dp.bpf_offload_xdp)
+ 			return -EBUSY;
+ 
+ 		/* Only support TC direct action */
+ 		if (!cls_bpf->exts_integrated ||
+ 		    tcf_exts_has_actions(cls_bpf->exts)) {
+ 			nn_err(nn, "only direct action with no legacy actions supported\n");
+ 			return -EOPNOTSUPP;
+ 		}
+ 
+ 		return nfp_net_bpf_offload(nn, cls_bpf);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int nfp_bpf_setup_tc_block(struct net_device *netdev,
+ 				  struct tc_block_offload *f)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 
+ 	if (f->binder_type != TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (f->command) {
+ 	case TC_BLOCK_BIND:
+ 		return tcf_block_cb_register(f->block,
+ 					     nfp_bpf_setup_tc_block_cb,
+ 					     nn, nn);
+ 	case TC_BLOCK_UNBIND:
+ 		tcf_block_cb_unregister(f->block,
+ 					nfp_bpf_setup_tc_block_cb,
+ 					nn);
+ 		return 0;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
++>>>>>>> 012bb8a8b5a2 (nfp: bpf: drop support for cls_bpf with legacy actions)
  static int nfp_bpf_setup_tc(struct nfp_app *app, struct net_device *netdev,
  			    enum tc_setup_type type, void *type_data)
  {
diff --cc drivers/net/ethernet/netronome/nfp/bpf/main.h
index ebcbc0ba3a0c,c5280de2ab14..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/main.h
+++ b/drivers/net/ethernet/netronome/nfp/bpf/main.h
@@@ -197,22 -190,6 +190,26 @@@ int nfp_prog_verify(struct nfp_prog *nf
  struct nfp_net;
  struct tc_cls_bpf_offload;
  
++<<<<<<< HEAD
 +/**
 + * struct nfp_net_bpf_priv - per-vNIC BPF private data
 + * @rx_filter:		Filter offload statistics - dropped packets/bytes
 + * @rx_filter_prev:	Filter offload statistics - values from previous update
 + * @rx_filter_change:	Jiffies when statistics last changed
 + * @rx_filter_stats_timer:  Timer for polling filter offload statistics
 + * @rx_filter_lock:	Lock protecting timer state changes (teardown)
 + */
 +struct nfp_net_bpf_priv {
 +	struct nfp_stat_pair rx_filter, rx_filter_prev;
 +	unsigned long rx_filter_change;
 +	struct timer_list rx_filter_stats_timer;
 +	spinlock_t rx_filter_lock;
 +};
 +
 +int nfp_net_bpf_offload(struct nfp_net *nn, struct tc_cls_bpf_offload *cls_bpf);
 +void nfp_net_filter_stats_timer(unsigned long data);
++=======
+ int nfp_net_bpf_offload(struct nfp_net *nn, struct tc_cls_bpf_offload *cls_bpf);
++>>>>>>> 012bb8a8b5a2 (nfp: bpf: drop support for cls_bpf with legacy actions)
  
  #endif
diff --cc drivers/net/ethernet/netronome/nfp/bpf/offload.c
index de79faf0874b,b9b5d675c4d3..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/offload.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/offload.c
@@@ -51,101 -51,6 +51,104 @@@
  #include "../nfp_net_ctrl.h"
  #include "../nfp_net.h"
  
++<<<<<<< HEAD
 +void nfp_net_filter_stats_timer(unsigned long data)
 +{
 +	struct nfp_net *nn = (void *)data;
 +	struct nfp_net_bpf_priv *priv;
 +	struct nfp_stat_pair latest;
 +
 +	priv = nn->app_priv;
 +
 +	spin_lock_bh(&priv->rx_filter_lock);
 +
 +	if (nn->dp.ctrl & NFP_NET_CFG_CTRL_BPF)
 +		mod_timer(&priv->rx_filter_stats_timer,
 +			  jiffies + NFP_NET_STAT_POLL_IVL);
 +
 +	spin_unlock_bh(&priv->rx_filter_lock);
 +
 +	latest.pkts = nn_readq(nn, NFP_NET_CFG_STATS_APP1_FRAMES);
 +	latest.bytes = nn_readq(nn, NFP_NET_CFG_STATS_APP1_BYTES);
 +
 +	if (latest.pkts != priv->rx_filter.pkts)
 +		priv->rx_filter_change = jiffies;
 +
 +	priv->rx_filter = latest;
 +}
 +
 +#if 0 /* Not in RHEL7 */
 +static void nfp_net_bpf_stats_reset(struct nfp_net *nn)
 +{
 +	struct nfp_net_bpf_priv *priv = nn->app_priv;
 +
 +	priv->rx_filter.pkts = nn_readq(nn, NFP_NET_CFG_STATS_APP1_FRAMES);
 +	priv->rx_filter.bytes = nn_readq(nn, NFP_NET_CFG_STATS_APP1_BYTES);
 +	priv->rx_filter_prev = priv->rx_filter;
 +	priv->rx_filter_change = jiffies;
 +}
 +
 +static int
 +nfp_net_bpf_stats_update(struct nfp_net *nn, struct tc_cls_bpf_offload *cls_bpf)
 +{
 +	struct tc_action *a;
 +	LIST_HEAD(actions);
 +	struct nfp_net_bpf_priv *priv = nn->app_priv;
 +	u64 bytes, pkts;
 +
 +	pkts = priv->rx_filter.pkts - priv->rx_filter_prev.pkts;
 +	bytes = priv->rx_filter.bytes - priv->rx_filter_prev.bytes;
 +	bytes -= pkts * ETH_HLEN;
 +
 +	priv->rx_filter_prev = priv->rx_filter;
 +
 +	preempt_disable();
 +
 +	tcf_exts_to_list(cls_bpf->exts, &actions);
 +	list_for_each_entry(a, &actions, list)
 +		tcf_action_stats_update(a, bytes, pkts, nn->rx_filter_change);
 +
 +	preempt_enable();
 +
 +	return 0;
 +}
 +
 +static int
 +nfp_net_bpf_get_act(struct nfp_net *nn, struct tc_cls_bpf_offload *cls_bpf)
 +{
 +	const struct tc_action *a;
 +	LIST_HEAD(actions);
 +
 +	if (!cls_bpf->exts)
 +		return NN_ACT_XDP;
 +
 +	/* TC direct action */
 +	if (cls_bpf->exts_integrated) {
 +		if (tc_no_actions(cls_bpf->exts))
 +			return NN_ACT_DIRECT;
 +
 +		return -EOPNOTSUPP;
 +	}
 +
 +	/* TC legacy mode */
 +	if (!tc_single_action(cls_bpf->exts))
 +		return -EOPNOTSUPP;
 +
 +	tcf_exts_to_list(cls_bpf->exts, &actions);
 +	list_for_each_entry(a, &actions, list) {
 +		if (is_tcf_gact_shot(a))
 +			return NN_ACT_TC_DROP;
 +
 +		if (is_tcf_mirred_egress_redirect(a) &&
 +		    tcf_mirred_ifindex(a) == nn->dp.netdev->ifindex)
 +			return NN_ACT_TC_REDIR;
 +	}
 +
 +	return -EOPNOTSUPP;
 +}
 +
++=======
++>>>>>>> 012bb8a8b5a2 (nfp: bpf: drop support for cls_bpf with legacy actions)
  static int
  nfp_net_bpf_offload_prepare(struct nfp_net *nn,
  			    struct tc_cls_bpf_offload *cls_bpf,
diff --cc drivers/net/ethernet/netronome/nfp/bpf/verifier.c
index 8b981cfbeb65,4f31bdefd331..000000000000
--- a/drivers/net/ethernet/netronome/nfp/bpf/verifier.c
+++ b/drivers/net/ethernet/netronome/nfp/bpf/verifier.c
@@@ -76,31 -76,30 +76,39 @@@ nfp_bpf_goto_meta(struct nfp_prog *nfp_
  
  static int
  nfp_bpf_check_exit(struct nfp_prog *nfp_prog,
 -		   struct bpf_verifier_env *env)
 +		   const struct bpf_verifier_env *env)
  {
 -	const struct bpf_reg_state *reg0 = cur_regs(env) + BPF_REG_0;
 -	u64 imm;
 +	const struct bpf_reg_state *reg0 = &env->cur_state.regs[0];
  
- 	if (nfp_prog->act == NN_ACT_XDP)
+ 	if (nfp_prog->type == BPF_PROG_TYPE_XDP)
  		return 0;
  
 -	if (!(reg0->type == SCALAR_VALUE && tnum_is_const(reg0->var_off))) {
 -		char tn_buf[48];
 +	if (reg0->type != CONST_IMM) {
 +		pr_info("unsupported exit state: %d, imm: %llx\n",
 +			reg0->type, reg0->imm);
 +		return -EINVAL;
 +	}
  
 -		tnum_strn(tn_buf, sizeof(tn_buf), reg0->var_off);
 -		pr_info("unsupported exit state: %d, var_off: %s\n",
 -			reg0->type, tn_buf);
++<<<<<<< HEAD
 +	if (nfp_prog->act != NN_ACT_DIRECT &&
 +	    reg0->imm != 0 && (reg0->imm & ~0U) != ~0U) {
 +		pr_info("unsupported exit state: %d, imm: %llx\n",
 +			reg0->type, reg0->imm);
  		return -EINVAL;
  	}
  
 +	if (nfp_prog->act == NN_ACT_DIRECT && reg0->imm <= TC_ACT_REDIRECT &&
 +	    reg0->imm != TC_ACT_SHOT && reg0->imm != TC_ACT_STOLEN &&
 +	    reg0->imm != TC_ACT_QUEUED) {
++=======
+ 	imm = reg0->var_off.value;
+ 	if (nfp_prog->type == BPF_PROG_TYPE_SCHED_CLS &&
+ 	    imm <= TC_ACT_REDIRECT &&
+ 	    imm != TC_ACT_SHOT && imm != TC_ACT_STOLEN &&
+ 	    imm != TC_ACT_QUEUED) {
++>>>>>>> 012bb8a8b5a2 (nfp: bpf: drop support for cls_bpf with legacy actions)
  		pr_info("unsupported exit state: %d, imm: %llx\n",
 -			reg0->type, imm);
 +			reg0->type, reg0->imm);
  		return -EINVAL;
  	}
  
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/jit.c
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/main.c
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/main.h
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/offload.c
* Unmerged path drivers/net/ethernet/netronome/nfp/bpf/verifier.c
