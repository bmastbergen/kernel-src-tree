net/mlx5e: Ignore attempts to offload multiple times a TC flow

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Ignore attempts to offload multiple times a TC flow (Alaa Hleihel) [1591249]
Rebuild_FUZZ: 96.67%
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit 8f8ae8953fb34ac01723f1dae5b231f64a3c526b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/8f8ae895.failed

For VF->VF and uplink->VF rules, the TC core (cls_api) attempts
to offload the same flow multiple times into the driver, b/c we
registered to the egdev callback.

Use the flow cookie to ignore attempts to add such flows, we can't
reject them (return error), b/c this will fail the offload attempt,
so we ignore that. We indentify wrong stat/del calls using the flow
ingress/egress flags, here we do return error to the core.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Reviewed-by: Paul Blakey <paulb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 8f8ae8953fb34ac01723f1dae5b231f64a3c526b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 6d96a2447540,674f1d7d2737..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -2579,11 -2664,19 +2579,22 @@@ int mlx5e_configure_flower(struct mlx5e
  	int attr_size, err = 0;
  	u8 flow_flags = 0;
  
++<<<<<<< HEAD
++=======
+ 	get_flags(flags, &flow_flags);
+ 
+ 	flow = rhashtable_lookup_fast(tc_ht, &f->cookie, tc_ht_params);
+ 	if (flow) {
+ 		netdev_warn_once(priv->netdev, "flow cookie %lx already exists, ignoring\n", f->cookie);
+ 		return 0;
+ 	}
+ 
++>>>>>>> 8f8ae8953fb3 (net/mlx5e: Ignore attempts to offload multiple times a TC flow)
  	if (esw && esw->mode == SRIOV_OFFLOADS) {
 -		flow_flags |= MLX5E_TC_FLOW_ESWITCH;
 +		flow_flags = MLX5E_TC_FLOW_ESWITCH;
  		attr_size  = sizeof(struct mlx5_esw_flow_attr);
  	} else {
 -		flow_flags |= MLX5E_TC_FLOW_NIC;
 +		flow_flags = MLX5E_TC_FLOW_NIC;
  		attr_size  = sizeof(struct mlx5_nic_flow_attr);
  	}
  
@@@ -2640,8 -2734,19 +2651,19 @@@ err_free
  	return err;
  }
  
+ #define DIRECTION_MASK (MLX5E_TC_INGRESS | MLX5E_TC_EGRESS)
+ #define FLOW_DIRECTION_MASK (MLX5E_TC_FLOW_INGRESS | MLX5E_TC_FLOW_EGRESS)
+ 
+ static bool same_flow_direction(struct mlx5e_tc_flow *flow, int flags)
+ {
+ 	if ((flow->flags & FLOW_DIRECTION_MASK) == (flags & DIRECTION_MASK))
+ 		return true;
+ 
+ 	return false;
+ }
+ 
  int mlx5e_delete_flower(struct mlx5e_priv *priv,
 -			struct tc_cls_flower_offload *f, int flags)
 +			struct tc_cls_flower_offload *f)
  {
  	struct rhashtable *tc_ht = get_tc_ht(priv);
  	struct mlx5e_tc_flow *flow;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
