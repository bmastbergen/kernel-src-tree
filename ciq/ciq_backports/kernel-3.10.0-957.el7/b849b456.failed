target: Add netlink command reply supported option for each device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [target] Add netlink command reply supported option for each device (Xiubo Li) [1559232]
Rebuild_FUZZ: 93.55%
commit-author Kenjiro Nakayama <nakayamakenjiro@gmail.com>
commit b849b4567549d5a54ab34ffacfd48fca05e8b34e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/b849b456.failed

Currently netlink command reply support option
(TCMU_ATTR_SUPP_KERN_CMD_REPLY) can be enabled only on module
scope. Because of that, once an application enables the netlink
command reply support, all applications using target_core_user.ko
would be expected to support the netlink reply. To make matters worse,
users will not be able to add a device via configfs manually.

To fix these issues, this patch adds an option to make netlink command
reply disabled on each device through configfs. Original
TCMU_ATTR_SUPP_KERN_CMD_REPLY is still enabled on module scope to keep
backward-compatibility and used by default, however once users set
nl_reply_supported=<NAGATIVE_VALUE> via configfs for a particular
device, the device disables the netlink command reply support.

	Signed-off-by: Kenjiro Nakayama <nakayamakenjiro@gmail.com>
	Reviewed-by: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit b849b4567549d5a54ab34ffacfd48fca05e8b34e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_user.c
diff --cc drivers/target/target_core_user.c
index 2ac4515b6a67,3189bf0bc7f1..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -1262,8 -1555,22 +1271,23 @@@ static int tcmu_configure_device(struc
  	/* Other attributes can be configured in userspace */
  	if (!dev->dev_attrib.hw_max_sectors)
  		dev->dev_attrib.hw_max_sectors = 128;
 -	if (!dev->dev_attrib.emulate_write_cache)
 -		dev->dev_attrib.emulate_write_cache = 0;
  	dev->dev_attrib.hw_queue_depth = 128;
  
++<<<<<<< HEAD
++=======
+ 	/* If user didn't explicitly disable netlink reply support, use
+ 	 * module scope setting.
+ 	 */
+ 	if (udev->nl_reply_supported >= 0)
+ 		udev->nl_reply_supported = tcmu_kern_cmd_reply_supported;
+ 
+ 	/*
+ 	 * Get a ref incase userspace does a close on the uio device before
+ 	 * LIO has initiated tcmu_free_device.
+ 	 */
+ 	kref_get(&udev->kref);
+ 
++>>>>>>> b849b4567549 (target: Add netlink command reply supported option for each device)
  	ret = tcmu_netlink_event(udev, TCMU_CMD_ADDED_DEVICE, 0, NULL);
  	if (ret)
  		goto err_netlink;
@@@ -1350,7 -1627,7 +1374,11 @@@ static void tcmu_destroy_device(struct 
  
  enum {
  	Opt_dev_config, Opt_dev_size, Opt_hw_block_size, Opt_hw_max_sectors,
++<<<<<<< HEAD
 +	Opt_max_data_area_mb, Opt_err,
++=======
+ 	Opt_nl_reply_supported, Opt_err,
++>>>>>>> b849b4567549 (target: Add netlink command reply supported option for each device)
  };
  
  static match_table_t tokens = {
@@@ -1358,7 -1635,7 +1386,11 @@@
  	{Opt_dev_size, "dev_size=%u"},
  	{Opt_hw_block_size, "hw_block_size=%u"},
  	{Opt_hw_max_sectors, "hw_max_sectors=%u"},
++<<<<<<< HEAD
 +	{Opt_max_data_area_mb, "max_data_area_mb=%u"},
++=======
+ 	{Opt_nl_reply_supported, "nl_reply_supported=%d"},
++>>>>>>> b849b4567549 (target: Add netlink command reply supported option for each device)
  	{Opt_err, NULL}
  };
  
@@@ -1433,38 -1710,17 +1465,50 @@@ static ssize_t tcmu_set_configfs_dev_pa
  			ret = tcmu_set_dev_attrib(&args[0],
  					&(dev->dev_attrib.hw_max_sectors));
  			break;
++<<<<<<< HEAD
 +		case Opt_max_data_area_mb:
 +			if (dev->export_count) {
 +				pr_err("Unable to set max_data_area_mb while exports exist\n");
 +				ret = -EINVAL;
 +				break;
 +			}
 +
++=======
+ 		case Opt_nl_reply_supported:
++>>>>>>> b849b4567549 (target: Add netlink command reply supported option for each device)
  			arg_p = match_strdup(&args[0]);
  			if (!arg_p) {
  				ret = -ENOMEM;
  				break;
  			}
++<<<<<<< HEAD
 +			ret = kstrtoint(arg_p, 0, &tmpval);
 +			kfree(arg_p);
 +			if (ret < 0) {
 +				pr_err("kstrtoint() failed for max_data_area_mb=\n");
 +				break;
 +			}
 +
 +			if (tmpval <= 0) {
 +				pr_err("Invalid max_data_area %d\n", tmpval);
 +				ret = -EINVAL;
 +				break;
 +			}
 +
 +			udev->max_blocks = TCMU_MBS_TO_BLOCKS(tmpval);
 +			if (udev->max_blocks > DATA_BLOCKS_BITS_MAX) {
 +				pr_err("%d is too large. Adjusting max_data_area_mb to global limit of %u\n",
 +				       tmpval,
 +				       TCMU_BLOCKS_TO_MBS(DATA_BLOCKS_BITS_MAX));
 +				udev->max_blocks = DATA_BLOCKS_BITS_MAX;
 +			}
++=======
+ 			ret = kstrtol(arg_p, 0,
+ 					(long int *) &udev->nl_reply_supported);
+ 			kfree(arg_p);
+ 			if (ret < 0)
+ 				pr_err("kstrtoul() failed for nl_reply_supported=\n");
++>>>>>>> b849b4567549 (target: Add netlink command reply supported option for each device)
  			break;
  		default:
  			break;
@@@ -1611,22 -1871,77 +1655,60 @@@ static ssize_t tcmu_dev_size_store(stru
  }
  CONFIGFS_ATTR(tcmu_, dev_size);
  
++<<<<<<< HEAD
 +static ssize_t tcmu_max_data_area_mb_show(struct config_item *item, char *page)
++=======
+ static ssize_t tcmu_nl_reply_supported_show(struct config_item *item,
+ 		char *page)
+ {
+ 	struct se_dev_attrib *da = container_of(to_config_group(item),
+ 						struct se_dev_attrib, da_group);
+ 	struct tcmu_dev *udev = TCMU_DEV(da->da_dev);
+ 
+ 	return snprintf(page, PAGE_SIZE, "%d\n", udev->nl_reply_supported);
+ }
+ 
+ static ssize_t tcmu_nl_reply_supported_store(struct config_item *item,
+ 		const char *page, size_t count)
+ {
+ 	struct se_dev_attrib *da = container_of(to_config_group(item),
+ 						struct se_dev_attrib, da_group);
+ 	struct tcmu_dev *udev = TCMU_DEV(da->da_dev);
+ 	s8 val;
+ 	int ret;
+ 
+ 	ret = kstrtos8(page, 0, &val);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	udev->nl_reply_supported = val;
+ 	return count;
+ }
+ CONFIGFS_ATTR(tcmu_, nl_reply_supported);
+ 
+ static ssize_t tcmu_emulate_write_cache_show(struct config_item *item,
+ 					     char *page)
++>>>>>>> b849b4567549 (target: Add netlink command reply supported option for each device)
  {
  	struct se_dev_attrib *da = container_of(to_config_group(item),
 -					struct se_dev_attrib, da_group);
 -
 -	return snprintf(page, PAGE_SIZE, "%i\n", da->emulate_write_cache);
 -}
 -
 -static ssize_t tcmu_emulate_write_cache_store(struct config_item *item,
 -					      const char *page, size_t count)
 -{
 -	struct se_dev_attrib *da = container_of(to_config_group(item),
 -					struct se_dev_attrib, da_group);
 +						struct se_dev_attrib, da_group);
  	struct tcmu_dev *udev = TCMU_DEV(da->da_dev);
 -	u8 val;
 -	int ret;
 -
 -	ret = kstrtou8(page, 0, &val);
 -	if (ret < 0)
 -		return ret;
 -
 -	/* Check if device has been configured before */
 -	if (tcmu_dev_configured(udev)) {
 -		ret = tcmu_netlink_event(udev, TCMU_CMD_RECONFIG_DEVICE,
 -					 TCMU_ATTR_WRITECACHE, &val);
 -		if (ret) {
 -			pr_err("Unable to reconfigure device\n");
 -			return ret;
 -		}
 -	}
  
 -	da->emulate_write_cache = val;
 -	return count;
 +	return snprintf(page, PAGE_SIZE, "%u\n",
 +			TCMU_BLOCKS_TO_MBS(udev->max_blocks));
  }
 -CONFIGFS_ATTR(tcmu_, emulate_write_cache);
 +CONFIGFS_ATTR_RO(tcmu_, max_data_area_mb);
  
 -static struct configfs_attribute *tcmu_attrib_attrs[] = {
 +struct configfs_attribute *tcmu_attrib_attrs[] = {
  	&tcmu_attr_cmd_time_out,
 -	&tcmu_attr_dev_config,
 +	&tcmu_attr_qfull_time_out,
 +	&tcmu_attr_max_data_area_mb,
  	&tcmu_attr_dev_size,
++<<<<<<< HEAD
++=======
+ 	&tcmu_attr_emulate_write_cache,
+ 	&tcmu_attr_nl_reply_supported,
++>>>>>>> b849b4567549 (target: Add netlink command reply supported option for each device)
  	NULL,
  };
  
* Unmerged path drivers/target/target_core_user.c
