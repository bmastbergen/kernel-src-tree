mqprio: fix potential null pointer dereference on opt

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Colin Ian King <colin.king@canonical.com>
commit 22ce97fe49b5522e0f97b7c2282ed71a1abd7410
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/22ce97fe.failed

The pointer opt has a null check however before for this check opt is
dereferenced when len is initialized, hence we potentially have a null
pointer deference on opt.  Avoid this by checking for a null opt before
dereferencing it.

Detected by CoverityScan, CID#1458234 ("Dereference before null check")

Fixes: 4e8b86c06269 ("mqprio: Introduce new hardware offload mode and shaper in mqprio")
	Signed-off-by: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 22ce97fe49b5522e0f97b7c2282ed71a1abd7410)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_mqprio.c
diff --cc net/sched/sch_mqprio.c
index 5cc75dbd241e,51c2b289c69b..000000000000
--- a/net/sched/sch_mqprio.c
+++ b/net/sched/sch_mqprio.c
@@@ -105,6 -139,10 +105,13 @@@ static int mqprio_init(struct Qdisc *sc
  	struct Qdisc *qdisc;
  	int i, err = -EOPNOTSUPP;
  	struct tc_mqprio_qopt *qopt = NULL;
++<<<<<<< HEAD
++=======
+ 	struct nlattr *tb[TCA_MQPRIO_MAX + 1];
+ 	struct nlattr *attr;
+ 	int rem;
+ 	int len;
++>>>>>>> 22ce97fe49b5 (mqprio: fix potential null pointer dereference on opt)
  
  	BUILD_BUG_ON(TC_MAX_QUEUE != TC_QOPT_MAX_QUEUE);
  	BUILD_BUG_ON(TC_BITMASK != TC_QOPT_BITMASK);
@@@ -122,6 -164,59 +129,62 @@@
  	if (mqprio_parse_opt(dev, qopt))
  		return -EINVAL;
  
++<<<<<<< HEAD
++=======
+ 	len = nla_len(opt) - NLA_ALIGN(sizeof(*qopt));
+ 	if (len > 0) {
+ 		err = parse_attr(tb, TCA_MQPRIO_MAX, opt, mqprio_policy,
+ 				 sizeof(*qopt));
+ 		if (err < 0)
+ 			return err;
+ 
+ 		if (!qopt->hw)
+ 			return -EINVAL;
+ 
+ 		if (tb[TCA_MQPRIO_MODE]) {
+ 			priv->flags |= TC_MQPRIO_F_MODE;
+ 			priv->mode = *(u16 *)nla_data(tb[TCA_MQPRIO_MODE]);
+ 		}
+ 
+ 		if (tb[TCA_MQPRIO_SHAPER]) {
+ 			priv->flags |= TC_MQPRIO_F_SHAPER;
+ 			priv->shaper = *(u16 *)nla_data(tb[TCA_MQPRIO_SHAPER]);
+ 		}
+ 
+ 		if (tb[TCA_MQPRIO_MIN_RATE64]) {
+ 			if (priv->shaper != TC_MQPRIO_SHAPER_BW_RATE)
+ 				return -EINVAL;
+ 			i = 0;
+ 			nla_for_each_nested(attr, tb[TCA_MQPRIO_MIN_RATE64],
+ 					    rem) {
+ 				if (nla_type(attr) != TCA_MQPRIO_MIN_RATE64)
+ 					return -EINVAL;
+ 				if (i >= qopt->num_tc)
+ 					break;
+ 				priv->min_rate[i] = *(u64 *)nla_data(attr);
+ 				i++;
+ 			}
+ 			priv->flags |= TC_MQPRIO_F_MIN_RATE;
+ 		}
+ 
+ 		if (tb[TCA_MQPRIO_MAX_RATE64]) {
+ 			if (priv->shaper != TC_MQPRIO_SHAPER_BW_RATE)
+ 				return -EINVAL;
+ 			i = 0;
+ 			nla_for_each_nested(attr, tb[TCA_MQPRIO_MAX_RATE64],
+ 					    rem) {
+ 				if (nla_type(attr) != TCA_MQPRIO_MAX_RATE64)
+ 					return -EINVAL;
+ 				if (i >= qopt->num_tc)
+ 					break;
+ 				priv->max_rate[i] = *(u64 *)nla_data(attr);
+ 				i++;
+ 			}
+ 			priv->flags |= TC_MQPRIO_F_MAX_RATE;
+ 		}
+ 	}
+ 
++>>>>>>> 22ce97fe49b5 (mqprio: fix potential null pointer dereference on opt)
  	/* pre-allocate qdisc, attachment can't fail */
  	priv->qdiscs = kcalloc(dev->num_tx_queues, sizeof(priv->qdiscs[0]),
  			       GFP_KERNEL);
* Unmerged path net/sched/sch_mqprio.c
