tcp: free batches of packets in tcp_prune_ofo_queue()

jira LE-1907
cve CVE-2018-5390
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 72cd43ba64fc172a443410ce01645895850844c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/72cd43ba.failed

Juha-Matti Tilli reported that malicious peers could inject tiny
packets in out_of_order_queue, forcing very expensive calls
to tcp_collapse_ofo_queue() and tcp_prune_ofo_queue() for
every incoming packet. out_of_order_queue rb-tree can contain
thousands of nodes, iterating over all of them is not nice.

Before linux-4.9, we would have pruned all packets in ofo_queue
in one go, every XXXX packets. XXXX depends on sk_rcvbuf and skbs
truesize, but is about 7000 packets with tcp_rmem[2] default of 6 MB.

Since we plan to increase tcp_rmem[2] in the future to cope with
modern BDP, can not revert to the old behavior, without great pain.

Strategy taken in this patch is to purge ~12.5 % of the queue capacity.

Fixes: 36a6503fedda ("tcp: refine tcp_prune_ofo_queue() to not drop all packets")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reported-by: Juha-Matti Tilli <juha-matti.tilli@iki.fi>
	Acked-by: Yuchung Cheng <ycheng@google.com>
	Acked-by: Soheil Hassas Yeganeh <soheil@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 72cd43ba64fc172a443410ce01645895850844c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_input.c
diff --cc net/ipv4/tcp_input.c
index 4ec1e4f8ab44,64e45b279431..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -4748,29 -4936,52 +4748,76 @@@ static void tcp_collapse_ofo_queue(stru
  }
  
  /*
++<<<<<<< HEAD
 + * Purge the out-of-order queue.
 + * Return true if queue was pruned.
++=======
+  * Clean the out-of-order queue to make room.
+  * We drop high sequences packets to :
+  * 1) Let a chance for holes to be filled.
+  * 2) not add too big latencies if thousands of packets sit there.
+  *    (But if application shrinks SO_RCVBUF, we could still end up
+  *     freeing whole queue here)
+  * 3) Drop at least 12.5 % of sk_rcvbuf to avoid malicious attacks.
+  *
+  * Return true if queue has shrunk.
++>>>>>>> 72cd43ba64fc (tcp: free batches of packets in tcp_prune_ofo_queue())
   */
  static bool tcp_prune_ofo_queue(struct sock *sk)
  {
  	struct tcp_sock *tp = tcp_sk(sk);
++<<<<<<< HEAD
 +	bool res = false;
++=======
+ 	struct rb_node *node, *prev;
+ 	int goal;
++>>>>>>> 72cd43ba64fc (tcp: free batches of packets in tcp_prune_ofo_queue())
  
 -	if (RB_EMPTY_ROOT(&tp->out_of_order_queue))
 -		return false;
 +	if (!skb_queue_empty(&tp->out_of_order_queue)) {
 +		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_OFOPRUNED);
 +		__skb_queue_purge(&tp->out_of_order_queue);
  
++<<<<<<< HEAD
 +		/* Reset SACK state.  A conforming SACK implementation will
 +		 * do the same at a timeout based retransmit.  When a connection
 +		 * is in a sad state like this, we care only about integrity
 +		 * of the connection not performance.
 +		 */
 +		if (tp->rx_opt.sack_ok)
 +			tcp_sack_reset(&tp->rx_opt);
 +		sk_mem_reclaim(sk);
 +		res = true;
 +	}
 +	return res;
++=======
+ 	NET_INC_STATS(sock_net(sk), LINUX_MIB_OFOPRUNED);
+ 	goal = sk->sk_rcvbuf >> 3;
+ 	node = &tp->ooo_last_skb->rbnode;
+ 	do {
+ 		prev = rb_prev(node);
+ 		rb_erase(node, &tp->out_of_order_queue);
+ 		goal -= rb_to_skb(node)->truesize;
+ 		tcp_drop(sk, rb_to_skb(node));
+ 		if (!prev || goal <= 0) {
+ 			sk_mem_reclaim(sk);
+ 			if (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf &&
+ 			    !tcp_under_memory_pressure(sk))
+ 				break;
+ 			goal = sk->sk_rcvbuf >> 3;
+ 		}
+ 		node = prev;
+ 	} while (node);
+ 	tp->ooo_last_skb = rb_to_skb(prev);
+ 
+ 	/* Reset SACK state.  A conforming SACK implementation will
+ 	 * do the same at a timeout based retransmit.  When a connection
+ 	 * is in a sad state like this, we care only about integrity
+ 	 * of the connection not performance.
+ 	 */
+ 	if (tp->rx_opt.sack_ok)
+ 		tcp_sack_reset(&tp->rx_opt);
+ 	return true;
++>>>>>>> 72cd43ba64fc (tcp: free batches of packets in tcp_prune_ofo_queue())
  }
  
  /* Reduce allocated memory if we can, trying to get
* Unmerged path net/ipv4/tcp_input.c
