netfilter: ipset: Simplify mtype_expire() for hash types

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
commit 509debc97587629dd5a6dca337afa57cb874b418
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/509debc9.failed

Remove one leve of intendation by using continue while
iterating over elements in bucket.

Ported from a patch proposed by Sergey Popovich <popovich_sergei@mail.ua>.

	Signed-off-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
(cherry picked from commit 509debc97587629dd5a6dca337afa57cb874b418)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_hash_gen.h
diff --cc net/netfilter/ipset/ip_set_hash_gen.h
index 9ce28af662bf,7999e4c556a5..000000000000
--- a/net/netfilter/ipset/ip_set_hash_gen.h
+++ b/net/netfilter/ipset/ip_set_hash_gen.h
@@@ -433,43 -463,54 +433,60 @@@ mtype_same_set(const struct ip_set *a, 
  	       a->extensions == b->extensions;
  }
  
 +/* Get the ith element from the array block n */
 +#define ahash_data(n, i, dsize)	\
 +	((struct mtype_elem *)((n)->value + ((i) * (dsize))))
 +
  /* Delete expired elements from the hashtable */
  static void
 -mtype_expire(struct ip_set *set, struct htype *h)
 +mtype_expire(struct htype *h, u8 nets_length, size_t dsize)
  {
 -	struct htable *t;
 -	struct hbucket *n, *tmp;
 +	struct htable *t = h->table;
 +	struct hbucket *n;
  	struct mtype_elem *data;
 -	u32 i, j, d;
 -	size_t dsize = set->dsize;
 -#ifdef IP_SET_HASH_WITH_NETS
 -	u8 k, nets_length = NLEN(set->family);
 -#endif
 +	u32 i;
 +	int j;
  
 -	t = ipset_dereference_protected(h->table, set);
  	for (i = 0; i < jhash_size(t->htable_bits); i++) {
 -		n = __ipset_dereference_protected(hbucket(t, i), 1);
 -		if (!n)
 -			continue;
 -		for (j = 0, d = 0; j < n->pos; j++) {
 -			if (!test_bit(j, n->used)) {
 -				d++;
 -				continue;
 -			}
 +		n = hbucket(t, i);
 +		for (j = 0; j < n->pos; j++) {
  			data = ahash_data(n, j, dsize);
++<<<<<<< HEAD
 +			if (ip_set_timeout_expired(ext_timeout(data, h))) {
 +				pr_debug("expired %u/%u\n", i, j);
 +#ifdef IP_SET_HASH_WITH_NETS
 +				mtype_del_cidr(h, CIDR(data->cidr),
 +					       nets_length);
 +#endif
 +				if (j != n->pos - 1)
 +					/* Not last one */
 +					memcpy(data,
 +					       ahash_data(n, n->pos - 1, dsize),
 +					       dsize);
 +				n->pos--;
 +				h->elements--;
 +			}
++=======
+ 			if (!ip_set_timeout_expired(ext_timeout(data, set)))
+ 				continue;
+ 			pr_debug("expired %u/%u\n", i, j);
+ 			clear_bit(j, n->used);
+ 			smp_mb__after_atomic();
+ #ifdef IP_SET_HASH_WITH_NETS
+ 			for (k = 0; k < IPSET_NET_COUNT; k++)
+ 				mtype_del_cidr(h,
+ 					NCIDR_PUT(DCIDR_GET(data->cidr, k)),
+ 					nets_length, k);
+ #endif
+ 			ip_set_ext_destroy(set, data);
+ 			set->elements--;
+ 			d++;
++>>>>>>> 509debc97587 (netfilter: ipset: Simplify mtype_expire() for hash types)
  		}
 -		if (d >= AHASH_INIT_SIZE) {
 -			if (d >= n->size) {
 -				rcu_assign_pointer(hbucket(t, i), NULL);
 -				kfree_rcu(n, rcu);
 -				continue;
 -			}
 -			tmp = kzalloc(sizeof(*tmp) +
 -				      (n->size - AHASH_INIT_SIZE) * dsize,
 -				      GFP_ATOMIC);
 +		if (n->pos + AHASH_INIT_SIZE < n->size) {
 +			void *tmp = kzalloc((n->size - AHASH_INIT_SIZE)
 +					    * dsize,
 +					    GFP_ATOMIC);
  			if (!tmp)
  				/* Still try to delete expired elements */
  				continue;
* Unmerged path net/netfilter/ipset/ip_set_hash_gen.h
