x86/bugs, kvm: Introduce boot-time control of L1TF mitigations

jira LE-1907
cve CVE-2018-3620
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [x86] bugs, kvm: introduce boot-time control of l1tf mitigations (Christoph von Recklinghausen) [1593384] {CVE-2018-3620}
Rebuild_FUZZ: 96.67%
commit-author Jiri Kosina <jkosina@suse.cz>
commit d90a7a0ec83fb86622cd7dae23255d3c50a99ec8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/d90a7a0e.failed

Introduce the 'l1tf=' kernel command line option to allow for boot-time
switching of mitigation that is used on processors affected by L1TF.

The possible values are:

  full
	Provides all available mitigations for the L1TF vulnerability. Disables
	SMT and enables all mitigations in the hypervisors. SMT control via
	/sys/devices/system/cpu/smt/control is still possible after boot.
	Hypervisors will issue a warning when the first VM is started in
	a potentially insecure configuration, i.e. SMT enabled or L1D flush
	disabled.

  full,force
	Same as 'full', but disables SMT control. Implies the 'nosmt=force'
	command line option. sysfs control of SMT and the hypervisor flush
	control is disabled.

  flush
	Leaves SMT enabled and enables the conditional hypervisor mitigation.
	Hypervisors will issue a warning when the first VM is started in a
	potentially insecure configuration, i.e. SMT enabled or L1D flush
	disabled.

  flush,nosmt
	Disables SMT and enables the conditional hypervisor mitigation. SMT
	control via /sys/devices/system/cpu/smt/control is still possible
	after boot. If SMT is reenabled or flushing disabled at runtime
	hypervisors will issue a warning.

  flush,nowarn
	Same as 'flush', but hypervisors will not warn when
	a VM is started in a potentially insecure configuration.

  off
	Disables hypervisor mitigations and doesn't emit any warnings.

Default is 'flush'.

Let KVM adhere to these semantics, which means:

  - 'lt1f=full,force'	: Performe L1D flushes. No runtime control
    			  possible.

  - 'l1tf=full'
  - 'l1tf-flush'
  - 'l1tf=flush,nosmt'	: Perform L1D flushes and warn on VM start if
			  SMT has been runtime enabled or L1D flushing
			  has been run-time enabled
			  
  - 'l1tf=flush,nowarn'	: Perform L1D flushes and no warnings are emitted.
  
  - 'l1tf=off'		: L1D flushes are not performed and no warnings
			  are emitted.

KVM can always override the L1D flushing behavior using its 'vmentry_l1d_flush'
module parameter except when lt1f=full,force is set.

This makes KVM's private 'nosmt' option redundant, and as it is a bit
non-systematic anyway (this is something to control globally, not on
hypervisor level), remove that option.

Add the missing Documentation entry for the l1tf vulnerability sysfs file
while at it.

	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Tested-by: Jiri Kosina <jkosina@suse.cz>
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
Link: https://lkml.kernel.org/r/20180713142323.202758176@linutronix.de

(cherry picked from commit d90a7a0ec83fb86622cd7dae23255d3c50a99ec8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/ABI/testing/sysfs-devices-system-cpu
#	Documentation/kernel-parameters.txt
#	arch/x86/include/asm/processor.h
#	arch/x86/kernel/cpu/bugs.c
#	arch/x86/kvm/vmx.c
diff --cc Documentation/ABI/testing/sysfs-devices-system-cpu
index 7b467f328883,73318225a368..000000000000
--- a/Documentation/ABI/testing/sysfs-devices-system-cpu
+++ b/Documentation/ABI/testing/sysfs-devices-system-cpu
@@@ -274,7 -475,9 +274,13 @@@ What:		/sys/devices/system/cpu/vulnerab
  		/sys/devices/system/cpu/vulnerabilities/meltdown
  		/sys/devices/system/cpu/vulnerabilities/spectre_v1
  		/sys/devices/system/cpu/vulnerabilities/spectre_v2
++<<<<<<< HEAD
 +Date:		Januar 2018
++=======
+ 		/sys/devices/system/cpu/vulnerabilities/spec_store_bypass
+ 		/sys/devices/system/cpu/vulnerabilities/l1tf
+ Date:		January 2018
++>>>>>>> d90a7a0ec83f (x86/bugs, kvm: Introduce boot-time control of L1TF mitigations)
  Contact:	Linux kernel mailing list <linux-kernel@vger.kernel.org>
  Description:	Information about CPU vulnerabilities
  
@@@ -284,4 -487,27 +290,31 @@@
  
  		"Not affected"	  CPU is not affected by the vulnerability
  		"Vulnerable"	  CPU is affected and no mitigation in effect
++<<<<<<< HEAD
 +		"Mitigation: $M"  CPU is affetcted and mitigation $M is in effect
++=======
+ 		"Mitigation: $M"  CPU is affected and mitigation $M is in effect
+ 
+ 		Details about the l1tf file can be found in
+ 		Documentation/admin-guide/l1tf.rst
+ 
+ What:		/sys/devices/system/cpu/smt
+ 		/sys/devices/system/cpu/smt/active
+ 		/sys/devices/system/cpu/smt/control
+ Date:		June 2018
+ Contact:	Linux kernel mailing list <linux-kernel@vger.kernel.org>
+ Description:	Control Symetric Multi Threading (SMT)
+ 
+ 		active:  Tells whether SMT is active (enabled and siblings online)
+ 
+ 		control: Read/write interface to control SMT. Possible
+ 			 values:
+ 
+ 			 "on"		SMT is enabled
+ 			 "off"		SMT is disabled
+ 			 "forceoff"	SMT is force disabled. Cannot be changed.
+ 			 "notsupported" SMT is not supported by the CPU
+ 
+ 			 If control status is "forceoff" or "notsupported" writes
+ 			 are rejected.
++>>>>>>> d90a7a0ec83f (x86/bugs, kvm: Introduce boot-time control of L1TF mitigations)
diff --cc Documentation/kernel-parameters.txt
index a0f1f1428af0,9a08a7aa2bc3..000000000000
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@@ -1553,6 -1930,22 +1553,25 @@@ bytes respectively. Such letter suffixe
  			for all guests.
  			Default is 1 (enabled) if in 64-bit or 32-bit PAE mode.
  
++<<<<<<< HEAD:Documentation/kernel-parameters.txt
++=======
+ 	kvm-arm.vgic_v3_group0_trap=
+ 			[KVM,ARM] Trap guest accesses to GICv3 group-0
+ 			system registers
+ 
+ 	kvm-arm.vgic_v3_group1_trap=
+ 			[KVM,ARM] Trap guest accesses to GICv3 group-1
+ 			system registers
+ 
+ 	kvm-arm.vgic_v3_common_trap=
+ 			[KVM,ARM] Trap guest accesses to GICv3 common
+ 			system registers
+ 
+ 	kvm-arm.vgic_v4_enable=
+ 			[KVM,ARM] Allow use of GICv4 for direct injection of
+ 			LPIs.
+ 
++>>>>>>> d90a7a0ec83f (x86/bugs, kvm: Introduce boot-time control of L1TF mitigations):Documentation/admin-guide/kernel-parameters.txt
  	kvm-intel.ept=	[KVM,Intel] Disable extended page tables
  			(virtualized MMU) support on capable Intel chips.
  			Default is 1 (enabled)
diff --cc arch/x86/include/asm/processor.h
index 926574da6e32,79e409974ccc..000000000000
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@@ -1064,5 -980,18 +1064,21 @@@ bool xen_set_default_idle(void)
  #endif
  
  void stop_this_cpu(void *dummy);
++<<<<<<< HEAD
++=======
+ void df_debug(struct pt_regs *regs, long error_code);
+ void microcode_check(void);
+ 
+ enum l1tf_mitigations {
+ 	L1TF_MITIGATION_OFF,
+ 	L1TF_MITIGATION_FLUSH_NOWARN,
+ 	L1TF_MITIGATION_FLUSH,
+ 	L1TF_MITIGATION_FLUSH_NOSMT,
+ 	L1TF_MITIGATION_FULL,
+ 	L1TF_MITIGATION_FULL_FORCE
+ };
+ 
+ extern enum l1tf_mitigations l1tf_mitigation;
++>>>>>>> d90a7a0ec83f (x86/bugs, kvm: Introduce boot-time control of L1TF mitigations)
  
  #endif /* _ASM_X86_PROCESSOR_H */
diff --cc arch/x86/kernel/cpu/bugs.c
index 29b8876b1f95,fa6123bdd032..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -153,50 -358,386 +153,409 @@@ void __spectre_v2_select_mitigation(voi
  
  	case SPECTRE_V2_CMD_FORCE:
  	case SPECTRE_V2_CMD_AUTO:
 -		if (IS_ENABLED(CONFIG_RETPOLINE))
 -			goto retpoline_auto;
 -		break;
 -	case SPECTRE_V2_CMD_RETPOLINE_AMD:
 -		if (IS_ENABLED(CONFIG_RETPOLINE))
 -			goto retpoline_amd;
 -		break;
 -	case SPECTRE_V2_CMD_RETPOLINE_GENERIC:
 -		if (IS_ENABLED(CONFIG_RETPOLINE))
 -			goto retpoline_generic;
  		break;
 +
  	case SPECTRE_V2_CMD_RETPOLINE:
++<<<<<<< HEAD
 +		spec_ctrl_enable_retpoline();
 +		return;
 +
 +	case SPECTRE_V2_CMD_IBRS:
 +		if (spec_ctrl_force_enable_ibrs())
 +			return;
 +		break;
++=======
+ 		if (IS_ENABLED(CONFIG_RETPOLINE))
+ 			goto retpoline_auto;
+ 		break;
+ 	}
+ 	pr_err("Spectre mitigation: kernel not compiled with retpoline; no mitigation available!");
+ 	return;
+ 
+ retpoline_auto:
+ 	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) {
+ 	retpoline_amd:
+ 		if (!boot_cpu_has(X86_FEATURE_LFENCE_RDTSC)) {
+ 			pr_err("Spectre mitigation: LFENCE not serializing, switching to generic retpoline\n");
+ 			goto retpoline_generic;
+ 		}
+ 		mode = retp_compiler() ? SPECTRE_V2_RETPOLINE_AMD :
+ 					 SPECTRE_V2_RETPOLINE_MINIMAL_AMD;
+ 		setup_force_cpu_cap(X86_FEATURE_RETPOLINE_AMD);
+ 		setup_force_cpu_cap(X86_FEATURE_RETPOLINE);
+ 	} else {
+ 	retpoline_generic:
+ 		mode = retp_compiler() ? SPECTRE_V2_RETPOLINE_GENERIC :
+ 					 SPECTRE_V2_RETPOLINE_MINIMAL;
+ 		setup_force_cpu_cap(X86_FEATURE_RETPOLINE);
+ 	}
+ 
+ 	spectre_v2_enabled = mode;
+ 	pr_info("%s\n", spectre_v2_strings[mode]);
+ 
+ 	/*
+ 	 * If neither SMEP nor PTI are available, there is a risk of
+ 	 * hitting userspace addresses in the RSB after a context switch
+ 	 * from a shallow call stack to a deeper one. To prevent this fill
+ 	 * the entire RSB, even when using IBRS.
+ 	 *
+ 	 * Skylake era CPUs have a separate issue with *underflow* of the
+ 	 * RSB, when they will predict 'ret' targets from the generic BTB.
+ 	 * The proper mitigation for this is IBRS. If IBRS is not supported
+ 	 * or deactivated in favour of retpolines the RSB fill on context
+ 	 * switch is required.
+ 	 */
+ 	if ((!boot_cpu_has(X86_FEATURE_PTI) &&
+ 	     !boot_cpu_has(X86_FEATURE_SMEP)) || is_skylake_era()) {
+ 		setup_force_cpu_cap(X86_FEATURE_RSB_CTXSW);
+ 		pr_info("Spectre v2 mitigation: Filling RSB on context switch\n");
+ 	}
+ 
+ 	/* Initialize Indirect Branch Prediction Barrier if supported */
+ 	if (boot_cpu_has(X86_FEATURE_IBPB)) {
+ 		setup_force_cpu_cap(X86_FEATURE_USE_IBPB);
+ 		pr_info("Spectre v2 mitigation: Enabling Indirect Branch Prediction Barrier\n");
+ 	}
+ 
+ 	/*
+ 	 * Retpoline means the kernel is safe because it has no indirect
+ 	 * branches. But firmware isn't, so use IBRS to protect that.
+ 	 */
+ 	if (boot_cpu_has(X86_FEATURE_IBRS)) {
+ 		setup_force_cpu_cap(X86_FEATURE_USE_IBRS_FW);
+ 		pr_info("Enabling Restricted Speculation for firmware calls\n");
+ 	}
+ }
+ 
+ #undef pr_fmt
+ #define pr_fmt(fmt)	"Speculative Store Bypass: " fmt
+ 
+ static enum ssb_mitigation ssb_mode __ro_after_init = SPEC_STORE_BYPASS_NONE;
+ 
+ /* The kernel command line selection */
+ enum ssb_mitigation_cmd {
+ 	SPEC_STORE_BYPASS_CMD_NONE,
+ 	SPEC_STORE_BYPASS_CMD_AUTO,
+ 	SPEC_STORE_BYPASS_CMD_ON,
+ 	SPEC_STORE_BYPASS_CMD_PRCTL,
+ 	SPEC_STORE_BYPASS_CMD_SECCOMP,
+ };
+ 
+ static const char *ssb_strings[] = {
+ 	[SPEC_STORE_BYPASS_NONE]	= "Vulnerable",
+ 	[SPEC_STORE_BYPASS_DISABLE]	= "Mitigation: Speculative Store Bypass disabled",
+ 	[SPEC_STORE_BYPASS_PRCTL]	= "Mitigation: Speculative Store Bypass disabled via prctl",
+ 	[SPEC_STORE_BYPASS_SECCOMP]	= "Mitigation: Speculative Store Bypass disabled via prctl and seccomp",
+ };
+ 
+ static const struct {
+ 	const char *option;
+ 	enum ssb_mitigation_cmd cmd;
+ } ssb_mitigation_options[] = {
+ 	{ "auto",	SPEC_STORE_BYPASS_CMD_AUTO },    /* Platform decides */
+ 	{ "on",		SPEC_STORE_BYPASS_CMD_ON },      /* Disable Speculative Store Bypass */
+ 	{ "off",	SPEC_STORE_BYPASS_CMD_NONE },    /* Don't touch Speculative Store Bypass */
+ 	{ "prctl",	SPEC_STORE_BYPASS_CMD_PRCTL },   /* Disable Speculative Store Bypass via prctl */
+ 	{ "seccomp",	SPEC_STORE_BYPASS_CMD_SECCOMP }, /* Disable Speculative Store Bypass via prctl and seccomp */
+ };
+ 
+ static enum ssb_mitigation_cmd __init ssb_parse_cmdline(void)
+ {
+ 	enum ssb_mitigation_cmd cmd = SPEC_STORE_BYPASS_CMD_AUTO;
+ 	char arg[20];
+ 	int ret, i;
+ 
+ 	if (cmdline_find_option_bool(boot_command_line, "nospec_store_bypass_disable")) {
+ 		return SPEC_STORE_BYPASS_CMD_NONE;
+ 	} else {
+ 		ret = cmdline_find_option(boot_command_line, "spec_store_bypass_disable",
+ 					  arg, sizeof(arg));
+ 		if (ret < 0)
+ 			return SPEC_STORE_BYPASS_CMD_AUTO;
+ 
+ 		for (i = 0; i < ARRAY_SIZE(ssb_mitigation_options); i++) {
+ 			if (!match_option(arg, ret, ssb_mitigation_options[i].option))
+ 				continue;
+ 
+ 			cmd = ssb_mitigation_options[i].cmd;
+ 			break;
+ 		}
+ 
+ 		if (i >= ARRAY_SIZE(ssb_mitigation_options)) {
+ 			pr_err("unknown option (%s). Switching to AUTO select\n", arg);
+ 			return SPEC_STORE_BYPASS_CMD_AUTO;
+ 		}
+ 	}
+ 
+ 	return cmd;
+ }
+ 
+ static enum ssb_mitigation __init __ssb_select_mitigation(void)
+ {
+ 	enum ssb_mitigation mode = SPEC_STORE_BYPASS_NONE;
+ 	enum ssb_mitigation_cmd cmd;
+ 
+ 	if (!boot_cpu_has(X86_FEATURE_SSBD))
+ 		return mode;
+ 
+ 	cmd = ssb_parse_cmdline();
+ 	if (!boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS) &&
+ 	    (cmd == SPEC_STORE_BYPASS_CMD_NONE ||
+ 	     cmd == SPEC_STORE_BYPASS_CMD_AUTO))
+ 		return mode;
+ 
+ 	switch (cmd) {
+ 	case SPEC_STORE_BYPASS_CMD_AUTO:
+ 	case SPEC_STORE_BYPASS_CMD_SECCOMP:
+ 		/*
+ 		 * Choose prctl+seccomp as the default mode if seccomp is
+ 		 * enabled.
+ 		 */
+ 		if (IS_ENABLED(CONFIG_SECCOMP))
+ 			mode = SPEC_STORE_BYPASS_SECCOMP;
+ 		else
+ 			mode = SPEC_STORE_BYPASS_PRCTL;
+ 		break;
+ 	case SPEC_STORE_BYPASS_CMD_ON:
+ 		mode = SPEC_STORE_BYPASS_DISABLE;
+ 		break;
+ 	case SPEC_STORE_BYPASS_CMD_PRCTL:
+ 		mode = SPEC_STORE_BYPASS_PRCTL;
+ 		break;
+ 	case SPEC_STORE_BYPASS_CMD_NONE:
+ 		break;
+ 	}
+ 
+ 	/*
+ 	 * We have three CPU feature flags that are in play here:
+ 	 *  - X86_BUG_SPEC_STORE_BYPASS - CPU is susceptible.
+ 	 *  - X86_FEATURE_SSBD - CPU is able to turn off speculative store bypass
+ 	 *  - X86_FEATURE_SPEC_STORE_BYPASS_DISABLE - engage the mitigation
+ 	 */
+ 	if (mode == SPEC_STORE_BYPASS_DISABLE) {
+ 		setup_force_cpu_cap(X86_FEATURE_SPEC_STORE_BYPASS_DISABLE);
+ 		/*
+ 		 * Intel uses the SPEC CTRL MSR Bit(2) for this, while AMD may
+ 		 * use a completely different MSR and bit dependent on family.
+ 		 */
+ 		if (!static_cpu_has(X86_FEATURE_MSR_SPEC_CTRL))
+ 			x86_amd_ssb_disable();
+ 		else {
+ 			x86_spec_ctrl_base |= SPEC_CTRL_SSBD;
+ 			x86_spec_ctrl_mask |= SPEC_CTRL_SSBD;
+ 			wrmsrl(MSR_IA32_SPEC_CTRL, x86_spec_ctrl_base);
+ 		}
+ 	}
+ 
+ 	return mode;
+ }
+ 
+ static void ssb_select_mitigation(void)
+ {
+ 	ssb_mode = __ssb_select_mitigation();
+ 
+ 	if (boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS))
+ 		pr_info("%s\n", ssb_strings[ssb_mode]);
+ }
+ 
+ #undef pr_fmt
+ #define pr_fmt(fmt)     "Speculation prctl: " fmt
+ 
+ static int ssb_prctl_set(struct task_struct *task, unsigned long ctrl)
+ {
+ 	bool update;
+ 
+ 	if (ssb_mode != SPEC_STORE_BYPASS_PRCTL &&
+ 	    ssb_mode != SPEC_STORE_BYPASS_SECCOMP)
+ 		return -ENXIO;
+ 
+ 	switch (ctrl) {
+ 	case PR_SPEC_ENABLE:
+ 		/* If speculation is force disabled, enable is not allowed */
+ 		if (task_spec_ssb_force_disable(task))
+ 			return -EPERM;
+ 		task_clear_spec_ssb_disable(task);
+ 		update = test_and_clear_tsk_thread_flag(task, TIF_SSBD);
+ 		break;
+ 	case PR_SPEC_DISABLE:
+ 		task_set_spec_ssb_disable(task);
+ 		update = !test_and_set_tsk_thread_flag(task, TIF_SSBD);
+ 		break;
+ 	case PR_SPEC_FORCE_DISABLE:
+ 		task_set_spec_ssb_disable(task);
+ 		task_set_spec_ssb_force_disable(task);
+ 		update = !test_and_set_tsk_thread_flag(task, TIF_SSBD);
+ 		break;
+ 	default:
+ 		return -ERANGE;
+ 	}
+ 
+ 	/*
+ 	 * If being set on non-current task, delay setting the CPU
+ 	 * mitigation until it is next scheduled.
+ 	 */
+ 	if (task == current && update)
+ 		speculative_store_bypass_update_current();
+ 
+ 	return 0;
+ }
+ 
+ int arch_prctl_spec_ctrl_set(struct task_struct *task, unsigned long which,
+ 			     unsigned long ctrl)
+ {
+ 	switch (which) {
+ 	case PR_SPEC_STORE_BYPASS:
+ 		return ssb_prctl_set(task, ctrl);
+ 	default:
+ 		return -ENODEV;
+ 	}
+ }
+ 
+ #ifdef CONFIG_SECCOMP
+ void arch_seccomp_spec_mitigate(struct task_struct *task)
+ {
+ 	if (ssb_mode == SPEC_STORE_BYPASS_SECCOMP)
+ 		ssb_prctl_set(task, PR_SPEC_FORCE_DISABLE);
+ }
+ #endif
+ 
+ static int ssb_prctl_get(struct task_struct *task)
+ {
+ 	switch (ssb_mode) {
+ 	case SPEC_STORE_BYPASS_DISABLE:
+ 		return PR_SPEC_DISABLE;
+ 	case SPEC_STORE_BYPASS_SECCOMP:
+ 	case SPEC_STORE_BYPASS_PRCTL:
+ 		if (task_spec_ssb_force_disable(task))
+ 			return PR_SPEC_PRCTL | PR_SPEC_FORCE_DISABLE;
+ 		if (task_spec_ssb_disable(task))
+ 			return PR_SPEC_PRCTL | PR_SPEC_DISABLE;
+ 		return PR_SPEC_PRCTL | PR_SPEC_ENABLE;
+ 	default:
+ 		if (boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS))
+ 			return PR_SPEC_ENABLE;
+ 		return PR_SPEC_NOT_AFFECTED;
+ 	}
+ }
+ 
+ int arch_prctl_spec_ctrl_get(struct task_struct *task, unsigned long which)
+ {
+ 	switch (which) {
+ 	case PR_SPEC_STORE_BYPASS:
+ 		return ssb_prctl_get(task);
+ 	default:
+ 		return -ENODEV;
+ 	}
+ }
+ 
+ void x86_spec_ctrl_setup_ap(void)
+ {
+ 	if (boot_cpu_has(X86_FEATURE_MSR_SPEC_CTRL))
+ 		wrmsrl(MSR_IA32_SPEC_CTRL, x86_spec_ctrl_base);
+ 
+ 	if (ssb_mode == SPEC_STORE_BYPASS_DISABLE)
+ 		x86_amd_ssb_disable();
+ }
+ 
+ #undef pr_fmt
+ #define pr_fmt(fmt)	"L1TF: " fmt
+ 
+ /* Default mitigation for L1TF-affected CPUs */
+ enum l1tf_mitigations l1tf_mitigation __ro_after_init = L1TF_MITIGATION_FLUSH;
+ #if IS_ENABLED(CONFIG_KVM_INTEL)
+ EXPORT_SYMBOL_GPL(l1tf_mitigation);
+ 
+ enum vmx_l1d_flush_state l1tf_vmx_mitigation = VMENTER_L1D_FLUSH_AUTO;
+ EXPORT_SYMBOL_GPL(l1tf_vmx_mitigation);
+ #endif
+ 
+ static void __init l1tf_select_mitigation(void)
+ {
+ 	u64 half_pa;
+ 
+ 	if (!boot_cpu_has_bug(X86_BUG_L1TF))
+ 		return;
+ 
+ 	switch (l1tf_mitigation) {
+ 	case L1TF_MITIGATION_OFF:
+ 	case L1TF_MITIGATION_FLUSH_NOWARN:
+ 	case L1TF_MITIGATION_FLUSH:
+ 		break;
+ 	case L1TF_MITIGATION_FLUSH_NOSMT:
+ 	case L1TF_MITIGATION_FULL:
+ 		cpu_smt_disable(false);
+ 		break;
+ 	case L1TF_MITIGATION_FULL_FORCE:
+ 		cpu_smt_disable(true);
+ 		break;
+ 	}
+ 
+ #if CONFIG_PGTABLE_LEVELS == 2
+ 	pr_warn("Kernel not compiled for PAE. No mitigation for L1TF\n");
+ 	return;
+ #endif
++>>>>>>> d90a7a0ec83f (x86/bugs, kvm: Introduce boot-time control of L1TF mitigations)
  
 -	/*
 -	 * This is extremely unlikely to happen because almost all
 -	 * systems have far more MAX_PA/2 than RAM can be fit into
 -	 * DIMM slots.
 -	 */
 -	half_pa = (u64)l1tf_pfn_limit() << PAGE_SHIFT;
 -	if (e820__mapped_any(half_pa, ULLONG_MAX - half_pa, E820_TYPE_RAM)) {
 -		pr_warn("System has more than MAX_PA/2 memory. L1TF mitigation not effective.\n");
 -		return;
 +	case SPECTRE_V2_CMD_IBRS_ALWAYS:
 +		if (spec_ctrl_enable_ibrs_always() ||
 +		    spec_ctrl_force_enable_ibp_disabled())
 +			return;
 +		break;
 +
 +	case SPECTRE_V2_CMD_RETPOLINE_IBRS_USER:
 +		if (spec_ctrl_enable_retpoline_ibrs_user())
 +			return;
 +		break;
  	}
  
 -	setup_force_cpu_cap(X86_FEATURE_L1TF_PTEINV);
 +	if (spec_ctrl_cond_enable_ibrs(full_retpoline))
 +		return;
 +
 +	if (spec_ctrl_cond_enable_ibp_disabled())
 +		return;
 +
 +	spec_ctrl_enable_retpoline();
  }
  
++<<<<<<< HEAD
 +void spectre_v2_print_mitigation(void)
 +{
 +
 +	pr_info("%s\n", spectre_v2_strings[spec_ctrl_get_mitigation()]);
 +}
 +
 +static void __init spectre_v2_select_mitigation(void)
 +{
 +	spectre_v2_cmd = spectre_v2_parse_cmdline();
 +	__spectre_v2_select_mitigation();
 +	spectre_v2_print_mitigation();
 +}
++=======
+ static int __init l1tf_cmdline(char *str)
+ {
+ 	if (!boot_cpu_has_bug(X86_BUG_L1TF))
+ 		return 0;
+ 
+ 	if (!str)
+ 		return -EINVAL;
+ 
+ 	if (!strcmp(str, "off"))
+ 		l1tf_mitigation = L1TF_MITIGATION_OFF;
+ 	else if (!strcmp(str, "flush,nowarn"))
+ 		l1tf_mitigation = L1TF_MITIGATION_FLUSH_NOWARN;
+ 	else if (!strcmp(str, "flush"))
+ 		l1tf_mitigation = L1TF_MITIGATION_FLUSH;
+ 	else if (!strcmp(str, "flush,nosmt"))
+ 		l1tf_mitigation = L1TF_MITIGATION_FLUSH_NOSMT;
+ 	else if (!strcmp(str, "full"))
+ 		l1tf_mitigation = L1TF_MITIGATION_FULL;
+ 	else if (!strcmp(str, "full,force"))
+ 		l1tf_mitigation = L1TF_MITIGATION_FULL_FORCE;
+ 
+ 	return 0;
+ }
+ early_param("l1tf", l1tf_cmdline);
++>>>>>>> d90a7a0ec83f (x86/bugs, kvm: Introduce boot-time control of L1TF mitigations)
  
  #undef pr_fmt
  
diff --cc arch/x86/kvm/vmx.c
index e2f48f8aba96,c5c0118b126d..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -175,6 -188,137 +175,140 @@@ module_param(ple_window_max, uint, 0444
  
  extern const ulong vmx_return;
  
++<<<<<<< HEAD
++=======
+ static DEFINE_STATIC_KEY_FALSE(vmx_l1d_should_flush);
+ static DEFINE_STATIC_KEY_FALSE(vmx_l1d_flush_always);
+ static DEFINE_MUTEX(vmx_l1d_flush_mutex);
+ 
+ /* Storage for pre module init parameter parsing */
+ static enum vmx_l1d_flush_state __read_mostly vmentry_l1d_flush_param = VMENTER_L1D_FLUSH_AUTO;
+ 
+ static const struct {
+ 	const char *option;
+ 	enum vmx_l1d_flush_state cmd;
+ } vmentry_l1d_param[] = {
+ 	{"auto",	VMENTER_L1D_FLUSH_AUTO},
+ 	{"never",	VMENTER_L1D_FLUSH_NEVER},
+ 	{"cond",	VMENTER_L1D_FLUSH_COND},
+ 	{"always",	VMENTER_L1D_FLUSH_ALWAYS},
+ };
+ 
+ #define L1D_CACHE_ORDER 4
+ static void *vmx_l1d_flush_pages;
+ 
+ static int vmx_setup_l1d_flush(enum vmx_l1d_flush_state l1tf)
+ {
+ 	struct page *page;
+ 
+ 	if (!enable_ept) {
+ 		l1tf_vmx_mitigation = VMENTER_L1D_FLUSH_EPT_DISABLED;
+ 		return 0;
+ 	}
+ 
+ 	/* If set to auto use the default l1tf mitigation method */
+ 	if (l1tf == VMENTER_L1D_FLUSH_AUTO) {
+ 		switch (l1tf_mitigation) {
+ 		case L1TF_MITIGATION_OFF:
+ 			l1tf = VMENTER_L1D_FLUSH_NEVER;
+ 			break;
+ 		case L1TF_MITIGATION_FLUSH_NOWARN:
+ 		case L1TF_MITIGATION_FLUSH:
+ 		case L1TF_MITIGATION_FLUSH_NOSMT:
+ 			l1tf = VMENTER_L1D_FLUSH_COND;
+ 			break;
+ 		case L1TF_MITIGATION_FULL:
+ 		case L1TF_MITIGATION_FULL_FORCE:
+ 			l1tf = VMENTER_L1D_FLUSH_ALWAYS;
+ 			break;
+ 		}
+ 	} else if (l1tf_mitigation == L1TF_MITIGATION_FULL_FORCE) {
+ 		l1tf = VMENTER_L1D_FLUSH_ALWAYS;
+ 	}
+ 
+ 	if (l1tf != VMENTER_L1D_FLUSH_NEVER && !vmx_l1d_flush_pages &&
+ 	    !boot_cpu_has(X86_FEATURE_FLUSH_L1D)) {
+ 		page = alloc_pages(GFP_KERNEL, L1D_CACHE_ORDER);
+ 		if (!page)
+ 			return -ENOMEM;
+ 		vmx_l1d_flush_pages = page_address(page);
+ 	}
+ 
+ 	l1tf_vmx_mitigation = l1tf;
+ 
+ 	if (l1tf != VMENTER_L1D_FLUSH_NEVER)
+ 		static_branch_enable(&vmx_l1d_should_flush);
+ 	else
+ 		static_branch_disable(&vmx_l1d_should_flush);
+ 
+ 	if (l1tf == VMENTER_L1D_FLUSH_ALWAYS)
+ 		static_branch_enable(&vmx_l1d_flush_always);
+ 	else
+ 		static_branch_disable(&vmx_l1d_flush_always);
+ 	return 0;
+ }
+ 
+ static int vmentry_l1d_flush_parse(const char *s)
+ {
+ 	unsigned int i;
+ 
+ 	if (s) {
+ 		for (i = 0; i < ARRAY_SIZE(vmentry_l1d_param); i++) {
+ 			if (sysfs_streq(s, vmentry_l1d_param[i].option))
+ 				return vmentry_l1d_param[i].cmd;
+ 		}
+ 	}
+ 	return -EINVAL;
+ }
+ 
+ static int vmentry_l1d_flush_set(const char *s, const struct kernel_param *kp)
+ {
+ 	int l1tf, ret;
+ 
+ 	if (!boot_cpu_has(X86_BUG_L1TF))
+ 		return 0;
+ 
+ 	l1tf = vmentry_l1d_flush_parse(s);
+ 	if (l1tf < 0)
+ 		return l1tf;
+ 
+ 	/*
+ 	 * Has vmx_init() run already? If not then this is the pre init
+ 	 * parameter parsing. In that case just store the value and let
+ 	 * vmx_init() do the proper setup after enable_ept has been
+ 	 * established.
+ 	 */
+ 	if (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_AUTO) {
+ 		vmentry_l1d_flush_param = l1tf;
+ 		return 0;
+ 	}
+ 
+ 	mutex_lock(&vmx_l1d_flush_mutex);
+ 	ret = vmx_setup_l1d_flush(l1tf);
+ 	mutex_unlock(&vmx_l1d_flush_mutex);
+ 	return ret;
+ }
+ 
+ static int vmentry_l1d_flush_get(char *s, const struct kernel_param *kp)
+ {
+ 	return sprintf(s, "%s\n", vmentry_l1d_param[l1tf_vmx_mitigation].option);
+ }
+ 
+ static const struct kernel_param_ops vmentry_l1d_flush_ops = {
+ 	.set = vmentry_l1d_flush_set,
+ 	.get = vmentry_l1d_flush_get,
+ };
+ module_param_cb(vmentry_l1d_flush, &vmentry_l1d_flush_ops, NULL, 0644);
+ 
+ struct kvm_vmx {
+ 	struct kvm kvm;
+ 
+ 	unsigned int tss_addr;
+ 	bool ept_identity_pagetable_done;
+ 	gpa_t ept_identity_map_addr;
+ };
+ 
++>>>>>>> d90a7a0ec83f (x86/bugs, kvm: Introduce boot-time control of L1TF mitigations)
  #define NR_AUTOLOAD_MSRS 8
  
  struct vmcs {
@@@ -9247,6 -10584,40 +9381,43 @@@ free_vcpu
  	return ERR_PTR(err);
  }
  
++<<<<<<< HEAD
++=======
+ #define L1TF_MSG_SMT "L1TF CPU bug present and SMT on, data leak possible. See CVE-2018-3646 and https://www.kernel.org/doc/html/latest/admin-guide/l1tf.html for details.\n"
+ #define L1TF_MSG_L1D "L1TF CPU bug present and virtualization mitigation disabled, data leak possible. See CVE-2018-3646 and https://www.kernel.org/doc/html/latest/admin-guide/l1tf.html for details.\n"
+ 
+ static int vmx_vm_init(struct kvm *kvm)
+ {
+ 	if (!ple_gap)
+ 		kvm->arch.pause_in_guest = true;
+ 
+ 	if (boot_cpu_has(X86_BUG_L1TF) && enable_ept) {
+ 		switch (l1tf_mitigation) {
+ 		case L1TF_MITIGATION_OFF:
+ 		case L1TF_MITIGATION_FLUSH_NOWARN:
+ 			/* 'I explicitly don't care' is set */
+ 			break;
+ 		case L1TF_MITIGATION_FLUSH:
+ 		case L1TF_MITIGATION_FLUSH_NOSMT:
+ 		case L1TF_MITIGATION_FULL:
+ 			/*
+ 			 * Warn upon starting the first VM in a potentially
+ 			 * insecure environment.
+ 			 */
+ 			if (cpu_smt_control == CPU_SMT_ENABLED)
+ 				pr_warn_once(L1TF_MSG_SMT);
+ 			if (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_NEVER)
+ 				pr_warn_once(L1TF_MSG_L1D);
+ 			break;
+ 		case L1TF_MITIGATION_FULL_FORCE:
+ 			/* Flush is enforced */
+ 			break;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> d90a7a0ec83f (x86/bugs, kvm: Introduce boot-time control of L1TF mitigations)
  static void __init vmx_check_processor_compat(void *rtn)
  {
  	struct vmcs_config vmcs_conf;
* Unmerged path Documentation/ABI/testing/sysfs-devices-system-cpu
* Unmerged path Documentation/kernel-parameters.txt
* Unmerged path arch/x86/include/asm/processor.h
* Unmerged path arch/x86/kernel/cpu/bugs.c
* Unmerged path arch/x86/kvm/vmx.c
