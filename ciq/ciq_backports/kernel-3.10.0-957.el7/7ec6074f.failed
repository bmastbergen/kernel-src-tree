nvme: enforce 64bit offset for nvme_get_log_ext fn

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [nvme] enforce 64bit offset for nvme_get_log_ext fn (David Milburn) [1515584]
Rebuild_FUZZ: 93.62%
commit-author Matias Bjørling <mb@lightnvm.io>
commit 7ec6074ff005e5f6cd2cf186a9ec7496c3db04f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/7ec6074f.failed

Compiling on 32 bits system produces a warning for the shift width
when shifting 32 bit integer with 64bit integer.

Make sure that offset always is 64bit, and use macros for retrieving
lower and upper bits of the offset.

	Signed-off-by: Matias Bjørling <mb@lightnvm.io>
	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 7ec6074ff005e5f6cd2cf186a9ec7496c3db04f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
#	drivers/nvme/host/nvme.h
diff --cc drivers/nvme/host/core.c
index d63d62bfc80f,1bdd010a0cf5..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -1581,14 -2015,255 +1581,259 @@@ static void nvme_init_subnqn(struct nvm
  		dev_warn(ctrl->device, "missing or invalid SUBNQN field.\n");
  
  	/* Generate a "fake" NQN per Figure 254 in NVMe 1.3 + ECN 001 */
 -	off = snprintf(subsys->subnqn, NVMF_NQN_SIZE,
 +	off = snprintf(ctrl->subnqn, NVMF_NQN_SIZE,
  			"nqn.2014.08.org.nvmexpress:%4x%4x",
  			le16_to_cpu(id->vid), le16_to_cpu(id->ssvid));
 -	memcpy(subsys->subnqn + off, id->sn, sizeof(id->sn));
 +	memcpy(ctrl->subnqn + off, id->sn, sizeof(id->sn));
  	off += sizeof(id->sn);
 -	memcpy(subsys->subnqn + off, id->mn, sizeof(id->mn));
 +	memcpy(ctrl->subnqn + off, id->mn, sizeof(id->mn));
  	off += sizeof(id->mn);
++<<<<<<< HEAD
 +	memset(ctrl->subnqn + off, 0, sizeof(ctrl->subnqn) - off);
++=======
+ 	memset(subsys->subnqn + off, 0, sizeof(subsys->subnqn) - off);
+ }
+ 
+ static void __nvme_release_subsystem(struct nvme_subsystem *subsys)
+ {
+ 	ida_simple_remove(&nvme_subsystems_ida, subsys->instance);
+ 	kfree(subsys);
+ }
+ 
+ static void nvme_release_subsystem(struct device *dev)
+ {
+ 	__nvme_release_subsystem(container_of(dev, struct nvme_subsystem, dev));
+ }
+ 
+ static void nvme_destroy_subsystem(struct kref *ref)
+ {
+ 	struct nvme_subsystem *subsys =
+ 			container_of(ref, struct nvme_subsystem, ref);
+ 
+ 	mutex_lock(&nvme_subsystems_lock);
+ 	list_del(&subsys->entry);
+ 	mutex_unlock(&nvme_subsystems_lock);
+ 
+ 	ida_destroy(&subsys->ns_ida);
+ 	device_del(&subsys->dev);
+ 	put_device(&subsys->dev);
+ }
+ 
+ static void nvme_put_subsystem(struct nvme_subsystem *subsys)
+ {
+ 	kref_put(&subsys->ref, nvme_destroy_subsystem);
+ }
+ 
+ static struct nvme_subsystem *__nvme_find_get_subsystem(const char *subsysnqn)
+ {
+ 	struct nvme_subsystem *subsys;
+ 
+ 	lockdep_assert_held(&nvme_subsystems_lock);
+ 
+ 	list_for_each_entry(subsys, &nvme_subsystems, entry) {
+ 		if (strcmp(subsys->subnqn, subsysnqn))
+ 			continue;
+ 		if (!kref_get_unless_zero(&subsys->ref))
+ 			continue;
+ 		return subsys;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ #define SUBSYS_ATTR_RO(_name, _mode, _show)			\
+ 	struct device_attribute subsys_attr_##_name = \
+ 		__ATTR(_name, _mode, _show, NULL)
+ 
+ static ssize_t nvme_subsys_show_nqn(struct device *dev,
+ 				    struct device_attribute *attr,
+ 				    char *buf)
+ {
+ 	struct nvme_subsystem *subsys =
+ 		container_of(dev, struct nvme_subsystem, dev);
+ 
+ 	return snprintf(buf, PAGE_SIZE, "%s\n", subsys->subnqn);
+ }
+ static SUBSYS_ATTR_RO(subsysnqn, S_IRUGO, nvme_subsys_show_nqn);
+ 
+ #define nvme_subsys_show_str_function(field)				\
+ static ssize_t subsys_##field##_show(struct device *dev,		\
+ 			    struct device_attribute *attr, char *buf)	\
+ {									\
+ 	struct nvme_subsystem *subsys =					\
+ 		container_of(dev, struct nvme_subsystem, dev);		\
+ 	return sprintf(buf, "%.*s\n",					\
+ 		       (int)sizeof(subsys->field), subsys->field);	\
+ }									\
+ static SUBSYS_ATTR_RO(field, S_IRUGO, subsys_##field##_show);
+ 
+ nvme_subsys_show_str_function(model);
+ nvme_subsys_show_str_function(serial);
+ nvme_subsys_show_str_function(firmware_rev);
+ 
+ static struct attribute *nvme_subsys_attrs[] = {
+ 	&subsys_attr_model.attr,
+ 	&subsys_attr_serial.attr,
+ 	&subsys_attr_firmware_rev.attr,
+ 	&subsys_attr_subsysnqn.attr,
+ 	NULL,
+ };
+ 
+ static struct attribute_group nvme_subsys_attrs_group = {
+ 	.attrs = nvme_subsys_attrs,
+ };
+ 
+ static const struct attribute_group *nvme_subsys_attrs_groups[] = {
+ 	&nvme_subsys_attrs_group,
+ 	NULL,
+ };
+ 
+ static int nvme_active_ctrls(struct nvme_subsystem *subsys)
+ {
+ 	int count = 0;
+ 	struct nvme_ctrl *ctrl;
+ 
+ 	mutex_lock(&subsys->lock);
+ 	list_for_each_entry(ctrl, &subsys->ctrls, subsys_entry) {
+ 		if (ctrl->state != NVME_CTRL_DELETING &&
+ 		    ctrl->state != NVME_CTRL_DEAD)
+ 			count++;
+ 	}
+ 	mutex_unlock(&subsys->lock);
+ 
+ 	return count;
+ }
+ 
+ static int nvme_init_subsystem(struct nvme_ctrl *ctrl, struct nvme_id_ctrl *id)
+ {
+ 	struct nvme_subsystem *subsys, *found;
+ 	int ret;
+ 
+ 	subsys = kzalloc(sizeof(*subsys), GFP_KERNEL);
+ 	if (!subsys)
+ 		return -ENOMEM;
+ 	ret = ida_simple_get(&nvme_subsystems_ida, 0, 0, GFP_KERNEL);
+ 	if (ret < 0) {
+ 		kfree(subsys);
+ 		return ret;
+ 	}
+ 	subsys->instance = ret;
+ 	mutex_init(&subsys->lock);
+ 	kref_init(&subsys->ref);
+ 	INIT_LIST_HEAD(&subsys->ctrls);
+ 	INIT_LIST_HEAD(&subsys->nsheads);
+ 	nvme_init_subnqn(subsys, ctrl, id);
+ 	memcpy(subsys->serial, id->sn, sizeof(subsys->serial));
+ 	memcpy(subsys->model, id->mn, sizeof(subsys->model));
+ 	memcpy(subsys->firmware_rev, id->fr, sizeof(subsys->firmware_rev));
+ 	subsys->vendor_id = le16_to_cpu(id->vid);
+ 	subsys->cmic = id->cmic;
+ 
+ 	subsys->dev.class = nvme_subsys_class;
+ 	subsys->dev.release = nvme_release_subsystem;
+ 	subsys->dev.groups = nvme_subsys_attrs_groups;
+ 	dev_set_name(&subsys->dev, "nvme-subsys%d", subsys->instance);
+ 	device_initialize(&subsys->dev);
+ 
+ 	mutex_lock(&nvme_subsystems_lock);
+ 	found = __nvme_find_get_subsystem(subsys->subnqn);
+ 	if (found) {
+ 		/*
+ 		 * Verify that the subsystem actually supports multiple
+ 		 * controllers, else bail out.
+ 		 */
+ 		if (nvme_active_ctrls(found) && !(id->cmic & (1 << 1))) {
+ 			dev_err(ctrl->device,
+ 				"ignoring ctrl due to duplicate subnqn (%s).\n",
+ 				found->subnqn);
+ 			nvme_put_subsystem(found);
+ 			ret = -EINVAL;
+ 			goto out_unlock;
+ 		}
+ 
+ 		__nvme_release_subsystem(subsys);
+ 		subsys = found;
+ 	} else {
+ 		ret = device_add(&subsys->dev);
+ 		if (ret) {
+ 			dev_err(ctrl->device,
+ 				"failed to register subsystem device.\n");
+ 			goto out_unlock;
+ 		}
+ 		ida_init(&subsys->ns_ida);
+ 		list_add_tail(&subsys->entry, &nvme_subsystems);
+ 	}
+ 
+ 	ctrl->subsys = subsys;
+ 	mutex_unlock(&nvme_subsystems_lock);
+ 
+ 	if (sysfs_create_link(&subsys->dev.kobj, &ctrl->device->kobj,
+ 			dev_name(ctrl->device))) {
+ 		dev_err(ctrl->device,
+ 			"failed to create sysfs link from subsystem.\n");
+ 		/* the transport driver will eventually put the subsystem */
+ 		return -EINVAL;
+ 	}
+ 
+ 	mutex_lock(&subsys->lock);
+ 	list_add_tail(&ctrl->subsys_entry, &subsys->ctrls);
+ 	mutex_unlock(&subsys->lock);
+ 
+ 	return 0;
+ 
+ out_unlock:
+ 	mutex_unlock(&nvme_subsystems_lock);
+ 	put_device(&subsys->dev);
+ 	return ret;
+ }
+ 
+ int nvme_get_log_ext(struct nvme_ctrl *ctrl, struct nvme_ns *ns,
+ 		     u8 log_page, void *log,
+ 		     size_t size, u64 offset)
+ {
+ 	struct nvme_command c = { };
+ 	unsigned long dwlen = size / 4 - 1;
+ 
+ 	c.get_log_page.opcode = nvme_admin_get_log_page;
+ 
+ 	if (ns)
+ 		c.get_log_page.nsid = cpu_to_le32(ns->head->ns_id);
+ 	else
+ 		c.get_log_page.nsid = cpu_to_le32(NVME_NSID_ALL);
+ 
+ 	c.get_log_page.lid = log_page;
+ 	c.get_log_page.numdl = cpu_to_le16(dwlen & ((1 << 16) - 1));
+ 	c.get_log_page.numdu = cpu_to_le16(dwlen >> 16);
+ 	c.get_log_page.lpol = cpu_to_le32(lower_32_bits(offset));
+ 	c.get_log_page.lpou = cpu_to_le32(upper_32_bits(offset));
+ 
+ 	return nvme_submit_sync_cmd(ctrl->admin_q, &c, log, size);
+ }
+ 
+ static int nvme_get_log(struct nvme_ctrl *ctrl, u8 log_page, void *log,
+ 			size_t size)
+ {
+ 	return nvme_get_log_ext(ctrl, NULL, log_page, log, size, 0);
+ }
+ 
+ static int nvme_get_effects_log(struct nvme_ctrl *ctrl)
+ {
+ 	int ret;
+ 
+ 	if (!ctrl->effects)
+ 		ctrl->effects = kzalloc(sizeof(*ctrl->effects), GFP_KERNEL);
+ 
+ 	if (!ctrl->effects)
+ 		return 0;
+ 
+ 	ret = nvme_get_log(ctrl, NVME_LOG_CMD_EFFECTS, ctrl->effects,
+ 					sizeof(*ctrl->effects));
+ 	if (ret) {
+ 		kfree(ctrl->effects);
+ 		ctrl->effects = NULL;
+ 	}
+ 	return ret;
++>>>>>>> 7ec6074ff005 (nvme: enforce 64bit offset for nvme_get_log_ext fn)
  }
  
  /*
diff --cc drivers/nvme/host/nvme.h
index 9f38c3e9b7c3,09d47b1937ff..000000000000
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@@ -329,12 -425,104 +329,17 @@@ int nvme_set_queue_count(struct nvme_ct
  void nvme_start_keep_alive(struct nvme_ctrl *ctrl);
  void nvme_stop_keep_alive(struct nvme_ctrl *ctrl);
  int nvme_reset_ctrl(struct nvme_ctrl *ctrl);
 -int nvme_reset_ctrl_sync(struct nvme_ctrl *ctrl);
 -int nvme_delete_ctrl(struct nvme_ctrl *ctrl);
 -int nvme_delete_ctrl_sync(struct nvme_ctrl *ctrl);
  
++<<<<<<< HEAD
 +struct sg_io_hdr;
++=======
+ int nvme_get_log_ext(struct nvme_ctrl *ctrl, struct nvme_ns *ns,
+ 		u8 log_page, void *log, size_t size, u64 offset);
++>>>>>>> 7ec6074ff005 (nvme: enforce 64bit offset for nvme_get_log_ext fn)
  
 -extern const struct attribute_group nvme_ns_id_attr_group;
 -extern const struct block_device_operations nvme_ns_head_ops;
 -
 -#ifdef CONFIG_NVME_MULTIPATH
 -void nvme_failover_req(struct request *req);
 -bool nvme_req_needs_failover(struct request *req, blk_status_t error);
 -void nvme_kick_requeue_lists(struct nvme_ctrl *ctrl);
 -int nvme_mpath_alloc_disk(struct nvme_ctrl *ctrl,struct nvme_ns_head *head);
 -void nvme_mpath_add_disk(struct nvme_ns_head *head);
 -void nvme_mpath_remove_disk(struct nvme_ns_head *head);
 -
 -static inline void nvme_mpath_clear_current_path(struct nvme_ns *ns)
 -{
 -	struct nvme_ns_head *head = ns->head;
 -
 -	if (head && ns == srcu_dereference(head->current_path, &head->srcu))
 -		rcu_assign_pointer(head->current_path, NULL);
 -}
 -struct nvme_ns *nvme_find_path(struct nvme_ns_head *head);
 -
 -static inline void nvme_mpath_check_last_path(struct nvme_ns *ns)
 -{
 -	struct nvme_ns_head *head = ns->head;
 -
 -	if (head->disk && list_empty(&head->list))
 -		kblockd_schedule_work(&head->requeue_work);
 -}
 -
 -#else
 -static inline void nvme_failover_req(struct request *req)
 -{
 -}
 -static inline bool nvme_req_needs_failover(struct request *req,
 -					   blk_status_t error)
 -{
 -	return false;
 -}
 -static inline void nvme_kick_requeue_lists(struct nvme_ctrl *ctrl)
 -{
 -}
 -static inline int nvme_mpath_alloc_disk(struct nvme_ctrl *ctrl,
 -		struct nvme_ns_head *head)
 -{
 -	return 0;
 -}
 -static inline void nvme_mpath_add_disk(struct nvme_ns_head *head)
 -{
 -}
 -static inline void nvme_mpath_remove_disk(struct nvme_ns_head *head)
 -{
 -}
 -static inline void nvme_mpath_clear_current_path(struct nvme_ns *ns)
 -{
 -}
 -static inline void nvme_mpath_check_last_path(struct nvme_ns *ns)
 -{
 -}
 -#endif /* CONFIG_NVME_MULTIPATH */
 -
 -#ifdef CONFIG_NVM
 -void nvme_nvm_update_nvm_info(struct nvme_ns *ns);
 -int nvme_nvm_register(struct nvme_ns *ns, char *disk_name, int node);
 -void nvme_nvm_unregister(struct nvme_ns *ns);
 -int nvme_nvm_register_sysfs(struct nvme_ns *ns);
 -void nvme_nvm_unregister_sysfs(struct nvme_ns *ns);
 -int nvme_nvm_ioctl(struct nvme_ns *ns, unsigned int cmd, unsigned long arg);
 -#else
 -static inline void nvme_nvm_update_nvm_info(struct nvme_ns *ns) {};
 -static inline int nvme_nvm_register(struct nvme_ns *ns, char *disk_name,
 -				    int node)
 -{
 -	return 0;
 -}
 -
 -static inline void nvme_nvm_unregister(struct nvme_ns *ns) {};
 -static inline int nvme_nvm_register_sysfs(struct nvme_ns *ns)
 -{
 -	return 0;
 -}
 -static inline void nvme_nvm_unregister_sysfs(struct nvme_ns *ns) {};
 -static inline int nvme_nvm_ioctl(struct nvme_ns *ns, unsigned int cmd,
 -							unsigned long arg)
 -{
 -	return -ENOTTY;
 -}
 -#endif /* CONFIG_NVM */
 -
 -static inline struct nvme_ns *nvme_get_ns_from_dev(struct device *dev)
 -{
 -	return dev_to_disk(dev)->private_data;
 -}
 +int nvme_sg_io(struct nvme_ns *ns, struct sg_io_hdr __user *u_hdr);
 +int nvme_sg_io32(struct nvme_ns *ns, unsigned long arg);
 +int nvme_sg_get_version_num(int __user *ip);
  
  int __init nvme_core_init(void);
  void nvme_core_exit(void);
* Unmerged path drivers/nvme/host/core.c
* Unmerged path drivers/nvme/host/nvme.h
