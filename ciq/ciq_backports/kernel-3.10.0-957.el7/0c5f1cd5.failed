mlxsw: spectrum_router: Generalize __mlxsw_sp_ipip_entry_update_tunnel()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
commit-author Petr Machata <petrm@mellanox.com>
commit 0c5f1cd5ba8c03567c67910816a7a0fb9fee5746
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/0c5f1cd5.failed

The work that needs to be done to update HW configuration in response to
changes is similar to what __mlxsw_sp_ipip_entry_update_tunnel() already
does, but with a number of twists: each change requires a different
subset of things to happen. Extend the function to support all these
uses, and allow finely-grained configuration of what should happen at
each call through a suite of function arguments.

Publish the updated function to allow use from the spectrum_ipip module.

	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0c5f1cd5ba8c03567c67910816a7a0fb9fee5746)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 366876570ba2,1376a9738b3c..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -1348,51 -1355,100 +1348,137 @@@ static void mlxsw_sp_netdevice_ipip_ol_
  		mlxsw_sp_ipip_entry_ol_down_event(mlxsw_sp, ipip_entry);
  }
  
++<<<<<<< HEAD
 +static int mlxsw_sp_netdevice_ipip_ol_vrf_event(struct mlxsw_sp *mlxsw_sp,
 +						struct net_device *ol_dev)
++=======
+ static void mlxsw_sp_nexthop_rif_update(struct mlxsw_sp *mlxsw_sp,
+ 					struct mlxsw_sp_rif *rif);
+ static int
+ mlxsw_sp_ipip_entry_ol_lb_update(struct mlxsw_sp *mlxsw_sp,
+ 				 struct mlxsw_sp_ipip_entry *ipip_entry,
+ 				 bool keep_encap,
+ 				 struct netlink_ext_ack *extack)
++>>>>>>> 0c5f1cd5ba8c (mlxsw: spectrum_router: Generalize __mlxsw_sp_ipip_entry_update_tunnel())
  {
 -	struct mlxsw_sp_rif_ipip_lb *old_lb_rif = ipip_entry->ol_lb;
 -	struct mlxsw_sp_rif_ipip_lb *new_lb_rif;
 +	struct mlxsw_sp_fib_entry *decap_fib_entry;
 +	struct mlxsw_sp_ipip_entry *ipip_entry;
 +	struct mlxsw_sp_rif_ipip_lb *lb_rif;
 +
++<<<<<<< HEAD
 +	ipip_entry = mlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, ol_dev);
 +	if (!ipip_entry)
 +		return 0;
  
 +	/* When a tunneling device is moved to a different VRF, we need to
 +	 * update the backing loopback. Since RIFs can't be edited, we need to
 +	 * destroy and recreate it. That might create a window of opportunity
 +	 * where RALUE and RATR registers end up referencing a RIF that's
 +	 * already gone. RATRs are handled by the RIF destroy, and to take care
++=======
+ 	new_lb_rif = mlxsw_sp_ipip_ol_ipip_lb_create(mlxsw_sp,
+ 						     ipip_entry->ipipt,
+ 						     ipip_entry->ol_dev,
+ 						     extack);
+ 	if (IS_ERR(new_lb_rif))
+ 		return PTR_ERR(new_lb_rif);
+ 	ipip_entry->ol_lb = new_lb_rif;
+ 
+ 	if (keep_encap) {
+ 		list_splice_init(&old_lb_rif->common.nexthop_list,
+ 				 &new_lb_rif->common.nexthop_list);
+ 		mlxsw_sp_nexthop_rif_update(mlxsw_sp, &new_lb_rif->common);
+ 	}
+ 
+ 	mlxsw_sp_rif_destroy(&old_lb_rif->common);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * Update the offload related to an IPIP entry. This always updates decap, and
+  * in addition to that it also:
+  * @recreate_loopback: recreates the associated loopback RIF
+  * @keep_encap: updates next hops that use the tunnel netdevice. This is only
+  *              relevant when recreate_loopback is true.
+  * @update_nexthops: updates next hops, keeping the current loopback RIF. This
+  *                   is only relevant when recreate_loopback is false.
+  */
+ int __mlxsw_sp_ipip_entry_update_tunnel(struct mlxsw_sp *mlxsw_sp,
+ 					struct mlxsw_sp_ipip_entry *ipip_entry,
+ 					bool recreate_loopback,
+ 					bool keep_encap,
+ 					bool update_nexthops,
+ 					struct netlink_ext_ack *extack)
+ {
+ 	int err;
+ 
+ 	/* RIFs can't be edited, so to update loopback, we need to destroy and
+ 	 * recreate it. That creates a window of opportunity where RALUE and
+ 	 * RATR registers end up referencing a RIF that's already gone. RATRs
+ 	 * are handled in mlxsw_sp_ipip_entry_ol_lb_update(), and to take care
++>>>>>>> 0c5f1cd5ba8c (mlxsw: spectrum_router: Generalize __mlxsw_sp_ipip_entry_update_tunnel())
  	 * of RALUE, demote the decap route back.
  	 */
  	if (ipip_entry->decap_fib_entry)
  		mlxsw_sp_ipip_entry_demote_decap(mlxsw_sp, ipip_entry);
  
++<<<<<<< HEAD
 +	lb_rif = mlxsw_sp_ipip_ol_ipip_lb_create(mlxsw_sp, ipip_entry->ipipt,
 +						 ol_dev);
 +	if (IS_ERR(lb_rif))
 +		return PTR_ERR(lb_rif);
 +	mlxsw_sp_rif_destroy(&ipip_entry->ol_lb->common);
 +	ipip_entry->ol_lb = lb_rif;
++=======
+ 	if (recreate_loopback) {
+ 		err = mlxsw_sp_ipip_entry_ol_lb_update(mlxsw_sp, ipip_entry,
+ 						       keep_encap, extack);
+ 		if (err)
+ 			return err;
+ 	} else if (update_nexthops) {
+ 		mlxsw_sp_nexthop_rif_update(mlxsw_sp,
+ 					    &ipip_entry->ol_lb->common);
+ 	}
++>>>>>>> 0c5f1cd5ba8c (mlxsw: spectrum_router: Generalize __mlxsw_sp_ipip_entry_update_tunnel())
  
 -	if (ipip_entry->ol_dev->flags & IFF_UP)
 -		mlxsw_sp_ipip_entry_ol_up_event(mlxsw_sp, ipip_entry);
 +	if (ol_dev->flags & IFF_UP) {
 +		decap_fib_entry = mlxsw_sp_ipip_entry_find_decap(mlxsw_sp,
 +								 ipip_entry);
 +		if (decap_fib_entry)
 +			mlxsw_sp_ipip_entry_promote_decap(mlxsw_sp, ipip_entry,
 +							  decap_fib_entry);
 +	}
  
  	return 0;
  }
  
 -static int mlxsw_sp_netdevice_ipip_ol_vrf_event(struct mlxsw_sp *mlxsw_sp,
 -						struct net_device *ol_dev,
 -						struct netlink_ext_ack *extack)
 +int
 +mlxsw_sp_netdevice_ipip_ol_event(struct mlxsw_sp *mlxsw_sp,
 +				 struct net_device *ol_dev,
 +				 unsigned long event,
 +				 struct netdev_notifier_changeupper_info *info)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlxsw_sp_ipip_entry *ipip_entry =
+ 		mlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, ol_dev);
+ 
+ 	if (!ipip_entry)
+ 		return 0;
+ 	return __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,
+ 						   true, false, false, extack);
+ }
+ 
+ int mlxsw_sp_netdevice_ipip_ol_event(struct mlxsw_sp *mlxsw_sp,
+ 				     struct net_device *ol_dev,
+ 				     unsigned long event,
+ 				     struct netdev_notifier_info *info)
+ {
+ 	struct netdev_notifier_changeupper_info *chup;
+ 	struct netlink_ext_ack *extack;
+ 
++>>>>>>> 0c5f1cd5ba8c (mlxsw: spectrum_router: Generalize __mlxsw_sp_ipip_entry_update_tunnel())
  	switch (event) {
  	case NETDEV_REGISTER:
  		return mlxsw_sp_netdevice_ipip_ol_reg_event(mlxsw_sp, ol_dev);
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.h b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.h
index 8120b01a9c36..4b8a12a4f493 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.h
@@ -63,6 +63,7 @@ enum mlxsw_sp_rif_counter_dir {
 
 struct mlxsw_sp_neigh_entry;
 struct mlxsw_sp_nexthop;
+struct mlxsw_sp_ipip_entry;
 
 struct mlxsw_sp_rif *mlxsw_sp_rif_by_index(const struct mlxsw_sp *mlxsw_sp,
 					   u16 rif_index);
@@ -103,6 +104,12 @@ mlxsw_sp_neigh_entry_counter_update(struct mlxsw_sp *mlxsw_sp,
 				    struct mlxsw_sp_neigh_entry *neigh_entry,
 				    bool adding);
 bool mlxsw_sp_neigh_ipv6_ignore(struct mlxsw_sp_neigh_entry *neigh_entry);
+int __mlxsw_sp_ipip_entry_update_tunnel(struct mlxsw_sp *mlxsw_sp,
+					struct mlxsw_sp_ipip_entry *ipip_entry,
+					bool recreate_loopback,
+					bool keep_encap,
+					bool update_nexthops,
+					struct netlink_ext_ack *extack);
 struct mlxsw_sp_nexthop *mlxsw_sp_nexthop_next(struct mlxsw_sp_router *router,
 					       struct mlxsw_sp_nexthop *nh);
 bool mlxsw_sp_nexthop_offload(struct mlxsw_sp_nexthop *nh);
