i2c: do not enable fall back to Host Notify by default

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-957.el7
Rebuild_CHGLOG: - [i2c] do not enable fall back to Host Notify by default (Benjamin Tissoires) [1554926]
Rebuild_FUZZ: 95.15%
commit-author Dmitry Torokhov <dmitry.torokhov@gmail.com>
commit 331c34255293cd02d395b7097008b509ba89e60e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-957.el7/331c3425.failed

Falling back unconditionally to HostNotify as primary client's interrupt
breaks some drivers which alter their functionality depending on whether
interrupt is present or not, so let's introduce a board flag telling I2C
core explicitly if we want wired interrupt or HostNotify-based one:
I2C_CLIENT_HOST_NOTIFY.

For DT-based systems we introduce "host-notify" property that we convert
to I2C_CLIENT_HOST_NOTIFY board flag.

	Tested-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
	Acked-by: Pali Roh√°r <pali.rohar@gmail.com>
	Acked-by: Rob Herring <robh@kernel.org>
	Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
(cherry picked from commit 331c34255293cd02d395b7097008b509ba89e60e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/devicetree/bindings/i2c/i2c.txt
#	drivers/i2c/i2c-core.c
diff --cc Documentation/devicetree/bindings/i2c/i2c.txt
index 788dd8a22983,cee9d5055fa2..000000000000
--- a/Documentation/devicetree/bindings/i2c/i2c.txt
+++ b/Documentation/devicetree/bindings/i2c/i2c.txt
@@@ -29,8 -29,50 +29,55 @@@ Optional propertie
  These properties may not be supported by all drivers. However, if a driver
  wants to support one of the below features, it should adapt the bindings below.
  
++<<<<<<< HEAD
 +- clock-frequency	- frequency of bus clock in Hz
 +- wakeup-source		- device can be used as a wakeup source.
++=======
+ - clock-frequency
+ 	frequency of bus clock in Hz.
+ 
+ - i2c-bus
+ 	For I2C adapters that have child nodes that are a mixture of both I2C
+ 	devices and non-I2C devices, the 'i2c-bus' subnode can be used for
+ 	populating I2C devices. If the 'i2c-bus' subnode is present, only
+ 	subnodes of this will be considered as I2C slaves. The properties,
+ 	'#address-cells' and '#size-cells' must be defined under this subnode
+ 	if present.
+ 
+ - i2c-scl-falling-time-ns
+ 	Number of nanoseconds the SCL signal takes to fall; t(f) in the I2C
+ 	specification.
+ 
+ - i2c-scl-internal-delay-ns
+ 	Number of nanoseconds the IP core additionally needs to setup SCL.
+ 
+ - i2c-scl-rising-time-ns
+ 	Number of nanoseconds the SCL signal takes to rise; t(r) in the I2C
+ 	specification.
+ 
+ - i2c-sda-falling-time-ns
+ 	Number of nanoseconds the SDA signal takes to fall; t(f) in the I2C
+ 	specification.
+ 
+ - interrupts
+ 	interrupts used by the device.
+ 
+ - interrupt-names
+ 	"irq" and "wakeup" names are recognized by I2C core, other names are
+ 	left to individual drivers.
+ 
+ - host-notify
+ 	device uses SMBus host notify protocol instead of interrupt line.
+ 
+ - multi-master
+ 	states that there is another master active on this bus. The OS can use
+ 	this information to adapt power management to keep the arbitration awake
+ 	all the time, for example.
+ 
+ - wakeup-source
+ 	device can be used as a wakeup source.
+ 
++>>>>>>> 331c34255293 (i2c: do not enable fall back to Host Notify by default)
  - reg
  	I2C slave addresses
  
@@@ -38,3 -80,15 +85,18 @@@
  	Names of map programmable addresses.
  	It can contain any map needing another address than default one.
  
++<<<<<<< HEAD
++=======
+ Binding may contain optional "interrupts" property, describing interrupts
+ used by the device. I2C core will assign "irq" interrupt (or the very first
+ interrupt if not using interrupt names) as primary interrupt for the slave.
+ 
+ Alternatively, devices supporting SMbus Host Notify, and connected to
+ adapters that support this feature, may use "host-notify" property. I2C
+ core will create a virtual interrupt for Host Notify and assign it as
+ primary interrupt for the slave.
+ 
+ Also, if device is marked as a wakeup source, I2C core will set up "wakeup"
+ interrupt for the device. If "wakeup" interrupt name is not present in the
+ binding, then primary interrupt will be used as wakeup interrupt.
++>>>>>>> 331c34255293 (i2c: do not enable fall back to Host Notify by default)
diff --cc drivers/i2c/i2c-core.c
index ef9500aced53,7b117240f1ea..000000000000
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@@ -885,11 -931,19 +885,26 @@@ static int i2c_device_probe(struct devi
  	if (!client->irq) {
  		int irq = -ENOENT;
  
++<<<<<<< HEAD
 +		if (ACPI_COMPANION(dev))
++=======
+ 		if (client->flags & I2C_CLIENT_HOST_NOTIFY) {
+ 			dev_dbg(dev, "Using Host Notify IRQ\n");
+ 			irq = i2c_smbus_host_notify_to_irq(client);
+ 		} else if (dev->of_node) {
+ 			irq = of_irq_get_byname(dev->of_node, "irq");
+ 			if (irq == -EINVAL || irq == -ENODATA)
+ 				irq = of_irq_get(dev->of_node, 0);
+ 		} else if (ACPI_COMPANION(dev)) {
++>>>>>>> 331c34255293 (i2c: do not enable fall back to Host Notify by default)
  			irq = acpi_dev_gpio_irq_get(ACPI_COMPANION(dev), 0);
 -		}
 +
  		if (irq == -EPROBE_DEFER)
  			return irq;
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> 331c34255293 (i2c: do not enable fall back to Host Notify by default)
  		if (irq < 0)
  			irq = 0;
  
@@@ -1567,10 -1666,72 +1582,75 @@@ static void i2c_scan_static_board_info(
  /* OF support code */
  
  #if IS_ENABLED(CONFIG_OF)
++<<<<<<< HEAD
++=======
+ static struct i2c_client *of_i2c_register_device(struct i2c_adapter *adap,
+ 						 struct device_node *node)
+ {
+ 	struct i2c_client *result;
+ 	struct i2c_board_info info = {};
+ 	struct dev_archdata dev_ad = {};
+ 	const __be32 *addr_be;
+ 	u32 addr;
+ 	int len;
+ 
+ 	dev_dbg(&adap->dev, "of_i2c: register %s\n", node->full_name);
+ 
+ 	if (of_modalias_node(node, info.type, sizeof(info.type)) < 0) {
+ 		dev_err(&adap->dev, "of_i2c: modalias failure on %s\n",
+ 			node->full_name);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	addr_be = of_get_property(node, "reg", &len);
+ 	if (!addr_be || (len < sizeof(*addr_be))) {
+ 		dev_err(&adap->dev, "of_i2c: invalid reg on %s\n",
+ 			node->full_name);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	addr = be32_to_cpup(addr_be);
+ 	if (addr & I2C_TEN_BIT_ADDRESS) {
+ 		addr &= ~I2C_TEN_BIT_ADDRESS;
+ 		info.flags |= I2C_CLIENT_TEN;
+ 	}
+ 
+ 	if (addr & I2C_OWN_SLAVE_ADDRESS) {
+ 		addr &= ~I2C_OWN_SLAVE_ADDRESS;
+ 		info.flags |= I2C_CLIENT_SLAVE;
+ 	}
+ 
+ 	if (i2c_check_addr_validity(addr, info.flags)) {
+ 		dev_err(&adap->dev, "of_i2c: invalid addr=%x on %s\n",
+ 			info.addr, node->full_name);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	info.addr = addr;
+ 	info.of_node = of_node_get(node);
+ 	info.archdata = &dev_ad;
+ 
+ 	if (of_property_read_bool(node, "host-notify"))
+ 		info.flags |= I2C_CLIENT_HOST_NOTIFY;
+ 
+ 	if (of_get_property(node, "wakeup-source", NULL))
+ 		info.flags |= I2C_CLIENT_WAKE;
+ 
+ 	result = i2c_new_device(adap, &info);
+ 	if (result == NULL) {
+ 		dev_err(&adap->dev, "of_i2c: Failure registering %s\n",
+ 			node->full_name);
+ 		of_node_put(node);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 	return result;
+ }
+ 
++>>>>>>> 331c34255293 (i2c: do not enable fall back to Host Notify by default)
  static void of_i2c_register_devices(struct i2c_adapter *adap)
  {
 -	struct device_node *bus, *node;
 -	struct i2c_client *client;
 +	void *result;
 +	struct device_node *node;
  
  	/* Only register child devices if the adapter has a node pointer set */
  	if (!adap->dev.of_node)
* Unmerged path Documentation/devicetree/bindings/i2c/i2c.txt
* Unmerged path drivers/i2c/i2c-core.c
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index 299c7e878502..341ed64f8ebe 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -547,6 +547,7 @@ void i2c_unlock_adapter(struct i2c_adapter *);
 #define I2C_CLIENT_TEN		0x10	/* we have a ten bit chip address */
 					/* Must equal I2C_M_TEN below */
 #define I2C_CLIENT_SLAVE	0x20	/* we are the slave */
+#define I2C_CLIENT_HOST_NOTIFY	0x40	/* We want to use I2C host notify */
 #define I2C_CLIENT_WAKE		0x80	/* for board_info; true iff can wake */
 #define I2C_CLIENT_SCCB		0x9000	/* Use Omnivision SCCB protocol */
 					/* Must match I2C_M_STOP|IGNORE_NAK */
