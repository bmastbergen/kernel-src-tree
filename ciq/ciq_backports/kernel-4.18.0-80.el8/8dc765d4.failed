SCSI: fix queue cleanup race before queue initialization is done

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Ming Lei <ming.lei@redhat.com>
commit 8dc765d438f1e42b3e8227b3b09fad7d73f4ec9a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/8dc765d4.failed

c2856ae2f315d ("blk-mq: quiesce queue before freeing queue") has
already fixed this race, however the implied synchronize_rcu()
in blk_mq_quiesce_queue() can slow down LUN probe a lot, so caused
performance regression.

Then 1311326cf4755c7 ("blk-mq: avoid to synchronize rcu inside blk_cleanup_queue()")
tried to quiesce queue for avoiding unnecessary synchronize_rcu()
only when queue initialization is done, because it is usual to see
lots of inexistent LUNs which need to be probed.

However, turns out it isn't safe to quiesce queue only when queue
initialization is done. Because when one SCSI command is completed,
the user of sending command can be waken up immediately, then the
scsi device may be removed, meantime the run queue in scsi_end_request()
is still in-progress, so kernel panic can be caused.

In Red Hat QE lab, there are several reports about this kind of kernel
panic triggered during kernel booting.

This patch tries to address the issue by grabing one queue usage
counter during freeing one request and the following run queue.

Fixes: 1311326cf4755c7 ("blk-mq: avoid to synchronize rcu inside blk_cleanup_queue()")
	Cc: Andrew Jones <drjones@redhat.com>
	Cc: Bart Van Assche <bart.vanassche@wdc.com>
	Cc: linux-scsi@vger.kernel.org
	Cc: Martin K. Petersen <martin.petersen@oracle.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: James E.J. Bottomley <jejb@linux.vnet.ibm.com>
	Cc: stable <stable@vger.kernel.org>
	Cc: jianchao.wang <jianchao.w.wang@oracle.com>
	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 8dc765d438f1e42b3e8227b3b09fad7d73f4ec9a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_lib.c
diff --cc drivers/scsi/scsi_lib.c
index aefb9c673863,fa6e0c3b3aa6..000000000000
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@@ -601,22 -687,45 +601,54 @@@ static bool scsi_end_request(struct req
  		destroy_rcu_head(&cmd->rcu);
  	}
  
 -	if (req->mq_ctx) {
 -		/*
 -		 * In the MQ case the command gets freed by __blk_mq_end_request,
 -		 * so we have to do all cleanup that depends on it earlier.
 -		 *
 -		 * We also can't kick the queues from irq context, so we
 -		 * will have to defer it to a workqueue.
 -		 */
 -		scsi_mq_uninit_cmd(cmd);
 +	/*
 +	 * In the MQ case the command gets freed by __blk_mq_end_request,
 +	 * so we have to do all cleanup that depends on it earlier.
 +	 *
 +	 * We also can't kick the queues from irq context, so we
 +	 * will have to defer it to a workqueue.
 +	 */
 +	scsi_mq_uninit_cmd(cmd);
 +
++<<<<<<< HEAD
 +	__blk_mq_end_request(req, error);
  
 +	if (scsi_target(sdev)->single_lun ||
 +	    !list_empty(&sdev->host->starved_list))
 +		kblockd_schedule_work(&sdev->requeue_work);
 +	else
 +		blk_mq_run_hw_queues(q, true);
++=======
+ 		/*
+ 		 * queue is still alive, so grab the ref for preventing it
+ 		 * from being cleaned up during running queue.
+ 		 */
+ 		percpu_ref_get(&q->q_usage_counter);
+ 
+ 		__blk_mq_end_request(req, error);
+ 
+ 		if (scsi_target(sdev)->single_lun ||
+ 		    !list_empty(&sdev->host->starved_list))
+ 			kblockd_schedule_work(&sdev->requeue_work);
+ 		else
+ 			blk_mq_run_hw_queues(q, true);
+ 
+ 		percpu_ref_put(&q->q_usage_counter);
+ 	} else {
+ 		unsigned long flags;
+ 
+ 		if (bidi_bytes)
+ 			scsi_release_bidi_buffers(cmd);
+ 		scsi_release_buffers(cmd);
+ 		scsi_put_command(cmd);
+ 
+ 		spin_lock_irqsave(q->queue_lock, flags);
+ 		blk_finish_request(req, error);
+ 		spin_unlock_irqrestore(q->queue_lock, flags);
+ 
+ 		scsi_run_queue(q);
+ 	}
++>>>>>>> 8dc765d438f1 (SCSI: fix queue cleanup race before queue initialization is done)
  
  	put_device(&sdev->sdev_gendev);
  	return false;
diff --git a/block/blk-core.c b/block/blk-core.c
index 05801be43439..903a34fa2f7c 100644
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -792,9 +792,8 @@ void blk_cleanup_queue(struct request_queue *q)
 	 * dispatch may still be in-progress since we dispatch requests
 	 * from more than one contexts.
 	 *
-	 * No need to quiesce queue if it isn't initialized yet since
-	 * blk_freeze_queue() should be enough for cases of passthrough
-	 * request.
+	 * We rely on driver to deal with the race in case that queue
+	 * initialization isn't done.
 	 */
 	if (q->mq_ops && blk_queue_init_done(q))
 		blk_mq_quiesce_queue(q);
* Unmerged path drivers/scsi/scsi_lib.c
