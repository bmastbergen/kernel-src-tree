arm64: Kconfig: Re-jig CONFIG options for 52-bit VA

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Will Deacon <will.deacon@arm.com>
commit 68d23da4373aba76f5300017c4746440f276698e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/68d23da4.failed

Enabling 52-bit VAs for userspace is pretty confusing, since it requires
you to select "48-bit" virtual addressing in the Kconfig.

Rework the logic so that 52-bit user virtual addressing is advertised in
the "Virtual address space size" choice, along with some help text to
describe its interaction with Pointer Authentication. The EXPERT-only
option to force all user mappings to the 52-bit range is then made
available immediately below the VA size selection.

	Signed-off-by: Will Deacon <will.deacon@arm.com>
(cherry picked from commit 68d23da4373aba76f5300017c4746440f276698e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/Kconfig
#	arch/arm64/include/asm/assembler.h
#	arch/arm64/include/asm/pgtable-hwdef.h
diff --cc arch/arm64/Kconfig
index fb2fa81c0abb,905ce1653e82..000000000000
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@@ -1155,6 -1196,20 +1179,23 @@@ config ARM64_RAS_EXT
  	  and access the new registers if the system supports the extension.
  	  Platform RAS features may additionally depend on firmware support.
  
++<<<<<<< HEAD
++=======
+ config ARM64_CNP
+ 	bool "Enable support for Common Not Private (CNP) translations"
+ 	default y
+ 	depends on ARM64_PAN || !ARM64_SW_TTBR0_PAN
+ 	help
+ 	  Common Not Private (CNP) allows translation table entries to
+ 	  be shared between different PEs in the same inner shareable
+ 	  domain, so the hardware can use this fact to optimise the
+ 	  caching of such entries in the TLB.
+ 
+ 	  Selecting this option allows the CNP feature to be detected
+ 	  at runtime, and does not affect PEs that do not implement
+ 	  this feature.
+ 
++>>>>>>> 68d23da4373a (arm64: Kconfig: Re-jig CONFIG options for 52-bit VA)
  endmenu
  
  config ARM64_SVE
diff --cc arch/arm64/include/asm/assembler.h
index 8c8ed20beca9,ce985f13dce5..000000000000
--- a/arch/arm64/include/asm/assembler.h
+++ b/arch/arm64/include/asm/assembler.h
@@@ -516,6 -543,29 +516,32 @@@ USER(\label, ic	ivau, \tmp2)			// inval
  	.endm
  
  /*
++<<<<<<< HEAD
++=======
+  * Offset ttbr1 to allow for 48-bit kernel VAs set with 52-bit PTRS_PER_PGD.
+  * orr is used as it can cover the immediate value (and is idempotent).
+  * In future this may be nop'ed out when dealing with 52-bit kernel VAs.
+  * 	ttbr: Value of ttbr to set, modified.
+  */
+ 	.macro	offset_ttbr1, ttbr
+ #ifdef CONFIG_ARM64_USER_VA_BITS_52
+ 	orr	\ttbr, \ttbr, #TTBR1_BADDR_4852_OFFSET
+ #endif
+ 	.endm
+ 
+ /*
+  * Perform the reverse of offset_ttbr1.
+  * bic is used as it can cover the immediate value and, in future, won't need
+  * to be nop'ed out when dealing with 52-bit kernel VAs.
+  */
+ 	.macro	restore_ttbr1, ttbr
+ #ifdef CONFIG_ARM64_USER_VA_BITS_52
+ 	bic	\ttbr, \ttbr, #TTBR1_BADDR_4852_OFFSET
+ #endif
+ 	.endm
+ 
+ /*
++>>>>>>> 68d23da4373a (arm64: Kconfig: Re-jig CONFIG options for 52-bit VA)
   * Arrange a physical address in a TTBR register, taking care of 52-bit
   * addresses.
   *
diff --cc arch/arm64/include/asm/pgtable-hwdef.h
index fd208eac9f2a,41c808d9168a..000000000000
--- a/arch/arm64/include/asm/pgtable-hwdef.h
+++ b/arch/arm64/include/asm/pgtable-hwdef.h
@@@ -80,7 -80,11 +80,13 @@@
  #define PGDIR_SHIFT		ARM64_HW_PGTABLE_LEVEL_SHIFT(4 - CONFIG_PGTABLE_LEVELS)
  #define PGDIR_SIZE		(_AC(1, UL) << PGDIR_SHIFT)
  #define PGDIR_MASK		(~(PGDIR_SIZE-1))
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARM64_USER_VA_BITS_52
+ #define PTRS_PER_PGD		(1 << (52 - PGDIR_SHIFT))
+ #else
++>>>>>>> 68d23da4373a (arm64: Kconfig: Re-jig CONFIG options for 52-bit VA)
  #define PTRS_PER_PGD		(1 << (VA_BITS - PGDIR_SHIFT))
 -#endif
  
  /*
   * Section address mask and size definitions.
@@@ -304,4 -310,10 +310,13 @@@
  #define TTBR_BADDR_MASK_52	(((UL(1) << 46) - 1) << 2)
  #endif
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARM64_USER_VA_BITS_52
+ /* Must be at least 64-byte aligned to prevent corruption of the TTBR */
+ #define TTBR1_BADDR_4852_OFFSET	(((UL(1) << (52 - PGDIR_SHIFT)) - \
+ 				 (UL(1) << (48 - PGDIR_SHIFT))) * 8)
+ #endif
+ 
++>>>>>>> 68d23da4373a (arm64: Kconfig: Re-jig CONFIG options for 52-bit VA)
  #endif
* Unmerged path arch/arm64/Kconfig
* Unmerged path arch/arm64/include/asm/assembler.h
diff --git a/arch/arm64/include/asm/mmu_context.h b/arch/arm64/include/asm/mmu_context.h
index e96e10fa7887..0992d4fa59d6 100644
--- a/arch/arm64/include/asm/mmu_context.h
+++ b/arch/arm64/include/asm/mmu_context.h
@@ -74,7 +74,7 @@ extern u64 idmap_ptrs_per_pgd;
 
 static inline bool __cpu_uses_extended_idmap(void)
 {
-	if (IS_ENABLED(CONFIG_ARM64_52BIT_VA))
+	if (IS_ENABLED(CONFIG_ARM64_USER_VA_BITS_52))
 		return false;
 
 	return unlikely(idmap_t0sz != TCR_T0SZ(VA_BITS));
* Unmerged path arch/arm64/include/asm/pgtable-hwdef.h
diff --git a/arch/arm64/include/asm/processor.h b/arch/arm64/include/asm/processor.h
index 516c433ecbba..1b35822328a5 100644
--- a/arch/arm64/include/asm/processor.h
+++ b/arch/arm64/include/asm/processor.h
@@ -20,11 +20,11 @@
 #define __ASM_PROCESSOR_H
 
 #define KERNEL_DS		UL(-1)
-#ifdef CONFIG_ARM64_52BIT_VA
+#ifdef CONFIG_ARM64_USER_VA_BITS_52
 #define USER_DS			((UL(1) << 52) - 1)
 #else
 #define USER_DS			((UL(1) << VA_BITS) - 1)
-#endif /* CONFIG_ARM64_52BIT_VA */
+#endif /* CONFIG_ARM64_USER_VA_BITS_52 */
 
 #ifndef __ASSEMBLY__
 
diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S
index 33fc71ac0c0a..c3cf4e220068 100644
--- a/arch/arm64/kernel/head.S
+++ b/arch/arm64/kernel/head.S
@@ -318,7 +318,7 @@ __create_page_tables:
 	adrp	x0, idmap_pg_dir
 	adrp	x3, __idmap_text_start		// __pa(__idmap_text_start)
 
-#ifdef CONFIG_ARM64_52BIT_VA
+#ifdef CONFIG_ARM64_USER_VA_BITS_52
 	mrs_s	x6, SYS_ID_AA64MMFR2_EL1
 	and	x6, x6, #(0xf << ID_AA64MMFR2_LVA_SHIFT)
 	mov	x5, #52
@@ -799,7 +799,7 @@ ENTRY(__enable_mmu)
 ENDPROC(__enable_mmu)
 
 ENTRY(__cpu_secondary_check52bitva)
-#ifdef CONFIG_ARM64_52BIT_VA
+#ifdef CONFIG_ARM64_USER_VA_BITS_52
 	ldr_l	x0, vabits_user
 	cmp	x0, #52
 	b.ne	2f
diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c
index 907649d24c9f..1a7db8c0782f 100644
--- a/arch/arm64/kernel/smp.c
+++ b/arch/arm64/kernel/smp.c
@@ -139,7 +139,7 @@ int __cpu_up(unsigned int cpu, struct task_struct *idle)
 		if (!cpu_online(cpu)) {
 			pr_crit("CPU%u: failed to come online\n", cpu);
 
-			if (IS_ENABLED(CONFIG_ARM64_52BIT_VA) && va52mismatch)
+			if (IS_ENABLED(CONFIG_ARM64_USER_VA_BITS_52) && va52mismatch)
 				pr_crit("CPU%u: does not support 52-bit VAs\n", cpu);
 
 			ret = -EIO;
diff --git a/arch/arm64/mm/proc.S b/arch/arm64/mm/proc.S
index bd01506a2555..11ad72ccb564 100644
--- a/arch/arm64/mm/proc.S
+++ b/arch/arm64/mm/proc.S
@@ -442,8 +442,8 @@ ENTRY(__cpu_setup)
 			TCR_TG_FLAGS | TCR_KASLR_FLAGS | TCR_ASID16 | \
 			TCR_TBI0 | TCR_A1
 
-#ifdef CONFIG_ARM64_52BIT_VA
-	ldr_l 		x9, vabits_user
+#ifdef CONFIG_ARM64_USER_VA_BITS_52
+	ldr_l		x9, vabits_user
 	sub		x9, xzr, x9
 	add		x9, x9, #64
 #else
