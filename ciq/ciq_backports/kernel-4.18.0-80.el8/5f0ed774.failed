block: sum requests in the plug structure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit 5f0ed774ed2914decfd397569fface997532e94d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/5f0ed774.failed

This isn't exactly the same as the previous count, as it includes
requests for all devices. But that really doesn't matter, if we have
more than the threshold (16) queued up, flush it. It's not worth it
to have an expensive list loop for this.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 5f0ed774ed2914decfd397569fface997532e94d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-core.c
diff --cc block/blk-core.c
index 7df0c1244abd,be9233400314..000000000000
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@@ -1851,12 -745,8 +1850,11 @@@ bool blk_attempt_plug_merge(struct requ
  	plug = current->plug;
  	if (!plug)
  		return false;
- 	*request_count = 0;
  
 -	plug_list = &plug->mq_list;
 +	if (q->mq_ops)
 +		plug_list = &plug->mq_list;
 +	else
 +		plug_list = &plug->list;
  
  	list_for_each_entry_reverse(rq, plug_list, queuelist) {
  		bool merged = false;
@@@ -1896,34 -784,8 +1892,37 @@@
  	return false;
  }
  
++<<<<<<< HEAD
 +unsigned int blk_plug_queued_count(struct request_queue *q)
 +{
 +	struct blk_plug *plug;
 +	struct request *rq;
 +	struct list_head *plug_list;
 +	unsigned int ret = 0;
 +
 +	plug = current->plug;
 +	if (!plug)
 +		goto out;
 +
 +	if (q->mq_ops)
 +		plug_list = &plug->mq_list;
 +	else
 +		plug_list = &plug->list;
 +
 +	list_for_each_entry(rq, plug_list, queuelist) {
 +		if (rq->q == q)
 +			ret++;
 +	}
 +out:
 +	return ret;
 +}
 +
++=======
++>>>>>>> 5f0ed774ed29 (block: sum requests in the plug structure)
  void blk_init_request_from_bio(struct request *req, struct bio *bio)
  {
 +	struct io_context *ioc = rq_ioc(bio);
 +
  	if (bio->bi_opf & REQ_RAHEAD)
  		req->cmd_flags |= REQ_FAILFAST_MASK;
  
@@@ -3522,9 -1777,10 +3521,11 @@@ void blk_start_plug(struct blk_plug *pl
  	if (tsk->plug)
  		return;
  
 +	INIT_LIST_HEAD(&plug->list);
  	INIT_LIST_HEAD(&plug->mq_list);
  	INIT_LIST_HEAD(&plug->cb_list);
+ 	plug->rq_count = 0;
+ 
  	/*
  	 * Store ordering should not be needed here, since a potential
  	 * preempt will imply a full memory barrier
* Unmerged path block/blk-core.c
diff --git a/block/blk-mq.c b/block/blk-mq.c
index c70006acef1d..795bf58bf5e2 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -1664,6 +1664,7 @@ void blk_mq_flush_plug_list(struct blk_plug *plug, bool from_schedule)
 	unsigned int depth;
 
 	list_splice_init(&plug->mq_list, &list);
+	plug->rq_count = 0;
 
 	list_sort(NULL, &list, plug_rq_cmp);
 
@@ -1860,7 +1861,6 @@ static blk_qc_t blk_mq_make_request(struct request_queue *q, struct bio *bio)
 	const int is_flush_fua = op_is_flush(bio->bi_opf);
 	struct blk_mq_alloc_data data = { .flags = 0 };
 	struct request *rq;
-	unsigned int request_count = 0;
 	struct blk_plug *plug;
 	struct request *same_queue_rq = NULL;
 	blk_qc_t cookie;
@@ -1873,7 +1873,7 @@ static blk_qc_t blk_mq_make_request(struct request_queue *q, struct bio *bio)
 		return BLK_QC_T_NONE;
 
 	if (!is_flush_fua && !blk_queue_nomerges(q) &&
-	    blk_attempt_plug_merge(q, bio, &request_count, &same_queue_rq))
+	    blk_attempt_plug_merge(q, bio, &same_queue_rq))
 		return BLK_QC_T_NONE;
 
 	if (blk_mq_sched_bio_merge(q, bio))
@@ -1904,20 +1904,12 @@ static blk_qc_t blk_mq_make_request(struct request_queue *q, struct bio *bio)
 		blk_insert_flush(rq);
 		blk_mq_run_hw_queue(data.hctx, true);
 	} else if (plug && q->nr_hw_queues == 1) {
+		unsigned int request_count = plug->rq_count;
 		struct request *last = NULL;
 
 		blk_mq_put_ctx(data.ctx);
 		blk_mq_bio_to_request(rq, bio);
 
-		/*
-		 * @request_count may become stale because of schedule
-		 * out, so check the list again.
-		 */
-		if (list_empty(&plug->mq_list))
-			request_count = 0;
-		else if (blk_queue_nomerges(q))
-			request_count = blk_plug_queued_count(q);
-
 		if (!request_count)
 			trace_block_plug(q);
 		else
@@ -1930,6 +1922,7 @@ static blk_qc_t blk_mq_make_request(struct request_queue *q, struct bio *bio)
 		}
 
 		list_add_tail(&rq->queuelist, &plug->mq_list);
+		plug->rq_count++;
 	} else if (plug && !blk_queue_nomerges(q)) {
 		blk_mq_bio_to_request(rq, bio);
 
@@ -1945,6 +1938,7 @@ static blk_qc_t blk_mq_make_request(struct request_queue *q, struct bio *bio)
 		if (same_queue_rq)
 			list_del_init(&same_queue_rq->queuelist);
 		list_add_tail(&rq->queuelist, &plug->mq_list);
+		plug->rq_count++;
 
 		blk_mq_put_ctx(data.ctx);
 
diff --git a/block/blk.h b/block/blk.h
index fc4461de2d5b..0c02c362aa40 100644
--- a/block/blk.h
+++ b/block/blk.h
@@ -245,9 +245,7 @@ bool bio_attempt_back_merge(struct request_queue *q, struct request *req,
 bool bio_attempt_discard_merge(struct request_queue *q, struct request *req,
 		struct bio *bio);
 bool blk_attempt_plug_merge(struct request_queue *q, struct bio *bio,
-			    unsigned int *request_count,
 			    struct request **same_queue_rq);
-unsigned int blk_plug_queued_count(struct request_queue *q);
 
 void blk_account_io_start(struct request *req, bool new_io);
 void blk_account_io_completion(struct request *req, unsigned int bytes);
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index d890005b9f66..6cdc8b2cbce2 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -1263,6 +1263,7 @@ struct blk_plug {
 	struct list_head list; /* requests */
 	struct list_head mq_list; /* blk-mq requests */
 	struct list_head cb_list; /* md requires an unplug callback */
+	unsigned short rq_count;
 };
 #define BLK_MAX_REQUEST_COUNT 16
 #define BLK_PLUG_FLUSH_SIZE (128 * 1024)
