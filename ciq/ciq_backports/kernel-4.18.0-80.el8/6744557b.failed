vfs: allow some remap flags to be passed to vfs_clone_file_range

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 6744557b53a2b710ebce3736a5c27a0119685fcc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/6744557b.failed

In overlayfs, ovl_remap_file_range calls vfs_clone_file_range on the
lower filesystem's inode, passing through whatever remap flags it got
from its caller.  Since vfs_copy_file_range first tries a filesystem's
remap function with REMAP_FILE_CAN_SHORTEN, this can get passed through
to the second vfs_copy_file_range call, and this isn't an issue.
Change the WARN_ON to look only for the DEDUP flag.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 6744557b53a2b710ebce3736a5c27a0119685fcc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/read_write.c
diff --cc fs/read_write.c
index 050fc909a788,58f30537c47a..000000000000
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@@ -1978,12 -1841,200 +1978,196 @@@ int vfs_dedupe_file_range_compare(struc
  out_error:
  	return error;
  }
 +EXPORT_SYMBOL(vfs_dedupe_file_range_compare);
  
 -/*
 - * Check that the two inodes are eligible for cloning, the ranges make
 - * sense, and then flush all dirty data.  Caller must ensure that the
 - * inodes have been locked against any other modifications.
 - *
 - * If there's an error, then the usual negative error code is returned.
 - * Otherwise returns 0 with *len set to the request length.
 - */
 -int generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,
 -				  struct file *file_out, loff_t pos_out,
 -				  loff_t *len, unsigned int remap_flags)
 +int vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,
 +			      struct file *dst_file, loff_t dst_pos, u64 len)
  {
++<<<<<<< HEAD
 +	s64 ret;
++=======
+ 	struct inode *inode_in = file_inode(file_in);
+ 	struct inode *inode_out = file_inode(file_out);
+ 	bool same_inode = (inode_in == inode_out);
+ 	int ret;
+ 
+ 	/* Don't touch certain kinds of inodes */
+ 	if (IS_IMMUTABLE(inode_out))
+ 		return -EPERM;
+ 
+ 	if (IS_SWAPFILE(inode_in) || IS_SWAPFILE(inode_out))
+ 		return -ETXTBSY;
+ 
+ 	/* Don't reflink dirs, pipes, sockets... */
+ 	if (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))
+ 		return -EISDIR;
+ 	if (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))
+ 		return -EINVAL;
+ 
+ 	/* Zero length dedupe exits immediately; reflink goes to EOF. */
+ 	if (*len == 0) {
+ 		loff_t isize = i_size_read(inode_in);
+ 
+ 		if ((remap_flags & REMAP_FILE_DEDUP) || pos_in == isize)
+ 			return 0;
+ 		if (pos_in > isize)
+ 			return -EINVAL;
+ 		*len = isize - pos_in;
+ 		if (*len == 0)
+ 			return 0;
+ 	}
+ 
+ 	/* Check that we don't violate system file offset limits. */
+ 	ret = generic_remap_checks(file_in, pos_in, file_out, pos_out, len,
+ 			remap_flags);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Wait for the completion of any pending IOs on both files */
+ 	inode_dio_wait(inode_in);
+ 	if (!same_inode)
+ 		inode_dio_wait(inode_out);
+ 
+ 	ret = filemap_write_and_wait_range(inode_in->i_mapping,
+ 			pos_in, pos_in + *len - 1);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = filemap_write_and_wait_range(inode_out->i_mapping,
+ 			pos_out, pos_out + *len - 1);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/*
+ 	 * Check that the extents are the same.
+ 	 */
+ 	if (remap_flags & REMAP_FILE_DEDUP) {
+ 		bool		is_same = false;
+ 
+ 		ret = vfs_dedupe_file_range_compare(inode_in, pos_in,
+ 				inode_out, pos_out, *len, &is_same);
+ 		if (ret)
+ 			return ret;
+ 		if (!is_same)
+ 			return -EBADE;
+ 	}
+ 
+ 	ret = generic_remap_check_len(inode_in, inode_out, pos_out, len,
+ 			remap_flags);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* If can't alter the file contents, we're done. */
+ 	if (!(remap_flags & REMAP_FILE_DEDUP)) {
+ 		/* Update the timestamps, since we can alter file contents. */
+ 		if (!(file_out->f_mode & FMODE_NOCMTIME)) {
+ 			ret = file_update_time(file_out);
+ 			if (ret)
+ 				return ret;
+ 		}
+ 
+ 		/*
+ 		 * Clear the security bits if the process is not being run by
+ 		 * root.  This keeps people from modifying setuid and setgid
+ 		 * binaries.
+ 		 */
+ 		ret = file_remove_privs(file_out);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(generic_remap_file_range_prep);
+ 
+ loff_t do_clone_file_range(struct file *file_in, loff_t pos_in,
+ 			   struct file *file_out, loff_t pos_out,
+ 			   loff_t len, unsigned int remap_flags)
+ {
+ 	struct inode *inode_in = file_inode(file_in);
+ 	struct inode *inode_out = file_inode(file_out);
+ 	loff_t ret;
+ 
+ 	WARN_ON_ONCE(remap_flags & REMAP_FILE_DEDUP);
+ 
+ 	if (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))
+ 		return -EISDIR;
+ 	if (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * FICLONE/FICLONERANGE ioctls enforce that src and dest files are on
+ 	 * the same mount. Practically, they only need to be on the same file
+ 	 * system.
+ 	 */
+ 	if (inode_in->i_sb != inode_out->i_sb)
+ 		return -EXDEV;
+ 
+ 	if (!(file_in->f_mode & FMODE_READ) ||
+ 	    !(file_out->f_mode & FMODE_WRITE) ||
+ 	    (file_out->f_flags & O_APPEND))
+ 		return -EBADF;
+ 
+ 	if (!file_in->f_op->remap_file_range)
+ 		return -EOPNOTSUPP;
+ 
+ 	ret = remap_verify_area(file_in, pos_in, len, false);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = remap_verify_area(file_out, pos_out, len, true);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = file_in->f_op->remap_file_range(file_in, pos_in,
+ 			file_out, pos_out, len, remap_flags);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	fsnotify_access(file_in);
+ 	fsnotify_modify(file_out);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(do_clone_file_range);
+ 
+ loff_t vfs_clone_file_range(struct file *file_in, loff_t pos_in,
+ 			    struct file *file_out, loff_t pos_out,
+ 			    loff_t len, unsigned int remap_flags)
+ {
+ 	loff_t ret;
+ 
+ 	file_start_write(file_out);
+ 	ret = do_clone_file_range(file_in, pos_in, file_out, pos_out, len,
+ 				  remap_flags);
+ 	file_end_write(file_out);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL(vfs_clone_file_range);
+ 
+ /* Check whether we are allowed to dedupe the destination file */
+ static bool allow_file_dedupe(struct file *file)
+ {
+ 	if (capable(CAP_SYS_ADMIN))
+ 		return true;
+ 	if (file->f_mode & FMODE_WRITE)
+ 		return true;
+ 	if (uid_eq(current_fsuid(), file_inode(file)->i_uid))
+ 		return true;
+ 	if (!inode_permission(file_inode(file), MAY_WRITE))
+ 		return true;
+ 	return false;
+ }
+ 
+ loff_t vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,
+ 				 struct file *dst_file, loff_t dst_pos,
+ 				 loff_t len, unsigned int remap_flags)
+ {
+ 	loff_t ret;
+ 
+ 	WARN_ON_ONCE(remap_flags & ~(REMAP_FILE_DEDUP |
+ 				     REMAP_FILE_CAN_SHORTEN));
++>>>>>>> 6744557b53a2 (vfs: allow some remap flags to be passed to vfs_clone_file_range)
  
  	ret = mnt_want_write_file(dst_file);
  	if (ret)
* Unmerged path fs/read_write.c
