scsi: megaraid_sas: Fix Ventura series based checks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
commit 630d42b70f5d5cdac94dc5d080fc6d389076bf6e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/630d42b7.failed

In preparation for the new Aero series adapter type, all the places where
we check adapter type for Ventura series needs to include any later adapter
types.

	Signed-off-by: Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 630d42b70f5d5cdac94dc5d080fc6d389076bf6e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas_base.c
#	drivers/scsi/megaraid/megaraid_sas_fusion.c
diff --cc drivers/scsi/megaraid/megaraid_sas_base.c
index ff5c2d50b7b6,975c8a384ad1..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@@ -5302,10 -5398,10 +5302,17 @@@ static int megasas_init_fw(struct megas
  
  	fusion = instance->ctrl_context;
  
++<<<<<<< HEAD
 +	if (instance->adapter_type == VENTURA_SERIES) {
 +		scratch_pad_3 =
 +			readl(&instance->reg_set->outbound_scratch_pad_3);
 +		instance->max_raid_mapsize = ((scratch_pad_3 >>
++=======
+ 	if (instance->adapter_type >= VENTURA_SERIES) {
+ 		scratch_pad_2 =
+ 			readl(&instance->reg_set->outbound_scratch_pad_2);
+ 		instance->max_raid_mapsize = ((scratch_pad_2 >>
++>>>>>>> 630d42b70f5d (scsi: megaraid_sas: Fix Ventura series based checks)
  			MR_MAX_RAID_MAP_SIZE_OFFSET_SHIFT) &
  			MR_MAX_RAID_MAP_SIZE_MASK);
  	}
@@@ -5408,13 -5521,13 +5415,20 @@@
  	if (instance->instancet->init_adapter(instance))
  		goto fail_init_adapter;
  
++<<<<<<< HEAD
 +	if (instance->adapter_type == VENTURA_SERIES) {
 +		scratch_pad_4 =
 +			readl(&instance->reg_set->outbound_scratch_pad_4);
 +		if ((scratch_pad_4 & MR_NVME_PAGE_SIZE_MASK) >=
++=======
+ 	if (instance->adapter_type >= VENTURA_SERIES) {
+ 		scratch_pad_3 =
+ 			readl(&instance->reg_set->outbound_scratch_pad_3);
+ 		if ((scratch_pad_3 & MR_NVME_PAGE_SIZE_MASK) >=
++>>>>>>> 630d42b70f5d (scsi: megaraid_sas: Fix Ventura series based checks)
  			MR_DEFAULT_NVME_PAGE_SHIFT)
  			instance->nvme_page_size =
 -				(1 << (scratch_pad_3 & MR_NVME_PAGE_SIZE_MASK));
 +				(1 << (scratch_pad_4 & MR_NVME_PAGE_SIZE_MASK));
  
  		dev_info(&instance->pdev->dev,
  			 "NVME page size\t: (%d)\n", instance->nvme_page_size);
@@@ -6043,10 -6173,10 +6057,10 @@@ megasas_set_dma_mask(struct megasas_ins
  {
  	u64 consistent_mask;
  	struct pci_dev *pdev;
 -	u32 scratch_pad_1;
 +	u32 scratch_pad_2;
  
  	pdev = instance->pdev;
- 	consistent_mask = (instance->adapter_type == VENTURA_SERIES) ?
+ 	consistent_mask = (instance->adapter_type >= VENTURA_SERIES) ?
  				DMA_BIT_MASK(64) : DMA_BIT_MASK(32);
  
  	if (IS_DMA64) {
diff --cc drivers/scsi/megaraid/megaraid_sas_fusion.c
index c7f95bace353,765633cd182c..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@@ -2643,9 -2721,7 +2643,13 @@@ megasas_build_ldio_fusion(struct megasa
  	cmd->request_desc->SCSIIO.MSIxIndex =
  		instance->reply_map[raw_smp_processor_id()];
  
++<<<<<<< HEAD
 +	praid_context = &io_request->RaidContext;
 +
 +	if (instance->adapter_type == VENTURA_SERIES) {
++=======
+ 	if (instance->adapter_type >= VENTURA_SERIES) {
++>>>>>>> 630d42b70f5d (scsi: megaraid_sas: Fix Ventura series based checks)
  		/* FP for Optimal raid level 1.
  		 * All large RAID-1 writes (> 32 KiB, both WT and WB modes)
  		 * are built by the driver as LD I/Os.
@@@ -2708,20 -2783,16 +2712,27 @@@
  				cmd->request_desc->SCSIIO.RequestFlags =
  					(MEGASAS_REQ_DESCRIPT_FLAGS_NO_LOCK <<
  					MEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);
 -			rctx->type = MPI2_TYPE_CUDA;
 -			rctx->nseg = 0x1;
 +			io_request->RaidContext.raid_context.type
 +				= MPI2_TYPE_CUDA;
 +			io_request->RaidContext.raid_context.nseg = 0x1;
  			io_request->IoFlags |= cpu_to_le16(MPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH);
 -			rctx->reg_lock_flags |=
 +			io_request->RaidContext.raid_context.reg_lock_flags |=
  			  (MR_RL_FLAGS_GRANT_DESTINATION_CUDA |
  			   MR_RL_FLAGS_SEQ_NUM_ENABLE);
++<<<<<<< HEAD
 +		} else if (instance->adapter_type == VENTURA_SERIES) {
 +			io_request->RaidContext.raid_context_g35.nseg_type |=
 +						(1 << RAID_CONTEXT_NSEG_SHIFT);
 +			io_request->RaidContext.raid_context_g35.nseg_type |=
 +						(MPI2_TYPE_CUDA << RAID_CONTEXT_TYPE_SHIFT);
 +			io_request->RaidContext.raid_context_g35.routing_flags |=
 +						(1 << MR_RAID_CTX_ROUTINGFLAGS_SQN_SHIFT);
++=======
+ 		} else if (instance->adapter_type >= VENTURA_SERIES) {
+ 			rctx_g35->nseg_type |= (1 << RAID_CONTEXT_NSEG_SHIFT);
+ 			rctx_g35->nseg_type |= (MPI2_TYPE_CUDA << RAID_CONTEXT_TYPE_SHIFT);
+ 			rctx_g35->routing_flags |= (1 << MR_RAID_CTX_ROUTINGFLAGS_SQN_SHIFT);
++>>>>>>> 630d42b70f5d (scsi: megaraid_sas: Fix Ventura series based checks)
  			io_request->IoFlags |=
  				cpu_to_le16(MPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH);
  		}
@@@ -2734,12 -2805,10 +2745,17 @@@
  					&io_info, local_map_ptr);
  			scp->SCp.Status |= MEGASAS_LOAD_BALANCE_FLAG;
  			cmd->pd_r1_lb = io_info.pd_after_lb;
++<<<<<<< HEAD
 +			if (instance->adapter_type == VENTURA_SERIES)
 +				io_request->RaidContext.raid_context_g35.span_arm
 +					= io_info.span_arm;
++=======
+ 			if (instance->adapter_type >= VENTURA_SERIES)
+ 				rctx_g35->span_arm = io_info.span_arm;
++>>>>>>> 630d42b70f5d (scsi: megaraid_sas: Fix Ventura series based checks)
  			else
 -				rctx->span_arm = io_info.span_arm;
 +				io_request->RaidContext.raid_context.span_arm
 +					= io_info.span_arm;
  
  		} else
  			scp->SCp.Status &= ~MEGASAS_LOAD_BALANCE_FLAG;
@@@ -2774,19 -2842,15 +2790,28 @@@
  				cmd->request_desc->SCSIIO.RequestFlags =
  					(MEGASAS_REQ_DESCRIPT_FLAGS_NO_LOCK <<
  					MEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);
 -			rctx->type = MPI2_TYPE_CUDA;
 -			rctx->reg_lock_flags |=
 +			io_request->RaidContext.raid_context.type
 +				= MPI2_TYPE_CUDA;
 +			io_request->RaidContext.raid_context.reg_lock_flags |=
  				(MR_RL_FLAGS_GRANT_DESTINATION_CPU0 |
++<<<<<<< HEAD
 +				 MR_RL_FLAGS_SEQ_NUM_ENABLE);
 +			io_request->RaidContext.raid_context.nseg = 0x1;
 +		} else if (instance->adapter_type == VENTURA_SERIES) {
 +			io_request->RaidContext.raid_context_g35.routing_flags |=
 +					(1 << MR_RAID_CTX_ROUTINGFLAGS_SQN_SHIFT);
 +			io_request->RaidContext.raid_context_g35.nseg_type |=
 +					(1 << RAID_CONTEXT_NSEG_SHIFT);
 +			io_request->RaidContext.raid_context_g35.nseg_type |=
 +					(MPI2_TYPE_CUDA << RAID_CONTEXT_TYPE_SHIFT);
++=======
+ 					MR_RL_FLAGS_SEQ_NUM_ENABLE);
+ 			rctx->nseg = 0x1;
+ 		} else if (instance->adapter_type >= VENTURA_SERIES) {
+ 			rctx_g35->routing_flags |= (1 << MR_RAID_CTX_ROUTINGFLAGS_SQN_SHIFT);
+ 			rctx_g35->nseg_type |= (1 << RAID_CONTEXT_NSEG_SHIFT);
+ 			rctx_g35->nseg_type |= (MPI2_TYPE_CUDA << RAID_CONTEXT_TYPE_SHIFT);
++>>>>>>> 630d42b70f5d (scsi: megaraid_sas: Fix Ventura series based checks)
  		}
  		io_request->Function = MEGASAS_MPI2_FUNCTION_LD_IO_REQUEST;
  		io_request->DevHandle = cpu_to_le16(device_id);
* Unmerged path drivers/scsi/megaraid/megaraid_sas_base.c
diff --git a/drivers/scsi/megaraid/megaraid_sas_fp.c b/drivers/scsi/megaraid/megaraid_sas_fp.c
index 59ecbb3b53b5..641567259683 100644
--- a/drivers/scsi/megaraid/megaraid_sas_fp.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fp.c
@@ -745,7 +745,7 @@ static u8 mr_spanset_get_phy_params(struct megasas_instance *instance, u32 ld,
 		*pDevHandle = MR_PdDevHandleGet(pd, map);
 		*pPdInterface = MR_PdInterfaceTypeGet(pd, map);
 		/* get second pd also for raid 1/10 fast path writes*/
-		if ((instance->adapter_type == VENTURA_SERIES) &&
+		if ((instance->adapter_type >= VENTURA_SERIES) &&
 		    (raid->level == 1) &&
 		    !io_info->isRead) {
 			r1_alt_pd = MR_ArPdGet(arRef, physArm + 1, map);
@@ -770,7 +770,7 @@ static u8 mr_spanset_get_phy_params(struct megasas_instance *instance, u32 ld,
 	}
 
 	*pdBlock += stripRef + le64_to_cpu(MR_LdSpanPtrGet(ld, span, map)->startBlk);
-	if (instance->adapter_type == VENTURA_SERIES) {
+	if (instance->adapter_type >= VENTURA_SERIES) {
 		((struct RAID_CONTEXT_G35 *)pRAID_Context)->span_arm =
 			(span << RAID_CTX_SPANARM_SPAN_SHIFT) | physArm;
 		io_info->span_arm =
@@ -861,7 +861,7 @@ u8 MR_GetPhyParams(struct megasas_instance *instance, u32 ld, u64 stripRow,
 		*pDevHandle = MR_PdDevHandleGet(pd, map);
 		*pPdInterface = MR_PdInterfaceTypeGet(pd, map);
 		/* get second pd also for raid 1/10 fast path writes*/
-		if ((instance->adapter_type == VENTURA_SERIES) &&
+		if ((instance->adapter_type >= VENTURA_SERIES) &&
 		    (raid->level == 1) &&
 		    !io_info->isRead) {
 			r1_alt_pd = MR_ArPdGet(arRef, physArm + 1, map);
@@ -888,7 +888,7 @@ u8 MR_GetPhyParams(struct megasas_instance *instance, u32 ld, u64 stripRow,
 	}
 
 	*pdBlock += stripRef + le64_to_cpu(MR_LdSpanPtrGet(ld, span, map)->startBlk);
-	if (instance->adapter_type == VENTURA_SERIES) {
+	if (instance->adapter_type >= VENTURA_SERIES) {
 		((struct RAID_CONTEXT_G35 *)pRAID_Context)->span_arm =
 				(span << RAID_CTX_SPANARM_SPAN_SHIFT) | physArm;
 		io_info->span_arm =
* Unmerged path drivers/scsi/megaraid/megaraid_sas_fusion.c
