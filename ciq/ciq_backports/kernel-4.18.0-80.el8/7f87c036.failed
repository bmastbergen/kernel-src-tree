rcu: Clean up flavor-related definitions and comments in rcu.h

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Paul E. McKenney <paulmck@linux.vnet.ibm.com>
commit 7f87c036fea3c17eb6a6e4f4164c67aeb98710ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/7f87c036.failed

	Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
(cherry picked from commit 7f87c036fea3c17eb6a6e4f4164c67aeb98710ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/rcu/rcu.h
diff --cc kernel/rcu/rcu.h
index 91fd7f65888d,5dec94509a7e..000000000000
--- a/kernel/rcu/rcu.h
+++ b/kernel/rcu/rcu.h
@@@ -328,40 -329,35 +329,51 @@@ static inline void rcu_init_levelspread
  	}
  }
  
++<<<<<<< HEAD
 +/* Returns first leaf rcu_node of the specified RCU flavor. */
 +#define rcu_first_leaf_node(rsp) ((rsp)->level[rcu_num_lvls - 1])
++=======
+ /* Returns a pointer to the first leaf rcu_node structure. */
+ #define rcu_first_leaf_node() (rcu_state.level[rcu_num_lvls - 1])
++>>>>>>> 7f87c036fea3 (rcu: Clean up flavor-related definitions and comments in rcu.h)
  
  /* Is this rcu_node a leaf? */
  #define rcu_is_leaf_node(rnp) ((rnp)->level == rcu_num_lvls - 1)
  
  /* Is this rcu_node the last leaf? */
 -#define rcu_is_last_leaf_node(rnp) ((rnp) == &rcu_state.node[rcu_num_nodes - 1])
 +#define rcu_is_last_leaf_node(rsp, rnp) ((rnp) == &(rsp)->node[rcu_num_nodes - 1])
  
  /*
++<<<<<<< HEAD
 + * Do a full breadth-first scan of the rcu_node structures for the
 + * specified rcu_state structure.
++=======
+  * Do a full breadth-first scan of the {s,}rcu_node structures for the
+  * specified state structure (for SRCU) or the only rcu_state structure
+  * (for RCU).
++>>>>>>> 7f87c036fea3 (rcu: Clean up flavor-related definitions and comments in rcu.h)
   */
 -#define srcu_for_each_node_breadth_first(sp, rnp) \
 -	for ((rnp) = &(sp)->node[0]; \
 -	     (rnp) < &(sp)->node[rcu_num_nodes]; (rnp)++)
 -#define rcu_for_each_node_breadth_first(rnp) \
 -	srcu_for_each_node_breadth_first(&rcu_state, rnp)
 +#define rcu_for_each_node_breadth_first(rsp, rnp) \
 +	for ((rnp) = &(rsp)->node[0]; \
 +	     (rnp) < &(rsp)->node[rcu_num_nodes]; (rnp)++)
 +
 +/*
 + * Do a breadth-first scan of the non-leaf rcu_node structures for the
 + * specified rcu_state structure.  Note that if there is a singleton
 + * rcu_node tree with but one rcu_node structure, this loop is a no-op.
 + */
 +#define rcu_for_each_nonleaf_node_breadth_first(rsp, rnp) \
 +	for ((rnp) = &(rsp)->node[0]; !rcu_is_leaf_node(rsp, rnp); (rnp)++)
  
  /*
-  * Scan the leaves of the rcu_node hierarchy for the specified rcu_state
-  * structure.  Note that if there is a singleton rcu_node tree with but
-  * one rcu_node structure, this loop -will- visit the rcu_node structure.
-  * It is still a leaf node, even if it is also the root node.
+  * Scan the leaves of the rcu_node hierarchy for the rcu_state structure.
+  * Note that if there is a singleton rcu_node tree with but one rcu_node
+  * structure, this loop -will- visit the rcu_node structure.  It is still
+  * a leaf node, even if it is also the root node.
   */
 -#define rcu_for_each_leaf_node(rnp) \
 -	for ((rnp) = rcu_first_leaf_node(); \
 -	     (rnp) < &rcu_state.node[rcu_num_nodes]; (rnp)++)
 +#define rcu_for_each_leaf_node(rsp, rnp) \
 +	for ((rnp) = rcu_first_leaf_node(rsp); \
 +	     (rnp) < &(rsp)->node[rcu_num_nodes]; (rnp)++)
  
  /*
   * Iterate over all possible CPUs in a leaf RCU node.
* Unmerged path kernel/rcu/rcu.h
