rcu: Remove obsolete ->dynticks_fqs and ->cond_resched_completed

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Paul E. McKenney <paulmck@linux.vnet.ibm.com>
commit 8d8a9d0e7eda9feeee4af7be31932e14b512d3ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/8d8a9d0e.failed

The rcu_data structure's ->dynticks_fqs is incremented but never
accesses.  Its ->cond_resched_completed field isn't used at all.
This commit therefore removes both fields.

	Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
(cherry picked from commit 8d8a9d0e7eda9feeee4af7be31932e14b512d3ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/rcu/tree.c
#	kernel/rcu/tree.h
diff --cc kernel/rcu/tree.c
index 65383db6b433,85c2c2dc4c4a..000000000000
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@@ -1023,30 -1037,10 +1023,35 @@@ static int rcu_implicit_dynticks_qs(str
  	 * read-side critical section that started before the beginning
  	 * of the current RCU grace period.
  	 */
++<<<<<<< HEAD
 +	if (rcu_dynticks_in_eqs_since(rdp->dynticks, rdp->dynticks_snap)) {
 +		trace_rcu_fqs(rdp->rsp->name, rdp->gp_seq, rdp->cpu, TPS("dti"));
 +		rdp->dynticks_fqs++;
++=======
+ 	if (rcu_dynticks_in_eqs_since(rdp, rdp->dynticks_snap)) {
+ 		trace_rcu_fqs(rcu_state.name, rdp->gp_seq, rdp->cpu, TPS("dti"));
++>>>>>>> 8d8a9d0e7eda (rcu: Remove obsolete ->dynticks_fqs and ->cond_resched_completed)
 +		rcu_gpnum_ovf(rnp, rdp);
 +		return 1;
 +	}
 +
 +	/*
 +	 * Has this CPU encountered a cond_resched() since the beginning
 +	 * of the grace period?  For this to be the case, the CPU has to
 +	 * have noticed the current grace period.  This might not be the
 +	 * case for nohz_full CPUs looping in the kernel.
 +	 */
 +	jtsq = jiffies_till_sched_qs;
 +	ruqp = per_cpu_ptr(&rcu_dynticks.rcu_urgent_qs, rdp->cpu);
 +	if (time_after(jiffies, rdp->rsp->gp_start + jtsq) &&
 +	    READ_ONCE(rdp->rcu_qs_ctr_snap) != per_cpu(rcu_dynticks.rcu_qs_ctr, rdp->cpu) &&
 +	    rcu_seq_current(&rdp->gp_seq) == rnp->gp_seq && !rdp->gpwrap) {
 +		trace_rcu_fqs(rdp->rsp->name, rdp->gp_seq, rdp->cpu, TPS("rqc"));
  		rcu_gpnum_ovf(rnp, rdp);
  		return 1;
 +	} else if (time_after(jiffies, rdp->rsp->gp_start + jtsq)) {
 +		/* Load rcu_qs_ctr before store to rcu_urgent_qs. */
 +		smp_store_release(ruqp, true);
  	}
  
  	/* If waiting too long on an offline CPU, complain. */
diff --cc kernel/rcu/tree.h
index 971069b043e9,bfbf97a1c29d..000000000000
--- a/kernel/rcu/tree.h
+++ b/kernel/rcu/tree.h
@@@ -214,33 -187,23 +214,37 @@@ struct rcu_data 
  	long		blimit;		/* Upper limit on a processed batch */
  
  	/* 3) dynticks interface. */
 +	struct rcu_dynticks *dynticks;	/* Shared per-CPU dynticks state. */
  	int dynticks_snap;		/* Per-GP tracking for dynticks. */
 -	long dynticks_nesting;		/* Track process nesting level. */
 -	long dynticks_nmi_nesting;	/* Track irq/NMI nesting level. */
 -	atomic_t dynticks;		/* Even value for idle, else odd. */
 -	bool rcu_need_heavy_qs;		/* GP old, so heavy quiescent state! */
 -	bool rcu_urgent_qs;		/* GP old need light quiescent state. */
 +	long dynticks_nesting;      /* Track process nesting level. */
 +	long dynticks_nmi_nesting;  /* Track irq/NMI nesting level. */
 +	// atomic_t dynticks;	    /* Even value for idle, else odd. */
 +	bool rcu_need_heavy_qs;     /* GP old, need heavy quiescent state. */
 +	bool rcu_urgent_qs;	    /* GP old need light quiescent state. */
  #ifdef CONFIG_RCU_FAST_NO_HZ
 -	bool all_lazy;			/* Are all CPU's CBs lazy? */
 -	unsigned long nonlazy_posted;	/* # times non-lazy CB posted to CPU. */
 +	bool all_lazy;		    /* Are all CPU's CBs lazy? */
 +	unsigned long nonlazy_posted;
 +				    /* # times non-lazy CBs posted to CPU. */
  	unsigned long nonlazy_posted_snap;
 -					/* Nonlazy_posted snapshot. */
 -	unsigned long last_accelerate;	/* Last jiffy CBs were accelerated. */
 -	unsigned long last_advance_all;	/* Last jiffy CBs were all advanced. */
 -	int tick_nohz_enabled_snap;	/* Previously seen value from sysfs. */
 +				    /* idle-period nonlazy_posted snapshot. */
 +	unsigned long last_accelerate;
 +				    /* Last jiffy CBs were accelerated. */
 +	unsigned long last_advance_all;
 +				    /* Last jiffy CBs were all advanced. */
 +	int tick_nohz_enabled_snap; /* Previously seen value from sysfs. */
  #endif /* #ifdef CONFIG_RCU_FAST_NO_HZ */
  
++<<<<<<< HEAD
 +	/* 4) reasons this CPU needed to be kicked by force_quiescent_state */
 +	unsigned long dynticks_fqs;	/* Kicked due to dynticks idle. */
 +	unsigned long cond_resched_completed;
 +					/* Grace period that needs help */
 +					/*  from cond_resched(). */
 +
 +	/* 5) _rcu_barrier(), OOM callbacks, and expediting. */
++=======
+ 	/* 4) rcu_barrier(), OOM callbacks, and expediting. */
++>>>>>>> 8d8a9d0e7eda (rcu: Remove obsolete ->dynticks_fqs and ->cond_resched_completed)
  	struct rcu_head barrier_head;
  	int exp_dynticks_snap;		/* Double-check need for IPI. */
  
* Unmerged path kernel/rcu/tree.c
* Unmerged path kernel/rcu/tree.h
