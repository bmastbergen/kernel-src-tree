rcu: Remove rsp parameter from rcu_gp_kthread_wake()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Paul E. McKenney <paulmck@linux.vnet.ibm.com>
commit 532c00c97f16a2a8576d453ae13ddc38162faed4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/532c00c9.failed

There now is only one rcu_state structure in a given build of the
Linux kernel, so there is no need to pass it as a parameter to RCU's
functions.  This commit therefore removes the rsp parameter from
rcu_gp_kthread_wake().

	Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
(cherry picked from commit 532c00c97f16a2a8576d453ae13ddc38162faed4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/rcu/tree.c
diff --cc kernel/rcu/tree.c
index 467070baeed1,06f83fce416b..000000000000
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@@ -1642,13 -1642,13 +1642,17 @@@ static bool rcu_future_gp_cleanup(struc
   * raced to awaken, and we lost), and finally don't try to awaken
   * a kthread that has not yet been created.
   */
- static void rcu_gp_kthread_wake(struct rcu_state *rsp)
+ static void rcu_gp_kthread_wake(void)
  {
- 	if (current == rsp->gp_kthread ||
- 	    !READ_ONCE(rsp->gp_flags) ||
- 	    !rsp->gp_kthread)
+ 	if (current == rcu_state.gp_kthread ||
+ 	    !READ_ONCE(rcu_state.gp_flags) ||
+ 	    !rcu_state.gp_kthread)
  		return;
++<<<<<<< HEAD
 +	swake_up(&rsp->gp_wq);
++=======
+ 	swake_up_one(&rcu_state.gp_wq);
++>>>>>>> 532c00c97f16 (rcu: Remove rsp parameter from rcu_gp_kthread_wake())
  }
  
  /*
* Unmerged path kernel/rcu/tree.c
diff --git a/kernel/rcu/tree_plugin.h b/kernel/rcu/tree_plugin.h
index 0948ea6bf9f3..a360f596c005 100644
--- a/kernel/rcu/tree_plugin.h
+++ b/kernel/rcu/tree_plugin.h
@@ -1700,7 +1700,7 @@ static void rcu_prepare_for_idle(void)
 		needwake = rcu_accelerate_cbs(rsp, rnp, rdp);
 		raw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */
 		if (needwake)
-			rcu_gp_kthread_wake(rsp);
+			rcu_gp_kthread_wake();
 	}
 }
 
@@ -2147,7 +2147,7 @@ static void rcu_nocb_wait_gp(struct rcu_data *rdp)
 		needwake = rcu_start_this_gp(rnp, rdp, c);
 		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 		if (needwake)
-			rcu_gp_kthread_wake(rdp->rsp);
+			rcu_gp_kthread_wake();
 	}
 
 	/*
