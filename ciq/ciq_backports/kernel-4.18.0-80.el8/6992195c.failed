KVM: arm64: Clarify explanation of STAGE2_PGTABLE_LEVELS

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Christoffer Dall <christoffer.dall@arm.com>
commit 6992195cc6c6c4d673a3266ae59cbeeb746d61af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/6992195c.failed

In attempting to re-construct the logic for our stage 2 page table
layout I found the reasoning in the comment explaining how we calculate
the number of levels used for stage 2 page tables a bit backwards.

This commit attempts to clarify the comment, to make it slightly easier
to read without having the Arm ARM open on the right page.

While we're at it, fixup a typo in a comment that was recently changed.

	Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
	Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>
	Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
(cherry picked from commit 6992195cc6c6c4d673a3266ae59cbeeb746d61af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	virt/kvm/arm/mmu.c
diff --cc virt/kvm/arm/mmu.c
index c87a77b52606,f605514395a1..000000000000
--- a/virt/kvm/arm/mmu.c
+++ b/virt/kvm/arm/mmu.c
@@@ -1227,8 -1353,14 +1227,17 @@@ static bool transparent_hugepage_adjust
  {
  	kvm_pfn_t pfn = *pfnp;
  	gfn_t gfn = *ipap >> PAGE_SHIFT;
 -	struct page *page = pfn_to_page(pfn);
  
++<<<<<<< HEAD
 +	if (PageTransCompoundMap(pfn_to_page(pfn))) {
++=======
+ 	/*
+ 	 * PageTransCompoundMap() returns true for THP and
+ 	 * hugetlbfs. Make sure the adjustment is done only for THP
+ 	 * pages.
+ 	 */
+ 	if (!PageHuge(page) && PageTransCompoundMap(page)) {
++>>>>>>> 6992195cc6c6 (KVM: arm64: Clarify explanation of STAGE2_PGTABLE_LEVELS)
  		unsigned long mask;
  		/*
  		 * The address we faulted on is backed by a transparent huge
diff --git a/arch/arm64/include/asm/stage2_pgtable.h b/arch/arm64/include/asm/stage2_pgtable.h
index 2cce769ba4c6..58c899eab286 100644
--- a/arch/arm64/include/asm/stage2_pgtable.h
+++ b/arch/arm64/include/asm/stage2_pgtable.h
@@ -30,16 +30,14 @@
 #define pt_levels_pgdir_shift(lvls)	ARM64_HW_PGTABLE_LEVEL_SHIFT(4 - (lvls))
 
 /*
- * The hardware supports concatenation of up to 16 tables at stage2 entry level
- * and we use the feature whenever possible.
+ * The hardware supports concatenation of up to 16 tables at stage2 entry
+ * level and we use the feature whenever possible, which means we resolve 4
+ * additional bits of address at the entry level.
  *
- * Now, the minimum number of bits resolved at any level is (PAGE_SHIFT - 3).
- * On arm64, the smallest PAGE_SIZE supported is 4k, which means
- *             (PAGE_SHIFT - 3) > 4 holds for all page sizes.
- * This implies, the total number of page table levels at stage2 expected
- * by the hardware is actually the number of levels required for (IPA_SHIFT - 4)
- * in normal translations(e.g, stage1), since we cannot have another level in
- * the range (IPA_SHIFT, IPA_SHIFT - 4).
+ * This implies, the total number of page table levels required for
+ * IPA_SHIFT at stage2 expected by the hardware can be calculated using
+ * the same logic used for the (non-collapsable) stage1 page tables but for
+ * (IPA_SHIFT - 4).
  */
 #define stage2_pgtable_levels(ipa)	ARM64_HW_PGTABLE_LEVELS((ipa) - 4)
 #define STAGE2_PGTABLE_LEVELS		stage2_pgtable_levels(KVM_PHYS_SHIFT)
* Unmerged path virt/kvm/arm/mmu.c
