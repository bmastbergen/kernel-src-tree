sctp: check and update stream->out_curr when allocating stream_out

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Xin Long <lucien.xin@gmail.com>
commit cfe4bd7a257f6d6f81d3458d8c9d9ec4957539e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/cfe4bd7a.failed

Now when using stream reconfig to add out streams, stream->out
will get re-allocated, and all old streams' information will
be copied to the new ones and the old ones will be freed.

So without stream->out_curr updated, next time when trying to
send from stream->out_curr stream, a panic would be caused.

This patch is to check and update stream->out_curr when
allocating stream_out.

v1->v2:
  - define fa_index() to get elem index from stream->out_curr.
v2->v3:
  - repost with no change.

Fixes: 5bbbbe32a431 ("sctp: introduce stream scheduler foundations")
	Reported-by: Ying Xu <yinxu@redhat.com>
	Reported-by: syzbot+e33a3a138267ca119c7d@syzkaller.appspotmail.com
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Acked-by: Neil Horman <nhorman@tuxdriver.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cfe4bd7a257f6d6f81d3458d8c9d9ec4957539e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/stream.c
diff --cc net/sctp/stream.c
index ff233f6bd465,f24633114dfd..000000000000
--- a/net/sctp/stream.c
+++ b/net/sctp/stream.c
@@@ -37,6 -37,66 +37,69 @@@
  #include <net/sctp/sm.h>
  #include <net/sctp/stream_sched.h>
  
++<<<<<<< HEAD
++=======
+ static struct flex_array *fa_alloc(size_t elem_size, size_t elem_count,
+ 				   gfp_t gfp)
+ {
+ 	struct flex_array *result;
+ 	int err;
+ 
+ 	result = flex_array_alloc(elem_size, elem_count, gfp);
+ 	if (result) {
+ 		err = flex_array_prealloc(result, 0, elem_count, gfp);
+ 		if (err) {
+ 			flex_array_free(result);
+ 			result = NULL;
+ 		}
+ 	}
+ 
+ 	return result;
+ }
+ 
+ static void fa_free(struct flex_array *fa)
+ {
+ 	if (fa)
+ 		flex_array_free(fa);
+ }
+ 
+ static void fa_copy(struct flex_array *fa, struct flex_array *from,
+ 		    size_t index, size_t count)
+ {
+ 	void *elem;
+ 
+ 	while (count--) {
+ 		elem = flex_array_get(from, index);
+ 		flex_array_put(fa, index, elem, 0);
+ 		index++;
+ 	}
+ }
+ 
+ static void fa_zero(struct flex_array *fa, size_t index, size_t count)
+ {
+ 	void *elem;
+ 
+ 	while (count--) {
+ 		elem = flex_array_get(fa, index);
+ 		memset(elem, 0, fa->element_size);
+ 		index++;
+ 	}
+ }
+ 
+ static size_t fa_index(struct flex_array *fa, void *elem, size_t count)
+ {
+ 	size_t index = 0;
+ 
+ 	while (count--) {
+ 		if (elem == flex_array_get(fa, index))
+ 			break;
+ 		index++;
+ 	}
+ 
+ 	return index;
+ }
+ 
++>>>>>>> cfe4bd7a257f (sctp: check and update stream->out_curr when allocating stream_out)
  /* Migrates chunks from stream queues to new stream queues if needed,
   * but not across associations. Also, removes those chunks to streams
   * higher than the new max.
@@@ -98,9 -159,15 +161,21 @@@ static int sctp_stream_alloc_out(struc
  		return -ENOMEM;
  
  	if (stream->out) {
++<<<<<<< HEAD
 +		memcpy(out, stream->out, min(outcnt, stream->outcnt) *
 +					 sizeof(*out));
 +		kfree(stream->out);
++=======
+ 		fa_copy(out, stream->out, 0, min(outcnt, stream->outcnt));
+ 		if (stream->out_curr) {
+ 			size_t index = fa_index(stream->out, stream->out_curr,
+ 						stream->outcnt);
+ 
+ 			BUG_ON(index == stream->outcnt);
+ 			stream->out_curr = flex_array_get(out, index);
+ 		}
+ 		fa_free(stream->out);
++>>>>>>> cfe4bd7a257f (sctp: check and update stream->out_curr when allocating stream_out)
  	}
  
  	if (outcnt > stream->outcnt)
* Unmerged path net/sctp/stream.c
