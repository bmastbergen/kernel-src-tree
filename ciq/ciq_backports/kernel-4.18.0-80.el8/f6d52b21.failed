drm/nouveau/disp: move eDP panel power handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Ben Skeggs <bskeggs@redhat.com>
commit f6d52b2172b1adfde010df34730290c282ee641b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/f6d52b21.failed

We need to do this earlier to prevent aux channel timeouts in resume
paths on certain systems.

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit f6d52b2172b1adfde010df34730290c282ee641b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/nouveau_connector.c
diff --cc drivers/gpu/drm/nouveau/nouveau_connector.c
index de4ab310ef8e,247f72cc4d10..000000000000
--- a/drivers/gpu/drm/nouveau/nouveau_connector.c
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.c
@@@ -417,66 -409,45 +417,79 @@@ static struct nouveau_encoder 
  nouveau_connector_ddc_detect(struct drm_connector *connector)
  {
  	struct drm_device *dev = connector->dev;
++<<<<<<< HEAD
 +	struct nouveau_connector *nv_connector = nouveau_connector(connector);
 +	struct nouveau_drm *drm = nouveau_drm(dev);
 +	struct nvkm_gpio *gpio = nvxx_gpio(&drm->client.device);
 +	struct nouveau_encoder *nv_encoder;
 +	struct drm_encoder *encoder;
 +	int i, panel = -ENODEV;
 +
 +	/* eDP panels need powering on by us (if the VBIOS doesn't default it
 +	 * to on) before doing any AUX channel transactions.  LVDS panel power
 +	 * is handled by the SOR itself, and not required for LVDS DDC.
 +	 */
 +	if (nv_connector->type == DCB_CONNECTOR_eDP) {
 +		panel = nvkm_gpio_get(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff);
 +		if (panel == 0) {
 +			nvkm_gpio_set(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff, 1);
 +			msleep(300);
 +		}
 +	}
 +
 +	for (i = 0; nv_encoder = NULL, i < DRM_CONNECTOR_MAX_ENCODER; i++) {
 +		int id = connector->encoder_ids[i];
 +		if (id == 0)
 +			break;
 +
 +		encoder = drm_encoder_find(dev, NULL, id);
 +		if (!encoder)
 +			continue;
++=======
+ 	struct nouveau_encoder *nv_encoder = NULL, *found = NULL;
+ 	struct drm_encoder *encoder;
+ 	int i, ret;
+ 	bool switcheroo_ddc = false;
+ 
+ 	drm_connector_for_each_possible_encoder(connector, encoder, i) {
++>>>>>>> f6d52b2172b1 (drm/nouveau/disp: move eDP panel power handling)
  		nv_encoder = nouveau_encoder(encoder);
  
 -		switch (nv_encoder->dcb->type) {
 -		case DCB_OUTPUT_DP:
 -			ret = nouveau_dp_detect(nv_encoder);
 +		if (nv_encoder->dcb->type == DCB_OUTPUT_DP) {
 +			int ret = nouveau_dp_detect(nv_encoder);
  			if (ret == NOUVEAU_DP_MST)
  				return NULL;
 -			else if (ret == NOUVEAU_DP_SST)
 -				found = nv_encoder;
 -
 -			break;
 -		case DCB_OUTPUT_LVDS:
 -			switcheroo_ddc = !!(vga_switcheroo_handler_flags() &
 -					    VGA_SWITCHEROO_CAN_SWITCH_DDC);
 -		/* fall-through */
 -		default:
 -			if (!nv_encoder->i2c)
 +			if (ret == NOUVEAU_DP_SST)
  				break;
 -
 -			if (switcheroo_ddc)
 -				vga_switcheroo_lock_ddc(dev->pdev);
 +		} else
 +		if ((vga_switcheroo_handler_flags() &
 +		     VGA_SWITCHEROO_CAN_SWITCH_DDC) &&
 +		    nv_encoder->dcb->type == DCB_OUTPUT_LVDS &&
 +		    nv_encoder->i2c) {
 +			int ret;
 +			vga_switcheroo_lock_ddc(dev->pdev);
 +			ret = nvkm_probe_i2c(nv_encoder->i2c, 0x50);
 +			vga_switcheroo_unlock_ddc(dev->pdev);
 +			if (ret)
 +				break;
 +		} else
 +		if (nv_encoder->i2c) {
  			if (nvkm_probe_i2c(nv_encoder->i2c, 0x50))
 -				found = nv_encoder;
 -			if (switcheroo_ddc)
 -				vga_switcheroo_unlock_ddc(dev->pdev);
 -
 -			break;
 +				break;
  		}
 -		if (found)
 -			break;
  	}
  
++<<<<<<< HEAD
 +	/* eDP panel not detected, restore panel power GPIO to previous
 +	 * state to avoid confusing the SOR for other output types.
 +	 */
 +	if (!nv_encoder && panel == 0)
 +		nvkm_gpio_set(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff, panel);
 +
 +	return nv_encoder;
++=======
+ 	return found;
++>>>>>>> f6d52b2172b1 (drm/nouveau/disp: move eDP panel power handling)
  }
  
  static struct nouveau_encoder *
* Unmerged path drivers/gpu/drm/nouveau/nouveau_connector.c
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 6160a6158cf2..5f301e632599 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -28,6 +28,7 @@
 
 #include <subdev/bios.h>
 #include <subdev/bios/init.h>
+#include <subdev/gpio.h>
 #include <subdev/i2c.h>
 
 #include <nvif/event.h>
@@ -497,7 +498,7 @@ nvkm_dp_acquire(struct nvkm_outp *outp)
 	return ret;
 }
 
-static void
+static bool
 nvkm_dp_enable(struct nvkm_dp *dp, bool enable)
 {
 	struct nvkm_i2c_aux *aux = dp->aux;
@@ -511,7 +512,7 @@ nvkm_dp_enable(struct nvkm_dp *dp, bool enable)
 
 		if (!nvkm_rdaux(aux, DPCD_RC00_DPCD_REV, dp->dpcd,
 				sizeof(dp->dpcd)))
-			return;
+			return true;
 	}
 
 	if (dp->present) {
@@ -521,6 +522,7 @@ nvkm_dp_enable(struct nvkm_dp *dp, bool enable)
 	}
 
 	atomic_set(&dp->lt.done, 0);
+	return false;
 }
 
 static int
@@ -561,9 +563,38 @@ nvkm_dp_fini(struct nvkm_outp *outp)
 static void
 nvkm_dp_init(struct nvkm_outp *outp)
 {
+	struct nvkm_gpio *gpio = outp->disp->engine.subdev.device->gpio;
 	struct nvkm_dp *dp = nvkm_dp(outp);
+
 	nvkm_notify_put(&dp->outp.conn->hpd);
-	nvkm_dp_enable(dp, true);
+
+	/* eDP panels need powering on by us (if the VBIOS doesn't default it
+	 * to on) before doing any AUX channel transactions.  LVDS panel power
+	 * is handled by the SOR itself, and not required for LVDS DDC.
+	 */
+	if (dp->outp.conn->info.type == DCB_CONNECTOR_eDP) {
+		int power = nvkm_gpio_get(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff);
+		if (power == 0)
+			nvkm_gpio_set(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff, 1);
+
+		/* We delay here unconditionally, even if already powered,
+		 * because some laptop panels having a significant resume
+		 * delay before the panel begins responding.
+		 *
+		 * This is likely a bit of a hack, but no better idea for
+		 * handling this at the moment.
+		 */
+		msleep(300);
+
+		/* If the eDP panel can't be detected, we need to restore
+		 * the panel power GPIO to avoid breaking another output.
+		 */
+		if (!nvkm_dp_enable(dp, true) && power == 0)
+			nvkm_gpio_set(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff, 0);
+	} else {
+		nvkm_dp_enable(dp, true);
+	}
+
 	nvkm_notify_get(&dp->hpd);
 }
 
