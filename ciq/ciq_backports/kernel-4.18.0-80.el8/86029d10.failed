tls: zero the crypto information from tls_context before freeing

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Sabrina Dubroca <sd@queasysnail.net>
commit 86029d10af18381814881d6cce2dd6872163b59f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/86029d10.failed

This contains key material in crypto_send_aes_gcm_128 and
crypto_recv_aes_gcm_128.

Introduce union tls_crypto_context, and replace the two identical
unions directly embedded in struct tls_context with it. We can then
use this union to clean up the memory in the new tls_ctx_free()
function.

Fixes: 3c4d7559159b ("tls: kernel TLS support")
	Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 86029d10af18381814881d6cce2dd6872163b59f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tls/tls_device.c
#	net/tls/tls_sw.c
diff --cc net/tls/tls_device.c
index a7a8f8e20ff3,961b07d4d41c..000000000000
--- a/net/tls/tls_device.c
+++ b/net/tls/tls_device.c
@@@ -690,6 -815,105 +690,108 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ int tls_set_device_offload_rx(struct sock *sk, struct tls_context *ctx)
+ {
+ 	struct tls_offload_context_rx *context;
+ 	struct net_device *netdev;
+ 	int rc = 0;
+ 
+ 	/* We support starting offload on multiple sockets
+ 	 * concurrently, so we only need a read lock here.
+ 	 * This lock must precede get_netdev_for_sock to prevent races between
+ 	 * NETDEV_DOWN and setsockopt.
+ 	 */
+ 	down_read(&device_offload_lock);
+ 	netdev = get_netdev_for_sock(sk);
+ 	if (!netdev) {
+ 		pr_err_ratelimited("%s: netdev not found\n", __func__);
+ 		rc = -EINVAL;
+ 		goto release_lock;
+ 	}
+ 
+ 	if (!(netdev->features & NETIF_F_HW_TLS_RX)) {
+ 		pr_err_ratelimited("%s: netdev %s with no TLS offload\n",
+ 				   __func__, netdev->name);
+ 		rc = -ENOTSUPP;
+ 		goto release_netdev;
+ 	}
+ 
+ 	/* Avoid offloading if the device is down
+ 	 * We don't want to offload new flows after
+ 	 * the NETDEV_DOWN event
+ 	 */
+ 	if (!(netdev->flags & IFF_UP)) {
+ 		rc = -EINVAL;
+ 		goto release_netdev;
+ 	}
+ 
+ 	context = kzalloc(TLS_OFFLOAD_CONTEXT_SIZE_RX, GFP_KERNEL);
+ 	if (!context) {
+ 		rc = -ENOMEM;
+ 		goto release_netdev;
+ 	}
+ 
+ 	ctx->priv_ctx_rx = context;
+ 	rc = tls_set_sw_offload(sk, ctx, 0);
+ 	if (rc)
+ 		goto release_ctx;
+ 
+ 	rc = netdev->tlsdev_ops->tls_dev_add(netdev, sk, TLS_OFFLOAD_CTX_DIR_RX,
+ 					     &ctx->crypto_recv.info,
+ 					     tcp_sk(sk)->copied_seq);
+ 	if (rc) {
+ 		pr_err_ratelimited("%s: The netdev has refused to offload this socket\n",
+ 				   __func__);
+ 		goto free_sw_resources;
+ 	}
+ 
+ 	tls_device_attach(ctx, sk, netdev);
+ 	goto release_netdev;
+ 
+ free_sw_resources:
+ 	tls_sw_free_resources_rx(sk);
+ release_ctx:
+ 	ctx->priv_ctx_rx = NULL;
+ release_netdev:
+ 	dev_put(netdev);
+ release_lock:
+ 	up_read(&device_offload_lock);
+ 	return rc;
+ }
+ 
+ void tls_device_offload_cleanup_rx(struct sock *sk)
+ {
+ 	struct tls_context *tls_ctx = tls_get_ctx(sk);
+ 	struct net_device *netdev;
+ 
+ 	down_read(&device_offload_lock);
+ 	netdev = tls_ctx->netdev;
+ 	if (!netdev)
+ 		goto out;
+ 
+ 	if (!(netdev->features & NETIF_F_HW_TLS_RX)) {
+ 		pr_err_ratelimited("%s: device is missing NETIF_F_HW_TLS_RX cap\n",
+ 				   __func__);
+ 		goto out;
+ 	}
+ 
+ 	netdev->tlsdev_ops->tls_dev_del(netdev, tls_ctx,
+ 					TLS_OFFLOAD_CTX_DIR_RX);
+ 
+ 	if (tls_ctx->tx_conf != TLS_HW) {
+ 		dev_put(netdev);
+ 		tls_ctx->netdev = NULL;
+ 	}
+ out:
+ 	up_read(&device_offload_lock);
+ 	kfree(tls_ctx->rx.rec_seq);
+ 	kfree(tls_ctx->rx.iv);
+ 	tls_sw_release_resources_rx(sk);
+ }
+ 
++>>>>>>> 86029d10af18 (tls: zero the crypto information from tls_context before freeing)
  static int tls_device_down(struct net_device *netdev)
  {
  	struct tls_context *ctx, *tmp;
diff --cc net/tls/tls_sw.c
index 1909de5a5c83,9e918489f4fb..000000000000
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@@ -1097,11 -1179,13 +1097,21 @@@ int tls_set_sw_offload(struct sock *sk
  	}
  
  	if (tx) {
++<<<<<<< HEAD
 +		crypto_info = &ctx->crypto_send;
 +		cctx = &ctx->tx;
 +		aead = &sw_ctx_tx->aead_send;
 +	} else {
 +		crypto_info = &ctx->crypto_recv;
++=======
+ 		crypto_init_wait(&sw_ctx_tx->async_wait);
+ 		crypto_info = &ctx->crypto_send.info;
+ 		cctx = &ctx->tx;
+ 		aead = &sw_ctx_tx->aead_send;
+ 	} else {
+ 		crypto_init_wait(&sw_ctx_rx->async_wait);
+ 		crypto_info = &ctx->crypto_recv.info;
++>>>>>>> 86029d10af18 (tls: zero the crypto information from tls_context before freeing)
  		cctx = &ctx->rx;
  		aead = &sw_ctx_rx->aead_recv;
  	}
diff --git a/include/net/tls.h b/include/net/tls.h
index 70c273777fe9..32b71e5b1290 100644
--- a/include/net/tls.h
+++ b/include/net/tls.h
@@ -165,15 +165,14 @@ struct cipher_context {
 	char *rec_seq;
 };
 
+union tls_crypto_context {
+	struct tls_crypto_info info;
+	struct tls12_crypto_info_aes_gcm_128 aes_gcm_128;
+};
+
 struct tls_context {
-	union {
-		struct tls_crypto_info crypto_send;
-		struct tls12_crypto_info_aes_gcm_128 crypto_send_aes_gcm_128;
-	};
-	union {
-		struct tls_crypto_info crypto_recv;
-		struct tls12_crypto_info_aes_gcm_128 crypto_recv_aes_gcm_128;
-	};
+	union tls_crypto_context crypto_send;
+	union tls_crypto_context crypto_recv;
 
 	struct list_head list;
 	struct net_device *netdev;
@@ -337,8 +336,8 @@ static inline void tls_fill_prepend(struct tls_context *ctx,
 	 * size KTLS_DTLS_HEADER_SIZE + KTLS_DTLS_NONCE_EXPLICIT_SIZE
 	 */
 	buf[0] = record_type;
-	buf[1] = TLS_VERSION_MINOR(ctx->crypto_send.version);
-	buf[2] = TLS_VERSION_MAJOR(ctx->crypto_send.version);
+	buf[1] = TLS_VERSION_MINOR(ctx->crypto_send.info.version);
+	buf[2] = TLS_VERSION_MAJOR(ctx->crypto_send.info.version);
 	/* we can use IV for nonce explicit according to spec */
 	buf[3] = pkt_len >> 8;
 	buf[4] = pkt_len & 0xFF;
* Unmerged path net/tls/tls_device.c
diff --git a/net/tls/tls_device_fallback.c b/net/tls/tls_device_fallback.c
index 748914abdb60..72143679d3d6 100644
--- a/net/tls/tls_device_fallback.c
+++ b/net/tls/tls_device_fallback.c
@@ -320,7 +320,7 @@ static struct sk_buff *tls_enc_skb(struct tls_context *tls_ctx,
 		goto free_req;
 
 	iv = buf;
-	memcpy(iv, tls_ctx->crypto_send_aes_gcm_128.salt,
+	memcpy(iv, tls_ctx->crypto_send.aes_gcm_128.salt,
 	       TLS_CIPHER_AES_GCM_128_SALT_SIZE);
 	aad = buf + TLS_CIPHER_AES_GCM_128_SALT_SIZE +
 	      TLS_CIPHER_AES_GCM_128_IV_SIZE;
diff --git a/net/tls/tls_main.c b/net/tls/tls_main.c
index 2890fdae2e1c..2418a81ce523 100644
--- a/net/tls/tls_main.c
+++ b/net/tls/tls_main.c
@@ -249,6 +249,16 @@ static void tls_write_space(struct sock *sk)
 	ctx->sk_write_space(sk);
 }
 
+static void tls_ctx_free(struct tls_context *ctx)
+{
+	if (!ctx)
+		return;
+
+	memzero_explicit(&ctx->crypto_send, sizeof(ctx->crypto_send));
+	memzero_explicit(&ctx->crypto_recv, sizeof(ctx->crypto_recv));
+	kfree(ctx);
+}
+
 static void tls_sk_proto_close(struct sock *sk, long timeout)
 {
 	struct tls_context *ctx = tls_get_ctx(sk);
@@ -299,7 +309,7 @@ static void tls_sk_proto_close(struct sock *sk, long timeout)
 #else
 	{
 #endif
-		kfree(ctx);
+		tls_ctx_free(ctx);
 		ctx = NULL;
 	}
 
@@ -310,7 +320,7 @@ static void tls_sk_proto_close(struct sock *sk, long timeout)
 	 * for sk->sk_prot->unhash [tls_hw_unhash]
 	 */
 	if (free_ctx)
-		kfree(ctx);
+		tls_ctx_free(ctx);
 }
 
 static int do_tls_getsockopt_tx(struct sock *sk, char __user *optval,
@@ -335,7 +345,7 @@ static int do_tls_getsockopt_tx(struct sock *sk, char __user *optval,
 	}
 
 	/* get user crypto info */
-	crypto_info = &ctx->crypto_send;
+	crypto_info = &ctx->crypto_send.info;
 
 	if (!TLS_CRYPTO_INFO_READY(crypto_info)) {
 		rc = -EBUSY;
@@ -422,9 +432,9 @@ static int do_tls_setsockopt_conf(struct sock *sk, char __user *optval,
 	}
 
 	if (tx)
-		crypto_info = &ctx->crypto_send;
+		crypto_info = &ctx->crypto_send.info;
 	else
-		crypto_info = &ctx->crypto_recv;
+		crypto_info = &ctx->crypto_recv.info;
 
 	/* Currently we don't support set crypto info more than one time */
 	if (TLS_CRYPTO_INFO_READY(crypto_info)) {
* Unmerged path net/tls/tls_sw.c
