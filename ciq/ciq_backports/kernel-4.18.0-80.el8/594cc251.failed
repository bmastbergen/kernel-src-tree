make 'user_access_begin()' do 'access_ok()'

jira LE-1907
cve CVE-2018-20669
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Linus Torvalds <torvalds@linux-foundation.org>
commit 594cc251fdd0d231d342d88b2fdff4bc42fb0690
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/594cc251.failed

Originally, the rule used to be that you'd have to do access_ok()
separately, and then user_access_begin() before actually doing the
direct (optimized) user access.

But experience has shown that people then decide not to do access_ok()
at all, and instead rely on it being implied by other operations or
similar.  Which makes it very hard to verify that the access has
actually been range-checked.

If you use the unsafe direct user accesses, hardware features (either
SMAP - Supervisor Mode Access Protection - on x86, or PAN - Privileged
Access Never - on ARM) do force you to use user_access_begin().  But
nothing really forces the range check.

By putting the range check into user_access_begin(), we actually force
people to do the right thing (tm), and the range check vill be visible
near the actual accesses.  We have way too long a history of people
trying to avoid them.

	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 594cc251fdd0d231d342d88b2fdff4bc42fb0690)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/compat.c
#	kernel/exit.c
diff --cc kernel/compat.c
index 702aa846ddac,f01affa17e22..000000000000
--- a/kernel/compat.c
+++ b/kernel/compat.c
@@@ -383,10 -354,9 +383,13 @@@ long compat_get_bitmap(unsigned long *m
  	bitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);
  	nr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);
  
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_READ, umask, bitmap_size / 8))
++=======
+ 	if (!user_access_begin(umask, bitmap_size / 8))
++>>>>>>> 594cc251fdd0 (make 'user_access_begin()' do 'access_ok()')
  		return -EFAULT;
  
- 	user_access_begin();
  	while (nr_compat_longs > 1) {
  		compat_ulong_t l1, l2;
  		unsafe_get_user(l1, umask++, Efault);
@@@ -413,10 -383,9 +416,13 @@@ long compat_put_bitmap(compat_ulong_t _
  	bitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);
  	nr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);
  
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_WRITE, umask, bitmap_size / 8))
++=======
+ 	if (!user_access_begin(umask, bitmap_size / 8))
++>>>>>>> 594cc251fdd0 (make 'user_access_begin()' do 'access_ok()')
  		return -EFAULT;
  
- 	user_access_begin();
  	while (nr_compat_longs > 1) {
  		unsigned long m = *mask++;
  		unsafe_put_user((compat_ulong_t)m, umask++, Efault);
diff --cc kernel/exit.c
index 012e1942c078,2d14979577ee..000000000000
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@@ -1610,10 -1604,9 +1610,13 @@@ SYSCALL_DEFINE5(waitid, int, which, pid
  	if (!infop)
  		return err;
  
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_WRITE, infop, sizeof(*infop)))
++=======
+ 	if (!user_access_begin(infop, sizeof(*infop)))
++>>>>>>> 594cc251fdd0 (make 'user_access_begin()' do 'access_ok()')
  		return -EFAULT;
  
- 	user_access_begin();
  	unsafe_put_user(signo, &infop->si_signo, Efault);
  	unsafe_put_user(0, &infop->si_errno, Efault);
  	unsafe_put_user(info.cause, &infop->si_code, Efault);
@@@ -1738,10 -1731,9 +1741,13 @@@ COMPAT_SYSCALL_DEFINE5(waitid
  	if (!infop)
  		return err;
  
++<<<<<<< HEAD
 +	if (!access_ok(VERIFY_WRITE, infop, sizeof(*infop)))
++=======
+ 	if (!user_access_begin(infop, sizeof(*infop)))
++>>>>>>> 594cc251fdd0 (make 'user_access_begin()' do 'access_ok()')
  		return -EFAULT;
  
- 	user_access_begin();
  	unsafe_put_user(signo, &infop->si_signo, Efault);
  	unsafe_put_user(0, &infop->si_errno, Efault);
  	unsafe_put_user(info.cause, &infop->si_code, Efault);
diff --git a/arch/x86/include/asm/uaccess.h b/arch/x86/include/asm/uaccess.h
index aae77eb8491c..e76d5d26c496 100644
--- a/arch/x86/include/asm/uaccess.h
+++ b/arch/x86/include/asm/uaccess.h
@@ -708,7 +708,14 @@ extern struct movsl_mask {
  * checking before using them, but you have to surround them with the
  * user_access_begin/end() pair.
  */
-#define user_access_begin()	__uaccess_begin()
+static __must_check inline bool user_access_begin(const void __user *ptr, size_t len)
+{
+	if (unlikely(!access_ok(ptr,len)))
+		return 0;
+	__uaccess_begin();
+	return 1;
+}
+#define user_access_begin(a,b)	user_access_begin(a,b)
 #define user_access_end()	__uaccess_end()
 
 #define unsafe_put_user(x, ptr, err_label)					\
diff --git a/drivers/gpu/drm/i915/i915_gem_execbuffer.c b/drivers/gpu/drm/i915/i915_gem_execbuffer.c
index 2884c9feb602..21c82b90318f 100644
--- a/drivers/gpu/drm/i915/i915_gem_execbuffer.c
+++ b/drivers/gpu/drm/i915/i915_gem_execbuffer.c
@@ -1595,7 +1595,9 @@ static int eb_copy_relocations(const struct i915_execbuffer *eb)
 		 * happened we would make the mistake of assuming that the
 		 * relocations were valid.
 		 */
-		user_access_begin();
+		if (!user_access_begin(urelocs, size))
+			goto end_user;
+
 		for (copied = 0; copied < nreloc; copied++)
 			unsafe_put_user(-1,
 					&urelocs[copied].presumed_offset,
@@ -2648,7 +2650,16 @@ i915_gem_execbuffer2_ioctl(struct drm_device *dev, void *data,
 		unsigned int i;
 
 		/* Copy the new buffer offsets back to the user's exec list. */
-		user_access_begin();
+		/*
+		 * Note: count * sizeof(*user_exec_list) does not overflow,
+		 * because we checked 'count' in check_buffer_count().
+		 *
+		 * And this range already got effectively checked earlier
+		 * when we did the "copy_from_user()" above.
+		 */
+		if (!user_access_begin(user_exec_list, count * sizeof(*user_exec_list)))
+			goto end_user;
+
 		for (i = 0; i < args->buffer_count; i++) {
 			if (!(exec2_list[i].offset & UPDATE))
 				continue;
diff --git a/include/linux/uaccess.h b/include/linux/uaccess.h
index efe79c1cdd47..8a6aaa748eb8 100644
--- a/include/linux/uaccess.h
+++ b/include/linux/uaccess.h
@@ -267,7 +267,7 @@ extern long strncpy_from_unsafe(char *dst, const void *unsafe_addr, long count);
 	probe_kernel_read(&retval, addr, sizeof(retval))
 
 #ifndef user_access_begin
-#define user_access_begin() do { } while (0)
+#define user_access_begin(ptr,len) access_ok(ptr, len)
 #define user_access_end() do { } while (0)
 #define unsafe_get_user(x, ptr, err) do { if (unlikely(__get_user(x, ptr))) goto err; } while (0)
 #define unsafe_put_user(x, ptr, err) do { if (unlikely(__put_user(x, ptr))) goto err; } while (0)
* Unmerged path kernel/compat.c
* Unmerged path kernel/exit.c
diff --git a/lib/strncpy_from_user.c b/lib/strncpy_from_user.c
index b53e1b5d80f4..58eacd41526c 100644
--- a/lib/strncpy_from_user.c
+++ b/lib/strncpy_from_user.c
@@ -114,10 +114,11 @@ long strncpy_from_user(char *dst, const char __user *src, long count)
 
 		kasan_check_write(dst, count);
 		check_object_size(dst, count, false);
-		user_access_begin();
-		retval = do_strncpy_from_user(dst, src, count, max);
-		user_access_end();
-		return retval;
+		if (user_access_begin(src, max)) {
+			retval = do_strncpy_from_user(dst, src, count, max);
+			user_access_end();
+			return retval;
+		}
 	}
 	return -EFAULT;
 }
diff --git a/lib/strnlen_user.c b/lib/strnlen_user.c
index 60d0bbda8f5e..1c1a1b0e38a5 100644
--- a/lib/strnlen_user.c
+++ b/lib/strnlen_user.c
@@ -114,10 +114,11 @@ long strnlen_user(const char __user *str, long count)
 		unsigned long max = max_addr - src_addr;
 		long retval;
 
-		user_access_begin();
-		retval = do_strnlen_user(str, count, max);
-		user_access_end();
-		return retval;
+		if (user_access_begin(str, max)) {
+			retval = do_strnlen_user(str, count, max);
+			user_access_end();
+			return retval;
+		}
 	}
 	return 0;
 }
