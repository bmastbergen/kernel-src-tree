net: aquantia: implement WOL support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Yana Esina <yana.esina@aquantia.com>
commit a0da96c08cfacc97d16330e12be2135f502017dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/a0da96c0.failed

Add WOL support. Currently only magic packet
(ethtool -s <ethX> wol g) feature is implemented.

Remove hw_set_power and move that to FW_OPS set_power:
because WOL configuration behaves differently on 1x and 2x
firmwares

	Signed-off-by: Yana Esina <yana.esina@aquantia.com>
	Signed-off-by: Nikita Danilov <nikita.danilov@aquantia.com>
	Tested-by: Nikita Danilov <nikita.danilov@aquantia.com>
	Signed-off-by: Igor Russkikh <igor.russkikh@aquantia.com>
	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a0da96c08cfacc97d16330e12be2135f502017dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
index f2d8063a2cef,b88be5e5f0a2..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
@@@ -284,6 -285,147 +284,150 @@@ static int aq_ethtool_set_coalesce(stru
  	return aq_nic_update_interrupt_moderation_settings(aq_nic);
  }
  
++<<<<<<< HEAD
++=======
+ static void aq_ethtool_get_wol(struct net_device *ndev,
+ 			       struct ethtool_wolinfo *wol)
+ {
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
+ 
+ 	wol->supported = WAKE_MAGIC;
+ 	wol->wolopts = 0;
+ 
+ 	if (cfg->wol)
+ 		wol->wolopts |= WAKE_MAGIC;
+ }
+ 
+ static int aq_ethtool_set_wol(struct net_device *ndev,
+ 			      struct ethtool_wolinfo *wol)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(ndev->dev.parent);
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
+ 	int err = 0;
+ 
+ 	if (wol->wolopts & WAKE_MAGIC)
+ 		cfg->wol |= AQ_NIC_WOL_ENABLED;
+ 	else
+ 		cfg->wol &= ~AQ_NIC_WOL_ENABLED;
+ 	err = device_set_wakeup_enable(&pdev->dev, wol->wolopts);
+ 
+ 	return err;
+ }
+ 
+ static int aq_ethtool_nway_reset(struct net_device *ndev)
+ {
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 
+ 	if (unlikely(!aq_nic->aq_fw_ops->renegotiate))
+ 		return -EOPNOTSUPP;
+ 
+ 	if (netif_running(ndev))
+ 		return aq_nic->aq_fw_ops->renegotiate(aq_nic->aq_hw);
+ 
+ 	return 0;
+ }
+ 
+ static void aq_ethtool_get_pauseparam(struct net_device *ndev,
+ 				      struct ethtool_pauseparam *pause)
+ {
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 
+ 	pause->autoneg = 0;
+ 
+ 	if (aq_nic->aq_hw->aq_nic_cfg->flow_control & AQ_NIC_FC_RX)
+ 		pause->rx_pause = 1;
+ 	if (aq_nic->aq_hw->aq_nic_cfg->flow_control & AQ_NIC_FC_TX)
+ 		pause->tx_pause = 1;
+ }
+ 
+ static int aq_ethtool_set_pauseparam(struct net_device *ndev,
+ 				     struct ethtool_pauseparam *pause)
+ {
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 	int err = 0;
+ 
+ 	if (!aq_nic->aq_fw_ops->set_flow_control)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (pause->autoneg == AUTONEG_ENABLE)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (pause->rx_pause)
+ 		aq_nic->aq_hw->aq_nic_cfg->flow_control |= AQ_NIC_FC_RX;
+ 	else
+ 		aq_nic->aq_hw->aq_nic_cfg->flow_control &= ~AQ_NIC_FC_RX;
+ 
+ 	if (pause->tx_pause)
+ 		aq_nic->aq_hw->aq_nic_cfg->flow_control |= AQ_NIC_FC_TX;
+ 	else
+ 		aq_nic->aq_hw->aq_nic_cfg->flow_control &= ~AQ_NIC_FC_TX;
+ 
+ 	err = aq_nic->aq_fw_ops->set_flow_control(aq_nic->aq_hw);
+ 
+ 	return err;
+ }
+ 
+ static void aq_get_ringparam(struct net_device *ndev,
+ 			     struct ethtool_ringparam *ring)
+ {
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 	struct aq_nic_cfg_s *aq_nic_cfg = aq_nic_get_cfg(aq_nic);
+ 
+ 	ring->rx_pending = aq_nic_cfg->rxds;
+ 	ring->tx_pending = aq_nic_cfg->txds;
+ 
+ 	ring->rx_max_pending = aq_nic_cfg->aq_hw_caps->rxds_max;
+ 	ring->tx_max_pending = aq_nic_cfg->aq_hw_caps->txds_max;
+ }
+ 
+ static int aq_set_ringparam(struct net_device *ndev,
+ 			    struct ethtool_ringparam *ring)
+ {
+ 	int err = 0;
+ 	bool ndev_running = false;
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 	struct aq_nic_cfg_s *aq_nic_cfg = aq_nic_get_cfg(aq_nic);
+ 	const struct aq_hw_caps_s *hw_caps = aq_nic_cfg->aq_hw_caps;
+ 
+ 	if (ring->rx_mini_pending || ring->rx_jumbo_pending) {
+ 		err = -EOPNOTSUPP;
+ 		goto err_exit;
+ 	}
+ 
+ 	if (netif_running(ndev)) {
+ 		ndev_running = true;
+ 		dev_close(ndev);
+ 	}
+ 
+ 	aq_nic_free_vectors(aq_nic);
+ 
+ 	aq_nic_cfg->rxds = max(ring->rx_pending, hw_caps->rxds_min);
+ 	aq_nic_cfg->rxds = min(aq_nic_cfg->rxds, hw_caps->rxds_max);
+ 	aq_nic_cfg->rxds = ALIGN(aq_nic_cfg->rxds, AQ_HW_RXD_MULTIPLE);
+ 
+ 	aq_nic_cfg->txds = max(ring->tx_pending, hw_caps->txds_min);
+ 	aq_nic_cfg->txds = min(aq_nic_cfg->txds, hw_caps->txds_max);
+ 	aq_nic_cfg->txds = ALIGN(aq_nic_cfg->txds, AQ_HW_TXD_MULTIPLE);
+ 
+ 	for (aq_nic->aq_vecs = 0; aq_nic->aq_vecs < aq_nic_cfg->vecs;
+ 	     aq_nic->aq_vecs++) {
+ 		aq_nic->aq_vec[aq_nic->aq_vecs] =
+ 		    aq_vec_alloc(aq_nic, aq_nic->aq_vecs, aq_nic_cfg);
+ 		if (unlikely(!aq_nic->aq_vec[aq_nic->aq_vecs])) {
+ 			err = -ENOMEM;
+ 			goto err_exit;
+ 		}
+ 	}
+ 	if (ndev_running)
+ 		err = dev_open(ndev);
+ 
+ err_exit:
+ 	return err;
+ }
+ 
++>>>>>>> a0da96c08cfa (net: aquantia: implement WOL support)
  const struct ethtool_ops aq_ethtool_ops = {
  	.get_link            = aq_ethtool_get_link,
  	.get_regs_len        = aq_ethtool_get_regs_len,
@@@ -291,6 -433,13 +435,16 @@@
  	.get_drvinfo         = aq_ethtool_get_drvinfo,
  	.get_strings         = aq_ethtool_get_strings,
  	.get_rxfh_indir_size = aq_ethtool_get_rss_indir_size,
++<<<<<<< HEAD
++=======
+ 	.get_wol             = aq_ethtool_get_wol,
+ 	.set_wol             = aq_ethtool_set_wol,
+ 	.nway_reset          = aq_ethtool_nway_reset,
+ 	.get_ringparam       = aq_get_ringparam,
+ 	.set_ringparam       = aq_set_ringparam,
+ 	.get_pauseparam      = aq_ethtool_get_pauseparam,
+ 	.set_pauseparam      = aq_ethtool_set_pauseparam,
++>>>>>>> a0da96c08cfa (net: aquantia: implement WOL support)
  	.get_rxfh_key_size   = aq_ethtool_get_rss_key_size,
  	.get_rxfh            = aq_ethtool_get_rss,
  	.get_rxnfc           = aq_ethtool_get_rxnfc,
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
index 54d5759f0ff8,c6fe4a58e047..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
@@@ -848,4 -915,6 +915,9 @@@ const struct aq_fw_ops aq_fw_1x_ops = 
  	.set_state = hw_atl_utils_mpi_set_state,
  	.update_link_status = hw_atl_utils_mpi_get_link_status,
  	.update_stats = hw_atl_utils_update_stats,
++<<<<<<< HEAD
++=======
+ 	.set_power = aq_fw1x_set_power,
+ 	.set_flow_control = NULL,
++>>>>>>> a0da96c08cfa (net: aquantia: implement WOL support)
  };
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
index 9c442f3e95f1,9fc187f57ed4..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
@@@ -238,6 -252,123 +238,126 @@@ int aq_fw2x_update_stats(struct aq_hw_
  	return hw_atl_utils_update_stats(self);
  }
  
++<<<<<<< HEAD
++=======
+ static int aq_fw2x_set_sleep_proxy(struct aq_hw_s *self, u8 *mac)
+ {
+ 	struct hw_aq_atl_utils_fw_rpc *rpc = NULL;
+ 	struct offload_info *cfg = NULL;
+ 	unsigned int rpc_size = 0U;
+ 	u32 mpi_opts;
+ 	int err = 0;
+ 
+ 	rpc_size = sizeof(rpc->msg_id) + sizeof(*cfg);
+ 
+ 	err = hw_atl_utils_fw_rpc_wait(self, &rpc);
+ 	if (err < 0)
+ 		goto err_exit;
+ 
+ 	memset(rpc, 0, rpc_size);
+ 	cfg = (struct offload_info *)(&rpc->msg_id + 1);
+ 
+ 	memcpy(cfg->mac_addr, mac, ETH_ALEN);
+ 	cfg->len = sizeof(*cfg);
+ 
+ 	/* Clear bit 0x36C.23 and 0x36C.22 */
+ 	mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+ 	mpi_opts &= ~HW_ATL_FW2X_CTRL_SLEEP_PROXY;
+ 	mpi_opts &= ~HW_ATL_FW2X_CTRL_LINK_DROP;
+ 
+ 	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+ 
+ 	err = hw_atl_utils_fw_rpc_call(self, rpc_size);
+ 	if (err < 0)
+ 		goto err_exit;
+ 
+ 	/* Set bit 0x36C.23 */
+ 	mpi_opts |= HW_ATL_FW2X_CTRL_SLEEP_PROXY;
+ 	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+ 
+ 	AQ_HW_WAIT_FOR((aq_hw_read_reg(self, HW_ATL_FW2X_MPI_STATE2_ADDR) &
+ 			HW_ATL_FW2X_CTRL_SLEEP_PROXY), 1U, 10000U);
+ 
+ err_exit:
+ 	return err;
+ }
+ 
+ static int aq_fw2x_set_wol_params(struct aq_hw_s *self, u8 *mac)
+ {
+ 	struct hw_aq_atl_utils_fw_rpc *rpc = NULL;
+ 	struct fw2x_msg_wol *msg = NULL;
+ 	u32 mpi_opts;
+ 	int err = 0;
+ 
+ 	err = hw_atl_utils_fw_rpc_wait(self, &rpc);
+ 	if (err < 0)
+ 		goto err_exit;
+ 
+ 	msg = (struct fw2x_msg_wol *)rpc;
+ 
+ 	msg->msg_id = HAL_ATLANTIC_UTILS_FW2X_MSG_WOL;
+ 	msg->magic_packet_enabled = true;
+ 	memcpy(msg->hw_addr, mac, ETH_ALEN);
+ 
+ 	mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+ 	mpi_opts &= ~(HW_ATL_FW2X_CTRL_SLEEP_PROXY | HW_ATL_FW2X_CTRL_WOL);
+ 
+ 	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+ 
+ 	err = hw_atl_utils_fw_rpc_call(self, sizeof(*msg));
+ 	if (err < 0)
+ 		goto err_exit;
+ 
+ 	/* Set bit 0x36C.24 */
+ 	mpi_opts |= HW_ATL_FW2X_CTRL_WOL;
+ 	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+ 
+ 	AQ_HW_WAIT_FOR((aq_hw_read_reg(self, HW_ATL_FW2X_MPI_STATE2_ADDR) &
+ 			HW_ATL_FW2X_CTRL_WOL), 1U, 10000U);
+ 
+ err_exit:
+ 	return err;
+ }
+ 
+ static int aq_fw2x_set_power(struct aq_hw_s *self, unsigned int power_state,
+ 			     u8 *mac)
+ {
+ 	int err = 0;
+ 
+ 	if (self->aq_nic_cfg->wol & AQ_NIC_WOL_ENABLED) {
+ 		err = aq_fw2x_set_sleep_proxy(self, mac);
+ 		if (err < 0)
+ 			goto err_exit;
+ 		err = aq_fw2x_set_wol_params(self, mac);
+ 	}
+ 
+ err_exit:
+ 	return err;
+ }
+ 
+ static int aq_fw2x_renegotiate(struct aq_hw_s *self)
+ {
+ 	u32 mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+ 
+ 	mpi_opts |= BIT(CTRL_FORCE_RECONNECT);
+ 
+ 	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+ 
+ 	return 0;
+ }
+ 
+ static int aq_fw2x_set_flow_control(struct aq_hw_s *self)
+ {
+ 	u32 mpi_state = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+ 
+ 	aq_fw2x_set_mpi_flow_control(self, &mpi_state);
+ 
+ 	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_state);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> a0da96c08cfa (net: aquantia: implement WOL support)
  const struct aq_fw_ops aq_fw_2x_ops = {
  	.init = aq_fw2x_init,
  	.deinit = aq_fw2x_deinit,
@@@ -247,4 -379,6 +367,9 @@@
  	.set_state = aq_fw2x_set_state,
  	.update_link_status = aq_fw2x_update_link_status,
  	.update_stats = aq_fw2x_update_stats,
++<<<<<<< HEAD
++=======
+ 	.set_power = aq_fw2x_set_power,
+ 	.set_flow_control   = aq_fw2x_set_flow_control,
++>>>>>>> a0da96c08cfa (net: aquantia: implement WOL support)
  };
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
index 1cf486d813e0..161a6dd1916f 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
@@ -199,7 +199,6 @@ struct aq_hw_ops {
 
 	int (*hw_get_fw_version)(struct aq_hw_s *self, u32 *fw_version);
 
-	int (*hw_set_power)(struct aq_hw_s *self, unsigned int power_state);
 };
 
 struct aq_fw_ops {
@@ -221,6 +220,9 @@ struct aq_fw_ops {
 	int (*update_stats)(struct aq_hw_s *self);
 
 	int (*set_flow_control)(struct aq_hw_s *self);
+
+	int (*set_power)(struct aq_hw_s *self, unsigned int power_state,
+			 u8 *mac);
 };
 
 #endif /* AQ_HW_H */
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
index 05f82879ec0d..9590e24fa2bf 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.c
@@ -885,11 +885,13 @@ void aq_nic_deinit(struct aq_nic_s *self)
 		self->aq_vecs > i; ++i, aq_vec = self->aq_vec[i])
 		aq_vec_deinit(aq_vec);
 
-	if (self->power_state == AQ_HW_POWER_STATE_D0) {
-		(void)self->aq_fw_ops->deinit(self->aq_hw);
-	} else {
-		(void)self->aq_hw_ops->hw_set_power(self->aq_hw,
-						   self->power_state);
+	self->aq_fw_ops->deinit(self->aq_hw);
+
+	if (self->power_state != AQ_HW_POWER_STATE_D0 ||
+	    self->aq_hw->aq_nic_cfg->wol) {
+		self->aq_fw_ops->set_power(self->aq_hw,
+					   self->power_state,
+					   self->ndev->dev_addr);
 	}
 
 err_exit:;
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c
index a9f236ec0cf2..48e3e856d746 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c
@@ -875,7 +875,6 @@ static int hw_atl_a0_hw_ring_rx_stop(struct aq_hw_s *self,
 const struct aq_hw_ops hw_atl_ops_a0 = {
 	.hw_set_mac_address   = hw_atl_a0_hw_mac_addr_set,
 	.hw_init              = hw_atl_a0_hw_init,
-	.hw_set_power         = hw_atl_utils_hw_set_power,
 	.hw_reset             = hw_atl_a0_hw_reset,
 	.hw_start             = hw_atl_a0_hw_start,
 	.hw_ring_tx_start     = hw_atl_a0_hw_ring_tx_start,
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
index b245cd105cc1..7b362a59aaa4 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
@@ -933,7 +933,6 @@ static int hw_atl_b0_hw_ring_rx_stop(struct aq_hw_s *self,
 const struct aq_hw_ops hw_atl_ops_b0 = {
 	.hw_set_mac_address   = hw_atl_b0_hw_mac_addr_set,
 	.hw_init              = hw_atl_b0_hw_init,
-	.hw_set_power         = hw_atl_utils_hw_set_power,
 	.hw_reset             = hw_atl_b0_hw_reset,
 	.hw_start             = hw_atl_b0_hw_start,
 	.hw_ring_tx_start     = hw_atl_b0_hw_ring_tx_start,
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h
index a0fcd232c627..75e024fc08fc 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h
@@ -257,6 +257,9 @@ enum hal_atl_utils_fw_state_e {
 #define HAL_ATLANTIC_UTILS_FW_MSG_ARP           0x2U
 #define HAL_ATLANTIC_UTILS_FW_MSG_INJECT        0x3U
 #define HAL_ATLANTIC_UTILS_FW_MSG_WOL_ADD       0x4U
+#define HAL_ATLANTIC_UTILS_FW_MSG_WOL_PRIOR     0x10000000U
+#define HAL_ATLANTIC_UTILS_FW_MSG_WOL_PATTERN   0x1U
+#define HAL_ATLANTIC_UTILS_FW_MSG_WOL_MAG_PKT   0x2U
 #define HAL_ATLANTIC_UTILS_FW_MSG_WOL_DEL       0x5U
 #define HAL_ATLANTIC_UTILS_FW_MSG_ENABLE_WAKEUP 0x6U
 #define HAL_ATLANTIC_UTILS_FW_MSG_MSM_PFC       0x7U
@@ -368,6 +371,8 @@ struct aq_stats_s *hw_atl_utils_get_hw_stats(struct aq_hw_s *self);
 int hw_atl_utils_fw_downld_dwords(struct aq_hw_s *self, u32 a,
 				  u32 *p, u32 cnt);
 
+int hw_atl_utils_fw_set_wol(struct aq_hw_s *self, bool wol_enabled, u8 *mac);
+
 int hw_atl_utils_fw_rpc_call(struct aq_hw_s *self, unsigned int rpc_size);
 
 int hw_atl_utils_fw_rpc_wait(struct aq_hw_s *self,
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
