rcu: Eliminate grace-period management code use of rsp

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Paul E. McKenney <paulmck@linux.vnet.ibm.com>
commit 9cbc5b97029bff2db7fb413d6ce588d38373834c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/9cbc5b97.failed

Now that there is only one rcu_state structure, there is less point
in maintaining a pointer to it.  This commit therefore replaces
rsp with &rcu_state in rcu_start_this_gp(), rcu_accelerate_cbs(),
__note_gp_changes(), rcu_gp_init(), rcu_gp_fqs(), rcu_gp_cleanup(),
rcu_gp_kthread(), and rcu_report_qs_rsp().

	Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
(cherry picked from commit 9cbc5b97029bff2db7fb413d6ce588d38373834c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/rcu/tree.c
diff --cc kernel/rcu/tree.c
index 5b3a3a98d197,88915372ba38..000000000000
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@@ -1540,7 -1525,6 +1540,10 @@@ static bool rcu_start_this_gp(struct rc
  			      unsigned long gp_seq_req)
  {
  	bool ret = false;
++<<<<<<< HEAD
 +	struct rcu_state *rsp = rdp->rsp;
++=======
++>>>>>>> 9cbc5b97029b (rcu: Eliminate grace-period management code use of rsp)
  	struct rcu_node *rnp;
  
  	/*
@@@ -1861,9 -1843,9 +1862,15 @@@ static bool rcu_gp_init(struct rcu_stat
  	 * for subsequent online CPUs, and that quiescent-state forcing
  	 * will handle subsequent offline CPUs.
  	 */
++<<<<<<< HEAD
 +	rsp->gp_state = RCU_GP_ONOFF;
 +	rcu_for_each_leaf_node(rsp, rnp) {
 +		spin_lock(&rsp->ofl_lock);
++=======
+ 	rcu_state.gp_state = RCU_GP_ONOFF;
+ 	rcu_for_each_leaf_node(rnp) {
+ 		spin_lock(&rcu_state.ofl_lock);
++>>>>>>> 9cbc5b97029b (rcu: Eliminate grace-period management code use of rsp)
  		raw_spin_lock_irq_rcu_node(rnp);
  		if (rnp->qsmaskinit == rnp->qsmaskinitnext &&
  		    !rnp->wait_blkd_tasks) {
@@@ -1921,8 -1903,8 +1928,13 @@@
  	 * The grace period cannot complete until the initialization
  	 * process finishes, because this kthread handles both.
  	 */
++<<<<<<< HEAD
 +	rsp->gp_state = RCU_GP_INIT;
 +	rcu_for_each_node_breadth_first(rsp, rnp) {
++=======
+ 	rcu_state.gp_state = RCU_GP_INIT;
+ 	rcu_for_each_node_breadth_first(rnp) {
++>>>>>>> 9cbc5b97029b (rcu: Eliminate grace-period management code use of rsp)
  		rcu_gp_slow(gp_init_delay);
  		raw_spin_lock_irqsave_rcu_node(rnp, flags);
  		rdp = this_cpu_ptr(&rcu_data);
@@@ -2031,9 -2013,9 +2043,9 @@@ static void rcu_gp_cleanup(struct rcu_s
  	 * the rcu_node structures before the beginning of the next grace
  	 * period is recorded in any of the rcu_node structures.
  	 */
- 	new_gp_seq = rsp->gp_seq;
+ 	new_gp_seq = rcu_state.gp_seq;
  	rcu_seq_end(&new_gp_seq);
 -	rcu_for_each_node_breadth_first(rnp) {
 +	rcu_for_each_node_breadth_first(rsp, rnp) {
  		raw_spin_lock_irq_rcu_node(rnp);
  		if (WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)))
  			dump_blkd_tasks(rnp, 10);
@@@ -2086,7 -2070,6 +2100,10 @@@ static int __noreturn rcu_gp_kthread(vo
  	int gf;
  	unsigned long j;
  	int ret;
++<<<<<<< HEAD
 +	struct rcu_state *rsp = arg;
++=======
++>>>>>>> 9cbc5b97029b (rcu: Eliminate grace-period management code use of rsp)
  	struct rcu_node *rnp = rcu_get_root();
  
  	rcu_bind_gp_kthread();
@@@ -2094,21 -2077,22 +2111,29 @@@
  
  		/* Handle grace-period start. */
  		for (;;) {
- 			trace_rcu_grace_period(rsp->name,
- 					       READ_ONCE(rsp->gp_seq),
+ 			trace_rcu_grace_period(rcu_state.name,
+ 					       READ_ONCE(rcu_state.gp_seq),
  					       TPS("reqwait"));
++<<<<<<< HEAD
 +			rsp->gp_state = RCU_GP_WAIT_GPS;
 +			swait_event_idle(rsp->gp_wq, READ_ONCE(rsp->gp_flags) &
 +						     RCU_GP_FLAG_INIT);
 +			rsp->gp_state = RCU_GP_DONE_GPS;
++=======
+ 			rcu_state.gp_state = RCU_GP_WAIT_GPS;
+ 			swait_event_idle_exclusive(rcu_state.gp_wq,
+ 					 READ_ONCE(rcu_state.gp_flags) &
+ 					 RCU_GP_FLAG_INIT);
+ 			rcu_state.gp_state = RCU_GP_DONE_GPS;
++>>>>>>> 9cbc5b97029b (rcu: Eliminate grace-period management code use of rsp)
  			/* Locking provides needed memory barrier. */
 -			if (rcu_gp_init())
 +			if (rcu_gp_init(rsp))
  				break;
  			cond_resched_tasks_rcu_qs();
- 			WRITE_ONCE(rsp->gp_activity, jiffies);
+ 			WRITE_ONCE(rcu_state.gp_activity, jiffies);
  			WARN_ON(signal_pending(current));
- 			trace_rcu_grace_period(rsp->name,
- 					       READ_ONCE(rsp->gp_seq),
+ 			trace_rcu_grace_period(rcu_state.name,
+ 					       READ_ONCE(rcu_state.gp_seq),
  					       TPS("reqwaitsig"));
  		}
  
@@@ -2118,35 -2102,35 +2143,42 @@@
  		ret = 0;
  		for (;;) {
  			if (!ret) {
- 				rsp->jiffies_force_qs = jiffies + j;
- 				WRITE_ONCE(rsp->jiffies_kick_kthreads,
+ 				rcu_state.jiffies_force_qs = jiffies + j;
+ 				WRITE_ONCE(rcu_state.jiffies_kick_kthreads,
  					   jiffies + 3 * j);
  			}
- 			trace_rcu_grace_period(rsp->name,
- 					       READ_ONCE(rsp->gp_seq),
+ 			trace_rcu_grace_period(rcu_state.name,
+ 					       READ_ONCE(rcu_state.gp_seq),
  					       TPS("fqswait"));
++<<<<<<< HEAD
 +			rsp->gp_state = RCU_GP_WAIT_FQS;
 +			ret = swait_event_idle_timeout(rsp->gp_wq,
 +					rcu_gp_fqs_check_wake(rsp, &gf), j);
 +			rsp->gp_state = RCU_GP_DOING_FQS;
++=======
+ 			rcu_state.gp_state = RCU_GP_WAIT_FQS;
+ 			ret = swait_event_idle_timeout_exclusive(rcu_state.gp_wq,
+ 					rcu_gp_fqs_check_wake(&gf), j);
+ 			rcu_state.gp_state = RCU_GP_DOING_FQS;
++>>>>>>> 9cbc5b97029b (rcu: Eliminate grace-period management code use of rsp)
  			/* Locking provides needed memory barriers. */
  			/* If grace period done, leave loop. */
  			if (!READ_ONCE(rnp->qsmask) &&
  			    !rcu_preempt_blocked_readers_cgp(rnp))
  				break;
  			/* If time for quiescent-state forcing, do it. */
- 			if (ULONG_CMP_GE(jiffies, rsp->jiffies_force_qs) ||
+ 			if (ULONG_CMP_GE(jiffies, rcu_state.jiffies_force_qs) ||
  			    (gf & RCU_GP_FLAG_FQS)) {
- 				trace_rcu_grace_period(rsp->name,
- 						       READ_ONCE(rsp->gp_seq),
+ 				trace_rcu_grace_period(rcu_state.name,
+ 						       READ_ONCE(rcu_state.gp_seq),
  						       TPS("fqsstart"));
 -				rcu_gp_fqs(first_gp_fqs);
 +				rcu_gp_fqs(rsp, first_gp_fqs);
  				first_gp_fqs = false;
- 				trace_rcu_grace_period(rsp->name,
- 						       READ_ONCE(rsp->gp_seq),
+ 				trace_rcu_grace_period(rcu_state.name,
+ 						       READ_ONCE(rcu_state.gp_seq),
  						       TPS("fqsend"));
  				cond_resched_tasks_rcu_qs();
- 				WRITE_ONCE(rsp->gp_activity, jiffies);
+ 				WRITE_ONCE(rcu_state.gp_activity, jiffies);
  				ret = 0; /* Force full wait till next FQS. */
  				j = jiffies_till_next_fqs;
  			} else {
@@@ -2167,9 -2152,9 +2200,15 @@@
  		}
  
  		/* Handle grace-period end. */
++<<<<<<< HEAD
 +		rsp->gp_state = RCU_GP_CLEANUP;
 +		rcu_gp_cleanup(rsp);
 +		rsp->gp_state = RCU_GP_CLEANED;
++=======
+ 		rcu_state.gp_state = RCU_GP_CLEANUP;
+ 		rcu_gp_cleanup();
+ 		rcu_state.gp_state = RCU_GP_CLEANED;
++>>>>>>> 9cbc5b97029b (rcu: Eliminate grace-period management code use of rsp)
  	}
  }
  
@@@ -2185,13 -2170,12 +2224,12 @@@
  static void rcu_report_qs_rsp(unsigned long flags)
  	__releases(rcu_get_root()->lock)
  {
- 	struct rcu_state *rsp = &rcu_state;
- 
  	raw_lockdep_assert_held_rcu_node(rcu_get_root());
  	WARN_ON_ONCE(!rcu_gp_in_progress());
- 	WRITE_ONCE(rsp->gp_flags, READ_ONCE(rsp->gp_flags) | RCU_GP_FLAG_FQS);
+ 	WRITE_ONCE(rcu_state.gp_flags,
+ 		   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);
  	raw_spin_unlock_irqrestore_rcu_node(rcu_get_root(), flags);
 -	rcu_gp_kthread_wake();
 +	rcu_gp_kthread_wake(rsp);
  }
  
  /*
* Unmerged path kernel/rcu/tree.c
