net: sched: act_mirred: remove dependency on rtnl lock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
Rebuild_CHGLOG: - [net] sched: act_mirred: remove dependency on rtnl lock (Ivan Vecera) [1638022]
Rebuild_FUZZ: 95.15%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit 4e232818bd32b29f15bef532f320a14367d172b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/4e232818.failed

Re-introduce mirred list spinlock, that was removed some time ago, in order
to protect it from concurrent modifications, instead of relying on rtnl
lock.

Use tcf spinlock to protect mirred action private data from concurrent
modification in init and dump. Rearrange access to mirred data in order to
be performed only while holding the lock.

Rearrange net dev access to always hold reference while working with it,
instead of relying on rntl lock.

	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4e232818bd32b29f15bef532f320a14367d172b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_mirred.c
diff --cc net/sched/act_mirred.c
index a38ac4910c5e,327be257033d..000000000000
--- a/net/sched/act_mirred.c
+++ b/net/sched/act_mirred.c
@@@ -123,20 -137,12 +134,27 @@@ static int tcf_mirred_init(struct net *
  		NL_SET_ERR_MSG_MOD(extack, "Unknown mirred option");
  		return -EINVAL;
  	}
++<<<<<<< HEAD
 +	if (parm->ifindex) {
 +		dev = __dev_get_by_index(net, parm->ifindex);
 +		if (dev == NULL) {
 +			if (exists)
 +				tcf_idr_release(*a, bind);
 +			return -ENODEV;
 +		}
 +		mac_header_xmit = dev_is_mac_header_xmit(dev);
 +	} else {
 +		dev = NULL;
 +	}
 +
 +	if (!exists) {
 +		if (!dev) {
++=======
+ 
+ 	if (!exists) {
+ 		if (!parm->ifindex) {
+ 			tcf_idr_cleanup(tn, parm->index);
++>>>>>>> 4e232818bd32 (net: sched: act_mirred: remove dependency on rtnl lock)
  			NL_SET_ERR_MSG_MOD(extack, "Specified device does not exist");
  			return -EINVAL;
  		}
@@@ -280,17 -297,21 +310,29 @@@ static int tcf_mirred_dump(struct sk_bu
  {
  	unsigned char *b = skb_tail_pointer(skb);
  	struct tcf_mirred *m = to_mirred(a);
- 	struct net_device *dev = rtnl_dereference(m->tcfm_dev);
  	struct tc_mirred opt = {
  		.index   = m->tcf_index,
++<<<<<<< HEAD
 +		.action  = m->tcf_action,
 +		.refcnt  = m->tcf_refcnt - ref,
 +		.bindcnt = m->tcf_bindcnt - bind,
 +		.eaction = m->tcfm_eaction,
 +		.ifindex = dev ? dev->ifindex : 0,
++=======
+ 		.refcnt  = refcount_read(&m->tcf_refcnt) - ref,
+ 		.bindcnt = atomic_read(&m->tcf_bindcnt) - bind,
++>>>>>>> 4e232818bd32 (net: sched: act_mirred: remove dependency on rtnl lock)
  	};
+ 	struct net_device *dev;
  	struct tcf_t t;
  
+ 	spin_lock(&m->tcf_lock);
+ 	opt.action = m->tcf_action;
+ 	opt.eaction = m->tcfm_eaction;
+ 	dev = tcf_mirred_dev_dereference(m);
+ 	if (dev)
+ 		opt.ifindex = dev->ifindex;
+ 
  	if (nla_put(skb, TCA_MIRRED_PARMS, sizeof(opt), &opt))
  		goto nla_put_failure;
  
* Unmerged path net/sched/act_mirred.c
