ip6_tunnel: Fix encapsulation layout

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Stefano Brivio <sbrivio@redhat.com>
commit d4d576f5ab7edcb757bb33e6a5600666a0b1232d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/d4d576f5.failed

Commit 058214a4d1df ("ip6_tun: Add infrastructure for doing
encapsulation") added the ip6_tnl_encap() call in ip6_tnl_xmit(), before
the call to ipv6_push_frag_opts() to append the IPv6 Tunnel Encapsulation
Limit option (option 4, RFC 2473, par. 5.1) to the outer IPv6 header.

As long as the option didn't actually end up in generated packets, this
wasn't an issue. Then commit 89a23c8b528b ("ip6_tunnel: Fix missing tunnel
encapsulation limit option") fixed sending of this option, and the
resulting layout, e.g. for FoU, is:

.-------------------.------------.----------.-------------------.----- - -
| Outer IPv6 Header | UDP header | Option 4 | Inner IPv6 Header | Payload
'-------------------'------------'----------'-------------------'----- - -

Needless to say, FoU and GUE (at least) won't work over IPv6. The option
is appended by default, and I couldn't find a way to disable it with the
current iproute2.

Turn this into a more reasonable:

.-------------------.----------.------------.-------------------.----- - -
| Outer IPv6 Header | Option 4 | UDP header | Inner IPv6 Header | Payload
'-------------------'----------'------------'-------------------'----- - -

With this, and with 84dad55951b0 ("udp6: fix encap return code for
resubmitting"), FoU and GUE work again over IPv6.

Fixes: 058214a4d1df ("ip6_tun: Add infrastructure for doing encapsulation")
	Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d4d576f5ab7edcb757bb33e6a5600666a0b1232d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_tunnel.c
diff --cc net/ipv6/ip6_tunnel.c
index 1cc9650af9fb,a9d06d4dd057..000000000000
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@@ -1184,11 -1184,14 +1184,22 @@@ route_lookup
  	}
  	skb_dst_set(skb, dst);
  
++<<<<<<< HEAD
 +	if (encap_limit >= 0) {
 +		init_tel_txopt(&opt, encap_limit);
 +		ipv6_push_frag_opts(skb, &opt.ops, &proto);
 +	}
 +	hop_limit = hop_limit ? : ip6_dst_hoplimit(dst);
++=======
+ 	if (hop_limit == 0) {
+ 		if (skb->protocol == htons(ETH_P_IP))
+ 			hop_limit = ip_hdr(skb)->ttl;
+ 		else if (skb->protocol == htons(ETH_P_IPV6))
+ 			hop_limit = ipv6_hdr(skb)->hop_limit;
+ 		else
+ 			hop_limit = ip6_dst_hoplimit(dst);
+ 	}
++>>>>>>> d4d576f5ab7e (ip6_tunnel: Fix encapsulation layout)
  
  	/* Calculate max headroom for all the headers and adjust
  	 * needed_headroom if necessary.
* Unmerged path net/ipv6/ip6_tunnel.c
