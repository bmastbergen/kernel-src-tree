nvmet: don't try to add ns to p2p map unless it actually uses it

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Sagi Grimberg <sagi@grimberg.me>
commit 21d3bbdd4c342f16eac8d70893e45cdfa3381a1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/21d3bbdd.failed

Even without CONFIG_P2PDMA this results in a error print:
nvmet: no peer-to-peer memory is available that's supported by rxe0 and /dev/nullb0

Fixes: c6925093d0b2 ("nvmet: Optionally use PCI P2P memory")
	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Reviewed-by: Logan Gunthorpe <logang@deltatee.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 21d3bbdd4c342f16eac8d70893e45cdfa3381a1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/core.c
diff --cc drivers/nvme/target/core.c
index 380d69c52c74,a5f9bbce863f..000000000000
--- a/drivers/nvme/target/core.c
+++ b/drivers/nvme/target/core.c
@@@ -333,6 -366,89 +333,92 @@@ static void nvmet_ns_dev_disable(struc
  	nvmet_file_ns_disable(ns);
  }
  
++<<<<<<< HEAD
++=======
+ static int nvmet_p2pmem_ns_enable(struct nvmet_ns *ns)
+ {
+ 	int ret;
+ 	struct pci_dev *p2p_dev;
+ 
+ 	if (!ns->use_p2pmem)
+ 		return 0;
+ 
+ 	if (!ns->bdev) {
+ 		pr_err("peer-to-peer DMA is not supported by non-block device namespaces\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!blk_queue_pci_p2pdma(ns->bdev->bd_queue)) {
+ 		pr_err("peer-to-peer DMA is not supported by the driver of %s\n",
+ 		       ns->device_path);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (ns->p2p_dev) {
+ 		ret = pci_p2pdma_distance(ns->p2p_dev, nvmet_ns_dev(ns), true);
+ 		if (ret < 0)
+ 			return -EINVAL;
+ 	} else {
+ 		/*
+ 		 * Right now we just check that there is p2pmem available so
+ 		 * we can report an error to the user right away if there
+ 		 * is not. We'll find the actual device to use once we
+ 		 * setup the controller when the port's device is available.
+ 		 */
+ 
+ 		p2p_dev = pci_p2pmem_find(nvmet_ns_dev(ns));
+ 		if (!p2p_dev) {
+ 			pr_err("no peer-to-peer memory is available for %s\n",
+ 			       ns->device_path);
+ 			return -EINVAL;
+ 		}
+ 
+ 		pci_dev_put(p2p_dev);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Note: ctrl->subsys->lock should be held when calling this function
+  */
+ static void nvmet_p2pmem_ns_add_p2p(struct nvmet_ctrl *ctrl,
+ 				    struct nvmet_ns *ns)
+ {
+ 	struct device *clients[2];
+ 	struct pci_dev *p2p_dev;
+ 	int ret;
+ 
+ 	if (!ctrl->p2p_client || !ns->use_p2pmem)
+ 		return;
+ 
+ 	if (ns->p2p_dev) {
+ 		ret = pci_p2pdma_distance(ns->p2p_dev, ctrl->p2p_client, true);
+ 		if (ret < 0)
+ 			return;
+ 
+ 		p2p_dev = pci_dev_get(ns->p2p_dev);
+ 	} else {
+ 		clients[0] = ctrl->p2p_client;
+ 		clients[1] = nvmet_ns_dev(ns);
+ 
+ 		p2p_dev = pci_p2pmem_find_many(clients, ARRAY_SIZE(clients));
+ 		if (!p2p_dev) {
+ 			pr_err("no peer-to-peer memory is available that's supported by %s and %s\n",
+ 			       dev_name(ctrl->p2p_client), ns->device_path);
+ 			return;
+ 		}
+ 	}
+ 
+ 	ret = radix_tree_insert(&ctrl->p2p_ns_map, ns->nsid, p2p_dev);
+ 	if (ret < 0)
+ 		pci_dev_put(p2p_dev);
+ 
+ 	pr_info("using p2pmem on %s for nsid %d\n", pci_name(p2p_dev),
+ 		ns->nsid);
+ }
+ 
++>>>>>>> 21d3bbdd4c34 (nvmet: don't try to add ns to p2p map unless it actually uses it)
  int nvmet_ns_enable(struct nvmet_ns *ns)
  {
  	struct nvmet_subsys *subsys = ns->subsys;
* Unmerged path drivers/nvme/target/core.c
