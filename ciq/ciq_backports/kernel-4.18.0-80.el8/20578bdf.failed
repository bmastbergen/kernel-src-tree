block: Initialize BIO I/O priority early

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Damien Le Moal <damien.lemoal@wdc.com>
commit 20578bdfd0418efb11ec316229e670d085cd574a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/20578bdf.failed

For the synchronous I/O path case (read(), write() etc system calls), a
BIO I/O priority is not initialized until the execution of
blk_init_request_from_bio() when the BIO is submitted and a request
initialized for the BIO execution. This is due to the ki_ioprio field of
the struct kiocb defined on stack being always initialized to
IOPRIO_CLASS_NONE, regardless of the calling process I/O context ioprio
value set with ioprio_set(). This late initialization can result in the
BIO being merged to pending requests even when the I/O priorities
differ.

Fix this by initializing the ki_iopriority field of on stack struct
kiocb using the get_current_ioprio() helper, ensuring that all BIOs
allocated and submitted for the system call execution see the correct
intended I/O priority early. With this, since a BIO I/O priority is
always set to the intended effective value for both the sync and async
path, blk_init_request_from_bio() can be simplified.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Adam Manzanares <adam.manzanares@wdc.com>
	Signed-off-by: Damien Le Moal <damien.lemoal@wdc.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 20578bdfd0418efb11ec316229e670d085cd574a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-core.c
diff --cc block/blk-core.c
index 7df0c1244abd,04f5be473638..000000000000
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@@ -1928,12 -814,7 +1928,16 @@@ void blk_init_request_from_bio(struct r
  		req->cmd_flags |= REQ_FAILFAST_MASK;
  
  	req->__sector = bio->bi_iter.bi_sector;
++<<<<<<< HEAD
 +	if (ioprio_valid(bio_prio(bio)))
 +		req->ioprio = bio_prio(bio);
 +	else if (ioc)
 +		req->ioprio = ioc->ioprio;
 +	else
 +		req->ioprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, 0);
++=======
+ 	req->ioprio = bio_prio(bio);
++>>>>>>> 20578bdfd041 (block: Initialize BIO I/O priority early)
  	req->write_hint = bio->bi_write_hint;
  	blk_rq_bio_prep(req->q, req, bio);
  }
* Unmerged path block/blk-core.c
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6f009fb80ab1..ef035b1b079a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1954,7 +1954,7 @@ static inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
 		.ki_filp = filp,
 		.ki_flags = iocb_flags(filp),
 		.ki_hint = ki_hint_validate(file_write_hint(filp)),
-		.ki_ioprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, 0),
+		.ki_ioprio = get_current_ioprio(),
 	};
 }
 
