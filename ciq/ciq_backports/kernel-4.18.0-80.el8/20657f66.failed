lockdown: Lock down module params that specify hardware parameters (eg. ioport)

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
Rebuild_CHGLOG: - [kernel] Lock down module params that specify hardware parameters (eg. ioport) (Lenny Szubowicz) [1568532]
Rebuild_FUZZ: 93.24%
commit-author David Howells <dhowells@redhat.com>
commit 20657f66ef52e5005369e4ef539d4cbf01eab10d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/20657f66.failed

Provided an annotation for module parameters that specify hardware
parameters (such as io ports, iomem addresses, irqs, dma channels, fixed
dma buffers and other types).

	Suggested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
	Signed-off-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Matthew Garrett <mjg59@google.com>
	Reviewed-by: Kees Cook <keescook@chromium.org>
	Cc: Jessica Yu <jeyu@kernel.org>
	Signed-off-by: James Morris <jmorris@namei.org>
(cherry picked from commit 20657f66ef52e5005369e4ef539d4cbf01eab10d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/security.h
#	security/lockdown/lockdown.c
diff --cc include/linux/security.h
index 88d30fc975e7,1a3404f9c060..000000000000
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@@ -70,9 -77,50 +70,53 @@@ enum lsm_event 
  	LSM_POLICY_CHANGE,
  };
  
++<<<<<<< HEAD
++=======
+ /*
+  * These are reasons that can be passed to the security_locked_down()
+  * LSM hook. Lockdown reasons that protect kernel integrity (ie, the
+  * ability for userland to modify kernel code) are placed before
+  * LOCKDOWN_INTEGRITY_MAX.  Lockdown reasons that protect kernel
+  * confidentiality (ie, the ability for userland to extract
+  * information from the running kernel that would otherwise be
+  * restricted) are placed before LOCKDOWN_CONFIDENTIALITY_MAX.
+  *
+  * LSM authors should note that the semantics of any given lockdown
+  * reason are not guaranteed to be stable - the same reason may block
+  * one set of features in one kernel release, and a slightly different
+  * set of features in a later kernel release. LSMs that seek to expose
+  * lockdown policy at any level of granularity other than "none",
+  * "integrity" or "confidentiality" are responsible for either
+  * ensuring that they expose a consistent level of functionality to
+  * userland, or ensuring that userland is aware that this is
+  * potentially a moving target. It is easy to misuse this information
+  * in a way that could break userspace. Please be careful not to do
+  * so.
+  *
+  * If you add to this, remember to extend lockdown_reasons in
+  * security/lockdown/lockdown.c.
+  */
+ enum lockdown_reason {
+ 	LOCKDOWN_NONE,
+ 	LOCKDOWN_MODULE_SIGNATURE,
+ 	LOCKDOWN_DEV_MEM,
+ 	LOCKDOWN_KEXEC,
+ 	LOCKDOWN_HIBERNATION,
+ 	LOCKDOWN_PCI_ACCESS,
+ 	LOCKDOWN_IOPORT,
+ 	LOCKDOWN_MSR,
+ 	LOCKDOWN_ACPI_TABLES,
+ 	LOCKDOWN_PCMCIA_CIS,
+ 	LOCKDOWN_TIOCSSERIAL,
+ 	LOCKDOWN_MODULE_PARAMETERS,
+ 	LOCKDOWN_INTEGRITY_MAX,
+ 	LOCKDOWN_CONFIDENTIALITY_MAX,
+ };
+ 
++>>>>>>> 20657f66ef52 (lockdown: Lock down module params that specify hardware parameters (eg. ioport))
  /* These functions are in security/commoncap.c */
  extern int cap_capable(const struct cred *cred, struct user_namespace *ns,
 -		       int cap, unsigned int opts);
 +		       int cap, int audit);
  extern int cap_settime(const struct timespec64 *ts, const struct timezone *tz);
  extern int cap_ptrace_access_check(struct task_struct *child, unsigned int mode);
  extern int cap_ptrace_traceme(struct task_struct *parent);
* Unmerged path security/lockdown/lockdown.c
* Unmerged path include/linux/security.h
diff --git a/kernel/params.c b/kernel/params.c
index ce89f757e6da..b35b38f67d41 100644
--- a/kernel/params.c
+++ b/kernel/params.c
@@ -24,6 +24,7 @@
 #include <linux/err.h>
 #include <linux/slab.h>
 #include <linux/ctype.h>
+#include <linux/security.h>
 
 #ifdef CONFIG_SYSFS
 /* Protects all built-in parameters, modules use their own param_lock */
@@ -108,13 +109,19 @@ bool parameq(const char *a, const char *b)
 	return parameqn(a, b, strlen(a)+1);
 }
 
-static void param_check_unsafe(const struct kernel_param *kp)
+static bool param_check_unsafe(const struct kernel_param *kp)
 {
+	if (kp->flags & KERNEL_PARAM_FL_HWPARAM &&
+	    security_locked_down(LOCKDOWN_MODULE_PARAMETERS))
+		return false;
+
 	if (kp->flags & KERNEL_PARAM_FL_UNSAFE) {
 		pr_notice("Setting dangerous option %s - tainting kernel\n",
 			  kp->name);
 		add_taint(TAINT_USER, LOCKDEP_STILL_OK);
 	}
+
+	return true;
 }
 
 static int parse_one(char *param,
@@ -144,8 +151,10 @@ static int parse_one(char *param,
 			pr_debug("handling %s with %p\n", param,
 				params[i].ops->set);
 			kernel_param_lock(params[i].mod);
-			param_check_unsafe(&params[i]);
-			err = params[i].ops->set(val, &params[i]);
+			if (param_check_unsafe(&params[i]))
+				err = params[i].ops->set(val, &params[i]);
+			else
+				err = -EPERM;
 			kernel_param_unlock(params[i].mod);
 			return err;
 		}
@@ -565,8 +574,10 @@ static ssize_t param_attr_store(struct module_attribute *mattr,
 		return -EPERM;
 
 	kernel_param_lock(mk->mod);
-	param_check_unsafe(attribute->param);
-	err = attribute->param->ops->set(buf, attribute->param);
+	if (param_check_unsafe(attribute->param))
+		err = attribute->param->ops->set(buf, attribute->param);
+	else
+		err = -EPERM;
 	kernel_param_unlock(mk->mod);
 	if (!err)
 		return len;
* Unmerged path security/lockdown/lockdown.c
