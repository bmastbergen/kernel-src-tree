arm64: use the generic swiotlb_dma_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 886643b766321f15f63bd950be618cbb6dd22bbc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/886643b7.failed

Now that the generic swiotlb code supports non-coherent DMA we can switch
to it for arm64.  For that we need to refactor the existing
alloc/free/mmap/pgprot helpers to be used as the architecture hooks,
and implement the standard arch_sync_dma_for_{device,cpu} hooks for
cache maintaincance in the streaming dma hooks, which also implies
using the generic dma_coherent flag in struct device.

Note that we need to keep the old is_device_dma_coherent function around
for now, so that the shared arm/arm64 Xen code keeps working.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Acked-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit 886643b766321f15f63bd950be618cbb6dd22bbc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/mm/dma-mapping.c
diff --cc arch/arm64/mm/dma-mapping.c
index f9ad9f019915,5a5d7990e980..000000000000
--- a/arch/arm64/mm/dma-mapping.c
+++ b/arch/arm64/mm/dma-mapping.c
@@@ -709,11 -548,11 +548,16 @@@ static void __iommu_sync_single_for_cpu
  {
  	phys_addr_t phys;
  
- 	if (is_device_dma_coherent(dev))
+ 	if (dev_is_dma_coherent(dev))
  		return;
  
++<<<<<<< HEAD
 +	phys = iommu_iova_to_phys(iommu_get_dma_domain(dev), dev_addr);
 +	__dma_unmap_area(phys_to_virt(phys), size, dir);
++=======
+ 	phys = iommu_iova_to_phys(iommu_get_domain_for_dev(dev), dev_addr);
+ 	arch_sync_dma_for_cpu(dev, phys, size, dir);
++>>>>>>> 886643b76632 (arm64: use the generic swiotlb_dma_ops)
  }
  
  static void __iommu_sync_single_for_device(struct device *dev,
@@@ -722,11 -561,11 +566,16 @@@
  {
  	phys_addr_t phys;
  
- 	if (is_device_dma_coherent(dev))
+ 	if (dev_is_dma_coherent(dev))
  		return;
  
++<<<<<<< HEAD
 +	phys = iommu_iova_to_phys(iommu_get_dma_domain(dev), dev_addr);
 +	__dma_map_area(phys_to_virt(phys), size, dir);
++=======
+ 	phys = iommu_iova_to_phys(iommu_get_domain_for_dev(dev), dev_addr);
+ 	arch_sync_dma_for_device(dev, phys, size, dir);
++>>>>>>> 886643b76632 (arm64: use the generic swiotlb_dma_ops)
  }
  
  static dma_addr_t __iommu_map_page(struct device *dev, struct page *page,
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 5b4fd63f9948..12c7ee80a69a 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -11,6 +11,8 @@ config ARM64
 	select ARCH_CLOCKSOURCE_DATA
 	select ARCH_HAS_DEBUG_VIRTUAL
 	select ARCH_HAS_DEVMEM_IS_ALLOWED
+	select ARCH_HAS_DMA_COHERENT_TO_PFN
+	select ARCH_HAS_DMA_MMAP_PGPROT
 	select ARCH_HAS_ACPI_TABLE_UPGRADE if ACPI
 	select ARCH_HAS_ELF_RANDOMIZE
 	select ARCH_HAS_FAST_MULTIPLIER
@@ -24,6 +26,8 @@ config ARM64
 	select ARCH_HAS_SG_CHAIN
 	select ARCH_HAS_STRICT_KERNEL_RWX
 	select ARCH_HAS_STRICT_MODULE_RWX
+	select ARCH_HAS_SYNC_DMA_FOR_DEVICE
+	select ARCH_HAS_SYNC_DMA_FOR_CPU
 	select ARCH_HAS_SYSCALL_WRAPPER
 	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
 	select ARCH_HAVE_NMI_SAFE_CMPXCHG
diff --git a/arch/arm64/include/asm/device.h b/arch/arm64/include/asm/device.h
index 5a5fa47a6b18..3dd3d664c5c5 100644
--- a/arch/arm64/include/asm/device.h
+++ b/arch/arm64/include/asm/device.h
@@ -23,7 +23,6 @@ struct dev_archdata {
 #ifdef CONFIG_XEN
 	const struct dma_map_ops *dev_dma_ops;
 #endif
-	bool dma_coherent;
 };
 
 struct pdev_archdata {
diff --git a/arch/arm64/include/asm/dma-mapping.h b/arch/arm64/include/asm/dma-mapping.h
index b7847eb8a7bb..c41f3fb1446c 100644
--- a/arch/arm64/include/asm/dma-mapping.h
+++ b/arch/arm64/include/asm/dma-mapping.h
@@ -44,10 +44,13 @@ void arch_teardown_dma_ops(struct device *dev);
 #define arch_teardown_dma_ops	arch_teardown_dma_ops
 #endif
 
-/* do not use this function in a driver */
+/*
+ * Do not use this function in a driver, it is only provided for
+ * arch/arm/mm/xen.c, which is used by arm64 as well.
+ */
 static inline bool is_device_dma_coherent(struct device *dev)
 {
-	return dev->archdata.dma_coherent;
+	return dev->dma_coherent;
 }
 
 #endif	/* __KERNEL__ */
* Unmerged path arch/arm64/mm/dma-mapping.c
