KVM: arm/arm64: Fix VMID alloc race by reverting to lock-less

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Christoffer Dall <christoffer.dall@arm.com>
commit fb544d1ca65a89f7a3895f7531221ceeed74ada7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/fb544d1c.failed

We recently addressed a VMID generation race by introducing a read/write
lock around accesses and updates to the vmid generation values.

However, kvm_arch_vcpu_ioctl_run() also calls need_new_vmid_gen() but
does so without taking the read lock.

As far as I can tell, this can lead to the same kind of race:

  VM 0, VCPU 0			VM 0, VCPU 1
  ------------			------------
  update_vttbr (vmid 254)
  				update_vttbr (vmid 1) // roll over
				read_lock(kvm_vmid_lock);
				force_vm_exit()
  local_irq_disable
  need_new_vmid_gen == false //because vmid gen matches

  enter_guest (vmid 254)
  				kvm_arch.vttbr = <PGD>:<VMID 1>
				read_unlock(kvm_vmid_lock);

  				enter_guest (vmid 1)

Which results in running two VCPUs in the same VM with different VMIDs
and (even worse) other VCPUs from other VMs could now allocate clashing
VMID 254 from the new generation as long as VCPU 0 is not exiting.

Attempt to solve this by making sure vttbr is updated before another CPU
can observe the updated VMID generation.

	Cc: stable@vger.kernel.org
Fixes: f0cf47d939d0 "KVM: arm/arm64: Close VMID generation race"
	Reviewed-by: Julien Thierry <julien.thierry@arm.com>
	Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>
	Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
(cherry picked from commit fb544d1ca65a89f7a3895f7531221ceeed74ada7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	virt/kvm/arm/arm.c
diff --cc virt/kvm/arm/arm.c
index 0cb26049fff3,d9273f972828..000000000000
--- a/virt/kvm/arm/arm.c
+++ b/virt/kvm/arm/arm.c
@@@ -497,17 -500,12 +499,17 @@@ static bool need_new_vmid_gen(struct kv
  static void update_vttbr(struct kvm *kvm)
  {
  	phys_addr_t pgd_phys;
++<<<<<<< HEAD
 +	u64 vmid;
 +	bool new_gen;
++=======
+ 	u64 vmid, cnp = kvm_cpu_has_cnp() ? VTTBR_CNP_BIT : 0;
++>>>>>>> fb544d1ca65a (KVM: arm/arm64: Fix VMID alloc race by reverting to lock-less)
  
- 	read_lock(&kvm_vmid_lock);
- 	new_gen = need_new_vmid_gen(kvm);
- 	read_unlock(&kvm_vmid_lock);
- 
- 	if (!new_gen)
+ 	if (!need_new_vmid_gen(kvm))
  		return;
  
- 	write_lock(&kvm_vmid_lock);
+ 	spin_lock(&kvm_vmid_lock);
  
  	/*
  	 * We need to re-check the vmid_gen here to ensure that if another vcpu
@@@ -547,9 -544,12 +548,12 @@@
  	pgd_phys = virt_to_phys(kvm->arch.pgd);
  	BUG_ON(pgd_phys & ~kvm_vttbr_baddr_mask(kvm));
  	vmid = ((u64)(kvm->arch.vmid) << VTTBR_VMID_SHIFT) & VTTBR_VMID_MASK(kvm_vmid_bits);
 -	kvm->arch.vttbr = kvm_phys_to_vttbr(pgd_phys) | vmid | cnp;
 +	kvm->arch.vttbr = kvm_phys_to_vttbr(pgd_phys) | vmid;
  
- 	write_unlock(&kvm_vmid_lock);
+ 	smp_wmb();
+ 	WRITE_ONCE(kvm->arch.vmid_gen, atomic64_read(&kvm_vmid_gen));
+ 
+ 	spin_unlock(&kvm_vmid_lock);
  }
  
  static int kvm_vcpu_first_run_init(struct kvm_vcpu *vcpu)
* Unmerged path virt/kvm/arm/arm.c
