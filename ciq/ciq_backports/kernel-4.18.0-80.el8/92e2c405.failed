flow_dissector: allow dissection of tunnel options from metadata

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Simon Horman <simon.horman@netronome.com>
commit 92e2c4053623f21d61a683f7ef7bd61c8300ac7d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/92e2c405.failed

Allow the existing 'dissection' of tunnel metadata to 'dissect'
options already present in tunnel metadata. This dissection is
controlled by a new dissector key, FLOW_DISSECTOR_KEY_ENC_OPTS.

This dissection only occurs when skb_flow_dissect_tunnel_info()
is called, currently only the Flower classifier makes that call.
So there should be no impact on other users of the flow dissector.

This is in preparation for allowing the flower classifier to
match on Geneve options.

	Signed-off-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 92e2c4053623f21d61a683f7ef7bd61c8300ac7d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/flow_dissector.h
#	net/core/flow_dissector.c
diff --cc include/net/flow_dissector.h
index c64406717eee,6a4586dcdede..000000000000
--- a/include/net/flow_dissector.h
+++ b/include/net/flow_dissector.h
@@@ -207,6 -222,8 +222,11 @@@ enum flow_dissector_key_id 
  	FLOW_DISSECTOR_KEY_TCP, /* struct flow_dissector_key_tcp */
  	FLOW_DISSECTOR_KEY_IP, /* struct flow_dissector_key_ip */
  	FLOW_DISSECTOR_KEY_CVLAN, /* struct flow_dissector_key_flow_vlan */
++<<<<<<< HEAD
++=======
+ 	FLOW_DISSECTOR_KEY_ENC_IP, /* struct flow_dissector_key_ip */
+ 	FLOW_DISSECTOR_KEY_ENC_OPTS, /* struct flow_dissector_key_enc_opts */
++>>>>>>> 92e2c4053623 (flow_dissector: allow dissection of tunnel options from metadata)
  
  	FLOW_DISSECTOR_KEY_MAX,
  };
diff --cc net/core/flow_dissector.c
index b555fc229e96,ce9eeeb7c024..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -152,7 -152,11 +152,15 @@@ skb_flow_dissect_tunnel_info(const stru
  	    !dissector_uses_key(flow_dissector,
  				FLOW_DISSECTOR_KEY_ENC_CONTROL) &&
  	    !dissector_uses_key(flow_dissector,
++<<<<<<< HEAD
 +				FLOW_DISSECTOR_KEY_ENC_PORTS))
++=======
+ 				FLOW_DISSECTOR_KEY_ENC_PORTS) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_IP) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_OPTS))
++>>>>>>> 92e2c4053623 (flow_dissector: allow dissection of tunnel options from metadata)
  		return;
  
  	info = skb_tunnel_info(skb);
@@@ -212,6 -216,31 +220,34 @@@
  		tp->src = key->tp_src;
  		tp->dst = key->tp_dst;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_IP)) {
+ 		struct flow_dissector_key_ip *ip;
+ 
+ 		ip = skb_flow_dissector_target(flow_dissector,
+ 					       FLOW_DISSECTOR_KEY_ENC_IP,
+ 					       target_container);
+ 		ip->tos = key->tos;
+ 		ip->ttl = key->ttl;
+ 	}
+ 
+ 	if (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_OPTS)) {
+ 		struct flow_dissector_key_enc_opts *enc_opt;
+ 
+ 		enc_opt = skb_flow_dissector_target(flow_dissector,
+ 						    FLOW_DISSECTOR_KEY_ENC_OPTS,
+ 						    target_container);
+ 
+ 		if (info->options_len) {
+ 			enc_opt->len = info->options_len;
+ 			ip_tunnel_info_opts_get(enc_opt->data, info);
+ 			enc_opt->dst_opt_type = info->key.tun_flags &
+ 						TUNNEL_OPTIONS_PRESENT;
+ 		}
+ 	}
++>>>>>>> 92e2c4053623 (flow_dissector: allow dissection of tunnel options from metadata)
  }
  EXPORT_SYMBOL(skb_flow_dissect_tunnel_info);
  
* Unmerged path include/net/flow_dissector.h
* Unmerged path net/core/flow_dissector.c
