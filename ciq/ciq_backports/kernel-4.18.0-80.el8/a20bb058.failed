dma-direct: add an explicit dma_direct_get_required_mask

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Christoph Hellwig <hch@lst.de>
commit a20bb058375147cb639c7aa17ef86ad68b32d847
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/a20bb058.failed

This is somewhat modelled after the powerpc version, and differs from
the legacy fallback in use fls64 instead of pointlessly splitting up the
address into low and high dwords and in that it takes (__)phys_to_dma
into account.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Reviewed-by: Robin Murphy <robin.murphy@arm.com>
(cherry picked from commit a20bb058375147cb639c7aa17ef86ad68b32d847)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/dma/direct.c
diff --cc kernel/dma/direct.c
index 2ba3b52698ea,f32b33cfa331..000000000000
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@@ -1,8 -1,10 +1,9 @@@
  // SPDX-License-Identifier: GPL-2.0
  /*
 - * Copyright (C) 2018 Christoph Hellwig.
 - *
 - * DMA operations that map physical memory directly without using an IOMMU.
 + * DMA operations that map physical memory directly without using an IOMMU or
 + * flushing caches.
   */
+ #include <linux/bootmem.h> /* for max_pfn */
  #include <linux/export.h>
  #include <linux/mm.h>
  #include <linux/dma-direct.h>
@@@ -49,15 -54,29 +50,29 @@@ check_addr(struct device *dev, dma_addr
  	return true;
  }
  
+ static inline dma_addr_t phys_to_dma_direct(struct device *dev,
+ 		phys_addr_t phys)
+ {
+ 	if (force_dma_unencrypted())
+ 		return __phys_to_dma(dev, phys);
+ 	return phys_to_dma(dev, phys);
+ }
+ 
+ u64 dma_direct_get_required_mask(struct device *dev)
+ {
+ 	u64 max_dma = phys_to_dma_direct(dev, (max_pfn - 1) << PAGE_SHIFT);
+ 
+ 	return (1ULL << (fls64(max_dma) - 1)) * 2 - 1;
+ }
+ 
  static bool dma_coherent_ok(struct device *dev, phys_addr_t phys, size_t size)
  {
- 	dma_addr_t addr = force_dma_unencrypted() ?
- 		__phys_to_dma(dev, phys) : phys_to_dma(dev, phys);
- 	return addr + size - 1 <= dev->coherent_dma_mask;
+ 	return phys_to_dma_direct(dev, phys) + size - 1 <=
+ 			dev->coherent_dma_mask;
  }
  
 -void *dma_direct_alloc_pages(struct device *dev, size_t size,
 -		dma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs)
 +void *dma_direct_alloc(struct device *dev, size_t size, dma_addr_t *dma_handle,
 +		gfp_t gfp, unsigned long attrs)
  {
  	unsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;
  	int page_order = get_order(size);
@@@ -197,7 -300,20 +212,22 @@@ const struct dma_map_ops dma_direct_op
  	.free			= dma_direct_free,
  	.map_page		= dma_direct_map_page,
  	.map_sg			= dma_direct_map_sg,
++<<<<<<< HEAD
++=======
+ #if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE)
+ 	.sync_single_for_device	= dma_direct_sync_single_for_device,
+ 	.sync_sg_for_device	= dma_direct_sync_sg_for_device,
+ #endif
+ #if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \
+     defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)
+ 	.sync_single_for_cpu	= dma_direct_sync_single_for_cpu,
+ 	.sync_sg_for_cpu	= dma_direct_sync_sg_for_cpu,
+ 	.unmap_page		= dma_direct_unmap_page,
+ 	.unmap_sg		= dma_direct_unmap_sg,
+ #endif
+ 	.get_required_mask	= dma_direct_get_required_mask,
++>>>>>>> a20bb0583751 (dma-direct: add an explicit dma_direct_get_required_mask)
  	.dma_supported		= dma_direct_supported,
  	.mapping_error		= dma_direct_mapping_error,
 -	.cache_sync		= arch_dma_cache_sync,
  };
  EXPORT_SYMBOL(dma_direct_ops);
diff --git a/include/linux/dma-direct.h b/include/linux/dma-direct.h
index 38d0cd3bc850..ca3af126e56f 100644
--- a/include/linux/dma-direct.h
+++ b/include/linux/dma-direct.h
@@ -57,6 +57,7 @@ static inline void dma_mark_clean(void *addr, size_t size)
 }
 #endif /* CONFIG_ARCH_HAS_DMA_MARK_CLEAN */
 
+u64 dma_direct_get_required_mask(struct device *dev);
 void *dma_direct_alloc(struct device *dev, size_t size, dma_addr_t *dma_handle,
 		gfp_t gfp, unsigned long attrs);
 void dma_direct_free(struct device *dev, size_t size, void *cpu_addr,
* Unmerged path kernel/dma/direct.c
