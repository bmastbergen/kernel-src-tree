net: sched: act_skbedit: remove dependency on rtnl lock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
Rebuild_CHGLOG: - [net] sched: act_skbedit: remove dependency on rtnl lock (Ivan Vecera) [1638022]
Rebuild_FUZZ: 95.24%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit 6d7a8df6dfe4d62335673fb15407d79180a33ea2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/6d7a8df6.failed

According to the new locking rule, we have to take tcf_lock for both
->init() and ->dump(), as RTNL will be removed.

Use tcf lock to protect skbedit action struct private data from concurrent
modification in init and dump. Use rcu swap operation to reassign params
pointer under protection of tcf lock. (old params value is not used by
init, so there is no need of standalone rcu dereference step)

Remove rtnl lock assertion that is no longer required.

	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6d7a8df6dfe4d62335673fb15407d79180a33ea2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_skbedit.c
diff --cc net/sched/act_skbedit.c
index 9dc63f52da40,64dba3708fce..000000000000
--- a/net/sched/act_skbedit.c
+++ b/net/sched/act_skbedit.c
@@@ -98,6 -99,7 +98,10 @@@ static int tcf_skbedit_init(struct net 
  			    struct netlink_ext_ack *extack)
  {
  	struct tc_action_net *tn = net_generic(net, skbedit_net_id);
++<<<<<<< HEAD
++=======
+ 	struct tcf_skbedit_params *params_new;
++>>>>>>> 6d7a8df6dfe4 (net: sched: act_skbedit: remove dependency on rtnl lock)
  	struct nlattr *tb[TCA_SKBEDIT_MAX + 1];
  	struct tc_skbedit *parm;
  	struct tcf_skbedit *d;
@@@ -172,30 -181,40 +176,50 @@@
  		ret = ACT_P_CREATED;
  	} else {
  		d = to_skbedit(*a);
 -		if (!ovr) {
 -			tcf_idr_release(*a, bind);
 +		tcf_idr_release(*a, bind);
 +		if (!ovr)
  			return -EEXIST;
 -		}
  	}
  
++<<<<<<< HEAD
 +	spin_lock_bh(&d->tcf_lock);
 +
 +	d->flags = flags;
++=======
+ 	params_new = kzalloc(sizeof(*params_new), GFP_KERNEL);
+ 	if (unlikely(!params_new)) {
+ 		if (ret == ACT_P_CREATED)
+ 			tcf_idr_release(*a, bind);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	params_new->flags = flags;
++>>>>>>> 6d7a8df6dfe4 (net: sched: act_skbedit: remove dependency on rtnl lock)
  	if (flags & SKBEDIT_F_PRIORITY)
 -		params_new->priority = *priority;
 +		d->priority = *priority;
  	if (flags & SKBEDIT_F_QUEUE_MAPPING)
 -		params_new->queue_mapping = *queue_mapping;
 +		d->queue_mapping = *queue_mapping;
  	if (flags & SKBEDIT_F_MARK)
 -		params_new->mark = *mark;
 +		d->mark = *mark;
  	if (flags & SKBEDIT_F_PTYPE)
 -		params_new->ptype = *ptype;
 +		d->ptype = *ptype;
  	/* default behaviour is to use all the bits */
 -	params_new->mask = 0xffffffff;
 +	d->mask = 0xffffffff;
  	if (flags & SKBEDIT_F_MASK)
 -		params_new->mask = *mask;
 +		d->mask = *mask;
  
+ 	spin_lock_bh(&d->tcf_lock);
  	d->tcf_action = parm->action;
++<<<<<<< HEAD
 +
 +	spin_unlock_bh(&d->tcf_lock);
++=======
+ 	rcu_swap_protected(d->params, params_new,
+ 			   lockdep_is_held(&d->tcf_lock));
+ 	spin_unlock_bh(&d->tcf_lock);
+ 	if (params_new)
+ 		kfree_rcu(params_new, rcu);
++>>>>>>> 6d7a8df6dfe4 (net: sched: act_skbedit: remove dependency on rtnl lock)
  
  	if (ret == ACT_P_CREATED)
  		tcf_idr_insert(tn, *a);
@@@ -207,14 -226,19 +231,27 @@@ static int tcf_skbedit_dump(struct sk_b
  {
  	unsigned char *b = skb_tail_pointer(skb);
  	struct tcf_skbedit *d = to_skbedit(a);
 -	struct tcf_skbedit_params *params;
  	struct tc_skbedit opt = {
  		.index   = d->tcf_index,
++<<<<<<< HEAD
 +		.refcnt  = d->tcf_refcnt - ref,
 +		.bindcnt = d->tcf_bindcnt - bind,
 +		.action  = d->tcf_action,
++=======
+ 		.refcnt  = refcount_read(&d->tcf_refcnt) - ref,
+ 		.bindcnt = atomic_read(&d->tcf_bindcnt) - bind,
++>>>>>>> 6d7a8df6dfe4 (net: sched: act_skbedit: remove dependency on rtnl lock)
  	};
 -	u64 pure_flags = 0;
  	struct tcf_t t;
++<<<<<<< HEAD
 +	u64 pure_flags = 0;
++=======
+ 
+ 	spin_lock_bh(&d->tcf_lock);
+ 	params = rcu_dereference_protected(d->params,
+ 					   lockdep_is_held(&d->tcf_lock));
+ 	opt.action = d->tcf_action;
++>>>>>>> 6d7a8df6dfe4 (net: sched: act_skbedit: remove dependency on rtnl lock)
  
  	if (nla_put(skb, TCA_SKBEDIT_PARMS, sizeof(opt), &opt))
  		goto nla_put_failure;
* Unmerged path net/sched/act_skbedit.c
