RDMA/core: Avoid holding lock while initializing fields on stack

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Parav Pandit <parav@mellanox.com>
commit 7582df826734bad71522b442b8977e3dee63a77a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/7582df82.failed

In various functions rdma_cm_event is zero initialized on stack using
memset() while holding lock which is not necessary.
Therefore, don't hold the lock while initializing on stack.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Daniel Jurgens <danielj@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 7582df826734bad71522b442b8977e3dee63a77a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cma.c
diff --cc drivers/infiniband/core/cma.c
index bff10ab141b0,fcae854b3ca8..000000000000
--- a/drivers/infiniband/core/cma.c
+++ b/drivers/infiniband/core/cma.c
@@@ -1743,10 -1783,11 +1743,10 @@@ static void cma_set_rep_event_data(stru
  	event->param.conn.qp_num = rep_data->remote_qpn;
  }
  
 -static int cma_ib_handler(struct ib_cm_id *cm_id,
 -			  const struct ib_cm_event *ib_event)
 +static int cma_ib_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event)
  {
  	struct rdma_id_private *id_priv = cm_id->context;
- 	struct rdma_cm_event event;
+ 	struct rdma_cm_event event = {};
  	int ret = 0;
  
  	mutex_lock(&id_priv->handler_mutex);
@@@ -1955,10 -1998,11 +1954,10 @@@ static int cma_check_req_qp_type(struc
  		(!id->qp_type));
  }
  
 -static int cma_req_handler(struct ib_cm_id *cm_id,
 -			   const struct ib_cm_event *ib_event)
 +static int cma_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event)
  {
  	struct rdma_id_private *listen_id, *conn_id = NULL;
- 	struct rdma_cm_event event;
+ 	struct rdma_cm_event event = {};
  	struct net_device *net_dev;
  	u8 offset;
  	int ret;
@@@ -3451,11 -3483,12 +3446,17 @@@ static int cma_format_hdr(void *hdr, st
  }
  
  static int cma_sidr_rep_handler(struct ib_cm_id *cm_id,
 -				const struct ib_cm_event *ib_event)
 +				struct ib_cm_event *ib_event)
  {
  	struct rdma_id_private *id_priv = cm_id->context;
++<<<<<<< HEAD
 +	struct rdma_cm_event event;
 +	struct ib_cm_sidr_rep_event_param *rep = &ib_event->param.sidr_rep_rcvd;
++=======
+ 	struct rdma_cm_event event = {};
+ 	const struct ib_cm_sidr_rep_event_param *rep =
+ 				&ib_event->param.sidr_rep_rcvd;
++>>>>>>> 7582df826734 (RDMA/core: Avoid holding lock while initializing fields on stack)
  	int ret = 0;
  
  	mutex_lock(&id_priv->handler_mutex);
* Unmerged path drivers/infiniband/core/cma.c
