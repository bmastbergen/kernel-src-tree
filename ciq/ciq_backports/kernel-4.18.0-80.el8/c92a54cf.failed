dma-direct: do not include SME mask in the DMA supported check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Lendacky, Thomas <Thomas.Lendacky@amd.com>
commit c92a54cfa0257e8ffd66b2a17d49e9c0bd4b769f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/c92a54cf.failed

The dma_direct_supported() function intends to check the DMA mask against
specific values. However, the phys_to_dma() function includes the SME
encryption mask, which defeats the intended purpose of the check. This
results in drivers that support less than 48-bit DMA (SME encryption mask
is bit 47) from being able to set the DMA mask successfully when SME is
active, which results in the driver failing to initialize.

Change the function used to check the mask from phys_to_dma() to
__phys_to_dma() so that the SME encryption mask is not part of the check.

Fixes: c1d0af1a1d5d ("kernel/dma/direct: take DMA offset into account in dma_direct_supported")
	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit c92a54cfa0257e8ffd66b2a17d49e9c0bd4b769f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/dma/direct.c
diff --cc kernel/dma/direct.c
index a0ae9e05e04e,375c77e8d52f..000000000000
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@@ -166,28 -290,31 +166,46 @@@ int dma_direct_map_sg(struct device *de
  	return nents;
  }
  
 -/*
 - * Because 32-bit DMA masks are so common we expect every architecture to be
 - * able to satisfy them - either by not supporting more physical memory, or by
 - * providing a ZONE_DMA32.  If neither is the case, the architecture needs to
 - * use an IOMMU instead of the direct mapping.
 - */
  int dma_direct_supported(struct device *dev, u64 mask)
  {
++<<<<<<< HEAD
 +#ifdef CONFIG_ZONE_DMA
 +	if (mask < phys_to_dma(dev, DMA_BIT_MASK(ARCH_ZONE_DMA_BITS)))
 +		return 0;
 +#else
 +	/*
 +	 * Because 32-bit DMA masks are so common we expect every architecture
 +	 * to be able to satisfy them - either by not supporting more physical
 +	 * memory, or by providing a ZONE_DMA32.  If neither is the case, the
 +	 * architecture needs to use an IOMMU instead of the direct mapping.
 +	 */
 +	if (mask < phys_to_dma(dev, DMA_BIT_MASK(32)))
 +		return 0;
 +#endif
 +	/*
 +	 * Upstream PCI/PCIe bridges or SoC interconnects may not carry
 +	 * as many DMA address bits as the device itself supports.
 +	 */
 +	if (dev->bus_dma_mask && mask > dev->bus_dma_mask)
 +		return 0;
 +	return 1;
++=======
+ 	u64 min_mask;
+ 
+ 	if (IS_ENABLED(CONFIG_ZONE_DMA))
+ 		min_mask = DMA_BIT_MASK(ARCH_ZONE_DMA_BITS);
+ 	else
+ 		min_mask = DMA_BIT_MASK(32);
+ 
+ 	min_mask = min_t(u64, min_mask, (max_pfn - 1) << PAGE_SHIFT);
+ 
+ 	/*
+ 	 * This check needs to be against the actual bit mask value, so
+ 	 * use __phys_to_dma() here so that the SME encryption mask isn't
+ 	 * part of the check.
+ 	 */
+ 	return mask >= __phys_to_dma(dev, min_mask);
++>>>>>>> c92a54cfa025 (dma-direct: do not include SME mask in the DMA supported check)
  }
  
  int dma_direct_mapping_error(struct device *dev, dma_addr_t dma_addr)
* Unmerged path kernel/dma/direct.c
