lockdown: Restrict /dev/{mem,kmem,port} when the kernel is locked down

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
Rebuild_CHGLOG: - [char] Restrict /dev/{mem, kmem, port} when the kernel is locked down (Lenny Szubowicz) [1568532]
Rebuild_FUZZ: 90.91%
commit-author Matthew Garrett <mjg59@srcf.ucam.org>
commit 9b9d8dda1ed72e9bd560ab0ca93d322a9440510e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/9b9d8dda.failed

Allowing users to read and write to core kernel memory makes it possible
for the kernel to be subverted, avoiding module loading restrictions, and
also to steal cryptographic information.

Disallow /dev/mem and /dev/kmem from being opened this when the kernel has
been locked down to prevent this.

Also disallow /dev/port from being opened to prevent raw ioport access and
thus DMA from being used to accomplish the same thing.

	Signed-off-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Matthew Garrett <mjg59@google.com>
	Reviewed-by: Kees Cook <keescook@chromium.org>
	Cc: x86@kernel.org
	Signed-off-by: James Morris <jmorris@namei.org>
(cherry picked from commit 9b9d8dda1ed72e9bd560ab0ca93d322a9440510e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/security.h
#	security/lockdown/lockdown.c
diff --cc include/linux/security.h
index 88d30fc975e7,e5dd446ef35b..000000000000
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@@ -70,9 -77,41 +70,44 @@@ enum lsm_event 
  	LSM_POLICY_CHANGE,
  };
  
++<<<<<<< HEAD
++=======
+ /*
+  * These are reasons that can be passed to the security_locked_down()
+  * LSM hook. Lockdown reasons that protect kernel integrity (ie, the
+  * ability for userland to modify kernel code) are placed before
+  * LOCKDOWN_INTEGRITY_MAX.  Lockdown reasons that protect kernel
+  * confidentiality (ie, the ability for userland to extract
+  * information from the running kernel that would otherwise be
+  * restricted) are placed before LOCKDOWN_CONFIDENTIALITY_MAX.
+  *
+  * LSM authors should note that the semantics of any given lockdown
+  * reason are not guaranteed to be stable - the same reason may block
+  * one set of features in one kernel release, and a slightly different
+  * set of features in a later kernel release. LSMs that seek to expose
+  * lockdown policy at any level of granularity other than "none",
+  * "integrity" or "confidentiality" are responsible for either
+  * ensuring that they expose a consistent level of functionality to
+  * userland, or ensuring that userland is aware that this is
+  * potentially a moving target. It is easy to misuse this information
+  * in a way that could break userspace. Please be careful not to do
+  * so.
+  *
+  * If you add to this, remember to extend lockdown_reasons in
+  * security/lockdown/lockdown.c.
+  */
+ enum lockdown_reason {
+ 	LOCKDOWN_NONE,
+ 	LOCKDOWN_MODULE_SIGNATURE,
+ 	LOCKDOWN_DEV_MEM,
+ 	LOCKDOWN_INTEGRITY_MAX,
+ 	LOCKDOWN_CONFIDENTIALITY_MAX,
+ };
+ 
++>>>>>>> 9b9d8dda1ed7 (lockdown: Restrict /dev/{mem,kmem,port} when the kernel is locked down)
  /* These functions are in security/commoncap.c */
  extern int cap_capable(const struct cred *cred, struct user_namespace *ns,
 -		       int cap, unsigned int opts);
 +		       int cap, int audit);
  extern int cap_settime(const struct timespec64 *ts, const struct timezone *tz);
  extern int cap_ptrace_access_check(struct task_struct *child, unsigned int mode);
  extern int cap_ptrace_traceme(struct task_struct *parent);
* Unmerged path security/lockdown/lockdown.c
diff --git a/drivers/char/mem.c b/drivers/char/mem.c
index df66a9dd0aae..022bb446c845 100644
--- a/drivers/char/mem.c
+++ b/drivers/char/mem.c
@@ -29,8 +29,8 @@
 #include <linux/export.h>
 #include <linux/io.h>
 #include <linux/uio.h>
-
 #include <linux/uaccess.h>
+#include <linux/security.h>
 
 #ifdef CONFIG_IA64
 # include <linux/efi.h>
@@ -785,7 +785,10 @@ static loff_t memory_lseek(struct file *file, loff_t offset, int orig)
 
 static int open_port(struct inode *inode, struct file *filp)
 {
-	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
+	if (!capable(CAP_SYS_RAWIO))
+		return -EPERM;
+
+	return security_locked_down(LOCKDOWN_DEV_MEM);
 }
 
 #define zero_lseek	null_lseek
* Unmerged path include/linux/security.h
* Unmerged path security/lockdown/lockdown.c
