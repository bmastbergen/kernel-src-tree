IB/ipoib: Consolidate checking of the proposed child interface

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 760109760455a0a35491cb02a3bc3e15f0c180f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/76010976.failed

Move all the checking for pkey and other validity to the __ipoib_vlan_add
function. This removes the last difference from the control flow
of the __ipoib_vlan_add to make the overall design simpler to
understand.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Erez Shitrit <erezsh@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit 760109760455a0a35491cb02a3bc3e15f0c180f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/ipoib/ipoib_netlink.c
#	drivers/infiniband/ulp/ipoib/ipoib_vlan.c
diff --cc drivers/infiniband/ulp/ipoib/ipoib_netlink.c
index 3e44087935ae,d4d553a51fa9..000000000000
--- a/drivers/infiniband/ulp/ipoib/ipoib_netlink.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_netlink.c
@@@ -122,15 -122,6 +122,18 @@@ static int ipoib_new_child_link(struct 
  	} else
  		child_pkey  = nla_get_u16(data[IFLA_IPOIB_PKEY]);
  
++<<<<<<< HEAD
 +	if (child_pkey == 0 || child_pkey == 0x8000)
 +		return -EINVAL;
 +
 +	/*
 +	 * Set the full membership bit, so that we join the right
 +	 * broadcast group, etc.
 +	 */
 +	child_pkey |= 0x8000;
 +
++=======
++>>>>>>> 760109760455 (IB/ipoib: Consolidate checking of the proposed child interface)
  	err = __ipoib_vlan_add(ppriv, ipoib_priv(dev),
  			       child_pkey, IPOIB_RTNL_CHILD);
  
diff --cc drivers/infiniband/ulp/ipoib/ipoib_vlan.c
index b62ab85c8ead,341753fbda54..000000000000
--- a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_vlan.c
@@@ -50,40 -50,88 +50,120 @@@ static ssize_t show_parent(struct devic
  }
  static DEVICE_ATTR(parent, S_IRUGO, show_parent, NULL);
  
++<<<<<<< HEAD
++=======
+ static bool is_child_unique(struct ipoib_dev_priv *ppriv,
+ 			    struct ipoib_dev_priv *priv)
+ {
+ 	struct ipoib_dev_priv *tpriv;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	/*
+ 	 * Since the legacy sysfs interface uses pkey for deletion it cannot
+ 	 * support more than one interface with the same pkey, it creates
+ 	 * ambiguity.  The RTNL interface deletes using the netdev so it does
+ 	 * not have a problem to support duplicated pkeys.
+ 	 */
+ 	if (priv->child_type != IPOIB_LEGACY_CHILD)
+ 		return true;
+ 
+ 	/*
+ 	 * First ensure this isn't a duplicate. We check the parent device and
+ 	 * then all of the legacy child interfaces to make sure the Pkey
+ 	 * doesn't match.
+ 	 */
+ 	if (ppriv->pkey == priv->pkey)
+ 		return false;
+ 
+ 	list_for_each_entry(tpriv, &ppriv->child_intfs, list) {
+ 		if (tpriv->pkey == priv->pkey &&
+ 		    tpriv->child_type == IPOIB_LEGACY_CHILD)
+ 			return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ /*
+  * NOTE: If this function fails then the priv->dev will remain valid, however
+  * priv can have been freed and must not be touched by caller in the error
+  * case.
+  *
+  * If (ndev->reg_state == NETREG_UNINITIALIZED) then it is up to the caller to
+  * free the net_device (just as rtnl_newlink does) otherwise the net_device
+  * will be freed when the rtnl is unlocked.
+  */
++>>>>>>> 760109760455 (IB/ipoib: Consolidate checking of the proposed child interface)
  int __ipoib_vlan_add(struct ipoib_dev_priv *ppriv, struct ipoib_dev_priv *priv,
  		     u16 pkey, int type)
  {
 -	struct net_device *ndev = priv->dev;
  	int result;
  
++<<<<<<< HEAD
 +	priv->max_ib_mtu = ppriv->max_ib_mtu;
 +	/* MTU will be reset when mcast join happens */
 +	priv->dev->mtu   = IPOIB_UD_MTU(priv->max_ib_mtu);
 +	priv->mcast_mtu  = priv->admin_mtu = priv->dev->mtu;
++=======
+ 	ASSERT_RTNL();
+ 
+ 	/*
+ 	 * Racing with unregister of the parent must be prevented by the
+ 	 * caller.
+ 	 */
+ 	WARN_ON(ppriv->dev->reg_state != NETREG_REGISTERED);
+ 
+ 	if (pkey == 0 || pkey == 0x8000) {
+ 		result = -EINVAL;
+ 		goto out_early;
+ 	}
+ 
++>>>>>>> 760109760455 (IB/ipoib: Consolidate checking of the proposed child interface)
  	priv->parent = ppriv->dev;
 +	set_bit(IPOIB_FLAG_SUBINTERFACE, &priv->flags);
 +
 +	ipoib_set_dev_features(priv, ppriv->ca);
 +
  	priv->pkey = pkey;
 -	priv->child_type = type;
  
++<<<<<<< HEAD
 +	memcpy(priv->dev->dev_addr, ppriv->dev->dev_addr, INFINIBAND_ALEN);
 +	memcpy(&priv->local_gid, &ppriv->local_gid, sizeof(priv->local_gid));
 +	set_bit(IPOIB_FLAG_DEV_ADDR_SET, &priv->flags);
 +	priv->dev->broadcast[8] = pkey >> 8;
 +	priv->dev->broadcast[9] = pkey & 0xff;
++=======
+ 	if (!is_child_unique(ppriv, priv)) {
+ 		result = -ENOTUNIQ;
+ 		goto out_early;
+ 	}
+ 
+ 	/* We do not need to touch priv if register_netdevice fails */
+ 	ndev->priv_destructor = ipoib_intf_free;
++>>>>>>> 760109760455 (IB/ipoib: Consolidate checking of the proposed child interface)
 +
 +	result = ipoib_dev_init(priv->dev, ppriv->ca, ppriv->port);
 +	if (result < 0) {
 +		ipoib_warn(ppriv, "failed to initialize subinterface: "
 +			   "device %s, port %d",
 +			   ppriv->ca->name, ppriv->port);
 +		goto err;
 +	}
  
 -	result = register_netdevice(ndev);
 +	result = register_netdevice(priv->dev);
  	if (result) {
  		ipoib_warn(priv, "failed to initialize; error %i", result);
++<<<<<<< HEAD
 +		goto err;
++=======
+ 
+ 		/*
+ 		 * register_netdevice sometimes calls priv_destructor,
+ 		 * sometimes not. Make sure it was done.
+ 		 */
+ 		goto out_early;
++>>>>>>> 760109760455 (IB/ipoib: Consolidate checking of the proposed child interface)
  	}
  
  	/* RTNL childs don't need proprietary sysfs entries */
@@@ -105,10 -150,12 +185,18 @@@
  	return 0;
  
  sysfs_failed:
 +	result = -ENOMEM;
  	unregister_netdevice(priv->dev);
++<<<<<<< HEAD
 +
 +err:
++=======
+ 	return -ENOMEM;
+ 
+ out_early:
+ 	if (ndev->priv_destructor)
+ 		ndev->priv_destructor(ndev);
++>>>>>>> 760109760455 (IB/ipoib: Consolidate checking of the proposed child interface)
  	return result;
  }
  
@@@ -116,24 -163,14 +204,32 @@@ int ipoib_vlan_add(struct net_device *p
  {
  	struct ipoib_dev_priv *ppriv, *priv;
  	char intf_name[IFNAMSIZ];
++<<<<<<< HEAD
 +	struct ipoib_dev_priv *tpriv;
++=======
+ 	struct net_device *ndev;
++>>>>>>> 760109760455 (IB/ipoib: Consolidate checking of the proposed child interface)
  	int result;
  
  	if (!capable(CAP_NET_ADMIN))
  		return -EPERM;
  
++<<<<<<< HEAD
 +	ppriv = ipoib_priv(pdev);
 +
 +	snprintf(intf_name, sizeof(intf_name), "%s.%04x",
 +		 ppriv->dev->name, pkey);
 +
 +	if (!mutex_trylock(&ppriv->sysfs_mutex))
++=======
+ 	if (!rtnl_trylock())
++>>>>>>> 760109760455 (IB/ipoib: Consolidate checking of the proposed child interface)
 +		return restart_syscall();
 +
 +	if (!rtnl_trylock()) {
 +		mutex_unlock(&ppriv->sysfs_mutex);
  		return restart_syscall();
 +	}
  
  	if (pdev->reg_state != NETREG_REGISTERED) {
  		rtnl_unlock();
@@@ -141,52 -177,64 +237,51 @@@
  		return -EPERM;
  	}
  
 -	ppriv = ipoib_priv(pdev);
 -
 -	snprintf(intf_name, sizeof(intf_name), "%s.%04x",
 -		 ppriv->dev->name, pkey);
++<<<<<<< HEAD
 +	if (!down_write_trylock(&ppriv->vlan_rwsem)) {
 +		rtnl_unlock();
 +		mutex_unlock(&ppriv->sysfs_mutex);
 +		return restart_syscall();
 +	}
  
  	priv = ipoib_intf_alloc(ppriv->ca, ppriv->port, intf_name);
  	if (!priv) {
  		result = -ENOMEM;
  		goto out;
  	}
 -	ndev = priv->dev;
  
 -	result = __ipoib_vlan_add(ppriv, priv, pkey, IPOIB_LEGACY_CHILD);
 +	/*
 +	 * First ensure this isn't a duplicate. We check the parent device and
 +	 * then all of the legacy child interfaces to make sure the Pkey
 +	 * doesn't match.
 +	 */
 +	if (ppriv->pkey == pkey) {
 +		result = -ENOTUNIQ;
 +		goto out;
 +	}
++=======
++	ppriv = ipoib_priv(pdev);
++>>>>>>> 760109760455 (IB/ipoib: Consolidate checking of the proposed child interface)
 +
- 	list_for_each_entry(tpriv, &ppriv->child_intfs, list) {
- 		if (tpriv->pkey == pkey &&
- 		    tpriv->child_type == IPOIB_LEGACY_CHILD) {
- 			result = -ENOTUNIQ;
- 			goto out;
- 		}
- 	}
++	snprintf(intf_name, sizeof(intf_name), "%s.%04x",
++		 ppriv->dev->name, pkey);
  
 -	if (result && ndev->reg_state == NETREG_UNINITIALIZED)
 -		free_netdev(ndev);
 +	result = __ipoib_vlan_add(ppriv, priv, pkey, IPOIB_LEGACY_CHILD);
  
  out:
 +	up_write(&ppriv->vlan_rwsem);
  	rtnl_unlock();
 +	mutex_unlock(&ppriv->sysfs_mutex);
  
 -	return result;
 -}
 -
 -struct ipoib_vlan_delete_work {
 -	struct work_struct work;
 -	struct net_device *dev;
 -};
 -
 -/*
 - * sysfs callbacks of a netdevice cannot obtain the rtnl lock as
 - * unregister_netdev ultimately deletes the sysfs files while holding the rtnl
 - * lock. This deadlocks the system.
 - *
 - * A callback can use rtnl_trylock to avoid the deadlock but it cannot call
 - * unregister_netdev as that internally takes and releases the rtnl_lock.  So
 - * instead we find the netdev to unregister and then do the actual unregister
 - * from the global work queue where we can obtain the rtnl_lock safely.
 - */
 -static void ipoib_vlan_delete_task(struct work_struct *work)
 -{
 -	struct ipoib_vlan_delete_work *pwork =
 -		container_of(work, struct ipoib_vlan_delete_work, work);
 -	struct net_device *dev = pwork->dev;
 +	if (result && priv) {
 +		struct rdma_netdev *rn;
  
 -	rtnl_lock();
 -
 -	/* Unregistering tasks can race with another task or parent removal */
 -	if (dev->reg_state == NETREG_REGISTERED) {
 -		struct ipoib_dev_priv *priv = ipoib_priv(dev);
 -		struct ipoib_dev_priv *ppriv = ipoib_priv(priv->parent);
 -
 -		ipoib_dbg(ppriv, "delete child vlan %s\n", dev->name);
 -		unregister_netdevice(dev);
 +		rn = netdev_priv(priv->dev);
 +		rn->free_rdma_netdev(priv->dev);
 +		kfree(priv);
  	}
  
 -	rtnl_unlock();
 -
 -	kfree(pwork);
 +	return result;
  }
  
  int ipoib_vlan_delete(struct net_device *pdev, unsigned short pkey)
* Unmerged path drivers/infiniband/ulp/ipoib/ipoib_netlink.c
* Unmerged path drivers/infiniband/ulp/ipoib/ipoib_vlan.c
