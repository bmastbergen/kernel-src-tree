blk-mq: use plug for devices that implement ->commits_rqs()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit b2c5d16b72df1116f05c9be16a630ac939d34101
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/b2c5d16b.failed

If we have that hook, we know the driver handles bd->last == true in
a smart fashion. If it does, even for multiple hardware queues, it's
a good idea to flush batches of requests to the device, if we have
batches of requests from the submitter.

	Reviewed-by: Ming Lei <ming.lei@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit b2c5d16b72df1116f05c9be16a630ac939d34101)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index 519da1c104b3,7dcef565dc0f..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -1903,7 -1945,12 +1903,16 @@@ static blk_qc_t blk_mq_make_request(str
  		/* bypass scheduler for flush rq */
  		blk_insert_flush(rq);
  		blk_mq_run_hw_queue(data.hctx, true);
++<<<<<<< HEAD
 +	} else if (plug && q->nr_hw_queues == 1) {
++=======
+ 	} else if (plug && (q->nr_hw_queues == 1 || q->mq_ops->commit_rqs)) {
+ 		/*
+ 		 * Use plugging if we have a ->commit_rqs() hook as well, as
+ 		 * we know the driver uses bd->last in a smart fashion.
+ 		 */
+ 		unsigned int request_count = plug->rq_count;
++>>>>>>> b2c5d16b72df (blk-mq: use plug for devices that implement ->commits_rqs())
  		struct request *last = NULL;
  
  		blk_mq_put_ctx(data.ctx);
* Unmerged path block/blk-mq.c
