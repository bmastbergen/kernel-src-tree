block: improve logic around when to sort a plug list

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit ce5b009cff1961137127edf91f44effd0eec8ffd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/ce5b009c.failed

Only do it if we have requests for multiple queues in the same
plug.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit ce5b009cff1961137127edf91f44effd0eec8ffd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-core.c
#	block/blk-mq.c
#	include/linux/blkdev.h
diff --cc block/blk-core.c
index 7df0c1244abd,d107d016b92b..000000000000
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@@ -3522,9 -1777,11 +3522,15 @@@ void blk_start_plug(struct blk_plug *pl
  	if (tsk->plug)
  		return;
  
 +	INIT_LIST_HEAD(&plug->list);
  	INIT_LIST_HEAD(&plug->mq_list);
  	INIT_LIST_HEAD(&plug->cb_list);
++<<<<<<< HEAD
++=======
+ 	plug->rq_count = 0;
+ 	plug->multiple_queues = false;
+ 
++>>>>>>> ce5b009cff19 (block: improve logic around when to sort a plug list)
  	/*
  	 * Store ordering should not be needed here, since a potential
  	 * preempt will imply a full memory barrier
diff --cc block/blk-mq.c
index 519da1c104b3,2a1a653a8054..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -1664,10 -1675,13 +1664,11 @@@ void blk_mq_flush_plug_list(struct blk_
  	unsigned int depth;
  
  	list_splice_init(&plug->mq_list, &list);
 -	plug->rq_count = 0;
  
- 	list_sort(NULL, &list, plug_rq_cmp);
+ 	if (plug->rq_count > 2 && plug->multiple_queues)
+ 		list_sort(NULL, &list, plug_rq_cmp);
  
  	this_q = NULL;
 -	this_hctx = NULL;
  	this_ctx = NULL;
  	depth = 0;
  
@@@ -1929,7 -1947,7 +1944,11 @@@ static blk_qc_t blk_mq_make_request(str
  			trace_block_plug(q);
  		}
  
++<<<<<<< HEAD
 +		list_add_tail(&rq->queuelist, &plug->mq_list);
++=======
+ 		blk_add_rq_to_plug(plug, rq);
++>>>>>>> ce5b009cff19 (block: improve logic around when to sort a plug list)
  	} else if (plug && !blk_queue_nomerges(q)) {
  		blk_mq_bio_to_request(rq, bio);
  
@@@ -1946,7 -1964,7 +1965,11 @@@
  			list_del_init(&same_queue_rq->queuelist);
  			plug->rq_count--;
  		}
++<<<<<<< HEAD
 +		list_add_tail(&rq->queuelist, &plug->mq_list);
++=======
+ 		blk_add_rq_to_plug(plug, rq);
++>>>>>>> ce5b009cff19 (block: improve logic around when to sort a plug list)
  
  		blk_mq_put_ctx(data.ctx);
  
diff --cc include/linux/blkdev.h
index d890005b9f66,08d940f85fa0..000000000000
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@@ -1260,9 -1128,10 +1260,14 @@@ extern void blk_set_queue_dying(struct 
   * schedule() where blk_schedule_flush_plug() is called.
   */
  struct blk_plug {
 +	struct list_head list; /* requests */
  	struct list_head mq_list; /* blk-mq requests */
  	struct list_head cb_list; /* md requires an unplug callback */
++<<<<<<< HEAD
++=======
+ 	unsigned short rq_count;
+ 	bool multiple_queues;
++>>>>>>> ce5b009cff19 (block: improve logic around when to sort a plug list)
  };
  #define BLK_MAX_REQUEST_COUNT 16
  #define BLK_PLUG_FLUSH_SIZE (128 * 1024)
* Unmerged path block/blk-core.c
* Unmerged path block/blk-mq.c
* Unmerged path include/linux/blkdev.h
