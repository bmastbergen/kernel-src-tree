netdevsim: add support for simultaneous driver and hw XDP

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 799e173d7125155c00e9492c8212c5e41333049f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/799e173d.failed

Allow netdevsim to accept driver and offload attachment of XDP
BPF programs at the same time.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Quentin Monnet <quentin.monnet@netronome.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 799e173d7125155c00e9492c8212c5e41333049f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/netdevsim/bpf.c
#	drivers/net/netdevsim/netdevsim.h
diff --cc drivers/net/netdevsim/bpf.c
index 712e6f918065,c36d2a768202..000000000000
--- a/drivers/net/netdevsim/bpf.c
+++ b/drivers/net/netdevsim/bpf.c
@@@ -199,10 -201,8 +201,14 @@@ nsim_xdp_set_prog(struct netdevsim *ns
  {
  	int err;
  
++<<<<<<< HEAD
 +	if (ns->xdp_prog && (bpf->flags ^ ns->xdp_flags) & XDP_FLAGS_MODES) {
 +		NSIM_EA(bpf->extack, "program loaded with different flags");
++=======
+ 	if (!xdp_attachment_flags_ok(xdp, bpf))
++>>>>>>> 799e173d7125 (netdevsim: add support for simultaneous driver and hw XDP)
  		return -EBUSY;
 +	}
  
  	if (bpf->command == XDP_SETUP_PROG && !ns->bpf_xdpdrv_accept) {
  		NSIM_EA(bpf->extack, "driver XDP disabled in DebugFS");
@@@ -219,18 -219,7 +225,22 @@@
  			return err;
  	}
  
++<<<<<<< HEAD
 +	if (ns->xdp_prog)
 +		bpf_prog_put(ns->xdp_prog);
 +
 +	ns->xdp_prog = bpf->prog;
 +	ns->xdp_flags = bpf->flags;
 +
 +	if (!bpf->prog)
 +		ns->xdp_prog_mode = XDP_ATTACHED_NONE;
 +	else if (bpf->command == XDP_SETUP_PROG)
 +		ns->xdp_prog_mode = XDP_ATTACHED_DRV;
 +	else
 +		ns->xdp_prog_mode = XDP_ATTACHED_HW;
++=======
+ 	xdp_attachment_setup(xdp, bpf);
++>>>>>>> 799e173d7125 (netdevsim: add support for simultaneous driver and hw XDP)
  
  	return 0;
  }
@@@ -567,9 -552,9 +573,15 @@@ int nsim_bpf(struct net_device *dev, st
  		nsim_bpf_destroy_prog(bpf->offload.prog);
  		return 0;
  	case XDP_QUERY_PROG:
++<<<<<<< HEAD
 +		bpf->prog_id = ns->xdp_prog ? ns->xdp_prog->aux->id : 0;
 +		bpf->prog_flags = ns->xdp_prog ? ns->xdp_flags : 0;
 +		return 0;
++=======
+ 		return xdp_attachment_query(&ns->xdp, bpf);
+ 	case XDP_QUERY_PROG_HW:
+ 		return xdp_attachment_query(&ns->xdp_hw, bpf);
++>>>>>>> 799e173d7125 (netdevsim: add support for simultaneous driver and hw XDP)
  	case XDP_SETUP_PROG:
  		err = nsim_setup_prog_checks(ns, bpf);
  		if (err)
@@@ -636,6 -621,7 +648,11 @@@ void nsim_bpf_uninit(struct netdevsim *
  {
  	WARN_ON(!list_empty(&ns->bpf_bound_progs));
  	WARN_ON(!list_empty(&ns->bpf_bound_maps));
++<<<<<<< HEAD
 +	WARN_ON(ns->xdp_prog);
++=======
+ 	WARN_ON(ns->xdp.prog);
+ 	WARN_ON(ns->xdp_hw.prog);
++>>>>>>> 799e173d7125 (netdevsim: add support for simultaneous driver and hw XDP)
  	WARN_ON(ns->bpf_offloaded);
  }
diff --cc drivers/net/netdevsim/netdevsim.h
index 8ca50b72c328,0aeabbe81cc6..000000000000
--- a/drivers/net/netdevsim/netdevsim.h
+++ b/drivers/net/netdevsim/netdevsim.h
@@@ -46,9 -68,8 +46,14 @@@ struct netdevsim 
  	struct bpf_prog	*bpf_offloaded;
  	u32 bpf_offloaded_id;
  
++<<<<<<< HEAD
 +	u32 xdp_flags;
 +	int xdp_prog_mode;
 +	struct bpf_prog	*xdp_prog;
++=======
+ 	struct xdp_attachment_info xdp;
+ 	struct xdp_attachment_info xdp_hw;
++>>>>>>> 799e173d7125 (netdevsim: add support for simultaneous driver and hw XDP)
  
  	u32 prog_id_gen;
  
* Unmerged path drivers/net/netdevsim/bpf.c
diff --git a/drivers/net/netdevsim/netdev.c b/drivers/net/netdevsim/netdev.c
index c9dacc6fcd59..7bcdd1fb919c 100644
--- a/drivers/net/netdevsim/netdev.c
+++ b/drivers/net/netdevsim/netdev.c
@@ -221,8 +221,7 @@ static int nsim_change_mtu(struct net_device *dev, int new_mtu)
 {
 	struct netdevsim *ns = netdev_priv(dev);
 
-	if (ns->xdp_prog_mode == XDP_ATTACHED_DRV &&
-	    new_mtu > NSIM_XDP_MAX_MTU)
+	if (ns->xdp.prog && new_mtu > NSIM_XDP_MAX_MTU)
 		return -EBUSY;
 
 	dev->mtu = new_mtu;
* Unmerged path drivers/net/netdevsim/netdevsim.h
diff --git a/tools/testing/selftests/bpf/test_offload.py b/tools/testing/selftests/bpf/test_offload.py
index be800d0e7a84..7a6ca517a101 100755
--- a/tools/testing/selftests/bpf/test_offload.py
+++ b/tools/testing/selftests/bpf/test_offload.py
@@ -814,20 +814,12 @@ try:
          "Device parameters reported for non-offloaded program")
 
     start_test("Test XDP prog replace with bad flags...")
-    ret, _, err = sim.set_xdp(obj, "offload", force=True,
-                              fail=False, include_stderr=True)
-    fail(ret == 0, "Replaced XDP program with a program in different mode")
-    check_extack_nsim(err, "program loaded with different flags.", args)
     ret, _, err = sim.set_xdp(obj, "", force=True,
                               fail=False, include_stderr=True)
     fail(ret == 0, "Replaced XDP program with a program in different mode")
     check_extack_nsim(err, "program loaded with different flags.", args)
 
     start_test("Test XDP prog remove with bad flags...")
-    ret, _, err = sim.unset_xdp("offload", force=True,
-                                fail=False, include_stderr=True)
-    fail(ret == 0, "Removed program with a bad mode mode")
-    check_extack_nsim(err, "program loaded with different flags.", args)
     ret, _, err = sim.unset_xdp("", force=True,
                                 fail=False, include_stderr=True)
     fail(ret == 0, "Removed program with a bad mode mode")
