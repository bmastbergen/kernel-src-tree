blkcg: remove bio->bi_css and instead use bio->bi_blkg

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Dennis Zhou (Facebook) <dennisszhou@gmail.com>
commit c839e7a03f92bafd71fd145b470dcdc7f43f2d4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/c839e7a0.failed

Prior patches ensured that all bios are now associated with some blkg.
This now makes bio->bi_css unnecessary as blkg maintains a reference to
the blkcg already.

This patch removes the field bi_css and transfers corresponding uses to
access via bi_blkg.

	Signed-off-by: Dennis Zhou <dennisszhou@gmail.com>
	Reviewed-by: Josef Bacik <josef@toxicpanda.com>
	Acked-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit c839e7a03f92bafd71fd145b470dcdc7f43f2d4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/bio.c
#	include/linux/bio.h
diff --cc block/bio.c
index 8d70c85b6b8f,71cfe3720ea7..000000000000
--- a/block/bio.c
+++ b/block/bio.c
@@@ -610,7 -609,9 +610,13 @@@ void __bio_clone_fast(struct bio *bio, 
  	bio->bi_iter = bio_src->bi_iter;
  	bio->bi_io_vec = bio_src->bi_io_vec;
  
++<<<<<<< HEAD
 +	bio_clone_blkcg_association(bio, bio_src);
++=======
+ 	bio_clone_blkg_association(bio, bio_src);
+ 
+ 	blkcg_bio_issue_init(bio);
++>>>>>>> c839e7a03f92 (blkcg: remove bio->bi_css and instead use bio->bi_blkg)
  }
  EXPORT_SYMBOL(__bio_clone_fast);
  
@@@ -1956,60 -1956,8 +1962,64 @@@ EXPORT_SYMBOL(bioset_init_from_src)
  
  #ifdef CONFIG_BLK_CGROUP
  
 +#ifdef CONFIG_MEMCG
 +/**
 + * bio_associate_blkcg_from_page - associate a bio with the page's blkcg
 + * @bio: target bio
 + * @page: the page to lookup the blkcg from
 + *
 + * Associate @bio with the blkcg from @page's owning memcg.  This works like
 + * every other associate function wrt references.
 + */
 +int bio_associate_blkcg_from_page(struct bio *bio, struct page *page)
 +{
 +	struct cgroup_subsys_state *blkcg_css;
 +
 +	if (unlikely(bio->bi_css))
 +		return -EBUSY;
 +	if (!page->mem_cgroup)
 +		return 0;
 +	blkcg_css = cgroup_get_e_css(page->mem_cgroup->css.cgroup,
 +				     &io_cgrp_subsys);
 +	bio->bi_css = blkcg_css;
 +	return 0;
 +}
 +#endif /* CONFIG_MEMCG */
 +
 +/**
++<<<<<<< HEAD
 + * bio_associate_blkcg - associate a bio with the specified blkcg
 + * @bio: target bio
 + * @blkcg_css: css of the blkcg to associate
 + *
 + * Associate @bio with the blkcg specified by @blkcg_css.  Block layer will
 + * treat @bio as if it were issued by a task which belongs to the blkcg.
 + *
 + * This function takes an extra reference of @blkcg_css which will be put
 + * when @bio is released.  The caller must own @bio and is responsible for
 + * synchronizing calls to this function.  If @blkcg_css is %NULL, a call to
 + * blkcg_get_css() finds the current css from the kthread or task.
 + */
 +int bio_associate_blkcg(struct bio *bio, struct cgroup_subsys_state *blkcg_css)
 +{
 +	if (unlikely(bio->bi_css))
 +		return -EBUSY;
 +
 +	if (blkcg_css)
 +		css_get(blkcg_css);
 +	else
 +		blkcg_css = blkcg_get_css();
 +
 +	bio->bi_css = blkcg_css;
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(bio_associate_blkcg);
 +
  /**
 + * bio_associate_blkg - associate a bio with the specified blkg
++=======
+  * bio_associate_blkg - associate a bio with the a blkg
++>>>>>>> c839e7a03f92 (blkcg: remove bio->bi_css and instead use bio->bi_blkg)
   * @bio: target bio
   * @blkg: the blkg to associate
   *
@@@ -2027,6 -1978,97 +2037,100 @@@ int bio_associate_blkg(struct bio *bio
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int __bio_associate_blkg_from_css(struct bio *bio,
+ 					 struct cgroup_subsys_state *css)
+ {
+ 	struct blkcg_gq *blkg;
+ 
+ 	rcu_read_lock();
+ 
+ 	blkg = blkg_lookup_create(css_to_blkcg(css), bio->bi_disk->queue);
+ 
+ 	rcu_read_unlock();
+ 
+ 	return bio_associate_blkg(bio, blkg);
+ }
+ 
+ /**
+  * bio_associate_blkg_from_css - associate a bio with a specified css
+  * @bio: target bio
+  * @css: target css
+  *
+  * Associate @bio with the blkg found by combining the css's blkg and the
+  * request_queue of the @bio.  This takes a reference on the css that will
+  * be put upon freeing of @bio.
+  */
+ int bio_associate_blkg_from_css(struct bio *bio,
+ 				struct cgroup_subsys_state *css)
+ {
+ 	css_get(css);
+ 	return __bio_associate_blkg_from_css(bio, css);
+ }
+ EXPORT_SYMBOL_GPL(bio_associate_blkg_from_css);
+ 
+ #ifdef CONFIG_MEMCG
+ /**
+  * bio_associate_blkg_from_page - associate a bio with the page's blkg
+  * @bio: target bio
+  * @page: the page to lookup the blkcg from
+  *
+  * Associate @bio with the blkg from @page's owning memcg and the respective
+  * request_queue.  This works like every other associate function wrt
+  * references.
+  *
+  * Note: this must be called after bio has an associated device.
+  */
+ int bio_associate_blkg_from_page(struct bio *bio, struct page *page)
+ {
+ 	struct cgroup_subsys_state *css;
+ 
+ 	if (unlikely(bio->bi_blkg))
+ 		return -EBUSY;
+ 	if (!page->mem_cgroup)
+ 		return 0;
+ 	css = cgroup_get_e_css(page->mem_cgroup->css.cgroup, &io_cgrp_subsys);
+ 
+ 	return __bio_associate_blkg_from_css(bio, css);
+ }
+ #endif /* CONFIG_MEMCG */
+ 
+ /**
+  * bio_associate_create_blkg - associate a bio with a blkg from q
+  * @q: request_queue where bio is going
+  * @bio: target bio
+  *
+  * Associate @bio with the blkg found from the bio's css and the request_queue.
+  * If one is not found, bio_lookup_blkg creates the blkg.
+  */
+ int bio_associate_create_blkg(struct request_queue *q, struct bio *bio)
+ {
+ 	struct blkcg *blkcg;
+ 	struct blkcg_gq *blkg;
+ 	int ret = 0;
+ 
+ 	/* someone has already associated this bio with a blkg */
+ 	if (bio->bi_blkg)
+ 		return ret;
+ 
+ 	rcu_read_lock();
+ 
+ 	blkcg = css_to_blkcg(blkcg_get_css());
+ 
+ 	if (!blkcg->css.parent) {
+ 		ret = bio_associate_blkg(bio, q->root_blkg);
+ 	} else {
+ 		blkg = blkg_lookup_create(blkcg, q);
+ 
+ 		ret = bio_associate_blkg(bio, blkg);
+ 	}
+ 
+ 	rcu_read_unlock();
+ 	return ret;
+ }
+ 
++>>>>>>> c839e7a03f92 (blkcg: remove bio->bi_css and instead use bio->bi_blkg)
  /**
   * bio_disassociate_task - undo bio_associate_current()
   * @bio: target bio
@@@ -2052,12 -2092,14 +2154,19 @@@ void bio_disassociate_task(struct bio *
   * @dst: destination bio
   * @src: source bio
   */
- void bio_clone_blkcg_association(struct bio *dst, struct bio *src)
+ void bio_clone_blkg_association(struct bio *dst, struct bio *src)
  {
++<<<<<<< HEAD
 +	if (src->bi_css)
 +		WARN_ON(bio_associate_blkcg(dst, src->bi_css));
++=======
+ 	if (src->bi_blkg) {
+ 		css_get(&bio_blkcg(src)->css);
+ 		bio_associate_blkg(dst, src->bi_blkg);
+ 	}
++>>>>>>> c839e7a03f92 (blkcg: remove bio->bi_css and instead use bio->bi_blkg)
  }
- EXPORT_SYMBOL_GPL(bio_clone_blkcg_association);
+ EXPORT_SYMBOL_GPL(bio_clone_blkg_association);
  #endif /* CONFIG_BLK_CGROUP */
  
  static void __init biovec_init_slabs(void)
diff --cc include/linux/bio.h
index 056fb627edb3,e973876625a8..000000000000
--- a/include/linux/bio.h
+++ b/include/linux/bio.h
@@@ -510,16 -540,21 +510,23 @@@ static inline int bio_associate_blkcg_f
  #endif
  
  #ifdef CONFIG_BLK_CGROUP
- int bio_associate_blkcg(struct bio *bio, struct cgroup_subsys_state *blkcg_css);
  int bio_associate_blkg(struct bio *bio, struct blkcg_gq *blkg);
 -int bio_associate_blkg_from_css(struct bio *bio,
 -				struct cgroup_subsys_state *css);
 -int bio_associate_create_blkg(struct request_queue *q, struct bio *bio);
  void bio_disassociate_task(struct bio *bio);
- void bio_clone_blkcg_association(struct bio *dst, struct bio *src);
+ void bio_clone_blkg_association(struct bio *dst, struct bio *src);
  #else	/* CONFIG_BLK_CGROUP */
++<<<<<<< HEAD
 +static inline int bio_associate_blkcg(struct bio *bio,
 +			struct cgroup_subsys_state *blkcg_css) { return 0; }
++=======
+ static inline int bio_associate_blkg_from_css(struct bio *bio,
+ 					      struct cgroup_subsys_state *css)
+ { return 0; }
+ static inline int bio_associate_create_blkg(struct request_queue *q,
+ 					    struct bio *bio) { return 0; }
++>>>>>>> c839e7a03f92 (blkcg: remove bio->bi_css and instead use bio->bi_blkg)
  static inline void bio_disassociate_task(struct bio *bio) { }
- static inline void bio_clone_blkcg_association(struct bio *dst,
- 			struct bio *src) { }
+ static inline void bio_clone_blkg_association(struct bio *dst,
+ 					      struct bio *src) { }
  #endif	/* CONFIG_BLK_CGROUP */
  
  #ifdef CONFIG_HIGHMEM
* Unmerged path block/bio.c
diff --git a/block/bounce.c b/block/bounce.c
index a2d951197420..e0d6ad7ce5ba 100644
--- a/block/bounce.c
+++ b/block/bounce.c
@@ -258,7 +258,7 @@ static struct bio *bounce_clone_bio(struct bio *bio_src, gfp_t gfp_mask,
 		}
 	}
 
-	bio_clone_blkcg_association(bio, bio_src);
+	bio_clone_blkg_association(bio, bio_src);
 
 	return bio;
 }
diff --git a/drivers/block/loop.c b/drivers/block/loop.c
index ea9debf59b22..abad6d15f956 100644
--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@ -77,6 +77,7 @@
 #include <linux/falloc.h>
 #include <linux/uio.h>
 #include <linux/ioprio.h>
+#include <linux/blk-cgroup.h>
 
 #include "loop.h"
 
@@ -1760,8 +1761,8 @@ static blk_status_t loop_queue_rq(struct blk_mq_hw_ctx *hctx,
 
 	/* always use the first bio's css */
 #ifdef CONFIG_BLK_CGROUP
-	if (cmd->use_aio && rq->bio && rq->bio->bi_css) {
-		cmd->css = rq->bio->bi_css;
+	if (cmd->use_aio && rq->bio && rq->bio->bi_blkg) {
+		cmd->css = &bio_blkcg(rq->bio)->css;
 		css_get(cmd->css);
 	} else
 #endif
diff --git a/drivers/md/raid0.c b/drivers/md/raid0.c
index ac1cffd2a09b..f3fb5bb8c82a 100644
--- a/drivers/md/raid0.c
+++ b/drivers/md/raid0.c
@@ -542,7 +542,7 @@ static void raid0_handle_discard(struct mddev *mddev, struct bio *bio)
 		    !discard_bio)
 			continue;
 		bio_chain(discard_bio, bio);
-		bio_clone_blkcg_association(discard_bio, bio);
+		bio_clone_blkg_association(discard_bio, bio);
 		if (mddev->gendisk)
 			trace_block_bio_remap(bdev_get_queue(rdev->bdev),
 				discard_bio, disk_devt(mddev->gendisk),
* Unmerged path include/linux/bio.h
diff --git a/include/linux/blk-cgroup.h b/include/linux/blk-cgroup.h
index 8bf2308b920c..64934932527b 100644
--- a/include/linux/blk-cgroup.h
+++ b/include/linux/blk-cgroup.h
@@ -309,8 +309,8 @@ static inline struct blkcg *css_to_blkcg(struct cgroup_subsys_state *css)
  */
 static inline struct blkcg *__bio_blkcg(struct bio *bio)
 {
-	if (bio && bio->bi_css)
-		return css_to_blkcg(bio->bi_css);
+	if (bio && bio->bi_blkg)
+		return bio->bi_blkg->blkcg;
 	return css_to_blkcg(blkcg_css());
 }
 
@@ -324,8 +324,8 @@ static inline struct blkcg *__bio_blkcg(struct bio *bio)
  */
 static inline struct blkcg *bio_blkcg(struct bio *bio)
 {
-	if (bio && bio->bi_css)
-		return css_to_blkcg(bio->bi_css);
+	if (bio && bio->bi_blkg)
+		return bio->bi_blkg->blkcg;
 	return NULL;
 }
 
diff --git a/include/linux/blk_types.h b/include/linux/blk_types.h
index dbdbfbd6a987..d6c2558d6b73 100644
--- a/include/linux/blk_types.h
+++ b/include/linux/blk_types.h
@@ -178,7 +178,6 @@ struct bio {
 	 * release.  Read comment on top of bio_associate_current().
 	 */
 	struct io_context	*bi_ioc;
-	struct cgroup_subsys_state *bi_css;
 	struct blkcg_gq		*bi_blkg;
 	struct bio_issue	bi_issue;
 #endif
diff --git a/kernel/trace/blktrace.c b/kernel/trace/blktrace.c
index 96457ad8d720..3861c64fff4d 100644
--- a/kernel/trace/blktrace.c
+++ b/kernel/trace/blktrace.c
@@ -776,9 +776,9 @@ blk_trace_bio_get_cgid(struct request_queue *q, struct bio *bio)
 	if (!bt || !(blk_tracer_flags.val & TRACE_BLK_OPT_CGROUP))
 		return NULL;
 
-	if (!bio->bi_css)
+	if (!bio->bi_blkg)
 		return NULL;
-	return cgroup_get_kernfs_id(bio->bi_css->cgroup);
+	return cgroup_get_kernfs_id(bio_blkcg(bio)->css.cgroup);
 }
 #else
 static union kernfs_node_id *
