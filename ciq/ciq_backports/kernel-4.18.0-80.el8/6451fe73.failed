nvme: fix irq vs io_queue calculations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit 6451fe73fa0f542a49bfacd7205b88a597897f58
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/6451fe73.failed

Guenter reported an boot hang issue on HPPA after we default to 0 poll
queues. We have two issues in the queue count calculations:

1) We don't separate the poll queues from the read/write queues. This is
   important, since the former doesn't need interrupts.
2) The adjust logic is broken.

Adjust the poll queue count before doing nvme_calc_io_queues(). The poll
queue count is only limited by the IO queue count we were able to get
from the controller, not failures in the IRQ allocation loop. This
leaves nvme_calc_io_queues() just adjusting the read/write queue map.

	Reported-by: Reported-by: Guenter Roeck <linux@roeck-us.net>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 6451fe73fa0f542a49bfacd7205b88a597897f58)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/pci.c
diff --cc drivers/nvme/host/pci.c
index e63d03795df8,fb9d8270f32c..000000000000
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@@ -2046,32 -2037,13 +2045,41 @@@ static void nvme_calc_io_queues(struct 
  	/*
  	 * Setup read/write queue split
  	 */
++<<<<<<< HEAD
 +	if (nr_io_queues == 1) {
 +		dev->io_queues[NVMEQ_TYPE_READ] = 1;
 +		dev->io_queues[NVMEQ_TYPE_WRITE] = 0;
 +		dev->io_queues[NVMEQ_TYPE_POLL] = 0;
++=======
+ 	if (irq_queues == 1) {
+ 		dev->io_queues[HCTX_TYPE_DEFAULT] = 1;
+ 		dev->io_queues[HCTX_TYPE_READ] = 0;
++>>>>>>> 6451fe73fa0f (nvme: fix irq vs io_queue calculations)
  		return;
  	}
  
  	/*
++<<<<<<< HEAD
 +	 * Configure number of poll queues, if set
 +	 */
 +	if (this_p_queues) {
 +		/*
 +		 * We need at least one queue left. With just one queue, we'll
 +		 * have a single shared read/write set.
 +		 */
 +		if (this_p_queues >= nr_io_queues) {
 +			this_w_queues = 0;
 +			this_p_queues = nr_io_queues - 1;
 +		}
 +
 +		dev->io_queues[NVMEQ_TYPE_POLL] = this_p_queues;
 +		nr_io_queues -= this_p_queues;
 +	} else
 +		dev->io_queues[NVMEQ_TYPE_POLL] = 0;
 +
 +	/*
++=======
++>>>>>>> 6451fe73fa0f (nvme: fix irq vs io_queue calculations)
  	 * If 'write_queues' is set, ensure it leaves room for at least
  	 * one read queue
  	 */
@@@ -2083,11 -2055,11 +2091,19 @@@
  	 * a queue set.
  	 */
  	if (!this_w_queues) {
++<<<<<<< HEAD
 +		dev->io_queues[NVMEQ_TYPE_WRITE] = 0;
 +		dev->io_queues[NVMEQ_TYPE_READ] = nr_io_queues;
 +	} else {
 +		dev->io_queues[NVMEQ_TYPE_WRITE] = this_w_queues;
 +		dev->io_queues[NVMEQ_TYPE_READ] = nr_io_queues - this_w_queues;
++=======
+ 		dev->io_queues[HCTX_TYPE_DEFAULT] = irq_queues;
+ 		dev->io_queues[HCTX_TYPE_READ] = 0;
+ 	} else {
+ 		dev->io_queues[HCTX_TYPE_DEFAULT] = this_w_queues;
+ 		dev->io_queues[HCTX_TYPE_READ] = irq_queues - this_w_queues;
++>>>>>>> 6451fe73fa0f (nvme: fix irq vs io_queue calculations)
  	}
  }
  
@@@ -2108,9 -2094,9 +2138,15 @@@ static int nvme_setup_irqs(struct nvme_
  	 * IRQ vector needs.
  	 */
  	do {
++<<<<<<< HEAD
 +		nvme_calc_io_queues(dev, nr_io_queues);
 +		irq_sets[0] = dev->io_queues[NVMEQ_TYPE_READ];
 +		irq_sets[1] = dev->io_queues[NVMEQ_TYPE_WRITE];
++=======
+ 		nvme_calc_io_queues(dev, irq_queues);
+ 		irq_sets[0] = dev->io_queues[HCTX_TYPE_DEFAULT];
+ 		irq_sets[1] = dev->io_queues[HCTX_TYPE_READ];
++>>>>>>> 6451fe73fa0f (nvme: fix irq vs io_queue calculations)
  		if (!irq_sets[1])
  			affd.nr_sets = 1;
  
* Unmerged path drivers/nvme/host/pci.c
