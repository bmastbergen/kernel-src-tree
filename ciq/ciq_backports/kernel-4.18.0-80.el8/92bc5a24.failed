block: remove __blk_put_request()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit 92bc5a24844ada9b010f03c49a493e3edeadaa54
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/92bc5a24.failed

Now there's no difference between blk_put_request() and
__blk_put_request() anymore, get rid of the underscore version and
convert the few callers.

	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Tested-by: Ming Lei <ming.lei@redhat.com>
	Reviewed-by: Omar Sandoval <osandov@fb.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 92bc5a24844ada9b010f03c49a493e3edeadaa54)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-core.c
diff --cc block/blk-core.c
index 8d851985fd1d,700dd4587282..000000000000
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@@ -1728,63 -803,9 +1728,66 @@@ void part_round_stats(struct request_qu
  }
  EXPORT_SYMBOL_GPL(part_round_stats);
  
++<<<<<<< HEAD
 +void __blk_put_request(struct request_queue *q, struct request *req)
 +{
 +	req_flags_t rq_flags = req->rq_flags;
 +
 +	if (unlikely(!q))
 +		return;
 +
 +	if (q->mq_ops) {
 +		blk_mq_free_request(req);
 +		return;
 +	}
 +
 +	lockdep_assert_held(q->queue_lock);
 +
 +	blk_req_zone_write_unlock(req);
 +	blk_pm_put_request(req);
 +	blk_pm_mark_last_busy(req);
 +
 +	elv_completed_request(q, req);
 +
 +	/* this is a bio leak */
 +	WARN_ON(req->bio != NULL);
 +
 +	rq_qos_done(q, req);
 +
 +	/*
 +	 * Request may not have originated from ll_rw_blk. if not,
 +	 * it didn't come out of our reserved rq pools
 +	 */
 +	if (rq_flags & RQF_ALLOCED) {
 +		struct request_list *rl = blk_rq_rl(req);
 +		bool sync = op_is_sync(req->cmd_flags);
 +
 +		BUG_ON(!list_empty(&req->queuelist));
 +		BUG_ON(ELV_ON_HASH(req));
 +
 +		blk_free_request(rl, req);
 +		freed_request(rl, sync, rq_flags);
 +		blk_put_rl(rl);
 +		blk_queue_exit(q);
 +	}
 +}
 +EXPORT_SYMBOL_GPL(__blk_put_request);
 +
++=======
++>>>>>>> 92bc5a24844a (block: remove __blk_put_request())
  void blk_put_request(struct request *req)
  {
 -	blk_mq_free_request(req);
 +	struct request_queue *q = req->q;
 +
 +	if (q->mq_ops)
 +		blk_mq_free_request(req);
 +	else {
 +		unsigned long flags;
 +
 +		spin_lock_irqsave(q->queue_lock, flags);
 +		__blk_put_request(q, req);
 +		spin_unlock_irqrestore(q->queue_lock, flags);
 +	}
  }
  EXPORT_SYMBOL(blk_put_request);
  
* Unmerged path block/blk-core.c
diff --git a/block/blk-merge.c b/block/blk-merge.c
index e7696c47489a..2224b28c7478 100644
--- a/block/blk-merge.c
+++ b/block/blk-merge.c
@@ -872,7 +872,7 @@ int blk_attempt_req_merge(struct request_queue *q, struct request *rq,
 
 	free = attempt_merge(q, rq, next);
 	if (free) {
-		__blk_put_request(q, free);
+		blk_put_request(free);
 		return 1;
 	}
 
diff --git a/drivers/scsi/osd/osd_initiator.c b/drivers/scsi/osd/osd_initiator.c
index e19fa883376f..60cf7c5eb880 100644
--- a/drivers/scsi/osd/osd_initiator.c
+++ b/drivers/scsi/osd/osd_initiator.c
@@ -506,11 +506,11 @@ static void osd_request_async_done(struct request *req, blk_status_t error)
 
 	_set_error_resid(or, req, error);
 	if (req->next_rq) {
-		__blk_put_request(req->q, req->next_rq);
+		blk_put_request(req->next_rq);
 		req->next_rq = NULL;
 	}
 
-	__blk_put_request(req->q, req);
+	blk_put_request(req);
 	or->request = NULL;
 	or->in.req = NULL;
 	or->out.req = NULL;
diff --git a/drivers/scsi/osst.c b/drivers/scsi/osst.c
index 7a1a1edde35d..664c1238a87f 100644
--- a/drivers/scsi/osst.c
+++ b/drivers/scsi/osst.c
@@ -341,7 +341,7 @@ static void osst_end_async(struct request *req, blk_status_t status)
 		blk_rq_unmap_user(SRpnt->bio);
 	}
 
-	__blk_put_request(req->q, req);
+	blk_put_request(req);
 }
 
 /* osst_request memory management */
diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index 7cc43290a568..56dcdac21dfb 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -1935,7 +1935,7 @@ int scsi_decide_disposition(struct scsi_cmnd *scmd)
 
 static void eh_lock_door_done(struct request *req, blk_status_t status)
 {
-	__blk_put_request(req->q, req);
+	blk_put_request(req);
 }
 
 /**
diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c
index 5b36fb51263e..67a75bcb4f4d 100644
--- a/drivers/scsi/sg.c
+++ b/drivers/scsi/sg.c
@@ -1399,7 +1399,7 @@ sg_rq_end_io(struct request *rq, blk_status_t status)
 	 */
 	srp->rq = NULL;
 	scsi_req_free_cmd(scsi_req(rq));
-	__blk_put_request(rq->q, rq);
+	blk_put_request(rq);
 
 	write_lock_irqsave(&sfp->rq_list_lock, iflags);
 	if (unlikely(srp->orphan)) {
diff --git a/drivers/scsi/st.c b/drivers/scsi/st.c
index 50c66ccc4b41..27d48064cc92 100644
--- a/drivers/scsi/st.c
+++ b/drivers/scsi/st.c
@@ -530,7 +530,7 @@ static void st_scsi_execute_end(struct request *req, blk_status_t status)
 		complete(SRpnt->waiting);
 
 	blk_rq_unmap_user(tmp);
-	__blk_put_request(req->q, req);
+	blk_put_request(req);
 }
 
 static int st_scsi_execute(struct st_request *SRpnt, const unsigned char *cmd,
diff --git a/drivers/target/target_core_pscsi.c b/drivers/target/target_core_pscsi.c
index 47d76c862014..c062d363dce3 100644
--- a/drivers/target/target_core_pscsi.c
+++ b/drivers/target/target_core_pscsi.c
@@ -1094,7 +1094,7 @@ static void pscsi_req_done(struct request *req, blk_status_t status)
 		break;
 	}
 
-	__blk_put_request(req->q, req);
+	blk_put_request(req);
 	kfree(pt);
 }
 
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 3848b29b455c..aff14ce550d1 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -951,7 +951,6 @@ extern blk_qc_t direct_make_request(struct bio *bio);
 extern void blk_rq_init(struct request_queue *q, struct request *rq);
 extern void blk_init_request_from_bio(struct request *req, struct bio *bio);
 extern void blk_put_request(struct request *);
-extern void __blk_put_request(struct request_queue *, struct request *);
 extern struct request *blk_get_request(struct request_queue *, unsigned int op,
 				       blk_mq_req_flags_t flags);
 extern void blk_requeue_request(struct request_queue *, struct request *);
