scsi: megaraid_sas: add retry logic in megasas_readl

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
Rebuild_CHGLOG: - [scsi] megaraid_sas: add retry logic in megasas_readl (Tomas Henzl) [1659972]
Rebuild_FUZZ: 93.88%
commit-author Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
commit 272652fcbf1adf6321efe288583fa4a30a15af31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/272652fc.failed

Due to hardware errata in Aero controllers, reads to certain fusion
registers could intermittently return zero.  This behavior is
transient in nature and subsequent reads will return valid value.

For Aero controllers, any calls to readl to read from certain
registers will be retried for maximum three times, if read returns
zero.

	Signed-off-by: Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 272652fcbf1adf6321efe288583fa4a30a15af31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas_base.c
#	drivers/scsi/megaraid/megaraid_sas_fusion.c
diff --cc drivers/scsi/megaraid/megaraid_sas_base.c
index ff5c2d50b7b6,d0f4075fe36e..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@@ -5302,10 -5422,11 +5325,18 @@@ static int megasas_init_fw(struct megas
  
  	fusion = instance->ctrl_context;
  
++<<<<<<< HEAD
 +	if (instance->adapter_type == VENTURA_SERIES) {
 +		scratch_pad_3 =
 +			readl(&instance->reg_set->outbound_scratch_pad_3);
 +		instance->max_raid_mapsize = ((scratch_pad_3 >>
++=======
+ 	if (instance->adapter_type >= VENTURA_SERIES) {
+ 		scratch_pad_2 =
+ 			megasas_readl(instance,
+ 				      &instance->reg_set->outbound_scratch_pad_2);
+ 		instance->max_raid_mapsize = ((scratch_pad_2 >>
++>>>>>>> 272652fcbf1a (scsi: megaraid_sas: add retry logic in megasas_readl)
  			MR_MAX_RAID_MAP_SIZE_OFFSET_SHIFT) &
  			MR_MAX_RAID_MAP_SIZE_MASK);
  	}
@@@ -5316,8 -5437,8 +5347,13 @@@
  	if (msix_enable && !msix_disable) {
  		int irq_flags = PCI_IRQ_MSIX;
  
++<<<<<<< HEAD
 +		scratch_pad_2 = readl
 +			(&instance->reg_set->outbound_scratch_pad_2);
++=======
+ 		scratch_pad_1 = megasas_readl
+ 			(instance, &instance->reg_set->outbound_scratch_pad_1);
++>>>>>>> 272652fcbf1a (scsi: megaraid_sas: add retry logic in megasas_readl)
  		/* Check max MSI-X vectors */
  		if (fusion) {
  			if (instance->adapter_type == THUNDERBOLT_SERIES) {
@@@ -5408,13 -5547,14 +5444,21 @@@
  	if (instance->instancet->init_adapter(instance))
  		goto fail_init_adapter;
  
++<<<<<<< HEAD
 +	if (instance->adapter_type == VENTURA_SERIES) {
 +		scratch_pad_4 =
 +			readl(&instance->reg_set->outbound_scratch_pad_4);
 +		if ((scratch_pad_4 & MR_NVME_PAGE_SIZE_MASK) >=
++=======
+ 	if (instance->adapter_type >= VENTURA_SERIES) {
+ 		scratch_pad_3 =
+ 			megasas_readl(instance,
+ 				      &instance->reg_set->outbound_scratch_pad_3);
+ 		if ((scratch_pad_3 & MR_NVME_PAGE_SIZE_MASK) >=
++>>>>>>> 272652fcbf1a (scsi: megaraid_sas: add retry logic in megasas_readl)
  			MR_DEFAULT_NVME_PAGE_SHIFT)
  			instance->nvme_page_size =
 -				(1 << (scratch_pad_3 & MR_NVME_PAGE_SIZE_MASK));
 +				(1 << (scratch_pad_4 & MR_NVME_PAGE_SIZE_MASK));
  
  		dev_info(&instance->pdev->dev,
  			 "NVME page size\t: (%d)\n", instance->nvme_page_size);
@@@ -6061,10 -6218,10 +6105,15 @@@ megasas_set_dma_mask(struct megasas_ins
  			 * If 32 bit DMA mask fails, then try for 64 bit mask
  			 * for FW capable of handling 64 bit DMA.
  			 */
++<<<<<<< HEAD
 +			scratch_pad_2 = readl
 +				(&instance->reg_set->outbound_scratch_pad_2);
++=======
+ 			scratch_pad_1 = megasas_readl
+ 				(instance, &instance->reg_set->outbound_scratch_pad_1);
++>>>>>>> 272652fcbf1a (scsi: megaraid_sas: add retry logic in megasas_readl)
  
 -			if (!(scratch_pad_1 & MR_CAN_HANDLE_64_BIT_DMA_OFFSET))
 +			if (!(scratch_pad_2 & MR_CAN_HANDLE_64_BIT_DMA_OFFSET))
  				goto fail_set_dma_mask;
  			else if (dma_set_mask_and_coherent(&pdev->dev,
  							   DMA_BIT_MASK(64)))
diff --cc drivers/scsi/megaraid/megaraid_sas_fusion.c
index c7f95bace353,50e2ed865041..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@@ -95,6 -94,9 +95,12 @@@ static void megasas_free_rdpq_fusion(st
  static void megasas_free_reply_fusion(struct megasas_instance *instance);
  static inline
  void megasas_configure_queue_sizes(struct megasas_instance *instance);
++<<<<<<< HEAD
++=======
+ static void megasas_fusion_crash_dump(struct megasas_instance *instance);
+ extern u32 megasas_readl(struct megasas_instance *instance,
+ 			 const volatile void __iomem *addr);
++>>>>>>> 272652fcbf1a (scsi: megaraid_sas: add retry logic in megasas_readl)
  
  /**
   * megasas_check_same_4gb_region -	check if allocation
@@@ -262,16 -266,17 +268,21 @@@ megasas_fusion_update_can_queue(struct 
  
  	reg_set = instance->reg_set;
  
 -	/* ventura FW does not fill outbound_scratch_pad_2 with queue depth */
 +	/* ventura FW does not fill outbound_scratch_pad_3 with queue depth */
  	if (instance->adapter_type < VENTURA_SERIES)
  		cur_max_fw_cmds =
++<<<<<<< HEAD
 +		readl(&instance->reg_set->outbound_scratch_pad_3) & 0x00FFFF;
++=======
+ 		megasas_readl(instance,
+ 			      &instance->reg_set->outbound_scratch_pad_2) & 0x00FFFF;
++>>>>>>> 272652fcbf1a (scsi: megaraid_sas: add retry logic in megasas_readl)
  
  	if (dual_qdepth_disable || !cur_max_fw_cmds)
 -		cur_max_fw_cmds = instance->instancet->read_fw_status_reg(instance) & 0x00FFFF;
 +		cur_max_fw_cmds = instance->instancet->read_fw_status_reg(reg_set) & 0x00FFFF;
  	else
  		ldio_threshold =
 -			(instance->instancet->read_fw_status_reg(instance) & 0x00FFFF) - MEGASAS_FUSION_IOCTL_CMDS;
 +			(instance->instancet->read_fw_status_reg(reg_set) & 0x00FFFF) - MEGASAS_FUSION_IOCTL_CMDS;
  
  	dev_info(&instance->pdev->dev,
  		 "Current firmware supports maximum commands: %d\t LDIO threshold: %d\n",
@@@ -985,10 -987,10 +996,15 @@@ megasas_ioc_init_fusion(struct megasas_
  
  	cmd = fusion->ioc_init_cmd;
  
++<<<<<<< HEAD
 +	scratch_pad_2 = readl
 +		(&instance->reg_set->outbound_scratch_pad_2);
++=======
+ 	scratch_pad_1 = megasas_readl
+ 		(instance, &instance->reg_set->outbound_scratch_pad_1);
++>>>>>>> 272652fcbf1a (scsi: megaraid_sas: add retry logic in megasas_readl)
  
 -	cur_rdpq_mode = (scratch_pad_1 & MR_RDPQ_MODE_OFFSET) ? 1 : 0;
 +	cur_rdpq_mode = (scratch_pad_2 & MR_RDPQ_MODE_OFFSET) ? 1 : 0;
  
  	if (instance->adapter_type == INVADER_SERIES) {
  		cur_fw_64bit_dma_capable =
@@@ -1659,8 -1656,9 +1675,14 @@@ megasas_init_adapter_fusion(struct mega
  
  	megasas_configure_queue_sizes(instance);
  
++<<<<<<< HEAD
 +	scratch_pad_2 = readl(&instance->reg_set->outbound_scratch_pad_2);
 +	/* If scratch_pad_2 & MEGASAS_MAX_CHAIN_SIZE_UNITS_MASK is set,
++=======
+ 	scratch_pad_1 = megasas_readl(instance,
+ 				      &instance->reg_set->outbound_scratch_pad_1);
+ 	/* If scratch_pad_1 & MEGASAS_MAX_CHAIN_SIZE_UNITS_MASK is set,
++>>>>>>> 272652fcbf1a (scsi: megaraid_sas: add retry logic in megasas_readl)
  	 * Firmware support extended IO chain frame which is 4 times more than
  	 * legacy Firmware.
  	 * Legacy Firmware - Frame size is (8 * 128) = 1K
@@@ -3692,9 -3733,9 +3714,13 @@@ megasas_release_fusion(struct megasas_i
   * @regs:			MFI register set
   */
  static u32
 -megasas_read_fw_status_reg_fusion(struct megasas_instance *instance)
 +megasas_read_fw_status_reg_fusion(struct megasas_register_set __iomem *regs)
  {
++<<<<<<< HEAD
 +	return readl(&(regs)->outbound_scratch_pad);
++=======
+ 	return megasas_readl(instance, &instance->reg_set->outbound_scratch_pad_0);
++>>>>>>> 272652fcbf1a (scsi: megaraid_sas: add retry logic in megasas_readl)
  }
  
  /**
* Unmerged path drivers/scsi/megaraid/megaraid_sas_base.c
* Unmerged path drivers/scsi/megaraid/megaraid_sas_fusion.c
