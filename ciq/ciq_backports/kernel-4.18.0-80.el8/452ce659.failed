vfs: plumb remap flags through the vfs clone functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 452ce65951a2f0719e4e119ecca134c06cfe22ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/452ce659.failed

Plumb a remap_flags argument through the {do,vfs}_clone_file_range
functions so that clone can take advantage of it.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 452ce65951a2f0719e4e119ecca134c06cfe22ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ioctl.c
#	fs/nfsd/vfs.c
#	fs/overlayfs/copy_up.c
#	fs/overlayfs/file.c
#	fs/read_write.c
#	include/linux/fs.h
diff --cc fs/ioctl.c
index 0400297c8d72,505275ec5596..000000000000
--- a/fs/ioctl.c
+++ b/fs/ioctl.c
@@@ -230,7 -231,14 +230,18 @@@ static long ioctl_file_clone(struct fil
  	ret = -EXDEV;
  	if (src_file.file->f_path.mnt != dst_file->f_path.mnt)
  		goto fdput;
++<<<<<<< HEAD
 +	ret = vfs_clone_file_range(src_file.file, off, dst_file, destoff, olen);
++=======
+ 	cloned = vfs_clone_file_range(src_file.file, off, dst_file, destoff,
+ 				      olen, 0);
+ 	if (cloned < 0)
+ 		ret = cloned;
+ 	else if (olen && cloned != olen)
+ 		ret = -EINVAL;
+ 	else
+ 		ret = 0;
++>>>>>>> 452ce65951a2 (vfs: plumb remap flags through the vfs clone functions)
  fdput:
  	fdput(src_file);
  	return ret;
diff --cc fs/nfsd/vfs.c
index 613d2fe2dddd,726fc5b2b27a..000000000000
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@@ -541,8 -541,12 +541,17 @@@ __be32 nfsd4_set_nfs4_label(struct svc_
  __be32 nfsd4_clone_file_range(struct file *src, u64 src_pos, struct file *dst,
  		u64 dst_pos, u64 count)
  {
++<<<<<<< HEAD
 +	return nfserrno(vfs_clone_file_range(src, src_pos, dst, dst_pos,
 +					     count));
++=======
+ 	loff_t cloned;
+ 
+ 	cloned = vfs_clone_file_range(src, src_pos, dst, dst_pos, count, 0);
+ 	if (count && cloned != count)
+ 		cloned = -EINVAL;
+ 	return nfserrno(cloned < 0 ? cloned : 0);
++>>>>>>> 452ce65951a2 (vfs: plumb remap flags through the vfs clone functions)
  }
  
  ssize_t nfsd_copy_file_range(struct file *src, u64 src_pos, struct file *dst,
diff --cc fs/overlayfs/copy_up.c
index 1cc797a08a5b,5f82fece64a0..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -141,11 -142,10 +141,16 @@@ static int ovl_copy_up_data(struct pat
  	}
  
  	/* Try to use clone_file_range to clone up within the same fs */
++<<<<<<< HEAD
 +	error = do_clone_file_range(old_file, 0, new_file, 0, len);
 +	if (!error)
++=======
+ 	cloned = do_clone_file_range(old_file, 0, new_file, 0, len, 0);
+ 	if (cloned == len)
++>>>>>>> 452ce65951a2 (vfs: plumb remap flags through the vfs clone functions)
  		goto out;
  	/* Couldn't clone, so now we try to copy the data */
 +	error = 0;
  
  	/* FIXME: copy up sparse files efficiently */
  	while (len) {
diff --cc fs/overlayfs/file.c
index 986313da0c88,0393815c8971..000000000000
--- a/fs/overlayfs/file.c
+++ b/fs/overlayfs/file.c
@@@ -503,12 -507,13 +503,17 @@@ static int ovl_dedupe_file_range(struc
  	 * Don't copy up because of a dedupe request, this wouldn't make sense
  	 * most of the time (data would be duplicated instead of deduplicated).
  	 */
 -	if (op == OVL_DEDUPE &&
 -	    (!ovl_inode_upper(file_inode(file_in)) ||
 -	     !ovl_inode_upper(file_inode(file_out))))
 +	if (!ovl_inode_upper(file_inode(file_in)) ||
 +	    !ovl_inode_upper(file_inode(file_out)))
  		return -EPERM;
  
++<<<<<<< HEAD
 +	return ovl_copyfile(file_in, pos_in, file_out, pos_out, len, 0,
 +			    OVL_DEDUPE);
++=======
+ 	return ovl_copyfile(file_in, pos_in, file_out, pos_out, len,
+ 			    remap_flags, op);
++>>>>>>> 452ce65951a2 (vfs: plumb remap flags through the vfs clone functions)
  }
  
  const struct file_operations ovl_file_operations = {
diff --cc fs/read_write.c
index 734c5661fb69,0d1ac1b9bc22..000000000000
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@@ -1824,13 -1847,16 +1824,21 @@@ int generic_remap_file_range_prep(struc
  }
  EXPORT_SYMBOL(generic_remap_file_range_prep);
  
++<<<<<<< HEAD
 +int do_clone_file_range(struct file *file_in, loff_t pos_in,
 +			struct file *file_out, loff_t pos_out, u64 len)
++=======
+ loff_t do_clone_file_range(struct file *file_in, loff_t pos_in,
+ 			   struct file *file_out, loff_t pos_out,
+ 			   loff_t len, unsigned int remap_flags)
++>>>>>>> 452ce65951a2 (vfs: plumb remap flags through the vfs clone functions)
  {
  	struct inode *inode_in = file_inode(file_in);
  	struct inode *inode_out = file_inode(file_out);
 -	loff_t ret;
 +	int ret;
  
+ 	WARN_ON_ONCE(remap_flags);
+ 
  	if (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))
  		return -EISDIR;
  	if (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))
@@@ -1860,24 -1886,26 +1868,38 @@@
  	if (ret)
  		return ret;
  
++<<<<<<< HEAD
 +	ret = file_in->f_op->clone_file_range(file_in, pos_in,
 +			file_out, pos_out, len);
 +	if (!ret) {
 +		fsnotify_access(file_in);
 +		fsnotify_modify(file_out);
 +	}
++=======
+ 	ret = file_in->f_op->remap_file_range(file_in, pos_in,
+ 			file_out, pos_out, len, remap_flags);
+ 	if (ret < 0)
+ 		return ret;
++>>>>>>> 452ce65951a2 (vfs: plumb remap flags through the vfs clone functions)
  
 -	fsnotify_access(file_in);
 -	fsnotify_modify(file_out);
  	return ret;
  }
  EXPORT_SYMBOL(do_clone_file_range);
  
++<<<<<<< HEAD
 +int vfs_clone_file_range(struct file *file_in, loff_t pos_in,
 +			 struct file *file_out, loff_t pos_out, u64 len)
++=======
+ loff_t vfs_clone_file_range(struct file *file_in, loff_t pos_in,
+ 			    struct file *file_out, loff_t pos_out,
+ 			    loff_t len, unsigned int remap_flags)
++>>>>>>> 452ce65951a2 (vfs: plumb remap flags through the vfs clone functions)
  {
 -	loff_t ret;
 +	int ret;
  
  	file_start_write(file_out);
- 	ret = do_clone_file_range(file_in, pos_in, file_out, pos_out, len);
+ 	ret = do_clone_file_range(file_in, pos_in, file_out, pos_out, len,
+ 				  remap_flags);
  	file_end_write(file_out);
  
  	return ret;
diff --cc include/linux/fs.h
index 6f009fb80ab1,1c5e55d2a67d..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -1809,11 -1844,14 +1809,22 @@@ extern ssize_t vfs_copy_file_range(stru
  				   loff_t, size_t, unsigned int);
  extern int generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,
  					 struct file *file_out, loff_t pos_out,
++<<<<<<< HEAD
 +					 u64 *count, bool is_dedupe);
 +extern int do_clone_file_range(struct file *file_in, loff_t pos_in,
 +			       struct file *file_out, loff_t pos_out, u64 len);
 +extern int vfs_clone_file_range(struct file *file_in, loff_t pos_in,
 +				struct file *file_out, loff_t pos_out, u64 len);
++=======
+ 					 loff_t *count,
+ 					 unsigned int remap_flags);
+ extern loff_t do_clone_file_range(struct file *file_in, loff_t pos_in,
+ 				  struct file *file_out, loff_t pos_out,
+ 				  loff_t len, unsigned int remap_flags);
+ extern loff_t vfs_clone_file_range(struct file *file_in, loff_t pos_in,
+ 				   struct file *file_out, loff_t pos_out,
+ 				   loff_t len, unsigned int remap_flags);
++>>>>>>> 452ce65951a2 (vfs: plumb remap flags through the vfs clone functions)
  extern int vfs_dedupe_file_range_compare(struct inode *src, loff_t srcoff,
  					 struct inode *dest, loff_t destoff,
  					 loff_t len, bool *is_same);
* Unmerged path fs/ioctl.c
* Unmerged path fs/nfsd/vfs.c
* Unmerged path fs/overlayfs/copy_up.c
* Unmerged path fs/overlayfs/file.c
* Unmerged path fs/read_write.c
* Unmerged path include/linux/fs.h
