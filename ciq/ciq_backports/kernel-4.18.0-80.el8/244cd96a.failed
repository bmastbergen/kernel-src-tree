net_sched: remove list_head from tc_action

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Cong Wang <xiyou.wangcong@gmail.com>
commit 244cd96adb5f5ab39551081fb1f9009a54bb12ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/244cd96a.failed

After commit 90b73b77d08e, list_head is no longer needed.
Now we just need to convert the list iteration to array
iteration for drivers.

Fixes: 90b73b77d08e ("net: sched: change action API to use array of pointers to actions")
	Cc: Jiri Pirko <jiri@mellanox.com>
	Cc: Vlad Buslov <vladbu@mellanox.com>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 244cd96adb5f5ab39551081fb1f9009a54bb12ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/qlogic/qede/qede_filter.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 430dda05e9da,9fed54017659..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -2578,6 -2666,7 +2578,10 @@@ static int parse_tc_fdb_actions(struct 
  	LIST_HEAD(actions);
  	bool encap = false;
  	u32 action = 0;
++<<<<<<< HEAD
++=======
+ 	int err, i;
++>>>>>>> 244cd96adb5f (net_sched: remove list_head from tc_action)
  
  	if (!tcf_exts_has_actions(exts))
  		return -EINVAL;
diff --cc drivers/net/ethernet/qlogic/qede/qede_filter.c
index f9a327c821eb,b16ce7d93caf..000000000000
--- a/drivers/net/ethernet/qlogic/qede/qede_filter.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_filter.c
@@@ -1982,3 -2002,291 +1982,294 @@@ unlock
  	__qede_unlock(edev);
  	return count;
  }
++<<<<<<< HEAD
++=======
+ 
+ static int qede_parse_actions(struct qede_dev *edev,
+ 			      struct tcf_exts *exts)
+ {
+ 	int rc = -EINVAL, num_act = 0, i;
+ 	const struct tc_action *a;
+ 	bool is_drop = false;
+ 
+ 	if (!tcf_exts_has_actions(exts)) {
+ 		DP_NOTICE(edev, "No tc actions received\n");
+ 		return rc;
+ 	}
+ 
+ 	tcf_exts_for_each_action(i, a, exts) {
+ 		num_act++;
+ 
+ 		if (is_tcf_gact_shot(a))
+ 			is_drop = true;
+ 	}
+ 
+ 	if (num_act == 1 && is_drop)
+ 		return 0;
+ 
+ 	return rc;
+ }
+ 
+ static int
+ qede_tc_parse_ports(struct qede_dev *edev,
+ 		    struct tc_cls_flower_offload *f,
+ 		    struct qede_arfs_tuple *t)
+ {
+ 	if (dissector_uses_key(f->dissector, FLOW_DISSECTOR_KEY_PORTS)) {
+ 		struct flow_dissector_key_ports *key, *mask;
+ 
+ 		key = skb_flow_dissector_target(f->dissector,
+ 						FLOW_DISSECTOR_KEY_PORTS,
+ 						f->key);
+ 		mask = skb_flow_dissector_target(f->dissector,
+ 						 FLOW_DISSECTOR_KEY_PORTS,
+ 						 f->mask);
+ 
+ 		if ((key->src && mask->src != U16_MAX) ||
+ 		    (key->dst && mask->dst != U16_MAX)) {
+ 			DP_NOTICE(edev, "Do not support ports masks\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		t->src_port = key->src;
+ 		t->dst_port = key->dst;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qede_tc_parse_v6_common(struct qede_dev *edev,
+ 			struct tc_cls_flower_offload *f,
+ 			struct qede_arfs_tuple *t)
+ {
+ 	struct in6_addr zero_addr, addr;
+ 
+ 	memset(&zero_addr, 0, sizeof(addr));
+ 	memset(&addr, 0xff, sizeof(addr));
+ 
+ 	if (dissector_uses_key(f->dissector, FLOW_DISSECTOR_KEY_IPV6_ADDRS)) {
+ 		struct flow_dissector_key_ipv6_addrs *key, *mask;
+ 
+ 		key = skb_flow_dissector_target(f->dissector,
+ 						FLOW_DISSECTOR_KEY_IPV6_ADDRS,
+ 						f->key);
+ 		mask = skb_flow_dissector_target(f->dissector,
+ 						 FLOW_DISSECTOR_KEY_IPV6_ADDRS,
+ 						 f->mask);
+ 
+ 		if ((memcmp(&key->src, &zero_addr, sizeof(addr)) &&
+ 		     memcmp(&mask->src, &addr, sizeof(addr))) ||
+ 		    (memcmp(&key->dst, &zero_addr, sizeof(addr)) &&
+ 		     memcmp(&mask->dst, &addr, sizeof(addr)))) {
+ 			DP_NOTICE(edev,
+ 				  "Do not support IPv6 address prefix/mask\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		memcpy(&t->src_ipv6, &key->src, sizeof(addr));
+ 		memcpy(&t->dst_ipv6, &key->dst, sizeof(addr));
+ 	}
+ 
+ 	if (qede_tc_parse_ports(edev, f, t))
+ 		return -EINVAL;
+ 
+ 	return qede_set_v6_tuple_to_profile(edev, t, &zero_addr);
+ }
+ 
+ static int
+ qede_tc_parse_v4_common(struct qede_dev *edev,
+ 			struct tc_cls_flower_offload *f,
+ 			struct qede_arfs_tuple *t)
+ {
+ 	if (dissector_uses_key(f->dissector, FLOW_DISSECTOR_KEY_IPV4_ADDRS)) {
+ 		struct flow_dissector_key_ipv4_addrs *key, *mask;
+ 
+ 		key = skb_flow_dissector_target(f->dissector,
+ 						FLOW_DISSECTOR_KEY_IPV4_ADDRS,
+ 						f->key);
+ 		mask = skb_flow_dissector_target(f->dissector,
+ 						 FLOW_DISSECTOR_KEY_IPV4_ADDRS,
+ 						 f->mask);
+ 
+ 		if ((key->src && mask->src != U32_MAX) ||
+ 		    (key->dst && mask->dst != U32_MAX)) {
+ 			DP_NOTICE(edev, "Do not support ipv4 prefix/masks\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		t->src_ipv4 = key->src;
+ 		t->dst_ipv4 = key->dst;
+ 	}
+ 
+ 	if (qede_tc_parse_ports(edev, f, t))
+ 		return -EINVAL;
+ 
+ 	return qede_set_v4_tuple_to_profile(edev, t);
+ }
+ 
+ static int
+ qede_tc_parse_tcp_v6(struct qede_dev *edev,
+ 		     struct tc_cls_flower_offload *f,
+ 		     struct qede_arfs_tuple *tuple)
+ {
+ 	tuple->ip_proto = IPPROTO_TCP;
+ 	tuple->eth_proto = htons(ETH_P_IPV6);
+ 
+ 	return qede_tc_parse_v6_common(edev, f, tuple);
+ }
+ 
+ static int
+ qede_tc_parse_tcp_v4(struct qede_dev *edev,
+ 		     struct tc_cls_flower_offload *f,
+ 		     struct qede_arfs_tuple *tuple)
+ {
+ 	tuple->ip_proto = IPPROTO_TCP;
+ 	tuple->eth_proto = htons(ETH_P_IP);
+ 
+ 	return qede_tc_parse_v4_common(edev, f, tuple);
+ }
+ 
+ static int
+ qede_tc_parse_udp_v6(struct qede_dev *edev,
+ 		     struct tc_cls_flower_offload *f,
+ 		     struct qede_arfs_tuple *tuple)
+ {
+ 	tuple->ip_proto = IPPROTO_UDP;
+ 	tuple->eth_proto = htons(ETH_P_IPV6);
+ 
+ 	return qede_tc_parse_v6_common(edev, f, tuple);
+ }
+ 
+ static int
+ qede_tc_parse_udp_v4(struct qede_dev *edev,
+ 		     struct tc_cls_flower_offload *f,
+ 		     struct qede_arfs_tuple *tuple)
+ {
+ 	tuple->ip_proto = IPPROTO_UDP;
+ 	tuple->eth_proto = htons(ETH_P_IP);
+ 
+ 	return qede_tc_parse_v4_common(edev, f, tuple);
+ }
+ 
+ static int
+ qede_parse_flower_attr(struct qede_dev *edev, __be16 proto,
+ 		       struct tc_cls_flower_offload *f,
+ 		       struct qede_arfs_tuple *tuple)
+ {
+ 	int rc = -EINVAL;
+ 	u8 ip_proto = 0;
+ 
+ 	memset(tuple, 0, sizeof(*tuple));
+ 
+ 	if (f->dissector->used_keys &
+ 	    ~(BIT(FLOW_DISSECTOR_KEY_CONTROL) |
+ 	      BIT(FLOW_DISSECTOR_KEY_IPV4_ADDRS) |
+ 	      BIT(FLOW_DISSECTOR_KEY_BASIC) |
+ 	      BIT(FLOW_DISSECTOR_KEY_IPV6_ADDRS) |
+ 	      BIT(FLOW_DISSECTOR_KEY_PORTS))) {
+ 		DP_NOTICE(edev, "Unsupported key set:0x%x\n",
+ 			  f->dissector->used_keys);
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (proto != htons(ETH_P_IP) &&
+ 	    proto != htons(ETH_P_IPV6)) {
+ 		DP_NOTICE(edev, "Unsupported proto=0x%x\n", proto);
+ 		return -EPROTONOSUPPORT;
+ 	}
+ 
+ 	if (dissector_uses_key(f->dissector, FLOW_DISSECTOR_KEY_BASIC)) {
+ 		struct flow_dissector_key_basic *key;
+ 
+ 		key = skb_flow_dissector_target(f->dissector,
+ 						FLOW_DISSECTOR_KEY_BASIC,
+ 						f->key);
+ 		ip_proto = key->ip_proto;
+ 	}
+ 
+ 	if (ip_proto == IPPROTO_TCP && proto == htons(ETH_P_IP))
+ 		rc = qede_tc_parse_tcp_v4(edev, f, tuple);
+ 	else if (ip_proto == IPPROTO_TCP && proto == htons(ETH_P_IPV6))
+ 		rc = qede_tc_parse_tcp_v6(edev, f, tuple);
+ 	else if (ip_proto == IPPROTO_UDP && proto == htons(ETH_P_IP))
+ 		rc = qede_tc_parse_udp_v4(edev, f, tuple);
+ 	else if (ip_proto == IPPROTO_UDP && proto == htons(ETH_P_IPV6))
+ 		rc = qede_tc_parse_udp_v6(edev, f, tuple);
+ 	else
+ 		DP_NOTICE(edev, "Invalid tc protocol request\n");
+ 
+ 	return rc;
+ }
+ 
+ int qede_add_tc_flower_fltr(struct qede_dev *edev, __be16 proto,
+ 			    struct tc_cls_flower_offload *f)
+ {
+ 	struct qede_arfs_fltr_node *n;
+ 	int min_hlen, rc = -EINVAL;
+ 	struct qede_arfs_tuple t;
+ 
+ 	__qede_lock(edev);
+ 
+ 	if (!edev->arfs) {
+ 		rc = -EPERM;
+ 		goto unlock;
+ 	}
+ 
+ 	/* parse flower attribute and prepare filter */
+ 	if (qede_parse_flower_attr(edev, proto, f, &t))
+ 		goto unlock;
+ 
+ 	/* Validate profile mode and number of filters */
+ 	if ((edev->arfs->filter_count && edev->arfs->mode != t.mode) ||
+ 	    edev->arfs->filter_count == QEDE_RFS_MAX_FLTR) {
+ 		DP_NOTICE(edev,
+ 			  "Filter configuration invalidated, filter mode=0x%x, configured mode=0x%x, filter count=0x%x\n",
+ 			  t.mode, edev->arfs->mode, edev->arfs->filter_count);
+ 		goto unlock;
+ 	}
+ 
+ 	/* parse tc actions and get the vf_id */
+ 	if (qede_parse_actions(edev, f->exts))
+ 		goto unlock;
+ 
+ 	if (qede_flow_find_fltr(edev, &t)) {
+ 		rc = -EEXIST;
+ 		goto unlock;
+ 	}
+ 
+ 	n = kzalloc(sizeof(*n), GFP_KERNEL);
+ 	if (!n) {
+ 		rc = -ENOMEM;
+ 		goto unlock;
+ 	}
+ 
+ 	min_hlen = qede_flow_get_min_header_size(&t);
+ 
+ 	n->data = kzalloc(min_hlen, GFP_KERNEL);
+ 	if (!n->data) {
+ 		kfree(n);
+ 		rc = -ENOMEM;
+ 		goto unlock;
+ 	}
+ 
+ 	memcpy(&n->tuple, &t, sizeof(n->tuple));
+ 
+ 	n->buf_len = min_hlen;
+ 	n->b_is_drop = true;
+ 	n->sw_id = f->cookie;
+ 
+ 	n->tuple.build_hdr(&n->tuple, n->data);
+ 
+ 	rc = qede_enqueue_fltr_and_config_searcher(edev, n, 0);
+ 	if (rc)
+ 		goto unlock;
+ 
+ 	qede_configure_arfs_fltr(edev, n, n->rxq_id, true);
+ 	rc = qede_poll_arfs_filter_config(edev, n);
+ 
+ unlock:
+ 	__qede_unlock(edev);
+ 	return rc;
+ }
++>>>>>>> 244cd96adb5f (net_sched: remove list_head from tc_action)
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c b/drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c
index 139d96c5a023..092c817f8f11 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_tc.c
@@ -110,16 +110,14 @@ static int bnxt_tc_parse_actions(struct bnxt *bp,
 				 struct tcf_exts *tc_exts)
 {
 	const struct tc_action *tc_act;
-	LIST_HEAD(tc_actions);
-	int rc;
+	int i, rc;
 
 	if (!tcf_exts_has_actions(tc_exts)) {
 		netdev_info(bp->dev, "no actions");
 		return -EINVAL;
 	}
 
-	tcf_exts_to_list(tc_exts, &tc_actions);
-	list_for_each_entry(tc_act, &tc_actions, list) {
+	tcf_exts_for_each_action(i, tc_act, tc_exts) {
 		/* Drop action */
 		if (is_tcf_gact_shot(tc_act)) {
 			actions->flags |= BNXT_TC_ACTION_FLAG_DROP;
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_flower.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_flower.c
index 623f73dd7738..c116f96956fe 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_flower.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_flower.c
@@ -417,10 +417,9 @@ static void cxgb4_process_flow_actions(struct net_device *in,
 				       struct ch_filter_specification *fs)
 {
 	const struct tc_action *a;
-	LIST_HEAD(actions);
+	int i;
 
-	tcf_exts_to_list(cls->exts, &actions);
-	list_for_each_entry(a, &actions, list) {
+	tcf_exts_for_each_action(i, a, cls->exts) {
 		if (is_tcf_gact_ok(a)) {
 			fs->action = FILTER_PASS;
 		} else if (is_tcf_gact_shot(a)) {
@@ -591,10 +590,9 @@ static int cxgb4_validate_flow_actions(struct net_device *dev,
 	bool act_redir = false;
 	bool act_pedit = false;
 	bool act_vlan = false;
-	LIST_HEAD(actions);
+	int i;
 
-	tcf_exts_to_list(cls->exts, &actions);
-	list_for_each_entry(a, &actions, list) {
+	tcf_exts_for_each_action(i, a, cls->exts) {
 		if (is_tcf_gact_ok(a)) {
 			/* Do nothing */
 		} else if (is_tcf_gact_shot(a)) {
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_u32.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_u32.c
index 18eb2aedd4cb..c7d2b4dc7568 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_u32.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_u32.c
@@ -93,14 +93,13 @@ static int fill_action_fields(struct adapter *adap,
 	unsigned int num_actions = 0;
 	const struct tc_action *a;
 	struct tcf_exts *exts;
-	LIST_HEAD(actions);
+	int i;
 
 	exts = cls->knode.exts;
 	if (!tcf_exts_has_actions(exts))
 		return -EINVAL;
 
-	tcf_exts_to_list(exts, &actions);
-	list_for_each_entry(a, &actions, list) {
+	tcf_exts_for_each_action(i, a, exts) {
 		/* Don't allow more than one action per rule. */
 		if (num_actions)
 			return -EINVAL;
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 3c9344dbad5d..cddbbd37560e 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@ -9002,14 +9002,12 @@ static int parse_tc_actions(struct ixgbe_adapter *adapter,
 			    struct tcf_exts *exts, u64 *action, u8 *queue)
 {
 	const struct tc_action *a;
-	LIST_HEAD(actions);
+	int i;
 
 	if (!tcf_exts_has_actions(exts))
 		return -EINVAL;
 
-	tcf_exts_to_list(exts, &actions);
-	list_for_each_entry(a, &actions, list) {
-
+	tcf_exts_for_each_action(i, a, exts) {
 		/* Drop action */
 		if (is_tcf_gact_shot(a)) {
 			*action = IXGBE_FDIR_DROP_QUEUE;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
index 52437363766a..a8567dca4f99 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
@@ -1354,8 +1354,7 @@ static int mlxsw_sp_port_add_cls_matchall(struct mlxsw_sp_port *mlxsw_sp_port,
 		return -ENOMEM;
 	mall_tc_entry->cookie = f->cookie;
 
-	tcf_exts_to_list(f->exts, &actions);
-	a = list_first_entry(&actions, struct tc_action, list);
+	a = tcf_exts_first_action(f->exts);
 
 	if (is_tcf_mirred_egress_mirror(a) && protocol == htons(ETH_P_ALL)) {
 		struct mlxsw_sp_port_mall_mirror_tc_entry *mirror;
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_flower.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_flower.c
index 89dbf569dff5..3a6e943fdfdc 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_flower.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_flower.c
@@ -51,8 +51,7 @@ static int mlxsw_sp_flower_parse_actions(struct mlxsw_sp *mlxsw_sp,
 					 struct tcf_exts *exts)
 {
 	const struct tc_action *a;
-	LIST_HEAD(actions);
-	int err;
+	int err, i;
 
 	if (!tcf_exts_has_actions(exts))
 		return 0;
@@ -62,8 +61,7 @@ static int mlxsw_sp_flower_parse_actions(struct mlxsw_sp *mlxsw_sp,
 	if (err)
 		return err;
 
-	tcf_exts_to_list(exts, &actions);
-	list_for_each_entry(a, &actions, list) {
+	tcf_exts_for_each_action(i, a, exts) {
 		if (is_tcf_gact_ok(a)) {
 			err = mlxsw_sp_acl_rulei_act_terminate(rulei);
 			if (err)
diff --git a/drivers/net/ethernet/netronome/nfp/flower/action.c b/drivers/net/ethernet/netronome/nfp/flower/action.c
index d9179a2afffb..889eacc9f839 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/action.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/action.c
@@ -808,11 +808,10 @@ int nfp_flower_compile_action(struct nfp_app *app,
 			      struct net_device *netdev,
 			      struct nfp_fl_payload *nfp_flow)
 {
-	int act_len, act_cnt, err, tun_out_cnt, out_cnt;
+	int act_len, act_cnt, err, tun_out_cnt, out_cnt, i;
 	enum nfp_flower_tun_type tun_type;
 	const struct tc_action *a;
 	u32 csum_updated = 0;
-	LIST_HEAD(actions);
 
 	memset(nfp_flow->action_data, 0, NFP_FL_MAX_A_SIZ);
 	nfp_flow->meta.act_len = 0;
@@ -822,8 +821,7 @@ int nfp_flower_compile_action(struct nfp_app *app,
 	tun_out_cnt = 0;
 	out_cnt = 0;
 
-	tcf_exts_to_list(flow->exts, &actions);
-	list_for_each_entry(a, &actions, list) {
+	tcf_exts_for_each_action(i, a, flow->exts) {
 		err = nfp_flower_loop_action(app, a, flow, nfp_flow, &act_len,
 					     netdev, &tun_type, &tun_out_cnt,
 					     &out_cnt, &csum_updated);
* Unmerged path drivers/net/ethernet/qlogic/qede/qede_filter.c
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
index 2258cd8cc844..e926c6e36acc 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
@@ -61,7 +61,7 @@ static int tc_fill_actions(struct stmmac_tc_entry *entry,
 	struct stmmac_tc_entry *action_entry = entry;
 	const struct tc_action *act;
 	struct tcf_exts *exts;
-	LIST_HEAD(actions);
+	int i;
 
 	exts = cls->knode.exts;
 	if (!tcf_exts_has_actions(exts))
@@ -69,8 +69,7 @@ static int tc_fill_actions(struct stmmac_tc_entry *entry,
 	if (frag)
 		action_entry = frag;
 
-	tcf_exts_to_list(exts, &actions);
-	list_for_each_entry(act, &actions, list) {
+	tcf_exts_for_each_action(i, act, exts) {
 		/* Accept */
 		if (is_tcf_gact_ok(act)) {
 			action_entry->val.af = 1;
diff --git a/include/net/act_api.h b/include/net/act_api.h
index 3713cac1ded4..eb0e0edf7313 100644
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@ -22,7 +22,6 @@ struct tc_action {
 	const struct tc_action_ops	*ops;
 	__u32				type; /* for backward compat(TCA_OLD_COMPAT) */
 	__u32				order;
-	struct list_head		list;
 	struct tcf_idrinfo		*idrinfo;
 
 	u32				tcfa_index;
diff --git a/include/net/pkt_cls.h b/include/net/pkt_cls.h
index ef727f71336e..c17d51865469 100644
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@ -298,19 +298,13 @@ static inline void tcf_exts_put_net(struct tcf_exts *exts)
 #endif
 }
 
-static inline void tcf_exts_to_list(const struct tcf_exts *exts,
-				    struct list_head *actions)
-{
 #ifdef CONFIG_NET_CLS_ACT
-	int i;
-
-	for (i = 0; i < exts->nr_actions; i++) {
-		struct tc_action *a = exts->actions[i];
-
-		list_add_tail(&a->list, actions);
-	}
+#define tcf_exts_for_each_action(i, a, exts) \
+	for (i = 0; i < TCA_ACT_MAX_PRIO && ((a) = (exts)->actions[i]); i++)
+#else
+#define tcf_exts_for_each_action(i, a, exts) \
+	for (; 0; )
 #endif
-}
 
 static inline void
 tcf_exts_stats_update(const struct tcf_exts *exts,
@@ -361,6 +355,15 @@ static inline bool tcf_exts_has_one_action(struct tcf_exts *exts)
 #endif
 }
 
+static inline struct tc_action *tcf_exts_first_action(struct tcf_exts *exts)
+{
+#ifdef CONFIG_NET_CLS_ACT
+	return exts->actions[0];
+#else
+	return NULL;
+#endif
+}
+
 /**
  * tcf_exts_exec - execute tc filter extensions
  * @skb: socket buffer
diff --git a/net/dsa/slave.c b/net/dsa/slave.c
index 962c4fd338ba..1c45c1d6d241 100644
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@ -767,7 +767,6 @@ static int dsa_slave_add_cls_matchall(struct net_device *dev,
 	const struct tc_action *a;
 	struct dsa_port *to_dp;
 	int err = -EOPNOTSUPP;
-	LIST_HEAD(actions);
 
 	if (!ds->ops->port_mirror_add)
 		return err;
@@ -775,8 +774,7 @@ static int dsa_slave_add_cls_matchall(struct net_device *dev,
 	if (!tcf_exts_has_one_action(cls->exts))
 		return err;
 
-	tcf_exts_to_list(cls->exts, &actions);
-	a = list_first_entry(&actions, struct tc_action, list);
+	a = tcf_exts_first_action(cls->exts);
 
 	if (is_tcf_mirred_egress_mirror(a) && protocol == htons(ETH_P_ALL)) {
 		struct dsa_mall_mirror_tc_entry *mirror;
diff --git a/net/sched/act_api.c b/net/sched/act_api.c
index 798bd0da5ca2..33ff3b5b952a 100644
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@ -409,7 +409,6 @@ int tcf_idr_create(struct tc_action_net *tn, u32 index, struct nlattr *est,
 
 	p->idrinfo = idrinfo;
 	p->ops = ops;
-	INIT_LIST_HEAD(&p->list);
 	*a = p;
 	return 0;
 err4:
