rcu: Remove for_each_rcu_flavor() flavor-traversal macro

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Paul E. McKenney <paulmck@linux.vnet.ibm.com>
commit b97d23c51c9fee56b0c7598c323ab2846d873f2d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/b97d23c5.failed

Now that there is only ever a single flavor of RCU in a given kernel
build, there isn't a whole lot of point in having a flavor-traversal
macro.  This commit therefore removes it and converts calls to it to
straightline code, inlining trivial functions as appropriate.

	Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
(cherry picked from commit b97d23c51c9fee56b0c7598c323ab2846d873f2d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/rcu/tree.c
diff --cc kernel/rcu/tree.c
index f33d62c3dd9d,46a32999020d..000000000000
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@@ -568,31 -566,28 +566,36 @@@ void show_rcu_gp_kthreads(void
  	int cpu;
  	struct rcu_data *rdp;
  	struct rcu_node *rnp;
- 	struct rcu_state *rsp;
  
++<<<<<<< HEAD
 +	for_each_rcu_flavor(rsp) {
 +		pr_info("%s: wait state: %d ->state: %#lx\n",
 +			rsp->name, rsp->gp_state, rsp->gp_kthread->state);
 +		rcu_for_each_node_breadth_first(rsp, rnp) {
 +			if (ULONG_CMP_GE(rsp->gp_seq, rnp->gp_seq_needed))
++=======
+ 	pr_info("%s: wait state: %d ->state: %#lx\n", rcu_state.name,
+ 		rcu_state.gp_state, rcu_state.gp_kthread->state);
+ 	rcu_for_each_node_breadth_first(rnp) {
+ 		if (ULONG_CMP_GE(rcu_state.gp_seq, rnp->gp_seq_needed))
+ 			continue;
+ 		pr_info("\trcu_node %d:%d ->gp_seq %lu ->gp_seq_needed %lu\n",
+ 			rnp->grplo, rnp->grphi, rnp->gp_seq,
+ 			rnp->gp_seq_needed);
+ 		if (!rcu_is_leaf_node(rnp))
+ 			continue;
+ 		for_each_leaf_node_possible_cpu(rnp, cpu) {
+ 			rdp = per_cpu_ptr(&rcu_data, cpu);
+ 			if (rdp->gpwrap ||
+ 			    ULONG_CMP_GE(rcu_state.gp_seq,
+ 					 rdp->gp_seq_needed))
++>>>>>>> b97d23c51c9f (rcu: Remove for_each_rcu_flavor() flavor-traversal macro)
  				continue;
- 			pr_info("\trcu_node %d:%d ->gp_seq %lu ->gp_seq_needed %lu\n",
- 				rnp->grplo, rnp->grphi, rnp->gp_seq,
- 				rnp->gp_seq_needed);
- 			if (!rcu_is_leaf_node(rnp))
- 				continue;
- 			for_each_leaf_node_possible_cpu(rnp, cpu) {
- 				rdp = per_cpu_ptr(&rcu_data, cpu);
- 				if (rdp->gpwrap ||
- 				    ULONG_CMP_GE(rsp->gp_seq,
- 						 rdp->gp_seq_needed))
- 					continue;
- 				pr_info("\tcpu %d ->gp_seq_needed %lu\n",
- 					cpu, rdp->gp_seq_needed);
- 			}
+ 			pr_info("\tcpu %d ->gp_seq_needed %lu\n",
+ 				cpu, rdp->gp_seq_needed);
  		}
- 		/* sched_show_task(rsp->gp_kthread); */
  	}
+ 	/* sched_show_task(rcu_state.gp_kthread); */
  }
  EXPORT_SYMBOL_GPL(show_rcu_gp_kthreads);
  
@@@ -3664,19 -3635,17 +3643,32 @@@ static int __init rcu_spawn_gp_kthread(
  			 kthread_prio, kthread_prio_in);
  
  	rcu_scheduler_fully_active = 1;
++<<<<<<< HEAD
 +	for_each_rcu_flavor(rsp) {
 +		t = kthread_create(rcu_gp_kthread, rsp, "%s", rsp->name);
 +		BUG_ON(IS_ERR(t));
 +		rnp = rcu_get_root();
 +		raw_spin_lock_irqsave_rcu_node(rnp, flags);
 +		rsp->gp_kthread = t;
 +		if (kthread_prio) {
 +			sp.sched_priority = kthread_prio;
 +			sched_setscheduler_nocheck(t, SCHED_FIFO, &sp);
 +		}
 +		raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
 +		wake_up_process(t);
++=======
+ 	t = kthread_create(rcu_gp_kthread, NULL, "%s", rcu_state.name);
+ 	BUG_ON(IS_ERR(t));
+ 	rnp = rcu_get_root();
+ 	raw_spin_lock_irqsave_rcu_node(rnp, flags);
+ 	rcu_state.gp_kthread = t;
+ 	if (kthread_prio) {
+ 		sp.sched_priority = kthread_prio;
+ 		sched_setscheduler_nocheck(t, SCHED_FIFO, &sp);
++>>>>>>> b97d23c51c9f (rcu: Remove for_each_rcu_flavor() flavor-traversal macro)
  	}
+ 	raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
+ 	wake_up_process(t);
  	rcu_spawn_nocb_kthreads();
  	rcu_spawn_boost_kthreads();
  	return 0;
* Unmerged path kernel/rcu/tree.c
diff --git a/kernel/rcu/tree.h b/kernel/rcu/tree.h
index 7c6033d71e9d..dc699bc712bd 100644
--- a/kernel/rcu/tree.h
+++ b/kernel/rcu/tree.h
@@ -362,7 +362,6 @@ struct rcu_state {
 						/*  jiffies. */
 	const char *name;			/* Name of structure. */
 	char abbr;				/* Abbreviated name. */
-	struct list_head flavors;		/* List of RCU flavors. */
 
 	spinlock_t ofl_lock ____cacheline_internodealigned_in_smp;
 						/* Synchronize offline with */
@@ -419,12 +418,6 @@ static const char *tp_rcu_varname __used __tracepoint_string = rcu_name;
 #define RCU_NAME rcu_name
 #endif /* #else #ifdef CONFIG_TRACING */
 
-extern struct list_head rcu_struct_flavors;
-
-/* Sequence through rcu_state structures for each RCU flavor. */
-#define for_each_rcu_flavor(rsp) \
-	list_for_each_entry((rsp), &rcu_struct_flavors, flavors)
-
 /*
  * RCU implementation internal declarations:
  */
diff --git a/kernel/rcu/tree_plugin.h b/kernel/rcu/tree_plugin.h
index 1a3e7482ab1d..15bd16cf032c 100644
--- a/kernel/rcu/tree_plugin.h
+++ b/kernel/rcu/tree_plugin.h
@@ -1562,31 +1562,28 @@ static bool __maybe_unused rcu_try_advance_all_cbs(void)
 	struct rcu_data *rdp;
 	struct rcu_dynticks *rdtp = this_cpu_ptr(&rcu_dynticks);
 	struct rcu_node *rnp;
-	struct rcu_state *rsp;
 
 	/* Exit early if we advanced recently. */
 	if (jiffies == rdtp->last_advance_all)
 		return false;
 	rdtp->last_advance_all = jiffies;
 
-	for_each_rcu_flavor(rsp) {
-		rdp = this_cpu_ptr(&rcu_data);
-		rnp = rdp->mynode;
+	rdp = this_cpu_ptr(&rcu_data);
+	rnp = rdp->mynode;
 
-		/*
-		 * Don't bother checking unless a grace period has
-		 * completed since we last checked and there are
-		 * callbacks not yet ready to invoke.
-		 */
-		if ((rcu_seq_completed_gp(rdp->gp_seq,
-					  rcu_seq_current(&rnp->gp_seq)) ||
-		     unlikely(READ_ONCE(rdp->gpwrap))) &&
-		    rcu_segcblist_pend_cbs(&rdp->cblist))
-			note_gp_changes(rdp);
-
-		if (rcu_segcblist_ready_cbs(&rdp->cblist))
-			cbs_ready = true;
-	}
+	/*
+	 * Don't bother checking unless a grace period has
+	 * completed since we last checked and there are
+	 * callbacks not yet ready to invoke.
+	 */
+	if ((rcu_seq_completed_gp(rdp->gp_seq,
+				  rcu_seq_current(&rnp->gp_seq)) ||
+	     unlikely(READ_ONCE(rdp->gpwrap))) &&
+	    rcu_segcblist_pend_cbs(&rdp->cblist))
+		note_gp_changes(rdp);
+
+	if (rcu_segcblist_ready_cbs(&rdp->cblist))
+		cbs_ready = true;
 	return cbs_ready;
 }
 
@@ -1649,7 +1646,6 @@ static void rcu_prepare_for_idle(void)
 	struct rcu_data *rdp;
 	struct rcu_dynticks *rdtp = this_cpu_ptr(&rcu_dynticks);
 	struct rcu_node *rnp;
-	struct rcu_state *rsp;
 	int tne;
 
 	lockdep_assert_irqs_disabled();
@@ -1687,10 +1683,8 @@ static void rcu_prepare_for_idle(void)
 	if (rdtp->last_accelerate == jiffies)
 		return;
 	rdtp->last_accelerate = jiffies;
-	for_each_rcu_flavor(rsp) {
-		rdp = this_cpu_ptr(&rcu_data);
-		if (!rcu_segcblist_pend_cbs(&rdp->cblist))
-			continue;
+	rdp = this_cpu_ptr(&rcu_data);
+	if (rcu_segcblist_pend_cbs(&rdp->cblist)) {
 		rnp = rdp->mynode;
 		raw_spin_lock_rcu_node(rnp); /* irqs already disabled. */
 		needwake = rcu_accelerate_cbs(rnp, rdp);
@@ -1825,10 +1819,7 @@ static void zero_cpu_stall_ticks(struct rcu_data *rdp)
 /* Increment ->ticks_this_gp for all flavors of RCU. */
 static void increment_cpu_stall_ticks(void)
 {
-	struct rcu_state *rsp;
-
-	for_each_rcu_flavor(rsp)
-		raw_cpu_inc(rcu_data.ticks_this_gp);
+	raw_cpu_inc(rcu_data.ticks_this_gp);
 }
 
 #ifdef CONFIG_RCU_NOCB_CPU
@@ -2385,7 +2376,6 @@ void __init rcu_init_nohz(void)
 {
 	int cpu;
 	bool need_rcu_nocb_mask = false;
-	struct rcu_state *rsp;
 
 #if defined(CONFIG_NO_HZ_FULL)
 	if (tick_nohz_full_running && cpumask_weight(tick_nohz_full_mask))
@@ -2419,11 +2409,9 @@ void __init rcu_init_nohz(void)
 	if (rcu_nocb_poll)
 		pr_info("\tPoll for callbacks from no-CBs CPUs.\n");
 
-	for_each_rcu_flavor(rsp) {
-		for_each_cpu(cpu, rcu_nocb_mask)
-			init_nocb_callback_list(per_cpu_ptr(&rcu_data, cpu));
-		rcu_organize_nocb_kthreads();
-	}
+	for_each_cpu(cpu, rcu_nocb_mask)
+		init_nocb_callback_list(per_cpu_ptr(&rcu_data, cpu));
+	rcu_organize_nocb_kthreads();
 }
 
 /* Initialize per-rcu_data variables for no-CBs CPUs. */
@@ -2490,11 +2478,8 @@ static void rcu_spawn_one_nocb_kthread(int cpu)
  */
 static void rcu_spawn_all_nocb_kthreads(int cpu)
 {
-	struct rcu_state *rsp;
-
 	if (rcu_scheduler_fully_active)
-		for_each_rcu_flavor(rsp)
-			rcu_spawn_one_nocb_kthread(cpu);
+		rcu_spawn_one_nocb_kthread(cpu);
 }
 
 /*
