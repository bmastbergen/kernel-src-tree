net/sched: act_skbedit: don't use spinlock in the data path

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
Rebuild_CHGLOG: - [net] sched: act_skbedit: don't use spinlock in the data path (Ivan Vecera) [1638022]
Rebuild_FUZZ: 96.49%
commit-author Davide Caratti <dcaratti@redhat.com>
commit c749cdda9089eb1fdb6a9ab98f945124d12f2595
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/c749cdda.failed

use RCU instead of spin_{,un}lock_bh, to protect concurrent read/write on
act_skbedit configuration. This reduces the effects of contention in the
data path, in case multiple readers are present.

	Signed-off-by: Davide Caratti <dcaratti@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c749cdda9089eb1fdb6a9ab98f945124d12f2595)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_skbedit.c
diff --cc net/sched/act_skbedit.c
index c802e1a85239,da56e6938c9e..000000000000
--- a/net/sched/act_skbedit.c
+++ b/net/sched/act_skbedit.c
@@@ -37,14 -37,19 +37,29 @@@ static int tcf_skbedit(struct sk_buff *
  		       struct tcf_result *res)
  {
  	struct tcf_skbedit *d = to_skbedit(a);
+ 	struct tcf_skbedit_params *params;
+ 	int action;
  
++<<<<<<< HEAD
 +	spin_lock(&d->tcf_lock);
 +	tcf_lastuse_update(&d->tcf_tm);
 +	bstats_update(&d->tcf_bstats, skb);
 +
 +	if (d->flags & SKBEDIT_F_PRIORITY)
 +		skb->priority = d->priority;
 +	if (d->flags & SKBEDIT_F_INHERITDSFIELD) {
++=======
+ 	tcf_lastuse_update(&d->tcf_tm);
+ 	bstats_cpu_update(this_cpu_ptr(d->common.cpu_bstats), skb);
+ 
+ 	rcu_read_lock();
+ 	params = rcu_dereference(d->params);
+ 	action = READ_ONCE(d->tcf_action);
+ 
+ 	if (params->flags & SKBEDIT_F_PRIORITY)
+ 		skb->priority = params->priority;
+ 	if (params->flags & SKBEDIT_F_INHERITDSFIELD) {
++>>>>>>> c749cdda9089 (net/sched: act_skbedit: don't use spinlock in the data path)
  		int wlen = skb_network_offset(skb);
  
  		switch (tc_skb_protocol(skb)) {
@@@ -63,23 -68,23 +78,29 @@@
  			break;
  		}
  	}
- 	if (d->flags & SKBEDIT_F_QUEUE_MAPPING &&
- 	    skb->dev->real_num_tx_queues > d->queue_mapping)
- 		skb_set_queue_mapping(skb, d->queue_mapping);
- 	if (d->flags & SKBEDIT_F_MARK) {
- 		skb->mark &= ~d->mask;
- 		skb->mark |= d->mark & d->mask;
+ 	if (params->flags & SKBEDIT_F_QUEUE_MAPPING &&
+ 	    skb->dev->real_num_tx_queues > params->queue_mapping)
+ 		skb_set_queue_mapping(skb, params->queue_mapping);
+ 	if (params->flags & SKBEDIT_F_MARK) {
+ 		skb->mark &= ~params->mask;
+ 		skb->mark |= params->mark & params->mask;
  	}
- 	if (d->flags & SKBEDIT_F_PTYPE)
- 		skb->pkt_type = d->ptype;
- 
- 	spin_unlock(&d->tcf_lock);
- 	return d->tcf_action;
+ 	if (params->flags & SKBEDIT_F_PTYPE)
+ 		skb->pkt_type = params->ptype;
  
+ unlock:
+ 	rcu_read_unlock();
+ 	return action;
  err:
++<<<<<<< HEAD
 +	d->tcf_qstats.drops++;
 +	spin_unlock(&d->tcf_lock);
 +	return TC_ACT_SHOT;
++=======
+ 	qstats_drop_inc(this_cpu_ptr(d->common.cpu_qstats));
+ 	action = TC_ACT_SHOT;
+ 	goto unlock;
++>>>>>>> c749cdda9089 (net/sched: act_skbedit: don't use spinlock in the data path)
  }
  
  static const struct nla_policy skbedit_policy[TCA_SKBEDIT_MAX + 1] = {
@@@ -172,30 -185,40 +194,39 @@@ static int tcf_skbedit_init(struct net 
  		ret = ACT_P_CREATED;
  	} else {
  		d = to_skbedit(*a);
 -		if (!ovr) {
 -			tcf_idr_release(*a, bind);
 +		tcf_idr_release(*a, bind);
 +		if (!ovr)
  			return -EEXIST;
 -		}
  	}
  
- 	spin_lock_bh(&d->tcf_lock);
+ 	ASSERT_RTNL();
  
- 	d->flags = flags;
+ 	params_new = kzalloc(sizeof(*params_new), GFP_KERNEL);
+ 	if (unlikely(!params_new)) {
+ 		if (ret == ACT_P_CREATED)
+ 			tcf_idr_release(*a, bind);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	params_new->flags = flags;
  	if (flags & SKBEDIT_F_PRIORITY)
- 		d->priority = *priority;
+ 		params_new->priority = *priority;
  	if (flags & SKBEDIT_F_QUEUE_MAPPING)
- 		d->queue_mapping = *queue_mapping;
+ 		params_new->queue_mapping = *queue_mapping;
  	if (flags & SKBEDIT_F_MARK)
- 		d->mark = *mark;
+ 		params_new->mark = *mark;
  	if (flags & SKBEDIT_F_PTYPE)
- 		d->ptype = *ptype;
+ 		params_new->ptype = *ptype;
  	/* default behaviour is to use all the bits */
- 	d->mask = 0xffffffff;
+ 	params_new->mask = 0xffffffff;
  	if (flags & SKBEDIT_F_MASK)
- 		d->mask = *mask;
+ 		params_new->mask = *mask;
  
  	d->tcf_action = parm->action;
- 
- 	spin_unlock_bh(&d->tcf_lock);
+ 	params_old = rtnl_dereference(d->params);
+ 	rcu_assign_pointer(d->params, params_new);
+ 	if (params_old)
+ 		kfree_rcu(params_old, rcu);
  
  	if (ret == ACT_P_CREATED)
  		tcf_idr_insert(tn, *a);
@@@ -207,14 -230,17 +238,17 @@@ static int tcf_skbedit_dump(struct sk_b
  {
  	unsigned char *b = skb_tail_pointer(skb);
  	struct tcf_skbedit *d = to_skbedit(a);
+ 	struct tcf_skbedit_params *params;
  	struct tc_skbedit opt = {
  		.index   = d->tcf_index,
 -		.refcnt  = refcount_read(&d->tcf_refcnt) - ref,
 -		.bindcnt = atomic_read(&d->tcf_bindcnt) - bind,
 +		.refcnt  = d->tcf_refcnt - ref,
 +		.bindcnt = d->tcf_bindcnt - bind,
  		.action  = d->tcf_action,
  	};
- 	struct tcf_t t;
  	u64 pure_flags = 0;
+ 	struct tcf_t t;
+ 
+ 	params = rtnl_dereference(d->params);
  
  	if (nla_put(skb, TCA_SKBEDIT_PARMS, sizeof(opt), &opt))
  		goto nla_put_failure;
diff --git a/include/net/tc_act/tc_skbedit.h b/include/net/tc_act/tc_skbedit.h
index 19cd3d345804..911bbac838a2 100644
--- a/include/net/tc_act/tc_skbedit.h
+++ b/include/net/tc_act/tc_skbedit.h
@@ -22,14 +22,19 @@
 #include <net/act_api.h>
 #include <linux/tc_act/tc_skbedit.h>
 
+struct tcf_skbedit_params {
+	u32 flags;
+	u32 priority;
+	u32 mark;
+	u32 mask;
+	u16 queue_mapping;
+	u16 ptype;
+	struct rcu_head rcu;
+};
+
 struct tcf_skbedit {
-	struct tc_action	common;
-	u32		flags;
-	u32		priority;
-	u32		mark;
-	u32		mask;
-	u16		queue_mapping;
-	u16		ptype;
+	struct tc_action common;
+	struct tcf_skbedit_params __rcu *params;
 };
 #define to_skbedit(a) ((struct tcf_skbedit *)a)
 
@@ -37,15 +42,27 @@ struct tcf_skbedit {
 static inline bool is_tcf_skbedit_mark(const struct tc_action *a)
 {
 #ifdef CONFIG_NET_CLS_ACT
-	if (a->ops && a->ops->type == TCA_ACT_SKBEDIT)
-		return to_skbedit(a)->flags == SKBEDIT_F_MARK;
+	u32 flags;
+
+	if (a->ops && a->ops->type == TCA_ACT_SKBEDIT) {
+		rcu_read_lock();
+		flags = rcu_dereference(to_skbedit(a)->params)->flags;
+		rcu_read_unlock();
+		return flags == SKBEDIT_F_MARK;
+	}
 #endif
 	return false;
 }
 
 static inline u32 tcf_skbedit_mark(const struct tc_action *a)
 {
-	return to_skbedit(a)->mark;
+	u32 mark;
+
+	rcu_read_lock();
+	mark = rcu_dereference(to_skbedit(a)->params)->mark;
+	rcu_read_unlock();
+
+	return mark;
 }
 
 #endif /* __NET_TC_SKBEDIT_H */
* Unmerged path net/sched/act_skbedit.c
