xfs: make xfs_file_remap_range() static

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Eric Biggers <ebiggers@google.com>
commit da034bcc6aaaf2a6ba6c5b5e63565c5ef4816a0e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/da034bcc.failed

xfs_file_remap_range() is only used in fs/xfs/xfs_file.c, so make it
static.

This addresses a gcc warning when -Wmissing-prototypes is enabled.

	Signed-off-by: Eric Biggers <ebiggers@google.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit da034bcc6aaaf2a6ba6c5b5e63565c5ef4816a0e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_file.c
diff --cc fs/xfs/xfs_file.c
index 61a5ad2600e8,e47425071e65..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -919,28 -919,67 +919,40 @@@ out_unlock
  	return error;
  }
  
++<<<<<<< HEAD
 +STATIC int
 +xfs_file_clone_range(
 +	struct file	*file_in,
 +	loff_t		pos_in,
 +	struct file	*file_out,
 +	loff_t		pos_out,
 +	u64		len)
++=======
+ 
+ STATIC loff_t
+ xfs_file_remap_range(
+ 	struct file		*file_in,
+ 	loff_t			pos_in,
+ 	struct file		*file_out,
+ 	loff_t			pos_out,
+ 	loff_t			len,
+ 	unsigned int		remap_flags)
++>>>>>>> da034bcc6aaa (xfs: make xfs_file_remap_range() static)
  {
 -	struct inode		*inode_in = file_inode(file_in);
 -	struct xfs_inode	*src = XFS_I(inode_in);
 -	struct inode		*inode_out = file_inode(file_out);
 -	struct xfs_inode	*dest = XFS_I(inode_out);
 -	struct xfs_mount	*mp = src->i_mount;
 -	loff_t			remapped = 0;
 -	xfs_extlen_t		cowextsize;
 -	int			ret;
 -
 -	if (remap_flags & ~(REMAP_FILE_DEDUP | REMAP_FILE_ADVISORY))
 -		return -EINVAL;
 -
 -	if (!xfs_sb_version_hasreflink(&mp->m_sb))
 -		return -EOPNOTSUPP;
 -
 -	if (XFS_FORCED_SHUTDOWN(mp))
 -		return -EIO;
 -
 -	/* Prepare and then clone file data. */
 -	ret = xfs_reflink_remap_prep(file_in, pos_in, file_out, pos_out,
 -			&len, remap_flags);
 -	if (ret < 0 || len == 0)
 -		return ret;
 -
 -	trace_xfs_reflink_remap_range(src, pos_in, len, dest, pos_out);
 -
 -	ret = xfs_reflink_remap_blocks(src, pos_in, dest, pos_out, len,
 -			&remapped);
 -	if (ret)
 -		goto out_unlock;
 -
 -	/*
 -	 * Carry the cowextsize hint from src to dest if we're sharing the
 -	 * entire source file to the entire destination file, the source file
 -	 * has a cowextsize hint, and the destination file does not.
 -	 */
 -	cowextsize = 0;
 -	if (pos_in == 0 && len == i_size_read(inode_in) &&
 -	    (src->i_d.di_flags2 & XFS_DIFLAG2_COWEXTSIZE) &&
 -	    pos_out == 0 && len >= i_size_read(inode_out) &&
 -	    !(dest->i_d.di_flags2 & XFS_DIFLAG2_COWEXTSIZE))
 -		cowextsize = src->i_d.di_cowextsize;
 -
 -	ret = xfs_reflink_update_dest(dest, pos_out + len, cowextsize,
 -			remap_flags);
 +	return xfs_reflink_remap_range(file_in, pos_in, file_out, pos_out,
 +				     len, false);
 +}
  
 -out_unlock:
 -	xfs_reflink_remap_unlock(file_in, file_out);
 -	if (ret)
 -		trace_xfs_reflink_remap_range_error(dest, ret, _RET_IP_);
 -	return remapped > 0 ? remapped : ret;
 +STATIC int
 +xfs_file_dedupe_range(
 +	struct file	*file_in,
 +	loff_t		pos_in,
 +	struct file	*file_out,
 +	loff_t		pos_out,
 +	u64		len)
 +{
 +	return xfs_reflink_remap_range(file_in, pos_in, file_out, pos_out,
 +				     len, true);
  }
  
  STATIC int
* Unmerged path fs/xfs/xfs_file.c
