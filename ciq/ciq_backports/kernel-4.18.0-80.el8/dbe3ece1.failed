dm: don't reuse bio for flushes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit dbe3ece1287dafe4113c64ada3113c39f344c64a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/dbe3ece1.failed

DM currently has a statically allocated bio that it uses to issue empty
flushes. It doesn't submit this bio, it just uses it for maintaining
state while setting up clones. Multiple users can access this bio at the
same time. This wasn't previously an issue, even if it was a bit iffy,
but with the blkg associations it can become one.

We setup the blkg association, then clone bio's and submit, then remove
the blkg assocation again. But since we can have multiple tasks doing
this at the same time, against multiple blkg's, then we can either lose
references to a blkg, or put it twice. The latter causes complaints on
the percpu ref being <= 0 when released, and can cause use-after-free as
well. Ming reports that xfstest generic/475 triggers this:

------------[ cut here ]------------
percpu ref (blkg_release) <= 0 (0) after switching to atomic
WARNING: CPU: 13 PID: 0 at lib/percpu-refcount.c:155 percpu_ref_switch_to_atomic_rcu+0x2c9/0x4a0

Switch to just using an on-stack bio for this, and get rid of the
embedded bio.

Fixes: 5cdf2e3fea5e ("blkcg: associate blkg when associating a device")
	Reported-by: Ming Lei <ming.lei@redhat.com>
	Tested-by: Ming Lei <ming.lei@redhat.com>
	Reviewed-by: Mike Snitzer <snitzer@redhat.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit dbe3ece1287dafe4113c64ada3113c39f344c64a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index 6816867057ad,f588a6a83d80..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -1419,6 -1419,15 +1419,18 @@@ static int __send_empty_flush(struct cl
  	unsigned target_nr = 0;
  	struct dm_target *ti;
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Empty flush uses a statically initialized bio, as the base for
+ 	 * cloning.  However, blkg association requires that a bdev is
+ 	 * associated with a gendisk, which doesn't happen until the bdev is
+ 	 * opened.  So, blkg association is done at issue time of the flush
+ 	 * rather than when the device is created in alloc_dev().
+ 	 */
+ 	bio_set_dev(ci->bio, ci->io->md->bdev);
+ 
++>>>>>>> dbe3ece1287d (dm: don't reuse bio for flushes)
  	BUG_ON(bio_has_data(ci->bio));
  	while ((ti = dm_table_get_target(ci->map, target_nr++)))
  		__send_duplicate_bios(ci, ti, ti->num_flush_bios, NULL);
@@@ -1923,10 -1967,6 +1953,13 @@@ static struct mapped_device *alloc_dev(
  	if (!md->bdev)
  		goto bad;
  
++<<<<<<< HEAD
 +	bio_init(&md->flush_bio, NULL, 0);
 +	bio_set_dev(&md->flush_bio, md->bdev);
 +	md->flush_bio.bi_opf = REQ_OP_WRITE | REQ_PREFLUSH | REQ_SYNC;
 +
++=======
++>>>>>>> dbe3ece1287d (dm: don't reuse bio for flushes)
  	dm_stats_init(&md->stats);
  
  	/* Populate the mapping, nobody knows we exist yet */
diff --git a/drivers/md/dm-core.h b/drivers/md/dm-core.h
index 6fe883fac471..95c6d86ab5e8 100644
--- a/drivers/md/dm-core.h
+++ b/drivers/md/dm-core.h
@@ -106,9 +106,6 @@ struct mapped_device {
 
 	struct block_device *bdev;
 
-	/* zero-length flush that will be cloned and submitted to targets */
-	struct bio flush_bio;
-
 	struct dm_stats stats;
 
 	/* for blk-mq request-based DM support */
* Unmerged path drivers/md/dm.c
