dma-direct: refine dma_direct_alloc zone selection

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 7d21ee4c719f00896767ce19c4c01a56374c2ced
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/7d21ee4c.failed

We need to take the DMA offset and encryption bit into account when
selecting a zone.  User the opportunity to factor out the zone
selection into a helper for reuse.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Robin Murphy <robin.murphy@arm.com>
(cherry picked from commit 7d21ee4c719f00896767ce19c4c01a56374c2ced)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/dma/direct.c
diff --cc kernel/dma/direct.c
index 2ba3b52698ea,e78548397a92..000000000000
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@@ -49,15 -54,45 +49,49 @@@ check_addr(struct device *dev, dma_addr
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ static inline dma_addr_t phys_to_dma_direct(struct device *dev,
+ 		phys_addr_t phys)
+ {
+ 	if (force_dma_unencrypted())
+ 		return __phys_to_dma(dev, phys);
+ 	return phys_to_dma(dev, phys);
+ }
+ 
+ u64 dma_direct_get_required_mask(struct device *dev)
+ {
+ 	u64 max_dma = phys_to_dma_direct(dev, (max_pfn - 1) << PAGE_SHIFT);
+ 
+ 	return (1ULL << (fls64(max_dma) - 1)) * 2 - 1;
+ }
+ 
+ static gfp_t __dma_direct_optimal_gfp_mask(struct device *dev, u64 dma_mask,
+ 		u64 *phys_mask)
+ {
+ 	if (force_dma_unencrypted())
+ 		*phys_mask = __dma_to_phys(dev, dma_mask);
+ 	else
+ 		*phys_mask = dma_to_phys(dev, dma_mask);
+ 
+ 	/* GFP_DMA32 and GFP_DMA are no ops without the corresponding zones: */
+ 	if (*phys_mask <= DMA_BIT_MASK(ARCH_ZONE_DMA_BITS))
+ 		return GFP_DMA;
+ 	if (*phys_mask <= DMA_BIT_MASK(32))
+ 		return GFP_DMA32;
+ 	return 0;
+ }
+ 
++>>>>>>> 7d21ee4c719f (dma-direct: refine dma_direct_alloc zone selection)
  static bool dma_coherent_ok(struct device *dev, phys_addr_t phys, size_t size)
  {
 -	return phys_to_dma_direct(dev, phys) + size - 1 <=
 -			dev->coherent_dma_mask;
 +	dma_addr_t addr = force_dma_unencrypted() ?
 +		__phys_to_dma(dev, phys) : phys_to_dma(dev, phys);
 +	return addr + size - 1 <= dev->coherent_dma_mask;
  }
  
 -void *dma_direct_alloc_pages(struct device *dev, size_t size,
 -		dma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs)
 +void *dma_direct_alloc(struct device *dev, size_t size, dma_addr_t *dma_handle,
 +		gfp_t gfp, unsigned long attrs)
  {
  	unsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;
  	int page_order = get_order(size);
* Unmerged path kernel/dma/direct.c
