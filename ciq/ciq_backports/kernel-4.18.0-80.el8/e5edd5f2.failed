blk-mq: skip zero-queue maps in blk_mq_map_swqueue

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Ming Lei <ming.lei@redhat.com>
commit e5edd5f298fafda28284bafb8371e6f0b7681035
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/e5edd5f2.failed

From 7e849dd9cf37 ("nvme-pci: don't share queue maps"), the mapping
table won't be initialized actually if map->nr_queues is zero, so
we can't use blk_mq_map_queue_type() to retrieve hctx any more.

This way still may cause broken mapping, fix it by skipping zero-queues
maps in blk_mq_map_swqueue().

	Cc: Jeff Moyer <jmoyer@redhat.com>
	Cc: Mike Snitzer <snitzer@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit e5edd5f298fafda28284bafb8371e6f0b7681035)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index 3326a4ca1205,6847f014606b..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -2394,11 -2437,31 +2394,19 @@@ static void blk_mq_map_swqueue(struct r
  		}
  
  		ctx = per_cpu_ptr(q->queue_ctx, i);
++<<<<<<< HEAD
 +		hctx = blk_mq_map_queue(q, i);
++=======
+ 		for (j = 0; j < set->nr_maps; j++) {
+ 			if (!set->map[j].nr_queues)
+ 				continue;
+ 
+ 			hctx = blk_mq_map_queue_type(q, j, i);
++>>>>>>> e5edd5f298fa (blk-mq: skip zero-queue maps in blk_mq_map_swqueue)
  
 -			/*
 -			 * If the CPU is already set in the mask, then we've
 -			 * mapped this one already. This can happen if
 -			 * devices share queues across queue maps.
 -			 */
 -			if (cpumask_test_cpu(i, hctx->cpumask))
 -				continue;
 -
 -			cpumask_set_cpu(i, hctx->cpumask);
 -			hctx->type = j;
 -			ctx->index_hw[hctx->type] = hctx->nr_ctx;
 -			hctx->ctxs[hctx->nr_ctx++] = ctx;
 -
 -			/*
 -			 * If the nr_ctx type overflows, we have exceeded the
 -			 * amount of sw queues we can support.
 -			 */
 -			BUG_ON(!hctx->nr_ctx);
 -		}
 +		cpumask_set_cpu(i, hctx->cpumask);
 +		ctx->index_hw = hctx->nr_ctx;
 +		hctx->ctxs[hctx->nr_ctx++] = ctx;
  	}
  
  	mutex_unlock(&q->sysfs_lock);
* Unmerged path block/blk-mq.c
