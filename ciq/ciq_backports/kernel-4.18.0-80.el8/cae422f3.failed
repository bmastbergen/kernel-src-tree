net: sched: use reference counting action init

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
Rebuild_CHGLOG: - [net] sched: use reference counting action init (Ivan Vecera) [1638022]
Rebuild_FUZZ: 94.25%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit cae422f379f37fe9105d2a113259788f989e7df5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/cae422f3.failed

Change action API to assume that action init function always takes
reference to action, even when overwriting existing action. This is
necessary because action API continues to use action pointer after init
function is done. At this point action becomes accessible for concurrent
modifications, so user must always hold reference to it.

Implement helper put list function to atomically release list of actions
after action API init code is done using them.

	Reviewed-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cae422f379f37fe9105d2a113259788f989e7df5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_api.c
diff --cc net/sched/act_api.c
index d445f144d9dc,eefe8c2fe667..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -609,6 -622,23 +609,26 @@@ int tcf_action_destroy(struct list_hea
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_action_put(struct tc_action *p)
+ {
+ 	return __tcf_action_put(p, false);
+ }
+ 
+ static void tcf_action_put_lst(struct list_head *actions)
+ {
+ 	struct tc_action *a, *tmp;
+ 
+ 	list_for_each_entry_safe(a, tmp, actions, list) {
+ 		const struct tc_action_ops *ops = a->ops;
+ 
+ 		if (tcf_action_put(a))
+ 			module_put(ops->owner);
+ 	}
+ }
+ 
++>>>>>>> cae422f379f3 (net: sched: use reference counting action init)
  int
  tcf_action_dump_old(struct sk_buff *skb, struct tc_action *a, int bind, int ref)
  {
@@@ -817,17 -847,6 +837,20 @@@ err_out
  	return ERR_PTR(err);
  }
  
++<<<<<<< HEAD
 +static void cleanup_a(struct list_head *actions, int ovr)
 +{
 +	struct tc_action *a;
 +
 +	if (!ovr)
 +		return;
 +
 +	list_for_each_entry(a, actions, list)
 +		a->tcfa_refcnt--;
 +}
 +
++=======
++>>>>>>> cae422f379f3 (net: sched: use reference counting action init)
  int tcf_action_init(struct net *net, struct tcf_proto *tp, struct nlattr *nla,
  		    struct nlattr *est, char *name, int ovr, int bind,
  		    struct list_head *actions, size_t *attr_size,
@@@ -1164,8 -1205,7 +1182,12 @@@ tca_action_gd(struct net *net, struct n
  		return ret;
  	}
  err:
++<<<<<<< HEAD
 +	if (event != RTM_GETACTION)
 +		tcf_action_destroy(&actions, 0);
++=======
+ 	tcf_action_put_lst(&actions);
++>>>>>>> cae422f379f3 (net: sched: use reference counting action init)
  	return ret;
  }
  
* Unmerged path net/sched/act_api.c
