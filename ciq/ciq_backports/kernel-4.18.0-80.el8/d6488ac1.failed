PCI: Mark fall-through switch cases before enabling -Wimplicit-fallthrough

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Gustavo A. R. Silva <gustavo@embeddedor.com>
commit d6488ac19aabcc6c85a74b69eaf1b7301124c323
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/d6488ac1.failed

In preparation to enabling -Wimplicit-fallthrough, mark switch cases where
we are expecting to fall through.

Warning level 2 was used: -Wimplicit-fallthrough=2

	Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit d6488ac19aabcc6c85a74b69eaf1b7301124c323)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/pciehp_ctrl.c
diff --cc drivers/pci/hotplug/pciehp_ctrl.c
index da7c72372ffc,cfc46e82ceca..000000000000
--- a/drivers/pci/hotplug/pciehp_ctrl.c
+++ b/drivers/pci/hotplug/pciehp_ctrl.c
@@@ -370,17 -435,17 +370,24 @@@ int pciehp_sysfs_enable_slot(struct slo
  	mutex_lock(&p_slot->lock);
  	switch (p_slot->state) {
  	case BLINKINGON_STATE:
++<<<<<<< HEAD
 +	case OFF_STATE:
++=======
+ 		cancel_delayed_work(&p_slot->work);
+ 		/* fall through */
+ 	case STATIC_STATE:
+ 		p_slot->state = POWERON_STATE;
++>>>>>>> d6488ac19aab (PCI: Mark fall-through switch cases before enabling -Wimplicit-fallthrough)
  		mutex_unlock(&p_slot->lock);
 -		mutex_lock(&p_slot->hotplug_lock);
 -		retval = pciehp_enable_slot(p_slot);
 -		mutex_unlock(&p_slot->hotplug_lock);
 -		mutex_lock(&p_slot->lock);
 -		p_slot->state = STATIC_STATE;
 -		break;
 +		/*
 +		 * The IRQ thread becomes a no-op if the user pulls out the
 +		 * card before the thread wakes up, so initialize to -ENODEV.
 +		 */
 +		ctrl->request_result = -ENODEV;
 +		pciehp_request(ctrl, PCI_EXP_SLTSTA_PDC);
 +		wait_event(ctrl->requester,
 +			   !atomic_read(&ctrl->pending_events));
 +		return ctrl->request_result;
  	case POWERON_STATE:
  		ctrl_info(ctrl, "Slot(%s): Already in powering on state\n",
  			  slot_name(p_slot));
@@@ -408,12 -473,17 +415,19 @@@ int pciehp_sysfs_disable_slot(struct sl
  	mutex_lock(&p_slot->lock);
  	switch (p_slot->state) {
  	case BLINKINGOFF_STATE:
++<<<<<<< HEAD
 +	case ON_STATE:
++=======
+ 		cancel_delayed_work(&p_slot->work);
+ 		/* fall through */
+ 	case STATIC_STATE:
+ 		p_slot->state = POWEROFF_STATE;
++>>>>>>> d6488ac19aab (PCI: Mark fall-through switch cases before enabling -Wimplicit-fallthrough)
  		mutex_unlock(&p_slot->lock);
 -		mutex_lock(&p_slot->hotplug_lock);
 -		retval = pciehp_disable_slot(p_slot);
 -		mutex_unlock(&p_slot->hotplug_lock);
 -		mutex_lock(&p_slot->lock);
 -		p_slot->state = STATIC_STATE;
 -		break;
 +		pciehp_request(ctrl, DISABLE_SLOT);
 +		wait_event(ctrl->requester,
 +			   !atomic_read(&ctrl->pending_events));
 +		return ctrl->request_result;
  	case POWEROFF_STATE:
  		ctrl_info(ctrl, "Slot(%s): Already in powering off state\n",
  			  slot_name(p_slot));
* Unmerged path drivers/pci/hotplug/pciehp_ctrl.c
diff --git a/drivers/pci/hotplug/shpchp_ctrl.c b/drivers/pci/hotplug/shpchp_ctrl.c
index 1047b56e5730..1267dcc5a531 100644
--- a/drivers/pci/hotplug/shpchp_ctrl.c
+++ b/drivers/pci/hotplug/shpchp_ctrl.c
@@ -654,6 +654,7 @@ int shpchp_sysfs_enable_slot(struct slot *p_slot)
 	switch (p_slot->state) {
 	case BLINKINGON_STATE:
 		cancel_delayed_work(&p_slot->work);
+		/* fall through */
 	case STATIC_STATE:
 		p_slot->state = POWERON_STATE;
 		mutex_unlock(&p_slot->lock);
@@ -689,6 +690,7 @@ int shpchp_sysfs_disable_slot(struct slot *p_slot)
 	switch (p_slot->state) {
 	case BLINKINGOFF_STATE:
 		cancel_delayed_work(&p_slot->work);
+		/* fall through */
 	case STATIC_STATE:
 		p_slot->state = POWEROFF_STATE;
 		mutex_unlock(&p_slot->lock);
diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 588886371df1..0306fa44653a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2044,6 +2044,7 @@ static pci_power_t pci_target_state(struct pci_dev *dev, bool wakeup)
 		case PCI_D2:
 			if (pci_no_d1d2(dev))
 				break;
+			/* else: fall through */
 		default:
 			target_state = state;
 		}
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index cab2d5f922a9..cd66803d2bcf 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -2105,6 +2105,7 @@ static void quirk_netmos(struct pci_dev *dev)
 		if (dev->subsystem_vendor == PCI_VENDOR_ID_IBM &&
 				dev->subsystem_device == 0x0299)
 			return;
+		/* else: fall through */
 	case PCI_DEVICE_ID_NETMOS_9735:
 	case PCI_DEVICE_ID_NETMOS_9745:
 	case PCI_DEVICE_ID_NETMOS_9845:
