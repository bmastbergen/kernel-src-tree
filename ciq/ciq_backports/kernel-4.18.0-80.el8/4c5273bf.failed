rcu: Switch dyntick nesting counters to rcu_data structure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Paul E. McKenney <paulmck@linux.vnet.ibm.com>
commit 4c5273bf2b5ed9b585e470dda19c09c875a9fbbd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/4c5273bf.failed

This commit removes ->dynticks_nesting and ->dynticks_nmi_nesting from
the rcu_dynticks structure and updates the code to access them from the
rcu_data structure.

	Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
(cherry picked from commit 4c5273bf2b5ed9b585e470dda19c09c875a9fbbd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/rcu/tree.c
diff --cc kernel/rcu/tree.c
index 65383db6b433,bfa264a6f3fc..000000000000
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@@ -546,8 -572,7 +547,12 @@@ static struct rcu_node *rcu_get_root(vo
   */
  static void rcu_eqs_enter(bool user)
  {
++<<<<<<< HEAD
 +	struct rcu_state *rsp;
 +	struct rcu_data *rdp;
++=======
+ 	struct rcu_data *rdp = this_cpu_ptr(&rcu_data);
++>>>>>>> 4c5273bf2b5e (rcu: Switch dyntick nesting counters to rcu_data structure)
  	struct rcu_dynticks *rdtp;
  
  	rdtp = this_cpu_ptr(&rcu_dynticks);
@@@ -561,15 -586,13 +566,15 @@@
  	}
  
  	lockdep_assert_irqs_disabled();
- 	trace_rcu_dyntick(TPS("Start"), rdtp->dynticks_nesting, 0, rdtp->dynticks);
+ 	trace_rcu_dyntick(TPS("Start"), rdp->dynticks_nesting, 0, rdtp->dynticks);
  	WARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));
 -	rdp = this_cpu_ptr(&rcu_data);
 -	do_nocb_deferred_wakeup(rdp);
 +	for_each_rcu_flavor(rsp) {
 +		rdp = this_cpu_ptr(&rcu_data);
 +		do_nocb_deferred_wakeup(rdp);
 +	}
  	rcu_prepare_for_idle();
  	rcu_preempt_deferred_qs(current);
- 	WRITE_ONCE(rdtp->dynticks_nesting, 0); /* Avoid irq-access tearing. */
+ 	WRITE_ONCE(rdp->dynticks_nesting, 0); /* Avoid irq-access tearing. */
  	rcu_dynticks_eqs_enter();
  	rcu_dynticks_task_enter();
  }
* Unmerged path kernel/rcu/tree.c
diff --git a/kernel/rcu/tree.h b/kernel/rcu/tree.h
index 971069b043e9..9f48be338452 100644
--- a/kernel/rcu/tree.h
+++ b/kernel/rcu/tree.h
@@ -38,8 +38,6 @@
  * Dynticks per-CPU state.
  */
 struct rcu_dynticks {
-	long dynticks_nesting;      /* Track process nesting level. */
-	long dynticks_nmi_nesting;  /* Track irq/NMI nesting level. */
 	atomic_t dynticks;	    /* Even value for idle, else odd. */
 	bool rcu_need_heavy_qs;     /* GP old, need heavy quiescent state. */
 	unsigned long rcu_qs_ctr;   /* Light universal quiescent state ctr. */
diff --git a/kernel/rcu/tree_plugin.h b/kernel/rcu/tree_plugin.h
index 6d38152e918f..3bf8102b3f08 100644
--- a/kernel/rcu/tree_plugin.h
+++ b/kernel/rcu/tree_plugin.h
@@ -1843,7 +1843,7 @@ static void print_cpu_stall_info(int cpu)
 				"!."[!delta],
 	       ticks_value, ticks_title,
 	       rcu_dynticks_snap(rdtp) & 0xfff,
-	       rdtp->dynticks_nesting, rdtp->dynticks_nmi_nesting,
+	       rdp->dynticks_nesting, rdp->dynticks_nmi_nesting,
 	       rdp->softirq_snap, kstat_softirqs_cpu(RCU_SOFTIRQ, cpu),
 	       READ_ONCE(rcu_state.n_force_qs) - rcu_state.n_force_qs_gpstart,
 	       fast_no_hz);
