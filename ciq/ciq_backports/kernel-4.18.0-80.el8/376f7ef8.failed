block: only allow polling if a poll queue_map exists

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 376f7ef8bfeaee3993c2e85df1bbaa06725b9342
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/376f7ef8.failed

This avoids having to have differnet mq_ops for different setups
with or without poll queues.

	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 376f7ef8bfeaee3993c2e85df1bbaa06725b9342)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/pci.c
diff --cc drivers/nvme/host/pci.c
index e63d03795df8,7732c4979a4e..000000000000
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@@ -1601,24 -1602,15 +1601,36 @@@ static const struct blk_mq_ops nvme_mq_
  	.timeout	= nvme_timeout,
  };
  
++<<<<<<< HEAD
 +#define NVME_SHARED_MQ_OPS					\
 +	.queue_rq		= nvme_queue_rq,		\
 +	.commit_rqs		= nvme_commit_rqs,		\
 +	.rq_flags_to_type	= nvme_rq_flags_to_type,	\
 +	.complete		= nvme_pci_complete_rq,		\
 +	.init_hctx		= nvme_init_hctx,		\
 +	.init_request		= nvme_init_request,		\
 +	.map_queues		= nvme_pci_map_queues,		\
 +	.timeout		= nvme_timeout			\
 +
 +static const struct blk_mq_ops nvme_mq_ops = {
 +	NVME_SHARED_MQ_OPS,
 +	.poll			= nvme_poll,
 +};
 +
 +static const struct blk_mq_ops nvme_mq_poll_noirq_ops = {
 +	NVME_SHARED_MQ_OPS,
 +	.poll			= nvme_poll_noirq,
++=======
+ static const struct blk_mq_ops nvme_mq_ops = {
+ 	.queue_rq	= nvme_queue_rq,
+ 	.complete	= nvme_pci_complete_rq,
+ 	.commit_rqs	= nvme_commit_rqs,
+ 	.init_hctx	= nvme_init_hctx,
+ 	.init_request	= nvme_init_request,
+ 	.map_queues	= nvme_pci_map_queues,
+ 	.timeout	= nvme_timeout,
+ 	.poll		= nvme_poll,
++>>>>>>> 376f7ef8bfea (block: only allow polling if a poll queue_map exists)
  };
  
  static void nvme_dev_remove_admin(struct nvme_dev *dev)
@@@ -2305,13 -2297,9 +2317,17 @@@ static int nvme_dev_add(struct nvme_de
  	int ret;
  
  	if (!dev->ctrl.tagset) {
++<<<<<<< HEAD
 +		if (!dev->io_queues[NVMEQ_TYPE_POLL])
 +			dev->tagset.ops = &nvme_mq_ops;
 +		else
 +			dev->tagset.ops = &nvme_mq_poll_noirq_ops;
 +
++=======
+ 		dev->tagset.ops = &nvme_mq_ops;
++>>>>>>> 376f7ef8bfea (block: only allow polling if a poll queue_map exists)
  		dev->tagset.nr_hw_queues = dev->online_queues - 1;
 -		dev->tagset.nr_maps = HCTX_MAX_TYPES;
 +		dev->tagset.nr_maps = NVMEQ_TYPE_NR;
  		dev->tagset.timeout = NVME_IO_TIMEOUT;
  		dev->tagset.numa_node = dev_to_node(dev->dev);
  		dev->tagset.queue_depth =
diff --git a/block/blk-sysfs.c b/block/blk-sysfs.c
index b8a7832d6c94..67dac6bd2456 100644
--- a/block/blk-sysfs.c
+++ b/block/blk-sysfs.c
@@ -405,7 +405,7 @@ static ssize_t queue_poll_store(struct request_queue *q, const char *page,
 	unsigned long poll_on;
 	ssize_t ret;
 
-	if (!q->mq_ops || !q->mq_ops->poll)
+	if (!q->tag_set || q->tag_set->nr_maps <= HCTX_TYPE_POLL)
 		return -EINVAL;
 
 	ret = queue_var_store(&poll_on, page, count);
* Unmerged path drivers/nvme/host/pci.c
