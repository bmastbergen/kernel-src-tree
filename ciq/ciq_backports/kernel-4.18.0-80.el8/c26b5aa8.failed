gfs2: Fix iomap buffer head reference counting bug

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit c26b5aa8ef0d46035060fded475e6ab957b9f69f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/c26b5aa8.failed

GFS2 passes the inode buffer head (dibh) from gfs2_iomap_begin to
gfs2_iomap_end in iomap->private.  It sets that private pointer in
gfs2_iomap_get.  Users of gfs2_iomap_get other than gfs2_iomap_begin
would have to release iomap->private, but this isn't done correctly,
leading to a leak of buffer head references.

To fix this, move the code for setting iomap->private from
gfs2_iomap_get to gfs2_iomap_begin.

Fixes: 64bc06bb32 ("gfs2: iomap buffered write support")
	Cc: stable@vger.kernel.org # v4.19+
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit c26b5aa8ef0d46035060fded475e6ab957b9f69f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/bmap.c
diff --cc fs/gfs2/bmap.c
index ff1652f71f1a,0d643306c255..000000000000
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@@ -1056,8 -1049,7 +1049,12 @@@ static int gfs2_iomap_begin_write(struc
  			goto out_qunlock;
  		}
  	}
++<<<<<<< HEAD
 +	release_metapath(&mp);
 +	if (!gfs2_is_stuffed(ip) && gfs2_is_jdata(ip))
++=======
+ 	if (gfs2_is_jdata(ip))
++>>>>>>> c26b5aa8ef0d (gfs2: Fix iomap buffer head reference counting bug)
  		iomap->page_done = gfs2_iomap_journaled_page_done;
  	return 0;
  
@@@ -1084,12 -1073,14 +1078,12 @@@ static int gfs2_iomap_begin(struct inod
  	struct metapath mp = { .mp_aheight = 1, };
  	int ret;
  
 -	iomap->flags |= IOMAP_F_BUFFER_HEAD;
 -
  	trace_gfs2_iomap_start(ip, pos, length, flags);
  	if ((flags & IOMAP_WRITE) && !(flags & IOMAP_DIRECT)) {
- 		ret = gfs2_iomap_begin_write(inode, pos, length, flags, iomap);
+ 		ret = gfs2_iomap_begin_write(inode, pos, length, flags, iomap, &mp);
  	} else {
  		ret = gfs2_iomap_get(inode, pos, length, flags, iomap, &mp);
- 		release_metapath(&mp);
+ 
  		/*
  		 * Silently fall back to buffered I/O for stuffed files or if
  		 * we've hot a hole (see gfs2_file_direct_write).
* Unmerged path fs/gfs2/bmap.c
