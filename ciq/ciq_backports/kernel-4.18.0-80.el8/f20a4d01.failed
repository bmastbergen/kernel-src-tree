net: sched: act_nat: remove dependency on rtnl lock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
Rebuild_CHGLOG: - [net] sched: act_nat: remove dependency on rtnl lock (Ivan Vecera) [1638022]
Rebuild_FUZZ: 94.85%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit f20a4d01175ad681a88d571c6391d188453ca6d0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/f20a4d01.failed

According to the new locking rule, we have to take tcf_lock for both
->init() and ->dump(), as RTNL will be removed.

Use tcf spinlock to protect private nat action data from concurrent
modification during dump. (nat init already uses tcf spinlock when changing
action state)

	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f20a4d01175ad681a88d571c6391d188453ca6d0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_nat.c
diff --cc net/sched/act_nat.c
index c088a7e80ef2,c5c1e23add77..000000000000
--- a/net/sched/act_nat.c
+++ b/net/sched/act_nat.c
@@@ -250,15 -256,9 +250,15 @@@ static int tcf_nat_dump(struct sk_buff 
  	unsigned char *b = skb_tail_pointer(skb);
  	struct tcf_nat *p = to_tcf_nat(a);
  	struct tc_nat opt = {
- 		.old_addr = p->old_addr,
- 		.new_addr = p->new_addr,
- 		.mask     = p->mask,
- 		.flags    = p->flags,
- 
  		.index    = p->tcf_index,
++<<<<<<< HEAD
 +		.action   = p->tcf_action,
 +		.refcnt   = p->tcf_refcnt - ref,
 +		.bindcnt  = p->tcf_bindcnt - bind,
++=======
+ 		.refcnt   = refcount_read(&p->tcf_refcnt) - ref,
+ 		.bindcnt  = atomic_read(&p->tcf_bindcnt) - bind,
++>>>>>>> f20a4d01175a (net: sched: act_nat: remove dependency on rtnl lock)
  	};
  	struct tcf_t t;
  
* Unmerged path net/sched/act_nat.c
