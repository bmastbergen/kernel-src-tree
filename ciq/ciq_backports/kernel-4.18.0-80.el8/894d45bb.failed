rcu: Convert rcu_state.ofl_lock to raw_spinlock_t

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Mike Galbraith <efault@gmx.de>
commit 894d45bbf7e7569ec2aa845155801fd503b5f1bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/894d45bb.failed

1e64b15a4b10 ("rcu: Fix grace-period hangs due to race with CPU offline")
added spinlock_t ofl_lock to the rcu_state structure, then takes it with
preemption disabled during CPU offline, which gives the -rt patchset's
sleeping spinlock heartburn.

This commit therefore converts ->ofl_lock to raw_spinlock_t.

	Signed-off-by: Mike Galbraith <efault@gmx.de>
	Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
(cherry picked from commit 894d45bbf7e7569ec2aa845155801fd503b5f1bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/rcu/tree.c
diff --cc kernel/rcu/tree.c
index 65383db6b433,58aa6c2fd7fa..000000000000
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@@ -82,11 -97,9 +82,11 @@@ struct rcu_state rcu_state = 
  	.abbr = RCU_ABBR,
  	.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),
  	.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),
- 	.ofl_lock = __SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),
+ 	.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),
  };
  
 +LIST_HEAD(rcu_struct_flavors);
 +
  /* Dump rcu_node combining tree at boot to verify correct setup. */
  static bool dump_tree;
  module_param(dump_tree, bool, 0444);
@@@ -1770,15 -1774,15 +1770,25 @@@ static bool rcu_gp_init(struct rcu_stat
  	 * for subsequent online CPUs, and that quiescent-state forcing
  	 * will handle subsequent offline CPUs.
  	 */
++<<<<<<< HEAD
 +	rsp->gp_state = RCU_GP_ONOFF;
 +	rcu_for_each_leaf_node(rsp, rnp) {
 +		spin_lock(&rsp->ofl_lock);
++=======
+ 	rcu_state.gp_state = RCU_GP_ONOFF;
+ 	rcu_for_each_leaf_node(rnp) {
+ 		raw_spin_lock(&rcu_state.ofl_lock);
++>>>>>>> 894d45bbf7e7 (rcu: Convert rcu_state.ofl_lock to raw_spinlock_t)
  		raw_spin_lock_irq_rcu_node(rnp);
  		if (rnp->qsmaskinit == rnp->qsmaskinitnext &&
  		    !rnp->wait_blkd_tasks) {
  			/* Nothing to do on this leaf rcu_node structure. */
  			raw_spin_unlock_irq_rcu_node(rnp);
++<<<<<<< HEAD
 +			spin_unlock(&rsp->ofl_lock);
++=======
+ 			raw_spin_unlock(&rcu_state.ofl_lock);
++>>>>>>> 894d45bbf7e7 (rcu: Convert rcu_state.ofl_lock to raw_spinlock_t)
  			continue;
  		}
  
@@@ -1814,7 -1818,7 +1824,11 @@@
  		}
  
  		raw_spin_unlock_irq_rcu_node(rnp);
++<<<<<<< HEAD
 +		spin_unlock(&rsp->ofl_lock);
++=======
+ 		raw_spin_unlock(&rcu_state.ofl_lock);
++>>>>>>> 894d45bbf7e7 (rcu: Convert rcu_state.ofl_lock to raw_spinlock_t)
  	}
  	rcu_gp_slow(gp_preinit_delay); /* Races with CPU hotplug. */
  
* Unmerged path kernel/rcu/tree.c
diff --git a/kernel/rcu/tree.h b/kernel/rcu/tree.h
index 971069b043e9..9d8c1b10aa0b 100644
--- a/kernel/rcu/tree.h
+++ b/kernel/rcu/tree.h
@@ -381,7 +381,7 @@ struct rcu_state {
 	char abbr;				/* Abbreviated name. */
 	struct list_head flavors;		/* List of RCU flavors. */
 
-	spinlock_t ofl_lock ____cacheline_internodealigned_in_smp;
+	raw_spinlock_t ofl_lock ____cacheline_internodealigned_in_smp;
 						/* Synchronize offline with */
 						/*  GP pre-initialization. */
 };
