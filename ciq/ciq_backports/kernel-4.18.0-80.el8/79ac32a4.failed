dma-direct: document the zone selection logic

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 79ac32a427f5d1211fa417021fd04c36f63ab917
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/79ac32a4.failed

What we are doing here isn't quite obvious, so add a comment explaining
it.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 79ac32a427f5d1211fa417021fd04c36f63ab917)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/dma/direct.c
diff --cc kernel/dma/direct.c
index 2ba3b52698ea,a5a943836c8e..000000000000
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@@ -49,15 -55,58 +49,62 @@@ check_addr(struct device *dev, dma_addr
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ static inline dma_addr_t phys_to_dma_direct(struct device *dev,
+ 		phys_addr_t phys)
+ {
+ 	if (force_dma_unencrypted())
+ 		return __phys_to_dma(dev, phys);
+ 	return phys_to_dma(dev, phys);
+ }
+ 
+ u64 dma_direct_get_required_mask(struct device *dev)
+ {
+ 	u64 max_dma = phys_to_dma_direct(dev, (max_pfn - 1) << PAGE_SHIFT);
+ 
+ 	if (dev->bus_dma_mask && dev->bus_dma_mask < max_dma)
+ 		max_dma = dev->bus_dma_mask;
+ 
+ 	return (1ULL << (fls64(max_dma) - 1)) * 2 - 1;
+ }
+ 
+ static gfp_t __dma_direct_optimal_gfp_mask(struct device *dev, u64 dma_mask,
+ 		u64 *phys_mask)
+ {
+ 	if (dev->bus_dma_mask && dev->bus_dma_mask < dma_mask)
+ 		dma_mask = dev->bus_dma_mask;
+ 
+ 	if (force_dma_unencrypted())
+ 		*phys_mask = __dma_to_phys(dev, dma_mask);
+ 	else
+ 		*phys_mask = dma_to_phys(dev, dma_mask);
+ 
+ 	/*
+ 	 * Optimistically try the zone that the physical address mask falls
+ 	 * into first.  If that returns memory that isn't actually addressable
+ 	 * we will fallback to the next lower zone and try again.
+ 	 *
+ 	 * Note that GFP_DMA32 and GFP_DMA are no ops without the corresponding
+ 	 * zones.
+ 	 */
+ 	if (*phys_mask <= DMA_BIT_MASK(ARCH_ZONE_DMA_BITS))
+ 		return GFP_DMA;
+ 	if (*phys_mask <= DMA_BIT_MASK(32))
+ 		return GFP_DMA32;
+ 	return 0;
+ }
+ 
++>>>>>>> 79ac32a427f5 (dma-direct: document the zone selection logic)
  static bool dma_coherent_ok(struct device *dev, phys_addr_t phys, size_t size)
  {
 -	return phys_to_dma_direct(dev, phys) + size - 1 <=
 -			min_not_zero(dev->coherent_dma_mask, dev->bus_dma_mask);
 +	dma_addr_t addr = force_dma_unencrypted() ?
 +		__phys_to_dma(dev, phys) : phys_to_dma(dev, phys);
 +	return addr + size - 1 <= dev->coherent_dma_mask;
  }
  
 -void *dma_direct_alloc_pages(struct device *dev, size_t size,
 -		dma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs)
 +void *dma_direct_alloc(struct device *dev, size_t size, dma_addr_t *dma_handle,
 +		gfp_t gfp, unsigned long attrs)
  {
  	unsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;
  	int page_order = get_order(size);
* Unmerged path kernel/dma/direct.c
