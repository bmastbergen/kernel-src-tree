act_ife: fix a potential deadlock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Cong Wang <xiyou.wangcong@gmail.com>
commit 5ffe57da29b3802baeddaa40909682bbb4cb4d48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/5ffe57da.failed

use_all_metadata() acquires read_lock(&ife_mod_lock), then calls
add_metainfo() which calls find_ife_oplist() which acquires the same
lock again. Deadlock!

Introduce __add_metainfo() which accepts struct tcf_meta_ops *ops
as an additional parameter and let its callers to decide how
to find it. For use_all_metadata(), it already has ops, no
need to find it again, just call __add_metainfo() directly.

And, as ife_mod_lock is only needed for find_ife_oplist(),
this means we can make non-atomic allocation for populate_metalist()
now.

Fixes: 817e9f2c5c26 ("act_ife: acquire ife_mod_lock before reading ifeoplist")
	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5ffe57da29b3802baeddaa40909682bbb4cb4d48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_ife.c
diff --cc net/sched/act_ife.c
index dc8f301f3be3,196430aefe87..000000000000
--- a/net/sched/act_ife.c
+++ b/net/sched/act_ife.c
@@@ -299,24 -295,17 +299,23 @@@ static int load_metaops_and_vet(struct 
  }
  
  /* called when adding new meta information
 + * under ife->tcf_lock for existing action
  */
++<<<<<<< HEAD
 +static int add_metainfo(struct tcf_ife_info *ife, u32 metaid, void *metaval,
 +			int len, bool atomic)
++=======
+ static int __add_metainfo(const struct tcf_meta_ops *ops,
+ 			  struct tcf_ife_info *ife, u32 metaid, void *metaval,
+ 			  int len, bool atomic, bool exists)
++>>>>>>> 5ffe57da29b3 (act_ife: fix a potential deadlock)
  {
  	struct tcf_meta_info *mi = NULL;
- 	struct tcf_meta_ops *ops = find_ife_oplist(metaid);
  	int ret = 0;
  
- 	if (!ops)
- 		return -ENOENT;
- 
  	mi = kzalloc(sizeof(*mi), atomic ? GFP_ATOMIC : GFP_KERNEL);
- 	if (!mi) {
- 		/*put back what find_ife_oplist took */
- 		module_put(ops->owner);
+ 	if (!mi)
  		return -ENOMEM;
- 	}
  
  	mi->metaid = metaid;
  	mi->ops = ops;
@@@ -334,7 -326,22 +332,26 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int use_all_metadata(struct tcf_ife_info *ife)
++=======
+ static int add_metainfo(struct tcf_ife_info *ife, u32 metaid, void *metaval,
+ 			int len, bool exists)
+ {
+ 	const struct tcf_meta_ops *ops = find_ife_oplist(metaid);
+ 	int ret;
+ 
+ 	if (!ops)
+ 		return -ENOENT;
+ 	ret = __add_metainfo(ops, ife, metaid, metaval, len, false, exists);
+ 	if (ret)
+ 		/*put back what find_ife_oplist took */
+ 		module_put(ops->owner);
+ 	return ret;
+ }
+ 
+ static int use_all_metadata(struct tcf_ife_info *ife, bool exists)
++>>>>>>> 5ffe57da29b3 (act_ife: fix a potential deadlock)
  {
  	struct tcf_meta_ops *o;
  	int rc = 0;
@@@ -342,7 -349,7 +359,11 @@@
  
  	read_lock(&ife_mod_lock);
  	list_for_each_entry(o, &ifeoplist, list) {
++<<<<<<< HEAD
 +		rc = add_metainfo(ife, o->metaid, NULL, 0, true);
++=======
+ 		rc = __add_metainfo(o, ife, o->metaid, NULL, 0, true, exists);
++>>>>>>> 5ffe57da29b3 (act_ife: fix a potential deadlock)
  		if (rc == 0)
  			installed += 1;
  	}
* Unmerged path net/sched/act_ife.c
