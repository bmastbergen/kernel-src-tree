x86/litf: Introduce vmx status variable

jira LE-1907
cve CVE-2018-3646
cve CVE-2018-3620
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 72c6d2db64fa18c996ece8f06e499509e6c9a37e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/72c6d2db.failed

Store the effective mitigation of VMX in a status variable and use it to
report the VMX state in the l1tf sysfs file.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Tested-by: Jiri Kosina <jkosina@suse.cz>
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
Link: https://lkml.kernel.org/r/20180713142322.433098358@linutronix.de

(cherry picked from commit 72c6d2db64fa18c996ece8f06e499509e6c9a37e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/bugs.c
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kernel/cpu/bugs.c
index 65d7ea159fff,8aba7d3abccb..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -713,6 -744,10 +746,13 @@@ static ssize_t cpu_show_common(struct d
  	case X86_BUG_SPEC_STORE_BYPASS:
  		return sprintf(buf, "%s\n", ssb_strings[ssb_mode]);
  
++<<<<<<< HEAD
++=======
+ 	case X86_BUG_L1TF:
+ 		if (boot_cpu_has(X86_FEATURE_L1TF_PTEINV))
+ 			return l1tf_show_state(buf);
+ 		break;
++>>>>>>> 72c6d2db64fa (x86/litf: Introduce vmx status variable)
  	default:
  		break;
  	}
diff --cc arch/x86/kvm/vmx.c
index d9e0ef7725c0,385cbfaa3c71..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -192,12 -191,48 +192,57 @@@ module_param(ple_window_max, uint, 0444
  
  extern const ulong vmx_return;
  
++<<<<<<< HEAD
 +enum ept_pointers_status {
 +	EPT_POINTERS_CHECK = 0,
 +	EPT_POINTERS_MATCH = 1,
 +	EPT_POINTERS_MISMATCH = 2
 +};
 +
++=======
+ static DEFINE_STATIC_KEY_FALSE(vmx_l1d_should_flush);
+ 
+ static enum vmx_l1d_flush_state __read_mostly vmentry_l1d_flush = VMENTER_L1D_FLUSH_COND;
+ 
+ static const struct {
+ 	const char *option;
+ 	enum vmx_l1d_flush_state cmd;
+ } vmentry_l1d_param[] = {
+ 	{"auto",	VMENTER_L1D_FLUSH_AUTO},
+ 	{"never",	VMENTER_L1D_FLUSH_NEVER},
+ 	{"cond",	VMENTER_L1D_FLUSH_COND},
+ 	{"always",	VMENTER_L1D_FLUSH_ALWAYS},
+ };
+ 
+ static int vmentry_l1d_flush_set(const char *s, const struct kernel_param *kp)
+ {
+ 	unsigned int i;
+ 
+ 	if (!s)
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(vmentry_l1d_param); i++) {
+ 		if (!strcmp(s, vmentry_l1d_param[i].option)) {
+ 			vmentry_l1d_flush = vmentry_l1d_param[i].cmd;
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
+ static int vmentry_l1d_flush_get(char *s, const struct kernel_param *kp)
+ {
+ 	return sprintf(s, "%s\n", vmentry_l1d_param[vmentry_l1d_flush].option);
+ }
+ 
+ static const struct kernel_param_ops vmentry_l1d_flush_ops = {
+ 	.set = vmentry_l1d_flush_set,
+ 	.get = vmentry_l1d_flush_get,
+ };
+ module_param_cb(vmentry_l1d_flush, &vmentry_l1d_flush_ops, &vmentry_l1d_flush, S_IRUGO);
+ 
++>>>>>>> 72c6d2db64fa (x86/litf: Introduce vmx status variable)
  struct kvm_vmx {
  	struct kvm kvm;
  
@@@ -13877,6 -13225,40 +13922,43 @@@ static struct kvm_x86_ops vmx_x86_ops _
  	.enable_smi_window = enable_smi_window,
  };
  
++<<<<<<< HEAD
++=======
+ static int __init vmx_setup_l1d_flush(void)
+ {
+ 	struct page *page;
+ 
+ 	if (!boot_cpu_has_bug(X86_BUG_L1TF))
+ 		return 0;
+ 
+ 	l1tf_vmx_mitigation = vmentry_l1d_flush;
+ 
+ 	if (vmentry_l1d_flush == VMENTER_L1D_FLUSH_NEVER ||
+ 	    vmx_l1d_use_msr_save_list())
+ 		return 0;
+ 
+ 	if (!boot_cpu_has(X86_FEATURE_FLUSH_L1D)) {
+ 		page = alloc_pages(GFP_KERNEL, L1D_CACHE_ORDER);
+ 		if (!page)
+ 			return -ENOMEM;
+ 		vmx_l1d_flush_pages = page_address(page);
+ 	}
+ 
+ 	static_branch_enable(&vmx_l1d_should_flush);
+ 	return 0;
+ }
+ 
+ static void vmx_cleanup_l1d_flush(void)
+ {
+ 	if (vmx_l1d_flush_pages) {
+ 		free_pages((unsigned long)vmx_l1d_flush_pages, L1D_CACHE_ORDER);
+ 		vmx_l1d_flush_pages = NULL;
+ 	}
+ 	/* Restore state so sysfs ignores VMX */
+ 	l1tf_vmx_mitigation = VMENTER_L1D_FLUSH_AUTO;
+ }
+ 
++>>>>>>> 72c6d2db64fa (x86/litf: Introduce vmx status variable)
  static int __init vmx_init(void)
  {
  	int r;
@@@ -13915,6 -13296,13 +13997,16 @@@
  	if (r)
  		return r;
  
++<<<<<<< HEAD
++=======
+ 	r = kvm_init(&vmx_x86_ops, sizeof(struct vcpu_vmx),
+ 		     __alignof__(struct vcpu_vmx), THIS_MODULE);
+ 	if (r) {
+ 		vmx_cleanup_l1d_flush();
+ 		return r;
+ 	}
+ 
++>>>>>>> 72c6d2db64fa (x86/litf: Introduce vmx status variable)
  #ifdef CONFIG_KEXEC_CORE
  	rcu_assign_pointer(crash_vmclear_loaded_vmcss,
  			   crash_vmclear_local_loaded_vmcss);
@@@ -13955,6 -13343,7 +14047,10 @@@ static void __exit vmx_exit(void
  		static_branch_disable(&enable_evmcs);
  	}
  #endif
++<<<<<<< HEAD
++=======
+ 	vmx_cleanup_l1d_flush();
++>>>>>>> 72c6d2db64fa (x86/litf: Introduce vmx status variable)
  }
  
  module_init(vmx_init)
diff --git a/arch/x86/include/asm/vmx.h b/arch/x86/include/asm/vmx.h
index 6aa8499e1f62..6439f01d2ff2 100644
--- a/arch/x86/include/asm/vmx.h
+++ b/arch/x86/include/asm/vmx.h
@@ -576,4 +576,13 @@ enum vm_instruction_error_number {
 	VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID = 28,
 };
 
+enum vmx_l1d_flush_state {
+	VMENTER_L1D_FLUSH_AUTO,
+	VMENTER_L1D_FLUSH_NEVER,
+	VMENTER_L1D_FLUSH_COND,
+	VMENTER_L1D_FLUSH_ALWAYS,
+};
+
+extern enum vmx_l1d_flush_state l1tf_vmx_mitigation;
+
 #endif
* Unmerged path arch/x86/kernel/cpu/bugs.c
* Unmerged path arch/x86/kvm/vmx.c
