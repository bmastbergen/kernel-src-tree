blkcg: rename blkg_try_get() to blkg_tryget()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Dennis Zhou <dennis@kernel.org>
commit 7754f669ffde3919e398a9e591cd7510d6cf4e73
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/7754f669.failed

blkg reference counting now uses percpu_ref rather than atomic_t. Let's
make this consistent with css_tryget. This renames blkg_try_get to
blkg_tryget and now returns a bool rather than the blkg or %NULL.

	Signed-off-by: Dennis Zhou <dennis@kernel.org>
	Reviewed-by: Josef Bacik <josef@toxicpanda.com>
	Acked-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 7754f669ffde3919e398a9e591cd7510d6cf4e73)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/bio.c
#	include/linux/blk-cgroup.h
diff --cc block/bio.c
index 8d70c85b6b8f,06760543ec81..000000000000
--- a/block/bio.c
+++ b/block/bio.c
@@@ -2046,9 -1970,111 +2046,114 @@@ void bio_disassociate_task(struct bio *
  		bio->bi_blkg = NULL;
  	}
  }
 -EXPORT_SYMBOL_GPL(bio_disassociate_blkg);
  
  /**
++<<<<<<< HEAD
 + * bio_clone_blkcg_association - clone blkcg association from src to dst bio
++=======
+  * __bio_associate_blkg - associate a bio with the a blkg
+  * @bio: target bio
+  * @blkg: the blkg to associate
+  *
+  * This tries to associate @bio with the specified @blkg.  Association failure
+  * is handled by walking up the blkg tree.  Therefore, the blkg associated can
+  * be anything between @blkg and the root_blkg.  This situation only happens
+  * when a cgroup is dying and then the remaining bios will spill to the closest
+  * alive blkg.
+  *
+  * A reference will be taken on the @blkg and will be released when @bio is
+  * freed.
+  */
+ static void __bio_associate_blkg(struct bio *bio, struct blkcg_gq *blkg)
+ {
+ 	bio_disassociate_blkg(bio);
+ 
+ 	bio->bi_blkg = blkg_tryget_closest(blkg);
+ }
+ 
+ /**
+  * bio_associate_blkg_from_css - associate a bio with a specified css
+  * @bio: target bio
+  * @css: target css
+  *
+  * Associate @bio with the blkg found by combining the css's blkg and the
+  * request_queue of the @bio.  This falls back to the queue's root_blkg if
+  * the association fails with the css.
+  */
+ void bio_associate_blkg_from_css(struct bio *bio,
+ 				 struct cgroup_subsys_state *css)
+ {
+ 	struct request_queue *q = bio->bi_disk->queue;
+ 	struct blkcg_gq *blkg;
+ 
+ 	rcu_read_lock();
+ 
+ 	if (!css || !css->parent)
+ 		blkg = q->root_blkg;
+ 	else
+ 		blkg = blkg_lookup_create(css_to_blkcg(css), q);
+ 
+ 	__bio_associate_blkg(bio, blkg);
+ 
+ 	rcu_read_unlock();
+ }
+ EXPORT_SYMBOL_GPL(bio_associate_blkg_from_css);
+ 
+ #ifdef CONFIG_MEMCG
+ /**
+  * bio_associate_blkg_from_page - associate a bio with the page's blkg
+  * @bio: target bio
+  * @page: the page to lookup the blkcg from
+  *
+  * Associate @bio with the blkg from @page's owning memcg and the respective
+  * request_queue.  If cgroup_e_css returns %NULL, fall back to the queue's
+  * root_blkg.
+  */
+ void bio_associate_blkg_from_page(struct bio *bio, struct page *page)
+ {
+ 	struct cgroup_subsys_state *css;
+ 
+ 	if (!page->mem_cgroup)
+ 		return;
+ 
+ 	rcu_read_lock();
+ 
+ 	css = cgroup_e_css(page->mem_cgroup->css.cgroup, &io_cgrp_subsys);
+ 	bio_associate_blkg_from_css(bio, css);
+ 
+ 	rcu_read_unlock();
+ }
+ #endif /* CONFIG_MEMCG */
+ 
+ /**
+  * bio_associate_blkg - associate a bio with a blkg
+  * @bio: target bio
+  *
+  * Associate @bio with the blkg found from the bio's css and request_queue.
+  * If one is not found, bio_lookup_blkg() creates the blkg.  If a blkg is
+  * already associated, the css is reused and association redone as the
+  * request_queue may have changed.
+  */
+ void bio_associate_blkg(struct bio *bio)
+ {
+ 	struct cgroup_subsys_state *css;
+ 
+ 	rcu_read_lock();
+ 
+ 	if (bio->bi_blkg)
+ 		css = &bio_blkcg(bio)->css;
+ 	else
+ 		css = blkcg_css();
+ 
+ 	bio_associate_blkg_from_css(bio, css);
+ 
+ 	rcu_read_unlock();
+ }
+ EXPORT_SYMBOL_GPL(bio_associate_blkg);
+ 
+ /**
+  * bio_clone_blkg_association - clone blkg association from src to dst bio
++>>>>>>> 7754f669ffde (blkcg: rename blkg_try_get() to blkg_tryget())
   * @dst: destination bio
   * @src: source bio
   */
diff --cc include/linux/blk-cgroup.h
index 8bf2308b920c,752de1becb5c..000000000000
--- a/include/linux/blk-cgroup.h
+++ b/include/linux/blk-cgroup.h
@@@ -502,15 -497,25 +502,32 @@@ static inline void blkg_get(struct blkc
   * This is for use when doing an RCU lookup of the blkg.  We may be in the midst
   * of freeing this blkg, so we can only use it if the refcnt is not zero.
   */
- static inline struct blkcg_gq *blkg_try_get(struct blkcg_gq *blkg)
+ static inline bool blkg_tryget(struct blkcg_gq *blkg)
  {
++<<<<<<< HEAD
 +	if (atomic_inc_not_zero(&blkg->refcnt))
 +		return blkg;
 +	return NULL;
 +}
 +
++=======
+ 	return percpu_ref_tryget(&blkg->refcnt);
+ }
+ 
+ /**
+  * blkg_tryget_closest - try and get a blkg ref on the closet blkg
+  * @blkg: blkg to get
+  *
+  * This walks up the blkg tree to find the closest non-dying blkg and returns
+  * the blkg that it did association with as it may not be the passed in blkg.
+  */
+ static inline struct blkcg_gq *blkg_tryget_closest(struct blkcg_gq *blkg)
+ {
+ 	while (!percpu_ref_tryget(&blkg->refcnt))
+ 		blkg = blkg->parent;
++>>>>>>> 7754f669ffde (blkcg: rename blkg_try_get() to blkg_tryget())
  
 -	return blkg;
 -}
 +void __blkg_release_rcu(struct rcu_head *rcu);
  
  /**
   * blkg_put - put a blkg reference
* Unmerged path block/bio.c
diff --git a/block/blk-cgroup.c b/block/blk-cgroup.c
index 301ed0447460..dbec74f2f0ec 100644
--- a/block/blk-cgroup.c
+++ b/block/blk-cgroup.c
@@ -1729,8 +1729,7 @@ void blkcg_maybe_throttle_current(void)
 	blkg = blkg_lookup(blkcg, q);
 	if (!blkg)
 		goto out;
-	blkg = blkg_try_get(blkg);
-	if (!blkg)
+	if (!blkg_tryget(blkg))
 		goto out;
 	rcu_read_unlock();
 
diff --git a/block/blk-iolatency.c b/block/blk-iolatency.c
index 171f7ae1a396..4e1ffef7a8a8 100644
--- a/block/blk-iolatency.c
+++ b/block/blk-iolatency.c
@@ -638,7 +638,7 @@ static void blkiolatency_timer_fn(struct timer_list *t)
 		 * We could be exiting, don't access the pd unless we have a
 		 * ref on the blkg.
 		 */
-		if (!blkg_try_get(blkg))
+		if (!blkg_tryget(blkg))
 			continue;
 
 		iolat = blkg_to_lat(blkg);
* Unmerged path include/linux/blk-cgroup.h
