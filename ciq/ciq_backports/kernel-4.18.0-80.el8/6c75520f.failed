IB/mlx5: Don't hold spin lock while checking device state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Parav Pandit <parav@mellanox.com>
commit 6c75520f7e5a6a353f3b332509d205e213d05855
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/6c75520f.failed

mdev->state device state is not protected by the QP for which WRs are
being processed. Therefore, there is no need to hold spin lock while
checking mdev state.

Given that device fatal error is unlikely situation, wrap the condition
check with unlikely().

Additionally, kernel QP1 is also a kernel ULP for which soft CQEs needs
to be generated. Therefore, check for device fatal error before
processing QP1 work requests.

Fixes: 89ea94a7b6c4 ("IB/mlx5: Reset flow support for IB kernel ULPs")
	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Daniel Jurgens <danielj@mellanox.com>
	Reviewed-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 6c75520f7e5a6a353f3b332509d205e213d05855)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/qp.c
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 01eae67d5a6e,a2073ee7a16f..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -4393,13 -4415,6 +4399,16 @@@ int mlx5_ib_post_send(struct ib_qp *ibq
  
  	spin_lock_irqsave(&qp->sq.lock, flags);
  
++<<<<<<< HEAD
 +	if (mdev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR) {
 +		err = -EIO;
 +		*bad_wr = wr;
 +		nreq = 0;
 +		goto out;
 +	}
 +
++=======
++>>>>>>> 6c75520f7e5a (IB/mlx5: Don't hold spin lock while checking device state)
  	for (nreq = 0; wr; nreq++, wr = wr->next) {
  		if (unlikely(wr->opcode >= ARRAY_SIZE(mlx5_ib_opcode))) {
  			mlx5_ib_warn(dev, "\n");
@@@ -4714,13 -4739,6 +4729,16 @@@ int mlx5_ib_post_recv(struct ib_qp *ibq
  
  	spin_lock_irqsave(&qp->rq.lock, flags);
  
++<<<<<<< HEAD
 +	if (mdev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR) {
 +		err = -EIO;
 +		*bad_wr = wr;
 +		nreq = 0;
 +		goto out;
 +	}
 +
++=======
++>>>>>>> 6c75520f7e5a (IB/mlx5: Don't hold spin lock while checking device state)
  	ind = qp->rq.head & (qp->rq.wqe_cnt - 1);
  
  	for (nreq = 0; wr; nreq++, wr = wr->next) {
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
