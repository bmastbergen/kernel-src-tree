rcu: Pull rcu_gp_kthread() FQS loop into separate function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Paul E. McKenney <paulmck@linux.vnet.ibm.com>
commit c3854a055bc834806b481b34f5f552ac415b2000
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/c3854a05.failed

The rcu_gp_kthread() function is long and deeply indented, so this
commit pulls the loop that repeatedly invokes rcu_gp_fqs() into a new
rcu_gp_fqs_loop() function.

	Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
(cherry picked from commit c3854a055bc834806b481b34f5f552ac415b2000)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/rcu/tree.c
diff --cc kernel/rcu/tree.c
index 768e92ffb380,53ba7747878c..000000000000
--- a/kernel/rcu/tree.c
+++ b/kernel/rcu/tree.c
@@@ -2080,15 -2129,8 +2145,18 @@@ static void rcu_gp_cleanup(struct rcu_s
  /*
   * Body of kthread that handles grace periods.
   */
 -static int __noreturn rcu_gp_kthread(void *unused)
 +static int __noreturn rcu_gp_kthread(void *arg)
  {
++<<<<<<< HEAD
 +	bool first_gp_fqs;
 +	int gf;
 +	unsigned long j;
 +	int ret;
 +	struct rcu_state *rsp = arg;
 +	struct rcu_node *rnp = rcu_get_root();
 +
++=======
++>>>>>>> c3854a055bc8 (rcu: Pull rcu_gp_kthread() FQS loop into separate function)
  	rcu_bind_gp_kthread();
  	for (;;) {
  
@@@ -2113,63 -2156,12 +2181,67 @@@
  		}
  
  		/* Handle quiescent-state forcing. */
++<<<<<<< HEAD
 +		first_gp_fqs = true;
 +		j = jiffies_till_first_fqs;
 +		ret = 0;
 +		for (;;) {
 +			if (!ret) {
 +				rsp->jiffies_force_qs = jiffies + j;
 +				WRITE_ONCE(rsp->jiffies_kick_kthreads,
 +					   jiffies + 3 * j);
 +			}
 +			trace_rcu_grace_period(rsp->name,
 +					       READ_ONCE(rsp->gp_seq),
 +					       TPS("fqswait"));
 +			rsp->gp_state = RCU_GP_WAIT_FQS;
 +			ret = swait_event_idle_timeout(rsp->gp_wq,
 +					rcu_gp_fqs_check_wake(rsp, &gf), j);
 +			rsp->gp_state = RCU_GP_DOING_FQS;
 +			/* Locking provides needed memory barriers. */
 +			/* If grace period done, leave loop. */
 +			if (!READ_ONCE(rnp->qsmask) &&
 +			    !rcu_preempt_blocked_readers_cgp(rnp))
 +				break;
 +			/* If time for quiescent-state forcing, do it. */
 +			if (ULONG_CMP_GE(jiffies, rsp->jiffies_force_qs) ||
 +			    (gf & RCU_GP_FLAG_FQS)) {
 +				trace_rcu_grace_period(rsp->name,
 +						       READ_ONCE(rsp->gp_seq),
 +						       TPS("fqsstart"));
 +				rcu_gp_fqs(rsp, first_gp_fqs);
 +				first_gp_fqs = false;
 +				trace_rcu_grace_period(rsp->name,
 +						       READ_ONCE(rsp->gp_seq),
 +						       TPS("fqsend"));
 +				cond_resched_tasks_rcu_qs();
 +				WRITE_ONCE(rsp->gp_activity, jiffies);
 +				ret = 0; /* Force full wait till next FQS. */
 +				j = jiffies_till_next_fqs;
 +			} else {
 +				/* Deal with stray signal. */
 +				cond_resched_tasks_rcu_qs();
 +				WRITE_ONCE(rsp->gp_activity, jiffies);
 +				WARN_ON(signal_pending(current));
 +				trace_rcu_grace_period(rsp->name,
 +						       READ_ONCE(rsp->gp_seq),
 +						       TPS("fqswaitsig"));
 +				ret = 1; /* Keep old FQS timing. */
 +				j = jiffies;
 +				if (time_after(jiffies, rsp->jiffies_force_qs))
 +					j = 1;
 +				else
 +					j = rsp->jiffies_force_qs - j;
 +			}
 +		}
++=======
+ 		rcu_gp_fqs_loop();
++>>>>>>> c3854a055bc8 (rcu: Pull rcu_gp_kthread() FQS loop into separate function)
  
  		/* Handle grace-period end. */
 -		rcu_state.gp_state = RCU_GP_CLEANUP;
 -		rcu_gp_cleanup();
 -		rcu_state.gp_state = RCU_GP_CLEANED;
 +		rsp->gp_state = RCU_GP_CLEANUP;
 +		rcu_gp_cleanup(rsp);
 +		rsp->gp_state = RCU_GP_CLEANED;
  	}
  }
  
* Unmerged path kernel/rcu/tree.c
