x86/mmiotrace: Lock down the testmmiotrace module

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author David Howells <dhowells@redhat.com>
commit 906357f77a077508d160e729f917c5f0a4304f25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/906357f7.failed

The testmmiotrace module shouldn't be permitted when the kernel is locked
down as it can be used to arbitrarily read and write MMIO space. This is
a runtime check rather than buildtime in order to allow configurations
where the same kernel may be run in both locked down or permissive modes
depending on local policy.

	Suggested-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: David Howells <dhowells@redhat.com
	Signed-off-by: Matthew Garrett <mjg59@google.com>
	Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
	Reviewed-by: Kees Cook <keescook@chromium.org>
cc: Thomas Gleixner <tglx@linutronix.de>
cc: Steven Rostedt <rostedt@goodmis.org>
cc: Ingo Molnar <mingo@kernel.org>
cc: "H. Peter Anvin" <hpa@zytor.com>
cc: x86@kernel.org
	Signed-off-by: James Morris <jmorris@namei.org>
(cherry picked from commit 906357f77a077508d160e729f917c5f0a4304f25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/security.h
#	security/lockdown/lockdown.c
diff --cc include/linux/security.h
index 88d30fc975e7,d8db7ea4c4bf..000000000000
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@@ -70,9 -77,51 +70,54 @@@ enum lsm_event 
  	LSM_POLICY_CHANGE,
  };
  
++<<<<<<< HEAD
++=======
+ /*
+  * These are reasons that can be passed to the security_locked_down()
+  * LSM hook. Lockdown reasons that protect kernel integrity (ie, the
+  * ability for userland to modify kernel code) are placed before
+  * LOCKDOWN_INTEGRITY_MAX.  Lockdown reasons that protect kernel
+  * confidentiality (ie, the ability for userland to extract
+  * information from the running kernel that would otherwise be
+  * restricted) are placed before LOCKDOWN_CONFIDENTIALITY_MAX.
+  *
+  * LSM authors should note that the semantics of any given lockdown
+  * reason are not guaranteed to be stable - the same reason may block
+  * one set of features in one kernel release, and a slightly different
+  * set of features in a later kernel release. LSMs that seek to expose
+  * lockdown policy at any level of granularity other than "none",
+  * "integrity" or "confidentiality" are responsible for either
+  * ensuring that they expose a consistent level of functionality to
+  * userland, or ensuring that userland is aware that this is
+  * potentially a moving target. It is easy to misuse this information
+  * in a way that could break userspace. Please be careful not to do
+  * so.
+  *
+  * If you add to this, remember to extend lockdown_reasons in
+  * security/lockdown/lockdown.c.
+  */
+ enum lockdown_reason {
+ 	LOCKDOWN_NONE,
+ 	LOCKDOWN_MODULE_SIGNATURE,
+ 	LOCKDOWN_DEV_MEM,
+ 	LOCKDOWN_KEXEC,
+ 	LOCKDOWN_HIBERNATION,
+ 	LOCKDOWN_PCI_ACCESS,
+ 	LOCKDOWN_IOPORT,
+ 	LOCKDOWN_MSR,
+ 	LOCKDOWN_ACPI_TABLES,
+ 	LOCKDOWN_PCMCIA_CIS,
+ 	LOCKDOWN_TIOCSSERIAL,
+ 	LOCKDOWN_MODULE_PARAMETERS,
+ 	LOCKDOWN_MMIOTRACE,
+ 	LOCKDOWN_INTEGRITY_MAX,
+ 	LOCKDOWN_CONFIDENTIALITY_MAX,
+ };
+ 
++>>>>>>> 906357f77a07 (x86/mmiotrace: Lock down the testmmiotrace module)
  /* These functions are in security/commoncap.c */
  extern int cap_capable(const struct cred *cred, struct user_namespace *ns,
 -		       int cap, unsigned int opts);
 +		       int cap, int audit);
  extern int cap_settime(const struct timespec64 *ts, const struct timezone *tz);
  extern int cap_ptrace_access_check(struct task_struct *child, unsigned int mode);
  extern int cap_ptrace_traceme(struct task_struct *parent);
* Unmerged path security/lockdown/lockdown.c
diff --git a/arch/x86/mm/testmmiotrace.c b/arch/x86/mm/testmmiotrace.c
index f6ae6830b341..6b9486baa2e9 100644
--- a/arch/x86/mm/testmmiotrace.c
+++ b/arch/x86/mm/testmmiotrace.c
@@ -7,6 +7,7 @@
 #include <linux/module.h>
 #include <linux/io.h>
 #include <linux/mmiotrace.h>
+#include <linux/security.h>
 
 static unsigned long mmio_address;
 module_param_hw(mmio_address, ulong, iomem, 0);
@@ -114,6 +115,10 @@ static void do_test_bulk_ioremapping(void)
 static int __init init(void)
 {
 	unsigned long size = (read_far) ? (8 << 20) : (16 << 10);
+	int ret = security_locked_down(LOCKDOWN_MMIOTRACE);
+
+	if (ret)
+		return ret;
 
 	if (mmio_address == 0) {
 		pr_err("you have to use the module argument mmio_address.\n");
* Unmerged path include/linux/security.h
* Unmerged path security/lockdown/lockdown.c
