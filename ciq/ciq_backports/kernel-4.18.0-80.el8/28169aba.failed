net/sched: Add hardware specific counters to TC actions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
Rebuild_CHGLOG: - [net] sched: Add hardware specific counters to TC actions (Ivan Vecera) [1638022]
Rebuild_FUZZ: 96.23%
commit-author Eelco Chaudron <echaudro@redhat.com>
commit 28169abadb08333eb607621faa3a1dd7109e0d45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/28169aba.failed

Add additional counters that will store the bytes/packets processed by
hardware. These will be exported through the netlink interface for
displaying by the iproute2 tc tool

	Signed-off-by: Eelco Chaudron <echaudro@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 28169abadb08333eb607621faa3a1dd7109e0d45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_api.c
diff --cc net/sched/act_api.c
index 3b4dbb994330,3c7c23421885..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -394,25 -391,14 +395,28 @@@ int tcf_idr_create(struct tc_action_ne
  		p->cpu_bstats = netdev_alloc_pcpu_stats(struct gnet_stats_basic_cpu);
  		if (!p->cpu_bstats)
  			goto err1;
+ 		p->cpu_bstats_hw = netdev_alloc_pcpu_stats(struct gnet_stats_basic_cpu);
+ 		if (!p->cpu_bstats_hw)
+ 			goto err2;
  		p->cpu_qstats = alloc_percpu(struct gnet_stats_queue);
  		if (!p->cpu_qstats)
- 			goto err2;
+ 			goto err3;
  	}
  	spin_lock_init(&p->tcfa_lock);
 +	idr_preload(GFP_KERNEL);
 +	spin_lock(&idrinfo->lock);
 +	/* user doesn't specify an index */
 +	if (!index) {
 +		index = 1;
 +		err = idr_alloc_u32(idr, NULL, &index, UINT_MAX, GFP_ATOMIC);
 +	} else {
 +		err = idr_alloc_u32(idr, NULL, &index, index, GFP_ATOMIC);
 +	}
 +	spin_unlock(&idrinfo->lock);
 +	idr_preload_end();
 +	if (err)
 +		goto err3;
 +
  	p->tcfa_index = index;
  	p->tcfa_tm.install = jiffies;
  	p->tcfa_tm.lastuse = jiffies;
@@@ -431,9 -416,9 +435,14 @@@
  	*a = p;
  	return 0;
  err4:
++<<<<<<< HEAD
 +	idr_remove(idr, index);
 +err3:
++=======
++>>>>>>> 28169abadb08 (net/sched: Add hardware specific counters to TC actions)
  	free_percpu(p->cpu_qstats);
+ err3:
+ 	free_percpu(p->cpu_bstats_hw);
  err2:
  	free_percpu(p->cpu_bstats);
  err1:
diff --git a/include/net/act_api.h b/include/net/act_api.h
index b912ed75d38d..5bd3d77c05c2 100644
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@ -32,10 +32,12 @@ struct tc_action {
 	int				tcfa_action;
 	struct tcf_t			tcfa_tm;
 	struct gnet_stats_basic_packed	tcfa_bstats;
+	struct gnet_stats_basic_packed	tcfa_bstats_hw;
 	struct gnet_stats_queue		tcfa_qstats;
 	struct net_rate_estimator __rcu *tcfa_rate_est;
 	spinlock_t			tcfa_lock;
 	struct gnet_stats_basic_cpu __percpu *cpu_bstats;
+	struct gnet_stats_basic_cpu __percpu *cpu_bstats_hw;
 	struct gnet_stats_queue __percpu *cpu_qstats;
 	struct tc_cookie	__rcu *act_cookie;
 	struct tcf_chain	*goto_chain;
@@ -96,7 +98,7 @@ struct tc_action_ops {
 			struct netlink_callback *, int,
 			const struct tc_action_ops *,
 			struct netlink_ext_ack *);
-	void	(*stats_update)(struct tc_action *, u64, u32, u64);
+	void	(*stats_update)(struct tc_action *, u64, u32, u64, bool);
 	size_t  (*get_fill_size)(const struct tc_action *act);
 	struct net_device *(*get_dev)(const struct tc_action *a);
 	void	(*put_dev)(struct net_device *dev);
@@ -184,13 +186,13 @@ int tcf_action_copy_stats(struct sk_buff *, struct tc_action *, int);
 #endif /* CONFIG_NET_CLS_ACT */
 
 static inline void tcf_action_stats_update(struct tc_action *a, u64 bytes,
-					   u64 packets, u64 lastuse)
+					   u64 packets, u64 lastuse, bool hw)
 {
 #ifdef CONFIG_NET_CLS_ACT
 	if (!a->ops->stats_update)
 		return;
 
-	a->ops->stats_update(a, bytes, packets, lastuse);
+	a->ops->stats_update(a, bytes, packets, lastuse, hw);
 #endif
 }
 
diff --git a/include/net/pkt_cls.h b/include/net/pkt_cls.h
index ef727f71336e..de1f06ab1f2d 100644
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@ -324,7 +324,7 @@ tcf_exts_stats_update(const struct tcf_exts *exts,
 	for (i = 0; i < exts->nr_actions; i++) {
 		struct tc_action *a = exts->actions[i];
 
-		tcf_action_stats_update(a, bytes, packets, lastuse);
+		tcf_action_stats_update(a, bytes, packets, lastuse, true);
 	}
 
 	preempt_enable();
* Unmerged path net/sched/act_api.c
diff --git a/net/sched/act_gact.c b/net/sched/act_gact.c
index b5d443afc928..d9035b1dc616 100644
--- a/net/sched/act_gact.c
+++ b/net/sched/act_gact.c
@@ -149,7 +149,7 @@ static int tcf_gact_act(struct sk_buff *skb, const struct tc_action *a,
 }
 
 static void tcf_gact_stats_update(struct tc_action *a, u64 bytes, u32 packets,
-				  u64 lastuse)
+				  u64 lastuse, bool hw)
 {
 	struct tcf_gact *gact = to_gact(a);
 	int action = READ_ONCE(gact->tcf_action);
@@ -160,6 +160,10 @@ static void tcf_gact_stats_update(struct tc_action *a, u64 bytes, u32 packets,
 	if (action == TC_ACT_SHOT)
 		this_cpu_ptr(gact->common.cpu_qstats)->drops += packets;
 
+	if (hw)
+		_bstats_cpu_update(this_cpu_ptr(gact->common.cpu_bstats_hw),
+				   bytes, packets);
+
 	tm->lastuse = max_t(u64, tm->lastuse, lastuse);
 }
 
diff --git a/net/sched/act_mirred.c b/net/sched/act_mirred.c
index ac29367c48b6..6ba7f492a915 100644
--- a/net/sched/act_mirred.c
+++ b/net/sched/act_mirred.c
@@ -266,12 +266,15 @@ static int tcf_mirred_act(struct sk_buff *skb, const struct tc_action *a,
 }
 
 static void tcf_stats_update(struct tc_action *a, u64 bytes, u32 packets,
-			     u64 lastuse)
+			     u64 lastuse, bool hw)
 {
 	struct tcf_mirred *m = to_mirred(a);
 	struct tcf_t *tm = &m->tcf_tm;
 
 	_bstats_cpu_update(this_cpu_ptr(a->cpu_bstats), bytes, packets);
+	if (hw)
+		_bstats_cpu_update(this_cpu_ptr(a->cpu_bstats_hw),
+				   bytes, packets);
 	tm->lastuse = max_t(u64, tm->lastuse, lastuse);
 }
 
