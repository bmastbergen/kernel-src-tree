bsg: provide bsg_remove_queue() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit 5e28b8d8a1b03ce86f33d38a64a4983d2b5c7679
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/5e28b8d8.failed

All drivers do unregister + cleanup, provide a helper for that.

	Cc: linux-scsi@vger.kernel.org
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Tested-by: Benjamin Block <bblock@linux.vnet.ibm.com>
	Tested-by: Ming Lei <ming.lei@redhat.com>
	Reviewed-by: Omar Sandoval <osandov@fb.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 5e28b8d8a1b03ce86f33d38a64a4983d2b5c7679)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/ufs/ufs_bsg.c
#	include/linux/bsg-lib.h
diff --cc include/linux/bsg-lib.h
index 6aeaf6472665,9c9b134b1fa5..000000000000
--- a/include/linux/bsg-lib.h
+++ b/include/linux/bsg-lib.h
@@@ -72,7 -72,8 +72,12 @@@ struct bsg_job 
  void bsg_job_done(struct bsg_job *job, int result,
  		  unsigned int reply_payload_rcv_len);
  struct request_queue *bsg_setup_queue(struct device *dev, const char *name,
++<<<<<<< HEAD
 +		bsg_job_fn *job_fn, int dd_job_size);
++=======
+ 		bsg_job_fn *job_fn, rq_timed_out_fn *timeout, int dd_job_size);
+ void bsg_remove_queue(struct request_queue *q);
++>>>>>>> 5e28b8d8a1b0 (bsg: provide bsg_remove_queue() helper)
  void bsg_job_put(struct bsg_job *job);
  int __must_check bsg_job_get(struct bsg_job *job);
  
* Unmerged path drivers/scsi/ufs/ufs_bsg.c
diff --git a/block/bsg-lib.c b/block/bsg-lib.c
index f3501cdaf1a6..8cc34c246d20 100644
--- a/block/bsg-lib.c
+++ b/block/bsg-lib.c
@@ -296,6 +296,15 @@ static void bsg_exit_rq(struct request_queue *q, struct request *req)
 	kfree(job->reply);
 }
 
+void bsg_remove_queue(struct request_queue *q)
+{
+	if (q) {
+		bsg_unregister_queue(q);
+		blk_cleanup_queue(q);
+	}
+}
+EXPORT_SYMBOL_GPL(bsg_remove_queue);
+
 /**
  * bsg_setup_queue - Create and add the bsg hooks so we can receive requests
  * @dev: device to attach bsg device to
diff --git a/drivers/scsi/scsi_transport_fc.c b/drivers/scsi/scsi_transport_fc.c
index 13948102ca29..42beb6e2819b 100644
--- a/drivers/scsi/scsi_transport_fc.c
+++ b/drivers/scsi/scsi_transport_fc.c
@@ -3852,10 +3852,7 @@ fc_bsg_rportadd(struct Scsi_Host *shost, struct fc_rport *rport)
 static void
 fc_bsg_remove(struct request_queue *q)
 {
-	if (q) {
-		bsg_unregister_queue(q);
-		blk_cleanup_queue(q);
-	}
+	bsg_remove_queue(q);
 }
 
 
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 6fd2fe210fc3..2502f846f43b 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -1576,10 +1576,7 @@ static int iscsi_remove_host(struct transport_container *tc,
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct iscsi_cls_host *ihost = shost->shost_data;
 
-	if (ihost->bsg_q) {
-		bsg_unregister_queue(ihost->bsg_q);
-		blk_cleanup_queue(ihost->bsg_q);
-	}
+	bsg_remove_queue(ihost->bsg_q);
 	return 0;
 }
 
diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 0cd16e80b019..790d6b4b3af3 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -246,11 +246,7 @@ static int sas_host_remove(struct transport_container *tc, struct device *dev,
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct request_queue *q = to_sas_host_attrs(shost)->q;
 
-	if (q) {
-		bsg_unregister_queue(q);
-		blk_cleanup_queue(q);
-	}
-
+	bsg_remove_queue(q);
 	return 0;
 }
 
* Unmerged path drivers/scsi/ufs/ufs_bsg.c
* Unmerged path include/linux/bsg-lib.h
