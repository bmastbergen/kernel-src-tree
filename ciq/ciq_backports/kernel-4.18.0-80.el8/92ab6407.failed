net: aquantia: implement EEE support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-80.el8
commit-author Yana Esina <yana.esina@aquantia.com>
commit 92ab64079d6b750c2b6860d988b6c912a7eddfef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-80.el8/92ab6407.failed

Support of Energy-Efficient Ethernet to aQuantia NIC's via ethtool
(according to the IEEE 802.3az specifications)

	Signed-off-by: Yana Esina <yana.esina@aquantia.com>
	Signed-off-by: Nikita Danilov <nikita.danilov@aquantia.com>
	Tested-by: Nikita Danilov <nikita.danilov@aquantia.com>
	Signed-off-by: Igor Russkikh <igor.russkikh@aquantia.com>
	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 92ab64079d6b750c2b6860d988b6c912a7eddfef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
#	drivers/net/ethernet/aquantia/atlantic/aq_hw.h
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
#	drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
index f2d8063a2cef,22dd4fbd34d7..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
@@@ -284,6 -285,222 +284,225 @@@ static int aq_ethtool_set_coalesce(stru
  	return aq_nic_update_interrupt_moderation_settings(aq_nic);
  }
  
++<<<<<<< HEAD
++=======
+ static void aq_ethtool_get_wol(struct net_device *ndev,
+ 			       struct ethtool_wolinfo *wol)
+ {
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
+ 
+ 	wol->supported = WAKE_MAGIC;
+ 	wol->wolopts = 0;
+ 
+ 	if (cfg->wol)
+ 		wol->wolopts |= WAKE_MAGIC;
+ }
+ 
+ static int aq_ethtool_set_wol(struct net_device *ndev,
+ 			      struct ethtool_wolinfo *wol)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(ndev->dev.parent);
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 	struct aq_nic_cfg_s *cfg = aq_nic_get_cfg(aq_nic);
+ 	int err = 0;
+ 
+ 	if (wol->wolopts & WAKE_MAGIC)
+ 		cfg->wol |= AQ_NIC_WOL_ENABLED;
+ 	else
+ 		cfg->wol &= ~AQ_NIC_WOL_ENABLED;
+ 	err = device_set_wakeup_enable(&pdev->dev, wol->wolopts);
+ 
+ 	return err;
+ }
+ 
+ static enum hw_atl_fw2x_rate eee_mask_to_ethtool_mask(u32 speed)
+ {
+ 	u32 rate = 0;
+ 
+ 	if (speed & AQ_NIC_RATE_EEE_10G)
+ 		rate |= SUPPORTED_10000baseT_Full;
+ 
+ 	if (speed & AQ_NIC_RATE_EEE_2GS)
+ 		rate |= SUPPORTED_2500baseX_Full;
+ 
+ 	if (speed & AQ_NIC_RATE_EEE_1G)
+ 		rate |= SUPPORTED_1000baseT_Full;
+ 
+ 	return rate;
+ }
+ 
+ static int aq_ethtool_get_eee(struct net_device *ndev, struct ethtool_eee *eee)
+ {
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 	u32 rate, supported_rates;
+ 	int err = 0;
+ 
+ 	if (!aq_nic->aq_fw_ops->get_eee_rate)
+ 		return -EOPNOTSUPP;
+ 
+ 	err = aq_nic->aq_fw_ops->get_eee_rate(aq_nic->aq_hw, &rate,
+ 					      &supported_rates);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	eee->supported = eee_mask_to_ethtool_mask(supported_rates);
+ 
+ 	if (aq_nic->aq_nic_cfg.eee_speeds)
+ 		eee->advertised = eee->supported;
+ 
+ 	eee->lp_advertised = eee_mask_to_ethtool_mask(rate);
+ 
+ 	eee->eee_enabled = !!eee->advertised;
+ 
+ 	eee->tx_lpi_enabled = eee->eee_enabled;
+ 	if (eee->advertised & eee->lp_advertised)
+ 		eee->eee_active = true;
+ 
+ 	return 0;
+ }
+ 
+ static int aq_ethtool_set_eee(struct net_device *ndev, struct ethtool_eee *eee)
+ {
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 	u32 rate, supported_rates;
+ 	struct aq_nic_cfg_s *cfg;
+ 	int err = 0;
+ 
+ 	cfg = aq_nic_get_cfg(aq_nic);
+ 
+ 	if (unlikely(!aq_nic->aq_fw_ops->get_eee_rate ||
+ 		     !aq_nic->aq_fw_ops->set_eee_rate))
+ 		return -EOPNOTSUPP;
+ 
+ 	err = aq_nic->aq_fw_ops->get_eee_rate(aq_nic->aq_hw, &rate,
+ 					      &supported_rates);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (eee->eee_enabled) {
+ 		rate = supported_rates;
+ 		cfg->eee_speeds = rate;
+ 	} else {
+ 		rate = 0;
+ 		cfg->eee_speeds = 0;
+ 	}
+ 
+ 	return aq_nic->aq_fw_ops->set_eee_rate(aq_nic->aq_hw, rate);
+ }
+ 
+ static int aq_ethtool_nway_reset(struct net_device *ndev)
+ {
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 
+ 	if (unlikely(!aq_nic->aq_fw_ops->renegotiate))
+ 		return -EOPNOTSUPP;
+ 
+ 	if (netif_running(ndev))
+ 		return aq_nic->aq_fw_ops->renegotiate(aq_nic->aq_hw);
+ 
+ 	return 0;
+ }
+ 
+ static void aq_ethtool_get_pauseparam(struct net_device *ndev,
+ 				      struct ethtool_pauseparam *pause)
+ {
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 
+ 	pause->autoneg = 0;
+ 
+ 	if (aq_nic->aq_hw->aq_nic_cfg->flow_control & AQ_NIC_FC_RX)
+ 		pause->rx_pause = 1;
+ 	if (aq_nic->aq_hw->aq_nic_cfg->flow_control & AQ_NIC_FC_TX)
+ 		pause->tx_pause = 1;
+ }
+ 
+ static int aq_ethtool_set_pauseparam(struct net_device *ndev,
+ 				     struct ethtool_pauseparam *pause)
+ {
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 	int err = 0;
+ 
+ 	if (!aq_nic->aq_fw_ops->set_flow_control)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (pause->autoneg == AUTONEG_ENABLE)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (pause->rx_pause)
+ 		aq_nic->aq_hw->aq_nic_cfg->flow_control |= AQ_NIC_FC_RX;
+ 	else
+ 		aq_nic->aq_hw->aq_nic_cfg->flow_control &= ~AQ_NIC_FC_RX;
+ 
+ 	if (pause->tx_pause)
+ 		aq_nic->aq_hw->aq_nic_cfg->flow_control |= AQ_NIC_FC_TX;
+ 	else
+ 		aq_nic->aq_hw->aq_nic_cfg->flow_control &= ~AQ_NIC_FC_TX;
+ 
+ 	err = aq_nic->aq_fw_ops->set_flow_control(aq_nic->aq_hw);
+ 
+ 	return err;
+ }
+ 
+ static void aq_get_ringparam(struct net_device *ndev,
+ 			     struct ethtool_ringparam *ring)
+ {
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 	struct aq_nic_cfg_s *aq_nic_cfg = aq_nic_get_cfg(aq_nic);
+ 
+ 	ring->rx_pending = aq_nic_cfg->rxds;
+ 	ring->tx_pending = aq_nic_cfg->txds;
+ 
+ 	ring->rx_max_pending = aq_nic_cfg->aq_hw_caps->rxds_max;
+ 	ring->tx_max_pending = aq_nic_cfg->aq_hw_caps->txds_max;
+ }
+ 
+ static int aq_set_ringparam(struct net_device *ndev,
+ 			    struct ethtool_ringparam *ring)
+ {
+ 	int err = 0;
+ 	bool ndev_running = false;
+ 	struct aq_nic_s *aq_nic = netdev_priv(ndev);
+ 	struct aq_nic_cfg_s *aq_nic_cfg = aq_nic_get_cfg(aq_nic);
+ 	const struct aq_hw_caps_s *hw_caps = aq_nic_cfg->aq_hw_caps;
+ 
+ 	if (ring->rx_mini_pending || ring->rx_jumbo_pending) {
+ 		err = -EOPNOTSUPP;
+ 		goto err_exit;
+ 	}
+ 
+ 	if (netif_running(ndev)) {
+ 		ndev_running = true;
+ 		dev_close(ndev);
+ 	}
+ 
+ 	aq_nic_free_vectors(aq_nic);
+ 
+ 	aq_nic_cfg->rxds = max(ring->rx_pending, hw_caps->rxds_min);
+ 	aq_nic_cfg->rxds = min(aq_nic_cfg->rxds, hw_caps->rxds_max);
+ 	aq_nic_cfg->rxds = ALIGN(aq_nic_cfg->rxds, AQ_HW_RXD_MULTIPLE);
+ 
+ 	aq_nic_cfg->txds = max(ring->tx_pending, hw_caps->txds_min);
+ 	aq_nic_cfg->txds = min(aq_nic_cfg->txds, hw_caps->txds_max);
+ 	aq_nic_cfg->txds = ALIGN(aq_nic_cfg->txds, AQ_HW_TXD_MULTIPLE);
+ 
+ 	for (aq_nic->aq_vecs = 0; aq_nic->aq_vecs < aq_nic_cfg->vecs;
+ 	     aq_nic->aq_vecs++) {
+ 		aq_nic->aq_vec[aq_nic->aq_vecs] =
+ 		    aq_vec_alloc(aq_nic, aq_nic->aq_vecs, aq_nic_cfg);
+ 		if (unlikely(!aq_nic->aq_vec[aq_nic->aq_vecs])) {
+ 			err = -ENOMEM;
+ 			goto err_exit;
+ 		}
+ 	}
+ 	if (ndev_running)
+ 		err = dev_open(ndev);
+ 
+ err_exit:
+ 	return err;
+ }
+ 
++>>>>>>> 92ab64079d6b (net: aquantia: implement EEE support)
  const struct ethtool_ops aq_ethtool_ops = {
  	.get_link            = aq_ethtool_get_link,
  	.get_regs_len        = aq_ethtool_get_regs_len,
@@@ -291,6 -508,15 +510,18 @@@
  	.get_drvinfo         = aq_ethtool_get_drvinfo,
  	.get_strings         = aq_ethtool_get_strings,
  	.get_rxfh_indir_size = aq_ethtool_get_rss_indir_size,
++<<<<<<< HEAD
++=======
+ 	.get_wol             = aq_ethtool_get_wol,
+ 	.set_wol             = aq_ethtool_set_wol,
+ 	.nway_reset          = aq_ethtool_nway_reset,
+ 	.get_ringparam       = aq_get_ringparam,
+ 	.set_ringparam       = aq_set_ringparam,
+ 	.get_eee             = aq_ethtool_get_eee,
+ 	.set_eee             = aq_ethtool_set_eee,
+ 	.get_pauseparam      = aq_ethtool_get_pauseparam,
+ 	.set_pauseparam      = aq_ethtool_set_pauseparam,
++>>>>>>> 92ab64079d6b (net: aquantia: implement EEE support)
  	.get_rxfh_key_size   = aq_ethtool_get_rss_key_size,
  	.get_rxfh            = aq_ethtool_get_rss,
  	.get_rxnfc           = aq_ethtool_get_rxnfc,
diff --cc drivers/net/ethernet/aquantia/atlantic/aq_hw.h
index 1cf486d813e0,908f19fe19b3..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
@@@ -221,6 -227,14 +221,17 @@@ struct aq_fw_ops 
  	int (*update_stats)(struct aq_hw_s *self);
  
  	int (*set_flow_control)(struct aq_hw_s *self);
++<<<<<<< HEAD
++=======
+ 
+ 	int (*set_power)(struct aq_hw_s *self, unsigned int power_state,
+ 			 u8 *mac);
+ 
+ 	int (*set_eee_rate)(struct aq_hw_s *self, u32 speed);
+ 
+ 	int (*get_eee_rate)(struct aq_hw_s *self, u32 *rate,
+ 			    u32 *supported_rates);
++>>>>>>> 92ab64079d6b (net: aquantia: implement EEE support)
  };
  
  #endif /* AQ_HW_H */
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
index 54d5759f0ff8,bb1561c6d25a..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
@@@ -848,4 -915,8 +848,11 @@@ const struct aq_fw_ops aq_fw_1x_ops = 
  	.set_state = hw_atl_utils_mpi_set_state,
  	.update_link_status = hw_atl_utils_mpi_get_link_status,
  	.update_stats = hw_atl_utils_update_stats,
++<<<<<<< HEAD
++=======
+ 	.set_power = aq_fw1x_set_power,
+ 	.set_eee_rate = NULL,
+ 	.get_eee_rate = NULL,
+ 	.set_flow_control = NULL,
++>>>>>>> 92ab64079d6b (net: aquantia: implement EEE support)
  };
diff --cc drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
index 9c442f3e95f1,27bed5dd5295..000000000000
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
@@@ -124,6 -161,30 +161,33 @@@ static int aq_fw2x_set_link_speed(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void aq_fw2x_set_mpi_flow_control(struct aq_hw_s *self, u32 *mpi_state)
+ {
+ 	if (self->aq_nic_cfg->flow_control & AQ_NIC_FC_RX)
+ 		*mpi_state |= BIT(CAPS_HI_PAUSE);
+ 	else
+ 		*mpi_state &= ~BIT(CAPS_HI_PAUSE);
+ 
+ 	if (self->aq_nic_cfg->flow_control & AQ_NIC_FC_TX)
+ 		*mpi_state |= BIT(CAPS_HI_ASYMMETRIC_PAUSE);
+ 	else
+ 		*mpi_state &= ~BIT(CAPS_HI_ASYMMETRIC_PAUSE);
+ }
+ 
+ static void aq_fw2x_upd_eee_rate_bits(struct aq_hw_s *self, u32 *mpi_opts,
+ 				      u32 eee_speeds)
+ {
+ 	*mpi_opts &= ~(HW_ATL_FW2X_CAP_EEE_1G_MASK |
+ 		       HW_ATL_FW2X_CAP_EEE_2G5_MASK |
+ 		       HW_ATL_FW2X_CAP_EEE_5G_MASK |
+ 		       HW_ATL_FW2X_CAP_EEE_10G_MASK);
+ 
+ 	*mpi_opts |= eee_mask_to_fw2x(eee_speeds);
+ }
+ 
++>>>>>>> 92ab64079d6b (net: aquantia: implement EEE support)
  static int aq_fw2x_set_state(struct aq_hw_s *self,
  			     enum hal_atl_utils_fw_state_e state)
  {
@@@ -132,6 -194,8 +197,11 @@@
  	switch (state) {
  	case MPI_INIT:
  		mpi_state &= ~BIT(CAPS_HI_LINK_DROP);
++<<<<<<< HEAD
++=======
+ 		aq_fw2x_upd_eee_rate_bits(self, &mpi_state, cfg->eee_speeds);
+ 		aq_fw2x_set_mpi_flow_control(self, &mpi_state);
++>>>>>>> 92ab64079d6b (net: aquantia: implement EEE support)
  		break;
  	case MPI_DEINIT:
  		mpi_state |= BIT(CAPS_HI_LINK_DROP);
@@@ -238,6 -302,157 +308,160 @@@ static int aq_fw2x_update_stats(struct 
  	return hw_atl_utils_update_stats(self);
  }
  
++<<<<<<< HEAD
++=======
+ static int aq_fw2x_set_sleep_proxy(struct aq_hw_s *self, u8 *mac)
+ {
+ 	struct hw_aq_atl_utils_fw_rpc *rpc = NULL;
+ 	struct offload_info *cfg = NULL;
+ 	unsigned int rpc_size = 0U;
+ 	u32 mpi_opts;
+ 	int err = 0;
+ 
+ 	rpc_size = sizeof(rpc->msg_id) + sizeof(*cfg);
+ 
+ 	err = hw_atl_utils_fw_rpc_wait(self, &rpc);
+ 	if (err < 0)
+ 		goto err_exit;
+ 
+ 	memset(rpc, 0, rpc_size);
+ 	cfg = (struct offload_info *)(&rpc->msg_id + 1);
+ 
+ 	memcpy(cfg->mac_addr, mac, ETH_ALEN);
+ 	cfg->len = sizeof(*cfg);
+ 
+ 	/* Clear bit 0x36C.23 and 0x36C.22 */
+ 	mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+ 	mpi_opts &= ~HW_ATL_FW2X_CTRL_SLEEP_PROXY;
+ 	mpi_opts &= ~HW_ATL_FW2X_CTRL_LINK_DROP;
+ 
+ 	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+ 
+ 	err = hw_atl_utils_fw_rpc_call(self, rpc_size);
+ 	if (err < 0)
+ 		goto err_exit;
+ 
+ 	/* Set bit 0x36C.23 */
+ 	mpi_opts |= HW_ATL_FW2X_CTRL_SLEEP_PROXY;
+ 	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+ 
+ 	AQ_HW_WAIT_FOR((aq_hw_read_reg(self, HW_ATL_FW2X_MPI_STATE2_ADDR) &
+ 			HW_ATL_FW2X_CTRL_SLEEP_PROXY), 1U, 10000U);
+ 
+ err_exit:
+ 	return err;
+ }
+ 
+ static int aq_fw2x_set_wol_params(struct aq_hw_s *self, u8 *mac)
+ {
+ 	struct hw_aq_atl_utils_fw_rpc *rpc = NULL;
+ 	struct fw2x_msg_wol *msg = NULL;
+ 	u32 mpi_opts;
+ 	int err = 0;
+ 
+ 	err = hw_atl_utils_fw_rpc_wait(self, &rpc);
+ 	if (err < 0)
+ 		goto err_exit;
+ 
+ 	msg = (struct fw2x_msg_wol *)rpc;
+ 
+ 	msg->msg_id = HAL_ATLANTIC_UTILS_FW2X_MSG_WOL;
+ 	msg->magic_packet_enabled = true;
+ 	memcpy(msg->hw_addr, mac, ETH_ALEN);
+ 
+ 	mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+ 	mpi_opts &= ~(HW_ATL_FW2X_CTRL_SLEEP_PROXY | HW_ATL_FW2X_CTRL_WOL);
+ 
+ 	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+ 
+ 	err = hw_atl_utils_fw_rpc_call(self, sizeof(*msg));
+ 	if (err < 0)
+ 		goto err_exit;
+ 
+ 	/* Set bit 0x36C.24 */
+ 	mpi_opts |= HW_ATL_FW2X_CTRL_WOL;
+ 	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+ 
+ 	AQ_HW_WAIT_FOR((aq_hw_read_reg(self, HW_ATL_FW2X_MPI_STATE2_ADDR) &
+ 			HW_ATL_FW2X_CTRL_WOL), 1U, 10000U);
+ 
+ err_exit:
+ 	return err;
+ }
+ 
+ static int aq_fw2x_set_power(struct aq_hw_s *self, unsigned int power_state,
+ 			     u8 *mac)
+ {
+ 	int err = 0;
+ 
+ 	if (self->aq_nic_cfg->wol & AQ_NIC_WOL_ENABLED) {
+ 		err = aq_fw2x_set_sleep_proxy(self, mac);
+ 		if (err < 0)
+ 			goto err_exit;
+ 		err = aq_fw2x_set_wol_params(self, mac);
+ 	}
+ 
+ err_exit:
+ 	return err;
+ }
+ 
+ static int aq_fw2x_set_eee_rate(struct aq_hw_s *self, u32 speed)
+ {
+ 	u32 mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+ 
+ 	aq_fw2x_upd_eee_rate_bits(self, &mpi_opts, speed);
+ 
+ 	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+ 
+ 	return 0;
+ }
+ 
+ static int aq_fw2x_get_eee_rate(struct aq_hw_s *self, u32 *rate,
+ 				u32 *supported_rates)
+ {
+ 	u32 mpi_state;
+ 	u32 caps_hi;
+ 	int err = 0;
+ 	u32 addr = self->mbox_addr + offsetof(struct hw_aq_atl_utils_mbox, info) +
+ 		   offsetof(struct hw_aq_info, caps_hi);
+ 
+ 	err = hw_atl_utils_fw_downld_dwords(self, addr, &caps_hi,
+ 					    sizeof(caps_hi) / sizeof(u32));
+ 
+ 	if (err)
+ 		return err;
+ 
+ 	*supported_rates = fw2x_to_eee_mask(caps_hi);
+ 
+ 	mpi_state = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_STATE2_ADDR);
+ 	*rate = fw2x_to_eee_mask(mpi_state);
+ 
+ 	return err;
+ }
+ 
+ static int aq_fw2x_renegotiate(struct aq_hw_s *self)
+ {
+ 	u32 mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+ 
+ 	mpi_opts |= BIT(CTRL_FORCE_RECONNECT);
+ 
+ 	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);
+ 
+ 	return 0;
+ }
+ 
+ static int aq_fw2x_set_flow_control(struct aq_hw_s *self)
+ {
+ 	u32 mpi_state = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);
+ 
+ 	aq_fw2x_set_mpi_flow_control(self, &mpi_state);
+ 
+ 	aq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_state);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 92ab64079d6b (net: aquantia: implement EEE support)
  const struct aq_fw_ops aq_fw_2x_ops = {
  	.init = aq_fw2x_init,
  	.deinit = aq_fw2x_deinit,
@@@ -247,4 -463,8 +471,11 @@@
  	.set_state = aq_fw2x_set_state,
  	.update_link_status = aq_fw2x_update_link_status,
  	.update_stats = aq_fw2x_update_stats,
++<<<<<<< HEAD
++=======
+ 	.set_power = aq_fw2x_set_power,
+ 	.set_eee_rate = aq_fw2x_set_eee_rate,
+ 	.get_eee_rate = aq_fw2x_get_eee_rate,
+ 	.set_flow_control   = aq_fw2x_set_flow_control,
++>>>>>>> 92ab64079d6b (net: aquantia: implement EEE support)
  };
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_common.h b/drivers/net/ethernet/aquantia/atlantic/aq_common.h
index d52b088ff8f0..becb578211ed 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_common.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_common.h
@@ -57,4 +57,9 @@
 #define AQ_NIC_RATE_1G         BIT(4)
 #define AQ_NIC_RATE_100M       BIT(5)
 
+#define AQ_NIC_RATE_EEE_10G	BIT(6)
+#define AQ_NIC_RATE_EEE_5G	BIT(7)
+#define AQ_NIC_RATE_EEE_2GS	BIT(8)
+#define AQ_NIC_RATE_EEE_1G	BIT(9)
+
 #endif /* AQ_COMMON_H */
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_hw.h
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_nic.h b/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
index 2069cbb6e1a1..c1582f4e8e1b 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_nic.h
@@ -45,6 +45,7 @@ struct aq_nic_cfg_s {
 	bool is_lro;
 	u8  tcs;
 	struct aq_rss_parameters aq_rss;
+	u32 eee_speeds;
 };
 
 #define AQ_NIC_FLAG_STARTED     0x00000004U
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h
index a0fcd232c627..6e87986213c0 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.h
@@ -171,9 +171,22 @@ struct __packed hw_aq_atl_utils_mbox_header {
 	u32 error;
 };
 
+struct __packed hw_aq_info {
+	u8 reserved[6];
+	u16 phy_fault_code;
+	u16 phy_temperature;
+	u8 cable_len;
+	u8 reserved1;
+	u32 cable_diag_data[4];
+	u8 reserved2[32];
+	u32 caps_lo;
+	u32 caps_hi;
+};
+
 struct __packed hw_aq_atl_utils_mbox {
 	struct hw_aq_atl_utils_mbox_header header;
 	struct hw_atl_stats_s stats;
+	struct hw_aq_info info;
 };
 
 /* fw2x */
* Unmerged path drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
