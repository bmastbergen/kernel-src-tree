drm/i915/gem: Flush coherency domains on first set-domain-ioctl

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-301.1.el8
commit-author Chris Wilson <chris@chris-wilson.co.uk>
commit 44c2200afcd59f441b43f27829b4003397cc495d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-301.1.el8/44c2200a.failed

Avoid skipping what appears to be a no-op set-domain-ioctl if the cache
coherency state is inconsistent with our target domain. This also has
the utility of using the population of the pages to validate the backing
store.

The danger in skipping the first set-domain is leaving the cache
inconsistent and submitting stale data, or worse leaving the clean data
in the cache and not flushing it to the GPU. The impact should be small
as it requires a no-op set-domain as the very first ioctl in a
particular sequence not found in typical userspace.

	Reported-by: Zbigniew Kempczyński <zbigniew.kempczynski@intel.com>
Fixes: 754a25442705 ("drm/i915: Skip object locking around a no-op set-domain ioctl")
Testcase: igt/gem_mmap_offset/blt-coherency
	Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
	Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
	Cc: Matthew Auld <matthew.william.auld@gmail.com>
	Cc: Zbigniew Kempczyński <zbigniew.kempczynski@intel.com>
	Cc: <stable@vger.kernel.org> # v5.2+
	Reviewed-by: Matthew Auld <matthew.auld@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20201019203825.10966-1-chris@chris-wilson.co.uk
(cherry picked from commit 44c2200afcd59f441b43f27829b4003397cc495d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/gem/i915_gem_domain.c
diff --cc drivers/gpu/drm/i915/gem/i915_gem_domain.c
index 7f76fc68f498,fcce6909f201..000000000000
--- a/drivers/gpu/drm/i915/gem/i915_gem_domain.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_domain.c
@@@ -536,7 -545,20 +521,24 @@@ i915_gem_set_domain_ioctl(struct drm_de
  	if (err)
  		goto out;
  
++<<<<<<< HEAD
 +	err = i915_gem_object_lock_interruptible(obj);
++=======
+ 	/*
+ 	 * Already in the desired write domain? Nothing for us to do!
+ 	 *
+ 	 * We apply a little bit of cunning here to catch a broader set of
+ 	 * no-ops. If obj->write_domain is set, we must be in the same
+ 	 * obj->read_domains, and only that domain. Therefore, if that
+ 	 * obj->write_domain matches the request read_domains, we are
+ 	 * already in the same read/write domain and can skip the operation,
+ 	 * without having to further check the requested write_domain.
+ 	 */
+ 	if (READ_ONCE(obj->write_domain) == read_domains)
+ 		goto out_unpin;
+ 
+ 	err = i915_gem_object_lock_interruptible(obj, NULL);
++>>>>>>> 44c2200afcd5 (drm/i915/gem: Flush coherency domains on first set-domain-ioctl)
  	if (err)
  		goto out_unpin;
  
* Unmerged path drivers/gpu/drm/i915/gem/i915_gem_domain.c
