KVM: x86/mmu: Allow parallel page faults for the TDP MMU

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-301.1.el8
commit-author Ben Gardon <bgardon@google.com>
commit a2855afc7ee88475e8feb16840b23f787bfc994d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-301.1.el8/a2855afc.failed

Make the last few changes necessary to enable the TDP MMU to handle page
faults in parallel while holding the mmu_lock in read mode.

	Reviewed-by: Peter Feiner <pfeiner@google.com>
	Signed-off-by: Ben Gardon <bgardon@google.com>
Message-Id: <20210202185734.1680553-24-bgardon@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit a2855afc7ee88475e8feb16840b23f787bfc994d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/mmu.c
diff --cc arch/x86/kvm/mmu/mmu.c
index 817f867018a4,e8bfff9acd5e..000000000000
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@@ -3715,7 -3718,12 +3715,16 @@@ static int direct_page_fault(struct kvm
  		return r;
  
  	r = RET_PF_RETRY;
++<<<<<<< HEAD
 +	spin_lock(&vcpu->kvm->mmu_lock);
++=======
+ 
+ 	if (is_tdp_mmu_root(vcpu->kvm, vcpu->arch.mmu->root_hpa))
+ 		read_lock(&vcpu->kvm->mmu_lock);
+ 	else
+ 		write_lock(&vcpu->kvm->mmu_lock);
+ 
++>>>>>>> a2855afc7ee8 (KVM: x86/mmu: Allow parallel page faults for the TDP MMU)
  	if (mmu_notifier_retry(vcpu->kvm, mmu_seq))
  		goto out_unlock;
  	r = make_mmu_pages_available(vcpu);
@@@ -3730,7 -3738,10 +3739,14 @@@
  				 prefault, is_tdp);
  
  out_unlock:
++<<<<<<< HEAD
 +	spin_unlock(&vcpu->kvm->mmu_lock);
++=======
+ 	if (is_tdp_mmu_root(vcpu->kvm, vcpu->arch.mmu->root_hpa))
+ 		read_unlock(&vcpu->kvm->mmu_lock);
+ 	else
+ 		write_unlock(&vcpu->kvm->mmu_lock);
++>>>>>>> a2855afc7ee8 (KVM: x86/mmu: Allow parallel page faults for the TDP MMU)
  	kvm_release_pfn_clean(pfn);
  	return r;
  }
* Unmerged path arch/x86/kvm/mmu/mmu.c
