netlink: make NLA_BINARY validation more flexible

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-301.1.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit 8aa26c575fb343ebde810b30dad0cba7d8121efb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-301.1.el8/8aa26c57.failed

Add range validation for NLA_BINARY, allowing validation of any
combination of combination minimum or maximum lengths, using the
existing NLA_POLICY_RANGE()/NLA_POLICY_FULL_RANGE() macros, just
like for integers where the value is checked.

Also make NLA_POLICY_EXACT_LEN(), NLA_POLICY_EXACT_LEN_WARN()
and NLA_POLICY_MIN_LEN() special cases of this, removing the old
types NLA_EXACT_LEN and NLA_MIN_LEN.

This allows us to save some code where both minimum and maximum
lengths are requires, currently the policy only allows maximum
(NLA_BINARY), minimum (NLA_MIN_LEN) or exact (NLA_EXACT_LEN), so
a range of lengths cannot be accepted and must be checked by the
code that consumes the attributes later.

Also, this allows advertising the correct ranges in the policy
export to userspace. Here, NLA_MIN_LEN and NLA_EXACT_LEN already
were special cases of NLA_BINARY with min and min/max length
respectively.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8aa26c575fb343ebde810b30dad0cba7d8121efb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netlink.h
#	lib/nlattr.c
diff --cc include/net/netlink.h
index e9fce5130a10,fdd317f8fde4..000000000000
--- a/include/net/netlink.h
+++ b/include/net/netlink.h
@@@ -181,9 -181,6 +181,12 @@@ enum 
  	NLA_S64,
  	NLA_BITFIELD32,
  	NLA_REJECT,
++<<<<<<< HEAD
 +	NLA_EXACT_LEN,
 +	NLA_EXACT_LEN_WARN,
 +	NLA_MIN_LEN,
++=======
++>>>>>>> 8aa26c575fb3 (netlink: make NLA_BINARY validation more flexible)
  	__NLA_TYPE_MAX,
  };
  
@@@ -200,14 -197,11 +203,18 @@@ struct netlink_range_validation_signed 
  enum nla_policy_validation {
  	NLA_VALIDATE_NONE,
  	NLA_VALIDATE_RANGE,
+ 	NLA_VALIDATE_RANGE_WARN_TOO_LONG,
  	NLA_VALIDATE_MIN,
  	NLA_VALIDATE_MAX,
 -	NLA_VALIDATE_RANGE_PTR,
  	NLA_VALIDATE_FUNCTION,
++<<<<<<< HEAD
 +	/* RHEL: any new enumerants need to be placed at the end to preserve
 +	 * KABI for older kernel modules.
 +	*/
 +	NLA_VALIDATE_RANGE_PTR,
 +	NLA_VALIDATE_WARN_TOO_LONG,
++=======
++>>>>>>> 8aa26c575fb3 (netlink: make NLA_BINARY validation more flexible)
  };
  
  /**
@@@ -241,13 -235,6 +248,16 @@@
   *                         just like "All other"
   *    NLA_BITFIELD32       Unused
   *    NLA_REJECT           Unused
++<<<<<<< HEAD
 + *    NLA_EXACT_LEN        Attribute should have exactly this length, otherwise
 + *                         it is rejected or warned about, the latter happening
 + *                         if and only if the `validation_type' is set to
 + *                         NLA_VALIDATE_WARN_TOO_LONG.
 + *    NLA_EXACT_LEN_WARN   Deprecated, to preserve the numerical values
 + *                         of the successors in kabi.
 + *    NLA_MIN_LEN          Minimum length of attribute payload
++=======
++>>>>>>> 8aa26c575fb3 (netlink: make NLA_BINARY validation more flexible)
   *    All other            Minimum length of attribute payload
   *
   * Meaning of validation union:
@@@ -316,8 -307,8 +331,13 @@@
   * static const struct nla_policy my_policy[ATTR_MAX+1] = {
   * 	[ATTR_FOO] = { .type = NLA_U16 },
   *	[ATTR_BAR] = { .type = NLA_STRING, .len = BARSIZ },
++<<<<<<< HEAD
 + *	[ATTR_BAZ] = { .type = NLA_EXACT_LEN, .len = sizeof(struct mystruct) },
 + *	[ATTR_GOO] = NLA_POLICY_BITFIELD32_PTR(&myvalidflags),
++=======
+  *	[ATTR_BAZ] = NLA_POLICY_EXACT_LEN(sizeof(struct mystruct)),
+  *	[ATTR_GOO] = NLA_POLICY_BITFIELD32(myvalidflags),
++>>>>>>> 8aa26c575fb3 (netlink: make NLA_BINARY validation more flexible)
   * };
   */
  struct nla_policy {
@@@ -369,22 -346,8 +390,25 @@@
  		 */
  		u16 strict_start_type;
  	};
 +#endif
  };
  
++<<<<<<< HEAD
 +/* RHEL only: make sure the union doesn't grow and is aligned
 + * to the end of the struct, like the original field.
 + */
 +static_assert(offsetofend(struct nla_policy,
 +			  bitfield32_valid_ptr) == sizeof(struct nla_policy),
 +	      "The size of struct nla_policy is fixed and cannot be changed");
 +
 +#define NLA_POLICY_EXACT_LEN(_len)	{ .type = NLA_EXACT_LEN, .len = _len }
 +#define NLA_POLICY_EXACT_LEN_WARN(_len) \
 +	{ .type = NLA_EXACT_LEN, .len = _len, \
 +	  .validation_type = NLA_VALIDATE_WARN_TOO_LONG, }
 +#define NLA_POLICY_MIN_LEN(_len)	{ .type = NLA_MIN_LEN, .len = _len }
 +
++=======
++>>>>>>> 8aa26c575fb3 (netlink: make NLA_BINARY validation more flexible)
  #define NLA_POLICY_ETH_ADDR		NLA_POLICY_EXACT_LEN(ETH_ALEN)
  #define NLA_POLICY_ETH_ADDR_COMPAT	NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN)
  
@@@ -396,14 -359,15 +420,15 @@@
  	_NLA_POLICY_NESTED(ARRAY_SIZE(policy) - 1, policy)
  #define NLA_POLICY_NESTED_ARRAY(policy) \
  	_NLA_POLICY_NESTED_ARRAY(ARRAY_SIZE(policy) - 1, policy)
 -#define NLA_POLICY_BITFIELD32(valid) \
 -	{ .type = NLA_BITFIELD32, .bitfield32_valid = valid }
 +#define NLA_POLICY_BITFIELD32_PTR(valid) \
 +	{ .type = NLA_BITFIELD32, .bitfield32_valid_ptr = valid }
  
  #define __NLA_ENSURE(condition) BUILD_BUG_ON_ZERO(!(condition))
- #define NLA_ENSURE_UINT_TYPE(tp)			\
+ #define NLA_ENSURE_UINT_OR_BINARY_TYPE(tp)		\
  	(__NLA_ENSURE(tp == NLA_U8 || tp == NLA_U16 ||	\
  		      tp == NLA_U32 || tp == NLA_U64 ||	\
- 		      tp == NLA_MSECS) + tp)
+ 		      tp == NLA_MSECS ||		\
+ 		      tp == NLA_BINARY) + tp)
  #define NLA_ENSURE_SINT_TYPE(tp)			\
  	(__NLA_ENSURE(tp == NLA_S8 || tp == NLA_S16  ||	\
  		      tp == NLA_S32 || tp == NLA_S64) + tp)
diff --cc lib/nlattr.c
index 161f70864b52,665bdaff02c8..000000000000
--- a/lib/nlattr.c
+++ b/lib/nlattr.c
@@@ -313,15 -342,7 +342,19 @@@ static int validate_nla(const struct nl
  
  	BUG_ON(pt->type > NLA_TYPE_MAX);
  
++<<<<<<< HEAD
 +	/* RHEL: To preserve backward compatibility with older binary modules
 +	 * we need to preserve NLA_EXACT_LEN_WARN type together with its
 +	 * semantic.
 +	*/
 +	if ((nla_attr_len[pt->type] && attrlen != nla_attr_len[pt->type]) ||
 +	    (pt->type == NLA_EXACT_LEN_WARN && attrlen != pt->len) ||
 +	    (pt->type == NLA_EXACT_LEN &&
 +	     pt->validation_type == NLA_VALIDATE_WARN_TOO_LONG &&
 +	     attrlen != pt->len)) {
++=======
+ 	if (nla_attr_len[pt->type] && attrlen != nla_attr_len[pt->type]) {
++>>>>>>> 8aa26c575fb3 (netlink: make NLA_BINARY validation more flexible)
  		pr_warn_ratelimited("netlink: '%s': attribute type %d has an invalid length.\n",
  				    current->comm, type);
  		if (validate & NL_VALIDATE_STRICT_ATTRS) {
* Unmerged path include/net/netlink.h
* Unmerged path lib/nlattr.c
diff --git a/net/netlink/policy.c b/net/netlink/policy.c
index e7447aea98a0..164091d77b31 100644
--- a/net/netlink/policy.c
+++ b/net/netlink/policy.c
@@ -254,12 +254,6 @@ int netlink_policy_dump_write(struct sk_buff *skb, unsigned long _state)
 				*pt->bitfield32_valid_ptr))
 			goto nla_put_failure;
 		break;
-	case NLA_EXACT_LEN:
-		type = NL_ATTR_TYPE_BINARY;
-		if (nla_put_u32(skb, NL_POLICY_TYPE_ATTR_MIN_LENGTH, pt->len) ||
-		    nla_put_u32(skb, NL_POLICY_TYPE_ATTR_MAX_LENGTH, pt->len))
-			goto nla_put_failure;
-		break;
 	case NLA_STRING:
 	case NLA_NUL_STRING:
 	case NLA_BINARY:
@@ -269,14 +263,26 @@ int netlink_policy_dump_write(struct sk_buff *skb, unsigned long _state)
 			type = NL_ATTR_TYPE_NUL_STRING;
 		else
 			type = NL_ATTR_TYPE_BINARY;
-		if (pt->len && nla_put_u32(skb, NL_POLICY_TYPE_ATTR_MAX_LENGTH,
-					   pt->len))
-			goto nla_put_failure;
-		break;
-	case NLA_MIN_LEN:
-		type = NL_ATTR_TYPE_BINARY;
-		if (nla_put_u32(skb, NL_POLICY_TYPE_ATTR_MIN_LENGTH, pt->len))
+
+		if (pt->validation_type != NLA_VALIDATE_NONE) {
+			struct netlink_range_validation range;
+
+			nla_get_range_unsigned(pt, &range);
+
+			if (range.min &&
+			    nla_put_u32(skb, NL_POLICY_TYPE_ATTR_MIN_LENGTH,
+					range.min))
+				goto nla_put_failure;
+
+			if (range.max < U16_MAX &&
+			    nla_put_u32(skb, NL_POLICY_TYPE_ATTR_MAX_LENGTH,
+					range.max))
+				goto nla_put_failure;
+		} else if (pt->len &&
+			   nla_put_u32(skb, NL_POLICY_TYPE_ATTR_MAX_LENGTH,
+				       pt->len)) {
 			goto nla_put_failure;
+		}
 		break;
 	case NLA_FLAG:
 		type = NL_ATTR_TYPE_FLAG;
