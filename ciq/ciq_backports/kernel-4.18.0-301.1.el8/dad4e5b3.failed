mm: fix page reference leak in soft_offline_page()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-301.1.el8
commit-author Dan Williams <dan.j.williams@intel.com>
commit dad4e5b390866ca902653df0daa864ae4b8d4147
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-301.1.el8/dad4e5b3.failed

The conversion to move pfn_to_online_page() internal to
soft_offline_page() missed that the get_user_pages() reference taken by
the madvise() path needs to be dropped when pfn_to_online_page() fails.

Note the direct sysfs-path to soft_offline_page() does not perform a
get_user_pages() lookup.

When soft_offline_page() is handed a pfn_valid() && !pfn_to_online_page()
pfn the kernel hangs at dax-device shutdown due to a leaked reference.

Link: https://lkml.kernel.org/r/161058501210.1840162.8108917599181157327.stgit@dwillia2-desk3.amr.corp.intel.com
Fixes: feec24a6139d ("mm, soft-offline: convert parameter to pfn")
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Reviewed-by: David Hildenbrand <david@redhat.com>
	Reviewed-by: Oscar Salvador <osalvador@suse.de>
	Reviewed-by: Naoya Horiguchi <naoya.horiguchi@nec.com>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Qian Cai <cai@lca.pw>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit dad4e5b390866ca902653df0daa864ae4b8d4147)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory-failure.c
diff --cc mm/memory-failure.c
index e5b3fb97b4e8,e9481632fcd1..000000000000
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@@ -1880,15 -1923,19 +1888,25 @@@ int soft_offline_page(unsigned long pfn
  
  	if (!pfn_valid(pfn))
  		return -ENXIO;
+ 	if (flags & MF_COUNT_INCREASED)
+ 		ref_page = pfn_to_page(pfn);
+ 
  	/* Only online pages can be soft-offlined (esp., not ZONE_DEVICE). */
  	page = pfn_to_online_page(pfn);
- 	if (!page)
+ 	if (!page) {
+ 		put_ref_page(ref_page);
  		return -EIO;
+ 	}
  
  	if (PageHWPoison(page)) {
++<<<<<<< HEAD
 +		pr_info("soft offline: %#lx page already poisoned\n", pfn);
 +		if (flags & MF_COUNT_INCREASED)
 +			put_page(page);
++=======
+ 		pr_info("%s: %#lx page already poisoned\n", __func__, pfn);
+ 		put_ref_page(ref_page);
++>>>>>>> dad4e5b39086 (mm: fix page reference leak in soft_offline_page())
  		return 0;
  	}
  
* Unmerged path mm/memory-failure.c
