net/mlx5e: Fix a use after free on error in mlx5_tc_ct_shared_counter_get()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-301.1.el8
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit 7b2b16ee54cc08e268ddae59152cc99ec8275e1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-301.1.el8/7b2b16ee.failed

This code frees "shared_counter" and then dereferences on the next line
to get the error code.

Fixes: 1edae2335adf ("net/mlx5e: CT: Use the same counter for both directions")
	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
	Reviewed-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 7b2b16ee54cc08e268ddae59152cc99ec8275e1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
index 5ca0fb79498c,cea2070af9af..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
@@@ -713,6 -730,64 +713,67 @@@ err_mod_hdr
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static struct mlx5_ct_shared_counter *
+ mlx5_tc_ct_shared_counter_get(struct mlx5_tc_ct_priv *ct_priv,
+ 			      struct mlx5_ct_entry *entry)
+ {
+ 	struct mlx5_ct_tuple rev_tuple = entry->tuple;
+ 	struct mlx5_ct_shared_counter *shared_counter;
+ 	struct mlx5_core_dev *dev = ct_priv->dev;
+ 	struct mlx5_ct_entry *rev_entry;
+ 	__be16 tmp_port;
+ 	int ret;
+ 
+ 	/* get the reversed tuple */
+ 	tmp_port = rev_tuple.port.src;
+ 	rev_tuple.port.src = rev_tuple.port.dst;
+ 	rev_tuple.port.dst = tmp_port;
+ 
+ 	if (rev_tuple.addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {
+ 		__be32 tmp_addr = rev_tuple.ip.src_v4;
+ 
+ 		rev_tuple.ip.src_v4 = rev_tuple.ip.dst_v4;
+ 		rev_tuple.ip.dst_v4 = tmp_addr;
+ 	} else if (rev_tuple.addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {
+ 		struct in6_addr tmp_addr = rev_tuple.ip.src_v6;
+ 
+ 		rev_tuple.ip.src_v6 = rev_tuple.ip.dst_v6;
+ 		rev_tuple.ip.dst_v6 = tmp_addr;
+ 	} else {
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 	}
+ 
+ 	/* Use the same counter as the reverse direction */
+ 	mutex_lock(&ct_priv->shared_counter_lock);
+ 	rev_entry = rhashtable_lookup_fast(&ct_priv->ct_tuples_ht, &rev_tuple,
+ 					   tuples_ht_params);
+ 	if (rev_entry) {
+ 		if (refcount_inc_not_zero(&rev_entry->shared_counter->refcount)) {
+ 			mutex_unlock(&ct_priv->shared_counter_lock);
+ 			return rev_entry->shared_counter;
+ 		}
+ 	}
+ 	mutex_unlock(&ct_priv->shared_counter_lock);
+ 
+ 	shared_counter = kzalloc(sizeof(*shared_counter), GFP_KERNEL);
+ 	if (!shared_counter)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	shared_counter->counter = mlx5_fc_create(dev, true);
+ 	if (IS_ERR(shared_counter->counter)) {
+ 		ct_dbg("Failed to create counter for ct entry");
+ 		ret = PTR_ERR(shared_counter->counter);
+ 		kfree(shared_counter);
+ 		return ERR_PTR(ret);
+ 	}
+ 
+ 	refcount_set(&shared_counter->refcount, 1);
+ 	return shared_counter;
+ }
+ 
++>>>>>>> 7b2b16ee54cc (net/mlx5e: Fix a use after free on error in mlx5_tc_ct_shared_counter_get())
  static int
  mlx5_tc_ct_entry_add_rules(struct mlx5_tc_ct_priv *ct_priv,
  			   struct flow_rule *flow_rule,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
