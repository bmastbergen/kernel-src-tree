drm/amdgpu/swsmu: drop smu i2c bus on navi1x

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-301.1.el8
commit-author Alex Deucher <alexander.deucher@amd.com>
commit 19cc89dcb94b47a015fece85db685f1a2563a422
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-301.1.el8/19cc89dc.failed

Stop registering the SMU i2c bus on navi1x.  This leads to instability
issues when userspace processes mess with the bus and also seems to
cause display stability issues in some cases.

Bug: https://gitlab.freedesktop.org/drm/amd/-/issues/1314
Bug: https://gitlab.freedesktop.org/drm/amd/-/issues/1341
	Reviewed-by: Evan Quan <evan.quan@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit 19cc89dcb94b47a015fece85db685f1a2563a422)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/powerplay/navi10_ppt.c
diff --cc drivers/gpu/drm/amd/powerplay/navi10_ppt.c
index b1547a83e721,9cf97744b67e..000000000000
--- a/drivers/gpu/drm/amd/powerplay/navi10_ppt.c
+++ b/drivers/gpu/drm/amd/powerplay/navi10_ppt.c
@@@ -2463,29 -2534,130 +2463,156 @@@ static const struct i2c_algorithm navi1
  	.functionality = navi10_i2c_func,
  };
  
++<<<<<<< HEAD:drivers/gpu/drm/amd/powerplay/navi10_ppt.c
 +static int navi10_i2c_control_init(struct smu_context *smu, struct i2c_adapter *control)
 +{
 +	struct amdgpu_device *adev = to_amdgpu_device(control);
 +	int res;
 +
 +	control->owner = THIS_MODULE;
 +	control->class = I2C_CLASS_SPD;
 +	control->dev.parent = &adev->pdev->dev;
 +	control->algo = &navi10_i2c_algo;
 +	snprintf(control->name, sizeof(control->name), "AMDGPU SMU");
 +
 +	res = i2c_add_adapter(control);
 +	if (res)
 +		DRM_ERROR("Failed to register hw i2c, err: %d\n", res);
 +
 +	return res;
 +}
 +
 +static void navi10_i2c_control_fini(struct smu_context *smu, struct i2c_adapter *control)
 +{
 +	i2c_del_adapter(control);
 +}
 +
++=======
+ static ssize_t navi10_get_gpu_metrics(struct smu_context *smu,
+ 				      void **table)
+ {
+ 	struct smu_table_context *smu_table = &smu->smu_table;
+ 	struct gpu_metrics_v1_0 *gpu_metrics =
+ 		(struct gpu_metrics_v1_0 *)smu_table->gpu_metrics_table;
+ 	struct amdgpu_device *adev = smu->adev;
+ 	SmuMetrics_NV12_t nv12_metrics = { 0 };
+ 	SmuMetrics_t metrics;
+ 	int ret = 0;
+ 
+ 	mutex_lock(&smu->metrics_lock);
+ 
+ 	ret = smu_cmn_get_metrics_table_locked(smu,
+ 					       NULL,
+ 					       true);
+ 	if (ret) {
+ 		mutex_unlock(&smu->metrics_lock);
+ 		return ret;
+ 	}
+ 
+ 	memcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_t));
+ 	if (adev->asic_type == CHIP_NAVI12)
+ 		memcpy(&nv12_metrics, smu_table->metrics_table, sizeof(SmuMetrics_NV12_t));
+ 
+ 	mutex_unlock(&smu->metrics_lock);
+ 
+ 	smu_v11_0_init_gpu_metrics_v1_0(gpu_metrics);
+ 
+ 	gpu_metrics->temperature_edge = metrics.TemperatureEdge;
+ 	gpu_metrics->temperature_hotspot = metrics.TemperatureHotspot;
+ 	gpu_metrics->temperature_mem = metrics.TemperatureMem;
+ 	gpu_metrics->temperature_vrgfx = metrics.TemperatureVrGfx;
+ 	gpu_metrics->temperature_vrsoc = metrics.TemperatureVrSoc;
+ 	gpu_metrics->temperature_vrmem = metrics.TemperatureVrMem0;
+ 
+ 	gpu_metrics->average_gfx_activity = metrics.AverageGfxActivity;
+ 	gpu_metrics->average_umc_activity = metrics.AverageUclkActivity;
+ 
+ 	gpu_metrics->average_socket_power = metrics.AverageSocketPower;
+ 
+ 	gpu_metrics->average_gfxclk_frequency = metrics.AverageGfxclkFrequency;
+ 	gpu_metrics->average_socclk_frequency = metrics.AverageSocclkFrequency;
+ 	gpu_metrics->average_uclk_frequency = metrics.AverageUclkFrequency;
+ 
+ 	if (adev->asic_type == CHIP_NAVI12) {
+ 		gpu_metrics->energy_accumulator = nv12_metrics.EnergyAccumulator;
+ 		gpu_metrics->average_vclk0_frequency = nv12_metrics.AverageVclkFrequency;
+ 		gpu_metrics->average_dclk0_frequency = nv12_metrics.AverageDclkFrequency;
+ 		gpu_metrics->average_mm_activity = nv12_metrics.VcnActivityPercentage;
+ 	}
+ 
+ 	gpu_metrics->current_gfxclk = metrics.CurrClock[PPCLK_GFXCLK];
+ 	gpu_metrics->current_socclk = metrics.CurrClock[PPCLK_SOCCLK];
+ 	gpu_metrics->current_uclk = metrics.CurrClock[PPCLK_UCLK];
+ 	gpu_metrics->current_vclk0 = metrics.CurrClock[PPCLK_VCLK];
+ 	gpu_metrics->current_dclk0 = metrics.CurrClock[PPCLK_DCLK];
+ 
+ 	gpu_metrics->throttle_status = metrics.ThrottlerStatus;
+ 
+ 	gpu_metrics->current_fan_speed = metrics.CurrFanSpeed;
+ 
+ 	gpu_metrics->pcie_link_width =
+ 			smu_v11_0_get_current_pcie_link_width(smu);
+ 	gpu_metrics->pcie_link_speed =
+ 			smu_v11_0_get_current_pcie_link_speed(smu);
+ 
+ 	*table = (void *)gpu_metrics;
+ 
+ 	return sizeof(struct gpu_metrics_v1_0);
+ }
+ 
+ static int navi10_enable_mgpu_fan_boost(struct smu_context *smu)
+ {
+ 	struct amdgpu_device *adev = smu->adev;
+ 	uint32_t param = 0;
+ 
+ 	/* Navi12 does not support this */
+ 	if (adev->asic_type == CHIP_NAVI12)
+ 		return 0;
+ 
+ 	/* Workaround for WS SKU */
+ 	if (adev->pdev->device == 0x7312 &&
+ 	    adev->pdev->revision == 0)
+ 		param = 0xD188;
+ 
+ 	return smu_cmn_send_smc_msg_with_param(smu,
+ 					       SMU_MSG_SetMGpuFanBoostLimitRpm,
+ 					       param,
+ 					       NULL);
+ }
+ 
+ static int navi10_post_smu_init(struct smu_context *smu)
+ {
+ 	struct amdgpu_device *adev = smu->adev;
+ 	int ret = 0;
+ 
+ 	if (amdgpu_sriov_vf(adev))
+ 		return 0;
+ 
+ 	ret = navi10_run_umc_cdr_workaround(smu);
+ 	if (ret) {
+ 		dev_err(adev->dev, "Failed to apply umc cdr workaround!\n");
+ 		return ret;
+ 	}
+ 
+ 	if (!smu->dc_controlled_by_gpio) {
+ 		/*
+ 		 * For Navi1X, manually switch it to AC mode as PMFW
+ 		 * may boot it with DC mode.
+ 		 */
+ 		ret = smu_v11_0_set_power_source(smu,
+ 						 adev->pm.ac_power ?
+ 						 SMU_POWER_SOURCE_AC :
+ 						 SMU_POWER_SOURCE_DC);
+ 		if (ret) {
+ 			dev_err(adev->dev, "Failed to switch to %s mode!\n",
+ 					adev->pm.ac_power ? "AC" : "DC");
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
++>>>>>>> 19cc89dcb94b (drm/amdgpu/swsmu: drop smu i2c bus on navi1x):drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c
  
  static const struct pptable_funcs navi10_ppt_funcs = {
  	.get_allowed_feature_mask = navi10_get_allowed_feature_mask,
* Unmerged path drivers/gpu/drm/amd/powerplay/navi10_ppt.c
