ibmvnic: fix a race between open and reset

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-301.1.el8
commit-author Sukadev Bhattiprolu <sukadev@linux.ibm.com>
commit 8f1c0fd2c84c8bf738b7139d09d4ea53027f47c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-301.1.el8/8f1c0fd2.failed

__ibmvnic_reset() currently reads the adapter->state before getting the
rtnl and saves that state as the "target state" for the reset. If this
read occurs when adapter is in PROBED state, the target state would be
PROBED.

Just after the target state is saved, and before the actual reset process
is started (i.e before rtnl is acquired) if we get an ibmvnic_open() call
we would move the adapter to OPEN state.

But when the reset is processed (after ibmvnic_open()) drops the rtnl),
it will leave the adapter in PROBED state even though we already moved
it to OPEN.

To fix this, use the RTNL to improve serialization when reading/updating
the adapter state. i.e determine the target state of a reset only after
getting the RTNL. And if a reset is in progress during an open, simply
set the target state of the adapter and let the reset code finish the
open (like we currently do if failover is pending).

One twist to this serialization is if the adapter state changes when we
drop the RTNL to update the link state. Account for this by checking if
there was an intervening open and update the target state for the reset
accordingly (see new comments in the code). Note that only the reset
functions and ibmvnic_open() can set the adapter to OPEN state and this
must happen under rtnl.

Fixes: 7d7195a026ba ("ibmvnic: Do not process device remove during device reset")
	Signed-off-by: Sukadev Bhattiprolu <sukadev@linux.ibm.com>
	Reviewed-by: Dany Madden <drt@linux.ibm.com>
Link: https://lore.kernel.org/r/20210224050229.1155468-1-sukadev@linux.ibm.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 8f1c0fd2c84c8bf738b7139d09d4ea53027f47c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/ibm/ibmvnic.c
diff --cc drivers/net/ethernet/ibm/ibmvnic.c
index e8ffc2c1ce44,118a4bd3f877..000000000000
--- a/drivers/net/ethernet/ibm/ibmvnic.c
+++ b/drivers/net/ethernet/ibm/ibmvnic.c
@@@ -1235,11 -1209,12 +1248,18 @@@ static int ibmvnic_open(struct net_devi
  	rc = __ibmvnic_open(netdev);
  
  out:
++<<<<<<< HEAD
 +	/*
 +	 * If open fails due to a pending failover, set device state and
 +	 * return. Device operation will be handled by reset routine.
++=======
+ 	/* If open failed and there is a pending failover or in-progress reset,
+ 	 * set device state and return. Device operation will be handled by
+ 	 * reset routine. See also comments above regarding rtnl.
++>>>>>>> 8f1c0fd2c84c (ibmvnic: fix a race between open and reset)
  	 */
- 	if (rc && adapter->failover_pending) {
+ 	if (rc &&
+ 	    (adapter->failover_pending || (test_bit(0, &adapter->resetting)))) {
  		adapter->state = VNIC_OPEN;
  		rc = 0;
  	}
@@@ -2049,8 -1943,15 +2069,16 @@@ static int do_reset(struct ibmvnic_adap
  	if (rwi->reset_reason == VNIC_RESET_FAILOVER)
  		adapter->failover_pending = false;
  
+ 	/* read the state and check (again) after getting rtnl */
+ 	reset_state = adapter->state;
+ 
+ 	if (reset_state == VNIC_REMOVING || reset_state == VNIC_REMOVED) {
+ 		rc = -EBUSY;
+ 		goto out;
+ 	}
+ 
  	netif_carrier_off(netdev);
 +	adapter->reset_reason = rwi->reset_reason;
  
  	old_num_rx_queues = adapter->req_rx_queues;
  	old_num_tx_queues = adapter->req_tx_queues;
@@@ -2062,25 -1963,53 +2090,50 @@@
  	if (reset_state == VNIC_OPEN &&
  	    adapter->reset_reason != VNIC_RESET_MOBILITY &&
  	    adapter->reset_reason != VNIC_RESET_FAILOVER) {
 -		if (adapter->reset_reason == VNIC_RESET_CHANGE_PARAM) {
 -			rc = __ibmvnic_close(netdev);
 -			if (rc)
 -				goto out;
 -		} else {
 -			adapter->state = VNIC_CLOSING;
 +		adapter->state = VNIC_CLOSING;
  
 -			/* Release the RTNL lock before link state change and
 -			 * re-acquire after the link state change to allow
 -			 * linkwatch_event to grab the RTNL lock and run during
 -			 * a reset.
 -			 */
 -			rtnl_unlock();
 -			rc = set_link_state(adapter, IBMVNIC_LOGICAL_LNK_DN);
 -			rtnl_lock();
 -			if (rc)
 -				goto out;
 +		/* Release the RTNL lock before link state change and
 +		 * re-acquire after the link state change to allow
 +		 * linkwatch_event to grab the RTNL lock and run during
 +		 * a reset.
 +		 */
 +		rtnl_unlock();
 +		rc = set_link_state(adapter, IBMVNIC_LOGICAL_LNK_DN);
 +		rtnl_lock();
 +		if (rc)
 +			goto out;
  
++<<<<<<< HEAD
 +		if (adapter->state != VNIC_CLOSING) {
 +			rc = -1;
 +			goto out;
++=======
+ 			if (adapter->state == VNIC_OPEN) {
+ 				/* When we dropped rtnl, ibmvnic_open() got
+ 				 * it and noticed that we are resetting and
+ 				 * set the adapter state to OPEN. Update our
+ 				 * new "target" state, and resume the reset
+ 				 * from VNIC_CLOSING state.
+ 				 */
+ 				netdev_dbg(netdev,
+ 					   "Open changed state from %d, updating.\n",
+ 					   reset_state);
+ 				reset_state = VNIC_OPEN;
+ 				adapter->state = VNIC_CLOSING;
+ 			}
+ 
+ 			if (adapter->state != VNIC_CLOSING) {
+ 				/* If someone else changed the adapter state
+ 				 * when we dropped the rtnl, fail the reset
+ 				 */
+ 				rc = -1;
+ 				goto out;
+ 			}
+ 			adapter->state = VNIC_CLOSED;
++>>>>>>> 8f1c0fd2c84c (ibmvnic: fix a race between open and reset)
  		}
 -	}
  
 -	if (adapter->reset_reason == VNIC_RESET_CHANGE_PARAM) {
 -		release_resources(adapter);
 -		release_sub_crqs(adapter, 1);
 -		release_crq_queue(adapter);
 +		adapter->state = VNIC_CLOSED;
  	}
  
  	if (adapter->reset_reason != VNIC_RESET_NON_FATAL) {
* Unmerged path drivers/net/ethernet/ibm/ibmvnic.c
