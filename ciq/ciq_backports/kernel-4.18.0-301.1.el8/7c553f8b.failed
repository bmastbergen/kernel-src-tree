drm/dp: Revert "drm/dp: Introduce EDID-based quirks"

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-301.1.el8
commit-author Lyude Paul <lyude@redhat.com>
commit 7c553f8b5a7dcf45f7a06da23b45e431aafbbdba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-301.1.el8/7c553f8b.failed

This reverts commit 0883ce8146ed6074c76399f4e70dbed788582e12. Originally
these quirks were added because of the issues with using the eDP
backlight interfaces on certain laptop panels, which made it impossible
to properly probe for DPCD backlight support without having a whitelist
for panels that we know have working VESA backlight control interfaces
over DPCD. As well, it should be noted it was impossible to use the
normal sink OUI for recognizing these panels as none of them actually
filled out their OUIs, hence needing to resort to checking EDIDs.

At the time we weren't really sure why certain panels had issues with
DPCD backlight controls, but we eventually figured out that there was a
second interface that these problematic laptop panels actually did work
with and advertise properly: Intel's proprietary backlight interface for
HDR panels. So far the testing we've done hasn't brought any panels to
light that advertise this interface and don't support it properly, which
means we finally have a real solution to this problem.

As a result, we now have no need for the force DPCD backlight quirk, and
furthermore this also removes the need for any kind of EDID quirk
checking in DRM. So, let's just revert it for now since we were the only
driver using this.

v3:
* Rebase
v2:
* Fix indenting error picked up by checkpatch in
  intel_edp_init_connector()

	Signed-off-by: Lyude Paul <lyude@redhat.com>
	Acked-by: Jani Nikula <jani.nikula@intel.com>
	Cc: thaytan@noraisin.net
	Cc: Vasily Khoruzhick <anarsoul@gmail.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210114221709.2261452-6-lyude@redhat.com
(cherry picked from commit 7c553f8b5a7dcf45f7a06da23b45e431aafbbdba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/drm_dp_helper.c
#	drivers/gpu/drm/i915/display/intel_dp.c
diff --cc drivers/gpu/drm/drm_dp_helper.c
index 092c8c985911,19dbdeb581cb..000000000000
--- a/drivers/gpu/drm/drm_dp_helper.c
+++ b/drivers/gpu/drm/drm_dp_helper.c
@@@ -597,6 -1140,130 +597,133 @@@ void drm_dp_downstream_debug(struct seq
  }
  EXPORT_SYMBOL(drm_dp_downstream_debug);
  
++<<<<<<< HEAD
++=======
+ /**
+  * drm_dp_subconnector_type() - get DP branch device type
+  * @dpcd: DisplayPort configuration data
+  * @port_cap: port capabilities
+  */
+ enum drm_mode_subconnector
+ drm_dp_subconnector_type(const u8 dpcd[DP_RECEIVER_CAP_SIZE],
+ 			 const u8 port_cap[4])
+ {
+ 	int type;
+ 	if (!drm_dp_is_branch(dpcd))
+ 		return DRM_MODE_SUBCONNECTOR_Native;
+ 	/* DP 1.0 approach */
+ 	if (dpcd[DP_DPCD_REV] == DP_DPCD_REV_10) {
+ 		type = dpcd[DP_DOWNSTREAMPORT_PRESENT] &
+ 		       DP_DWN_STRM_PORT_TYPE_MASK;
+ 
+ 		switch (type) {
+ 		case DP_DWN_STRM_PORT_TYPE_TMDS:
+ 			/* Can be HDMI or DVI-D, DVI-D is a safer option */
+ 			return DRM_MODE_SUBCONNECTOR_DVID;
+ 		case DP_DWN_STRM_PORT_TYPE_ANALOG:
+ 			/* Can be VGA or DVI-A, VGA is more popular */
+ 			return DRM_MODE_SUBCONNECTOR_VGA;
+ 		case DP_DWN_STRM_PORT_TYPE_DP:
+ 			return DRM_MODE_SUBCONNECTOR_DisplayPort;
+ 		case DP_DWN_STRM_PORT_TYPE_OTHER:
+ 		default:
+ 			return DRM_MODE_SUBCONNECTOR_Unknown;
+ 		}
+ 	}
+ 	type = port_cap[0] & DP_DS_PORT_TYPE_MASK;
+ 
+ 	switch (type) {
+ 	case DP_DS_PORT_TYPE_DP:
+ 	case DP_DS_PORT_TYPE_DP_DUALMODE:
+ 		return DRM_MODE_SUBCONNECTOR_DisplayPort;
+ 	case DP_DS_PORT_TYPE_VGA:
+ 		return DRM_MODE_SUBCONNECTOR_VGA;
+ 	case DP_DS_PORT_TYPE_DVI:
+ 		return DRM_MODE_SUBCONNECTOR_DVID;
+ 	case DP_DS_PORT_TYPE_HDMI:
+ 		return DRM_MODE_SUBCONNECTOR_HDMIA;
+ 	case DP_DS_PORT_TYPE_WIRELESS:
+ 		return DRM_MODE_SUBCONNECTOR_Wireless;
+ 	case DP_DS_PORT_TYPE_NON_EDID:
+ 	default:
+ 		return DRM_MODE_SUBCONNECTOR_Unknown;
+ 	}
+ }
+ EXPORT_SYMBOL(drm_dp_subconnector_type);
+ 
+ /**
+  * drm_dp_set_subconnector_property - set subconnector for DP connector
+  * @connector: connector to set property on
+  * @status: connector status
+  * @dpcd: DisplayPort configuration data
+  * @port_cap: port capabilities
+  *
+  * Called by a driver on every detect event.
+  */
+ void drm_dp_set_subconnector_property(struct drm_connector *connector,
+ 				      enum drm_connector_status status,
+ 				      const u8 *dpcd,
+ 				      const u8 port_cap[4])
+ {
+ 	enum drm_mode_subconnector subconnector = DRM_MODE_SUBCONNECTOR_Unknown;
+ 
+ 	if (status == connector_status_connected)
+ 		subconnector = drm_dp_subconnector_type(dpcd, port_cap);
+ 	drm_object_property_set_value(&connector->base,
+ 			connector->dev->mode_config.dp_subconnector_property,
+ 			subconnector);
+ }
+ EXPORT_SYMBOL(drm_dp_set_subconnector_property);
+ 
+ /**
+  * drm_dp_read_sink_count_cap() - Check whether a given connector has a valid sink
+  * count
+  * @connector: The DRM connector to check
+  * @dpcd: A cached copy of the connector's DPCD RX capabilities
+  * @desc: A cached copy of the connector's DP descriptor
+  *
+  * See also: drm_dp_read_sink_count()
+  *
+  * Returns: %True if the (e)DP connector has a valid sink count that should
+  * be probed, %false otherwise.
+  */
+ bool drm_dp_read_sink_count_cap(struct drm_connector *connector,
+ 				const u8 dpcd[DP_RECEIVER_CAP_SIZE],
+ 				const struct drm_dp_desc *desc)
+ {
+ 	/* Some eDP panels don't set a valid value for the sink count */
+ 	return connector->connector_type != DRM_MODE_CONNECTOR_eDP &&
+ 		dpcd[DP_DPCD_REV] >= DP_DPCD_REV_11 &&
+ 		dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DWN_STRM_PORT_PRESENT &&
+ 		!drm_dp_has_quirk(desc, DP_DPCD_QUIRK_NO_SINK_COUNT);
+ }
+ EXPORT_SYMBOL(drm_dp_read_sink_count_cap);
+ 
+ /**
+  * drm_dp_read_sink_count() - Retrieve the sink count for a given sink
+  * @aux: The DP AUX channel to use
+  *
+  * See also: drm_dp_read_sink_count_cap()
+  *
+  * Returns: The current sink count reported by @aux, or a negative error code
+  * otherwise.
+  */
+ int drm_dp_read_sink_count(struct drm_dp_aux *aux)
+ {
+ 	u8 count;
+ 	int ret;
+ 
+ 	ret = drm_dp_dpcd_readb(aux, DP_SINK_COUNT, &count);
+ 	if (ret < 0)
+ 		return ret;
+ 	if (ret != 1)
+ 		return -EIO;
+ 
+ 	return DP_GET_SINK_COUNT(count);
+ }
+ EXPORT_SYMBOL(drm_dp_read_sink_count);
+ 
++>>>>>>> 7c553f8b5a7d (drm/dp: Revert "drm/dp: Introduce EDID-based quirks")
  /*
   * I2C-over-AUX implementation
   */
@@@ -1290,86 -1957,6 +1417,89 @@@ drm_dp_get_quirks(const struct drm_dp_d
  #undef DEVICE_ID_ANY
  #undef DEVICE_ID
  
++<<<<<<< HEAD
 +struct edid_quirk {
 +	u8 mfg_id[2];
 +	u8 prod_id[2];
 +	u32 quirks;
 +};
 +
 +#define MFG(first, second) { (first), (second) }
 +#define PROD_ID(first, second) { (first), (second) }
 +
 +/*
 + * Some devices have unreliable OUIDs where they don't set the device ID
 + * correctly, and as a result we need to use the EDID for finding additional
 + * DP quirks in such cases.
 + */
 +static const struct edid_quirk edid_quirk_list[] = {
 +	/* Optional 4K AMOLED panel in the ThinkPad X1 Extreme 2nd Generation
 +	 * only supports DPCD backlight controls
 +	 */
 +	{ MFG(0x4c, 0x83), PROD_ID(0x41, 0x41), BIT(DP_QUIRK_FORCE_DPCD_BACKLIGHT) },
 +	/*
 +	 * Some Dell CML 2020 systems have panels support both AUX and PWM
 +	 * backlight control, and some only support AUX backlight control. All
 +	 * said panels start up in AUX mode by default, and we don't have any
 +	 * support for disabling HDR mode on these panels which would be
 +	 * required to switch to PWM backlight control mode (plus, I'm not
 +	 * even sure we want PWM backlight controls over DPCD backlight
 +	 * controls anyway...). Until we have a better way of detecting these,
 +	 * force DPCD backlight mode on all of them.
 +	 */
 +	{ MFG(0x06, 0xaf), PROD_ID(0x9b, 0x32), BIT(DP_QUIRK_FORCE_DPCD_BACKLIGHT) },
 +	{ MFG(0x06, 0xaf), PROD_ID(0xeb, 0x41), BIT(DP_QUIRK_FORCE_DPCD_BACKLIGHT) },
 +	{ MFG(0x4d, 0x10), PROD_ID(0xc7, 0x14), BIT(DP_QUIRK_FORCE_DPCD_BACKLIGHT) },
 +	{ MFG(0x4d, 0x10), PROD_ID(0xe6, 0x14), BIT(DP_QUIRK_FORCE_DPCD_BACKLIGHT) },
 +	{ MFG(0x4c, 0x83), PROD_ID(0x47, 0x41), BIT(DP_QUIRK_FORCE_DPCD_BACKLIGHT) },
 +};
 +
 +#undef MFG
 +#undef PROD_ID
 +
 +/**
 + * drm_dp_get_edid_quirks() - Check the EDID of a DP device to find additional
 + * DP-specific quirks
 + * @edid: The EDID to check
 + *
 + * While OUIDs are meant to be used to recognize a DisplayPort device, a lot
 + * of manufacturers don't seem to like following standards and neglect to fill
 + * the dev-ID in, making it impossible to only use OUIDs for determining
 + * quirks in some cases. This function can be used to check the EDID and look
 + * up any additional DP quirks. The bits returned by this function correspond
 + * to the quirk bits in &drm_dp_quirk.
 + *
 + * Returns: a bitmask of quirks, if any. The driver can check this using
 + * drm_dp_has_quirk().
 + */
 +u32 drm_dp_get_edid_quirks(const struct edid *edid)
 +{
 +	const struct edid_quirk *quirk;
 +	u32 quirks = 0;
 +	int i;
 +
 +	if (!edid)
 +		return 0;
 +
 +	for (i = 0; i < ARRAY_SIZE(edid_quirk_list); i++) {
 +		quirk = &edid_quirk_list[i];
 +		if (memcmp(quirk->mfg_id, edid->mfg_id,
 +			   sizeof(edid->mfg_id)) == 0 &&
 +		    memcmp(quirk->prod_id, edid->prod_code,
 +			   sizeof(edid->prod_code)) == 0)
 +			quirks |= quirk->quirks;
 +	}
 +
 +	DRM_DEBUG_KMS("DP sink: EDID mfg %*phD prod-ID %*phD quirks: 0x%04x\n",
 +		      (int)sizeof(edid->mfg_id), edid->mfg_id,
 +		      (int)sizeof(edid->prod_code), edid->prod_code, quirks);
 +
 +	return quirks;
 +}
 +EXPORT_SYMBOL(drm_dp_get_edid_quirks);
 +
++=======
++>>>>>>> 7c553f8b5a7d (drm/dp: Revert "drm/dp: Introduce EDID-based quirks")
  /**
   * drm_dp_read_desc - read sink/branch descriptor from DPCD
   * @aux: DisplayPort AUX channel
diff --cc drivers/gpu/drm/i915/display/intel_dp.c
index d6295eb20b63,8b9c20555f0e..000000000000
--- a/drivers/gpu/drm/i915/display/intel_dp.c
+++ b/drivers/gpu/drm/i915/display/intel_dp.c
@@@ -162,9 -160,9 +162,8 @@@ static void intel_dp_set_sink_rates(str
  		162000, 270000, 540000, 810000
  	};
  	int i, max_rate;
 -	int max_lttpr_rate;
  
- 	if (drm_dp_has_quirk(&intel_dp->desc, 0,
- 			     DP_DPCD_QUIRK_CAN_DO_MAX_LINK_RATE_3_24_GBPS)) {
+ 	if (drm_dp_has_quirk(&intel_dp->desc, DP_DPCD_QUIRK_CAN_DO_MAX_LINK_RATE_3_24_GBPS)) {
  		/* Needed, e.g., for Apple MBP 2017, 15 inch eDP Retina panel */
  		static const int quirk_rates[] = { 162000, 270000, 324000 };
  
@@@ -5493,1537 -5101,1244 +5491,1549 @@@ void intel_dp_process_phy_request(struc
  	}
  
  	/* retrieve vswing & pre-emphasis setting */
 -	intel_dp_get_adjust_train(intel_dp, crtc_state, DP_PHY_DPRX,
 -				  link_status);
 +	intel_dp_get_adjust_train(intel_dp, link_status);
 +
 +	intel_dp_autotest_phy_ddi_disable(intel_dp);
 +
 +	intel_dp_set_signal_levels(intel_dp);
 +
 +	intel_dp_phy_pattern_update(intel_dp);
 +
 +	intel_dp_autotest_phy_ddi_enable(intel_dp, data->num_lanes);
 +
 +	drm_dp_set_phy_test_pattern(&intel_dp->aux, data,
 +				    link_status[DP_DPCD_REV]);
 +}
 +
 +static u8 intel_dp_autotest_phy_pattern(struct intel_dp *intel_dp)
 +{
 +	u8 test_result;
 +
 +	test_result = intel_dp_prepare_phytest(intel_dp);
 +	if (test_result != DP_TEST_ACK)
 +		DRM_ERROR("Phy test preparation failed\n");
 +
 +	intel_dp_process_phy_request(intel_dp);
 +
 +	return test_result;
 +}
 +
 +static void intel_dp_handle_test_request(struct intel_dp *intel_dp)
 +{
 +	struct drm_i915_private *i915 = dp_to_i915(intel_dp);
 +	u8 response = DP_TEST_NAK;
 +	u8 request = 0;
 +	int status;
 +
 +	status = drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_REQUEST, &request);
 +	if (status <= 0) {
 +		drm_dbg_kms(&i915->drm,
 +			    "Could not read test request from sink\n");
 +		goto update_status;
 +	}
 +
 +	switch (request) {
 +	case DP_TEST_LINK_TRAINING:
 +		drm_dbg_kms(&i915->drm, "LINK_TRAINING test requested\n");
 +		response = intel_dp_autotest_link_training(intel_dp);
 +		break;
 +	case DP_TEST_LINK_VIDEO_PATTERN:
 +		drm_dbg_kms(&i915->drm, "TEST_PATTERN test requested\n");
 +		response = intel_dp_autotest_video_pattern(intel_dp);
 +		break;
 +	case DP_TEST_LINK_EDID_READ:
 +		drm_dbg_kms(&i915->drm, "EDID test requested\n");
 +		response = intel_dp_autotest_edid(intel_dp);
 +		break;
 +	case DP_TEST_LINK_PHY_TEST_PATTERN:
 +		drm_dbg_kms(&i915->drm, "PHY_PATTERN test requested\n");
 +		response = intel_dp_autotest_phy_pattern(intel_dp);
 +		break;
 +	default:
 +		drm_dbg_kms(&i915->drm, "Invalid test request '%02x'\n",
 +			    request);
 +		break;
 +	}
 +
 +	if (response & DP_TEST_ACK)
 +		intel_dp->compliance.test_type = request;
 +
 +update_status:
 +	status = drm_dp_dpcd_writeb(&intel_dp->aux, DP_TEST_RESPONSE, response);
 +	if (status <= 0)
 +		drm_dbg_kms(&i915->drm,
 +			    "Could not write test response to sink\n");
 +}
 +
 +/**
 + * intel_dp_check_mst_status - service any pending MST interrupts, check link status
 + * @intel_dp: Intel DP struct
 + *
 + * Read any pending MST interrupts, call MST core to handle these and ack the
 + * interrupts. Check if the main and AUX link state is ok.
 + *
 + * Returns:
 + * - %true if pending interrupts were serviced (or no interrupts were
 + *   pending) w/o detecting an error condition.
 + * - %false if an error condition - like AUX failure or a loss of link - is
 + *   detected, which needs servicing from the hotplug work.
 + */
 +static bool
 +intel_dp_check_mst_status(struct intel_dp *intel_dp)
 +{
 +	struct drm_i915_private *i915 = dp_to_i915(intel_dp);
 +	bool link_ok = true;
 +
 +	drm_WARN_ON_ONCE(&i915->drm, intel_dp->active_mst_links < 0);
 +
 +	for (;;) {
 +		u8 esi[DP_DPRX_ESI_LEN] = {};
 +		bool handled;
 +		int retry;
 +
 +		if (!intel_dp_get_sink_irq_esi(intel_dp, esi)) {
 +			drm_dbg_kms(&i915->drm,
 +				    "failed to get ESI - device may have failed\n");
 +			link_ok = false;
 +
 +			break;
 +		}
 +
 +		/* check link status - esi[10] = 0x200c */
 +		if (intel_dp->active_mst_links > 0 && link_ok &&
 +		    !drm_dp_channel_eq_ok(&esi[10], intel_dp->lane_count)) {
 +			drm_dbg_kms(&i915->drm,
 +				    "channel EQ not ok, retraining\n");
 +			link_ok = false;
 +		}
 +
 +		drm_dbg_kms(&i915->drm, "got esi %3ph\n", esi);
 +
 +		drm_dp_mst_hpd_irq(&intel_dp->mst_mgr, esi, &handled);
 +		if (!handled)
 +			break;
 +
 +		for (retry = 0; retry < 3; retry++) {
 +			int wret;
 +
 +			wret = drm_dp_dpcd_write(&intel_dp->aux,
 +						 DP_SINK_COUNT_ESI+1,
 +						 &esi[1], 3);
 +			if (wret == 3)
 +				break;
 +		}
 +	}
 +
 +	return link_ok;
 +}
 +
 +static bool
 +intel_dp_needs_link_retrain(struct intel_dp *intel_dp)
 +{
 +	u8 link_status[DP_LINK_STATUS_SIZE];
 +
 +	if (!intel_dp->link_trained)
 +		return false;
 +
 +	/*
 +	 * While PSR source HW is enabled, it will control main-link sending
 +	 * frames, enabling and disabling it so trying to do a retrain will fail
 +	 * as the link would or not be on or it could mix training patterns
 +	 * and frame data at the same time causing retrain to fail.
 +	 * Also when exiting PSR, HW will retrain the link anyways fixing
 +	 * any link status error.
 +	 */
 +	if (intel_psr_enabled(intel_dp))
 +		return false;
 +
 +	if (!intel_dp_get_link_status(intel_dp, link_status))
 +		return false;
 +
 +	/*
 +	 * Validate the cached values of intel_dp->link_rate and
 +	 * intel_dp->lane_count before attempting to retrain.
 +	 */
 +	if (!intel_dp_link_params_valid(intel_dp, intel_dp->link_rate,
 +					intel_dp->lane_count))
 +		return false;
 +
 +	/* Retrain if Channel EQ or CR not ok */
 +	return !drm_dp_channel_eq_ok(link_status, intel_dp->lane_count);
 +}
 +
 +static bool intel_dp_has_connector(struct intel_dp *intel_dp,
 +				   const struct drm_connector_state *conn_state)
 +{
 +	struct drm_i915_private *i915 = dp_to_i915(intel_dp);
 +	struct intel_encoder *encoder;
 +	enum pipe pipe;
 +
 +	if (!conn_state->best_encoder)
 +		return false;
 +
 +	/* SST */
 +	encoder = &dp_to_dig_port(intel_dp)->base;
 +	if (conn_state->best_encoder == &encoder->base)
 +		return true;
 +
 +	/* MST */
 +	for_each_pipe(i915, pipe) {
 +		encoder = &intel_dp->mst_encoders[pipe]->base;
 +		if (conn_state->best_encoder == &encoder->base)
 +			return true;
 +	}
 +
 +	return false;
 +}
 +
 +static int intel_dp_prep_link_retrain(struct intel_dp *intel_dp,
 +				      struct drm_modeset_acquire_ctx *ctx,
 +				      u32 *crtc_mask)
 +{
 +	struct drm_i915_private *i915 = dp_to_i915(intel_dp);
 +	struct drm_connector_list_iter conn_iter;
 +	struct intel_connector *connector;
 +	int ret = 0;
 +
 +	*crtc_mask = 0;
 +
 +	if (!intel_dp_needs_link_retrain(intel_dp))
 +		return 0;
 +
 +	drm_connector_list_iter_begin(&i915->drm, &conn_iter);
 +	for_each_intel_connector_iter(connector, &conn_iter) {
 +		struct drm_connector_state *conn_state =
 +			connector->base.state;
 +		struct intel_crtc_state *crtc_state;
 +		struct intel_crtc *crtc;
 +
 +		if (!intel_dp_has_connector(intel_dp, conn_state))
 +			continue;
 +
 +		crtc = to_intel_crtc(conn_state->crtc);
 +		if (!crtc)
 +			continue;
 +
 +		ret = drm_modeset_lock(&crtc->base.mutex, ctx);
 +		if (ret)
 +			break;
 +
 +		crtc_state = to_intel_crtc_state(crtc->base.state);
 +
 +		drm_WARN_ON(&i915->drm, !intel_crtc_has_dp_encoder(crtc_state));
 +
 +		if (!crtc_state->hw.active)
 +			continue;
 +
 +		if (conn_state->commit &&
 +		    !try_wait_for_completion(&conn_state->commit->hw_done))
 +			continue;
  
 -	intel_dp_autotest_phy_ddi_disable(intel_dp, crtc_state);
 +		*crtc_mask |= drm_crtc_mask(&crtc->base);
 +	}
 +	drm_connector_list_iter_end(&conn_iter);
  
 -	intel_dp_set_signal_levels(intel_dp, crtc_state, DP_PHY_DPRX);
 +	if (!intel_dp_needs_link_retrain(intel_dp))
 +		*crtc_mask = 0;
  
 -	intel_dp_phy_pattern_update(intel_dp, crtc_state);
 +	return ret;
 +}
  
 -	intel_dp_autotest_phy_ddi_enable(intel_dp, crtc_state);
 +static bool intel_dp_is_connected(struct intel_dp *intel_dp)
 +{
 +	struct intel_connector *connector = intel_dp->attached_connector;
  
 -	drm_dp_set_phy_test_pattern(&intel_dp->aux, data,
 -				    link_status[DP_DPCD_REV]);
 +	return connector->base.status == connector_status_connected ||
 +		intel_dp->is_mst;
  }
  
 -static u8 intel_dp_autotest_phy_pattern(struct intel_dp *intel_dp)
 +int intel_dp_retrain_link(struct intel_encoder *encoder,
 +			  struct drm_modeset_acquire_ctx *ctx)
  {
 -	struct drm_dp_phy_test_params *data =
 -		&intel_dp->compliance.test_data.phytest;
 +	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 +	struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
 +	struct intel_crtc *crtc;
 +	u32 crtc_mask;
 +	int ret;
  
 -	if (drm_dp_get_phy_test_pattern(&intel_dp->aux, data)) {
 -		DRM_DEBUG_KMS("DP Phy Test pattern AUX read failure\n");
 -		return DP_TEST_NAK;
 -	}
 +	if (!intel_dp_is_connected(intel_dp))
 +		return 0;
  
 -	/* Set test active flag here so userspace doesn't interrupt things */
 -	intel_dp->compliance.test_active = true;
 +	ret = drm_modeset_lock(&dev_priv->drm.mode_config.connection_mutex,
 +			       ctx);
 +	if (ret)
 +		return ret;
  
 -	return DP_TEST_ACK;
 -}
 +	ret = intel_dp_prep_link_retrain(intel_dp, ctx, &crtc_mask);
 +	if (ret)
 +		return ret;
  
 -static void intel_dp_handle_test_request(struct intel_dp *intel_dp)
 -{
 -	struct drm_i915_private *i915 = dp_to_i915(intel_dp);
 -	u8 response = DP_TEST_NAK;
 -	u8 request = 0;
 -	int status;
 +	if (crtc_mask == 0)
 +		return 0;
  
 -	status = drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_REQUEST, &request);
 -	if (status <= 0) {
 -		drm_dbg_kms(&i915->drm,
 -			    "Could not read test request from sink\n");
 -		goto update_status;
 -	}
 +	drm_dbg_kms(&dev_priv->drm, "[ENCODER:%d:%s] retraining link\n",
 +		    encoder->base.base.id, encoder->base.name);
  
 -	switch (request) {
 -	case DP_TEST_LINK_TRAINING:
 -		drm_dbg_kms(&i915->drm, "LINK_TRAINING test requested\n");
 -		response = intel_dp_autotest_link_training(intel_dp);
 -		break;
 -	case DP_TEST_LINK_VIDEO_PATTERN:
 -		drm_dbg_kms(&i915->drm, "TEST_PATTERN test requested\n");
 -		response = intel_dp_autotest_video_pattern(intel_dp);
 -		break;
 -	case DP_TEST_LINK_EDID_READ:
 -		drm_dbg_kms(&i915->drm, "EDID test requested\n");
 -		response = intel_dp_autotest_edid(intel_dp);
 -		break;
 -	case DP_TEST_LINK_PHY_TEST_PATTERN:
 -		drm_dbg_kms(&i915->drm, "PHY_PATTERN test requested\n");
 -		response = intel_dp_autotest_phy_pattern(intel_dp);
 -		break;
 -	default:
 -		drm_dbg_kms(&i915->drm, "Invalid test request '%02x'\n",
 -			    request);
 -		break;
 +	for_each_intel_crtc_mask(&dev_priv->drm, crtc, crtc_mask) {
 +		const struct intel_crtc_state *crtc_state =
 +			to_intel_crtc_state(crtc->base.state);
 +
 +		/* Suppress underruns caused by re-training */
 +		intel_set_cpu_fifo_underrun_reporting(dev_priv, crtc->pipe, false);
 +		if (crtc_state->has_pch_encoder)
 +			intel_set_pch_fifo_underrun_reporting(dev_priv,
 +							      intel_crtc_pch_transcoder(crtc), false);
  	}
  
 -	if (response & DP_TEST_ACK)
 -		intel_dp->compliance.test_type = request;
 +	intel_dp_start_link_train(intel_dp);
 +	intel_dp_stop_link_train(intel_dp);
  
 -update_status:
 -	status = drm_dp_dpcd_writeb(&intel_dp->aux, DP_TEST_RESPONSE, response);
 -	if (status <= 0)
 -		drm_dbg_kms(&i915->drm,
 -			    "Could not write test response to sink\n");
 -}
 +	for_each_intel_crtc_mask(&dev_priv->drm, crtc, crtc_mask) {
 +		const struct intel_crtc_state *crtc_state =
 +			to_intel_crtc_state(crtc->base.state);
  
 -static void
 -intel_dp_mst_hpd_irq(struct intel_dp *intel_dp, u8 *esi, bool *handled)
 -{
 -		drm_dp_mst_hpd_irq(&intel_dp->mst_mgr, esi, handled);
 +		/* Keep underrun reporting disabled until things are stable */
 +		intel_wait_for_vblank(dev_priv, crtc->pipe);
  
 -		if (esi[1] & DP_CP_IRQ) {
 -			intel_hdcp_handle_cp_irq(intel_dp->attached_connector);
 -			*handled = true;
 -		}
 +		intel_set_cpu_fifo_underrun_reporting(dev_priv, crtc->pipe, true);
 +		if (crtc_state->has_pch_encoder)
 +			intel_set_pch_fifo_underrun_reporting(dev_priv,
 +							      intel_crtc_pch_transcoder(crtc), true);
 +	}
 +
 +	return 0;
  }
  
 -/**
 - * intel_dp_check_mst_status - service any pending MST interrupts, check link status
 - * @intel_dp: Intel DP struct
 - *
 - * Read any pending MST interrupts, call MST core to handle these and ack the
 - * interrupts. Check if the main and AUX link state is ok.
 +/*
 + * If display is now connected check links status,
 + * there has been known issues of link loss triggering
 + * long pulse.
   *
 - * Returns:
 - * - %true if pending interrupts were serviced (or no interrupts were
 - *   pending) w/o detecting an error condition.
 - * - %false if an error condition - like AUX failure or a loss of link - is
 - *   detected, which needs servicing from the hotplug work.
 + * Some sinks (eg. ASUS PB287Q) seem to perform some
 + * weird HPD ping pong during modesets. So we can apparently
 + * end up with HPD going low during a modeset, and then
 + * going back up soon after. And once that happens we must
 + * retrain the link to get a picture. That's in case no
 + * userspace component reacted to intermittent HPD dip.
   */
 -static bool
 -intel_dp_check_mst_status(struct intel_dp *intel_dp)
 +static enum intel_hotplug_state
 +intel_dp_hotplug(struct intel_encoder *encoder,
 +		 struct intel_connector *connector)
  {
 -	struct drm_i915_private *i915 = dp_to_i915(intel_dp);
 -	bool link_ok = true;
 -
 -	drm_WARN_ON_ONCE(&i915->drm, intel_dp->active_mst_links < 0);
 +	struct drm_modeset_acquire_ctx ctx;
 +	enum intel_hotplug_state state;
 +	int ret;
  
 -	for (;;) {
 -		u8 esi[DP_DPRX_ESI_LEN] = {};
 -		bool handled;
 -		int retry;
 +	state = intel_encoder_hotplug(encoder, connector);
  
 -		if (!intel_dp_get_sink_irq_esi(intel_dp, esi)) {
 -			drm_dbg_kms(&i915->drm,
 -				    "failed to get ESI - device may have failed\n");
 -			link_ok = false;
 +	drm_modeset_acquire_init(&ctx, 0);
  
 -			break;
 -		}
 +	for (;;) {
 +		ret = intel_dp_retrain_link(encoder, &ctx);
  
 -		/* check link status - esi[10] = 0x200c */
 -		if (intel_dp->active_mst_links > 0 && link_ok &&
 -		    !drm_dp_channel_eq_ok(&esi[10], intel_dp->lane_count)) {
 -			drm_dbg_kms(&i915->drm,
 -				    "channel EQ not ok, retraining\n");
 -			link_ok = false;
 +		if (ret == -EDEADLK) {
 +			drm_modeset_backoff(&ctx);
 +			continue;
  		}
  
 -		drm_dbg_kms(&i915->drm, "got esi %3ph\n", esi);
 -
 -		intel_dp_mst_hpd_irq(intel_dp, esi, &handled);
 -
 -		if (!handled)
 -			break;
 +		break;
 +	}
  
 -		for (retry = 0; retry < 3; retry++) {
 -			int wret;
 +	drm_modeset_drop_locks(&ctx);
 +	drm_modeset_acquire_fini(&ctx);
 +	drm_WARN(encoder->base.dev, ret,
 +		 "Acquiring modeset locks failed with %i\n", ret);
  
 -			wret = drm_dp_dpcd_write(&intel_dp->aux,
 -						 DP_SINK_COUNT_ESI+1,
 -						 &esi[1], 3);
 -			if (wret == 3)
 -				break;
 -		}
 -	}
 +	/*
 +	 * Keeping it consistent with intel_ddi_hotplug() and
 +	 * intel_hdmi_hotplug().
 +	 */
 +	if (state == INTEL_HOTPLUG_UNCHANGED && !connector->hotplug_retries)
 +		state = INTEL_HOTPLUG_RETRY;
  
 -	return link_ok;
 +	return state;
  }
  
 -static void
 -intel_dp_handle_hdmi_link_status_change(struct intel_dp *intel_dp)
 +static void intel_dp_check_service_irq(struct intel_dp *intel_dp)
  {
 -	bool is_active;
 -	u8 buf = 0;
 +	struct drm_i915_private *i915 = dp_to_i915(intel_dp);
 +	u8 val;
  
 -	is_active = drm_dp_pcon_hdmi_link_active(&intel_dp->aux);
 -	if (intel_dp->frl.is_trained && !is_active) {
 -		if (drm_dp_dpcd_readb(&intel_dp->aux, DP_PCON_HDMI_LINK_CONFIG_1, &buf) < 0)
 -			return;
 +	if (intel_dp->dpcd[DP_DPCD_REV] < 0x11)
 +		return;
  
 -		buf &=  ~DP_PCON_ENABLE_HDMI_LINK;
 -		if (drm_dp_dpcd_writeb(&intel_dp->aux, DP_PCON_HDMI_LINK_CONFIG_1, buf) < 0)
 -			return;
 +	if (drm_dp_dpcd_readb(&intel_dp->aux,
 +			      DP_DEVICE_SERVICE_IRQ_VECTOR, &val) != 1 || !val)
 +		return;
  
 -		drm_dp_pcon_hdmi_frl_link_error_count(&intel_dp->aux, &intel_dp->attached_connector->base);
 +	drm_dp_dpcd_writeb(&intel_dp->aux, DP_DEVICE_SERVICE_IRQ_VECTOR, val);
  
 -		/* Restart FRL training or fall back to TMDS mode */
 -		intel_dp_check_frl_training(intel_dp);
 -	}
 +	if (val & DP_AUTOMATED_TEST_REQUEST)
 +		intel_dp_handle_test_request(intel_dp);
 +
 +	if (val & DP_CP_IRQ)
 +		intel_hdcp_handle_cp_irq(intel_dp->attached_connector);
 +
 +	if (val & DP_SINK_SPECIFIC_IRQ)
 +		drm_dbg_kms(&i915->drm, "Sink specific irq unhandled\n");
  }
  
 +/*
 + * According to DP spec
 + * 5.1.2:
 + *  1. Read DPCD
 + *  2. Configure link according to Receiver Capabilities
 + *  3. Use Link Training from 2.5.3.3 and 3.5.1.3
 + *  4. Check link status on receipt of hot-plug interrupt
 + *
 + * intel_dp_short_pulse -  handles short pulse interrupts
 + * when full detection is not required.
 + * Returns %true if short pulse is handled and full detection
 + * is NOT required and %false otherwise.
 + */
  static bool
 -intel_dp_needs_link_retrain(struct intel_dp *intel_dp)
 +intel_dp_short_pulse(struct intel_dp *intel_dp)
  {
 -	u8 link_status[DP_LINK_STATUS_SIZE];
 -
 -	if (!intel_dp->link_trained)
 -		return false;
 +	struct drm_i915_private *dev_priv = dp_to_i915(intel_dp);
 +	u8 old_sink_count = intel_dp->sink_count;
 +	bool ret;
  
  	/*
 -	 * While PSR source HW is enabled, it will control main-link sending
 -	 * frames, enabling and disabling it so trying to do a retrain will fail
 -	 * as the link would or not be on or it could mix training patterns
 -	 * and frame data at the same time causing retrain to fail.
 -	 * Also when exiting PSR, HW will retrain the link anyways fixing
 -	 * any link status error.
 +	 * Clearing compliance test variables to allow capturing
 +	 * of values for next automated test request.
  	 */
 -	if (intel_psr_enabled(intel_dp))
 -		return false;
 -
 -	if (drm_dp_dpcd_read_phy_link_status(&intel_dp->aux, DP_PHY_DPRX,
 -					     link_status) < 0)
 -		return false;
 +	memset(&intel_dp->compliance, 0, sizeof(intel_dp->compliance));
  
  	/*
 -	 * Validate the cached values of intel_dp->link_rate and
 -	 * intel_dp->lane_count before attempting to retrain.
 -	 *
 -	 * FIXME would be nice to user the crtc state here, but since
 -	 * we need to call this from the short HPD handler that seems
 -	 * a bit hard.
 +	 * Now read the DPCD to see if it's actually running
 +	 * If the current value of sink count doesn't match with
 +	 * the value that was stored earlier or dpcd read failed
 +	 * we need to do full detection
  	 */
 -	if (!intel_dp_link_params_valid(intel_dp, intel_dp->link_rate,
 -					intel_dp->lane_count))
 +	ret = intel_dp_get_dpcd(intel_dp);
 +
 +	if ((old_sink_count != intel_dp->sink_count) || !ret) {
 +		/* No need to proceed if we are going to do full detect */
  		return false;
 +	}
  
 -	/* Retrain if Channel EQ or CR not ok */
 -	return !drm_dp_channel_eq_ok(link_status, intel_dp->lane_count);
 -}
 +	intel_dp_check_service_irq(intel_dp);
  
 -static bool intel_dp_has_connector(struct intel_dp *intel_dp,
 -				   const struct drm_connector_state *conn_state)
 -{
 -	struct drm_i915_private *i915 = dp_to_i915(intel_dp);
 -	struct intel_encoder *encoder;
 -	enum pipe pipe;
 +	/* Handle CEC interrupts, if any */
 +	drm_dp_cec_irq(&intel_dp->aux);
  
 -	if (!conn_state->best_encoder)
 +	/* defer to the hotplug work for link retraining if needed */
 +	if (intel_dp_needs_link_retrain(intel_dp))
  		return false;
  
 -	/* SST */
 -	encoder = &dp_to_dig_port(intel_dp)->base;
 -	if (conn_state->best_encoder == &encoder->base)
 -		return true;
 +	intel_psr_short_pulse(intel_dp);
  
 -	/* MST */
 -	for_each_pipe(i915, pipe) {
 -		encoder = &intel_dp->mst_encoders[pipe]->base;
 -		if (conn_state->best_encoder == &encoder->base)
 -			return true;
 +	if (intel_dp->compliance.test_type == DP_TEST_LINK_TRAINING) {
 +		drm_dbg_kms(&dev_priv->drm,
 +			    "Link Training Compliance Test requested\n");
 +		/* Send a Hotplug Uevent to userspace to start modeset */
 +		drm_kms_helper_hotplug_event(&dev_priv->drm);
  	}
  
 -	return false;
 +	return true;
  }
  
 -static int intel_dp_prep_link_retrain(struct intel_dp *intel_dp,
 -				      struct drm_modeset_acquire_ctx *ctx,
 -				      u32 *crtc_mask)
 +/* XXX this is probably wrong for multiple downstream ports */
 +static enum drm_connector_status
 +intel_dp_detect_dpcd(struct intel_dp *intel_dp)
  {
  	struct drm_i915_private *i915 = dp_to_i915(intel_dp);
 -	struct drm_connector_list_iter conn_iter;
 -	struct intel_connector *connector;
 -	int ret = 0;
 -
 -	*crtc_mask = 0;
 -
 -	if (!intel_dp_needs_link_retrain(intel_dp))
 -		return 0;
 +	struct intel_lspcon *lspcon = dp_to_lspcon(intel_dp);
 +	u8 *dpcd = intel_dp->dpcd;
 +	u8 type;
  
 -	drm_connector_list_iter_begin(&i915->drm, &conn_iter);
 -	for_each_intel_connector_iter(connector, &conn_iter) {
 -		struct drm_connector_state *conn_state =
 -			connector->base.state;
 -		struct intel_crtc_state *crtc_state;
 -		struct intel_crtc *crtc;
 +	if (drm_WARN_ON(&i915->drm, intel_dp_is_edp(intel_dp)))
 +		return connector_status_connected;
  
 -		if (!intel_dp_has_connector(intel_dp, conn_state))
 -			continue;
 +	if (lspcon->active)
 +		lspcon_resume(lspcon);
  
 -		crtc = to_intel_crtc(conn_state->crtc);
 -		if (!crtc)
 -			continue;
 +	if (!intel_dp_get_dpcd(intel_dp))
 +		return connector_status_disconnected;
  
 -		ret = drm_modeset_lock(&crtc->base.mutex, ctx);
 -		if (ret)
 -			break;
 +	/* if there's no downstream port, we're done */
 +	if (!drm_dp_is_branch(dpcd))
 +		return connector_status_connected;
  
 -		crtc_state = to_intel_crtc_state(crtc->base.state);
 +	/* If we're HPD-aware, SINK_COUNT changes dynamically */
 +	if (intel_dp->dpcd[DP_DPCD_REV] >= 0x11 &&
 +	    intel_dp->downstream_ports[0] & DP_DS_PORT_HPD) {
  
 -		drm_WARN_ON(&i915->drm, !intel_crtc_has_dp_encoder(crtc_state));
 +		return intel_dp->sink_count ?
 +		connector_status_connected : connector_status_disconnected;
 +	}
  
 -		if (!crtc_state->hw.active)
 -			continue;
 +	if (intel_dp_can_mst(intel_dp))
 +		return connector_status_connected;
  
 -		if (conn_state->commit &&
 -		    !try_wait_for_completion(&conn_state->commit->hw_done))
 -			continue;
 +	/* If no HPD, poke DDC gently */
 +	if (drm_probe_ddc(&intel_dp->aux.ddc))
 +		return connector_status_connected;
  
 -		*crtc_mask |= drm_crtc_mask(&crtc->base);
 +	/* Well we tried, say unknown for unreliable port types */
 +	if (intel_dp->dpcd[DP_DPCD_REV] >= 0x11) {
 +		type = intel_dp->downstream_ports[0] & DP_DS_PORT_TYPE_MASK;
 +		if (type == DP_DS_PORT_TYPE_VGA ||
 +		    type == DP_DS_PORT_TYPE_NON_EDID)
 +			return connector_status_unknown;
 +	} else {
 +		type = intel_dp->dpcd[DP_DOWNSTREAMPORT_PRESENT] &
 +			DP_DWN_STRM_PORT_TYPE_MASK;
 +		if (type == DP_DWN_STRM_PORT_TYPE_ANALOG ||
 +		    type == DP_DWN_STRM_PORT_TYPE_OTHER)
 +			return connector_status_unknown;
  	}
 -	drm_connector_list_iter_end(&conn_iter);
 -
 -	if (!intel_dp_needs_link_retrain(intel_dp))
 -		*crtc_mask = 0;
  
 -	return ret;
 +	/* Anything else is out of spec, warn and ignore */
 +	drm_dbg_kms(&i915->drm, "Broken DP branch device, ignoring\n");
 +	return connector_status_disconnected;
  }
  
 -static bool intel_dp_is_connected(struct intel_dp *intel_dp)
 +static enum drm_connector_status
 +edp_detect(struct intel_dp *intel_dp)
  {
 -	struct intel_connector *connector = intel_dp->attached_connector;
 -
 -	return connector->base.status == connector_status_connected ||
 -		intel_dp->is_mst;
 +	return connector_status_connected;
  }
  
 -int intel_dp_retrain_link(struct intel_encoder *encoder,
 -			  struct drm_modeset_acquire_ctx *ctx)
 +static bool ibx_digital_port_connected(struct intel_encoder *encoder)
  {
  	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 -	struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
 -	struct intel_crtc *crtc;
 -	u32 crtc_mask;
 -	int ret;
 -
 -	if (!intel_dp_is_connected(intel_dp))
 -		return 0;
 -
 -	ret = drm_modeset_lock(&dev_priv->drm.mode_config.connection_mutex,
 -			       ctx);
 -	if (ret)
 -		return ret;
 -
 -	ret = intel_dp_prep_link_retrain(intel_dp, ctx, &crtc_mask);
 -	if (ret)
 -		return ret;
 -
 -	if (crtc_mask == 0)
 -		return 0;
 -
 -	drm_dbg_kms(&dev_priv->drm, "[ENCODER:%d:%s] retraining link\n",
 -		    encoder->base.base.id, encoder->base.name);
 -
 -	for_each_intel_crtc_mask(&dev_priv->drm, crtc, crtc_mask) {
 -		const struct intel_crtc_state *crtc_state =
 -			to_intel_crtc_state(crtc->base.state);
 -
 -		/* Suppress underruns caused by re-training */
 -		intel_set_cpu_fifo_underrun_reporting(dev_priv, crtc->pipe, false);
 -		if (crtc_state->has_pch_encoder)
 -			intel_set_pch_fifo_underrun_reporting(dev_priv,
 -							      intel_crtc_pch_transcoder(crtc), false);
 -	}
 +	u32 bit = dev_priv->hotplug.pch_hpd[encoder->hpd_pin];
  
 -	for_each_intel_crtc_mask(&dev_priv->drm, crtc, crtc_mask) {
 -		const struct intel_crtc_state *crtc_state =
 -			to_intel_crtc_state(crtc->base.state);
 +	return intel_de_read(dev_priv, SDEISR) & bit;
 +}
  
 -		/* retrain on the MST master transcoder */
 -		if (INTEL_GEN(dev_priv) >= 12 &&
 -		    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST) &&
 -		    !intel_dp_mst_is_master_trans(crtc_state))
 -			continue;
 +static bool g4x_digital_port_connected(struct intel_encoder *encoder)
 +{
 +	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 +	u32 bit;
  
 -		intel_dp_check_frl_training(intel_dp);
 -		intel_dp_pcon_dsc_configure(intel_dp, crtc_state);
 -		intel_dp_start_link_train(intel_dp, crtc_state);
 -		intel_dp_stop_link_train(intel_dp, crtc_state);
 +	switch (encoder->hpd_pin) {
 +	case HPD_PORT_B:
 +		bit = PORTB_HOTPLUG_LIVE_STATUS_G4X;
 +		break;
 +	case HPD_PORT_C:
 +		bit = PORTC_HOTPLUG_LIVE_STATUS_G4X;
 +		break;
 +	case HPD_PORT_D:
 +		bit = PORTD_HOTPLUG_LIVE_STATUS_G4X;
  		break;
 +	default:
 +		MISSING_CASE(encoder->hpd_pin);
 +		return false;
  	}
  
 -	for_each_intel_crtc_mask(&dev_priv->drm, crtc, crtc_mask) {
 -		const struct intel_crtc_state *crtc_state =
 -			to_intel_crtc_state(crtc->base.state);
 +	return intel_de_read(dev_priv, PORT_HOTPLUG_STAT) & bit;
 +}
  
 -		/* Keep underrun reporting disabled until things are stable */
 -		intel_wait_for_vblank(dev_priv, crtc->pipe);
 +static bool gm45_digital_port_connected(struct intel_encoder *encoder)
 +{
 +	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 +	u32 bit;
  
 -		intel_set_cpu_fifo_underrun_reporting(dev_priv, crtc->pipe, true);
 -		if (crtc_state->has_pch_encoder)
 -			intel_set_pch_fifo_underrun_reporting(dev_priv,
 -							      intel_crtc_pch_transcoder(crtc), true);
 +	switch (encoder->hpd_pin) {
 +	case HPD_PORT_B:
 +		bit = PORTB_HOTPLUG_LIVE_STATUS_GM45;
 +		break;
 +	case HPD_PORT_C:
 +		bit = PORTC_HOTPLUG_LIVE_STATUS_GM45;
 +		break;
 +	case HPD_PORT_D:
 +		bit = PORTD_HOTPLUG_LIVE_STATUS_GM45;
 +		break;
 +	default:
 +		MISSING_CASE(encoder->hpd_pin);
 +		return false;
  	}
  
 -	return 0;
 +	return intel_de_read(dev_priv, PORT_HOTPLUG_STAT) & bit;
  }
  
 -static int intel_dp_prep_phy_test(struct intel_dp *intel_dp,
 -				  struct drm_modeset_acquire_ctx *ctx,
 -				  u32 *crtc_mask)
 +static bool ilk_digital_port_connected(struct intel_encoder *encoder)
  {
 -	struct drm_i915_private *i915 = dp_to_i915(intel_dp);
 -	struct drm_connector_list_iter conn_iter;
 -	struct intel_connector *connector;
 -	int ret = 0;
 -
 -	*crtc_mask = 0;
 -
 -	drm_connector_list_iter_begin(&i915->drm, &conn_iter);
 -	for_each_intel_connector_iter(connector, &conn_iter) {
 -		struct drm_connector_state *conn_state =
 -			connector->base.state;
 -		struct intel_crtc_state *crtc_state;
 -		struct intel_crtc *crtc;
 -
 -		if (!intel_dp_has_connector(intel_dp, conn_state))
 -			continue;
 -
 -		crtc = to_intel_crtc(conn_state->crtc);
 -		if (!crtc)
 -			continue;
 -
 -		ret = drm_modeset_lock(&crtc->base.mutex, ctx);
 -		if (ret)
 -			break;
 -
 -		crtc_state = to_intel_crtc_state(crtc->base.state);
 -
 -		drm_WARN_ON(&i915->drm, !intel_crtc_has_dp_encoder(crtc_state));
 -
 -		if (!crtc_state->hw.active)
 -			continue;
 -
 -		if (conn_state->commit &&
 -		    !try_wait_for_completion(&conn_state->commit->hw_done))
 -			continue;
 -
 -		*crtc_mask |= drm_crtc_mask(&crtc->base);
 -	}
 -	drm_connector_list_iter_end(&conn_iter);
 +	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 +	u32 bit = dev_priv->hotplug.hpd[encoder->hpd_pin];
  
 -	return ret;
 +	return intel_de_read(dev_priv, DEISR) & bit;
  }
  
 -static int intel_dp_do_phy_test(struct intel_encoder *encoder,
 -				struct drm_modeset_acquire_ctx *ctx)
 +/*
 + * intel_digital_port_connected - is the specified port connected?
 + * @encoder: intel_encoder
 + *
 + * In cases where there's a connector physically connected but it can't be used
 + * by our hardware we also return false, since the rest of the driver should
 + * pretty much treat the port as disconnected. This is relevant for type-C
 + * (starting on ICL) where there's ownership involved.
 + *
 + * Return %true if port is connected, %false otherwise.
 + */
 +bool intel_digital_port_connected(struct intel_encoder *encoder)
  {
  	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 -	struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
 -	struct intel_crtc *crtc;
 -	u32 crtc_mask;
 -	int ret;
 +	struct intel_digital_port *dig_port = enc_to_dig_port(encoder);
 +	bool is_connected = false;
 +	intel_wakeref_t wakeref;
  
 -	ret = drm_modeset_lock(&dev_priv->drm.mode_config.connection_mutex,
 -			       ctx);
 -	if (ret)
 -		return ret;
 +	with_intel_display_power(dev_priv, POWER_DOMAIN_DISPLAY_CORE, wakeref)
 +		is_connected = dig_port->connected(encoder);
  
 -	ret = intel_dp_prep_phy_test(intel_dp, ctx, &crtc_mask);
 -	if (ret)
 -		return ret;
 +	return is_connected;
 +}
  
 -	if (crtc_mask == 0)
 -		return 0;
 +static struct edid *
 +intel_dp_get_edid(struct intel_dp *intel_dp)
 +{
 +	struct intel_connector *intel_connector = intel_dp->attached_connector;
  
 -	drm_dbg_kms(&dev_priv->drm, "[ENCODER:%d:%s] PHY test\n",
 -		    encoder->base.base.id, encoder->base.name);
 +	/* use cached edid if we have one */
 +	if (intel_connector->edid) {
 +		/* invalid edid */
 +		if (IS_ERR(intel_connector->edid))
 +			return NULL;
  
 -	for_each_intel_crtc_mask(&dev_priv->drm, crtc, crtc_mask) {
 -		const struct intel_crtc_state *crtc_state =
 -			to_intel_crtc_state(crtc->base.state);
 +		return drm_edid_duplicate(intel_connector->edid);
 +	} else
 +		return drm_get_edid(&intel_connector->base,
 +				    &intel_dp->aux.ddc);
 +}
  
 -		/* test on the MST master transcoder */
 -		if (INTEL_GEN(dev_priv) >= 12 &&
 -		    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST) &&
 -		    !intel_dp_mst_is_master_trans(crtc_state))
 -			continue;
 +static void
 +intel_dp_set_edid(struct intel_dp *intel_dp)
 +{
 +	struct intel_connector *intel_connector = intel_dp->attached_connector;
 +	struct edid *edid;
  
 -		intel_dp_process_phy_request(intel_dp, crtc_state);
 -		break;
 -	}
 +	intel_dp_unset_edid(intel_dp);
 +	edid = intel_dp_get_edid(intel_dp);
 +	intel_connector->detect_edid = edid;
  
 -	return 0;
 +	intel_dp->has_audio = drm_detect_monitor_audio(edid);
 +	drm_dp_cec_set_edid(&intel_dp->aux, edid);
- 	intel_dp->edid_quirks = drm_dp_get_edid_quirks(edid);
  }
  
 -void intel_dp_phy_test(struct intel_encoder *encoder)
 +static void
 +intel_dp_unset_edid(struct intel_dp *intel_dp)
  {
 -	struct drm_modeset_acquire_ctx ctx;
 -	int ret;
 +	struct intel_connector *intel_connector = intel_dp->attached_connector;
  
 -	drm_modeset_acquire_init(&ctx, 0);
 +	drm_dp_cec_unset_edid(&intel_dp->aux);
 +	kfree(intel_connector->detect_edid);
 +	intel_connector->detect_edid = NULL;
  
 -	for (;;) {
 -		ret = intel_dp_do_phy_test(encoder, &ctx);
 +	intel_dp->has_audio = false;
++<<<<<<< HEAD
 +	intel_dp->edid_quirks = 0;
++=======
+ 
 -		if (ret == -EDEADLK) {
 -			drm_modeset_backoff(&ctx);
 -			continue;
 -		}
++	intel_dp->dfp.max_bpc = 0;
++	intel_dp->dfp.max_dotclock = 0;
++	intel_dp->dfp.min_tmds_clock = 0;
++	intel_dp->dfp.max_tmds_clock = 0;
+ 
 -		break;
 -	}
++	intel_dp->dfp.pcon_max_frl_bw = 0;
+ 
 -	drm_modeset_drop_locks(&ctx);
 -	drm_modeset_acquire_fini(&ctx);
 -	drm_WARN(encoder->base.dev, ret,
 -		 "Acquiring modeset locks failed with %i\n", ret);
++	intel_dp->dfp.ycbcr_444_to_420 = false;
++	connector->base.ycbcr_420_allowed = false;
++>>>>>>> 7c553f8b5a7d (drm/dp: Revert "drm/dp: Introduce EDID-based quirks")
  }
  
 -/*
 - * If display is now connected check links status,
 - * there has been known issues of link loss triggering
 - * long pulse.
 - *
 - * Some sinks (eg. ASUS PB287Q) seem to perform some
 - * weird HPD ping pong during modesets. So we can apparently
 - * end up with HPD going low during a modeset, and then
 - * going back up soon after. And once that happens we must
 - * retrain the link to get a picture. That's in case no
 - * userspace component reacted to intermittent HPD dip.
 - */
 -static enum intel_hotplug_state
 -intel_dp_hotplug(struct intel_encoder *encoder,
 -		 struct intel_connector *connector)
 +static int
 +intel_dp_detect(struct drm_connector *connector,
 +		struct drm_modeset_acquire_ctx *ctx,
 +		bool force)
  {
 -	struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
 -	struct drm_modeset_acquire_ctx ctx;
 -	enum intel_hotplug_state state;
 -	int ret;
 -
 -	if (intel_dp->compliance.test_active &&
 -	    intel_dp->compliance.test_type == DP_TEST_LINK_PHY_TEST_PATTERN) {
 -		intel_dp_phy_test(encoder);
 -		/* just do the PHY test and nothing else */
 -		return INTEL_HOTPLUG_UNCHANGED;
 -	}
 +	struct drm_i915_private *dev_priv = to_i915(connector->dev);
 +	struct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));
 +	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
 +	struct intel_encoder *encoder = &dig_port->base;
 +	enum drm_connector_status status;
  
 -	state = intel_encoder_hotplug(encoder, connector);
 +	drm_dbg_kms(&dev_priv->drm, "[CONNECTOR:%d:%s]\n",
 +		    connector->base.id, connector->name);
 +	drm_WARN_ON(&dev_priv->drm,
 +		    !drm_modeset_is_locked(&dev_priv->drm.mode_config.connection_mutex));
  
 -	drm_modeset_acquire_init(&ctx, 0);
 +	/* Can't disconnect eDP */
 +	if (intel_dp_is_edp(intel_dp))
 +		status = edp_detect(intel_dp);
 +	else if (intel_digital_port_connected(encoder))
 +		status = intel_dp_detect_dpcd(intel_dp);
 +	else
 +		status = connector_status_disconnected;
  
 -	for (;;) {
 -		ret = intel_dp_retrain_link(encoder, &ctx);
 +	if (status == connector_status_disconnected) {
 +		memset(&intel_dp->compliance, 0, sizeof(intel_dp->compliance));
 +		memset(intel_dp->dsc_dpcd, 0, sizeof(intel_dp->dsc_dpcd));
  
 -		if (ret == -EDEADLK) {
 -			drm_modeset_backoff(&ctx);
 -			continue;
 +		if (intel_dp->is_mst) {
 +			drm_dbg_kms(&dev_priv->drm,
 +				    "MST device may have disappeared %d vs %d\n",
 +				    intel_dp->is_mst,
 +				    intel_dp->mst_mgr.mst_state);
 +			intel_dp->is_mst = false;
 +			drm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr,
 +							intel_dp->is_mst);
  		}
  
 -		break;
 +		goto out;
  	}
  
 -	drm_modeset_drop_locks(&ctx);
 -	drm_modeset_acquire_fini(&ctx);
 -	drm_WARN(encoder->base.dev, ret,
 -		 "Acquiring modeset locks failed with %i\n", ret);
 +	/* Read DP Sink DSC Cap DPCD regs for DP v1.4 */
 +	if (INTEL_GEN(dev_priv) >= 11)
 +		intel_dp_get_dsc_sink_cap(intel_dp);
 +
 +	intel_dp_configure_mst(intel_dp);
  
  	/*
 -	 * Keeping it consistent with intel_ddi_hotplug() and
 -	 * intel_hdmi_hotplug().
 +	 * TODO: Reset link params when switching to MST mode, until MST
 +	 * supports link training fallback params.
  	 */
 -	if (state == INTEL_HOTPLUG_UNCHANGED && !connector->hotplug_retries)
 -		state = INTEL_HOTPLUG_RETRY;
 -
 -	return state;
 -}
 -
 -static void intel_dp_check_device_service_irq(struct intel_dp *intel_dp)
 -{
 -	struct drm_i915_private *i915 = dp_to_i915(intel_dp);
 -	u8 val;
 -
 -	if (intel_dp->dpcd[DP_DPCD_REV] < 0x11)
 -		return;
 -
 -	if (drm_dp_dpcd_readb(&intel_dp->aux,
 -			      DP_DEVICE_SERVICE_IRQ_VECTOR, &val) != 1 || !val)
 -		return;
 -
 -	drm_dp_dpcd_writeb(&intel_dp->aux, DP_DEVICE_SERVICE_IRQ_VECTOR, val);
 +	if (intel_dp->reset_link_params || intel_dp->is_mst) {
 +		/* Initial max link lane count */
 +		intel_dp->max_link_lane_count = intel_dp_max_common_lane_count(intel_dp);
  
 -	if (val & DP_AUTOMATED_TEST_REQUEST)
 -		intel_dp_handle_test_request(intel_dp);
 +		/* Initial max link rate */
 +		intel_dp->max_link_rate = intel_dp_max_common_rate(intel_dp);
  
 -	if (val & DP_CP_IRQ)
 -		intel_hdcp_handle_cp_irq(intel_dp->attached_connector);
 +		intel_dp->reset_link_params = false;
 +	}
  
 -	if (val & DP_SINK_SPECIFIC_IRQ)
 -		drm_dbg_kms(&i915->drm, "Sink specific irq unhandled\n");
 -}
 +	intel_dp_print_rates(intel_dp);
  
 -static void intel_dp_check_link_service_irq(struct intel_dp *intel_dp)
 -{
 -	struct drm_i915_private *i915 = dp_to_i915(intel_dp);
 -	u8 val;
 +	if (intel_dp->is_mst) {
 +		/*
 +		 * If we are in MST mode then this connector
 +		 * won't appear connected or have anything
 +		 * with EDID on it
 +		 */
 +		status = connector_status_disconnected;
 +		goto out;
 +	}
  
 -	if (intel_dp->dpcd[DP_DPCD_REV] < 0x11)
 -		return;
 +	/*
 +	 * Some external monitors do not signal loss of link synchronization
 +	 * with an IRQ_HPD, so force a link status check.
 +	 */
 +	if (!intel_dp_is_edp(intel_dp)) {
 +		int ret;
  
 -	if (drm_dp_dpcd_readb(&intel_dp->aux,
 -			      DP_LINK_SERVICE_IRQ_VECTOR_ESI0, &val) != 1 || !val) {
 -		drm_dbg_kms(&i915->drm, "Error in reading link service irq vector\n");
 -		return;
 +		ret = intel_dp_retrain_link(encoder, ctx);
 +		if (ret)
 +			return ret;
  	}
  
 -	if (drm_dp_dpcd_writeb(&intel_dp->aux,
 -			       DP_LINK_SERVICE_IRQ_VECTOR_ESI0, val) != 1) {
 -		drm_dbg_kms(&i915->drm, "Error in writing link service irq vector\n");
 -		return;
 -	}
 +	/*
 +	 * Clearing NACK and defer counts to get their exact values
 +	 * while reading EDID which are required by Compliance tests
 +	 * 4.2.2.4 and 4.2.2.5
 +	 */
 +	intel_dp->aux.i2c_nack_count = 0;
 +	intel_dp->aux.i2c_defer_count = 0;
  
 -	if (val & HDMI_LINK_STATUS_CHANGED)
 -		intel_dp_handle_hdmi_link_status_change(intel_dp);
 -}
 +	intel_dp_set_edid(intel_dp);
 +	if (intel_dp_is_edp(intel_dp) ||
 +	    to_intel_connector(connector)->detect_edid)
 +		status = connector_status_connected;
  
 -/*
 - * According to DP spec
 - * 5.1.2:
 - *  1. Read DPCD
 - *  2. Configure link according to Receiver Capabilities
 - *  3. Use Link Training from 2.5.3.3 and 3.5.1.3
 - *  4. Check link status on receipt of hot-plug interrupt
 - *
 - * intel_dp_short_pulse -  handles short pulse interrupts
 - * when full detection is not required.
 - * Returns %true if short pulse is handled and full detection
 - * is NOT required and %false otherwise.
 - */
 -static bool
 -intel_dp_short_pulse(struct intel_dp *intel_dp)
 -{
 -	struct drm_i915_private *dev_priv = dp_to_i915(intel_dp);
 -	u8 old_sink_count = intel_dp->sink_count;
 -	bool ret;
 +	intel_dp_check_service_irq(intel_dp);
  
 -	/*
 -	 * Clearing compliance test variables to allow capturing
 -	 * of values for next automated test request.
 -	 */
 -	memset(&intel_dp->compliance, 0, sizeof(intel_dp->compliance));
 +out:
 +	if (status != connector_status_connected && !intel_dp->is_mst)
 +		intel_dp_unset_edid(intel_dp);
  
  	/*
 -	 * Now read the DPCD to see if it's actually running
 -	 * If the current value of sink count doesn't match with
 -	 * the value that was stored earlier or dpcd read failed
 -	 * we need to do full detection
 +	 * Make sure the refs for power wells enabled during detect are
 +	 * dropped to avoid a new detect cycle triggered by HPD polling.
  	 */
 -	ret = intel_dp_get_dpcd(intel_dp);
 +	intel_display_power_flush_work(dev_priv);
  
 -	if ((old_sink_count != intel_dp->sink_count) || !ret) {
 -		/* No need to proceed if we are going to do full detect */
 -		return false;
 -	}
 +	return status;
 +}
  
 -	intel_dp_check_device_service_irq(intel_dp);
 -	intel_dp_check_link_service_irq(intel_dp);
 +static void
 +intel_dp_force(struct drm_connector *connector)
 +{
 +	struct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));
 +	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
 +	struct intel_encoder *intel_encoder = &dig_port->base;
 +	struct drm_i915_private *dev_priv = to_i915(intel_encoder->base.dev);
 +	enum intel_display_power_domain aux_domain =
 +		intel_aux_power_domain(dig_port);
 +	intel_wakeref_t wakeref;
  
 -	/* Handle CEC interrupts, if any */
 -	drm_dp_cec_irq(&intel_dp->aux);
 +	drm_dbg_kms(&dev_priv->drm, "[CONNECTOR:%d:%s]\n",
 +		    connector->base.id, connector->name);
 +	intel_dp_unset_edid(intel_dp);
  
 -	/* defer to the hotplug work for link retraining if needed */
 -	if (intel_dp_needs_link_retrain(intel_dp))
 -		return false;
 +	if (connector->status != connector_status_connected)
 +		return;
  
 -	intel_psr_short_pulse(intel_dp);
 +	wakeref = intel_display_power_get(dev_priv, aux_domain);
  
 -	switch (intel_dp->compliance.test_type) {
 -	case DP_TEST_LINK_TRAINING:
 -		drm_dbg_kms(&dev_priv->drm,
 -			    "Link Training Compliance Test requested\n");
 -		/* Send a Hotplug Uevent to userspace to start modeset */
 -		drm_kms_helper_hotplug_event(&dev_priv->drm);
 -		break;
 -	case DP_TEST_LINK_PHY_TEST_PATTERN:
 -		drm_dbg_kms(&dev_priv->drm,
 -			    "PHY test pattern Compliance Test requested\n");
 -		/*
 -		 * Schedule long hpd to do the test
 -		 *
 -		 * FIXME get rid of the ad-hoc phy test modeset code
 -		 * and properly incorporate it into the normal modeset.
 -		 */
 -		return false;
 +	intel_dp_set_edid(intel_dp);
 +
 +	intel_display_power_put(dev_priv, aux_domain, wakeref);
 +}
 +
 +static int intel_dp_get_modes(struct drm_connector *connector)
 +{
 +	struct intel_connector *intel_connector = to_intel_connector(connector);
 +	struct edid *edid;
 +
 +	edid = intel_connector->detect_edid;
 +	if (edid) {
 +		int ret = intel_connector_update_modes(connector, edid);
 +		if (ret)
 +			return ret;
  	}
  
 -	return true;
 +	/* if eDP has no EDID, fall back to fixed mode */
 +	if (intel_dp_is_edp(intel_attached_dp(to_intel_connector(connector))) &&
 +	    intel_connector->panel.fixed_mode) {
 +		struct drm_display_mode *mode;
 +
 +		mode = drm_mode_duplicate(connector->dev,
 +					  intel_connector->panel.fixed_mode);
 +		if (mode) {
 +			drm_mode_probed_add(connector, mode);
 +			return 1;
 +		}
 +	}
 +
 +	return 0;
  }
  
 -/* XXX this is probably wrong for multiple downstream ports */
 -static enum drm_connector_status
 -intel_dp_detect_dpcd(struct intel_dp *intel_dp)
 +static int
 +intel_dp_connector_register(struct drm_connector *connector)
  {
 -	struct drm_i915_private *i915 = dp_to_i915(intel_dp);
 -	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
 -	u8 *dpcd = intel_dp->dpcd;
 -	u8 type;
 +	struct drm_i915_private *i915 = to_i915(connector->dev);
 +	struct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));
 +	int ret;
  
 -	if (drm_WARN_ON(&i915->drm, intel_dp_is_edp(intel_dp)))
 -		return connector_status_connected;
 +	ret = intel_connector_register(connector);
 +	if (ret)
 +		return ret;
  
 -	lspcon_resume(dig_port);
 +	drm_dbg_kms(&i915->drm, "registering %s bus for %s\n",
 +		    intel_dp->aux.name, connector->kdev->kobj.name);
  
 -	if (!intel_dp_get_dpcd(intel_dp))
 -		return connector_status_disconnected;
 +	intel_dp->aux.dev = connector->kdev;
 +	ret = drm_dp_aux_register(&intel_dp->aux);
 +	if (!ret)
 +		drm_dp_cec_register_connector(&intel_dp->aux, connector);
 +	return ret;
 +}
  
 -	/* if there's no downstream port, we're done */
 -	if (!drm_dp_is_branch(dpcd))
 -		return connector_status_connected;
 +static void
 +intel_dp_connector_unregister(struct drm_connector *connector)
 +{
 +	struct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));
  
 -	/* If we're HPD-aware, SINK_COUNT changes dynamically */
 -	if (intel_dp_has_sink_count(intel_dp) &&
 -	    intel_dp->downstream_ports[0] & DP_DS_PORT_HPD) {
 -		return intel_dp->sink_count ?
 -		connector_status_connected : connector_status_disconnected;
 -	}
 +	drm_dp_cec_unregister_connector(&intel_dp->aux);
 +	drm_dp_aux_unregister(&intel_dp->aux);
 +	intel_connector_unregister(connector);
 +}
  
 -	if (intel_dp_can_mst(intel_dp))
 -		return connector_status_connected;
 +void intel_dp_encoder_flush_work(struct drm_encoder *encoder)
 +{
 +	struct intel_digital_port *dig_port = enc_to_dig_port(to_intel_encoder(encoder));
 +	struct intel_dp *intel_dp = &dig_port->dp;
  
 -	/* If no HPD, poke DDC gently */
 -	if (drm_probe_ddc(&intel_dp->aux.ddc))
 -		return connector_status_connected;
 +	intel_dp_mst_encoder_cleanup(dig_port);
 +	if (intel_dp_is_edp(intel_dp)) {
 +		intel_wakeref_t wakeref;
  
 -	/* Well we tried, say unknown for unreliable port types */
 -	if (intel_dp->dpcd[DP_DPCD_REV] >= 0x11) {
 -		type = intel_dp->downstream_ports[0] & DP_DS_PORT_TYPE_MASK;
 -		if (type == DP_DS_PORT_TYPE_VGA ||
 -		    type == DP_DS_PORT_TYPE_NON_EDID)
 -			return connector_status_unknown;
 -	} else {
 -		type = intel_dp->dpcd[DP_DOWNSTREAMPORT_PRESENT] &
 -			DP_DWN_STRM_PORT_TYPE_MASK;
 -		if (type == DP_DWN_STRM_PORT_TYPE_ANALOG ||
 -		    type == DP_DWN_STRM_PORT_TYPE_OTHER)
 -			return connector_status_unknown;
 +		cancel_delayed_work_sync(&intel_dp->panel_vdd_work);
 +		/*
 +		 * vdd might still be enabled do to the delayed vdd off.
 +		 * Make sure vdd is actually turned off here.
 +		 */
 +		with_pps_lock(intel_dp, wakeref)
 +			edp_panel_vdd_off_sync(intel_dp);
 +
 +		if (intel_dp->edp_notifier.notifier_call) {
 +			unregister_reboot_notifier(&intel_dp->edp_notifier);
 +			intel_dp->edp_notifier.notifier_call = NULL;
 +		}
  	}
  
 -	/* Anything else is out of spec, warn and ignore */
 -	drm_dbg_kms(&i915->drm, "Broken DP branch device, ignoring\n");
 -	return connector_status_disconnected;
 +	intel_dp_aux_fini(intel_dp);
  }
  
 -static enum drm_connector_status
 -edp_detect(struct intel_dp *intel_dp)
 +static void intel_dp_encoder_destroy(struct drm_encoder *encoder)
  {
 -	return connector_status_connected;
 +	intel_dp_encoder_flush_work(encoder);
 +
 +	drm_encoder_cleanup(encoder);
 +	kfree(enc_to_dig_port(to_intel_encoder(encoder)));
  }
  
 -static bool ibx_digital_port_connected(struct intel_encoder *encoder)
 +void intel_dp_encoder_suspend(struct intel_encoder *intel_encoder)
  {
 -	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 -	u32 bit = dev_priv->hotplug.pch_hpd[encoder->hpd_pin];
 +	struct intel_dp *intel_dp = enc_to_intel_dp(intel_encoder);
 +	intel_wakeref_t wakeref;
  
 -	return intel_de_read(dev_priv, SDEISR) & bit;
 +	if (!intel_dp_is_edp(intel_dp))
 +		return;
 +
 +	/*
 +	 * vdd might still be enabled do to the delayed vdd off.
 +	 * Make sure vdd is actually turned off here.
 +	 */
 +	cancel_delayed_work_sync(&intel_dp->panel_vdd_work);
 +	with_pps_lock(intel_dp, wakeref)
 +		edp_panel_vdd_off_sync(intel_dp);
  }
  
 -static bool g4x_digital_port_connected(struct intel_encoder *encoder)
 +static void intel_dp_hdcp_wait_for_cp_irq(struct intel_hdcp *hdcp, int timeout)
  {
 -	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 -	u32 bit;
 +	long ret;
  
 -	switch (encoder->hpd_pin) {
 -	case HPD_PORT_B:
 -		bit = PORTB_HOTPLUG_LIVE_STATUS_G4X;
 -		break;
 -	case HPD_PORT_C:
 -		bit = PORTC_HOTPLUG_LIVE_STATUS_G4X;
 -		break;
 -	case HPD_PORT_D:
 -		bit = PORTD_HOTPLUG_LIVE_STATUS_G4X;
 -		break;
 -	default:
 -		MISSING_CASE(encoder->hpd_pin);
 -		return false;
 -	}
 +#define C (hdcp->cp_irq_count_cached != atomic_read(&hdcp->cp_irq_count))
 +	ret = wait_event_interruptible_timeout(hdcp->cp_irq_queue, C,
 +					       msecs_to_jiffies(timeout));
  
 -	return intel_de_read(dev_priv, PORT_HOTPLUG_STAT) & bit;
 +	if (!ret)
 +		DRM_DEBUG_KMS("Timedout at waiting for CP_IRQ\n");
  }
  
 -static bool gm45_digital_port_connected(struct intel_encoder *encoder)
 +static
 +int intel_dp_hdcp_write_an_aksv(struct intel_digital_port *dig_port,
 +				u8 *an)
  {
 -	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 -	u32 bit;
 +	struct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);
 +	struct intel_dp *intel_dp = enc_to_intel_dp(to_intel_encoder(&dig_port->base.base));
 +	static const struct drm_dp_aux_msg msg = {
 +		.request = DP_AUX_NATIVE_WRITE,
 +		.address = DP_AUX_HDCP_AKSV,
 +		.size = DRM_HDCP_KSV_LEN,
 +	};
 +	u8 txbuf[HEADER_SIZE + DRM_HDCP_KSV_LEN] = {}, rxbuf[2], reply = 0;
 +	ssize_t dpcd_ret;
 +	int ret;
  
 -	switch (encoder->hpd_pin) {
 -	case HPD_PORT_B:
 -		bit = PORTB_HOTPLUG_LIVE_STATUS_GM45;
 -		break;
 -	case HPD_PORT_C:
 -		bit = PORTC_HOTPLUG_LIVE_STATUS_GM45;
 -		break;
 -	case HPD_PORT_D:
 -		bit = PORTD_HOTPLUG_LIVE_STATUS_GM45;
 -		break;
 -	default:
 -		MISSING_CASE(encoder->hpd_pin);
 -		return false;
 +	/* Output An first, that's easy */
 +	dpcd_ret = drm_dp_dpcd_write(&dig_port->dp.aux, DP_AUX_HDCP_AN,
 +				     an, DRM_HDCP_AN_LEN);
 +	if (dpcd_ret != DRM_HDCP_AN_LEN) {
 +		drm_dbg_kms(&i915->drm,
 +			    "Failed to write An over DP/AUX (%zd)\n",
 +			    dpcd_ret);
 +		return dpcd_ret >= 0 ? -EIO : dpcd_ret;
  	}
  
 -	return intel_de_read(dev_priv, PORT_HOTPLUG_STAT) & bit;
 +	/*
 +	 * Since Aksv is Oh-So-Secret, we can't access it in software. So in
 +	 * order to get it on the wire, we need to create the AUX header as if
 +	 * we were writing the data, and then tickle the hardware to output the
 +	 * data once the header is sent out.
 +	 */
 +	intel_dp_aux_header(txbuf, &msg);
 +
 +	ret = intel_dp_aux_xfer(intel_dp, txbuf, HEADER_SIZE + msg.size,
 +				rxbuf, sizeof(rxbuf),
 +				DP_AUX_CH_CTL_AUX_AKSV_SELECT);
 +	if (ret < 0) {
 +		drm_dbg_kms(&i915->drm,
 +			    "Write Aksv over DP/AUX failed (%d)\n", ret);
 +		return ret;
 +	} else if (ret == 0) {
 +		drm_dbg_kms(&i915->drm, "Aksv write over DP/AUX was empty\n");
 +		return -EIO;
 +	}
 +
 +	reply = (rxbuf[0] >> 4) & DP_AUX_NATIVE_REPLY_MASK;
 +	if (reply != DP_AUX_NATIVE_REPLY_ACK) {
 +		drm_dbg_kms(&i915->drm,
 +			    "Aksv write: no DP_AUX_NATIVE_REPLY_ACK %x\n",
 +			    reply);
 +		return -EIO;
 +	}
 +	return 0;
  }
  
 -static bool ilk_digital_port_connected(struct intel_encoder *encoder)
 +static int intel_dp_hdcp_read_bksv(struct intel_digital_port *dig_port,
 +				   u8 *bksv)
  {
 -	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 -	u32 bit = dev_priv->hotplug.hpd[encoder->hpd_pin];
 +	struct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);
 +	ssize_t ret;
  
 -	return intel_de_read(dev_priv, DEISR) & bit;
 +	ret = drm_dp_dpcd_read(&dig_port->dp.aux, DP_AUX_HDCP_BKSV, bksv,
 +			       DRM_HDCP_KSV_LEN);
 +	if (ret != DRM_HDCP_KSV_LEN) {
 +		drm_dbg_kms(&i915->drm,
 +			    "Read Bksv from DP/AUX failed (%zd)\n", ret);
 +		return ret >= 0 ? -EIO : ret;
 +	}
 +	return 0;
  }
  
 -/*
 - * intel_digital_port_connected - is the specified port connected?
 - * @encoder: intel_encoder
 - *
 - * In cases where there's a connector physically connected but it can't be used
 - * by our hardware we also return false, since the rest of the driver should
 - * pretty much treat the port as disconnected. This is relevant for type-C
 - * (starting on ICL) where there's ownership involved.
 - *
 - * Return %true if port is connected, %false otherwise.
 - */
 -bool intel_digital_port_connected(struct intel_encoder *encoder)
 +static int intel_dp_hdcp_read_bstatus(struct intel_digital_port *dig_port,
 +				      u8 *bstatus)
  {
 -	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 -	struct intel_digital_port *dig_port = enc_to_dig_port(encoder);
 -	bool is_connected = false;
 -	intel_wakeref_t wakeref;
 -
 -	with_intel_display_power(dev_priv, POWER_DOMAIN_DISPLAY_CORE, wakeref)
 -		is_connected = dig_port->connected(encoder);
 +	struct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);
 +	ssize_t ret;
  
 -	return is_connected;
 +	/*
 +	 * For some reason the HDMI and DP HDCP specs call this register
 +	 * definition by different names. In the HDMI spec, it's called BSTATUS,
 +	 * but in DP it's called BINFO.
 +	 */
 +	ret = drm_dp_dpcd_read(&dig_port->dp.aux, DP_AUX_HDCP_BINFO,
 +			       bstatus, DRM_HDCP_BSTATUS_LEN);
 +	if (ret != DRM_HDCP_BSTATUS_LEN) {
 +		drm_dbg_kms(&i915->drm,
 +			    "Read bstatus from DP/AUX failed (%zd)\n", ret);
 +		return ret >= 0 ? -EIO : ret;
 +	}
 +	return 0;
  }
  
 -static struct edid *
 -intel_dp_get_edid(struct intel_dp *intel_dp)
 +static
 +int intel_dp_hdcp_read_bcaps(struct intel_digital_port *dig_port,
 +			     u8 *bcaps)
  {
 -	struct intel_connector *intel_connector = intel_dp->attached_connector;
 +	struct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);
 +	ssize_t ret;
  
 -	/* use cached edid if we have one */
 -	if (intel_connector->edid) {
 -		/* invalid edid */
 -		if (IS_ERR(intel_connector->edid))
 -			return NULL;
 +	ret = drm_dp_dpcd_read(&dig_port->dp.aux, DP_AUX_HDCP_BCAPS,
 +			       bcaps, 1);
 +	if (ret != 1) {
 +		drm_dbg_kms(&i915->drm,
 +			    "Read bcaps from DP/AUX failed (%zd)\n", ret);
 +		return ret >= 0 ? -EIO : ret;
 +	}
  
 -		return drm_edid_duplicate(intel_connector->edid);
 -	} else
 -		return drm_get_edid(&intel_connector->base,
 -				    &intel_dp->aux.ddc);
 +	return 0;
  }
  
 -static void
 -intel_dp_update_dfp(struct intel_dp *intel_dp,
 -		    const struct edid *edid)
 +static
 +int intel_dp_hdcp_repeater_present(struct intel_digital_port *dig_port,
 +				   bool *repeater_present)
  {
 -	struct drm_i915_private *i915 = dp_to_i915(intel_dp);
 -	struct intel_connector *connector = intel_dp->attached_connector;
 +	ssize_t ret;
 +	u8 bcaps;
  
 -	intel_dp->dfp.max_bpc =
 -		drm_dp_downstream_max_bpc(intel_dp->dpcd,
 -					  intel_dp->downstream_ports, edid);
 +	ret = intel_dp_hdcp_read_bcaps(dig_port, &bcaps);
 +	if (ret)
 +		return ret;
  
 -	intel_dp->dfp.max_dotclock =
 -		drm_dp_downstream_max_dotclock(intel_dp->dpcd,
 -					       intel_dp->downstream_ports);
 +	*repeater_present = bcaps & DP_BCAPS_REPEATER_PRESENT;
 +	return 0;
 +}
  
 -	intel_dp->dfp.min_tmds_clock =
 -		drm_dp_downstream_min_tmds_clock(intel_dp->dpcd,
 -						 intel_dp->downstream_ports,
 -						 edid);
 -	intel_dp->dfp.max_tmds_clock =
 -		drm_dp_downstream_max_tmds_clock(intel_dp->dpcd,
 -						 intel_dp->downstream_ports,
 -						 edid);
 +static
 +int intel_dp_hdcp_read_ri_prime(struct intel_digital_port *dig_port,
 +				u8 *ri_prime)
 +{
 +	struct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);
 +	ssize_t ret;
  
 -	intel_dp->dfp.pcon_max_frl_bw =
 -		drm_dp_get_pcon_max_frl_bw(intel_dp->dpcd,
 -					   intel_dp->downstream_ports);
 +	ret = drm_dp_dpcd_read(&dig_port->dp.aux, DP_AUX_HDCP_RI_PRIME,
 +			       ri_prime, DRM_HDCP_RI_LEN);
 +	if (ret != DRM_HDCP_RI_LEN) {
 +		drm_dbg_kms(&i915->drm, "Read Ri' from DP/AUX failed (%zd)\n",
 +			    ret);
 +		return ret >= 0 ? -EIO : ret;
 +	}
 +	return 0;
 +}
  
 -	drm_dbg_kms(&i915->drm,
 -		    "[CONNECTOR:%d:%s] DFP max bpc %d, max dotclock %d, TMDS clock %d-%d, PCON Max FRL BW %dGbps\n",
 -		    connector->base.base.id, connector->base.name,
 -		    intel_dp->dfp.max_bpc,
 -		    intel_dp->dfp.max_dotclock,
 -		    intel_dp->dfp.min_tmds_clock,
 -		    intel_dp->dfp.max_tmds_clock,
 -		    intel_dp->dfp.pcon_max_frl_bw);
 +static
 +int intel_dp_hdcp_read_ksv_ready(struct intel_digital_port *dig_port,
 +				 bool *ksv_ready)
 +{
 +	struct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);
 +	ssize_t ret;
 +	u8 bstatus;
  
 -	intel_dp_get_pcon_dsc_cap(intel_dp);
 +	ret = drm_dp_dpcd_read(&dig_port->dp.aux, DP_AUX_HDCP_BSTATUS,
 +			       &bstatus, 1);
 +	if (ret != 1) {
 +		drm_dbg_kms(&i915->drm,
 +			    "Read bstatus from DP/AUX failed (%zd)\n", ret);
 +		return ret >= 0 ? -EIO : ret;
 +	}
 +	*ksv_ready = bstatus & DP_BSTATUS_READY;
 +	return 0;
  }
  
 -static void
 -intel_dp_update_420(struct intel_dp *intel_dp)
 +static
 +int intel_dp_hdcp_read_ksv_fifo(struct intel_digital_port *dig_port,
 +				int num_downstream, u8 *ksv_fifo)
  {
 -	struct drm_i915_private *i915 = dp_to_i915(intel_dp);
 -	struct intel_connector *connector = intel_dp->attached_connector;
 -	bool is_branch, ycbcr_420_passthrough, ycbcr_444_to_420, rgb_to_ycbcr;
 -
 -	/* No YCbCr output support on gmch platforms */
 -	if (HAS_GMCH(i915))
 -		return;
 +	struct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);
 +	ssize_t ret;
 +	int i;
  
 -	/*
 -	 * ILK doesn't seem capable of DP YCbCr output. The
 -	 * displayed image is severly corrupted. SNB+ is fine.
 -	 */
 -	if (IS_GEN(i915, 5))
 -		return;
 +	/* KSV list is read via 15 byte window (3 entries @ 5 bytes each) */
 +	for (i = 0; i < num_downstream; i += 3) {
 +		size_t len = min(num_downstream - i, 3) * DRM_HDCP_KSV_LEN;
 +		ret = drm_dp_dpcd_read(&dig_port->dp.aux,
 +				       DP_AUX_HDCP_KSV_FIFO,
 +				       ksv_fifo + i * DRM_HDCP_KSV_LEN,
 +				       len);
 +		if (ret != len) {
 +			drm_dbg_kms(&i915->drm,
 +				    "Read ksv[%d] from DP/AUX failed (%zd)\n",
 +				    i, ret);
 +			return ret >= 0 ? -EIO : ret;
 +		}
 +	}
 +	return 0;
 +}
  
 -	is_branch = drm_dp_is_branch(intel_dp->dpcd);
 -	ycbcr_420_passthrough =
 -		drm_dp_downstream_420_passthrough(intel_dp->dpcd,
 -						  intel_dp->downstream_ports);
 -	/* on-board LSPCON always assumed to support 4:4:4->4:2:0 conversion */
 -	ycbcr_444_to_420 =
 -		dp_to_dig_port(intel_dp)->lspcon.active ||
 -		drm_dp_downstream_444_to_420_conversion(intel_dp->dpcd,
 -							intel_dp->downstream_ports);
 -	rgb_to_ycbcr = drm_dp_downstream_rgb_to_ycbcr_conversion(intel_dp->dpcd,
 -								 intel_dp->downstream_ports,
 -								 DP_DS_HDMI_BT601_RGB_YCBCR_CONV |
 -								 DP_DS_HDMI_BT709_RGB_YCBCR_CONV |
 -								 DP_DS_HDMI_BT2020_RGB_YCBCR_CONV);
 -
 -	if (INTEL_GEN(i915) >= 11) {
 -		/* Let PCON convert from RGB->YCbCr if possible */
 -		if (is_branch && rgb_to_ycbcr && ycbcr_444_to_420) {
 -			intel_dp->dfp.rgb_to_ycbcr = true;
 -			intel_dp->dfp.ycbcr_444_to_420 = true;
 -			connector->base.ycbcr_420_allowed = true;
 -		} else {
 -		/* Prefer 4:2:0 passthrough over 4:4:4->4:2:0 conversion */
 -			intel_dp->dfp.ycbcr_444_to_420 =
 -				ycbcr_444_to_420 && !ycbcr_420_passthrough;
 +static
 +int intel_dp_hdcp_read_v_prime_part(struct intel_digital_port *dig_port,
 +				    int i, u32 *part)
 +{
 +	struct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);
 +	ssize_t ret;
  
 -			connector->base.ycbcr_420_allowed =
 -				!is_branch || ycbcr_444_to_420 || ycbcr_420_passthrough;
 -		}
 -	} else {
 -		/* 4:4:4->4:2:0 conversion is the only way */
 -		intel_dp->dfp.ycbcr_444_to_420 = ycbcr_444_to_420;
 +	if (i >= DRM_HDCP_V_PRIME_NUM_PARTS)
 +		return -EINVAL;
  
 -		connector->base.ycbcr_420_allowed = ycbcr_444_to_420;
 +	ret = drm_dp_dpcd_read(&dig_port->dp.aux,
 +			       DP_AUX_HDCP_V_PRIME(i), part,
 +			       DRM_HDCP_V_PRIME_PART_LEN);
 +	if (ret != DRM_HDCP_V_PRIME_PART_LEN) {
 +		drm_dbg_kms(&i915->drm,
 +			    "Read v'[%d] from DP/AUX failed (%zd)\n", i, ret);
 +		return ret >= 0 ? -EIO : ret;
  	}
 -
 -	drm_dbg_kms(&i915->drm,
 -		    "[CONNECTOR:%d:%s] RGB->YcbCr conversion? %s, YCbCr 4:2:0 allowed? %s, YCbCr 4:4:4->4:2:0 conversion? %s\n",
 -		    connector->base.base.id, connector->base.name,
 -		    yesno(intel_dp->dfp.rgb_to_ycbcr),
 -		    yesno(connector->base.ycbcr_420_allowed),
 -		    yesno(intel_dp->dfp.ycbcr_444_to_420));
 +	return 0;
  }
  
 -static void
 -intel_dp_set_edid(struct intel_dp *intel_dp)
 +static
 +int intel_dp_hdcp_toggle_signalling(struct intel_digital_port *dig_port,
 +				    bool enable)
  {
 -	struct intel_connector *connector = intel_dp->attached_connector;
 -	struct edid *edid;
 -
 -	intel_dp_unset_edid(intel_dp);
 -	edid = intel_dp_get_edid(intel_dp);
 -	connector->detect_edid = edid;
 +	/* Not used for single stream DisplayPort setups */
 +	return 0;
 +}
  
 -	intel_dp_update_dfp(intel_dp, edid);
 -	intel_dp_update_420(intel_dp);
 +static
 +bool intel_dp_hdcp_check_link(struct intel_digital_port *dig_port)
 +{
 +	struct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);
 +	ssize_t ret;
 +	u8 bstatus;
  
 -	if (edid && edid->input & DRM_EDID_INPUT_DIGITAL) {
 -		intel_dp->has_hdmi_sink = drm_detect_hdmi_monitor(edid);
 -		intel_dp->has_audio = drm_detect_monitor_audio(edid);
 +	ret = drm_dp_dpcd_read(&dig_port->dp.aux, DP_AUX_HDCP_BSTATUS,
 +			       &bstatus, 1);
 +	if (ret != 1) {
 +		drm_dbg_kms(&i915->drm,
 +			    "Read bstatus from DP/AUX failed (%zd)\n", ret);
 +		return false;
  	}
  
 -	drm_dp_cec_set_edid(&intel_dp->aux, edid);
 +	return !(bstatus & (DP_BSTATUS_LINK_FAILURE | DP_BSTATUS_REAUTH_REQ));
  }
  
 -static void
 -intel_dp_unset_edid(struct intel_dp *intel_dp)
 +static
 +int intel_dp_hdcp_capable(struct intel_digital_port *dig_port,
 +			  bool *hdcp_capable)
  {
 -	struct intel_connector *connector = intel_dp->attached_connector;
 +	ssize_t ret;
 +	u8 bcaps;
  
 -	drm_dp_cec_unset_edid(&intel_dp->aux);
 -	kfree(connector->detect_edid);
 -	connector->detect_edid = NULL;
 +	ret = intel_dp_hdcp_read_bcaps(dig_port, &bcaps);
 +	if (ret)
 +		return ret;
  
 -	intel_dp->has_hdmi_sink = false;
 -	intel_dp->has_audio = false;
 +	*hdcp_capable = bcaps & DP_BCAPS_HDCP_CAPABLE;
 +	return 0;
 +}
  
 -	intel_dp->dfp.max_bpc = 0;
 -	intel_dp->dfp.max_dotclock = 0;
 -	intel_dp->dfp.min_tmds_clock = 0;
 -	intel_dp->dfp.max_tmds_clock = 0;
 +struct hdcp2_dp_errata_stream_type {
 +	u8	msg_id;
 +	u8	stream_type;
 +} __packed;
  
 -	intel_dp->dfp.pcon_max_frl_bw = 0;
 +struct hdcp2_dp_msg_data {
 +	u8 msg_id;
 +	u32 offset;
 +	bool msg_detectable;
 +	u32 timeout;
 +	u32 timeout2; /* Added for non_paired situation */
 +};
  
 -	intel_dp->dfp.ycbcr_444_to_420 = false;
 -	connector->base.ycbcr_420_allowed = false;
 -}
 +static const struct hdcp2_dp_msg_data hdcp2_dp_msg_data[] = {
 +	{ HDCP_2_2_AKE_INIT, DP_HDCP_2_2_AKE_INIT_OFFSET, false, 0, 0 },
 +	{ HDCP_2_2_AKE_SEND_CERT, DP_HDCP_2_2_AKE_SEND_CERT_OFFSET,
 +	  false, HDCP_2_2_CERT_TIMEOUT_MS, 0 },
 +	{ HDCP_2_2_AKE_NO_STORED_KM, DP_HDCP_2_2_AKE_NO_STORED_KM_OFFSET,
 +	  false, 0, 0 },
 +	{ HDCP_2_2_AKE_STORED_KM, DP_HDCP_2_2_AKE_STORED_KM_OFFSET,
 +	  false, 0, 0 },
 +	{ HDCP_2_2_AKE_SEND_HPRIME, DP_HDCP_2_2_AKE_SEND_HPRIME_OFFSET,
 +	  true, HDCP_2_2_HPRIME_PAIRED_TIMEOUT_MS,
 +	  HDCP_2_2_HPRIME_NO_PAIRED_TIMEOUT_MS },
 +	{ HDCP_2_2_AKE_SEND_PAIRING_INFO,
 +	  DP_HDCP_2_2_AKE_SEND_PAIRING_INFO_OFFSET, true,
 +	  HDCP_2_2_PAIRING_TIMEOUT_MS, 0 },
 +	{ HDCP_2_2_LC_INIT, DP_HDCP_2_2_LC_INIT_OFFSET, false, 0, 0 },
 +	{ HDCP_2_2_LC_SEND_LPRIME, DP_HDCP_2_2_LC_SEND_LPRIME_OFFSET,
 +	  false, HDCP_2_2_DP_LPRIME_TIMEOUT_MS, 0 },
 +	{ HDCP_2_2_SKE_SEND_EKS, DP_HDCP_2_2_SKE_SEND_EKS_OFFSET, false,
 +	  0, 0 },
 +	{ HDCP_2_2_REP_SEND_RECVID_LIST,
 +	  DP_HDCP_2_2_REP_SEND_RECVID_LIST_OFFSET, true,
 +	  HDCP_2_2_RECVID_LIST_TIMEOUT_MS, 0 },
 +	{ HDCP_2_2_REP_SEND_ACK, DP_HDCP_2_2_REP_SEND_ACK_OFFSET, false,
 +	  0, 0 },
 +	{ HDCP_2_2_REP_STREAM_MANAGE,
 +	  DP_HDCP_2_2_REP_STREAM_MANAGE_OFFSET, false,
 +	  0, 0 },
 +	{ HDCP_2_2_REP_STREAM_READY, DP_HDCP_2_2_REP_STREAM_READY_OFFSET,
 +	  false, HDCP_2_2_STREAM_READY_TIMEOUT_MS, 0 },
 +/* local define to shovel this through the write_2_2 interface */
 +#define HDCP_2_2_ERRATA_DP_STREAM_TYPE	50
 +	{ HDCP_2_2_ERRATA_DP_STREAM_TYPE,
 +	  DP_HDCP_2_2_REG_STREAM_TYPE_OFFSET, false,
 +	  0, 0 },
 +};
  
  static int
 -intel_dp_detect(struct drm_connector *connector,
 -		struct drm_modeset_acquire_ctx *ctx,
 -		bool force)
 +intel_dp_hdcp2_read_rx_status(struct intel_digital_port *dig_port,
 +			      u8 *rx_status)
  {
 -	struct drm_i915_private *dev_priv = to_i915(connector->dev);
 -	struct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));
 -	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
 -	struct intel_encoder *encoder = &dig_port->base;
 -	enum drm_connector_status status;
 -
 -	drm_dbg_kms(&dev_priv->drm, "[CONNECTOR:%d:%s]\n",
 -		    connector->base.id, connector->name);
 -	drm_WARN_ON(&dev_priv->drm,
 -		    !drm_modeset_is_locked(&dev_priv->drm.mode_config.connection_mutex));
 +	struct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);
 +	ssize_t ret;
  
 -	if (!INTEL_DISPLAY_ENABLED(dev_priv))
 -		return connector_status_disconnected;
 +	ret = drm_dp_dpcd_read(&dig_port->dp.aux,
 +			       DP_HDCP_2_2_REG_RXSTATUS_OFFSET, rx_status,
 +			       HDCP_2_2_DP_RXSTATUS_LEN);
 +	if (ret != HDCP_2_2_DP_RXSTATUS_LEN) {
 +		drm_dbg_kms(&i915->drm,
 +			    "Read bstatus from DP/AUX failed (%zd)\n", ret);
 +		return ret >= 0 ? -EIO : ret;
 +	}
  
 -	/* Can't disconnect eDP */
 -	if (intel_dp_is_edp(intel_dp))
 -		status = edp_detect(intel_dp);
 -	else if (intel_digital_port_connected(encoder))
 -		status = intel_dp_detect_dpcd(intel_dp);
 -	else
 -		status = connector_status_disconnected;
 +	return 0;
 +}
  
 -	if (status == connector_status_disconnected) {
 -		memset(&intel_dp->compliance, 0, sizeof(intel_dp->compliance));
 -		memset(intel_dp->dsc_dpcd, 0, sizeof(intel_dp->dsc_dpcd));
 +static
 +int hdcp2_detect_msg_availability(struct intel_digital_port *dig_port,
 +				  u8 msg_id, bool *msg_ready)
 +{
 +	u8 rx_status;
 +	int ret;
  
 -		if (intel_dp->is_mst) {
 -			drm_dbg_kms(&dev_priv->drm,
 -				    "MST device may have disappeared %d vs %d\n",
 -				    intel_dp->is_mst,
 -				    intel_dp->mst_mgr.mst_state);
 -			intel_dp->is_mst = false;
 -			drm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr,
 -							intel_dp->is_mst);
 -		}
 +	*msg_ready = false;
 +	ret = intel_dp_hdcp2_read_rx_status(dig_port, &rx_status);
 +	if (ret < 0)
 +		return ret;
  
 -		goto out;
 +	switch (msg_id) {
 +	case HDCP_2_2_AKE_SEND_HPRIME:
 +		if (HDCP_2_2_DP_RXSTATUS_H_PRIME(rx_status))
 +			*msg_ready = true;
 +		break;
 +	case HDCP_2_2_AKE_SEND_PAIRING_INFO:
 +		if (HDCP_2_2_DP_RXSTATUS_PAIRING(rx_status))
 +			*msg_ready = true;
 +		break;
 +	case HDCP_2_2_REP_SEND_RECVID_LIST:
 +		if (HDCP_2_2_DP_RXSTATUS_READY(rx_status))
 +			*msg_ready = true;
 +		break;
 +	default:
 +		DRM_ERROR("Unidentified msg_id: %d\n", msg_id);
 +		return -EINVAL;
  	}
  
 -	/* Read DP Sink DSC Cap DPCD regs for DP v1.4 */
 -	if (INTEL_GEN(dev_priv) >= 11)
 -		intel_dp_get_dsc_sink_cap(intel_dp);
 +	return 0;
 +}
  
 -	intel_dp_configure_mst(intel_dp);
 +static ssize_t
 +intel_dp_hdcp2_wait_for_msg(struct intel_digital_port *dig_port,
 +			    const struct hdcp2_dp_msg_data *hdcp2_msg_data)
 +{
 +	struct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);
 +	struct intel_dp *dp = &dig_port->dp;
 +	struct intel_hdcp *hdcp = &dp->attached_connector->hdcp;
 +	u8 msg_id = hdcp2_msg_data->msg_id;
 +	int ret, timeout;
 +	bool msg_ready = false;
 +
 +	if (msg_id == HDCP_2_2_AKE_SEND_HPRIME && !hdcp->is_paired)
 +		timeout = hdcp2_msg_data->timeout2;
 +	else
 +		timeout = hdcp2_msg_data->timeout;
  
  	/*
 -	 * TODO: Reset link params when switching to MST mode, until MST
 -	 * supports link training fallback params.
 +	 * There is no way to detect the CERT, LPRIME and STREAM_READY
 +	 * availability. So Wait for timeout and read the msg.
  	 */
 -	if (intel_dp->reset_link_params || intel_dp->is_mst) {
 -		/* Initial max link lane count */
 -		intel_dp->max_link_lane_count = intel_dp_max_common_lane_count(intel_dp);
 +	if (!hdcp2_msg_data->msg_detectable) {
 +		mdelay(timeout);
 +		ret = 0;
 +	} else {
 +		/*
 +		 * As we want to check the msg availability at timeout, Ignoring
 +		 * the timeout at wait for CP_IRQ.
 +		 */
 +		intel_dp_hdcp_wait_for_cp_irq(hdcp, timeout);
 +		ret = hdcp2_detect_msg_availability(dig_port,
 +						    msg_id, &msg_ready);
 +		if (!msg_ready)
 +			ret = -ETIMEDOUT;
 +	}
  
 -		/* Initial max link rate */
 -		intel_dp->max_link_rate = intel_dp_max_common_rate(intel_dp);
 +	if (ret)
 +		drm_dbg_kms(&i915->drm,
 +			    "msg_id %d, ret %d, timeout(mSec): %d\n",
 +			    hdcp2_msg_data->msg_id, ret, timeout);
  
 -		intel_dp->reset_link_params = false;
 -	}
 +	return ret;
 +}
  
 -	intel_dp_print_rates(intel_dp);
 +static const struct hdcp2_dp_msg_data *get_hdcp2_dp_msg_data(u8 msg_id)
 +{
 +	int i;
  
 -	if (intel_dp->is_mst) {
 -		/*
 -		 * If we are in MST mode then this connector
 -		 * won't appear connected or have anything
 -		 * with EDID on it
 -		 */
 -		status = connector_status_disconnected;
 -		goto out;
 -	}
 +	for (i = 0; i < ARRAY_SIZE(hdcp2_dp_msg_data); i++)
 +		if (hdcp2_dp_msg_data[i].msg_id == msg_id)
 +			return &hdcp2_dp_msg_data[i];
  
 -	/*
 -	 * Some external monitors do not signal loss of link synchronization
 -	 * with an IRQ_HPD, so force a link status check.
 -	 */
 -	if (!intel_dp_is_edp(intel_dp)) {
 -		int ret;
 +	return NULL;
 +}
  
 -		ret = intel_dp_retrain_link(encoder, ctx);
 -		if (ret)
 -			return ret;
 -	}
 +static
 +int intel_dp_hdcp2_write_msg(struct intel_digital_port *dig_port,
 +			     void *buf, size_t size)
 +{
 +	struct intel_dp *dp = &dig_port->dp;
 +	struct intel_hdcp *hdcp = &dp->attached_connector->hdcp;
 +	unsigned int offset;
 +	u8 *byte = buf;
 +	ssize_t ret, bytes_to_write, len;
 +	const struct hdcp2_dp_msg_data *hdcp2_msg_data;
  
 -	/*
 -	 * Clearing NACK and defer counts to get their exact values
 -	 * while reading EDID which are required by Compliance tests
 -	 * 4.2.2.4 and 4.2.2.5
 -	 */
 -	intel_dp->aux.i2c_nack_count = 0;
 -	intel_dp->aux.i2c_defer_count = 0;
 +	hdcp2_msg_data = get_hdcp2_dp_msg_data(*byte);
 +	if (!hdcp2_msg_data)
 +		return -EINVAL;
  
 -	intel_dp_set_edid(intel_dp);
 -	if (intel_dp_is_edp(intel_dp) ||
 -	    to_intel_connector(connector)->detect_edid)
 -		status = connector_status_connected;
 +	offset = hdcp2_msg_data->offset;
  
 -	intel_dp_check_device_service_irq(intel_dp);
 +	/* No msg_id in DP HDCP2.2 msgs */
 +	bytes_to_write = size - 1;
 +	byte++;
  
 -out:
 -	if (status != connector_status_connected && !intel_dp->is_mst)
 -		intel_dp_unset_edid(intel_dp);
 +	hdcp->cp_irq_count_cached = atomic_read(&hdcp->cp_irq_count);
  
 -	/*
 -	 * Make sure the refs for power wells enabled during detect are
 -	 * dropped to avoid a new detect cycle triggered by HPD polling.
 -	 */
 -	intel_display_power_flush_work(dev_priv);
 +	while (bytes_to_write) {
 +		len = bytes_to_write > DP_AUX_MAX_PAYLOAD_BYTES ?
 +				DP_AUX_MAX_PAYLOAD_BYTES : bytes_to_write;
  
 -	if (!intel_dp_is_edp(intel_dp))
 -		drm_dp_set_subconnector_property(connector,
 -						 status,
 -						 intel_dp->dpcd,
 -						 intel_dp->downstream_ports);
 -	return status;
 +		ret = drm_dp_dpcd_write(&dig_port->dp.aux,
 +					offset, (void *)byte, len);
 +		if (ret < 0)
 +			return ret;
 +
 +		bytes_to_write -= ret;
 +		byte += ret;
 +		offset += ret;
 +	}
 +
 +	return size;
  }
  
 -static void
 -intel_dp_force(struct drm_connector *connector)
 +static
 +ssize_t get_receiver_id_list_size(struct intel_digital_port *dig_port)
  {
 -	struct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));
 -	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
 -	struct intel_encoder *intel_encoder = &dig_port->base;
 -	struct drm_i915_private *dev_priv = to_i915(intel_encoder->base.dev);
 -	enum intel_display_power_domain aux_domain =
 -		intel_aux_power_domain(dig_port);
 -	intel_wakeref_t wakeref;
 +	u8 rx_info[HDCP_2_2_RXINFO_LEN];
 +	u32 dev_cnt;
 +	ssize_t ret;
  
 -	drm_dbg_kms(&dev_priv->drm, "[CONNECTOR:%d:%s]\n",
 -		    connector->base.id, connector->name);
 -	intel_dp_unset_edid(intel_dp);
 +	ret = drm_dp_dpcd_read(&dig_port->dp.aux,
 +			       DP_HDCP_2_2_REG_RXINFO_OFFSET,
 +			       (void *)rx_info, HDCP_2_2_RXINFO_LEN);
 +	if (ret != HDCP_2_2_RXINFO_LEN)
 +		return ret >= 0 ? -EIO : ret;
  
 -	if (connector->status != connector_status_connected)
 -		return;
 +	dev_cnt = (HDCP_2_2_DEV_COUNT_HI(rx_info[0]) << 4 |
 +		   HDCP_2_2_DEV_COUNT_LO(rx_info[1]));
  
 -	wakeref = intel_display_power_get(dev_priv, aux_domain);
 +	if (dev_cnt > HDCP_2_2_MAX_DEVICE_COUNT)
 +		dev_cnt = HDCP_2_2_MAX_DEVICE_COUNT;
  
 -	intel_dp_set_edid(intel_dp);
 +	ret = sizeof(struct hdcp2_rep_send_receiverid_list) -
 +		HDCP_2_2_RECEIVER_IDS_MAX_LEN +
 +		(dev_cnt * HDCP_2_2_RECEIVER_ID_LEN);
  
 -	intel_display_power_put(dev_priv, aux_domain, wakeref);
 +	return ret;
  }
  
 -static int intel_dp_get_modes(struct drm_connector *connector)
 +static
 +int intel_dp_hdcp2_read_msg(struct intel_digital_port *dig_port,
 +			    u8 msg_id, void *buf, size_t size)
  {
 -	struct intel_connector *intel_connector = to_intel_connector(connector);
 -	struct edid *edid;
 +	struct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);
 +	unsigned int offset;
 +	u8 *byte = buf;
 +	ssize_t ret, bytes_to_recv, len;
 +	const struct hdcp2_dp_msg_data *hdcp2_msg_data;
  
 -	edid = intel_connector->detect_edid;
 -	if (edid) {
 -		int ret = intel_connector_update_modes(connector, edid);
 -		if (ret)
 -			return ret;
 -	}
 +	hdcp2_msg_data = get_hdcp2_dp_msg_data(msg_id);
 +	if (!hdcp2_msg_data)
 +		return -EINVAL;
 +	offset = hdcp2_msg_data->offset;
  
 -	/* if eDP has no EDID, fall back to fixed mode */
 -	if (intel_dp_is_edp(intel_attached_dp(intel_connector)) &&
 -	    intel_connector->panel.fixed_mode) {
 -		struct drm_display_mode *mode;
 +	ret = intel_dp_hdcp2_wait_for_msg(dig_port, hdcp2_msg_data);
 +	if (ret < 0)
 +		return ret;
 +
 +	if (msg_id == HDCP_2_2_REP_SEND_RECVID_LIST) {
 +		ret = get_receiver_id_list_size(dig_port);
 +		if (ret < 0)
 +			return ret;
  
 -		mode = drm_mode_duplicate(connector->dev,
 -					  intel_connector->panel.fixed_mode);
 -		if (mode) {
 -			drm_mode_probed_add(connector, mode);
 -			return 1;
 -		}
 +		size = ret;
  	}
 +	bytes_to_recv = size - 1;
  
 -	if (!edid) {
 -		struct intel_dp *intel_dp = intel_attached_dp(intel_connector);
 -		struct drm_display_mode *mode;
 +	/* DP adaptation msgs has no msg_id */
 +	byte++;
  
 -		mode = drm_dp_downstream_mode(connector->dev,
 -					      intel_dp->dpcd,
 -					      intel_dp->downstream_ports);
 -		if (mode) {
 -			drm_mode_probed_add(connector, mode);
 -			return 1;
 +	while (bytes_to_recv) {
 +		len = bytes_to_recv > DP_AUX_MAX_PAYLOAD_BYTES ?
 +		      DP_AUX_MAX_PAYLOAD_BYTES : bytes_to_recv;
 +
 +		ret = drm_dp_dpcd_read(&dig_port->dp.aux, offset,
 +				       (void *)byte, len);
 +		if (ret < 0) {
 +			drm_dbg_kms(&i915->drm, "msg_id %d, ret %zd\n",
 +				    msg_id, ret);
 +			return ret;
  		}
 +
 +		bytes_to_recv -= ret;
 +		byte += ret;
 +		offset += ret;
  	}
 +	byte = buf;
 +	*byte = msg_id;
  
 -	return 0;
 +	return size;
  }
  
 -static int
 -intel_dp_connector_register(struct drm_connector *connector)
 +static
 +int intel_dp_hdcp2_config_stream_type(struct intel_digital_port *dig_port,
 +				      bool is_repeater, u8 content_type)
  {
 -	struct drm_i915_private *i915 = to_i915(connector->dev);
 -	struct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));
 -	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
 -	struct intel_lspcon *lspcon = &dig_port->lspcon;
  	int ret;
 +	struct hdcp2_dp_errata_stream_type stream_type_msg;
  
 -	ret = intel_connector_register(connector);
 -	if (ret)
 -		return ret;
 -
 -	drm_dbg_kms(&i915->drm, "registering %s bus for %s\n",
 -		    intel_dp->aux.name, connector->kdev->kobj.name);
 -
 -	intel_dp->aux.dev = connector->kdev;
 -	ret = drm_dp_aux_register(&intel_dp->aux);
 -	if (!ret)
 -		drm_dp_cec_register_connector(&intel_dp->aux, connector);
 -
 -	if (!intel_bios_is_lspcon_present(i915, dig_port->base.port))
 -		return ret;
 +	if (is_repeater)
 +		return 0;
  
  	/*
 -	 * ToDo: Clean this up to handle lspcon init and resume more
 -	 * efficiently and streamlined.
 +	 * Errata for DP: As Stream type is used for encryption, Receiver
 +	 * should be communicated with stream type for the decryption of the
 +	 * content.
 +	 * Repeater will be communicated with stream type as a part of it's
 +	 * auth later in time.
  	 */
 -	if (lspcon_init(dig_port)) {
 -		lspcon_detect_hdr_capability(lspcon);
 -		if (lspcon->hdr_supported)
 -			drm_object_attach_property(&connector->base,
 -						   connector->dev->mode_config.hdr_output_metadata_property,
 -						   0);
 -	}
 +	stream_type_msg.msg_id = HDCP_2_2_ERRATA_DP_STREAM_TYPE;
 +	stream_type_msg.stream_type = content_type;
  
 -	return ret;
 -}
 +	ret =  intel_dp_hdcp2_write_msg(dig_port, &stream_type_msg,
 +					sizeof(stream_type_msg));
  
 -static void
 -intel_dp_connector_unregister(struct drm_connector *connector)
 -{
 -	struct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));
 +	return ret < 0 ? ret : 0;
  
 -	drm_dp_cec_unregister_connector(&intel_dp->aux);
 -	drm_dp_aux_unregister(&intel_dp->aux);
 -	intel_connector_unregister(connector);
  }
  
 -void intel_dp_encoder_flush_work(struct drm_encoder *encoder)
 +static
 +int intel_dp_hdcp2_check_link(struct intel_digital_port *dig_port)
  {
 -	struct intel_digital_port *dig_port = enc_to_dig_port(to_intel_encoder(encoder));
 -	struct intel_dp *intel_dp = &dig_port->dp;
 +	u8 rx_status;
 +	int ret;
  
 -	intel_dp_mst_encoder_cleanup(dig_port);
 +	ret = intel_dp_hdcp2_read_rx_status(dig_port, &rx_status);
 +	if (ret)
 +		return ret;
  
 -	intel_pps_vdd_off_sync(intel_dp);
 +	if (HDCP_2_2_DP_RXSTATUS_REAUTH_REQ(rx_status))
 +		ret = HDCP_REAUTH_REQUEST;
 +	else if (HDCP_2_2_DP_RXSTATUS_LINK_FAILED(rx_status))
 +		ret = HDCP_LINK_INTEGRITY_FAILURE;
 +	else if (HDCP_2_2_DP_RXSTATUS_READY(rx_status))
 +		ret = HDCP_TOPOLOGY_CHANGE;
  
 -	intel_dp_aux_fini(intel_dp);
 +	return ret;
  }
  
 -static void intel_dp_encoder_destroy(struct drm_encoder *encoder)
 +static
 +int intel_dp_hdcp2_capable(struct intel_digital_port *dig_port,
 +			   bool *capable)
  {
 -	intel_dp_encoder_flush_work(encoder);
 +	u8 rx_caps[3];
 +	int ret;
  
 -	drm_encoder_cleanup(encoder);
 -	kfree(enc_to_dig_port(to_intel_encoder(encoder)));
 -}
 +	*capable = false;
 +	ret = drm_dp_dpcd_read(&dig_port->dp.aux,
 +			       DP_HDCP_2_2_REG_RX_CAPS_OFFSET,
 +			       rx_caps, HDCP_2_2_RXCAPS_LEN);
 +	if (ret != HDCP_2_2_RXCAPS_LEN)
 +		return ret >= 0 ? -EIO : ret;
  
 -void intel_dp_encoder_suspend(struct intel_encoder *intel_encoder)
 -{
 -	struct intel_dp *intel_dp = enc_to_intel_dp(intel_encoder);
 +	if (rx_caps[0] == HDCP_2_2_RX_CAPS_VERSION_VAL &&
 +	    HDCP_2_2_DP_HDCP_CAPABLE(rx_caps[2]))
 +		*capable = true;
  
 -	intel_pps_vdd_off_sync(intel_dp);
 +	return 0;
  }
  
 -void intel_dp_encoder_shutdown(struct intel_encoder *intel_encoder)
 +static const struct intel_hdcp_shim intel_dp_hdcp_shim = {
 +	.write_an_aksv = intel_dp_hdcp_write_an_aksv,
 +	.read_bksv = intel_dp_hdcp_read_bksv,
 +	.read_bstatus = intel_dp_hdcp_read_bstatus,
 +	.repeater_present = intel_dp_hdcp_repeater_present,
 +	.read_ri_prime = intel_dp_hdcp_read_ri_prime,
 +	.read_ksv_ready = intel_dp_hdcp_read_ksv_ready,
 +	.read_ksv_fifo = intel_dp_hdcp_read_ksv_fifo,
 +	.read_v_prime_part = intel_dp_hdcp_read_v_prime_part,
 +	.toggle_signalling = intel_dp_hdcp_toggle_signalling,
 +	.check_link = intel_dp_hdcp_check_link,
 +	.hdcp_capable = intel_dp_hdcp_capable,
 +	.write_2_2_msg = intel_dp_hdcp2_write_msg,
 +	.read_2_2_msg = intel_dp_hdcp2_read_msg,
 +	.config_stream_type = intel_dp_hdcp2_config_stream_type,
 +	.check_2_2_link = intel_dp_hdcp2_check_link,
 +	.hdcp_2_2_capable = intel_dp_hdcp2_capable,
 +	.protocol = HDCP_PROTOCOL_DP,
 +};
 +
 +static void intel_edp_panel_vdd_sanitize(struct intel_dp *intel_dp)
  {
 -	struct intel_dp *intel_dp = enc_to_intel_dp(intel_encoder);
 +	struct drm_i915_private *dev_priv = dp_to_i915(intel_dp);
 +	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
 +
 +	lockdep_assert_held(&dev_priv->pps_mutex);
 +
 +	if (!edp_have_panel_vdd(intel_dp))
 +		return;
  
 -	intel_pps_wait_power_cycle(intel_dp);
 +	/*
 +	 * The VDD bit needs a power domain reference, so if the bit is
 +	 * already enabled when we boot or resume, grab this reference and
 +	 * schedule a vdd off, so we don't hold on to the reference
 +	 * indefinitely.
 +	 */
 +	drm_dbg_kms(&dev_priv->drm,
 +		    "VDD left on by BIOS, adjusting state tracking\n");
 +	intel_display_power_get(dev_priv, intel_aux_power_domain(dig_port));
 +
 +	edp_panel_vdd_schedule_off(intel_dp);
  }
  
  static enum pipe vlv_active_pipe(struct intel_dp *intel_dp)
* Unmerged path drivers/gpu/drm/drm_dp_helper.c
diff --git a/drivers/gpu/drm/drm_dp_mst_topology.c b/drivers/gpu/drm/drm_dp_mst_topology.c
index 67dd72ea200e..5abea8f46a62 100644
--- a/drivers/gpu/drm/drm_dp_mst_topology.c
+++ b/drivers/gpu/drm/drm_dp_mst_topology.c
@@ -5578,8 +5578,7 @@ struct drm_dp_aux *drm_dp_mst_dsc_aux_for_port(struct drm_dp_mst_port *port)
 	if (drm_dp_read_desc(port->mgr->aux, &desc, true))
 		return NULL;
 
-	if (drm_dp_has_quirk(&desc, 0,
-			     DP_DPCD_QUIRK_DSC_WITHOUT_VIRTUAL_DPCD) &&
+	if (drm_dp_has_quirk(&desc, DP_DPCD_QUIRK_DSC_WITHOUT_VIRTUAL_DPCD) &&
 	    port->mgr->dpcd[DP_DPCD_REV] >= DP_DPCD_REV_14 &&
 	    port->parent == port->mgr->mst_primary) {
 		u8 downstreamport;
diff --git a/drivers/gpu/drm/i915/display/intel_display_types.h b/drivers/gpu/drm/i915/display/intel_display_types.h
index ab6e942224e3..7d191bed483e 100644
--- a/drivers/gpu/drm/i915/display/intel_display_types.h
+++ b/drivers/gpu/drm/i915/display/intel_display_types.h
@@ -1300,7 +1300,6 @@ struct intel_dp {
 	int max_link_rate;
 	/* sink or branch descriptor */
 	struct drm_dp_desc desc;
-	u32 edid_quirks;
 	struct drm_dp_aux aux;
 	u32 aux_busy_last_status;
 	u8 train_set[4];
* Unmerged path drivers/gpu/drm/i915/display/intel_dp.c
diff --git a/drivers/gpu/drm/i915/display/intel_dp_mst.c b/drivers/gpu/drm/i915/display/intel_dp_mst.c
index a2d91a499700..f43b39c5ea5c 100644
--- a/drivers/gpu/drm/i915/display/intel_dp_mst.c
+++ b/drivers/gpu/drm/i915/display/intel_dp_mst.c
@@ -51,8 +51,7 @@ static int intel_dp_mst_compute_link_config(struct intel_encoder *encoder,
 	struct drm_i915_private *i915 = to_i915(connector->base.dev);
 	const struct drm_display_mode *adjusted_mode =
 		&crtc_state->hw.adjusted_mode;
-	bool constant_n = drm_dp_has_quirk(&intel_dp->desc, 0,
-					   DP_DPCD_QUIRK_CONSTANT_N);
+	bool constant_n = drm_dp_has_quirk(&intel_dp->desc, DP_DPCD_QUIRK_CONSTANT_N);
 	int bpp, slots = -EINVAL;
 
 	crtc_state->lane_count = limits->max_lane_count;
diff --git a/drivers/gpu/drm/i915/display/intel_psr.c b/drivers/gpu/drm/i915/display/intel_psr.c
index dcd451219804..3635285ce61b 100644
--- a/drivers/gpu/drm/i915/display/intel_psr.c
+++ b/drivers/gpu/drm/i915/display/intel_psr.c
@@ -310,7 +310,7 @@ void intel_psr_init_dpcd(struct intel_dp *intel_dp)
 	drm_dbg_kms(&dev_priv->drm, "eDP panel supports PSR version %x\n",
 		    intel_dp->psr_dpcd[0]);
 
-	if (drm_dp_has_quirk(&intel_dp->desc, 0, DP_DPCD_QUIRK_NO_PSR)) {
+	if (drm_dp_has_quirk(&intel_dp->desc, DP_DPCD_QUIRK_NO_PSR)) {
 		drm_dbg_kms(&dev_priv->drm,
 			    "PSR support not currently available for this panel\n");
 		return;
diff --git a/include/drm/drm_dp_helper.h b/include/drm/drm_dp_helper.h
index e47dc22ebf50..c478ef2c2fec 100644
--- a/include/drm/drm_dp_helper.h
+++ b/include/drm/drm_dp_helper.h
@@ -1648,16 +1648,13 @@ struct drm_dp_desc {
 
 int drm_dp_read_desc(struct drm_dp_aux *aux, struct drm_dp_desc *desc,
 		     bool is_branch);
-u32 drm_dp_get_edid_quirks(const struct edid *edid);
 
 /**
  * enum drm_dp_quirk - Display Port sink/branch device specific quirks
  *
  * Display Port sink and branch devices in the wild have a variety of bugs, try
  * to collect them here. The quirks are shared, but it's up to the drivers to
- * implement workarounds for them. Note that because some devices have
- * unreliable OUIDs, the EDID of sinks should also be checked for quirks using
- * drm_dp_get_edid_quirks().
+ * implement workarounds for them.
  */
 enum drm_dp_quirk {
 	/**
@@ -1688,16 +1685,6 @@ enum drm_dp_quirk {
 	 * The DSC caps can be read from the physical aux instead.
 	 */
 	DP_DPCD_QUIRK_DSC_WITHOUT_VIRTUAL_DPCD,
-	/**
-	 * @DP_QUIRK_FORCE_DPCD_BACKLIGHT:
-	 *
-	 * The device is telling the truth when it says that it uses DPCD
-	 * backlight controls, even if the system's firmware disagrees. This
-	 * quirk should be checked against both the ident and panel EDID.
-	 * When present, the driver should honor the DPCD backlight
-	 * capabilities advertised.
-	 */
-	DP_QUIRK_FORCE_DPCD_BACKLIGHT,
 	/**
 	 * @DP_DPCD_QUIRK_CAN_DO_MAX_LINK_RATE_3_24_GBPS:
 	 *
@@ -1710,16 +1697,14 @@ enum drm_dp_quirk {
 /**
  * drm_dp_has_quirk() - does the DP device have a specific quirk
  * @desc: Device descriptor filled by drm_dp_read_desc()
- * @edid_quirks: Optional quirk bitmask filled by drm_dp_get_edid_quirks()
  * @quirk: Quirk to query for
  *
  * Return true if DP device identified by @desc has @quirk.
  */
 static inline bool
-drm_dp_has_quirk(const struct drm_dp_desc *desc, u32 edid_quirks,
-		 enum drm_dp_quirk quirk)
+drm_dp_has_quirk(const struct drm_dp_desc *desc, enum drm_dp_quirk quirk)
 {
-	return (desc->quirks | edid_quirks) & BIT(quirk);
+	return desc->quirks & BIT(quirk);
 }
 
 #ifdef CONFIG_DRM_DP_CEC
