netlink: add mask validation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-301.1.el8
commit-author Jakub Kicinski <kuba@kernel.org>
commit bdbb4e29df8b790db50cb73ce25d23543329f05f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-301.1.el8/bdbb4e29.failed

We don't have good validation policy for existing unsigned int attrs
which serve as flags (for new ones we could use NLA_BITFIELD32).
With increased use of policy dumping having the validation be
expressed as part of the policy is important. Add validation
policy in form of a mask of supported/valid bits.

Support u64 in the uAPI to be future-proof, but really for now
the embedded mask member can only hold 32 bits, so anything with
bit 32+ set will always fail validation.

	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bdbb4e29df8b790db50cb73ce25d23543329f05f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netlink.h
diff --cc include/net/netlink.h
index e9fce5130a10,2b9e41075f19..000000000000
--- a/include/net/netlink.h
+++ b/include/net/netlink.h
@@@ -200,14 -197,12 +200,19 @@@ struct netlink_range_validation_signed 
  enum nla_policy_validation {
  	NLA_VALIDATE_NONE,
  	NLA_VALIDATE_RANGE,
 -	NLA_VALIDATE_RANGE_WARN_TOO_LONG,
  	NLA_VALIDATE_MIN,
  	NLA_VALIDATE_MAX,
++<<<<<<< HEAD
++=======
+ 	NLA_VALIDATE_MASK,
+ 	NLA_VALIDATE_RANGE_PTR,
++>>>>>>> bdbb4e29df8b (netlink: add mask validation)
  	NLA_VALIDATE_FUNCTION,
 +	/* RHEL: any new enumerants need to be placed at the end to preserve
 +	 * KABI for older kernel modules.
 +	*/
 +	NLA_VALIDATE_RANGE_PTR,
 +	NLA_VALIDATE_WARN_TOO_LONG,
  };
  
  /**
@@@ -321,26 -313,12 +326,31 @@@
   * };
   */
  struct nla_policy {
 -	u8		type;
 -	u8		validation_type;
 +#ifdef __BIG_ENDIAN__
 +	RH_KABI_REPLACE_SPLIT(u16 type,
 +			      u8 validation_type,
 +			      u8 type)
 +#else
 +	RH_KABI_REPLACE_SPLIT(u16 type,
 +			      u8 type,
 +			      u8 validation_type)
 +#endif
  	u16		len;
 +#ifdef __GENKSYMS__
 +	void		*validation_data;
 +#else
  	union {
++<<<<<<< HEAD
 +		/* RHEL: Older binary modules expected validation_data pointer.
 +		 * To preserve backward compatibility we use u32*
 +		 * bitfield32_valid_ptr instead of upstream u32
 +		 * bitfield32_valid. Old modules can safe dereference it.
 +		 */
 +		const u32 *bitfield32_valid_ptr;
++=======
+ 		const u32 bitfield32_valid;
+ 		const u32 mask;
++>>>>>>> bdbb4e29df8b (netlink: add mask validation)
  		const char *reject_message;
  		const struct nla_policy *nested_policy;
  		struct netlink_range_validation *range;
@@@ -401,18 -371,18 +411,26 @@@ static_assert(offsetofend(struct nla_po
  
  #define __NLA_ENSURE(condition) BUILD_BUG_ON_ZERO(!(condition))
  #define NLA_ENSURE_UINT_TYPE(tp)			\
++<<<<<<< HEAD
 +	(__NLA_ENSURE(tp == NLA_U8 || tp == NLA_U16 ||	\
 +		      tp == NLA_U32 || tp == NLA_U64 ||	\
 +		      tp == NLA_MSECS) + tp)
++=======
+ 	(__NLA_ENSURE(__NLA_IS_UINT_TYPE(tp)) + tp)
+ #define NLA_ENSURE_UINT_OR_BINARY_TYPE(tp)		\
+ 	(__NLA_ENSURE(__NLA_IS_UINT_TYPE(tp) ||	\
+ 		      tp == NLA_MSECS ||		\
+ 		      tp == NLA_BINARY) + tp)
++>>>>>>> bdbb4e29df8b (netlink: add mask validation)
  #define NLA_ENSURE_SINT_TYPE(tp)			\
 -	(__NLA_ENSURE(__NLA_IS_SINT_TYPE(tp)) + tp)
 -#define NLA_ENSURE_INT_OR_BINARY_TYPE(tp)		\
 -	(__NLA_ENSURE(__NLA_IS_UINT_TYPE(tp) ||		\
 -		      __NLA_IS_SINT_TYPE(tp) ||		\
 -		      tp == NLA_MSECS ||		\
 -		      tp == NLA_BINARY) + tp)
 +	(__NLA_ENSURE(tp == NLA_S8 || tp == NLA_S16  ||	\
 +		      tp == NLA_S32 || tp == NLA_S64) + tp)
 +#define NLA_ENSURE_INT_TYPE(tp)				\
 +	(__NLA_ENSURE(tp == NLA_S8 || tp == NLA_U8 ||	\
 +		      tp == NLA_S16 || tp == NLA_U16 ||	\
 +		      tp == NLA_S32 || tp == NLA_U32 ||	\
 +		      tp == NLA_S64 || tp == NLA_U64 ||	\
 +		      tp == NLA_MSECS) + tp)
  #define NLA_ENSURE_NO_VALIDATION_PTR(tp)		\
  	(__NLA_ENSURE(tp != NLA_BITFIELD32 &&		\
  		      tp != NLA_REJECT &&		\
* Unmerged path include/net/netlink.h
diff --git a/include/uapi/linux/netlink.h b/include/uapi/linux/netlink.h
index eac8a6a648ea..d02e472ba54c 100644
--- a/include/uapi/linux/netlink.h
+++ b/include/uapi/linux/netlink.h
@@ -331,6 +331,7 @@ enum netlink_attribute_type {
  *	the index, if limited inside the nesting (U32)
  * @NL_POLICY_TYPE_ATTR_BITFIELD32_MASK: valid mask for the
  *	bitfield32 type (U32)
+ * @NL_POLICY_TYPE_ATTR_MASK: mask of valid bits for unsigned integers (U64)
  * @NL_POLICY_TYPE_ATTR_PAD: pad attribute for 64-bit alignment
  */
 enum netlink_policy_type_attr {
@@ -346,6 +347,7 @@ enum netlink_policy_type_attr {
 	NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE,
 	NL_POLICY_TYPE_ATTR_BITFIELD32_MASK,
 	NL_POLICY_TYPE_ATTR_PAD,
+	NL_POLICY_TYPE_ATTR_MASK,
 
 	/* keep last */
 	__NL_POLICY_TYPE_ATTR_MAX,
diff --git a/lib/nlattr.c b/lib/nlattr.c
index 161f70864b52..1cfe356fbcda 100644
--- a/lib/nlattr.c
+++ b/lib/nlattr.c
@@ -294,6 +294,37 @@ static int nla_validate_int_range(const struct nla_policy *pt,
 	}
 }
 
+static int nla_validate_mask(const struct nla_policy *pt,
+			     const struct nlattr *nla,
+			     struct netlink_ext_ack *extack)
+{
+	u64 value;
+
+	switch (pt->type) {
+	case NLA_U8:
+		value = nla_get_u8(nla);
+		break;
+	case NLA_U16:
+		value = nla_get_u16(nla);
+		break;
+	case NLA_U32:
+		value = nla_get_u32(nla);
+		break;
+	case NLA_U64:
+		value = nla_get_u64(nla);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (value & ~(u64)pt->mask) {
+		NL_SET_ERR_MSG_ATTR(extack, nla, "reserved bit set");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int validate_nla(const struct nlattr *nla, int maxtype,
 			const struct nla_policy *policy, unsigned int validate,
 			struct netlink_ext_ack *extack, unsigned int depth)
@@ -490,6 +521,11 @@ static int validate_nla(const struct nlattr *nla, int maxtype,
 		if (err)
 			return err;
 		break;
+	case NLA_VALIDATE_MASK:
+		err = nla_validate_mask(pt, nla, extack);
+		if (err)
+			return err;
+		break;
 	case NLA_VALIDATE_FUNCTION:
 		if (pt->validate) {
 			err = pt->validate(nla, extack);
diff --git a/net/netlink/policy.c b/net/netlink/policy.c
index e7447aea98a0..54a3852a0022 100644
--- a/net/netlink/policy.c
+++ b/net/netlink/policy.c
@@ -215,6 +215,14 @@ int netlink_policy_dump_write(struct sk_buff *skb, unsigned long _state)
 		else
 			type = NL_ATTR_TYPE_U64;
 
+		if (pt->validation_type == NLA_VALIDATE_MASK) {
+			if (nla_put_u64_64bit(skb, NL_POLICY_TYPE_ATTR_MASK,
+					      pt->mask,
+					      NL_POLICY_TYPE_ATTR_PAD))
+				goto nla_put_failure;
+			break;
+		}
+
 		nla_get_range_unsigned(pt, &range);
 
 		if (nla_put_u64_64bit(skb, NL_POLICY_TYPE_ATTR_MIN_VALUE_U,
