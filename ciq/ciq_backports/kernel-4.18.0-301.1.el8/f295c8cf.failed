drm/nouveau: fix dma syncing warning with debugging on.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-301.1.el8
Rebuild_CHGLOG: - [drm] drm/nouveau: fix dma syncing warning with debugging on (Lyude Paul) [1915548]
Rebuild_FUZZ: 99.08%
commit-author Dave Airlie <airlied@redhat.com>
commit f295c8cfec833c2707ff1512da10d65386dde7af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-301.1.el8/f295c8cf.failed

Since I wrote the below patch if you run a debug kernel you can a
dma debug warning like:
nouveau 0000:1f:00.0: DMA-API: device driver tries to sync DMA memory it has not allocated [device address=0x000000016e012000] [size=4096 bytes]

The old nouveau code wasn't consolidate the pages like the ttm code,
but the dma-debug expects the sync code to give it the same base/range
pairs as the allocator.

Fix the nouveau sync code to consolidate pages before calling the
sync code.

Fixes: bd549d35b4be0 ("nouveau: use ttm populate mapping functions. (v2)")
	Reported-by: Lyude Paul <lyude@redhat.com>
	Reviewed-by: Ben Skeggs <bskeggs@redhat.com>
	Signed-off-by: Dave Airlie <airlied@redhat.com>
Link: https://patchwork.freedesktop.org/patch/417588/
(cherry picked from commit f295c8cfec833c2707ff1512da10d65386dde7af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/nouveau_bo.c
diff --cc drivers/gpu/drm/nouveau/nouveau_bo.c
index 7806278dce57,7ea367a5444d..000000000000
--- a/drivers/gpu/drm/nouveau/nouveau_bo.c
+++ b/drivers/gpu/drm/nouveau/nouveau_bo.c
@@@ -539,8 -546,8 +539,13 @@@ voi
  nouveau_bo_sync_for_device(struct nouveau_bo *nvbo)
  {
  	struct nouveau_drm *drm = nouveau_bdev(nvbo->bo.bdev);
++<<<<<<< HEAD
 +	struct ttm_dma_tt *ttm_dma = (struct ttm_dma_tt *)nvbo->bo.ttm;
 +	int i;
++=======
+ 	struct ttm_tt *ttm_dma = (struct ttm_tt *)nvbo->bo.ttm;
+ 	int i, j;
++>>>>>>> f295c8cfec83 (drm/nouveau: fix dma syncing warning with debugging on.)
  
  	if (!ttm_dma)
  		return;
@@@ -549,18 -556,29 +554,38 @@@
  	if (nvbo->force_coherent)
  		return;
  
++<<<<<<< HEAD
 +	for (i = 0; i < ttm_dma->ttm.num_pages; i++)
++=======
+ 	for (i = 0; i < ttm_dma->num_pages; ++i) {
+ 		struct page *p = ttm_dma->pages[i];
+ 		size_t num_pages = 1;
+ 
+ 		for (j = i + 1; j < ttm_dma->num_pages; ++j) {
+ 			if (++p != ttm_dma->pages[j])
+ 				break;
+ 
+ 			++num_pages;
+ 		}
++>>>>>>> f295c8cfec83 (drm/nouveau: fix dma syncing warning with debugging on.)
  		dma_sync_single_for_device(drm->dev->dev,
  					   ttm_dma->dma_address[i],
- 					   PAGE_SIZE, DMA_TO_DEVICE);
+ 					   num_pages * PAGE_SIZE, DMA_TO_DEVICE);
+ 		i += num_pages;
+ 	}
  }
  
  void
  nouveau_bo_sync_for_cpu(struct nouveau_bo *nvbo)
  {
  	struct nouveau_drm *drm = nouveau_bdev(nvbo->bo.bdev);
++<<<<<<< HEAD
 +	struct ttm_dma_tt *ttm_dma = (struct ttm_dma_tt *)nvbo->bo.ttm;
 +	int i;
++=======
+ 	struct ttm_tt *ttm_dma = (struct ttm_tt *)nvbo->bo.ttm;
+ 	int i, j;
++>>>>>>> f295c8cfec83 (drm/nouveau: fix dma syncing warning with debugging on.)
  
  	if (!ttm_dma)
  		return;
@@@ -569,11 -587,43 +594,27 @@@
  	if (nvbo->force_coherent)
  		return;
  
++<<<<<<< HEAD
 +	for (i = 0; i < ttm_dma->ttm.num_pages; i++)
++=======
+ 	for (i = 0; i < ttm_dma->num_pages; ++i) {
+ 		struct page *p = ttm_dma->pages[i];
+ 		size_t num_pages = 1;
+ 
+ 		for (j = i + 1; j < ttm_dma->num_pages; ++j) {
+ 			if (++p != ttm_dma->pages[j])
+ 				break;
+ 
+ 			++num_pages;
+ 		}
+ 
++>>>>>>> f295c8cfec83 (drm/nouveau: fix dma syncing warning with debugging on.)
  		dma_sync_single_for_cpu(drm->dev->dev, ttm_dma->dma_address[i],
- 					PAGE_SIZE, DMA_FROM_DEVICE);
+ 					num_pages * PAGE_SIZE, DMA_FROM_DEVICE);
+ 		i += num_pages;
+ 	}
  }
  
 -void nouveau_bo_add_io_reserve_lru(struct ttm_buffer_object *bo)
 -{
 -	struct nouveau_drm *drm = nouveau_bdev(bo->bdev);
 -	struct nouveau_bo *nvbo = nouveau_bo(bo);
 -
 -	mutex_lock(&drm->ttm.io_reserve_mutex);
 -	list_move_tail(&nvbo->io_reserve_lru, &drm->ttm.io_reserve_lru);
 -	mutex_unlock(&drm->ttm.io_reserve_mutex);
 -}
 -
 -void nouveau_bo_del_io_reserve_lru(struct ttm_buffer_object *bo)
 -{
 -	struct nouveau_drm *drm = nouveau_bdev(bo->bdev);
 -	struct nouveau_bo *nvbo = nouveau_bo(bo);
 -
 -	mutex_lock(&drm->ttm.io_reserve_mutex);
 -	list_del_init(&nvbo->io_reserve_lru);
 -	mutex_unlock(&drm->ttm.io_reserve_mutex);
 -}
 -
  int
  nouveau_bo_validate(struct nouveau_bo *nvbo, bool interruptible,
  		    bool no_wait_gpu)
* Unmerged path drivers/gpu/drm/nouveau/nouveau_bo.c
