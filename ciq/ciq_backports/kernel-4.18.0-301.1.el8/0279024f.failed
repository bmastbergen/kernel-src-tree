SUNRPC: Fix up xdr_set_page()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-301.1.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 0279024f22705128c7139bd55af6981afe90e876
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-301.1.el8/0279024f.failed

While we always want to align to the next page and/or the beginning of
the tail buffer when we call xdr_set_next_page(), the functions
xdr_align_data() and xdr_expand_hole() really want to align to the next
object in that next page or tail.

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 0279024f22705128c7139bd55af6981afe90e876)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xdr.c
diff --cc net/sunrpc/xdr.c
index 194d16a7596a,ddd5cc2281ab..000000000000
--- a/net/sunrpc/xdr.c
+++ b/net/sunrpc/xdr.c
@@@ -1049,6 -1249,79 +1052,82 @@@ unsigned int xdr_read_pages(struct xdr_
  }
  EXPORT_SYMBOL_GPL(xdr_read_pages);
  
++<<<<<<< HEAD
++=======
+ uint64_t xdr_align_data(struct xdr_stream *xdr, uint64_t offset, uint32_t length)
+ {
+ 	struct xdr_buf *buf = xdr->buf;
+ 	unsigned int from, bytes;
+ 	unsigned int shift = 0;
+ 
+ 	if ((offset + length) < offset ||
+ 	    (offset + length) > buf->page_len)
+ 		length = buf->page_len - offset;
+ 
+ 	xdr_realign_pages(xdr);
+ 	from = xdr_page_pos(xdr);
+ 	bytes = xdr->nwords << 2;
+ 	if (length < bytes)
+ 		bytes = length;
+ 
+ 	/* Move page data to the left */
+ 	if (from > offset) {
+ 		shift = min_t(unsigned int, bytes, buf->page_len - from);
+ 		_shift_data_left_pages(buf->pages,
+ 				       buf->page_base + offset,
+ 				       buf->page_base + from,
+ 				       shift);
+ 		bytes -= shift;
+ 
+ 		/* Move tail data into the pages, if necessary */
+ 		if (bytes > 0)
+ 			_shift_data_left_tail(buf, offset + shift, bytes);
+ 	}
+ 
+ 	xdr->nwords -= XDR_QUADLEN(length);
+ 	xdr_set_page(xdr, from + length, xdr_stream_remaining(xdr));
+ 	return length;
+ }
+ EXPORT_SYMBOL_GPL(xdr_align_data);
+ 
+ uint64_t xdr_expand_hole(struct xdr_stream *xdr, uint64_t offset, uint64_t length)
+ {
+ 	struct xdr_buf *buf = xdr->buf;
+ 	unsigned int bytes;
+ 	unsigned int from;
+ 	unsigned int truncated = 0;
+ 
+ 	if ((offset + length) < offset ||
+ 	    (offset + length) > buf->page_len)
+ 		length = buf->page_len - offset;
+ 
+ 	xdr_realign_pages(xdr);
+ 	from = xdr_page_pos(xdr);
+ 	bytes = xdr->nwords << 2;
+ 
+ 	if (offset + length + bytes > buf->page_len) {
+ 		unsigned int shift = (offset + length + bytes) - buf->page_len;
+ 		unsigned int res = _shift_data_right_tail(buf, from + bytes - shift, shift);
+ 		truncated = shift - res;
+ 		xdr->nwords -= XDR_QUADLEN(truncated);
+ 		bytes -= shift;
+ 	}
+ 
+ 	/* Now move the page data over and zero pages */
+ 	if (bytes > 0)
+ 		_shift_data_right_pages(buf->pages,
+ 					buf->page_base + offset + length,
+ 					buf->page_base + from,
+ 					bytes);
+ 	_zero_pages(buf->pages, buf->page_base + offset, length);
+ 
+ 	buf->len += length - (from - offset) - truncated;
+ 	xdr_set_page(xdr, offset + length, xdr_stream_remaining(xdr));
+ 	return length;
+ }
+ EXPORT_SYMBOL_GPL(xdr_expand_hole);
+ 
++>>>>>>> 0279024f2270 (SUNRPC: Fix up xdr_set_page())
  /**
   * xdr_enter_page - decode data from the XDR page
   * @xdr: pointer to xdr_stream struct
* Unmerged path net/sunrpc/xdr.c
