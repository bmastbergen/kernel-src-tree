cpufreq: Avoid cpufreq_suspend() deadlock on system shutdown

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-301.1.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 65650b35133ff20f0c9ef0abd5c3c66dbce3ae57
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-301.1.el8/65650b35.failed

It is incorrect to set the cpufreq syscore shutdown callback pointer
to cpufreq_suspend(), because that function cannot be run in the
syscore stage of system shutdown for two reasons: (a) it may attempt
to carry out actions depending on devices that have already been shut
down at that point and (b) the RCU synchronization carried out by it
may not be able to make progress then.

The latter issue has been present since commit 45975c7d21a1 ("rcu:
Define RCU-sched API in terms of RCU for Tree RCU PREEMPT builds"),
but the former one has been there since commit 90de2a4aa9f3 ("cpufreq:
suspend cpufreq governors on shutdown") regardless.

Fix that by dropping cpufreq_syscore_ops altogether and making
device_shutdown() call cpufreq_suspend() directly before shutting
down devices, which is along the lines of what system-wide power
management does.

Fixes: 45975c7d21a1 ("rcu: Define RCU-sched API in terms of RCU for Tree RCU PREEMPT builds")
Fixes: 90de2a4aa9f3 ("cpufreq: suspend cpufreq governors on shutdown")
	Reported-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Tested-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
	Cc: 4.0+ <stable@vger.kernel.org> # 4.0+
(cherry picked from commit 65650b35133ff20f0c9ef0abd5c3c66dbce3ae57)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/core.c
diff --cc drivers/base/core.c
index 796e1d18eac5,7bd9cd366d41..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -3807,6 -3177,11 +3808,14 @@@ void device_shutdown(void
  {
  	struct device *dev, *parent;
  
++<<<<<<< HEAD
++=======
+ 	wait_for_device_probe();
+ 	device_block_probing();
+ 
+ 	cpufreq_suspend();
+ 
++>>>>>>> 65650b35133f (cpufreq: Avoid cpufreq_suspend() deadlock on system shutdown)
  	spin_lock(&devices_kset->list_lock);
  	/*
  	 * Walk the devices list backward, shutting down each in turn.
* Unmerged path drivers/base/core.c
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 7e3f92f413dd..ada168629d55 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -2777,14 +2777,6 @@ int cpufreq_unregister_driver(struct cpufreq_driver *driver)
 }
 EXPORT_SYMBOL_GPL(cpufreq_unregister_driver);
 
-/*
- * Stop cpufreq at shutdown to make sure it isn't holding any locks
- * or mutexes when secondary CPUs are halted.
- */
-static struct syscore_ops cpufreq_syscore_ops = {
-	.shutdown = cpufreq_suspend,
-};
-
 struct kobject *cpufreq_global_kobject;
 EXPORT_SYMBOL(cpufreq_global_kobject);
 
@@ -2796,8 +2788,6 @@ static int __init cpufreq_core_init(void)
 	cpufreq_global_kobject = kobject_create_and_add("cpufreq", &cpu_subsys.dev_root->kobj);
 	BUG_ON(!cpufreq_global_kobject);
 
-	register_syscore_ops(&cpufreq_syscore_ops);
-
 	return 0;
 }
 module_param(off, int, 0444);
