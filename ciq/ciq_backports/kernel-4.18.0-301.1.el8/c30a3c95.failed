netlink: policy: correct validation type check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-301.1.el8
commit-author Johannes Berg <johannes.berg@intel.com>
commit c30a3c957c885e618ddffc065f888be4f8d5a9bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-301.1.el8/c30a3c95.failed

In the policy export for binary attributes I erroneously used
a != NLA_VALIDATE_NONE comparison instead of checking for the
two possible values, which meant that if a validation function
pointer ended up aliasing the min/max as negatives, we'd hit
a warning in nla_get_range_unsigned().

Fix this to correctly check for only the two types that should
be handled here, i.e. range with or without warn-too-long.

	Reported-by: syzbot+353df1490da781637624@syzkaller.appspotmail.com
Fixes: 8aa26c575fb3 ("netlink: make NLA_BINARY validation more flexible")
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c30a3c957c885e618ddffc065f888be4f8d5a9bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netlink/policy.c
diff --cc net/netlink/policy.c
index e7447aea98a0,5c9e7530865f..000000000000
--- a/net/netlink/policy.c
+++ b/net/netlink/policy.c
@@@ -269,14 -263,27 +269,36 @@@ send_attribute
  			type = NL_ATTR_TYPE_NUL_STRING;
  		else
  			type = NL_ATTR_TYPE_BINARY;
++<<<<<<< HEAD
 +		if (pt->len && nla_put_u32(skb, NL_POLICY_TYPE_ATTR_MAX_LENGTH,
 +					   pt->len))
 +			goto nla_put_failure;
 +		break;
 +	case NLA_MIN_LEN:
 +		type = NL_ATTR_TYPE_BINARY;
 +		if (nla_put_u32(skb, NL_POLICY_TYPE_ATTR_MIN_LENGTH, pt->len))
++=======
+ 
+ 		if (pt->validation_type == NLA_VALIDATE_RANGE ||
+ 		    pt->validation_type == NLA_VALIDATE_RANGE_WARN_TOO_LONG) {
+ 			struct netlink_range_validation range;
+ 
+ 			nla_get_range_unsigned(pt, &range);
+ 
+ 			if (range.min &&
+ 			    nla_put_u32(skb, NL_POLICY_TYPE_ATTR_MIN_LENGTH,
+ 					range.min))
+ 				goto nla_put_failure;
+ 
+ 			if (range.max < U16_MAX &&
+ 			    nla_put_u32(skb, NL_POLICY_TYPE_ATTR_MAX_LENGTH,
+ 					range.max))
+ 				goto nla_put_failure;
+ 		} else if (pt->len &&
+ 			   nla_put_u32(skb, NL_POLICY_TYPE_ATTR_MAX_LENGTH,
+ 				       pt->len)) {
++>>>>>>> c30a3c957c88 (netlink: policy: correct validation type check)
  			goto nla_put_failure;
 -		}
  		break;
  	case NLA_FLAG:
  		type = NL_ATTR_TYPE_FLAG;
* Unmerged path net/netlink/policy.c
