net/mlx5e: CT: Use the same counter for both directions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-301.1.el8
commit-author Oz Shlomo <ozsh@mellanox.com>
commit 1edae2335adfa7006853e8b427f0c7c3f46b51dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-301.1.el8/1edae233.failed

A connection is represented by two 5-tuple entries, one for each direction.
Currently, each direction allocates its own hw counter, which is
inefficient as ct aging is managed per connection.

Share the counter that was allocated for the original direction with the
reverse direction.

	Signed-off-by: Oz Shlomo <ozsh@mellanox.com>
	Reviewed-by: Roi Dayan <roid@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 1edae2335adfa7006853e8b427f0c7c3f46b51dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
index 5ca0fb79498c,9a7bd681f8fe..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
@@@ -50,8 -51,11 +50,9 @@@ struct mlx5_tc_ct_priv 
  	struct mlx5_flow_table *ct_nat;
  	struct mlx5_flow_table *post_ct;
  	struct mutex control_lock; /* guards parallel adds/dels */
+ 	struct mutex shared_counter_lock;
  	struct mapping_ctx *zone_mapping;
  	struct mapping_ctx *labels_mapping;
 -	enum mlx5_flow_namespace_type ns_type;
 -	struct mlx5_fs_chains *chains;
  };
  
  struct mlx5_ct_flow {
@@@ -682,9 -696,9 +697,9 @@@ mlx5_tc_ct_entry_add_rule(struct mlx5_t
  		       MLX5_FLOW_CONTEXT_ACTION_COUNT;
  	attr->dest_chain = 0;
  	attr->dest_ft = ct_priv->post_ct;
 -	attr->ft = nat ? ct_priv->ct_nat : ct_priv->ct;
 +	attr->fdb = nat ? ct_priv->ct_nat : ct_priv->ct;
  	attr->outer_match_level = MLX5_MATCH_L4;
- 	attr->counter = entry->counter;
+ 	attr->counter = entry->shared_counter->counter;
  	attr->flags |= MLX5_ESW_ATTR_FLAG_NO_IN_PORT;
  
  	mlx5_tc_ct_set_tuple_match(netdev_priv(ct_priv->netdev), spec, flow_rule);
@@@ -834,7 -907,8 +904,12 @@@ mlx5_tc_ct_del_ft_entry(struct mlx5_tc_
  			struct mlx5_ct_entry *entry)
  {
  	mlx5_tc_ct_entry_del_rules(ct_priv, entry);
++<<<<<<< HEAD
 +	if (mlx5_tc_ct_entry_has_nat(entry))
++=======
+ 	mutex_lock(&ct_priv->shared_counter_lock);
+ 	if (entry->tuple_node.next)
++>>>>>>> 1edae2335adf (net/mlx5e: CT: Use the same counter for both directions)
  		rhashtable_remove_fast(&ct_priv->ct_tuples_nat_ht,
  				       &entry->tuple_nat_node,
  				       tuples_nat_ht_params);
@@@ -1891,10 -2009,9 +1970,11 @@@ mlx5_tc_ct_clean(struct mlx5_rep_uplink
  	rhashtable_destroy(&ct_priv->ct_tuples_nat_ht);
  	rhashtable_destroy(&ct_priv->zone_ht);
  	mutex_destroy(&ct_priv->control_lock);
+ 	mutex_destroy(&ct_priv->shared_counter_lock);
  	idr_destroy(&ct_priv->fte_ids);
  	kfree(ct_priv);
 +
 +	uplink_priv->ct_priv = NULL;
  }
  
  bool
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
