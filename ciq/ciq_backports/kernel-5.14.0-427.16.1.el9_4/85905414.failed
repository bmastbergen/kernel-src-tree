net: tls: handle backlogging of crypto requests

jira LE-1907
cve CVE-2024-26584
Rebuild_History Non-Buildable kernel-5.14.0-427.16.1.el9_4
commit-author Jakub Kicinski <kuba@kernel.org>
commit 8590541473188741055d27b955db0777569438e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.16.1.el9_4/85905414.failed

Since we're setting the CRYPTO_TFM_REQ_MAY_BACKLOG flag on our
requests to the crypto API, crypto_aead_{encrypt,decrypt} can return
 -EBUSY instead of -EINPROGRESS in valid situations. For example, when
the cryptd queue for AESNI is full (easy to trigger with an
artificially low cryptd.cryptd_max_cpu_qlen), requests will be enqueued
to the backlog but still processed. In that case, the async callback
will also be called twice: first with err == -EINPROGRESS, which it
seems we can just ignore, then with err == 0.

Compared to Sabrina's original patch this version uses the new
tls_*crypt_async_wait() helpers and converts the EBUSY to
EINPROGRESS to avoid having to modify all the error handling
paths. The handling is identical.

Fixes: a54667f6728c ("tls: Add support for encryption using async offload accelerator")
Fixes: 94524d8fc965 ("net/tls: Add support for async decryption of tls records")
Co-developed-by: Sabrina Dubroca <sd@queasysnail.net>
	Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
Link: https://lore.kernel.org/netdev/9681d1febfec295449a62300938ed2ae66983f28.1694018970.git.sd@queasysnail.net/
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
	Reviewed-by: Simon Horman <horms@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8590541473188741055d27b955db0777569438e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tls/tls_sw.c
diff --cc net/tls/tls_sw.c
index 4c918094226a,63bef5666e36..000000000000
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@@ -190,8 -194,24 +190,27 @@@ static void tls_decrypt_done(struct cry
  	struct scatterlist *sg;
  	unsigned int pages;
  	struct sock *sk;
 -	int aead_size;
  
++<<<<<<< HEAD
 +	sk = (struct sock *)req->data;
++=======
+ 	/* If requests get too backlogged crypto API returns -EBUSY and calls
+ 	 * ->complete(-EINPROGRESS) immediately followed by ->complete(0)
+ 	 * to make waiting for backlog to flush with crypto_wait_req() easier.
+ 	 * First wait converts -EBUSY -> -EINPROGRESS, and the second one
+ 	 * -EINPROGRESS -> 0.
+ 	 * We have a single struct crypto_async_request per direction, this
+ 	 * scheme doesn't help us, so just ignore the first ->complete().
+ 	 */
+ 	if (err == -EINPROGRESS)
+ 		return;
+ 
+ 	aead_size = sizeof(*aead_req) + crypto_aead_reqsize(aead);
+ 	aead_size = ALIGN(aead_size, __alignof__(*dctx));
+ 	dctx = (void *)((u8 *)aead_req + aead_size);
+ 
+ 	sk = dctx->sk;
++>>>>>>> 859054147318 (net: tls: handle backlogging of crypto requests)
  	tls_ctx = tls_get_ctx(sk);
  	ctx = tls_sw_ctx_rx(tls_ctx);
  
@@@ -420,22 -454,26 +443,28 @@@ tx_err
  	return rc;
  }
  
 -static void tls_encrypt_done(void *data, int err)
 +static void tls_encrypt_done(struct crypto_async_request *req, int err)
  {
 -	struct tls_sw_context_tx *ctx;
 -	struct tls_context *tls_ctx;
 -	struct tls_prot_info *prot;
 -	struct tls_rec *rec = data;
 +	struct aead_request *aead_req = (struct aead_request *)req;
 +	struct sock *sk = req->data;
 +	struct tls_context *tls_ctx = tls_get_ctx(sk);
 +	struct tls_prot_info *prot = &tls_ctx->prot_info;
 +	struct tls_sw_context_tx *ctx = tls_sw_ctx_tx(tls_ctx);
  	struct scatterlist *sge;
  	struct sk_msg *msg_en;
 -	struct sock *sk;
 +	struct tls_rec *rec;
 +	bool ready = false;
 +	int pending;
  
++<<<<<<< HEAD
 +	rec = container_of(aead_req, struct tls_rec, aead_req);
++=======
+ 	if (err == -EINPROGRESS) /* see the comment in tls_decrypt_done() */
+ 		return;
+ 
++>>>>>>> 859054147318 (net: tls: handle backlogging of crypto requests)
  	msg_en = &rec->msg_encrypted;
  
 -	sk = rec->sk;
 -	tls_ctx = tls_get_ctx(sk);
 -	prot = &tls_ctx->prot_info;
 -	ctx = tls_sw_ctx_tx(tls_ctx);
 -
  	sge = sk_msg_elem(msg_en, msg_en->sg.curr);
  	sge->offset -= prot->prepend_size;
  	sge->length += prot->prepend_size;
* Unmerged path net/tls/tls_sw.c
