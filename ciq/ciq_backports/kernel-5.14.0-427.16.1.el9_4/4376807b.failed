mm/mglru: reclaim offlined memcgs harder

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-427.16.1.el9_4
commit-author Yu Zhao <yuzhao@google.com>
commit 4376807bf2d5371c3e00080c972be568c3f8a7d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.16.1.el9_4/4376807b.failed

In the effort to reduce zombie memcgs [1], it was discovered that the
memcg LRU doesn't apply enough pressure on offlined memcgs.  Specifically,
instead of rotating them to the tail of the current generation
(MEMCG_LRU_TAIL) for a second attempt, it moves them to the next
generation (MEMCG_LRU_YOUNG) after the first attempt.

Not applying enough pressure on offlined memcgs can cause them to build
up, and this can be particularly harmful to memory-constrained systems.

On Pixel 8 Pro, launching apps for 50 cycles:
                 Before  After  Change
  Zombie memcgs  45      35     -22%

[1] https://lore.kernel.org/CABdmKX2M6koq4Q0Cmp_-=wbP0Qa190HdEGGaHfxNS05gAkUtPA@mail.gmail.com/

Link: https://lkml.kernel.org/r/20231208061407.2125867-4-yuzhao@google.com
Fixes: e4dde56cd208 ("mm: multi-gen LRU: per-node lru_gen_folio lists")
	Signed-off-by: Yu Zhao <yuzhao@google.com>
	Reported-by: T.J. Mercier <tjmercier@google.com>
	Tested-by: T.J. Mercier <tjmercier@google.com>
	Cc: Charan Teja Kalla <quic_charante@quicinc.com>
	Cc: Hillf Danton <hdanton@sina.com>
	Cc: Jaroslav Pulchart <jaroslav.pulchart@gooddata.com>
	Cc: Kairui Song <ryncsn@gmail.com>
	Cc: Kalesh Singh <kaleshsingh@google.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
(cherry picked from commit 4376807bf2d5371c3e00080c972be568c3f8a7d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mmzone.h
diff --cc include/linux/mmzone.h
index 0563a54dcea7,9db36e197712..000000000000
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@@ -514,21 -517,25 +514,29 @@@ void lru_gen_look_around(struct page_vm
   *
   * The events that trigger the above operations are:
   * 1. Exceeding the soft limit, which triggers MEMCG_LRU_HEAD;
 - * 2. The first attempt to reclaim a memcg below low, which triggers
 + * 2. The first attempt to reclaim an memcg below low, which triggers
   *    MEMCG_LRU_TAIL;
++<<<<<<< HEAD
 + * 3. The first attempt to reclaim an memcg below reclaimable size threshold,
 + *    which triggers MEMCG_LRU_TAIL;
 + * 4. The second attempt to reclaim an memcg below reclaimable size threshold,
 + *    which triggers MEMCG_LRU_YOUNG;
 + * 5. Attempting to reclaim an memcg below min, which triggers MEMCG_LRU_YOUNG;
++=======
+  * 3. The first attempt to reclaim a memcg offlined or below reclaimable size
+  *    threshold, which triggers MEMCG_LRU_TAIL;
+  * 4. The second attempt to reclaim a memcg offlined or below reclaimable size
+  *    threshold, which triggers MEMCG_LRU_YOUNG;
+  * 5. Attempting to reclaim a memcg below min, which triggers MEMCG_LRU_YOUNG;
++>>>>>>> 4376807bf2d5 (mm/mglru: reclaim offlined memcgs harder)
   * 6. Finishing the aging on the eviction path, which triggers MEMCG_LRU_YOUNG;
 - * 7. Offlining a memcg, which triggers MEMCG_LRU_OLD.
 + * 7. Offlining an memcg, which triggers MEMCG_LRU_OLD.
   *
 - * Notes:
 - * 1. Memcg LRU only applies to global reclaim, and the round-robin incrementing
 - *    of their max_seq counters ensures the eventual fairness to all eligible
 - *    memcgs. For memcg reclaim, it still relies on mem_cgroup_iter().
 - * 2. There are only two valid generations: old (seq) and young (seq+1).
 - *    MEMCG_NR_GENS is set to three so that when reading the generation counter
 - *    locklessly, a stale value (seq-1) does not wraparound to young.
 + * Note that memcg LRU only applies to global reclaim, and the round-robin
 + * incrementing of their max_seq counters ensures the eventual fairness to all
 + * eligible memcgs. For memcg reclaim, it still relies on mem_cgroup_iter().
   */
 -#define MEMCG_NR_GENS	3
 +#define MEMCG_NR_GENS	2
  #define MEMCG_NR_BINS	8
  
  struct lru_gen_memcg {
* Unmerged path include/linux/mmzone.h
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 78a303c2022b..b8a92c936e2e 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -5223,7 +5223,12 @@ static bool should_run_aging(struct lruvec *lruvec, unsigned long max_seq,
 	}
 
 	/* try to scrape all its memory if this memcg was deleted */
-	*nr_to_scan = mem_cgroup_online(memcg) ? (total >> sc->priority) : total;
+	if (!mem_cgroup_online(memcg)) {
+		*nr_to_scan = total;
+		return false;
+	}
+
+	*nr_to_scan = total >> sc->priority;
 
 	/*
 	 * The aging tries to be lazy to reduce the overhead, while the eviction
@@ -5323,14 +5328,9 @@ static int shrink_one(struct lruvec *lruvec, struct scan_control *sc)
 	bool success;
 	unsigned long scanned = sc->nr_scanned;
 	unsigned long reclaimed = sc->nr_reclaimed;
-	int seg = lru_gen_memcg_seg(lruvec);
 	struct mem_cgroup *memcg = lruvec_memcg(lruvec);
 	struct pglist_data *pgdat = lruvec_pgdat(lruvec);
 
-	/* see the comment on MEMCG_NR_GENS */
-	if (!lruvec_is_sizable(lruvec, sc))
-		return seg != MEMCG_LRU_TAIL ? MEMCG_LRU_TAIL : MEMCG_LRU_YOUNG;
-
 	mem_cgroup_calculate_protection(NULL, memcg);
 
 	if (mem_cgroup_below_min(NULL, memcg))
@@ -5338,7 +5338,7 @@ static int shrink_one(struct lruvec *lruvec, struct scan_control *sc)
 
 	if (mem_cgroup_below_low(NULL, memcg)) {
 		/* see the comment on MEMCG_NR_GENS */
-		if (seg != MEMCG_LRU_TAIL)
+		if (lru_gen_memcg_seg(lruvec) != MEMCG_LRU_TAIL)
 			return MEMCG_LRU_TAIL;
 
 		memcg_memory_event(memcg, MEMCG_LOW);
@@ -5355,7 +5355,15 @@ static int shrink_one(struct lruvec *lruvec, struct scan_control *sc)
 	sc->nr_reclaimed += current->reclaim_state->reclaimed_slab;
 	current->reclaim_state->reclaimed_slab = 0;
 
-	return success ? MEMCG_LRU_YOUNG : 0;
+	if (success && mem_cgroup_online(memcg))
+		return MEMCG_LRU_YOUNG;
+
+	if (!success && lruvec_is_sizable(lruvec, sc))
+		return 0;
+
+	/* one retry if offlined or too small */
+	return lru_gen_memcg_seg(lruvec) != MEMCG_LRU_TAIL ?
+	       MEMCG_LRU_TAIL : MEMCG_LRU_YOUNG;
 }
 
 #ifdef CONFIG_MEMCG
