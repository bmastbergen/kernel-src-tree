shmem: support idmapped mounts for tmpfs

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-427.16.1.el9_4
commit-author Giuseppe Scrivano <gscrivan@redhat.com>
commit 7a80e5b8c6fa7d0ae6624bd6aedc4a6a1cfc62fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.16.1.el9_4/7a80e5b8.failed

This patch enables idmapped mounts for tmpfs when CONFIG_SHMEM is defined.
Since all dedicated helpers for this functionality exist, in this
patch we just pass down the idmap argument from the VFS methods to the
relevant helpers.

	Signed-off-by: Giuseppe Scrivano <gscrivan@redhat.com>
	Tested-by: Christian Brauner (Microsoft) <brauner@kernel.org>
	Reviewed-by: Christian Brauner (Microsoft) <brauner@kernel.org>
	Reviewed-by: Seth Forshee (DigitalOcean) <sforshee@kernel.org>
	Signed-off-by: Christian Brauner (Microsoft) <brauner@kernel.org>
(cherry picked from commit 7a80e5b8c6fa7d0ae6624bd6aedc4a6a1cfc62fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/shmem.c
diff --cc mm/shmem.c
index f782851fdf9d,2fdd76ab337f..000000000000
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@@ -1072,9 -1068,9 +1072,13 @@@ static int shmem_getattr(struct user_na
  	stat->attributes_mask |= (STATX_ATTR_APPEND |
  			STATX_ATTR_IMMUTABLE |
  			STATX_ATTR_NODUMP);
++<<<<<<< HEAD
 +	generic_fillattr(&init_user_ns, inode, stat);
++=======
+ 	generic_fillattr(idmap, inode, stat);
++>>>>>>> 7a80e5b8c6fa (shmem: support idmapped mounts for tmpfs)
  
 -	if (shmem_is_huge(NULL, inode, 0, false))
 +	if (shmem_is_huge(inode, 0, false, NULL, 0))
  		stat->blksize = HPAGE_PMD_SIZE;
  
  	if (request_mask & STATX_BTIME) {
@@@ -1095,7 -1091,7 +1099,11 @@@ static int shmem_setattr(struct user_na
  	bool update_mtime = false;
  	bool update_ctime = true;
  
++<<<<<<< HEAD
 +	error = setattr_prepare(&init_user_ns, dentry, attr);
++=======
+ 	error = setattr_prepare(idmap, dentry, attr);
++>>>>>>> 7a80e5b8c6fa (shmem: support idmapped mounts for tmpfs)
  	if (error)
  		return error;
  
@@@ -1139,9 -1129,9 +1147,15 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	setattr_copy(&init_user_ns, inode, attr);
 +	if (attr->ia_valid & ATTR_MODE)
 +		error = posix_acl_chmod(&init_user_ns, inode, inode->i_mode);
++=======
+ 	setattr_copy(idmap, inode, attr);
+ 	if (attr->ia_valid & ATTR_MODE)
+ 		error = posix_acl_chmod(idmap, dentry, inode->i_mode);
++>>>>>>> 7a80e5b8c6fa (shmem: support idmapped mounts for tmpfs)
  	if (!error && update_ctime) {
  		inode->i_ctime = current_time(inode);
  		if (update_mtime)
@@@ -2365,7 -2344,7 +2380,11 @@@ static struct inode *shmem_get_inode(st
  	inode = new_inode(sb);
  	if (inode) {
  		inode->i_ino = ino;
++<<<<<<< HEAD
 +		inode_init_owner(&init_user_ns, inode, dir, mode);
++=======
+ 		inode_init_owner(idmap, inode, dir, mode);
++>>>>>>> 7a80e5b8c6fa (shmem: support idmapped mounts for tmpfs)
  		inode->i_blocks = 0;
  		inode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);
  		inode->i_generation = get_random_u32();
@@@ -2987,17 -2976,17 +3006,26 @@@ static int shmem_mkdir(struct user_name
  {
  	int error;
  
++<<<<<<< HEAD
 +	if ((error = shmem_mknod(&init_user_ns, dir, dentry,
 +				 mode | S_IFDIR, 0)))
++=======
+ 	error = shmem_mknod(idmap, dir, dentry, mode | S_IFDIR, 0);
+ 	if (error)
++>>>>>>> 7a80e5b8c6fa (shmem: support idmapped mounts for tmpfs)
  		return error;
  	inc_nlink(dir);
  	return 0;
  }
  
 -static int shmem_create(struct mnt_idmap *idmap, struct inode *dir,
 +static int shmem_create(struct user_namespace *mnt_userns, struct inode *dir,
  			struct dentry *dentry, umode_t mode, bool excl)
  {
++<<<<<<< HEAD
 +	return shmem_mknod(&init_user_ns, dir, dentry, mode | S_IFREG, 0);
++=======
+ 	return shmem_mknod(idmap, dir, dentry, mode | S_IFREG, 0);
++>>>>>>> 7a80e5b8c6fa (shmem: support idmapped mounts for tmpfs)
  }
  
  /*
@@@ -3067,7 -3056,7 +3095,11 @@@ static int shmem_whiteout(struct user_n
  	if (!whiteout)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	error = shmem_mknod(&init_user_ns, old_dir, whiteout,
++=======
+ 	error = shmem_mknod(idmap, old_dir, whiteout,
++>>>>>>> 7a80e5b8c6fa (shmem: support idmapped mounts for tmpfs)
  			    S_IFCHR | WHITEOUT_MODE, WHITEOUT_DEV);
  	dput(whiteout);
  	if (error)
@@@ -3110,7 -3099,7 +3142,11 @@@ static int shmem_rename2(struct user_na
  	if (flags & RENAME_WHITEOUT) {
  		int error;
  
++<<<<<<< HEAD
 +		error = shmem_whiteout(&init_user_ns, old_dir, old_dentry);
++=======
+ 		error = shmem_whiteout(idmap, old_dir, old_dentry);
++>>>>>>> 7a80e5b8c6fa (shmem: support idmapped mounts for tmpfs)
  		if (error)
  			return error;
  	}
* Unmerged path mm/shmem.c
