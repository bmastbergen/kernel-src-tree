x86/boot: Move x86_cache_alignment initialization to correct spot

jira LE-1907
Rebuild_History Non-Buildable kernel-5.14.0-427.16.1.el9_4
commit-author Dave Hansen <dave.hansen@linux.intel.com>
commit 3e32552652917f10c0aa8ac75cdc8f0b8d257dec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.16.1.el9_4/3e325526.failed

c->x86_cache_alignment is initialized from c->x86_clflush_size.
However, commit fbf6449f84bf moved c->x86_clflush_size initialization
to later in boot without moving the c->x86_cache_alignment assignment:

  fbf6449f84bf ("x86/sev-es: Set x86_virt_bits to the correct value straight away, instead of a two-phase approach")

This presumably left c->x86_cache_alignment set to zero for longer
than it should be.

The result was an oops on 32-bit kernels while accessing a pointer
at 0x20.  The 0x20 came from accessing a structure member at offset
0x10 (buffer->cpumask) from a ZERO_SIZE_PTR=0x10.  kmalloc() can
evidently return ZERO_SIZE_PTR when it's given 0 as its alignment
requirement.

Move the c->x86_cache_alignment initialization to be after
c->x86_clflush_size has an actual value.

Fixes: fbf6449f84bf ("x86/sev-es: Set x86_virt_bits to the correct value straight away, instead of a two-phase approach")
	Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
	Tested-by: Nathan Chancellor <nathan@kernel.org>
Link: https://lore.kernel.org/r/20231002220045.1014760-1-dave.hansen@linux.intel.com
(cherry picked from commit 3e32552652917f10c0aa8ac75cdc8f0b8d257dec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/common.c
diff --cc arch/x86/kernel/cpu/common.c
index ef417ca60542,9c51ad5bbf31..000000000000
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -1178,12 -1125,23 +1178,13 @@@ void get_cpu_address_sizes(struct cpuin
  
  		c->x86_virt_bits = (eax >> 8) & 0xff;
  		c->x86_phys_bits = eax & 0xff;
 -	} else {
 -		if (IS_ENABLED(CONFIG_X86_64)) {
 -			c->x86_clflush_size = 64;
 -			c->x86_phys_bits = 36;
 -			c->x86_virt_bits = 48;
 -		} else {
 -			c->x86_clflush_size = 32;
 -			c->x86_virt_bits = 32;
 -			c->x86_phys_bits = 32;
 -
 -			if (cpu_has(c, X86_FEATURE_PAE) ||
 -			    cpu_has(c, X86_FEATURE_PSE36))
 -				c->x86_phys_bits = 36;
 -		}
  	}
 +#ifdef CONFIG_X86_32
 +	else if (cpu_has(c, X86_FEATURE_PAE) || cpu_has(c, X86_FEATURE_PSE36))
 +		c->x86_phys_bits = 36;
 +#endif
  	c->x86_cache_bits = c->x86_phys_bits;
+ 	c->x86_cache_alignment = c->x86_clflush_size;
  }
  
  static void identify_cpu_without_cpuid(struct cpuinfo_x86 *c)
@@@ -1599,17 -1595,6 +1600,20 @@@ static void __init cpu_parse_early_para
   */
  static void __init early_identify_cpu(struct cpuinfo_x86 *c)
  {
++<<<<<<< HEAD
 +#ifdef CONFIG_X86_64
 +	c->x86_clflush_size = 64;
 +	c->x86_phys_bits = 36;
 +	c->x86_virt_bits = 48;
 +#else
 +	c->x86_clflush_size = 32;
 +	c->x86_phys_bits = 32;
 +	c->x86_virt_bits = 32;
 +#endif
 +	c->x86_cache_alignment = c->x86_clflush_size;
 +
++=======
++>>>>>>> 3e3255265291 (x86/boot: Move x86_cache_alignment initialization to correct spot)
  	memset(&c->x86_capability, 0, sizeof(c->x86_capability));
  	c->extended_cpuid_level = 0;
  
* Unmerged path arch/x86/kernel/cpu/common.c
