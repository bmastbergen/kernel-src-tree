GFS2: use kvfree() instead of open-coding it

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.99.1.el7
commit-author Al Viro <viro@ZenIV.linux.org.uk>
commit 3cdcf63ed2d169c82d70a506f3569e484cd9e7a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.99.1.el7/3cdcf63e.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

(cherry picked from commit 3cdcf63ed2d169c82d70a506f3569e484cd9e7a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/dir.c
diff --cc fs/gfs2/dir.c
index c5e83830a5cd,c247fed4a9a6..000000000000
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@@ -395,16 -387,9 +388,20 @@@ static __be64 *gfs2_dir_get_hash_table(
   */
  void gfs2_dir_hash_inval(struct gfs2_inode *ip)
  {
 -	__be64 *hc = ip->i_hash_cache;
 +	__be64 *hc;
 +
 +	spin_lock(&ip->i_inode.i_lock);
 +	hc = ip->i_hash_cache;
  	ip->i_hash_cache = NULL;
++<<<<<<< HEAD
 +	if (is_vmalloc_addr(hc))
 +		vfree(hc);
 +	else
 +		kfree(hc);
 +	spin_unlock(&ip->i_inode.i_lock);
++=======
+ 	kvfree(hc);
++>>>>>>> 3cdcf63ed2d1 (GFS2: use kvfree() instead of open-coding it)
  }
  
  static inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)
@@@ -1355,49 -1289,8 +1349,54 @@@ static void *gfs2_alloc_sort_buffer(uns
  	return ptr;
  }
  
++<<<<<<< HEAD
 +static void gfs2_free_sort_buffer(void *ptr)
 +{
 +	if (is_vmalloc_addr(ptr))
 +		vfree(ptr);
 +	else
 +		kfree(ptr);
 +}
 +
 +static int gfs2_set_cookies(struct gfs2_sbd *sdp, struct buffer_head *bh,
 +			    unsigned leaf_nr, struct gfs2_dirent **darr,
 +			    unsigned entries)
 +{
 +	int sort_id = -1;
 +	int i;
 +
 +	for (i = 0; i < entries; i++) {
 +		unsigned offset;
 +
 +		darr[i]->de_cookie = be32_to_cpu(darr[i]->de_hash);
 +		darr[i]->de_cookie = gfs2_disk_hash2offset(darr[i]->de_cookie);
 +
 +		if (!sdp->sd_args.ar_loccookie)
 +			continue;
 +		offset = (char *)(darr[i]) -
 +			(bh->b_data + gfs2_dirent_offset(sdp, bh->b_data));
 +		offset /= GFS2_MIN_DIRENT_SIZE;
 +		offset += leaf_nr * sdp->sd_max_dents_per_leaf;
 +		if (offset >= GFS2_USE_HASH_FLAG ||
 +		    leaf_nr >= GFS2_USE_HASH_FLAG) {
 +			darr[i]->de_cookie |= GFS2_USE_HASH_FLAG;
 +			if (sort_id < 0)
 +				sort_id = i;
 +			continue;
 +		}
 +		darr[i]->de_cookie &= GFS2_HASH_INDEX_MASK;
 +		darr[i]->de_cookie |= offset;
 +	}
 +	return sort_id;
 +}
 +
 +
 +static int gfs2_dir_read_leaf(struct inode *inode, u64 *offset, void *opaque,
 +			      filldir_t filldir, int *copied, unsigned *depth,
++=======
+ static int gfs2_dir_read_leaf(struct inode *inode, struct dir_context *ctx,
+ 			      int *copied, unsigned *depth,
++>>>>>>> 3cdcf63ed2d1 (GFS2: use kvfree() instead of open-coding it)
  			      u64 leaf_no)
  {
  	struct gfs2_inode *ip = GFS2_I(inode);
@@@ -1487,13 -1368,11 +1486,18 @@@
  	} while(lfn);
  
  	BUG_ON(entries2 != entries);
 -	error = do_filldir_main(ip, ctx, darr, entries, copied);
 +	error = do_filldir_main(ip, offset, opaque, filldir, darr, entries,
 +				need_sort ? sort_offset : entries, copied);
  out_free:
  	for(i = 0; i < leaf; i++)
++<<<<<<< HEAD
 +		if (larr[i])
 +			brelse(larr[i]);
 +	gfs2_free_sort_buffer(larr);
++=======
+ 		brelse(larr[i]);
+ 	kvfree(larr);
++>>>>>>> 3cdcf63ed2d1 (GFS2: use kvfree() instead of open-coding it)
  out:
  	return error;
  }
* Unmerged path fs/gfs2/dir.c
diff --git a/fs/gfs2/quota.c b/fs/gfs2/quota.c
index f60dc377d78c..ffbdb85ffe96 100644
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@ -1477,13 +1477,8 @@ void gfs2_quota_cleanup(struct gfs2_sbd *sdp)
 
 	gfs2_assert_warn(sdp, !atomic_read(&sdp->sd_quota_count));
 
-	if (sdp->sd_quota_bitmap) {
-		if (is_vmalloc_addr(sdp->sd_quota_bitmap))
-			vfree(sdp->sd_quota_bitmap);
-		else
-			kfree(sdp->sd_quota_bitmap);
-		sdp->sd_quota_bitmap = NULL;
-	}
+	kvfree(sdp->sd_quota_bitmap);
+	sdp->sd_quota_bitmap = NULL;
 }
 
 static void quotad_error(struct gfs2_sbd *sdp, const char *msg, int error)
