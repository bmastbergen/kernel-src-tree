netfilter: conntrack: avoid misleading 'invalid' in log message

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.99.1.el7
commit-author Florian Westphal <fw@strlen.de>
commit 07b5a76e18925a595bfef44531dbf2f397bb5507
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.99.1.el7/07b5a76e.failed

The packet is not flagged as invalid: conntrack will accept it and
its associated with the conntrack entry.

This happens e.g. when receiving a retransmitted SYN in SYN_RECV state.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 07b5a76e18925a595bfef44531dbf2f397bb5507)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_proto_tcp.c
diff --cc net/netfilter/nf_conntrack_proto_tcp.c
index 00cf1604f756,ec23330687a5..000000000000
--- a/net/netfilter/nf_conntrack_proto_tcp.c
+++ b/net/netfilter/nf_conntrack_proto_tcp.c
@@@ -1206,6 -834,354 +1206,357 @@@ static bool tcp_new(struct nf_conn *ct
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ /* Returns verdict for packet, or -1 for invalid. */
+ int nf_conntrack_tcp_packet(struct nf_conn *ct,
+ 			    struct sk_buff *skb,
+ 			    unsigned int dataoff,
+ 			    enum ip_conntrack_info ctinfo,
+ 			    const struct nf_hook_state *state)
+ {
+ 	struct net *net = nf_ct_net(ct);
+ 	struct nf_tcp_net *tn = nf_tcp_pernet(net);
+ 	struct nf_conntrack_tuple *tuple;
+ 	enum tcp_conntrack new_state, old_state;
+ 	unsigned int index, *timeouts;
+ 	enum ip_conntrack_dir dir;
+ 	const struct tcphdr *th;
+ 	struct tcphdr _tcph;
+ 	unsigned long timeout;
+ 
+ 	th = skb_header_pointer(skb, dataoff, sizeof(_tcph), &_tcph);
+ 	if (th == NULL)
+ 		return -NF_ACCEPT;
+ 
+ 	if (tcp_error(th, skb, dataoff, state))
+ 		return -NF_ACCEPT;
+ 
+ 	if (!nf_ct_is_confirmed(ct) && !tcp_new(ct, skb, dataoff, th))
+ 		return -NF_ACCEPT;
+ 
+ 	spin_lock_bh(&ct->lock);
+ 	old_state = ct->proto.tcp.state;
+ 	dir = CTINFO2DIR(ctinfo);
+ 	index = get_conntrack_index(th);
+ 	new_state = tcp_conntracks[dir][index][old_state];
+ 	tuple = &ct->tuplehash[dir].tuple;
+ 
+ 	switch (new_state) {
+ 	case TCP_CONNTRACK_SYN_SENT:
+ 		if (old_state < TCP_CONNTRACK_TIME_WAIT)
+ 			break;
+ 		/* RFC 1122: "When a connection is closed actively,
+ 		 * it MUST linger in TIME-WAIT state for a time 2xMSL
+ 		 * (Maximum Segment Lifetime). However, it MAY accept
+ 		 * a new SYN from the remote TCP to reopen the connection
+ 		 * directly from TIME-WAIT state, if..."
+ 		 * We ignore the conditions because we are in the
+ 		 * TIME-WAIT state anyway.
+ 		 *
+ 		 * Handle aborted connections: we and the server
+ 		 * think there is an existing connection but the client
+ 		 * aborts it and starts a new one.
+ 		 */
+ 		if (((ct->proto.tcp.seen[dir].flags
+ 		      | ct->proto.tcp.seen[!dir].flags)
+ 		     & IP_CT_TCP_FLAG_CLOSE_INIT)
+ 		    || (ct->proto.tcp.last_dir == dir
+ 		        && ct->proto.tcp.last_index == TCP_RST_SET)) {
+ 			/* Attempt to reopen a closed/aborted connection.
+ 			 * Delete this connection and look up again. */
+ 			spin_unlock_bh(&ct->lock);
+ 
+ 			/* Only repeat if we can actually remove the timer.
+ 			 * Destruction may already be in progress in process
+ 			 * context and we must give it a chance to terminate.
+ 			 */
+ 			if (nf_ct_kill(ct))
+ 				return -NF_REPEAT;
+ 			return NF_DROP;
+ 		}
+ 		fallthrough;
+ 	case TCP_CONNTRACK_IGNORE:
+ 		/* Ignored packets:
+ 		 *
+ 		 * Our connection entry may be out of sync, so ignore
+ 		 * packets which may signal the real connection between
+ 		 * the client and the server.
+ 		 *
+ 		 * a) SYN in ORIGINAL
+ 		 * b) SYN/ACK in REPLY
+ 		 * c) ACK in reply direction after initial SYN in original.
+ 		 *
+ 		 * If the ignored packet is invalid, the receiver will send
+ 		 * a RST we'll catch below.
+ 		 */
+ 		if (index == TCP_SYNACK_SET
+ 		    && ct->proto.tcp.last_index == TCP_SYN_SET
+ 		    && ct->proto.tcp.last_dir != dir
+ 		    && ntohl(th->ack_seq) == ct->proto.tcp.last_end) {
+ 			/* b) This SYN/ACK acknowledges a SYN that we earlier
+ 			 * ignored as invalid. This means that the client and
+ 			 * the server are both in sync, while the firewall is
+ 			 * not. We get in sync from the previously annotated
+ 			 * values.
+ 			 */
+ 			old_state = TCP_CONNTRACK_SYN_SENT;
+ 			new_state = TCP_CONNTRACK_SYN_RECV;
+ 			ct->proto.tcp.seen[ct->proto.tcp.last_dir].td_end =
+ 				ct->proto.tcp.last_end;
+ 			ct->proto.tcp.seen[ct->proto.tcp.last_dir].td_maxend =
+ 				ct->proto.tcp.last_end;
+ 			ct->proto.tcp.seen[ct->proto.tcp.last_dir].td_maxwin =
+ 				ct->proto.tcp.last_win == 0 ?
+ 					1 : ct->proto.tcp.last_win;
+ 			ct->proto.tcp.seen[ct->proto.tcp.last_dir].td_scale =
+ 				ct->proto.tcp.last_wscale;
+ 			ct->proto.tcp.last_flags &= ~IP_CT_EXP_CHALLENGE_ACK;
+ 			ct->proto.tcp.seen[ct->proto.tcp.last_dir].flags =
+ 				ct->proto.tcp.last_flags;
+ 			memset(&ct->proto.tcp.seen[dir], 0,
+ 			       sizeof(struct ip_ct_tcp_state));
+ 			break;
+ 		}
+ 		ct->proto.tcp.last_index = index;
+ 		ct->proto.tcp.last_dir = dir;
+ 		ct->proto.tcp.last_seq = ntohl(th->seq);
+ 		ct->proto.tcp.last_end =
+ 		    segment_seq_plus_len(ntohl(th->seq), skb->len, dataoff, th);
+ 		ct->proto.tcp.last_win = ntohs(th->window);
+ 
+ 		/* a) This is a SYN in ORIGINAL. The client and the server
+ 		 * may be in sync but we are not. In that case, we annotate
+ 		 * the TCP options and let the packet go through. If it is a
+ 		 * valid SYN packet, the server will reply with a SYN/ACK, and
+ 		 * then we'll get in sync. Otherwise, the server potentially
+ 		 * responds with a challenge ACK if implementing RFC5961.
+ 		 */
+ 		if (index == TCP_SYN_SET && dir == IP_CT_DIR_ORIGINAL) {
+ 			struct ip_ct_tcp_state seen = {};
+ 
+ 			ct->proto.tcp.last_flags =
+ 			ct->proto.tcp.last_wscale = 0;
+ 			tcp_options(skb, dataoff, th, &seen);
+ 			if (seen.flags & IP_CT_TCP_FLAG_WINDOW_SCALE) {
+ 				ct->proto.tcp.last_flags |=
+ 					IP_CT_TCP_FLAG_WINDOW_SCALE;
+ 				ct->proto.tcp.last_wscale = seen.td_scale;
+ 			}
+ 			if (seen.flags & IP_CT_TCP_FLAG_SACK_PERM) {
+ 				ct->proto.tcp.last_flags |=
+ 					IP_CT_TCP_FLAG_SACK_PERM;
+ 			}
+ 			/* Mark the potential for RFC5961 challenge ACK,
+ 			 * this pose a special problem for LAST_ACK state
+ 			 * as ACK is intrepretated as ACKing last FIN.
+ 			 */
+ 			if (old_state == TCP_CONNTRACK_LAST_ACK)
+ 				ct->proto.tcp.last_flags |=
+ 					IP_CT_EXP_CHALLENGE_ACK;
+ 		}
+ 		spin_unlock_bh(&ct->lock);
+ 		nf_ct_l4proto_log_invalid(skb, ct,
+ 					  "packet (index %d) in dir %d ignored, state %s",
+ 					  index, dir,
+ 					  tcp_conntrack_names[old_state]);
+ 		return NF_ACCEPT;
+ 	case TCP_CONNTRACK_MAX:
+ 		/* Special case for SYN proxy: when the SYN to the server or
+ 		 * the SYN/ACK from the server is lost, the client may transmit
+ 		 * a keep-alive packet while in SYN_SENT state. This needs to
+ 		 * be associated with the original conntrack entry in order to
+ 		 * generate a new SYN with the correct sequence number.
+ 		 */
+ 		if (nfct_synproxy(ct) && old_state == TCP_CONNTRACK_SYN_SENT &&
+ 		    index == TCP_ACK_SET && dir == IP_CT_DIR_ORIGINAL &&
+ 		    ct->proto.tcp.last_dir == IP_CT_DIR_ORIGINAL &&
+ 		    ct->proto.tcp.seen[dir].td_end - 1 == ntohl(th->seq)) {
+ 			pr_debug("nf_ct_tcp: SYN proxy client keep alive\n");
+ 			spin_unlock_bh(&ct->lock);
+ 			return NF_ACCEPT;
+ 		}
+ 
+ 		/* Invalid packet */
+ 		pr_debug("nf_ct_tcp: Invalid dir=%i index=%u ostate=%u\n",
+ 			 dir, get_conntrack_index(th), old_state);
+ 		spin_unlock_bh(&ct->lock);
+ 		nf_ct_l4proto_log_invalid(skb, ct, "invalid state");
+ 		return -NF_ACCEPT;
+ 	case TCP_CONNTRACK_TIME_WAIT:
+ 		/* RFC5961 compliance cause stack to send "challenge-ACK"
+ 		 * e.g. in response to spurious SYNs.  Conntrack MUST
+ 		 * not believe this ACK is acking last FIN.
+ 		 */
+ 		if (old_state == TCP_CONNTRACK_LAST_ACK &&
+ 		    index == TCP_ACK_SET &&
+ 		    ct->proto.tcp.last_dir != dir &&
+ 		    ct->proto.tcp.last_index == TCP_SYN_SET &&
+ 		    (ct->proto.tcp.last_flags & IP_CT_EXP_CHALLENGE_ACK)) {
+ 			/* Detected RFC5961 challenge ACK */
+ 			ct->proto.tcp.last_flags &= ~IP_CT_EXP_CHALLENGE_ACK;
+ 			spin_unlock_bh(&ct->lock);
+ 			nf_ct_l4proto_log_invalid(skb, ct, "challenge-ack ignored");
+ 			return NF_ACCEPT; /* Don't change state */
+ 		}
+ 		break;
+ 	case TCP_CONNTRACK_SYN_SENT2:
+ 		/* tcp_conntracks table is not smart enough to handle
+ 		 * simultaneous open.
+ 		 */
+ 		ct->proto.tcp.last_flags |= IP_CT_TCP_SIMULTANEOUS_OPEN;
+ 		break;
+ 	case TCP_CONNTRACK_SYN_RECV:
+ 		if (dir == IP_CT_DIR_REPLY && index == TCP_ACK_SET &&
+ 		    ct->proto.tcp.last_flags & IP_CT_TCP_SIMULTANEOUS_OPEN)
+ 			new_state = TCP_CONNTRACK_ESTABLISHED;
+ 		break;
+ 	case TCP_CONNTRACK_CLOSE:
+ 		if (index != TCP_RST_SET)
+ 			break;
+ 
+ 		if (ct->proto.tcp.seen[!dir].flags & IP_CT_TCP_FLAG_MAXACK_SET) {
+ 			u32 seq = ntohl(th->seq);
+ 
+ 			if (before(seq, ct->proto.tcp.seen[!dir].td_maxack)) {
+ 				/* Invalid RST  */
+ 				spin_unlock_bh(&ct->lock);
+ 				nf_ct_l4proto_log_invalid(skb, ct, "invalid rst");
+ 				return -NF_ACCEPT;
+ 			}
+ 
+ 			if (!nf_conntrack_tcp_established(ct) ||
+ 			    seq == ct->proto.tcp.seen[!dir].td_maxack)
+ 				break;
+ 
+ 			/* Check if rst is part of train, such as
+ 			 *   foo:80 > bar:4379: P, 235946583:235946602(19) ack 42
+ 			 *   foo:80 > bar:4379: R, 235946602:235946602(0)  ack 42
+ 			 */
+ 			if (ct->proto.tcp.last_index == TCP_ACK_SET &&
+ 			    ct->proto.tcp.last_dir == dir &&
+ 			    seq == ct->proto.tcp.last_end)
+ 				break;
+ 
+ 			/* ... RST sequence number doesn't match exactly, keep
+ 			 * established state to allow a possible challenge ACK.
+ 			 */
+ 			new_state = old_state;
+ 		}
+ 		if (((test_bit(IPS_SEEN_REPLY_BIT, &ct->status)
+ 			 && ct->proto.tcp.last_index == TCP_SYN_SET)
+ 			|| (!test_bit(IPS_ASSURED_BIT, &ct->status)
+ 			    && ct->proto.tcp.last_index == TCP_ACK_SET))
+ 		    && ntohl(th->ack_seq) == ct->proto.tcp.last_end) {
+ 			/* RST sent to invalid SYN or ACK we had let through
+ 			 * at a) and c) above:
+ 			 *
+ 			 * a) SYN was in window then
+ 			 * c) we hold a half-open connection.
+ 			 *
+ 			 * Delete our connection entry.
+ 			 * We skip window checking, because packet might ACK
+ 			 * segments we ignored. */
+ 			goto in_window;
+ 		}
+ 		break;
+ 	default:
+ 		/* Keep compilers happy. */
+ 		break;
+ 	}
+ 
+ 	if (!tcp_in_window(ct, &ct->proto.tcp, dir, index,
+ 			   skb, dataoff, th)) {
+ 		spin_unlock_bh(&ct->lock);
+ 		return -NF_ACCEPT;
+ 	}
+      in_window:
+ 	/* From now on we have got in-window packets */
+ 	ct->proto.tcp.last_index = index;
+ 	ct->proto.tcp.last_dir = dir;
+ 
+ 	pr_debug("tcp_conntracks: ");
+ 	nf_ct_dump_tuple(tuple);
+ 	pr_debug("syn=%i ack=%i fin=%i rst=%i old=%i new=%i\n",
+ 		 (th->syn ? 1 : 0), (th->ack ? 1 : 0),
+ 		 (th->fin ? 1 : 0), (th->rst ? 1 : 0),
+ 		 old_state, new_state);
+ 
+ 	ct->proto.tcp.state = new_state;
+ 	if (old_state != new_state
+ 	    && new_state == TCP_CONNTRACK_FIN_WAIT)
+ 		ct->proto.tcp.seen[dir].flags |= IP_CT_TCP_FLAG_CLOSE_INIT;
+ 
+ 	timeouts = nf_ct_timeout_lookup(ct);
+ 	if (!timeouts)
+ 		timeouts = tn->timeouts;
+ 
+ 	if (ct->proto.tcp.retrans >= tn->tcp_max_retrans &&
+ 	    timeouts[new_state] > timeouts[TCP_CONNTRACK_RETRANS])
+ 		timeout = timeouts[TCP_CONNTRACK_RETRANS];
+ 	else if (unlikely(index == TCP_RST_SET))
+ 		timeout = timeouts[TCP_CONNTRACK_CLOSE];
+ 	else if ((ct->proto.tcp.seen[0].flags | ct->proto.tcp.seen[1].flags) &
+ 		 IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED &&
+ 		 timeouts[new_state] > timeouts[TCP_CONNTRACK_UNACK])
+ 		timeout = timeouts[TCP_CONNTRACK_UNACK];
+ 	else if (ct->proto.tcp.last_win == 0 &&
+ 		 timeouts[new_state] > timeouts[TCP_CONNTRACK_RETRANS])
+ 		timeout = timeouts[TCP_CONNTRACK_RETRANS];
+ 	else
+ 		timeout = timeouts[new_state];
+ 	spin_unlock_bh(&ct->lock);
+ 
+ 	if (new_state != old_state)
+ 		nf_conntrack_event_cache(IPCT_PROTOINFO, ct);
+ 
+ 	if (!test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {
+ 		/* If only reply is a RST, we can consider ourselves not to
+ 		   have an established connection: this is a fairly common
+ 		   problem case, so we can delete the conntrack
+ 		   immediately.  --RR */
+ 		if (th->rst) {
+ 			nf_ct_kill_acct(ct, ctinfo, skb);
+ 			return NF_ACCEPT;
+ 		}
+ 		/* ESTABLISHED without SEEN_REPLY, i.e. mid-connection
+ 		 * pickup with loose=1. Avoid large ESTABLISHED timeout.
+ 		 */
+ 		if (new_state == TCP_CONNTRACK_ESTABLISHED &&
+ 		    timeout > timeouts[TCP_CONNTRACK_UNACK])
+ 			timeout = timeouts[TCP_CONNTRACK_UNACK];
+ 	} else if (!test_bit(IPS_ASSURED_BIT, &ct->status)
+ 		   && (old_state == TCP_CONNTRACK_SYN_RECV
+ 		       || old_state == TCP_CONNTRACK_ESTABLISHED)
+ 		   && new_state == TCP_CONNTRACK_ESTABLISHED) {
+ 		/* Set ASSURED if we see valid ack in ESTABLISHED
+ 		   after SYN_RECV or a valid answer for a picked up
+ 		   connection. */
+ 		set_bit(IPS_ASSURED_BIT, &ct->status);
+ 		nf_conntrack_event_cache(IPCT_ASSURED, ct);
+ 	}
+ 	nf_ct_refresh_acct(ct, ctinfo, skb, timeout);
+ 
+ 	return NF_ACCEPT;
+ }
+ 
+ static bool tcp_can_early_drop(const struct nf_conn *ct)
+ {
+ 	switch (ct->proto.tcp.state) {
+ 	case TCP_CONNTRACK_FIN_WAIT:
+ 	case TCP_CONNTRACK_LAST_ACK:
+ 	case TCP_CONNTRACK_TIME_WAIT:
+ 	case TCP_CONNTRACK_CLOSE:
+ 	case TCP_CONNTRACK_CLOSE_WAIT:
+ 		return true;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return false;
+ }
+ 
++>>>>>>> 07b5a76e1892 (netfilter: conntrack: avoid misleading 'invalid' in log message)
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  
  #include <linux/netfilter/nfnetlink.h>
* Unmerged path net/netfilter/nf_conntrack_proto_tcp.c
