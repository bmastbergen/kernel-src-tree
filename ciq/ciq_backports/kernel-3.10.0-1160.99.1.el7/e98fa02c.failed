sched/fair: Eliminate bandwidth race between throttling and distribution

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.99.1.el7
commit-author Paul Turner <pjt@google.com>
commit e98fa02c4f2ea4991dae422ac7e34d102d2f0599
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.99.1.el7/e98fa02c.failed

There is a race window in which an entity begins throttling before quota
is added to the pool, but does not finish throttling until after we have
finished with distribute_cfs_runtime(). This entity is not observed by
distribute_cfs_runtime() because it was not on the throttled list at the
time that distribution was running. This race manifests as rare
period-length statlls for such entities.

Rather than heavy-weight the synchronization with the progress of
distribution, we can fix this by aborting throttling if bandwidth has
become available. Otherwise, we immediately add the entity to the
throttled list so that it can be observed by a subsequent distribution.

Additionally, we can remove the case of adding the throttled entity to
the head of the throttled list, and simply always add to the tail.
Thanks to 26a8b12747c97, distribute_cfs_runtime() no longer holds onto
its own pool of runtime. This means that if we do hit the !assign and
distribute_running case, we know that distribution is about to end.

	Signed-off-by: Paul Turner <pjt@google.com>
	Signed-off-by: Ben Segall <bsegall@google.com>
	Signed-off-by: Josh Don <joshdon@google.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Phil Auld <pauld@redhat.com>
Link: https://lkml.kernel.org/r/20200410225208.109717-2-joshdon@google.com
(cherry picked from commit e98fa02c4f2ea4991dae422ac7e34d102d2f0599)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/fair.c
diff --cc kernel/sched/fair.c
index 5869b3fb548c,0c13a41bde81..000000000000
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@@ -3295,26 -4587,17 +3295,26 @@@ static inline struct cfs_bandwidth *tg_
  	return &tg->cfs_bandwidth;
  }
  
 +/* rq->task_clock normalized against any time this cfs_rq has spent throttled */
 +static inline u64 cfs_rq_clock_task(struct cfs_rq *cfs_rq)
 +{
 +	if (unlikely(cfs_rq->throttle_count))
 +		return cfs_rq->throttled_clock_task;
 +
 +	return rq_clock_task(rq_of(cfs_rq)) - cfs_rq->throttled_clock_task_time;
 +}
 +
  /* returns 0 on failure to allocate runtime */
- static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)
+ static int __assign_cfs_rq_runtime(struct cfs_bandwidth *cfs_b,
+ 				   struct cfs_rq *cfs_rq, u64 target_runtime)
  {
- 	struct task_group *tg = cfs_rq->tg;
- 	struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);
- 	u64 amount = 0, min_amount;
+ 	u64 min_amount, amount = 0;
+ 
+ 	lockdep_assert_held(&cfs_b->lock);
  
  	/* note: this is a positive sum as runtime_remaining <= 0 */
- 	min_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining;
+ 	min_amount = target_runtime - cfs_rq->runtime_remaining;
  
- 	raw_spin_lock(&cfs_b->lock);
  	if (cfs_b->quota == RUNTIME_INF)
  		amount = min_amount;
  	else {
@@@ -3424,8 -4721,28 +3436,33 @@@ static bool throttle_cfs_rq(struct cfs_
  	struct rq *rq = rq_of(cfs_rq);
  	struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);
  	struct sched_entity *se;
++<<<<<<< HEAD
 +	long task_delta, dequeue = 1;
 +	bool empty;
++=======
+ 	long task_delta, idle_task_delta, dequeue = 1;
+ 
+ 	raw_spin_lock(&cfs_b->lock);
+ 	/* This will start the period timer if necessary */
+ 	if (__assign_cfs_rq_runtime(cfs_b, cfs_rq, 1)) {
+ 		/*
+ 		 * We have raced with bandwidth becoming available, and if we
+ 		 * actually throttled the timer might not unthrottle us for an
+ 		 * entire period. We additionally needed to make sure that any
+ 		 * subsequent check_cfs_rq_runtime calls agree not to throttle
+ 		 * us, as we may commit to do cfs put_prev+pick_next, so we ask
+ 		 * for 1ns of runtime rather than just check cfs_b.
+ 		 */
+ 		dequeue = 0;
+ 	} else {
+ 		list_add_tail_rcu(&cfs_rq->throttled_list,
+ 				  &cfs_b->throttled_cfs_rq);
+ 	}
+ 	raw_spin_unlock(&cfs_b->lock);
+ 
+ 	if (!dequeue)
+ 		return false;  /* Throttle no longer required. */
++>>>>>>> e98fa02c4f2e (sched/fair: Eliminate bandwidth race between throttling and distribution)
  
  	se = cfs_rq->tg->se[cpu_of(rq_of(cfs_rq))];
  
@@@ -3450,31 -4774,15 +3487,39 @@@
  	}
  
  	if (!se)
 -		sub_nr_running(rq, task_delta);
 +		rq->nr_running -= task_delta;
  
+ 	/*
+ 	 * Note: distribution will already see us throttled via the
+ 	 * throttled-list.  rq->lock protects completion.
+ 	 */
  	cfs_rq->throttled = 1;
  	cfs_rq->throttled_clock = rq_clock(rq);
++<<<<<<< HEAD
 +	raw_spin_lock(&cfs_b->lock);
 +	empty = list_empty(&cfs_rq->throttled_list);
 +
 +	/*
 +	 * Add to the _head_ of the list, so that an already-started
 +	 * distribute_cfs_runtime will not see us. If disribute_cfs_runtime is
 +	 * not running add to the tail so that later runqueues don't get starved.
 +	 */
 +	if (cfs_b->distribute_running)
 +		list_add_rcu(&cfs_rq->throttled_list, &cfs_b->throttled_cfs_rq);
 +	else
 +		list_add_tail_rcu(&cfs_rq->throttled_list, &cfs_b->throttled_cfs_rq);
 +
 +	/*
 +	 * If we're the first throttled task, make sure the bandwidth
 +	 * timer is running.
 +	 */
 +	if (empty)
 +		start_cfs_bandwidth(cfs_b);
 +
 +	raw_spin_unlock(&cfs_b->lock);
++=======
+ 	return true;
++>>>>>>> e98fa02c4f2e (sched/fair: Eliminate bandwidth race between throttling and distribution)
  }
  
  void unthrottle_cfs_rq(struct cfs_rq *cfs_rq)
@@@ -3808,14 -5137,9 +3853,13 @@@ static bool check_cfs_rq_runtime(struc
  	if (cfs_rq_throttled(cfs_rq))
  		return true;
  
- 	throttle_cfs_rq(cfs_rq);
- 	return true;
+ 	return throttle_cfs_rq(cfs_rq);
  }
  
 +static inline u64 default_cfs_period(void);
 +static int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun);
 +static void do_sched_cfs_slack_timer(struct cfs_bandwidth *cfs_b);
 +
  static enum hrtimer_restart sched_cfs_slack_timer(struct hrtimer *timer)
  {
  	struct cfs_bandwidth *cfs_b =
* Unmerged path kernel/sched/fair.c
