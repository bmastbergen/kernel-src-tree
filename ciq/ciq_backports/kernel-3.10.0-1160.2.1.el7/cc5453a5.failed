netfilter: conntrack: allow sctp hearbeat after connection re-use

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.2.1.el7
commit-author Florian Westphal <fw@strlen.de>
commit cc5453a5b7e90c39f713091a7ebc53c1f87d1700
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.2.1.el7/cc5453a5.failed

If an sctp connection gets re-used, heartbeats are flagged as invalid
because their vtag doesn't match.

Handle this in a similar way as TCP conntrack when it suspects that the
endpoints and conntrack are out-of-sync.

When a HEARTBEAT request fails its vtag validation, flag this in the
conntrack state and accept the packet.

When a HEARTBEAT_ACK is received with an invalid vtag in the reverse
direction after we allowed such a HEARTBEAT through, assume we are
out-of-sync and re-set the vtag info.

v2: remove left-over snippet from an older incarnation that moved
    new_state/old_state assignments, thats not needed so keep that
    as-is.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit cc5453a5b7e90c39f713091a7ebc53c1f87d1700)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/nf_conntrack_sctp.h
#	net/netfilter/nf_conntrack_proto_sctp.c
diff --cc net/netfilter/nf_conntrack_proto_sctp.c
index f9d6353b98b9,810cca24b399..000000000000
--- a/net/netfilter/nf_conntrack_proto_sctp.c
+++ b/net/netfilter/nf_conntrack_proto_sctp.c
@@@ -330,8 -369,13 +332,9 @@@ static int sctp_packet(struct nf_conn *
  	const struct sctp_chunkhdr *sch;
  	struct sctp_chunkhdr _sch;
  	u_int32_t offset, count;
 -	unsigned int *timeouts;
  	unsigned long map[256 / sizeof(unsigned long)] = { 0 };
+ 	bool ignore = false;
  
 -	if (sctp_error(skb, dataoff, state))
 -		return -NF_ACCEPT;
 -
  	sh = skb_header_pointer(skb, dataoff, sizeof(_sctph), &_sctph);
  	if (sh == NULL)
  		goto out;
@@@ -418,6 -497,14 +445,17 @@@
  	}
  	spin_unlock_bh(&ct->lock);
  
++<<<<<<< HEAD
++=======
+ 	/* allow but do not refresh timeout */
+ 	if (ignore)
+ 		return NF_ACCEPT;
+ 
+ 	timeouts = nf_ct_timeout_lookup(ct);
+ 	if (!timeouts)
+ 		timeouts = nf_sctp_pernet(nf_ct_net(ct))->timeouts;
+ 
++>>>>>>> cc5453a5b7e9 (netfilter: conntrack: allow sctp hearbeat after connection re-use)
  	nf_ct_refresh_acct(ct, ctinfo, skb, timeouts[new_state]);
  
  	if (old_state == SCTP_CONNTRACK_COOKIE_ECHOED &&
* Unmerged path include/linux/netfilter/nf_conntrack_sctp.h
* Unmerged path include/linux/netfilter/nf_conntrack_sctp.h
* Unmerged path net/netfilter/nf_conntrack_proto_sctp.c
