x86/cpu: Add helper function to get the type of the current hybrid CPU

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-348.el8
commit-author Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
commit 250b3c0d79d1f4a55e54d8a9ef48058660483fef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-348.el8/250b3c0d.failed

On processors with Intel Hybrid Technology (i.e., one having more than
one type of CPU in the same package), all CPUs support the same
instruction set and enumerate the same features on CPUID. Thus, all
software can run on any CPU without restrictions. However, there may be
model-specific differences among types of CPUs. For instance, each type
of CPU may support a different number of performance counters. Also,
machine check error banks may be wired differently. Even though most
software will not care about these differences, kernel subsystems
dealing with these differences must know.

Add and expose a new helper function get_this_hybrid_cpu_type() to query
the type of the current hybrid CPU. The function will be used later in
the perf subsystem.

The Intel Software Developer's Manual defines the CPU type as 8-bit
identifier.

	Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Tony Luck <tony.luck@intel.com>
	Reviewed-by: Len Brown <len.brown@intel.com>
	Acked-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/1618237865-33448-3-git-send-email-kan.liang@linux.intel.com
(cherry picked from commit 250b3c0d79d1f4a55e54d8a9ef48058660483fef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/cpu.h
diff --cc arch/x86/include/asm/cpu.h
index 6b86b7dc620d,610905d7e541..000000000000
--- a/arch/x86/include/asm/cpu.h
+++ b/arch/x86/include/asm/cpu.h
@@@ -45,10 -45,9 +45,14 @@@ extern void __init sld_setup(struct cpu
  extern void switch_to_sld(unsigned long tifn);
  extern bool handle_user_split_lock(struct pt_regs *regs, long error_code);
  extern bool handle_guest_split_lock(unsigned long ip);
++<<<<<<< HEAD
 +extern void handle_kernel_split_lock(struct pt_regs *regs, long error_code);
 +extern void handle_bus_lock(struct pt_regs *regs);
++=======
+ u8 get_this_hybrid_cpu_type(void);
++>>>>>>> 250b3c0d79d1 (x86/cpu: Add helper function to get the type of the current hybrid CPU)
  #else
 -static inline void __init cpu_set_core_cap_bits(struct cpuinfo_x86 *c) {}
 +static inline void __init sld_setup(struct cpuinfo_x86 *c) {}
  static inline void switch_to_sld(unsigned long tifn) {}
  static inline bool handle_user_split_lock(struct pt_regs *regs, long error_code)
  {
@@@ -59,12 -58,15 +63,25 @@@ static inline bool handle_guest_split_l
  {
  	return false;
  }
++<<<<<<< HEAD
 +static inline void handle_kernel_split_lock(struct pt_regs *regs,
 +					    long error_code)
 +{
 +	return;
 +}
 +
 +static inline void handle_bus_lock(struct pt_regs *regs) {}
++=======
+ 
+ static inline u8 get_this_hybrid_cpu_type(void)
+ {
+ 	return 0;
+ }
+ #endif
+ #ifdef CONFIG_IA32_FEAT_CTL
+ void init_ia32_feat_ctl(struct cpuinfo_x86 *c);
+ #else
+ static inline void init_ia32_feat_ctl(struct cpuinfo_x86 *c) {}
++>>>>>>> 250b3c0d79d1 (x86/cpu: Add helper function to get the type of the current hybrid CPU)
  #endif
  #endif /* _ASM_X86_CPU_H */
* Unmerged path arch/x86/include/asm/cpu.h
diff --git a/arch/x86/kernel/cpu/intel.c b/arch/x86/kernel/cpu/intel.c
index 3a6478a936cd..afa387000727 100644
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@ -1435,3 +1435,19 @@ void __init sld_setup(struct cpuinfo_x86 *c)
 	sld_state_setup();
 	sld_state_show();
 }
+
+#define X86_HYBRID_CPU_TYPE_ID_SHIFT	24
+
+/**
+ * get_this_hybrid_cpu_type() - Get the type of this hybrid CPU
+ *
+ * Returns the CPU type [31:24] (i.e., Atom or Core) of a CPU in
+ * a hybrid processor. If the processor is not hybrid, returns 0.
+ */
+u8 get_this_hybrid_cpu_type(void)
+{
+	if (!cpu_feature_enabled(X86_FEATURE_HYBRID_CPU))
+		return 0;
+
+	return cpuid_eax(0x0000001a) >> X86_HYBRID_CPU_TYPE_ID_SHIFT;
+}
