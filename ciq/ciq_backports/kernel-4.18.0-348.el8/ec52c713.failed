arm64: cpufeature: Treat ID_AA64ZFR0_EL1 as RAZ when SVE is not enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-348.el8
commit-author Julien Grall <julien.grall@arm.com>
commit ec52c7134b1fcef0edfc56d55072fd4f261ef198
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-348.el8/ec52c713.failed

If CONFIG_ARM64_SVE=n then we fail to report ID_AA64ZFR0_EL1 as 0 when
read by userspace, despite being required by the architecture. Although
this is theoretically a change in ABI, userspace will first check for
the presence of SVE via the HWCAP or the ID_AA64PFR0_EL1.SVE field
before probing the ID_AA64ZFR0_EL1 register. Given that these are
reported correctly for this configuration, we can safely tighten up the
current behaviour.

Ensure ID_AA64ZFR0_EL1 is treated as RAZ when CONFIG_ARM64_SVE=n.

	Signed-off-by: Julien Grall <julien.grall@arm.com>
	Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
	Reviewed-by: Mark Rutland <mark.rutland@arm.com>
	Reviewed-by: Dave Martin <dave.martin@arm.com>
Fixes: 06a916feca2b ("arm64: Expose SVE2 features for userspace")
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit ec52c7134b1fcef0edfc56d55072fd4f261ef198)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/cpufeature.c
diff --cc arch/arm64/kernel/cpufeature.c
index 5c98a0b235b2,80f459ad0190..000000000000
--- a/arch/arm64/kernel/cpufeature.c
+++ b/arch/arm64/kernel/cpufeature.c
@@@ -187,25 -175,21 +187,42 @@@ static const struct arm64_ftr_bits ftr_
  	ARM64_FTR_END,
  };
  
++<<<<<<< HEAD
++=======
+ static const struct arm64_ftr_bits ftr_id_aa64zfr0[] = {
+ 	ARM64_FTR_BITS(FTR_VISIBLE_IF_IS_ENABLED(CONFIG_ARM64_SVE),
+ 		       FTR_STRICT, FTR_LOWER_SAFE, ID_AA64ZFR0_SM4_SHIFT, 4, 0),
+ 	ARM64_FTR_BITS(FTR_VISIBLE_IF_IS_ENABLED(CONFIG_ARM64_SVE),
+ 		       FTR_STRICT, FTR_LOWER_SAFE, ID_AA64ZFR0_SHA3_SHIFT, 4, 0),
+ 	ARM64_FTR_BITS(FTR_VISIBLE_IF_IS_ENABLED(CONFIG_ARM64_SVE),
+ 		       FTR_STRICT, FTR_LOWER_SAFE, ID_AA64ZFR0_BITPERM_SHIFT, 4, 0),
+ 	ARM64_FTR_BITS(FTR_VISIBLE_IF_IS_ENABLED(CONFIG_ARM64_SVE),
+ 		       FTR_STRICT, FTR_LOWER_SAFE, ID_AA64ZFR0_AES_SHIFT, 4, 0),
+ 	ARM64_FTR_BITS(FTR_VISIBLE_IF_IS_ENABLED(CONFIG_ARM64_SVE),
+ 		       FTR_STRICT, FTR_LOWER_SAFE, ID_AA64ZFR0_SVEVER_SHIFT, 4, 0),
+ 	ARM64_FTR_END,
+ };
+ 
++>>>>>>> ec52c7134b1f (arm64: cpufeature: Treat ID_AA64ZFR0_EL1 as RAZ when SVE is not enabled)
  static const struct arm64_ftr_bits ftr_id_aa64mmfr0[] = {
 +	/*
 +	 * Page size not being supported at Stage-2 is not fatal. You
 +	 * just give up KVM if PAGE_SIZE isn't supported there. Go fix
 +	 * your favourite nesting hypervisor.
 +	 *
 +	 * There is a small corner case where the hypervisor explicitly
 +	 * advertises a given granule size at Stage-2 (value 2) on some
 +	 * vCPUs, and uses the fallback to Stage-1 (value 0) for other
 +	 * vCPUs. Although this is not forbidden by the architecture, it
 +	 * indicates that the hypervisor is being silly (or buggy).
 +	 *
 +	 * We make no effort to cope with this and pretend that if these
 +	 * fields are inconsistent across vCPUs, then it isn't worth
 +	 * trying to bring KVM up.
 +	 */
 +	ARM64_FTR_BITS(FTR_HIDDEN, FTR_NONSTRICT, FTR_EXACT, ID_AA64MMFR0_TGRAN4_2_SHIFT, 4, 1),
 +	ARM64_FTR_BITS(FTR_HIDDEN, FTR_NONSTRICT, FTR_EXACT, ID_AA64MMFR0_TGRAN64_2_SHIFT, 4, 1),
 +	ARM64_FTR_BITS(FTR_HIDDEN, FTR_NONSTRICT, FTR_EXACT, ID_AA64MMFR0_TGRAN16_2_SHIFT, 4, 1),
  	/*
  	 * We already refuse to boot CPUs that don't support our configured
  	 * page size, so we can only detect mismatches for a page size other
* Unmerged path arch/arm64/kernel/cpufeature.c
