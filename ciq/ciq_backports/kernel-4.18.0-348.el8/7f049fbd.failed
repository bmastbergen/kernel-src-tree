perf/x86/intel/lbr: Zero the xstate buffer on allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-348.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 7f049fbdd57f6ea71dc741d903c19c73b2f70950
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-348.el8/7f049fbd.failed

XRSTORS requires a valid xstate buffer to work correctly. XSAVES does not
guarantee to write a fully valid buffer according to the SDM:

  "XSAVES does not write to any parts of the XSAVE header other than the
   XSTATE_BV and XCOMP_BV fields."

XRSTORS triggers a #GP:

  "If bytes 63:16 of the XSAVE header are not all zero."

It's dubious at best how this can work at all when the buffer is not zeroed
before use.

Allocate the buffers with __GFP_ZERO to prevent XRSTORS failure.

Fixes: ce711ea3cab9 ("perf/x86/intel/lbr: Support XSAVES/XRSTORS for LBR context switch")
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
Link: https://lore.kernel.org/r/87wnr0wo2z.ffs@nanos.tec.linutronix.de
(cherry picked from commit 7f049fbdd57f6ea71dc741d903c19c73b2f70950)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/events/intel/lbr.c
diff --cc arch/x86/events/intel/lbr.c
index d05b80c1c2dd,e8453de7a964..000000000000
--- a/arch/x86/events/intel/lbr.c
+++ b/arch/x86/events/intel/lbr.c
@@@ -675,6 -697,46 +675,49 @@@ void intel_pmu_lbr_add(struct perf_even
  		intel_pmu_lbr_reset();
  }
  
++<<<<<<< HEAD
++=======
+ void release_lbr_buffers(void)
+ {
+ 	struct kmem_cache *kmem_cache;
+ 	struct cpu_hw_events *cpuc;
+ 	int cpu;
+ 
+ 	if (!static_cpu_has(X86_FEATURE_ARCH_LBR))
+ 		return;
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		cpuc = per_cpu_ptr(&cpu_hw_events, cpu);
+ 		kmem_cache = x86_get_pmu(cpu)->task_ctx_cache;
+ 		if (kmem_cache && cpuc->lbr_xsave) {
+ 			kmem_cache_free(kmem_cache, cpuc->lbr_xsave);
+ 			cpuc->lbr_xsave = NULL;
+ 		}
+ 	}
+ }
+ 
+ void reserve_lbr_buffers(void)
+ {
+ 	struct kmem_cache *kmem_cache;
+ 	struct cpu_hw_events *cpuc;
+ 	int cpu;
+ 
+ 	if (!static_cpu_has(X86_FEATURE_ARCH_LBR))
+ 		return;
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		cpuc = per_cpu_ptr(&cpu_hw_events, cpu);
+ 		kmem_cache = x86_get_pmu(cpu)->task_ctx_cache;
+ 		if (!kmem_cache || cpuc->lbr_xsave)
+ 			continue;
+ 
+ 		cpuc->lbr_xsave = kmem_cache_alloc_node(kmem_cache,
+ 							GFP_KERNEL | __GFP_ZERO,
+ 							cpu_to_node(cpu));
+ 	}
+ }
+ 
++>>>>>>> 7f049fbdd57f (perf/x86/intel/lbr: Zero the xstate buffer on allocation)
  void intel_pmu_lbr_del(struct perf_event *event)
  {
  	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
* Unmerged path arch/x86/events/intel/lbr.c
