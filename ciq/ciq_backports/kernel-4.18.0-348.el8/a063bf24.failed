x86/fpu: Use proper mask to replace full instruction mask

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-348.el8
commit-author Kan Liang <kan.liang@linux.intel.com>
commit a063bf249b9f8d8004f282031781322c1b527d13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-348.el8/a063bf24.failed

When saving xstate to a kernel/user XSAVE area with the XSAVE family of
instructions, the current code applies the 'full' instruction mask (-1),
which tries to XSAVE all possible features. This method relies on
hardware to trim 'all possible' down to what is enabled in the
hardware. The code works well for now. However, there will be a
problem, if some features are enabled in hardware, but are not suitable
to be saved into all kernel XSAVE buffers, like task->fpu, due to
performance consideration.

One such example is the Last Branch Records (LBR) state. The LBR state
only contains valuable information when LBR is explicitly enabled by
the perf subsystem, and the size of an LBR state is large (808 bytes
for now). To avoid both CPU overhead and space overhead at each context
switch, the LBR state should not be saved into task->fpu like other
state components. It should be saved/restored on demand when LBR is
enabled in the perf subsystem. Current copy_xregs_to_* will trigger a
buffer overflow for such cases.

Three sites use the '-1' instruction mask which must be updated.

Two are saving/restoring the xstate to/from a kernel-allocated XSAVE
buffer and can use 'xfeatures_mask_all', which will save/restore all of
the features present in a normal task FPU buffer.

The last one saves the register state directly to a user buffer. It
could
also use 'xfeatures_mask_all'. Just as it was with the '-1' argument,
any supervisor states in the mask will be filtered out by the hardware
and not saved to the buffer.  But, to be more explicit about what is
expected to be saved, use xfeatures_mask_user() for the instruction
mask.

KVM includes the header file fpu/internal.h. To avoid 'undefined
xfeatures_mask_all' compiling issue, move copy_fpregs_to_fpstate() to
fpu/core.c and export it, because:
- The xfeatures_mask_all is indirectly used via copy_fpregs_to_fpstate()
  by KVM. The function which is directly used by other modules should be
  exported.
- The copy_fpregs_to_fpstate() is a function, while xfeatures_mask_all
  is a variable for the "internal" FPU state. It's safer to export a
  function than a variable, which may be implicitly changed by others.
- The copy_fpregs_to_fpstate() is a big function with many checks. The
  removal of the inline keyword should not impact the performance.

	Signed-off-by: Kan Liang <kan.liang@linux.intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Dave Hansen <dave.hansen@intel.com>
Link: https://lkml.kernel.org/r/1593780569-62993-20-git-send-email-kan.liang@linux.intel.com
(cherry picked from commit a063bf249b9f8d8004f282031781322c1b527d13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/fpu/internal.h
#	arch/x86/kernel/fpu/core.c
diff --cc arch/x86/include/asm/fpu/internal.h
index 2fc1ddf801dd,d3724dc8c5d2..000000000000
--- a/arch/x86/include/asm/fpu/internal.h
+++ b/arch/x86/include/asm/fpu/internal.h
@@@ -444,36 -411,7 +447,40 @@@ static inline int copy_kernel_to_xregs_
  	return err;
  }
  
++<<<<<<< HEAD
 +/*
 + * These must be called with preempt disabled. Returns
 + * 'true' if the FPU state is still intact and we can
 + * keep registers active.
 + *
 + * The legacy FNSAVE instruction cleared all FPU state
 + * unconditionally, so registers are essentially destroyed.
 + * Modern FPU state can be kept in registers, if there are
 + * no pending FP exceptions.
 + */
 +static inline int copy_fpregs_to_fpstate(struct fpu *fpu)
 +{
 +	if (likely(use_xsave())) {
 +		copy_xregs_to_kernel(&fpu->state.xsave);
 +		return 1;
 +	}
 +
 +	if (likely(use_fxsr())) {
 +		copy_fxregs_to_kernel(fpu);
 +		return 1;
 +	}
 +
 +	/*
 +	 * Legacy FPU register saving, FNSAVE always clears FPU registers,
 +	 * so we have to mark them inactive:
 +	 */
 +	asm volatile("fnsave %[fp]; fwait" : [fp] "=m" (fpu->state.fsave));
 +
 +	return 0;
 +}
++=======
+ extern int copy_fpregs_to_fpstate(struct fpu *fpu);
++>>>>>>> a063bf249b9f (x86/fpu: Use proper mask to replace full instruction mask)
  
  static inline void __copy_kernel_to_fpregs(union fpregs_state *fpstate, u64 mask)
  {
diff --cc arch/x86/kernel/fpu/core.c
index cd297e361ad3,1bb7532f5f34..000000000000
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@@ -81,7 -82,46 +81,50 @@@ bool irq_fpu_usable(void
  }
  EXPORT_SYMBOL(irq_fpu_usable);
  
++<<<<<<< HEAD
 +void kernel_fpu_begin_mask(unsigned int kfpu_mask)
++=======
+ /*
+  * These must be called with preempt disabled. Returns
+  * 'true' if the FPU state is still intact and we can
+  * keep registers active.
+  *
+  * The legacy FNSAVE instruction cleared all FPU state
+  * unconditionally, so registers are essentially destroyed.
+  * Modern FPU state can be kept in registers, if there are
+  * no pending FP exceptions.
+  */
+ int copy_fpregs_to_fpstate(struct fpu *fpu)
+ {
+ 	if (likely(use_xsave())) {
+ 		copy_xregs_to_kernel(&fpu->state.xsave);
+ 
+ 		/*
+ 		 * AVX512 state is tracked here because its use is
+ 		 * known to slow the max clock speed of the core.
+ 		 */
+ 		if (fpu->state.xsave.header.xfeatures & XFEATURE_MASK_AVX512)
+ 			fpu->avx512_timestamp = jiffies;
+ 		return 1;
+ 	}
+ 
+ 	if (likely(use_fxsr())) {
+ 		copy_fxregs_to_kernel(fpu);
+ 		return 1;
+ 	}
+ 
+ 	/*
+ 	 * Legacy FPU register saving, FNSAVE always clears FPU registers,
+ 	 * so we have to mark them inactive:
+ 	 */
+ 	asm volatile("fnsave %[fp]; fwait" : [fp] "=m" (fpu->state.fsave));
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(copy_fpregs_to_fpstate);
+ 
+ void kernel_fpu_begin(void)
++>>>>>>> a063bf249b9f (x86/fpu: Use proper mask to replace full instruction mask)
  {
  	preempt_disable();
  
* Unmerged path arch/x86/include/asm/fpu/internal.h
* Unmerged path arch/x86/kernel/fpu/core.c
