ACPICA: Store GPE register enable masks upfront

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.31.1.el7
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 0ee0d34985ceffe4036319e1e46df8bff591b9e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.31.1.el7/0ee0d349.failed

It is reported that ACPI interrupts do not work any more on
Dell Latitude D600 after commit c50f13c672df (ACPICA: Save
current masks of enabled GPEs after enable register writes).
The problem turns out to be related to the fact that the
enable_mask and enable_for_run GPE bit masks are not in
sync (in the absence of any system suspend/resume events)
for at least one GPE register on that machine.

Address this problem by writing the enable_for_run mask into
enable_mask as soon as enable_for_run is updated instead of
doing that only after the subsequent register write has
succeeded.  For consistency, update acpi_hw_gpe_enable_write()
to store the bit mask to be written into the GPE register
in enable_mask unconditionally before the write.

Since the ACPI_GPE_SAVE_MASK flag is not necessary any more after
that, drop it along with the symbols depending on it.

Reported-and-tested-by: Jim Bos <jim876@xs4all.nl>
Fixes: c50f13c672df (ACPICA: Save current masks of enabled GPEs after enable register writes)
	Cc: 3.19+ <stable@vger.kernel.org> # 3.19+
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 0ee0d34985ceffe4036319e1e46df8bff591b9e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/acpica/evgpe.c
#	drivers/acpi/acpica/hwgpe.c
diff --cc drivers/acpi/acpica/evgpe.c
index a604ae477e81,ccf793247447..000000000000
--- a/drivers/acpi/acpica/evgpe.c
+++ b/drivers/acpi/acpica/evgpe.c
@@@ -266,7 -203,7 +267,11 @@@ acpi_ev_remove_gpe_reference(struct acp
  		if (ACPI_SUCCESS(status)) {
  			status =
  			    acpi_hw_low_set_gpe(gpe_event_info,
++<<<<<<< HEAD
 +						     ACPI_GPE_DISABLE_SAVE);
++=======
+ 						ACPI_GPE_DISABLE);
++>>>>>>> 0ee0d34985ce (ACPICA: Store GPE register enable masks upfront)
  		}
  
  		if (ACPI_FAILURE(status)) {
diff --cc drivers/acpi/acpica/hwgpe.c
index e240e54e3d1c,73cfa5947ff3..000000000000
--- a/drivers/acpi/acpica/hwgpe.c
+++ b/drivers/acpi/acpica/hwgpe.c
@@@ -142,17 -148,9 +144,21 @@@ acpi_hw_low_set_gpe(struct acpi_gpe_eve
  		return (AE_BAD_PARAMETER);
  	}
  
 -	/* Write the updated enable mask */
 +	if (!(register_bit & gpe_register_info->mask_for_run)) {
 +
++<<<<<<< HEAD
 +		/* Write the updated enable mask */
  
 +		status =
 +		    acpi_hw_write(enable_mask,
 +				  &gpe_register_info->enable_address);
 +	}
 +	if (ACPI_SUCCESS(status) && (action & ACPI_GPE_SAVE_MASK)) {
 +		gpe_register_info->enable_mask = enable_mask;
 +	}
++=======
+ 	status = acpi_hw_write(enable_mask, &gpe_register_info->enable_address);
++>>>>>>> 0ee0d34985ce (ACPICA: Store GPE register enable masks upfront)
  	return (status);
  }
  
* Unmerged path drivers/acpi/acpica/evgpe.c
* Unmerged path drivers/acpi/acpica/hwgpe.c
diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h
index f2610ea0fe9f..fe4480a3f91c 100644
--- a/include/acpi/actypes.h
+++ b/include/acpi/actypes.h
@@ -725,10 +725,6 @@ typedef u32 acpi_event_status;
 #define ACPI_GPE_ENABLE                 0
 #define ACPI_GPE_DISABLE                1
 #define ACPI_GPE_CONDITIONAL_ENABLE     2
-#define ACPI_GPE_SAVE_MASK              4
-
-#define ACPI_GPE_ENABLE_SAVE            (ACPI_GPE_ENABLE | ACPI_GPE_SAVE_MASK)
-#define ACPI_GPE_DISABLE_SAVE           (ACPI_GPE_DISABLE | ACPI_GPE_SAVE_MASK)
 
 /*
  * GPE info flags - Per GPE
