exit: reparent: call forget_original_parent() under tasklist_lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.15.2.el7
commit-author Oleg Nesterov <oleg@redhat.com>
commit 482a3767e5087f6e6ad2486a6655aaa5f3d59301
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.15.2.el7/482a3767.failed

Shift "release dead children" loop from forget_original_parent() to its
caller, exit_notify().  It is safe to reap them even if our parent reaps
us right after we drop tasklist_lock, those children no longer have any
connection to the exiting task.

And this allows us to avoid write_lock_irq(tasklist_lock) right after it
was released by forget_original_parent(), we can simply call it with
tasklist_lock held.

While at it, move the comment about forget_original_parent() up to
this function.

	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Cc: Aaron Tomlin <atomlin@redhat.com>
	Cc: "Eric W. Biederman" <ebiederm@xmission.com>
	Cc: Sterling Alexander <stalexan@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 482a3767e5087f6e6ad2486a6655aaa5f3d59301)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/exit.c
diff --cc kernel/exit.c
index 0b8f83d6f20c,8061891ddd9b..000000000000
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@@ -682,41 -560,46 +682,78 @@@ static void reparent_leader(struct task
  	kill_orphaned_pgrp(p, father);
  }
  
- static void forget_original_parent(struct task_struct *father)
+ /*
+  * This does two things:
+  *
+  * A.  Make init inherit all the child processes
+  * B.  Check to see if any process groups have become orphaned
+  *	as a result of our exiting, and if they have any stopped
+  *	jobs, send them a SIGHUP and then a SIGCONT.  (POSIX 3.2.2.2)
+  */
+ static void forget_original_parent(struct task_struct *father,
+ 					struct list_head *dead)
  {
++<<<<<<< HEAD
 +	struct task_struct *p, *n, *reaper;
 +	LIST_HEAD(dead_children);
 +
 +	tasklist_write_lock_irq();
 +	/*
 +	 * Note that exit_ptrace() and find_new_reaper() might
 +	 * drop tasklist_lock and reacquire it.
 +	 */
 +	exit_ptrace(father);
 +	reaper = find_new_reaper(father);
 +
 +	list_for_each_entry_safe(p, n, &father->children, sibling) {
 +		struct task_struct *t = p;
 +		do {
++=======
+ 	struct task_struct *p, *t, *reaper;
+ 
+ 	if (unlikely(!list_empty(&father->ptraced)))
+ 		exit_ptrace(father, dead);
+ 
+ 	/* Can drop and reacquire tasklist_lock */
+ 	reaper = find_child_reaper(father);
+ 	if (list_empty(&father->children))
+ 		return;
+ 
+ 	reaper = find_new_reaper(father, reaper);
+ 	list_for_each_entry(p, &father->children, sibling) {
+ 		for_each_thread(p, t) {
++>>>>>>> 482a3767e508 (exit: reparent: call forget_original_parent() under tasklist_lock)
  			t->real_parent = reaper;
 -			BUG_ON((!t->ptrace) != (t->parent == father));
 -			if (likely(!t->ptrace))
 +			if (t->parent == father) {
 +				BUG_ON(t->ptrace);
  				t->parent = t->real_parent;
 +			}
  			if (t->pdeath_signal)
  				group_send_sig_info(t->pdeath_signal,
  						    SEND_SIG_NOINFO, t);
++<<<<<<< HEAD
 +		} while_each_thread(p, t);
 +		reparent_leader(father, p, &dead_children);
 +	}
 +	qwrite_unlock_irq(&tasklist_lock);
 +
 +	BUG_ON(!list_empty(&father->children));
 +
 +	list_for_each_entry_safe(p, n, &dead_children, sibling) {
 +		list_del_init(&p->sibling);
 +		release_task(p);
 +	}
++=======
+ 		}
+ 		/*
+ 		 * If this is a threaded reparent there is no need to
+ 		 * notify anyone anything has happened.
+ 		 */
+ 		if (!same_thread_group(reaper, father))
+ 			reparent_leader(father, p, dead);
+ 	}
+ 	list_splice_tail_init(&father->children, &reaper->children);
++>>>>>>> 482a3767e508 (exit: reparent: call forget_original_parent() under tasklist_lock)
  }
  
  /*
@@@ -726,18 -609,12 +763,27 @@@
  static void exit_notify(struct task_struct *tsk, int group_dead)
  {
  	bool autoreap;
++<<<<<<< HEAD
 +
 +	/*
 +	 * This does two things:
 +	 *
 +  	 * A.  Make init inherit all the child processes
 +	 * B.  Check to see if any process groups have become orphaned
 +	 *	as a result of our exiting, and if they have any stopped
 +	 *	jobs, send them a SIGHUP and then a SIGCONT.  (POSIX 3.2.2.2)
 +	 */
 +	forget_original_parent(tsk);
 +
 +	tasklist_write_lock_irq();
++=======
+ 	struct task_struct *p, *n;
+ 	LIST_HEAD(dead);
+ 
+ 	write_lock_irq(&tasklist_lock);
+ 	forget_original_parent(tsk, &dead);
+ 
++>>>>>>> 482a3767e508 (exit: reparent: call forget_original_parent() under tasklist_lock)
  	if (group_dead)
  		kill_orphaned_pgrp(tsk->group_leader, NULL);
  
@@@ -759,8 -636,13 +805,13 @@@
  	/* mt-exec, de_thread() is waiting for group leader */
  	if (unlikely(tsk->signal->notify_count < 0))
  		wake_up_process(tsk->signal->group_exit_task);
 -	write_unlock_irq(&tasklist_lock);
 +	qwrite_unlock_irq(&tasklist_lock);
  
+ 	list_for_each_entry_safe(p, n, &dead, ptrace_entry) {
+ 		list_del_init(&p->ptrace_entry);
+ 		release_task(p);
+ 	}
+ 
  	/* If the process is dead, release it - nobody will wait for it */
  	if (autoreap)
  		release_task(tsk);
* Unmerged path kernel/exit.c
