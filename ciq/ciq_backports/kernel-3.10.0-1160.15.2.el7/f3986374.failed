dm: simplify start of block stats accounting for bio-based

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.15.2.el7
commit-author Mike Snitzer <snitzer@redhat.com>
commit f3986374f94951b0fec6980e5b2dd621c51b215c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.15.2.el7/f3986374.failed

No apparent need to generic_start_io_acct() until before the IO is ready
for submission.  start_io_acct() is the proper place to do this
accounting -- it is also where DM accounts for pending IO and, if
enabled, starts dm-stats accounting.

Replace start_io_acct()'s part_round_stats() with generic_start_io_acct().
This eliminates needing to take part_stat_lock() multiple times when
starting an IO on bio-based devices.

	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit f3986374f94951b0fec6980e5b2dd621c51b215c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index 223507e1c998,cbb4ae5051fc..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -504,21 -598,20 +504,24 @@@ int md_in_flight(struct mapped_device *
  static void start_io_acct(struct dm_io *io)
  {
  	struct mapped_device *md = io->md;
++<<<<<<< HEAD
 +	struct bio *bio = io->bio;
 +	int cpu;
++=======
+ 	struct bio *bio = io->orig_bio;
++>>>>>>> f3986374f949 (dm: simplify start of block stats accounting for bio-based)
  	int rw = bio_data_dir(bio);
  
  	io->start_time = jiffies;
  
- 	cpu = part_stat_lock();
- 	part_round_stats(md->queue, cpu, &dm_disk(md)->part0);
- 	part_stat_unlock();
+ 	generic_start_io_acct(md->queue, rw, bio_sectors(bio), &dm_disk(md)->part0);
+ 
  	atomic_set(&dm_disk(md)->part0.in_flight[rw],
- 		atomic_inc_return(&md->pending[rw]));
+ 		   atomic_inc_return(&md->pending[rw]));
  
  	if (unlikely(dm_stats_used(&md->stats)))
 -		dm_stats_account_io(&md->stats, bio_data_dir(bio),
 -				    bio->bi_iter.bi_sector, bio_sectors(bio),
 -				    false, 0, &io->stats_aux);
 +		dm_stats_account_io(&md->stats, bio->bi_rw, bio->bi_sector,
 +				    bio_sectors(bio), false, 0, &io->stats_aux);
  }
  
  static void end_io_acct(struct dm_io *io)
@@@ -1589,24 -1549,17 +1592,26 @@@ out
  }
  
  /*
 - * The request function that remaps the bio to one target and
 - * splits off any remainder.
 + * The request function that just remaps the bio built up by
 + * dm_merge_bvec.
   */
 -static blk_qc_t dm_make_request(struct request_queue *q, struct bio *bio)
 +static void dm_make_request(struct request_queue *q, struct bio *bio)
  {
- 	int rw = bio_data_dir(bio);
  	struct mapped_device *md = q->queuedata;
 +	int cpu;
  	int srcu_idx;
  	struct dm_table *map;
  
  	map = dm_get_live_table(md, &srcu_idx);
  
++<<<<<<< HEAD
 +	cpu = part_stat_lock();
 +	part_stat_inc(cpu, &dm_disk(md)->part0, ios[rw]);
 +	part_stat_add(cpu, &dm_disk(md)->part0, sectors[rw], bio_sectors(bio));
 +	part_stat_unlock();
 +
++=======
++>>>>>>> f3986374f949 (dm: simplify start of block stats accounting for bio-based)
  	/* if we're suspended, we have to queue this io for later */
  	if (unlikely(test_bit(DMF_BLOCK_IO_FOR_SUSPEND, &md->flags))) {
  		dm_put_live_table(md, srcu_idx);
* Unmerged path drivers/md/dm.c
