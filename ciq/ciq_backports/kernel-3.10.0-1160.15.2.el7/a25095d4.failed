of: Move dynamic node fixups out of powerpc and into common code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.15.2.el7
Rebuild_CHGLOG: - [of] Move dynamic node fixups out of powerpc and into common code (Laurent Vivier) [1866138]
Rebuild_FUZZ: 96.77%
commit-author Grant Likely <grant.likely@linaro.org>
commit a25095d451ece23b1fef34474f3230100db7aa05
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.15.2.el7/a25095d4.failed

PowerPC does an odd thing with dynamic nodes. It uses a notifier to
catch new node additions and set some of the values like name and type.
This makes no sense since that same code can be put directly into
of_attach_node(). Besides, all dynamic node users need this, not just
powerpc. Fix this problem by moving the logic out of arch/powerpc and
into drivers/of/dynamic.c.

It is also important to remove this notifier because we want to move the
firing of notifiers from before the tree is modified to after so that
the receiver gets a consistent view of the tree, but that is
incompatible with notifiers that modify the node.

	Signed-off-by: Grant Likely <grant.likely@linaro.org>
	Cc: Nathan Fontenot <nfont@austin.ibm.com>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit a25095d451ece23b1fef34474f3230100db7aa05)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/prom.c
#	drivers/of/dynamic.c
#	drivers/of/of_private.h
diff --cc arch/powerpc/kernel/prom.c
index ae371dedede5,9e8d8a880d6f..000000000000
--- a/arch/powerpc/kernel/prom.c
+++ b/arch/powerpc/kernel/prom.c
@@@ -887,76 -821,6 +887,79 @@@ int cpu_to_chip_id(int cpu
  }
  EXPORT_SYMBOL(cpu_to_chip_id);
  
++<<<<<<< HEAD
 +#ifdef CONFIG_PPC_PSERIES
 +/*
 + * Fix up the uninitialized fields in a new device node:
 + * name, type and pci-specific fields
 + */
 +
 +static int of_finish_dynamic_node(struct device_node *node)
 +{
 +	struct device_node *parent = of_get_parent(node);
 +	int err = 0;
 +	const __be32 *ibm_phandle;
 +
 +	node->name = of_get_property(node, "name", NULL);
 +	node->type = of_get_property(node, "device_type", NULL);
 +
 +	if (!node->name)
 +		node->name = "<NULL>";
 +	if (!node->type)
 +		node->type = "<NULL>";
 +
 +	if (!parent) {
 +		err = -ENODEV;
 +		goto out;
 +	}
 +
 +	/* We don't support that function on PowerMac, at least
 +	 * not yet
 +	 */
 +	if (machine_is(powermac))
 +		return -ENODEV;
 +
 +	/* fix up new node's phandle field */
 +	if ((ibm_phandle = of_get_property(node, "ibm,phandle", NULL)))
 +		node->phandle = be32_to_cpup(ibm_phandle);
 +
 +out:
 +	of_node_put(parent);
 +	return err;
 +}
 +
 +static int prom_reconfig_notifier(struct notifier_block *nb,
 +				  unsigned long action, void *node)
 +{
 +	int err;
 +
 +	switch (action) {
 +	case OF_RECONFIG_ATTACH_NODE:
 +		err = of_finish_dynamic_node(node);
 +		if (err < 0)
 +			printk(KERN_ERR "finish_node returned %d\n", err);
 +		break;
 +	default:
 +		err = 0;
 +		break;
 +	}
 +	return notifier_from_errno(err);
 +}
 +
 +static struct notifier_block prom_reconfig_nb = {
 +	.notifier_call = prom_reconfig_notifier,
 +	.priority = 10, /* This one needs to run first */
 +};
 +
 +static int __init prom_reconfig_setup(void)
 +{
 +	return of_reconfig_notifier_register(&prom_reconfig_nb);
 +}
 +__initcall(prom_reconfig_setup);
 +#endif
 +
++=======
++>>>>>>> a25095d451ec (of: Move dynamic node fixups out of powerpc and into common code)
  bool arch_match_cpu_phys_id(int cpu, u64 phys_id)
  {
  	return (int)phys_id == get_hard_smp_processor_id(cpu);
diff --cc drivers/of/of_private.h
index 441609c4a66d,8129c0e58d70..000000000000
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@@ -31,9 -31,54 +31,59 @@@ struct alias_prop 
  	char stem[0];
  };
  
 -extern struct mutex of_mutex;
 +extern struct mutex of_aliases_mutex;
  extern struct list_head aliases_lookup;
++<<<<<<< HEAD
++=======
+ extern struct kset *of_kset;
+ 
+ 
+ static inline struct device_node *kobj_to_device_node(struct kobject *kobj)
+ {
+ 	return container_of(kobj, struct device_node, kobj);
+ }
+ 
+ #if defined(CONFIG_OF_DYNAMIC)
+ extern int of_property_notify(int action, struct device_node *np,
+ 			      struct property *prop);
+ extern void of_node_release(struct kobject *kobj);
+ #else /* CONFIG_OF_DYNAMIC */
+ static inline int of_property_notify(int action, struct device_node *np,
+ 				     struct property *prop)
+ {
+ 	return 0;
+ }
+ #endif /* CONFIG_OF_DYNAMIC */
+ 
+ /**
+  * General utilities for working with live trees.
+  *
+  * All functions with two leading underscores operate
+  * without taking node references, so you either have to
+  * own the devtree lock or work on detached trees only.
+  */
+ struct property *__of_prop_dup(const struct property *prop, gfp_t allocflags);
+ struct device_node *__of_node_alloc(const char *full_name, gfp_t allocflags);
+ 
+ extern const void *__of_get_property(const struct device_node *np,
+ 				     const char *name, int *lenp);
+ extern int __of_add_property(struct device_node *np, struct property *prop);
+ extern int __of_add_property_sysfs(struct device_node *np,
+ 		struct property *prop);
+ extern int __of_remove_property(struct device_node *np, struct property *prop);
+ extern void __of_remove_property_sysfs(struct device_node *np,
+ 		struct property *prop);
+ extern int __of_update_property(struct device_node *np,
+ 		struct property *newprop, struct property **oldprop);
+ extern void __of_update_property_sysfs(struct device_node *np,
+ 		struct property *newprop, struct property *oldprop);
+ 
+ extern void __of_attach_node(struct device_node *np);
+ extern int __of_attach_node_sysfs(struct device_node *np);
+ extern void __of_detach_node(struct device_node *np);
+ extern void __of_detach_node_sysfs(struct device_node *np);
++>>>>>>> a25095d451ec (of: Move dynamic node fixups out of powerpc and into common code)
  
 +extern void __of_sysfs_remove_bin_file(struct device_node *np,
 +				       struct property *prop);
  #endif /* _LINUX_OF_PRIVATE_H */
* Unmerged path drivers/of/dynamic.c
* Unmerged path arch/powerpc/kernel/prom.c
diff --git a/drivers/of/base.c b/drivers/of/base.c
index 7995688b8dbd..56fe4a36e507 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -390,8 +390,8 @@ EXPORT_SYMBOL(of_find_all_nodes);
  * Find a property with a given name for a given node
  * and return the value.
  */
-static const void *__of_get_property(const struct device_node *np,
-				     const char *name, int *lenp)
+const void *__of_get_property(const struct device_node *np,
+			      const char *name, int *lenp)
 {
 	struct property *pp = __of_find_property(np, name, lenp);
 
* Unmerged path drivers/of/dynamic.c
* Unmerged path drivers/of/of_private.h
