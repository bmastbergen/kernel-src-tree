mmap: relax file size limit for regular files

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.15.2.el7
commit-author Linus Torvalds <torvalds@linux-foundation.org>
commit 423913ad4ae5b3e8fb8983f70969fb522261ba26
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.15.2.el7/423913ad.failed

Commit be83bbf80682 ("mmap: introduce sane default mmap limits") was
introduced to catch problems in various ad-hoc character device drivers
doing mmap and getting the size limits wrong.  In the process, it used
"known good" limits for the normal cases of mapping regular files and
block device drivers.

It turns out that the "s_maxbytes" limit was less "known good" than I
thought.  In particular, /proc doesn't set it, but exposes one regular
file to mmap: /proc/vmcore.  As a result, that file got limited to the
default MAX_INT s_maxbytes value.

This went unnoticed for a while, because apparently the only thing that
needs it is the s390 kernel zfcpdump, but there might be other tools
that use this too.

Vasily suggested just changing s_maxbytes for all of /proc, which isn't
wrong, but makes me nervous at this stage.  So instead, just make the
new mmap limit always be MAX_LFS_FILESIZE for regular files, which won't
affect anything else.  It wasn't the regular file case I was worried
about.

I'd really prefer for maxsize to have been per-inode, but that is not
how things are today.

Fixes: be83bbf80682 ("mmap: introduce sane default mmap limits")
	Reported-by: Vasily Gorbik <gor@linux.ibm.com>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 423913ad4ae5b3e8fb8983f70969fb522261ba26)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/mmap.c
diff --cc mm/mmap.c
index 671e2ef2451d,fc41c0543d7f..000000000000
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@@ -1400,6 -1306,53 +1400,56 @@@ static inline unsigned long round_hint_
  	return hint;
  }
  
++<<<<<<< HEAD
++=======
+ static inline int mlock_future_check(struct mm_struct *mm,
+ 				     unsigned long flags,
+ 				     unsigned long len)
+ {
+ 	unsigned long locked, lock_limit;
+ 
+ 	/*  mlock MCL_FUTURE? */
+ 	if (flags & VM_LOCKED) {
+ 		locked = len >> PAGE_SHIFT;
+ 		locked += mm->locked_vm;
+ 		lock_limit = rlimit(RLIMIT_MEMLOCK);
+ 		lock_limit >>= PAGE_SHIFT;
+ 		if (locked > lock_limit && !capable(CAP_IPC_LOCK))
+ 			return -EAGAIN;
+ 	}
+ 	return 0;
+ }
+ 
+ static inline u64 file_mmap_size_max(struct file *file, struct inode *inode)
+ {
+ 	if (S_ISREG(inode->i_mode))
+ 		return MAX_LFS_FILESIZE;
+ 
+ 	if (S_ISBLK(inode->i_mode))
+ 		return MAX_LFS_FILESIZE;
+ 
+ 	/* Special "we do even unsigned file positions" case */
+ 	if (file->f_mode & FMODE_UNSIGNED_OFFSET)
+ 		return 0;
+ 
+ 	/* Yes, random drivers might want more. But I'm tired of buggy drivers */
+ 	return ULONG_MAX;
+ }
+ 
+ static inline bool file_mmap_ok(struct file *file, struct inode *inode,
+ 				unsigned long pgoff, unsigned long len)
+ {
+ 	u64 maxsize = file_mmap_size_max(file, inode);
+ 
+ 	if (maxsize && len > maxsize)
+ 		return false;
+ 	maxsize -= len;
+ 	if (pgoff > maxsize >> PAGE_SHIFT)
+ 		return false;
+ 	return true;
+ }
+ 
++>>>>>>> 423913ad4ae5 (mmap: relax file size limit for regular files)
  /*
   * The caller must hold down_write(&current->mm->mmap_sem).
   */
* Unmerged path mm/mmap.c
