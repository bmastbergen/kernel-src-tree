x86/cpu: Factor out application of forced CPU caps

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.11.1.el7
Rebuild_CHGLOG: - [x86] cpu: Factor out application of forced CPU caps (Herbert Xu) [1886792]
Rebuild_FUZZ: 95.83%
commit-author Andy Lutomirski <luto@kernel.org>
commit 8bf1ebca215c262e48c15a4a15f175991776f57f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.11.1.el7/8bf1ebca.failed

There are multiple call sites that apply forced CPU caps.  Factor
them into a helper.

	Signed-off-by: Andy Lutomirski <luto@kernel.org>
	Reviewed-by: Borislav Petkov <bp@suse.de>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Fenghua Yu <fenghua.yu@intel.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Matthew Whitehead <tedheadster@gmail.com>
	Cc: Oleg Nesterov <oleg@redhat.com>
	Cc: One Thousand Gnomes <gnomes@lxorguk.ukuu.org.uk>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Yu-cheng Yu <yu-cheng.yu@intel.com>
Link: http://lkml.kernel.org/r/623ff7555488122143e4417de09b18be2085ad06.1484705016.git.luto@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 8bf1ebca215c262e48c15a4a15f175991776f57f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/common.c
diff --cc arch/x86/kernel/cpu/common.c
index 1970e49705e0,2ea16e05de43..000000000000
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -734,44 -655,13 +734,54 @@@ void cpu_detect(struct cpuinfo_x86 *c
  	}
  }
  
++<<<<<<< HEAD
 +static void init_speculation_control(struct cpuinfo_x86 *c)
 +{
 +	/*
 +	 * The Intel SPEC_CTRL CPUID bit implies IBRS and IBPB support,
 +	 * and they also have a different bit for STIBP support. Also,
 +	 * a hypervisor might have set the individual AMD bits even on
 +	 * Intel CPUs, for finer-grained selection of what's available.
 +	 */
 +	if (cpu_has(c, X86_FEATURE_SPEC_CTRL)) {
 +		set_cpu_cap(c, X86_FEATURE_IBRS);
 +		set_cpu_cap(c, X86_FEATURE_IBPB);
 +		set_cpu_cap(c, X86_FEATURE_MSR_SPEC_CTRL);
 +	}
 +
 +	if (cpu_has(c, X86_FEATURE_INTEL_STIBP))
 +		set_cpu_cap(c, X86_FEATURE_STIBP);
 +
 +	if (cpu_has(c, X86_FEATURE_SPEC_CTRL_SSBD) ||
 +	    cpu_has(c, X86_FEATURE_VIRT_SSBD))
 +		set_cpu_cap(c, X86_FEATURE_SSBD);
 +
 +	if (cpu_has(c, X86_FEATURE_AMD_IBRS)) {
 +		set_cpu_cap(c, X86_FEATURE_IBRS);
 +		set_cpu_cap(c, X86_FEATURE_MSR_SPEC_CTRL);
 +	}
 +
 +	if (cpu_has(c, X86_FEATURE_AMD_IBPB))
 +		set_cpu_cap(c, X86_FEATURE_IBPB);
 +
 +	if (cpu_has(c, X86_FEATURE_AMD_STIBP)) {
 +		set_cpu_cap(c, X86_FEATURE_STIBP);
 +		set_cpu_cap(c, X86_FEATURE_MSR_SPEC_CTRL);
 +	}
 +
 +	if (cpu_has(c, X86_FEATURE_AMD_SSBD)) {
 +		set_cpu_cap(c, X86_FEATURE_SSBD);
 +		set_cpu_cap(c, X86_FEATURE_MSR_SPEC_CTRL);
 +		clear_cpu_cap(c, X86_FEATURE_VIRT_SSBD);
++=======
+ static void apply_forced_caps(struct cpuinfo_x86 *c)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < NCAPINTS; i++) {
+ 		c->x86_capability[i] &= ~cpu_caps_cleared[i];
+ 		c->x86_capability[i] |= cpu_caps_set[i];
++>>>>>>> 8bf1ebca215c (x86/cpu: Factor out application of forced CPU caps)
  	}
  }
  
@@@ -1297,11 -1044,8 +1307,16 @@@ static void identify_cpu(struct cpuinfo
  	if (this_cpu->c_identify)
  		this_cpu->c_identify(c);
  
++<<<<<<< HEAD
 +	/* Clear/Set all flags overriden by options, after probe */
 +	for (i = 0; i < NCAPINTS + NBUGINTS; i++) {
 +		c->x86_capability[i] &= ~cpu_caps_cleared[i];
 +		c->x86_capability[i] |= cpu_caps_set[i];
 +	}
++=======
+ 	/* Clear/Set all flags overridden by options, after probe */
+ 	apply_forced_caps(c);
++>>>>>>> 8bf1ebca215c (x86/cpu: Factor out application of forced CPU caps)
  
  #ifdef CONFIG_X86_64
  	c->apicid = apic->phys_pkg_id(c->initial_apicid, 0);
@@@ -1358,13 -1101,10 +1373,17 @@@
  	setup_pku(c);
  
  	/*
 -	 * Clear/Set all flags overridden by options, need do it
 +	 * Clear/Set all flags overriden by options, need do it
  	 * before following smp all cpus cap AND.
  	 */
++<<<<<<< HEAD
 +	for (i = 0; i < NCAPINTS + NBUGINTS; i++) {
 +		c->x86_capability[i] &= ~cpu_caps_cleared[i];
 +		c->x86_capability[i] |= cpu_caps_set[i];
 +	}
++=======
+ 	apply_forced_caps(c);
++>>>>>>> 8bf1ebca215c (x86/cpu: Factor out application of forced CPU caps)
  
  	/*
  	 * On SMP, boot_cpu_data holds the common feature set between
* Unmerged path arch/x86/kernel/cpu/common.c
