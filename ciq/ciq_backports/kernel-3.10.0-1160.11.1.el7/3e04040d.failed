Revert "mm/page_alloc: fix memmap_init_zone pageblock alignment"

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.11.1.el7
commit-author Ard Biesheuvel <ard.biesheuvel@linaro.org>
commit 3e04040df6d4613a8af5a80882d5f7f298f49810
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.11.1.el7/3e04040d.failed

This reverts commit 864b75f9d6b0100bb24fdd9a20d156e7cda9b5ae.

Commit 864b75f9d6b0 ("mm/page_alloc: fix memmap_init_zone pageblock
alignment") modified the logic in memmap_init_zone() to initialize
struct pages associated with invalid PFNs, to appease a VM_BUG_ON()
in move_freepages(), which is redundant by its own admission, and
dereferences struct page fields to obtain the zone without checking
whether the struct pages in question are valid to begin with.

Commit 864b75f9d6b0 only makes it worse, since the rounding it does
may cause pfn assume the same value it had in a prior iteration of
the loop, resulting in an infinite loop and a hang very early in the
boot. Also, since it doesn't perform the same rounding on start_pfn
itself but only on intermediate values following an invalid PFN, we
may still hit the same VM_BUG_ON() as before.

So instead, let's fix this at the core, and ensure that the BUG
check doesn't dereference struct page fields of invalid pages.

Fixes: 864b75f9d6b0 ("mm/page_alloc: fix memmap_init_zone pageblock alignment")
	Tested-by: Jan Glauber <jglauber@cavium.com>
	Tested-by: Shanker Donthineni <shankerd@codeaurora.org>
	Cc: Daniel Vacek <neelx@redhat.com>
	Cc: Mel Gorman <mgorman@techsingularity.net>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Paul Burton <paul.burton@imgtec.com>
	Cc: Pavel Tatashin <pasha.tatashin@oracle.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 3e04040df6d4613a8af5a80882d5f7f298f49810)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/page_alloc.c
diff --cc mm/page_alloc.c
index 346d45e830c2,635d7dd29d7f..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -1657,13 -1910,15 +1657,15 @@@ int move_freepages(struct zone *zone
  	 * Remove at a later date when no bug reports exist related to
  	 * grouping pages by mobility
  	 */
- 	VM_BUG_ON(page_zone(start_page) != page_zone(end_page));
+ 	VM_BUG_ON(pfn_valid(page_to_pfn(start_page)) &&
+ 	          pfn_valid(page_to_pfn(end_page)) &&
+ 	          page_zone(start_page) != page_zone(end_page));
  #endif
  
 -	if (num_movable)
 -		*num_movable = 0;
 -
  	for (page = start_page; page <= end_page;) {
 +		/* Make sure we are not inadvertently changing nodes */
 +		VM_BUG_ON_PAGE(page_to_nid(page) != zone_to_nid(zone), page);
 +
  		if (!pfn_valid_within(page_to_pfn(page))) {
  			page++;
  			continue;
@@@ -4931,14 -5361,9 +4933,20 @@@ void __meminit memmap_init_zone(unsigne
  			/*
  			 * Skip to the pfn preceding the next valid one (or
  			 * end_pfn), such that we hit a valid pfn (or end_pfn)
++<<<<<<< HEAD
 +			 * on our next iteration of the loop. Note that it needs
 +			 * to be pageblock aligned even when the region itself
 +			 * is not as move_freepages_block() can shift ahead of
 +			 * the valid region but still depends on correct page
 +			 * metadata.
 +			 */
 +			pfn = (memblock_next_valid_pfn(pfn, end_pfn) &
 +						~(pageblock_nr_pages-1)) - 1;
++=======
+ 			 * on our next iteration of the loop.
+ 			 */
+ 			pfn = memblock_next_valid_pfn(pfn, end_pfn) - 1;
++>>>>>>> 3e04040df6d4 (Revert "mm/page_alloc: fix memmap_init_zone pageblock alignment")
  #endif
  			continue;
  		}
* Unmerged path mm/page_alloc.c
