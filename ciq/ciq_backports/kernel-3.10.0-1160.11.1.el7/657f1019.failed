xfs: fix off-by-one in inode alloc block reservation calculation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.11.1.el7
commit-author Brian Foster <bfoster@redhat.com>
commit 657f101930bc6c5b41bd7d6c22565c4302a80d33
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.11.1.el7/657f1019.failed

The inode chunk allocation transaction reserves inobt_maxlevels-1
blocks to accommodate a full split of the inode btree. A full split
requires an allocation for every existing level and a new root
block, which means inobt_maxlevels is the worst case block
requirement for a transaction that inserts to the inobt. This can
lead to a transaction block reservation overrun when tmpfile
creation allocates an inode chunk and expands the inobt to its
maximum depth. This problem has been observed in conjunction with
overlayfs, which makes frequent use of tmpfiles internally.

The existing reservation code goes back as far as the Linux git repo
history (v2.6.12). It was likely never observed as a problem because
the traditional file/directory creation transactions also include
worst case block reservation for directory modifications, which most
likely is able to make up for a single block deficiency in the inode
allocation portion of the calculation. tmpfile support is relatively
more recent (v3.15), less heavily used, and only includes the inode
allocation block reservation as tmpfiles aren't linked into the
directory tree on creation.

Fix up the inode alloc block reservation macro and a couple of the
block allocator minleft parameters that enforce an allocation to
leave enough free blocks in the AG for a full inobt split.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 657f101930bc6c5b41bd7d6c22565c4302a80d33)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_ialloc.c
#	fs/xfs/libxfs/xfs_trans_space.h
diff --cc fs/xfs/libxfs/xfs_ialloc.c
index 24ef54f134fe,a6b37db55169..000000000000
--- a/fs/xfs/libxfs/xfs_ialloc.c
+++ b/fs/xfs/libxfs/xfs_ialloc.c
@@@ -702,10 -685,10 +702,14 @@@ xfs_ialloc_ag_alloc
  		 * but not to use them in the actual exact allocation.
  		 */
  		args.alignment = 1;
 -		args.minalignslop = igeo->cluster_align - 1;
 +		args.minalignslop = xfs_ialloc_cluster_alignment(args.mp) - 1;
  
  		/* Allow space for the inode btree to split. */
++<<<<<<< HEAD
 +		args.minleft = args.mp->m_in_maxlevels - 1;
++=======
+ 		args.minleft = igeo->inobt_maxlevels;
++>>>>>>> 657f101930bc (xfs: fix off-by-one in inode alloc block reservation calculation)
  		if ((error = xfs_alloc_vextent(&args)))
  			return error;
  
@@@ -753,7 -736,7 +757,11 @@@
  		/*
  		 * Allow space for the inode btree to split.
  		 */
++<<<<<<< HEAD
 +		args.minleft = args.mp->m_in_maxlevels - 1;
++=======
+ 		args.minleft = igeo->inobt_maxlevels;
++>>>>>>> 657f101930bc (xfs: fix off-by-one in inode alloc block reservation calculation)
  		if ((error = xfs_alloc_vextent(&args)))
  			return error;
  	}
diff --cc fs/xfs/libxfs/xfs_trans_space.h
index 41e0428d8175,7ad3659c5d2a..000000000000
--- a/fs/xfs/libxfs/xfs_trans_space.h
+++ b/fs/xfs/libxfs/xfs_trans_space.h
@@@ -48,9 -56,9 +48,15 @@@
  #define	XFS_DIRREMOVE_SPACE_RES(mp)	\
  	XFS_DAREMOVE_SPACE_RES(mp, XFS_DATA_FORK)
  #define	XFS_IALLOC_SPACE_RES(mp)	\
++<<<<<<< HEAD
 +	((mp)->m_ialloc_blks + \
 +	 (xfs_sb_version_hasfinobt(&mp->m_sb) ? 2 : 1 * \
 +	  ((mp)->m_in_maxlevels - 1)))
++=======
+ 	(M_IGEO(mp)->ialloc_blks + \
+ 	 ((xfs_sb_version_hasfinobt(&mp->m_sb) ? 2 : 1) * \
+ 	  M_IGEO(mp)->inobt_maxlevels))
++>>>>>>> 657f101930bc (xfs: fix off-by-one in inode alloc block reservation calculation)
  
  /*
   * Space reservation values for various transactions.
* Unmerged path fs/xfs/libxfs/xfs_ialloc.c
* Unmerged path fs/xfs/libxfs/xfs_trans_space.h
