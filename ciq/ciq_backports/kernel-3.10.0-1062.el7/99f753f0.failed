perf script: Implement --graph-function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Andi Kleen <ak@linux.intel.com>
commit 99f753f048b3f02f31a56951781672021af6cd0d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/99f753f0.failed

Add a ftrace style --graph-function argument to 'perf script' that
allows to print itrace function calls only below a given function. This
makes it easier to find the code of interest in a large trace.

% perf record -e intel_pt//k -a sleep 1
% perf script --graph-function group_sched_in --call-trace
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])          group_sched_in
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])              __x86_indirect_thunk_rax
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])              event_sched_in.isra.107
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])                  perf_event_set_state.part.71
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])                      perf_event_update_time
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])                  perf_pmu_disable
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])                  perf_log_itrace_start
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])                  __x86_indirect_thunk_rax
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])                      perf_event_update_userpage
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])                          calc_timer_values
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])                              sched_clock_cpu
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])                          __x86_indirect_thunk_rax
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])                          arch_perf_update_userpage
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])                              __fentry__
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])                              using_native_sched_clock
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])                              sched_clock_stable
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])                  perf_pmu_enable
            perf   900 [000] 194167.205652203: ([kernel.kallsyms])              __x86_indirect_thunk_rax
         swapper     0 [001] 194167.205660693: ([kernel.kallsyms])          group_sched_in
         swapper     0 [001] 194167.205660693: ([kernel.kallsyms])              __x86_indirect_thunk_rax
         swapper     0 [001] 194167.205660693: ([kernel.kallsyms])              event_sched_in.isra.107
         swapper     0 [001] 194167.205660693: ([kernel.kallsyms])                  perf_event_set_state.part.71
         swapper     0 [001] 194167.205660693: ([kernel.kallsyms])                      perf_event_update_time
         swapper     0 [001] 194167.205660693: ([kernel.kallsyms])                  perf_pmu_disable
         swapper     0 [001] 194167.205660693: ([kernel.kallsyms])                  perf_log_itrace_start
         swapper     0 [001] 194167.205660693: ([kernel.kallsyms])                  __x86_indirect_thunk_rax
         swapper     0 [001] 194167.205660693: ([kernel.kallsyms])                      perf_event_update_userpage
         swapper     0 [001] 194167.205660693: ([kernel.kallsyms])                          calc_timer_values
         swapper     0 [001] 194167.205660693: ([kernel.kallsyms])                              sched_clock_cpu
         swapper     0 [001] 194167.205660693: ([kernel.kallsyms])                          __x86_indirect_thunk_rax
         swapper     0 [001] 194167.205660693: ([kernel.kallsyms])                          arch_perf_update_userpage
         swapper     0 [001] 194167.205660693: ([kernel.kallsyms])                              __fentry__
         swapper     0 [001] 194167.205660693: ([kernel.kallsyms])                              using_native_sched_clock
         swapper     0 [001] 194167.205660693: ([kernel.kallsyms])                              sched_clock_stable

	Signed-off-by: Andi Kleen <ak@linux.intel.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Tested-by: Leo Yan <leo.yan@linaro.org>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Kim Phillips <kim.phillips@arm.com>
Link: http://lkml.kernel.org/r/20180920180540.14039-5-andi@firstfloor.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 99f753f048b3f02f31a56951781672021af6cd0d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-script.c
diff --cc tools/perf/builtin-script.c
index d3656bb2f390,9d2249ea75e3..000000000000
--- a/tools/perf/builtin-script.c
+++ b/tools/perf/builtin-script.c
@@@ -1429,6 -1576,131 +1442,134 @@@ static int data_src__fprintf(u64 data_s
  	return fprintf(fp, "%-*s", maxlen, out);
  }
  
++<<<<<<< HEAD
++=======
+ struct metric_ctx {
+ 	struct perf_sample	*sample;
+ 	struct thread		*thread;
+ 	struct perf_evsel	*evsel;
+ 	FILE 			*fp;
+ };
+ 
+ static void script_print_metric(struct perf_stat_config *config __maybe_unused,
+ 				void *ctx, const char *color,
+ 			        const char *fmt,
+ 			        const char *unit, double val)
+ {
+ 	struct metric_ctx *mctx = ctx;
+ 
+ 	if (!fmt)
+ 		return;
+ 	perf_sample__fprintf_start(mctx->sample, mctx->thread, mctx->evsel,
+ 				   PERF_RECORD_SAMPLE, mctx->fp);
+ 	fputs("\tmetric: ", mctx->fp);
+ 	if (color)
+ 		color_fprintf(mctx->fp, color, fmt, val);
+ 	else
+ 		printf(fmt, val);
+ 	fprintf(mctx->fp, " %s\n", unit);
+ }
+ 
+ static void script_new_line(struct perf_stat_config *config __maybe_unused,
+ 			    void *ctx)
+ {
+ 	struct metric_ctx *mctx = ctx;
+ 
+ 	perf_sample__fprintf_start(mctx->sample, mctx->thread, mctx->evsel,
+ 				   PERF_RECORD_SAMPLE, mctx->fp);
+ 	fputs("\tmetric: ", mctx->fp);
+ }
+ 
+ static void perf_sample__fprint_metric(struct perf_script *script,
+ 				       struct thread *thread,
+ 				       struct perf_evsel *evsel,
+ 				       struct perf_sample *sample,
+ 				       FILE *fp)
+ {
+ 	struct perf_stat_output_ctx ctx = {
+ 		.print_metric = script_print_metric,
+ 		.new_line = script_new_line,
+ 		.ctx = &(struct metric_ctx) {
+ 				.sample = sample,
+ 				.thread = thread,
+ 				.evsel  = evsel,
+ 				.fp     = fp,
+ 			 },
+ 		.force_header = false,
+ 	};
+ 	struct perf_evsel *ev2;
+ 	static bool init;
+ 	u64 val;
+ 
+ 	if (!init) {
+ 		perf_stat__init_shadow_stats();
+ 		init = true;
+ 	}
+ 	if (!evsel->stats)
+ 		perf_evlist__alloc_stats(script->session->evlist, false);
+ 	if (evsel_script(evsel->leader)->gnum++ == 0)
+ 		perf_stat__reset_shadow_stats();
+ 	val = sample->period * evsel->scale;
+ 	perf_stat__update_shadow_stats(evsel,
+ 				       val,
+ 				       sample->cpu,
+ 				       &rt_stat);
+ 	evsel_script(evsel)->val = val;
+ 	if (evsel_script(evsel->leader)->gnum == evsel->leader->nr_members) {
+ 		for_each_group_member (ev2, evsel->leader) {
+ 			perf_stat__print_shadow_stats(&stat_config, ev2,
+ 						      evsel_script(ev2)->val,
+ 						      sample->cpu,
+ 						      &ctx,
+ 						      NULL,
+ 						      &rt_stat);
+ 		}
+ 		evsel_script(evsel->leader)->gnum = 0;
+ 	}
+ }
+ 
+ static bool show_event(struct perf_sample *sample,
+ 		       struct perf_evsel *evsel,
+ 		       struct thread *thread,
+ 		       struct addr_location *al)
+ {
+ 	int depth = thread_stack__depth(thread);
+ 
+ 	if (!symbol_conf.graph_function)
+ 		return true;
+ 
+ 	if (thread->filter) {
+ 		if (depth <= thread->filter_entry_depth) {
+ 			thread->filter = false;
+ 			return false;
+ 		}
+ 		return true;
+ 	} else {
+ 		const char *s = symbol_conf.graph_function;
+ 		u64 ip;
+ 		const char *name = resolve_branch_sym(sample, evsel, thread, al,
+ 				&ip);
+ 		unsigned nlen;
+ 
+ 		if (!name)
+ 			return false;
+ 		nlen = strlen(name);
+ 		while (*s) {
+ 			unsigned len = strcspn(s, ",");
+ 			if (nlen == len && !strncmp(name, s, len)) {
+ 				thread->filter = true;
+ 				thread->filter_entry_depth = depth;
+ 				return true;
+ 			}
+ 			s += len;
+ 			if (*s == ',')
+ 				s++;
+ 		}
+ 		return false;
+ 	}
+ }
+ 
++>>>>>>> 99f753f048b3 (perf script: Implement --graph-function)
  static void process_event(struct perf_script *script,
  			  struct perf_sample *sample, struct perf_evsel *evsel,
  			  struct addr_location *al,
@@@ -1443,9 -1715,13 +1584,12 @@@
  	if (output[type].fields == 0)
  		return;
  
+ 	if (!show_event(sample, evsel, thread, al))
+ 		return;
+ 
  	++es->samples;
  
 -	perf_sample__fprintf_start(sample, thread, evsel,
 -				   PERF_RECORD_SAMPLE, fp);
 +	perf_sample__fprintf_start(sample, thread, evsel, fp);
  
  	if (PRINT_FIELD(PERIOD))
  		fprintf(fp, "%10" PRIu64 " ", sample->period);
diff --git a/tools/perf/Documentation/perf-script.txt b/tools/perf/Documentation/perf-script.txt
index d0e5639f001d..88ad45430128 100644
--- a/tools/perf/Documentation/perf-script.txt
+++ b/tools/perf/Documentation/perf-script.txt
@@ -361,6 +361,10 @@ include::itrace.txt[]
 --call-ret-trace::
 	Show call and return stream for intel_pt traces.
 
+--graph-function::
+	For itrace only show specified functions and their callees for
+	itrace. Multiple functions can be separated by comma.
+
 SEE ALSO
 --------
 linkperf:perf-record[1], linkperf:perf-script-perl[1],
* Unmerged path tools/perf/builtin-script.c
diff --git a/tools/perf/util/symbol.h b/tools/perf/util/symbol.h
index 57f14ba54637..226b1f5a3f94 100644
--- a/tools/perf/util/symbol.h
+++ b/tools/perf/util/symbol.h
@@ -122,7 +122,8 @@ struct symbol_conf {
 	const char	*vmlinux_name,
 			*kallsyms_name,
 			*source_prefix,
-			*field_sep;
+			*field_sep,
+			*graph_function;
 	const char	*default_guest_vmlinux_name,
 			*default_guest_kallsyms,
 			*default_guest_modules;
diff --git a/tools/perf/util/thread.h b/tools/perf/util/thread.h
index 6720c6d2aae4..88cbf28a2c8e 100644
--- a/tools/perf/util/thread.h
+++ b/tools/perf/util/thread.h
@@ -38,6 +38,8 @@ struct thread {
 	void				*addr_space;
 	struct unwind_libunwind_ops	*unwind_libunwind_ops;
 #endif
+	bool			filter;
+	int			filter_entry_depth;
 };
 
 struct machine;
