net: phy: add 802.3 clause 45 support to phylib

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] phy: add 802.3 clause 45 support to phylib (Ivan Vecera) [1655590]
Rebuild_FUZZ: 94.38%
commit-author Russell King <rmk+kernel@armlinux.org.uk>
commit 5acde34a5a420ffe7441bb7d3909dc2618025c3c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/5acde34a.failed

Add generic helpers for 802.3 clause 45 PHYs for >= 10Gbps support.

	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5acde34a5a420ffe7441bb7d3909dc2618025c3c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/Makefile
#	include/linux/phy.h
diff --cc drivers/net/phy/Makefile
index a2bb4785c03f,ae58f507aba9..000000000000
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@@ -1,32 -1,72 +1,52 @@@
 -# Makefile for Linux PHY drivers and MDIO bus drivers
 +# Makefile for Linux PHY drivers
  
++<<<<<<< HEAD
 +libphy-objs			:= phy.o phy_device.o mdio_bus.o
++=======
+ libphy-y			:= phy.o phy-c45.o phy-core.o phy_device.o
+ mdio-bus-y			+= mdio_bus.o mdio_device.o
+ 
+ ifdef CONFIG_MDIO_DEVICE
+ obj-y				+= mdio-boardinfo.o
+ endif
+ 
+ # PHYLIB implies MDIO_DEVICE, in that case, we have a bunch of circular
+ # dependencies that does not make it possible to split mdio-bus objects into a
+ # dedicated loadable module, so we bundle them all together into libphy.ko
+ ifdef CONFIG_PHYLIB
+ libphy-y			+= $(mdio-bus-y)
+ else
+ obj-$(CONFIG_MDIO_DEVICE)	+= mdio-bus.o
+ endif
+ libphy-$(CONFIG_SWPHY)		+= swphy.o
+ libphy-$(CONFIG_LED_TRIGGER_PHY)	+= phy_led_triggers.o
++>>>>>>> 5acde34a5a42 (net: phy: add 802.3 clause 45 support to phylib)
  
  obj-$(CONFIG_PHYLIB)		+= libphy.o
 -
 -obj-$(CONFIG_MDIO_BCM_IPROC)	+= mdio-bcm-iproc.o
 -obj-$(CONFIG_MDIO_BCM_UNIMAC)	+= mdio-bcm-unimac.o
 -obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
 -obj-$(CONFIG_MDIO_BUS_MUX)	+= mdio-mux.o
 -obj-$(CONFIG_MDIO_BUS_MUX_BCM_IPROC)	+= mdio-mux-bcm-iproc.o
 -obj-$(CONFIG_MDIO_BUS_MUX_GPIO)	+= mdio-mux-gpio.o
 -obj-$(CONFIG_MDIO_BUS_MUX_MMIOREG) += mdio-mux-mmioreg.o
 -obj-$(CONFIG_MDIO_CAVIUM)	+= mdio-cavium.o
 -obj-$(CONFIG_MDIO_GPIO)		+= mdio-gpio.o
 -obj-$(CONFIG_MDIO_HISI_FEMAC)	+= mdio-hisi-femac.o
 -obj-$(CONFIG_MDIO_MOXART)	+= mdio-moxart.o
 -obj-$(CONFIG_MDIO_OCTEON)	+= mdio-octeon.o
 -obj-$(CONFIG_MDIO_SUN4I)	+= mdio-sun4i.o
 -obj-$(CONFIG_MDIO_THUNDER)	+= mdio-thunder.o
 -obj-$(CONFIG_MDIO_XGENE)	+= mdio-xgene.o
 -
 -obj-$(CONFIG_AMD_PHY)		+= amd.o
 -obj-$(CONFIG_AQUANTIA_PHY)	+= aquantia.o
 -obj-$(CONFIG_AT803X_PHY)	+= at803x.o
 +obj-$(CONFIG_MARVELL_PHY)	+= marvell.o
 +obj-$(CONFIG_DAVICOM_PHY)	+= davicom.o
 +obj-$(CONFIG_CICADA_PHY)	+= cicada.o
 +obj-$(CONFIG_LXT_PHY)		+= lxt.o
 +obj-$(CONFIG_QSEMI_PHY)		+= qsemi.o
 +obj-$(CONFIG_SMSC_PHY)		+= smsc.o
 +obj-$(CONFIG_VITESSE_PHY)	+= vitesse.o
 +obj-$(CONFIG_BROADCOM_PHY)	+= broadcom.o
  obj-$(CONFIG_BCM63XX_PHY)	+= bcm63xx.o
 -obj-$(CONFIG_BCM7XXX_PHY)	+= bcm7xxx.o
  obj-$(CONFIG_BCM87XX_PHY)	+= bcm87xx.o
 -obj-$(CONFIG_BCM_CYGNUS_PHY)	+= bcm-cygnus.o
 -obj-$(CONFIG_BCM_NET_PHYLIB)	+= bcm-phy-lib.o
 -obj-$(CONFIG_BROADCOM_PHY)	+= broadcom.o
 -obj-$(CONFIG_CICADA_PHY)	+= cicada.o
 -obj-$(CONFIG_CORTINA_PHY)	+= cortina.o
 -obj-$(CONFIG_DAVICOM_PHY)	+= davicom.o
 -obj-$(CONFIG_DP83640_PHY)	+= dp83640.o
 -obj-$(CONFIG_DP83848_PHY)	+= dp83848.o
 -obj-$(CONFIG_DP83867_PHY)	+= dp83867.o
 -obj-$(CONFIG_FIXED_PHY)		+= fixed_phy.o
  obj-$(CONFIG_ICPLUS_PHY)	+= icplus.o
 -obj-$(CONFIG_INTEL_XWAY_PHY)	+= intel-xway.o
 +obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
  obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
 -obj-$(CONFIG_LXT_PHY)		+= lxt.o
 -obj-$(CONFIG_MARVELL_PHY)	+= marvell.o
 -obj-$(CONFIG_MESON_GXL_PHY)	+= meson-gxl.o
 -obj-$(CONFIG_MICREL_KS8995MA)	+= spi_ks8995.o
 -obj-$(CONFIG_MICREL_PHY)	+= micrel.o
 -obj-$(CONFIG_MICROCHIP_PHY)	+= microchip.o
 -obj-$(CONFIG_MICROSEMI_PHY)	+= mscc.o
 +obj-$(CONFIG_FIXED_PHY)		+= fixed_phy.o
 +obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
 +obj-$(CONFIG_MDIO_GPIO)		+= mdio-gpio.o
  obj-$(CONFIG_NATIONAL_PHY)	+= national.o
 -obj-$(CONFIG_QSEMI_PHY)		+= qsemi.o
 -obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
 -obj-$(CONFIG_SMSC_PHY)		+= smsc.o
 +obj-$(CONFIG_DP83640_PHY)	+= dp83640.o
  obj-$(CONFIG_STE10XP)		+= ste10Xp.o
 -obj-$(CONFIG_TERANETICS_PHY)	+= teranetics.o
 -obj-$(CONFIG_VITESSE_PHY)	+= vitesse.o
 -obj-$(CONFIG_XILINX_GMII2RGMII) += xilinx_gmii2rgmii.o
 +obj-$(CONFIG_MICREL_PHY)	+= micrel.o
 +obj-$(CONFIG_MDIO_OCTEON)	+= mdio-octeon.o
 +obj-$(CONFIG_MICREL_KS8995MA)	+= spi_ks8995.o
 +obj-$(CONFIG_AT803X_PHY)	+= at803x.o
 +obj-$(CONFIG_AMD_PHY)		+= amd.o
 +obj-$(CONFIG_MDIO_BUS_MUX)	+= mdio-mux.o
 +obj-$(CONFIG_MDIO_BUS_MUX_GPIO)	+= mdio-mux-gpio.o
 +obj-$(CONFIG_MDIO_BUS_MUX_MMIOREG) += mdio-mux-mmioreg.o
diff --cc include/linux/phy.h
index 9542c61131f8,a47eb5e841d2..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -669,6 -810,27 +669,27 @@@ static inline int phy_read_status(struc
  	return phydev->drv->read_status(phydev);
  }
  
++<<<<<<< HEAD
++=======
+ #define phydev_err(_phydev, format, args...)	\
+ 	dev_err(&_phydev->mdio.dev, format, ##args)
+ 
+ #define phydev_dbg(_phydev, format, args...)	\
+ 	dev_dbg(&_phydev->mdio.dev, format, ##args);
+ 
+ static inline const char *phydev_name(const struct phy_device *phydev)
+ {
+ 	return dev_name(&phydev->mdio.dev);
+ }
+ 
+ void phy_attached_print(struct phy_device *phydev, const char *fmt, ...)
+ 	__printf(2, 3);
+ void phy_attached_info(struct phy_device *phydev);
+ 
+ /* Clause 22 PHY */
+ int genphy_config_init(struct phy_device *phydev);
+ int genphy_setup_forced(struct phy_device *phydev);
++>>>>>>> 5acde34a5a42 (net: phy: add 802.3 clause 45 support to phylib)
  int genphy_restart_aneg(struct phy_device *phydev);
  int genphy_config_aneg(struct phy_device *phydev);
  int genphy_aneg_done(struct phy_device *phydev);
@@@ -677,12 -839,28 +698,29 @@@ int genphy_read_status(struct phy_devic
  int genphy_suspend(struct phy_device *phydev);
  int genphy_resume(struct phy_device *phydev);
  int genphy_soft_reset(struct phy_device *phydev);
++<<<<<<< HEAD
++=======
+ static inline int genphy_no_soft_reset(struct phy_device *phydev)
+ {
+ 	return 0;
+ }
+ 
+ /* Clause 45 PHY */
+ int genphy_c45_restart_aneg(struct phy_device *phydev);
+ int genphy_c45_aneg_done(struct phy_device *phydev);
+ int genphy_c45_read_link(struct phy_device *phydev, u32 mmd_mask);
+ int genphy_c45_read_lpa(struct phy_device *phydev);
+ int genphy_c45_read_pma(struct phy_device *phydev);
+ int genphy_c45_pma_setup_forced(struct phy_device *phydev);
+ int genphy_c45_an_disable_aneg(struct phy_device *phydev);
+ 
++>>>>>>> 5acde34a5a42 (net: phy: add 802.3 clause 45 support to phylib)
  void phy_driver_unregister(struct phy_driver *drv);
  void phy_drivers_unregister(struct phy_driver *drv, int n);
 -int phy_driver_register(struct phy_driver *new_driver, struct module *owner);
 -int phy_drivers_register(struct phy_driver *new_driver, int n,
 -			 struct module *owner);
 +int phy_driver_register(struct phy_driver *new_driver);
 +int phy_drivers_register(struct phy_driver *new_driver, int n);
  void phy_state_machine(struct work_struct *work);
 -void phy_change(struct phy_device *phydev);
 -void phy_change_work(struct work_struct *work);
 +void phy_change(struct work_struct *work);
  void phy_mac_interrupt(struct phy_device *phydev, int new_link);
  void phy_start_machine(struct phy_device *phydev);
  void phy_stop_machine(struct phy_device *phydev);
* Unmerged path drivers/net/phy/Makefile
diff --git a/drivers/net/phy/phy-c45.c b/drivers/net/phy/phy-c45.c
new file mode 100644
index 000000000000..d311d6e6141c
--- /dev/null
+++ b/drivers/net/phy/phy-c45.c
@@ -0,0 +1,234 @@
+/*
+ * Clause 45 PHY support
+ */
+#include <linux/ethtool.h>
+#include <linux/export.h>
+#include <linux/mdio.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+
+/**
+ * genphy_c45_setup_forced - configures a forced speed
+ * @phydev: target phy_device struct
+ */
+int genphy_c45_pma_setup_forced(struct phy_device *phydev)
+{
+	int ctrl1, ctrl2, ret;
+
+	/* Half duplex is not supported */
+	if (phydev->duplex != DUPLEX_FULL)
+		return -EINVAL;
+
+	ctrl1 = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_CTRL1);
+	if (ctrl1 < 0)
+		return ctrl1;
+
+	ctrl2 = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_CTRL2);
+	if (ctrl2 < 0)
+		return ctrl2;
+
+	ctrl1 &= ~MDIO_CTRL1_SPEEDSEL;
+	/*
+	 * PMA/PMD type selection is 1.7.5:0 not 1.7.3:0.  See 45.2.1.6.1
+	 * in 802.3-2012 and 802.3-2015.
+	 */
+	ctrl2 &= ~(MDIO_PMA_CTRL2_TYPE | 0x30);
+
+	switch (phydev->speed) {
+	case SPEED_10:
+		ctrl2 |= MDIO_PMA_CTRL2_10BT;
+		break;
+	case SPEED_100:
+		ctrl1 |= MDIO_PMA_CTRL1_SPEED100;
+		ctrl2 |= MDIO_PMA_CTRL2_100BTX;
+		break;
+	case SPEED_1000:
+		ctrl1 |= MDIO_PMA_CTRL1_SPEED1000;
+		/* Assume 1000base-T */
+		ctrl2 |= MDIO_PMA_CTRL2_1000BT;
+		break;
+	case SPEED_10000:
+		ctrl1 |= MDIO_CTRL1_SPEED10G;
+		/* Assume 10Gbase-T */
+		ctrl2 |= MDIO_PMA_CTRL2_10GBT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = phy_write_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_CTRL1, ctrl1);
+	if (ret < 0)
+		return ret;
+
+	return phy_write_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_CTRL2, ctrl2);
+}
+EXPORT_SYMBOL_GPL(genphy_c45_pma_setup_forced);
+
+/**
+ * genphy_c45_an_disable_aneg - disable auto-negotiation
+ * @phydev: target phy_device struct
+ *
+ * Disable auto-negotiation in the Clause 45 PHY. The link parameters
+ * parameters are controlled through the PMA/PMD MMD registers.
+ *
+ * Returns zero on success, negative errno code on failure.
+ */
+int genphy_c45_an_disable_aneg(struct phy_device *phydev)
+{
+	int val;
+
+	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_CTRL1);
+	if (val < 0)
+		return val;
+
+	val &= ~(MDIO_AN_CTRL1_ENABLE | MDIO_AN_CTRL1_RESTART);
+
+	return phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_CTRL1, val);
+}
+EXPORT_SYMBOL_GPL(genphy_c45_an_disable_aneg);
+
+/**
+ * genphy_c45_restart_aneg - Enable and restart auto-negotiation
+ * @phydev: target phy_device struct
+ *
+ * This assumes that the auto-negotiation MMD is present.
+ *
+ * Enable and restart auto-negotiation.
+ */
+int genphy_c45_restart_aneg(struct phy_device *phydev)
+{
+	int val;
+
+	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_CTRL1);
+	if (val < 0)
+		return val;
+
+	val |= MDIO_AN_CTRL1_ENABLE | MDIO_AN_CTRL1_RESTART;
+
+	return phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_CTRL1, val);
+}
+EXPORT_SYMBOL_GPL(genphy_c45_restart_aneg);
+
+/**
+ * genphy_c45_aneg_done - return auto-negotiation complete status
+ * @phydev: target phy_device struct
+ *
+ * This assumes that the auto-negotiation MMD is present.
+ *
+ * Reads the status register from the auto-negotiation MMD, returning:
+ * - positive if auto-negotiation is complete
+ * - negative errno code on error
+ * - zero otherwise
+ */
+int genphy_c45_aneg_done(struct phy_device *phydev)
+{
+	int val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_STAT1);
+
+	return val < 0 ? val : val & MDIO_AN_STAT1_COMPLETE ? 1 : 0;
+}
+EXPORT_SYMBOL_GPL(genphy_c45_aneg_done);
+
+/**
+ * genphy_c45_read_link - read the overall link status from the MMDs
+ * @phydev: target phy_device struct
+ * @mmd_mask: MMDs to read status from
+ *
+ * Read the link status from the specified MMDs, and if they all indicate
+ * that the link is up, return positive.  If an error is encountered,
+ * a negative errno will be returned, otherwise zero.
+ */
+int genphy_c45_read_link(struct phy_device *phydev, u32 mmd_mask)
+{
+	int val, devad;
+	bool link = true;
+
+	while (mmd_mask) {
+		devad = __ffs(mmd_mask);
+		mmd_mask &= ~BIT(devad);
+
+		/* The link state is latched low so that momentary link
+		 * drops can be detected.  Do not double-read the status
+		 * register if the link is down.
+		 */
+		val = phy_read_mmd(phydev, devad, MDIO_STAT1);
+		if (val < 0)
+			return val;
+
+		if (!(val & MDIO_STAT1_LSTATUS))
+			link = false;
+	}
+
+	return link;
+}
+EXPORT_SYMBOL_GPL(genphy_c45_read_link);
+
+/**
+ * genphy_c45_read_lpa - read the link partner advertisment and pause
+ * @phydev: target phy_device struct
+ *
+ * Read the Clause 45 defined base (7.19) and 10G (7.33) status registers,
+ * filling in the link partner advertisment, pause and asym_pause members
+ * in @phydev.  This assumes that the auto-negotiation MMD is present, and
+ * the backplane bit (7.48.0) is clear.  Clause 45 PHY drivers are expected
+ * to fill in the remainder of the link partner advert from vendor registers.
+ */
+int genphy_c45_read_lpa(struct phy_device *phydev)
+{
+	int val;
+
+	/* Read the link partner's base page advertisment */
+	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_LPA);
+	if (val < 0)
+		return val;
+
+	phydev->lp_advertising = mii_lpa_to_ethtool_lpa_t(val);
+	phydev->pause = val & LPA_PAUSE_CAP ? 1 : 0;
+	phydev->asym_pause = val & LPA_PAUSE_ASYM ? 1 : 0;
+
+	/* Read the link partner's 10G advertisment */
+	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_10GBT_STAT);
+	if (val < 0)
+		return val;
+
+	if (val & MDIO_AN_10GBT_STAT_LP10G)
+		phydev->lp_advertising |= ADVERTISED_10000baseT_Full;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(genphy_c45_read_lpa);
+
+/**
+ * genphy_c45_read_pma - read link speed etc from PMA
+ * @phydev: target phy_device struct
+ */
+int genphy_c45_read_pma(struct phy_device *phydev)
+{
+	int val;
+
+	val = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_CTRL1);
+	if (val < 0)
+		return val;
+
+	switch (val & MDIO_CTRL1_SPEEDSEL) {
+	case 0:
+		phydev->speed = SPEED_10;
+		break;
+	case MDIO_PMA_CTRL1_SPEED100:
+		phydev->speed = SPEED_100;
+		break;
+	case MDIO_PMA_CTRL1_SPEED1000:
+		phydev->speed = SPEED_1000;
+		break;
+	case MDIO_CTRL1_SPEED10G:
+		phydev->speed = SPEED_10000;
+		break;
+	default:
+		phydev->speed = SPEED_UNKNOWN;
+		break;
+	}
+
+	phydev->duplex = DUPLEX_FULL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(genphy_c45_read_pma);
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index 2dbcaed2657a..449102cb586c 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -1063,27 +1063,19 @@ EXPORT_SYMBOL(genphy_read_status);
 
 static int gen10g_read_status(struct phy_device *phydev)
 {
-	int devad, reg;
 	u32 mmd_mask = phydev->c45_ids.devices_in_package;
-
-	phydev->link = 1;
+	int ret;
 
 	/* For now just lie and say it's 10G all the time */
 	phydev->speed = SPEED_10000;
 	phydev->duplex = DUPLEX_FULL;
 
-	for (devad = 0; mmd_mask; devad++, mmd_mask = mmd_mask >> 1) {
-		if (!(mmd_mask & 1))
-			continue;
+	/* Avoid reading the vendor MMDs */
+	mmd_mask &= ~(BIT(MDIO_MMD_VEND1) | BIT(MDIO_MMD_VEND2));
 
-		/* Read twice because link state is latched and a
-		 * read moves the current state into the register
-		 */
-		phy_read_mmd(phydev, devad, MDIO_STAT1);
-		reg = phy_read_mmd(phydev, devad, MDIO_STAT1);
-		if (reg < 0 || !(reg & MDIO_STAT1_LSTATUS))
-			phydev->link = 0;
-	}
+	ret = genphy_c45_read_link(phydev, mmd_mask);
+
+	phydev->link = ret > 0 ? 1 : 0;
 
 	return 0;
 }
* Unmerged path include/linux/phy.h
