perf tools: Apply tracepoint event definition options to BPF script

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Wang Nan <wangnan0@huawei.com>
commit 95088a591e197610bd03f4059f5fdbe9e376425b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/95088a59.failed

Users can pass options to tracepoints defined in the BPF script.  For
example:

  # perf record -e ./test.c/no-inherit/ bash
  # dd if=/dev/zero of=/dev/null count=10000
  # exit
  [ perf record: Woken up 1 times to write data ]
  [ perf record: Captured and wrote 0.022 MB perf.data (139 samples) ]

  (no-inherit works, only the sys_read issued by bash are captured, at
   least 10000 sys_read issued by dd are skipped.)

test.c:

  #define SEC(NAME) __attribute__((section(NAME), used))
  SEC("func=sys_read")
  int bpf_func__sys_read(void *ctx)
  {
      return 1;
  }
  char _license[] SEC("license") = "GPL";
  int _version SEC("version") = LINUX_VERSION_CODE;

no-inherit is applied to the kprobe event defined in test.c.

	Signed-off-by: Wang Nan <wangnan0@huawei.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Alexei Starovoitov <ast@kernel.org>
	Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
	Cc: Cody P Schafer <dev@codyps.com>
	Cc: He Kuang <hekuang@huawei.com>
	Cc: Jeremie Galarneau <jeremie.galarneau@efficios.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Kirill Smelkov <kirr@nexedi.com>
	Cc: Li Zefan <lizefan@huawei.com>
	Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: pi3orama@163.com
Link: http://lkml.kernel.org/r/1456132275-98875-10-git-send-email-wangnan0@huawei.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 95088a591e197610bd03f4059f5fdbe9e376425b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/tests/bpf.c
#	tools/perf/util/parse-events.c
#	tools/perf/util/parse-events.h
diff --cc tools/perf/util/parse-events.c
index 3a234b74d6ff,4c19d5e79d8c..000000000000
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@@ -590,6 -578,227 +590,230 @@@ static int add_tracepoint_multi_sys(str
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ struct __add_bpf_event_param {
+ 	struct parse_events_evlist *data;
+ 	struct list_head *list;
+ 	struct list_head *head_config;
+ };
+ 
+ static int add_bpf_event(struct probe_trace_event *tev, int fd,
+ 			 void *_param)
+ {
+ 	LIST_HEAD(new_evsels);
+ 	struct __add_bpf_event_param *param = _param;
+ 	struct parse_events_evlist *evlist = param->data;
+ 	struct list_head *list = param->list;
+ 	struct perf_evsel *pos;
+ 	int err;
+ 
+ 	pr_debug("add bpf event %s:%s and attach bpf program %d\n",
+ 		 tev->group, tev->event, fd);
+ 
+ 	err = parse_events_add_tracepoint(&new_evsels, &evlist->idx, tev->group,
+ 					  tev->event, evlist->error,
+ 					  param->head_config);
+ 	if (err) {
+ 		struct perf_evsel *evsel, *tmp;
+ 
+ 		pr_debug("Failed to add BPF event %s:%s\n",
+ 			 tev->group, tev->event);
+ 		list_for_each_entry_safe(evsel, tmp, &new_evsels, node) {
+ 			list_del(&evsel->node);
+ 			perf_evsel__delete(evsel);
+ 		}
+ 		return err;
+ 	}
+ 	pr_debug("adding %s:%s\n", tev->group, tev->event);
+ 
+ 	list_for_each_entry(pos, &new_evsels, node) {
+ 		pr_debug("adding %s:%s to %p\n",
+ 			 tev->group, tev->event, pos);
+ 		pos->bpf_fd = fd;
+ 	}
+ 	list_splice(&new_evsels, list);
+ 	return 0;
+ }
+ 
+ int parse_events_load_bpf_obj(struct parse_events_evlist *data,
+ 			      struct list_head *list,
+ 			      struct bpf_object *obj,
+ 			      struct list_head *head_config)
+ {
+ 	int err;
+ 	char errbuf[BUFSIZ];
+ 	struct __add_bpf_event_param param = {data, list, head_config};
+ 	static bool registered_unprobe_atexit = false;
+ 
+ 	if (IS_ERR(obj) || !obj) {
+ 		snprintf(errbuf, sizeof(errbuf),
+ 			 "Internal error: load bpf obj with NULL");
+ 		err = -EINVAL;
+ 		goto errout;
+ 	}
+ 
+ 	/*
+ 	 * Register atexit handler before calling bpf__probe() so
+ 	 * bpf__probe() don't need to unprobe probe points its already
+ 	 * created when failure.
+ 	 */
+ 	if (!registered_unprobe_atexit) {
+ 		atexit(bpf__clear);
+ 		registered_unprobe_atexit = true;
+ 	}
+ 
+ 	err = bpf__probe(obj);
+ 	if (err) {
+ 		bpf__strerror_probe(obj, err, errbuf, sizeof(errbuf));
+ 		goto errout;
+ 	}
+ 
+ 	err = bpf__load(obj);
+ 	if (err) {
+ 		bpf__strerror_load(obj, err, errbuf, sizeof(errbuf));
+ 		goto errout;
+ 	}
+ 
+ 	err = bpf__foreach_tev(obj, add_bpf_event, &param);
+ 	if (err) {
+ 		snprintf(errbuf, sizeof(errbuf),
+ 			 "Attach events in BPF object failed");
+ 		goto errout;
+ 	}
+ 
+ 	return 0;
+ errout:
+ 	data->error->help = strdup("(add -v to see detail)");
+ 	data->error->str = strdup(errbuf);
+ 	return err;
+ }
+ 
+ static int
+ parse_events_config_bpf(struct parse_events_evlist *data,
+ 			struct bpf_object *obj,
+ 			struct list_head *head_config)
+ {
+ 	struct parse_events_term *term;
+ 	int error_pos;
+ 
+ 	if (!head_config || list_empty(head_config))
+ 		return 0;
+ 
+ 	list_for_each_entry(term, head_config, list) {
+ 		char errbuf[BUFSIZ];
+ 		int err;
+ 
+ 		if (term->type_term != PARSE_EVENTS__TERM_TYPE_USER) {
+ 			snprintf(errbuf, sizeof(errbuf),
+ 				 "Invalid config term for BPF object");
+ 			errbuf[BUFSIZ - 1] = '\0';
+ 
+ 			data->error->idx = term->err_term;
+ 			data->error->str = strdup(errbuf);
+ 			return -EINVAL;
+ 		}
+ 
+ 		err = bpf__config_obj(obj, term, data->evlist, &error_pos);
+ 		if (err) {
+ 			bpf__strerror_config_obj(obj, term, data->evlist,
+ 						 &error_pos, err, errbuf,
+ 						 sizeof(errbuf));
+ 			data->error->help = strdup(
+ "Hint:\tValid config terms:\n"
+ "     \tmap:[<arraymap>].value<indices>=[value]\n"
+ "     \tmap:[<eventmap>].event<indices>=[event]\n"
+ "\n"
+ "     \twhere <indices> is something like [0,3...5] or [all]\n"
+ "     \t(add -v to see detail)");
+ 			data->error->str = strdup(errbuf);
+ 			if (err == -BPF_LOADER_ERRNO__OBJCONF_MAP_VALUE)
+ 				data->error->idx = term->err_val;
+ 			else
+ 				data->error->idx = term->err_term + error_pos;
+ 			return err;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * Split config terms:
+  * perf record -e bpf.c/call-graph=fp,map:array.value[0]=1/ ...
+  *  'call-graph=fp' is 'evt config', should be applied to each
+  *  events in bpf.c.
+  * 'map:array.value[0]=1' is 'obj config', should be processed
+  * with parse_events_config_bpf.
+  *
+  * Move object config terms from the first list to obj_head_config.
+  */
+ static void
+ split_bpf_config_terms(struct list_head *evt_head_config,
+ 		       struct list_head *obj_head_config)
+ {
+ 	struct parse_events_term *term, *temp;
+ 
+ 	/*
+ 	 * Currectly, all possible user config term
+ 	 * belong to bpf object. parse_events__is_hardcoded_term()
+ 	 * happends to be a good flag.
+ 	 *
+ 	 * See parse_events_config_bpf() and
+ 	 * config_term_tracepoint().
+ 	 */
+ 	list_for_each_entry_safe(term, temp, evt_head_config, list)
+ 		if (!parse_events__is_hardcoded_term(term))
+ 			list_move_tail(&term->list, obj_head_config);
+ }
+ 
+ int parse_events_load_bpf(struct parse_events_evlist *data,
+ 			  struct list_head *list,
+ 			  char *bpf_file_name,
+ 			  bool source,
+ 			  struct list_head *head_config)
+ {
+ 	int err;
+ 	struct bpf_object *obj;
+ 	LIST_HEAD(obj_head_config);
+ 
+ 	if (head_config)
+ 		split_bpf_config_terms(head_config, &obj_head_config);
+ 
+ 	obj = bpf__prepare_load(bpf_file_name, source);
+ 	if (IS_ERR(obj)) {
+ 		char errbuf[BUFSIZ];
+ 
+ 		err = PTR_ERR(obj);
+ 
+ 		if (err == -ENOTSUP)
+ 			snprintf(errbuf, sizeof(errbuf),
+ 				 "BPF support is not compiled");
+ 		else
+ 			bpf__strerror_prepare_load(bpf_file_name,
+ 						   source,
+ 						   -err, errbuf,
+ 						   sizeof(errbuf));
+ 
+ 		data->error->help = strdup("(add -v to see detail)");
+ 		data->error->str = strdup(errbuf);
+ 		return err;
+ 	}
+ 
+ 	err = parse_events_load_bpf_obj(data, list, obj, head_config);
+ 	if (err)
+ 		return err;
+ 	err = parse_events_config_bpf(data, obj, &obj_head_config);
+ 
+ 	/*
+ 	 * Caller doesn't know anything about obj_head_config,
+ 	 * so combine them together again before returnning.
+ 	 */
+ 	if (head_config)
+ 		list_splice_tail(&obj_head_config, head_config);
+ 	return err;
+ }
+ 
++>>>>>>> 95088a591e19 (perf tools: Apply tracepoint event definition options to BPF script)
  static int
  parse_breakpoint_type(const char *type, struct perf_event_attr *attr)
  {
diff --cc tools/perf/util/parse-events.h
index 411808bd5db5,67e493088e81..000000000000
--- a/tools/perf/util/parse-events.h
+++ b/tools/perf/util/parse-events.h
@@@ -128,10 -134,21 +128,25 @@@ int parse_events__modifier_event(struc
  int parse_events__modifier_group(struct list_head *list, char *event_mod);
  int parse_events_name(struct list_head *list, char *name);
  int parse_events_add_tracepoint(struct list_head *list, int *idx,
 -				char *sys, char *event,
 +				const char *sys, const char *event,
  				struct parse_events_error *error,
  				struct list_head *head_config);
++<<<<<<< HEAD
 +int parse_events_add_numeric(struct parse_events_state *parse_state,
++=======
+ int parse_events_load_bpf(struct parse_events_evlist *data,
+ 			  struct list_head *list,
+ 			  char *bpf_file_name,
+ 			  bool source,
+ 			  struct list_head *head_config);
+ /* Provide this function for perf test */
+ struct bpf_object;
+ int parse_events_load_bpf_obj(struct parse_events_evlist *data,
+ 			      struct list_head *list,
+ 			      struct bpf_object *obj,
+ 			      struct list_head *head_config);
+ int parse_events_add_numeric(struct parse_events_evlist *data,
++>>>>>>> 95088a591e19 (perf tools: Apply tracepoint event definition options to BPF script)
  			     struct list_head *list,
  			     u32 type, u64 config,
  			     struct list_head *head_config);
* Unmerged path tools/perf/tests/bpf.c
* Unmerged path tools/perf/tests/bpf.c
* Unmerged path tools/perf/util/parse-events.c
* Unmerged path tools/perf/util/parse-events.h
