mm, swap: don't use VMA based swap readahead if HDD is used as swap

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [kernel] mm: swap: don't use VMA based swap readahead if HDD is used as swap (Rafael Aquini) [1485248]
Rebuild_FUZZ: 98.51%
commit-author Huang Ying <ying.huang@intel.com>
commit 81a0298bdfab0203d360df7c9bf690d1d457f999
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/81a0298b.failed

VMA based swap readahead will readahead the virtual pages that is
continuous in the virtual address space.  While the original swap
readahead will readahead the swap slots that is continuous in the swap
device.  Although VMA based swap readahead is more correct for the swap
slots to be readahead, it will trigger more small random readings, which
may cause the performance of HDD (hard disk) to degrade heavily, and may
finally exceed the benefit.

To avoid the issue, in this patch, if the HDD is used as swap, the VMA
based swap readahead will be disabled, and the original swap readahead
will be used instead.

Link: http://lkml.kernel.org/r/20170807054038.1843-6-ying.huang@intel.com
	Signed-off-by: "Huang, Ying" <ying.huang@intel.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Minchan Kim <minchan@kernel.org>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Shaohua Li <shli@kernel.org>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Fengguang Wu <fengguang.wu@intel.com>
	Cc: Tim Chen <tim.c.chen@intel.com>
	Cc: Dave Hansen <dave.hansen@intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 81a0298bdfab0203d360df7c9bf690d1d457f999)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/swap.h
diff --cc include/linux/swap.h
index a8d3662b5bce,9c4ae6f14eea..000000000000
--- a/include/linux/swap.h
+++ b/include/linux/swap.h
@@@ -457,6 -394,12 +457,15 @@@ extern struct page *__read_swap_cache_a
  extern struct page *swapin_readahead(swp_entry_t, gfp_t,
  			struct vm_area_struct *vma, unsigned long addr);
  
++<<<<<<< HEAD
++=======
+ extern struct page *swap_readahead_detect(struct vm_fault *vmf,
+ 					  struct vma_swap_readahead *swap_ra);
+ extern struct page *do_swap_page_readahead(swp_entry_t fentry, gfp_t gfp_mask,
+ 					   struct vm_fault *vmf,
+ 					   struct vma_swap_readahead *swap_ra);
+ 
++>>>>>>> 81a0298bdfab (mm, swap: don't use VMA based swap readahead if HDD is used as swap)
  /* linux/mm/swapfile.c */
  extern atomic_long_t nr_swap_pages;
  extern long total_swap_pages;
* Unmerged path include/linux/swap.h
diff --git a/mm/swapfile.c b/mm/swapfile.c
index 8cf0784a0684..519f5ddcd958 100644
--- a/mm/swapfile.c
+++ b/mm/swapfile.c
@@ -93,6 +93,8 @@ static DECLARE_WAIT_QUEUE_HEAD(proc_poll_wait);
 /* Activity counter to indicate that a swapon or swapoff has occurred */
 static atomic_t proc_poll_event = ATOMIC_INIT(0);
 
+atomic_t nr_rotate_swap = ATOMIC_INIT(0);
+
 static inline unsigned char swap_count(unsigned char ent)
 {
 	return ent & ~SWAP_HAS_CACHE;	/* may include SWAP_HAS_CONT flag */
@@ -2238,6 +2240,9 @@ SYSCALL_DEFINE1(swapoff, const char __user *, specialfile)
 	if (p->flags & SWP_CONTINUED)
 		free_swap_count_continuations(p);
 
+	if (!p->bdev || !blk_queue_nonrot(bdev_get_queue(p->bdev)))
+		atomic_dec(&nr_rotate_swap);
+
 	mutex_lock(&swapon_mutex);
 	spin_lock(&swap_lock);
 	spin_lock(&p->lock);
@@ -2836,7 +2841,8 @@ SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)
 			cluster = per_cpu_ptr(p->percpu_cluster, i);
 			cluster_set_null(&cluster->index);
 		}
-	}
+	} else
+		atomic_inc(&nr_rotate_swap);
 
 	error = swap_cgroup_swapon(p->type, maxpages);
 	if (error)
