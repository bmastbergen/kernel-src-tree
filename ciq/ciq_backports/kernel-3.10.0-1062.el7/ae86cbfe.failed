libnvdimm, pfn: Pad pfn namespaces relative to other regions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit ae86cbfef3818300f1972e52f67a93211acb0e24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ae86cbfe.failed

Commit cfe30b872058 "libnvdimm, pmem: adjust for section collisions with
'System RAM'" enabled Linux to workaround occasions where platform
firmware arranges for "System RAM" and "Persistent Memory" to collide
within a single section boundary. Unfortunately, as reported in this
issue [1], platform firmware can inflict the same collision between
persistent memory regions.

The approach of interrogating iomem_resource does not work in this
case because platform firmware may merge multiple regions into a single
iomem_resource range. Instead provide a method to interrogate regions
that share the same parent bus.

This is a stop-gap until the core-MM can grow support for hotplug on
sub-section boundaries.

[1]: https://github.com/pmem/ndctl/issues/76

Fixes: cfe30b872058 ("libnvdimm, pmem: adjust for section collisions with...")
	Cc: <stable@vger.kernel.org>
	Reported-by: Patrick Geary <patrickg@supermicro.com>
	Tested-by: Patrick Geary <patrickg@supermicro.com>
	Reviewed-by: Vishal Verma <vishal.l.verma@intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit ae86cbfef3818300f1972e52f67a93211acb0e24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvdimm/pfn_devs.c
diff --cc drivers/nvdimm/pfn_devs.c
index f14eeec7c210,6f22272e8d80..000000000000
--- a/drivers/nvdimm/pfn_devs.c
+++ b/drivers/nvdimm/pfn_devs.c
@@@ -688,28 -721,7 +721,32 @@@ static int nd_pfn_init(struct nd_pfn *n
  
  	memset(pfn_sb, 0, sizeof(*pfn_sb));
  
++<<<<<<< HEAD
 +	/*
 +	 * Check if pmem collides with 'System RAM' when section aligned and
 +	 * trim it accordingly
 +	 */
 +	nsio = to_nd_namespace_io(&ndns->dev);
 +	start = PHYS_SECTION_ALIGN_DOWN(nsio->res.start);
 +	size = resource_size(&nsio->res);
 +	if (region_intersects_ram(start, size) == REGION_MIXED) {
 +		start = nsio->res.start;
 +		start_pad = PHYS_SECTION_ALIGN_UP(start) - start;
 +	}
 +
 +	start = nsio->res.start;
 +	size = PHYS_SECTION_ALIGN_UP(start + size) - start;
 +	if (region_intersects_ram(start, size) == REGION_MIXED
 +			|| !IS_ALIGNED(start + resource_size(&nsio->res),
 +				nd_pfn->align)) {
 +		size = resource_size(&nsio->res);
 +		end_trunc = start + size - phys_pmem_align_down(nd_pfn,
 +				start + size);
 +	}
 +
++=======
+ 	trim_pfn_device(nd_pfn, &start_pad, &end_trunc);
++>>>>>>> ae86cbfef381 (libnvdimm, pfn: Pad pfn namespaces relative to other regions)
  	if (start_pad + end_trunc)
  		dev_info(&nd_pfn->dev, "%s alignment collision, truncate %d bytes\n",
  				dev_name(&ndns->dev), start_pad + end_trunc);
diff --git a/drivers/nvdimm/nd-core.h b/drivers/nvdimm/nd-core.h
index 182258f64417..d0c621b32f72 100644
--- a/drivers/nvdimm/nd-core.h
+++ b/drivers/nvdimm/nd-core.h
@@ -111,6 +111,8 @@ resource_size_t nd_pmem_available_dpa(struct nd_region *nd_region,
 		struct nd_mapping *nd_mapping, resource_size_t *overlap);
 resource_size_t nd_blk_available_dpa(struct nd_region *nd_region);
 resource_size_t nd_region_available_dpa(struct nd_region *nd_region);
+int nd_region_conflict(struct nd_region *nd_region, resource_size_t start,
+		resource_size_t size);
 resource_size_t nvdimm_allocated_dpa(struct nvdimm_drvdata *ndd,
 		struct nd_label_id *label_id);
 int alias_dpa_busy(struct device *dev, void *data);
* Unmerged path drivers/nvdimm/pfn_devs.c
diff --git a/drivers/nvdimm/region_devs.c b/drivers/nvdimm/region_devs.c
index d075c21f501f..3597b66e3cb3 100644
--- a/drivers/nvdimm/region_devs.c
+++ b/drivers/nvdimm/region_devs.c
@@ -1183,6 +1183,47 @@ int nvdimm_has_cache(struct nd_region *nd_region)
 }
 EXPORT_SYMBOL_GPL(nvdimm_has_cache);
 
+struct conflict_context {
+	struct nd_region *nd_region;
+	resource_size_t start, size;
+};
+
+static int region_conflict(struct device *dev, void *data)
+{
+	struct nd_region *nd_region;
+	struct conflict_context *ctx = data;
+	resource_size_t res_end, region_end, region_start;
+
+	if (!is_memory(dev))
+		return 0;
+
+	nd_region = to_nd_region(dev);
+	if (nd_region == ctx->nd_region)
+		return 0;
+
+	res_end = ctx->start + ctx->size;
+	region_start = nd_region->ndr_start;
+	region_end = region_start + nd_region->ndr_size;
+	if (ctx->start >= region_start && ctx->start < region_end)
+		return -EBUSY;
+	if (res_end > region_start && res_end <= region_end)
+		return -EBUSY;
+	return 0;
+}
+
+int nd_region_conflict(struct nd_region *nd_region, resource_size_t start,
+		resource_size_t size)
+{
+	struct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(&nd_region->dev);
+	struct conflict_context ctx = {
+		.nd_region = nd_region,
+		.start = start,
+		.size = size,
+	};
+
+	return device_for_each_child(&nvdimm_bus->dev, &ctx, region_conflict);
+}
+
 void __exit nd_region_devs_exit(void)
 {
 	ida_destroy(&region_ida);
