ipv4: fix memory leaks in ip_cmsg_send() callers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 919483096bfe75dda338e98d56da91a263746a0a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/91948309.failed

Dmitry reported memory leaks of IP options allocated in
ip_cmsg_send() when/if this function returns an error.

Callers are responsible for the freeing.

Many thanks to Dmitry for the report and diagnostic.

	Reported-by: Dmitry Vyukov <dvyukov@google.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 919483096bfe75dda338e98d56da91a263746a0a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/raw.c
diff --cc net/ipv4/raw.c
index 0cd045b9d560,7113bae4e6a0..000000000000
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@@ -525,9 -546,11 +525,16 @@@ static int raw_sendmsg(struct kiocb *io
  	ipc.oif = sk->sk_bound_dev_if;
  
  	if (msg->msg_controllen) {
++<<<<<<< HEAD
 +		err = ip_cmsg_send(sock_net(sk), msg, &ipc, false);
 +		if (err)
++=======
+ 		err = ip_cmsg_send(net, msg, &ipc, false);
+ 		if (unlikely(err)) {
+ 			kfree(ipc.opt);
++>>>>>>> 919483096bfe (ipv4: fix memory leaks in ip_cmsg_send() callers)
  			goto out;
+ 		}
  		if (ipc.opt)
  			free = 1;
  	}
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index 1ef6dc3508f1..19bc39e11819 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -216,6 +216,8 @@ int ip_cmsg_send(struct net *net, struct msghdr *msg, struct ipcm_cookie *ipc,
 		switch (cmsg->cmsg_type) {
 		case IP_RETOPTS:
 			err = cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr));
+
+			/* Our caller is responsible for freeing ipc->opt */
 			err = ip_options_get(net, &ipc->opt, CMSG_DATA(cmsg),
 					     err < 40 ? err : 40);
 			if (err)
diff --git a/net/ipv4/ping.c b/net/ipv4/ping.c
index 51ce23303b24..88a894354e1f 100644
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@ -535,8 +535,10 @@ static int ping_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 
 	if (msg->msg_controllen) {
 		err = ip_cmsg_send(sock_net(sk), msg, &ipc, false);
-		if (err)
+		if (unlikely(err)) {
+			kfree(ipc.opt);
 			return err;
+		}
 		if (ipc.opt)
 			free = 1;
 	}
* Unmerged path net/ipv4/raw.c
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 9a9ad5b95505..5ffc91bd251e 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -965,8 +965,10 @@ int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 	if (msg->msg_controllen) {
 		err = ip_cmsg_send(sock_net(sk), msg, &ipc,
 				   sk->sk_family == AF_INET6);
-		if (err)
+		if (unlikely(err)) {
+			kfree(ipc.opt);
 			return err;
+		}
 		if (ipc.opt)
 			free = 1;
 		connected = 0;
