s390: remove 31 bit support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [s390] remove 31 bit support (Yauheni Kaliuta) [1691710]
Rebuild_FUZZ: 87.50%
commit-author Heiko Carstens <heiko.carstens@de.ibm.com>
commit 5a79859ae0f35d25c67a03e82bf0c80592f16a39
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/5a79859a.failed

Remove the 31 bit support in order to reduce maintenance cost and
effectively remove dead code. Since a couple of years there is no
distribution left that comes with a 31 bit kernel.

The 31 bit kernel also has been broken since more than a year before
anybody noticed. In addition I added a removal warning to the kernel
shown at ipl for 5 minutes: a960062e5826 ("s390: add 31 bit warning
message") which let everybody know about the plan to remove 31 bit
code. We didn't get any response.

Given that the last 31 bit only machine was introduced in 1999 let's
remove the code.
Anybody with 31 bit user space code can still use the compat mode.

	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 5a79859ae0f35d25c67a03e82bf0c80592f16a39)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/Kconfig
#	arch/s390/boot/compressed/Makefile
#	arch/s390/include/asm/atomic.h
#	arch/s390/include/asm/bitops.h
#	arch/s390/include/asm/cputime.h
#	arch/s390/include/asm/ctl_reg.h
#	arch/s390/include/asm/jump_label.h
#	arch/s390/include/asm/lowcore.h
#	arch/s390/include/asm/mman.h
#	arch/s390/include/asm/mmu_context.h
#	arch/s390/include/asm/percpu.h
#	arch/s390/include/asm/pgtable.h
#	arch/s390/include/asm/processor.h
#	arch/s390/include/asm/rwsem.h
#	arch/s390/include/asm/setup.h
#	arch/s390/include/asm/tlb.h
#	arch/s390/include/asm/tlbflush.h
#	arch/s390/include/asm/unistd.h
#	arch/s390/kernel/Makefile
#	arch/s390/kernel/asm-offsets.c
#	arch/s390/kernel/base.S
#	arch/s390/kernel/cpcmd.c
#	arch/s390/kernel/dis.c
#	arch/s390/kernel/dumpstack.c
#	arch/s390/kernel/early.c
#	arch/s390/kernel/entry.S
#	arch/s390/kernel/head31.S
#	arch/s390/kernel/module.c
#	arch/s390/kernel/ptrace.c
#	arch/s390/kernel/relocate_kernel.S
#	arch/s390/kernel/setup.c
#	arch/s390/kernel/signal.c
#	arch/s390/kernel/smp.c
#	arch/s390/kernel/traps.c
#	arch/s390/lib/Makefile
#	arch/s390/mm/dump_pagetables.c
#	arch/s390/mm/fault.c
#	arch/s390/mm/init.c
#	arch/s390/mm/mem_detect.c
#	arch/s390/mm/mmap.c
#	arch/s390/mm/vmem.c
#	drivers/s390/block/dasd_eckd.c
#	drivers/s390/block/dasd_fba.c
#	drivers/s390/char/Kconfig
#	drivers/s390/crypto/ap_bus.c
diff --cc arch/s390/Kconfig
index b53742a99368,1de26e1c48ac..000000000000
--- a/arch/s390/Kconfig
+++ b/arch/s390/Kconfig
@@@ -110,47 -109,47 +110,68 @@@ config S39
  	select GENERIC_SMP_IDLE_THREAD
  	select GENERIC_TIME_VSYSCALL
  	select HAVE_ALIGNED_STRUCT_PAGE if SLUB
++<<<<<<< HEAD
 +	select HAVE_ARCH_JUMP_LABEL if !MARCH_G5
 +	select HAVE_ARCH_SECCOMP_FILTER
 +	select HAVE_ARCH_TRACEHOOK
 +	select HAVE_ARCH_TRANSPARENT_HUGEPAGE if 64BIT
 +	select HAVE_EBPF_JIT if 64BIT && PACK_STACK
++=======
+ 	select HAVE_ARCH_AUDITSYSCALL
+ 	select HAVE_ARCH_JUMP_LABEL
+ 	select HAVE_ARCH_SECCOMP_FILTER
+ 	select HAVE_ARCH_TRACEHOOK
+ 	select HAVE_ARCH_TRANSPARENT_HUGEPAGE
+ 	select HAVE_BPF_JIT if PACK_STACK
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	select HAVE_CMPXCHG_DOUBLE
  	select HAVE_CMPXCHG_LOCAL
 +	select HAVE_C_RECORDMCOUNT
  	select HAVE_DEBUG_KMEMLEAK
++<<<<<<< HEAD
 +	select HAVE_DMA_API_DEBUG
 +	select HAVE_DYNAMIC_FTRACE
 +	select HAVE_DYNAMIC_FTRACE_WITH_REGS if 64BIT
 +	select HAVE_FTRACE_MCOUNT_RECORD
 +	select HAVE_FUNCTION_GRAPH_TRACER
 +	select HAVE_FUNCTION_TRACER
++=======
+ 	select HAVE_DYNAMIC_FTRACE
+ 	select HAVE_DYNAMIC_FTRACE_WITH_REGS
+ 	select HAVE_FTRACE_MCOUNT_RECORD
+ 	select HAVE_FUNCTION_GRAPH_TRACER
+ 	select HAVE_FUNCTION_TRACER
+ 	select HAVE_FUTEX_CMPXCHG if FUTEX
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	select HAVE_KERNEL_BZIP2
  	select HAVE_KERNEL_GZIP
 -	select HAVE_KERNEL_LZ4
  	select HAVE_KERNEL_LZMA
  	select HAVE_KERNEL_LZO
  	select HAVE_KERNEL_XZ
  	select HAVE_KPROBES
  	select HAVE_KRETPROBES
++<<<<<<< HEAD
 +	select HAVE_KVM if 64BIT
 +	select HAVE_LIVEPATCH
++=======
+ 	select HAVE_KVM
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	select HAVE_MEMBLOCK
  	select HAVE_MEMBLOCK_NODE_MAP
 -	select HAVE_MEMBLOCK_PHYS_MAP
  	select HAVE_MOD_ARCH_SPECIFIC
  	select HAVE_OPROFILE
  	select HAVE_PERF_EVENTS
  	select HAVE_REGS_AND_STACK_ACCESS_API
  	select HAVE_SYSCALL_TRACEPOINTS
- 	select HAVE_UID16 if 32BIT
  	select HAVE_VIRT_CPU_ACCOUNTING
 +	select VIRT_TO_BUS
 +	select KTIME_SCALAR if 32BIT
  	select MODULES_USE_ELF_RELA
 -	select NO_BOOTMEM
 -	select OLD_SIGACTION
  	select OLD_SIGSUSPEND3
 +	select OLD_SIGACTION
  	select SYSCTL_EXCEPTION_TRACE
 -	select TTY
 +	select USE_GENERIC_SMP_HELPERS if SMP
  	select VIRT_CPU_ACCOUNTING
 -	select VIRT_TO_BUS
  
  config SCHED_OMIT_FRAME_POINTER
  	def_bool y
@@@ -372,14 -351,13 +372,13 @@@ config SM
  	  Even if you don't know what to do here, say Y.
  
  config NR_CPUS
 -	int "Maximum number of CPUs (2-512)"
 -	range 2 512
 +	int "Maximum number of CPUs (2-256)"
 +	range 2 256
  	depends on SMP
- 	default "32" if !64BIT
- 	default "64" if 64BIT
+ 	default "64"
  	help
  	  This allows you to specify the maximum number of CPUs which this
 -	  kernel will support. The maximum supported value is 512 and the
 +	  kernel will support. The maximum supported value is 256 and the
  	  minimum value which makes sense is 2.
  
  	  This is purely to save memory - each supported CPU adds
@@@ -421,78 -395,8 +420,69 @@@ config SCHED_TOPOLOG
  
  source kernel/Kconfig.preempt
  
- config MATHEMU
- 	def_bool y
- 	prompt "IEEE FPU emulation"
- 	depends on MARCH_G5
- 	help
- 	  This option is required for IEEE compliant floating point arithmetic
- 	  on older ESA/390 machines. Say Y unless you know your machine doesn't
- 	  need this.
- 
  source kernel/Kconfig.hz
  
 +config ARCH_RANDOM
 +	def_bool y
 +	prompt "s390 architectural random number generation API"
 +	help
 +	  Enable the s390 architectural random number generation API
 +	  to provide random data for all consumers within the Linux
 +	  kernel.
 +
 +	  When enabled the arch_random_* functions declared in linux/random.h
 +	  are implemented. The implementation is based on the s390 CPACF
 +	  instruction subfunction TRNG which provides a real true random
 +	  number generator.
 +
 +	  If unsure, say Y.
 +
 +config KERNEL_NOBP
 +	def_bool n
 +	prompt "Enable modified branch prediction for the kernel by default"
 +	help
 +	  If this option is selected the kernel will switch to a modified
 +	  branch prediction mode if the firmware interface is available.
 +	  The modified branch prediction mode improves the behaviour in
 +	  regard to speculative execution.
 +
 +	  With the option enabled the kernel parameter "nobp=0" or "nospec"
 +	  can be used to run the kernel in the normal branch prediction mode.
 +
 +	  With the option disabled the modified branch prediction mode is
 +	  enabled with the "nobp=1" kernel parameter.
 +
 +	  If unsure, say N.
 +
 +config EXPOLINE
 +	def_bool n
 +	prompt "Avoid speculative indirect branches in the kernel"
 +	depends on 64BIT
 +	help
 +	  Compile the kernel with the expoline compiler options to guard
 +	  against kernel-to-user data leaks by avoiding speculative indirect
 +	  branches.
 +	  Requires a compiler with -mindirect-branch=thunk support for full
 +	  protection. The kernel may run slower.
 +
 +	  If unsure, say N.
 +
 +choice
 +	prompt "Expoline default"
 +	depends on EXPOLINE
 +	default EXPOLINE_FULL
 +
 +config EXPOLINE_OFF
 +	bool "spectre_v2=off"
 +
 +config EXPOLINE_AUTO
 +	bool "spectre_v2=auto"
 +
 +config EXPOLINE_FULL
 +	bool "spectre_v2=on"
 +
 +endchoice
 +
  endmenu
  
  menu "Memory setup"
@@@ -515,9 -418,8 +504,12 @@@ config ARCH_ENABLE_MEMORY_HOTPLU
  config ARCH_ENABLE_MEMORY_HOTREMOVE
  	def_bool y
  
 -config ARCH_ENABLE_SPLIT_PMD_PTLOCK
 +config ARCH_HAS_ADD_PAGES
  	def_bool y
++<<<<<<< HEAD
 +	depends on ARCH_ENABLE_MEMORY_HOTPLUG
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  
  config FORCE_MAX_ZONEORDER
  	int
@@@ -592,7 -494,7 +584,11 @@@ config QDI
  
  menuconfig PCI
  	bool "PCI support"
++<<<<<<< HEAD
 +	depends on 64BIT
++=======
+ 	select HAVE_DMA_ATTRS
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	select PCI_MSI
  	help
  	  Enable PCI support.
@@@ -665,25 -582,10 +660,25 @@@ endmen
  
  menu "Dump support"
  
 +config KEXEC_AUTO_RESERVE
 +	bool "automatically reserve memory for kexec kernel"
 +	depends on KEXEC
 +	default y
 +	---help---
 +	  Automatically reserve memory for a kexec kernel, so that you don't
 +	  need to specify numbers for the "crashkernel=X@Y" boot option,
 +	  instead you can use "crashkernel=auto". This option works for
 +	  systems that have at least 4 GiB memory. Then 128 MiB plus a small
 +	  amount of additional memory that grows linearly with the 1st kernel
 +	  memory size is reserved. When "crashkernel=auto" is used for
 +	  systems with less than 4 GiB memory, no crashkernel memory will be
 +	  reserved.
 +
  config CRASH_DUMP
  	bool "kernel crash dumps"
- 	depends on 64BIT && SMP
+ 	depends on SMP
  	select KEXEC
 +	select ZFCPDUMP
  	help
  	  Generate crash dump after being started by kexec.
  	  Crash dump kernels are loaded in the main kernel with kexec-tools
@@@ -878,7 -774,7 +873,11 @@@ source "arch/s390/kvm/Kconfig
  config S390_GUEST
  	def_bool y
  	prompt "s390 support for virtio devices"
++<<<<<<< HEAD
 +	depends on 64BIT
++=======
+ 	select TTY
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	select VIRTUALIZATION
  	select VIRTIO
  	select VIRTIO_CONSOLE
diff --cc arch/s390/boot/compressed/Makefile
index 3ad8f61c9985,254fb05c5d6c..000000000000
--- a/arch/s390/boot/compressed/Makefile
+++ b/arch/s390/boot/compressed/Makefile
@@@ -4,15 -4,13 +4,21 @@@
  # create a compressed vmlinux image from the original vmlinux
  #
  
++<<<<<<< HEAD
 +BITS := $(if $(CONFIG_64BIT),64,31)
 +
 +targets	:= vmlinux.lds vmlinux vmlinux.bin vmlinux.bin.gz vmlinux.bin.bz2 \
 +	   vmlinux.bin.xz vmlinux.bin.lzma vmlinux.bin.lzo misc.o piggy.o \
 +	   sizes.h head$(BITS).o
++=======
+ targets	:= vmlinux.lds vmlinux vmlinux.bin vmlinux.bin.gz vmlinux.bin.bz2
+ targets += vmlinux.bin.xz vmlinux.bin.lzma vmlinux.bin.lzo vmlinux.bin.lz4
+ targets += misc.o piggy.o sizes.h head64.o
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  
- KBUILD_CFLAGS := -m$(BITS) -D__KERNEL__ $(LINUX_INCLUDE) -O2
+ KBUILD_CFLAGS := -m64 -D__KERNEL__ $(LINUX_INCLUDE) -O2
  KBUILD_CFLAGS += -DDISABLE_BRANCH_PROFILING
 -KBUILD_CFLAGS += $(cflags-y) -fno-delete-null-pointer-checks
 +KBUILD_CFLAGS += $(cflags-y)
  KBUILD_CFLAGS += $(call cc-option,-mpacked-stack)
  KBUILD_CFLAGS += $(call cc-option,-ffreestanding)
  
diff --cc arch/s390/include/asm/atomic.h
index 43f471c111b9,adbe3802e377..000000000000
--- a/arch/s390/include/asm/atomic.h
+++ b/arch/s390/include/asm/atomic.h
@@@ -113,10 -160,42 +113,46 @@@ static inline int __atomic_add_unless(a
  
  #define ATOMIC64_INIT(i)  { (i) }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_64BIT
 +
 +#define __CSG_LOOP(ptr, op_val, op_string) ({				\
++=======
+ #define __ATOMIC64_NO_BARRIER	"\n"
+ 
+ #ifdef CONFIG_HAVE_MARCH_Z196_FEATURES
+ 
+ #define __ATOMIC64_OR	"laog"
+ #define __ATOMIC64_AND	"lang"
+ #define __ATOMIC64_ADD	"laag"
+ #define __ATOMIC64_BARRIER "bcr	14,0\n"
+ 
+ #define __ATOMIC64_LOOP(ptr, op_val, op_string, __barrier)		\
+ ({									\
+ 	long long old_val;						\
+ 									\
+ 	typecheck(atomic64_t *, ptr);					\
+ 	asm volatile(							\
+ 		__barrier						\
+ 		op_string "	%0,%2,%1\n"				\
+ 		__barrier						\
+ 		: "=d" (old_val), "+Q" ((ptr)->counter)			\
+ 		: "d" (op_val)						\
+ 		: "cc", "memory");					\
+ 	old_val;							\
+ })
+ 
+ #else /* CONFIG_HAVE_MARCH_Z196_FEATURES */
+ 
+ #define __ATOMIC64_OR	"ogr"
+ #define __ATOMIC64_AND	"ngr"
+ #define __ATOMIC64_ADD	"agr"
+ #define __ATOMIC64_BARRIER "\n"
+ 
+ #define __ATOMIC64_LOOP(ptr, op_val, op_string, __barrier)		\
+ ({									\
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	long long old_val, new_val;					\
 -									\
 -	typecheck(atomic64_t *, ptr);					\
  	asm volatile(							\
  		"	lg	%0,%2\n"				\
  		"0:	lgr	%1,%0\n"				\
@@@ -180,108 -270,9 +216,112 @@@ static inline long long atomic64_cmpxch
  	return old;
  }
  
 -#undef __ATOMIC64_LOOP
 +#undef __CSG_LOOP
 +
++<<<<<<< HEAD
 +#else /* CONFIG_64BIT */
 +
 +typedef struct {
 +	long long counter;
 +} atomic64_t;
 +
 +static inline long long atomic64_read(const atomic64_t *v)
 +{
 +	register_pair rp;
 +
 +	asm volatile(
 +		"	lm	%0,%N0,%1"
 +		: "=&d" (rp) : "Q" (v->counter)	);
 +	return rp.pair;
 +}
 +
 +static inline void atomic64_set(atomic64_t *v, long long i)
 +{
 +	register_pair rp = {.pair = i};
 +
 +	asm volatile(
 +		"	stm	%1,%N1,%0"
 +		: "=Q" (v->counter) : "d" (rp) );
 +}
 +
 +static inline long long atomic64_xchg(atomic64_t *v, long long new)
 +{
 +	register_pair rp_new = {.pair = new};
 +	register_pair rp_old;
 +
 +	asm volatile(
 +		"	lm	%0,%N0,%1\n"
 +		"0:	cds	%0,%2,%1\n"
 +		"	jl	0b\n"
 +		: "=&d" (rp_old), "=Q" (v->counter)
 +		: "d" (rp_new), "Q" (v->counter)
 +		: "cc");
 +	return rp_old.pair;
 +}
 +
 +static inline long long atomic64_cmpxchg(atomic64_t *v,
 +					 long long old, long long new)
 +{
 +	register_pair rp_old = {.pair = old};
 +	register_pair rp_new = {.pair = new};
 +
 +	asm volatile(
 +		"	cds	%0,%2,%1"
 +		: "+&d" (rp_old), "=Q" (v->counter)
 +		: "d" (rp_new), "Q" (v->counter)
 +		: "cc");
 +	return rp_old.pair;
 +}
 +
 +
 +static inline long long atomic64_add_return(long long i, atomic64_t *v)
 +{
 +	long long old, new;
 +
 +	do {
 +		old = atomic64_read(v);
 +		new = old + i;
 +	} while (atomic64_cmpxchg(v, old, new) != old);
 +	return new;
 +}
 +
 +static inline long long atomic64_sub_return(long long i, atomic64_t *v)
 +{
 +	long long old, new;
 +
 +	do {
 +		old = atomic64_read(v);
 +		new = old - i;
 +	} while (atomic64_cmpxchg(v, old, new) != old);
 +	return new;
 +}
 +
 +static inline void atomic64_set_mask(unsigned long long mask, atomic64_t *v)
 +{
 +	long long old, new;
 +
 +	do {
 +		old = atomic64_read(v);
 +		new = old | mask;
 +	} while (atomic64_cmpxchg(v, old, new) != old);
 +}
 +
 +static inline void atomic64_clear_mask(unsigned long long mask, atomic64_t *v)
 +{
 +	long long old, new;
 +
 +	do {
 +		old = atomic64_read(v);
 +		new = old & mask;
 +	} while (atomic64_cmpxchg(v, old, new) != old);
 +}
 +
 +#endif /* CONFIG_64BIT */
  
 +static inline int atomic64_add_unless(atomic64_t *v, long long a, long long u)
++=======
+ static inline int atomic64_add_unless(atomic64_t *v, long long i, long long u)
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  {
  	long long c, old;
  
diff --cc arch/s390/include/asm/bitops.h
index 6038349c8410,9b68e98a724f..000000000000
--- a/arch/s390/include/asm/bitops.h
+++ b/arch/s390/include/asm/bitops.h
@@@ -17,72 -47,10 +17,75 @@@
  
  #include <linux/typecheck.h>
  #include <linux/compiler.h>
 -#include <asm/barrier.h>
  
 -#define __BITOPS_NO_BARRIER	"\n"
 +/*
 + * 32 bit bitops format:
 + * bit 0 is the LSB of *addr; bit 31 is the MSB of *addr;
 + * bit 32 is the LSB of *(addr+4). That combined with the
 + * big endian byte order on S390 give the following bit
 + * order in memory:
 + *    1f 1e 1d 1c 1b 1a 19 18 17 16 15 14 13 12 11 10 \
 + *    0f 0e 0d 0c 0b 0a 09 08 07 06 05 04 03 02 01 00
 + * after that follows the next long with bit numbers
 + *    3f 3e 3d 3c 3b 3a 39 38 37 36 35 34 33 32 31 30
 + *    2f 2e 2d 2c 2b 2a 29 28 27 26 25 24 23 22 21 20
 + * The reason for this bit ordering is the fact that
 + * in the architecture independent code bits operations
 + * of the form "flags |= (1 << bitnr)" are used INTERMIXED
 + * with operation of the form "set_bit(bitnr, flags)".
 + *
 + * 64 bit bitops format:
 + * bit 0 is the LSB of *addr; bit 63 is the MSB of *addr;
 + * bit 64 is the LSB of *(addr+8). That combined with the
 + * big endian byte order on S390 give the following bit
 + * order in memory:
 + *    3f 3e 3d 3c 3b 3a 39 38 37 36 35 34 33 32 31 30
 + *    2f 2e 2d 2c 2b 2a 29 28 27 26 25 24 23 22 21 20
 + *    1f 1e 1d 1c 1b 1a 19 18 17 16 15 14 13 12 11 10
 + *    0f 0e 0d 0c 0b 0a 09 08 07 06 05 04 03 02 01 00
 + * after that follows the next long with bit numbers
 + *    7f 7e 7d 7c 7b 7a 79 78 77 76 75 74 73 72 71 70
 + *    6f 6e 6d 6c 6b 6a 69 68 67 66 65 64 63 62 61 60
 + *    5f 5e 5d 5c 5b 5a 59 58 57 56 55 54 53 52 51 50
 + *    4f 4e 4d 4c 4b 4a 49 48 47 46 45 44 43 42 41 40
 + * The reason for this bit ordering is the fact that
 + * in the architecture independent code bits operations
 + * of the form "flags |= (1 << bitnr)" are used INTERMIXED
 + * with operation of the form "set_bit(bitnr, flags)".
 + */
 +
 +/* bitmap tables from arch/s390/kernel/bitmap.c */
 +extern const char _zb_findmap[];
 +extern const char _sb_findmap[];
 +
++<<<<<<< HEAD
 +#ifndef CONFIG_64BIT
 +
 +#define __BITOPS_OR		"or"
 +#define __BITOPS_AND		"nr"
 +#define __BITOPS_XOR		"xr"
  
 +#define __BITOPS_LOOP(__addr, __val, __op_string)		\
 +({								\
 +	unsigned long __old, __new;				\
 +								\
 +	typecheck(unsigned long *, (__addr));			\
 +	asm volatile(						\
 +		"	l	%0,%2\n"			\
 +		"0:	lr	%1,%0\n"			\
 +		__op_string "	%1,%3\n"			\
 +		"	cs	%0,%1,%2\n"			\
 +		"	jl	0b"				\
 +		: "=&d" (__old), "=&d" (__new), "+Q" (*(__addr))\
 +		: "d" (__val)					\
 +		: "cc");					\
 +	__old;							\
 +})
 +
 +#else /* CONFIG_64BIT */
 +
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  #ifdef CONFIG_HAVE_MARCH_Z196_FEATURES
  
  #define __BITOPS_OR		"laog"
diff --cc arch/s390/include/asm/cputime.h
index 3001887f94b7,221b454c734a..000000000000
--- a/arch/s390/include/asm/cputime.h
+++ b/arch/s390/include/asm/cputime.h
@@@ -101,17 -93,8 +93,22 @@@ static inline void cputime_to_timespec(
  				       struct timespec *value)
  {
  	unsigned long long __cputime = (__force unsigned long long) cputime;
++<<<<<<< HEAD
 +#ifndef CONFIG_64BIT
 +	register_pair rp;
 +
 +	rp.pair = __cputime >> 1;
 +	asm ("dr %0,%1" : "+d" (rp) : "d" (2048000000UL));
 +	value->tv_nsec = rp.subreg.even * 1000 / 4096;
 +	value->tv_sec = rp.subreg.odd;
 +#else
 +	value->tv_nsec = (__cputime % 4096000000ULL) * 1000 / 4096;
 +	value->tv_sec = __cputime / 4096000000ULL;
 +#endif
++=======
+ 	value->tv_nsec = (__cputime % CPUTIME_PER_SEC) * NSEC_PER_USEC / CPUTIME_PER_USEC;
+ 	value->tv_sec = __cputime / CPUTIME_PER_SEC;
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  }
  
  /*
@@@ -129,17 -112,8 +126,22 @@@ static inline void cputime_to_timeval(c
  				      struct timeval *value)
  {
  	unsigned long long __cputime = (__force unsigned long long) cputime;
++<<<<<<< HEAD
 +#ifndef CONFIG_64BIT
 +	register_pair rp;
 +
 +	rp.pair = __cputime >> 1;
 +	asm ("dr %0,%1" : "+d" (rp) : "d" (2048000000UL));
 +	value->tv_usec = rp.subreg.even / 4096;
 +	value->tv_sec = rp.subreg.odd;
 +#else
 +	value->tv_usec = (__cputime % 4096000000ULL) / 4096;
 +	value->tv_sec = __cputime / 4096000000ULL;
 +#endif
++=======
+ 	value->tv_usec = (__cputime % CPUTIME_PER_SEC) / CPUTIME_PER_USEC;
+ 	value->tv_sec = __cputime / CPUTIME_PER_SEC;
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  }
  
  /*
diff --cc arch/s390/include/asm/ctl_reg.h
index e8289bc6d454,cfad7fca01d6..000000000000
--- a/arch/s390/include/asm/ctl_reg.h
+++ b/arch/s390/include/asm/ctl_reg.h
@@@ -9,57 -9,45 +9,78 @@@
  
  #include <linux/bug.h>
  
++<<<<<<< HEAD
 +#ifdef CONFIG_64BIT
 +
 +#define __ctl_load(array, low, high) ({				\
 +	typedef struct { char _[sizeof(array)]; } addrtype;	\
 +	asm volatile(						\
 +		"	lctlg	%1,%2,%0\n"			\
 +		: : "Q" (*(addrtype *)(&array)),		\
 +		    "i" (low), "i" (high));			\
 +	})
 +
 +#define __ctl_store(array, low, high) ({			\
 +	typedef struct { char _[sizeof(array)]; } addrtype;	\
 +	asm volatile(						\
 +		"	stctg	%1,%2,%0\n"			\
 +		: "=Q" (*(addrtype *)(&array))			\
 +		: "i" (low), "i" (high));			\
 +	})
++=======
+ #define __ctl_load(array, low, high) {					\
+ 	typedef struct { char _[sizeof(array)]; } addrtype;		\
+ 									\
+ 	BUILD_BUG_ON(sizeof(addrtype) != (high - low + 1) * sizeof(long));\
+ 	asm volatile(							\
+ 		"	lctlg	%1,%2,%0\n"				\
+ 		: : "Q" (*(addrtype *)(&array)), "i" (low), "i" (high));\
+ }
+ 
+ #define __ctl_store(array, low, high) {					\
+ 	typedef struct { char _[sizeof(array)]; } addrtype;		\
+ 									\
+ 	BUILD_BUG_ON(sizeof(addrtype) != (high - low + 1) * sizeof(long));\
+ 	asm volatile(							\
+ 		"	stctg	%1,%2,%0\n"				\
+ 		: "=Q" (*(addrtype *)(&array))				\
+ 		: "i" (low), "i" (high));				\
+ }
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  
 -static inline void __ctl_set_bit(unsigned int cr, unsigned int bit)
 -{
 -	unsigned long reg;
 +#else /* CONFIG_64BIT */
  
 -	__ctl_store(reg, cr, cr);
 -	reg |= 1UL << bit;
 -	__ctl_load(reg, cr, cr);
 -}
 +#define __ctl_load(array, low, high) ({				\
 +	typedef struct { char _[sizeof(array)]; } addrtype;	\
 +	asm volatile(						\
 +		"	lctl	%1,%2,%0\n"			\
 +		: : "Q" (*(addrtype *)(&array)),		\
 +		    "i" (low), "i" (high));			\
 +})
  
 -static inline void __ctl_clear_bit(unsigned int cr, unsigned int bit)
 -{
 -	unsigned long reg;
 +#define __ctl_store(array, low, high) ({			\
 +	typedef struct { char _[sizeof(array)]; } addrtype;	\
 +	asm volatile(						\
 +		"	stctl	%1,%2,%0\n"			\
 +		: "=Q" (*(addrtype *)(&array))			\
 +		: "i" (low), "i" (high));			\
 +	})
  
 -	__ctl_store(reg, cr, cr);
 -	reg &= ~(1UL << bit);
 -	__ctl_load(reg, cr, cr);
 -}
 +#endif /* CONFIG_64BIT */
 +
 +#define __ctl_set_bit(cr, bit) ({	\
 +	unsigned long __dummy;		\
 +	__ctl_store(__dummy, cr, cr);	\
 +	__dummy |= 1UL << (bit);	\
 +	__ctl_load(__dummy, cr, cr);	\
 +})
  
 -void smp_ctl_set_bit(int cr, int bit);
 -void smp_ctl_clear_bit(int cr, int bit);
 +#define __ctl_clear_bit(cr, bit) ({	\
 +	unsigned long __dummy;		\
 +	__ctl_store(__dummy, cr, cr);	\
 +	__dummy &= ~(1UL << (bit));	\
 +	__ctl_load(__dummy, cr, cr);	\
 +})
  
  union ctlreg0 {
  	unsigned long val;
diff --cc arch/s390/include/asm/jump_label.h
index 346b1c85ffb4,510012bceb75..000000000000
--- a/arch/s390/include/asm/jump_label.h
+++ b/arch/s390/include/asm/jump_label.h
@@@ -4,21 -4,18 +4,28 @@@
  #include <linux/types.h>
  
  #define JUMP_LABEL_NOP_SIZE 6
 -#define JUMP_LABEL_NOP_OFFSET 2
  
++<<<<<<< HEAD
 +#ifdef CONFIG_64BIT
 +#define ASM_PTR ".quad"
 +#define ASM_ALIGN ".balign 8"
 +#else
 +#define ASM_PTR ".long"
 +#define ASM_ALIGN ".balign 4"
 +#endif
 +
++=======
+ /*
+  * We use a brcl 0,2 instruction for jump labels at compile time so it
+  * can be easily distinguished from a hotpatch generated instruction.
+  */
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  static __always_inline bool arch_static_branch(struct static_key *key)
  {
 -	asm_volatile_goto("0:	brcl 0,"__stringify(JUMP_LABEL_NOP_OFFSET)"\n"
 +	asm_volatile_goto("0:	brcl 0,0\n"
  		".pushsection __jump_table, \"aw\"\n"
- 		ASM_ALIGN "\n"
- 		ASM_PTR " 0b, %l[label], %0\n"
+ 		".balign 8\n"
+ 		".quad 0b, %l[label], %0\n"
  		".popsection\n"
  		: : "X" (key) : : label);
  	return false;
diff --cc arch/s390/include/asm/lowcore.h
index ba61ae080ac1,663f23e37460..000000000000
--- a/arch/s390/include/asm/lowcore.h
+++ b/arch/s390/include/asm/lowcore.h
@@@ -13,168 -13,6 +13,171 @@@
  #include <asm/cpu.h>
  #include <asm/types.h>
  
++<<<<<<< HEAD
 +#ifdef CONFIG_32BIT
 +
 +#define LC_ORDER 0
 +#define LC_PAGES 1
 +
 +struct save_area {
 +	u32	ext_save;
 +	u64	timer;
 +	u64	clk_cmp;
 +	u8	pad1[24];
 +	u8	psw[8];
 +	u32	pref_reg;
 +	u8	pad2[20];
 +	u32	acc_regs[16];
 +	u64	fp_regs[4];
 +	u32	gp_regs[16];
 +	u32	ctrl_regs[16];
 +} __packed;
 +
 +struct save_area_ext {
 +	struct save_area	sa;
 +	__vector128		vx_regs[32];
 +};
 +
 +struct _lowcore {
 +	psw_t	restart_psw;			/* 0x0000 */
 +	psw_t	restart_old_psw;		/* 0x0008 */
 +	__u8	pad_0x0010[0x0014-0x0010];	/* 0x0010 */
 +	__u32	ipl_parmblock_ptr;		/* 0x0014 */
 +	psw_t	external_old_psw;		/* 0x0018 */
 +	psw_t	svc_old_psw;			/* 0x0020 */
 +	psw_t	program_old_psw;		/* 0x0028 */
 +	psw_t	mcck_old_psw;			/* 0x0030 */
 +	psw_t	io_old_psw;			/* 0x0038 */
 +	__u8	pad_0x0040[0x0058-0x0040];	/* 0x0040 */
 +	psw_t	external_new_psw;		/* 0x0058 */
 +	psw_t	svc_new_psw;			/* 0x0060 */
 +	psw_t	program_new_psw;		/* 0x0068 */
 +	psw_t	mcck_new_psw;			/* 0x0070 */
 +	psw_t	io_new_psw;			/* 0x0078 */
 +	__u32	ext_params;			/* 0x0080 */
 +	__u16	ext_cpu_addr;			/* 0x0084 */
 +	__u16	ext_int_code;			/* 0x0086 */
 +	__u16	svc_ilc;			/* 0x0088 */
 +	__u16	svc_code;			/* 0x008a */
 +	__u16	pgm_ilc;			/* 0x008c */
 +	__u16	pgm_code;			/* 0x008e */
 +	__u32	trans_exc_code;			/* 0x0090 */
 +	__u16	mon_class_num;			/* 0x0094 */
 +	__u16	per_perc_atmid;			/* 0x0096 */
 +	__u32	per_address;			/* 0x0098 */
 +	__u32	monitor_code;			/* 0x009c */
 +	__u8	exc_access_id;			/* 0x00a0 */
 +	__u8	per_access_id;			/* 0x00a1 */
 +	__u8	op_access_id;			/* 0x00a2 */
 +	__u8	ar_access_id;			/* 0x00a3 */
 +	__u8	pad_0x00a4[0x00b8-0x00a4];	/* 0x00a4 */
 +	__u16	subchannel_id;			/* 0x00b8 */
 +	__u16	subchannel_nr;			/* 0x00ba */
 +	__u32	io_int_parm;			/* 0x00bc */
 +	__u32	io_int_word;			/* 0x00c0 */
 +	__u8	pad_0x00c4[0x00c8-0x00c4];	/* 0x00c4 */
 +	__u32	stfl_fac_list;			/* 0x00c8 */
 +	__u8	pad_0x00cc[0x00d4-0x00cc];	/* 0x00cc */
 +	__u32	extended_save_area_addr;	/* 0x00d4 */
 +	__u32	cpu_timer_save_area[2];		/* 0x00d8 */
 +	__u32	clock_comp_save_area[2];	/* 0x00e0 */
 +	__u32	mcck_interruption_code[2];	/* 0x00e8 */
 +	__u8	pad_0x00f0[0x00f4-0x00f0];	/* 0x00f0 */
 +	__u32	external_damage_code;		/* 0x00f4 */
 +	__u32	failing_storage_address;	/* 0x00f8 */
 +	__u8	pad_0x00fc[0x0100-0x00fc];	/* 0x00fc */
 +	psw_t	psw_save_area;			/* 0x0100 */
 +	__u32	prefixreg_save_area;		/* 0x0108 */
 +	__u8	pad_0x010c[0x0120-0x010c];	/* 0x010c */
 +
 +	/* CPU register save area: defined by architecture */
 +	__u32	access_regs_save_area[16];	/* 0x0120 */
 +	__u32	floating_pt_save_area[8];	/* 0x0160 */
 +	__u32	gpregs_save_area[16];		/* 0x0180 */
 +	__u32	cregs_save_area[16];		/* 0x01c0 */
 +
 +	/* Save areas. */
 +	__u32	save_area_sync[8];		/* 0x0200 */
 +	__u32	save_area_async[8];		/* 0x0220 */
 +	__u32	save_area_restart[1];		/* 0x0240 */
 +	__u8	pad_0x0244[0x0248-0x0244];	/* 0x0244 */
 +
 +	/* Return psws. */
 +	psw_t	return_psw;			/* 0x0248 */
 +	psw_t	return_mcck_psw;		/* 0x0250 */
 +
 +	/* CPU time accounting values */
 +	__u64	sync_enter_timer;		/* 0x0258 */
 +	__u64	async_enter_timer;		/* 0x0260 */
 +	__u64	mcck_enter_timer;		/* 0x0268 */
 +	__u64	exit_timer;			/* 0x0270 */
 +	__u64	user_timer;			/* 0x0278 */
 +	__u64	system_timer;			/* 0x0280 */
 +	__u64	steal_timer;			/* 0x0288 */
 +	__u64	last_update_timer;		/* 0x0290 */
 +	__u64	last_update_clock;		/* 0x0298 */
 +	__u64	int_clock;			/* 0x02a0 */
 +	__u64	mcck_clock;			/* 0x02a8 */
 +	__u64	clock_comparator;		/* 0x02b0 */
 +
 +	/* Current process. */
 +	__u32	current_task;			/* 0x02b8 */
 +	__u32	thread_info;			/* 0x02bc */
 +	__u32	kernel_stack;			/* 0x02c0 */
 +
 +	/* Interrupt, panic and restart stack. */
 +	__u32	async_stack;			/* 0x02c4 */
 +	__u32	panic_stack;			/* 0x02c8 */
 +	__u32	restart_stack;			/* 0x02cc */
 +
 +	/* Restart function and parameter. */
 +	__u32	restart_fn;			/* 0x02d0 */
 +	__u32	restart_data;			/* 0x02d4 */
 +	__u32	restart_source;			/* 0x02d8 */
 +
 +	/* Address space pointer. */
 +	__u32	kernel_asce;			/* 0x02dc */
 +	__u32	user_asce;			/* 0x02e0 */
 +	__u32	current_pid;			/* 0x02e4 */
 +
 +	/* SMP info area */
 +	__u32	cpu_nr;				/* 0x02e8 */
 +	__u32	softirq_pending;		/* 0x02ec */
 +	__u32	percpu_offset;			/* 0x02f0 */
 +	__u32	machine_flags;			/* 0x02f4 */
 +	__u32	ftrace_func;			/* 0x02f8 */
 +	__u32	spinlock_lockval;		/* 0x02fc */
 +
 +	/* Interrupt response block */
 +	__u8	irb[64];			/* 0x0300 */
 +
 +	__u8	pad_0x0340[0x0400-0x0340];	/* 0x0340 */
 +
 +	/* br %r1 trampoline */
 +	__u16	br_r1_trampoline;		/* 0x0400 */
 +	__u8	pad_0x0402[0x0e00-0x0402];	/* 0x0402 */
 +
 +	/*
 +	 * 0xe00 contains the address of the IPL Parameter Information
 +	 * block. Dump tools need IPIB for IPL after dump.
 +	 * Note: do not change the position of any fields in 0x0e00-0x0f00
 +	 */
 +	__u32	ipib;				/* 0x0e00 */
 +	__u32	ipib_checksum;			/* 0x0e04 */
 +	__u32	vmcore_info;			/* 0x0e08 */
 +	__u8	pad_0x0e0c[0x0e18-0x0e0c];	/* 0x0e0c */
 +	__u32	os_info;			/* 0x0e18 */
 +	__u8	pad_0x0e1c[0x0f00-0x0e1c];	/* 0x0e1c */
 +
 +	/* Extended facility list */
 +	__u64	stfle_fac_list[16];		/* 0x0f00 */
 +	__u64	alt_stfle_fac_list[16];		/* 0x0f80 */
 +} __packed;
 +
 +#else /* CONFIG_32BIT */
 +
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  #define LC_ORDER 1
  #define LC_PAGES 2
  
@@@ -365,11 -191,12 +368,9 @@@ struct _lowcore 
  
  	/* Transaction abort diagnostic block */
  	__u8	pgm_tdb[256];			/* 0x1800 */
 -	__u8	pad_0x1900[0x1c00-0x1900];	/* 0x1900 */
 -
 -	/* Software defined save area for vector registers */
 -	__u8	vector_save_area[1024];		/* 0x1c00 */
 +	__u8	pad_0x1900[0x2000-0x1900];	/* 0x1900 */
  } __packed;
  
- #endif /* CONFIG_32BIT */
- 
  #define S390_lowcore (*((struct _lowcore *) 0))
  
  extern struct _lowcore *lowcore_ptr[];
diff --cc arch/s390/include/asm/mman.h
index b79813d9cf68,b55a59e1d134..000000000000
--- a/arch/s390/include/asm/mman.h
+++ b/arch/s390/include/asm/mman.h
@@@ -8,4 -8,8 +8,11 @@@
  
  #include <uapi/asm/mman.h>
  
++<<<<<<< HEAD
++=======
+ #ifndef __ASSEMBLY__
+ int s390_mmap_check(unsigned long addr, unsigned long len, unsigned long flags);
+ #define arch_mmap_check(addr, len, flags) s390_mmap_check(addr, len, flags)
+ #endif
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  #endif /* __S390_MMAN_H__ */
diff --cc arch/s390/include/asm/mmu_context.h
index 57a6373c2555,d25d9ff10ba8..000000000000
--- a/arch/s390/include/asm/mmu_context.h
+++ b/arch/s390/include/asm/mmu_context.h
@@@ -15,34 -15,14 +15,39 @@@
  static inline int init_new_context(struct task_struct *tsk,
  				   struct mm_struct *mm)
  {
 -	cpumask_clear(&mm->context.cpu_attach_mask);
  	atomic_set(&mm->context.attach_count, 0);
  	mm->context.flush_mm = 0;
++<<<<<<< HEAD
++=======
+ 	mm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;
+ 	mm->context.asce_bits |= _ASCE_TYPE_REGION3;
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	mm->context.has_pgste = 0;
 -	mm->context.use_skey = 0;
 -	mm->context.asce_limit = STACK_TOP_MAX;
 +	switch (mm->context.asce_limit) {
 +	case 1UL << 42:
 +		/*
 +		 * forked 3-level task, fall through to set new asce with new
 +		 * mm->pgd
 +		 */
 +	case 0:
 +		/* context created by exec, set asce limit to 4TB */
 +		mm->context.asce = __pa(mm->pgd) | _ASCE_TABLE_LENGTH |
 +				   _ASCE_USER_BITS;
 +#ifdef CONFIG_64BIT
 +		mm->context.asce |= _ASCE_TYPE_REGION3;
 +#endif
 +		mm->context.asce_limit = STACK_TOP_MAX;
 +		break;
 +	case 1UL << 53:
 +		/* forked 4-level task, set new asce with new mm->pgd */
 +		mm->context.asce = __pa(mm->pgd) | _ASCE_TABLE_LENGTH |
 +				   _ASCE_USER_BITS | _ASCE_TYPE_REGION2;
 +		break;
 +	case 1UL << 31:
 +		/* forked 2-level compat task, set new asce with new mm->pgd */
 +		mm->context.asce = __pa(mm->pgd) | _ASCE_TABLE_LENGTH |
 +				   _ASCE_USER_BITS | _ASCE_TYPE_SEGMENT;
 +	}
  	crst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));
  	return 0;
  }
@@@ -91,6 -108,8 +96,11 @@@ static inline void activate_mm(struct m
  static inline void arch_dup_mmap(struct mm_struct *oldmm,
  				 struct mm_struct *mm)
  {
++<<<<<<< HEAD
++=======
+ 	if (oldmm->context.asce_limit < mm->context.asce_limit)
+ 		crst_table_downgrade(mm, oldmm->context.asce_limit);
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  }
  
  static inline void arch_exit_mmap(struct mm_struct *mm)
diff --cc arch/s390/include/asm/percpu.h
index 86fe0ee2cee5,6d6556ca24aa..000000000000
--- a/arch/s390/include/asm/percpu.h
+++ b/arch/s390/include/asm/percpu.h
@@@ -124,9 -179,7 +124,12 @@@
  })
  
  #define this_cpu_cmpxchg_double_4 arch_this_cpu_cmpxchg_double
 +#ifdef CONFIG_64BIT
  #define this_cpu_cmpxchg_double_8 arch_this_cpu_cmpxchg_double
++<<<<<<< HEAD
 +#endif
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  
  #include <asm-generic/percpu.h>
  
diff --cc arch/s390/include/asm/pgtable.h
index b22f965817c2,989cfae9e202..000000000000
--- a/arch/s390/include/asm/pgtable.h
+++ b/arch/s390/include/asm/pgtable.h
@@@ -94,16 -84,11 +88,18 @@@ extern unsigned long zero_page_mask
   * that leads to 1024 pte per pgd
   */
  #define PTRS_PER_PTE	256
++<<<<<<< HEAD
 +#ifndef CONFIG_64BIT
 +#define PTRS_PER_PMD	1
 +#define PTRS_PER_PUD	1
 +#else /* CONFIG_64BIT */
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  #define PTRS_PER_PMD	2048
  #define PTRS_PER_PUD	2048
- #endif /* CONFIG_64BIT */
  #define PTRS_PER_PGD	2048
  
 -#define FIRST_USER_ADDRESS  0UL
 +#define FIRST_USER_ADDRESS  0
  
  #define pte_ERROR(e) \
  	printk("%s:%d: bad pte %p.\n", __FILE__, __LINE__, (void *) pte_val(e))
@@@ -135,8 -119,17 +130,20 @@@ extern unsigned long MODULES_END
  #define MODULES_VADDR	MODULES_VADDR
  #define MODULES_END	MODULES_END
  #define MODULES_LEN	(1UL << 31)
- #endif
  
++<<<<<<< HEAD
++=======
+ static inline int is_module_addr(void *addr)
+ {
+ 	BUILD_BUG_ON(MODULES_LEN > (1UL << 31));
+ 	if (addr < (void *)MODULES_VADDR)
+ 		return 0;
+ 	if (addr > (void *)MODULES_END)
+ 		return 0;
+ 	return 1;
+ }
+ 
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  /*
   * A 31 bit pagetable entry of S390 has following format:
   *  |   PFRA          |    |  OS  |
@@@ -275,55 -267,6 +282,58 @@@
   * pte_swap    is true for the bit pattern .10...xxxx10, (pte & 0x603) == 0x402
   */
  
++<<<<<<< HEAD
 +#ifndef CONFIG_64BIT
 +
 +/* Bits in the segment table address-space-control-element */
 +#define _ASCE_SPACE_SWITCH	0x80000000UL	/* space switch event	    */
 +#define _ASCE_ORIGIN_MASK	0x7ffff000UL	/* segment table origin	    */
 +#define _ASCE_PRIVATE_SPACE	0x100	/* private space control	    */
 +#define _ASCE_ALT_EVENT		0x80	/* storage alteration event control */
 +#define _ASCE_TABLE_LENGTH	0x7f	/* 128 x 64 entries = 8k	    */
 +
 +/* Bits in the segment table entry */
 +#define _SEGMENT_ENTRY_BITS	0x7fffffffUL	/* Valid segment table bits */
 +#define _SEGMENT_ENTRY_ORIGIN	0x7fffffc0UL	/* page table origin	    */
 +#define _SEGMENT_ENTRY_PROTECT	0x200	/* page protection bit		    */
 +#define _SEGMENT_ENTRY_INVALID	0x20	/* invalid segment table entry	    */
 +#define _SEGMENT_ENTRY_COMMON	0x10	/* common segment bit		    */
 +#define _SEGMENT_ENTRY_PTL	0x0f	/* page table length		    */
 +
 +#define _SEGMENT_ENTRY_DIRTY	0	/* No sw dirty bit for 31-bit */
 +#define _SEGMENT_ENTRY_YOUNG	0	/* No sw young bit for 31-bit */
 +#define _SEGMENT_ENTRY_READ	0	/* No sw read bit for 31-bit */
 +#define _SEGMENT_ENTRY_WRITE	0	/* No sw write bit for 31-bit */
 +#define _SEGMENT_ENTRY_LARGE	0	/* No large pages for 31-bit */
 +#define _SEGMENT_ENTRY_BITS_LARGE 0
 +#define _SEGMENT_ENTRY_ORIGIN_LARGE 0
 +
 +#define _SEGMENT_ENTRY		(_SEGMENT_ENTRY_PTL)
 +#define _SEGMENT_ENTRY_EMPTY	(_SEGMENT_ENTRY_INVALID)
 +
 +/*
 + * Segment table entry encoding (I = invalid, R = read-only bit):
 + *		..R...I.....
 + * prot-none	..1...1.....
 + * read-only	..1...0.....
 + * read-write	..0...0.....
 + * empty	..0...1.....
 + */
 +
 +/* Page status table bits for virtualization */
 +#define PGSTE_ACC_BITS	0xf0000000UL
 +#define PGSTE_FP_BIT	0x08000000UL
 +#define PGSTE_PCL_BIT	0x00800000UL
 +#define PGSTE_HR_BIT	0x00400000UL
 +#define PGSTE_HC_BIT	0x00200000UL
 +#define PGSTE_GR_BIT	0x00040000UL
 +#define PGSTE_GC_BIT	0x00020000UL
 +#define PGSTE_IN_BIT	0x00008000UL	/* IPTE notify bit */
 +
 +#else /* CONFIG_64BIT */
 +
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  /* Bits in the segment/region table address-space-control-element */
  #define _ASCE_ORIGIN		~0xfffUL/* segment table origin		    */
  #define _ASCE_PRIVATE_SPACE	0x100	/* private space control	    */
@@@ -416,9 -347,14 +426,17 @@@
  #define PGSTE_HC_BIT	0x0020000000000000UL
  #define PGSTE_GR_BIT	0x0004000000000000UL
  #define PGSTE_GC_BIT	0x0002000000000000UL
 -#define PGSTE_UC_BIT	0x0000800000000000UL	/* user dirty (migration) */
 -#define PGSTE_IN_BIT	0x0000400000000000UL	/* IPTE notify bit */
 +#define PGSTE_IN_BIT	0x0000800000000000UL	/* IPTE notify bit */
  
++<<<<<<< HEAD
 +#endif /* CONFIG_64BIT */
++=======
+ /* Guest Page State used for virtualization */
+ #define _PGSTE_GPS_ZERO		0x0000000080000000UL
+ #define _PGSTE_GPS_USAGE_MASK	0x0000000003000000UL
+ #define _PGSTE_GPS_USAGE_STABLE 0x0000000000000000UL
+ #define _PGSTE_GPS_USAGE_UNUSED 0x0000000001000000UL
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  
  /*
   * A user page table pointer has the space-switch-event bit, the
@@@ -585,18 -439,7 +603,21 @@@ static inline int mm_has_pgste(struct m
  /*
   * pgd/pmd/pte query functions
   */
++<<<<<<< HEAD
 +#ifndef CONFIG_64BIT
 +
 +static inline int pgd_present(pgd_t pgd) { return 1; }
 +static inline int pgd_none(pgd_t pgd)    { return 0; }
 +static inline int pgd_bad(pgd_t pgd)     { return 0; }
 +
 +static inline int pud_present(pud_t pud) { return 1; }
 +static inline int pud_none(pud_t pud)	 { return 0; }
 +static inline int pud_large(pud_t pud)	 { return 0; }
 +
 +#else /* CONFIG_64BIT */
 +
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  static inline int pgd_present(pgd_t pgd)
  {
  	if ((pgd_val(pgd) & _REGION_ENTRY_TYPE_MASK) < _REGION_ENTRY_TYPE_R2)
@@@ -645,18 -488,19 +666,16 @@@ static inline int pud_large(pud_t pud
  	return !!(pud_val(pud) & _REGION3_ENTRY_LARGE);
  }
  
 -static inline int pud_bad(pud_t pud)
 +static inline unsigned long pud_pfn(pud_t pud)
  {
 -	/*
 -	 * With dynamic page table levels the pud can be a region table
 -	 * entry or a segment table entry. Check for the bit that are
 -	 * invalid for either table entry.
 -	 */
 -	unsigned long mask =
 -		~_SEGMENT_ENTRY_ORIGIN & ~_REGION_ENTRY_INVALID &
 -		~_REGION_ENTRY_TYPE_MASK & ~_REGION_ENTRY_LENGTH;
 -	return (pud_val(pud) & mask) != 0;
 +	unsigned long origin_mask;
 +
 +	origin_mask = _REGION3_ENTRY_ORIGIN;
 +	if (pud_large(pud))
 +		origin_mask = _REGION3_ENTRY_ORIGIN_LARGE;
 +	return (pud_val(pud) & origin_mask) >> PAGE_SHIFT;
  }
  
- #endif /* CONFIG_64BIT */
- 
  static inline int pmd_present(pmd_t pmd)
  {
  	return pmd_val(pmd) != _SEGMENT_ENTRY_INVALID;
@@@ -1115,60 -934,24 +1130,74 @@@ static inline pte_t pte_mkhuge(pte_t pt
  }
  #endif
  
 -static inline void __ptep_ipte(unsigned long address, pte_t *ptep)
 +/*
 + * Get (and clear) the user dirty bit for a pte.
 + */
 +static inline int ptep_test_and_clear_user_dirty(struct mm_struct *mm,
 +						 pte_t *ptep)
  {
 -	unsigned long pto = (unsigned long) ptep;
 +	pgste_t pgste;
 +	int dirty = 0;
  
++<<<<<<< HEAD
 +	if (mm_has_pgste(mm)) {
 +		pgste = pgste_get_lock(ptep);
 +		pgste = pgste_update_all(ptep, pgste);
 +		dirty = !!(pgste_val(pgste) & PGSTE_HC_BIT);
 +		pgste_val(pgste) &= ~PGSTE_HC_BIT;
 +		pgste_set_unlock(ptep, pgste);
 +		return dirty;
 +	}
 +	return dirty;
++=======
+ 	/* Invalidation + global TLB flush for the pte */
+ 	asm volatile(
+ 		"	ipte	%2,%3"
+ 		: "=m" (*ptep) : "m" (*ptep), "a" (pto), "a" (address));
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  }
  
 -static inline void __ptep_ipte_local(unsigned long address, pte_t *ptep)
 +/*
 + * Get (and clear) the user referenced bit for a pte.
 + */
 +static inline int ptep_test_and_clear_user_young(struct mm_struct *mm,
 +						 pte_t *ptep)
  {
 -	unsigned long pto = (unsigned long) ptep;
 +	pgste_t pgste;
 +	int young = 0;
  
++<<<<<<< HEAD
 +	if (mm_has_pgste(mm)) {
 +		pgste = pgste_get_lock(ptep);
 +		pgste = pgste_update_young(ptep, pgste);
 +		young = !!(pgste_val(pgste) & PGSTE_HR_BIT);
 +		pgste_val(pgste) &= ~PGSTE_HR_BIT;
 +		pgste_set_unlock(ptep, pgste);
 +	}
 +	return young;
 +}
 +
 +static inline void __ptep_ipte(unsigned long address, pte_t *ptep)
 +{
 +	if (!(pte_val(*ptep) & _PAGE_INVALID)) {
 +#ifndef CONFIG_64BIT
 +		/* pto must point to the start of the segment table */
 +		pte_t *pto = (pte_t *) (((unsigned long) ptep) & 0x7ffffc00);
 +#else
 +		/* ipte in zarch mode can do the math */
 +		pte_t *pto = ptep;
 +#endif
 +		asm volatile(
 +			"	ipte	%2,%3"
 +			: "=m" (*ptep) : "m" (*ptep),
 +			  "a" (pto), "a" (address));
 +	}
++=======
+ 	/* Invalidation + local TLB flush for the pte */
+ 	asm volatile(
+ 		"	.insn rrf,0xb2210000,%2,%3,0,1"
+ 		: "=m" (*ptep) : "m" (*ptep), "a" (pto), "a" (address));
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  }
  
  static inline void __ptep_ipte_range(unsigned long address, int nr, pte_t *ptep)
diff --cc arch/s390/include/asm/processor.h
index e43794870abc,dedb6218544b..000000000000
--- a/arch/s390/include/asm/processor.h
+++ b/arch/s390/include/asm/processor.h
@@@ -11,9 -11,16 +11,20 @@@
  #ifndef __ASM_S390_PROCESSOR_H
  #define __ASM_S390_PROCESSOR_H
  
++<<<<<<< HEAD
++=======
+ #define CIF_MCCK_PENDING	0	/* machine check handling is pending */
+ #define CIF_ASCE		1	/* user asce needs fixup / uaccess */
+ #define CIF_NOHZ_DELAY		2	/* delay HZ disable for a tick */
+ 
+ #define _CIF_MCCK_PENDING	(1<<CIF_MCCK_PENDING)
+ #define _CIF_ASCE		(1<<CIF_ASCE)
+ #define _CIF_NOHZ_DELAY		(1<<CIF_NOHZ_DELAY)
+ 
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  #ifndef __ASSEMBLY__
  
 +#include <linux/rh_kabi.h>
  #include <linux/linkage.h>
  #include <linux/irqflags.h>
  #include <asm/cpu.h>
@@@ -45,31 -65,15 +56,27 @@@ extern int s390_isolate_bp_guest(void)
  /*
   * User space process size: 2GB for 31 bit, 4TB or 8PT for 64 bit.
   */
- #ifndef CONFIG_64BIT
- 
- #define TASK_SIZE		(1UL << 31)
- #define TASK_MAX_SIZE		(1UL << 31)
- #define TASK_UNMAPPED_BASE	(1UL << 30)
- 
- #else /* CONFIG_64BIT */
  
 -#define TASK_SIZE_OF(tsk)	((tsk)->mm->context.asce_limit)
 +#define TASK_SIZE_OF(tsk)	(test_tsk_thread_flag(tsk, TIF_31BIT) ? \
 +					(1UL << 31) : (1UL << 53))
  #define TASK_UNMAPPED_BASE	(test_thread_flag(TIF_31BIT) ? \
  					(1UL << 30) : (1UL << 41))
  #define TASK_SIZE		TASK_SIZE_OF(current)
 -#define TASK_MAX_SIZE		(1UL << 53)
 -
 +#define TASK_SIZE_MAX		(1UL << 53)
 +
++<<<<<<< HEAD
 +#endif /* CONFIG_64BIT */
 +
 +#ifndef CONFIG_64BIT
 +#define STACK_TOP		(1UL << 31)
 +#define STACK_TOP_MAX		(1UL << 31)
 +#else /* CONFIG_64BIT */
 +#define STACK_TOP		(test_thread_flag(TIF_31BIT) ? \
 +					(1UL << 31) : (1UL << 42))
++=======
+ #define STACK_TOP		(1UL << (test_thread_flag(TIF_31BIT) ? 31:42))
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  #define STACK_TOP_MAX		(1UL << 42)
- #endif /* CONFIG_64BIT */
  
  #define HAVE_ARCH_PICK_MMAP_LAYOUT
  
@@@ -95,12 -100,8 +102,15 @@@ struct thread_struct 
  	/* cpu runtime instrumentation */
  	struct runtime_instr_cb *ri_cb;
  	int ri_signum;
- #ifdef CONFIG_64BIT
  	unsigned char trap_tdb[256];	/* Transaction abort diagnose block */
++<<<<<<< HEAD
 +	RH_KABI_EXTEND(__vector128 *vxrs) /* Vector register save area */
 +	RH_KABI_EXTEND(struct gs_cb *gs_cb) /* Current guarded storage cb */
 +	RH_KABI_EXTEND(struct gs_cb *gs_bc_cb) /* Broadcast guarded storage cb */
 +#endif
++=======
+ 	__vector128 *vxrs;		/* Vector register save area */
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  };
  
  /* Flag to disable transactions. */
@@@ -268,9 -241,13 +253,8 @@@ static inline unsigned long __rewind_ps
  	       (psw.mask & PSW_MASK_BA) ? (1UL << 31) - 1 :
  					  (1UL << 24) - 1;
  	return (psw.addr - ilc) & mask;
- #endif
  }
 -
 -/*
 - * Function to stop a processor until the next interrupt occurs
 - */
 -void enabled_wait(void);
 -
 + 
  /*
   * Function to drop a processor into disabled wait state
   */
diff --cc arch/s390/include/asm/rwsem.h
index 7b5acf4cd34b,4b43ee7e6776..000000000000
--- a/arch/s390/include/asm/rwsem.h
+++ b/arch/s390/include/asm/rwsem.h
@@@ -262,4 -197,41 +197,44 @@@ static inline void __downgrade_write(st
  		rwsem_downgrade_wake(sem);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * implement atomic add functionality
+  */
+ static inline void rwsem_atomic_add(long delta, struct rw_semaphore *sem)
+ {
+ 	signed long old, new;
+ 
+ 	asm volatile(
+ 		"	lg	%0,%2\n"
+ 		"0:	lgr	%1,%0\n"
+ 		"	agr	%1,%4\n"
+ 		"	csg	%0,%1,%2\n"
+ 		"	jl	0b"
+ 		: "=&d" (old), "=&d" (new), "=Q" (sem->count)
+ 		: "Q" (sem->count), "d" (delta)
+ 		: "cc", "memory");
+ }
+ 
+ /*
+  * implement exchange and add functionality
+  */
+ static inline long rwsem_atomic_update(long delta, struct rw_semaphore *sem)
+ {
+ 	signed long old, new;
+ 
+ 	asm volatile(
+ 		"	lg	%0,%2\n"
+ 		"0:	lgr	%1,%0\n"
+ 		"	agr	%1,%4\n"
+ 		"	csg	%0,%1,%2\n"
+ 		"	jl	0b"
+ 		: "=&d" (old), "=&d" (new), "=Q" (sem->count)
+ 		: "Q" (sem->count), "d" (delta)
+ 		: "cc", "memory");
+ 	return new;
+ }
+ 
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  #endif /* _S390_RWSEM_H */
diff --cc arch/s390/include/asm/setup.h
index 548eb9d112c4,b8ffc1bd0a9f..000000000000
--- a/arch/s390/include/asm/setup.h
+++ b/arch/s390/include/asm/setup.h
@@@ -31,25 -20,13 +24,24 @@@
  #define INITRD_SIZE       (*(unsigned long *)  (0x10410))
  #define OLDMEM_BASE	  (*(unsigned long *)  (0x10418))
  #define OLDMEM_SIZE	  (*(unsigned long *)  (0x10420))
- #endif /* CONFIG_64BIT */
  #define COMMAND_LINE      ((char *)            (0x10480))
  
 +#define CHUNK_READ_WRITE 0
 +#define CHUNK_READ_ONLY  1
 +
 +struct mem_chunk {
 +	unsigned long addr;
 +	unsigned long size;
 +	int type;
 +};
 +
 +extern struct mem_chunk memory_chunk[];
  extern int memory_end_set;
  extern unsigned long memory_end;
 -extern unsigned long max_physmem_end;
  
 -extern void detect_memory_memblock(void);
 +void detect_memory_layout(struct mem_chunk chunk[], unsigned long maxsize);
 +void create_mem_hole(struct mem_chunk mem_chunk[], unsigned long addr,
 +		     unsigned long size);
  
  /*
   * Machine features detected in head.S
@@@ -84,37 -60,16 +76,43 @@@
  #define MACHINE_HAS_PFMF	MACHINE_HAS_EDAT1
  #define MACHINE_HAS_HPAGE	MACHINE_HAS_EDAT1
  
++<<<<<<< HEAD
 +#ifndef CONFIG_64BIT
 +#define MACHINE_HAS_IEEE	(S390_lowcore.machine_flags & MACHINE_FLAG_IEEE)
 +#define MACHINE_HAS_CSP		(S390_lowcore.machine_flags & MACHINE_FLAG_CSP)
 +#define MACHINE_HAS_IDTE	(0)
 +#define MACHINE_HAS_DIAG44	(1)
 +#define MACHINE_HAS_MVPG	(S390_lowcore.machine_flags & MACHINE_FLAG_MVPG)
 +#define MACHINE_HAS_EDAT1	(0)
 +#define MACHINE_HAS_EDAT2	(0)
 +#define MACHINE_HAS_LPP		(0)
 +#define MACHINE_HAS_TOPOLOGY	(0)
 +#define MACHINE_HAS_TE		(0)
 +#define MACHINE_HAS_RRBM	(0)
 +#define MACHINE_HAS_VX		(0)
 +#define MACHINE_HAS_GS		(0)
 +#define MACHINE_HAS_NX		(0)
 +#else /* CONFIG_64BIT */
 +#define MACHINE_HAS_IEEE	(1)
 +#define MACHINE_HAS_CSP		(1)
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  #define MACHINE_HAS_IDTE	(S390_lowcore.machine_flags & MACHINE_FLAG_IDTE)
  #define MACHINE_HAS_DIAG44	(S390_lowcore.machine_flags & MACHINE_FLAG_DIAG44)
- #define MACHINE_HAS_MVPG	(1)
  #define MACHINE_HAS_EDAT1	(S390_lowcore.machine_flags & MACHINE_FLAG_EDAT1)
  #define MACHINE_HAS_EDAT2	(S390_lowcore.machine_flags & MACHINE_FLAG_EDAT2)
  #define MACHINE_HAS_LPP		(S390_lowcore.machine_flags & MACHINE_FLAG_LPP)
  #define MACHINE_HAS_TOPOLOGY	(S390_lowcore.machine_flags & MACHINE_FLAG_TOPOLOGY)
  #define MACHINE_HAS_TE		(S390_lowcore.machine_flags & MACHINE_FLAG_TE)
 -#define MACHINE_HAS_TLB_LC	(S390_lowcore.machine_flags & MACHINE_FLAG_TLB_LC)
 +#define MACHINE_HAS_RRBM	(S390_lowcore.machine_flags & MACHINE_FLAG_RRBM)
  #define MACHINE_HAS_VX		(S390_lowcore.machine_flags & MACHINE_FLAG_VX)
++<<<<<<< HEAD
 +#define MACHINE_HAS_GS		(S390_lowcore.machine_flags & MACHINE_FLAG_GS)
 +#define MACHINE_HAS_NX		(S390_lowcore.machine_flags & MACHINE_FLAG_NX)
 +#endif /* CONFIG_64BIT */
++=======
+ #define MACHINE_HAS_CAD		(S390_lowcore.machine_flags & MACHINE_FLAG_CAD)
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  
  /*
   * Console mode. Override with conmode=
diff --cc arch/s390/include/asm/tlb.h
index 6d6d92b4ea11,7a92e69c50bc..000000000000
--- a/arch/s390/include/asm/tlb.h
+++ b/arch/s390/include/asm/tlb.h
@@@ -110,13 -118,10 +110,17 @@@ static inline void pte_free_tlb(struct 
  static inline void pmd_free_tlb(struct mmu_gather *tlb, pmd_t *pmd,
  				unsigned long address)
  {
- #ifdef CONFIG_64BIT
  	if (tlb->mm->context.asce_limit <= (1UL << 31))
  		return;
++<<<<<<< HEAD
 +	if (!tlb->fullmm)
 +		return tlb_remove_table(tlb, pmd);
 +	crst_table_free(tlb->mm, (unsigned long *) pmd);
 +#endif
++=======
+ 	pgtable_pmd_page_dtor(virt_to_page(pmd));
+ 	tlb_remove_table(tlb, pmd);
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  }
  
  /*
@@@ -129,13 -134,9 +133,16 @@@
  static inline void pud_free_tlb(struct mmu_gather *tlb, pud_t *pud,
  				unsigned long address)
  {
- #ifdef CONFIG_64BIT
  	if (tlb->mm->context.asce_limit <= (1UL << 42))
  		return;
++<<<<<<< HEAD
 +	if (!tlb->fullmm)
 +		return tlb_remove_table(tlb, pud);
 +	crst_table_free(tlb->mm, (unsigned long *) pud);
 +#endif
++=======
+ 	tlb_remove_table(tlb, pud);
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  }
  
  #define tlb_start_vma(tlb, vma)			do { } while (0)
diff --cc arch/s390/include/asm/tlbflush.h
index d41a81016f6d,ca148f7c3eaa..000000000000
--- a/arch/s390/include/asm/tlbflush.h
+++ b/arch/s390/include/asm/tlbflush.h
@@@ -53,11 -19,127 +53,129 @@@ static inline void __tlb_flush_full(str
   */
  static inline void __tlb_flush_idte(unsigned long asce)
  {
 -	/* Global TLB flush for the mm */
  	asm volatile(
  		"	.insn	rrf,0xb98e0000,0,%0,%1,0"
 -		: : "a" (2048), "a" (asce) : "cc");
 +		: : "a" (2048), "a" (asce) : "cc" );
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Flush TLB entries for a specific ASCE on the local CPU
+  */
+ static inline void __tlb_flush_idte_local(unsigned long asce)
+ {
+ 	/* Local TLB flush for the mm */
+ 	asm volatile(
+ 		"	.insn	rrf,0xb98e0000,0,%0,%1,1"
+ 		: : "a" (2048), "a" (asce) : "cc");
+ }
+ 
+ #ifdef CONFIG_SMP
+ void smp_ptlb_all(void);
+ 
+ /*
+  * Flush all TLB entries on all CPUs.
+  */
+ static inline void __tlb_flush_global(void)
+ {
+ 	register unsigned long reg2 asm("2");
+ 	register unsigned long reg3 asm("3");
+ 	register unsigned long reg4 asm("4");
+ 	long dummy;
+ 
+ 	dummy = 0;
+ 	reg2 = reg3 = 0;
+ 	reg4 = ((unsigned long) &dummy) + 1;
+ 	asm volatile(
+ 		"	csp	%0,%2"
+ 		: : "d" (reg2), "d" (reg3), "d" (reg4), "m" (dummy) : "cc" );
+ }
+ 
+ /*
+  * Flush TLB entries for a specific mm on all CPUs (in case gmap is used
+  * this implicates multiple ASCEs!).
+  */
+ static inline void __tlb_flush_full(struct mm_struct *mm)
+ {
+ 	preempt_disable();
+ 	atomic_add(0x10000, &mm->context.attach_count);
+ 	if (cpumask_equal(mm_cpumask(mm), cpumask_of(smp_processor_id()))) {
+ 		/* Local TLB flush */
+ 		__tlb_flush_local();
+ 	} else {
+ 		/* Global TLB flush */
+ 		__tlb_flush_global();
+ 		/* Reset TLB flush mask */
+ 		if (MACHINE_HAS_TLB_LC)
+ 			cpumask_copy(mm_cpumask(mm),
+ 				     &mm->context.cpu_attach_mask);
+ 	}
+ 	atomic_sub(0x10000, &mm->context.attach_count);
+ 	preempt_enable();
+ }
+ 
+ /*
+  * Flush TLB entries for a specific ASCE on all CPUs.
+  */
+ static inline void __tlb_flush_asce(struct mm_struct *mm, unsigned long asce)
+ {
+ 	int active, count;
+ 
+ 	preempt_disable();
+ 	active = (mm == current->active_mm) ? 1 : 0;
+ 	count = atomic_add_return(0x10000, &mm->context.attach_count);
+ 	if (MACHINE_HAS_TLB_LC && (count & 0xffff) <= active &&
+ 	    cpumask_equal(mm_cpumask(mm), cpumask_of(smp_processor_id()))) {
+ 		__tlb_flush_idte_local(asce);
+ 	} else {
+ 		if (MACHINE_HAS_IDTE)
+ 			__tlb_flush_idte(asce);
+ 		else
+ 			__tlb_flush_global();
+ 		/* Reset TLB flush mask */
+ 		if (MACHINE_HAS_TLB_LC)
+ 			cpumask_copy(mm_cpumask(mm),
+ 				     &mm->context.cpu_attach_mask);
+ 	}
+ 	atomic_sub(0x10000, &mm->context.attach_count);
+ 	preempt_enable();
+ }
+ 
+ static inline void __tlb_flush_kernel(void)
+ {
+ 	if (MACHINE_HAS_IDTE)
+ 		__tlb_flush_idte((unsigned long) init_mm.pgd |
+ 				 init_mm.context.asce_bits);
+ 	else
+ 		__tlb_flush_global();
+ }
+ #else
+ #define __tlb_flush_global()	__tlb_flush_local()
+ #define __tlb_flush_full(mm)	__tlb_flush_local()
+ 
+ /*
+  * Flush TLB entries for a specific ASCE on all CPUs.
+  */
+ static inline void __tlb_flush_asce(struct mm_struct *mm, unsigned long asce)
+ {
+ 	if (MACHINE_HAS_TLB_LC)
+ 		__tlb_flush_idte_local(asce);
+ 	else
+ 		__tlb_flush_local();
+ }
+ 
+ static inline void __tlb_flush_kernel(void)
+ {
+ 	if (MACHINE_HAS_TLB_LC)
+ 		__tlb_flush_idte_local((unsigned long) init_mm.pgd |
+ 				       init_mm.context.asce_bits);
+ 	else
+ 		__tlb_flush_local();
+ }
+ #endif
+ 
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  static inline void __tlb_flush_mm(struct mm_struct * mm)
  {
  	/*
diff --cc arch/s390/include/asm/unistd.h
index 283aea4cf7b9,91f56b1d8156..000000000000
--- a/arch/s390/include/asm/unistd.h
+++ b/arch/s390/include/asm/unistd.h
@@@ -9,14 -9,7 +9,14 @@@
  #include <uapi/asm/unistd.h>
  
  
- #ifndef CONFIG_64BIT
- #define __IGNORE_select
- #else
  #define __IGNORE_time
++<<<<<<< HEAD
 +#endif
 +#define __IGNORE_pkey_mprotect
 +#define __IGNORE_pkey_alloc
 +#define __IGNORE_pkey_free
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  
  /* Ignore NUMA system calls. Not wired up on s390. */
  #define __IGNORE_mbind
diff --cc arch/s390/kernel/Makefile
index e35f714df28b,d94cbba95c50..000000000000
--- a/arch/s390/kernel/Makefile
+++ b/arch/s390/kernel/Makefile
@@@ -26,25 -26,17 +26,25 @@@ CFLAGS_dumpstack.o	+= -fno-optimize-sib
  #
  CFLAGS_ptrace.o		+= -DUTS_MACHINE='"$(UTS_MACHINE)"'
  
- CFLAGS_sysinfo.o += -Iinclude/math-emu -Iarch/s390/math-emu -w
+ CFLAGS_sysinfo.o += -w
  
 -obj-y	:= traps.o time.o process.o base.o early.o setup.o idle.o vtime.o
 +obj-y	:= bitmap.o traps.o time.o process.o base.o early.o setup.o vtime.o
  obj-y	+= processor.o sys_s390.o ptrace.o signal.o cpcmd.o ebcdic.o nmi.o
  obj-y	+= debug.o irq.o ipl.o dis.o diag.o sclp.o vdso.o
  obj-y	+= sysinfo.o jump_label.o lgr.o os_info.o machine_kexec.o pgm_check.o
++<<<<<<< HEAD
 +obj-y	+= dumpstack.o guarded_storage.o alternative.o sthyi.o
 +obj-y	+= nospec-branch.o
++=======
+ obj-y	+= runtime_instr.o cache.o dumpstack.o
+ obj-y	+= entry64.o reipl64.o relocate_kernel64.o
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  
- obj-y	+= $(if $(CONFIG_64BIT),entry64.o,entry.o)
- obj-y	+= $(if $(CONFIG_64BIT),reipl64.o,reipl.o)
- obj-y	+= $(if $(CONFIG_64BIT),relocate_kernel64.o,relocate_kernel.o)
- 
- extra-y				+= head.o vmlinux.lds
- extra-y				+= $(if $(CONFIG_64BIT),head64.o,head31.o)
+ extra-y				+= head.o head64.o vmlinux.lds
  
 +obj-$(CONFIG_SYSFS)		+= nospec-sysfs.o
 +CFLAGS_REMOVE_nospec-branch.o	+= $(CC_FLAGS_EXPOLINE)
 +
  obj-$(CONFIG_MODULES)		+= s390_ksyms.o module.o
  obj-$(CONFIG_SMP)		+= smp.o
  obj-$(CONFIG_SCHED_BOOK)	+= topology.o
diff --cc arch/s390/kernel/asm-offsets.c
index 8e7394965c28,6e94edd90318..000000000000
--- a/arch/s390/kernel/asm-offsets.c
+++ b/arch/s390/kernel/asm-offsets.c
@@@ -157,9 -166,8 +157,14 @@@ int main(void
  	DEFINE(__LC_FPREGS_SAVE_AREA, offsetof(struct _lowcore, floating_pt_save_area));
  	DEFINE(__LC_GPREGS_SAVE_AREA, offsetof(struct _lowcore, gpregs_save_area));
  	DEFINE(__LC_CREGS_SAVE_AREA, offsetof(struct _lowcore, cregs_save_area));
++<<<<<<< HEAD
 +#ifdef CONFIG_32BIT
 +	DEFINE(SAVE_AREA_BASE, offsetof(struct _lowcore, extended_save_area_addr));
 +#else /* CONFIG_32BIT */
++=======
+ 	DEFINE(__LC_DATA_EXC_CODE, offsetof(struct _lowcore, data_exc_code));
+ 	DEFINE(__LC_MCCK_FAIL_STOR_ADDR, offsetof(struct _lowcore, failing_storage_address));
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	DEFINE(__LC_EXT_PARAMS2, offsetof(struct _lowcore, ext_params2));
  	DEFINE(SAVE_AREA_BASE, offsetof(struct _lowcore, floating_pt_save_area));
  	DEFINE(__LC_PASTE, offsetof(struct _lowcore, paste));
diff --cc arch/s390/kernel/base.S
index a70c85e8b383,daed3fde42ec..000000000000
--- a/arch/s390/kernel/base.S
+++ b/arch/s390/kernel/base.S
@@@ -12,11 -11,6 +12,14 @@@
  #include <asm/ptrace.h>
  #include <asm/sigp.h>
  
++<<<<<<< HEAD
 +#ifdef CONFIG_64BIT
 +
 +	GEN_BR_THUNK %r9
 +	GEN_BR_THUNK %r14
 +
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  ENTRY(s390_base_mcck_handler)
  	basr	%r13,0
  0:	lg	%r15,__LC_PANIC_STACK	# load panic stack
diff --cc arch/s390/kernel/cpcmd.c
index 825079d65898,199ec92ef4fe..000000000000
--- a/arch/s390/kernel/cpcmd.c
+++ b/arch/s390/kernel/cpcmd.c
@@@ -28,11 -27,9 +28,17 @@@ static int diag8_noresponse(int cmdlen
  	register unsigned long reg3 asm ("3") = cmdlen;
  
  	asm volatile(
++<<<<<<< HEAD
 +#ifndef CONFIG_64BIT
 +		"	diag	%1,%0,0x8\n"
 +#else /* CONFIG_64BIT */
 +		"	diag	%1,%0,0x8\n"
 +#endif /* CONFIG_64BIT */
++=======
+ 		"	sam31\n"
+ 		"	diag	%1,%0,0x8\n"
+ 		"	sam64\n"
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  		: "+d" (reg3) : "d" (reg2) : "cc");
  	return reg3;
  }
@@@ -45,15 -42,11 +51,18 @@@ static int diag8_response(int cmdlen, c
  	register unsigned long reg5 asm ("5") = *rlen;
  
  	asm volatile(
++<<<<<<< HEAD
 +#ifndef CONFIG_64BIT
 +		"	diag	%2,%0,0x8\n"
 +		"	brc	8,1f\n"
 +		"	ar	%1,%4\n"
 +#else /* CONFIG_64BIT */
++=======
+ 		"	sam31\n"
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  		"	diag	%2,%0,0x8\n"
 -		"	sam64\n"
  		"	brc	8,1f\n"
  		"	agr	%1,%4\n"
- #endif /* CONFIG_64BIT */
  		"1:\n"
  		: "+d" (reg4), "+d" (reg5)
  		: "d" (reg2), "d" (reg3), "d" (*rlen) : "cc");
diff --cc arch/s390/kernel/dis.c
index d06831666261,8140d10c6785..000000000000
--- a/arch/s390/kernel/dis.c
+++ b/arch/s390/kernel/dis.c
@@@ -1589,8 -1549,6 +1550,11 @@@ static struct s390_insn opcode_e7[] = 
  	{ "vfsq", 0xce, INSTR_VRR_VV000MM },
  	{ "vfs", 0xe2, INSTR_VRR_VVV00MM },
  	{ "vftci", 0x4a, INSTR_VRI_VVIMM },
++<<<<<<< HEAD
 +#endif
 +	{ "", 0, INSTR_INVALID }
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  };
  
  static struct s390_insn opcode_eb[] = {
diff --cc arch/s390/kernel/dumpstack.c
index c4b9aeaef122,dc8e20473484..000000000000
--- a/arch/s390/kernel/dumpstack.c
+++ b/arch/s390/kernel/dumpstack.c
@@@ -128,11 -118,8 +118,14 @@@ void show_stack(struct task_struct *tas
  
  static void show_last_breaking_event(struct pt_regs *regs)
  {
- #ifdef CONFIG_64BIT
  	printk("Last Breaking-Event-Address:\n");
++<<<<<<< HEAD
 +	printk(" [<%016lx>] ", regs->args[0] & PSW_ADDR_INSN);
 +	print_symbol("%s\n", regs->args[0] & PSW_ADDR_INSN);
 +#endif
++=======
+ 	printk(" [<%016lx>] %pSR\n", regs->args[0], (void *)regs->args[0]);
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  }
  
  static inline int mask_bits(struct pt_regs *regs, unsigned long bits)
diff --cc arch/s390/kernel/early.c
index 176ec30b4896,549a73a4b543..000000000000
--- a/arch/s390/kernel/early.c
+++ b/arch/s390/kernel/early.c
@@@ -283,65 -278,8 +273,13 @@@ static noinline __init void setup_facil
  {
  	stfle(S390_lowcore.stfle_fac_list,
  	      ARRAY_SIZE(S390_lowcore.stfle_fac_list));
 +	memcpy(S390_lowcore.alt_stfle_fac_list,
 +	       S390_lowcore.stfle_fac_list,
 +	       sizeof(S390_lowcore.alt_stfle_fac_list));
 +	if (!IS_ENABLED(CONFIG_KERNEL_NOBP))
 +		__clear_facility(82, S390_lowcore.alt_stfle_fac_list);
  }
  
- static __init void detect_mvpg(void)
- {
- #ifndef CONFIG_64BIT
- 	int rc;
- 
- 	asm volatile(
- 		"	la	0,0\n"
- 		"	mvpg	%2,%2\n"
- 		"0:	la	%0,0\n"
- 		"1:\n"
- 		EX_TABLE(0b,1b)
- 		: "=d" (rc) : "0" (-EOPNOTSUPP), "a" (0) : "memory", "cc", "0");
- 	if (!rc)
- 		S390_lowcore.machine_flags |= MACHINE_FLAG_MVPG;
- #endif
- }
- 
- static __init void detect_ieee(void)
- {
- #ifndef CONFIG_64BIT
- 	int rc, tmp;
- 
- 	asm volatile(
- 		"	efpc	%1,0\n"
- 		"0:	la	%0,0\n"
- 		"1:\n"
- 		EX_TABLE(0b,1b)
- 		: "=d" (rc), "=d" (tmp): "0" (-EOPNOTSUPP) : "cc");
- 	if (!rc)
- 		S390_lowcore.machine_flags |= MACHINE_FLAG_IEEE;
- #endif
- }
- 
- static __init void detect_csp(void)
- {
- #ifndef CONFIG_64BIT
- 	int rc;
- 
- 	asm volatile(
- 		"	la	0,0\n"
- 		"	la	1,0\n"
- 		"	la	2,4\n"
- 		"	csp	0,2\n"
- 		"0:	la	%0,0\n"
- 		"1:\n"
- 		EX_TABLE(0b,1b)
- 		: "=d" (rc) : "0" (-EOPNOTSUPP) : "cc", "0", "1", "2");
- 	if (!rc)
- 		S390_lowcore.machine_flags |= MACHINE_FLAG_CSP;
- #endif
- }
- 
  static __init void detect_diag9c(void)
  {
  	unsigned int cpu_address;
@@@ -387,39 -322,33 +322,42 @@@ static __init void detect_machine_facil
  		S390_lowcore.machine_flags |= MACHINE_FLAG_IDTE;
  	if (test_facility(40))
  		S390_lowcore.machine_flags |= MACHINE_FLAG_LPP;
 -	if (test_facility(50) && test_facility(73))
 +	if (test_facility(50) && test_facility(73)) {
  		S390_lowcore.machine_flags |= MACHINE_FLAG_TE;
 -	if (test_facility(51))
 -		S390_lowcore.machine_flags |= MACHINE_FLAG_TLB_LC;
 +		__ctl_set_bit(0, 55);
 +	}
 +	if (test_facility(66))
 +		S390_lowcore.machine_flags |= MACHINE_FLAG_RRBM;
  	if (test_facility(129))
  		S390_lowcore.machine_flags |= MACHINE_FLAG_VX;
++<<<<<<< HEAD
 +	if (test_facility(130)) {
 +		S390_lowcore.machine_flags |= MACHINE_FLAG_NX;
 +		__ctl_set_bit(0, 20);
 +	}
 +	if (test_facility(133))
 +		S390_lowcore.machine_flags |= MACHINE_FLAG_GS;
 +#endif
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  }
  
 -static int __init cad_setup(char *str)
 +#ifdef CONFIG_64BIT
 +static int __init noexec_setup(char *str)
  {
 -	int val;
 -
 -	get_option(&str, &val);
 -	if (val && test_facility(128))
 -		S390_lowcore.machine_flags |= MACHINE_FLAG_CAD;
 -	return 0;
 -}
 -early_param("cad", cad_setup);
 +	bool enabled;
 +	int rc;
  
 -static int __init cad_init(void)
 -{
 -	if (MACHINE_HAS_CAD)
 -		/* Enable problem state CAD. */
 -		__ctl_set_bit(2, 3);
 -	return 0;
 +	rc = kstrtobool(str, &enabled);
 +	if (!rc && !enabled) {
 +		/* Disable no-execute support */
 +		S390_lowcore.machine_flags &= ~MACHINE_FLAG_NX;
 +		__ctl_clear_bit(0, 20);
 +	}
 +	return rc;
  }
 -early_initcall(cad_init);
 +early_param("noexec", noexec_setup);
 +#endif
  
  static __init void rescue_initrd(void)
  {
diff --cc arch/s390/kernel/module.c
index 9cf7bdf5d962,0c1a679314dd..000000000000
--- a/arch/s390/kernel/module.c
+++ b/arch/s390/kernel/module.c
@@@ -53,19 -45,14 +48,18 @@@ void *module_alloc(unsigned long size
  	if (PAGE_ALIGN(size) > MODULES_LEN)
  		return NULL;
  	return __vmalloc_node_range(size, 1, MODULES_VADDR, MODULES_END,
 -				    GFP_KERNEL, PAGE_KERNEL, 0, NUMA_NO_NODE,
 +				    GFP_KERNEL, PAGE_KERNEL_EXEC, NUMA_NO_NODE,
  				    __builtin_return_address(0));
  }
- #endif
  
 -void module_arch_freeing_init(struct module *mod)
 +/* Free memory returned from module_alloc */
 +void module_free(struct module *mod, void *module_region)
  {
 -	vfree(mod->arch.syminfo);
 -	mod->arch.syminfo = NULL;
 +	if (mod) {
 +		vfree(mod->arch.syminfo);
 +		mod->arch.syminfo = NULL;
 +	}
 +	vfree(module_region);
  }
  
  static void check_rela(Elf_Rela *rela, struct module *me)
@@@ -334,28 -317,11 +328,33 @@@ static int apply_rela(Elf_Rela *rela, E
  			unsigned int *ip;
  			ip = me->module_core + me->arch.plt_offset +
  				info->plt_offset;
++<<<<<<< HEAD
 +#ifndef CONFIG_64BIT
 +			ip[0] = 0x0d105810; /* basr 1,0; l 1,6(1); br 1 */
 +			ip[1] = 0x100607f1;
 +			ip[2] = val;
 +#else /* CONFIG_64BIT */
 +			ip[0] = 0x0d10e310;	/* basr 1,0  */
 +			ip[1] = 0x100a0004;	/* lg	1,10(1) */
 +			if (IS_ENABLED(CONFIG_EXPOLINE) && !nospec_disable) {
 +				unsigned int *ij;
 +				ij = me->module_core +
 +					me->arch.plt_offset +
 +					me->arch.plt_size - PLT_ENTRY_SIZE;
 +				ip[2] = 0xa7f40000 +	/* j __jump_r1 */
 +					(unsigned int)(u16)
 +					(((unsigned long) ij - 8 -
 +					  (unsigned long) ip) / 2);
 +			} else {
 +				ip[2] = 0x07f10000;	/* br %r1 */
 +			}
++=======
+ 			ip[0] = 0x0d10e310; /* basr 1,0; lg 1,10(1); br 1 */
+ 			ip[1] = 0x100a0004;
+ 			ip[2] = 0x07f10000;
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  			ip[3] = (unsigned int) (val >> 32);
  			ip[4] = (unsigned int) val;
- #endif /* CONFIG_64BIT */
  			info->plt_initialized = 1;
  		}
  		if (r_type == R_390_PLTOFF16 ||
diff --cc arch/s390/kernel/ptrace.c
index 8ac3240d6fb5,d363c9c322a1..000000000000
--- a/arch/s390/kernel/ptrace.c
+++ b/arch/s390/kernel/ptrace.c
@@@ -43,52 -43,42 +43,62 @@@ void update_cr_regs(struct task_struct 
  	struct pt_regs *regs = task_pt_regs(task);
  	struct thread_struct *thread = &task->thread;
  	struct per_regs old, new;
++<<<<<<< HEAD
 +#ifdef CONFIG_64BIT
 +	unsigned long cr0_old, cr0_new;
 +	unsigned long cr2_old, cr2_new;
 +	int cr0_changed, cr2_changed;
++=======
+ 
+ 	/* Take care of the enable/disable of transactional execution. */
+ 	if (MACHINE_HAS_TE || MACHINE_HAS_VX) {
+ 		unsigned long cr, cr_new;
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  
 -		__ctl_store(cr, 0, 0);
 -		cr_new = cr;
 -		if (MACHINE_HAS_TE) {
 -			/* Set or clear transaction execution TXC bit 8. */
 -			cr_new |= (1UL << 55);
 -			if (task->thread.per_flags & PER_FLAG_NO_TE)
 -				cr_new &= ~(1UL << 55);
 -		}
 -		if (MACHINE_HAS_VX) {
 -			/* Enable/disable of vector extension */
 -			cr_new &= ~(1UL << 17);
 -			if (task->thread.vxrs)
 -				cr_new |= (1UL << 17);
 -		}
 -		if (cr_new != cr)
 -			__ctl_load(cr_new, 0, 0);
 -		if (MACHINE_HAS_TE) {
 -			/* Set/clear transaction execution TDC bits 62/63. */
 -			__ctl_store(cr, 2, 2);
 -			cr_new = cr & ~3UL;
 -			if (task->thread.per_flags & PER_FLAG_TE_ABORT_RAND) {
 -				if (task->thread.per_flags &
 -				    PER_FLAG_TE_ABORT_RAND_TEND)
 -					cr_new |= 1UL;
 -				else
 -					cr_new |= 2UL;
 -			}
 -			if (cr_new != cr)
 -				__ctl_load(cr_new, 2, 2);
 +	__ctl_store(cr0_old, 0, 0);
 +	__ctl_store(cr2_old, 2, 2);
 +	cr0_new = cr0_old;
 +	cr2_new = cr2_old;
 +
 +	/* Take care of the enable/disable of transactional execution. */
 +	if (MACHINE_HAS_TE) {
 +		/* Set or clear transaction execution TXC bit 8. */
 +		cr0_new |= (1UL << 55);
 +		if (task->thread.per_flags & PER_FLAG_NO_TE)
 +			cr0_new &= ~(1UL << 55);
 +		/* Set/clear transaction execution TDC bits 62/63. */
 +		cr2_new &= ~3UL;
 +		if (task->thread.per_flags & PER_FLAG_TE_ABORT_RAND) {
 +			if (task->thread.per_flags &
 +			    PER_FLAG_TE_ABORT_RAND_TEND)
 +				cr2_new |= 1UL;
 +			else
 +				cr2_new |= 2UL;
  		}
  	}
++<<<<<<< HEAD
 +	if (MACHINE_HAS_VX) {
 +		/* Enable/disable of vector extension */
 +		cr0_new &= ~(1UL << 17);
 +		if (task->thread.vxrs)
 +			cr0_new |= (1UL << 17);
 +	}
 +	/* Take care of enable/disable of guarded storage. */
 +	if (MACHINE_HAS_GS) {
 +		cr2_new &= ~(1UL << 4);
 +		if (task->thread.gs_cb)
 +			cr2_new |= (1UL << 4);
 +	}
 +	/* Load control register 0/2 iff changed */
 +	cr0_changed = cr0_new != cr0_old;
 +	cr2_changed = cr2_new != cr2_old;
 +	if (cr0_changed)
 +		__ctl_load(cr0_new, 0, 0);
 +	if (cr2_changed)
 +		__ctl_load(cr2_new, 2, 2);
 +#endif
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	/* Copy user specified PER registers */
  	new.control = thread->per_user.control;
  	new.start = thread->per_user.start;
@@@ -97,11 -87,12 +107,17 @@@
  	/* merge TIF_SINGLE_STEP into user specified PER registers. */
  	if (test_tsk_thread_flag(task, TIF_SINGLE_STEP) ||
  	    test_tsk_thread_flag(task, TIF_UPROBE_SINGLESTEP)) {
++<<<<<<< HEAD
 +		new.control |= PER_EVENT_IFETCH;
 +#ifdef CONFIG_64BIT
++=======
+ 		if (test_tsk_thread_flag(task, TIF_BLOCK_STEP))
+ 			new.control |= PER_EVENT_BRANCH;
+ 		else
+ 			new.control |= PER_EVENT_IFETCH;
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  		new.control |= PER_CONTROL_SUSPENSION;
  		new.control |= PER_EVENT_TRANSACTION_END;
- #endif
  		if (test_tsk_thread_flag(task, TIF_UPROBE_SINGLESTEP))
  			new.control |= PER_EVENT_IFETCH;
  		new.start = 0;
@@@ -1346,23 -1227,6 +1331,26 @@@ static const struct user_regset s390_re
  		.get = s390_vxrs_high_get,
  		.set = s390_vxrs_high_set,
  	},
++<<<<<<< HEAD
 +	{
 +		.core_note_type = NT_S390_GS_CB,
 +		.n = sizeof(struct gs_cb) / sizeof(__u64),
 +		.size = sizeof(__u64),
 +		.align = sizeof(__u64),
 +		.get = s390_gs_cb_get,
 +		.set = s390_gs_cb_set,
 +	},
 +	{
 +		.core_note_type = NT_S390_GS_BC,
 +		.n = sizeof(struct gs_cb) / sizeof(__u64),
 +		.size = sizeof(__u64),
 +		.align = sizeof(__u64),
 +		.get = s390_gs_bc_get,
 +		.set = s390_gs_bc_set,
 +	},
 +#endif
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  };
  
  static const struct user_regset_view user_s390_view = {
diff --cc arch/s390/kernel/setup.c
index 0016bfa2fe72,7262fe438c99..000000000000
--- a/arch/s390/kernel/setup.c
+++ b/arch/s390/kernel/setup.c
@@@ -340,28 -331,11 +338,34 @@@ static void __init setup_lowcore(void
  	lc->machine_flags = S390_lowcore.machine_flags;
  	lc->stfl_fac_list = S390_lowcore.stfl_fac_list;
  	memcpy(lc->stfle_fac_list, S390_lowcore.stfle_fac_list,
++<<<<<<< HEAD
 +	       sizeof(lc->stfle_fac_list));
 +	memcpy(lc->alt_stfle_fac_list, S390_lowcore.alt_stfle_fac_list,
 +	       sizeof(lc->alt_stfle_fac_list));
 +#ifndef CONFIG_64BIT
 +	if (MACHINE_HAS_IEEE) {
 +		lc->extended_save_area_addr = (__u32)
 +			__alloc_bootmem_low(PAGE_SIZE, PAGE_SIZE, 0);
 +		/* enable extended save area */
 +		__ctl_set_bit(14, 29);
 +	}
 +#else
 +	if (MACHINE_HAS_VX || MACHINE_HAS_GS) {
 +		unsigned long bits, size;
 +
 +		bits = MACHINE_HAS_GS ? 11 : 10;
 +		size = 1UL << bits;
 +		lc->mcesad = (__u64) __alloc_bootmem_low(size, size, 0);
 +		if (MACHINE_HAS_GS)
 +			lc->mcesad |= bits;
 +	}
++=======
+ 	       MAX_FACILITY_BIT/8);
+ 	if (MACHINE_HAS_VX)
+ 		lc->vector_save_area_addr =
+ 			(unsigned long) &lc->vector_save_area;
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	lc->vdso_per_cpu_data = (unsigned long) &lc->paste[0];
- #endif
  	lc->sync_enter_timer = S390_lowcore.sync_enter_timer;
  	lc->async_enter_timer = S390_lowcore.async_enter_timer;
  	lc->exit_timer = S390_lowcore.exit_timer;
@@@ -476,50 -437,12 +480,49 @@@ static void __init setup_resources(void
  static void __init setup_memory_end(void)
  {
  	unsigned long vmax, vmalloc_size, tmp;
 +	unsigned long real_memory_size = 0;
 +	int i;
 +
 +
 +#ifdef CONFIG_ZFCPDUMP
 +	if (ipl_info.type == IPL_TYPE_FCP_DUMP &&
 +	    !OLDMEM_BASE && sclp_get_hsa_size()) {
 +		memory_end = sclp_get_hsa_size();
 +		memory_end_set = 1;
 +	}
 +#endif
 +	memory_end &= PAGE_MASK;
 +
 +	/*
 +	 * Make sure all chunks are MAX_ORDER aligned so we don't need the
 +	 * extra checks that HOLES_IN_ZONE would require.
 +	 */
 +	for (i = 0; i < MEMORY_CHUNKS; i++) {
 +		unsigned long start, end;
 +		struct mem_chunk *chunk;
 +		unsigned long align;
 +
 +		chunk = &memory_chunk[i];
 +		if (!chunk->size)
 +			continue;
 +		align = 1UL << (MAX_ORDER + PAGE_SHIFT - 1);
 +		start = (chunk->addr + align - 1) & ~(align - 1);
 +		end = (chunk->addr + chunk->size) & ~(align - 1);
 +		if (start >= end)
 +			memset(chunk, 0, sizeof(*chunk));
 +		else {
 +			chunk->addr = start;
 +			chunk->size = end - start;
 +		}
 +		real_memory_size = max(real_memory_size,
 +				       chunk->addr + chunk->size);
 +	}
  
  	/* Choose kernel address space layout: 2, 3, or 4 levels. */
- #ifdef CONFIG_64BIT
  	vmalloc_size = VMALLOC_END ?: (128UL << 30) - MODULES_LEN;
 -	tmp = (memory_end ?: max_physmem_end) / PAGE_SIZE;
 -	tmp = tmp * (sizeof(struct page) + PAGE_SIZE);
 -	if (tmp + vmalloc_size + MODULES_LEN <= (1UL << 42))
 +	tmp = (memory_end ?: real_memory_size) / PAGE_SIZE;
 +	tmp = tmp * (sizeof(struct page) + PAGE_SIZE) + vmalloc_size;
 +	if (tmp <= (1UL << 42))
  		vmax = 1UL << 42;	/* 3-level kernel page table */
  	else
  		vmax = 1UL << 53;	/* 4-level kernel page table */
@@@ -944,27 -751,12 +940,27 @@@ static void __init setup_hwcaps(void
  	/*
  	 * Vector extension HWCAP_S390_VXRS is bit 11.
  	 */
 -	if (test_facility(129))
 +	if (test_facility(129)) {
  		elf_hwcap |= HWCAP_S390_VXRS;
++<<<<<<< HEAD
 +		if (test_facility(134))
 +			elf_hwcap |= HWCAP_S390_VXRS_EXT;
 +		if (test_facility(135))
 +			elf_hwcap |= HWCAP_S390_VXRS_BCD;
 +	}
 +#endif
 +
 +	/*
 +	 * Guarded storage support HWCAP_S390_GS is bit 12.
 +	 */
 +	if (MACHINE_HAS_GS)
 +		elf_hwcap |= HWCAP_S390_GS;
 +
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	get_cpu_id(&cpu_id);
 -	add_device_randomness(&cpu_id, sizeof(cpu_id));
  	switch (cpu_id.machine) {
  	case 0x9672:
- #if !defined(CONFIG_64BIT)
- 	default:	/* Use "g5" as default for 31 bit kernels. */
- #endif
  		strcpy(elf_platform, "g5");
  		break;
  	case 0x2064:
diff --cc arch/s390/kernel/signal.c
index 83438de94adf,7fec60cb0b75..000000000000
--- a/arch/s390/kernel/signal.c
+++ b/arch/s390/kernel/signal.c
@@@ -425,11 -412,10 +416,16 @@@ static int setup_rt_frame(int sig, stru
  		frame_size += sizeof(_sigregs_ext);
  		if (current->thread.vxrs)
  			uc_flags |= UC_VXRS;
++<<<<<<< HEAD
 + 	}
 +#endif
 +	frame = get_sigframe(ka, regs, frame_size);
++=======
+ 	}
+ 	frame = get_sigframe(&ksig->ka, regs, frame_size);
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	if (frame == (void __user *) -1UL)
 -		return -EFAULT;
 +		goto give_sigsegv;
  
  	/* Set up backchain. */
  	if (__put_user(regs->gprs[15], (addr_t __user *) frame))
diff --cc arch/s390/kernel/smp.c
index 19eb0681a236,d140160c9aec..000000000000
--- a/arch/s390/kernel/smp.c
+++ b/arch/s390/kernel/smp.c
@@@ -219,24 -194,15 +219,29 @@@ static int pcpu_alloc_lowcore(struct pc
  	lc = pcpu->lowcore;
  	memcpy(lc, &S390_lowcore, 512);
  	memset((char *) lc + 512, 0, sizeof(*lc) - 512);
 -	lc->async_stack = async_stack + ASYNC_FRAME_OFFSET;
 -	lc->panic_stack = panic_stack + PANIC_FRAME_OFFSET;
 +	lc->async_stack = pcpu->async_stack + ASYNC_SIZE
 +		- STACK_FRAME_OVERHEAD - sizeof(struct pt_regs);
 +	lc->panic_stack = pcpu->panic_stack + PAGE_SIZE
 +		- STACK_FRAME_OVERHEAD - sizeof(struct pt_regs);
 +	lc->mcesad = mcesa_origin | mcesa_bits;
  	lc->cpu_nr = cpu;
  	lc->spinlock_lockval = arch_spin_lockval(cpu);
++<<<<<<< HEAD
 +	lc->br_r1_trampoline = 0x07f1;	/* br %r1 */
 +#ifndef CONFIG_64BIT
 +	if (MACHINE_HAS_IEEE) {
 +		lc->extended_save_area_addr = get_zeroed_page(GFP_KERNEL);
 +		if (!lc->extended_save_area_addr)
 +			goto out;
 +	}
 +#else
++=======
+ 	if (MACHINE_HAS_VX)
+ 		lc->vector_save_area_addr =
+ 			(unsigned long) &lc->vector_save_area;
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	if (vdso_alloc_per_cpu(lc))
  		goto out;
- #endif
  	lowcore_ptr[cpu] = lc;
  	pcpu_sigp_retry(pcpu, SIGP_SET_PREFIX, (u32)(unsigned long) lc);
  	return 0;
@@@ -256,28 -219,13 +261,19 @@@ out
  
  static void pcpu_free_lowcore(struct pcpu *pcpu)
  {
 +	unsigned long mcesa_origin;
 +
  	pcpu_sigp_retry(pcpu, SIGP_SET_PREFIX, 0);
  	lowcore_ptr[pcpu - pcpu_devices] = NULL;
- #ifndef CONFIG_64BIT
- 	if (MACHINE_HAS_IEEE) {
- 		struct _lowcore *lc = pcpu->lowcore;
- 
- 		free_page((unsigned long) lc->extended_save_area_addr);
- 		lc->extended_save_area_addr = 0;
- 	}
- #else
  	vdso_free_per_cpu(pcpu->lowcore);
- #endif
  	if (pcpu == &pcpu_devices[0])
  		return;
 -	free_page(pcpu->lowcore->panic_stack-PANIC_FRAME_OFFSET);
 -	free_pages(pcpu->lowcore->async_stack-ASYNC_FRAME_OFFSET, ASYNC_ORDER);
 +	if (MACHINE_HAS_VX || MACHINE_HAS_GS) {
 +		mcesa_origin = pcpu->lowcore->mcesad & MCESA_ORIGIN_MASK;
 +		kmem_cache_free(pcpu_mcesa_cache, (void *) mcesa_origin);
 +	}
 +	free_page(pcpu->panic_stack);
 +	free_pages(pcpu->async_stack, ASYNC_ORDER);
  	free_pages((unsigned long) pcpu->lowcore, LC_ORDER);
  }
  
diff --cc arch/s390/kernel/traps.c
index 08951ec711ba,8be11c22ed17..000000000000
--- a/arch/s390/kernel/traps.c
+++ b/arch/s390/kernel/traps.c
@@@ -151,13 -148,8 +146,15 @@@ DO_ERROR_INFO(privileged_op, SIGILL, IL
  	      "privileged operation")
  DO_ERROR_INFO(special_op_exception, SIGILL, ILL_ILLOPN,
  	      "special operation exception")
++<<<<<<< HEAD
 +DO_ERROR_INFO(translation_exception, SIGILL, ILL_ILLOPN,
 +	      "translation exception")
 +
 +#ifdef CONFIG_64BIT
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  DO_ERROR_INFO(transaction_exception, SIGILL, ILL_ILLOPN,
  	      "transaction constraint exception")
- #endif
  
  static inline void do_fp_trap(struct pt_regs *regs, int fpc)
  {
@@@ -244,68 -219,11 +218,11 @@@ void __kprobes illegal_op(struct pt_reg
  	if (signal)
  		do_trap(regs, signal, ILL_ILLOPC, "illegal operation");
  }
 -NOKPROBE_SYMBOL(illegal_op);
 +
  
- #ifdef CONFIG_MATHEMU
- void specification_exception(struct pt_regs *regs)
- {
-         __u8 opcode[6];
- 	__u16 __user *location = NULL;
- 	int signal = 0;
- 
- 	location = (__u16 __user *) get_trap_ip(regs);
- 
- 	if (user_mode(regs)) {
- 		get_user(*((__u16 *) opcode), location);
- 		switch (opcode[0]) {
- 		case 0x28: /* LDR Rx,Ry   */
- 			signal = math_emu_ldr(opcode);
- 			break;
- 		case 0x38: /* LER Rx,Ry   */
- 			signal = math_emu_ler(opcode);
- 			break;
- 		case 0x60: /* STD R,D(X,B) */
- 			get_user(*((__u16 *) (opcode+2)), location+1);
- 			signal = math_emu_std(opcode, regs);
- 			break;
- 		case 0x68: /* LD R,D(X,B) */
- 			get_user(*((__u16 *) (opcode+2)), location+1);
- 			signal = math_emu_ld(opcode, regs);
- 			break;
- 		case 0x70: /* STE R,D(X,B) */
- 			get_user(*((__u16 *) (opcode+2)), location+1);
- 			signal = math_emu_ste(opcode, regs);
- 			break;
- 		case 0x78: /* LE R,D(X,B) */
- 			get_user(*((__u16 *) (opcode+2)), location+1);
- 			signal = math_emu_le(opcode, regs);
- 			break;
- 		default:
- 			signal = SIGILL;
- 			break;
-                 }
-         } else
- 		signal = SIGILL;
- 
-         if (signal == SIGFPE)
- 		do_fp_trap(regs, current->thread.fp_regs.fpc);
- 	else if (signal)
- 		do_trap(regs, signal, ILL_ILLOPN, "specification exception");
- }
- #else
  DO_ERROR_INFO(specification_exception, SIGILL, ILL_ILLOPN,
  	      "specification exception");
- #endif
  
- #ifdef CONFIG_64BIT
  int alloc_vector_registers(struct task_struct *tsk)
  {
  	__vector128 *vxrs;
@@@ -445,11 -304,9 +303,9 @@@ void data_exception(struct pt_regs *reg
  		alloc_vector_registers(current);
  		/* Vector data exception is suppressing, rewind psw. */
  		regs->psw.addr = __rewind_psw(regs->psw, regs->int_code >> 16);
 -		clear_pt_regs_flag(regs, PIF_PER_TRAP);
 +		clear_thread_flag(TIF_PER_TRAP);
  		return;
  	}
- #endif
- 
  	if (current->thread.fp_regs.fpc & FPC_DXC_MASK)
  		signal = SIGFPE;
  	else
diff --cc arch/s390/lib/Makefile
index 79609da5e3bf,15536da68e18..000000000000
--- a/arch/s390/lib/Makefile
+++ b/arch/s390/lib/Makefile
@@@ -2,9 -2,8 +2,14 @@@
  # Makefile for s390-specific library files..
  #
  
++<<<<<<< HEAD
 +lib-y += delay.o string.o uaccess.o
 +obj-$(CONFIG_32BIT) += div64.o qrnnd.o ucmpdi2.o mem32.o
 +obj-$(CONFIG_64BIT) += mem64.o
++=======
+ lib-y += delay.o string.o uaccess.o find.o
+ obj-y += mem64.o
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  lib-$(CONFIG_SMP) += spinlock.o
  lib-$(CONFIG_KPROBES) += probes.o
  lib-$(CONFIG_UPROBES) += probes.o
diff --cc arch/s390/mm/dump_pagetables.c
index f8155c9acdd7,8556d6be9b54..000000000000
--- a/arch/s390/mm/dump_pagetables.c
+++ b/arch/s390/mm/dump_pagetables.c
@@@ -128,12 -123,6 +124,15 @@@ static void walk_pte_level(struct seq_f
  	}
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_64BIT
 +#define _PMD_PROT_MASK (_SEGMENT_ENTRY_PROTECT | _SEGMENT_ENTRY_NOEXEC)
 +#else
 +#define _PMD_PROT_MASK 0
 +#endif
 +
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  static void walk_pmd_level(struct seq_file *m, struct pg_state *st,
  			   pud_t *pud, unsigned long addr)
  {
@@@ -156,12 -145,6 +155,15 @@@
  	}
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_64BIT
 +#define _PUD_PROT_MASK (_REGION3_ENTRY_RO | _REGION_ENTRY_NOEXEC)
 +#else
 +#define _PUD_PROT_MASK 0
 +#endif
 +
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  static void walk_pud_level(struct seq_file *m, struct pg_state *st,
  			   pgd_t *pgd, unsigned long addr)
  {
diff --cc arch/s390/mm/fault.c
index 54bfc6b9a179,76515bcea2f1..000000000000
--- a/arch/s390/mm/fault.c
+++ b/arch/s390/mm/fault.c
@@@ -125,6 -118,105 +117,108 @@@ static inline int user_space_fault(stru
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int bad_address(void *p)
+ {
+ 	unsigned long dummy;
+ 
+ 	return probe_kernel_address((unsigned long *)p, dummy);
+ }
+ 
+ static void dump_pagetable(unsigned long asce, unsigned long address)
+ {
+ 	unsigned long *table = __va(asce & PAGE_MASK);
+ 
+ 	pr_alert("AS:%016lx ", asce);
+ 	switch (asce & _ASCE_TYPE_MASK) {
+ 	case _ASCE_TYPE_REGION1:
+ 		table = table + ((address >> 53) & 0x7ff);
+ 		if (bad_address(table))
+ 			goto bad;
+ 		pr_cont("R1:%016lx ", *table);
+ 		if (*table & _REGION_ENTRY_INVALID)
+ 			goto out;
+ 		table = (unsigned long *)(*table & _REGION_ENTRY_ORIGIN);
+ 		/* fallthrough */
+ 	case _ASCE_TYPE_REGION2:
+ 		table = table + ((address >> 42) & 0x7ff);
+ 		if (bad_address(table))
+ 			goto bad;
+ 		pr_cont("R2:%016lx ", *table);
+ 		if (*table & _REGION_ENTRY_INVALID)
+ 			goto out;
+ 		table = (unsigned long *)(*table & _REGION_ENTRY_ORIGIN);
+ 		/* fallthrough */
+ 	case _ASCE_TYPE_REGION3:
+ 		table = table + ((address >> 31) & 0x7ff);
+ 		if (bad_address(table))
+ 			goto bad;
+ 		pr_cont("R3:%016lx ", *table);
+ 		if (*table & (_REGION_ENTRY_INVALID | _REGION3_ENTRY_LARGE))
+ 			goto out;
+ 		table = (unsigned long *)(*table & _REGION_ENTRY_ORIGIN);
+ 		/* fallthrough */
+ 	case _ASCE_TYPE_SEGMENT:
+ 		table = table + ((address >> 20) & 0x7ff);
+ 		if (bad_address(table))
+ 			goto bad;
+ 		pr_cont("S:%016lx ", *table);
+ 		if (*table & (_SEGMENT_ENTRY_INVALID | _SEGMENT_ENTRY_LARGE))
+ 			goto out;
+ 		table = (unsigned long *)(*table & _SEGMENT_ENTRY_ORIGIN);
+ 	}
+ 	table = table + ((address >> 12) & 0xff);
+ 	if (bad_address(table))
+ 		goto bad;
+ 	pr_cont("P:%016lx ", *table);
+ out:
+ 	pr_cont("\n");
+ 	return;
+ bad:
+ 	pr_cont("BAD\n");
+ }
+ 
+ static void dump_fault_info(struct pt_regs *regs)
+ {
+ 	unsigned long asce;
+ 
+ 	pr_alert("Fault in ");
+ 	switch (regs->int_parm_long & 3) {
+ 	case 3:
+ 		pr_cont("home space ");
+ 		break;
+ 	case 2:
+ 		pr_cont("secondary space ");
+ 		break;
+ 	case 1:
+ 		pr_cont("access register ");
+ 		break;
+ 	case 0:
+ 		pr_cont("primary space ");
+ 		break;
+ 	}
+ 	pr_cont("mode while using ");
+ 	if (!user_space_fault(regs)) {
+ 		asce = S390_lowcore.kernel_asce;
+ 		pr_cont("kernel ");
+ 	}
+ #ifdef CONFIG_PGSTE
+ 	else if ((current->flags & PF_VCPU) && S390_lowcore.gmap) {
+ 		struct gmap *gmap = (struct gmap *)S390_lowcore.gmap;
+ 		asce = gmap->asce;
+ 		pr_cont("gmap ");
+ 	}
+ #endif
+ 	else {
+ 		asce = S390_lowcore.user_asce;
+ 		pr_cont("user ");
+ 	}
+ 	pr_cont("ASCE.\n");
+ 	dump_pagetable(asce, regs->int_parm_long & __FAIL_ADDR_MASK);
+ }
+ 
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  static inline void report_user_fault(struct pt_regs *regs, long signr)
  {
  	if ((task_pid_nr(current) > 1) && !show_unhandled_signals)
diff --cc arch/s390/mm/init.c
index f01c5dae7a69,80875c43a4a4..000000000000
--- a/arch/s390/mm/init.c
+++ b/arch/s390/mm/init.c
@@@ -113,12 -112,7 +112,16 @@@ void __init paging_init(void
  		asce_bits = _ASCE_TYPE_REGION3 | _ASCE_TABLE_LENGTH;
  		pgd_type = _REGION3_ENTRY_EMPTY;
  	}
++<<<<<<< HEAD
 +#else
 +	asce_bits = _ASCE_TABLE_LENGTH;
 +	pgd_type = _SEGMENT_ENTRY_EMPTY;
 +#endif
 +	init_mm.context.asce = (__pa(init_mm.pgd) & PAGE_MASK) | asce_bits;
 +	S390_lowcore.kernel_asce = init_mm.context.asce;
++=======
+ 	S390_lowcore.kernel_asce = (__pa(init_mm.pgd) & PAGE_MASK) | asce_bits;
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	clear_table((unsigned long *) init_mm.pgd, pgd_type,
  		    sizeof(unsigned long)*2048);
  	vmem_map_init();
diff --cc arch/s390/mm/mem_detect.c
index e94ff5495b39,0f3604395805..000000000000
--- a/arch/s390/mm/mem_detect.c
+++ b/arch/s390/mm/mem_detect.c
@@@ -23,12 -36,10 +23,19 @@@ static void find_memory_chunks(struct m
  	memsize = rzm * rnmax;
  	if (!rzm)
  		rzm = 1ULL << 17;
++<<<<<<< HEAD
 +	if (sizeof(long) == 4) {
 +		rzm = min(ADDR2G, rzm);
 +		memsize = memsize ? min(ADDR2G, memsize) : ADDR2G;
 +	}
 +	if (maxsize)
 +		memsize = memsize ? min((unsigned long)memsize, maxsize) : maxsize;
++=======
+ 	max_physmem_end = memsize;
+ 	addr = 0;
+ 	/* keep memblock lists close to the kernel */
+ 	memblock_set_bottom_up(true);
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	do {
  		size = 0;
  		type = tprot(addr);
diff --cc arch/s390/mm/mmap.c
index e797c97791e9,2e8378796e87..000000000000
--- a/arch/s390/mm/mmap.c
+++ b/arch/s390/mm/mmap.c
@@@ -200,29 -179,87 +200,108 @@@ check_asce_limit
  	return addr;
  }
  
++<<<<<<< HEAD
++=======
+ unsigned long randomize_et_dyn(void)
+ {
+ 	unsigned long base;
+ 
+ 	base = STACK_TOP / 3 * 2;
+ 	if (!is_32bit_task())
+ 		/* Align to 4GB */
+ 		base &= ~((1UL << 32) - 1);
+ 	return base + mmap_rnd();
+ }
+ 
+ int s390_mmap_check(unsigned long addr, unsigned long len, unsigned long flags)
+ {
+ 	if (is_compat_task() || (TASK_SIZE >= (1UL << 53)))
+ 		return 0;
+ 	if (!(flags & MAP_FIXED))
+ 		addr = 0;
+ 	if ((addr + len) >= TASK_SIZE)
+ 		return crst_table_upgrade(current->mm, 1UL << 53);
+ 	return 0;
+ }
+ 
+ static unsigned long
+ s390_get_unmapped_area(struct file *filp, unsigned long addr,
+ 		unsigned long len, unsigned long pgoff, unsigned long flags)
+ {
+ 	struct mm_struct *mm = current->mm;
+ 	unsigned long area;
+ 	int rc;
+ 
+ 	area = arch_get_unmapped_area(filp, addr, len, pgoff, flags);
+ 	if (!(area & ~PAGE_MASK))
+ 		return area;
+ 	if (area == -ENOMEM && !is_compat_task() && TASK_SIZE < (1UL << 53)) {
+ 		/* Upgrade the page table to 4 levels and retry. */
+ 		rc = crst_table_upgrade(mm, 1UL << 53);
+ 		if (rc)
+ 			return (unsigned long) rc;
+ 		area = arch_get_unmapped_area(filp, addr, len, pgoff, flags);
+ 	}
+ 	return area;
+ }
+ 
+ static unsigned long
+ s390_get_unmapped_area_topdown(struct file *filp, const unsigned long addr,
+ 			  const unsigned long len, const unsigned long pgoff,
+ 			  const unsigned long flags)
+ {
+ 	struct mm_struct *mm = current->mm;
+ 	unsigned long area;
+ 	int rc;
+ 
+ 	area = arch_get_unmapped_area_topdown(filp, addr, len, pgoff, flags);
+ 	if (!(area & ~PAGE_MASK))
+ 		return area;
+ 	if (area == -ENOMEM && !is_compat_task() && TASK_SIZE < (1UL << 53)) {
+ 		/* Upgrade the page table to 4 levels and retry. */
+ 		rc = crst_table_upgrade(mm, 1UL << 53);
+ 		if (rc)
+ 			return (unsigned long) rc;
+ 		area = arch_get_unmapped_area_topdown(filp, addr, len,
+ 						      pgoff, flags);
+ 	}
+ 	return area;
+ }
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  /*
   * This function, called very early during the creation of a new
   * process VM image, sets up which VM layout function to use:
   */
  void arch_pick_mmap_layout(struct mm_struct *mm)
  {
++<<<<<<< HEAD
 +	unsigned long random_factor = 0UL;
 +
 +	if (current->flags & PF_RANDOMIZE)
 +		random_factor = arch_mmap_rnd();
 +
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	/*
  	 * Fall back to the standard layout if the personality
  	 * bit is set, or if the expected stack growth is unlimited:
  	 */
  	if (mmap_is_legacy()) {
++<<<<<<< HEAD
 +		mm->mmap_base = mmap_base_legacy(random_factor);
 +		mm->get_unmapped_area = arch_get_unmapped_area;
 +		mm->unmap_area = arch_unmap_area;
 +	} else {
 +		mm->mmap_base = mmap_base(random_factor);
 +		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
 +		mm->unmap_area = arch_unmap_area_topdown;
++=======
+ 		mm->mmap_base = mmap_base_legacy();
+ 		mm->get_unmapped_area = s390_get_unmapped_area;
+ 	} else {
+ 		mm->mmap_base = mmap_base();
+ 		mm->get_unmapped_area = s390_get_unmapped_area_topdown;
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	}
  }
  
diff --cc arch/s390/mm/vmem.c
index 3b444771e4c7,ef7d6c8fea66..000000000000
--- a/arch/s390/mm/vmem.c
+++ b/arch/s390/mm/vmem.c
@@@ -108,11 -94,12 +104,15 @@@ static int vmem_add_mem(unsigned long s
  			pgd_populate(&init_mm, pg_dir, pu_dir);
  		}
  		pu_dir = pud_offset(pg_dir, address);
++<<<<<<< HEAD
 +#ifdef CONFIG_64BIT
++=======
+ #ifndef CONFIG_DEBUG_PAGEALLOC
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  		if (MACHINE_HAS_EDAT2 && pud_none(*pu_dir) && address &&
 -		    !(address & ~PUD_MASK) && (address + PUD_SIZE <= end)) {
 -			pud_val(*pu_dir) = __pa(address) |
 -				_REGION_ENTRY_TYPE_R3 | _REGION3_ENTRY_LARGE |
 -				(ro ? _REGION_ENTRY_PROTECT : 0);
 +		    !(address & ~PUD_MASK) && (address + PUD_SIZE <= end) &&
 +		    !debug_pagealloc_enabled()) {
 +			pud_val(*pu_dir) = address | r3_prot;
  			address += PUD_SIZE;
  			continue;
  		}
@@@ -124,11 -111,13 +124,15 @@@
  			pud_populate(&init_mm, pu_dir, pm_dir);
  		}
  		pm_dir = pmd_offset(pu_dir, address);
++<<<<<<< HEAD
 +#ifdef CONFIG_64BIT
++=======
+ #ifndef CONFIG_DEBUG_PAGEALLOC
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  		if (MACHINE_HAS_EDAT1 && pmd_none(*pm_dir) && address &&
 -		    !(address & ~PMD_MASK) && (address + PMD_SIZE <= end)) {
 -			pmd_val(*pm_dir) = __pa(address) |
 -				_SEGMENT_ENTRY | _SEGMENT_ENTRY_LARGE |
 -				_SEGMENT_ENTRY_YOUNG |
 -				(ro ? _SEGMENT_ENTRY_PROTECT : 0);
 +		    !(address & ~PMD_MASK) && (address + PMD_SIZE <= end) &&
 +		    !debug_pagealloc_enabled()) {
 +			pmd_val(*pm_dir) = address | sgt_prot;
  			address += PMD_SIZE;
  			continue;
  		}
diff --cc drivers/s390/block/dasd_eckd.c
index 366086e6dfc3,49b48a887c66..000000000000
--- a/drivers/s390/block/dasd_eckd.c
+++ b/drivers/s390/block/dasd_eckd.c
@@@ -1622,8 -1628,34 +1622,39 @@@ static void dasd_eckd_kick_validate_ser
  		return;
  	}
  	/* queue call to do_validate_server to the kernel event daemon. */
++<<<<<<< HEAD
 +	if (!schedule_work(&device->kick_validate))
 +		dasd_put_device(device);
++=======
+ 	schedule_work(&device->kick_validate);
+ }
+ 
+ static u32 get_fcx_max_data(struct dasd_device *device)
+ {
+ 	int tpm, mdc;
+ 	int fcx_in_css, fcx_in_gneq, fcx_in_features;
+ 	struct dasd_eckd_private *private;
+ 
+ 	if (dasd_nofcx)
+ 		return 0;
+ 	/* is transport mode supported? */
+ 	private = (struct dasd_eckd_private *) device->private;
+ 	fcx_in_css = css_general_characteristics.fcx;
+ 	fcx_in_gneq = private->gneq->reserved2[7] & 0x04;
+ 	fcx_in_features = private->features.feature[40] & 0x80;
+ 	tpm = fcx_in_css && fcx_in_gneq && fcx_in_features;
+ 
+ 	if (!tpm)
+ 		return 0;
+ 
+ 	mdc = ccw_device_get_mdc(device->cdev, 0);
+ 	if (mdc < 0) {
+ 		dev_warn(&device->cdev->dev, "Detecting the maximum supported"
+ 			 " data size for zHPF requests failed\n");
+ 		return 0;
+ 	} else
+ 		return mdc * FCX_MAX_DATA_FACTOR;
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  }
  
  /*
@@@ -3050,14 -2607,12 +3081,20 @@@ static struct dasd_ccw_req *dasd_eckd_b
  	count = 0;
  	cidaw = 0;
  	rq_for_each_segment(bv, req, iter) {
 -		if (bv.bv_len & (blksize - 1))
 +		if (bv->bv_len & (blksize - 1))
  			/* Eckd can only do full blocks. */
  			return ERR_PTR(-EINVAL);
++<<<<<<< HEAD
 +		count += bv->bv_len >> (block->s2b_shift + 9);
 +#if defined(CONFIG_64BIT)
 +		if (idal_is_needed (page_address(bv->bv_page), bv->bv_len))
 +			cidaw += bv->bv_len >> (block->s2b_shift + 9);
 +#endif
++=======
+ 		count += bv.bv_len >> (block->s2b_shift + 9);
+ 		if (idal_is_needed (page_address(bv.bv_page), bv.bv_len))
+ 			cidaw += bv.bv_len >> (block->s2b_shift + 9);
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	}
  	/* Paranoia. */
  	if (count != last_rec - first_rec + 1)
diff --cc drivers/s390/block/dasd_fba.c
index 1687a07dcee9,c9262e78938b..000000000000
--- a/drivers/s390/block/dasd_fba.c
+++ b/drivers/s390/block/dasd_fba.c
@@@ -462,14 -283,12 +462,20 @@@ static struct dasd_ccw_req *dasd_fba_bu
  	count = 0;
  	cidaw = 0;
  	rq_for_each_segment(bv, req, iter) {
 -		if (bv.bv_len & (blksize - 1))
 +		if (bv->bv_len & (blksize - 1))
  			/* Fba can only do full blocks. */
  			return ERR_PTR(-EINVAL);
++<<<<<<< HEAD
 +		count += bv->bv_len >> (block->s2b_shift + 9);
 +#if defined(CONFIG_64BIT)
 +		if (idal_is_needed (page_address(bv->bv_page), bv->bv_len))
 +			cidaw += bv->bv_len / blksize;
 +#endif
++=======
+ 		count += bv.bv_len >> (block->s2b_shift + 9);
+ 		if (idal_is_needed (page_address(bv.bv_page), bv.bv_len))
+ 			cidaw += bv.bv_len / blksize;
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	}
  	/* Paranoia. */
  	if (count != last_rec - first_rec + 1)
diff --cc drivers/s390/char/Kconfig
index dc24ecfac2d1,eaca3e006301..000000000000
--- a/drivers/s390/char/Kconfig
+++ b/drivers/s390/char/Kconfig
@@@ -105,7 -105,17 +105,11 @@@ config SCLP_ASYN
  config HMC_DRV
  	def_tristate m
  	prompt "Support for file transfers from HMC drive CD/DVD-ROM"
++<<<<<<< HEAD
 +	depends on 64BIT
++=======
+ 	depends on S390
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  	select CRC16
  	help
  	  This option enables support for file transfers from a Hardware
diff --cc drivers/s390/crypto/ap_bus.c
index d0ed4a978782,33890c9850de..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -173,123 -178,337 +173,361 @@@ static int ap_configuration_available(v
  {
  	return test_facility(2) && test_facility(12);
  }
++<<<<<<< HEAD
  
  /**
 - * ap_test_queue(): Test adjunct processor queue.
 - * @qid: The AP queue number
 - * @queue_depth: Pointer to queue depth value
 - * @device_type: Pointer to device type value
 + * ap_apft_available(): Test if AP facilities test (APFT)
 + * facility is available.
   *
 - * Returns AP queue status structure.
 + * Returns 1 if APFT is is available.
   */
 -static inline struct ap_queue_status
 -ap_test_queue(ap_qid_t qid, int *queue_depth, int *device_type)
 +static int ap_apft_available(void)
  {
 -	register unsigned long reg0 asm ("0") = qid;
 -	register struct ap_queue_status reg1 asm ("1");
 -	register unsigned long reg2 asm ("2") = 0UL;
 +	return test_facility(15);
 +}
  
 -	asm volatile(".long 0xb2af0000"		/* PQAP(TAPQ) */
 -		     : "+d" (reg0), "=d" (reg1), "+d" (reg2) : : "cc");
 -	*device_type = (int) (reg2 >> 24);
 -	*queue_depth = (int) (reg2 & 0xff);
 -	return reg1;
 +/*
 + * ap_qact_available(): Test if the PQAP(QACT) subfunction is available.
 + *
 + * Returns 1 if the QACT subfunction is available.
 + */
 +static inline int ap_qact_available(void)
 +{
 +	if (ap_configuration)
 +		return ap_configuration->qact;
 +	return 0;
  }
++=======
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  
  /**
 - * ap_query_facilities(): PQAP(TAPQ) query facilities.
 + * ap_test_queue(): Test adjunct processor queue.
   * @qid: The AP queue number
 + * @tbit: Test facilities bit
 + * @info: Pointer to queue descriptor
 + *
 + * Returns AP queue status structure.
 + */
 +struct ap_queue_status ap_test_queue(ap_qid_t qid,
 +				     int tbit,
 +				     unsigned long *info)
 +{
 +	if (tbit)
 +		qid |= 1UL << 23; /* set T bit*/
 +	return ap_tapq(qid, info);
 +}
 +EXPORT_SYMBOL(ap_test_queue);
 +
 +/*
 + * ap_query_configuration(): Fetch cryptographic config info
   *
 - * Returns content of general register 2 after the PQAP(TAPQ)
 - * instruction was called.
 + * Returns the ap configuration info fetched via PQAP(QCI).
 + * On success 0 is returned, on failure a negative errno
 + * is returned, e.g. if the PQAP(QCI) instruction is not
 + * available, the return value will be -EOPNOTSUPP.
   */
 -static inline unsigned long ap_query_facilities(ap_qid_t qid)
 +int ap_query_configuration(struct ap_config_info *info)
  {
++<<<<<<< HEAD
 +	if (!ap_configuration_available())
 +		return -EOPNOTSUPP;
 +	if (!info)
++=======
+ 	register unsigned long reg0 asm ("0") = qid | 0x00800000UL;
+ 	register unsigned long reg1 asm ("1");
+ 	register unsigned long reg2 asm ("2") = 0UL;
+ 
+ 	asm volatile(".long 0xb2af0000"  /* PQAP(TAPQ) */
+ 		     : "+d" (reg0), "=d" (reg1), "+d" (reg2) : : "cc");
+ 	return reg2;
+ }
+ 
+ /**
+  * ap_reset_queue(): Reset adjunct processor queue.
+  * @qid: The AP queue number
+  *
+  * Returns AP queue status structure.
+  */
+ static inline struct ap_queue_status ap_reset_queue(ap_qid_t qid)
+ {
+ 	register unsigned long reg0 asm ("0") = qid | 0x01000000UL;
+ 	register struct ap_queue_status reg1 asm ("1");
+ 	register unsigned long reg2 asm ("2") = 0UL;
+ 
+ 	asm volatile(
+ 		".long 0xb2af0000"		/* PQAP(RAPQ) */
+ 		: "+d" (reg0), "=d" (reg1), "+d" (reg2) : : "cc");
+ 	return reg1;
+ }
+ 
+ /**
+  * ap_queue_interruption_control(): Enable interruption for a specific AP.
+  * @qid: The AP queue number
+  * @ind: The notification indicator byte
+  *
+  * Returns AP queue status.
+  */
+ static inline struct ap_queue_status
+ ap_queue_interruption_control(ap_qid_t qid, void *ind)
+ {
+ 	register unsigned long reg0 asm ("0") = qid | 0x03000000UL;
+ 	register unsigned long reg1_in asm ("1") = 0x0000800000000000UL | AP_ISC;
+ 	register struct ap_queue_status reg1_out asm ("1");
+ 	register void *reg2 asm ("2") = ind;
+ 	asm volatile(
+ 		".long 0xb2af0000"		/* PQAP(AQIC) */
+ 		: "+d" (reg0), "+d" (reg1_in), "=d" (reg1_out), "+d" (reg2)
+ 		:
+ 		: "cc" );
+ 	return reg1_out;
+ }
+ 
+ static inline struct ap_queue_status
+ __ap_query_functions(ap_qid_t qid, unsigned int *functions)
+ {
+ 	register unsigned long reg0 asm ("0") = 0UL | qid | (1UL << 23);
+ 	register struct ap_queue_status reg1 asm ("1") = AP_QUEUE_STATUS_INVALID;
+ 	register unsigned long reg2 asm ("2");
+ 
+ 	asm volatile(
+ 		".long 0xb2af0000\n"		/* PQAP(TAPQ) */
+ 		"0:\n"
+ 		EX_TABLE(0b, 0b)
+ 		: "+d" (reg0), "+d" (reg1), "=d" (reg2)
+ 		:
+ 		: "cc");
+ 
+ 	*functions = (unsigned int)(reg2 >> 32);
+ 	return reg1;
+ }
+ 
+ static inline int __ap_query_configuration(struct ap_config_info *config)
+ {
+ 	register unsigned long reg0 asm ("0") = 0x04000000UL;
+ 	register unsigned long reg1 asm ("1") = -EINVAL;
+ 	register unsigned char *reg2 asm ("2") = (unsigned char *)config;
+ 
+ 	asm volatile(
+ 		".long 0xb2af0000\n"		/* PQAP(QCI) */
+ 		"0: la    %1,0\n"
+ 		"1:\n"
+ 		EX_TABLE(0b, 1b)
+ 		: "+d" (reg0), "+d" (reg1), "+d" (reg2)
+ 		:
+ 		: "cc");
+ 
+ 	return reg1;
+ }
+ 
+ /**
+  * ap_query_functions(): Query supported functions.
+  * @qid: The AP queue number
+  * @functions: Pointer to functions field.
+  *
+  * Returns
+  *   0	     on success.
+  *   -ENODEV  if queue not valid.
+  *   -EBUSY   if device busy.
+  *   -EINVAL  if query function is not supported
+  */
+ static int ap_query_functions(ap_qid_t qid, unsigned int *functions)
+ {
+ 	struct ap_queue_status status;
+ 	int i;
+ 	status = __ap_query_functions(qid, functions);
+ 
+ 	for (i = 0; i < AP_MAX_RESET; i++) {
+ 		if (ap_queue_status_invalid_test(&status))
+ 			return -ENODEV;
+ 
+ 		switch (status.response_code) {
+ 		case AP_RESPONSE_NORMAL:
+ 			return 0;
+ 		case AP_RESPONSE_RESET_IN_PROGRESS:
+ 		case AP_RESPONSE_BUSY:
+ 			break;
+ 		case AP_RESPONSE_Q_NOT_AVAIL:
+ 		case AP_RESPONSE_DECONFIGURED:
+ 		case AP_RESPONSE_CHECKSTOPPED:
+ 		case AP_RESPONSE_INVALID_ADDRESS:
+ 			return -ENODEV;
+ 		case AP_RESPONSE_OTHERWISE_CHANGED:
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 		if (i < AP_MAX_RESET - 1) {
+ 			udelay(5);
+ 			status = __ap_query_functions(qid, functions);
+ 		}
+ 	}
+ 	return -EBUSY;
+ }
+ 
+ /**
+  * ap_queue_enable_interruption(): Enable interruption on an AP.
+  * @qid: The AP queue number
+  * @ind: the notification indicator byte
+  *
+  * Enables interruption on AP queue via ap_queue_interruption_control(). Based
+  * on the return value it waits a while and tests the AP queue if interrupts
+  * have been switched on using ap_test_queue().
+  */
+ static int ap_queue_enable_interruption(ap_qid_t qid, void *ind)
+ {
+ 	struct ap_queue_status status;
+ 	int t_depth, t_device_type, rc, i;
+ 
+ 	rc = -EBUSY;
+ 	status = ap_queue_interruption_control(qid, ind);
+ 
+ 	for (i = 0; i < AP_MAX_RESET; i++) {
+ 		switch (status.response_code) {
+ 		case AP_RESPONSE_NORMAL:
+ 			if (status.int_enabled)
+ 				return 0;
+ 			break;
+ 		case AP_RESPONSE_RESET_IN_PROGRESS:
+ 		case AP_RESPONSE_BUSY:
+ 			if (i < AP_MAX_RESET - 1) {
+ 				udelay(5);
+ 				status = ap_queue_interruption_control(qid,
+ 								       ind);
+ 				continue;
+ 			}
+ 			break;
+ 		case AP_RESPONSE_Q_NOT_AVAIL:
+ 		case AP_RESPONSE_DECONFIGURED:
+ 		case AP_RESPONSE_CHECKSTOPPED:
+ 		case AP_RESPONSE_INVALID_ADDRESS:
+ 			return -ENODEV;
+ 		case AP_RESPONSE_OTHERWISE_CHANGED:
+ 			if (status.int_enabled)
+ 				return 0;
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 		if (i < AP_MAX_RESET - 1) {
+ 			udelay(5);
+ 			status = ap_test_queue(qid, &t_depth, &t_device_type);
+ 		}
+ 	}
+ 	return rc;
+ }
+ 
+ /**
+  * __ap_send(): Send message to adjunct processor queue.
+  * @qid: The AP queue number
+  * @psmid: The program supplied message identifier
+  * @msg: The message text
+  * @length: The message length
+  * @special: Special Bit
+  *
+  * Returns AP queue status structure.
+  * Condition code 1 on NQAP can't happen because the L bit is 1.
+  * Condition code 2 on NQAP also means the send is incomplete,
+  * because a segment boundary was reached. The NQAP is repeated.
+  */
+ static inline struct ap_queue_status
+ __ap_send(ap_qid_t qid, unsigned long long psmid, void *msg, size_t length,
+ 	  unsigned int special)
+ {
+ 	typedef struct { char _[length]; } msgblock;
+ 	register unsigned long reg0 asm ("0") = qid | 0x40000000UL;
+ 	register struct ap_queue_status reg1 asm ("1");
+ 	register unsigned long reg2 asm ("2") = (unsigned long) msg;
+ 	register unsigned long reg3 asm ("3") = (unsigned long) length;
+ 	register unsigned long reg4 asm ("4") = (unsigned int) (psmid >> 32);
+ 	register unsigned long reg5 asm ("5") = psmid & 0xffffffff;
+ 
+ 	if (special == 1)
+ 		reg0 |= 0x400000UL;
+ 
+ 	asm volatile (
+ 		"0: .long 0xb2ad0042\n"		/* NQAP */
+ 		"   brc   2,0b"
+ 		: "+d" (reg0), "=d" (reg1), "+d" (reg2), "+d" (reg3)
+ 		: "d" (reg4), "d" (reg5), "m" (*(msgblock *) msg)
+ 		: "cc" );
+ 	return reg1;
+ }
+ 
+ int ap_send(ap_qid_t qid, unsigned long long psmid, void *msg, size_t length)
+ {
+ 	struct ap_queue_status status;
+ 
+ 	status = __ap_send(qid, psmid, msg, length, 0);
+ 	switch (status.response_code) {
+ 	case AP_RESPONSE_NORMAL:
+ 		return 0;
+ 	case AP_RESPONSE_Q_FULL:
+ 	case AP_RESPONSE_RESET_IN_PROGRESS:
+ 		return -EBUSY;
+ 	case AP_RESPONSE_REQ_FAC_NOT_INST:
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
  		return -EINVAL;
 -	default:	/* Device is gone. */
 -		return -ENODEV;
 -	}
 +	return ap_qci(info);
  }
 -EXPORT_SYMBOL(ap_send);
 +EXPORT_SYMBOL(ap_query_configuration);
  
  /**
 - * __ap_recv(): Receive message from adjunct processor queue.
 - * @qid: The AP queue number
 - * @psmid: Pointer to program supplied message identifier
 - * @msg: The message text
 - * @length: The message length
 - *
 - * Returns AP queue status structure.
 - * Condition code 1 on DQAP means the receive has taken place
 - * but only partially.	The response is incomplete, hence the
 - * DQAP is repeated.
 - * Condition code 2 on DQAP also means the receive is incomplete,
 - * this time because a segment boundary was reached. Again, the
 - * DQAP is repeated.
 - * Note that gpr2 is used by the DQAP instruction to keep track of
 - * any 'residual' length, in case the instruction gets interrupted.
 - * Hence it gets zeroed before the instruction.
 + * ap_init_configuration(): Allocate and query configuration array.
   */
 -static inline struct ap_queue_status
 -__ap_recv(ap_qid_t qid, unsigned long long *psmid, void *msg, size_t length)
 +static void ap_init_configuration(void)
  {
 -	typedef struct { char _[length]; } msgblock;
 -	register unsigned long reg0 asm("0") = qid | 0x80000000UL;
 -	register struct ap_queue_status reg1 asm ("1");
 -	register unsigned long reg2 asm("2") = 0UL;
 -	register unsigned long reg4 asm("4") = (unsigned long) msg;
 -	register unsigned long reg5 asm("5") = (unsigned long) length;
 -	register unsigned long reg6 asm("6") = 0UL;
 -	register unsigned long reg7 asm("7") = 0UL;
 +	if (!ap_configuration_available())
 +		return;
  
 +	ap_configuration = kzalloc(sizeof(*ap_configuration), GFP_KERNEL);
 +	if (!ap_configuration)
 +		return;
 +	if (ap_query_configuration(ap_configuration) != 0) {
 +		kfree(ap_configuration);
 +		ap_configuration = NULL;
 +		return;
 +	}
 +}
  
 -	asm volatile(
 -		"0: .long 0xb2ae0064\n"		/* DQAP */
 -		"   brc   6,0b\n"
 -		: "+d" (reg0), "=d" (reg1), "+d" (reg2),
 -		"+d" (reg4), "+d" (reg5), "+d" (reg6), "+d" (reg7),
 -		"=m" (*(msgblock *) msg) : : "cc" );
 -	*psmid = (((unsigned long long) reg6) << 32) + reg7;
 -	return reg1;
 +/*
 + * ap_test_config(): helper function to extract the nrth bit
 + *		     within the unsigned int array field.
 + */
 +static inline int ap_test_config(unsigned int *field, unsigned int nr)
 +{
 +	return ap_test_bit((field + (nr >> 5)), (nr & 0x1f));
  }
  
 -int ap_recv(ap_qid_t qid, unsigned long long *psmid, void *msg, size_t length)
 +/*
 + * ap_test_config_card_id(): Test, whether an AP card ID is configured.
 + * @id AP card ID
 + *
 + * Returns 0 if the card is not configured
 + *	   1 if the card is configured or
 + *	     if the configuration information is not available
 + */
 +static inline int ap_test_config_card_id(unsigned int id)
  {
 -	struct ap_queue_status status;
 +	if (!ap_configuration)	/* QCI not supported */
 +		/* only ids 0...3F may be probed */
 +		return id < 0x40 ? 1 : 0;
 +	return ap_test_config(ap_configuration->apm, id);
 +}
  
 -	status = __ap_recv(qid, psmid, msg, length);
 -	switch (status.response_code) {
 -	case AP_RESPONSE_NORMAL:
 -		return 0;
 -	case AP_RESPONSE_NO_PENDING_REPLY:
 -		if (status.queue_empty)
 -			return -ENOENT;
 -		return -EBUSY;
 -	case AP_RESPONSE_RESET_IN_PROGRESS:
 -		return -EBUSY;
 -	default:
 -		return -ENODEV;
 -	}
 +/*
 + * ap_test_config_domain(): Test, whether an AP usage domain is configured.
 + * @domain AP usage domain ID
 + *
 + * Returns 0 if the usage domain is not configured
 + *	   1 if the usage domain is configured or
 + *	     if the configuration information is not available
 + */
 +static inline int ap_test_config_domain(unsigned int domain)
 +{
 +	if (!ap_configuration)	/* QCI not supported */
 +		return domain < 16;
 +	return ap_test_config(ap_configuration->aqm, domain);
  }
 -EXPORT_SYMBOL(ap_recv);
  
  /**
   * ap_query_queue(): Check if an AP queue is available.
@@@ -956,6 -1216,24 +1194,27 @@@ static struct bus_attribute *const ap_b
  };
  
  /**
++<<<<<<< HEAD
++=======
+  * ap_query_configuration(): Query AP configuration information.
+  *
+  * Query information of installed cards and configured domains from AP.
+  */
+ static void ap_query_configuration(void)
+ {
+ 	if (ap_configuration_available()) {
+ 		if (!ap_configuration)
+ 			ap_configuration =
+ 				kzalloc(sizeof(struct ap_config_info),
+ 					GFP_KERNEL);
+ 		if (ap_configuration)
+ 			__ap_query_configuration(ap_configuration);
+ 	} else
+ 		ap_configuration = NULL;
+ }
+ 
+ /**
++>>>>>>> 5a79859ae0f3 (s390: remove 31 bit support)
   * ap_select_domain(): Select an AP domain.
   *
   * Pick one of the 16 AP domains.
* Unmerged path arch/s390/kernel/entry.S
* Unmerged path arch/s390/kernel/head31.S
* Unmerged path arch/s390/kernel/relocate_kernel.S
diff --git a/arch/s390/Kbuild b/arch/s390/Kbuild
index 3f6fc68e233b..267bdd0b6e40 100644
--- a/arch/s390/Kbuild
+++ b/arch/s390/Kbuild
@@ -4,6 +4,5 @@ obj-$(CONFIG_KVM)		+= kvm/
 obj-y				+= crypto/
 obj-$(CONFIG_S390_HYPFS_FS)	+= hypfs/
 obj-$(CONFIG_APPLDATA_BASE)	+= appldata/
-obj-$(CONFIG_MATHEMU)		+= math-emu/
 obj-y				+= net/
 obj-$(CONFIG_PCI)		+= pci/
* Unmerged path arch/s390/Kconfig
diff --git a/arch/s390/Makefile b/arch/s390/Makefile
index a1209ffc5263..8ab9945fd1d2 100644
--- a/arch/s390/Makefile
+++ b/arch/s390/Makefile
@@ -13,15 +13,6 @@
 # Copyright (C) 1994 by Linus Torvalds
 #
 
-ifndef CONFIG_64BIT
-LD_BFD		:= elf32-s390
-LDFLAGS		:= -m elf_s390
-KBUILD_CFLAGS	+= -m31
-KBUILD_AFLAGS	+= -m31
-UTS_MACHINE	:= s390
-STACK_SIZE	:= 8192
-CHECKFLAGS	+= -D__s390__ -msize-long
-else
 LD_BFD		:= elf64-s390
 LDFLAGS		:= -m elf64_s390
 KBUILD_AFLAGS_MODULE += -fPIC
@@ -31,11 +22,9 @@ KBUILD_AFLAGS	+= -m64
 UTS_MACHINE	:= s390x
 STACK_SIZE	:= 16384
 CHECKFLAGS	+= -D__s390__ -D__s390x__
-endif
 
 export LD_BFD
 
-mflags-$(CONFIG_MARCH_G5)     := -march=g5
 mflags-$(CONFIG_MARCH_Z900)   := -march=z900
 mflags-$(CONFIG_MARCH_Z990)   := -march=z990
 mflags-$(CONFIG_MARCH_Z9_109) := -march=z9-109
@@ -47,7 +36,6 @@ mflags-$(CONFIG_MARCH_Z13)    := -march=z13
 aflags-y += $(mflags-y)
 cflags-y += $(mflags-y)
 
-cflags-$(CONFIG_MARCH_G5_TUNE)		+= -mtune=g5
 cflags-$(CONFIG_MARCH_Z900_TUNE)	+= -mtune=z900
 cflags-$(CONFIG_MARCH_Z990_TUNE)	+= -mtune=z990
 cflags-$(CONFIG_MARCH_Z9_109_TUNE)	+= -mtune=z9-109
@@ -104,7 +92,7 @@ KBUILD_AFLAGS	+= $(aflags-y)
 OBJCOPYFLAGS	:= -O binary
 
 head-y		:= arch/s390/kernel/head.o
-head-y		+= arch/s390/kernel/$(if $(CONFIG_64BIT),head64.o,head31.o)
+head-y		+= arch/s390/kernel/head64.o
 
 # See arch/s390/Kbuild for content of core part of the kernel
 core-y		+= arch/s390/
@@ -129,9 +117,7 @@ zfcpdump:
 	$(Q)$(MAKE) $(build)=$(boot) $(boot)/$@
 
 vdso_install:
-ifeq ($(CONFIG_64BIT),y)
 	$(Q)$(MAKE) $(build)=arch/$(ARCH)/kernel/vdso64 $@
-endif
 	$(Q)$(MAKE) $(build)=arch/$(ARCH)/kernel/vdso32 $@
 
 archclean:
* Unmerged path arch/s390/boot/compressed/Makefile
diff --git a/arch/s390/boot/compressed/head31.S b/arch/s390/boot/compressed/head31.S
deleted file mode 100644
index e8c9e18b8039..000000000000
--- a/arch/s390/boot/compressed/head31.S
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Startup glue code to uncompress the kernel
- *
- * Copyright IBM Corp. 2010
- *
- *   Author(s):	Martin Schwidefsky <schwidefsky@de.ibm.com>
- */
-
-#include <linux/init.h>
-#include <linux/linkage.h>
-#include <asm/asm-offsets.h>
-#include <asm/thread_info.h>
-#include <asm/page.h>
-#include "sizes.h"
-
-__HEAD
-ENTRY(startup_continue)
-	basr	%r13,0			# get base
-.LPG1:
-	# setup stack
-	l	%r15,.Lstack-.LPG1(%r13)
-	ahi	%r15,-96
-	l	%r1,.Ldecompress-.LPG1(%r13)
-	basr	%r14,%r1
-	# setup registers for memory mover & branch to target
-	lr	%r4,%r2
-	l	%r2,.Loffset-.LPG1(%r13)
-	la	%r4,0(%r2,%r4)
-	l	%r3,.Lmvsize-.LPG1(%r13)
-	lr	%r5,%r3
-	# move the memory mover someplace safe
-	la	%r1,0x200
-	mvc	0(mover_end-mover,%r1),mover-.LPG1(%r13)
-	# decompress image is started at 0x11000
-	lr	%r6,%r2
-	br	%r1
-mover:
-	mvcle	%r2,%r4,0
-	jo	mover
-	br	%r6
-mover_end:
-
-	.align	8
-.Lstack:
-	.long	0x8000 + (1<<(PAGE_SHIFT+THREAD_ORDER))
-.Ldecompress:
-	.long	decompress_kernel
-.Loffset:
-	.long	0x11000
-.Lmvsize:
-	.long	SZ__bss_start
diff --git a/arch/s390/boot/compressed/vmlinux.lds.S b/arch/s390/boot/compressed/vmlinux.lds.S
index 8e1fb8239287..747735f83426 100644
--- a/arch/s390/boot/compressed/vmlinux.lds.S
+++ b/arch/s390/boot/compressed/vmlinux.lds.S
@@ -1,12 +1,7 @@
 #include <asm-generic/vmlinux.lds.h>
 
-#ifdef CONFIG_64BIT
 OUTPUT_FORMAT("elf64-s390", "elf64-s390", "elf64-s390")
 OUTPUT_ARCH(s390:64-bit)
-#else
-OUTPUT_FORMAT("elf32-s390", "elf32-s390", "elf32-s390")
-OUTPUT_ARCH(s390:31-bit)
-#endif
 
 ENTRY(startup)
 
diff --git a/arch/s390/hypfs/hypfs_diag0c.c b/arch/s390/hypfs/hypfs_diag0c.c
index d4c0d3717543..24c747a0fcc3 100644
--- a/arch/s390/hypfs/hypfs_diag0c.c
+++ b/arch/s390/hypfs/hypfs_diag0c.c
@@ -19,13 +19,9 @@
 static void diag0c(struct hypfs_diag0c_entry *entry)
 {
 	asm volatile (
-#ifdef CONFIG_64BIT
 		"	sam31\n"
 		"	diag	%0,%0,0x0c\n"
 		"	sam64\n"
-#else
-		"	diag %0,%0,0x0c\n"
-#endif
 		: /* no output register */
 		: "a" (entry)
 		: "memory");
diff --git a/arch/s390/include/asm/appldata.h b/arch/s390/include/asm/appldata.h
index 32a705987156..16887c5fd989 100644
--- a/arch/s390/include/asm/appldata.h
+++ b/arch/s390/include/asm/appldata.h
@@ -9,28 +9,6 @@
 
 #include <asm/io.h>
 
-#ifndef CONFIG_64BIT
-
-#define APPLDATA_START_INTERVAL_REC	0x00	/* Function codes for */
-#define APPLDATA_STOP_REC		0x01	/* DIAG 0xDC	      */
-#define APPLDATA_GEN_EVENT_REC		0x02
-#define APPLDATA_START_CONFIG_REC	0x03
-
-/*
- * Parameter list for DIAGNOSE X'DC'
- */
-struct appldata_parameter_list {
-	u16 diag;		/* The DIAGNOSE code X'00DC'	      */
-	u8  function;		/* The function code for the DIAGNOSE */
-	u8  parlist_length;	/* Length of the parameter list       */
-	u32 product_id_addr;	/* Address of the 16-byte product ID  */
-	u16 reserved;
-	u16 buffer_length;	/* Length of the application data buffer  */
-	u32 buffer_addr;	/* Address of the application data buffer */
-} __attribute__ ((packed));
-
-#else /* CONFIG_64BIT */
-
 #define APPLDATA_START_INTERVAL_REC	0x80
 #define APPLDATA_STOP_REC		0x81
 #define APPLDATA_GEN_EVENT_REC		0x82
@@ -51,8 +29,6 @@ struct appldata_parameter_list {
 	u64 buffer_addr;
 } __attribute__ ((packed));
 
-#endif /* CONFIG_64BIT */
-
 struct appldata_product_id {
 	char prod_nr[7];	/* product number */
 	u16  prod_fn;		/* product function */
* Unmerged path arch/s390/include/asm/atomic.h
* Unmerged path arch/s390/include/asm/bitops.h
* Unmerged path arch/s390/include/asm/cputime.h
* Unmerged path arch/s390/include/asm/ctl_reg.h
diff --git a/arch/s390/include/asm/elf.h b/arch/s390/include/asm/elf.h
index acb5598e81db..bb3555cabfa5 100644
--- a/arch/s390/include/asm/elf.h
+++ b/arch/s390/include/asm/elf.h
@@ -113,11 +113,7 @@
 /*
  * These are used to set parameters in the core dumps.
  */
-#ifndef CONFIG_64BIT
-#define ELF_CLASS	ELFCLASS32
-#else /* CONFIG_64BIT */
 #define ELF_CLASS	ELFCLASS64
-#endif /* CONFIG_64BIT */
 #define ELF_DATA	ELFDATA2MSB
 #define ELF_ARCH	EM_S390
 
diff --git a/arch/s390/include/asm/idals.h b/arch/s390/include/asm/idals.h
index ea5a6e45fd93..a7b2d7504049 100644
--- a/arch/s390/include/asm/idals.h
+++ b/arch/s390/include/asm/idals.h
@@ -19,11 +19,7 @@
 #include <asm/cio.h>
 #include <asm/uaccess.h>
 
-#ifdef CONFIG_64BIT
 #define IDA_SIZE_LOG 12 /* 11 for 2k , 12 for 4k */
-#else
-#define IDA_SIZE_LOG 11 /* 11 for 2k , 12 for 4k */
-#endif
 #define IDA_BLOCK_SIZE (1L<<IDA_SIZE_LOG)
 
 /*
@@ -32,11 +28,7 @@
 static inline int
 idal_is_needed(void *vaddr, unsigned int length)
 {
-#ifdef CONFIG_64BIT
 	return ((__pa(vaddr) + length - 1) >> 31) != 0;
-#else
-	return 0;
-#endif
 }
 
 
@@ -77,7 +69,6 @@ static inline unsigned long *idal_create_words(unsigned long *idaws,
 static inline int
 set_normalized_cda(struct ccw1 * ccw, void *vaddr)
 {
-#ifdef CONFIG_64BIT
 	unsigned int nridaws;
 	unsigned long *idal;
 
@@ -93,7 +84,6 @@ set_normalized_cda(struct ccw1 * ccw, void *vaddr)
 		ccw->flags |= CCW_FLAG_IDA;
 		vaddr = idal;
 	}
-#endif
 	ccw->cda = (__u32)(unsigned long) vaddr;
 	return 0;
 }
@@ -104,12 +94,10 @@ set_normalized_cda(struct ccw1 * ccw, void *vaddr)
 static inline void
 clear_normalized_cda(struct ccw1 * ccw)
 {
-#ifdef CONFIG_64BIT
 	if (ccw->flags & CCW_FLAG_IDA) {
 		kfree((void *)(unsigned long) ccw->cda);
 		ccw->flags &= ~CCW_FLAG_IDA;
 	}
-#endif
 	ccw->cda = 0;
 }
 
@@ -181,12 +169,8 @@ idal_buffer_free(struct idal_buffer *ib)
 static inline int
 __idal_buffer_is_needed(struct idal_buffer *ib)
 {
-#ifdef CONFIG_64BIT
 	return ib->size > (4096ul << ib->page_order) ||
 		idal_is_needed(ib->data[0], ib->size);
-#else
-	return ib->size > (4096ul << ib->page_order);
-#endif
 }
 
 /*
* Unmerged path arch/s390/include/asm/jump_label.h
* Unmerged path arch/s390/include/asm/lowcore.h
* Unmerged path arch/s390/include/asm/mman.h
* Unmerged path arch/s390/include/asm/mmu_context.h
* Unmerged path arch/s390/include/asm/percpu.h
diff --git a/arch/s390/include/asm/perf_event.h b/arch/s390/include/asm/perf_event.h
index a3584555f968..7c9edfc2e0ae 100644
--- a/arch/s390/include/asm/perf_event.h
+++ b/arch/s390/include/asm/perf_event.h
@@ -9,8 +9,6 @@
 #ifndef _ASM_S390_PERF_EVENT_H
 #define _ASM_S390_PERF_EVENT_H
 
-#ifdef CONFIG_64BIT
-
 #include <linux/perf_event.h>
 #include <linux/device.h>
 #include <asm/cpu_mf.h>
@@ -94,5 +92,4 @@ struct sf_raw_sample {
 int perf_reserve_sampling(void);
 void perf_release_sampling(void);
 
-#endif /* CONFIG_64BIT */
 #endif /* _ASM_S390_PERF_EVENT_H */
diff --git a/arch/s390/include/asm/pgalloc.h b/arch/s390/include/asm/pgalloc.h
index 9eb1f209d7ee..cb4fc4c30536 100644
--- a/arch/s390/include/asm/pgalloc.h
+++ b/arch/s390/include/asm/pgalloc.h
@@ -32,11 +32,7 @@ static inline void clear_table(unsigned long *s, unsigned long val, size_t n)
 	*s = val;
 	n = (n / 256) - 1;
 	asm volatile(
-#ifdef CONFIG_64BIT
 		"	mvc	8(248,%0),0(%0)\n"
-#else
-		"	mvc	4(252,%0),0(%0)\n"
-#endif
 		"0:	mvc	256(256,%0),0(%0)\n"
 		"	la	%0,256(%0)\n"
 		"	brct	%1,0b\n"
@@ -49,24 +45,6 @@ static inline void crst_table_init(unsigned long *crst, unsigned long entry)
 	clear_table(crst, entry, sizeof(unsigned long)*2048);
 }
 
-#ifndef CONFIG_64BIT
-
-static inline unsigned long pgd_entry_type(struct mm_struct *mm)
-{
-	return _SEGMENT_ENTRY_EMPTY;
-}
-
-#define pud_alloc_one(mm,address)		({ BUG(); ((pud_t *)2); })
-#define pud_free(mm, x)				do { } while (0)
-
-#define pmd_alloc_one(mm,address)		({ BUG(); ((pmd_t *)2); })
-#define pmd_free(mm, x)				do { } while (0)
-
-#define pgd_populate(mm, pgd, pud)		BUG()
-#define pud_populate(mm, pud, pmd)		BUG()
-
-#else /* CONFIG_64BIT */
-
 static inline unsigned long pgd_entry_type(struct mm_struct *mm)
 {
 	if (mm->context.asce_limit <= (1UL << 31))
@@ -107,8 +85,6 @@ static inline void pud_populate(struct mm_struct *mm, pud_t *pud, pmd_t *pmd)
 	pud_val(*pud) = _REGION3_ENTRY | __pa(pmd);
 }
 
-#endif /* CONFIG_64BIT */
-
 static inline pgd_t *pgd_alloc(struct mm_struct *mm)
 {
 	spin_lock_init(&mm->context.list_lock);
* Unmerged path arch/s390/include/asm/pgtable.h
* Unmerged path arch/s390/include/asm/processor.h
diff --git a/arch/s390/include/asm/ptrace.h b/arch/s390/include/asm/ptrace.h
index 59eb3278c81b..68064bd64d14 100644
--- a/arch/s390/include/asm/ptrace.h
+++ b/arch/s390/include/asm/ptrace.h
@@ -34,12 +34,8 @@ struct psw_bits {
 	unsigned long long ri	: 1; /* Runtime Instrumentation */
 	unsigned long long	: 6;
 	unsigned long long eaba : 2; /* Addressing Mode */
-#ifdef CONFIG_64BIT
 	unsigned long long	: 31;
 	unsigned long long ia	: 64;/* Instruction Address */
-#else
-	unsigned long long ia	: 31;/* Instruction Address */
-#endif
 };
 
 enum {
diff --git a/arch/s390/include/asm/qdio.h b/arch/s390/include/asm/qdio.h
index bc3a4272d9f3..a0177e405e20 100644
--- a/arch/s390/include/asm/qdio.h
+++ b/arch/s390/include/asm/qdio.h
@@ -211,11 +211,6 @@ struct qdio_buffer_element {
 	u8 scount;
 	u8 sflags;
 	u32 length;
-#ifdef CONFIG_32BIT
-	/* private: */
-	void *res2;
-	/* public: */
-#endif
 	void *addr;
 } __attribute__ ((packed, aligned(16)));
 
@@ -232,11 +227,6 @@ struct qdio_buffer {
  * @sbal: absolute SBAL address
  */
 struct sl_element {
-#ifdef CONFIG_32BIT
-	/* private: */
-	unsigned long reserved;
-	/* public: */
-#endif
 	unsigned long sbal;
 } __attribute__ ((packed));
 
diff --git a/arch/s390/include/asm/runtime_instr.h b/arch/s390/include/asm/runtime_instr.h
index 830da737ff85..402ad6df4897 100644
--- a/arch/s390/include/asm/runtime_instr.h
+++ b/arch/s390/include/asm/runtime_instr.h
@@ -72,27 +72,19 @@ static inline void store_runtime_instr_cb(struct runtime_instr_cb *cb)
 
 static inline void save_ri_cb(struct runtime_instr_cb *cb_prev)
 {
-#ifdef CONFIG_64BIT
 	if (cb_prev)
 		store_runtime_instr_cb(cb_prev);
-#endif
 }
 
 static inline void restore_ri_cb(struct runtime_instr_cb *cb_next,
 				 struct runtime_instr_cb *cb_prev)
 {
-#ifdef CONFIG_64BIT
 	if (cb_next)
 		load_runtime_instr_cb(cb_next);
 	else if (cb_prev)
 		load_runtime_instr_cb(&runtime_instr_empty_cb);
-#endif
 }
 
-#ifdef CONFIG_64BIT
-extern void exit_thread_runtime_instr(void);
-#else
-static inline void exit_thread_runtime_instr(void) { }
-#endif
+void exit_thread_runtime_instr(void);
 
 #endif /* _RUNTIME_INSTR_H */
* Unmerged path arch/s390/include/asm/rwsem.h
* Unmerged path arch/s390/include/asm/setup.h
diff --git a/arch/s390/include/asm/sfp-util.h b/arch/s390/include/asm/sfp-util.h
index 5959bfb3b693..c8b7cf9d6279 100644
--- a/arch/s390/include/asm/sfp-util.h
+++ b/arch/s390/include/asm/sfp-util.h
@@ -51,7 +51,6 @@
 	wl = __wl;					\
 })
 
-#ifdef CONFIG_64BIT
 #define udiv_qrnnd(q, r, n1, n0, d)			\
   do { unsigned long __n;				\
        unsigned int __r, __d;				\
@@ -60,15 +59,6 @@
     (q) = __n / __d;					\
     (r) = __n % __d;					\
   } while (0)
-#else
-#define udiv_qrnnd(q, r, n1, n0, d)			\
-  do { unsigned int __r;				\
-    (q) = __udiv_qrnnd (&__r, (n1), (n0), (d));		\
-    (r) = __r;						\
-  } while (0)
-extern unsigned long __udiv_qrnnd (unsigned int *, unsigned int,
-				   unsigned int , unsigned int);
-#endif
 
 #define UDIV_NEEDS_NORMALIZATION 0
 
diff --git a/arch/s390/include/asm/sparsemem.h b/arch/s390/include/asm/sparsemem.h
index a60d085ddb4d..487428b6d099 100644
--- a/arch/s390/include/asm/sparsemem.h
+++ b/arch/s390/include/asm/sparsemem.h
@@ -1,16 +1,7 @@
 #ifndef _ASM_S390_SPARSEMEM_H
 #define _ASM_S390_SPARSEMEM_H
 
-#ifdef CONFIG_64BIT
-
 #define SECTION_SIZE_BITS	28
 #define MAX_PHYSMEM_BITS	46
 
-#else
-
-#define SECTION_SIZE_BITS	25
-#define MAX_PHYSMEM_BITS	31
-
-#endif /* CONFIG_64BIT */
-
 #endif /* _ASM_S390_SPARSEMEM_H */
diff --git a/arch/s390/include/asm/switch_to.h b/arch/s390/include/asm/switch_to.h
index 68c9a0d2ea0a..a7eea455bc23 100644
--- a/arch/s390/include/asm/switch_to.h
+++ b/arch/s390/include/asm/switch_to.h
@@ -18,9 +18,6 @@ static inline int test_fp_ctl(u32 fpc)
 	u32 orig_fpc;
 	int rc;
 
-	if (!MACHINE_HAS_IEEE)
-		return 0;
-
 	asm volatile(
 		"	efpc    %1\n"
 		"	sfpc	%2\n"
@@ -35,9 +32,6 @@ static inline int test_fp_ctl(u32 fpc)
 
 static inline void save_fp_ctl(u32 *fpc)
 {
-	if (!MACHINE_HAS_IEEE)
-		return;
-
 	asm volatile(
 		"       stfpc   %0\n"
 		: "+Q" (*fpc));
@@ -47,9 +41,6 @@ static inline int restore_fp_ctl(u32 *fpc)
 {
 	int rc;
 
-	if (!MACHINE_HAS_IEEE)
-		return 0;
-
 	asm volatile(
 		"	lfpc    %1\n"
 		"0:	la	%0,0\n"
@@ -65,8 +56,6 @@ static inline void save_fp_regs(freg_t *fprs)
 	asm volatile("std 2,%0" : "=Q" (fprs[2]));
 	asm volatile("std 4,%0" : "=Q" (fprs[4]));
 	asm volatile("std 6,%0" : "=Q" (fprs[6]));
-	if (!MACHINE_HAS_IEEE)
-		return;
 	asm volatile("std 1,%0" : "=Q" (fprs[1]));
 	asm volatile("std 3,%0" : "=Q" (fprs[3]));
 	asm volatile("std 5,%0" : "=Q" (fprs[5]));
@@ -87,8 +76,6 @@ static inline void restore_fp_regs(freg_t *fprs)
 	asm volatile("ld 2,%0" : : "Q" (fprs[2]));
 	asm volatile("ld 4,%0" : : "Q" (fprs[4]));
 	asm volatile("ld 6,%0" : : "Q" (fprs[6]));
-	if (!MACHINE_HAS_IEEE)
-		return;
 	asm volatile("ld 1,%0" : : "Q" (fprs[1]));
 	asm volatile("ld 3,%0" : : "Q" (fprs[3]));
 	asm volatile("ld 5,%0" : : "Q" (fprs[5]));
@@ -140,22 +127,18 @@ static inline void restore_vx_regs(__vector128 *vxrs)
 
 static inline void save_fp_vx_regs(struct task_struct *task)
 {
-#ifdef CONFIG_64BIT
 	if (task->thread.vxrs)
 		save_vx_regs(task->thread.vxrs);
 	else
-#endif
-	save_fp_regs(task->thread.fp_regs.fprs);
+		save_fp_regs(task->thread.fp_regs.fprs);
 }
 
 static inline void restore_fp_vx_regs(struct task_struct *task)
 {
-#ifdef CONFIG_64BIT
 	if (task->thread.vxrs)
 		restore_vx_regs(task->thread.vxrs);
 	else
-#endif
-	restore_fp_regs(task->thread.fp_regs.fprs);
+		restore_fp_regs(task->thread.fp_regs.fprs);
 }
 
 static inline void save_access_regs(unsigned int *acrs)
diff --git a/arch/s390/include/asm/thread_info.h b/arch/s390/include/asm/thread_info.h
index 0997be6be9fa..22730286706b 100644
--- a/arch/s390/include/asm/thread_info.h
+++ b/arch/s390/include/asm/thread_info.h
@@ -10,13 +10,8 @@
 /*
  * Size of kernel stack for each process
  */
-#ifndef CONFIG_64BIT
-#define THREAD_ORDER 1
-#define ASYNC_ORDER  1
-#else /* CONFIG_64BIT */
 #define THREAD_ORDER 2
 #define ASYNC_ORDER  2
-#endif /* CONFIG_64BIT */
 
 #define THREAD_SIZE (PAGE_SIZE << THREAD_ORDER)
 #define ASYNC_SIZE  (PAGE_SIZE << ASYNC_ORDER)
@@ -116,11 +111,7 @@ static inline struct thread_info *current_thread_info(void)
 #define _TIF_SINGLE_STEP	(1<<TIF_SINGLE_STEP)
 #define _TIF_GUARDED_STORAGE	(1<<TIF_GUARDED_STORAGE)
 
-#ifdef CONFIG_64BIT
 #define is_32bit_task()		(test_thread_flag(TIF_31BIT))
-#else
-#define is_32bit_task()		(1)
-#endif
 
 #define PREEMPT_ACTIVE		0x4000000
 
* Unmerged path arch/s390/include/asm/tlb.h
* Unmerged path arch/s390/include/asm/tlbflush.h
diff --git a/arch/s390/include/asm/types.h b/arch/s390/include/asm/types.h
index dccef3ca91fa..6740f4f9781f 100644
--- a/arch/s390/include/asm/types.h
+++ b/arch/s390/include/asm/types.h
@@ -8,21 +8,4 @@
 
 #include <uapi/asm/types.h>
 
-/*
- * These aren't exported outside the kernel to avoid name space clashes
- */
-
-#ifndef __ASSEMBLY__
-
-#ifndef CONFIG_64BIT
-typedef union {
-	unsigned long long pair;
-	struct {
-		unsigned long even;
-		unsigned long odd;
-	} subreg;
-} register_pair;
-
-#endif /* ! CONFIG_64BIT   */
-#endif /* __ASSEMBLY__  */
 #endif /* _S390_TYPES_H */
* Unmerged path arch/s390/include/asm/unistd.h
diff --git a/arch/s390/include/asm/vdso.h b/arch/s390/include/asm/vdso.h
index bc9746a7d47c..6342a8c79af2 100644
--- a/arch/s390/include/asm/vdso.h
+++ b/arch/s390/include/asm/vdso.h
@@ -38,10 +38,8 @@ struct vdso_per_cpu_data {
 
 extern struct vdso_data *vdso_data;
 
-#ifdef CONFIG_64BIT
 int vdso_alloc_per_cpu(struct _lowcore *lowcore);
 void vdso_free_per_cpu(struct _lowcore *lowcore);
-#endif
 
 #endif /* __ASSEMBLY__ */
 #endif /* __S390_VDSO_H__ */
* Unmerged path arch/s390/kernel/Makefile
* Unmerged path arch/s390/kernel/asm-offsets.c
* Unmerged path arch/s390/kernel/base.S
* Unmerged path arch/s390/kernel/cpcmd.c
diff --git a/arch/s390/kernel/diag.c b/arch/s390/kernel/diag.c
index 55dee28dda39..0da13e24ebab 100644
--- a/arch/s390/kernel/diag.c
+++ b/arch/s390/kernel/diag.c
@@ -18,13 +18,9 @@ int diag14(unsigned long rx, unsigned long ry1, unsigned long subcode)
 	int rc = 0;
 
 	asm volatile(
-#ifdef CONFIG_64BIT
 		"   sam31\n"
 		"   diag    %2,2,0x14\n"
 		"   sam64\n"
-#else
-		"   diag    %2,2,0x14\n"
-#endif
 		"   ipm     %0\n"
 		"   srl     %0,28\n"
 		: "=d" (rc), "+d" (_ry2)
@@ -73,7 +69,6 @@ int diag210(struct diag210 *addr)
 	spin_lock_irqsave(&diag210_lock, flags);
 	diag210_tmp = *addr;
 
-#ifdef CONFIG_64BIT
 	asm volatile(
 		"	lhi	%0,-1\n"
 		"	sam31\n"
@@ -83,16 +78,6 @@ int diag210(struct diag210 *addr)
 		"1:	sam64\n"
 		EX_TABLE(0b, 1b)
 		: "=&d" (ccode) : "a" (&diag210_tmp) : "cc", "memory");
-#else
-	asm volatile(
-		"	lhi	%0,-1\n"
-		"	diag	%1,0,0x210\n"
-		"0:	ipm	%0\n"
-		"	srl	%0,28\n"
-		"1:\n"
-		EX_TABLE(0b, 1b)
-		: "=&d" (ccode) : "a" (&diag210_tmp) : "cc", "memory");
-#endif
 
 	*addr = diag210_tmp;
 	spin_unlock_irqrestore(&diag210_lock, flags);
* Unmerged path arch/s390/kernel/dis.c
* Unmerged path arch/s390/kernel/dumpstack.c
* Unmerged path arch/s390/kernel/early.c
* Unmerged path arch/s390/kernel/entry.S
diff --git a/arch/s390/kernel/head.S b/arch/s390/kernel/head.S
index 8ae133e103c5..f16ae4691c79 100644
--- a/arch/s390/kernel/head.S
+++ b/arch/s390/kernel/head.S
@@ -27,11 +27,7 @@
 #include <asm/thread_info.h>
 #include <asm/page.h>
 
-#ifdef CONFIG_64BIT
 #define ARCH_OFFSET	4
-#else
-#define ARCH_OFFSET	0
-#endif
 
 __HEAD
 
@@ -67,7 +63,6 @@ __HEAD
 # subroutine to set architecture mode
 #
 .Lsetmode:
-#ifdef CONFIG_64BIT
 	mvi	__LC_AR_MODE_ID,1	# set esame flag
 	slr	%r0,%r0 		# set cpuid to zero
 	lhi	%r1,2			# mode 2 = esame (dump)
@@ -76,16 +71,12 @@ __HEAD
 	.fill	16,4,0x0
 0:	lmh	%r0,%r15,0(%r13)	# clear high-order half of gprs
 	sam31				# switch to 31 bit addressing mode
-#else
-	mvi	__LC_AR_MODE_ID,0	# set ESA flag (mode 0)
-#endif
 	br	%r14
 
 #
 # subroutine to wait for end I/O
 #
 .Lirqwait:
-#ifdef CONFIG_64BIT
 	mvc	0x1f0(16),.Lnewpsw	# set up IO interrupt psw
 	lpsw	.Lwaitpsw
 .Lioint:
@@ -93,15 +84,6 @@ __HEAD
 	.align	8
 .Lnewpsw:
 	.quad	0x0000000080000000,.Lioint
-#else
-	mvc	0x78(8),.Lnewpsw	# set up IO interrupt psw
-	lpsw	.Lwaitpsw
-.Lioint:
-	br	%r14
-	.align	8
-.Lnewpsw:
-	.long	0x00080000,0x80000000+.Lioint
-#endif
 .Lwaitpsw:
 	.long	0x020a0000,0x80000000+.Lioint
 
@@ -375,7 +357,6 @@ ENTRY(startup)
 ENTRY(startup_kdump)
 	j	.Lep_startup_kdump
 .Lep_startup_normal:
-#ifdef CONFIG_64BIT
 	mvi	__LC_AR_MODE_ID,1	# set esame flag
 	slr	%r0,%r0 		# set cpuid to zero
 	lhi	%r1,2			# mode 2 = esame (dump)
@@ -384,9 +365,6 @@ ENTRY(startup_kdump)
 	.fill	16,4,0x0
 0:	lmh	%r0,%r15,0(%r13)	# clear high-order half of gprs
 	sam31				# switch to 31 bit addressing mode
-#else
-	mvi	__LC_AR_MODE_ID,0	# set ESA flag (mode 0)
-#endif
 	basr	%r13,0			# get base
 .LPG0:
 	xc	0x200(256),0x200	# partially clear lowcore
@@ -396,7 +374,6 @@ ENTRY(startup_kdump)
 	spt	6f-.LPG0(%r13)
 	mvc	__LC_LAST_UPDATE_TIMER(8),6f-.LPG0(%r13)
 	xc	__LC_STFL_FAC_LIST(8),__LC_STFL_FAC_LIST
-#ifndef CONFIG_MARCH_G5
 	# check capabilities against MARCH_{G5,Z900,Z990,Z9_109,Z10}
 	.insn	s,0xb2b10000,__LC_STFL_FAC_LIST	# store facility list
 	tm	__LC_STFL_FAC_LIST,0x01	# stfle available ?
@@ -435,7 +412,6 @@ ENTRY(startup_kdump)
 # the kernel will crash. Format is number of facility words with bits set,
 # followed by the facility words.
 
-#if defined(CONFIG_64BIT)
 #if defined(CONFIG_MARCH_Z13)
 	.long 3, 0xc100eff2, 0xf46ce800, 0x00400000
 #elif defined(CONFIG_MARCH_ZEC12)
@@ -451,35 +427,10 @@ ENTRY(startup_kdump)
 #elif defined(CONFIG_MARCH_Z900)
 	.long 1, 0xc0000000
 #endif
-#else
-#if defined(CONFIG_MARCH_ZEC12)
-	.long 1, 0x8100c880
-#elif defined(CONFIG_MARCH_Z196)
-	.long 1, 0x8100c880
-#elif defined(CONFIG_MARCH_Z10)
-	.long 1, 0x8100c880
-#elif defined(CONFIG_MARCH_Z9_109)
-	.long 1, 0x8100c880
-#elif defined(CONFIG_MARCH_Z990)
-	.long 1, 0x80002000
-#elif defined(CONFIG_MARCH_Z900)
-	.long 1, 0x80000000
-#endif
-#endif
 4:
-#endif
-
-#ifdef CONFIG_64BIT
 	/* Continue with 64bit startup code in head64.S */
 	sam64				# switch to 64 bit mode
 	jg	startup_continue
-#else
-	/* Continue with 31bit startup code in head31.S */
-	l	%r13,5f-.LPG0(%r13)
-	b	0(%r13)
-	.align	8
-5:	.long	startup_continue
-#endif
 
 	.align	8
 6:	.long	0x7fffffff,0xffffffff
* Unmerged path arch/s390/kernel/head31.S
diff --git a/arch/s390/kernel/head_kdump.S b/arch/s390/kernel/head_kdump.S
index 085a95eb315f..d05950f02c34 100644
--- a/arch/s390/kernel/head_kdump.S
+++ b/arch/s390/kernel/head_kdump.S
@@ -92,17 +92,9 @@ startup_kdump_relocated:
 #else
 .align 2
 .Lep_startup_kdump:
-#ifdef CONFIG_64BIT
 	larl	%r13,startup_kdump_crash
 	lpswe	0(%r13)
 .align 8
 startup_kdump_crash:
 	.quad	0x0002000080000000,0x0000000000000000 + startup_kdump_crash
-#else
-	basr	%r13,0
-0:	lpsw	startup_kdump_crash-0b(%r13)
-.align 8
-startup_kdump_crash:
-	.long	0x000a0000,0x00000000 + startup_kdump_crash
-#endif /* CONFIG_64BIT */
 #endif /* CONFIG_CRASH_DUMP */
diff --git a/arch/s390/kernel/ipl.c b/arch/s390/kernel/ipl.c
index 579fadf9e63f..d73737b4dffc 100644
--- a/arch/s390/kernel/ipl.c
+++ b/arch/s390/kernel/ipl.c
@@ -1990,12 +1990,10 @@ static void do_reset_calls(void)
 {
 	struct reset_call *reset;
 
-#ifdef CONFIG_64BIT
 	if (diag308_set_works) {
 		diag308_reset();
 		return;
 	}
-#endif
 	list_for_each_entry(reset, &rcall, list)
 		reset->fn();
 }
* Unmerged path arch/s390/kernel/module.c
diff --git a/arch/s390/kernel/nmi.c b/arch/s390/kernel/nmi.c
index 641893ed337e..4977c045c39c 100644
--- a/arch/s390/kernel/nmi.c
+++ b/arch/s390/kernel/nmi.c
@@ -119,55 +119,36 @@ static int notrace s390_revalidate_registers(struct mci *mci)
 		 */
 		kill_task = 1;
 	}
-#ifndef CONFIG_64BIT
+	fpt_save_area = &S390_lowcore.floating_pt_save_area;
+	fpt_creg_save_area = &S390_lowcore.fpt_creg_save_area;
+	if (!mci->fc) {
+		/*
+		 * Floating point control register can't be restored.
+		 * Task will be terminated.
+		 */
+		asm volatile("lfpc 0(%0)" : : "a" (&zero), "m" (zero));
+		kill_task = 1;
+	} else
+		asm volatile("lfpc 0(%0)" : : "a" (fpt_creg_save_area));
+
 	asm volatile(
 		"	ld	0,0(%0)\n"
-		"	ld	2,8(%0)\n"
-		"	ld	4,16(%0)\n"
-		"	ld	6,24(%0)"
-		: : "a" (&S390_lowcore.floating_pt_save_area));
-#endif
-
-	if (MACHINE_HAS_IEEE) {
-#ifdef CONFIG_64BIT
-		fpt_save_area = &S390_lowcore.floating_pt_save_area;
-		fpt_creg_save_area = &S390_lowcore.fpt_creg_save_area;
-#else
-		fpt_save_area = (void *) S390_lowcore.extended_save_area_addr;
-		fpt_creg_save_area = fpt_save_area + 128;
-#endif
-		if (!mci->fc) {
-			/*
-			 * Floating point control register can't be restored.
-			 * Task will be terminated.
-			 */
-			asm volatile("lfpc 0(%0)" : : "a" (&zero), "m" (zero));
-			kill_task = 1;
-
-		} else
-			asm volatile("lfpc 0(%0)" : : "a" (fpt_creg_save_area));
-
-		asm volatile(
-			"	ld	0,0(%0)\n"
-			"	ld	1,8(%0)\n"
-			"	ld	2,16(%0)\n"
-			"	ld	3,24(%0)\n"
-			"	ld	4,32(%0)\n"
-			"	ld	5,40(%0)\n"
-			"	ld	6,48(%0)\n"
-			"	ld	7,56(%0)\n"
-			"	ld	8,64(%0)\n"
-			"	ld	9,72(%0)\n"
-			"	ld	10,80(%0)\n"
-			"	ld	11,88(%0)\n"
-			"	ld	12,96(%0)\n"
-			"	ld	13,104(%0)\n"
-			"	ld	14,112(%0)\n"
-			"	ld	15,120(%0)\n"
-			: : "a" (fpt_save_area));
-	}
-
-#ifdef CONFIG_64BIT
+		"	ld	1,8(%0)\n"
+		"	ld	2,16(%0)\n"
+		"	ld	3,24(%0)\n"
+		"	ld	4,32(%0)\n"
+		"	ld	5,40(%0)\n"
+		"	ld	6,48(%0)\n"
+		"	ld	7,56(%0)\n"
+		"	ld	8,64(%0)\n"
+		"	ld	9,72(%0)\n"
+		"	ld	10,80(%0)\n"
+		"	ld	11,88(%0)\n"
+		"	ld	12,96(%0)\n"
+		"	ld	13,104(%0)\n"
+		"	ld	14,112(%0)\n"
+		"	ld	15,120(%0)\n"
+		: : "a" (fpt_save_area));
 	/* Revalidate vector registers */
 	mcesa = (struct mcesa *)(S390_lowcore.mcesad & MCESA_ORIGIN_MASK);
 	if (MACHINE_HAS_VX) {
@@ -186,7 +167,6 @@ static int notrace s390_revalidate_registers(struct mci *mci)
 		restore_vx_regs((__vector128 *) &mcesa->vector_save_area);
 		__ctl_load(S390_lowcore.cregs_save_area[0], 0, 0);
 	}
-#endif
 	/* Revalidate access registers */
 	asm volatile(
 		"	lam	0,15,0(%0)"
@@ -206,15 +186,9 @@ static int notrace s390_revalidate_registers(struct mci *mci)
 		 */
 		s390_handle_damage("invalid control registers.");
 	} else {
-#ifdef CONFIG_64BIT
 		asm volatile(
 			"	lctlg	0,15,0(%0)"
 			: : "a" (&S390_lowcore.cregs_save_area));
-#else
-		asm volatile(
-			"	lctl	0,15,0(%0)"
-			: : "a" (&S390_lowcore.cregs_save_area));
-#endif
 	}
 	/* Validate guarded storage registers */
 	if (MACHINE_HAS_GS && (S390_lowcore.cregs_save_area[2] & (1UL << 4))) {
@@ -233,7 +207,6 @@ static int notrace s390_revalidate_registers(struct mci *mci)
 	 * We don't even try to revalidate the TOD register, since we simply
 	 * can't write something sensible into that register.
 	 */
-#ifdef CONFIG_64BIT
 	/*
 	 * See if we can revalidate the TOD programmable register with its
 	 * old contents (should be zero) otherwise set it to zero.
@@ -249,7 +222,6 @@ static int notrace s390_revalidate_registers(struct mci *mci)
 			"	sckpf"
 			: : "a" (&S390_lowcore.tod_progreg_save_area)
 			: "0", "cc");
-#endif
 	/* Revalidate clock comparator register */
 	if (S390_lowcore.clock_comparator == -1)
 		set_clock_comparator(S390_lowcore.mcck_clock);
@@ -304,19 +276,11 @@ void notrace s390_do_machine_check(struct pt_regs *regs)
 		if (mci->b) {
 			/* Processing backup -> verify if we can survive this */
 			u64 z_mcic, o_mcic, t_mcic;
-#ifdef CONFIG_64BIT
 			z_mcic = (1ULL<<63 | 1ULL<<59 | 1ULL<<29);
 			o_mcic = (1ULL<<43 | 1ULL<<42 | 1ULL<<41 | 1ULL<<40 |
 				  1ULL<<36 | 1ULL<<35 | 1ULL<<34 | 1ULL<<32 |
 				  1ULL<<30 | 1ULL<<21 | 1ULL<<20 | 1ULL<<17 |
 				  1ULL<<16);
-#else
-			z_mcic = (1ULL<<63 | 1ULL<<59 | 1ULL<<57 | 1ULL<<50 |
-				  1ULL<<29);
-			o_mcic = (1ULL<<43 | 1ULL<<42 | 1ULL<<41 | 1ULL<<40 |
-				  1ULL<<36 | 1ULL<<35 | 1ULL<<34 | 1ULL<<32 |
-				  1ULL<<30 | 1ULL<<20 | 1ULL<<17 | 1ULL<<16);
-#endif
 			t_mcic = *(u64 *)mci;
 
 			if (((t_mcic & z_mcic) != 0) ||
diff --git a/arch/s390/kernel/pgm_check.S b/arch/s390/kernel/pgm_check.S
index f6f8886399f6..036aa01d06a9 100644
--- a/arch/s390/kernel/pgm_check.S
+++ b/arch/s390/kernel/pgm_check.S
@@ -6,19 +6,13 @@
 
 #include <linux/linkage.h>
 
-#ifdef CONFIG_32BIT
-#define PGM_CHECK_64BIT(handler) .long default_trap_handler
-#else
-#define PGM_CHECK_64BIT(handler) .long handler
-#endif
-
 #define PGM_CHECK(handler)	.long handler
 #define PGM_CHECK_DEFAULT	PGM_CHECK(default_trap_handler)
 
 /*
  * The program check table contains exactly 128 (0x00-0x7f) entries. Each
- * line defines the 31 and/or 64 bit function to be called corresponding
- * to the program check interruption code.
+ * line defines the function to be called corresponding to the program check
+ * interruption code.
  */
 .section .rodata, "a"
 ENTRY(pgm_check_table)
@@ -46,10 +40,10 @@ PGM_CHECK_DEFAULT			/* 14 */
 PGM_CHECK(operand_exception)		/* 15 */
 PGM_CHECK_DEFAULT			/* 16 */
 PGM_CHECK_DEFAULT			/* 17 */
-PGM_CHECK_64BIT(transaction_exception)	/* 18 */
+PGM_CHECK(transaction_exception)	/* 18 */
 PGM_CHECK_DEFAULT			/* 19 */
 PGM_CHECK_DEFAULT			/* 1a */
-PGM_CHECK_64BIT(vector_exception)	/* 1b */
+PGM_CHECK(vector_exception)		/* 1b */
 PGM_CHECK(space_switch_exception)	/* 1c */
 PGM_CHECK(hfp_sqrt_exception)		/* 1d */
 PGM_CHECK_DEFAULT			/* 1e */
@@ -78,10 +72,10 @@ PGM_CHECK_DEFAULT			/* 34 */
 PGM_CHECK_DEFAULT			/* 35 */
 PGM_CHECK_DEFAULT			/* 36 */
 PGM_CHECK_DEFAULT			/* 37 */
-PGM_CHECK_64BIT(do_dat_exception)	/* 38 */
-PGM_CHECK_64BIT(do_dat_exception)	/* 39 */
-PGM_CHECK_64BIT(do_dat_exception)	/* 3a */
-PGM_CHECK_64BIT(do_dat_exception)	/* 3b */
+PGM_CHECK(do_dat_exception)		/* 38 */
+PGM_CHECK(do_dat_exception)		/* 39 */
+PGM_CHECK(do_dat_exception)		/* 3a */
+PGM_CHECK(do_dat_exception)		/* 3b */
 PGM_CHECK_DEFAULT			/* 3c */
 PGM_CHECK_DEFAULT			/* 3d */
 PGM_CHECK_DEFAULT			/* 3e */
diff --git a/arch/s390/kernel/process.c b/arch/s390/kernel/process.c
index fcaf47fbcd75..86e00e00e25b 100644
--- a/arch/s390/kernel/process.c
+++ b/arch/s390/kernel/process.c
@@ -104,13 +104,11 @@ void release_thread(struct task_struct *dead_task)
 {
 }
 
-#ifdef CONFIG_64BIT
 void arch_release_task_struct(struct task_struct *tsk)
 {
 	if (tsk->thread.vxrs)
 		kfree(tsk->thread.vxrs);
 }
-#endif
 
 int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)
 {
@@ -180,19 +178,6 @@ int copy_thread(unsigned long clone_flags, unsigned long new_stackp,
 	p->thread.gs_cb = NULL;
 	p->thread.gs_bc_cb = NULL;
 
-#ifndef CONFIG_64BIT
-	/*
-	 * save fprs to current->thread.fp_regs to merge them with
-	 * the emulated registers and then copy the result to the child.
-	 */
-	save_fp_ctl(&current->thread.fp_regs.fpc);
-	save_fp_regs(current->thread.fp_regs.fprs);
-	memcpy(&p->thread.fp_regs, &current->thread.fp_regs,
-	       sizeof(s390_fp_regs));
-	/* Set a new TLS ?  */
-	if (clone_flags & CLONE_SETTLS)
-		p->thread.acrs[0] = frame->childregs.gprs[6];
-#else /* CONFIG_64BIT */
 	/* Save the fpu registers to new thread structure. */
 	save_fp_ctl(&p->thread.fp_regs.fpc);
 	save_fp_regs(p->thread.fp_regs.fprs);
@@ -207,15 +192,13 @@ int copy_thread(unsigned long clone_flags, unsigned long new_stackp,
 			p->thread.acrs[1] = (unsigned int)tls;
 		}
 	}
-#endif /* CONFIG_64BIT */
 	return 0;
 }
 
 asmlinkage void execve_tail(void)
 {
 	current->thread.fp_regs.fpc = 0;
-	if (MACHINE_HAS_IEEE)
-		asm volatile("sfpc %0,%0" : : "d" (0));
+	asm volatile("sfpc %0,%0" : : "d" (0));
 }
 
 /*
@@ -223,18 +206,8 @@ asmlinkage void execve_tail(void)
  */
 int dump_fpu (struct pt_regs * regs, s390_fp_regs *fpregs)
 {
-#ifndef CONFIG_64BIT
-	/*
-	 * save fprs to current->thread.fp_regs to merge them with
-	 * the emulated registers and then copy the result to the dump.
-	 */
-	save_fp_ctl(&current->thread.fp_regs.fpc);
-	save_fp_regs(current->thread.fp_regs.fprs);
-	memcpy(fpregs, &current->thread.fp_regs, sizeof(s390_fp_regs));
-#else /* CONFIG_64BIT */
 	save_fp_ctl(&fpregs->fpc);
 	save_fp_regs(fpregs->fprs);
-#endif /* CONFIG_64BIT */
 	return 1;
 }
 EXPORT_SYMBOL(dump_fpu);
* Unmerged path arch/s390/kernel/ptrace.c
diff --git a/arch/s390/kernel/reipl.S b/arch/s390/kernel/reipl.S
deleted file mode 100644
index dd8016b0477e..000000000000
--- a/arch/s390/kernel/reipl.S
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- *  S390 version
- *    Copyright IBM Corp. 2000
- *    Author(s): Holger Smolinski (Holger.Smolinski@de.ibm.com)
- */
-
-#include <linux/linkage.h>
-#include <asm/asm-offsets.h>
-#include <asm/sigp.h>
-
-#
-# store_status: Empty implementation until kdump is supported on 31 bit
-#
-ENTRY(store_status)
-		br	%r14
-
-#
-# do_reipl_asm
-# Parameter: r2 = schid of reipl device
-#
-ENTRY(do_reipl_asm)
-		basr	%r13,0
-.Lpg0:		lpsw	.Lnewpsw-.Lpg0(%r13)
-.Lpg1:		# do store status of all registers
-
-		stm	%r0,%r15,__LC_GPREGS_SAVE_AREA
-		stctl	%c0,%c15,__LC_CREGS_SAVE_AREA
-		stam	%a0,%a15,__LC_AREGS_SAVE_AREA
-		l	%r10,.Ldump_pfx-.Lpg0(%r13)
-		mvc	__LC_PREFIX_SAVE_AREA(4),0(%r10)
-		stckc	.Lclkcmp-.Lpg0(%r13)
-		mvc	__LC_CLOCK_COMP_SAVE_AREA(8),.Lclkcmp-.Lpg0(%r13)
-		stpt	__LC_CPU_TIMER_SAVE_AREA
-		st	%r13, __LC_PSW_SAVE_AREA+4
-		lctl	%c6,%c6,.Lall-.Lpg0(%r13)
-		lr	%r1,%r2
-		mvc	__LC_PGM_NEW_PSW(8),.Lpcnew-.Lpg0(%r13)
-		stsch	.Lschib-.Lpg0(%r13)
-		oi	.Lschib+5-.Lpg0(%r13),0x84
-.Lecs:  	xi	.Lschib+27-.Lpg0(%r13),0x01
-		msch	.Lschib-.Lpg0(%r13)
-		lhi	%r0,5
-.Lssch:		ssch	.Liplorb-.Lpg0(%r13)
-		jz	.L001
-		brct	%r0,.Lssch
-		bas	%r14,.Ldisab-.Lpg0(%r13)
-.L001:		mvc	__LC_IO_NEW_PSW(8),.Lionew-.Lpg0(%r13)
-.Ltpi:		lpsw	.Lwaitpsw-.Lpg0(%r13)
-.Lcont:		c	%r1,__LC_SUBCHANNEL_ID
-		jnz	.Ltpi
-		clc	__LC_IO_INT_PARM(4),.Liplorb-.Lpg0(%r13)
-		jnz	.Ltpi
-		tsch	.Liplirb-.Lpg0(%r13)
-		tm	.Liplirb+9-.Lpg0(%r13),0xbf
-		jz	.L002
-		bas	%r14,.Ldisab-.Lpg0(%r13)
-.L002:		tm	.Liplirb+8-.Lpg0(%r13),0xf3
-		jz	.L003
-		bas	%r14,.Ldisab-.Lpg0(%r13)
-.L003:		st	%r1,__LC_SUBCHANNEL_ID
-		lpsw	0
-		sigp	0,0,SIGP_RESTART
-.Ldisab:	st	%r14,.Ldispsw+4-.Lpg0(%r13)
-		lpsw	.Ldispsw-.Lpg0(%r13)
-		.align	8
-.Lclkcmp:	.quad	0x0000000000000000
-.Lall:		.long	0xff000000
-.Ldump_pfx:	.long	dump_prefix_page
-		.align	8
-.Lnewpsw:	.long	0x00080000,0x80000000+.Lpg1
-.Lpcnew:	.long	0x00080000,0x80000000+.Lecs
-.Lionew:	.long	0x00080000,0x80000000+.Lcont
-.Lwaitpsw:	.long	0x020a0000,0x00000000+.Ltpi
-.Ldispsw:	.long	0x000a0000,0x00000000
-.Liplccws:	.long	0x02000000,0x60000018
-		.long	0x08000008,0x20000001
-.Liplorb:	.long	0x0049504c,0x0040ff80
-		.long	0x00000000+.Liplccws
-.Lschib:	.long	0x00000000,0x00000000
-		.long	0x00000000,0x00000000
-		.long	0x00000000,0x00000000
-		.long	0x00000000,0x00000000
-		.long	0x00000000,0x00000000
-		.long	0x00000000,0x00000000
-.Liplirb:	.long	0x00000000,0x00000000
-		.long	0x00000000,0x00000000
-		.long	0x00000000,0x00000000
-		.long	0x00000000,0x00000000
-		.long	0x00000000,0x00000000
-		.long	0x00000000,0x00000000
-		.long	0x00000000,0x00000000
-		.long	0x00000000,0x00000000
* Unmerged path arch/s390/kernel/relocate_kernel.S
diff --git a/arch/s390/kernel/sclp.S b/arch/s390/kernel/sclp.S
index 29bd7bec4176..666d29a98c30 100644
--- a/arch/s390/kernel/sclp.S
+++ b/arch/s390/kernel/sclp.S
@@ -35,21 +35,17 @@ _sclp_wait_int:
 	ahi	%r15,-96			# create stack frame
 	la	%r8,LC_EXT_NEW_PSW		# register int handler
 	la	%r9,.LextpswS1-.LbaseS1(%r13)
-#ifdef CONFIG_64BIT
 	tm	LC_AR_MODE_ID,1
 	jno	.Lesa1
 	la	%r8,LC_EXT_NEW_PSW_64		# register int handler 64 bit
 	la	%r9,.LextpswS1_64-.LbaseS1(%r13)
 .Lesa1:
-#endif
 	mvc	.LoldpswS1-.LbaseS1(16,%r13),0(%r8)
 	mvc	0(16,%r8),0(%r9)
-#ifdef CONFIG_64BIT
 	epsw	%r6,%r7				# set current addressing mode
 	nill	%r6,0x1				# in new psw (31 or 64 bit mode)
 	nilh	%r7,0x8000
 	stm	%r6,%r7,0(%r8)
-#endif
 	lhi	%r6,0x0200			# cr mask for ext int (cr0.54)
 	ltr	%r2,%r2
 	jz	.LsetctS1
@@ -91,10 +87,8 @@ _sclp_wait_int:
 	.long	0, 0, 0, 0			# old ext int PSW
 .LextpswS1:
 	.long	0x00080000, 0x80000000+.LwaitS1	# PSW to handle ext int
-#ifdef CONFIG_64BIT
 .LextpswS1_64:
 	.quad	0, .LwaitS1			# PSW to handle ext int, 64 bit
-#endif
 .LwaitpswS1:
 	.long	0x010a0000, 0x00000000+.LloopS1	# PSW to wait for ext int
 .LtimeS1:
@@ -271,13 +265,11 @@ _sclp_print:
 ENTRY(_sclp_print_early)
 	stm	%r6,%r15,24(%r15)		# save registers
 	ahi	%r15,-96			# create stack frame
-#ifdef CONFIG_64BIT
 	tm	LC_AR_MODE_ID,1
 	jno	.Lesa2
 	ahi	%r15,-80
 	stmh	%r6,%r15,96(%r15)		# store upper register halves
 .Lesa2:
-#endif
 	lr	%r10,%r2			# save string pointer
 	lhi	%r2,0
 	bras	%r14,_sclp_setup		# enable console
@@ -290,13 +282,11 @@ ENTRY(_sclp_print_early)
 	lhi	%r2,1
 	bras	%r14,_sclp_setup		# disable console
 .LendS5:
-#ifdef CONFIG_64BIT
 	tm	LC_AR_MODE_ID,1
 	jno	.Lesa3
 	lmh	%r6,%r15,96(%r15)		# store upper register halves
 	ahi	%r15,80
 .Lesa3:
-#endif
 	lm	%r6,%r15,120(%r15)		# restore registers
 	br	%r14
 
* Unmerged path arch/s390/kernel/setup.c
* Unmerged path arch/s390/kernel/signal.c
* Unmerged path arch/s390/kernel/smp.c
diff --git a/arch/s390/kernel/sys_s390.c b/arch/s390/kernel/sys_s390.c
index 23eb222c1658..f145490cce54 100644
--- a/arch/s390/kernel/sys_s390.c
+++ b/arch/s390/kernel/sys_s390.c
@@ -76,7 +76,6 @@ SYSCALL_DEFINE5(s390_ipc, uint, call, int, first, unsigned long, second,
 	return sys_ipc(call, first, second, third, ptr, third);
 }
 
-#ifdef CONFIG_64BIT
 SYSCALL_DEFINE1(s390_personality, unsigned int, personality)
 {
 	unsigned int ret;
@@ -90,51 +89,3 @@ SYSCALL_DEFINE1(s390_personality, unsigned int, personality)
 
 	return ret;
 }
-#endif /* CONFIG_64BIT */
-
-/*
- * Wrapper function for sys_fadvise64/fadvise64_64
- */
-#ifndef CONFIG_64BIT
-
-SYSCALL_DEFINE5(s390_fadvise64, int, fd, u32, offset_high, u32, offset_low,
-		size_t, len, int, advice)
-{
-	return sys_fadvise64(fd, (u64) offset_high << 32 | offset_low,
-			len, advice);
-}
-
-struct fadvise64_64_args {
-	int fd;
-	long long offset;
-	long long len;
-	int advice;
-};
-
-SYSCALL_DEFINE1(s390_fadvise64_64, struct fadvise64_64_args __user *, args)
-{
-	struct fadvise64_64_args a;
-
-	if ( copy_from_user(&a, args, sizeof(a)) )
-		return -EFAULT;
-	return sys_fadvise64_64(a.fd, a.offset, a.len, a.advice);
-}
-
-/*
- * This is a wrapper to call sys_fallocate(). For 31 bit s390 the last
- * 64 bit argument "len" is split into the upper and lower 32 bits. The
- * system call wrapper in the user space loads the value to %r6/%r7.
- * The code in entry.S keeps the values in %r2 - %r6 where they are and
- * stores %r7 to 96(%r15). But the standard C linkage requires that
- * the whole 64 bit value for len is stored on the stack and doesn't
- * use %r6 at all. So s390_fallocate has to convert the arguments from
- *   %r2: fd, %r3: mode, %r4/%r5: offset, %r6/96(%r15)-99(%r15): len
- * to
- *   %r2: fd, %r3: mode, %r4/%r5: offset, 96(%r15)-103(%r15): len
- */
-SYSCALL_DEFINE5(s390_fallocate, int, fd, int, mode, loff_t, offset,
-			       u32, len_high, u32, len_low)
-{
-	return sys_fallocate(fd, mode, offset, ((u64)len_high << 32) | len_low);
-}
-#endif
* Unmerged path arch/s390/kernel/traps.c
diff --git a/arch/s390/kernel/vdso.c b/arch/s390/kernel/vdso.c
index f19cb448513c..8e6847da1a4c 100644
--- a/arch/s390/kernel/vdso.c
+++ b/arch/s390/kernel/vdso.c
@@ -32,19 +32,17 @@
 #include <asm/vdso.h>
 #include <asm/facility.h>
 
-#if defined(CONFIG_32BIT) || defined(CONFIG_COMPAT)
+#ifdef CONFIG_COMPAT
 extern char vdso32_start, vdso32_end;
 static void *vdso32_kbase = &vdso32_start;
 static unsigned int vdso32_pages;
 static struct page **vdso32_pagelist;
 #endif
 
-#ifdef CONFIG_64BIT
 extern char vdso64_start, vdso64_end;
 static void *vdso64_kbase = &vdso64_start;
 static unsigned int vdso64_pages;
 static struct page **vdso64_pagelist;
-#endif /* CONFIG_64BIT */
 
 /*
  * Should the kernel map a VDSO page into processes and pass its
@@ -87,7 +85,6 @@ static void vdso_init_data(struct vdso_data *vd)
 	vd->ectg_available = test_facility(31);
 }
 
-#ifdef CONFIG_64BIT
 /*
  * Allocate/free per cpu vdso data.
  */
@@ -169,7 +166,6 @@ static void vdso_init_cr5(void)
 	cr5 = offsetof(struct _lowcore, paste);
 	__ctl_load(cr5, 5, 5);
 }
-#endif /* CONFIG_64BIT */
 
 /*
  * This is called from binfmt_elf, we create the special vma for the
@@ -191,7 +187,6 @@ int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 	if (!uses_interp)
 		return 0;
 
-#ifdef CONFIG_64BIT
 	vdso_pagelist = vdso64_pagelist;
 	vdso_pages = vdso64_pages;
 #ifdef CONFIG_COMPAT
@@ -200,11 +195,6 @@ int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 		vdso_pages = vdso32_pages;
 	}
 #endif
-#else
-	vdso_pagelist = vdso32_pagelist;
-	vdso_pages = vdso32_pages;
-#endif
-
 	/*
 	 * vDSO has a problem and was disabled, just don't "enable" it for
 	 * the process
@@ -268,7 +258,7 @@ static int __init vdso_init(void)
 	if (!vdso_enabled)
 		return 0;
 	vdso_init_data(vdso_data);
-#if defined(CONFIG_32BIT) || defined(CONFIG_COMPAT)
+#ifdef CONFIG_COMPAT
 	/* Calculate the size of the 32 bit vDSO */
 	vdso32_pages = ((&vdso32_end - &vdso32_start
 			 + PAGE_SIZE - 1) >> PAGE_SHIFT) + 1;
@@ -287,7 +277,6 @@ static int __init vdso_init(void)
 	vdso32_pagelist[vdso32_pages] = NULL;
 #endif
 
-#ifdef CONFIG_64BIT
 	/* Calculate the size of the 64 bit vDSO */
 	vdso64_pages = ((&vdso64_end - &vdso64_start
 			 + PAGE_SIZE - 1) >> PAGE_SHIFT) + 1;
@@ -307,7 +296,6 @@ static int __init vdso_init(void)
 	if (vdso_alloc_per_cpu(&S390_lowcore))
 		BUG();
 	vdso_init_cr5();
-#endif /* CONFIG_64BIT */
 
 	get_page(virt_to_page(vdso_data));
 
diff --git a/arch/s390/kernel/vmlinux.lds.S b/arch/s390/kernel/vmlinux.lds.S
index e47aad9a4cbb..73f7b87ff5d1 100644
--- a/arch/s390/kernel/vmlinux.lds.S
+++ b/arch/s390/kernel/vmlinux.lds.S
@@ -13,17 +13,10 @@
 
 #include <asm-generic/vmlinux.lds.h>
 
-#ifndef CONFIG_64BIT
-OUTPUT_FORMAT("elf32-s390", "elf32-s390", "elf32-s390")
-OUTPUT_ARCH(s390:31-bit)
-ENTRY(startup)
-jiffies = jiffies_64 + 4;
-#else
 OUTPUT_FORMAT("elf64-s390", "elf64-s390", "elf64-s390")
 OUTPUT_ARCH(s390:64-bit)
 ENTRY(startup)
 jiffies = jiffies_64;
-#endif
 
 PHDRS {
 	text PT_LOAD FLAGS(5);	/* R_E */
* Unmerged path arch/s390/lib/Makefile
diff --git a/arch/s390/lib/div64.c b/arch/s390/lib/div64.c
deleted file mode 100644
index 261152f83242..000000000000
--- a/arch/s390/lib/div64.c
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- *  __div64_32 implementation for 31 bit.
- *
- *    Copyright IBM Corp. 2006
- *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
- */
-
-#include <linux/types.h>
-#include <linux/module.h>
-
-#ifdef CONFIG_MARCH_G5
-
-/*
- * Function to divide an unsigned 64 bit integer by an unsigned
- * 31 bit integer using signed 64/32 bit division.
- */
-static uint32_t __div64_31(uint64_t *n, uint32_t base)
-{
-	register uint32_t reg2 asm("2");
-	register uint32_t reg3 asm("3");
-	uint32_t *words = (uint32_t *) n;
-	uint32_t tmp;
-
-	/* Special case base==1, remainder = 0, quotient = n */
-	if (base == 1)
-		return 0;
-	/*
-	 * Special case base==0 will cause a fixed point divide exception
-	 * on the dr instruction and may not happen anyway. For the
-	 * following calculation we can assume base > 1. The first
-	 * signed 64 / 32 bit division with an upper half of 0 will
-	 * give the correct upper half of the 64 bit quotient.
-	 */
-	reg2 = 0UL;
-	reg3 = words[0];
-	asm volatile(
-		"	dr	%0,%2\n"
-		: "+d" (reg2), "+d" (reg3) : "d" (base) : "cc" );
-	words[0] = reg3;
-	reg3 = words[1];
-	/*
-	 * To get the lower half of the 64 bit quotient and the 32 bit
-	 * remainder we have to use a little trick. Since we only have
-	 * a signed division the quotient can get too big. To avoid this
-	 * the 64 bit dividend is halved, then the signed division will
-	 * work. Afterwards the quotient and the remainder are doubled.
-	 * If the last bit of the dividend has been one the remainder
-	 * is increased by one then checked against the base. If the
-	 * remainder has overflown subtract base and increase the
-	 * quotient. Simple, no ?
-	 */
-	asm volatile(
-		"	nr	%2,%1\n"
-		"	srdl	%0,1\n"
-		"	dr	%0,%3\n"
-		"	alr	%0,%0\n"
-		"	alr	%1,%1\n"
-		"	alr	%0,%2\n"
-		"	clr	%0,%3\n"
-		"	jl	0f\n"
-		"	slr	%0,%3\n"
-		"	ahi	%1,1\n"
-		"0:\n"
-		: "+d" (reg2), "+d" (reg3), "=d" (tmp)
-		: "d" (base), "2" (1UL) : "cc" );
-	words[1] = reg3;
-	return reg2;
-}
-
-/*
- * Function to divide an unsigned 64 bit integer by an unsigned
- * 32 bit integer using the unsigned 64/31 bit division.
- */
-uint32_t __div64_32(uint64_t *n, uint32_t base)
-{
-	uint32_t r;
-
-	/*
-	 * If the most significant bit of base is set, divide n by
-	 * (base/2). That allows to use 64/31 bit division and gives a
-	 * good approximation of the result: n = (base/2)*q + r. The
-	 * result needs to be corrected with two simple transformations.
-	 * If base is already < 2^31-1 __div64_31 can be used directly.
-	 */
-	r = __div64_31(n, ((signed) base < 0) ? (base/2) : base);
-	if ((signed) base < 0) {
-		uint64_t q = *n;
-		/*
-		 * First transformation:
-		 * n = (base/2)*q + r
-		 *   = ((base/2)*2)*(q/2) + ((q&1) ? (base/2) : 0) + r
-		 * Since r < (base/2), r + (base/2) < base.
-		 * With q1 = (q/2) and r1 = r + ((q&1) ? (base/2) : 0)
-		 * n = ((base/2)*2)*q1 + r1 with r1 < base.
-		 */
-		if (q & 1)
-			r += base/2;
-		q >>= 1;
-		/*
-		 * Second transformation. ((base/2)*2) could have lost the
-		 * last bit.
-		 * n = ((base/2)*2)*q1 + r1
-		 *   = base*q1 - ((base&1) ? q1 : 0) + r1
-		 */
-		if (base & 1) {
-			int64_t rx = r - q;
-			/*
-			 * base is >= 2^31. The worst case for the while
-			 * loop is n=2^64-1 base=2^31+1. That gives a
-			 * maximum for q=(2^64-1)/2^31 = 0x1ffffffff. Since
-			 * base >= 2^31 the loop is finished after a maximum
-			 * of three iterations.
-			 */
-			while (rx < 0) {
-				rx += base;
-				q--;
-			}
-			r = rx;
-		}
-		*n = q;
-	}
-	return r;
-}
-
-#else /* MARCH_G5 */
-
-uint32_t __div64_32(uint64_t *n, uint32_t base)
-{
-	register uint32_t reg2 asm("2");
-	register uint32_t reg3 asm("3");
-	uint32_t *words = (uint32_t *) n;
-
-	reg2 = 0UL;
-	reg3 = words[0];
-	asm volatile(
-		"	dlr	%0,%2\n"
-		: "+d" (reg2), "+d" (reg3) : "d" (base) : "cc" );
-	words[0] = reg3;
-	reg3 = words[1];
-	asm volatile(
-		"	dlr	%0,%2\n"
-		: "+d" (reg2), "+d" (reg3) : "d" (base) : "cc" );
-	words[1] = reg3;
-	return reg2;
-}
-
-#endif /* MARCH_G5 */
diff --git a/arch/s390/lib/mem32.S b/arch/s390/lib/mem32.S
deleted file mode 100644
index 14ca9244b615..000000000000
--- a/arch/s390/lib/mem32.S
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * String handling functions.
- *
- * Copyright IBM Corp. 2012
- */
-
-#include <linux/linkage.h>
-
-/*
- * memset implementation
- *
- * This code corresponds to the C construct below. We do distinguish
- * between clearing (c == 0) and setting a memory array (c != 0) simply
- * because nearly all memset invocations in the kernel clear memory and
- * the xc instruction is preferred in such cases.
- *
- * void *memset(void *s, int c, size_t n)
- * {
- *	if (likely(c == 0))
- *		return __builtin_memset(s, 0, n);
- *	return __builtin_memset(s, c, n);
- * }
- */
-ENTRY(memset)
-	basr	%r5,%r0
-.Lmemset_base:
-	ltr	%r4,%r4
-	bzr	%r14
-	ltr	%r3,%r3
-	jnz	.Lmemset_fill
-	ahi	%r4,-1
-	lr	%r3,%r4
-	srl	%r3,8
-	ltr	%r3,%r3
-	lr	%r1,%r2
-	je	.Lmemset_clear_rest
-.Lmemset_clear_loop:
-	xc	0(256,%r1),0(%r1)
-	la	%r1,256(%r1)
-	brct	%r3,.Lmemset_clear_loop
-.Lmemset_clear_rest:
-	ex	%r4,.Lmemset_xc-.Lmemset_base(%r5)
-	br	%r14
-.Lmemset_fill:
-	stc	%r3,0(%r2)
-	chi	%r4,1
-	lr	%r1,%r2
-	ber	%r14
-	ahi	%r4,-2
-	lr	%r3,%r4
-	srl	%r3,8
-	ltr	%r3,%r3
-	je	.Lmemset_fill_rest
-.Lmemset_fill_loop:
-	mvc	1(256,%r1),0(%r1)
-	la	%r1,256(%r1)
-	brct	%r3,.Lmemset_fill_loop
-.Lmemset_fill_rest:
-	ex	%r4,.Lmemset_mvc-.Lmemset_base(%r5)
-	br	%r14
-.Lmemset_xc:
-	xc	0(1,%r1),0(%r1)
-.Lmemset_mvc:
-	mvc	1(1,%r1),0(%r1)
-
-/*
- * memcpy implementation
- *
- * void *memcpy(void *dest, const void *src, size_t n)
- */
-ENTRY(memcpy)
-	basr	%r5,%r0
-.Lmemcpy_base:
-	ltr	%r4,%r4
-	bzr	%r14
-	ahi	%r4,-1
-	lr	%r0,%r4
-	srl	%r0,8
-	ltr	%r0,%r0
-	lr	%r1,%r2
-	jnz	.Lmemcpy_loop
-.Lmemcpy_rest:
-	ex	%r4,.Lmemcpy_mvc-.Lmemcpy_base(%r5)
-	br	%r14
-.Lmemcpy_loop:
-	mvc	0(256,%r1),0(%r3)
-	la	%r1,256(%r1)
-	la	%r3,256(%r3)
-	brct	%r0,.Lmemcpy_loop
-	j	.Lmemcpy_rest
-.Lmemcpy_mvc:
-	mvc	0(1,%r1),0(%r3)
diff --git a/arch/s390/lib/qrnnd.S b/arch/s390/lib/qrnnd.S
deleted file mode 100644
index d321329130ec..000000000000
--- a/arch/s390/lib/qrnnd.S
+++ /dev/null
@@ -1,78 +0,0 @@
-# S/390 __udiv_qrnnd
-
-#include <linux/linkage.h>
-
-# r2 : &__r
-# r3 : upper half of 64 bit word n
-# r4 : lower half of 64 bit word n
-# r5 : divisor d
-# the reminder r of the division is to be stored to &__r and
-# the quotient q is to be returned
-
-	.text
-ENTRY(__udiv_qrnnd)
-	st    %r2,24(%r15)	  # store pointer to reminder for later
-	lr    %r0,%r3		  # reload n
-	lr    %r1,%r4
-	ltr   %r2,%r5		  # reload and test divisor
-	jp    5f
-	# divisor >= 0x80000000
-	srdl  %r0,2		  # n/4
-	srl   %r2,1		  # d/2
-	slr   %r1,%r2		  # special case if last bit of d is set
-	brc   3,0f		  #  (n/4) div (n/2) can overflow by 1
-	ahi   %r0,-1		  #  trick: subtract n/2, then divide
-0:	dr    %r0,%r2		  # signed division
-	ahi   %r1,1		  #  trick part 2: add 1 to the quotient
-	# now (n >> 2) = (d >> 1) * %r1 + %r0
-	lhi   %r3,1
-	nr    %r3,%r1		  # test last bit of q
-	jz    1f
-	alr   %r0,%r2		  # add (d>>1) to r
-1:	srl   %r1,1		  # q >>= 1
-	# now (n >> 2) = (d&-2) * %r1 + %r0
-	lhi   %r3,1
-	nr    %r3,%r5		  # test last bit of d
-	jz    2f
-	slr   %r0,%r1		  # r -= q
-	brc   3,2f		  # borrow ?
-	alr   %r0,%r5		  # r += d
-	ahi   %r1,-1
-2:	# now (n >> 2) = d * %r1 + %r0
-	alr   %r1,%r1		  # q <<= 1
-	alr   %r0,%r0		  # r <<= 1
-	brc   12,3f		  # overflow on r ?
-	slr   %r0,%r5		  # r -= d
-	ahi   %r1,1		  # q += 1
-3:	lhi   %r3,2
-	nr    %r3,%r4		  # test next to last bit of n
-	jz    4f
-	ahi   %r0,1		  # r += 1
-4:	clr   %r0,%r5		  # r >= d ?
-	jl    6f
-	slr   %r0,%r5		  # r -= d
-	ahi   %r1,1		  # q += 1
-	# now (n >> 1) = d * %r1 + %r0
-	j     6f
-5:	# divisor < 0x80000000
-	srdl  %r0,1
-	dr    %r0,%r2		  # signed division
-	# now (n >> 1) = d * %r1 + %r0
-6:	alr   %r1,%r1		  # q <<= 1
-	alr   %r0,%r0		  # r <<= 1
-	brc   12,7f		  # overflow on r ?
-	slr   %r0,%r5		  # r -= d
-	ahi   %r1,1		  # q += 1
-7:	lhi   %r3,1
-	nr    %r3,%r4		  # isolate last bit of n
-	alr   %r0,%r3		  # r += (n & 1)
-	clr   %r0,%r5		  # r >= d ?
-	jl    8f
-	slr   %r0,%r5		  # r -= d
-	ahi   %r1,1		  # q += 1
-8:	# now n = d * %r1 + %r0
-	l     %r2,24(%r15)
-	st    %r0,0(%r2)
-	lr    %r2,%r1
-	br    %r14
-	.end	__udiv_qrnnd
diff --git a/arch/s390/lib/uaccess.c b/arch/s390/lib/uaccess.c
index c5477ac57e19..f8dc12c8a9a6 100644
--- a/arch/s390/lib/uaccess.c
+++ b/arch/s390/lib/uaccess.c
@@ -15,20 +15,6 @@
 #include <asm/mmu_context.h>
 #include <asm/facility.h>
 
-#ifndef CONFIG_64BIT
-#define AHI	"ahi"
-#define ALR	"alr"
-#define CLR	"clr"
-#define LHI	"lhi"
-#define SLR	"slr"
-#else
-#define AHI	"aghi"
-#define ALR	"algr"
-#define CLR	"clgr"
-#define LHI	"lghi"
-#define SLR	"slgr"
-#endif
-
 static struct static_key have_mvcos = STATIC_KEY_INIT_FALSE;
 
 static inline unsigned long copy_from_user_mvcos(void *x, const void __user *ptr,
@@ -41,29 +27,29 @@ static inline unsigned long copy_from_user_mvcos(void *x, const void __user *ptr
 	asm volatile(
 		"0: .insn ss,0xc80000000000,0(%0,%2),0(%1),0\n"
 		"9: jz    7f\n"
-		"1:"ALR"  %0,%3\n"
-		"  "SLR"  %1,%3\n"
-		"  "SLR"  %2,%3\n"
+		"1: algr  %0,%3\n"
+		"   slgr  %1,%3\n"
+		"   slgr  %2,%3\n"
 		"   j     0b\n"
 		"2: la    %4,4095(%1)\n"/* %4 = ptr + 4095 */
 		"   nr    %4,%3\n"	/* %4 = (ptr + 4095) & -4096 */
-		"  "SLR"  %4,%1\n"
-		"  "CLR"  %0,%4\n"	/* copy crosses next page boundary? */
+		"   slgr  %4,%1\n"
+		"   clgr  %0,%4\n"	/* copy crosses next page boundary? */
 		"   jnh   4f\n"
 		"3: .insn ss,0xc80000000000,0(%4,%2),0(%1),0\n"
-		"10:"SLR"  %0,%4\n"
-		"  "ALR"  %2,%4\n"
-		"4:"LHI"  %4,-1\n"
-		"  "ALR"  %4,%0\n"	/* copy remaining size, subtract 1 */
+		"10:slgr  %0,%4\n"
+		"   algr  %2,%4\n"
+		"4: lghi  %4,-1\n"
+		"   algr  %4,%0\n"	/* copy remaining size, subtract 1 */
 		"   bras  %3,6f\n"	/* memset loop */
 		"   xc    0(1,%2),0(%2)\n"
 		"5: xc    0(256,%2),0(%2)\n"
 		"   la    %2,256(%2)\n"
-		"6:"AHI"  %4,-256\n"
+		"6: aghi  %4,-256\n"
 		"   jnm   5b\n"
 		"   ex    %4,0(%3)\n"
 		"   j     8f\n"
-		"7:"SLR"  %0,%0\n"
+		"7:slgr  %0,%0\n"
 		"8:\n"
 		EX_TABLE(0b,2b) EX_TABLE(3b,4b) EX_TABLE(9b,2b) EX_TABLE(10b,4b)
 		: "+a" (size), "+a" (ptr), "+a" (x), "+a" (tmp1), "=a" (tmp2)
@@ -82,32 +68,32 @@ static inline unsigned long copy_from_user_mvcp(void *x, const void __user *ptr,
 		"   sacf  0\n"
 		"0: mvcp  0(%0,%2),0(%1),%3\n"
 		"10:jz    8f\n"
-		"1:"ALR"  %0,%3\n"
+		"1: algr  %0,%3\n"
 		"   la    %1,256(%1)\n"
 		"   la    %2,256(%2)\n"
 		"2: mvcp  0(%0,%2),0(%1),%3\n"
 		"11:jnz   1b\n"
 		"   j     8f\n"
 		"3: la    %4,255(%1)\n"	/* %4 = ptr + 255 */
-		"  "LHI"  %3,-4096\n"
+		"   lghi  %3,-4096\n"
 		"   nr    %4,%3\n"	/* %4 = (ptr + 255) & -4096 */
-		"  "SLR"  %4,%1\n"
-		"  "CLR"  %0,%4\n"	/* copy crosses next page boundary? */
+		"   slgr  %4,%1\n"
+		"   clgr  %0,%4\n"	/* copy crosses next page boundary? */
 		"   jnh   5f\n"
 		"4: mvcp  0(%4,%2),0(%1),%3\n"
-		"12:"SLR"  %0,%4\n"
-		"  "ALR"  %2,%4\n"
-		"5:"LHI"  %4,-1\n"
-		"  "ALR"  %4,%0\n"	/* copy remaining size, subtract 1 */
+		"12:slgr  %0,%4\n"
+		"   algr  %2,%4\n"
+		"5: lghi  %4,-1\n"
+		"   algr  %4,%0\n"	/* copy remaining size, subtract 1 */
 		"   bras  %3,7f\n"	/* memset loop */
 		"   xc    0(1,%2),0(%2)\n"
 		"6: xc    0(256,%2),0(%2)\n"
 		"   la    %2,256(%2)\n"
-		"7:"AHI"  %4,-256\n"
+		"7: aghi  %4,-256\n"
 		"   jnm   6b\n"
 		"   ex    %4,0(%3)\n"
 		"   j     9f\n"
-		"8:"SLR"  %0,%0\n"
+		"8:slgr  %0,%0\n"
 		"9: sacf  768\n"
 		EX_TABLE(0b,3b) EX_TABLE(2b,3b) EX_TABLE(4b,5b)
 		EX_TABLE(10b,3b) EX_TABLE(11b,3b) EX_TABLE(12b,5b)
@@ -135,19 +121,19 @@ static inline unsigned long copy_to_user_mvcos(void __user *ptr, const void *x,
 	asm volatile(
 		"0: .insn ss,0xc80000000000,0(%0,%1),0(%2),0\n"
 		"6: jz    4f\n"
-		"1:"ALR"  %0,%3\n"
-		"  "SLR"  %1,%3\n"
-		"  "SLR"  %2,%3\n"
+		"1: algr  %0,%3\n"
+		"   slgr  %1,%3\n"
+		"   slgr  %2,%3\n"
 		"   j     0b\n"
 		"2: la    %4,4095(%1)\n"/* %4 = ptr + 4095 */
 		"   nr    %4,%3\n"	/* %4 = (ptr + 4095) & -4096 */
-		"  "SLR"  %4,%1\n"
-		"  "CLR"  %0,%4\n"	/* copy crosses next page boundary? */
+		"   slgr  %4,%1\n"
+		"   clgr  %0,%4\n"	/* copy crosses next page boundary? */
 		"   jnh   5f\n"
 		"3: .insn ss,0xc80000000000,0(%4,%1),0(%2),0\n"
-		"7:"SLR"  %0,%4\n"
+		"7: slgr  %0,%4\n"
 		"   j     5f\n"
-		"4:"SLR"  %0,%0\n"
+		"4: slgr  %0,%0\n"
 		"5:\n"
 		EX_TABLE(0b,2b) EX_TABLE(3b,5b) EX_TABLE(6b,2b) EX_TABLE(7b,5b)
 		: "+a" (size), "+a" (ptr), "+a" (x), "+a" (tmp1), "=a" (tmp2)
@@ -166,22 +152,22 @@ static inline unsigned long copy_to_user_mvcs(void __user *ptr, const void *x,
 		"   sacf  0\n"
 		"0: mvcs  0(%0,%1),0(%2),%3\n"
 		"7: jz    5f\n"
-		"1:"ALR"  %0,%3\n"
+		"1: algr  %0,%3\n"
 		"   la    %1,256(%1)\n"
 		"   la    %2,256(%2)\n"
 		"2: mvcs  0(%0,%1),0(%2),%3\n"
 		"8: jnz   1b\n"
 		"   j     5f\n"
 		"3: la    %4,255(%1)\n" /* %4 = ptr + 255 */
-		"  "LHI"  %3,-4096\n"
+		"   lghi  %3,-4096\n"
 		"   nr    %4,%3\n"	/* %4 = (ptr + 255) & -4096 */
-		"  "SLR"  %4,%1\n"
-		"  "CLR"  %0,%4\n"	/* copy crosses next page boundary? */
+		"   slgr  %4,%1\n"
+		"   clgr  %0,%4\n"	/* copy crosses next page boundary? */
 		"   jnh   6f\n"
 		"4: mvcs  0(%4,%1),0(%2),%3\n"
-		"9:"SLR"  %0,%4\n"
+		"9: slgr  %0,%4\n"
 		"   j     6f\n"
-		"5:"SLR"  %0,%0\n"
+		"5: slgr  %0,%0\n"
 		"6: sacf  768\n"
 		EX_TABLE(0b,3b) EX_TABLE(2b,3b) EX_TABLE(4b,6b)
 		EX_TABLE(7b,3b) EX_TABLE(8b,3b) EX_TABLE(9b,6b)
@@ -210,11 +196,11 @@ static inline unsigned long copy_in_user_mvcos(void __user *to, const void __use
 	asm volatile(
 		"0: .insn ss,0xc80000000000,0(%0,%1),0(%2),0\n"
 		"   jz	  2f\n"
-		"1:"ALR"  %0,%3\n"
-		"  "SLR"  %1,%3\n"
-		"  "SLR"  %2,%3\n"
+		"1: algr  %0,%3\n"
+		"   slgr  %1,%3\n"
+		"   slgr  %2,%3\n"
 		"   j	  0b\n"
-		"2:"SLR"  %0,%0\n"
+		"2:slgr  %0,%0\n"
 		"3: \n"
 		EX_TABLE(0b,3b)
 		: "+a" (size), "+a" (to), "+a" (from), "+a" (tmp1), "=a" (tmp2)
@@ -230,23 +216,23 @@ static inline unsigned long copy_in_user_mvc(void __user *to, const void __user
 	update_primary_asce(current);
 	asm volatile(
 		"   sacf  256\n"
-		"  "AHI"  %0,-1\n"
+		"   aghi  %0,-1\n"
 		"   jo	  5f\n"
 		"   bras  %3,3f\n"
-		"0:"AHI"  %0,257\n"
+		"0: aghi  %0,257\n"
 		"1: mvc	  0(1,%1),0(%2)\n"
 		"   la	  %1,1(%1)\n"
 		"   la	  %2,1(%2)\n"
-		"  "AHI"  %0,-1\n"
+		"   aghi  %0,-1\n"
 		"   jnz	  1b\n"
 		"   j	  5f\n"
 		"2: mvc	  0(256,%1),0(%2)\n"
 		"   la	  %1,256(%1)\n"
 		"   la	  %2,256(%2)\n"
-		"3:"AHI"  %0,-256\n"
+		"3: aghi  %0,-256\n"
 		"   jnm	  2b\n"
 		"4: ex	  %0,1b-0b(%3)\n"
-		"5: "SLR"  %0,%0\n"
+		"5: slgr  %0,%0\n"
 		"6: sacf  768\n"
 		EX_TABLE(1b,6b) EX_TABLE(2b,0b) EX_TABLE(4b,0b)
 		: "+a" (size), "+a" (to), "+a" (from), "=a" (tmp1)
@@ -271,18 +257,18 @@ static inline unsigned long clear_user_mvcos(void __user *to, unsigned long size
 	asm volatile(
 		"0: .insn ss,0xc80000000000,0(%0,%1),0(%4),0\n"
 		"   jz	  4f\n"
-		"1:"ALR"  %0,%2\n"
-		"  "SLR"  %1,%2\n"
+		"1: algr  %0,%2\n"
+		"   slgr  %1,%2\n"
 		"   j	  0b\n"
 		"2: la	  %3,4095(%1)\n"/* %4 = to + 4095 */
 		"   nr	  %3,%2\n"	/* %4 = (to + 4095) & -4096 */
-		"  "SLR"  %3,%1\n"
-		"  "CLR"  %0,%3\n"	/* copy crosses next page boundary? */
+		"   slgr  %3,%1\n"
+		"   clgr  %0,%3\n"	/* copy crosses next page boundary? */
 		"   jnh	  5f\n"
 		"3: .insn ss,0xc80000000000,0(%3,%1),0(%4),0\n"
-		"  "SLR"  %0,%3\n"
+		"   slgr  %0,%3\n"
 		"   j	  5f\n"
-		"4:"SLR"  %0,%0\n"
+		"4:slgr  %0,%0\n"
 		"5:\n"
 		EX_TABLE(0b,2b) EX_TABLE(3b,5b)
 		: "+a" (size), "+a" (to), "+a" (tmp1), "=a" (tmp2)
@@ -297,28 +283,28 @@ static inline unsigned long clear_user_xc(void __user *to, unsigned long size)
 	update_primary_asce(current);
 	asm volatile(
 		"   sacf  256\n"
-		"  "AHI"  %0,-1\n"
+		"   aghi  %0,-1\n"
 		"   jo    5f\n"
 		"   bras  %3,3f\n"
 		"   xc    0(1,%1),0(%1)\n"
-		"0:"AHI"  %0,257\n"
+		"0: aghi  %0,257\n"
 		"   la    %2,255(%1)\n" /* %2 = ptr + 255 */
 		"   srl   %2,12\n"
 		"   sll   %2,12\n"	/* %2 = (ptr + 255) & -4096 */
-		"  "SLR"  %2,%1\n"
-		"  "CLR"  %0,%2\n"	/* clear crosses next page boundary? */
+		"   slgr  %2,%1\n"
+		"   clgr  %0,%2\n"	/* clear crosses next page boundary? */
 		"   jnh   5f\n"
-		"  "AHI"  %2,-1\n"
+		"   aghi  %2,-1\n"
 		"1: ex    %2,0(%3)\n"
-		"  "AHI"  %2,1\n"
-		"  "SLR"  %0,%2\n"
+		"   aghi  %2,1\n"
+		"   slgr  %0,%2\n"
 		"   j     5f\n"
 		"2: xc    0(256,%1),0(%1)\n"
 		"   la    %1,256(%1)\n"
-		"3:"AHI"  %0,-256\n"
+		"3: aghi  %0,-256\n"
 		"   jnm   2b\n"
 		"4: ex    %0,0(%3)\n"
-		"5: "SLR"  %0,%0\n"
+		"5: slgr  %0,%0\n"
 		"6: sacf  768\n"
 		EX_TABLE(1b,6b) EX_TABLE(2b,0b) EX_TABLE(4b,0b)
 		: "+a" (size), "+a" (to), "=a" (tmp1), "=a" (tmp2)
@@ -343,12 +329,12 @@ static inline unsigned long strnlen_user_srst(const char __user *src,
 	asm volatile(
 		"   la    %2,0(%1)\n"
 		"   la    %3,0(%0,%1)\n"
-		"  "SLR"  %0,%0\n"
+		"   slgr  %0,%0\n"
 		"   sacf  256\n"
 		"0: srst  %3,%2\n"
 		"   jo    0b\n"
 		"   la    %0,1(%3)\n"	/* strnlen_user results includes \0 */
-		"  "SLR"  %0,%1\n"
+		"   slgr  %0,%1\n"
 		"1: sacf  768\n"
 		EX_TABLE(0b,1b)
 		: "+a" (size), "+a" (src), "=a" (tmp1), "=a" (tmp2)
@@ -401,7 +387,7 @@ early_param("uaccess_primary", parse_uaccess_pt);
 
 static int __init uaccess_init(void)
 {
-	if (IS_ENABLED(CONFIG_64BIT) && !uaccess_primary && test_facility(27))
+	if (!uaccess_primary && test_facility(27))
 		static_key_slow_inc(&have_mvcos);
 	return 0;
 }
diff --git a/arch/s390/lib/ucmpdi2.c b/arch/s390/lib/ucmpdi2.c
deleted file mode 100644
index 3e05ff532582..000000000000
--- a/arch/s390/lib/ucmpdi2.c
+++ /dev/null
@@ -1,26 +0,0 @@
-#include <linux/module.h>
-
-union ull_union {
-	unsigned long long ull;
-	struct {
-		unsigned int high;
-		unsigned int low;
-	} ui;
-};
-
-int __ucmpdi2(unsigned long long a, unsigned long long b)
-{
-	union ull_union au = {.ull = a};
-	union ull_union bu = {.ull = b};
-
-	if (au.ui.high < bu.ui.high)
-		return 0;
-	else if (au.ui.high > bu.ui.high)
-		return 2;
-	if (au.ui.low < bu.ui.low)
-		return 0;
-	else if (au.ui.low > bu.ui.low)
-		return 2;
-	return 1;
-}
-EXPORT_SYMBOL(__ucmpdi2);
diff --git a/arch/s390/math-emu/Makefile b/arch/s390/math-emu/Makefile
deleted file mode 100644
index 51d399549f60..000000000000
--- a/arch/s390/math-emu/Makefile
+++ /dev/null
@@ -1,7 +0,0 @@
-#
-# Makefile for the FPU instruction emulation.
-#
-
-obj-$(CONFIG_MATHEMU) := math.o
-
-ccflags-y := -I$(src) -Iinclude/math-emu -w
diff --git a/arch/s390/math-emu/math.c b/arch/s390/math-emu/math.c
deleted file mode 100644
index a6ba0d724335..000000000000
--- a/arch/s390/math-emu/math.c
+++ /dev/null
@@ -1,2255 +0,0 @@
-/*
- *  S390 version
- *    Copyright IBM Corp. 1999, 2001
- *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
- *
- * 'math.c' emulates IEEE instructions on a S390 processor
- *          that does not have the IEEE fpu (all processors before G5).
- */
-
-#include <linux/types.h>
-#include <linux/sched.h>
-#include <linux/mm.h>
-#include <asm/uaccess.h>
-#include <asm/lowcore.h>
-
-#include <asm/sfp-util.h>
-#include <math-emu/soft-fp.h>
-#include <math-emu/single.h>
-#include <math-emu/double.h>
-#include <math-emu/quad.h>
-
-#define FPC_VALID_MASK		0xF8F8FF03
-
-/*
- * I miss a macro to round a floating point number to the
- * nearest integer in the same floating point format.
- */
-#define _FP_TO_FPINT_ROUND(fs, wc, X)					\
-  do {									\
-    switch (X##_c)							\
-      {									\
-      case FP_CLS_NORMAL:						\
-        if (X##_e > _FP_FRACBITS_##fs + _FP_EXPBIAS_##fs)		\
-          { /* floating point number has no bits after the dot. */	\
-          }								\
-        else if (X##_e <= _FP_FRACBITS_##fs + _FP_EXPBIAS_##fs &&	\
-                 X##_e > _FP_EXPBIAS_##fs)				\
-	  { /* some bits before the dot, some after it. */		\
-            _FP_FRAC_SRS_##wc(X, _FP_WFRACBITS_##fs,			\
-                              X##_e - _FP_EXPBIAS_##fs			\
-                              + _FP_FRACBITS_##fs);			\
-	    _FP_ROUND(wc, X);						\
-	    _FP_FRAC_SLL_##wc(X, X##_e - _FP_EXPBIAS_##fs		\
-                              + _FP_FRACBITS_##fs);			\
-          }								\
-        else								\
-          { /* all bits after the dot. */				\
-	    FP_SET_EXCEPTION(FP_EX_INEXACT);				\
-            X##_c = FP_CLS_ZERO;					\
-	  }								\
-        break;								\
-      case FP_CLS_NAN:							\
-      case FP_CLS_INF:							\
-      case FP_CLS_ZERO:							\
-        break;								\
-      }									\
-  } while (0)
-
-#define FP_TO_FPINT_ROUND_S(X)	_FP_TO_FPINT_ROUND(S,1,X)
-#define FP_TO_FPINT_ROUND_D(X)	_FP_TO_FPINT_ROUND(D,2,X)
-#define FP_TO_FPINT_ROUND_Q(X)	_FP_TO_FPINT_ROUND(Q,4,X)
-
-typedef union {
-        long double ld;
-        struct {
-                __u64 high;
-                __u64 low;
-        } w;
-} mathemu_ldcv;
-
-#ifdef CONFIG_SYSCTL
-int sysctl_ieee_emulation_warnings=1;
-#endif
-
-#define mathemu_put_user(x, p) \
-        do { \
-                if (put_user((x),(p))) \
-                        return SIGSEGV; \
-        } while (0)
-
-#define mathemu_get_user(x, p) \
-        do { \
-                if (get_user((x),(p))) \
-                        return SIGSEGV; \
-        } while (0)
-
-#define mathemu_copy_from_user(d, s, n)\
-        do { \
-                if (copy_from_user((d),(s),(n)) != 0) \
-                        return SIGSEGV; \
-        } while (0)
-
-#define mathemu_copy_to_user(d, s, n) \
-        do { \
-                if (copy_to_user((d),(s),(n)) != 0) \
-                        return SIGSEGV; \
-        } while (0)
-
-static void display_emulation_not_implemented(struct pt_regs *regs, char *instr)
-{
-        __u16 *location;
-        
-#ifdef CONFIG_SYSCTL
-        if(sysctl_ieee_emulation_warnings)
-#endif
-        {
-                location = (__u16 *)(regs->psw.addr-S390_lowcore.pgm_ilc);
-                printk("%s ieee fpu instruction not emulated "
-                       "process name: %s pid: %d \n",
-                       instr, current->comm, current->pid);
-                printk("%s's PSW:    %08lx %08lx\n", instr,
-                       (unsigned long) regs->psw.mask,
-                       (unsigned long) location);
-        }
-}
-
-static inline void emu_set_CC (struct pt_regs *regs, int cc)
-{
-        regs->psw.mask = (regs->psw.mask & 0xFFFFCFFF) | ((cc&3) << 12);
-}
-
-/*
- * Set the condition code in the user psw.
- *  0 : Result is zero
- *  1 : Result is less than zero
- *  2 : Result is greater than zero
- *  3 : Result is NaN or INF
- */
-static inline void emu_set_CC_cs(struct pt_regs *regs, int class, int sign)
-{
-        switch (class) {
-        case FP_CLS_NORMAL:
-        case FP_CLS_INF:
-                emu_set_CC(regs, sign ? 1 : 2);
-                break;
-        case FP_CLS_ZERO:
-                emu_set_CC(regs, 0);
-                break;
-        case FP_CLS_NAN:
-                emu_set_CC(regs, 3);
-                break;
-        }
-}
-
-/* Add long double */
-static int emu_axbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_Q(QA); FP_DECL_Q(QB); FP_DECL_Q(QR);
-        FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        cvt.w.high = current->thread.fp_regs.fprs[rx].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[rx+2].ui;
-        FP_UNPACK_QP(QA, &cvt.ld);
-        cvt.w.high = current->thread.fp_regs.fprs[ry].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[ry+2].ui;
-        FP_UNPACK_QP(QB, &cvt.ld);
-        FP_ADD_Q(QR, QA, QB);
-        FP_PACK_QP(&cvt.ld, QR);
-        current->thread.fp_regs.fprs[rx].ui = cvt.w.high;
-        current->thread.fp_regs.fprs[rx+2].ui = cvt.w.low;
-        emu_set_CC_cs(regs, QR_c, QR_s);
-        return _fex;
-}
-
-/* Add double */
-static int emu_adbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-        FP_UNPACK_DP(DB, &current->thread.fp_regs.fprs[ry].d);
-        FP_ADD_D(DR, DA, DB);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-        emu_set_CC_cs(regs, DR_c, DR_s);
-        return _fex;
-}
-
-/* Add double */
-static int emu_adb (struct pt_regs *regs, int rx, double *val) {
-        FP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-        FP_UNPACK_DP(DB, val);
-        FP_ADD_D(DR, DA, DB);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-        emu_set_CC_cs(regs, DR_c, DR_s);
-        return _fex;
-}
-
-/* Add float */
-static int emu_aebr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-        FP_UNPACK_SP(SB, &current->thread.fp_regs.fprs[ry].f);
-        FP_ADD_S(SR, SA, SB);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rx].f, SR);
-        emu_set_CC_cs(regs, SR_c, SR_s);
-        return _fex;
-}
-
-/* Add float */
-static int emu_aeb (struct pt_regs *regs, int rx, float *val) {
-        FP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-        FP_UNPACK_SP(SB, val);
-        FP_ADD_S(SR, SA, SB);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rx].f, SR);
-        emu_set_CC_cs(regs, SR_c, SR_s);
-        return _fex;
-}
-
-/* Compare long double */
-static int emu_cxbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_Q(QA); FP_DECL_Q(QB);
-	mathemu_ldcv cvt;
-        int IR;
-
-        cvt.w.high = current->thread.fp_regs.fprs[rx].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[rx+2].ui;
-        FP_UNPACK_RAW_QP(QA, &cvt.ld);
-        cvt.w.high = current->thread.fp_regs.fprs[ry].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[ry+2].ui;
-        FP_UNPACK_RAW_QP(QB, &cvt.ld);
-        FP_CMP_Q(IR, QA, QB, 3);
-        /*
-         * IR == -1 if DA < DB, IR == 0 if DA == DB,
-         * IR == 1 if DA > DB and IR == 3 if unorderded
-         */
-        emu_set_CC(regs, (IR == -1) ? 1 : (IR == 1) ? 2 : IR);
-        return 0;
-}
-
-/* Compare double */
-static int emu_cdbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_D(DA); FP_DECL_D(DB);
-        int IR;
-
-        FP_UNPACK_RAW_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-        FP_UNPACK_RAW_DP(DB, &current->thread.fp_regs.fprs[ry].d);
-        FP_CMP_D(IR, DA, DB, 3);
-        /*
-         * IR == -1 if DA < DB, IR == 0 if DA == DB,
-         * IR == 1 if DA > DB and IR == 3 if unorderded
-         */
-        emu_set_CC(regs, (IR == -1) ? 1 : (IR == 1) ? 2 : IR);
-        return 0;
-}
-
-/* Compare double */
-static int emu_cdb (struct pt_regs *regs, int rx, double *val) {
-        FP_DECL_D(DA); FP_DECL_D(DB);
-        int IR;
-
-        FP_UNPACK_RAW_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-        FP_UNPACK_RAW_DP(DB, val);
-        FP_CMP_D(IR, DA, DB, 3);
-        /*
-         * IR == -1 if DA < DB, IR == 0 if DA == DB,
-         * IR == 1 if DA > DB and IR == 3 if unorderded
-         */
-        emu_set_CC(regs, (IR == -1) ? 1 : (IR == 1) ? 2 : IR);
-        return 0;
-}
-
-/* Compare float */
-static int emu_cebr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_S(SA); FP_DECL_S(SB);
-        int IR;
-
-        FP_UNPACK_RAW_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-        FP_UNPACK_RAW_SP(SB, &current->thread.fp_regs.fprs[ry].f);
-        FP_CMP_S(IR, SA, SB, 3);
-        /*
-         * IR == -1 if DA < DB, IR == 0 if DA == DB,
-         * IR == 1 if DA > DB and IR == 3 if unorderded
-         */
-        emu_set_CC(regs, (IR == -1) ? 1 : (IR == 1) ? 2 : IR);
-        return 0;
-}
-
-/* Compare float */
-static int emu_ceb (struct pt_regs *regs, int rx, float *val) {
-        FP_DECL_S(SA); FP_DECL_S(SB);
-        int IR;
-
-        FP_UNPACK_RAW_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-        FP_UNPACK_RAW_SP(SB, val);
-        FP_CMP_S(IR, SA, SB, 3);
-        /*
-         * IR == -1 if DA < DB, IR == 0 if DA == DB,
-         * IR == 1 if DA > DB and IR == 3 if unorderded
-         */
-        emu_set_CC(regs, (IR == -1) ? 1 : (IR == 1) ? 2 : IR);
-        return 0;
-}
-
-/* Compare and signal long double */
-static int emu_kxbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_Q(QA); FP_DECL_Q(QB);
-        FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int IR;
-
-        cvt.w.high = current->thread.fp_regs.fprs[rx].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[rx+2].ui;
-        FP_UNPACK_RAW_QP(QA, &cvt.ld);
-        cvt.w.high = current->thread.fp_regs.fprs[ry].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[ry+2].ui;
-        FP_UNPACK_QP(QB, &cvt.ld);
-        FP_CMP_Q(IR, QA, QB, 3);
-        /*
-         * IR == -1 if DA < DB, IR == 0 if DA == DB,
-         * IR == 1 if DA > DB and IR == 3 if unorderded
-         */
-        emu_set_CC(regs, (IR == -1) ? 1 : (IR == 1) ? 2 : IR);
-        if (IR == 3)
-                FP_SET_EXCEPTION (FP_EX_INVALID);
-        return _fex;
-}
-
-/* Compare and signal double */
-static int emu_kdbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_D(DA); FP_DECL_D(DB);
-        FP_DECL_EX;
-        int IR;
-
-        FP_UNPACK_RAW_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-        FP_UNPACK_RAW_DP(DB, &current->thread.fp_regs.fprs[ry].d);
-        FP_CMP_D(IR, DA, DB, 3);
-        /*
-         * IR == -1 if DA < DB, IR == 0 if DA == DB,
-         * IR == 1 if DA > DB and IR == 3 if unorderded
-         */
-        emu_set_CC(regs, (IR == -1) ? 1 : (IR == 1) ? 2 : IR);
-        if (IR == 3)
-                FP_SET_EXCEPTION (FP_EX_INVALID);
-        return _fex;
-}
-
-/* Compare and signal double */
-static int emu_kdb (struct pt_regs *regs, int rx, double *val) {
-        FP_DECL_D(DA); FP_DECL_D(DB);
-        FP_DECL_EX;
-        int IR;
-
-        FP_UNPACK_RAW_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-        FP_UNPACK_RAW_DP(DB, val);
-        FP_CMP_D(IR, DA, DB, 3);
-        /*
-         * IR == -1 if DA < DB, IR == 0 if DA == DB,
-         * IR == 1 if DA > DB and IR == 3 if unorderded
-         */
-        emu_set_CC(regs, (IR == -1) ? 1 : (IR == 1) ? 2 : IR);
-        if (IR == 3)
-                FP_SET_EXCEPTION (FP_EX_INVALID);
-        return _fex;
-}
-
-/* Compare and signal float */
-static int emu_kebr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_S(SA); FP_DECL_S(SB);
-        FP_DECL_EX;
-        int IR;
-
-        FP_UNPACK_RAW_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-        FP_UNPACK_RAW_SP(SB, &current->thread.fp_regs.fprs[ry].f);
-        FP_CMP_S(IR, SA, SB, 3);
-        /*
-         * IR == -1 if DA < DB, IR == 0 if DA == DB,
-         * IR == 1 if DA > DB and IR == 3 if unorderded
-         */
-        emu_set_CC(regs, (IR == -1) ? 1 : (IR == 1) ? 2 : IR);
-        if (IR == 3)
-                FP_SET_EXCEPTION (FP_EX_INVALID);
-        return _fex;
-}
-
-/* Compare and signal float */
-static int emu_keb (struct pt_regs *regs, int rx, float *val) {
-        FP_DECL_S(SA); FP_DECL_S(SB);
-        FP_DECL_EX;
-        int IR;
-
-        FP_UNPACK_RAW_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-        FP_UNPACK_RAW_SP(SB, val);
-        FP_CMP_S(IR, SA, SB, 3);
-        /*
-         * IR == -1 if DA < DB, IR == 0 if DA == DB,
-         * IR == 1 if DA > DB and IR == 3 if unorderded
-         */
-        emu_set_CC(regs, (IR == -1) ? 1 : (IR == 1) ? 2 : IR);
-        if (IR == 3)
-                FP_SET_EXCEPTION (FP_EX_INVALID);
-        return _fex;
-}
-
-/* Convert from fixed long double */
-static int emu_cxfbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_Q(QR);
-        FP_DECL_EX;
-	mathemu_ldcv cvt;
-        __s32 si;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        si = regs->gprs[ry];
-        FP_FROM_INT_Q(QR, si, 32, int);
-        FP_PACK_QP(&cvt.ld, QR);
-        current->thread.fp_regs.fprs[rx].ui = cvt.w.high;
-        current->thread.fp_regs.fprs[rx+2].ui = cvt.w.low;
-        return _fex;
-}
-
-/* Convert from fixed double */
-static int emu_cdfbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_D(DR);
-        FP_DECL_EX;
-        __s32 si;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        si = regs->gprs[ry];
-        FP_FROM_INT_D(DR, si, 32, int);
-        FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-        return _fex;
-}
-
-/* Convert from fixed float */
-static int emu_cefbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_S(SR);
-        FP_DECL_EX;
-        __s32 si;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        si = regs->gprs[ry];
-        FP_FROM_INT_S(SR, si, 32, int);
-        FP_PACK_SP(&current->thread.fp_regs.fprs[rx].f, SR);
-        return _fex;
-}
-
-/* Convert to fixed long double */
-static int emu_cfxbr (struct pt_regs *regs, int rx, int ry, int mask) {
-        FP_DECL_Q(QA);
-        FP_DECL_EX;
-	mathemu_ldcv cvt;
-        __s32 si;
-        int mode;
-
-	if (mask == 0)
-		mode = current->thread.fp_regs.fpc & 3;
-	else if (mask == 1)
-		mode = FP_RND_NEAREST;
-	else
-		mode = mask - 4;
-        cvt.w.high = current->thread.fp_regs.fprs[ry].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[ry+2].ui;
-        FP_UNPACK_QP(QA, &cvt.ld);
-        FP_TO_INT_ROUND_Q(si, QA, 32, 1);
-        regs->gprs[rx] = si;
-        emu_set_CC_cs(regs, QA_c, QA_s);
-        return _fex;
-}
-
-/* Convert to fixed double */
-static int emu_cfdbr (struct pt_regs *regs, int rx, int ry, int mask) {
-        FP_DECL_D(DA);
-        FP_DECL_EX;
-        __s32 si;
-        int mode;
-
-	if (mask == 0)
-		mode = current->thread.fp_regs.fpc & 3;
-	else if (mask == 1)
-		mode = FP_RND_NEAREST;
-	else
-		mode = mask - 4;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[ry].d);
-        FP_TO_INT_ROUND_D(si, DA, 32, 1);
-        regs->gprs[rx] = si;
-        emu_set_CC_cs(regs, DA_c, DA_s);
-        return _fex;
-}
-
-/* Convert to fixed float */
-static int emu_cfebr (struct pt_regs *regs, int rx, int ry, int mask) {
-        FP_DECL_S(SA);
-        FP_DECL_EX;
-        __s32 si;
-        int mode;
-
-	if (mask == 0)
-		mode = current->thread.fp_regs.fpc & 3;
-	else if (mask == 1)
-		mode = FP_RND_NEAREST;
-	else
-		mode = mask - 4;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[ry].f);
-        FP_TO_INT_ROUND_S(si, SA, 32, 1);
-        regs->gprs[rx] = si;
-        emu_set_CC_cs(regs, SA_c, SA_s);
-        return _fex;
-}
-
-/* Divide long double */
-static int emu_dxbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_Q(QA); FP_DECL_Q(QB); FP_DECL_Q(QR);
-        FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        cvt.w.high = current->thread.fp_regs.fprs[rx].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[rx+2].ui;
-        FP_UNPACK_QP(QA, &cvt.ld);
-        cvt.w.high = current->thread.fp_regs.fprs[ry].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[ry+2].ui;
-        FP_UNPACK_QP(QB, &cvt.ld);
-        FP_DIV_Q(QR, QA, QB);
-        FP_PACK_QP(&cvt.ld, QR);
-        current->thread.fp_regs.fprs[rx].ui = cvt.w.high;
-        current->thread.fp_regs.fprs[rx+2].ui = cvt.w.low;
-        return _fex;
-}
-
-/* Divide double */
-static int emu_ddbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-        FP_UNPACK_DP(DB, &current->thread.fp_regs.fprs[ry].d);
-        FP_DIV_D(DR, DA, DB);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-        return _fex;
-}
-
-/* Divide double */
-static int emu_ddb (struct pt_regs *regs, int rx, double *val) {
-        FP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-        FP_UNPACK_DP(DB, val);
-        FP_DIV_D(DR, DA, DB);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-        return _fex;
-}
-
-/* Divide float */
-static int emu_debr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-        FP_UNPACK_SP(SB, &current->thread.fp_regs.fprs[ry].f);
-        FP_DIV_S(SR, SA, SB);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rx].f, SR);
-        return _fex;
-}
-
-/* Divide float */
-static int emu_deb (struct pt_regs *regs, int rx, float *val) {
-        FP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-        FP_UNPACK_SP(SB, val);
-        FP_DIV_S(SR, SA, SB);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rx].f, SR);
-        return _fex;
-}
-
-/* Divide to integer double */
-static int emu_didbr (struct pt_regs *regs, int rx, int ry, int mask) {
-        display_emulation_not_implemented(regs, "didbr");
-        return 0;
-}
-
-/* Divide to integer float */
-static int emu_diebr (struct pt_regs *regs, int rx, int ry, int mask) {
-        display_emulation_not_implemented(regs, "diebr");
-        return 0;
-}
-
-/* Extract fpc */
-static int emu_efpc (struct pt_regs *regs, int rx, int ry) {
-        regs->gprs[rx] = current->thread.fp_regs.fpc;
-        return 0;
-}
-
-/* Load and test long double */
-static int emu_ltxbr (struct pt_regs *regs, int rx, int ry) {
-        s390_fp_regs *fp_regs = &current->thread.fp_regs;
-	mathemu_ldcv cvt;
-        FP_DECL_Q(QA);
-        FP_DECL_EX;
-
-        cvt.w.high = current->thread.fp_regs.fprs[ry].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[ry+2].ui;
-        FP_UNPACK_QP(QA, &cvt.ld);
-        fp_regs->fprs[rx].ui = fp_regs->fprs[ry].ui;
-        fp_regs->fprs[rx+2].ui = fp_regs->fprs[ry+2].ui;
-        emu_set_CC_cs(regs, QA_c, QA_s);
-        return _fex;
-}
-
-/* Load and test double */
-static int emu_ltdbr (struct pt_regs *regs, int rx, int ry) {
-        s390_fp_regs *fp_regs = &current->thread.fp_regs;
-        FP_DECL_D(DA);
-        FP_DECL_EX;
-
-        FP_UNPACK_DP(DA, &fp_regs->fprs[ry].d);
-        fp_regs->fprs[rx].ui = fp_regs->fprs[ry].ui;
-        emu_set_CC_cs(regs, DA_c, DA_s);
-        return _fex;
-}
-
-/* Load and test double */
-static int emu_ltebr (struct pt_regs *regs, int rx, int ry) {
-        s390_fp_regs *fp_regs = &current->thread.fp_regs;
-        FP_DECL_S(SA);
-        FP_DECL_EX;
-
-        FP_UNPACK_SP(SA, &fp_regs->fprs[ry].f);
-        fp_regs->fprs[rx].ui = fp_regs->fprs[ry].ui;
-        emu_set_CC_cs(regs, SA_c, SA_s);
-        return _fex;
-}
-
-/* Load complement long double */
-static int emu_lcxbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_Q(QA); FP_DECL_Q(QR);
-        FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        cvt.w.high = current->thread.fp_regs.fprs[ry].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[ry+2].ui;
-        FP_UNPACK_QP(QA, &cvt.ld);
-	FP_NEG_Q(QR, QA);
-        FP_PACK_QP(&cvt.ld, QR);
-        current->thread.fp_regs.fprs[rx].ui = cvt.w.high;
-        current->thread.fp_regs.fprs[rx+2].ui = cvt.w.low;
-        emu_set_CC_cs(regs, QR_c, QR_s);
-        return _fex;
-}
-
-/* Load complement double */
-static int emu_lcdbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_D(DA); FP_DECL_D(DR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[ry].d);
-	FP_NEG_D(DR, DA);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-        emu_set_CC_cs(regs, DR_c, DR_s);
-        return _fex;
-}
-
-/* Load complement float */
-static int emu_lcebr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_S(SA); FP_DECL_S(SR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[ry].f);
-	FP_NEG_S(SR, SA);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rx].f, SR);
-        emu_set_CC_cs(regs, SR_c, SR_s);
-        return _fex;
-}
-
-/* Load floating point integer long double */
-static int emu_fixbr (struct pt_regs *regs, int rx, int ry, int mask) {
-        s390_fp_regs *fp_regs = &current->thread.fp_regs;
-        FP_DECL_Q(QA);
-        FP_DECL_EX;
-	mathemu_ldcv cvt;
-        __s32 si;
-        int mode;
-
-	if (mask == 0)
-		mode = fp_regs->fpc & 3;
-	else if (mask == 1)
-		mode = FP_RND_NEAREST;
-	else
-		mode = mask - 4;
-        cvt.w.high = fp_regs->fprs[ry].ui;
-        cvt.w.low = fp_regs->fprs[ry+2].ui;
-        FP_UNPACK_QP(QA, &cvt.ld);
-	FP_TO_FPINT_ROUND_Q(QA);
-	FP_PACK_QP(&cvt.ld, QA);
-	fp_regs->fprs[rx].ui = cvt.w.high;
-	fp_regs->fprs[rx+2].ui = cvt.w.low;
-        return _fex;
-}
-
-/* Load floating point integer double */
-static int emu_fidbr (struct pt_regs *regs, int rx, int ry, int mask) {
-	/* FIXME: rounding mode !! */
-        s390_fp_regs *fp_regs = &current->thread.fp_regs;
-        FP_DECL_D(DA);
-        FP_DECL_EX;
-        __s32 si;
-        int mode;
-
-	if (mask == 0)
-		mode = fp_regs->fpc & 3;
-	else if (mask == 1)
-		mode = FP_RND_NEAREST;
-	else
-		mode = mask - 4;
-        FP_UNPACK_DP(DA, &fp_regs->fprs[ry].d);
-	FP_TO_FPINT_ROUND_D(DA);
-	FP_PACK_DP(&fp_regs->fprs[rx].d, DA);
-        return _fex;
-}
-
-/* Load floating point integer float */
-static int emu_fiebr (struct pt_regs *regs, int rx, int ry, int mask) {
-        s390_fp_regs *fp_regs = &current->thread.fp_regs;
-        FP_DECL_S(SA);
-        FP_DECL_EX;
-        __s32 si;
-        int mode;
-
-	if (mask == 0)
-		mode = fp_regs->fpc & 3;
-	else if (mask == 1)
-		mode = FP_RND_NEAREST;
-	else
-		mode = mask - 4;
-        FP_UNPACK_SP(SA, &fp_regs->fprs[ry].f);
-	FP_TO_FPINT_ROUND_S(SA);
-	FP_PACK_SP(&fp_regs->fprs[rx].f, SA);
-        return _fex;
-}
-
-/* Load lengthened double to long double */
-static int emu_lxdbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_D(DA); FP_DECL_Q(QR);
-	FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[ry].d);
-	FP_CONV (Q, D, 4, 2, QR, DA);
-        FP_PACK_QP(&cvt.ld, QR);
-        current->thread.fp_regs.fprs[rx].ui = cvt.w.high;
-        current->thread.fp_regs.fprs[rx+2].ui = cvt.w.low;
-        return _fex;
-}
-
-/* Load lengthened double to long double */
-static int emu_lxdb (struct pt_regs *regs, int rx, double *val) {
-        FP_DECL_D(DA); FP_DECL_Q(QR);
-	FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, val);
-	FP_CONV (Q, D, 4, 2, QR, DA);
-        FP_PACK_QP(&cvt.ld, QR);
-        current->thread.fp_regs.fprs[rx].ui = cvt.w.high;
-        current->thread.fp_regs.fprs[rx+2].ui = cvt.w.low;
-        return _fex;
-}
-
-/* Load lengthened float to long double */
-static int emu_lxebr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_S(SA); FP_DECL_Q(QR);
-	FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[ry].f);
-	FP_CONV (Q, S, 4, 1, QR, SA);
-        FP_PACK_QP(&cvt.ld, QR);
-        current->thread.fp_regs.fprs[rx].ui = cvt.w.high;
-        current->thread.fp_regs.fprs[rx+2].ui = cvt.w.low;
-        return _fex;
-}
-
-/* Load lengthened float to long double */
-static int emu_lxeb (struct pt_regs *regs, int rx, float *val) {
-        FP_DECL_S(SA); FP_DECL_Q(QR);
-	FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, val);
-	FP_CONV (Q, S, 4, 1, QR, SA);
-        FP_PACK_QP(&cvt.ld, QR);
-        current->thread.fp_regs.fprs[rx].ui = cvt.w.high;
-        current->thread.fp_regs.fprs[rx+2].ui = cvt.w.low;
-        return _fex;
-}
-
-/* Load lengthened float to double */
-static int emu_ldebr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_S(SA); FP_DECL_D(DR);
-	FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[ry].f);
-	FP_CONV (D, S, 2, 1, DR, SA);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-        return _fex;
-}
-
-/* Load lengthened float to double */
-static int emu_ldeb (struct pt_regs *regs, int rx, float *val) {
-        FP_DECL_S(SA); FP_DECL_D(DR);
-	FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, val);
-	FP_CONV (D, S, 2, 1, DR, SA);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-        return _fex;
-}
-
-/* Load negative long double */
-static int emu_lnxbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_Q(QA); FP_DECL_Q(QR);
-	FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        cvt.w.high = current->thread.fp_regs.fprs[ry].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[ry+2].ui;
-        FP_UNPACK_QP(QA, &cvt.ld);
-        if (QA_s == 0) {
-		FP_NEG_Q(QR, QA);
-		FP_PACK_QP(&cvt.ld, QR);
-		current->thread.fp_regs.fprs[rx].ui = cvt.w.high;
-		current->thread.fp_regs.fprs[rx+2].ui = cvt.w.low;
-	} else {
-		current->thread.fp_regs.fprs[rx].ui =
-			current->thread.fp_regs.fprs[ry].ui;
-		current->thread.fp_regs.fprs[rx+2].ui =
-			current->thread.fp_regs.fprs[ry+2].ui;
-	}
-	emu_set_CC_cs(regs, QR_c, QR_s);
-        return _fex;
-}
-
-/* Load negative double */
-static int emu_lndbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_D(DA); FP_DECL_D(DR);
-	FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[ry].d);
-        if (DA_s == 0) {
-		FP_NEG_D(DR, DA);
-		FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-	} else
-		current->thread.fp_regs.fprs[rx].ui =
-			current->thread.fp_regs.fprs[ry].ui;
-	emu_set_CC_cs(regs, DR_c, DR_s);
-        return _fex;
-}
-
-/* Load negative float */
-static int emu_lnebr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_S(SA); FP_DECL_S(SR);
-	FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[ry].f);
-        if (SA_s == 0) {
-		FP_NEG_S(SR, SA);
-		FP_PACK_SP(&current->thread.fp_regs.fprs[rx].f, SR);
-	} else
-		current->thread.fp_regs.fprs[rx].ui =
-			current->thread.fp_regs.fprs[ry].ui;
-	emu_set_CC_cs(regs, SR_c, SR_s);
-        return _fex;
-}
-
-/* Load positive long double */
-static int emu_lpxbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_Q(QA); FP_DECL_Q(QR);
-	FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        cvt.w.high = current->thread.fp_regs.fprs[ry].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[ry+2].ui;
-        FP_UNPACK_QP(QA, &cvt.ld);
-        if (QA_s != 0) {
-		FP_NEG_Q(QR, QA);
-		FP_PACK_QP(&cvt.ld, QR);
-		current->thread.fp_regs.fprs[rx].ui = cvt.w.high;
-		current->thread.fp_regs.fprs[rx+2].ui = cvt.w.low;
-	} else{
-		current->thread.fp_regs.fprs[rx].ui =
-			current->thread.fp_regs.fprs[ry].ui;
-		current->thread.fp_regs.fprs[rx+2].ui =
-			current->thread.fp_regs.fprs[ry+2].ui;
-	}
-	emu_set_CC_cs(regs, QR_c, QR_s);
-        return _fex;
-}
-
-/* Load positive double */
-static int emu_lpdbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_D(DA); FP_DECL_D(DR);
-	FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[ry].d);
-        if (DA_s != 0) {
-		FP_NEG_D(DR, DA);
-		FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-	} else
-		current->thread.fp_regs.fprs[rx].ui =
-			current->thread.fp_regs.fprs[ry].ui;
-	emu_set_CC_cs(regs, DR_c, DR_s);
-        return _fex;
-}
-
-/* Load positive float */
-static int emu_lpebr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_S(SA); FP_DECL_S(SR);
-	FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[ry].f);
-        if (SA_s != 0) {
-		FP_NEG_S(SR, SA);
-		FP_PACK_SP(&current->thread.fp_regs.fprs[rx].f, SR);
-	} else
-		current->thread.fp_regs.fprs[rx].ui =
-			current->thread.fp_regs.fprs[ry].ui;
-	emu_set_CC_cs(regs, SR_c, SR_s);
-        return _fex;
-}
-
-/* Load rounded long double to double */
-static int emu_ldxbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_Q(QA); FP_DECL_D(DR);
-	FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        cvt.w.high = current->thread.fp_regs.fprs[ry].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[ry+2].ui;
-        FP_UNPACK_QP(QA, &cvt.ld);
-	FP_CONV (D, Q, 2, 4, DR, QA);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rx].f, DR);
-        return _fex;
-}
-
-/* Load rounded long double to float */
-static int emu_lexbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_Q(QA); FP_DECL_S(SR);
-	FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        cvt.w.high = current->thread.fp_regs.fprs[ry].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[ry+2].ui;
-        FP_UNPACK_QP(QA, &cvt.ld);
-	FP_CONV (S, Q, 1, 4, SR, QA);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rx].f, SR);
-        return _fex;
-}
-
-/* Load rounded double to float */
-static int emu_ledbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_D(DA); FP_DECL_S(SR);
-	FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[ry].d);
-	FP_CONV (S, D, 1, 2, SR, DA);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rx].f, SR);
-        return _fex;
-}
-
-/* Multiply long double */
-static int emu_mxbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_Q(QA); FP_DECL_Q(QB); FP_DECL_Q(QR);
-        FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        cvt.w.high = current->thread.fp_regs.fprs[rx].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[rx+2].ui;
-        FP_UNPACK_QP(QA, &cvt.ld);
-        cvt.w.high = current->thread.fp_regs.fprs[ry].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[ry+2].ui;
-        FP_UNPACK_QP(QB, &cvt.ld);
-        FP_MUL_Q(QR, QA, QB);
-        FP_PACK_QP(&cvt.ld, QR);
-        current->thread.fp_regs.fprs[rx].ui = cvt.w.high;
-        current->thread.fp_regs.fprs[rx+2].ui = cvt.w.low;
-        return _fex;
-}
-
-/* Multiply double */
-static int emu_mdbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-        FP_UNPACK_DP(DB, &current->thread.fp_regs.fprs[ry].d);
-        FP_MUL_D(DR, DA, DB);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-        return _fex;
-}
-
-/* Multiply double */
-static int emu_mdb (struct pt_regs *regs, int rx, double *val) {
-        FP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-        FP_UNPACK_DP(DB, val);
-        FP_MUL_D(DR, DA, DB);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-        return _fex;
-}
-
-/* Multiply double to long double */
-static int emu_mxdbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_D(DA); FP_DECL_Q(QA); FP_DECL_Q(QB); FP_DECL_Q(QR);
-	FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-	FP_CONV (Q, D, 4, 2, QA, DA);
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[ry].d);
-	FP_CONV (Q, D, 4, 2, QB, DA);
-        FP_MUL_Q(QR, QA, QB);
-        FP_PACK_QP(&cvt.ld, QR);
-        current->thread.fp_regs.fprs[rx].ui = cvt.w.high;
-        current->thread.fp_regs.fprs[rx+2].ui = cvt.w.low;
-        return _fex;
-}
-
-/* Multiply double to long double */
-static int emu_mxdb (struct pt_regs *regs, int rx, long double *val) {
-        FP_DECL_Q(QA); FP_DECL_Q(QB); FP_DECL_Q(QR);
-        FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        cvt.w.high = current->thread.fp_regs.fprs[rx].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[rx+2].ui;
-        FP_UNPACK_QP(QA, &cvt.ld);
-        FP_UNPACK_QP(QB, val);
-        FP_MUL_Q(QR, QA, QB);
-        FP_PACK_QP(&cvt.ld, QR);
-        current->thread.fp_regs.fprs[rx].ui = cvt.w.high;
-        current->thread.fp_regs.fprs[rx+2].ui = cvt.w.low;
-        return _fex;
-}
-
-/* Multiply float */
-static int emu_meebr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-        FP_UNPACK_SP(SB, &current->thread.fp_regs.fprs[ry].f);
-        FP_MUL_S(SR, SA, SB);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rx].f, SR);
-        return _fex;
-}
-
-/* Multiply float */
-static int emu_meeb (struct pt_regs *regs, int rx, float *val) {
-        FP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-        FP_UNPACK_SP(SB, val);
-        FP_MUL_S(SR, SA, SB);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rx].f, SR);
-        return _fex;
-}
-
-/* Multiply float to double */
-static int emu_mdebr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_S(SA); FP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DR);
-	FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-	FP_CONV (D, S, 2, 1, DA, SA);
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[ry].f);
-	FP_CONV (D, S, 2, 1, DB, SA);
-        FP_MUL_D(DR, DA, DB);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-        return _fex;
-}
-
-/* Multiply float to double */
-static int emu_mdeb (struct pt_regs *regs, int rx, float *val) {
-        FP_DECL_S(SA); FP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DR);
-	FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-	FP_CONV (D, S, 2, 1, DA, SA);
-        FP_UNPACK_SP(SA, val);
-	FP_CONV (D, S, 2, 1, DB, SA);
-        FP_MUL_D(DR, DA, DB);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-        return _fex;
-}
-
-/* Multiply and add double */
-static int emu_madbr (struct pt_regs *regs, int rx, int ry, int rz) {
-        FP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DC); FP_DECL_D(DR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-        FP_UNPACK_DP(DB, &current->thread.fp_regs.fprs[ry].d);
-        FP_UNPACK_DP(DC, &current->thread.fp_regs.fprs[rz].d);
-        FP_MUL_D(DR, DA, DB);
-        FP_ADD_D(DR, DR, DC);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rz].d, DR);
-        return _fex;
-}
-
-/* Multiply and add double */
-static int emu_madb (struct pt_regs *regs, int rx, double *val, int rz) {
-        FP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DC); FP_DECL_D(DR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-        FP_UNPACK_DP(DB, val);
-        FP_UNPACK_DP(DC, &current->thread.fp_regs.fprs[rz].d);
-        FP_MUL_D(DR, DA, DB);
-        FP_ADD_D(DR, DR, DC);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rz].d, DR);
-        return _fex;
-}
-
-/* Multiply and add float */
-static int emu_maebr (struct pt_regs *regs, int rx, int ry, int rz) {
-        FP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SC); FP_DECL_S(SR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-        FP_UNPACK_SP(SB, &current->thread.fp_regs.fprs[ry].f);
-        FP_UNPACK_SP(SC, &current->thread.fp_regs.fprs[rz].f);
-        FP_MUL_S(SR, SA, SB);
-        FP_ADD_S(SR, SR, SC);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rz].f, SR);
-        return _fex;
-}
-
-/* Multiply and add float */
-static int emu_maeb (struct pt_regs *regs, int rx, float *val, int rz) {
-        FP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SC); FP_DECL_S(SR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-        FP_UNPACK_SP(SB, val);
-        FP_UNPACK_SP(SC, &current->thread.fp_regs.fprs[rz].f);
-        FP_MUL_S(SR, SA, SB);
-        FP_ADD_S(SR, SR, SC);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rz].f, SR);
-        return _fex;
-}
-
-/* Multiply and subtract double */
-static int emu_msdbr (struct pt_regs *regs, int rx, int ry, int rz) {
-        FP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DC); FP_DECL_D(DR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-        FP_UNPACK_DP(DB, &current->thread.fp_regs.fprs[ry].d);
-        FP_UNPACK_DP(DC, &current->thread.fp_regs.fprs[rz].d);
-        FP_MUL_D(DR, DA, DB);
-        FP_SUB_D(DR, DR, DC);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rz].d, DR);
-        return _fex;
-}
-
-/* Multiply and subtract double */
-static int emu_msdb (struct pt_regs *regs, int rx, double *val, int rz) {
-        FP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DC); FP_DECL_D(DR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-        FP_UNPACK_DP(DB, val);
-        FP_UNPACK_DP(DC, &current->thread.fp_regs.fprs[rz].d);
-        FP_MUL_D(DR, DA, DB);
-        FP_SUB_D(DR, DR, DC);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rz].d, DR);
-        return _fex;
-}
-
-/* Multiply and subtract float */
-static int emu_msebr (struct pt_regs *regs, int rx, int ry, int rz) {
-        FP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SC); FP_DECL_S(SR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-        FP_UNPACK_SP(SB, &current->thread.fp_regs.fprs[ry].f);
-        FP_UNPACK_SP(SC, &current->thread.fp_regs.fprs[rz].f);
-        FP_MUL_S(SR, SA, SB);
-        FP_SUB_S(SR, SR, SC);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rz].f, SR);
-        return _fex;
-}
-
-/* Multiply and subtract float */
-static int emu_mseb (struct pt_regs *regs, int rx, float *val, int rz) {
-        FP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SC); FP_DECL_S(SR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-        FP_UNPACK_SP(SB, val);
-        FP_UNPACK_SP(SC, &current->thread.fp_regs.fprs[rz].f);
-        FP_MUL_S(SR, SA, SB);
-        FP_SUB_S(SR, SR, SC);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rz].f, SR);
-        return _fex;
-}
-
-/* Set floating point control word */
-static int emu_sfpc (struct pt_regs *regs, int rx, int ry) {
-        __u32 temp;
-
-        temp = regs->gprs[rx];
-        if ((temp & ~FPC_VALID_MASK) != 0)
-		return SIGILL;
-	current->thread.fp_regs.fpc = temp;
-        return 0;
-}
-
-/* Square root long double */
-static int emu_sqxbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_Q(QA); FP_DECL_Q(QR);
-        FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        cvt.w.high = current->thread.fp_regs.fprs[ry].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[ry+2].ui;
-        FP_UNPACK_QP(QA, &cvt.ld);
-	FP_SQRT_Q(QR, QA);
-        FP_PACK_QP(&cvt.ld, QR);
-        current->thread.fp_regs.fprs[rx].ui = cvt.w.high;
-        current->thread.fp_regs.fprs[rx+2].ui = cvt.w.low;
-        emu_set_CC_cs(regs, QR_c, QR_s);
-        return _fex;
-}
-
-/* Square root double */
-static int emu_sqdbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_D(DA); FP_DECL_D(DR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[ry].d);
-	FP_SQRT_D(DR, DA);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-        emu_set_CC_cs(regs, DR_c, DR_s);
-        return _fex;
-}
-
-/* Square root double */
-static int emu_sqdb (struct pt_regs *regs, int rx, double *val) {
-        FP_DECL_D(DA); FP_DECL_D(DR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, val);
-	FP_SQRT_D(DR, DA);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-        emu_set_CC_cs(regs, DR_c, DR_s);
-        return _fex;
-}
-
-/* Square root float */
-static int emu_sqebr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_S(SA); FP_DECL_S(SR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[ry].f);
-	FP_SQRT_S(SR, SA);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rx].f, SR);
-        emu_set_CC_cs(regs, SR_c, SR_s);
-        return _fex;
-}
-
-/* Square root float */
-static int emu_sqeb (struct pt_regs *regs, int rx, float *val) {
-        FP_DECL_S(SA); FP_DECL_S(SR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, val);
-	FP_SQRT_S(SR, SA);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rx].f, SR);
-        emu_set_CC_cs(regs, SR_c, SR_s);
-        return _fex;
-}
-
-/* Subtract long double */
-static int emu_sxbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_Q(QA); FP_DECL_Q(QB); FP_DECL_Q(QR);
-        FP_DECL_EX;
-	mathemu_ldcv cvt;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        cvt.w.high = current->thread.fp_regs.fprs[rx].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[rx+2].ui;
-        FP_UNPACK_QP(QA, &cvt.ld);
-        cvt.w.high = current->thread.fp_regs.fprs[ry].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[ry+2].ui;
-        FP_UNPACK_QP(QB, &cvt.ld);
-        FP_SUB_Q(QR, QA, QB);
-        FP_PACK_QP(&cvt.ld, QR);
-        current->thread.fp_regs.fprs[rx].ui = cvt.w.high;
-        current->thread.fp_regs.fprs[rx+2].ui = cvt.w.low;
-        emu_set_CC_cs(regs, QR_c, QR_s);
-        return _fex;
-}
-
-/* Subtract double */
-static int emu_sdbr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-        FP_UNPACK_DP(DB, &current->thread.fp_regs.fprs[ry].d);
-        FP_SUB_D(DR, DA, DB);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-        emu_set_CC_cs(regs, DR_c, DR_s);
-        return _fex;
-}
-
-/* Subtract double */
-static int emu_sdb (struct pt_regs *regs, int rx, double *val) {
-        FP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-        FP_UNPACK_DP(DB, val);
-        FP_SUB_D(DR, DA, DB);
-	FP_PACK_DP(&current->thread.fp_regs.fprs[rx].d, DR);
-        emu_set_CC_cs(regs, DR_c, DR_s);
-        return _fex;
-}
-
-/* Subtract float */
-static int emu_sebr (struct pt_regs *regs, int rx, int ry) {
-        FP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-        FP_UNPACK_SP(SB, &current->thread.fp_regs.fprs[ry].f);
-        FP_SUB_S(SR, SA, SB);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rx].f, SR);
-        emu_set_CC_cs(regs, SR_c, SR_s);
-        return _fex;
-}
-
-/* Subtract float */
-static int emu_seb (struct pt_regs *regs, int rx, float *val) {
-        FP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SR);
-        FP_DECL_EX;
-        int mode;
-
-	mode = current->thread.fp_regs.fpc & 3;
-        FP_UNPACK_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-        FP_UNPACK_SP(SB, val);
-        FP_SUB_S(SR, SA, SB);
-	FP_PACK_SP(&current->thread.fp_regs.fprs[rx].f, SR);
-        emu_set_CC_cs(regs, SR_c, SR_s);
-        return _fex;
-}
-
-/* Test data class long double */
-static int emu_tcxb (struct pt_regs *regs, int rx, long val) {
-        FP_DECL_Q(QA);
-	mathemu_ldcv cvt;
-	int bit;
-
-        cvt.w.high = current->thread.fp_regs.fprs[rx].ui;
-        cvt.w.low = current->thread.fp_regs.fprs[rx+2].ui;
-        FP_UNPACK_RAW_QP(QA, &cvt.ld);
-	switch (QA_e) {
-	default:
-		bit = 8;		/* normalized number */
-		break;
-	case 0:
-		if (_FP_FRAC_ZEROP_4(QA))
-			bit = 10;	/* zero */
-		else
-			bit = 6;	/* denormalized number */
-		break;
-	case _FP_EXPMAX_Q:
-		if (_FP_FRAC_ZEROP_4(QA))
-			bit = 4;	/* infinity */
-		else if (_FP_FRAC_HIGH_RAW_Q(QA) & _FP_QNANBIT_Q)
-			bit = 2;	/* quiet NAN */
-		else
-			bit = 0;	/* signaling NAN */
-		break;
-	}
-	if (!QA_s)
-		bit++;
-	emu_set_CC(regs, ((__u32) val >> bit) & 1);
-        return 0;
-}
-
-/* Test data class double */
-static int emu_tcdb (struct pt_regs *regs, int rx, long val) {
-        FP_DECL_D(DA);
-	int bit;
-
-        FP_UNPACK_RAW_DP(DA, &current->thread.fp_regs.fprs[rx].d);
-	switch (DA_e) {
-	default:
-		bit = 8;		/* normalized number */
-		break;
-	case 0:
-		if (_FP_FRAC_ZEROP_2(DA))
-			bit = 10;	/* zero */
-		else
-			bit = 6;	/* denormalized number */
-		break;
-	case _FP_EXPMAX_D:
-		if (_FP_FRAC_ZEROP_2(DA))
-			bit = 4;	/* infinity */
-		else if (_FP_FRAC_HIGH_RAW_D(DA) & _FP_QNANBIT_D)
-			bit = 2;	/* quiet NAN */
-		else
-			bit = 0;	/* signaling NAN */
-		break;
-	}
-	if (!DA_s)
-		bit++;
-	emu_set_CC(regs, ((__u32) val >> bit) & 1);
-        return 0;
-}
-
-/* Test data class float */
-static int emu_tceb (struct pt_regs *regs, int rx, long val) {
-        FP_DECL_S(SA);
-	int bit;
-
-        FP_UNPACK_RAW_SP(SA, &current->thread.fp_regs.fprs[rx].f);
-	switch (SA_e) {
-	default:
-		bit = 8;		/* normalized number */
-		break;
-	case 0:
-		if (_FP_FRAC_ZEROP_1(SA))
-			bit = 10;	/* zero */
-		else
-			bit = 6;	/* denormalized number */
-		break;
-	case _FP_EXPMAX_S:
-		if (_FP_FRAC_ZEROP_1(SA))
-			bit = 4;	/* infinity */
-		else if (_FP_FRAC_HIGH_RAW_S(SA) & _FP_QNANBIT_S)
-			bit = 2;	/* quiet NAN */
-		else
-			bit = 0;	/* signaling NAN */
-		break;
-	}
-	if (!SA_s)
-		bit++;
-	emu_set_CC(regs, ((__u32) val >> bit) & 1);
-        return 0;
-}
-
-static inline void emu_load_regd(int reg) {
-	if ((reg&9) != 0)	/* test if reg in {0,2,4,6} */
-                return;
-	asm volatile(		/* load reg from fp_regs.fprs[reg] */
-		"	bras	1,0f\n"
-		"	ld	0,0(%1)\n"
-		"0:	ex	%0,0(1)"
-		: /* no output */
-		: "a" (reg<<4),"a" (&current->thread.fp_regs.fprs[reg].d)
-		: "1");
-}
-
-static inline void emu_load_rege(int reg) {
-	if ((reg&9) != 0)	/* test if reg in {0,2,4,6} */
-                return;
-	asm volatile(		/* load reg from fp_regs.fprs[reg] */
-		"	bras	1,0f\n"
-		"	le	0,0(%1)\n"
-		"0:	ex	%0,0(1)"
-		: /* no output */
-		: "a" (reg<<4), "a" (&current->thread.fp_regs.fprs[reg].f)
-		: "1");
-}
-
-static inline void emu_store_regd(int reg) {
-	if ((reg&9) != 0)	/* test if reg in {0,2,4,6} */
-                return;
-	asm volatile(		/* store reg to fp_regs.fprs[reg] */
-		"	bras	1,0f\n"
-		"	std	0,0(%1)\n"
-		"0:	ex	%0,0(1)"
-		: /* no output */
-		: "a" (reg<<4), "a" (&current->thread.fp_regs.fprs[reg].d)
-		: "1");
-}
-
-
-static inline void emu_store_rege(int reg) {
-	if ((reg&9) != 0)	/* test if reg in {0,2,4,6} */
-                return;
-	asm volatile(		/* store reg to fp_regs.fprs[reg] */
-		"	bras	1,0f\n"
-		"	ste	0,0(%1)\n"
-		"0:	ex	%0,0(1)"
-		: /* no output */
-		: "a" (reg<<4), "a" (&current->thread.fp_regs.fprs[reg].f)
-		: "1");
-}
-
-int math_emu_b3(__u8 *opcode, struct pt_regs * regs) {
-        int _fex = 0;
-        static const __u8 format_table[256] = {
-                [0x00] = 0x03,[0x01] = 0x03,[0x02] = 0x03,[0x03] = 0x03,
-		[0x04] = 0x0f,[0x05] = 0x0d,[0x06] = 0x0e,[0x07] = 0x0d,
-		[0x08] = 0x03,[0x09] = 0x03,[0x0a] = 0x03,[0x0b] = 0x03,
-                [0x0c] = 0x0f,[0x0d] = 0x03,[0x0e] = 0x06,[0x0f] = 0x06,
-		[0x10] = 0x02,[0x11] = 0x02,[0x12] = 0x02,[0x13] = 0x02,
-		[0x14] = 0x03,[0x15] = 0x02,[0x16] = 0x01,[0x17] = 0x03,
-                [0x18] = 0x02,[0x19] = 0x02,[0x1a] = 0x02,[0x1b] = 0x02,
-		[0x1c] = 0x02,[0x1d] = 0x02,[0x1e] = 0x05,[0x1f] = 0x05,
-		[0x40] = 0x01,[0x41] = 0x01,[0x42] = 0x01,[0x43] = 0x01,
-                [0x44] = 0x12,[0x45] = 0x0d,[0x46] = 0x11,[0x47] = 0x04,
-		[0x48] = 0x01,[0x49] = 0x01,[0x4a] = 0x01,[0x4b] = 0x01,
-		[0x4c] = 0x01,[0x4d] = 0x01,[0x53] = 0x06,[0x57] = 0x06,
-                [0x5b] = 0x05,[0x5f] = 0x05,[0x84] = 0x13,[0x8c] = 0x13,
-		[0x94] = 0x09,[0x95] = 0x08,[0x96] = 0x07,[0x98] = 0x0c,
-		[0x99] = 0x0b,[0x9a] = 0x0a
-        };
-        static const void *jump_table[256]= {
-                [0x00] = emu_lpebr,[0x01] = emu_lnebr,[0x02] = emu_ltebr,
-                [0x03] = emu_lcebr,[0x04] = emu_ldebr,[0x05] = emu_lxdbr,
-                [0x06] = emu_lxebr,[0x07] = emu_mxdbr,[0x08] = emu_kebr,
-                [0x09] = emu_cebr, [0x0a] = emu_aebr, [0x0b] = emu_sebr,
-                [0x0c] = emu_mdebr,[0x0d] = emu_debr, [0x0e] = emu_maebr,
-                [0x0f] = emu_msebr,[0x10] = emu_lpdbr,[0x11] = emu_lndbr, 
-                [0x12] = emu_ltdbr,[0x13] = emu_lcdbr,[0x14] = emu_sqebr,
-                [0x15] = emu_sqdbr,[0x16] = emu_sqxbr,[0x17] = emu_meebr,
-                [0x18] = emu_kdbr, [0x19] = emu_cdbr, [0x1a] = emu_adbr,
-                [0x1b] = emu_sdbr, [0x1c] = emu_mdbr, [0x1d] = emu_ddbr,  
-                [0x1e] = emu_madbr,[0x1f] = emu_msdbr,[0x40] = emu_lpxbr,
-                [0x41] = emu_lnxbr,[0x42] = emu_ltxbr,[0x43] = emu_lcxbr,
-                [0x44] = emu_ledbr,[0x45] = emu_ldxbr,[0x46] = emu_lexbr,
-                [0x47] = emu_fixbr,[0x48] = emu_kxbr, [0x49] = emu_cxbr,  
-                [0x4a] = emu_axbr, [0x4b] = emu_sxbr, [0x4c] = emu_mxbr,
-                [0x4d] = emu_dxbr, [0x53] = emu_diebr,[0x57] = emu_fiebr,
-                [0x5b] = emu_didbr,[0x5f] = emu_fidbr,[0x84] = emu_sfpc,
-                [0x8c] = emu_efpc, [0x94] = emu_cefbr,[0x95] = emu_cdfbr, 
-                [0x96] = emu_cxfbr,[0x98] = emu_cfebr,[0x99] = emu_cfdbr,
-                [0x9a] = emu_cfxbr
-        };
-
-        switch (format_table[opcode[1]]) {
-        case 1: /* RRE format, long double operation */
-                if (opcode[3] & 0x22)
-			return SIGILL;
-                emu_store_regd((opcode[3] >> 4) & 15);
-                emu_store_regd(((opcode[3] >> 4) & 15) + 2);
-                emu_store_regd(opcode[3] & 15);
-                emu_store_regd((opcode[3] & 15) + 2);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *,int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15);
-                emu_load_regd((opcode[3] >> 4) & 15);
-                emu_load_regd(((opcode[3] >> 4) & 15) + 2);
-                emu_load_regd(opcode[3] & 15);
-                emu_load_regd((opcode[3] & 15) + 2);
-		break;
-        case 2: /* RRE format, double operation */
-                emu_store_regd((opcode[3] >> 4) & 15);
-                emu_store_regd(opcode[3] & 15);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15);
-                emu_load_regd((opcode[3] >> 4) & 15);
-                emu_load_regd(opcode[3] & 15);
-		break;
-        case 3: /* RRE format, float operation */
-                emu_store_rege((opcode[3] >> 4) & 15);
-                emu_store_rege(opcode[3] & 15);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15);
-                emu_load_rege((opcode[3] >> 4) & 15);
-                emu_load_rege(opcode[3] & 15);
-		break;
-        case 4: /* RRF format, long double operation */
-                if (opcode[3] & 0x22)
-			return SIGILL;
-                emu_store_regd((opcode[3] >> 4) & 15);
-                emu_store_regd(((opcode[3] >> 4) & 15) + 2);
-                emu_store_regd(opcode[3] & 15);
-                emu_store_regd((opcode[3] & 15) + 2);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15, opcode[2] >> 4);
-                emu_load_regd((opcode[3] >> 4) & 15);
-                emu_load_regd(((opcode[3] >> 4) & 15) + 2);
-                emu_load_regd(opcode[3] & 15);
-                emu_load_regd((opcode[3] & 15) + 2);
-		break;
-        case 5: /* RRF format, double operation */
-                emu_store_regd((opcode[2] >> 4) & 15);
-                emu_store_regd((opcode[3] >> 4) & 15);
-                emu_store_regd(opcode[3] & 15);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15, opcode[2] >> 4);
-                emu_load_regd((opcode[2] >> 4) & 15);
-                emu_load_regd((opcode[3] >> 4) & 15);
-                emu_load_regd(opcode[3] & 15);
-		break;
-        case 6: /* RRF format, float operation */
-                emu_store_rege((opcode[2] >> 4) & 15);
-                emu_store_rege((opcode[3] >> 4) & 15);
-                emu_store_rege(opcode[3] & 15);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15, opcode[2] >> 4);
-                emu_load_rege((opcode[2] >> 4) & 15);
-                emu_load_rege((opcode[3] >> 4) & 15);
-                emu_load_rege(opcode[3] & 15);
-		break;
-        case 7: /* RRE format, cxfbr instruction */
-                /* call the emulation function */
-                if (opcode[3] & 0x20)
-			return SIGILL;
-                _fex = ((int (*)(struct pt_regs *, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15);
-                emu_load_regd((opcode[3] >> 4) & 15);
-                emu_load_regd(((opcode[3] >> 4) & 15) + 2);
-		break;
-        case 8: /* RRE format, cdfbr instruction */
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15);
-                emu_load_regd((opcode[3] >> 4) & 15);
-		break;
-        case 9: /* RRE format, cefbr instruction */
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15);
-                emu_load_rege((opcode[3] >> 4) & 15);
-		break;
-        case 10: /* RRF format, cfxbr instruction */
-                if ((opcode[2] & 128) == 128 || (opcode[2] & 96) == 32)
-			/* mask of { 2,3,8-15 } is invalid */
-			return SIGILL;
-                if (opcode[3] & 2)
-			return SIGILL;
-                emu_store_regd(opcode[3] & 15);
-                emu_store_regd((opcode[3] & 15) + 2);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15, opcode[2] >> 4);
-		break;
-        case 11: /* RRF format, cfdbr instruction */
-                if ((opcode[2] & 128) == 128 || (opcode[2] & 96) == 32)
-			/* mask of { 2,3,8-15 } is invalid */
-			return SIGILL;
-                emu_store_regd(opcode[3] & 15);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15, opcode[2] >> 4);
-		break;
-        case 12: /* RRF format, cfebr instruction */
-                if ((opcode[2] & 128) == 128 || (opcode[2] & 96) == 32)
-			/* mask of { 2,3,8-15 } is invalid */
-			return SIGILL;
-                emu_store_rege(opcode[3] & 15);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15, opcode[2] >> 4);
-		break;
-        case 13: /* RRE format, ldxbr & mdxbr instruction */
-                /* double store but long double load */
-                if (opcode[3] & 0x20)
-			return SIGILL;
-                emu_store_regd((opcode[3] >> 4) & 15);
-                emu_store_regd(opcode[3]  & 15);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15);
-                emu_load_regd((opcode[3] >> 4) & 15);
-                emu_load_regd(((opcode[3] >> 4) & 15) + 2);
-		break;
-        case 14: /* RRE format, ldxbr & mdxbr instruction */
-                /* float store but long double load */
-                if (opcode[3] & 0x20)
-			return SIGILL;
-                emu_store_rege((opcode[3] >> 4) & 15);
-                emu_store_rege(opcode[3]  & 15);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15);
-                emu_load_regd((opcode[3] >> 4) & 15);
-                emu_load_regd(((opcode[3] >> 4) & 15) + 2);
-		break;
-        case 15: /* RRE format, ldebr & mdebr instruction */
-                /* float store but double load */
-                emu_store_rege((opcode[3] >> 4) & 15);
-                emu_store_rege(opcode[3]  & 15);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15);
-                emu_load_regd((opcode[3] >> 4) & 15);
-		break;
-        case 16: /* RRE format, ldxbr instruction */
-                /* long double store but double load */
-                if (opcode[3] & 2)
-			return SIGILL;
-                emu_store_regd(opcode[3] & 15);
-                emu_store_regd((opcode[3] & 15) + 2);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15);
-                emu_load_regd((opcode[3] >> 4) & 15);
-                break;
-        case 17: /* RRE format, ldxbr instruction */
-                /* long double store but float load */
-                if (opcode[3] & 2)
-			return SIGILL;
-                emu_store_regd(opcode[3] & 15);
-                emu_store_regd((opcode[3] & 15) + 2);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15);
-                emu_load_rege((opcode[3] >> 4) & 15);
-                break;
-        case 18: /* RRE format, ledbr instruction */
-                /* double store but float load */
-                emu_store_regd(opcode[3] & 15);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15);
-                emu_load_rege((opcode[3] >> 4) & 15);
-                break;
-        case 19: /* RRE format, efpc & sfpc instruction */
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, int))
-			jump_table[opcode[1]])
-                        (regs, opcode[3] >> 4, opcode[3] & 15);
-                break;
-        default: /* invalid operation */
-                return SIGILL;
-        }
-	if (_fex != 0) {
-		current->thread.fp_regs.fpc |= _fex;
-		if (current->thread.fp_regs.fpc & (_fex << 8))
-			return SIGFPE;
-	}
-	return 0;
-}
-
-static void* calc_addr(struct pt_regs *regs, int rx, int rb, int disp)
-{
-        addr_t addr;
-
-        rx &= 15;
-        rb &= 15;
-        addr = disp & 0xfff;
-        addr += (rx != 0) ? regs->gprs[rx] : 0;  /* + index */
-        addr += (rb != 0) ? regs->gprs[rb] : 0;  /* + base  */
-        return (void*) addr;
-}
-    
-int math_emu_ed(__u8 *opcode, struct pt_regs * regs) {
-        int _fex = 0;
-
-        static const __u8 format_table[256] = {
-                [0x04] = 0x06,[0x05] = 0x05,[0x06] = 0x07,[0x07] = 0x05,
-		[0x08] = 0x02,[0x09] = 0x02,[0x0a] = 0x02,[0x0b] = 0x02,
-		[0x0c] = 0x06,[0x0d] = 0x02,[0x0e] = 0x04,[0x0f] = 0x04,
-                [0x10] = 0x08,[0x11] = 0x09,[0x12] = 0x0a,[0x14] = 0x02,
-		[0x15] = 0x01,[0x17] = 0x02,[0x18] = 0x01,[0x19] = 0x01,
-		[0x1a] = 0x01,[0x1b] = 0x01,[0x1c] = 0x01,[0x1d] = 0x01,
-                [0x1e] = 0x03,[0x1f] = 0x03,
-        };
-        static const void *jump_table[]= {
-                [0x04] = emu_ldeb,[0x05] = emu_lxdb,[0x06] = emu_lxeb,
-                [0x07] = emu_mxdb,[0x08] = emu_keb, [0x09] = emu_ceb,
-                [0x0a] = emu_aeb, [0x0b] = emu_seb, [0x0c] = emu_mdeb,
-                [0x0d] = emu_deb, [0x0e] = emu_maeb,[0x0f] = emu_mseb,
-                [0x10] = emu_tceb,[0x11] = emu_tcdb,[0x12] = emu_tcxb,
-                [0x14] = emu_sqeb,[0x15] = emu_sqdb,[0x17] = emu_meeb,
-                [0x18] = emu_kdb, [0x19] = emu_cdb, [0x1a] = emu_adb,
-                [0x1b] = emu_sdb, [0x1c] = emu_mdb, [0x1d] = emu_ddb,
-                [0x1e] = emu_madb,[0x1f] = emu_msdb
-        };
-
-        switch (format_table[opcode[5]]) {
-        case 1: /* RXE format, double constant */ {
-                __u64 *dxb, temp;
-                __u32 opc;
-
-                emu_store_regd((opcode[1] >> 4) & 15);
-                opc = *((__u32 *) opcode);
-                dxb = (__u64 *) calc_addr(regs, opc >> 16, opc >> 12, opc);
-                mathemu_copy_from_user(&temp, dxb, 8);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, double *))
-			jump_table[opcode[5]])
-                        (regs, opcode[1] >> 4, (double *) &temp);
-                emu_load_regd((opcode[1] >> 4) & 15);
-                break;
-        }
-        case 2: /* RXE format, float constant */ {
-                __u32 *dxb, temp;
-                __u32 opc;
-
-                emu_store_rege((opcode[1] >> 4) & 15);
-                opc = *((__u32 *) opcode);
-                dxb = (__u32 *) calc_addr(regs, opc >> 16, opc >> 12, opc);
-                mathemu_get_user(temp, dxb);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, float *))
-			jump_table[opcode[5]])
-                        (regs, opcode[1] >> 4, (float *) &temp);
-                emu_load_rege((opcode[1] >> 4) & 15);
-                break;
-        }
-        case 3: /* RXF format, double constant */ {
-                __u64 *dxb, temp;
-                __u32 opc;
-
-                emu_store_regd((opcode[1] >> 4) & 15);
-                emu_store_regd((opcode[4] >> 4) & 15);
-                opc = *((__u32 *) opcode);
-                dxb = (__u64 *) calc_addr(regs, opc >> 16, opc >> 12, opc);
-                mathemu_copy_from_user(&temp, dxb, 8);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, double *, int))
-			jump_table[opcode[5]])
-                        (regs, opcode[1] >> 4, (double *) &temp, opcode[4] >> 4);
-                emu_load_regd((opcode[1] >> 4) & 15);
-                break;
-        }
-        case 4: /* RXF format, float constant */ {
-                __u32 *dxb, temp;
-                __u32 opc;
-
-                emu_store_rege((opcode[1] >> 4) & 15);
-                emu_store_rege((opcode[4] >> 4) & 15);
-                opc = *((__u32 *) opcode);
-                dxb = (__u32 *) calc_addr(regs, opc >> 16, opc >> 12, opc);
-                mathemu_get_user(temp, dxb);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, float *, int))
-			jump_table[opcode[5]])
-                        (regs, opcode[1] >> 4, (float *) &temp, opcode[4] >> 4);
-                emu_load_rege((opcode[4] >> 4) & 15);
-                break;
-        }
-        case 5: /* RXE format, double constant */
-                /* store double and load long double */ 
-        {
-                __u64 *dxb, temp;
-                __u32 opc;
-                if ((opcode[1] >> 4) & 0x20)
-			return SIGILL;
-                emu_store_regd((opcode[1] >> 4) & 15);
-                opc = *((__u32 *) opcode);
-                dxb = (__u64 *) calc_addr(regs, opc >> 16, opc >> 12, opc);
-                mathemu_copy_from_user(&temp, dxb, 8);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, double *))
-			jump_table[opcode[5]])
-                        (regs, opcode[1] >> 4, (double *) &temp);
-                emu_load_regd((opcode[1] >> 4) & 15);
-                emu_load_regd(((opcode[1] >> 4) & 15) + 2);
-                break;
-        }
-        case 6: /* RXE format, float constant */
-                /* store float and load double */ 
-        {
-                __u32 *dxb, temp;
-                __u32 opc;
-                emu_store_rege((opcode[1] >> 4) & 15);
-                opc = *((__u32 *) opcode);
-                dxb = (__u32 *) calc_addr(regs, opc >> 16, opc >> 12, opc);
-                mathemu_get_user(temp, dxb);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, float *))
-			jump_table[opcode[5]])
-                        (regs, opcode[1] >> 4, (float *) &temp);
-                emu_load_regd((opcode[1] >> 4) & 15);
-                break;
-        }
-        case 7: /* RXE format, float constant */
-                /* store float and load long double */ 
-        {
-                __u32 *dxb, temp;
-                __u32 opc;
-                if ((opcode[1] >> 4) & 0x20)
-			return SIGILL;
-                emu_store_rege((opcode[1] >> 4) & 15);
-                opc = *((__u32 *) opcode);
-                dxb = (__u32 *) calc_addr(regs, opc >> 16, opc >> 12, opc);
-                mathemu_get_user(temp, dxb);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, float *))
-			jump_table[opcode[5]])
-                        (regs, opcode[1] >> 4, (float *) &temp);
-                emu_load_regd((opcode[1] >> 4) & 15);
-                emu_load_regd(((opcode[1] >> 4) & 15) + 2);
-                break;
-        }
-        case 8: /* RXE format, RX address used as int value */ {
-                __u64 dxb;
-                __u32 opc;
-
-                emu_store_rege((opcode[1] >> 4) & 15);
-                opc = *((__u32 *) opcode);
-                dxb = (__u64) calc_addr(regs, opc >> 16, opc >> 12, opc);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, long))
-			jump_table[opcode[5]])
-                        (regs, opcode[1] >> 4, dxb);
-                break;
-        }
-        case 9: /* RXE format, RX address used as int value */ {
-                __u64 dxb;
-                __u32 opc;
-
-                emu_store_regd((opcode[1] >> 4) & 15);
-                opc = *((__u32 *) opcode);
-                dxb = (__u64) calc_addr(regs, opc >> 16, opc >> 12, opc);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, long))
-			jump_table[opcode[5]])
-                        (regs, opcode[1] >> 4, dxb);
-                break;
-        }
-        case 10: /* RXE format, RX address used as int value */ {
-                __u64 dxb;
-                __u32 opc;
-
-                if ((opcode[1] >> 4) & 2)
-			return SIGILL;
-                emu_store_regd((opcode[1] >> 4) & 15);
-                emu_store_regd(((opcode[1] >> 4) & 15) + 2);
-                opc = *((__u32 *) opcode);
-                dxb = (__u64) calc_addr(regs, opc >> 16, opc >> 12, opc);
-                /* call the emulation function */
-                _fex = ((int (*)(struct pt_regs *, int, long))
-			jump_table[opcode[5]])
-                        (regs, opcode[1] >> 4, dxb);
-                break;
-        }
-        default: /* invalid operation */
-                return SIGILL;
-        }
-	if (_fex != 0) {
-		current->thread.fp_regs.fpc |= _fex;
-		if (current->thread.fp_regs.fpc & (_fex << 8))
-			return SIGFPE;
-	}
-	return 0;
-}
-
-/*
- * Emulate LDR Rx,Ry with Rx or Ry not in {0, 2, 4, 6}
- */
-int math_emu_ldr(__u8 *opcode) {
-        s390_fp_regs *fp_regs = &current->thread.fp_regs;
-        __u16 opc = *((__u16 *) opcode);
-
-        if ((opc & 0x90) == 0) {           /* test if rx in {0,2,4,6} */
-                /* we got an exception therefore ry can't be in {0,2,4,6} */
-		asm volatile(		/* load rx from fp_regs.fprs[ry] */
-			"	bras	1,0f\n"
-			"	ld	0,0(%1)\n"
-			"0:	ex	%0,0(1)"
-			: /* no output */
-			: "a" (opc & 0xf0), "a" (&fp_regs->fprs[opc & 0xf].d)
-			: "1");
-        } else if ((opc & 0x9) == 0) {     /* test if ry in {0,2,4,6} */
-		asm volatile (		/* store ry to fp_regs.fprs[rx] */
-			"	bras	1,0f\n"
-			"	std	0,0(%1)\n"
-			"0:	ex	%0,0(1)"
-			: /* no output */
-			: "a" ((opc & 0xf) << 4),
-			  "a" (&fp_regs->fprs[(opc & 0xf0)>>4].d)
-			: "1");
-        } else  /* move fp_regs.fprs[ry] to fp_regs.fprs[rx] */
-                fp_regs->fprs[(opc & 0xf0) >> 4] = fp_regs->fprs[opc & 0xf];
-	return 0;
-}
-
-/*
- * Emulate LER Rx,Ry with Rx or Ry not in {0, 2, 4, 6}
- */
-int math_emu_ler(__u8 *opcode) {
-        s390_fp_regs *fp_regs = &current->thread.fp_regs;
-        __u16 opc = *((__u16 *) opcode);
-
-        if ((opc & 0x90) == 0) {           /* test if rx in {0,2,4,6} */
-                /* we got an exception therefore ry can't be in {0,2,4,6} */
-		asm volatile(		/* load rx from fp_regs.fprs[ry] */
-			"	bras	1,0f\n"
-			"	le	0,0(%1)\n"
-			"0:	ex	%0,0(1)"
-			: /* no output */
-			: "a" (opc & 0xf0), "a" (&fp_regs->fprs[opc & 0xf].f)
-			: "1");
-        } else if ((opc & 0x9) == 0) {     /* test if ry in {0,2,4,6} */
-		asm volatile(		/* store ry to fp_regs.fprs[rx] */
-			"	bras	1,0f\n"
-			"	ste	0,0(%1)\n"
-			"0:	ex	%0,0(1)"
-			: /* no output */
-			: "a" ((opc & 0xf) << 4),
-			  "a" (&fp_regs->fprs[(opc & 0xf0) >> 4].f)
-			: "1");
-        } else  /* move fp_regs.fprs[ry] to fp_regs.fprs[rx] */
-                fp_regs->fprs[(opc & 0xf0) >> 4] = fp_regs->fprs[opc & 0xf];
-	return 0;
-}
-
-/*
- * Emulate LD R,D(X,B) with R not in {0, 2, 4, 6}
- */
-int math_emu_ld(__u8 *opcode, struct pt_regs * regs) {
-        s390_fp_regs *fp_regs = &current->thread.fp_regs;
-        __u32 opc = *((__u32 *) opcode);
-        __u64 *dxb;
-
-        dxb = (__u64 *) calc_addr(regs, opc >> 16, opc >> 12, opc);
-        mathemu_copy_from_user(&fp_regs->fprs[(opc >> 20) & 0xf].d, dxb, 8);
-	return 0;
-}
-
-/*
- * Emulate LE R,D(X,B) with R not in {0, 2, 4, 6}
- */
-int math_emu_le(__u8 *opcode, struct pt_regs * regs) {
-        s390_fp_regs *fp_regs = &current->thread.fp_regs;
-        __u32 opc = *((__u32 *) opcode);
-        __u32 *mem, *dxb;
-
-        dxb = (__u32 *) calc_addr(regs, opc >> 16, opc >> 12, opc);
-        mem = (__u32 *) (&fp_regs->fprs[(opc >> 20) & 0xf].f);
-        mathemu_get_user(mem[0], dxb);
-	return 0;
-}
-
-/*
- * Emulate STD R,D(X,B) with R not in {0, 2, 4, 6}
- */
-int math_emu_std(__u8 *opcode, struct pt_regs * regs) {
-        s390_fp_regs *fp_regs = &current->thread.fp_regs;
-        __u32 opc = *((__u32 *) opcode);
-        __u64 *dxb;
-
-        dxb = (__u64 *) calc_addr(regs, opc >> 16, opc >> 12, opc);
-        mathemu_copy_to_user(dxb, &fp_regs->fprs[(opc >> 20) & 0xf].d, 8);
-	return 0;
-}
-
-/*
- * Emulate STE R,D(X,B) with R not in {0, 2, 4, 6}
- */
-int math_emu_ste(__u8 *opcode, struct pt_regs * regs) {
-        s390_fp_regs *fp_regs = &current->thread.fp_regs;
-        __u32 opc = *((__u32 *) opcode);
-        __u32 *mem, *dxb;
-
-        dxb = (__u32 *) calc_addr(regs, opc >> 16, opc >> 12, opc);
-        mem = (__u32 *) (&fp_regs->fprs[(opc >> 20) & 0xf].f);
-        mathemu_put_user(mem[0], dxb);
-	return 0;
-}
-
-/*
- * Emulate LFPC D(B)
- */
-int math_emu_lfpc(__u8 *opcode, struct pt_regs *regs) {
-        __u32 opc = *((__u32 *) opcode);
-        __u32 *dxb, temp;
-
-        dxb= (__u32 *) calc_addr(regs, 0, opc>>12, opc);
-        mathemu_get_user(temp, dxb);
-        if ((temp & ~FPC_VALID_MASK) != 0)
-		return SIGILL;
-	current->thread.fp_regs.fpc = temp;
-        return 0;
-}
-
-/*
- * Emulate STFPC D(B)
- */
-int math_emu_stfpc(__u8 *opcode, struct pt_regs *regs) {
-        __u32 opc = *((__u32 *) opcode);
-        __u32 *dxb;
-
-        dxb= (__u32 *) calc_addr(regs, 0, opc>>12, opc);
-        mathemu_put_user(current->thread.fp_regs.fpc, dxb);
-        return 0;
-}
-
-/*
- * Emulate SRNM D(B)
- */
-int math_emu_srnm(__u8 *opcode, struct pt_regs *regs) {
-        __u32 opc = *((__u32 *) opcode);
-        __u32 temp;
-
-        temp = calc_addr(regs, 0, opc>>12, opc);
-	current->thread.fp_regs.fpc &= ~3;
-        current->thread.fp_regs.fpc |= (temp & 3);
-        return 0;
-}
-
-/* broken compiler ... */
-long long
-__negdi2 (long long u)
-{
-
-  union lll {
-    long long ll;
-    long s[2];
-  };
-
-  union lll w,uu;
-
-  uu.ll = u;
-
-  w.s[1] = -uu.s[1];
-  w.s[0] = -uu.s[0] - ((int) w.s[1] != 0);
-
-  return w.ll;
-}
* Unmerged path arch/s390/mm/dump_pagetables.c
diff --git a/arch/s390/mm/extmem.c b/arch/s390/mm/extmem.c
index 519bba716cc3..23c496957c22 100644
--- a/arch/s390/mm/extmem.c
+++ b/arch/s390/mm/extmem.c
@@ -51,7 +51,6 @@ struct qout64 {
 	struct qrange range[6];
 };
 
-#ifdef CONFIG_64BIT
 struct qrange_old {
 	unsigned int start; /* last byte type */
 	unsigned int end;   /* last byte reserved */
@@ -65,7 +64,6 @@ struct qout64_old {
 	int segrcnt;
 	struct qrange_old range[6];
 };
-#endif
 
 struct qin64 {
 	char qopcode;
@@ -103,7 +101,6 @@ static int scode_set;
 static int
 dcss_set_subcodes(void)
 {
-#ifdef CONFIG_64BIT
 	char *name = kmalloc(8 * sizeof(char), GFP_KERNEL | GFP_DMA);
 	unsigned long rx, ry;
 	int rc;
@@ -135,7 +132,6 @@ dcss_set_subcodes(void)
 		segext_scode = DCSS_SEGEXTX;
 		return 0;
 	}
-#endif
 	/* Diag x'64' new subcodes are not supported, set to old subcodes */
 	loadshr_scode = DCSS_LOADNOLY;
 	loadnsr_scode = DCSS_LOADNSR;
@@ -208,7 +204,6 @@ dcss_diag(int *func, void *parameter,
 	rx = (unsigned long) parameter;
 	ry = (unsigned long) *func;
 
-#ifdef CONFIG_64BIT
 	/* 64-bit Diag x'64' new subcode, keep in 64-bit addressing mode */
 	if (*func > DCSS_SEGEXT)
 		asm volatile(
@@ -225,13 +220,6 @@ dcss_diag(int *func, void *parameter,
 			"	ipm	%2\n"
 			"	srl	%2,28\n"
 			: "+d" (rx), "+d" (ry), "=d" (rc) : : "cc");
-#else
-	asm volatile(
-		"	diag	%0,%1,0x64\n"
-		"	ipm	%2\n"
-		"	srl	%2,28\n"
-		: "+d" (rx), "+d" (ry), "=d" (rc) : : "cc");
-#endif
 	*ret1 = rx;
 	*ret2 = ry;
 	return rc;
@@ -281,7 +269,6 @@ query_segment_type (struct dcss_segment *seg)
 		goto out_free;
 	}
 
-#ifdef CONFIG_64BIT
 	/* Only old format of output area of Diagnose x'64' is supported,
 	   copy data for the new format. */
 	if (segext_scode == DCSS_SEGEXT) {
@@ -307,7 +294,6 @@ query_segment_type (struct dcss_segment *seg)
 		}
 		kfree(qout_old);
 	}
-#endif
 	if (qout->segcnt > 6) {
 		rc = -EOPNOTSUPP;
 		goto out_free;
* Unmerged path arch/s390/mm/fault.c
diff --git a/arch/s390/mm/gup.c b/arch/s390/mm/gup.c
index d67bddd5c17b..e0b399eb8df7 100644
--- a/arch/s390/mm/gup.c
+++ b/arch/s390/mm/gup.c
@@ -107,11 +107,9 @@ static inline int gup_pmd_range(pud_t *pudp, pud_t pud, unsigned long addr,
 	pmd_t *pmdp, pmd;
 
 	pmdp = (pmd_t *) pudp;
-#ifdef CONFIG_64BIT
 	if ((pud_val(pud) & _REGION_ENTRY_TYPE_MASK) == _REGION_ENTRY_TYPE_R3)
 		pmdp = (pmd_t *) pud_deref(pud);
 	pmdp += pmd_index(addr);
-#endif
 	do {
 		pmd = *pmdp;
 		barrier();
@@ -184,11 +182,9 @@ static inline int gup_pud_range(pgd_t *pgdp, pgd_t pgd, unsigned long addr,
 	pud_t *pudp, pud;
 
 	pudp = (pud_t *) pgdp;
-#ifdef CONFIG_64BIT
 	if ((pgd_val(pgd) & _REGION_ENTRY_TYPE_MASK) == _REGION_ENTRY_TYPE_R2)
 		pudp = (pud_t *) pgd_deref(pgd);
 	pudp += pud_index(addr);
-#endif
 	do {
 		pud = *pudp;
 		barrier();
* Unmerged path arch/s390/mm/init.c
* Unmerged path arch/s390/mm/mem_detect.c
* Unmerged path arch/s390/mm/mmap.c
diff --git a/arch/s390/mm/pageattr.c b/arch/s390/mm/pageattr.c
index 8408c2e16f04..d6aee550378f 100644
--- a/arch/s390/mm/pageattr.c
+++ b/arch/s390/mm/pageattr.c
@@ -285,7 +285,7 @@ static void ipte_range(pte_t *pte, unsigned long address, int nr)
 {
 	int i;
 
-	if (test_facility(13) && IS_ENABLED(CONFIG_64BIT)) {
+	if (test_facility(13)) {
 		__ptep_ipte_range(address, nr - 1, pte);
 		return;
 	}
diff --git a/arch/s390/mm/pgtable.c b/arch/s390/mm/pgtable.c
index 51db8b210e5f..f8b61b169541 100644
--- a/arch/s390/mm/pgtable.c
+++ b/arch/s390/mm/pgtable.c
@@ -24,14 +24,8 @@
 #include <asm/tlbflush.h>
 #include <asm/mmu_context.h>
 
-#ifndef CONFIG_64BIT
-#define ALLOC_ORDER	1
-#define FRAG_MASK	0x0f
-#else
 #define ALLOC_ORDER	2
 #define FRAG_MASK	0x03
-#endif
-
 
 unsigned long *crst_table_alloc(struct mm_struct *mm)
 {
@@ -47,7 +41,6 @@ void crst_table_free(struct mm_struct *mm, unsigned long *table)
 	free_pages((unsigned long) table, ALLOC_ORDER);
 }
 
-#ifdef CONFIG_64BIT
 static void __crst_table_upgrade(void *arg)
 {
 	struct mm_struct *mm = arg;
@@ -102,7 +95,6 @@ void crst_table_downgrade(struct mm_struct *mm)
 	if (current->active_mm == mm)
 		update_mm(mm, current);
 }
-#endif
 
 #ifdef CONFIG_PGSTE
 
* Unmerged path arch/s390/mm/vmem.c
diff --git a/arch/s390/oprofile/Makefile b/arch/s390/oprofile/Makefile
index 524c4b615821..1bd23017191e 100644
--- a/arch/s390/oprofile/Makefile
+++ b/arch/s390/oprofile/Makefile
@@ -7,4 +7,4 @@ DRIVER_OBJS = $(addprefix ../../../drivers/oprofile/, \
 		timer_int.o )
 
 oprofile-y :=	$(DRIVER_OBJS) init.o backtrace.o
-oprofile-$(CONFIG_64BIT)	+= hwsampler.o
+oprofile-y +=	hwsampler.o
diff --git a/arch/s390/oprofile/init.c b/arch/s390/oprofile/init.c
index fe0952227058..14e08681c4b2 100644
--- a/arch/s390/oprofile/init.c
+++ b/arch/s390/oprofile/init.c
@@ -21,8 +21,6 @@
 
 extern void s390_backtrace(struct pt_regs * const regs, unsigned int depth);
 
-#ifdef CONFIG_64BIT
-
 #include "hwsampler.h"
 #include "op_counter.h"
 
@@ -496,14 +494,10 @@ static void oprofile_hwsampler_exit(void)
 	hwsampler_shutdown();
 }
 
-#endif /* CONFIG_64BIT */
-
 int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
 	ops->backtrace = s390_backtrace;
 
-#ifdef CONFIG_64BIT
-
 	/*
 	 * -ENODEV is not reported to the caller.  The module itself
          * will use the timer mode sampling as fallback and this is
@@ -512,14 +506,9 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	hwsampler_available = oprofile_hwsampler_init(ops) == 0;
 
 	return 0;
-#else
-	return -ENODEV;
-#endif
 }
 
 void oprofile_arch_exit(void)
 {
-#ifdef CONFIG_64BIT
 	oprofile_hwsampler_exit();
-#endif
 }
diff --git a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c
index 8ffc56c24376..4257745fd2ae 100644
--- a/drivers/s390/block/dasd.c
+++ b/drivers/s390/block/dasd.c
@@ -1354,7 +1354,6 @@ struct dasd_ccw_req *dasd_smalloc_request(int magic, int cplength,
  */
 void dasd_kfree_request(struct dasd_ccw_req *cqr, struct dasd_device *device)
 {
-#ifdef CONFIG_64BIT
 	struct ccw1 *ccw;
 
 	/* Clear any idals used for the request. */
@@ -1362,7 +1361,6 @@ void dasd_kfree_request(struct dasd_ccw_req *cqr, struct dasd_device *device)
 	do {
 		clear_normalized_cda(ccw);
 	} while (ccw++->flags & (CCW_FLAG_CC | CCW_FLAG_DC));
-#endif
 	kfree(cqr->cpaddr);
 	kfree(cqr->data);
 	kfree(cqr);
diff --git a/drivers/s390/block/dasd_diag.h b/drivers/s390/block/dasd_diag.h
index a803cc731586..e84a5468d810 100644
--- a/drivers/s390/block/dasd_diag.h
+++ b/drivers/s390/block/dasd_diag.h
@@ -38,8 +38,6 @@ struct dasd_diag_characteristics {
 	u8 rdev_features;
 } __attribute__ ((packed, aligned(4)));
 
-
-#ifdef CONFIG_64BIT
 #define DASD_DIAG_FLAGA_DEFAULT		DASD_DIAG_FLAGA_FORMAT_64BIT
 
 typedef u64 blocknum_t;
@@ -80,43 +78,3 @@ struct dasd_diag_rw_io {
 	struct dasd_diag_bio *bio_list;
 	u8  spare4[8];
 } __attribute__ ((packed, aligned(8)));
-#else /* CONFIG_64BIT */
-#define DASD_DIAG_FLAGA_DEFAULT		0x0
-
-typedef u32 blocknum_t;
-typedef s32 sblocknum_t;
-
-struct dasd_diag_bio {
-	u8 type;
-	u8 status;
-	u16 spare1;
-	blocknum_t block_number;
-	u32 alet;
-	void *buffer;
-} __attribute__ ((packed, aligned(8)));
-
-struct dasd_diag_init_io {
-	u16 dev_nr;
-	u8 flaga;
-	u8 spare1[21];
-	u32 block_size;
-	blocknum_t offset;
-	sblocknum_t start_block;
-	blocknum_t end_block;
-	u8 spare2[24];
-} __attribute__ ((packed, aligned(8)));
-
-struct dasd_diag_rw_io {
-	u16 dev_nr;
-	u8 flaga;
-	u8 spare1[21];
-	u8 key;
-	u8 flags;
-	u8 spare2[2];
-	u32 block_count;
-	u32 alet;
-	struct dasd_diag_bio *bio_list;
-	u32 interrupt_params;
-	u8 spare3[20];
-} __attribute__ ((packed, aligned(8)));
-#endif /* CONFIG_64BIT */
* Unmerged path drivers/s390/block/dasd_eckd.c
* Unmerged path drivers/s390/block/dasd_fba.c
* Unmerged path drivers/s390/char/Kconfig
diff --git a/drivers/s390/char/sclp_sdias.c b/drivers/s390/char/sclp_sdias.c
index 561a0414b352..eb7cb076c001 100644
--- a/drivers/s390/char/sclp_sdias.c
+++ b/drivers/s390/char/sclp_sdias.c
@@ -178,11 +178,7 @@ int sclp_sdias_copy(void *dest, int start_blk, int nr_blks)
 	sccb.evbuf.event_qual = SDIAS_EQ_STORE_DATA;
 	sccb.evbuf.data_id = SDIAS_DI_FCP_DUMP;
 	sccb.evbuf.event_id = 4712;
-#ifdef CONFIG_64BIT
 	sccb.evbuf.asa_size = SDIAS_ASA_SIZE_64;
-#else
-	sccb.evbuf.asa_size = SDIAS_ASA_SIZE_32;
-#endif
 	sccb.evbuf.event_status = 0;
 	sccb.evbuf.blk_cnt = nr_blks;
 	sccb.evbuf.asa = (unsigned long)dest;
diff --git a/drivers/s390/char/zcore.c b/drivers/s390/char/zcore.c
index d55aa4409397..e435e6824cb9 100644
--- a/drivers/s390/char/zcore.c
+++ b/drivers/s390/char/zcore.c
@@ -210,11 +210,7 @@ static struct zcore_header zcore_header = {
 	.dump_level	= 0,
 	.page_size	= PAGE_SIZE,
 	.mem_start	= 0,
-#ifdef CONFIG_64BIT
 	.build_arch	= DUMP_ARCH_S390X,
-#else
-	.build_arch	= DUMP_ARCH_S390,
-#endif
 };
 
 /*
@@ -512,23 +508,6 @@ static const struct file_operations zcore_hsa_fops = {
 	.llseek		= no_llseek,
 };
 
-#ifdef CONFIG_32BIT
-
-static void __init set_lc_mask(struct save_area *map)
-{
-	memset(&map->ext_save, 0xff, sizeof(map->ext_save));
-	memset(&map->timer, 0xff, sizeof(map->timer));
-	memset(&map->clk_cmp, 0xff, sizeof(map->clk_cmp));
-	memset(&map->psw, 0xff, sizeof(map->psw));
-	memset(&map->pref_reg, 0xff, sizeof(map->pref_reg));
-	memset(&map->acc_regs, 0xff, sizeof(map->acc_regs));
-	memset(&map->fp_regs, 0xff, sizeof(map->fp_regs));
-	memset(&map->gp_regs, 0xff, sizeof(map->gp_regs));
-	memset(&map->ctrl_regs, 0xff, sizeof(map->ctrl_regs));
-}
-
-#else /* CONFIG_32BIT */
-
 static void __init set_lc_mask(struct save_area *map)
 {
 	memset(&map->fp_regs, 0xff, sizeof(map->fp_regs));
@@ -543,8 +522,6 @@ static void __init set_lc_mask(struct save_area *map)
 	memset(&map->ctrl_regs, 0xff, sizeof(map->ctrl_regs));
 }
 
-#endif /* CONFIG_32BIT */
-
 /*
  * Initialize dump globals for a given architecture
  */
@@ -693,21 +670,12 @@ static int __init zcore_init(void)
 	if (rc)
 		goto fail;
 
-#ifdef CONFIG_64BIT
 	if (arch == ARCH_S390) {
 		pr_alert("The 64-bit dump tool cannot be used for a "
 			 "32-bit system\n");
 		rc = -EINVAL;
 		goto fail;
 	}
-#else /* CONFIG_64BIT */
-	if (arch == ARCH_S390X) {
-		pr_alert("The 32-bit dump tool cannot be used for a "
-			 "64-bit system\n");
-		rc = -EINVAL;
-		goto fail;
-	}
-#endif /* CONFIG_64BIT */
 
 	rc = get_mem_info(&mem_size, &mem_end);
 	if (rc)
diff --git a/drivers/s390/cio/cio.c b/drivers/s390/cio/cio.c
index ace10937134d..943694ad4a51 100644
--- a/drivers/s390/cio/cio.c
+++ b/drivers/s390/cio/cio.c
@@ -139,13 +139,11 @@ cio_start_key (struct subchannel *sch,	/* subchannel structure */
 	orb->cmd.spnd = priv->options.suspend;
 	orb->cmd.ssic = priv->options.suspend && priv->options.inter;
 	orb->cmd.lpm = (lpm != 0) ? lpm : sch->lpm;
-#ifdef CONFIG_64BIT
 	/*
 	 * for 64 bit we always support 64 bit IDAWs with 4k page size only
 	 */
 	orb->cmd.c64 = 1;
 	orb->cmd.i2k = 0;
-#endif
 	orb->cmd.key = key >> 4;
 	/* issue "Start Subchannel" */
 	orb->cmd.cpa = (__u32) __pa(cpa);
diff --git a/drivers/s390/cio/qdio.h b/drivers/s390/cio/qdio.h
index 8acaae18bd11..5408105677fe 100644
--- a/drivers/s390/cio/qdio.h
+++ b/drivers/s390/cio/qdio.h
@@ -84,7 +84,6 @@ enum qdio_irq_states {
 #define QDIO_SIGA_WRITEQ	0x04
 #define QDIO_SIGA_QEBSM_FLAG	0x80
 
-#ifdef CONFIG_64BIT
 static inline int do_sqbs(u64 token, unsigned char state, int queue,
 			  int *start, int *count)
 {
@@ -122,12 +121,6 @@ static inline int do_eqbs(u64 token, unsigned char *state, int queue,
 
 	return (_ccq >> 32) & 0xff;
 }
-#else
-static inline int do_sqbs(u64 token, unsigned char state, int queue,
-			  int *start, int *count) { return 0; }
-static inline int do_eqbs(u64 token, unsigned char *state, int queue,
-			  int *start, int *count, int ack) { return 0; }
-#endif /* CONFIG_64BIT */
 
 struct qdio_irq;
 
diff --git a/drivers/s390/cio/qdio_setup.c b/drivers/s390/cio/qdio_setup.c
index 09ecb9c1457e..3c88a910e4fc 100644
--- a/drivers/s390/cio/qdio_setup.c
+++ b/drivers/s390/cio/qdio_setup.c
@@ -38,10 +38,7 @@ EXPORT_SYMBOL_GPL(qdio_release_aob);
  */
 static inline int qebsm_possible(void)
 {
-#ifdef CONFIG_64BIT
 	return css_general_characteristics.qebsm;
-#endif
-	return 0;
 }
 
 /*
* Unmerged path drivers/s390/crypto/ap_bus.c
diff --git a/drivers/s390/net/ctcm_mpc.c b/drivers/s390/net/ctcm_mpc.c
index d3c576d790f7..c103fc7efe9f 100644
--- a/drivers/s390/net/ctcm_mpc.c
+++ b/drivers/s390/net/ctcm_mpc.c
@@ -130,11 +130,7 @@ void ctcmpc_dumpit(char *buf, int len)
 	__u32	ct, sw, rm, dup;
 	char	*ptr, *rptr;
 	char	tbuf[82], tdup[82];
-	#ifdef CONFIG_64BIT
 	char	addr[22];
-	#else
-	char	addr[12];
-	#endif
 	char	boff[12];
 	char	bhex[82], duphex[82];
 	char	basc[40];
@@ -147,11 +143,7 @@ void ctcmpc_dumpit(char *buf, int len)
 
 	for (ct = 0; ct < len; ct++, ptr++, rptr++) {
 		if (sw == 0) {
-			#ifdef CONFIG_64BIT
 			sprintf(addr, "%16.16llx", (__u64)rptr);
-			#else
-			sprintf(addr, "%8.8X", (__u32)rptr);
-			#endif
 
 			sprintf(boff, "%4.4X", (__u32)ct);
 			bhex[0] = '\0';
@@ -162,11 +154,7 @@ void ctcmpc_dumpit(char *buf, int len)
 		if (sw == 8)
 			strcat(bhex, "	");
 
-		#if CONFIG_64BIT
 		sprintf(tbuf, "%2.2llX", (__u64)*ptr);
-		#else
-		sprintf(tbuf, "%2.2X", (__u32)*ptr);
-		#endif
 
 		tbuf[2] = '\0';
 		strcat(bhex, tbuf);
