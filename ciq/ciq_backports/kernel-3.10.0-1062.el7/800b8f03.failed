X86/Hyper-V: Consolidate code for converting cpumask to vpset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [x86] hyper-v: Consolidate code for converting cpumask to vpset (Vitaly Kuznetsov) [1661654]
Rebuild_FUZZ: 96.61%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit 800b8f03fdc8d66885ff03de531285526a4ca0d4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/800b8f03.failed

Consolidate code for converting cpumask to vpset.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
	Cc: olaf@aepfle.de
	Cc: sthemmin@microsoft.com
	Cc: gregkh@linuxfoundation.org
	Cc: jasowang@redhat.com
	Cc: Michael.H.Kelley@microsoft.com
	Cc: hpa@zytor.com
	Cc: apw@canonical.com
	Cc: devel@linuxdriverproject.org
	Cc: vkuznets@redhat.com
Link: https://lkml.kernel.org/r/20180516215334.6547-4-kys@linuxonhyperv.com

(cherry picked from commit 800b8f03fdc8d66885ff03de531285526a4ca0d4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/mmu.c
diff --cc arch/x86/hyperv/mmu.c
index 456304ec28bd,c9cd28f0bae4..000000000000
--- a/arch/x86/hyperv/mmu.c
+++ b/arch/x86/hyperv/mmu.c
@@@ -69,45 -66,8 +65,10 @@@ static inline int fill_gva_list(u64 gva
  	return gva_n - offset;
  }
  
- /* Return the number of banks in the resulting vp_set */
- static inline int cpumask_to_vp_set(struct hv_flush_pcpu_ex *flush,
- 				    const struct cpumask *cpus)
- {
- 	int cpu, vcpu, vcpu_bank, vcpu_offset, nr_bank = 1;
- 
- 	/* valid_bank_mask can represent up to 64 banks */
- 	if (hv_max_vp_index / 64 >= 64)
- 		return 0;
- 
- 	/*
- 	 * Clear all banks up to the maximum possible bank as hv_flush_pcpu_ex
- 	 * structs are not cleared between calls, we risk flushing unneeded
- 	 * vCPUs otherwise.
- 	 */
- 	for (vcpu_bank = 0; vcpu_bank <= hv_max_vp_index / 64; vcpu_bank++)
- 		flush->hv_vp_set.bank_contents[vcpu_bank] = 0;
- 
- 	/*
- 	 * Some banks may end up being empty but this is acceptable.
- 	 */
- 	for_each_cpu(cpu, cpus) {
- 		vcpu = hv_cpu_number_to_vp_number(cpu);
- 		vcpu_bank = vcpu / 64;
- 		vcpu_offset = vcpu % 64;
- 		__set_bit(vcpu_offset, (unsigned long *)
- 			  &flush->hv_vp_set.bank_contents[vcpu_bank]);
- 		if (vcpu_bank >= nr_bank)
- 			nr_bank = vcpu_bank + 1;
- 	}
- 	flush->hv_vp_set.valid_bank_mask = GENMASK_ULL(nr_bank - 1, 0);
- 
- 	return nr_bank;
- }
- 
  static void hyperv_flush_tlb_others(const struct cpumask *cpus,
 -				    const struct flush_tlb_info *info)
 +				    struct mm_struct *mm,
 +				    unsigned long start,
 +				    unsigned long end)
  {
  	int cpu, vcpu, gva_n, max_gvas;
  	struct hv_flush_pcpu **flush_pcpu;
@@@ -232,8 -200,8 +193,13 @@@ static void hyperv_flush_tlb_others_ex(
  	flush->hv_vp_set.valid_bank_mask = 0;
  
  	if (!cpumask_equal(cpus, cpu_present_mask)) {
++<<<<<<< HEAD
 +		flush->hv_vp_set.format = HV_GENERIC_SET_SPARCE_4K;
 +		nr_bank = cpumask_to_vp_set(flush, cpus);
++=======
+ 		flush->hv_vp_set.format = HV_GENERIC_SET_SPARSE_4K;
+ 		nr_bank = cpumask_to_vpset(&(flush->hv_vp_set), cpus);
++>>>>>>> 800b8f03fdc8 (X86/Hyper-V: Consolidate code for converting cpumask to vpset)
  	}
  
  	if (!nr_bank) {
* Unmerged path arch/x86/hyperv/mmu.c
