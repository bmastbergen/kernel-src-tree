tracing/kprobes: Avoid perf_trace_buf_*() if ->perf_events is empty

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Oleg Nesterov <oleg@redhat.com>
commit 288e984e622336bab8bc3dfdf2f190816362d9a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/288e984e.failed

perf_trace_buf_prepare() + perf_trace_buf_submit() make no sense
if this task/CPU has no active counters. Change kprobe_perf_func()
and kretprobe_perf_func() to check call->perf_events beforehand
and return if this list is empty.

For example, "perf record -e some_probe -p1". Only /sbin/init will
report, all other threads which hit the same probe will do
perf_trace_buf_prepare/perf_trace_buf_submit just to realize that
nobody wants perf_swevent_event().

Link: http://lkml.kernel.org/r/20130620173806.GA13151@redhat.com

	Acked-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
(cherry picked from commit 288e984e622336bab8bc3dfdf2f190816362d9a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace_kprobe.c
diff --cc kernel/trace/trace_kprobe.c
index f043398d9608,c35bebe53ffe..000000000000
--- a/kernel/trace/trace_kprobe.c
+++ b/kernel/trace/trace_kprobe.c
@@@ -1144,11 -1156,12 +1144,20 @@@ kprobe_perf_func(struct trace_kprobe *t
  	int size, __size, dsize;
  	int rctx;
  
++<<<<<<< HEAD
 +	if (bpf_prog_array_valid(call) && !trace_call_bpf(call, regs))
 +		return;
 +
 +	dsize = __get_data_size(&tk->tp, regs);
 +	__size = sizeof(*entry) + tk->tp.size + dsize;
++=======
+ 	head = this_cpu_ptr(call->perf_events);
+ 	if (hlist_empty(head))
+ 		return;
+ 
+ 	dsize = __get_data_size(tp, regs);
+ 	__size = sizeof(*entry) + tp->size + dsize;
++>>>>>>> 288e984e6223 (tracing/kprobes: Avoid perf_trace_buf_*() if ->perf_events is empty)
  	size = ALIGN(__size + sizeof(u32), sizeof(u64));
  	size -= sizeof(u32);
  	if (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,
@@@ -1159,11 -1172,9 +1168,15 @@@
  	if (!entry)
  		return;
  
 -	entry->ip = (unsigned long)tp->rp.kp.addr;
 +	entry->ip = (unsigned long)tk->rp.kp.addr;
  	memset(&entry[1], 0, dsize);
++<<<<<<< HEAD
 +	store_trace_args(sizeof(*entry), &tk->tp, regs, (u8 *)&entry[1], dsize);
 +
 +	head = this_cpu_ptr(call->perf_events);
++=======
+ 	store_trace_args(sizeof(*entry), tp, regs, (u8 *)&entry[1], dsize);
++>>>>>>> 288e984e6223 (tracing/kprobes: Avoid perf_trace_buf_*() if ->perf_events is empty)
  	perf_trace_buf_submit(entry, size, rctx,
  					entry->ip, 1, regs, head, NULL);
  }
@@@ -1179,11 -1190,12 +1192,20 @@@ kretprobe_perf_func(struct trace_kprob
  	int size, __size, dsize;
  	int rctx;
  
++<<<<<<< HEAD
 +	if (bpf_prog_array_valid(call) && !trace_call_bpf(call, regs))
 +		return;
 +
 +	dsize = __get_data_size(&tk->tp, regs);
 +	__size = sizeof(*entry) + tk->tp.size + dsize;
++=======
+ 	head = this_cpu_ptr(call->perf_events);
+ 	if (hlist_empty(head))
+ 		return;
+ 
+ 	dsize = __get_data_size(tp, regs);
+ 	__size = sizeof(*entry) + tp->size + dsize;
++>>>>>>> 288e984e6223 (tracing/kprobes: Avoid perf_trace_buf_*() if ->perf_events is empty)
  	size = ALIGN(__size + sizeof(u32), sizeof(u64));
  	size -= sizeof(u32);
  	if (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,
@@@ -1194,11 -1206,9 +1216,15 @@@
  	if (!entry)
  		return;
  
 -	entry->func = (unsigned long)tp->rp.kp.addr;
 +	entry->func = (unsigned long)tk->rp.kp.addr;
  	entry->ret_ip = (unsigned long)ri->ret_addr;
++<<<<<<< HEAD
 +	store_trace_args(sizeof(*entry), &tk->tp, regs, (u8 *)&entry[1], dsize);
 +
 +	head = this_cpu_ptr(call->perf_events);
++=======
+ 	store_trace_args(sizeof(*entry), tp, regs, (u8 *)&entry[1], dsize);
++>>>>>>> 288e984e6223 (tracing/kprobes: Avoid perf_trace_buf_*() if ->perf_events is empty)
  	perf_trace_buf_submit(entry, size, rctx,
  					entry->ret_ip, 1, regs, head, NULL);
  }
* Unmerged path kernel/trace/trace_kprobe.c
