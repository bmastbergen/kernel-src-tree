docs: Fix a couple typos

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Stan Drozd <drozdziak1@gmail.com>
commit 9bb0e9cb04c82d6bf0e72f3207307d621083b801
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9bb0e9cb.failed

This commit gets rid of some minor errors in Documentation/:
* cputopology.txt: drawes -> drawers
* debugging-via-ohci1394.txt: remove an unnecessary line break
* static-keys: statemnts -> statements
* zorro.txt: busses -> buses

	Signed-off-by: Stan Drozd <drozdziak1@gmail.com>
	Signed-off-by: Jonathan Corbet <corbet@lwn.net>
(cherry picked from commit 9bb0e9cb04c82d6bf0e72f3207307d621083b801)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/static-keys.txt
diff --cc Documentation/static-keys.txt
index 9f5263d3152c,ef419fd0897f..000000000000
--- a/Documentation/static-keys.txt
+++ b/Documentation/static-keys.txt
@@@ -103,41 -116,39 +103,47 @@@ Or
          else
                  do unlikely code
  
++<<<<<<< HEAD
 +A key that is initialized via 'STATIC_KEY_INIT_FALSE', must be used in a
 +'static_key_false()' construct. Likewise, a key initialized via
 +'STATIC_KEY_INIT_TRUE' must be used in a 'static_key_true()' construct. A
 +single key can be used in many branches, but all the branches must match the
 +way that the key has been initialized.
++=======
+ Keys defined via DEFINE_STATIC_KEY_TRUE(), or DEFINE_STATIC_KEY_FALSE, may
+ be used in either static_branch_likely() or static_branch_unlikely()
+ statements.
++>>>>>>> 9bb0e9cb04c8 (docs: Fix a couple typos)
  
 -Branch(es) can be set true via:
 +The branch(es) can then be switched via:
  
 -static_branch_enable(&key);
 -
 -or false via:
 -
 -static_branch_disable(&key);
 -
 -The branch(es) can then be switched via reference counts:
 -
 -	static_branch_inc(&key);
 +	static_key_slow_inc(&key);
  	...
 -	static_branch_dec(&key);
 +	static_key_slow_dec(&key);
  
 -Thus, 'static_branch_inc()' means 'make the branch true', and
 -'static_branch_dec()' means 'make the branch false' with appropriate
 +Thus, 'static_key_slow_inc()' means 'make the branch true', and
 +'static_key_slow_dec()' means 'make the the branch false' with appropriate
  reference counting. For example, if the key is initialized true, a
 -static_branch_dec(), will switch the branch to false. And a subsequent
 -static_branch_inc(), will change the branch back to true. Likewise, if the
 -key is initialized false, a 'static_branch_inc()', will change the branch to
 -true. And then a 'static_branch_dec()', will again make the branch false.
 +static_key_slow_dec(), will switch the branch to false. And a subsequent
 +static_key_slow_inc(), will change the branch back to true. Likewise, if the
 +key is initialized false, a 'static_key_slow_inc()', will change the branch to
 +true. And then a 'static_key_slow_dec()', will again make the branch false.
  
 -Where an array of keys is required, it can be defined as:
 +An example usage in the kernel is the implementation of tracepoints:
  
 -	DEFINE_STATIC_KEY_ARRAY_TRUE(keys, count);
 +        static inline void trace_##name(proto)                          \
 +        {                                                               \
 +                if (static_key_false(&__tracepoint_##name.key))		\
 +                        __DO_TRACE(&__tracepoint_##name,                \
 +                                TP_PROTO(data_proto),                   \
 +                                TP_ARGS(data_args),                     \
 +                                TP_CONDITION(cond));                    \
 +        }
  
 -or:
 +Tracepoints are disabled by default, and can be placed in performance critical
 +pieces of the kernel. Thus, by using a static key, the tracepoints can have
 +absolutely minimal impact when not in use.
  
 -	DEFINE_STATIC_KEY_ARRAY_FALSE(keys, count);
  
  4) Architecture level code patching interface, 'jump labels'
  
diff --git a/Documentation/cputopology.txt b/Documentation/cputopology.txt
index 97b985b50ce7..166470358f4d 100644
--- a/Documentation/cputopology.txt
+++ b/Documentation/cputopology.txt
@@ -69,7 +69,7 @@ not defined by include/asm-XXX/topology.h:
 
 For architectures that don't support books (CONFIG_SCHED_BOOK) there are no
 default definitions for topology_book_id() and topology_book_cpumask().
-For architectures that don't support drawes (CONFIG_SCHED_DRAWER) there are
+For architectures that don't support drawers (CONFIG_SCHED_DRAWER) there are
 no default definitions for topology_drawer_id() and topology_drawer_cpumask().
 
 Additionally, CPU topology information is provided under
diff --git a/Documentation/debugging-via-ohci1394.txt b/Documentation/debugging-via-ohci1394.txt
index 611f5a5499b1..2f593d1149af 100644
--- a/Documentation/debugging-via-ohci1394.txt
+++ b/Documentation/debugging-via-ohci1394.txt
@@ -102,8 +102,8 @@ Step-by-step instructions for using firescope with early OHCI initialization:
    CardBus and even some Express cards which are fully compliant to OHCI-1394
    specification are available. If it requires no driver for Windows operating
    systems, it most likely is. Only specialized shops have cards which are not
-   compliant, they are based on TI PCILynx chips and require drivers for Win-
-   dows operating systems.
+   compliant, they are based on TI PCILynx chips and require drivers for Windows
+   operating systems.
 
 2) Establish a working FireWire cable connection:
 
* Unmerged path Documentation/static-keys.txt
diff --git a/Documentation/zorro.txt b/Documentation/zorro.txt
index d5829d14774a..f355900e50fe 100644
--- a/Documentation/zorro.txt
+++ b/Documentation/zorro.txt
@@ -11,7 +11,7 @@ Last revised: September 5, 2003
 The Zorro bus is the bus used in the Amiga family of computers. Thanks to
 AutoConfig(tm), it's 100% Plug-and-Play.
 
-There are two types of Zorro busses, Zorro II and Zorro III:
+There are two types of Zorro buses, Zorro II and Zorro III:
 
   - The Zorro II address space is 24-bit and lies within the first 16 MB of the
     Amiga's address map.
