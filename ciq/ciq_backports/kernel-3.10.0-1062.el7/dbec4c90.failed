scsi: mpt3sas: lockless command submission

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [scsi] mpt3sas: lockless command submission (Tomas Henzl) [1513855]
Rebuild_FUZZ: 92.31%
commit-author Suganath Prabu Subramani <suganath-prabu.subramani@broadcom.com>
commit dbec4c9040edc15442c3ebdb65408aa9d3b82c24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/dbec4c90.failed

Performance improvement using block layer tag.

Curent driver gets scsiio tracker and free smid from link list and array
based tracking managed by driver.  Accessing list in main io path is
performance pentaly because of protection using spinlock
"scsi_lookup_lock".

In this patch:

1. Driver removes all link list access from main io path and
   use scmd->request->tag to get free smid.

2. Instead of holding 'struct scsiio_tracker' in its own pool
   driver can embed it into the scsi command.

Driver provides cmd_size in scsi_host_template, so that struct
scsiio_tracker is preallocated by scsi mid layer for each scsi command.

	Signed-off-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Suganath Prabu S <suganath-prabu.subramani@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit dbec4c9040edc15442c3ebdb65408aa9d3b82c24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpt3sas/mpt3sas_base.c
#	drivers/scsi/mpt3sas/mpt3sas_base.h
#	drivers/scsi/mpt3sas/mpt3sas_scsih.c
#	drivers/scsi/mpt3sas/mpt3sas_warpdrive.c
diff --cc drivers/scsi/mpt3sas/mpt3sas_base.c
index 8dac7624baff,a44b9be6e3c5..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_base.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c
@@@ -2307,6 -2756,32 +2313,35 @@@ mpt3sas_base_get_sense_buffer_dma(struc
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * mpt3sas_base_get_pcie_sgl - obtain a PCIe SGL virt addr
+  * @ioc: per adapter object
+  * @smid: system request message index
+  *
+  * Returns virt pointer to a PCIe SGL.
+  */
+ void *
+ mpt3sas_base_get_pcie_sgl(struct MPT3SAS_ADAPTER *ioc, u16 smid)
+ {
+ 	return (void *)(ioc->pcie_sg_lookup[smid - 1].pcie_sgl);
+ }
+ 
+ /**
+  * mpt3sas_base_get_pcie_sgl_dma - obtain a PCIe SGL dma addr
+  * @ioc: per adapter object
+  * @smid: system request message index
+  *
+  * Returns phys pointer to the address of the PCIe buffer.
+  */
+ dma_addr_t
+ mpt3sas_base_get_pcie_sgl_dma(struct MPT3SAS_ADAPTER *ioc, u16 smid)
+ {
+ 	return ioc->pcie_sg_lookup[smid - 1].pcie_sgl_dma;
+ }
+ 
+ /**
++>>>>>>> dbec4c9040ed (scsi: mpt3sas: lockless command submission)
   * mpt3sas_base_get_reply_virt_addr - obtain reply frames virt address
   * @ioc: per adapter object
   * @phys_addr: lower 32 physical addr of the reply
@@@ -3196,6 -3813,16 +3234,19 @@@ _base_release_memory_pools(struct MPT3S
  		kfree(ioc->reply_post);
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (ioc->pcie_sgl_dma_pool) {
+ 		for (i = 0; i < ioc->scsiio_depth; i++) {
+ 			dma_pool_free(ioc->pcie_sgl_dma_pool,
+ 					ioc->pcie_sg_lookup[i].pcie_sgl,
+ 					ioc->pcie_sg_lookup[i].pcie_sgl_dma);
+ 		}
+ 		if (ioc->pcie_sgl_dma_pool)
+ 			dma_pool_destroy(ioc->pcie_sgl_dma_pool);
+ 	}
+ 
++>>>>>>> dbec4c9040ed (scsi: mpt3sas: lockless command submission)
  	if (ioc->config_page) {
  		dexitprintk(ioc, pr_info(MPT3SAS_FMT
  		    "config_page(0x%p): free\n", ioc->name,
@@@ -3582,7 -4194,58 +3619,43 @@@ _base_allocate_memory_pools(struct MPT3
  		"internal(0x%p): depth(%d), start smid(%d)\n",
  		ioc->name, ioc->internal,
  	    ioc->internal_depth, ioc->internal_smid));
 -	/*
 -	 * The number of NVMe page sized blocks needed is:
 -	 *     (((sg_tablesize * 8) - 1) / (page_size - 8)) + 1
 -	 * ((sg_tablesize * 8) - 1) is the max PRP's minus the first PRP entry
 -	 * that is placed in the main message frame.  8 is the size of each PRP
 -	 * entry or PRP list pointer entry.  8 is subtracted from page_size
 -	 * because of the PRP list pointer entry at the end of a page, so this
 -	 * is not counted as a PRP entry.  The 1 added page is a round up.
 -	 *
 -	 * To avoid allocation failures due to the amount of memory that could
 -	 * be required for NVMe PRP's, only each set of NVMe blocks will be
 -	 * contiguous, so a new set is allocated for each possible I/O.
 -	 */
 -	if (ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_NVME_DEVICES) {
 -		nvme_blocks_needed =
 -			(ioc->shost->sg_tablesize * NVME_PRP_SIZE) - 1;
 -		nvme_blocks_needed /= (ioc->page_size - NVME_PRP_SIZE);
 -		nvme_blocks_needed++;
  
++<<<<<<< HEAD
++=======
+ 		sz = sizeof(struct pcie_sg_list) * ioc->scsiio_depth;
+ 		ioc->pcie_sg_lookup = kzalloc(sz, GFP_KERNEL);
+ 		if (!ioc->pcie_sg_lookup) {
+ 			pr_info(MPT3SAS_FMT
+ 			    "PCIe SGL lookup: kzalloc failed\n", ioc->name);
+ 			goto out;
+ 		}
+ 		sz = nvme_blocks_needed * ioc->page_size;
+ 		ioc->pcie_sgl_dma_pool =
+ 			dma_pool_create("PCIe SGL pool", &ioc->pdev->dev, sz, 16, 0);
+ 		if (!ioc->pcie_sgl_dma_pool) {
+ 			pr_info(MPT3SAS_FMT
+ 			    "PCIe SGL pool: dma_pool_create failed\n",
+ 			    ioc->name);
+ 			goto out;
+ 		}
+ 		for (i = 0; i < ioc->scsiio_depth; i++) {
+ 			ioc->pcie_sg_lookup[i].pcie_sgl = dma_pool_alloc(
+ 				ioc->pcie_sgl_dma_pool, GFP_KERNEL,
+ 				&ioc->pcie_sg_lookup[i].pcie_sgl_dma);
+ 			if (!ioc->pcie_sg_lookup[i].pcie_sgl) {
+ 				pr_info(MPT3SAS_FMT
+ 				    "PCIe SGL pool: dma_pool_alloc failed\n",
+ 				    ioc->name);
+ 				goto out;
+ 			}
+ 		}
+ 
+ 		dinitprintk(ioc, pr_info(MPT3SAS_FMT "PCIe sgl pool depth(%d), "
+ 			"element_size(%d), pool_size(%d kB)\n", ioc->name,
+ 			ioc->scsiio_depth, sz, (sz * ioc->scsiio_depth)/1024));
+ 		total_sz += sz * ioc->scsiio_depth;
+ 	}
++>>>>>>> dbec4c9040ed (scsi: mpt3sas: lockless command submission)
  	/* sense buffers, 4 byte align */
  	sz = ioc->scsiio_depth * SCSI_SENSE_BUFFERSIZE;
  	ioc->sense_dma_pool = dma_pool_create("sense pool", &ioc->pdev->dev, sz,
diff --cc drivers/scsi/mpt3sas/mpt3sas_base.h
index d5220e9570ad,789bc421424b..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_base.h
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.h
@@@ -757,11 -779,10 +756,9 @@@ struct chain_tracker 
   */
  struct scsiio_tracker {
  	u16	smid;
- 	struct scsi_cmnd *scmd;
  	u8	cb_idx;
  	u8	direct_io;
 -	struct pcie_sg_list pcie_sg_list;
  	struct list_head chain_list;
- 	struct list_head tracker_list;
  	u16     msix_io;
  };
  
@@@ -1576,13 -1611,11 +1574,13 @@@ void mpt3sas_trigger_mpi(struct MPT3SAS
  u8 mpt3sas_get_num_volumes(struct MPT3SAS_ADAPTER *ioc);
  void mpt3sas_init_warpdrive_properties(struct MPT3SAS_ADAPTER *ioc,
  	struct _raid_device *raid_device);
- u8
- mpt3sas_scsi_direct_io_get(struct MPT3SAS_ADAPTER *ioc, u16 smid);
- void
- mpt3sas_scsi_direct_io_set(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 direct_io);
  void
  mpt3sas_setup_direct_io(struct MPT3SAS_ADAPTER *ioc, struct scsi_cmnd *scmd,
++<<<<<<< HEAD
 +	struct _raid_device *raid_device, Mpi2SCSIIORequest_t *mpi_request,
 +	u16 smid);
++=======
+ 	struct _raid_device *raid_device, Mpi25SCSIIORequest_t *mpi_request);
 -
 -/* NCQ Prio Handling Check */
 -bool scsih_ncq_prio_supp(struct scsi_device *sdev);
++>>>>>>> dbec4c9040ed (scsi: mpt3sas: lockless command submission)
  
  #endif /* MPT3SAS_BASE_H_INCLUDED */
diff --cc drivers/scsi/mpt3sas/mpt3sas_scsih.c
index 79c41385bced,74fca184dba9..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c
@@@ -1477,67 -1452,24 +1476,80 @@@ _scsih_is_nvme_device(u32 device_info
   * Returns the smid stored scmd pointer.
   * Then will dereference the stored scmd pointer.
   */
- static inline struct scsi_cmnd *
- __scsih_scsi_lookup_get_clear(struct MPT3SAS_ADAPTER *ioc,
- 		u16 smid)
+ struct scsi_cmnd *
+ mpt3sas_scsih_scsi_lookup_get(struct MPT3SAS_ADAPTER *ioc, u16 smid)
  {
  	struct scsi_cmnd *scmd = NULL;
+ 	struct scsiio_tracker *st;
  
- 	swap(scmd, ioc->scsi_lookup[smid - 1].scmd);
+ 	if (smid > 0  &&
+ 	    smid <= ioc->scsiio_depth - INTERNAL_SCSIIO_CMDS_COUNT) {
+ 		u32 unique_tag = smid - 1;
  
++<<<<<<< HEAD
 +	return scmd;
 +}
 +
 +/**
 + * _scsih_scsi_lookup_get_clear - returns scmd entry
 + * @ioc: per adapter object
 + * @smid: system request message index
 + *
 + * Returns the smid stored scmd pointer.
 + * Then will derefrence the stored scmd pointer.
 + */
 +static inline struct scsi_cmnd *
 +_scsih_scsi_lookup_get_clear(struct MPT3SAS_ADAPTER *ioc, u16 smid)
 +{
 +	unsigned long flags;
 +	struct scsi_cmnd *scmd;
 +
 +	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
 +	scmd = __scsih_scsi_lookup_get_clear(ioc, smid);
 +	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
 +
 +	return scmd;
 +}
 +
 +/**
 + * _scsih_scsi_lookup_find_by_scmd - scmd lookup
 + * @ioc: per adapter object
 + * @smid: system request message index
 + * @scmd: pointer to scsi command object
 + * Context: This function will acquire ioc->scsi_lookup_lock.
 + *
 + * This will search for a scmd pointer in the scsi_lookup array,
 + * returning the revelent smid.  A returned value of zero means invalid.
 + */
 +static u16
 +_scsih_scsi_lookup_find_by_scmd(struct MPT3SAS_ADAPTER *ioc, struct scsi_cmnd
 +	*scmd)
 +{
 +	u16 smid;
 +	unsigned long	flags;
 +	int i;
 +
 +	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
 +	smid = 0;
 +	for (i = 0; i < ioc->scsiio_depth; i++) {
 +		if (ioc->scsi_lookup[i].scmd == scmd) {
 +			smid = ioc->scsi_lookup[i].smid;
 +			goto out;
 +		}
 +	}
 + out:
 +	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
 +	return smid;
++=======
+ 		scmd = scsi_host_find_tag(ioc->shost, unique_tag);
+ 		if (scmd) {
+ 			st = scsi_cmd_priv(scmd);
+ 			if (st->cb_idx == 0xFF)
+ 				scmd = NULL;
+ 		}
+ 	}
+ 	return scmd;
++>>>>>>> dbec4c9040ed (scsi: mpt3sas: lockless command submission)
  }
  
  /**
@@@ -3001,7 -2826,7 +3013,11 @@@ scsih_abort(struct scsi_cmnd *scmd
  {
  	struct MPT3SAS_ADAPTER *ioc = shost_priv(scmd->device->host);
  	struct MPT3SAS_DEVICE *sas_device_priv_data;
++<<<<<<< HEAD
 +	u16 smid;
++=======
+ 	struct scsiio_tracker *st = scsi_cmd_priv(scmd);
++>>>>>>> dbec4c9040ed (scsi: mpt3sas: lockless command submission)
  	u16 handle;
  	int r;
  
@@@ -3019,9 -2844,8 +3035,14 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	/* search for the command */
 +	smid = _scsih_scsi_lookup_find_by_scmd(ioc, scmd);
 +	if (!smid) {
++=======
+ 	/* check for completed command */
+ 	if (st == NULL || st->cb_idx == 0xFF) {
++>>>>>>> dbec4c9040ed (scsi: mpt3sas: lockless command submission)
  		scmd->result = DID_RESET << 16;
  		r = SUCCESS;
  		goto out;
@@@ -3039,10 -2863,12 +3060,19 @@@
  	mpt3sas_halt_firmware(ioc);
  
  	handle = sas_device_priv_data->sas_target->handle;
++<<<<<<< HEAD
 +	r = mpt3sas_scsih_issue_locked_tm(ioc, handle, scmd->device->channel,
 +	    scmd->device->id, scmd->device->lun,
 +	    MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK, smid, 30);
 +
++=======
+ 	r = mpt3sas_scsih_issue_locked_tm(ioc, handle, scmd->device->lun,
+ 		MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK,
+ 		st->smid, st->msix_io, 30);
+ 	/* Command must be cleared after abort */
+ 	if (r == SUCCESS && st->cb_idx != 0xFF)
+ 		r = FAILED;
++>>>>>>> dbec4c9040ed (scsi: mpt3sas: lockless command submission)
   out:
  	sdev_printk(KERN_INFO, scmd->device, "task abort: %s scmd(%p)\n",
  	    ((r == SUCCESS) ? "SUCCESS" : "FAILED"), scmd);
@@@ -5341,9 -5171,10 +5373,10 @@@ out_unlock
  static u8
  _scsih_io_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)
  {
 -	Mpi25SCSIIORequest_t *mpi_request;
 +	Mpi2SCSIIORequest_t *mpi_request;
  	Mpi2SCSIIOReply_t *mpi_reply;
  	struct scsi_cmnd *scmd;
+ 	struct scsiio_tracker *st;
  	u16 ioc_status;
  	u32 xfer_cnt;
  	u8 scsi_state;
@@@ -5351,8 -5182,6 +5384,11 @@@
  	u32 log_info;
  	struct MPT3SAS_DEVICE *sas_device_priv_data;
  	u32 response_code = 0;
++<<<<<<< HEAD
 +	unsigned long flags;
 +	unsigned int sector_sz;
++=======
++>>>>>>> dbec4c9040ed (scsi: mpt3sas: lockless command submission)
  
  	mpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);
  
@@@ -7570,9 -7379,10 +7599,14 @@@ _scsih_sas_broadcast_primitive_event(st
  	for (smid = 1; smid <= ioc->scsiio_depth; smid++) {
  		if (ioc->shost_recovery)
  			goto out;
++<<<<<<< HEAD
 +		scmd = ioc->scsi_lookup[smid - 1].scmd;
++=======
+ 		scmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);
++>>>>>>> dbec4c9040ed (scsi: mpt3sas: lockless command submission)
  		if (!scmd)
  			continue;
+ 		st = scsi_cmd_priv(scmd);
  		sdev = scmd->device;
  		sas_device_priv_data = sdev->hostdata;
  		if (!sas_device_priv_data || !sas_device_priv_data->sas_target)
@@@ -7594,8 -7404,9 +7628,14 @@@
  			goto out;
  
  		spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
++<<<<<<< HEAD
 +		r = mpt3sas_scsih_issue_tm(ioc, handle, 0, 0, lun,
 +		    MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK, smid, 30);
++=======
+ 		r = mpt3sas_scsih_issue_tm(ioc, handle, lun,
+ 			MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK, st->smid,
+ 			st->msix_io, 30);
++>>>>>>> dbec4c9040ed (scsi: mpt3sas: lockless command submission)
  		if (r == FAILED) {
  			sdev_printk(KERN_WARNING, sdev,
  			    "mpt3sas_scsih_issue_tm: FAILED when sending "
@@@ -7634,10 -7445,10 +7674,17 @@@
  		if (ioc->shost_recovery)
  			goto out_no_lock;
  
++<<<<<<< HEAD
 +		r = mpt3sas_scsih_issue_tm(ioc, handle, sdev->channel, sdev->id,
 +		    sdev->lun, MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK, smid,
 +		    30);
 +		if (r == FAILED) {
++=======
+ 		r = mpt3sas_scsih_issue_tm(ioc, handle, sdev->lun,
+ 			MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK, st->smid,
+ 			st->msix_io, 30);
+ 		if (r == FAILED || st->cb_idx != 0xFF) {
++>>>>>>> dbec4c9040ed (scsi: mpt3sas: lockless command submission)
  			sdev_printk(KERN_WARNING, sdev,
  			    "mpt3sas_scsih_issue_tm: ABORT_TASK: FAILED : "
  			    "scmd(%p)\n", scmd);
@@@ -10443,9 -10253,10 +10490,14 @@@ static struct scsi_host_template mpt2sa
  	.use_clustering			= ENABLE_CLUSTERING,
  	.shost_attrs			= mpt3sas_host_attrs,
  	.sdev_attrs			= mpt3sas_dev_attrs,
++<<<<<<< HEAD
++=======
+ 	.track_queue_depth		= 1,
+ 	.cmd_size			= sizeof(struct scsiio_tracker),
++>>>>>>> dbec4c9040ed (scsi: mpt3sas: lockless command submission)
  };
  
 +#ifdef MPT2SAS_SCSI
  /* raid transport support for SAS 2.0 HBA devices */
  static struct raid_function_template mpt2sas_raid_functions = {
  	.cookie		= &mpt2sas_driver_template,
@@@ -10483,9 -10292,10 +10535,14 @@@ static struct scsi_host_template mpt3sa
  	.use_clustering			= ENABLE_CLUSTERING,
  	.shost_attrs			= mpt3sas_host_attrs,
  	.sdev_attrs			= mpt3sas_dev_attrs,
++<<<<<<< HEAD
++=======
+ 	.track_queue_depth		= 1,
+ 	.cmd_size			= sizeof(struct scsiio_tracker),
++>>>>>>> dbec4c9040ed (scsi: mpt3sas: lockless command submission)
  };
  
 +#ifndef MPT2SAS_SCSI
  /* raid transport support for SAS 3.0 HBA devices */
  static struct raid_function_template mpt3sas_raid_functions = {
  	.cookie		= &mpt3sas_driver_template,
diff --cc drivers/scsi/mpt3sas/mpt3sas_warpdrive.c
index 06e3f7d634b2,6bfcee4757e0..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_warpdrive.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_warpdrive.c
@@@ -301,8 -272,7 +272,12 @@@ out_error
   */
  void
  mpt3sas_setup_direct_io(struct MPT3SAS_ADAPTER *ioc, struct scsi_cmnd *scmd,
++<<<<<<< HEAD
 +	struct _raid_device *raid_device, Mpi2SCSIIORequest_t *mpi_request,
 +	u16 smid)
++=======
+ 	struct _raid_device *raid_device, Mpi25SCSIIORequest_t *mpi_request)
++>>>>>>> dbec4c9040ed (scsi: mpt3sas: lockless command submission)
  {
  	sector_t v_lba, p_lba, stripe_off, column, io_size;
  	u32 stripe_sz, stripe_exp;
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_base.c
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_base.h
diff --git a/drivers/scsi/mpt3sas/mpt3sas_ctl.c b/drivers/scsi/mpt3sas/mpt3sas_ctl.c
index a6a5ecb79a3a..59e2249ce54a 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_ctl.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_ctl.c
@@ -553,11 +553,10 @@ _ctl_set_task_mid(struct MPT3SAS_ADAPTER *ioc, struct mpt3_ioctl_command *karg,
 	Mpi2SCSITaskManagementRequest_t *tm_request)
 {
 	u8 found = 0;
-	u16 i;
+	u16 smid;
 	u16 handle;
 	struct scsi_cmnd *scmd;
 	struct MPT3SAS_DEVICE *priv_data;
-	unsigned long flags;
 	Mpi2SCSITaskManagementReply_t *tm_reply;
 	u32 sz;
 	u32 lun;
@@ -573,11 +572,11 @@ _ctl_set_task_mid(struct MPT3SAS_ADAPTER *ioc, struct mpt3_ioctl_command *karg,
 	lun = scsilun_to_int((struct scsi_lun *)tm_request->LUN);
 
 	handle = le16_to_cpu(tm_request->DevHandle);
-	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
-	for (i = ioc->scsiio_depth; i && !found; i--) {
-		scmd = ioc->scsi_lookup[i - 1].scmd;
-		if (scmd == NULL || scmd->device == NULL ||
-		    scmd->device->hostdata == NULL)
+	for (smid = ioc->scsiio_depth; smid && !found; smid--) {
+		struct scsiio_tracker *st;
+
+		scmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);
+		if (!scmd)
 			continue;
 		if (lun != scmd->device->lun)
 			continue;
@@ -586,10 +585,10 @@ _ctl_set_task_mid(struct MPT3SAS_ADAPTER *ioc, struct mpt3_ioctl_command *karg,
 			continue;
 		if (priv_data->sas_target->handle != handle)
 			continue;
-		tm_request->TaskMID = cpu_to_le16(ioc->scsi_lookup[i - 1].smid);
+		st = scsi_cmd_priv(scmd);
+		tm_request->TaskMID = cpu_to_le16(st->smid);
 		found = 1;
 	}
-	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
 
 	if (!found) {
 		dctlprintk(ioc, pr_info(MPT3SAS_FMT
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_scsih.c
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_warpdrive.c
