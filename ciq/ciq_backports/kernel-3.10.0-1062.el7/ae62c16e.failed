userfaultfd: disable irqs when taking the waitqueue lock

jira LE-1907
cve CVE-2018-18397
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit ae62c16e105a869524afcf8a07ee85c5ae5d0479
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ae62c16e.failed

userfaultfd contains howe-grown locking of the waitqueue lock, and does
not disable interrupts.  This relies on the fact that no one else takes it
from interrupt context and violates an invariat of the normal waitqueue
locking scheme.  With aio poll it is easy to trigger other locks that
disable interrupts (or are called from interrupt context).

Link: http://lkml.kernel.org/r/20181018154101.18750-1-hch@lst.de
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Andrea Arcangeli <aarcange@redhat.com>
	Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
	Cc: <stable@vger.kernel.org>	[4.19.x]
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ae62c16e105a869524afcf8a07ee85c5ae5d0479)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/userfaultfd.c
diff --cc fs/userfaultfd.c
index 461ed05b3a6e,356d2b8568c1..000000000000
--- a/fs/userfaultfd.c
+++ b/fs/userfaultfd.c
@@@ -1023,8 -1026,8 +1023,13 @@@ static ssize_t userfaultfd_ctx_read(str
  	struct userfaultfd_ctx *fork_nctx = NULL;
  
  	/* always take the fd_wqh lock before the fault_pending_wqh lock */
++<<<<<<< HEAD
 +	spin_lock(&ctx->fd_wqh.lock);
 +	__add_wait_queue_exclusive(&ctx->fd_wqh, &wait);
++=======
+ 	spin_lock_irq(&ctx->fd_wqh.lock);
+ 	__add_wait_queue(&ctx->fd_wqh, &wait);
++>>>>>>> ae62c16e105a (userfaultfd: disable irqs when taking the waitqueue lock)
  	for (;;) {
  		set_current_state(TASK_INTERRUPTIBLE);
  		spin_lock(&ctx->fault_pending_wqh.lock);
* Unmerged path fs/userfaultfd.c
