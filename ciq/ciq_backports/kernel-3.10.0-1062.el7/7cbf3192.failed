mm: fix nr_rotate_swap leak in swapon() error case

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [mm] swap: fix nr_rotate_swap leak in swapon() error case (Rafael Aquini) [1485248]
Rebuild_FUZZ: 94.12%
commit-author Omar Sandoval <osandov@fb.com>
commit 7cbf319234adaa4518a28c8c523d3330e06638f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7cbf3192.failed

If swapon() fails after incrementing nr_rotate_swap, we don't decrement
it and thus effectively leak it.  Make sure we decrement it if we
incremented it.

Link: http://lkml.kernel.org/r/b6fe6b879f17fa68eee6cbd876f459f6e5e33495.1526491581.git.osandov@fb.com
Fixes: 81a0298bdfab ("mm, swap: don't use VMA based swap readahead if HDD is used as swap")
	Signed-off-by: Omar Sandoval <osandov@fb.com>
	Reviewed-by: Rik van Riel <riel@surriel.com>
	Reviewed-by: "Huang, Ying" <ying.huang@intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 7cbf319234adaa4518a28c8c523d3330e06638f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/swapfile.c
diff --cc mm/swapfile.c
index 8cf0784a0684,78a015fcec3b..000000000000
--- a/mm/swapfile.c
+++ b/mm/swapfile.c
@@@ -2831,11 -3211,14 +2832,17 @@@ SYSCALL_DEFINE2(swapon, const char __us
  			error = -ENOMEM;
  			goto bad_swap;
  		}
 -		for_each_possible_cpu(cpu) {
 +		for_each_possible_cpu(i) {
  			struct percpu_cluster *cluster;
 -			cluster = per_cpu_ptr(p->percpu_cluster, cpu);
 +			cluster = per_cpu_ptr(p->percpu_cluster, i);
  			cluster_set_null(&cluster->index);
  		}
++<<<<<<< HEAD
++=======
+ 	} else {
+ 		atomic_inc(&nr_rotate_swap);
+ 		inced_nr_rotate_swap = true;
++>>>>>>> 7cbf319234ad (mm: fix nr_rotate_swap leak in swapon() error case)
  	}
  
  	error = swap_cgroup_swapon(p->type, maxpages);
@@@ -2928,9 -3309,12 +2935,15 @@@ bad_swap
  	spin_unlock(&swap_lock);
  	vfree(swap_map);
  	kvfree(cluster_info);
++<<<<<<< HEAD
++=======
+ 	kvfree(frontswap_map);
+ 	if (inced_nr_rotate_swap)
+ 		atomic_dec(&nr_rotate_swap);
++>>>>>>> 7cbf319234ad (mm: fix nr_rotate_swap leak in swapon() error case)
  	if (swap_file) {
  		if (inode && S_ISREG(inode->i_mode)) {
 -			inode_unlock(inode);
 +			mutex_unlock(&inode->i_mutex);
  			inode = NULL;
  		}
  		filp_close(swap_file, NULL);
* Unmerged path mm/swapfile.c
