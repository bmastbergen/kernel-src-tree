net/mlx5e: Support offloading double vlan push/pop tc actions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Support offloading double vlan push/pop tc actions (Alaa Hleihel) [1642344 1642498]
Rebuild_FUZZ: 96.61%
commit-author Jianbo Liu <jianbol@mellanox.com>
commit cc495188a8ff0d169ad7c0182acd9c08b90e29ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/cc495188.failed

As we can configure two push/pop actions in one flow table entry,
add support to offload those double vlan actions in a rule to HW.

	Signed-off-by: Jianbo Liu <jianbol@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit cc495188a8ff0d169ad7c0182acd9c08b90e29ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 79628b20ce99,e9888d6c1f7c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -2537,6 -2578,56 +2537,59 @@@ out_err
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int parse_tc_vlan_action(struct mlx5e_priv *priv,
+ 				const struct tc_action *a,
+ 				struct mlx5_esw_flow_attr *attr,
+ 				u32 *action)
+ {
+ 	u8 vlan_idx = attr->total_vlan;
+ 
+ 	if (vlan_idx >= MLX5_FS_VLAN_DEPTH)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (tcf_vlan_action(a) == TCA_VLAN_ACT_POP) {
+ 		if (vlan_idx) {
+ 			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev,
+ 								 MLX5_FS_VLAN_DEPTH))
+ 				return -EOPNOTSUPP;
+ 
+ 			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP_2;
+ 		} else {
+ 			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;
+ 		}
+ 	} else if (tcf_vlan_action(a) == TCA_VLAN_ACT_PUSH) {
+ 		attr->vlan_vid[vlan_idx] = tcf_vlan_push_vid(a);
+ 		attr->vlan_prio[vlan_idx] = tcf_vlan_push_prio(a);
+ 		attr->vlan_proto[vlan_idx] = tcf_vlan_push_proto(a);
+ 		if (!attr->vlan_proto[vlan_idx])
+ 			attr->vlan_proto[vlan_idx] = htons(ETH_P_8021Q);
+ 
+ 		if (vlan_idx) {
+ 			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev,
+ 								 MLX5_FS_VLAN_DEPTH))
+ 				return -EOPNOTSUPP;
+ 
+ 			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH_2;
+ 		} else {
+ 			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev, 1) &&
+ 			    (tcf_vlan_push_proto(a) != htons(ETH_P_8021Q) ||
+ 			     tcf_vlan_push_prio(a)))
+ 				return -EOPNOTSUPP;
+ 
+ 			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH;
+ 		}
+ 	} else { /* action is TCA_VLAN_ACT_MODIFY */
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	attr->total_vlan = vlan_idx + 1;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> cc495188a8ff (net/mlx5e: Support offloading double vlan push/pop tc actions)
  static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
  				struct mlx5e_tc_flow_parse_attr *parse_attr,
  				struct mlx5e_tc_flow *flow)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index dbd6e161f51c,c17bfcab517c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -240,16 -244,23 +241,23 @@@ enum mlx5_flow_match_level 
  	MLX5_MATCH_L4	= MLX5_INLINE_MODE_TCP_UDP,
  };
  
 -/* current maximum for flow based vport multicasting */
 -#define MLX5_MAX_FLOW_FWD_VPORTS 2
 -
  struct mlx5_esw_flow_attr {
  	struct mlx5_eswitch_rep *in_rep;
 -	struct mlx5_eswitch_rep *out_rep[MLX5_MAX_FLOW_FWD_VPORTS];
 -	struct mlx5_core_dev	*out_mdev[MLX5_MAX_FLOW_FWD_VPORTS];
 +	struct mlx5_eswitch_rep *out_rep;
 +	struct mlx5_core_dev	*out_mdev;
  	struct mlx5_core_dev	*in_mdev;
  
 -	int mirror_count;
 -	int out_count;
 -
  	int	action;
++<<<<<<< HEAD
 +	__be16	vlan_proto;
 +	u16	vlan_vid;
 +	u8	vlan_prio;
++=======
+ 	__be16	vlan_proto[MLX5_FS_VLAN_DEPTH];
+ 	u16	vlan_vid[MLX5_FS_VLAN_DEPTH];
+ 	u8	vlan_prio[MLX5_FS_VLAN_DEPTH];
+ 	u8	total_vlan;
++>>>>>>> cc495188a8ff (net/mlx5e: Support offloading double vlan push/pop tc actions)
  	bool	vlan_handled;
  	u32	encap_id;
  	u32	mod_hdr_id;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index c66aee7a3bf6,f72b5c9dcfe9..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -58,15 -59,25 +58,26 @@@ mlx5_eswitch_add_offloaded_rule(struct 
  	if (esw->mode != SRIOV_OFFLOADS)
  		return ERR_PTR(-EOPNOTSUPP);
  
 -	if (attr->mirror_count)
 -		ft = esw->fdb_table.offloads.fwd_fdb;
 -	else
 -		ft = esw->fdb_table.offloads.fast_fdb;
 -
  	flow_act.action = attr->action;
  	/* if per flow vlan pop/push is emulated, don't set that into the firmware */
- 	if (!mlx5_eswitch_vlan_actions_supported(esw->dev))
+ 	if (!mlx5_eswitch_vlan_actions_supported(esw->dev, 1))
  		flow_act.action &= ~(MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH |
  				     MLX5_FLOW_CONTEXT_ACTION_VLAN_POP);
  	else if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH) {
++<<<<<<< HEAD
 +		flow_act.vlan.ethtype = ntohs(attr->vlan_proto);
 +		flow_act.vlan.vid = attr->vlan_vid;
 +		flow_act.vlan.prio = attr->vlan_prio;
++=======
+ 		flow_act.vlan[0].ethtype = ntohs(attr->vlan_proto[0]);
+ 		flow_act.vlan[0].vid = attr->vlan_vid[0];
+ 		flow_act.vlan[0].prio = attr->vlan_prio[0];
+ 		if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH_2) {
+ 			flow_act.vlan[1].ethtype = ntohs(attr->vlan_proto[1]);
+ 			flow_act.vlan[1].vid = attr->vlan_vid[1];
+ 			flow_act.vlan[1].prio = attr->vlan_prio[1];
+ 		}
++>>>>>>> cc495188a8ff (net/mlx5e: Support offloading double vlan push/pop tc actions)
  	}
  
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
