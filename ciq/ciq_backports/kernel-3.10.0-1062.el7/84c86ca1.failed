perf tools: Enable passing bpf object file to --event

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Wang Nan <wangnan0@huawei.com>
commit 84c86ca12b2189df751eed7b2d67cb63bc8feda5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/84c86ca1.failed

By introducing new rules in tools/perf/util/parse-events.[ly], this
patch enables 'perf record --event bpf_file.o' to select events by an
eBPF object file. It calls parse_events_load_bpf() to load that file,
which uses bpf__prepare_load() and finally calls bpf_object__open() for
the object files.

After applying this patch, commands like:

 # perf record --event foo.o sleep

become possible.

However, at this point it is unable to link any useful things onto the
evsel list because the creating of probe points and BPF program
attaching have not been implemented.  Before real events are possible to
be extracted, to avoid perf report error because of empty evsel list,
this patch link a dummy evsel. The dummy event related code will be
removed when probing and extracting code is ready.

Commiter notes:

Using it:

  $ ls -la foo.o
  ls: cannot access foo.o: No such file or directory
  $ perf record --event foo.o sleep
  libbpf: failed to open foo.o: No such file or directory
  event syntax error: 'foo.o'
                       \___ BPF object file 'foo.o' is invalid

  (add -v to see detail)
  Run 'perf list' for a list of valid events

   Usage: perf record [<options>] [<command>]
      or: perf record [<options>] -- <command> [<options>]

      -e, --event <event>   event selector. use 'perf list' to list available events
  $

  $ file /tmp/build/perf/perf.o
  /tmp/build/perf/perf.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
  $ perf record --event /tmp/build/perf/perf.o sleep
  libbpf: /tmp/build/perf/perf.o is not an eBPF object file
  event syntax error: '/tmp/build/perf/perf.o'
                       \___ BPF object file '/tmp/build/perf/perf.o' is invalid

  (add -v to see detail)
  Run 'perf list' for a list of valid events

   Usage: perf record [<options>] [<command>]
      or: perf record [<options>] -- <command> [<options>]

      -e, --event <event>   event selector. use 'perf list' to list available events
  $

  $ file /tmp/foo.o
  /tmp/foo.o: ELF 64-bit LSB relocatable, no machine, version 1 (SYSV), not stripped
  $ perf record --event /tmp/foo.o sleep 1
  [ perf record: Woken up 1 times to write data ]
  [ perf record: Captured and wrote 0.013 MB perf.data ]
  $ perf evlist
  /tmp/foo.o
  $ perf evlist  -v
  /tmp/foo.o: type: 1, size: 112, config: 0x9, { sample_period, sample_freq }: 4000, sample_type: IP|TID|TIME|PERIOD, disabled: 1, inherit: 1, mmap: 1, comm: 1, freq: 1, enable_on_exec: 1, task: 1, sample_id_all: 1, exclude_guest: 1, mmap2: 1, comm_exec: 1
  $

So, type 1 is PERF_TYPE_SOFTWARE, config 0x9 is PERF_COUNT_SW_DUMMY, ok.

  $ perf report --stdio
  Error:
  The perf.data file has no samples!
  # To display the perf.data header info, please use --header/--header-only options.
  #
  $

	Signed-off-by: Wang Nan <wangnan0@huawei.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Alexei Starovoitov <ast@plumgrid.com>
	Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
	Cc: Daniel Borkmann <daniel@iogearbox.net>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: He Kuang <hekuang@huawei.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Kaixu Xia <xiakaixu@huawei.com>
	Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: pi3orama@163.com
Link: http://lkml.kernel.org/r/1444826502-49291-4-git-send-email-wangnan0@huawei.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 84c86ca12b2189df751eed7b2d67cb63bc8feda5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/perf.c
#	tools/perf/util/parse-events.h
#	tools/perf/util/parse-events.y
diff --cc tools/perf/perf.c
index 4d2452b7e6f5,3d4c7c09adea..000000000000
--- a/tools/perf/perf.c
+++ b/tools/perf/perf.c
@@@ -9,25 -9,16 +9,30 @@@
  #include "builtin.h"
  
  #include "util/env.h"
 -#include "util/exec_cmd.h"
 -#include "util/cache.h"
 +#include <subcmd/exec-cmd.h>
 +#include "util/config.h"
  #include "util/quote.h"
 -#include "util/run-command.h"
 +#include <subcmd/run-command.h>
  #include "util/parse-events.h"
++<<<<<<< HEAD
 +#include <subcmd/parse-options.h>
++=======
+ #include "util/parse-options.h"
+ #include "util/bpf-loader.h"
++>>>>>>> 84c86ca12b21 (perf tools: Enable passing bpf object file to --event)
  #include "util/debug.h"
 +#include "util/event.h"
 +#include <api/fs/fs.h>
  #include <api/fs/tracing_path.h>
 +#include <errno.h>
  #include <pthread.h>
 +#include <signal.h>
 +#include <stdlib.h>
 +#include <time.h>
 +#include <sys/types.h>
 +#include <sys/stat.h>
 +#include <unistd.h>
 +#include <linux/kernel.h>
  
  const char perf_usage_string[] =
  	"perf [--version] [--help] [OPTIONS] COMMAND [ARGS]";
@@@ -291,11 -383,10 +296,12 @@@ static int run_builtin(struct cmd_struc
  		use_pager = 1;
  	commit_pager_choice();
  
 -	status = p->fn(argc, argv, prefix);
 +	perf_env__set_cmdline(&perf_env, argc, argv);
 +	status = p->fn(argc, argv);
 +	perf_config__exit();
  	exit_browser(status);
  	perf_env__exit(&perf_env);
+ 	bpf__clear();
  
  	if (status)
  		return status & 0xff;
diff --cc tools/perf/util/parse-events.h
index 411808bd5db5,765018a17448..000000000000
--- a/tools/perf/util/parse-events.h
+++ b/tools/perf/util/parse-events.h
@@@ -128,10 -120,18 +128,22 @@@ int parse_events__modifier_event(struc
  int parse_events__modifier_group(struct list_head *list, char *event_mod);
  int parse_events_name(struct list_head *list, char *name);
  int parse_events_add_tracepoint(struct list_head *list, int *idx,
 -				char *sys, char *event,
 +				const char *sys, const char *event,
  				struct parse_events_error *error,
  				struct list_head *head_config);
++<<<<<<< HEAD
 +int parse_events_add_numeric(struct parse_events_state *parse_state,
++=======
+ int parse_events_load_bpf(struct parse_events_evlist *data,
+ 			  struct list_head *list,
+ 			  char *bpf_file_name);
+ /* Provide this function for perf test */
+ struct bpf_object;
+ int parse_events_load_bpf_obj(struct parse_events_evlist *data,
+ 			      struct list_head *list,
+ 			      struct bpf_object *obj);
+ int parse_events_add_numeric(struct parse_events_evlist *data,
++>>>>>>> 84c86ca12b21 (perf tools: Enable passing bpf object file to --event)
  			     struct list_head *list,
  			     u32 type, u64 config,
  			     struct list_head *head_config);
diff --cc tools/perf/util/parse-events.y
index b7975dc972b1,497f19b20f0b..000000000000
--- a/tools/perf/util/parse-events.y
+++ b/tools/perf/util/parse-events.y
@@@ -210,40 -206,28 +213,41 @@@ event_def: event_pmu 
  	   event_legacy_mem |
  	   event_legacy_tracepoint sep_dc |
  	   event_legacy_numeric sep_dc |
- 	   event_legacy_raw sep_dc
+ 	   event_legacy_raw sep_dc |
+ 	   event_bpf_file
  
  event_pmu:
 -PE_NAME '/' event_config '/'
 +PE_NAME opt_event_config
  {
 -	struct parse_events_evlist *data = _data;
 -	struct list_head *list;
 +	struct list_head *list, *orig_terms, *terms;
  
 -	ALLOC_LIST(list);
 -	ABORT_ON(parse_events_add_pmu(data, list, $1, $3));
 -	parse_events__free_terms($3);
 -	$$ = list;
 -}
 -|
 -PE_NAME '/' '/'
 -{
 -	struct parse_events_evlist *data = _data;
 -	struct list_head *list;
 +	if (parse_events_copy_term_list($2, &orig_terms))
 +		YYABORT;
  
  	ALLOC_LIST(list);
 -	ABORT_ON(parse_events_add_pmu(data, list, $1, NULL));
 +	if (parse_events_add_pmu(_parse_state, list, $1, $2)) {
 +		struct perf_pmu *pmu = NULL;
 +		int ok = 0;
 +
 +		while ((pmu = perf_pmu__scan(pmu)) != NULL) {
 +			char *name = pmu->name;
 +
 +			if (!strncmp(name, "uncore_", 7) &&
 +			    strncmp($1, "uncore_", 7))
 +				name += 7;
 +			if (!strncmp($1, name, strlen($1))) {
 +				if (parse_events_copy_term_list(orig_terms, &terms))
 +					YYABORT;
 +				if (!parse_events_add_pmu(_parse_state, list, pmu->name, terms))
 +					ok++;
 +				parse_events_terms__delete(terms);
 +			}
 +		}
 +		if (!ok)
 +			YYABORT;
 +	}
 +	parse_events_terms__delete($2);
 +	parse_events_terms__delete(orig_terms);
  	$$ = list;
  }
  |
@@@ -438,19 -453,16 +442,32 @@@ PE_RAW opt_event_confi
  	$$ = list;
  }
  
++<<<<<<< HEAD
 +opt_event_config:
 +'/' event_config '/'
 +{
 +	$$ = $2;
 +}
 +|
 +'/' '/'
 +{
 +	$$ = NULL;
 +}
 +|
 +{
 +	$$ = NULL;
++=======
+ event_bpf_file:
+ PE_BPF_OBJECT
+ {
+ 	struct parse_events_evlist *data = _data;
+ 	struct parse_events_error *error = data->error;
+ 	struct list_head *list;
+ 
+ 	ALLOC_LIST(list);
+ 	ABORT_ON(parse_events_load_bpf(data, list, $1));
+ 	$$ = list;
++>>>>>>> 84c86ca12b21 (perf tools: Enable passing bpf object file to --event)
  }
  
  start_terms: event_config
* Unmerged path tools/perf/perf.c
diff --git a/tools/perf/util/Build b/tools/perf/util/Build
index 6be76ae5c66f..13eceb412c0f 100644
--- a/tools/perf/util/Build
+++ b/tools/perf/util/Build
@@ -98,6 +98,7 @@ libperf-y += time-utils.o
 libperf-y += expr-bison.o
 libperf-y += branch.o
 
+libperf-$(CONFIG_LIBBPF) += bpf-loader.o
 libperf-$(CONFIG_LIBELF) += symbol-elf.o
 libperf-$(CONFIG_LIBELF) += probe-file.o
 libperf-$(CONFIG_LIBELF) += probe-event.o
diff --git a/tools/perf/util/parse-events.c b/tools/perf/util/parse-events.c
index 3a234b74d6ff..4146fe7aa00e 100644
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@ -16,6 +16,7 @@
 #include "symbol.h"
 #include "cache.h"
 #include "header.h"
+#include "bpf-loader.h"
 #include "debug.h"
 #include <api/fs/tracing_path.h>
 #include "parse-events-bison.h"
@@ -590,6 +591,62 @@ static int add_tracepoint_multi_sys(struct list_head *list, int *idx,
 	return ret;
 }
 
+int parse_events_load_bpf_obj(struct parse_events_evlist *data,
+			      struct list_head *list,
+			      struct bpf_object *obj)
+{
+	int err;
+	char errbuf[BUFSIZ];
+
+	if (IS_ERR(obj) || !obj) {
+		snprintf(errbuf, sizeof(errbuf),
+			 "Internal error: load bpf obj with NULL");
+		err = -EINVAL;
+		goto errout;
+	}
+
+	/*
+	 * Temporary add a dummy event here so we can check whether
+	 * basic bpf loader works. Following patches will replace
+	 * dummy event by useful evsels.
+	 */
+	return parse_events_add_numeric(data, list, PERF_TYPE_SOFTWARE,
+					PERF_COUNT_SW_DUMMY, NULL);
+errout:
+	data->error->help = strdup("(add -v to see detail)");
+	data->error->str = strdup(errbuf);
+	return err;
+}
+
+int parse_events_load_bpf(struct parse_events_evlist *data,
+			  struct list_head *list,
+			  char *bpf_file_name)
+{
+	struct bpf_object *obj;
+
+	obj = bpf__prepare_load(bpf_file_name);
+	if (IS_ERR(obj) || !obj) {
+		char errbuf[BUFSIZ];
+		int err;
+
+		err = obj ? PTR_ERR(obj) : -EINVAL;
+
+		if (err == -ENOTSUP)
+			snprintf(errbuf, sizeof(errbuf),
+				 "BPF support is not compiled");
+		else
+			snprintf(errbuf, sizeof(errbuf),
+				 "BPF object file '%s' is invalid",
+				 bpf_file_name);
+
+		data->error->help = strdup("(add -v to see detail)");
+		data->error->str = strdup(errbuf);
+		return err;
+	}
+
+	return parse_events_load_bpf_obj(data, list, obj);
+}
+
 static int
 parse_breakpoint_type(const char *type, struct perf_event_attr *attr)
 {
* Unmerged path tools/perf/util/parse-events.h
diff --git a/tools/perf/util/parse-events.l b/tools/perf/util/parse-events.l
index 32c8c241ab5c..39cb790e2e89 100644
--- a/tools/perf/util/parse-events.l
+++ b/tools/perf/util/parse-events.l
@@ -135,6 +135,7 @@ do {							\
 group		[^,{}/]*[{][^}]*[}][^,{}/]*
 event_pmu	[^,{}/]+[/][^/]*[/][^,{}/]*
 event		[^,{}/]+
+bpf_object	.*\.(o|bpf)
 
 num_dec		[0-9]+
 num_hex		0x[a-fA-F0-9]+
@@ -180,6 +181,7 @@ modifier_bp	[rwx]{1,3}
 		}
 
 {event_pmu}	|
+{bpf_object}	|
 {event}		{
 			BEGIN(INITIAL);
 			REWIND(1);
@@ -291,6 +293,7 @@ r{num_raw_hex}		{ return raw(yyscanner); }
 {num_hex}		{ return value(yyscanner, 16); }
 
 {modifier_event}	{ return str(yyscanner, PE_MODIFIER_EVENT); }
+{bpf_object}		{ return str(yyscanner, PE_BPF_OBJECT); }
 {name}			{ return pmu_str_check(yyscanner); }
 "/"			{ BEGIN(config); return '/'; }
 -			{ return '-'; }
* Unmerged path tools/perf/util/parse-events.y
