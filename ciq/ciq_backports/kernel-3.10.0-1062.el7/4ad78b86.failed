s390/setup: set control program code via diag 318

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [s390] setup: set control program code via diag 318 (Thomas Huth) [1642855]
Rebuild_FUZZ: 94.62%
commit-author Collin Walling <walling@linux.ibm.com>
commit 4ad78b8651aacf26b3ab6d1e784952eb70469c43
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4ad78b86.failed

The s390x diagnose 318 instruction sets the control program name code (CPNC)
and control program version code (CPVC) to provide useful information
regarding the OS during debugging. The CPNC is explicitly set to 4 to
indicate a Linux/KVM environment.

The CPVC is a 7-byte value containing:

 - 3-byte Linux version code, currently set to 0
 - 3-byte unique value, currently set to 0
 - 1-byte trailing null

	Signed-off-by: Collin Walling <walling@linux.ibm.com>
	Acked-by: Janosch Frank <frankja@linux.ibm.com>
	Acked-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Reviewed-by: David Hildenbrand <david@redhat.com>
	Reviewed-by: Cornelia Huck <cohuck@redhat.com>
Message-Id: <1544135405-22385-2-git-send-email-walling@linux.ibm.com>
[set version code to 0 until the structure is fully defined]
	Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 4ad78b8651aacf26b3ab6d1e784952eb70469c43)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/diag.h
#	arch/s390/include/asm/sclp.h
#	arch/s390/kernel/diag.c
#	arch/s390/kernel/setup.c
#	drivers/s390/char/sclp.h
#	drivers/s390/char/sclp_early.c
diff --cc arch/s390/include/asm/diag.h
index a14df4d20367,19562be22b7e..000000000000
--- a/arch/s390/include/asm/diag.h
+++ b/arch/s390/include/asm/diag.h
@@@ -9,6 -10,35 +9,38 @@@
  #define _ASM_S390_DIAG_H
  
  #include <linux/if_ether.h>
++<<<<<<< HEAD
++=======
+ #include <linux/percpu.h>
+ 
+ enum diag_stat_enum {
+ 	DIAG_STAT_X008,
+ 	DIAG_STAT_X00C,
+ 	DIAG_STAT_X010,
+ 	DIAG_STAT_X014,
+ 	DIAG_STAT_X044,
+ 	DIAG_STAT_X064,
+ 	DIAG_STAT_X09C,
+ 	DIAG_STAT_X0DC,
+ 	DIAG_STAT_X204,
+ 	DIAG_STAT_X210,
+ 	DIAG_STAT_X224,
+ 	DIAG_STAT_X250,
+ 	DIAG_STAT_X258,
+ 	DIAG_STAT_X26C,
+ 	DIAG_STAT_X288,
+ 	DIAG_STAT_X2C4,
+ 	DIAG_STAT_X2FC,
+ 	DIAG_STAT_X304,
+ 	DIAG_STAT_X308,
+ 	DIAG_STAT_X318,
+ 	DIAG_STAT_X500,
+ 	NR_DIAG_STAT
+ };
+ 
+ void diag_stat_inc(enum diag_stat_enum nr);
+ void diag_stat_inc_norecursion(enum diag_stat_enum nr);
++>>>>>>> 4ad78b8651aa (s390/setup: set control program code via diag 318)
  
  /*
   * Diagnose 10: Release page range
@@@ -223,6 -229,83 +255,85 @@@ struct diag204_x_phys_block 
  	struct diag204_x_phys_cpu cpus[];
  } __packed;
  
++<<<<<<< HEAD
++=======
+ enum diag26c_sc {
+ 	DIAG26C_PORT_VNIC    = 0x00000024,
+ 	DIAG26C_MAC_SERVICES = 0x00000030
+ };
+ 
+ enum diag26c_version {
+ 	DIAG26C_VERSION2	 = 0x00000002,	/* z/VM 5.4.0 */
+ 	DIAG26C_VERSION6_VM65918 = 0x00020006	/* z/VM 6.4.0 + VM65918 */
+ };
+ 
+ #define DIAG26C_VNIC_INFO	0x0002
+ struct diag26c_vnic_req {
+ 	u32	resp_buf_len;
+ 	u32	resp_version;
+ 	u16	req_format;
+ 	u16	vlan_id;
+ 	u64	sys_name;
+ 	u8	res[2];
+ 	u16	devno;
+ } __packed __aligned(8);
+ 
+ #define VNIC_INFO_PROT_L3	1
+ #define VNIC_INFO_PROT_L2	2
+ /* Note: this is the bare minimum, use it for uninitialized VNICs only. */
+ struct diag26c_vnic_resp {
+ 	u32	version;
+ 	u32	entry_cnt;
+ 	/* VNIC info: */
+ 	u32	next_entry;
+ 	u64	owner;
+ 	u16	devno;
+ 	u8	status;
+ 	u8	type;
+ 	u64	lan_owner;
+ 	u64	lan_name;
+ 	u64	port_name;
+ 	u8	port_type;
+ 	u8	ext_status:6;
+ 	u8	protocol:2;
+ 	u16	base_devno;
+ 	u32	port_num;
+ 	u32	ifindex;
+ 	u32	maxinfo;
+ 	u32	dev_count;
+ 	/* 3x device info: */
+ 	u8	dev_info1[28];
+ 	u8	dev_info2[28];
+ 	u8	dev_info3[28];
+ } __packed __aligned(8);
+ 
+ #define DIAG26C_GET_MAC	0x0000
+ struct diag26c_mac_req {
+ 	u32	resp_buf_len;
+ 	u32	resp_version;
+ 	u16	op_code;
+ 	u16	devno;
+ 	u8	res[4];
+ };
+ 
+ struct diag26c_mac_resp {
+ 	u32	version;
+ 	u8	mac[ETH_ALEN];
+ 	u8	res[2];
+ } __aligned(8);
+ 
+ #define CPNC_LINUX		0x4
+ union diag318_info {
+ 	unsigned long val;
+ 	struct {
+ 		unsigned int cpnc : 8;
+ 		unsigned int cpvc_linux : 24;
+ 		unsigned char cpvc_distro[3];
+ 		unsigned char zero;
+ 	};
+ };
+ 
++>>>>>>> 4ad78b8651aa (s390/setup: set control program code via diag 318)
  int diag204(unsigned long subcode, unsigned long size, void *addr);
  int diag224(void *ptr);
 -int diag26c(void *req, void *resp, enum diag26c_sc subcode);
  #endif /* _ASM_S390_DIAG_H */
diff --cc arch/s390/include/asm/sclp.h
index 21049d84cc3d,ef4c9dec06a4..000000000000
--- a/arch/s390/include/asm/sclp.h
+++ b/arch/s390/include/asm/sclp.h
@@@ -44,19 -54,72 +44,85 @@@ struct sclp_cpu_info 
  	unsigned int configured;
  	unsigned int standby;
  	unsigned int combined;
 -	struct sclp_core_entry core[SCLP_MAX_CORES];
 +	int has_cpu_type;
 +	struct sclp_cpu_entry cpu[MAX_CPU_ADDRESS + 1];
  };
  
++<<<<<<< HEAD
 +int sclp_get_cpu_info(struct sclp_cpu_info *info);
 +int sclp_cpu_configure(u8 cpu);
 +int sclp_cpu_deconfigure(u8 cpu);
 +unsigned long long sclp_get_rnmax(void);
 +unsigned long long sclp_get_rzm(void);
 +unsigned int sclp_get_max_cpu(void);
 +unsigned int sclp_get_mtid(u8 cpu_type);
 +unsigned int sclp_get_mtid_max(void);
 +unsigned int sclp_get_mtid_prev(void);
++=======
+ struct sclp_info {
+ 	unsigned char has_linemode : 1;
+ 	unsigned char has_vt220 : 1;
+ 	unsigned char has_siif : 1;
+ 	unsigned char has_sigpif : 1;
+ 	unsigned char has_core_type : 1;
+ 	unsigned char has_sprp : 1;
+ 	unsigned char has_hvs : 1;
+ 	unsigned char has_esca : 1;
+ 	unsigned char has_sief2 : 1;
+ 	unsigned char has_64bscao : 1;
+ 	unsigned char has_gpere : 1;
+ 	unsigned char has_cmma : 1;
+ 	unsigned char has_gsls : 1;
+ 	unsigned char has_ib : 1;
+ 	unsigned char has_cei : 1;
+ 	unsigned char has_pfmfi : 1;
+ 	unsigned char has_ibs : 1;
+ 	unsigned char has_skey : 1;
+ 	unsigned char has_kss : 1;
+ 	unsigned char has_gisaf : 1;
+ 	unsigned char has_diag318 : 1;
+ 	unsigned int ibc;
+ 	unsigned int mtid;
+ 	unsigned int mtid_cp;
+ 	unsigned int mtid_prev;
+ 	unsigned long rzm;
+ 	unsigned long rnmax;
+ 	unsigned long hamax;
+ 	unsigned int max_cores;
+ 	unsigned long hsa_size;
+ 	unsigned long facilities;
+ 	unsigned int hmfai;
+ };
+ extern struct sclp_info sclp;
+ 
+ struct zpci_report_error_header {
+ 	u8 version;	/* Interface version byte */
+ 	u8 action;	/* Action qualifier byte
+ 			 * 0: Adapter Reset Request
+ 			 * 1: Deconfigure and repair action requested
+ 			 *	(OpenCrypto Problem Call Home)
+ 			 * 2: Informational Report
+ 			 *	(OpenCrypto Successful Diagnostics Execution)
+ 			 */
+ 	u16 length;	/* Length of Subsequent Data (up to 4K â€“ SCLP header */
+ 	u8 data[0];	/* Subsequent Data passed verbatim to SCLP ET 24 */
+ } __packed;
+ 
+ int sclp_early_read_info(void);
+ int sclp_early_read_storage_info(void);
+ int sclp_early_get_core_info(struct sclp_core_info *info);
+ void sclp_early_get_ipl_info(struct sclp_ipl_info *info);
+ void sclp_early_detect(void);
+ void sclp_early_printk(const char *s);
+ void sclp_early_printk_force(const char *s);
+ void __sclp_early_printk(const char *s, unsigned int len, unsigned int force);
+ 
+ int sclp_early_get_memsize(unsigned long *mem);
+ int sclp_early_get_hsa_size(unsigned long *hsa_size);
+ int _sclp_get_core_info(struct sclp_core_info *info);
+ int sclp_core_configure(u8 core);
+ int sclp_core_deconfigure(u8 core);
++>>>>>>> 4ad78b8651aa (s390/setup: set control program code via diag 318)
  int sclp_sdias_blk_count(void);
  int sclp_sdias_copy(void *dest, int blk_num, int nr_blks);
  int sclp_chp_configure(struct chp_id chpid);
diff --cc arch/s390/kernel/diag.c
index 55dee28dda39,7edaa733a77f..000000000000
--- a/arch/s390/kernel/diag.c
+++ b/arch/s390/kernel/diag.c
@@@ -5,8 -6,135 +5,134 @@@
   * Author(s): Michael Holzheu <holzheu@de.ibm.com>
   */
  
 -#include <linux/export.h>
 -#include <linux/init.h>
 -#include <linux/cpu.h>
 -#include <linux/seq_file.h>
 -#include <linux/debugfs.h>
 +#include <linux/module.h>
  #include <asm/diag.h>
++<<<<<<< HEAD
++=======
+ #include <asm/trace/diag.h>
+ 
+ struct diag_stat {
+ 	unsigned int counter[NR_DIAG_STAT];
+ };
+ 
+ static DEFINE_PER_CPU(struct diag_stat, diag_stat);
+ 
+ struct diag_desc {
+ 	int code;
+ 	char *name;
+ };
+ 
+ static const struct diag_desc diag_map[NR_DIAG_STAT] = {
+ 	[DIAG_STAT_X008] = { .code = 0x008, .name = "Console Function" },
+ 	[DIAG_STAT_X00C] = { .code = 0x00c, .name = "Pseudo Timer" },
+ 	[DIAG_STAT_X010] = { .code = 0x010, .name = "Release Pages" },
+ 	[DIAG_STAT_X014] = { .code = 0x014, .name = "Spool File Services" },
+ 	[DIAG_STAT_X044] = { .code = 0x044, .name = "Voluntary Timeslice End" },
+ 	[DIAG_STAT_X064] = { .code = 0x064, .name = "NSS Manipulation" },
+ 	[DIAG_STAT_X09C] = { .code = 0x09c, .name = "Relinquish Timeslice" },
+ 	[DIAG_STAT_X0DC] = { .code = 0x0dc, .name = "Appldata Control" },
+ 	[DIAG_STAT_X204] = { .code = 0x204, .name = "Logical-CPU Utilization" },
+ 	[DIAG_STAT_X210] = { .code = 0x210, .name = "Device Information" },
+ 	[DIAG_STAT_X224] = { .code = 0x224, .name = "EBCDIC-Name Table" },
+ 	[DIAG_STAT_X250] = { .code = 0x250, .name = "Block I/O" },
+ 	[DIAG_STAT_X258] = { .code = 0x258, .name = "Page-Reference Services" },
+ 	[DIAG_STAT_X26C] = { .code = 0x26c, .name = "Certain System Information" },
+ 	[DIAG_STAT_X288] = { .code = 0x288, .name = "Time Bomb" },
+ 	[DIAG_STAT_X2C4] = { .code = 0x2c4, .name = "FTP Services" },
+ 	[DIAG_STAT_X2FC] = { .code = 0x2fc, .name = "Guest Performance Data" },
+ 	[DIAG_STAT_X304] = { .code = 0x304, .name = "Partition-Resource Service" },
+ 	[DIAG_STAT_X308] = { .code = 0x308, .name = "List-Directed IPL" },
+ 	[DIAG_STAT_X318] = { .code = 0x318, .name = "CP Name and Version Codes" },
+ 	[DIAG_STAT_X500] = { .code = 0x500, .name = "Virtio Service" },
+ };
+ 
+ static int show_diag_stat(struct seq_file *m, void *v)
+ {
+ 	struct diag_stat *stat;
+ 	unsigned long n = (unsigned long) v - 1;
+ 	int cpu, prec, tmp;
+ 
+ 	get_online_cpus();
+ 	if (n == 0) {
+ 		seq_puts(m, "         ");
+ 
+ 		for_each_online_cpu(cpu) {
+ 			prec = 10;
+ 			for (tmp = 10; cpu >= tmp; tmp *= 10)
+ 				prec--;
+ 			seq_printf(m, "%*s%d", prec, "CPU", cpu);
+ 		}
+ 		seq_putc(m, '\n');
+ 	} else if (n <= NR_DIAG_STAT) {
+ 		seq_printf(m, "diag %03x:", diag_map[n-1].code);
+ 		for_each_online_cpu(cpu) {
+ 			stat = &per_cpu(diag_stat, cpu);
+ 			seq_printf(m, " %10u", stat->counter[n-1]);
+ 		}
+ 		seq_printf(m, "    %s\n", diag_map[n-1].name);
+ 	}
+ 	put_online_cpus();
+ 	return 0;
+ }
+ 
+ static void *show_diag_stat_start(struct seq_file *m, loff_t *pos)
+ {
+ 	return *pos <= nr_cpu_ids ? (void *)((unsigned long) *pos + 1) : NULL;
+ }
+ 
+ static void *show_diag_stat_next(struct seq_file *m, void *v, loff_t *pos)
+ {
+ 	++*pos;
+ 	return show_diag_stat_start(m, pos);
+ }
+ 
+ static void show_diag_stat_stop(struct seq_file *m, void *v)
+ {
+ }
+ 
+ static const struct seq_operations show_diag_stat_sops = {
+ 	.start	= show_diag_stat_start,
+ 	.next	= show_diag_stat_next,
+ 	.stop	= show_diag_stat_stop,
+ 	.show	= show_diag_stat,
+ };
+ 
+ static int show_diag_stat_open(struct inode *inode, struct file *file)
+ {
+ 	return seq_open(file, &show_diag_stat_sops);
+ }
+ 
+ static const struct file_operations show_diag_stat_fops = {
+ 	.open		= show_diag_stat_open,
+ 	.read		= seq_read,
+ 	.llseek		= seq_lseek,
+ 	.release	= seq_release,
+ };
+ 
+ 
+ static int __init show_diag_stat_init(void)
+ {
+ 	debugfs_create_file("diag_stat", 0400, NULL, NULL,
+ 			    &show_diag_stat_fops);
+ 	return 0;
+ }
+ 
+ device_initcall(show_diag_stat_init);
+ 
+ void diag_stat_inc(enum diag_stat_enum nr)
+ {
+ 	this_cpu_inc(diag_stat.counter[nr]);
+ 	trace_s390_diagnose(diag_map[nr].code);
+ }
+ EXPORT_SYMBOL(diag_stat_inc);
+ 
+ void diag_stat_inc_norecursion(enum diag_stat_enum nr)
+ {
+ 	this_cpu_inc(diag_stat.counter[nr]);
+ 	trace_s390_diagnose_norecursion(diag_map[nr].code);
+ }
+ EXPORT_SYMBOL(diag_stat_inc_norecursion);
++>>>>>>> 4ad78b8651aa (s390/setup: set control program code via diag 318)
  
  /*
   * Diagnose 14: Input spool file manipulation
diff --cc arch/s390/kernel/setup.c
index 0016bfa2fe72,5295e536515b..000000000000
--- a/arch/s390/kernel/setup.c
+++ b/arch/s390/kernel/setup.c
@@@ -45,6 -48,8 +45,11 @@@
  #include <linux/crash_dump.h>
  #include <linux/memory.h>
  #include <linux/compat.h>
++<<<<<<< HEAD
++=======
+ #include <linux/start_kernel.h>
+ #include <linux/version.h>
++>>>>>>> 4ad78b8651aa (s390/setup: set control program code via diag 318)
  
  #include <asm/ipl.h>
  #include <asm/facility.h>
@@@ -1007,10 -953,62 +1012,29 @@@ static void __init setup_hwcaps(void
  	/*
  	 * Virtualization support HWCAP_INT_SIE is bit 0.
  	 */
 -	if (sclp.has_sief2)
 +	if (sclp_has_sief2())
  		int_hwcap |= HWCAP_INT_SIE;
 -
 -	return 0;
 -}
 -arch_initcall(setup_hwcaps);
 -
 -/*
 - * Add system information as device randomness
 - */
 -static void __init setup_randomness(void)
 -{
 -	struct sysinfo_3_2_2 *vmms;
 -
 -	vmms = (struct sysinfo_3_2_2 *) memblock_phys_alloc(PAGE_SIZE,
 -							    PAGE_SIZE);
 -	if (stsi(vmms, 3, 2, 2) == 0 && vmms->count)
 -		add_device_randomness(&vmms->vm, sizeof(vmms->vm[0]) * vmms->count);
 -	memblock_free((unsigned long) vmms, PAGE_SIZE);
 -}
 -
 -/*
 - * Find the correct size for the task_struct. This depends on
 - * the size of the struct fpu at the end of the thread_struct
 - * which is embedded in the task_struct.
 - */
 -static void __init setup_task_size(void)
 -{
 -	int task_size = sizeof(struct task_struct);
 -
 -	if (!MACHINE_HAS_VX) {
 -		task_size -= sizeof(__vector128) * __NUM_VXRS;
 -		task_size += sizeof(freg_t) * __NUM_FPRS;
 -	}
 -	arch_task_struct_size = task_size;
  }
  
+ /*
+  * Issue diagnose 318 to set the control program name and
+  * version codes.
+  */
+ static void __init setup_control_program_code(void)
+ {
+ 	union diag318_info diag318_info = {
+ 		.cpnc = CPNC_LINUX,
+ 		.cpvc_linux = 0,
+ 		.cpvc_distro = {0},
+ 	};
+ 
+ 	if (!sclp.has_diag318)
+ 		return;
+ 
+ 	diag_stat_inc(DIAG_STAT_X318);
+ 	asm volatile("diag %0,0,0x318\n" : : "d" (diag318_info.val));
+ }
+ 
  /*
   * Setup function called from init/main.c just after the banner
   * was printed.
@@@ -1058,25 -1043,61 +1082,33 @@@ void __init setup_arch(char **cmdline_p
  		nospec_auto_detect();
  
  	parse_early_param();
 -#ifdef CONFIG_CRASH_DUMP
 -	/* Deactivate elfcorehdr= kernel parameter */
 -	elfcorehdr_addr = ELFCORE_ADDR_MAX;
 -#endif
 -
 +	detect_memory_layout(memory_chunk, memory_end);
  	os_info_init();
  	setup_ipl();
++<<<<<<< HEAD
++=======
+ 	setup_task_size();
+ 	setup_control_program_code();
+ 
+ 	/* Do some memory reservations *before* memory is added to memblock */
+ 	reserve_memory_end();
++>>>>>>> 4ad78b8651aa (s390/setup: set control program code via diag 318)
  	reserve_oldmem();
 -	reserve_kernel();
 -	reserve_initrd();
 -	reserve_mem_detect_info();
 -	memblock_allow_resize();
 -
 -	/* Get information about *all* installed memory */
 -	memblock_add_mem_detect_info();
 -
 -	free_mem_detect_info();
 -	remove_oldmem();
 -
 -	/*
 -	 * Make sure all chunks are MAX_ORDER aligned so we don't need the
 -	 * extra checks that HOLES_IN_ZONE would require.
 -	 *
 -	 * Is this still required?
 -	 */
 -	memblock_trim_memory(1UL << (MAX_ORDER - 1 + PAGE_SHIFT));
 -
  	setup_memory_end();
 -	setup_memory();
 -	dma_contiguous_reserve(memory_end);
 -	vmcp_cma_reserve();
 -
 -	check_initrd();
  	reserve_crashkernel();
 -#ifdef CONFIG_CRASH_DUMP
 -	/*
 -	 * Be aware that smp_save_dump_cpus() triggers a system reset.
 -	 * Therefore CPU and device initialization should be done afterwards.
 -	 */
 -	smp_save_dump_cpus();
 -#endif
 -
 +	setup_memory();
  	setup_resources();
 +	setup_vmcoreinfo();
  	setup_lowcore();
 +
  	smp_fill_possible_mask();
 -	cpu_detect_mhz_feature();
          cpu_init();
 -	numa_setup();
 -	smp_detect_cpus();
 -	topology_init_early();
 +	s390_init_cpu_topology();
 +
 +	/*
 +	 * Setup capabilities (ELF_HWCAP & ELF_PLATFORM).
 +	 */
 +	setup_hwcaps();
  
  	/*
  	 * Create kernel page tables and switch to virtual addressing.
diff --cc drivers/s390/char/sclp.h
index 4d46349762d1,367e9d384d85..000000000000
--- a/drivers/s390/char/sclp.h
+++ b/drivers/s390/char/sclp.h
@@@ -94,19 -103,130 +94,135 @@@ struct init_sccb 
  	struct sccb_header header;
  	u16 _reserved;
  	u16 mask_length;
 -	u8 masks[4 * 1021];	/* variable length */
 -	/*
 -	 * u8 receive_mask[mask_length];
 -	 * u8 send_mask[mask_length];
 -	 * u8 sclp_receive_mask[mask_length];
 -	 * u8 sclp_send_mask[mask_length];
 -	 */
 +	sccb_mask_t receive_mask;
 +	sccb_mask_t send_mask;
 +	sccb_mask_t sclp_receive_mask;
 +	sccb_mask_t sclp_send_mask;
  } __attribute__((packed));
  
 -#define SCLP_MASK_SIZE_COMPAT 4
 +extern u64 sclp_facilities;
  
++<<<<<<< HEAD
 +#define SCLP_HAS_CHP_INFO	(sclp_facilities & 0x8000000000000000ULL)
 +#define SCLP_HAS_CHP_RECONFIG	(sclp_facilities & 0x2000000000000000ULL)
 +#define SCLP_HAS_CPU_INFO	(sclp_facilities & 0x0800000000000000ULL)
 +#define SCLP_HAS_CPU_RECONFIG	(sclp_facilities & 0x0400000000000000ULL)
 +#define SCLP_HAS_PCI_RECONFIG	(sclp_facilities & 0x0000000040000000ULL)
++=======
+ static inline sccb_mask_t sccb_get_mask(u8 *masks, size_t len, int i)
+ {
+ 	sccb_mask_t res = 0;
+ 
+ 	memcpy(&res, masks + i * len, min(sizeof(res), len));
+ 	return res;
+ }
+ 
+ static inline void sccb_set_mask(u8 *masks, size_t len, int i, sccb_mask_t val)
+ {
+ 	memset(masks + i * len, 0, len);
+ 	memcpy(masks + i * len, &val, min(sizeof(val), len));
+ }
+ 
+ #define sccb_get_generic_mask(sccb, i)					\
+ ({									\
+ 	__typeof__(sccb) __sccb = sccb;					\
+ 									\
+ 	sccb_get_mask(__sccb->masks, __sccb->mask_length, i);		\
+ })
+ #define sccb_get_recv_mask(sccb)	sccb_get_generic_mask(sccb, 0)
+ #define sccb_get_send_mask(sccb)	sccb_get_generic_mask(sccb, 1)
+ #define sccb_get_sclp_recv_mask(sccb)	sccb_get_generic_mask(sccb, 2)
+ #define sccb_get_sclp_send_mask(sccb)	sccb_get_generic_mask(sccb, 3)
+ 
+ #define sccb_set_generic_mask(sccb, i, val)				\
+ ({									\
+ 	__typeof__(sccb) __sccb = sccb;					\
+ 									\
+ 	sccb_set_mask(__sccb->masks, __sccb->mask_length, i, val);	\
+ })
+ #define sccb_set_recv_mask(sccb, val)	    sccb_set_generic_mask(sccb, 0, val)
+ #define sccb_set_send_mask(sccb, val)	    sccb_set_generic_mask(sccb, 1, val)
+ #define sccb_set_sclp_recv_mask(sccb, val)  sccb_set_generic_mask(sccb, 2, val)
+ #define sccb_set_sclp_send_mask(sccb, val)  sccb_set_generic_mask(sccb, 3, val)
+ 
+ struct read_cpu_info_sccb {
+ 	struct	sccb_header header;
+ 	u16	nr_configured;
+ 	u16	offset_configured;
+ 	u16	nr_standby;
+ 	u16	offset_standby;
+ 	u8	reserved[4096 - 16];
+ } __attribute__((packed, aligned(PAGE_SIZE)));
+ 
+ struct read_info_sccb {
+ 	struct	sccb_header header;	/* 0-7 */
+ 	u16	rnmax;			/* 8-9 */
+ 	u8	rnsize;			/* 10 */
+ 	u8	_pad_11[16 - 11];	/* 11-15 */
+ 	u16	ncpurl;			/* 16-17 */
+ 	u16	cpuoff;			/* 18-19 */
+ 	u8	_pad_20[24 - 20];	/* 20-23 */
+ 	u8	loadparm[8];		/* 24-31 */
+ 	u8	_pad_32[42 - 32];	/* 32-41 */
+ 	u8	fac42;			/* 42 */
+ 	u8	fac43;			/* 43 */
+ 	u8	_pad_44[48 - 44];	/* 44-47 */
+ 	u64	facilities;		/* 48-55 */
+ 	u8	_pad_56[66 - 56];	/* 56-65 */
+ 	u8	fac66;			/* 66 */
+ 	u8	_pad_67[76 - 67];	/* 67-83 */
+ 	u32	ibc;			/* 76-79 */
+ 	u8	_pad80[84 - 80];	/* 80-83 */
+ 	u8	fac84;			/* 84 */
+ 	u8	fac85;			/* 85 */
+ 	u8	_pad_86[91 - 86];	/* 86-90 */
+ 	u8	fac91;			/* 91 */
+ 	u8	_pad_92[98 - 92];	/* 92-97 */
+ 	u8	fac98;			/* 98 */
+ 	u8	hamaxpow;		/* 99 */
+ 	u32	rnsize2;		/* 100-103 */
+ 	u64	rnmax2;			/* 104-111 */
+ 	u32	hsa_size;		/* 112-115 */
+ 	u8	fac116;			/* 116 */
+ 	u8	fac117;			/* 117 */
+ 	u8	fac118;			/* 118 */
+ 	u8	fac119;			/* 119 */
+ 	u16	hcpua;			/* 120-121 */
+ 	u8	_pad_122[124 - 122];	/* 122-123 */
+ 	u32	hmfai;			/* 124-127 */
+ 	u8	_pad_128[134 - 128];	/* 128-133 */
+ 	u8	byte_134;			/* 134 */
+ 	u8	_pad_135[4096 - 135];	/* 135-4095 */
+ } __packed __aligned(PAGE_SIZE);
+ 
+ struct read_storage_sccb {
+ 	struct sccb_header header;
+ 	u16 max_id;
+ 	u16 assigned;
+ 	u16 standby;
+ 	u16 :16;
+ 	u32 entries[0];
+ } __packed;
+ 
+ static inline void sclp_fill_core_info(struct sclp_core_info *info,
+ 				       struct read_cpu_info_sccb *sccb)
+ {
+ 	char *page = (char *) sccb;
+ 
+ 	memset(info, 0, sizeof(*info));
+ 	info->configured = sccb->nr_configured;
+ 	info->standby = sccb->nr_standby;
+ 	info->combined = sccb->nr_configured + sccb->nr_standby;
+ 	memcpy(&info->core, page + sccb->offset_configured,
+ 	       info->combined * sizeof(struct sclp_core_entry));
+ }
+ 
+ #define SCLP_HAS_CHP_INFO	(sclp.facilities & 0x8000000000000000ULL)
+ #define SCLP_HAS_CHP_RECONFIG	(sclp.facilities & 0x2000000000000000ULL)
+ #define SCLP_HAS_CPU_INFO	(sclp.facilities & 0x0800000000000000ULL)
+ #define SCLP_HAS_CPU_RECONFIG	(sclp.facilities & 0x0400000000000000ULL)
+ #define SCLP_HAS_PCI_RECONFIG	(sclp.facilities & 0x0000000040000000ULL)
++>>>>>>> 4ad78b8651aa (s390/setup: set control program code via diag 318)
  
  
  struct gds_subvector {
diff --cc drivers/s390/char/sclp_early.c
index 43c1a325231d,8332788681c4..000000000000
--- a/drivers/s390/char/sclp_early.c
+++ b/drivers/s390/char/sclp_early.c
@@@ -13,114 -15,46 +13,130 @@@
  #include "sclp_sdias.h"
  #include "sclp.h"
  
 +#define SCLP_CMDW_READ_SCP_INFO		0x00020001
 +#define SCLP_CMDW_READ_SCP_INFO_FORCED	0x00120001
 +
 +struct read_info_sccb {
 +	struct	sccb_header header;	/* 0-7 */
 +	u16	rnmax;			/* 8-9 */
 +	u8	rnsize;			/* 10 */
 +	u8	_pad_11[16 - 11];	/* 11-15 */
 +	u16	ncpurl;			/* 16-17 */
 +	u16	cpuoff;			/* 18-19 */
 +	u8	_reserved7[24 - 20];	/* 20-23 */
 +	u8	loadparm[8];		/* 24-31 */
 +	u8	_pad_32[42 - 32];	/* 32-41 */
 +	u8	fac42;			/* 42 */
 +	u8	fac43;			/* 43 */
 +	u8	_pad_44[48 - 44];	/* 44-47 */
 +	u64	facilities;		/* 48-55 */
 +	u8	_pad_56[66 - 56];	/* 56-65 */
 +	u8	fac66;			/* 66 */
 +	u8	_pad_67[84 - 67];	/* 67-83 */
 +	u8	fac84;			/* 84 */
 +	u8	fac85;			/* 85 */
 +	u8	_pad_86[91 - 86];	/* 86-90 */
 +	u8	flags;			/* 91 */
 +	u8	_pad_92[100 - 92];	/* 92-99 */
 +	u32	rnsize2;		/* 100-103 */
 +	u64	rnmax2;			/* 104-111 */
 +	u8	_pad_112[120 - 112];	/* 112-119 */
 +	u16	hcpua;			/* 120-121 */
 +	u8	_pad_122[4096 - 122];	/* 122-4095 */
 +} __packed __aligned(PAGE_SIZE);
 +
 +static char sccb_early[PAGE_SIZE] __aligned(PAGE_SIZE) __initdata;
 +static unsigned int sclp_con_has_vt220 __initdata;
 +static unsigned int sclp_con_has_linemode __initdata;
 +static unsigned long sclp_hsa_size;
 +static unsigned int sclp_max_cpu;
  static struct sclp_ipl_info sclp_ipl_info;
 +static unsigned char sclp_siif;
 +static unsigned int sclp_mtid;
 +static unsigned int sclp_mtid_cp;
 +static unsigned int sclp_mtid_max;
 +static unsigned int sclp_mtid_prev;
 +static unsigned char sclp_sief2;
 +
 +u64 sclp_facilities;
 +u8 sclp_fac84;
 +unsigned long long sclp_rzm;
 +unsigned long long sclp_rnmax;
 +
 +static int __init sclp_cmd_sync_early(sclp_cmdw_t cmd, void *sccb)
 +{
 +	int rc;
  
 -struct sclp_info sclp;
 -EXPORT_SYMBOL(sclp);
 +	__ctl_set_bit(0, 9);
 +	rc = sclp_service_call(cmd, sccb);
 +	if (rc)
 +		goto out;
 +	__load_psw_mask(PSW_DEFAULT_KEY | PSW_MASK_BASE | PSW_MASK_EA |
 +			PSW_MASK_BA | PSW_MASK_EXT | PSW_MASK_WAIT);
 +	local_irq_disable();
 +out:
 +	/* Contents of the sccb might have changed. */
 +	barrier();
 +	__ctl_clear_bit(0, 9);
 +	return rc;
 +}
  
 -static void __init sclp_early_facilities_detect(struct read_info_sccb *sccb)
 +static int __init sclp_read_info_early(struct read_info_sccb *sccb)
  {
 -	struct sclp_core_entry *cpue;
 +	int rc, i;
 +	sclp_cmdw_t commands[] = {SCLP_CMDW_READ_SCP_INFO_FORCED,
 +				  SCLP_CMDW_READ_SCP_INFO};
 +
 +	for (i = 0; i < ARRAY_SIZE(commands); i++) {
 +		do {
 +			memset(sccb, 0, sizeof(*sccb));
 +			sccb->header.length = sizeof(*sccb);
 +			sccb->header.function_code = 0x80;
 +			sccb->header.control_mask[2] = 0x80;
 +			rc = sclp_cmd_sync_early(commands[i], sccb);
 +		} while (rc == -EBUSY);
 +
 +		if (rc)
 +			break;
 +		if (sccb->header.response_code == 0x10)
 +			return 0;
 +		if (sccb->header.response_code != 0x1f0)
 +			break;
 +	}
 +	return -EIO;
 +}
 +
 +static void __init sclp_facilities_detect(struct read_info_sccb *sccb)
 +{
 +	struct sclp_cpu_entry *cpue;
  	u16 boot_cpu_address, cpu;
  
 -	if (sclp_early_get_info(sccb))
 +	if (sclp_read_info_early(sccb))
  		return;
  
 -	sclp.facilities = sccb->facilities;
 -	sclp.has_sprp = !!(sccb->fac84 & 0x02);
 -	sclp.has_core_type = !!(sccb->fac84 & 0x01);
 -	sclp.has_gsls = !!(sccb->fac85 & 0x80);
 -	sclp.has_64bscao = !!(sccb->fac116 & 0x80);
 -	sclp.has_cmma = !!(sccb->fac116 & 0x40);
 -	sclp.has_esca = !!(sccb->fac116 & 0x08);
 -	sclp.has_pfmfi = !!(sccb->fac117 & 0x40);
 -	sclp.has_ibs = !!(sccb->fac117 & 0x20);
 -	sclp.has_gisaf = !!(sccb->fac118 & 0x08);
 -	sclp.has_hvs = !!(sccb->fac119 & 0x80);
 -	sclp.has_kss = !!(sccb->fac98 & 0x01);
 +	sclp_facilities = sccb->facilities;
 +	sclp_fac84 = sccb->fac84;
  	if (sccb->fac85 & 0x02)
  		S390_lowcore.machine_flags |= MACHINE_FLAG_ESOP;
++<<<<<<< HEAD
 +	sclp_rnmax = sccb->rnmax ? sccb->rnmax : sccb->rnmax2;
 +	sclp_rzm = sccb->rnsize ? sccb->rnsize : sccb->rnsize2;
 +	sclp_rzm <<= 20;
++=======
+ 	if (sccb->fac91 & 0x40)
+ 		S390_lowcore.machine_flags |= MACHINE_FLAG_TLB_GUEST;
+ 	if (sccb->cpuoff > 134)
+ 		sclp.has_diag318 = !!(sccb->byte_134 & 0x80);
+ 	sclp.rnmax = sccb->rnmax ? sccb->rnmax : sccb->rnmax2;
+ 	sclp.rzm = sccb->rnsize ? sccb->rnsize : sccb->rnsize2;
+ 	sclp.rzm <<= 20;
+ 	sclp.ibc = sccb->ibc;
+ 
+ 	if (sccb->hamaxpow && sccb->hamaxpow < 64)
+ 		sclp.hamax = (1UL << sccb->hamaxpow) - 1;
+ 	else
+ 		sclp.hamax = U64_MAX;
++>>>>>>> 4ad78b8651aa (s390/setup: set control program code via diag 318)
  
  	if (!sccb->hcpua) {
  		if (MACHINE_IS_VM)
* Unmerged path arch/s390/include/asm/diag.h
* Unmerged path arch/s390/include/asm/sclp.h
* Unmerged path arch/s390/kernel/diag.c
* Unmerged path arch/s390/kernel/setup.c
* Unmerged path drivers/s390/char/sclp.h
* Unmerged path drivers/s390/char/sclp_early.c
