usb: core: Add USB_QUIRK_DELAY_CTRL_MSG to usbcore quirks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Kai-Heng Feng <kai.heng.feng@canonical.com>
commit 4d8d5a392ae110d9b5889afd2b4beef9a09e712d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4d8d5a39.failed

There's a new quirk, USB_QUIRK_DELAY_CTRL_MSG. Add it to usbcore quirks
for completeness.

	Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 4d8d5a392ae110d9b5889afd2b4beef9a09e712d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/kernel-parameters.txt
#	drivers/usb/core/quirks.c
diff --cc Documentation/kernel-parameters.txt
index f6852ae416ce,372d48326b1d..000000000000
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@@ -3691,6 -4366,66 +3691,69 @@@ bytes respectively. Such letter suffixe
                          USB_REQ_GET_DESCRIPTOR request in milliseconds
  			(default 5000 = 5.0 seconds).
  
++<<<<<<< HEAD:Documentation/kernel-parameters.txt
++=======
+ 	usbcore.nousb	[USB] Disable the USB subsystem
+ 
+ 	usbcore.quirks=
+ 			[USB] A list of quirk entries to augment the built-in
+ 			usb core quirk list. List entries are separated by
+ 			commas. Each entry has the form
+ 			VendorID:ProductID:Flags. The IDs are 4-digit hex
+ 			numbers and Flags is a set of letters. Each letter
+ 			will change the built-in quirk; setting it if it is
+ 			clear and clearing it if it is set. The letters have
+ 			the following meanings:
+ 				a = USB_QUIRK_STRING_FETCH_255 (string
+ 					descriptors must not be fetched using
+ 					a 255-byte read);
+ 				b = USB_QUIRK_RESET_RESUME (device can't resume
+ 					correctly so reset it instead);
+ 				c = USB_QUIRK_NO_SET_INTF (device can't handle
+ 					Set-Interface requests);
+ 				d = USB_QUIRK_CONFIG_INTF_STRINGS (device can't
+ 					handle its Configuration or Interface
+ 					strings);
+ 				e = USB_QUIRK_RESET (device can't be reset
+ 					(e.g morph devices), don't use reset);
+ 				f = USB_QUIRK_HONOR_BNUMINTERFACES (device has
+ 					more interface descriptions than the
+ 					bNumInterfaces count, and can't handle
+ 					talking to these interfaces);
+ 				g = USB_QUIRK_DELAY_INIT (device needs a pause
+ 					during initialization, after we read
+ 					the device descriptor);
+ 				h = USB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL (For
+ 					high speed and super speed interrupt
+ 					endpoints, the USB 2.0 and USB 3.0 spec
+ 					require the interval in microframes (1
+ 					microframe = 125 microseconds) to be
+ 					calculated as interval = 2 ^
+ 					(bInterval-1).
+ 					Devices with this quirk report their
+ 					bInterval as the result of this
+ 					calculation instead of the exponent
+ 					variable used in the calculation);
+ 				i = USB_QUIRK_DEVICE_QUALIFIER (device can't
+ 					handle device_qualifier descriptor
+ 					requests);
+ 				j = USB_QUIRK_IGNORE_REMOTE_WAKEUP (device
+ 					generates spurious wakeup, ignore
+ 					remote wakeup capability);
+ 				k = USB_QUIRK_NO_LPM (device can't handle Link
+ 					Power Management);
+ 				l = USB_QUIRK_LINEAR_FRAME_INTR_BINTERVAL
+ 					(Device reports its bInterval as linear
+ 					frames instead of the USB 2.0
+ 					calculation);
+ 				m = USB_QUIRK_DISCONNECT_SUSPEND (Device needs
+ 					to be disconnected before suspend to
+ 					prevent spurious wakeup);
+ 				n = USB_QUIRK_DELAY_CTRL_MSG (Device needs a
+ 					pause after every control message);
+ 			Example: quirks=0781:5580:bk,0a5c:5834:gij
+ 
++>>>>>>> 4d8d5a392ae1 (usb: core: Add USB_QUIRK_DELAY_CTRL_MSG to usbcore quirks):Documentation/admin-guide/kernel-parameters.txt
  	usbhid.mousepoll=
  			[USBHID] The interval which mice are to be polled at.
  
diff --cc drivers/usb/core/quirks.c
index 54b019e267c5,920f48a49a87..000000000000
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@@ -11,6 -12,151 +11,154 @@@
  #include <linux/usb/hcd.h>
  #include "usb.h"
  
++<<<<<<< HEAD
++=======
+ struct quirk_entry {
+ 	u16 vid;
+ 	u16 pid;
+ 	u32 flags;
+ };
+ 
+ static DEFINE_MUTEX(quirk_mutex);
+ 
+ static struct quirk_entry *quirk_list;
+ static unsigned int quirk_count;
+ 
+ static char quirks_param[128];
+ 
+ static int quirks_param_set(const char *val, const struct kernel_param *kp)
+ {
+ 	char *p, *field;
+ 	u16 vid, pid;
+ 	u32 flags;
+ 	size_t i;
+ 	int err;
+ 
+ 	err = param_set_copystring(val, kp);
+ 	if (err)
+ 		return err;
+ 
+ 	mutex_lock(&quirk_mutex);
+ 
+ 	if (!*val) {
+ 		quirk_count = 0;
+ 		kfree(quirk_list);
+ 		quirk_list = NULL;
+ 		goto unlock;
+ 	}
+ 
+ 	for (quirk_count = 1, i = 0; val[i]; i++)
+ 		if (val[i] == ',')
+ 			quirk_count++;
+ 
+ 	if (quirk_list) {
+ 		kfree(quirk_list);
+ 		quirk_list = NULL;
+ 	}
+ 
+ 	quirk_list = kcalloc(quirk_count, sizeof(struct quirk_entry),
+ 			     GFP_KERNEL);
+ 	if (!quirk_list) {
+ 		mutex_unlock(&quirk_mutex);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	for (i = 0, p = (char *)val; p && *p;) {
+ 		/* Each entry consists of VID:PID:flags */
+ 		field = strsep(&p, ":");
+ 		if (!field)
+ 			break;
+ 
+ 		if (kstrtou16(field, 16, &vid))
+ 			break;
+ 
+ 		field = strsep(&p, ":");
+ 		if (!field)
+ 			break;
+ 
+ 		if (kstrtou16(field, 16, &pid))
+ 			break;
+ 
+ 		field = strsep(&p, ",");
+ 		if (!field || !*field)
+ 			break;
+ 
+ 		/* Collect the flags */
+ 		for (flags = 0; *field; field++) {
+ 			switch (*field) {
+ 			case 'a':
+ 				flags |= USB_QUIRK_STRING_FETCH_255;
+ 				break;
+ 			case 'b':
+ 				flags |= USB_QUIRK_RESET_RESUME;
+ 				break;
+ 			case 'c':
+ 				flags |= USB_QUIRK_NO_SET_INTF;
+ 				break;
+ 			case 'd':
+ 				flags |= USB_QUIRK_CONFIG_INTF_STRINGS;
+ 				break;
+ 			case 'e':
+ 				flags |= USB_QUIRK_RESET;
+ 				break;
+ 			case 'f':
+ 				flags |= USB_QUIRK_HONOR_BNUMINTERFACES;
+ 				break;
+ 			case 'g':
+ 				flags |= USB_QUIRK_DELAY_INIT;
+ 				break;
+ 			case 'h':
+ 				flags |= USB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL;
+ 				break;
+ 			case 'i':
+ 				flags |= USB_QUIRK_DEVICE_QUALIFIER;
+ 				break;
+ 			case 'j':
+ 				flags |= USB_QUIRK_IGNORE_REMOTE_WAKEUP;
+ 				break;
+ 			case 'k':
+ 				flags |= USB_QUIRK_NO_LPM;
+ 				break;
+ 			case 'l':
+ 				flags |= USB_QUIRK_LINEAR_FRAME_INTR_BINTERVAL;
+ 				break;
+ 			case 'm':
+ 				flags |= USB_QUIRK_DISCONNECT_SUSPEND;
+ 				break;
+ 			case 'n':
+ 				flags |= USB_QUIRK_DELAY_CTRL_MSG;
+ 				break;
+ 			/* Ignore unrecognized flag characters */
+ 			}
+ 		}
+ 
+ 		quirk_list[i++] = (struct quirk_entry)
+ 			{ .vid = vid, .pid = pid, .flags = flags };
+ 	}
+ 
+ 	if (i < quirk_count)
+ 		quirk_count = i;
+ 
+ unlock:
+ 	mutex_unlock(&quirk_mutex);
+ 
+ 	return 0;
+ }
+ 
+ static const struct kernel_param_ops quirks_param_ops = {
+ 	.set = quirks_param_set,
+ 	.get = param_get_string,
+ };
+ 
+ static struct kparam_string quirks_param_string = {
+ 	.maxlen = sizeof(quirks_param),
+ 	.string = quirks_param,
+ };
+ 
+ module_param_cb(quirks, &quirks_param_ops, &quirks_param_string, 0644);
+ MODULE_PARM_DESC(quirks, "Add/modify USB quirks by specifying quirks=vendorID:productID:quirks");
+ 
++>>>>>>> 4d8d5a392ae1 (usb: core: Add USB_QUIRK_DELAY_CTRL_MSG to usbcore quirks)
  /* Lists of quirky USB devices, split in device quirks and interface quirks.
   * Device quirks are applied at the very beginning of the enumeration process,
   * right after reading the device descriptor. They can thus only match on device
* Unmerged path Documentation/kernel-parameters.txt
* Unmerged path drivers/usb/core/quirks.c
