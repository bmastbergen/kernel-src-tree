sctp: delay the authentication for the duplicated cookie-echo chunk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit 59d8d4434f429b4fa8a346fd889058bda427a837
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/59d8d443.failed

Now sctp only delays the authentication for the normal cookie-echo
chunk by setting chunk->auth_chunk in sctp_endpoint_bh_rcv(). But
for the duplicated one with auth, in sctp_assoc_bh_rcv(), it does
authentication first based on the old asoc, which will definitely
fail due to the different auth info in the old asoc.

The duplicated cookie-echo chunk will create a new asoc with the
auth info from this chunk, and the authentication should also be
done with the new asoc's auth info for all of the collision 'A',
'B' and 'D'. Otherwise, the duplicated cookie-echo chunk with auth
will never pass the authentication and create the new connection.

This issue exists since very beginning, and this fix is to make
sctp_assoc_bh_rcv() follow the way sctp_endpoint_bh_rcv() does
for the normal cookie-echo chunk to delay the authentication.

While at it, remove the unused params from sctp_sf_authenticate()
and define sctp_auth_chunk_verify() used for all the places that
do the delayed authentication.

v1->v2:
  fix the typo in changelog as Marcelo noticed.

	Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Acked-by: Neil Horman <nhorman@tuxdriver.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 59d8d4434f429b4fa8a346fd889058bda427a837)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/associola.c
#	net/sctp/sm_statefuns.c
diff --cc net/sctp/associola.c
index dbb4cd1cc493,a47179da24e6..000000000000
--- a/net/sctp/associola.c
+++ b/net/sctp/associola.c
@@@ -1021,9 -1023,10 +1021,14 @@@ static void sctp_assoc_bh_rcv(struct wo
  	struct sctp_endpoint *ep;
  	struct sctp_chunk *chunk;
  	struct sctp_inq *inqueue;
++<<<<<<< HEAD
 +	int state;
 +	sctp_subtype_t subtype;
++=======
+ 	int first_time = 1;	/* is this the first time through the loop */
++>>>>>>> 59d8d4434f42 (sctp: delay the authentication for the duplicated cookie-echo chunk)
  	int error = 0;
+ 	int state;
  
  	/* The association should be held so we should be safe. */
  	ep = asoc->ep;
diff --cc net/sctp/sm_statefuns.c
index efdda6194fbd,c9ae3404b1bb..000000000000
--- a/net/sctp/sm_statefuns.c
+++ b/net/sctp/sm_statefuns.c
@@@ -82,87 -79,90 +82,137 @@@ static void sctp_send_stale_cookie_err(
  				       const struct sctp_endpoint *ep,
  				       const struct sctp_association *asoc,
  				       const struct sctp_chunk *chunk,
 -				       struct sctp_cmd_seq *commands,
 +				       sctp_cmd_seq_t *commands,
  				       struct sctp_chunk *err_chunk);
 -static enum sctp_disposition sctp_sf_do_5_2_6_stale(
 -					struct net *net,
 -					const struct sctp_endpoint *ep,
 -					const struct sctp_association *asoc,
 -					const union sctp_subtype type,
 -					void *arg,
 -					struct sctp_cmd_seq *commands);
 -static enum sctp_disposition sctp_sf_shut_8_4_5(
 -					struct net *net,
 -					const struct sctp_endpoint *ep,
 -					const struct sctp_association *asoc,
 -					const union sctp_subtype type,
 -					void *arg,
 -					struct sctp_cmd_seq *commands);
 -static enum sctp_disposition sctp_sf_tabort_8_4_8(
 -					struct net *net,
 +static sctp_disposition_t sctp_sf_do_5_2_6_stale(struct net *net,
 +						 const struct sctp_endpoint *ep,
 +						 const struct sctp_association *asoc,
 +						 const sctp_subtype_t type,
 +						 void *arg,
 +						 sctp_cmd_seq_t *commands);
 +static sctp_disposition_t sctp_sf_shut_8_4_5(struct net *net,
 +					     const struct sctp_endpoint *ep,
 +					     const struct sctp_association *asoc,
 +					     const sctp_subtype_t type,
 +					     void *arg,
 +					     sctp_cmd_seq_t *commands);
 +static sctp_disposition_t sctp_sf_tabort_8_4_8(struct net *net,
  					const struct sctp_endpoint *ep,
  					const struct sctp_association *asoc,
 -					const union sctp_subtype type,
 +					const sctp_subtype_t type,
  					void *arg,
 -					struct sctp_cmd_seq *commands);
 +					sctp_cmd_seq_t *commands);
  static struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk);
  
 -static enum sctp_disposition sctp_stop_t1_and_abort(
 -					struct net *net,
 -					struct sctp_cmd_seq *commands,
 -					__be16 error, int sk_err,
 -					const struct sctp_association *asoc,
 -					struct sctp_transport *transport);
 +static sctp_disposition_t sctp_stop_t1_and_abort(struct net *net,
 +					   sctp_cmd_seq_t *commands,
 +					   __be16 error, int sk_err,
 +					   const struct sctp_association *asoc,
 +					   struct sctp_transport *transport);
  
 -static enum sctp_disposition sctp_sf_abort_violation(
 -					struct net *net,
 +static sctp_disposition_t sctp_sf_abort_violation(
 +				     struct net *net,
 +				     const struct sctp_endpoint *ep,
 +				     const struct sctp_association *asoc,
 +				     void *arg,
 +				     sctp_cmd_seq_t *commands,
 +				     const __u8 *payload,
 +				     const size_t paylen);
 +
 +static sctp_disposition_t sctp_sf_violation_chunklen(
 +				     struct net *net,
 +				     const struct sctp_endpoint *ep,
 +				     const struct sctp_association *asoc,
 +				     const sctp_subtype_t type,
 +				     void *arg,
 +				     sctp_cmd_seq_t *commands);
 +
 +static sctp_disposition_t sctp_sf_violation_paramlen(
 +				     struct net *net,
 +				     const struct sctp_endpoint *ep,
 +				     const struct sctp_association *asoc,
 +				     const sctp_subtype_t type,
 +				     void *arg, void *ext,
 +				     sctp_cmd_seq_t *commands);
 +
 +static sctp_disposition_t sctp_sf_violation_ctsn(
 +				     struct net *net,
 +				     const struct sctp_endpoint *ep,
 +				     const struct sctp_association *asoc,
 +				     const sctp_subtype_t type,
 +				     void *arg,
 +				     sctp_cmd_seq_t *commands);
 +
 +static sctp_disposition_t sctp_sf_violation_chunk(
 +				     struct net *net,
 +				     const struct sctp_endpoint *ep,
 +				     const struct sctp_association *asoc,
 +				     const sctp_subtype_t type,
 +				     void *arg,
 +				     sctp_cmd_seq_t *commands);
 +
 +static sctp_ierror_t sctp_sf_authenticate(struct net *net,
 +				    const struct sctp_endpoint *ep,
 +				    const struct sctp_association *asoc,
 +				    const sctp_subtype_t type,
 +				    struct sctp_chunk *chunk);
 +
 +static sctp_disposition_t __sctp_sf_do_9_1_abort(struct net *net,
  					const struct sctp_endpoint *ep,
  					const struct sctp_association *asoc,
 +					const sctp_subtype_t type,
  					void *arg,
++<<<<<<< HEAD
 +					sctp_cmd_seq_t *commands);
++=======
+ 					struct sctp_cmd_seq *commands,
+ 					const __u8 *payload,
+ 					const size_t paylen);
+ 
+ static enum sctp_disposition sctp_sf_violation_chunklen(
+ 					struct net *net,
+ 					const struct sctp_endpoint *ep,
+ 					const struct sctp_association *asoc,
+ 					const union sctp_subtype type,
+ 					void *arg,
+ 					struct sctp_cmd_seq *commands);
+ 
+ static enum sctp_disposition sctp_sf_violation_paramlen(
+ 					struct net *net,
+ 					const struct sctp_endpoint *ep,
+ 					const struct sctp_association *asoc,
+ 					const union sctp_subtype type,
+ 					void *arg, void *ext,
+ 					struct sctp_cmd_seq *commands);
+ 
+ static enum sctp_disposition sctp_sf_violation_ctsn(
+ 					struct net *net,
+ 					const struct sctp_endpoint *ep,
+ 					const struct sctp_association *asoc,
+ 					const union sctp_subtype type,
+ 					void *arg,
+ 					struct sctp_cmd_seq *commands);
+ 
+ static enum sctp_disposition sctp_sf_violation_chunk(
+ 					struct net *net,
+ 					const struct sctp_endpoint *ep,
+ 					const struct sctp_association *asoc,
+ 					const union sctp_subtype type,
+ 					void *arg,
+ 					struct sctp_cmd_seq *commands);
+ 
+ static enum sctp_ierror sctp_sf_authenticate(
+ 					const struct sctp_association *asoc,
+ 					struct sctp_chunk *chunk);
+ 
+ static enum sctp_disposition __sctp_sf_do_9_1_abort(
+ 					struct net *net,
+ 					const struct sctp_endpoint *ep,
+ 					const struct sctp_association *asoc,
+ 					const union sctp_subtype type,
+ 					void *arg,
+ 					struct sctp_cmd_seq *commands);
++>>>>>>> 59d8d4434f42 (sctp: delay the authentication for the duplicated cookie-echo chunk)
  
  /* Small helper function that checks if the chunk length
   * is of the appropriate length.  The 'required_length' argument
@@@ -758,36 -792,9 +840,42 @@@ sctp_disposition_t sctp_sf_do_5_1D_ce(s
  	if (error)
  		goto nomem_init;
  
++<<<<<<< HEAD
 +	/* SCTP-AUTH:  auth_chunk pointer is only set when the cookie-echo
 +	 * is supposed to be authenticated and we have to do delayed
 +	 * authentication.  We've just recreated the association using
 +	 * the information in the cookie and now it's much easier to
 +	 * do the authentication.
 +	 */
 +	if (chunk->auth_chunk) {
 +		struct sctp_chunk auth;
 +		sctp_ierror_t ret;
 +
 +		/* Make sure that we and the peer are AUTH capable */
 +		if (!net->sctp.auth_enable || !new_asoc->peer.auth_capable) {
 +			sctp_association_free(new_asoc);
 +			return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);
 +		}
 +
 +		/* set-up our fake chunk so that we can process it */
 +		auth.skb = chunk->auth_chunk;
 +		auth.asoc = chunk->asoc;
 +		auth.sctp_hdr = chunk->sctp_hdr;
 +		auth.chunk_hdr = skb_push(chunk->auth_chunk,
 +					  sizeof(sctp_chunkhdr_t));
 +		skb_pull(chunk->auth_chunk, sizeof(sctp_chunkhdr_t));
 +		auth.transport = chunk->transport;
 +
 +		ret = sctp_sf_authenticate(net, ep, new_asoc, type, &auth);
 +		if (ret != SCTP_IERROR_NO_ERROR) {
 +			sctp_association_free(new_asoc);
 +			return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);
 +		}
++=======
+ 	if (!sctp_auth_chunk_verify(net, chunk, new_asoc)) {
+ 		sctp_association_free(new_asoc);
+ 		return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);
++>>>>>>> 59d8d4434f42 (sctp: delay the authentication for the duplicated cookie-echo chunk)
  	}
  
  	repl = sctp_make_cookie_ack(new_asoc, chunk);
@@@ -4003,13 -4179,13 +4099,19 @@@ gen_shutdown
   *
   * The return value is the disposition of the chunk.
   */
++<<<<<<< HEAD
 +static sctp_ierror_t sctp_sf_authenticate(struct net *net,
 +				    const struct sctp_endpoint *ep,
 +				    const struct sctp_association *asoc,
 +				    const sctp_subtype_t type,
 +				    struct sctp_chunk *chunk)
++=======
+ static enum sctp_ierror sctp_sf_authenticate(
+ 					const struct sctp_association *asoc,
+ 					struct sctp_chunk *chunk)
++>>>>>>> 59d8d4434f42 (sctp: delay the authentication for the duplicated cookie-echo chunk)
  {
 -	struct sctp_shared_key *sh_key = NULL;
  	struct sctp_authhdr *auth_hdr;
 -	__u8 *save_digest, *digest;
  	struct sctp_hmac *hmac;
  	unsigned int sig_len;
  	__u16 key_id;
* Unmerged path net/sctp/associola.c
* Unmerged path net/sctp/sm_statefuns.c
