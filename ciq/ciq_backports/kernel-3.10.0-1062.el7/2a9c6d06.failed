ovl: allocate anonymous devs for lowerdirs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Chandan Rajendra <chandan@linux.vnet.ibm.com>
commit 2a9c6d066e98c1fe51a735b1439929f2f2afd891
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/2a9c6d06.failed

Generate unique values of st_dev per lower layer for non-samefs
overlay mount. The unique values are obtained by allocating anonymous
bdevs for each of the lowerdirs in the overlayfs instance.

The anonymous bdev is going to be returned by stat(2) for lowerdir
non-dir entries in non-samefs case.

[amir: split from ovl_getattr() and re-structure patches]

	Signed-off-by: Chandan Rajendra <chandan@linux.vnet.ibm.com>
	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 2a9c6d066e98c1fe51a735b1439929f2f2afd891)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/ovl_entry.h
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/ovl_entry.h
index ec700f861f1b,93eb6a044dd2..000000000000
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@@ -19,6 -17,16 +19,19 @@@ struct ovl_config 
  	bool index;
  };
  
++<<<<<<< HEAD
++=======
+ struct ovl_layer {
+ 	struct vfsmount *mnt;
+ 	dev_t pseudo_dev;
+ };
+ 
+ struct ovl_path {
+ 	struct ovl_layer *layer;
+ 	struct dentry *dentry;
+ };
+ 
++>>>>>>> 2a9c6d066e98 (ovl: allocate anonymous devs for lowerdirs)
  /* private information held for overlayfs's superblock */
  struct ovl_fs {
  	struct vfsmount *upper_mnt;
diff --cc fs/overlayfs/super.c
index fa66b8c6f109,2c9f48096ff0..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -231,9 -219,11 +231,17 @@@ static void ovl_put_super(struct super_
  	if (ufs->upper_mnt && ufs->upperdir_locked)
  		ovl_inuse_unlock(ufs->upper_mnt->mnt_root);
  	mntput(ufs->upper_mnt);
++<<<<<<< HEAD
 +	for (i = 0; i < ufs->numlower; i++)
 +		mntput(ufs->lower_mnt[i]);
 +	kfree(ufs->lower_mnt);
++=======
+ 	for (i = 0; i < ufs->numlower; i++) {
+ 		mntput(ufs->lower_layers[i].mnt);
+ 		free_anon_bdev(ufs->lower_layers[i].pseudo_dev);
+ 	}
+ 	kfree(ufs->lower_layers);
++>>>>>>> 2a9c6d066e98 (ovl: allocate anonymous devs for lowerdirs)
  
  	kfree(ufs->config.lowerdir);
  	kfree(ufs->config.upperdir);
@@@ -1086,24 -1028,35 +1094,45 @@@ static int ovl_fill_super(struct super_
  	}
  
  	err = -ENOMEM;
 -	ufs->lower_layers = kcalloc(numlower, sizeof(struct ovl_layer),
 -				    GFP_KERNEL);
 -	if (ufs->lower_layers == NULL)
 +	ufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL);
 +	if (ufs->lower_mnt == NULL)
  		goto out_put_workdir;
  	for (i = 0; i < numlower; i++) {
++<<<<<<< HEAD
 +		struct vfsmount *mnt = clone_private_mount(&stack[i]);
++=======
+ 		struct vfsmount *mnt;
+ 		dev_t dev;
+ 
+ 		err = get_anon_bdev(&dev);
+ 		if (err) {
+ 			pr_err("overlayfs: failed to get anonymous bdev for lowerpath\n");
+ 			goto out_put_lower_layers;
+ 		}
++>>>>>>> 2a9c6d066e98 (ovl: allocate anonymous devs for lowerdirs)
  
 -		mnt = clone_private_mount(&stack[i]);
  		err = PTR_ERR(mnt);
  		if (IS_ERR(mnt)) {
  			pr_err("overlayfs: failed to clone lowerpath\n");
++<<<<<<< HEAD
 +			goto out_put_lower_mnt;
++=======
+ 			free_anon_bdev(dev);
+ 			goto out_put_lower_layers;
++>>>>>>> 2a9c6d066e98 (ovl: allocate anonymous devs for lowerdirs)
  		}
  		/*
 -		 * Make lower layers R/O.  That way fchmod/fchown on lower file
 +		 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
  		 * will fail instead of modifying lower fs.
  		 */
  		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
  
++<<<<<<< HEAD
 +		ufs->lower_mnt[ufs->numlower] = mnt;
++=======
+ 		ufs->lower_layers[ufs->numlower].mnt = mnt;
+ 		ufs->lower_layers[ufs->numlower].pseudo_dev = dev;
++>>>>>>> 2a9c6d066e98 (ovl: allocate anonymous devs for lowerdirs)
  		ufs->numlower++;
  
  		/* Check if all lower layers are on same sb */
@@@ -1215,10 -1170,15 +1244,22 @@@ out_put_cred
  	put_cred(ufs->creator_cred);
  out_put_indexdir:
  	dput(ufs->indexdir);
++<<<<<<< HEAD
 +out_put_lower_mnt:
 +	for (i = 0; i < ufs->numlower; i++)
 +		mntput(ufs->lower_mnt[i]);
 +	kfree(ufs->lower_mnt);
++=======
+ out_free_oe:
+ 	kfree(oe);
+ out_put_lower_layers:
+ 	for (i = 0; i < ufs->numlower; i++) {
+ 		if (ufs->lower_layers[i].mnt)
+ 			free_anon_bdev(ufs->lower_layers[i].pseudo_dev);
+ 		mntput(ufs->lower_layers[i].mnt);
+ 	}
+ 	kfree(ufs->lower_layers);
++>>>>>>> 2a9c6d066e98 (ovl: allocate anonymous devs for lowerdirs)
  out_put_workdir:
  	dput(ufs->workdir);
  	mntput(ufs->upper_mnt);
* Unmerged path fs/overlayfs/ovl_entry.h
* Unmerged path fs/overlayfs/super.c
