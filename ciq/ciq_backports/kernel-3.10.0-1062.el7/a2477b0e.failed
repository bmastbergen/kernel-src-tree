fuse: Don't access pipe->buffers without pipe_lock()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Andrey Ryabinin <aryabinin@virtuozzo.com>
commit a2477b0e67c52f4364a47c3ad70902bc2a61bd4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a2477b0e.failed

fuse_dev_splice_write() reads pipe->buffers to determine the size of
'bufs' array before taking the pipe_lock(). This is not safe as
another thread might change the 'pipe->buffers' between the allocation
and taking the pipe_lock(). So we end up with too small 'bufs' array.

Move the bufs allocations inside pipe_lock()/pipe_unlock() to fix this.

Fixes: dd3bb14f44a6 ("fuse: support splice() writing to fuse device")
	Signed-off-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
	Cc: <stable@vger.kernel.org> # v2.6.35
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit a2477b0e67c52f4364a47c3ad70902bc2a61bd4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/dev.c
diff --cc fs/fuse/dev.c
index d81feeed9393,4a9ace7280b9..000000000000
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@@ -1918,15 -1951,19 +1918,24 @@@ static ssize_t fuse_dev_splice_write(st
  	size_t rem;
  	ssize_t ret;
  
 -	fud = fuse_get_dev(out);
 -	if (!fud)
 +	fc = fuse_get_conn(out);
 +	if (!fc)
  		return -EPERM;
  
++<<<<<<< HEAD
 +	bufs = kmalloc(pipe->buffers * sizeof(struct pipe_buffer), GFP_KERNEL);
 +	if (!bufs)
++=======
+ 	pipe_lock(pipe);
+ 
+ 	bufs = kmalloc_array(pipe->buffers, sizeof(struct pipe_buffer),
+ 			     GFP_KERNEL);
+ 	if (!bufs) {
+ 		pipe_unlock(pipe);
++>>>>>>> a2477b0e67c5 (fuse: Don't access pipe->buffers without pipe_lock())
  		return -ENOMEM;
+ 	}
  
- 	pipe_lock(pipe);
  	nbuf = 0;
  	rem = 0;
  	for (idx = 0; idx < pipe->nrbufs && rem < len; idx++)
* Unmerged path fs/fuse/dev.c
