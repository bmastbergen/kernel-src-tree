netfilter: conntrack: introduce clash resolution on insertion race

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 71d8c47fc653711c41bc3282e5b0e605b3727956
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/71d8c47f.failed

This patch introduces nf_ct_resolve_clash() to resolve race condition on
conntrack insertions.

This is particularly a problem for connection-less protocols such as
UDP, with no initial handshake. Two or more packets may race to insert
the entry resulting in packet drops.

Another problematic scenario are packets enqueued to userspace via
NFQUEUE after the raw table, that make it easier to trigger this
race.

To resolve this, the idea is to reset the conntrack entry to the one
that won race. Packet and bytes counters are also merged.

The 'insert_failed' stats still accounts for this situation, after
this patch, the drop counter is bumped whenever we drop packets, so we
can watch for unresolved clashes.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 71d8c47fc653711c41bc3282e5b0e605b3727956)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_core.c
#	net/netfilter/nf_conntrack_proto_udplite.c
diff --cc net/netfilter/nf_conntrack_core.c
index 5a73e052c209,f58a70410c69..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -640,6 -602,63 +640,66 @@@ out
  }
  EXPORT_SYMBOL_GPL(nf_conntrack_hash_check_insert);
  
++<<<<<<< HEAD
++=======
+ static inline void nf_ct_acct_update(struct nf_conn *ct,
+ 				     enum ip_conntrack_info ctinfo,
+ 				     unsigned int len)
+ {
+ 	struct nf_conn_acct *acct;
+ 
+ 	acct = nf_conn_acct_find(ct);
+ 	if (acct) {
+ 		struct nf_conn_counter *counter = acct->counter;
+ 
+ 		atomic64_inc(&counter[CTINFO2DIR(ctinfo)].packets);
+ 		atomic64_add(len, &counter[CTINFO2DIR(ctinfo)].bytes);
+ 	}
+ }
+ 
+ static void nf_ct_acct_merge(struct nf_conn *ct, enum ip_conntrack_info ctinfo,
+ 			     const struct nf_conn *loser_ct)
+ {
+ 	struct nf_conn_acct *acct;
+ 
+ 	acct = nf_conn_acct_find(loser_ct);
+ 	if (acct) {
+ 		struct nf_conn_counter *counter = acct->counter;
+ 		enum ip_conntrack_info ctinfo;
+ 		unsigned int bytes;
+ 
+ 		/* u32 should be fine since we must have seen one packet. */
+ 		bytes = atomic64_read(&counter[CTINFO2DIR(ctinfo)].bytes);
+ 		nf_ct_acct_update(ct, ctinfo, bytes);
+ 	}
+ }
+ 
+ /* Resolve race on insertion if this protocol allows this. */
+ static int nf_ct_resolve_clash(struct net *net, struct sk_buff *skb,
+ 			       enum ip_conntrack_info ctinfo,
+ 			       struct nf_conntrack_tuple_hash *h)
+ {
+ 	/* This is the conntrack entry already in hashes that won race. */
+ 	struct nf_conn *ct = nf_ct_tuplehash_to_ctrack(h);
+ 	struct nf_conntrack_l4proto *l4proto;
+ 
+ 	l4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));
+ 	if (l4proto->allow_clash &&
+ 	    !nf_ct_is_dying(ct) &&
+ 	    atomic_inc_not_zero(&ct->ct_general.use)) {
+ 		nf_ct_acct_merge(ct, ctinfo, (struct nf_conn *)skb->nfct);
+ 		nf_conntrack_put(skb->nfct);
+ 		/* Assign conntrack already in hashes to this skbuff. Don't
+ 		 * modify skb->nfctinfo to ensure consistent stateful filtering.
+ 		 */
+ 		skb->nfct = &ct->ct_general;
+ 		return NF_ACCEPT;
+ 	}
+ 	NF_CT_STAT_INC(net, drop);
+ 	return NF_DROP;
+ }
+ 
++>>>>>>> 71d8c47fc653 (netfilter: conntrack: introduce clash resolution on insertion race)
  /* Confirm a connection given skb; places it in hash table */
  int
  __nf_conntrack_confirm(struct sk_buff *skb)
* Unmerged path net/netfilter/nf_conntrack_proto_udplite.c
diff --git a/include/net/netfilter/nf_conntrack_l4proto.h b/include/net/netfilter/nf_conntrack_l4proto.h
index 6100fc3a3c88..9a433cc527d8 100644
--- a/include/net/netfilter/nf_conntrack_l4proto.h
+++ b/include/net/netfilter/nf_conntrack_l4proto.h
@@ -23,6 +23,9 @@ struct nf_conntrack_l4proto {
 	/* L4 Protocol number. */
 	u_int8_t l4proto;
 
+	/* Resolve clashes on insertion races. */
+	bool allow_clash;
+
 	/* Try to fill in the third arg: dataoff is offset past network protocol
            hdr.  Return true if possible. */
 	bool (*pkt_to_tuple)(const struct sk_buff *skb, unsigned int dataoff,
* Unmerged path net/netfilter/nf_conntrack_core.c
diff --git a/net/netfilter/nf_conntrack_proto_udp.c b/net/netfilter/nf_conntrack_proto_udp.c
index 426f03f8fbdc..cd778c1aee5c 100644
--- a/net/netfilter/nf_conntrack_proto_udp.c
+++ b/net/netfilter/nf_conntrack_proto_udp.c
@@ -360,6 +360,7 @@ struct nf_conntrack_l4proto nf_conntrack_l4proto_udp4 __read_mostly =
 	.l3proto		= PF_INET,
 	.l4proto		= IPPROTO_UDP,
 	.name			= "udp",
+	.allow_clash		= true,
 	.pkt_to_tuple		= udp_pkt_to_tuple,
 	.invert_tuple		= udp_invert_tuple,
 	.print_tuple		= udp_print_tuple,
@@ -426,6 +427,7 @@ struct nf_conntrack_l4proto nf_conntrack_l4proto_udp6 __read_mostly =
 	.l3proto		= PF_INET6,
 	.l4proto		= IPPROTO_UDP,
 	.name			= "udp",
+	.allow_clash		= true,
 	.pkt_to_tuple		= udp_pkt_to_tuple,
 	.invert_tuple		= udp_invert_tuple,
 	.print_tuple		= udp_print_tuple,
* Unmerged path net/netfilter/nf_conntrack_proto_udplite.c
