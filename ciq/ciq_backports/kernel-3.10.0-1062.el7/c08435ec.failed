bpf: move {prev_,}insn_idx into verifier env

jira LE-1907
cve {CVE-2019-7308
cve [1673617]
cve Olsa)
cve (Jiri
cve env
cve verifier
cve into
cve insn_idx
cve prev_,
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [kernel] bpf: move {prev_, }insn_idx into verifier env (Jiri Olsa) [1673617] {CVE-2019-7308}
Rebuild_FUZZ: 98.88%
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit c08435ec7f2bc8f4109401f696fd55159b4b40cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c08435ec.failed

Move prev_insn_idx and insn_idx from the do_check() function into
the verifier environment, so they can be read inside the various
helper functions for handling the instructions. It's easier to put
this into the environment rather than changing all call-sites only
to pass it along. insn_idx is useful in particular since this later
on allows to hold state in env->insn_aux_data[env->insn_idx].

	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit c08435ec7f2bc8f4109401f696fd55159b4b40cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/verifier.c
index d8db1dfe467c,afa8515bbb34..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -4647,18 -5725,24 +4646,36 @@@ static int do_check(struct bpf_verifier
  		if (env->log.level) {
  			const struct bpf_insn_cbs cbs = {
  				.cb_print	= verbose,
 -				.private_data	= env,
  			};
  
++<<<<<<< HEAD
 +			verbose(env, "%d: ", insn_idx);
 +			print_bpf_insn(&cbs, env, insn, env->allow_ptr_leaks);
 +		}
 +
 +		err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);
 +		if (err)
 +			return err;
 +
 +		regs = cur_regs(env);
 +		env->insn_aux_data[insn_idx].seen = true;
++=======
+ 			verbose_linfo(env, env->insn_idx, "; ");
+ 			verbose(env, "%d: ", env->insn_idx);
+ 			print_bpf_insn(&cbs, insn, env->allow_ptr_leaks);
+ 		}
+ 
+ 		if (bpf_prog_is_dev_bound(env->prog->aux)) {
+ 			err = bpf_prog_offload_verify_insn(env, env->insn_idx,
+ 							   env->prev_insn_idx);
+ 			if (err)
+ 				return err;
+ 		}
+ 
+ 		regs = cur_regs(env);
+ 		env->insn_aux_data[env->insn_idx].seen = true;
+ 
++>>>>>>> c08435ec7f2b (bpf: move {prev_,}insn_idx into verifier env)
  		if (class == BPF_ALU || class == BPF_ALU64) {
  			err = check_alu_op(env, insn);
  			if (err)
diff --git a/include/linux/bpf_verifier.h b/include/linux/bpf_verifier.h
index 30a64bcc7a7d..9bc6bc828d0a 100644
--- a/include/linux/bpf_verifier.h
+++ b/include/linux/bpf_verifier.h
@@ -179,6 +179,8 @@ struct bpf_ext_analyzer_ops {
  * one verifier_env per bpf_check() call
  */
 struct bpf_verifier_env {
+	u32 insn_idx;
+	u32 prev_insn_idx;
 	struct bpf_prog *prog;		/* eBPF program being verified */
 	const struct bpf_verifier_ops *ops;
 	struct bpf_verifier_stack_elem *head; /* stack of verifier states to be processed */
* Unmerged path kernel/bpf/verifier.c
