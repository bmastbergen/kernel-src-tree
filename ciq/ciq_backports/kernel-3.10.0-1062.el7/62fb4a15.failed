don't carry MAY_OPEN in op->acc_mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 62fb4a155f745285d9b1640c3ef53bf90c12f17c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/62fb4a15.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 62fb4a155f745285d9b1640c3ef53bf90c12f17c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namei.c
diff --cc fs/namei.c
index 48f117bb6375,45c702edce3c..000000000000
--- a/fs/namei.c
+++ b/fs/namei.c
@@@ -3122,8 -3089,8 +3118,13 @@@ retry_lookup
  		/* Don't check for write permission, don't truncate */
  		open_flag &= ~O_TRUNC;
  		will_truncate = false;
++<<<<<<< HEAD
 +		acc_mode = MAY_OPEN;
 +		path_to_nameidata(path, nd);
++=======
+ 		acc_mode = 0;
+ 		path_to_nameidata(&path, nd);
++>>>>>>> 62fb4a155f74 (don't carry MAY_OPEN in op->acc_mode)
  		goto finish_open_created;
  	}
  
@@@ -3301,20 -3257,18 +3303,24 @@@ static int do_tmpfile(int dfd, struct f
  		error = -ENOMEM;
  		goto out2;
  	}
 -	dput(path.dentry);
 -	path.dentry = child;
 -	error = dir->i_op->tmpfile(dir, child, op->mode);
 +	nd->flags &= ~LOOKUP_DIRECTORY;
 +	nd->flags |= op->intent;
 +	dput(nd->path.dentry);
 +	nd->path.dentry = child;
 +	error = tmpfile(dir, nd->path.dentry, op->mode);
  	if (error)
  		goto out2;
 -	audit_inode(nd->name, child, 0);
 +	audit_inode(pathname, nd->path.dentry, 0);
  	/* Don't check for other permissions, the inode was just created */
++<<<<<<< HEAD
 +	error = may_open(&nd->path, MAY_OPEN, op->open_flag);
++=======
+ 	error = may_open(&path, 0, op->open_flag);
++>>>>>>> 62fb4a155f74 (don't carry MAY_OPEN in op->acc_mode)
  	if (error)
  		goto out2;
 -	file->f_path.mnt = path.mnt;
 -	error = finish_open(file, child, NULL, opened);
 +	file->f_path.mnt = nd->path.mnt;
 +	error = finish_open(file, nd->path.dentry, NULL, opened);
  	if (error)
  		goto out2;
  	error = open_check_o_direct(file);
diff --git a/fs/exec.c b/fs/exec.c
index 31e9d17a7fb6..7635ea00c0d6 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -118,7 +118,7 @@ SYSCALL_DEFINE1(uselib, const char __user *, library)
 	int error = PTR_ERR(tmp);
 	static const struct open_flags uselib_flags = {
 		.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,
-		.acc_mode = MAY_READ | MAY_EXEC | MAY_OPEN,
+		.acc_mode = MAY_READ | MAY_EXEC,
 		.intent = LOOKUP_OPEN,
 		.lookup_flags = LOOKUP_FOLLOW,
 	};
@@ -790,7 +790,7 @@ static struct file *do_open_exec(struct filename *name)
 	int err;
 	static const struct open_flags open_exec_flags = {
 		.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,
-		.acc_mode = MAY_EXEC | MAY_OPEN,
+		.acc_mode = MAY_EXEC,
 		.intent = LOOKUP_OPEN,
 		.lookup_flags = LOOKUP_FOLLOW,
 	};
* Unmerged path fs/namei.c
diff --git a/fs/open.c b/fs/open.c
index 78a390518479..fa55c6572b48 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -909,7 +909,7 @@ EXPORT_SYMBOL(vfs_open);
 static inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)
 {
 	int lookup_flags = 0;
-	int acc_mode;
+	int acc_mode = ACC_MODE(flags);
 
 	if (flags & (O_CREAT | __O_TMPFILE))
 		op->mode = (mode & S_IALLUGO) | S_IFREG;
@@ -931,7 +931,6 @@ static inline int build_open_flags(int flags, umode_t mode, struct open_flags *o
 	if (flags & __O_TMPFILE) {
 		if ((flags & O_TMPFILE_MASK) != O_TMPFILE)
 			return -EINVAL;
-		acc_mode = MAY_OPEN | ACC_MODE(flags);
 		if (!(acc_mode & MAY_WRITE))
 			return -EINVAL;
 	} else if (flags & O_PATH) {
@@ -941,8 +940,6 @@ static inline int build_open_flags(int flags, umode_t mode, struct open_flags *o
 		 */
 		flags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;
 		acc_mode = 0;
-	} else {
-		acc_mode = MAY_OPEN | ACC_MODE(flags);
 	}
 
 	op->open_flag = flags;
