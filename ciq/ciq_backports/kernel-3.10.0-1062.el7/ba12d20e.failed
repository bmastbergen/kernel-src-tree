perf/x86/intel: Factor out common code of PMI handler

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Kan Liang <kan.liang@linux.intel.com>
commit ba12d20edc5caf9835006d8f3efd4ed18465c75b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ba12d20e.failed

The Arch Perfmon v4 PMI handler is substantially different than
the older PMI handler. Instead of adding more and more ifs cleanly
fork the new handler into a new function, with the main common
code factored out into a common function.

Fix complaint from checkpatch.pl by removing "false" from "static bool
warned".

No functional change.

Based-on-code-from: Andi Kleen <ak@linux.intel.com>
	Signed-off-by: Kan Liang <kan.liang@linux.intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
	Cc: acme@kernel.org
Link: http://lkml.kernel.org/r/1533712328-2834-1-git-send-email-kan.liang@linux.intel.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit ba12d20edc5caf9835006d8f3efd4ed18465c75b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/events/intel/core.c
diff --cc arch/x86/events/intel/core.c
index 65e18eccc087,9b320a51f82f..000000000000
--- a/arch/x86/events/intel/core.c
+++ b/arch/x86/events/intel/core.c
@@@ -2141,51 -2200,12 +2141,53 @@@ static void intel_pmu_reset(void
  	local_irq_restore(flags);
  }
  
- /*
-  * This handler is triggered by the local APIC, so the APIC IRQ handling
-  * rules apply:
-  */
- static int intel_pmu_handle_irq(struct pt_regs *regs)
+ static int handle_pmi_common(struct pt_regs *regs, u64 status)
  {
  	struct perf_sample_data data;
++<<<<<<< HEAD
 +	struct cpu_hw_events *cpuc;
 +	int bit, loops;
 +	u64 status;
 +	int handled;
 +	int pmu_enabled;
 +
 +	cpuc = &__get_cpu_var(cpu_hw_events);
 +
 +	/*
 +	 * Save the PMU state.
 +	 * It needs to be restored when leaving the handler.
 +	 */
 +	pmu_enabled = cpuc->enabled;
 +	/*
 +	 * No known reason to not always do late ACK,
 +	 * but just in case do it opt-in.
 +	 */
 +	if (!x86_pmu.late_ack)
 +		apic_write(APIC_LVTPC, APIC_DM_NMI);
 +	intel_bts_disable_local();
 +	cpuc->enabled = 0;
 +	__intel_pmu_disable_all();
 +	handled = intel_pmu_drain_bts_buffer();
 +	handled += intel_bts_interrupt();
 +	status = intel_pmu_get_status();
 +	if (!status)
 +		goto done;
 +
 +	loops = 0;
 +again:
 +	intel_pmu_lbr_read();
 +	intel_pmu_ack_status(status);
 +	if (++loops > 100) {
 +		WARN_ONCE(1, "perfevents: irq loop stuck!\n");
 +		perf_event_print_debug();
 +		intel_pmu_reset();
 +		goto done;
 +	}
++=======
+ 	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
+ 	int bit;
+ 	int handled = 0;
++>>>>>>> ba12d20edc5c (perf/x86/intel: Factor out common code of PMI handler)
  
  	inc_irq_stat(apic_perf_irqs);
  
* Unmerged path arch/x86/events/intel/core.c
