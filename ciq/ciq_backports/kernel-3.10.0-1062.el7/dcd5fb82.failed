drm/amd/display: Fix reference counting for struct dc_sink.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [gpu] drm/amd/display: Fix reference counting for struct dc_sink (Dave Airlie) [1680275]
Rebuild_FUZZ: 99.15%
commit-author Mathias Fröhlich <Mathias.Froehlich@web.de>
commit dcd5fb82ffb484124203aa339733663ac0b059f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/dcd5fb82.failed

Reference counting in amdgpu_dm_connector for amdgpu_dm_connector::dc_sink
and amdgpu_dm_connector::dc_em_sink as well as in dc_link::local_sink seems
to be out of shape. Thus make reference counting consistent for these
members and just plain increment the reference count when the variable
gets assigned and decrement when the pointer is set to zero or replaced.
Also simplify reference counting in selected function sopes to be sure the
reference is released in any case. In some cases add NULL pointer check
before dereferencing.
At a hand full of places a comment is placed to stat that the reference
increment happened already somewhere else.

This actually fixes the following kernel bug on my system when enabling
display core in amdgpu. There are some more similar bug reports around,
so it probably helps at more places.

   kernel BUG at mm/slub.c:294!
   invalid opcode: 0000 [#1] SMP PTI
   CPU: 9 PID: 1180 Comm: Xorg Not tainted 5.0.0-rc1+ #2
   Hardware name: Supermicro X10DAi/X10DAI, BIOS 3.0a 02/05/2018
   RIP: 0010:__slab_free+0x1e2/0x3d0
   Code: 8b 54 24 30 48 89 4c 24 28 e8 da fb ff ff 4c 8b 54 24 28 85 c0 0f 85 67 fe ff ff 48 8d 65 d8 5b 41 5c 41 5d 41 5e 41 5f 5d c3 <0f> 0b 49 3b 5c 24 28 75 ab 48 8b 44 24 30 49 89 4c 24 28 49 89 44
   RSP: 0018:ffffb0978589fa90 EFLAGS: 00010246
   RAX: ffff92f12806c400 RBX: 0000000080200019 RCX: ffff92f12806c400
   RDX: ffff92f12806c400 RSI: ffffdd6421a01a00 RDI: ffff92ed2f406e80
   RBP: ffffb0978589fb40 R08: 0000000000000001 R09: ffffffffc0ee4748
   R10: ffff92f12806c400 R11: 0000000000000001 R12: ffffdd6421a01a00
   R13: ffff92f12806c400 R14: ffff92ed2f406e80 R15: ffffdd6421a01a20
   FS:  00007f4170be0ac0(0000) GS:ffff92ed2fb40000(0000) knlGS:0000000000000000
   CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
   CR2: 0000562818aaa000 CR3: 000000045745a002 CR4: 00000000003606e0
   DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
   DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
   Call Trace:
    ? drm_dbg+0x87/0x90 [drm]
    dc_stream_release+0x28/0x50 [amdgpu]
    amdgpu_dm_connector_mode_valid+0xb4/0x1f0 [amdgpu]
    drm_helper_probe_single_connector_modes+0x492/0x6b0 [drm_kms_helper]
    drm_mode_getconnector+0x457/0x490 [drm]
    ? drm_connector_property_set_ioctl+0x60/0x60 [drm]
    drm_ioctl_kernel+0xa9/0xf0 [drm]
    drm_ioctl+0x201/0x3a0 [drm]
    ? drm_connector_property_set_ioctl+0x60/0x60 [drm]
    amdgpu_drm_ioctl+0x49/0x80 [amdgpu]
    do_vfs_ioctl+0xa4/0x630
    ? __sys_recvmsg+0x83/0xa0
    ksys_ioctl+0x60/0x90
    __x64_sys_ioctl+0x16/0x20
    do_syscall_64+0x5b/0x160
    entry_SYSCALL_64_after_hwframe+0x44/0xa9
   RIP: 0033:0x7f417110809b
   Code: 0f 1e fa 48 8b 05 ed bd 0c 00 64 c7 00 26 00 00 00 48 c7 c0 ff ff ff ff c3 66 0f 1f 44 00 00 f3 0f 1e fa b8 10 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d bd bd 0c 00 f7 d8 64 89 01 48
   RSP: 002b:00007ffdd8d1c268 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
   RAX: ffffffffffffffda RBX: 0000562818a8ebc0 RCX: 00007f417110809b
   RDX: 00007ffdd8d1c2a0 RSI: 00000000c05064a7 RDI: 0000000000000012
   RBP: 00007ffdd8d1c2a0 R08: 0000562819012280 R09: 0000000000000007
   R10: 0000000000000000 R11: 0000000000000246 R12: 00000000c05064a7
   R13: 0000000000000012 R14: 0000000000000012 R15: 00007ffdd8d1c2a0
   Modules linked in: nfsv4 dns_resolver nfs lockd grace fscache fuse vfat fat amdgpu intel_rapl sb_edac x86_pkg_temp_thermal intel_powerclamp coretemp kvm_intel kvm irqbypass crct10dif_pclmul chash gpu_sched crc32_pclmul snd_hda_codec_realtek ghash_clmulni_intel amd_iommu_v2 iTCO_wdt iTCO_vendor_support ttm snd_hda_codec_generic snd_hda_codec_hdmi ledtrig_audio snd_hda_intel drm_kms_helper snd_hda_codec intel_cstate snd_hda_core drm snd_hwdep snd_seq snd_seq_device intel_uncore snd_pcm intel_rapl_perf snd_timer snd soundcore ioatdma pcspkr intel_wmi_thunderbolt mxm_wmi i2c_i801 lpc_ich pcc_cpufreq auth_rpcgss sunrpc igb crc32c_intel i2c_algo_bit dca wmi hid_cherry analog gameport joydev

This patch is based on agd5f/drm-next-5.1-wip. This patch does not require
all of that, but agd5f/drm-next-5.1-wip contains at least one more dc_sink
counting fix that I could spot.

	Signed-off-by: Mathias Fröhlich <Mathias.Froehlich@web.de>
	Reviewed-by: Leo Li <sunpeng.li@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit dcd5fb82ffb484124203aa339733663ac0b059f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
diff --cc drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 8dafb10b7832,2e7f4d2ae73a..000000000000
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@@ -647,6 -817,88 +647,91 @@@ amdgpu_dm_find_first_crtc_matching_conn
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ static void emulated_link_detect(struct dc_link *link)
+ {
+ 	struct dc_sink_init_data sink_init_data = { 0 };
+ 	struct display_sink_capability sink_caps = { 0 };
+ 	enum dc_edid_status edid_status;
+ 	struct dc_context *dc_ctx = link->ctx;
+ 	struct dc_sink *sink = NULL;
+ 	struct dc_sink *prev_sink = NULL;
+ 
+ 	link->type = dc_connection_none;
+ 	prev_sink = link->local_sink;
+ 
+ 	if (prev_sink != NULL)
+ 		dc_sink_retain(prev_sink);
+ 
+ 	switch (link->connector_signal) {
+ 	case SIGNAL_TYPE_HDMI_TYPE_A: {
+ 		sink_caps.transaction_type = DDC_TRANSACTION_TYPE_I2C;
+ 		sink_caps.signal = SIGNAL_TYPE_HDMI_TYPE_A;
+ 		break;
+ 	}
+ 
+ 	case SIGNAL_TYPE_DVI_SINGLE_LINK: {
+ 		sink_caps.transaction_type = DDC_TRANSACTION_TYPE_I2C;
+ 		sink_caps.signal = SIGNAL_TYPE_DVI_SINGLE_LINK;
+ 		break;
+ 	}
+ 
+ 	case SIGNAL_TYPE_DVI_DUAL_LINK: {
+ 		sink_caps.transaction_type = DDC_TRANSACTION_TYPE_I2C;
+ 		sink_caps.signal = SIGNAL_TYPE_DVI_DUAL_LINK;
+ 		break;
+ 	}
+ 
+ 	case SIGNAL_TYPE_LVDS: {
+ 		sink_caps.transaction_type = DDC_TRANSACTION_TYPE_I2C;
+ 		sink_caps.signal = SIGNAL_TYPE_LVDS;
+ 		break;
+ 	}
+ 
+ 	case SIGNAL_TYPE_EDP: {
+ 		sink_caps.transaction_type =
+ 			DDC_TRANSACTION_TYPE_I2C_OVER_AUX;
+ 		sink_caps.signal = SIGNAL_TYPE_EDP;
+ 		break;
+ 	}
+ 
+ 	case SIGNAL_TYPE_DISPLAY_PORT: {
+ 		sink_caps.transaction_type =
+ 			DDC_TRANSACTION_TYPE_I2C_OVER_AUX;
+ 		sink_caps.signal = SIGNAL_TYPE_VIRTUAL;
+ 		break;
+ 	}
+ 
+ 	default:
+ 		DC_ERROR("Invalid connector type! signal:%d\n",
+ 			link->connector_signal);
+ 		return;
+ 	}
+ 
+ 	sink_init_data.link = link;
+ 	sink_init_data.sink_signal = sink_caps.signal;
+ 
+ 	sink = dc_sink_create(&sink_init_data);
+ 	if (!sink) {
+ 		DC_ERROR("Failed to create sink!\n");
+ 		return;
+ 	}
+ 
+ 	/* dc_sink_create returns a new reference */
+ 	link->local_sink = sink;
+ 
+ 	edid_status = dm_helpers_read_local_edid(
+ 			link->ctx,
+ 			link,
+ 			sink);
+ 
+ 	if (edid_status != EDID_OK)
+ 		DC_ERROR("Failed to read EDID");
+ 
+ }
+ 
++>>>>>>> dcd5fb82ffb4 (drm/amd/display: Fix reference counting for struct dc_sink.)
  static int dm_resume(void *handle)
  {
  	struct amdgpu_device *adev = handle;
@@@ -841,10 -1064,13 +928,12 @@@ amdgpu_dm_update_connector_after_detect
  
  
  	sink = aconnector->dc_link->local_sink;
+ 	if (sink)
+ 		dc_sink_retain(sink);
  
 -	/*
 -	 * Edid mgmt connector gets first update only in mode_valid hook and then
 +	/* Edid mgmt connector gets first update only in mode_valid hook and then
  	 * the connector sink is set to either fake or physical sink depends on link status.
 -	 * Skip if already done during boot.
 +	 * don't do it here if u are during boot
  	 */
  	if (aconnector->base.force != DRM_FORCE_UNSPECIFIED
  			&& aconnector->dc_em_sink) {
@@@ -856,25 -1083,25 +945,33 @@@
  
  		if (sink) {
  			if (aconnector->dc_sink) {
 -				amdgpu_dm_update_freesync_caps(connector, NULL);
 -				/*
 -				 * retain and release below are used to
 -				 * bump up refcount for sink because the link doesn't point
 -				 * to it anymore after disconnect, so on next crtc to connector
 +				amdgpu_dm_remove_sink_from_freesync_module(
 +								connector);
 +				/* retain and release bellow are used for
 +				 * bump up refcount for sink because the link don't point
 +				 * to it anymore after disconnect so on next crtc to connector
  				 * reshuffle by UMD we will get into unwanted dc_sink release
  				 */
- 				if (aconnector->dc_sink != aconnector->dc_em_sink)
- 					dc_sink_release(aconnector->dc_sink);
+ 				dc_sink_release(aconnector->dc_sink);
  			}
  			aconnector->dc_sink = sink;
++<<<<<<< HEAD
 +			amdgpu_dm_add_sink_to_freesync_module(
 +						connector, aconnector->edid);
 +		} else {
 +			amdgpu_dm_remove_sink_from_freesync_module(connector);
 +			if (!aconnector->dc_sink)
++=======
+ 			dc_sink_retain(aconnector->dc_sink);
+ 			amdgpu_dm_update_freesync_caps(connector,
+ 					aconnector->edid);
+ 		} else {
+ 			amdgpu_dm_update_freesync_caps(connector, NULL);
+ 			if (!aconnector->dc_sink) {
++>>>>>>> dcd5fb82ffb4 (drm/amd/display: Fix reference counting for struct dc_sink.)
  				aconnector->dc_sink = aconnector->dc_em_sink;
- 			else if (aconnector->dc_sink != aconnector->dc_em_sink)
  				dc_sink_retain(aconnector->dc_sink);
+ 			}
  		}
  
  		mutex_unlock(&dev->mode_config.mutex);
@@@ -885,14 -1115,20 +985,18 @@@
  	 * TODO: temporary guard to look for proper fix
  	 * if this sink is MST sink, we should not do anything
  	 */
- 	if (sink && sink->sink_signal == SIGNAL_TYPE_DISPLAY_PORT_MST)
+ 	if (sink && sink->sink_signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {
+ 		dc_sink_release(sink);
  		return;
+ 	}
  
  	if (aconnector->dc_sink == sink) {
 -		/*
 -		 * We got a DP short pulse (Link Loss, DP CTS, etc...).
 -		 * Do nothing!!
 -		 */
 +		/* We got a DP short pulse (Link Loss, DP CTS, etc...).
 +		 * Do nothing!! */
  		DRM_DEBUG_DRIVER("DCHPD: connector_id=%d: dc_sink didn't change.\n",
  				aconnector->connector_id);
+ 		if (sink)
+ 			dc_sink_release(sink);
  		return;
  	}
  
@@@ -901,32 -1137,41 +1005,34 @@@
  
  	mutex_lock(&dev->mode_config.mutex);
  
 -	/*
 -	 * 1. Update status of the drm connector
 -	 * 2. Send an event and let userspace tell us what to do
 -	 */
 +	/* 1. Update status of the drm connector
 +	 * 2. Send an event and let userspace tell us what to do */
  	if (sink) {
 -		/*
 -		 * TODO: check if we still need the S3 mode update workaround.
 -		 * If yes, put it here.
 -		 */
 +		/* TODO: check if we still need the S3 mode update workaround.
 +		 * If yes, put it here. */
  		if (aconnector->dc_sink)
 -			amdgpu_dm_update_freesync_caps(connector, NULL);
 +			amdgpu_dm_remove_sink_from_freesync_module(
 +							connector);
  
  		aconnector->dc_sink = sink;
+ 		dc_sink_retain(aconnector->dc_sink);
  		if (sink->dc_edid.length == 0) {
  			aconnector->edid = NULL;
 -			drm_dp_cec_unset_edid(&aconnector->dm_dp_aux.aux);
  		} else {
  			aconnector->edid =
  				(struct edid *) sink->dc_edid.raw_edid;
  
  
 -			drm_connector_update_edid_property(connector,
 +			drm_mode_connector_update_edid_property(connector,
  					aconnector->edid);
 -			drm_dp_cec_set_edid(&aconnector->dm_dp_aux.aux,
 -					    aconnector->edid);
  		}
 -		amdgpu_dm_update_freesync_caps(connector, aconnector->edid);
 +		amdgpu_dm_add_sink_to_freesync_module(connector, aconnector->edid);
  
  	} else {
 -		drm_dp_cec_unset_edid(&aconnector->dm_dp_aux.aux);
 -		amdgpu_dm_update_freesync_caps(connector, NULL);
 -		drm_connector_update_edid_property(connector, NULL);
 +		amdgpu_dm_remove_sink_from_freesync_module(connector);
 +		drm_mode_connector_update_edid_property(connector, NULL);
  		aconnector->num_modes = 0;
+ 		dc_sink_release(aconnector->dc_sink);
  		aconnector->dc_sink = NULL;
  		aconnector->edid = NULL;
  	}
@@@ -2430,20 -2989,15 +2539,26 @@@ create_stream_for_sink(struct amdgpu_dm
  	drm_connector = &aconnector->base;
  
  	if (!aconnector->dc_sink) {
 -		sink = create_fake_sink(aconnector);
 -		if (!sink)
 +		/*
 +		 * Create dc_sink when necessary to MST
 +		 * Don't apply fake_sink to MST
 +		 */
 +		if (aconnector->mst_port) {
 +			dm_dp_mst_dc_sink_create(drm_connector);
 +			return stream;
 +		}
 +
 +		if (create_fake_sink(aconnector))
  			return stream;
++<<<<<<< HEAD
++=======
+ 	} else {
+ 		sink = aconnector->dc_sink;
+ 		dc_sink_retain(sink);
++>>>>>>> dcd5fb82ffb4 (drm/amd/display: Fix reference counting for struct dc_sink.)
  	}
  
 -	stream = dc_create_stream_for_sink(sink);
 +	stream = dc_create_stream_for_sink(aconnector->dc_sink);
  
  	if (stream == NULL) {
  		DRM_ERROR("Failed to create stream for sink!\n");
@@@ -2486,9 -3055,12 +2601,16 @@@
  	fill_audio_info(
  		&stream->audio_info,
  		drm_connector,
 -		sink);
 +		aconnector->dc_sink);
  
++<<<<<<< HEAD
 +	update_stream_signal(stream);
++=======
+ 	update_stream_signal(stream, sink);
+ 
+ finish:
+ 	dc_sink_release(sink);
++>>>>>>> dcd5fb82ffb4 (drm/amd/display: Fix reference counting for struct dc_sink.)
  
  	return stream;
  }
@@@ -2716,16 -3312,21 +2838,28 @@@ static void amdgpu_dm_connector_destroy
  	defined(CONFIG_BACKLIGHT_CLASS_DEVICE_MODULE)
  
  	if ((link->connector_signal & (SIGNAL_TYPE_EDP | SIGNAL_TYPE_LVDS)) &&
 -	    link->type != dc_connection_none &&
 -	    dm->backlight_dev) {
 -		backlight_device_unregister(dm->backlight_dev);
 -		dm->backlight_dev = NULL;
 +	    link->type != dc_connection_none) {
 +		amdgpu_dm_register_backlight_device(dm);
 +
 +		if (dm->backlight_dev) {
 +			backlight_device_unregister(dm->backlight_dev);
 +			dm->backlight_dev = NULL;
 +		}
 +
  	}
  #endif
++<<<<<<< HEAD
++=======
+ 
+ 	if (aconnector->dc_em_sink)
+ 		dc_sink_release(aconnector->dc_em_sink);
+ 	aconnector->dc_em_sink = NULL;
+ 	if (aconnector->dc_sink)
+ 		dc_sink_release(aconnector->dc_sink);
+ 	aconnector->dc_sink = NULL;
+ 
+ 	drm_dp_cec_unregister_connector(&aconnector->dm_dp_aux.aux);
++>>>>>>> dcd5fb82ffb4 (drm/amd/display: Fix reference counting for struct dc_sink.)
  	drm_connector_unregister(connector);
  	drm_connector_cleanup(connector);
  	kfree(connector);
* Unmerged path drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index ace9ad578ca0..2366c1ec95c6 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -250,6 +250,7 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 			&init_params);
 
 		dc_sink->priv = aconnector;
+		/* dc_link_add_remote_sink returns a new reference */
 		aconnector->dc_sink = dc_sink;
 
 		if (aconnector->dc_sink)
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link.c b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
index 6d1c4981a185..03e2f86db29c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
@@ -670,6 +670,7 @@ bool dc_link_detect(struct dc_link *link, enum dc_detect_reason reason)
 		sink->dongle_max_pix_clk = sink_caps.max_hdmi_pixel_clock;
 		sink->converter_disable_audio = converter_disable_audio;
 
+		/* dc_sink_create returns a new reference */
 		link->local_sink = sink;
 
 		edid_status = dm_helpers_read_local_edid(
