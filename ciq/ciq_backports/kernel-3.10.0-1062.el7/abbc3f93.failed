ext4: fix a race in the ext4 shutdown path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Harshad Shirwadkar <harshads@google.com>
commit abbc3f9395c76d554a9ed27d4b1ebfb5d9b0e4ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/abbc3f93.failed

This patch fixes a race between the shutdown path and bio completion
handling. In the ext4 direct io path with async io, after submitting a
bio to the block layer, if journal starting fails,
ext4_direct_IO_write() would bail out pretending that the IO
failed. The caller would have had no way of knowing whether or not the
IO was successfully submitted. So instead, we return -EIOCBQUEUED in
this case. Now, the caller knows that the IO was submitted.  The bio
completion handler takes care of the error.

Tested: Ran the shutdown xfstest test 461 in loop for over 2 hours across
4 machines resulting in over 400 runs. Verified that the race didn't
occur. Usually the race was seen in about 20-30 iterations.

	Signed-off-by: Harshad Shirwadkar <harshads@google.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: stable@vger.kernel.org
(cherry picked from commit abbc3f9395c76d554a9ed27d4b1ebfb5d9b0e4ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/inode.c
diff --cc fs/ext4/inode.c
index 10cc03709589,4c2f8b57bdc7..000000000000
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@@ -3426,13 -3752,60 +3426,65 @@@ static ssize_t ext4_ext_direct_IO(int r
  		ext4_clear_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);
  	}
  
 -	inode_dio_end(inode);
 +retake_lock:
 +	if (rw == WRITE)
 +		inode_dio_end(inode);
  	/* take i_mutex locking again if we do a ovewrite dio */
  	if (overwrite)
 -		inode_lock(inode);
 +		mutex_lock(&inode->i_mutex);
  
++<<<<<<< HEAD
++=======
+ 	if (ret < 0 && final_size > inode->i_size)
+ 		ext4_truncate_failed_write(inode);
+ 
+ 	/* Handle extending of i_size after direct IO write */
+ 	if (orphan) {
+ 		int err;
+ 
+ 		/* Credits for sb + inode write */
+ 		handle = ext4_journal_start(inode, EXT4_HT_INODE, 2);
+ 		if (IS_ERR(handle)) {
+ 			/*
+ 			 * We wrote the data but cannot extend
+ 			 * i_size. Bail out. In async io case, we do
+ 			 * not return error here because we have
+ 			 * already submmitted the corresponding
+ 			 * bio. Returning error here makes the caller
+ 			 * think that this IO is done and failed
+ 			 * resulting in race with bio's completion
+ 			 * handler.
+ 			 */
+ 			if (!ret)
+ 				ret = PTR_ERR(handle);
+ 			if (inode->i_nlink)
+ 				ext4_orphan_del(NULL, inode);
+ 
+ 			goto out;
+ 		}
+ 		if (inode->i_nlink)
+ 			ext4_orphan_del(handle, inode);
+ 		if (ret > 0) {
+ 			loff_t end = offset + ret;
+ 			if (end > inode->i_size) {
+ 				ei->i_disksize = end;
+ 				i_size_write(inode, end);
+ 				/*
+ 				 * We're going to return a positive `ret'
+ 				 * here due to non-zero-length I/O, so there's
+ 				 * no way of reporting error returns from
+ 				 * ext4_mark_inode_dirty() to userspace.  So
+ 				 * ignore it.
+ 				 */
+ 				ext4_mark_inode_dirty(handle, inode);
+ 			}
+ 		}
+ 		err = ext4_journal_stop(handle);
+ 		if (ret == 0)
+ 			ret = err;
+ 	}
+ out:
++>>>>>>> abbc3f9395c7 (ext4: fix a race in the ext4 shutdown path)
  	return ret;
  }
  
* Unmerged path fs/ext4/inode.c
