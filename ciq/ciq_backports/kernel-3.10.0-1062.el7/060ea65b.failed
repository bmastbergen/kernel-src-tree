xfs: add a xfs_bmap_fork_to_state helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 060ea65b39409f3b9952dfa6db5fbe4355e6888a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/060ea65b.failed

This creates the right initial bmap state from the passed in inode
fork enum.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 060ea65b39409f3b9952dfa6db5fbe4355e6888a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/libxfs/xfs_bmap.h
diff --cc fs/xfs/libxfs/xfs_bmap.c
index b9959d9eb265,070b078c3494..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -502,10 -499,7 +502,14 @@@ xfs_bmap_trace_exlist
  {
  	xfs_extnum_t	idx;		/* extent record index */
  	xfs_ifork_t	*ifp;		/* inode fork pointer */
++<<<<<<< HEAD
 +	int		state = 0;
 +
 +	if (whichfork == XFS_ATTR_FORK)
 +		state |= BMAP_ATTRFORK;
++=======
+ 	int		state = xfs_bmap_fork_to_state(whichfork);
++>>>>>>> 060ea65b3940 (xfs: add a xfs_bmap_fork_to_state helper)
  
  	ifp = XFS_IFORK_PTR(ip, whichfork);
  	ASSERT(cnt == xfs_iext_count(ifp));
@@@ -2641,11 -2590,10 +2644,15 @@@ xfs_bmap_add_extent_hole_delay
  	xfs_filblks_t		newlen=0;	/* new indirect size */
  	xfs_filblks_t		oldlen=0;	/* old indirect size */
  	xfs_bmbt_irec_t		right;	/* right neighbor extent entry */
- 	int			state;  /* state bits, accessed thru macros */
+ 	int			state = xfs_bmap_fork_to_state(whichfork);
  	xfs_filblks_t		temp;	 /* temp for indirect calculations */
  
++<<<<<<< HEAD
 +	ifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);
 +	state = 0;
++=======
+ 	ifp = XFS_IFORK_PTR(ip, whichfork);
++>>>>>>> 060ea65b3940 (xfs: add a xfs_bmap_fork_to_state helper)
  	ASSERT(isnullstartblock(new->br_startblock));
  
  	/*
@@@ -2808,10 -2756,6 +2815,13 @@@ xfs_bmap_add_extent_hole_real
  
  	XFS_STATS_INC(mp, xs_add_exlist);
  
++<<<<<<< HEAD
 +	state = 0;
 +	if (whichfork == XFS_ATTR_FORK)
 +		state |= BMAP_ATTRFORK;
 +
++=======
++>>>>>>> 060ea65b3940 (xfs: add a xfs_bmap_fork_to_state helper)
  	/*
  	 * Check and set flags if this segment has a left neighbor.
  	 */
@@@ -4653,12 -4714,226 +4663,229 @@@ xfs_bmap_split_indlen
  	return stolen;
  }
  
++<<<<<<< HEAD
++=======
+ int
+ xfs_bmap_del_extent_delay(
+ 	struct xfs_inode	*ip,
+ 	int			whichfork,
+ 	xfs_extnum_t		*idx,
+ 	struct xfs_bmbt_irec	*got,
+ 	struct xfs_bmbt_irec	*del)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	struct xfs_bmbt_irec	new;
+ 	int64_t			da_old, da_new, da_diff = 0;
+ 	xfs_fileoff_t		del_endoff, got_endoff;
+ 	xfs_filblks_t		got_indlen, new_indlen, stolen;
+ 	int			state = xfs_bmap_fork_to_state(whichfork);
+ 	int			error = 0;
+ 	bool			isrt;
+ 
+ 	XFS_STATS_INC(mp, xs_del_exlist);
+ 
+ 	isrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);
+ 	del_endoff = del->br_startoff + del->br_blockcount;
+ 	got_endoff = got->br_startoff + got->br_blockcount;
+ 	da_old = startblockval(got->br_startblock);
+ 	da_new = 0;
+ 
+ 	ASSERT(*idx >= 0);
+ 	ASSERT(*idx <= xfs_iext_count(ifp));
+ 	ASSERT(del->br_blockcount > 0);
+ 	ASSERT(got->br_startoff <= del->br_startoff);
+ 	ASSERT(got_endoff >= del_endoff);
+ 
+ 	if (isrt) {
+ 		uint64_t rtexts = XFS_FSB_TO_B(mp, del->br_blockcount);
+ 
+ 		do_div(rtexts, mp->m_sb.sb_rextsize);
+ 		xfs_mod_frextents(mp, rtexts);
+ 	}
+ 
+ 	/*
+ 	 * Update the inode delalloc counter now and wait to update the
+ 	 * sb counters as we might have to borrow some blocks for the
+ 	 * indirect block accounting.
+ 	 */
+ 	error = xfs_trans_reserve_quota_nblks(NULL, ip,
+ 			-((long)del->br_blockcount), 0,
+ 			isrt ? XFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS);
+ 	if (error)
+ 		return error;
+ 	ip->i_delayed_blks -= del->br_blockcount;
+ 
+ 	if (got->br_startoff == del->br_startoff)
+ 		state |= BMAP_LEFT_FILLING;
+ 	if (got_endoff == del_endoff)
+ 		state |= BMAP_RIGHT_FILLING;
+ 
+ 	switch (state & (BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING)) {
+ 	case BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Matches the whole extent.  Delete the entry.
+ 		 */
+ 		xfs_iext_remove(ip, *idx, 1, state);
+ 		--*idx;
+ 		break;
+ 	case BMAP_LEFT_FILLING:
+ 		/*
+ 		 * Deleting the first part of the extent.
+ 		 */
+ 		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
+ 		got->br_startoff = del_endoff;
+ 		got->br_blockcount -= del->br_blockcount;
+ 		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip,
+ 				got->br_blockcount), da_old);
+ 		got->br_startblock = nullstartblock((int)da_new);
+ 		xfs_iext_update_extent(ifp, *idx, got);
+ 		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
+ 		break;
+ 	case BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Deleting the last part of the extent.
+ 		 */
+ 		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
+ 		got->br_blockcount = got->br_blockcount - del->br_blockcount;
+ 		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip,
+ 				got->br_blockcount), da_old);
+ 		got->br_startblock = nullstartblock((int)da_new);
+ 		xfs_iext_update_extent(ifp, *idx, got);
+ 		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
+ 		break;
+ 	case 0:
+ 		/*
+ 		 * Deleting the middle of the extent.
+ 		 *
+ 		 * Distribute the original indlen reservation across the two new
+ 		 * extents.  Steal blocks from the deleted extent if necessary.
+ 		 * Stealing blocks simply fudges the fdblocks accounting below.
+ 		 * Warn if either of the new indlen reservations is zero as this
+ 		 * can lead to delalloc problems.
+ 		 */
+ 		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
+ 
+ 		got->br_blockcount = del->br_startoff - got->br_startoff;
+ 		got_indlen = xfs_bmap_worst_indlen(ip, got->br_blockcount);
+ 
+ 		new.br_blockcount = got_endoff - del_endoff;
+ 		new_indlen = xfs_bmap_worst_indlen(ip, new.br_blockcount);
+ 
+ 		WARN_ON_ONCE(!got_indlen || !new_indlen);
+ 		stolen = xfs_bmap_split_indlen(da_old, &got_indlen, &new_indlen,
+ 						       del->br_blockcount);
+ 
+ 		got->br_startblock = nullstartblock((int)got_indlen);
+ 		xfs_iext_update_extent(ifp, *idx, got);
+ 		trace_xfs_bmap_post_update(ip, *idx, 0, _THIS_IP_);
+ 
+ 		new.br_startoff = del_endoff;
+ 		new.br_state = got->br_state;
+ 		new.br_startblock = nullstartblock((int)new_indlen);
+ 
+ 		++*idx;
+ 		xfs_iext_insert(ip, *idx, 1, &new, state);
+ 
+ 		da_new = got_indlen + new_indlen - stolen;
+ 		del->br_blockcount -= stolen;
+ 		break;
+ 	}
+ 
+ 	ASSERT(da_old >= da_new);
+ 	da_diff = da_old - da_new;
+ 	if (!isrt)
+ 		da_diff += del->br_blockcount;
+ 	if (da_diff)
+ 		xfs_mod_fdblocks(mp, da_diff, false);
+ 	return error;
+ }
+ 
+ void
+ xfs_bmap_del_extent_cow(
+ 	struct xfs_inode	*ip,
+ 	xfs_extnum_t		*idx,
+ 	struct xfs_bmbt_irec	*got,
+ 	struct xfs_bmbt_irec	*del)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, XFS_COW_FORK);
+ 	struct xfs_bmbt_irec	new;
+ 	xfs_fileoff_t		del_endoff, got_endoff;
+ 	int			state = BMAP_COWFORK;
+ 
+ 	XFS_STATS_INC(mp, xs_del_exlist);
+ 
+ 	del_endoff = del->br_startoff + del->br_blockcount;
+ 	got_endoff = got->br_startoff + got->br_blockcount;
+ 
+ 	ASSERT(*idx >= 0);
+ 	ASSERT(*idx <= xfs_iext_count(ifp));
+ 	ASSERT(del->br_blockcount > 0);
+ 	ASSERT(got->br_startoff <= del->br_startoff);
+ 	ASSERT(got_endoff >= del_endoff);
+ 	ASSERT(!isnullstartblock(got->br_startblock));
+ 
+ 	if (got->br_startoff == del->br_startoff)
+ 		state |= BMAP_LEFT_FILLING;
+ 	if (got_endoff == del_endoff)
+ 		state |= BMAP_RIGHT_FILLING;
+ 
+ 	switch (state & (BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING)) {
+ 	case BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Matches the whole extent.  Delete the entry.
+ 		 */
+ 		xfs_iext_remove(ip, *idx, 1, state);
+ 		--*idx;
+ 		break;
+ 	case BMAP_LEFT_FILLING:
+ 		/*
+ 		 * Deleting the first part of the extent.
+ 		 */
+ 		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
+ 		got->br_startoff = del_endoff;
+ 		got->br_blockcount -= del->br_blockcount;
+ 		got->br_startblock = del->br_startblock + del->br_blockcount;
+ 		xfs_iext_update_extent(ifp, *idx, got);
+ 		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
+ 		break;
+ 	case BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Deleting the last part of the extent.
+ 		 */
+ 		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
+ 		got->br_blockcount -= del->br_blockcount;
+ 		xfs_iext_update_extent(ifp, *idx, got);
+ 		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
+ 		break;
+ 	case 0:
+ 		/*
+ 		 * Deleting the middle of the extent.
+ 		 */
+ 		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
+ 		got->br_blockcount = del->br_startoff - got->br_startoff;
+ 		xfs_iext_update_extent(ifp, *idx, got);
+ 		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
+ 
+ 		new.br_startoff = del_endoff;
+ 		new.br_blockcount = got_endoff - del_endoff;
+ 		new.br_state = got->br_state;
+ 		new.br_startblock = del->br_startblock + del->br_blockcount;
+ 
+ 		++*idx;
+ 		xfs_iext_insert(ip, *idx, 1, &new, state);
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 060ea65b3940 (xfs: add a xfs_bmap_fork_to_state helper)
  /*
   * Called by xfs_bmapi to update file extent records and the btree
 - * after removing space.
 + * after removing space (or undoing a delayed allocation).
   */
  STATIC int				/* error */
 -xfs_bmap_del_extent_real(
 +xfs_bmap_del_extent(
  	xfs_inode_t		*ip,	/* incore inode pointer */
  	xfs_trans_t		*tp,	/* current transaction pointer */
  	xfs_extnum_t		*idx,	/* extent number to update/delete */
@@@ -4686,16 -4958,12 +4913,24 @@@
  	xfs_bmbt_irec_t		new;	/* new record to be inserted */
  	/* REFERENCED */
  	uint			qfield;	/* quota field to update */
++<<<<<<< HEAD
 +	xfs_filblks_t		temp;	/* for indirect length calculations */
 +	xfs_filblks_t		temp2;	/* for indirect length calculations */
 +	int			state = 0;
++=======
+ 	int			state = xfs_bmap_fork_to_state(whichfork);
+ 	struct xfs_bmbt_irec	old;
++>>>>>>> 060ea65b3940 (xfs: add a xfs_bmap_fork_to_state helper)
  
  	mp = ip->i_mount;
  	XFS_STATS_INC(mp, xs_del_exlist);
  
++<<<<<<< HEAD
 +	if (whichfork == XFS_ATTR_FORK)
 +		state |= BMAP_ATTRFORK;
 +
++=======
++>>>>>>> 060ea65b3940 (xfs: add a xfs_bmap_fork_to_state helper)
  	ifp = XFS_IFORK_PTR(ip, whichfork);
  	ASSERT((*idx >= 0) && (*idx < xfs_iext_count(ifp)));
  	ASSERT(del->br_blockcount > 0);
diff --cc fs/xfs/libxfs/xfs_bmap.h
index bbb72c6ceb86,612d3c778691..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.h
+++ b/fs/xfs/libxfs/xfs_bmap.h
@@@ -194,13 -240,54 +194,50 @@@ int	xfs_bunmapi(struct xfs_trans *tp, s
  		xfs_fileoff_t bno, xfs_filblks_t len, int flags,
  		xfs_extnum_t nexts, xfs_fsblock_t *firstblock,
  		struct xfs_defer_ops *dfops, int *done);
 -int	xfs_bmap_del_extent_delay(struct xfs_inode *ip, int whichfork,
 -		xfs_extnum_t *idx, struct xfs_bmbt_irec *got,
 -		struct xfs_bmbt_irec *del);
 -void	xfs_bmap_del_extent_cow(struct xfs_inode *ip, xfs_extnum_t *idx,
 -		struct xfs_bmbt_irec *got, struct xfs_bmbt_irec *del);
  uint	xfs_default_attroffset(struct xfs_inode *ip);
  int	xfs_bmap_shift_extents(struct xfs_trans *tp, struct xfs_inode *ip,
 -		xfs_fileoff_t *next_fsb, xfs_fileoff_t offset_shift_fsb,
 -		int *done, xfs_fileoff_t stop_fsb, xfs_fsblock_t *firstblock,
 -		struct xfs_defer_ops *dfops, enum shift_direction direction,
 -		int num_exts);
 -int	xfs_bmap_split_extent(struct xfs_inode *ip, xfs_fileoff_t split_offset);
 -int	xfs_bmapi_reserve_delalloc(struct xfs_inode *ip, int whichfork,
 -		xfs_fileoff_t off, xfs_filblks_t len, xfs_filblks_t prealloc,
 +		xfs_fileoff_t start_fsb, xfs_fileoff_t offset_shift_fsb,
 +		int *done, xfs_fileoff_t *next_fsb, xfs_fsblock_t *firstblock,
 +		struct xfs_defer_ops *dfops, int num_exts);
 +int	xfs_bmapi_reserve_delalloc(struct xfs_inode *ip, xfs_fileoff_t off,
 +		xfs_filblks_t len, xfs_filblks_t prealloc,
  		struct xfs_bmbt_irec *got, xfs_extnum_t *lastx, int eof);
  
++<<<<<<< HEAD
++=======
+ enum xfs_bmap_intent_type {
+ 	XFS_BMAP_MAP = 1,
+ 	XFS_BMAP_UNMAP,
+ };
+ 
+ struct xfs_bmap_intent {
+ 	struct list_head			bi_list;
+ 	enum xfs_bmap_intent_type		bi_type;
+ 	struct xfs_inode			*bi_owner;
+ 	int					bi_whichfork;
+ 	struct xfs_bmbt_irec			bi_bmap;
+ };
+ 
+ int	xfs_bmap_finish_one(struct xfs_trans *tp, struct xfs_defer_ops *dfops,
+ 		struct xfs_inode *ip, enum xfs_bmap_intent_type type,
+ 		int whichfork, xfs_fileoff_t startoff, xfs_fsblock_t startblock,
+ 		xfs_filblks_t *blockcount, xfs_exntst_t state);
+ int	xfs_bmap_map_extent(struct xfs_mount *mp, struct xfs_defer_ops *dfops,
+ 		struct xfs_inode *ip, struct xfs_bmbt_irec *imap);
+ int	xfs_bmap_unmap_extent(struct xfs_mount *mp, struct xfs_defer_ops *dfops,
+ 		struct xfs_inode *ip, struct xfs_bmbt_irec *imap);
+ 
+ static inline int xfs_bmap_fork_to_state(int whichfork)
+ {
+ 	switch (whichfork) {
+ 	case XFS_ATTR_FORK:
+ 		return BMAP_ATTRFORK;
+ 	case XFS_COW_FORK:
+ 		return BMAP_COWFORK;
+ 	default:
+ 		return 0;
+ 	}
+ }
+ 
++>>>>>>> 060ea65b3940 (xfs: add a xfs_bmap_fork_to_state helper)
  #endif	/* __XFS_BMAP_H__ */
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
* Unmerged path fs/xfs/libxfs/xfs_bmap.h
