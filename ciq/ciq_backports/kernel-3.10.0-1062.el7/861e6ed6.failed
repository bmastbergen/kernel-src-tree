EDAC: Drop per-memory controller buses

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [edac] Drop per-memory controller buses (Aristeu Rozanski) [1630288 1641038]
Rebuild_FUZZ: 91.43%
commit-author Borislav Petkov <bp@suse.de>
commit 861e6ed667c83d64a42b0db41a22d6b4de4e913f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/861e6ed6.failed

... and use the single edac_subsys object returned from
subsys_system_register(). The idea is to have a single bus
and multiple devices on it.

	Signed-off-by: Borislav Petkov <bp@suse.de>
	Acked-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
CC: Aristeu Rozanski Filho <arozansk@redhat.com>
CC: Greg KH <gregkh@linuxfoundation.org>
CC: Justin Ernst <justin.ernst@hpe.com>
CC: linux-edac <linux-edac@vger.kernel.org>
CC: Mauro Carvalho Chehab <mchehab@kernel.org>
CC: Russ Anderson <rja@hpe.com>
	Cc: Tony Luck <tony.luck@intel.com>
Link: https://lkml.kernel.org/r/20180926152752.GG5584@zn.tnic
(cherry picked from commit 861e6ed667c83d64a42b0db41a22d6b4de4e913f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/edac_mc.c
#	drivers/edac/edac_mc_sysfs.c
diff --cc drivers/edac/edac_mc.c
index 145f402e59fa,13594ffadcb3..000000000000
--- a/drivers/edac/edac_mc.c
+++ b/drivers/edac/edac_mc.c
@@@ -43,9 -53,66 +43,70 @@@ static LIST_HEAD(mc_devices)
   * Used to lock EDAC MC to just one module, avoiding two drivers e. g.
   *	apei/ghes and i7core_edac to be used at the same time.
   */
 -static const char *edac_mc_owner;
 +static void const *edac_mc_owner;
  
++<<<<<<< HEAD
 +static struct bus_type mc_bus[EDAC_MAX_MCS];
++=======
+ int edac_get_report_status(void)
+ {
+ 	return edac_report;
+ }
+ EXPORT_SYMBOL_GPL(edac_get_report_status);
+ 
+ void edac_set_report_status(int new)
+ {
+ 	if (new == EDAC_REPORTING_ENABLED ||
+ 	    new == EDAC_REPORTING_DISABLED ||
+ 	    new == EDAC_REPORTING_FORCE)
+ 		edac_report = new;
+ }
+ EXPORT_SYMBOL_GPL(edac_set_report_status);
+ 
+ static int edac_report_set(const char *str, const struct kernel_param *kp)
+ {
+ 	if (!str)
+ 		return -EINVAL;
+ 
+ 	if (!strncmp(str, "on", 2))
+ 		edac_report = EDAC_REPORTING_ENABLED;
+ 	else if (!strncmp(str, "off", 3))
+ 		edac_report = EDAC_REPORTING_DISABLED;
+ 	else if (!strncmp(str, "force", 5))
+ 		edac_report = EDAC_REPORTING_FORCE;
+ 
+ 	return 0;
+ }
+ 
+ static int edac_report_get(char *buffer, const struct kernel_param *kp)
+ {
+ 	int ret = 0;
+ 
+ 	switch (edac_report) {
+ 	case EDAC_REPORTING_ENABLED:
+ 		ret = sprintf(buffer, "on");
+ 		break;
+ 	case EDAC_REPORTING_DISABLED:
+ 		ret = sprintf(buffer, "off");
+ 		break;
+ 	case EDAC_REPORTING_FORCE:
+ 		ret = sprintf(buffer, "force");
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static const struct kernel_param_ops edac_report_ops = {
+ 	.set = edac_report_set,
+ 	.get = edac_report_get,
+ };
+ 
+ module_param_cb(edac_report, &edac_report_ops, &edac_report, 0644);
++>>>>>>> 861e6ed667c8 (EDAC: Drop per-memory controller buses)
  
  unsigned edac_dimm_info_location(struct dimm_info *dimm, char *buf,
  			         unsigned len)
diff --cc drivers/edac/edac_mc_sysfs.c
index 674570ede3e6,464174685589..000000000000
--- a/drivers/edac/edac_mc_sysfs.c
+++ b/drivers/edac/edac_mc_sysfs.c
@@@ -964,20 -914,6 +964,23 @@@ int edac_create_sysfs_mci_device(struc
  {
  	int i, err;
  
++<<<<<<< HEAD
 +	/*
 +	 * The memory controller needs its own bus, in order to avoid
 +	 * namespace conflicts at /sys/bus/edac.
 +	 */
 +	mci->bus->name = kasprintf(GFP_KERNEL, "mc%d", mci->mc_idx);
 +	if (!mci->bus->name)
 +		return -ENOMEM;
 +
 +	edac_dbg(0, "creating bus %s\n", mci->bus->name);
 +
 +	err = bus_register(mci->bus);
 +	if (err < 0)
 +		goto fail_free_name;
 +
++=======
++>>>>>>> 861e6ed667c8 (EDAC: Drop per-memory controller buses)
  	/* get the /sys/devices/system/edac subsys reference */
  	mci->dev.type = &mci_attr_type;
  	device_initialize(&mci->dev);
@@@ -1042,10 -976,8 +1045,15 @@@ fail_unregister_dimm
  		device_unregister(&dimm->dev);
  	}
  	device_unregister(&mci->dev);
++<<<<<<< HEAD
 +fail_unregister_bus:
 +	bus_unregister(mci->bus);
 +fail_free_name:
 +	kfree(mci->bus->name);
++=======
+ 
+ out:
++>>>>>>> 861e6ed667c8 (EDAC: Drop per-memory controller buses)
  	return err;
  }
  
@@@ -1078,8 -1010,6 +1086,11 @@@ void edac_unregister_sysfs(struct mem_c
  {
  	edac_dbg(1, "Unregistering device %s\n", dev_name(&mci->dev));
  	device_unregister(&mci->dev);
++<<<<<<< HEAD
 +	bus_unregister(mci->bus);
 +	kfree(mci->bus->name);
++=======
++>>>>>>> 861e6ed667c8 (EDAC: Drop per-memory controller buses)
  }
  
  static void mc_attr_release(struct device *dev)
* Unmerged path drivers/edac/edac_mc.c
* Unmerged path drivers/edac/edac_mc_sysfs.c
diff --git a/include/linux/edac.h b/include/linux/edac.h
index fa0de0fb32b1..b313cd58263c 100644
--- a/include/linux/edac.h
+++ b/include/linux/edac.h
@@ -794,10 +794,4 @@ struct mem_ctl_info {
 	u16 fake_inject_count;
 #endif
 };
-
-/*
- * Maximum number of memory controllers in the coherent fabric.
- */
-#define EDAC_MAX_MCS	2 * MAX_NUMNODES
-
 #endif
