net: remove unnecessary genlmsg_cancel() calls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [net] remove unnecessary genlmsg_cancel() calls (Petr Oros) [1657816]
Rebuild_FUZZ: 94.25%
commit-author YueHaibing <yuehaibing@huawei.com>
commit c1c9a3c9663b2e15176758626278792862f1ed32
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c1c9a3c9.failed

the message be freed immediately, no need to trim it
back to the previous size.

Inspired by commit 7a9b3ec1e19f ("nl80211: remove unnecessary genlmsg_cancel() calls")

	Signed-off-by: YueHaibing <yuehaibing@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c1c9a3c9663b2e15176758626278792862f1ed32)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/seg6.c
#	net/ncsi/ncsi-netlink.c
#	net/nfc/netlink.c
diff --cc net/nfc/netlink.c
index 580226abc2ad,376181cc1def..000000000000
--- a/net/nfc/netlink.c
+++ b/net/nfc/netlink.c
@@@ -191,10 -203,9 +191,9 @@@ int nfc_genl_targets_found(struct nfc_d
  
  	genlmsg_end(msg, hdr);
  
 -	return genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);
 +	return genlmsg_multicast(msg, 0, nfc_genl_event_mcgrp.id, GFP_ATOMIC);
  
  nla_put_failure:
- 	genlmsg_cancel(msg, hdr);
  free_msg:
  	nlmsg_free(msg);
  	return -EMSGSIZE;
@@@ -411,11 -425,9 +405,9 @@@ int nfc_genl_llc_send_sdres(struct nfc_
  
  	genlmsg_end(msg, hdr);
  
 -	return genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);
 +	return genlmsg_multicast(msg, 0, nfc_genl_event_mcgrp.id, GFP_ATOMIC);
  
  nla_put_failure:
- 	genlmsg_cancel(msg, hdr);
- 
  free_msg:
  	nlmsg_free(msg);
  
@@@ -424,6 -436,149 +416,152 @@@
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ int nfc_genl_se_added(struct nfc_dev *dev, u32 se_idx, u16 type)
+ {
+ 	struct sk_buff *msg;
+ 	void *hdr;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg)
+ 		return -ENOMEM;
+ 
+ 	hdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,
+ 			  NFC_EVENT_SE_ADDED);
+ 	if (!hdr)
+ 		goto free_msg;
+ 
+ 	if (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||
+ 	    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||
+ 	    nla_put_u8(msg, NFC_ATTR_SE_TYPE, type))
+ 		goto nla_put_failure;
+ 
+ 	genlmsg_end(msg, hdr);
+ 
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ free_msg:
+ 	nlmsg_free(msg);
+ 	return -EMSGSIZE;
+ }
+ 
+ int nfc_genl_se_removed(struct nfc_dev *dev, u32 se_idx)
+ {
+ 	struct sk_buff *msg;
+ 	void *hdr;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg)
+ 		return -ENOMEM;
+ 
+ 	hdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,
+ 			  NFC_EVENT_SE_REMOVED);
+ 	if (!hdr)
+ 		goto free_msg;
+ 
+ 	if (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||
+ 	    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx))
+ 		goto nla_put_failure;
+ 
+ 	genlmsg_end(msg, hdr);
+ 
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ free_msg:
+ 	nlmsg_free(msg);
+ 	return -EMSGSIZE;
+ }
+ 
+ int nfc_genl_se_transaction(struct nfc_dev *dev, u8 se_idx,
+ 			    struct nfc_evt_transaction *evt_transaction)
+ {
+ 	struct nfc_se *se;
+ 	struct sk_buff *msg;
+ 	void *hdr;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg)
+ 		return -ENOMEM;
+ 
+ 	hdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,
+ 			  NFC_EVENT_SE_TRANSACTION);
+ 	if (!hdr)
+ 		goto free_msg;
+ 
+ 	se = nfc_find_se(dev, se_idx);
+ 	if (!se)
+ 		goto free_msg;
+ 
+ 	if (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||
+ 	    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||
+ 	    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type) ||
+ 	    nla_put(msg, NFC_ATTR_SE_AID, evt_transaction->aid_len,
+ 		    evt_transaction->aid) ||
+ 	    nla_put(msg, NFC_ATTR_SE_PARAMS, evt_transaction->params_len,
+ 		    evt_transaction->params))
+ 		goto nla_put_failure;
+ 
+ 	/* evt_transaction is no more used */
+ 	devm_kfree(&dev->dev, evt_transaction);
+ 
+ 	genlmsg_end(msg, hdr);
+ 
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ free_msg:
+ 	/* evt_transaction is no more used */
+ 	devm_kfree(&dev->dev, evt_transaction);
+ 	nlmsg_free(msg);
+ 	return -EMSGSIZE;
+ }
+ 
+ int nfc_genl_se_connectivity(struct nfc_dev *dev, u8 se_idx)
+ {
+ 	struct nfc_se *se;
+ 	struct sk_buff *msg;
+ 	void *hdr;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg)
+ 		return -ENOMEM;
+ 
+ 	hdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,
+ 			  NFC_EVENT_SE_CONNECTIVITY);
+ 	if (!hdr)
+ 		goto free_msg;
+ 
+ 	se = nfc_find_se(dev, se_idx);
+ 	if (!se)
+ 		goto free_msg;
+ 
+ 	if (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||
+ 	    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||
+ 	    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type))
+ 		goto nla_put_failure;
+ 
+ 	genlmsg_end(msg, hdr);
+ 
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ free_msg:
+ 	nlmsg_free(msg);
+ 	return -EMSGSIZE;
+ }
+ 
++>>>>>>> c1c9a3c9663b (net: remove unnecessary genlmsg_cancel() calls)
  static int nfc_genl_send_device(struct sk_buff *msg, struct nfc_dev *dev,
  				u32 portid, u32 seq,
  				struct netlink_callback *cb,
@@@ -1027,7 -1223,448 +1162,452 @@@ exit
  	return rc;
  }
  
++<<<<<<< HEAD
 +static struct genl_ops nfc_genl_ops[] = {
++=======
+ static int nfc_genl_fw_download(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	struct nfc_dev *dev;
+ 	int rc;
+ 	u32 idx;
+ 	char firmware_name[NFC_FIRMWARE_NAME_MAXSIZE + 1];
+ 
+ 	if (!info->attrs[NFC_ATTR_DEVICE_INDEX])
+ 		return -EINVAL;
+ 
+ 	idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);
+ 
+ 	dev = nfc_get_device(idx);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	nla_strlcpy(firmware_name, info->attrs[NFC_ATTR_FIRMWARE_NAME],
+ 		    sizeof(firmware_name));
+ 
+ 	rc = nfc_fw_download(dev, firmware_name);
+ 
+ 	nfc_put_device(dev);
+ 	return rc;
+ }
+ 
+ int nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,
+ 			      u32 result)
+ {
+ 	struct sk_buff *msg;
+ 	void *hdr;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg)
+ 		return -ENOMEM;
+ 
+ 	hdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,
+ 			  NFC_CMD_FW_DOWNLOAD);
+ 	if (!hdr)
+ 		goto free_msg;
+ 
+ 	if (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||
+ 	    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||
+ 	    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))
+ 		goto nla_put_failure;
+ 
+ 	genlmsg_end(msg, hdr);
+ 
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ free_msg:
+ 	nlmsg_free(msg);
+ 	return -EMSGSIZE;
+ }
+ 
+ static int nfc_genl_enable_se(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	struct nfc_dev *dev;
+ 	int rc;
+ 	u32 idx, se_idx;
+ 
+ 	if (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||
+ 	    !info->attrs[NFC_ATTR_SE_INDEX])
+ 		return -EINVAL;
+ 
+ 	idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);
+ 	se_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);
+ 
+ 	dev = nfc_get_device(idx);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	rc = nfc_enable_se(dev, se_idx);
+ 
+ 	nfc_put_device(dev);
+ 	return rc;
+ }
+ 
+ static int nfc_genl_disable_se(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	struct nfc_dev *dev;
+ 	int rc;
+ 	u32 idx, se_idx;
+ 
+ 	if (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||
+ 	    !info->attrs[NFC_ATTR_SE_INDEX])
+ 		return -EINVAL;
+ 
+ 	idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);
+ 	se_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);
+ 
+ 	dev = nfc_get_device(idx);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	rc = nfc_disable_se(dev, se_idx);
+ 
+ 	nfc_put_device(dev);
+ 	return rc;
+ }
+ 
+ static int nfc_genl_send_se(struct sk_buff *msg, struct nfc_dev *dev,
+ 				u32 portid, u32 seq,
+ 				struct netlink_callback *cb,
+ 				int flags)
+ {
+ 	void *hdr;
+ 	struct nfc_se *se, *n;
+ 
+ 	list_for_each_entry_safe(se, n, &dev->secure_elements, list) {
+ 		hdr = genlmsg_put(msg, portid, seq, &nfc_genl_family, flags,
+ 				  NFC_CMD_GET_SE);
+ 		if (!hdr)
+ 			goto nla_put_failure;
+ 
+ 		if (cb)
+ 			genl_dump_check_consistent(cb, hdr);
+ 
+ 		if (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||
+ 		    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se->idx) ||
+ 		    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type))
+ 			goto nla_put_failure;
+ 
+ 		genlmsg_end(msg, hdr);
+ 	}
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ 	genlmsg_cancel(msg, hdr);
+ 	return -EMSGSIZE;
+ }
+ 
+ static int nfc_genl_dump_ses(struct sk_buff *skb,
+ 				 struct netlink_callback *cb)
+ {
+ 	struct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];
+ 	struct nfc_dev *dev = (struct nfc_dev *) cb->args[1];
+ 	bool first_call = false;
+ 
+ 	if (!iter) {
+ 		first_call = true;
+ 		iter = kmalloc(sizeof(struct class_dev_iter), GFP_KERNEL);
+ 		if (!iter)
+ 			return -ENOMEM;
+ 		cb->args[0] = (long) iter;
+ 	}
+ 
+ 	mutex_lock(&nfc_devlist_mutex);
+ 
+ 	cb->seq = nfc_devlist_generation;
+ 
+ 	if (first_call) {
+ 		nfc_device_iter_init(iter);
+ 		dev = nfc_device_iter_next(iter);
+ 	}
+ 
+ 	while (dev) {
+ 		int rc;
+ 
+ 		rc = nfc_genl_send_se(skb, dev, NETLINK_CB(cb->skb).portid,
+ 					  cb->nlh->nlmsg_seq, cb, NLM_F_MULTI);
+ 		if (rc < 0)
+ 			break;
+ 
+ 		dev = nfc_device_iter_next(iter);
+ 	}
+ 
+ 	mutex_unlock(&nfc_devlist_mutex);
+ 
+ 	cb->args[1] = (long) dev;
+ 
+ 	return skb->len;
+ }
+ 
+ static int nfc_genl_dump_ses_done(struct netlink_callback *cb)
+ {
+ 	struct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];
+ 
+ 	nfc_device_iter_exit(iter);
+ 	kfree(iter);
+ 
+ 	return 0;
+ }
+ 
+ static int nfc_se_io(struct nfc_dev *dev, u32 se_idx,
+ 		     u8 *apdu, size_t apdu_length,
+ 		     se_io_cb_t cb, void *cb_context)
+ {
+ 	struct nfc_se *se;
+ 	int rc;
+ 
+ 	pr_debug("%s se index %d\n", dev_name(&dev->dev), se_idx);
+ 
+ 	device_lock(&dev->dev);
+ 
+ 	if (!device_is_registered(&dev->dev)) {
+ 		rc = -ENODEV;
+ 		goto error;
+ 	}
+ 
+ 	if (!dev->dev_up) {
+ 		rc = -ENODEV;
+ 		goto error;
+ 	}
+ 
+ 	if (!dev->ops->se_io) {
+ 		rc = -EOPNOTSUPP;
+ 		goto error;
+ 	}
+ 
+ 	se = nfc_find_se(dev, se_idx);
+ 	if (!se) {
+ 		rc = -EINVAL;
+ 		goto error;
+ 	}
+ 
+ 	if (se->state != NFC_SE_ENABLED) {
+ 		rc = -ENODEV;
+ 		goto error;
+ 	}
+ 
+ 	rc = dev->ops->se_io(dev, se_idx, apdu,
+ 			apdu_length, cb, cb_context);
+ 
+ error:
+ 	device_unlock(&dev->dev);
+ 	return rc;
+ }
+ 
+ struct se_io_ctx {
+ 	u32 dev_idx;
+ 	u32 se_idx;
+ };
+ 
+ static void se_io_cb(void *context, u8 *apdu, size_t apdu_len, int err)
+ {
+ 	struct se_io_ctx *ctx = context;
+ 	struct sk_buff *msg;
+ 	void *hdr;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg) {
+ 		kfree(ctx);
+ 		return;
+ 	}
+ 
+ 	hdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,
+ 			  NFC_CMD_SE_IO);
+ 	if (!hdr)
+ 		goto free_msg;
+ 
+ 	if (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, ctx->dev_idx) ||
+ 	    nla_put_u32(msg, NFC_ATTR_SE_INDEX, ctx->se_idx) ||
+ 	    nla_put(msg, NFC_ATTR_SE_APDU, apdu_len, apdu))
+ 		goto nla_put_failure;
+ 
+ 	genlmsg_end(msg, hdr);
+ 
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);
+ 
+ 	kfree(ctx);
+ 
+ 	return;
+ 
+ nla_put_failure:
+ free_msg:
+ 	nlmsg_free(msg);
+ 	kfree(ctx);
+ 
+ 	return;
+ }
+ 
+ static int nfc_genl_se_io(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	struct nfc_dev *dev;
+ 	struct se_io_ctx *ctx;
+ 	u32 dev_idx, se_idx;
+ 	u8 *apdu;
+ 	size_t apdu_len;
+ 
+ 	if (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||
+ 	    !info->attrs[NFC_ATTR_SE_INDEX] ||
+ 	    !info->attrs[NFC_ATTR_SE_APDU])
+ 		return -EINVAL;
+ 
+ 	dev_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);
+ 	se_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);
+ 
+ 	dev = nfc_get_device(dev_idx);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	if (!dev->ops || !dev->ops->se_io)
+ 		return -ENOTSUPP;
+ 
+ 	apdu_len = nla_len(info->attrs[NFC_ATTR_SE_APDU]);
+ 	if (apdu_len == 0)
+ 		return -EINVAL;
+ 
+ 	apdu = nla_data(info->attrs[NFC_ATTR_SE_APDU]);
+ 	if (!apdu)
+ 		return -EINVAL;
+ 
+ 	ctx = kzalloc(sizeof(struct se_io_ctx), GFP_KERNEL);
+ 	if (!ctx)
+ 		return -ENOMEM;
+ 
+ 	ctx->dev_idx = dev_idx;
+ 	ctx->se_idx = se_idx;
+ 
+ 	return nfc_se_io(dev, se_idx, apdu, apdu_len, se_io_cb, ctx);
+ }
+ 
+ static int nfc_genl_vendor_cmd(struct sk_buff *skb,
+ 			       struct genl_info *info)
+ {
+ 	struct nfc_dev *dev;
+ 	struct nfc_vendor_cmd *cmd;
+ 	u32 dev_idx, vid, subcmd;
+ 	u8 *data;
+ 	size_t data_len;
+ 	int i, err;
+ 
+ 	if (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||
+ 	    !info->attrs[NFC_ATTR_VENDOR_ID] ||
+ 	    !info->attrs[NFC_ATTR_VENDOR_SUBCMD])
+ 		return -EINVAL;
+ 
+ 	dev_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);
+ 	vid = nla_get_u32(info->attrs[NFC_ATTR_VENDOR_ID]);
+ 	subcmd = nla_get_u32(info->attrs[NFC_ATTR_VENDOR_SUBCMD]);
+ 
+ 	dev = nfc_get_device(dev_idx);
+ 	if (!dev || !dev->vendor_cmds || !dev->n_vendor_cmds)
+ 		return -ENODEV;
+ 
+ 	if (info->attrs[NFC_ATTR_VENDOR_DATA]) {
+ 		data = nla_data(info->attrs[NFC_ATTR_VENDOR_DATA]);
+ 		data_len = nla_len(info->attrs[NFC_ATTR_VENDOR_DATA]);
+ 		if (data_len == 0)
+ 			return -EINVAL;
+ 	} else {
+ 		data = NULL;
+ 		data_len = 0;
+ 	}
+ 
+ 	for (i = 0; i < dev->n_vendor_cmds; i++) {
+ 		cmd = &dev->vendor_cmds[i];
+ 
+ 		if (cmd->vendor_id != vid || cmd->subcmd != subcmd)
+ 			continue;
+ 
+ 		dev->cur_cmd_info = info;
+ 		err = cmd->doit(dev, data, data_len);
+ 		dev->cur_cmd_info = NULL;
+ 		return err;
+ 	}
+ 
+ 	return -EOPNOTSUPP;
+ }
+ 
+ /* message building helper */
+ static inline void *nfc_hdr_put(struct sk_buff *skb, u32 portid, u32 seq,
+ 				int flags, u8 cmd)
+ {
+ 	/* since there is no private header just add the generic one */
+ 	return genlmsg_put(skb, portid, seq, &nfc_genl_family, flags, cmd);
+ }
+ 
+ static struct sk_buff *
+ __nfc_alloc_vendor_cmd_skb(struct nfc_dev *dev, int approxlen,
+ 			   u32 portid, u32 seq,
+ 			   enum nfc_attrs attr,
+ 			   u32 oui, u32 subcmd, gfp_t gfp)
+ {
+ 	struct sk_buff *skb;
+ 	void *hdr;
+ 
+ 	skb = nlmsg_new(approxlen + 100, gfp);
+ 	if (!skb)
+ 		return NULL;
+ 
+ 	hdr = nfc_hdr_put(skb, portid, seq, 0, NFC_CMD_VENDOR);
+ 	if (!hdr) {
+ 		kfree_skb(skb);
+ 		return NULL;
+ 	}
+ 
+ 	if (nla_put_u32(skb, NFC_ATTR_DEVICE_INDEX, dev->idx))
+ 		goto nla_put_failure;
+ 	if (nla_put_u32(skb, NFC_ATTR_VENDOR_ID, oui))
+ 		goto nla_put_failure;
+ 	if (nla_put_u32(skb, NFC_ATTR_VENDOR_SUBCMD, subcmd))
+ 		goto nla_put_failure;
+ 
+ 	((void **)skb->cb)[0] = dev;
+ 	((void **)skb->cb)[1] = hdr;
+ 
+ 	return skb;
+ 
+ nla_put_failure:
+ 	kfree_skb(skb);
+ 	return NULL;
+ }
+ 
+ struct sk_buff *__nfc_alloc_vendor_cmd_reply_skb(struct nfc_dev *dev,
+ 						 enum nfc_attrs attr,
+ 						 u32 oui, u32 subcmd,
+ 						 int approxlen)
+ {
+ 	if (WARN_ON(!dev->cur_cmd_info))
+ 		return NULL;
+ 
+ 	return __nfc_alloc_vendor_cmd_skb(dev, approxlen,
+ 					  dev->cur_cmd_info->snd_portid,
+ 					  dev->cur_cmd_info->snd_seq, attr,
+ 					  oui, subcmd, GFP_KERNEL);
+ }
+ EXPORT_SYMBOL(__nfc_alloc_vendor_cmd_reply_skb);
+ 
+ int nfc_vendor_cmd_reply(struct sk_buff *skb)
+ {
+ 	struct nfc_dev *dev = ((void **)skb->cb)[0];
+ 	void *hdr = ((void **)skb->cb)[1];
+ 
+ 	/* clear CB data for netlink core to own from now on */
+ 	memset(skb->cb, 0, sizeof(skb->cb));
+ 
+ 	if (WARN_ON(!dev->cur_cmd_info)) {
+ 		kfree_skb(skb);
+ 		return -EINVAL;
+ 	}
+ 
+ 	genlmsg_end(skb, hdr);
+ 	return genlmsg_reply(skb, dev->cur_cmd_info);
+ }
+ EXPORT_SYMBOL(nfc_vendor_cmd_reply);
+ 
+ static const struct genl_ops nfc_genl_ops[] = {
++>>>>>>> c1c9a3c9663b (net: remove unnecessary genlmsg_cancel() calls)
  	{
  		.cmd = NFC_CMD_GET_DEVICE,
  		.doit = nfc_genl_get_device,
* Unmerged path net/ipv6/seg6.c
* Unmerged path net/ncsi/ncsi-netlink.c
diff --git a/drivers/net/team/team.c b/drivers/net/team/team.c
index 43766247fcd0..b274d8c1bf1e 100644
--- a/drivers/net/team/team.c
+++ b/drivers/net/team/team.c
@@ -2410,7 +2410,6 @@ send_done:
 nla_put_failure:
 	err = -EMSGSIZE;
 errout:
-	genlmsg_cancel(skb, hdr);
 	nlmsg_free(skb);
 	return err;
 }
@@ -2695,7 +2694,6 @@ send_done:
 nla_put_failure:
 	err = -EMSGSIZE;
 errout:
-	genlmsg_cancel(skb, hdr);
 	nlmsg_free(skb);
 	return err;
 }
diff --git a/drivers/net/wireless/mac80211_hwsim.c b/drivers/net/wireless/mac80211_hwsim.c
index 7778a708ddb6..9d30e944a8ca 100644
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@ -2452,7 +2452,6 @@ static void hwsim_mcast_new_radio(int id, struct genl_info *info,
 	return;
 
 out_err:
-	genlmsg_cancel(mcast_skb, data);
 	nlmsg_free(mcast_skb);
 }
 
diff --git a/net/core/devlink.c b/net/core/devlink.c
index 6559946a1bb7..4250fb3bf636 100644
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@ -1825,7 +1825,6 @@ send_done:
 nla_put_failure:
 	err = -EMSGSIZE;
 err_table_put:
-	genlmsg_cancel(skb, hdr);
 	nlmsg_free(skb);
 	return err;
 }
@@ -2031,7 +2030,6 @@ int devlink_dpipe_entry_ctx_prepare(struct devlink_dpipe_dump_ctx *dump_ctx)
 	return 0;
 
 nla_put_failure:
-	genlmsg_cancel(dump_ctx->skb, dump_ctx->hdr);
 	nlmsg_free(dump_ctx->skb);
 	return -EMSGSIZE;
 }
@@ -2248,7 +2246,6 @@ send_done:
 nla_put_failure:
 	err = -EMSGSIZE;
 err_table_put:
-	genlmsg_cancel(skb, hdr);
 	nlmsg_free(skb);
 	return err;
 }
@@ -2546,7 +2543,6 @@ nla_put_failure:
 	err = -EMSGSIZE;
 err_resource_put:
 err_skb_send_alloc:
-	genlmsg_cancel(skb, hdr);
 	nlmsg_free(skb);
 	return err;
 }
* Unmerged path net/ipv6/seg6.c
* Unmerged path net/ncsi/ncsi-netlink.c
* Unmerged path net/nfc/netlink.c
