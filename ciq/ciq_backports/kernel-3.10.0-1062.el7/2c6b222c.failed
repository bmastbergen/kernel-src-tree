media: uvcvideo: Use internal kernel integer types

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [media] uvcvideo: Use internal kernel integer types (Torez Smith) [1657401]
Rebuild_FUZZ: 92.47%
commit-author Laurent Pinchart <laurent.pinchart@ideasonboard.com>
commit 2c6b222cee2d68e30f059b8ca9194532416bb3f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/2c6b222c.failed

Replace the __[su]{8,16,32} variant of integer types with the
non-underscored types as the code is internal to the driver, not exposed
to userspace.

	Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
(cherry picked from commit 2c6b222cee2d68e30f059b8ca9194532416bb3f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/usb/uvc/uvc_ctrl.c
#	drivers/media/usb/uvc/uvc_v4l2.c
#	drivers/media/usb/uvc/uvc_video.c
#	drivers/media/usb/uvc/uvcvideo.h
diff --cc drivers/media/usb/uvc/uvc_ctrl.c
index 9f38ad9607e7,723c517474fc..000000000000
--- a/drivers/media/usb/uvc/uvc_ctrl.c
+++ b/drivers/media/usb/uvc/uvc_ctrl.c
@@@ -391,6 -391,35 +391,38 @@@ static void uvc_ctrl_set_zoom(struct uv
  	data[2] = min((int)abs(value), 0xff);
  }
  
++<<<<<<< HEAD
++=======
+ static s32 uvc_ctrl_get_rel_speed(struct uvc_control_mapping *mapping,
+ 	u8 query, const u8 *data)
+ {
+ 	unsigned int first = mapping->offset / 8;
+ 	s8 rel = (s8)data[first];
+ 
+ 	switch (query) {
+ 	case UVC_GET_CUR:
+ 		return (rel == 0) ? 0 : (rel > 0 ? data[first+1]
+ 						 : -data[first+1]);
+ 	case UVC_GET_MIN:
+ 		return -data[first+1];
+ 	case UVC_GET_MAX:
+ 	case UVC_GET_RES:
+ 	case UVC_GET_DEF:
+ 	default:
+ 		return data[first+1];
+ 	}
+ }
+ 
+ static void uvc_ctrl_set_rel_speed(struct uvc_control_mapping *mapping,
+ 	s32 value, u8 *data)
+ {
+ 	unsigned int first = mapping->offset / 8;
+ 
+ 	data[first] = value == 0 ? 0 : (value > 0) ? 1 : 0xff;
+ 	data[first+1] = min_t(int, abs(value), 0xff);
+ }
+ 
++>>>>>>> 2c6b222cee2d (media: uvcvideo: Use internal kernel integer types)
  static struct uvc_control_mapping uvc_ctrl_mappings[] = {
  	{
  		.id		= V4L2_CID_BRIGHTNESS,
diff --cc drivers/media/usb/uvc/uvc_v4l2.c
index 140b28bb3f09,5e1bfdc5b829..000000000000
--- a/drivers/media/usb/uvc/uvc_v4l2.c
+++ b/drivers/media/usb/uvc/uvc_v4l2.c
@@@ -143,6 -137,21 +143,24 @@@ static u32 uvc_try_frame_interval(struc
  	return interval;
  }
  
++<<<<<<< HEAD
++=======
+ static u32 uvc_v4l2_get_bytesperline(const struct uvc_format *format,
+ 	const struct uvc_frame *frame)
+ {
+ 	switch (format->fcc) {
+ 	case V4L2_PIX_FMT_NV12:
+ 	case V4L2_PIX_FMT_YVU420:
+ 	case V4L2_PIX_FMT_YUV420:
+ 	case V4L2_PIX_FMT_M420:
+ 		return frame->wWidth;
+ 
+ 	default:
+ 		return format->bpp * frame->wWidth / 8;
+ 	}
+ }
+ 
++>>>>>>> 2c6b222cee2d (media: uvcvideo: Use internal kernel integer types)
  static int uvc_v4l2_try_format(struct uvc_streaming *stream,
  	struct v4l2_format *fmt, struct uvc_streaming_control *probe,
  	struct uvc_format **uvc_format, struct uvc_frame **uvc_frame)
@@@ -364,7 -373,10 +382,14 @@@ static int uvc_v4l2_set_streamparm(stru
  {
  	struct uvc_streaming_control probe;
  	struct v4l2_fract timeperframe;
++<<<<<<< HEAD
 +	uint32_t interval;
++=======
+ 	struct uvc_format *format;
+ 	struct uvc_frame *frame;
+ 	u32 interval, maxd;
+ 	unsigned int i;
++>>>>>>> 2c6b222cee2d (media: uvcvideo: Use internal kernel integer types)
  	int ret;
  
  	if (parm->type != stream->type)
@@@ -387,9 -399,33 +412,36 @@@
  		return -EBUSY;
  	}
  
 -	format = stream->cur_format;
 -	frame = stream->cur_frame;
  	probe = stream->ctrl;
++<<<<<<< HEAD
 +	probe.dwFrameInterval =
 +		uvc_try_frame_interval(stream->cur_frame, interval);
++=======
+ 	probe.dwFrameInterval = uvc_try_frame_interval(frame, interval);
+ 	maxd = abs((s32)probe.dwFrameInterval - interval);
+ 
+ 	/* Try frames with matching size to find the best frame interval. */
+ 	for (i = 0; i < format->nframes && maxd != 0; i++) {
+ 		u32 d, ival;
+ 
+ 		if (&format->frame[i] == stream->cur_frame)
+ 			continue;
+ 
+ 		if (format->frame[i].wWidth != stream->cur_frame->wWidth ||
+ 		    format->frame[i].wHeight != stream->cur_frame->wHeight)
+ 			continue;
+ 
+ 		ival = uvc_try_frame_interval(&format->frame[i], interval);
+ 		d = abs((s32)ival - interval);
+ 		if (d >= maxd)
+ 			continue;
+ 
+ 		frame = &format->frame[i];
+ 		probe.bFrameIndex = frame->bFrameIndex;
+ 		probe.dwFrameInterval = ival;
+ 		maxd = d;
+ 	}
++>>>>>>> 2c6b222cee2d (media: uvcvideo: Use internal kernel integer types)
  
  	/* Probe the device with the new settings. */
  	ret = uvc_probe_video(stream, &probe);
@@@ -551,537 -590,703 +603,795 @@@ static long uvc_v4l2_do_ioctl(struct fi
  	struct uvc_fh *handle = file->private_data;
  	struct uvc_video_chain *chain = handle->chain;
  	struct uvc_streaming *stream = handle->stream;
 +	long ret = 0;
  
 -	strlcpy(cap->driver, "uvcvideo", sizeof(cap->driver));
 -	strlcpy(cap->card, vdev->name, sizeof(cap->card));
 -	usb_make_path(stream->dev->udev, cap->bus_info, sizeof(cap->bus_info));
 -	cap->capabilities = V4L2_CAP_DEVICE_CAPS | V4L2_CAP_STREAMING
 -			  | chain->caps;
 -
 +	switch (cmd) {
 +	/* Query capabilities */
 +	case VIDIOC_QUERYCAP:
 +	{
 +		struct v4l2_capability *cap = arg;
 +
++<<<<<<< HEAD
 +		memset(cap, 0, sizeof *cap);
 +		strlcpy(cap->driver, "uvcvideo", sizeof cap->driver);
 +		strlcpy(cap->card, vdev->name, sizeof cap->card);
 +		usb_make_path(stream->dev->udev,
 +			      cap->bus_info, sizeof(cap->bus_info));
 +		cap->version = LINUX_VERSION_CODE;
 +		cap->capabilities = V4L2_CAP_DEVICE_CAPS | V4L2_CAP_STREAMING
 +				  | chain->caps;
 +		if (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
 +			cap->device_caps = V4L2_CAP_VIDEO_CAPTURE
 +					 | V4L2_CAP_STREAMING;
 +		else
 +			cap->device_caps = V4L2_CAP_VIDEO_OUTPUT
 +					 | V4L2_CAP_STREAMING;
 +		break;
++=======
+ 	return 0;
+ }
+ 
+ static int uvc_ioctl_enum_fmt(struct uvc_streaming *stream,
+ 			      struct v4l2_fmtdesc *fmt)
+ {
+ 	struct uvc_format *format;
+ 	enum v4l2_buf_type type = fmt->type;
+ 	u32 index = fmt->index;
+ 
+ 	if (fmt->type != stream->type || fmt->index >= stream->nformats)
+ 		return -EINVAL;
+ 
+ 	memset(fmt, 0, sizeof(*fmt));
+ 	fmt->index = index;
+ 	fmt->type = type;
+ 
+ 	format = &stream->format[fmt->index];
+ 	fmt->flags = 0;
+ 	if (format->flags & UVC_FMT_FLAG_COMPRESSED)
+ 		fmt->flags |= V4L2_FMT_FLAG_COMPRESSED;
+ 	strlcpy(fmt->description, format->name, sizeof(fmt->description));
+ 	fmt->description[sizeof(fmt->description) - 1] = 0;
+ 	fmt->pixelformat = format->fcc;
+ 	return 0;
+ }
+ 
+ static int uvc_ioctl_enum_fmt_vid_cap(struct file *file, void *fh,
+ 				      struct v4l2_fmtdesc *fmt)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_streaming *stream = handle->stream;
+ 
+ 	return uvc_ioctl_enum_fmt(stream, fmt);
+ }
+ 
+ static int uvc_ioctl_enum_fmt_vid_out(struct file *file, void *fh,
+ 				      struct v4l2_fmtdesc *fmt)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_streaming *stream = handle->stream;
+ 
+ 	return uvc_ioctl_enum_fmt(stream, fmt);
+ }
+ 
+ static int uvc_ioctl_g_fmt_vid_cap(struct file *file, void *fh,
+ 				   struct v4l2_format *fmt)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_streaming *stream = handle->stream;
+ 
+ 	return uvc_v4l2_get_format(stream, fmt);
+ }
+ 
+ static int uvc_ioctl_g_fmt_vid_out(struct file *file, void *fh,
+ 				   struct v4l2_format *fmt)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_streaming *stream = handle->stream;
+ 
+ 	return uvc_v4l2_get_format(stream, fmt);
+ }
+ 
+ static int uvc_ioctl_s_fmt_vid_cap(struct file *file, void *fh,
+ 				   struct v4l2_format *fmt)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_streaming *stream = handle->stream;
+ 	int ret;
+ 
+ 	ret = uvc_acquire_privileges(handle);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return uvc_v4l2_set_format(stream, fmt);
+ }
+ 
+ static int uvc_ioctl_s_fmt_vid_out(struct file *file, void *fh,
+ 				   struct v4l2_format *fmt)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_streaming *stream = handle->stream;
+ 	int ret;
+ 
+ 	ret = uvc_acquire_privileges(handle);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return uvc_v4l2_set_format(stream, fmt);
+ }
+ 
+ static int uvc_ioctl_try_fmt_vid_cap(struct file *file, void *fh,
+ 				     struct v4l2_format *fmt)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_streaming *stream = handle->stream;
+ 	struct uvc_streaming_control probe;
+ 
+ 	return uvc_v4l2_try_format(stream, fmt, &probe, NULL, NULL);
+ }
+ 
+ static int uvc_ioctl_try_fmt_vid_out(struct file *file, void *fh,
+ 				     struct v4l2_format *fmt)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_streaming *stream = handle->stream;
+ 	struct uvc_streaming_control probe;
+ 
+ 	return uvc_v4l2_try_format(stream, fmt, &probe, NULL, NULL);
+ }
+ 
+ static int uvc_ioctl_reqbufs(struct file *file, void *fh,
+ 			     struct v4l2_requestbuffers *rb)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_streaming *stream = handle->stream;
+ 	int ret;
+ 
+ 	ret = uvc_acquire_privileges(handle);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	mutex_lock(&stream->mutex);
+ 	ret = uvc_request_buffers(&stream->queue, rb);
+ 	mutex_unlock(&stream->mutex);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	if (ret == 0)
+ 		uvc_dismiss_privileges(handle);
+ 
+ 	return 0;
+ }
+ 
+ static int uvc_ioctl_querybuf(struct file *file, void *fh,
+ 			      struct v4l2_buffer *buf)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_streaming *stream = handle->stream;
+ 
+ 	if (!uvc_has_privileges(handle))
+ 		return -EBUSY;
+ 
+ 	return uvc_query_buffer(&stream->queue, buf);
+ }
+ 
+ static int uvc_ioctl_qbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_streaming *stream = handle->stream;
+ 
+ 	if (!uvc_has_privileges(handle))
+ 		return -EBUSY;
+ 
+ 	return uvc_queue_buffer(&stream->queue, buf);
+ }
+ 
+ static int uvc_ioctl_expbuf(struct file *file, void *fh,
+ 			    struct v4l2_exportbuffer *exp)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_streaming *stream = handle->stream;
+ 
+ 	if (!uvc_has_privileges(handle))
+ 		return -EBUSY;
+ 
+ 	return uvc_export_buffer(&stream->queue, exp);
+ }
+ 
+ static int uvc_ioctl_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_streaming *stream = handle->stream;
+ 
+ 	if (!uvc_has_privileges(handle))
+ 		return -EBUSY;
+ 
+ 	return uvc_dequeue_buffer(&stream->queue, buf,
+ 				  file->f_flags & O_NONBLOCK);
+ }
+ 
+ static int uvc_ioctl_create_bufs(struct file *file, void *fh,
+ 				  struct v4l2_create_buffers *cb)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_streaming *stream = handle->stream;
+ 	int ret;
+ 
+ 	ret = uvc_acquire_privileges(handle);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return uvc_create_buffers(&stream->queue, cb);
+ }
+ 
+ static int uvc_ioctl_streamon(struct file *file, void *fh,
+ 			      enum v4l2_buf_type type)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_streaming *stream = handle->stream;
+ 	int ret;
+ 
+ 	if (!uvc_has_privileges(handle))
+ 		return -EBUSY;
+ 
+ 	mutex_lock(&stream->mutex);
+ 	ret = uvc_queue_streamon(&stream->queue, type);
+ 	mutex_unlock(&stream->mutex);
+ 
+ 	return ret;
+ }
+ 
+ static int uvc_ioctl_streamoff(struct file *file, void *fh,
+ 			       enum v4l2_buf_type type)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_streaming *stream = handle->stream;
+ 
+ 	if (!uvc_has_privileges(handle))
+ 		return -EBUSY;
+ 
+ 	mutex_lock(&stream->mutex);
+ 	uvc_queue_streamoff(&stream->queue, type);
+ 	mutex_unlock(&stream->mutex);
+ 
+ 	return 0;
+ }
+ 
+ static int uvc_ioctl_enum_input(struct file *file, void *fh,
+ 				struct v4l2_input *input)
+ {
+ 	struct uvc_fh *handle = fh;
+ 	struct uvc_video_chain *chain = handle->chain;
+ 	const struct uvc_entity *selector = chain->selector;
+ 	struct uvc_entity *iterm = NULL;
+ 	u32 index = input->index;
+ 	int pin = 0;
+ 
+ 	if (selector == NULL ||
+ 	    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
+ 		if (index != 0)
+ 			return -EINVAL;
+ 		list_for_each_entry(iterm, &chain->entities, chain) {
+ 			if (UVC_ENTITY_IS_ITERM(iterm))
+ 				break;
+ 		}
+ 		pin = iterm->id;
+ 	} else if (index < selector->bNrInPins) {
+ 		pin = selector->baSourceID[index];
+ 		list_for_each_entry(iterm, &chain->entities, chain) {
+ 			if (!UVC_ENTITY_IS_ITERM(iterm))
+ 				continue;
+ 			if (iterm->id == pin)
+ 				break;
+ 		}
++>>>>>>> 2c6b222cee2d (media: uvcvideo: Use internal kernel integer types)
  	}
  
 -	if (iterm == NULL || iterm->id != pin)
 -		return -EINVAL;
 +	/* Priority */
 +	case VIDIOC_G_PRIORITY:
 +		*(u32 *)arg = v4l2_prio_max(vdev->prio);
 +		break;
  
 -	memset(input, 0, sizeof(*input));
 -	input->index = index;
 -	strlcpy(input->name, iterm->name, sizeof(input->name));
 -	if (UVC_ENTITY_TYPE(iterm) == UVC_ITT_CAMERA)
 -		input->type = V4L2_INPUT_TYPE_CAMERA;
 +	case VIDIOC_S_PRIORITY:
 +		ret = v4l2_prio_check(vdev->prio, handle->vfh.prio);
 +		if (ret < 0)
 +			return ret;
  
 -	return 0;
 -}
 +		return v4l2_prio_change(vdev->prio, &handle->vfh.prio,
 +					*(u32 *)arg);
  
 -static int uvc_ioctl_g_input(struct file *file, void *fh, unsigned int *input)
 -{
 -	struct uvc_fh *handle = fh;
 -	struct uvc_video_chain *chain = handle->chain;
 -	int ret;
 -	u8 i;
 +	/* Get, Set & Query control */
 +	case VIDIOC_QUERYCTRL:
 +		return uvc_query_v4l2_ctrl(chain, arg);
  
 -	if (chain->selector == NULL ||
 -	    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 -		*input = 0;
 -		return 0;
 +	case VIDIOC_G_CTRL:
 +	{
 +		struct v4l2_control *ctrl = arg;
 +		struct v4l2_ext_control xctrl;
 +
 +		memset(&xctrl, 0, sizeof xctrl);
 +		xctrl.id = ctrl->id;
 +
 +		ret = uvc_ctrl_begin(chain);
 +		if (ret < 0)
 +			return ret;
 +
 +		ret = uvc_ctrl_get(chain, &xctrl);
 +		uvc_ctrl_rollback(handle);
 +		if (ret >= 0)
 +			ctrl->value = xctrl.value;
 +		break;
  	}
  
 -	ret = uvc_query_ctrl(chain->dev, UVC_GET_CUR, chain->selector->id,
 -			     chain->dev->intfnum,  UVC_SU_INPUT_SELECT_CONTROL,
 -			     &i, 1);
 -	if (ret < 0)
 -		return ret;
 +	case VIDIOC_S_CTRL:
 +	{
 +		struct v4l2_control *ctrl = arg;
 +		struct v4l2_ext_control xctrl;
  
 -	*input = i - 1;
 -	return 0;
 -}
 +		ret = v4l2_prio_check(vdev->prio, handle->vfh.prio);
 +		if (ret < 0)
 +			return ret;
  
 -static int uvc_ioctl_s_input(struct file *file, void *fh, unsigned int input)
 -{
 -	struct uvc_fh *handle = fh;
 -	struct uvc_video_chain *chain = handle->chain;
 -	int ret;
 -	u32 i;
 +		memset(&xctrl, 0, sizeof xctrl);
 +		xctrl.id = ctrl->id;
 +		xctrl.value = ctrl->value;
  
 -	ret = uvc_acquire_privileges(handle);
 -	if (ret < 0)
 -		return ret;
 +		ret = uvc_ctrl_begin(chain);
 +		if (ret < 0)
 +			return ret;
  
 -	if (chain->selector == NULL ||
 -	    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 -		if (input)
 -			return -EINVAL;
 -		return 0;
 +		ret = uvc_ctrl_set(chain, &xctrl);
 +		if (ret < 0) {
 +			uvc_ctrl_rollback(handle);
 +			return ret;
 +		}
 +		ret = uvc_ctrl_commit(handle, &xctrl, 1);
 +		if (ret == 0)
 +			ctrl->value = xctrl.value;
 +		break;
  	}
  
 -	if (input >= chain->selector->bNrInPins)
 -		return -EINVAL;
 +	case VIDIOC_QUERYMENU:
 +		return uvc_query_v4l2_menu(chain, arg);
  
 -	i = input + 1;
 -	return uvc_query_ctrl(chain->dev, UVC_SET_CUR, chain->selector->id,
 -			      chain->dev->intfnum, UVC_SU_INPUT_SELECT_CONTROL,
 -			      &i, 1);
 -}
 +	case VIDIOC_G_EXT_CTRLS:
 +	{
 +		struct v4l2_ext_controls *ctrls = arg;
 +		struct v4l2_ext_control *ctrl = ctrls->controls;
 +		unsigned int i;
  
 -static int uvc_ioctl_queryctrl(struct file *file, void *fh,
 -			       struct v4l2_queryctrl *qc)
 -{
 -	struct uvc_fh *handle = fh;
 -	struct uvc_video_chain *chain = handle->chain;
 +		ret = uvc_ctrl_begin(chain);
 +		if (ret < 0)
 +			return ret;
  
 -	return uvc_query_v4l2_ctrl(chain, qc);
 -}
 +		for (i = 0; i < ctrls->count; ++ctrl, ++i) {
 +			ret = uvc_ctrl_get(chain, ctrl);
 +			if (ret < 0) {
 +				uvc_ctrl_rollback(handle);
 +				ctrls->error_idx = i;
 +				return ret;
 +			}
 +		}
 +		ctrls->error_idx = 0;
 +		ret = uvc_ctrl_rollback(handle);
 +		break;
 +	}
  
 -static int uvc_ioctl_query_ext_ctrl(struct file *file, void *fh,
 -				    struct v4l2_query_ext_ctrl *qec)
 -{
 -	struct uvc_fh *handle = fh;
 -	struct uvc_video_chain *chain = handle->chain;
 -	struct v4l2_queryctrl qc = { qec->id };
 -	int ret;
 +	case VIDIOC_S_EXT_CTRLS:
 +		ret = v4l2_prio_check(vdev->prio, handle->vfh.prio);
 +		if (ret < 0)
 +			return ret;
 +		/* Fall through */
 +	case VIDIOC_TRY_EXT_CTRLS:
 +	{
 +		struct v4l2_ext_controls *ctrls = arg;
 +		struct v4l2_ext_control *ctrl = ctrls->controls;
 +		unsigned int i;
 +
 +		ret = uvc_ctrl_begin(chain);
 +		if (ret < 0)
 +			return ret;
  
 -	ret = uvc_query_v4l2_ctrl(chain, &qc);
 -	if (ret)
 -		return ret;
 +		for (i = 0; i < ctrls->count; ++ctrl, ++i) {
 +			ret = uvc_ctrl_set(chain, ctrl);
 +			if (ret < 0) {
 +				uvc_ctrl_rollback(handle);
 +				ctrls->error_idx = cmd == VIDIOC_S_EXT_CTRLS
 +						 ? ctrls->count : i;
 +				return ret;
 +			}
 +		}
  
 -	qec->id = qc.id;
 -	qec->type = qc.type;
 -	strlcpy(qec->name, qc.name, sizeof(qec->name));
 -	qec->minimum = qc.minimum;
 -	qec->maximum = qc.maximum;
 -	qec->step = qc.step;
 -	qec->default_value = qc.default_value;
 -	qec->flags = qc.flags;
 -	qec->elem_size = 4;
 -	qec->elems = 1;
 -	qec->nr_of_dims = 0;
 -	memset(qec->dims, 0, sizeof(qec->dims));
 -	memset(qec->reserved, 0, sizeof(qec->reserved));
 +		ctrls->error_idx = 0;
  
 -	return 0;
 -}
 +		if (cmd == VIDIOC_S_EXT_CTRLS)
 +			ret = uvc_ctrl_commit(handle,
 +					      ctrls->controls, ctrls->count);
 +		else
 +			ret = uvc_ctrl_rollback(handle);
 +		break;
 +	}
  
 -static int uvc_ioctl_g_ctrl(struct file *file, void *fh,
 -			    struct v4l2_control *ctrl)
 -{
 -	struct uvc_fh *handle = fh;
 -	struct uvc_video_chain *chain = handle->chain;
 -	struct v4l2_ext_control xctrl;
 -	int ret;
 +	/* Get, Set & Enum input */
 +	case VIDIOC_ENUMINPUT:
 +	{
 +		const struct uvc_entity *selector = chain->selector;
 +		struct v4l2_input *input = arg;
 +		struct uvc_entity *iterm = NULL;
 +		u32 index = input->index;
 +		int pin = 0;
 +
 +		if (selector == NULL ||
 +		    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 +			if (index != 0)
 +				return -EINVAL;
 +			list_for_each_entry(iterm, &chain->entities, chain) {
 +				if (UVC_ENTITY_IS_ITERM(iterm))
 +					break;
 +			}
 +			pin = iterm->id;
 +		} else if (index < selector->bNrInPins) {
 +			gmb();
 +			pin = selector->baSourceID[index];
 +			list_for_each_entry(iterm, &chain->entities, chain) {
 +				if (!UVC_ENTITY_IS_ITERM(iterm))
 +					continue;
 +				if (iterm->id == pin)
 +					break;
 +			}
 +		}
  
 -	memset(&xctrl, 0, sizeof(xctrl));
 -	xctrl.id = ctrl->id;
 +		if (iterm == NULL || iterm->id != pin)
 +			return -EINVAL;
  
 -	ret = uvc_ctrl_begin(chain);
 -	if (ret < 0)
 -		return ret;
 +		memset(input, 0, sizeof *input);
 +		input->index = index;
 +		strlcpy(input->name, iterm->name, sizeof input->name);
 +		if (UVC_ENTITY_TYPE(iterm) == UVC_ITT_CAMERA)
 +			input->type = V4L2_INPUT_TYPE_CAMERA;
 +		break;
 +	}
  
 -	ret = uvc_ctrl_get(chain, &xctrl);
 -	uvc_ctrl_rollback(handle);
 -	if (ret < 0)
 -		return ret;
 +	case VIDIOC_G_INPUT:
 +	{
 +		u8 input;
  
 -	ctrl->value = xctrl.value;
 -	return 0;
 -}
 +		if (chain->selector == NULL ||
 +		    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 +			*(int *)arg = 0;
 +			break;
 +		}
  
 -static int uvc_ioctl_s_ctrl(struct file *file, void *fh,
 -			    struct v4l2_control *ctrl)
 -{
 -	struct uvc_fh *handle = fh;
 -	struct uvc_video_chain *chain = handle->chain;
 -	struct v4l2_ext_control xctrl;
 -	int ret;
 +		ret = uvc_query_ctrl(chain->dev, UVC_GET_CUR,
 +			chain->selector->id, chain->dev->intfnum,
 +			UVC_SU_INPUT_SELECT_CONTROL, &input, 1);
 +		if (ret < 0)
 +			return ret;
  
 -	memset(&xctrl, 0, sizeof(xctrl));
 -	xctrl.id = ctrl->id;
 -	xctrl.value = ctrl->value;
 +		*(int *)arg = input - 1;
 +		break;
 +	}
  
 -	ret = uvc_ctrl_begin(chain);
 -	if (ret < 0)
 -		return ret;
 +	case VIDIOC_S_INPUT:
 +	{
 +		u32 input = *(u32 *)arg + 1;
  
 -	ret = uvc_ctrl_set(chain, &xctrl);
 -	if (ret < 0) {
 -		uvc_ctrl_rollback(handle);
 -		return ret;
 -	}
 +		ret = v4l2_prio_check(vdev->prio, handle->vfh.prio);
 +		if (ret < 0)
 +			return ret;
  
 -	ret = uvc_ctrl_commit(handle, &xctrl, 1);
 -	if (ret < 0)
 -		return ret;
 +		if ((ret = uvc_acquire_privileges(handle)) < 0)
 +			return ret;
  
 -	ctrl->value = xctrl.value;
 -	return 0;
 -}
 +		if (chain->selector == NULL ||
 +		    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 +			if (input != 1)
 +				return -EINVAL;
 +			break;
 +		}
  
 -static int uvc_ioctl_g_ext_ctrls(struct file *file, void *fh,
 -				 struct v4l2_ext_controls *ctrls)
 -{
 -	struct uvc_fh *handle = fh;
 -	struct uvc_video_chain *chain = handle->chain;
 -	struct v4l2_ext_control *ctrl = ctrls->controls;
 -	unsigned int i;
 -	int ret;
 +		if (input == 0 || input > chain->selector->bNrInPins)
 +			return -EINVAL;
  
 -	if (ctrls->which == V4L2_CTRL_WHICH_DEF_VAL) {
 -		for (i = 0; i < ctrls->count; ++ctrl, ++i) {
 -			struct v4l2_queryctrl qc = { .id = ctrl->id };
 +		return uvc_query_ctrl(chain->dev, UVC_SET_CUR,
 +			chain->selector->id, chain->dev->intfnum,
 +			UVC_SU_INPUT_SELECT_CONTROL, &input, 1);
 +	}
  
 -			ret = uvc_query_v4l2_ctrl(chain, &qc);
 -			if (ret < 0) {
 -				ctrls->error_idx = i;
 -				return ret;
 -			}
 +	/* Try, Get, Set & Enum format */
 +	case VIDIOC_ENUM_FMT:
 +	{
 +		struct v4l2_fmtdesc *fmt = arg;
 +		struct uvc_format *format;
 +		enum v4l2_buf_type type = fmt->type;
 +		__u32 index = fmt->index;
  
 -			ctrl->value = qc.default_value;
 -		}
 +		if (fmt->type != stream->type ||
 +		    fmt->index >= stream->nformats)
 +			return -EINVAL;
  
 -		return 0;
 +		memset(fmt, 0, sizeof(*fmt));
 +		fmt->index = index;
 +		fmt->type = type;
 +
 +		format = &stream->format[fmt->index];
 +		fmt->flags = 0;
 +		if (format->flags & UVC_FMT_FLAG_COMPRESSED)
 +			fmt->flags |= V4L2_FMT_FLAG_COMPRESSED;
 +		strlcpy(fmt->description, format->name,
 +			sizeof fmt->description);
 +		fmt->description[sizeof fmt->description - 1] = 0;
 +		fmt->pixelformat = format->fcc;
 +		break;
  	}
  
 -	ret = uvc_ctrl_begin(chain);
 -	if (ret < 0)
 -		return ret;
 +	case VIDIOC_TRY_FMT:
 +	{
 +		struct uvc_streaming_control probe;
  
 -	for (i = 0; i < ctrls->count; ++ctrl, ++i) {
 -		ret = uvc_ctrl_get(chain, ctrl);
 -		if (ret < 0) {
 -			uvc_ctrl_rollback(handle);
 -			ctrls->error_idx = i;
 -			return ret;
 -		}
 +		return uvc_v4l2_try_format(stream, arg, &probe, NULL, NULL);
  	}
  
 -	ctrls->error_idx = 0;
 +	case VIDIOC_S_FMT:
 +		ret = v4l2_prio_check(vdev->prio, handle->vfh.prio);
 +		if (ret < 0)
 +			return ret;
  
 -	return uvc_ctrl_rollback(handle);
 -}
 +		if ((ret = uvc_acquire_privileges(handle)) < 0)
 +			return ret;
  
 -static int uvc_ioctl_s_try_ext_ctrls(struct uvc_fh *handle,
 -				     struct v4l2_ext_controls *ctrls,
 -				     bool commit)
 -{
 -	struct v4l2_ext_control *ctrl = ctrls->controls;
 -	struct uvc_video_chain *chain = handle->chain;
 -	unsigned int i;
 -	int ret;
 +		return uvc_v4l2_set_format(stream, arg);
  
 -	/* Default value cannot be changed */
 -	if (ctrls->which == V4L2_CTRL_WHICH_DEF_VAL)
 -		return -EINVAL;
 +	case VIDIOC_G_FMT:
 +		return uvc_v4l2_get_format(stream, arg);
  
 -	ret = uvc_ctrl_begin(chain);
 -	if (ret < 0)
 -		return ret;
 +	/* Frame size enumeration */
 +	case VIDIOC_ENUM_FRAMESIZES:
 +	{
 +		struct v4l2_frmsizeenum *fsize = arg;
 +		struct uvc_format *format = NULL;
 +		struct uvc_frame *frame;
 +		int i;
  
 -	for (i = 0; i < ctrls->count; ++ctrl, ++i) {
 -		ret = uvc_ctrl_set(chain, ctrl);
 -		if (ret < 0) {
 -			uvc_ctrl_rollback(handle);
 -			ctrls->error_idx = commit ? ctrls->count : i;
 -			return ret;
 +		/* Look for the given pixel format */
 +		for (i = 0; i < stream->nformats; i++) {
 +			if (stream->format[i].fcc ==
 +					fsize->pixel_format) {
 +				format = &stream->format[i];
 +				break;
 +			}
  		}
 -	}
 +		if (format == NULL)
 +			return -EINVAL;
  
 -	ctrls->error_idx = 0;
 +		if (fsize->index >= format->nframes)
 +			return -EINVAL;
  
 -	if (commit)
 -		return uvc_ctrl_commit(handle, ctrls->controls, ctrls->count);
 -	else
 -		return uvc_ctrl_rollback(handle);
 -}
 +		frame = &format->frame[fsize->index];
 +		fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
 +		fsize->discrete.width = frame->wWidth;
 +		fsize->discrete.height = frame->wHeight;
 +		break;
 +	}
  
 -static int uvc_ioctl_s_ext_ctrls(struct file *file, void *fh,
 -				 struct v4l2_ext_controls *ctrls)
 -{
 -	struct uvc_fh *handle = fh;
 +	/* Frame interval enumeration */
 +	case VIDIOC_ENUM_FRAMEINTERVALS:
 +	{
 +		struct v4l2_frmivalenum *fival = arg;
 +		struct uvc_format *format = NULL;
 +		struct uvc_frame *frame = NULL;
 +		int i;
 +
 +		/* Look for the given pixel format and frame size */
 +		for (i = 0; i < stream->nformats; i++) {
 +			if (stream->format[i].fcc ==
 +					fival->pixel_format) {
 +				format = &stream->format[i];
 +				break;
 +			}
 +		}
 +		if (format == NULL)
 +			return -EINVAL;
  
 -	return uvc_ioctl_s_try_ext_ctrls(handle, ctrls, true);
 -}
 +		for (i = 0; i < format->nframes; i++) {
 +			if (format->frame[i].wWidth == fival->width &&
 +			    format->frame[i].wHeight == fival->height) {
 +				frame = &format->frame[i];
 +				break;
 +			}
 +		}
 +		if (frame == NULL)
 +			return -EINVAL;
  
 -static int uvc_ioctl_try_ext_ctrls(struct file *file, void *fh,
 -				   struct v4l2_ext_controls *ctrls)
 -{
 -	struct uvc_fh *handle = fh;
 +		if (frame->bFrameIntervalType) {
 +			if (fival->index >= frame->bFrameIntervalType)
 +				return -EINVAL;
 +
 +			fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
 +			fival->discrete.numerator =
 +				frame->dwFrameInterval[fival->index];
 +			fival->discrete.denominator = 10000000;
 +			uvc_simplify_fraction(&fival->discrete.numerator,
 +				&fival->discrete.denominator, 8, 333);
 +		} else {
 +			fival->type = V4L2_FRMIVAL_TYPE_STEPWISE;
 +			fival->stepwise.min.numerator =
 +				frame->dwFrameInterval[0];
 +			fival->stepwise.min.denominator = 10000000;
 +			fival->stepwise.max.numerator =
 +				frame->dwFrameInterval[1];
 +			fival->stepwise.max.denominator = 10000000;
 +			fival->stepwise.step.numerator =
 +				frame->dwFrameInterval[2];
 +			fival->stepwise.step.denominator = 10000000;
 +			uvc_simplify_fraction(&fival->stepwise.min.numerator,
 +				&fival->stepwise.min.denominator, 8, 333);
 +			uvc_simplify_fraction(&fival->stepwise.max.numerator,
 +				&fival->stepwise.max.denominator, 8, 333);
 +			uvc_simplify_fraction(&fival->stepwise.step.numerator,
 +				&fival->stepwise.step.denominator, 8, 333);
 +		}
 +		break;
 +	}
  
 -	return uvc_ioctl_s_try_ext_ctrls(handle, ctrls, false);
 -}
 +	/* Get & Set streaming parameters */
 +	case VIDIOC_G_PARM:
 +		return uvc_v4l2_get_streamparm(stream, arg);
  
 -static int uvc_ioctl_querymenu(struct file *file, void *fh,
 -			       struct v4l2_querymenu *qm)
 -{
 -	struct uvc_fh *handle = fh;
 -	struct uvc_video_chain *chain = handle->chain;
 +	case VIDIOC_S_PARM:
 +		ret = v4l2_prio_check(vdev->prio, handle->vfh.prio);
 +		if (ret < 0)
 +			return ret;
  
 -	return uvc_query_v4l2_menu(chain, qm);
 -}
 +		if ((ret = uvc_acquire_privileges(handle)) < 0)
 +			return ret;
  
 -static int uvc_ioctl_g_selection(struct file *file, void *fh,
 -				 struct v4l2_selection *sel)
 -{
 -	struct uvc_fh *handle = fh;
 -	struct uvc_streaming *stream = handle->stream;
 +		return uvc_v4l2_set_streamparm(stream, arg);
  
 -	if (sel->type != stream->type)
 -		return -EINVAL;
 +	/* Cropping and scaling */
 +	case VIDIOC_CROPCAP:
 +	{
 +		struct v4l2_cropcap *ccap = arg;
  
 -	switch (sel->target) {
 -	case V4L2_SEL_TGT_CROP_DEFAULT:
 -	case V4L2_SEL_TGT_CROP_BOUNDS:
 -		if (stream->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
 -			return -EINVAL;
 -		break;
 -	case V4L2_SEL_TGT_COMPOSE_DEFAULT:
 -	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
 -		if (stream->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
 +		if (ccap->type != stream->type)
  			return -EINVAL;
 +
 +		ccap->bounds.left = 0;
 +		ccap->bounds.top = 0;
 +
 +		mutex_lock(&stream->mutex);
 +		ccap->bounds.width = stream->cur_frame->wWidth;
 +		ccap->bounds.height = stream->cur_frame->wHeight;
 +		mutex_unlock(&stream->mutex);
 +
 +		ccap->defrect = ccap->bounds;
 +
 +		ccap->pixelaspect.numerator = 1;
 +		ccap->pixelaspect.denominator = 1;
  		break;
 -	default:
 -		return -EINVAL;
  	}
  
 -	sel->r.left = 0;
 -	sel->r.top = 0;
 -	mutex_lock(&stream->mutex);
 -	sel->r.width = stream->cur_frame->wWidth;
 -	sel->r.height = stream->cur_frame->wHeight;
 -	mutex_unlock(&stream->mutex);
 +	case VIDIOC_G_CROP:
 +	case VIDIOC_S_CROP:
 +		return -ENOTTY;
  
 -	return 0;
 -}
 +	/* Buffers & streaming */
 +	case VIDIOC_REQBUFS:
 +		ret = v4l2_prio_check(vdev->prio, handle->vfh.prio);
 +		if (ret < 0)
 +			return ret;
  
 -static int uvc_ioctl_g_parm(struct file *file, void *fh,
 -			    struct v4l2_streamparm *parm)
 -{
 -	struct uvc_fh *handle = fh;
 -	struct uvc_streaming *stream = handle->stream;
 +		if ((ret = uvc_acquire_privileges(handle)) < 0)
 +			return ret;
  
 -	return uvc_v4l2_get_streamparm(stream, parm);
 -}
 +		mutex_lock(&stream->mutex);
 +		ret = uvc_alloc_buffers(&stream->queue, arg);
 +		mutex_unlock(&stream->mutex);
 +		if (ret < 0)
 +			return ret;
  
 -static int uvc_ioctl_s_parm(struct file *file, void *fh,
 -			    struct v4l2_streamparm *parm)
 -{
 -	struct uvc_fh *handle = fh;
 -	struct uvc_streaming *stream = handle->stream;
 -	int ret;
 +		if (ret == 0)
 +			uvc_dismiss_privileges(handle);
  
 -	ret = uvc_acquire_privileges(handle);
 -	if (ret < 0)
 -		return ret;
 +		ret = 0;
 +		break;
  
 -	return uvc_v4l2_set_streamparm(stream, parm);
 -}
 +	case VIDIOC_QUERYBUF:
 +	{
 +		struct v4l2_buffer *buf = arg;
  
 -static int uvc_ioctl_enum_framesizes(struct file *file, void *fh,
 -				     struct v4l2_frmsizeenum *fsize)
 -{
 -	struct uvc_fh *handle = fh;
 -	struct uvc_streaming *stream = handle->stream;
 -	struct uvc_format *format = NULL;
 -	struct uvc_frame *frame;
 -	unsigned int index;
 -	unsigned int i;
 +		if (!uvc_has_privileges(handle))
 +			return -EBUSY;
  
 -	/* Look for the given pixel format */
 -	for (i = 0; i < stream->nformats; i++) {
 -		if (stream->format[i].fcc == fsize->pixel_format) {
 -			format = &stream->format[i];
 -			break;
 -		}
 +		return uvc_query_buffer(&stream->queue, buf);
  	}
 -	if (format == NULL)
 -		return -EINVAL;
  
 -	/* Skip duplicate frame sizes */
 -	for (i = 0, index = 0; i < format->nframes; i++) {
 -		if (i && frame->wWidth == format->frame[i].wWidth &&
 -		    frame->wHeight == format->frame[i].wHeight)
 -			continue;
 -		frame = &format->frame[i];
 -		if (index == fsize->index)
 -			break;
 -		index++;
 +	case VIDIOC_QBUF:
 +		if (!uvc_has_privileges(handle))
 +			return -EBUSY;
 +
 +		return uvc_queue_buffer(&stream->queue, arg);
 +
 +	case VIDIOC_DQBUF:
 +		if (!uvc_has_privileges(handle))
 +			return -EBUSY;
 +
 +		return uvc_dequeue_buffer(&stream->queue, arg,
 +			file->f_flags & O_NONBLOCK);
 +
 +	case VIDIOC_STREAMON:
 +	{
 +		int *type = arg;
 +
 +		if (*type != stream->type)
 +			return -EINVAL;
 +
 +		ret = v4l2_prio_check(vdev->prio, handle->vfh.prio);
 +		if (ret < 0)
 +			return ret;
 +
 +		if (!uvc_has_privileges(handle))
 +			return -EBUSY;
 +
 +		mutex_lock(&stream->mutex);
 +		ret = uvc_video_enable(stream, 1);
 +		mutex_unlock(&stream->mutex);
 +		if (ret < 0)
 +			return ret;
 +		break;
  	}
  
 -	if (i == format->nframes)
 -		return -EINVAL;
 +	case VIDIOC_STREAMOFF:
 +	{
 +		int *type = arg;
  
 -	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
 -	fsize->discrete.width = frame->wWidth;
 -	fsize->discrete.height = frame->wHeight;
 -	return 0;
 -}
 +		if (*type != stream->type)
 +			return -EINVAL;
  
 -static int uvc_ioctl_enum_frameintervals(struct file *file, void *fh,
 -					 struct v4l2_frmivalenum *fival)
 -{
 -	struct uvc_fh *handle = fh;
 -	struct uvc_streaming *stream = handle->stream;
 -	struct uvc_format *format = NULL;
 -	struct uvc_frame *frame = NULL;
 -	unsigned int nintervals;
 -	unsigned int index;
 -	unsigned int i;
 +		ret = v4l2_prio_check(vdev->prio, handle->vfh.prio);
 +		if (ret < 0)
 +			return ret;
  
 -	/* Look for the given pixel format and frame size */
 -	for (i = 0; i < stream->nformats; i++) {
 -		if (stream->format[i].fcc == fival->pixel_format) {
 -			format = &stream->format[i];
 -			break;
 -		}
 +		if (!uvc_has_privileges(handle))
 +			return -EBUSY;
 +
 +		return uvc_video_enable(stream, 0);
  	}
 -	if (format == NULL)
 -		return -EINVAL;
  
 -	index = fival->index;
 -	for (i = 0; i < format->nframes; i++) {
 -		if (format->frame[i].wWidth == fival->width &&
 -		    format->frame[i].wHeight == fival->height) {
 -			frame = &format->frame[i];
 -			nintervals = frame->bFrameIntervalType ?: 1;
 -			if (index < nintervals)
 -				break;
 -			index -= nintervals;
 +	case VIDIOC_SUBSCRIBE_EVENT:
 +	{
 +		struct v4l2_event_subscription *sub = arg;
 +
 +		switch (sub->type) {
 +		case V4L2_EVENT_CTRL:
 +			return v4l2_event_subscribe(&handle->vfh, sub, 0,
 +						    &uvc_ctrl_sub_ev_ops);
 +		default:
 +			return -EINVAL;
  		}
  	}
 -	if (i == format->nframes)
 -		return -EINVAL;
  
 -	if (frame->bFrameIntervalType) {
 -		fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
 -		fival->discrete.numerator =
 -			frame->dwFrameInterval[index];
 -		fival->discrete.denominator = 10000000;
 -		uvc_simplify_fraction(&fival->discrete.numerator,
 -			&fival->discrete.denominator, 8, 333);
 -	} else {
 -		fival->type = V4L2_FRMIVAL_TYPE_STEPWISE;
 -		fival->stepwise.min.numerator = frame->dwFrameInterval[0];
 -		fival->stepwise.min.denominator = 10000000;
 -		fival->stepwise.max.numerator = frame->dwFrameInterval[1];
 -		fival->stepwise.max.denominator = 10000000;
 -		fival->stepwise.step.numerator = frame->dwFrameInterval[2];
 -		fival->stepwise.step.denominator = 10000000;
 -		uvc_simplify_fraction(&fival->stepwise.min.numerator,
 -			&fival->stepwise.min.denominator, 8, 333);
 -		uvc_simplify_fraction(&fival->stepwise.max.numerator,
 -			&fival->stepwise.max.denominator, 8, 333);
 -		uvc_simplify_fraction(&fival->stepwise.step.numerator,
 -			&fival->stepwise.step.denominator, 8, 333);
 -	}
 +	case VIDIOC_UNSUBSCRIBE_EVENT:
 +		return v4l2_event_unsubscribe(&handle->vfh, arg);
  
 -	return 0;
 -}
 +	case VIDIOC_DQEVENT:
 +		return v4l2_event_dequeue(&handle->vfh, arg,
 +					  file->f_flags & O_NONBLOCK);
  
 -static int uvc_ioctl_subscribe_event(struct v4l2_fh *fh,
 -				     const struct v4l2_event_subscription *sub)
 -{
 -	switch (sub->type) {
 -	case V4L2_EVENT_CTRL:
 -		return v4l2_event_subscribe(fh, sub, 0, &uvc_ctrl_sub_ev_ops);
 -	default:
 -		return -EINVAL;
 -	}
 -}
 +	/* Analog video standards make no sense for digital cameras. */
 +	case VIDIOC_ENUMSTD:
 +	case VIDIOC_QUERYSTD:
 +	case VIDIOC_G_STD:
 +	case VIDIOC_S_STD:
  
 -static long uvc_ioctl_default(struct file *file, void *fh, bool valid_prio,
 -			      unsigned int cmd, void *arg)
 -{
 -	struct uvc_fh *handle = fh;
 -	struct uvc_video_chain *chain = handle->chain;
 +	case VIDIOC_OVERLAY:
 +
 +	case VIDIOC_ENUMAUDIO:
 +	case VIDIOC_ENUMAUDOUT:
 +
 +	case VIDIOC_ENUMOUTPUT:
 +		uvc_trace(UVC_TRACE_IOCTL, "Unsupported ioctl 0x%08x\n", cmd);
 +		return -ENOTTY;
  
 -	switch (cmd) {
 -	/* Dynamic controls. */
  	case UVCIOC_CTRL_MAP:
  		return uvc_ioctl_ctrl_map(chain, arg);
  
diff --cc drivers/media/usb/uvc/uvc_video.c
index ea917fd6d84e,dfe13c55a067..000000000000
--- a/drivers/media/usb/uvc/uvc_video.c
+++ b/drivers/media/usb/uvc/uvc_video.c
@@@ -163,27 -163,14 +163,32 @@@ static void uvc_fixup_video_ctrl(struc
  	}
  }
  
 +static size_t uvc_video_ctrl_size(struct uvc_streaming *stream)
 +{
 +	/*
 +	 * Return the size of the video probe and commit controls, which depends
 +	 * on the protocol version.
 +	 */
 +	if (stream->dev->uvc_version < 0x0110)
 +		return 26;
 +	else if (stream->dev->uvc_version < 0x0150)
 +		return 34;
 +	else
 +		return 48;
 +}
 +
  static int uvc_get_video_ctrl(struct uvc_streaming *stream,
- 	struct uvc_streaming_control *ctrl, int probe, __u8 query)
+ 	struct uvc_streaming_control *ctrl, int probe, u8 query)
  {
++<<<<<<< HEAD
 +	__u16 size = uvc_video_ctrl_size(stream);
 +	__u8 *data;
++=======
+ 	u8 *data;
+ 	u16 size;
++>>>>>>> 2c6b222cee2d (media: uvcvideo: Use internal kernel integer types)
  	int ret;
  
 -	size = stream->dev->uvc_version >= 0x0110 ? 34 : 26;
  	if ((stream->dev->quirks & UVC_QUIRK_PROBE_DEF) &&
  			query == UVC_GET_DEF)
  		return -EIO;
@@@ -267,10 -254,11 +272,15 @@@ out
  static int uvc_set_video_ctrl(struct uvc_streaming *stream,
  	struct uvc_streaming_control *ctrl, int probe)
  {
++<<<<<<< HEAD
 +	__u16 size = uvc_video_ctrl_size(stream);
 +	__u8 *data;
++=======
+ 	u8 *data;
+ 	u16 size;
++>>>>>>> 2c6b222cee2d (media: uvcvideo: Use internal kernel integer types)
  	int ret;
  
 -	size = stream->dev->uvc_version >= 0x0110 ? 34 : 26;
  	data = kzalloc(size, GFP_KERNEL);
  	if (data == NULL)
  		return -ENOMEM;
diff --cc drivers/media/usb/uvc/uvcvideo.h
index 8abc612877d2,be5cf179228b..000000000000
--- a/drivers/media/usb/uvc/uvcvideo.h
+++ b/drivers/media/usb/uvc/uvcvideo.h
@@@ -457,7 -512,13 +457,17 @@@ struct uvc_streaming 
  	unsigned int frozen : 1;
  	struct uvc_video_queue queue;
  	void (*decode) (struct urb *urb, struct uvc_streaming *video,
++<<<<<<< HEAD
 +			struct uvc_buffer *buf);
++=======
+ 			struct uvc_buffer *buf, struct uvc_buffer *meta_buf);
+ 
+ 	struct {
+ 		struct video_device vdev;
+ 		struct uvc_video_queue queue;
+ 		u32 format;
+ 	} meta;
++>>>>>>> 2c6b222cee2d (media: uvcvideo: Use internal kernel integer types)
  
  	/* Context data used by the bulk completion handler. */
  	struct {
@@@ -511,7 -570,8 +521,12 @@@ struct uvc_device 
  	struct usb_device *udev;
  	struct usb_interface *intf;
  	unsigned long warnings;
++<<<<<<< HEAD
 +	__u32 quirks;
++=======
+ 	u32 quirks;
+ 	u32 meta_format;
++>>>>>>> 2c6b222cee2d (media: uvcvideo: Use internal kernel integer types)
  	int intfnum;
  	char name[32];
  
@@@ -644,29 -708,37 +659,40 @@@ static inline int uvc_queue_streaming(s
  extern const struct v4l2_file_operations uvc_fops;
  
  /* Media controller */
 -int uvc_mc_register_entities(struct uvc_video_chain *chain);
 -void uvc_mc_cleanup_entity(struct uvc_entity *entity);
 +extern int uvc_mc_register_entities(struct uvc_video_chain *chain);
 +extern void uvc_mc_cleanup_entity(struct uvc_entity *entity);
  
  /* Video */
++<<<<<<< HEAD
 +extern int uvc_video_init(struct uvc_streaming *stream);
 +extern int uvc_video_suspend(struct uvc_streaming *stream);
 +extern int uvc_video_resume(struct uvc_streaming *stream, int reset);
 +extern int uvc_video_enable(struct uvc_streaming *stream, int enable);
 +extern int uvc_probe_video(struct uvc_streaming *stream,
 +		struct uvc_streaming_control *probe);
 +extern int uvc_query_ctrl(struct uvc_device *dev, __u8 query, __u8 unit,
 +		__u8 intfnum, __u8 cs, void *data, __u16 size);
++=======
+ int uvc_video_init(struct uvc_streaming *stream);
+ int uvc_video_suspend(struct uvc_streaming *stream);
+ int uvc_video_resume(struct uvc_streaming *stream, int reset);
+ int uvc_video_enable(struct uvc_streaming *stream, int enable);
+ int uvc_probe_video(struct uvc_streaming *stream,
+ 		    struct uvc_streaming_control *probe);
+ int uvc_query_ctrl(struct uvc_device *dev, u8 query, u8 unit,
+ 		   u8 intfnum, u8 cs, void *data, u16 size);
++>>>>>>> 2c6b222cee2d (media: uvcvideo: Use internal kernel integer types)
  void uvc_video_clock_update(struct uvc_streaming *stream,
 -			    struct vb2_v4l2_buffer *vbuf,
 +			    struct v4l2_buffer *v4l2_buf,
  			    struct uvc_buffer *buf);
 -int uvc_meta_register(struct uvc_streaming *stream);
 -
 -int uvc_register_video_device(struct uvc_device *dev,
 -			      struct uvc_streaming *stream,
 -			      struct video_device *vdev,
 -			      struct uvc_video_queue *queue,
 -			      enum v4l2_buf_type type,
 -			      const struct v4l2_file_operations *fops,
 -			      const struct v4l2_ioctl_ops *ioctl_ops);
  
  /* Status */
 -int uvc_status_init(struct uvc_device *dev);
 -void uvc_status_cleanup(struct uvc_device *dev);
 -int uvc_status_start(struct uvc_device *dev, gfp_t flags);
 -void uvc_status_stop(struct uvc_device *dev);
 +extern int uvc_status_init(struct uvc_device *dev);
 +extern void uvc_status_cleanup(struct uvc_device *dev);
 +extern int uvc_status_start(struct uvc_device *dev);
 +extern void uvc_status_stop(struct uvc_device *dev);
 +extern int uvc_status_suspend(struct uvc_device *dev);
 +extern int uvc_status_resume(struct uvc_device *dev);
  
  /* Controls */
  extern const struct v4l2_subscribed_event_ops uvc_ctrl_sub_ev_ops;
@@@ -697,21 -769,18 +723,29 @@@ static inline int uvc_ctrl_rollback(str
  	return __uvc_ctrl_commit(handle, 1, NULL, 0);
  }
  
 -int uvc_ctrl_get(struct uvc_video_chain *chain, struct v4l2_ext_control *xctrl);
 -int uvc_ctrl_set(struct uvc_video_chain *chain, struct v4l2_ext_control *xctrl);
 +extern int uvc_ctrl_get(struct uvc_video_chain *chain,
 +		struct v4l2_ext_control *xctrl);
 +extern int uvc_ctrl_set(struct uvc_video_chain *chain,
 +		struct v4l2_ext_control *xctrl);
  
 -int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
 -		      struct uvc_xu_control_query *xqry);
 +extern int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
 +		struct uvc_xu_control_query *xqry);
  
  /* Utility functions */
++<<<<<<< HEAD
 +extern void uvc_simplify_fraction(uint32_t *numerator, uint32_t *denominator,
 +		unsigned int n_terms, unsigned int threshold);
 +extern uint32_t uvc_fraction_to_interval(uint32_t numerator,
 +		uint32_t denominator);
 +extern struct usb_host_endpoint *uvc_find_endpoint(
 +		struct usb_host_interface *alts, __u8 epaddr);
++=======
+ void uvc_simplify_fraction(u32 *numerator, u32 *denominator,
+ 			   unsigned int n_terms, unsigned int threshold);
+ u32 uvc_fraction_to_interval(u32 numerator, u32 denominator);
+ struct usb_host_endpoint *uvc_find_endpoint(struct usb_host_interface *alts,
+ 					    u8 epaddr);
++>>>>>>> 2c6b222cee2d (media: uvcvideo: Use internal kernel integer types)
  
  /* Quirks support */
  void uvc_video_decode_isight(struct urb *urb, struct uvc_streaming *stream,
* Unmerged path drivers/media/usb/uvc/uvc_ctrl.c
diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driver.c
index 8337faa635f2..d3c024626a22 100644
--- a/drivers/media/usb/uvc/uvc_driver.c
+++ b/drivers/media/usb/uvc/uvc_driver.c
@@ -130,7 +130,7 @@ static struct uvc_format_desc uvc_fmts[] = {
  */
 
 struct usb_host_endpoint *uvc_find_endpoint(struct usb_host_interface *alts,
-		__u8 epaddr)
+		u8 epaddr)
 {
 	struct usb_host_endpoint *ep;
 	unsigned int i;
@@ -144,7 +144,7 @@ struct usb_host_endpoint *uvc_find_endpoint(struct usb_host_interface *alts,
 	return NULL;
 }
 
-static struct uvc_format_desc *uvc_format_by_guid(const __u8 guid[16])
+static struct uvc_format_desc *uvc_format_by_guid(const u8 guid[16])
 {
 	unsigned int len = ARRAY_SIZE(uvc_fmts);
 	unsigned int i;
@@ -157,9 +157,9 @@ static struct uvc_format_desc *uvc_format_by_guid(const __u8 guid[16])
 	return NULL;
 }
 
-static __u32 uvc_colorspace(const __u8 primaries)
+static u32 uvc_colorspace(const u8 primaries)
 {
-	static const __u8 colorprimaries[] = {
+	static const u8 colorprimaries[] = {
 		0,
 		V4L2_COLORSPACE_SRGB,
 		V4L2_COLORSPACE_470_SYSTEM_M,
@@ -305,7 +305,7 @@ static struct uvc_streaming *uvc_stream_by_id(struct uvc_device *dev, int id)
 
 static int uvc_parse_format(struct uvc_device *dev,
 	struct uvc_streaming *streaming, struct uvc_format *format,
-	__u32 **intervals, unsigned char *buffer, int buflen)
+	u32 **intervals, unsigned char *buffer, int buflen)
 {
 	struct usb_interface *intf = streaming->intf;
 	struct usb_host_interface *alts = intf->cur_altsetting;
@@ -314,7 +314,7 @@ static int uvc_parse_format(struct uvc_device *dev,
 	const unsigned char *start = buffer;
 	unsigned int interval;
 	unsigned int i, n;
-	__u8 ftype;
+	u8 ftype;
 
 	format->type = buffer[2];
 	format->index = buffer[3];
@@ -556,8 +556,8 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 	int _buflen, buflen = alts->extralen;
 	unsigned int nformats = 0, nframes = 0, nintervals = 0;
 	unsigned int size, i, n, p;
-	__u32 *interval;
-	__u16 psize;
+	u32 *interval;
+	u16 psize;
 	int ret = -EINVAL;
 
 	if (intf->cur_altsetting->desc.bInterfaceSubClass
@@ -734,7 +734,7 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 	}
 
 	frame = (struct uvc_frame *)&format[nformats];
-	interval = (__u32 *)&frame[nframes];
+	interval = (u32 *)&frame[nframes];
 
 	streaming->format = format;
 	streaming->nformats = nformats;
@@ -828,7 +828,7 @@ static struct uvc_entity *uvc_alloc_entity(u16 type, u8 id,
 		entity->pads[num_pads-1].flags = MEDIA_PAD_FL_SOURCE;
 
 	entity->bNrInPins = num_inputs;
-	entity->baSourceID = (__u8 *)(&entity->pads[num_pads]);
+	entity->baSourceID = (u8 *)(&entity->pads[num_pads]);
 
 	return entity;
 }
@@ -893,8 +893,8 @@ static int uvc_parse_vendor_control(struct uvc_device *dev,
 		unit->extension.bNumControls = buffer[20];
 		memcpy(unit->baSourceID, &buffer[22], p);
 		unit->extension.bControlSize = buffer[22+p];
-		unit->extension.bmControls = (__u8 *)unit + sizeof(*unit);
-		unit->extension.bmControlsType = (__u8 *)unit + sizeof(*unit)
+		unit->extension.bmControls = (u8 *)unit + sizeof(*unit);
+		unit->extension.bmControlsType = (u8 *)unit + sizeof(*unit)
 					       + n;
 		memcpy(unit->extension.bmControls, &buffer[23+p], 2*n);
 
@@ -920,7 +920,7 @@ static int uvc_parse_standard_control(struct uvc_device *dev,
 	struct usb_interface *intf;
 	struct usb_host_interface *alts = dev->intf->cur_altsetting;
 	unsigned int i, n, p, len;
-	__u16 type;
+	u16 type;
 
 	switch (buffer[2]) {
 	case UVC_VC_HEADER:
@@ -999,7 +999,7 @@ static int uvc_parse_standard_control(struct uvc_device *dev,
 
 		if (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA) {
 			term->camera.bControlSize = n;
-			term->camera.bmControls = (__u8 *)term + sizeof *term;
+			term->camera.bmControls = (u8 *)term + sizeof *term;
 			term->camera.wObjectiveFocalLengthMin =
 				get_unaligned_le16(&buffer[8]);
 			term->camera.wObjectiveFocalLengthMax =
@@ -1010,9 +1010,9 @@ static int uvc_parse_standard_control(struct uvc_device *dev,
 		} else if (UVC_ENTITY_TYPE(term) ==
 			   UVC_ITT_MEDIA_TRANSPORT_INPUT) {
 			term->media.bControlSize = n;
-			term->media.bmControls = (__u8 *)term + sizeof *term;
+			term->media.bmControls = (u8 *)term + sizeof *term;
 			term->media.bTransportModeSize = p;
-			term->media.bmTransportModes = (__u8 *)term
+			term->media.bmTransportModes = (u8 *)term
 						     + sizeof *term + n;
 			memcpy(term->media.bmControls, &buffer[9], n);
 			memcpy(term->media.bmTransportModes, &buffer[10+n], p);
@@ -1111,7 +1111,7 @@ static int uvc_parse_standard_control(struct uvc_device *dev,
 		unit->processing.wMaxMultiplier =
 			get_unaligned_le16(&buffer[5]);
 		unit->processing.bControlSize = buffer[7];
-		unit->processing.bmControls = (__u8 *)unit + sizeof *unit;
+		unit->processing.bmControls = (u8 *)unit + sizeof *unit;
 		memcpy(unit->processing.bmControls, &buffer[8], n);
 		if (dev->uvc_version >= 0x0110)
 			unit->processing.bmVideoStandards = buffer[9+n];
@@ -1144,7 +1144,7 @@ static int uvc_parse_standard_control(struct uvc_device *dev,
 		unit->extension.bNumControls = buffer[20];
 		memcpy(unit->baSourceID, &buffer[22], p);
 		unit->extension.bControlSize = buffer[22+p];
-		unit->extension.bmControls = (__u8 *)unit + sizeof *unit;
+		unit->extension.bmControls = (u8 *)unit + sizeof *unit;
 		memcpy(unit->extension.bmControls, &buffer[23+p], n);
 
 		if (buffer[23+p+n] != 0)
diff --git a/drivers/media/usb/uvc/uvc_isight.c b/drivers/media/usb/uvc/uvc_isight.c
index 8510e7259e76..20092d9214cc 100644
--- a/drivers/media/usb/uvc/uvc_isight.c
+++ b/drivers/media/usb/uvc/uvc_isight.c
@@ -37,16 +37,16 @@
  */
 
 static int isight_decode(struct uvc_video_queue *queue, struct uvc_buffer *buf,
-		const __u8 *data, unsigned int len)
+		const u8 *data, unsigned int len)
 {
-	static const __u8 hdr[] = {
+	static const u8 hdr[] = {
 		0x11, 0x22, 0x33, 0x44,
 		0xde, 0xad, 0xbe, 0xef,
 		0xde, 0xad, 0xfa, 0xce
 	};
 
 	unsigned int maxlen, nbytes;
-	__u8 *mem;
+	u8 *mem;
 	int is_header = 0;
 
 	if (buf == NULL)
diff --git a/drivers/media/usb/uvc/uvc_status.c b/drivers/media/usb/uvc/uvc_status.c
index b7492775e6ae..9ec160b88972 100644
--- a/drivers/media/usb/uvc/uvc_status.c
+++ b/drivers/media/usb/uvc/uvc_status.c
@@ -78,7 +78,7 @@ static void uvc_input_report_key(struct uvc_device *dev, unsigned int code,
 /* --------------------------------------------------------------------------
  * Status interrupt endpoint
  */
-static void uvc_event_streaming(struct uvc_device *dev, __u8 *data, int len)
+static void uvc_event_streaming(struct uvc_device *dev, u8 *data, int len)
 {
 	if (len < 3) {
 		uvc_trace(UVC_TRACE_STATUS, "Invalid streaming status event "
@@ -98,7 +98,7 @@ static void uvc_event_streaming(struct uvc_device *dev, __u8 *data, int len)
 	}
 }
 
-static void uvc_event_control(struct uvc_device *dev, __u8 *data, int len)
+static void uvc_event_control(struct uvc_device *dev, u8 *data, int len)
 {
 	char *attrs[3] = { "value", "info", "failure" };
 
* Unmerged path drivers/media/usb/uvc/uvc_v4l2.c
* Unmerged path drivers/media/usb/uvc/uvc_video.c
* Unmerged path drivers/media/usb/uvc/uvcvideo.h
