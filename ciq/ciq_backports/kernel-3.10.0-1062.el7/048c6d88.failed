usb: usbtmc: Add ioctls to set/get usb timeout

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [usb] usbtmc: Add ioctls to set/get usb timeout (Torez Smith) [1657401]
Rebuild_FUZZ: 94.25%
commit-author Guido Kiener <guido@kiener-muenchen.de>
commit 048c6d88a0214757926f264823829e79154fcd4f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/048c6d88.failed

Add ioctls USBTMC_IOCTL_GET_TIMEOUT / USBTMC_IOCTL_SET_TIMEOUT to
get/set I/O timeout for specific file handle.

Different operations on an instrument can take different lengths of
time thus it is important to be able to set the timeout slightly
longer than the expected duration of each operation to optimise the
responsiveness of the application. As the instrument may be shared by
multiple applications the timeout should be settable on a per file
descriptor basis.

	Tested-by: Dave Penkler <dpenkler@gmail.com>
	Reviewed-by: Steve Bayless <steve_bayless@keysight.com>
	Signed-off-by: Dave Penkler <dpenkler@gmail.com>
	Signed-off-by: Guido Kiener <guido.kiener@rohde-schwarz.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 048c6d88a0214757926f264823829e79154fcd4f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/class/usbtmc.c
diff --cc drivers/usb/class/usbtmc.c
index 9b12b21d2038,36d740c4c6fb..000000000000
--- a/drivers/usb/class/usbtmc.c
+++ b/drivers/usb/class/usbtmc.c
@@@ -107,6 -109,19 +109,21 @@@ struct usbtmc_device_data 
  };
  #define to_usbtmc_data(d) container_of(d, struct usbtmc_device_data, kref)
  
++<<<<<<< HEAD
++=======
+ /*
+  * This structure holds private data for each USBTMC file handle.
+  */
+ struct usbtmc_file_data {
+ 	struct usbtmc_device_data *data;
+ 	struct list_head file_elem;
+ 
+ 	u32            timeout;
+ 	u8             srq_byte;
+ 	atomic_t       srq_asserted;
+ };
+ 
++>>>>>>> 048c6d88a021 (usb: usbtmc: Add ioctls to set/get usb timeout)
  /* Forward declarations */
  static struct usb_driver usbtmc_driver;
  
@@@ -134,10 -153,21 +151,24 @@@ static int usbtmc_open(struct inode *in
  	/* Protect reference to data from file structure until release */
  	kref_get(&data->kref);
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&data->io_mutex);
+ 	file_data->data = data;
+ 
+ 	file_data->timeout = USBTMC_TIMEOUT;
+ 
+ 	INIT_LIST_HEAD(&file_data->file_elem);
+ 	spin_lock_irq(&data->dev_lock);
+ 	list_add_tail(&file_data->file_elem, &data->file_list);
+ 	spin_unlock_irq(&data->dev_lock);
+ 	mutex_unlock(&data->io_mutex);
+ 
++>>>>>>> 048c6d88a021 (usb: usbtmc: Add ioctls to set/get usb timeout)
  	/* Store pointer in file structure's private data field */
 -	filp->private_data = file_data;
 +	filp->private_data = data;
  
 -	return 0;
 +	return retval;
  }
  
  static int usbtmc_release(struct inode *inode, struct file *file)
@@@ -1138,8 -1197,44 +1172,43 @@@ exit
  	return rv;
  }
  
+ /*
+  * Get the usb timeout value
+  */
+ static int usbtmc_ioctl_get_timeout(struct usbtmc_file_data *file_data,
+ 				void __user *arg)
+ {
+ 	u32 timeout;
+ 
+ 	timeout = file_data->timeout;
+ 
+ 	return put_user(timeout, (__u32 __user *)arg);
+ }
+ 
+ /*
+  * Set the usb timeout value
+  */
+ static int usbtmc_ioctl_set_timeout(struct usbtmc_file_data *file_data,
+ 				void __user *arg)
+ {
+ 	u32 timeout;
+ 
+ 	if (get_user(timeout, (__u32 __user *)arg))
+ 		return -EFAULT;
+ 
+ 	/* Note that timeout = 0 means
+ 	 * MAX_SCHEDULE_TIMEOUT in usb_control_msg
+ 	 */
+ 	if (timeout < USBTMC_MIN_TIMEOUT)
+ 		return -EINVAL;
+ 
+ 	file_data->timeout = timeout;
+ 
+ 	return 0;
+ }
+ 
  static long usbtmc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
  {
 -	struct usbtmc_file_data *file_data;
  	struct usbtmc_device_data *data;
  	int retval = -EBADRQC;
  
* Unmerged path drivers/usb/class/usbtmc.c
diff --git a/include/uapi/linux/usb/tmc.h b/include/uapi/linux/usb/tmc.h
index 03f6adc8f35b..a89ffc33532e 100644
--- a/include/uapi/linux/usb/tmc.h
+++ b/include/uapi/linux/usb/tmc.h
@@ -16,6 +16,8 @@
 #ifndef __LINUX_USB_TMC_H
 #define __LINUX_USB_TMC_H
 
+#include <linux/types.h>   /* __u8 etc */
+
 /* USB TMC status values */
 #define USBTMC_STATUS_SUCCESS				0x01
 #define USBTMC_STATUS_PENDING				0x02
@@ -46,6 +48,8 @@
 #define USBTMC_IOCTL_ABORT_BULK_IN	_IO(USBTMC_IOC_NR, 4)
 #define USBTMC_IOCTL_CLEAR_OUT_HALT	_IO(USBTMC_IOC_NR, 6)
 #define USBTMC_IOCTL_CLEAR_IN_HALT	_IO(USBTMC_IOC_NR, 7)
+#define USBTMC_IOCTL_GET_TIMEOUT	_IOR(USBTMC_IOC_NR, 9, __u32)
+#define USBTMC_IOCTL_SET_TIMEOUT	_IOW(USBTMC_IOC_NR, 10, __u32)
 #define USBTMC488_IOCTL_GET_CAPS	_IOR(USBTMC_IOC_NR, 17, unsigned char)
 #define USBTMC488_IOCTL_READ_STB	_IOR(USBTMC_IOC_NR, 18, unsigned char)
 #define USBTMC488_IOCTL_REN_CONTROL	_IOW(USBTMC_IOC_NR, 19, unsigned char)
