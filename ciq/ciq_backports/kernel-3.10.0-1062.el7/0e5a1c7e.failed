netfilter: nf_tables: use hook state from xt_action_param structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 0e5a1c7eb3fc705c4cc6c1e058e81d1f2e721c72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/0e5a1c7e.failed

Don't copy relevant fields from hook state structure, instead use the
one that is already available in struct xt_action_param.

This patch also adds a set of new wrapper functions to fetch relevant
hook state structure fields.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 0e5a1c7eb3fc705c4cc6c1e058e81d1f2e721c72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables.h
#	net/bridge/netfilter/nft_reject_bridge.c
#	net/ipv4/netfilter/nft_dup_ipv4.c
#	net/ipv4/netfilter/nft_fib_ipv4.c
#	net/ipv4/netfilter/nft_reject_ipv4.c
#	net/ipv6/netfilter/nft_dup_ipv6.c
#	net/ipv6/netfilter/nft_fib_ipv6.c
#	net/ipv6/netfilter/nft_reject_ipv6.c
#	net/netfilter/nf_dup_netdev.c
#	net/netfilter/nf_tables_core.c
#	net/netfilter/nf_tables_trace.c
#	net/netfilter/nft_fib.c
#	net/netfilter/nft_fib_inet.c
#	net/netfilter/nft_log.c
#	net/netfilter/nft_lookup.c
#	net/netfilter/nft_meta.c
#	net/netfilter/nft_reject_inet.c
#	net/netfilter/nft_rt.c
diff --cc include/net/netfilter/nf_tables.h
index aefa47fab07d,3295fb85bff6..000000000000
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@@ -14,18 -14,35 +14,48 @@@
  
  struct nft_pktinfo {
  	struct sk_buff			*skb;
++<<<<<<< HEAD
 +	const struct net_device		*in;
 +	const struct net_device		*out;
 +	u8				pf;
 +	u8				hook;
++=======
+ 	bool				tprot_set;
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  	u8				tprot;
  	/* for x_tables compatibility */
  	struct xt_action_param		xt;
  };
  
++<<<<<<< HEAD
 +static inline struct net *pkt_net(const struct nft_pktinfo *pkt)
 +{
 +	return dev_net(pkt->in ? pkt->in : pkt->out);
++=======
+ static inline struct net *nft_net(const struct nft_pktinfo *pkt)
+ {
+ 	return pkt->xt.state->net;
+ }
+ 
+ static inline unsigned int nft_hook(const struct nft_pktinfo *pkt)
+ {
+ 	return pkt->xt.state->hook;
+ }
+ 
+ static inline u8 nft_pf(const struct nft_pktinfo *pkt)
+ {
+ 	return pkt->xt.state->pf;
+ }
+ 
+ static inline const struct net_device *nft_in(const struct nft_pktinfo *pkt)
+ {
+ 	return pkt->xt.state->in;
+ }
+ 
+ static inline const struct net_device *nft_out(const struct nft_pktinfo *pkt)
+ {
+ 	return pkt->xt.state->out;
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  }
  
  static inline void nft_set_pktinfo(struct nft_pktinfo *pkt,
@@@ -33,10 -50,24 +63,31 @@@
  				   const struct nf_hook_state *state)
  {
  	pkt->skb = skb;
++<<<<<<< HEAD
 +	pkt->in = pkt->xt.in = state->in;
 +	pkt->out = pkt->xt.out = state->out;
 +	pkt->hook = pkt->xt.hooknum = state->hook;
 +	pkt->pf = pkt->xt.family = state->pf;
++=======
+ 	pkt->xt.state = state;
+ }
+ 
+ static inline void nft_set_pktinfo_proto_unspec(struct nft_pktinfo *pkt,
+ 						struct sk_buff *skb)
+ {
+ 	pkt->tprot_set = false;
+ 	pkt->tprot = 0;
+ 	pkt->xt.thoff = 0;
+ 	pkt->xt.fragoff = 0;
+ }
+ 
+ static inline void nft_set_pktinfo_unspec(struct nft_pktinfo *pkt,
+ 					  struct sk_buff *skb,
+ 					  const struct nf_hook_state *state)
+ {
+ 	nft_set_pktinfo(pkt, skb, state);
+ 	nft_set_pktinfo_proto_unspec(pkt, skb);
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  }
  
  /**
diff --cc net/bridge/netfilter/nft_reject_bridge.c
index 63db6a0ed327,206dc266ecd2..000000000000
--- a/net/bridge/netfilter/nft_reject_bridge.c
+++ b/net/bridge/netfilter/nft_reject_bridge.c
@@@ -267,17 -315,20 +267,34 @@@ static void nft_reject_bridge_eval(cons
  	case htons(ETH_P_IP):
  		switch (priv->type) {
  		case NFT_REJECT_ICMP_UNREACH:
++<<<<<<< HEAD
 +			nft_reject_br_send_v4_unreach(pkt_net(pkt), pkt->skb,
 +						      pkt->in, pkt->hook,
 +						      priv->icmp_code);
 +			break;
 +		case NFT_REJECT_TCP_RST:
 +			nft_reject_br_send_v4_tcp_reset(pkt_net(pkt), pkt->skb,
 +							pkt->in, pkt->hook);
 +			break;
 +		case NFT_REJECT_ICMPX_UNREACH:
 +			nft_reject_br_send_v4_unreach(pkt_net(pkt), pkt->skb,
 +						      pkt->in, pkt->hook,
++=======
+ 			nft_reject_br_send_v4_unreach(nft_net(pkt), pkt->skb,
+ 						      nft_in(pkt),
+ 						      nft_hook(pkt),
+ 						      priv->icmp_code);
+ 			break;
+ 		case NFT_REJECT_TCP_RST:
+ 			nft_reject_br_send_v4_tcp_reset(nft_net(pkt), pkt->skb,
+ 							nft_in(pkt),
+ 							nft_hook(pkt));
+ 			break;
+ 		case NFT_REJECT_ICMPX_UNREACH:
+ 			nft_reject_br_send_v4_unreach(nft_net(pkt), pkt->skb,
+ 						      nft_in(pkt),
+ 						      nft_hook(pkt),
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  						      nft_reject_icmp_code(priv->icmp_code));
  			break;
  		}
@@@ -285,17 -336,20 +302,34 @@@
  	case htons(ETH_P_IPV6):
  		switch (priv->type) {
  		case NFT_REJECT_ICMP_UNREACH:
++<<<<<<< HEAD
 +			nft_reject_br_send_v6_unreach(net, pkt->skb, pkt->in,
 +						      pkt->hook,
 +						      priv->icmp_code);
 +			break;
 +		case NFT_REJECT_TCP_RST:
 +			nft_reject_br_send_v6_tcp_reset(net, pkt->skb, pkt->in,
 +							pkt->hook);
 +			break;
 +		case NFT_REJECT_ICMPX_UNREACH:
 +			nft_reject_br_send_v6_unreach(net, pkt->skb, pkt->in,
 +						      pkt->hook,
++=======
+ 			nft_reject_br_send_v6_unreach(nft_net(pkt), pkt->skb,
+ 						      nft_in(pkt),
+ 						      nft_hook(pkt),
+ 						      priv->icmp_code);
+ 			break;
+ 		case NFT_REJECT_TCP_RST:
+ 			nft_reject_br_send_v6_tcp_reset(nft_net(pkt), pkt->skb,
+ 							nft_in(pkt),
+ 							nft_hook(pkt));
+ 			break;
+ 		case NFT_REJECT_ICMPX_UNREACH:
+ 			nft_reject_br_send_v6_unreach(nft_net(pkt), pkt->skb,
+ 						      nft_in(pkt),
+ 						      nft_hook(pkt),
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  						      nft_reject_icmpv6_code(priv->icmp_code));
  			break;
  		}
diff --cc net/ipv4/netfilter/nft_dup_ipv4.c
index 30bcf820e8bd,7ab544fbc382..000000000000
--- a/net/ipv4/netfilter/nft_dup_ipv4.c
+++ b/net/ipv4/netfilter/nft_dup_ipv4.c
@@@ -30,7 -30,7 +30,11 @@@ static void nft_dup_ipv4_eval(const str
  	};
  	int oif = regs->data[priv->sreg_dev];
  
++<<<<<<< HEAD
 +	nf_dup_ipv4(pkt->skb, pkt->hook, &gw, oif);
++=======
+ 	nf_dup_ipv4(nft_net(pkt), pkt->skb, nft_hook(pkt), &gw, oif);
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  }
  
  static int nft_dup_ipv4_init(const struct nft_ctx *ctx,
diff --cc net/ipv4/netfilter/nft_reject_ipv4.c
index adc30e649da7,517ce93699de..000000000000
--- a/net/ipv4/netfilter/nft_reject_ipv4.c
+++ b/net/ipv4/netfilter/nft_reject_ipv4.c
@@@ -27,10 -27,10 +27,14 @@@ static void nft_reject_ipv4_eval(const 
  
  	switch (priv->type) {
  	case NFT_REJECT_ICMP_UNREACH:
- 		nf_send_unreach(pkt->skb, priv->icmp_code, pkt->hook);
+ 		nf_send_unreach(pkt->skb, priv->icmp_code, nft_hook(pkt));
  		break;
  	case NFT_REJECT_TCP_RST:
++<<<<<<< HEAD
 +		nf_send_reset(pkt->skb, pkt->hook);
++=======
+ 		nf_send_reset(nft_net(pkt), pkt->skb, nft_hook(pkt));
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  		break;
  	default:
  		break;
diff --cc net/ipv6/netfilter/nft_dup_ipv6.c
index c81204faf15d,26074a8bada7..000000000000
--- a/net/ipv6/netfilter/nft_dup_ipv6.c
+++ b/net/ipv6/netfilter/nft_dup_ipv6.c
@@@ -28,7 -28,7 +28,11 @@@ static void nft_dup_ipv6_eval(const str
  	struct in6_addr *gw = (struct in6_addr *)&regs->data[priv->sreg_addr];
  	int oif = regs->data[priv->sreg_dev];
  
++<<<<<<< HEAD
 +	nf_dup_ipv6(pkt->skb, pkt->hook, gw, oif);
++=======
+ 	nf_dup_ipv6(nft_net(pkt), pkt->skb, nft_hook(pkt), gw, oif);
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  }
  
  static int nft_dup_ipv6_init(const struct nft_ctx *ctx,
diff --cc net/ipv6/netfilter/nft_reject_ipv6.c
index 0abb30cc68c3,057deeaff1cb..000000000000
--- a/net/ipv6/netfilter/nft_reject_ipv6.c
+++ b/net/ipv6/netfilter/nft_reject_ipv6.c
@@@ -28,10 -27,11 +28,18 @@@ static void nft_reject_ipv6_eval(const 
  
  	switch (priv->type) {
  	case NFT_REJECT_ICMP_UNREACH:
++<<<<<<< HEAD
 +		nf_send_unreach6(net, pkt->skb, priv->icmp_code, pkt->hook);
 +		break;
 +	case NFT_REJECT_TCP_RST:
 +		nf_send_reset6(net, pkt->skb, pkt->hook);
++=======
+ 		nf_send_unreach6(nft_net(pkt), pkt->skb, priv->icmp_code,
+ 				 nft_hook(pkt));
+ 		break;
+ 	case NFT_REJECT_TCP_RST:
+ 		nf_send_reset6(nft_net(pkt), pkt->skb, nft_hook(pkt));
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  		break;
  	default:
  		break;
diff --cc net/netfilter/nf_tables_core.c
index 7f1a318d68a3,b63b1edb76a6..000000000000
--- a/net/netfilter/nf_tables_core.c
+++ b/net/netfilter/nf_tables_core.c
@@@ -52,10 -53,10 +52,17 @@@ static noinline void __nft_trace_packet
  
  	nft_trace_notify(info);
  
++<<<<<<< HEAD
 +	nf_log_trace(pkt_net(pkt), pkt->pf, pkt->hook, pkt->skb, pkt->in,
 +		     pkt->out, &trace_loginfo, "TRACE: %s:%s:%s:%u ",
 +		     chain->table->name, chain->name, comments[type],
 +		     rulenum);
++=======
+ 	nf_log_trace(nft_net(pkt), nft_pf(pkt), nft_hook(pkt), pkt->skb,
+ 		     nft_in(pkt), nft_out(pkt), &trace_loginfo,
+ 		     "TRACE: %s:%s:%s:%u ",
+ 		     chain->table->name, chain->name, comments[type], rulenum);
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  }
  
  static inline void nft_trace_packet(struct nft_traceinfo *info,
@@@ -117,11 -121,10 +124,16 @@@ struct nft_jumpstack 
  };
  
  unsigned int
 -nft_do_chain(struct nft_pktinfo *pkt, void *priv)
 +nft_do_chain(struct nft_pktinfo *pkt, const struct nf_hook_ops *ops)
  {
++<<<<<<< HEAD
 +	const struct nft_chain *chain = ops->priv, *basechain = chain;
 +	const struct net *chain_net = read_pnet(&nft_base_chain(basechain)->pnet);
 +	const struct net *net = dev_net(pkt->in ? pkt->in : pkt->out);
++=======
+ 	const struct nft_chain *chain = priv, *basechain = chain;
+ 	const struct net *net = nft_net(pkt);
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  	const struct nft_rule *rule;
  	const struct nft_expr *expr, *last;
  	struct nft_regs regs;
diff --cc net/netfilter/nf_tables_trace.c
index 9f529c90dabb,12eb9041dca2..000000000000
--- a/net/netfilter/nf_tables_trace.c
+++ b/net/netfilter/nf_tables_trace.c
@@@ -169,7 -171,7 +169,11 @@@ void nft_trace_notify(struct nft_tracei
  	unsigned int size;
  	int event = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_TRACE;
  
++<<<<<<< HEAD
 +	if (!nfnetlink_has_listeners(pkt_net(pkt), NFNLGRP_NFTRACE))
++=======
+ 	if (!nfnetlink_has_listeners(nft_net(pkt), NFNLGRP_NFTRACE))
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  		return;
  
  	size = nlmsg_total_size(sizeof(struct nfgenmsg)) +
@@@ -256,7 -258,7 +260,11 @@@
  	}
  
  	nlmsg_end(skb, nlh);
++<<<<<<< HEAD
 +	nfnetlink_send(skb, pkt_net(pkt), 0, NFNLGRP_NFTRACE, 0, GFP_ATOMIC);
++=======
+ 	nfnetlink_send(skb, nft_net(pkt), 0, NFNLGRP_NFTRACE, 0, GFP_ATOMIC);
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  	return;
  
   nla_put_failure:
diff --cc net/netfilter/nft_log.c
index af868c1dc6ae,6271e40a3dd6..000000000000
--- a/net/netfilter/nft_log.c
+++ b/net/netfilter/nft_log.c
@@@ -31,10 -31,10 +31,16 @@@ static void nft_log_eval(const struct n
  			 const struct nft_pktinfo *pkt)
  {
  	const struct nft_log *priv = nft_expr_priv(expr);
 +	struct net *net = dev_net(pkt->in ? pkt->in : pkt->out);
  
++<<<<<<< HEAD
 +	nf_log_packet(net, pkt->pf, pkt->hook, pkt->skb, pkt->in,
 +		      pkt->out, &priv->loginfo, "%s", priv->prefix);
++=======
+ 	nf_log_packet(nft_net(pkt), nft_pf(pkt), nft_hook(pkt), pkt->skb,
+ 		      nft_in(pkt), nft_out(pkt), &priv->loginfo, "%s",
+ 		      priv->prefix);
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  }
  
  static const struct nla_policy nft_log_policy[NFTA_LOG_MAX + 1] = {
diff --cc net/netfilter/nft_lookup.c
index c9ce7d60cd73,a8ce49bcda80..000000000000
--- a/net/netfilter/nft_lookup.c
+++ b/net/netfilter/nft_lookup.c
@@@ -35,9 -35,8 +35,14 @@@ static void nft_lookup_eval(const struc
  	const struct nft_set_ext *ext;
  	bool found;
  
++<<<<<<< HEAD
 +	found = set->ops->lookup(set, &regs->data[priv->sreg], &ext) ^
 +		priv->invert;
 +
++=======
+ 	found = set->ops->lookup(nft_net(pkt), set, &regs->data[priv->sreg],
+ 				 &ext) ^ priv->invert;
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  	if (!found) {
  		regs->verdict.code = NFT_BREAK;
  		return;
diff --cc net/netfilter/nft_meta.c
index 5c2aa110f022,66c7f4b4c49b..000000000000
--- a/net/netfilter/nft_meta.c
+++ b/net/netfilter/nft_meta.c
@@@ -43,13 -45,16 +43,17 @@@ void nft_meta_get_eval(const struct nft
  		*dest = skb->len;
  		break;
  	case NFT_META_PROTOCOL:
 -		*dest = 0;
 -		*(__be16 *)dest = skb->protocol;
 +		nft_reg_store16(dest, (__force u16)skb->protocol);
  		break;
  	case NFT_META_NFPROTO:
++<<<<<<< HEAD
 +		nft_reg_store8(dest, pkt->pf);
++=======
+ 		*dest = nft_pf(pkt);
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  		break;
  	case NFT_META_L4PROTO:
 -		if (!pkt->tprot_set)
 -			goto err;
 -		*dest = pkt->tprot;
 +		nft_reg_store8(dest, pkt->tprot);
  		break;
  	case NFT_META_PRIORITY:
  		*dest = skb->priority;
@@@ -139,12 -146,12 +143,12 @@@
  			break;
  		}
  
- 		switch (pkt->pf) {
+ 		switch (nft_pf(pkt)) {
  		case NFPROTO_IPV4:
  			if (ipv4_is_multicast(ip_hdr(skb)->daddr))
 -				*dest = PACKET_MULTICAST;
 +				nft_reg_store8(dest, PACKET_MULTICAST);
  			else
 -				*dest = PACKET_BROADCAST;
 +				nft_reg_store8(dest, PACKET_BROADCAST);
  			break;
  		case NFPROTO_IPV6:
  			if (ipv6_hdr(skb)->daddr.s6_addr[0] == 0xFF)
diff --cc net/netfilter/nft_reject_inet.c
index 912bf65f32e3,9e90a02cb104..000000000000
--- a/net/netfilter/nft_reject_inet.c
+++ b/net/netfilter/nft_reject_inet.c
@@@ -22,17 -22,16 +22,21 @@@ static void nft_reject_inet_eval(const 
  				 const struct nft_pktinfo *pkt)
  {
  	struct nft_reject *priv = nft_expr_priv(expr);
 +	struct net *net = dev_net((pkt->in != NULL) ? pkt->in : pkt->out);
  
- 	switch (pkt->pf) {
+ 	switch (nft_pf(pkt)) {
  	case NFPROTO_IPV4:
  		switch (priv->type) {
  		case NFT_REJECT_ICMP_UNREACH:
  			nf_send_unreach(pkt->skb, priv->icmp_code,
- 					pkt->hook);
+ 					nft_hook(pkt));
  			break;
  		case NFT_REJECT_TCP_RST:
++<<<<<<< HEAD
 +			nf_send_reset(pkt->skb, pkt->hook);
++=======
+ 			nf_send_reset(nft_net(pkt), pkt->skb, nft_hook(pkt));
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  			break;
  		case NFT_REJECT_ICMPX_UNREACH:
  			nf_send_unreach(pkt->skb,
@@@ -44,16 -43,16 +48,27 @@@
  	case NFPROTO_IPV6:
  		switch (priv->type) {
  		case NFT_REJECT_ICMP_UNREACH:
++<<<<<<< HEAD
 +			nf_send_unreach6(net, pkt->skb, priv->icmp_code,
 +					 pkt->hook);
 +			break;
 +		case NFT_REJECT_TCP_RST:
 +			nf_send_reset6(net, pkt->skb, pkt->hook);
 +			break;
 +		case NFT_REJECT_ICMPX_UNREACH:
 +			nf_send_unreach6(net, pkt->skb,
++=======
+ 			nf_send_unreach6(nft_net(pkt), pkt->skb,
+ 					 priv->icmp_code, nft_hook(pkt));
+ 			break;
+ 		case NFT_REJECT_TCP_RST:
+ 			nf_send_reset6(nft_net(pkt), pkt->skb, nft_hook(pkt));
+ 			break;
+ 		case NFT_REJECT_ICMPX_UNREACH:
+ 			nf_send_unreach6(nft_net(pkt), pkt->skb,
++>>>>>>> 0e5a1c7eb3fc (netfilter: nf_tables: use hook state from xt_action_param structure)
  					 nft_reject_icmpv6_code(priv->icmp_code),
- 					 pkt->hook);
+ 					 nft_hook(pkt));
  			break;
  		}
  		break;
* Unmerged path net/ipv4/netfilter/nft_fib_ipv4.c
* Unmerged path net/ipv6/netfilter/nft_fib_ipv6.c
* Unmerged path net/netfilter/nf_dup_netdev.c
* Unmerged path net/netfilter/nft_fib.c
* Unmerged path net/netfilter/nft_fib_inet.c
* Unmerged path net/netfilter/nft_rt.c
* Unmerged path include/net/netfilter/nf_tables.h
diff --git a/net/bridge/netfilter/nft_meta_bridge.c b/net/bridge/netfilter/nft_meta_bridge.c
index 4b901d9f2e7c..00ea783dfd19 100644
--- a/net/bridge/netfilter/nft_meta_bridge.c
+++ b/net/bridge/netfilter/nft_meta_bridge.c
@@ -23,7 +23,7 @@ static void nft_meta_bridge_get_eval(const struct nft_expr *expr,
 				     const struct nft_pktinfo *pkt)
 {
 	const struct nft_meta *priv = nft_expr_priv(expr);
-	const struct net_device *in = pkt->in, *out = pkt->out;
+	const struct net_device *in = nft_in(pkt), *out = nft_out(pkt);
 	u32 *dest = &regs->data[priv->dreg];
 	const struct net_bridge_port *p;
 
* Unmerged path net/bridge/netfilter/nft_reject_bridge.c
* Unmerged path net/ipv4/netfilter/nft_dup_ipv4.c
* Unmerged path net/ipv4/netfilter/nft_fib_ipv4.c
diff --git a/net/ipv4/netfilter/nft_masq_ipv4.c b/net/ipv4/netfilter/nft_masq_ipv4.c
index dc3628a396ec..11fef74b41bf 100644
--- a/net/ipv4/netfilter/nft_masq_ipv4.c
+++ b/net/ipv4/netfilter/nft_masq_ipv4.c
@@ -31,8 +31,8 @@ static void nft_masq_ipv4_eval(const struct nft_expr *expr,
 		range.max_proto.all = (__force __be16)nft_reg_load16(
 			&regs->data[priv->sreg_proto_max]);
 	}
-	regs->verdict.code = nf_nat_masquerade_ipv4(pkt->skb, pkt->hook,
-						    &range, pkt->out);
+	regs->verdict.code = nf_nat_masquerade_ipv4(pkt->skb, nft_hook(pkt),
+						    &range, nft_out(pkt));
 }
 
 static struct nft_expr_type nft_masq_ipv4_type;
diff --git a/net/ipv4/netfilter/nft_redir_ipv4.c b/net/ipv4/netfilter/nft_redir_ipv4.c
index f760524e1353..4f13d9d69244 100644
--- a/net/ipv4/netfilter/nft_redir_ipv4.c
+++ b/net/ipv4/netfilter/nft_redir_ipv4.c
@@ -35,8 +35,7 @@ static void nft_redir_ipv4_eval(const struct nft_expr *expr,
 
 	mr.range[0].flags |= priv->flags;
 
-	regs->verdict.code = nf_nat_redirect_ipv4(pkt->skb, &mr,
-						  pkt->hook);
+	regs->verdict.code = nf_nat_redirect_ipv4(pkt->skb, &mr, nft_hook(pkt));
 }
 
 static struct nft_expr_type nft_redir_ipv4_type;
* Unmerged path net/ipv4/netfilter/nft_reject_ipv4.c
* Unmerged path net/ipv6/netfilter/nft_dup_ipv6.c
* Unmerged path net/ipv6/netfilter/nft_fib_ipv6.c
diff --git a/net/ipv6/netfilter/nft_masq_ipv6.c b/net/ipv6/netfilter/nft_masq_ipv6.c
index b74a420050c4..810e92fba72d 100644
--- a/net/ipv6/netfilter/nft_masq_ipv6.c
+++ b/net/ipv6/netfilter/nft_masq_ipv6.c
@@ -32,7 +32,8 @@ static void nft_masq_ipv6_eval(const struct nft_expr *expr,
 		range.max_proto.all = (__force __be16)nft_reg_load16(
 			&regs->data[priv->sreg_proto_max]);
 	}
-	regs->verdict.code = nf_nat_masquerade_ipv6(pkt->skb, &range, pkt->out);
+	regs->verdict.code = nf_nat_masquerade_ipv6(pkt->skb, &range,
+						    nft_out(pkt));
 }
 
 static struct nft_expr_type nft_masq_ipv6_type;
diff --git a/net/ipv6/netfilter/nft_redir_ipv6.c b/net/ipv6/netfilter/nft_redir_ipv6.c
index 7ef58e493fca..a2c84d27791a 100644
--- a/net/ipv6/netfilter/nft_redir_ipv6.c
+++ b/net/ipv6/netfilter/nft_redir_ipv6.c
@@ -35,7 +35,8 @@ static void nft_redir_ipv6_eval(const struct nft_expr *expr,
 
 	range.flags |= priv->flags;
 
-	regs->verdict.code = nf_nat_redirect_ipv6(pkt->skb, &range, pkt->hook);
+	regs->verdict.code =
+		nf_nat_redirect_ipv6(pkt->skb, &range, nft_hook(pkt));
 }
 
 static struct nft_expr_type nft_redir_ipv6_type;
* Unmerged path net/ipv6/netfilter/nft_reject_ipv6.c
* Unmerged path net/netfilter/nf_dup_netdev.c
* Unmerged path net/netfilter/nf_tables_core.c
* Unmerged path net/netfilter/nf_tables_trace.c
* Unmerged path net/netfilter/nft_fib.c
* Unmerged path net/netfilter/nft_fib_inet.c
* Unmerged path net/netfilter/nft_log.c
* Unmerged path net/netfilter/nft_lookup.c
* Unmerged path net/netfilter/nft_meta.c
diff --git a/net/netfilter/nft_queue.c b/net/netfilter/nft_queue.c
index 61d216eb7917..87817c80ef78 100644
--- a/net/netfilter/nft_queue.c
+++ b/net/netfilter/nft_queue.c
@@ -42,7 +42,7 @@ static void nft_queue_eval(const struct nft_expr *expr,
 			queue = priv->queuenum + cpu % priv->queues_total;
 		} else {
 			queue = nfqueue_hash(pkt->skb, queue,
-					     priv->queues_total, pkt->pf,
+					     priv->queues_total, nft_pf(pkt),
 					     jhash_initval);
 		}
 	}
* Unmerged path net/netfilter/nft_reject_inet.c
* Unmerged path net/netfilter/nft_rt.c
