perf llvm: Extract helpers in llvm-utils.c

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Wang Nan <wangnan0@huawei.com>
commit 2bd42de0e196f89994cbae1990d2c7c5a9b6a529
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/2bd42de0.failed

The following commits will use builtin clang to compile BPF scripts.

llvm__get_kbuild_opts() and llvm__get_nr_cpus() are extracted to help
building '-DKERNEL_VERSION_CODE' and '-D__NR_CPUS__' macros.

Doing object dumping in bpf loader, so further builtin clang compiling
needn't consider it.

	Signed-off-by: Wang Nan <wangnan0@huawei.com>
	Cc: Alexei Starovoitov <ast@fb.com>
	Cc: He Kuang <hekuang@huawei.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Joe Stringer <joe@ovn.org>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: pi3orama@163.com
Link: http://lkml.kernel.org/r/20161126070354.141764-7-wangnan0@huawei.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 2bd42de0e196f89994cbae1990d2c7c5a9b6a529)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/bpf-loader.c
#	tools/perf/util/llvm-utils.c
diff --cc tools/perf/util/bpf-loader.c
index 39bf9252ae96,cf16b94115b5..000000000000
--- a/tools/perf/util/bpf-loader.c
+++ b/tools/perf/util/bpf-loader.c
@@@ -39,10 -61,46 +39,51 @@@ struct bpf_object *bpf__prepare_load(co
  		libbpf_initialized = true;
  	}
  
++<<<<<<< HEAD
 +	obj = bpf_object__open(filename);
 +	if (!obj) {
++=======
+ 	obj = bpf_object__open_buffer(obj_buf, obj_buf_sz, name);
+ 	if (IS_ERR(obj)) {
+ 		pr_debug("bpf: failed to load buffer\n");
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	return obj;
+ }
+ 
+ struct bpf_object *bpf__prepare_load(const char *filename, bool source)
+ {
+ 	struct bpf_object *obj;
+ 
+ 	if (!libbpf_initialized) {
+ 		libbpf_set_print(libbpf_warning,
+ 				 libbpf_info,
+ 				 libbpf_debug);
+ 		libbpf_initialized = true;
+ 	}
+ 
+ 	if (source) {
+ 		int err;
+ 		void *obj_buf;
+ 		size_t obj_buf_sz;
+ 
+ 		err = llvm__compile_bpf(filename, &obj_buf, &obj_buf_sz);
+ 		if (err)
+ 			return ERR_PTR(-BPF_LOADER_ERRNO__COMPILE);
+ 		obj = bpf_object__open_buffer(obj_buf, obj_buf_sz, filename);
+ 
+ 		if (!IS_ERR(obj) && llvm_param.dump_obj)
+ 			llvm__dump_obj(filename, obj_buf, obj_buf_sz);
+ 
+ 		free(obj_buf);
+ 	} else
+ 		obj = bpf_object__open(filename);
+ 
+ 	if (IS_ERR(obj)) {
++>>>>>>> 2bd42de0e196 (perf llvm: Extract helpers in llvm-utils.c)
  		pr_debug("bpf: failed to load %s\n", filename);
 -		return obj;
 +		return ERR_PTR(-EINVAL);
  	}
  
  	return obj;
diff --cc tools/perf/util/llvm-utils.c
index 1094f8780b7a,b23ff44cf214..000000000000
--- a/tools/perf/util/llvm-utils.c
+++ b/tools/perf/util/llvm-utils.c
@@@ -6,7 -6,8 +6,12 @@@
  #include <errno.h>
  #include <limits.h>
  #include <stdio.h>
++<<<<<<< HEAD
 +#include <sys/utsname.h>
++=======
+ #include <stdlib.h>
+ #include <linux/err.h>
++>>>>>>> 2bd42de0e196 (perf llvm: Extract helpers in llvm-utils.c)
  #include "debug.h"
  #include "llvm-utils.h"
  #include "config.h"
@@@ -325,8 -349,73 +349,76 @@@ void llvm__get_kbuild_opts(char **kbuil
  	}
  
  	pr_debug("include option is set to %s\n", *kbuild_include_opts);
+ 
+ 	saved_kbuild_dir = strdup(*kbuild_dir);
+ 	saved_kbuild_include_opts = strdup(*kbuild_include_opts);
+ 
+ 	if (!saved_kbuild_dir || !saved_kbuild_include_opts) {
+ 		zfree(&saved_kbuild_dir);
+ 		zfree(&saved_kbuild_include_opts);
+ 	}
+ 	return;
+ errout:
+ 	saved_kbuild_dir = ERR_PTR(-EINVAL);
+ 	saved_kbuild_include_opts = ERR_PTR(-EINVAL);
+ }
+ 
++<<<<<<< HEAD
++=======
+ int llvm__get_nr_cpus(void)
+ {
+ 	static int nr_cpus_avail = 0;
+ 	char serr[STRERR_BUFSIZE];
+ 
+ 	if (nr_cpus_avail > 0)
+ 		return nr_cpus_avail;
+ 
+ 	nr_cpus_avail = sysconf(_SC_NPROCESSORS_CONF);
+ 	if (nr_cpus_avail <= 0) {
+ 		pr_err(
+ "WARNING:\tunable to get available CPUs in this system: %s\n"
+ "        \tUse 128 instead.\n", str_error_r(errno, serr, sizeof(serr)));
+ 		nr_cpus_avail = 128;
+ 	}
+ 	return nr_cpus_avail;
  }
  
+ void llvm__dump_obj(const char *path, void *obj_buf, size_t size)
+ {
+ 	char *obj_path = strdup(path);
+ 	FILE *fp;
+ 	char *p;
+ 
+ 	if (!obj_path) {
+ 		pr_warning("WARNING: Not enough memory, skip object dumping\n");
+ 		return;
+ 	}
+ 
+ 	p = strrchr(obj_path, '.');
+ 	if (!p || (strcmp(p, ".c") != 0)) {
+ 		pr_warning("WARNING: invalid llvm source path: '%s', skip object dumping\n",
+ 			   obj_path);
+ 		goto out;
+ 	}
+ 
+ 	p[1] = 'o';
+ 	fp = fopen(obj_path, "wb");
+ 	if (!fp) {
+ 		pr_warning("WARNING: failed to open '%s': %s, skip object dumping\n",
+ 			   obj_path, strerror(errno));
+ 		goto out;
+ 	}
+ 
+ 	pr_info("LLVM: dumping %s\n", obj_path);
+ 	if (fwrite(obj_buf, size, 1, fp) != 1)
+ 		pr_warning("WARNING: failed to write to file '%s': %s, skip object dumping\n",
+ 			   obj_path, strerror(errno));
+ 	fclose(fp);
+ out:
+ 	free(obj_path);
+ }
+ 
++>>>>>>> 2bd42de0e196 (perf llvm: Extract helpers in llvm-utils.c)
  int llvm__compile_bpf(const char *path, void **p_obj_buf,
  		      size_t *p_obj_buf_sz)
  {
@@@ -364,8 -455,20 +456,23 @@@
  	 * This is an optional work. Even it fail we can continue our
  	 * work. Needn't to check error return.
  	 */
- 	get_kbuild_opts(&kbuild_dir, &kbuild_include_opts);
+ 	llvm__get_kbuild_opts(&kbuild_dir, &kbuild_include_opts);
+ 
++<<<<<<< HEAD
++=======
+ 	nr_cpus_avail = llvm__get_nr_cpus();
+ 	snprintf(nr_cpus_avail_str, sizeof(nr_cpus_avail_str), "%d",
+ 		 nr_cpus_avail);
+ 
+ 	if (fetch_kernel_version(&kernel_version, NULL, 0))
+ 		kernel_version = 0;
  
+ 	snprintf(linux_version_code_str, sizeof(linux_version_code_str),
+ 		 "0x%x", kernel_version);
+ 
+ 	force_set_env("NR_CPUS", nr_cpus_avail_str);
+ 	force_set_env("LINUX_VERSION_CODE", linux_version_code_str);
++>>>>>>> 2bd42de0e196 (perf llvm: Extract helpers in llvm-utils.c)
  	force_set_env("CLANG_EXEC", clang_path);
  	force_set_env("CLANG_OPTIONS", clang_opt);
  	force_set_env("KERNEL_INC_OPTIONS", kbuild_include_opts);
@@@ -392,6 -495,7 +499,10 @@@
  
  	free(kbuild_dir);
  	free(kbuild_include_opts);
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> 2bd42de0e196 (perf llvm: Extract helpers in llvm-utils.c)
  	if (!p_obj_buf)
  		free(obj_buf);
  	else
* Unmerged path tools/perf/util/bpf-loader.c
* Unmerged path tools/perf/util/llvm-utils.c
diff --git a/tools/perf/util/llvm-utils.h b/tools/perf/util/llvm-utils.h
index 5861fbff0c0d..746092a62872 100644
--- a/tools/perf/util/llvm-utils.h
+++ b/tools/perf/util/llvm-utils.h
@@ -39,4 +39,10 @@ int llvm__compile_bpf(const char *path, void **p_obj_buf,
 
 /* This function is for test__llvm() use only */
 int llvm__search_clang(void);
+
+/* Following functions are reused by builtin clang support */
+void llvm__get_kbuild_opts(char **kbuild_dir, char **kbuild_include_opts);
+int llvm__get_nr_cpus(void);
+
+void llvm__dump_obj(const char *path, void *obj_buf, size_t size);
 #endif
