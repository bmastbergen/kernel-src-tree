selinux: use separate table for initial SID lookup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Ondrej Mosnacek <omosnace@redhat.com>
commit 24ed7fdae669feda4c5e0dadba2467c4c0d297d3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/24ed7fda.failed

This moves handling of initial SIDs into a separate table. Note that the
SIDs stored in the main table are now shifted by SECINITSID_NUM and
converted to/from the actual SIDs transparently by helper functions.

This change doesn't make much sense on its own, but it simplifies
further sidtab overhaul in a succeeding patch.

	Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
	Reviewed-by: Stephen Smalley <sds@tycho.nsa.gov>
[PM: fixed some checkpatch warnings on line length, whitespace]
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit 24ed7fdae669feda4c5e0dadba2467c4c0d297d3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/ss/services.c
#	security/selinux/ss/services.h
#	security/selinux/ss/sidtab.c
#	security/selinux/ss/sidtab.h
diff --cc security/selinux/ss/services.c
index f2e85744961c,4ff4b0edbf6b..000000000000
--- a/security/selinux/ss/services.c
+++ b/security/selinux/ss/services.c
@@@ -790,16 -769,21 +790,21 @@@ int security_validate_transition(u32 ol
  	u16 tclass;
  	int rc = 0;
  
 -
 -	if (!state->initialized)
 +	if (!ss_initialized)
  		return 0;
  
 -	read_lock(&state->ss->policy_rwlock);
 +	read_lock(&policy_rwlock);
  
++<<<<<<< HEAD
 +	tclass = unmap_class(orig_tclass);
++=======
+ 	policydb = &state->ss->policydb;
+ 	sidtab = state->ss->sidtab;
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  
 -	if (!user)
 -		tclass = unmap_class(&state->ss->map, orig_tclass);
 -	else
 -		tclass = orig_tclass;
 -
 -	if (!tclass || tclass > policydb->p_classes.nprim) {
 +	if (!tclass || tclass > policydb.p_classes.nprim) {
 +		printk(KERN_ERR "SELinux: %s:  unrecognized class %d\n",
 +			__func__, tclass);
  		rc = -EINVAL;
  		goto out;
  	}
@@@ -861,12 -870,18 +866,22 @@@ int security_bounded_transition(u32 old
  	int index;
  	int rc;
  
++<<<<<<< HEAD
 +	read_lock(&policy_rwlock);
++=======
+ 	if (!state->initialized)
+ 		return 0;
+ 
+ 	read_lock(&state->ss->policy_rwlock);
+ 
+ 	policydb = &state->ss->policydb;
+ 	sidtab = state->ss->sidtab;
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  
  	rc = -EINVAL;
 -	old_context = sidtab_search(sidtab, old_sid);
 +	old_context = sidtab_search(&sidtab, old_sid);
  	if (!old_context) {
 -		pr_err("SELinux: %s: unrecognized SID %u\n",
 +		printk(KERN_ERR "SELinux: %s: unrecognized SID %u\n",
  		       __func__, old_sid);
  		goto out;
  	}
@@@ -1011,13 -1029,16 +1026,20 @@@ void security_compute_xperms_decision(u
  	memset(xpermd->auditallow->p, 0, sizeof(xpermd->auditallow->p));
  	memset(xpermd->dontaudit->p, 0, sizeof(xpermd->dontaudit->p));
  
 -	read_lock(&state->ss->policy_rwlock);
 -	if (!state->initialized)
 +	read_lock(&policy_rwlock);
 +	if (!ss_initialized)
  		goto allow;
  
++<<<<<<< HEAD
 +	scontext = sidtab_search(&sidtab, ssid);
++=======
+ 	policydb = &state->ss->policydb;
+ 	sidtab = state->ss->sidtab;
+ 
+ 	scontext = sidtab_search(sidtab, ssid);
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	if (!scontext) {
 -		pr_err("SELinux: %s:  unrecognized SID %d\n",
 +		printk(KERN_ERR "SELinux: %s:  unrecognized SID %d\n",
  		       __func__, ssid);
  		goto out;
  	}
@@@ -1091,15 -1114,20 +1113,22 @@@ void security_compute_av(u32 ssid
  	u16 tclass;
  	struct context *scontext = NULL, *tcontext = NULL;
  
 -	read_lock(&state->ss->policy_rwlock);
 -	avd_init(state, avd);
 +	read_lock(&policy_rwlock);
 +	avd_init(avd);
  	xperms->len = 0;
 -	if (!state->initialized)
 +	if (!ss_initialized)
  		goto allow;
  
++<<<<<<< HEAD
 +	scontext = sidtab_search(&sidtab, ssid);
++=======
+ 	policydb = &state->ss->policydb;
+ 	sidtab = state->ss->sidtab;
+ 
+ 	scontext = sidtab_search(sidtab, ssid);
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	if (!scontext) {
 -		pr_err("SELinux: %s:  unrecognized SID %d\n",
 +		printk(KERN_ERR "SELinux: %s:  unrecognized SID %d\n",
  		       __func__, ssid);
  		goto out;
  	}
@@@ -1136,16 -1167,21 +1165,23 @@@ void security_compute_av_user(u32 ssid
  			      u16 tclass,
  			      struct av_decision *avd)
  {
 -	struct policydb *policydb;
 -	struct sidtab *sidtab;
  	struct context *scontext = NULL, *tcontext = NULL;
  
 -	read_lock(&state->ss->policy_rwlock);
 -	avd_init(state, avd);
 -	if (!state->initialized)
 +	read_lock(&policy_rwlock);
 +	avd_init(avd);
 +	if (!ss_initialized)
  		goto allow;
  
++<<<<<<< HEAD
 +	scontext = sidtab_search(&sidtab, ssid);
++=======
+ 	policydb = &state->ss->policydb;
+ 	sidtab = state->ss->sidtab;
+ 
+ 	scontext = sidtab_search(sidtab, ssid);
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	if (!scontext) {
 -		pr_err("SELinux: %s:  unrecognized SID %d\n",
 +		printk(KERN_ERR "SELinux: %s:  unrecognized SID %d\n",
  		       __func__, ssid);
  		goto out;
  	}
@@@ -1274,13 -1313,15 +1310,19 @@@ static int security_sid_to_context_core
  		rc = -EINVAL;
  		goto out;
  	}
++<<<<<<< HEAD
 +	read_lock(&policy_rwlock);
++=======
+ 	read_lock(&state->ss->policy_rwlock);
+ 	policydb = &state->ss->policydb;
+ 	sidtab = state->ss->sidtab;
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	if (force)
 -		context = sidtab_search_force(sidtab, sid);
 +		context = sidtab_search_force(&sidtab, sid);
  	else
 -		context = sidtab_search(sidtab, sid);
 +		context = sidtab_search(&sidtab, sid);
  	if (!context) {
 -		pr_err("SELinux: %s:  unrecognized SID %d\n",
 +		printk(KERN_ERR "SELinux: %s:  unrecognized SID %d\n",
  			__func__, sid);
  		rc = -EINVAL;
  		goto out_unlock;
@@@ -1438,10 -1481,11 +1480,18 @@@ static int security_context_to_sid_core
  		if (!str)
  			goto out;
  	}
++<<<<<<< HEAD
 +
 +	read_lock(&policy_rwlock);
 +	rc = string_to_context_struct(&policydb, &sidtab, scontext2,
 +				      scontext_len, &context, def_sid);
++=======
+ 	read_lock(&state->ss->policy_rwlock);
+ 	policydb = &state->ss->policydb;
+ 	sidtab = state->ss->sidtab;
+ 	rc = string_to_context_struct(policydb, sidtab, scontext2,
+ 				      &context, def_sid);
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	if (rc == -EINVAL && force) {
  		context.str = str;
  		context.len = strlen(str) + 1;
@@@ -1601,12 -1663,16 +1651,19 @@@ static int security_compute_sid(u32 ssi
  		sock = security_is_socket_class(orig_tclass);
  	} else {
  		tclass = orig_tclass;
 -		sock = security_is_socket_class(map_class(&state->ss->map,
 -							  tclass));
 +		sock = security_is_socket_class(map_class(tclass));
  	}
  
++<<<<<<< HEAD
 +	scontext = sidtab_search(&sidtab, ssid);
++=======
+ 	policydb = &state->ss->policydb;
+ 	sidtab = state->ss->sidtab;
+ 
+ 	scontext = sidtab_search(sidtab, ssid);
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	if (!scontext) {
 -		pr_err("SELinux: %s:  unrecognized SID %d\n",
 +		printk(KERN_ERR "SELinux: %s:  unrecognized SID %d\n",
  		       __func__, ssid);
  		rc = -EINVAL;
  		goto out_unlock;
@@@ -2011,14 -2084,15 +2065,22 @@@ static int security_preserve_bools(stru
   * This function will flush the access vector cache after
   * loading the new policy.
   */
 -int security_load_policy(struct selinux_state *state, void *data, size_t len)
 +int security_load_policy(void *data, size_t len)
  {
++<<<<<<< HEAD
 +	struct policydb *oldpolicydb, *newpolicydb;
 +	struct sidtab oldsidtab, newsidtab;
 +	struct selinux_mapping *oldmap, *map = NULL;
++=======
+ 	struct policydb *policydb;
+ 	struct sidtab *oldsidtab, *newsidtab;
+ 	struct policydb *oldpolicydb, *newpolicydb;
+ 	struct selinux_mapping *oldmapping;
+ 	struct selinux_map newmap;
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	struct convert_context_args args;
  	u32 seqno;
 +	u16 map_size;
  	int rc = 0;
  	struct policy_file file = { data, len }, *fp = &file;
  
@@@ -2029,45 -2103,54 +2091,89 @@@
  	}
  	newpolicydb = oldpolicydb + 1;
  
++<<<<<<< HEAD
 +	if (!ss_initialized) {
 +		avtab_cache_init();
 +		rc = policydb_read(&policydb, fp);
 +		if (rc) {
 +			avtab_cache_destroy();
 +			goto out;
 +		}
 +
 +		policydb.len = len;
 +		rc = selinux_set_mapping(&policydb, secclass_map,
 +					 &current_mapping,
 +					 &current_mapping_size);
 +		if (rc) {
 +			policydb_destroy(&policydb);
 +			avtab_cache_destroy();
 +			goto out;
 +		}
 +
 +		rc = policydb_load_isids(&policydb, &sidtab);
 +		if (rc) {
 +			policydb_destroy(&policydb);
 +			avtab_cache_destroy();
 +			goto out;
 +		}
 +
 +		security_load_policycaps();
 +		ss_initialized = 1;
 +		seqno = ++latest_granting;
++=======
+ 	policydb = &state->ss->policydb;
+ 
+ 	newsidtab = kmalloc(sizeof(*newsidtab), GFP_KERNEL);
+ 	if (!newsidtab) {
+ 		rc = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	if (!state->initialized) {
+ 		rc = policydb_read(policydb, fp);
+ 		if (rc) {
+ 			kfree(newsidtab);
+ 			goto out;
+ 		}
+ 
+ 		policydb->len = len;
+ 		rc = selinux_set_mapping(policydb, secclass_map,
+ 					 &state->ss->map);
+ 		if (rc) {
+ 			kfree(newsidtab);
+ 			policydb_destroy(policydb);
+ 			goto out;
+ 		}
+ 
+ 		rc = policydb_load_isids(policydb, newsidtab);
+ 		if (rc) {
+ 			kfree(newsidtab);
+ 			policydb_destroy(policydb);
+ 			goto out;
+ 		}
+ 
+ 		state->ss->sidtab = newsidtab;
+ 		security_load_policycaps(state);
+ 		state->initialized = 1;
+ 		seqno = ++state->ss->latest_granting;
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  		selinux_complete_init();
 -		avc_ss_reset(state->avc, seqno);
 +		avc_ss_reset(seqno);
  		selnl_notify_policyload(seqno);
 -		selinux_status_update_policyload(state, seqno);
 +		selinux_status_update_policyload(seqno);
  		selinux_netlbl_cache_invalidate();
  		selinux_xfrm_notify_policyload();
  		goto out;
  	}
  
+ 	oldsidtab = state->ss->sidtab;
+ 
  #if 0
++<<<<<<< HEAD
 +	sidtab_hash_eval(&sidtab, "sids");
++=======
+ 	sidtab_hash_eval(oldsidtab, "sids");
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  #endif
  
  	rc = policydb_read(newpolicydb, fp);
@@@ -2076,15 -2161,16 +2184,16 @@@
  
  	newpolicydb->len = len;
  	/* If switching between different policy types, log MLS status */
 -	if (policydb->mls_enabled && !newpolicydb->mls_enabled)
 -		pr_info("SELinux: Disabling MLS support...\n");
 -	else if (!policydb->mls_enabled && newpolicydb->mls_enabled)
 -		pr_info("SELinux: Enabling MLS support...\n");
 +	if (policydb.mls_enabled && !newpolicydb->mls_enabled)
 +		printk(KERN_INFO "SELinux: Disabling MLS support...\n");
 +	else if (!policydb.mls_enabled && newpolicydb->mls_enabled)
 +		printk(KERN_INFO "SELinux: Enabling MLS support...\n");
  
- 	rc = policydb_load_isids(newpolicydb, &newsidtab);
+ 	rc = policydb_load_isids(newpolicydb, newsidtab);
  	if (rc) {
 -		pr_err("SELinux:  unable to load the initial SIDs\n");
 +		printk(KERN_ERR "SELinux:  unable to load the initial SIDs\n");
  		policydb_destroy(newpolicydb);
+ 		kfree(newsidtab);
  		goto out;
  	}
  
@@@ -2109,39 -2188,40 +2218,64 @@@
  	 * Convert the internal representations of contexts
  	 * in the new SID table.
  	 */
 -	args.state = state;
 -	args.oldp = policydb;
 +	args.oldp = &policydb;
  	args.newp = newpolicydb;
++<<<<<<< HEAD
 +	rc = sidtab_map(&newsidtab, convert_context, &args);
++=======
+ 	rc = sidtab_convert(oldsidtab, newsidtab, convert_context, &args);
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	if (rc) {
 -		pr_err("SELinux:  unable to convert the internal"
 +		printk(KERN_ERR "SELinux:  unable to convert the internal"
  			" representation of contexts in the new SID"
  			" table\n");
  		goto err;
  	}
  
  	/* Save the old policydb and SID table to free later. */
++<<<<<<< HEAD
 +	memcpy(oldpolicydb, &policydb, sizeof(policydb));
 +	sidtab_set(&oldsidtab, &sidtab);
 +
 +	/* Install the new policydb and SID table. */
 +	write_lock_irq(&policy_rwlock);
 +	memcpy(&policydb, newpolicydb, sizeof(policydb));
 +	sidtab_set(&sidtab, &newsidtab);
 +	security_load_policycaps();
 +	oldmap = current_mapping;
 +	current_mapping = map;
 +	current_mapping_size = map_size;
 +	seqno = ++latest_granting;
 +	write_unlock_irq(&policy_rwlock);
 +
 +	/* Free the old policydb and SID table. */
 +	policydb_destroy(oldpolicydb);
 +	sidtab_destroy(&oldsidtab);
 +	kfree(oldmap);
++=======
+ 	memcpy(oldpolicydb, policydb, sizeof(*policydb));
+ 
+ 	/* Install the new policydb and SID table. */
+ 	write_lock_irq(&state->ss->policy_rwlock);
+ 	memcpy(policydb, newpolicydb, sizeof(*policydb));
+ 	state->ss->sidtab = newsidtab;
+ 	security_load_policycaps(state);
+ 	oldmapping = state->ss->map.mapping;
+ 	state->ss->map.mapping = newmap.mapping;
+ 	state->ss->map.size = newmap.size;
+ 	seqno = ++state->ss->latest_granting;
+ 	write_unlock_irq(&state->ss->policy_rwlock);
+ 
+ 	/* Free the old policydb and SID table. */
+ 	policydb_destroy(oldpolicydb);
+ 	sidtab_destroy(oldsidtab);
+ 	kfree(oldsidtab);
+ 	kfree(oldmapping);
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  
 -	avc_ss_reset(state->avc, seqno);
 +	avc_ss_reset(seqno);
  	selnl_notify_policyload(seqno);
 -	selinux_status_update_policyload(state, seqno);
 +	selinux_status_update_policyload(seqno);
  	selinux_netlbl_cache_invalidate();
  	selinux_xfrm_notify_policyload();
  
@@@ -2149,8 -2229,9 +2283,14 @@@
  	goto out;
  
  err:
++<<<<<<< HEAD
 +	kfree(map);
 +	sidtab_destroy(&newsidtab);
++=======
+ 	kfree(newmap.mapping);
+ 	sidtab_destroy(newsidtab);
+ 	kfree(newsidtab);
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	policydb_destroy(newpolicydb);
  
  out:
@@@ -2180,9 -2263,14 +2320,16 @@@ int security_port_sid(u8 protocol, u16 
  	struct ocontext *c;
  	int rc = 0;
  
 -	read_lock(&state->ss->policy_rwlock);
 +	read_lock(&policy_rwlock);
  
++<<<<<<< HEAD
 +	c = policydb.ocontexts[OCON_PORT];
++=======
+ 	policydb = &state->ss->policydb;
+ 	sidtab = state->ss->sidtab;
+ 
+ 	c = policydb->ocontexts[OCON_PORT];
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	while (c) {
  		if (c->u.port.protocol == protocol &&
  		    c->u.port.low_port <= port &&
@@@ -2220,9 -2309,14 +2367,16 @@@ int security_ib_pkey_sid(u64 subnet_pre
  	struct ocontext *c;
  	int rc = 0;
  
 -	read_lock(&state->ss->policy_rwlock);
 +	read_lock(&policy_rwlock);
  
++<<<<<<< HEAD
 +	c = policydb.ocontexts[OCON_IBPKEY];
++=======
+ 	policydb = &state->ss->policydb;
+ 	sidtab = state->ss->sidtab;
+ 
+ 	c = policydb->ocontexts[OCON_IBPKEY];
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	while (c) {
  		if (c->u.ibpkey.low_pkey <= pkey_num &&
  		    c->u.ibpkey.high_pkey >= pkey_num &&
@@@ -2260,9 -2355,14 +2414,16 @@@ int security_ib_endport_sid(const char 
  	struct ocontext *c;
  	int rc = 0;
  
 -	read_lock(&state->ss->policy_rwlock);
 +	read_lock(&policy_rwlock);
  
++<<<<<<< HEAD
 +	c = policydb.ocontexts[OCON_IBENDPORT];
++=======
+ 	policydb = &state->ss->policydb;
+ 	sidtab = state->ss->sidtab;
+ 
+ 	c = policydb->ocontexts[OCON_IBENDPORT];
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	while (c) {
  		if (c->u.ibendport.port == port_num &&
  		    !strncmp(c->u.ibendport.dev_name,
@@@ -2300,9 -2401,14 +2461,16 @@@ int security_netif_sid(char *name, u32 
  	int rc = 0;
  	struct ocontext *c;
  
 -	read_lock(&state->ss->policy_rwlock);
 +	read_lock(&policy_rwlock);
  
++<<<<<<< HEAD
 +	c = policydb.ocontexts[OCON_NETIF];
++=======
+ 	policydb = &state->ss->policydb;
+ 	sidtab = state->ss->sidtab;
+ 
+ 	c = policydb->ocontexts[OCON_NETIF];
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	while (c) {
  		if (strcmp(name, c->u.name) == 0)
  			break;
@@@ -2359,7 -2466,12 +2527,14 @@@ int security_node_sid(u16 domain
  	int rc;
  	struct ocontext *c;
  
++<<<<<<< HEAD
 +	read_lock(&policy_rwlock);
++=======
+ 	read_lock(&state->ss->policy_rwlock);
+ 
+ 	policydb = &state->ss->policydb;
+ 	sidtab = state->ss->sidtab;
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  
  	switch (domain) {
  	case AF_INET: {
@@@ -2450,10 -2565,13 +2625,17 @@@ int security_get_user_sids(u32 fromsid
  	*sids = NULL;
  	*nel = 0;
  
 -	if (!state->initialized)
 +	if (!ss_initialized)
  		goto out;
  
++<<<<<<< HEAD
 +	read_lock(&policy_rwlock);
++=======
+ 	read_lock(&state->ss->policy_rwlock);
+ 
+ 	policydb = &state->ss->policydb;
+ 	sidtab = state->ss->sidtab;
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  
  	context_init(&usercon);
  
@@@ -2543,12 -2663,17 +2725,17 @@@ out
   * Obtain a SID to use for a file in a filesystem that
   * cannot support xattr or use a fixed labeling behavior like
   * transition SIDs or task SIDs.
 - *
 - * The caller must acquire the policy_rwlock before calling this function.
   */
 -static inline int __security_genfs_sid(struct selinux_state *state,
 -				       const char *fstype,
 -				       char *path,
 -				       u16 orig_sclass,
 -				       u32 *sid)
 +int security_genfs_sid(const char *fstype,
 +		       char *path,
 +		       u16 orig_sclass,
 +		       u32 *sid)
  {
++<<<<<<< HEAD
++=======
+ 	struct policydb *policydb = &state->ss->policydb;
+ 	struct sidtab *sidtab = state->ss->sidtab;
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	int len;
  	u16 sclass;
  	struct genfs *genfs;
@@@ -2597,23 -2719,49 +2784,30 @@@ out
  	return rc;
  }
  
 -/**
 - * security_genfs_sid - Obtain a SID for a file in a filesystem
 - * @fstype: filesystem type
 - * @path: path from root of mount
 - * @sclass: file security class
 - * @sid: SID for path
 - *
 - * Acquire policy_rwlock before calling __security_genfs_sid() and release
 - * it afterward.
 - */
 -int security_genfs_sid(struct selinux_state *state,
 -		       const char *fstype,
 -		       char *path,
 -		       u16 orig_sclass,
 -		       u32 *sid)
 -{
 -	int retval;
 -
 -	read_lock(&state->ss->policy_rwlock);
 -	retval = __security_genfs_sid(state, fstype, path, orig_sclass, sid);
 -	read_unlock(&state->ss->policy_rwlock);
 -	return retval;
 -}
 -
  /**
   * security_fs_use - Determine how to handle labeling for a filesystem.
 - * @sb: superblock in question
 + * @fstype: filesystem type
 + * @behavior: labeling behavior
 + * @sid: SID for filesystem (superblock)
   */
 -int security_fs_use(struct selinux_state *state, struct super_block *sb)
 +int security_fs_use(
 +	const char *fstype,
 +	unsigned int *behavior,
 +	u32 *sid)
  {
 -	struct policydb *policydb;
 -	struct sidtab *sidtab;
  	int rc = 0;
  	struct ocontext *c;
 -	struct superblock_security_struct *sbsec = sb->s_security;
 -	const char *fstype = sb->s_type->name;
  
 -	read_lock(&state->ss->policy_rwlock);
 +	read_lock(&policy_rwlock);
  
++<<<<<<< HEAD
 +	c = policydb.ocontexts[OCON_FSUSE];
++=======
+ 	policydb = &state->ss->policydb;
+ 	sidtab = state->ss->sidtab;
+ 
+ 	c = policydb->ocontexts[OCON_FSUSE];
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	while (c) {
  		if (strcmp(fstype, c->u.name) == 0)
  			break;
@@@ -2797,8 -2961,11 +2991,13 @@@ out
   * security_sid_mls_copy() - computes a new sid based on the given
   * sid and the mls portion of mls_sid.
   */
 -int security_sid_mls_copy(struct selinux_state *state,
 -			  u32 sid, u32 mls_sid, u32 *new_sid)
 +int security_sid_mls_copy(u32 sid, u32 mls_sid, u32 *new_sid)
  {
++<<<<<<< HEAD
++=======
+ 	struct policydb *policydb = &state->ss->policydb;
+ 	struct sidtab *sidtab = state->ss->sidtab;
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	struct context *context1;
  	struct context *context2;
  	struct context newcon;
@@@ -2886,6 -3055,8 +3085,11 @@@ int security_net_peersid_resolve(u32 nl
  				 u32 xfrm_sid,
  				 u32 *peer_sid)
  {
++<<<<<<< HEAD
++=======
+ 	struct policydb *policydb = &state->ss->policydb;
+ 	struct sidtab *sidtab = state->ss->sidtab;
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	int rc;
  	struct context *nlbl_ctx;
  	struct context *xfrm_ctx;
@@@ -3228,7 -3417,7 +3432,11 @@@ int selinux_audit_rule_match(u32 sid, u
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	ctxt = sidtab_search(&sidtab, sid);
++=======
+ 	ctxt = sidtab_search(state->ss->sidtab, sid);
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	if (unlikely(!ctxt)) {
  		WARN_ONCE(1, "selinux_audit_rule_match: unrecognized SID %d\n",
  			  sid);
@@@ -3386,9 -3575,12 +3594,14 @@@ static void security_netlbl_cache_add(s
   * failure.
   *
   */
 -int security_netlbl_secattr_to_sid(struct selinux_state *state,
 -				   struct netlbl_lsm_secattr *secattr,
 +int security_netlbl_secattr_to_sid(struct netlbl_lsm_secattr *secattr,
  				   u32 *sid)
  {
++<<<<<<< HEAD
++=======
+ 	struct policydb *policydb = &state->ss->policydb;
+ 	struct sidtab *sidtab = state->ss->sidtab;
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	int rc;
  	struct context *ctx;
  	struct context ctx_new;
@@@ -3462,13 -3651,14 +3675,17 @@@ int security_netlbl_sid_to_secattr(u32 
  	int rc;
  	struct context *ctx;
  
 -	if (!state->initialized)
 +	if (!ss_initialized)
  		return 0;
  
 -	read_lock(&state->ss->policy_rwlock);
 +	read_lock(&policy_rwlock);
  
  	rc = -ENOENT;
++<<<<<<< HEAD
 +	ctx = sidtab_search(&sidtab, sid);
++=======
+ 	ctx = sidtab_search(state->ss->sidtab, sid);
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  	if (ctx == NULL)
  		goto out;
  
diff --cc security/selinux/ss/services.h
index 6abcd8729ec3,9a36de860368..000000000000
--- a/security/selinux/ss/services.h
+++ b/security/selinux/ss/services.h
@@@ -9,7 -10,28 +9,32 @@@
  #include "policydb.h"
  #include "sidtab.h"
  
++<<<<<<< HEAD
 +extern struct policydb policydb;
++=======
+ /* Mapping for a single class */
+ struct selinux_mapping {
+ 	u16 value; /* policy value for class */
+ 	unsigned int num_perms; /* number of permissions in class */
+ 	u32 perms[sizeof(u32) * 8]; /* policy values for permissions */
+ };
+ 
+ /* Map for all of the classes, with array size */
+ struct selinux_map {
+ 	struct selinux_mapping *mapping; /* indexed by class */
+ 	u16 size; /* array size of mapping */
+ };
+ 
+ struct selinux_ss {
+ 	struct sidtab *sidtab;
+ 	struct policydb policydb;
+ 	rwlock_t policy_rwlock;
+ 	u32 latest_granting;
+ 	struct selinux_map map;
+ 	struct page *status_page;
+ 	struct mutex status_lock;
+ };
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  
  void services_compute_xperms_drivers(struct extended_perms *xperms,
  				struct avtab_node *node);
diff --cc security/selinux/ss/sidtab.c
index 5840a35155fc,e44e7cec630c..000000000000
--- a/security/selinux/ss/sidtab.c
+++ b/security/selinux/ss/sidtab.c
@@@ -18,27 -19,33 +18,35 @@@ int sidtab_init(struct sidtab *s
  {
  	int i;
  
 -	s->htable = kmalloc_array(SIDTAB_SIZE, sizeof(*s->htable), GFP_ATOMIC);
 +	s->htable = kmalloc(sizeof(*(s->htable)) * SIDTAB_SIZE, GFP_ATOMIC);
  	if (!s->htable)
  		return -ENOMEM;
+ 
+ 	for (i = 0; i < SECINITSID_NUM; i++)
+ 		s->isids[i].set = 0;
+ 
  	for (i = 0; i < SIDTAB_SIZE; i++)
  		s->htable[i] = NULL;
+ 
+ 	for (i = 0; i < SIDTAB_CACHE_LEN; i++)
+ 		s->cache[i] = NULL;
+ 
  	s->nel = 0;
- 	s->next_sid = 1;
+ 	s->next_sid = 0;
  	s->shutdown = 0;
  	spin_lock_init(&s->lock);
  	return 0;
  }
  
- int sidtab_insert(struct sidtab *s, u32 sid, struct context *context)
+ static int sidtab_insert(struct sidtab *s, u32 sid, struct context *context)
  {
 -	int hvalue;
 +	int hvalue, rc = 0;
  	struct sidtab_node *prev, *cur, *newnode;
  
 -	if (!s)
 -		return -ENOMEM;
 +	if (!s) {
 +		rc = -ENOMEM;
 +		goto out;
 +	}
  
  	hvalue = SIDTAB_HASH(sid);
  	prev = NULL;
@@@ -78,11 -81,28 +86,29 @@@
  	s->nel++;
  	if (sid >= s->next_sid)
  		s->next_sid = sid + 1;
 -	return 0;
 +out:
 +	return rc;
  }
  
- static struct context *sidtab_search_core(struct sidtab *s, u32 sid, int force)
+ int sidtab_set_initial(struct sidtab *s, u32 sid, struct context *context)
+ {
+ 	struct sidtab_isid_entry *entry;
+ 	int rc;
+ 
+ 	if (sid == 0 || sid > SECINITSID_NUM)
+ 		return -EINVAL;
+ 
+ 	entry = &s->isids[sid - 1];
+ 
+ 	rc = context_cpy(&entry->context, context);
+ 	if (rc)
+ 		return rc;
+ 
+ 	entry->set = 1;
+ 	return 0;
+ }
+ 
+ static struct context *sidtab_lookup(struct sidtab *s, u32 sid)
  {
  	int hvalue;
  	struct sidtab_node *cur;
@@@ -95,19 -112,8 +118,24 @@@
  	while (cur && sid > cur->sid)
  		cur = cur->next;
  
++<<<<<<< HEAD
 +	if (force && cur && sid == cur->sid && cur->context.len)
 +		return &cur->context;
 +
 +	if (cur == NULL || sid != cur->sid || cur->context.len) {
 +		/* Remap invalid SIDs to the unlabeled SID. */
 +		sid = SECINITSID_UNLABELED;
 +		hvalue = SIDTAB_HASH(sid);
 +		cur = s->htable[hvalue];
 +		while (cur && sid > cur->sid)
 +			cur = cur->next;
 +		if (!cur || sid != cur->sid)
 +			return NULL;
 +	}
++=======
+ 	if (!cur || sid != cur->sid)
+ 		return NULL;
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  
  	return &cur->context;
  }
@@@ -147,6 -177,33 +199,36 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ /* Clone the SID into the new SID table. */
+ static int clone_sid(u32 sid, struct context *context, void *arg)
+ {
+ 	struct sidtab *s = arg;
+ 	return sidtab_insert(s, sid, context);
+ }
+ 
+ int sidtab_convert(struct sidtab *s, struct sidtab *news,
+ 		   int (*convert)(u32 sid,
+ 				  struct context *context,
+ 				  void *args),
+ 		   void *args)
+ {
+ 	unsigned long flags;
+ 	int rc;
+ 
+ 	spin_lock_irqsave(&s->lock, flags);
+ 	s->shutdown = 1;
+ 	spin_unlock_irqrestore(&s->lock, flags);
+ 
+ 	rc = sidtab_map(s, clone_sid, news);
+ 	if (rc)
+ 		return rc;
+ 
+ 	return sidtab_map(news, convert, args);
+ }
+ 
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  static void sidtab_update_cache(struct sidtab *s, struct sidtab_node *n, int loc)
  {
  	BUG_ON(loc >= SIDTAB_CACHE_LEN);
@@@ -218,12 -275,11 +300,12 @@@ static int sidtab_reverse_lookup(struc
  			ret = -ENOMEM;
  			goto unlock_out;
  		}
- 		sid = s->next_sid++;
+ 		*sid = s->next_sid++;
  		if (context->len)
 -			pr_info("SELinux:  Context %s is not valid (left unmapped).\n",
 +			printk(KERN_INFO
 +		       "SELinux:  Context %s is not valid (left unmapped).\n",
  			       context->str);
- 		ret = sidtab_insert(s, sid, context);
+ 		ret = sidtab_insert(s, *sid, context);
  		if (ret)
  			s->next_sid--;
  unlock_out:
@@@ -287,27 -364,3 +390,30 @@@ void sidtab_destroy(struct sidtab *s
  	s->nel = 0;
  	s->next_sid = 1;
  }
++<<<<<<< HEAD
 +
 +void sidtab_set(struct sidtab *dst, struct sidtab *src)
 +{
 +	unsigned long flags;
 +	int i;
 +
 +	spin_lock_irqsave(&src->lock, flags);
 +	dst->htable = src->htable;
 +	dst->nel = src->nel;
 +	dst->next_sid = src->next_sid;
 +	dst->shutdown = 0;
 +	for (i = 0; i < SIDTAB_CACHE_LEN; i++)
 +		dst->cache[i] = NULL;
 +	spin_unlock_irqrestore(&src->lock, flags);
 +}
 +
 +void sidtab_shutdown(struct sidtab *s)
 +{
 +	unsigned long flags;
 +
 +	spin_lock_irqsave(&s->lock, flags);
 +	s->shutdown = 1;
 +	spin_unlock_irqrestore(&s->lock, flags);
 +}
++=======
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
diff --cc security/selinux/ss/sidtab.h
index 84dc154d9389,e657ae6bf996..000000000000
--- a/security/selinux/ss/sidtab.h
+++ b/security/selinux/ss/sidtab.h
@@@ -36,20 -45,16 +44,21 @@@ int sidtab_set_initial(struct sidtab *s
  struct context *sidtab_search(struct sidtab *s, u32 sid);
  struct context *sidtab_search_force(struct sidtab *s, u32 sid);
  
 -int sidtab_convert(struct sidtab *s, struct sidtab *news,
 -		   int (*apply)(u32 sid,
 -				struct context *context,
 -				void *args),
 -		   void *args);
 +int sidtab_map(struct sidtab *s,
 +	       int (*apply) (u32 sid,
 +			     struct context *context,
 +			     void *args),
 +	       void *args);
  
- int sidtab_context_to_sid(struct sidtab *s,
- 			  struct context *context,
- 			  u32 *sid);
+ int sidtab_context_to_sid(struct sidtab *s, struct context *context, u32 *sid);
  
  void sidtab_hash_eval(struct sidtab *h, char *tag);
  void sidtab_destroy(struct sidtab *s);
++<<<<<<< HEAD
 +void sidtab_set(struct sidtab *dst, struct sidtab *src);
 +void sidtab_shutdown(struct sidtab *s);
++=======
++>>>>>>> 24ed7fdae669 (selinux: use separate table for initial SID lookup)
  
  #endif	/* _SS_SIDTAB_H_ */
  
diff --git a/security/selinux/ss/policydb.c b/security/selinux/ss/policydb.c
index 4db6549964f1..3a4037e191c7 100644
--- a/security/selinux/ss/policydb.c
+++ b/security/selinux/ss/policydb.c
@@ -921,13 +921,21 @@ int policydb_load_isids(struct policydb *p, struct sidtab *s)
 		if (!c->context[0].user) {
 			printk(KERN_ERR "SELinux:  SID %s was never defined.\n",
 				c->u.name);
+			sidtab_destroy(s);
+			goto out;
+		}
+		if (c->sid[0] == SECSID_NULL || c->sid[0] > SECINITSID_NUM) {
+			pr_err("SELinux:  Initial SID %s out of range.\n",
+				c->u.name);
+			sidtab_destroy(s);
 			goto out;
 		}
 
-		rc = sidtab_insert(s, c->sid[0], &c->context[0]);
+		rc = sidtab_set_initial(s, c->sid[0], &c->context[0]);
 		if (rc) {
 			printk(KERN_ERR "SELinux:  unable to load initial SID %s.\n",
 				c->u.name);
+			sidtab_destroy(s);
 			goto out;
 		}
 	}
* Unmerged path security/selinux/ss/services.c
* Unmerged path security/selinux/ss/services.h
* Unmerged path security/selinux/ss/sidtab.c
* Unmerged path security/selinux/ss/sidtab.h
