slub: convert SLAB_DEBUG_FREE to SLAB_CONSISTENCY_CHECKS

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Laura Abbott <labbott@fedoraproject.org>
commit becfda68abca673d61d5cc953e8e099816db99d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/becfda68.failed

SLAB_DEBUG_FREE allows expensive consistency checks at free to be turned
on or off.  Expand its use to be able to turn off all consistency
checks.  This gives a nice speed up if you only want features such as
poisoning or tracing.

Credit to Mathias Krause for the original work which inspired this
series

	Signed-off-by: Laura Abbott <labbott@fedoraproject.org>
	Acked-by: Christoph Lameter <cl@linux.com>
	Cc: Pekka Enberg <penberg@kernel.org>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Joonsoo Kim <js1304@gmail.com>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: Mathias Krause <minipli@googlemail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit becfda68abca673d61d5cc953e8e099816db99d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/slub.c
diff --cc mm/slub.c
index c9459d98c8fd,9cde663bbb10..000000000000
--- a/mm/slub.c
+++ b/mm/slub.c
@@@ -1093,7 -1007,8 +1093,12 @@@ static void setup_object_debug(struct k
  	init_tracking(s, object);
  }
  
++<<<<<<< HEAD
 +static noinline int alloc_debug_processing(struct kmem_cache *s, struct page *page,
++=======
+ static inline int alloc_consistency_checks(struct kmem_cache *s,
+ 					struct page *page,
++>>>>>>> becfda68abca (slub: convert SLAB_DEBUG_FREE to SLAB_CONSISTENCY_CHECKS)
  					void *object, unsigned long addr)
  {
  	if (!check_slab(s, page))
@@@ -1149,32 -1110,9 +1200,38 @@@ static noinline int free_debug_processi
  next_object:
  	cnt++;
  
++<<<<<<< HEAD
 +	if (!check_valid_pointer(s, page, object)) {
 +		slab_err(s, page, "Invalid object pointer 0x%p", object);
 +		goto out;
 +	}
 +
 +	if (on_freelist(s, page, object)) {
 +		object_err(s, page, object, "Object already free");
 +		goto out;
 +	}
 +
 +	if (!check_object(s, page, object, SLUB_RED_ACTIVE))
 +		goto out;
 +
 +	if (unlikely(s != page->slab_cache)) {
 +		if (!PageSlab(page)) {
 +			slab_err(s, page, "Attempt to free object(0x%p) "
 +				"outside of slab", object);
 +		} else if (!page->slab_cache) {
 +			printk(KERN_ERR
 +				"SLUB <none>: no slab for object 0x%p.\n",
 +						object);
 +			dump_stack();
 +		} else
 +			object_err(s, page, object,
 +					"page slab pointer corrupt.");
 +		goto out;
++=======
+ 	if (s->flags & SLAB_CONSISTENCY_CHECKS) {
+ 		if (!free_consistency_checks(s, page, object, addr))
+ 			goto out;
++>>>>>>> becfda68abca (slub: convert SLAB_DEBUG_FREE to SLAB_CONSISTENCY_CHECKS)
  	}
  
  	if (s->flags & SLAB_STORE_USER)
diff --git a/Documentation/vm/slub.txt b/Documentation/vm/slub.txt
index b0c6d1bbb434..3ae2ee98c4b9 100644
--- a/Documentation/vm/slub.txt
+++ b/Documentation/vm/slub.txt
@@ -35,8 +35,8 @@ slub_debug=<Debug-Options>,<slab name>
 				Enable options only for select slabs
 
 Possible debug options are
-	F		Sanity checks on (enables SLAB_DEBUG_FREE. Sorry
-			SLAB legacy issues)
+	F		Sanity checks on (enables SLAB_DEBUG_CONSISTENCY_CHECKS
+			Sorry SLAB legacy issues)
 	Z		Red zoning
 	P		Poisoning (object and padding)
 	U		User tracking (free and alloc)
diff --git a/include/linux/slab.h b/include/linux/slab.h
index 33faa2bdd87b..9390852d29af 100644
--- a/include/linux/slab.h
+++ b/include/linux/slab.h
@@ -18,7 +18,7 @@
  * Flags to pass to kmem_cache_create().
  * The ones marked DEBUG are only valid if CONFIG_SLAB_DEBUG is set.
  */
-#define SLAB_DEBUG_FREE		0x00000100UL	/* DEBUG: Perform (expensive) checks on free */
+#define SLAB_CONSISTENCY_CHECKS	0x00000100UL	/* DEBUG: Perform (expensive) checks on alloc/free */
 #define SLAB_RED_ZONE		0x00000400UL	/* DEBUG: Red zone objs in a cache */
 #define SLAB_POISON		0x00000800UL	/* DEBUG: Poison objects */
 #define SLAB_HWCACHE_ALIGN	0x00002000UL	/* Align objs on cache lines */
diff --git a/mm/slab.h b/mm/slab.h
index 7474c0a584b5..fe8b9813d1f4 100644
--- a/mm/slab.h
+++ b/mm/slab.h
@@ -73,7 +73,7 @@ __kmem_cache_alias(const char *name, size_t size, size_t align,
 #define SLAB_DEBUG_FLAGS (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER)
 #elif defined(CONFIG_SLUB_DEBUG)
 #define SLAB_DEBUG_FLAGS (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER | \
-			  SLAB_TRACE | SLAB_DEBUG_FREE)
+			  SLAB_TRACE | SLAB_CONSISTENCY_CHECKS)
 #else
 #define SLAB_DEBUG_FLAGS (0)
 #endif
@@ -223,7 +223,8 @@ static inline struct kmem_cache *cache_from_obj(struct kmem_cache *s, void *x)
 	 * to not do even the assignment. In that case, slab_equal_or_root
 	 * will also be a constant.
 	 */
-	if (!memcg_kmem_enabled() && !unlikely(s->flags & SLAB_DEBUG_FREE))
+	if (!memcg_kmem_enabled() &&
+	    !unlikely(s->flags & SLAB_CONSISTENCY_CHECKS))
 		return s;
 
 	page = virt_to_head_page(x);
* Unmerged path mm/slub.c
diff --git a/tools/vm/slabinfo.c b/tools/vm/slabinfo.c
index 808d5a9d5dcf..b826824d0544 100644
--- a/tools/vm/slabinfo.c
+++ b/tools/vm/slabinfo.c
@@ -127,7 +127,7 @@ static void usage(void)
 		"\nValid debug options (FZPUT may be combined)\n"
 		"a / A          Switch on all debug options (=FZUP)\n"
 		"-              Switch off all debug options\n"
-		"f / F          Sanity Checks (SLAB_DEBUG_FREE)\n"
+		"f / F          Sanity Checks (SLAB_CONSISTENCY_CHECKS)\n"
 		"z / Z          Redzoning\n"
 		"p / P          Poisoning\n"
 		"u / U          Tracking\n"
