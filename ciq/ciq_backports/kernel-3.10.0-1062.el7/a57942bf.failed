ALSA: hda: Make audio component support more generic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit a57942bfdd61b46df94021c9c33b8faaae5b65e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a57942bf.failed

This is the final step for more generic support of DRM audio
component.  The generic audio component code is now moved to its own
file, and the symbols are renamed from snd_hac_i915_* to
snd_hdac_acomp_*, respectively.  The generic code is enabled via the
new kconfig, CONFIG_SND_HDA_COMPONENT, while CONFIG_SND_HDA_I915 is
kept as the super-class.

Along with the split, three new callbacks are added to audio_ops:
pin2port is for providing the conversion between the pin number and
the widget id, and master_bind/master_unbin are called at binding /
unbinding the master component, respectively.  All these are optional,
but used in i915 implementation and also other later implementations.

A note about the new snd_hdac_acomp_init() function: there is a slight
difference between this and the old snd_hdac_i915_init().  The latter
(still) synchronizes with the master component binding, i.e. it
assures that the relevant DRM component gets bound when it returns, or
gives a negative error.  Meanwhile the new function doesn't
synchronize but just leaves as is.  It's the responsibility by the
caller's side to synchronize, or the caller may accept the
asynchronous binding on the fly.

v1->v2: Fix missing NULL check in master_bind/unbind

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit a57942bfdd61b46df94021c9c33b8faaae5b65e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/drm/drm_audio_component.h
#	include/sound/hda_i915.h
#	sound/hda/hdac_i915.c
#	sound/pci/hda/patch_hdmi.c
#	sound/soc/codecs/hdac_hdmi.c
diff --cc include/sound/hda_i915.h
index c4368bd51aed,6b79614a893b..000000000000
--- a/include/sound/hda_i915.h
+++ b/include/sound/hda_i915.h
@@@ -4,28 -5,12 +4,30 @@@
  #ifndef __SOUND_HDA_I915_H
  #define __SOUND_HDA_I915_H
  
++<<<<<<< HEAD
 +#include <drm/i915_component.h>
++=======
+ #include "hda_component.h"
++>>>>>>> a57942bfdd61 (ALSA: hda: Make audio component support more generic)
  
  #ifdef CONFIG_SND_HDA_I915
- int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable);
- int snd_hdac_display_power(struct hdac_bus *bus, bool enable);
  void snd_hdac_i915_set_bclk(struct hdac_bus *bus);
- int snd_hdac_sync_audio_rate(struct hdac_device *codec, hda_nid_t nid,
- 			     int dev_id, int rate);
- int snd_hdac_acomp_get_eld(struct hdac_device *codec, hda_nid_t nid, int dev_id,
- 			   bool *audio_enabled, char *buffer, int max_bytes);
  int snd_hdac_i915_init(struct hdac_bus *bus);
++<<<<<<< HEAD
 +int snd_hdac_i915_exit(struct hdac_bus *bus);
 +int snd_hdac_i915_register_notifier(const struct i915_audio_component_audio_ops *);
  #else
 +static int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable)
 +{
 +	return 0;
 +}
 +static inline int snd_hdac_display_power(struct hdac_bus *bus, bool enable)
 +{
 +	return 0;
 +}
++=======
++#else
++>>>>>>> a57942bfdd61 (ALSA: hda: Make audio component support more generic)
  static inline void snd_hdac_i915_set_bclk(struct hdac_bus *bus)
  {
  }
@@@ -44,14 -18,10 +35,18 @@@ static inline int snd_hdac_i915_init(st
  {
  	return -ENODEV;
  }
+ #endif
  static inline int snd_hdac_i915_exit(struct hdac_bus *bus)
  {
- 	return 0;
+ 	return snd_hdac_acomp_exit(bus);
  }
++<<<<<<< HEAD
 +static inline int snd_hdac_i915_register_notifier(const struct i915_audio_component_audio_ops *ops)
 +{
 +	return -ENODEV;
 +}
 +#endif
++=======
++>>>>>>> a57942bfdd61 (ALSA: hda: Make audio component support more generic)
  
  #endif /* __SOUND_HDA_I915_H */
diff --cc sound/hda/hdac_i915.c
index 6ecc8d650ee7,8f2aa8bc1185..000000000000
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@@ -15,89 -15,11 +15,95 @@@
  #include <linux/init.h>
  #include <linux/module.h>
  #include <linux/pci.h>
++<<<<<<< HEAD
 +#include <linux/component.h>
 +#include <drm/i915_component.h>
++=======
++>>>>>>> a57942bfdd61 (ALSA: hda: Make audio component support more generic)
  #include <sound/core.h>
  #include <sound/hdaudio.h>
  #include <sound/hda_i915.h>
  #include <sound/hda_register.h>
  
++<<<<<<< HEAD
 +static struct i915_audio_component *hdac_acomp;
 +
 +/**
 + * snd_hdac_set_codec_wakeup - Enable / disable HDMI/DP codec wakeup
 + * @bus: HDA core bus
 + * @enable: enable or disable the wakeup
 + *
 + * This function is supposed to be used only by a HD-audio controller
 + * driver that needs the interaction with i915 graphics.
 + *
 + * This function should be called during the chip reset, also called at
 + * resume for updating STATESTS register read.
 + *
 + * Returns zero for success or a negative error code.
 + */
 +int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable)
 +{
 +	struct i915_audio_component *acomp = bus->audio_component;
 +
 +	if (!acomp || !acomp->ops)
 +		return -ENODEV;
 +
 +	if (!acomp->ops->codec_wake_override) {
 +		dev_warn(bus->dev,
 +			"Invalid codec wake callback\n");
 +		return 0;
 +	}
 +
 +	dev_dbg(bus->dev, "%s codec wakeup\n",
 +		enable ? "enable" : "disable");
 +
 +	acomp->ops->codec_wake_override(acomp->dev, enable);
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(snd_hdac_set_codec_wakeup);
 +
 +/**
 + * snd_hdac_display_power - Power up / down the power refcount
 + * @bus: HDA core bus
 + * @enable: power up or down
 + *
 + * This function is supposed to be used only by a HD-audio controller
 + * driver that needs the interaction with i915 graphics.
 + *
 + * This function manages a refcount and calls the i915 get_power() and
 + * put_power() ops accordingly, toggling the codec wakeup, too.
 + *
 + * Returns zero for success or a negative error code.
 + */
 +int snd_hdac_display_power(struct hdac_bus *bus, bool enable)
 +{
 +	struct i915_audio_component *acomp = bus->audio_component;
 +
 +	if (!acomp || !acomp->ops)
 +		return -ENODEV;
 +
 +	dev_dbg(bus->dev, "display power %s\n",
 +		enable ? "enable" : "disable");
 +
 +	if (enable) {
 +		if (!bus->i915_power_refcount++) {
 +			acomp->ops->get_power(acomp->dev);
 +			snd_hdac_set_codec_wakeup(bus, true);
 +			snd_hdac_set_codec_wakeup(bus, false);
 +		}
 +	} else {
 +		WARN_ON(!bus->i915_power_refcount);
 +		if (!--bus->i915_power_refcount)
 +			acomp->ops->put_power(acomp->dev);
 +	}
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(snd_hdac_display_power);
 +
++=======
++>>>>>>> a57942bfdd61 (ALSA: hda: Make audio component support more generic)
  #define CONTROLLER_IN_GPU(pci) (((pci)->device == 0x0a0c) || \
  				((pci)->device == 0x0c0c) || \
  				((pci)->device == 0x0d0c) || \
@@@ -158,181 -80,11 +164,176 @@@ void snd_hdac_i915_set_bclk(struct hdac
  }
  EXPORT_SYMBOL_GPL(snd_hdac_i915_set_bclk);
  
- /* There is a fixed mapping between audio pin node and display port.
-  * on SNB, IVY, HSW, BSW, SKL, BXT, KBL:
-  * Pin Widget 5 - PORT B (port = 1 in i915 driver)
-  * Pin Widget 6 - PORT C (port = 2 in i915 driver)
-  * Pin Widget 7 - PORT D (port = 3 in i915 driver)
-  *
-  * on VLV, ILK:
-  * Pin Widget 4 - PORT B (port = 1 in i915 driver)
-  * Pin Widget 5 - PORT C (port = 2 in i915 driver)
-  * Pin Widget 6 - PORT D (port = 3 in i915 driver)
-  */
- static int pin2port(struct hdac_device *codec, hda_nid_t pin_nid)
+ static int i915_component_master_match(struct device *dev, void *data)
  {
++<<<<<<< HEAD
 +	int base_nid;
 +
 +	switch (codec->vendor_id) {
 +	case 0x80860054: /* ILK */
 +	case 0x80862804: /* ILK */
 +	case 0x80862882: /* VLV */
 +		base_nid = 3;
 +		break;
 +	default:
 +		base_nid = 4;
 +		break;
 +	}
 +
 +	if (WARN_ON(pin_nid <= base_nid || pin_nid > base_nid + 3))
 +		return -1;
 +	return pin_nid - base_nid;
 +}
 +
 +/**
 + * snd_hdac_sync_audio_rate - Set N/CTS based on the sample rate
 + * @codec: HDA codec
 + * @nid: the pin widget NID
 + * @dev_id: device identifier
 + * @rate: the sample rate to set
 + *
 + * This function is supposed to be used only by a HD-audio controller
 + * driver that needs the interaction with i915 graphics.
 + *
 + * This function sets N/CTS value based on the given sample rate.
 + * Returns zero for success, or a negative error code.
 + */
 +int snd_hdac_sync_audio_rate(struct hdac_device *codec, hda_nid_t nid,
 +			     int dev_id, int rate)
 +{
 +	struct hdac_bus *bus = codec->bus;
 +	struct i915_audio_component *acomp = bus->audio_component;
 +	int port, pipe;
 +
 +	if (!acomp || !acomp->ops || !acomp->ops->sync_audio_rate)
 +		return -ENODEV;
 +	port = pin2port(codec, nid);
 +	if (port < 0)
 +		return -EINVAL;
 +	pipe = dev_id;
 +	return acomp->ops->sync_audio_rate(acomp->dev, port, pipe, rate);
 +}
 +EXPORT_SYMBOL_GPL(snd_hdac_sync_audio_rate);
 +
 +/**
 + * snd_hdac_acomp_get_eld - Get the audio state and ELD via component
 + * @codec: HDA codec
 + * @nid: the pin widget NID
 + * @dev_id: device identifier
 + * @audio_enabled: the pointer to store the current audio state
 + * @buffer: the buffer pointer to store ELD bytes
 + * @max_bytes: the max bytes to be stored on @buffer
 + *
 + * This function is supposed to be used only by a HD-audio controller
 + * driver that needs the interaction with i915 graphics.
 + *
 + * This function queries the current state of the audio on the given
 + * digital port and fetches the ELD bytes onto the given buffer.
 + * It returns the number of bytes for the total ELD data, zero for
 + * invalid ELD, or a negative error code.
 + *
 + * The return size is the total bytes required for the whole ELD bytes,
 + * thus it may be over @max_bytes.  If it's over @max_bytes, it implies
 + * that only a part of ELD bytes have been fetched.
 + */
 +int snd_hdac_acomp_get_eld(struct hdac_device *codec, hda_nid_t nid, int dev_id,
 +			   bool *audio_enabled, char *buffer, int max_bytes)
 +{
 +	struct hdac_bus *bus = codec->bus;
 +	struct i915_audio_component *acomp = bus->audio_component;
 +	int port, pipe;
 +
 +	if (!acomp || !acomp->ops || !acomp->ops->get_eld)
 +		return -ENODEV;
 +
 +	port = pin2port(codec, nid);
 +	if (port < 0)
 +		return -EINVAL;
 +
 +	pipe = dev_id;
 +	return acomp->ops->get_eld(acomp->dev, port, pipe, audio_enabled,
 +				   buffer, max_bytes);
 +}
 +EXPORT_SYMBOL_GPL(snd_hdac_acomp_get_eld);
 +
 +static int hdac_component_master_bind(struct device *dev)
 +{
 +	struct i915_audio_component *acomp = hdac_acomp;
 +	int ret;
 +
 +	ret = component_bind_all(dev, acomp);
 +	if (ret < 0)
 +		return ret;
 +
 +	if (WARN_ON(!(acomp->dev && acomp->ops && acomp->ops->get_power &&
 +		      acomp->ops->put_power && acomp->ops->get_cdclk_freq))) {
 +		ret = -EINVAL;
 +		goto out_unbind;
 +	}
 +
 +	/*
 +	 * Atm, we don't support dynamic unbinding initiated by the child
 +	 * component, so pin its containing module until we unbind.
 +	 */
 +	if (!try_module_get(acomp->ops->owner)) {
 +		ret = -ENODEV;
 +		goto out_unbind;
 +	}
 +
 +	return 0;
 +
 +out_unbind:
 +	component_unbind_all(dev, acomp);
 +
 +	return ret;
 +}
 +
 +static void hdac_component_master_unbind(struct device *dev)
 +{
 +	struct i915_audio_component *acomp = hdac_acomp;
 +
 +	module_put(acomp->ops->owner);
 +	component_unbind_all(dev, acomp);
 +	WARN_ON(acomp->ops || acomp->dev);
 +}
 +
 +static const struct component_master_ops hdac_component_master_ops = {
 +	.bind = hdac_component_master_bind,
 +	.unbind = hdac_component_master_unbind,
 +};
 +
 +static int hdac_component_master_match(struct device *dev, void *data)
 +{
 +	/* i915 is the only supported component */
  	return !strcmp(dev->driver->name, "i915");
  }
  
 +/**
 + * snd_hdac_i915_register_notifier - Register i915 audio component ops
 + * @aops: i915 audio component ops
 + *
 + * This function is supposed to be used only by a HD-audio controller
 + * driver that needs the interaction with i915 graphics.
 + *
 + * This function sets the given ops to be called by the i915 graphics driver.
 + *
 + * Returns zero for success or a negative error code.
 + */
 +int snd_hdac_i915_register_notifier(const struct i915_audio_component_audio_ops *aops)
 +{
 +	if (!hdac_acomp)
 +		return -ENODEV;
 +
 +	hdac_acomp->audio_ops = aops;
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(snd_hdac_i915_register_notifier);
 +
++=======
++	return !strcmp(dev->driver->name, "i915");
++}
++
++>>>>>>> a57942bfdd61 (ALSA: hda: Make audio component support more generic)
  /* check whether intel graphics is present */
  static bool i915_gfx_present(void)
  {
@@@ -359,83 -111,26 +360,104 @@@
   */
  int snd_hdac_i915_init(struct hdac_bus *bus)
  {
++<<<<<<< HEAD
 +	struct component_match *match = NULL;
 +	struct device *dev = bus->dev;
 +	struct i915_audio_component *acomp;
 +	int ret;
++=======
+ 	struct drm_audio_component *acomp;
+ 	int err;
++>>>>>>> a57942bfdd61 (ALSA: hda: Make audio component support more generic)
  
  	if (!i915_gfx_present())
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	if (WARN_ON(hdac_acomp))
 +		return -EBUSY;
 +
 +	acomp = kzalloc(sizeof(*acomp), GFP_KERNEL);
 +	if (!acomp)
 +		return -ENOMEM;
 +	bus->audio_component = acomp;
 +	hdac_acomp = acomp;
 +
 +	component_match_add(dev, &match, hdac_component_master_match, bus);
 +	ret = component_master_add_with_match(dev, &hdac_component_master_ops,
 +					      match);
 +	if (ret < 0)
 +		goto out_err;
 +
 +	/*
 +	 * Atm, we don't support deferring the component binding, so make sure
 +	 * i915 is loaded and that the binding successfully completes.
 +	 */
 +	request_module("i915");
 +
++=======
+ 	err = snd_hdac_acomp_init(bus, NULL,
+ 				  i915_component_master_match,
+ 				  sizeof(struct i915_audio_component) - sizeof(*acomp));
+ 	if (err < 0)
+ 		return err;
+ 	acomp = bus->audio_component;
+ 	if (!acomp)
+ 		return -ENODEV;
+ 	if (!acomp->ops)
+ 		request_module("i915");
++>>>>>>> a57942bfdd61 (ALSA: hda: Make audio component support more generic)
  	if (!acomp->ops) {
- 		ret = -ENODEV;
- 		goto out_master_del;
+ 		snd_hdac_acomp_exit(bus);
+ 		return -ENODEV;
  	}
- 	dev_dbg(dev, "bound to i915 component master\n");
- 
  	return 0;
++<<<<<<< HEAD
 +out_master_del:
 +	component_master_del(dev, &hdac_component_master_ops);
 +out_err:
 +	kfree(acomp);
 +	bus->audio_component = NULL;
 +	hdac_acomp = NULL;
 +	dev_info(dev, "failed to add i915 component master (%d)\n", ret);
 +
 +	return ret;
 +}
 +EXPORT_SYMBOL_GPL(snd_hdac_i915_init);
 +
 +/**
 + * snd_hdac_i915_exit - Finalize i915 audio component
 + * @bus: HDA core bus
 + *
 + * This function is supposed to be used only by a HD-audio controller
 + * driver that needs the interaction with i915 graphics.
 + *
 + * This function releases the i915 audio component that has been used.
 + *
 + * Returns zero for success or a negative error code.
 + */
 +int snd_hdac_i915_exit(struct hdac_bus *bus)
 +{
 +	struct device *dev = bus->dev;
 +	struct i915_audio_component *acomp = bus->audio_component;
 +
 +	if (!acomp)
 +		return 0;
 +
 +	WARN_ON(bus->i915_power_refcount);
 +	if (bus->i915_power_refcount > 0 && acomp->ops)
 +		acomp->ops->put_power(acomp->dev);
 +
 +	component_master_del(dev, &hdac_component_master_ops);
 +
 +	kfree(acomp);
 +	bus->audio_component = NULL;
 +	hdac_acomp = NULL;
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(snd_hdac_i915_exit);
++=======
+ }
+ EXPORT_SYMBOL_GPL(snd_hdac_i915_init);
++>>>>>>> a57942bfdd61 (ALSA: hda: Make audio component support more generic)
diff --cc sound/pci/hda/patch_hdmi.c
index 4648c40d4484,1de5491fb9bf..000000000000
--- a/sound/pci/hda/patch_hdmi.c
+++ b/sound/pci/hda/patch_hdmi.c
@@@ -2295,7 -2288,7 +2295,11 @@@ static void generic_hdmi_free(struct hd
  	int pin_idx, pcm_idx;
  
  	if (codec_has_acomp(codec))
++<<<<<<< HEAD
 +		snd_hdac_i915_register_notifier(NULL);
++=======
+ 		snd_hdac_acomp_register_notifier(&codec->bus->core, NULL);
++>>>>>>> a57942bfdd61 (ALSA: hda: Make audio component support more generic)
  
  	for (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {
  		struct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);
@@@ -2524,8 -2540,10 +2551,15 @@@ static void register_i915_notifier(stru
  	 * We need make sure audio_ptr is really setup
  	 */
  	wmb();
++<<<<<<< HEAD
 +	spec->i915_audio_ops.pin_eld_notify = intel_pin_eld_notify;
 +	snd_hdac_i915_register_notifier(&spec->i915_audio_ops);
++=======
+ 	spec->drm_audio_ops.pin2port = intel_pin2port;
+ 	spec->drm_audio_ops.pin_eld_notify = intel_pin_eld_notify;
+ 	snd_hdac_acomp_register_notifier(&codec->bus->core,
+ 					&spec->drm_audio_ops);
++>>>>>>> a57942bfdd61 (ALSA: hda: Make audio component support more generic)
  }
  
  /* setup_stream ops override for HSW+ */
diff --cc sound/soc/codecs/hdac_hdmi.c
index 84f7a7a36e4b,4748a9d5de3b..000000000000
--- a/sound/soc/codecs/hdac_hdmi.c
+++ b/sound/soc/codecs/hdac_hdmi.c
@@@ -1542,13 -1530,18 +1542,18 @@@ free_widgets
  	return ret;
  }
  
+ static int hdac_hdmi_pin2port(void *aptr, int pin)
+ {
+ 	return pin - 4; /* map NID 0x05 -> port #1 */
+ }
+ 
  static void hdac_hdmi_eld_notify_cb(void *aptr, int port, int pipe)
  {
 -	struct hdac_device *hdev = aptr;
 -	struct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);
 +	struct hdac_ext_device *edev = aptr;
 +	struct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(&edev->hdev);
  	struct hdac_hdmi_pin *pin = NULL;
  	struct hdac_hdmi_port *hport = NULL;
 -	struct snd_soc_component *component = hdmi->component;
 +	struct snd_soc_component *component = edev->scodec;
  	int i;
  
  	/* Don't know how this mapping is derived */
@@@ -1595,7 -1588,8 +1600,12 @@@
  
  }
  
++<<<<<<< HEAD
 +static struct i915_audio_component_audio_ops aops = {
++=======
+ static struct drm_audio_component_audio_ops aops = {
+ 	.pin2port	= hdac_hdmi_pin2port,
++>>>>>>> a57942bfdd61 (ALSA: hda: Make audio component support more generic)
  	.pin_eld_notify	= hdac_hdmi_eld_notify_cb,
  };
  
@@@ -1823,11 -1817,10 +1833,16 @@@ static int hdmi_codec_probe(struct snd_
  	if (ret < 0)
  		return ret;
  
++<<<<<<< HEAD
 +	aops.audio_ptr = edev;
 +	ret = snd_hdac_i915_register_notifier(&aops);
++=======
+ 	aops.audio_ptr = hdev;
+ 	ret = snd_hdac_acomp_register_notifier(hdev->bus, &aops);
++>>>>>>> a57942bfdd61 (ALSA: hda: Make audio component support more generic)
  	if (ret < 0) {
 -		dev_err(&hdev->dev, "notifier register failed: err: %d\n", ret);
 +		dev_err(&edev->hdev.dev, "notifier register failed: err: %d\n",
 +				ret);
  		return ret;
  	}
  
* Unmerged path include/drm/drm_audio_component.h
diff --git a/drivers/gpu/drm/i915/Kconfig b/drivers/gpu/drm/i915/Kconfig
index dfd95889f4b7..5c607f2c707b 100644
--- a/drivers/gpu/drm/i915/Kconfig
+++ b/drivers/gpu/drm/i915/Kconfig
@@ -23,6 +23,7 @@ config DRM_I915
 	select SYNC_FILE
 	select IOSF_MBI
 	select CRC32
+	select SND_HDA_I915 if SND_HDA_CORE
 	help
 	  Choose this option if you have a system that has "Intel Graphics
 	  Media Accelerator" or "HD Graphics" integrated graphics,
* Unmerged path include/drm/drm_audio_component.h
diff --git a/include/sound/hda_component.h b/include/sound/hda_component.h
new file mode 100644
index 000000000000..78626cde7081
--- /dev/null
+++ b/include/sound/hda_component.h
@@ -0,0 +1,61 @@
+// SPDX-License-Identifier: GPL-2.0
+// HD-Audio helpers to sync with DRM driver
+
+#ifndef __SOUND_HDA_COMPONENT_H
+#define __SOUND_HDA_COMPONENT_H
+
+#include <drm/drm_audio_component.h>
+
+#ifdef CONFIG_SND_HDA_COMPONENT
+int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable);
+int snd_hdac_display_power(struct hdac_bus *bus, bool enable);
+int snd_hdac_sync_audio_rate(struct hdac_device *codec, hda_nid_t nid,
+			     int dev_id, int rate);
+int snd_hdac_acomp_get_eld(struct hdac_device *codec, hda_nid_t nid, int dev_id,
+			   bool *audio_enabled, char *buffer, int max_bytes);
+int snd_hdac_acomp_init(struct hdac_bus *bus,
+			const struct drm_audio_component_audio_ops *aops,
+			int (*match_master)(struct device *, void *),
+			size_t extra_size);
+int snd_hdac_acomp_exit(struct hdac_bus *bus);
+int snd_hdac_acomp_register_notifier(struct hdac_bus *bus,
+				    const struct drm_audio_component_audio_ops *ops);
+#else
+static inline int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable)
+{
+	return 0;
+}
+static inline int snd_hdac_display_power(struct hdac_bus *bus, bool enable)
+{
+	return 0;
+}
+static inline int snd_hdac_sync_audio_rate(struct hdac_device *codec,
+					   hda_nid_t nid, int dev_id, int rate)
+{
+	return 0;
+}
+static inline int snd_hdac_acomp_get_eld(struct hdac_device *codec, hda_nid_t nid,
+					 int dev_id, bool *audio_enabled,
+					 char *buffer, int max_bytes)
+{
+	return -ENODEV;
+}
+static inline int snd_hdac_acomp_init(struct hdac_bus *bus,
+				      const struct drm_audio_component_audio_ops *aops,
+				      int (*match_master)(struct device *, void *),
+				      size_t extra_size)
+{
+	return -ENODEV;
+}
+static inline int snd_hdac_acomp_exit(struct hdac_bus *bus)
+{
+	return 0;
+}
+static inline int snd_hdac_acomp_register_notifier(struct hdac_bus *bus,
+						  const struct drm_audio_component_audio_ops *ops)
+{
+	return -ENODEV;
+}
+#endif
+
+#endif /* __SOUND_HDA_COMPONENT_H */
* Unmerged path include/sound/hda_i915.h
diff --git a/sound/hda/Kconfig b/sound/hda/Kconfig
index 3129546398d0..2d90e11b3eaa 100644
--- a/sound/hda/Kconfig
+++ b/sound/hda/Kconfig
@@ -5,11 +5,12 @@ config SND_HDA_CORE
 config SND_HDA_DSP_LOADER
 	bool
 
+config SND_HDA_COMPONENT
+	bool
+
 config SND_HDA_I915
 	bool
-	default y
-	depends on DRM_I915
-	depends on SND_HDA_CORE
+	select SND_HDA_COMPONENT
 
 config SND_HDA_EXT_CORE
        tristate
diff --git a/sound/hda/Makefile b/sound/hda/Makefile
index 3b9bedee2fa4..7cf5af9732dc 100644
--- a/sound/hda/Makefile
+++ b/sound/hda/Makefile
@@ -5,6 +5,7 @@ snd-hda-core-objs += trace.o
 CFLAGS_trace.o := -I$(src)
 
 # for sync with i915 gfx driver
+snd-hda-core-$(CONFIG_SND_HDA_COMPONENT) += hdac_component.o
 snd-hda-core-$(CONFIG_SND_HDA_I915) += hdac_i915.o
 
 obj-$(CONFIG_SND_HDA_CORE) += snd-hda-core.o
diff --git a/sound/hda/hdac_component.c b/sound/hda/hdac_component.c
new file mode 100644
index 000000000000..6e46a9c73aed
--- /dev/null
+++ b/sound/hda/hdac_component.c
@@ -0,0 +1,335 @@
+// SPDX-License-Identifier: GPL-2.0
+// hdac_component.c - routines for sync between HD-A core and DRM driver
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/component.h>
+#include <sound/core.h>
+#include <sound/hdaudio.h>
+#include <sound/hda_component.h>
+#include <sound/hda_register.h>
+
+static void hdac_acomp_release(struct device *dev, void *res)
+{
+}
+
+static struct drm_audio_component *hdac_get_acomp(struct device *dev)
+{
+	return devres_find(dev, hdac_acomp_release, NULL, NULL);
+}
+
+/**
+ * snd_hdac_set_codec_wakeup - Enable / disable HDMI/DP codec wakeup
+ * @bus: HDA core bus
+ * @enable: enable or disable the wakeup
+ *
+ * This function is supposed to be used only by a HD-audio controller
+ * driver that needs the interaction with graphics driver.
+ *
+ * This function should be called during the chip reset, also called at
+ * resume for updating STATESTS register read.
+ *
+ * Returns zero for success or a negative error code.
+ */
+int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable)
+{
+	struct drm_audio_component *acomp = bus->audio_component;
+
+	if (!acomp || !acomp->ops)
+		return -ENODEV;
+
+	if (!acomp->ops->codec_wake_override)
+		return 0;
+
+	dev_dbg(bus->dev, "%s codec wakeup\n",
+		enable ? "enable" : "disable");
+
+	acomp->ops->codec_wake_override(acomp->dev, enable);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_set_codec_wakeup);
+
+/**
+ * snd_hdac_display_power - Power up / down the power refcount
+ * @bus: HDA core bus
+ * @enable: power up or down
+ *
+ * This function is supposed to be used only by a HD-audio controller
+ * driver that needs the interaction with graphics driver.
+ *
+ * This function manages a refcount and calls the get_power() and
+ * put_power() ops accordingly, toggling the codec wakeup, too.
+ *
+ * Returns zero for success or a negative error code.
+ */
+int snd_hdac_display_power(struct hdac_bus *bus, bool enable)
+{
+	struct drm_audio_component *acomp = bus->audio_component;
+
+	if (!acomp || !acomp->ops)
+		return -ENODEV;
+
+	dev_dbg(bus->dev, "display power %s\n",
+		enable ? "enable" : "disable");
+
+	if (enable) {
+		if (!bus->drm_power_refcount++) {
+			if (acomp->ops->get_power)
+				acomp->ops->get_power(acomp->dev);
+			snd_hdac_set_codec_wakeup(bus, true);
+			snd_hdac_set_codec_wakeup(bus, false);
+		}
+	} else {
+		WARN_ON(!bus->drm_power_refcount);
+		if (!--bus->drm_power_refcount)
+			if (acomp->ops->put_power)
+				acomp->ops->put_power(acomp->dev);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_display_power);
+
+/**
+ * snd_hdac_sync_audio_rate - Set N/CTS based on the sample rate
+ * @codec: HDA codec
+ * @nid: the pin widget NID
+ * @dev_id: device identifier
+ * @rate: the sample rate to set
+ *
+ * This function is supposed to be used only by a HD-audio controller
+ * driver that needs the interaction with graphics driver.
+ *
+ * This function sets N/CTS value based on the given sample rate.
+ * Returns zero for success, or a negative error code.
+ */
+int snd_hdac_sync_audio_rate(struct hdac_device *codec, hda_nid_t nid,
+			     int dev_id, int rate)
+{
+	struct hdac_bus *bus = codec->bus;
+	struct drm_audio_component *acomp = bus->audio_component;
+	int port, pipe;
+
+	if (!acomp || !acomp->ops || !acomp->ops->sync_audio_rate)
+		return -ENODEV;
+	port = nid;
+	if (acomp->audio_ops && acomp->audio_ops->pin2port) {
+		port = acomp->audio_ops->pin2port(codec, nid);
+		if (port < 0)
+			return -EINVAL;
+	}
+	pipe = dev_id;
+	return acomp->ops->sync_audio_rate(acomp->dev, port, pipe, rate);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_sync_audio_rate);
+
+/**
+ * snd_hdac_acomp_get_eld - Get the audio state and ELD via component
+ * @codec: HDA codec
+ * @nid: the pin widget NID
+ * @dev_id: device identifier
+ * @audio_enabled: the pointer to store the current audio state
+ * @buffer: the buffer pointer to store ELD bytes
+ * @max_bytes: the max bytes to be stored on @buffer
+ *
+ * This function is supposed to be used only by a HD-audio controller
+ * driver that needs the interaction with graphics driver.
+ *
+ * This function queries the current state of the audio on the given
+ * digital port and fetches the ELD bytes onto the given buffer.
+ * It returns the number of bytes for the total ELD data, zero for
+ * invalid ELD, or a negative error code.
+ *
+ * The return size is the total bytes required for the whole ELD bytes,
+ * thus it may be over @max_bytes.  If it's over @max_bytes, it implies
+ * that only a part of ELD bytes have been fetched.
+ */
+int snd_hdac_acomp_get_eld(struct hdac_device *codec, hda_nid_t nid, int dev_id,
+			   bool *audio_enabled, char *buffer, int max_bytes)
+{
+	struct hdac_bus *bus = codec->bus;
+	struct drm_audio_component *acomp = bus->audio_component;
+	int port, pipe;
+
+	if (!acomp || !acomp->ops || !acomp->ops->get_eld)
+		return -ENODEV;
+
+	port = nid;
+	if (acomp->audio_ops && acomp->audio_ops->pin2port) {
+		port = acomp->audio_ops->pin2port(codec, nid);
+		if (port < 0)
+			return -EINVAL;
+	}
+	pipe = dev_id;
+	return acomp->ops->get_eld(acomp->dev, port, pipe, audio_enabled,
+				   buffer, max_bytes);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_acomp_get_eld);
+
+static int hdac_component_master_bind(struct device *dev)
+{
+	struct drm_audio_component *acomp = hdac_get_acomp(dev);
+	int ret;
+
+	if (WARN_ON(!acomp))
+		return -EINVAL;
+
+	ret = component_bind_all(dev, acomp);
+	if (ret < 0)
+		return ret;
+
+	if (WARN_ON(!(acomp->dev && acomp->ops))) {
+		ret = -EINVAL;
+		goto out_unbind;
+	}
+
+	/* pin the module to avoid dynamic unbinding, but only if given */
+	if (!try_module_get(acomp->ops->owner)) {
+		ret = -ENODEV;
+		goto out_unbind;
+	}
+
+	if (acomp->audio_ops && acomp->audio_ops->master_bind) {
+		ret = acomp->audio_ops->master_bind(dev, acomp);
+		if (ret < 0)
+			goto module_put;
+	}
+
+	return 0;
+
+ module_put:
+	module_put(acomp->ops->owner);
+out_unbind:
+	component_unbind_all(dev, acomp);
+
+	return ret;
+}
+
+static void hdac_component_master_unbind(struct device *dev)
+{
+	struct drm_audio_component *acomp = hdac_get_acomp(dev);
+
+	if (acomp->audio_ops && acomp->audio_ops->master_unbind)
+		acomp->audio_ops->master_unbind(dev, acomp);
+	module_put(acomp->ops->owner);
+	component_unbind_all(dev, acomp);
+	WARN_ON(acomp->ops || acomp->dev);
+}
+
+static const struct component_master_ops hdac_component_master_ops = {
+	.bind = hdac_component_master_bind,
+	.unbind = hdac_component_master_unbind,
+};
+
+/**
+ * snd_hdac_acomp_register_notifier - Register audio component ops
+ * @bus: HDA core bus
+ * @aops: audio component ops
+ *
+ * This function is supposed to be used only by a HD-audio controller
+ * driver that needs the interaction with graphics driver.
+ *
+ * This function sets the given ops to be called by the graphics driver.
+ *
+ * Returns zero for success or a negative error code.
+ */
+int snd_hdac_acomp_register_notifier(struct hdac_bus *bus,
+				    const struct drm_audio_component_audio_ops *aops)
+{
+	if (!bus->audio_component)
+		return -ENODEV;
+
+	bus->audio_component->audio_ops = aops;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_acomp_register_notifier);
+
+/**
+ * snd_hdac_acomp_init - Initialize audio component
+ * @bus: HDA core bus
+ * @match_master: match function for finding components
+ * @extra_size: Extra bytes to allocate
+ *
+ * This function is supposed to be used only by a HD-audio controller
+ * driver that needs the interaction with graphics driver.
+ *
+ * This function initializes and sets up the audio component to communicate
+ * with graphics driver.
+ *
+ * Unlike snd_hdac_i915_init(), this function doesn't synchronize with the
+ * binding with the DRM component.  Each caller needs to sync via master_bind
+ * audio_ops.
+ *
+ * Returns zero for success or a negative error code.
+ */
+int snd_hdac_acomp_init(struct hdac_bus *bus,
+			const struct drm_audio_component_audio_ops *aops,
+			int (*match_master)(struct device *, void *),
+			size_t extra_size)
+{
+	struct component_match *match = NULL;
+	struct device *dev = bus->dev;
+	struct drm_audio_component *acomp;
+	int ret;
+
+	if (WARN_ON(hdac_get_acomp(dev)))
+		return -EBUSY;
+
+	acomp = devres_alloc(hdac_acomp_release, sizeof(*acomp) + extra_size,
+			     GFP_KERNEL);
+	if (!acomp)
+		return -ENOMEM;
+	acomp->audio_ops = aops;
+	bus->audio_component = acomp;
+	devres_add(dev, acomp);
+
+	component_match_add(dev, &match, match_master, bus);
+	ret = component_master_add_with_match(dev, &hdac_component_master_ops,
+					      match);
+	if (ret < 0)
+		goto out_err;
+
+	return 0;
+
+out_err:
+	bus->audio_component = NULL;
+	devres_destroy(dev, hdac_acomp_release, NULL, NULL);
+	dev_info(dev, "failed to add audio component master (%d)\n", ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_acomp_init);
+
+/**
+ * snd_hdac_acomp_exit - Finalize audio component
+ * @bus: HDA core bus
+ *
+ * This function is supposed to be used only by a HD-audio controller
+ * driver that needs the interaction with graphics driver.
+ *
+ * This function releases the audio component that has been used.
+ *
+ * Returns zero for success or a negative error code.
+ */
+int snd_hdac_acomp_exit(struct hdac_bus *bus)
+{
+	struct device *dev = bus->dev;
+	struct drm_audio_component *acomp = bus->audio_component;
+
+	if (!acomp)
+		return 0;
+
+	WARN_ON(bus->drm_power_refcount);
+	if (bus->drm_power_refcount > 0 && acomp->ops)
+		acomp->ops->put_power(acomp->dev);
+
+	component_master_del(dev, &hdac_component_master_ops);
+
+	bus->audio_component = NULL;
+	devres_destroy(dev, hdac_acomp_release, NULL, NULL);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_acomp_exit);
* Unmerged path sound/hda/hdac_i915.c
* Unmerged path sound/pci/hda/patch_hdmi.c
* Unmerged path sound/soc/codecs/hdac_hdmi.c
