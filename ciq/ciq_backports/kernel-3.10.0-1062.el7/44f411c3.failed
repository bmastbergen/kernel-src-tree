NFSv4.x: fix lock recovery during delegation recall

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Olga Kornievskaia <kolga@netapp.com>
commit 44f411c353bf6d98d5a34f8f1b8605d43b2e50b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/44f411c3.failed

Running "./nfstest_delegation --runtest recall26" uncovers that
client doesn't recover the lock when we have an appending open,
where the initial open got a write delegation.

Instead of checking for the passed in open context against
the file lock's open context. Check that the state is the same.

	Signed-off-by: Olga Kornievskaia <kolga@netapp.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 44f411c353bf6d98d5a34f8f1b8605d43b2e50b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/delegation.c
diff --cc fs/nfs/delegation.c
index c08c85b97fa2,07b839560576..000000000000
--- a/fs/nfs/delegation.c
+++ b/fs/nfs/delegation.c
@@@ -95,19 -97,20 +95,27 @@@ static int nfs_delegation_claim_locks(s
  {
  	struct inode *inode = state->inode;
  	struct file_lock *fl;
 -	struct file_lock_context *flctx = inode->i_flctx;
 -	struct list_head *list;
  	int status = 0;
  
 -	if (flctx == NULL)
 +	if (inode->i_flock == NULL)
  		goto out;
  
++<<<<<<< HEAD
 +	/* Protect inode->i_flock using the i_lock */
 +	spin_lock(&inode->i_lock);
 +	for (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {
 +		if (!(fl->fl_flags & (FL_POSIX|FL_FLOCK)))
 +			continue;
 +		if (nfs_file_open_context(fl->fl_file) != ctx)
++=======
+ 	list = &flctx->flc_posix;
+ 	spin_lock(&flctx->flc_lock);
+ restart:
+ 	list_for_each_entry(fl, list, fl_list) {
+ 		if (nfs_file_open_context(fl->fl_file)->state != state)
++>>>>>>> 44f411c353bf (NFSv4.x: fix lock recovery during delegation recall)
  			continue;
 -		spin_unlock(&flctx->flc_lock);
 +		spin_unlock(&inode->i_lock);
  		status = nfs4_lock_delegation_recall(fl, state, stateid);
  		if (status < 0)
  			goto out;
* Unmerged path fs/nfs/delegation.c
