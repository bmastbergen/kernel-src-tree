tun: free skb in early errors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Wei Xu <wexu@redhat.com>
commit c33ee15b3820a03cf8229ba9415084197b827f8c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c33ee15b.failed

tun_recvmsg() supports accepting skb by msg_control after
commit ac77cfd4258f ("tun: support receiving skb through msg_control"),
the skb if presented should be freed no matter how far it can go
along, otherwise it would be leaked.

This patch fixes several missed cases.

	Signed-off-by: Wei Xu <wexu@redhat.com>
	Reported-by: Matthew Rosato <mjrosato@linux.vnet.ibm.com>
	Acked-by: Michael S. Tsirkin <mst@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c33ee15b3820a03cf8229ba9415084197b827f8c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/tun.c
diff --cc drivers/net/tun.c
index 35cc09f13a24,4f4a842a1c9c..000000000000
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@@ -1659,15 -1952,20 +1659,22 @@@ static ssize_t tun_do_read(struct tun_s
  
  	tun_debug(KERN_INFO, tun, "tun_do_read\n");
  
++<<<<<<< HEAD
 +	if (!len)
++=======
+ 	if (!iov_iter_count(to)) {
+ 		if (skb)
+ 			kfree_skb(skb);
++>>>>>>> c33ee15b3820 (tun: free skb in early errors)
  		return 0;
+ 	}
  
 -	if (!skb) {
 -		/* Read frames from ring */
 -		skb = tun_ring_recv(tfile, noblock, &err);
 -		if (!skb)
 -			return err;
 -	}
 +	/* Read frames from ring */
 +	skb = tun_ring_recv(tun, tfile, noblock, &err);
 +	if (!skb)
 +		return err;
  
 -	ret = tun_put_user(tun, tfile, skb, to);
 +	ret = tun_put_user(tun, tfile, skb, iv, len);
  	if (unlikely(ret < 0))
  		kfree_skb(skb);
  	else
@@@ -1837,34 -2071,41 +1844,58 @@@ static int tun_recvmsg(struct kiocb *io
  		       int flags)
  {
  	struct tun_file *tfile = container_of(sock, struct tun_file, socket);
++<<<<<<< HEAD
 +	struct tun_struct *tun = __tun_get(tfile);
++=======
+ 	struct tun_struct *tun = tun_get(tfile);
+ 	struct sk_buff *skb = m->msg_control;
++>>>>>>> c33ee15b3820 (tun: free skb in early errors)
  	int ret;
  
- 	if (!tun)
- 		return -EBADFD;
+ 	if (!tun) {
+ 		ret = -EBADFD;
+ 		goto out_free_skb;
+ 	}
  
 -	if (flags & ~(MSG_DONTWAIT|MSG_TRUNC|MSG_ERRQUEUE)) {
 +	if (flags & ~(MSG_DONTWAIT|MSG_TRUNC)) {
  		ret = -EINVAL;
- 		goto out;
+ 		goto out_put_tun;
  	}
++<<<<<<< HEAD
 +	ret = tun_do_read(tun, tfile, iocb, m->msg_iov, total_len,
 +			  flags & MSG_DONTWAIT);
 +	if (ret > total_len) {
++=======
+ 	if (flags & MSG_ERRQUEUE) {
+ 		ret = sock_recv_errqueue(sock->sk, m, total_len,
+ 					 SOL_PACKET, TUN_TX_TIMESTAMP);
+ 		goto out;
+ 	}
+ 	ret = tun_do_read(tun, tfile, &m->msg_iter, flags & MSG_DONTWAIT, skb);
+ 	if (ret > (ssize_t)total_len) {
++>>>>>>> c33ee15b3820 (tun: free skb in early errors)
  		m->msg_flags |= MSG_TRUNC;
  		ret = flags & MSG_TRUNC ? ret : total_len;
  	}
  out:
  	tun_put(tun);
  	return ret;
+ 
+ out_put_tun:
+ 	tun_put(tun);
+ out_free_skb:
+ 	if (skb)
+ 		kfree_skb(skb);
+ 	return ret;
  }
  
 +static int tun_release(struct socket *sock)
 +{
 +	if (sock->sk)
 +		sock_put(sock->sk);
 +	return 0;
 +}
 +
  static int tun_peek_len(struct socket *sock)
  {
  	struct tun_file *tfile = container_of(sock, struct tun_file, socket);
* Unmerged path drivers/net/tun.c
