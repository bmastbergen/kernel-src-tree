net/mlx5e: Add extack messages for TC offload failures

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Add extack messages for TC offload failures (Alaa Hleihel) [1642498]
Rebuild_FUZZ: 96.15%
commit-author Eli Britstein <elibr@mellanox.com>
commit e98bedf5e61beb8ea4707e97ff9ef14d9deeb0c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e98bedf5.failed

Return tc extack messages for failures to user space.
Messages provide reasons for not being able to offload rules to HW.

	Signed-off-by: Eli Britstein <elibr@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit e98bedf5e61beb8ea4707e97ff9ef14d9deeb0c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 3a01f0d3c372,eeb2b215f5a4..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -2053,8 -2139,9 +2110,14 @@@ static int parse_tc_nic_actions(struct 
  		}
  
  		if (is_tcf_csum(a)) {
++<<<<<<< HEAD
 +			if (csum_offload_supported(priv, attr->action,
 +						   tcf_csum_update_flags(a)))
++=======
+ 			if (csum_offload_supported(priv, action,
+ 						   tcf_csum_update_flags(a),
+ 						   extack))
++>>>>>>> e98bedf5e61b (net/mlx5e: Add extack messages for TC offload failures)
  				continue;
  
  			return -EOPNOTSUPP;
@@@ -2067,9 -2154,11 +2130,11 @@@
  			    same_hw_devs(priv, netdev_priv(peer_dev))) {
  				parse_attr->mirred_ifindex = peer_dev->ifindex;
  				flow->flags |= MLX5E_TC_FLOW_HAIRPIN;
 -				action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 -					  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +				attr->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +						MLX5_FLOW_CONTEXT_ACTION_COUNT;
  			} else {
+ 				NL_SET_ERR_MSG_MOD(extack,
+ 						   "device is not on same HW, can't offload");
  				netdev_warn(priv->netdev, "device %s not on same HW, can't offload\n",
  					    peer_dev->name);
  				return -EINVAL;
@@@ -2094,7 -2183,8 +2159,12 @@@
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	if (!actions_match_supported(priv, exts, parse_attr, flow))
++=======
+ 	attr->action = action;
+ 	if (!actions_match_supported(priv, exts, parse_attr, flow, extack))
++>>>>>>> e98bedf5e61b (net/mlx5e: Add extack messages for TC offload failures)
  		return -EOPNOTSUPP;
  
  	return 0;
@@@ -2483,14 -2586,11 +2553,15 @@@ static int mlx5e_attach_encap(struct ml
  			      struct ip_tunnel_info *tun_info,
  			      struct net_device *mirred_dev,
  			      struct net_device **encap_dev,
- 			      struct mlx5e_tc_flow *flow)
+ 			      struct mlx5e_tc_flow *flow,
+ 			      struct netlink_ext_ack *extack)
  {
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 +	struct mlx5e_rep_priv *uplink_rpriv = mlx5_eswitch_get_uplink_priv(esw,
 +									   REP_ETH);
 +	struct net_device *up_dev = uplink_rpriv->netdev;
  	unsigned short family = ip_tunnel_info_af(tun_info);
 +	struct mlx5e_priv *up_priv = netdev_priv(up_dev);
  	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
  	struct ip_tunnel_key *key = &tun_info->key;
  	struct mlx5e_encap_entry *e;
@@@ -2566,9 -2670,60 +2641,10 @@@ out_err
  	return err;
  }
  
 -static int parse_tc_vlan_action(struct mlx5e_priv *priv,
 -				const struct tc_action *a,
 -				struct mlx5_esw_flow_attr *attr,
 -				u32 *action)
 -{
 -	u8 vlan_idx = attr->total_vlan;
 -
 -	if (vlan_idx >= MLX5_FS_VLAN_DEPTH)
 -		return -EOPNOTSUPP;
 -
 -	if (tcf_vlan_action(a) == TCA_VLAN_ACT_POP) {
 -		if (vlan_idx) {
 -			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev,
 -								 MLX5_FS_VLAN_DEPTH))
 -				return -EOPNOTSUPP;
 -
 -			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP_2;
 -		} else {
 -			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;
 -		}
 -	} else if (tcf_vlan_action(a) == TCA_VLAN_ACT_PUSH) {
 -		attr->vlan_vid[vlan_idx] = tcf_vlan_push_vid(a);
 -		attr->vlan_prio[vlan_idx] = tcf_vlan_push_prio(a);
 -		attr->vlan_proto[vlan_idx] = tcf_vlan_push_proto(a);
 -		if (!attr->vlan_proto[vlan_idx])
 -			attr->vlan_proto[vlan_idx] = htons(ETH_P_8021Q);
 -
 -		if (vlan_idx) {
 -			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev,
 -								 MLX5_FS_VLAN_DEPTH))
 -				return -EOPNOTSUPP;
 -
 -			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH_2;
 -		} else {
 -			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev, 1) &&
 -			    (tcf_vlan_push_proto(a) != htons(ETH_P_8021Q) ||
 -			     tcf_vlan_push_prio(a)))
 -				return -EOPNOTSUPP;
 -
 -			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH;
 -		}
 -	} else { /* action is TCA_VLAN_ACT_MODIFY */
 -		return -EOPNOTSUPP;
 -	}
 -
 -	attr->total_vlan = vlan_idx + 1;
 -
 -	return 0;
 -}
 -
  static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
  				struct mlx5e_tc_flow_parse_attr *parse_attr,
- 				struct mlx5e_tc_flow *flow)
+ 				struct mlx5e_tc_flow *flow,
+ 				struct netlink_ext_ack *extack)
  {
  	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
  	struct mlx5e_rep_priv *rpriv = priv->ppriv;
@@@ -2583,17 -2740,28 +2659,39 @@@
  	attr->in_rep = rpriv->rep;
  	attr->in_mdev = priv->mdev;
  
 -	tcf_exts_for_each_action(i, a, exts) {
 +	tcf_exts_to_list(exts, &actions);
 +	list_for_each_entry(a, &actions, list) {
  		if (is_tcf_gact_shot(a)) {
++<<<<<<< HEAD
 +			attr->action |= MLX5_FLOW_CONTEXT_ACTION_DROP |
 +					MLX5_FLOW_CONTEXT_ACTION_COUNT;
++=======
+ 			action |= MLX5_FLOW_CONTEXT_ACTION_DROP |
+ 				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
+ 			continue;
+ 		}
+ 
+ 		if (is_tcf_pedit(a)) {
+ 			err = parse_tc_pedit_action(priv, a, MLX5_FLOW_NAMESPACE_FDB,
+ 						    parse_attr, extack);
+ 			if (err)
+ 				return err;
+ 
+ 			action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
+ 			attr->mirror_count = attr->out_count;
++>>>>>>> e98bedf5e61b (net/mlx5e: Add extack messages for TC offload failures)
  			continue;
  		}
  
  		if (is_tcf_csum(a)) {
++<<<<<<< HEAD
 +			if (csum_offload_supported(priv, attr->action,
 +						   tcf_csum_update_flags(a)))
++=======
+ 			if (csum_offload_supported(priv, action,
+ 						   tcf_csum_update_flags(a),
+ 						   extack))
++>>>>>>> e98bedf5e61b (net/mlx5e: Add extack messages for TC offload failures)
  				continue;
  
  			return -EOPNOTSUPP;
@@@ -2617,23 -2773,34 +2715,36 @@@
  
  			out_dev = tcf_mirred_dev(a);
  
++<<<<<<< HEAD
++=======
+ 			if (attr->out_count >= MLX5_MAX_FLOW_FWD_VPORTS) {
+ 				NL_SET_ERR_MSG_MOD(extack,
+ 						   "can't support more output ports, can't offload forwarding");
+ 				pr_err("can't support more than %d output ports, can't offload forwarding\n",
+ 				       attr->out_count);
+ 				return -EOPNOTSUPP;
+ 			}
+ 
++>>>>>>> e98bedf5e61b (net/mlx5e: Add extack messages for TC offload failures)
  			if (switchdev_port_same_parent_id(priv->netdev,
 -							  out_dev) ||
 -			    is_merged_eswitch_dev(priv, out_dev)) {
 -				action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 -					  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +							  out_dev)) {
 +				attr->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +					MLX5_FLOW_CONTEXT_ACTION_COUNT;
  				out_priv = netdev_priv(out_dev);
  				rpriv = out_priv->ppriv;
 -				attr->out_rep[attr->out_count] = rpriv->rep;
 -				attr->out_mdev[attr->out_count++] = out_priv->mdev;
 +				attr->out_rep = rpriv->rep;
 +				attr->out_mdev = out_priv->mdev;
  			} else if (encap) {
  				parse_attr->mirred_ifindex = out_dev->ifindex;
  				parse_attr->tun_info = *info;
  				attr->parse_attr = parse_attr;
 -				action |= MLX5_FLOW_CONTEXT_ACTION_ENCAP |
 -					  MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 -					  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +				attr->action |= MLX5_FLOW_CONTEXT_ACTION_ENCAP |
 +					MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +					MLX5_FLOW_CONTEXT_ACTION_COUNT;
  				/* attr->out_rep is resolved when we handle encap */
  			} else {
+ 				NL_SET_ERR_MSG_MOD(extack,
+ 						   "devices are not on same switch HW, can't offload forwarding");
  				pr_err("devices %s %s not on same switch HW, can't offload forwarding\n",
  				       priv->netdev->name, out_dev->name);
  				return -EINVAL;
@@@ -2679,9 -2836,17 +2790,23 @@@
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	if (!actions_match_supported(priv, exts, parse_attr, flow))
 +		return -EOPNOTSUPP;
 +
++=======
+ 	attr->action = action;
+ 	if (!actions_match_supported(priv, exts, parse_attr, flow, extack))
+ 		return -EOPNOTSUPP;
+ 
+ 	if (attr->out_count > 1 && !mlx5_esw_has_fwd_fdb(priv->mdev)) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "current firmware doesn't support split rule for port mirroring");
+ 		netdev_warn_once(priv->netdev, "current firmware doesn't support split rule for port mirroring\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
++>>>>>>> e98bedf5e61b (net/mlx5e: Add extack messages for TC offload failures)
  	return 0;
  }
  
@@@ -2758,19 -2926,23 +2886,31 @@@ int mlx5e_configure_flower(struct mlx5e
  		goto err_free;
  
  	if (flow->flags & MLX5E_TC_FLOW_ESWITCH) {
- 		err = parse_tc_fdb_actions(priv, f->exts, parse_attr, flow);
+ 		err = parse_tc_fdb_actions(priv, f->exts, parse_attr, flow,
+ 					   extack);
  		if (err < 0)
  			goto err_free;
++<<<<<<< HEAD
 +		flow->rule = mlx5e_tc_add_fdb_flow(priv, parse_attr, flow);
++=======
+ 		flow->rule[0] = mlx5e_tc_add_fdb_flow(priv, parse_attr, flow,
+ 						      extack);
++>>>>>>> e98bedf5e61b (net/mlx5e: Add extack messages for TC offload failures)
  	} else {
- 		err = parse_tc_nic_actions(priv, f->exts, parse_attr, flow);
+ 		err = parse_tc_nic_actions(priv, f->exts, parse_attr, flow,
+ 					   extack);
  		if (err < 0)
  			goto err_free;
++<<<<<<< HEAD
 +		flow->rule = mlx5e_tc_add_nic_flow(priv, parse_attr, flow);
++=======
+ 		flow->rule[0] = mlx5e_tc_add_nic_flow(priv, parse_attr, flow,
+ 						      extack);
++>>>>>>> e98bedf5e61b (net/mlx5e: Add extack messages for TC offload failures)
  	}
  
 -	if (IS_ERR(flow->rule[0])) {
 -		err = PTR_ERR(flow->rule[0]);
 +	if (IS_ERR(flow->rule)) {
 +		err = PTR_ERR(flow->rule);
  		if (err != -EAGAIN)
  			goto err_free;
  	}
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
