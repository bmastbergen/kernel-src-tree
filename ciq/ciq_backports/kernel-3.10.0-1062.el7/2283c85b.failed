ALSA: hda/ca0132 - Add output set commands for AE-5

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Connor McAdams <conmanx360@gmail.com>
commit 2283c85b4aa6b65e23be898f6a629d260e0cc07a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/2283c85b.failed

This patch adds output selection commands for the AE-5.

	Signed-off-by: Connor McAdams <conmanx360@gmail.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 2283c85b4aa6b65e23be898f6a629d260e0cc07a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index 20ce308ff039,2b7442f4a72d..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -477,6 -511,184 +477,187 @@@ static struct ct_voicefx_preset ca0132_
  	}
  };
  
++<<<<<<< HEAD
++=======
+ /* ca0132 EQ presets, taken from Windows Sound Blaster Z Driver */
+ 
+ #define EQ_PRESET_MAX_PARAM_COUNT 11
+ 
+ struct ct_eq {
+ 	char *name;
+ 	hda_nid_t nid;
+ 	int mid;
+ 	int reqs[EQ_PRESET_MAX_PARAM_COUNT]; /*effect module request*/
+ };
+ 
+ struct ct_eq_preset {
+ 	char *name; /*preset name*/
+ 	unsigned int vals[EQ_PRESET_MAX_PARAM_COUNT];
+ };
+ 
+ static const struct ct_eq ca0132_alt_eq_enum = {
+ 	.name = "FX: Equalizer Preset Switch",
+ 	.nid = EQ_PRESET_ENUM,
+ 	.mid = 0x96,
+ 	.reqs = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
+ };
+ 
+ 
+ static const struct ct_eq_preset ca0132_alt_eq_presets[] = {
+ 	{ .name = "Flat",
+ 	 .vals = { 0x00000000, 0x00000000, 0x00000000,
+ 		   0x00000000, 0x00000000, 0x00000000,
+ 		   0x00000000, 0x00000000, 0x00000000,
+ 		   0x00000000, 0x00000000	     }
+ 	},
+ 	{ .name = "Acoustic",
+ 	 .vals = { 0x00000000, 0x00000000, 0x3F8CCCCD,
+ 		   0x40000000, 0x00000000, 0x00000000,
+ 		   0x00000000, 0x00000000, 0x40000000,
+ 		   0x40000000, 0x40000000	     }
+ 	},
+ 	{ .name = "Classical",
+ 	 .vals = { 0x00000000, 0x00000000, 0x40C00000,
+ 		   0x40C00000, 0x40466666, 0x00000000,
+ 		   0x00000000, 0x00000000, 0x00000000,
+ 		   0x40466666, 0x40466666	     }
+ 	},
+ 	{ .name = "Country",
+ 	 .vals = { 0x00000000, 0xBF99999A, 0x00000000,
+ 		   0x3FA66666, 0x3FA66666, 0x3F8CCCCD,
+ 		   0x00000000, 0x00000000, 0x40000000,
+ 		   0x40466666, 0x40800000	     }
+ 	},
+ 	{ .name = "Dance",
+ 	 .vals = { 0x00000000, 0xBF99999A, 0x40000000,
+ 		   0x40466666, 0x40866666, 0xBF99999A,
+ 		   0xBF99999A, 0x00000000, 0x00000000,
+ 		   0x40800000, 0x40800000	     }
+ 	},
+ 	{ .name = "Jazz",
+ 	 .vals = { 0x00000000, 0x00000000, 0x00000000,
+ 		   0x3F8CCCCD, 0x40800000, 0x40800000,
+ 		   0x40800000, 0x00000000, 0x3F8CCCCD,
+ 		   0x40466666, 0x40466666	     }
+ 	},
+ 	{ .name = "New Age",
+ 	 .vals = { 0x00000000, 0x00000000, 0x40000000,
+ 		   0x40000000, 0x00000000, 0x00000000,
+ 		   0x00000000, 0x3F8CCCCD, 0x40000000,
+ 		   0x40000000, 0x40000000	     }
+ 	},
+ 	{ .name = "Pop",
+ 	 .vals = { 0x00000000, 0xBFCCCCCD, 0x00000000,
+ 		   0x40000000, 0x40000000, 0x00000000,
+ 		   0xBF99999A, 0xBF99999A, 0x00000000,
+ 		   0x40466666, 0x40C00000	     }
+ 	},
+ 	{ .name = "Rock",
+ 	 .vals = { 0x00000000, 0xBF99999A, 0xBF99999A,
+ 		   0x3F8CCCCD, 0x40000000, 0xBF99999A,
+ 		   0xBF99999A, 0x00000000, 0x00000000,
+ 		   0x40800000, 0x40800000	     }
+ 	},
+ 	{ .name = "Vocal",
+ 	 .vals = { 0x00000000, 0xC0000000, 0xBF99999A,
+ 		   0xBF99999A, 0x00000000, 0x40466666,
+ 		   0x40800000, 0x40466666, 0x00000000,
+ 		   0x00000000, 0x3F8CCCCD	     }
+ 	}
+ };
+ 
+ /* DSP command sequences for ca0132_alt_select_out */
+ #define ALT_OUT_SET_MAX_COMMANDS 9 /* Max number of commands in sequence */
+ struct ca0132_alt_out_set {
+ 	char *name; /*preset name*/
+ 	unsigned char commands;
+ 	unsigned int mids[ALT_OUT_SET_MAX_COMMANDS];
+ 	unsigned int reqs[ALT_OUT_SET_MAX_COMMANDS];
+ 	unsigned int vals[ALT_OUT_SET_MAX_COMMANDS];
+ };
+ 
+ static const struct ca0132_alt_out_set alt_out_presets[] = {
+ 	{ .name = "Line Out",
+ 	  .commands = 7,
+ 	  .mids = { 0x96, 0x96, 0x96, 0x8F,
+ 		    0x96, 0x96, 0x96 },
+ 	  .reqs = { 0x19, 0x17, 0x18, 0x01,
+ 		    0x1F, 0x15, 0x3A },
+ 	  .vals = { 0x3F000000, 0x42A00000, 0x00000000,
+ 		    0x00000000, 0x00000000, 0x00000000,
+ 		    0x00000000 }
+ 	},
+ 	{ .name = "Headphone",
+ 	  .commands = 7,
+ 	  .mids = { 0x96, 0x96, 0x96, 0x8F,
+ 		    0x96, 0x96, 0x96 },
+ 	  .reqs = { 0x19, 0x17, 0x18, 0x01,
+ 		    0x1F, 0x15, 0x3A },
+ 	  .vals = { 0x3F000000, 0x42A00000, 0x00000000,
+ 		    0x00000000, 0x00000000, 0x00000000,
+ 		    0x00000000 }
+ 	},
+ 	{ .name = "Surround",
+ 	  .commands = 8,
+ 	  .mids = { 0x96, 0x8F, 0x96, 0x96,
+ 		    0x96, 0x96, 0x96, 0x96 },
+ 	  .reqs = { 0x18, 0x01, 0x1F, 0x15,
+ 		    0x3A, 0x1A, 0x1B, 0x1C },
+ 	  .vals = { 0x00000000, 0x00000000, 0x00000000,
+ 		    0x00000000, 0x00000000, 0x00000000,
+ 		    0x00000000, 0x00000000 }
+ 	}
+ };
+ 
+ /*
+  * DSP volume setting structs. Req 1 is left volume, req 2 is right volume,
+  * and I don't know what the third req is, but it's always zero. I assume it's
+  * some sort of update or set command to tell the DSP there's new volume info.
+  */
+ #define DSP_VOL_OUT 0
+ #define DSP_VOL_IN  1
+ 
+ struct ct_dsp_volume_ctl {
+ 	hda_nid_t vnid;
+ 	int mid; /* module ID*/
+ 	unsigned int reqs[3]; /* scp req ID */
+ };
+ 
+ static const struct ct_dsp_volume_ctl ca0132_alt_vol_ctls[] = {
+ 	{ .vnid = VNID_SPK,
+ 	  .mid = 0x32,
+ 	  .reqs = {3, 4, 2}
+ 	},
+ 	{ .vnid = VNID_MIC,
+ 	  .mid = 0x37,
+ 	  .reqs = {2, 3, 1}
+ 	}
+ };
+ 
+ /* Values for ca0113_mmio_command_set for selecting output. */
+ #define AE5_CA0113_OUT_SET_COMMANDS 6
+ struct ae5_ca0113_output_set {
+ 	unsigned int group[AE5_CA0113_OUT_SET_COMMANDS];
+ 	unsigned int target[AE5_CA0113_OUT_SET_COMMANDS];
+ 	unsigned int vals[AE5_CA0113_OUT_SET_COMMANDS];
+ };
+ 
+ static const struct ae5_ca0113_output_set ae5_ca0113_output_presets[] = {
+ 	{ .group =  { 0x30, 0x30, 0x48, 0x48, 0x48, 0x30 },
+ 	  .target = { 0x2e, 0x30, 0x0d, 0x17, 0x19, 0x32 },
+ 	  .vals =   { 0x00, 0x00, 0x40, 0x00, 0x00, 0x3f }
+ 	},
+ 	{ .group =  { 0x30, 0x30, 0x48, 0x48, 0x48, 0x30 },
+ 	  .target = { 0x2e, 0x30, 0x0d, 0x17, 0x19, 0x32 },
+ 	  .vals =   { 0x3f, 0x3f, 0x00, 0x00, 0x00, 0x00 }
+ 	},
+ 	{ .group =  { 0x30, 0x30, 0x48, 0x48, 0x48, 0x30 },
+ 	  .target = { 0x2e, 0x30, 0x0d, 0x17, 0x19, 0x32 },
+ 	  .vals =   { 0x00, 0x00, 0x40, 0x00, 0x00, 0x3f }
+ 	}
+ };
+ 
++>>>>>>> 2283c85b4aa6 (ALSA: hda/ca0132 - Add output set commands for AE-5)
  enum hda_cmd_vendor_io {
  	/* for DspIO node */
  	VENDOR_DSPIO_SCP_WRITE_DATA_LOW      = 0x000,
@@@ -3324,6 -4048,265 +3505,268 @@@ exit
  	return err < 0 ? err : 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void ae5_mmio_select_out(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < AE5_CA0113_OUT_SET_COMMANDS; i++)
+ 		ca0113_mmio_command_set(codec,
+ 			ae5_ca0113_output_presets[spec->cur_out_type].group[i],
+ 			ae5_ca0113_output_presets[spec->cur_out_type].target[i],
+ 			ae5_ca0113_output_presets[spec->cur_out_type].vals[i]);
+ }
+ 
+ /*
+  * These are the commands needed to setup output on each of the different card
+  * types.
+  */
+ static void ca0132_alt_select_out_quirk_handler(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 
+ 	switch (spec->cur_out_type) {
+ 	case SPEAKER_OUT:
+ 		switch (spec->quirk) {
+ 		case QUIRK_SBZ:
+ 			ca0113_mmio_gpio_set(codec, 7, false);
+ 			ca0113_mmio_gpio_set(codec, 4, true);
+ 			ca0113_mmio_gpio_set(codec, 1, true);
+ 			chipio_set_control_param(codec, 0x0d, 0x18);
+ 			break;
+ 		case QUIRK_R3DI:
+ 			chipio_set_control_param(codec, 0x0d, 0x24);
+ 			r3di_gpio_out_set(codec, R3DI_LINE_OUT);
+ 			break;
+ 		case QUIRK_R3D:
+ 			chipio_set_control_param(codec, 0x0d, 0x24);
+ 			ca0113_mmio_gpio_set(codec, 1, true);
+ 			break;
+ 		case QUIRK_AE5:
+ 			ae5_mmio_select_out(codec);
+ 			tmp = FLOAT_ZERO;
+ 			dspio_set_uint_param(codec, 0x96, 0x29, tmp);
+ 			dspio_set_uint_param(codec, 0x96, 0x2a, tmp);
+ 			chipio_set_control_param(codec, 0x0d, 0xa4);
+ 			chipio_write(codec, 0x18b03c, 0x00000012);
+ 			break;
+ 		}
+ 		break;
+ 	case HEADPHONE_OUT:
+ 		switch (spec->quirk) {
+ 		case QUIRK_SBZ:
+ 			ca0113_mmio_gpio_set(codec, 7, true);
+ 			ca0113_mmio_gpio_set(codec, 4, true);
+ 			ca0113_mmio_gpio_set(codec, 1, false);
+ 			chipio_set_control_param(codec, 0x0d, 0x12);
+ 			break;
+ 		case QUIRK_R3DI:
+ 			chipio_set_control_param(codec, 0x0d, 0x21);
+ 			r3di_gpio_out_set(codec, R3DI_HEADPHONE_OUT);
+ 			break;
+ 		case QUIRK_R3D:
+ 			chipio_set_control_param(codec, 0x0d, 0x21);
+ 			ca0113_mmio_gpio_set(codec, 0x1, false);
+ 			break;
+ 		case QUIRK_AE5:
+ 			ae5_mmio_select_out(codec);
+ 			tmp = FLOAT_ONE;
+ 			dspio_set_uint_param(codec, 0x96, 0x29, tmp);
+ 			dspio_set_uint_param(codec, 0x96, 0x2a, tmp);
+ 			chipio_set_control_param(codec, 0x0d, 0xa1);
+ 			chipio_write(codec, 0x18b03c, 0x00000012);
+ 			break;
+ 		}
+ 		break;
+ 	case SURROUND_OUT:
+ 		switch (spec->quirk) {
+ 		case QUIRK_SBZ:
+ 			ca0113_mmio_gpio_set(codec, 7, false);
+ 			ca0113_mmio_gpio_set(codec, 4, true);
+ 			ca0113_mmio_gpio_set(codec, 1, true);
+ 			chipio_set_control_param(codec, 0x0d, 0x18);
+ 			break;
+ 		case QUIRK_R3DI:
+ 			chipio_set_control_param(codec, 0x0d, 0x24);
+ 			r3di_gpio_out_set(codec, R3DI_LINE_OUT);
+ 			break;
+ 		case QUIRK_R3D:
+ 			ca0113_mmio_gpio_set(codec, 1, true);
+ 			chipio_set_control_param(codec, 0x0d, 0x24);
+ 			break;
+ 		case QUIRK_AE5:
+ 			ae5_mmio_select_out(codec);
+ 			tmp = FLOAT_ZERO;
+ 			dspio_set_uint_param(codec, 0x96, 0x29, tmp);
+ 			dspio_set_uint_param(codec, 0x96, 0x2a, tmp);
+ 			chipio_set_control_param(codec, 0x0d, 0xa4);
+ 			chipio_write(codec, 0x18b03c, 0x00000012);
+ 			break;
+ 		}
+ 		break;
+ 	}
+ }
+ 
+ /*
+  * This function behaves similarly to the ca0132_select_out funciton above,
+  * except with a few differences. It adds the ability to select the current
+  * output with an enumerated control "output source" if the auto detect
+  * mute switch is set to off. If the auto detect mute switch is enabled, it
+  * will detect either headphone or lineout(SPEAKER_OUT) from jack detection.
+  * It also adds the ability to auto-detect the front headphone port. The only
+  * way to select surround is to disable auto detect, and set Surround with the
+  * enumerated control.
+  */
+ static int ca0132_alt_select_out(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int pin_ctl;
+ 	int jack_present;
+ 	int auto_jack;
+ 	unsigned int i;
+ 	unsigned int tmp;
+ 	int err;
+ 	/* Default Headphone is rear headphone */
+ 	hda_nid_t headphone_nid = spec->out_pins[1];
+ 
+ 	codec_dbg(codec, "%s\n", __func__);
+ 
+ 	snd_hda_power_up_pm(codec);
+ 
+ 	auto_jack = spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];
+ 
+ 	/*
+ 	 * If headphone rear or front is plugged in, set to headphone.
+ 	 * If neither is plugged in, set to rear line out. Only if
+ 	 * hp/speaker auto detect is enabled.
+ 	 */
+ 	if (auto_jack) {
+ 		jack_present = snd_hda_jack_detect(codec, spec->unsol_tag_hp) ||
+ 			   snd_hda_jack_detect(codec, spec->unsol_tag_front_hp);
+ 
+ 		if (jack_present)
+ 			spec->cur_out_type = HEADPHONE_OUT;
+ 		else
+ 			spec->cur_out_type = SPEAKER_OUT;
+ 	} else
+ 		spec->cur_out_type = spec->out_enum_val;
+ 
+ 	/* Begin DSP output switch */
+ 	tmp = FLOAT_ONE;
+ 	err = dspio_set_uint_param(codec, 0x96, 0x3A, tmp);
+ 	if (err < 0)
+ 		goto exit;
+ 
+ 	ca0132_alt_select_out_quirk_handler(codec);
+ 
+ 	switch (spec->cur_out_type) {
+ 	case SPEAKER_OUT:
+ 		codec_dbg(codec, "%s speaker\n", __func__);
+ 
+ 		/* disable headphone node */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[1], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[1],
+ 				    pin_ctl & ~PIN_HP);
+ 		/* enable line-out node */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,
+ 				AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[0],
+ 				    pin_ctl | PIN_OUT);
+ 		/* Enable EAPD */
+ 		snd_hda_codec_write(codec, spec->out_pins[0], 0,
+ 			AC_VERB_SET_EAPD_BTLENABLE, 0x01);
+ 
+ 		/* If PlayEnhancement is enabled, set different source */
+ 		if (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ONE);
+ 		else
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_EIGHT);
+ 		break;
+ 	case HEADPHONE_OUT:
+ 		codec_dbg(codec, "%s hp\n", __func__);
+ 
+ 		snd_hda_codec_write(codec, spec->out_pins[0], 0,
+ 			AC_VERB_SET_EAPD_BTLENABLE, 0x00);
+ 
+ 		/* disable speaker*/
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[0],
+ 				pin_ctl & ~PIN_HP);
+ 
+ 		/* enable headphone, either front or rear */
+ 
+ 		if (snd_hda_jack_detect(codec, spec->unsol_tag_front_hp))
+ 			headphone_nid = spec->out_pins[2];
+ 		else if (snd_hda_jack_detect(codec, spec->unsol_tag_hp))
+ 			headphone_nid = spec->out_pins[1];
+ 
+ 		pin_ctl = snd_hda_codec_read(codec, headphone_nid, 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, headphone_nid,
+ 				    pin_ctl | PIN_HP);
+ 
+ 		if (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ONE);
+ 		else
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ZERO);
+ 		break;
+ 	case SURROUND_OUT:
+ 		codec_dbg(codec, "%s surround\n", __func__);
+ 
+ 		/* enable line out node */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,
+ 				AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[0],
+ 						pin_ctl | PIN_OUT);
+ 		/* Disable headphone out */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[1], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[1],
+ 				    pin_ctl & ~PIN_HP);
+ 		/* Enable EAPD on line out */
+ 		snd_hda_codec_write(codec, spec->out_pins[0], 0,
+ 			AC_VERB_SET_EAPD_BTLENABLE, 0x01);
+ 		/* enable center/lfe out node */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[2], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[2],
+ 				    pin_ctl | PIN_OUT);
+ 		/* Now set rear surround node as out. */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[3], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[3],
+ 				    pin_ctl | PIN_OUT);
+ 
+ 		if (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ONE);
+ 		else
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_EIGHT);
+ 		break;
+ 	}
+ 
+ 	/* run through the output dsp commands for the selected output. */
+ 	for (i = 0; i < alt_out_presets[spec->cur_out_type].commands; i++) {
+ 		err = dspio_set_uint_param(codec,
+ 		alt_out_presets[spec->cur_out_type].mids[i],
+ 		alt_out_presets[spec->cur_out_type].reqs[i],
+ 		alt_out_presets[spec->cur_out_type].vals[i]);
+ 
+ 		if (err < 0)
+ 			goto exit;
+ 	}
+ 
+ exit:
+ 	snd_hda_power_down_pm(codec);
+ 
+ 	return err < 0 ? err : 0;
+ }
+ 
++>>>>>>> 2283c85b4aa6 (ALSA: hda/ca0132 - Add output set commands for AE-5)
  static void ca0132_unsol_hp_delayed(struct work_struct *work)
  {
  	struct ca0132_spec *spec = container_of(
* Unmerged path sound/pci/hda/patch_ca0132.c
