iavf: rename most of i40e strings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jesse Brandeburg <jesse.brandeburg@intel.com>
commit 56184e01c00d6d23609f9f9e52cc731568e8088f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/56184e01.failed

This is the big rename patch, it takes most of the i40e_
and I40E_ strings and renames them to iavf_ and IAVF_.

Some of the adminq code, as well as most of the client
interface code used by RDMA is left unchanged in order
to indicate that the driver is talking to non-internal to
iavf code.

	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 56184e01c00d6d23609f9f9e52cc731568e8088f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40evf/i40e_adminq.c
#	drivers/net/ethernet/intel/i40evf/i40e_alloc.h
#	drivers/net/ethernet/intel/i40evf/i40e_common.c
#	drivers/net/ethernet/intel/i40evf/i40e_osdep.h
#	drivers/net/ethernet/intel/i40evf/i40e_trace.h
#	drivers/net/ethernet/intel/i40evf/i40e_txrx.c
#	drivers/net/ethernet/intel/i40evf/i40e_txrx.h
#	drivers/net/ethernet/intel/i40evf/i40evf_client.c
#	drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
#	drivers/net/ethernet/intel/i40evf/i40evf_main.c
#	drivers/net/ethernet/intel/iavf/i40e_adminq_cmd.h
#	drivers/net/ethernet/intel/iavf/i40e_prototype.h
#	drivers/net/ethernet/intel/iavf/i40e_type.h
#	drivers/net/ethernet/intel/iavf/iavf.h
diff --cc drivers/net/ethernet/intel/i40evf/i40e_adminq.c
index 35630356cd6a,d6e76a2489d6..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_adminq.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_adminq.c
@@@ -44,11 -32,11 +44,11 @@@ static void i40e_adminq_init_regs(struc
   *  i40e_alloc_adminq_asq_ring - Allocate Admin Queue send rings
   *  @hw: pointer to the hardware structure
   **/
 -static iavf_status i40e_alloc_adminq_asq_ring(struct iavf_hw *hw)
 +static i40e_status i40e_alloc_adminq_asq_ring(struct i40e_hw *hw)
  {
 -	iavf_status ret_code;
 +	i40e_status ret_code;
  
- 	ret_code = i40e_allocate_dma_mem(hw, &hw->aq.asq.desc_buf,
+ 	ret_code = iavf_allocate_dma_mem(hw, &hw->aq.asq.desc_buf,
  					 i40e_mem_atq_ring,
  					 (hw->aq.num_asq_entries *
  					 sizeof(struct i40e_aq_desc)),
@@@ -71,11 -59,11 +71,11 @@@
   *  i40e_alloc_adminq_arq_ring - Allocate Admin Queue receive rings
   *  @hw: pointer to the hardware structure
   **/
 -static iavf_status i40e_alloc_adminq_arq_ring(struct iavf_hw *hw)
 +static i40e_status i40e_alloc_adminq_arq_ring(struct i40e_hw *hw)
  {
 -	iavf_status ret_code;
 +	i40e_status ret_code;
  
- 	ret_code = i40e_allocate_dma_mem(hw, &hw->aq.arq.desc_buf,
+ 	ret_code = iavf_allocate_dma_mem(hw, &hw->aq.arq.desc_buf,
  					 i40e_mem_arq_ring,
  					 (hw->aq.num_arq_entries *
  					 sizeof(struct i40e_aq_desc)),
@@@ -91,9 -79,9 +91,9 @@@
   *  This assumes the posted send buffers have already been cleaned
   *  and de-allocated
   **/
 -static void i40e_free_adminq_asq(struct iavf_hw *hw)
 +static void i40e_free_adminq_asq(struct i40e_hw *hw)
  {
- 	i40e_free_dma_mem(hw, &hw->aq.asq.desc_buf);
+ 	iavf_free_dma_mem(hw, &hw->aq.asq.desc_buf);
  }
  
  /**
@@@ -103,20 -91,20 +103,25 @@@
   *  This assumes the posted receive buffers have already been cleaned
   *  and de-allocated
   **/
 -static void i40e_free_adminq_arq(struct iavf_hw *hw)
 +static void i40e_free_adminq_arq(struct i40e_hw *hw)
  {
- 	i40e_free_dma_mem(hw, &hw->aq.arq.desc_buf);
+ 	iavf_free_dma_mem(hw, &hw->aq.arq.desc_buf);
  }
  
  /**
   *  i40e_alloc_arq_bufs - Allocate pre-posted buffers for the receive queue
   *  @hw: pointer to the hardware structure
   **/
 -static iavf_status i40e_alloc_arq_bufs(struct iavf_hw *hw)
 +static i40e_status i40e_alloc_arq_bufs(struct i40e_hw *hw)
  {
 +	i40e_status ret_code;
  	struct i40e_aq_desc *desc;
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +	struct i40e_dma_mem *bi;
++=======
+ 	struct iavf_dma_mem *bi;
+ 	iavf_status ret_code;
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  	int i;
  
  	/* We'll be allocating the buffer info memory first, then we can
@@@ -124,11 -112,12 +129,17 @@@
  	 */
  
  	/* buffer_info structures do not need alignment */
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +	ret_code = i40e_allocate_virt_mem(hw, &hw->aq.arq.dma_head,
 +		(hw->aq.num_arq_entries * sizeof(struct i40e_dma_mem)));
++=======
+ 	ret_code = iavf_allocate_virt_mem(hw, &hw->aq.arq.dma_head,
+ 					  (hw->aq.num_arq_entries *
+ 					   sizeof(struct iavf_dma_mem)));
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  	if (ret_code)
  		goto alloc_arq_bufs;
- 	hw->aq.arq.r.arq_bi = (struct i40e_dma_mem *)hw->aq.arq.dma_head.va;
+ 	hw->aq.arq.r.arq_bi = (struct iavf_dma_mem *)hw->aq.arq.dma_head.va;
  
  	/* allocate the mapped buffers */
  	for (i = 0; i < hw->aq.num_arq_entries; i++) {
@@@ -179,18 -168,19 +190,29 @@@ unwind_alloc_arq_bufs
   *  i40e_alloc_asq_bufs - Allocate empty buffer structs for the send queue
   *  @hw: pointer to the hardware structure
   **/
 -static iavf_status i40e_alloc_asq_bufs(struct iavf_hw *hw)
 +static i40e_status i40e_alloc_asq_bufs(struct i40e_hw *hw)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +	i40e_status ret_code;
 +	struct i40e_dma_mem *bi;
 +	int i;
 +
 +	/* No mapped memory needed yet, just the buffer info structures */
 +	ret_code = i40e_allocate_virt_mem(hw, &hw->aq.asq.dma_head,
 +		(hw->aq.num_asq_entries * sizeof(struct i40e_dma_mem)));
++=======
+ 	struct iavf_dma_mem *bi;
+ 	iavf_status ret_code;
+ 	int i;
+ 
+ 	/* No mapped memory needed yet, just the buffer info structures */
+ 	ret_code = iavf_allocate_virt_mem(hw, &hw->aq.asq.dma_head,
+ 					  (hw->aq.num_asq_entries *
+ 					   sizeof(struct iavf_dma_mem)));
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  	if (ret_code)
  		goto alloc_asq_bufs;
- 	hw->aq.asq.r.asq_bi = (struct i40e_dma_mem *)hw->aq.asq.dma_head.va;
+ 	hw->aq.asq.r.asq_bi = (struct iavf_dma_mem *)hw->aq.asq.dma_head.va;
  
  	/* allocate the mapped buffers */
  	for (i = 0; i < hw->aq.num_asq_entries; i++) {
@@@ -581,9 -568,9 +603,13 @@@ i40e_status i40evf_shutdown_adminq(stru
   *
   *  returns the number of free desc
   **/
 -static u16 i40e_clean_asq(struct iavf_hw *hw)
 +static u16 i40e_clean_asq(struct i40e_hw *hw)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +	struct i40e_adminq_ring *asq = &(hw->aq.asq);
++=======
+ 	struct iavf_adminq_ring *asq = &hw->aq.asq;
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  	struct i40e_asq_cmd_details *details;
  	u16 ntc = asq->next_to_clean;
  	struct i40e_aq_desc desc_cb;
@@@ -592,7 -579,7 +618,11 @@@
  	desc = IAVF_ADMINQ_DESC(*asq, ntc);
  	details = I40E_ADMINQ_DETAILS(*asq, ntc);
  	while (rd32(hw, hw->aq.asq.head) != ntc) {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +		i40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,
++=======
+ 		iavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE,
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  			   "ntc %d head %d.\n", ntc, rd32(hw, hw->aq.asq.head));
  
  		if (details->callback) {
@@@ -643,14 -629,12 +673,18 @@@ bool i40evf_asq_done(struct i40e_hw *hw
   *  This is the main send command driver routine for the Admin Queue send
   *  queue.  It runs the queue, cleans the queue, etc
   **/
 -iavf_status iavf_asq_send_command(struct iavf_hw *hw, struct i40e_aq_desc *desc,
 -				  void *buff, /* can be NULL */
 -				  u16  buff_size,
 -				  struct i40e_asq_cmd_details *cmd_details)
 +i40e_status i40evf_asq_send_command(struct i40e_hw *hw,
 +				struct i40e_aq_desc *desc,
 +				void *buff, /* can be NULL */
 +				u16  buff_size,
 +				struct i40e_asq_cmd_details *cmd_details)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +	i40e_status status = 0;
 +	struct i40e_dma_mem *dma_buff = NULL;
++=======
+ 	struct iavf_dma_mem *dma_buff = NULL;
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  	struct i40e_asq_cmd_details *details;
  	struct i40e_aq_desc *desc_on_ring;
  	bool cmd_completed = false;
@@@ -660,7 -645,7 +695,11 @@@
  	mutex_lock(&hw->aq.asq_mutex);
  
  	if (hw->aq.asq.count == 0) {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +		i40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,
++=======
+ 		iavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE,
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  			   "AQTX: Admin queue not initialized.\n");
  		status = I40E_ERR_QUEUE_EMPTY;
  		goto asq_send_command_error;
@@@ -670,7 -655,7 +709,11 @@@
  
  	val = rd32(hw, hw->aq.asq.head);
  	if (val >= hw->aq.num_asq_entries) {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +		i40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,
++=======
+ 		iavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE,
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  			   "AQTX: head overrun at %d\n", val);
  		status = I40E_ERR_QUEUE_EMPTY;
  		goto asq_send_command_error;
@@@ -699,8 -684,8 +742,13 @@@
  	desc->flags |= cpu_to_le16(details->flags_ena);
  
  	if (buff_size > hw->aq.asq_buf_size) {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +		i40e_debug(hw,
 +			   I40E_DEBUG_AQ_MESSAGE,
++=======
+ 		iavf_debug(hw,
+ 			   IAVF_DEBUG_AQ_MESSAGE,
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  			   "AQTX: Invalid buffer size: %d.\n",
  			   buff_size);
  		status = I40E_ERR_INVALID_SIZE;
@@@ -708,8 -693,8 +756,13 @@@
  	}
  
  	if (details->postpone && !details->async) {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +		i40e_debug(hw,
 +			   I40E_DEBUG_AQ_MESSAGE,
++=======
+ 		iavf_debug(hw,
+ 			   IAVF_DEBUG_AQ_MESSAGE,
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  			   "AQTX: Async flag not set along with postpone flag");
  		status = I40E_ERR_PARAM;
  		goto asq_send_command_error;
@@@ -723,8 -708,8 +776,13 @@@
  	 * in case of asynchronous completions
  	 */
  	if (i40e_clean_asq(hw) == 0) {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +		i40e_debug(hw,
 +			   I40E_DEBUG_AQ_MESSAGE,
++=======
+ 		iavf_debug(hw,
+ 			   IAVF_DEBUG_AQ_MESSAGE,
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  			   "AQTX: Error queue is full.\n");
  		status = I40E_ERR_ADMIN_QUEUE_FULL;
  		goto asq_send_command_error;
@@@ -753,9 -738,9 +811,15 @@@
  	}
  
  	/* bump the tail */
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +	i40e_debug(hw, I40E_DEBUG_AQ_MESSAGE, "AQTX: desc and buffer:\n");
 +	i40evf_debug_aq(hw, I40E_DEBUG_AQ_COMMAND, (void *)desc_on_ring,
 +			buff, buff_size);
++=======
+ 	iavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE, "AQTX: desc and buffer:\n");
+ 	iavf_debug_aq(hw, IAVF_DEBUG_AQ_COMMAND, (void *)desc_on_ring,
+ 		      buff, buff_size);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  	(hw->aq.asq.next_to_use)++;
  	if (hw->aq.asq.next_to_use == hw->aq.asq.count)
  		hw->aq.asq.next_to_use = 0;
@@@ -786,8 -771,8 +850,13 @@@
  			memcpy(buff, dma_buff->va, buff_size);
  		retval = le16_to_cpu(desc->retval);
  		if (retval != 0) {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +			i40e_debug(hw,
 +				   I40E_DEBUG_AQ_MESSAGE,
++=======
+ 			iavf_debug(hw,
+ 				   IAVF_DEBUG_AQ_MESSAGE,
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  				   "AQTX: Command completed with error 0x%X.\n",
  				   retval);
  
@@@ -804,10 -789,9 +873,16 @@@
  		hw->aq.asq_last_status = (enum i40e_admin_queue_err)retval;
  	}
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +	i40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,
 +		   "AQTX: desc and buffer writeback:\n");
 +	i40evf_debug_aq(hw, I40E_DEBUG_AQ_COMMAND, (void *)desc, buff,
 +			buff_size);
++=======
+ 	iavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE,
+ 		   "AQTX: desc and buffer writeback:\n");
+ 	iavf_debug_aq(hw, IAVF_DEBUG_AQ_COMMAND, (void *)desc, buff, buff_size);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  
  	/* save writeback aq if requested */
  	if (details->wb_desc)
@@@ -816,12 -800,12 +891,21 @@@
  	/* update the error if time out occurred */
  	if ((!cmd_completed) &&
  	    (!details->async && !details->postpone)) {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +		if (rd32(hw, hw->aq.asq.len) & I40E_VF_ATQLEN1_ATQCRIT_MASK) {
 +			i40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,
 +				   "AQTX: AQ Critical error.\n");
 +			status = I40E_ERR_ADMIN_QUEUE_CRITICAL_ERROR;
 +		} else {
 +			i40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,
++=======
+ 		if (rd32(hw, hw->aq.asq.len) & IAVF_VF_ATQLEN1_ATQCRIT_MASK) {
+ 			iavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE,
+ 				   "AQTX: AQ Critical error.\n");
+ 			status = I40E_ERR_ADMIN_QUEUE_CRITICAL_ERROR;
+ 		} else {
+ 			iavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE,
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  				   "AQTX: Writeback timeout.\n");
  			status = I40E_ERR_ADMIN_QUEUE_TIMEOUT;
  		}
@@@ -858,14 -841,14 +942,19 @@@ void i40evf_fill_default_direct_cmd_des
   *  the contents through e.  It can also return how many events are
   *  left to process through 'pending'
   **/
 -iavf_status iavf_clean_arq_element(struct iavf_hw *hw,
 -				   struct i40e_arq_event_info *e,
 -				   u16 *pending)
 +i40e_status i40evf_clean_arq_element(struct i40e_hw *hw,
 +					     struct i40e_arq_event_info *e,
 +					     u16 *pending)
  {
 +	i40e_status ret_code = 0;
  	u16 ntc = hw->aq.arq.next_to_clean;
  	struct i40e_aq_desc *desc;
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +	struct i40e_dma_mem *bi;
++=======
+ 	iavf_status ret_code = 0;
+ 	struct iavf_dma_mem *bi;
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  	u16 desc_idx;
  	u16 datalen;
  	u16 flags;
@@@ -878,7 -861,7 +967,11 @@@
  	mutex_lock(&hw->aq.arq_mutex);
  
  	if (hw->aq.arq.count == 0) {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +		i40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,
++=======
+ 		iavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE,
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  			   "AQRX: Admin queue not initialized.\n");
  		ret_code = I40E_ERR_QUEUE_EMPTY;
  		goto clean_arq_element_err;
@@@ -901,8 -884,8 +994,13 @@@
  	flags = le16_to_cpu(desc->flags);
  	if (flags & I40E_AQ_FLAG_ERR) {
  		ret_code = I40E_ERR_ADMIN_QUEUE_ERROR;
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +		i40e_debug(hw,
 +			   I40E_DEBUG_AQ_MESSAGE,
++=======
+ 		iavf_debug(hw,
+ 			   IAVF_DEBUG_AQ_MESSAGE,
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  			   "AQRX: Event received with error 0x%X.\n",
  			   hw->aq.arq_last_status);
  	}
@@@ -914,9 -897,9 +1012,15 @@@
  		memcpy(e->msg_buf, hw->aq.arq.r.arq_bi[desc_idx].va,
  		       e->msg_len);
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +	i40e_debug(hw, I40E_DEBUG_AQ_MESSAGE, "AQRX: desc and buffer:\n");
 +	i40evf_debug_aq(hw, I40E_DEBUG_AQ_COMMAND, (void *)desc, e->msg_buf,
 +			hw->aq.arq_buf_size);
++=======
+ 	iavf_debug(hw, IAVF_DEBUG_AQ_MESSAGE, "AQRX: desc and buffer:\n");
+ 	iavf_debug_aq(hw, IAVF_DEBUG_AQ_COMMAND, (void *)desc, e->msg_buf,
+ 		      hw->aq.arq_buf_size);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  
  	/* Restore the original datalen and buffer address in the desc,
  	 * FW updates datalen to indicate the event message
diff --cc drivers/net/ethernet/intel/i40evf/i40e_alloc.h
index cb8689222c8b,bf2753146f30..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_alloc.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_alloc.h
@@@ -1,35 -1,31 +1,45 @@@
  /* SPDX-License-Identifier: GPL-2.0 */
  /* Copyright(c) 2013 - 2018 Intel Corporation. */
  
- #ifndef _I40E_ALLOC_H_
- #define _I40E_ALLOC_H_
+ #ifndef _IAVF_ALLOC_H_
+ #define _IAVF_ALLOC_H_
  
 -struct iavf_hw;
 +struct i40e_hw;
  
  /* Memory allocation types */
- enum i40e_memory_type {
- 	i40e_mem_arq_buf = 0,		/* ARQ indirect command buffer */
- 	i40e_mem_asq_buf = 1,
- 	i40e_mem_atq_buf = 2,		/* ATQ indirect command buffer */
- 	i40e_mem_arq_ring = 3,		/* ARQ descriptor ring */
- 	i40e_mem_atq_ring = 4,		/* ATQ descriptor ring */
- 	i40e_mem_pd = 5,		/* Page Descriptor */
- 	i40e_mem_bp = 6,		/* Backing Page - 4KB */
- 	i40e_mem_bp_jumbo = 7,		/* Backing Page - > 4KB */
- 	i40e_mem_reserved
+ enum iavf_memory_type {
+ 	iavf_mem_arq_buf = 0,		/* ARQ indirect command buffer */
+ 	iavf_mem_asq_buf = 1,
+ 	iavf_mem_atq_buf = 2,		/* ATQ indirect command buffer */
+ 	iavf_mem_arq_ring = 3,		/* ARQ descriptor ring */
+ 	iavf_mem_atq_ring = 4,		/* ATQ descriptor ring */
+ 	iavf_mem_pd = 5,		/* Page Descriptor */
+ 	iavf_mem_bp = 6,		/* Backing Page - 4KB */
+ 	iavf_mem_bp_jumbo = 7,		/* Backing Page - > 4KB */
+ 	iavf_mem_reserved
  };
  
  /* prototype for functions used for dynamic memory allocation */
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_alloc.h
 +i40e_status i40e_allocate_dma_mem(struct i40e_hw *hw,
 +					    struct i40e_dma_mem *mem,
 +					    enum i40e_memory_type type,
 +					    u64 size, u32 alignment);
 +i40e_status i40e_free_dma_mem(struct i40e_hw *hw,
 +					struct i40e_dma_mem *mem);
 +i40e_status i40e_allocate_virt_mem(struct i40e_hw *hw,
 +					     struct i40e_virt_mem *mem,
 +					     u32 size);
 +i40e_status i40e_free_virt_mem(struct i40e_hw *hw,
 +					 struct i40e_virt_mem *mem);
++=======
+ iavf_status iavf_allocate_dma_mem(struct iavf_hw *hw, struct iavf_dma_mem *mem,
+ 				  enum iavf_memory_type type,
+ 				  u64 size, u32 alignment);
+ iavf_status iavf_free_dma_mem(struct iavf_hw *hw, struct iavf_dma_mem *mem);
+ iavf_status iavf_allocate_virt_mem(struct iavf_hw *hw,
+ 				   struct iavf_virt_mem *mem, u32 size);
+ iavf_status iavf_free_virt_mem(struct iavf_hw *hw, struct iavf_virt_mem *mem);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_alloc.h
  
- #endif /* _I40E_ALLOC_H_ */
+ #endif /* _IAVF_ALLOC_H_ */
diff --cc drivers/net/ethernet/intel/i40evf/i40e_common.c
index eea280ba411e,d9fd2f24b3e7..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_common.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_common.c
@@@ -13,43 -13,22 +13,57 @@@
   * This function sets the mac type of the adapter based on the
   * vendor ID and device ID stored in the hw structure.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +i40e_status i40e_set_mac_type(struct i40e_hw *hw)
++=======
+ iavf_status iavf_set_mac_type(struct iavf_hw *hw)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
 -	iavf_status status = 0;
 +	i40e_status status = 0;
  
  	if (hw->vendor_id == PCI_VENDOR_ID_INTEL) {
  		switch (hw->device_id) {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +		case I40E_DEV_ID_SFP_XL710:
 +		case I40E_DEV_ID_QEMU:
 +		case I40E_DEV_ID_KX_B:
 +		case I40E_DEV_ID_KX_C:
 +		case I40E_DEV_ID_QSFP_A:
 +		case I40E_DEV_ID_QSFP_B:
 +		case I40E_DEV_ID_QSFP_C:
 +		case I40E_DEV_ID_10G_BASE_T:
 +		case I40E_DEV_ID_10G_BASE_T4:
 +		case I40E_DEV_ID_20G_KR2:
 +		case I40E_DEV_ID_20G_KR2_A:
 +		case I40E_DEV_ID_25G_B:
 +		case I40E_DEV_ID_25G_SFP28:
 +			hw->mac.type = I40E_MAC_XL710;
 +			break;
 +		case I40E_DEV_ID_SFP_X722:
 +		case I40E_DEV_ID_1G_BASE_T_X722:
 +		case I40E_DEV_ID_10G_BASE_T_X722:
 +		case I40E_DEV_ID_SFP_I_X722:
 +			hw->mac.type = I40E_MAC_X722;
 +			break;
 +		case I40E_DEV_ID_X722_VF:
 +			hw->mac.type = I40E_MAC_X722_VF;
 +			break;
 +		case I40E_DEV_ID_VF:
 +		case I40E_DEV_ID_VF_HV:
 +		case I40E_DEV_ID_ADAPTIVE_VF:
 +			hw->mac.type = I40E_MAC_VF;
++=======
+ 		case IAVF_DEV_ID_X722_VF:
+ 			hw->mac.type = IAVF_MAC_X722_VF;
+ 			break;
+ 		case IAVF_DEV_ID_VF:
+ 		case IAVF_DEV_ID_VF_HV:
+ 		case IAVF_DEV_ID_ADAPTIVE_VF:
+ 			hw->mac.type = IAVF_MAC_VF;
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_common.c
  			break;
  		default:
- 			hw->mac.type = I40E_MAC_GENERIC;
+ 			hw->mac.type = IAVF_MAC_GENERIC;
  			break;
  		}
  	} else {
@@@ -378,7 -354,7 +392,11 @@@ i40e_status i40evf_aq_queue_shutdown(st
   *
   * Internal function to get or set RSS look up table
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +static i40e_status i40e_aq_get_set_rss_lut(struct i40e_hw *hw,
++=======
+ static iavf_status iavf_aq_get_set_rss_lut(struct iavf_hw *hw,
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_common.c
  					   u16 vsi_id, bool pf_lut,
  					   u8 *lut, u16 lut_size,
  					   bool set)
@@@ -431,10 -407,10 +449,10 @@@
   *
   * get the RSS lookup table, PF or VSI type
   **/
 -iavf_status iavf_aq_get_rss_lut(struct iavf_hw *hw, u16 vsi_id,
 -				bool pf_lut, u8 *lut, u16 lut_size)
 +i40e_status i40evf_aq_get_rss_lut(struct i40e_hw *hw, u16 vsi_id,
 +				  bool pf_lut, u8 *lut, u16 lut_size)
  {
- 	return i40e_aq_get_set_rss_lut(hw, vsi_id, pf_lut, lut, lut_size,
+ 	return iavf_aq_get_set_rss_lut(hw, vsi_id, pf_lut, lut, lut_size,
  				       false);
  }
  
@@@ -448,10 -424,10 +466,10 @@@
   *
   * set the RSS lookup table, PF or VSI type
   **/
 -iavf_status iavf_aq_set_rss_lut(struct iavf_hw *hw, u16 vsi_id,
 -				bool pf_lut, u8 *lut, u16 lut_size)
 +i40e_status i40evf_aq_set_rss_lut(struct i40e_hw *hw, u16 vsi_id,
 +				  bool pf_lut, u8 *lut, u16 lut_size)
  {
- 	return i40e_aq_get_set_rss_lut(hw, vsi_id, pf_lut, lut, lut_size, true);
+ 	return iavf_aq_get_set_rss_lut(hw, vsi_id, pf_lut, lut, lut_size, true);
  }
  
  /**
@@@ -463,12 -439,12 +481,19 @@@
   *
   * get the RSS key per VSI
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +static i40e_status i40e_aq_get_set_rss_key(struct i40e_hw *hw,
 +				      u16 vsi_id,
 +				      struct i40e_aqc_get_set_rss_key_data *key,
 +				      bool set)
++=======
+ static
+ iavf_status iavf_aq_get_set_rss_key(struct iavf_hw *hw, u16 vsi_id,
+ 				    struct i40e_aqc_get_set_rss_key_data *key,
+ 				    bool set)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
 -	iavf_status status;
 +	i40e_status status;
  	struct i40e_aq_desc desc;
  	struct i40e_aqc_get_set_rss_key *cmd_resp =
  			(struct i40e_aqc_get_set_rss_key *)&desc.params.raw;
@@@ -503,11 -479,10 +528,11 @@@
   * @key: pointer to key info struct
   *
   **/
 -iavf_status iavf_aq_get_rss_key(struct iavf_hw *hw, u16 vsi_id,
 -				struct i40e_aqc_get_set_rss_key_data *key)
 +i40e_status i40evf_aq_get_rss_key(struct i40e_hw *hw,
 +				  u16 vsi_id,
 +				  struct i40e_aqc_get_set_rss_key_data *key)
  {
- 	return i40e_aq_get_set_rss_key(hw, vsi_id, key, false);
+ 	return iavf_aq_get_set_rss_key(hw, vsi_id, key, false);
  }
  
  /**
@@@ -518,15 -493,13 +543,15 @@@
   *
   * set the RSS key per VSI
   **/
 -iavf_status iavf_aq_set_rss_key(struct iavf_hw *hw, u16 vsi_id,
 -				struct i40e_aqc_get_set_rss_key_data *key)
 +i40e_status i40evf_aq_set_rss_key(struct i40e_hw *hw,
 +				  u16 vsi_id,
 +				  struct i40e_aqc_get_set_rss_key_data *key)
  {
- 	return i40e_aq_get_set_rss_key(hw, vsi_id, key, true);
+ 	return iavf_aq_get_set_rss_key(hw, vsi_id, key, true);
  }
  
 -/* The iavf_ptype_lookup table is used to convert from the 8-bit ptype in the
 +
 +/* The i40evf_ptype_lookup table is used to convert from the 8-bit ptype in the
   * hardware to a bit-field that can be used by SW to more easily determine the
   * packet type.
   *
@@@ -539,13 -512,13 +564,13 @@@
   *
   * Typical work flow:
   *
 - * IF NOT iavf_ptype_lookup[ptype].known
 + * IF NOT i40evf_ptype_lookup[ptype].known
   * THEN
   *      Packet is unknown
 - * ELSE IF iavf_ptype_lookup[ptype].outer_ip == I40E_RX_PTYPE_OUTER_IP
 + * ELSE IF i40evf_ptype_lookup[ptype].outer_ip == I40E_RX_PTYPE_OUTER_IP
   *      Use the rest of the fields to look at the tunnels, inner protocols, etc
   * ELSE
-  *      Use the enum i40e_rx_l2_ptype to decode the packet type
+  *      Use the enum iavf_rx_l2_ptype to decode the packet type
   * ENDIF
   */
  
@@@ -566,329 -539,329 +591,333 @@@
  		{ PTYPE, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
  
  /* shorter macros makes the table fit but are terse */
- #define I40E_RX_PTYPE_NOF		I40E_RX_PTYPE_NOT_FRAG
- #define I40E_RX_PTYPE_FRG		I40E_RX_PTYPE_FRAG
- #define I40E_RX_PTYPE_INNER_PROT_TS	I40E_RX_PTYPE_INNER_PROT_TIMESYNC
+ #define IAVF_RX_PTYPE_NOF		IAVF_RX_PTYPE_NOT_FRAG
+ #define IAVF_RX_PTYPE_FRG		IAVF_RX_PTYPE_FRAG
+ #define IAVF_RX_PTYPE_INNER_PROT_TS	IAVF_RX_PTYPE_INNER_PROT_TIMESYNC
  
  /* Lookup table mapping the HW PTYPE to the bit field for decoding */
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +struct i40e_rx_ptype_decoded i40evf_ptype_lookup[] = {
++=======
+ struct iavf_rx_ptype_decoded iavf_ptype_lookup[] = {
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_common.c
  	/* L2 Packet types */
- 	I40E_PTT_UNUSED_ENTRY(0),
- 	I40E_PTT(1,  L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY2),
- 	I40E_PTT(2,  L2, NONE, NOF, NONE, NONE, NOF, TS,   PAY2),
- 	I40E_PTT(3,  L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY2),
- 	I40E_PTT_UNUSED_ENTRY(4),
- 	I40E_PTT_UNUSED_ENTRY(5),
- 	I40E_PTT(6,  L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY2),
- 	I40E_PTT(7,  L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY2),
- 	I40E_PTT_UNUSED_ENTRY(8),
- 	I40E_PTT_UNUSED_ENTRY(9),
- 	I40E_PTT(10, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY2),
- 	I40E_PTT(11, L2, NONE, NOF, NONE, NONE, NOF, NONE, NONE),
- 	I40E_PTT(12, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
- 	I40E_PTT(13, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
- 	I40E_PTT(14, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
- 	I40E_PTT(15, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
- 	I40E_PTT(16, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
- 	I40E_PTT(17, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
- 	I40E_PTT(18, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
- 	I40E_PTT(19, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
- 	I40E_PTT(20, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
- 	I40E_PTT(21, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT_UNUSED_ENTRY(0),
+ 	IAVF_PTT(1,  L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY2),
+ 	IAVF_PTT(2,  L2, NONE, NOF, NONE, NONE, NOF, TS,   PAY2),
+ 	IAVF_PTT(3,  L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY2),
+ 	IAVF_PTT_UNUSED_ENTRY(4),
+ 	IAVF_PTT_UNUSED_ENTRY(5),
+ 	IAVF_PTT(6,  L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY2),
+ 	IAVF_PTT(7,  L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY2),
+ 	IAVF_PTT_UNUSED_ENTRY(8),
+ 	IAVF_PTT_UNUSED_ENTRY(9),
+ 	IAVF_PTT(10, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY2),
+ 	IAVF_PTT(11, L2, NONE, NOF, NONE, NONE, NOF, NONE, NONE),
+ 	IAVF_PTT(12, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(13, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(14, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(15, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(16, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(17, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(18, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(19, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(20, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(21, L2, NONE, NOF, NONE, NONE, NOF, NONE, PAY3),
  
  	/* Non Tunneled IPv4 */
- 	I40E_PTT(22, IP, IPV4, FRG, NONE, NONE, NOF, NONE, PAY3),
- 	I40E_PTT(23, IP, IPV4, NOF, NONE, NONE, NOF, NONE, PAY3),
- 	I40E_PTT(24, IP, IPV4, NOF, NONE, NONE, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(25),
- 	I40E_PTT(26, IP, IPV4, NOF, NONE, NONE, NOF, TCP,  PAY4),
- 	I40E_PTT(27, IP, IPV4, NOF, NONE, NONE, NOF, SCTP, PAY4),
- 	I40E_PTT(28, IP, IPV4, NOF, NONE, NONE, NOF, ICMP, PAY4),
+ 	IAVF_PTT(22, IP, IPV4, FRG, NONE, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(23, IP, IPV4, NOF, NONE, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(24, IP, IPV4, NOF, NONE, NONE, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(25),
+ 	IAVF_PTT(26, IP, IPV4, NOF, NONE, NONE, NOF, TCP,  PAY4),
+ 	IAVF_PTT(27, IP, IPV4, NOF, NONE, NONE, NOF, SCTP, PAY4),
+ 	IAVF_PTT(28, IP, IPV4, NOF, NONE, NONE, NOF, ICMP, PAY4),
  
  	/* IPv4 --> IPv4 */
- 	I40E_PTT(29, IP, IPV4, NOF, IP_IP, IPV4, FRG, NONE, PAY3),
- 	I40E_PTT(30, IP, IPV4, NOF, IP_IP, IPV4, NOF, NONE, PAY3),
- 	I40E_PTT(31, IP, IPV4, NOF, IP_IP, IPV4, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(32),
- 	I40E_PTT(33, IP, IPV4, NOF, IP_IP, IPV4, NOF, TCP,  PAY4),
- 	I40E_PTT(34, IP, IPV4, NOF, IP_IP, IPV4, NOF, SCTP, PAY4),
- 	I40E_PTT(35, IP, IPV4, NOF, IP_IP, IPV4, NOF, ICMP, PAY4),
+ 	IAVF_PTT(29, IP, IPV4, NOF, IP_IP, IPV4, FRG, NONE, PAY3),
+ 	IAVF_PTT(30, IP, IPV4, NOF, IP_IP, IPV4, NOF, NONE, PAY3),
+ 	IAVF_PTT(31, IP, IPV4, NOF, IP_IP, IPV4, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(32),
+ 	IAVF_PTT(33, IP, IPV4, NOF, IP_IP, IPV4, NOF, TCP,  PAY4),
+ 	IAVF_PTT(34, IP, IPV4, NOF, IP_IP, IPV4, NOF, SCTP, PAY4),
+ 	IAVF_PTT(35, IP, IPV4, NOF, IP_IP, IPV4, NOF, ICMP, PAY4),
  
  	/* IPv4 --> IPv6 */
- 	I40E_PTT(36, IP, IPV4, NOF, IP_IP, IPV6, FRG, NONE, PAY3),
- 	I40E_PTT(37, IP, IPV4, NOF, IP_IP, IPV6, NOF, NONE, PAY3),
- 	I40E_PTT(38, IP, IPV4, NOF, IP_IP, IPV6, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(39),
- 	I40E_PTT(40, IP, IPV4, NOF, IP_IP, IPV6, NOF, TCP,  PAY4),
- 	I40E_PTT(41, IP, IPV4, NOF, IP_IP, IPV6, NOF, SCTP, PAY4),
- 	I40E_PTT(42, IP, IPV4, NOF, IP_IP, IPV6, NOF, ICMP, PAY4),
+ 	IAVF_PTT(36, IP, IPV4, NOF, IP_IP, IPV6, FRG, NONE, PAY3),
+ 	IAVF_PTT(37, IP, IPV4, NOF, IP_IP, IPV6, NOF, NONE, PAY3),
+ 	IAVF_PTT(38, IP, IPV4, NOF, IP_IP, IPV6, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(39),
+ 	IAVF_PTT(40, IP, IPV4, NOF, IP_IP, IPV6, NOF, TCP,  PAY4),
+ 	IAVF_PTT(41, IP, IPV4, NOF, IP_IP, IPV6, NOF, SCTP, PAY4),
+ 	IAVF_PTT(42, IP, IPV4, NOF, IP_IP, IPV6, NOF, ICMP, PAY4),
  
  	/* IPv4 --> GRE/NAT */
- 	I40E_PTT(43, IP, IPV4, NOF, IP_GRENAT, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(43, IP, IPV4, NOF, IP_GRENAT, NONE, NOF, NONE, PAY3),
  
  	/* IPv4 --> GRE/NAT --> IPv4 */
- 	I40E_PTT(44, IP, IPV4, NOF, IP_GRENAT, IPV4, FRG, NONE, PAY3),
- 	I40E_PTT(45, IP, IPV4, NOF, IP_GRENAT, IPV4, NOF, NONE, PAY3),
- 	I40E_PTT(46, IP, IPV4, NOF, IP_GRENAT, IPV4, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(47),
- 	I40E_PTT(48, IP, IPV4, NOF, IP_GRENAT, IPV4, NOF, TCP,  PAY4),
- 	I40E_PTT(49, IP, IPV4, NOF, IP_GRENAT, IPV4, NOF, SCTP, PAY4),
- 	I40E_PTT(50, IP, IPV4, NOF, IP_GRENAT, IPV4, NOF, ICMP, PAY4),
+ 	IAVF_PTT(44, IP, IPV4, NOF, IP_GRENAT, IPV4, FRG, NONE, PAY3),
+ 	IAVF_PTT(45, IP, IPV4, NOF, IP_GRENAT, IPV4, NOF, NONE, PAY3),
+ 	IAVF_PTT(46, IP, IPV4, NOF, IP_GRENAT, IPV4, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(47),
+ 	IAVF_PTT(48, IP, IPV4, NOF, IP_GRENAT, IPV4, NOF, TCP,  PAY4),
+ 	IAVF_PTT(49, IP, IPV4, NOF, IP_GRENAT, IPV4, NOF, SCTP, PAY4),
+ 	IAVF_PTT(50, IP, IPV4, NOF, IP_GRENAT, IPV4, NOF, ICMP, PAY4),
  
  	/* IPv4 --> GRE/NAT --> IPv6 */
- 	I40E_PTT(51, IP, IPV4, NOF, IP_GRENAT, IPV6, FRG, NONE, PAY3),
- 	I40E_PTT(52, IP, IPV4, NOF, IP_GRENAT, IPV6, NOF, NONE, PAY3),
- 	I40E_PTT(53, IP, IPV4, NOF, IP_GRENAT, IPV6, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(54),
- 	I40E_PTT(55, IP, IPV4, NOF, IP_GRENAT, IPV6, NOF, TCP,  PAY4),
- 	I40E_PTT(56, IP, IPV4, NOF, IP_GRENAT, IPV6, NOF, SCTP, PAY4),
- 	I40E_PTT(57, IP, IPV4, NOF, IP_GRENAT, IPV6, NOF, ICMP, PAY4),
+ 	IAVF_PTT(51, IP, IPV4, NOF, IP_GRENAT, IPV6, FRG, NONE, PAY3),
+ 	IAVF_PTT(52, IP, IPV4, NOF, IP_GRENAT, IPV6, NOF, NONE, PAY3),
+ 	IAVF_PTT(53, IP, IPV4, NOF, IP_GRENAT, IPV6, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(54),
+ 	IAVF_PTT(55, IP, IPV4, NOF, IP_GRENAT, IPV6, NOF, TCP,  PAY4),
+ 	IAVF_PTT(56, IP, IPV4, NOF, IP_GRENAT, IPV6, NOF, SCTP, PAY4),
+ 	IAVF_PTT(57, IP, IPV4, NOF, IP_GRENAT, IPV6, NOF, ICMP, PAY4),
  
  	/* IPv4 --> GRE/NAT --> MAC */
- 	I40E_PTT(58, IP, IPV4, NOF, IP_GRENAT_MAC, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(58, IP, IPV4, NOF, IP_GRENAT_MAC, NONE, NOF, NONE, PAY3),
  
  	/* IPv4 --> GRE/NAT --> MAC --> IPv4 */
- 	I40E_PTT(59, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, FRG, NONE, PAY3),
- 	I40E_PTT(60, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, NOF, NONE, PAY3),
- 	I40E_PTT(61, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(62),
- 	I40E_PTT(63, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, NOF, TCP,  PAY4),
- 	I40E_PTT(64, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, NOF, SCTP, PAY4),
- 	I40E_PTT(65, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, NOF, ICMP, PAY4),
+ 	IAVF_PTT(59, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, FRG, NONE, PAY3),
+ 	IAVF_PTT(60, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, NOF, NONE, PAY3),
+ 	IAVF_PTT(61, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(62),
+ 	IAVF_PTT(63, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, NOF, TCP,  PAY4),
+ 	IAVF_PTT(64, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, NOF, SCTP, PAY4),
+ 	IAVF_PTT(65, IP, IPV4, NOF, IP_GRENAT_MAC, IPV4, NOF, ICMP, PAY4),
  
  	/* IPv4 --> GRE/NAT -> MAC --> IPv6 */
- 	I40E_PTT(66, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, FRG, NONE, PAY3),
- 	I40E_PTT(67, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, NOF, NONE, PAY3),
- 	I40E_PTT(68, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(69),
- 	I40E_PTT(70, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, NOF, TCP,  PAY4),
- 	I40E_PTT(71, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, NOF, SCTP, PAY4),
- 	I40E_PTT(72, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, NOF, ICMP, PAY4),
+ 	IAVF_PTT(66, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, FRG, NONE, PAY3),
+ 	IAVF_PTT(67, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, NOF, NONE, PAY3),
+ 	IAVF_PTT(68, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(69),
+ 	IAVF_PTT(70, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, NOF, TCP,  PAY4),
+ 	IAVF_PTT(71, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, NOF, SCTP, PAY4),
+ 	IAVF_PTT(72, IP, IPV4, NOF, IP_GRENAT_MAC, IPV6, NOF, ICMP, PAY4),
  
  	/* IPv4 --> GRE/NAT --> MAC/VLAN */
- 	I40E_PTT(73, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(73, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, NONE, NOF, NONE, PAY3),
  
  	/* IPv4 ---> GRE/NAT -> MAC/VLAN --> IPv4 */
- 	I40E_PTT(74, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, FRG, NONE, PAY3),
- 	I40E_PTT(75, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, NONE, PAY3),
- 	I40E_PTT(76, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(77),
- 	I40E_PTT(78, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, TCP,  PAY4),
- 	I40E_PTT(79, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, SCTP, PAY4),
- 	I40E_PTT(80, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, ICMP, PAY4),
+ 	IAVF_PTT(74, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, FRG, NONE, PAY3),
+ 	IAVF_PTT(75, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, NONE, PAY3),
+ 	IAVF_PTT(76, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(77),
+ 	IAVF_PTT(78, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, TCP,  PAY4),
+ 	IAVF_PTT(79, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, SCTP, PAY4),
+ 	IAVF_PTT(80, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, ICMP, PAY4),
  
  	/* IPv4 -> GRE/NAT -> MAC/VLAN --> IPv6 */
- 	I40E_PTT(81, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, FRG, NONE, PAY3),
- 	I40E_PTT(82, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, NONE, PAY3),
- 	I40E_PTT(83, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(84),
- 	I40E_PTT(85, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, TCP,  PAY4),
- 	I40E_PTT(86, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, SCTP, PAY4),
- 	I40E_PTT(87, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, ICMP, PAY4),
+ 	IAVF_PTT(81, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, FRG, NONE, PAY3),
+ 	IAVF_PTT(82, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, NONE, PAY3),
+ 	IAVF_PTT(83, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(84),
+ 	IAVF_PTT(85, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, TCP,  PAY4),
+ 	IAVF_PTT(86, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, SCTP, PAY4),
+ 	IAVF_PTT(87, IP, IPV4, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, ICMP, PAY4),
  
  	/* Non Tunneled IPv6 */
- 	I40E_PTT(88, IP, IPV6, FRG, NONE, NONE, NOF, NONE, PAY3),
- 	I40E_PTT(89, IP, IPV6, NOF, NONE, NONE, NOF, NONE, PAY3),
- 	I40E_PTT(90, IP, IPV6, NOF, NONE, NONE, NOF, UDP,  PAY3),
- 	I40E_PTT_UNUSED_ENTRY(91),
- 	I40E_PTT(92, IP, IPV6, NOF, NONE, NONE, NOF, TCP,  PAY4),
- 	I40E_PTT(93, IP, IPV6, NOF, NONE, NONE, NOF, SCTP, PAY4),
- 	I40E_PTT(94, IP, IPV6, NOF, NONE, NONE, NOF, ICMP, PAY4),
+ 	IAVF_PTT(88, IP, IPV6, FRG, NONE, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(89, IP, IPV6, NOF, NONE, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(90, IP, IPV6, NOF, NONE, NONE, NOF, UDP,  PAY3),
+ 	IAVF_PTT_UNUSED_ENTRY(91),
+ 	IAVF_PTT(92, IP, IPV6, NOF, NONE, NONE, NOF, TCP,  PAY4),
+ 	IAVF_PTT(93, IP, IPV6, NOF, NONE, NONE, NOF, SCTP, PAY4),
+ 	IAVF_PTT(94, IP, IPV6, NOF, NONE, NONE, NOF, ICMP, PAY4),
  
  	/* IPv6 --> IPv4 */
- 	I40E_PTT(95,  IP, IPV6, NOF, IP_IP, IPV4, FRG, NONE, PAY3),
- 	I40E_PTT(96,  IP, IPV6, NOF, IP_IP, IPV4, NOF, NONE, PAY3),
- 	I40E_PTT(97,  IP, IPV6, NOF, IP_IP, IPV4, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(98),
- 	I40E_PTT(99,  IP, IPV6, NOF, IP_IP, IPV4, NOF, TCP,  PAY4),
- 	I40E_PTT(100, IP, IPV6, NOF, IP_IP, IPV4, NOF, SCTP, PAY4),
- 	I40E_PTT(101, IP, IPV6, NOF, IP_IP, IPV4, NOF, ICMP, PAY4),
+ 	IAVF_PTT(95,  IP, IPV6, NOF, IP_IP, IPV4, FRG, NONE, PAY3),
+ 	IAVF_PTT(96,  IP, IPV6, NOF, IP_IP, IPV4, NOF, NONE, PAY3),
+ 	IAVF_PTT(97,  IP, IPV6, NOF, IP_IP, IPV4, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(98),
+ 	IAVF_PTT(99,  IP, IPV6, NOF, IP_IP, IPV4, NOF, TCP,  PAY4),
+ 	IAVF_PTT(100, IP, IPV6, NOF, IP_IP, IPV4, NOF, SCTP, PAY4),
+ 	IAVF_PTT(101, IP, IPV6, NOF, IP_IP, IPV4, NOF, ICMP, PAY4),
  
  	/* IPv6 --> IPv6 */
- 	I40E_PTT(102, IP, IPV6, NOF, IP_IP, IPV6, FRG, NONE, PAY3),
- 	I40E_PTT(103, IP, IPV6, NOF, IP_IP, IPV6, NOF, NONE, PAY3),
- 	I40E_PTT(104, IP, IPV6, NOF, IP_IP, IPV6, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(105),
- 	I40E_PTT(106, IP, IPV6, NOF, IP_IP, IPV6, NOF, TCP,  PAY4),
- 	I40E_PTT(107, IP, IPV6, NOF, IP_IP, IPV6, NOF, SCTP, PAY4),
- 	I40E_PTT(108, IP, IPV6, NOF, IP_IP, IPV6, NOF, ICMP, PAY4),
+ 	IAVF_PTT(102, IP, IPV6, NOF, IP_IP, IPV6, FRG, NONE, PAY3),
+ 	IAVF_PTT(103, IP, IPV6, NOF, IP_IP, IPV6, NOF, NONE, PAY3),
+ 	IAVF_PTT(104, IP, IPV6, NOF, IP_IP, IPV6, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(105),
+ 	IAVF_PTT(106, IP, IPV6, NOF, IP_IP, IPV6, NOF, TCP,  PAY4),
+ 	IAVF_PTT(107, IP, IPV6, NOF, IP_IP, IPV6, NOF, SCTP, PAY4),
+ 	IAVF_PTT(108, IP, IPV6, NOF, IP_IP, IPV6, NOF, ICMP, PAY4),
  
  	/* IPv6 --> GRE/NAT */
- 	I40E_PTT(109, IP, IPV6, NOF, IP_GRENAT, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(109, IP, IPV6, NOF, IP_GRENAT, NONE, NOF, NONE, PAY3),
  
  	/* IPv6 --> GRE/NAT -> IPv4 */
- 	I40E_PTT(110, IP, IPV6, NOF, IP_GRENAT, IPV4, FRG, NONE, PAY3),
- 	I40E_PTT(111, IP, IPV6, NOF, IP_GRENAT, IPV4, NOF, NONE, PAY3),
- 	I40E_PTT(112, IP, IPV6, NOF, IP_GRENAT, IPV4, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(113),
- 	I40E_PTT(114, IP, IPV6, NOF, IP_GRENAT, IPV4, NOF, TCP,  PAY4),
- 	I40E_PTT(115, IP, IPV6, NOF, IP_GRENAT, IPV4, NOF, SCTP, PAY4),
- 	I40E_PTT(116, IP, IPV6, NOF, IP_GRENAT, IPV4, NOF, ICMP, PAY4),
+ 	IAVF_PTT(110, IP, IPV6, NOF, IP_GRENAT, IPV4, FRG, NONE, PAY3),
+ 	IAVF_PTT(111, IP, IPV6, NOF, IP_GRENAT, IPV4, NOF, NONE, PAY3),
+ 	IAVF_PTT(112, IP, IPV6, NOF, IP_GRENAT, IPV4, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(113),
+ 	IAVF_PTT(114, IP, IPV6, NOF, IP_GRENAT, IPV4, NOF, TCP,  PAY4),
+ 	IAVF_PTT(115, IP, IPV6, NOF, IP_GRENAT, IPV4, NOF, SCTP, PAY4),
+ 	IAVF_PTT(116, IP, IPV6, NOF, IP_GRENAT, IPV4, NOF, ICMP, PAY4),
  
  	/* IPv6 --> GRE/NAT -> IPv6 */
- 	I40E_PTT(117, IP, IPV6, NOF, IP_GRENAT, IPV6, FRG, NONE, PAY3),
- 	I40E_PTT(118, IP, IPV6, NOF, IP_GRENAT, IPV6, NOF, NONE, PAY3),
- 	I40E_PTT(119, IP, IPV6, NOF, IP_GRENAT, IPV6, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(120),
- 	I40E_PTT(121, IP, IPV6, NOF, IP_GRENAT, IPV6, NOF, TCP,  PAY4),
- 	I40E_PTT(122, IP, IPV6, NOF, IP_GRENAT, IPV6, NOF, SCTP, PAY4),
- 	I40E_PTT(123, IP, IPV6, NOF, IP_GRENAT, IPV6, NOF, ICMP, PAY4),
+ 	IAVF_PTT(117, IP, IPV6, NOF, IP_GRENAT, IPV6, FRG, NONE, PAY3),
+ 	IAVF_PTT(118, IP, IPV6, NOF, IP_GRENAT, IPV6, NOF, NONE, PAY3),
+ 	IAVF_PTT(119, IP, IPV6, NOF, IP_GRENAT, IPV6, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(120),
+ 	IAVF_PTT(121, IP, IPV6, NOF, IP_GRENAT, IPV6, NOF, TCP,  PAY4),
+ 	IAVF_PTT(122, IP, IPV6, NOF, IP_GRENAT, IPV6, NOF, SCTP, PAY4),
+ 	IAVF_PTT(123, IP, IPV6, NOF, IP_GRENAT, IPV6, NOF, ICMP, PAY4),
  
  	/* IPv6 --> GRE/NAT -> MAC */
- 	I40E_PTT(124, IP, IPV6, NOF, IP_GRENAT_MAC, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(124, IP, IPV6, NOF, IP_GRENAT_MAC, NONE, NOF, NONE, PAY3),
  
  	/* IPv6 --> GRE/NAT -> MAC -> IPv4 */
- 	I40E_PTT(125, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, FRG, NONE, PAY3),
- 	I40E_PTT(126, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, NOF, NONE, PAY3),
- 	I40E_PTT(127, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(128),
- 	I40E_PTT(129, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, NOF, TCP,  PAY4),
- 	I40E_PTT(130, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, NOF, SCTP, PAY4),
- 	I40E_PTT(131, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, NOF, ICMP, PAY4),
+ 	IAVF_PTT(125, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, FRG, NONE, PAY3),
+ 	IAVF_PTT(126, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, NOF, NONE, PAY3),
+ 	IAVF_PTT(127, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(128),
+ 	IAVF_PTT(129, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, NOF, TCP,  PAY4),
+ 	IAVF_PTT(130, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, NOF, SCTP, PAY4),
+ 	IAVF_PTT(131, IP, IPV6, NOF, IP_GRENAT_MAC, IPV4, NOF, ICMP, PAY4),
  
  	/* IPv6 --> GRE/NAT -> MAC -> IPv6 */
- 	I40E_PTT(132, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, FRG, NONE, PAY3),
- 	I40E_PTT(133, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, NOF, NONE, PAY3),
- 	I40E_PTT(134, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(135),
- 	I40E_PTT(136, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, NOF, TCP,  PAY4),
- 	I40E_PTT(137, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, NOF, SCTP, PAY4),
- 	I40E_PTT(138, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, NOF, ICMP, PAY4),
+ 	IAVF_PTT(132, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, FRG, NONE, PAY3),
+ 	IAVF_PTT(133, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, NOF, NONE, PAY3),
+ 	IAVF_PTT(134, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(135),
+ 	IAVF_PTT(136, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, NOF, TCP,  PAY4),
+ 	IAVF_PTT(137, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, NOF, SCTP, PAY4),
+ 	IAVF_PTT(138, IP, IPV6, NOF, IP_GRENAT_MAC, IPV6, NOF, ICMP, PAY4),
  
  	/* IPv6 --> GRE/NAT -> MAC/VLAN */
- 	I40E_PTT(139, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, NONE, NOF, NONE, PAY3),
+ 	IAVF_PTT(139, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, NONE, NOF, NONE, PAY3),
  
  	/* IPv6 --> GRE/NAT -> MAC/VLAN --> IPv4 */
- 	I40E_PTT(140, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, FRG, NONE, PAY3),
- 	I40E_PTT(141, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, NONE, PAY3),
- 	I40E_PTT(142, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(143),
- 	I40E_PTT(144, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, TCP,  PAY4),
- 	I40E_PTT(145, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, SCTP, PAY4),
- 	I40E_PTT(146, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, ICMP, PAY4),
+ 	IAVF_PTT(140, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, FRG, NONE, PAY3),
+ 	IAVF_PTT(141, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, NONE, PAY3),
+ 	IAVF_PTT(142, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(143),
+ 	IAVF_PTT(144, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, TCP,  PAY4),
+ 	IAVF_PTT(145, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, SCTP, PAY4),
+ 	IAVF_PTT(146, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV4, NOF, ICMP, PAY4),
  
  	/* IPv6 --> GRE/NAT -> MAC/VLAN --> IPv6 */
- 	I40E_PTT(147, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, FRG, NONE, PAY3),
- 	I40E_PTT(148, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, NONE, PAY3),
- 	I40E_PTT(149, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, UDP,  PAY4),
- 	I40E_PTT_UNUSED_ENTRY(150),
- 	I40E_PTT(151, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, TCP,  PAY4),
- 	I40E_PTT(152, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, SCTP, PAY4),
- 	I40E_PTT(153, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, ICMP, PAY4),
+ 	IAVF_PTT(147, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, FRG, NONE, PAY3),
+ 	IAVF_PTT(148, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, NONE, PAY3),
+ 	IAVF_PTT(149, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, UDP,  PAY4),
+ 	IAVF_PTT_UNUSED_ENTRY(150),
+ 	IAVF_PTT(151, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, TCP,  PAY4),
+ 	IAVF_PTT(152, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, SCTP, PAY4),
+ 	IAVF_PTT(153, IP, IPV6, NOF, IP_GRENAT_MAC_VLAN, IPV6, NOF, ICMP, PAY4),
  
  	/* unused entries */
- 	I40E_PTT_UNUSED_ENTRY(154),
- 	I40E_PTT_UNUSED_ENTRY(155),
- 	I40E_PTT_UNUSED_ENTRY(156),
- 	I40E_PTT_UNUSED_ENTRY(157),
- 	I40E_PTT_UNUSED_ENTRY(158),
- 	I40E_PTT_UNUSED_ENTRY(159),
- 
- 	I40E_PTT_UNUSED_ENTRY(160),
- 	I40E_PTT_UNUSED_ENTRY(161),
- 	I40E_PTT_UNUSED_ENTRY(162),
- 	I40E_PTT_UNUSED_ENTRY(163),
- 	I40E_PTT_UNUSED_ENTRY(164),
- 	I40E_PTT_UNUSED_ENTRY(165),
- 	I40E_PTT_UNUSED_ENTRY(166),
- 	I40E_PTT_UNUSED_ENTRY(167),
- 	I40E_PTT_UNUSED_ENTRY(168),
- 	I40E_PTT_UNUSED_ENTRY(169),
- 
- 	I40E_PTT_UNUSED_ENTRY(170),
- 	I40E_PTT_UNUSED_ENTRY(171),
- 	I40E_PTT_UNUSED_ENTRY(172),
- 	I40E_PTT_UNUSED_ENTRY(173),
- 	I40E_PTT_UNUSED_ENTRY(174),
- 	I40E_PTT_UNUSED_ENTRY(175),
- 	I40E_PTT_UNUSED_ENTRY(176),
- 	I40E_PTT_UNUSED_ENTRY(177),
- 	I40E_PTT_UNUSED_ENTRY(178),
- 	I40E_PTT_UNUSED_ENTRY(179),
- 
- 	I40E_PTT_UNUSED_ENTRY(180),
- 	I40E_PTT_UNUSED_ENTRY(181),
- 	I40E_PTT_UNUSED_ENTRY(182),
- 	I40E_PTT_UNUSED_ENTRY(183),
- 	I40E_PTT_UNUSED_ENTRY(184),
- 	I40E_PTT_UNUSED_ENTRY(185),
- 	I40E_PTT_UNUSED_ENTRY(186),
- 	I40E_PTT_UNUSED_ENTRY(187),
- 	I40E_PTT_UNUSED_ENTRY(188),
- 	I40E_PTT_UNUSED_ENTRY(189),
- 
- 	I40E_PTT_UNUSED_ENTRY(190),
- 	I40E_PTT_UNUSED_ENTRY(191),
- 	I40E_PTT_UNUSED_ENTRY(192),
- 	I40E_PTT_UNUSED_ENTRY(193),
- 	I40E_PTT_UNUSED_ENTRY(194),
- 	I40E_PTT_UNUSED_ENTRY(195),
- 	I40E_PTT_UNUSED_ENTRY(196),
- 	I40E_PTT_UNUSED_ENTRY(197),
- 	I40E_PTT_UNUSED_ENTRY(198),
- 	I40E_PTT_UNUSED_ENTRY(199),
- 
- 	I40E_PTT_UNUSED_ENTRY(200),
- 	I40E_PTT_UNUSED_ENTRY(201),
- 	I40E_PTT_UNUSED_ENTRY(202),
- 	I40E_PTT_UNUSED_ENTRY(203),
- 	I40E_PTT_UNUSED_ENTRY(204),
- 	I40E_PTT_UNUSED_ENTRY(205),
- 	I40E_PTT_UNUSED_ENTRY(206),
- 	I40E_PTT_UNUSED_ENTRY(207),
- 	I40E_PTT_UNUSED_ENTRY(208),
- 	I40E_PTT_UNUSED_ENTRY(209),
- 
- 	I40E_PTT_UNUSED_ENTRY(210),
- 	I40E_PTT_UNUSED_ENTRY(211),
- 	I40E_PTT_UNUSED_ENTRY(212),
- 	I40E_PTT_UNUSED_ENTRY(213),
- 	I40E_PTT_UNUSED_ENTRY(214),
- 	I40E_PTT_UNUSED_ENTRY(215),
- 	I40E_PTT_UNUSED_ENTRY(216),
- 	I40E_PTT_UNUSED_ENTRY(217),
- 	I40E_PTT_UNUSED_ENTRY(218),
- 	I40E_PTT_UNUSED_ENTRY(219),
- 
- 	I40E_PTT_UNUSED_ENTRY(220),
- 	I40E_PTT_UNUSED_ENTRY(221),
- 	I40E_PTT_UNUSED_ENTRY(222),
- 	I40E_PTT_UNUSED_ENTRY(223),
- 	I40E_PTT_UNUSED_ENTRY(224),
- 	I40E_PTT_UNUSED_ENTRY(225),
- 	I40E_PTT_UNUSED_ENTRY(226),
- 	I40E_PTT_UNUSED_ENTRY(227),
- 	I40E_PTT_UNUSED_ENTRY(228),
- 	I40E_PTT_UNUSED_ENTRY(229),
- 
- 	I40E_PTT_UNUSED_ENTRY(230),
- 	I40E_PTT_UNUSED_ENTRY(231),
- 	I40E_PTT_UNUSED_ENTRY(232),
- 	I40E_PTT_UNUSED_ENTRY(233),
- 	I40E_PTT_UNUSED_ENTRY(234),
- 	I40E_PTT_UNUSED_ENTRY(235),
- 	I40E_PTT_UNUSED_ENTRY(236),
- 	I40E_PTT_UNUSED_ENTRY(237),
- 	I40E_PTT_UNUSED_ENTRY(238),
- 	I40E_PTT_UNUSED_ENTRY(239),
- 
- 	I40E_PTT_UNUSED_ENTRY(240),
- 	I40E_PTT_UNUSED_ENTRY(241),
- 	I40E_PTT_UNUSED_ENTRY(242),
- 	I40E_PTT_UNUSED_ENTRY(243),
- 	I40E_PTT_UNUSED_ENTRY(244),
- 	I40E_PTT_UNUSED_ENTRY(245),
- 	I40E_PTT_UNUSED_ENTRY(246),
- 	I40E_PTT_UNUSED_ENTRY(247),
- 	I40E_PTT_UNUSED_ENTRY(248),
- 	I40E_PTT_UNUSED_ENTRY(249),
- 
- 	I40E_PTT_UNUSED_ENTRY(250),
- 	I40E_PTT_UNUSED_ENTRY(251),
- 	I40E_PTT_UNUSED_ENTRY(252),
- 	I40E_PTT_UNUSED_ENTRY(253),
- 	I40E_PTT_UNUSED_ENTRY(254),
- 	I40E_PTT_UNUSED_ENTRY(255)
+ 	IAVF_PTT_UNUSED_ENTRY(154),
+ 	IAVF_PTT_UNUSED_ENTRY(155),
+ 	IAVF_PTT_UNUSED_ENTRY(156),
+ 	IAVF_PTT_UNUSED_ENTRY(157),
+ 	IAVF_PTT_UNUSED_ENTRY(158),
+ 	IAVF_PTT_UNUSED_ENTRY(159),
+ 
+ 	IAVF_PTT_UNUSED_ENTRY(160),
+ 	IAVF_PTT_UNUSED_ENTRY(161),
+ 	IAVF_PTT_UNUSED_ENTRY(162),
+ 	IAVF_PTT_UNUSED_ENTRY(163),
+ 	IAVF_PTT_UNUSED_ENTRY(164),
+ 	IAVF_PTT_UNUSED_ENTRY(165),
+ 	IAVF_PTT_UNUSED_ENTRY(166),
+ 	IAVF_PTT_UNUSED_ENTRY(167),
+ 	IAVF_PTT_UNUSED_ENTRY(168),
+ 	IAVF_PTT_UNUSED_ENTRY(169),
+ 
+ 	IAVF_PTT_UNUSED_ENTRY(170),
+ 	IAVF_PTT_UNUSED_ENTRY(171),
+ 	IAVF_PTT_UNUSED_ENTRY(172),
+ 	IAVF_PTT_UNUSED_ENTRY(173),
+ 	IAVF_PTT_UNUSED_ENTRY(174),
+ 	IAVF_PTT_UNUSED_ENTRY(175),
+ 	IAVF_PTT_UNUSED_ENTRY(176),
+ 	IAVF_PTT_UNUSED_ENTRY(177),
+ 	IAVF_PTT_UNUSED_ENTRY(178),
+ 	IAVF_PTT_UNUSED_ENTRY(179),
+ 
+ 	IAVF_PTT_UNUSED_ENTRY(180),
+ 	IAVF_PTT_UNUSED_ENTRY(181),
+ 	IAVF_PTT_UNUSED_ENTRY(182),
+ 	IAVF_PTT_UNUSED_ENTRY(183),
+ 	IAVF_PTT_UNUSED_ENTRY(184),
+ 	IAVF_PTT_UNUSED_ENTRY(185),
+ 	IAVF_PTT_UNUSED_ENTRY(186),
+ 	IAVF_PTT_UNUSED_ENTRY(187),
+ 	IAVF_PTT_UNUSED_ENTRY(188),
+ 	IAVF_PTT_UNUSED_ENTRY(189),
+ 
+ 	IAVF_PTT_UNUSED_ENTRY(190),
+ 	IAVF_PTT_UNUSED_ENTRY(191),
+ 	IAVF_PTT_UNUSED_ENTRY(192),
+ 	IAVF_PTT_UNUSED_ENTRY(193),
+ 	IAVF_PTT_UNUSED_ENTRY(194),
+ 	IAVF_PTT_UNUSED_ENTRY(195),
+ 	IAVF_PTT_UNUSED_ENTRY(196),
+ 	IAVF_PTT_UNUSED_ENTRY(197),
+ 	IAVF_PTT_UNUSED_ENTRY(198),
+ 	IAVF_PTT_UNUSED_ENTRY(199),
+ 
+ 	IAVF_PTT_UNUSED_ENTRY(200),
+ 	IAVF_PTT_UNUSED_ENTRY(201),
+ 	IAVF_PTT_UNUSED_ENTRY(202),
+ 	IAVF_PTT_UNUSED_ENTRY(203),
+ 	IAVF_PTT_UNUSED_ENTRY(204),
+ 	IAVF_PTT_UNUSED_ENTRY(205),
+ 	IAVF_PTT_UNUSED_ENTRY(206),
+ 	IAVF_PTT_UNUSED_ENTRY(207),
+ 	IAVF_PTT_UNUSED_ENTRY(208),
+ 	IAVF_PTT_UNUSED_ENTRY(209),
+ 
+ 	IAVF_PTT_UNUSED_ENTRY(210),
+ 	IAVF_PTT_UNUSED_ENTRY(211),
+ 	IAVF_PTT_UNUSED_ENTRY(212),
+ 	IAVF_PTT_UNUSED_ENTRY(213),
+ 	IAVF_PTT_UNUSED_ENTRY(214),
+ 	IAVF_PTT_UNUSED_ENTRY(215),
+ 	IAVF_PTT_UNUSED_ENTRY(216),
+ 	IAVF_PTT_UNUSED_ENTRY(217),
+ 	IAVF_PTT_UNUSED_ENTRY(218),
+ 	IAVF_PTT_UNUSED_ENTRY(219),
+ 
+ 	IAVF_PTT_UNUSED_ENTRY(220),
+ 	IAVF_PTT_UNUSED_ENTRY(221),
+ 	IAVF_PTT_UNUSED_ENTRY(222),
+ 	IAVF_PTT_UNUSED_ENTRY(223),
+ 	IAVF_PTT_UNUSED_ENTRY(224),
+ 	IAVF_PTT_UNUSED_ENTRY(225),
+ 	IAVF_PTT_UNUSED_ENTRY(226),
+ 	IAVF_PTT_UNUSED_ENTRY(227),
+ 	IAVF_PTT_UNUSED_ENTRY(228),
+ 	IAVF_PTT_UNUSED_ENTRY(229),
+ 
+ 	IAVF_PTT_UNUSED_ENTRY(230),
+ 	IAVF_PTT_UNUSED_ENTRY(231),
+ 	IAVF_PTT_UNUSED_ENTRY(232),
+ 	IAVF_PTT_UNUSED_ENTRY(233),
+ 	IAVF_PTT_UNUSED_ENTRY(234),
+ 	IAVF_PTT_UNUSED_ENTRY(235),
+ 	IAVF_PTT_UNUSED_ENTRY(236),
+ 	IAVF_PTT_UNUSED_ENTRY(237),
+ 	IAVF_PTT_UNUSED_ENTRY(238),
+ 	IAVF_PTT_UNUSED_ENTRY(239),
+ 
+ 	IAVF_PTT_UNUSED_ENTRY(240),
+ 	IAVF_PTT_UNUSED_ENTRY(241),
+ 	IAVF_PTT_UNUSED_ENTRY(242),
+ 	IAVF_PTT_UNUSED_ENTRY(243),
+ 	IAVF_PTT_UNUSED_ENTRY(244),
+ 	IAVF_PTT_UNUSED_ENTRY(245),
+ 	IAVF_PTT_UNUSED_ENTRY(246),
+ 	IAVF_PTT_UNUSED_ENTRY(247),
+ 	IAVF_PTT_UNUSED_ENTRY(248),
+ 	IAVF_PTT_UNUSED_ENTRY(249),
+ 
+ 	IAVF_PTT_UNUSED_ENTRY(250),
+ 	IAVF_PTT_UNUSED_ENTRY(251),
+ 	IAVF_PTT_UNUSED_ENTRY(252),
+ 	IAVF_PTT_UNUSED_ENTRY(253),
+ 	IAVF_PTT_UNUSED_ENTRY(254),
+ 	IAVF_PTT_UNUSED_ENTRY(255)
  };
  
  /**
diff --cc drivers/net/ethernet/intel/i40evf/i40e_osdep.h
index d394f0fe8516,e6e0b0328706..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_osdep.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_osdep.h
@@@ -24,29 -24,29 +24,45 @@@
  
  #define wr64(a, reg, value)	writeq((value), ((a)->hw_addr + (reg)))
  #define rd64(a, reg)		readq((a)->hw_addr + (reg))
 -#define iavf_flush(a)		readl((a)->hw_addr + IAVF_VFGEN_RSTAT)
 +#define i40e_flush(a)		readl((a)->hw_addr + I40E_VFGEN_RSTAT)
  
  /* memory allocation tracking */
- struct i40e_dma_mem {
+ struct iavf_dma_mem {
  	void *va;
  	dma_addr_t pa;
  	u32 size;
  };
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_osdep.h
 +#define i40e_allocate_dma_mem(h, m, unused, s, a) \
 +	i40evf_allocate_dma_mem_d(h, m, s, a)
 +#define i40e_free_dma_mem(h, m) i40evf_free_dma_mem_d(h, m)
++=======
+ #define iavf_allocate_dma_mem(h, m, unused, s, a) \
+ 	iavf_allocate_dma_mem_d(h, m, s, a)
+ #define iavf_free_dma_mem(h, m) iavf_free_dma_mem_d(h, m)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_osdep.h
  
- struct i40e_virt_mem {
+ struct iavf_virt_mem {
  	void *va;
  	u32 size;
  };
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_osdep.h
 +#define i40e_allocate_virt_mem(h, m, s) i40evf_allocate_virt_mem_d(h, m, s)
 +#define i40e_free_virt_mem(h, m) i40evf_free_virt_mem_d(h, m)
++=======
+ #define iavf_allocate_virt_mem(h, m, s) iavf_allocate_virt_mem_d(h, m, s)
+ #define iavf_free_virt_mem(h, m) iavf_free_virt_mem_d(h, m)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_osdep.h
  
 -#define iavf_debug(h, m, s, ...)  iavf_debug_d(h, m, s, ##__VA_ARGS__)
 -extern void iavf_debug_d(void *hw, u32 mask, char *fmt_str, ...)
 +#define i40e_debug(h, m, s, ...)  i40evf_debug_d(h, m, s, ##__VA_ARGS__)
 +extern void i40evf_debug_d(void *hw, u32 mask, char *fmt_str, ...)
  	__attribute__ ((format(gnu_printf, 3, 4)));
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_osdep.h
 +typedef enum i40e_status_code i40e_status;
 +#endif /* _I40E_OSDEP_H_ */
++=======
+ typedef enum iavf_status_code iavf_status;
+ #endif /* _IAVF_OSDEP_H_ */
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/i40e_osdep.h
diff --cc drivers/net/ethernet/intel/i40evf/i40e_trace.h
index d7a4e68820a8,1474f5539751..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_trace.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_trace.h
@@@ -57,11 -57,11 +57,11 @@@
  
  /* Events related to a vsi & ring */
  DECLARE_EVENT_CLASS(
 -	iavf_tx_template,
 +	i40evf_tx_template,
  
- 	TP_PROTO(struct i40e_ring *ring,
- 		 struct i40e_tx_desc *desc,
- 		 struct i40e_tx_buffer *buf),
+ 	TP_PROTO(struct iavf_ring *ring,
+ 		 struct iavf_tx_desc *desc,
+ 		 struct iavf_tx_buffer *buf),
  
  	TP_ARGS(ring, desc, buf),
  
@@@ -93,26 -93,26 +93,40 @@@
  );
  
  DEFINE_EVENT(
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_trace.h
 +	i40evf_tx_template, i40evf_clean_tx_irq,
 +	TP_PROTO(struct i40e_ring *ring,
 +		 struct i40e_tx_desc *desc,
 +		 struct i40e_tx_buffer *buf),
++=======
+ 	iavf_tx_template, iavf_clean_tx_irq,
+ 	TP_PROTO(struct iavf_ring *ring,
+ 		 struct iavf_tx_desc *desc,
+ 		 struct iavf_tx_buffer *buf),
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_trace.h
  
  	TP_ARGS(ring, desc, buf));
  
  DEFINE_EVENT(
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_trace.h
 +	i40evf_tx_template, i40evf_clean_tx_irq_unmap,
 +	TP_PROTO(struct i40e_ring *ring,
 +		 struct i40e_tx_desc *desc,
 +		 struct i40e_tx_buffer *buf),
++=======
+ 	iavf_tx_template, iavf_clean_tx_irq_unmap,
+ 	TP_PROTO(struct iavf_ring *ring,
+ 		 struct iavf_tx_desc *desc,
+ 		 struct iavf_tx_buffer *buf),
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_trace.h
  
  	TP_ARGS(ring, desc, buf));
  
  DECLARE_EVENT_CLASS(
 -	iavf_rx_template,
 +	i40evf_rx_template,
  
- 	TP_PROTO(struct i40e_ring *ring,
- 		 union i40e_32byte_rx_desc *desc,
+ 	TP_PROTO(struct iavf_ring *ring,
+ 		 union iavf_32byte_rx_desc *desc,
  		 struct sk_buff *skb),
  
  	TP_ARGS(ring, desc, skb),
@@@ -138,26 -138,26 +152,38 @@@
  );
  
  DEFINE_EVENT(
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_trace.h
 +	i40evf_rx_template, i40evf_clean_rx_irq,
 +	TP_PROTO(struct i40e_ring *ring,
 +		 union i40e_32byte_rx_desc *desc,
++=======
+ 	iavf_rx_template, iavf_clean_rx_irq,
+ 	TP_PROTO(struct iavf_ring *ring,
+ 		 union iavf_32byte_rx_desc *desc,
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_trace.h
  		 struct sk_buff *skb),
  
  	TP_ARGS(ring, desc, skb));
  
  DEFINE_EVENT(
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_trace.h
 +	i40evf_rx_template, i40evf_clean_rx_irq_rx,
 +	TP_PROTO(struct i40e_ring *ring,
 +		 union i40e_32byte_rx_desc *desc,
++=======
+ 	iavf_rx_template, iavf_clean_rx_irq_rx,
+ 	TP_PROTO(struct iavf_ring *ring,
+ 		 union iavf_32byte_rx_desc *desc,
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_trace.h
  		 struct sk_buff *skb),
  
  	TP_ARGS(ring, desc, skb));
  
  DECLARE_EVENT_CLASS(
 -	iavf_xmit_template,
 +	i40evf_xmit_template,
  
  	TP_PROTO(struct sk_buff *skb,
- 		 struct i40e_ring *ring),
+ 		 struct iavf_ring *ring),
  
  	TP_ARGS(skb, ring),
  
@@@ -180,16 -180,16 +206,16 @@@
  );
  
  DEFINE_EVENT(
 -	iavf_xmit_template, iavf_xmit_frame_ring,
 +	i40evf_xmit_template, i40evf_xmit_frame_ring,
  	TP_PROTO(struct sk_buff *skb,
- 		 struct i40e_ring *ring),
+ 		 struct iavf_ring *ring),
  
  	TP_ARGS(skb, ring));
  
  DEFINE_EVENT(
 -	iavf_xmit_template, iavf_xmit_frame_ring_drop,
 +	i40evf_xmit_template, i40evf_xmit_frame_ring_drop,
  	TP_PROTO(struct sk_buff *skb,
- 		 struct i40e_ring *ring),
+ 		 struct iavf_ring *ring),
  
  	TP_ARGS(skb, ring));
  
diff --cc drivers/net/ethernet/intel/i40evf/i40e_txrx.c
index 800d621606e8,1768c64a922f..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
@@@ -11,17 -11,17 +11,28 @@@
  static inline __le64 build_ctob(u32 td_cmd, u32 td_offset, unsigned int size,
  				u32 td_tag)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +	return cpu_to_le64(I40E_TX_DESC_DTYPE_DATA |
 +			   ((u64)td_cmd  << I40E_TXD_QW1_CMD_SHIFT) |
 +			   ((u64)td_offset << I40E_TXD_QW1_OFFSET_SHIFT) |
 +			   ((u64)size  << I40E_TXD_QW1_TX_BUF_SZ_SHIFT) |
 +			   ((u64)td_tag  << I40E_TXD_QW1_L2TAG1_SHIFT));
 +}
 +
 +#define I40E_TXD_CMD (I40E_TX_DESC_CMD_EOP | I40E_TX_DESC_CMD_RS)
++=======
+ 	return cpu_to_le64(IAVF_TX_DESC_DTYPE_DATA |
+ 			   ((u64)td_cmd  << IAVF_TXD_QW1_CMD_SHIFT) |
+ 			   ((u64)td_offset << IAVF_TXD_QW1_OFFSET_SHIFT) |
+ 			   ((u64)size  << IAVF_TXD_QW1_TX_BUF_SZ_SHIFT) |
+ 			   ((u64)td_tag  << IAVF_TXD_QW1_L2TAG1_SHIFT));
+ }
+ 
+ #define IAVF_TXD_CMD (IAVF_TX_DESC_CMD_EOP | IAVF_TX_DESC_CMD_RS)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  
  /**
-  * i40e_unmap_and_free_tx_resource - Release a Tx buffer
+  * iavf_unmap_and_free_tx_resource - Release a Tx buffer
   * @ring:      the ring that owns the buffer
   * @tx_buffer: the buffer to free
   **/
@@@ -52,10 -52,10 +63,14 @@@ static void iavf_unmap_and_free_tx_reso
  }
  
  /**
 - * iavf_clean_tx_ring - Free any empty Tx buffers
 + * i40evf_clean_tx_ring - Free any empty Tx buffers
   * @tx_ring: ring to be cleaned
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +void i40evf_clean_tx_ring(struct i40e_ring *tx_ring)
++=======
+ void iavf_clean_tx_ring(struct iavf_ring *tx_ring)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  {
  	unsigned long bi_size;
  	u16 i;
@@@ -90,9 -90,9 +105,13 @@@
   *
   * Free all transmit software resources
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +void i40evf_free_tx_resources(struct i40e_ring *tx_ring)
++=======
+ void iavf_free_tx_resources(struct iavf_ring *tx_ring)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  {
 -	iavf_clean_tx_ring(tx_ring);
 +	i40evf_clean_tx_ring(tx_ring);
  	kfree(tx_ring->tx_bi);
  	tx_ring->tx_bi = NULL;
  
@@@ -111,7 -111,7 +130,11 @@@
   * Since there is no access to the ring head register
   * in XL710, we need to use our local copies
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +u32 i40evf_get_tx_pending(struct i40e_ring *ring, bool in_sw)
++=======
+ u32 iavf_get_tx_pending(struct iavf_ring *ring, bool in_sw)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  {
  	u32 head, tail;
  
@@@ -132,9 -132,9 +155,13 @@@
   * VSI has netdev and netdev has TX queues. This function is to check each of
   * those TX queues if they are hung, trigger recovery by issuing SW interrupt.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +void i40evf_detect_recover_hung(struct i40e_vsi *vsi)
++=======
+ void iavf_detect_recover_hung(struct iavf_vsi *vsi)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  {
- 	struct i40e_ring *tx_ring = NULL;
+ 	struct iavf_ring *tx_ring = NULL;
  	struct net_device *netdev;
  	unsigned int i;
  	int packets;
@@@ -356,12 -356,12 +383,16 @@@ static void iavf_enable_wb_on_itr(struc
   * @q_vector: the vector  on which to force writeback
   *
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +void i40evf_force_wb(struct i40e_vsi *vsi, struct i40e_q_vector *q_vector)
++=======
+ void iavf_force_wb(struct iavf_vsi *vsi, struct iavf_q_vector *q_vector)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  {
 -	u32 val = IAVF_VFINT_DYN_CTLN1_INTENA_MASK |
 -		  IAVF_VFINT_DYN_CTLN1_ITR_INDX_MASK | /* set noitr */
 -		  IAVF_VFINT_DYN_CTLN1_SWINT_TRIG_MASK |
 -		  IAVF_VFINT_DYN_CTLN1_SW_ITR_INDX_ENA_MASK
 +	u32 val = I40E_VFINT_DYN_CTLN1_INTENA_MASK |
 +		  I40E_VFINT_DYN_CTLN1_ITR_INDX_MASK | /* set noitr */
 +		  I40E_VFINT_DYN_CTLN1_SWINT_TRIG_MASK |
 +		  I40E_VFINT_DYN_CTLN1_SW_ITR_INDX_ENA_MASK
  		  /* allow 00 to be written to the index */;
  
  	wr32(&vsi->back->hw,
@@@ -612,7 -612,7 +643,11 @@@ clear_counts
   *
   * Return 0 on success, negative on error
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +int i40evf_setup_tx_descriptors(struct i40e_ring *tx_ring)
++=======
+ int iavf_setup_tx_descriptors(struct iavf_ring *tx_ring)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  {
  	struct device *dev = tx_ring->dev;
  	int bi_size;
@@@ -650,10 -650,10 +685,14 @@@ err
  }
  
  /**
 - * iavf_clean_rx_ring - Free Rx buffers
 + * i40evf_clean_rx_ring - Free Rx buffers
   * @rx_ring: ring to be cleaned
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +void i40evf_clean_rx_ring(struct i40e_ring *rx_ring)
++=======
+ void iavf_clean_rx_ring(struct iavf_ring *rx_ring)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  {
  	unsigned long bi_size;
  	u16 i;
@@@ -685,12 -684,10 +724,16 @@@
  					      DMA_FROM_DEVICE);
  
  		/* free resources associated with mapping */
 +		dma_set_attr(DMA_ATTR_SKIP_CPU_SYNC, &attrs);
 +		dma_set_attr(DMA_ATTR_WEAK_ORDERING, &attrs);
  		dma_unmap_page_attrs(rx_ring->dev, rx_bi->dma,
- 				     i40e_rx_pg_size(rx_ring),
+ 				     iavf_rx_pg_size(rx_ring),
  				     DMA_FROM_DEVICE,
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +				     &attrs);
++=======
+ 				     IAVF_RX_DMA_ATTR);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  
  		__page_frag_cache_drain(rx_bi->page, rx_bi->pagecnt_bias);
  
@@@ -715,9 -712,9 +758,13 @@@
   *
   * Free all receive software resources
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +void i40evf_free_rx_resources(struct i40e_ring *rx_ring)
++=======
+ void iavf_free_rx_resources(struct iavf_ring *rx_ring)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  {
 -	iavf_clean_rx_ring(rx_ring);
 +	i40evf_clean_rx_ring(rx_ring);
  	kfree(rx_ring->rx_bi);
  	rx_ring->rx_bi = NULL;
  
@@@ -734,7 -731,7 +781,11 @@@
   *
   * Returns 0 on success, negative on failure
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +int i40evf_setup_rx_descriptors(struct i40e_ring *rx_ring)
++=======
+ int iavf_setup_rx_descriptors(struct iavf_ring *rx_ring)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  {
  	struct device *dev = rx_ring->dev;
  	int bi_size;
@@@ -832,12 -828,10 +883,16 @@@ static bool iavf_alloc_mapped_page(stru
  	}
  
  	/* map page for use */
 +	dma_set_attr(DMA_ATTR_SKIP_CPU_SYNC, &attrs);
 +	dma_set_attr(DMA_ATTR_WEAK_ORDERING, &attrs);
  	dma = dma_map_page_attrs(rx_ring->dev, page, 0,
- 				 i40e_rx_pg_size(rx_ring),
+ 				 iavf_rx_pg_size(rx_ring),
  				 DMA_FROM_DEVICE,
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +				 &attrs);
++=======
+ 				 IAVF_RX_DMA_ATTR);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  
  	/* if mapping failed free memory back to system since
  	 * there isn't much point in holding memory we can't use
@@@ -883,11 -877,11 +938,15 @@@ static void iavf_receive_skb(struct iav
   *
   * Returns false if all allocations were successful, true if any fail
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +bool i40evf_alloc_rx_buffers(struct i40e_ring *rx_ring, u16 cleaned_count)
++=======
+ bool iavf_alloc_rx_buffers(struct iavf_ring *rx_ring, u16 cleaned_count)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  {
  	u16 ntu = rx_ring->next_to_use;
- 	union i40e_rx_desc *rx_desc;
- 	struct i40e_rx_buffer *bi;
+ 	union iavf_rx_desc *rx_desc;
+ 	struct iavf_rx_buffer *bi;
  
  	/* do nothing if no valid netdev defined */
  	if (!rx_ring->netdev || !cleaned_count)
@@@ -981,14 -975,14 +1040,14 @@@ static inline void iavf_rx_checksum(str
  	if (!(decoded.known && decoded.outer_ip))
  		return;
  
- 	ipv4 = (decoded.outer_ip == I40E_RX_PTYPE_OUTER_IP) &&
- 	       (decoded.outer_ip_ver == I40E_RX_PTYPE_OUTER_IPV4);
- 	ipv6 = (decoded.outer_ip == I40E_RX_PTYPE_OUTER_IP) &&
- 	       (decoded.outer_ip_ver == I40E_RX_PTYPE_OUTER_IPV6);
+ 	ipv4 = (decoded.outer_ip == IAVF_RX_PTYPE_OUTER_IP) &&
+ 	       (decoded.outer_ip_ver == IAVF_RX_PTYPE_OUTER_IPV4);
+ 	ipv6 = (decoded.outer_ip == IAVF_RX_PTYPE_OUTER_IP) &&
+ 	       (decoded.outer_ip_ver == IAVF_RX_PTYPE_OUTER_IPV6);
  
  	if (ipv4 &&
 -	    (rx_error & (BIT(IAVF_RX_DESC_ERROR_IPE_SHIFT) |
 -			 BIT(IAVF_RX_DESC_ERROR_EIPE_SHIFT))))
 +	    (rx_error & (BIT(I40E_RX_DESC_ERROR_IPE_SHIFT) |
 +			 BIT(I40E_RX_DESC_ERROR_EIPE_SHIFT))))
  		goto checksum_fail;
  
  	/* likely incorrect csum if alternate IP extension headers found */
@@@ -1086,13 -1080,13 +1145,19 @@@ static inline void iavf_rx_hash(struct 
   * other fields within the skb.
   **/
  static inline
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +void i40evf_process_skb_fields(struct i40e_ring *rx_ring,
 +			       union i40e_rx_desc *rx_desc, struct sk_buff *skb,
 +			       u8 rx_ptype)
++=======
+ void iavf_process_skb_fields(struct iavf_ring *rx_ring,
+ 			     union iavf_rx_desc *rx_desc, struct sk_buff *skb,
+ 			     u8 rx_ptype)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  {
- 	i40e_rx_hash(rx_ring, rx_desc, skb, rx_ptype);
+ 	iavf_rx_hash(rx_ring, rx_desc, skb, rx_ptype);
  
- 	i40e_rx_checksum(rx_ring->vsi, skb, rx_desc);
+ 	iavf_rx_checksum(rx_ring->vsi, skb, rx_desc);
  
  	skb_record_rx_queue(skb, rx_ring->queue_index);
  
@@@ -1402,22 -1396,18 +1467,31 @@@ static struct sk_buff *iavf_build_skb(s
   * This function will clean up the contents of the rx_buffer.  It will
   * either recycle the buffer or unmap it and free the associated resources.
   */
- static void i40e_put_rx_buffer(struct i40e_ring *rx_ring,
- 			       struct i40e_rx_buffer *rx_buffer)
+ static void iavf_put_rx_buffer(struct iavf_ring *rx_ring,
+ 			       struct iavf_rx_buffer *rx_buffer)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +	DEFINE_DMA_ATTRS(attrs);
 +
 +	if (i40e_can_reuse_rx_page(rx_buffer)) {
++=======
+ 	if (iavf_can_reuse_rx_page(rx_buffer)) {
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  		/* hand second half of page back to the ring */
- 		i40e_reuse_rx_page(rx_ring, rx_buffer);
+ 		iavf_reuse_rx_page(rx_ring, rx_buffer);
  		rx_ring->rx_stats.page_reuse_count++;
  	} else {
  		/* we are not reusing the buffer so unmap it */
 +		dma_set_attr(DMA_ATTR_SKIP_CPU_SYNC, &attrs);
 +		dma_set_attr(DMA_ATTR_WEAK_ORDERING, &attrs);
  		dma_unmap_page_attrs(rx_ring->dev, rx_buffer->dma,
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +				     i40e_rx_pg_size(rx_ring),
 +				     DMA_FROM_DEVICE, &attrs);
++=======
+ 				     iavf_rx_pg_size(rx_ring),
+ 				     DMA_FROM_DEVICE, IAVF_RX_DMA_ATTR);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  		__page_frag_cache_drain(rx_buffer->page,
  					rx_buffer->pagecnt_bias);
  	}
@@@ -1447,11 -1437,11 +1521,16 @@@ static bool iavf_is_non_eop(struct iavf
  	ntc = (ntc < rx_ring->count) ? ntc : 0;
  	rx_ring->next_to_clean = ntc;
  
 -	prefetch(IAVF_RX_DESC(rx_ring, ntc));
 +	prefetch(I40E_RX_DESC(rx_ring, ntc));
  
  	/* if we are the last buffer then there is nothing else to do */
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +#define I40E_RXD_EOF BIT(I40E_RX_DESC_STATUS_EOF_SHIFT)
 +	if (likely(i40e_test_staterr(rx_desc, I40E_RXD_EOF)))
++=======
+ #define IAVF_RXD_EOF BIT(IAVF_RX_DESC_STATUS_EOF_SHIFT)
+ 	if (likely(iavf_test_staterr(rx_desc, IAVF_RXD_EOF)))
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  		return false;
  
  	rx_ring->rx_stats.non_eop_descs++;
@@@ -1487,9 -1477,9 +1566,9 @@@ static int iavf_clean_rx_irq(struct iav
  		u64 qword;
  
  		/* return some buffers to hardware, one at a time is too slow */
- 		if (cleaned_count >= I40E_RX_BUFFER_WRITE) {
+ 		if (cleaned_count >= IAVF_RX_BUFFER_WRITE) {
  			failure = failure ||
 -				  iavf_alloc_rx_buffers(rx_ring, cleaned_count);
 +				  i40evf_alloc_rx_buffers(rx_ring, cleaned_count);
  			cleaned_count = 0;
  		}
  
@@@ -1513,8 -1503,8 +1592,13 @@@
  		if (!size)
  			break;
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +		i40e_trace(clean_rx_irq, rx_ring, rx_desc, skb);
 +		rx_buffer = i40e_get_rx_buffer(rx_ring, size);
++=======
+ 		iavf_trace(clean_rx_irq, rx_ring, rx_desc, skb);
+ 		rx_buffer = iavf_get_rx_buffer(rx_ring, size);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  
  		/* retrieve a buffer from the ring */
  		if (skb)
@@@ -1539,10 -1529,10 +1623,10 @@@
  
  		/* ERR_MASK will only have valid bits if EOP set, and
  		 * what we are doing here is actually checking
 -		 * IAVF_RX_DESC_ERROR_RXE_SHIFT, since it is the zeroth bit in
 +		 * I40E_RX_DESC_ERROR_RXE_SHIFT, since it is the zeroth bit in
  		 * the error field
  		 */
- 		if (unlikely(i40e_test_staterr(rx_desc, BIT(I40E_RXD_QW1_ERROR_SHIFT)))) {
+ 		if (unlikely(iavf_test_staterr(rx_desc, BIT(IAVF_RXD_QW1_ERROR_SHIFT)))) {
  			dev_kfree_skb_any(skb);
  			skb = NULL;
  			continue;
@@@ -1557,18 -1547,18 +1641,23 @@@
  		total_rx_bytes += skb->len;
  
  		qword = le64_to_cpu(rx_desc->wb.qword1.status_error_len);
- 		rx_ptype = (qword & I40E_RXD_QW1_PTYPE_MASK) >>
- 			   I40E_RXD_QW1_PTYPE_SHIFT;
+ 		rx_ptype = (qword & IAVF_RXD_QW1_PTYPE_MASK) >>
+ 			   IAVF_RXD_QW1_PTYPE_SHIFT;
  
  		/* populate checksum, VLAN, and protocol */
 -		iavf_process_skb_fields(rx_ring, rx_desc, skb, rx_ptype);
 +		i40evf_process_skb_fields(rx_ring, rx_desc, skb, rx_ptype);
  
  
 -		vlan_tag = (qword & BIT(IAVF_RX_DESC_STATUS_L2TAG1P_SHIFT)) ?
 +		vlan_tag = (qword & BIT(I40E_RX_DESC_STATUS_L2TAG1P_SHIFT)) ?
  			   le16_to_cpu(rx_desc->wb.qword0.lo_dword.l2tag1) : 0;
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +		i40e_trace(clean_rx_irq_rx, rx_ring, rx_desc, skb);
 +		i40e_receive_skb(rx_ring, skb, vlan_tag);
++=======
+ 		iavf_trace(clean_rx_irq_rx, rx_ring, rx_desc, skb);
+ 		iavf_receive_skb(rx_ring, skb, vlan_tag);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  		skb = NULL;
  
  		/* update budget accounting */
@@@ -1607,11 -1597,11 +1696,11 @@@ static inline u32 iavf_buildreg_itr(con
  	 * only need to shift by the interval shift - 1 instead of the
  	 * full value.
  	 */
- 	itr &= I40E_ITR_MASK;
+ 	itr &= IAVF_ITR_MASK;
  
 -	val = IAVF_VFINT_DYN_CTLN1_INTENA_MASK |
 -	      (type << IAVF_VFINT_DYN_CTLN1_ITR_INDX_SHIFT) |
 -	      (itr << (IAVF_VFINT_DYN_CTLN1_INTERVAL_SHIFT - 1));
 +	val = I40E_VFINT_DYN_CTLN1_INTENA_MASK |
 +	      (type << I40E_VFINT_DYN_CTLN1_ITR_INDX_SHIFT) |
 +	      (itr << (I40E_VFINT_DYN_CTLN1_INTERVAL_SHIFT - 1));
  
  	return val;
  }
@@@ -1634,10 -1624,10 +1723,10 @@@
   * @q_vector: q_vector for which itr is being updated and interrupt enabled
   *
   **/
- static inline void i40e_update_enable_itr(struct i40e_vsi *vsi,
- 					  struct i40e_q_vector *q_vector)
+ static inline void iavf_update_enable_itr(struct iavf_vsi *vsi,
+ 					  struct iavf_q_vector *q_vector)
  {
 -	struct iavf_hw *hw = &vsi->back->hw;
 +	struct i40e_hw *hw = &vsi->back->hw;
  	u32 intval;
  
  	/* These will do nothing if dynamic updates are not enabled */
@@@ -1694,12 -1684,12 +1783,12 @@@
   *
   * Returns the amount of work done
   **/
 -int iavf_napi_poll(struct napi_struct *napi, int budget)
 +int i40evf_napi_poll(struct napi_struct *napi, int budget)
  {
- 	struct i40e_q_vector *q_vector =
- 			       container_of(napi, struct i40e_q_vector, napi);
- 	struct i40e_vsi *vsi = q_vector->vsi;
- 	struct i40e_ring *ring;
+ 	struct iavf_q_vector *q_vector =
+ 			       container_of(napi, struct iavf_q_vector, napi);
+ 	struct iavf_vsi *vsi = q_vector->vsi;
+ 	struct iavf_ring *ring;
  	bool clean_complete = true;
  	bool arm_wb = false;
  	int budget_per_ring;
@@@ -1792,9 -1782,9 +1881,15 @@@ tx_only
   * Returns error code indicate the frame should be dropped upon error and the
   * otherwise  returns 0 to indicate the flags has been set properly.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +static inline int i40evf_tx_prepare_vlan_flags(struct sk_buff *skb,
 +					       struct i40e_ring *tx_ring,
 +					       u32 *flags)
++=======
+ static inline int iavf_tx_prepare_vlan_flags(struct sk_buff *skb,
+ 					     struct iavf_ring *tx_ring,
+ 					     u32 *flags)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  {
  	__be16 protocol = skb->protocol;
  	u32  tx_flags = 0;
@@@ -2060,11 -2050,11 +2155,19 @@@ static int iavf_tx_enable_csum(struct s
  		/* the stack computes the IP header already, the only time we
  		 * need the hardware to recompute it is in the case of TSO.
  		 */
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +		cmd |= (*tx_flags & I40E_TX_FLAGS_TSO) ?
 +		       I40E_TX_DESC_CMD_IIPT_IPV4_CSUM :
 +		       I40E_TX_DESC_CMD_IIPT_IPV4;
 +	} else if (*tx_flags & I40E_TX_FLAGS_IPV6) {
 +		cmd |= I40E_TX_DESC_CMD_IIPT_IPV6;
++=======
+ 		cmd |= (*tx_flags & IAVF_TX_FLAGS_TSO) ?
+ 		       IAVF_TX_DESC_CMD_IIPT_IPV4_CSUM :
+ 		       IAVF_TX_DESC_CMD_IIPT_IPV4;
+ 	} else if (*tx_flags & IAVF_TX_FLAGS_IPV6) {
+ 		cmd |= IAVF_TX_DESC_CMD_IIPT_IPV6;
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  
  		exthdr = ip.hdr + sizeof(*ip.v6);
  		l4_proto = ip.v6->nexthdr;
@@@ -2091,12 -2081,12 +2194,12 @@@
  		break;
  	case IPPROTO_UDP:
  		/* enable UDP checksum offload */
 -		cmd |= IAVF_TX_DESC_CMD_L4T_EOFT_UDP;
 +		cmd |= I40E_TX_DESC_CMD_L4T_EOFT_UDP;
  		offset |= (sizeof(struct udphdr) >> 2) <<
 -			  IAVF_TX_DESC_LENGTH_L4_FC_LEN_SHIFT;
 +			  I40E_TX_DESC_LENGTH_L4_FC_LEN_SHIFT;
  		break;
  	default:
- 		if (*tx_flags & I40E_TX_FLAGS_TSO)
+ 		if (*tx_flags & IAVF_TX_FLAGS_TSO)
  			return -1;
  		skb_checksum_help(skb);
  		return 0;
@@@ -2119,10 -2109,10 +2222,10 @@@ static void iavf_create_tx_ctx(struct i
  			       const u64 cd_type_cmd_tso_mss,
  			       const u32 cd_tunneling, const u32 cd_l2tag2)
  {
- 	struct i40e_tx_context_desc *context_desc;
+ 	struct iavf_tx_context_desc *context_desc;
  	int i = tx_ring->next_to_use;
  
 -	if ((cd_type_cmd_tso_mss == IAVF_TX_DESC_DTYPE_CONTEXT) &&
 +	if ((cd_type_cmd_tso_mss == I40E_TX_DESC_DTYPE_CONTEXT) &&
  	    !cd_tunneling && !cd_l2tag2)
  		return;
  
@@@ -2230,7 -2220,7 +2333,11 @@@ bool __i40evf_chk_linearize(struct sk_b
   *
   * Returns -EBUSY if a stop is needed, else 0
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +int __i40evf_maybe_stop_tx(struct i40e_ring *tx_ring, int size)
++=======
+ int __iavf_maybe_stop_tx(struct iavf_ring *tx_ring, int size)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  {
  	netif_stop_subqueue(tx_ring->netdev, tx_ring->queue_index);
  	/* Memory barrier before checking head and tail */
@@@ -2256,9 -2246,9 +2363,15 @@@
   * @td_cmd:   the command field in the descriptor
   * @td_offset: offset for checksum or crc
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +static inline void i40evf_tx_map(struct i40e_ring *tx_ring, struct sk_buff *skb,
 +				 struct i40e_tx_buffer *first, u32 tx_flags,
 +				 const u8 hdr_len, u32 td_cmd, u32 td_offset)
++=======
+ static inline void iavf_tx_map(struct iavf_ring *tx_ring, struct sk_buff *skb,
+ 			       struct iavf_tx_buffer *first, u32 tx_flags,
+ 			       const u8 hdr_len, u32 td_cmd, u32 td_offset)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  {
  	unsigned int data_len = skb->data_len;
  	unsigned int size = skb_headlen(skb);
@@@ -2269,10 -2259,10 +2382,17 @@@
  	u32 td_tag = 0;
  	dma_addr_t dma;
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +	if (tx_flags & I40E_TX_FLAGS_HW_VLAN) {
 +		td_cmd |= I40E_TX_DESC_CMD_IL2TAG1;
 +		td_tag = (tx_flags & I40E_TX_FLAGS_VLAN_MASK) >>
 +			 I40E_TX_FLAGS_VLAN_SHIFT;
++=======
+ 	if (tx_flags & IAVF_TX_FLAGS_HW_VLAN) {
+ 		td_cmd |= IAVF_TX_DESC_CMD_IL2TAG1;
+ 		td_tag = (tx_flags & IAVF_TX_FLAGS_VLAN_MASK) >>
+ 			 IAVF_TX_FLAGS_VLAN_SHIFT;
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  	}
  
  	first->tx_flags = tx_flags;
@@@ -2401,12 -2391,12 +2521,12 @@@ dma_error
   *
   * Returns NETDEV_TX_OK if sent, else an error code
   **/
- static netdev_tx_t i40e_xmit_frame_ring(struct sk_buff *skb,
- 					struct i40e_ring *tx_ring)
+ static netdev_tx_t iavf_xmit_frame_ring(struct sk_buff *skb,
+ 					struct iavf_ring *tx_ring)
  {
 -	u64 cd_type_cmd_tso_mss = IAVF_TX_DESC_DTYPE_CONTEXT;
 +	u64 cd_type_cmd_tso_mss = I40E_TX_DESC_DTYPE_CONTEXT;
  	u32 cd_tunneling = 0, cd_l2tag2 = 0;
- 	struct i40e_tx_buffer *first;
+ 	struct iavf_tx_buffer *first;
  	u32 td_offset = 0;
  	u32 tx_flags = 0;
  	__be16 protocol;
@@@ -2417,10 -2407,10 +2537,10 @@@
  	/* prefetch the data, we'll need it later */
  	prefetch(skb->data);
  
 -	iavf_trace(xmit_frame_ring, skb, tx_ring);
 +	i40e_trace(xmit_frame_ring, skb, tx_ring);
  
- 	count = i40e_xmit_descriptor_count(skb);
- 	if (i40e_chk_linearize(skb, count)) {
+ 	count = iavf_xmit_descriptor_count(skb);
+ 	if (iavf_chk_linearize(skb, count)) {
  		if (__skb_linearize(skb)) {
  			dev_kfree_skb_any(skb);
  			return NETDEV_TX_OK;
@@@ -2475,13 -2465,13 +2595,13 @@@
  	skb_tx_timestamp(skb);
  
  	/* always enable CRC insertion offload */
 -	td_cmd |= IAVF_TX_DESC_CMD_ICRC;
 +	td_cmd |= I40E_TX_DESC_CMD_ICRC;
  
- 	i40e_create_tx_ctx(tx_ring, cd_type_cmd_tso_mss,
+ 	iavf_create_tx_ctx(tx_ring, cd_type_cmd_tso_mss,
  			   cd_tunneling, cd_l2tag2);
  
 -	iavf_tx_map(tx_ring, skb, first, tx_flags, hdr_len,
 -		    td_cmd, td_offset);
 +	i40evf_tx_map(tx_ring, skb, first, tx_flags, hdr_len,
 +		      td_cmd, td_offset);
  
  	return NETDEV_TX_OK;
  
@@@ -2499,10 -2489,10 +2619,15 @@@ out_drop
   *
   * Returns NETDEV_TX_OK if sent, else an error code
   **/
 -netdev_tx_t iavf_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
 +netdev_tx_t i40evf_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.c
 +	struct i40evf_adapter *adapter = netdev_priv(netdev);
 +	struct i40e_ring *tx_ring = &adapter->tx_rings[skb->queue_mapping];
++=======
+ 	struct iavf_adapter *adapter = netdev_priv(netdev);
+ 	struct iavf_ring *tx_ring = &adapter->tx_rings[skb->queue_mapping];
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.c
  
  	/* hardware can't handle really short frames, hardware padding works
  	 * beyond this point
diff --cc drivers/net/ethernet/intel/i40evf/i40e_txrx.h
index d7a9fa0d91eb,71e7d090f8db..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.h
@@@ -95,14 -95,12 +95,18 @@@ enum iavf_dyn_idx_t 
   * i.e. RXBUFFER_256 --> 960 byte skb (size-1024 slab)
   * i.e. RXBUFFER_512 --> 1216 byte skb (size-2048 slab)
   */
- #define I40E_RX_HDR_SIZE I40E_RXBUFFER_256
- #define I40E_PACKET_HDR_PAD (ETH_HLEN + ETH_FCS_LEN + (VLAN_HLEN * 2))
- #define i40e_rx_desc i40e_32byte_rx_desc
+ #define IAVF_RX_HDR_SIZE IAVF_RXBUFFER_256
+ #define IAVF_PACKET_HDR_PAD (ETH_HLEN + ETH_FCS_LEN + (VLAN_HLEN * 2))
+ #define iavf_rx_desc iavf_32byte_rx_desc
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.h
 +#if 0 /* cannot use combined I40E_RX_DMA_ATTR in RHEL7 */
 +#define I40E_RX_DMA_ATTR \
++=======
+ #define IAVF_RX_DMA_ATTR \
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.h
  	(DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING)
 +#endif
  
  /* Attempt to maximize the headroom available for incoming frames.  We
   * use a 2K buffer for receives and need 1536/1534 to store the data for
@@@ -188,12 -185,12 +191,12 @@@ static inline bool iavf_test_staterr(un
  		(i)++;				\
  		if ((i) == (r)->count)		\
  			i = 0;			\
 -		(n) = IAVF_RX_DESC((r), (i));	\
 +		(n) = I40E_RX_DESC((r), (i));	\
  	} while (0)
  
- #define I40E_RX_NEXT_DESC_PREFETCH(r, i, n)		\
+ #define IAVF_RX_NEXT_DESC_PREFETCH(r, i, n)		\
  	do {						\
- 		I40E_RX_NEXT_DESC((r), (i), (n));	\
+ 		IAVF_RX_NEXT_DESC((r), (i), (n));	\
  		prefetch((n));				\
  	} while (0)
  
@@@ -437,25 -434,25 +440,42 @@@ static inline unsigned int iavf_rx_pg_o
  	return 0;
  }
  
- #define i40e_rx_pg_size(_ring) (PAGE_SIZE << i40e_rx_pg_order(_ring))
+ #define iavf_rx_pg_size(_ring) (PAGE_SIZE << iavf_rx_pg_order(_ring))
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_txrx.h
 +bool i40evf_alloc_rx_buffers(struct i40e_ring *rxr, u16 cleaned_count);
 +netdev_tx_t i40evf_xmit_frame(struct sk_buff *skb, struct net_device *netdev);
 +void i40evf_clean_tx_ring(struct i40e_ring *tx_ring);
 +void i40evf_clean_rx_ring(struct i40e_ring *rx_ring);
 +int i40evf_setup_tx_descriptors(struct i40e_ring *tx_ring);
 +int i40evf_setup_rx_descriptors(struct i40e_ring *rx_ring);
 +void i40evf_free_tx_resources(struct i40e_ring *tx_ring);
 +void i40evf_free_rx_resources(struct i40e_ring *rx_ring);
 +int i40evf_napi_poll(struct napi_struct *napi, int budget);
 +void i40evf_force_wb(struct i40e_vsi *vsi, struct i40e_q_vector *q_vector);
 +u32 i40evf_get_tx_pending(struct i40e_ring *ring, bool in_sw);
 +void i40evf_detect_recover_hung(struct i40e_vsi *vsi);
 +int __i40evf_maybe_stop_tx(struct i40e_ring *tx_ring, int size);
 +bool __i40evf_chk_linearize(struct sk_buff *skb);
++=======
+ bool iavf_alloc_rx_buffers(struct iavf_ring *rxr, u16 cleaned_count);
+ netdev_tx_t iavf_xmit_frame(struct sk_buff *skb, struct net_device *netdev);
+ void iavf_clean_tx_ring(struct iavf_ring *tx_ring);
+ void iavf_clean_rx_ring(struct iavf_ring *rx_ring);
+ int iavf_setup_tx_descriptors(struct iavf_ring *tx_ring);
+ int iavf_setup_rx_descriptors(struct iavf_ring *rx_ring);
+ void iavf_free_tx_resources(struct iavf_ring *tx_ring);
+ void iavf_free_rx_resources(struct iavf_ring *rx_ring);
+ int iavf_napi_poll(struct napi_struct *napi, int budget);
+ void iavf_force_wb(struct iavf_vsi *vsi, struct iavf_q_vector *q_vector);
+ u32 iavf_get_tx_pending(struct iavf_ring *ring, bool in_sw);
+ void iavf_detect_recover_hung(struct iavf_vsi *vsi);
+ int __iavf_maybe_stop_tx(struct iavf_ring *tx_ring, int size);
+ bool __iavf_chk_linearize(struct sk_buff *skb);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_txrx.h
  
  /**
-  * i40e_xmit_descriptor_count - calculate number of Tx descriptors needed
+  * iavf_xmit_descriptor_count - calculate number of Tx descriptors needed
   * @skb:     send buffer
   * @tx_ring: ring to send buffer on
   *
@@@ -488,11 -485,11 +508,11 @@@ static inline int iavf_xmit_descriptor_
   *
   * Returns 0 if stop is not needed
   **/
- static inline int i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size)
+ static inline int iavf_maybe_stop_tx(struct iavf_ring *tx_ring, int size)
  {
- 	if (likely(I40E_DESC_UNUSED(tx_ring) >= size))
+ 	if (likely(IAVF_DESC_UNUSED(tx_ring) >= size))
  		return 0;
 -	return __iavf_maybe_stop_tx(tx_ring, size);
 +	return __i40evf_maybe_stop_tx(tx_ring, size);
  }
  
  /**
@@@ -511,10 -508,10 +531,10 @@@ static inline bool iavf_chk_linearize(s
  		return false;
  
  	if (skb_is_gso(skb))
 -		return __iavf_chk_linearize(skb);
 +		return __i40evf_chk_linearize(skb);
  
  	/* we can support up to 8 data buffers for a single send */
- 	return count != I40E_MAX_BUFFER_TXD;
+ 	return count != IAVF_MAX_BUFFER_TXD;
  }
  /**
   * @ring: Tx ring to find the netdev equivalent of
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_client.c
index 3cc9d60d0d72,51dd0def3b85..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_client.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_client.c
@@@ -4,27 -4,27 +4,32 @@@
  #include <linux/list.h>
  #include <linux/errno.h>
  
 -#include "iavf.h"
 +#include "i40evf.h"
  #include "i40e_prototype.h"
 -#include "iavf_client.h"
 +#include "i40evf_client.h"
  
  static
 -const char iavf_client_interface_version_str[] = IAVF_CLIENT_VERSION_STR;
 +const char i40evf_client_interface_version_str[] = I40EVF_CLIENT_VERSION_STR;
  static struct i40e_client *vf_registered_client;
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_client.c
 +static LIST_HEAD(i40evf_devices);
 +static DEFINE_MUTEX(i40evf_device_mutex);
++=======
+ static LIST_HEAD(i40e_devices);
+ static DEFINE_MUTEX(iavf_device_mutex);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_client.c
  
 -static u32 iavf_client_virtchnl_send(struct i40e_info *ldev,
 -				     struct i40e_client *client,
 -				     u8 *msg, u16 len);
 +static u32 i40evf_client_virtchnl_send(struct i40e_info *ldev,
 +				       struct i40e_client *client,
 +				       u8 *msg, u16 len);
  
 -static int iavf_client_setup_qvlist(struct i40e_info *ldev,
 -				    struct i40e_client *client,
 -				    struct i40e_qvlist_info *qvlist_info);
 +static int i40evf_client_setup_qvlist(struct i40e_info *ldev,
 +				      struct i40e_client *client,
 +				      struct i40e_qvlist_info *qvlist_info);
  
 -static struct i40e_ops iavf_lan_ops = {
 -	.virtchnl_send = iavf_client_virtchnl_send,
 -	.setup_qvlist = iavf_client_setup_qvlist,
 +static struct i40e_ops i40evf_lan_ops = {
 +	.virtchnl_send = i40evf_client_virtchnl_send,
 +	.setup_qvlist = i40evf_client_setup_qvlist,
  };
  
  /**
@@@ -33,7 -33,7 +38,11 @@@
   * @params: client param struct
   **/
  static
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_client.c
 +void i40evf_client_get_params(struct i40e_vsi *vsi, struct i40e_params *params)
++=======
+ void iavf_client_get_params(struct iavf_vsi *vsi, struct i40e_params *params)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_client.c
  {
  	int i;
  
@@@ -55,7 -55,7 +64,11 @@@
   *
   * If there is a client to this VSI, call the client
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_client.c
 +void i40evf_notify_client_message(struct i40e_vsi *vsi, u8 *msg, u16 len)
++=======
+ void iavf_notify_client_message(struct iavf_vsi *vsi, u8 *msg, u16 len)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_client.c
  {
  	struct i40e_client_instance *cinst;
  
@@@ -79,7 -79,7 +92,11 @@@
   *
   * If there is a client to this VSI, call the client
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_client.c
 +void i40evf_notify_client_l2_params(struct i40e_vsi *vsi)
++=======
+ void iavf_notify_client_l2_params(struct iavf_vsi *vsi)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_client.c
  {
  	struct i40e_client_instance *cinst;
  	struct i40e_params params;
@@@ -107,9 -107,9 +124,13 @@@
   *
   * If there is a client to this netdev, call the client with open
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_client.c
 +void i40evf_notify_client_open(struct i40e_vsi *vsi)
++=======
+ void iavf_notify_client_open(struct iavf_vsi *vsi)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_client.c
  {
 -	struct iavf_adapter *adapter = vsi->back;
 +	struct i40evf_adapter *adapter = vsi->back;
  	struct i40e_client_instance *cinst = adapter->cinst;
  	int ret;
  
@@@ -159,9 -159,9 +180,13 @@@ static int i40evf_client_release_qvlist
   *
   * If there is a client to this netdev, call the client with close
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_client.c
 +void i40evf_notify_client_close(struct i40e_vsi *vsi, bool reset)
++=======
+ void iavf_notify_client_close(struct iavf_vsi *vsi, bool reset)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_client.c
  {
 -	struct iavf_adapter *adapter = vsi->back;
 +	struct i40evf_adapter *adapter = vsi->back;
  	struct i40e_client_instance *cinst = adapter->cinst;
  
  	if (!cinst || !cinst->client || !cinst->client->ops ||
@@@ -182,10 -182,10 +207,10 @@@
   * Returns cinst ptr on success, NULL on failure
   **/
  static struct i40e_client_instance *
 -iavf_client_add_instance(struct iavf_adapter *adapter)
 +i40evf_client_add_instance(struct i40evf_adapter *adapter)
  {
  	struct i40e_client_instance *cinst = NULL;
- 	struct i40e_vsi *vsi = &adapter->vsi;
+ 	struct iavf_vsi *vsi = &adapter->vsi;
  	struct netdev_hw_addr *mac = NULL;
  	struct i40e_params params;
  
@@@ -294,8 -294,8 +319,13 @@@ int i40evf_lan_add_device(struct i40evf
  	struct i40e_device *ldev;
  	int ret = 0;
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_client.c
 +	mutex_lock(&i40evf_device_mutex);
 +	list_for_each_entry(ldev, &i40evf_devices, list) {
++=======
+ 	mutex_lock(&iavf_device_mutex);
+ 	list_for_each_entry(ldev, &i40e_devices, list) {
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_client.c
  		if (ldev->vf == adapter) {
  			ret = -EEXIST;
  			goto out;
@@@ -308,7 -308,7 +338,11 @@@
  	}
  	ldev->vf = adapter;
  	INIT_LIST_HEAD(&ldev->list);
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_client.c
 +	list_add(&ldev->list, &i40evf_devices);
++=======
+ 	list_add(&ldev->list, &i40e_devices);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_client.c
  	dev_info(&adapter->pdev->dev, "Added LAN device bus=0x%02x dev=0x%02x func=0x%02x\n",
  		 adapter->hw.bus.bus_id, adapter->hw.bus.device,
  		 adapter->hw.bus.func);
@@@ -334,8 -334,8 +368,13 @@@ int i40evf_lan_del_device(struct i40evf
  	struct i40e_device *ldev, *tmp;
  	int ret = -ENODEV;
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_client.c
 +	mutex_lock(&i40evf_device_mutex);
 +	list_for_each_entry_safe(ldev, tmp, &i40evf_devices, list) {
++=======
+ 	mutex_lock(&iavf_device_mutex);
+ 	list_for_each_entry_safe(ldev, tmp, &i40e_devices, list) {
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_client.c
  		if (ldev->vf == adapter) {
  			dev_info(&adapter->pdev->dev,
  				 "Deleted LAN device bus=0x%02x dev=0x%02x func=0x%02x\n",
@@@ -361,10 -361,10 +400,15 @@@ static void i40evf_client_release(struc
  {
  	struct i40e_client_instance *cinst;
  	struct i40e_device *ldev;
 -	struct iavf_adapter *adapter;
 +	struct i40evf_adapter *adapter;
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_client.c
 +	mutex_lock(&i40evf_device_mutex);
 +	list_for_each_entry(ldev, &i40evf_devices, list) {
++=======
+ 	mutex_lock(&iavf_device_mutex);
+ 	list_for_each_entry(ldev, &i40e_devices, list) {
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_client.c
  		adapter = ldev->vf;
  		cinst = adapter->cinst;
  		if (!cinst)
@@@ -392,18 -392,18 +436,23 @@@
   * @client: pointer to the registered client
   *
   **/
 -static void iavf_client_prepare(struct i40e_client *client)
 +static void i40evf_client_prepare(struct i40e_client *client)
  {
  	struct i40e_device *ldev;
 -	struct iavf_adapter *adapter;
 +	struct i40evf_adapter *adapter;
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_client.c
 +	mutex_lock(&i40evf_device_mutex);
 +	list_for_each_entry(ldev, &i40evf_devices, list) {
++=======
+ 	mutex_lock(&iavf_device_mutex);
+ 	list_for_each_entry(ldev, &i40e_devices, list) {
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_client.c
  		adapter = ldev->vf;
  		/* Signal the watchdog to service the client */
 -		adapter->flags |= IAVF_FLAG_SERVICE_CLIENT_REQUESTED;
 +		adapter->flags |= I40EVF_FLAG_SERVICE_CLIENT_REQUESTED;
  	}
 -	mutex_unlock(&iavf_device_mutex);
 +	mutex_unlock(&i40evf_device_mutex);
  }
  
  /**
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
index 50f65ab737c9,9f87304109fe..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
@@@ -69,12 -63,12 +63,21 @@@ static const struct iavf_stats iavf_gst
   * @stat: the stat definition
   *
   * Copies the stat data defined by the pointer and stat structure pair into
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
 + * the memory supplied as data. Used to implement i40e_add_ethtool_stats and
 + * i40evf_add_queue_stats. If the pointer is null, data will be zero'd.
 + */
 +static void
 +i40evf_add_one_ethtool_stat(u64 *data, void *pointer,
 +			    const struct i40e_stats *stat)
++=======
+  * the memory supplied as data. Used to implement iavf_add_ethtool_stats and
+  * iavf_add_queue_stats. If the pointer is null, data will be zero'd.
+  */
+ static void
+ iavf_add_one_ethtool_stat(u64 *data, void *pointer,
+ 			  const struct iavf_stats *stat)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_ethtool.c
  {
  	char *p;
  
@@@ -121,9 -115,9 +124,15 @@@
   * skip these stats.
   **/
  static void
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
 +__i40evf_add_ethtool_stats(u64 **data, void *pointer,
 +			   const struct i40e_stats stats[],
 +			   const unsigned int size)
++=======
+ __iavf_add_ethtool_stats(u64 **data, void *pointer,
+ 			 const struct iavf_stats stats[],
+ 			 const unsigned int size)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_ethtool.c
  {
  	unsigned int i;
  
@@@ -144,11 -138,11 +153,16 @@@
   * The parameter @stats is evaluated twice, so parameters with side effects
   * should be avoided.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
 +#define i40e_add_ethtool_stats(data, pointer, stats) \
 +	__i40evf_add_ethtool_stats(data, pointer, stats, ARRAY_SIZE(stats))
++=======
+ #define iavf_add_ethtool_stats(data, pointer, stats) \
+ 	__iavf_add_ethtool_stats(data, pointer, stats, ARRAY_SIZE(stats))
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_ethtool.c
  
  /**
 - * iavf_add_queue_stats - copy queue statistics into supplied buffer
 + * i40evf_add_queue_stats - copy queue statistics into supplied buffer
   * @data: ethtool stats buffer
   * @ring: the ring to copy
   *
@@@ -162,10 -156,10 +176,14 @@@
   * This function expects to be called while under rcu_read_lock().
   **/
  static void
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
 +i40evf_add_queue_stats(u64 **data, struct i40e_ring *ring)
++=======
+ iavf_add_queue_stats(u64 **data, struct iavf_ring *ring)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_ethtool.c
  {
- 	const unsigned int size = ARRAY_SIZE(i40e_gstrings_queue_stats);
- 	const struct i40e_stats *stats = i40e_gstrings_queue_stats;
+ 	const unsigned int size = ARRAY_SIZE(iavf_gstrings_queue_stats);
+ 	const struct iavf_stats *stats = iavf_gstrings_queue_stats;
  	unsigned int start;
  	unsigned int i;
  
@@@ -211,7 -203,7 +229,11 @@@ static void __iavf_add_stat_strings(u8 
  }
  
  /**
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
 + * 40e_add_stat_strings - copy stat strings into ethtool buffer
++=======
+  * iavf_add_stat_strings - copy stat strings into ethtool buffer
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_ethtool.c
   * @p: ethtool supplied buffer
   * @stats: stat definitions array
   *
@@@ -222,30 -214,30 +244,53 @@@
   * should be avoided. Additionally, stats must be an array such that
   * ARRAY_SIZE can be called on it.
   **/
- #define i40e_add_stat_strings(p, stats, ...) \
- 	__i40e_add_stat_strings(p, stats, ARRAY_SIZE(stats), ## __VA_ARGS__)
+ #define iavf_add_stat_strings(p, stats, ...) \
+ 	__iavf_add_stat_strings(p, stats, ARRAY_SIZE(stats), ## __VA_ARGS__)
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
 +#define I40EVF_STAT(_name, _stat) \
 +	I40E_STAT(struct i40evf_adapter, _name, _stat)
 +
 +static const struct i40e_stats i40evf_gstrings_stats[] = {
 +	I40EVF_STAT("rx_bytes", current_stats.rx_bytes),
 +	I40EVF_STAT("rx_unicast", current_stats.rx_unicast),
 +	I40EVF_STAT("rx_multicast", current_stats.rx_multicast),
 +	I40EVF_STAT("rx_broadcast", current_stats.rx_broadcast),
 +	I40EVF_STAT("rx_discards", current_stats.rx_discards),
 +	I40EVF_STAT("rx_unknown_protocol", current_stats.rx_unknown_protocol),
 +	I40EVF_STAT("tx_bytes", current_stats.tx_bytes),
 +	I40EVF_STAT("tx_unicast", current_stats.tx_unicast),
 +	I40EVF_STAT("tx_multicast", current_stats.tx_multicast),
 +	I40EVF_STAT("tx_broadcast", current_stats.tx_broadcast),
 +	I40EVF_STAT("tx_discards", current_stats.tx_discards),
 +	I40EVF_STAT("tx_errors", current_stats.tx_errors),
++=======
+ #define VF_STAT(_name, _stat) \
+ 	IAVF_STAT(struct iavf_adapter, _name, _stat)
+ 
+ static const struct iavf_stats iavf_gstrings_stats[] = {
+ 	VF_STAT("rx_bytes", current_stats.rx_bytes),
+ 	VF_STAT("rx_unicast", current_stats.rx_unicast),
+ 	VF_STAT("rx_multicast", current_stats.rx_multicast),
+ 	VF_STAT("rx_broadcast", current_stats.rx_broadcast),
+ 	VF_STAT("rx_discards", current_stats.rx_discards),
+ 	VF_STAT("rx_unknown_protocol", current_stats.rx_unknown_protocol),
+ 	VF_STAT("tx_bytes", current_stats.tx_bytes),
+ 	VF_STAT("tx_unicast", current_stats.tx_unicast),
+ 	VF_STAT("tx_multicast", current_stats.tx_multicast),
+ 	VF_STAT("tx_broadcast", current_stats.tx_broadcast),
+ 	VF_STAT("tx_discards", current_stats.tx_discards),
+ 	VF_STAT("tx_errors", current_stats.tx_errors),
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_ethtool.c
  };
  
 -#define IAVF_STATS_LEN	ARRAY_SIZE(iavf_gstrings_stats)
 +#define I40EVF_STATS_LEN	ARRAY_SIZE(i40evf_gstrings_stats)
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
 +#define I40EVF_QUEUE_STATS_LEN	ARRAY_SIZE(i40e_gstrings_queue_stats)
++=======
+ #define IAVF_QUEUE_STATS_LEN	ARRAY_SIZE(iavf_gstrings_queue_stats)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_ethtool.c
  
  /* For now we have one and only one private flag and it is only defined
   * when we have support for the SKIP_CPU_SYNC DMA attribute.  Instead
@@@ -345,17 -337,17 +390,25 @@@ static int i40evf_get_sset_count(struc
   *
   * All statistics are added to the data buffer as an array of u64.
   **/
 -static void iavf_get_ethtool_stats(struct net_device *netdev,
 -				   struct ethtool_stats *stats, u64 *data)
 +static void i40evf_get_ethtool_stats(struct net_device *netdev,
 +				     struct ethtool_stats *stats, u64 *data)
  {
 -	struct iavf_adapter *adapter = netdev_priv(netdev);
 +	struct i40evf_adapter *adapter = netdev_priv(netdev);
  	unsigned int i;
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
 +	i40e_add_ethtool_stats(&data, adapter, i40evf_gstrings_stats);
 +
 +	rcu_read_lock();
 +	for (i = 0; i < I40EVF_MAX_REQ_QUEUES; i++) {
 +		struct i40e_ring *ring;
++=======
+ 	iavf_add_ethtool_stats(&data, adapter, iavf_gstrings_stats);
+ 
+ 	rcu_read_lock();
+ 	for (i = 0; i < IAVF_MAX_REQ_QUEUES; i++) {
+ 		struct iavf_ring *ring;
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_ethtool.c
  
  		/* Avoid accessing un-allocated queues */
  		ring = (i < adapter->num_active_queues ?
@@@ -399,7 -391,7 +452,11 @@@ static void i40evf_get_stat_strings(str
  {
  	unsigned int i;
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
 +	i40e_add_stat_strings(&data, i40evf_gstrings_stats);
++=======
+ 	iavf_add_stat_strings(&data, iavf_gstrings_stats);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_ethtool.c
  
  	/* Queues are always allocated in pairs, so we just use num_tx_queues
  	 * for both Tx and Rx queues.
@@@ -546,11 -538,11 +603,11 @@@ static u32 i40evf_get_msglevel(struct n
   * Set current debug message level. Higher values cause the driver to
   * be noisier.
   **/
 -static void iavf_set_msglevel(struct net_device *netdev, u32 data)
 +static void i40evf_set_msglevel(struct net_device *netdev, u32 data)
  {
 -	struct iavf_adapter *adapter = netdev_priv(netdev);
 +	struct i40evf_adapter *adapter = netdev_priv(netdev);
  
- 	if (I40E_DEBUG_USER & data)
+ 	if (IAVF_DEBUG_USER & data)
  		adapter->hw.debug_mask = data;
  	adapter->msg_enable = data;
  }
@@@ -646,13 -638,12 +703,19 @@@ static int i40evf_set_ringparam(struct 
   * are per queue. If queue is <0 then we default to queue 0 as the
   * representative value.
   **/
 -static int __iavf_get_coalesce(struct net_device *netdev,
 -			       struct ethtool_coalesce *ec, int queue)
 +static int __i40evf_get_coalesce(struct net_device *netdev,
 +				 struct ethtool_coalesce *ec,
 +				 int queue)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
 +	struct i40evf_adapter *adapter = netdev_priv(netdev);
 +	struct i40e_vsi *vsi = &adapter->vsi;
 +	struct i40e_ring *rx_ring, *tx_ring;
++=======
+ 	struct iavf_adapter *adapter = netdev_priv(netdev);
+ 	struct iavf_vsi *vsi = &adapter->vsi;
+ 	struct iavf_ring *rx_ring, *tx_ring;
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_ethtool.c
  
  	ec->tx_max_coalesced_frames = vsi->work_limit;
  	ec->rx_max_coalesced_frames = vsi->work_limit;
@@@ -719,13 -709,12 +782,13 @@@ static int i40evf_get_per_queue_coalesc
   *
   * Change the ITR settings for a specific queue.
   **/
 -static void iavf_set_itr_per_queue(struct iavf_adapter *adapter,
 -				   struct ethtool_coalesce *ec, int queue)
 +static void i40evf_set_itr_per_queue(struct i40evf_adapter *adapter,
 +				     struct ethtool_coalesce *ec,
 +				     int queue)
  {
- 	struct i40e_ring *rx_ring = &adapter->rx_rings[queue];
- 	struct i40e_ring *tx_ring = &adapter->tx_rings[queue];
- 	struct i40e_q_vector *q_vector;
+ 	struct iavf_ring *rx_ring = &adapter->rx_rings[queue];
+ 	struct iavf_ring *tx_ring = &adapter->tx_rings[queue];
+ 	struct iavf_q_vector *q_vector;
  
  	rx_ring->itr_setting = ITR_REG_ALIGN(ec->rx_coalesce_usecs);
  	tx_ring->itr_setting = ITR_REG_ALIGN(ec->tx_coalesce_usecs);
@@@ -758,12 -747,11 +821,17 @@@
   *
   * Sets the coalesce settings for a particular queue.
   **/
 -static int __iavf_set_coalesce(struct net_device *netdev,
 -			       struct ethtool_coalesce *ec, int queue)
 +static int __i40evf_set_coalesce(struct net_device *netdev,
 +				 struct ethtool_coalesce *ec,
 +				 int queue)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
 +	struct i40evf_adapter *adapter = netdev_priv(netdev);
 +	struct i40e_vsi *vsi = &adapter->vsi;
++=======
+ 	struct iavf_adapter *adapter = netdev_priv(netdev);
+ 	struct iavf_vsi *vsi = &adapter->vsi;
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_ethtool.c
  	int i;
  
  	if (ec->tx_max_coalesced_frames_irq || ec->rx_max_coalesced_frames_irq)
@@@ -772,18 -760,15 +840,18 @@@
  	if (ec->rx_coalesce_usecs == 0) {
  		if (ec->use_adaptive_rx_coalesce)
  			netif_info(adapter, drv, netdev, "rx-usecs=0, need to disable adaptive-rx for a complete disable\n");
- 	} else if ((ec->rx_coalesce_usecs < I40E_MIN_ITR) ||
- 		   (ec->rx_coalesce_usecs > I40E_MAX_ITR)) {
+ 	} else if ((ec->rx_coalesce_usecs < IAVF_MIN_ITR) ||
+ 		   (ec->rx_coalesce_usecs > IAVF_MAX_ITR)) {
  		netif_info(adapter, drv, netdev, "Invalid value, rx-usecs range is 0-8160\n");
  		return -EINVAL;
 -	} else if (ec->tx_coalesce_usecs == 0) {
 +	}
 +
 +	else
 +	if (ec->tx_coalesce_usecs == 0) {
  		if (ec->use_adaptive_tx_coalesce)
  			netif_info(adapter, drv, netdev, "tx-usecs=0, need to disable adaptive-tx for a complete disable\n");
- 	} else if ((ec->tx_coalesce_usecs < I40E_MIN_ITR) ||
- 		   (ec->tx_coalesce_usecs > I40E_MAX_ITR)) {
+ 	} else if ((ec->tx_coalesce_usecs < IAVF_MIN_ITR) ||
+ 		   (ec->tx_coalesce_usecs > IAVF_MAX_ITR)) {
  		netif_info(adapter, drv, netdev, "Invalid value, tx-usecs range is 0-8160\n");
  		return -EINVAL;
  	}
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_main.c
index 950c8aeb0fc9,aa157fdf909c..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_main.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
@@@ -65,11 -66,11 +65,17 @@@ static struct workqueue_struct *i40evf_
   * @size: size of memory requested
   * @alignment: what to align the allocation to
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +i40e_status i40evf_allocate_dma_mem_d(struct i40e_hw *hw,
 +				      struct i40e_dma_mem *mem,
 +				      u64 size, u32 alignment)
++=======
+ iavf_status iavf_allocate_dma_mem_d(struct iavf_hw *hw,
+ 				    struct iavf_dma_mem *mem,
+ 				    u64 size, u32 alignment)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  {
 -	struct iavf_adapter *adapter = (struct iavf_adapter *)hw->back;
 +	struct i40evf_adapter *adapter = (struct i40evf_adapter *)hw->back;
  
  	if (!mem)
  		return I40E_ERR_PARAM;
@@@ -88,9 -89,9 +94,13 @@@
   * @hw:   pointer to the HW structure
   * @mem:  ptr to mem struct to free
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +i40e_status i40evf_free_dma_mem_d(struct i40e_hw *hw, struct i40e_dma_mem *mem)
++=======
+ iavf_status iavf_free_dma_mem_d(struct iavf_hw *hw, struct iavf_dma_mem *mem)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  {
 -	struct iavf_adapter *adapter = (struct iavf_adapter *)hw->back;
 +	struct i40evf_adapter *adapter = (struct i40evf_adapter *)hw->back;
  
  	if (!mem || !mem->va)
  		return I40E_ERR_PARAM;
@@@ -105,8 -106,8 +115,13 @@@
   * @mem:  ptr to mem struct to fill out
   * @size: size of memory requested
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +i40e_status i40evf_allocate_virt_mem_d(struct i40e_hw *hw,
 +				       struct i40e_virt_mem *mem, u32 size)
++=======
+ iavf_status iavf_allocate_virt_mem_d(struct iavf_hw *hw,
+ 				     struct iavf_virt_mem *mem, u32 size)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  {
  	if (!mem)
  		return I40E_ERR_PARAM;
@@@ -125,8 -126,7 +140,12 @@@
   * @hw:   pointer to the HW structure
   * @mem:  ptr to mem struct to free
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +i40e_status i40evf_free_virt_mem_d(struct i40e_hw *hw,
 +				   struct i40e_virt_mem *mem)
++=======
+ iavf_status iavf_free_virt_mem_d(struct iavf_hw *hw, struct iavf_virt_mem *mem)
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  {
  	if (!mem)
  		return I40E_ERR_PARAM;
@@@ -300,9 -297,9 +319,9 @@@ static irqreturn_t i40evf_msix_aq(int i
   * @irq: interrupt number
   * @data: pointer to a q_vector
   **/
 -static irqreturn_t iavf_msix_clean_rings(int irq, void *data)
 +static irqreturn_t i40evf_msix_clean_rings(int irq, void *data)
  {
- 	struct i40e_q_vector *q_vector = data;
+ 	struct iavf_q_vector *q_vector = data;
  
  	if (!q_vector->tx.ring && !q_vector->rx.ring)
  		return IRQ_HANDLED;
@@@ -319,11 -316,11 +338,17 @@@
   * @r_idx: queue number
   **/
  static void
 -iavf_map_vector_to_rxq(struct iavf_adapter *adapter, int v_idx, int r_idx)
 +i40evf_map_vector_to_rxq(struct i40evf_adapter *adapter, int v_idx, int r_idx)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +	struct i40e_q_vector *q_vector = &adapter->q_vectors[v_idx];
 +	struct i40e_ring *rx_ring = &adapter->rx_rings[r_idx];
 +	struct i40e_hw *hw = &adapter->hw;
++=======
+ 	struct iavf_q_vector *q_vector = &adapter->q_vectors[v_idx];
+ 	struct iavf_ring *rx_ring = &adapter->rx_rings[r_idx];
+ 	struct iavf_hw *hw = &adapter->hw;
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  
  	rx_ring->q_vector = q_vector;
  	rx_ring->next = q_vector->rx.ring;
@@@ -333,7 -330,7 +358,11 @@@
  	q_vector->rx.next_update = jiffies + 1;
  	q_vector->rx.target_itr = ITR_TO_REG(rx_ring->itr_setting);
  	q_vector->ring_mask |= BIT(r_idx);
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +	wr32(hw, I40E_VFINT_ITRN1(I40E_RX_ITR, q_vector->reg_idx),
++=======
+ 	wr32(hw, IAVF_VFINT_ITRN1(IAVF_RX_ITR, q_vector->reg_idx),
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  	     q_vector->rx.current_itr);
  	q_vector->rx.current_itr = q_vector->rx.target_itr;
  }
@@@ -345,11 -342,11 +374,17 @@@
   * @t_idx: queue number
   **/
  static void
 -iavf_map_vector_to_txq(struct iavf_adapter *adapter, int v_idx, int t_idx)
 +i40evf_map_vector_to_txq(struct i40evf_adapter *adapter, int v_idx, int t_idx)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +	struct i40e_q_vector *q_vector = &adapter->q_vectors[v_idx];
 +	struct i40e_ring *tx_ring = &adapter->tx_rings[t_idx];
 +	struct i40e_hw *hw = &adapter->hw;
++=======
+ 	struct iavf_q_vector *q_vector = &adapter->q_vectors[v_idx];
+ 	struct iavf_ring *tx_ring = &adapter->tx_rings[t_idx];
+ 	struct iavf_hw *hw = &adapter->hw;
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  
  	tx_ring->q_vector = q_vector;
  	tx_ring->next = q_vector->tx.ring;
@@@ -359,7 -356,7 +394,11 @@@
  	q_vector->tx.next_update = jiffies + 1;
  	q_vector->tx.target_itr = ITR_TO_REG(tx_ring->itr_setting);
  	q_vector->num_ringpairs++;
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +	wr32(hw, I40E_VFINT_ITRN1(I40E_TX_ITR, q_vector->reg_idx),
++=======
+ 	wr32(hw, IAVF_VFINT_ITRN1(IAVF_TX_ITR, q_vector->reg_idx),
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  	     q_vector->tx.target_itr);
  	q_vector->tx.current_itr = q_vector->tx.target_itr;
  }
@@@ -427,11 -424,11 +466,11 @@@ static void i40evf_netpoll(struct net_d
   * This is a callback function used by the irq_set_affinity_notifier function
   * so that we may register to receive changes to the irq affinity masks.
   **/
 -static void iavf_irq_affinity_notify(struct irq_affinity_notify *notify,
 -				     const cpumask_t *mask)
 +static void i40evf_irq_affinity_notify(struct irq_affinity_notify *notify,
 +				       const cpumask_t *mask)
  {
- 	struct i40e_q_vector *q_vector =
- 		container_of(notify, struct i40e_q_vector, affinity_notify);
+ 	struct iavf_q_vector *q_vector =
+ 		container_of(notify, struct iavf_q_vector, affinity_notify);
  
  	cpumask_copy(&q_vector->affinity_mask, mask);
  }
@@@ -467,7 -464,8 +506,12 @@@ i40evf_request_traffic_irqs(struct i40e
  	q_vectors = adapter->num_msix_vectors - NONQ_VECS;
  
  	for (vector = 0; vector < q_vectors; vector++) {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +		struct i40e_q_vector *q_vector = &adapter->q_vectors[vector];
++=======
+ 		struct iavf_q_vector *q_vector = &adapter->q_vectors[vector];
+ 
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  		irq_num = adapter->msix_entries[vector + NONQ_VECS].vector;
  
  		if (q_vector->tx.ring && q_vector->rx.ring) {
@@@ -608,10 -606,10 +652,15 @@@ static void i40evf_configure_tx(struct 
   *
   * Configure the Rx unit of the MAC after a reset.
   **/
 -static void iavf_configure_rx(struct iavf_adapter *adapter)
 +static void i40evf_configure_rx(struct i40evf_adapter *adapter)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +	unsigned int rx_buf_len = I40E_RXBUFFER_2048;
 +	struct i40e_hw *hw = &adapter->hw;
++=======
+ 	unsigned int rx_buf_len = IAVF_RXBUFFER_2048;
+ 	struct iavf_hw *hw = &adapter->hw;
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  	int i;
  
  	/* Legacy Rx will always default to a 2048 buffer size. */
@@@ -932,13 -930,13 +981,13 @@@ static void i40evf_set_rx_mode(struct n
  }
  
  /**
 - * iavf_napi_enable_all - enable NAPI on all queue vectors
 + * i40evf_napi_enable_all - enable NAPI on all queue vectors
   * @adapter: board private structure
   **/
 -static void iavf_napi_enable_all(struct iavf_adapter *adapter)
 +static void i40evf_napi_enable_all(struct i40evf_adapter *adapter)
  {
  	int q_idx;
- 	struct i40e_q_vector *q_vector;
+ 	struct iavf_q_vector *q_vector;
  	int q_vectors = adapter->num_msix_vectors - NONQ_VECS;
  
  	for (q_idx = 0; q_idx < q_vectors; q_idx++) {
@@@ -951,13 -949,13 +1000,13 @@@
  }
  
  /**
 - * iavf_napi_disable_all - disable NAPI on all queue vectors
 + * i40evf_napi_disable_all - disable NAPI on all queue vectors
   * @adapter: board private structure
   **/
 -static void iavf_napi_disable_all(struct iavf_adapter *adapter)
 +static void i40evf_napi_disable_all(struct i40evf_adapter *adapter)
  {
  	int q_idx;
- 	struct i40e_q_vector *q_vector;
+ 	struct iavf_q_vector *q_vector;
  	int q_vectors = adapter->num_msix_vectors - NONQ_VECS;
  
  	for (q_idx = 0; q_idx < q_vectors; q_idx++) {
@@@ -975,52 -973,52 +1024,61 @@@ static void i40evf_configure(struct i40
  	struct net_device *netdev = adapter->netdev;
  	int i;
  
 -	iavf_set_rx_mode(netdev);
 +	i40evf_set_rx_mode(netdev);
  
 -	iavf_configure_tx(adapter);
 -	iavf_configure_rx(adapter);
 -	adapter->aq_required |= IAVF_FLAG_AQ_CONFIGURE_QUEUES;
 +	i40evf_configure_tx(adapter);
 +	i40evf_configure_rx(adapter);
 +	adapter->aq_required |= I40EVF_FLAG_AQ_CONFIGURE_QUEUES;
  
  	for (i = 0; i < adapter->num_active_queues; i++) {
- 		struct i40e_ring *ring = &adapter->rx_rings[i];
+ 		struct iavf_ring *ring = &adapter->rx_rings[i];
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +		i40evf_alloc_rx_buffers(ring, I40E_DESC_UNUSED(ring));
++=======
+ 		iavf_alloc_rx_buffers(ring, IAVF_DESC_UNUSED(ring));
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  	}
  }
  
  /**
 - * iavf_up_complete - Finish the last steps of bringing up a connection
 + * i40evf_up_complete - Finish the last steps of bringing up a connection
   * @adapter: board private structure
   *
 - * Expects to be called while holding the __IAVF_IN_CRITICAL_TASK bit lock.
 + * Expects to be called while holding the __I40EVF_IN_CRITICAL_TASK bit lock.
   **/
 -static void iavf_up_complete(struct iavf_adapter *adapter)
 +static void i40evf_up_complete(struct i40evf_adapter *adapter)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +	adapter->state = __I40EVF_RUNNING;
 +	clear_bit(__I40E_VSI_DOWN, adapter->vsi.state);
++=======
+ 	adapter->state = __IAVF_RUNNING;
+ 	clear_bit(__IAVF_VSI_DOWN, adapter->vsi.state);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  
 -	iavf_napi_enable_all(adapter);
 +	i40evf_napi_enable_all(adapter);
  
 -	adapter->aq_required |= IAVF_FLAG_AQ_ENABLE_QUEUES;
 +	adapter->aq_required |= I40EVF_FLAG_AQ_ENABLE_QUEUES;
  	if (CLIENT_ENABLED(adapter))
 -		adapter->flags |= IAVF_FLAG_CLIENT_NEEDS_OPEN;
 +		adapter->flags |= I40EVF_FLAG_CLIENT_NEEDS_OPEN;
  	mod_timer_pending(&adapter->watchdog_timer, jiffies + 1);
  }
  
  /**
-  * i40e_down - Shutdown the connection processing
+  * iavf_down - Shutdown the connection processing
   * @adapter: board private structure
   *
 - * Expects to be called while holding the __IAVF_IN_CRITICAL_TASK bit lock.
 + * Expects to be called while holding the __I40EVF_IN_CRITICAL_TASK bit lock.
   **/
 -void iavf_down(struct iavf_adapter *adapter)
 +void i40evf_down(struct i40evf_adapter *adapter)
  {
  	struct net_device *netdev = adapter->netdev;
 -	struct iavf_vlan_filter *vlf;
 -	struct iavf_mac_filter *f;
 -	struct iavf_cloud_filter *cf;
 +	struct i40evf_vlan_filter *vlf;
 +	struct i40evf_mac_filter *f;
 +	struct i40evf_cloud_filter *cf;
  
 -	if (adapter->state <= __IAVF_DOWN_PENDING)
 +	if (adapter->state <= __I40EVF_DOWN_PENDING)
  		return;
  
  	netif_carrier_off(netdev);
@@@ -1178,9 -1176,9 +1236,15 @@@ static int i40evf_alloc_queues(struct i
  		tx_ring->netdev = adapter->netdev;
  		tx_ring->dev = &adapter->pdev->dev;
  		tx_ring->count = adapter->tx_desc_count;
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +		tx_ring->itr_setting = I40E_ITR_TX_DEF;
 +		if (adapter->flags & I40EVF_FLAG_WB_ON_ITR_CAPABLE)
 +			tx_ring->flags |= I40E_TXR_FLAGS_WB_ON_ITR;
++=======
+ 		tx_ring->itr_setting = IAVF_ITR_TX_DEF;
+ 		if (adapter->flags & IAVF_FLAG_WB_ON_ITR_CAPABLE)
+ 			tx_ring->flags |= IAVF_TXR_FLAGS_WB_ON_ITR;
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  
  		rx_ring = &adapter->rx_rings[i];
  		rx_ring->queue_index = i;
@@@ -1357,18 -1355,17 +1421,18 @@@ static int i40evf_init_rss(struct i40ev
  		/* Enable PCTYPES for RSS, TCP/UDP with IPv4/IPv6 */
  		if (adapter->vf_res->vf_cap_flags &
  		    VIRTCHNL_VF_OFFLOAD_RSS_PCTYPE_V2)
- 			adapter->hena = I40E_DEFAULT_RSS_HENA_EXPANDED;
+ 			adapter->hena = IAVF_DEFAULT_RSS_HENA_EXPANDED;
  		else
- 			adapter->hena = I40E_DEFAULT_RSS_HENA;
+ 			adapter->hena = IAVF_DEFAULT_RSS_HENA;
  
 -		wr32(hw, IAVF_VFQF_HENA(0), (u32)adapter->hena);
 -		wr32(hw, IAVF_VFQF_HENA(1), (u32)(adapter->hena >> 32));
 +		wr32(hw, I40E_VFQF_HENA(0), (u32)adapter->hena);
 +		wr32(hw, I40E_VFQF_HENA(1), (u32)(adapter->hena >> 32));
  	}
  
 -	iavf_fill_rss_lut(adapter);
 +	i40evf_fill_rss_lut(adapter);
 +
  	netdev_rss_key_fill((void *)adapter->rss_key, adapter->rss_key_size);
 -	ret = iavf_config_rss(adapter);
 +	ret = i40evf_config_rss(adapter);
  
  	return ret;
  }
@@@ -1380,10 -1377,10 +1444,10 @@@
   * We allocate one q_vector per queue interrupt.  If allocation fails we
   * return -ENOMEM.
   **/
 -static int iavf_alloc_q_vectors(struct iavf_adapter *adapter)
 +static int i40evf_alloc_q_vectors(struct i40evf_adapter *adapter)
  {
  	int q_idx = 0, num_q_vectors;
- 	struct i40e_q_vector *q_vector;
+ 	struct iavf_q_vector *q_vector;
  
  	num_q_vectors = adapter->num_msix_vectors - NONQ_VECS;
  	adapter->q_vectors = kcalloc(num_q_vectors, sizeof(*q_vector),
@@@ -1425,7 -1422,8 +1489,12 @@@ static void i40evf_free_q_vectors(struc
  	napi_vectors = adapter->num_active_queues;
  
  	for (q_idx = 0; q_idx < num_q_vectors; q_idx++) {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +		struct i40e_q_vector *q_vector = &adapter->q_vectors[q_idx];
++=======
+ 		struct iavf_q_vector *q_vector = &adapter->q_vectors[q_idx];
+ 
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  		if (q_idx < napi_vectors)
  			netif_napi_del(&q_vector->napi);
  	}
@@@ -1544,14 -1542,14 +1613,14 @@@ static int i40evf_reinit_interrupt_sche
  	if (err)
  		goto err;
  
- 	set_bit(__I40E_VSI_DOWN, adapter->vsi.state);
+ 	set_bit(__IAVF_VSI_DOWN, adapter->vsi.state);
  
 -	iavf_map_rings_to_vectors(adapter);
 +	i40evf_map_rings_to_vectors(adapter);
  
  	if (RSS_AQ(adapter))
 -		adapter->aq_required |= IAVF_FLAG_AQ_CONFIGURE_RSS;
 +		adapter->aq_required |= I40EVF_FLAG_AQ_CONFIGURE_RSS;
  	else
 -		err = iavf_init_rss(adapter);
 +		err = i40evf_init_rss(adapter);
  err:
  	return err;
  }
@@@ -1782,8 -1781,8 +1851,13 @@@ static void i40evf_disable_vf(struct i4
  	 * ndo_open() returning, so we can't assume it means all our open
  	 * tasks have finished, since we're not holding the rtnl_lock here.
  	 */
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +	if (adapter->state == __I40EVF_RUNNING) {
 +		set_bit(__I40E_VSI_DOWN, adapter->vsi.state);
++=======
+ 	if (adapter->state == __IAVF_RUNNING) {
+ 		set_bit(__IAVF_VSI_DOWN, adapter->vsi.state);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  		netif_carrier_off(adapter->netdev);
  		netif_tx_disable(adapter->netdev);
  		adapter->link_up = false;
@@@ -3057,15 -3055,15 +3131,15 @@@ static int i40evf_close(struct net_devi
  				&adapter->crit_section))
  		usleep_range(500, 1000);
  
- 	set_bit(__I40E_VSI_DOWN, adapter->vsi.state);
+ 	set_bit(__IAVF_VSI_DOWN, adapter->vsi.state);
  	if (CLIENT_ENABLED(adapter))
 -		adapter->flags |= IAVF_FLAG_CLIENT_NEEDS_CLOSE;
 +		adapter->flags |= I40EVF_FLAG_CLIENT_NEEDS_CLOSE;
  
 -	iavf_down(adapter);
 -	adapter->state = __IAVF_DOWN_PENDING;
 -	iavf_free_traffic_irqs(adapter);
 +	i40evf_down(adapter);
 +	adapter->state = __I40EVF_DOWN_PENDING;
 +	i40evf_free_traffic_irqs(adapter);
  
 -	clear_bit(__IAVF_IN_CRITICAL_TASK, &adapter->crit_section);
 +	clear_bit(__I40EVF_IN_CRITICAL_TASK, &adapter->crit_section);
  
  	/* We explicitly don't free resources here because the hardware is
  	 * still active and can DMA into memory. Resources are cleared in
@@@ -3420,11 -3417,11 +3494,17 @@@ static void i40evf_init_task(struct wor
  	int err, bufsz;
  
  	switch (adapter->state) {
 -	case __IAVF_STARTUP:
 +	case __I40EVF_STARTUP:
  		/* driver loaded, probe complete */
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +		adapter->flags &= ~I40EVF_FLAG_PF_COMMS_FAILED;
 +		adapter->flags &= ~I40EVF_FLAG_RESET_PENDING;
 +		err = i40e_set_mac_type(hw);
++=======
+ 		adapter->flags &= ~IAVF_FLAG_PF_COMMS_FAILED;
+ 		adapter->flags &= ~IAVF_FLAG_RESET_PENDING;
+ 		err = iavf_set_mac_type(hw);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  		if (err) {
  			dev_err(&pdev->dev, "Failed to set MAC type (%d)\n",
  				err);
@@@ -3529,8 -3526,8 +3609,13 @@@
  	netdev->watchdog_timeo = 5 * HZ;
  
  	/* MTU range: 68 - 9710 */
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +	netdev->extended->min_mtu = ETH_MIN_MTU;
 +	netdev->extended->max_mtu = I40E_MAX_RXBUFFER - I40E_PACKET_HDR_PAD;
++=======
+ 	netdev->min_mtu = ETH_MIN_MTU;
+ 	netdev->max_mtu = IAVF_MAX_RXBUFFER - IAVF_PACKET_HDR_PAD;
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  
  	if (!is_valid_ether_addr(adapter->hw.mac.addr)) {
  		dev_info(&pdev->dev, "Invalid MAC address %pM, using random\n",
@@@ -3584,9 -3580,9 +3669,15 @@@
  	if (netdev->features & NETIF_F_GRO)
  		dev_info(&pdev->dev, "GRO is enabled\n");
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +	adapter->state = __I40EVF_DOWN;
 +	set_bit(__I40E_VSI_DOWN, adapter->vsi.state);
 +	i40evf_misc_irq_enable(adapter);
++=======
+ 	adapter->state = __IAVF_DOWN;
+ 	set_bit(__IAVF_VSI_DOWN, adapter->vsi.state);
+ 	iavf_misc_irq_enable(adapter);
++>>>>>>> 56184e01c00d (iavf: rename most of i40e strings):drivers/net/ethernet/intel/iavf/iavf_main.c
  	wake_up(&adapter->down_waitqueue);
  
  	adapter->rss_key = kzalloc(adapter->rss_key_size, GFP_KERNEL);
@@@ -3971,12 -3967,12 +4062,12 @@@ static struct pci_driver i40evf_driver 
  };
  
  /**
-  * i40e_init_module - Driver Registration Routine
+  * iavf_init_module - Driver Registration Routine
   *
-  * i40e_init_module is the first routine called when the driver is
+  * iavf_init_module is the first routine called when the driver is
   * loaded. All it does is register with the PCI subsystem.
   **/
 -static int __init iavf_init_module(void)
 +static int __init i40evf_init_module(void)
  {
  	int ret;
  
@@@ -3995,20 -3991,20 +4086,20 @@@
  	return ret;
  }
  
 -module_init(iavf_init_module);
 +module_init(i40evf_init_module);
  
  /**
-  * i40e_exit_module - Driver Exit Cleanup Routine
+  * iavf_exit_module - Driver Exit Cleanup Routine
   *
-  * i40e_exit_module is called just before the driver is removed
+  * iavf_exit_module is called just before the driver is removed
   * from memory.
   **/
 -static void __exit iavf_exit_module(void)
 +static void __exit i40evf_exit_module(void)
  {
 -	pci_unregister_driver(&iavf_driver);
 -	destroy_workqueue(iavf_wq);
 +	pci_unregister_driver(&i40evf_driver);
 +	destroy_workqueue(i40evf_wq);
  }
  
 -module_exit(iavf_exit_module);
 +module_exit(i40evf_exit_module);
  
 -/* iavf_main.c */
 +/* i40evf_main.c */
* Unmerged path drivers/net/ethernet/intel/iavf/i40e_adminq_cmd.h
* Unmerged path drivers/net/ethernet/intel/iavf/i40e_prototype.h
* Unmerged path drivers/net/ethernet/intel/iavf/i40e_type.h
* Unmerged path drivers/net/ethernet/intel/iavf/iavf.h
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_adminq.c
diff --git a/drivers/net/ethernet/intel/i40evf/i40e_adminq.h b/drivers/net/ethernet/intel/i40evf/i40e_adminq.h
index 8c3b6e00d5d7..f969e65d7dea 100644
--- a/drivers/net/ethernet/intel/i40evf/i40e_adminq.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_adminq.h
@@ -1,8 +1,8 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /* Copyright(c) 2013 - 2018 Intel Corporation. */
 
-#ifndef _I40E_ADMINQ_H_
-#define _I40E_ADMINQ_H_
+#ifndef _IAVF_ADMINQ_H_
+#define _IAVF_ADMINQ_H_
 
 #include "i40e_osdep.h"
 #include "i40e_status.h"
@@ -13,14 +13,14 @@
 
 #define IAVF_ADMINQ_DESC_ALIGNMENT 4096
 
-struct i40e_adminq_ring {
-	struct i40e_virt_mem dma_head;	/* space for dma structures */
-	struct i40e_dma_mem desc_buf;	/* descriptor ring memory */
-	struct i40e_virt_mem cmd_buf;	/* command buffer memory */
+struct iavf_adminq_ring {
+	struct iavf_virt_mem dma_head;	/* space for dma structures */
+	struct iavf_dma_mem desc_buf;	/* descriptor ring memory */
+	struct iavf_virt_mem cmd_buf;	/* command buffer memory */
 
 	union {
-		struct i40e_dma_mem *asq_bi;
-		struct i40e_dma_mem *arq_bi;
+		struct iavf_dma_mem *asq_bi;
+		struct iavf_dma_mem *arq_bi;
 	} r;
 
 	u16 count;		/* Number of descriptors */
@@ -61,9 +61,9 @@ struct i40e_arq_event_info {
 };
 
 /* Admin Queue information */
-struct i40e_adminq_info {
-	struct i40e_adminq_ring arq;    /* receive queue */
-	struct i40e_adminq_ring asq;    /* send queue */
+struct iavf_adminq_info {
+	struct iavf_adminq_ring arq;    /* receive queue */
+	struct iavf_adminq_ring asq;    /* send queue */
 	u32 asq_cmd_timeout;            /* send queue cmd write back timeout*/
 	u16 num_arq_entries;            /* receive queue depth */
 	u16 num_asq_entries;            /* send queue depth */
@@ -133,4 +133,4 @@ static inline int i40e_aq_rc_to_posix(int aq_ret, int aq_rc)
 void i40evf_fill_default_direct_cmd_desc(struct i40e_aq_desc *desc,
 				       u16 opcode);
 
-#endif /* _I40E_ADMINQ_H_ */
+#endif /* _IAVF_ADMINQ_H_ */
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_alloc.h
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_common.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_osdep.h
diff --git a/drivers/net/ethernet/intel/i40evf/i40e_status.h b/drivers/net/ethernet/intel/i40evf/i40e_status.h
index 77be0702d07c..46742fab7b8c 100644
--- a/drivers/net/ethernet/intel/i40evf/i40e_status.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_status.h
@@ -1,11 +1,11 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /* Copyright(c) 2013 - 2018 Intel Corporation. */
 
-#ifndef _I40E_STATUS_H_
-#define _I40E_STATUS_H_
+#ifndef _IAVF_STATUS_H_
+#define _IAVF_STATUS_H_
 
 /* Error Codes */
-enum i40e_status_code {
+enum iavf_status_code {
 	I40E_SUCCESS				= 0,
 	I40E_ERR_NVM				= -1,
 	I40E_ERR_NVM_CHECKSUM			= -2,
@@ -75,4 +75,4 @@ enum i40e_status_code {
 	I40E_ERR_ADMIN_QUEUE_CRITICAL_ERROR	= -66,
 };
 
-#endif /* _I40E_STATUS_H_ */
+#endif /* _IAVF_STATUS_H_ */
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_trace.h
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_txrx.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_txrx.h
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_client.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_main.c
diff --git a/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c b/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
index 6579dabab78c..ec20a533a396 100644
--- a/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
@@ -197,7 +197,7 @@ int i40evf_get_vf_config(struct i40evf_adapter *adapter)
 	u16 len;
 
 	len =  sizeof(struct virtchnl_vf_resource) +
-		I40E_MAX_VF_VSI * sizeof(struct virtchnl_vsi_resource);
+		IAVF_MAX_VF_VSI * sizeof(struct virtchnl_vsi_resource);
 	event.buf_len = len;
 	event.msg_buf = kzalloc(event.buf_len, GFP_KERNEL);
 	if (!event.msg_buf) {
@@ -244,7 +244,7 @@ void i40evf_configure_queues(struct i40evf_adapter *adapter)
 	struct virtchnl_vsi_queue_config_info *vqci;
 	struct virtchnl_queue_pair_info *vqpi;
 	int pairs = adapter->num_active_queues;
-	int i, len, max_frame = I40E_MAX_RXBUFFER;
+	int i, len, max_frame = IAVF_MAX_RXBUFFER;
 
 	if (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {
 		/* bail because we already have a command pending */
@@ -262,7 +262,7 @@ void i40evf_configure_queues(struct i40evf_adapter *adapter)
 	/* Limit maximum frame size when jumbo frames is not enabled */
 	if (!(adapter->flags & I40EVF_FLAG_LEGACY_RX) &&
 	    (adapter->netdev->mtu <= ETH_DATA_LEN))
-		max_frame = I40E_RXBUFFER_1536 - NET_IP_ALIGN;
+		max_frame = IAVF_RXBUFFER_1536 - NET_IP_ALIGN;
 
 	vqci->vsi_id = adapter->vsi_res->vsi_id;
 	vqci->num_queue_pairs = pairs;
@@ -282,7 +282,7 @@ void i40evf_configure_queues(struct i40evf_adapter *adapter)
 		vqpi->rxq.max_pkt_size = max_frame;
 		vqpi->rxq.databuffer_size =
 			ALIGN(adapter->rx_rings[i].rx_buf_len,
-			      BIT_ULL(I40E_RXQ_CTX_DBUFF_SHIFT));
+			      BIT_ULL(IAVF_RXQ_CTX_DBUFF_SHIFT));
 		vqpi++;
 	}
 
@@ -354,7 +354,7 @@ void i40evf_map_queues(struct i40evf_adapter *adapter)
 	struct virtchnl_irq_map_info *vimi;
 	struct virtchnl_vector_map *vecmap;
 	int v_idx, q_vectors, len;
-	struct i40e_q_vector *q_vector;
+	struct iavf_q_vector *q_vector;
 
 	if (adapter->current_op != VIRTCHNL_OP_UNKNOWN) {
 		/* bail because we already have a command pending */
@@ -383,8 +383,8 @@ void i40evf_map_queues(struct i40evf_adapter *adapter)
 		vecmap->vector_id = v_idx + NONQ_VECS;
 		vecmap->txq_map = q_vector->ring_mask;
 		vecmap->rxq_map = q_vector->ring_mask;
-		vecmap->rxitr_idx = I40E_RX_ITR;
-		vecmap->txitr_idx = I40E_TX_ITR;
+		vecmap->rxitr_idx = IAVF_RX_ITR;
+		vecmap->txitr_idx = IAVF_TX_ITR;
 	}
 	/* Misc vector last - this is only for AdminQ messages */
 	vecmap = &vimi->vecmap[v_idx];
@@ -1339,8 +1339,8 @@ void i40evf_virtchnl_completion(struct i40evf_adapter *adapter,
 	}
 	switch (v_opcode) {
 	case VIRTCHNL_OP_GET_STATS: {
-		struct i40e_eth_stats *stats =
-			(struct i40e_eth_stats *)msg;
+		struct iavf_eth_stats *stats =
+			(struct iavf_eth_stats *)msg;
 		netdev->stats.rx_packets = stats->rx_unicast +
 					   stats->rx_multicast +
 					   stats->rx_broadcast;
@@ -1357,7 +1357,7 @@ void i40evf_virtchnl_completion(struct i40evf_adapter *adapter,
 		break;
 	case VIRTCHNL_OP_GET_VF_RESOURCES: {
 		u16 len = sizeof(struct virtchnl_vf_resource) +
-			  I40E_MAX_VF_VSI *
+			  IAVF_MAX_VF_VSI *
 			  sizeof(struct virtchnl_vsi_resource);
 		memcpy(adapter->vf_res, msg, min(msglen, len));
 		i40evf_validate_num_queues(adapter);
* Unmerged path drivers/net/ethernet/intel/iavf/i40e_adminq_cmd.h
* Unmerged path drivers/net/ethernet/intel/iavf/i40e_prototype.h
* Unmerged path drivers/net/ethernet/intel/iavf/i40e_type.h
* Unmerged path drivers/net/ethernet/intel/iavf/iavf.h
