efi: Make efi_rts_work accessible to efi page fault handler

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Sai Praneeth <sai.praneeth.prakhya@intel.com>
commit 9dbbedaa6171247c4c7c40b83f05b200a117c2e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9dbbedaa.failed

After the kernel has booted, if any accesses by firmware causes a page
fault, the efi page fault handler would freeze efi_rts_wq and schedules
a new process. To do this, the efi page fault handler needs
efi_rts_work. Hence, make it accessible.

There will be no race conditions in accessing this structure, because
all the calls to efi runtime services are already serialized.

	Tested-by: Bhupesh Sharma <bhsharma@redhat.com>
	Suggested-by: Matt Fleming <matt@codeblueprint.co.uk>
Based-on-code-from: Ricardo Neri <ricardo.neri@intel.com>
	Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
	Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
(cherry picked from commit 9dbbedaa6171247c4c7c40b83f05b200a117c2e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/runtime-wrappers.c
#	include/linux/efi.h
diff --cc drivers/firmware/efi/runtime-wrappers.c
index dcc976822484,b18b2d864c2c..000000000000
--- a/drivers/firmware/efi/runtime-wrappers.c
+++ b/drivers/firmware/efi/runtime-wrappers.c
@@@ -27,6 -45,43 +27,46 @@@
  #define __efi_call_virt(f, args...) \
  	__efi_call_virt_pointer(efi.systab->runtime, f, args)
  
++<<<<<<< HEAD
++=======
+ struct efi_runtime_work efi_rts_work;
+ 
+ /*
+  * efi_queue_work:	Queue efi_runtime_service() and wait until it's done
+  * @rts:		efi_runtime_service() function identifier
+  * @rts_arg<1-5>:	efi_runtime_service() function arguments
+  *
+  * Accesses to efi_runtime_services() are serialized by a binary
+  * semaphore (efi_runtime_lock) and caller waits until the work is
+  * finished, hence _only_ one work is queued at a time and the caller
+  * thread waits for completion.
+  */
+ #define efi_queue_work(_rts, _arg1, _arg2, _arg3, _arg4, _arg5)		\
+ ({									\
+ 	efi_rts_work.status = EFI_ABORTED;				\
+ 									\
+ 	init_completion(&efi_rts_work.efi_rts_comp);			\
+ 	INIT_WORK_ONSTACK(&efi_rts_work.work, efi_call_rts);		\
+ 	efi_rts_work.arg1 = _arg1;					\
+ 	efi_rts_work.arg2 = _arg2;					\
+ 	efi_rts_work.arg3 = _arg3;					\
+ 	efi_rts_work.arg4 = _arg4;					\
+ 	efi_rts_work.arg5 = _arg5;					\
+ 	efi_rts_work.efi_rts_id = _rts;					\
+ 									\
+ 	/*								\
+ 	 * queue_work() returns 0 if work was already on queue,         \
+ 	 * _ideally_ this should never happen.                          \
+ 	 */								\
+ 	if (queue_work(efi_rts_wq, &efi_rts_work.work))			\
+ 		wait_for_completion(&efi_rts_work.efi_rts_comp);	\
+ 	else								\
+ 		pr_err("Failed to queue work to efi_rts_wq.\n");	\
+ 									\
+ 	efi_rts_work.status;						\
+ })
+ 
++>>>>>>> 9dbbedaa6171 (efi: Make efi_rts_work accessible to efi page fault handler)
  void efi_call_virt_check_flags(unsigned long flags, const char *call)
  {
  	unsigned long cur_flags, mismatch;
@@@ -43,12 -98,129 +83,99 @@@
  	local_irq_restore(flags);
  }
  
 -/*
 - * According to section 7.1 of the UEFI spec, Runtime Services are not fully
 - * reentrant, and there are particular combinations of calls that need to be
 - * serialized. (source: UEFI Specification v2.4A)
 - *
 - * Table 31. Rules for Reentry Into Runtime Services
 - * +------------------------------------+-------------------------------+
 - * | If previous call is busy in	| Forbidden to call		|
 - * +------------------------------------+-------------------------------+
 - * | Any				| SetVirtualAddressMap()	|
 - * +------------------------------------+-------------------------------+
 - * | ConvertPointer()			| ConvertPointer()		|
 - * +------------------------------------+-------------------------------+
 - * | SetVariable()			| ResetSystem()			|
 - * | UpdateCapsule()			|				|
 - * | SetTime()				|				|
 - * | SetWakeupTime()			|				|
 - * | GetNextHighMonotonicCount()	|				|
 - * +------------------------------------+-------------------------------+
 - * | GetVariable()			| GetVariable()			|
 - * | GetNextVariableName()		| GetNextVariableName()		|
 - * | SetVariable()			| SetVariable()			|
 - * | QueryVariableInfo()		| QueryVariableInfo()		|
 - * | UpdateCapsule()			| UpdateCapsule()		|
 - * | QueryCapsuleCapabilities()		| QueryCapsuleCapabilities()	|
 - * | GetNextHighMonotonicCount()	| GetNextHighMonotonicCount()	|
 - * +------------------------------------+-------------------------------+
 - * | GetTime()				| GetTime()			|
 - * | SetTime()				| SetTime()			|
 - * | GetWakeupTime()			| GetWakeupTime()		|
 - * | SetWakeupTime()			| SetWakeupTime()		|
 - * +------------------------------------+-------------------------------+
 - *
 - * Due to the fact that the EFI pstore may write to the variable store in
 - * interrupt context, we need to use a lock for at least the groups that
 - * contain SetVariable() and QueryVariableInfo(). That leaves little else, as
 - * none of the remaining functions are actually ever called at runtime.
 - * So let's just use a single lock to serialize all Runtime Services calls.
 +/* As per commit ef68c8f87ed1 ("x86: Serialize EFI time accesses on rtc_lock"),
 + * the EFI specification requires that callers of the time related runtime
 + * functions serialize with other CMOS accesses in the kernel, as the EFI time
 + * functions may choose to also use the legacy CMOS RTC.
   */
++<<<<<<< HEAD
 +__weak DEFINE_SPINLOCK(rtc_lock);
++=======
+ static DEFINE_SEMAPHORE(efi_runtime_lock);
+ 
+ /*
+  * Calls the appropriate efi_runtime_service() with the appropriate
+  * arguments.
+  *
+  * Semantics followed by efi_call_rts() to understand efi_runtime_work:
+  * 1. If argument was a pointer, recast it from void pointer to original
+  * pointer type.
+  * 2. If argument was a value, recast it from void pointer to original
+  * pointer type and dereference it.
+  */
+ static void efi_call_rts(struct work_struct *work)
+ {
+ 	void *arg1, *arg2, *arg3, *arg4, *arg5;
+ 	efi_status_t status = EFI_NOT_FOUND;
+ 
+ 	arg1 = efi_rts_work.arg1;
+ 	arg2 = efi_rts_work.arg2;
+ 	arg3 = efi_rts_work.arg3;
+ 	arg4 = efi_rts_work.arg4;
+ 	arg5 = efi_rts_work.arg5;
+ 
+ 	switch (efi_rts_work.efi_rts_id) {
+ 	case GET_TIME:
+ 		status = efi_call_virt(get_time, (efi_time_t *)arg1,
+ 				       (efi_time_cap_t *)arg2);
+ 		break;
+ 	case SET_TIME:
+ 		status = efi_call_virt(set_time, (efi_time_t *)arg1);
+ 		break;
+ 	case GET_WAKEUP_TIME:
+ 		status = efi_call_virt(get_wakeup_time, (efi_bool_t *)arg1,
+ 				       (efi_bool_t *)arg2, (efi_time_t *)arg3);
+ 		break;
+ 	case SET_WAKEUP_TIME:
+ 		status = efi_call_virt(set_wakeup_time, *(efi_bool_t *)arg1,
+ 				       (efi_time_t *)arg2);
+ 		break;
+ 	case GET_VARIABLE:
+ 		status = efi_call_virt(get_variable, (efi_char16_t *)arg1,
+ 				       (efi_guid_t *)arg2, (u32 *)arg3,
+ 				       (unsigned long *)arg4, (void *)arg5);
+ 		break;
+ 	case GET_NEXT_VARIABLE:
+ 		status = efi_call_virt(get_next_variable, (unsigned long *)arg1,
+ 				       (efi_char16_t *)arg2,
+ 				       (efi_guid_t *)arg3);
+ 		break;
+ 	case SET_VARIABLE:
+ 		status = efi_call_virt(set_variable, (efi_char16_t *)arg1,
+ 				       (efi_guid_t *)arg2, *(u32 *)arg3,
+ 				       *(unsigned long *)arg4, (void *)arg5);
+ 		break;
+ 	case QUERY_VARIABLE_INFO:
+ 		status = efi_call_virt(query_variable_info, *(u32 *)arg1,
+ 				       (u64 *)arg2, (u64 *)arg3, (u64 *)arg4);
+ 		break;
+ 	case GET_NEXT_HIGH_MONO_COUNT:
+ 		status = efi_call_virt(get_next_high_mono_count, (u32 *)arg1);
+ 		break;
+ 	case UPDATE_CAPSULE:
+ 		status = efi_call_virt(update_capsule,
+ 				       (efi_capsule_header_t **)arg1,
+ 				       *(unsigned long *)arg2,
+ 				       *(unsigned long *)arg3);
+ 		break;
+ 	case QUERY_CAPSULE_CAPS:
+ 		status = efi_call_virt(query_capsule_caps,
+ 				       (efi_capsule_header_t **)arg1,
+ 				       *(unsigned long *)arg2, (u64 *)arg3,
+ 				       (int *)arg4);
+ 		break;
+ 	default:
+ 		/*
+ 		 * Ideally, we should never reach here because a caller of this
+ 		 * function should have put the right efi_runtime_service()
+ 		 * function identifier into efi_rts_work->efi_rts_id
+ 		 */
+ 		pr_err("Requested executing invalid EFI Runtime Service.\n");
+ 	}
+ 	efi_rts_work.status = status;
+ 	complete(&efi_rts_work.efi_rts_comp);
+ }
++>>>>>>> 9dbbedaa6171 (efi: Make efi_rts_work accessible to efi page fault handler)
  
  static efi_status_t virt_efi_get_time(efi_time_t *tm, efi_time_cap_t *tc)
  {
diff --cc include/linux/efi.h
index ce99ad24fa74,a929d2bf41fa..000000000000
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@@ -1334,7 -1633,78 +1334,81 @@@ extern void efi_call_virt_check_flags(u
  	arch_efi_call_virt(p, f, args);					\
  	efi_call_virt_check_flags(__flags, __stringify(f));		\
  									\
 -	arch_efi_call_virt_teardown();					\
 +	arch_efi_call_virt_teardown(ibrs_on);				\
  })
  
++<<<<<<< HEAD
++=======
+ typedef efi_status_t (*efi_exit_boot_map_processing)(
+ 	efi_system_table_t *sys_table_arg,
+ 	struct efi_boot_memmap *map,
+ 	void *priv);
+ 
+ efi_status_t efi_exit_boot_services(efi_system_table_t *sys_table,
+ 				    void *handle,
+ 				    struct efi_boot_memmap *map,
+ 				    void *priv,
+ 				    efi_exit_boot_map_processing priv_func);
+ 
+ #define EFI_RANDOM_SEED_SIZE		64U
+ 
+ struct linux_efi_random_seed {
+ 	u32	size;
+ 	u8	bits[];
+ };
+ 
+ struct linux_efi_tpm_eventlog {
+ 	u32	size;
+ 	u8	version;
+ 	u8	log[];
+ };
+ 
+ extern int efi_tpm_eventlog_init(void);
+ 
+ /* efi_runtime_service() function identifiers */
+ enum efi_rts_ids {
+ 	GET_TIME,
+ 	SET_TIME,
+ 	GET_WAKEUP_TIME,
+ 	SET_WAKEUP_TIME,
+ 	GET_VARIABLE,
+ 	GET_NEXT_VARIABLE,
+ 	SET_VARIABLE,
+ 	QUERY_VARIABLE_INFO,
+ 	GET_NEXT_HIGH_MONO_COUNT,
+ 	UPDATE_CAPSULE,
+ 	QUERY_CAPSULE_CAPS,
+ };
+ 
+ /*
+  * efi_runtime_work:	Details of EFI Runtime Service work
+  * @arg<1-5>:		EFI Runtime Service function arguments
+  * @status:		Status of executing EFI Runtime Service
+  * @efi_rts_id:		EFI Runtime Service function identifier
+  * @efi_rts_comp:	Struct used for handling completions
+  */
+ struct efi_runtime_work {
+ 	void *arg1;
+ 	void *arg2;
+ 	void *arg3;
+ 	void *arg4;
+ 	void *arg5;
+ 	efi_status_t status;
+ 	struct work_struct work;
+ 	enum efi_rts_ids efi_rts_id;
+ 	struct completion efi_rts_comp;
+ };
+ 
+ extern struct efi_runtime_work efi_rts_work;
+ 
+ /* Workqueue to queue EFI Runtime Services */
+ extern struct workqueue_struct *efi_rts_wq;
+ 
+ struct linux_efi_memreserve {
+ 	phys_addr_t	next;
+ 	phys_addr_t	base;
+ 	phys_addr_t	size;
+ };
+ 
++>>>>>>> 9dbbedaa6171 (efi: Make efi_rts_work accessible to efi page fault handler)
  #endif /* _LINUX_EFI_H */
* Unmerged path drivers/firmware/efi/runtime-wrappers.c
* Unmerged path include/linux/efi.h
