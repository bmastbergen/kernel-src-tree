RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jason Gunthorpe <jgg@mellanox.com>
commit 15a1b4becba886176aa1426604548c34904fd054
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/15a1b4be.failed

The uverbs_attr_bundle already contains this pointer, and most methods
don't actually need it. Get rid of the redundant function argument.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit 15a1b4becba886176aa1426604548c34904fd054)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/rdma_core.h
#	drivers/infiniband/core/uverbs_ioctl.c
#	drivers/infiniband/core/uverbs_std_types.c
#	drivers/infiniband/core/uverbs_std_types_counters.c
#	drivers/infiniband/core/uverbs_std_types_cq.c
#	drivers/infiniband/core/uverbs_std_types_dm.c
#	drivers/infiniband/core/uverbs_std_types_flow_action.c
#	drivers/infiniband/core/uverbs_std_types_mr.c
#	drivers/infiniband/hw/mlx5/devx.c
#	drivers/infiniband/hw/mlx5/flow.c
#	include/rdma/ib_verbs.h
#	include/rdma/uverbs_ioctl.h
diff --cc drivers/infiniband/core/rdma_core.h
index a243cc2a59f7,ce323439a0f9..000000000000
--- a/drivers/infiniband/core/rdma_core.h
+++ b/drivers/infiniband/core/rdma_core.h
@@@ -113,4 -106,101 +113,104 @@@ int uverbs_finalize_object(struct ib_uo
  			   enum uverbs_obj_access access,
  			   bool commit);
  
++<<<<<<< HEAD
++=======
+ void setup_ufile_idr_uobject(struct ib_uverbs_file *ufile);
+ void release_ufile_idr_uobject(struct ib_uverbs_file *ufile);
+ 
+ /*
+  * This is the runtime description of the uverbs API, used by the syscall
+  * machinery to validate and dispatch calls.
+  */
+ 
+ /*
+  * Depending on ID the slot pointer in the radix tree points at one of these
+  * structs.
+  */
+ struct uverbs_api_object {
+ 	const struct uverbs_obj_type *type_attrs;
+ 	const struct uverbs_obj_type_class *type_class;
+ 	u8 disabled:1;
+ };
+ 
+ struct uverbs_api_ioctl_method {
+ 	int(__rcu *handler)(struct uverbs_attr_bundle *attrs);
+ 	DECLARE_BITMAP(attr_mandatory, UVERBS_API_ATTR_BKEY_LEN);
+ 	u16 bundle_size;
+ 	u8 use_stack:1;
+ 	u8 driver_method:1;
+ 	u8 disabled:1;
+ 	u8 key_bitmap_len;
+ 	u8 destroy_bkey;
+ };
+ 
+ struct uverbs_api_write_method {
+ 	int (*handler)(struct uverbs_attr_bundle *attrs, const char __user *buf,
+ 		       int in_len, int out_len);
+ 	int (*handler_ex)(struct uverbs_attr_bundle *attrs,
+ 			  struct ib_udata *ucore, struct ib_udata *uhw);
+ 	u8 disabled:1;
+ 	u8 is_ex:1;
+ };
+ 
+ struct uverbs_api_attr {
+ 	struct uverbs_attr_spec spec;
+ };
+ 
+ struct uverbs_api {
+ 	/* radix tree contains struct uverbs_api_* pointers */
+ 	struct radix_tree_root radix;
+ 	enum rdma_driver_id driver_id;
+ 
+ 	unsigned int num_write;
+ 	unsigned int num_write_ex;
+ 	struct uverbs_api_write_method notsupp_method;
+ 	const struct uverbs_api_write_method **write_methods;
+ 	const struct uverbs_api_write_method **write_ex_methods;
+ };
+ 
+ static inline const struct uverbs_api_object *
+ uapi_get_object(struct uverbs_api *uapi, u16 object_id)
+ {
+ 	return radix_tree_lookup(&uapi->radix, uapi_key_obj(object_id));
+ }
+ 
+ char *uapi_key_format(char *S, unsigned int key);
+ struct uverbs_api *uverbs_alloc_api(struct ib_device *ibdev);
+ void uverbs_disassociate_api_pre(struct ib_uverbs_device *uverbs_dev);
+ void uverbs_disassociate_api(struct uverbs_api *uapi);
+ void uverbs_destroy_api(struct uverbs_api *uapi);
+ void uapi_compute_bundle_size(struct uverbs_api_ioctl_method *method_elm,
+ 			      unsigned int num_attrs);
+ void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile);
+ 
+ extern const struct uapi_definition uverbs_def_obj_counters[];
+ extern const struct uapi_definition uverbs_def_obj_cq[];
+ extern const struct uapi_definition uverbs_def_obj_dm[];
+ extern const struct uapi_definition uverbs_def_obj_flow_action[];
+ extern const struct uapi_definition uverbs_def_obj_intf[];
+ extern const struct uapi_definition uverbs_def_obj_mr[];
+ extern const struct uapi_definition uverbs_def_write_intf[];
+ 
+ static inline const struct uverbs_api_write_method *
+ uapi_get_method(const struct uverbs_api *uapi, u32 command)
+ {
+ 	u32 cmd_idx = command & IB_USER_VERBS_CMD_COMMAND_MASK;
+ 
+ 	if (command & ~(u32)(IB_USER_VERBS_CMD_FLAG_EXTENDED |
+ 			     IB_USER_VERBS_CMD_COMMAND_MASK))
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	if (command & IB_USER_VERBS_CMD_FLAG_EXTENDED) {
+ 		if (cmd_idx >= uapi->num_write_ex)
+ 			return ERR_PTR(-EOPNOTSUPP);
+ 		return uapi->write_ex_methods[cmd_idx];
+ 	}
+ 
+ 	if (cmd_idx >= uapi->num_write)
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 	return uapi->write_methods[cmd_idx];
+ }
+ 
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  #endif /* RDMA_CORE_H */
diff --cc drivers/infiniband/core/uverbs_ioctl.c
index ec7b453e622b,5c04149ce775..000000000000
--- a/drivers/infiniband/core/uverbs_ioctl.c
+++ b/drivers/infiniband/core/uverbs_ioctl.c
@@@ -165,303 -339,408 +165,368 @@@ static int uverbs_process_attr(struct i
  	return 0;
  }
  
 -/*
 - * We search the radix tree with the method prefix and now we want to fast
 - * search the suffix bits to get a particular attribute pointer. It is not
 - * totally clear to me if this breaks the radix tree encasulation or not, but
 - * it uses the iter data to determine if the method iter points at the same
 - * chunk that will store the attribute, if so it just derefs it directly. By
 - * construction in most kernel configs the method and attrs will all fit in a
 - * single radix chunk, so in most cases this will have no search. Other cases
 - * this falls back to a full search.
 - */
 -static void __rcu **uapi_get_attr_for_method(struct bundle_priv *pbundle,
 -					     u32 attr_key)
 +static int uverbs_finalize_attrs(struct uverbs_attr_bundle *attrs_bundle,
 +				 struct uverbs_attr_spec_hash *const *spec_hash,
 +				 size_t num, bool commit)
  {
++<<<<<<< HEAD
++=======
+ 	void __rcu **slot;
+ 
+ 	if (likely(attr_key < pbundle->radix_slots_len)) {
+ 		void *entry;
+ 
+ 		slot = pbundle->radix_slots + attr_key;
+ 		entry = rcu_dereference_raw(*slot);
+ 		if (likely(!radix_tree_is_internal_node(entry) && entry))
+ 			return slot;
+ 	}
+ 
+ 	return radix_tree_lookup_slot(pbundle->radix,
+ 				      pbundle->method_key | attr_key);
+ }
+ 
+ static int uverbs_set_attr(struct bundle_priv *pbundle,
+ 			   struct ib_uverbs_attr *uattr)
+ {
+ 	u32 attr_key = uapi_key_attr(uattr->attr_id);
+ 	u32 attr_bkey = uapi_bkey_attr(attr_key);
+ 	const struct uverbs_api_attr *attr;
+ 	void __rcu **slot;
+ 	int ret;
+ 
+ 	slot = uapi_get_attr_for_method(pbundle, attr_key);
+ 	if (!slot) {
+ 		/*
+ 		 * Kernel does not support the attribute but user-space says it
+ 		 * is mandatory
+ 		 */
+ 		if (uattr->flags & UVERBS_ATTR_F_MANDATORY)
+ 			return -EPROTONOSUPPORT;
+ 		return 0;
+ 	}
+ 	attr = rcu_dereference_protected(*slot, true);
+ 
+ 	/* Reject duplicate attributes from user-space */
+ 	if (test_bit(attr_bkey, pbundle->bundle.attr_present))
+ 		return -EINVAL;
+ 
+ 	ret = uverbs_process_attr(pbundle, attr, uattr, attr_bkey);
+ 	if (ret)
+ 		return ret;
+ 
+ 	__set_bit(attr_bkey, pbundle->bundle.attr_present);
+ 
+ 	return 0;
+ }
+ 
+ static int ib_uverbs_run_method(struct bundle_priv *pbundle,
+ 				unsigned int num_attrs)
+ {
+ 	int (*handler)(struct uverbs_attr_bundle *attrs);
+ 	size_t uattrs_size = array_size(sizeof(*pbundle->uattrs), num_attrs);
+ 	unsigned int destroy_bkey = pbundle->method_elm->destroy_bkey;
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  	unsigned int i;
 -	int ret;
 +	int ret = 0;
  
 -	/* See uverbs_disassociate_api() */
 -	handler = srcu_dereference(
 -		pbundle->method_elm->handler,
 -		&pbundle->bundle.ufile->device->disassociate_srcu);
 -	if (!handler)
 -		return -EIO;
 -
 -	pbundle->uattrs = uverbs_alloc(&pbundle->bundle, uattrs_size);
 -	if (IS_ERR(pbundle->uattrs))
 -		return PTR_ERR(pbundle->uattrs);
 -	if (copy_from_user(pbundle->uattrs, pbundle->user_attrs, uattrs_size))
 -		return -EFAULT;
 -
 -	for (i = 0; i != num_attrs; i++) {
 -		ret = uverbs_set_attr(pbundle, &pbundle->uattrs[i]);
 -		if (unlikely(ret))
 -			return ret;
 -	}
 +	for (i = 0; i < num; i++) {
 +		struct uverbs_attr_bundle_hash *curr_bundle =
 +			&attrs_bundle->hash[i];
 +		const struct uverbs_attr_spec_hash *curr_spec_bucket =
 +			spec_hash[i];
 +		unsigned int j;
  
 -	/* User space did not provide all the mandatory attributes */
 -	if (unlikely(!bitmap_subset(pbundle->method_elm->attr_mandatory,
 -				    pbundle->bundle.attr_present,
 -				    pbundle->method_elm->key_bitmap_len)))
 -		return -EINVAL;
 +		if (!curr_spec_bucket)
 +			continue;
  
 -	if (destroy_bkey != UVERBS_API_ATTR_BKEY_LEN) {
 -		struct uverbs_obj_attr *destroy_attr =
 -			&pbundle->bundle.attrs[destroy_bkey].obj_attr;
 +		for (j = 0; j < curr_bundle->num_attrs; j++) {
 +			struct uverbs_attr *attr;
 +			const struct uverbs_attr_spec *spec;
  
 -		ret = uobj_destroy(destroy_attr->uobject);
 -		if (ret)
 -			return ret;
 -		__clear_bit(destroy_bkey, pbundle->uobj_finalize);
 +			if (!uverbs_attr_is_valid_in_hash(curr_bundle, j))
 +				continue;
  
 -		ret = handler(&pbundle->bundle);
 -		uobj_put_destroy(destroy_attr->uobject);
 -	} else {
 -		ret = handler(&pbundle->bundle);
 -	}
 +			attr = &curr_bundle->attrs[j];
 +			spec = &curr_spec_bucket->attrs[j];
  
 -	/*
 -	 * EPROTONOSUPPORT is ONLY to be returned if the ioctl framework can
 -	 * not invoke the method because the request is not supported.  No
 -	 * other cases should return this code.
 -	 */
 -	if (WARN_ON_ONCE(ret == -EPROTONOSUPPORT))
 -		return -EINVAL;
 +			if (spec->type == UVERBS_ATTR_TYPE_IDR ||
 +			    spec->type == UVERBS_ATTR_TYPE_FD) {
 +				int current_ret;
  
 +				current_ret = uverbs_finalize_object(
 +					attr->obj_attr.uobject,
 +					spec->obj.access, commit);
 +				if (!ret)
 +					ret = current_ret;
 +			}
 +		}
 +	}
  	return ret;
  }
  
 -static int bundle_destroy(struct bundle_priv *pbundle, bool commit)
 +static int uverbs_uattrs_process(struct ib_device *ibdev,
 +				 struct ib_ucontext *ucontext,
 +				 const struct ib_uverbs_attr *uattrs,
 +				 size_t num_uattrs,
 +				 const struct uverbs_method_spec *method,
 +				 struct uverbs_attr_bundle *attr_bundle,
 +				 struct ib_uverbs_attr __user *uattr_ptr)
  {
 -	unsigned int key_bitmap_len = pbundle->method_elm->key_bitmap_len;
 -	struct bundle_alloc_head *memblock;
 -	unsigned int i;
 +	size_t i;
  	int ret = 0;
 +	int num_given_buckets = 0;
 +
 +	for (i = 0; i < num_uattrs; i++) {
 +		const struct ib_uverbs_attr *uattr = &uattrs[i];
 +		u16 attr_id = uattr->attr_id;
 +		struct uverbs_attr_spec_hash *attr_spec_bucket;
 +
 +		ret = uverbs_ns_idx(&attr_id, method->num_buckets);
 +		if (ret < 0 || !method->attr_buckets[ret]) {
 +			if (uattr->flags & UVERBS_ATTR_F_MANDATORY) {
 +				uverbs_finalize_attrs(attr_bundle,
 +						      method->attr_buckets,
 +						      num_given_buckets,
 +						      false);
 +				return ret;
 +			}
 +			continue;
 +		}
  
 -	/* fast path for simple uobjects */
 -	i = -1;
 -	while ((i = find_next_bit(pbundle->uobj_finalize, key_bitmap_len,
 -				  i + 1)) < key_bitmap_len) {
 -		struct uverbs_attr *attr = &pbundle->bundle.attrs[i];
 -		int current_ret;
 -
 -		current_ret = uverbs_finalize_object(
 -			attr->obj_attr.uobject,
 -			attr->obj_attr.attr_elm->spec.u.obj.access, commit);
 -		if (!ret)
 -			ret = current_ret;
 +		/*
 +		 * ret is the found ns, so increase num_given_buckets if
 +		 * necessary.
 +		 */
 +		if (ret >= num_given_buckets)
 +			num_given_buckets = ret + 1;
 +
 +		attr_spec_bucket = method->attr_buckets[ret];
 +		ret = uverbs_process_attr(ibdev, ucontext, uattr, attr_id,
 +					  attr_spec_bucket, &attr_bundle->hash[ret],
 +					  uattr_ptr++);
 +		if (ret) {
 +			uverbs_finalize_attrs(attr_bundle,
 +					      method->attr_buckets,
 +					      num_given_buckets,
 +					      false);
 +			return ret;
 +		}
  	}
  
 -	i = -1;
 -	while ((i = find_next_bit(pbundle->spec_finalize, key_bitmap_len,
 -				  i + 1)) < key_bitmap_len) {
 -		struct uverbs_attr *attr = &pbundle->bundle.attrs[i];
 -		const struct uverbs_api_attr *attr_uapi;
 -		void __rcu **slot;
 -		int current_ret;
 -
 -		slot = uapi_get_attr_for_method(
 -			pbundle,
 -			pbundle->method_key | uapi_bkey_to_key_attr(i));
 -		if (WARN_ON(!slot))
 -			continue;
 +	return num_given_buckets;
 +}
  
 -		attr_uapi = rcu_dereference_protected(*slot, true);
 +static int uverbs_validate_kernel_mandatory(const struct uverbs_method_spec *method_spec,
 +					    struct uverbs_attr_bundle *attr_bundle)
 +{
 +	unsigned int i;
  
 -		if (attr_uapi->spec.type == UVERBS_ATTR_TYPE_IDRS_ARRAY) {
 -			current_ret = uverbs_free_idrs_array(
 -				attr_uapi, &attr->objs_arr_attr, commit);
 -			if (!ret)
 -				ret = current_ret;
 -		}
 +	for (i = 0; i < attr_bundle->num_buckets; i++) {
 +		struct uverbs_attr_spec_hash *attr_spec_bucket =
 +			method_spec->attr_buckets[i];
 +
 +		if (!attr_spec_bucket)
 +			continue;
 +
 +		if (!bitmap_subset(attr_spec_bucket->mandatory_attrs_bitmask,
 +				   attr_bundle->hash[i].valid_bitmap,
 +				   attr_spec_bucket->num_attrs))
 +			return -EINVAL;
  	}
  
 -	for (memblock = pbundle->allocated_mem; memblock;) {
 -		struct bundle_alloc_head *tmp = memblock;
 +	for (; i < method_spec->num_buckets; i++) {
 +		struct uverbs_attr_spec_hash *attr_spec_bucket =
 +			method_spec->attr_buckets[i];
  
 -		memblock = memblock->next;
 -		kvfree(tmp);
 +		if (!bitmap_empty(attr_spec_bucket->mandatory_attrs_bitmask,
 +				  attr_spec_bucket->num_attrs))
 +			return -EINVAL;
  	}
  
 -	return ret;
 +	return 0;
  }
  
 -static int ib_uverbs_cmd_verbs(struct ib_uverbs_file *ufile,
 -			       struct ib_uverbs_ioctl_hdr *hdr,
 -			       struct ib_uverbs_attr __user *user_attrs)
 +static int uverbs_handle_method(struct ib_uverbs_attr __user *uattr_ptr,
 +				const struct ib_uverbs_attr *uattrs,
 +				size_t num_uattrs,
 +				struct ib_device *ibdev,
 +				struct ib_uverbs_file *ufile,
 +				const struct uverbs_method_spec *method_spec,
 +				struct uverbs_attr_bundle *attr_bundle)
  {
 -	const struct uverbs_api_ioctl_method *method_elm;
 -	struct uverbs_api *uapi = ufile->device->uapi;
 -	struct radix_tree_iter attrs_iter;
 -	struct bundle_priv *pbundle;
 -	struct bundle_priv onstack;
 -	void __rcu **slot;
 -	int destroy_ret;
  	int ret;
 +	int finalize_ret;
 +	int num_given_buckets;
  
 -	if (unlikely(hdr->driver_id != uapi->driver_id))
 +	num_given_buckets = uverbs_uattrs_process(ibdev, ufile->ucontext, uattrs,
 +						  num_uattrs, method_spec,
 +						  attr_bundle, uattr_ptr);
 +	if (num_given_buckets <= 0)
  		return -EINVAL;
  
 -	slot = radix_tree_iter_lookup(
 -		&uapi->radix, &attrs_iter,
 -		uapi_key_obj(hdr->object_id) |
 -			uapi_key_ioctl_method(hdr->method_id));
 -	if (unlikely(!slot))
 -		return -EPROTONOSUPPORT;
 -	method_elm = rcu_dereference_protected(*slot, true);
 -
 -	if (!method_elm->use_stack) {
 -		pbundle = kmalloc(method_elm->bundle_size, GFP_KERNEL);
 -		if (!pbundle)
 -			return -ENOMEM;
 -		pbundle->internal_avail =
 -			method_elm->bundle_size -
 -			offsetof(struct bundle_priv, internal_buffer);
 -		pbundle->alloc_head.next = NULL;
 -		pbundle->allocated_mem = &pbundle->alloc_head;
 -	} else {
 -		pbundle = &onstack;
 -		pbundle->internal_avail = sizeof(pbundle->internal_buffer);
 -		pbundle->allocated_mem = NULL;
 -	}
 +	attr_bundle->num_buckets = num_given_buckets;
 +	ret = uverbs_validate_kernel_mandatory(method_spec, attr_bundle);
 +	if (ret)
 +		goto cleanup;
  
 -	/* Space for the pbundle->bundle.attrs flex array */
 -	pbundle->method_elm = method_elm;
 -	pbundle->method_key = attrs_iter.index;
 -	pbundle->bundle.ufile = ufile;
 -	pbundle->radix = &uapi->radix;
 -	pbundle->radix_slots = slot;
 -	pbundle->radix_slots_len = radix_tree_chunk_size(&attrs_iter);
 -	pbundle->user_attrs = user_attrs;
 -
 -	pbundle->internal_used = ALIGN(pbundle->method_elm->key_bitmap_len *
 -					       sizeof(*pbundle->bundle.attrs),
 -				       sizeof(*pbundle->internal_buffer));
 -	memset(pbundle->bundle.attr_present, 0,
 -	       sizeof(pbundle->bundle.attr_present));
 -	memset(pbundle->uobj_finalize, 0, sizeof(pbundle->uobj_finalize));
 -	memset(pbundle->spec_finalize, 0, sizeof(pbundle->spec_finalize));
 -
 -	ret = ib_uverbs_run_method(pbundle, hdr->num_attrs);
 -	destroy_ret = bundle_destroy(pbundle, ret == 0);
 -	if (unlikely(destroy_ret && !ret))
 -		return destroy_ret;
 +	ret = method_spec->handler(ibdev, ufile, attr_bundle);
 +cleanup:
 +	finalize_ret = uverbs_finalize_attrs(attr_bundle,
 +					     method_spec->attr_buckets,
 +					     attr_bundle->num_buckets,
 +					     !ret);
  
 -	return ret;
++<<<<<<< HEAD
 +	return ret ? ret : finalize_ret;
  }
  
 -long ib_uverbs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 +#define UVERBS_OPTIMIZE_USING_STACK_SZ  256
 +static long ib_uverbs_cmd_verbs(struct ib_device *ib_dev,
 +				struct ib_uverbs_file *file,
 +				struct ib_uverbs_ioctl_hdr *hdr,
 +				void __user *buf)
  {
 -	struct ib_uverbs_file *file = filp->private_data;
 -	struct ib_uverbs_ioctl_hdr __user *user_hdr =
 -		(struct ib_uverbs_ioctl_hdr __user *)arg;
 -	struct ib_uverbs_ioctl_hdr hdr;
 -	int srcu_key;
 -	int err;
 -
 -	if (unlikely(cmd != RDMA_VERBS_IOCTL))
 -		return -ENOIOCTLCMD;
 -
 -	err = copy_from_user(&hdr, user_hdr, sizeof(hdr));
 -	if (err)
 -		return -EFAULT;
 -
 -	if (hdr.length > PAGE_SIZE ||
 -	    hdr.length != struct_size(&hdr, attrs, hdr.num_attrs))
 -		return -EINVAL;
 -
 -	if (hdr.reserved1 || hdr.reserved2)
 +	const struct uverbs_object_spec *object_spec;
 +	const struct uverbs_method_spec *method_spec;
 +	long err = 0;
 +	unsigned int i;
 +	struct {
 +		struct ib_uverbs_attr		*uattrs;
 +		struct uverbs_attr_bundle	*uverbs_attr_bundle;
 +	} *ctx = NULL;
 +	struct uverbs_attr *curr_attr;
 +	unsigned long *curr_bitmap;
 +	size_t ctx_size;
 +	uintptr_t data[UVERBS_OPTIMIZE_USING_STACK_SZ / sizeof(uintptr_t)];
 +
 +	object_spec = uverbs_get_object(ib_dev, hdr->object_id);
 +	if (!object_spec)
  		return -EPROTONOSUPPORT;
  
 -	srcu_key = srcu_read_lock(&file->device->disassociate_srcu);
 -	err = ib_uverbs_cmd_verbs(file, &hdr, user_hdr->attrs);
 -	srcu_read_unlock(&file->device->disassociate_srcu, srcu_key);
 -	return err;
 -}
 +	method_spec = uverbs_get_method(object_spec, hdr->method_id);
 +	if (!method_spec)
 +		return -EPROTONOSUPPORT;
  
 -int uverbs_get_flags64(u64 *to, const struct uverbs_attr_bundle *attrs_bundle,
 -		       size_t idx, u64 allowed_bits)
 -{
 -	const struct uverbs_attr *attr;
 -	u64 flags;
 +	if ((method_spec->flags & UVERBS_ACTION_FLAG_CREATE_ROOT) ^ !file->ucontext)
 +		return -EINVAL;
  
 -	attr = uverbs_attr_get(attrs_bundle, idx);
 -	/* Missing attribute means 0 flags */
 -	if (IS_ERR(attr)) {
 -		*to = 0;
 -		return 0;
 -	}
 +	ctx_size = sizeof(*ctx) +
 +		   sizeof(struct uverbs_attr_bundle) +
 +		   sizeof(struct uverbs_attr_bundle_hash) * method_spec->num_buckets +
 +		   sizeof(*ctx->uattrs) * hdr->num_attrs +
 +		   sizeof(*ctx->uverbs_attr_bundle->hash[0].attrs) *
 +		   method_spec->num_child_attrs +
 +		   sizeof(*ctx->uverbs_attr_bundle->hash[0].valid_bitmap) *
 +			(method_spec->num_child_attrs / BITS_PER_LONG +
 +			 method_spec->num_buckets);
 +
 +	if (ctx_size <= UVERBS_OPTIMIZE_USING_STACK_SZ)
 +		ctx = (void *)data;
 +	if (!ctx)
 +		ctx = kmalloc(ctx_size, GFP_KERNEL);
 +	if (!ctx)
 +		return -ENOMEM;
 +
 +	ctx->uverbs_attr_bundle = (void *)ctx + sizeof(*ctx);
 +	ctx->uattrs = (void *)(ctx->uverbs_attr_bundle + 1) +
 +			      (sizeof(ctx->uverbs_attr_bundle->hash[0]) *
 +			       method_spec->num_buckets);
 +	curr_attr = (void *)(ctx->uattrs + hdr->num_attrs);
 +	curr_bitmap = (void *)(curr_attr + method_spec->num_child_attrs);
  
  	/*
 -	 * New userspace code should use 8 bytes to pass flags, but we
 -	 * transparently support old userspaces that were using 4 bytes as
 -	 * well.
 +	 * We just fill the pointers and num_attrs here. The data itself will be
 +	 * filled at a later stage (uverbs_process_attr)
  	 */
 -	if (attr->ptr_attr.len == 8)
 -		flags = attr->ptr_attr.data;
 -	else if (attr->ptr_attr.len == 4)
 -		flags = *(u32 *)&attr->ptr_attr.data;
 -	else
 -		return -EINVAL;
 +	for (i = 0; i < method_spec->num_buckets; i++) {
 +		unsigned int curr_num_attrs;
  
 -	if (flags & ~allowed_bits)
 -		return -EINVAL;
 -
 -	*to = flags;
 -	return 0;
 -}
 -EXPORT_SYMBOL(uverbs_get_flags64);
 -
 -int uverbs_get_flags32(u32 *to, const struct uverbs_attr_bundle *attrs_bundle,
 -		       size_t idx, u64 allowed_bits)
 -{
 -	u64 flags;
 -	int ret;
 -
 -	ret = uverbs_get_flags64(&flags, attrs_bundle, idx, allowed_bits);
 -	if (ret)
 -		return ret;
 -
 -	if (flags > U32_MAX)
 -		return -EINVAL;
 -	*to = flags;
 +		if (!method_spec->attr_buckets[i])
 +			continue;
  
 -	return 0;
 -}
 -EXPORT_SYMBOL(uverbs_get_flags32);
 +		curr_num_attrs = method_spec->attr_buckets[i]->num_attrs;
  
 -/*
 - * This is for ease of conversion. The purpose is to convert all drivers to
 - * use uverbs_attr_bundle instead of ib_udata.  Assume attr == 0 is input and
 - * attr == 1 is output.
 - */
 -void create_udata(struct uverbs_attr_bundle *bundle, struct ib_udata *udata)
 -{
 -	struct bundle_priv *pbundle =
 -		container_of(bundle, struct bundle_priv, bundle);
 -	const struct uverbs_attr *uhw_in =
 -		uverbs_attr_get(bundle, UVERBS_ATTR_UHW_IN);
 -	const struct uverbs_attr *uhw_out =
 -		uverbs_attr_get(bundle, UVERBS_ATTR_UHW_OUT);
 -
 -	if (!IS_ERR(uhw_in)) {
 -		udata->inlen = uhw_in->ptr_attr.len;
 -		if (uverbs_attr_ptr_is_inline(uhw_in))
 -			udata->inbuf =
 -				&pbundle->user_attrs[uhw_in->ptr_attr.uattr_idx]
 -					 .data;
 -		else
 -			udata->inbuf = u64_to_user_ptr(uhw_in->ptr_attr.data);
 +		ctx->uverbs_attr_bundle->hash[i].attrs = curr_attr;
 +		curr_attr += curr_num_attrs;
 +		ctx->uverbs_attr_bundle->hash[i].num_attrs = curr_num_attrs;
 +		ctx->uverbs_attr_bundle->hash[i].valid_bitmap = curr_bitmap;
 +		bitmap_zero(curr_bitmap, curr_num_attrs);
 +		curr_bitmap += BITS_TO_LONGS(curr_num_attrs);
++=======
++		ret = handler(&pbundle->bundle);
++		uobj_put_destroy(destroy_attr->uobject);
+ 	} else {
 -		udata->inbuf = NULL;
 -		udata->inlen = 0;
++		ret = handler(&pbundle->bundle);
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  	}
  
 -	if (!IS_ERR(uhw_out)) {
 -		udata->outbuf = u64_to_user_ptr(uhw_out->ptr_attr.data);
 -		udata->outlen = uhw_out->ptr_attr.len;
 -	} else {
 -		udata->outbuf = NULL;
 -		udata->outlen = 0;
 +	err = copy_from_user(ctx->uattrs, buf,
 +			     sizeof(*ctx->uattrs) * hdr->num_attrs);
 +	if (err) {
 +		err = -EFAULT;
 +		goto out;
  	}
 -}
  
 -int uverbs_copy_to(const struct uverbs_attr_bundle *bundle, size_t idx,
 -		   const void *from, size_t size)
 -{
 -	struct bundle_priv *pbundle =
 -		container_of(bundle, struct bundle_priv, bundle);
 -	const struct uverbs_attr *attr = uverbs_attr_get(bundle, idx);
 -	u16 flags;
 -	size_t min_size;
 +	err = uverbs_handle_method(buf, ctx->uattrs, hdr->num_attrs, ib_dev,
 +				   file, method_spec, ctx->uverbs_attr_bundle);
 +
 +	/*
 +	 * EPROTONOSUPPORT is ONLY to be returned if the ioctl framework can
 +	 * not invoke the method because the request is not supported.  No
 +	 * other cases should return this code.
 +	*/
 +	if (unlikely(err == -EPROTONOSUPPORT)) {
 +		WARN_ON_ONCE(err == -EPROTONOSUPPORT);
 +		err = -EINVAL;
 +	}
 +out:
 +	if (ctx != (void *)data)
 +		kfree(ctx);
 +	return err;
 +}
  
 -	if (IS_ERR(attr))
 -		return PTR_ERR(attr);
 +#define IB_UVERBS_MAX_CMD_SZ 4096
  
 -	min_size = min_t(size_t, attr->ptr_attr.len, size);
 -	if (copy_to_user(u64_to_user_ptr(attr->ptr_attr.data), from, min_size))
 -		return -EFAULT;
 +long ib_uverbs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 +{
 +	struct ib_uverbs_file *file = filp->private_data;
 +	struct ib_uverbs_ioctl_hdr __user *user_hdr =
 +		(struct ib_uverbs_ioctl_hdr __user *)arg;
 +	struct ib_uverbs_ioctl_hdr hdr;
 +	struct ib_device *ib_dev;
 +	int srcu_key;
 +	long err;
  
 -	flags = pbundle->uattrs[attr->ptr_attr.uattr_idx].flags |
 -		UVERBS_ATTR_F_VALID_OUTPUT;
 -	if (put_user(flags,
 -		     &pbundle->user_attrs[attr->ptr_attr.uattr_idx].flags))
 -		return -EFAULT;
 +	srcu_key = srcu_read_lock(&file->device->disassociate_srcu);
 +	ib_dev = srcu_dereference(file->device->ib_dev,
 +				  &file->device->disassociate_srcu);
 +	if (!ib_dev) {
 +		err = -EIO;
 +		goto out;
 +	}
  
 -	return 0;
 -}
 -EXPORT_SYMBOL(uverbs_copy_to);
 +	if (cmd == RDMA_VERBS_IOCTL) {
 +		err = copy_from_user(&hdr, user_hdr, sizeof(hdr));
  
 -int _uverbs_get_const(s64 *to, const struct uverbs_attr_bundle *attrs_bundle,
 -		      size_t idx, s64 lower_bound, u64 upper_bound,
 -		      s64  *def_val)
 -{
 -	const struct uverbs_attr *attr;
 +		if (err || hdr.length > IB_UVERBS_MAX_CMD_SZ ||
 +		    hdr.length != sizeof(hdr) + hdr.num_attrs * sizeof(struct ib_uverbs_attr)) {
 +			err = -EINVAL;
 +			goto out;
 +		}
  
 -	attr = uverbs_attr_get(attrs_bundle, idx);
 -	if (IS_ERR(attr)) {
 -		if ((PTR_ERR(attr) != -ENOENT) || !def_val)
 -			return PTR_ERR(attr);
 +		if (hdr.reserved) {
 +			err = -EPROTONOSUPPORT;
 +			goto out;
 +		}
  
 -		*to = *def_val;
 +		err = ib_uverbs_cmd_verbs(ib_dev, file, &hdr,
 +					  (__user void *)arg + sizeof(hdr));
  	} else {
 -		*to = attr->ptr_attr.data;
 +		err = -ENOIOCTLCMD;
  	}
 +out:
 +	srcu_read_unlock(&file->device->disassociate_srcu, srcu_key);
  
 -	if (*to < lower_bound || (*to > 0 && (u64)*to > upper_bound))
 -		return -EINVAL;
 -
 -	return 0;
 +	return err;
  }
 -EXPORT_SYMBOL(_uverbs_get_const);
diff --cc drivers/infiniband/core/uverbs_std_types.c
index bd9387aa9ae7,063aff9e7a04..000000000000
--- a/drivers/infiniband/core/uverbs_std_types.c
+++ b/drivers/infiniband/core/uverbs_std_types.c
@@@ -204,113 -210,79 +204,117 @@@ static int uverbs_hot_unplug_completion
  	return 0;
  };
  
++<<<<<<< HEAD
 +/*
 + * This spec is used in order to pass information to the hardware driver in a
 + * legacy way. Every verb that could get driver specific data should get this
 + * spec.
 + */
 +const struct uverbs_attr_def uverbs_uhw_compat_in =
 +	UVERBS_ATTR_PTR_IN_SZ(UVERBS_ATTR_UHW_IN, UVERBS_ATTR_MIN_SIZE(0),
 +			      UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO));
 +const struct uverbs_attr_def uverbs_uhw_compat_out =
 +	UVERBS_ATTR_PTR_OUT_SZ(UVERBS_ATTR_UHW_OUT, UVERBS_ATTR_MIN_SIZE(0),
 +			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO));
 +
 +void create_udata(struct uverbs_attr_bundle *ctx, struct ib_udata *udata)
++=======
+ int uverbs_destroy_def_handler(struct uverbs_attr_bundle *attrs)
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  {
 -	return 0;
 +	/*
 +	 * This is for ease of conversion. The purpose is to convert all drivers
 +	 * to use uverbs_attr_bundle instead of ib_udata.
 +	 * Assume attr == 0 is input and attr == 1 is output.
 +	 */
 +	const struct uverbs_attr *uhw_in =
 +		uverbs_attr_get(ctx, UVERBS_ATTR_UHW_IN);
 +	const struct uverbs_attr *uhw_out =
 +		uverbs_attr_get(ctx, UVERBS_ATTR_UHW_OUT);
 +
 +	if (!IS_ERR(uhw_in)) {
 +		udata->inlen = uhw_in->ptr_attr.len;
 +		if (uverbs_attr_ptr_is_inline(uhw_in))
 +			udata->inbuf = &uhw_in->uattr->data;
 +		else
 +			udata->inbuf = u64_to_user_ptr(uhw_in->ptr_attr.data);
 +	} else {
 +		udata->inbuf = NULL;
 +		udata->inlen = 0;
 +	}
 +
 +	if (!IS_ERR(uhw_out)) {
 +		udata->outbuf = u64_to_user_ptr(uhw_out->ptr_attr.data);
 +		udata->outlen = uhw_out->ptr_attr.len;
 +	} else {
 +		udata->outbuf = NULL;
 +		udata->outlen = 0;
 +	}
  }
 -EXPORT_SYMBOL(uverbs_destroy_def_handler);
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_COMP_CHANNEL,
 -	UVERBS_TYPE_ALLOC_FD(sizeof(struct ib_uverbs_completion_event_file),
 -			     uverbs_hot_unplug_completion_event_file,
 -			     &uverbs_event_fops,
 -			     "[infinibandevent]",
 -			     O_RDONLY));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_COMP_CHANNEL,
 +			    &UVERBS_TYPE_ALLOC_FD(0,
 +						  sizeof(struct ib_uverbs_completion_event_file),
 +						  uverbs_hot_unplug_completion_event_file,
 +						  &uverbs_event_fops,
 +						  "[infinibandevent]", O_RDONLY));
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_QP,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uqp_object), uverbs_free_qp));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_QP,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uqp_object), 0,
 +						      uverbs_free_qp));
  
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_MW,
 -			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_mw));
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_mw));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_MR,
 +			    /* 1 is used in order to free the MR after all the MWs */
 +			    &UVERBS_TYPE_ALLOC_IDR(1, uverbs_free_mr));
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_SRQ,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_usrq_object),
 -				 uverbs_free_srq));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_SRQ,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_usrq_object), 0,
 +						      uverbs_free_srq));
  
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_AH,
 -			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_ah));
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_ah));
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_FLOW,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uflow_object),
 -				 uverbs_free_flow));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_FLOW,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uflow_object),
 +						      0, uverbs_free_flow));
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_WQ,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uwq_object), uverbs_free_wq));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_WQ,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uwq_object), 0,
 +						      uverbs_free_wq));
  
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL,
 -			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_rwq_ind_tbl));
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_rwq_ind_tbl));
  
 -DECLARE_UVERBS_NAMED_OBJECT(
 -	UVERBS_OBJECT_XRCD,
 -	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uxrcd_object),
 -				 uverbs_free_xrcd));
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_XRCD,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uxrcd_object), 0,
 +						      uverbs_free_xrcd));
  
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_PD,
 -			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_pd));
 -
 -DECLARE_UVERBS_GLOBAL_METHODS(UVERBS_OBJECT_DEVICE);
 -
 -const struct uapi_definition uverbs_def_obj_intf[] = {
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_DEVICE),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_PD,
 -				      UAPI_DEF_OBJ_NEEDS_FN(dealloc_pd)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_COMP_CHANNEL,
 -				      UAPI_DEF_OBJ_NEEDS_FN(dealloc_pd)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_QP,
 -				      UAPI_DEF_OBJ_NEEDS_FN(destroy_qp)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_AH,
 -				      UAPI_DEF_OBJ_NEEDS_FN(destroy_ah)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_MW,
 -				      UAPI_DEF_OBJ_NEEDS_FN(dealloc_mw)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_SRQ,
 -				      UAPI_DEF_OBJ_NEEDS_FN(destroy_srq)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_FLOW,
 -				      UAPI_DEF_OBJ_NEEDS_FN(destroy_flow)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_WQ,
 -				      UAPI_DEF_OBJ_NEEDS_FN(destroy_wq)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(
 -		UVERBS_OBJECT_RWQ_IND_TBL,
 -		UAPI_DEF_OBJ_NEEDS_FN(destroy_rwq_ind_table)),
 -	UAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_XRCD,
 -				      UAPI_DEF_OBJ_NEEDS_FN(dealloc_xrcd)),
 -	{}
 -};
 +			    /* 2 is used in order to free the PD after MRs */
 +			    &UVERBS_TYPE_ALLOC_IDR(2, uverbs_free_pd));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_DEVICE, NULL);
 +
 +static DECLARE_UVERBS_OBJECT_TREE(uverbs_default_objects,
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_DEVICE),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_PD),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_MR),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_COMP_CHANNEL),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_CQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_QP),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_AH),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_MW),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_SRQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_FLOW),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_WQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_XRCD));
 +
 +const struct uverbs_object_tree_def *uverbs_default_get_objects(void)
 +{
 +	return &uverbs_default_objects;
 +}
 +EXPORT_SYMBOL_GPL(uverbs_default_get_objects);
diff --cc drivers/infiniband/core/uverbs_std_types_cq.c
index b0dbae9dd0d7,859d1e862034..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_cq.c
+++ b/drivers/infiniband/core/uverbs_std_types_cq.c
@@@ -53,12 -57,13 +53,17 @@@ static int uverbs_free_cq(struct ib_uob
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int UVERBS_HANDLER(UVERBS_METHOD_CQ_CREATE)(struct ib_device *ib_dev,
 +						   struct ib_uverbs_file *file,
 +						   struct uverbs_attr_bundle *attrs)
++=======
+ static int UVERBS_HANDLER(UVERBS_METHOD_CQ_CREATE)(
+ 	struct uverbs_attr_bundle *attrs)
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  {
 -	struct ib_ucq_object *obj = container_of(
 -		uverbs_attr_get_uobject(attrs, UVERBS_ATTR_CREATE_CQ_HANDLE),
 -		typeof(*obj), uobject);
 -	struct ib_device *ib_dev = obj->uobject.context->device;
 +	struct ib_ucontext *ucontext = file->ucontext;
 +	struct ib_ucq_object           *obj;
  	struct ib_udata uhw;
  	int ret;
  	u64 user_handle;
@@@ -97,7 -101,7 +102,11 @@@
  		uverbs_uobject_get(ev_file_uobj);
  	}
  
++<<<<<<< HEAD
 +	if (attr.comp_vector >= ucontext->ufile->device->num_comp_vectors) {
++=======
+ 	if (attr.comp_vector >= attrs->ufile->device->num_comp_vectors) {
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  		ret = -EINVAL;
  		goto err_event_file;
  	}
@@@ -146,46 -146,43 +155,51 @@@ err_event_file
  	return ret;
  };
  
 -DECLARE_UVERBS_NAMED_METHOD(
 -	UVERBS_METHOD_CQ_CREATE,
 -	UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_CQ_HANDLE,
 -			UVERBS_OBJECT_CQ,
 -			UVERBS_ACCESS_NEW,
 -			UA_MANDATORY),
 -	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_CQE,
 -			   UVERBS_ATTR_TYPE(u32),
 -			   UA_MANDATORY),
 -	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_USER_HANDLE,
 -			   UVERBS_ATTR_TYPE(u64),
 -			   UA_MANDATORY),
 -	UVERBS_ATTR_FD(UVERBS_ATTR_CREATE_CQ_COMP_CHANNEL,
 -		       UVERBS_OBJECT_COMP_CHANNEL,
 -		       UVERBS_ACCESS_READ,
 -		       UA_OPTIONAL),
 -	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_COMP_VECTOR,
 -			   UVERBS_ATTR_TYPE(u32),
 -			   UA_MANDATORY),
 -	UVERBS_ATTR_FLAGS_IN(UVERBS_ATTR_CREATE_CQ_FLAGS,
 -			     enum ib_uverbs_ex_create_cq_flags),
 -	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_CREATE_CQ_RESP_CQE,
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_CQ_CREATE,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_CQ_HANDLE, UVERBS_OBJECT_CQ,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_CQE,
  			    UVERBS_ATTR_TYPE(u32),
 -			    UA_MANDATORY),
 -	UVERBS_ATTR_UHW());
 -
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_USER_HANDLE,
 +			    UVERBS_ATTR_TYPE(u64),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_FD(UVERBS_ATTR_CREATE_CQ_COMP_CHANNEL,
 +			UVERBS_OBJECT_COMP_CHANNEL,
 +			UVERBS_ACCESS_READ),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_COMP_VECTOR, UVERBS_ATTR_TYPE(u32),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_FLAGS, UVERBS_ATTR_TYPE(u32)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_CREATE_CQ_RESP_CQE, UVERBS_ATTR_TYPE(u32),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&uverbs_uhw_compat_in, &uverbs_uhw_compat_out);
 +
++<<<<<<< HEAD
 +static int UVERBS_HANDLER(UVERBS_METHOD_CQ_DESTROY)(struct ib_device *ib_dev,
 +						    struct ib_uverbs_file *file,
 +						    struct uverbs_attr_bundle *attrs)
++=======
+ static int UVERBS_HANDLER(UVERBS_METHOD_CQ_DESTROY)(
+ 	struct uverbs_attr_bundle *attrs)
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  {
 +	struct ib_uverbs_destroy_cq_resp resp;
  	struct ib_uobject *uobj =
 -		uverbs_attr_get_uobject(attrs, UVERBS_ATTR_DESTROY_CQ_HANDLE);
 -	struct ib_ucq_object *obj =
 -		container_of(uobj, struct ib_ucq_object, uobject);
 -	struct ib_uverbs_destroy_cq_resp resp = {
 -		.comp_events_reported = obj->comp_events_reported,
 -		.async_events_reported = obj->async_events_reported
 -	};
 +		uverbs_attr_get(attrs, UVERBS_ATTR_DESTROY_CQ_HANDLE)->obj_attr.uobject;
 +	struct ib_ucq_object *obj = container_of(uobj, struct ib_ucq_object,
 +						 uobject);
 +	int ret;
 +
 +	if (!(ib_dev->uverbs_cmd_mask & 1ULL << IB_USER_VERBS_CMD_DESTROY_CQ))
 +		return -EOPNOTSUPP;
 +
 +	ret = rdma_explicit_destroy(uobj);
 +	if (ret)
 +		return ret;
 +
 +	resp.comp_events_reported  = obj->comp_events_reported;
 +	resp.async_events_reported = obj->async_events_reported;
  
  	return uverbs_copy_to(attrs, UVERBS_ATTR_DESTROY_CQ_RESP, &resp,
  			      sizeof(resp));
diff --cc include/rdma/ib_verbs.h
index b950ea239071,92633c15125b..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -4070,6 -4207,42 +4070,46 @@@ ib_get_vector_affinity(struct ib_devic
   */
  void rdma_roce_rescan_device(struct ib_device *ibdev);
  
++<<<<<<< HEAD
 +struct ib_ucontext *ib_uverbs_get_ucontext(struct ib_uverbs_file *ufile);
++=======
+ struct ib_ucontext *ib_uverbs_get_ucontext_file(struct ib_uverbs_file *ufile);
+ 
+ 
+ int uverbs_destroy_def_handler(struct uverbs_attr_bundle *attrs);
+ 
+ struct net_device *rdma_alloc_netdev(struct ib_device *device, u8 port_num,
+ 				     enum rdma_netdev_t type, const char *name,
+ 				     unsigned char name_assign_type,
+ 				     void (*setup)(struct net_device *));
+ 
+ int rdma_init_netdev(struct ib_device *device, u8 port_num,
+ 		     enum rdma_netdev_t type, const char *name,
+ 		     unsigned char name_assign_type,
+ 		     void (*setup)(struct net_device *),
+ 		     struct net_device *netdev);
+ 
+ /**
+  * rdma_set_device_sysfs_group - Set device attributes group to have
+  *				 driver specific sysfs entries at
+  *				 for infiniband class.
+  *
+  * @device:	device pointer for which attributes to be created
+  * @group:	Pointer to group which should be added when device
+  *		is registered with sysfs.
+  * rdma_set_device_sysfs_group() allows existing drivers to expose one
+  * group per device to have sysfs attributes.
+  *
+  * NOTE: New drivers should not make use of this API; instead new device
+  * parameter should be exposed via netlink command. This API and mechanism
+  * exist only for existing drivers.
+  */
+ static inline void
+ rdma_set_device_sysfs_group(struct ib_device *dev,
+ 			    const struct attribute_group *group)
+ {
+ 	dev->groups[1] = group;
+ }
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  
  #endif /* IB_VERBS_H */
diff --cc include/rdma/uverbs_ioctl.h
index 2cc45699a237,e0b1a77b1c2c..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -176,8 -327,7 +176,12 @@@ struct uverbs_method_def 
  	u32				     flags;
  	size_t				     num_attrs;
  	const struct uverbs_attr_def * const (*attrs)[];
++<<<<<<< HEAD
 +	int (*handler)(struct ib_device *ib_dev, struct ib_uverbs_file *ufile,
 +		       struct uverbs_attr_bundle *ctx);
++=======
+ 	int (*handler)(struct uverbs_attr_bundle *attrs);
++>>>>>>> 15a1b4becba8 (RDMA/uverbs: Do not pass ib_uverbs_file to ioctl methods)
  };
  
  struct uverbs_object_def {
* Unmerged path drivers/infiniband/core/uverbs_std_types_counters.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_dm.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_flow_action.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_mr.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/hw/mlx5/flow.c
* Unmerged path drivers/infiniband/core/rdma_core.h
* Unmerged path drivers/infiniband/core/uverbs_ioctl.c
* Unmerged path drivers/infiniband/core/uverbs_std_types.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_counters.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_cq.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_dm.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_flow_action.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_mr.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/hw/mlx5/flow.c
* Unmerged path include/rdma/ib_verbs.h
* Unmerged path include/rdma/uverbs_ioctl.h
