perf stat: Move perf_stat_synthesize_config() to stat.c

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 0a4e64d391a2c771ae33e648cf84d4492369560c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/0a4e64d3.failed

So that it can be used globally.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20180830063252.23729-15-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 0a4e64d391a2c771ae33e648cf84d4492369560c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/stat.c
#	tools/perf/util/stat.h
diff --cc tools/perf/util/stat.c
index 79602e19daba,5d3172bcc4ae..000000000000
--- a/tools/perf/util/stat.c
+++ b/tools/perf/util/stat.c
@@@ -427,3 -435,98 +427,101 @@@ size_t perf_event__fprintf_stat_config(
  
  	return ret;
  }
++<<<<<<< HEAD
++=======
+ 
+ int create_perf_stat_counter(struct perf_evsel *evsel,
+ 			     struct perf_stat_config *config,
+ 			     struct target *target)
+ {
+ 	struct perf_event_attr *attr = &evsel->attr;
+ 	struct perf_evsel *leader = evsel->leader;
+ 
+ 	if (config->scale) {
+ 		attr->read_format = PERF_FORMAT_TOTAL_TIME_ENABLED |
+ 				    PERF_FORMAT_TOTAL_TIME_RUNNING;
+ 	}
+ 
+ 	/*
+ 	 * The event is part of non trivial group, let's enable
+ 	 * the group read (for leader) and ID retrieval for all
+ 	 * members.
+ 	 */
+ 	if (leader->nr_members > 1)
+ 		attr->read_format |= PERF_FORMAT_ID|PERF_FORMAT_GROUP;
+ 
+ 	attr->inherit = !config->no_inherit;
+ 
+ 	/*
+ 	 * Some events get initialized with sample_(period/type) set,
+ 	 * like tracepoints. Clear it up for counting.
+ 	 */
+ 	attr->sample_period = 0;
+ 
+ 	if (config->identifier)
+ 		attr->sample_type = PERF_SAMPLE_IDENTIFIER;
+ 
+ 	/*
+ 	 * Disabling all counters initially, they will be enabled
+ 	 * either manually by us or by kernel via enable_on_exec
+ 	 * set later.
+ 	 */
+ 	if (perf_evsel__is_group_leader(evsel)) {
+ 		attr->disabled = 1;
+ 
+ 		/*
+ 		 * In case of initial_delay we enable tracee
+ 		 * events manually.
+ 		 */
+ 		if (target__none(target) && !config->initial_delay)
+ 			attr->enable_on_exec = 1;
+ 	}
+ 
+ 	if (target__has_cpu(target) && !target__has_per_thread(target))
+ 		return perf_evsel__open_per_cpu(evsel, perf_evsel__cpus(evsel));
+ 
+ 	return perf_evsel__open_per_thread(evsel, evsel->threads);
+ }
+ 
+ int perf_stat_synthesize_config(struct perf_stat_config *config,
+ 				struct perf_tool *tool,
+ 				struct perf_evlist *evlist,
+ 				perf_event__handler_t process,
+ 				bool attrs)
+ {
+ 	int err;
+ 
+ 	if (attrs) {
+ 		err = perf_event__synthesize_attrs(tool, evlist, process);
+ 		if (err < 0) {
+ 			pr_err("Couldn't synthesize attrs.\n");
+ 			return err;
+ 		}
+ 	}
+ 
+ 	err = perf_event__synthesize_extra_attr(tool, evlist, process,
+ 						attrs);
+ 
+ 	err = perf_event__synthesize_thread_map2(tool, evlist->threads,
+ 						 process, NULL);
+ 	if (err < 0) {
+ 		pr_err("Couldn't synthesize thread map.\n");
+ 		return err;
+ 	}
+ 
+ 	err = perf_event__synthesize_cpu_map(tool, evlist->cpus,
+ 					     process, NULL);
+ 	if (err < 0) {
+ 		pr_err("Couldn't synthesize thread map.\n");
+ 		return err;
+ 	}
+ 
+ 	err = perf_event__synthesize_stat_config(tool, config, process, NULL);
+ 	if (err < 0) {
+ 		pr_err("Couldn't synthesize config.\n");
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
++>>>>>>> 0a4e64d391a2 (perf stat: Move perf_stat_synthesize_config() to stat.c)
diff --cc tools/perf/util/stat.h
index 4b88aef959fb,da6a706daecc..000000000000
--- a/tools/perf/util/stat.h
+++ b/tools/perf/util/stat.h
@@@ -163,4 -176,13 +164,16 @@@ int perf_event__process_stat_event(stru
  size_t perf_event__fprintf_stat(union perf_event *event, FILE *fp);
  size_t perf_event__fprintf_stat_round(union perf_event *event, FILE *fp);
  size_t perf_event__fprintf_stat_config(union perf_event *event, FILE *fp);
++<<<<<<< HEAD
++=======
+ 
+ int create_perf_stat_counter(struct perf_evsel *evsel,
+ 			     struct perf_stat_config *config,
+ 			     struct target *target);
+ int perf_stat_synthesize_config(struct perf_stat_config *config,
+ 				struct perf_tool *tool,
+ 				struct perf_evlist *evlist,
+ 				perf_event__handler_t process,
+ 				bool attrs);
++>>>>>>> 0a4e64d391a2 (perf stat: Move perf_stat_synthesize_config() to stat.c)
  #endif
diff --git a/tools/perf/builtin-stat.c b/tools/perf/builtin-stat.c
index dc7a6d4f00c0..ac901b7c051b 100644
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@ -466,48 +466,6 @@ static void workload_exec_failed_signal(int signo __maybe_unused, siginfo_t *inf
 	workload_exec_errno = info->si_value.sival_int;
 }
 
-static int perf_stat_synthesize_config(struct perf_stat_config *config,
-				       struct perf_tool *tool,
-				       struct perf_evlist *evlist,
-				       perf_event__handler_t process,
-				       bool attrs)
-{
-	int err;
-
-	if (attrs) {
-		err = perf_event__synthesize_attrs(tool, evlist, process);
-		if (err < 0) {
-			pr_err("Couldn't synthesize attrs.\n");
-			return err;
-		}
-	}
-
-	err = perf_event__synthesize_extra_attr(tool, evlist, process,
-						attrs);
-
-	err = perf_event__synthesize_thread_map2(tool, evlist->threads,
-						 process, NULL);
-	if (err < 0) {
-		pr_err("Couldn't synthesize thread map.\n");
-		return err;
-	}
-
-	err = perf_event__synthesize_cpu_map(tool, evlist->cpus,
-					     process, NULL);
-	if (err < 0) {
-		pr_err("Couldn't synthesize thread map.\n");
-		return err;
-	}
-
-	err = perf_event__synthesize_stat_config(tool, config, process, NULL);
-	if (err < 0) {
-		pr_err("Couldn't synthesize config.\n");
-		return err;
-	}
-
-	return 0;
-}
-
 static bool perf_evsel__should_store_id(struct perf_evsel *counter)
 {
 	return STAT_RECORD || counter->attr.read_format & PERF_FORMAT_ID;
* Unmerged path tools/perf/util/stat.c
* Unmerged path tools/perf/util/stat.h
