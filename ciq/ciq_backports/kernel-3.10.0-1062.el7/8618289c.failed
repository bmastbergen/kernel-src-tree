NFSv4: Fix a sleep in atomic context in nfs4_callback_sequence()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Trond Myklebust <trondmy@gmail.com>
commit 8618289c46556fd4dd259a1af02ccc448032f48d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/8618289c.failed

We must drop the lock before we can sleep in referring_call_exists().

	Reported-by: Jia-Ju Bai <baijiaju1990@gmail.com>
Fixes: 045d2a6d076a ("NFSv4.1: Delay callback processing...")
	Cc: stable@vger.kernel.org # v4.9+
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 8618289c46556fd4dd259a1af02ccc448032f48d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/callback_proc.c
diff --cc fs/nfs/callback_proc.c
index 04f4e53f64b8,fa515d5ea5ba..000000000000
--- a/fs/nfs/callback_proc.c
+++ b/fs/nfs/callback_proc.c
@@@ -452,11 -442,14 +452,18 @@@ validate_seqid(const struct nfs4_slot_t
   * a match.  If the slot is in use and the sequence numbers match, the
   * client is still waiting for a response to the original request.
   */
- static bool referring_call_exists(struct nfs_client *clp,
+ static int referring_call_exists(struct nfs_client *clp,
  				  uint32_t nrclists,
- 				  struct referring_call_list *rclists)
+ 				  struct referring_call_list *rclists,
+ 				  spinlock_t *lock)
+ 	__releases(lock)
+ 	__acquires(lock)
  {
++<<<<<<< HEAD
 +	bool status = 0;
++=======
+ 	int status = 0;
++>>>>>>> 8618289c4655 (NFSv4: Fix a sleep in atomic context in nfs4_callback_sequence())
  	int i, j;
  	struct nfs4_session *session;
  	struct nfs4_slot_table *tbl;
@@@ -479,17 -472,10 +486,22 @@@
  
  		for (j = 0; j < rclist->rcl_nrefcalls; j++) {
  			ref = &rclist->rcl_refcalls[j];
++<<<<<<< HEAD
 +
 +			dprintk("%s: sessionid %x:%x:%x:%x sequenceid %u "
 +				"slotid %u\n", __func__,
 +				((u32 *)&rclist->rcl_sessionid.data)[0],
 +				((u32 *)&rclist->rcl_sessionid.data)[1],
 +				((u32 *)&rclist->rcl_sessionid.data)[2],
 +				((u32 *)&rclist->rcl_sessionid.data)[3],
 +				ref->rc_sequenceid, ref->rc_slotid);
 +
++=======
+ 			spin_unlock(lock);
++>>>>>>> 8618289c4655 (NFSv4: Fix a sleep in atomic context in nfs4_callback_sequence())
  			status = nfs4_slot_wait_on_seqid(tbl, ref->rc_slotid,
  					ref->rc_sequenceid, HZ >> 1) < 0;
+ 			spin_lock(lock);
  			if (status)
  				goto out;
  		}
* Unmerged path fs/nfs/callback_proc.c
