ALSA: hda/ca0132 - Actually fix microphone issue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Connor McAdams <conmanx360@gmail.com>
commit b5a229350b72b929edac5ba77c825f8ebb413533
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/b5a22935.failed

This patch fixes the microphone issue for all cards. The previous fix
worked on the ZxR, but not on the AE-5 or Z. This patch has been tested
to work for all cards.

	Signed-off-by: Connor McAdams <conmanx360@gmail.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit b5a229350b72b929edac5ba77c825f8ebb413533)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index e10b8cea0b28,f0ef52eb22a9..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -4376,6 -6847,358 +4376,361 @@@ static void ca0132_refresh_widget_caps(
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Creates a dummy stream to bind the output to. This seems to have to be done
+  * after changing the main outputs source and destination streams.
+  */
+ static void ca0132_alt_create_dummy_stream(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int stream_format;
+ 
+ 	stream_format = snd_hdac_calc_stream_format(48000, 2,
+ 			SNDRV_PCM_FORMAT_S32_LE, 32, 0);
+ 
+ 	snd_hda_codec_setup_stream(codec, spec->dacs[0], spec->dsp_stream_id,
+ 					0, stream_format);
+ 
+ 	snd_hda_codec_cleanup_stream(codec, spec->dacs[0]);
+ }
+ 
+ /*
+  * Initialize mic for non-chromebook ca0132 implementations.
+  */
+ static void ca0132_alt_init_analog_mics(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 
+ 	/* Mic 1 Setup */
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 	if (spec->quirk == QUIRK_R3DI) {
+ 		chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 		tmp = FLOAT_ONE;
+ 	} else
+ 		tmp = FLOAT_THREE;
+ 	dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 	/* Mic 2 setup (not present on desktop cards) */
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN2, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT2, SR_96_000);
+ 	if (spec->quirk == QUIRK_R3DI)
+ 		chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x80, 0x01, tmp);
+ }
+ 
+ /*
+  * Sets the source of stream 0x14 to connpointID 0x48, and the destination
+  * connpointID to 0x91. If this isn't done, the destination is 0x71, and
+  * you get no sound. I'm guessing this has to do with the Sound Blaster Z
+  * having an updated DAC, which changes the destination to that DAC.
+  */
+ static void sbz_connect_streams(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	mutex_lock(&spec->chipio_mutex);
+ 
+ 	codec_dbg(codec, "Connect Streams entered, mutex locked and loaded.\n");
+ 
+ 	chipio_set_stream_channels(codec, 0x0C, 6);
+ 	chipio_set_stream_control(codec, 0x0C, 1);
+ 
+ 	/* This value is 0x43 for 96khz, and 0x83 for 192khz. */
+ 	chipio_write_no_mutex(codec, 0x18a020, 0x00000043);
+ 
+ 	/* Setup stream 0x14 with it's source and destination points */
+ 	chipio_set_stream_source_dest(codec, 0x14, 0x48, 0x91);
+ 	chipio_set_conn_rate_no_mutex(codec, 0x48, SR_96_000);
+ 	chipio_set_conn_rate_no_mutex(codec, 0x91, SR_96_000);
+ 	chipio_set_stream_channels(codec, 0x14, 2);
+ 	chipio_set_stream_control(codec, 0x14, 1);
+ 
+ 	codec_dbg(codec, "Connect Streams exited, mutex released.\n");
+ 
+ 	mutex_unlock(&spec->chipio_mutex);
+ }
+ 
+ /*
+  * Write data through ChipIO to setup proper stream destinations.
+  * Not sure how it exactly works, but it seems to direct data
+  * to different destinations. Example is f8 to c0, e0 to c0.
+  * All I know is, if you don't set these, you get no sound.
+  */
+ static void sbz_chipio_startup_data(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	mutex_lock(&spec->chipio_mutex);
+ 	codec_dbg(codec, "Startup Data entered, mutex locked and loaded.\n");
+ 
+ 	/* These control audio output */
+ 	chipio_write_no_mutex(codec, 0x190060, 0x0001f8c0);
+ 	chipio_write_no_mutex(codec, 0x190064, 0x0001f9c1);
+ 	chipio_write_no_mutex(codec, 0x190068, 0x0001fac6);
+ 	chipio_write_no_mutex(codec, 0x19006c, 0x0001fbc7);
+ 	/* Signal to update I think */
+ 	chipio_write_no_mutex(codec, 0x19042c, 0x00000001);
+ 
+ 	chipio_set_stream_channels(codec, 0x0C, 6);
+ 	chipio_set_stream_control(codec, 0x0C, 1);
+ 	/* No clue what these control */
+ 	if (spec->quirk == QUIRK_SBZ) {
+ 		chipio_write_no_mutex(codec, 0x190030, 0x0001e0c0);
+ 		chipio_write_no_mutex(codec, 0x190034, 0x0001e1c1);
+ 		chipio_write_no_mutex(codec, 0x190038, 0x0001e4c2);
+ 		chipio_write_no_mutex(codec, 0x19003c, 0x0001e5c3);
+ 		chipio_write_no_mutex(codec, 0x190040, 0x0001e2c4);
+ 		chipio_write_no_mutex(codec, 0x190044, 0x0001e3c5);
+ 		chipio_write_no_mutex(codec, 0x190048, 0x0001e8c6);
+ 		chipio_write_no_mutex(codec, 0x19004c, 0x0001e9c7);
+ 		chipio_write_no_mutex(codec, 0x190050, 0x0001ecc8);
+ 		chipio_write_no_mutex(codec, 0x190054, 0x0001edc9);
+ 		chipio_write_no_mutex(codec, 0x190058, 0x0001eaca);
+ 		chipio_write_no_mutex(codec, 0x19005c, 0x0001ebcb);
+ 	} else if (spec->quirk == QUIRK_ZXR) {
+ 		chipio_write_no_mutex(codec, 0x190038, 0x000140c2);
+ 		chipio_write_no_mutex(codec, 0x19003c, 0x000141c3);
+ 		chipio_write_no_mutex(codec, 0x190040, 0x000150c4);
+ 		chipio_write_no_mutex(codec, 0x190044, 0x000151c5);
+ 		chipio_write_no_mutex(codec, 0x190050, 0x000142c8);
+ 		chipio_write_no_mutex(codec, 0x190054, 0x000143c9);
+ 		chipio_write_no_mutex(codec, 0x190058, 0x000152ca);
+ 		chipio_write_no_mutex(codec, 0x19005c, 0x000153cb);
+ 	}
+ 	chipio_write_no_mutex(codec, 0x19042c, 0x00000001);
+ 
+ 	codec_dbg(codec, "Startup Data exited, mutex released.\n");
+ 	mutex_unlock(&spec->chipio_mutex);
+ }
+ 
+ /*
+  * Custom DSP SCP commands where the src value is 0x00 instead of 0x20. This is
+  * done after the DSP is loaded.
+  */
+ static void ca0132_alt_dsp_scp_startup(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp, i;
+ 
+ 	/*
+ 	 * Gotta run these twice, or else mic works inconsistently. Not clear
+ 	 * why this is, but multiple tests have confirmed it.
+ 	 */
+ 	for (i = 0; i < 2; i++) {
+ 		switch (spec->quirk) {
+ 		case QUIRK_SBZ:
+ 		case QUIRK_AE5:
+ 			tmp = 0x00000003;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 			tmp = 0x00000000;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0A, tmp);
+ 			tmp = 0x00000001;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0B, tmp);
+ 			tmp = 0x00000004;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 			tmp = 0x00000005;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 			tmp = 0x00000000;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 			break;
+ 		case QUIRK_R3D:
+ 		case QUIRK_R3DI:
+ 			tmp = 0x00000000;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0A, tmp);
+ 			tmp = 0x00000001;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0B, tmp);
+ 			tmp = 0x00000004;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 			tmp = 0x00000005;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 			tmp = 0x00000000;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 			break;
+ 		}
+ 		msleep(100);
+ 	}
+ }
+ 
+ static void ca0132_alt_dsp_initial_mic_setup(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 
+ 	chipio_set_stream_control(codec, 0x03, 0);
+ 	chipio_set_stream_control(codec, 0x04, 0);
+ 
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 
+ 	tmp = FLOAT_THREE;
+ 	dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 	chipio_set_stream_control(codec, 0x03, 1);
+ 	chipio_set_stream_control(codec, 0x04, 1);
+ 
+ 	switch (spec->quirk) {
+ 	case QUIRK_SBZ:
+ 		chipio_write(codec, 0x18b098, 0x0000000c);
+ 		chipio_write(codec, 0x18b09C, 0x0000000c);
+ 		break;
+ 	case QUIRK_AE5:
+ 		chipio_write(codec, 0x18b098, 0x0000000c);
+ 		chipio_write(codec, 0x18b09c, 0x0000004c);
+ 		break;
+ 	}
+ }
+ 
+ static void ae5_post_dsp_register_set(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	chipio_8051_write_direct(codec, 0x93, 0x10);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x44);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc2);
+ 
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0x00, spec->mem_base + 0x100);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0x00, spec->mem_base + 0x100);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0x00, spec->mem_base + 0x100);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0x00, spec->mem_base + 0x100);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 
+ 	ca0113_mmio_command_set(codec, 0x30, 0x2b, 0x3f);
+ 	ca0113_mmio_command_set(codec, 0x30, 0x2d, 0x3f);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x07, 0x83);
+ }
+ 
+ static void ae5_post_dsp_param_setup(struct hda_codec *codec)
+ {
+ 	/*
+ 	 * Param3 in the 8051's memory is represented by the ascii string 'mch'
+ 	 * which seems to be 'multichannel'. This is also mentioned in the
+ 	 * AE-5's registry values in Windows.
+ 	 */
+ 	chipio_set_control_param(codec, 3, 0);
+ 	/*
+ 	 * I believe ASI is 'audio serial interface' and that it's used to
+ 	 * change colors on the external LED strip connected to the AE-5.
+ 	 */
+ 	chipio_set_control_flag(codec, CONTROL_FLAG_ASI_96KHZ, 1);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0, 0x724, 0x83);
+ 	chipio_set_control_param(codec, CONTROL_PARAM_ASI, 0);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x92);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_HIGH, 0xfa);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_DATA_WRITE, 0x22);
+ }
+ 
+ static void ae5_post_dsp_pll_setup(struct hda_codec *codec)
+ {
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x41);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc8);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x45);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xcc);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x40);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xcb);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x43);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc7);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x51);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0x8d);
+ }
+ 
+ static void ae5_post_dsp_stream_setup(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	mutex_lock(&spec->chipio_mutex);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0, 0x725, 0x81);
+ 
+ 	chipio_set_conn_rate_no_mutex(codec, 0x70, SR_96_000);
+ 
+ 	chipio_set_stream_channels(codec, 0x0C, 6);
+ 	chipio_set_stream_control(codec, 0x0C, 1);
+ 
+ 	chipio_set_stream_source_dest(codec, 0x5, 0x43, 0x0);
+ 
+ 	chipio_set_stream_source_dest(codec, 0x18, 0x9, 0xd0);
+ 	chipio_set_conn_rate_no_mutex(codec, 0xd0, SR_96_000);
+ 	chipio_set_stream_channels(codec, 0x18, 6);
+ 	chipio_set_stream_control(codec, 0x18, 1);
+ 
+ 	chipio_set_control_param_no_mutex(codec, CONTROL_PARAM_ASI, 4);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x43);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc7);
+ 
+ 	ca0113_mmio_command_set(codec, 0x48, 0x01, 0x80);
+ 
+ 	mutex_unlock(&spec->chipio_mutex);
+ }
+ 
+ static void ae5_post_dsp_startup_data(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	mutex_lock(&spec->chipio_mutex);
+ 
+ 	chipio_write_no_mutex(codec, 0x189000, 0x0001f101);
+ 	chipio_write_no_mutex(codec, 0x189004, 0x0001f101);
+ 	chipio_write_no_mutex(codec, 0x189024, 0x00014004);
+ 	chipio_write_no_mutex(codec, 0x189028, 0x0002000f);
+ 
+ 	ca0113_mmio_command_set(codec, 0x48, 0x0a, 0x05);
+ 	chipio_set_control_param_no_mutex(codec, CONTROL_PARAM_ASI, 7);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x0b, 0x12);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x04, 0x00);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x06, 0x48);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x0a, 0x05);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x07, 0x83);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x0f, 0x00);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x10, 0x00);
+ 	ca0113_mmio_gpio_set(codec, 0, true);
+ 	ca0113_mmio_gpio_set(codec, 1, true);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x07, 0x80);
+ 
+ 	chipio_write_no_mutex(codec, 0x18b03c, 0x00000012);
+ 
+ 	ca0113_mmio_command_set(codec, 0x48, 0x0f, 0x00);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x10, 0x00);
+ 
+ 	mutex_unlock(&spec->chipio_mutex);
+ }
+ 
+ /*
++>>>>>>> b5a229350b72 (ALSA: hda/ca0132 - Actually fix microphone issue)
   * Setup default parameters for DSP
   */
  static void ca0132_setup_defaults(struct hda_codec *codec)
@@@ -4420,6 -7243,175 +4775,178 @@@
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Setup default parameters for Recon3D/Recon3Di DSP.
+  */
+ 
+ static void r3d_setup_defaults(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 	int num_fx;
+ 	int idx, i;
+ 
+ 	if (spec->dsp_state != DSP_DOWNLOADED)
+ 		return;
+ 
+ 	ca0132_alt_dsp_scp_startup(codec);
+ 	ca0132_alt_init_analog_mics(codec);
+ 
+ 	/*remove DSP headroom*/
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x96, 0x3C, tmp);
+ 
+ 	/* set WUH source */
+ 	tmp = FLOAT_TWO;
+ 	dspio_set_uint_param(codec, 0x31, 0x00, tmp);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);
+ 
+ 	/* Set speaker source? */
+ 	dspio_set_uint_param(codec, 0x32, 0x00, tmp);
+ 
+ 	if (spec->quirk == QUIRK_R3DI)
+ 		r3di_gpio_dsp_status_set(codec, R3DI_DSP_DOWNLOADED);
+ 
+ 	/* Setup effect defaults */
+ 	num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;
+ 	for (idx = 0; idx < num_fx; idx++) {
+ 		for (i = 0; i <= ca0132_effects[idx].params; i++) {
+ 			dspio_set_uint_param(codec,
+ 					ca0132_effects[idx].mid,
+ 					ca0132_effects[idx].reqs[i],
+ 					ca0132_effects[idx].def_vals[i]);
+ 		}
+ 	}
+ }
+ 
+ /*
+  * Setup default parameters for the Sound Blaster Z DSP. A lot more going on
+  * than the Chromebook setup.
+  */
+ static void sbz_setup_defaults(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 	int num_fx;
+ 	int idx, i;
+ 
+ 	if (spec->dsp_state != DSP_DOWNLOADED)
+ 		return;
+ 
+ 	ca0132_alt_dsp_scp_startup(codec);
+ 	ca0132_alt_init_analog_mics(codec);
+ 	sbz_connect_streams(codec);
+ 	sbz_chipio_startup_data(codec);
+ 
+ 	chipio_set_stream_control(codec, 0x03, 1);
+ 	chipio_set_stream_control(codec, 0x04, 1);
+ 
+ 	/*
+ 	 * Sets internal input loopback to off, used to have a switch to
+ 	 * enable input loopback, but turned out to be way too buggy.
+ 	 */
+ 	tmp = FLOAT_ONE;
+ 	dspio_set_uint_param(codec, 0x37, 0x08, tmp);
+ 	dspio_set_uint_param(codec, 0x37, 0x10, tmp);
+ 
+ 	/*remove DSP headroom*/
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x96, 0x3C, tmp);
+ 
+ 	/* set WUH source */
+ 	tmp = FLOAT_TWO;
+ 	dspio_set_uint_param(codec, 0x31, 0x00, tmp);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);
+ 
+ 	/* Set speaker source? */
+ 	dspio_set_uint_param(codec, 0x32, 0x00, tmp);
+ 
+ 	ca0132_alt_dsp_initial_mic_setup(codec);
+ 
+ 	/* out, in effects + voicefx */
+ 	num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;
+ 	for (idx = 0; idx < num_fx; idx++) {
+ 		for (i = 0; i <= ca0132_effects[idx].params; i++) {
+ 			dspio_set_uint_param(codec,
+ 					ca0132_effects[idx].mid,
+ 					ca0132_effects[idx].reqs[i],
+ 					ca0132_effects[idx].def_vals[i]);
+ 		}
+ 	}
+ 
+ 	ca0132_alt_create_dummy_stream(codec);
+ }
+ 
+ /*
+  * Setup default parameters for the Sound BlasterX AE-5 DSP.
+  */
+ static void ae5_setup_defaults(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 	int num_fx;
+ 	int idx, i;
+ 
+ 	if (spec->dsp_state != DSP_DOWNLOADED)
+ 		return;
+ 
+ 	ca0132_alt_dsp_scp_startup(codec);
+ 	ca0132_alt_init_analog_mics(codec);
+ 	chipio_set_stream_control(codec, 0x03, 1);
+ 	chipio_set_stream_control(codec, 0x04, 1);
+ 
+ 	/* New, unknown SCP req's */
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x96, 0x29, tmp);
+ 	dspio_set_uint_param(codec, 0x96, 0x2a, tmp);
+ 	dspio_set_uint_param(codec, 0x80, 0x0d, tmp);
+ 	dspio_set_uint_param(codec, 0x80, 0x0e, tmp);
+ 
+ 	ca0113_mmio_command_set(codec, 0x30, 0x2e, 0x3f);
+ 	ca0113_mmio_gpio_set(codec, 0, false);
+ 	ca0113_mmio_command_set(codec, 0x30, 0x28, 0x00);
+ 
+ 	/* Internal loopback off */
+ 	tmp = FLOAT_ONE;
+ 	dspio_set_uint_param(codec, 0x37, 0x08, tmp);
+ 	dspio_set_uint_param(codec, 0x37, 0x10, tmp);
+ 
+ 	/*remove DSP headroom*/
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x96, 0x3C, tmp);
+ 
+ 	/* set WUH source */
+ 	tmp = FLOAT_TWO;
+ 	dspio_set_uint_param(codec, 0x31, 0x00, tmp);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);
+ 
+ 	/* Set speaker source? */
+ 	dspio_set_uint_param(codec, 0x32, 0x00, tmp);
+ 
+ 	ca0132_alt_dsp_initial_mic_setup(codec);
+ 	ae5_post_dsp_register_set(codec);
+ 	ae5_post_dsp_param_setup(codec);
+ 	ae5_post_dsp_pll_setup(codec);
+ 	ae5_post_dsp_stream_setup(codec);
+ 	ae5_post_dsp_startup_data(codec);
+ 
+ 	/* out, in effects + voicefx */
+ 	num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;
+ 	for (idx = 0; idx < num_fx; idx++) {
+ 		for (i = 0; i <= ca0132_effects[idx].params; i++) {
+ 			dspio_set_uint_param(codec,
+ 					ca0132_effects[idx].mid,
+ 					ca0132_effects[idx].reqs[i],
+ 					ca0132_effects[idx].def_vals[i]);
+ 		}
+ 	}
+ 
+ 	ca0132_alt_create_dummy_stream(codec);
+ }
+ 
+ /*
++>>>>>>> b5a229350b72 (ALSA: hda/ca0132 - Actually fix microphone issue)
   * Initialization of flags in chip
   */
  static void ca0132_init_flags(struct hda_codec *codec)
* Unmerged path sound/pci/hda/patch_ca0132.c
