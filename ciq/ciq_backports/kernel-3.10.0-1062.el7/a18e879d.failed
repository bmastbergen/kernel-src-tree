net/mlx5e: Annul encap action ordering requirement

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Annul encap action ordering requirement (Alaa Hleihel) [1642383 1642498]
Rebuild_FUZZ: 95.83%
commit-author Eli Britstein <elibr@mellanox.com>
commit a18e879d4e45b6aef73f42c765cd0da4b26f4260
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a18e879d.failed

Currently a FW syndrome is emitted if the driver configures a
multi-destination FTE where the first destination is a tunneled uplink
port and the second destination is a local vPort.

Support this scenario by creating a multi-destination FTE using the
firmware's extended destination capabilities.

	Signed-off-by: Eli Britstein <elibr@mellanox.com>
	Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit a18e879d4e45b6aef73f42c765cd0da4b26f4260)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 84864631953e,bb96c4661e26..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -70,23 -107,40 +70,55 @@@ mlx5_eswitch_add_offloaded_rule(struct 
  	}
  
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) {
++<<<<<<< HEAD
 +		dest[i].type = MLX5_FLOW_DESTINATION_TYPE_VPORT;
 +		dest[i].vport.num = attr->out_rep->vport;
 +		if (MLX5_CAP_ESW(esw->dev, merged_eswitch)) {
 +			dest[i].vport.vhca_id =
 +				MLX5_CAP_GEN(attr->out_mdev, vhca_id);
 +			dest[i].vport.vhca_id_valid = 1;
++=======
+ 		if (attr->dest_chain) {
+ 			struct mlx5_flow_table *ft;
+ 
+ 			ft = esw_get_prio_table(esw, attr->dest_chain, 1, 0);
+ 			if (IS_ERR(ft)) {
+ 				rule = ERR_CAST(ft);
+ 				goto err_create_goto_table;
+ 			}
+ 
+ 			dest[i].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 			dest[i].ft = ft;
+ 			i++;
+ 		} else {
+ 			for (j = attr->split_count; j < attr->out_count; j++) {
+ 				dest[i].type = MLX5_FLOW_DESTINATION_TYPE_VPORT;
+ 				dest[i].vport.num = attr->dests[j].rep->vport;
+ 				dest[i].vport.vhca_id =
+ 					MLX5_CAP_GEN(attr->dests[j].mdev, vhca_id);
+ 				if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
+ 					dest[i].vport.flags |=
+ 						MLX5_FLOW_DEST_VPORT_VHCA_ID;
+ 				if (attr->dests[j].flags & MLX5_ESW_DEST_ENCAP) {
+ 					flow_act.action |= MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;
+ 					flow_act.reformat_id = attr->encap_id;
+ 					dest[i].vport.flags |= MLX5_FLOW_DEST_VPORT_REFORMAT_ID;
+ 					dest[i].vport.reformat_id = attr->encap_id;
+ 				}
+ 				i++;
+ 			}
++>>>>>>> a18e879d4e45 (net/mlx5e: Annul encap action ordering requirement)
  		}
 +		i++;
  	}
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_COUNT) {
 +		counter = mlx5_fc_create(esw->dev, true);
 +		if (IS_ERR(counter)) {
 +			rule = ERR_CAST(counter);
 +			goto err_counter_alloc;
 +		}
  		dest[i].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;
 -		dest[i].counter_id = mlx5_fc_id(attr->counter);
 +		dest[i].counter = counter;
  		i++;
  	}
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
