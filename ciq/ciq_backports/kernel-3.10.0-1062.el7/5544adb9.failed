flow_dissector: Dissect tos and ttl from the tunnel info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit 5544adb9707fda5d54494c37940701894c16b9a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/5544adb9.failed

Add dissection of the tos and ttl from the ip tunnel headers
fields in case a match is needed on them.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5544adb9707fda5d54494c37940701894c16b9a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index ec6a8d0a3cc7,08a5184f4b34..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -116,6 -118,115 +116,118 @@@ __be32 __skb_flow_get_ports(const struc
  }
  EXPORT_SYMBOL(__skb_flow_get_ports);
  
++<<<<<<< HEAD
++=======
+ static void
+ skb_flow_dissect_set_enc_addr_type(enum flow_dissector_key_id type,
+ 				   struct flow_dissector *flow_dissector,
+ 				   void *target_container)
+ {
+ 	struct flow_dissector_key_control *ctrl;
+ 
+ 	if (!dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_CONTROL))
+ 		return;
+ 
+ 	ctrl = skb_flow_dissector_target(flow_dissector,
+ 					 FLOW_DISSECTOR_KEY_ENC_CONTROL,
+ 					 target_container);
+ 	ctrl->addr_type = type;
+ }
+ 
+ void
+ skb_flow_dissect_tunnel_info(const struct sk_buff *skb,
+ 			     struct flow_dissector *flow_dissector,
+ 			     void *target_container)
+ {
+ 	struct ip_tunnel_info *info;
+ 	struct ip_tunnel_key *key;
+ 
+ 	/* A quick check to see if there might be something to do. */
+ 	if (!dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_KEYID) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_CONTROL) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_PORTS) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_IP))
+ 		return;
+ 
+ 	info = skb_tunnel_info(skb);
+ 	if (!info)
+ 		return;
+ 
+ 	key = &info->key;
+ 
+ 	switch (ip_tunnel_info_af(info)) {
+ 	case AF_INET:
+ 		skb_flow_dissect_set_enc_addr_type(FLOW_DISSECTOR_KEY_IPV4_ADDRS,
+ 						   flow_dissector,
+ 						   target_container);
+ 		if (dissector_uses_key(flow_dissector,
+ 				       FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS)) {
+ 			struct flow_dissector_key_ipv4_addrs *ipv4;
+ 
+ 			ipv4 = skb_flow_dissector_target(flow_dissector,
+ 							 FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS,
+ 							 target_container);
+ 			ipv4->src = key->u.ipv4.src;
+ 			ipv4->dst = key->u.ipv4.dst;
+ 		}
+ 		break;
+ 	case AF_INET6:
+ 		skb_flow_dissect_set_enc_addr_type(FLOW_DISSECTOR_KEY_IPV6_ADDRS,
+ 						   flow_dissector,
+ 						   target_container);
+ 		if (dissector_uses_key(flow_dissector,
+ 				       FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS)) {
+ 			struct flow_dissector_key_ipv6_addrs *ipv6;
+ 
+ 			ipv6 = skb_flow_dissector_target(flow_dissector,
+ 							 FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS,
+ 							 target_container);
+ 			ipv6->src = key->u.ipv6.src;
+ 			ipv6->dst = key->u.ipv6.dst;
+ 		}
+ 		break;
+ 	}
+ 
+ 	if (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_KEYID)) {
+ 		struct flow_dissector_key_keyid *keyid;
+ 
+ 		keyid = skb_flow_dissector_target(flow_dissector,
+ 						  FLOW_DISSECTOR_KEY_ENC_KEYID,
+ 						  target_container);
+ 		keyid->keyid = tunnel_id_to_key32(key->tun_id);
+ 	}
+ 
+ 	if (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_PORTS)) {
+ 		struct flow_dissector_key_ports *tp;
+ 
+ 		tp = skb_flow_dissector_target(flow_dissector,
+ 					       FLOW_DISSECTOR_KEY_ENC_PORTS,
+ 					       target_container);
+ 		tp->src = key->tp_src;
+ 		tp->dst = key->tp_dst;
+ 	}
+ 
+ 	if (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_IP)) {
+ 		struct flow_dissector_key_ip *ip;
+ 
+ 		ip = skb_flow_dissector_target(flow_dissector,
+ 					       FLOW_DISSECTOR_KEY_ENC_IP,
+ 					       target_container);
+ 		ip->tos = key->tos;
+ 		ip->ttl = key->ttl;
+ 	}
+ }
+ EXPORT_SYMBOL(skb_flow_dissect_tunnel_info);
+ 
++>>>>>>> 5544adb9707f (flow_dissector: Dissect tos and ttl from the tunnel info)
  static enum flow_dissect_ret
  __skb_flow_dissect_mpls(const struct sk_buff *skb,
  			struct flow_dissector *flow_dissector,
diff --git a/include/net/flow_dissector.h b/include/net/flow_dissector.h
index e783eb6e2773..d4abc292c853 100644
--- a/include/net/flow_dissector.h
+++ b/include/net/flow_dissector.h
@@ -206,7 +206,7 @@ enum flow_dissector_key_id {
 	FLOW_DISSECTOR_KEY_TCP, /* struct flow_dissector_key_tcp */
 	FLOW_DISSECTOR_KEY_IP, /* struct flow_dissector_key_ip */
 	FLOW_DISSECTOR_KEY_CVLAN, /* struct flow_dissector_key_flow_vlan */
-
+	FLOW_DISSECTOR_KEY_ENC_IP, /* struct flow_dissector_key_ip */
 	FLOW_DISSECTOR_KEY_MAX,
 };
 
* Unmerged path net/core/flow_dissector.c
