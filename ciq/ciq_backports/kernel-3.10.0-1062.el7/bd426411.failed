drm/ttm: fix re-init of global structures

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christian König <christian.koenig@amd.com>
commit bd4264112f93045704731850c5e4d85db981cd85
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/bd426411.failed

When a driver unloads without unloading TTM we don't correctly
clear the global structures leading to errors on re-init.

Next step should probably be to remove the global structures and
kobjs all together, but this is tricky since we need to maintain
backward compatibility.

	Signed-off-by: Christian König <christian.koenig@amd.com>
	Reviewed-by: Karol Herbst <kherbst@redhat.com>
	Tested-by: Karol Herbst <kherbst@redhat.com>
CC: stable@vger.kernel.org # 5.0.x
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit bd4264112f93045704731850c5e4d85db981cd85)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/ttm/ttm_bo.c
diff --cc drivers/gpu/drm/ttm/ttm_bo.c
index 98e06f8bf23b,1a01669b159a..000000000000
--- a/drivers/gpu/drm/ttm/ttm_bo.c
+++ b/drivers/gpu/drm/ttm/ttm_bo.c
@@@ -44,6 -45,13 +44,16 @@@
  
  static void ttm_bo_global_kobj_release(struct kobject *kobj);
  
++<<<<<<< HEAD
++=======
+ /**
+  * ttm_global_mutex - protecting the global BO state
+  */
+ DEFINE_MUTEX(ttm_global_mutex);
+ unsigned ttm_bo_glob_use_count;
+ struct ttm_bo_global ttm_bo_glob;
+ 
++>>>>>>> bd4264112f93 (drm/ttm: fix re-init of global structures)
  static struct attribute ttm_bo_count = {
  	.name = "bo_count",
  	.mode = S_IRUGO
@@@ -1442,29 -1523,40 +1452,55 @@@ static void ttm_bo_global_kobj_release(
  		container_of(kobj, struct ttm_bo_global, kobj);
  
  	__free_page(glob->dummy_read_page);
 +	kfree(glob);
  }
  
 -static void ttm_bo_global_release(void)
 +void ttm_bo_global_release(struct drm_global_reference *ref)
  {
++<<<<<<< HEAD
 +	struct ttm_bo_global *glob = ref->object;
 +
 +	kobject_del(&glob->kobj);
 +	kobject_put(&glob->kobj);
++=======
+ 	struct ttm_bo_global *glob = &ttm_bo_glob;
+ 
+ 	mutex_lock(&ttm_global_mutex);
+ 	if (--ttm_bo_glob_use_count > 0)
+ 		goto out;
+ 
+ 	kobject_del(&glob->kobj);
+ 	kobject_put(&glob->kobj);
+ 	ttm_mem_global_release(&ttm_mem_glob);
+ 	memset(glob, 0, sizeof(*glob));
+ out:
+ 	mutex_unlock(&ttm_global_mutex);
++>>>>>>> bd4264112f93 (drm/ttm: fix re-init of global structures)
  }
 +EXPORT_SYMBOL(ttm_bo_global_release);
  
 -static int ttm_bo_global_init(void)
 +int ttm_bo_global_init(struct drm_global_reference *ref)
  {
 -	struct ttm_bo_global *glob = &ttm_bo_glob;
 -	int ret = 0;
 +	struct ttm_bo_global_ref *bo_ref =
 +		container_of(ref, struct ttm_bo_global_ref, ref);
 +	struct ttm_bo_global *glob = ref->object;
 +	int ret;
  	unsigned i;
  
++<<<<<<< HEAD
 +	mutex_init(&glob->device_list_mutex);
++=======
+ 	mutex_lock(&ttm_global_mutex);
+ 	if (++ttm_bo_glob_use_count > 1)
+ 		goto out;
+ 
+ 	ret = ttm_mem_global_init(&ttm_mem_glob);
+ 	if (ret)
+ 		goto out;
+ 
++>>>>>>> bd4264112f93 (drm/ttm: fix re-init of global structures)
  	spin_lock_init(&glob->lru_lock);
 -	glob->mem_glob = &ttm_mem_glob;
 +	glob->mem_glob = bo_ref->mem_glob;
  	glob->mem_glob->bo_glob = glob;
  	glob->dummy_read_page = alloc_page(__GFP_ZERO | GFP_DMA32);
  
* Unmerged path drivers/gpu/drm/ttm/ttm_bo.c
diff --git a/drivers/gpu/drm/ttm/ttm_memory.c b/drivers/gpu/drm/ttm/ttm_memory.c
index 27856c55dc84..abe595e5d998 100644
--- a/drivers/gpu/drm/ttm/ttm_memory.c
+++ b/drivers/gpu/drm/ttm/ttm_memory.c
@@ -467,8 +467,8 @@ EXPORT_SYMBOL(ttm_mem_global_init);
 
 void ttm_mem_global_release(struct ttm_mem_global *glob)
 {
-	unsigned int i;
 	struct ttm_mem_zone *zone;
+	unsigned int i;
 
 	/* let the page allocator first stop the shrink work. */
 	ttm_page_alloc_fini();
@@ -481,9 +481,10 @@ void ttm_mem_global_release(struct ttm_mem_global *glob)
 		zone = glob->zones[i];
 		kobject_del(&zone->kobj);
 		kobject_put(&zone->kobj);
-			}
+	}
 	kobject_del(&glob->kobj);
 	kobject_put(&glob->kobj);
+	memset(glob, 0, sizeof(*glob));
 }
 EXPORT_SYMBOL(ttm_mem_global_release);
 
