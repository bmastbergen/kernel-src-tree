s390/sclp: add error notification command

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [s390] sclp: add error notification command (Hendrik Brueckner) [1640682]
Rebuild_FUZZ: 93.51%
commit-author Sebastian Ott <sebott@linux.vnet.ibm.com>
commit 12283a4035691697977083a5ac1e00ad5cfa6a3d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/12283a40.failed

Add SCLP event 24 "Adapter-error notification".

	Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 12283a4035691697977083a5ac1e00ad5cfa6a3d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/sclp.h
diff --cc arch/s390/include/asm/sclp.h
index 21049d84cc3d,bd7893d274fa..000000000000
--- a/arch/s390/include/asm/sclp.h
+++ b/arch/s390/include/asm/sclp.h
@@@ -44,34 -46,59 +44,81 @@@ struct sclp_cpu_info 
  	unsigned int configured;
  	unsigned int standby;
  	unsigned int combined;
 -	struct sclp_core_entry core[SCLP_MAX_CORES];
 +	int has_cpu_type;
 +	struct sclp_cpu_entry cpu[MAX_CPU_ADDRESS + 1];
  };
  
++<<<<<<< HEAD
 +int sclp_get_cpu_info(struct sclp_cpu_info *info);
 +int sclp_cpu_configure(u8 cpu);
 +int sclp_cpu_deconfigure(u8 cpu);
 +unsigned long long sclp_get_rnmax(void);
 +unsigned long long sclp_get_rzm(void);
 +unsigned int sclp_get_max_cpu(void);
 +unsigned int sclp_get_mtid(u8 cpu_type);
 +unsigned int sclp_get_mtid_max(void);
 +unsigned int sclp_get_mtid_prev(void);
++=======
+ struct sclp_info {
+ 	unsigned char has_linemode : 1;
+ 	unsigned char has_vt220 : 1;
+ 	unsigned char has_siif : 1;
+ 	unsigned char has_sigpif : 1;
+ 	unsigned char has_core_type : 1;
+ 	unsigned char has_sprp : 1;
+ 	unsigned char has_hvs : 1;
+ 	unsigned char has_esca : 1;
+ 	unsigned char has_sief2 : 1;
+ 	unsigned int ibc;
+ 	unsigned int mtid;
+ 	unsigned int mtid_cp;
+ 	unsigned int mtid_prev;
+ 	unsigned long rzm;
+ 	unsigned long rnmax;
+ 	unsigned long hamax;
+ 	unsigned int max_cores;
+ 	unsigned long hsa_size;
+ 	unsigned long facilities;
+ };
+ extern struct sclp_info sclp;
+ 
+ struct zpci_report_error_header {
+ 	u8 version;	/* Interface version byte */
+ 	u8 action;	/* Action qualifier byte
+ 			 * 1: Deconfigure and repair action requested
+ 			 *	(OpenCrypto Problem Call Home)
+ 			 * 2: Informational Report
+ 			 *	(OpenCrypto Successful Diagnostics Execution)
+ 			 */
+ 	u16 length;	/* Length of Subsequent Data (up to 4K â€“ SCLP header */
+ 	u8 data[0];	/* Subsequent Data passed verbatim to SCLP ET 24 */
+ } __packed;
+ 
+ int sclp_get_core_info(struct sclp_core_info *info);
+ int sclp_core_configure(u8 core);
+ int sclp_core_deconfigure(u8 core);
++>>>>>>> 12283a403569 (s390/sclp: add error notification command)
  int sclp_sdias_blk_count(void);
  int sclp_sdias_copy(void *dest, int blk_num, int nr_blks);
  int sclp_chp_configure(struct chp_id chpid);
  int sclp_chp_deconfigure(struct chp_id chpid);
  int sclp_chp_read_info(struct sclp_chp_info *info);
  void sclp_get_ipl_info(struct sclp_ipl_info *info);
 +bool __init sclp_has_linemode(void);
 +bool __init sclp_has_vt220(void);
  int sclp_pci_configure(u32 fid);
  int sclp_pci_deconfigure(u32 fid);
++<<<<<<< HEAD
 +int memcpy_hsa(void *dest, unsigned long src, size_t count, int mode);
 +unsigned long sclp_get_hsa_size(void);
++=======
+ int sclp_pci_report(struct zpci_report_error_header *report, u32 fh, u32 fid);
+ int memcpy_hsa_kernel(void *dest, unsigned long src, size_t count);
+ int memcpy_hsa_user(void __user *dest, unsigned long src, size_t count);
++>>>>>>> 12283a403569 (s390/sclp: add error notification command)
  void sclp_early_detect(void);
 -void _sclp_print_early(const char *);
 +int sclp_has_siif(void);
 +int sclp_has_sief2(void);
 +void sclp_ocf_cpc_name_copy(char *dst);
  
  #endif /* _ASM_S390_SCLP_H */
* Unmerged path arch/s390/include/asm/sclp.h
diff --git a/drivers/s390/char/sclp.h b/drivers/s390/char/sclp.h
index 4d46349762d1..cef8bdd4451f 100644
--- a/drivers/s390/char/sclp.h
+++ b/drivers/s390/char/sclp.h
@@ -22,6 +22,7 @@
 #define EVTYP_DIAG_TEST		0x07
 #define EVTYP_STATECHANGE	0x08
 #define EVTYP_PMSGCMD		0x09
+#define EVTYP_ERRNOTIFY		0x18
 #define EVTYP_CNTLPROGOPCMD	0x20
 #define EVTYP_CNTLPROGIDENT	0x0B
 #define EVTYP_SIGQUIESCE	0x1D
@@ -36,6 +37,7 @@
 #define EVTYP_DIAG_TEST_MASK	0x02000000
 #define EVTYP_STATECHANGE_MASK	0x01000000
 #define EVTYP_PMSGCMD_MASK	0x00800000
+#define EVTYP_ERRNOTIFY_MASK	0x00000100
 #define EVTYP_CTLPROGOPCMD_MASK	0x00000001
 #define EVTYP_CTLPROGIDENT_MASK	0x00200000
 #define EVTYP_SIGQUIESCE_MASK	0x00000008
diff --git a/drivers/s390/char/sclp_pci.c b/drivers/s390/char/sclp_pci.c
index 943e92539e65..0c8973c45b48 100644
--- a/drivers/s390/char/sclp_pci.c
+++ b/drivers/s390/char/sclp_pci.c
@@ -8,6 +8,7 @@
 
 #include <linux/completion.h>
 #include <linux/export.h>
+#include <linux/mutex.h>
 #include <linux/errno.h>
 #include <linux/slab.h>
 #include <linux/init.h>
@@ -20,7 +21,29 @@
 #define SCLP_CMDW_CONFIGURE_PCI			0x001a0001
 #define SCLP_CMDW_DECONFIGURE_PCI		0x001b0001
 
-#define SCLP_RECONFIG_PCI_ATPYE			2
+#define SCLP_ATYPE_PCI				2
+
+#define SCLP_ERRNOTIFY_AQ_REPAIR		1
+#define SCLP_ERRNOTIFY_AQ_INFO_LOG		2
+
+static DEFINE_MUTEX(sclp_pci_mutex);
+static struct sclp_register sclp_pci_event = {
+	.send_mask = EVTYP_ERRNOTIFY_MASK,
+};
+
+struct err_notify_evbuf {
+	struct evbuf_header header;
+	u8 action;
+	u8 atype;
+	u32 fh;
+	u32 fid;
+	u8 data[0];
+} __packed;
+
+struct err_notify_sccb {
+	struct sccb_header header;
+	struct err_notify_evbuf evbuf;
+} __packed;
 
 struct pci_cfg_sccb {
 	struct sccb_header header;
@@ -43,7 +66,7 @@ static int do_pci_configure(sclp_cmdw_t cmd, u32 fid)
 		return -ENOMEM;
 
 	sccb->header.length = PAGE_SIZE;
-	sccb->atype = SCLP_RECONFIG_PCI_ATPYE;
+	sccb->atype = SCLP_ATYPE_PCI;
 	sccb->aid = fid;
 	rc = sclp_sync_request(cmd, sccb);
 	if (rc)
@@ -74,3 +97,96 @@ int sclp_pci_deconfigure(u32 fid)
 	return do_pci_configure(SCLP_CMDW_DECONFIGURE_PCI, fid);
 }
 EXPORT_SYMBOL(sclp_pci_deconfigure);
+
+static void sclp_pci_callback(struct sclp_req *req, void *data)
+{
+	struct completion *completion = data;
+
+	complete(completion);
+}
+
+static int sclp_pci_check_report(struct zpci_report_error_header *report)
+{
+	if (report->version != 1)
+		return -EINVAL;
+
+	if (report->action != SCLP_ERRNOTIFY_AQ_REPAIR &&
+	    report->action != SCLP_ERRNOTIFY_AQ_INFO_LOG)
+		return -EINVAL;
+
+	if (report->length > (PAGE_SIZE - sizeof(struct err_notify_sccb)))
+		return -EINVAL;
+
+	return 0;
+}
+
+int sclp_pci_report(struct zpci_report_error_header *report, u32 fh, u32 fid)
+{
+	DECLARE_COMPLETION_ONSTACK(completion);
+	struct err_notify_sccb *sccb;
+	struct sclp_req req = {0};
+	int ret;
+
+	ret = sclp_pci_check_report(report);
+	if (ret)
+		return ret;
+
+	mutex_lock(&sclp_pci_mutex);
+	ret = sclp_register(&sclp_pci_event);
+	if (ret)
+		goto out_unlock;
+
+	if (!(sclp_pci_event.sclp_receive_mask & EVTYP_ERRNOTIFY_MASK)) {
+		ret = -EOPNOTSUPP;
+		goto out_unregister;
+	}
+
+	sccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);
+	if (!sccb) {
+		ret = -ENOMEM;
+		goto out_unregister;
+	}
+
+	req.callback_data = &completion;
+	req.callback = sclp_pci_callback;
+	req.command = SCLP_CMDW_WRITE_EVENT_DATA;
+	req.status = SCLP_REQ_FILLED;
+	req.sccb = sccb;
+
+	sccb->evbuf.header.length = sizeof(sccb->evbuf) + report->length;
+	sccb->evbuf.header.type = EVTYP_ERRNOTIFY;
+	sccb->header.length = sizeof(sccb->header) + sccb->evbuf.header.length;
+
+	sccb->evbuf.action = report->action;
+	sccb->evbuf.atype = SCLP_ATYPE_PCI;
+	sccb->evbuf.fh = fh;
+	sccb->evbuf.fid = fid;
+
+	memcpy(sccb->evbuf.data, report->data, report->length);
+
+	ret = sclp_add_request(&req);
+	if (ret)
+		goto out_free_req;
+
+	wait_for_completion(&completion);
+	if (req.status != SCLP_REQ_DONE) {
+		pr_warn("request failed (status=0x%02x)\n",
+			req.status);
+		ret = -EIO;
+		goto out_free_req;
+	}
+
+	if (sccb->header.response_code != 0x0020) {
+		pr_warn("request failed with response code 0x%x\n",
+			sccb->header.response_code);
+		ret = -EIO;
+	}
+
+out_free_req:
+	free_page((unsigned long) sccb);
+out_unregister:
+	sclp_unregister(&sclp_pci_event);
+out_unlock:
+	mutex_unlock(&sclp_pci_mutex);
+	return ret;
+}
