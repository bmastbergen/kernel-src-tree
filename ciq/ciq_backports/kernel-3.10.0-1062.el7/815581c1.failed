bpf: get JITed image lengths of functions via syscall

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Sandipan Das <sandipan@linux.vnet.ibm.com>
commit 815581c11cc29f74af252b6306ea1ec94160231a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/815581c1.failed

This adds new two new fields to struct bpf_prog_info. For
multi-function programs, these fields can be used to pass
a list of the JITed image lengths of each function for a
given program to userspace using the bpf system call with
the BPF_OBJ_GET_INFO_BY_FD command.

This can be used by userspace applications like bpftool
to split up the contiguous JITed dump, also obtained via
the system call, into more relatable chunks corresponding
to each function.

	Signed-off-by: Sandipan Das <sandipan@linux.vnet.ibm.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 815581c11cc29f74af252b6306ea1ec94160231a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/bpf.h
#	kernel/bpf/syscall.c
diff --cc include/uapi/linux/bpf.h
index 000f5ce2d064,344d2ddcef49..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -670,6 -2203,12 +670,15 @@@ struct bpf_prog_info 
  	char name[BPF_OBJ_NAME_LEN];
  	__u32 ifindex;
  	__u32 gpl_compatible:1;
++<<<<<<< HEAD
++=======
+ 	__u64 netns_dev;
+ 	__u64 netns_ino;
+ 	__u32 nr_jited_ksyms;
+ 	__u32 nr_jited_func_lens;
+ 	__aligned_u64 jited_ksyms;
+ 	__aligned_u64 jited_func_lens;
++>>>>>>> 815581c11cc2 (bpf: get JITed image lengths of functions via syscall)
  } __attribute__((aligned(8)));
  
  struct bpf_map_info {
diff --cc kernel/bpf/syscall.c
index f8f3ed8bef67,788456c18617..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -1625,6 -1958,105 +1625,108 @@@ static int bpf_prog_get_info_by_fd(stru
  			return -EFAULT;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (bpf_prog_is_dev_bound(prog->aux)) {
+ 		err = bpf_prog_offload_info_fill(&info, prog);
+ 		if (err)
+ 			return err;
+ 		goto done;
+ 	}
+ 
+ 	/* NOTE: the following code is supposed to be skipped for offload.
+ 	 * bpf_prog_offload_info_fill() is the place to fill similar fields
+ 	 * for offload.
+ 	 */
+ 	ulen = info.jited_prog_len;
+ 	if (prog->aux->func_cnt) {
+ 		u32 i;
+ 
+ 		info.jited_prog_len = 0;
+ 		for (i = 0; i < prog->aux->func_cnt; i++)
+ 			info.jited_prog_len += prog->aux->func[i]->jited_len;
+ 	} else {
+ 		info.jited_prog_len = prog->jited_len;
+ 	}
+ 
+ 	if (info.jited_prog_len && ulen) {
+ 		if (bpf_dump_raw_ok()) {
+ 			uinsns = u64_to_user_ptr(info.jited_prog_insns);
+ 			ulen = min_t(u32, info.jited_prog_len, ulen);
+ 
+ 			/* for multi-function programs, copy the JITed
+ 			 * instructions for all the functions
+ 			 */
+ 			if (prog->aux->func_cnt) {
+ 				u32 len, free, i;
+ 				u8 *img;
+ 
+ 				free = ulen;
+ 				for (i = 0; i < prog->aux->func_cnt; i++) {
+ 					len = prog->aux->func[i]->jited_len;
+ 					len = min_t(u32, len, free);
+ 					img = (u8 *) prog->aux->func[i]->bpf_func;
+ 					if (copy_to_user(uinsns, img, len))
+ 						return -EFAULT;
+ 					uinsns += len;
+ 					free -= len;
+ 					if (!free)
+ 						break;
+ 				}
+ 			} else {
+ 				if (copy_to_user(uinsns, prog->bpf_func, ulen))
+ 					return -EFAULT;
+ 			}
+ 		} else {
+ 			info.jited_prog_insns = 0;
+ 		}
+ 	}
+ 
+ 	ulen = info.nr_jited_ksyms;
+ 	info.nr_jited_ksyms = prog->aux->func_cnt;
+ 	if (info.nr_jited_ksyms && ulen) {
+ 		if (bpf_dump_raw_ok()) {
+ 			u64 __user *user_ksyms;
+ 			ulong ksym_addr;
+ 			u32 i;
+ 
+ 			/* copy the address of the kernel symbol
+ 			 * corresponding to each function
+ 			 */
+ 			ulen = min_t(u32, info.nr_jited_ksyms, ulen);
+ 			user_ksyms = u64_to_user_ptr(info.jited_ksyms);
+ 			for (i = 0; i < ulen; i++) {
+ 				ksym_addr = (ulong) prog->aux->func[i]->bpf_func;
+ 				ksym_addr &= PAGE_MASK;
+ 				if (put_user((u64) ksym_addr, &user_ksyms[i]))
+ 					return -EFAULT;
+ 			}
+ 		} else {
+ 			info.jited_ksyms = 0;
+ 		}
+ 	}
+ 
+ 	ulen = info.nr_jited_func_lens;
+ 	info.nr_jited_func_lens = prog->aux->func_cnt;
+ 	if (info.nr_jited_func_lens && ulen) {
+ 		if (bpf_dump_raw_ok()) {
+ 			u32 __user *user_lens;
+ 			u32 func_len, i;
+ 
+ 			/* copy the JITed image lengths for each function */
+ 			ulen = min_t(u32, info.nr_jited_func_lens, ulen);
+ 			user_lens = u64_to_user_ptr(info.jited_func_lens);
+ 			for (i = 0; i < ulen; i++) {
+ 				func_len = prog->aux->func[i]->jited_len;
+ 				if (put_user(func_len, &user_lens[i]))
+ 					return -EFAULT;
+ 			}
+ 		} else {
+ 			info.jited_func_lens = 0;
+ 		}
+ 	}
+ 
++>>>>>>> 815581c11cc2 (bpf: get JITed image lengths of functions via syscall)
  done:
  	if (copy_to_user(uinfo, &info, info_len) ||
  	    put_user(info_len, &uattr->info.info_len))
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path kernel/bpf/syscall.c
