nfp: flower: fix multiple keys per pedit action

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
commit d08c9e589300b015e72e5b41ff4dfed6eb8e7421
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/d08c9e58.failed

Previously we only allowed a single header key per pedit action to
change the header. This used to result in the last header key in the
pedit action to overwrite previous headers. We now keep track of them
and allow multiple header keys per pedit action.

Fixes: c0b1bd9a8b8a ("nfp: add set ipv4 header action flower offload")
Fixes: 354b82bb320e ("nfp: add set ipv6 source and destination address")
Fixes: f8b7b0a6b113 ("nfp: add set tcp and udp header action flower offload")
	Signed-off-by: Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d08c9e589300b015e72e5b41ff4dfed6eb8e7421)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/flower/action.c
diff --cc drivers/net/ethernet/netronome/nfp/flower/action.c
index 87a2048a497a,c39d7fdf73e6..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/action.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/action.c
@@@ -458,8 -544,9 +458,8 @@@ nfp_fl_pedit(const struct tc_action *ac
  	struct nfp_fl_set_eth set_eth;
  	enum pedit_header_type htype;
  	int idx, nkeys, err;
- 	size_t act_size;
+ 	size_t act_size = 0;
  	u32 offset, cmd;
 -	u8 ip_proto = 0;
  
  	memset(&set_ip6_dst, 0, sizeof(set_ip6_dst));
  	memset(&set_ip6_src, 0, sizeof(set_ip6_src));
@@@ -510,7 -608,12 +512,16 @@@
  		act_size = sizeof(set_ip_addr);
  		memcpy(nfp_action, &set_ip_addr, act_size);
  		*a_len += act_size;
++<<<<<<< HEAD
 +	} else if (set_ip6_dst.head.len_lw && set_ip6_src.head.len_lw) {
++=======
+ 
+ 		/* Hardware will automatically fix IPv4 and TCP/UDP checksum. */
+ 		*csum_updated |= TCA_CSUM_UPDATE_FLAG_IPV4HDR |
+ 				nfp_fl_csum_l4_to_flag(ip_proto);
+ 	}
+ 	if (set_ip6_dst.head.len_lw && set_ip6_src.head.len_lw) {
++>>>>>>> d08c9e589300 (nfp: flower: fix multiple keys per pedit action)
  		/* TC compiles set src and dst IPv6 address as a single action,
  		 * the hardware requires this to be 2 separate actions.
  		 */
@@@ -522,15 -626,28 +534,26 @@@
  		memcpy(&nfp_action[sizeof(set_ip6_src)], &set_ip6_dst,
  		       act_size);
  		*a_len += act_size;
 -
 -		/* Hardware will automatically fix TCP/UDP checksum. */
 -		*csum_updated |= nfp_fl_csum_l4_to_flag(ip_proto);
  	} else if (set_ip6_dst.head.len_lw) {
+ 		nfp_action += act_size;
  		act_size = sizeof(set_ip6_dst);
  		memcpy(nfp_action, &set_ip6_dst, act_size);
  		*a_len += act_size;
 -
 -		/* Hardware will automatically fix TCP/UDP checksum. */
 -		*csum_updated |= nfp_fl_csum_l4_to_flag(ip_proto);
  	} else if (set_ip6_src.head.len_lw) {
+ 		nfp_action += act_size;
  		act_size = sizeof(set_ip6_src);
  		memcpy(nfp_action, &set_ip6_src, act_size);
  		*a_len += act_size;
++<<<<<<< HEAD
 +	} else if (set_tport.head.len_lw) {
++=======
+ 
+ 		/* Hardware will automatically fix TCP/UDP checksum. */
+ 		*csum_updated |= nfp_fl_csum_l4_to_flag(ip_proto);
+ 	}
+ 	if (set_tport.head.len_lw) {
+ 		nfp_action += act_size;
++>>>>>>> d08c9e589300 (nfp: flower: fix multiple keys per pedit action)
  		act_size = sizeof(set_tport);
  		memcpy(nfp_action, &set_tport, act_size);
  		*a_len += act_size;
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/action.c
