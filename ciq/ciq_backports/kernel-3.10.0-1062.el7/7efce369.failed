IB/mlx5: Add obj create and destroy functionality

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Yishai Hadas <yishaih@mellanox.com>
commit 7efce3691d33e1f4263a7c64e8ff39b12922509b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7efce369.failed

Add support to create and destroy firmware objects via the DEVX
interface.

	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 7efce3691d33e1f4263a7c64e8ff39b12922509b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
#	drivers/infiniband/hw/mlx5/devx.c
diff --cc drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
index 1d7bd82a1fb1,8d285f4555cd..000000000000
--- a/drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
+++ b/drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
@@@ -30,33 -30,48 +30,71 @@@
   * SOFTWARE.
   */
  
 -#ifndef MLX5_USER_IOCTL_CMDS_H
 -#define MLX5_USER_IOCTL_CMDS_H
 +/*
 + * This file is conditionally built on PowerPC only.  Otherwise weak symbol
 + * versions of the functions exported from here are used.
 + */
  
 -#include <rdma/ib_user_ioctl_cmds.h>
 +#include "ipath_kernel.h"
  
 -enum mlx5_ib_create_flow_action_attrs {
 -	/* This attribute belong to the driver namespace */
 -	MLX5_IB_ATTR_CREATE_FLOW_ACTION_FLAGS = (1U << UVERBS_ID_NS_SHIFT),
 -};
 +/**
 + * ipath_enable_wc - enable write combining for MMIO writes to the device
 + * @dd: infinipath device
 + *
 + * Nothing to do on PowerPC, so just return without error.
 + */
 +int ipath_enable_wc(struct ipath_devdata *dd)
 +{
 +	return 0;
 +}
  
++<<<<<<< HEAD:drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
 +/**
 + * ipath_unordered_wc - indicate whether write combining is unordered
 + *
 + * Because our performance depends on our ability to do write
 + * combining mmio writes in the most efficient way, we need to
 + * know if we are on a processor that may reorder stores when
 + * write combining.
 + */
 +int ipath_unordered_wc(void)
 +{
 +	return 1;
 +}
++=======
+ enum mlx5_ib_alloc_dm_attrs {
+ 	MLX5_IB_ATTR_ALLOC_DM_RESP_START_OFFSET = (1U << UVERBS_ID_NS_SHIFT),
+ 	MLX5_IB_ATTR_ALLOC_DM_RESP_PAGE_INDEX,
+ };
+ 
+ enum mlx5_ib_devx_methods {
+ 	MLX5_IB_METHOD_DEVX_OTHER  = (1U << UVERBS_ID_NS_SHIFT),
+ };
+ 
+ enum  mlx5_ib_devx_other_attrs {
+ 	MLX5_IB_ATTR_DEVX_OTHER_CMD_IN = (1U << UVERBS_ID_NS_SHIFT),
+ 	MLX5_IB_ATTR_DEVX_OTHER_CMD_OUT,
+ };
+ 
+ enum mlx5_ib_devx_obj_create_attrs {
+ 	MLX5_IB_ATTR_DEVX_OBJ_CREATE_HANDLE = (1U << UVERBS_ID_NS_SHIFT),
+ 	MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_IN,
+ 	MLX5_IB_ATTR_DEVX_OBJ_CREATE_CMD_OUT,
+ };
+ 
+ enum mlx5_ib_devx_obj_destroy_attrs {
+ 	MLX5_IB_ATTR_DEVX_OBJ_DESTROY_HANDLE = (1U << UVERBS_ID_NS_SHIFT),
+ };
+ 
+ enum mlx5_ib_devx_obj_methods {
+ 	MLX5_IB_METHOD_DEVX_OBJ_CREATE = (1U << UVERBS_ID_NS_SHIFT),
+ 	MLX5_IB_METHOD_DEVX_OBJ_DESTROY,
+ };
+ 
+ enum mlx5_ib_devx_objects {
+ 	MLX5_IB_OBJECT_DEVX = (1U << UVERBS_ID_NS_SHIFT),
+ 	MLX5_IB_OBJECT_DEVX_OBJ,
+ };
+ 
+ #endif
++>>>>>>> 7efce3691d33 (IB/mlx5: Add obj create and destroy functionality):include/uapi/rdma/mlx5_user_ioctl_cmds.h
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
