ALSA: hda/ca0132 - Remove input select enum for ZxR

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Connor McAdams <conmanx360@gmail.com>
commit 76dea4dbf06bd49557a1dcc4c54f3ada88d8c8a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/76dea4db.failed

This patch removes the input select control for the ZxR, as it only has
one input option, rear microphone.

	Signed-off-by: Connor McAdams <conmanx360@gmail.com>
	Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 76dea4dbf06bd49557a1dcc4c54f3ada88d8c8a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index 5992a3b4cc50,f0781e4b0da9..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -4018,229 -6829,303 +4018,252 @@@ static int add_voicefx(struct hda_code
  }
  
  /*
 - * Sets the source of stream 0x14 to connpointID 0x48, and the destination
 - * connpointID to 0x91. If this isn't done, the destination is 0x71, and
 - * you get no sound. I'm guessing this has to do with the Sound Blaster Z
 - * having an updated DAC, which changes the destination to that DAC.
 + * When changing Node IDs for Mixer Controls below, make sure to update
 + * Node IDs in ca0132_config() as well.
   */
 -static void sbz_connect_streams(struct hda_codec *codec)
 -{
 -	struct ca0132_spec *spec = codec->spec;
 -
 -	mutex_lock(&spec->chipio_mutex);
 -
 -	codec_dbg(codec, "Connect Streams entered, mutex locked and loaded.\n");
 -
 -	chipio_set_stream_channels(codec, 0x0C, 6);
 -	chipio_set_stream_control(codec, 0x0C, 1);
 -
 -	/* This value is 0x43 for 96khz, and 0x83 for 192khz. */
 -	chipio_write_no_mutex(codec, 0x18a020, 0x00000043);
 -
 -	/* Setup stream 0x14 with it's source and destination points */
 -	chipio_set_stream_source_dest(codec, 0x14, 0x48, 0x91);
 -	chipio_set_conn_rate_no_mutex(codec, 0x48, SR_96_000);
 -	chipio_set_conn_rate_no_mutex(codec, 0x91, SR_96_000);
 -	chipio_set_stream_channels(codec, 0x14, 2);
 -	chipio_set_stream_control(codec, 0x14, 1);
 -
 -	codec_dbg(codec, "Connect Streams exited, mutex released.\n");
 -
 -	mutex_unlock(&spec->chipio_mutex);
 -}
 +static struct snd_kcontrol_new ca0132_mixer[] = {
 +	CA0132_CODEC_VOL("Master Playback Volume", VNID_SPK, HDA_OUTPUT),
 +	CA0132_CODEC_MUTE("Master Playback Switch", VNID_SPK, HDA_OUTPUT),
 +	CA0132_CODEC_VOL("Capture Volume", VNID_MIC, HDA_INPUT),
 +	CA0132_CODEC_MUTE("Capture Switch", VNID_MIC, HDA_INPUT),
 +	HDA_CODEC_VOLUME("Analog-Mic2 Capture Volume", 0x08, 0, HDA_INPUT),
 +	HDA_CODEC_MUTE("Analog-Mic2 Capture Switch", 0x08, 0, HDA_INPUT),
 +	HDA_CODEC_VOLUME("What U Hear Capture Volume", 0x0a, 0, HDA_INPUT),
 +	HDA_CODEC_MUTE("What U Hear Capture Switch", 0x0a, 0, HDA_INPUT),
 +	CA0132_CODEC_MUTE_MONO("Mic1-Boost (30dB) Capture Switch",
 +			       0x12, 1, HDA_INPUT),
 +	CA0132_CODEC_MUTE_MONO("HP/Speaker Playback Switch",
 +			       VNID_HP_SEL, 1, HDA_OUTPUT),
 +	CA0132_CODEC_MUTE_MONO("AMic1/DMic Capture Switch",
 +			       VNID_AMIC1_SEL, 1, HDA_INPUT),
 +	CA0132_CODEC_MUTE_MONO("HP/Speaker Auto Detect Playback Switch",
 +			       VNID_HP_ASEL, 1, HDA_OUTPUT),
 +	CA0132_CODEC_MUTE_MONO("AMic1/DMic Auto Detect Capture Switch",
 +			       VNID_AMIC1_ASEL, 1, HDA_INPUT),
 +	{ } /* end */
 +};
  
 -/*
 - * Write data through ChipIO to setup proper stream destinations.
 - * Not sure how it exactly works, but it seems to direct data
 - * to different destinations. Example is f8 to c0, e0 to c0.
 - * All I know is, if you don't set these, you get no sound.
 - */
 -static void sbz_chipio_startup_data(struct hda_codec *codec)
 +static int ca0132_build_controls(struct hda_codec *codec)
  {
  	struct ca0132_spec *spec = codec->spec;
 +	int i, num_fx;
 +	int err = 0;
  
 -	mutex_lock(&spec->chipio_mutex);
 -	codec_dbg(codec, "Startup Data entered, mutex locked and loaded.\n");
 -
 -	/* These control audio output */
 -	chipio_write_no_mutex(codec, 0x190060, 0x0001f8c0);
 -	chipio_write_no_mutex(codec, 0x190064, 0x0001f9c1);
 -	chipio_write_no_mutex(codec, 0x190068, 0x0001fac6);
 -	chipio_write_no_mutex(codec, 0x19006c, 0x0001fbc7);
 -	/* Signal to update I think */
 -	chipio_write_no_mutex(codec, 0x19042c, 0x00000001);
 -
 -	chipio_set_stream_channels(codec, 0x0C, 6);
 -	chipio_set_stream_control(codec, 0x0C, 1);
 -	/* No clue what these control */
 -	if (spec->quirk == QUIRK_SBZ) {
 -		chipio_write_no_mutex(codec, 0x190030, 0x0001e0c0);
 -		chipio_write_no_mutex(codec, 0x190034, 0x0001e1c1);
 -		chipio_write_no_mutex(codec, 0x190038, 0x0001e4c2);
 -		chipio_write_no_mutex(codec, 0x19003c, 0x0001e5c3);
 -		chipio_write_no_mutex(codec, 0x190040, 0x0001e2c4);
 -		chipio_write_no_mutex(codec, 0x190044, 0x0001e3c5);
 -		chipio_write_no_mutex(codec, 0x190048, 0x0001e8c6);
 -		chipio_write_no_mutex(codec, 0x19004c, 0x0001e9c7);
 -		chipio_write_no_mutex(codec, 0x190050, 0x0001ecc8);
 -		chipio_write_no_mutex(codec, 0x190054, 0x0001edc9);
 -		chipio_write_no_mutex(codec, 0x190058, 0x0001eaca);
 -		chipio_write_no_mutex(codec, 0x19005c, 0x0001ebcb);
 -	} else if (spec->quirk == QUIRK_ZXR) {
 -		chipio_write_no_mutex(codec, 0x190038, 0x000140c2);
 -		chipio_write_no_mutex(codec, 0x19003c, 0x000141c3);
 -		chipio_write_no_mutex(codec, 0x190040, 0x000150c4);
 -		chipio_write_no_mutex(codec, 0x190044, 0x000151c5);
 -		chipio_write_no_mutex(codec, 0x190050, 0x000142c8);
 -		chipio_write_no_mutex(codec, 0x190054, 0x000143c9);
 -		chipio_write_no_mutex(codec, 0x190058, 0x000152ca);
 -		chipio_write_no_mutex(codec, 0x19005c, 0x000153cb);
 +	/* Add Mixer controls */
 +	for (i = 0; i < spec->num_mixers; i++) {
 +		err = snd_hda_add_new_ctls(codec, spec->mixers[i]);
 +		if (err < 0)
 +			return err;
  	}
 -	chipio_write_no_mutex(codec, 0x19042c, 0x00000001);
 -
 -	codec_dbg(codec, "Startup Data exited, mutex released.\n");
 -	mutex_unlock(&spec->chipio_mutex);
 -}
 -
 -/*
 - * Custom DSP SCP commands where the src value is 0x00 instead of 0x20. This is
 - * done after the DSP is loaded.
 - */
 -static void ca0132_alt_dsp_scp_startup(struct hda_codec *codec)
 -{
 -	struct ca0132_spec *spec = codec->spec;
 -	unsigned int tmp;
  
 -	switch (spec->quirk) {
 -	case QUIRK_SBZ:
 -	case QUIRK_AE5:
 -		tmp = 0x00000003;
 -		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
 -		tmp = 0x00000000;
 -		dspio_set_uint_param_no_source(codec, 0x80, 0x0A, tmp);
 -		tmp = 0x00000001;
 -		dspio_set_uint_param_no_source(codec, 0x80, 0x0B, tmp);
 -		tmp = 0x00000004;
 -		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
 -		tmp = 0x00000005;
 -		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
 -		tmp = 0x00000000;
 -		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
 -		break;
 -	case QUIRK_R3D:
 -	case QUIRK_R3DI:
 -		tmp = 0x00000000;
 -		dspio_set_uint_param_no_source(codec, 0x80, 0x0A, tmp);
 -		tmp = 0x00000001;
 -		dspio_set_uint_param_no_source(codec, 0x80, 0x0B, tmp);
 -		tmp = 0x00000004;
 -		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
 -		tmp = 0x00000005;
 -		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
 -		tmp = 0x00000000;
 -		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
 -		break;
 +	/* Add in and out effects controls.
 +	 * VoiceFX, PE and CrystalVoice are added separately.
 +	 */
 +	num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT;
 +	for (i = 0; i < num_fx; i++) {
 +		err = add_fx_switch(codec, ca0132_effects[i].nid,
 +				    ca0132_effects[i].name,
 +				    ca0132_effects[i].direct);
 +		if (err < 0)
 +			return err;
  	}
 -}
 -
 -static void ca0132_alt_dsp_initial_mic_setup(struct hda_codec *codec)
 -{
 -	struct ca0132_spec *spec = codec->spec;
 -	unsigned int tmp;
 -
 -	chipio_set_stream_control(codec, 0x03, 0);
 -	chipio_set_stream_control(codec, 0x04, 0);
  
 -	chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
 -	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
 +	err = add_fx_switch(codec, PLAY_ENHANCEMENT, "PlayEnhancement", 0);
 +	if (err < 0)
 +		return err;
  
 -	tmp = FLOAT_THREE;
 -	dspio_set_uint_param(codec, 0x80, 0x00, tmp);
 +	err = add_fx_switch(codec, CRYSTAL_VOICE, "CrystalVoice", 1);
 +	if (err < 0)
 +		return err;
  
 -	chipio_set_stream_control(codec, 0x03, 1);
 -	chipio_set_stream_control(codec, 0x04, 1);
 +	add_voicefx(codec);
  
 -	switch (spec->quirk) {
 -	case QUIRK_SBZ:
 -		chipio_write(codec, 0x18b098, 0x0000000c);
 -		chipio_write(codec, 0x18b09C, 0x0000000c);
 -		break;
 -	case QUIRK_AE5:
 -		chipio_write(codec, 0x18b098, 0x0000000c);
 -		chipio_write(codec, 0x18b09c, 0x0000004c);
 -		break;
++<<<<<<< HEAD
++=======
++	/*
++	 * If the codec uses alt_functions, you need the enumerated controls
++	 * to select the new outputs and inputs, plus add the new mic boost
++	 * setting control.
++	 */
++	if (spec->use_alt_functions) {
++		ca0132_alt_add_output_enum(codec);
++		ca0132_alt_add_mic_boost_enum(codec);
++		/*
++		 * ZxR only has microphone input, there is no front panel
++		 * header on the card, and aux-in is handled by the DBPro board.
++		 */
++		if (spec->quirk != QUIRK_ZXR)
++			ca0132_alt_add_input_enum(codec);
+ 	}
 -}
 -
 -static void ae5_post_dsp_register_set(struct hda_codec *codec)
 -{
 -	struct ca0132_spec *spec = codec->spec;
+ 
 -	chipio_8051_write_direct(codec, 0x93, 0x10);
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x44);
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc2);
 -
 -	writeb(0xff, spec->mem_base + 0x304);
 -	writeb(0xff, spec->mem_base + 0x304);
 -	writeb(0xff, spec->mem_base + 0x304);
 -	writeb(0xff, spec->mem_base + 0x304);
 -	writeb(0x00, spec->mem_base + 0x100);
 -	writeb(0xff, spec->mem_base + 0x304);
 -	writeb(0x00, spec->mem_base + 0x100);
 -	writeb(0xff, spec->mem_base + 0x304);
 -	writeb(0x00, spec->mem_base + 0x100);
 -	writeb(0xff, spec->mem_base + 0x304);
 -	writeb(0x00, spec->mem_base + 0x100);
 -	writeb(0xff, spec->mem_base + 0x304);
 -
 -	ca0113_mmio_command_set(codec, 0x30, 0x2b, 0x3f);
 -	ca0113_mmio_command_set(codec, 0x30, 0x2d, 0x3f);
 -	ca0113_mmio_command_set(codec, 0x48, 0x07, 0x83);
 -}
++	if (spec->quirk == QUIRK_AE5) {
++		ae5_add_headphone_gain_enum(codec);
++		ae5_add_sound_filter_enum(codec);
++	}
++>>>>>>> 76dea4dbf06b (ALSA: hda/ca0132 - Remove input select enum for ZxR)
 +#ifdef ENABLE_TUNING_CONTROLS
 +	add_tuning_ctls(codec);
 +#endif
  
 -static void ae5_post_dsp_param_setup(struct hda_codec *codec)
 -{
 -	/*
 -	 * Param3 in the 8051's memory is represented by the ascii string 'mch'
 -	 * which seems to be 'multichannel'. This is also mentioned in the
 -	 * AE-5's registry values in Windows.
 -	 */
 -	chipio_set_control_param(codec, 3, 0);
 -	/*
 -	 * I believe ASI is 'audio serial interface' and that it's used to
 -	 * change colors on the external LED strip connected to the AE-5.
 -	 */
 -	chipio_set_control_flag(codec, CONTROL_FLAG_ASI_96KHZ, 1);
 +	err = snd_hda_jack_add_kctls(codec, &spec->gen.autocfg);
 +	if (err < 0)
 +		return err;
  
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0, 0x724, 0x83);
 -	chipio_set_control_param(codec, CONTROL_PARAM_ASI, 0);
 +	if (spec->dig_out) {
 +		err = snd_hda_create_spdif_out_ctls(codec, spec->dig_out,
 +						    spec->dig_out);
 +		if (err < 0)
 +			return err;
 +		err = snd_hda_create_spdif_share_sw(codec, &spec->multiout);
 +		if (err < 0)
 +			return err;
 +		/* spec->multiout.share_spdif = 1; */
 +	}
  
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x92);
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_8051_ADDRESS_HIGH, 0xfa);
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_8051_DATA_WRITE, 0x22);
 +	if (spec->dig_in) {
 +		err = snd_hda_create_spdif_in_ctls(codec, spec->dig_in);
 +		if (err < 0)
 +			return err;
 +	}
 +	return 0;
  }
  
 -static void ae5_post_dsp_pll_setup(struct hda_codec *codec)
 -{
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x41);
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc8);
 -
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x45);
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xcc);
 +/*
 + * PCM
 + */
 +static const struct hda_pcm_stream ca0132_pcm_analog_playback = {
 +	.substreams = 1,
 +	.channels_min = 2,
 +	.channels_max = 6,
 +	.ops = {
 +		.prepare = ca0132_playback_pcm_prepare,
 +		.cleanup = ca0132_playback_pcm_cleanup,
 +		.get_delay = ca0132_playback_pcm_delay,
 +	},
 +};
  
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x40);
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xcb);
 +static const struct hda_pcm_stream ca0132_pcm_analog_capture = {
 +	.substreams = 1,
 +	.channels_min = 2,
 +	.channels_max = 2,
 +	.ops = {
 +		.prepare = ca0132_capture_pcm_prepare,
 +		.cleanup = ca0132_capture_pcm_cleanup,
 +		.get_delay = ca0132_capture_pcm_delay,
 +	},
 +};
  
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x43);
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc7);
 +static const struct hda_pcm_stream ca0132_pcm_digital_playback = {
 +	.substreams = 1,
 +	.channels_min = 2,
 +	.channels_max = 2,
 +	.ops = {
 +		.open = ca0132_dig_playback_pcm_open,
 +		.close = ca0132_dig_playback_pcm_close,
 +		.prepare = ca0132_dig_playback_pcm_prepare,
 +		.cleanup = ca0132_dig_playback_pcm_cleanup
 +	},
 +};
  
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x51);
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0x8d);
 -}
 +static const struct hda_pcm_stream ca0132_pcm_digital_capture = {
 +	.substreams = 1,
 +	.channels_min = 2,
 +	.channels_max = 2,
 +};
  
 -static void ae5_post_dsp_stream_setup(struct hda_codec *codec)
 +static int ca0132_build_pcms(struct hda_codec *codec)
  {
  	struct ca0132_spec *spec = codec->spec;
 +	struct hda_pcm *info;
  
 -	mutex_lock(&spec->chipio_mutex);
 -
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0, 0x725, 0x81);
 -
 -	chipio_set_conn_rate_no_mutex(codec, 0x70, SR_96_000);
 -
 -	chipio_set_stream_channels(codec, 0x0C, 6);
 -	chipio_set_stream_control(codec, 0x0C, 1);
 -
 -	chipio_set_stream_source_dest(codec, 0x5, 0x43, 0x0);
 +	info = snd_hda_codec_pcm_new(codec, "CA0132 Analog");
 +	if (!info)
 +		return -ENOMEM;
 +	info->stream[SNDRV_PCM_STREAM_PLAYBACK] = ca0132_pcm_analog_playback;
 +	info->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = spec->dacs[0];
 +	info->stream[SNDRV_PCM_STREAM_PLAYBACK].channels_max =
 +		spec->multiout.max_channels;
 +	info->stream[SNDRV_PCM_STREAM_CAPTURE] = ca0132_pcm_analog_capture;
 +	info->stream[SNDRV_PCM_STREAM_CAPTURE].substreams = 1;
 +	info->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adcs[0];
  
 -	chipio_set_stream_source_dest(codec, 0x18, 0x9, 0xd0);
 -	chipio_set_conn_rate_no_mutex(codec, 0xd0, SR_96_000);
 -	chipio_set_stream_channels(codec, 0x18, 6);
 -	chipio_set_stream_control(codec, 0x18, 1);
 +	info = snd_hda_codec_pcm_new(codec, "CA0132 Analog Mic-In2");
 +	if (!info)
 +		return -ENOMEM;
 +	info->stream[SNDRV_PCM_STREAM_CAPTURE] = ca0132_pcm_analog_capture;
 +	info->stream[SNDRV_PCM_STREAM_CAPTURE].substreams = 1;
 +	info->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adcs[1];
  
 -	chipio_set_control_param_no_mutex(codec, CONTROL_PARAM_ASI, 4);
 +	info = snd_hda_codec_pcm_new(codec, "CA0132 What U Hear");
 +	if (!info)
 +		return -ENOMEM;
 +	info->stream[SNDRV_PCM_STREAM_CAPTURE] = ca0132_pcm_analog_capture;
 +	info->stream[SNDRV_PCM_STREAM_CAPTURE].substreams = 1;
 +	info->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adcs[2];
  
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x43);
 -	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
 -			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc7);
 +	if (!spec->dig_out && !spec->dig_in)
 +		return 0;
  
 -	ca0113_mmio_command_set(codec, 0x48, 0x01, 0x80);
 +	info = snd_hda_codec_pcm_new(codec, "CA0132 Digital");
 +	if (!info)
 +		return -ENOMEM;
 +	info->pcm_type = HDA_PCM_TYPE_SPDIF;
 +	if (spec->dig_out) {
 +		info->stream[SNDRV_PCM_STREAM_PLAYBACK] =
 +			ca0132_pcm_digital_playback;
 +		info->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = spec->dig_out;
 +	}
 +	if (spec->dig_in) {
 +		info->stream[SNDRV_PCM_STREAM_CAPTURE] =
 +			ca0132_pcm_digital_capture;
 +		info->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->dig_in;
 +	}
  
 -	mutex_unlock(&spec->chipio_mutex);
 +	return 0;
  }
  
 -static void ae5_post_dsp_startup_data(struct hda_codec *codec)
 +static void init_output(struct hda_codec *codec, hda_nid_t pin, hda_nid_t dac)
  {
 -	struct ca0132_spec *spec = codec->spec;
 -
 -	mutex_lock(&spec->chipio_mutex);
 +	if (pin) {
 +		snd_hda_set_pin_ctl(codec, pin, PIN_HP);
 +		if (get_wcaps(codec, pin) & AC_WCAP_OUT_AMP)
 +			snd_hda_codec_write(codec, pin, 0,
 +					    AC_VERB_SET_AMP_GAIN_MUTE,
 +					    AMP_OUT_UNMUTE);
 +	}
 +	if (dac && (get_wcaps(codec, dac) & AC_WCAP_OUT_AMP))
 +		snd_hda_codec_write(codec, dac, 0,
 +				    AC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO);
 +}
  
 -	chipio_write_no_mutex(codec, 0x189000, 0x0001f101);
 -	chipio_write_no_mutex(codec, 0x189004, 0x0001f101);
 -	chipio_write_no_mutex(codec, 0x189024, 0x00014004);
 -	chipio_write_no_mutex(codec, 0x189028, 0x0002000f);
 -
 -	ca0113_mmio_command_set(codec, 0x48, 0x0a, 0x05);
 -	chipio_set_control_param_no_mutex(codec, CONTROL_PARAM_ASI, 7);
 -	ca0113_mmio_command_set(codec, 0x48, 0x0b, 0x12);
 -	ca0113_mmio_command_set(codec, 0x48, 0x04, 0x00);
 -	ca0113_mmio_command_set(codec, 0x48, 0x06, 0x48);
 -	ca0113_mmio_command_set(codec, 0x48, 0x0a, 0x05);
 -	ca0113_mmio_command_set(codec, 0x48, 0x07, 0x83);
 -	ca0113_mmio_command_set(codec, 0x48, 0x0f, 0x00);
 -	ca0113_mmio_command_set(codec, 0x48, 0x10, 0x00);
 -	ca0113_mmio_gpio_set(codec, 0, true);
 -	ca0113_mmio_gpio_set(codec, 1, true);
 -	ca0113_mmio_command_set(codec, 0x48, 0x07, 0x80);
 +static void init_input(struct hda_codec *codec, hda_nid_t pin, hda_nid_t adc)
 +{
 +	if (pin) {
 +		snd_hda_set_pin_ctl(codec, pin, PIN_VREF80);
 +		if (get_wcaps(codec, pin) & AC_WCAP_IN_AMP)
 +			snd_hda_codec_write(codec, pin, 0,
 +					    AC_VERB_SET_AMP_GAIN_MUTE,
 +					    AMP_IN_UNMUTE(0));
 +	}
 +	if (adc && (get_wcaps(codec, adc) & AC_WCAP_IN_AMP)) {
 +		snd_hda_codec_write(codec, adc, 0, AC_VERB_SET_AMP_GAIN_MUTE,
 +				    AMP_IN_UNMUTE(0));
  
 -	chipio_write_no_mutex(codec, 0x18b03c, 0x00000012);
 +		/* init to 0 dB and unmute. */
 +		snd_hda_codec_amp_stereo(codec, adc, HDA_INPUT, 0,
 +					 HDA_AMP_VOLMASK, 0x5a);
 +		snd_hda_codec_amp_stereo(codec, adc, HDA_INPUT, 0,
 +					 HDA_AMP_MUTE, 0);
 +	}
 +}
  
 -	ca0113_mmio_command_set(codec, 0x48, 0x0f, 0x00);
 -	ca0113_mmio_command_set(codec, 0x48, 0x10, 0x00);
 +static void refresh_amp_caps(struct hda_codec *codec, hda_nid_t nid, int dir)
 +{
 +	unsigned int caps;
  
 -	mutex_unlock(&spec->chipio_mutex);
 +	caps = snd_hda_param_read(codec, nid, dir == HDA_OUTPUT ?
 +				  AC_PAR_AMP_OUT_CAP : AC_PAR_AMP_IN_CAP);
 +	snd_hda_override_amp_caps(codec, nid, dir, caps);
  }
  
  /*
* Unmerged path sound/pci/hda/patch_ca0132.c
