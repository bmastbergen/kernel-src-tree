fs/proc/task_mmu.c: do not show VmExe bigger than total executable virtual memory

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [fs] task_mmu.c: do not show VmExe bigger than total executable virtual memory (Rafael Aquini) [1690946]
Rebuild_FUZZ: 94.81%
commit-author Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
commit 8526d84f81710c77ead9a7bfe82b66a241f1aed1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/8526d84f.failed

If start_code / end_code pointers are screwed then "VmExe" could be
bigger than total executable virtual memory and "VmLib" becomes
negative:

  VmExe:	  294320 kB
  VmLib:	18446744073709327564 kB

VmExe and VmLib documented as text segment and shared library code size.

Now their sum will be always equal to mm->exec_vm which sums size of
executable and not writable and not stack areas.

I've seen this for huge (>2Gb) statically linked binary which has whole
world inside.  For it start_code ..  end_code range also covers one of
rodata sections.  Probably this is bug in customized linker, elf loader
or both.

Anyway CONFIG_CHECKPOINT_RESTORE allows to change these pointers, thus
we cannot trust them without validation.

Link: http://lkml.kernel.org/r/150728955451.743749.11276392315459539583.stgit@buzz
	Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
	Acked-by: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8526d84f81710c77ead9a7bfe82b66a241f1aed1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/task_mmu.c
diff --cc fs/proc/task_mmu.c
index bf81d9f4a02e,4691f5aca00e..000000000000
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@@ -42,9 -47,11 +42,17 @@@ void task_mem(struct seq_file *m, struc
  	if (hiwater_rss < mm->hiwater_rss)
  		hiwater_rss = mm->hiwater_rss;
  
++<<<<<<< HEAD
 +	data = mm->total_vm - mm->shared_vm - mm->stack_vm;
 +	text = (PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK)) >> 10;
 +	lib = (mm->exec_vm << (PAGE_SHIFT-10)) - text;
++=======
+ 	/* split executable areas between text and lib */
+ 	text = PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK);
+ 	text = min(text, mm->exec_vm << PAGE_SHIFT);
+ 	lib = (mm->exec_vm << PAGE_SHIFT) - text;
+ 
++>>>>>>> 8526d84f8171 (fs/proc/task_mmu.c: do not show VmExe bigger than total executable virtual memory)
  	swap = get_mm_counter(mm, MM_SWAPENTS);
  	seq_printf(m,
  		"VmPeak:\t%8lu kB\n"
@@@ -71,11 -78,13 +79,19 @@@
  		anon << (PAGE_SHIFT-10),
  		file << (PAGE_SHIFT-10),
  		shmem << (PAGE_SHIFT-10),
++<<<<<<< HEAD
 +		data << (PAGE_SHIFT-10),
 +		mm->stack_vm << (PAGE_SHIFT-10), text, lib,
 +		(PTRS_PER_PTE * sizeof(pte_t) *
 +		 atomic_long_read(&mm->nr_ptes)) >> 10,
++=======
+ 		mm->data_vm << (PAGE_SHIFT-10),
+ 		mm->stack_vm << (PAGE_SHIFT-10),
+ 		text >> 10,
+ 		lib >> 10,
+ 		mm_pgtables_bytes(mm) >> 10,
++>>>>>>> 8526d84f8171 (fs/proc/task_mmu.c: do not show VmExe bigger than total executable virtual memory)
  		swap << (PAGE_SHIFT-10));
 -	hugetlb_report_usage(m, mm);
  }
  
  unsigned long task_vsize(struct mm_struct *mm)
* Unmerged path fs/proc/task_mmu.c
