xfs: remove the nr_extents argument to xfs_iext_remove

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit c38ccf599022e7454a861145ce1a94c5b5d7e658
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c38ccf59.failed

We only have two places that remove 2 extents at the same time, so unroll
the loop there.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit c38ccf599022e7454a861145ce1a94c5b5d7e658)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/libxfs/xfs_iext_tree.c
#	fs/xfs/libxfs/xfs_inode_fork.h
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 59769f7334d7,e9fcb6d496a4..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -1647,15 -1643,14 +1647,25 @@@ xfs_bmap_add_extent_delay_real
  		 * Filling in all of a previously delayed allocation extent.
  		 * The left and right neighbors are both contiguous with new.
  		 */
++<<<<<<< HEAD
 +		bma->idx--;
 +		trace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);
 +		xfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),
 +			LEFT.br_blockcount + PREV.br_blockcount +
 +			RIGHT.br_blockcount);
 +		trace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);
++=======
+ 		LEFT.br_blockcount += PREV.br_blockcount + RIGHT.br_blockcount;
+ 
+ 		xfs_iext_remove(bma->ip, &bma->icur, state);
+ 		xfs_iext_remove(bma->ip, &bma->icur, state);
+ 		xfs_iext_prev(ifp, &bma->icur);
+ 		xfs_iext_update_extent(bma->ip, state, &bma->icur, &LEFT);
+ 		(*nextents)--;
++>>>>>>> c38ccf599022 (xfs: remove the nr_extents argument to xfs_iext_remove)
  
 +		xfs_iext_remove(bma->ip, bma->idx + 1, 2, state);
 +		bma->ip->i_d.di_nextents--;
  		if (bma->cur == NULL)
  			rval = XFS_ILOG_CORE | XFS_ILOG_DEXT;
  		else {
@@@ -1689,14 -1678,13 +1699,20 @@@
  		 * Filling in all of a previously delayed allocation extent.
  		 * The left neighbor is contiguous, the right is not.
  		 */
 -		old = LEFT;
 -		LEFT.br_blockcount += PREV.br_blockcount;
 -
 +		bma->idx--;
 +
++<<<<<<< HEAD
 +		trace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);
 +		xfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),
 +			LEFT.br_blockcount + PREV.br_blockcount);
 +		trace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);
++=======
+ 		xfs_iext_remove(bma->ip, &bma->icur, state);
+ 		xfs_iext_prev(ifp, &bma->icur);
+ 		xfs_iext_update_extent(bma->ip, state, &bma->icur, &LEFT);
++>>>>>>> c38ccf599022 (xfs: remove the nr_extents argument to xfs_iext_remove)
  
 +		xfs_iext_remove(bma->ip, bma->idx + 1, 1, state);
  		if (bma->cur == NULL)
  			rval = XFS_ILOG_DEXT;
  		else {
@@@ -1721,13 -1704,14 +1737,23 @@@
  		 * Filling in all of a previously delayed allocation extent.
  		 * The right neighbor is contiguous, the left is not.
  		 */
++<<<<<<< HEAD
 +		trace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);
 +		xfs_bmbt_set_startblock(ep, new->br_startblock);
 +		xfs_bmbt_set_blockcount(ep,
 +			PREV.br_blockcount + RIGHT.br_blockcount);
 +		trace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);
++=======
+ 		PREV.br_startblock = new->br_startblock;
+ 		PREV.br_blockcount += RIGHT.br_blockcount;
+ 
+ 		xfs_iext_next(ifp, &bma->icur);
+ 		xfs_iext_remove(bma->ip, &bma->icur, state);
+ 		xfs_iext_prev(ifp, &bma->icur);
+ 		xfs_iext_update_extent(bma->ip, state, &bma->icur, &PREV);
++>>>>>>> c38ccf599022 (xfs: remove the nr_extents argument to xfs_iext_remove)
  
 +		xfs_iext_remove(bma->ip, bma->idx + 1, 1, state);
  		if (bma->cur == NULL)
  			rval = XFS_ILOG_DEXT;
  		else {
@@@ -2198,14 -2143,12 +2224,21 @@@ xfs_bmap_add_extent_unwritten_real
  		 * Setting all of a previous oldext extent to newext.
  		 * The left and right neighbors are both contiguous with new.
  		 */
 +		--*idx;
 +
++<<<<<<< HEAD
 +		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
  		LEFT.br_blockcount += PREV.br_blockcount + RIGHT.br_blockcount;
 +		xfs_iext_update_extent(ifp, *idx, &LEFT);
 +		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
  
 +		xfs_iext_remove(ip, *idx + 1, 2, state);
++=======
+ 		xfs_iext_remove(ip, icur, state);
+ 		xfs_iext_remove(ip, icur, state);
+ 		xfs_iext_prev(ifp, icur);
+ 		xfs_iext_update_extent(ip, state, icur, &LEFT);
++>>>>>>> c38ccf599022 (xfs: remove the nr_extents argument to xfs_iext_remove)
  		XFS_IFORK_NEXT_SET(ip, whichfork,
  				XFS_IFORK_NEXTENTS(ip, whichfork) - 2);
  		if (cur == NULL)
@@@ -2242,14 -2182,11 +2275,20 @@@
  		 * Setting all of a previous oldext extent to newext.
  		 * The left neighbor is contiguous, the right is not.
  		 */
 +		--*idx;
 +
++<<<<<<< HEAD
 +		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
  		LEFT.br_blockcount += PREV.br_blockcount;
 +		xfs_iext_update_extent(ifp, *idx, &LEFT);
 +		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
  
 +		xfs_iext_remove(ip, *idx + 1, 1, state);
++=======
+ 		xfs_iext_remove(ip, icur, state);
+ 		xfs_iext_prev(ifp, icur);
+ 		xfs_iext_update_extent(ip, state, icur, &LEFT);
++>>>>>>> c38ccf599022 (xfs: remove the nr_extents argument to xfs_iext_remove)
  		XFS_IFORK_NEXT_SET(ip, whichfork,
  				XFS_IFORK_NEXTENTS(ip, whichfork) - 1);
  		if (cur == NULL)
@@@ -2280,13 -2214,14 +2319,21 @@@
  		 * Setting all of a previous oldext extent to newext.
  		 * The right neighbor is contiguous, the left is not.
  		 */
 +		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
  		PREV.br_blockcount += RIGHT.br_blockcount;
  		PREV.br_state = new->br_state;
 +		xfs_iext_update_extent(ifp, *idx, &PREV);
 +		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
  
++<<<<<<< HEAD
 +		xfs_iext_remove(ip, *idx + 1, 1, state);
++=======
+ 		xfs_iext_next(ifp, icur);
+ 		xfs_iext_remove(ip, icur, state);
+ 		xfs_iext_prev(ifp, icur);
+ 		xfs_iext_update_extent(ip, state, icur, &PREV);
+ 
++>>>>>>> c38ccf599022 (xfs: remove the nr_extents argument to xfs_iext_remove)
  		XFS_IFORK_NEXT_SET(ip, whichfork,
  				XFS_IFORK_NEXTENTS(ip, whichfork) - 1);
  		if (cur == NULL)
@@@ -2698,10 -2584,10 +2745,16 @@@ xfs_bmap_add_extent_hole_delay
  					 oldlen);
  		left.br_startblock = nullstartblock(newlen);
  		left.br_blockcount = temp;
 +		xfs_iext_update_extent(ifp, *idx, &left);
 +		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
  
++<<<<<<< HEAD
 +		xfs_iext_remove(ip, *idx + 1, 1, state);
++=======
+ 		xfs_iext_remove(ip, icur, state);
+ 		xfs_iext_prev(ifp, icur);
+ 		xfs_iext_update_extent(ip, state, icur, &left);
++>>>>>>> c38ccf599022 (xfs: remove the nr_extents argument to xfs_iext_remove)
  		break;
  
  	case BMAP_LEFT_CONTIG:
@@@ -2853,13 -2728,11 +2906,19 @@@ xfs_bmap_add_extent_hole_real
  		 * left and on the right.
  		 * Merge all three into a single extent record.
  		 */
 +		--*idx;
 +		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
  		left.br_blockcount += new->br_blockcount + right.br_blockcount;
 +		xfs_iext_update_extent(ifp, *idx, &left);
 +		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
  
++<<<<<<< HEAD
 +		xfs_iext_remove(ip, *idx + 1, 1, state);
++=======
+ 		xfs_iext_remove(ip, icur, state);
+ 		xfs_iext_prev(ifp, icur);
+ 		xfs_iext_update_extent(ip, state, icur, &left);
++>>>>>>> c38ccf599022 (xfs: remove the nr_extents argument to xfs_iext_remove)
  
  		XFS_IFORK_NEXT_SET(ip, whichfork,
  			XFS_IFORK_NEXTENTS(ip, whichfork) - 1);
@@@ -4641,15 -4629,212 +4700,215 @@@ xfs_bmap_split_indlen
  	return stolen;
  }
  
++<<<<<<< HEAD
++=======
+ int
+ xfs_bmap_del_extent_delay(
+ 	struct xfs_inode	*ip,
+ 	int			whichfork,
+ 	struct xfs_iext_cursor	*icur,
+ 	struct xfs_bmbt_irec	*got,
+ 	struct xfs_bmbt_irec	*del)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	struct xfs_bmbt_irec	new;
+ 	int64_t			da_old, da_new, da_diff = 0;
+ 	xfs_fileoff_t		del_endoff, got_endoff;
+ 	xfs_filblks_t		got_indlen, new_indlen, stolen;
+ 	int			state = xfs_bmap_fork_to_state(whichfork);
+ 	int			error = 0;
+ 	bool			isrt;
+ 
+ 	XFS_STATS_INC(mp, xs_del_exlist);
+ 
+ 	isrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);
+ 	del_endoff = del->br_startoff + del->br_blockcount;
+ 	got_endoff = got->br_startoff + got->br_blockcount;
+ 	da_old = startblockval(got->br_startblock);
+ 	da_new = 0;
+ 
+ 	ASSERT(del->br_blockcount > 0);
+ 	ASSERT(got->br_startoff <= del->br_startoff);
+ 	ASSERT(got_endoff >= del_endoff);
+ 
+ 	if (isrt) {
+ 		uint64_t rtexts = XFS_FSB_TO_B(mp, del->br_blockcount);
+ 
+ 		do_div(rtexts, mp->m_sb.sb_rextsize);
+ 		xfs_mod_frextents(mp, rtexts);
+ 	}
+ 
+ 	/*
+ 	 * Update the inode delalloc counter now and wait to update the
+ 	 * sb counters as we might have to borrow some blocks for the
+ 	 * indirect block accounting.
+ 	 */
+ 	error = xfs_trans_reserve_quota_nblks(NULL, ip,
+ 			-((long)del->br_blockcount), 0,
+ 			isrt ? XFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS);
+ 	if (error)
+ 		return error;
+ 	ip->i_delayed_blks -= del->br_blockcount;
+ 
+ 	if (got->br_startoff == del->br_startoff)
+ 		state |= BMAP_LEFT_FILLING;
+ 	if (got_endoff == del_endoff)
+ 		state |= BMAP_RIGHT_FILLING;
+ 
+ 	switch (state & (BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING)) {
+ 	case BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Matches the whole extent.  Delete the entry.
+ 		 */
+ 		xfs_iext_remove(ip, icur, state);
+ 		xfs_iext_prev(ifp, icur);
+ 		break;
+ 	case BMAP_LEFT_FILLING:
+ 		/*
+ 		 * Deleting the first part of the extent.
+ 		 */
+ 		got->br_startoff = del_endoff;
+ 		got->br_blockcount -= del->br_blockcount;
+ 		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip,
+ 				got->br_blockcount), da_old);
+ 		got->br_startblock = nullstartblock((int)da_new);
+ 		xfs_iext_update_extent(ip, state, icur, got);
+ 		break;
+ 	case BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Deleting the last part of the extent.
+ 		 */
+ 		got->br_blockcount = got->br_blockcount - del->br_blockcount;
+ 		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip,
+ 				got->br_blockcount), da_old);
+ 		got->br_startblock = nullstartblock((int)da_new);
+ 		xfs_iext_update_extent(ip, state, icur, got);
+ 		break;
+ 	case 0:
+ 		/*
+ 		 * Deleting the middle of the extent.
+ 		 *
+ 		 * Distribute the original indlen reservation across the two new
+ 		 * extents.  Steal blocks from the deleted extent if necessary.
+ 		 * Stealing blocks simply fudges the fdblocks accounting below.
+ 		 * Warn if either of the new indlen reservations is zero as this
+ 		 * can lead to delalloc problems.
+ 		 */
+ 		got->br_blockcount = del->br_startoff - got->br_startoff;
+ 		got_indlen = xfs_bmap_worst_indlen(ip, got->br_blockcount);
+ 
+ 		new.br_blockcount = got_endoff - del_endoff;
+ 		new_indlen = xfs_bmap_worst_indlen(ip, new.br_blockcount);
+ 
+ 		WARN_ON_ONCE(!got_indlen || !new_indlen);
+ 		stolen = xfs_bmap_split_indlen(da_old, &got_indlen, &new_indlen,
+ 						       del->br_blockcount);
+ 
+ 		got->br_startblock = nullstartblock((int)got_indlen);
+ 
+ 		new.br_startoff = del_endoff;
+ 		new.br_state = got->br_state;
+ 		new.br_startblock = nullstartblock((int)new_indlen);
+ 
+ 		xfs_iext_update_extent(ip, state, icur, got);
+ 		xfs_iext_next(ifp, icur);
+ 		xfs_iext_insert(ip, icur, &new, state);
+ 
+ 		da_new = got_indlen + new_indlen - stolen;
+ 		del->br_blockcount -= stolen;
+ 		break;
+ 	}
+ 
+ 	ASSERT(da_old >= da_new);
+ 	da_diff = da_old - da_new;
+ 	if (!isrt)
+ 		da_diff += del->br_blockcount;
+ 	if (da_diff)
+ 		xfs_mod_fdblocks(mp, da_diff, false);
+ 	return error;
+ }
+ 
+ void
+ xfs_bmap_del_extent_cow(
+ 	struct xfs_inode	*ip,
+ 	struct xfs_iext_cursor	*icur,
+ 	struct xfs_bmbt_irec	*got,
+ 	struct xfs_bmbt_irec	*del)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, XFS_COW_FORK);
+ 	struct xfs_bmbt_irec	new;
+ 	xfs_fileoff_t		del_endoff, got_endoff;
+ 	int			state = BMAP_COWFORK;
+ 
+ 	XFS_STATS_INC(mp, xs_del_exlist);
+ 
+ 	del_endoff = del->br_startoff + del->br_blockcount;
+ 	got_endoff = got->br_startoff + got->br_blockcount;
+ 
+ 	ASSERT(del->br_blockcount > 0);
+ 	ASSERT(got->br_startoff <= del->br_startoff);
+ 	ASSERT(got_endoff >= del_endoff);
+ 	ASSERT(!isnullstartblock(got->br_startblock));
+ 
+ 	if (got->br_startoff == del->br_startoff)
+ 		state |= BMAP_LEFT_FILLING;
+ 	if (got_endoff == del_endoff)
+ 		state |= BMAP_RIGHT_FILLING;
+ 
+ 	switch (state & (BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING)) {
+ 	case BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Matches the whole extent.  Delete the entry.
+ 		 */
+ 		xfs_iext_remove(ip, icur, state);
+ 		xfs_iext_prev(ifp, icur);
+ 		break;
+ 	case BMAP_LEFT_FILLING:
+ 		/*
+ 		 * Deleting the first part of the extent.
+ 		 */
+ 		got->br_startoff = del_endoff;
+ 		got->br_blockcount -= del->br_blockcount;
+ 		got->br_startblock = del->br_startblock + del->br_blockcount;
+ 		xfs_iext_update_extent(ip, state, icur, got);
+ 		break;
+ 	case BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Deleting the last part of the extent.
+ 		 */
+ 		got->br_blockcount -= del->br_blockcount;
+ 		xfs_iext_update_extent(ip, state, icur, got);
+ 		break;
+ 	case 0:
+ 		/*
+ 		 * Deleting the middle of the extent.
+ 		 */
+ 		got->br_blockcount = del->br_startoff - got->br_startoff;
+ 
+ 		new.br_startoff = del_endoff;
+ 		new.br_blockcount = got_endoff - del_endoff;
+ 		new.br_state = got->br_state;
+ 		new.br_startblock = del->br_startblock + del->br_blockcount;
+ 
+ 		xfs_iext_update_extent(ip, state, icur, got);
+ 		xfs_iext_next(ifp, icur);
+ 		xfs_iext_insert(ip, icur, &new, state);
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> c38ccf599022 (xfs: remove the nr_extents argument to xfs_iext_remove)
  /*
   * Called by xfs_bmapi to update file extent records and the btree
 - * after removing space.
 + * after removing space (or undoing a delayed allocation).
   */
  STATIC int				/* error */
 -xfs_bmap_del_extent_real(
 +xfs_bmap_del_extent(
  	xfs_inode_t		*ip,	/* incore inode pointer */
  	xfs_trans_t		*tp,	/* current transaction pointer */
 -	struct xfs_iext_cursor	*icur,
 +	xfs_extnum_t		*idx,	/* extent number to update/delete */
  	struct xfs_defer_ops	*dfops,	/* list of extents to be freed */
  	xfs_btree_cur_t		*cur,	/* if null, not a btree */
  	xfs_bmbt_irec_t		*del,	/* data to remove from extents */
@@@ -4761,12 -4929,8 +5020,17 @@@
  		/*
  		 * Matches the whole extent.  Delete the entry.
  		 */
++<<<<<<< HEAD
 +		xfs_iext_remove(ip, *idx, 1,
 +				whichfork == XFS_ATTR_FORK ? BMAP_ATTRFORK : 0);
 +		--*idx;
 +		if (delay)
 +			break;
 +
++=======
+ 		xfs_iext_remove(ip, icur, state);
+ 		xfs_iext_prev(ifp, icur);
++>>>>>>> c38ccf599022 (xfs: remove the nr_extents argument to xfs_iext_remove)
  		XFS_IFORK_NEXT_SET(ip, whichfork,
  			XFS_IFORK_NEXTENTS(ip, whichfork) - 1);
  		flags |= XFS_ILOG_CORE;
@@@ -5473,10 -5550,266 +5737,269 @@@ xfs_bmse_merge
  		return error;
  	XFS_WANT_CORRUPTED_RETURN(mp, i == 1);
  
 -	error = xfs_bmbt_update(cur, &new);
 -	if (error)
 -		return error;
 +	left.br_blockcount = blockcount;
  
++<<<<<<< HEAD
 +	return xfs_bmbt_update(cur, left.br_startoff, left.br_startblock,
 +			       left.br_blockcount, left.br_state);
++=======
+ done:
+ 	xfs_iext_remove(ip, icur, 0);
+ 	xfs_iext_prev(XFS_IFORK_PTR(ip, whichfork), icur);
+ 	xfs_iext_update_extent(ip, xfs_bmap_fork_to_state(whichfork), icur,
+ 			&new);
+ 
+ 	/* update reverse mapping. rmap functions merge the rmaps for us */
+ 	error = xfs_rmap_unmap_extent(mp, dfops, ip, whichfork, got);
+ 	if (error)
+ 		return error;
+ 	memcpy(&new, got, sizeof(new));
+ 	new.br_startoff = left->br_startoff + left->br_blockcount;
+ 	return xfs_rmap_map_extent(mp, dfops, ip, whichfork, &new);
+ }
+ 
+ static int
+ xfs_bmap_shift_update_extent(
+ 	struct xfs_inode	*ip,
+ 	int			whichfork,
+ 	struct xfs_iext_cursor	*icur,
+ 	struct xfs_bmbt_irec	*got,
+ 	struct xfs_btree_cur	*cur,
+ 	int			*logflags,
+ 	struct xfs_defer_ops	*dfops,
+ 	xfs_fileoff_t		startoff)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_bmbt_irec	prev = *got;
+ 	int			error, i;
+ 
+ 	*logflags |= XFS_ILOG_CORE;
+ 
+ 	got->br_startoff = startoff;
+ 
+ 	if (cur) {
+ 		error = xfs_bmbt_lookup_eq(cur, &prev, &i);
+ 		if (error)
+ 			return error;
+ 		XFS_WANT_CORRUPTED_RETURN(mp, i == 1);
+ 
+ 		error = xfs_bmbt_update(cur, got);
+ 		if (error)
+ 			return error;
+ 	} else {
+ 		*logflags |= XFS_ILOG_DEXT;
+ 	}
+ 
+ 	xfs_iext_update_extent(ip, xfs_bmap_fork_to_state(whichfork), icur,
+ 			got);
+ 
+ 	/* update reverse mapping */
+ 	error = xfs_rmap_unmap_extent(mp, dfops, ip, whichfork, &prev);
+ 	if (error)
+ 		return error;
+ 	return xfs_rmap_map_extent(mp, dfops, ip, whichfork, got);
+ }
+ 
+ int
+ xfs_bmap_collapse_extents(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*ip,
+ 	xfs_fileoff_t		*next_fsb,
+ 	xfs_fileoff_t		offset_shift_fsb,
+ 	bool			*done,
+ 	xfs_fileoff_t		stop_fsb,
+ 	xfs_fsblock_t		*firstblock,
+ 	struct xfs_defer_ops	*dfops)
+ {
+ 	int			whichfork = XFS_DATA_FORK;
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	struct xfs_btree_cur	*cur = NULL;
+ 	struct xfs_bmbt_irec	got, prev;
+ 	struct xfs_iext_cursor	icur;
+ 	xfs_fileoff_t		new_startoff;
+ 	int			error = 0;
+ 	int			logflags = 0;
+ 
+ 	if (unlikely(XFS_TEST_ERROR(
+ 	    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
+ 	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
+ 	     mp, XFS_ERRTAG_BMAPIFORMAT))) {
+ 		XFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
+ 
+ 	ASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL | XFS_ILOCK_EXCL));
+ 
+ 	if (!(ifp->if_flags & XFS_IFEXTENTS)) {
+ 		error = xfs_iread_extents(tp, ip, whichfork);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	if (ifp->if_flags & XFS_IFBROOT) {
+ 		cur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);
+ 		cur->bc_private.b.firstblock = *firstblock;
+ 		cur->bc_private.b.dfops = dfops;
+ 		cur->bc_private.b.flags = 0;
+ 	}
+ 
+ 	if (!xfs_iext_lookup_extent(ip, ifp, *next_fsb, &icur, &got)) {
+ 		*done = true;
+ 		goto del_cursor;
+ 	}
+ 	XFS_WANT_CORRUPTED_RETURN(mp, !isnullstartblock(got.br_startblock));
+ 
+ 	new_startoff = got.br_startoff - offset_shift_fsb;
+ 	if (xfs_iext_peek_prev_extent(ifp, &icur, &prev)) {
+ 		if (new_startoff < prev.br_startoff + prev.br_blockcount) {
+ 			error = -EINVAL;
+ 			goto del_cursor;
+ 		}
+ 
+ 		if (xfs_bmse_can_merge(&prev, &got, offset_shift_fsb)) {
+ 			error = xfs_bmse_merge(ip, whichfork, offset_shift_fsb,
+ 					&icur, &got, &prev, cur, &logflags,
+ 					dfops);
+ 			if (error)
+ 				goto del_cursor;
+ 			goto done;
+ 		}
+ 	} else {
+ 		if (got.br_startoff < offset_shift_fsb) {
+ 			error = -EINVAL;
+ 			goto del_cursor;
+ 		}
+ 	}
+ 
+ 	error = xfs_bmap_shift_update_extent(ip, whichfork, &icur, &got, cur,
+ 			&logflags, dfops, new_startoff);
+ 	if (error)
+ 		goto del_cursor;
+ 
+ done:
+ 	if (!xfs_iext_next_extent(ifp, &icur, &got)) {
+ 		*done = true;
+ 		goto del_cursor;
+ 	}
+ 
+ 	*next_fsb = got.br_startoff;
+ del_cursor:
+ 	if (cur)
+ 		xfs_btree_del_cursor(cur,
+ 			error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);
+ 	if (logflags)
+ 		xfs_trans_log_inode(tp, ip, logflags);
+ 	return error;
+ }
+ 
+ int
+ xfs_bmap_insert_extents(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*ip,
+ 	xfs_fileoff_t		*next_fsb,
+ 	xfs_fileoff_t		offset_shift_fsb,
+ 	bool			*done,
+ 	xfs_fileoff_t		stop_fsb,
+ 	xfs_fsblock_t		*firstblock,
+ 	struct xfs_defer_ops	*dfops)
+ {
+ 	int			whichfork = XFS_DATA_FORK;
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	struct xfs_btree_cur	*cur = NULL;
+ 	struct xfs_bmbt_irec	got, next;
+ 	struct xfs_iext_cursor	icur;
+ 	xfs_fileoff_t		new_startoff;
+ 	int			error = 0;
+ 	int			logflags = 0;
+ 
+ 	if (unlikely(XFS_TEST_ERROR(
+ 	    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
+ 	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
+ 	     mp, XFS_ERRTAG_BMAPIFORMAT))) {
+ 		XFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
+ 
+ 	ASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL | XFS_ILOCK_EXCL));
+ 
+ 	if (!(ifp->if_flags & XFS_IFEXTENTS)) {
+ 		error = xfs_iread_extents(tp, ip, whichfork);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	if (ifp->if_flags & XFS_IFBROOT) {
+ 		cur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);
+ 		cur->bc_private.b.firstblock = *firstblock;
+ 		cur->bc_private.b.dfops = dfops;
+ 		cur->bc_private.b.flags = 0;
+ 	}
+ 
+ 	if (*next_fsb == NULLFSBLOCK) {
+ 		xfs_iext_last(ifp, &icur);
+ 		if (!xfs_iext_get_extent(ifp, &icur, &got) ||
+ 		    stop_fsb > got.br_startoff) {
+ 			*done = true;
+ 			goto del_cursor;
+ 		}
+ 	} else {
+ 		if (!xfs_iext_lookup_extent(ip, ifp, *next_fsb, &icur, &got)) {
+ 			*done = true;
+ 			goto del_cursor;
+ 		}
+ 	}
+ 	XFS_WANT_CORRUPTED_RETURN(mp, !isnullstartblock(got.br_startblock));
+ 
+ 	if (stop_fsb >= got.br_startoff + got.br_blockcount) {
+ 		error = -EIO;
+ 		goto del_cursor;
+ 	}
+ 
+ 	new_startoff = got.br_startoff + offset_shift_fsb;
+ 	if (xfs_iext_peek_next_extent(ifp, &icur, &next)) {
+ 		if (new_startoff + got.br_blockcount > next.br_startoff) {
+ 			error = -EINVAL;
+ 			goto del_cursor;
+ 		}
+ 
+ 		/*
+ 		 * Unlike a left shift (which involves a hole punch), a right
+ 		 * shift does not modify extent neighbors in any way.  We should
+ 		 * never find mergeable extents in this scenario.  Check anyways
+ 		 * and warn if we encounter two extents that could be one.
+ 		 */
+ 		if (xfs_bmse_can_merge(&got, &next, offset_shift_fsb))
+ 			WARN_ON_ONCE(1);
+ 	}
+ 
+ 	error = xfs_bmap_shift_update_extent(ip, whichfork, &icur, &got, cur,
+ 			&logflags, dfops, new_startoff);
+ 	if (error)
+ 		goto del_cursor;
+ 
+ 	if (!xfs_iext_prev_extent(ifp, &icur, &got) ||
+ 	    stop_fsb >= got.br_startoff + got.br_blockcount) {
+ 		*done = true;
+ 		goto del_cursor;
+ 	}
+ 
+ 	*next_fsb = got.br_startoff;
+ del_cursor:
+ 	if (cur)
+ 		xfs_btree_del_cursor(cur,
+ 			error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);
+ 	if (logflags)
+ 		xfs_trans_log_inode(tp, ip, logflags);
+ 	return error;
++>>>>>>> c38ccf599022 (xfs: remove the nr_extents argument to xfs_iext_remove)
  }
  
  /*
diff --cc fs/xfs/libxfs/xfs_inode_fork.h
index a53b7ced7b58,b9f0098e33b8..000000000000
--- a/fs/xfs/libxfs/xfs_inode_fork.h
+++ b/fs/xfs/libxfs/xfs_inode_fork.h
@@@ -135,37 -112,12 +135,45 @@@ int		xfs_iextents_copy(struct xfs_inod
  				  int);
  void		xfs_init_local_fork(struct xfs_inode *, int, const void *, int);
  
++<<<<<<< HEAD
 +struct xfs_bmbt_rec_host *
 +		xfs_iext_get_ext(struct xfs_ifork *, xfs_extnum_t);
 +xfs_extnum_t	xfs_iext_count(struct xfs_ifork *);
 +void		xfs_iext_insert(struct xfs_inode *, xfs_extnum_t, xfs_extnum_t,
 +				struct xfs_bmbt_irec *, int);
 +void		xfs_iext_add(struct xfs_ifork *, xfs_extnum_t, int);
 +void		xfs_iext_add_indirect_multi(struct xfs_ifork *, int,
 +					    xfs_extnum_t, int);
 +void		xfs_iext_remove(struct xfs_inode *, xfs_extnum_t, int, int);
 +void		xfs_iext_remove_inline(struct xfs_ifork *, xfs_extnum_t, int);
 +void		xfs_iext_remove_direct(struct xfs_ifork *, xfs_extnum_t, int);
 +void		xfs_iext_remove_indirect(struct xfs_ifork *, xfs_extnum_t, int);
 +void		xfs_iext_realloc_direct(struct xfs_ifork *, int);
 +void		xfs_iext_direct_to_inline(struct xfs_ifork *, xfs_extnum_t);
 +void		xfs_iext_inline_to_direct(struct xfs_ifork *, int);
++=======
+ xfs_extnum_t	xfs_iext_count(struct xfs_ifork *ifp);
+ void		xfs_iext_insert(struct xfs_inode *, struct xfs_iext_cursor *cur,
+ 			struct xfs_bmbt_irec *, int);
+ void		xfs_iext_remove(struct xfs_inode *, struct xfs_iext_cursor *,
+ 			int);
++>>>>>>> c38ccf599022 (xfs: remove the nr_extents argument to xfs_iext_remove)
  void		xfs_iext_destroy(struct xfs_ifork *);
 +struct xfs_bmbt_rec_host *
 +		xfs_iext_bno_to_ext(struct xfs_ifork *, xfs_fileoff_t, int *);
 +struct xfs_ext_irec *
 +		xfs_iext_bno_to_irec(struct xfs_ifork *, xfs_fileoff_t, int *);
 +struct xfs_ext_irec *
 +		xfs_iext_idx_to_irec(struct xfs_ifork *, xfs_extnum_t *, int *,
 +				     int);
 +void		xfs_iext_irec_init(struct xfs_ifork *);
 +struct xfs_ext_irec *
 +		xfs_iext_irec_new(struct xfs_ifork *, int);
 +void		xfs_iext_irec_remove(struct xfs_ifork *, int);
 +void		xfs_iext_irec_compact(struct xfs_ifork *);
 +void		xfs_iext_irec_compact_pages(struct xfs_ifork *);
 +void		xfs_iext_irec_compact_full(struct xfs_ifork *);
 +void		xfs_iext_irec_update_extoffs(struct xfs_ifork *, int, int);
  
  bool		xfs_iext_lookup_extent(struct xfs_inode *ip,
  			struct xfs_ifork *ifp, xfs_fileoff_t bno,
* Unmerged path fs/xfs/libxfs/xfs_iext_tree.c
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
* Unmerged path fs/xfs/libxfs/xfs_iext_tree.c
* Unmerged path fs/xfs/libxfs/xfs_inode_fork.h
