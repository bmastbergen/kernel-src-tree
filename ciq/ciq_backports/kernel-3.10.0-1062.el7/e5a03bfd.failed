phy: Add an mdio_device structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Andrew Lunn <andrew@lunn.ch>
commit e5a03bfd873c29eb786655ef2e95e53ed242b404
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e5a03bfd.failed

Not all devices attached to an MDIO bus are phys. So add an
mdio_device structure to represent the generic parts of an mdio
device, and place this structure into the phy_device.

	Signed-off-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e5a03bfd873c29eb786655ef2e95e53ed242b404)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/altera/altera_tse_main.c
#	drivers/net/ethernet/broadcom/b44.c
#	drivers/net/ethernet/broadcom/genet/bcmmii.c
#	drivers/net/ethernet/freescale/fman/fman_dtsec.c
#	drivers/net/ethernet/freescale/fman/fman_memac.c
#	drivers/net/ethernet/freescale/gianfar.c
#	drivers/net/ethernet/freescale/ucc_geth.c
#	drivers/net/ethernet/hisilicon/hns/hns_ethtool.c
#	drivers/net/ethernet/marvell/mv643xx_eth.c
#	drivers/net/ethernet/marvell/mvneta.c
#	drivers/net/ethernet/ti/cpsw.c
#	drivers/net/ethernet/ti/davinci_mdio.c
#	drivers/net/ethernet/xilinx/xilinx_emaclite.c
#	drivers/net/phy/at803x.c
#	drivers/net/phy/dp83867.c
#	drivers/net/phy/fixed_phy.c
#	drivers/net/phy/marvell.c
#	drivers/net/phy/mdio_bus.c
#	drivers/net/phy/micrel.c
#	drivers/net/phy/microchip.c
#	drivers/net/phy/phy.c
#	drivers/net/phy/phy_device.c
#	drivers/net/phy/smsc.c
#	drivers/of/of_mdio.c
#	drivers/staging/et131x/et131x.c
#	include/linux/phy.h
#	net/dsa/dsa.c
diff --cc drivers/net/ethernet/broadcom/b44.c
index 468c4c17635e,843a4a5864fc..000000000000
--- a/drivers/net/ethernet/broadcom/b44.c
+++ b/drivers/net/ethernet/broadcom/b44.c
@@@ -2135,6 -2203,133 +2135,136 @@@ static const struct net_device_ops b44_
  #endif
  };
  
++<<<<<<< HEAD
++=======
+ static void b44_adjust_link(struct net_device *dev)
+ {
+ 	struct b44 *bp = netdev_priv(dev);
+ 	struct phy_device *phydev = bp->phydev;
+ 	bool status_changed = 0;
+ 
+ 	BUG_ON(!phydev);
+ 
+ 	if (bp->old_link != phydev->link) {
+ 		status_changed = 1;
+ 		bp->old_link = phydev->link;
+ 	}
+ 
+ 	/* reflect duplex change */
+ 	if (phydev->link) {
+ 		if ((phydev->duplex == DUPLEX_HALF) &&
+ 		    (bp->flags & B44_FLAG_FULL_DUPLEX)) {
+ 			status_changed = 1;
+ 			bp->flags &= ~B44_FLAG_FULL_DUPLEX;
+ 		} else if ((phydev->duplex == DUPLEX_FULL) &&
+ 			   !(bp->flags & B44_FLAG_FULL_DUPLEX)) {
+ 			status_changed = 1;
+ 			bp->flags |= B44_FLAG_FULL_DUPLEX;
+ 		}
+ 	}
+ 
+ 	if (status_changed) {
+ 		u32 val = br32(bp, B44_TX_CTRL);
+ 		if (bp->flags & B44_FLAG_FULL_DUPLEX)
+ 			val |= TX_CTRL_DUPLEX;
+ 		else
+ 			val &= ~TX_CTRL_DUPLEX;
+ 		bw32(bp, B44_TX_CTRL, val);
+ 		phy_print_status(phydev);
+ 	}
+ }
+ 
+ static int b44_register_phy_one(struct b44 *bp)
+ {
+ 	struct mii_bus *mii_bus;
+ 	struct ssb_device *sdev = bp->sdev;
+ 	struct phy_device *phydev;
+ 	char bus_id[MII_BUS_ID_SIZE + 3];
+ 	struct ssb_sprom *sprom = &sdev->bus->sprom;
+ 	int err;
+ 
+ 	mii_bus = mdiobus_alloc();
+ 	if (!mii_bus) {
+ 		dev_err(sdev->dev, "mdiobus_alloc() failed\n");
+ 		err = -ENOMEM;
+ 		goto err_out;
+ 	}
+ 
+ 	mii_bus->priv = bp;
+ 	mii_bus->read = b44_mdio_read_phylib;
+ 	mii_bus->write = b44_mdio_write_phylib;
+ 	mii_bus->name = "b44_eth_mii";
+ 	mii_bus->parent = sdev->dev;
+ 	mii_bus->phy_mask = ~(1 << bp->phy_addr);
+ 	snprintf(mii_bus->id, MII_BUS_ID_SIZE, "%x", instance);
+ 
+ 	bp->mii_bus = mii_bus;
+ 
+ 	err = mdiobus_register(mii_bus);
+ 	if (err) {
+ 		dev_err(sdev->dev, "failed to register MII bus\n");
+ 		goto err_out_mdiobus;
+ 	}
+ 
+ 	if (!bp->mii_bus->phy_map[bp->phy_addr] &&
+ 	    (sprom->boardflags_lo & (B44_BOARDFLAG_ROBO | B44_BOARDFLAG_ADM))) {
+ 
+ 		dev_info(sdev->dev,
+ 			 "could not find PHY at %i, use fixed one\n",
+ 			 bp->phy_addr);
+ 
+ 		bp->phy_addr = 0;
+ 		snprintf(bus_id, sizeof(bus_id), PHY_ID_FMT, "fixed-0",
+ 			 bp->phy_addr);
+ 	} else {
+ 		snprintf(bus_id, sizeof(bus_id), PHY_ID_FMT, mii_bus->id,
+ 			 bp->phy_addr);
+ 	}
+ 
+ 	phydev = phy_connect(bp->dev, bus_id, &b44_adjust_link,
+ 			     PHY_INTERFACE_MODE_MII);
+ 	if (IS_ERR(phydev)) {
+ 		dev_err(sdev->dev, "could not attach PHY at %i\n",
+ 			bp->phy_addr);
+ 		err = PTR_ERR(phydev);
+ 		goto err_out_mdiobus_unregister;
+ 	}
+ 
+ 	/* mask with MAC supported features */
+ 	phydev->supported &= (SUPPORTED_100baseT_Half |
+ 			      SUPPORTED_100baseT_Full |
+ 			      SUPPORTED_Autoneg |
+ 			      SUPPORTED_MII);
+ 	phydev->advertising = phydev->supported;
+ 
+ 	bp->phydev = phydev;
+ 	bp->old_link = 0;
+ 	bp->phy_addr = phydev->mdio.addr;
+ 
+ 	phy_attached_info(phydev);
+ 
+ 	return 0;
+ 
+ err_out_mdiobus_unregister:
+ 	mdiobus_unregister(mii_bus);
+ 
+ err_out_mdiobus:
+ 	mdiobus_free(mii_bus);
+ 
+ err_out:
+ 	return err;
+ }
+ 
+ static void b44_unregister_phy_one(struct b44 *bp)
+ {
+ 	struct mii_bus *mii_bus = bp->mii_bus;
+ 
+ 	phy_disconnect(bp->phydev);
+ 	mdiobus_unregister(mii_bus);
+ 	mdiobus_free(mii_bus);
+ }
+ 
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  static int b44_init_one(struct ssb_device *sdev,
  			const struct ssb_device_id *ent)
  {
diff --cc drivers/net/ethernet/freescale/gianfar.c
index 8c3c26ff4738,2aa7b401cc3b..000000000000
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@@ -1532,57 -1848,8 +1532,61 @@@ static void gfar_configure_serdes(struc
  	phy_write(tbiphy, MII_BMCR,
  		  BMCR_ANENABLE | BMCR_ANRESTART | BMCR_FULLDPLX |
  		  BMCR_SPEED1000);
 +}
 +
++<<<<<<< HEAD
 +static void init_registers(struct net_device *dev)
 +{
 +	struct gfar_private *priv = netdev_priv(dev);
 +	struct gfar __iomem *regs = NULL;
 +	int i;
 +
 +	for (i = 0; i < priv->num_grps; i++) {
 +		regs = priv->gfargrp[i].regs;
 +		/* Clear IEVENT */
 +		gfar_write(&regs->ievent, IEVENT_INIT_CLEAR);
  
 +		/* Initialize IMASK */
 +		gfar_write(&regs->imask, IMASK_INIT_CLEAR);
 +	}
 +
 +	regs = priv->gfargrp[0].regs;
 +	/* Init hash registers to zero */
 +	gfar_write(&regs->igaddr0, 0);
 +	gfar_write(&regs->igaddr1, 0);
 +	gfar_write(&regs->igaddr2, 0);
 +	gfar_write(&regs->igaddr3, 0);
 +	gfar_write(&regs->igaddr4, 0);
 +	gfar_write(&regs->igaddr5, 0);
 +	gfar_write(&regs->igaddr6, 0);
 +	gfar_write(&regs->igaddr7, 0);
 +
 +	gfar_write(&regs->gaddr0, 0);
 +	gfar_write(&regs->gaddr1, 0);
 +	gfar_write(&regs->gaddr2, 0);
 +	gfar_write(&regs->gaddr3, 0);
 +	gfar_write(&regs->gaddr4, 0);
 +	gfar_write(&regs->gaddr5, 0);
 +	gfar_write(&regs->gaddr6, 0);
 +	gfar_write(&regs->gaddr7, 0);
 +
 +	/* Zero out the rmon mib registers if it has them */
 +	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_RMON) {
 +		memset_io(&(regs->rmon), 0, sizeof (struct rmon_mib));
 +
 +		/* Mask off the CAM interrupts */
 +		gfar_write(&regs->rmon.cam1, 0xffffffff);
 +		gfar_write(&regs->rmon.cam2, 0xffffffff);
 +	}
 +
 +	/* Initialize the max receive buffer length */
 +	gfar_write(&regs->mrblr, priv->rx_buffer_size);
 +
 +	/* Initialize the Minimum Frame Length Register */
 +	gfar_write(&regs->minflr, MINFLR_INIT_SETTINGS);
++=======
+ 	put_device(&tbiphy->mdio.dev);
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  }
  
  static int __gfar_is_rx_idle(struct gfar_private *priv)
diff --cc drivers/net/ethernet/freescale/ucc_geth.c
index 388f2e5b6b27,0e7f24ec3239..000000000000
--- a/drivers/net/ethernet/freescale/ucc_geth.c
+++ b/drivers/net/ethernet/freescale/ucc_geth.c
@@@ -1387,6 -1384,8 +1387,11 @@@ static int adjust_enet_interface(struc
  		value = phy_read(tbiphy, ENET_TBI_MII_CR);
  		value &= ~0x1000;	/* Turn off autonegotiation */
  		phy_write(tbiphy, ENET_TBI_MII_CR, value);
++<<<<<<< HEAD
++=======
+ 
+ 		put_device(&tbiphy->mdio.dev);
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  	}
  
  	init_check_frame_length_mode(ug_info->lengthCheckRx, &ug_regs->maccfg2);
@@@ -1705,8 -1704,10 +1710,13 @@@ static void uec_configure_serdes(struc
  	 * everything for us?  Resetting it takes the link down and requires
  	 * several seconds for it to come back.
  	 */
++<<<<<<< HEAD
 +	if (phy_read(tbiphy, ENET_TBI_MII_SR) & TBISR_LSTATUS)
++=======
+ 	if (phy_read(tbiphy, ENET_TBI_MII_SR) & TBISR_LSTATUS) {
+ 		put_device(&tbiphy->mdio.dev);
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  		return;
 -	}
  
  	/* Single clk mode, mii mode off(for serdes communication) */
  	phy_write(tbiphy, ENET_TBI_MII_ANA, TBIANA_SETTINGS);
diff --cc drivers/net/ethernet/marvell/mv643xx_eth.c
index 96eef22501e0,a0c03834a2f7..000000000000
--- a/drivers/net/ethernet/marvell/mv643xx_eth.c
+++ b/drivers/net/ethernet/marvell/mv643xx_eth.c
@@@ -2714,19 -3125,31 +2714,32 @@@ static int mv643xx_eth_probe(struct pla
  	netif_set_real_num_tx_queues(dev, mp->txq_count);
  	netif_set_real_num_rx_queues(dev, mp->rxq_count);
  
++<<<<<<< HEAD
 +	if (pd->phy_addr != MV643XX_ETH_PHY_NONE) {
++=======
+ 	err = 0;
+ 	if (pd->phy_node) {
+ 		mp->phy = of_phy_connect(mp->dev, pd->phy_node,
+ 					 mv643xx_eth_adjust_link, 0,
+ 					 PHY_INTERFACE_MODE_GMII);
+ 		if (!mp->phy)
+ 			err = -ENODEV;
+ 		else
+ 			phy_addr_set(mp, mp->phy->mdio.addr);
+ 	} else if (pd->phy_addr != MV643XX_ETH_PHY_NONE) {
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  		mp->phy = phy_scan(mp, pd->phy_addr);
  
 -		if (IS_ERR(mp->phy))
 +		if (IS_ERR(mp->phy)) {
  			err = PTR_ERR(mp->phy);
 -		else
 -			phy_init(mp, pd->speed, pd->duplex);
 -	}
 -	if (err == -ENODEV) {
 -		err = -EPROBE_DEFER;
 -		goto out;
 +			if (err == -ENODEV)
 +				err = -EPROBE_DEFER;
 +			goto out;
 +		}
 +		phy_init(mp, pd->speed, pd->duplex);
  	}
 -	if (err)
 -		goto out;
  
 -	dev->ethtool_ops = &mv643xx_eth_ethtool_ops;
 +	SET_ETHTOOL_OPS(dev, &mv643xx_eth_ethtool_ops);
  
  	init_pscr(mp, pd->speed, pd->duplex);
  
diff --cc drivers/net/ethernet/marvell/mvneta.c
index bcf995e5c9b0,fabc8df40392..000000000000
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@@ -2789,14 -3709,24 +2789,25 @@@ static int mvneta_probe(struct platform
  
  	platform_set_drvdata(pdev, pp->dev);
  
++<<<<<<< HEAD
++=======
+ 	if (pp->use_inband_status) {
+ 		struct phy_device *phy = of_phy_find_device(dn);
+ 
+ 		mvneta_fixed_link_update(pp, phy);
+ 
+ 		put_device(&phy->mdio.dev);
+ 	}
+ 
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  	return 0;
  
 -err_free_stats:
 -	free_percpu(pp->stats);
 -err_free_ports:
 -	free_percpu(pp->ports);
 +err_deinit:
 +	mvneta_deinit(pp);
  err_clk:
  	clk_disable_unprepare(pp->clk);
 -err_put_phy_node:
 -	of_node_put(phy_node);
 +err_unmap:
 +	iounmap(pp->base);
  err_free_irq:
  	irq_dispose_mapping(dev->irq);
  err_free_netdev:
diff --cc drivers/net/ethernet/ti/cpsw.c
index 11a2c779af33,42fdfd4d9d4f..000000000000
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@@ -1527,33 -2021,77 +1527,81 @@@ static int cpsw_probe_dt(struct cpsw_pl
  	ret = of_platform_populate(node, NULL, NULL, &pdev->dev);
  	/* We do not want to force this, as in some cases may not have child */
  	if (ret)
 -		dev_warn(&pdev->dev, "Doesn't have any child node\n");
 +		pr_warn("Doesn't have any child node\n");
  
 -	for_each_child_of_node(node, slave_node) {
 +	for_each_node_by_name(slave_node, "slave") {
  		struct cpsw_slave_data *slave_data = data->slave_data + i;
  		const void *mac_addr = NULL;
 +		u32 phyid;
  		int lenp;
  		const __be32 *parp;
 +		struct device_node *mdio_node;
 +		struct platform_device *mdio;
  
 -		/* This is no slave child node, continue */
 -		if (strcmp(slave_node->name, "slave"))
 -			continue;
 -
 -		priv->phy_node = of_parse_phandle(slave_node, "phy-handle", 0);
  		parp = of_get_property(slave_node, "phy_id", &lenp);
++<<<<<<< HEAD
 +		if ((parp == NULL) || (lenp != (sizeof(void *) * 2))) {
 +			pr_err("Missing slave[%d] phy_id property\n", i);
 +			ret = -EINVAL;
 +			goto error_ret;
++=======
+ 		if (of_phy_is_fixed_link(slave_node)) {
+ 			struct device_node *phy_node;
+ 			struct phy_device *phy_dev;
+ 
+ 			/* In the case of a fixed PHY, the DT node associated
+ 			 * to the PHY is the Ethernet MAC DT node.
+ 			 */
+ 			ret = of_phy_register_fixed_link(slave_node);
+ 			if (ret)
+ 				return ret;
+ 			phy_node = of_node_get(slave_node);
+ 			phy_dev = of_phy_find_device(phy_node);
+ 			if (!phy_dev)
+ 				return -ENODEV;
+ 			snprintf(slave_data->phy_id, sizeof(slave_data->phy_id),
+ 				 PHY_ID_FMT, phy_dev->mdio.bus->id,
+ 				 phy_dev->mdio.addr);
+ 		} else if (parp) {
+ 			u32 phyid;
+ 			struct device_node *mdio_node;
+ 			struct platform_device *mdio;
+ 
+ 			if (lenp != (sizeof(__be32) * 2)) {
+ 				dev_err(&pdev->dev, "Invalid slave[%d] phy_id property\n", i);
+ 				goto no_phy_slave;
+ 			}
+ 			mdio_node = of_find_node_by_phandle(be32_to_cpup(parp));
+ 			phyid = be32_to_cpup(parp+1);
+ 			mdio = of_find_device_by_node(mdio_node);
+ 			of_node_put(mdio_node);
+ 			if (!mdio) {
+ 				dev_err(&pdev->dev, "Missing mdio platform device\n");
+ 				return -EINVAL;
+ 			}
+ 			snprintf(slave_data->phy_id, sizeof(slave_data->phy_id),
+ 				 PHY_ID_FMT, mdio->name, phyid);
+ 		} else {
+ 			dev_err(&pdev->dev, "No slave[%d] phy_id or fixed-link property\n", i);
+ 			goto no_phy_slave;
+ 		}
+ 		slave_data->phy_if = of_get_phy_mode(slave_node);
+ 		if (slave_data->phy_if < 0) {
+ 			dev_err(&pdev->dev, "Missing or malformed slave[%d] phy-mode property\n",
+ 				i);
+ 			return slave_data->phy_if;
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  		}
 +		mdio_node = of_find_node_by_phandle(be32_to_cpup(parp));
 +		phyid = be32_to_cpup(parp+1);
 +		mdio = of_find_device_by_node(mdio_node);
 +		snprintf(slave_data->phy_id, sizeof(slave_data->phy_id),
 +			 PHY_ID_FMT, mdio->name, phyid);
  
 -no_phy_slave:
  		mac_addr = of_get_mac_address(slave_node);
 -		if (mac_addr) {
 +		if (mac_addr)
  			memcpy(slave_data->mac_addr, mac_addr, ETH_ALEN);
 -		} else {
 -			ret = ti_cm_get_macid(&pdev->dev, i,
 -					      slave_data->mac_addr);
 -			if (ret)
 -				return ret;
 -		}
 +
  		if (data->dual_emac) {
  			if (of_property_read_u32(slave_node, "dual_emac_res_vlan",
  						 &prop)) {
diff --cc drivers/net/ethernet/ti/davinci_mdio.c
index c47f0dbcebb5,78299c1592c1..000000000000
--- a/drivers/net/ethernet/ti/davinci_mdio.c
+++ b/drivers/net/ethernet/ti/davinci_mdio.c
@@@ -393,7 -396,7 +393,11 @@@ static int davinci_mdio_probe(struct pl
  		phy = data->bus->phy_map[addr];
  		if (phy) {
  			dev_info(dev, "phy[%d]: device %s, driver %s\n",
++<<<<<<< HEAD
 +				 phy->addr, dev_name(&phy->dev),
++=======
+ 				 phy->mdio.addr, phydev_name(phy),
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  				 phy->drv ? phy->drv->name : "unknown");
  		}
  	}
diff --cc drivers/net/ethernet/xilinx/xilinx_emaclite.c
index 785c4955464b,e324b3092380..000000000000
--- a/drivers/net/ethernet/xilinx/xilinx_emaclite.c
+++ b/drivers/net/ethernet/xilinx/xilinx_emaclite.c
@@@ -852,8 -813,23 +852,25 @@@ static int xemaclite_mdio_setup(struct 
  	/* Don't register the MDIO bus if the phy_node or its parent node
  	 * can't be found.
  	 */
 -	if (!np) {
 -		dev_err(dev, "Failed to register mdio bus.\n");
 +	if (!np)
  		return -ENODEV;
++<<<<<<< HEAD
++=======
+ 	}
+ 	npp = of_get_parent(np);
+ 
+ 	of_address_to_resource(npp, 0, &res);
+ 	if (lp->ndev->mem_start != res.start) {
+ 		struct phy_device *phydev;
+ 		phydev = of_phy_find_device(lp->phy_node);
+ 		if (!phydev)
+ 			dev_info(dev,
+ 				 "MDIO of the phy is not registered yet\n");
+ 		else
+ 			put_device(&phydev->mdio.dev);
+ 		return 0;
+ 	}
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  
  	/* Enable the MDIO bus by asserting the enable bit in MDIO Control
  	 * register.
diff --cc drivers/net/phy/at803x.c
index 45cbc10de01c,b76ac09a554f..000000000000
--- a/drivers/net/phy/at803x.c
+++ b/drivers/net/phy/at803x.c
@@@ -43,23 -99,114 +43,101 @@@ static void at803x_set_wol_mac_addr(str
  	};
  
  	if (!ndev)
 -		return -ENODEV;
 +		return;
  
 -	if (wol->wolopts & WAKE_MAGIC) {
 -		mac = (const u8 *) ndev->dev_addr;
 +	mac = (const u8 *) ndev->dev_addr;
  
 -		if (!is_valid_ether_addr(mac))
 -			return -EFAULT;
 +	if (!is_valid_ether_addr(mac))
 +		return;
  
 -		for (i = 0; i < 3; i++) {
 -			phy_write(phydev, AT803X_MMD_ACCESS_CONTROL,
 +	for (i = 0; i < 3; i++) {
 +		phy_write(phydev, AT803X_MMD_ACCESS_CONTROL,
  				  AT803X_DEVICE_ADDR);
 -			phy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,
 +		phy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,
  				  offsets[i]);
 -			phy_write(phydev, AT803X_MMD_ACCESS_CONTROL,
 +		phy_write(phydev, AT803X_MMD_ACCESS_CONTROL,
  				  AT803X_FUNC_DATA);
 -			phy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,
 +		phy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,
  				  mac[(i * 2) + 1] | (mac[(i * 2)] << 8));
 -		}
 -
 -		value = phy_read(phydev, AT803X_INTR_ENABLE);
 -		value |= AT803X_WOL_ENABLE;
 -		ret = phy_write(phydev, AT803X_INTR_ENABLE, value);
 -		if (ret)
 -			return ret;
 -		value = phy_read(phydev, AT803X_INTR_STATUS);
 -	} else {
 -		value = phy_read(phydev, AT803X_INTR_ENABLE);
 -		value &= (~AT803X_WOL_ENABLE);
 -		ret = phy_write(phydev, AT803X_INTR_ENABLE, value);
 -		if (ret)
 -			return ret;
 -		value = phy_read(phydev, AT803X_INTR_STATUS);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	return ret;
+ }
+ 
+ static void at803x_get_wol(struct phy_device *phydev,
+ 			   struct ethtool_wolinfo *wol)
+ {
+ 	u32 value;
+ 
+ 	wol->supported = WAKE_MAGIC;
+ 	wol->wolopts = 0;
+ 
+ 	value = phy_read(phydev, AT803X_INTR_ENABLE);
+ 	if (value & AT803X_WOL_ENABLE)
+ 		wol->wolopts |= WAKE_MAGIC;
+ }
+ 
+ static int at803x_suspend(struct phy_device *phydev)
+ {
+ 	int value;
+ 	int wol_enabled;
+ 
+ 	mutex_lock(&phydev->lock);
+ 
+ 	value = phy_read(phydev, AT803X_INTR_ENABLE);
+ 	wol_enabled = value & AT803X_WOL_ENABLE;
+ 
+ 	value = phy_read(phydev, MII_BMCR);
+ 
+ 	if (wol_enabled)
+ 		value |= BMCR_ISOLATE;
+ 	else
+ 		value |= BMCR_PDOWN;
+ 
+ 	phy_write(phydev, MII_BMCR, value);
+ 
+ 	mutex_unlock(&phydev->lock);
+ 
+ 	return 0;
+ }
+ 
+ static int at803x_resume(struct phy_device *phydev)
+ {
+ 	int value;
+ 
+ 	mutex_lock(&phydev->lock);
+ 
+ 	value = phy_read(phydev, MII_BMCR);
+ 	value &= ~(BMCR_PDOWN | BMCR_ISOLATE);
+ 	phy_write(phydev, MII_BMCR, value);
+ 
+ 	mutex_unlock(&phydev->lock);
+ 
+ 	return 0;
+ }
+ 
+ static int at803x_probe(struct phy_device *phydev)
+ {
+ 	struct device *dev = &phydev->mdio.dev;
+ 	struct at803x_priv *priv;
+ 	struct gpio_desc *gpiod_reset;
+ 
+ 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+ 	if (!priv)
+ 		return -ENOMEM;
+ 
+ 	gpiod_reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+ 	if (IS_ERR(gpiod_reset))
+ 		return PTR_ERR(gpiod_reset);
+ 
+ 	priv->gpiod_reset = gpiod_reset;
+ 
+ 	phydev->priv = priv;
+ 
+ 	return 0;
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  }
  
  static int at803x_config_init(struct phy_device *phydev)
diff --cc drivers/net/phy/fixed_phy.c
index 82314743f4cc,ab9c473d75ea..000000000000
--- a/drivers/net/phy/fixed_phy.c
+++ b/drivers/net/phy/fixed_phy.c
@@@ -176,7 -197,7 +176,11 @@@ int fixed_phy_set_link_update(struct ph
  	struct fixed_mdio_bus *fmb = &platform_fmb;
  	struct fixed_phy *fp;
  
++<<<<<<< HEAD
 +	if (!link_update || !phydev || !phydev->bus)
++=======
+ 	if (!phydev || !phydev->mdio.bus)
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  		return -EINVAL;
  
  	list_for_each_entry(fp, &fmb->phys, node) {
@@@ -310,8 -334,30 +314,25 @@@ struct phy_device *fixed_phy_register(u
  		return ERR_PTR(-EINVAL);
  	}
  
 -	/* propagate the fixed link values to struct phy_device */
 -	phy->link = status->link;
 -	if (status->link) {
 -		phy->speed = status->speed;
 -		phy->duplex = status->duplex;
 -		phy->pause = status->pause;
 -		phy->asym_pause = status->asym_pause;
 -	}
 -
  	of_node_get(np);
++<<<<<<< HEAD
 +	phy->dev.of_node = np;
++=======
+ 	phy->mdio.dev.of_node = np;
+ 	phy->is_pseudo_fixed_link = true;
+ 
+ 	switch (status->speed) {
+ 	case SPEED_1000:
+ 		phy->supported = PHY_1000BT_FEATURES;
+ 		break;
+ 	case SPEED_100:
+ 		phy->supported = PHY_100BT_FEATURES;
+ 		break;
+ 	case SPEED_10:
+ 	default:
+ 		phy->supported = PHY_10BT_FEATURES;
+ 	}
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  
  	ret = phy_device_register(phy);
  	if (ret) {
diff --cc drivers/net/phy/marvell.c
index e84c049c80c3,f96c93c9819a..000000000000
--- a/drivers/net/phy/marvell.c
+++ b/drivers/net/phy/marvell.c
@@@ -859,6 -1003,73 +860,76 @@@ static int m88e1318_set_wol(struct phy_
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int marvell_get_sset_count(struct phy_device *phydev)
+ {
+ 	return ARRAY_SIZE(marvell_hw_stats);
+ }
+ 
+ static void marvell_get_strings(struct phy_device *phydev, u8 *data)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(marvell_hw_stats); i++) {
+ 		memcpy(data + i * ETH_GSTRING_LEN,
+ 		       marvell_hw_stats[i].string, ETH_GSTRING_LEN);
+ 	}
+ }
+ 
+ #ifndef UINT64_MAX
+ #define UINT64_MAX              (u64)(~((u64)0))
+ #endif
+ static u64 marvell_get_stat(struct phy_device *phydev, int i)
+ {
+ 	struct marvell_hw_stat stat = marvell_hw_stats[i];
+ 	struct marvell_priv *priv = phydev->priv;
+ 	int err, oldpage;
+ 	u64 val;
+ 
+ 	oldpage = phy_read(phydev, MII_MARVELL_PHY_PAGE);
+ 	err = phy_write(phydev, MII_MARVELL_PHY_PAGE,
+ 			stat.page);
+ 	if (err < 0)
+ 		return UINT64_MAX;
+ 
+ 	val = phy_read(phydev, stat.reg);
+ 	if (val < 0) {
+ 		val = UINT64_MAX;
+ 	} else {
+ 		val = val & ((1 << stat.bits) - 1);
+ 		priv->stats[i] += val;
+ 		val = priv->stats[i];
+ 	}
+ 
+ 	phy_write(phydev, MII_MARVELL_PHY_PAGE, oldpage);
+ 
+ 	return val;
+ }
+ 
+ static void marvell_get_stats(struct phy_device *phydev,
+ 			      struct ethtool_stats *stats, u64 *data)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(marvell_hw_stats); i++)
+ 		data[i] = marvell_get_stat(phydev, i);
+ }
+ 
+ static int marvell_probe(struct phy_device *phydev)
+ {
+ 	struct marvell_priv *priv;
+ 
+ 	priv = devm_kzalloc(&phydev->mdio.dev, sizeof(*priv), GFP_KERNEL);
+ 	if (!priv)
+ 		return -ENOMEM;
+ 
+ 	phydev->priv = priv;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  static struct phy_driver marvell_drivers[] = {
  	{
  		.phy_id = MARVELL_PHY_ID_88E1101,
diff --cc drivers/net/phy/mdio_bus.c
index 81d2fc391bba,e5b1ccde835b..000000000000
--- a/drivers/net/phy/mdio_bus.c
+++ b/drivers/net/phy/mdio_bus.c
@@@ -192,6 -194,50 +192,53 @@@ struct mii_bus *of_mdio_find_bus(struc
  	return d ? to_mii_bus(d) : NULL;
  }
  EXPORT_SYMBOL(of_mdio_find_bus);
++<<<<<<< HEAD
++=======
+ 
+ /* Walk the list of subnodes of a mdio bus and look for a node that matches the
+  * phy's address with its 'reg' property. If found, set the of_node pointer for
+  * the phy. This allows auto-probed pyh devices to be supplied with information
+  * passed in via DT.
+  */
+ static void of_mdiobus_link_phydev(struct mii_bus *bus,
+ 				   struct phy_device *phydev)
+ {
+ 	struct device *dev = &phydev->mdio.dev;
+ 	struct device_node *child;
+ 
+ 	if (dev->of_node || !bus->dev.of_node)
+ 		return;
+ 
+ 	for_each_available_child_of_node(bus->dev.of_node, child) {
+ 		int addr;
+ 		int ret;
+ 
+ 		ret = of_property_read_u32(child, "reg", &addr);
+ 		if (ret < 0) {
+ 			dev_err(dev, "%s has invalid PHY address\n",
+ 				child->full_name);
+ 			continue;
+ 		}
+ 
+ 		/* A PHY must have a reg property in the range [0-31] */
+ 		if (addr >= PHY_MAX_ADDR) {
+ 			dev_err(dev, "%s PHY address %i is too large\n",
+ 				child->full_name, addr);
+ 			continue;
+ 		}
+ 
+ 		if (addr == phydev->mdio.addr) {
+ 			dev->of_node = child;
+ 			return;
+ 		}
+ 	}
+ }
+ #else /* !IS_ENABLED(CONFIG_OF_MDIO) */
+ static inline void of_mdiobus_link_phydev(struct mii_bus *mdio,
+ 					  struct phy_device *phydev)
+ {
+ }
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  #endif
  
  /**
diff --cc drivers/net/phy/micrel.c
index 2510435f34ed,b51505be1fa9..000000000000
--- a/drivers/net/phy/micrel.c
+++ b/drivers/net/phy/micrel.c
@@@ -124,21 -273,239 +124,180 @@@ static int kszphy_config_init(struct ph
  	return 0;
  }
  
 -static int ksz9021_load_values_from_of(struct phy_device *phydev,
 -				       const struct device_node *of_node,
 -				       u16 reg,
 -				       const char *field1, const char *field2,
 -				       const char *field3, const char *field4)
 +static int ksz8021_config_init(struct phy_device *phydev)
  {
 -	int val1 = -1;
 -	int val2 = -2;
 -	int val3 = -3;
 -	int val4 = -4;
 -	int newval;
 -	int matches = 0;
 -
 -	if (!of_property_read_u32(of_node, field1, &val1))
 -		matches++;
 -
 -	if (!of_property_read_u32(of_node, field2, &val2))
 -		matches++;
 -
 -	if (!of_property_read_u32(of_node, field3, &val3))
 -		matches++;
 -
 -	if (!of_property_read_u32(of_node, field4, &val4))
 -		matches++;
 -
 -	if (!matches)
 -		return 0;
 -
 -	if (matches < 4)
 -		newval = kszphy_extended_read(phydev, reg);
 -	else
 -		newval = 0;
 -
 -	if (val1 != -1)
 -		newval = ((newval & 0xfff0) | ((val1 / PS_TO_REG) & 0xf) << 0);
 -
 -	if (val2 != -2)
 -		newval = ((newval & 0xff0f) | ((val2 / PS_TO_REG) & 0xf) << 4);
 -
 -	if (val3 != -3)
 -		newval = ((newval & 0xf0ff) | ((val3 / PS_TO_REG) & 0xf) << 8);
 -
 -	if (val4 != -4)
 -		newval = ((newval & 0x0fff) | ((val4 / PS_TO_REG) & 0xf) << 12);
 -
 -	return kszphy_extended_write(phydev, reg, newval);
 +	int rc;
 +	const u16 val = KSZPHY_OMSO_B_CAST_OFF | KSZPHY_OMSO_RMII_OVERRIDE;
 +	phy_write(phydev, MII_KSZPHY_OMSO, val);
 +	rc = ksz_config_flags(phydev);
 +	return rc < 0 ? rc : 0;
  }
  
 -static int ksz9021_config_init(struct phy_device *phydev)
 +static int ks8051_config_init(struct phy_device *phydev)
  {
++<<<<<<< HEAD
 +	int rc;
 +
 +	rc = ksz_config_flags(phydev);
 +	return rc < 0 ? rc : 0;
++=======
+ 	const struct device *dev = &phydev->mdio.dev;
+ 	const struct device_node *of_node = dev->of_node;
+ 	const struct device *dev_walker;
+ 
+ 	/* The Micrel driver has a deprecated option to place phy OF
+ 	 * properties in the MAC node. Walk up the tree of devices to
+ 	 * find a device with an OF node.
+ 	 */
+ 	dev_walker = &phydev->mdio.dev;
+ 	do {
+ 		of_node = dev_walker->of_node;
+ 		dev_walker = dev_walker->parent;
+ 
+ 	} while (!of_node && dev_walker);
+ 
+ 	if (of_node) {
+ 		ksz9021_load_values_from_of(phydev, of_node,
+ 				    MII_KSZPHY_CLK_CONTROL_PAD_SKEW,
+ 				    "txen-skew-ps", "txc-skew-ps",
+ 				    "rxdv-skew-ps", "rxc-skew-ps");
+ 		ksz9021_load_values_from_of(phydev, of_node,
+ 				    MII_KSZPHY_RX_DATA_PAD_SKEW,
+ 				    "rxd0-skew-ps", "rxd1-skew-ps",
+ 				    "rxd2-skew-ps", "rxd3-skew-ps");
+ 		ksz9021_load_values_from_of(phydev, of_node,
+ 				    MII_KSZPHY_TX_DATA_PAD_SKEW,
+ 				    "txd0-skew-ps", "txd1-skew-ps",
+ 				    "txd2-skew-ps", "txd3-skew-ps");
+ 	}
+ 	return 0;
+ }
+ 
+ #define MII_KSZ9031RN_MMD_CTRL_REG	0x0d
+ #define MII_KSZ9031RN_MMD_REGDATA_REG	0x0e
+ #define OP_DATA				1
+ #define KSZ9031_PS_TO_REG		60
+ 
+ /* Extended registers */
+ /* MMD Address 0x0 */
+ #define MII_KSZ9031RN_FLP_BURST_TX_LO	3
+ #define MII_KSZ9031RN_FLP_BURST_TX_HI	4
+ 
+ /* MMD Address 0x2 */
+ #define MII_KSZ9031RN_CONTROL_PAD_SKEW	4
+ #define MII_KSZ9031RN_RX_DATA_PAD_SKEW	5
+ #define MII_KSZ9031RN_TX_DATA_PAD_SKEW	6
+ #define MII_KSZ9031RN_CLK_PAD_SKEW	8
+ 
+ static int ksz9031_extended_write(struct phy_device *phydev,
+ 				  u8 mode, u32 dev_addr, u32 regnum, u16 val)
+ {
+ 	phy_write(phydev, MII_KSZ9031RN_MMD_CTRL_REG, dev_addr);
+ 	phy_write(phydev, MII_KSZ9031RN_MMD_REGDATA_REG, regnum);
+ 	phy_write(phydev, MII_KSZ9031RN_MMD_CTRL_REG, (mode << 14) | dev_addr);
+ 	return phy_write(phydev, MII_KSZ9031RN_MMD_REGDATA_REG, val);
+ }
+ 
+ static int ksz9031_extended_read(struct phy_device *phydev,
+ 				 u8 mode, u32 dev_addr, u32 regnum)
+ {
+ 	phy_write(phydev, MII_KSZ9031RN_MMD_CTRL_REG, dev_addr);
+ 	phy_write(phydev, MII_KSZ9031RN_MMD_REGDATA_REG, regnum);
+ 	phy_write(phydev, MII_KSZ9031RN_MMD_CTRL_REG, (mode << 14) | dev_addr);
+ 	return phy_read(phydev, MII_KSZ9031RN_MMD_REGDATA_REG);
+ }
+ 
+ static int ksz9031_of_load_skew_values(struct phy_device *phydev,
+ 				       const struct device_node *of_node,
+ 				       u16 reg, size_t field_sz,
+ 				       const char *field[], u8 numfields)
+ {
+ 	int val[4] = {-1, -2, -3, -4};
+ 	int matches = 0;
+ 	u16 mask;
+ 	u16 maxval;
+ 	u16 newval;
+ 	int i;
+ 
+ 	for (i = 0; i < numfields; i++)
+ 		if (!of_property_read_u32(of_node, field[i], val + i))
+ 			matches++;
+ 
+ 	if (!matches)
+ 		return 0;
+ 
+ 	if (matches < numfields)
+ 		newval = ksz9031_extended_read(phydev, OP_DATA, 2, reg);
+ 	else
+ 		newval = 0;
+ 
+ 	maxval = (field_sz == 4) ? 0xf : 0x1f;
+ 	for (i = 0; i < numfields; i++)
+ 		if (val[i] != -(i + 1)) {
+ 			mask = 0xffff;
+ 			mask ^= maxval << (field_sz * i);
+ 			newval = (newval & mask) |
+ 				(((val[i] / KSZ9031_PS_TO_REG) & maxval)
+ 					<< (field_sz * i));
+ 		}
+ 
+ 	return ksz9031_extended_write(phydev, OP_DATA, 2, reg, newval);
+ }
+ 
+ static int ksz9031_center_flp_timing(struct phy_device *phydev)
+ {
+ 	int result;
+ 
+ 	/* Center KSZ9031RNX FLP timing at 16ms. */
+ 	result = ksz9031_extended_write(phydev, OP_DATA, 0,
+ 					MII_KSZ9031RN_FLP_BURST_TX_HI, 0x0006);
+ 	result = ksz9031_extended_write(phydev, OP_DATA, 0,
+ 					MII_KSZ9031RN_FLP_BURST_TX_LO, 0x1A80);
+ 
+ 	if (result)
+ 		return result;
+ 
+ 	return genphy_restart_aneg(phydev);
+ }
+ 
+ static int ksz9031_config_init(struct phy_device *phydev)
+ {
+ 	const struct device *dev = &phydev->mdio.dev;
+ 	const struct device_node *of_node = dev->of_node;
+ 	static const char *clk_skews[2] = {"rxc-skew-ps", "txc-skew-ps"};
+ 	static const char *rx_data_skews[4] = {
+ 		"rxd0-skew-ps", "rxd1-skew-ps",
+ 		"rxd2-skew-ps", "rxd3-skew-ps"
+ 	};
+ 	static const char *tx_data_skews[4] = {
+ 		"txd0-skew-ps", "txd1-skew-ps",
+ 		"txd2-skew-ps", "txd3-skew-ps"
+ 	};
+ 	static const char *control_skews[2] = {"txen-skew-ps", "rxdv-skew-ps"};
+ 
+ 	if (!of_node && dev->parent->of_node)
+ 		of_node = dev->parent->of_node;
+ 
+ 	if (of_node) {
+ 		ksz9031_of_load_skew_values(phydev, of_node,
+ 				MII_KSZ9031RN_CLK_PAD_SKEW, 5,
+ 				clk_skews, 2);
+ 
+ 		ksz9031_of_load_skew_values(phydev, of_node,
+ 				MII_KSZ9031RN_CONTROL_PAD_SKEW, 4,
+ 				control_skews, 2);
+ 
+ 		ksz9031_of_load_skew_values(phydev, of_node,
+ 				MII_KSZ9031RN_RX_DATA_PAD_SKEW, 4,
+ 				rx_data_skews, 4);
+ 
+ 		ksz9031_of_load_skew_values(phydev, of_node,
+ 				MII_KSZ9031RN_TX_DATA_PAD_SKEW, 4,
+ 				tx_data_skews, 4);
+ 	}
+ 
+ 	return ksz9031_center_flp_timing(phydev);
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  }
  
  #define KSZ8873MLL_GLOBAL_CONTROL_4	0x06
@@@ -174,6 -562,132 +333,135 @@@ static int ksz8873mll_config_aneg(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* This routine returns -1 as an indication to the caller that the
+  * Micrel ksz9021 10/100/1000 PHY does not support standard IEEE
+  * MMD extended PHY registers.
+  */
+ static int
+ ksz9021_rd_mmd_phyreg(struct phy_device *phydev, int ptrad, int devnum,
+ 		      int regnum)
+ {
+ 	return -1;
+ }
+ 
+ /* This routine does nothing since the Micrel ksz9021 does not support
+  * standard IEEE MMD extended PHY registers.
+  */
+ static void
+ ksz9021_wr_mmd_phyreg(struct phy_device *phydev, int ptrad, int devnum,
+ 		      int regnum, u32 val)
+ {
+ }
+ 
+ static int kszphy_get_sset_count(struct phy_device *phydev)
+ {
+ 	return ARRAY_SIZE(kszphy_hw_stats);
+ }
+ 
+ static void kszphy_get_strings(struct phy_device *phydev, u8 *data)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(kszphy_hw_stats); i++) {
+ 		memcpy(data + i * ETH_GSTRING_LEN,
+ 		       kszphy_hw_stats[i].string, ETH_GSTRING_LEN);
+ 	}
+ }
+ 
+ #ifndef UINT64_MAX
+ #define UINT64_MAX              (u64)(~((u64)0))
+ #endif
+ static u64 kszphy_get_stat(struct phy_device *phydev, int i)
+ {
+ 	struct kszphy_hw_stat stat = kszphy_hw_stats[i];
+ 	struct kszphy_priv *priv = phydev->priv;
+ 	u64 val;
+ 
+ 	val = phy_read(phydev, stat.reg);
+ 	if (val < 0) {
+ 		val = UINT64_MAX;
+ 	} else {
+ 		val = val & ((1 << stat.bits) - 1);
+ 		priv->stats[i] += val;
+ 		val = priv->stats[i];
+ 	}
+ 
+ 	return val;
+ }
+ 
+ static void kszphy_get_stats(struct phy_device *phydev,
+ 			     struct ethtool_stats *stats, u64 *data)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(kszphy_hw_stats); i++)
+ 		data[i] = kszphy_get_stat(phydev, i);
+ }
+ 
+ static int kszphy_probe(struct phy_device *phydev)
+ {
+ 	const struct kszphy_type *type = phydev->drv->driver_data;
+ 	const struct device_node *np = phydev->mdio.dev.of_node;
+ 	struct kszphy_priv *priv;
+ 	struct clk *clk;
+ 	int ret;
+ 
+ 	priv = devm_kzalloc(&phydev->mdio.dev, sizeof(*priv), GFP_KERNEL);
+ 	if (!priv)
+ 		return -ENOMEM;
+ 
+ 	phydev->priv = priv;
+ 
+ 	priv->type = type;
+ 
+ 	if (type->led_mode_reg) {
+ 		ret = of_property_read_u32(np, "micrel,led-mode",
+ 				&priv->led_mode);
+ 		if (ret)
+ 			priv->led_mode = -1;
+ 
+ 		if (priv->led_mode > 3) {
+ 			phydev_err(phydev, "invalid led mode: 0x%02x\n",
+ 				   priv->led_mode);
+ 			priv->led_mode = -1;
+ 		}
+ 	} else {
+ 		priv->led_mode = -1;
+ 	}
+ 
+ 	clk = devm_clk_get(&phydev->mdio.dev, "rmii-ref");
+ 	/* NOTE: clk may be NULL if building without CONFIG_HAVE_CLK */
+ 	if (!IS_ERR_OR_NULL(clk)) {
+ 		unsigned long rate = clk_get_rate(clk);
+ 		bool rmii_ref_clk_sel_25_mhz;
+ 
+ 		priv->rmii_ref_clk_sel = type->has_rmii_ref_clk_sel;
+ 		rmii_ref_clk_sel_25_mhz = of_property_read_bool(np,
+ 				"micrel,rmii-reference-clock-select-25-mhz");
+ 
+ 		if (rate > 24500000 && rate < 25500000) {
+ 			priv->rmii_ref_clk_sel_val = rmii_ref_clk_sel_25_mhz;
+ 		} else if (rate > 49500000 && rate < 50500000) {
+ 			priv->rmii_ref_clk_sel_val = !rmii_ref_clk_sel_25_mhz;
+ 		} else {
+ 			phydev_err(phydev, "Clock rate out of range: %ld\n",
+ 				   rate);
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	/* Support legacy board-file configuration */
+ 	if (phydev->dev_flags & MICREL_PHY_50MHZ_CLK) {
+ 		priv->rmii_ref_clk_sel = true;
+ 		priv->rmii_ref_clk_sel_val = true;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  static struct phy_driver ksphy_driver[] = {
  {
  	.phy_id		= PHY_ID_KS8737,
diff --cc drivers/net/phy/phy.c
index 72b4ef80a369,8763bb20988a..000000000000
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@@ -328,25 -413,32 +329,25 @@@ int phy_mii_ioctl(struct phy_device *ph
  		return 0;
  
  	case SIOCSMIIREG:
- 		if (mii_data->phy_id == phydev->addr) {
+ 		if (mii_data->phy_id == phydev->mdio.addr) {
  			switch (mii_data->reg_num) {
  			case MII_BMCR:
 -				if ((val & (BMCR_RESET | BMCR_ANENABLE)) == 0) {
 -					if (phydev->autoneg == AUTONEG_ENABLE)
 -						change_autoneg = true;
 +				if ((val & (BMCR_RESET | BMCR_ANENABLE)) == 0)
  					phydev->autoneg = AUTONEG_DISABLE;
 -					if (val & BMCR_FULLDPLX)
 -						phydev->duplex = DUPLEX_FULL;
 -					else
 -						phydev->duplex = DUPLEX_HALF;
 -					if (val & BMCR_SPEED1000)
 -						phydev->speed = SPEED_1000;
 -					else if (val & BMCR_SPEED100)
 -						phydev->speed = SPEED_100;
 -					else phydev->speed = SPEED_10;
 -				}
 -				else {
 -					if (phydev->autoneg == AUTONEG_DISABLE)
 -						change_autoneg = true;
 +				else
  					phydev->autoneg = AUTONEG_ENABLE;
 -				}
 +				if (!phydev->autoneg && (val & BMCR_FULLDPLX))
 +					phydev->duplex = DUPLEX_FULL;
 +				else
 +					phydev->duplex = DUPLEX_HALF;
 +				if (!phydev->autoneg && (val & BMCR_SPEED1000))
 +					phydev->speed = SPEED_1000;
 +				else if (!phydev->autoneg &&
 +					 (val & BMCR_SPEED100))
 +					phydev->speed = SPEED_100;
  				break;
  			case MII_ADVERTISE:
 -				phydev->advertising = mii_adv_to_ethtool_adv_t(val);
 -				change_autoneg = true;
 +				phydev->advertising = val;
  				break;
  			default:
  				/* do nothing */
@@@ -354,12 -446,17 +355,17 @@@
  			}
  		}
  
- 		mdiobus_write(phydev->bus, mii_data->phy_id,
+ 		mdiobus_write(phydev->mdio.bus, mii_data->phy_id,
  			      mii_data->reg_num, val);
  
++<<<<<<< HEAD
 +		if (mii_data->reg_num == MII_BMCR &&
++=======
+ 		if (mii_data->phy_id == phydev->mdio.addr &&
+ 		    mii_data->reg_num == MII_BMCR &&
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  		    val & BMCR_RESET)
  			return phy_init_hw(phydev);
 -
 -		if (change_autoneg)
 -			return phy_start_aneg(phydev);
 -
  		return 0;
  
  	case SIOCSHWTSTAMP:
@@@ -544,12 -641,10 +550,12 @@@ phy_err
  int phy_start_interrupts(struct phy_device *phydev)
  {
  	atomic_set(&phydev->irq_disable, 0);
 -	if (request_irq(phydev->irq, phy_interrupt, 0, "phy_interrupt",
 -			phydev) < 0) {
 +	if (request_irq(phydev->irq, phy_interrupt,
 +				IRQF_SHARED,
 +				"phy_interrupt",
 +				phydev) < 0) {
  		pr_warn("%s: Can't get IRQ %d (PHY)\n",
- 			phydev->bus->name, phydev->irq);
+ 			phydev->mdio.bus->name, phydev->irq);
  		phydev->irq = PHY_POLL;
  		return 0;
  	}
@@@ -939,14 -1039,27 +945,34 @@@ static inline void mmd_phy_indirect(str
   * 3) Write reg 13 // MMD Data Command for MMD DEVAD
   * 3) Read  reg 14 // Read MMD data
   */
 -int phy_read_mmd_indirect(struct phy_device *phydev, int prtad, int devad)
 +static int phy_read_mmd_indirect(struct mii_bus *bus, int prtad, int devad,
 +				 int addr)
  {
++<<<<<<< HEAD
 +	mmd_phy_indirect(bus, prtad, devad, addr);
 +
 +	/* Read the content of the MMD's selected register */
 +	return bus->read(bus, addr, MII_MMD_DATA);
++=======
+ 	struct phy_driver *phydrv = phydev->drv;
+ 	int addr = phydev->mdio.addr;
+ 	int value = -1;
+ 
+ 	if (!phydrv->read_mmd_indirect) {
+ 		struct mii_bus *bus = phydev->mdio.bus;
+ 
+ 		mutex_lock(&bus->mdio_lock);
+ 		mmd_phy_indirect(bus, prtad, devad, addr);
+ 
+ 		/* Read the content of the MMD's selected register */
+ 		value = bus->read(bus, addr, MII_MMD_DATA);
+ 		mutex_unlock(&bus->mdio_lock);
+ 	} else {
+ 		value = phydrv->read_mmd_indirect(phydev, prtad, devad, addr);
+ 	}
+ 	return value;
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  }
 -EXPORT_SYMBOL(phy_read_mmd_indirect);
  
  /**
   * phy_write_mmd_indirect - writes data to the MMD registers
@@@ -964,14 -1076,26 +990,32 @@@
   * 3) Write reg 13 // MMD Data Command for MMD DEVAD
   * 3) Write reg 14 // Write MMD data
   */
 -void phy_write_mmd_indirect(struct phy_device *phydev, int prtad,
 -				   int devad, u32 data)
 +static void phy_write_mmd_indirect(struct mii_bus *bus, int prtad, int devad,
 +				   int addr, u32 data)
  {
++<<<<<<< HEAD
 +	mmd_phy_indirect(bus, prtad, devad, addr);
 +
 +	/* Write the data into MMD's selected register */
 +	bus->write(bus, addr, MII_MMD_DATA, data);
++=======
+ 	struct phy_driver *phydrv = phydev->drv;
+ 	int addr = phydev->mdio.addr;
+ 
+ 	if (!phydrv->write_mmd_indirect) {
+ 		struct mii_bus *bus = phydev->mdio.bus;
+ 
+ 		mutex_lock(&bus->mdio_lock);
+ 		mmd_phy_indirect(bus, prtad, devad, addr);
+ 
+ 		/* Write the data into MMD's selected register */
+ 		bus->write(bus, addr, MII_MMD_DATA, data);
+ 		mutex_unlock(&bus->mdio_lock);
+ 	} else {
+ 		phydrv->write_mmd_indirect(phydev, prtad, devad, addr, data);
+ 	}
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  }
 -EXPORT_SYMBOL(phy_write_mmd_indirect);
  
  /**
   * phy_init_eee - init and check the EEE feature
diff --cc drivers/net/phy/phy_device.c
index 8dd3432c8c20,01e5d52dc37c..000000000000
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@@ -154,10 -157,15 +155,15 @@@ struct phy_device *phy_device_create(st
  
  	/* We allocate the device, and initialize the default values */
  	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 -	if (!dev)
 -		return ERR_PTR(-ENOMEM);
 +	if (NULL == dev)
 +		return (struct phy_device *)PTR_ERR((void *)-ENOMEM);
  
- 	dev->dev.release = phy_device_release;
+ 	mdiodev = &dev->mdio;
+ 	mdiodev->dev.release = phy_device_release;
+ 	mdiodev->dev.parent = &bus->dev;
+ 	mdiodev->dev.bus = &mdio_bus_type;
+ 	mdiodev->bus = bus;
+ 	mdiodev->addr = addr;
  
  	dev->speed = 0;
  	dev->duplex = -1;
@@@ -172,12 -180,8 +178,16 @@@
  	dev->phy_id = phy_id;
  	if (c45_ids)
  		dev->c45_ids = *c45_ids;
++<<<<<<< HEAD
 +	dev->bus = bus;
 +	dev->dev.parent = bus->parent;
 +	dev->dev.bus = &mdio_bus_type;
 +	dev->irq = bus->irq != NULL ? bus->irq[addr] : PHY_POLL;
 +	dev_set_name(&dev->dev, PHY_ID_FMT, bus->id, addr);
++=======
+ 	dev->irq = bus->irq ? bus->irq[addr] : PHY_POLL;
+ 	dev_set_name(&mdiodev->dev, PHY_ID_FMT, bus->id, addr);
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  
  	dev->state = PHY_DOWN;
  
@@@ -569,6 -609,33 +579,36 @@@ int phy_init_hw(struct phy_device *phyd
  }
  EXPORT_SYMBOL(phy_init_hw);
  
++<<<<<<< HEAD
++=======
+ void phy_attached_info(struct phy_device *phydev)
+ {
+ 	phy_attached_print(phydev, NULL);
+ }
+ EXPORT_SYMBOL(phy_attached_info);
+ 
+ #define ATTACHED_FMT "attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)"
+ void phy_attached_print(struct phy_device *phydev, const char *fmt, ...)
+ {
+ 	if (!fmt) {
+ 		dev_info(&phydev->mdio.dev, ATTACHED_FMT "\n",
+ 			 phydev->drv->name, phydev_name(phydev),
+ 			 phydev->irq);
+ 	} else {
+ 		va_list ap;
+ 
+ 		dev_info(&phydev->mdio.dev, ATTACHED_FMT,
+ 			 phydev->drv->name, phydev_name(phydev),
+ 			 phydev->irq);
+ 
+ 		va_start(ap, fmt);
+ 		vprintk(fmt, ap);
+ 		va_end(ap);
+ 	}
+ }
+ EXPORT_SYMBOL(phy_attached_print);
+ 
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  /**
   * phy_attach_direct - attach a network device to a given PHY device pointer
   * @dev: network device to attach
@@@ -587,17 -654,11 +627,22 @@@
  int phy_attach_direct(struct net_device *dev, struct phy_device *phydev,
  		      u32 flags, phy_interface_t interface)
  {
++<<<<<<< HEAD
 +	struct module *ndev_owner = dev->dev.parent->driver->owner;
 +	struct mii_bus *bus = phydev->bus;
 +	struct device *d = &phydev->dev;
++=======
+ 	struct mii_bus *bus = phydev->mdio.bus;
+ 	struct device *d = &phydev->mdio.dev;
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  	int err;
  
 -	if (!try_module_get(bus->owner)) {
 +	/* For Ethernet device drivers that register their own MDIO bus, we
 +	 * will have bus->owner match ndev_mod, so we do not want to increment
 +	 * our own module->refcnt here, otherwise we would not be able to
 +	 * unload later on.
 +	 */
 +	if (ndev_owner != bus->owner && !try_module_get(bus->owner)) {
  		dev_err(&dev->dev, "failed to get the bus module\n");
  		return -EIO;
  	}
@@@ -725,18 -783,18 +770,23 @@@ void phy_detach(struct phy_device *phyd
  	 * The phydev might go away on the put_device() below, so avoid
  	 * a use-after-free bug by reading the underlying bus first.
  	 */
- 	bus = phydev->bus;
+ 	bus = phydev->mdio.bus;
  
++<<<<<<< HEAD
 +	put_device(&phydev->dev);
 +	if (ndev_owner != bus->owner)
 +		module_put(bus->owner);
++=======
+ 	put_device(&phydev->mdio.dev);
+ 	module_put(bus->owner);
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  }
  EXPORT_SYMBOL(phy_detach);
  
  int phy_suspend(struct phy_device *phydev)
  {
- 	struct phy_driver *phydrv = to_phy_driver(phydev->dev.driver);
+ 	struct phy_driver *phydrv = to_phy_driver(phydev->mdio.dev.driver);
  	struct ethtool_wolinfo wol = { .cmd = ETHTOOL_GWOL };
 -	int ret = 0;
  
  	/* If the device has WOL enabled, we cannot suspend the PHY */
  	phy_ethtool_get_wol(phydev, &wol);
@@@ -751,11 -815,18 +801,16 @@@ EXPORT_SYMBOL(phy_suspend)
  
  int phy_resume(struct phy_device *phydev)
  {
++<<<<<<< HEAD
 +	struct phy_driver *phydrv = to_phy_driver(phydev->dev.driver);
++=======
+ 	struct phy_driver *phydrv = to_phy_driver(phydev->mdio.dev.driver);
+ 	int ret = 0;
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  
  	if (phydrv->resume)
 -		ret = phydrv->resume(phydev);
 -
 -	if (ret)
 -		return ret;
 -
 -	phydev->suspended = false;
 -
 -	return ret;
 +		return phydrv->resume(phydev);
 +	return 0;
  }
  EXPORT_SYMBOL(phy_resume);
  
@@@ -1204,6 -1292,59 +1259,62 @@@ static int gen10g_resume(struct phy_dev
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int __set_phy_supported(struct phy_device *phydev, u32 max_speed)
+ {
+ 	/* The default values for phydev->supported are provided by the PHY
+ 	 * driver "features" member, we want to reset to sane defaults first
+ 	 * before supporting higher speeds.
+ 	 */
+ 	phydev->supported &= PHY_DEFAULT_FEATURES;
+ 
+ 	switch (max_speed) {
+ 	default:
+ 		return -ENOTSUPP;
+ 	case SPEED_1000:
+ 		phydev->supported |= PHY_1000BT_FEATURES;
+ 		/* fall through */
+ 	case SPEED_100:
+ 		phydev->supported |= PHY_100BT_FEATURES;
+ 		/* fall through */
+ 	case SPEED_10:
+ 		phydev->supported |= PHY_10BT_FEATURES;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int phy_set_max_speed(struct phy_device *phydev, u32 max_speed)
+ {
+ 	int err;
+ 
+ 	err = __set_phy_supported(phydev, max_speed);
+ 	if (err)
+ 		return err;
+ 
+ 	phydev->advertising = phydev->supported;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(phy_set_max_speed);
+ 
+ static void of_set_phy_supported(struct phy_device *phydev)
+ {
+ 	struct device_node *node = phydev->mdio.dev.of_node;
+ 	u32 max_speed;
+ 
+ 	if (!IS_ENABLED(CONFIG_OF_MDIO))
+ 		return;
+ 
+ 	if (!node)
+ 		return;
+ 
+ 	if (!of_property_read_u32(node, "max-speed", &max_speed))
+ 		__set_phy_supported(phydev, max_speed);
+ }
+ 
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  /**
   * phy_probe - probe and init a PHY device
   * @dev: device to probe and init
diff --cc drivers/net/phy/smsc.c
index 11f34813e23f,18c981b95910..000000000000
--- a/drivers/net/phy/smsc.c
+++ b/drivers/net/phy/smsc.c
@@@ -43,6 -43,31 +43,34 @@@ static int smsc_phy_ack_interrupt(struc
  
  static int smsc_phy_config_init(struct phy_device *phydev)
  {
++<<<<<<< HEAD
++=======
+ 	int __maybe_unused len;
+ 	struct device *dev __maybe_unused = &phydev->mdio.dev;
+ 	struct device_node *of_node __maybe_unused = dev->of_node;
+ 	int rc = phy_read(phydev, MII_LAN83C185_CTRL_STATUS);
+ 	int enable_energy = 1;
+ 
+ 	if (rc < 0)
+ 		return rc;
+ 
+ 	if (of_find_property(of_node, "smsc,disable-energy-detect", &len))
+ 		enable_energy = 0;
+ 
+ 	if (enable_energy) {
+ 		/* Enable energy detect mode for this SMSC Transceivers */
+ 		rc = phy_write(phydev, MII_LAN83C185_CTRL_STATUS,
+ 			       rc | MII_LAN83C185_EDPWRDOWN);
+ 		if (rc < 0)
+ 			return rc;
+ 	}
+ 
+ 	return smsc_phy_ack_interrupt(phydev);
+ }
+ 
+ static int smsc_phy_reset(struct phy_device *phydev)
+ {
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  	int rc = phy_read(phydev, MII_LAN83C185_SPECIAL_MODES);
  	if (rc < 0)
  		return rc;
diff --cc drivers/of/of_mdio.c
index f996232149b2,bc9d76329435..000000000000
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@@ -22,6 -24,96 +22,99 @@@
  MODULE_AUTHOR("Grant Likely <grant.likely@secretlab.ca>");
  MODULE_LICENSE("GPL");
  
++<<<<<<< HEAD
++=======
+ /* Extract the clause 22 phy ID from the compatible string of the form
+  * ethernet-phy-idAAAA.BBBB */
+ static int of_get_phy_id(struct device_node *device, u32 *phy_id)
+ {
+ 	struct property *prop;
+ 	const char *cp;
+ 	unsigned int upper, lower;
+ 
+ 	of_property_for_each_string(device, "compatible", prop, cp) {
+ 		if (sscanf(cp, "ethernet-phy-id%4x.%4x", &upper, &lower) == 2) {
+ 			*phy_id = ((upper & 0xFFFF) << 16) | (lower & 0xFFFF);
+ 			return 0;
+ 		}
+ 	}
+ 	return -EINVAL;
+ }
+ 
+ static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *child,
+ 				   u32 addr)
+ {
+ 	struct phy_device *phy;
+ 	bool is_c45;
+ 	int rc;
+ 	u32 phy_id;
+ 
+ 	is_c45 = of_device_is_compatible(child,
+ 					 "ethernet-phy-ieee802.3-c45");
+ 
+ 	if (!is_c45 && !of_get_phy_id(child, &phy_id))
+ 		phy = phy_device_create(mdio, addr, phy_id, 0, NULL);
+ 	else
+ 		phy = get_phy_device(mdio, addr, is_c45);
+ 	if (!phy || IS_ERR(phy))
+ 		return 1;
+ 
+ 	rc = irq_of_parse_and_map(child, 0);
+ 	if (rc > 0) {
+ 		phy->irq = rc;
+ 		if (mdio->irq)
+ 			mdio->irq[addr] = rc;
+ 	} else {
+ 		if (mdio->irq)
+ 			phy->irq = mdio->irq[addr];
+ 	}
+ 
+ 	if (of_property_read_bool(child, "broken-turn-around"))
+ 		mdio->phy_ignore_ta_mask |= 1 << addr;
+ 
+ 	/* Associate the OF node with the device structure so it
+ 	 * can be looked up later */
+ 	of_node_get(child);
+ 	phy->mdio.dev.of_node = child;
+ 
+ 	/* All data is now stored in the phy struct;
+ 	 * register it */
+ 	rc = phy_device_register(phy);
+ 	if (rc) {
+ 		phy_device_free(phy);
+ 		of_node_put(child);
+ 		return 1;
+ 	}
+ 
+ 	dev_dbg(&mdio->dev, "registered phy %s at address %i\n",
+ 		child->name, addr);
+ 
+ 	return 0;
+ }
+ 
+ int of_mdio_parse_addr(struct device *dev, const struct device_node *np)
+ {
+ 	u32 addr;
+ 	int ret;
+ 
+ 	ret = of_property_read_u32(np, "reg", &addr);
+ 	if (ret < 0) {
+ 		dev_err(dev, "%s has invalid PHY address\n", np->full_name);
+ 		return ret;
+ 	}
+ 
+ 	/* A PHY must have a reg property in the range [0-31] */
+ 	if (addr >= PHY_MAX_ADDR) {
+ 		dev_err(dev, "%s PHY address %i is too large\n",
+ 			np->full_name, addr);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return addr;
+ }
+ EXPORT_SYMBOL(of_mdio_parse_addr);
+ 
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  /**
   * of_mdiobus_register - Register mii_bus and create PHYs from the device tree
   * @mdio: pointer to mii_bus structure
@@@ -220,39 -240,123 +313,44 @@@ struct phy_device *of_phy_connect(struc
  EXPORT_SYMBOL(of_phy_connect);
  
  /**
 - * of_phy_attach - Attach to a PHY without starting the state machine
 + * of_phy_connect_fixed_link - Parse fixed-link property and return a dummy phy
   * @dev: pointer to net_device claiming the phy
 - * @phy_np: Node pointer for the PHY
 - * @flags: flags to pass to the PHY
 + * @hndlr: Link state callback for the network device
   * @iface: PHY data interface type
   *
 - * If successful, returns a pointer to the phy_device with the embedded
 - * struct device refcount incremented by one, or NULL on failure. The
 - * refcount must be dropped by calling phy_disconnect() or phy_detach().
 + * This function is a temporary stop-gap and will be removed soon.  It is
 + * only to support the fs_enet, ucc_geth and gianfar Ethernet drivers.  Do
 + * not call this function from new drivers.
   */
 -struct phy_device *of_phy_attach(struct net_device *dev,
 -				 struct device_node *phy_np, u32 flags,
 -				 phy_interface_t iface)
 +struct phy_device *of_phy_connect_fixed_link(struct net_device *dev,
 +					     void (*hndlr)(struct net_device *),
 +					     phy_interface_t iface)
  {
 -	struct phy_device *phy = of_phy_find_device(phy_np);
 -	int ret;
 +	struct device_node *net_np;
 +	char bus_id[MII_BUS_ID_SIZE + 3];
 +	struct phy_device *phy;
 +	const __be32 *phy_id;
 +	int sz;
  
 -	if (!phy)
 +	if (!dev->dev.parent)
  		return NULL;
  
 -	ret = phy_attach_direct(dev, phy, flags, iface);
 +	net_np = dev->dev.parent->of_node;
 +	if (!net_np)
 +		return NULL;
  
++<<<<<<< HEAD
 +	phy_id = of_get_property(net_np, "fixed-link", &sz);
 +	if (!phy_id || sz < sizeof(*phy_id))
 +		return NULL;
++=======
+ 	/* refcount is held by phy_attach_direct() on success */
+ 	put_device(&phy->mdio.dev);
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  
 -	return ret ? NULL : phy;
 -}
 -EXPORT_SYMBOL(of_phy_attach);
 -
 -#if defined(CONFIG_FIXED_PHY)
 -/*
 - * of_phy_is_fixed_link() and of_phy_register_fixed_link() must
 - * support two DT bindings:
 - * - the old DT binding, where 'fixed-link' was a property with 5
 - *   cells encoding various informations about the fixed PHY
 - * - the new DT binding, where 'fixed-link' is a sub-node of the
 - *   Ethernet device.
 - */
 -bool of_phy_is_fixed_link(struct device_node *np)
 -{
 -	struct device_node *dn;
 -	int len, err;
 -	const char *managed;
 -
 -	/* New binding */
 -	dn = of_get_child_by_name(np, "fixed-link");
 -	if (dn) {
 -		of_node_put(dn);
 -		return true;
 -	}
 -
 -	err = of_property_read_string(np, "managed", &managed);
 -	if (err == 0 && strcmp(managed, "auto") != 0)
 -		return true;
 -
 -	/* Old binding */
 -	if (of_get_property(np, "fixed-link", &len) &&
 -	    len == (5 * sizeof(__be32)))
 -		return true;
 -
 -	return false;
 -}
 -EXPORT_SYMBOL(of_phy_is_fixed_link);
 -
 -int of_phy_register_fixed_link(struct device_node *np)
 -{
 -	struct fixed_phy_status status = {};
 -	struct device_node *fixed_link_node;
 -	const __be32 *fixed_link_prop;
 -	int link_gpio;
 -	int len, err;
 -	struct phy_device *phy;
 -	const char *managed;
 -
 -	err = of_property_read_string(np, "managed", &managed);
 -	if (err == 0) {
 -		if (strcmp(managed, "in-band-status") == 0) {
 -			/* status is zeroed, namely its .link member */
 -			phy = fixed_phy_register(PHY_POLL, &status, -1, np);
 -			return IS_ERR(phy) ? PTR_ERR(phy) : 0;
 -		}
 -	}
 -
 -	/* New binding */
 -	fixed_link_node = of_get_child_by_name(np, "fixed-link");
 -	if (fixed_link_node) {
 -		status.link = 1;
 -		status.duplex = of_property_read_bool(fixed_link_node,
 -						      "full-duplex");
 -		if (of_property_read_u32(fixed_link_node, "speed", &status.speed))
 -			return -EINVAL;
 -		status.pause = of_property_read_bool(fixed_link_node, "pause");
 -		status.asym_pause = of_property_read_bool(fixed_link_node,
 -							  "asym-pause");
 -		link_gpio = of_get_named_gpio_flags(fixed_link_node,
 -						    "link-gpios", 0, NULL);
 -		of_node_put(fixed_link_node);
 -		if (link_gpio == -EPROBE_DEFER)
 -			return -EPROBE_DEFER;
 -
 -		phy = fixed_phy_register(PHY_POLL, &status, link_gpio, np);
 -		return IS_ERR(phy) ? PTR_ERR(phy) : 0;
 -	}
 -
 -	/* Old binding */
 -	fixed_link_prop = of_get_property(np, "fixed-link", &len);
 -	if (fixed_link_prop && len == (5 * sizeof(__be32))) {
 -		status.link = 1;
 -		status.duplex = be32_to_cpu(fixed_link_prop[1]);
 -		status.speed = be32_to_cpu(fixed_link_prop[2]);
 -		status.pause = be32_to_cpu(fixed_link_prop[3]);
 -		status.asym_pause = be32_to_cpu(fixed_link_prop[4]);
 -		phy = fixed_phy_register(PHY_POLL, &status, -1, np);
 -		return IS_ERR(phy) ? PTR_ERR(phy) : 0;
 -	}
 +	sprintf(bus_id, PHY_ID_FMT, "fixed-0", be32_to_cpu(phy_id[0]));
  
 -	return -ENODEV;
 +	phy = phy_connect(dev, bus_id, hndlr, iface);
 +	return IS_ERR(phy) ? NULL : phy;
  }
 -EXPORT_SYMBOL(of_phy_register_fixed_link);
 -#endif
 +EXPORT_SYMBOL(of_phy_connect_fixed_link);
diff --cc drivers/staging/et131x/et131x.c
index f73e58f5ef8d,3f3bcbea15bd..000000000000
--- a/drivers/staging/et131x/et131x.c
+++ b/drivers/staging/et131x/et131x.c
@@@ -1421,24 -1235,14 +1421,24 @@@ static int et131x_mii_read(struct et131
  	if (!phydev)
  		return -EIO;
  
- 	return et131x_phy_mii_read(adapter, phydev->addr, reg, value);
+ 	return et131x_phy_mii_read(adapter, phydev->mdio.addr, reg, value);
  }
  
 -static int et131x_mii_write(struct et131x_adapter *adapter, u8 addr, u8 reg,
 -			    u16 value)
 +/* et131x_mii_write - Write to a PHY reg through the MII interface of the MAC
 + * @adapter: pointer to our private adapter structure
 + * @reg: the register to read
 + * @value: 16-bit value to write
 + *
 + * FIXME: one caller in netdev still
 + *
 + * Return 0 on success, errno on failure (as defined in errno.h)
 + */
 +static int et131x_mii_write(struct et131x_adapter *adapter, u8 reg, u16 value)
  {
  	struct mac_regs __iomem *mac = &adapter->regs->mac;
 +	struct phy_device *phydev = adapter->phydev;
  	int status = 0;
 +	u8 addr;
  	u32 delay = 0;
  	u32 mii_addr;
  	u32 mii_cmd;
@@@ -1699,13 -1462,10 +1699,17 @@@ static void et1310_phy_power_down(struc
  	data &= ~BMCR_PDOWN;
  	if (down)
  		data |= BMCR_PDOWN;
++<<<<<<< HEAD:drivers/staging/et131x/et131x.c
 +	et131x_mii_write(adapter, MII_BMCR, data);
++=======
+ 	et131x_mii_write(adapter, phydev->mdio.addr, MII_BMCR, data);
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure):drivers/net/ethernet/agere/et131x.c
  }
  
 -/* et131x_xcvr_init - Init the phy if we are setting it into force mode */
 +/* et131x_xcvr_init - Init the phy if we are setting it into force mode
 + * @adapter: pointer to our private adapter structure
 + *
 + */
  static void et131x_xcvr_init(struct et131x_adapter *adapter)
  {
  	u16 lcr2;
@@@ -1729,7 -1490,7 +1733,11 @@@
  		else
  			lcr2 |= (LED_VAL_LINKON << LED_TXRX_SHIFT);
  
++<<<<<<< HEAD:drivers/staging/et131x/et131x.c
 +		et131x_mii_write(adapter, PHY_LED_2, lcr2);
++=======
+ 		et131x_mii_write(adapter, phydev->mdio.addr, PHY_LED_2, lcr2);
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure):drivers/net/ethernet/agere/et131x.c
  	}
  }
  
@@@ -3768,97 -3170,87 +3776,174 @@@ static void et131x_adjust_link(struct n
  	struct et131x_adapter *adapter = netdev_priv(netdev);
  	struct  phy_device *phydev = adapter->phydev;
  
++<<<<<<< HEAD:drivers/staging/et131x/et131x.c
 +	if (phydev && phydev->link != adapter->link) {
 +		/* Check to see if we are in coma mode and if
 +		 * so, disable it because we will not be able
 +		 * to read PHY values until we are out.
++=======
+ 	if (!phydev)
+ 		return;
+ 	if (phydev->link == adapter->link)
+ 		return;
+ 
+ 	/* Check to see if we are in coma mode and if
+ 	 * so, disable it because we will not be able
+ 	 * to read PHY values until we are out.
+ 	 */
+ 	if (et1310_in_phy_coma(adapter))
+ 		et1310_disable_phy_coma(adapter);
+ 
+ 	adapter->link = phydev->link;
+ 	phy_print_status(phydev);
+ 
+ 	if (phydev->link) {
+ 		adapter->boot_coma = 20;
+ 		if (phydev->speed == SPEED_10) {
+ 			u16 register18;
+ 
+ 			et131x_mii_read(adapter, PHY_MPHY_CONTROL_REG,
+ 					&register18);
+ 			et131x_mii_write(adapter, phydev->mdio.addr,
+ 					 PHY_MPHY_CONTROL_REG,
+ 					 register18 | 0x4);
+ 			et131x_mii_write(adapter, phydev->mdio.addr,
+ 					 PHY_INDEX_REG, register18 | 0x8402);
+ 			et131x_mii_write(adapter, phydev->mdio.addr,
+ 					 PHY_DATA_REG, register18 | 511);
+ 			et131x_mii_write(adapter, phydev->mdio.addr,
+ 					 PHY_MPHY_CONTROL_REG, register18);
+ 		}
+ 
+ 		et1310_config_flow_control(adapter);
+ 
+ 		if (phydev->speed == SPEED_1000 &&
+ 		    adapter->registry_jumbo_packet > 2048) {
+ 			u16 reg;
+ 
+ 			et131x_mii_read(adapter, PHY_CONFIG, &reg);
+ 			reg &= ~ET_PHY_CONFIG_TX_FIFO_DEPTH;
+ 			reg |= ET_PHY_CONFIG_FIFO_DEPTH_32;
+ 			et131x_mii_write(adapter, phydev->mdio.addr,
+ 					 PHY_CONFIG, reg);
+ 		}
+ 
+ 		et131x_set_rx_dma_timer(adapter);
+ 		et1310_config_mac_regs2(adapter);
+ 	} else {
+ 		adapter->boot_coma = 0;
+ 
+ 		if (phydev->speed == SPEED_10) {
+ 			u16 register18;
+ 
+ 			et131x_mii_read(adapter, PHY_MPHY_CONTROL_REG,
+ 					&register18);
+ 			et131x_mii_write(adapter, phydev->mdio.addr,
+ 					 PHY_MPHY_CONTROL_REG,
+ 					 register18 | 0x4);
+ 			et131x_mii_write(adapter, phydev->mdio.addr,
+ 					 PHY_INDEX_REG, register18 | 0x8402);
+ 			et131x_mii_write(adapter, phydev->mdio.addr,
+ 					 PHY_DATA_REG, register18 | 511);
+ 			et131x_mii_write(adapter, phydev->mdio.addr,
+ 					 PHY_MPHY_CONTROL_REG, register18);
+ 		}
+ 
+ 		et131x_free_busy_send_packets(adapter);
+ 		et131x_init_send(adapter);
+ 
+ 		/* Bring the device back to the state it was during
+ 		 * init prior to autonegotiation being complete. This
+ 		 * way, when we get the auto-neg complete interrupt,
+ 		 * we can complete init by calling config_mac_regs2.
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure):drivers/net/ethernet/agere/et131x.c
  		 */
 -		et131x_soft_reset(adapter);
 +		if (et1310_in_phy_coma(adapter))
 +			et1310_disable_phy_coma(adapter);
 +
 +		adapter->link = phydev->link;
 +		phy_print_status(phydev);
 +
 +		if (phydev->link) {
 +			adapter->boot_coma = 20;
 +			if (phydev && phydev->speed == SPEED_10) {
 +				/* NOTE - Is there a way to query this without
 +				 * TruePHY?
 +				 * && TRU_QueryCoreType(adapter->hTruePhy, 0)==
 +				 * EMI_TRUEPHY_A13O) {
 +				 */
 +				u16 register18;
 +
 +				et131x_mii_read(adapter, PHY_MPHY_CONTROL_REG,
 +						 &register18);
 +				et131x_mii_write(adapter, PHY_MPHY_CONTROL_REG,
 +						 register18 | 0x4);
 +				et131x_mii_write(adapter, PHY_INDEX_REG,
 +						 register18 | 0x8402);
 +				et131x_mii_write(adapter, PHY_DATA_REG,
 +						 register18 | 511);
 +				et131x_mii_write(adapter, PHY_MPHY_CONTROL_REG,
 +						 register18);
 +			}
 +
 +			et1310_config_flow_control(adapter);
 +
 +			if (phydev && phydev->speed == SPEED_1000 &&
 +					adapter->registry_jumbo_packet > 2048) {
 +				u16 reg;
 +
 +				et131x_mii_read(adapter, PHY_CONFIG, &reg);
 +				reg &= ~ET_PHY_CONFIG_TX_FIFO_DEPTH;
 +				reg |= ET_PHY_CONFIG_FIFO_DEPTH_32;
 +				et131x_mii_write(adapter, PHY_CONFIG, reg);
 +			}
 +
 +			et131x_set_rx_dma_timer(adapter);
 +			et1310_config_mac_regs2(adapter);
 +		} else {
 +			adapter->boot_coma = 0;
 +
 +			if (phydev->speed == SPEED_10) {
 +				/* NOTE - Is there a way to query this without
 +				 * TruePHY?
 +				 * && TRU_QueryCoreType(adapter->hTruePhy, 0) ==
 +				 * EMI_TRUEPHY_A13O)
 +				 */
 +				u16 register18;
 +
 +				et131x_mii_read(adapter, PHY_MPHY_CONTROL_REG,
 +						 &register18);
 +				et131x_mii_write(adapter, PHY_MPHY_CONTROL_REG,
 +						 register18 | 0x4);
 +				et131x_mii_write(adapter, PHY_INDEX_REG,
 +						 register18 | 0x8402);
 +				et131x_mii_write(adapter, PHY_DATA_REG,
 +						 register18 | 511);
 +				et131x_mii_write(adapter, PHY_MPHY_CONTROL_REG,
 +						 register18);
 +			}
 +
 +			/* Free the packets being actively sent & stopped */
 +			et131x_free_busy_send_packets(adapter);
  
 -		et131x_adapter_setup(adapter);
 +			/* Re-initialize the send structures */
 +			et131x_init_send(adapter);
 +
 +			/* Bring the device back to the state it was during
 +			 * init prior to autonegotiation being complete. This
 +			 * way, when we get the auto-neg complete interrupt,
 +			 * we can complete init by calling config_mac_regs2.
 +			 */
 +			et131x_soft_reset(adapter);
 +
 +			/* Setup ET1310 as per the documentation */
 +			et131x_adapter_setup(adapter);
 +
 +			/* perform reset of tx/rx */
 +			et131x_disable_txrx(netdev);
 +			et131x_enable_txrx(netdev);
 +		}
  
 -		et131x_disable_txrx(netdev);
 -		et131x_enable_txrx(netdev);
  	}
  }
  
diff --cc include/linux/phy.h
index 4477c1bcd079,239a0c2bc49d..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -413,9 -426,9 +408,10 @@@ struct phy_device 
  	u8 mdix;
  
  	void (*adjust_link)(struct net_device *dev);
 +	RH_KABI_DEPRECATE_FN(void, adjust_state, struct net_device *dev)
  };
- #define to_phy_device(d) container_of(d, struct phy_device, dev)
+ #define to_phy_device(d) container_of(to_mdio_device(d), \
+ 				      struct phy_device, mdio)
  
  /* struct phy_driver: Driver structure for a particular PHY type
   *
@@@ -632,9 -722,22 +628,9 @@@ static inline int phy_write_mmd(struct 
  
  	regnum = MII_ADDR_C45 | ((devad & 0x1f) << 16) | (regnum & 0xffff);
  
- 	return mdiobus_write(phydev->bus, phydev->addr, regnum, val);
+ 	return mdiobus_write(phydev->mdio.bus, phydev->mdio.addr, regnum, val);
  }
  
 -/**
 - * phy_write_mmd_indirect - writes data to the MMD registers
 - * @phydev: The PHY device
 - * @prtad: MMD Address
 - * @devad: MMD DEVAD
 - * @data: data to write in the MMD register
 - *
 - * Description: Write data from the MMD registers of the specified
 - * phy address.
 - */
 -void phy_write_mmd_indirect(struct phy_device *phydev, int prtad,
 -			    int devad, u32 data);
 -
  struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
  				     bool is_c45,
  				     struct phy_c45_device_ids *c45_ids);
@@@ -669,6 -771,22 +665,25 @@@ static inline int phy_read_status(struc
  	return phydev->drv->read_status(phydev);
  }
  
++<<<<<<< HEAD
++=======
+ #define phydev_err(_phydev, format, args...)	\
+ 	dev_err(&_phydev->mdio.dev, format, ##args)
+ 
+ #define phydev_dbg(_phydev, format, args...)	\
+ 	dev_dbg(&_phydev->mdio.dev, format, ##args);
+ 
+ static inline const char *phydev_name(const struct phy_device *phydev)
+ {
+ 	return dev_name(&phydev->mdio.dev);
+ }
+ 
+ void phy_attached_print(struct phy_device *phydev, const char *fmt, ...)
+ 	__printf(2, 3);
+ void phy_attached_info(struct phy_device *phydev);
+ int genphy_config_init(struct phy_device *phydev);
+ int genphy_setup_forced(struct phy_device *phydev);
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  int genphy_restart_aneg(struct phy_device *phydev);
  int genphy_config_aneg(struct phy_device *phydev);
  int genphy_aneg_done(struct phy_device *phydev);
diff --cc net/dsa/dsa.c
index 7a57da66c0a5,fa4daba8db55..000000000000
--- a/net/dsa/dsa.c
+++ b/net/dsa/dsa.c
@@@ -208,34 -420,92 +208,77 @@@ out
  
  static void dsa_switch_destroy(struct dsa_switch *ds)
  {
++<<<<<<< HEAD
++=======
+ 	struct device_node *port_dn;
+ 	struct phy_device *phydev;
+ 	struct dsa_chip_data *cd = ds->pd;
+ 	int port;
+ 
+ #ifdef CONFIG_NET_DSA_HWMON
+ 	if (ds->hwmon_dev)
+ 		hwmon_device_unregister(ds->hwmon_dev);
+ #endif
+ 
+ 	/* Disable configuration of the CPU and DSA ports */
+ 	for (port = 0; port < DSA_MAX_PORTS; port++) {
+ 		if (!(dsa_is_cpu_port(ds, port) || dsa_is_dsa_port(ds, port)))
+ 			continue;
+ 
+ 		port_dn = cd->port_dn[port];
+ 		if (of_phy_is_fixed_link(port_dn)) {
+ 			phydev = of_phy_find_device(port_dn);
+ 			if (phydev) {
+ 				int addr = phydev->mdio.addr;
+ 
+ 				phy_device_free(phydev);
+ 				of_node_put(port_dn);
+ 				fixed_phy_del(addr);
+ 			}
+ 		}
+ 	}
+ 
+ 	/* Destroy network devices for physical switch ports. */
+ 	for (port = 0; port < DSA_MAX_PORTS; port++) {
+ 		if (!(ds->phys_port_mask & (1 << port)))
+ 			continue;
+ 
+ 		if (!ds->ports[port])
+ 			continue;
+ 
+ 		dsa_slave_destroy(ds->ports[port]);
+ 	}
+ 
+ 	mdiobus_unregister(ds->slave_mii_bus);
++>>>>>>> e5a03bfd873c (phy: Add an mdio_device structure)
  }
  
 -#ifdef CONFIG_PM_SLEEP
 -static int dsa_switch_suspend(struct dsa_switch *ds)
 +
 +/* link polling *************************************************************/
 +static void dsa_link_poll_work(struct work_struct *ugly)
  {
 -	int i, ret = 0;
 +	struct dsa_switch_tree *dst;
 +	int i;
  
 -	/* Suspend slave network devices */
 -	for (i = 0; i < DSA_MAX_PORTS; i++) {
 -		if (!dsa_is_port_initialized(ds, i))
 -			continue;
 +	dst = container_of(ugly, struct dsa_switch_tree, link_poll_work);
  
 -		ret = dsa_slave_suspend(ds->ports[i]);
 -		if (ret)
 -			return ret;
 -	}
 +	for (i = 0; i < dst->pd->nr_chips; i++) {
 +		struct dsa_switch *ds = dst->ds[i];
  
 -	if (ds->drv->suspend)
 -		ret = ds->drv->suspend(ds);
 +		if (ds != NULL && ds->drv->poll_link != NULL)
 +			ds->drv->poll_link(ds);
 +	}
  
 -	return ret;
 +	mod_timer(&dst->link_poll_timer, round_jiffies(jiffies + HZ));
  }
  
 -static int dsa_switch_resume(struct dsa_switch *ds)
 +static void dsa_link_poll_timer(unsigned long _dst)
  {
 -	int i, ret = 0;
 -
 -	if (ds->drv->resume)
 -		ret = ds->drv->resume(ds);
 -
 -	if (ret)
 -		return ret;
 -
 -	/* Resume slave network devices */
 -	for (i = 0; i < DSA_MAX_PORTS; i++) {
 -		if (!dsa_is_port_initialized(ds, i))
 -			continue;
 -
 -		ret = dsa_slave_resume(ds->ports[i]);
 -		if (ret)
 -			return ret;
 -	}
 +	struct dsa_switch_tree *dst = (void *)_dst;
  
 -	return 0;
 +	schedule_work(&dst->link_poll_work);
  }
 -#endif
 +
  
  /* platform driver init and cleanup *****************************************/
  static int dev_is_class(struct device *dev, void *class)
* Unmerged path drivers/net/ethernet/altera/altera_tse_main.c
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmmii.c
* Unmerged path drivers/net/ethernet/freescale/fman/fman_dtsec.c
* Unmerged path drivers/net/ethernet/freescale/fman/fman_memac.c
* Unmerged path drivers/net/ethernet/hisilicon/hns/hns_ethtool.c
* Unmerged path drivers/net/phy/dp83867.c
* Unmerged path drivers/net/phy/microchip.c
* Unmerged path drivers/net/ethernet/altera/altera_tse_main.c
* Unmerged path drivers/net/ethernet/broadcom/b44.c
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmmii.c
diff --git a/drivers/net/ethernet/broadcom/sb1250-mac.c b/drivers/net/ethernet/broadcom/sb1250-mac.c
index 8be89b05a490..0f8aa0ef8aa7 100644
--- a/drivers/net/ethernet/broadcom/sb1250-mac.c
+++ b/drivers/net/ethernet/broadcom/sb1250-mac.c
@@ -2382,8 +2382,8 @@ static int sbmac_mii_probe(struct net_device *dev)
 		return -ENXIO;
 	}
 
-	phy_dev = phy_connect(dev, dev_name(&phy_dev->dev), &sbmac_mii_poll,
-			      PHY_INTERFACE_MODE_GMII);
+	phy_dev = phy_connect(dev, dev_name(&phy_dev->mdio.dev),
+			      &sbmac_mii_poll, PHY_INTERFACE_MODE_GMII);
 	if (IS_ERR(phy_dev)) {
 		printk(KERN_ERR "%s: could not attach to PHY\n", dev->name);
 		return PTR_ERR(phy_dev);
* Unmerged path drivers/net/ethernet/freescale/fman/fman_dtsec.c
* Unmerged path drivers/net/ethernet/freescale/fman/fman_memac.c
diff --git a/drivers/net/ethernet/freescale/fs_enet/mac-fec.c b/drivers/net/ethernet/freescale/fs_enet/mac-fec.c
index 9ae6cdbcac2e..0028922006d8 100644
--- a/drivers/net/ethernet/freescale/fs_enet/mac-fec.c
+++ b/drivers/net/ethernet/freescale/fs_enet/mac-fec.c
@@ -252,7 +252,7 @@ static void restart(struct net_device *dev)
 	int r;
 	u32 addrhi, addrlo;
 
-	struct mii_bus* mii = fep->phydev->bus;
+	struct mii_bus *mii = fep->phydev->mdio.bus;
 	struct fec_info* fec_inf = mii->priv;
 
 	r = whack_reset(fep->fec.fecp);
* Unmerged path drivers/net/ethernet/freescale/gianfar.c
* Unmerged path drivers/net/ethernet/freescale/ucc_geth.c
* Unmerged path drivers/net/ethernet/hisilicon/hns/hns_ethtool.c
* Unmerged path drivers/net/ethernet/marvell/mv643xx_eth.c
* Unmerged path drivers/net/ethernet/marvell/mvneta.c
diff --git a/drivers/net/ethernet/smsc/smsc911x.c b/drivers/net/ethernet/smsc/smsc911x.c
index 5b897f599a11..4fe0b33207da 100644
--- a/drivers/net/ethernet/smsc/smsc911x.c
+++ b/drivers/net/ethernet/smsc/smsc911x.c
@@ -865,8 +865,8 @@ static int smsc911x_phy_loopbacktest(struct net_device *dev)
 
 	for (i = 0; i < 10; i++) {
 		/* Set PHY to 10/FD, no ANEG, and loopback mode */
-		smsc911x_mii_write(phy_dev->bus, phy_dev->addr,	MII_BMCR,
-			BMCR_LOOPBACK | BMCR_FULLDPLX);
+		smsc911x_mii_write(phy_dev->mdio.bus, phy_dev->mdio.addr,
+				   MII_BMCR, BMCR_LOOPBACK | BMCR_FULLDPLX);
 
 		/* Enable MAC tx/rx, FD */
 		spin_lock_irqsave(&pdata->mac_lock, flags);
@@ -894,7 +894,7 @@ static int smsc911x_phy_loopbacktest(struct net_device *dev)
 	spin_unlock_irqrestore(&pdata->mac_lock, flags);
 
 	/* Cancel PHY loopback mode */
-	smsc911x_mii_write(phy_dev->bus, phy_dev->addr, MII_BMCR, 0);
+	smsc911x_mii_write(phy_dev->mdio.bus, phy_dev->mdio.addr, MII_BMCR, 0);
 
 	smsc911x_reg_write(pdata, TX_CFG, 0);
 	smsc911x_reg_write(pdata, RX_CFG, 0);
@@ -1022,7 +1022,7 @@ static int smsc911x_mii_probe(struct net_device *dev)
 	}
 
 	SMSC_TRACE(pdata, probe, "PHY: addr %d, phy_id 0x%08X",
-		   phydev->addr, phydev->phy_id);
+		   phydev->mdio.addr, phydev->phy_id);
 
 	ret = phy_connect_direct(dev, phydev, &smsc911x_phy_adjust_link,
 				 pdata->config.phy_interface);
@@ -1953,7 +1953,8 @@ smsc911x_ethtool_getregs(struct net_device *dev, struct ethtool_regs *regs,
 	}
 
 	for (i = 0; i <= 31; i++)
-		data[j++] = smsc911x_mii_read(phy_dev->bus, phy_dev->addr, i);
+		data[j++] = smsc911x_mii_read(phy_dev->mdio.bus,
+					      phy_dev->mdio.addr, i);
 }
 
 static void smsc911x_eeprom_enable_access(struct smsc911x_data *pdata)
diff --git a/drivers/net/ethernet/smsc/smsc9420.c b/drivers/net/ethernet/smsc/smsc9420.c
index 64fda33cebb1..d8163442ab65 100644
--- a/drivers/net/ethernet/smsc/smsc9420.c
+++ b/drivers/net/ethernet/smsc/smsc9420.c
@@ -331,7 +331,8 @@ smsc9420_ethtool_getregs(struct net_device *dev, struct ethtool_regs *regs,
 		return;
 
 	for (i = 0; i <= 31; i++)
-		data[j++] = smsc9420_mii_read(phy_dev->bus, phy_dev->addr, i);
+		data[j++] = smsc9420_mii_read(phy_dev->mdio.bus,
+					      phy_dev->mdio.addr, i);
 }
 
 static void smsc9420_eeprom_enable_access(struct smsc9420_pdata *pd)
* Unmerged path drivers/net/ethernet/ti/cpsw.c
* Unmerged path drivers/net/ethernet/ti/davinci_mdio.c
* Unmerged path drivers/net/ethernet/xilinx/xilinx_emaclite.c
* Unmerged path drivers/net/phy/at803x.c
diff --git a/drivers/net/phy/bcm87xx.c b/drivers/net/phy/bcm87xx.c
index 799789518e87..5b0b629220fe 100644
--- a/drivers/net/phy/bcm87xx.c
+++ b/drivers/net/phy/bcm87xx.c
@@ -40,10 +40,10 @@ static int bcm87xx_of_reg_init(struct phy_device *phydev)
 	const __be32 *paddr_end;
 	int len, ret;
 
-	if (!phydev->dev.of_node)
+	if (!phydev->mdio.dev.of_node)
 		return 0;
 
-	paddr = of_get_property(phydev->dev.of_node,
+	paddr = of_get_property(phydev->mdio.dev.of_node,
 				"broadcom,c45-reg-init", &len);
 	if (!paddr)
 		return 0;
diff --git a/drivers/net/phy/dp83640.c b/drivers/net/phy/dp83640.c
index 7490b6c866e6..3946f81b95e8 100644
--- a/drivers/net/phy/dp83640.c
+++ b/drivers/net/phy/dp83640.c
@@ -183,9 +183,10 @@ static void rx_timestamp_work(struct work_struct *work);
 
 #define BROADCAST_ADDR 31
 
-static inline int broadcast_write(struct mii_bus *bus, u32 regnum, u16 val)
+static inline int broadcast_write(struct phy_device *phydev, u32 regnum,
+				  u16 val)
 {
-	return mdiobus_write(bus, BROADCAST_ADDR, regnum, val);
+	return mdiobus_write(phydev->mdio.bus, BROADCAST_ADDR, regnum, val);
 }
 
 /* Caller must hold extreg_lock. */
@@ -195,7 +196,7 @@ static int ext_read(struct phy_device *phydev, int page, u32 regnum)
 	int val;
 
 	if (dp83640->clock->page != page) {
-		broadcast_write(phydev->bus, PAGESEL, page);
+		broadcast_write(phydev, PAGESEL, page);
 		dp83640->clock->page = page;
 	}
 	val = phy_read(phydev, regnum);
@@ -210,11 +211,11 @@ static void ext_write(int broadcast, struct phy_device *phydev,
 	struct dp83640_private *dp83640 = phydev->priv;
 
 	if (dp83640->clock->page != page) {
-		broadcast_write(phydev->bus, PAGESEL, page);
+		broadcast_write(phydev, PAGESEL, page);
 		dp83640->clock->page = page;
 	}
 	if (broadcast)
-		broadcast_write(phydev->bus, regnum, val);
+		broadcast_write(phydev, regnum, val);
 	else
 		phy_write(phydev, regnum, val);
 }
@@ -909,7 +910,7 @@ static int choose_this_phy(struct dp83640_clock *clock,
 	if (chosen_phy == -1 && !clock->chosen)
 		return 1;
 
-	if (chosen_phy == phydev->addr)
+	if (chosen_phy == phydev->mdio.addr)
 		return 1;
 
 	return 0;
@@ -966,10 +967,10 @@ static int dp83640_probe(struct phy_device *phydev)
 	struct dp83640_private *dp83640;
 	int err = -ENOMEM, i;
 
-	if (phydev->addr == BROADCAST_ADDR)
+	if (phydev->mdio.addr == BROADCAST_ADDR)
 		return 0;
 
-	clock = dp83640_clock_get_bus(phydev->bus);
+	clock = dp83640_clock_get_bus(phydev->mdio.bus);
 	if (!clock)
 		goto no_clock;
 
@@ -995,7 +996,8 @@ static int dp83640_probe(struct phy_device *phydev)
 
 	if (choose_this_phy(clock, phydev)) {
 		clock->chosen = dp83640;
-		clock->ptp_clock = ptp_clock_register(&clock->caps, &phydev->dev);
+		clock->ptp_clock = ptp_clock_register(&clock->caps,
+						      &phydev->mdio.dev);
 		if (IS_ERR(clock->ptp_clock)) {
 			err = PTR_ERR(clock->ptp_clock);
 			goto no_register;
@@ -1027,7 +1029,7 @@ static void dp83640_remove(struct phy_device *phydev)
 	struct dp83640_private *tmp, *dp83640 = phydev->priv;
 	struct sk_buff *skb;
 
-	if (phydev->addr == BROADCAST_ADDR)
+	if (phydev->mdio.addr == BROADCAST_ADDR)
 		return;
 
 	enable_status_frames(phydev, false);
* Unmerged path drivers/net/phy/dp83867.c
* Unmerged path drivers/net/phy/fixed_phy.c
diff --git a/drivers/net/phy/icplus.c b/drivers/net/phy/icplus.c
index b5ddd5077a80..4dd1cdadd8c7 100644
--- a/drivers/net/phy/icplus.c
+++ b/drivers/net/phy/icplus.c
@@ -53,43 +53,43 @@ static int ip175c_config_init(struct phy_device *phydev)
 	if (full_reset_performed == 0) {
 
 		/* master reset */
-		err = mdiobus_write(phydev->bus, 30, 0, 0x175c);
+		err = mdiobus_write(phydev->mdio.bus, 30, 0, 0x175c);
 		if (err < 0)
 			return err;
 
 		/* ensure no bus delays overlap reset period */
-		err = mdiobus_read(phydev->bus, 30, 0);
+		err = mdiobus_read(phydev->mdio.bus, 30, 0);
 
 		/* data sheet specifies reset period is 2 msec */
 		mdelay(2);
 
 		/* enable IP175C mode */
-		err = mdiobus_write(phydev->bus, 29, 31, 0x175c);
+		err = mdiobus_write(phydev->mdio.bus, 29, 31, 0x175c);
 		if (err < 0)
 			return err;
 
 		/* Set MII0 speed and duplex (in PHY mode) */
-		err = mdiobus_write(phydev->bus, 29, 22, 0x420);
+		err = mdiobus_write(phydev->mdio.bus, 29, 22, 0x420);
 		if (err < 0)
 			return err;
 
 		/* reset switch ports */
 		for (i = 0; i < 5; i++) {
-			err = mdiobus_write(phydev->bus, i,
+			err = mdiobus_write(phydev->mdio.bus, i,
 					    MII_BMCR, BMCR_RESET);
 			if (err < 0)
 				return err;
 		}
 
 		for (i = 0; i < 5; i++)
-			err = mdiobus_read(phydev->bus, i, MII_BMCR);
+			err = mdiobus_read(phydev->mdio.bus, i, MII_BMCR);
 
 		mdelay(2);
 
 		full_reset_performed = 1;
 	}
 
-	if (phydev->addr != 4) {
+	if (phydev->mdio.addr != 4) {
 		phydev->state = PHY_RUNNING;
 		phydev->speed = SPEED_100;
 		phydev->duplex = DUPLEX_FULL;
@@ -187,7 +187,7 @@ static int ip101a_g_config_init(struct phy_device *phydev)
 
 static int ip175c_read_status(struct phy_device *phydev)
 {
-	if (phydev->addr == 4) /* WAN port */
+	if (phydev->mdio.addr == 4) /* WAN port */
 		genphy_read_status(phydev);
 	else
 		/* Don't need to read status for switch ports */
@@ -198,7 +198,7 @@ static int ip175c_read_status(struct phy_device *phydev)
 
 static int ip175c_config_aneg(struct phy_device *phydev)
 {
-	if (phydev->addr == 4) /* WAN port */
+	if (phydev->mdio.addr == 4) /* WAN port */
 		genphy_config_aneg(phydev);
 
 	return 0;
* Unmerged path drivers/net/phy/marvell.c
* Unmerged path drivers/net/phy/mdio_bus.c
* Unmerged path drivers/net/phy/micrel.c
* Unmerged path drivers/net/phy/microchip.c
* Unmerged path drivers/net/phy/phy.c
* Unmerged path drivers/net/phy/phy_device.c
* Unmerged path drivers/net/phy/smsc.c
* Unmerged path drivers/of/of_mdio.c
* Unmerged path drivers/staging/et131x/et131x.c
diff --git a/include/linux/mdio.h b/include/linux/mdio.h
index 07a206d16ffc..c1cebe3639d8 100644
--- a/include/linux/mdio.h
+++ b/include/linux/mdio.h
@@ -13,6 +13,15 @@
 
 struct mii_bus;
 
+struct mdio_device {
+	struct device dev;
+
+	struct mii_bus *bus;
+	/* Bus address of the MDIO device (0-31) */
+	int addr;
+};
+#define to_mdio_device(d) container_of(d, struct mdio_device, dev)
+
 static inline bool mdio_phy_id_is_c45(int phy_id)
 {
 	return (phy_id & MDIO_PHY_ID_C45) && !(phy_id & ~MDIO_PHY_ID_C45_MASK);
* Unmerged path include/linux/phy.h
* Unmerged path net/dsa/dsa.c
