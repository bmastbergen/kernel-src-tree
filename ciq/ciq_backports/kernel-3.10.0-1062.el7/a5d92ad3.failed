efivars: Stop passing a struct argument to efivar_validate()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Matt Fleming <matt.fleming@intel.com>
commit a5d92ad32dad94fd8f3f61778561d532bb3a2f77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a5d92ad3.failed

In preparation for compat support, we can't assume that user variable
object is represented by a 'struct efi_variable'. Convert the validation
functions to take the variable name as an argument, which is the only
piece of the struct that was ever used anyway.

	Cc: Mike Waychison <mikew@google.com>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit a5d92ad32dad94fd8f3f61778561d532bb3a2f77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/efivars.c
diff --cc drivers/firmware/efi/efivars.c
index 5cbba0eea363,5ee2cfb96698..000000000000
--- a/drivers/firmware/efi/efivars.c
+++ b/drivers/firmware/efi/efivars.c
@@@ -242,8 -230,8 +242,13 @@@ efivar_store_raw(struct efivar_entry *e
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	if ((new_var->Attributes & ~EFI_VARIABLE_MASK) != 0 ||
 +	    efivar_validate(new_var, new_var->Data, new_var->DataSize) == false) {
++=======
+ 	if ((attributes & ~EFI_VARIABLE_MASK) != 0 ||
+ 	    efivar_validate(name, data, size) == false) {
++>>>>>>> a5d92ad32dad (efivars: Stop passing a struct argument to efivar_validate())
  		printk(KERN_ERR "efivars: Malformed variable content\n");
  		return -EINVAL;
  	}
@@@ -359,13 -339,25 +364,33 @@@ static ssize_t efivar_create(struct fil
  {
  	struct efi_variable *new_var = (struct efi_variable *)buf;
  	struct efivar_entry *new_entry;
++<<<<<<< HEAD
++=======
+ 	efi_char16_t *name;
+ 	unsigned long size;
+ 	u32 attributes;
+ 	u8 *data;
++>>>>>>> a5d92ad32dad (efivars: Stop passing a struct argument to efivar_validate())
  	int err;
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EACCES;
  
++<<<<<<< HEAD
 +	if ((new_var->Attributes & ~EFI_VARIABLE_MASK) != 0 ||
 +	    efivar_validate(new_var, new_var->Data, new_var->DataSize) == false) {
++=======
+ 	if (count != sizeof(*new_var))
+ 		return -EINVAL;
+ 
+ 	attributes = new_var->Attributes;
+ 	name = new_var->VariableName;
+ 	size = new_var->DataSize;
+ 	data = new_var->Data;
+ 
+ 	if ((attributes & ~EFI_VARIABLE_MASK) != 0 ||
+ 	    efivar_validate(name, data, size) == false) {
++>>>>>>> a5d92ad32dad (efivars: Stop passing a struct argument to efivar_validate())
  		printk(KERN_ERR "efivars: Malformed variable content\n");
  		return -EINVAL;
  	}
* Unmerged path drivers/firmware/efi/efivars.c
diff --git a/drivers/firmware/efi/vars.c b/drivers/firmware/efi/vars.c
index caf5f9efc1c2..75dcb8bd9d50 100644
--- a/drivers/firmware/efi/vars.c
+++ b/drivers/firmware/efi/vars.c
@@ -42,7 +42,7 @@ DECLARE_WORK(efivar_work, NULL);
 EXPORT_SYMBOL_GPL(efivar_work);
 
 static bool
-validate_device_path(struct efi_variable *var, int match, u8 *buffer,
+validate_device_path(efi_char16_t *var_name, int match, u8 *buffer,
 		     unsigned long len)
 {
 	struct efi_generic_dev_path *node;
@@ -75,7 +75,7 @@ validate_device_path(struct efi_variable *var, int match, u8 *buffer,
 }
 
 static bool
-validate_boot_order(struct efi_variable *var, int match, u8 *buffer,
+validate_boot_order(efi_char16_t *var_name, int match, u8 *buffer,
 		    unsigned long len)
 {
 	/* An array of 16-bit integers */
@@ -86,18 +86,18 @@ validate_boot_order(struct efi_variable *var, int match, u8 *buffer,
 }
 
 static bool
-validate_load_option(struct efi_variable *var, int match, u8 *buffer,
+validate_load_option(efi_char16_t *var_name, int match, u8 *buffer,
 		     unsigned long len)
 {
 	u16 filepathlength;
 	int i, desclength = 0, namelen;
 
-	namelen = ucs2_strnlen(var->VariableName, sizeof(var->VariableName));
+	namelen = ucs2_strnlen(var_name, EFI_VAR_NAME_LEN);
 
 	/* Either "Boot" or "Driver" followed by four digits of hex */
 	for (i = match; i < match+4; i++) {
-		if (var->VariableName[i] > 127 ||
-		    hex_to_bin(var->VariableName[i] & 0xff) < 0)
+		if (var_name[i] > 127 ||
+		    hex_to_bin(var_name[i] & 0xff) < 0)
 			return true;
 	}
 
@@ -132,12 +132,12 @@ validate_load_option(struct efi_variable *var, int match, u8 *buffer,
 	/*
 	 * And, finally, check the filepath
 	 */
-	return validate_device_path(var, match, buffer + desclength + 6,
+	return validate_device_path(var_name, match, buffer + desclength + 6,
 				    filepathlength);
 }
 
 static bool
-validate_uint16(struct efi_variable *var, int match, u8 *buffer,
+validate_uint16(efi_char16_t *var_name, int match, u8 *buffer,
 		unsigned long len)
 {
 	/* A single 16-bit integer */
@@ -148,7 +148,7 @@ validate_uint16(struct efi_variable *var, int match, u8 *buffer,
 }
 
 static bool
-validate_ascii_string(struct efi_variable *var, int match, u8 *buffer,
+validate_ascii_string(efi_char16_t *var_name, int match, u8 *buffer,
 		      unsigned long len)
 {
 	int i;
@@ -166,7 +166,7 @@ validate_ascii_string(struct efi_variable *var, int match, u8 *buffer,
 
 struct variable_validate {
 	char *name;
-	bool (*validate)(struct efi_variable *var, int match, u8 *data,
+	bool (*validate)(efi_char16_t *var_name, int match, u8 *data,
 			 unsigned long len);
 };
 
@@ -189,10 +189,10 @@ static const struct variable_validate variable_validate[] = {
 };
 
 bool
-efivar_validate(struct efi_variable *var, u8 *data, unsigned long len)
+efivar_validate(efi_char16_t *var_name, u8 *data, unsigned long len)
 {
 	int i;
-	u16 *unicode_name = var->VariableName;
+	u16 *unicode_name = var_name;
 
 	for (i = 0; variable_validate[i].validate != NULL; i++) {
 		const char *name = variable_validate[i].name;
@@ -208,7 +208,7 @@ efivar_validate(struct efi_variable *var, u8 *data, unsigned long len)
 
 			/* Wildcard in the matching name means we've matched */
 			if (c == '*')
-				return variable_validate[i].validate(var,
+				return variable_validate[i].validate(var_name,
 							     match, data, len);
 
 			/* Case sensitive match */
@@ -217,7 +217,7 @@ efivar_validate(struct efi_variable *var, u8 *data, unsigned long len)
 
 			/* Reached the end of the string while matching */
 			if (!c)
-				return variable_validate[i].validate(var,
+				return variable_validate[i].validate(var_name,
 							     match, data, len);
 		}
 	}
@@ -852,7 +852,7 @@ int efivar_entry_set_get_size(struct efivar_entry *entry, u32 attributes,
 
 	*set = false;
 
-	if (efivar_validate(&entry->var, data, *size) == false)
+	if (efivar_validate(name, data, *size) == false)
 		return -EINVAL;
 
 	/*
diff --git a/include/linux/efi.h b/include/linux/efi.h
index ce99ad24fa74..2b8f48ebfdb8 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -1155,8 +1155,10 @@ struct efivars {
  * and we use a page for reading/writing.
  */
 
+#define EFI_VAR_NAME_LEN	1024
+
 struct efi_variable {
-	efi_char16_t  VariableName[1024/sizeof(efi_char16_t)];
+	efi_char16_t  VariableName[EFI_VAR_NAME_LEN/sizeof(efi_char16_t)];
 	efi_guid_t    VendorGuid;
 	unsigned long DataSize;
 	__u8          Data[1024];
@@ -1239,7 +1241,7 @@ int efivar_entry_iter(int (*func)(struct efivar_entry *, void *),
 struct efivar_entry *efivar_entry_find(efi_char16_t *name, efi_guid_t guid,
 				       struct list_head *head, bool remove);
 
-bool efivar_validate(struct efi_variable *var, u8 *data, unsigned long len);
+bool efivar_validate(efi_char16_t *var_name, u8 *data, unsigned long len);
 
 extern struct work_struct efivar_work;
 void efivar_run_worker(void);
