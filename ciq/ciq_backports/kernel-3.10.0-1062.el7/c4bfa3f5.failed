seqcount: Introduce raw_write_seqcount_barrier()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit c4bfa3f5f906aee2e084c5b1fb15caf876338ef8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c4bfa3f5.failed

Introduce raw_write_seqcount_barrier(), a new construct that can be
used to provide write barrier semantics in seqcount read loops instead
of the usual consistency guarantee.

raw_write_seqcount_barier() is equivalent to:

	raw_write_seqcount_begin();
	raw_write_seqcount_end();

But avoids issueing two back-to-back smp_wmb() instructions.

This construct works because the read side will 'stall' when observing
odd values. This means that -- referring to the example in the comment
below -- even though there is no (matching) read barrier between the
loads of X and Y, we cannot observe !x && !y, because:

 - if we observe Y == false we must observe the first sequence
   increment, which makes us loop, until

 - we observe !(seq & 1) -- the second sequence increment -- at which
   time we must also observe T == true.

	Suggested-by: Oleg Nesterov <oleg@redhat.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: umgwanakikbuti@gmail.com
	Cc: ktkhai@parallels.com
	Cc: rostedt@goodmis.org
	Cc: juri.lelli@gmail.com
	Cc: pang.xunlei@linaro.org
	Cc: oleg@redhat.com
	Cc: wanpeng.li@linux.intel.com
	Cc: Al Viro <viro@ZenIV.linux.org.uk>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Link: http://lkml.kernel.org/r/20150617122924.GP3644@twins.programming.kicks-ass.net
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit c4bfa3f5f906aee2e084c5b1fb15caf876338ef8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/seqlock.h
diff --cc include/linux/seqlock.h
index 48f2f69e3867,486e685a226a..000000000000
--- a/include/linux/seqlock.h
+++ b/include/linux/seqlock.h
@@@ -171,6 -220,60 +171,63 @@@ static inline int read_seqcount_retry(c
  }
  
  
++<<<<<<< HEAD
++=======
+ 
+ static inline void raw_write_seqcount_begin(seqcount_t *s)
+ {
+ 	s->sequence++;
+ 	smp_wmb();
+ }
+ 
+ static inline void raw_write_seqcount_end(seqcount_t *s)
+ {
+ 	smp_wmb();
+ 	s->sequence++;
+ }
+ 
+ /**
+  * raw_write_seqcount_barrier - do a seq write barrier
+  * @s: pointer to seqcount_t
+  *
+  * This can be used to provide an ordering guarantee instead of the
+  * usual consistency guarantee. It is one wmb cheaper, because we can
+  * collapse the two back-to-back wmb()s.
+  *
+  *      seqcount_t seq;
+  *      bool X = true, Y = false;
+  *
+  *      void read(void)
+  *      {
+  *              bool x, y;
+  *
+  *              do {
+  *                      int s = read_seqcount_begin(&seq);
+  *
+  *                      x = X; y = Y;
+  *
+  *              } while (read_seqcount_retry(&seq, s));
+  *
+  *              BUG_ON(!x && !y);
+  *      }
+  *
+  *      void write(void)
+  *      {
+  *              Y = true;
+  *
+  *              raw_write_seqcount_barrier(seq);
+  *
+  *              X = false;
+  *      }
+  */
+ static inline void raw_write_seqcount_barrier(seqcount_t *s)
+ {
+ 	s->sequence++;
+ 	smp_wmb();
+ 	s->sequence++;
+ }
+ 
++>>>>>>> c4bfa3f5f906 (seqcount: Introduce raw_write_seqcount_barrier())
  /*
   * raw_write_seqcount_latch - redirect readers to even/odd copy
   * @s: pointer to seqcount_t
* Unmerged path include/linux/seqlock.h
