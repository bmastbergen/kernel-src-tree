ext4: fix incorrect quotaoff if the quota feature is enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author zhangyi (F) <yi.zhang@huawei.com>
commit b0a5a9589decd07db755d6a8d9c0910d96ff7992
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/b0a5a958.failed

Current ext4 quota should always "usage enabled" if the
quota feautre is enabled. But in ext4_orphan_cleanup(), it
turn quotas off directly (used for the older journaled
quota), so we cannot turn it on again via "quotaon" unless
umount and remount ext4.

Simple reproduce:

  mkfs.ext4 -O project,quota /dev/vdb1
  mount -o prjquota /dev/vdb1 /mnt
  chattr -p 123 /mnt
  chattr +P /mnt
  touch /mnt/aa /mnt/bb
  exec 100<>/mnt/aa
  rm -f /mnt/aa
  sync
  echo c > /proc/sysrq-trigger

  #reboot and mount
  mount -o prjquota /dev/vdb1 /mnt
  #query status
  quotaon -Ppv /dev/vdb1
  #output
  quotaon: Cannot find mountpoint for device /dev/vdb1
  quotaon: No correct mountpoint specified.

This patch add check for journaled quotas to avoid incorrect
quotaoff when ext4 has quota feautre.

	Signed-off-by: zhangyi (F) <yi.zhang@huawei.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Cc: stable@vger.kernel.org # 3.18
(cherry picked from commit b0a5a9589decd07db755d6a8d9c0910d96ff7992)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/super.c
diff --cc fs/ext4/super.c
index fd0252f29e8f,cade5c894f4a..000000000000
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@@ -2281,8 -2442,8 +2281,13 @@@ static void ext4_orphan_cleanup(struct 
  #ifdef CONFIG_QUOTA
  	/* Needed for iput() to work correctly and not trash data */
  	sb->s_flags |= MS_ACTIVE;
++<<<<<<< HEAD
 +	/* Turn on quotas so that they are updated correctly */
 +	for (i = 0; i < MAXQUOTAS; i++) {
++=======
+ 	/* Turn on journaled quotas so that they are updated correctly */
+ 	for (i = 0; i < EXT4_MAXQUOTAS; i++) {
++>>>>>>> b0a5a9589dec (ext4: fix incorrect quotaoff if the quota feature is enabled)
  		if (EXT4_SB(sb)->s_qf_names[i]) {
  			int ret = ext4_quota_on_mount(sb, i);
  			if (ret < 0)
@@@ -2347,9 -2510,9 +2352,15 @@@
  		ext4_msg(sb, KERN_INFO, "%d truncate%s cleaned up",
  		       PLURAL(nr_truncates));
  #ifdef CONFIG_QUOTA
++<<<<<<< HEAD
 +	/* Turn quotas off */
 +	for (i = 0; i < MAXQUOTAS; i++) {
 +		if (sb_dqopt(sb)->files[i])
++=======
+ 	/* Turn off journaled quotas if they were enabled for orphan cleanup */
+ 	for (i = 0; i < EXT4_MAXQUOTAS; i++) {
+ 		if (EXT4_SB(sb)->s_qf_names[i] && sb_dqopt(sb)->files[i])
++>>>>>>> b0a5a9589dec (ext4: fix incorrect quotaoff if the quota feature is enabled)
  			dquot_quota_off(sb, i);
  	}
  #endif
* Unmerged path fs/ext4/super.c
