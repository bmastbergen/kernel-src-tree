net/mlx5e: Vxlan, move vxlan logic to core driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Vxlan, move vxlan logic to core driver (Alaa Hleihel) [1642498]
Rebuild_FUZZ: 95.74%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 358aa5ce288aa1085f0f3ef9f315119563fa6541
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/358aa5ce.failed

Move vxlan logic and objects to mlx5 core dirver.
Since it going to be used from different mlx5 interfaces.
e.g. mlx5e PF NIC netdev and mlx5e E-Switch representors.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
(cherry picked from commit 358aa5ce288aa1085f0f3ef9f315119563fa6541)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/Makefile
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/Makefile
index 7500fab9286b,f20fda1ced4f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
@@@ -13,8 -14,8 +13,13 @@@ mlx5_core-$(CONFIG_MLX5_FPGA) += fpga/c
  		fpga/ipsec.o fpga/tls.o
  
  mlx5_core-$(CONFIG_MLX5_CORE_EN) += en_main.o en_common.o en_fs.o en_ethtool.o \
++<<<<<<< HEAD
 +		en_tx.o en_rx.o en_dim.o en_txrx.o en_stats.o vxlan.o \
 +		en_arfs.o en_fs_ethtool.o en_selftest.o
++=======
+ 		en_tx.o en_rx.o en_dim.o en_txrx.o en/xdp.o en_stats.o \
+ 		en_arfs.o en_fs_ethtool.o en_selftest.o en/port.o lib/vxlan.o
++>>>>>>> 358aa5ce288a (net/mlx5e: Vxlan, move vxlan logic to core driver)
  
  mlx5_core-$(CONFIG_MLX5_MPFS) += lib/mpfs.o
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index 575afb9430fa,c7ed3d20fd54..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -52,6 -52,11 +52,14 @@@
  #include "wq.h"
  #include "mlx5_core.h"
  #include "en_stats.h"
++<<<<<<< HEAD
++=======
+ 
+ struct page_pool;
+ 
+ #define MLX5E_METADATA_ETHER_TYPE (0x8CE4)
+ #define MLX5E_METADATA_ETHER_LEN 8
++>>>>>>> 358aa5ce288a (net/mlx5e: Vxlan, move vxlan logic to core driver)
  
  #define MLX5_SET_CFG(p, f, v) MLX5_SET(create_flow_group_in, p, f, v)
  
@@@ -773,7 -811,6 +781,10 @@@ struct mlx5e_priv 
  	u32                        tx_rates[MLX5E_MAX_NUM_SQS];
  
  	struct mlx5e_flow_steering fs;
++<<<<<<< HEAD
 +	struct mlx5e_vxlan_db      vxlan;
++=======
++>>>>>>> 358aa5ce288a (net/mlx5e: Vxlan, move vxlan logic to core driver)
  
  	struct workqueue_struct    *wq;
  	struct work_struct         update_carrier_work;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index f4e90173ee9f,fde35021a257..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -51,7 -45,9 +51,13 @@@
  #include "en_accel/tls.h"
  #include "accel/ipsec.h"
  #include "accel/tls.h"
++<<<<<<< HEAD
 +#include "vxlan.h"
++=======
+ #include "lib/vxlan.h"
+ #include "en/port.h"
+ #include "en/xdp.h"
++>>>>>>> 358aa5ce288a (net/mlx5e: Vxlan, move vxlan logic to core driver)
  
  struct mlx5e_rq_param {
  	u32			rqc[MLX5_ST_SZ_DW(rqc)];
@@@ -2611,7 -2974,7 +2617,11 @@@ int mlx5e_open(struct net_device *netde
  		mlx5_set_port_admin_status(priv->mdev, MLX5_PORT_UP);
  	mutex_unlock(&priv->state_lock);
  
++<<<<<<< HEAD
 +	if (mlx5e_vxlan_allowed(priv->mdev))
++=======
+ 	if (mlx5_vxlan_allowed(priv->mdev->vxlan))
++>>>>>>> 358aa5ce288a (net/mlx5e: Vxlan, move vxlan logic to core driver)
  		udp_tunnel_get_rx_info(netdev);
  
  	return err;
@@@ -3578,7 -3983,7 +3588,11 @@@ static void mlx5e_vxlan_add_work(struc
  	u16 port = vxlan_work->port;
  
  	mutex_lock(&priv->state_lock);
++<<<<<<< HEAD
 +	mlx5e_vxlan_add_port(priv, port);
++=======
+ 	mlx5_vxlan_add_port(priv->mdev->vxlan, port);
++>>>>>>> 358aa5ce288a (net/mlx5e: Vxlan, move vxlan logic to core driver)
  	mutex_unlock(&priv->state_lock);
  
  	kfree(vxlan_work);
@@@ -3592,7 -3997,7 +3606,11 @@@ static void mlx5e_vxlan_del_work(struc
  	u16 port = vxlan_work->port;
  
  	mutex_lock(&priv->state_lock);
++<<<<<<< HEAD
 +	mlx5e_vxlan_del_port(priv, port);
++=======
+ 	mlx5_vxlan_del_port(priv->mdev->vxlan, port);
++>>>>>>> 358aa5ce288a (net/mlx5e: Vxlan, move vxlan logic to core driver)
  	mutex_unlock(&priv->state_lock);
  	kfree(vxlan_work);
  }
@@@ -3623,7 -4028,7 +3641,11 @@@ static void mlx5e_add_vxlan_port(struc
  	if (ti->type != UDP_TUNNEL_TYPE_VXLAN)
  		return;
  
++<<<<<<< HEAD
 +	if (!mlx5e_vxlan_allowed(priv->mdev))
++=======
+ 	if (!mlx5_vxlan_allowed(priv->mdev->vxlan))
++>>>>>>> 358aa5ce288a (net/mlx5e: Vxlan, move vxlan logic to core driver)
  		return;
  
  	mlx5e_vxlan_queue_work(priv, be16_to_cpu(ti->port), 1);
@@@ -3637,7 -4042,7 +3659,11 @@@ static void mlx5e_del_vxlan_port(struc
  	if (ti->type != UDP_TUNNEL_TYPE_VXLAN)
  		return;
  
++<<<<<<< HEAD
 +	if (!mlx5e_vxlan_allowed(priv->mdev))
++=======
+ 	if (!mlx5_vxlan_allowed(priv->mdev->vxlan))
++>>>>>>> 358aa5ce288a (net/mlx5e: Vxlan, move vxlan logic to core driver)
  		return;
  
  	mlx5e_vxlan_queue_work(priv, be16_to_cpu(ti->port), 0);
@@@ -3671,7 -4076,7 +3697,11 @@@ static netdev_features_t mlx5e_tunnel_f
  		port = be16_to_cpu(udph->dest);
  
  		/* Verify if UDP port is being offloaded by HW */
++<<<<<<< HEAD
 +		if (mlx5e_vxlan_lookup_port(priv, port))
++=======
+ 		if (mlx5_vxlan_lookup_port(priv->mdev->vxlan, port))
++>>>>>>> 358aa5ce288a (net/mlx5e: Vxlan, move vxlan logic to core driver)
  			return features;
  	}
  
@@@ -4250,8 -4648,7 +4280,12 @@@ static void mlx5e_build_nic_netdev(stru
  	netdev->hw_features      |= NETIF_F_HW_VLAN_CTAG_FILTER;
  	netdev->hw_features      |= NETIF_F_HW_VLAN_STAG_TX;
  
++<<<<<<< HEAD
 +	if (mlx5e_vxlan_allowed(mdev) || MLX5_CAP_ETH(mdev, tunnel_stateless_gre)) {
 +		netdev->hw_features     |= NETIF_F_GSO_PARTIAL;
++=======
+ 	if (mlx5_vxlan_allowed(mdev->vxlan) || MLX5_CAP_ETH(mdev, tunnel_stateless_gre)) {
++>>>>>>> 358aa5ce288a (net/mlx5e: Vxlan, move vxlan logic to core driver)
  		netdev->hw_enc_features |= NETIF_F_IP_CSUM;
  		netdev->hw_enc_features |= NETIF_F_IPV6_CSUM;
  		netdev->hw_enc_features |= NETIF_F_TSO;
@@@ -4259,7 -4656,7 +4293,11 @@@
  		netdev->hw_enc_features |= NETIF_F_GSO_PARTIAL;
  	}
  
++<<<<<<< HEAD
 +	if (mlx5e_vxlan_allowed(mdev)) {
++=======
+ 	if (mlx5_vxlan_allowed(mdev->vxlan)) {
++>>>>>>> 358aa5ce288a (net/mlx5e: Vxlan, move vxlan logic to core driver)
  		netdev->hw_features     |= NETIF_F_GSO_UDP_TUNNEL |
  					   NETIF_F_GSO_UDP_TUNNEL_CSUM;
  		netdev->hw_enc_features |= NETIF_F_GSO_UDP_TUNNEL |
@@@ -4367,11 -4771,8 +4405,15 @@@ static void mlx5e_nic_init(struct mlx5_
  
  static void mlx5e_nic_cleanup(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
++=======
+ 	mlx5e_tls_cleanup(priv);
++>>>>>>> 358aa5ce288a (net/mlx5e: Vxlan, move vxlan logic to core driver)
  	mlx5e_ipsec_cleanup(priv);
 +	mlx5e_vxlan_cleanup(priv);
 +
 +	if (priv->channels.params.xdp_prog)
 +		bpf_prog_put(priv->channels.params.xdp_prog);
  }
  
  static int mlx5e_init_nic_rx(struct mlx5e_priv *priv)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 34f949800898,288a57f76e84..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -50,8 -50,9 +50,8 @@@
  #include "en_rep.h"
  #include "en_tc.h"
  #include "eswitch.h"
- #include "vxlan.h"
+ #include "lib/vxlan.h"
  #include "fs_core.h"
 -#include "en/port.h"
  
  struct mlx5_nic_flow_attr {
  	u32 action;
@@@ -1103,7 -1133,7 +1103,11 @@@ static int parse_tunnel_attr(struct mlx
  		if (memchr_inv(&mask->dst, 0xff, sizeof(mask->dst)))
  			goto vxlan_match_offload_err;
  
++<<<<<<< HEAD
 +		if (mlx5e_vxlan_lookup_port(up_priv, be16_to_cpu(key->dst)) &&
++=======
+ 		if (mlx5_vxlan_lookup_port(up_priv->mdev->vxlan, be16_to_cpu(key->dst)) &&
++>>>>>>> 358aa5ce288a (net/mlx5e: Vxlan, move vxlan logic to core driver)
  		    MLX5_CAP_ESW(priv->mdev, vxlan_encap_decap))
  			parse_vxlan_attr(spec, f);
  		else {
@@@ -2512,7 -2557,7 +2516,11 @@@ vxlan_encap_offload_err
  		return -EOPNOTSUPP;
  	}
  
++<<<<<<< HEAD
 +	if (mlx5e_vxlan_lookup_port(up_priv, be16_to_cpu(key->tp_dst)) &&
++=======
+ 	if (mlx5_vxlan_lookup_port(up_priv->mdev->vxlan, be16_to_cpu(key->tp_dst)) &&
++>>>>>>> 358aa5ce288a (net/mlx5e: Vxlan, move vxlan logic to core driver)
  	    MLX5_CAP_ESW(priv->mdev, vxlan_encap_decap)) {
  		tunnel_type = MLX5_HEADER_TYPE_VXLAN;
  	} else {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/Makefile
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/vxlan.c b/drivers/net/ethernet/mellanox/mlx5/core/lib/vxlan.c
similarity index 100%
rename from drivers/net/ethernet/mellanox/mlx5/core/vxlan.c
rename to drivers/net/ethernet/mellanox/mlx5/core/lib/vxlan.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/vxlan.h b/drivers/net/ethernet/mellanox/mlx5/core/lib/vxlan.h
similarity index 100%
rename from drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
rename to drivers/net/ethernet/mellanox/mlx5/core/lib/vxlan.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c
index 706907fd69d6..462435b26a70 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@ -61,6 +61,7 @@
 #include "accel/ipsec.h"
 #include "accel/tls.h"
 #include "lib/clock.h"
+#include "lib/vxlan.h"
 #include "diag/fw_tracer.h"
 
 MODULE_AUTHOR("Eli Cohen <eli@mellanox.com>");
@@ -993,6 +994,8 @@ static int mlx5_init_once(struct mlx5_core_dev *dev, struct mlx5_priv *priv)
 
 	mlx5_init_clock(dev);
 
+	dev->vxlan = mlx5_vxlan_create(dev);
+
 	err = mlx5_init_rl_table(dev);
 	if (err) {
 		dev_err(&pdev->dev, "Failed to init rate limiting\n");
@@ -1036,6 +1039,7 @@ err_mpfs_cleanup:
 err_rl_cleanup:
 	mlx5_cleanup_rl_table(dev);
 err_tables_cleanup:
+	mlx5_vxlan_destroy(dev->vxlan);
 	mlx5_cleanup_mkey_table(dev);
 	mlx5_cleanup_srq_table(dev);
 	mlx5_cleanup_qp_table(dev);
@@ -1056,6 +1060,7 @@ static void mlx5_cleanup_once(struct mlx5_core_dev *dev)
 	mlx5_eswitch_cleanup(dev->priv.eswitch);
 	mlx5_mpfs_cleanup(dev);
 	mlx5_cleanup_rl_table(dev);
+	mlx5_vxlan_destroy(dev->vxlan);
 	mlx5_cleanup_clock(dev);
 	mlx5_cleanup_reserved_gids(dev);
 	mlx5_cleanup_mkey_table(dev);
diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h
index 35545005ad03..01706db69863 100644
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -810,6 +810,7 @@ struct mlx5_clock {
 };
 
 struct mlx5_fw_tracer;
+struct mlx5_vxlan;
 
 struct mlx5_core_dev {
 	struct pci_dev	       *pdev;
@@ -842,6 +843,7 @@ struct mlx5_core_dev {
 	atomic_t		num_qps;
 	u32			issi;
 	struct mlx5e_resources  mlx5e_res;
+	struct mlx5_vxlan       *vxlan;
 	struct {
 		struct mlx5_rsvd_gids	reserved_gids;
 		u32			roce_en;
