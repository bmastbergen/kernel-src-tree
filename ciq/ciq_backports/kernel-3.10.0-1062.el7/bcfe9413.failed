gfs2: gfs2_extent_length cleanup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit bcfe94139a45fae128844558d6e27a0258860a90
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/bcfe9413.failed

Now that gfs2_extent_length is no longer used for determining the size
of a hole and always with an upper size limit, the function can be
simplified.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Reviewed-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit bcfe94139a45fae128844558d6e27a0258860a90)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/bmap.c
diff --cc fs/gfs2/bmap.c
index e578c30e1381,8b5876e19ecf..000000000000
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@@ -419,23 -429,143 +411,23 @@@ static inline unsigned int gfs2_extent_
  	} while(be64_to_cpu(*ptr) == d);
  	if (ptr >= end)
  		*eob = 1;
- 	return (ptr - first);
+ 	return ptr - first;
  }
  
 -typedef const __be64 *(*gfs2_metadata_walker)(
 -		struct metapath *mp,
 -		const __be64 *start, const __be64 *end,
 -		u64 factor, void *data);
 -
 -#define WALK_STOP ((__be64 *)0)
 -#define WALK_NEXT ((__be64 *)1)
 -
 -static int gfs2_walk_metadata(struct inode *inode, sector_t lblock,
 -		u64 len, struct metapath *mp, gfs2_metadata_walker walker,
 -		void *data)
 +static inline void bmap_lock(struct gfs2_inode *ip, int create)
  {
 -	struct metapath clone;
 -	struct gfs2_inode *ip = GFS2_I(inode);
 -	struct gfs2_sbd *sdp = GFS2_SB(inode);
 -	const __be64 *start, *end, *ptr;
 -	u64 factor = 1;
 -	unsigned int hgt;
 -	int ret = 0;
 -
 -	for (hgt = ip->i_height - 1; hgt >= mp->mp_aheight; hgt--)
 -		factor *= sdp->sd_inptrs;
 -
 -	for (;;) {
 -		u64 step;
 -
 -		/* Walk indirect block. */
 -		start = metapointer(hgt, mp);
 -		end = metaend(hgt, mp);
 -
 -		step = (end - start) * factor;
 -		if (step > len)
 -			end = start + DIV_ROUND_UP_ULL(len, factor);
 -
 -		ptr = walker(mp, start, end, factor, data);
 -		if (ptr == WALK_STOP)
 -			break;
 -		if (step >= len)
 -			break;
 -		len -= step;
 -		if (ptr != WALK_NEXT) {
 -			BUG_ON(!*ptr);
 -			mp->mp_list[hgt] += ptr - start;
 -			goto fill_up_metapath;
 -		}
 -
 -lower_metapath:
 -		/* Decrease height of metapath. */
 -		if (mp != &clone) {
 -			clone_metapath(&clone, mp);
 -			mp = &clone;
 -		}
 -		brelse(mp->mp_bh[hgt]);
 -		mp->mp_bh[hgt] = NULL;
 -		if (!hgt)
 -			break;
 -		hgt--;
 -		factor *= sdp->sd_inptrs;
 -
 -		/* Advance in metadata tree. */
 -		(mp->mp_list[hgt])++;
 -		start = metapointer(hgt, mp);
 -		end = metaend(hgt, mp);
 -		if (start >= end) {
 -			mp->mp_list[hgt] = 0;
 -			if (!hgt)
 -				break;
 -			goto lower_metapath;
 -		}
 -
 -fill_up_metapath:
 -		/* Increase height of metapath. */
 -		if (mp != &clone) {
 -			clone_metapath(&clone, mp);
 -			mp = &clone;
 -		}
 -		ret = fillup_metapath(ip, mp, ip->i_height - 1);
 -		if (ret < 0)
 -			break;
 -		hgt += ret;
 -		for (; ret; ret--)
 -			do_div(factor, sdp->sd_inptrs);
 -		mp->mp_aheight = hgt + 1;
 -	}
 -	if (mp == &clone)
 -		release_metapath(mp);
 -	return ret;
 +	if (create)
 +		down_write(&ip->i_rw_mutex);
 +	else
 +		down_read(&ip->i_rw_mutex);
  }
  
 -struct gfs2_hole_walker_args {
 -	u64 blocks;
 -};
 -
 -static const __be64 *gfs2_hole_walker(struct metapath *mp,
 -		const __be64 *start, const __be64 *end,
 -		u64 factor, void *data)
 +static inline void bmap_unlock(struct gfs2_inode *ip, int create)
  {
 -	struct gfs2_hole_walker_args *args = data;
 -	const __be64 *ptr;
 -
 -	for (ptr = start; ptr < end; ptr++) {
 -		if (*ptr) {
 -			args->blocks += (ptr - start) * factor;
 -			if (mp->mp_aheight == mp->mp_fheight)
 -				return WALK_STOP;
 -			return ptr;  /* increase height */
 -		}
 -	}
 -	args->blocks += (end - start) * factor;
 -	return WALK_NEXT;
 -}
 -
 -/**
 - * gfs2_hole_size - figure out the size of a hole
 - * @inode: The inode
 - * @lblock: The logical starting block number
 - * @len: How far to look (in blocks)
 - * @mp: The metapath at lblock
 - * @iomap: The iomap to store the hole size in
 - *
 - * This function modifies @mp.
 - *
 - * Returns: errno on error
 - */
 -static int gfs2_hole_size(struct inode *inode, sector_t lblock, u64 len,
 -			  struct metapath *mp, struct iomap *iomap)
 -{
 -	struct gfs2_hole_walker_args args = { };
 -	int ret = 0;
 -
 -	ret = gfs2_walk_metadata(inode, lblock, len, mp, gfs2_hole_walker, &args);
 -	if (!ret)
 -		iomap->length = args.blocks << inode->i_blkbits;
 -	return ret;
 +	if (create)
 +		up_write(&ip->i_rw_mutex);
 +	else
 +		up_read(&ip->i_rw_mutex);
  }
  
  static inline __be64 *gfs2_indirect_init(struct metapath *mp,
@@@ -757,7 -873,127 +749,131 @@@ int gfs2_iomap_begin(struct inode *inod
  	if (height > ip->i_height || gfs2_is_stuffed(ip))
  		goto do_alloc;
  
++<<<<<<< HEAD
 +	ret = lookup_metapath(ip, &mp);
++=======
+ 	ret = lookup_metapath(ip, mp);
+ 	if (ret)
+ 		goto unlock;
+ 
+ 	if (mp->mp_aheight != ip->i_height)
+ 		goto do_alloc;
+ 
+ 	ptr = metapointer(ip->i_height - 1, mp);
+ 	if (*ptr == 0)
+ 		goto do_alloc;
+ 
+ 	bh = mp->mp_bh[ip->i_height - 1];
+ 	len = gfs2_extent_length(bh, ptr, len, &eob);
+ 
+ 	iomap->addr = be64_to_cpu(*ptr) << inode->i_blkbits;
+ 	iomap->length = len << inode->i_blkbits;
+ 	iomap->type = IOMAP_MAPPED;
+ 	iomap->flags = IOMAP_F_MERGED;
+ 	if (eob)
+ 		iomap->flags |= IOMAP_F_GFS2_BOUNDARY;
+ 
+ out:
+ 	iomap->bdev = inode->i_sb->s_bdev;
+ unlock:
+ 	up_read(&ip->i_rw_mutex);
+ 	if (ret && dibh)
+ 		brelse(dibh);
+ 	return ret;
+ 
+ do_alloc:
+ 	iomap->addr = IOMAP_NULL_ADDR;
+ 	iomap->type = IOMAP_HOLE;
+ 	if (flags & IOMAP_REPORT) {
+ 		if (pos >= size)
+ 			ret = -ENOENT;
+ 		else if (height == ip->i_height)
+ 			ret = gfs2_hole_size(inode, lblock, len, mp, iomap);
+ 		else
+ 			iomap->length = size - pos;
+ 	} else if (flags & IOMAP_WRITE) {
+ 		u64 alloc_size;
+ 
+ 		len = gfs2_alloc_size(inode, mp, len);
+ 		alloc_size = len << inode->i_blkbits;
+ 		if (alloc_size < iomap->length)
+ 			iomap->length = alloc_size;
+ 	} else {
+ 		if (pos < size && height == ip->i_height)
+ 			ret = gfs2_hole_size(inode, lblock, len, mp, iomap);
+ 	}
+ 	goto out;
+ }
+ 
+ static int gfs2_write_lock(struct inode *inode)
+ {
+ 	struct gfs2_inode *ip = GFS2_I(inode);
+ 	struct gfs2_sbd *sdp = GFS2_SB(inode);
+ 	int error;
+ 
+ 	gfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &ip->i_gh);
+ 	error = gfs2_glock_nq(&ip->i_gh);
+ 	if (error)
+ 		goto out_uninit;
+ 	if (&ip->i_inode == sdp->sd_rindex) {
+ 		struct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);
+ 
+ 		error = gfs2_glock_nq_init(m_ip->i_gl, LM_ST_EXCLUSIVE,
+ 					   GL_NOCACHE, &m_ip->i_gh);
+ 		if (error)
+ 			goto out_unlock;
+ 	}
+ 	return 0;
+ 
+ out_unlock:
+ 	gfs2_glock_dq(&ip->i_gh);
+ out_uninit:
+ 	gfs2_holder_uninit(&ip->i_gh);
+ 	return error;
+ }
+ 
+ static void gfs2_write_unlock(struct inode *inode)
+ {
+ 	struct gfs2_inode *ip = GFS2_I(inode);
+ 	struct gfs2_sbd *sdp = GFS2_SB(inode);
+ 
+ 	if (&ip->i_inode == sdp->sd_rindex) {
+ 		struct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);
+ 
+ 		gfs2_glock_dq_uninit(&m_ip->i_gh);
+ 	}
+ 	gfs2_glock_dq_uninit(&ip->i_gh);
+ }
+ 
+ static void gfs2_iomap_journaled_page_done(struct inode *inode, loff_t pos,
+ 				unsigned copied, struct page *page,
+ 				struct iomap *iomap)
+ {
+ 	struct gfs2_inode *ip = GFS2_I(inode);
+ 
+ 	gfs2_page_add_databufs(ip, page, offset_in_page(pos), copied);
+ }
+ 
+ static int gfs2_iomap_begin_write(struct inode *inode, loff_t pos,
+ 				  loff_t length, unsigned flags,
+ 				  struct iomap *iomap)
+ {
+ 	struct metapath mp = { .mp_aheight = 1, };
+ 	struct gfs2_inode *ip = GFS2_I(inode);
+ 	struct gfs2_sbd *sdp = GFS2_SB(inode);
+ 	unsigned int data_blocks = 0, ind_blocks = 0, rblocks;
+ 	bool unstuff, alloc_required;
+ 	int ret;
+ 
+ 	ret = gfs2_write_lock(inode);
+ 	if (ret)
+ 		return ret;
+ 
+ 	unstuff = gfs2_is_stuffed(ip) &&
+ 		  pos + length > gfs2_max_stuffed_size(ip);
+ 
+ 	ret = gfs2_iomap_get(inode, pos, length, flags, iomap, &mp);
++>>>>>>> bcfe94139a45 (gfs2: gfs2_extent_length cleanup)
  	if (ret)
  		goto out_release;
  
* Unmerged path fs/gfs2/bmap.c
