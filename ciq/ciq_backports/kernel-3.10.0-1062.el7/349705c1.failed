IB/mlx5: Add modify_flow_action_esp verb

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Matan Barak <matanb@mellanox.com>
commit 349705c1936269aa6e5f923a0bc663e1addf288e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/349705c1.failed

Adding implementation in mlx5 driver to modify action_xfrm object. This
merely call the accel layer. Currently a user can modify only the
ESN parameters.

	Reviewed-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Matan Barak <matanb@mellanox.com>
	Signed-off-by: Aviad Yehezkel <aviadye@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 349705c1936269aa6e5f923a0bc663e1addf288e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
diff --cc drivers/infiniband/hw/mlx5/main.c
index 7128889d8a7d,bc46589a904d..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -3073,6 -3106,170 +3073,173 @@@ unlock
  	return ERR_PTR(err);
  }
  
++<<<<<<< HEAD
++=======
+ static u32 mlx5_ib_flow_action_flags_to_accel_xfrm_flags(u32 mlx5_flags)
+ {
+ 	u32 flags = 0;
+ 
+ 	if (mlx5_flags & MLX5_IB_UAPI_FLOW_ACTION_FLAGS_REQUIRE_METADATA)
+ 		flags |= MLX5_ACCEL_XFRM_FLAG_REQUIRE_METADATA;
+ 
+ 	return flags;
+ }
+ 
+ #define MLX5_FLOW_ACTION_ESP_CREATE_LAST_SUPPORTED	MLX5_IB_UAPI_FLOW_ACTION_FLAGS_REQUIRE_METADATA
+ static struct ib_flow_action *
+ mlx5_ib_create_flow_action_esp(struct ib_device *device,
+ 			       const struct ib_flow_action_attrs_esp *attr,
+ 			       struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_ib_dev *mdev = to_mdev(device);
+ 	struct ib_uverbs_flow_action_esp_keymat_aes_gcm *aes_gcm;
+ 	struct mlx5_accel_esp_xfrm_attrs accel_attrs = {};
+ 	struct mlx5_ib_flow_action *action;
+ 	u64 action_flags;
+ 	u64 flags;
+ 	int err = 0;
+ 
+ 	if (IS_UVERBS_COPY_ERR(uverbs_copy_from(&action_flags, attrs,
+ 						MLX5_IB_ATTR_CREATE_FLOW_ACTION_FLAGS)))
+ 		return ERR_PTR(-EFAULT);
+ 
+ 	if (action_flags >= (MLX5_FLOW_ACTION_ESP_CREATE_LAST_SUPPORTED << 1))
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 
+ 	flags = mlx5_ib_flow_action_flags_to_accel_xfrm_flags(action_flags);
+ 
+ 	/* We current only support a subset of the standard features. Only a
+ 	 * keymat of type AES_GCM, with icv_len == 16, iv_algo == SEQ and esn
+ 	 * (with overlap). Full offload mode isn't supported.
+ 	 */
+ 	if (!attr->keymat || attr->replay || attr->encap ||
+ 	    attr->spi || attr->seq || attr->tfc_pad ||
+ 	    attr->hard_limit_pkts ||
+ 	    (attr->flags & ~(IB_FLOW_ACTION_ESP_FLAGS_ESN_TRIGGERED |
+ 			     IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ENCRYPT)))
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 
+ 	if (attr->keymat->protocol !=
+ 	    IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM)
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 
+ 	aes_gcm = &attr->keymat->keymat.aes_gcm;
+ 
+ 	if (aes_gcm->icv_len != 16 ||
+ 	    aes_gcm->iv_algo != IB_UVERBS_FLOW_ACTION_IV_ALGO_SEQ)
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 
+ 	action = kmalloc(sizeof(*action), GFP_KERNEL);
+ 	if (!action)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	action->esp_aes_gcm.ib_flags = attr->flags;
+ 	memcpy(&accel_attrs.keymat.aes_gcm.aes_key, &aes_gcm->aes_key,
+ 	       sizeof(accel_attrs.keymat.aes_gcm.aes_key));
+ 	accel_attrs.keymat.aes_gcm.key_len = aes_gcm->key_len * 8;
+ 	memcpy(&accel_attrs.keymat.aes_gcm.salt, &aes_gcm->salt,
+ 	       sizeof(accel_attrs.keymat.aes_gcm.salt));
+ 	memcpy(&accel_attrs.keymat.aes_gcm.seq_iv, &aes_gcm->iv,
+ 	       sizeof(accel_attrs.keymat.aes_gcm.seq_iv));
+ 	accel_attrs.keymat.aes_gcm.icv_len = aes_gcm->icv_len * 8;
+ 	accel_attrs.keymat.aes_gcm.iv_algo = MLX5_ACCEL_ESP_AES_GCM_IV_ALGO_SEQ;
+ 	accel_attrs.keymat_type = MLX5_ACCEL_ESP_KEYMAT_AES_GCM;
+ 
+ 	accel_attrs.esn = attr->esn;
+ 	if (attr->flags & IB_FLOW_ACTION_ESP_FLAGS_ESN_TRIGGERED)
+ 		accel_attrs.flags |= MLX5_ACCEL_ESP_FLAGS_ESN_TRIGGERED;
+ 	if (attr->flags & IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ESN_NEW_WINDOW)
+ 		accel_attrs.flags |= MLX5_ACCEL_ESP_FLAGS_ESN_STATE_OVERLAP;
+ 
+ 	if (attr->flags & IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ENCRYPT)
+ 		accel_attrs.action |= MLX5_ACCEL_ESP_ACTION_ENCRYPT;
+ 
+ 	action->esp_aes_gcm.ctx =
+ 		mlx5_accel_esp_create_xfrm(mdev->mdev, &accel_attrs, flags);
+ 	if (IS_ERR(action->esp_aes_gcm.ctx)) {
+ 		err = PTR_ERR(action->esp_aes_gcm.ctx);
+ 		goto err_parse;
+ 	}
+ 
+ 	action->esp_aes_gcm.ib_flags = attr->flags;
+ 
+ 	return &action->ib_action;
+ 
+ err_parse:
+ 	kfree(action);
+ 	return ERR_PTR(err);
+ }
+ 
+ static int
+ mlx5_ib_modify_flow_action_esp(struct ib_flow_action *action,
+ 			       const struct ib_flow_action_attrs_esp *attr,
+ 			       struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_ib_flow_action *maction = to_mflow_act(action);
+ 	struct mlx5_accel_esp_xfrm_attrs accel_attrs;
+ 	int err = 0;
+ 
+ 	if (attr->keymat || attr->replay || attr->encap ||
+ 	    attr->spi || attr->seq || attr->tfc_pad ||
+ 	    attr->hard_limit_pkts ||
+ 	    (attr->flags & ~(IB_FLOW_ACTION_ESP_FLAGS_ESN_TRIGGERED |
+ 			     IB_FLOW_ACTION_ESP_FLAGS_MOD_ESP_ATTRS |
+ 			     IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ESN_NEW_WINDOW)))
+ 		return -EOPNOTSUPP;
+ 
+ 	/* Only the ESN value or the MLX5_ACCEL_ESP_FLAGS_ESN_STATE_OVERLAP can
+ 	 * be modified.
+ 	 */
+ 	if (!(maction->esp_aes_gcm.ib_flags &
+ 	      IB_FLOW_ACTION_ESP_FLAGS_ESN_TRIGGERED) &&
+ 	    attr->flags & (IB_FLOW_ACTION_ESP_FLAGS_ESN_TRIGGERED |
+ 			   IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ESN_NEW_WINDOW))
+ 		return -EINVAL;
+ 
+ 	memcpy(&accel_attrs, &maction->esp_aes_gcm.ctx->attrs,
+ 	       sizeof(accel_attrs));
+ 
+ 	accel_attrs.esn = attr->esn;
+ 	if (attr->flags & IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ESN_NEW_WINDOW)
+ 		accel_attrs.flags |= MLX5_ACCEL_ESP_FLAGS_ESN_STATE_OVERLAP;
+ 	else
+ 		accel_attrs.flags &= ~MLX5_ACCEL_ESP_FLAGS_ESN_STATE_OVERLAP;
+ 
+ 	err = mlx5_accel_esp_modify_xfrm(maction->esp_aes_gcm.ctx,
+ 					 &accel_attrs);
+ 	if (err)
+ 		return err;
+ 
+ 	maction->esp_aes_gcm.ib_flags &=
+ 		~IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ESN_NEW_WINDOW;
+ 	maction->esp_aes_gcm.ib_flags |=
+ 		attr->flags & IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ESN_NEW_WINDOW;
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5_ib_destroy_flow_action(struct ib_flow_action *action)
+ {
+ 	struct mlx5_ib_flow_action *maction = to_mflow_act(action);
+ 
+ 	switch (action->type) {
+ 	case IB_FLOW_ACTION_ESP:
+ 		/*
+ 		 * We only support aes_gcm by now, so we implicitly know this is
+ 		 * the underline crypto.
+ 		 */
+ 		mlx5_accel_esp_destroy_xfrm(maction->esp_aes_gcm.ctx);
+ 		break;
+ 	default:
+ 		WARN_ON(true);
+ 		break;
+ 	}
+ 
+ 	kfree(maction);
+ 	return 0;
+ }
+ 
++>>>>>>> 349705c19362 (IB/mlx5: Add modify_flow_action_esp verb)
  static int mlx5_ib_mcg_attach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)
  {
  	struct mlx5_ib_dev *dev = to_mdev(ibqp->device);
@@@ -4726,6 -4973,10 +4893,13 @@@ static int mlx5_ib_stage_caps_init(stru
  	dev->ib_dev.uverbs_ex_cmd_mask |=
  			(1ull << IB_USER_VERBS_EX_CMD_CREATE_FLOW) |
  			(1ull << IB_USER_VERBS_EX_CMD_DESTROY_FLOW);
++<<<<<<< HEAD
++=======
+ 	dev->ib_dev.create_flow_action_esp = mlx5_ib_create_flow_action_esp;
+ 	dev->ib_dev.destroy_flow_action = mlx5_ib_destroy_flow_action;
+ 	dev->ib_dev.modify_flow_action_esp = mlx5_ib_modify_flow_action_esp;
+ 	dev->ib_dev.driver_id = RDMA_DRIVER_MLX5;
++>>>>>>> 349705c19362 (IB/mlx5: Add modify_flow_action_esp verb)
  
  	err = init_node_data(dev);
  	if (err)
* Unmerged path drivers/infiniband/hw/mlx5/main.c
