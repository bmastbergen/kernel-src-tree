net: ipv4: update fnhe_pmtu when first hop's MTU changes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [net] ipv4: update fnhe_pmtu when first hop's MTU changes (Sabrina Dubroca) [1601814]
Rebuild_FUZZ: 95.33%
commit-author Sabrina Dubroca <sd@queasysnail.net>
commit af7d6cce53694a88d6a1bb60c9a239a6a5144459
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/af7d6cce.failed

Since commit 5aad1de5ea2c ("ipv4: use separate genid for next hop
exceptions"), exceptions get deprecated separately from cached
routes. In particular, administrative changes don't clear PMTU anymore.

As Stefano described in commit e9fa1495d738 ("ipv6: Reflect MTU changes
on PMTU of exceptions for MTU-less routes"), the PMTU discovered before
the local MTU change can become stale:
 - if the local MTU is now lower than the PMTU, that PMTU is now
   incorrect
 - if the local MTU was the lowest value in the path, and is increased,
   we might discover a higher PMTU

Similarly to what commit e9fa1495d738 did for IPv6, update PMTU in those
cases.

If the exception was locked, the discovered PMTU was smaller than the
minimal accepted PMTU. In that case, if the new local MTU is smaller
than the current PMTU, let PMTU discovery figure out if locking of the
exception is still needed.

To do this, we need to know the old link MTU in the NETDEV_CHANGEMTU
notifier. By the time the notifier is called, dev->mtu has been
changed. This patch adds the old MTU as additional information in the
notifier structure, and a new call_netdevice_notifiers_u32() function.

Fixes: 5aad1de5ea2c ("ipv4: use separate genid for next hop exceptions")
	Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
	Reviewed-by: Stefano Brivio <sbrivio@redhat.com>
	Reviewed-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit af7d6cce53694a88d6a1bb60c9a239a6a5144459)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip_fib.h
#	net/ipv4/fib_frontend.c
#	net/ipv4/fib_semantics.c
diff --cc include/net/ip_fib.h
index 63be6ff0b83e,c9b7b136939d..000000000000
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@@ -382,13 -391,14 +382,20 @@@ int fib_unmerge(struct net *net)
  
  /* Exported by fib_semantics.c */
  int ip_fib_check_default(__be32 gw, struct net_device *dev);
++<<<<<<< HEAD
 +int fib_sync_down_dev(struct net_device *dev, int force);
 +int fib_sync_down_addr(struct net *net, __be32 local);
 +int fib_sync_up(struct net_device *dev);
++=======
+ int fib_sync_down_dev(struct net_device *dev, unsigned long event, bool force);
+ int fib_sync_down_addr(struct net_device *dev, __be32 local);
+ int fib_sync_up(struct net_device *dev, unsigned int nh_flags);
+ void fib_sync_mtu(struct net_device *dev, u32 orig_mtu);
++>>>>>>> af7d6cce5369 (net: ipv4: update fnhe_pmtu when first hop's MTU changes)
  
  #ifdef CONFIG_IP_ROUTE_MULTIPATH
 -int fib_multipath_hash(const struct net *net, const struct flowi4 *fl4,
 -		       const struct sk_buff *skb, struct flow_keys *flkeys);
 +int fib_multipath_hash(const struct fib_info *fi, const struct flowi4 *fl4,
 +		       const struct sk_buff *skb);
  #endif
  void fib_select_multipath(struct fib_result *res, int hash);
  void fib_select_path(struct net *net, struct fib_result *res,
diff --cc net/ipv4/fib_frontend.c
index 9ca53ed464e7,0113993e9b2c..000000000000
--- a/net/ipv4/fib_frontend.c
+++ b/net/ipv4/fib_frontend.c
@@@ -1123,11 -1243,14 +1123,16 @@@ static int fib_inetaddr_event(struct no
  static int fib_netdev_event(struct notifier_block *this, unsigned long event, void *ptr)
  {
  	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
++<<<<<<< HEAD
++=======
+ 	struct netdev_notifier_changeupper_info *upper_info = ptr;
+ 	struct netdev_notifier_info_ext *info_ext = ptr;
++>>>>>>> af7d6cce5369 (net: ipv4: update fnhe_pmtu when first hop's MTU changes)
  	struct in_device *in_dev;
  	struct net *net = dev_net(dev);
 -	unsigned int flags;
  
  	if (event == NETDEV_UNREGISTER) {
 -		fib_disable_ip(dev, event, true);
 +		fib_disable_ip(dev, 2);
  		rt_flush_dev(dev);
  		return NOTIFY_DONE;
  	}
@@@ -1148,12 -1271,29 +1153,36 @@@
  		rt_cache_flush(net);
  		break;
  	case NETDEV_DOWN:
 -		fib_disable_ip(dev, event, false);
 +		fib_disable_ip(dev, 0);
 +		break;
++<<<<<<< HEAD
 +	case NETDEV_CHANGEMTU:
 +	case NETDEV_CHANGE:
 +		rt_cache_flush(net);
  		break;
++=======
+ 	case NETDEV_CHANGE:
+ 		flags = dev_get_flags(dev);
+ 		if (flags & (IFF_RUNNING | IFF_LOWER_UP))
+ 			fib_sync_up(dev, RTNH_F_LINKDOWN);
+ 		else
+ 			fib_sync_down_dev(dev, event, false);
+ 		rt_cache_flush(net);
+ 		break;
+ 	case NETDEV_CHANGEMTU:
+ 		fib_sync_mtu(dev, info_ext->ext.mtu);
+ 		rt_cache_flush(net);
+ 		break;
+ 	case NETDEV_CHANGEUPPER:
+ 		upper_info = ptr;
+ 		/* flush all routes if dev is linked to or unlinked from
+ 		 * an L3 master device (e.g., VRF)
+ 		 */
+ 		if (upper_info->upper_dev &&
+ 		    netif_is_l3_master(upper_info->upper_dev))
+ 			fib_disable_ip(dev, NETDEV_DOWN, true);
+ 		break;
++>>>>>>> af7d6cce5369 (net: ipv4: update fnhe_pmtu when first hop's MTU changes)
  	}
  	return NOTIFY_DONE;
  }
diff --cc net/ipv4/fib_semantics.c
index b3ccf81b8829,446204ca7406..000000000000
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@@ -1361,7 -1470,63 +1361,67 @@@ static int call_fib_nh_notifiers(struc
  	return NOTIFY_DONE;
  }
  
++<<<<<<< HEAD
 +int fib_sync_down_dev(struct net_device *dev, int force)
++=======
+ /* Update the PMTU of exceptions when:
+  * - the new MTU of the first hop becomes smaller than the PMTU
+  * - the old MTU was the same as the PMTU, and it limited discovery of
+  *   larger MTUs on the path. With that limit raised, we can now
+  *   discover larger MTUs
+  * A special case is locked exceptions, for which the PMTU is smaller
+  * than the minimal accepted PMTU:
+  * - if the new MTU is greater than the PMTU, don't make any change
+  * - otherwise, unlock and set PMTU
+  */
+ static void nh_update_mtu(struct fib_nh *nh, u32 new, u32 orig)
+ {
+ 	struct fnhe_hash_bucket *bucket;
+ 	int i;
+ 
+ 	bucket = rcu_dereference_protected(nh->nh_exceptions, 1);
+ 	if (!bucket)
+ 		return;
+ 
+ 	for (i = 0; i < FNHE_HASH_SIZE; i++) {
+ 		struct fib_nh_exception *fnhe;
+ 
+ 		for (fnhe = rcu_dereference_protected(bucket[i].chain, 1);
+ 		     fnhe;
+ 		     fnhe = rcu_dereference_protected(fnhe->fnhe_next, 1)) {
+ 			if (fnhe->fnhe_mtu_locked) {
+ 				if (new <= fnhe->fnhe_pmtu) {
+ 					fnhe->fnhe_pmtu = new;
+ 					fnhe->fnhe_mtu_locked = false;
+ 				}
+ 			} else if (new < fnhe->fnhe_pmtu ||
+ 				   orig == fnhe->fnhe_pmtu) {
+ 				fnhe->fnhe_pmtu = new;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ void fib_sync_mtu(struct net_device *dev, u32 orig_mtu)
+ {
+ 	unsigned int hash = fib_devindex_hashfn(dev->ifindex);
+ 	struct hlist_head *head = &fib_info_devhash[hash];
+ 	struct fib_nh *nh;
+ 
+ 	hlist_for_each_entry(nh, head, nh_hash) {
+ 		if (nh->nh_dev == dev)
+ 			nh_update_mtu(nh, dev->mtu, orig_mtu);
+ 	}
+ }
+ 
+ /* Event              force Flags           Description
+  * NETDEV_CHANGE      0     LINKDOWN        Carrier OFF, not for scope host
+  * NETDEV_DOWN        0     LINKDOWN|DEAD   Link down, not for scope host
+  * NETDEV_DOWN        1     LINKDOWN|DEAD   Last address removed
+  * NETDEV_UNREGISTER  1     LINKDOWN|DEAD   Device removed
+  */
+ int fib_sync_down_dev(struct net_device *dev, unsigned long event, bool force)
++>>>>>>> af7d6cce5369 (net: ipv4: update fnhe_pmtu when first hop's MTU changes)
  {
  	int ret = 0;
  	int scope = RT_SCOPE_NOWHERE;
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 1ef721c71fda..bdb313a92fc2 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -2481,6 +2481,13 @@ struct netdev_notifier_info {
 	struct net_device *dev;
 };
 
+struct netdev_notifier_info_ext {
+	struct netdev_notifier_info info; /* must be first */
+	union {
+		u32 mtu;
+	} ext;
+};
+
 struct netdev_notifier_change_info {
 	struct netdev_notifier_info info; /* must be first */
 	unsigned int flags_changed;
* Unmerged path include/net/ip_fib.h
diff --git a/net/core/dev.c b/net/core/dev.c
index fbbfd27c6efe..5e63d4512dd7 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -1777,6 +1777,28 @@ int call_netdevice_notifiers(unsigned long val, struct net_device *dev)
 }
 EXPORT_SYMBOL(call_netdevice_notifiers);
 
+/**
+ *	call_netdevice_notifiers_mtu - call all network notifier blocks
+ *	@val: value passed unmodified to notifier function
+ *	@dev: net_device pointer passed unmodified to notifier function
+ *	@arg: additional u32 argument passed to the notifier function
+ *
+ *	Call all network notifier blocks.  Parameters and return value
+ *	are as for raw_notifier_call_chain().
+ */
+static int call_netdevice_notifiers_mtu(unsigned long val,
+					struct net_device *dev, u32 arg)
+{
+	struct netdev_notifier_info_ext info = {
+		.info.dev = dev,
+		.ext.mtu = arg,
+	};
+
+	BUILD_BUG_ON(offsetof(struct netdev_notifier_info_ext, info) != 0);
+
+	return call_netdevice_notifiers_info(val, &info.info);
+}
+
 #ifdef CONFIG_NET_INGRESS
 static struct static_key ingress_needed __read_mostly;
 
@@ -6933,14 +6955,16 @@ skip_check:
 	err = __dev_set_mtu(dev, new_mtu);
 
 	if (!err) {
-		err = call_netdevice_notifiers(NETDEV_CHANGEMTU, dev);
+		err = call_netdevice_notifiers_mtu(NETDEV_CHANGEMTU, dev,
+						   orig_mtu);
 		err = notifier_to_errno(err);
 		if (err) {
 			/* setting mtu back and notifying everyone again,
 			 * so that they have a chance to revert changes.
 			 */
 			__dev_set_mtu(dev, orig_mtu);
-			call_netdevice_notifiers(NETDEV_CHANGEMTU, dev);
+			call_netdevice_notifiers_mtu(NETDEV_CHANGEMTU, dev,
+						     new_mtu);
 		}
 	}
 	return err;
* Unmerged path net/ipv4/fib_frontend.c
* Unmerged path net/ipv4/fib_semantics.c
