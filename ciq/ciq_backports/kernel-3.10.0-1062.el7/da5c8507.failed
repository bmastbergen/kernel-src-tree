RDMA/nldev: add driver-specific resource tracking

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Steve Wise <swise@opengridcomputing.com>
commit da5c8507821573b8ed6e3f47e009f273493ffaf7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/da5c8507.failed

Each driver can register a "fill entry" function with the restrack core.
This function will be called when filling out a resource, allowing the
driver to add driver-specific details.  The details consist of a
nltable of nested attributes, that are in the form of <key, [print-type],
value> tuples.  Both key and value attributes are mandatory.  The key
nlattr must be a string, and the value nlattr can be one of the driver
attributes that are generic, but typed, allowing the attributes to be
validated.  Currently the driver nlattr types include string, s32,
u32, s64, and u64.  The print-type nlattr allows a driver to specify
an alternative display format for user tools displaying the attribute.
For example, a u32 attribute will default to "%u", but a print-type
attribute can be included for it to be displayed in hex.  This allows
the user tool to print the number in the format desired by the driver
driver.

More attrs can be defined as they become needed by drivers.

	Signed-off-by: Steve Wise <swise@opengridcomputing.com>
	Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit da5c8507821573b8ed6e3f47e009f273493ffaf7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/nldev.c
#	drivers/infiniband/core/restrack.c
#	include/uapi/rdma/rdma_netlink.h
diff --cc drivers/infiniband/core/nldev.c
index 67368b6847cb,50efca482a6c..000000000000
--- a/drivers/infiniband/core/nldev.c
+++ b/drivers/infiniband/core/nldev.c
@@@ -71,6 -73,40 +71,43 @@@ static const struct nla_policy nldev_po
  	[RDMA_NLDEV_ATTR_RES_PID]		= { .type = NLA_U32 },
  	[RDMA_NLDEV_ATTR_RES_KERN_NAME]		= { .type = NLA_NUL_STRING,
  						    .len = TASK_COMM_LEN },
++<<<<<<< HEAD
++=======
+ 	[RDMA_NLDEV_ATTR_RES_CM_ID]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_CM_ID_ENTRY]	= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_PS]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_SRC_ADDR]	= {
+ 			.len = sizeof(struct __kernel_sockaddr_storage) },
+ 	[RDMA_NLDEV_ATTR_RES_DST_ADDR]	= {
+ 			.len = sizeof(struct __kernel_sockaddr_storage) },
+ 	[RDMA_NLDEV_ATTR_RES_CQ]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_CQ_ENTRY]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_CQE]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_USECNT]		= { .type = NLA_U64 },
+ 	[RDMA_NLDEV_ATTR_RES_POLL_CTX]		= { .type = NLA_U8 },
+ 	[RDMA_NLDEV_ATTR_RES_MR]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_MR_ENTRY]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_RKEY]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_LKEY]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_IOVA]		= { .type = NLA_U64 },
+ 	[RDMA_NLDEV_ATTR_RES_MRLEN]		= { .type = NLA_U64 },
+ 	[RDMA_NLDEV_ATTR_RES_PD]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_PD_ENTRY]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_LOCAL_DMA_LKEY]	= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_UNSAFE_GLOBAL_RKEY] = { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_NDEV_INDEX]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_NDEV_NAME]		= { .type = NLA_NUL_STRING,
+ 						    .len = IFNAMSIZ },
+ 	[RDMA_NLDEV_ATTR_DRIVER]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_DRIVER_ENTRY]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_DRIVER_STRING]		= { .type = NLA_NUL_STRING,
+ 				    .len = RDMA_NLDEV_ATTR_ENTRY_STRLEN },
+ 	[RDMA_NLDEV_ATTR_DRIVER_PRINT_TYPE]	= { .type = NLA_U8 },
+ 	[RDMA_NLDEV_ATTR_DRIVER_S32]		= { .type = NLA_S32 },
+ 	[RDMA_NLDEV_ATTR_DRIVER_U32]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_DRIVER_S64]		= { .type = NLA_S64 },
+ 	[RDMA_NLDEV_ATTR_DRIVER_U64]		= { .type = NLA_U64 },
++>>>>>>> da5c85078215 (RDMA/nldev: add driver-specific resource tracking)
  };
  
  static int fill_nldev_handle(struct sk_buff *msg, struct ib_device *device)
@@@ -262,19 -341,72 +300,86 @@@ static int fill_res_qp_entry(struct sk_
  	if (nla_put_u8(msg, RDMA_NLDEV_ATTR_RES_STATE, qp_attr.qp_state))
  		goto err;
  
++<<<<<<< HEAD
 +	/*
 +	 * Existence of task means that it is user QP and netlink
 +	 * user is invited to go and read /proc/PID/comm to get name
 +	 * of the task file and res->task_com should be NULL.
 +	 */
 +	if (rdma_is_kernel_res(res)) {
 +		if (nla_put_string(msg, RDMA_NLDEV_ATTR_RES_KERN_NAME, res->kern_name))
++=======
+ 	if (fill_res_name_pid(msg, res))
+ 		goto err;
+ 
+ 	if (resroot->fill_res_entry(msg, res))
+ 		goto err;
+ 
+ 	nla_nest_end(msg, entry_attr);
+ 	return 0;
+ 
+ err:
+ 	nla_nest_cancel(msg, entry_attr);
+ out:
+ 	return -EMSGSIZE;
+ }
+ 
+ static int fill_res_cm_id_entry(struct sk_buff *msg,
+ 				struct netlink_callback *cb,
+ 				struct rdma_restrack_entry *res, uint32_t port)
+ {
+ 	struct rdma_id_private *id_priv =
+ 				container_of(res, struct rdma_id_private, res);
+ 	struct rdma_restrack_root *resroot = &id_priv->id.device->res;
+ 	struct rdma_cm_id *cm_id = &id_priv->id;
+ 	struct nlattr *entry_attr;
+ 
+ 	if (port && port != cm_id->port_num)
+ 		return 0;
+ 
+ 	entry_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_RES_CM_ID_ENTRY);
+ 	if (!entry_attr)
+ 		goto out;
+ 
+ 	if (cm_id->port_num &&
+ 	    nla_put_u32(msg, RDMA_NLDEV_ATTR_PORT_INDEX, cm_id->port_num))
+ 		goto err;
+ 
+ 	if (id_priv->qp_num) {
+ 		if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_LQPN, id_priv->qp_num))
++>>>>>>> da5c85078215 (RDMA/nldev: add driver-specific resource tracking)
  			goto err;
 -		if (nla_put_u8(msg, RDMA_NLDEV_ATTR_RES_TYPE, cm_id->qp_type))
 +	} else {
 +		if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_PID, task_pid_vnr(res->task)))
  			goto err;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_PS, cm_id->ps))
+ 		goto err;
+ 
+ 	if (nla_put_u8(msg, RDMA_NLDEV_ATTR_RES_STATE, id_priv->state))
+ 		goto err;
+ 
+ 	if (cm_id->route.addr.src_addr.ss_family &&
+ 	    nla_put(msg, RDMA_NLDEV_ATTR_RES_SRC_ADDR,
+ 		    sizeof(cm_id->route.addr.src_addr),
+ 		    &cm_id->route.addr.src_addr))
+ 		goto err;
+ 	if (cm_id->route.addr.dst_addr.ss_family &&
+ 	    nla_put(msg, RDMA_NLDEV_ATTR_RES_DST_ADDR,
+ 		    sizeof(cm_id->route.addr.dst_addr),
+ 		    &cm_id->route.addr.dst_addr))
+ 		goto err;
+ 
+ 	if (fill_res_name_pid(msg, res))
+ 		goto err;
+ 
+ 	if (resroot->fill_res_entry(msg, res))
+ 		goto err;
+ 
++>>>>>>> da5c85078215 (RDMA/nldev: add driver-specific resource tracking)
  	nla_nest_end(msg, entry_attr);
  	return 0;
  
@@@ -284,7 -416,128 +389,132 @@@ out
  	return -EMSGSIZE;
  }
  
++<<<<<<< HEAD
 +static int nldev_get_doit(struct sk_buff *skb, struct nlmsghdr *nlh)
++=======
+ static int fill_res_cq_entry(struct sk_buff *msg, struct netlink_callback *cb,
+ 			     struct rdma_restrack_entry *res, uint32_t port)
+ {
+ 	struct ib_cq *cq = container_of(res, struct ib_cq, res);
+ 	struct rdma_restrack_root *resroot = &cq->device->res;
+ 	struct nlattr *entry_attr;
+ 
+ 	entry_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_RES_CQ_ENTRY);
+ 	if (!entry_attr)
+ 		goto out;
+ 
+ 	if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_CQE, cq->cqe))
+ 		goto err;
+ 	if (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_RES_USECNT,
+ 			      atomic_read(&cq->usecnt), RDMA_NLDEV_ATTR_PAD))
+ 		goto err;
+ 
+ 	/* Poll context is only valid for kernel CQs */
+ 	if (rdma_is_kernel_res(res) &&
+ 	    nla_put_u8(msg, RDMA_NLDEV_ATTR_RES_POLL_CTX, cq->poll_ctx))
+ 		goto err;
+ 
+ 	if (fill_res_name_pid(msg, res))
+ 		goto err;
+ 
+ 	if (resroot->fill_res_entry(msg, res))
+ 		goto err;
+ 
+ 	nla_nest_end(msg, entry_attr);
+ 	return 0;
+ 
+ err:
+ 	nla_nest_cancel(msg, entry_attr);
+ out:
+ 	return -EMSGSIZE;
+ }
+ 
+ static int fill_res_mr_entry(struct sk_buff *msg, struct netlink_callback *cb,
+ 			     struct rdma_restrack_entry *res, uint32_t port)
+ {
+ 	struct ib_mr *mr = container_of(res, struct ib_mr, res);
+ 	struct rdma_restrack_root *resroot = &mr->pd->device->res;
+ 	struct nlattr *entry_attr;
+ 
+ 	entry_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_RES_MR_ENTRY);
+ 	if (!entry_attr)
+ 		goto out;
+ 
+ 	if (netlink_capable(cb->skb, CAP_NET_ADMIN)) {
+ 		if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_RKEY, mr->rkey))
+ 			goto err;
+ 		if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_LKEY, mr->lkey))
+ 			goto err;
+ 		if (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_RES_IOVA,
+ 				      mr->iova, RDMA_NLDEV_ATTR_PAD))
+ 			goto err;
+ 	}
+ 
+ 	if (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_RES_MRLEN, mr->length,
+ 			      RDMA_NLDEV_ATTR_PAD))
+ 		goto err;
+ 
+ 	if (fill_res_name_pid(msg, res))
+ 		goto err;
+ 
+ 	if (resroot->fill_res_entry(msg, res))
+ 		goto err;
+ 
+ 	nla_nest_end(msg, entry_attr);
+ 	return 0;
+ 
+ err:
+ 	nla_nest_cancel(msg, entry_attr);
+ out:
+ 	return -EMSGSIZE;
+ }
+ 
+ static int fill_res_pd_entry(struct sk_buff *msg, struct netlink_callback *cb,
+ 			     struct rdma_restrack_entry *res, uint32_t port)
+ {
+ 	struct ib_pd *pd = container_of(res, struct ib_pd, res);
+ 	struct rdma_restrack_root *resroot = &pd->device->res;
+ 	struct nlattr *entry_attr;
+ 
+ 	entry_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_RES_PD_ENTRY);
+ 	if (!entry_attr)
+ 		goto out;
+ 
+ 	if (netlink_capable(cb->skb, CAP_NET_ADMIN)) {
+ 		if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_LOCAL_DMA_LKEY,
+ 				pd->local_dma_lkey))
+ 			goto err;
+ 		if ((pd->flags & IB_PD_UNSAFE_GLOBAL_RKEY) &&
+ 		    nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_UNSAFE_GLOBAL_RKEY,
+ 				pd->unsafe_global_rkey))
+ 			goto err;
+ 	}
+ 	if (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_RES_USECNT,
+ 			      atomic_read(&pd->usecnt), RDMA_NLDEV_ATTR_PAD))
+ 		goto err;
+ 	if ((pd->flags & IB_PD_UNSAFE_GLOBAL_RKEY) &&
+ 	    nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_UNSAFE_GLOBAL_RKEY,
+ 			pd->unsafe_global_rkey))
+ 		goto err;
+ 
+ 	if (fill_res_name_pid(msg, res))
+ 		goto err;
+ 
+ 	if (resroot->fill_res_entry(msg, res))
+ 		goto err;
+ 
+ 	nla_nest_end(msg, entry_attr);
+ 	return 0;
+ 
+ err:
+ 	nla_nest_cancel(msg, entry_attr);
+ out:
+ 	return -EMSGSIZE;
+ }
+ 
+ static int nldev_get_doit(struct sk_buff *skb, struct nlmsghdr *nlh,
+ 			  struct netlink_ext_ack *extack)
++>>>>>>> da5c85078215 (RDMA/nldev: add driver-specific resource tracking)
  {
  	struct nlattr *tb[RDMA_NLDEV_ATTR_MAX];
  	struct ib_device *device;
diff --cc drivers/infiniband/core/restrack.c
index d1a74d8e20d6,172b517dc7b9..000000000000
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@@ -6,9 -6,18 +6,20 @@@
  #include <rdma/ib_verbs.h>
  #include <rdma/restrack.h>
  #include <linux/mutex.h>
 -#include <linux/sched/task.h>
 +#include <linux/sched.h>
  #include <linux/pid_namespace.h>
  
++<<<<<<< HEAD
++=======
+ #include "cma_priv.h"
+ 
+ static int fill_res_noop(struct sk_buff *msg,
+ 			 struct rdma_restrack_entry *entry)
+ {
+ 	return 0;
+ }
+ 
++>>>>>>> da5c85078215 (RDMA/nldev: add driver-specific resource tracking)
  void rdma_restrack_init(struct rdma_restrack_root *res)
  {
  	init_rwsem(&res->rwsem);
diff --cc include/uapi/rdma/rdma_netlink.h
index b90c8cd4c303,07ff6c72fc50..000000000000
--- a/include/uapi/rdma/rdma_netlink.h
+++ b/include/uapi/rdma/rdma_netlink.h
@@@ -349,6 -370,63 +358,66 @@@ enum rdma_nldev_attr 
  	 */
  	RDMA_NLDEV_ATTR_RES_KERN_NAME,		/* string */
  
++<<<<<<< HEAD
++=======
+ 	RDMA_NLDEV_ATTR_RES_CM_ID,		/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_CM_ID_ENTRY,	/* nested table */
+ 	/*
+ 	 * rdma_cm_id port space.
+ 	 */
+ 	RDMA_NLDEV_ATTR_RES_PS,			/* u32 */
+ 	/*
+ 	 * Source and destination socket addresses
+ 	 */
+ 	RDMA_NLDEV_ATTR_RES_SRC_ADDR,		/* __kernel_sockaddr_storage */
+ 	RDMA_NLDEV_ATTR_RES_DST_ADDR,		/* __kernel_sockaddr_storage */
+ 
+ 	RDMA_NLDEV_ATTR_RES_CQ,			/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_CQ_ENTRY,		/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_CQE,		/* u32 */
+ 	RDMA_NLDEV_ATTR_RES_USECNT,		/* u64 */
+ 	RDMA_NLDEV_ATTR_RES_POLL_CTX,		/* u8 */
+ 
+ 	RDMA_NLDEV_ATTR_RES_MR,			/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_MR_ENTRY,		/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_RKEY,		/* u32 */
+ 	RDMA_NLDEV_ATTR_RES_LKEY,		/* u32 */
+ 	RDMA_NLDEV_ATTR_RES_IOVA,		/* u64 */
+ 	RDMA_NLDEV_ATTR_RES_MRLEN,		/* u64 */
+ 
+ 	RDMA_NLDEV_ATTR_RES_PD,			/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_PD_ENTRY,		/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_LOCAL_DMA_LKEY,	/* u32 */
+ 	RDMA_NLDEV_ATTR_RES_UNSAFE_GLOBAL_RKEY,	/* u32 */
+ 	/*
+ 	 * driver-specific attributes.
+ 	 */
+ 	RDMA_NLDEV_ATTR_DRIVER,			/* nested table */
+ 	RDMA_NLDEV_ATTR_DRIVER_ENTRY,		/* nested table */
+ 	RDMA_NLDEV_ATTR_DRIVER_STRING,		/* string */
+ 	/*
+ 	 * u8 values from enum rdma_nldev_print_type
+ 	 */
+ 	RDMA_NLDEV_ATTR_DRIVER_PRINT_TYPE,	/* u8 */
+ 	RDMA_NLDEV_ATTR_DRIVER_S32,		/* s32 */
+ 	RDMA_NLDEV_ATTR_DRIVER_U32,		/* u32 */
+ 	RDMA_NLDEV_ATTR_DRIVER_S64,		/* s64 */
+ 	RDMA_NLDEV_ATTR_DRIVER_U64,		/* u64 */
+ 
+ 	/*
+ 	 * Provides logical name and index of netdevice which is
+ 	 * connected to physical port. This information is relevant
+ 	 * for RoCE and iWARP.
+ 	 *
+ 	 * The netdevices which are associated with containers are
+ 	 * supposed to be exported together with GID table once it
+ 	 * will be exposed through the netlink. Because the
+ 	 * associated netdevices are properties of GIDs.
+ 	 */
+ 	RDMA_NLDEV_ATTR_NDEV_INDEX,		/* u32 */
+ 	RDMA_NLDEV_ATTR_NDEV_NAME,		/* string */
+ 
++>>>>>>> da5c85078215 (RDMA/nldev: add driver-specific resource tracking)
  	RDMA_NLDEV_ATTR_MAX
  };
  #endif /* _UAPI_RDMA_NETLINK_H */
* Unmerged path drivers/infiniband/core/nldev.c
* Unmerged path drivers/infiniband/core/restrack.c
diff --git a/include/rdma/restrack.h b/include/rdma/restrack.h
index 7513d0d8b9da..465e905a6681 100644
--- a/include/rdma/restrack.h
+++ b/include/rdma/restrack.h
@@ -35,6 +35,8 @@ enum rdma_restrack_type {
 };
 
 #define RDMA_RESTRACK_HASH_BITS	8
+struct rdma_restrack_entry;
+
 /**
  * struct rdma_restrack_root - main resource tracking management
  * entity, per-device
@@ -48,6 +50,13 @@ struct rdma_restrack_root {
 	 * @hash: global database for all resources per-device
 	 */
 	DECLARE_HASHTABLE(hash, RDMA_RESTRACK_HASH_BITS);
+	/**
+	 * @fill_res_entry: driver-specific fill function
+	 *
+	 * Allows rdma drivers to add their own restrack attributes.
+	 */
+	int (*fill_res_entry)(struct sk_buff *msg,
+			      struct rdma_restrack_entry *entry);
 };
 
 /**
* Unmerged path include/uapi/rdma/rdma_netlink.h
