scsi: lpfc: update fault value on successful trunk events.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [scsi] lpfc: update fault value on successful trunk events (Dick Kennedy) [1642905]
Rebuild_FUZZ: 93.58%
commit-author James Smart <jsmart2021@gmail.com>
commit 529b3ddcfff580a2457eceeda9f248bc77c49246
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/529b3ddc.failed

Currently, when a trunk link goes down due to some fault, the driver
snapshots the fault code.  If the link then comes back up, meaning there is
no fault, the driver is not clearing the fault code so the sysfs link_state
entry reports old/stale data.

Revise the logic so that on successful link up the fault code is cleared.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <jsmart2021@gmail.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 529b3ddcfff580a2457eceeda9f248bc77c49246)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_init.c
diff --cc drivers/scsi/lpfc/lpfc_init.c
index 627f7716d6d1,2b8baf190165..000000000000
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@@ -4627,6 -4623,136 +4627,139 @@@ out_free_pmb
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * lpfc_async_link_speed_to_read_top - Parse async evt link speed code to read
+  * topology.
+  * @phba: pointer to lpfc hba data structure.
+  * @evt_code: asynchronous event code.
+  * @speed_code: asynchronous event link speed code.
+  *
+  * This routine is to parse the giving SLI4 async event link speed code into
+  * value of Read topology link speed.
+  *
+  * Return: link speed in terms of Read topology.
+  **/
+ static uint8_t
+ lpfc_async_link_speed_to_read_top(struct lpfc_hba *phba, uint8_t speed_code)
+ {
+ 	uint8_t port_speed;
+ 
+ 	switch (speed_code) {
+ 	case LPFC_FC_LA_SPEED_1G:
+ 		port_speed = LPFC_LINK_SPEED_1GHZ;
+ 		break;
+ 	case LPFC_FC_LA_SPEED_2G:
+ 		port_speed = LPFC_LINK_SPEED_2GHZ;
+ 		break;
+ 	case LPFC_FC_LA_SPEED_4G:
+ 		port_speed = LPFC_LINK_SPEED_4GHZ;
+ 		break;
+ 	case LPFC_FC_LA_SPEED_8G:
+ 		port_speed = LPFC_LINK_SPEED_8GHZ;
+ 		break;
+ 	case LPFC_FC_LA_SPEED_16G:
+ 		port_speed = LPFC_LINK_SPEED_16GHZ;
+ 		break;
+ 	case LPFC_FC_LA_SPEED_32G:
+ 		port_speed = LPFC_LINK_SPEED_32GHZ;
+ 		break;
+ 	case LPFC_FC_LA_SPEED_64G:
+ 		port_speed = LPFC_LINK_SPEED_64GHZ;
+ 		break;
+ 	case LPFC_FC_LA_SPEED_128G:
+ 		port_speed = LPFC_LINK_SPEED_128GHZ;
+ 		break;
+ 	case LPFC_FC_LA_SPEED_256G:
+ 		port_speed = LPFC_LINK_SPEED_256GHZ;
+ 		break;
+ 	default:
+ 		port_speed = 0;
+ 		break;
+ 	}
+ 
+ 	return port_speed;
+ }
+ 
+ #define trunk_link_status(__idx)\
+ 	bf_get(lpfc_acqe_fc_la_trunk_config_port##__idx, acqe_fc) ?\
+ 	       ((phba->trunk_link.link##__idx.state == LPFC_LINK_UP) ?\
+ 		"Link up" : "Link down") : "NA"
+ /* Did port __idx reported an error */
+ #define trunk_port_fault(__idx)\
+ 	bf_get(lpfc_acqe_fc_la_trunk_config_port##__idx, acqe_fc) ?\
+ 	       (port_fault & (1 << __idx) ? "YES" : "NO") : "NA"
+ 
+ static void
+ lpfc_update_trunk_link_status(struct lpfc_hba *phba,
+ 			      struct lpfc_acqe_fc_la *acqe_fc)
+ {
+ 	uint8_t port_fault = bf_get(lpfc_acqe_fc_la_trunk_linkmask, acqe_fc);
+ 	uint8_t err = bf_get(lpfc_acqe_fc_la_trunk_fault, acqe_fc);
+ 
+ 	phba->sli4_hba.link_state.speed =
+ 		lpfc_sli4_port_speed_parse(phba, LPFC_TRAILER_CODE_FC,
+ 				bf_get(lpfc_acqe_fc_la_speed, acqe_fc));
+ 
+ 	phba->sli4_hba.link_state.logical_speed =
+ 				bf_get(lpfc_acqe_fc_la_llink_spd, acqe_fc);
+ 	/* We got FC link speed, convert to fc_linkspeed (READ_TOPOLOGY) */
+ 	phba->fc_linkspeed =
+ 		 lpfc_async_link_speed_to_read_top(
+ 				phba,
+ 				bf_get(lpfc_acqe_fc_la_speed, acqe_fc));
+ 
+ 	if (bf_get(lpfc_acqe_fc_la_trunk_config_port0, acqe_fc)) {
+ 		phba->trunk_link.link0.state =
+ 			bf_get(lpfc_acqe_fc_la_trunk_link_status_port0, acqe_fc)
+ 			? LPFC_LINK_UP : LPFC_LINK_DOWN;
+ 		phba->trunk_link.link0.fault = port_fault & 0x1 ? err : 0;
+ 	}
+ 	if (bf_get(lpfc_acqe_fc_la_trunk_config_port1, acqe_fc)) {
+ 		phba->trunk_link.link1.state =
+ 			bf_get(lpfc_acqe_fc_la_trunk_link_status_port1, acqe_fc)
+ 			? LPFC_LINK_UP : LPFC_LINK_DOWN;
+ 		phba->trunk_link.link1.fault = port_fault & 0x2 ? err : 0;
+ 	}
+ 	if (bf_get(lpfc_acqe_fc_la_trunk_config_port2, acqe_fc)) {
+ 		phba->trunk_link.link2.state =
+ 			bf_get(lpfc_acqe_fc_la_trunk_link_status_port2, acqe_fc)
+ 			? LPFC_LINK_UP : LPFC_LINK_DOWN;
+ 		phba->trunk_link.link2.fault = port_fault & 0x4 ? err : 0;
+ 	}
+ 	if (bf_get(lpfc_acqe_fc_la_trunk_config_port3, acqe_fc)) {
+ 		phba->trunk_link.link3.state =
+ 			bf_get(lpfc_acqe_fc_la_trunk_link_status_port3, acqe_fc)
+ 			? LPFC_LINK_UP : LPFC_LINK_DOWN;
+ 		phba->trunk_link.link3.fault = port_fault & 0x8 ? err : 0;
+ 	}
+ 
+ 	lpfc_printf_log(phba, KERN_ERR, LOG_SLI,
+ 			"2910 Async FC Trunking Event - Speed:%d\n"
+ 			"\tLogical speed:%d "
+ 			"port0: %s port1: %s port2: %s port3: %s\n",
+ 			phba->sli4_hba.link_state.speed,
+ 			phba->sli4_hba.link_state.logical_speed,
+ 			trunk_link_status(0), trunk_link_status(1),
+ 			trunk_link_status(2), trunk_link_status(3));
+ 
+ 	if (port_fault)
+ 		lpfc_printf_log(phba, KERN_ERR, LOG_SLI,
+ 				"3202 trunk error:0x%x (%s) seen on port0:%s "
+ 				/*
+ 				 * SLI-4: We have only 0xA error codes
+ 				 * defined as of now. print an appropriate
+ 				 * message in case driver needs to be updated.
+ 				 */
+ 				"port1:%s port2:%s port3:%s\n", err, err > 0xA ?
+ 				"UNDEFINED. update driver." : trunk_errmsg[err],
+ 				trunk_port_fault(0), trunk_port_fault(1),
+ 				trunk_port_fault(2), trunk_port_fault(3));
+ }
+ 
+ 
+ /**
++>>>>>>> 529b3ddcfff5 (scsi: lpfc: update fault value on successful trunk events.)
   * lpfc_sli4_async_fc_evt - Process the asynchronous FC link event
   * @phba: pointer to lpfc hba data structure.
   * @acqe_fc: pointer to the async fc completion queue entry.
* Unmerged path drivers/scsi/lpfc/lpfc_init.c
