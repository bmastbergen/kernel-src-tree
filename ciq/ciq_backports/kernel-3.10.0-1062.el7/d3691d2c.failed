proc: add cond_resched to /proc/kpage* read/write loop

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [fs] kernel: proc: add cond_resched to /proc/kpage* read/write loop (Rafael Aquini) [1560020]
Rebuild_FUZZ: 93.10%
commit-author Vladimir Davydov <vdavydov@parallels.com>
commit d3691d2c6d3e72624c987bbef6f322631bbb2d5d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/d3691d2c.failed

Reading/writing a /proc/kpage* file may take long on machines with a lot
of RAM installed.

	Signed-off-by: Vladimir Davydov <vdavydov@parallels.com>
	Suggested-by: Andres Lagar-Cavilla <andreslc@google.com>
	Reviewed-by: Andres Lagar-Cavilla <andreslc@google.com>
	Cc: Minchan Kim <minchan@kernel.org>
	Cc: Raghavendra K T <raghavendra.kt@linux.vnet.ibm.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Michal Hocko <mhocko@suse.cz>
	Cc: Greg Thelen <gthelen@google.com>
	Cc: Michel Lespinasse <walken@google.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Pavel Emelyanov <xemul@parallels.com>
	Cc: Cyrill Gorcunov <gorcunov@openvz.org>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit d3691d2c6d3e72624c987bbef6f322631bbb2d5d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/page.c
diff --cc fs/proc/page.c
index 4bb8e0142f7a,93484034a03d..000000000000
--- a/fs/proc/page.c
+++ b/fs/proc/page.c
@@@ -215,6 -236,57 +219,60 @@@ static const struct file_operations pro
  	.read = kpageflags_read,
  };
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_MEMCG
+ static ssize_t kpagecgroup_read(struct file *file, char __user *buf,
+ 				size_t count, loff_t *ppos)
+ {
+ 	u64 __user *out = (u64 __user *)buf;
+ 	struct page *ppage;
+ 	unsigned long src = *ppos;
+ 	unsigned long pfn;
+ 	ssize_t ret = 0;
+ 	u64 ino;
+ 
+ 	pfn = src / KPMSIZE;
+ 	count = min_t(unsigned long, count, (max_pfn * KPMSIZE) - src);
+ 	if (src & KPMMASK || count & KPMMASK)
+ 		return -EINVAL;
+ 
+ 	while (count > 0) {
+ 		if (pfn_valid(pfn))
+ 			ppage = pfn_to_page(pfn);
+ 		else
+ 			ppage = NULL;
+ 
+ 		if (ppage)
+ 			ino = page_cgroup_ino(ppage);
+ 		else
+ 			ino = 0;
+ 
+ 		if (put_user(ino, out)) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 
+ 		pfn++;
+ 		out++;
+ 		count -= KPMSIZE;
+ 
+ 		cond_resched();
+ 	}
+ 
+ 	*ppos += (char __user *)out - buf;
+ 	if (!ret)
+ 		ret = (char __user *)out - buf;
+ 	return ret;
+ }
+ 
+ static const struct file_operations proc_kpagecgroup_operations = {
+ 	.llseek = mem_lseek,
+ 	.read = kpagecgroup_read,
+ };
+ #endif /* CONFIG_MEMCG */
+ 
++>>>>>>> d3691d2c6d3e (proc: add cond_resched to /proc/kpage* read/write loop)
  static int __init proc_page_init(void)
  {
  	proc_create("kpagecount", S_IRUSR, NULL, &proc_kpagecount_operations);
* Unmerged path fs/proc/page.c
