fuse: only reuse auxiliary request in fuse_writepage_in_flight()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 419234d5958b8ec4f5e2ba8ed2e77916f844ded1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/419234d5.failed

Don't reuse the queued request, even if it only contains a single page.
This is needed because previous locking changes (spliting out
fiq->waitq.lock from fc->lock) broke the assumption that request will
remain in FR_PENDING at least until the new page contents are copied.

This fix removes a slight optimization for a rare corner case, so we really
shoudln't care.

	Reported-by: Kirill Tkhai <ktkhai@virtuozzo.com>
Fixes: fd22d62ed0c3 ("fuse: no fc->lock for iqueue parts")
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 419234d5958b8ec4f5e2ba8ed2e77916f844ded1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/file.c
diff --cc fs/fuse/file.c
index d851e606d416,b0c32a74082f..000000000000
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@@ -1775,6 -1744,13 +1775,16 @@@ static void fuse_writepages_send(struc
  		end_page_writeback(data->orig_pages[i]);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * First recheck under fi->lock if the offending offset is still under
+  * writeback.  If yes, then iterate auxiliary write requests, to see if there's
+  * one already added for a page at this offset.  If there's none, then insert
+  * this new request onto the auxiliary list, otherwise reuse the existing one by
+  * copying the new page contents over to the old temporary page.
+  */
++>>>>>>> 419234d5958b (fuse: only reuse auxiliary request in fuse_writepage_in_flight())
  static bool fuse_writepage_in_flight(struct fuse_req *new_req,
  				     struct page *page)
  {
@@@ -1804,12 -1771,16 +1814,25 @@@
  	}
  
  	new_req->num_pages = 1;
++<<<<<<< HEAD
 +	for (tmp = old_req; tmp != NULL; tmp = tmp->misc.write.next) {
 +		BUG_ON(tmp->inode != new_req->inode);
 +		curr_index = tmp->misc.write.in.offset >> PAGE_CACHE_SHIFT;
 +		if (tmp->num_pages == 1 &&
 +		    curr_index == page->index) {
 +			old_req = tmp;
++=======
+ 	for (tmp = old_req->misc.write.next; tmp; tmp = tmp->misc.write.next) {
+ 		pgoff_t curr_index;
+ 
+ 		WARN_ON(tmp->inode != new_req->inode);
+ 		curr_index = tmp->misc.write.in.offset >> PAGE_SHIFT;
+ 		if (curr_index == page->index) {
+ 			WARN_ON(tmp->num_pages != 1);
+ 			WARN_ON(!test_bit(FR_PENDING, &tmp->flags));
+ 			copy_highpage(tmp->pages[0], page);
+ 			break;
++>>>>>>> 419234d5958b (fuse: only reuse auxiliary request in fuse_writepage_in_flight())
  		}
  	}
  
* Unmerged path fs/fuse/file.c
