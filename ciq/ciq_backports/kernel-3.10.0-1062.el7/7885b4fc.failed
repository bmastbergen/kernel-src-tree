nfp: flower: allow non repr netdev offload

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author John Hurley <john.hurley@netronome.com>
commit 7885b4fc8d8e3d0e489f08144f3d4eb2952cb852
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7885b4fc.failed

Previously the offload functions in NFP assumed that the ingress (or
egress) netdev passed to them was an nfp repr.

Modify the driver to permit the passing of non repr netdevs as the ingress
device for an offload rule candidate. This may include devices such as
tunnels. The driver should then base its offload decision on a combination
of ingress device and egress port for a rule.

	Signed-off-by: John Hurley <john.hurley@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7885b4fc8d8e3d0e489f08144f3d4eb2952cb852)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/flower/offload.c
diff --cc drivers/net/ethernet/netronome/nfp/flower/offload.c
index 970ddbd64602,2c32edfc1a9d..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/offload.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/offload.c
@@@ -460,10 -429,24 +459,30 @@@ nfp_flower_add_offload(struct nfp_app *
  	struct nfp_flower_priv *priv = app->priv;
  	struct nfp_fl_payload *flow_pay;
  	struct nfp_fl_key_ls *key_layer;
++<<<<<<< HEAD
 +	unsigned long fl_key;
 +	int err;
 +
++=======
+ 	struct nfp_port *port = NULL;
+ 	struct net_device *ingr_dev;
+ 	int err;
+ 
+ 	if (nfp_netdev_is_nfp_repr(netdev))
+ 		port = nfp_port_from_netdev(netdev);
+ 
+ 	ingr_dev = egress ? NULL : netdev;
+ 	flow_pay = nfp_flower_search_fl_table(app, flow->cookie, ingr_dev,
+ 					      NFP_FL_STATS_CTX_DONT_CARE);
+ 	if (flow_pay) {
+ 		/* Ignore as duplicate if it has been added by different cb. */
+ 		if (flow_pay->ingress_offload && egress)
+ 			return 0;
+ 		else
+ 			return -EOPNOTSUPP;
+ 	}
+ 
++>>>>>>> 7885b4fc8d8e (nfp: flower: allow non repr netdev offload)
  	key_layer = kmalloc(sizeof(*key_layer), GFP_KERNEL);
  	if (!key_layer)
  		return -ENOMEM;
@@@ -479,8 -462,10 +498,15 @@@
  		goto err_free_key_ls;
  	}
  
++<<<<<<< HEAD
 +	err = nfp_flower_compile_flow_match(flow, key_layer, netdev, flow_pay,
 +					    tun_type);
++=======
+ 	flow_pay->ingress_dev = egress ? NULL : netdev;
+ 
+ 	err = nfp_flower_compile_flow_match(app, flow, key_layer, netdev,
+ 					    flow_pay, tun_type);
++>>>>>>> 7885b4fc8d8e (nfp: flower: allow non repr netdev offload)
  	if (err)
  		goto err_destroy_flow;
  
@@@ -497,11 -483,14 +523,21 @@@
  	if (err)
  		goto err_destroy_flow;
  
 +	INIT_HLIST_NODE(&flow_pay->link);
  	flow_pay->tc_flower_cookie = flow->cookie;
++<<<<<<< HEAD
 +	fl_key = nfp_flower_fl_key(flow->cookie);
 +	hash_add_rcu(priv->flow_table, &flow_pay->link, fl_key);
 +	port->tc_offload_cnt++;
++=======
+ 	err = rhashtable_insert_fast(&priv->flow_table, &flow_pay->fl_node,
+ 				     nfp_flower_table_params);
+ 	if (err)
+ 		goto err_destroy_flow;
+ 
+ 	if (port)
+ 		port->tc_offload_cnt++;
++>>>>>>> 7885b4fc8d8e (nfp: flower: allow non repr netdev offload)
  
  	/* Deallocate flow payload when flower rule has been destroyed. */
  	kfree(key_layer);
@@@ -531,15 -521,22 +567,30 @@@ err_free_key_ls
   */
  static int
  nfp_flower_del_offload(struct nfp_app *app, struct net_device *netdev,
 -		       struct tc_cls_flower_offload *flow, bool egress)
 +		       struct tc_cls_flower_offload *flow)
  {
++<<<<<<< HEAD
 +	struct nfp_port *port = nfp_port_from_netdev(netdev);
 +	struct nfp_fl_payload *nfp_flow;
 +	int err;
 +
 +	nfp_flow = nfp_flower_search_fl_table(app, flow->cookie);
++=======
+ 	struct nfp_flower_priv *priv = app->priv;
+ 	struct nfp_fl_payload *nfp_flow;
+ 	struct nfp_port *port = NULL;
+ 	struct net_device *ingr_dev;
+ 	int err;
+ 
+ 	if (nfp_netdev_is_nfp_repr(netdev))
+ 		port = nfp_port_from_netdev(netdev);
+ 
+ 	ingr_dev = egress ? NULL : netdev;
+ 	nfp_flow = nfp_flower_search_fl_table(app, flow->cookie, ingr_dev,
+ 					      NFP_FL_STATS_CTX_DONT_CARE);
++>>>>>>> 7885b4fc8d8e (nfp: flower: allow non repr netdev offload)
  	if (!nfp_flow)
 -		return egress ? 0 : -ENOENT;
 +		return -ENOENT;
  
  	err = nfp_modify_flow_metadata(app, nfp_flow);
  	if (err)
@@@ -554,8 -551,8 +605,13 @@@
  		goto err_free_flow;
  
  err_free_flow:
++<<<<<<< HEAD
 +	hash_del_rcu(&nfp_flow->link);
 +	port->tc_offload_cnt--;
++=======
+ 	if (port)
+ 		port->tc_offload_cnt--;
++>>>>>>> 7885b4fc8d8e (nfp: flower: allow non repr netdev offload)
  	kfree(nfp_flow->action_data);
  	kfree(nfp_flow->mask_data);
  	kfree(nfp_flow->unmasked_data);
diff --git a/drivers/net/ethernet/netronome/nfp/flower/action.c b/drivers/net/ethernet/netronome/nfp/flower/action.c
index 8dead3a52f6d..9362995cf5d1 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/action.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/action.c
@@ -132,11 +132,12 @@ nfp_fl_output(struct nfp_fl_output *output, const struct tc_action *action,
 		/* Set action output parameters. */
 		output->flags = cpu_to_be16(tmp_flags);
 
-		/* Only offload if egress ports are on the same device as the
-		 * ingress port.
-		 */
-		if (!switchdev_port_same_parent_id(in_dev, out_dev))
-			return -EOPNOTSUPP;
+		if (nfp_netdev_is_nfp_repr(in_dev)) {
+			/* Confirm ingress and egress are on same device. */
+			if (!switchdev_port_same_parent_id(in_dev, out_dev))
+				return -EOPNOTSUPP;
+		}
+
 		if (!nfp_netdev_is_nfp_repr(out_dev))
 			return -EOPNOTSUPP;
 
@@ -598,9 +599,8 @@ nfp_flower_loop_action(const struct tc_action *a,
 		*a_len += sizeof(struct nfp_fl_push_vlan);
 	} else if (is_tcf_tunnel_set(a)) {
 		struct ip_tunnel_info *ip_tun = tcf_tunnel_info(a);
-		struct nfp_repr *repr = netdev_priv(netdev);
 
-		*tun_type = nfp_fl_get_tun_from_act_l4_port(repr->app, a);
+		*tun_type = nfp_fl_get_tun_from_act_l4_port(app, a);
 		if (*tun_type == NFP_FL_TUNNEL_NONE)
 			return -EOPNOTSUPP;
 
diff --git a/drivers/net/ethernet/netronome/nfp/flower/main.h b/drivers/net/ethernet/netronome/nfp/flower/main.h
index 90cc96d4eae4..5dca083ddb56 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/main.h
+++ b/drivers/net/ethernet/netronome/nfp/flower/main.h
@@ -260,7 +260,8 @@ void nfp_flower_metadata_cleanup(struct nfp_app *app);
 
 int nfp_flower_setup_tc(struct nfp_app *app, struct net_device *netdev,
 			enum tc_setup_type type, void *type_data);
-int nfp_flower_compile_flow_match(struct tc_cls_flower_offload *flow,
+int nfp_flower_compile_flow_match(struct nfp_app *app,
+				  struct tc_cls_flower_offload *flow,
 				  struct nfp_fl_key_ls *key_ls,
 				  struct net_device *netdev,
 				  struct nfp_fl_payload *nfp_flow,
diff --git a/drivers/net/ethernet/netronome/nfp/flower/match.c b/drivers/net/ethernet/netronome/nfp/flower/match.c
index 17acb8cc6044..4900899995db 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/match.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/match.c
@@ -82,10 +82,13 @@ nfp_flower_compile_port(struct nfp_flower_in_port *frame, u32 cmsg_port,
 		return 0;
 	}
 
-	if (tun_type)
+	if (tun_type) {
 		frame->in_port = cpu_to_be32(NFP_FL_PORT_TYPE_TUN | tun_type);
-	else
+	} else {
+		if (!cmsg_port)
+			return -EOPNOTSUPP;
 		frame->in_port = cpu_to_be32(cmsg_port);
+	}
 
 	return 0;
 }
@@ -319,17 +322,21 @@ nfp_flower_compile_ipv4_udp_tun(struct nfp_flower_ipv4_udp_tun *frame,
 	}
 }
 
-int nfp_flower_compile_flow_match(struct tc_cls_flower_offload *flow,
+int nfp_flower_compile_flow_match(struct nfp_app *app,
+				  struct tc_cls_flower_offload *flow,
 				  struct nfp_fl_key_ls *key_ls,
 				  struct net_device *netdev,
 				  struct nfp_fl_payload *nfp_flow,
 				  enum nfp_flower_tun_type tun_type)
 {
-	struct nfp_repr *netdev_repr;
+	u32 cmsg_port = 0;
 	int err;
 	u8 *ext;
 	u8 *msk;
 
+	if (nfp_netdev_is_nfp_repr(netdev))
+		cmsg_port = nfp_repr_get_port_id(netdev);
+
 	memset(nfp_flow->unmasked_data, 0, key_ls->key_size);
 	memset(nfp_flow->mask_data, 0, key_ls->key_size);
 
@@ -357,15 +364,13 @@ int nfp_flower_compile_flow_match(struct tc_cls_flower_offload *flow,
 
 	/* Populate Exact Port data. */
 	err = nfp_flower_compile_port((struct nfp_flower_in_port *)ext,
-				      nfp_repr_get_port_id(netdev),
-				      false, tun_type);
+				      cmsg_port, false, tun_type);
 	if (err)
 		return err;
 
 	/* Populate Mask Port Data. */
 	err = nfp_flower_compile_port((struct nfp_flower_in_port *)msk,
-				      nfp_repr_get_port_id(netdev),
-				      true, tun_type);
+				      cmsg_port, true, tun_type);
 	if (err)
 		return err;
 
@@ -429,16 +434,13 @@ int nfp_flower_compile_flow_match(struct tc_cls_flower_offload *flow,
 		msk += sizeof(struct nfp_flower_ipv4_udp_tun);
 
 		/* Configure tunnel end point MAC. */
-		if (nfp_netdev_is_nfp_repr(netdev)) {
-			netdev_repr = netdev_priv(netdev);
-			nfp_tunnel_write_macs(netdev_repr->app);
-
-			/* Store the tunnel destination in the rule data.
-			 * This must be present and be an exact match.
-			 */
-			nfp_flow->nfp_tun_ipv4_addr = tun_dst;
-			nfp_tunnel_add_ipv4_off(netdev_repr->app, tun_dst);
-		}
+		nfp_tunnel_write_macs(app);
+
+		/* Store the tunnel destination in the rule data.
+		 * This must be present and be an exact match.
+		 */
+		nfp_flow->nfp_tun_ipv4_addr = tun_dst;
+		nfp_tunnel_add_ipv4_off(app, tun_dst);
 
 		if (key_ls->key_layer_two & NFP_FLOWER_LAYER2_GENEVE_OP) {
 			err = nfp_flower_compile_geneve_opt(ext, flow, false);
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/offload.c
