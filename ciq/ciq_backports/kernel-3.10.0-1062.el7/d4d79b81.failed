autofs: fix directory and symlink access

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Ian Kent <raven@themaw.net>
commit d4d79b8195bfc6d5d8f82f9189c1bc828cc7e03a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/d4d79b81.failed

Depending on how it is configured the autofs user space daemon can leave
in use mounts mounted at exit and re-connect to them at start up.  But for
this to work best the state of the autofs file system needs to be left
intact over the restart.

Also, at system shutdown, mounts in an autofs file system might be
umounted exposing a mount point trigger for which subsequent access can
lead to a hang.  So recent versions of automount(8) now does its best to
set autofs file system mounts catatonic at shutdown.

When autofs file system mounts are catatonic it's currently possible to
create and remove directories and symlinks which can be a problem at
restart, as described above.

So return EACCES in the directory, symlink and unlink methods if the
autofs file system is catatonic.

Link: http://lkml.kernel.org/r/152902119090.4144.9561910674530214291.stgit@pluto.themaw.net
	Signed-off-by: Ian Kent <raven@themaw.net>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit d4d79b8195bfc6d5d8f82f9189c1bc828cc7e03a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/autofs4/root.c
diff --cc fs/autofs4/root.c
index 4975f663a9f2,782e57b911ab..000000000000
--- a/fs/autofs4/root.c
+++ b/fs/autofs4/root.c
@@@ -562,14 -556,21 +562,21 @@@ static int autofs4_dir_symlink(struct i
  
  	pr_debug("%s <- %pd\n", symname, dentry);
  
 -	if (!autofs_oz_mode(sbi))
 +	if (!autofs4_oz_mode(sbi))
  		return -EACCES;
  
+ 	/* autofs_oz_mode() needs to allow path walks when the
+ 	 * autofs mount is catatonic but the state of an autofs
+ 	 * file system needs to be preserved over restarts.
+ 	 */
+ 	if (sbi->catatonic)
+ 		return -EACCES;
+ 
  	BUG_ON(!ino);
  
 -	autofs_clean_ino(ino);
 +	autofs4_clean_ino(ino);
  
 -	autofs_del_active(dentry);
 +	autofs4_del_active(dentry);
  
  	cp = kmalloc(size + 1, GFP_KERNEL);
  	if (!cp)
@@@ -610,20 -611,26 +617,32 @@@
   * If a process is blocked on the dentry waiting for the expire to finish,
   * it will invalidate the dentry and try to mount with a new one.
   *
 - * Also see autofs_dir_rmdir()..
 + * Also see autofs4_dir_rmdir()..
   */
 -static int autofs_dir_unlink(struct inode *dir, struct dentry *dentry)
 +static int autofs4_dir_unlink(struct inode *dir, struct dentry *dentry)
  {
 -	struct autofs_sb_info *sbi = autofs_sbi(dir->i_sb);
 -	struct autofs_info *ino = autofs_dentry_ino(dentry);
 +	struct autofs_sb_info *sbi = autofs4_sbi(dir->i_sb);
 +	struct autofs_info *ino = autofs4_dentry_ino(dentry);
  	struct autofs_info *p_ino;
  
++<<<<<<< HEAD:fs/autofs4/root.c
 +	/* This allows root to remove symlinks */
 +	if (!autofs4_oz_mode(sbi) && !capable(CAP_SYS_ADMIN))
 +		return -EPERM;
++=======
+ 	if (!autofs_oz_mode(sbi))
+ 		return -EACCES;
+ 
+ 	/* autofs_oz_mode() needs to allow path walks when the
+ 	 * autofs mount is catatonic but the state of an autofs
+ 	 * file system needs to be preserved over restarts.
+ 	 */
+ 	if (sbi->catatonic)
+ 		return -EACCES;
++>>>>>>> d4d79b8195bf (autofs: fix directory and symlink access):fs/autofs/root.c
  
  	if (atomic_dec_and_test(&ino->count)) {
 -		p_ino = autofs_dentry_ino(dentry->d_parent);
 +		p_ino = autofs4_dentry_ino(dentry->d_parent);
  		if (p_ino && !IS_ROOT(dentry))
  			atomic_dec(&p_ino->count);
  	}
@@@ -700,9 -707,16 +719,16 @@@ static int autofs4_dir_rmdir(struct ino
  
  	pr_debug("dentry %p, removing %pd\n", dentry, dentry);
  
 -	if (!autofs_oz_mode(sbi))
 +	if (!autofs4_oz_mode(sbi))
  		return -EACCES;
  
+ 	/* autofs_oz_mode() needs to allow path walks when the
+ 	 * autofs mount is catatonic but the state of an autofs
+ 	 * file system needs to be preserved over restarts.
+ 	 */
+ 	if (sbi->catatonic)
+ 		return -EACCES;
+ 
  	spin_lock(&sbi->lookup_lock);
  	if (!simple_empty(dentry)) {
  		spin_unlock(&sbi->lookup_lock);
@@@ -738,9 -752,16 +764,16 @@@ static int autofs4_dir_mkdir(struct ino
  	struct autofs_info *p_ino;
  	struct inode *inode;
  
 -	if (!autofs_oz_mode(sbi))
 +	if (!autofs4_oz_mode(sbi))
  		return -EACCES;
  
+ 	/* autofs_oz_mode() needs to allow path walks when the
+ 	 * autofs mount is catatonic but the state of an autofs
+ 	 * file system needs to be preserved over restarts.
+ 	 */
+ 	if (sbi->catatonic)
+ 		return -EACCES;
+ 
  	pr_debug("dentry %p, creating %pd\n", dentry, dentry);
  
  	BUG_ON(!ino);
* Unmerged path fs/autofs4/root.c
