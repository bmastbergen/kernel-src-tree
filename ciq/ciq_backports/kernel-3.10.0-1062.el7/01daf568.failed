x86/speculation: Reorganize speculation control MSRs update

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [x86] speculation: Reorganize speculation control MSRs update (Waiman Long) [1671826]
Rebuild_FUZZ: 96.49%
commit-author Tim Chen <tim.c.chen@linux.intel.com>
commit 01daf56875ee0cd50ed496a09b20eb369b45dfa5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/01daf568.failed

The logic to detect whether there's a change in the previous and next
task's flag relevant to update speculation control MSRs is spread out
across multiple functions.

Consolidate all checks needed for updating speculation control MSRs into
the new __speculation_ctrl_update() helper function.

This makes it easy to pick the right speculation control MSR and the bits
in MSR_IA32_SPEC_CTRL that need updating based on TIF flags changes.

Originally-by: Thomas Lendacky <Thomas.Lendacky@amd.com>
	Signed-off-by: Tim Chen <tim.c.chen@linux.intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Ingo Molnar <mingo@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Jiri Kosina <jkosina@suse.cz>
	Cc: Tom Lendacky <thomas.lendacky@amd.com>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: David Woodhouse <dwmw@amazon.co.uk>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Dave Hansen <dave.hansen@intel.com>
	Cc: Casey Schaufler <casey.schaufler@intel.com>
	Cc: Asit Mallick <asit.k.mallick@intel.com>
	Cc: Arjan van de Ven <arjan@linux.intel.com>
	Cc: Jon Masters <jcm@redhat.com>
	Cc: Waiman Long <longman9394@gmail.com>
	Cc: Greg KH <gregkh@linuxfoundation.org>
	Cc: Dave Stewart <david.c.stewart@intel.com>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: stable@vger.kernel.org
Link: https://lkml.kernel.org/r/20181125185004.151077005@linutronix.de


(cherry picked from commit 01daf56875ee0cd50ed496a09b20eb369b45dfa5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/process.c
diff --cc arch/x86/kernel/process.c
index 5ad9710f0312,70e9832379e1..000000000000
--- a/arch/x86/kernel/process.c
+++ b/arch/x86/kernel/process.c
@@@ -315,32 -395,42 +315,67 @@@ static __always_inline void amd_set_ssb
  	wrmsrl(MSR_AMD64_VIRT_SPEC_CTRL, ssbd_tif_to_spec_ctrl(tifn));
  }
  
++<<<<<<< HEAD
 +static __always_inline void intel_set_ssb_state(unsigned long tifn)
 +{
 +	spec_ctrl_set_ssbd(ssbd_tif_to_spec_ctrl(tifn));
 +	wrmsrl(MSR_IA32_SPEC_CTRL, this_cpu_read(spec_ctrl_pcp.entry64));
 +}
 +
 +static __always_inline void __speculative_store_bypass_update(unsigned long tifn)
 +{
 +	if (!static_key_false(&ssbd_userset_key))
 +		return;	/* Don't do anything if not user settable */
 +
 +	if (static_cpu_has(X86_FEATURE_VIRT_SSBD))
 +		amd_set_ssb_virt_state(tifn);
 +	else if (static_cpu_has(X86_FEATURE_LS_CFG_SSBD))
 +		amd_set_core_ssb_state(tifn);
 +	else
 +		intel_set_ssb_state(tifn);
++=======
+ /*
+  * Update the MSRs managing speculation control, during context switch.
+  *
+  * tifp: Previous task's thread flags
+  * tifn: Next task's thread flags
+  */
+ static __always_inline void __speculation_ctrl_update(unsigned long tifp,
+ 						      unsigned long tifn)
+ {
+ 	u64 msr = x86_spec_ctrl_base;
+ 	bool updmsr = false;
+ 
+ 	/* If TIF_SSBD is different, select the proper mitigation method */
+ 	if ((tifp ^ tifn) & _TIF_SSBD) {
+ 		if (static_cpu_has(X86_FEATURE_VIRT_SSBD)) {
+ 			amd_set_ssb_virt_state(tifn);
+ 		} else if (static_cpu_has(X86_FEATURE_LS_CFG_SSBD)) {
+ 			amd_set_core_ssb_state(tifn);
+ 		} else if (static_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD) ||
+ 			   static_cpu_has(X86_FEATURE_AMD_SSBD)) {
+ 			msr |= ssbd_tif_to_spec_ctrl(tifn);
+ 			updmsr  = true;
+ 		}
+ 	}
+ 
+ 	if (updmsr)
+ 		wrmsrl(MSR_IA32_SPEC_CTRL, msr);
++>>>>>>> 01daf56875ee (x86/speculation: Reorganize speculation control MSRs update)
  }
  
 -void speculation_ctrl_update(unsigned long tif)
 +void speculative_store_bypass_update(unsigned long tif)
  {
+ 	/* Forced update. Make sure all relevant TIF flags are different */
  	preempt_disable();
++<<<<<<< HEAD
 +	__speculative_store_bypass_update(tif);
++=======
+ 	__speculation_ctrl_update(~tif, tif);
++>>>>>>> 01daf56875ee (x86/speculation: Reorganize speculation control MSRs update)
  	preempt_enable();
  }
 +EXPORT_SYMBOL_GPL(speculative_store_bypass_update);
  
  void __switch_to_xtra(struct task_struct *prev_p, struct task_struct *next_p,
  		      struct tss_struct *tss)
@@@ -350,44 -441,30 +385,48 @@@
  	prev = &prev_p->thread;
  	next = &next_p->thread;
  
 -	tifn = READ_ONCE(task_thread_info(next_p)->flags);
 -	tifp = READ_ONCE(task_thread_info(prev_p)->flags);
 -	switch_to_bitmap(tss, prev, next, tifp, tifn);
 -
 -	propagate_user_return_notify(prev_p, next_p);
 -
 -	if ((tifp & _TIF_BLOCKSTEP || tifn & _TIF_BLOCKSTEP) &&
 -	    arch_has_block_step()) {
 -		unsigned long debugctl, msk;
 +	if (test_tsk_thread_flag(prev_p, TIF_BLOCKSTEP) ^
 +	    test_tsk_thread_flag(next_p, TIF_BLOCKSTEP)) {
 +		unsigned long debugctl = get_debugctlmsr();
  
 -		rdmsrl(MSR_IA32_DEBUGCTLMSR, debugctl);
  		debugctl &= ~DEBUGCTLMSR_BTF;
 -		msk = tifn & _TIF_BLOCKSTEP;
 -		debugctl |= (msk >> TIF_BLOCKSTEP) << DEBUGCTLMSR_BTF_SHIFT;
 -		wrmsrl(MSR_IA32_DEBUGCTLMSR, debugctl);
 +		if (test_tsk_thread_flag(next_p, TIF_BLOCKSTEP))
 +			debugctl |= DEBUGCTLMSR_BTF;
 +
 +		update_debugctlmsr(debugctl);
  	}
  
 -	if ((tifp ^ tifn) & _TIF_NOTSC)
 -		cr4_toggle_bits_irqsoff(X86_CR4_TSD);
 +	if (test_tsk_thread_flag(prev_p, TIF_NOTSC) ^
 +	    test_tsk_thread_flag(next_p, TIF_NOTSC)) {
 +		/* prev and next are different */
 +		if (test_tsk_thread_flag(next_p, TIF_NOTSC))
 +			hard_disable_TSC();
 +		else
 +			hard_enable_TSC();
 +	}
  
 -	if ((tifp ^ tifn) & _TIF_NOCPUID)
 -		set_cpuid_faulting(!!(tifn & _TIF_NOCPUID));
 +	if (test_tsk_thread_flag(next_p, TIF_IO_BITMAP)) {
 +		/*
 +		 * Copy the relevant range of the IO bitmap.
 +		 * Normally this is 128 bytes or less:
 +		 */
 +		memcpy(tss->io_bitmap, next->io_bitmap_ptr,
 +		       max(prev->io_bitmap_max, next->io_bitmap_max));
 +	} else if (test_tsk_thread_flag(prev_p, TIF_IO_BITMAP)) {
 +		/*
 +		 * Clear any possible leftover bits:
 +		 */
 +		memset(tss->io_bitmap, 0xff, prev->io_bitmap_max);
 +	}
 +	propagate_user_return_notify(prev_p, next_p);
  
++<<<<<<< HEAD
 +	if (test_tsk_thread_flag(prev_p, TIF_SSBD) ^
 +	    test_tsk_thread_flag(next_p, TIF_SSBD))
 +		__speculative_store_bypass_update(task_thread_info(next_p)->flags);
++=======
+ 	__speculation_ctrl_update(tifp, tifn);
++>>>>>>> 01daf56875ee (x86/speculation: Reorganize speculation control MSRs update)
  }
  
  /*
* Unmerged path arch/x86/kernel/process.c
