net/9p: Simplify ib_post_(send|recv|srq_recv)() calls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [net] 9p: Simplify ib_post_(send|recv|srq_recv)() calls (Kamal Heib) [1655920]
Rebuild_FUZZ: 96.08%
commit-author Bart Van Assche <bart.vanassche@wdc.com>
commit 72bc4d375d89d0ecb0df491c1eada201a995c471
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/72bc4d37.failed

Instead of declaring and passing a dummy 'bad_wr' pointer, pass NULL
as third argument to ib_post_(send|recv|srq_recv)().

	Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 72bc4d375d89d0ecb0df491c1eada201a995c471)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/9p/trans_rdma.c
diff --cc net/9p/trans_rdma.c
index 6e8d1607ab84,b06286f253cb..000000000000
--- a/net/9p/trans_rdma.c
+++ b/net/9p/trans_rdma.c
@@@ -395,16 -405,17 +395,16 @@@ post_recv(struct p9_client *client, str
  	if (ib_dma_mapping_error(rdma->cm_id->device, c->busa))
  		goto error;
  
 -	c->cqe.done = recv_done;
 -
  	sge.addr = c->busa;
  	sge.length = client->msize;
 -	sge.lkey = rdma->pd->local_dma_lkey;
 +	sge.lkey = rdma->lkey;
  
  	wr.next = NULL;
 -	wr.wr_cqe = &c->cqe;
 +	c->wc_op = IB_WC_RECV;
 +	wr.wr_id = (unsigned long) c;
  	wr.sg_list = &sge;
  	wr.num_sge = 1;
- 	return ib_post_recv(rdma->qp, &wr, &bad_wr);
+ 	return ib_post_recv(rdma->qp, &wr, NULL);
  
   error:
  	p9_debug(P9_DEBUG_ERROR, "EIO\n");
@@@ -491,22 -510,38 +491,33 @@@ static int rdma_request(struct p9_clien
  	wr.sg_list = &sge;
  	wr.num_sge = 1;
  
 -	if (down_interruptible(&rdma->sq_sem)) {
 -		err = -EINTR;
 -		goto send_error;
 -	}
 +	if (down_interruptible(&rdma->sq_sem))
 +		goto error;
  
++<<<<<<< HEAD
 +	return ib_post_send(rdma->qp, &wr, &bad_wr);
++=======
+ 	/* Mark request as `sent' *before* we actually send it,
+ 	 * because doing if after could erase the REQ_STATUS_RCVD
+ 	 * status in case of a very fast reply.
+ 	 */
+ 	req->status = REQ_STATUS_SENT;
+ 	err = ib_post_send(rdma->qp, &wr, NULL);
+ 	if (err)
+ 		goto send_error;
++>>>>>>> 72bc4d375d89 (net/9p: Simplify ib_post_(send|recv|srq_recv)() calls)
  
 -	/* Success */
 -	return 0;
 -
 - /* Handle errors that happened during or while preparing the send: */
 - send_error:
 -	req->status = REQ_STATUS_ERROR;
 + error:
  	kfree(c);
 -	p9_debug(P9_DEBUG_ERROR, "Error %d in rdma_request()\n", err);
 -
 -	/* Ach.
 -	 *  We did recv_post(), but not send. We have one recv_post in excess.
 -	 */
 -	atomic_inc(&rdma->excess_rc);
 -	return err;
 -
 - /* Handle errors that happened during or while preparing post_recv(): */
 - recv_error:
 +	kfree(rpl_context->rc);
  	kfree(rpl_context);
 +	p9_debug(P9_DEBUG_ERROR, "EIO\n");
 +	return -EIO;
 + err_free1:
 +	kfree(rpl_context->rc);
 + err_free2:
 +	kfree(rpl_context);
 + err_close:
  	spin_lock_irqsave(&rdma->req_lock, flags);
  	if (rdma->state < P9_RDMA_CLOSING) {
  		rdma->state = P9_RDMA_CLOSING;
* Unmerged path net/9p/trans_rdma.c
