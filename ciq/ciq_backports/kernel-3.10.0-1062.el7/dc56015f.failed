xfs: add a new xfs_iext_lookup_extent_before helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit dc56015faff1bc9e7493c2b28302c423a02237c2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/dc56015f.failed

This helper looks up the last extent the covers space before the passed
in block number.  This is useful for truncate and similar operations that
operate backwards over the extent list.  For xfs_bunmapi it also is
a slight optimization as we can return early if there are not extents
at or below the end of the to be truncated range.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit dc56015faff1bc9e7493c2b28302c423a02237c2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/xfs_reflink.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 905742f2f1f9,f45f05c45e15..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -5031,18 -5162,13 +5022,27 @@@ __xfs_bunmapi
  	}
  	XFS_STATS_INC(mp, xs_blk_unmap);
  	isrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);
++<<<<<<< HEAD
 +	start = bno;
 +	bno = start + len - 1;
 +
 +	/*
 +	 * Check to see if the given block number is past the end of the
 +	 * file, back up to the last block if so...
 +	 */
 +	if (!xfs_iext_lookup_extent(ip, ifp, bno, &lastx, &got)) {
 +		ASSERT(lastx > 0);
 +		xfs_iext_get_extent(ifp, --lastx, &got);
 +		bno = got.br_startoff + got.br_blockcount - 1;
++=======
+ 	end = start + len;
+ 
+ 	if (!xfs_iext_lookup_extent_before(ip, ifp, &end, &lastx, &got)) {
+ 		*rlen = 0;
+ 		return 0;
++>>>>>>> dc56015faff1 (xfs: add a new xfs_iext_lookup_extent_before helper)
  	}
+ 	end--;
  
  	logflags = 0;
  	if (ifp->if_flags & XFS_IFBROOT) {
* Unmerged path fs/xfs/xfs_reflink.c
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
diff --git a/fs/xfs/libxfs/xfs_inode_fork.c b/fs/xfs/libxfs/xfs_inode_fork.c
index f83028029221..aaf24d4fb575 100644
--- a/fs/xfs/libxfs/xfs_inode_fork.c
+++ b/fs/xfs/libxfs/xfs_inode_fork.c
@@ -1852,6 +1852,27 @@ xfs_iext_lookup_extent(
 	return true;
 }
 
+/*
+ * Returns the last extent before end, and if this extent doesn't cover
+ * end, update end to the end of the extent.
+ */
+bool
+xfs_iext_lookup_extent_before(
+	struct xfs_inode	*ip,
+	struct xfs_ifork	*ifp,
+	xfs_fileoff_t		*end,
+	xfs_extnum_t		*idxp,
+	struct xfs_bmbt_irec	*gotp)
+{
+	if (xfs_iext_lookup_extent(ip, ifp, *end - 1, idxp, gotp) &&
+	    gotp->br_startoff <= *end - 1)
+		return true;
+	if (!xfs_iext_get_extent(ifp, --*idxp, gotp))
+		return false;
+	*end = gotp->br_startoff + gotp->br_blockcount;
+	return true;
+}
+
 /*
  * Return true if there is an extent at index idx, and return the expanded
  * extent structure at idx in that case.  Else return false.
diff --git a/fs/xfs/libxfs/xfs_inode_fork.h b/fs/xfs/libxfs/xfs_inode_fork.h
index a53b7ced7b58..59a1219efed3 100644
--- a/fs/xfs/libxfs/xfs_inode_fork.h
+++ b/fs/xfs/libxfs/xfs_inode_fork.h
@@ -170,6 +170,10 @@ void		xfs_iext_irec_update_extoffs(struct xfs_ifork *, int, int);
 bool		xfs_iext_lookup_extent(struct xfs_inode *ip,
 			struct xfs_ifork *ifp, xfs_fileoff_t bno,
 			xfs_extnum_t *idxp, struct xfs_bmbt_irec *gotp);
+bool		xfs_iext_lookup_extent_before(struct xfs_inode *ip,
+			struct xfs_ifork *ifp, xfs_fileoff_t *end,
+			xfs_extnum_t *idxp, struct xfs_bmbt_irec *gotp);
+
 bool		xfs_iext_get_extent(struct xfs_ifork *ifp, xfs_extnum_t idx,
 			struct xfs_bmbt_irec *gotp);
 
* Unmerged path fs/xfs/xfs_reflink.c
