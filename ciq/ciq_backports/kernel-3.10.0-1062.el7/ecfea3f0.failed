xfs: split xfs_bmap_shift_extents

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit ecfea3f0c8c64ce7375f4be4506996968958bd01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ecfea3f0.failed

Have a separate helper for insert vs collapse, as this prepares us for
simplifying the code in the next patches.

Also changed the done output argument to a bool intead of int for both
new functions.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit ecfea3f0c8c64ce7375f4be4506996968958bd01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/libxfs/xfs_bmap.h
#	fs/xfs/xfs_bmap_util.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index a33b0b71527e,47fb51774fcc..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -5543,58 -5666,61 +5543,79 @@@ xfs_bmse_shift_one
  	 * Increment the extent index for the next iteration, update the start
  	 * offset of the in-core extent and update the btree if applicable.
  	 */
 -update_current_ext:
 +	(*current_ext)++;
 +	xfs_bmbt_set_startoff(gotp, startoff);
  	*logflags |= XFS_ILOG_CORE;
 -
 -	new = *got;
 -	new.br_startoff = startoff;
 -
 -	if (cur) {
 -		error = xfs_bmbt_lookup_eq(cur, got, &i);
 -		if (error)
 -			return error;
 -		XFS_WANT_CORRUPTED_RETURN(mp, i == 1);
 -
 -		error = xfs_bmbt_update(cur, &new);
 -		if (error)
 -			return error;
 -	} else {
 +	if (!cur) {
  		*logflags |= XFS_ILOG_DEXT;
 +		return 0;
  	}
  
 -	xfs_iext_update_extent(ip, xfs_bmap_fork_to_state(whichfork),
 -			*current_ext, &new);
 -
 -	if (direction == SHIFT_LEFT)
 -		(*current_ext)++;
 -	else
 -		(*current_ext)--;
 -
 -	/* update reverse mapping */
 -	error = xfs_rmap_unmap_extent(mp, dfops, ip, whichfork, got);
 +	error = xfs_bmbt_lookup_eq(cur, got.br_startoff, got.br_startblock,
 +				   got.br_blockcount, &i);
  	if (error)
  		return error;
 -	return xfs_rmap_map_extent(mp, dfops, ip, whichfork, &new);
 +	XFS_WANT_CORRUPTED_RETURN(mp, i == 1);
 +
 +	got.br_startoff = startoff;
 +	return xfs_bmbt_update(cur, got.br_startoff, got.br_startblock,
 +				got.br_blockcount, got.br_state);
  }
  
++<<<<<<< HEAD
 +/*
 + * Shift extent records to the left to cover a hole.
 + *
 + * The maximum number of extents to be shifted in a single operation is
 + * @num_exts. @start_fsb specifies the file offset to start the shift and the
 + * file offset where we've left off is returned in @next_fsb. @offset_shift_fsb
 + * is the length by which each extent is shifted. If there is no hole to shift
 + * the extents into, this will be considered invalid operation and we abort
 + * immediately.
 + */
++=======
++>>>>>>> ecfea3f0c8c6 (xfs: split xfs_bmap_shift_extents)
  int
- xfs_bmap_shift_extents(
+ xfs_bmap_collapse_extents(
  	struct xfs_trans	*tp,
  	struct xfs_inode	*ip,
 -	xfs_fileoff_t		*next_fsb,
 +	xfs_fileoff_t		start_fsb,
  	xfs_fileoff_t		offset_shift_fsb,
++<<<<<<< HEAD
 +	int			*done,
 +	xfs_fileoff_t		*next_fsb,
 +	xfs_fsblock_t		*firstblock,
 +	struct xfs_defer_ops	*dfops,
 +	int			num_exts)
 +{
 +	struct xfs_btree_cur		*cur = NULL;
 +	struct xfs_bmbt_rec_host	*gotp;
 +	struct xfs_bmbt_irec            got;
 +	struct xfs_mount		*mp = ip->i_mount;
 +	struct xfs_ifork		*ifp;
 +	xfs_extnum_t			nexts = 0;
 +	xfs_extnum_t			current_ext;
 +	int				error = 0;
 +	int				whichfork = XFS_DATA_FORK;
 +	int				logflags = 0;
 +	int				total_extents;
++=======
+ 	bool			*done,
+ 	xfs_fileoff_t		stop_fsb,
+ 	xfs_fsblock_t		*firstblock,
+ 	struct xfs_defer_ops	*dfops)
+ {
+ 	int			whichfork = XFS_DATA_FORK;
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	struct xfs_btree_cur	*cur = NULL;
+ 	struct xfs_bmbt_irec	got;
+ 	xfs_extnum_t		current_ext;
+ 	xfs_extnum_t		total_extents;
+ 	xfs_extnum_t		stop_extent;
+ 	int			error = 0;
+ 	int			logflags = 0;
++>>>>>>> ecfea3f0c8c6 (xfs: split xfs_bmap_shift_extents)
  
  	if (unlikely(XFS_TEST_ERROR(
  	    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
@@@ -5608,12 -5733,9 +5628,14 @@@
  	if (XFS_FORCED_SHUTDOWN(mp))
  		return -EIO;
  
++<<<<<<< HEAD
 +	ASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));
 +	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));
++=======
+ 	ASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL | XFS_ILOCK_EXCL));
++>>>>>>> ecfea3f0c8c6 (xfs: split xfs_bmap_shift_extents)
  
- 	ifp = XFS_IFORK_PTR(ip, whichfork);
  	if (!(ifp->if_flags & XFS_IFEXTENTS)) {
- 		/* Read in all the extents */
  		error = xfs_iread_extents(tp, ip, whichfork);
  		if (error)
  			return error;
@@@ -5647,26 -5754,168 +5669,187 @@@
  	 * Instead we have to calculate it from the incore fork.
  	 */
  	total_extents = xfs_iext_count(ifp);
++<<<<<<< HEAD
 +	while (nexts++ < num_exts && current_ext < total_extents) {
 +		error = xfs_bmse_shift_one(ip, whichfork, offset_shift_fsb,
 +					&current_ext, gotp, cur, &logflags);
 +		if (error)
 +			goto del_cursor;
 +
 +		/* update total extent count and grab the next record */
 +		total_extents = xfs_iext_count(ifp);
 +		if (current_ext >= total_extents)
 +			break;
 +		gotp = xfs_iext_get_ext(ifp, current_ext);
 +	}
 +
 +	/* Check if we are done */
 +	if (current_ext == total_extents) {
 +		*done = 1;
 +	} else if (next_fsb) {
 +		xfs_bmbt_get_all(gotp, &got);
 +		*next_fsb = got.br_startoff;
++=======
+ 	if (total_extents == 0) {
+ 		*done = true;
+ 		goto del_cursor;
+ 	}
+ 
+ 	/*
+ 	 * Look up the extent index for the fsb where we start shifting. We can
+ 	 * henceforth iterate with current_ext as extent list changes are locked
+ 	 * out via ilock.
+ 	 *
+ 	 * If next_fsb lies in a hole beyond which there are no extents we are
+ 	 * done.
+ 	 */
+ 	if (!xfs_iext_lookup_extent(ip, ifp, *next_fsb, &current_ext, &got)) {
+ 		*done = true;
+ 		goto del_cursor;
+ 	}
+ 
+ 	stop_extent = total_extents;
+ 	if (current_ext >= stop_extent) {
+ 		error = -EIO;
+ 		goto del_cursor;
+ 	}
+ 
+ 	error = xfs_bmse_shift_one(ip, whichfork, offset_shift_fsb,
+ 				   &current_ext, &got, cur, &logflags,
+ 				   SHIFT_LEFT, dfops);
+ 	if (error)
+ 		goto del_cursor;
+ 	/*
+ 	 * If there was an extent merge during the shift, the extent
+ 	 * count can change. Update the total and grade the next record.
+ 	 */
+ 	total_extents = xfs_iext_count(ifp);
+ 	stop_extent = total_extents;
+ 	if (current_ext == stop_extent) {
+ 		*done = true;
+ 		goto del_cursor;
+ 	}
+ 	xfs_iext_get_extent(ifp, current_ext, &got);
+ 
+ 	if (!*done)
+ 		*next_fsb = got.br_startoff;
+ 
+ del_cursor:
+ 	if (cur)
+ 		xfs_btree_del_cursor(cur,
+ 			error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);
+ 
+ 	if (logflags)
+ 		xfs_trans_log_inode(tp, ip, logflags);
+ 
+ 	return error;
+ }
+ 
+ int
+ xfs_bmap_insert_extents(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*ip,
+ 	xfs_fileoff_t		*next_fsb,
+ 	xfs_fileoff_t		offset_shift_fsb,
+ 	bool			*done,
+ 	xfs_fileoff_t		stop_fsb,
+ 	xfs_fsblock_t		*firstblock,
+ 	struct xfs_defer_ops	*dfops)
+ {
+ 	int			whichfork = XFS_DATA_FORK;
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	struct xfs_btree_cur	*cur = NULL;
+ 	struct xfs_bmbt_irec	got, s;
+ 	xfs_extnum_t		current_ext;
+ 	xfs_extnum_t		total_extents;
+ 	xfs_extnum_t		stop_extent;
+ 	int			error = 0;
+ 	int			logflags = 0;
+ 
+ 	if (unlikely(XFS_TEST_ERROR(
+ 	    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
+ 	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
+ 	     mp, XFS_ERRTAG_BMAPIFORMAT))) {
+ 		XFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
+ 
+ 	ASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL | XFS_ILOCK_EXCL));
+ 
+ 	if (!(ifp->if_flags & XFS_IFEXTENTS)) {
+ 		error = xfs_iread_extents(tp, ip, whichfork);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	if (ifp->if_flags & XFS_IFBROOT) {
+ 		cur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);
+ 		cur->bc_private.b.firstblock = *firstblock;
+ 		cur->bc_private.b.dfops = dfops;
+ 		cur->bc_private.b.flags = 0;
+ 	}
+ 
+ 	/*
+ 	 * There may be delalloc extents in the data fork before the range we
+ 	 * are collapsing out, so we cannot use the count of real extents here.
+ 	 * Instead we have to calculate it from the incore fork.
+ 	 */
+ 	total_extents = xfs_iext_count(ifp);
+ 	if (total_extents == 0) {
+ 		*done = true;
+ 		goto del_cursor;
+ 	}
+ 
+ 	/*
+ 	 * In case of first right shift, we need to initialize next_fsb
+ 	 */
+ 	if (*next_fsb == NULLFSBLOCK) {
+ 		current_ext = total_extents - 1;
+ 		xfs_iext_get_extent(ifp, current_ext, &got);
+ 		if (stop_fsb > got.br_startoff) {
+ 			*done = true;
+ 			goto del_cursor;
+ 		}
+ 		*next_fsb = got.br_startoff;
+ 	} else {
+ 		/*
+ 		 * Look up the extent index for the fsb where we start shifting. We can
+ 		 * henceforth iterate with current_ext as extent list changes are locked
+ 		 * out via ilock.
+ 		 *
+ 		 * If next_fsb lies in a hole beyond which there are no extents we are
+ 		 * done.
+ 		 */
+ 		if (!xfs_iext_lookup_extent(ip, ifp, *next_fsb, &current_ext,
+ 				&got)) {
+ 			*done = true;
+ 			goto del_cursor;
+ 		}
+ 	}
+ 
+ 	/* Lookup the extent index at which we have to stop */
+ 	xfs_iext_lookup_extent(ip, ifp, stop_fsb, &stop_extent, &s);
+ 	/* Make stop_extent exclusive of shift range */
+ 	stop_extent--;
+ 	if (current_ext <= stop_extent) {
+ 		error = -EIO;
+ 		goto del_cursor;
+ 	}
+ 
+ 	error = xfs_bmse_shift_one(ip, whichfork, offset_shift_fsb,
+ 				   &current_ext, &got, cur, &logflags,
+ 				   SHIFT_RIGHT, dfops);
+ 	if (error)
+ 		goto del_cursor;
+ 	if (current_ext == stop_extent) {
+ 		*done = true;
+ 		goto del_cursor;
++>>>>>>> ecfea3f0c8c6 (xfs: split xfs_bmap_shift_extents)
  	}
 -	xfs_iext_get_extent(ifp, current_ext, &got);
 -
 -	*next_fsb = got.br_startoff;
  
  del_cursor:
  	if (cur)
diff --cc fs/xfs/libxfs/xfs_bmap.h
index bbb72c6ceb86,ca37030f4cfb..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.h
+++ b/fs/xfs/libxfs/xfs_bmap.h
@@@ -194,13 -222,57 +194,27 @@@ int	xfs_bunmapi(struct xfs_trans *tp, s
  		xfs_fileoff_t bno, xfs_filblks_t len, int flags,
  		xfs_extnum_t nexts, xfs_fsblock_t *firstblock,
  		struct xfs_defer_ops *dfops, int *done);
 -int	xfs_bmap_del_extent_delay(struct xfs_inode *ip, int whichfork,
 -		xfs_extnum_t *idx, struct xfs_bmbt_irec *got,
 -		struct xfs_bmbt_irec *del);
 -void	xfs_bmap_del_extent_cow(struct xfs_inode *ip, xfs_extnum_t *idx,
 -		struct xfs_bmbt_irec *got, struct xfs_bmbt_irec *del);
  uint	xfs_default_attroffset(struct xfs_inode *ip);
++<<<<<<< HEAD
 +int	xfs_bmap_shift_extents(struct xfs_trans *tp, struct xfs_inode *ip,
 +		xfs_fileoff_t start_fsb, xfs_fileoff_t offset_shift_fsb,
 +		int *done, xfs_fileoff_t *next_fsb, xfs_fsblock_t *firstblock,
 +		struct xfs_defer_ops *dfops, int num_exts);
 +int	xfs_bmapi_reserve_delalloc(struct xfs_inode *ip, xfs_fileoff_t off,
 +		xfs_filblks_t len, xfs_filblks_t prealloc,
++=======
+ int	xfs_bmap_collapse_extents(struct xfs_trans *tp, struct xfs_inode *ip,
+ 		xfs_fileoff_t *next_fsb, xfs_fileoff_t offset_shift_fsb,
+ 		bool *done, xfs_fileoff_t stop_fsb, xfs_fsblock_t *firstblock,
+ 		struct xfs_defer_ops *dfops);
+ int	xfs_bmap_insert_extents(struct xfs_trans *tp, struct xfs_inode *ip,
+ 		xfs_fileoff_t *next_fsb, xfs_fileoff_t offset_shift_fsb,
+ 		bool *done, xfs_fileoff_t stop_fsb, xfs_fsblock_t *firstblock,
+ 		struct xfs_defer_ops *dfops);
+ int	xfs_bmap_split_extent(struct xfs_inode *ip, xfs_fileoff_t split_offset);
+ int	xfs_bmapi_reserve_delalloc(struct xfs_inode *ip, int whichfork,
+ 		xfs_fileoff_t off, xfs_filblks_t len, xfs_filblks_t prealloc,
++>>>>>>> ecfea3f0c8c6 (xfs: split xfs_bmap_shift_extents)
  		struct xfs_bmbt_irec *got, xfs_extnum_t *lastx, int eof);
  
 -enum xfs_bmap_intent_type {
 -	XFS_BMAP_MAP = 1,
 -	XFS_BMAP_UNMAP,
 -};
 -
 -struct xfs_bmap_intent {
 -	struct list_head			bi_list;
 -	enum xfs_bmap_intent_type		bi_type;
 -	struct xfs_inode			*bi_owner;
 -	int					bi_whichfork;
 -	struct xfs_bmbt_irec			bi_bmap;
 -};
 -
 -int	xfs_bmap_finish_one(struct xfs_trans *tp, struct xfs_defer_ops *dfops,
 -		struct xfs_inode *ip, enum xfs_bmap_intent_type type,
 -		int whichfork, xfs_fileoff_t startoff, xfs_fsblock_t startblock,
 -		xfs_filblks_t *blockcount, xfs_exntst_t state);
 -int	xfs_bmap_map_extent(struct xfs_mount *mp, struct xfs_defer_ops *dfops,
 -		struct xfs_inode *ip, struct xfs_bmbt_irec *imap);
 -int	xfs_bmap_unmap_extent(struct xfs_mount *mp, struct xfs_defer_ops *dfops,
 -		struct xfs_inode *ip, struct xfs_bmbt_irec *imap);
 -
 -static inline int xfs_bmap_fork_to_state(int whichfork)
 -{
 -	switch (whichfork) {
 -	case XFS_ATTR_FORK:
 -		return BMAP_ATTRFORK;
 -	case XFS_COW_FORK:
 -		return BMAP_COWFORK;
 -	default:
 -		return 0;
 -	}
 -}
 -
  #endif	/* __XFS_BMAP_H__ */
diff --cc fs/xfs/xfs_bmap_util.c
index ad7a1ab465c3,034f3429ca8c..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -1271,17 -1327,15 +1270,25 @@@ xfs_collapse_file_space
  	int			error;
  	struct xfs_defer_ops	dfops;
  	xfs_fsblock_t		first_block;
++<<<<<<< HEAD
 +	xfs_fileoff_t		start_fsb;
 +	xfs_fileoff_t		next_fsb;
 +	xfs_fileoff_t		shift_fsb;
++=======
+ 	xfs_fileoff_t		stop_fsb = XFS_B_TO_FSB(mp, VFS_I(ip)->i_size);
+ 	xfs_fileoff_t		next_fsb = XFS_B_TO_FSB(mp, offset + len);
+ 	xfs_fileoff_t		shift_fsb = XFS_B_TO_FSB(mp, len);
+ 	uint			resblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);
+ 	bool			done = false;
++>>>>>>> ecfea3f0c8c6 (xfs: split xfs_bmap_shift_extents)
  
  	ASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));
 +
  	trace_xfs_collapse_file_space(ip);
  
 +	next_fsb = XFS_B_TO_FSB(mp, offset + len);
 +	shift_fsb = XFS_B_TO_FSB(mp, len);
 +
  	error = xfs_free_file_space(ip, offset, len);
  	if (error)
  		return error;
@@@ -1331,19 -1356,11 +1338,24 @@@
  				XFS_QMOPT_RES_REGBLKS);
  		if (error)
  			goto out_trans_cancel;
 -		xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
 +
 +		xfs_trans_ijoin(tp, ip, 0);
  
  		xfs_defer_init(&dfops, &first_block);
++<<<<<<< HEAD
 +
 +		/*
 +		 * We are using the write transaction in which max 2 bmbt
 +		 * updates are allowed
 +		 */
 +		start_fsb = next_fsb;
 +		error = xfs_bmap_shift_extents(tp, ip, start_fsb, shift_fsb,
 +				&done, &next_fsb, &first_block, &dfops,
 +				XFS_BMAP_MAX_SHIFT_EXTENTS);
++=======
+ 		error = xfs_bmap_collapse_extents(tp, ip, &next_fsb, shift_fsb,
+ 				&done, stop_fsb, &first_block, &dfops);
++>>>>>>> ecfea3f0c8c6 (xfs: split xfs_bmap_shift_extents)
  		if (error)
  			goto out_bmap_cancel;
  
@@@ -1361,7 -1376,78 +1373,82 @@@ out_bmap_cancel
  	xfs_defer_cancel(&dfops);
  out_trans_cancel:
  	xfs_trans_cancel(tp);
++<<<<<<< HEAD
 +	xfs_iunlock(ip, XFS_ILOCK_EXCL);
++=======
+ 	return error;
+ }
+ 
+ /*
+  * xfs_insert_file_space()
+  *	This routine create hole space by shifting extents for the given file.
+  *	The first thing we do is to sync dirty data and invalidate page cache
+  *	over the region on which insert range is working. And split an extent
+  *	to two extents at given offset by calling xfs_bmap_split_extent.
+  *	And shift all extent records which are laying between [offset,
+  *	last allocated extent] to the right to reserve hole range.
+  * RETURNS:
+  *	0 on success
+  *	errno on error
+  */
+ int
+ xfs_insert_file_space(
+ 	struct xfs_inode	*ip,
+ 	loff_t			offset,
+ 	loff_t			len)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_trans	*tp;
+ 	int			error;
+ 	struct xfs_defer_ops	dfops;
+ 	xfs_fsblock_t		first_block;
+ 	xfs_fileoff_t		stop_fsb = XFS_B_TO_FSB(mp, offset);
+ 	xfs_fileoff_t		next_fsb = NULLFSBLOCK;
+ 	xfs_fileoff_t		shift_fsb = XFS_B_TO_FSB(mp, len);
+ 	bool			done = false;
+ 
+ 	ASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));
+ 	trace_xfs_insert_file_space(ip);
+ 
+ 	error = xfs_prepare_shift(ip, offset);
+ 	if (error)
+ 		return error;
+ 
+ 	/*
+ 	 * The extent shifting code works on extent granularity. So, if stop_fsb
+ 	 * is not the starting block of extent, we need to split the extent at
+ 	 * stop_fsb.
+ 	 */
+ 	error = xfs_bmap_split_extent(ip, stop_fsb);
+ 	if (error)
+ 		return error;
+ 
+ 	while (!error && !done) {
+ 		error = xfs_trans_alloc(mp, &M_RES(mp)->tr_write, 0, 0, 0,
+ 					&tp);
+ 		if (error)
+ 			break;
+ 
+ 		xfs_ilock(ip, XFS_ILOCK_EXCL);
+ 		xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
+ 		xfs_defer_init(&dfops, &first_block);
+ 		error = xfs_bmap_insert_extents(tp, ip, &next_fsb, shift_fsb,
+ 				&done, stop_fsb, &first_block, &dfops);
+ 		if (error)
+ 			goto out_bmap_cancel;
+ 
+ 		error = xfs_defer_finish(&tp, &dfops);
+ 		if (error)
+ 			goto out_bmap_cancel;
+ 		error = xfs_trans_commit(tp);
+ 	}
+ 
+ 	return error;
+ 
+ out_bmap_cancel:
+ 	xfs_defer_cancel(&dfops);
+ 	xfs_trans_cancel(tp);
++>>>>>>> ecfea3f0c8c6 (xfs: split xfs_bmap_shift_extents)
  	return error;
  }
  
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
* Unmerged path fs/xfs/libxfs/xfs_bmap.h
* Unmerged path fs/xfs/xfs_bmap_util.c
