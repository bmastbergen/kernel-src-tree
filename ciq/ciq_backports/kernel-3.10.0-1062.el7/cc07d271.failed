r8169: add EEE support for RTL8168f

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Heiner Kallweit <hkallweit1@gmail.com>
commit cc07d2714a846457bec930c88da814a19deeecfc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/cc07d271.failed

Add EEE support for RTL8168f to the recently added EEE handling
framework in the driver. This patch leaves the chip defaults, means
EEE typically is disabled initially and it's up to the user to enable
it via ethtool.

	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cc07d2714a846457bec930c88da814a19deeecfc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/realtek/r8169.c
diff --cc drivers/net/ethernet/realtek/r8169.c
index f80daa5053d5,4572de1703b8..000000000000
--- a/drivers/net/ethernet/realtek/r8169.c
+++ b/drivers/net/ethernet/realtek/r8169.c
@@@ -2193,6 -1984,196 +2193,199 @@@ static int rtl_set_coalesce(struct net_
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int rtl_get_eee_supp(struct rtl8169_private *tp)
+ {
+ 	struct phy_device *phydev = tp->phydev;
+ 	int ret;
+ 
+ 	switch (tp->mac_version) {
+ 	case RTL_GIGA_MAC_VER_34:
+ 	case RTL_GIGA_MAC_VER_35:
+ 	case RTL_GIGA_MAC_VER_36:
+ 	case RTL_GIGA_MAC_VER_38:
+ 		ret = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);
+ 		break;
+ 	case RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_51:
+ 		phy_write(phydev, 0x1f, 0x0a5c);
+ 		ret = phy_read(phydev, 0x12);
+ 		phy_write(phydev, 0x1f, 0x0000);
+ 		break;
+ 	default:
+ 		ret = -EPROTONOSUPPORT;
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int rtl_get_eee_lpadv(struct rtl8169_private *tp)
+ {
+ 	struct phy_device *phydev = tp->phydev;
+ 	int ret;
+ 
+ 	switch (tp->mac_version) {
+ 	case RTL_GIGA_MAC_VER_34:
+ 	case RTL_GIGA_MAC_VER_35:
+ 	case RTL_GIGA_MAC_VER_36:
+ 	case RTL_GIGA_MAC_VER_38:
+ 		ret = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_LPABLE);
+ 		break;
+ 	case RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_51:
+ 		phy_write(phydev, 0x1f, 0x0a5d);
+ 		ret = phy_read(phydev, 0x11);
+ 		phy_write(phydev, 0x1f, 0x0000);
+ 		break;
+ 	default:
+ 		ret = -EPROTONOSUPPORT;
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int rtl_get_eee_adv(struct rtl8169_private *tp)
+ {
+ 	struct phy_device *phydev = tp->phydev;
+ 	int ret;
+ 
+ 	switch (tp->mac_version) {
+ 	case RTL_GIGA_MAC_VER_34:
+ 	case RTL_GIGA_MAC_VER_35:
+ 	case RTL_GIGA_MAC_VER_36:
+ 	case RTL_GIGA_MAC_VER_38:
+ 		ret = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV);
+ 		break;
+ 	case RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_51:
+ 		phy_write(phydev, 0x1f, 0x0a5d);
+ 		ret = phy_read(phydev, 0x10);
+ 		phy_write(phydev, 0x1f, 0x0000);
+ 		break;
+ 	default:
+ 		ret = -EPROTONOSUPPORT;
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int rtl_set_eee_adv(struct rtl8169_private *tp, int val)
+ {
+ 	struct phy_device *phydev = tp->phydev;
+ 	int ret = 0;
+ 
+ 	switch (tp->mac_version) {
+ 	case RTL_GIGA_MAC_VER_34:
+ 	case RTL_GIGA_MAC_VER_35:
+ 	case RTL_GIGA_MAC_VER_36:
+ 	case RTL_GIGA_MAC_VER_38:
+ 		ret = phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV, val);
+ 		break;
+ 	case RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_51:
+ 		phy_write(phydev, 0x1f, 0x0a5d);
+ 		phy_write(phydev, 0x10, val);
+ 		phy_write(phydev, 0x1f, 0x0000);
+ 		break;
+ 	default:
+ 		ret = -EPROTONOSUPPORT;
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int rtl8169_get_eee(struct net_device *dev, struct ethtool_eee *data)
+ {
+ 	struct rtl8169_private *tp = netdev_priv(dev);
+ 	struct device *d = tp_to_dev(tp);
+ 	int ret;
+ 
+ 	pm_runtime_get_noresume(d);
+ 
+ 	if (!pm_runtime_active(d)) {
+ 		ret = -EOPNOTSUPP;
+ 		goto out;
+ 	}
+ 
+ 	/* Get Supported EEE */
+ 	ret = rtl_get_eee_supp(tp);
+ 	if (ret < 0)
+ 		goto out;
+ 	data->supported = mmd_eee_cap_to_ethtool_sup_t(ret);
+ 
+ 	/* Get advertisement EEE */
+ 	ret = rtl_get_eee_adv(tp);
+ 	if (ret < 0)
+ 		goto out;
+ 	data->advertised = mmd_eee_adv_to_ethtool_adv_t(ret);
+ 	data->eee_enabled = !!data->advertised;
+ 
+ 	/* Get LP advertisement EEE */
+ 	ret = rtl_get_eee_lpadv(tp);
+ 	if (ret < 0)
+ 		goto out;
+ 	data->lp_advertised = mmd_eee_adv_to_ethtool_adv_t(ret);
+ 	data->eee_active = !!(data->advertised & data->lp_advertised);
+ out:
+ 	pm_runtime_put_noidle(d);
+ 	return ret < 0 ? ret : 0;
+ }
+ 
+ static int rtl8169_set_eee(struct net_device *dev, struct ethtool_eee *data)
+ {
+ 	struct rtl8169_private *tp = netdev_priv(dev);
+ 	struct device *d = tp_to_dev(tp);
+ 	int old_adv, adv = 0, cap, ret;
+ 
+ 	pm_runtime_get_noresume(d);
+ 
+ 	if (!dev->phydev || !pm_runtime_active(d)) {
+ 		ret = -EOPNOTSUPP;
+ 		goto out;
+ 	}
+ 
+ 	if (dev->phydev->autoneg == AUTONEG_DISABLE ||
+ 	    dev->phydev->duplex != DUPLEX_FULL) {
+ 		ret = -EPROTONOSUPPORT;
+ 		goto out;
+ 	}
+ 
+ 	/* Get Supported EEE */
+ 	ret = rtl_get_eee_supp(tp);
+ 	if (ret < 0)
+ 		goto out;
+ 	cap = ret;
+ 
+ 	ret = rtl_get_eee_adv(tp);
+ 	if (ret < 0)
+ 		goto out;
+ 	old_adv = ret;
+ 
+ 	if (data->eee_enabled) {
+ 		adv = !data->advertised ? cap :
+ 		      ethtool_adv_to_mmd_eee_adv_t(data->advertised) & cap;
+ 		/* Mask prohibited EEE modes */
+ 		adv &= ~dev->phydev->eee_broken_modes;
+ 	}
+ 
+ 	if (old_adv != adv) {
+ 		ret = rtl_set_eee_adv(tp, adv);
+ 		if (ret < 0)
+ 			goto out;
+ 
+ 		/* Restart autonegotiation so the new modes get sent to the
+ 		 * link partner.
+ 		 */
+ 		ret = phy_restart_aneg(dev->phydev);
+ 	}
+ 
+ out:
+ 	pm_runtime_put_noidle(d);
+ 	return ret < 0 ? ret : 0;
+ }
+ 
++>>>>>>> cc07d2714a84 (r8169: add EEE support for RTL8168f)
  static const struct ethtool_ops rtl8169_ethtool_ops = {
  	.get_drvinfo		= rtl8169_get_drvinfo,
  	.get_regs_len		= rtl8169_get_regs_len,
@@@ -2607,6 -2593,33 +2800,36 @@@ static void rtl_apply_firmware_cond(str
  		rtl_apply_firmware(tp);
  }
  
++<<<<<<< HEAD
++=======
+ static void rtl8168_config_eee_mac(struct rtl8169_private *tp)
+ {
+ 	rtl_w0w1_eri(tp, 0x1b0, ERIAR_MASK_1111, 0x0003, 0x0000, ERIAR_EXGMAC);
+ }
+ 
+ static void rtl8168f_config_eee_phy(struct rtl8169_private *tp)
+ {
+ 	struct phy_device *phydev = tp->phydev;
+ 
+ 	phy_write(phydev, 0x1f, 0x0007);
+ 	phy_write(phydev, 0x1e, 0x0020);
+ 	phy_set_bits(phydev, 0x15, BIT(8));
+ 
+ 	phy_write(phydev, 0x1f, 0x0005);
+ 	phy_write(phydev, 0x05, 0x8b85);
+ 	phy_set_bits(phydev, 0x06, BIT(13));
+ 
+ 	phy_write(phydev, 0x1f, 0x0000);
+ }
+ 
+ static void rtl8168g_config_eee_phy(struct rtl8169_private *tp)
+ {
+ 	phy_write(tp->phydev, 0x1f, 0x0a43);
+ 	phy_set_bits(tp->phydev, 0x11, BIT(4));
+ 	phy_write(tp->phydev, 0x1f, 0x0000);
+ }
+ 
++>>>>>>> cc07d2714a84 (r8169: add EEE support for RTL8168f)
  static void rtl8169s_hw_phy_config(struct rtl8169_private *tp)
  {
  	static const struct phy_reg phy_reg_init[] = {
* Unmerged path drivers/net/ethernet/realtek/r8169.c
