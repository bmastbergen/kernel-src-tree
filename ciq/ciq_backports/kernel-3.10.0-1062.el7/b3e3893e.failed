net: use core MTU range checking in misc drivers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [infiniband] use core MTU range checking in misc drivers (Kamal Heib) [1655920]
Rebuild_FUZZ: 94.51%
commit-author Jarod Wilson <jarod@redhat.com>
commit b3e3893e1253692c3d2b8e8ebd5a26183ed30443
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/b3e3893e.failed

firewire-net:
- set min/max_mtu
- remove fwnet_change_mtu

nes:
- set max_mtu
- clean up nes_netdev_change_mtu

xpnet:
- set min/max_mtu
- remove xpnet_dev_change_mtu

hippi:
- set min/max_mtu
- remove hippi_change_mtu

batman-adv:
- set max_mtu
- remove batadv_interface_change_mtu
- initialization is a little async, not 100% certain that max_mtu is set
  in the optimal place, don't have hardware to test with

rionet:
- set min/max_mtu
- remove rionet_change_mtu

slip:
- set min/max_mtu
- streamline sl_change_mtu

um/net_kern:
- remove pointless ndo_change_mtu

hsi/clients/ssi_protocol:
- use core MTU range checking
- remove now redundant ssip_pn_set_mtu

ipoib:
- set a default max MTU value
- Note: ipoib's actual max MTU can vary, depending on if the device is in
  connected mode or not, so we'll just set the max_mtu value to the max
  possible, and let the ndo_change_mtu function continue to validate any new
  MTU change requests with checks for CM or not. Note that ipoib has no
  min_mtu set, and thus, the network core's mtu > 0 check is the only lower
  bounds here.

mptlan:
- use net core MTU range checking
- remove now redundant mpt_lan_change_mtu

fddi:
- min_mtu = 21, max_mtu = 4470
- remove now redundant fddi_change_mtu (including export)

fjes:
- min_mtu = 8192, max_mtu = 65536
- The max_mtu value is actually one over IP_MAX_MTU here, but the idea is to
  get past the core net MTU range checks so fjes_change_mtu can validate a
  new MTU against what it supports (see fjes_support_mtu in fjes_hw.c)

hsr:
- min_mtu = 0 (calls ether_setup, max_mtu is 1500)

f_phonet:
- min_mtu = 6, max_mtu = 65541

u_ether:
- min_mtu = 14, max_mtu = 15412

phonet/pep-gprs:
- min_mtu = 576, max_mtu = 65530
- remove redundant gprs_set_mtu

CC: netdev@vger.kernel.org
CC: linux-rdma@vger.kernel.org
CC: Stefan Richter <stefanr@s5r6.in-berlin.de>
CC: Faisal Latif <faisal.latif@intel.com>
CC: linux-rdma@vger.kernel.org
CC: Cliff Whickman <cpw@sgi.com>
CC: Robin Holt <robinmholt@gmail.com>
CC: Jes Sorensen <jes@trained-monkey.org>
CC: Marek Lindner <mareklindner@neomailbox.ch>
CC: Simon Wunderlich <sw@simonwunderlich.de>
CC: Antonio Quartulli <a@unstable.cc>
CC: Sathya Prakash <sathya.prakash@broadcom.com>
CC: Chaitra P B <chaitra.basappa@broadcom.com>
CC: Suganath Prabu Subramani <suganath-prabu.subramani@broadcom.com>
CC: MPT-FusionLinux.pdl@broadcom.com
CC: Sebastian Reichel <sre@kernel.org>
CC: Felipe Balbi <balbi@kernel.org>
CC: Arvid Brodin <arvid.brodin@alten.se>
CC: Remi Denis-Courmont <courmisch@gmail.com>
	Signed-off-by: Jarod Wilson <jarod@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b3e3893e1253692c3d2b8e8ebd5a26183ed30443)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firewire/net.c
#	drivers/hsi/clients/ssi_protocol.c
#	drivers/misc/sgi-xp/xpnet.c
#	drivers/net/rionet.c
#	drivers/usb/gadget/u_ether.c
#	net/batman-adv/soft-interface.c
#	net/hsr/hsr_device.c
diff --cc drivers/firewire/net.c
index 9dd4573c4f95,8430222151fc..000000000000
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@@ -1398,7 -1357,6 +1389,10 @@@ static const struct net_device_ops fwne
  	.ndo_open       = fwnet_open,
  	.ndo_stop	= fwnet_stop,
  	.ndo_start_xmit = fwnet_tx,
++<<<<<<< HEAD
 +	.ndo_change_mtu_rh74 = fwnet_change_mtu,
++=======
++>>>>>>> b3e3893e1253 (net: use core MTU range checking in misc drivers)
  };
  
  static void fwnet_init_dev(struct net_device *net)
diff --cc drivers/misc/sgi-xp/xpnet.c
index f5416637838e,0c26eaf5f62b..000000000000
--- a/drivers/misc/sgi-xp/xpnet.c
+++ b/drivers/misc/sgi-xp/xpnet.c
@@@ -519,7 -505,6 +505,10 @@@ static const struct net_device_ops xpne
  	.ndo_open		= xpnet_dev_open,
  	.ndo_stop		= xpnet_dev_stop,
  	.ndo_start_xmit		= xpnet_dev_hard_start_xmit,
++<<<<<<< HEAD
 +	.ndo_change_mtu_rh74	= xpnet_dev_change_mtu,
++=======
++>>>>>>> b3e3893e1253 (net: use core MTU range checking in misc drivers)
  	.ndo_tx_timeout		= xpnet_dev_tx_timeout,
  	.ndo_set_mac_address 	= eth_mac_addr,
  	.ndo_validate_addr	= eth_validate_addr,
diff --cc drivers/net/rionet.c
index f433b594388e,300bb1479b3a..000000000000
--- a/drivers/net/rionet.c
+++ b/drivers/net/rionet.c
@@@ -441,7 -477,6 +441,10 @@@ static const struct net_device_ops rion
  	.ndo_open		= rionet_open,
  	.ndo_stop		= rionet_close,
  	.ndo_start_xmit		= rionet_start_xmit,
++<<<<<<< HEAD
 +	.ndo_change_mtu		= eth_change_mtu,
++=======
++>>>>>>> b3e3893e1253 (net: use core MTU range checking in misc drivers)
  	.ndo_validate_addr	= eth_validate_addr,
  	.ndo_set_mac_address	= eth_mac_addr,
  };
@@@ -476,9 -512,13 +479,16 @@@ static int rionet_setup_netdev(struct r
  	ndev->dev_addr[5] = device_id & 0xff;
  
  	ndev->netdev_ops = &rionet_netdev_ops;
++<<<<<<< HEAD
 +	ndev->mtu = RIO_MAX_MSG_SIZE - 14;
++=======
+ 	ndev->mtu = RIONET_MAX_MTU;
+ 	/* MTU range: 68 - 4082 */
+ 	ndev->min_mtu = ETH_MIN_MTU;
+ 	ndev->max_mtu = RIONET_MAX_MTU;
++>>>>>>> b3e3893e1253 (net: use core MTU range checking in misc drivers)
  	ndev->features = NETIF_F_LLTX;
 -	SET_NETDEV_DEV(ndev, &mport->dev);
 -	ndev->ethtool_ops = &rionet_ethtool_ops;
 +	SET_ETHTOOL_OPS(ndev, &rionet_ethtool_ops);
  
  	spin_lock_init(&rnet->lock);
  	spin_lock_init(&rnet->tx_lock);
diff --cc drivers/usb/gadget/u_ether.c
index 4b76124ce96b,39a6df1e2ded..000000000000
--- a/drivers/usb/gadget/u_ether.c
+++ b/drivers/usb/gadget/u_ether.c
@@@ -137,25 -142,6 +137,28 @@@ static inline int qlen(struct usb_gadge
  
  /* NETWORK DRIVER HOOKUP (to the layer above this driver) */
  
++<<<<<<< HEAD:drivers/usb/gadget/u_ether.c
 +static int ueth_change_mtu(struct net_device *net, int new_mtu)
 +{
 +	struct eth_dev	*dev = netdev_priv(net);
 +	unsigned long	flags;
 +	int		status = 0;
 +
 +	/* don't change MTU on "live" link (peer won't know) */
 +	spin_lock_irqsave(&dev->lock, flags);
 +	if (dev->port_usb)
 +		status = -EBUSY;
 +	else if (new_mtu <= ETH_HLEN || new_mtu > ETH_FRAME_LEN)
 +		status = -ERANGE;
 +	else
 +		net->mtu = new_mtu;
 +	spin_unlock_irqrestore(&dev->lock, flags);
 +
 +	return status;
 +}
 +
++=======
++>>>>>>> b3e3893e1253 (net: use core MTU range checking in misc drivers):drivers/usb/gadget/function/u_ether.c
  static void eth_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *p)
  {
  	struct eth_dev *dev = netdev_priv(net);
@@@ -791,8 -787,12 +793,12 @@@ struct eth_dev *gether_setup_name(struc
  
  	net->netdev_ops = &eth_netdev_ops;
  
 -	net->ethtool_ops = &ops;
 +	SET_ETHTOOL_OPS(net, &ops);
  
+ 	/* MTU range: 14 - 15412 */
+ 	net->min_mtu = ETH_HLEN;
+ 	net->max_mtu = GETHER_MAX_ETH_FRAME_LEN;
+ 
  	dev->gadget = g;
  	SET_NETDEV_DEV(net, &g->dev);
  	SET_NETDEV_DEVTYPE(net, &gadget_type);
diff --cc net/batman-adv/soft-interface.c
index da34481729e7,112679d64be5..000000000000
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@@ -128,15 -158,16 +128,28 @@@ static int batadv_interface_set_mac_add
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int batadv_interface_change_mtu(struct net_device *dev, int new_mtu)
 +{
 +	/* check ranges */
 +	if ((new_mtu < 68) || (new_mtu > batadv_hardif_min_mtu(dev)))
 +		return -EINVAL;
 +
 +	dev->mtu = new_mtu;
 +
 +	return 0;
++=======
+ /**
+  * batadv_interface_set_rx_mode - set the rx mode of a device
+  * @dev: registered network device to modify
+  *
+  * We do not actually need to set any rx filters for the virtual batman
+  * soft interface. However a dummy handler enables a user to set static
+  * multicast listeners for instance.
+  */
+ static void batadv_interface_set_rx_mode(struct net_device *dev)
+ {
++>>>>>>> b3e3893e1253 (net: use core MTU range checking in misc drivers)
  }
  
  static int batadv_interface_tx(struct sk_buff *skb,
@@@ -565,8 -906,10 +578,12 @@@ static const struct net_device_ops bata
  	.ndo_open = batadv_interface_open,
  	.ndo_stop = batadv_interface_release,
  	.ndo_get_stats = batadv_interface_stats,
 -	.ndo_vlan_rx_add_vid = batadv_interface_add_vid,
 -	.ndo_vlan_rx_kill_vid = batadv_interface_kill_vid,
  	.ndo_set_mac_address = batadv_interface_set_mac_addr,
++<<<<<<< HEAD
 +	.ndo_change_mtu = batadv_interface_change_mtu,
++=======
+ 	.ndo_set_rx_mode = batadv_interface_set_rx_mode,
++>>>>>>> b3e3893e1253 (net: use core MTU range checking in misc drivers)
  	.ndo_start_xmit = batadv_interface_tx,
  	.ndo_validate_addr = eth_validate_addr,
  	.ndo_add_slave = batadv_softif_slave_add,
@@@ -630,7 -972,10 +647,8 @@@ struct net_device *batadv_softif_create
  	if (!soft_iface)
  		return NULL;
  
 -	dev_net_set(soft_iface, net);
 -
  	soft_iface->rtnl_link_ops = &batadv_link_ops;
+ 	soft_iface->max_mtu = batadv_hardif_min_mtu(soft_iface);
  
  	ret = register_netdevice(soft_iface);
  	if (ret < 0) {
* Unmerged path drivers/hsi/clients/ssi_protocol.c
* Unmerged path net/hsr/hsr_device.c
diff --git a/arch/um/drivers/net_kern.c b/arch/um/drivers/net_kern.c
index 5c28aafae433..d934953139ec 100644
--- a/arch/um/drivers/net_kern.c
+++ b/arch/um/drivers/net_kern.c
@@ -256,13 +256,6 @@ static void uml_net_tx_timeout(struct net_device *dev)
 	netif_wake_queue(dev);
 }
 
-static int uml_net_change_mtu(struct net_device *dev, int new_mtu)
-{
-	dev->mtu = new_mtu;
-
-	return 0;
-}
-
 #ifdef CONFIG_NET_POLL_CONTROLLER
 static void uml_net_poll_controller(struct net_device *dev)
 {
@@ -374,7 +367,6 @@ static const struct net_device_ops uml_netdev_ops = {
 	.ndo_set_rx_mode	= uml_net_set_multicast_list,
 	.ndo_tx_timeout 	= uml_net_tx_timeout,
 	.ndo_set_mac_address	= eth_mac_addr,
-	.ndo_change_mtu 	= uml_net_change_mtu,
 	.ndo_validate_addr	= eth_validate_addr,
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller = uml_net_poll_controller,
* Unmerged path drivers/firewire/net.c
* Unmerged path drivers/hsi/clients/ssi_protocol.c
diff --git a/drivers/infiniband/hw/nes/nes.c b/drivers/infiniband/hw/nes/nes.c
index 23f64bcb7014..10c2ed880bec 100644
--- a/drivers/infiniband/hw/nes/nes.c
+++ b/drivers/infiniband/hw/nes/nes.c
@@ -64,7 +64,6 @@ MODULE_AUTHOR("NetEffect");
 MODULE_DESCRIPTION("NetEffect RNIC Low-level iWARP Driver");
 MODULE_LICENSE("Dual BSD/GPL");
 
-int max_mtu = 9000;
 int interrupt_mod_interval = 0;
 
 /* Interoperability */
diff --git a/drivers/infiniband/hw/nes/nes.h b/drivers/infiniband/hw/nes/nes.h
index a49e45e33786..bedaa02749fb 100644
--- a/drivers/infiniband/hw/nes/nes.h
+++ b/drivers/infiniband/hw/nes/nes.h
@@ -84,6 +84,8 @@
 #define NES_FIRST_QPN           64
 #define NES_SW_CONTEXT_ALIGN    1024
 
+#define NES_MAX_MTU		9000
+
 #define NES_NIC_MAX_NICS        16
 #define NES_MAX_ARP_TABLE_SIZE  4096
 
@@ -170,8 +172,6 @@ do { \
 #include "nes_cm.h"
 #include "nes_mgt.h"
 
-extern int max_mtu;
-#define max_frame_len (max_mtu+ETH_HLEN)
 extern int interrupt_mod_interval;
 extern int nes_if_count;
 extern int mpa_version;
diff --git a/drivers/infiniband/hw/nes/nes_nic.c b/drivers/infiniband/hw/nes/nes_nic.c
index 3f4caa65cf23..a97ddaf71377 100644
--- a/drivers/infiniband/hw/nes/nes_nic.c
+++ b/drivers/infiniband/hw/nes/nes_nic.c
@@ -983,20 +983,16 @@ static int nes_netdev_change_mtu(struct net_device *netdev, int new_mtu)
 {
 	struct nes_vnic	*nesvnic = netdev_priv(netdev);
 	struct nes_device *nesdev = nesvnic->nesdev;
-	int ret = 0;
 	u8 jumbomode = 0;
 	u32 nic_active;
 	u32 nic_active_bit;
 	u32 uc_all_active;
 	u32 mc_all_active;
 
-	if ((new_mtu < ETH_ZLEN) || (new_mtu > max_mtu))
-		return -EINVAL;
-
 	netdev->mtu = new_mtu;
 	nesvnic->max_frame_size	= new_mtu + VLAN_ETH_HLEN;
 
-	if (netdev->mtu	> 1500)	{
+	if (netdev->mtu	> ETH_DATA_LEN)	{
 		jumbomode=1;
 	}
 	nes_nic_init_timer_defaults(nesdev, jumbomode);
@@ -1022,7 +1018,7 @@ static int nes_netdev_change_mtu(struct net_device *netdev, int new_mtu)
 		nes_write_indexed(nesdev, NES_IDX_NIC_UNICAST_ALL, nic_active);
 	}
 
-	return ret;
+	return 0;
 }
 
 
@@ -1668,7 +1664,7 @@ struct net_device *nes_netdev_init(struct nes_device *nesdev,
 
 	netdev->watchdog_timeo = NES_TX_TIMEOUT;
 	netdev->irq = nesdev->pcidev->irq;
-	netdev->mtu = ETH_DATA_LEN;
+	netdev->max_mtu = NES_MAX_MTU;
 	netdev->hard_header_len = ETH_HLEN;
 	netdev->addr_len = ETH_ALEN;
 	netdev->type = ARPHRD_ETHER;
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c
index 2f3832daed34..db712adf95c7 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@ -2263,6 +2263,7 @@ static struct net_device *ipoib_add_port(const char *format,
 	/* MTU will be reset when mcast join happens */
 	priv->dev->mtu  = IPOIB_UD_MTU(priv->max_ib_mtu);
 	priv->mcast_mtu  = priv->admin_mtu = priv->dev->mtu;
+	priv->dev->max_mtu = IPOIB_CM_MTU;
 
 	priv->dev->neigh_priv_len = sizeof(struct ipoib_neigh);
 
diff --git a/drivers/message/fusion/mptlan.c b/drivers/message/fusion/mptlan.c
index 6955c9e22d57..55dd71bbdc2a 100644
--- a/drivers/message/fusion/mptlan.c
+++ b/drivers/message/fusion/mptlan.c
@@ -548,16 +548,6 @@ mpt_lan_close(struct net_device *dev)
 	return 0;
 }
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-static int
-mpt_lan_change_mtu(struct net_device *dev, int new_mtu)
-{
-	if ((new_mtu < MPT_LAN_MIN_MTU) || (new_mtu > MPT_LAN_MAX_MTU))
-		return -EINVAL;
-	dev->mtu = new_mtu;
-	return 0;
-}
-
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /* Tx timeout handler. */
 static void
@@ -1304,7 +1294,6 @@ static const struct net_device_ops mpt_netdev_ops = {
 	.ndo_open       = mpt_lan_open,
 	.ndo_stop       = mpt_lan_close,
 	.ndo_start_xmit = mpt_lan_sdu_send,
-	.ndo_change_mtu = mpt_lan_change_mtu,
 	.ndo_tx_timeout = mpt_lan_tx_timeout,
 };
 
@@ -1375,6 +1364,10 @@ mpt_register_lan_device (MPT_ADAPTER *mpt_dev, int pnum)
 	dev->netdev_ops = &mpt_netdev_ops;
 	dev->watchdog_timeo = MPT_LAN_TX_TIMEOUT;
 
+	/* MTU range: 96 - 65280 */
+	dev->min_mtu = MPT_LAN_MIN_MTU;
+	dev->max_mtu = MPT_LAN_MAX_MTU;
+
 	dlprintk((KERN_INFO MYNAM ": Finished registering dev "
 		"and setting initial values\n"));
 
* Unmerged path drivers/misc/sgi-xp/xpnet.c
diff --git a/drivers/net/fddi/skfp/skfddi.c b/drivers/net/fddi/skfp/skfddi.c
index 1f99975e1467..3d60a93023ec 100644
--- a/drivers/net/fddi/skfp/skfddi.c
+++ b/drivers/net/fddi/skfp/skfddi.c
@@ -166,7 +166,6 @@ static const struct net_device_ops skfp_netdev_ops = {
 	.ndo_stop		= skfp_close,
 	.ndo_start_xmit		= skfp_send_pkt,
 	.ndo_get_stats		= skfp_ctl_get_stats,
-	.ndo_change_mtu		= fddi_change_mtu,
 	.ndo_set_rx_mode	= skfp_ctl_set_multicast_list,
 	.ndo_set_mac_address	= skfp_ctl_set_mac_address,
 	.ndo_do_ioctl		= skfp_ioctl,
diff --git a/drivers/net/fjes/fjes_main.c b/drivers/net/fjes/fjes_main.c
index 7cdaf486605a..6ee3bb6bb7b4 100644
--- a/drivers/net/fjes/fjes_main.c
+++ b/drivers/net/fjes/fjes_main.c
@@ -1347,6 +1347,8 @@ static void fjes_netdev_setup(struct net_device *netdev)
 	netdev->netdev_ops = &fjes_netdev_ops;
 	fjes_set_ethtool_ops(netdev);
 	netdev->mtu = fjes_support_mtu[3];
+	netdev->min_mtu = fjes_support_mtu[0];
+	netdev->max_mtu = fjes_support_mtu[3];
 	netdev->flags |= IFF_BROADCAST;
 	netdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
 }
diff --git a/drivers/net/hippi/rrunner.c b/drivers/net/hippi/rrunner.c
index 91d46c3c11b0..74e6ed97d6f3 100644
--- a/drivers/net/hippi/rrunner.c
+++ b/drivers/net/hippi/rrunner.c
@@ -69,7 +69,6 @@ static const struct net_device_ops rr_netdev_ops = {
 	.ndo_stop		= rr_close,
 	.ndo_do_ioctl		= rr_ioctl,
 	.ndo_start_xmit		= rr_start_xmit,
-	.ndo_change_mtu		= hippi_change_mtu,
 	.ndo_set_mac_address	= hippi_mac_addr,
 };
 
* Unmerged path drivers/net/rionet.c
diff --git a/drivers/net/slip/slip.c b/drivers/net/slip/slip.c
index 3a65fc0cbfe5..eeb883c392c4 100644
--- a/drivers/net/slip/slip.c
+++ b/drivers/net/slip/slip.c
@@ -561,12 +561,7 @@ static int sl_change_mtu(struct net_device *dev, int new_mtu)
 {
 	struct slip *sl = netdev_priv(dev);
 
-	if (new_mtu < 68 || new_mtu > 65534)
-		return -EINVAL;
-
-	if (new_mtu != dev->mtu)
-		return sl_realloc_bufs(sl, new_mtu);
-	return 0;
+	return sl_realloc_bufs(sl, new_mtu);
 }
 
 /* Netdevice get statistics request */
@@ -663,6 +658,10 @@ static void sl_setup(struct net_device *dev)
 	dev->addr_len		= 0;
 	dev->tx_queue_len	= 10;
 
+	/* MTU range: 68 - 65534 */
+	dev->min_mtu = 68;
+	dev->max_mtu = 65534;
+
 	/* New-style flags. */
 	dev->flags		= IFF_NOARP|IFF_POINTOPOINT|IFF_MULTICAST;
 }
diff --git a/drivers/usb/gadget/f_phonet.c b/drivers/usb/gadget/f_phonet.c
index b21ab558b6c0..5232c6bf1b14 100644
--- a/drivers/usb/gadget/f_phonet.c
+++ b/drivers/usb/gadget/f_phonet.c
@@ -259,19 +259,10 @@ out:
 	return NETDEV_TX_OK;
 }
 
-static int pn_net_mtu(struct net_device *dev, int new_mtu)
-{
-	if ((new_mtu < PHONET_MIN_MTU) || (new_mtu > PHONET_MAX_MTU))
-		return -EINVAL;
-	dev->mtu = new_mtu;
-	return 0;
-}
-
 static const struct net_device_ops pn_netdev_ops = {
 	.ndo_open	= pn_net_open,
 	.ndo_stop	= pn_net_close,
 	.ndo_start_xmit	= pn_net_xmit,
-	.ndo_change_mtu	= pn_net_mtu,
 };
 
 static void pn_net_setup(struct net_device *dev)
@@ -280,6 +271,8 @@ static void pn_net_setup(struct net_device *dev)
 	dev->type		= ARPHRD_PHONET;
 	dev->flags		= IFF_POINTOPOINT | IFF_NOARP;
 	dev->mtu		= PHONET_DEV_MTU;
+	dev->min_mtu		= PHONET_MIN_MTU;
+	dev->max_mtu		= PHONET_MAX_MTU;
 	dev->hard_header_len	= 1;
 	dev->dev_addr[0]	= PN_MEDIA_USB;
 	dev->addr_len		= 1;
* Unmerged path drivers/usb/gadget/u_ether.c
diff --git a/include/linux/fddidevice.h b/include/linux/fddidevice.h
index 9a79f0106da1..32c22cfb238b 100644
--- a/include/linux/fddidevice.h
+++ b/include/linux/fddidevice.h
@@ -26,7 +26,6 @@
 
 #ifdef __KERNEL__
 __be16 fddi_type_trans(struct sk_buff *skb, struct net_device *dev);
-int fddi_change_mtu(struct net_device *dev, int new_mtu);
 struct net_device *alloc_fddidev(int sizeof_priv);
 #endif
 
diff --git a/include/linux/hippidevice.h b/include/linux/hippidevice.h
index 8ec23fb0b412..402f99e328d4 100644
--- a/include/linux/hippidevice.h
+++ b/include/linux/hippidevice.h
@@ -32,7 +32,6 @@ struct hippi_cb {
 };
 
 __be16 hippi_type_trans(struct sk_buff *skb, struct net_device *dev);
-int hippi_change_mtu(struct net_device *dev, int new_mtu);
 int hippi_mac_addr(struct net_device *dev, void *p);
 int hippi_neigh_setup_dev(struct net_device *dev, struct neigh_parms *p);
 struct net_device *alloc_hippi_dev(int sizeof_priv);
diff --git a/net/802/fddi.c b/net/802/fddi.c
index 5655d8e2372a..65be4e9f586c 100644
--- a/net/802/fddi.c
+++ b/net/802/fddi.c
@@ -166,15 +166,6 @@ __be16 fddi_type_trans(struct sk_buff *skb, struct net_device *dev)
 
 EXPORT_SYMBOL(fddi_type_trans);
 
-int fddi_change_mtu(struct net_device *dev, int new_mtu)
-{
-	if ((new_mtu < FDDI_K_SNAP_HLEN) || (new_mtu > FDDI_K_SNAP_DLEN))
-		return -EINVAL;
-	dev->mtu = new_mtu;
-	return 0;
-}
-EXPORT_SYMBOL(fddi_change_mtu);
-
 static const struct header_ops fddi_header_ops = {
 	.create		= fddi_header,
 	.rebuild	= fddi_rebuild_header,
@@ -187,6 +178,8 @@ static void fddi_setup(struct net_device *dev)
 	dev->type		= ARPHRD_FDDI;
 	dev->hard_header_len	= FDDI_K_SNAP_HLEN+3;	/* Assume 802.2 SNAP hdr len + 3 pad bytes */
 	dev->mtu		= FDDI_K_SNAP_DLEN;	/* Assume max payload of 802.2 SNAP frame */
+	dev->min_mtu		= FDDI_K_SNAP_HLEN;
+	dev->max_mtu		= FDDI_K_SNAP_DLEN;
 	dev->addr_len		= FDDI_K_ALEN;
 	dev->tx_queue_len	= 100;			/* Long queues on FDDI */
 	dev->flags		= IFF_BROADCAST | IFF_MULTICAST;
diff --git a/net/802/hippi.c b/net/802/hippi.c
index dc320610fa51..c41868df1499 100644
--- a/net/802/hippi.c
+++ b/net/802/hippi.c
@@ -143,18 +143,6 @@ __be16 hippi_type_trans(struct sk_buff *skb, struct net_device *dev)
 
 EXPORT_SYMBOL(hippi_type_trans);
 
-int hippi_change_mtu(struct net_device *dev, int new_mtu)
-{
-	/*
-	 * HIPPI's got these nice large MTUs.
-	 */
-	if ((new_mtu < 68) || (new_mtu > 65280))
-		return -EINVAL;
-	dev->mtu = new_mtu;
-	return 0;
-}
-EXPORT_SYMBOL(hippi_change_mtu);
-
 /*
  * For HIPPI we will actually use the lower 4 bytes of the hardware
  * address as the I-FIELD rather than the actual hardware address.
@@ -202,6 +190,8 @@ static void hippi_setup(struct net_device *dev)
 	dev->type		= ARPHRD_HIPPI;
 	dev->hard_header_len 	= HIPPI_HLEN;
 	dev->mtu		= 65280;
+	dev->min_mtu		= 68;
+	dev->max_mtu		= 65280;
 	dev->addr_len		= HIPPI_ALEN;
 	dev->tx_queue_len	= 25 /* 5 */;
 	memset(dev->broadcast, 0xFF, HIPPI_ALEN);
* Unmerged path net/batman-adv/soft-interface.c
* Unmerged path net/hsr/hsr_device.c
diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index a2fba7edfd1f..df1204391675 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -218,20 +218,10 @@ static netdev_tx_t gprs_xmit(struct sk_buff *skb, struct net_device *dev)
 	return NETDEV_TX_OK;
 }
 
-static int gprs_set_mtu(struct net_device *dev, int new_mtu)
-{
-	if ((new_mtu < 576) || (new_mtu > (PHONET_MAX_MTU - 11)))
-		return -EINVAL;
-
-	dev->mtu = new_mtu;
-	return 0;
-}
-
 static const struct net_device_ops gprs_netdev_ops = {
 	.ndo_open	= gprs_open,
 	.ndo_stop	= gprs_close,
 	.ndo_start_xmit	= gprs_xmit,
-	.ndo_change_mtu	= gprs_set_mtu,
 };
 
 static void gprs_setup(struct net_device *dev)
@@ -240,6 +230,8 @@ static void gprs_setup(struct net_device *dev)
 	dev->type		= ARPHRD_PHONET_PIPE;
 	dev->flags		= IFF_POINTOPOINT | IFF_NOARP;
 	dev->mtu		= GPRS_DEFAULT_MTU;
+	dev->min_mtu		= 576;
+	dev->max_mtu		= (PHONET_MAX_MTU - 11);
 	dev->hard_header_len	= 0;
 	dev->addr_len		= 0;
 	dev->tx_queue_len	= 10;
