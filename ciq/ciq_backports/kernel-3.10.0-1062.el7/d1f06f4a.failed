nvme-pci: move ->cq_vector == -1 check outside of ->q_lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jens Axboe <axboe@kernel.dk>
commit d1f06f4ae0410f8e5025f3c9129a52b86579e174
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/d1f06f4a.failed

We only clear it dynamically in nvme_suspend_queue(). When we do, ensure
to do a full flush so that any nvme_queue_rq() invocation will see it.

Ideally we'd kill this check completely, but we're using it to flush
requests on a dying queue.

	Signed-off-by: Jens Axboe <axboe@kernel.dk>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit d1f06f4ae0410f8e5025f3c9129a52b86579e174)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/pci.c
diff --cc drivers/nvme/host/pci.c
index 555634b3136a,3dfedc84a921..000000000000
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@@ -665,38 -870,39 +665,53 @@@ static int nvme_queue_rq(struct blk_mq_
  	struct nvme_dev *dev = nvmeq->dev;
  	struct request *req = bd->rq;
  	struct nvme_command cmnd;
 -	blk_status_t ret;
 -
 +	unsigned map_len;
 +	int ret = BLK_MQ_RQ_QUEUE_OK;
 +
++<<<<<<< HEAD
 +	map_len = nvme_map_len(req);
 +	ret = nvme_init_iod(req, map_len, dev);
 +	if (ret != BLK_MQ_RQ_QUEUE_OK)
++=======
+ 	/*
+ 	 * We should not need to do this, but we're still using this to
+ 	 * ensure we can drain requests on a dying queue.
+ 	 */
+ 	if (unlikely(nvmeq->cq_vector < 0))
+ 		return BLK_STS_IOERR;
+ 
+ 	ret = nvme_setup_cmd(ns, req, &cmnd);
+ 	if (ret)
++>>>>>>> d1f06f4ae041 (nvme-pci: move ->cq_vector == -1 check outside of ->q_lock)
  		return ret;
  
 -	ret = nvme_init_iod(req, dev);
 -	if (ret)
 -		goto out_free_cmd;
 +	ret = nvme_setup_cmd(ns, req, &cmnd);
 +	if (ret != BLK_MQ_RQ_QUEUE_OK)
 +		goto out;
  
 -	if (blk_rq_nr_phys_segments(req)) {
 -		ret = nvme_map_data(dev, req, &cmnd);
 -		if (ret)
 -			goto out_cleanup_iod;
 -	}
 +	if (req->nr_phys_segments)
 +		ret = nvme_map_data(dev, req, map_len, &cmnd);
 +
 +	if (ret != BLK_MQ_RQ_QUEUE_OK)
 +		goto out;
  
  	blk_mq_start_request(req);
  
  	spin_lock_irq(&nvmeq->q_lock);
++<<<<<<< HEAD
 +	if (unlikely(nvmeq->cq_vector < 0)) {
 +		ret = BLK_MQ_RQ_QUEUE_ERROR;
 +		spin_unlock_irq(&nvmeq->q_lock);
 +		goto out;
 +	}
++=======
++>>>>>>> d1f06f4ae041 (nvme-pci: move ->cq_vector == -1 check outside of ->q_lock)
  	__nvme_submit_cmd(nvmeq, &cmnd);
 +	nvme_process_cq(nvmeq);
  	spin_unlock_irq(&nvmeq->q_lock);
 -	return BLK_STS_OK;
 -out_cleanup_iod:
 +	return BLK_MQ_RQ_QUEUE_OK;
 +out:
  	nvme_free_iod(dev, req);
 -out_free_cmd:
 -	nvme_cleanup_cmd(req);
  	return ret;
  }
  
* Unmerged path drivers/nvme/host/pci.c
