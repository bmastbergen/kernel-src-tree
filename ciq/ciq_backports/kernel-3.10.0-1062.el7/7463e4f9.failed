geneve, vxlan: Don't check skb_dst() twice

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Stefano Brivio <sbrivio@redhat.com>
commit 7463e4f9b99c089cc962033b46349ff29f466e40
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7463e4f9.failed

Commit f15ca723c1eb ("net: don't call update_pmtu unconditionally") avoids
that we try updating PMTU for a non-existent destination, but didn't clean
up cases where the check was already explicit. Drop those redundant checks.

	Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
	Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7463e4f9b99c089cc962033b46349ff29f466e40)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
#	drivers/net/vxlan.c
diff --cc drivers/net/geneve.c
index 33df2da67472,61c4bfbeb41c..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -879,12 -830,8 +879,17 @@@ static int geneve_xmit_skb(struct sk_bu
  	if (IS_ERR(rt))
  		return PTR_ERR(rt);
  
++<<<<<<< HEAD
 +	if (skb_dst(skb)) {
 +		int mtu = dst_mtu(&rt->dst) - GENEVE_IPV4_HLEN -
 +			  info->options_len;
 +
 +		skb_dst(skb)->ops->update_pmtu(skb_dst(skb), NULL, skb, mtu);
 +	}
++=======
+ 	skb_dst_update_pmtu(skb, dst_mtu(&rt->dst) -
+ 				 GENEVE_IPV4_HLEN - info->options_len);
++>>>>>>> 7463e4f9b99c (geneve, vxlan: Don't check skb_dst() twice)
  
  	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
  	if (geneve->collect_md) {
@@@ -925,11 -872,8 +930,16 @@@ static int geneve6_xmit_skb(struct sk_b
  	if (IS_ERR(dst))
  		return PTR_ERR(dst);
  
++<<<<<<< HEAD
 +	if (skb_dst(skb)) {
 +		int mtu = dst_mtu(dst) - GENEVE_IPV6_HLEN - info->options_len;
 +
 +		skb_dst(skb)->ops->update_pmtu(skb_dst(skb), NULL, skb, mtu);
 +	}
++=======
+ 	skb_dst_update_pmtu(skb, dst_mtu(dst) -
+ 				 GENEVE_IPV6_HLEN - info->options_len);
++>>>>>>> 7463e4f9b99c (geneve, vxlan: Don't check skb_dst() twice)
  
  	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
  	if (geneve->collect_md) {
diff --cc drivers/net/vxlan.c
index e093c26c92e0,22e0ce592e07..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -2164,12 -2194,7 +2164,16 @@@ static void vxlan_xmit_one(struct sk_bu
  		}
  
  		ndst = &rt->dst;
++<<<<<<< HEAD
 +		if (skb_dst(skb)) {
 +			int mtu = dst_mtu(ndst) - VXLAN_HEADROOM;
 +
 +			skb_dst(skb)->ops->update_pmtu(skb_dst(skb), NULL,
 +						       skb, mtu);
 +		}
++=======
+ 		skb_dst_update_pmtu(skb, dst_mtu(ndst) - VXLAN_HEADROOM);
++>>>>>>> 7463e4f9b99c (geneve, vxlan: Don't check skb_dst() twice)
  
  		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip4_dst_hoplimit(&rt->dst);
@@@ -2206,12 -2231,7 +2210,16 @@@
  				goto out_unlock;
  		}
  
++<<<<<<< HEAD
 +		if (skb_dst(skb)) {
 +			int mtu = dst_mtu(ndst) - VXLAN6_HEADROOM;
 +
 +			skb_dst(skb)->ops->update_pmtu(skb_dst(skb), NULL,
 +						       skb, mtu);
 +		}
++=======
+ 		skb_dst_update_pmtu(skb, dst_mtu(ndst) - VXLAN6_HEADROOM);
++>>>>>>> 7463e4f9b99c (geneve, vxlan: Don't check skb_dst() twice)
  
  		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip6_dst_hoplimit(ndst);
* Unmerged path drivers/net/geneve.c
* Unmerged path drivers/net/vxlan.c
