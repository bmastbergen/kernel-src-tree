net: phy: convert read-modify-write to phy_modify()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] phy: convert read-modify-write to phy_modify() (Ivan Vecera) [1685646]
Rebuild_FUZZ: 94.85%
commit-author Russell King <rmk+kernel@armlinux.org.uk>
commit fea23fb591cce99546baca043d2a068228e87a79
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/fea23fb5.failed

Convert read-modify-write sequences in at803x, Marvell and core phylib
to use phy_modify() to ensure safety.

	Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fea23fb591cce99546baca043d2a068228e87a79)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/at803x.c
#	drivers/net/phy/marvell.c
#	drivers/net/phy/phy_device.c
diff --cc drivers/net/phy/at803x.c
index 45cbc10de01c,c2715908d43e..000000000000
--- a/drivers/net/phy/at803x.c
+++ b/drivers/net/phy/at803x.c
@@@ -43,23 -160,91 +43,78 @@@ static void at803x_set_wol_mac_addr(str
  	};
  
  	if (!ndev)
 -		return -ENODEV;
 +		return;
  
 -	if (wol->wolopts & WAKE_MAGIC) {
 -		mac = (const u8 *) ndev->dev_addr;
 +	mac = (const u8 *) ndev->dev_addr;
  
 -		if (!is_valid_ether_addr(mac))
 -			return -EINVAL;
 +	if (!is_valid_ether_addr(mac))
 +		return;
  
 -		for (i = 0; i < 3; i++) {
 -			phy_write(phydev, AT803X_MMD_ACCESS_CONTROL,
 +	for (i = 0; i < 3; i++) {
 +		phy_write(phydev, AT803X_MMD_ACCESS_CONTROL,
  				  AT803X_DEVICE_ADDR);
 -			phy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,
 +		phy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,
  				  offsets[i]);
 -			phy_write(phydev, AT803X_MMD_ACCESS_CONTROL,
 +		phy_write(phydev, AT803X_MMD_ACCESS_CONTROL,
  				  AT803X_FUNC_DATA);
 -			phy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,
 +		phy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,
  				  mac[(i * 2) + 1] | (mac[(i * 2)] << 8));
 -		}
 -
 -		value = phy_read(phydev, AT803X_INTR_ENABLE);
 -		value |= AT803X_INTR_ENABLE_WOL;
 -		ret = phy_write(phydev, AT803X_INTR_ENABLE, value);
 -		if (ret)
 -			return ret;
 -		value = phy_read(phydev, AT803X_INTR_STATUS);
 -	} else {
 -		value = phy_read(phydev, AT803X_INTR_ENABLE);
 -		value &= (~AT803X_INTR_ENABLE_WOL);
 -		ret = phy_write(phydev, AT803X_INTR_ENABLE, value);
 -		if (ret)
 -			return ret;
 -		value = phy_read(phydev, AT803X_INTR_STATUS);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	return ret;
+ }
+ 
+ static void at803x_get_wol(struct phy_device *phydev,
+ 			   struct ethtool_wolinfo *wol)
+ {
+ 	u32 value;
+ 
+ 	wol->supported = WAKE_MAGIC;
+ 	wol->wolopts = 0;
+ 
+ 	value = phy_read(phydev, AT803X_INTR_ENABLE);
+ 	if (value & AT803X_INTR_ENABLE_WOL)
+ 		wol->wolopts |= WAKE_MAGIC;
+ }
+ 
+ static int at803x_suspend(struct phy_device *phydev)
+ {
+ 	int value;
+ 	int wol_enabled;
+ 
+ 	value = phy_read(phydev, AT803X_INTR_ENABLE);
+ 	wol_enabled = value & AT803X_INTR_ENABLE_WOL;
+ 
+ 	if (wol_enabled)
+ 		value = BMCR_ISOLATE;
+ 	else
+ 		value = BMCR_PDOWN;
+ 
+ 	phy_modify(phydev, MII_BMCR, 0, value);
+ 
+ 	return 0;
+ }
+ 
+ static int at803x_resume(struct phy_device *phydev)
+ {
+ 	return phy_modify(phydev, MII_BMCR, ~(BMCR_PDOWN | BMCR_ISOLATE), 0);
+ }
+ 
+ static int at803x_probe(struct phy_device *phydev)
+ {
+ 	struct device *dev = &phydev->mdio.dev;
+ 	struct at803x_priv *priv;
+ 
+ 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+ 	if (!priv)
+ 		return -ENOMEM;
+ 
+ 	phydev->priv = priv;
+ 
+ 	return 0;
++>>>>>>> fea23fb591cc (net: phy: convert read-modify-write to phy_modify())
  }
  
  static int at803x_config_init(struct phy_device *phydev)
diff --cc drivers/net/phy/marvell.c
index e84c049c80c3,2bd38962b5d2..000000000000
--- a/drivers/net/phy/marvell.c
+++ b/drivers/net/phy/marvell.c
@@@ -331,34 -446,31 +331,39 @@@ static int marvell_of_reg_init(struct p
  }
  #endif /* CONFIG_OF_MDIO */
  
 -static int m88e1121_config_aneg_rgmii_delays(struct phy_device *phydev)
 +static int m88e1121_config_aneg(struct phy_device *phydev)
  {
 -	int mscr;
 -
 -	if (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID)
 -		mscr = MII_88E1121_PHY_MSCR_RX_DELAY |
 -		       MII_88E1121_PHY_MSCR_TX_DELAY;
 -	else if (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID)
 -		mscr = MII_88E1121_PHY_MSCR_RX_DELAY;
 -	else if (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)
 -		mscr = MII_88E1121_PHY_MSCR_TX_DELAY;
 -	else
 -		mscr = 0;
 +	int err, oldpage, mscr;
  
 -	return phy_modify_paged(phydev, MII_MARVELL_MSCR_PAGE,
 -				MII_88E1121_PHY_MSCR_REG,
 -				MII_88E1121_PHY_MSCR_DELAY_MASK, mscr);
 -}
++<<<<<<< HEAD
 +	oldpage = phy_read(phydev, MII_MARVELL_PHY_PAGE);
  
 -static int m88e1121_config_aneg(struct phy_device *phydev)
 -{
 -	int err = 0;
 +	err = phy_write(phydev, MII_MARVELL_PHY_PAGE,
 +			MII_88E1121_PHY_MSCR_PAGE);
 +	if (err < 0)
 +		return err;
  
 +	if ((phydev->interface == PHY_INTERFACE_MODE_RGMII) ||
 +	    (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID) ||
 +	    (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID) ||
 +	    (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)) {
 +
 +		mscr = phy_read(phydev, MII_88E1121_PHY_MSCR_REG) &
 +			MII_88E1121_PHY_MSCR_DELAY_MASK;
 +
 +		if (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID)
 +			mscr |= (MII_88E1121_PHY_MSCR_RX_DELAY |
 +				 MII_88E1121_PHY_MSCR_TX_DELAY);
 +		else if (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID)
 +			mscr |= MII_88E1121_PHY_MSCR_RX_DELAY;
 +		else if (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)
 +			mscr |= MII_88E1121_PHY_MSCR_TX_DELAY;
 +
 +		err = phy_write(phydev, MII_88E1121_PHY_MSCR_REG, mscr);
++=======
+ 	if (phy_interface_is_rgmii(phydev)) {
+ 		err = m88e1121_config_aneg_rgmii_delays(phydev);
++>>>>>>> fea23fb591cc (net: phy: convert read-modify-write to phy_modify())
  		if (err < 0)
  			return err;
  	}
@@@ -410,46 -499,287 +415,329 @@@ static int m88e1318_config_aneg(struct 
  	return m88e1121_config_aneg(phydev);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * ethtool_adv_to_fiber_adv_t
+  * @ethadv: the ethtool advertisement settings
+  *
+  * A small helper function that translates ethtool advertisement
+  * settings to phy autonegotiation advertisements for the
+  * MII_ADV register for fiber link.
+  */
+ static inline u32 ethtool_adv_to_fiber_adv_t(u32 ethadv)
+ {
+ 	u32 result = 0;
+ 
+ 	if (ethadv & ADVERTISED_1000baseT_Half)
+ 		result |= ADVERTISE_FIBER_1000HALF;
+ 	if (ethadv & ADVERTISED_1000baseT_Full)
+ 		result |= ADVERTISE_FIBER_1000FULL;
+ 
+ 	if ((ethadv & ADVERTISE_PAUSE_ASYM) && (ethadv & ADVERTISE_PAUSE_CAP))
+ 		result |= LPA_PAUSE_ASYM_FIBER;
+ 	else if (ethadv & ADVERTISE_PAUSE_CAP)
+ 		result |= (ADVERTISE_PAUSE_FIBER
+ 			   & (~ADVERTISE_PAUSE_ASYM_FIBER));
+ 
+ 	return result;
+ }
+ 
+ /**
+  * marvell_config_aneg_fiber - restart auto-negotiation or write BMCR
+  * @phydev: target phy_device struct
+  *
+  * Description: If auto-negotiation is enabled, we configure the
+  *   advertising, and then restart auto-negotiation.  If it is not
+  *   enabled, then we write the BMCR. Adapted for fiber link in
+  *   some Marvell's devices.
+  */
+ static int marvell_config_aneg_fiber(struct phy_device *phydev)
+ {
+ 	int changed = 0;
+ 	int err;
+ 	int adv, oldadv;
+ 	u32 advertise;
+ 
+ 	if (phydev->autoneg != AUTONEG_ENABLE)
+ 		return genphy_setup_forced(phydev);
+ 
+ 	/* Only allow advertising what this PHY supports */
+ 	phydev->advertising &= phydev->supported;
+ 	advertise = phydev->advertising;
+ 
+ 	/* Setup fiber advertisement */
+ 	adv = phy_read(phydev, MII_ADVERTISE);
+ 	if (adv < 0)
+ 		return adv;
+ 
+ 	oldadv = adv;
+ 	adv &= ~(ADVERTISE_FIBER_1000HALF | ADVERTISE_FIBER_1000FULL
+ 		| LPA_PAUSE_FIBER);
+ 	adv |= ethtool_adv_to_fiber_adv_t(advertise);
+ 
+ 	if (adv != oldadv) {
+ 		err = phy_write(phydev, MII_ADVERTISE, adv);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		changed = 1;
+ 	}
+ 
+ 	if (changed == 0) {
+ 		/* Advertisement hasn't changed, but maybe aneg was never on to
+ 		 * begin with?	Or maybe phy was isolated?
+ 		 */
+ 		int ctl = phy_read(phydev, MII_BMCR);
+ 
+ 		if (ctl < 0)
+ 			return ctl;
+ 
+ 		if (!(ctl & BMCR_ANENABLE) || (ctl & BMCR_ISOLATE))
+ 			changed = 1; /* do restart aneg */
+ 	}
+ 
+ 	/* Only restart aneg if we are advertising something different
+ 	 * than we were before.
+ 	 */
+ 	if (changed > 0)
+ 		changed = genphy_restart_aneg(phydev);
+ 
+ 	return changed;
+ }
+ 
+ static int m88e1510_config_aneg(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	err = marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 	if (err < 0)
+ 		goto error;
+ 
+ 	/* Configure the copper link first */
+ 	err = m88e1318_config_aneg(phydev);
+ 	if (err < 0)
+ 		goto error;
+ 
+ 	/* Do not touch the fiber page if we're in copper->sgmii mode */
+ 	if (phydev->interface == PHY_INTERFACE_MODE_SGMII)
+ 		return 0;
+ 
+ 	/* Then the fiber link */
+ 	err = marvell_set_page(phydev, MII_MARVELL_FIBER_PAGE);
+ 	if (err < 0)
+ 		goto error;
+ 
+ 	err = marvell_config_aneg_fiber(phydev);
+ 	if (err < 0)
+ 		goto error;
+ 
+ 	return marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 
+ error:
+ 	marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 	return err;
+ }
+ 
+ static int marvell_config_init(struct phy_device *phydev)
+ {
+ 	/* Set registers from marvell,reg-init DT property */
+ 	return marvell_of_reg_init(phydev);
+ }
+ 
+ static int m88e1116r_config_init(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	err = genphy_soft_reset(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	mdelay(500);
+ 
+ 	err = marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = marvell_set_polarity(phydev, phydev->mdix_ctrl);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = marvell_set_downshift(phydev, true, 8);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (phy_interface_is_rgmii(phydev)) {
+ 		err = m88e1121_config_aneg_rgmii_delays(phydev);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	err = genphy_soft_reset(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	return marvell_config_init(phydev);
+ }
+ 
+ static int m88e3016_config_init(struct phy_device *phydev)
+ {
+ 	int ret;
+ 
+ 	/* Enable Scrambler and Auto-Crossover */
+ 	ret = phy_modify(phydev, MII_88E3016_PHY_SPEC_CTRL,
+ 			 ~MII_88E3016_DISABLE_SCRAMBLER,
+ 			 MII_88E3016_AUTO_MDIX_CROSSOVER);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return marvell_config_init(phydev);
+ }
+ 
+ static int m88e1111_config_init_hwcfg_mode(struct phy_device *phydev,
+ 					   u16 mode,
+ 					   int fibre_copper_auto)
+ {
+ 	if (fibre_copper_auto)
+ 		mode |= MII_M1111_HWCFG_FIBER_COPPER_AUTO;
+ 
+ 	return phy_modify(phydev, MII_M1111_PHY_EXT_SR,
+ 			  (u16)~(MII_M1111_HWCFG_MODE_MASK |
+ 				 MII_M1111_HWCFG_FIBER_COPPER_AUTO |
+ 				 MII_M1111_HWCFG_FIBER_COPPER_RES),
+ 			  mode);
+ }
+ 
+ static int m88e1111_config_init_rgmii_delays(struct phy_device *phydev)
+ {
+ 	int delay;
+ 
+ 	if (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID) {
+ 		delay = MII_M1111_RGMII_RX_DELAY | MII_M1111_RGMII_TX_DELAY;
+ 	} else if (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID) {
+ 		delay = MII_M1111_RGMII_RX_DELAY;
+ 	} else if (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID) {
+ 		delay = MII_M1111_RGMII_TX_DELAY;
+ 	} else {
+ 		delay = 0;
+ 	}
+ 
+ 	return phy_modify(phydev, MII_M1111_PHY_EXT_CR,
+ 			  (u16)~(MII_M1111_RGMII_RX_DELAY |
+ 				 MII_M1111_RGMII_TX_DELAY),
+ 			  delay);
+ }
+ 
+ static int m88e1111_config_init_rgmii(struct phy_device *phydev)
+ {
+ 	int temp;
+ 	int err;
+ 
+ 	err = m88e1111_config_init_rgmii_delays(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	temp = phy_read(phydev, MII_M1111_PHY_EXT_SR);
+ 	if (temp < 0)
+ 		return temp;
+ 
+ 	temp &= ~(MII_M1111_HWCFG_MODE_MASK);
+ 
+ 	if (temp & MII_M1111_HWCFG_FIBER_COPPER_RES)
+ 		temp |= MII_M1111_HWCFG_MODE_FIBER_RGMII;
+ 	else
+ 		temp |= MII_M1111_HWCFG_MODE_COPPER_RGMII;
+ 
+ 	return phy_write(phydev, MII_M1111_PHY_EXT_SR, temp);
+ }
+ 
+ static int m88e1111_config_init_sgmii(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	err = m88e1111_config_init_hwcfg_mode(
+ 		phydev,
+ 		MII_M1111_HWCFG_MODE_SGMII_NO_CLK,
+ 		MII_M1111_HWCFG_FIBER_COPPER_AUTO);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	/* make sure copper is selected */
+ 	return marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ }
+ 
+ static int m88e1111_config_init_rtbi(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	err = m88e1111_config_init_rgmii_delays(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = m88e1111_config_init_hwcfg_mode(
+ 		phydev,
+ 		MII_M1111_HWCFG_MODE_RTBI,
+ 		MII_M1111_HWCFG_FIBER_COPPER_AUTO);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	/* soft reset */
+ 	err = genphy_soft_reset(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	return m88e1111_config_init_hwcfg_mode(
+ 		phydev,
+ 		MII_M1111_HWCFG_MODE_RTBI,
+ 		MII_M1111_HWCFG_FIBER_COPPER_AUTO);
+ }
+ 
++>>>>>>> fea23fb591cc (net: phy: convert read-modify-write to phy_modify())
  static int m88e1111_config_init(struct phy_device *phydev)
  {
  	int err;
 +	int temp;
 +
++<<<<<<< HEAD
 +	if ((phydev->interface == PHY_INTERFACE_MODE_RGMII) ||
 +	    (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID) ||
 +	    (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID) ||
 +	    (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)) {
 +
 +		temp = phy_read(phydev, MII_M1111_PHY_EXT_CR);
 +		if (temp < 0)
 +			return temp;
 +
 +		if (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID) {
 +			temp |= (MII_M1111_RX_DELAY | MII_M1111_TX_DELAY);
 +		} else if (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID) {
 +			temp &= ~MII_M1111_TX_DELAY;
 +			temp |= MII_M1111_RX_DELAY;
 +		} else if (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID) {
 +			temp &= ~MII_M1111_RX_DELAY;
 +			temp |= MII_M1111_TX_DELAY;
 +		}
 +
 +		err = phy_write(phydev, MII_M1111_PHY_EXT_CR, temp);
 +		if (err < 0)
 +			return err;
 +
 +		temp = phy_read(phydev, MII_M1111_PHY_EXT_SR);
 +		if (temp < 0)
 +			return temp;
 +
 +		temp &= ~(MII_M1111_HWCFG_MODE_MASK);
  
 +		if (temp & MII_M1111_HWCFG_FIBER_COPPER_RES)
 +			temp |= MII_M1111_HWCFG_MODE_FIBER_RGMII;
 +		else
 +			temp |= MII_M1111_HWCFG_MODE_COPPER_RGMII;
 +
 +		err = phy_write(phydev, MII_M1111_PHY_EXT_SR, temp);
++=======
+ 	if (phy_interface_is_rgmii(phydev)) {
+ 		err = m88e1111_config_init_rgmii(phydev);
++>>>>>>> fea23fb591cc (net: phy: convert read-modify-write to phy_modify())
  		if (err < 0)
  			return err;
  	}
@@@ -508,7 -800,67 +796,71 @@@
  	if (err < 0)
  		return err;
  
++<<<<<<< HEAD
 +	return phy_write(phydev, MII_BMCR, BMCR_RESET);
++=======
+ 	return genphy_soft_reset(phydev);
+ }
+ 
+ static int m88e1121_config_init(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	/* Default PHY LED config: LED[0] .. Link, LED[1] .. Activity */
+ 	err = phy_write_paged(phydev, MII_MARVELL_LED_PAGE,
+ 			      MII_88E1121_PHY_LED_CTRL,
+ 			      MII_88E1121_PHY_LED_DEF);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	/* Set marvell,reg-init configuration from device tree */
+ 	return marvell_config_init(phydev);
+ }
+ 
+ static int m88e1510_config_init(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	/* SGMII-to-Copper mode initialization */
+ 	if (phydev->interface == PHY_INTERFACE_MODE_SGMII) {
+ 		u32 pause;
+ 
+ 		/* Select page 18 */
+ 		err = marvell_set_page(phydev, 18);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		/* In reg 20, write MODE[2:0] = 0x1 (SGMII to Copper) */
+ 		err = phy_modify(phydev, MII_88E1510_GEN_CTRL_REG_1,
+ 				 ~MII_88E1510_GEN_CTRL_REG_1_MODE_MASK,
+ 				 MII_88E1510_GEN_CTRL_REG_1_MODE_SGMII);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		/* PHY reset is necessary after changing MODE[2:0] */
+ 		err = phy_modify(phydev, MII_88E1510_GEN_CTRL_REG_1, 0,
+ 				 MII_88E1510_GEN_CTRL_REG_1_RESET);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		/* Reset page selection */
+ 		err = marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		/* There appears to be a bug in the 88e1512 when used in
+ 		 * SGMII to copper mode, where the AN advertisment register
+ 		 * clears the pause bits each time a negotiation occurs.
+ 		 * This means we can never be truely sure what was advertised,
+ 		 * so disable Pause support.
+ 		 */
+ 		pause = SUPPORTED_Pause | SUPPORTED_Asym_Pause;
+ 		phydev->supported &= ~pause;
+ 		phydev->advertising &= ~pause;
+ 	}
+ 
+ 	return m88e1121_config_init(phydev);
++>>>>>>> fea23fb591cc (net: phy: convert read-modify-write to phy_modify())
  }
  
  static int m88e1118_config_aneg(struct phy_device *phydev)
@@@ -590,7 -941,42 +942,46 @@@ static int m88e1149_config_init(struct 
  	if (err < 0)
  		return err;
  
++<<<<<<< HEAD
 +	return phy_write(phydev, MII_BMCR, BMCR_RESET);
++=======
+ 	return genphy_soft_reset(phydev);
+ }
+ 
+ static int m88e1145_config_init_rgmii(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	err = m88e1111_config_init_rgmii_delays(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (phydev->dev_flags & MARVELL_PHY_M1145_FLAGS_RESISTANCE) {
+ 		err = phy_write(phydev, 0x1d, 0x0012);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		err = phy_modify(phydev, 0x1e, 0xf03f,
+ 				 2 << 9 | /* 36 ohm */
+ 				 2 << 6); /* 39 ohm */
+ 		if (err < 0)
+ 			return err;
+ 
+ 		err = phy_write(phydev, 0x1d, 0x3);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		err = phy_write(phydev, 0x1e, 0x8000);
+ 	}
+ 	return err;
+ }
+ 
+ static int m88e1145_config_init_sgmii(struct phy_device *phydev)
+ {
+ 	return m88e1111_config_init_hwcfg_mode(
+ 		phydev, MII_M1111_HWCFG_MODE_SGMII_NO_CLK,
+ 		MII_M1111_HWCFG_FIBER_COPPER_AUTO);
++>>>>>>> fea23fb591cc (net: phy: convert read-modify-write to phy_modify())
  }
  
  static int m88e1145_config_init(struct phy_device *phydev)
diff --cc drivers/net/phy/phy_device.c
index f7f4abfd4a6f,2c5b2e041c0f..000000000000
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@@ -838,11 -1366,10 +838,10 @@@ static int genphy_config_advert(struct 
   *   to the values in phydev. Assumes that the values are valid.
   *   Please see phy_sanitize_settings().
   */
 -int genphy_setup_forced(struct phy_device *phydev)
 +static int genphy_setup_forced(struct phy_device *phydev)
  {
- 	int ctl = phy_read(phydev, MII_BMCR);
+ 	u16 ctl = 0;
  
- 	ctl &= BMCR_LOOPBACK | BMCR_ISOLATE | BMCR_PDOWN;
  	phydev->pause = 0;
  	phydev->asym_pause = 0;
  
@@@ -854,9 -1381,10 +853,10 @@@
  	if (DUPLEX_FULL == phydev->duplex)
  		ctl |= BMCR_FULLDPLX;
  
- 	return phy_write(phydev, MII_BMCR, ctl);
+ 	return phy_modify(phydev, MII_BMCR,
+ 			  BMCR_LOOPBACK | BMCR_ISOLATE | BMCR_PDOWN, ctl);
  }
 -EXPORT_SYMBOL(genphy_setup_forced);
 +
  
  /**
   * genphy_restart_aneg - Enable and Restart Autonegotiation
@@@ -1189,28 -1664,40 +1172,61 @@@ int genphy_suspend(struct phy_device *p
  }
  EXPORT_SYMBOL(genphy_suspend);
  
 +static int gen10g_suspend(struct phy_device *phydev)
 +{
 +	return 0;
 +}
 +
  int genphy_resume(struct phy_device *phydev)
  {
++<<<<<<< HEAD
 +	int value;
 +
 +	mutex_lock(&phydev->lock);
 +
 +	value = phy_read(phydev, MII_BMCR);
 +	phy_write(phydev, MII_BMCR, value & ~BMCR_PDOWN);
 +
 +	mutex_unlock(&phydev->lock);
 +
 +	return 0;
++=======
+ 	return phy_modify(phydev, MII_BMCR, ~BMCR_PDOWN, 0);
++>>>>>>> fea23fb591cc (net: phy: convert read-modify-write to phy_modify())
  }
  EXPORT_SYMBOL(genphy_resume);
  
 -int genphy_loopback(struct phy_device *phydev, bool enable)
 +static int gen10g_resume(struct phy_device *phydev)
  {
++<<<<<<< HEAD
++=======
+ 	return phy_modify(phydev, MII_BMCR, ~BMCR_LOOPBACK,
+ 			  enable ? BMCR_LOOPBACK : 0);
+ }
+ EXPORT_SYMBOL(genphy_loopback);
+ 
+ static int __set_phy_supported(struct phy_device *phydev, u32 max_speed)
+ {
+ 	/* The default values for phydev->supported are provided by the PHY
+ 	 * driver "features" member, we want to reset to sane defaults first
+ 	 * before supporting higher speeds.
+ 	 */
+ 	phydev->supported &= PHY_DEFAULT_FEATURES;
+ 
+ 	switch (max_speed) {
+ 	default:
+ 		return -ENOTSUPP;
+ 	case SPEED_1000:
+ 		phydev->supported |= PHY_1000BT_FEATURES;
+ 		/* fall through */
+ 	case SPEED_100:
+ 		phydev->supported |= PHY_100BT_FEATURES;
+ 		/* fall through */
+ 	case SPEED_10:
+ 		phydev->supported |= PHY_10BT_FEATURES;
+ 	}
+ 
++>>>>>>> fea23fb591cc (net: phy: convert read-modify-write to phy_modify())
  	return 0;
  }
  
* Unmerged path drivers/net/phy/at803x.c
* Unmerged path drivers/net/phy/marvell.c
* Unmerged path drivers/net/phy/phy_device.c
