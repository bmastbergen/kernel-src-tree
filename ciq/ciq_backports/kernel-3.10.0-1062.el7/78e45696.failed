watchdog: iTCO_wdt: Use pdev for platform device and pci_dev for pci device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [watchdog] itco_wdt: Use pdev for platform device and pci_dev for pci device (David Arcari) [1645537]
Rebuild_FUZZ: 92.86%
commit-author Guenter Roeck <linux@roeck-us.net>
commit 78e45696d55c0754384f81e628b57b4e865a2478
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/78e45696.failed

Use pdev for struct platform_device, pci_dev for struct pci_dev, and dev
for struct device variables to improve consistency.

Remove 'struct platform_device *dev;' from struct iTCO_wdt_private since
it was unused.

	Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Guenter Roeck <linux@roeck-us.net>
(cherry picked from commit 78e45696d55c0754384f81e628b57b4e865a2478)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/watchdog/iTCO_wdt.c
diff --cc drivers/watchdog/iTCO_wdt.c
index 247fd1d7ca0d,9b60f4201c26..000000000000
--- a/drivers/watchdog/iTCO_wdt.c
+++ b/drivers/watchdog/iTCO_wdt.c
@@@ -102,12 -102,11 +102,11 @@@ static struct {		/* this is private dat
  	unsigned long __iomem *gcs_pmc;
  	/* the lock for io operations */
  	spinlock_t io_lock;
- 	struct platform_device *dev;
  	/* the PCI-device */
- 	struct pci_dev *pdev;
+ 	struct pci_dev *pci_dev;
  	/* whether or not the watchdog has been suspended */
  	bool suspended;
 -};
 +} iTCO_wdt_private;
  
  /* module parameters */
  #define WATCHDOG_TIMEOUT 30	/* 30 sec default heartbeat */
@@@ -174,14 -175,14 +173,25 @@@ static void iTCO_wdt_set_NO_REBOOT_bit(
  	u32 val32;
  
  	/* Set the NO_REBOOT bit: this disables reboots */
++<<<<<<< HEAD
 +	if (iTCO_wdt_private.iTCO_version >= 2) {
 +		val32 = readl(iTCO_wdt_private.gcs_pmc);
 +		val32 |= no_reboot_bit();
 +		writel(val32, iTCO_wdt_private.gcs_pmc);
 +	} else if (iTCO_wdt_private.iTCO_version == 1) {
 +		pci_read_config_dword(iTCO_wdt_private.pdev, 0xd4, &val32);
 +		val32 |= no_reboot_bit();
 +		pci_write_config_dword(iTCO_wdt_private.pdev, 0xd4, val32);
++=======
+ 	if (p->iTCO_version >= 2) {
+ 		val32 = readl(p->gcs_pmc);
+ 		val32 |= no_reboot_bit(p);
+ 		writel(val32, p->gcs_pmc);
+ 	} else if (p->iTCO_version == 1) {
+ 		pci_read_config_dword(p->pci_dev, 0xd4, &val32);
+ 		val32 |= no_reboot_bit(p);
+ 		pci_write_config_dword(p->pci_dev, 0xd4, val32);
++>>>>>>> 78e45696d55c (watchdog: iTCO_wdt: Use pdev for platform device and pci_dev for pci device)
  	}
  }
  
@@@ -191,18 -192,18 +201,28 @@@ static int iTCO_wdt_unset_NO_REBOOT_bit
  	u32 val32 = 0;
  
  	/* Unset the NO_REBOOT bit: this enables reboots */
 -	if (p->iTCO_version >= 2) {
 -		val32 = readl(p->gcs_pmc);
 +	if (iTCO_wdt_private.iTCO_version >= 2) {
 +		val32 = readl(iTCO_wdt_private.gcs_pmc);
  		val32 &= ~enable_bit;
 -		writel(val32, p->gcs_pmc);
 +		writel(val32, iTCO_wdt_private.gcs_pmc);
 +
++<<<<<<< HEAD
 +		val32 = readl(iTCO_wdt_private.gcs_pmc);
 +	} else if (iTCO_wdt_private.iTCO_version == 1) {
 +		pci_read_config_dword(iTCO_wdt_private.pdev, 0xd4, &val32);
 +		val32 &= ~enable_bit;
 +		pci_write_config_dword(iTCO_wdt_private.pdev, 0xd4, val32);
  
 +		pci_read_config_dword(iTCO_wdt_private.pdev, 0xd4, &val32);
++=======
+ 		val32 = readl(p->gcs_pmc);
+ 	} else if (p->iTCO_version == 1) {
+ 		pci_read_config_dword(p->pci_dev, 0xd4, &val32);
+ 		val32 &= ~enable_bit;
+ 		pci_write_config_dword(p->pci_dev, 0xd4, val32);
+ 
+ 		pci_read_config_dword(p->pci_dev, 0xd4, &val32);
++>>>>>>> 78e45696d55c (watchdog: iTCO_wdt: Use pdev for platform device and pci_dev for pci device)
  	}
  
  	if (val32 & enable_bit)
@@@ -398,80 -400,45 +418,117 @@@ static struct watchdog_device iTCO_wdt_
   *	Init & exit routines
   */
  
++<<<<<<< HEAD
 +static void iTCO_wdt_cleanup(void)
 +{
 +	/* Stop the timer before we leave */
 +	if (!nowayout)
 +		iTCO_wdt_stop(&iTCO_wdt_watchdog_dev);
 +
 +	/* Deregister */
 +	watchdog_unregister_device(&iTCO_wdt_watchdog_dev);
 +
 +	/* release resources */
 +	release_region(iTCO_wdt_private.tco_res->start,
 +			resource_size(iTCO_wdt_private.tco_res));
 +	release_region(iTCO_wdt_private.smi_res->start,
 +			resource_size(iTCO_wdt_private.smi_res));
 +	if (iTCO_wdt_private.iTCO_version >= 2) {
 +		iounmap(iTCO_wdt_private.gcs_pmc);
 +		release_mem_region(iTCO_wdt_private.gcs_pmc_res->start,
 +				resource_size(iTCO_wdt_private.gcs_pmc_res));
 +	}
 +
 +	iTCO_wdt_private.tco_res = NULL;
 +	iTCO_wdt_private.smi_res = NULL;
 +	iTCO_wdt_private.gcs_pmc_res = NULL;
 +	iTCO_wdt_private.gcs_pmc = NULL;
 +}
 +
 +static int iTCO_wdt_probe(struct platform_device *dev)
 +{
 +	int ret = -ENODEV;
++=======
+ static int iTCO_wdt_probe(struct platform_device *pdev)
+ {
+ 	struct device *dev = &pdev->dev;
+ 	struct itco_wdt_platform_data *pdata = dev_get_platdata(dev);
+ 	struct iTCO_wdt_private *p;
++>>>>>>> 78e45696d55c (watchdog: iTCO_wdt: Use pdev for platform device and pci_dev for pci device)
  	unsigned long val32;
 -	int ret;
 +	struct itco_wdt_platform_data *pdata = dev->dev.platform_data;
  
  	if (!pdata)
 -		return -ENODEV;
 +		goto out;
  
++<<<<<<< HEAD
 +	spin_lock_init(&iTCO_wdt_private.io_lock);
++=======
+ 	p = devm_kzalloc(dev, sizeof(*p), GFP_KERNEL);
+ 	if (!p)
+ 		return -ENOMEM;
 -
 -	spin_lock_init(&p->io_lock);
 -
++>>>>>>> 78e45696d55c (watchdog: iTCO_wdt: Use pdev for platform device and pci_dev for pci device)
 +
 +	iTCO_wdt_private.tco_res =
 +		platform_get_resource(dev, IORESOURCE_IO, ICH_RES_IO_TCO);
 +	if (!iTCO_wdt_private.tco_res)
 +		goto out;
 +
++<<<<<<< HEAD
 +	iTCO_wdt_private.smi_res =
 +		platform_get_resource(dev, IORESOURCE_IO, ICH_RES_IO_SMI);
 +	if (!iTCO_wdt_private.smi_res)
 +		goto out;
 +
 +	iTCO_wdt_private.iTCO_version = pdata->version;
 +	iTCO_wdt_private.dev = dev;
 +	iTCO_wdt_private.pdev = to_pci_dev(dev->dev.parent);
++=======
+ 	p->tco_res = platform_get_resource(pdev, IORESOURCE_IO, ICH_RES_IO_TCO);
+ 	if (!p->tco_res)
+ 		return -ENODEV;
+ 
+ 	p->smi_res = platform_get_resource(pdev, IORESOURCE_IO, ICH_RES_IO_SMI);
+ 	if (!p->smi_res)
+ 		return -ENODEV;
+ 
+ 	p->iTCO_version = pdata->version;
+ 	p->pci_dev = to_pci_dev(dev->parent);
++>>>>>>> 78e45696d55c (watchdog: iTCO_wdt: Use pdev for platform device and pci_dev for pci device)
  
  	/*
  	 * Get the Memory-Mapped GCS or PMC register, we need it for the
  	 * NO_REBOOT flag (TCO v2 and v3).
  	 */
++<<<<<<< HEAD
 +	if (iTCO_wdt_private.iTCO_version >= 2) {
 +		iTCO_wdt_private.gcs_pmc_res = platform_get_resource(dev,
 +							IORESOURCE_MEM,
 +							ICH_RES_MEM_GCS_PMC);
 +
 +		if (!iTCO_wdt_private.gcs_pmc_res)
 +			goto out;
 +
 +		if (!request_mem_region(iTCO_wdt_private.gcs_pmc_res->start,
 +			resource_size(iTCO_wdt_private.gcs_pmc_res), dev->name)) {
 +			ret = -EBUSY;
 +			goto out;
 +		}
 +		iTCO_wdt_private.gcs_pmc = ioremap(iTCO_wdt_private.gcs_pmc_res->start,
 +			resource_size(iTCO_wdt_private.gcs_pmc_res));
 +		if (!iTCO_wdt_private.gcs_pmc) {
 +			ret = -EIO;
 +			goto unreg_gcs_pmc;
 +		}
++=======
+ 	if (p->iTCO_version >= 2) {
+ 		p->gcs_pmc_res = platform_get_resource(pdev,
+ 						       IORESOURCE_MEM,
+ 						       ICH_RES_MEM_GCS_PMC);
+ 		p->gcs_pmc = devm_ioremap_resource(dev, p->gcs_pmc_res);
+ 		if (IS_ERR(p->gcs_pmc))
+ 			return PTR_ERR(p->gcs_pmc);
++>>>>>>> 78e45696d55c (watchdog: iTCO_wdt: Use pdev for platform device and pci_dev for pci device)
  	}
  
  	/* Check chipset's NO_REBOOT bit */
@@@ -482,32 -449,32 +539,44 @@@
  	}
  
  	/* Set the NO_REBOOT bit to prevent later reboots, just for sure */
 -	iTCO_wdt_set_NO_REBOOT_bit(p);
 +	iTCO_wdt_set_NO_REBOOT_bit();
  
  	/* The TCO logic uses the TCO_EN bit in the SMI_EN register */
++<<<<<<< HEAD
 +	if (!request_region(iTCO_wdt_private.smi_res->start,
 +			resource_size(iTCO_wdt_private.smi_res), dev->name)) {
++=======
+ 	if (!devm_request_region(dev, p->smi_res->start,
+ 				 resource_size(p->smi_res),
+ 				 pdev->name)) {
++>>>>>>> 78e45696d55c (watchdog: iTCO_wdt: Use pdev for platform device and pci_dev for pci device)
  		pr_err("I/O address 0x%04llx already in use, device disabled\n",
 -		       (u64)SMI_EN(p));
 -		return -EBUSY;
 +		       (u64)SMI_EN);
 +		ret = -EBUSY;
 +		goto unmap_gcs_pmc;
  	}
 -	if (turn_SMI_watchdog_clear_off >= p->iTCO_version) {
 +	if (turn_SMI_watchdog_clear_off >= iTCO_wdt_private.iTCO_version) {
  		/*
  		 * Bit 13: TCO_EN -> 0
  		 * Disables TCO logic generating an SMI#
  		 */
 -		val32 = inl(SMI_EN(p));
 +		val32 = inl(SMI_EN);
  		val32 &= 0xffffdfff;	/* Turn off SMI clearing watchdog */
 -		outl(val32, SMI_EN(p));
 +		outl(val32, SMI_EN);
  	}
  
++<<<<<<< HEAD
 +	if (!request_region(iTCO_wdt_private.tco_res->start,
 +			resource_size(iTCO_wdt_private.tco_res), dev->name)) {
++=======
+ 	if (!devm_request_region(dev, p->tco_res->start,
+ 				 resource_size(p->tco_res),
+ 				 pdev->name)) {
++>>>>>>> 78e45696d55c (watchdog: iTCO_wdt: Use pdev for platform device and pci_dev for pci device)
  		pr_err("I/O address 0x%04llx already in use, device disabled\n",
 -		       (u64)TCOBASE(p));
 -		return -EBUSY;
 +		       (u64)TCOBASE);
 +		ret = -EBUSY;
 +		goto unreg_smi;
  	}
  
  	pr_info("Found a %s TCO device (Version=%d, TCOBASE=0x%04llx)\n",
@@@ -532,13 -499,18 +601,25 @@@
  		break;
  	}
  
++<<<<<<< HEAD
 +	iTCO_wdt_watchdog_dev.bootstatus = 0;
 +	iTCO_wdt_watchdog_dev.timeout = WATCHDOG_TIMEOUT;
 +	watchdog_set_nowayout(&iTCO_wdt_watchdog_dev, nowayout);
 +	iTCO_wdt_watchdog_dev.parent = &dev->dev;
++=======
+ 	p->wddev.info =	&ident,
+ 	p->wddev.ops = &iTCO_wdt_ops,
+ 	p->wddev.bootstatus = 0;
+ 	p->wddev.timeout = WATCHDOG_TIMEOUT;
+ 	watchdog_set_nowayout(&p->wddev, nowayout);
+ 	p->wddev.parent = dev;
+ 
+ 	watchdog_set_drvdata(&p->wddev, p);
+ 	platform_set_drvdata(pdev, p);
++>>>>>>> 78e45696d55c (watchdog: iTCO_wdt: Use pdev for platform device and pci_dev for pci device)
  
  	/* Make sure the watchdog is not running */
 -	iTCO_wdt_stop(&p->wddev);
 +	iTCO_wdt_stop(&iTCO_wdt_watchdog_dev);
  
  	/* Check that the heartbeat value is within it's range;
  	   if not reset to the default */
@@@ -548,50 -520,34 +629,68 @@@
  			WATCHDOG_TIMEOUT);
  	}
  
++<<<<<<< HEAD
 +	ret = watchdog_register_device(&iTCO_wdt_watchdog_dev);
++=======
+ 	ret = devm_watchdog_register_device(dev, &p->wddev);
++>>>>>>> 78e45696d55c (watchdog: iTCO_wdt: Use pdev for platform device and pci_dev for pci device)
  	if (ret != 0) {
  		pr_err("cannot register watchdog device (err=%d)\n", ret);
 -		return ret;
 +		goto unreg_tco;
  	}
  
  	pr_info("initialized. heartbeat=%d sec (nowayout=%d)\n",
  		heartbeat, nowayout);
  
  	return 0;
 +
 +unreg_tco:
 +	release_region(iTCO_wdt_private.tco_res->start,
 +			resource_size(iTCO_wdt_private.tco_res));
 +unreg_smi:
 +	release_region(iTCO_wdt_private.smi_res->start,
 +			resource_size(iTCO_wdt_private.smi_res));
 +unmap_gcs_pmc:
 +	if (iTCO_wdt_private.iTCO_version >= 2)
 +		iounmap(iTCO_wdt_private.gcs_pmc);
 +unreg_gcs_pmc:
 +	if (iTCO_wdt_private.iTCO_version >= 2)
 +		release_mem_region(iTCO_wdt_private.gcs_pmc_res->start,
 +				resource_size(iTCO_wdt_private.gcs_pmc_res));
 +out:
 +	iTCO_wdt_private.tco_res = NULL;
 +	iTCO_wdt_private.smi_res = NULL;
 +	iTCO_wdt_private.gcs_pmc_res = NULL;
 +	iTCO_wdt_private.gcs_pmc = NULL;
 +
 +	return ret;
  }
  
- static int iTCO_wdt_remove(struct platform_device *dev)
+ static int iTCO_wdt_remove(struct platform_device *pdev)
  {
++<<<<<<< HEAD
 +	if (iTCO_wdt_private.tco_res || iTCO_wdt_private.smi_res)
 +		iTCO_wdt_cleanup();
++=======
+ 	struct iTCO_wdt_private *p = platform_get_drvdata(pdev);
+ 
+ 	/* Stop the timer before we leave */
+ 	if (!nowayout)
+ 		iTCO_wdt_stop(&p->wddev);
++>>>>>>> 78e45696d55c (watchdog: iTCO_wdt: Use pdev for platform device and pci_dev for pci device)
  
  	return 0;
  }
  
- static void iTCO_wdt_shutdown(struct platform_device *dev)
+ static void iTCO_wdt_shutdown(struct platform_device *pdev)
  {
++<<<<<<< HEAD
 +	iTCO_wdt_stop(NULL);
++=======
+ 	struct iTCO_wdt_private *p = platform_get_drvdata(pdev);
+ 
+ 	iTCO_wdt_stop(&p->wddev);
++>>>>>>> 78e45696d55c (watchdog: iTCO_wdt: Use pdev for platform device and pci_dev for pci device)
  }
  
  #ifdef CONFIG_PM_SLEEP
* Unmerged path drivers/watchdog/iTCO_wdt.c
