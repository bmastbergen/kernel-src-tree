net: phy: provide full set of accessor functions to MMD registers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [kernel] phy: provide full set of accessor functions to MMD registers (Ivan Vecera) [1685646]
Rebuild_FUZZ: 96.00%
commit-author Nikita Yushchenko <nikita.yoush@cogentembedded.com>
commit 1878f0dcbff0cd07f62602deb160a44d69a8f146
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/1878f0dc.failed

This adds full set of locked and unlocked accessor functions to read and
write PHY MMD registers and/or bitfields.

Set of functions exactly matches what is already available for PHY
legacy registers.

	Signed-off-by: Nikita Yushchenko <nikita.yoush@cogentembedded.com>
	Signed-off-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1878f0dcbff0cd07f62602deb160a44d69a8f146)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/phy-core.c
#	include/linux/phy.h
diff --cc include/linux/phy.h
index 2a7a15321caa,237dd035858a..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -546,25 -650,49 +546,28 @@@ struct phy_fixup 
  	int (*run)(struct phy_device *phydev);
  };
  
 -const char *phy_speed_to_str(int speed);
 -const char *phy_duplex_to_str(unsigned int duplex);
 -
 -/* A structure for mapping a particular speed and duplex
 - * combination to a particular SUPPORTED and ADVERTISED value
 - */
 -struct phy_setting {
 -	u32 speed;
 -	u8 duplex;
 -	u8 bit;
 -};
 -
 -const struct phy_setting *
 -phy_lookup_setting(int speed, int duplex, const unsigned long *mask,
 -		   bool exact);
 -size_t phy_speeds(unsigned int *speeds, size_t size,
 -		  unsigned long *mask);
 -
 -static inline bool __phy_is_started(struct phy_device *phydev)
 -{
 -	WARN_ON(!mutex_is_locked(&phydev->lock));
 -
 -	return phydev->state >= PHY_UP;
 -}
 -
  /**
 - * phy_is_started - Convenience function to check whether PHY is started
++<<<<<<< HEAD
 + * phy_read_mmd - Convenience function for reading a register
 + * from an MMD on a given PHY.
   * @phydev: The phy_device struct
 + * @devad: The MMD to read from
 + * @regnum: The register on the MMD to read
 + *
 + * Same rules as for phy_read();
   */
 -static inline bool phy_is_started(struct phy_device *phydev)
 +static inline int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum)
  {
 -	bool started;
 -
 -	mutex_lock(&phydev->lock);
 -	started = __phy_is_started(phydev);
 -	mutex_unlock(&phydev->lock);
 +	if (!phydev->is_c45)
 +		return -EOPNOTSUPP;
  
 -	return started;
 +	return mdiobus_read(phydev->bus, phydev->addr,
 +			    MII_ADDR_C45 | (devad << 16) | (regnum & 0xffff));
  }
  
 -void phy_resolve_aneg_linkmode(struct phy_device *phydev);
 -
  /**
++=======
++>>>>>>> 1878f0dcbff0 (net: phy: provide full set of accessor functions to MMD registers)
   * phy_read - Convenience function for reading a given PHY register
   * @phydev: the phy_device struct
   * @regnum: register number to read
@@@ -590,7 -730,184 +593,188 @@@ static inline int phy_read(struct phy_d
   */
  static inline int phy_write(struct phy_device *phydev, u32 regnum, u16 val)
  {
++<<<<<<< HEAD
 +	return mdiobus_write(phydev->bus, phydev->addr, regnum, val);
++=======
+ 	return mdiobus_write(phydev->mdio.bus, phydev->mdio.addr, regnum, val);
+ }
+ 
+ /**
+  * __phy_write - Convenience function for writing a given PHY register
+  * @phydev: the phy_device struct
+  * @regnum: register number to write
+  * @val: value to write to @regnum
+  *
+  * The caller must have taken the MDIO bus lock.
+  */
+ static inline int __phy_write(struct phy_device *phydev, u32 regnum, u16 val)
+ {
+ 	return __mdiobus_write(phydev->mdio.bus, phydev->mdio.addr, regnum,
+ 			       val);
+ }
+ 
+ /**
+  * phy_read_mmd - Convenience function for reading a register
+  * from an MMD on a given PHY.
+  * @phydev: The phy_device struct
+  * @devad: The MMD to read from
+  * @regnum: The register on the MMD to read
+  *
+  * Same rules as for phy_read();
+  */
+ int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum);
+ 
+ /**
+  * __phy_read_mmd - Convenience function for reading a register
+  * from an MMD on a given PHY.
+  * @phydev: The phy_device struct
+  * @devad: The MMD to read from
+  * @regnum: The register on the MMD to read
+  *
+  * Same rules as for __phy_read();
+  */
+ int __phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum);
+ 
+ /**
+  * phy_write_mmd - Convenience function for writing a register
+  * on an MMD on a given PHY.
+  * @phydev: The phy_device struct
+  * @devad: The MMD to write to
+  * @regnum: The register on the MMD to read
+  * @val: value to write to @regnum
+  *
+  * Same rules as for phy_write();
+  */
+ int phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val);
+ 
+ /**
+  * __phy_write_mmd - Convenience function for writing a register
+  * on an MMD on a given PHY.
+  * @phydev: The phy_device struct
+  * @devad: The MMD to write to
+  * @regnum: The register on the MMD to read
+  * @val: value to write to @regnum
+  *
+  * Same rules as for __phy_write();
+  */
+ int __phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val);
+ 
+ int __phy_modify(struct phy_device *phydev, u32 regnum, u16 mask, u16 set);
+ int phy_modify(struct phy_device *phydev, u32 regnum, u16 mask, u16 set);
+ 
+ int __phy_modify_mmd(struct phy_device *phydev, int devad, u32 regnum,
+ 		u16 mask, u16 set);
+ int phy_modify_mmd(struct phy_device *phydev, int devad, u32 regnum,
+ 		u16 mask, u16 set);
+ 
+ /**
+  * __phy_set_bits - Convenience function for setting bits in a PHY register
+  * @phydev: the phy_device struct
+  * @regnum: register number to write
+  * @val: bits to set
+  *
+  * The caller must have taken the MDIO bus lock.
+  */
+ static inline int __phy_set_bits(struct phy_device *phydev, u32 regnum, u16 val)
+ {
+ 	return __phy_modify(phydev, regnum, 0, val);
+ }
+ 
+ /**
+  * __phy_clear_bits - Convenience function for clearing bits in a PHY register
+  * @phydev: the phy_device struct
+  * @regnum: register number to write
+  * @val: bits to clear
+  *
+  * The caller must have taken the MDIO bus lock.
+  */
+ static inline int __phy_clear_bits(struct phy_device *phydev, u32 regnum,
+ 				   u16 val)
+ {
+ 	return __phy_modify(phydev, regnum, val, 0);
+ }
+ 
+ /**
+  * phy_set_bits - Convenience function for setting bits in a PHY register
+  * @phydev: the phy_device struct
+  * @regnum: register number to write
+  * @val: bits to set
+  */
+ static inline int phy_set_bits(struct phy_device *phydev, u32 regnum, u16 val)
+ {
+ 	return phy_modify(phydev, regnum, 0, val);
+ }
+ 
+ /**
+  * phy_clear_bits - Convenience function for clearing bits in a PHY register
+  * @phydev: the phy_device struct
+  * @regnum: register number to write
+  * @val: bits to clear
+  */
+ static inline int phy_clear_bits(struct phy_device *phydev, u32 regnum, u16 val)
+ {
+ 	return phy_modify(phydev, regnum, val, 0);
++>>>>>>> 1878f0dcbff0 (net: phy: provide full set of accessor functions to MMD registers)
+ }
+ 
+ /**
+  * __phy_set_bits_mmd - Convenience function for setting bits in a register
+  * on MMD
+  * @phydev: the phy_device struct
+  * @devad: the MMD containing register to modify
+  * @regnum: register number to modify
+  * @val: bits to set
+  *
+  * The caller must have taken the MDIO bus lock.
+  */
+ static inline int __phy_set_bits_mmd(struct phy_device *phydev, int devad,
+ 		u32 regnum, u16 val)
+ {
+ 	return __phy_modify_mmd(phydev, devad, regnum, 0, val);
+ }
+ 
+ /**
+  * __phy_clear_bits_mmd - Convenience function for clearing bits in a register
+  * on MMD
+  * @phydev: the phy_device struct
+  * @devad: the MMD containing register to modify
+  * @regnum: register number to modify
+  * @val: bits to clear
+  *
+  * The caller must have taken the MDIO bus lock.
+  */
+ static inline int __phy_clear_bits_mmd(struct phy_device *phydev, int devad,
+ 		u32 regnum, u16 val)
+ {
+ 	return __phy_modify_mmd(phydev, devad, regnum, val, 0);
+ }
+ 
+ /**
+  * phy_set_bits_mmd - Convenience function for setting bits in a register
+  * on MMD
+  * @phydev: the phy_device struct
+  * @devad: the MMD containing register to modify
+  * @regnum: register number to modify
+  * @val: bits to set
+  */
+ static inline int phy_set_bits_mmd(struct phy_device *phydev, int devad,
+ 		u32 regnum, u16 val)
+ {
+ 	return phy_modify_mmd(phydev, devad, regnum, 0, val);
+ }
+ 
+ /**
+  * phy_clear_bits_mmd - Convenience function for clearing bits in a register
+  * on MMD
+  * @phydev: the phy_device struct
+  * @devad: the MMD containing register to modify
+  * @regnum: register number to modify
+  * @val: bits to clear
+  */
+ static inline int phy_clear_bits_mmd(struct phy_device *phydev, int devad,
+ 		u32 regnum, u16 val)
+ {
+ 	return phy_modify_mmd(phydev, devad, regnum, val, 0);
  }
  
  /**
@@@ -615,25 -942,57 +799,79 @@@ static inline bool phy_is_internal(stru
  }
  
  /**
++<<<<<<< HEAD
 + * phy_write_mmd - Convenience function for writing a register
 + * on an MMD on a given PHY.
 + * @phydev: The phy_device struct
 + * @devad: The MMD to read from
 + * @regnum: The register on the MMD to read
 + * @val: value to write to @regnum
 + *
 + * Same rules as for phy_write();
 + */
 +static inline int phy_write_mmd(struct phy_device *phydev, int devad,
 +				u32 regnum, u16 val)
 +{
 +	if (!phydev->is_c45)
 +		return -EOPNOTSUPP;
 +
 +	regnum = MII_ADDR_C45 | ((devad & 0x1f) << 16) | (regnum & 0xffff);
 +
 +	return mdiobus_write(phydev->bus, phydev->addr, regnum, val);
 +}
++=======
+  * phy_interface_mode_is_rgmii - Convenience function for testing if a
+  * PHY interface mode is RGMII (all variants)
+  * @mode: the phy_interface_t enum
+  */
+ static inline bool phy_interface_mode_is_rgmii(phy_interface_t mode)
+ {
+ 	return mode >= PHY_INTERFACE_MODE_RGMII &&
+ 		mode <= PHY_INTERFACE_MODE_RGMII_TXID;
+ };
+ 
+ /**
+  * phy_interface_mode_is_8023z() - does the phy interface mode use 802.3z
+  *   negotiation
+  * @mode: one of &enum phy_interface_t
+  *
+  * Returns true if the phy interface mode uses the 16-bit negotiation
+  * word as defined in 802.3z. (See 802.3-2015 37.2.1 Config_Reg encoding)
+  */
+ static inline bool phy_interface_mode_is_8023z(phy_interface_t mode)
+ {
+ 	return mode == PHY_INTERFACE_MODE_1000BASEX ||
+ 	       mode == PHY_INTERFACE_MODE_2500BASEX;
+ }
+ 
+ /**
+  * phy_interface_is_rgmii - Convenience function for testing if a PHY interface
+  * is RGMII (all variants)
+  * @phydev: the phy_device struct
+  */
+ static inline bool phy_interface_is_rgmii(struct phy_device *phydev)
+ {
+ 	return phy_interface_mode_is_rgmii(phydev->interface);
+ };
+ 
+ /*
+  * phy_is_pseudo_fixed_link - Convenience function for testing if this
+  * PHY is the CPU port facing side of an Ethernet switch, or similar.
+  * @phydev: the phy_device struct
+  */
+ static inline bool phy_is_pseudo_fixed_link(struct phy_device *phydev)
+ {
+ 	return phydev->is_pseudo_fixed_link;
+ }
+ 
+ int phy_save_page(struct phy_device *phydev);
+ int phy_select_page(struct phy_device *phydev, int page);
+ int phy_restore_page(struct phy_device *phydev, int oldpage, int ret);
+ int phy_read_paged(struct phy_device *phydev, int page, u32 regnum);
+ int phy_write_paged(struct phy_device *phydev, int page, u32 regnum, u16 val);
+ int phy_modify_paged(struct phy_device *phydev, int page, u32 regnum,
+ 		     u16 mask, u16 set);
++>>>>>>> 1878f0dcbff0 (net: phy: provide full set of accessor functions to MMD registers)
  
  struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
  				     bool is_c45,
* Unmerged path drivers/net/phy/phy-core.c
* Unmerged path drivers/net/phy/phy-core.c
* Unmerged path include/linux/phy.h
