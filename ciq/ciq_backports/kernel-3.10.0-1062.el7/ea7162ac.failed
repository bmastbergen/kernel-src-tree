net/mlx5e: Refactor VXLAN tunnel encap offloading code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Refactor VXLAN tunnel encap offloading code (Alaa Hleihel) [1642362 1642498]
Rebuild_FUZZ: 96.15%
commit-author Oz Shlomo <ozsh@mellanox.com>
commit ea7162ac3a33a44a7bb0b5793057015d25617e68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ea7162ac.failed

Separates the vxlan header encap logic from the general ipv4/6
encapsulation methods, thus allowing the common IP encap/decap code to
branch in downstream patch to multiple IP tunnels.

Code refactoring with no functional change.

	Signed-off-by: Oz Shlomo <ozsh@mellanox.com>
	Reviewed-by: Eli Britstein <elibr@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit ea7162ac3a33a44a7bb0b5793057015d25617e68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index fbb4f1b36627,ed04ab8287e9..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -2285,19 -2465,7 +2244,23 @@@ static int mlx5e_create_encap_header_ip
  	if (!encap_header)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	switch (e->tunnel_type) {
 +	case MLX5_HEADER_TYPE_VXLAN:
 +		fl4.flowi4_proto = IPPROTO_UDP;
 +		fl4.fl4_dport = tun_key->tp_dst;
 +		break;
 +	default:
 +		err = -EOPNOTSUPP;
 +		goto free_encap;
 +	}
 +
 +	tos = tun_key->tos;
 +	ttl = tun_key->ttl;
 +
++=======
+ 	/* add the IP fields */
++>>>>>>> ea7162ac3a33 (net/mlx5e: Refactor VXLAN tunnel encap offloading code)
  	fl4.flowi4_tos = tun_key->tos;
  	fl4.daddr = tun_key->u.ipv4.dst;
  	fl4.saddr = tun_key->u.ipv4.src;
@@@ -2329,18 -2498,27 +2293,40 @@@
  	ether_addr_copy(e->h_dest, n->ha);
  	read_unlock_bh(&n->lock);
  
++<<<<<<< HEAD
 +	switch (e->tunnel_type) {
 +	case MLX5_HEADER_TYPE_VXLAN:
 +		gen_vxlan_header_ipv4(out_dev, encap_header,
 +				      ipv4_encap_size, e->h_dest, tos, ttl,
 +				      fl4.daddr,
 +				      fl4.saddr, tun_key->tp_dst,
 +				      tunnel_id_to_key32(tun_key->tun_id));
 +		break;
 +	default:
 +		err = -EOPNOTSUPP;
++=======
+ 	/* add ethernet header */
+ 	eth = (struct ethhdr *)encap_header;
+ 	ether_addr_copy(eth->h_dest, e->h_dest);
+ 	ether_addr_copy(eth->h_source, out_dev->dev_addr);
+ 	eth->h_proto = htons(ETH_P_IP);
+ 
+ 	/* add ip header */
+ 	ip = (struct iphdr *)((char *)eth + sizeof(struct ethhdr));
+ 	ip->tos = tun_key->tos;
+ 	ip->version = 0x4;
+ 	ip->ihl = 0x5;
+ 	ip->ttl = ttl;
+ 	ip->daddr = fl4.daddr;
+ 	ip->saddr = fl4.saddr;
+ 
+ 	/* add tunneling protocol header */
+ 	err = mlx5e_gen_ip_tunnel_header((char *)ip + sizeof(struct iphdr),
+ 					 &ip->protocol, tun_key);
+ 	if (err)
++>>>>>>> ea7162ac3a33 (net/mlx5e: Refactor VXLAN tunnel encap offloading code)
  		goto destroy_neigh_entry;
- 	}
+ 
  	e->encap_size = ipv4_encap_size;
  	e->encap_header = encap_header;
  
@@@ -2394,17 -2578,6 +2384,20 @@@ static int mlx5e_create_encap_header_ip
  	if (!encap_header)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	switch (e->tunnel_type) {
 +	case MLX5_HEADER_TYPE_VXLAN:
 +		fl6.flowi6_proto = IPPROTO_UDP;
 +		fl6.fl6_dport = tun_key->tp_dst;
 +		break;
 +	default:
 +		err = -EOPNOTSUPP;
 +		goto free_encap;
 +	}
 +
 +	tos = tun_key->tos;
++=======
++>>>>>>> ea7162ac3a33 (net/mlx5e: Refactor VXLAN tunnel encap offloading code)
  	ttl = tun_key->ttl;
  
  	fl6.flowlabel = ip6_make_flowinfo(RT_TOS(tun_key->tos), tun_key->label);
@@@ -2438,18 -2611,25 +2431,38 @@@
  	ether_addr_copy(e->h_dest, n->ha);
  	read_unlock_bh(&n->lock);
  
++<<<<<<< HEAD
 +	switch (e->tunnel_type) {
 +	case MLX5_HEADER_TYPE_VXLAN:
 +		gen_vxlan_header_ipv6(out_dev, encap_header,
 +				      ipv6_encap_size, e->h_dest, tos, ttl,
 +				      &fl6.daddr,
 +				      &fl6.saddr, tun_key->tp_dst,
 +				      tunnel_id_to_key32(tun_key->tun_id));
 +		break;
 +	default:
 +		err = -EOPNOTSUPP;
++=======
+ 	/* add ethernet header */
+ 	eth = (struct ethhdr *)encap_header;
+ 	ether_addr_copy(eth->h_dest, e->h_dest);
+ 	ether_addr_copy(eth->h_source, out_dev->dev_addr);
+ 	eth->h_proto = htons(ETH_P_IPV6);
+ 
+ 	/* add ip header */
+ 	ip6h = (struct ipv6hdr *)((char *)eth + sizeof(struct ethhdr));
+ 	ip6_flow_hdr(ip6h, tun_key->tos, 0);
+ 	/* the HW fills up ipv6 payload len */
+ 	ip6h->hop_limit   = ttl;
+ 	ip6h->daddr	  = fl6.daddr;
+ 	ip6h->saddr	  = fl6.saddr;
+ 
+ 	/* add tunneling protocol header */
+ 	err = mlx5e_gen_ip_tunnel_header((char *)ip6h + sizeof(struct ipv6hdr),
+ 					 &ip6h->nexthdr, tun_key);
+ 	if (err)
++>>>>>>> ea7162ac3a33 (net/mlx5e: Refactor VXLAN tunnel encap offloading code)
  		goto destroy_neigh_entry;
- 	}
  
  	e->encap_size = ipv6_encap_size;
  	e->encap_header = encap_header;
@@@ -2509,15 -2688,11 +2522,21 @@@ static int mlx5e_attach_encap(struct ml
  	uintptr_t hash_key;
  	bool found = false;
  
++<<<<<<< HEAD
 +	/* udp dst port must be set */
 +	if (!memchr_inv(&key->tp_dst, 0, sizeof(key->tp_dst)))
 +		goto vxlan_encap_offload_err;
 +
 +	/* setting udp src port isn't supported */
 +	if (memchr_inv(&key->tp_src, 0, sizeof(key->tp_src))) {
 +vxlan_encap_offload_err:
++=======
+ 	if (!MLX5_CAP_ESW(priv->mdev, vxlan_encap_decap)) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "vxlan HW offloading is not supported");
++>>>>>>> ea7162ac3a33 (net/mlx5e: Refactor VXLAN tunnel encap offloading code)
  		netdev_warn(priv->netdev,
- 			    "must set udp dst port and not set udp src port\n");
+ 			    "vxlan HW offloading is not supported\n");
  		return -EOPNOTSUPP;
  	}
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
