ext4: correctly detect when an xattr value has an invalid size

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Eric Biggers <ebiggers@google.com>
commit d7614cc16146e3f0b4c33e71875c19607602aed5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/d7614cc1.failed

It was possible for an xattr value to have a very large size, which
would then pass validation on 32-bit architectures due to a pointer
wraparound.  Fix this by validating the size in a way which avoids
pointer wraparound.

It was also possible that a value's size would fit in the available
space but its padded size would not.  This would cause an out-of-bounds
memory write in ext4_xattr_set_entry when replacing the xattr value.
For example, if an xattr value of unpadded size 253 bytes went until the
very end of the inode or block, then using setxattr(2) to replace this
xattr's value with 256 bytes would cause a write to the 3 bytes past the
end of the inode or buffer, and the new xattr value would be incorrectly
truncated.  Fix this by requiring that the padded size fit in the
available space rather than the unpadded size.

This patch shouldn't have any noticeable effect on
non-corrupted/non-malicious filesystems.

	Signed-off-by: Eric Biggers <ebiggers@google.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit d7614cc16146e3f0b4c33e71875c19607602aed5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/xattr.c
diff --cc fs/ext4/xattr.c
index ef6e269c5f10,5a94fa52b74f..000000000000
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@@ -202,12 -197,25 +204,34 @@@ ext4_xattr_check_names(struct ext4_xatt
  	while (!IS_LAST_ENTRY(entry)) {
  		if (entry->e_value_block != 0)
  			return -EFSCORRUPTED;
++<<<<<<< HEAD
 +		if (entry->e_value_size != 0 &&
 +		    (value_start + le16_to_cpu(entry->e_value_offs) <
 +		     (void *)e + sizeof(__u32) ||
 +		     value_start + le16_to_cpu(entry->e_value_offs) +
 +		    le32_to_cpu(entry->e_value_size) > end))
 +			return -EIO;
++=======
+ 		if (entry->e_value_size != 0) {
+ 			u16 offs = le16_to_cpu(entry->e_value_offs);
+ 			u32 size = le32_to_cpu(entry->e_value_size);
+ 			void *value;
+ 
+ 			/*
+ 			 * The value cannot overlap the names, and the value
+ 			 * with padding cannot extend beyond 'end'.  Check both
+ 			 * the padded and unpadded sizes, since the size may
+ 			 * overflow to 0 when adding padding.
+ 			 */
+ 			if (offs > end - value_start)
+ 				return -EFSCORRUPTED;
+ 			value = value_start + offs;
+ 			if (value < (void *)e + sizeof(u32) ||
+ 			    size > end - value ||
+ 			    EXT4_XATTR_SIZE(size) > end - value)
+ 				return -EFSCORRUPTED;
+ 		}
++>>>>>>> d7614cc16146 (ext4: correctly detect when an xattr value has an invalid size)
  		entry = EXT4_XATTR_NEXT(entry);
  	}
  
* Unmerged path fs/ext4/xattr.c
