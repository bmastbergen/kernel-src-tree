nfp: flower: increase scope of netdev checking functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author John Hurley <john.hurley@netronome.com>
commit 65b7970edf870c8b52fb2f3e847a9a4f0720a019
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/65b7970e.failed

Both the actions and tunnel_conf files contain local functions that check
the type of an input netdev. In preparation for re-use with tunnel offload
via indirect blocks, move these to static inline functions in a header
file.

	Signed-off-by: John Hurley <john.hurley@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 65b7970edf870c8b52fb2f3e847a9a4f0720a019)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/flower/action.c
diff --cc drivers/net/ethernet/netronome/nfp/flower/action.c
index 8dead3a52f6d,8d54b36afee8..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/action.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/action.c
@@@ -1,40 -1,10 +1,39 @@@
 -// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 -/* Copyright (C) 2017-2018 Netronome Systems, Inc. */
 +/*
 + * Copyright (C) 2017 Netronome Systems, Inc.
 + *
 + * This software is dual licensed under the GNU General License Version 2,
 + * June 1991 as shown in the file COPYING in the top-level directory of this
 + * source tree or the BSD 2-Clause License provided below.  You have the
 + * option to license this software under the complete terms of either license.
 + *
 + * The BSD 2-Clause License:
 + *
 + *     Redistribution and use in source and binary forms, with or
 + *     without modification, are permitted provided that the following
 + *     conditions are met:
 + *
 + *      1. Redistributions of source code must retain the above
 + *         copyright notice, this list of conditions and the following
 + *         disclaimer.
 + *
 + *      2. Redistributions in binary form must reproduce the above
 + *         copyright notice, this list of conditions and the following
 + *         disclaimer in the documentation and/or other materials
 + *         provided with the distribution.
 + *
 + * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 + * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 + * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 + * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 + * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 + * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 + * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 + * SOFTWARE.
 + */
  
  #include <linux/bitfield.h>
- #include <net/geneve.h>
  #include <net/pkt_cls.h>
  #include <net/switchdev.h>
 -#include <net/tc_act/tc_csum.h>
  #include <net/tc_act/tc_gact.h>
  #include <net/tc_act/tc_mirred.h>
  #include <net/tc_act/tc_pedit.h>
@@@ -85,16 -54,40 +83,53 @@@ nfp_fl_push_vlan(struct nfp_fl_push_vla
  	push_vlan->vlan_tci = cpu_to_be16(tmp_push_vlan_tci);
  }
  
++<<<<<<< HEAD
 +static bool nfp_fl_netdev_is_tunnel_type(struct net_device *out_dev,
 +					 enum nfp_flower_tun_type tun_type)
 +{
 +	if (netif_is_vxlan(out_dev))
 +		return tun_type == NFP_FL_TUNNEL_VXLAN;
 +
 +	if (netif_is_geneve(out_dev))
 +		return tun_type == NFP_FL_TUNNEL_GENEVE;
 +
 +	return false;
++=======
+ static int
+ nfp_fl_pre_lag(struct nfp_app *app, const struct tc_action *action,
+ 	       struct nfp_fl_payload *nfp_flow, int act_len)
+ {
+ 	size_t act_size = sizeof(struct nfp_fl_pre_lag);
+ 	struct nfp_fl_pre_lag *pre_lag;
+ 	struct net_device *out_dev;
+ 	int err;
+ 
+ 	out_dev = tcf_mirred_dev(action);
+ 	if (!out_dev || !netif_is_lag_master(out_dev))
+ 		return 0;
+ 
+ 	if (act_len + act_size > NFP_FL_MAX_A_SIZ)
+ 		return -EOPNOTSUPP;
+ 
+ 	/* Pre_lag action must be first on action list.
+ 	 * If other actions already exist they need pushed forward.
+ 	 */
+ 	if (act_len)
+ 		memmove(nfp_flow->action_data + act_size,
+ 			nfp_flow->action_data, act_len);
+ 
+ 	pre_lag = (struct nfp_fl_pre_lag *)nfp_flow->action_data;
+ 	err = nfp_flower_lag_populate_pre_action(app, out_dev, pre_lag);
+ 	if (err)
+ 		return err;
+ 
+ 	pre_lag->head.jump_id = NFP_FL_ACTION_OPCODE_PRE_LAG;
+ 	pre_lag->head.len_lw = act_size >> NFP_FL_LW_SIZ;
+ 
+ 	nfp_flow->meta.shortcut = cpu_to_be32(NFP_FL_SC_ACT_NULL);
+ 
+ 	return act_size;
++>>>>>>> 65b7970edf87 (nfp: flower: increase scope of netdev checking functions)
  }
  
  static int
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/action.c
diff --git a/drivers/net/ethernet/netronome/nfp/flower/cmsg.h b/drivers/net/ethernet/netronome/nfp/flower/cmsg.h
index 062d7040a0dc..c9244cbff7cb 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/cmsg.h
+++ b/drivers/net/ethernet/netronome/nfp/flower/cmsg.h
@@ -38,6 +38,7 @@
 #include <linux/skbuff.h>
 #include <linux/types.h>
 #include <net/geneve.h>
+#include <net/vxlan.h>
 
 #include "../nfp_app.h"
 #include "../nfpcore/nfp_cpp.h"
@@ -492,6 +493,32 @@ static inline int nfp_flower_cmsg_get_data_len(struct sk_buff *skb)
 	return skb->len - NFP_FLOWER_CMSG_HLEN;
 }
 
+static inline bool
+nfp_fl_netdev_is_tunnel_type(struct net_device *netdev,
+			     enum nfp_flower_tun_type tun_type)
+{
+	if (netif_is_vxlan(netdev))
+		return tun_type == NFP_FL_TUNNEL_VXLAN;
+	if (netif_is_geneve(netdev))
+		return tun_type == NFP_FL_TUNNEL_GENEVE;
+
+	return false;
+}
+
+static inline bool nfp_fl_is_netdev_to_offload(struct net_device *netdev)
+{
+	if (!netdev->rtnl_link_ops)
+		return false;
+	if (!strcmp(netdev->rtnl_link_ops->kind, "openvswitch"))
+		return true;
+	if (netif_is_vxlan(netdev))
+		return true;
+	if (netif_is_geneve(netdev))
+		return true;
+
+	return false;
+}
+
 struct sk_buff *
 nfp_flower_cmsg_mac_repr_start(struct nfp_app *app, unsigned int num_ports);
 void
diff --git a/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c b/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c
index a32657f30433..8f90df2cd069 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c
@@ -34,7 +34,6 @@
 #include <linux/etherdevice.h>
 #include <linux/inetdevice.h>
 #include <net/netevent.h>
-#include <net/vxlan.h>
 #include <linux/idr.h>
 #include <net/dst_metadata.h>
 #include <net/arp.h>
@@ -212,20 +211,6 @@ void nfp_tunnel_keep_alive(struct nfp_app *app, struct sk_buff *skb)
 	}
 }
 
-static bool nfp_tun_is_netdev_to_offload(struct net_device *netdev)
-{
-	if (!netdev->rtnl_link_ops)
-		return false;
-	if (!strcmp(netdev->rtnl_link_ops->kind, "openvswitch"))
-		return true;
-	if (netif_is_vxlan(netdev))
-		return true;
-	if (netif_is_geneve(netdev))
-		return true;
-
-	return false;
-}
-
 static int
 nfp_flower_xmit_tun_conf(struct nfp_app *app, u8 mtype, u16 plen, void *pdata,
 			 gfp_t flag)
@@ -647,7 +632,7 @@ static void nfp_tun_add_to_mac_offload_list(struct net_device *netdev,
 
 	if (nfp_netdev_is_nfp_repr(netdev))
 		port = nfp_repr_get_port_id(netdev);
-	else if (!nfp_tun_is_netdev_to_offload(netdev))
+	else if (!nfp_fl_is_netdev_to_offload(netdev))
 		return;
 
 	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
@@ -698,7 +683,7 @@ static int nfp_tun_mac_event_handler(struct notifier_block *nb,
 		netdev = netdev_notifier_info_to_dev(ptr);
 
 		/* If non-nfp netdev then free its offload index. */
-		if (nfp_tun_is_netdev_to_offload(netdev))
+		if (nfp_fl_is_netdev_to_offload(netdev))
 			nfp_tun_del_mac_idx(app, netdev->ifindex);
 	} else if (event == NETDEV_UP || event == NETDEV_CHANGEADDR ||
 		   event == NETDEV_REGISTER) {
