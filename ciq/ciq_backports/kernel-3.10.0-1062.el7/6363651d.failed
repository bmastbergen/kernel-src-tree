net/mlx5e: Properly set steering match levels for offloaded TC decap rules

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Properly set steering match levels for offloaded TC decap rules (Alaa Hleihel) [1683975]
Rebuild_FUZZ: 97.22%
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit 6363651d6dd79694d586f4ae68967036dd14bc3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6363651d.failed

The match level computed by the driver gets to be wrong for decap
rules with wildcarded inner packet match such as:

tc filter add dev vxlan_sys_4789 protocol all parent ffff: prio 2 flower
       enc_dst_ip 192.168.0.9 enc_key_id 100 enc_dst_port 4789
       action tunnel_key unset
       action mirred egress redirect dev eth1

The FW errs for a missing matching meta-data indicator for the outer
headers (where we do have a match), and a wrong matching meta-data
indicator for the inner headers (where we don't have a match).

Fix that by taking into account the matching on the tunnel info and
relating the match level of the encapsulated packet to the firmware
inner headers indicator in case of decap.

As for vxlan we mandate a match on the tunnel udp dst port, and in general
we practically madndate a match on the source or dest ip for any IP tunnel,
the fix was done in a minimal manner around the tunnel match parsing code.

Fixes: d708f902989b ('net/mlx5e: Get the required HW match level while parsing TC flow matches')
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Reported-by: Slava Ovsiienko <viacheslavo@mellanox.com>
	Reviewed-by: Jianbo Liu <jianbol@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 6363651d6dd79694d586f4ae68967036dd14bc3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index fbb4f1b36627,043896e13ffa..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -1066,10 -1298,13 +1066,15 @@@ static void parse_vxlan_attr(struct mlx
  	}
  }
  
 -
  static int parse_tunnel_attr(struct mlx5e_priv *priv,
  			     struct mlx5_flow_spec *spec,
++<<<<<<< HEAD
 +			     struct tc_cls_flower_offload *f)
++=======
+ 			     struct tc_cls_flower_offload *f,
+ 			     struct net_device *filter_dev, u8 *match_level)
++>>>>>>> 6363651d6dd7 (net/mlx5e: Properly set steering match levels for offloaded TC decap rules)
  {
 -	struct netlink_ext_ack *extack = f->common.extack;
  	void *headers_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,
  				       outer_headers);
  	void *headers_v = MLX5_ADDR_OF(fte_match_param, spec->match_value,
@@@ -1079,48 -1314,14 +1084,57 @@@
  		skb_flow_dissector_target(f->dissector,
  					  FLOW_DISSECTOR_KEY_ENC_CONTROL,
  					  f->key);
 -	int err = 0;
  
++<<<<<<< HEAD
 +	if (dissector_uses_key(f->dissector, FLOW_DISSECTOR_KEY_ENC_PORTS)) {
 +		struct flow_dissector_key_ports *key =
 +			skb_flow_dissector_target(f->dissector,
 +						  FLOW_DISSECTOR_KEY_ENC_PORTS,
 +						  f->key);
 +		struct flow_dissector_key_ports *mask =
 +			skb_flow_dissector_target(f->dissector,
 +						  FLOW_DISSECTOR_KEY_ENC_PORTS,
 +						  f->mask);
 +		struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 +		struct mlx5e_rep_priv *uplink_rpriv = mlx5_eswitch_get_uplink_priv(esw, REP_ETH);
 +		struct net_device *up_dev = uplink_rpriv->netdev;
 +		struct mlx5e_priv *up_priv = netdev_priv(up_dev);
 +
 +		/* Full udp dst port must be given */
 +		if (memchr_inv(&mask->dst, 0xff, sizeof(mask->dst)))
 +			goto vxlan_match_offload_err;
 +
 +		if (mlx5e_vxlan_lookup_port(up_priv, be16_to_cpu(key->dst)) &&
 +		    MLX5_CAP_ESW(priv->mdev, vxlan_encap_decap))
 +			parse_vxlan_attr(spec, f);
 +		else {
 +			netdev_warn(priv->netdev,
 +				    "%d isn't an offloaded vxlan udp dport\n", be16_to_cpu(key->dst));
 +			return -EOPNOTSUPP;
 +		}
 +
 +		MLX5_SET(fte_match_set_lyr_2_4, headers_c,
 +			 udp_dport, ntohs(mask->dst));
 +		MLX5_SET(fte_match_set_lyr_2_4, headers_v,
 +			 udp_dport, ntohs(key->dst));
 +
 +		MLX5_SET(fte_match_set_lyr_2_4, headers_c,
 +			 udp_sport, ntohs(mask->src));
 +		MLX5_SET(fte_match_set_lyr_2_4, headers_v,
 +			 udp_sport, ntohs(key->src));
 +	} else { /* udp dst port must be given */
 +vxlan_match_offload_err:
 +		netdev_warn(priv->netdev,
 +			    "IP tunnel decap offload supported only for vxlan, must set UDP dport\n");
 +		return -EOPNOTSUPP;
++=======
+ 	err = mlx5e_tc_tun_parse(filter_dev, priv, spec, f,
+ 				 headers_c, headers_v, match_level);
+ 	if (err) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "failed to parse tunnel attributes");
+ 		return err;
++>>>>>>> 6363651d6dd7 (net/mlx5e: Properly set steering match levels for offloaded TC decap rules)
  	}
  
  	if (enc_control->addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {
@@@ -1214,8 -1425,10 +1228,13 @@@
  static int __parse_cls_flower(struct mlx5e_priv *priv,
  			      struct mlx5_flow_spec *spec,
  			      struct tc_cls_flower_offload *f,
++<<<<<<< HEAD
 +			      u8 *match_level)
++=======
+ 			      struct net_device *filter_dev,
+ 			      u8 *match_level, u8 *tunnel_match_level)
++>>>>>>> 6363651d6dd7 (net/mlx5e: Properly set steering match levels for offloaded TC decap rules)
  {
 -	struct netlink_ext_ack *extack = f->common.extack;
  	void *headers_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,
  				       outer_headers);
  	void *headers_v = MLX5_ADDR_OF(fte_match_param, spec->match_value,
@@@ -1263,7 -1477,7 +1282,11 @@@
  		switch (key->addr_type) {
  		case FLOW_DISSECTOR_KEY_IPV4_ADDRS:
  		case FLOW_DISSECTOR_KEY_IPV6_ADDRS:
++<<<<<<< HEAD
 +			if (parse_tunnel_attr(priv, spec, f))
++=======
+ 			if (parse_tunnel_attr(priv, spec, f, filter_dev, tunnel_match_level))
++>>>>>>> 6363651d6dd7 (net/mlx5e: Properly set steering match levels for offloaded TC decap rules)
  				return -EOPNOTSUPP;
  			break;
  		default:
@@@ -1605,11 -1825,12 +1628,15 @@@ static int parse_cls_flower(struct mlx5
  	struct mlx5_core_dev *dev = priv->mdev;
  	struct mlx5_eswitch *esw = dev->priv.eswitch;
  	struct mlx5e_rep_priv *rpriv = priv->ppriv;
+ 	u8 match_level, tunnel_match_level = MLX5_MATCH_NONE;
  	struct mlx5_eswitch_rep *rep;
- 	u8 match_level;
  	int err;
  
++<<<<<<< HEAD
 +	err = __parse_cls_flower(priv, spec, f, &match_level);
++=======
+ 	err = __parse_cls_flower(priv, spec, f, filter_dev, &match_level, &tunnel_match_level);
++>>>>>>> 6363651d6dd7 (net/mlx5e: Properly set steering match levels for offloaded TC decap rules)
  
  	if (!err && (flow->flags & MLX5E_TC_FLOW_ESWITCH)) {
  		rep = rpriv->rep;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 21bc97b70ed9,748ff178a1d6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -241,20 -282,41 +241,28 @@@ enum mlx5_flow_match_level 
  	MLX5_MATCH_L4	= MLX5_INLINE_MODE_TCP_UDP,
  };
  
 -/* current maximum for flow based vport multicasting */
 -#define MLX5_MAX_FLOW_FWD_VPORTS 2
 -
 -enum {
 -	MLX5_ESW_DEST_ENCAP         = BIT(0),
 -	MLX5_ESW_DEST_ENCAP_VALID   = BIT(1),
 -};
 -
  struct mlx5_esw_flow_attr {
  	struct mlx5_eswitch_rep *in_rep;
 +	struct mlx5_eswitch_rep *out_rep;
 +	struct mlx5_core_dev	*out_mdev;
  	struct mlx5_core_dev	*in_mdev;
 -	struct mlx5_core_dev    *counter_dev;
 -
 -	int split_count;
 -	int out_count;
  
  	int	action;
 -	__be16	vlan_proto[MLX5_FS_VLAN_DEPTH];
 -	u16	vlan_vid[MLX5_FS_VLAN_DEPTH];
 -	u8	vlan_prio[MLX5_FS_VLAN_DEPTH];
 -	u8	total_vlan;
 +	__be16	vlan_proto;
 +	u16	vlan_vid;
 +	u8	vlan_prio;
  	bool	vlan_handled;
 -	struct {
 -		u32 flags;
 -		struct mlx5_eswitch_rep *rep;
 -		struct mlx5_core_dev *mdev;
 -		u32 encap_id;
 -	} dests[MLX5_MAX_FLOW_FWD_VPORTS];
 +	u32	encap_id;
  	u32	mod_hdr_id;
  	u8	match_level;
++<<<<<<< HEAD
++=======
+ 	u8	tunnel_match_level;
+ 	struct mlx5_fc *counter;
+ 	u32	chain;
+ 	u16	prio;
+ 	u32	dest_chain;
++>>>>>>> 6363651d6dd7 (net/mlx5e: Properly set steering match levels for offloaded TC decap rules)
  	struct mlx5e_tc_flow_parse_attr *parse_attr;
  };
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 84864631953e..a7e038722948 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@ -104,14 +104,15 @@ mlx5_eswitch_add_offloaded_rule(struct mlx5_eswitch *esw,
 		MLX5_SET_TO_ONES(fte_match_set_misc, misc,
 				 source_eswitch_owner_vhca_id);
 
-	if (attr->match_level == MLX5_MATCH_NONE)
-		spec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS;
-	else
-		spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS |
-					      MLX5_MATCH_MISC_PARAMETERS;
-
-	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_DECAP)
-		spec->match_criteria_enable |= MLX5_MATCH_INNER_HEADERS;
+	spec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS;
+	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_DECAP) {
+		if (attr->tunnel_match_level != MLX5_MATCH_NONE)
+			spec->match_criteria_enable |= MLX5_MATCH_OUTER_HEADERS;
+		if (attr->match_level != MLX5_MATCH_NONE)
+			spec->match_criteria_enable |= MLX5_MATCH_INNER_HEADERS;
+	} else if (attr->match_level != MLX5_MATCH_NONE) {
+		spec->match_criteria_enable |= MLX5_MATCH_OUTER_HEADERS;
+	}
 
 	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
 		flow_act.modify_id = attr->mod_hdr_id;
