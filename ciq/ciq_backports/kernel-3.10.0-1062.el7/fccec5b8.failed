RDMA/nldev: provide detailed MR information

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Steve Wise <swise@opengridcomputing.com>
commit fccec5b89ac61ebe2f353feecd08a16621f2418b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/fccec5b8.failed

Implement the RDMA nldev netlink interface for dumping detailed
MR information.

	Signed-off-by: Steve Wise <swise@opengridcomputing.com>
	Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit fccec5b89ac61ebe2f353feecd08a16621f2418b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/nldev.c
#	drivers/infiniband/core/restrack.c
#	include/rdma/restrack.h
#	include/uapi/rdma/rdma_netlink.h
diff --cc drivers/infiniband/core/nldev.c
index 67368b6847cb,4c6626ecdb99..000000000000
--- a/drivers/infiniband/core/nldev.c
+++ b/drivers/infiniband/core/nldev.c
@@@ -71,6 -73,24 +71,27 @@@ static const struct nla_policy nldev_po
  	[RDMA_NLDEV_ATTR_RES_PID]		= { .type = NLA_U32 },
  	[RDMA_NLDEV_ATTR_RES_KERN_NAME]		= { .type = NLA_NUL_STRING,
  						    .len = TASK_COMM_LEN },
++<<<<<<< HEAD
++=======
+ 	[RDMA_NLDEV_ATTR_RES_CM_ID]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_CM_ID_ENTRY]	= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_PS]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_SRC_ADDR]	= {
+ 			.len = sizeof(struct __kernel_sockaddr_storage) },
+ 	[RDMA_NLDEV_ATTR_RES_DST_ADDR]	= {
+ 			.len = sizeof(struct __kernel_sockaddr_storage) },
+ 	[RDMA_NLDEV_ATTR_RES_CQ]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_CQ_ENTRY]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_CQE]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_USECNT]		= { .type = NLA_U64 },
+ 	[RDMA_NLDEV_ATTR_RES_POLL_CTX]		= { .type = NLA_U8 },
+ 	[RDMA_NLDEV_ATTR_RES_MR]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_MR_ENTRY]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_RKEY]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_LKEY]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_IOVA]		= { .type = NLA_U64 },
+ 	[RDMA_NLDEV_ATTR_RES_MRLEN]		= { .type = NLA_U64 },
++>>>>>>> fccec5b89ac6 (RDMA/nldev: provide detailed MR information)
  };
  
  static int fill_nldev_handle(struct sk_buff *msg, struct ib_device *device)
@@@ -182,6 -202,8 +203,11 @@@ static int fill_res_info(struct sk_buf
  		[RDMA_RESTRACK_PD] = "pd",
  		[RDMA_RESTRACK_CQ] = "cq",
  		[RDMA_RESTRACK_QP] = "qp",
++<<<<<<< HEAD
++=======
+ 		[RDMA_RESTRACK_CM_ID] = "cm_id",
+ 		[RDMA_RESTRACK_MR] = "mr",
++>>>>>>> fccec5b89ac6 (RDMA/nldev: provide detailed MR information)
  	};
  
  	struct rdma_restrack_root *res = &device->res;
@@@ -284,7 -371,76 +310,80 @@@ out
  	return -EMSGSIZE;
  }
  
++<<<<<<< HEAD
 +static int nldev_get_doit(struct sk_buff *skb, struct nlmsghdr *nlh)
++=======
+ static int fill_res_cq_entry(struct sk_buff *msg, struct netlink_callback *cb,
+ 			     struct rdma_restrack_entry *res, uint32_t port)
+ {
+ 	struct ib_cq *cq = container_of(res, struct ib_cq, res);
+ 	struct nlattr *entry_attr;
+ 
+ 	entry_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_RES_CQ_ENTRY);
+ 	if (!entry_attr)
+ 		goto out;
+ 
+ 	if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_CQE, cq->cqe))
+ 		goto err;
+ 	if (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_RES_USECNT,
+ 			      atomic_read(&cq->usecnt), 0))
+ 		goto err;
+ 
+ 	/* Poll context is only valid for kernel CQs */
+ 	if (rdma_is_kernel_res(res) &&
+ 	    nla_put_u8(msg, RDMA_NLDEV_ATTR_RES_POLL_CTX, cq->poll_ctx))
+ 		goto err;
+ 
+ 	if (fill_res_name_pid(msg, res))
+ 		goto err;
+ 
+ 	nla_nest_end(msg, entry_attr);
+ 	return 0;
+ 
+ err:
+ 	nla_nest_cancel(msg, entry_attr);
+ out:
+ 	return -EMSGSIZE;
+ }
+ 
+ static int fill_res_mr_entry(struct sk_buff *msg, struct netlink_callback *cb,
+ 			     struct rdma_restrack_entry *res, uint32_t port)
+ {
+ 	struct ib_mr *mr = container_of(res, struct ib_mr, res);
+ 	struct nlattr *entry_attr;
+ 
+ 	entry_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_RES_MR_ENTRY);
+ 	if (!entry_attr)
+ 		goto out;
+ 
+ 	if (netlink_capable(cb->skb, CAP_NET_ADMIN)) {
+ 		if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_RKEY, mr->rkey))
+ 			goto err;
+ 		if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_LKEY, mr->lkey))
+ 			goto err;
+ 		if (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_RES_IOVA,
+ 				      mr->iova, 0))
+ 			goto err;
+ 	}
+ 
+ 	if (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_RES_MRLEN, mr->length, 0))
+ 		goto err;
+ 
+ 	if (fill_res_name_pid(msg, res))
+ 		goto err;
+ 
+ 	nla_nest_end(msg, entry_attr);
+ 	return 0;
+ 
+ err:
+ 	nla_nest_cancel(msg, entry_attr);
+ out:
+ 	return -EMSGSIZE;
+ }
+ 
+ static int nldev_get_doit(struct sk_buff *skb, struct nlmsghdr *nlh,
+ 			  struct netlink_ext_ack *extack)
++>>>>>>> fccec5b89ac6 (RDMA/nldev: provide detailed MR information)
  {
  	struct nlattr *tb[RDMA_NLDEV_ATTR_MAX];
  	struct ib_device *device;
@@@ -568,6 -726,21 +667,24 @@@ static const struct nldev_fill_res_entr
  		.nldev_cmd = RDMA_NLDEV_CMD_RES_QP_GET,
  		.nldev_attr = RDMA_NLDEV_ATTR_RES_QP,
  	},
++<<<<<<< HEAD
++=======
+ 	[RDMA_RESTRACK_CM_ID] = {
+ 		.fill_res_func = fill_res_cm_id_entry,
+ 		.nldev_cmd = RDMA_NLDEV_CMD_RES_CM_ID_GET,
+ 		.nldev_attr = RDMA_NLDEV_ATTR_RES_CM_ID,
+ 	},
+ 	[RDMA_RESTRACK_CQ] = {
+ 		.fill_res_func = fill_res_cq_entry,
+ 		.nldev_cmd = RDMA_NLDEV_CMD_RES_CQ_GET,
+ 		.nldev_attr = RDMA_NLDEV_ATTR_RES_CQ,
+ 	},
+ 	[RDMA_RESTRACK_MR] = {
+ 		.fill_res_func = fill_res_mr_entry,
+ 		.nldev_cmd = RDMA_NLDEV_CMD_RES_MR_GET,
+ 		.nldev_attr = RDMA_NLDEV_ATTR_RES_MR,
+ 	},
++>>>>>>> fccec5b89ac6 (RDMA/nldev: provide detailed MR information)
  };
  
  static int res_get_common_dumpit(struct sk_buff *skb,
@@@ -710,6 -883,24 +827,27 @@@ static int nldev_res_get_qp_dumpit(stru
  	return res_get_common_dumpit(skb, cb, RDMA_RESTRACK_QP);
  }
  
++<<<<<<< HEAD
++=======
+ static int nldev_res_get_cm_id_dumpit(struct sk_buff *skb,
+ 				      struct netlink_callback *cb)
+ {
+ 	return res_get_common_dumpit(skb, cb, RDMA_RESTRACK_CM_ID);
+ }
+ 
+ static int nldev_res_get_cq_dumpit(struct sk_buff *skb,
+ 				   struct netlink_callback *cb)
+ {
+ 	return res_get_common_dumpit(skb, cb, RDMA_RESTRACK_CQ);
+ }
+ 
+ static int nldev_res_get_mr_dumpit(struct sk_buff *skb,
+ 				   struct netlink_callback *cb)
+ {
+ 	return res_get_common_dumpit(skb, cb, RDMA_RESTRACK_MR);
+ }
+ 
++>>>>>>> fccec5b89ac6 (RDMA/nldev: provide detailed MR information)
  static const struct rdma_nl_cbs nldev_cb_table[RDMA_NLDEV_NUM_OPS] = {
  	[RDMA_NLDEV_CMD_GET] = {
  		.doit = nldev_get_doit,
@@@ -736,6 -927,15 +874,18 @@@
  		 * too.
  		 */
  	},
++<<<<<<< HEAD
++=======
+ 	[RDMA_NLDEV_CMD_RES_CM_ID_GET] = {
+ 		.dump = nldev_res_get_cm_id_dumpit,
+ 	},
+ 	[RDMA_NLDEV_CMD_RES_CQ_GET] = {
+ 		.dump = nldev_res_get_cq_dumpit,
+ 	},
+ 	[RDMA_NLDEV_CMD_RES_MR_GET] = {
+ 		.dump = nldev_res_get_mr_dumpit,
+ 	},
++>>>>>>> fccec5b89ac6 (RDMA/nldev: provide detailed MR information)
  };
  
  void __init nldev_init(void)
diff --cc drivers/infiniband/core/restrack.c
index 08f5acef0a0e,e1d9934d6e81..000000000000
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@@ -40,22 -43,28 +40,41 @@@ EXPORT_SYMBOL(rdma_restrack_count)
  
  static void set_kern_name(struct rdma_restrack_entry *res)
  {
- 	enum rdma_restrack_type type = res->type;
- 	struct ib_qp *qp;
+ 	struct ib_pd *pd;
  
++<<<<<<< HEAD
 +	if (type != RDMA_RESTRACK_QP)
 +		/* PD and CQ types already have this name embedded in */
 +		return;
 +
 +	qp = container_of(res, struct ib_qp, res);
 +	if (!qp->pd) {
 +		WARN_ONCE(true, "XRC QPs are not supported\n");
 +		/* Survive, despite the programmer's error */
 +		res->kern_name = " ";
 +		return;
++=======
+ 	switch (res->type) {
+ 	case RDMA_RESTRACK_QP:
+ 		pd = container_of(res, struct ib_qp, res)->pd;
+ 		if (!pd) {
+ 			WARN_ONCE(true, "XRC QPs are not supported\n");
+ 			/* Survive, despite the programmer's error */
+ 			res->kern_name = " ";
+ 		}
+ 		break;
+ 	case RDMA_RESTRACK_MR:
+ 		pd = container_of(res, struct ib_mr, res)->pd;
+ 		break;
+ 	default:
+ 		/* Other types set kern_name directly */
+ 		pd = NULL;
+ 		break;
++>>>>>>> fccec5b89ac6 (RDMA/nldev: provide detailed MR information)
  	}
  
- 	res->kern_name = qp->pd->res.kern_name;
+ 	if (pd)
+ 		res->kern_name = pd->res.kern_name;
  }
  
  static struct ib_device *res_to_dev(struct rdma_restrack_entry *res)
@@@ -67,6 -76,11 +86,14 @@@
  		return container_of(res, struct ib_cq, res)->device;
  	case RDMA_RESTRACK_QP:
  		return container_of(res, struct ib_qp, res)->device;
++<<<<<<< HEAD
++=======
+ 	case RDMA_RESTRACK_CM_ID:
+ 		return container_of(res, struct rdma_id_private,
+ 				    res)->id.device;
+ 	case RDMA_RESTRACK_MR:
+ 		return container_of(res, struct ib_mr, res)->device;
++>>>>>>> fccec5b89ac6 (RDMA/nldev: provide detailed MR information)
  	default:
  		WARN_ONCE(true, "Wrong resource tracking type %u\n", res->type);
  		return NULL;
@@@ -82,6 -96,10 +109,13 @@@ static bool res_is_user(struct rdma_res
  		return container_of(res, struct ib_cq, res)->uobject;
  	case RDMA_RESTRACK_QP:
  		return container_of(res, struct ib_qp, res)->uobject;
++<<<<<<< HEAD
++=======
+ 	case RDMA_RESTRACK_CM_ID:
+ 		return !res->kern_name;
+ 	case RDMA_RESTRACK_MR:
+ 		return container_of(res, struct ib_mr, res)->pd->uobject;
++>>>>>>> fccec5b89ac6 (RDMA/nldev: provide detailed MR information)
  	default:
  		WARN_ONCE(true, "Wrong resource tracking type %u\n", res->type);
  		return false;
diff --cc include/rdma/restrack.h
index 2cdf8dcf4bdc,a56f4f200277..000000000000
--- a/include/rdma/restrack.h
+++ b/include/rdma/restrack.h
@@@ -29,6 -30,14 +29,17 @@@ enum rdma_restrack_type 
  	 */
  	RDMA_RESTRACK_QP,
  	/**
++<<<<<<< HEAD
++=======
+ 	 * @RDMA_RESTRACK_CM_ID: Connection Manager ID (CM_ID)
+ 	 */
+ 	RDMA_RESTRACK_CM_ID,
+ 	/**
+ 	 * @RDMA_RESTRACK_MR: Memory Region (MR)
+ 	 */
+ 	RDMA_RESTRACK_MR,
+ 	/**
++>>>>>>> fccec5b89ac6 (RDMA/nldev: provide detailed MR information)
  	 * @RDMA_RESTRACK_MAX: Last entry, used for array dclarations
  	 */
  	RDMA_RESTRACK_MAX
diff --cc include/uapi/rdma/rdma_netlink.h
index b90c8cd4c303,6d9ec38e3af0..000000000000
--- a/include/uapi/rdma/rdma_netlink.h
+++ b/include/uapi/rdma/rdma_netlink.h
@@@ -237,6 -238,12 +237,15 @@@ enum rdma_nldev_command 
  
  	RDMA_NLDEV_CMD_RES_QP_GET, /* can dump */
  
++<<<<<<< HEAD
++=======
+ 	RDMA_NLDEV_CMD_RES_CM_ID_GET, /* can dump */
+ 
+ 	RDMA_NLDEV_CMD_RES_CQ_GET, /* can dump */
+ 
+ 	RDMA_NLDEV_CMD_RES_MR_GET, /* can dump */
+ 
++>>>>>>> fccec5b89ac6 (RDMA/nldev: provide detailed MR information)
  	RDMA_NLDEV_NUM_OPS
  };
  
@@@ -349,6 -356,31 +358,34 @@@ enum rdma_nldev_attr 
  	 */
  	RDMA_NLDEV_ATTR_RES_KERN_NAME,		/* string */
  
++<<<<<<< HEAD
++=======
+ 	RDMA_NLDEV_ATTR_RES_CM_ID,		/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_CM_ID_ENTRY,	/* nested table */
+ 	/*
+ 	 * rdma_cm_id port space.
+ 	 */
+ 	RDMA_NLDEV_ATTR_RES_PS,			/* u32 */
+ 	/*
+ 	 * Source and destination socket addresses
+ 	 */
+ 	RDMA_NLDEV_ATTR_RES_SRC_ADDR,		/* __kernel_sockaddr_storage */
+ 	RDMA_NLDEV_ATTR_RES_DST_ADDR,		/* __kernel_sockaddr_storage */
+ 
+ 	RDMA_NLDEV_ATTR_RES_CQ,			/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_CQ_ENTRY,		/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_CQE,		/* u32 */
+ 	RDMA_NLDEV_ATTR_RES_USECNT,		/* u64 */
+ 	RDMA_NLDEV_ATTR_RES_POLL_CTX,		/* u8 */
+ 
+ 	RDMA_NLDEV_ATTR_RES_MR,			/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_MR_ENTRY,		/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_RKEY,		/* u32 */
+ 	RDMA_NLDEV_ATTR_RES_LKEY,		/* u32 */
+ 	RDMA_NLDEV_ATTR_RES_IOVA,		/* u64 */
+ 	RDMA_NLDEV_ATTR_RES_MRLEN,		/* u64 */
+ 
++>>>>>>> fccec5b89ac6 (RDMA/nldev: provide detailed MR information)
  	RDMA_NLDEV_ATTR_MAX
  };
  #endif /* _UAPI_RDMA_NETLINK_H */
* Unmerged path drivers/infiniband/core/nldev.c
* Unmerged path drivers/infiniband/core/restrack.c
diff --git a/drivers/infiniband/core/uverbs_cmd.c b/drivers/infiniband/core/uverbs_cmd.c
index 1ce350a12135..585c27cdba9c 100644
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@ -684,6 +684,8 @@ ssize_t ib_uverbs_reg_mr(struct ib_uverbs_file *file,
 	mr->pd      = pd;
 	mr->uobject = uobj;
 	atomic_inc(&pd->usecnt);
+	mr->res.type = RDMA_RESTRACK_MR;
+	rdma_restrack_add(&mr->res);
 
 	uobj->object = mr;
 
diff --git a/drivers/infiniband/core/verbs.c b/drivers/infiniband/core/verbs.c
index 71516a548ce6..711c3cefd64b 100644
--- a/drivers/infiniband/core/verbs.c
+++ b/drivers/infiniband/core/verbs.c
@@ -1623,6 +1623,7 @@ int ib_dereg_mr(struct ib_mr *mr)
 	struct ib_pd *pd = mr->pd;
 	int ret;
 
+	rdma_restrack_del(&mr->res);
 	ret = mr->device->dereg_mr(mr);
 	if (!ret)
 		atomic_dec(&pd->usecnt);
@@ -1659,6 +1660,8 @@ struct ib_mr *ib_alloc_mr(struct ib_pd *pd,
 		mr->uobject = NULL;
 		atomic_inc(&pd->usecnt);
 		mr->need_inval = false;
+		mr->res.type = RDMA_RESTRACK_MR;
+		rdma_restrack_add(&mr->res);
 	}
 
 	return mr;
diff --git a/include/rdma/ib_verbs.h b/include/rdma/ib_verbs.h
index c5984de2d83a..88189e699c9f 100644
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@ -1758,6 +1758,11 @@ struct ib_mr {
 		struct ib_uobject	*uobject;	/* user */
 		struct list_head	qp_entry;	/* FR */
 	};
+
+	/*
+	 * Implementation details of the RDMA core, don't use in drivers:
+	 */
+	struct rdma_restrack_entry res;
 };
 
 struct ib_mw {
* Unmerged path include/rdma/restrack.h
* Unmerged path include/uapi/rdma/rdma_netlink.h
