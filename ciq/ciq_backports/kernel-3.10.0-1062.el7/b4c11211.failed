powerpc: Fix bad inline asm constraint in create_zero_mask()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [powerpc] Fix bad inline asm constraint in create_zero_mask() (Yauheni Kaliuta) [1657284]
Rebuild_FUZZ: 91.89%
commit-author Anton Blanchard <anton@samba.org>
commit b4c112114aab9aff5ed4568ca5e662bb02cdfe74
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/b4c11211.failed

In create_zero_mask() we have:

	addi	%1,%2,-1
	andc	%1,%1,%2
	popcntd	%0,%1

using the "r" constraint for %2. r0 is a valid register in the "r" set,
but addi X,r0,X turns it into an li:

	li	r7,-1
	andc	r7,r7,r0
	popcntd	r4,r7

Fix this by using the "b" constraint, for which r0 is not a valid
register.

This was found with a kernel build using gcc trunk, narrowed down to
when -frename-registers was enabled at -O2. It is just luck however
that we aren't seeing this on older toolchains.

Thanks to Segher for working with me to find this issue.

	Cc: stable@vger.kernel.org
Fixes: d0cebfa650a0 ("powerpc: word-at-a-time optimization for 64-bit Little Endian")
	Signed-off-by: Anton Blanchard <anton@samba.org>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit b4c112114aab9aff5ed4568ca5e662bb02cdfe74)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/word-at-a-time.h
diff --cc arch/powerpc/include/asm/word-at-a-time.h
index 9a5c928bb3c6,4afe66aa1400..000000000000
--- a/arch/powerpc/include/asm/word-at-a-time.h
+++ b/arch/powerpc/include/asm/word-at-a-time.h
@@@ -40,8 -40,66 +40,64 @@@ static inline bool has_zero(unsigned lo
  	return (val + c->high_bits) & ~rhs;
  }
  
 -static inline unsigned long zero_bytemask(unsigned long mask)
 -{
 -	return ~1ul << __fls(mask);
 -}
 -
  #else
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_64BIT
+ 
+ /* unused */
+ struct word_at_a_time {
+ };
+ 
+ #define WORD_AT_A_TIME_CONSTANTS { }
+ 
+ /* This will give us 0xff for a NULL char and 0x00 elsewhere */
+ static inline unsigned long has_zero(unsigned long a, unsigned long *bits, const struct word_at_a_time *c)
+ {
+ 	unsigned long ret;
+ 	unsigned long zero = 0;
+ 
+ 	asm("cmpb %0,%1,%2" : "=r" (ret) : "r" (a), "r" (zero));
+ 	*bits = ret;
+ 
+ 	return ret;
+ }
+ 
+ static inline unsigned long prep_zero_mask(unsigned long a, unsigned long bits, const struct word_at_a_time *c)
+ {
+ 	return bits;
+ }
+ 
+ /* Alan Modra's little-endian strlen tail for 64-bit */
+ static inline unsigned long create_zero_mask(unsigned long bits)
+ {
+ 	unsigned long leading_zero_bits;
+ 	long trailing_zero_bit_mask;
+ 
+ 	asm("addi	%1,%2,-1\n\t"
+ 	    "andc	%1,%1,%2\n\t"
+ 	    "popcntd	%0,%1"
+ 		: "=r" (leading_zero_bits), "=&r" (trailing_zero_bit_mask)
+ 		: "b" (bits));
+ 
+ 	return leading_zero_bits;
+ }
+ 
+ static inline unsigned long find_zero(unsigned long mask)
+ {
+ 	return mask >> 3;
+ }
+ 
+ /* This assumes that we never ask for an all 1s bitmask */
+ static inline unsigned long zero_bytemask(unsigned long mask)
+ {
+ 	return (1UL << mask) - 1;
+ }
+ 
+ #else	/* 32-bit case */
+ 
++>>>>>>> b4c112114aab (powerpc: Fix bad inline asm constraint in create_zero_mask())
  struct word_at_a_time {
  	const unsigned long one_bits, high_bits;
  };
* Unmerged path arch/powerpc/include/asm/word-at-a-time.h
