IB/hfi1: Eliminate races in the SDMA send error path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Michael J. Ruhl <michael.j.ruhl@intel.com>
commit a0e0cb82804a6a21d9067022c2dfdf80d11da429
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a0e0cb82.failed

pq_update() can only be called in two places: from the completion
function when the complete (npkts) sequence of packets has been
submitted and processed, or from setup function if a subset of the
packets were submitted (i.e. the error path).

Currently both paths can call pq_update() if an error occurrs.  This
race will cause the n_req value to go negative, hanging file_close(),
or cause a crash by freeing the txlist more than once.

Several variables are used to determine SDMA send state.  Most of
these are unnecessary, and have code inspectible races between the
setup function and the completion function, in both the send path and
the error path.

The request 'status' value can be set by the setup or by the
completion function.  This is code inspectibly racy.  Since the status
is not needed in the completion code or by the caller it has been
removed.

The request 'done' value races between usage by the setup and the
completion function.  The completion function does not need this.
When the number of processed packets matches npkts, it is done.

The 'has_error' value races between usage of the setup and the
completion function.  This can cause incorrect error handling and leave
the n_req in an incorrect value (i.e. negative).

Simplify the code by removing all of the unneeded state checks and
variables.

Clean up iovs node when it is freed.

Eliminate race conditions in the error path:

If all packets are submitted, the completion handler will set the
completion status correctly (ok or aborted).

If all packets are not submitted, the caller must wait until the
submitted packets have completed, and then set the completion status.

These two change eliminate the race condition in the error path.

	Reviewed-by: Mitko Haralanov <mitko.haralanov@intel.com>
	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Signed-off-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit a0e0cb82804a6a21d9067022c2dfdf80d11da429)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/user_sdma.c
diff --cc drivers/infiniband/hw/hfi1/user_sdma.c
index 3d0dc7ab45d1,9f471672e2d5..000000000000
--- a/drivers/infiniband/hw/hfi1/user_sdma.c
+++ b/drivers/infiniband/hw/hfi1/user_sdma.c
@@@ -588,14 -583,8 +583,19 @@@ int hfi1_user_sdma_process_request(stru
  	while (req->seqsubmitted != req->info.npkts) {
  		ret = user_sdma_send_pkts(req, pcount);
  		if (ret < 0) {
++<<<<<<< HEAD
 +			if (ret != -EBUSY) {
 +				req->status = ret;
 +				WRITE_ONCE(req->has_error, 1);
 +				if (ACCESS_ONCE(req->seqcomp) ==
 +				    req->seqsubmitted - 1)
 +					goto free_req;
 +				return ret;
 +			}
++=======
+ 			if (ret != -EBUSY)
+ 				goto free_req;
++>>>>>>> a0e0cb82804a (IB/hfi1: Eliminate races in the SDMA send error path)
  			wait_event_interruptible_timeout(
  				pq->busy.wait_dma,
  				(pq->state == SDMA_PKT_Q_ACTIVE),
@@@ -1395,27 -1397,14 +1408,36 @@@ static void user_sdma_txreq_cb(struct s
  
  	req->seqcomp = tx->seqnum;
  	kmem_cache_free(pq->txreq_cache, tx);
- 	tx = NULL;
  
++<<<<<<< HEAD
 +	idx = req->info.comp_idx;
 +	if (req->status == -1 && status == SDMA_TXREQ_S_OK) {
 +		if (req->seqcomp == req->info.npkts - 1) {
 +			req->status = 0;
 +			user_sdma_free_request(req, false);
 +			pq_update(pq);
 +			set_comp_state(pq, cq, idx, COMPLETE, 0);
 +		}
 +	} else {
 +		if (status != SDMA_TXREQ_S_OK)
 +			req->status = status;
 +		if (req->seqcomp == (ACCESS_ONCE(req->seqsubmitted) - 1) &&
 +		    (READ_ONCE(req->done) ||
 +		     READ_ONCE(req->has_error))) {
 +			user_sdma_free_request(req, false);
 +			pq_update(pq);
 +			set_comp_state(pq, cq, idx, ERROR, req->status);
 +		}
 +	}
++=======
+ 	/* sequence isn't complete?  We are done */
+ 	if (req->seqcomp != req->info.npkts - 1)
+ 		return;
+ 
+ 	user_sdma_free_request(req, false);
+ 	set_comp_state(pq, cq, req->info.comp_idx, state, status);
+ 	pq_update(pq);
++>>>>>>> a0e0cb82804a (IB/hfi1: Eliminate races in the SDMA send error path)
  }
  
  static inline void pq_update(struct hfi1_user_sdma_pkt_q *pq)
* Unmerged path drivers/infiniband/hw/hfi1/user_sdma.c
diff --git a/drivers/infiniband/hw/hfi1/user_sdma.h b/drivers/infiniband/hw/hfi1/user_sdma.h
index d2bc77f75253..0ae06456c868 100644
--- a/drivers/infiniband/hw/hfi1/user_sdma.h
+++ b/drivers/infiniband/hw/hfi1/user_sdma.h
@@ -205,8 +205,6 @@ struct user_sdma_request {
 	/* Writeable fields shared with interrupt */
 	u64 seqcomp ____cacheline_aligned_in_smp;
 	u64 seqsubmitted;
-	/* status of the last txreq completed */
-	int status;
 
 	/* Send side fields */
 	struct list_head txps ____cacheline_aligned_in_smp;
@@ -228,7 +226,6 @@ struct user_sdma_request {
 	u16 tididx;
 	/* progress index moving along the iovs array */
 	u8 iov_idx;
-	u8 done;
 	u8 has_error;
 
 	struct user_sdma_iovec iovs[MAX_VECTORS_PER_REQ];
