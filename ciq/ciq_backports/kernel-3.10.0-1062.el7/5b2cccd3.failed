ovl: disambiguate ovl_encode_fh()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 5b2cccd32c668de6bd1979545184cd7f0260f053
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/5b2cccd3.failed

Rename ovl_encode_fh() to ovl_encode_real_fh() to differentiate from the
exportfs function ovl_encode_inode_fh() and change the latter to
ovl_encode_fh() to match the exportfs method name.

Rename ovl_decode_fh() to ovl_decode_real_fh() for consistency.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 5b2cccd32c668de6bd1979545184cd7f0260f053)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
#	fs/overlayfs/export.c
#	fs/overlayfs/namei.c
#	fs/overlayfs/overlayfs.h
diff --cc fs/overlayfs/copy_up.c
index 5bfbfc122918,8bede0742619..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -265,7 -232,7 +265,11 @@@ int ovl_set_attr(struct dentry *upperde
  	return err;
  }
  
++<<<<<<< HEAD
 +struct ovl_fh *ovl_encode_fh(struct dentry *lower, bool is_upper)
++=======
+ struct ovl_fh *ovl_encode_real_fh(struct dentry *real, bool is_upper)
++>>>>>>> 5b2cccd32c66 (ovl: disambiguate ovl_encode_fh())
  {
  	struct ovl_fh *fh;
  	int fh_type, fh_len, dwords;
diff --cc fs/overlayfs/namei.c
index bc8556692f97,24bd387321d1..000000000000
--- a/fs/overlayfs/namei.c
+++ b/fs/overlayfs/namei.c
@@@ -148,16 -180,11 +148,20 @@@ invalid
  	goto out;
  }
  
++<<<<<<< HEAD
 +static struct dentry *ovl_get_origin(struct dentry *dentry,
 +				     struct vfsmount *mnt)
++=======
+ struct dentry *ovl_decode_real_fh(struct ovl_fh *fh, struct vfsmount *mnt)
++>>>>>>> 5b2cccd32c66 (ovl: disambiguate ovl_encode_fh())
  {
 -	struct dentry *real;
 +	struct dentry *origin = NULL;
 +	struct ovl_fh *fh = ovl_get_origin_fh(dentry);
  	int bytes;
  
 +	if (IS_ERR_OR_NULL(fh))
 +		return (struct dentry *)fh;
 +
  	/*
  	 * Make sure that the stored uuid matches the uuid of the lower
  	 * layer where file handle will be decoded.
@@@ -301,13 -325,8 +305,18 @@@ static int ovl_check_origin(struct dent
  	struct dentry *origin = NULL;
  	int i;
  
++<<<<<<< HEAD
 +
 +	for (i = 0; i < numlower; i++) {
 +		mnt = lowerstack[i].mnt;
 +		origin = ovl_get_origin(upperdentry, mnt);
 +		if (IS_ERR(origin))
 +			return PTR_ERR(origin);
 +
++=======
+ 	for (i = 0; i < ofs->numlower; i++) {
+ 		origin = ovl_decode_real_fh(fh, ofs->lower_layers[i].mnt);
++>>>>>>> 5b2cccd32c66 (ovl: disambiguate ovl_encode_fh())
  		if (origin)
  			break;
  	}
@@@ -365,7 -424,7 +374,11 @@@ int ovl_verify_origin(struct dentry *de
  	struct ovl_fh *fh;
  	int err;
  
++<<<<<<< HEAD
 +	fh = ovl_encode_fh(origin, is_upper);
++=======
+ 	fh = ovl_encode_real_fh(real, is_upper);
++>>>>>>> 5b2cccd32c66 (ovl: disambiguate ovl_encode_fh())
  	err = PTR_ERR(fh);
  	if (IS_ERR(fh))
  		goto fail;
@@@ -387,6 -447,41 +400,44 @@@ fail
  	goto out;
  }
  
++<<<<<<< HEAD
++=======
+ /* Get upper dentry from index */
+ struct dentry *ovl_index_upper(struct ovl_fs *ofs, struct dentry *index)
+ {
+ 	struct ovl_fh *fh;
+ 	struct dentry *upper;
+ 
+ 	if (!d_is_dir(index))
+ 		return dget(index);
+ 
+ 	fh = ovl_get_fh(index, OVL_XATTR_UPPER);
+ 	if (IS_ERR_OR_NULL(fh))
+ 		return ERR_CAST(fh);
+ 
+ 	upper = ovl_decode_real_fh(fh, ofs->upper_mnt);
+ 	kfree(fh);
+ 
+ 	if (IS_ERR_OR_NULL(upper))
+ 		return upper ?: ERR_PTR(-ESTALE);
+ 
+ 	if (!d_is_dir(upper)) {
+ 		pr_warn_ratelimited("overlayfs: invalid index upper (%pd2, upper=%pd2).\n",
+ 				    index, upper);
+ 		dput(upper);
+ 		return ERR_PTR(-EIO);
+ 	}
+ 
+ 	return upper;
+ }
+ 
+ /* Is this a leftover from create/whiteout of directory index entry? */
+ static bool ovl_is_temp_index(struct dentry *index)
+ {
+ 	return index->d_name.name[0] == '#';
+ }
+ 
++>>>>>>> 5b2cccd32c66 (ovl: disambiguate ovl_encode_fh())
  /*
   * Verify that an index entry name matches the origin file handle stored in
   * OVL_XATTR_ORIGIN and that origin file handle can be decoded to lower path.
@@@ -476,11 -625,10 +527,11 @@@ fail
   */
  int ovl_get_index_name(struct dentry *origin, struct qstr *name)
  {
 -	struct ovl_fh *fh;
  	int err;
 +	struct ovl_fh *fh;
 +	char *n, *s;
  
- 	fh = ovl_encode_fh(origin, false);
+ 	fh = ovl_encode_real_fh(origin, false);
  	if (IS_ERR(fh))
  		return PTR_ERR(fh);
  
diff --cc fs/overlayfs/overlayfs.h
index 403c48960f89,dd6c10e5a7db..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -247,15 -265,35 +247,26 @@@ static inline bool ovl_is_impuredir(str
  
  
  /* namei.c */
++<<<<<<< HEAD
 +int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
 +		      struct dentry *origin, bool is_upper, bool set);
 +int ovl_verify_index(struct dentry *index, struct path *lowerstack,
 +		     unsigned int numlower);
++=======
+ int ovl_check_fh_len(struct ovl_fh *fh, int fh_len);
+ struct dentry *ovl_decode_real_fh(struct ovl_fh *fh, struct vfsmount *mnt);
+ int ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh,
+ 			struct dentry *upperdentry, struct ovl_path **stackp);
+ int ovl_verify_set_fh(struct dentry *dentry, const char *name,
+ 		      struct dentry *real, bool is_upper, bool set);
+ struct dentry *ovl_index_upper(struct ovl_fs *ofs, struct dentry *index);
+ int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);
++>>>>>>> 5b2cccd32c66 (ovl: disambiguate ovl_encode_fh())
  int ovl_get_index_name(struct dentry *origin, struct qstr *name);
 -struct dentry *ovl_get_index_fh(struct ovl_fs *ofs, struct ovl_fh *fh);
 -struct dentry *ovl_lookup_index(struct ovl_fs *ofs, struct dentry *upper,
 -				struct dentry *origin, bool verify);
  int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 -struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 -			  unsigned int flags);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
  bool ovl_lower_positive(struct dentry *dentry);
  
 -static inline int ovl_verify_origin(struct dentry *upper,
 -				    struct dentry *origin, bool set)
 -{
 -	return ovl_verify_set_fh(upper, OVL_XATTR_ORIGIN, origin, false, set);
 -}
 -
 -static inline int ovl_verify_upper(struct dentry *index,
 -				    struct dentry *upper, bool set)
 -{
 -	return ovl_verify_set_fh(index, OVL_XATTR_UPPER, upper, true, set);
 -}
 -
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
  int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list);
@@@ -322,4 -361,9 +333,13 @@@ int ovl_copy_up(struct dentry *dentry)
  int ovl_copy_up_flags(struct dentry *dentry, int flags);
  int ovl_copy_xattr(struct dentry *old, struct dentry *new);
  int ovl_set_attr(struct dentry *upper, struct kstat *stat);
++<<<<<<< HEAD
 +struct ovl_fh *ovl_encode_fh(struct dentry *lower, bool is_upper);
++=======
+ struct ovl_fh *ovl_encode_real_fh(struct dentry *real, bool is_upper);
+ int ovl_set_origin(struct dentry *dentry, struct dentry *lower,
+ 		   struct dentry *upper);
+ 
+ /* export.c */
+ extern const struct export_operations ovl_export_operations;
++>>>>>>> 5b2cccd32c66 (ovl: disambiguate ovl_encode_fh())
* Unmerged path fs/overlayfs/export.c
* Unmerged path fs/overlayfs/copy_up.c
* Unmerged path fs/overlayfs/export.c
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/overlayfs.h
